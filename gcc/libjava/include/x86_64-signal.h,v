head	1.1;
branch	1.1.101;
access;
symbols
	MIRBSD_10_BASE:1.1.101.2
	MIRBSD_9_BASE:1.1.101.2
	gcc-3_4_6:1.1.101.2
	MIRBSD_8:1.1.101.1.0.2
	MIRBSD_8_BASE:1.1.101.1
	gcc-3_4-20051206:1.1.101.1
	gcc-3_4-20051115:1.1.101.1
	gcc-3_4-20050823:1.1.101.1
	FSF:1.1.101;
locks; strict;
comment	@ * @;


1.1
date	2005.03.21.12.07.50;	author tg;	state Exp;
branches
	1.1.101.1;
next	;

1.1.101.1
date	2005.03.21.12.07.50;	author tg;	state Exp;
branches;
next	1.1.101.2;

1.1.101.2
date	2006.03.27.10.38.26;	author tg;	state Exp;
branches;
next	;
commitid	1004427C017452A9C05;


desc
@@


1.1
log
@Initial revision
@
text
@// x86_64-signal.h - Catch runtime signals and turn them into exceptions
// on an x86_64 based GNU/Linux system.

/* Copyright (C) 2003  Free Software Foundation

   This file is part of libgcj.

This software is copyrighted work licensed under the terms of the
Libgcj License.  Please consult the file "LIBGCJ_LICENSE" for
details.  */


#ifdef __x86_64__

#ifndef JAVA_SIGNAL_H
#define JAVA_SIGNAL_H 1

#include <signal.h>
#include <sys/syscall.h>

#define HANDLE_SEGV 1

#define SIGNAL_HANDLER(_name)	\
static void _Jv_##_name (int, siginfo_t *, void *_p)

extern "C" 
{
  struct kernel_sigaction 
  {
    void (*k_sa_sigaction)(int,siginfo_t *,void *);
    unsigned long k_sa_flags;
    void (*k_sa_restorer) (void);
    sigset_t k_sa_mask;
  };
}

#define MAKE_THROW_FRAME(_exception)					     \
do									     \
{									     \
  /* Advance the program counter so that it is after the start of the	     \
     instruction:  the x86_64 exception handler expects			     \
     the PC to point to the instruction after a call. */		     \
  struct ucontext *_uc = (struct ucontext *)_p;				     \
  volatile struct sigcontext *_sc = (struct sigcontext *) &_uc->uc_mcontext; \
  _sc->rip += 2;							     \
}									     \
while (0)

#define RESTORE(name, syscall) RESTORE2 (name, syscall)
#define RESTORE2(name, syscall)			\
asm						\
  (						\
   ".byte 0  # Yes, this really is necessary\n" \
   ".align 16\n"				\
   "__" #name ":\n"				\
   "	movq $" #syscall ", %rax\n"		\
   "	syscall\n"				\
   );

/* The return code for realtime-signals.  */
RESTORE (restore_rt, __NR_rt_sigreturn)
static void restore_rt (void) asm ("__restore_rt");

#define INIT_SEGV						\
do								\
  {								\
    struct kernel_sigaction act;				\
    act.k_sa_sigaction = _Jv_catch_segv;			\
    sigemptyset (&act.k_sa_mask);				\
    act.k_sa_flags = SA_SIGINFO|0x4000000;			\
    act.k_sa_restorer = restore_rt;				\
    syscall (SYS_rt_sigaction, SIGSEGV, &act, NULL, _NSIG / 8);	\
  }								\
while (0)  

/* We use syscall(SYS_rt_sigaction) in INIT_SEGV instead of
 * sigaction() because on some systems the pthreads wrappers for
 * signal handlers are not compiled with unwind information, so it's
 * not possible to unwind through them.  This is a problem that will
 * go away if all systems ever have pthreads libraries that are
 * compiled with unwind info.  */

#endif /* JAVA_SIGNAL_H */

#else /* __x86_64__ */

/* This is for the 32-bit subsystem on on x86-64.  */

#define sigcontext_struct sigcontext
#include <java-signal-aux.h>

#endif /* __x86_64__ */
@


1.1.101.1
log
@Import the GNU Compiler Collection 3.4-stable
from gcc-3.4-20050318.tar.bz2 after having
* all top-level non-directories (files)
  - except config.if
and these directories completely:
* INSTALL
* boehm-gc/Mac_files
* boehm-gc/cord
* boehm-gc/doc
* boehm-gc/tests
* contrib
  - except texi2pod.pl
* gcc/f
* gcc/po
* gcc/testsuite
* gcc/treelang
* include
* intl
* libf2c
* libffi/testsuite
* libiberty
* libjava/testsuite
* libstdc++-v3/docs
* libstdc++-v3/po
* libstdc++-v3/scripts
* libstdc++-v3/testsuite
* maintainer-scripts
* zlib
removed before importing.
@
text
@@


1.1.101.2
log
@Update to gcc 3.4.6-RELEASE (branch closed after release, thus...)
List of deleted files and directories taken 1:1 from the commit message
for revision 1.1.101.1 of /cvs/gcc/config.if,v (2005-03-21 12:04:22)
@
text
@a52 1
   ".text\n"					\
@

