head	1.1;
branch	1.1.101;
access;
symbols
	MIRBSD_10_BASE:1.1.101.1
	MIRBSD_9_BASE:1.1.101.1
	gcc-3_4_6:1.1.101.1
	MIRBSD_8:1.1.101.1.0.2
	MIRBSD_8_BASE:1.1.101.1
	gcc-3_4-20051206:1.1.101.1
	gcc-3_4-20051115:1.1.101.1
	gcc-3_4-20050823:1.1.101.1
	FSF:1.1.101;
locks; strict;
comment	@ * @;


1.1
date	2005.03.21.12.07.50;	author tg;	state Exp;
branches
	1.1.101.1;
next	;

1.1.101.1
date	2005.03.21.12.07.50;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@// s390-signal.h - Catch runtime signals and turn them into exceptions
// on an s390 based Linux system.

/* Copyright (C) 2002  Free Software Foundation

   This file is part of libgcj.

This software is copyrighted work licensed under the terms of the
Libgcj License.  Please consult the file "LIBGCJ_LICENSE" for
details.  */


#ifndef JAVA_SIGNAL_H
#define JAVA_SIGNAL_H 1

#include <signal.h>
#include <sys/syscall.h>

#define HANDLE_SEGV 1
#undef HANDLE_FPE

#define SIGNAL_HANDLER(_name)	\
static void _name (int /* _signal */, struct sigcontext _sc)

#define MAKE_THROW_FRAME(_exception)					\
do									\
{									\
  /* Advance the program counter so that it is after the start of the	\
     instruction:  the s390 exception handler expects the PSW to point 	\
     to the instruction after a call. */				\
  _sc.sregs->regs.psw.addr += 2;					\
									\
}									\
while (0)


/* For an explanation why we cannot simply use sigaction to
   install the handlers, see i386-signal.h.  */

/* We use old_kernel_sigaction here because we're calling the kernel
   directly rather than via glibc.  The sigaction structure that the
   syscall uses is a different shape from the one in userland and not
   visible to us in a header file so we define it here.  */

struct old_s390_kernel_sigaction {
	void (*k_sa_handler) (int, struct sigcontext);
	unsigned long k_sa_mask;
	unsigned long k_sa_flags;
	void (*sa_restorer) (void);
};

#define INIT_SEGV					\
do							\
  {							\
    struct old_s390_kernel_sigaction kact;		\
    kact.k_sa_handler = catch_segv;			\
    kact.k_sa_mask = 0;					\
    kact.k_sa_flags = 0;				\
    syscall (SYS_sigaction, SIGSEGV, &kact, NULL);	\
  }							\
while (0)  

#define INIT_FPE						\
do								\
  {								\
    struct old_s390_kernel_sigaction kact;			\
    kact.k_sa_handler = catch_fpe;				\
    kact.k_sa_mask = 0;						\
    kact.k_sa_flags = 0;					\
    syscall (SYS_sigaction, SIGFPE, &kact, NULL);		\
  }								\
while (0)  

#endif /* JAVA_SIGNAL_H */

@


1.1.101.1
log
@Import the GNU Compiler Collection 3.4-stable
from gcc-3.4-20050318.tar.bz2 after having
* all top-level non-directories (files)
  - except config.if
and these directories completely:
* INSTALL
* boehm-gc/Mac_files
* boehm-gc/cord
* boehm-gc/doc
* boehm-gc/tests
* contrib
  - except texi2pod.pl
* gcc/f
* gcc/po
* gcc/testsuite
* gcc/treelang
* include
* intl
* libf2c
* libffi/testsuite
* libiberty
* libjava/testsuite
* libstdc++-v3/docs
* libstdc++-v3/po
* libstdc++-v3/scripts
* libstdc++-v3/testsuite
* maintainer-scripts
* zlib
removed before importing.
@
text
@@
