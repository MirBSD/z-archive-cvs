head	1.1;
branch	1.1.101;
access;
symbols
	MIRBSD_10_BASE:1.1.101.1
	MIRBSD_9_BASE:1.1.101.1
	gcc-3_4_6:1.1.101.1
	MIRBSD_8:1.1.101.1.0.2
	MIRBSD_8_BASE:1.1.101.1
	gcc-3_4-20051206:1.1.101.1
	gcc-3_4-20051115:1.1.101.1
	gcc-3_4-20050823:1.1.101.1
	FSF:1.1.101;
locks; strict;
comment	@// @;


1.1
date	2005.03.21.12.08.48;	author tg;	state Exp;
branches
	1.1.101.1;
next	;

1.1.101.1
date	2005.03.21.12.08.48;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* dwarf2-backtrac.cc - backtrace implementation driven by the dwarf2
 exception unwinder.  */

/* Copyright (C) 2003  Free Software Foundation

   This file is part of libgcj.

This software is copyrighted work licensed under the terms of the
Libgcj License.  Please consult the file "LIBGCJ_LICENSE" for
details.  */

/* Written by David Daney <ddaney@@avtrex.com> */

/*
  Although this in theory could be 'C' instead of C++, saying that it
  is C++ and including jvm.h makes it easier to insure that the proper
  compiler options are used.  There must be unwind tables for
  backtrace because it is on the stack when _Unwind_Backtrace is
  called.  Compiling as C++ insures this.

*/

#include <config.h>

#include <unwind.h>

#include <jvm.h>


extern "C"
{
  int backtrace (void **, int);
}

struct backtrace_state
{
  int skip_count;
  int current_level;
  int max_level;
  void **locations;
};

static _Unwind_Reason_Code
my_trace_fn (struct _Unwind_Context *uc, void *arg)
{

  struct backtrace_state *bs = (struct backtrace_state *) arg;

  if (bs->skip_count)
    {
      bs->skip_count--;
      return _URC_NO_REASON;
    }

  _Unwind_Ptr loc = _Unwind_GetIP (uc);

  if (bs->current_level < bs->max_level)
    bs->locations[bs->current_level++] = (void *) loc;

  if (bs->current_level >= bs->max_level)
    return _URC_END_OF_STACK;
  else
    return _URC_NO_REASON;
}

/*
 * backtrace is defined in (some versions of) libc.  This definition
 * must match so that it can replace the libc version at link time.
 *
 * Fill the locations array with at most len back trace locations.
 *
 * Returns the number of locations actually filled in.
 *
 */
int
backtrace (void **locations, int len)
{
  struct backtrace_state bs;
  bs.skip_count = 1;		/* Don't log the call to backtrace itself. */
  bs.current_level = 0;
  bs.max_level = len;
  bs.locations = locations;

  _Unwind_Backtrace (my_trace_fn, &bs);
  return bs.current_level;
}
@


1.1.101.1
log
@Import the GNU Compiler Collection 3.4-stable
from gcc-3.4-20050318.tar.bz2 after having
* all top-level non-directories (files)
  - except config.if
and these directories completely:
* INSTALL
* boehm-gc/Mac_files
* boehm-gc/cord
* boehm-gc/doc
* boehm-gc/tests
* contrib
  - except texi2pod.pl
* gcc/f
* gcc/po
* gcc/testsuite
* gcc/treelang
* include
* intl
* libf2c
* libffi/testsuite
* libiberty
* libjava/testsuite
* libstdc++-v3/docs
* libstdc++-v3/po
* libstdc++-v3/scripts
* libstdc++-v3/testsuite
* maintainer-scripts
* zlib
removed before importing.
@
text
@@
