head	1.3;
access;
symbols
	gpc-20060325:1.1.111.1 gpc:1.1.111;
locks; strict;
comment	@# @;


1.3
date	2015.10.12.22.33.10;	author tg;	state Exp;
branches;
next	1.2;
commitid	100561C35394083962A;

1.2
date	2012.05.21.21.30.49;	author tg;	state Exp;
branches;
next	1.1;
commitid	1004FBAB3EE0D44F066;

1.1
date	2009.12.27.16.00.55;	author tg;	state Exp;
branches
	1.1.111.1;
next	;
commitid	1004B3784C47C0FC7CB;

1.1.111.1
date	2009.12.27.16.00.55;	author tg;	state Exp;
branches;
next	;
commitid	1004B3784C47C0FC7CB;


desc
@@


1.3
log
@manpage crosslink fixes
@
text
@\input texinfo
@@setfilename gpcs-de.info
@@settitle GNU Pascal Coding Standards (Deutsch)

@@c Copyright (C) 2001-2006 Free Software Foundation, Inc.
@@c
@@c Authors: Frank Heckenbach <frank@@pascal.gnu.de>
@@c          Peter Gerwinski <peter@@gerwinski.de>
@@c          Nicola Girardi <nicola@@g-n-u.de>
@@c          Eike Lange <eike@@@@g-n-u.de>
@@c
@@c Remember to update this when you save:
@@set lastupdate 2006-02-02
@@set lasttranslationupdate 2006-02-02

@@direntry
* Pascal Coding Standards: (gpcs-de).   GNU Pascal Coding Standards (German).
@@end direntry

@@setchapternewpage odd

@@c Put everything in one index (arbitrarily chosen to be the concept index).
@@syncodeindex fn cp
@@syncodeindex ky cp
@@syncodeindex pg cp
@@syncodeindex vr cp

@@ifnottex
GNU Pascal Coding Standards

Copyright (C) 2001-2006 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

@@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission
notice identical to this one except for the removal of this
paragraph (this paragraph not being relevant to the printed manual).
@@end ignore

Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of
a permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for
modified versions, except that this permission notice may be stated
in a translation approved by the copyright holders.
@@end ifnottex

@@titlepage
@@title GNU Pascal Coding Standards (Deutsch)
@@author Nicola Girardi
@@author last updated @@value{lastupdate}
@@page

@@vskip 0pt plus 1filll
Copyright @@copyright{} 2001-2006 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the copyright holders.
@@end titlepage

@@ifnottex
@@node Top
@@top Version

Letzte Änderung @@value{lasttranslationupdate}.
Basierend auf der englischen Version von @@value{lastupdate}.
@@end ifnottex

@@menu
* Vorwort::                   Über die GNU Pascal Coding Standards
* Rechtliches::               Freie Software soll frei bleiben
* Gestaltungsratschläge::     Allgemeine Projektgestaltung
* Verhalten von Programmen::  Wie sich Programme verhalten sollten
* Pascal Programmieren::      Ratschläge zur Gestaltung des Quelltextes
* Dokumentation::             Programme dokumentieren
* Veröffentlichungen::        Der Verlauf der Veröffentlichung
* Glossar::                   Glossar der Worte in diesem Text
* Index::
@@end menu

@@node Vorwort
@@chapter Über die GNU Pascal Coding Standards

Vorwort des Übersetzers:
Dieses Dokument enthält die Übersetzung der
``GNU Pascal Coding Standards''. Einige Worte werden so beibehalten,
wie sie im Englischen geschrieben wurden, weil es meiner Meinung
nach die Lesbarkeit des Textes fördert. Für Fehler in der
Übersetzung bin ich verantwortlich, nicht die ursprünglichen
Autoren. Für Rückfragen zur Übersetzung bin ich erreichbar unter:
Eike Lange @@email{eike@@@@g-n-u.de}. Mein besonderer Dank gilt Roland
Goretzki für seine unermüdliche Arbeit, dieses Dokument vom
Fehlerteufel zu befreien.

Trotz aller Sorgfalt lassen sich Fehler in der Übersetzung nicht
ganz ausschließen. In Konfliktfällen gilt stets das englische
Original. Bitte teilen sie uns eventuelle Diskrepanzen mit, damit
wir sie beheben können.

Die GNU Pascal Coding Standards wurden von einer Gruppe freiwilliger
Helfer des GNU Pascal Projektes entwickelt. Das Ziel dieses
Dokumentes ist es, die GNU Coding Standards um spezifische
Informationen für Pascal-Programmierer zu ergänzen. Die
Informationen in den GNU Coding Standard beziehen sich zu großen
Teilen auf die Programmiersprache C. Gleichsam erklären sie jedoch
viele der Regeln und Prinzipien, die zum Schreiben portabler,
robuster und zuverlässiger Programme nützlich sind. Die meisten
dieser Regeln können mit wenigen Anmerkungen versehen aus dem
Dokument übernommen werden, weswegen sich Referenzen zu den GNU
Coding Standards in diesem Dokument befinden.

Letzte Aktualisierung dieses Dokuments (original): @@value{lastupdate}.

@@cindex Wo man die GPCS findet
@@cindex Download der Coding Standards

Die GNU Pascal Coding Standards sind als Teil der GPC-Distributionen
erhältlich -- in Binärdistributionen als Info-Dateien, in
Quelltext-Distributions auch als Texinfo-Dateien, aus denen sich
weitere Formate wie HTML, PostScript und PDF erzeugen lassen. Eine
HTML-Version befindet sich auch auf der Homepage von GPC,
@@uref{http://www.gnu-pascal.de}.

@@cindex Feedback
@@cindex Beiträge zum Dokument

Berichtigungen oder Vorschläge zu diesem Dokument können Sie direkt
beim Autor einreichen: @@email{eike@@@@g-n-u.de}. Für das
englischsprachige Original wenden Sie sich bitte an die
Dokumentations-Mailingliste des GNU Pascal Compilers,
@@email{gpc-doc@@@@gnu.de}. Da unsere Zeit begrenzt ist, sollten Ihre
Vorschläge den geänderten Text enthalten. Ein ``context diff'' der
Quelldatei im Texinfo-Format ist sehr willkommen, wobei wir einer
einfachen Mail auch nicht abgeneigt sind.

Die folgenden Leute sind die Tyrannen, die ihre Art der
Programmierung anderen auferlegen:
Peter Gerwinski @@samp{peter(at)gerwinski.de}, Frank
Heckenbach @@samp{frank(at)pascal.gnu.de}, Markus Gerwinski
@@samp{markus(at)gerwinski.de}, Dominik Freche
@@samp{dominik.freche(at)gmx.net}, Nicola Girardi
@@samp{nicola(at)g-n-u.de}.

@@node Rechtliches
@@chapter Freie Software soll frei bleiben
@@cindex legal aspects

Dieses Kapitel der GNU Coding Standards beschreibt unter anderem,
wie man sich versichert, daß GNU Software rechtliche
Schwierigkeiten vermeidet. @@xref{Intellectual Property, , , standards}.

@@node Gestaltungsratschläge
@@chapter Allgemeine Projektgestaltung
@@cindex Projektgestaltung

Dieses Kapitel beschäftigt sich mit einigen grundlegenden Themen
zur Gestaltung eines Programmes.

@@menu
* Die Programmiersprache::      Welche Sprache nimmt man
* Pascal und C::                Linken mit C Bibliotheken
* Erweiterungen benutzen::      Das Benutzen von nicht standardisierten
                                Erweiterungen
@@end menu

@@node Die Programmiersprache
@@section Welche Sprache nimmt man
@@cindex Programmiersprache

Wir unterstützen die Idee, daß die Vielfalt der Programmiersprachen
etwas Gutes ist. Verschiedene Programmiersprachen sind nützlich für
verschiedene Aufgaben. Anders als die GNU Coding Standards
(@@pxref{Source Language, , , standards}) wollen wir Sie nicht davon
überzeugen, daß Sie C oder Pascal oder eine andere einzelne
Programmiersprache für alles nutzen sollten.

Wenn Sie das lesen, dann haben Sie sich möglicherweise schon bei
einigen Projekten für Pascal entschieden oder ziehen dies in
Erwägung. Dieses Dokument will Ihnen Vorschläge unterbreiten,
@@emph{wie} Sie ihren Quellcode formatieren, wenn Sie in GNU Pascal
programmieren.

@@node Pascal und C
@@section Linken mit C Bibliotheken
@@cindex Pascal und C
@@cindex Linken mit C Bibliotheken

Sie können eine C-Bibliothek oder eine C-Objektcode-Datei mit Ihrem
Pascal-Programm oder ihrer Unit verlinken. Bitte beachten Sie die
Hinweise im GPC-Handbuch bzgl. der Einzelheiten
(@@pxref{Other Languages, , , gpc}).

@@cindex Wrapper
Wir empfehlen die Verwendung von in C geschriebenen
``Wrapper-Funktionen'' zum Zugriff auf C-Bibliotheken, also kleinen
Funktionen, die i.w. nichts anderes machen, als die Funktionen der
C-Bilbiothek aufzurufen. Der Grund dafür ist die Portabilität. Eines
Tages könnte es Änderungen an der zu linkenden Bibliothek geben, die
direkte @@samp{external}-Deklarationen gefährden. Sie sollten dann
die Wrapper anpassen, so daß Pascal Programme mit jeder Version
dieser Bibliothek zusammenarbeiten.

Bei der Arbeit mit großen Paketen kann es passieren, daß
die Kompatibilität zwischen Versionen einer Library und dem
Programm nicht einfach aufrechterhalten werden kann. In diesem Fall
kann man direkt zur Bibliothek linken, mit der man arbeiten möchte, und
bindet ebenso eine ergänzende Datei hinzu, die ausschließlich der
Versionskontrolle dient.
Hier ein Beispiel:

@@smallexample
#include <foo.h>
#if FOO_MAJOR != 1 || FOO_MINOR != 2
#error The GPC interface for libfoo was only written for libfoo-1.2.
#error Please get libfoo-1.2 or check for a version of the GPC interface
#error matching your version of libfoo.
#endif
@@end smallexample

Beachten Sie die Benutzung von @@samp{!=} anstelle von @@samp{<} oder
@@samp{>}, um eine sehr präzise Versionskontrolle durchzuführen.
Bitte beachten Sie auch, daß dieses Verfahren nur dann anwendbar
ist, wenn es nur eine einzige Implementation dieser Bibliothek gibt,
d.h. es läßt sich mit einer Bibliothek wie GTK, aber nicht mit libc,
libm, curses etc. anwenden.

@@cindex Header-Übersetzung
Ein automatischer Header-Übersetzer ist geplant. Dieses Werkzeug
würde das Schreiben von Wrapperfunktionen überflüssig machen. Das
Schreiben eines solchen Programmes ist eine schwierige Aufgabe, und
niemand ist sich wirklich sicher, ob sie überhaupt durchführbar ist.
Wann ein solches Programm verfügbar sein wird, ist ungewiß.

@@cindex C-Code Compilation
Sie können annehmen, daß der GNU C Compiler benutzt wird, um die Wrapper,
und, allgemein, jedes bißchen C-Code zu übersetzen, das Sie Ihrem
Programm hinzufügen.
Der Grund für diese Annahme ist, daß nur der GNU C Compiler
garantiert, daß alle Konventionen kompatibel zum GNU Pascal Compiler
sind, und das auf jeder Plattform! Der GNU C Compiler und der GNU
Pascal Compiler teilen sich dasselbe Backend. Außerdem wird der GNU
C Compiler immer zusammen mit dem GNU Pascal Compiler erzeugt. Damit
ist @@samp{gcc} überall dort vorhanden, wo auch @@samp{gpc}
installiert ist.

@@node Erweiterungen benutzen
@@section Das Benutzen von nicht standardisierten Erweiterungen
@@cindex Nicht-Standard Erweiterungen

GNU Pascal hat viele Möglichkeiten, die Standard Pascal nicht bietet.
Ob diese Möglichkeiten in einem Programm genutzt werden sollen, ist
eine zu häufig diskutierte Frage.

Auf der einen Seite kann das Benutzen dieser Möglichkeiten zu
effizienteren oder übersichtlicheren Programmen führen. Auf der
anderen Seite ist dadurch nur der GNU Pascal Compiler in der Lage,
diesen Quelltext zu bearbeiten. Dadurch wird das Kompilieren des
Programmes auf Systemen unmöglich, auf denen dieser Compiler nicht
vorhanden ist.

Im allgemeinen ist es das beste, Kompatibilität zu anderen Compilern
oder zum Sprachstandard beizubehalten, @@emph{wenn diese
Kompatibilität einfach zu erhalten ist}. Leider ist dies jedoch
oftmals mit erheblichen Nachteilen verbunden. Als Beispiel dienen
viele eingefügte @@samp{@@{$ifdef@@}}s, um alle nicht-Standard-Compiler
zu versorgen, was den Code schwerer zu lesen, schreiben, testen und
warten macht. Außerdem sind @@samp{@@{$ifdef@@}}s selbst nicht
standardisiert. Sie gewinnen also nicht viel.

Daher schlagen wir vor, sich nicht zu sehr an Fragen der
Kompatibilität stören. Alles am GNU Pascal Compiler ist offen
(Compiler und Laufzeit-System). Das bedeutet, daß das gesamte
Interface bei Bedarf für andere Compiler verfügbar gemacht werden
kann. Dazu können sogar einfach die Quelltexte übernommen werden,
solange die Lizenzvereinbarung erhalten bleibt. Hier erfahren Sie
mehr über die GNU General Public License:
@@uref{http://www.gnu.org/copyleft/gpl.html}. Das ist sinnvoller als
eine Zerstückelung des Codes. Ein (begrenztes) Beispiel dieser
Strategie kann in der @@samp{gpc-bp}-Unit (für Borland Pascal)
gefunden werden. Schauen Sie einfach in das Interface. Es ist
meistens einfach, diese Unit um zusätzliche Features zu erweitern.

Bitte benutzen Sie die folgenden Features nicht, speziell solche
nicht, die lediglich aus Gründen der Rückwärtskompatibilität
eingeführt wurden:

@@itemize @@bullet
@@item
Kommentare der Form @@samp{(* *)} für alte Terminals, wo es die
Zeichen @@samp{@@{} und @@samp{@@}} nicht gab.

@@item
die @@samp{#}-Direktiven und @@samp{//}-Kommentare, wie in C/Delphi.
Wenn eine Datei auch in C genutzt werden muß, so darf sie die
@@samp{#}-Direktiven, die C-Syntax in Conditionalen sowie
@@samp{//}-Kommentare enthalten.
Gegenwärtig gibt es dazu das folgende Beispiel (das kann sich in
Zukunft ändern): @@file{p/rts/constants.h} in den GNU Pascal Compiler
Quellen.

@@item
den Mißbrauch der typisierten Konstanten als Variablen, was eine
seltsame Eigenschaft des Borland Pascal Compilers darstellt.

@@item
Zeichen-Konstanten der Form @@samp{^A}. Benutzen Sie bitte @@samp{#1}
oder @@samp{Chr (1)} stattdessen.

@@item
@@samp{CString}s (außer natürlich für C-Schnittstellen)

@@item
komplizierten Borland Pascal Code wie den folgenden anstelle von
@@samp{WriteStr}:

@@smallexample
Str (Foo, s);
s := 'Hallo ' + s;
@@end smallexample

@@item
die meisten Fälle von @@samp{FillChar} und @@samp{Move}, außer für
Low-Level-Programmierung und wenn es sich auf Zeichen innerhalb
eines Strings bezieht. Das Benutzen von

@@smallexample
FillChar (s, SizeOf (s), 0);
@@end smallexample

um einen String zu leeren ist falsch in GNU Pascal und außerdem
ineffizient, sogar in Borland Pascal. Bitte benutzen Sie folgendes:

@@smallexample
s := '';
@@end smallexample

Dieses Beispiel ändert lediglich das Längenfeld des Strings
@@samp{s}, und leert ihn schon dadurch.

@@item
die meisten Fälle von @@samp{GetMem} und @@samp{FreeMem}, die
normalerweise ein Work-Around für fehlende Schemata in anderen
Compilern sind.

@@item
die meisten Fälle untypisierter Parameter.

@@item
die meisten selbstgemachten dateinamenbezogenen Routinen.
(Falls sie in Borland Pascal geschrieben wurden, so sind
sie zumeist sowieso nur unter DOS anwendbar. Benutzen Sie die
Möglichkeiten der @@samp{GPC}-Unit, um einen portablen Weg
einzuschlagen.)

@@item
Assembler-Code. Außer natürlich in seltenen Fällen, wo es um
die Optimierung von Code geht. Dort sollte er mit Hilfe von
@@samp{@@{$ifdef@@}} (z.B. für den Prozessortyp) eingekapselt
werden. Unterstützen Sie in einem solchen Fall auch bitte
eine reine Pascal-Version dieser Routinen innerhalb des
@@samp{@@{$else@@}}-Teiles. Testen Sie diese Routinen.

@@item
alles, was die @@samp{System}-Unit erfordert.

@@item
Annahmen über Typengrößen.

@@item
Annahmen über ``Endianness''. (Einige Systeme verwenden für die
Anordnung von höher- und niederwertige Bytes eine andere Reihenfolge
als andere Systeme.) [Anm. d. Übersetzers: Die Begriffe ``Little
Endian'' und ``Big Endian'' lassen sich leider nicht direkt
übersetzen. Schauen Sie ins Glossar (@@pxref{Glossar}), um mehr über
diese Begriffe herauszufinden.]

@@item
Bezeichner, die mit einem oder mehreren Unterstrichen (@@samp{_})
beginnen oder enden.

@@item
Units, die nur zur Kompatibilität mit Borland Pascal geschrieben
wurden. (@@pxref{GPC Units, , , gpc}) Die Units @@samp{CRT}
und @@samp{Printer} hingegen dienen sowohl der Kompatibilität
zu Borland Pascal als auch dem allgemeinen Nutzen.

@@end itemize

Die GNU Coding Standards haben interessante Anmerkungen zu
diesem Thema. @@xref{Using Extensions, , , standards}.

@@node Verhalten von Programmen
@@chapter Wie sich Programme verhalten sollten

Dieses Kapitel der GNU Coding Standards beschreibt Konventionen zum
Schreiben stabiler Programme. Außerdem gibt es Richtlinien zur
Ausgabe von Fehlermeldungen, zum Kommandozeilen-Interface
und dazu, wie sich Bibliotheken verhalten sollten.
Bitte lesen Sie auch den entsprechenden Abschnitt der
GNU Coding Standards. @@xref{Program Behavior, , , standards}.

Einige Hinweise zur Pascal Programmierung:

@@cindex Signal-Funktionen
Die in den GNU Coding Standards besprochene Auswahl zwischen
verschiedenen Signal-Funktionen wurde bereits im Run Time System
getroffen, so daß Sie sich nicht mehr darum kümmern müssen.

@@cindex Fehlerabfragen
Ein weiterer Unterschied zu den GNU Coding Standards ist das
Verhalten bei Fehlerabfragen, die einen ``unmöglichen'' Zustand
entdecken. Wir empfehlen, das Programm nicht einfach abzubrechen.
Dies würde implizieren, daß der Anwender ein Programmierer ist,
der den Fehler schon irgendwie findet. Diese Annahme ist nicht
realistisch! Unser Vorschlag ist es deswegen, eine Fehlermeldung
herauszugeben, die es dem Anwender ermöglicht, eine
Fehlerbeschreibung an die Programmierer zu senden.

Die GNU Coding Standards schlagen außerdem vor, jeden
Funktionsaufruf auf Fehlerrückgaben zu überprüfen. Dieser
Vorschlag paßt durchaus zu C, jedoch nicht unbedingt zu Pascal.
In Pascal wird das Abfangen von Fehlern oftmals automatisch
durchgeführt, somit brauchen Sie sich in vielen Fällen nicht
darum zu kümmern. Viele I/O-Routinen geben Ihnen nicht einmal einen
Rückgabewert (beispielsweise @@samp{Reset}). Diejenigen
Fehlerwerte, die zurückgegeben werden, sollten aber auch
überprüft werden.

Sie können die automatischen Fehlerabfragen ausschalten und sich
selber darum kümmern. Tatsächlich ist es so, daß manche Fehler das
Programm mit einer Nachricht abbrechen lassen. Speziell in Units
oder Modulen wollen Sie stattdessen vielleicht den Benutzern eine
Möglichkeit einräumen, die Ursache des Fehlers zu beheben. Um das zu
tun, benutzen Sie bitte den Compiler-Switch @@samp{@@{$I-@@}} und
testen Sie den Wert der Funktion @@samp{IOResult} (@@pxref{IOResult, ,
, gpc}) oder der globalen Fehlervariablen wie @@samp{InOutRes}
(@@pxref{InOutRes, , , gpc}). Beachten Sie bitte, daß I/O-Routinen
sofort zurückkehren, während @@samp{InOutRes} gesetzt ist, so daß es
nicht notwendig ist, nach jeder Operation diesen Wert abzufragen.
Folgendes wird dadurch möglich:

@@smallexample
@@{$local I-@@}
Rewrite (f, 'bla');
WriteLn (f, 'foo');
WriteLn (f, 'bar');
WriteLn (f, 'baz');
Close (f);
@@{$endlocal@@}
if InOutRes <> 0 then
  begin
    WriteLn (StdErr, GetIOErrorMessage);
    @@dots{}
  end;
@@end smallexample

Es kann jedoch nützlich sein, nach @@samp{Rewrite} und anderen
Aufrufe zum Öffnen auf Fehler zu testen, denn dort treten die
meisten Fehler auf, und ein Test macht andere, nachgestellte
Aufrufe oftmals unnötig.

Die GPC-Unit enthält eine Menge Routinen für den Umgang mit
Temporärdateien, Konfigurationsdateien und vielen anderen
dateinamenbezogenen Aufgaben. Der Vorteil beim Gebrauch dieser
Routinen liegt darin, daß sie unter verschiedenen Betriebssystemen
laufen (zum Beispiel DOS und Unix) und daß evtl. dateinamenbezogene
Probleme an einer zentralen Stelle (dem Run Time System)
behoben werden können. Das ist besser, als verschiedene Stellen
im Code entsprechend anzupassen.

Soweit es die Bibliotheken betrifft, raten wir davon ab, jede einzelne
Routine in einer einzigen Datei unterzubringen. Wir hoffen, daß der GNU
Pascal Compiler das eines Tages auf der Ebene des Linkers selber macht.
Gegenwärtig, so glauben wir, ist Programmiererfreundlichkeit sinnvoller
als die Größe der ausführbaren Datei. Außerdem empfehlen wir, auf
Namens-Präfixe zu verzichten. Namenskonflikte können stattdessen
durch qualifizierte Bezeichner (@@samp{UnitName.RoutinenName}) gelöst
werden.

@@node Pascal Programmieren
@@chapter Ratschläge zur Gestaltung des Quelltextes

Dieses Kapitel gibt Ihnen Ratschläge, wie Sie Ihre Quelltexte gestalten
sollten. Diese Regeln gelten eigentlich nur für veröffentlichten
Code.
Wenn Sie als Beispiel Kommentare in der alten Form @@samp{(* this one *)}
schreiben möchten, so geht das natürlich vorübergehend, bei der
Veröffentlichung sollten Sie dann allerdings unsere diesbezüglichen
Ratschläge beherzigen. Da man aber niemals wissen kann, ob und wann man
den Code veröffentlicht, ist es vorzuziehen, sich von vornherein an
diese Ratschläge zu halten.

@@menu
* Verschiedene Tips::           Verschiedene Tips zur Gestaltung
* Konsitenzüberprüfung::        Über die Benutzung von @@code{Assert}, um
                                abzubrechen, wenn etwas ``Unmögliches''
                                passiert.
* Formatierung::                Wie man die Quellen formatiert
* Kommentare::                  Quellen kommentieren
* Reihenfolge::                 Reihenfolge der Code-Bereiche
* Großschreibung::              Großschreibung
* Compiler-Direktiven::         Benutzung von Compiler-Direktiven
* Zwischenraum::                Wie man Leerzeichen in Code benutzt
* Zeilenumbrüche::              Wo man seine Zeilen umbrechen sollte
* Strings::                     Zeichenketten
* Internationalisierung::       Techniken zur Internationalisierung
* MemoryMap::                   Wie Sie sicher @@samp{MemoryMap} benutzen
@@end menu

@@node Verschiedene Tips
@@section Verschiedene Tips zur Gestaltung
@@cindex Verschiedene Tips

Pascal Quelldateien sollten die Endung @@samp{.pas} haben.
Der Dateiname ohne diese Endung sollte der Name des Programmes,
der Unit oder des Modules sein, aber kleingeschrieben. Es sollte nur
eine einzige Unit, ein einziges Programm oder Modul pro Datei geben.

Der Code sollte mit der Option @@samp{-Wall}, sowohl mit als auch
ohne @@samp{-O3} kompilierbar sein und in keinem Fall irgendwelche
Warnungen ergeben. (Siehe: @@xref{Compiler-Direktiven}, um einzelne
Warnungen gezielt abzuschalten, wenn es gar nicht anders geht.)

Bitte benutzen Sie nicht die automatische @@samp{Result}-Variable in
Funktionen. Wenn Sie sie haben wollen, so sollten Sie diese auch
deklarieren:

@@smallexample
function Foo (@@dots{}) = Bar: Integer;
@@end smallexample

Benutzen Sie die Art der Deklaration mit @@samp{=}, nicht die ohne
Gleichheitszeichen, es sei denn, Sie wollen PXSC-kompatibel sein.

Wenn eine Funktion einen @@samp{Boolean}-Wert liefert, um den
Erfolg einer Operation anzuzeigen, so sollte @@samp{True} den
Erfolg melden und @@samp{False} das Fehlschlagen.
Beachten Sie, daß dieses Vorgehen anders ist als in C, wo
@@samp{0} oftmals den Erfolg meldet.

Vermeiden Sie @@samp{goto} und ähnliche Statements, wie @@samp{Exit},
@@samp{Return}, @@samp{Break} und @@samp{Continue}. Vermeiden Sie
@@samp{goto} um jeden Preis (außer @@emph{möglicherweise} ein
nicht-lokales @@samp{goto}, um aus einer @@emph{sehr tief}
geschachtelten rekursiven Funktion im Falle eines Fehlers
herauszukommen). Vermeiden Sie die anderen Statements, wenn dies
mit vertretbarem Aufwand möglich ist. Wenn Sie aber dafür eine
weitere @@samp{Boolean}-Variable einführen müssten, so darf dies als
Entschuldigung für das Benutzen dieser Statements gelten.
Beachten Sie, daß Code oftmals @@emph{einfacher} wird, wenn Sie auf
@@samp{Break} verzichten und stattdessen eine bessere
Abbruchbedingung oder eine andere Sorte Schleife benutzen.

Niemals sollten Sie die @@samp{for}-Zählvariable verändern oder dem
Wert der Variablen nach dem Durchlaufen dieser Schleife vertrauen.
(Das ist nicht nur eine Art, seinen Quelltext zu gestalten, sondern
mehr noch eine Definition von Pascal. Solche Dinge ergeben
undefinierte Ergebnisse.)

Vertrauen Sie niemals undefiniertem Verhalten. Als Beispiele dienen
globale Variablen, die zu Beginn des Programmes mit @@samp{0}
initialisiert zu sein scheinen, angeforderter Speicher, der
initialisiert zu sein scheint, ein freigegebener Speicherbereich,
dessen Inhalt immer noch gültig zu sein scheint oder die oben
besprochenen @@samp{for}-Zählvariablen. Nichts von all dem ist
garantiert und kann mit jeder Compilerversion oder Plattform
geändert werden. Undefiniert ist eben undefiniert. Und der
Eindruck, daß solche Dinge bei 42 anderen Compilern zu
funktionieren scheinen, ist dabei völlig belanglos!

Bei Vergleichen sollte die sich häufiger ändernde Variable auf der
linken Seite stehen.

@@smallexample
for i := 1 to 10 do
  if a[i] = Foo then
    for j := 1 to 10 do
      if b[j] = a[i] then @@dots{}
@@end smallexample

In diesem Beispiel ändert sich @@samp{a[i]} häufiger als @@samp{Foo}
und @@samp{b[j]} ändert sich häufiger als @@samp{a[i]} (da @@samp{j}
sich häufiger als @@samp{i} ändert).

Wir nehmen bei diesem Beispiel an, daß @@samp{Foo} konstant ist. Wenn
@@samp{Foo} ebenfalls von @@samp{i} abhängt, so kann es angebracht
sein, @@samp{Foo} auf die linke Seite zu stellen. Dies sollte dann
aber durch einen Kommentar erläutert werden.

Vermeiden Sie es, Code doppelt zu schreiben. Es ist zwar so einfach,
den Code an eine andere Stelle zu kopieren, aber es wird ein
Alptraum sein, diesen dann zu pflegen. Benutzen Sie stattdessen
Routinen oder Subroutinen, Units oder Module. Planen Sie Ihren Code
so, daß er erweitert werden kann. Packen Sie schlaue Tricks nicht an
Stellen, die Sie später ändern wollen.

Umfassen Sie einzelne Statements nicht mit @@samp{begin} und @@samp{end},
es sei denn, Sie wollen das ``dangling else'' - Problem vermeiden oder
diese Zeile ist der gesamte Rumpf einer Prozedur bzw. Funktion!
Siehe folgende Beispiele:

@@smallexample
if foo then
  begin
    if bar then
      baz
  end  @@{ Vermeiden des ``dangling else'' - Problems. @@}
else
  qux  @@{ Einzeiliges Statement. @@}
@@end smallexample

Schreiben Sie keine leere Unit-Initialisierung. Folgendes sollten
Sie @@emph{nicht} tun:

@@smallexample
@@dots{}

procedure Foo;
begin
  @@dots{}
end;

begin
end.
@@end smallexample

Stattdessen schreiben Sie einfach:

@@smallexample
@@dots{}

procedure Foo;
begin
  @@dots{}
end;

end.
@@end smallexample

Schreiben Sie keine ungenutzten Deklarationen, außer
in Interfaces, wo diese vom importierenden Code genutzt
werden können.

@@cindex Boolsche Werte
@@cindex Boolean
Denken Sie daran: @@samp{Boolean}-Werte sind @@samp{Boolean}-Werte!
Bitte schreiben Sie @@samp{if Foo then} statt
@@samp{if Foo = True then}, und @@samp{if not Foo then} statt
@@samp{if Foo = False then}.
Benutzen Sie auch @@samp{until False} statt @@samp{until 1 = 0},
das sieht auch hübscher aus. Ein anderes Beispiel ist
@@samp{Foo := Expression} statt @@samp{if
Expression then Foo := True else Foo := False}.

Vermeiden Sie doppelte globale Bezeichner, überladen Sie eingebaute
Bezeichner nicht, obwohl es der GNU Pascal Compiler verschmerzen
würde. Benutzen Sie dieselben globalen Bezeichner auch nicht in
verschiedenen Units oder Modulen. (Dank ``qualifizierter
Bezeichner'' wäre dies für den Compiler kein Problem, aber für den
Benutzer verwirrend.)

@@cindex Globale Variablen
Wir raten davon ab, globale Variablen für nicht-globale Zwecke
einzusetzen, z.B. eine globale Variable @@code{Counter} als Zähler in
diversen lokalen Routinen zu verwenden. Deklarieren Sie stattdessen
eine lokale Variable in jeder Routine, die eine benötigt. Dies
ermöglicht i.a. auch eine bessere Optimierung des erzeugten Codes.

@@cindex Unendliche Schleifen
Wenn Sie eine unendliche Schleife schreiben (auch wenn diese
möglicherweise durch @@samp{Break} verlassen wird), empfehlen wir die
Verwendung der @@code{repeat} und nicht der @@code{while} Schleife,
weil dadurch der Code weniger weit nach rechts eingerückt wird
(jedenfalls, sofern die Schleife mehr als eine Anweisung enthält).
Also:

@@smallexample
repeat
  @@dots{}
until False
@@end smallexample

Und nicht:

@@smallexample
while True do
  begin
    @@dots{}
  end
@@end smallexample

@@node Konsitenzüberprüfung
@@section Explizite Überprüfung der internen Konsistenz
@@cindex Konsitenzüberprüfung
@@cindex Assert

Wie in der GNU C-Bibliotheksdokumentation (@@pxref{Consistency
Checking, , , libc}) erläutert, ist es häufig von Vorteil, grundlegende
Annahmen in eigenen Programmen zu überprüfen.
Schauen Sie sich dazu einmal folgende Prozedur an:

@@smallexample
procedure MachWasMitPString (StrPtr: PString);
@@end smallexample

Hierbei könnten Sie implizit annehmen, daß diese Prozedur niemals mit
@@code{nil} als Argument aufgerufen wird. Es ist jedoch sicherer, diese
``unmögliche Bedingung'' zu überprüfen, um sicher zu stellen, daß
@@code{StrPtr} verschieden von @@code{nil} ist:

@@smallexample
procedure MachWasMitPString (StrPtr: PString);
begin
  Assert (StrPtr <> nil);
  @@dots{}
end;
@@end smallexample

Wenn die Überprüfung fehlschlägt, dann erzeugt das Programm einen
Laufzeitfehler. Daraus läßt sich der Schluß ziehen, daß der Code, welcher
diese Prozedur aufruft, fehlerhaft ist (oder diese Routine entsprechend
ergänzt werden sollte). Dieses Verfahren kann sich bei der Fehlersuche
wirklich als hilfreich erweisen. Mit anderen Worten: fundamentale Annahmen
am Anfang (oder einem anderen geeigneten Ort) einer Routine zu überprüfen
stellt sicher, daß eine Funktion oder Prozedur nicht falsch benutzt werden
kann.

Die GNU C-Bibliothek enthält das @@code{assert}-Makro für diese Art von
Überprüfungen. GNU-Pascals @@code{Assert} verhält sich ein wenig anders.
@@code{Assert} bricht das Programm nicht vollständig ab, sondern erzeugt
einen Laufzeit-Fehler (@@pxref{Assert, , , gpc}), den man z.B. mit der
@@samp{Trap}-Unit (@@pxref{Trap, , , gpc}) abfangen kann.

Wenn das Programm hinreichend getestet wurde, kann man die
Überprüfung von @@code{Assert} abstellen, indem man das Programm mit
der Option @@samp{--no-assertions} neu compiliert. Am Code selbst ist
keine Änderung nötig. Nebenwirkungen der Argumente von
@@code{Assert} werden weiterhin ausgewertet (dies ist anders als
in C), so daß man weiterhin schreiben kann:

@@smallexample
  Assert (MeineFunktion (Foo, Bar) > 0)
@@end smallexample

@@code{MeineFunktion} wird auf jeden Fall aufgerufen, die Überprüfung,
ob der Rückgabewert positiv ist, erfolgt jedoch nur, wenn
@@samp{--no-assertions} nicht als Option angegeben wurde.

Wir empfehlen, die Konsistenzüberprüfung nie abzuschalten, sofern man den
kleinen Laufzeitzuwachs verschmerzen kann.

@@node Formatierung
@@section Wie man die Quellen formatiert
@@cindex Formatierung

@@cindex Blanks
@@cindex Leerzeichen
Als erstes: Vermeiden Sie unnötige Leerzeichen am Ende einer Zeile.
Vergewissern Sie sich außerdem, daß Sie den Quelltext nicht mit
Tabulatorzeichen speichern. Verschiedene Editoren oder auch verschiedene
Konfigurationen eines Editors interpretieren diese Zeichen
mit einer unterschiedlichen Anzahl Leerzeichen.
Dies gefährdet Ihre mühsam erarbeitete Einrückung.
(Wenn Sie GNU Emacs benutzen, so ist die Funktion @@samp{untabify}
sehr nützlich; wenn sie VIM benutzen, die Umgebungsoption
@@samp{expandtab} (@@samp{:set et}); in PENG kann die Option
@@samp{Expand tabs} verwendet werden.)

@@cindex Steuerzeichen
Bitte vermeiden Sie es, in Ihren Quelltext Steuerzeichen einzufügen
(außer NewLine, selbstverständlich). Bitte auch keine Form-Feeds
(@@samp{#12}), wenngleich sie in den GNU Coding Standards zum
Separieren von logischen Bereichen empfohlen werden. Auch keine
@@samp{SUB}-Zeichen (@@samp{#26}), diese werden nämlich unter DOS
als Ende-der-Datei-Zeichen mißbraucht. Ältere DOS-Editoren
fügen dieses Zeichen an das Ende der Datei an, obwohl selbst das
FAT-Dateisystem selbst über das Ende der Datei Bescheid weiß.

@@cindex Zeilenlänge
Wir empfehlen eine maximale Länge von 68 Zeichen pro Zeile, so daß
eine Quelldatei in @@TeX{} mit voreingestelltem Font auf A4 gedruckt
werden kann. oder 78 Zeichen, geeignet für 80 Zeichen breite
Bildschirme. Dies ist keine feste Regel, denn umgebrochene Zeilen
verringern nur allzuoft die Lesbarkeit.

@@cindex Leerzeilen
Benutzen Sie Leerzeilen zwischen Blöcken. Blöcke sind lange
Kommentare, @@samp{type}, @@samp{const}, @@samp{var}, @@samp{label}
Abschnitte, Routinen-Rümpfe, Unit- oder
Modulinitialisierung/-finalisierung, @@samp{interface},
@@samp{implementation}, @@samp{module}, @@samp{export}, @@samp{uses},
@@samp{import} Zeilen, globale Compiler-Direktiven.
Soweit lange Kommentare eine folgende Deklaration betreffen,
bitten wir Sie, nur eine Zeile vor dem Kommentar abzusetzen,
nicht zwischen Kommentar und Deklaration.
Eine besondere Ausnahme ist zwischen den Blöcken innerhalb
derselben Routine. Benutzen Sie hier keine Leerzeilen:

@@smallexample
procedure Short;
var
  Foo: Integer;
  Bar: Char;
begin
  @@dots{}
end;
@@end smallexample

Aber benutzen Sie Leerzeilen, um Subroutinen abzusetzen:

@@smallexample
procedure Long;
const
  @@dots{}
var
  Variablen, die von Sub genutzt werden können @@dots{}

  procedure Sub;
  var
    @@dots{}
  begin
    @@dots{}
  end;

var
  Variablen, die nicht von Sub genutzt werden können @@dots{}
begin
  @@dots{}
end;
@@end smallexample

Benutzen Sie bitte auch keine Leerzeile nach der Deklaration des
Namens der Hauptroutine, es sei denn, eine Subroutine folgt sofort.
Andernfalls würde die Deklaration aussehen wie eine
Forward-Deklaration.

Beachten Sie bitte, daß wir im obigen Beispiel die lokalen Variablen
in Abschnitte vor und nach der Subroutine aufgeteilt haben. Dies ist
nicht zwingend.

Alles, was wir über Subroutinen gesagt haben, gilt
selbstverständlich auch für Sub-Subroutinen beliebiger
Verschachtelungstiefe.

Eine Leerzeile sollte dann zwischen Deklarationen desselben Types
stehen, wenn es Sinn macht, um diese logisch zu separieren. Falls
vor der Deklaration ein Kommentar steht, so soll die Leerzeile vor
dem Kommentar stehen. Anderenfalls soll die Leerzeile vor der
Deklaration stehen.

Leerzeilen können in langen Kommentaren Absätze teilen.

Keine Leerzeile am Anfang oder am Ende einer Datei. Lediglich ein
einzelnes Zeilenendzeichen nach dem letzten @@samp{end.}. Niemals
sollten Sie mehrere Leerzeilen hintereinander schreiben.

@@node Kommentare
@@section Quellen kommentieren
@@cindex Kommentare

Die Kommentare sollten in geschweiften Klammern stehen, wie hier:

@@smallexample
@@{ So ist es gut! @@}
@@end smallexample

Altmodische Kommentare zwischen Klammern und Sternchen sollten
nicht mehr benutzt werden:

@@smallexample
(* Ein häßlicher Kommentar. So etwas braucht man nicht mehr! *)
@@end smallexample

Auch sollten keine Kommentare mehr geschrieben werden, die mit
doppelten Schrägzeichen eingeleitet werden und bis zum Ende der
Zeile gehen:

@@smallexample
// Machen Sie es nicht.
@@end smallexample

Obwohl ISO Pascal gemischte Kommentare ausdrücklich erlaubt und
der GNU Pascal Compiler sich mit der Option
@@samp{@@{$mixed-comments@@}} auch nicht darüber beschweren würde,
sollten solche Kommentare nicht benutzt werden:

@@smallexample
(* Dieses ... @@}
@@{ ... und jenes. *)
@@end smallexample

@@cindex Verschachtelte Kommentare
Vermeiden Sie verschachtelte Kommentare wie
@@samp{@@{ @@{ diesen hier @@} @@}}. Das ist nur dann in Ordnung,
wenn Sie @@TeX{} in einem Kommentar setzen wollen oder ähnlich
exotische Dinge. Was auch immer Sie für Gründe haben mögen, müssen
Sie diese Option dann zunächst mit der Direktive
@@samp{@@{$nested-comments@@}} anschalten. Benutzen Sie bitte nicht die
Kommandozeilenoption @@samp{--nested-comments}. Packen Sie all
diese Optionen in den Quellcode, damit niemand, der den Quellcode
übersetzen möchte, erst die benötigten Optionen erraten muß, und
auch, weil Kommandozeilenoptionen z.B. bein Kompilieren eines
Projektes mit mehreren Units/Modules @@emph{alle} Dateien betreffen
würden.

@@cindex Sprache in Kommentaren
Bitte schreiben Sie Kommentare in Englisch! Englisch ist diejenige
Sprache, die die meisten Programmierer in allen Ländern lesen
können. Wenn Sie sich im Englischen nicht fit genug fühlen, dann bitten
Sie jemanden, Ihnen dabei zu helfen. Schreiben Sie so gut, wie Sie
können.

@@cindex Kommentarraster
Sie sollten sich ``French Spacing'' angewöhnen, d.h. nur ein
Leerzeichen am Ende eines Satzes. Dabei können Sie in GNU Emacs
@@samp{M-a} und @@samp{M-e} nicht benutzen. Wir hoffen, daß Sie das
verschmerzen können. Bitte lassen Sie nur ein Leerzeichen nach der
öffnenden und der schließenden geschweiften Klammer des Kommentares
Platz.

@@cindex Plazierung der Kommentare
Wenn ein Kommentar sich nur auf eine Zeile Code bezieht, so sollte
der Kommentar in derselben Zeile hinter dem Code stehen, soweit
das möglich ist. Bitte lassen Sie zwei Leerzeichen Platz.
Dies ist ebenfalls für den Interface-Bereich einer Unit und bei
globalen Variablen angemessen. Oftmals benötigt man diese Sorte
Kommentare neben Record-Feldern. Andernfalls sollten Kommentare
in eigenen Zeilen stehen:

@@smallexample
@@{ foo bar baz @@}
@@end smallexample

Oder etwas länger:

@@smallexample
@@{ foo bar
   baz @@}
@@end smallexample

Mit Absätzen:

@@smallexample
@@{ foo bar
   baz

   qux @@}
@@end smallexample

Die Kommentare sollten gewöhnlich vor den Code plaziert werden,
auf den sie sich beziehen. Sie erhalten dieselbe Einrückung:

@@smallexample
@@{ Meine Typen. @@}
type
  @@dots{}

type
  @@{ Mein erster Typ. @@}
  Foo = Integer;
  @@dots{}

begin
  @@{ Mein erstes Statement. @@}
  Bla;
  @@{ Anfang der Schleife. @@}
  repeat
    @@{ Schleifenkörper. @@}
    @@dots{}
  @@{ Beende die Schleife, wenn irgendwas passiert. @@}
  until Something
end;
@@end smallexample

Beachten Sie bitte besonders den Kommentar vor @@samp{until}.

Kommentare, die eine globale Deklarationen beschreiben, sollten in
eigenen Zeilen direkt vor der Deklaration stehen:

@@smallexample
@@{ Das ist Foo. Foo kann so Manches. @@}
procedure Foo;
@@end smallexample

@@cindex Dumme Kommentare
@@cindex Triviale Kommentare
Schreiben Sie keine ``trivialen'' Kommentare wie den obigen.
Sie sollten Kommentare dadurch vermeiden, daß Sie durchdachten
Code schreiben. Linus Torvalds macht das in seinem
Kernel Coding Style deutlich:

@@quotation
Comments are good, but there is also a danger of over-commenting.
@@strong{Never} try to explain @@strong{how} your code works in a comment:
it's much better to write the code so that the @@emph{working} is
obvious, and it's a waste of time to explain badly written code.
Generally, you want your comments to tell @@strong{what} your code does,
not @@strong{how}.
@@end quotation

Übersetzung:

@@quotation
Kommentare sind grundsätzlich sinnvoll, aber es besteht die Gefahr
der ``Überkommentierung''. @@strong{Niemals} sollten Sie im
Kommentar erklären, @@strong{wie} der Code arbeitet:
Es ist viel besser, offensichtlichen Code zu schreiben, so daß
seine @@emph{Arbeitsweise} sich ergibt. Es ist verschwendete Zeit,
schlecht geschriebenen Code zu kommentieren. Allgemein sollte man
mitteilen, @@strong{was} der Code macht, nicht @@strong{wie} er es macht.
@@end quotation

(Beachten Sie, daß wir in anderen Bereichen ziemlich stark von seinem
Coding Style abweichen.)

@@cindex Kommentare bei nicht naheliegendem Code
@@cindex Trickreiche Kommentare
``Trickreicher'' Code ist es wert, kommentiert zu werden. Wir
definieren den Code als ``trickreich'', der nicht naheliegende Dinge
tut, auf nicht sofort einleuchtenden Annahmen basiert, unerwartete
Implikationen beinhaltet, bei dessen Änderung etwas Spezielles
beachtet werden muss, der sich nicht so verhält, wie es auf den
ersten Eindruck scheint, der Seiteneffekte enthält oder es
erfordert, daß andere Teile des Codes an anderer Stelle gleichzeitig
mit ihm geändert werden. Trickreicher Code sollte grundsätzlich nur
in bescheidenem Maße benutzt werden.

@@cindex Kommentare zu externen Quellen
In dem Fall, daß sich ein Kommentar auf eine andere
Stelle des Codes bezieht, wobei es egal ist, ob die Referenz in
derselben oder einer anderen Datei liegt, beziehen Sie sich bitte
auf den Namen der Routine oder einen Kontext. Bitte geben Sie den
Bezug nicht in Form von Zeilennummern an (diese ändern sich zu
häufig). Lassen Sie in den Kommentaren außerdem beide Stellen
aufeinander verweisen, wo es Sinn macht. Diese Art der
``Kreuzverweise'' erwies sich schon oft als sinnvoll.

@@cindex Auskommentieren
Code, der auskommentiert werden soll, sollte mit Hilfe von
@@samp{@@{$if False@@} @@dots{} @@{$endif@@}} vom Kompilieren
ausgeschlossen werden. Bitte benutzen Sie dazu keine Kommentare.

@@cindex Kommentare zur Trennung logischer Abschnitte
Um logische Abschnitte innerhalb größerer Module oder Units zu
markieren, sollten Sie Kommentare benutzen. Wir schlagen Ihnen
folgende leicht zu suchende festgelegte Form vor:

@@smallexample
@@{@@@@section Name des Kapitels@@}
@@{@@@@subsection Name des Abschnitts@@}
@@end smallexample

Beachten Sie, daß in diesem Fall ausnahmsweise keine Leerzeichen
neben den geschweiften Klammern eingefügt werden.

@@cindex Beschreibende Kommentare
Ein Modul, eine Unit oder Library sollte im Interface-Bereich
Kommentare haben, so daß dieses Interface zu einer verläßlichen
Dokumentationsquelle wird. Es ist freigestellt, solche Kommentare
für Routinen zu benutzen, die nur im Implementationsbereich
oder in Programmen (im Gegensatz zu Modulen etc.) deklariert werden.
Mehrere zusammenhängende Deklarationen (z.B. Gruppen von Konstanten)
können sich einen Kommentar teilen.

@@cindex Kommentare mit Textauszeichnung
Es wird ein Utility namens @@samp{pas2texi} geschrieben, welches
Texinfo-Dateien aus Pascal-Kommentaren erzeugt. Dieses Utility
wird verschiedene Textauszeichnungsmöglichkeiten innerhalb von
Kommentaren erlauben. Diese Textauszeichnungen werden innerhalb
der Dokumentation von @@samp{pas2texi} oder in späteren
Versionen dieses Dokumentes erläutert werden.

@@cindex Fixme Kommentare
``Fixme''-Kommentare dienen dazu, aufzuzeigen, daß an dieser Stelle
Code etwas zu verändern ist. Den Kommentaren werden mindestens
zwei @@samp{@@@@} vorangestellt. Fügen Sie soviele @@samp{@@@@} ein,
wie es der Dringlichkeit der Korrektur entspricht.

Die Kommentare sollten das Wesentliche des Problems enthalten, vor
allem wenn die Wurzel des Übels woanderes liegt. Beispielsweise
erklärt der Kommentar @@samp{@@{ @@@@@@@@fjf226 @@}} den folgenden Code als
Work-Around für ein Problem des GNU Pascal Compilers, welches von
einem Test-Programm namens @@samp{fjf226.pas} verdeutlicht wird.
(Diese Datei können Sie tatsächlich innerhalb des Quellpaketes des
GNU Pascal Compilers finden.)

``Fixme''-Kommentare sollten nicht mit anderen Kommentaren vermischt
werden. Wenn beide Kommentare gebraucht werden, so sollten sie
getrennt, wenn auch direkt hintereinander stehen. Da sie
vorübergehender Natur sind, dürfen solche Kommentare überall stehen,
sogar innerhalb von Anweisungen. Normalerweise stehen sie im Rumpf
einer Routine, solange sie nicht das Interface eines Modules bzw.
einer Unit beeinflussen. Interfaces, die voraussichtlich in der
Zukunft geändert werden, sollten @@samp{@@@@@@@@}-Kommentare direkt vor
ihren beschreibenden Kommentaren aufweisen.

@@node Reihenfolge
@@section Reihenfolge der Code Bereiche
@@cindex Reihenfolge

Jede Datei sollte mit einem Kommentar beginnen, welcher der Reihe
nach folgendes beinhaltet:

@@itemize @@bullet
@@item
eine kurze Beschreibung, was der Code in dieser Datei macht
@@item
eine längere Beschreibung über Details des Codes und wo man sich
informieren kann
@@item
Copyright-Informationen (Autoren)
@@item
Die Lizenz (Klar, Sie wollen immer die GNU General Public License
oder die Lesser General Public License nutzen!)
@@end itemize

@@cindex declaration blocks
Allgemein sollte man diese Deklarations-Reihenfolge einhalten:

@@itemize @@bullet
@@item
@@samp{const}-Deklarationen
@@item
@@samp{type}-Deklarationen
@@item
@@samp{var}-Deklarationen
@@item
@@samp{label}-Deklarationen
@@item
Routinen
@@end itemize

Sie können von dieser Reihenfolge abweichen, wenn es notwendig
erscheint oder den Code lesbarer gestaltet. Im folgenden sehen Sie
ein Beispiel, bei dem diese Reihenfolge nicht eingehalten werden
kann:

@@smallexample
type
  TIrgendwas = record
    Dieses, Jenes: Integer
  end;

const
  IrgendEineKonstante = SizeOf (TIrgendwas);
@@end smallexample

Die obigen Regeln gelten selbstverständlich auch für
Deklarationsbereiche innerhalb von Routinen.

Wenn Sie mehrere mehr oder weniger unabhängige Bereiche in einer
großen Unit oder einem großen Modul haben, so sollten sie obige
Reihenfolge auf jeden Teilbereich des Modules anwenden. Es sollten
z.B. nicht alle Konstanten aller Bereiche in eine einzelne
@@samp{const}-Deklaration geschrieben werden, das macht den Code
eher unleserlich.

@@cindex Variablen-Deklaration
Variablen, die nur im Hauptprogramm genutzt werden, müssen in
Pascal global deklariert werden, wobei GNU Pascal eine Erweiterung
kennt, um diese Beschränkung zu umgehen und Variablen im
Anweisungsteil zu deklarieren (@@pxref{var, , , gpc}). In einem
solchen Fall sollten diese Variablen direkt vor dem @@samp{begin} des
Hauptprogrammes geschrieben werden, nach allen Routinen etc. Das
gilt besonders dann, wenn das Programm groß ist und viele Variablen
deklariert werden. Dadurch wird der Variablen-Deklarations-Bereich
leichter einsehbar und ist einfacher mit den entsprechenden
Code-Bereichen änderbar. Außerdem vermeidet man so, daß
versehentlich Routinen diese Variablen nutzen.

@@cindex Deklarationen innerhalb eines Typ-Deklarations-Blocks
Wenn Sie einen Typ und seinen zugehörigen Zeiger gleich mit
deklarieren wollen, so deklarieren Sie bitte zuerst den Zeiger.
Dies ist übersichtlicher, besonders wenn der zugehörige Typ eine
größere Struktur (@@samp{record} oder @@samp{object}) ist. Auch wird
es damit möglich, rekursive Strukturen aufzubauen (Typdefinitionen,
die Zeiger auf denselben Typ beinhalten). Bitte stellen Sie den
Typen ein @@samp{T}, und den zugehörigen Zeigern ein @@samp{P} voran.
Folgendes Beispiel veranschaulicht das:

@@smallexample
type
  PMyInt = ^TMyInt;
  TMyInt = Integer;

  PStrList = ^TStrList;
  TStrList = record
    Next: PStrList;
    s: TString
  end;
@@end smallexample

Bitte beachten Sie in dem Beispiel, daß das @@samp{Next}-Feld als
erstes aufgeführt ist. Wir schlagen vor, daß Sie es bei rekursiven
Typen immer so machen, es ermöglicht einige generische
Listenroutinen und ist etwas effizienter, da beim Durchlaufen der
Liste keine Offsets auftauchen.

Nicht verpflichtend ist es, alle Zeigertypen innerhalb einer
@@samp{type}-Deklaration zuerst aufzuführen, aber wir raten Ihnen
dazu. Hier ist ein Beispiel dazu:

@@smallexample
type
  @@{ Zeigertypen @@}
  PFoo = ^TFoo;
  PBar = ^TBar;
  PBaz = ^TBaz;

  @@{ Einige maßgefertigte Integertypen @@}
  TFoo = Integer attribute (Size = 16);
  TBar = Cardinal attribute (Size = 16);
  TBaz = Cardinal attribute (Size = 32);
@@end smallexample

@@cindex Deklarationen innerhalb von Objekttypen
Innerhalb von Objekt-Typen gibt es drei Deklarationsbereiche. Drei
reservierte Wörter leiten diese Bereiche ein: @@samp{public},
@@samp{protected}, @@samp{private}. Innerhalb eines jeden dieser
Bereiche sollte man folgende Reihenfolge einhalten:

@@itemize @@bullet
@@item
Felder
@@item
Konstruktoren
@@item
Destruktoren (hiervon sollte es nur einen geben)
@@item
Methoden
@@end itemize

@@cindex Reihenfolge der Implementation
Im Implementationsbereich sollte man dieselbe Reihenfolge
einhalten wie bei der Deklaration. Dies gilt selbstverständlich
ebenso für Units und Module.

Benutzen Sie nie ein @@samp{;} am Ende eines Blockes, also vor
@@samp{end}, @@samp{until}, usw, außer im Fall von @@samp{case}.
Der letzte Zweig vor @@samp{else} (oder der letzte Zweig, wenn es
keinen @@samp{else}-Zweig gibt) @@emph{sollte} ein abschließendes
@@samp{;} haben, um Probleme wie diese zu vermeiden:

@@smallexample
case @@dots{}
  Foo:
    if Bar then  @@{ später eingefügt @@}
      begin
        @@dots{}
      end  @@{ wenn es hier kein Semikolon gibt @@dots{} @@}
  else  @@{ @@dots{} dann wird dieses @@samp{else} plötzlich dem @@samp{then} zugerechnet @@}
    @@dots{}
@@end smallexample

(Dasselbe gilt auch, wenn es @@samp{if} schon gibt und das
@@samp{else} des @@samp{case} später eingefügt wird.)

In Objekten mag es merkwürdig aussehen, das @@samp{;} nach dem
letzten Eintrag (meistens eine Objekt-Methode) wegzulassen.
Deswegen erlauben wir es hier und zur Erhaltung der Konsistenz auch
in Records.

@@node Großschreibung
@@section Großschreibung
@@cindex Großschreibung

Reservierte Wörter sollten allesamt kleingeschrieben werden,
einschließlich aller Direktiven und Wörter, die nur in manchen
Kontexten reserviert sind (wie @@samp{protected}). Wenn Sie
Direktiven außerhalb ihres Kontextes als Bezeichner benutzen (was
leicht zu Problemen führen kann), so schreiben Sie diese bitte wie
Bezeichner.

Als besondere Ausnahme darf man @@samp{File} großschreiben, wenn
dieses als eigener Typ gebraucht wird. Anders ist es
selbstverständlich bei @@samp{file of Char}. Im Fall von
@@samp{procedure} als Typ (Borland Pascal) kann man diese Regel
nicht anwenden, denn @@samp{File} kann ein Typ an sich sein, während
@@samp{procedure} ein Typ-Konstruktor ist. Beispiel:

@@smallexample
procedure Foo (var a: File);  @@{ Das geht @@}
procedure Foo (var a: procedure);  @@{ Das geht nicht! @@}
@@end smallexample

@@cindex Großschreibung von Bezeichnern
Der nächste Punkt betrifft die Großschreibung von Bezeichnern. Es
gibt hierbei keinen Unterschied zwischen eingebauten und
selbstdefinierten Bezeichnern. Grundsätzlich sollte nur der erste
Buchstabe großgeschrieben werden, außer wenn es sich um
zusammengesetzte Wörter oder Akronyme handelt, dann sollte jeder
Anfangsbuchstabe eines jeden Teilwortes großgeschrieben werden.
Unterstriche sollten vermieden werden. Akronyme, die zu einem Teil
der natürlichen Sprache geworden sind, sollten so geschrieben
werden wie in der Sprache. Beispielsweise @@samp{Dos} oder @@samp{DOS},
aber immer @@samp{GPC} und niemals @@samp{Gpc}!
Hier einige Beispiele von Bezeichnern:
@@samp{Copy}, @@samp{Reset}, @@samp{SubStr}, @@samp{BlockRead},
@@samp{IOResult}, @@samp{WriteLn}, @@samp{Sqr}, @@samp{SqRt},
@@samp{EOF}, @@samp{EOLn}.

@@cindex Großschreibung von Konstanten
Anders als bei C-Makros gelten diese Regeln auch für Konstanten.

Sehr kurze Bezeichner dürfen kleingschrieben werden, z.B. @@samp{i},
@@samp{s1} oder @@samp{xx}. Solche kurzen Bezeichnernamen sollten nur
in lokalen Blöcken auftauchen. Dazu zählen auch Parameter globaler
Routinen, denn der Gültigkeitsbereich solcher Parameter ist lokal.
Der Gebrauch dieser Bezeichner sollte nicht in einem globalen
Kontext erfolgen, besonders nicht in Units oder Modulen. Der Autor
kann ja nie wissen, in welchen Kontexten die Units/Module benutzt
werden.

Bitte bleiben Sie einheitlich, was die Groß- und Kleinschreibung
ihrer Bezeichner anbelangt. Wenngleich Pascal Sie auch nicht
schlägt, wenn Sie mal die Großschreibung einer Variablen innerhalb
eines Blockes ändern: Bitte halten Sie sich an eine Form.

@@cindex Aufzählungstypen
@@cindex Konstanten
Für Bezeichner für die Werte von Aufzählungstypen und für Gruppen
von Konstanten, d.h. an Stellen, wo viele Bezeichner auf einmal
eingeführt werden, kann es nützlich sein, ein zweibuchstabiges
kleingeschriebenes Präfix zu verwenden, dem im Gegensatz zu obigen
Regeln ein Unterstrich (@@samp{_}) folgt:

@@smallexample
type
  TFooBar = (fb_Foo, fb_Bar, fb_Baz, fb_Qux);
@@end smallexample

@@smallexample
@@{ Meine Foos @@}
const
  mf_Foo = 1;
  mf_Bar = 3;
  mf_Baz = 42;
@@end smallexample

@@cindex OOP
In objektorientiertem Code, meistens in Konstruktoren, hat man den
Fall, daß der Parameter einer Funktion zu einem Feldnamen passen
soll, den dieser Parameter initialisiert. Da beide Namen nicht
übereinstimmen dürfen, sollte das Feld den ``natürlichen'' Namen
haben, da es an mehreren Stellen verwendet wird, und der
Parametername verändert werden. Wir haben bislang keine einheitliche
Regel für den Namen des Parameters in einem solchen Fall gefunden.
Manche Programmierer verwenden @@samp{a} als Präfix. Wenn Sie eine
gute Idee haben, so lassen Sie es uns wissen.

@@cindex Großschreibung von Makros
Makros sollten nicht genutzt werden! Sie sind die Reinkarnation
des Bösen! Wenn Sie es doch tun, so müssen Sie zur Strafe alle
Buchstaben groß schreiben und einzelne Teilwörter mit
Unterstrichen trennen. Da Makros außerhalb der
Pascal-Geltungsbereiche stehen, macht es durchaus Sinn, sie anders
zu schreiben als den übrigen Pascal-Code. Das gilt ebenso für
Bedingungen im Rahmen der bedingten Kompilierung (Conditionale).

@@node Compiler-Direktiven
@@section Benutzung von Compiler-Direktiven
@@cindex Compiler-Direktiven

Anmerkung des Übersetzers:
Um der Doppeldeutigkeit von ``condition'', wie sie in einer
@@samp{if}-Anweisung vorkommt, und wie sie in der bedingten
Ausführung von Code vorkommt, Herr zu werden, habe ich mich
entschieden, in diesem Abschnitt durchgängig ``Conditional'' im
letztgenannten Kontext zu verwenden. Der Leser möge mir verzeihen.

Grundsätzlich sollten Sie so wenig Compiler-Direktiven wie nur
irgend möglich verwenden, weil sie den Code schwerer lesbar
und wartbar machen. So sollten Direktiven aussehen:

@@smallexample
@@{$Ihre-Compiler-Direktive@@}
@@end smallexample

und niemals so: (@@pxref{Kommentare})

@@smallexample
(*$mach-es-nicht-Direktive*)
@@end smallexample

und auch nicht so, weil dies im Gegensatz zu Pascal, von
Zeilenumbrüchen anhängt:

@@smallexample
#so-auch-nicht-Direktive
@@end smallexample

Dasselbe bei Makro-Definitionen:

@@smallexample
@@{$define @@dots{}@@}
@@end smallexample

Dies spart außerdem den Backslash vor dem Zeilenumbruch, im
Gegensatz zu @@samp{#define}. Aber Sie wollen ohnehin keine Makros
benutzen, ODER? (@@pxref{Großschreibung})

@@cindex Blanks bei Direktiven
Fügen Sie niemals ein Leerzeichen vor der schließenden Klammer ein,
denn es darf auch keines nach der öffnenden Klammer kommen. Wenn
Sie mehrere Direktiven zusammenfügen, so fügen Sie zwischen zweien
kein Leerzeichen ein, ein einfaches Komma genügt.

@@cindex Kommentare und Direktiven
Es sollten keine Kommentare innerhalb der Direktiven eingefügt
werden. Schreiben Sie Kommentare stattdessen separat:

@@smallexample
@@{$X+@@}  @@{ Wir brauchen erweiterte Syntax @@}
@@end smallexample

Borland Pascal erlaubt, Kommentare mit Direktiven zu vermischen.
Das ist ein Mißbrauch eines solchen Kommentares!

Kurze Formen der Direktiven sind in Ordnung, aber man sollte den
langen Formen den Vorzug geben. Die kurzen Formen müssen
großgeschrieben werden, während die langen Formen kleingeschrieben
werden sollten (ausgenommen Argumente, bei denen es auf die
richtige Schreibweise ankommt, wie Fehlermeldungen, Warnungen,
Dateinamen -- bei letzteren ist auch unter DOS die korrekte Groß-
und Kleinschreibung zu verwenden, damit der Code portabel bleibt).

Sie können verschiedene Direktiven kombinieren, dabei auch kurze
und lange Formen mischen, wie im folgenden Beispiel:

@@smallexample
@@{$gnu-pascal,I-,X+@@}
@@end smallexample

@@cindex Standard-Direktiven
Jede Unit und jedes Modul sollte @@samp{@@{$gnu-pascal,I-@@}} oder
@@samp{@@{$gnu-pascal,I+@@}} nahe am Anfang stehen haben, und zwar
nach dem einleitenden Kommentar mit der Beschreibung und der
Lizenz. @@samp{@@{$gnu-pascal@@}} bewirkt, daß die Unit ohne
Dialekt-Optionen kompiliert wird, selbst wenn das aufrufende
Programm Dialekt-Optionen nutzt. @@samp{@@{$I-@@}} und @@samp{@@{$I+@@}}
zeigen dem Nutzer der Unit, daß Ein-/Ausgabe-Fehler von den Routinen
abgefangen werden oder Laufzeitfehler zu erwarten sind. Der erste
Fall ist dem anderen in den meisten Fällen vorzuziehen.
Für Programme ist dies optional. Routinen, die Ein-/Ausgabe-Fehler
hervorrufen können, sollten mit dem Attribut @@samp{iocritical}
(@@pxref{attribute, , , gpc}) deklariert werden:

@@smallexample
procedure KritischeRoutine; attribute (iocritical);
@@end smallexample


@@cindex no-warning Direktive
@@samp{@@{$W-@@}} (keine Warnungen) sollte nur lokal genutzt werden
und ein ``FIXME''-Kommentar (@@pxref{Kommentare}) haben, denn es
zeigt ein Problem mit dem Code oder dem Compiler.

Bitte schalten Sie keine Warnungen ab, wenn Sie nur zu faul sind,
Code zu schreiben, der keine Warnungen produziert.

@@cindex Lokale Direktiven
Jeder Compiler-Schalter, der nicht global gesetzt wird
(beispielsweise zusammen mit @@samp{@@{$gnu-pascal@@}}, siehe oben),
sollte mit @@samp{@@{$local @@dots{}@@}} kombiniert werden. Also nicht
so:

@@smallexample
@@{$I-@@} Reset (f); @@{$I+@@}
@@end smallexample

Sondern so:

@@smallexample
@@{$local I-@@} Reset (f); @@{$endlocal@@}
@@end smallexample

Das erste Beispiel ist falsch, wenn vorher schon @@samp{@@{$I-@@}}
geschrieben wurde. Selbst wenn ein Programmierer weiß, welches
die aktuellen globalen Einstellungen sind, so können sich diese
eines Tages ändern. Auch dadurch, daß Teile des Codes an
eine andere Stelle kopiert werden.
Das untere der beiden Beispiele ist daher die sichere Form.

Um zu verdeutlichen, was wir meinen, hier noch ein Beispiel:

@@smallexample
@@{$local W-@@} Foo; @@{$endlocal@@}  @@{ @@@@ GPC gibt hier eine überflüssige Warnung @@}
@@end smallexample

Nochmal: Vermeiden Sie es, lokale Direktiven zu gebrauchen.
@@samp{@@{$I-@@}} kann manchmal nütztlich sein. @@samp{@@{$X+@@}} sollte
nur dann gebraucht werden, wenn es @@emph{wirklich} notwendig ist,
und dann auch bitte so lokal wie nur irgend möglich. Vermeiden Sie
Zeiger-Arithmetik!

@@cindex Testen der Rückgabewerte
Benutzen Sie weder @@samp{@@{$X+@@}} noch
@@samp{@@{$ignore-function-results@@}}, um Funktionswerte zu
überprüfen. Es ist schlicht zu einfach, ein beachtenswertes
Funktionsergebnis zu ignorieren. Manchmal, besonders dann, wenn man
eine C-Bibliothek linkt, hat man es mit Funktionsergebnissen zu tun,
die überflüssig erscheinen, weshalb man sie nicht überprüfen möchte.
Solche Funktionen lassen sich bald mit dem Attribut @@samp{ignorable}
deklarieren, so daß das Funktionsergebnis stillschweigend ignoriert
wird.

Benutzen Sie auch dann Dummy-Variablen, wenn Sie
Funktionsergebnisse von Funktionen, deren Ergebnisse
gemeinhin nicht ignoriert werden sollen, ignorieren wollen.
Überprüfen Sie sehr sorgfältig, ob ein solches Ergebnis wirklich
sicher ignoriert werden kann! Wenn jedoch ein unerwarteter Wert
Sie in eine ``unmögliche'' Situation bringen würde, so ist es
normalerweise besser, das Funktionsergebnis zu überprüfen
und im unerwarteten Fall eine Warnung auszudrucken oder gar
abzubrechen. Tun Sie das wenigstens dann, wenn @@samp{DEBUG}
gesetzt ist. (@@pxref{Compiler-Direktiven}).

@@cindex Linker-Direktiven
Linker-Direktiven, d.h. @@samp{@@{$L@@}} fürBibliotheken und
C-Code-Dateien (oder Dateien anderer Sprachen) sollten nahe am
Anfang des Programmes und nahe am Implementationsanfang von Units
oder Modulen stehen. Mehrere Bibliotheken und C-Quelldateien können
in eine Direktive geschrieben werden, wenn sie logisch
zusammengehören (bspw. eine Bibliothek und ihre zugehörige
Wrapper-Funktion), nicht aber dann, wenn sie nicht zusammengehören.
Diese Direktiven sollten nicht mit anderen Direktiven gemischt
werden (was auch nicht geht, wenn @@samp{L} zuerst angeführt wird;
anders herum geht es, ist aber nicht ratsam). Die externen
Deklarationen der Bibliothek oder C-Routinen sollten sofort der
zugehörigen Direktive folgen (außer für Units oder Module bei
denjenigen Deklarationen, die in das Interface gehören). Das
Benutzen von @@samp{@@{$L@@}} innerhalb eines Programmes ist
normalerweise keine gute Idee. Da lohnt es sich schon, eine Unit zu
schreiben, welche abstrahiert und wiederverwertet werden kann.

@@cindex Bedingte Kompilierung
Bedingtes Kompilieren kann manchmal nützlich sein, aber es sollten
sowenige @@samp{@@{$ifdef@@}}s wie nur irgend möglich geschrieben
werden, denn sie vermindern die Lesbarkeit des Codes sehr stark.
Wo Conditionale eingesetzt werden, um verschiedene Systeme zu
unterscheiden, sollten die Fähigkeiten des Systems (bspw.
@@samp{__BYTES_LITTLE_ENDIAN__}) oder Gruppen von Systemen
(bspw. @@samp{__OS_DOS__}) überprüft werden, nicht einzelne Systeme.
Dieses Vorgehen funktioniert dann oftmals auch später noch auf
Systemen, von denen man noch nichts weiß oder die noch nicht
existieren.

Wann immer dies möglich ist, sollte vordefinierten Konstanten der
Vorzug gegenüber @@samp{define}s gegeben werden (bspw.
@@samp{BytesBigEndian}, @@samp{OSDosFlag}). Dies ist im Anweisungsteil
möglich (der ``immer false'' - Zweig wird schlicht wegoptimiert,
trotzdem wird seine Syntax überprüft). Bei Typen-Deklarationen ist
es normalerweise nicht möglich. Hier muß man @@samp{define}s
einsetzen. Folgendes ist ein Beispiel aus der CRT-Unit:

@@smallexample
TWindowXYInternalCard8 = Cardinal attribute (Size = 8);
TWindowXYInternalFill = Integer attribute (Size = BitSizeOf (Word) - 16);
TWindowXY = packed record
  @@{$ifdef __BYTES_BIG_ENDIAN__@@}
  Fill: TWindowXYInternalFill;
  y, x: TWindowXYInternalCard8
  @@{$elif defined (__BYTES_LITTLE_ENDIAN__)@@}
  x, y: TWindowXYInternalCard8;
  Fill: TWindowXYInternalFill
  @@{$else@@}
  @@{$error Endianness is not defined!@@}
  @@{$endif@@}
end;
@@end smallexample

@@cindex Debug-Flag
Das @@samp{DEBUG}-Flag sollte eine Unterstützung beim Debuggen des
Codes sein, also Code, der die Funktionalität beim Debuggen nicht
verändert. Nur dafür sollte er eingesetzt werden. Programme müssen
mit und ohne @@samp{DEBUG} lauffähig sein. Es kann sein, daß der
Code mit @@samp{DEBUG} langsamer läuft und eine Vielzahl von
Mitteilungen produziert. Diese Mitteilungen sollten klar als
Debug-Mitteilungen erkennbar sein, bspw. dadurch, daß der Ausgabe
ein @@samp{DEBUG: } vorangestellt wird. Solcher Code @@emph{darf} auch
einfach abbrechen, wenn fehlerhafte oder merkwürdige Zustände
eintreten.

@@cindex Conditionale und Versionsverwaltung
Conditionale können ebenfalls herangezogen werden, um verschiedene
Versionen ein und desselben Codes anzufertigen. So ist es z.B.
innerhalb eines Mathematik-Programmes möglich, eine eigene
Version mit GMP-Zahlen (GMP ist eine Bibliothek zur
Bearbeitung beliebig großer Zahlen) zu erzeugen und eine
ohne, je nachdem, welches Conditional gesetzt ist. In diesem
Fall sollten die Namen und Bedeutungen aller Conditionale in einem
weit oben im Quelltext stehenden Kommentar erklärt werden. Sehen Sie
sich bitte @@samp{__BP_TYPE_SIZES__}, @@samp{__BP_RANDOM__} und
@@samp{__BP_PARAMSTR_0__} als Beispiele aus der Unit @@samp{System}
an. Der Code sollte mit jeder Kombination dieser Conditionale
kompilierbar sein, was bedeutet, eine exponentielle Menge an
Kombinationen zu testen. Noch ein guter Grund, Conditionale so
selten wie möglich zu benutzen oder gar zu vermeiden.

@@cindex Conditionale und Implementationsverwaltung
Eine andere denkbare Benutzung von Conditionalen besteht darin, mit
ihrer Hilfe verschiedene Implementationen desselben Codes
anzufertigen. Sie sollten diese Strategie @@emph{nur} dann anwenden,
wenn alle Implementationen unterstützt werden oder es geplant ist,
sie zu unterstützen. Andernfalls sollte die alte Implementation
besser ins Museum wandern. Halten Sie den Code in einem solchen Fall
besser ``sauber''. Die Hinweise bzgl. des Testens gelten auch hier.

@@cindex Komplizierte Conditionale
Wenn Sie es mit komplizierten Conditionalen zu tun haben, so folgen
Sie bitte der Pascal-Syntax. Formatieren Sie den Code nach den
Regeln von Pascal, nicht nach denen von C. Hier ein dummes
Beispiel:

@@smallexample
@@{$if defined (Foo) or False@@}
@@end smallexample

Im Gegensatz zu (bitte nicht nachmachen!):

@@smallexample
@@{$if defined (Foo) || 0@@}
@@end smallexample

Oder noch schlimmer:

@@smallexample
#if defined (Foo) || 0
@@end smallexample

@@cindex Auskommentieren von Code
Eine spezielle Conditionale kann genutzt werden, um Code kurzfristig
auszukommentieren. Hier ist die zugehörige Syntax:

@@smallexample
@@{$if False@@} @@dots{} @@{$endif@@}
@@end smallexample

@@cindex Conditionale und GPC-Versionen
Ein Standard-Conditional sollte in Programmen, Units oder Modulen
genutzt werden, wenn Sie sicherstellen wollen, daß die richtige
Version des GNU Pascal Compilers verwendet wird. Folgen Sie diesem
Beispiel:

@@smallexample
@@{$if __GPC_RELEASE__ < 20020510@@}
@@{$error This unit requires GPC release 20020510 or newer.@@}
@@{$endif@@}
@@end smallexample

@@node Zwischenraum
@@section Wie man Leerzeichen in Code benutzt.

Im allgemeinen sollten nie mehrere Leerzeichen aufeinander
folgen, außer für Einrückungen und in speziellen Fällen, die im
folgenden Beschrieben werden.

Ein einzelner Blank soll vor und nach Operatoren, Zuweisungen
(@@samp{:=}) und @@samp{..} stehen. In @@samp{Write}, @@samp{WriteLn}
und @@samp{WriteStr} sollte ein Blank um das @@samp{:} angebracht
werden. Ein einzelner Blank soll nach Kommata und anderen @@samp{:}
stehen. Folgendes Beispiel macht es deutlicher:

@@smallexample
var
  Foo: Integer;
  @@dots{}
begin
  Foo := 42;
  WriteLn (Foo + 3 : 5, ' bar')
end;
@@end smallexample

Kein Leerzeichen sollte hingegen nach dem unären Minuszeichen
@@samp{-} stehen. Dieses sind die korrekten Formen: @@samp{x - 1},
@@samp{-x} und @@samp{-1}.

Ein Leerzeichen sollte vor und eines nach den Klammerzeichen
(@@samp{(}) und (@@samp{)}) stehen, solange diese nicht neben anderen
Klammern, eckigen Klammern, dem Pointer-Symbol (@@samp{^}), einem
Semikolon oder einem Komma auftreten. Mit anderen Worten: Ein
Leerzeichen sollte zwischen Bezeichnern/Schlüsselwörtern und
der öffnenden Klammern stehen. Beispiel:

@@smallexample
Foo (Bar^(Baz[Qux * (i + 2)]), Fred (i) + 3);
@@end smallexample

Für Arrayindizierung wird kein Leerzeichen verwendet (schreiben Sie
@@samp{Foo[42]} anstelle von @@samp{Foo [42]}), jedoch schon bei
Arraydeklarationen:

@@smallexample
Foo: array [1 .. 42] of Integer;
@@end smallexample

Bei Mengen-Konstruktoren sollte ggf. ein Blank vor der öffnenden
Klammer stehen -- diese eckigen Klammern sollten wie normale
Klammern behandelt werden:

@@smallexample
x := [0, 2 .. n];
@@end smallexample

Aber:

@@smallexample
Foo ([1, 2, 3]);
@@end smallexample

Kein Leerzeichen bei @@samp{.} und @@samp{^}:

@@smallexample
Rec.List^.Next^.Field := Foo
@@end smallexample

Wie wir schon ausführten, soll je ein Blank nach den öffnenden und
vor den schließenden geschweiften Klammern in Kommentaren stehen.
Dies gilt jedoch nicht für Compiler-Direktiven. Außerdem sollten vor
Kommentaren, die einer Code-Zeile folgen, zwei Leerzeichen stehen:

@@smallexample
Inc (x);  @@{ Increment x. @@}
@@end smallexample

@@cindex Abstand, Einrückung
@@cindex Einrückung, Abstand
Wenn Sie mögen, so fügen Sie beliebig viele Leerzeichen ein, um
``tabellarisch'' aussehenden Quellcode zu erzeugen. Unserer
Meinung nach erhöht dies die Lesbarkeit des Codes ungemein, weil
der menschliche Geist auf solche Strukturen trainiert ist,
Unterschiede in Zeilen besser gesehen werden können, und man
bei Änderungen im Quellcode verwandte Stellen nicht so leicht
übersieht. Eine Anwendung dieser Prinzipien sollte in
Interface-Deklarationen zu finden sein (es ist nicht leicht
anwendbar, wenn jede Routine durch Kommentare getrennt wird, daher
ist in einem solchen Fall möglicherweise ein gemeinsamer Kommentar
empfehlenswert):

@@smallexample
function Pos             (const SubString, s: String): Integer;
function LastPos         (const SubString, s: String): Integer;
function PosCase         (const SubString, s: String): Integer;
function LastPosCase     (const SubString, s: String): Integer;
function CharPos         (const Chars: CharSet; const s: String): Integer;
function LastCharPos     (const Chars: CharSet; const s: String): Integer;
function PosFrom         (const SubString, s: String; From: Integer): Integer;
function LastPosTill     (const SubString, s: String; Till: Integer): Integer;
function PosFromCase     (const SubString, s: String; From: Integer): Integer;
function LastPosTillCase (const SubString, s: String; Till: Integer): Integer;
@@end smallexample

Ebenfalls möglich:

@@smallexample
procedure Foo;
function  Bar @@dots{};
procedure Baz;
@@end smallexample

Und natürlich:

@@smallexample
const
  FooBar = 1;
  Baz    = 2;
  Quux   = 3;
@@end smallexample

Dieselbe ``Tabellenanordnung'' kann man für Initialisierungen
gebrauchen:

@@smallexample
const
  Foo: TBarArray =
    (('Foo'    ,  3),
     ('Bar baz', 42),
     (''       , -1));
@@end smallexample

Und in @@samp{case}-Anweisungen:

@@smallexample
case ReadKeyWord of
  kbLeft    : if s[n] > l    then Dec (s[n]) else s[n] := m[n];
  kbRight   : if s[n] < m[n] then Inc (s[n]) else s[n] := l;
  kbUp      : if n > 1 then Dec (n) else n := 5;
  kbDown    : if n < 5 then Inc (n) else n := 1;
  kbHome    : s[n] := l;
  kbEnd     : s[n] := m[n];
  kbPgUp,
  kbCtrlPgUp: n := 1;
  kbPgDn,
  kbCtrlPgDn: n := 5;
  kbCR      : Done := True;
end
@@end smallexample

Und auch je nach Geschmack in anderem Code:

@@smallexample
WriteCharAt (1, 1, 1,     Frame[1], TextAttr);
WriteCharAt (2, 1, w - 2, Frame[2], TextAttr);
WriteCharAt (w, 1, 1,     Frame[3], TextAttr);
@@end smallexample

@@node Zeilenumbrüche
@@section Wo man seine Zeilen umbrechen sollte
@@cindex Zeilenumbrüche

Zeilenumbrüche sind nach @@emph{lokalen} @@samp{const}-, @@samp{type}-
und @@samp{var}-Deklarationen freigestellt, wenn sie nur eine
einzige Deklaration beinhalten (Sie können auch mehrere Bezeichner
in einer Zeile deklarieren/definieren):

@@smallexample
procedure Baz;
var Foo, Bar: Integer;
begin
  @@dots{}
end;
@@end smallexample

Das geht auch:

@@smallexample
procedure Baz;
var
  Foo, Bar: Integer;
begin
  @@dots{}
end;
@@end smallexample

Aber bitte nicht so:

@@smallexample
procedure Baz;
var Foo, Bar: Integer;
    Qux: Real;
begin
  @@dots{}
end;
@@end smallexample

Wenn Sie viele Deklarationen haben, so können Sie Zeilenumbrüche
auf verschiedene Weisen vornehmen. Folgendes Beispiel ist die
bevorzugte Fassung für @@samp{var}-Deklarationen:

@@smallexample
var
  Foo, Bar, Baz, Qux, Quux, Corge, Grault, Garply, Waldo, Fred,
    Plugh, Xyzzy, Thud: Integer;
@@end smallexample

oder:

@@smallexample
var
  Foo, Bar, Baz, Qux, Quux, Corge, Grault, Garply, Waldo: Integer;
  Fred, Plugh, Xyzzy, Thud: Integer;
@@end smallexample

Die folgende Form ist eher bei der Definition von @@samp{record}-
oder öffentlichen @@samp{object}-Feldern gebräuchlich, besonders,
wenn jeder Zeile ein Kommentar folgt:

@@smallexample
var
  Foo,
  Bar,
  Baz,
  Qux: Integer;
@@end smallexample

Kein Zeilenumbruch darf nach @@samp{var}-Deklarationen
innerhalb von Blöcken erfolgen. Solche Zeilenumbrüche setzen das
falsche Signal, daß hier mehrere Deklarationsgruppen erlaubt wären:

@@smallexample
Foo := Bar;
var Baz: array [1 .. Foo] of Integer;
@@end smallexample

Da dieses Statement eine GNU Pascal Erweiterung ist, sollte es
selten eingesetzt werden, bei Variablen, deren Größe erst innerhalb
der Routine berechnet wird oder für Variablen innerhalb von
Modul-/Unit-Initialisierungen beispielsweise, um dafür keine
globalen Variablen zu benötigen. Denken Sie bitte bei der Anwendung
dieses Features über Unterroutinen nach.

@@cindex Einrückung von Labeln
Fügen Sie bitte keinen Zeilenumbruch nach @@samp{label} durch. Sie
sollten Label folgendermaßen deklarieren:

@@smallexample
label Foo, Bar, Baz;
@@end smallexample

So sollten Sie es auf keinen Fall tun:

@@smallexample
label
  Foo,
  Bar,
  Baz;
@@end smallexample

Verschiedene Deklarationen von Labeln in unterschiedlichen Zeilen
funktionieren auch nicht:

@@smallexample
label
  Foo;
  Bar;
  Baz;
@@end smallexample

@@cindex Case und der Zeilenumbruch
Hier folgt ein Beispiel, wie man innerhalb eines
@@samp{case}-Blockes Zeilen umbricht:

@@smallexample
case
  foo:
    begin
      @@dots{}
    end;
  bar,
  baz .. qux:
    @@dots{}
  else
    @@dots{}
end;
@@end smallexample

Oder auch ``tabellarisch'':

@@smallexample
case
  foo:        begin
                @@dots{}
              end;
  bar,
  baz .. qux: @@dots{}
  else        @@dots{}
end;
@@end smallexample

@@cindex Umbruch langer Zeilen
Lange Zeilen sollten immer vor oder immer nach Operatoren, sowie
nach Kommata umbrochen werden, wobei die Einrückung die
Gruppierungen verdeutlichen sollte:

@@smallexample
if (x = y)
   and (foo
        or (bar
            and (baz or qux))
        or fred) then
@@end smallexample

Oder so:

@@smallexample
if (x = y) and
   (foo or
    (bar and
     (baz or qux)) or
    fred) then
@@end smallexample

@@cindex if then else Anweisungen und Zeilenumbrüche
Hier sehen Sie, wie Sie Zeilenumbrüche innerhalb von if-then-else
Anweisungen vornehmen können. Diese Art der Einrückung sollte auch
verwendet werden, wenn Sie die @@samp{case}-Anweisung verwenden
würden, dies aber nicht möglich ist (weil die Typen nicht aufzählbar
sind, oder die Werte nicht konstant sind oder ein Vergleich die
Benutzung einer Funktion wie @@samp{StrEqualCase} notwendig machen
würde, oder zusätzliche Bedingungen auftauchen):

@@smallexample
if @@dots{} then
  a
else if @@dots{} then
  b
else
  c
@@end smallexample

Wenn @@samp{a} und ``nicht @@samp{a}'' die Hauptfälle sind und
@@samp{b} und @@samp{c} Unterfälle von ``nicht @@samp{a}'', so benutzen
Sie bitte die folgende Form (die Unterscheidung ist manchmal
Geschmackssache):

@@smallexample
if @@dots{} then
  a
else
  if @@dots{} then
    b
  else
    c
@@end smallexample

Das folgende (biologisch gesehen ziemlich unvollständige) Beispiel
enthält eine Mischung beider Formen, die wir für vernünftig halten:

@@smallexample
if Wohnort = 'Wasser' then
  @@{ Im Wasser lebende Tiere @@}
  WriteLn ('Ist es ein Fisch?')
else if Wohnort = 'Luft' then
  @@{ Lufttiere @@}
  WriteLn ('Ist es ein Vogel?')
else
  @@{ Landlebewesen @@}
  if Beine = 8 then
    WriteLn ('Ist es eine Spinne?')
  else
    WriteLn ('Ist es ein Gnu?')
@@end smallexample

Die Hauptfälle werden hier durch den Wohnort bestimmt, die Anzahl
der Beine bestimmen einige untergeordnete Fälle.

@@cindex Schleifen
Hier eine kurze Zusammenfassung der normalen Schleifen:

@@smallexample
for @@dots{} do
  @@dots{}
@@end smallexample

@@smallexample
while @@dots{} do
  @@dots{}
@@end smallexample

@@smallexample
repeat
  @@dots{}
until @@dots{}
@@end smallexample

Wenn nur eine einzelne Anweisung nach @@samp{if} oder in einer
@@samp{do}- oder @@samp{for}-Schleife bzw. zwischen @@samp{repeat} und
@@samp{until} existiert und diese Anweisung kurz genug für eine Zeile
ist, so darf diese Anweisung in eine Zeile wie folgt geschrieben
werden:

@@smallexample
if @@dots{} then @@dots{}
@@end smallexample

@@smallexample
for @@dots{} do @@dots{}
@@end smallexample

@@smallexample
while @@dots{} do @@dots{}
@@end smallexample

@@smallexample
repeat @@dots{} until @@dots{}
@@end smallexample

Wenn mehrere Anweisungen mit @@samp{begin} und @@samp{end} in einen
Block gefaßt werden, sieht es folgendermaßen aus:

@@smallexample
if @@dots{} then
  begin
    @@dots{}
  end
@@end smallexample

@@smallexample
for @@dots{} do
  begin
    @@dots{}
  end
@@end smallexample

@@smallexample
while @@dots{} do
  begin
    @@dots{}
  end
@@end smallexample

@@cindex Einrückung
Es wird nach folgenden Ausdrücken 2 Leerzeichen eingerückt:
@@samp{begin}, @@samp{then}, @@samp{else}, @@samp{case}, @@samp{do}
(@@samp{for}, @@samp{while}, @@samp{with}, @@samp{to begin},
@@samp{to end}), @@samp{repeat}, @@samp{record}, @@samp{object},
@@samp{type}, @@samp{const}, @@samp{var}, @@samp{label}.

Globale Routinen und ihre lokalen Variablen etc. werden nicht
eingerückt, ebenso wie globale Variablen etc. Jede Subroutine (Kopf
und Körper sowie ihre lokalen Variablen etc.) soll eingerückt
werden.

@@smallexample
program Prog;

var
  GlobalVar: Integer;

procedure GlobalProc;
var LocalVar: Integer;

  procedure LocalProc;
  var LocalLocalVar: Integer;
  begin
    WriteLn ('Dies ist eine lokale Prozedur.')
  end;

begin
  WriteLn ('Dies ist eine globale Prozedur.')
end;

begin
  WriteLn ('Dies ist das Hautpprogramm.')
end.
@@end smallexample

Variante Records sollten so eingerückt werden:

@@smallexample
type
  Foo = record
    NonVariant: Foo;
  case Discriminant: Bar of
    Val1: (Variant1: Baz;
           Variant2: Qux);
    Val2: (Variant3: Fred)
  end;

var
  Foo: record
    [ wie oben ]
  end = [ Initialisierung ]
@@end smallexample

Größere Einrückung (mehr als zwei Leerzeichen) kann bei
Zeilenumbrüchen im Code erfolgen, um einen ``tabularen'' Code
zu erzeugen.

Conditionale (@@samp{@@{$ifdef@@}}) sollten dieselbe Einrückung wie
der zugehörige Code haben:

@@smallexample
begin
  @@{$ifdef DEBUG@@}
  WriteLn ('Debugging-Version');
  @@{$endif@@}
  @@dots{}
end;
@@end smallexample

Kurze Conditionale, die sich nur auf einen Ausdruck beziehen, dürfen
auch in eine Zeile geschrieben werden:

@@smallexample
Foo := @@{$ifdef DEBUG@@} 'Debugging' @@{$else@@} 'Veröffentlichung' @@{$endif@@};
@@end smallexample

Wenn Conditionale beabsichtigterweise entgegen den normalen
syntaktischen Regeln genutzt werden, so setzen Sie diese an
passende Stellen und schreiben Kommentare dazu:

@@smallexample
begin
  @@{ Führe den Code bedingungslos aus, wenn wir debuggen @@}
  @@{$ifndef DEBUG@@}
  if EinigeBedingungen then
  @@{$endif@@}
    begin
      @@dots{}
    end
end;
@@end smallexample

Oftmals finden Sie schönere und nicht weniger effiziente Wege,
dasselbe zu schreiben. In diesem Fall kann es auch so erfolgen:

@@smallexample
begin
  if @@{$ifdef DEBUG@@} True @@{$else@@} EinigeBedingungen @@{$endif@@} then
    begin
      @@dots{}
    end
end;
@@end smallexample

Oder noch besser:

@@smallexample
@@{ global @@}
const
  DebugFlag = @@{$ifdef DEBUG@@} True @@{$else@@} False @@{$endif@@};

begin
  if DebugFlag or EinigeBedingungen then
    begin
      @@dots{}
    end
end;
@@end smallexample

@@node Strings
@@section Zeichenketten
@@cindex Strings
@@cindex Zeichenketten

Die meisten der bisherigen Regeln gelten nicht innerhalb von
Strings. Allgemein sollten Textausgaben innerhalb von Zeichenketten
den GNU Coding Standards folgen. Beispielsweise sollten zitierte
Namen von @@samp{`} und @@samp{'} begrenzt werden. In Pascal bedeutet
das, daß Sie doppelte @@samp{'} benutzen müssen. Mehr Informationen:
@@xref{Errors, , , standards}.

Normalerweise sollten Strings in einfachen Anführungszeichen
so wie @@samp{'dieser schöne Satz, den Sie lesen'} eingeschlossen
sein. Mit doppelten Anführungszeichen sollen nur Zeichenketten
umfaßt werden, die C-Escape-Sequenzen beinhalten, wie
@@samp{"\t"}. Beachten Sie bitte, daß @@samp{NewLine} (@@samp{"\n"})
vordefiniert ist. Geben Sie daher @@samp{NewLine} den Vorzug, wenn
Sie nicht gerade C-Strings für andere Zwecke benötigen.

Mehrzeilige Strings können folgendermaßen genutzt werden:

@@smallexample
WriteLn ('Hallo
Welt!')
@@end smallexample

Oder (diese Form ist vor allem dann vorzuziehen, wenn der String
selbst Einrückungen und/oder Absätze enthält):

@@smallexample
WriteLn (
'Hallo
Welt!')
@@end smallexample

Folgendes ist auch möglich:

@@smallexample
WriteLn ('Hallo' + NewLine + 'Welt!')
@@end smallexample

(Beachten Sie, daß obiger Code nicht ohne die Unit @@code{GPC}
kompiliert werden kann.)

Oder natürlich:

@@smallexample
WriteLn ('Hallo');
WriteLn ('Welt!')
@@end smallexample

Wenn Sie testen möchten, ob ein String leer ist, benutzen Sie
folgende Syntax:

@@smallexample
if s = '' then
  @@dots{}
@@end smallexample

Der GNU Pascal Compiler optimiert dies automatisch zu folgendem
schnelleren Test. Daher können Sie den vorhergehende, kürzere
Schreibweise ohne Bedenken verwenden:

@@smallexample
if Length (s) = 0 then
  @@dots{}
@@end smallexample

Dasselbe gilt natürlich auch für @@samp{<>} und sogar für
Zuweisungen, bei denen @@samp{s := ''} die empfohlene Form ist,
welche von GPC intern zu @@samp{SetLength (s, 0)} optimiert wird.

@@node Internationalisierung
@@section Techniken zur Internationalisierung
@@cindex Internationalisierung

Bitte beachten Sie die entsprechende Beschreibung in der
GPC-Dokumentation (@@pxref{I18N, , , gpc}).

@@node MemoryMap
@@section MemoryMap
@@findex MemoryMap

Dieser Abschnitt der GNU Coding Standards kann so, wie er ist,
auf GNU Pascal übertragen werden.
Beachten Sie, daß @@samp{mmap} hier @@samp{MemoryMap} bedeutet.
@@xref{Mmap, , , standards}.

@@node Dokumentation
@@chapter Programme dokumentieren
@@cindex dokumentieren

Wir empfehlen Ihnen, das entsprechende Kapitel der GNU Coding
Standards zu lesen @@xref{Documentation, , , standards}, die
dortigen Informationen gelten auch für GNU Pascal. Einige
Anmerkungen haben wir aber trotzdem.

Es wäre schön, eine Man-Page für jedes Programm zu haben. Diese
Man-Page sollte auf eine Info-Dokumentation verweisen. Es existiert
ein GNU Programm namens @@samp{help2man}, welches Man-Pages aus der
Ausgabe der @@samp{--help}- und @@samp{--version}-Optionen Ihres
Programmes generiert. Es funktioniert gut, bis auf die Tatsache, daß
es @@samp{FSF} an den Anfang der Man-Page schreibt, was nicht für
jedes mit dem GNU Pascal Compiler erzeugte Programm richtig ist.
Dies kann jedoch leicht mit der Hand oder automatisch mit einem
Programm wie @@samp{sed} geändert werden.

Geben Sie sich mit den Man-Pages nicht zuviel Mühe. Sie
gleichzeitig mit der Texinfo-Dokumentation auf dem neusten Stand
zu halten, bedeutet eine Menge Arbeit und ist möglicherweise sehr
fehlerträchtig. Wenn Sie die Man-Page nicht auf dem neuesten Stand
halten, so schafft sie mehr Verwirrung als Nutzen.

Auf der einen Seite fehlen wichtige Informationen, wenn Man-Pages
zu knapp ausfallen, auf der anderen Seite werden längere Man-Pages
sehr unübersichtlich.

Mit anderen Worten: Schreiben Sie Info- (bzw.
Texinfo-)Dokumentation!

@@node Veröffentlichungen
@@chapter Der Verlauf der Veröffentlichung
@@cindex Veröffentlichung des Programmes

Bitte lesen Sie das entsprechende Kapitel der GNU Coding
Standards. Beachten Sie, daß der ganze Aufwand mit den auto-Tools
(@@samp{autoconf}, @@samp{automake}, @@dots{}) im Rahmen von GNU
Pascal normalerweise nicht gebraucht werden. Außerdem sind Makefiles
in GNU Pascal Programmen nicht immer notwendig.
@@xref{Managing Releases, , , standards}.

@@menu
* Makefile-Regeln::           Wie man Makefiles schreibt
@@end menu

@@node Makefile-Regeln
@@section Wie man Makefiles schreibt
@@cindex Makefile-Regeln

Für Ihre Pascal-Projekte benötigen Sie keine großen @@samp{Makefile}s
und Sie brauchen sich ebenfalls nicht in @@samp{autoconf} und
@@samp{automake} einzuarbeiten. Sie brauchen nur die
Kommandozeilenoption @@samp{--automake}. Alles Weitere erledigt GNU
Pascal für Sie! (Zum Zeitpunkt des Schreibens hat GNU Pascal
einige kleinere Bugs im Zusammenhang mit der
@@samp{automake}-Option. Diese Fehler werden aber nachgebessert.
Außerdem wird gerade an einem Utility namens @@samp{gp} gearbeitet,
welches Ihnen noch mehr Arbeit beim Kompilieren abnimmt.)

Ein @@emph{einfaches} Makefile wie das folgende mag angebracht sein:

@@smallexample
GPC_FLAGS=-O2

all: foo

foo: foo.pas unit1.pas
	gpc --automake $(GPC_FLAGS) foo.pas

mostlyclean:
	-rm -f *.o *.gpi *.gpd core

clean: mostlyclean
	-rm -f foo

distclean: clean

extraclean: distclean
	-rm -f *~*

maintainer-clean: extraclean
@@end smallexample

Sie wollen vielleicht dem @@samp{Makefile} noch weitere Regeln
hinzufügen, sei es zur Erstellung der Dokumentation, Datendateien,
Paketen zur Veröffentlichung oder zu was auch immer. Diese Dinge
liegen außerhalb des Rahmens dieses Textes. Die Kompilierung eines
GNU Pascal Programmes erfolgt normalerweise mit
@@samp{gpc --automake}.

@@node Glossar
@@chapter Glossar der Worte in diesem Text
@@cindex Glossar

Routinen sind Prozeduren (@@samp{procedure}), Funktionen
(@@samp{function}), Objeckt-Konstruktoren (@@samp{constructor}) und
-Destruktoren (@@samp{destructor}) sowie (selbstdefinierte)
Operatoren.

Deklarationen sind diejenigen Bereiche des Programmes, die die
Eigenschaften irgendwelcher Objekte ``erklären'', wie Konstanten,
Typen, Variablen, Units, Module, und selbstverständlich das
Programm.

Anweisungen bzw. Statements sind solche Teile des Programmes, die
irgendetwas ``veranlassen''. Eine einzelne Anweisung ist eine
Zuweisung (assignment), der Aufruf einer Prozedur (procedure call),
ein Sprungbefehl (@@samp{goto}, @@samp{Exit}, @@samp{Return},
@@samp{Break}, @@samp{Continue}), eine Assembler-Anweisung oder
eine zusammengesetzte Anweisung (@@samp{begin} @@dots{} @@samp{end},
@@samp{if}, @@samp{case}, @@samp{repeat}, @@samp{while}, @@samp{for},
@@samp{with}), die ihrerseits wieder verschiedene Anweisungen
enthalten dürfen.

Bezeichner (identifiers) sind Sprachelemente, die Objekten
(Routinen, Konstanten, Variablen, Typen, Units oder Modulen) ihre
Namen geben. Sie können lokal umdefiniert werden, anders als
Schlüsselwörter (keywords), die Teil einer festen Syntax sind
(beispielsweise @@samp{if} @@dots{} @@samp{then} @@dots{} @@samp{else})
und nicht umdefiniert werden können. Makros sind keine
Sprachelemente, da sie niemals vom Compiler verarbeitet werden,
sondern von einem Präprozessor.

Endianess ist ein Begriff, der sich auf die Reihenfolge der
Anordnung der höher- und niederwertigen Bytes bezieht. Diese
Reihenfolge ist auf manchen Systeme anders als auf anderen. Schauen
Sie sich bitte die Erklärung dazu im GPC-Info Dokument an
(@@pxref{Endianness, , , gpc}).

@@emph{Hinweis:} Andere Begriffe können hier eingefügt werden,
sobald es sinnvoll erscheint. Wenn Sie die Definition eines
Ausdruckes wissen möchten, so teilen Sie es uns bitte mit.

@@node Index
@@unnumbered Index
@@printindex cp

@@contents

@@bye
@


1.2
log
@• ensure all texinfo-generated HTML pages are UTF-8
• iconv all those from GNU Pascal
• warn loudly in makeinfo when not
• use utf-8 as encoding in .htaccess in manINFO/
@
text
@d401 1
a401 1
wurden. (@@pxref{GPC Units, , , GPC}) Die Units @@samp{CRT}
@


1.1
log
@Initial revision
@
text
@a3 1
@@documentencoding iso-8859-1
d83 1
a83 1
Letzte nderung @@value{lasttranslationupdate}.
d88 1
a88 1
* Vorwort::                   ber die GNU Pascal Coding Standards
d90 1
a90 1
* Gestaltungsratschlge::     Allgemeine Projektgestaltung
d92 1
a92 1
* Pascal Programmieren::      Ratschlge zur Gestaltung des Quelltextes
d94 1
a94 1
* Verffentlichungen::        Der Verlauf der Verffentlichung
d100 1
a100 1
@@chapter ber die GNU Pascal Coding Standards
d102 2
a103 2
Vorwort des bersetzers:
Dieses Dokument enthlt die bersetzung der
d106 3
a108 3
nach die Lesbarkeit des Textes frdert. Fr Fehler in der
bersetzung bin ich verantwortlich, nicht die ursprnglichen
Autoren. Fr Rckfragen zur bersetzung bin ich erreichbar unter:
d110 1
a110 1
Goretzki fr seine unermdliche Arbeit, dieses Dokument vom
d113 2
a114 2
Trotz aller Sorgfalt lassen sich Fehler in der bersetzung nicht
ganz ausschlieen. In Konfliktfllen gilt stets das englische
d116 1
a116 1
wir sie beheben knnen.
d121 3
a123 3
Informationen fr Pascal-Programmierer zu ergnzen. Die
Informationen in den GNU Coding Standard beziehen sich zu groen
Teilen auf die Programmiersprache C. Gleichsam erklren sie jedoch
d125 3
a127 3
robuster und zuverlssiger Programme ntzlich sind. Die meisten
dieser Regeln knnen mit wenigen Anmerkungen versehen aus dem
Dokument bernommen werden, weswegen sich Referenzen zu den GNU
d136 1
a136 1
erhltlich -- in Binrdistributionen als Info-Dateien, in
d143 1
a143 1
@@cindex Beitrge zum Dokument
d145 2
a146 2
Berichtigungen oder Vorschlge zu diesem Dokument knnen Sie direkt
beim Autor einreichen: @@email{eike@@@@g-n-u.de}. Fr das
d150 1
a150 1
Vorschlge den genderten Text enthalten. Ein ``context diff'' der
d167 1
a167 1
wie man sich versichert, da GNU Software rechtliche
d170 1
a170 1
@@node Gestaltungsratschlge
d174 1
a174 1
Dieses Kapitel beschftigt sich mit einigen grundlegenden Themen
d188 2
a189 2
Wir untersttzen die Idee, da die Vielfalt der Programmiersprachen
etwas Gutes ist. Verschiedene Programmiersprachen sind ntzlich fr
d192 2
a193 2
berzeugen, da Sie C oder Pascal oder eine andere einzelne
Programmiersprache fr alles nutzen sollten.
d195 3
a197 3
Wenn Sie das lesen, dann haben Sie sich mglicherweise schon bei
einigen Projekten fr Pascal entschieden oder ziehen dies in
Erwgung. Dieses Dokument will Ihnen Vorschlge unterbreiten,
d206 1
a206 1
Sie knnen eine C-Bibliothek oder eine C-Objektcode-Datei mit Ihrem
d215 4
a218 4
C-Bilbiothek aufzurufen. Der Grund dafr ist die Portabilitt. Eines
Tages knnte es nderungen an der zu linkenden Bibliothek geben, die
direkte @@samp{external}-Deklarationen gefhrden. Sie sollten dann
die Wrapper anpassen, so da Pascal Programme mit jeder Version
d221 2
a222 2
Bei der Arbeit mit groen Paketen kann es passieren, da
die Kompatibilitt zwischen Versionen einer Library und dem
d224 2
a225 2
kann man direkt zur Bibliothek linken, mit der man arbeiten mchte, und
bindet ebenso eine ergnzende Datei hinzu, die ausschlielich der
d239 2
a240 2
@@samp{>}, um eine sehr przise Versionskontrolle durchzufhren.
Bitte beachten Sie auch, da dieses Verfahren nur dann anwendbar
d242 1
a242 1
d.h. es lt sich mit einer Bibliothek wie GTK, aber nicht mit libc,
d245 3
a247 3
@@cindex Header-bersetzung
Ein automatischer Header-bersetzer ist geplant. Dieses Werkzeug
wrde das Schreiben von Wrapperfunktionen berflssig machen. Das
d249 2
a250 2
niemand ist sich wirklich sicher, ob sie berhaupt durchfhrbar ist.
Wann ein solches Programm verfgbar sein wird, ist ungewi.
d253 5
a257 5
Sie knnen annehmen, da der GNU C Compiler benutzt wird, um die Wrapper,
und, allgemein, jedes bichen C-Code zu bersetzen, das Sie Ihrem
Programm hinzufgen.
Der Grund fr diese Annahme ist, da nur der GNU C Compiler
garantiert, da alle Konventionen kompatibel zum GNU Pascal Compiler
d259 1
a259 1
Pascal Compiler teilen sich dasselbe Backend. Auerdem wird der GNU
d261 1
a261 1
ist @@samp{gcc} berall dort vorhanden, wo auch @@samp{gpc}
d268 3
a270 3
GNU Pascal hat viele Mglichkeiten, die Standard Pascal nicht bietet.
Ob diese Mglichkeiten in einem Programm genutzt werden sollen, ist
eine zu hufig diskutierte Frage.
d272 2
a273 2
Auf der einen Seite kann das Benutzen dieser Mglichkeiten zu
effizienteren oder bersichtlicheren Programmen fhren. Auf der
d276 1
a276 1
Programmes auf Systemen unmglich, auf denen dieser Compiler nicht
d279 1
a279 1
Im allgemeinen ist es das beste, Kompatibilitt zu anderen Compilern
d281 1
a281 1
Kompatibilitt einfach zu erhalten ist}. Leider ist dies jedoch
d283 1
a283 1
viele eingefgte @@samp{@@{$ifdef@@}}s, um alle nicht-Standard-Compiler
d285 1
a285 1
warten macht. Auerdem sind @@samp{@@{$ifdef@@}}s selbst nicht
d289 4
a292 4
Kompatibilitt stren. Alles am GNU Pascal Compiler ist offen
(Compiler und Laufzeit-System). Das bedeutet, da das gesamte
Interface bei Bedarf fr andere Compiler verfgbar gemacht werden
kann. Dazu knnen sogar einfach die Quelltexte bernommen werden,
d294 1
a294 1
mehr ber die GNU General Public License:
d296 2
a297 2
eine Zerstckelung des Codes. Ein (begrenztes) Beispiel dieser
Strategie kann in der @@samp{gpc-bp}-Unit (fr Borland Pascal)
d299 1
a299 1
meistens einfach, diese Unit um zustzliche Features zu erweitern.
d302 2
a303 2
nicht, die lediglich aus Grnden der Rckwrtskompatibilitt
eingefhrt wurden:
d307 1
a307 1
Kommentare der Form @@samp{(* *)} fr alte Terminals, wo es die
d312 1
a312 1
Wenn eine Datei auch in C genutzt werden mu, so darf sie die
d315 2
a316 2
Gegenwrtig gibt es dazu das folgende Beispiel (das kann sich in
Zukunft ndern): @@file{p/rts/constants.h} in den GNU Pascal Compiler
d320 1
a320 1
den Mibrauch der typisierten Konstanten als Variablen, was eine
d328 1
a328 1
@@samp{CString}s (auer natrlich fr C-Schnittstellen)
d340 1
a340 1
die meisten Flle von @@samp{FillChar} und @@samp{Move}, auer fr
d348 1
a348 1
um einen String zu leeren ist falsch in GNU Pascal und auerdem
d355 1
a355 1
Dieses Beispiel ndert lediglich das Lngenfeld des Strings
d359 2
a360 2
die meisten Flle von @@samp{GetMem} und @@samp{FreeMem}, die
normalerweise ein Work-Around fr fehlende Schemata in anderen
d364 1
a364 1
die meisten Flle untypisierter Parameter.
d370 1
a370 1
Mglichkeiten der @@samp{GPC}-Unit, um einen portablen Weg
d374 1
a374 1
Assembler-Code. Auer natrlich in seltenen Fllen, wo es um
d376 2
a377 2
@@samp{@@{$ifdef@@}} (z.B. fr den Prozessortyp) eingekapselt
werden. Untersttzen Sie in einem solchen Fall auch bitte
d385 1
a385 1
Annahmen ber Typengren.
d388 3
a390 3
Annahmen ber ``Endianness''. (Einige Systeme verwenden fr die
Anordnung von hher- und niederwertige Bytes eine andere Reihenfolge
als andere Systeme.) [Anm. d. bersetzers: Die Begriffe ``Little
d392 1
a392 1
bersetzen. Schauen Sie ins Glossar (@@pxref{Glossar}), um mehr ber
d400 1
a400 1
Units, die nur zur Kompatibilitt mit Borland Pascal geschrieben
d402 1
a402 1
und @@samp{Printer} hingegen dienen sowohl der Kompatibilitt
d414 1
a414 1
Schreiben stabiler Programme. Auerdem gibt es Richtlinien zur
d425 1
a425 1
getroffen, so da Sie sich nicht mehr darum kmmern mssen.
d429 1
a429 1
Verhalten bei Fehlerabfragen, die einen ``unmglichen'' Zustand
d431 1
a431 1
Dies wrde implizieren, da der Anwender ein Programmierer ist,
d434 1
a434 1
herauszugeben, die es dem Anwender ermglicht, eine
d437 3
a439 3
Die GNU Coding Standards schlagen auerdem vor, jeden
Funktionsaufruf auf Fehlerrckgaben zu berprfen. Dieser
Vorschlag pat durchaus zu C, jedoch nicht unbedingt zu Pascal.
d441 5
a445 5
durchgefhrt, somit brauchen Sie sich in vielen Fllen nicht
darum zu kmmern. Viele I/O-Routinen geben Ihnen nicht einmal einen
Rckgabewert (beispielsweise @@samp{Reset}). Diejenigen
Fehlerwerte, die zurckgegeben werden, sollten aber auch
berprft werden.
d447 2
a448 2
Sie knnen die automatischen Fehlerabfragen ausschalten und sich
selber darum kmmern. Tatschlich ist es so, da manche Fehler das
d451 1
a451 1
Mglichkeit einrumen, die Ursache des Fehlers zu beheben. Um das zu
d455 2
a456 2
(@@pxref{InOutRes, , , gpc}). Beachten Sie bitte, da I/O-Routinen
sofort zurckkehren, whrend @@samp{InOutRes} gesetzt ist, so da es
d458 1
a458 1
Folgendes wird dadurch mglich:
d475 2
a476 2
Es kann jedoch ntzlich sein, nach @@samp{Rewrite} und anderen
Aufrufe zum ffnen auf Fehler zu testen, denn dort treten die
d478 1
a478 1
Aufrufe oftmals unntig.
d480 2
a481 2
Die GPC-Unit enthlt eine Menge Routinen fr den Umgang mit
Temporrdateien, Konfigurationsdateien und vielen anderen
d483 2
a484 2
Routinen liegt darin, da sie unter verschiedenen Betriebssystemen
laufen (zum Beispiel DOS und Unix) und da evtl. dateinamenbezogene
d486 1
a486 1
behoben werden knnen. Das ist besser, als verschiedene Stellen
d490 1
a490 1
Routine in einer einzigen Datei unterzubringen. Wir hoffen, da der GNU
d492 4
a495 4
Gegenwrtig, so glauben wir, ist Programmiererfreundlichkeit sinnvoller
als die Gre der ausfhrbaren Datei. Auerdem empfehlen wir, auf
Namens-Prfixe zu verzichten. Namenskonflikte knnen stattdessen
durch qualifizierte Bezeichner (@@samp{UnitName.RoutinenName}) gelst
d499 1
a499 1
@@chapter Ratschlge zur Gestaltung des Quelltextes
d501 2
a502 2
Dieses Kapitel gibt Ihnen Ratschlge, wie Sie Ihre Quelltexte gestalten
sollten. Diese Regeln gelten eigentlich nur fr verffentlichten
d505 5
a509 5
schreiben mchten, so geht das natrlich vorbergehend, bei der
Verffentlichung sollten Sie dann allerdings unsere diesbezglichen
Ratschlge beherzigen. Da man aber niemals wissen kann, ob und wann man
den Code verffentlicht, ist es vorzuziehen, sich von vornherein an
diese Ratschlge zu halten.
d513 2
a514 2
* Konsitenzberprfung::        ber die Benutzung von @@code{Assert}, um
                                abzubrechen, wenn etwas ``Unmgliches''
d519 1
a519 1
* Groschreibung::              Groschreibung
d522 1
a522 1
* Zeilenumbrche::              Wo man seine Zeilen umbrechen sollte
d556 1
a556 1
Beachten Sie, da dieses Vorgehen anders ist als in C, wo
d559 1
a559 1
Vermeiden Sie @@samp{goto} und hnliche Statements, wie @@samp{Exit},
d561 1
a561 1
@@samp{goto} um jeden Preis (auer @@emph{mglicherweise} ein
d565 4
a568 4
mit vertretbarem Aufwand mglich ist. Wenn Sie aber dafr eine
weitere @@samp{Boolean}-Variable einfhren mssten, so darf dies als
Entschuldigung fr das Benutzen dieser Statements gelten.
Beachten Sie, da Code oftmals @@emph{einfacher} wird, wenn Sie auf
d572 1
a572 1
Niemals sollten Sie die @@samp{for}-Zhlvariable verndern oder dem
d582 2
a583 2
dessen Inhalt immer noch gltig zu sein scheint oder die oben
besprochenen @@samp{for}-Zhlvariablen. Nichts von all dem ist
d585 3
a587 3
gendert werden. Undefiniert ist eben undefiniert. Und der
Eindruck, da solche Dinge bei 42 anderen Compilern zu
funktionieren scheinen, ist dabei vllig belanglos!
d589 1
a589 1
Bei Vergleichen sollte die sich hufiger ndernde Variable auf der
d599 3
a601 3
In diesem Beispiel ndert sich @@samp{a[i]} hufiger als @@samp{Foo}
und @@samp{b[j]} ndert sich hufiger als @@samp{a[i]} (da @@samp{j}
sich hufiger als @@samp{i} ndert).
d603 2
a604 2
Wir nehmen bei diesem Beispiel an, da @@samp{Foo} konstant ist. Wenn
@@samp{Foo} ebenfalls von @@samp{i} abhngt, so kann es angebracht
d606 1
a606 1
aber durch einen Kommentar erlutert werden.
d612 2
a613 2
so, da er erweitert werden kann. Packen Sie schlaue Tricks nicht an
Stellen, die Sie spter ndern wollen.
d658 1
a658 1
Schreiben Sie keine ungenutzten Deklarationen, auer
d660 1
a660 1
werden knnen.
d669 1
a669 1
das sieht auch hbscher aus. Ein anderes Beispiel ist
d673 1
a673 1
Vermeiden Sie doppelte globale Bezeichner, berladen Sie eingebaute
d675 1
a675 1
wrde. Benutzen Sie dieselben globalen Bezeichner auch nicht in
d677 1
a677 1
Bezeichner'' wre dies fr den Compiler kein Problem, aber fr den
d681 2
a682 2
Wir raten davon ab, globale Variablen fr nicht-globale Zwecke
einzusetzen, z.B. eine globale Variable @@code{Counter} als Zhler in
d684 2
a685 2
eine lokale Variable in jeder Routine, die eine bentigt. Dies
ermglicht i.a. auch eine bessere Optimierung des erzeugten Codes.
d689 1
a689 1
mglicherweise durch @@samp{Break} verlassen wird), empfehlen wir die
d691 2
a692 2
weil dadurch der Code weniger weit nach rechts eingerckt wird
(jedenfalls, sofern die Schleife mehr als eine Anweisung enthlt).
d710 3
a712 3
@@node Konsitenzberprfung
@@section Explizite berprfung der internen Konsistenz
@@cindex Konsitenzberprfung
d716 2
a717 2
Checking, , , libc}) erlutert, ist es hufig von Vorteil, grundlegende
Annahmen in eigenen Programmen zu berprfen.
d724 1
a724 1
Hierbei knnten Sie implizit annehmen, da diese Prozedur niemals mit
d726 1
a726 1
``unmgliche Bedingung'' zu berprfen, um sicher zu stellen, da
d737 2
a738 2
Wenn die berprfung fehlschlgt, dann erzeugt das Programm einen
Laufzeitfehler. Daraus lt sich der Schlu ziehen, da der Code, welcher
d740 1
a740 1
ergnzt werden sollte). Dieses Verfahren kann sich bei der Fehlersuche
d742 2
a743 2
am Anfang (oder einem anderen geeigneten Ort) einer Routine zu berprfen
stellt sicher, da eine Funktion oder Prozedur nicht falsch benutzt werden
d746 3
a748 3
Die GNU C-Bibliothek enthlt das @@code{assert}-Makro fr diese Art von
berprfungen. GNU-Pascals @@code{Assert} verhlt sich ein wenig anders.
@@code{Assert} bricht das Programm nicht vollstndig ab, sondern erzeugt
d753 1
a753 1
berprfung von @@code{Assert} abstellen, indem man das Programm mit
d755 1
a755 1
keine nderung ntig. Nebenwirkungen der Argumente von
d757 1
a757 1
in C), so da man weiterhin schreiben kann:
d763 2
a764 2
@@code{MeineFunktion} wird auf jeden Fall aufgerufen, die berprfung,
ob der Rckgabewert positiv ist, erfolgt jedoch nur, wenn
d767 1
a767 1
Wir empfehlen, die Konsistenzberprfung nie abzuschalten, sofern man den
d776 2
a777 2
Als erstes: Vermeiden Sie unntige Leerzeichen am Ende einer Zeile.
Vergewissern Sie sich auerdem, da Sie den Quelltext nicht mit
d781 1
a781 1
Dies gefhrdet Ihre mhsam erarbeitete Einrckung.
d783 1
a783 1
sehr ntzlich; wenn sie VIM benutzen, die Umgebungsoption
d788 2
a789 2
Bitte vermeiden Sie es, in Ihren Quelltext Steuerzeichen einzufgen
(auer NewLine, selbstverstndlich). Bitte auch keine Form-Feeds
d792 4
a795 4
@@samp{SUB}-Zeichen (@@samp{#26}), diese werden nmlich unter DOS
als Ende-der-Datei-Zeichen mibraucht. ltere DOS-Editoren
fgen dieses Zeichen an das Ende der Datei an, obwohl selbst das
FAT-Dateisystem selbst ber das Ende der Datei Bescheid wei.
d797 2
a798 2
@@cindex Zeilenlnge
Wir empfehlen eine maximale Lnge von 68 Zeichen pro Zeile, so da
d800 1
a800 1
werden kann. oder 78 Zeichen, geeignet fr 80 Zeichen breite
d805 1
a805 1
Benutzen Sie Leerzeilen zwischen Blcken. Blcke sind lange
d807 1
a807 1
Abschnitte, Routinen-Rmpfe, Unit- oder
d814 1
a814 1
Eine besondere Ausnahme ist zwischen den Blcken innerhalb
d834 1
a834 1
  Variablen, die von Sub genutzt werden knnen @@dots{}
d844 1
a844 1
  Variablen, die nicht von Sub genutzt werden knnen @@dots{}
d852 1
a852 1
Andernfalls wrde die Deklaration aussehen wie eine
d855 1
a855 1
Beachten Sie bitte, da wir im obigen Beispiel die lokalen Variablen
d859 2
a860 2
Alles, was wir ber Subroutinen gesagt haben, gilt
selbstverstndlich auch fr Sub-Subroutinen beliebiger
d869 1
a869 1
Leerzeilen knnen in langen Kommentaren Abstze teilen.
d889 1
a889 1
(* Ein hlicher Kommentar. So etwas braucht man nicht mehr! *)
d893 1
a893 1
doppelten Schrgzeichen eingeleitet werden und bis zum Ende der
d900 1
a900 1
Obwohl ISO Pascal gemischte Kommentare ausdrcklich erlaubt und
d902 1
a902 1
@@samp{@@{$mixed-comments@@}} auch nicht darber beschweren wrde,
d913 3
a915 3
wenn Sie @@TeX{} in einem Kommentar setzen wollen oder hnlich
exotische Dinge. Was auch immer Sie fr Grnde haben mgen, mssen
Sie diese Option dann zunchst mit der Direktive
d919 1
a919 1
bersetzen mchte, erst die bentigten Optionen erraten mu, und
d922 1
a922 1
wrden.
d926 2
a927 2
Sprache, die die meisten Programmierer in allen Lndern lesen
knnen. Wenn Sie sich im Englischen nicht fit genug fhlen, dann bitten
d929 1
a929 1
knnen.
d932 5
a936 5
Sie sollten sich ``French Spacing'' angewhnen, d.h. nur ein
Leerzeichen am Ende eines Satzes. Dabei knnen Sie in GNU Emacs
@@samp{M-a} und @@samp{M-e} nicht benutzen. Wir hoffen, da Sie das
verschmerzen knnen. Bitte lassen Sie nur ein Leerzeichen nach der
ffnenden und der schlieenden geschweiften Klammer des Kommentares
d942 3
a944 3
das mglich ist. Bitte lassen Sie zwei Leerzeichen Platz.
Dies ist ebenfalls fr den Interface-Bereich einer Unit und bei
globalen Variablen angemessen. Oftmals bentigt man diese Sorte
d952 1
a952 1
Oder etwas lnger:
d959 1
a959 1
Mit Abstzen:
d968 2
a969 2
Die Kommentare sollten gewhnlich vor den Code plaziert werden,
auf den sie sich beziehen. Sie erhalten dieselbe Einrckung:
d986 1
a986 1
    @@{ Schleifenkrper. @@}
d1006 1
a1006 1
Sie sollten Kommentare dadurch vermeiden, da Sie durchdachten
d1019 1
a1019 1
bersetzung:
d1022 4
a1025 4
Kommentare sind grundstzlich sinnvoll, aber es besteht die Gefahr
der ``berkommentierung''. @@strong{Niemals} sollten Sie im
Kommentar erklren, @@strong{wie} der Code arbeitet:
Es ist viel besser, offensichtlichen Code zu schreiben, so da
d1031 1
a1031 1
(Beachten Sie, da wir in anderen Bereichen ziemlich stark von seinem
d1039 6
a1044 6
Implikationen beinhaltet, bei dessen nderung etwas Spezielles
beachtet werden muss, der sich nicht so verhlt, wie es auf den
ersten Eindruck scheint, der Seiteneffekte enthlt oder es
erfordert, da andere Teile des Codes an anderer Stelle gleichzeitig
mit ihm gendert werden. Trickreicher Code sollte grundstzlich nur
in bescheidenem Mae benutzt werden.
d1047 1
a1047 1
In dem Fall, da sich ein Kommentar auf eine andere
d1051 2
a1052 2
Bezug nicht in Form von Zeilennummern an (diese ndern sich zu
hufig). Lassen Sie in den Kommentaren auerdem beide Stellen
d1062 1
a1062 1
Um logische Abschnitte innerhalb grerer Module oder Units zu
d1071 2
a1072 2
Beachten Sie, da in diesem Fall ausnahmsweise keine Leerzeichen
neben den geschweiften Klammern eingefgt werden.
d1076 1
a1076 1
Kommentare haben, so da dieses Interface zu einer verllichen
d1078 1
a1078 1
fr Routinen zu benutzen, die nur im Implementationsbereich
d1080 2
a1081 2
Mehrere zusammenhngende Deklarationen (z.B. Gruppen von Konstanten)
knnen sich einen Kommentar teilen.
d1086 1
a1086 1
wird verschiedene Textauszeichnungsmglichkeiten innerhalb von
d1088 2
a1089 2
der Dokumentation von @@samp{pas2texi} oder in spteren
Versionen dieses Dokumentes erlutert werden.
d1092 3
a1094 3
``Fixme''-Kommentare dienen dazu, aufzuzeigen, da an dieser Stelle
Code etwas zu verndern ist. Den Kommentaren werden mindestens
zwei @@samp{@@@@} vorangestellt. Fgen Sie soviele @@samp{@@@@} ein,
d1098 3
a1100 3
allem wenn die Wurzel des bels woanderes liegt. Beispielsweise
erklrt der Kommentar @@samp{@@{ @@@@@@@@fjf226 @@}} den folgenden Code als
Work-Around fr ein Problem des GNU Pascal Compilers, welches von
d1102 1
a1102 1
(Diese Datei knnen Sie tatschlich innerhalb des Quellpaketes des
d1108 1
a1108 1
vorbergehender Natur sind, drfen solche Kommentare berall stehen,
d1112 1
a1112 1
Zukunft gendert werden, sollten @@samp{@@@@@@@@}-Kommentare direkt vor
d1126 1
a1126 1
eine lngere Beschreibung ber Details des Codes und wo man sich
d1151 1
a1151 1
Sie knnen von dieser Reihenfolge abweichen, wenn es notwendig
d1166 1
a1166 1
Die obigen Regeln gelten selbstverstndlich auch fr
d1169 2
a1170 2
Wenn Sie mehrere mehr oder weniger unabhngige Bereiche in einer
groen Unit oder einem groen Modul haben, so sollten sie obige
d1177 1
a1177 1
Variablen, die nur im Hauptprogramm genutzt werden, mssen in
d1179 1
a1179 1
kennt, um diese Beschrnkung zu umgehen und Variablen im
d1183 1
a1183 1
gilt besonders dann, wenn das Programm gro ist und viele Variablen
d1186 1
a1186 1
Code-Bereichen nderbar. Auerdem vermeidet man so, da
d1190 1
a1190 1
Wenn Sie einen Typ und seinen zugehrigen Zeiger gleich mit
d1192 3
a1194 3
Dies ist bersichtlicher, besonders wenn der zugehrige Typ eine
grere Struktur (@@samp{record} oder @@samp{object}) ist. Auch wird
es damit mglich, rekursive Strukturen aufzubauen (Typdefinitionen,
d1196 1
a1196 1
Typen ein @@samp{T}, und den zugehrigen Zeigern ein @@samp{P} voran.
d1211 3
a1213 3
Bitte beachten Sie in dem Beispiel, da das @@samp{Next}-Feld als
erstes aufgefhrt ist. Wir schlagen vor, da Sie es bei rekursiven
Typen immer so machen, es ermglicht einige generische
d1218 1
a1218 1
@@samp{type}-Deklaration zuerst aufzufhren, aber wir raten Ihnen
d1228 1
a1228 1
  @@{ Einige magefertigte Integertypen @@}
d1236 1
a1236 1
reservierte Wrter leiten diese Bereiche ein: @@samp{public},
d1253 2
a1254 2
einhalten wie bei der Deklaration. Dies gilt selbstverstndlich
ebenso fr Units und Module.
d1257 1
a1257 1
@@samp{end}, @@samp{until}, usw, auer im Fall von @@samp{case}.
d1259 1
a1259 1
keinen @@samp{else}-Zweig gibt) @@emph{sollte} ein abschlieendes
d1265 1
a1265 1
    if Bar then  @@{ spter eingefgt @@}
d1269 1
a1269 1
  else  @@{ @@dots{} dann wird dieses @@samp{else} pltzlich dem @@samp{then} zugerechnet @@}
d1274 1
a1274 1
@@samp{else} des @@samp{case} spter eingefgt wird.)
d1276 1
a1276 1
In Objekten mag es merkwrdig aussehen, das @@samp{;} nach dem
d1281 3
a1283 3
@@node Groschreibung
@@section Groschreibung
@@cindex Groschreibung
d1285 2
a1286 2
Reservierte Wrter sollten allesamt kleingeschrieben werden,
einschlielich aller Direktiven und Wrter, die nur in manchen
d1288 2
a1289 2
Direktiven auerhalb ihres Kontextes als Bezeichner benutzen (was
leicht zu Problemen fhren kann), so schreiben Sie diese bitte wie
d1292 1
a1292 1
Als besondere Ausnahme darf man @@samp{File} groschreiben, wenn
d1294 1
a1294 1
selbstverstndlich bei @@samp{file of Char}. Im Fall von
d1296 1
a1296 1
nicht anwenden, denn @@samp{File} kann ein Typ an sich sein, whrend
d1304 2
a1305 2
@@cindex Groschreibung von Bezeichnern
Der nchste Punkt betrifft die Groschreibung von Bezeichnern. Es
d1307 4
a1310 4
selbstdefinierten Bezeichnern. Grundstzlich sollte nur der erste
Buchstabe grogeschrieben werden, auer wenn es sich um
zusammengesetzte Wrter oder Akronyme handelt, dann sollte jeder
Anfangsbuchstabe eines jeden Teilwortes grogeschrieben werden.
d1312 1
a1312 1
der natrlichen Sprache geworden sind, sollten so geschrieben
d1320 2
a1321 2
@@cindex Groschreibung von Konstanten
Anders als bei C-Makros gelten diese Regeln auch fr Konstanten.
d1323 1
a1323 1
Sehr kurze Bezeichner drfen kleingschrieben werden, z.B. @@samp{i},
d1325 2
a1326 2
in lokalen Blcken auftauchen. Dazu zhlen auch Parameter globaler
Routinen, denn der Gltigkeitsbereich solcher Parameter ist lokal.
d1332 1
a1332 1
Bitte bleiben Sie einheitlich, was die Gro- und Kleinschreibung
d1334 2
a1335 2
schlgt, wenn Sie mal die Groschreibung einer Variablen innerhalb
eines Blockes ndern: Bitte halten Sie sich an eine Form.
d1337 1
a1337 1
@@cindex Aufzhlungstypen
d1339 1
a1339 1
Fr Bezeichner fr die Werte von Aufzhlungstypen und fr Gruppen
d1341 2
a1342 2
eingefhrt werden, kann es ntzlich sein, ein zweibuchstabiges
kleingeschriebenes Prfix zu verwenden, dem im Gegensatz zu obigen
d1360 1
a1360 1
Fall, da der Parameter einer Funktion zu einem Feldnamen passen
d1362 1
a1362 1
bereinstimmen drfen, sollte das Feld den ``natrlichen'' Namen
d1364 3
a1366 3
Parametername verndert werden. Wir haben bislang keine einheitliche
Regel fr den Namen des Parameters in einem solchen Fall gefunden.
Manche Programmierer verwenden @@samp{a} als Prfix. Wenn Sie eine
d1369 1
a1369 1
@@cindex Groschreibung von Makros
d1371 3
a1373 3
des Bsen! Wenn Sie es doch tun, so mssen Sie zur Strafe alle
Buchstaben gro schreiben und einzelne Teilwrter mit
Unterstrichen trennen. Da Makros auerhalb der
d1375 1
a1375 1
zu schreiben als den brigen Pascal-Code. Das gilt ebenso fr
d1382 1
a1382 1
Anmerkung des bersetzers:
d1385 3
a1387 3
Ausfhrung von Code vorkommt, Herr zu werden, habe ich mich
entschieden, in diesem Abschnitt durchgngig ``Conditional'' im
letztgenannten Kontext zu verwenden. Der Leser mge mir verzeihen.
d1389 2
a1390 2
Grundstzlich sollten Sie so wenig Compiler-Direktiven wie nur
irgend mglich verwenden, weil sie den Code schwerer lesbar
d1404 1
a1404 1
Zeilenumbrchen anhngt:
d1416 1
a1416 1
Dies spart auerdem den Backslash vor dem Zeilenumbruch, im
d1418 1
a1418 1
benutzen, ODER? (@@pxref{Groschreibung})
d1421 4
a1424 4
Fgen Sie niemals ein Leerzeichen vor der schlieenden Klammer ein,
denn es darf auch keines nach der ffnenden Klammer kommen. Wenn
Sie mehrere Direktiven zusammenfgen, so fgen Sie zwischen zweien
kein Leerzeichen ein, ein einfaches Komma gengt.
d1427 1
a1427 1
Es sollten keine Kommentare innerhalb der Direktiven eingefgt
d1435 1
a1435 1
Das ist ein Mibrauch eines solchen Kommentares!
d1438 2
a1439 2
langen Formen den Vorzug geben. Die kurzen Formen mssen
grogeschrieben werden, whrend die langen Formen kleingeschrieben
d1442 1
a1442 1
Dateinamen -- bei letzteren ist auch unter DOS die korrekte Gro-
d1445 1
a1445 1
Sie knnen verschiedene Direktiven kombinieren, dabei auch kurze
d1456 1
a1456 1
Lizenz. @@samp{@@{$gnu-pascal@@}} bewirkt, da die Unit ohne
d1459 1
a1459 1
zeigen dem Nutzer der Unit, da Ein-/Ausgabe-Fehler von den Routinen
d1461 3
a1463 3
Fall ist dem anderen in den meisten Fllen vorzuziehen.
Fr Programme ist dies optional. Routinen, die Ein-/Ausgabe-Fehler
hervorrufen knnen, sollten mit dem Attribut @@samp{iocritical}
d1496 3
a1498 3
geschrieben wurde. Selbst wenn ein Programmierer wei, welches
die aktuellen globalen Einstellungen sind, so knnen sich diese
eines Tages ndern. Auch dadurch, da Teile des Codes an
d1505 1
a1505 1
@@{$local W-@@} Foo; @@{$endlocal@@}  @@{ @@@@ GPC gibt hier eine berflssige Warnung @@}
d1509 1
a1509 1
@@samp{@@{$I-@@}} kann manchmal ntztlich sein. @@samp{@@{$X+@@}} sollte
d1511 1
a1511 1
und dann auch bitte so lokal wie nur irgend mglich. Vermeiden Sie
d1514 1
a1514 1
@@cindex Testen der Rckgabewerte
d1517 1
a1517 1
berprfen. Es ist schlicht zu einfach, ein beachtenswertes
d1520 1
a1520 1
die berflssig erscheinen, weshalb man sie nicht berprfen mchte.
d1522 1
a1522 1
deklarieren, so da das Funktionsergebnis stillschweigend ignoriert
d1528 1
a1528 1
berprfen Sie sehr sorgfltig, ob ein solches Ergebnis wirklich
d1530 2
a1531 2
Sie in eine ``unmgliche'' Situation bringen wrde, so ist es
normalerweise besser, das Funktionsergebnis zu berprfen
d1537 1
a1537 1
Linker-Direktiven, d.h. @@samp{@@{$L@@}} frBibliotheken und
d1540 1
a1540 1
oder Modulen stehen. Mehrere Bibliotheken und C-Quelldateien knnen
d1542 2
a1543 2
zusammengehren (bspw. eine Bibliothek und ihre zugehrige
Wrapper-Funktion), nicht aber dann, wenn sie nicht zusammengehren.
d1545 1
a1545 1
werden (was auch nicht geht, wenn @@samp{L} zuerst angefhrt wird;
d1548 2
a1549 2
zugehrigen Direktive folgen (auer fr Units oder Module bei
denjenigen Deklarationen, die in das Interface gehren). Das
d1555 2
a1556 2
Bedingtes Kompilieren kann manchmal ntzlich sein, aber es sollten
sowenige @@samp{@@{$ifdef@@}}s wie nur irgend mglich geschrieben
d1559 1
a1559 1
unterscheiden, sollten die Fhigkeiten des Systems (bspw.
d1561 3
a1563 3
(bspw. @@samp{__OS_DOS__}) berprft werden, nicht einzelne Systeme.
Dieses Vorgehen funktioniert dann oftmals auch spter noch auf
Systemen, von denen man noch nichts wei oder die noch nicht
d1566 2
a1567 2
Wann immer dies mglich ist, sollte vordefinierten Konstanten der
Vorzug gegenber @@samp{define}s gegeben werden (bspw.
d1569 3
a1571 3
mglich (der ``immer false'' - Zweig wird schlicht wegoptimiert,
trotzdem wird seine Syntax berprft). Bei Typen-Deklarationen ist
es normalerweise nicht mglich. Hier mu man @@samp{define}s
d1591 5
a1595 5
Das @@samp{DEBUG}-Flag sollte eine Untersttzung beim Debuggen des
Codes sein, also Code, der die Funktionalitt beim Debuggen nicht
verndert. Nur dafr sollte er eingesetzt werden. Programme mssen
mit und ohne @@samp{DEBUG} lauffhig sein. Es kann sein, da der
Code mit @@samp{DEBUG} langsamer luft und eine Vielzahl von
d1597 1
a1597 1
Debug-Mitteilungen erkennbar sein, bspw. dadurch, da der Ausgabe
d1599 1
a1599 1
einfach abbrechen, wenn fehlerhafte oder merkwrdige Zustnde
d1603 1
a1603 1
Conditionale knnen ebenfalls herangezogen werden, um verschiedene
d1605 1
a1605 1
innerhalb eines Mathematik-Programmes mglich, eine eigene
d1607 1
a1607 1
Bearbeitung beliebig groer Zahlen) zu erzeugen und eine
d1610 1
a1610 1
weit oben im Quelltext stehenden Kommentar erklrt werden. Sehen Sie
d1616 1
a1616 1
selten wie mglich zu benutzen oder gar zu vermeiden.
d1622 2
a1623 2
wenn alle Implementationen untersttzt werden oder es geplant ist,
sie zu untersttzen. Andernfalls sollte die alte Implementation
d1651 1
a1651 1
auszukommentieren. Hier ist die zugehrige Syntax:
d1659 1
a1659 1
genutzt werden, wenn Sie sicherstellen wollen, da die richtige
d1673 1
a1673 1
folgen, auer fr Einrckungen und in speziellen Fllen, die im
d1692 1
a1692 1
Kein Leerzeichen sollte hingegen nach dem unren Minuszeichen
d1700 2
a1701 2
Leerzeichen sollte zwischen Bezeichnern/Schlsselwrtern und
der ffnenden Klammern stehen. Beispiel:
d1707 1
a1707 1
Fr Arrayindizierung wird kein Leerzeichen verwendet (schreiben Sie
d1715 1
a1715 1
Bei Mengen-Konstruktoren sollte ggf. ein Blank vor der ffnenden
d1735 3
a1737 3
Wie wir schon ausfhrten, soll je ein Blank nach den ffnenden und
vor den schlieenden geschweiften Klammern in Kommentaren stehen.
Dies gilt jedoch nicht fr Compiler-Direktiven. Auerdem sollten vor
d1744 3
a1746 3
@@cindex Abstand, Einrckung
@@cindex Einrckung, Abstand
Wenn Sie mgen, so fgen Sie beliebig viele Leerzeichen ein, um
d1748 1
a1748 1
Meinung nach erhht dies die Lesbarkeit des Codes ungemein, weil
d1750 3
a1752 3
Unterschiede in Zeilen besser gesehen werden knnen, und man
bei nderungen im Quellcode verwandte Stellen nicht so leicht
bersieht. Eine Anwendung dieser Prinzipien sollte in
d1755 1
a1755 1
ist in einem solchen Fall mglicherweise ein gemeinsamer Kommentar
d1771 1
a1771 1
Ebenfalls mglich:
d1779 1
a1779 1
Und natrlich:
d1788 1
a1788 1
Dieselbe ``Tabellenanordnung'' kann man fr Initialisierungen
d1825 1
a1825 1
@@node Zeilenumbrche
d1827 1
a1827 1
@@cindex Zeilenumbrche
d1829 1
a1829 1
Zeilenumbrche sind nach @@emph{lokalen} @@samp{const}-, @@samp{type}-
d1831 1
a1831 1
einzige Deklaration beinhalten (Sie knnen auch mehrere Bezeichner
d1864 1
a1864 1
Wenn Sie viele Deklarationen haben, so knnen Sie Zeilenumbrche
d1866 1
a1866 1
bevorzugte Fassung fr @@samp{var}-Deklarationen:
d1883 1
a1883 1
oder ffentlichen @@samp{object}-Feldern gebruchlich, besonders,
d1895 2
a1896 2
innerhalb von Blcken erfolgen. Solche Zeilenumbrche setzen das
falsche Signal, da hier mehrere Deklarationsgruppen erlaubt wren:
d1904 9
a1912 9
selten eingesetzt werden, bei Variablen, deren Gre erst innerhalb
der Routine berechnet wird oder fr Variablen innerhalb von
Modul-/Unit-Initialisierungen beispielsweise, um dafr keine
globalen Variablen zu bentigen. Denken Sie bitte bei der Anwendung
dieses Features ber Unterroutinen nach.

@@cindex Einrckung von Labeln
Fgen Sie bitte keinen Zeilenumbruch nach @@samp{label} durch. Sie
sollten Label folgendermaen deklarieren:
d1970 1
a1970 1
nach Kommata umbrochen werden, wobei die Einrckung die
d1991 3
a1993 3
@@cindex if then else Anweisungen und Zeilenumbrche
Hier sehen Sie, wie Sie Zeilenumbrche innerhalb von if-then-else
Anweisungen vornehmen knnen. Diese Art der Einrckung sollte auch
d1995 1
a1995 1
wrden, dies aber nicht mglich ist (weil die Typen nicht aufzhlbar
d1998 1
a1998 1
wrde, oder zustzliche Bedingungen auftauchen):
d2009 2
a2010 2
Wenn @@samp{a} und ``nicht @@samp{a}'' die Hauptflle sind und
@@samp{b} und @@samp{c} Unterflle von ``nicht @@samp{a}'', so benutzen
d2024 2
a2025 2
Das folgende (biologisch gesehen ziemlich unvollstndige) Beispiel
enthlt eine Mischung beider Formen, die wir fr vernnftig halten:
d2042 2
a2043 2
Die Hauptflle werden hier durch den Wohnort bestimmt, die Anzahl
der Beine bestimmen einige untergeordnete Flle.
d2066 1
a2066 1
@@samp{until} existiert und diese Anweisung kurz genug fr eine Zeile
d2087 1
a2087 1
Block gefat werden, sieht es folgendermaen aus:
d2110 2
a2111 2
@@cindex Einrckung
Es wird nach folgenden Ausdrcken 2 Leerzeichen eingerckt:
d2118 2
a2119 2
eingerckt, ebenso wie globale Variablen etc. Jede Subroutine (Kopf
und Krper sowie ihre lokalen Variablen etc.) soll eingerckt
d2146 1
a2146 1
Variante Records sollten so eingerckt werden:
d2164 2
a2165 2
Grere Einrckung (mehr als zwei Leerzeichen) kann bei
Zeilenumbrchen im Code erfolgen, um einen ``tabularen'' Code
d2168 2
a2169 2
Conditionale (@@samp{@@{$ifdef@@}}) sollten dieselbe Einrckung wie
der zugehrige Code haben:
d2180 1
a2180 1
Kurze Conditionale, die sich nur auf einen Ausdruck beziehen, drfen
d2184 1
a2184 1
Foo := @@{$ifdef DEBUG@@} 'Debugging' @@{$else@@} 'Verffentlichung' @@{$endif@@};
d2193 1
a2193 1
  @@{ Fhre den Code bedingungslos aus, wenn wir debuggen @@}
d2203 1
a2203 1
Oftmals finden Sie schnere und nicht weniger effiziente Wege,
d2239 1
a2239 1
das, da Sie doppelte @@samp{'} benutzen mssen. Mehr Informationen:
d2242 5
a2246 5
Normalerweise sollten Strings in einfachen Anfhrungszeichen
so wie @@samp{'dieser schne Satz, den Sie lesen'} eingeschlossen
sein. Mit doppelten Anfhrungszeichen sollen nur Zeichenketten
umfat werden, die C-Escape-Sequenzen beinhalten, wie
@@samp{"\t"}. Beachten Sie bitte, da @@samp{NewLine} (@@samp{"\n"})
d2248 1
a2248 1
Sie nicht gerade C-Strings fr andere Zwecke bentigen.
d2250 1
a2250 1
Mehrzeilige Strings knnen folgendermaen genutzt werden:
d2258 1
a2258 1
selbst Einrckungen und/oder Abstze enthlt):
d2266 1
a2266 1
Folgendes ist auch mglich:
d2272 1
a2272 1
(Beachten Sie, da obiger Code nicht ohne die Unit @@code{GPC}
d2275 1
a2275 1
Oder natrlich:
d2282 1
a2282 1
Wenn Sie testen mchten, ob ein String leer ist, benutzen Sie
d2291 1
a2291 1
schnelleren Test. Daher knnen Sie den vorhergehende, krzere
d2299 1
a2299 1
Dasselbe gilt natrlich auch fr @@samp{<>} und sogar fr
d2315 2
a2316 2
auf GNU Pascal bertragen werden.
Beachten Sie, da @@samp{mmap} hier @@samp{MemoryMap} bedeutet.
d2325 1
a2325 1
dortigen Informationen gelten auch fr GNU Pascal. Einige
d2328 1
a2328 1
Es wre schn, eine Man-Page fr jedes Programm zu haben. Diese
d2332 2
a2333 2
Programmes generiert. Es funktioniert gut, bis auf die Tatsache, da
es @@samp{FSF} an den Anfang der Man-Page schreibt, was nicht fr
d2336 1
a2336 1
Programm wie @@samp{sed} gendert werden.
d2338 1
a2338 1
Geben Sie sich mit den Man-Pages nicht zuviel Mhe. Sie
d2340 2
a2341 2
zu halten, bedeutet eine Menge Arbeit und ist mglicherweise sehr
fehlertrchtig. Wenn Sie die Man-Page nicht auf dem neuesten Stand
d2345 2
a2346 2
zu knapp ausfallen, auf der anderen Seite werden lngere Man-Pages
sehr unbersichtlich.
d2351 3
a2353 3
@@node Verffentlichungen
@@chapter Der Verlauf der Verffentlichung
@@cindex Verffentlichung des Programmes
d2356 1
a2356 1
Standards. Beachten Sie, da der ganze Aufwand mit den auto-Tools
d2358 1
a2358 1
Pascal normalerweise nicht gebraucht werden. Auerdem sind Makefiles
d2370 1
a2370 1
Fr Ihre Pascal-Projekte bentigen Sie keine groen @@samp{Makefile}s
d2374 1
a2374 1
Pascal fr Sie! (Zum Zeitpunkt des Schreibens hat GNU Pascal
d2377 1
a2377 1
Auerdem wird gerade an einem Utility namens @@samp{gp} gearbeitet,
d2405 3
a2407 3
hinzufgen, sei es zur Erstellung der Dokumentation, Datendateien,
Paketen zur Verffentlichung oder zu was auch immer. Diese Dinge
liegen auerhalb des Rahmens dieses Textes. Die Kompilierung eines
d2421 2
a2422 2
Eigenschaften irgendwelcher Objekte ``erklren'', wie Konstanten,
Typen, Variablen, Units, Module, und selbstverstndlich das
d2433 1
a2433 1
enthalten drfen.
d2437 2
a2438 2
Namen geben. Sie knnen lokal umdefiniert werden, anders als
Schlsselwrter (keywords), die Teil einer festen Syntax sind
d2440 1
a2440 1
und nicht umdefiniert werden knnen. Makros sind keine
d2442 1
a2442 1
sondern von einem Prprozessor.
d2445 1
a2445 1
Anordnung der hher- und niederwertigen Bytes bezieht. Diese
d2447 1
a2447 1
Sie sich bitte die Erklrung dazu im GPC-Info Dokument an
d2450 1
a2450 1
@@emph{Hinweis:} Andere Begriffe knnen hier eingefgt werden,
d2452 1
a2452 1
Ausdruckes wissen mchten, so teilen Sie es uns bitte mit.
@


1.1.111.1
log
@I missed these when upgrading gpc the first time (cf. gcc/gpcdoc/)
@
text
@@
