head	1.29;
access;
symbols
	MIRBSD_10:1.10.0.2
	MIRBSD_10_BASE:1.10
	MIRBSD_9_BASE:1.8
	MIRBSD_8:1.7.0.2
	MIRBSD_8_BASE:1.7
	cvs-200507211800:1.1.1.2
	cvs-200504291700:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@# @;


1.29
date	2017.08.07.20.10.51;	author tg;	state Exp;
branches;
next	1.28;
commitid	1005988C69344442E37;

1.28
date	2016.03.25.19.49.15;	author tg;	state Exp;
branches;
next	1.27;
commitid	10056F596401CDD6854;

1.27
date	2016.02.14.23.47.16;	author tg;	state Exp;
branches;
next	1.26;
commitid	10056C1121D70D21CC9;

1.26
date	2016.02.14.15.22.22;	author tg;	state Exp;
branches;
next	1.25;
commitid	10056C09BBE1A976A4B;

1.25
date	2016.02.13.17.54.24;	author tg;	state Exp;
branches;
next	1.24;
commitid	10056BF6D8611868373;

1.24
date	2016.02.13.17.48.10;	author tg;	state Exp;
branches;
next	1.23;
commitid	10056BF6C58245ED750;

1.23
date	2015.10.06.15.05.44;	author tg;	state Exp;
branches;
next	1.22;
commitid	1005613E34754F9CB63;

1.22
date	2009.10.17.16.20.04;	author tg;	state Exp;
branches;
next	1.21;
commitid	1004AD9EEB462983F05;

1.21
date	2009.07.18.14.09.07;	author tg;	state Exp;
branches;
next	1.20;
commitid	1004A61D73A7953CBB8;

1.20
date	2009.07.18.12.42.10;	author tg;	state Exp;
branches;
next	1.19;
commitid	1004A61C3126769A034;

1.19
date	2009.03.29.13.04.16;	author tg;	state Exp;
branches;
next	1.18;
commitid	10049CF71B654F9EF54;

1.18
date	2009.02.09.12.39.42;	author tg;	state Exp;
branches;
next	1.17;
commitid	1004990241F0C9B6F0E;

1.17
date	2009.02.09.11.08.06;	author tg;	state Exp;
branches;
next	1.16;
commitid	10049900E9D4F6377E7;

1.16
date	2009.01.14.21.16.26;	author tg;	state Exp;
branches;
next	1.15;
commitid	100496E564147CB6101;

1.15
date	2008.12.10.18.06.07;	author tg;	state Exp;
branches;
next	1.14;
commitid	100494005235071EEB4;

1.14
date	2008.11.30.16.49.20;	author tg;	state Exp;
branches;
next	1.13;
commitid	1004932C3B032F6B0C8;

1.13
date	2008.05.25.20.09.13;	author tg;	state Exp;
branches;
next	1.12;
commitid	1004839C779579115DB;

1.12
date	2008.05.07.12.16.12;	author tg;	state Exp;
branches;
next	1.11;
commitid	10048219D991FE06744;

1.11
date	2008.03.27.13.48.27;	author tg;	state Exp;
branches;
next	1.10;
commitid	10047EBA5A25F1AA7E1;

1.10
date	2006.10.07.22.22.14;	author tg;	state Exp;
branches;
next	1.9;
commitid	100452828A75F7B3E54;

1.9
date	2006.07.29.01.50.26;	author tg;	state Exp;
branches;
next	1.8;
commitid	10044CABEF13106D440;

1.8
date	2006.05.15.12.13.56;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004468709107E8B3FD;

1.7
date	2005.07.07.13.39.23;	author tg;	state Exp;
branches;
next	1.6;
commitid	331742cd306446f9;

1.6
date	2005.07.04.12.43.41;	author tg;	state Exp;
branches;
next	1.5;
commitid	46f442c92f0c1fc5;

1.5
date	2005.04.29.18.58.15;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2005.04.29.18.34.48;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2005.03.28.01.46.55;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.06.19.05.54;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.22.11;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.22.11;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.29.17.05.17;	author tg;	state Exp;
branches;
next	;


desc
@@


1.29
log
@filesystem
@
text
@#!/bin/mksh
# $MirSecuCron: etc_security 0.0 0000/00/00 00:00:00 root Backup $
# $MirOS: src/etc/security,v 1.28 2016/03/25 19:49:15 tg Exp $
# $OpenBSD: security,v 1.71 2005/02/22 10:50:55 otto Exp $
# from: @@(#)security	8.1 (Berkeley) 6/9/93

export LC_ALL=C PATH=/bin:/usr/bin:/sbin:/usr/sbin RCSLOCALID='!MirSecuCron'
cd /
nl='
'

umask 077

function _diffhdr {
	print
	print ======
	print -r -- "$1 diffs (-OLD  +NEW)"
	print ======
}
function _stripcom {
	set -o noglob
	cat "$@@" | while read _line; do
		_line=${_line%%#*}
		[[ -n $_line ]] && print -r -- $_line
	done
}
rm -f /var/backups/rcs.log

# fback [-m|-n] <file> [<backupfile>]
function fback {
	local fn bf cf
	local wd o fd fo ft fa fp

	if [[ $1 = -m ]]; then
		o=md5
		shift
	elif [[ $1 = -n ]]; then
		o=nodiff
		shift
	elif [[ $1 = -- ]]; then
		shift
	fi
	fn=$1
	cf=$fn
	bf=$2
	ft=$3
	[[ -s $fn ]] || return
	[[ -n $bf ]] || bf=$(sed 's/^\///;s/\//_/g' <<<"$fn")
	[[ -n $ft ]] || ft=$fn

	wd=$(pwd)
	cd /var/backups

	# migration for special cases
	if [[ $o = md5 ]]; then
		cf=$DIR/_md5
		md5 <"$fn" >$cf
		[[ -e "$bf".current.md5 ]] && \
		    mv "$bf".current.md5 "$bf".md5.current
		[[ -e "$bf".backup.md5 ]] && \
		    mv "$bf".backup.md5 "$bf".md5.backup
		bf=$bf.md5
	fi

	if [[ ! -x /usr/bin/co ]]; then
		# back things up without RCS tools
		if [[ ! -e $bf.current ]] || ! cmp -s "$cf" "$bf.current"; then
			[[ -e $bf.current ]] && \
			    cp -p "$bf.current" "$bf.backup"
			cp -p "$cf" "$bf.current"
			[[ $o = nodiff ]] || _diffhdr "$ft"
			[[ $o = nodiff ]] || if [[ -e $bf.backup ]]; then
				diff -up /var/backups/"$bf.backup" \
				    /var/backups/"$bf.current"
			else
				diff -u /dev/null /var/backups/"$bf.current"
			fi
			chown 0:0 "$bf.current"
			chmod 0600 "$bf.current"
		fi
		cd "$wd"
		return
	fi

	# migration for RCS/foo,x (-x,v/) to RCS/foo (-x)
	[[ -e RCS/$bf,v ]] && mv -f RCS/$bf,v RCS/$bf

	# migration for non-RCS to RCS schema
	if [[ -e $bf.backup ]]; then
		[[ -e RCS/$bf ]] && co -x -M -T -l "$bf" >>rcs.log 2>&1
		fd=$(stat -f '%Sm' -t '%Y/%m/%d %H:%M:%S' "$bf.backup")
		fo=$(stat -f '%Su' "$bf.backup")
		mv -f "$bf.backup" "$bf"
		ci -x -M -T -u -d"$fd" -t-"automatic backup for $fn" -w"$fo" \
		    -sAncient -f -m"legacy backup $fn" "$bf" >>rcs.log 2>&1
	fi
	if [[ -e $bf.current ]]; then
		[[ -e RCS/$bf ]] && co -x -M -T -l "$bf" >>rcs.log 2>&1
		fd=$(stat -f '%Sm' -t '%Y/%m/%d %H:%M:%S' "$bf.current")
		fo=$(stat -f '%Su' "$bf.current")
		mv -f "$bf.current" "$bf"
		ci -x -M -T -u -d"$fd" -t-"automatic backup for $fn" -w"$fo" \
		    -sLegacy -f -m"legacy current $fn" "$bf" >>rcs.log 2>&1
	fi
	rm -f "$bf.backup" "$bf.current"

	# back things up using RCS tools
	if [[ ! -e $bf ]] || ! cmp -s "$cf" "$bf"; then
		[[ -e RCS/$bf ]] && co -x -M -T -l "$bf" >>rcs.log 2>&1
		rm -f "$bf"
		cp -p "$cf" "$bf"
		fd=$(stat -f '%Sm' -t '%Y/%m/%d %H:%M:%S' "$fn")
		fo=$(stat -f '%Su' "$fn")
		fa=$(stat -f '%u:%g' "$fn")
		fp=$(stat -f '%Mp%Lp' "$fn")
		[[ $o = nodiff ]] || _diffhdr "$ft"
		[[ $o = nodiff ]] || if [[ -e RCS/$bf ]]; then
			rcsdiff -x -q -u -p /var/backups/"$bf"
		else
			diff -u /dev/null /var/backups/"$bf"
		fi
		ci -x -M -T -u -d"$fd" -t-"automatic backup for $fn" -w"$fo" \
		    -sBackup -m"$(date -u) backup for $fn" "$bf" >>rcs.log 2>&1
		cp -p "$bf" "$cf"
		chown 0:0 "$bf" "RCS/$bf"
		chmod 0400 "$bf" "RCS/$bf"
		chown $fa "$cf"
		chmod $fp "$cf"
	fi
	cd "$wd"
}

DIR=$(mktemp -d /tmp/_secure.XXXXXXXXXX) || exit 1
ERR=$DIR/_secure1
TMP1=$DIR/_secure2
TMP2=$DIR/_secure3
TMP3=$DIR/_secure4
LIST=$DIR/_secure5
OUTPUT=$DIR/_secure6

trap 'rm -rf $DIR; exit 1' 0 1 2 3 13 15

# Check the master password file syntax.
MP=/etc/master.passwd
awk -F: '{
	if ($0 ~ /^[	 ]*$/) {
		printf("Line %d is a blank line.\n", NR);
		next;
	}
	if (NF != 10)
		printf("Line %d has the wrong number of fields:\n%s\n", NR, $0);
	if ($1 ~ /^[+-]/)
		next;
	if ($1 == "")
		printf("Line %d has an empty login field:\n%s\n", NR, $0);
	else if ($1 !~ /^[A-Za-z0-9_][A-Za-z0-9_\-\.]*\$?$/)
		printf("Login %s has non-alphanumeric characters.\n", $1);
	if (length($1) > 31)
		printf("Login %s has more than 31 characters.\n", $1);
	if ($2 == "" && $1 !~ /^_*anoncvs$/ && $1 !~ /^_*rsync$/)
		printf("Login %s has no password.\n", $1);
	if ($2 != "" && length($2) != 13 && ($10 ~ /.*sh$/ || $10 == "") &&
	   ($2 !~ /^\$[0-9a-f]+\$/) && ($2 != "skey")) {
		if (system("test -s /etc/skey/"$1"") == 0)
			printf("Login %s is off but still has a valid shell and an entry in /etc/skey.\n", $1);
		if (system("test -d "$9" -a ! -r "$9"") == 0)
			printf("Login %s is off but still has valid shell and home directory is unreadable\n\t by root; cannot check for existence of alternate access files.\n", $1);
		else if (system("for file in .etc/ssh .rhosts .shosts .klogin; do if test -e "$9"/$file; then if ( (ls -ld "$9"/$file | cut -b 2-10 | grep -q r) && (test ! -O "$9"/$file)); then exit 1; fi; fi; done"))
			 printf("Login %s is off but still has a valid shell and alternate access files in\n\t home directory are still readable.\n",$1);
	}
	if ($3 == 0 && $1 != "root")
		printf("Login %s has a user ID of 0.\n", $1);
	if ($3 < 0)
		printf("Login %s has a negative user ID.\n", $1);
	if ($4 < 0)
		printf("Login %s has a negative group ID.\n", $1);
	if (int($7) != 0 && system("test "$7" -lt $(date +%s)") == 0)
		printf("Login %s has expired.\n", $1);
}' < $MP > $OUTPUT
if [ -s $OUTPUT ] ; then
	echo "\nChecking the ${MP} file:"
	cat $OUTPUT
fi

awk -F: '{ print $1 }' $MP | sort | uniq -d > $OUTPUT
if [ -s $OUTPUT ] ; then
	echo "\n${MP} has duplicate user names."
	column $OUTPUT
fi

awk -F: '/^[^\+]/ { print $1 " " $3 }' $MP | sort -n +1 | tee $TMP1 |
uniq -d -f 1 | awk '{ print $2 }' > $TMP2
set -A dupusers
if [ -s $TMP2 ] ; then
	echo "\n${MP} has duplicate user IDs."
	duptxt=
	while read uid; do
		grep " ${uid}\$" $TMP1 |&
		i=0
		while read -p uline; do
			duptxt=$duptxt$uline$nl
			if (( i++ )); then
				dupusers[${#dupusers[*]}]=-e
				dupusers[${#dupusers[*]}]='^'${uline%% *}' '
			fi
		done
	done <$TMP2
	print -nr -- "$duptxt" | column
fi
(( ${#dupusers[*]} )) || set -A dupusers -- -e '^$'

if [[ ! -d /var/backups/RCS/. ]]; then
	mkdir -p /var/backups/RCS
	chmod 700 /var/backups /var/backups/RCS
fi
for i in current backup; do
	f=/var/backups/master.passwd.$i
	[[ -e $f ]] && mv $f /var/backups/etc_master.passwd.$i
done

# Check the group file syntax.
GRP=/etc/group
awk -F: '{
	if ($0 ~ /^[	 ]*$/) {
		printf("Line %d is a blank line.\n", NR);
		next;
	}
	if ($1 ~ /^[+-].*$/)
		next;
	if (NF != 4)
		printf("Line %d has the wrong number of fields:\n%s\n", NR, $0);
	if ($1 !~ /^[A-Za-z0-9_][A-Za-z0-9_\-\.]*$/)
		printf("Group %s has non-alphanumeric characters.\n", $1);
	if (length($1) > 31)
		printf("Group %s has more than 31 characters.\n", $1);
	if ($3 !~ /[0-9]*/)
		printf("Login %s has a negative group ID.\n", $1);
}' < $GRP > $OUTPUT
if [ -s $OUTPUT ] ; then
	echo "\nChecking the ${GRP} file:"
	cat $OUTPUT
fi

awk -F: '{ print $1 }' $GRP | sort | uniq -d > $OUTPUT
if [ -s $OUTPUT ] ; then
	echo "\n${GRP} has duplicate group names."
	column $OUTPUT
fi

# Check for root paths, umask values in startup files.
# The check for the root paths is problematical -- it's likely to fail
# in other environments.  Once the shells have been modified to warn
# of '.' in the path, the path tests should go away.
> $OUTPUT
rhome=/
umaskset=no
list="/etc/profile ${rhome}/.profile"
for i in $list; do
	if [ -s $i ] ; then
		if egrep umask $i > /dev/null ; then
			umaskset=yes
		fi
		egrep umask $i |
		awk '$2 % 100 < 20 \
			{ print "Root umask is group writable" } \
		     $2 % 10 < 2 \
			{ print "Root umask is other writable" }' >> $OUTPUT
		SAVE_PATH=$PATH
		SAVE_ENV=$ENV
		unset PATH ENV
		mksh << end-of-sh > /dev/null 2>&1
			. $i
			if [ X"\$PATH" != "X" ]; then
				list=\`echo \$PATH | /usr/bin/sed -e 's/:/ /g'\`
				/bin/ls -ldgT \$list > $TMP1
			else
				> $TMP1
			fi
			echo \$ENV >> $TMP2
end-of-sh
		PATH=$SAVE_PATH
		ENV=$SAVE_ENV
		awk '{
			if ($10 ~ /^\.$/) {
				print "The root path includes .";
				next;
			}
		     }
		     $1 ~ /^d....w/ \
	{ print "Root path directory " $10 " is group writable." } \
		     $1 ~ /^d.......w/ \
	{ print "Root path directory " $10 " is other writable." }' \
		< $TMP1 >> $OUTPUT

	fi
done
if [ $umaskset = "no" -o -s $OUTPUT ] ; then
	echo "\nChecking root sh paths, umask values:\n${list}"
	if [ -s $OUTPUT ] ; then
		cat $OUTPUT
	fi
	if [ $umaskset = "no" ] ; then
		echo "\nRoot sh startup files do not set the umask."
	fi
fi

# Root and uucp should both be in /etc/ftpusers.
if egrep root /etc/ftpusers > /dev/null ; then
	:
else
	echo "\nRoot not listed in /etc/ftpusers file."
fi
if egrep uucp /etc/ftpusers > /dev/null ; then
	:
else
	echo "\nUucp not listed in /etc/ftpusers file."
fi

# Uudecode should not be in the /etc/mail/aliases file.
if egrep 'uudecode|decode' /etc/mail/aliases; then
	echo "\nThere is an entry for uudecode in the /etc/mail/aliases file."
fi

# Files that should not have + signs.
list="/etc/hosts.equiv /etc/shosts.equiv /etc/hosts.lpd"
for f in $list ; do
	if [ -s $f ] ; then
		awk '{
			if ($0 ~ /^\+@@.*$/)
				next;
			if ($0 ~ /^\+.*$/)
				printf("\nPlus sign in %s file.\n", FILENAME);
		}' $f
	fi
done

# Check for special users with .rhosts/.shosts files.  Only root
# should have .rhosts/.shosts files.  Also, .rhosts/.shosts
# files should not have plus signs.
awk -F: '$1 != "root" && $1 !~ /^[+-]/ && \
	($3 < 100 || $1 == "ftp" || $1 == "uucp") \
		{ print $1 " " $6 }' /etc/passwd |
grep -v "${dupusers[@@]}" |
while read uid homedir; do
	for j in .rhosts .shosts; do
		# Root owned .rhosts/.shosts files are ok.
		if [ -s ${homedir}/$j -a ! -O ${homedir}/$j ] ; then
			rhost=$(ls -ldgT ${homedir}/$j)
			echo "${uid}: ${rhost}"
		fi
	done
done > $OUTPUT
if [ -s $OUTPUT ] ; then
	echo "\nChecking for special users with .rhosts/.shosts files."
	cat $OUTPUT
fi

awk -F: '/^[^+-]/ { print $1 " " $6 }' /etc/passwd | \
grep -v "${dupusers[@@]}" |
while read uid homedir; do
	for j in .rhosts .shosts; do
		if [ -s ${homedir}/$j ] ; then
			awk '{
				if ($0 ~ /^+@@.*$/ )
					next;
				if ($0 ~ /^\+[ 	]*$/ )
					printf("%s has + sign in it.\n",
						FILENAME);
			}' ${homedir}/$j
		fi
	done
done > $OUTPUT
if [ -s $OUTPUT ] ; then
	echo "\nChecking .rhosts/.shosts files syntax."
	cat $OUTPUT
fi

# Check home directories.  Directories should not be owned by someone else
# or writeable.
awk -F: '/^[^+-]/ { print $1 " " $6 }' /etc/passwd | \
grep -v "${dupusers[@@]}" |
while read uid homedir; do
	if [ -d ${homedir}/ ] ; then
		file=$(ls -ldgT ${homedir})
		echo "${uid} ${file}"
	fi
done |
awk '$1 != $4 && $4 != "root" \
	{ print "user " $1 " home directory is owned by " $4 }
     $2 ~ /^-....w/ \
	{ print "user " $1 " home directory is group writable" }
     $2 ~ /^-.......w/ \
	{ print "user " $1 " home directory is other writable" }' > $OUTPUT
if [ -s $OUTPUT ] ; then
	echo "\nChecking home directories."
	cat $OUTPUT
fi

# Files that should not be owned by someone else or readable.
list=".netrc .rhosts .gnupg/secring.gpg .gnupg/random_seed \
	.pgp/secring.pgp .shosts .etc/ssh/identity .etc/ssh/id_dsa .etc/ssh/id_rsa"
awk -F: '/^[^+-]/ { print $1 " " $6 }' /etc/passwd | \
grep -v "${dupusers[@@]}" |
while read uid homedir; do
	for f in $list ; do
		file=${homedir}/${f}
		if [ -f $file ] ; then
			echo "${uid} ${f} $(ls -ldgT ${file})"
		fi
	done
done |
awk '$1 != $5 && $5 != "root" \
	{ print "user " $1 " " $2 " file is owned by " $5 }
     $3 ~ /^-...r/ \
	{ print "user " $1 " " $2 " file is group readable" }
     $3 ~ /^-......r/ \
	{ print "user " $1 " " $2 " file is other readable" }
     $3 ~ /^-....w/ \
	{ print "user " $1 " " $2 " file is group writable" }
     $3 ~ /^-.......w/ \
	{ print "user " $1 " " $2 " file is other writable" }' > $OUTPUT

# Files that should not be owned by someone else or writeable.
list=".bashrc .bash_profile .bash_login .bash_logout .cshrc \
      .emacs .exrc .forward .fvwmrc .inputrc .klogin .kshrc .login \
      .logout .nexrc .profile .screenrc .etc/ssh .etc/ssh/config \
      .etc/ssh/authorized_keys .etc/ssh/authorized_keys2 .etc/ssh/environment \
      .etc/ssh/known_hosts .etc/ssh/rc .tcshrc .twmrc .xsession .xinitrc \
      .Xdefaults .Xauthority mail"
awk -F: '/^[^+-]/ { print $1 " " $6 }' /etc/passwd | \
grep -v "${dupusers[@@]}" |
while read uid homedir; do
	for f in $list ; do
		file=${homedir}/${f}
		if [ -f $file ] ; then
			echo "${uid} ${f} $(ls -ldgT ${file})"
		fi
	done
done |
awk '$1 != $5 && $5 != "root" \
	{ print "user " $1 " " $2 " file is owned by " $5 }
     $3 ~ /^-....w/ \
	{ print "user " $1 " " $2 " file is group writable" }
     $3 ~ /^-.......w/ \
	{ print "user " $1 " " $2 " file is other writable" }' >> $OUTPUT
if [ -s $OUTPUT ] ; then
	echo "\nChecking dot files."
	cat $OUTPUT
fi

# Mailboxes should be owned by user and unreadable.
(
	cd /var/mail
	set -A f -- *
	[[ -e ${f[0]} ]] || exit 0
	stat -nf '%Sp:%Su:%Sg%/00%N%/00' -- "${f[@@]}"
) | while IFS=: read -d '' -r perms owner group; do
	IFS= read -d '' -r name || break
	[[ $name = "$owner".lock && -e /var/mail/$owner ]] && continue
	[[ $owner = "$name" ]] || print -r -- \
	    user "$name" mailbox is owned by "$owner"
	[[ $perms = -rw------- ]] || print -r -- \
	    user "$name" mailbox is "$perms", group "$group"
	[[ $name = +([a-z0-9-]) ]] || print -r -- \
	    mailbox name "$name" is not composed only of safe characters
	[[ $name = +([0-9]) ]] && print -r -- \
	    mailbox name "$name" is composed only of digits
done >$OUTPUT
if [ -s $OUTPUT ] ; then
	echo "\nChecking mailbox ownership."
	cat $OUTPUT
fi

# Filesystems should not be globally exported.
if [ -s /etc/exports ] ; then
	awk '{
		if (($1 ~ /^#/) || ($1 ~ /^$/))
			next;
		readonly = 0;
		for (i = 2; i <= NF; ++i) {
			if ($i ~ /^-ro$/)
				readonly = 1;
			else if ($i !~ /^-/ || $i ~ /^-network/)
				next;
		}
		if (readonly)
			print "Filesystem " $1 " globally exported, read-only."
		else
			print "Filesystem " $1 " globally exported, read-write."
	}' < /etc/exports > $OUTPUT
	if [ -s $OUTPUT ] ; then
		echo "\nChecking for globally exported filesystems."
		cat $OUTPUT
	fi
fi

# Display any changes in setuid/setgid files and devices.
pending="\nChecking setuid/setgid files and devices:\n"
(find / \( ! -fstype local -o -fstype fdesc -o -fstype kernfs \
	-o -fstype procfs \) -a -prune -o \
	-type f -a \( -perm -u+s -o -perm -g+s \) -print0 -o \
	! -type d -a ! -type f -a ! -type l -a ! -type s -a ! -type p \
	-print0 | xargs -0 ls -ldgT | sort +9 > $LIST) 2> $OUTPUT

# Display any errors that occurred during system file walk.
if [ -s $OUTPUT ] ; then
	echo "${pending}Setuid/device find errors:"
	pending=
	cat $OUTPUT
	echo ""
fi

# Display any changes in the setuid/setgid file list.
FIELDS1=1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,0
FIELDS2=2.1,2.2,2.3,2.4,2.5,2.6,2.7,2.8,2.9,0
egrep -av '^[bc]' $LIST | join -o $FIELDS2 -110 -210 -v2 /dev/null - > $TMP1
if [ -s $TMP1 ] ; then
	# Check to make sure uudecode isn't setuid.
	if grep -aw uudecode $TMP1 > /dev/null ; then
		echo "${pending}\nUudecode is setuid."
		pending=
	fi

	CUR=/var/backups/setuid.current
	BACK=/var/backups/setuid.backup

	if [ -s $CUR ] ; then
		if cmp -s $CUR $TMP1 ; then
			:
		else
			> $TMP2
			join -o $FIELDS2 -110 -210 -v2 $CUR $TMP1 > $OUTPUT
			if [ -s $OUTPUT ] ; then
				echo "${pending}Setuid additions:"
				pending=
				tee -a $TMP2 < $OUTPUT | column -t
				echo ""
			fi

			join -o $FIELDS1 -110 -210 -v1 $CUR $TMP1 > $OUTPUT
			if [ -s $OUTPUT ] ; then
				echo "${pending}Setuid deletions:"
				pending=
				tee -a $TMP2 < $OUTPUT | column -t
				echo ""
			fi

			sort +9 $TMP2 $CUR $TMP1 | \
			    sed -e 's/[	 ][	 ]*/ /g' | uniq -u > $OUTPUT
			if [ -s $OUTPUT ] ; then
				echo "${pending}Setuid changes:"
				pending=
				column -t $OUTPUT
				echo ""
			fi

			cp $CUR $BACK
			cp $TMP1 $CUR
		fi
	else
		echo "${pending}Setuid additions:"
		pending=
		column -t $TMP1
		echo ""
		cp $TMP1 $CUR
	fi
fi

# Check for block and character disk devices that are readable or writeable
# or not owned by root.operator.
>$TMP1
DISKLIST="ccd dk fd hd hk hp jb kra ra rb rd rl rx rz sd up vnd wd xd"
for i in $DISKLIST; do
	egrep "^b.*/${i}[0-9][0-9]*[B-H]?[a-p]$"  $LIST >> $TMP1
	egrep "^c.*/r${i}[0-9][0-9]*[B-H]?[a-p]$"  $LIST >> $TMP1
done

awk '$3 != "root" || $4 != "operator" || $1 !~ /.rw-r-----/ \
	{ printf("Disk %s is user %s, group %s, permissions %s.\n", \
	    $11, $3, $4, $1); }' < $TMP1 > $OUTPUT
if [ -s $OUTPUT ] ; then
	echo "\nChecking disk ownership and permissions."
	cat $OUTPUT
	echo ""
fi

FIELDS1=1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,1.10,0
FIELDS2=2.1,2.2,2.3,2.4,2.5,2.6,2.7,2.8,2.9,2.10,0
# Display any changes in the device file list.
egrep -a '^[bc]' $LIST | sort +10 | \
    join -o $FIELDS2 -111 -211 -v2 /dev/null - > $TMP1
if [ -s $TMP1 ] ; then
	CUR=/var/backups/device.current
	BACK=/var/backups/device.backup

	if [ -s $CUR ] ; then
		if cmp -s $CUR $TMP1 ; then
			:
		else
			> $TMP2
			join -o $FIELDS2 -111 -211 -v2 $CUR $TMP1 > $OUTPUT
			if [ -s $OUTPUT ] ; then
				echo "Device additions:"
				tee -a $TMP2 < $OUTPUT | column -t
				echo ""
			fi

			join -o $FIELDS1 -111 -211 -v1 $CUR $TMP1 > $OUTPUT
			if [ -s $OUTPUT ] ; then
				echo "Device deletions:"
				tee -a $TMP2 < $OUTPUT | column -t
				echo ""
			fi

			# Report any block device change.  Ignore character
			# devices, only the name is significant.
			cat $TMP2 $CUR $TMP1 | \
			sed -e '/^c/d' | \
			sort +10 | \
			sed -e 's/[	 ][	 ]*/ /g' | \
			uniq -u > $OUTPUT
			if [ -s $OUTPUT ] ; then
				echo "Block device changes:"
				column -t $OUTPUT
				echo ""
			fi

			cp $CUR $BACK
			cp $TMP1 $CUR
		fi
	else
		echo "Device additions:"
		column -t $TMP1
		echo ""
		cp $TMP1 $CUR
	fi
fi

# Check special files.
# Check system binaries.
#
# Create the mtree tree specifications using:
#
#	mtree -cx -p DIR -K md5digest,type >/etc/mtree/DIR.secure
#	chown root:wheel /etc/mtree/DIR.secure
#	chmod 600 /etc/mtree/DIR.secure
#
# Note, this is not complete protection against Trojan horsed binaries, as
# the hacker can modify the tree specification to match the replaced binary.
# For details on really protecting yourself against modified binaries, see
# the mtree(8) manual page.
if [ -d /etc/mtree ] ; then
	cd /etc/mtree
	mtree -e -l -p / -f /etc/mtree/special > $OUTPUT
	if [ -s $OUTPUT ] ; then
		echo "\nChecking special files and directories."
		echo "Output format is:\n\tfilename:"
		echo "\t\tcriteria (shouldbe, reallyis)"
		cat $OUTPUT
		echo "\nIf this message bugs you, use:"
		echo "\tmtree -e -p / -f /etc/mtree/special -U"
	fi

	> $OUTPUT
	for file in *.secure; do
		[ $file = '*.secure' ] && continue
		tree=$(sed -n -e '3s/.* //p' -e 3q $file)
		mtree -f $file -p $tree > $TMP1
		if [ -s $TMP1 ] ; then
			echo "\nChecking ${tree}:" >> $OUTPUT
			cat $TMP1 >> $OUTPUT
		fi
	done
	if [ -s $OUTPUT ] ; then
		echo "\nChecking system binaries:"
		cat $OUTPUT
	fi
else
	echo /etc/mtree is missing
fi

# Record a list of installed packages too; be sure to record
# the change to emptiness if previously recorded, but to not
# complain if no MirPorts Framework package tools installed.
if [[ -s /var/backups/pkglist || -x /usr/mpkg/sbin/pkg_info ]]; then
	if [[ -x /usr/mpkg/sbin/pkg_info ]]; then
		/usr/mpkg/sbin/pkg_info | sort
	else
		:
	fi >/var/backups/pkglist
fi

# List of files that get backed up and checked for any modifications.
# We try to use GNU RCS for versioning backups, otherwise, rotate: Each
# file is expected to have two backups, /var/backups/file.{current,backup}.
# Any changes cause the files to rotate.
if [ -s /etc/changelist ] ; then
	# Handle /etc/changelist.local
	if R=$(mktemp); then
		cat /etc/changelist >$R
		[ -e /etc/changelist.local ] && \
		    cat /etc/changelist.local >>$R
	else
		R=/etc/changelist
	fi
	# Now check
	_stripcom $R | while read file; do
		case $file {
		(+*)	fback -m "${file#+}" ;;
		(-*)	fback -n "${file#-}" ;;
		(/*)	fback -- "${file}" ;;
		}
	done

	for file in $(egrep -v "^(#|\+|$MP)" $R); do
		fback -- "$file"
	done
	for file in $(egrep "^\+" $R); do
		fback -m "${file#+}"
	done
	[ /etc/changelist = $R ] || rm -f $R
fi

# Make backups of the labels for any mounted disks and produce diffs
# when they change.
for d in `df -ln | sed -n 's:^/dev/\([a-z]*[0-9]*\)[a-p].*$:\1:p' | sort -u`; do
	if disklabel $d >$DIR/_disklabel 2>&1; then
		fback -- $DIR/_disklabel disklabel.$d
	fi
done
@


1.28
log
@prepare most scripts for locale tracking; drop some TZ=UTC; use modern mksh
@
text
@d3 1
a3 1
# $MirOS: src/etc/security,v 1.27 2016/02/14 23:47:16 tg Exp $
d474 1
a474 1
# File systems should not be globally exported.
d487 1
a487 1
			print "File system " $1 " globally exported, read-only."
d489 1
a489 1
			print "File system " $1 " globally exported, read-write."
d492 1
a492 1
		echo "\nChecking for globally exported file systems."
@


1.27
log
@optimise
@
text
@d3 1
a3 1
# $MirOS: src/etc/security,v 1.22 2009/10/17 16:20:04 tg Exp $
d7 1
a7 1
export TZ=UTC PATH=/bin:/usr/bin:/sbin:/usr/sbin RCSLOCALID='!MirSecuCron'
d21 2
a22 1
	cat "$@@" | { set -o noglob; while read _line; do
d25 1
a25 1
	done; }
d123 1
a123 1
		    -sBackup -m"$(date) backup for $fn" "$bf" >>rcs.log 2>&1
@


1.26
log
@handle the case where there are no mboxen
@
text
@d453 3
a455 5
	for x in *; do
		[[ -e $x ]] || exit 0
		break
	done
	stat -nf '%Sp:%Su:%Sg%/00%N%/00' *
@


1.25
log
@skip mailbox locks; implement additional sanity checks on the filenames
(underscore is deliberately not allowed as _user is a system user who
should not have a mailbox (but be forwarded) in most cases; the local
admin can always add a whitelist entry; period is deliberately not allowed
as its presence in usernames is daring even though chown uses a colon now)
@
text
@d451 8
a458 2
(cd /var/mail; stat -nf '%Sp:%Su:%Sg%/00%N%/00' *) | \
    while IFS=: read -d '' -r perms owner group; do
@


1.24
log
@rewrite mailbox name/owner check code to actually be secure…
dear OpenBSD developers, repeat after me: DO NOT PARSE ls(1) OUTPUT!
@
text
@d454 1
d459 4
@


1.23
log
@pre-fill MirSecuCron in correct width, at least for all that could be
affected during a run (I think I got them all)
@
text
@d451 8
a458 5
ls -l /var/mail | sed 1d | \
awk '$3 != $9 \
	{ print "user " $9 " mailbox is owned by " $3 }
     $1 != "-rw-------" \
	{ print "user " $9 " mailbox is " $1 ", group " $4 }' > $OUTPUT
@


1.22
log
@if we have a duplicate anyway, avoid things like this:

/etc/master.passwd has duplicate user IDs.
tg 2999         tgcsh 2999      tgzsh 2999

Checking home directories.
user tgcsh home directory is owned by tg
user tgzsh home directory is owned by tg

Checking dot files.
user tgcsh .Xauthority file is owned by tg
[…]
@
text
@d2 2
a3 2
# $MirSecuCron$
# $MirOS: src/etc/security,v 1.21 2009/07/18 14:09:07 tg Exp $
@


1.21
log
@prevent data corruption from /etc/security’s automated backup cronjob
by using “MirSecuCron” as RCS ID for these and preventing it from ex-
panding any of the default keywords

also, add RCS IDs to almost all configuration files and enhance the
default changelist file
@
text
@d3 1
a3 1
# $MirOS: src/etc/security,v 1.20 2009/07/18 12:42:10 tg Exp $
d9 2
d192 1
d195 1
d197 11
a207 2
		grep -w $uid $TMP1
	done < $TMP2 | column
d209 1
d342 1
d358 1
d380 1
d402 1
d430 1
@


1.20
log
@fix handling of RCS files (foo,v) by the security backup cronjob
by using RCS/foo instead of foo,v:RCS/foo,v as the rcs file name
@
text
@d2 2
a3 2
# $Id$
# $MirOS: src/etc/security,v 1.19 2009/03/29 13:04:16 tg Exp $
d7 1
a7 1
export TZ=UTC PATH=/bin:/usr/bin:/sbin:/usr/sbin
@


1.19
log
@• take care of dbins
• #!/bin/mksh shebang, in most places
• rcsid while here
@
text
@d3 1
a3 1
# $MirOS: src/etc/security,v 1.18 2009/02/09 12:39:42 tg Exp $
d48 1
a48 1
	wd="$(pwd)"
d51 1
d63 1
a63 1
		# Do it without RCS tools
d82 4
d87 1
a87 1
		[[ -e RCS/$bf,v ]] && co -M -T -l "$bf" >>rcs.log 2>&1
d91 1
a91 1
		ci -M -T -u -d"$fd" -t-"automatic backup for $fn" -w"$fo" \
d95 1
a95 1
		[[ -e RCS/$bf,v ]] && co -M -T -l "$bf" >>rcs.log 2>&1
d99 1
a99 1
		ci -M -T -u -d"$fd" -t-"automatic backup for $fn" -w"$fo" \
d103 2
d106 1
a106 1
		[[ -e RCS/$bf,v ]] && co -M -T -l "$bf" >>rcs.log 2>&1
d114 2
a115 2
		[[ $o = nodiff ]] || if [[ -e RCS/$bf,v ]]; then
			rcsdiff -q -u -p /var/backups/"$bf"
d119 1
a119 1
		ci -M -T -u -d"$fd" -t-"automatic backup for $fn" -w"$fo" \
d122 2
a123 2
		chown 0:0 "$bf" "RCS/$bf,v"
		chmod 0400 "$bf" "RCS/$bf,v"
@


1.18
log
@oops, committed from the wrong working copy
@
text
@d1 1
a1 1
#!/usr/bin/env mksh
d3 1
a3 1
# $MirOS: src/etc/security,v 1.17 2009/02/09 11:08:06 tg Exp $
d7 1
a7 1
export TZ=UTC PATH=/usr/dbin:/bin:/usr/bin:/usr/dsbin:/sbin:/usr/sbin
@


1.17
log
@allow anoncvs and anonrsync users to have empty passwords
prodded by gecko2@@
@
text
@d3 1
a3 1
# $MirOS: src/etc/security,v 1.16 2009/01/14 21:16:26 tg Exp $
d150 1
a150 1
	if ($2 == "" && $2 !~ /^_*anoncvs$/ && $2 !~ /^_*rsync$/)
@


1.16
log
@.Pa /var/backups/pkglist ,
idea from
.Ox ,
idea by me
@
text
@d3 1
a3 1
# $MirOS: src/etc/security,v 1.15 2008/12/10 18:06:07 tg Exp $
d150 1
a150 1
	if ($2 == "")
@


1.15
log
@use relative paths to mksh
@
text
@d3 1
a3 1
# $MirOS: src/etc/security,v 1.14 2008/11/30 16:49:20 tg Exp $
d643 11
@


1.14
log
@* præfixing changelist entries with '-' will now no longer send
  out diffs; coërce /etc/master.passwd into such an entry
  => updating security without updating changelist IS A SECURITY BREACH!
* if GNU RCS is installed, use it in /var/backups/RCS/ to keep track
  of versioned and protected (0:0 0400) configuration file backups,
  instead of the simple father-son rotational principle
  -- idea from ahoka@@, thanks
@
text
@d1 1
a1 1
#!/bin/mksh
d3 1
a3 1
# $MirOS: src/etc/security,v 1.13 2008/05/25 20:09:13 tg Exp $
d249 1
a249 1
		/bin/mksh << end-of-sh > /dev/null 2>&1
@


1.13
log
@http://linuxwiki.de/ApoStrophen
@
text
@d3 1
a3 1
# $MirOS: src/etc/security,v 1.12 2008/05/07 12:16:12 tg Exp $
d12 111
d190 8
a197 21
# Backup the master password file; a special case, the normal backup
# mechanisms also print out file differences and we don't want to do
# that because this file has encrypted passwords in it.
if [ ! -d /var/backups ] ; then
	mkdir /var/backups
	chmod 700 /var/backups
fi
CUR=/var/backups/$(basename $MP).current
BACK=/var/backups/$(basename $MP).backup
if [ -s $CUR ] ; then
	if cmp -s $CUR $MP; then
		:
	else
		cp -p $CUR $BACK
		cp -p $MP $CUR
		chown root:wheel $CUR
	fi
else
	cp -p $MP $CUR
	chown root:wheel $CUR
fi
d643 2
a644 1
# List of files that get backed up and checked for any modifications.  Each
a646 3
_fnchg() {
	echo "$1" | sed 's/^\///;s/\//_/g'
}
d649 1
a649 2
	R=$(mktemp)
	if [ $? -eq 0 ]; then
d653 1
a653 1
	  else
d657 8
d666 1
a666 17
		CUR=/var/backups/$(_fnchg  "$file").current
		BACK=/var/backups/$(_fnchg "$file").backup
		if [ -s $file -a ! -d $file ] ; then
			if [ -s $CUR ] ; then
				diff -u $CUR $file > $OUTPUT
				if [ -s $OUTPUT ] ; then
		echo "\n======\n${file} diffs (-OLD  +NEW)\n======"
					cat $OUTPUT
					cp -p $CUR $BACK
					cp -p $file $CUR
					chown root:wheel $CUR $BACK
				fi
			else
				cp -p $file $CUR
				chown root:wheel $CUR
			fi
		fi
d669 1
a669 22
		file="${file#+}"
		CUR=/var/backups/$(_fnchg  "$file").current.md5
		BACK=/var/backups/$(_fnchg "$file").backup.md5
		if [ -s $file -a ! -d $file ] ; then
			MD5_NEW=$(md5 $file | sed 's/^.* //')
			if [ -s $CUR ] ; then
				MD5_OLD="$(cat $CUR)"
				if [ "$MD5_NEW" != "$MD5_OLD" ]; then
		echo "\n======\n${file} MD5 checksums\n======"
					echo "OLD: $MD5_OLD"
					echo "NEW: $MD5_NEW"
					cp -p $CUR $BACK
					echo $MD5_NEW > $CUR
					chown root:wheel $CUR $BACK
					chmod 600 $CUR
				fi
			else
				echo $MD5_NEW > $CUR
				chown root:wheel $CUR
				chmod 600 $CUR
			fi
		fi
d677 2
a678 17
	file=/var/backups/disklabel.$d
	CUR=$file.current
	BACK=$file.backup
	if disklabel $d > $file 2>&1 ; then
		if [ -s $CUR ] ; then
			diff -u $CUR $file > $OUTPUT
			if [ -s $OUTPUT ] ; then
	echo "\n======\n${d} diffs (-OLD  +NEW)\n======"
				cat $OUTPUT
				cp -p $CUR $BACK
				cp -p $file $CUR
				chown root:wheel $CUR $BACK
			fi
		else
			cp -p $file $CUR
			chown root:wheel $CUR
		fi
a679 1
	rm -f $file
@


1.12
log
@remove all references to /root
@
text
@d3 1
a3 1
# $MirOS: src/etc/security,v 1.11 2008/03/27 13:48:27 tg Exp $
d73 1
a73 1
	echo "\n${MP} has duplicate user ID's."
@


1.11
log
@add /usr/dbin, /usr/dsbin to the path: usually before /bin and /sbin except
in the root+single user case (etc/root.profile, etc/profile + SINGLE)
@
text
@d3 1
a3 1
# $MirOS: src/etc/security,v 1.10 2006/10/07 22:22:14 tg Exp $
d135 1
a135 1
rhome=/root
@


1.10
log
@didn't export PATH either...
@
text
@d3 1
a3 1
# $MirOS: src/etc/security,v 1.9 2006/07/29 01:50:26 tg Exp $
d7 1
a7 1
export TZ=UTC PATH=/bin:/usr/bin:/sbin:/usr/sbin
@


1.9
log
@make work with mksh, d'oh
(openbsd folks?)
@
text
@d3 1
a3 1
# $MirOS: src/etc/security,v 1.8 2006/05/15 12:13:56 tg Exp $
d7 1
a7 2
export TZ=UTC
PATH=/bin:/usr/bin:/sbin:/usr/sbin
@


1.8
log
@avoid "cannot determine cwd" if invoked manually
@
text
@d3 1
a3 1
# $MirOS: src/etc/security,v 1.7 2005/07/07 13:39:23 tg Exp $
d48 1
a48 1
		else if (system("for file in .etc/ssh .rhosts .shosts .klogin; do if test -e "$9"/$file; then if ((ls -ld "$9"/$file | cut -b 2-10 | grep -q r) && (test ! -O "$9"/$file)) ; then exit 1; fi; fi; done"))
@


1.7
log
@/bin/sh and /bin/ksh -> /bin/mksh

This should cover most uses.
@
text
@d3 1
a3 1
# $MirOS: src/etc/security,v 1.6 2005/07/04 12:43:41 tg Exp $
d9 1
@


1.6
log
@nothing uses /etc/ksh.kshrc
@
text
@d1 1
a1 1
#!/bin/ksh
d3 1
a3 1
# $MirOS: src/etc/security,v 1.5 2005/04/29 18:58:15 tg Exp $
d151 1
a151 1
		/bin/ksh << end-of-sh > /dev/null 2>&1
@


1.5
log
@run cron'd scripts with TZ=UTC
idea from reading Message-ID: <20050429190347.3dd0f7b4.biorn@@dce.chalmers.se>
@
text
@d3 1
a3 1
# $MirOS: src/etc/security,v 1.4 2005/04/29 18:34:48 tg Exp $
a186 47
# A good .kshrc will not have a umask or path, that being set in .profile
# check anyway.
> $OUTPUT
rhome=/root
list="/etc/ksh.kshrc $(cat $TMP2)"
(cd $rhome
 for i in $list; do
	if [ -s $i ] ; then
		egrep umask $i |
		awk '$2 % 100 < 20 \
			{ print "Root umask is group writable" } \
		     $2 % 10 < 2 \
			{ print "Root umask is other writable" }' >> $OUTPUT
		if egrep PATH= $i > /dev/null ; then
			SAVE_PATH=$PATH
			unset PATH
			/bin/ksh << end-of-sh > /dev/null 2>&1
				. $i
				if [ X"\$PATH" != "X" ]; then
					list=\`echo \$PATH | /usr/bin/sed -e 's/:/ /g'\`
					/bin/ls -ldgT \$list > $TMP1
				else
					> $TMP1
				fi
end-of-sh
			PATH=$SAVE_PATH
			awk '{
				if ($10 ~ /^\.$/) {
					print "The root path includes .";
					next;
				}
			    }
			    $1 ~ /^d....w/ \
		{ print "Root path directory " $10 " is group writable." } \
			    $1 ~ /^d.......w/ \
		{ print "Root path directory " $10 " is other writable." }' \
			< $TMP1 >> $OUTPUT
		fi

	fi
 done
)
if [ -s $OUTPUT ] ; then
	echo "\nChecking root ksh paths, umask values:\n${list}"
	cat $OUTPUT
fi

@


1.4
log
@(tentative) merge, more to come
@
text
@d3 1
a3 1
# $MirOS: src/etc/security,v 1.3 2005/03/28 01:46:55 tg Exp $
d7 1
@


1.3
log
@tell the user how to fix the mtree too
also, stylistics, while here
@
text
@d3 2
a4 2
# $MirOS: src/etc/security,v 1.2 2005/03/06 19:05:54 tg Exp $
# $OpenBSD: security,v 1.66 2003/12/28 19:51:31 otto Exp $
d41 1
a41 1
           ($2 !~ /^\$[0-9a-f]+\$/) && ($2 != "skey")) {
d73 3
a75 3
        while read uid; do
                grep -w $uid $TMP1
        done < $TMP2 | column
d169 1
a169 1
        { print "Root path directory " $10 " is group writable." } \
d171 1
a171 1
        { print "Root path directory " $10 " is other writable." }' \
d392 1
a392 1
			else if ($i !~ /^-/)
d553 3
a555 3
#	mtree -cx -pDIR -kcksum,gid,mode,nlink,size,link,time,uid > DIR.secure
#	chown root:wheel DIR.secure
#	chmod 600 DIR.secure
d653 24
@


1.2
log
@merge src/etc minus generated files
@
text
@d2 4
a5 5
#	$Id$
#	$MirOS$
#	$OpenBSD: security,v 1.66 2003/12/28 19:51:31 otto Exp $
#	from: @@(#)security	8.1 (Berkeley) 6/9/93
#
d11 1
a11 1
DIR=`mktemp -d /tmp/_secure.XXXXXXXXXX` || exit 1
d55 1
a55 1
	if (int($7) != 0 && system("test "$7" -lt `date +%s`") == 0)
d85 2
a86 2
CUR=/var/backups/`basename $MP`.current
BACK=/var/backups/`basename $MP`.backup
d190 1
a190 1
list="/etc/ksh.kshrc `cat $TMP2`"
d273 1
a273 1
			rhost=`ls -ldgT ${homedir}/$j`
d307 1
a307 1
		file=`ls -ldgT ${homedir}`
d330 1
a330 1
			echo "${uid} ${f} `ls -ldgT ${file}`"
d357 1
a357 1
			echo "${uid} ${f} `ls -ldgT ${file}`"
d569 2
d576 1
a576 1
		tree=`sed -n -e '3s/.* //p' -e 3q $file`
d608 1
a608 1
	for file in `egrep -v "^(#|\+|$MP)" $R`; do
d627 1
a627 1
	for file in `egrep "^\+" $R`; do
d632 1
a632 1
			MD5_NEW=`md5 $file | sed 's/^.* //'`
d634 1
a634 1
				MD5_OLD="`cat $CUR`"
@


1.1
log
@Initial revision
@
text
@d1 3
a3 2
#!/bin/sh -
#
d47 1
a47 1
		else if (system("for file in .ssh .rhosts .shosts .klogin; do if test -e "$9"/$file; then if ((ls -ld "$9"/$file | cut -b 2-10 | grep -q r) && (test ! -O "$9"/$file)) ; then exit 1; fi; fi; done"))
a136 52
list="/etc/csh.cshrc /etc/csh.login ${rhome}/.cshrc ${rhome}/.login"
for i in $list ; do
	if [ -s $i ] ; then
		if egrep -q '[[:space:]]*umask[[:space:]]' $i ; then
			umaskset=yes
		fi
		awk '{
		    if ($1 == "umask") {
			 if ($2 % 100 / 10 ~ /^[0145]/)
			    print "Root umask is group writable";
			 if ($2 % 10 ~ /^[0145]/)
			    print "Root umask is other writable";
		    }
		}' < $i >> $OUTPUT
		SAVE_PATH=$PATH
		unset PATH
		/bin/csh -f -s << end-of-csh > /dev/null 2>&1
			source $i
			if (\$?path) then
				/bin/ls -ldgT \$path > $TMP1
			else
				cat /dev/null > $TMP1
			endif
end-of-csh
		PATH=$SAVE_PATH
		awk '{
			if ($10 ~ /^\.$/) {
				print "The root path includes .";
				next;
			}
		     }
		     $1 ~ /^d....w/ \
        { print "Root path directory " $10 " is group writable." } \
		     $1 ~ /^d.......w/ \
        { print "Root path directory " $10 " is other writable." }' \
		< $TMP1 >> $OUTPUT
	fi
done
if [ $umaskset = "no" -o -s $OUTPUT ] ; then
	echo "\nChecking root csh paths, umask values:\n${list}"
	if [ -s $OUTPUT ] ; then
		cat $OUTPUT
	fi
	if [ $umaskset = "no" ] ; then
		echo "\nRoot csh startup files do not set the umask."
	fi
fi

> $OUTPUT
> $TMP2
rhome=/root
umaskset=no
d151 1
a151 1
		/bin/sh << end-of-sh > /dev/null 2>&1
d325 1
a325 1
	.pgp/secring.pgp .shosts .ssh/identity .ssh/id_dsa .ssh/id_rsa"
d349 4
a352 4
      .logout .nexrc .profile .screenrc .ssh .ssh/config \
      .ssh/authorized_keys .ssh/authorized_keys2 .ssh/environment \
      .ssh/known_hosts .ssh/rc .tcshrc .twmrc .xsession .xinitrc \
      .Xdefaults .Xauthority"
d597 11
a607 1
	for file in `egrep -v "^(#|\+|$MP)" /etc/changelist`; do
d626 1
a626 1
	for file in `egrep "^\+" /etc/changelist`; do
d650 1
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@improve my Frankenstein OS (*wink* you know who you are) further
sans wchar_t of course

this is the essence of reading >1200 commit messages which suck
due to not having the new format of ours...
@
text
@d3 1
a3 1
#	$OpenBSD: security,v 1.71 2005/02/22 10:50:55 otto Exp $
d41 1
a41 1
	   ($2 !~ /^\$[0-9a-f]+\$/) && ($2 != "skey")) {
d73 3
a75 3
	while read uid; do
		grep -w $uid $TMP1
	done < $TMP2 | column
d168 1
a168 1
	{ print "Root path directory " $10 " is group writable." } \
d170 1
a170 1
	{ print "Root path directory " $10 " is other writable." }' \
d221 1
a221 1
	{ print "Root path directory " $10 " is group writable." } \
d223 1
a223 1
	{ print "Root path directory " $10 " is other writable." }' \
d444 1
a444 1
			else if ($i !~ /^-/ || $i ~ /^-network/)
d605 3
a607 3
#	mtree -cx -p DIR -K md5digest,type >/etc/mtree/DIR.secure
#	chown root:wheel /etc/mtree/DIR.secure
#	chmod 600 /etc/mtree/DIR.secure
a691 24

# Make backups of the labels for any mounted disks and produce diffs
# when they change.
for d in `df -ln | sed -n 's:^/dev/\([a-z]*[0-9]*\)[a-p].*$:\1:p' | sort -u`; do
	file=/var/backups/disklabel.$d
	CUR=$file.current
	BACK=$file.backup
	if disklabel $d > $file 2>&1 ; then
		if [ -s $CUR ] ; then
			diff -u $CUR $file > $OUTPUT
			if [ -s $OUTPUT ] ; then
	echo "\n======\n${d} diffs (-OLD  +NEW)\n======"
				cat $OUTPUT
				cp -p $CUR $BACK
				cp -p $file $CUR
				chown root:wheel $CUR $BACK
			fi
		else
			cp -p $file $CUR
			chown root:wheel $CUR
		fi
	fi
	rm -f $file
done
@

