head	1.14;
access;
symbols
	MIRBSD_10:1.9.0.2
	MIRBSD_10_BASE:1.9
	MIRBSD_9_BASE:1.5
	MIRBSD_8:1.4.0.2
	MIRBSD_8_BASE:1.4
	cvs-200507211800:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@# @;


1.14
date	2016.03.25.19.55.06;	author tg;	state Exp;
branches;
next	1.13;
commitid	10056F597B011870F52;

1.13
date	2016.03.25.19.49.15;	author tg;	state Exp;
branches;
next	1.12;
commitid	10056F596401CDD6854;

1.12
date	2009.07.18.14.09.03;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004A61D73A7953CBB8;

1.11
date	2009.03.29.13.04.15;	author tg;	state Exp;
branches;
next	1.10;
commitid	10049CF71B654F9EF54;

1.10
date	2008.12.10.18.06.05;	author tg;	state Exp;
branches;
next	1.9;
commitid	100494005235071EEB4;

1.9
date	2007.06.15.23.43.46;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004673243117F9CB1F;

1.8
date	2007.03.23.21.02.42;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004604406F3462400F;

1.7
date	2006.08.14.20.32.43;	author tg;	state Exp;
branches;
next	1.6;
commitid	10044E0DDB73A5BD9FD;

1.6
date	2006.08.09.20.54.49;	author tg;	state Exp;
branches;
next	1.5;
commitid	10044DA4BAC7A85289A;

1.5
date	2006.06.17.19.10.56;	author tg;	state Exp;
branches;
next	1.4;
commitid	100449453CE707D78E5;

1.4
date	2005.07.24.15.45.28;	author tg;	state Exp;
branches;
next	1.3;
commitid	777042e3b7a03843;

1.3
date	2005.07.07.13.39.22;	author tg;	state Exp;
branches;
next	1.2;
commitid	331742cd306446f9;

1.2
date	2005.03.06.19.05.54;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.22.11;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.22.11;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.07.21.20.45.36;	author tg;	state Exp;
branches;
next	;
commitid	560042e0092f571e;


desc
@@


1.14
log
@… ugh…
@
text
@#!/bin/mksh
# $MirSecuCron$
# $MirOS: src/etc/netstart,v 1.12 2009/07/18 14:09:03 tg Exp $
# $OpenBSD: netstart,v 1.105 2005/05/22 08:56:08 todd Exp $

export LC_ALL=C

# strip comments (and leading/trailing whitespace if IFS is set) from
# any file(s) given as argument, or stdin if none, and spew to stdout
function stripcom {
	set -o noglob
	cat "$@@" | while read _line; do
		_line=${_line%%#*}
		[[ -n $_line ]] && print -r -- $_line
	done
}

# Start the $1 interface
ifstart() {
	if=$1
	# Interface names must be alphanumeric only. We check to avoid
	# configuring backup or temp files, and to catch the "*" case.
	[[ $if = +([A-Za-z0-9]) ]] || return 0

	ifconfig $if >/dev/null 2>&1
	if [[ $? != 0 ]]; then
		# Try to create interface if it does not exist
		ifconfig $if create >/dev/null 2>&1
		if [[ $? != 0 ]]; then
			return
		fi
	fi

	# Now parse the hostname.* file
	while :; do
		if [[ -n $cmd2 ]]; then
			# We are carrying over from the 'read dt dtaddr'
			# last time.
			set -- $cmd2
			af="$1" name="$2" mask="$3" bcaddr="$4" ext1="$5" cmd2=
			# Make sure and get any remaining args in ext2,
			# like the read below
			i=1
			while [[ i -lt 6 && -n $1 ]]; do
				shift
				let i++
			done
			ext2="$@@"
		else
			# Read the next line or exit the while loop.
			read af name mask bcaddr ext1 ext2 || break
		fi
		# $af can be "dhcp", "up", "rtsol", an address family,
		# commands, or a comment.
		case "$af" in
		"#"*|"") # skip comments and empty lines
			continue
			;;
		"!"*) # parse commands
			cmd="${af#*!} ${name} ${mask} ${bcaddr} ${ext1} ${ext2}"
			;;
		bridge)
			cmd="echo /etc/hostname.$if: bridges now supported via bridgename.* files"
			;;
		dhcp)
			[[ $name = NONE ]] && name=
			[[ $mask = NONE ]] && mask=
			[[ $bcaddr = NONE ]] && bcaddr=
			ifconfig $if $name $mask $bcaddr $ext1 $ext2 down
			cmd="dhclient $if"
			;;
		route)
			routep="-n $name"
			[[ $name = +n ]] && routep=
			cmd="/sbin/route ${routep} ${mask} ${bcaddr} ${ext1} ${ext2}"
			;;
		rtsol)
			ifconfig $if $name $mask $bcaddr $ext1 $ext2 up
			rtsolif="$rtsolif $if"
			cmd=
			;;
		up)
			# The only one of these guaranteed to be set is $if.
			# The remaining ones exist so that media controls work.
			cmd="ifconfig $if $name $mask $bcaddr $ext1 $ext2 up"
			;;
		*)
			read dt dtaddr
			if [[ $name = alias ]]; then
				# perform a 'shift' of sorts
				alias=$name
				name=$mask
				mask=$bcaddr
				bcaddr=$ext1
				ext1=$ext2
				ext2=
			else
				alias=
			fi
			cmd="ifconfig $if $af $alias $name "
			case "$dt" in
			dest)
				cmd="$cmd $dtaddr"
				;;
			[a-z!]*)
				cmd2="$dt $dtaddr"
				;;
			esac
			if [[ -z $name ]]; then
				echo "/etc/hostname.$if: invalid network configuration file"
				return
			fi
			case $af in
			inet)
				[[ -n $mask ]] && \
				    if [[ $mask = @@([1-9]|[12][0-9]|3[0-2]) ]]; then
					cmd="$cmd prefixlen $mask"
				else
					cmd="$cmd netmask $mask"
				fi
				if [[ -n $bcaddr && $bcaddr != NONE ]]; then
					cmd="$cmd broadcast $bcaddr"
				fi
				[[ -n $alias ]] && rtcmd=";route -qn add -host $name 127.0.0.1"
				;;
			inet6)
				[[ -n $mask ]] && cmd="$cmd prefixlen $mask"
				cmd="$cmd $bcaddr"
				;;
			*)
				cmd="$cmd $mask $bcaddr"
				;;
			esac
			cmd="$cmd $ext1 $ext2$rtcmd" rtcmd=
			;;
		esac
		eval "$cmd"
	done </etc/hostname.$if
}

# Start multiple:
#   start "$1" interfaces in order or all interfaces if empty
#   don't start "$2" interfaces
ifmstart() {
	for sif in ${1:-ALL}; do
		for hn in /etc/hostname.*; do
			# Strip off /etc/hostname. prefix
			if=${hn#/etc/hostname.}
			test "$if" = "*" && continue

			# Skip unwanted ifs
			s=""
			for xf in $2; do
				test "$xf" = "${if%%[0-9]*}" && s="1" && break
			done
			test "$s" = "1" && continue

			# Start wanted ifs
			test "$sif" = "ALL" -o \
			     "$sif" = "${if%%[0-9]*}" \
				&& ifstart $if
		done
	done
}

# Start the $1 bridge
bridgestart() {
	# Interface names must be alphanumeric only. We check to avoid
	# configuring backup or temp files, and to catch the "*" case.
	[[ $1 = +([A-Za-z0-9]) ]] || return 0

	if ! brconfig $1 >/dev/null 2>&1; then
		# Try to create interface if it does not exist
		ifconfig $if create >/dev/null 2>&1
		if [[ $? != 0 ]]; then
			return
		fi
	fi

	# Now parse the bridgename.* file
	# All lines are run as brconfig(8) commands.
	stripcom /etc/bridgename.$1 | while read line; do
		case $line {
		("!"*)
			cmd="${line#*!}"
			;;
		(*)
			cmd="brconfig $1 $line"
			;;
		}
		eval "$cmd"
	done
}

# Re-read /etc/rc.conf
. /etc/rc.conf

# If we were invoked with a list of interface names, just reconfigure these
# interfaces (or bridges) and return.
[[ $1 = autoboot ]] && shift
if [ $# -gt 0 ]; then
	while [ $# -gt 0 ]; do
		if [ -f /etc/bridgename.$1 ]; then
			bridgestart $1
		else
			ifstart $1
		fi
		shift
	done
	return
fi

# Otherwise, process with the complete network initialization.

# Since no interface is set up yet, using DNS is pointless.
if [[ -e /etc/resolv.conf ]]; then
	T=/etc/resolv.conf.$RANDOM
	mv /etc/resolv.conf $T
	echo lookup file >/etc/resolv.conf
else
	T=fail
fi

# /etc/myname contains my symbolic name
if [ -f /etc/myname ]; then
	hostname=$(stripcom /etc/myname)
	hostname $hostname
else
	hostname=$(hostname)
fi

# Set the address for the loopback interface. Bringing the
# interface up automatically invokes the IPv6 address ::1.
ifconfig lo0 inet 127.0.0.1

if ifconfig lo0 inet6 >/dev/null 2>&1; then
	# IPv6 configurations.
	ip6kernel=YES

	# Disallow link-local unicast dest without outgoing scope identifiers.
	route -qn add -inet6 fe80:: -prefixlen 10 ::1 -reject >/dev/null

	# Disallow site-local unicast dest without outgoing scope identifiers.
	# If you configure site-locals without scope id (it is permissible
	# config for routers that are not on scope boundary), you may want
	# to comment the line out.
	route -qn add -inet6 fec0:: -prefixlen 10 ::1 -reject >/dev/null

	# Disallow "internal" addresses to appear on the wire.
	route -qn add -inet6 ::ffff:0.0.0.0 -prefixlen 96 ::1 -reject >/dev/null

	# Disallow packets to malicious IPv4 compatible prefix.
	route -qn add -inet6 ::224.0.0.0 -prefixlen 100 ::1 -reject >/dev/null
	route -qn add -inet6 ::127.0.0.0 -prefixlen 104 ::1 -reject >/dev/null
	route -qn add -inet6 ::0.0.0.0 -prefixlen 104 ::1 -reject >/dev/null
	route -qn add -inet6 ::255.0.0.0 -prefixlen 104 ::1 -reject >/dev/null

	# Disallow packets to malicious 6to4 prefix.
	route -qn add -inet6 2002:e000:: -prefixlen 20 ::1 -reject >/dev/null
	route -qn add -inet6 2002:7f00:: -prefixlen 24 ::1 -reject >/dev/null
	route -qn add -inet6 2002:0000:: -prefixlen 24 ::1 -reject >/dev/null
	route -qn add -inet6 2002:ff00:: -prefixlen 24 ::1 -reject >/dev/null

	# Completely disallow packets to IPv4 compatible prefix.
	# This may conflict with RFC1933 under following circumstances:
	# (1) An IPv6-only KAME node tries to originate packets to IPv4
	#     compatible destination.  The KAME node has no IPv4 compatible
	#     support.  Under RFC1933, it should transmit native IPv6
	#     packets toward IPv4 compatible destination, hoping it would
	#     reach a router that forwards the packet toward auto-tunnel
	#     interface.
	# (2) An IPv6-only node originates a packet to an IPv4 compatible
	#     destination.  A KAME node is acting as an IPv6 router, and
	#     asked to forward it.
	# Due to rare use of IPv4 compatible addresses, and security issues
	# with it, we disable it by default.
	route -qn add -inet6 ::0.0.0.0 -prefixlen 96 ::1 -reject >/dev/null

	rtsolif=""
else
	ip6kernel=NO
fi

# Now put back the DNS resolver config
[[ $T = fail ]] || mv $T /etc/resolv.conf

# Configure all the non-loopback interfaces which we know about, but
# do not start interfaces which must be delayed.
# Refer to hostname.if(5) and bridgename.if(5)
ifmstart "" "carp gif gre pfsync pppoe local"

if [[ $ip6kernel = YES && -n $rtsolif ]]; then
	fw=$(sysctl -n net.inet6.ip6.forwarding)
	ra=$(sysctl -n net.inet6.ip6.accept_rtadv)
	if [[ $fw = 0 && $ra = 1 ]]; then
		echo "IPv6 autoconf:$rtsolif"
		rtsol $rtsolif
	else
		echo "WARNING: inconsistent config - check /etc/sysctl.conf for IPv6 autoconf"
	fi
fi
if [[ $ip6kernel = YES ]]; then
	# this is to make sure DAD is completed before going further.
	sleep $(sysctl -n net.inet6.ip6.dad_count)
fi

# The pfsync interface needs to come up before carp.
# Configure all the carp interfaces which we know about.
# They must come up after pfsync but before default route.
ifmstart "pfsync carp" "local"

# Multicast routing.
#
# The routing to the 224.0.0.0/4 net is setup according to these rules:
# multicast_host	multicast_router	route		comment
# NO			NO			-reject		no multicast
# NO			YES			none installed	daemon will run
# YES/interface		NO			-interface	YES=def. iface
#	   Any other combination		-reject		config error
case "$multicast_host:$multicast_router" in
NO:NO)
	route -qn add -net 224.0.0.0/4 -interface 127.0.0.1 -reject >/dev/null
	;;
NO:YES)
	;;
*:NO)
	set $(if [ $multicast_host = YES ]; then
		ed -s '!route -qn show -inet' <<EOF
/^default/p
EOF
	else
		ed -s "!ifconfig $multicast_host" <<EOF
/^	inet /p
EOF
	fi)
	route -qn add -net 224.0.0.0/4 -interface $2 >/dev/null
	;;
*:*)
	echo 'config error, multicasting disabled until rc.conf is fixed'
	route -qn add -net 224.0.0.0/4 -interface 127.0.0.1 -reject >/dev/null
	;;
esac


# Configure PPPoE, GIF, GRE interfaces, delayed because they require routes
# to be set. PPPoE must be first, as GIF and GRE may depend on it.
ifmstart "pppoe gif gre" "local"

# reject 127/8 other than 127.0.0.1
route -qn add -net 127 127.0.0.1 -reject >/dev/null

# Configure all the bridges.
for bn in /etc/bridgename.*; do
	# Strip off /etc/bridgename. prefix
	if=${bn#/etc/bridgename.}
	test "$if" = "*" && continue

	bridgestart $if
done

[[ -s /etc/hostname.local ]] && . /etc/hostname.local
@


1.13
log
@prepare most scripts for locale tracking; drop some TZ=UTC; use modern mksh
@
text
@a17 14
# Returns true if $1 contains only alphanumerics
isalphanumeric() {
	typeset _n
	_n=$1
	while [ ${#_n} != 0 ]; do
		case $_n in
			[A-Za-z0-9]*)	;;
			*)		return 1;;
		esac
		_n=${_n#?}
	done
	return 0
}

d21 1
a21 1
	# Interface names must be alphanumeric only.  We check to avoid
d23 1
a23 3
	if ! isalphanumeric "$if"; then
		return
	fi
d89 1
a89 1
			if [[ $name  = alias ]]; then
d168 1
a168 1
	# Interface names must be alphanumeric only.  We check to avoid
d170 3
a172 5
	if ! isalphanumeric "$1"; then
		return
	fi
	brconfig $1 >/dev/null 2>&1
	if [[ $? != 0 ]]; then
d182 3
a184 5
	while read line ; do
		line=${line%%#*}		# strip comments
		test -z "$line" && continue
		case "$line" in
		"!"*)
d187 1
a187 1
		*)
d190 1
a190 1
		esac
d192 1
a192 1
	done </etc/bridgename.$1
d232 2
a233 2
# Set the address for the loopback interface.  Bringing the
# interface up, automatically invokes the IPv6 address ::1)
d346 1
a346 1
# to be set.  PPPoE must be first, as GIF and GRE may depend on it.
@


1.12
log
@prevent data corruption from /etc/security’s automated backup cronjob
by using “MirSecuCron” as RCS ID for these and preventing it from ex-
panding any of the default keywords

also, add RCS IDs to almost all configuration files and enhance the
default changelist file
@
text
@d3 1
a3 1
# $MirOS: src/etc/netstart,v 1.11 2009/03/29 13:04:15 tg Exp $
d6 2
d10 3
a12 3
function stripcom
{
	cat "$@@" | { set -o noglob; while read _line; do
d15 1
a15 1
	done; }
d381 1
a381 1
[[ -e /etc/hostname.local ]] && eval $(stripcom /etc/hostname.local)
@


1.11
log
@• take care of dbins
• #!/bin/mksh shebang, in most places
• rcsid while here
@
text
@d2 2
a3 1
# $MirOS: src/etc/netstart,v 1.10 2008/12/10 18:06:05 tg Exp $
@


1.10
log
@use relative paths to mksh
@
text
@d1 2
a2 2
#!/usr/bin/env mksh
# $MirOS: src/etc/netstart,v 1.9 2007/06/15 23:43:46 tg Exp $
@


1.9
log
@fixup for integer, typeset, local
(not regenerating MAKEDEVs because they use #!/bin/mksh but still, for style)
@
text
@d1 2
a2 2
#!/bin/mksh
# $MirOS: src/etc/netstart,v 1.8 2007/03/23 21:02:42 tg Exp $
@


1.8
log
@• sync stripcom() with mksh/dot.profile sample
• support prefixlens for netmasks (expressed as integer [1..32]), yay!
@
text
@d2 1
a2 1
# $MirOS: src/etc/netstart,v 1.7 2006/08/14 20:32:43 tg Exp $
d17 1
a17 1
	local _n
@


1.7
log
@rewrite stripcom/Lstripcom function, making use of the 'last command
of a pipeline is executed in a subshell' trick, don't use co-process
(because that's verbose twice in an interactive shell profile), move
the noglob block into the while and rid the redundant +o and local.
@
text
@d2 1
a2 1
# $MirOS: src/etc/netstart,v 1.6 2006/08/09 20:54:49 tg Exp $
d9 1
a9 2
	cat "$@@" | while read _line; do
		set -o noglob
d12 1
a12 1
	done
d128 6
a133 1
				[[ -n $mask ]] && cmd="$cmd netmask $mask"
@


1.6
log
@sync stripcom function
@
text
@d2 1
a2 1
# $MirOS: src/etc/netstart,v 1.5 2006/06/17 19:10:56 tg Exp $
d9 2
a10 4
	local _line
	set -o noglob
	cat "$@@" |&
	while read -p _line; do
a13 1
	set +o noglob
d159 1
a159 1
	
d161 1
a161 1
			s=""	
@


1.5
log
@no point in using /usr(sic!)/bin/mktemp here
@
text
@d2 1
a2 1
# $MirOS: src/etc/netstart,v 1.4 2005/07/24 15:45:28 tg Exp $
d5 4
a8 4
# Strip comments (and leading/trailing whitespace if IFS is set)
# from a file and spew to stdout
stripcom() {
	local _file="$1"
d10 7
a16 8

	{
		while read _line; do
			_line=${_line%%#*}		# strip comments
			test -z "$_line" && continue
			echo $_line
		done
	} <$_file
@


1.4
log
@merge [A-Za-p] and improve where possible/necessary
@
text
@d2 1
a2 1
# $MirOS: src/etc/netstart,v 1.3 2005/07/07 13:39:22 tg Exp $
d233 2
a234 3
if [ ! -e /etc/resolv.conf ]; then
	T=fail
elif T=$(mktemp /etc/resolv.conf.XXXXXXXXXX); then
@


1.3
log
@/bin/sh and /bin/ksh -> /bin/mksh

This should cover most uses.
@
text
@d2 17
a18 2
# $MirOS: src/etc/netstart,v 1.2 2005/03/06 19:05:54 tg Exp $
# $OpenBSD: netstart,v 1.99 2004/12/04 00:17:05 itojun Exp $
d154 25
d244 1
a244 1
	hostname=$(</etc/myname)
d305 2
a306 1
# Configure all the non-loopback interfaces which we know about.
d308 1
a308 20
for hn in /etc/hostname.*; do
	# Strip off /etc/hostname. prefix
	if=${hn#/etc/hostname.}
	test "$if" = "*" && continue

	case $if in
	"carp"*|"gif"*|"gre"*|"pfsync"*)
		# CARP, GIF, GRE and PFSYNC interfaces need the routes to be setup
		# before they are configured.
		continue
		;;
	local)
		# A list of commands to be run after netstart.
		continue
		;;
	*)
		ifstart $if
		;;
	esac
done
d325 5
a361 11
# The pfsync interface needs to come up before carp.
if [ -f /etc/hostname.pfsync0 ]; then
	ifstart pfsync0
fi

# Configure all the carp, gif and gre interfaces which we know about.
# They were delayed because they require the routes to be set.
for hn in /etc/hostname.*; do
	# Strip off /etc/hostname. prefix
	if=${hn#/etc/hostname.}
	test "$if" = "*" && continue
d363 3
a365 10
	case $if in
	"carp"*|"gif"*|"gre"*)
		ifstart $if
		;;
	*)
		# Regular interfaces have already been configured.
		continue
		;;
	esac
done
d379 1
a379 4
[[ -e /etc/hostname.local ]] && while read line; do
	line=${line%%#*}		# strip comments
	test -n "$line" && eval "$line"
done </etc/hostname.local
@


1.2
log
@merge src/etc minus generated files
@
text
@d1 2
a2 2
#!/bin/ksh
# $MirOS$
@


1.1
log
@Initial revision
@
text
@d1 3
a3 3
#!/bin/sh -
#
#	$OpenBSD: netstart,v 1.99 2004/12/04 00:17:05 itojun Exp $
d28 2
a29 2
	ifconfig $if > /dev/null 2>&1
	if [ "$?" != "0" ]; then
d31 2
a32 2
		ifconfig $if create > /dev/null 2>&1
		if [ "$?" != "0" ]; then
d39 1
a39 1
		if [ "$cmd2" ]; then
d47 4
a50 1
			while [ i -lt 6 -a -n "$1" ]; do shift; let i=i+1; done
d65 1
a65 1
		"bridge")
d68 4
a71 4
		"dhcp")
			[ "$name" = "NONE" ] && name=
			[ "$mask" = "NONE" ] && mask=
			[ "$bcaddr" = "NONE" ] && bcaddr=
d75 6
a80 1
		"rtsol")
d85 1
a85 1
		"up")
d92 1
a92 1
			if [ "$name"  = "alias" ]; then
d112 1
a112 1
			if [ ! -n "$name" ]; then
d118 2
a119 2
				[ "$mask" ] && cmd="$cmd netmask $mask"
				if [ "$bcaddr" -a "X$bcaddr" != "XNONE" ]; then
d122 1
a122 1
				[ "$alias" ] && rtcmd=";route -qn add -host $name 127.0.0.1"
d124 2
a125 1
			inet6) [ "$mask" ] && cmd="$cmd prefixlen $mask"
d136 1
a136 1
	done < /etc/hostname.$if
d146 2
a147 2
	brconfig $1 > /dev/null 2>&1
	if [ "$?" != "0" ]; then
d149 2
a150 2
		ifconfig $if create > /dev/null 2>&1
		if [ "$?" != "0" ]; then
d169 1
a169 1
	done < /etc/bridgename.$1
d177 1
a177 3
if [ $1x = autobootx ]; then
	shift
fi
d192 10
d204 1
a204 1
	hostname=`cat /etc/myname`
d207 1
a207 5
	hostname=`hostname`
fi

if [ -f /etc/defaultdomain ]; then
	domainname `cat /etc/defaultdomain`
d219 1
a219 1
	route -qn add -inet6 fe80:: -prefixlen 10 ::1 -reject > /dev/null
d225 1
a225 1
	route -qn add -inet6 fec0:: -prefixlen 10 ::1 -reject > /dev/null
d228 1
a228 1
	route -qn add -inet6 ::ffff:0.0.0.0 -prefixlen 96 ::1 -reject > /dev/null
d231 4
a234 4
	route -qn add -inet6 ::224.0.0.0 -prefixlen 100 ::1 -reject > /dev/null
	route -qn add -inet6 ::127.0.0.0 -prefixlen 104 ::1 -reject > /dev/null
	route -qn add -inet6 ::0.0.0.0 -prefixlen 104 ::1 -reject > /dev/null
	route -qn add -inet6 ::255.0.0.0 -prefixlen 104 ::1 -reject > /dev/null
d237 4
a240 4
	route -qn add -inet6 2002:e000:: -prefixlen 20 ::1 -reject > /dev/null
	route -qn add -inet6 2002:7f00:: -prefixlen 24 ::1 -reject > /dev/null
	route -qn add -inet6 2002:0000:: -prefixlen 24 ::1 -reject > /dev/null
	route -qn add -inet6 2002:ff00:: -prefixlen 24 ::1 -reject > /dev/null
d255 1
a255 1
	route -qn add -inet6 ::0.0.0.0 -prefixlen 96 ::1 -reject > /dev/null
d262 3
d278 4
d288 4
a291 4
if [ "$ip6kernel" = "YES" -a "x$rtsolif" != "x" ]; then
	fw=`sysctl -n net.inet6.ip6.forwarding`
	ra=`sysctl -n net.inet6.ip6.accept_rtadv`
	if [ "x$fw" = "x0" -a "x$ra" = "x1" ]; then
d298 1
a298 1
if [ "$ip6kernel" = "YES" ]; then
d300 1
a300 8
	sleep `sysctl -n net.inet6.ip6.dad_count`
fi

# /etc/mygate, if it exists, contains the name of my gateway host
# that name must be in /etc/hosts.
if [ -f /etc/mygate ]; then
	route -qn delete default > /dev/null 2>&1
	route -qn add -host default `cat /etc/mygate`
d313 1
a313 1
	route -qn add -net 224.0.0.0/4 -interface 127.0.0.1 -reject > /dev/null
d318 1
a318 1
	set `if [ $multicast_host = YES ]; then
d326 2
a327 2
	fi`
	route -qn add -net 224.0.0.0/4 -interface $2 > /dev/null
d331 1
a331 1
	route -qn add -net 224.0.0.0/4 -interface 127.0.0.1 -reject > /dev/null
d337 1
a337 1
		ifstart pfsync0
d359 1
a359 1
route -qn add -net 127 127.0.0.1 -reject > /dev/null
d369 5
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d3 1
a3 16
#	$OpenBSD: netstart,v 1.105 2005/05/22 08:56:08 todd Exp $

# Strip comments (and leading/trailing whitespace if IFS is set)
# from a file and spew to stdout
stripcom() {
	local _file="$1"
	local _line

	{
		while read _line ; do
			_line=${_line%%#*}		# strip comments
			test -z "$_line" && continue
			echo $_line
		done
	} < $_file
}
a70 1
			setgateway=N
a129 25
# Start multiple:
#   start "$1" interfaces in order or all interfaces if empty
#   don't start "$2" interfaces
ifmstart() {
	for sif in ${1:-ALL}; do
		for hn in /etc/hostname.*; do
			# Strip off /etc/hostname. prefix
			if=${hn#/etc/hostname.}
			test "$if" = "*" && continue
	
			# Skip unwanted ifs
			s=""	
			for xf in $2; do
				test "$xf" = "${if%%[0-9]*}" && s="1" && break
			done
			test "$s" = "1" && continue

			# Start wanted ifs
			test "$sif" = "ALL" -o \
			     "$sif" = "${if%%[0-9]*}" \
				&& ifstart $if
		done
	done
}

d187 1
a187 1
	hostname=`stripcom /etc/myname`
d194 1
a194 1
	domainname `stripcom /etc/defaultdomain`
d249 6
d256 11
a266 4
# Configure all the non-loopback interfaces which we know about, but
# do not start interfaces which must be delayed.
# Refer to hostname.if(5) and bridgename.if(5)
ifmstart "" "carp gif gre pfsync pppoe"
a282 5
# The pfsync interface needs to come up before carp.
# Configure all the carp interfaces which we know about.
# They must come up after pfsync but before default route.
ifmstart "pfsync carp"

d285 1
a285 1
if [ "X${setgateway}" != X"N" -a -f /etc/mygate ]; then
d287 1
a287 1
	route -qn add -host default `stripcom /etc/mygate`
d322 11
d334 10
a343 3
# Configure PPPoE, GIF, GRE interfaces, delayed because they require routes
# to be set.  PPPoE must be first, as GIF and GRE may depend on it.
ifmstart "pppoe gif gre"
@

