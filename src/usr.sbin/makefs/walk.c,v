head	1.11;
access;
symbols
	cvs-201003062040:1.1.3.3
	cvs-200810311900:1.1.3.2
	MIRBSD_10:1.2.0.2
	MIRBSD_10_BASE:1.2
	cvs-200607051500:1.1.3.1
	netbsd:1.1.3;
locks; strict;
comment	@ * @;


1.11
date	2010.03.07.00.02.17;	author tg;	state Exp;
branches;
next	1.10;
commitid	1004B92ED1350BD9E9D;

1.10
date	2010.03.06.23.24.15;	author tg;	state Exp;
branches;
next	1.9;
commitid	1004B92E431600E22B7;

1.9
date	2010.03.06.21.29.05;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004B92C8D37339B566;

1.8
date	2009.07.23.19.32.24;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004A68BAC01D44054A;

1.7
date	2008.12.26.23.37.54;	author tg;	state Exp;
branches;
next	1.6;
commitid	10049556AAF4DD0407E;

1.6
date	2008.12.26.23.02.16;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004955627F1EDA1DF2;

1.5
date	2008.11.06.18.13.22;	author tg;	state Exp;
branches;
next	1.4;
commitid	100491333D962AA8CD8;

1.4
date	2008.10.31.21.24.24;	author tg;	state Exp;
branches;
next	1.3;
commitid	100490B7799471618CD;

1.3
date	2008.10.31.19.11.33;	author tg;	state Exp;
branches;
next	1.2;
commitid	100490B58676FCB2D2F;

1.2
date	2007.05.19.23.17.48;	author tg;	state Exp;
branches;
next	1.1;
commitid	100464F859F79495987;

1.1
date	2006.07.05.15.08.37;	author tg;	state Exp;
branches
	1.1.3.1;
next	;
commitid	10044ABD6033365D559;

1.1.3.1
date	2006.07.05.15.08.37;	author tg;	state Exp;
branches;
next	1.1.3.2;
commitid	10044ABD6033365D559;

1.1.3.2
date	2008.10.31.19.06.04;	author tg;	state Exp;
branches;
next	1.1.3.3;
commitid	100490B57202F143953;

1.1.3.3
date	2010.03.06.20.44.40;	author tg;	state Exp;
branches;
next	;
commitid	1004B92BEC54F4CD073;


desc
@@


1.11
log
@get rid of PATH_MAX and MAXPATHLEN uses (probably could use asprintf thoâ€¦)
@
text
@/*	$NetBSD: walk.c,v 1.24 2008/12/28 21:51:46 christos Exp $	*/

/*
 * Copyright (c) 2009, 2010
 *	Thorsten Glaser <tg@@mirbsd.org>
 * Copyright (c) 2001 Wasabi Systems, Inc.
 * All rights reserved.
 *
 * Written by Luke Mewburn for Wasabi Systems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed for the NetBSD Project by
 *      Wasabi Systems, Inc.
 * 4. The name of Wasabi Systems, Inc. may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#if HAVE_NBTOOL_CONFIG_H
#include "nbtool_config.h"
#endif

#include <sys/cdefs.h>
#if defined(__RCSID) && !defined(__lint)
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/walk.c,v 1.10 2010/03/06 23:24:15 tg Exp $");
__RCSID("$NetBSD: walk.c,v 1.24 2008/12/28 21:51:46 christos Exp $");
#endif	/* !__lint */

#include <sys/param.h>
#include <sys/time.h>
#include <sys/stat.h>

#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <dirent.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "makefs.h"
#include "mtree.h"

static	void	 apply_specdir(const char *, NODE *, fsnode *, int);
static	void	 apply_specentry(const char *, NODE *, fsnode *);
static	fsnode	*create_fsnode(const char *, struct stat *);
static	fsinode	*link_check(fsinode *);

static uint32_t vinode = 3;

/*
 * walk_dir --
 *	build a tree of fsnodes from `dir', with a parent fsnode of `parent'
 *	(which may be NULL for the root of the tree).
 *	each "level" is a directory, with the "." entry guaranteed to be
 *	at the start of the list, and without ".." entries.
 */
fsnode *
walk_dir(const char *dir, fsnode *parent)
{
	fsnode		*first, *cur, *prev;
	DIR		*dirp;
	struct dirent	*dent;
	char		*path;
	struct stat	stbuf;

	assert(dir != NULL);
	if ((path = malloc(maxpathlen + 1)) == NULL)
		err(1, "malloc");

	if (debug & DEBUG_WALK_DIR)
		printf("walk_dir: %s %p\n", dir, parent);
	if ((dirp = opendir(dir)) == NULL)
		err(1, "Can't opendir `%s'", dir);
	first = prev = NULL;
	while ((dent = readdir(dirp)) != NULL) {
		if (strcmp(dent->d_name, "..") == 0)
			continue;
		if (debug & DEBUG_WALK_DIR_NODE)
			printf("scanning %s/%s\n", dir, dent->d_name);
		if ((size_t)snprintf(path, maxpathlen, "%s/%s", dir, dent->d_name)
		    >= maxpathlen)
			errx(1, "Pathname too long.");
		if (lstat(path, &stbuf) == -1)
			err(1, "Can't lstat `%s'", path);
#ifdef S_ISSOCK
		if (S_ISSOCK(stbuf.st_mode & S_IFMT)) {
			if (debug & DEBUG_WALK_DIR_NODE)
				printf("  skipping socket %s\n", path);
			continue;
		}
#endif

		cur = create_fsnode(dent->d_name, &stbuf);
		cur->parent = parent;
		if (strcmp(dent->d_name, ".") == 0) {
				/* ensure "." is at the start of the list */
			if (cur->parent)
				cur->inode->serno = cur->parent->inode->serno;
			cur->next = first;
			first = cur;
			if (! prev)
				prev = cur;
		} else {			/* not "." */
			if (prev)
				prev->next = cur;
			prev = cur;
			if (!first)
				first = cur;
			if (S_ISDIR(cur->type)) {
				cur->inode->serno = vinode++;
				cur->child = walk_dir(path, cur);
				continue;
			}
		}
		if (stbuf.st_nlink > 1) {
			fsinode	*curino;

			curino = link_check(cur->inode);
			if (curino != NULL) {
				free(cur->inode);
				cur->inode = curino;
				cur->inode->nlink++;
				if (debug & DEBUG_WALK_DIR_LINKCHECK)
					printf("link_check: found [%llu, %llu]\n",
					    (unsigned long long)curino->st.st_dev,
					    (unsigned long long)curino->st.st_ino);
			}
		}
		if (!cur->inode->serno)
			cur->inode->serno = vinode++;
		if (S_ISLNK(cur->type)) {
			int llen;
			char *slink;

			if ((slink = malloc(stbuf.st_size + 1)) == NULL)
				err(1, "malloc");
			llen = readlink(path, slink, stbuf.st_size);
			if (llen == -1)
				err(1, "Readlink `%s'", path);
			slink[llen] = '\0';
			cur->symlink = slink;
		}
	}
	for (cur = first; cur != NULL; cur = cur->next)
		cur->first = first;
	if (closedir(dirp) == -1)
		err(1, "Can't closedir `%s'", dir);
	free(path);
	return (first);
}

static fsnode *
create_fsnode(const char *name, struct stat *stbuf)
{
	fsnode *cur;

	if ((cur = calloc(1, sizeof(fsnode))) == NULL ||
	    (cur->name = strdup(name)) == NULL ||
	    (cur->inode = calloc(1, sizeof(fsinode))) == NULL)
		err(1, "Memory allocation error");
	cur->type = stbuf->st_mode & S_IFMT;
	cur->inode->nlink = 1;
	cur->inode->st = *stbuf;
	return (cur);
}

/*
 * free_fsnodes --
 *	Removes node from tree and frees it and all of
 *   its decendents.
 */
void
free_fsnodes(fsnode *node)
{
	fsnode	*cur, *next;

	assert(node != NULL);

	/* for ".", start with actual parent node */
	if (node->first == node) {
		assert(node->name[0] == '.' && node->name[1] == '\0');
		if (node->parent) {
			assert(node->parent->child == node);
			node = node->parent;
		}
	}

	/* Find ourselves in our sibling list and unlink */
	if (node->first != node) {
		for (cur = node->first; cur->next; cur = cur->next) {
			if (cur->next == node) {
				cur->next = node->next;
				node->next = NULL;
				break;
			}
		}
	}

	for (cur = node; cur != NULL; cur = next) {
		next = cur->next;
		if (cur->child) {
			cur->child->parent = NULL;
			free_fsnodes(cur->child);
		}
		if (cur->inode->nlink-- == 1)
			free(cur->inode);
		if (cur->symlink)
			free(cur->symlink);
		free(cur->name);
		free(cur);
	}
}

/*
 * apply_specfile --
 *	read in the mtree(8) specfile, and apply it to the tree
 *	at dir,parent. parameters in parent on equivalent types
 *	will be changed to those found in specfile, and missing
 *	entries will be added.
 */
void
apply_specfile(const char *specfile, const char *dir, fsnode *parent, int speconly)
{
	struct timeval	 start;
	FILE	*fp;
	NODE	*root;

	assert(specfile != NULL);
	assert(parent != NULL);

	if (debug & DEBUG_APPLY_SPECFILE)
		printf("apply_specfile: %s, %s %p\n", specfile, dir, parent);

				/* read in the specfile */
	if ((fp = fopen(specfile, "r")) == NULL)
		err(1, "Can't open `%s'", specfile);
	TIMER_START(start);
	root = spec(fp);
	TIMER_RESULTS(start, "spec");
	if (fclose(fp) == EOF)
		err(1, "Can't close `%s'", specfile);

				/* perform some sanity checks */
	if (root == NULL)
		errx(1, "Specfile `%s' did not contain a tree", specfile);
	assert(strcmp(root->name, ".") == 0);
	assert(root->type == F_DIR);

				/* merge in the changes */
	apply_specdir(dir, root, parent, speconly);

	free_nodes(root);
}

static void
apply_specdir(const char *dir, NODE *specnode, fsnode *dirnode, int speconly)
{
	char	 *path;
	NODE	*curnode;
	fsnode	*curfsnode;

	assert(specnode != NULL);
	assert(dirnode != NULL);
	if ((path = malloc(maxpathlen + 1)) == NULL)
		err(1, "malloc");

	if (debug & DEBUG_APPLY_SPECFILE)
		printf("apply_specdir: %s %p %p\n", dir, specnode, dirnode);

	if (specnode->type != F_DIR)
		errx(1, "Specfile node `%s/%s' is not a directory",
		    dir, specnode->name);
	if (dirnode->type != S_IFDIR)
		errx(1, "Directory node `%s/%s' is not a directory",
		    dir, dirnode->name);

	apply_specentry(dir, specnode, dirnode);

	/* Remove any filesystem nodes not found in specfile */
	/* XXX inefficient.  This is O^2 in each dir and it would
	 * have been better never to have walked this part of the tree
	 * to begin with
	 */
	if (speconly) {
		fsnode *next;
		assert(dirnode->name[0] == '.' && dirnode->name[1] == '\0');
		for (curfsnode = dirnode->next; curfsnode != NULL; curfsnode = next) {
			next = curfsnode->next;
			for (curnode = specnode->child; curnode != NULL;
			     curnode = curnode->next) {
				if (strcmp(curnode->name, curfsnode->name) == 0)
					break;
			}
			if (curnode == NULL) {
				if (debug & DEBUG_APPLY_SPECONLY) {
					printf("apply_specdir: trimming %s/%s %p\n", dir, curfsnode->name, curfsnode);
				}
				free_fsnodes(curfsnode);
			}
		}
	}

			/* now walk specnode->child matching up with dirnode */
	for (curnode = specnode->child; curnode != NULL;
	    curnode = curnode->next) {
		if (debug & DEBUG_APPLY_SPECENTRY)
			printf("apply_specdir:  spec %s\n",
			    curnode->name);
		for (curfsnode = dirnode->next; curfsnode != NULL;
		    curfsnode = curfsnode->next) {
#if 0	/* too verbose for now */
			if (debug & DEBUG_APPLY_SPECENTRY)
				printf("apply_specdir:  dirent %s\n",
				    curfsnode->name);
#endif
			if (strcmp(curnode->name, curfsnode->name) == 0)
				break;
		}
		if ((size_t)snprintf(path, maxpathlen, "%s/%s",
		    dir, curnode->name) >= maxpathlen)
			errx(1, "Pathname too long.");
		if (curfsnode == NULL) {	/* need new entry */
			struct stat	stbuf;

					    /*
					     * don't add optional spec entries
					     * that lack an existing fs entry
					     */
			if ((curnode->flags & F_OPT) &&
			    lstat(path, &stbuf) == -1)
					continue;

					/* check that enough info is provided */
#define NODETEST(t, m)							\
			if (!(t))					\
				errx(1, "`%s': %s not provided", path, m)
			NODETEST(curnode->flags & F_TYPE, "type");
			NODETEST(curnode->flags & F_MODE, "mode");
				/* XXX: require F_TIME ? */
			NODETEST(curnode->flags & F_GID ||
			    curnode->flags & F_GNAME, "group");
			NODETEST(curnode->flags & F_UID ||
			    curnode->flags & F_UNAME, "user");
			if (curnode->type == F_BLOCK || curnode->type == F_CHAR)
				NODETEST(curnode->flags & F_DEV,
				    "device number");
#undef NODETEST

			if (debug & DEBUG_APPLY_SPECFILE)
				printf("apply_specdir: adding %s\n",
				    curnode->name);
					/* build minimal fsnode */
			memset(&stbuf, 0, sizeof(stbuf));
			stbuf.st_mode = nodetoino(curnode->type);
			stbuf.st_nlink = 1;
			stbuf.st_mtime = stbuf.st_atime =
			    stbuf.st_ctime = start_time.tv_sec;
#if HAVE_STRUCT_STAT_ST_MTIMENSEC
			stbuf.st_mtimensec = stbuf.st_atimensec =
			    stbuf.st_ctimensec = start_time.tv_nsec;
#endif
			curfsnode = create_fsnode(curnode->name, &stbuf);
			curfsnode->parent = dirnode->parent;
			curfsnode->first = dirnode;
			curfsnode->next = dirnode->next;
			dirnode->next = curfsnode;
			if (curfsnode->type == S_IFDIR) {
					/* for dirs, make "." entry as well */
				curfsnode->child = create_fsnode(".", &stbuf);
				curfsnode->child->parent = curfsnode;
				curfsnode->child->first = curfsnode->child;
			}
			if (curfsnode->type == S_IFLNK) {
				assert(curnode->slink != NULL);
					/* for symlinks, copy the target */
				if ((curfsnode->symlink =
				    strdup(curnode->slink)) == NULL)
					err(1, "Memory allocation error");
			}
		}
		apply_specentry(dir, curnode, curfsnode);
		if (curnode->type == F_DIR) {
			if (curfsnode->type != S_IFDIR)
				errx(1, "`%s' is not a directory", path);
			assert (curfsnode->child != NULL);
			apply_specdir(path, curnode, curfsnode->child, speconly);
		}
	}
	free(path);
}

static void
apply_specentry(const char *dir, NODE *specnode, fsnode *dirnode)
{

	assert(specnode != NULL);
	assert(dirnode != NULL);

	if (nodetoino(specnode->type) != dirnode->type)
		errx(1, "`%s/%s' type mismatch: specfile %s, tree %s",
		    dir, specnode->name, inode_type(nodetoino(specnode->type)),
		    inode_type(dirnode->type));

	if (debug & DEBUG_APPLY_SPECENTRY)
		printf("apply_specentry: %s/%s\n", dir, dirnode->name);

#define ASEPRINT(t, b, o, n) \
		if (debug & DEBUG_APPLY_SPECENTRY) \
			printf("\t\t\tchanging %s from " b " to " b "\n", \
			    t, o, n)

	if (specnode->flags & (F_GID | F_GNAME)) {
		ASEPRINT("gid", "%d",
		    dirnode->inode->st.st_gid, specnode->st_gid);
		dirnode->inode->st.st_gid = specnode->st_gid;
	}
	if (specnode->flags & F_MODE) {
		ASEPRINT("mode", "%#o",
		    dirnode->inode->st.st_mode & ALLPERMS, specnode->st_mode);
		dirnode->inode->st.st_mode &= ~ALLPERMS;
		dirnode->inode->st.st_mode |= (specnode->st_mode & ALLPERMS);
	}
		/* XXX: ignoring F_NLINK for now */
	if (specnode->flags & F_SIZE) {
		ASEPRINT("size", "%lld",
		    (long long)dirnode->inode->st.st_size,
		    (long long)specnode->st_size);
		dirnode->inode->st.st_size = specnode->st_size;
	}
	if (specnode->flags & F_SLINK) {
		assert(dirnode->symlink != NULL);
		assert(specnode->slink != NULL);
		ASEPRINT("symlink", "%s", dirnode->symlink, specnode->slink);
		free(dirnode->symlink);
		if ((dirnode->symlink = strdup(specnode->slink)) == NULL)
			err(1, "Memory allocation error");
	}
	if (specnode->flags & F_TIME) {
		ASEPRINT("time", "%ld",
		    (long)dirnode->inode->st.st_mtime,
		    (long)specnode->st_mtimespec.tv_sec);
		dirnode->inode->st.st_mtime =		specnode->st_mtimespec.tv_sec;
		dirnode->inode->st.st_atime =		specnode->st_mtimespec.tv_sec;
		dirnode->inode->st.st_ctime =		start_time.tv_sec;
#if HAVE_STRUCT_STAT_ST_MTIMENSEC
		dirnode->inode->st.st_mtimensec =	specnode->st_mtimespec.tv_nsec;
		dirnode->inode->st.st_atimensec =	specnode->st_mtimespec.tv_nsec;
		dirnode->inode->st.st_ctimensec =	start_time.tv_nsec;
#endif
	}
	if (specnode->flags & (F_UID | F_UNAME)) {
		ASEPRINT("uid", "%d",
		    dirnode->inode->st.st_uid, specnode->st_uid);
		dirnode->inode->st.st_uid = specnode->st_uid;
	}
#if HAVE_STRUCT_STAT_ST_FLAGS
	if (specnode->flags & F_FLAGS) {
		ASEPRINT("flags", "%#lX",
		    (unsigned long)dirnode->inode->st.st_flags,
		    (unsigned long)specnode->st_flags);
		dirnode->inode->st.st_flags = specnode->st_flags;
	}
#endif
	if (specnode->flags & F_DEV) {
		ASEPRINT("rdev", "%#llx",
		    (unsigned long long)dirnode->inode->st.st_rdev,
		    (unsigned long long)specnode->st_rdev);
		dirnode->inode->st.st_rdev = specnode->st_rdev;
	}
#undef ASEPRINT

	dirnode->flags |= FSNODE_F_HASSPEC;
}


/*
 * dump_fsnodes --
 *	dump the fsnodes from `cur', based in the directory `dir'
 */
void
dump_fsnodes(const char *dir, fsnode *root)
{
	fsnode	*cur;
	char	*path;

	assert (dir != NULL);
	if ((path = malloc(maxpathlen + 1)) == NULL)
		err(1, "malloc");
	printf("dump_fsnodes: %s(%d) %p\n", dir, root->inode->serno, root);
	for (cur = root; cur != NULL; cur = cur->next) {
		if ((size_t)snprintf(path, maxpathlen, "%s/%s", dir, cur->name)
		    >= maxpathlen)
			errx(1, "Pathname too long.");

		if (debug & DEBUG_DUMP_FSNODES_VERBOSE)
			printf("cur=%8p parent=%8p first=%8p ",
			    cur, cur->parent, cur->first);
		printf("%7s %5d: %s", inode_type(cur->type),
		    cur->inode->serno, path);
		if (S_ISLNK(cur->type)) {
			assert(cur->symlink != NULL);
			printf(" -> %s", cur->symlink);
		} else {
			assert (cur->symlink == NULL);
		}
		if (cur->inode->nlink > 1)
			printf(", nlinks=%d", cur->inode->nlink);
		putchar('\n');

		if (cur->child) {
			assert (cur->type == S_IFDIR);
			dump_fsnodes(path, cur->child);
		}
	}
	printf("dump_fsnodes: finished %s\n", dir);
	free(path);
}


/*
 * inode_type --
 *	for a given inode type `mode', return a descriptive string.
 *	for most cases, uses inotype() from mtree/misc.c
 */
const char *
inode_type(mode_t mode)
{

	if (S_ISLNK(mode))
		return ("symlink");	/* inotype() returns "link"...  */
	return (inotype(mode));
}


/*
 * link_check --
 *	return pointer to fsinode matching `entry's st_ino & st_dev if it exists,
 *	otherwise add `entry' to table and return NULL
 */
/* This was borrowed from du.c and tweaked to keep an fsnode
 * pointer instead. -- dbj@@netbsd.org
 */
static fsinode *
link_check(fsinode *entry)
{
	static struct entry {
		fsinode *data;
	} *htable;
	static int htshift;  /* log(allocated size) */
	static int htmask;   /* allocated size - 1 */
	static int htused;   /* 2*number of insertions */
	int h, h2;
	uint64_t tmp;
	/* this constant is (1<<64)/((1+sqrt(5))/2)
	 * aka (word size)/(golden ratio)
	 */
	const uint64_t HTCONST = 11400714819323198485ULL;
	const int HTBITS = 64;

	/* Never store zero in hashtable */
	assert(entry);

	/* Extend hash table if necessary, keep load under 0.5 */
	if (htused<<1 >= htmask) {
		struct entry *ohtable;

		if (!htable)
			htshift = 10;   /* starting hashtable size */
		else
			htshift++;   /* exponential hashtable growth */

		htmask  = (1 << htshift) - 1;
		htused = 0;

		ohtable = htable;
		htable = calloc(htmask+1, sizeof(*htable));
		if (!htable)
			err(1, "Memory allocation error");

		/* populate newly allocated hashtable */
		if (ohtable) {
			int i;
			for (i = 0; i <= htmask>>1; i++)
				if (ohtable[i].data)
					link_check(ohtable[i].data);
			free(ohtable);
		}
	}

	/* multiplicative hashing */
	tmp = entry->st.st_dev;
	tmp <<= HTBITS>>1;
	tmp |=  entry->st.st_ino;
	tmp *= HTCONST;
	h  = tmp >> (HTBITS - htshift);
	h2 = 1 | ( tmp >> (HTBITS - (htshift<<1) - 1)); /* must be odd */

	/* open address hashtable search with double hash probing */
	while (htable[h].data) {
		if ((htable[h].data->st.st_ino == entry->st.st_ino) &&
		    (htable[h].data->st.st_dev == entry->st.st_dev)) {
			return htable[h].data;
		}
		h = (h + h2) & htmask;
	}

	/* Insert the current entry into hashtable */
	htable[h].data = entry;
	htused++;
	return NULL;
}
@


1.10
log
@sync Â© lines
@
text
@d4 1
a4 1
 * Copyright (c) 2009
d46 1
a46 1
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/walk.c,v 1.9 2010/03/06 21:29:05 tg Exp $");
d86 1
a86 1
	char		path[MAXPATHLEN + 1];
d90 2
d103 2
a104 2
		if ((size_t)snprintf(path, sizeof(path), "%s/%s", dir, dent->d_name)
		    >= sizeof(path))
d155 2
a156 2
			char	slink[PATH_MAX+1];
			int	llen;
d158 3
a160 1
			llen = readlink(path, slink, sizeof(slink) - 1);
d164 1
a164 2
			if ((cur->symlink = strdup(slink)) == NULL)
				err(1, "Memory allocation error");
d171 1
d281 1
a281 1
	char	 path[MAXPATHLEN + 1];
d287 2
d342 2
a343 2
		if ((size_t)snprintf(path, sizeof(path), "%s/%s",
		    dir, curnode->name) >= sizeof(path))
d412 1
d507 1
a507 1
	char	path[MAXPATHLEN + 1];
d510 2
d514 2
a515 2
		if ((size_t)snprintf(path, sizeof(path), "%s/%s", dir, cur->name)
		    >= sizeof(path))
d539 1
@


1.9
log
@merge and attempt to fix
â€¢ cd9660/iso9660_rrip.c:cd9660_susp_handle_continuation_common() has
  some different code for keeping track of working and placement of
  the CE on the disc now but it looks as if itâ€™s correct
â€¢ I am fairly positive this doesnâ€™t regressâ€¦ but, alas, no guarantee
@
text
@d4 2
a5 1
 * Copyright (c) 2009 Thorsten Glaser
d46 1
a46 1
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/walk.c,v 1.8 2009/07/23 19:32:24 tg Exp $");
@


1.8
log
@apply fixes, missing includes, and Debian compatibility glue to makefs(8);
create an initial, experimental Debian source package for it for Luca Fav.
@
text
@d1 1
a1 2
/**	$MirOS: src/usr.sbin/makefs/walk.c,v 1.7 2008/12/26 23:37:54 tg Exp $ */
/*	$NetBSD: walk.c,v 1.23 2006/10/10 01:55:45 dbj Exp $	*/
d45 2
a46 2
__RCSID("$NetBSD: walk.c,v 1.23 2006/10/10 01:55:45 dbj Exp $");
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/walk.c,v 1.7 2008/12/26 23:37:54 tg Exp $");
d144 2
a145 2
					printf("link_check: found [%u, %llu]\n",
					    (unsigned int)curino->st.st_dev,
d480 3
a482 3
		ASEPRINT("rdev", "%#x",
		    (unsigned int)dirnode->inode->st.st_rdev,
		    (unsigned int)specnode->st_rdev);
@


1.7
log
@now fix up serial numbers for good (a hexdump comparision between a
yesterday's edition of makefs and one after this patch yields no dif-
ferences, so the cd9660 code also DTRT regarding dirs and their dot
entries like the ffs code except not failing if the walk code links
them together alreadyâ€¦)
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/makefs/walk.c,v 1.6 2008/12/26 23:02:16 tg Exp $ */
d5 1
d47 1
a47 1
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/walk.c,v 1.6 2008/12/26 23:02:16 tg Exp $");
d51 2
a61 1
#include <sys/stat.h>
d146 1
a146 1
					    curino->st.st_dev,
d482 2
a483 1
		    dirnode->inode->st.st_rdev, specnode->st_rdev);
d553 1
a553 1
/* This was borrowed from du.c and tweaked to keep an fsnode 
d572 1
a572 1
	
d610 1
a610 1
	
@


1.6
log
@unbreak ffs support from 100491333D962AA8CD8
XXX need to figure out what to do with cd9660 now
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/makefs/walk.c,v 1.5 2008/11/06 18:13:22 tg Exp $ */
d46 1
a46 1
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/walk.c,v 1.5 2008/11/06 18:13:22 tg Exp $");
d116 2
d129 1
@


1.5
log
@assign virtual inode numbers just like the hard link count stuff in pax(1),
make sure that directories are hardlinked to their dot entries as well,
and use the serial numbers for the PX records
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/makefs/walk.c,v 1.4 2008/10/31 21:24:24 tg Exp $ */
d46 1
a46 1
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/walk.c,v 1.4 2008/10/31 21:24:24 tg Exp $");
d126 4
a146 4
		if (S_ISDIR(cur->type) && strcmp(dent->d_name, ".") != 0) {
			cur->child = walk_dir(path, cur);
			continue;
		}
@


1.4
log
@build with __CRAZY=Yes
@
text
@d1 1
a1 1
/**	$MirOS$ */
d46 1
a46 1
__IDSTRING(mbsdid, "$MirOS$");
d69 1
a125 4
			if (S_ISDIR(cur->type)) {
				cur->child = walk_dir(path, cur);
				continue;
			}
d141 6
d497 1
a497 1
	printf("dump_fsnodes: %s %p\n", dir, root);
d506 2
a507 1
		printf("%7s: %s", inode_type(cur->type), path);
@


1.3
log
@bring MAIN branch into the pristine TNF state for reverse-merging
@
text
@d1 1
d46 1
d98 1
a98 1
		if (snprintf(path, sizeof(path), "%s/%s", dir, dent->d_name)
d328 1
a328 1
		if (snprintf(path, sizeof(path), "%s/%s",
d496 1
a496 1
		if (snprintf(path, sizeof(path), "%s/%s", dir, cur->name)
@


1.2
log
@__CRAZY=Yes cleanupâ€¦ can't they even use compiler warningsâ€¦
cruel netbsd code *sigh*
@
text
@d1 1
a1 1
/*	$NetBSD: walk.c,v 1.19 2006/02/01 22:19:34 dyoung Exp $	*/
a37 36
/*
 * The function link_check() was inspired from NetBSD's usr.bin/du/du.c,
 * which has the following copyright notice:
 *
 *
 * Copyright (c) 1989, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Chris Newcomb.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

d44 1
a44 2
__RCSID("$MirOS$");
__RCSID("$NetBSD: walk.c,v 1.19 2006/02/01 22:19:34 dyoung Exp $");
d62 1
a62 1
static	void	 apply_specdir(const char *, NODE *, fsnode *);
d96 1
a96 1
		if ((size_t)snprintf(path, sizeof(path), "%s/%s", dir, dent->d_name)
d136 4
d177 47
d231 1
a231 1
apply_specfile(const char *specfile, const char *dir, fsnode *parent)
d259 3
a261 1
	apply_specdir(dir, root, parent);
d265 1
a265 1
apply_specdir(const char *dir, NODE *specnode, fsnode *dirnode)
d286 24
d326 1
a326 1
		if ((size_t)snprintf(path, sizeof(path), "%s/%s",
d393 1
a393 1
			apply_specdir(path, curnode, curfsnode->child);
d494 1
a494 1
		if ((size_t)snprintf(path, sizeof(path), "%s/%s", dir, cur->name)
d538 1
a538 1
 *	return pointer to fsnode matching `entry's st_ino & st_dev if it exists,
d541 3
d547 41
a587 20
	static	struct dupnode {
		uint32_t	dev;
		uint64_t	ino;
		fsinode		*dup;
	} *dups, *newdups;
	static	size_t	ndups, maxdups;

	size_t	i;

	assert (entry != NULL);

		/* XXX; maybe traverse in reverse for speed? */
	for (i = 0; i < ndups; i++) {
		if (dups[i].dev == (uint32_t)entry->st.st_dev &&
		    dups[i].ino == (uint64_t)entry->st.st_ino) {
			if (debug & DEBUG_WALK_DIR_LINKCHECK)
				printf("link_check: found [%u, %llu]\n",
				    entry->st.st_dev,
				    (unsigned long long)entry->st.st_ino);
			return (dups[i].dup);
d591 15
a605 9
	if (debug & DEBUG_WALK_DIR_LINKCHECK)
		printf("link_check: no match for [%u, %llu]\n",
		    entry->st.st_dev, (unsigned long long)entry->st.st_ino);
	if (ndups == maxdups) {
		if ((newdups = realloc(dups, sizeof(struct dupnode) * (maxdups + 128)))
		    == NULL)
			err(1, "Memory allocation error");
		dups = newdups;
		maxdups += 128;
a606 4
	dups[ndups].dev = entry->st.st_dev;
	dups[ndups].ino = entry->st.st_ino;
	dups[ndups].dup = entry;
	ndups++;
d608 4
a611 1
	return (NULL);
@


1.1
log
@Initial revision
@
text
@d80 1
d133 1
a133 1
		if (snprintf(path, sizeof(path), "%s/%s", dir, dent->d_name)
d286 1
a286 1
		if (snprintf(path, sizeof(path), "%s/%s",
d454 1
a454 1
		if (snprintf(path, sizeof(path), "%s/%s", dir, cur->name)
d509 1
a509 1
	static	int	ndups, maxdups;
d511 1
a511 1
	int	i;
d517 2
a518 2
		if (dups[i].dev == entry->st.st_dev &&
		    dups[i].ino == entry->st.st_ino) {
@


1.1.3.1
log
@Time to hack on makefs, from TNF
@
text
@@


1.1.3.2
log
@Import NetBSDÂ®-current (just after or at the 5.0 branch) makefs(8)
and subtree required to build it in MirBSD
@
text
@d1 1
a1 1
/*	$NetBSD: walk.c,v 1.23 2006/10/10 01:55:45 dbj Exp $	*/
d38 36
d80 1
a80 1
__RCSID("$NetBSD: walk.c,v 1.23 2006/10/10 01:55:45 dbj Exp $");
d98 1
a98 1
static	void	 apply_specdir(const char *, NODE *, fsnode *, int);
a171 4
				if (debug & DEBUG_WALK_DIR_LINKCHECK)
					printf("link_check: found [%u, %llu]\n",
					    curino->st.st_dev,
					    (unsigned long long)curino->st.st_ino);
a208 47
 * free_fsnodes --
 *	Removes node from tree and frees it and all of
 *   its decendents.
 */
void
free_fsnodes(fsnode *node)
{
	fsnode	*cur, *next;

	assert(node != NULL);

	/* for ".", start with actual parent node */
	if (node->first == node) {
		assert(node->name[0] == '.' && node->name[1] == '\0');
		if (node->parent) {
			assert(node->parent->child == node);
			node = node->parent;
		}
	}

	/* Find ourselves in our sibling list and unlink */
	if (node->first != node) {
		for (cur = node->first; cur->next; cur = cur->next) {
			if (cur->next == node) {
				cur->next = node->next;
				node->next = NULL;
				break;
			}
		}
	}

	for (cur = node; cur != NULL; cur = next) {
		next = cur->next;
		if (cur->child) {
			cur->child->parent = NULL;
			free_fsnodes(cur->child);
		}
		if (cur->inode->nlink-- == 1)
			free(cur->inode);
		if (cur->symlink)
			free(cur->symlink);
		free(cur->name);
		free(cur);
	}
}

/*
d216 1
a216 1
apply_specfile(const char *specfile, const char *dir, fsnode *parent, int speconly)
d244 1
a244 3
	apply_specdir(dir, root, parent, speconly);

	free_nodes(root);
d248 1
a248 1
apply_specdir(const char *dir, NODE *specnode, fsnode *dirnode, int speconly)
a268 24
	/* Remove any filesystem nodes not found in specfile */
	/* XXX inefficient.  This is O^2 in each dir and it would
	 * have been better never to have walked this part of the tree
	 * to begin with
	 */
	if (speconly) {
		fsnode *next;
		assert(dirnode->name[0] == '.' && dirnode->name[1] == '\0');
		for (curfsnode = dirnode->next; curfsnode != NULL; curfsnode = next) {
			next = curfsnode->next;
			for (curnode = specnode->child; curnode != NULL;
			     curnode = curnode->next) {
				if (strcmp(curnode->name, curfsnode->name) == 0)
					break;
			}
			if (curnode == NULL) {
				if (debug & DEBUG_APPLY_SPECONLY) {
					printf("apply_specdir: trimming %s/%s %p\n", dir, curfsnode->name, curfsnode);
				}
				free_fsnodes(curfsnode);
			}
		}
	}

d352 1
a352 1
			apply_specdir(path, curnode, curfsnode->child, speconly);
d497 1
a497 1
 *	return pointer to fsinode matching `entry's st_ino & st_dev if it exists,
a499 3
/* This was borrowed from du.c and tweaked to keep an fsnode 
 * pointer instead. -- dbj@@netbsd.org
 */
d503 20
a522 41
	static struct entry {
		fsinode *data;
	} *htable;
	static int htshift;  /* log(allocated size) */
	static int htmask;   /* allocated size - 1 */
	static int htused;   /* 2*number of insertions */
	int h, h2;
	uint64_t tmp;
	/* this constant is (1<<64)/((1+sqrt(5))/2)
	 * aka (word size)/(golden ratio)
	 */
	const uint64_t HTCONST = 11400714819323198485ULL;
	const int HTBITS = 64;
	
	/* Never store zero in hashtable */
	assert(entry);

	/* Extend hash table if necessary, keep load under 0.5 */
	if (htused<<1 >= htmask) {
		struct entry *ohtable;

		if (!htable)
			htshift = 10;   /* starting hashtable size */
		else
			htshift++;   /* exponential hashtable growth */

		htmask  = (1 << htshift) - 1;
		htused = 0;

		ohtable = htable;
		htable = calloc(htmask+1, sizeof(*htable));
		if (!htable)
			err(1, "Memory allocation error");

		/* populate newly allocated hashtable */
		if (ohtable) {
			int i;
			for (i = 0; i <= htmask>>1; i++)
				if (ohtable[i].data)
					link_check(ohtable[i].data);
			free(ohtable);
d526 9
a534 15
	/* multiplicative hashing */
	tmp = entry->st.st_dev;
	tmp <<= HTBITS>>1;
	tmp |=  entry->st.st_ino;
	tmp *= HTCONST;
	h  = tmp >> (HTBITS - htshift);
	h2 = 1 | ( tmp >> (HTBITS - (htshift<<1) - 1)); /* must be odd */
	
	/* open address hashtable search with double hash probing */
	while (htable[h].data) {
		if ((htable[h].data->st.st_ino == entry->st.st_ino) &&
		    (htable[h].data->st.st_dev == entry->st.st_dev)) {
			return htable[h].data;
		}
		h = (h + h2) & htmask;
d536 4
d541 1
a541 4
	/* Insert the current entry into hashtable */
	htable[h].data = entry;
	htused++;
	return NULL;
@


1.1.3.3
log
@import newer makefs from TNF (with Acorn Archimedes support)
@
text
@d1 1
a1 1
/*	$NetBSD: walk.c,v 1.24 2008/12/28 21:51:46 christos Exp $	*/
d44 1
a44 1
__RCSID("$NetBSD: walk.c,v 1.24 2008/12/28 21:51:46 christos Exp $");
d137 2
a138 2
					printf("link_check: found [%llu, %llu]\n",
					    (unsigned long long)curino->st.st_dev,
d471 2
a472 3
		ASEPRINT("rdev", "%#llx",
		    (unsigned long long)dirnode->inode->st.st_rdev,
		    (unsigned long long)specnode->st_rdev);
@


