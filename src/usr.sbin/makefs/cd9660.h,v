head	1.18;
access;
symbols
	cvs-201003062040:1.1.3.3
	cvs-200810311900:1.1.3.2
	MIRBSD_10:1.2.0.2
	MIRBSD_10_BASE:1.2
	cvs-200607051500:1.1.3.1
	netbsd:1.1.3;
locks; strict;
comment	@ * @;


1.18
date	2013.10.31.20.07.26;	author tg;	state Exp;
branches;
next	1.17;
commitid	1005272B7081B0E5655;

1.17
date	2010.03.06.23.24.14;	author tg;	state Exp;
branches;
next	1.16;
commitid	1004B92E431600E22B7;

1.16
date	2010.03.06.22.38.47;	author tg;	state Exp;
branches;
next	1.15;
commitid	1004B92D96675BE887A;

1.15
date	2010.03.06.21.29.03;	author tg;	state Exp;
branches;
next	1.14;
commitid	1004B92C8D37339B566;

1.14
date	2009.07.23.19.32.23;	author tg;	state Exp;
branches;
next	1.13;
commitid	1004A68BAC01D44054A;

1.13
date	2008.11.06.23.45.17;	author tg;	state Exp;
branches;
next	1.12;
commitid	100491381717E19935E;

1.12
date	2008.11.04.00.19.00;	author tg;	state Exp;
branches;
next	1.11;
commitid	100490F9505561D3157;

1.11
date	2008.10.31.21.39.52;	author tg;	state Exp;
branches;
next	1.10;
commitid	100490B7B3B7628CEC8;

1.10
date	2008.10.31.21.31.36;	author tg;	state Exp;
branches;
next	1.9;
commitid	100490B794B4F8B9E68;

1.9
date	2008.10.31.21.24.23;	author tg;	state Exp;
branches;
next	1.8;
commitid	100490B7799471618CD;

1.8
date	2008.10.31.20.42.29;	author tg;	state Exp;
branches;
next	1.7;
commitid	100490B6DAF31706723;

1.7
date	2008.10.31.20.33.47;	author tg;	state Exp;
branches;
next	1.6;
commitid	100490B6BBD48A7C3A2;

1.6
date	2008.10.31.20.13.19;	author tg;	state Exp;
branches;
next	1.5;
commitid	100490B66EF5E94D325;

1.5
date	2008.10.31.20.12.10;	author tg;	state Exp;
branches;
next	1.4;
commitid	100490B6697585594BF;

1.4
date	2008.10.31.19.51.52;	author tg;	state Exp;
branches;
next	1.3;
commitid	100490B61E76BF2136A;

1.3
date	2008.10.31.19.11.32;	author tg;	state Exp;
branches;
next	1.2;
commitid	100490B58676FCB2D2F;

1.2
date	2006.09.21.20.16.22;	author tg;	state Exp;
branches;
next	1.1;
commitid	1004512F320386F848A;

1.1
date	2006.07.05.15.08.37;	author tg;	state Exp;
branches
	1.1.3.1;
next	;
commitid	10044ABD6033365D559;

1.1.3.1
date	2006.07.05.15.08.37;	author tg;	state Exp;
branches;
next	1.1.3.2;
commitid	10044ABD6033365D559;

1.1.3.2
date	2008.10.31.19.06.04;	author tg;	state Exp;
branches;
next	1.1.3.3;
commitid	100490B57202F143953;

1.1.3.3
date	2010.03.06.20.44.40;	author tg;	state Exp;
branches;
next	;
commitid	1004B92BEC54F4CD073;


desc
@@


1.18
log
@adapt most __attribute__((…)) occurrences to new KNF style(9)
@
text
@/**	$MirOS: src/usr.sbin/makefs/cd9660.h,v 1.17 2010/03/06 23:24:14 tg Exp $ */
/*	$NetBSD: cd9660.h,v 1.13 2009/01/10 22:06:29 bjh21 Exp $	*/

/*
 * Copyright (c) 2009, 2010, 2013
 *	Thorsten Glaser <tg@@mirbsd.org>
 * Copyright (c) 2005 Daniel Watt, Walter Deignan, Ryan Gabrys, Alan
 * Perez-Rathke and Ram Vedam.  All rights reserved.
 *
 * This code was written by Daniel Watt, Walter Deignan, Ryan Gabrys,
 * Alan Perez-Rathke and Ram Vedam.
 *
 * Redistribution and use in source and binary forms, with or
 * without modification, are permitted provided that the following
 * conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY DANIEL WATT, WALTER DEIGNAN, RYAN
 * GABRYS, ALAN PEREZ-RATHKE AND RAM VEDAM ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL DANIEL WATT, WALTER DEIGNAN, RYAN
 * GABRYS, ALAN PEREZ-RATHKE AND RAM VEDAM BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE,DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 */

#ifndef _MAKEFS_CD9660_H
#define _MAKEFS_CD9660_H

#if HAVE_NBTOOL_CONFIG_H
#include "nbtool_config.h"
#endif

#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include <limits.h>
#include <sys/queue.h>
#include <sys/param.h>

#include "makefs.h"
#include "iso.h"
#include "iso_rrip.h"
#include "cd9660/cd9660_eltorito.h"

#ifdef DEBUG
#define	INODE_WARNX(__x)	warnx __x
#else /* DEBUG */
#define	INODE_WARNX(__x)
#endif /* DEBUG */

#undef __bounded
#if defined(__GNUC__) && (defined(__OpenBSD__) || defined(__MirBSD__))
#define __bounded(...)	__attribute__((__bounded__(__VA_ARGS__)))
#else
#define __bounded(...)	/* nothing */
#endif

/* prototype with bounds checking */
#if 0 /* defined(__GNUC__) && (defined(__OpenBSD__) || defined(__MirBSD__)) */
/* Anil Madhavapeddy's gcc bounds checker, doesn't trigger */
#define cd9660_DATATYPE_PROTO(name, bytes, type) \
	void __CONCAT(cd9660_real_, name)(type, unsigned char *)
	    __attribute__((__bounded__(__minbytes__, 2, bytes)))
#define cd9660_DATATYPE_INVOCATION(name, bytes, val, buf) \
	__CONCAT(cd9660_real_, name)(val, (unsigned char *)(buf))
#elif defined(DEBUG)
/* compile-time assertion */
#define cd9660_DATATYPE_PROTO(name, bytes, type) \
	void __CONCAT(cd9660_real_, name)(type, unsigned char *)
#define cd9660_DATATYPE_INVOCATION(name, bytes, val, buf) do {		\
	int cd9660_CHECK[sizeof (buf) >= bytes ? 1 : -1] __unused;	\
	__CONCAT(cd9660_real_, name)(val, (unsigned char *)(buf));	\
} while (/* CONSTCOND */ 0)
#else
/* run-time assertion */
#define cd9660_DATATYPE_PROTO(name, bytes, type) \
	void __CONCAT(cd9660_real_, name)(type, unsigned char *)
#define cd9660_DATATYPE_INVOCATION(name, bytes, val, buf) do {		\
	assert(sizeof (buf) >= bytes);					\
	__CONCAT(cd9660_real_, name)(val, (unsigned char *)(buf));	\
} while (/* CONSTCOND */ 0)
#endif

#ifdef CD9660_CONVERSION_IMPL
#undef cd9660_DATATYPE_INVOCATION
#define cd9660_DATATYPE_INVOCATION(name, bytes, val, buf) \
	__CONCAT(cd9660_real_, name)(val, buf)
#endif

#define CD9660MAXPATH 4096

#define ISO_STRING_FILTER_NONE = 0x00
#define ISO_STRING_FILTER_DCHARS = 0x01
#define ISO_STRING_FILTER_ACHARS = 0x02

/*
Extended preferences type, in the spirit of what makefs gives us (only ints)
*/
typedef struct {
	const char  *shortName;		/* Short option */
	const char	*name;		/* option name */
	char		*value;		/* where to stuff the value */
	int		minLength;	/* minimum for value */
	int		maxLength;	/* maximum for value */
	const char	*desc;		/* option description */
	int		filterFlags;
} string_option_t;

/******** STRUCTURES **********/

/*Defaults*/
#define ISO_DEFAULT_VOLUMEID "MAKEFS_CD9660_IMAGE"
#define ISO_DEFAULT_APPID "MAKEFS"
#define ISO_DEFAULT_PUBLISHER "MAKEFS"
#define ISO_DEFAULT_PREPARER "MAKEFS"

#ifdef __MirBSD__
#define ISO_DEFAULT_SYSID "MirBSD"
#else
#define ISO_DEFAULT_SYSID "NetBSD"
#endif

#define ISO_VOLUME_DESCRIPTOR_STANDARD_ID "CD001"
#define ISO_VOLUME_DESCRIPTOR_BOOT 0
#define ISO_VOLUME_DESCRIPTOR_PVD 1
#define ISO_VOLUME_DESCRIPTOR_TERMINATOR 255

/*30 for name and extension, as well as version number and padding bit*/
#define ISO_FILENAME_MAXLENGTH_BEFORE_VERSION 30
#define ISO_FILENAME_MAXLENGTH	36
#define ISO_FILENAME_MAXLENGTH_WITH_PADDING 37

#define ISO_FLAG_CLEAR 0x00
#define ISO_FLAG_HIDDEN 0x01
#define ISO_FLAG_DIRECTORY 0x02
#define ISO_FLAG_ASSOCIATED 0x04
#define ISO_FLAG_PERMISSIONS 0x08
#define ISO_FLAG_RESERVED5 0x10
#define ISO_FLAG_RESERVED6 0x20
#define ISO_FLAG_FINAL_RECORD 0x40

#define ISO_PATHTABLE_ENTRY_BASESIZE 8

#define ISO_RRIP_DEFAULT_MOVE_DIR_NAME "RR_MOVED"
#define RRIP_DEFAULT_MOVE_DIR_NAME \
	(diskStructure.hide_rr_moved ? "" : ".rr_moved")

#define	CD9660_BLOCKS(__sector_size, __bytes)	\
	howmany((__bytes), (__sector_size))

#define CD9660_MEM_ALLOC_ERROR(_F)	\
    err(EXIT_FAILURE, "%s, %s l. %d", _F, __FILE__, __LINE__)

#define CD9660_IS_COMMAND_ARG_DUAL(var,short,long)\
		(strcmp((var),(short)) == 0) || (strcmp((var),(long))==0)

#define CD9660_IS_COMMAND_ARG(var,arg)\
		(strcmp((var),(arg)) == 0)

#define CD9660_TYPE_FILE	0x01
#define CD9660_TYPE_DIR		0x02
#define CD9660_TYPE_DOT		0x04
#define CD9660_TYPE_DOTDOT	0x08
#define CD9660_TYPE_VIRTUAL 0x80

#define CD9660_INODE_HASH_SIZE 1024

#define CD9660_END_PADDING 150

/* Slight modification of the ISO structure in iso.h */
typedef struct _iso_directory_record_cd9660 {
	u_char length			[ISODCL (1, 1)];	/* 711 */
	u_char ext_attr_length		[ISODCL (2, 2)];	/* 711 */
	u_char extent			[ISODCL (3, 10)];	/* 733 */
	u_char size			[ISODCL (11, 18)];	/* 733 */
	u_char date			[ISODCL (19, 25)];	/* 7 by 711 */
	u_char flags			[ISODCL (26, 26)];
	u_char file_unit_size		[ISODCL (27, 27)];	/* 711 */
	u_char interleave		[ISODCL (28, 28)];	/* 711 */
	u_char volume_sequence_number	[ISODCL (29, 32)];	/* 723 */
	u_char name_len			[ISODCL (33, 33)];	/* 711 */
	char name			[ISO_FILENAME_MAXLENGTH_WITH_PADDING];
} iso_directory_record_cd9660;

/* TODO: Lots of optimization of this structure */
typedef struct _cd9660node {
	u_char	type;/* Used internally */
	/* Tree structure */
	struct _cd9660node	*parent;	/* parent (NULL if root) */
	TAILQ_HEAD(cd9660_children_head, _cd9660node)	cn_children;
	TAILQ_ENTRY(_cd9660node)		cn_next_child;

	struct _cd9660node *dot_record; /* For directories, used mainly in RRIP */
	struct _cd9660node *dot_dot_record;

	fsnode		*node;		/* pointer to fsnode */
	struct _iso_directory_record_cd9660	*isoDirRecord;
	struct iso_extended_attributes	*isoExtAttributes;

	/***** SIZE CALCULATION *****/
	/*already stored in isoDirRecord, but this is an int version, and will be
		copied to isoDirRecord on writing*/
	uint32_t fileDataSector;

	/*
	 * same thing, though some notes:
	 * If a file, this is the file size
	 * If a directory, this is the size of all its children's
	 *	directory records
	 * plus necessary padding
	 */
	int64_t fileDataLength;

	/*
	 * XXXfvdl sectors are int
	 */
	int fileSectorsUsed;
	int fileRecordSize;/*copy of a variable, int for quicker calculations*/

	/* Old name, used for renaming - needs to be optimized but low priority */
	char o_name [ISO_FILENAME_MAXLENGTH_WITH_PADDING];

	/***** SPACE RESERVED FOR EXTENSIONS *****/
	/* For memory efficiency's sake - we should move this to a separate struct
		and point to null if not needed */
	/* For Rock Ridge */
	struct _cd9660node *rr_real_parent, *rr_relocated;

	int susp_entry_size;
	int susp_dot_entry_size;
	int susp_dot_dot_entry_size;

	/* Continuation area stuff */
	int susp_entry_ce_start;
	int susp_dot_ce_start;
	int susp_dot_dot_ce_start;

	int susp_entry_ce_length;
	int susp_dot_ce_length;
	int susp_dot_dot_ce_length;

	/* Data to put at the end of the System Use field */
	int su_tail_size;
	char *su_tail_data;

	/*** PATH TABLE STUFF ***/
	int level;			/*depth*/
	int ptnumber;
	struct _cd9660node *ptnext, *ptprev, *ptlast;

	/* SUSP entries */
	TAILQ_HEAD(susp_linked_list, ISO_SUSP_ATTRIBUTES) head;
} cd9660node;

typedef struct _path_table_entry
{
	u_char length[ISODCL (1, 1)];
	u_char extended_attribute_length[ISODCL (2, 2)];
	u_char first_sector[ISODCL (3, 6)];
	u_char parent_number[ISODCL (7, 8)];
	u_char name[ISO_FILENAME_MAXLENGTH_WITH_PADDING];
} path_table_entry;

typedef struct _volume_descriptor
{
	u_char *volumeDescriptorData; /*ALWAYS 2048 bytes long*/
	int sector;
	struct _volume_descriptor *next;
} volume_descriptor;

typedef struct _iso9660_disk {
	int sectorSize;
	struct iso_primary_descriptor		primaryDescriptor;
	struct iso_supplementary_descriptor	supplementaryDescriptor;

	volume_descriptor *firstVolumeDescriptor;

	cd9660node *rootNode;

	const char *rootFilesystemPath;

	/* Important sector numbers here */
	/* primaryDescriptor.type_l_path_table*/
	int primaryBigEndianTableSector;

	/* primaryDescriptor.type_m_path_table*/
	int primaryLittleEndianTableSector;

	/* primaryDescriptor.opt_type_l_path_table*/
	int secondaryBigEndianTableSector;

	/* primaryDescriptor.opt_type_m_path_table*/
	int secondaryLittleEndianTableSector;

	/* primaryDescriptor.path_table_size*/
	int pathTableLength;
	int dataFirstSector;

	int totalSectors;
	/* OPTIONS GO HERE */
	int	isoLevel;

	int include_padding_areas;

	int follow_sym_links;
	int verbose_level;
	int displayHelp;
	int keep_bad_images;
	int hide_rr_moved;	/*XXX why int and not bool? */

	/* SUSP options and variables */
	int susp_continuation_area_start_sector;
	int susp_continuation_area_size;
	int susp_continuation_area_current_free;

	int rock_ridge_enabled;
	/* Other Rock Ridge Variables */
	char *rock_ridge_renamed_dir_name;
	int rock_ridge_move_count;
	cd9660node *rr_moved_dir;

	int archimedes_enabled;

	/* Spec breaking options */
	u_char allow_deep_trees;
	u_char allow_start_dot;
	u_char allow_max_name; /* Allow 37 char filenames*/
	u_char allow_illegal_chars; /* ~, !, # */
	u_char allow_lowercase;
	u_char allow_multidot;
	u_char omit_trailing_period;

	/* BOOT INFORMATION HERE */
	int has_generic_bootimage; /* Default to 0 */
	char *generic_bootimage;

	int is_bootable;/* Default to 0 */
	int boot_catalog_sector;
	boot_volume_descriptor *boot_descriptor;
	char * boot_image_directory;

	TAILQ_HEAD(boot_image_list,cd9660_boot_image) boot_images;
	int image_serialno;
	LIST_HEAD(boot_catalog_entries,boot_catalog_entry) boot_entries;

	char *forced_creation_date;
	char *forced_modification_date;
	char *forced_expiration_date;
	char *forced_effective_date;

} iso9660_disk;

/******** GLOBAL VARIABLES ***********/
extern iso9660_disk diskStructure;

/************ FUNCTIONS **************/
int			cd9660_valid_a_chars(const char *);
int			cd9660_valid_d_chars(const char *);
void			cd9660_uppercase_characters(char *, int);

/* ISO Data Types */
#define cd9660_721(val, buf) \
	cd9660_DATATYPE_INVOCATION(721, 2, val, buf)
cd9660_DATATYPE_PROTO(721, 2, uint16_t);
#define cd9660_731(val, buf) \
	cd9660_DATATYPE_INVOCATION(731, 4, val, buf)
cd9660_DATATYPE_PROTO(731, 4, uint32_t);
#define cd9660_722(val, buf) \
	cd9660_DATATYPE_INVOCATION(722, 2, val, buf)
cd9660_DATATYPE_PROTO(722, 2, uint16_t);
#define cd9660_732(val, buf) \
	cd9660_DATATYPE_INVOCATION(732, 4, val, buf)
cd9660_DATATYPE_PROTO(732, 4, uint32_t);
#define cd9660_bothendian_dword(val, buf) \
	cd9660_DATATYPE_INVOCATION(bothendian_dword, 8, val, buf)
cd9660_DATATYPE_PROTO(bothendian_dword, 8, uint32_t);
#define cd9660_bothendian_word(val, buf) \
	cd9660_DATATYPE_INVOCATION(bothendian_word, 4, val, buf)
cd9660_DATATYPE_PROTO(bothendian_word, 4, uint16_t);
#if 0
#define cd9660_set_date(val, buf) \
	cd9660_DATATYPE_INVOCATION(set_date, ?, val, buf)
cd9660_DATATYPE_PROTO(set_date, ?, time_t);
#endif
#define cd9660_time_8426(val, buf) \
	cd9660_DATATYPE_INVOCATION(time_8426, 17, val, buf)
cd9660_DATATYPE_PROTO(time_8426, 17, time_t);
#define cd9660_time_915(val, buf) \
	cd9660_DATATYPE_INVOCATION(time_915, 7, val, buf)
cd9660_DATATYPE_PROTO(time_915, 7, time_t);

int	cd9660_isthisa_time_8426_utc(const char *, const char *);

/*** Boot Functions ***/
int	cd9660_write_generic_bootimage(FILE *);
int	cd9660_add_generic_bootimage(const char *);
int	cd9660_write_boot(FILE *);
int	cd9660_add_boot_disk(const char *);
int	cd9660_eltorito_add_boot_option(const char *, const char *);
int	cd9660_setup_boot(int);
int	cd9660_setup_boot_volume_descriptor(volume_descriptor *);


/*** Write Functions ***/
int	cd9660_write_image(const char *image);
int	cd9660_copy_file(FILE *, int, const char *);

void	cd9660_compute_full_filename(cd9660node *, char *, size_t, int)
    __bounded(string, 2, 3);
int	cd9660_compute_record_size(cd9660node *);

/* Debugging functions */
void	debug_print_tree(cd9660node *,int);
void	debug_print_path_tree(cd9660node *);
void	debug_print_volume_descriptor_information(void);
void	debug_dump_to_xml_ptentry(path_table_entry *,int, int);
void	debug_dump_to_xml_path_table(FILE *, int, int, int);
void	debug_dump_to_xml(FILE *);
int	debug_get_encoded_number(unsigned char *, int);
void	debug_dump_integer(const char *, char *,int);
void	debug_dump_string(const char *,unsigned char *,int);
void	debug_dump_directory_record_9_1(unsigned char *);
void	debug_dump_to_xml_volume_descriptor(unsigned char *,int);

#define cd9660_pad_string_spaces(x) \
	cd9660_pad_string_spaces_((x), sizeof (x))
void	cd9660_pad_string_spaces_(char *, size_t);

#endif
@


1.17
log
@sync © lines
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/makefs/cd9660.h,v 1.16 2010/03/06 22:38:47 tg Exp $ */
d5 1
a5 1
 * Copyright (c) 2009, 2010
d71 1
a71 1
#define __bounded(...)	__attribute__((__bounded__ (__VA_ARGS__)))
d81 1
a81 1
	    __attribute__((__bounded__ (__minbytes__, 2, bytes)))
@


1.16
log
@The ability to set the {creation,modification,effective,expiry} date of
the created ECMA 119 image to any valid UTC value manually.

This is used by GNU GRUB 2 which takes the mtime as “UUID” of sorts.
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/makefs/cd9660.h,v 1.15 2010/03/06 21:29:03 tg Exp $ */
d5 2
a6 1
 * Copyright (c) 2009, 2010 Thorsten Glaser
@


1.15
log
@merge and attempt to fix
• cd9660/iso9660_rrip.c:cd9660_susp_handle_continuation_common() has
  some different code for keeping track of working and placement of
  the CE on the disc now but it looks as if it’s correct
• I am fairly positive this doesn’t regress… but, alas, no guarantee
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/makefs/cd9660.h,v 1.14 2009/07/23 19:32:23 tg Exp $ */
d5 1
a5 1
 * Copyright (c) 2009 Thorsten Glaser
d363 5
d409 2
@


1.14
log
@apply fixes, missing includes, and Debian compatibility glue to makefs(8);
create an initial, experimental Debian source package for it for Luca Fav.
@
text
@d1 2
a2 2
/**	$MirOS: src/usr.sbin/makefs/cd9660.h,v 1.13 2008/11/06 23:45:17 tg Exp $ */
/*	$NetBSD: cd9660.h,v 1.12 2008/07/27 10:29:32 reinoud Exp $	*/
d259 4
d339 1
@


1.13
log
@Honour Ecma-119 (ISO 9660) standard: fix out-of-bounds write/padding
access for the primary volume descriptor (and probably others) – the
padding overwrite some must-be-zero parts of this crucial structure!
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/makefs/cd9660.h,v 1.12 2008/11/04 00:19:00 tg Exp $ */
d5 1
d68 1
@


1.12
log
@code to hide RR_MOVED
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/makefs/cd9660.h,v 1.11 2008/10/31 21:39:52 tg Exp $ */
d428 3
a430 1
void	cd9660_pad_string_spaces(char *, int);
@


1.11
log
@kill strcat(3)
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/makefs/cd9660.h,v 1.10 2008/10/31 21:31:36 tg Exp $ */
d160 2
a161 1
#define RRIP_DEFAULT_MOVE_DIR_NAME ".rr_moved"
d320 1
@


1.10
log
@kill sprintf(3)
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/makefs/cd9660.h,v 1.9 2008/10/31 21:24:23 tg Exp $ */
d409 2
a410 1
void	cd9660_compute_full_filename(cd9660node *, char *, int);
@


1.9
log
@build with __CRAZY=Yes
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/makefs/cd9660.h,v 1.8 2008/10/31 20:42:29 tg Exp $ */
d67 6
@


1.8
log
@remove explicit casts to (unsigned char *) so that the sizeof stuff works
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/makefs/cd9660.h,v 1.7 2008/10/31 20:33:47 tg Exp $ */
d80 1
a80 1
	int cd9660_DATATYPE_CHECK[sizeof (buf) >= bytes ? 1 : -1];	\
@


1.7
log
@implement some bounds checking
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/makefs/cd9660.h,v 1.6 2008/10/31 20:13:19 tg Exp $ */
d74 1
a74 1
	__CONCAT(cd9660_real_, name)(val, buf)
d81 1
a81 1
	__CONCAT(cd9660_real_, name)(val, buf);				\
d89 1
a89 1
	__CONCAT(cd9660_real_, name)(val, buf);				\
@


1.6
log
@one more: cd9660_set_date (if 0’d)
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/makefs/cd9660.h,v 1.5 2008/10/31 20:12:10 tg Exp $ */
d67 32
d359 18
a376 6
void			cd9660_721(uint16_t, unsigned char *);
void			cd9660_731(uint32_t, unsigned char *);
void			cd9660_722(uint16_t, unsigned char *);
void			cd9660_732(uint32_t, unsigned char *);
void 			cd9660_bothendian_dword(uint32_t dw, unsigned char *);
void 			cd9660_bothendian_word(uint16_t dw, unsigned char *);
d378 3
a380 1
void			cd9660_set_date(time_t, char *);
d382 6
a387 2
void			cd9660_time_8426(time_t, unsigned char *);
void			cd9660_time_915(time_t, unsigned char *);
@


1.5
log
@switch argument order of cd9660_time_8426 and cd9660_time_915 to
match the prototype of the other ISO 9660 data type functions
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/makefs/cd9660.h,v 1.4 2008/10/31 19:51:52 tg Exp $ */
d333 3
a335 1
void			cd9660_set_date(char *, time_t);
@


1.4
log
@conditionalise the ISO 9660 default System Identifier
@
text
@d1 1
a1 1
/**	$MirOS$ */
d334 2
a335 2
void			cd9660_time_8426(unsigned char *, time_t);
void			cd9660_time_915(unsigned char *, time_t);
@


1.3
log
@bring MAIN branch into the pristine TNF state for reverse-merging
@
text
@d1 1
d94 6
@


1.2
log
@get rid of strcpy, strcat and sprintf
XXX should add bounded attributes

bad bad TNF
@
text
@d1 1
a1 1
/*	$NetBSD: cd9660.h,v 1.10 2006/02/01 22:19:34 dyoung Exp $	*/
d297 3
d331 2
d337 1
a337 1
int	cd9660_setup_boot_volume_descritpor(volume_descriptor *);
d344 1
a344 1
void	cd9660_compute_full_filename(cd9660node *, char *, int, size_t);
@


1.1
log
@Initial revision
@
text
@d339 1
a339 1
void	cd9660_compute_full_filename(cd9660node *, char *, int);
@


1.1.3.1
log
@Time to hack on makefs, from TNF
@
text
@@


1.1.3.2
log
@Import NetBSD®-current (just after or at the 5.0 branch) makefs(8)
and subtree required to build it in MirBSD
@
text
@d1 1
a1 1
/*	$NetBSD: cd9660.h,v 1.12 2008/07/27 10:29:32 reinoud Exp $	*/
a296 3
	int has_generic_bootimage; /* Default to 0 */
	char *generic_bootimage;

a327 2
int	cd9660_write_generic_bootimage(FILE *);
int	cd9660_add_generic_bootimage(const char *);
d332 1
a332 1
int	cd9660_setup_boot_volume_descriptor(volume_descriptor *);
@


1.1.3.3
log
@import newer makefs from TNF (with Acorn Archimedes support)
@
text
@d1 1
a1 1
/*	$NetBSD: cd9660.h,v 1.13 2009/01/10 22:06:29 bjh21 Exp $	*/
a210 4
	/* Data to put at the end of the System Use field */
	int su_tail_size;
	char *su_tail_data;

a285 1
	int archimedes_enabled;
@


