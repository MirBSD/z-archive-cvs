head	1.17;
access;
symbols
	cvs-201003062040:1.1.3.2
	cvs-200810311900:1.1.3.2
	MIRBSD_10:1.5.0.2
	MIRBSD_10_BASE:1.5
	cvs-200607051500:1.1.3.1
	netbsd:1.1.3;
locks; strict;
comment	@ * @;


1.17
date	2019.01.05.16.02.27;	author tg;	state Exp;
branches;
next	1.16;
commitid	1005C30D4FC04E81E4A;

1.16
date	2017.08.07.20.19.10;	author tg;	state Exp;
branches;
next	1.15;
commitid	1005988C69344442E37;

1.15
date	2016.06.11.14.55.39;	author tg;	state Exp;
branches;
next	1.14;
commitid	100575C2681764A56A0;

1.14
date	2016.06.11.14.52.48;	author tg;	state Exp;
branches;
next	1.13;
commitid	100575C25C924DD2901;

1.13
date	2010.03.16.22.05.55;	author tg;	state Exp;
branches;
next	1.12;
commitid	1004BA000DA53974893;

1.12
date	2010.03.07.00.02.17;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004B92ED1350BD9E9D;

1.11
date	2010.03.06.23.24.14;	author tg;	state Exp;
branches;
next	1.10;
commitid	1004B92E431600E22B7;

1.10
date	2010.03.06.21.29.04;	author tg;	state Exp;
branches;
next	1.9;
commitid	1004B92C8D37339B566;

1.9
date	2009.07.23.19.32.24;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004A68BAC01D44054A;

1.8
date	2008.10.31.21.24.24;	author tg;	state Exp;
branches;
next	1.7;
commitid	100490B7799471618CD;

1.7
date	2008.10.31.19.45.30;	author tg;	state Exp;
branches;
next	1.6;
commitid	100490B606B662DF594;

1.6
date	2008.10.31.19.11.32;	author tg;	state Exp;
branches;
next	1.5;
commitid	100490B58676FCB2D2F;

1.5
date	2007.05.19.23.17.48;	author tg;	state Exp;
branches;
next	1.4;
commitid	100464F859F79495987;

1.4
date	2006.07.05.20.27.24;	author tg;	state Exp;
branches;
next	1.3;
commitid	10044AC20BE2BD1E6FF;

1.3
date	2006.07.05.20.08.34;	author tg;	state Exp;
branches;
next	1.2;
commitid	10044AC1C596F24EF83;

1.2
date	2006.07.05.16.51.15;	author tg;	state Exp;
branches;
next	1.1;
commitid	10044ABEE19519D5566;

1.1
date	2006.07.05.15.08.37;	author tg;	state Exp;
branches
	1.1.3.1;
next	;
commitid	10044ABD6033365D559;

1.1.3.1
date	2006.07.05.15.08.37;	author tg;	state Exp;
branches;
next	1.1.3.2;
commitid	10044ABD6033365D559;

1.1.3.2
date	2008.10.31.19.06.04;	author tg;	state Exp;
branches;
next	;
commitid	100490B57202F143953;


desc
@@


1.17
log
@do not use libbsd, even on Debian (collapse FEDORA into GNUPORT):
it’ll RSN ship an incompatible strnvis() and strnunvis() from,
incidentally, NetBSD®… (and has fgetln/fparseln issues)
@
text
@/*	$NetBSD: makefs.c,v 1.26 2006/10/22 21:11:56 christos Exp $	*/

/*
 * Copyright (c) 2009, 2010
 *	Thorsten Glaser <tg@@mirbsd.org>
 * Copyright (c) 2001-2003 Wasabi Systems, Inc.
 * All rights reserved.
 *
 * Written by Luke Mewburn for Wasabi Systems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed for the NetBSD Project by
 *      Wasabi Systems, Inc.
 * 4. The name of Wasabi Systems, Inc. may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#if HAVE_NBTOOL_CONFIG_H
#include "nbtool_config.h"
#endif

#if defined(__MirBSD__) || defined(GNUPORT)
#include "mbsdtree.h"
#endif

#include <sys/cdefs.h>
#if defined(__RCSID) && !defined(__lint)
__RCSID("$NetBSD: makefs.c,v 1.26 2006/10/22 21:11:56 christos Exp $");
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/makefs.c,v 1.16 2017/08/07 20:19:10 tg Exp $");
#endif	/* !__lint */

#include <sys/param.h>
#include <sys/time.h>

#include <assert.h>
#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "makefs.h"
#include "mtree.h"
#include "cd9660.h"

/*
 * list of supported filesystems and dispatch functions
 */
typedef struct {
	const char	*type;
	void		(*prepare_options)(fsinfo_t *);
	int		(*parse_options)(const char *, fsinfo_t *);
	void		(*cleanup_options)(fsinfo_t *);
	void		(*make_fs)(const char *, const char *, fsnode *,
				fsinfo_t *);
} fstype_t;

static fstype_t fstypes[] = {
	{ "ffs", ffs_prep_opts,	ffs_parse_opts,	ffs_cleanup_opts, ffs_makefs },
	{ "cd9660", cd9660_prep_opts, cd9660_parse_opts, cd9660_cleanup_opts,
	  cd9660_makefs},
	{ .type = NULL	},
};

u_int		debug;
size_t		maxpathlen;
struct timespec	start_time;

static	fstype_t *get_fstype(const char *);
static	void	usage(void) __dead;
int		main(int, char *[]);

int
main(int argc, char *argv[])
{
	struct timeval	 start;
	fstype_t	*fstype;
	fsinfo_t	 fsoptions;
	fsnode		*root;
	int	 	 ch, len;
	char		*specfile;

#ifdef MAXPATHLEN
	maxpathlen = MAXPATHLEN;
#elif !defined(_PC_PATH_MAX)
	maxpathlen = 1024;
#else
	{
		long r;

		if ((r = sysconf(_PC_PATH_MAX)) == -1)
			err(1, "sysconf(_PC_PATH_MAX) == -1");
		maxpathlen = r;
	}
#endif

#ifdef __NetBSD__
	setprogname(argv[0]);
#endif

	debug = 0;
	if ((fstype = get_fstype(DEFAULT_FSTYPE)) == NULL)
		errx(1, "Unknown default fs type `%s'.", DEFAULT_FSTYPE);

		/* set default fsoptions */
	(void)memset(&fsoptions, 0, sizeof(fsoptions));
	fsoptions.fd = -1;
	fsoptions.sectorsize = -1;
	fsoptions.maxtime = -1;

	if (fstype->prepare_options)
		fstype->prepare_options(&fsoptions);

	specfile = NULL;
	if (gettimeofday(&start, NULL) == -1)
		err(1, "Unable to get system time");

	start_time.tv_sec = start.tv_sec;
	start_time.tv_nsec = start.tv_usec * 1000;

	while ((ch = getopt(argc, argv, "B:b:d:f:F:M:m:N:o:s:S:t:T:x")) != -1) {
		switch (ch) {

		case 'B':
			if (strcmp(optarg, "be") == 0 ||
			    strcmp(optarg, "4321") == 0 ||
			    strcmp(optarg, "big") == 0) {
#if BYTE_ORDER == LITTLE_ENDIAN
				fsoptions.needswap = 1;
#endif
			} else if (strcmp(optarg, "le") == 0 ||
			    strcmp(optarg, "1234") == 0 ||
			    strcmp(optarg, "little") == 0) {
#if BYTE_ORDER == BIG_ENDIAN
				fsoptions.needswap = 1;
#endif
			} else {
				warnx("Invalid endian `%s'.", optarg);
				usage();
			}
			break;

		case 'b':
			len = strlen(optarg) - 1;
			if (optarg[len] == '%') {
				optarg[len] = '\0';
				fsoptions.freeblockpc =
				    strsuftoll("free block percentage",
					optarg, 0, 99);
			} else {
				fsoptions.freeblocks =
				    strsuftoll("free blocks",
					optarg, 0, LLONG_MAX);
			}
			break;

		case 'd':
			debug = strtoll(optarg, NULL, 0);
			break;

		case 'f':
			len = strlen(optarg) - 1;
			if (optarg[len] == '%') {
				optarg[len] = '\0';
				fsoptions.freefilepc =
				    strsuftoll("free file percentage",
					optarg, 0, 99);
			} else {
				fsoptions.freefiles =
				    strsuftoll("free files",
					optarg, 0, LLONG_MAX);
			}
			break;

		case 'F':
			specfile = optarg;
			break;

		case 'M':
			fsoptions.minsize =
			    strsuftoll("minimum size", optarg, 1LL, LLONG_MAX);
			break;

		case 'N':
			if (! setup_getid(optarg))
				errx(1,
			    "Unable to use user and group databases in `%s'",
				    optarg);
			break;

		case 'm':
			fsoptions.maxsize =
			    strsuftoll("maximum size", optarg, 1LL, LLONG_MAX);
			break;

		case 'o':
		{
			char *p;

			while ((p = strsep(&optarg, ",")) != NULL) {
				if (*p == '\0')
					errx(1, "Empty option");
				if (! fstype->parse_options(p, &fsoptions))
					usage();
			}
			break;
		}

		case 's':
			fsoptions.minsize = fsoptions.maxsize =
			    strsuftoll("size", optarg, 1LL, LLONG_MAX);
			break;

		case 'S':
			fsoptions.sectorsize =
			    (int)strsuftoll("sector size", optarg,
				1LL, INT_MAX);
			break;

		case 't':
			/* Check current one and cleanup if necessary. */
			if (fstype->cleanup_options)
				fstype->cleanup_options(&fsoptions);
			fsoptions.fs_specific = NULL;
			if ((fstype = get_fstype(optarg)) == NULL)
				errx(1, "Unknown fs type `%s'.", optarg);
			fstype->prepare_options(&fsoptions);
			break;

		case 'T':
			fsoptions.maxtime = strtoll(optarg, NULL, 10);
			if (start_time.tv_sec >= fsoptions.maxtime) {
				start_time.tv_sec = fsoptions.maxtime;
				start_time.tv_nsec = 0;
			}
			break;

		case 'x':
			fsoptions.onlyspec = 1;
			break;

		case '?':
		default:
			usage();
			/* NOTREACHED */

		}
	}
	if (debug) {
		printf("debug mask: 0x%08x\n", debug);
		printf("start time: %ld.%ld, %s",
		    (long)start_time.tv_sec, (long)start_time.tv_nsec,
		    ctime(&start_time.tv_sec));
	}
	argc -= optind;
	argv += optind;

	if (argc != 2)
		usage();

	/* -x must be accompanied by -F */
	if (fsoptions.onlyspec != 0 && specfile == NULL)
		errx(1, "-x requires -F mtree-specfile.");

				/* walk the tree */
	TIMER_START(start);
	root = walk_dir(argv[1], NULL);
	TIMER_RESULTS(start, "walk_dir");

	if (specfile) {		/* apply a specfile */
		TIMER_START(start);
		apply_specfile(specfile, argv[1], root, fsoptions.onlyspec);
		TIMER_RESULTS(start, "apply_specfile");
	}

	if (debug & DEBUG_DUMP_FSNODES) {
		printf("\nparent: %s\n", argv[1]);
		dump_fsnodes(".", root);
		putchar('\n');
	}

				/* build the filesystem */
	TIMER_START(start);
	fstype->make_fs(argv[0], argv[1], root, &fsoptions);
	TIMER_RESULTS(start, "make_fs");

	free_fsnodes(root);

	exit(0);
	/* NOTREACHED */
}


int
set_option(option_t *options, const char *var, const char *val)
{
	int	i;

	for (i = 0; options[i].name != NULL; i++) {
		if (strcmp(options[i].name, var) != 0)
			continue;
		*options[i].value = (int)strsuftoll(options[i].desc, val,
		    options[i].minimum, options[i].maximum);
		return (1);
	}
	warnx("Unknown option `%s'", var);
	return (0);
}


static fstype_t *
get_fstype(const char *type)
{
	int i;

	for (i = 0; fstypes[i].type != NULL; i++)
		if (strcmp(fstypes[i].type, type) == 0)
			return (&fstypes[i]);
	return (NULL);
}

static void
usage(void)
{
#ifdef __NetBSD__
	const char *prog;

	prog = getprogname();
#define __progname prog
#else
	extern const char *__progname;
#endif
	fprintf(stderr,
"usage: %s [-t fs-type] [-o fs-options] [-d debug-mask] [-B endian]\n"
"\t[-S sector-size] [-M minimum-size] [-m maximum-size] [-s image-size]\n"
"\t[-b free-blocks] [-f free-files] [-F mtree-specfile] [-x]\n"
"\t[-N userdb-dir] [-T maximum-time] image-file directory\n",
	    __progname);
	exit(1);
}
@


1.16
log
@filesystem
@
text
@d44 1
a44 1
#if defined(__MirBSD__) || defined(DEBIAN)
d51 1
a51 1
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/makefs.c,v 1.15 2016/06/11 14:55:39 tg Exp $");
@


1.15
log
@oops, a .rej chunk
@
text
@d51 1
a51 1
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/makefs.c,v 1.14 2016/06/11 14:52:48 tg Exp $");
d71 1
a71 1
 * list of supported file systems and dispatch functions
d306 1
a306 1
				/* build the file system */
@


1.14
log
@apply “Implement -T maximum-time argument” patch
From: Steven Chamberlain <steven@@pyro.eu.org>
@
text
@d51 1
a51 1
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/makefs.c,v 1.13 2010/03/16 22:05:55 tg Exp $");
d361 1
a361 1
"\t[-N userdb-dir] image-file directory\n",
@


1.13
log
@experimental for Fedora without libbsd
@
text
@d51 1
a51 1
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/makefs.c,v 1.12 2010/03/07 00:02:17 tg Exp $");
d133 1
d145 1
a145 1
	while ((ch = getopt(argc, argv, "B:b:d:f:F:M:m:N:o:s:S:t:x")) != -1) {
d254 8
@


1.12
log
@get rid of PATH_MAX and MAXPATHLEN uses (probably could use asprintf tho…)
@
text
@d51 1
a51 1
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/makefs.c,v 1.11 2010/03/06 23:24:14 tg Exp $");
d121 1
d123 1
d340 1
d344 4
d353 1
a353 1
	    prog);
@


1.11
log
@sync © lines
@
text
@d4 1
a4 1
 * Copyright (c) 2009
d51 1
a51 1
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/makefs.c,v 1.10 2010/03/06 21:29:04 tg Exp $");
d90 1
d107 14
@


1.10
log
@merge and attempt to fix
• cd9660/iso9660_rrip.c:cd9660_susp_handle_continuation_common() has
  some different code for keeping track of working and placement of
  the CE on the disc now but it looks as if it’s correct
• I am fairly positive this doesn’t regress… but, alas, no guarantee
@
text
@d4 2
a5 1
 * Copyright (c) 2009 Thorsten Glaser
d51 1
a51 1
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/makefs.c,v 1.9 2009/07/23 19:32:24 tg Exp $");
@


1.9
log
@apply fixes, missing includes, and Debian compatibility glue to makefs(8);
create an initial, experimental Debian source package for it for Luca Fav.
@
text
@a0 1
/**	$MirOS: src/usr.sbin/makefs/makefs.c,v 1.8 2008/10/31 21:24:24 tg Exp $ */
d50 1
a50 1
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/makefs.c,v 1.8 2008/10/31 21:24:24 tg Exp $");
@


1.8
log
@build with __CRAZY=Yes
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/makefs/makefs.c,v 1.7 2008/10/31 19:45:30 tg Exp $ */
d5 1
d44 1
a44 1
#ifdef __MirBSD__
d51 1
a51 1
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/makefs.c,v 1.7 2008/10/31 19:45:30 tg Exp $");
d54 3
d201 1
a201 1
			
d313 1
a313 1
	
@


1.7
log
@now make it compile without -Wno-error
@
text
@d1 1
a1 1
/**	$MirOS$ */
d50 1
a50 1
__IDSTRING(mbsdid, "$MirOS$");
d89 1
a89 1
static	void	usage(void);
@


1.6
log
@bring MAIN branch into the pristine TNF state for reverse-merging
@
text
@d1 1
d43 4
d50 1
@


1.5
log
@__CRAZY=Yes cleanup… can't they even use compiler warnings…
cruel netbsd code *sigh*
@
text
@d1 1
a1 1
/*	$NetBSD: makefs.c,v 1.22 2005/08/13 01:53:01 fvdl Exp $	*/
d44 1
a44 2
__RCSID("$MirOS: src/usr.sbin/makefs/makefs.c,v 1.4 2006/07/05 20:27:24 tg Exp $");
__RCSID("$NetBSD: makefs.c,v 1.22 2005/08/13 01:53:01 fvdl Exp $");
a59 7
/* LONGLONG */
long long strsuftoll(const char *desc, const char *val,
    long long min, long long max);
/* LONGLONG */
long long strsuftollx(const char *desc, const char *val,
    long long min, long long max, char *ebuf, size_t ebuflen);

d76 1
a76 1
	{ NULL, NULL, NULL, NULL, NULL	},
d83 1
a83 1
static	void	usage(void) __dead;
d154 1
a154 2
			debug =
			    (int)strsuftoll("debug mask", optarg, 0, UINT_MAX);
d260 1
a260 1
		apply_specfile(specfile, argv[1], root);
d275 2
@


1.4
log
@fix missing protos
@
text
@d44 1
a60 2
__RCSID("$MirOS$");

d84 1
a84 1
	{ NULL	},
d91 1
a91 1
static	void	usage(void);
@


1.3
log
@build
@
text
@d60 9
@


1.2
log
@undo http://cvsweb.netbsd.org/bsdweb.cgi/src/usr.sbin/makefs/makefs.c.diff?r1=1.10&r2=1.11
@
text
@d57 1
d117 1
a117 1
	while ((ch = getopt(argc, argv, "B:b:d:f:F:M:m:o:s:S:t:x")) != -1) {
d181 7
d319 1
a319 1
"\timage-file directory\n",
@


1.1
log
@Initial revision
@
text
@a56 1
#include "mtree.h"
d116 1
a116 1
	while ((ch = getopt(argc, argv, "B:b:d:f:F:M:m:N:o:s:S:t:x")) != -1) {
a179 7
		case 'N':
			if (! setup_getid(optarg))
				errx(1,
			    "Unable to use user and group databases in `%s'",
				    optarg);
			break;

d311 1
a311 1
"\t[-N userdb-dir] image-file directory\n",
@


1.1.3.1
log
@Time to hack on makefs, from TNF
@
text
@@


1.1.3.2
log
@Import NetBSD®-current (just after or at the 5.0 branch) makefs(8)
and subtree required to build it in MirBSD
@
text
@d1 1
a1 1
/*	$NetBSD: makefs.c,v 1.26 2006/10/22 21:11:56 christos Exp $	*/
d44 1
a44 1
__RCSID("$NetBSD: makefs.c,v 1.26 2006/10/22 21:11:56 christos Exp $");
d76 1
a76 1
	{ .type = NULL	},
d154 2
a155 1
			debug = strtoll(optarg, NULL, 0);
d261 1
a261 1
		apply_specfile(specfile, argv[1], root, fsoptions.onlyspec);
a275 2
	free_fsnodes(root);

@

