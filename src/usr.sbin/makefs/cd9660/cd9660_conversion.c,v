head	1.8;
access;
symbols
	cvs-201003062040:1.1.3.2
	cvs-200810311900:1.1.3.2
	MIRBSD_10:1.2.0.2
	MIRBSD_10_BASE:1.2
	cvs-200607051500:1.1.3.1
	netbsd:1.1.3;
locks; strict;
comment	@ * @;


1.8
date	2010.03.06.22.38.48;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004B92D96675BE887A;

1.7
date	2010.03.06.21.29.06;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004B92C8D37339B566;

1.6
date	2008.11.06.23.45.18;	author tg;	state Exp;
branches;
next	1.5;
commitid	100491381717E19935E;

1.5
date	2008.10.31.20.33.47;	author tg;	state Exp;
branches;
next	1.4;
commitid	100490B6BBD48A7C3A2;

1.4
date	2008.10.31.20.12.10;	author tg;	state Exp;
branches;
next	1.3;
commitid	100490B6697585594BF;

1.3
date	2008.10.31.19.11.34;	author tg;	state Exp;
branches;
next	1.2;
commitid	100490B58676FCB2D2F;

1.2
date	2006.09.21.20.16.23;	author tg;	state Exp;
branches;
next	1.1;
commitid	1004512F320386F848A;

1.1
date	2006.07.05.15.08.37;	author tg;	state Exp;
branches
	1.1.3.1;
next	;
commitid	10044ABD6033365D559;

1.1.3.1
date	2006.07.05.15.08.37;	author tg;	state Exp;
branches;
next	1.1.3.2;
commitid	10044ABD6033365D559;

1.1.3.2
date	2008.10.31.19.06.04;	author tg;	state Exp;
branches;
next	;
commitid	100490B57202F143953;


desc
@@


1.8
log
@The ability to set the {creation,modification,effective,expiry} date of
the created ECMA 119 image to any valid UTC value manually.

This is used by GNU GRUB 2 which takes the mtime as “UUID” of sorts.
@
text
@/*	$NetBSD: cd9660_conversion.c,v 1.4 2007/03/14 14:11:17 christos Exp $	*/

/*
 * Copyright (c) 2005 Daniel Watt, Walter Deignan, Ryan Gabrys, Alan
 * Perez-Rathke and Ram Vedam.  All rights reserved.
 *
 * This code was written by Daniel Watt, Walter Deignan, Ryan Gabrys,
 * Alan Perez-Rathke and Ram Vedam.
 *
 * Redistribution and use in source and binary forms, with or
 * without modification, are permitted provided that the following
 * conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY DANIEL WATT, WALTER DEIGNAN, RYAN
 * GABRYS, ALAN PEREZ-RATHKE AND RAM VEDAM ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL DANIEL WATT, WALTER DEIGNAN, RYAN
 * GABRYS, ALAN PEREZ-RATHKE AND RAM VEDAM BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE,DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 */

#define CD9660_CONVERSION_IMPL
#include "cd9660.h"

#include <sys/cdefs.h>
#if defined(__RCSID) && !defined(__lint)
__RCSID("$NetBSD: cd9660_conversion.c,v 1.4 2007/03/14 14:11:17 christos Exp $");
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/cd9660/cd9660_conversion.c,v 1.7 2010/03/06 21:29:06 tg Exp $");
#endif  /* !__lint */


static char cd9660_compute_gm_offset(time_t);

#if 0
static inline int
cd9660_pad_even(length)
int length;
{
	return length + (length & 0x01);
}
#endif

/*
* These can probably be implemented using a macro
*/

/* Little endian */
void
cd9660_721(uint16_t w, unsigned char *twochar)
{
#if BYTE_ORDER == BIG_ENDIAN
	w = bswap16(w);
#endif
	memcpy(twochar,&w,2);
}

void
cd9660_731(uint32_t w, unsigned char *fourchar)
{
#if BYTE_ORDER == BIG_ENDIAN
	w = bswap32(w);
#endif
	memcpy(fourchar,&w,4);
}

/* Big endian */
void
cd9660_722(uint16_t w, unsigned char *twochar)
{
#if BYTE_ORDER == LITTLE_ENDIAN
	w = bswap16(w);
#endif
	memcpy(twochar,&w,2);
}

void
cd9660_732(uint32_t w, unsigned char *fourchar)
{
#if BYTE_ORDER == LITTLE_ENDIAN
	w = bswap32(w);
#endif
	memcpy(fourchar,&w,4);
}

/**
* Convert a dword into a double endian string of eight characters
* @@param int The double word to convert
* @@param char* The string to write the both endian double word to - It is assumed this is allocated and at least
*		eight characters long
*/
void
cd9660_bothendian_dword(uint32_t dw, unsigned char *eightchar)
{
	uint32_t le, be;
#if BYTE_ORDER == LITTLE_ENDIAN
	le = dw;
	be = bswap32(dw);
#endif
#if BYTE_ORDER == BIG_ENDIAN
	be = dw;
	le = bswap32(dw);
#endif
	memcpy(eightchar, &le, 4);
	memcpy((eightchar+4), &be, 4);
}

/**
* Convert a word into a double endian string of four characters
* @@param int The word to convert
* @@param char* The string to write the both endian word to - It is assumed this is allocated and at least
*		four characters long
*/
void
cd9660_bothendian_word(uint16_t dw, unsigned char *fourchar)
{
	uint16_t le, be;
#if BYTE_ORDER == LITTLE_ENDIAN
	le = dw;
	be = bswap16(dw);
#endif
#if BYTE_ORDER == BIG_ENDIAN
	be = dw;
	le = bswap16(dw);
#endif
	memcpy(fourchar, &le, 2);
	memcpy((fourchar+2), &be, 2);
}

void
cd9660_pad_string_spaces_(char *str, size_t len)
{
	size_t i;

	for (i = 0; i < len; i ++) {
		if (str[i] == '\0')
			str[i] = 0x20;
	}
}

static char
cd9660_compute_gm_offset(time_t tim)
{
	struct tm t, gm;

	(void)localtime_r(&tim, &t);
	(void)gmtime_r(&tim, &gm);
	gm.tm_year -= t.tm_year;
	gm.tm_yday -= t.tm_yday;
	gm.tm_hour -= t.tm_hour;
	gm.tm_min  -= t.tm_min;
	if (gm.tm_year < 0)
		gm.tm_yday = -1;
	else if (gm.tm_year > 0)
		gm.tm_yday = 1;

	return (char)(-(gm.tm_min + 60* (24 * gm.tm_yday + gm.tm_hour)) / 15);
}

/* Long dates: 17 characters */
void
cd9660_time_8426(time_t tim, unsigned char *buf)
{
	struct tm t;
	char temp[18];

	(void)localtime_r(&tim, &t);
	(void)snprintf(temp, sizeof(temp), "%04i%02i%02i%02i%02i%02i%02i",
		1900+(int)t.tm_year,
		(int)t.tm_mon+1,
		(int)t.tm_mday,
		(int)t.tm_hour,
		(int)t.tm_min,
		(int)t.tm_sec,
		0);
	(void)memcpy(buf, temp, 16);
	buf[16] = cd9660_compute_gm_offset(tim);
}

/* Short dates: 7 characters */
void
cd9660_time_915(time_t tim, unsigned char *buf)
{
	struct tm t;

	(void)localtime_r(&tim, &t);
	buf[0] = t.tm_year;
	buf[1] = t.tm_mon+1;
	buf[2] = t.tm_mday;
	buf[3] = t.tm_hour;
	buf[4] = t.tm_min;
	buf[5] = t.tm_sec;
	buf[6] = cd9660_compute_gm_offset(tim);
}

int
cd9660_isthisa_time_8426_utc(const char *val, const char *fieldtitle)
{
	int i, j;

	if (val == NULL || strlen(val) != 16) {
		warnx("error: The %s requires a 16 bytes 8.4.26 time argument",
		     fieldtitle);
		return (0);
	}

	j = 0;
	for (i = 0; i < 16; ++i)
		if (val[i] < '0' || val[i] > '9') {
			warnx("error: The %s must be composed of digits",
			    fieldtitle);
			return (0);
		} else if (val[i] != '0')
			j = 1;

	if (j == 0)
		/* 16 times '0' */
		return (1);

#define otoa(x) (val[x] - '0')

	if (val[0] == '0' && val[1] == '0' && val[2] == '0' && val[3] == '0') {
		warnx("error: The %s %s is invalid (%s)", fieldtitle,
		    "year", "too small");
		return (0);
	}

	i = otoa(4) * 10 + otoa(5);
	if (i < 1 || i > 12) {
		warnx("error: The %s %s is invalid (%s)", fieldtitle,
		    "month", "not 1..12");
		return (0);
	}

	i = otoa(6) * 10 + otoa(7);
	if (i < 1 || i > 31) {
		warnx("error: The %s %s is invalid (%s)", fieldtitle,
		    "day", "not 1..31");
		return (0);
	}

	i = otoa(8) * 10 + otoa(9);
	if (i > 23) {
		warnx("error: The %s %s is invalid (%s)", fieldtitle,
		    "hour", "not 0..23");
		return (0);
	}

	i = otoa(10) * 10 + otoa(11);
	if (i > 59) {
		warnx("error: The %s %s is invalid (%s)", fieldtitle,
		    "minute", "not 0..59");
		return (0);
	}

	i = otoa(12) * 10 + otoa(13);
	if (i > 59) {
		/* but in ECMA 119: should be 0..60 */
		warnx("error: The %s %s is invalid (%s)", fieldtitle,
		    "second", "not 0..59");
		return (0);
	}

#undef otoa

	/* hundredths are 00..99 alright */
	/* offset is NUL (UTC) alright */
	return (1);
}
@


1.7
log
@merge and attempt to fix
• cd9660/iso9660_rrip.c:cd9660_susp_handle_continuation_common() has
  some different code for keeping track of working and placement of
  the CE on the disc now but it looks as if it’s correct
• I am fairly positive this doesn’t regress… but, alas, no guarantee
@
text
@d41 1
a41 1
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/cd9660/cd9660_conversion.c,v 1.6 2008/11/06 23:45:18 tg Exp $");
d207 75
@


1.6
log
@Honour Ecma-119 (ISO 9660) standard: fix out-of-bounds write/padding
access for the primary volume descriptor (and probably others) – the
padding overwrite some must-be-zero parts of this crucial structure!
@
text
@a0 1
/**	$MirOS: src/usr.sbin/makefs/cd9660/cd9660_conversion.c,v 1.5 2008/10/31 20:33:47 tg Exp $ */
d41 1
a41 1
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/cd9660/cd9660_conversion.c,v 1.5 2008/10/31 20:33:47 tg Exp $");
@


1.5
log
@implement some bounds checking
@
text
@d1 1
a1 1
/**	$MirOS$ */
d42 1
a42 1
__IDSTRING(mbsdid, "$MirOS$");
d144 1
a144 1
cd9660_pad_string_spaces(char *str, int len)
d146 1
a146 1
	int i;
@


1.4
log
@switch argument order of cd9660_time_8426 and cd9660_time_915 to
match the prototype of the other ISO 9660 data type functions
@
text
@d1 1
d35 2
d42 1
@


1.3
log
@bring MAIN branch into the pristine TNF state for reverse-merging
@
text
@d171 1
a171 1
cd9660_time_8426(unsigned char *buf, time_t tim)
d191 1
a191 1
cd9660_time_915(unsigned char *buf, time_t tim)
@


1.2
log
@get rid of strcpy, strcat and sprintf
XXX should add bounded attributes

bad bad TNF
@
text
@d1 1
a1 1
/*	$NetBSD: cd9660_conversion.c,v 1.3 2005/12/24 20:56:41 perry Exp $	*/
d38 1
a38 2
__RCSID("$MirOS$");
__RCSID("$NetBSD: cd9660_conversion.c,v 1.3 2005/12/24 20:56:41 perry Exp $");
d153 1
a153 2
	struct tm* t;
	struct tm* gm;
d155 10
a164 10
	t = localtime(&tim);
	gm = gmtime(&tim);
	gm->tm_year -= t->tm_year;
	gm->tm_yday -= t->tm_yday;
	gm->tm_hour -= t->tm_hour;
	gm->tm_min  -= t->tm_min;
	if (gm->tm_year < 0)
		gm->tm_yday = -1;
	else if (gm->tm_year > 0)
		gm->tm_yday = 1;
d166 1
a166 1
	return (char)(-(gm->tm_min + 60* (24 * gm->tm_yday + gm->tm_hour)) / 15);
d173 1
a173 1
	struct tm *t;
d176 8
a183 8
	t = localtime(&tim);
	snprintf(temp, sizeof (temp), "%04i%02i%02i%02i%02i%02i%02i",
		1900+(int)t->tm_year,
		(int)t->tm_mon+1,
		(int)t->tm_mday,
		(int)t->tm_hour,
		(int)t->tm_min,
		(int)t->tm_sec,
d185 1
a185 1
	memcpy(buf, temp, 16);
d193 1
a193 2
	struct tm *t;
	t = localtime(&tim);
d195 7
a201 6
	buf[0] = t->tm_year;
	buf[1] = t->tm_mon+1;
	buf[2] = t->tm_mday;
	buf[3] = t->tm_hour;
	buf[4] = t->tm_min;
	buf[5] = t->tm_sec;
@


1.1
log
@Initial revision
@
text
@d38 1
d179 1
a179 1
	sprintf(temp,"%04i%02i%02i%02i%02i%02i%02i",
@


1.1.3.1
log
@Time to hack on makefs, from TNF
@
text
@@


1.1.3.2
log
@Import NetBSD®-current (just after or at the 5.0 branch) makefs(8)
and subtree required to build it in MirBSD
@
text
@d1 1
a1 1
/*	$NetBSD: cd9660_conversion.c,v 1.4 2007/03/14 14:11:17 christos Exp $	*/
d38 1
a38 1
__RCSID("$NetBSD: cd9660_conversion.c,v 1.4 2007/03/14 14:11:17 christos Exp $");
d153 2
a154 1
	struct tm t, gm;
d156 10
a165 10
	(void)localtime_r(&tim, &t);
	(void)gmtime_r(&tim, &gm);
	gm.tm_year -= t.tm_year;
	gm.tm_yday -= t.tm_yday;
	gm.tm_hour -= t.tm_hour;
	gm.tm_min  -= t.tm_min;
	if (gm.tm_year < 0)
		gm.tm_yday = -1;
	else if (gm.tm_year > 0)
		gm.tm_yday = 1;
d167 1
a167 1
	return (char)(-(gm.tm_min + 60* (24 * gm.tm_yday + gm.tm_hour)) / 15);
d174 1
a174 1
	struct tm t;
d177 8
a184 8
	(void)localtime_r(&tim, &t);
	(void)snprintf(temp, sizeof(temp), "%04i%02i%02i%02i%02i%02i%02i",
		1900+(int)t.tm_year,
		(int)t.tm_mon+1,
		(int)t.tm_mday,
		(int)t.tm_hour,
		(int)t.tm_min,
		(int)t.tm_sec,
d186 1
a186 1
	(void)memcpy(buf, temp, 16);
d194 2
a195 1
	struct tm t;
d197 6
a202 7
	(void)localtime_r(&tim, &t);
	buf[0] = t.tm_year;
	buf[1] = t.tm_mon+1;
	buf[2] = t.tm_mday;
	buf[3] = t.tm_hour;
	buf[4] = t.tm_min;
	buf[5] = t.tm_sec;
@

