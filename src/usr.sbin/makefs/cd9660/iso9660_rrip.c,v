head	1.22;
access;
symbols
	cvs-201003062040:1.1.3.3
	cvs-200810311900:1.1.3.2
	MIRBSD_10:1.1.3.1.0.2
	MIRBSD_10_BASE:1.1.3.1
	cvs-200607051500:1.1.3.1
	netbsd:1.1.3;
locks; strict;
comment	@ * @;


1.22
date	2010.03.06.21.29.07;	author tg;	state Exp;
branches;
next	1.21;
commitid	1004B92C8D37339B566;

1.21
date	2009.06.29.18.58.55;	author tg;	state Exp;
branches;
next	1.20;
commitid	1004A490EE45B107F59;

1.20
date	2009.06.29.18.49.28;	author tg;	state Exp;
branches;
next	1.19;
commitid	1004A490CCB4CB41093;

1.19
date	2009.01.18.18.47.06;	author tg;	state Exp;
branches;
next	1.18;
commitid	100497378EC5AE2AFC1;

1.18
date	2008.11.06.18.13.23;	author tg;	state Exp;
branches;
next	1.17;
commitid	100491333D962AA8CD8;

1.17
date	2008.11.04.00.29.37;	author tg;	state Exp;
branches;
next	1.16;
commitid	100490F97543836FF0F;

1.16
date	2008.11.04.00.21.11;	author tg;	state Exp;
branches;
next	1.15;
commitid	100490F95845C3F2C4D;

1.15
date	2008.11.04.00.11.31;	author tg;	state Exp;
branches;
next	1.14;
commitid	100490F933249A41937;

1.14
date	2008.11.03.23.11.28;	author tg;	state Exp;
branches;
next	1.13;
commitid	100490F853136592F4C;

1.13
date	2008.11.03.22.44.55;	author tg;	state Exp;
branches;
next	1.12;
commitid	100490F7E98213DF8E4;

1.12
date	2008.11.03.22.37.50;	author tg;	state Exp;
branches;
next	1.11;
commitid	100490F7D21527AD965;

1.11
date	2008.11.03.21.26.48;	author tg;	state Exp;
branches;
next	1.10;
commitid	100490F6CA85AE5AE57;

1.10
date	2008.11.03.20.54.55;	author tg;	state Exp;
branches;
next	1.9;
commitid	100490F646039644BF6;

1.9
date	2008.10.31.23.04.08;	author tg;	state Exp;
branches;
next	1.8;
commitid	100490B8EF75D813E85;

1.8
date	2008.10.31.22.55.17;	author tg;	state Exp;
branches;
next	1.7;
commitid	100490B8CE55C4A08FF;

1.7
date	2008.10.31.22.19.12;	author tg;	state Exp;
branches;
next	1.6;
commitid	100490B84671A281AB8;

1.6
date	2008.10.31.21.31.37;	author tg;	state Exp;
branches;
next	1.5;
commitid	100490B794B4F8B9E68;

1.5
date	2008.10.31.20.56.49;	author tg;	state Exp;
branches;
next	1.4;
commitid	100490B70F5455501C4;

1.4
date	2008.10.31.20.55.16;	author tg;	state Exp;
branches;
next	1.3;
commitid	100490B70C25F816D00;

1.3
date	2008.10.31.20.42.29;	author tg;	state Exp;
branches;
next	1.2;
commitid	100490B6DAF31706723;

1.2
date	2008.10.31.20.12.10;	author tg;	state Exp;
branches;
next	1.1;
commitid	100490B6697585594BF;

1.1
date	2006.07.05.15.08.37;	author tg;	state Exp;
branches
	1.1.3.1;
next	;
commitid	10044ABD6033365D559;

1.1.3.1
date	2006.07.05.15.08.37;	author tg;	state Exp;
branches;
next	1.1.3.2;
commitid	10044ABD6033365D559;

1.1.3.2
date	2008.10.31.19.06.04;	author tg;	state Exp;
branches;
next	1.1.3.3;
commitid	100490B57202F143953;

1.1.3.3
date	2010.03.06.20.44.40;	author tg;	state Exp;
branches;
next	;
commitid	1004B92BEC54F4CD073;


desc
@@


1.22
log
@merge and attempt to fix
• cd9660/iso9660_rrip.c:cd9660_susp_handle_continuation_common() has
  some different code for keeping track of working and placement of
  the CE on the disc now but it looks as if it’s correct
• I am fairly positive this doesn’t regress… but, alas, no guarantee
@
text
@/*	$NetBSD: iso9660_rrip.c,v 1.8 2009/01/10 22:06:29 bjh21 Exp $	*/

/*
 * Copyright (c) 2009, 2010
 *	Thorsten Glaser <tg@@mirbsd.org>
 * Copyright (c) 2005 Daniel Watt, Walter Deignan, Ryan Gabrys, Alan
 * Perez-Rathke and Ram Vedam.  All rights reserved.
 *
 * This code was written by Daniel Watt, Walter Deignan, Ryan Gabrys,
 * Alan Perez-Rathke and Ram Vedam.
 *
 * Redistribution and use in source and binary forms, with or
 * without modification, are permitted provided that the following
 * conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY DANIEL WATT, WALTER DEIGNAN, RYAN
 * GABRYS, ALAN PEREZ-RATHKE AND RAM VEDAM ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL DANIEL WATT, WALTER DEIGNAN, RYAN
 * GABRYS, ALAN PEREZ-RATHKE AND RAM VEDAM BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE,DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 */
/* This will hold all the function definitions
 * defined in iso9660_rrip.h
 */

#include "makefs.h"
#include "cd9660.h"
#include "iso9660_rrip.h"
#include <sys/queue.h>
#include <stdio.h>

#include <sys/cdefs.h>
#if defined(__RCSID) && !defined(__lint)
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.21 2009/06/29 18:58:55 tg Exp $");
__RCSID("$NetBSD: iso9660_rrip.c,v 1.8 2009/01/10 22:06:29 bjh21 Exp $");
#endif  /* !__lint */

static void cd9660_rrip_initialize_inode(cd9660node *);
static int cd9660_susp_handle_continuation(cd9660node *);
static int cd9660_susp_handle_continuation_common(cd9660node *, int);

int
cd9660_susp_initialize(cd9660node *node, cd9660node *parent,
    cd9660node *grandparent, int shortcut)
{
	cd9660node *cn;
	int r;

	/* Make sure the node is not NULL. If it is, there are major problems */
	assert(node != NULL);

	if (shortcut == 2) {
		shortcut = 0;
		goto cd9660_susp_initialize_shortcut;
	}

	if (!(node->type & CD9660_TYPE_DOT) &&
	    !(node->type & CD9660_TYPE_DOTDOT))
		TAILQ_INIT(&(node->head));
	if (node->dot_record != 0)
		TAILQ_INIT(&(node->dot_record->head));
	if (node->dot_dot_record != 0)
		TAILQ_INIT(&(node->dot_dot_record->head));

	 /* SUSP specific entries here */
	if ((r = cd9660_susp_initialize_node(node)) < 0)
		return r;

	/* currently called cd9660node_rrip_init_links */
	r = cd9660_rrip_initialize_node(node, parent, grandparent);
	if (r < 0)
		return r;

	/*
	 * If we are the root node, we need to initialise the entries for
	 * our dot node now (out of the below loop) with shortcut set to
	 * 1, then move all of its entries (save PX to prevent duplicates)
	 * into it, then finalise the dot node out of bounds but after us
	 * again. The “shortcut” variable is unused after the label, thus
	 * it can be used as temporary to speed up the loop.
	 */

	if (shortcut == 1)
		return 1;
 cd9660_susp_initialize_shortcut:
	/* assert: shortcut == 0 here */

	if (node == diskStructure.rootNode) {
		/* We are the root node. */
		struct ISO_SUSP_ATTRIBUTES *temp;

		/* Initialise our dot record. */
		if ((r = cd9660_susp_initialize(node->dot_record, node,
		    parent, 1)) < 0)
			return r;

		/* Move SUSP entries. */
		while ((temp = TAILQ_FIRST(&node->head))) {
			TAILQ_REMOVE(&node->head, temp, rr_ll);
			if (temp->attr.su_entry.SP.h.type[0] != 'P' ||
			    temp->attr.su_entry.SP.h.type[1] != 'X')
				TAILQ_INSERT_TAIL(&node->dot_record->head,
				    temp, rr_ll);
		}

		/* Note that we are the root node. */
		shortcut = 1;

		/* Now go on process ourselves normally. */
	}

	/*
	 * See if we need a CE record, and set all of the
	 * associated counters.
	 *
	 * This should be called after all extensions. After
	 * this is called, no new records should be added.
	 */
	if ((r = cd9660_susp_handle_continuation(node)) < 0)
		return r;

	/* Recurse on children. */
	TAILQ_FOREACH(cn, &node->cn_children, cn_next_child) {
		if ((r = cd9660_susp_initialize(cn, node, parent,
		    /* root node? */ shortcut && cn == node->dot_record ?
		    /* finish only */ 2 : /* full operation */ 0)) < 0)
			return 0;
	}
	return 1;
}

int
cd9660_susp_finalize(cd9660node *node)
{
	cd9660node *temp;
	int r;

	assert(node != NULL);

	if (node == diskStructure.rootNode)
		diskStructure.susp_continuation_area_current_free = 0;

	if ((r = cd9660_susp_finalize_node(node)) < 0)
		return r;
	if ((r = cd9660_rrip_finalize_node(node)) < 0)
		return r;

	TAILQ_FOREACH(temp, &node->cn_children, cn_next_child) {
		if ((r = cd9660_susp_finalize(temp)) < 0)
			return r;
	}
	return 1;
}

/*
 * If we really wanted to speed things up, we could have some sort of
 * lookup table on the SUSP entry type that calls a functor. Or, we could
 * combine the functions. These functions are kept separate to allow
 * easier addition of other extensions.

 * For the sake of simplicity and clarity, we won't be doing that for now.
 */

/*
 * SUSP needs to update the following types:
 * CE (continuation area)
 */
int
cd9660_susp_finalize_node(cd9660node *node)
{
	struct ISO_SUSP_ATTRIBUTES *t;

	/* Handle CE counters */
	if (node->susp_entry_ce_length > 0) {
		node->susp_entry_ce_start =
		    diskStructure.susp_continuation_area_current_free;
		diskStructure.susp_continuation_area_current_free +=
		    node->susp_entry_ce_length;
	}

	TAILQ_FOREACH(t, &node->head, rr_ll) {
		if (t->susp_type != SUSP_TYPE_SUSP ||
		    t->entry_type != SUSP_ENTRY_SUSP_CE)
			continue;
		cd9660_bothendian_dword(
			diskStructure.
			  susp_continuation_area_start_sector,
			t->attr.su_entry.CE.ca_sector);

		cd9660_bothendian_dword(
			diskStructure.
			  susp_continuation_area_start_sector,
			t->attr.su_entry.CE.ca_sector);
		cd9660_bothendian_dword(node->susp_entry_ce_start,
			t->attr.su_entry.CE.offset);
		cd9660_bothendian_dword(node->susp_entry_ce_length,
			t->attr.su_entry.CE.length);
	}
	return 0;
}

int
cd9660_rrip_finalize_node(cd9660node *node)
{
	struct ISO_SUSP_ATTRIBUTES *t;

	TAILQ_FOREACH(t, &node->head, rr_ll) {
		if (t->susp_type != SUSP_TYPE_RRIP)
			continue;
		switch (t->entry_type) {
		case SUSP_ENTRY_RRIP_CL:
			/* Look at rr_relocated*/
			if (node->rr_relocated == NULL)
				return -1;
			cd9660_bothendian_dword(
			    node->rr_relocated->fileDataSector,
			    t->attr.rr_entry.CL.dir_loc);
			break;
		case SUSP_ENTRY_RRIP_PL:
			/* Look at rr_real_parent */
			if (node->parent->rr_real_parent == NULL)
				return -1;
			cd9660_bothendian_dword(
			    node->parent->rr_real_parent->fileDataSector,
			    t->attr.rr_entry.PL.dir_loc);
			break;
		}
	}
	return 0;
}

static int
cd9660_susp_handle_continuation_common(cd9660node *node, int space)
{
	int ca_used, susp_used, susp_used_pre_ce, working;
	struct ISO_SUSP_ATTRIBUTES *temp, *pre_ce, *last, *CE, *ST;

	pre_ce = last = NULL;
	working = 254 - space;
	if (node->su_tail_size > 0)
		/* Allow 4 bytes for "ST" record. */
		working -= node->su_tail_size + 4;
#ifdef DEBUG
	printf("There are %i bytes to work with\n", working);
#endif

	susp_used_pre_ce = susp_used = 0;
	ca_used = 0;
	TAILQ_FOREACH(temp, &node->head, rr_ll) {
		if (working < 0)
			break;
#ifdef DEBUG
		printf("SUSP entry %c%c found, length %d\n",
		    temp->attr.su_entry.SP.h.type[0],
		    temp->attr.su_entry.SP.h.type[1],
		    temp->attr.su_entry.SP.h.length[0]);
#endif
		working -= CD9660_SUSP_ENTRY_SIZE(temp);
		if (working >= 0) {
			last = temp;
			susp_used += CD9660_SUSP_ENTRY_SIZE(temp);
		}
		if (working >= 28) {
			/*
			 * Remember the last entry after which we
			 * could insert a "CE" entry.
			 */
			pre_ce = last;
			susp_used_pre_ce = susp_used;
		}
	}

	/* A CE entry is needed */
	if (working <= 0) {
		CE = cd9660node_susp_create_node(SUSP_TYPE_SUSP,
			SUSP_ENTRY_SUSP_CE, "CE", SUSP_LOC_ENTRY);
		cd9660_susp_ce(CE, node);
		/* This will automatically insert at the appropriate location */
		if (pre_ce != NULL)
			TAILQ_INSERT_AFTER(&node->head, pre_ce, CE, rr_ll);
		else
			TAILQ_INSERT_HEAD(&node->head, CE, rr_ll);
		last = CE;
		susp_used = susp_used_pre_ce + 28;
		/* Count how much CA data is necessary */
		for (temp = TAILQ_NEXT(last, rr_ll); temp != NULL;
		     temp = TAILQ_NEXT(temp, rr_ll)) {
			ca_used += CD9660_SUSP_ENTRY_SIZE(temp);
		}
	}

	/* An ST entry is needed */
	if (node->su_tail_size > 0) {
		ST = cd9660node_susp_create_node(SUSP_TYPE_SUSP,
		    SUSP_ENTRY_SUSP_ST, "ST", SUSP_LOC_ENTRY);
		cd9660_susp_st(ST, node);
		if (last != NULL)
			TAILQ_INSERT_AFTER(&node->head, last, ST, rr_ll);
		else
			TAILQ_INSERT_HEAD(&node->head, ST, rr_ll);
		last = ST;
		susp_used += 4;
	}
	if (last != NULL)
		last->last_in_suf = 1;

	/* align to even size */
	node->susp_entry_size = ((susp_used + 1) >> 1) << 1;
	node->susp_entry_ce_length = ca_used;

	diskStructure.susp_continuation_area_size += ca_used;
	return 1;
}

/* See if a continuation entry is needed for each of the different types */
static int
cd9660_susp_handle_continuation(cd9660node *node)
{
	assert (node != NULL);

	/* Entry */
	if (cd9660_susp_handle_continuation_common(
		node,(int)(node->isoDirRecord->length[0])) < 0)
		return 0;

	return 1;
}

int
cd9660_susp_initialize_node(cd9660node *node)
{
	struct ISO_SUSP_ATTRIBUTES *temp;

	/*
	 * Requirements/notes:
	 * CE: is added for us where needed
	 * ST: not sure if it is even required, but if so, should be
	 *     handled by the CE code
	 * PD: isnt needed (though might be added for testing)
	 * SP: is stored ONLY on the . record of the root directory
	 * ES: not sure
	 */

	/* Check for root directory, add SP and ER if needed. */
	if (node->type & CD9660_TYPE_DOT) {
		if (node->parent == diskStructure.rootNode) {
			temp = cd9660node_susp_create_node(SUSP_TYPE_SUSP,
				SUSP_ENTRY_SUSP_SP, "SP", SUSP_LOC_DOT);
			cd9660_susp_sp(temp, node);

			/* Should be first entry. */
			TAILQ_INSERT_HEAD(&node->head, temp, rr_ll);
		}
	}
	return 1;
}

static void
cd9660_rrip_initialize_inode(cd9660node *node)
{
	struct ISO_SUSP_ATTRIBUTES *attr;

	/*
	 * Inode dependent values - this may change,
	 * but for now virtual files and directories do
	 * not have an inode structure
	 */

	if ((node->node != NULL) && (node->node->inode != NULL)) {
		/* PX - POSIX attributes */
		attr = cd9660node_susp_create_node(SUSP_TYPE_RRIP,
			SUSP_ENTRY_RRIP_PX, "PX", SUSP_LOC_ENTRY);
		cd9660node_rrip_px(attr, node->node);

		TAILQ_INSERT_TAIL(&node->head, attr, rr_ll);

		/* TF - timestamp */
		attr = cd9660node_susp_create_node(SUSP_TYPE_RRIP,
			SUSP_ENTRY_RRIP_TF, "TF", SUSP_LOC_ENTRY);
		cd9660node_rrip_tf(attr, node->node);
		TAILQ_INSERT_TAIL(&node->head, attr, rr_ll);

		/* SL - Symbolic link */
		/* ?????????? Dan - why is this here? */
		if (TAILQ_EMPTY(&node->cn_children) &&
		    node->node->inode != NULL &&
		    S_ISLNK(node->node->inode->st.st_mode))
			cd9660_createSL(node);

		/* PN - device number */
		if (node->node->inode != NULL &&
		    ((S_ISCHR(node->node->inode->st.st_mode) ||
		     S_ISBLK(node->node->inode->st.st_mode)))) {
			attr =
			    cd9660node_susp_create_node(SUSP_TYPE_RRIP,
				SUSP_ENTRY_RRIP_PN, "PN",
				SUSP_LOC_ENTRY);
			cd9660node_rrip_pn(attr, node->node);
			TAILQ_INSERT_TAIL(&node->head, attr, rr_ll);
		}
	}
}

int
cd9660_rrip_initialize_node(cd9660node *node, cd9660node *parent,
    cd9660node *grandparent)
{
	struct ISO_SUSP_ATTRIBUTES *current = NULL;

	assert(node != NULL);

	if (node->type & CD9660_TYPE_DOT) {
		/*
		 * Handle ER - should be the only entry to appear on
		 * a "." record
		 */
		if (node->parent == diskStructure.rootNode) {
			cd9660_susp_ER(node, 1, SUSP_RRIP_ER_EXT_ID,
				SUSP_RRIP_ER_EXT_DES, SUSP_RRIP_ER_EXT_SRC);
		}
		if (parent != NULL && parent->node != NULL &&
		    parent->node->inode != NULL) {
			/* PX - POSIX attributes */
			current = cd9660node_susp_create_node(SUSP_TYPE_RRIP,
				SUSP_ENTRY_RRIP_PX, "PX", SUSP_LOC_ENTRY);
			cd9660node_rrip_px(current, parent->node);
			TAILQ_INSERT_TAIL(&node->head, current, rr_ll);
		}
	} else if (node->type & CD9660_TYPE_DOTDOT) {
		if (grandparent != NULL && grandparent->node != NULL &&
		    grandparent->node->inode != NULL) {
			/* PX - POSIX attributes */
			current = cd9660node_susp_create_node(SUSP_TYPE_RRIP,
				SUSP_ENTRY_RRIP_PX, "PX", SUSP_LOC_ENTRY);
			cd9660node_rrip_px(current, grandparent->node);
			TAILQ_INSERT_TAIL(&node->head, current, rr_ll);
		}
	} else {
		cd9660_rrip_initialize_inode(node);

		/*
		 * Not every node needs a NM set - only if the name is
		 * actually different. IE: If a file is TEST -> TEST,
		 * no NM. test -> TEST, need a NM
		 *
		 * The rr_moved_dir needs to be assigned a NM record as well.
		 */
		if (node == diskStructure.rr_moved_dir) {
			cd9660_rrip_add_NM(node, RRIP_DEFAULT_MOVE_DIR_NAME);
		}
		else if ((node->node != NULL) &&
			((strlen(node->node->name) !=
			    (int)node->isoDirRecord->name_len[0]) ||
			(memcmp(node->node->name,node->isoDirRecord->name,
				(int) node->isoDirRecord->name_len[0]) != 0))) {
			cd9660_rrip_NM(node);
		}



		/* Rock ridge directory relocation code here. */

		/* First handle the CL for the placeholder file. */
		if (node->rr_relocated != NULL) {
			current = cd9660node_susp_create_node(SUSP_TYPE_RRIP,
				SUSP_ENTRY_RRIP_CL, "CL", SUSP_LOC_ENTRY);
			cd9660_rrip_CL(current, node);
			TAILQ_INSERT_TAIL(&node->head, current, rr_ll);
		}

		/* Handle RE*/
		if (node->rr_real_parent != NULL) {
			current = cd9660node_susp_create_node(SUSP_TYPE_RRIP,
				SUSP_ENTRY_RRIP_RE, "RE", SUSP_LOC_ENTRY);
			cd9660_rrip_RE(current,node);
			TAILQ_INSERT_TAIL(&node->head, current, rr_ll);

			/* Handle PL */
			current = cd9660node_susp_create_node(SUSP_TYPE_RRIP,
				SUSP_ENTRY_RRIP_PL, "PL", SUSP_LOC_DOTDOT);
			cd9660_rrip_PL(current,node->dot_dot_record);
			TAILQ_INSERT_TAIL(&node->dot_dot_record->head, current,
			    rr_ll);
		}
	}
	return 1;
}

struct ISO_SUSP_ATTRIBUTES*
cd9660node_susp_create_node(int susp_type, int entry_type, const char *type_id,
			    int write_loc)
{
	struct ISO_SUSP_ATTRIBUTES* temp;

	if ((temp = calloc(1, sizeof (struct ISO_SUSP_ATTRIBUTES))) == NULL) {
		CD9660_MEM_ALLOC_ERROR("cd9660node_susp_create_node");
		exit(1);
	}

	temp->susp_type = susp_type;
	temp->entry_type = entry_type;
	temp->last_in_suf = 0;
	/* Phase this out */
	temp->type_of[0] = type_id[0];
	temp->type_of[1] = type_id[1];
	temp->write_location = write_loc;

	/*
	 * Since the first four bytes is common, lets go ahead and
	 * set the type identifier, since we are passing that to this
	 * function anyhow.
	 */
	temp->attr.su_entry.SP.h.type[0] = type_id[0];
	temp->attr.su_entry.SP.h.type[1] = type_id[1];
	return temp;
}

int
cd9660_rrip_PL(struct ISO_SUSP_ATTRIBUTES* p, cd9660node *node __unused)
{
	p->attr.rr_entry.PL.h.length[0] = 12;
	p->attr.rr_entry.PL.h.version[0] = 1;
	return 1;
}

int
cd9660_rrip_CL(struct ISO_SUSP_ATTRIBUTES *p, cd9660node *node __unused)
{
	p->attr.rr_entry.CL.h.length[0] = 12;
	p->attr.rr_entry.CL.h.version[0] = 1;
	return 1;
}

int
cd9660_rrip_RE(struct ISO_SUSP_ATTRIBUTES *p, cd9660node *node __unused)
{
	p->attr.rr_entry.RE.h.length[0] = 0;
	p->attr.rr_entry.RE.h.version[0] = 1;
	return 1;
}

void
cd9660_createSL(cd9660node *node)
{
	struct ISO_SUSP_ATTRIBUTES* current;
	int path_count, dir_count, done, i, j, dir_copied;
	char temp_cr[255];
	char temp_sl[255]; /* used in copying continuation entry*/
	char* sl_ptr;

	sl_ptr = node->node->symlink;

	done = 0;
	path_count = 0;
	dir_count = 0;
	dir_copied = 0;
	current = cd9660node_susp_create_node(SUSP_TYPE_RRIP,
	    SUSP_ENTRY_RRIP_SL, "SL", SUSP_LOC_ENTRY);

	current->attr.rr_entry.SL.h.version[0] = 1;
	current->attr.rr_entry.SL.flags[0] = SL_FLAGS_NONE;

	if (*sl_ptr == '/') {
		temp_cr[0] = SL_FLAGS_ROOT;
		temp_cr[1] = 0;
		memcpy(current->attr.rr_entry.SL.component + path_count,
		    temp_cr, 2);
		path_count += 2;
		sl_ptr++;
	}

	for (i = 0; i < (dir_count + 2); i++)
		temp_cr[i] = '\0';

	while (!done) {
		while ((*sl_ptr != '/') && (*sl_ptr != '\0')) {
			dir_copied = 1;
			if (*sl_ptr == '.') {
				if ((*(sl_ptr + 1) == '/') || (*(sl_ptr + 1)
				     == '\0')) {
					temp_cr[0] = SL_FLAGS_CURRENT;
					sl_ptr++;
				} else if(*(sl_ptr + 1) == '.') {
					if ((*(sl_ptr + 2) == '/') ||
					    (*(sl_ptr + 2) == '\0')) {
						temp_cr[0] = SL_FLAGS_PARENT;
						sl_ptr += 2;
					}
				} else {
					temp_cr[dir_count+2] = *sl_ptr;
					sl_ptr++;
					dir_count++;
				}
			} else {
				temp_cr[dir_count + 2] = *sl_ptr;
				sl_ptr++;
				dir_count++;
			}
		}

		if ((path_count + dir_count) >= 249) {
			current->attr.rr_entry.SL.flags[0] |= SL_FLAGS_CONTINUE;

			j = 0;

			if (path_count <= 249) {
				while(j != (249 - path_count)) {
					temp_sl[j] = temp_cr[j];
					j++;
				}
				temp_sl[0] = SL_FLAGS_CONTINUE;
				temp_sl[1] = j - 2;
				memcpy(
				    current->attr.rr_entry.SL.component +
					path_count,
				    temp_sl, j);
			}

			path_count += j;
			current->attr.rr_entry.SL.h.length[0] = path_count + 5;
			TAILQ_INSERT_TAIL(&node->head, current, rr_ll);
			current= cd9660node_susp_create_node(SUSP_TYPE_RRIP,
			       SUSP_ENTRY_RRIP_SL, "SL", SUSP_LOC_ENTRY);
			current->attr.rr_entry.SL.h.version[0] = 1;
			current->attr.rr_entry.SL.flags[0] = SL_FLAGS_NONE;

			path_count = 0;

			if (dir_count > 2) {
				while (j != dir_count + 2) {
					current->attr.rr_entry.SL.component[
					    path_count + 2] = temp_cr[j];
					j++;
					path_count++;
				}
				current->attr.rr_entry.SL.component[1]
				    = path_count;
				path_count+= 2;
			} else {
				while(j != dir_count) {
					current->attr.rr_entry.SL.component[
					    path_count+2] = temp_cr[j];
					j++;
					path_count++;
				}
			}
		} else {
			if (dir_copied == 1) {
				temp_cr[1] = dir_count;
				memcpy(current->attr.rr_entry.SL.component +
					path_count,
				    temp_cr, dir_count + 2);
				path_count += dir_count + 2;
			}
		}

		if (*sl_ptr == '\0') {
			done = 1;
			current->attr.rr_entry.SL.h.length[0] = path_count + 5;
			TAILQ_INSERT_TAIL(&node->head, current, rr_ll);
		} else {
			sl_ptr++;
			dir_count = 0;
			dir_copied = 0;
			for(i = 0; i < 255; i++) {
				temp_cr[i] = '\0';
			}
		}
	}
}

int
cd9660node_rrip_px(struct ISO_SUSP_ATTRIBUTES *v, fsnode *pxinfo)
{
	v->attr.rr_entry.PX.h.length[0] = 44;
	v->attr.rr_entry.PX.h.version[0] = 1;
	cd9660_bothendian_dword(rrip_squash ?
	    /* turn on all R bits, and all X bits if one X bit is set */
	    (((pxinfo->inode->st.st_mode & 0111) ? 0555 : 0444) |
	    /* preserve original mode bits, except W, setugid, sticky */
	    pxinfo->inode->st.st_mode) & ~07222 : pxinfo->inode->st.st_mode,
	    v->attr.rr_entry.PX.mode);
	cd9660_bothendian_dword(pxinfo->inode->st.st_nlink,
	    v->attr.rr_entry.PX.links);
	cd9660_bothendian_dword(rrip_squash ? 0 : pxinfo->inode->st.st_uid,
	    v->attr.rr_entry.PX.uid);
	cd9660_bothendian_dword(rrip_squash ? 0 : pxinfo->inode->st.st_gid,
	    v->attr.rr_entry.PX.gid);
	cd9660_bothendian_dword(pxinfo->inode->serno,
	    v->attr.rr_entry.PX.serial);

	return 1;
}

int
cd9660node_rrip_pn(struct ISO_SUSP_ATTRIBUTES *pn_field, fsnode *fnode)
{
	pn_field->attr.rr_entry.PN.h.length[0] = 20;
	pn_field->attr.rr_entry.PN.h.version[0] = 1;

	if (sizeof (fnode->inode->st.st_rdev) > 32)
		cd9660_bothendian_dword((uint64_t)fnode->inode->st.st_rdev >> 32,
		    pn_field->attr.rr_entry.PN.high);
	else
		cd9660_bothendian_dword(0, pn_field->attr.rr_entry.PN.high);

	cd9660_bothendian_dword(fnode->inode->st.st_rdev & 0xffffffff,
		pn_field->attr.rr_entry.PN.low);
	return 1;
}

#if 0
int
cd9660node_rrip_nm(struct ISO_SUSP_ATTRIBUTES *p, cd9660node *file_node)
{
	int nm_length = strlen(file_node->isoDirRecord->name) + 5;
        p->attr.rr_entry.NM.h.type[0] = 'N';
	p->attr.rr_entry.NM.h.type[1] = 'M';
	snprintf(p->attr.rr_entry.NM.altname,
	    sizeof (p->attr.rr_entry.NM.altname),
	    "%s", file_node->isoDirRecord->name);
	p->attr.rr_entry.NM.h.length[0] = (unsigned char)nm_length;
	p->attr.rr_entry.NM.h.version[0] = (unsigned char)1;
	p->attr.rr_entry.NM.flags[0] = (unsigned char) NM_PARENT;
	return 1;
}
#endif

int
cd9660node_rrip_tf(struct ISO_SUSP_ATTRIBUTES *p, fsnode *_node)
{
	struct cd9660node_rrip_tf_data {
		ISO_SUSP_HEADER		 h;
		u_char flags		 [ISODCL ( 4, 4)];
#if 0
		u_char timestamp	 [ISODCL ( 5, 256)];
#else
		/* using short form */
		u_char ts_mtime		 [ISODCL ( 5, 11)];
		u_char ts_atime		 [ISODCL (12, 18)];
		u_char ts_ctime		 [ISODCL (19, 25)];
		u_char _ts_rest		 [ISODCL (26, 256)];
#endif
	} *tfp;

	/* memory alias */
	tfp = (struct cd9660node_rrip_tf_data *)(&(p->attr.rr_entry.TF));

	tfp->flags[0] = TF_MODIFY | TF_ACCESS | TF_ATTRIBUTES;
	tfp->h.length[0] = 4;
	tfp->h.version[0] = 1;

	/*
	 * Need to add creation time, backup time,
	 * expiration time, and effective time.
	 */

	cd9660_time_915(_node->inode->st.st_mtime, tfp->ts_mtime);
	tfp->h.length[0] += 7;

	cd9660_time_915(_node->inode->st.st_atime, tfp->ts_atime);
	tfp->h.length[0] += 7;

	cd9660_time_915(_node->inode->st.st_ctime, tfp->ts_ctime);
	tfp->h.length[0] += 7;
	return 1;
}

int
cd9660_susp_sp(struct ISO_SUSP_ATTRIBUTES *p, cd9660node *spinfo __unused)
{
	p->attr.su_entry.SP.h.length[0] = 7;
	p->attr.su_entry.SP.h.version[0] = 1;
	p->attr.su_entry.SP.check[0] = 0xBE;
	p->attr.su_entry.SP.check[1] = 0xEF;
	p->attr.su_entry.SP.len_skp[0] = 0;
	return 1;
}

int
cd9660_susp_st(struct ISO_SUSP_ATTRIBUTES *p, cd9660node *stinfo __unused)
{
	p->attr.su_entry.ST.h.type[0] = 'S';
	p->attr.su_entry.ST.h.type[1] = 'T';
	p->attr.su_entry.ST.h.length[0] = 4;
	p->attr.su_entry.ST.h.version[0] = 1;
	return 1;
}

int
cd9660_susp_ce(struct ISO_SUSP_ATTRIBUTES *p, cd9660node *spinfo __unused)
{
	p->attr.su_entry.CE.h.length[0] = 28;
	p->attr.su_entry.CE.h.version[0] = 1;
	/* Other attributes dont matter right now, will be updated later */
	return 1;
}

int
cd9660_susp_pd(struct ISO_SUSP_ATTRIBUTES *p __unused, int length __unused)
{
	return 1;
}

void
cd9660_rrip_add_NM(cd9660node *node, const char *name)
{
	int working,len;
	const char *p;
	struct ISO_SUSP_ATTRIBUTES *r;

	/*
	 * Each NM record has 254 byes to work with. This means that
	 * the name data itself only has 249 bytes to work with. So, a
	 * name with 251 characters would require two nm records.
	 */
	p = name;
	working = 1;
	while (working) {
		r = cd9660node_susp_create_node(SUSP_TYPE_RRIP,
		    SUSP_ENTRY_RRIP_NM, "NM", SUSP_LOC_ENTRY);
		r->attr.rr_entry.NM.h.version[0] = 1;
		r->attr.rr_entry.NM.flags[0] = RRIP_NM_FLAGS_NONE;
		len = strlen(p);

		if (len > 249) {
			len = 249;
			r->attr.rr_entry.NM.flags[0] = RRIP_NM_FLAGS_CONTINUE;
		} else {
			working = 0;
		}
		memcpy(r->attr.rr_entry.NM.altname, p, len);
		r->attr.rr_entry.NM.h.length[0] = 5 + len;

		TAILQ_INSERT_TAIL(&node->head, r, rr_ll);

		p += len;
	}
}

void
cd9660_rrip_NM(cd9660node *node)
{
	cd9660_rrip_add_NM(node, node->node->name);
}

struct ISO_SUSP_ATTRIBUTES*
cd9660_susp_ER(cd9660node *node,
	       u_char ext_version, const char* ext_id, const char* ext_des,
	       const char* ext_src)
{
	int l;
	struct ISO_SUSP_ATTRIBUTES *r;

	r = cd9660node_susp_create_node(SUSP_TYPE_SUSP,
			SUSP_ENTRY_SUSP_ER, "ER", SUSP_LOC_DOT);

	/* Fixed data is 8 bytes */
	r->attr.su_entry.ER.h.length[0] = 8;
	r->attr.su_entry.ER.h.version[0] = 1;

	r->attr.su_entry.ER.len_id[0] = (u_char)strlen(ext_id);
	r->attr.su_entry.ER.len_des[0] = (u_char)strlen(ext_des);
	r->attr.su_entry.ER.len_src[0] = (u_char)strlen(ext_src);

	l = r->attr.su_entry.ER.len_id[0] +
		r->attr.su_entry.ER.len_src[0] +
		r->attr.su_entry.ER.len_des[0];

	/* Everything must fit. */
	assert(l + r->attr.su_entry.ER.h.length[0] <= 254);

	r->attr.su_entry.ER.h.length[0] += (u_char)l;


	r->attr.su_entry.ER.ext_ver[0] = ext_version;
	memcpy(r->attr.su_entry.ER.ext_data, ext_id,
		(int)r->attr.su_entry.ER.len_id[0]);
	l = (int) r->attr.su_entry.ER.len_id[0];
	memcpy(r->attr.su_entry.ER.ext_data + l,ext_des,
		(int)r->attr.su_entry.ER.len_des[0]);

	l += (int)r->attr.su_entry.ER.len_des[0];
	memcpy(r->attr.su_entry.ER.ext_data + l,ext_src,
		(int)r->attr.su_entry.ER.len_src[0]);

	TAILQ_INSERT_TAIL(&node->head, r, rr_ll);
	return r;
}

struct ISO_SUSP_ATTRIBUTES*
cd9660_susp_ES(struct ISO_SUSP_ATTRIBUTES *last __unused, cd9660node *node __unused)
{
	return NULL;
}
@


1.21
log
@now, finally. (I still have headaches, and it's too warm.) the squash thing
does approximately the same as the mkisofs -r option; without it's -R tho
@
text
@d1 1
a1 2
/**	$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.20 2009/06/29 18:49:28 tg Exp $ */
/*	$NetBSD: iso9660_rrip.c,v 1.4 2006/12/18 21:03:29 christos Exp $	*/
d4 2
d48 2
a49 2
__RCSID("$NetBSD: iso9660_rrip.c,v 1.4 2006/12/18 21:03:29 christos Exp $");
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.20 2009/06/29 18:49:28 tg Exp $");
d249 2
a250 2
	int ca_used, susp_used, working;
	struct ISO_SUSP_ATTRIBUTES *temp, *last = NULL, *CE;
d252 1
d254 3
d261 1
a261 1
	susp_used = 0;
d264 2
d273 1
a273 1
		if (working >= 28) {
d276 9
a284 2
		} else if (working < 0)
			break;
d292 7
a298 3
		TAILQ_INSERT_BEFORE(temp, CE, rr_ll);
		susp_used += 28;

d300 1
a300 1
		for (temp = TAILQ_NEXT(CE, rr_ll); temp != NULL;
d306 15
d516 1
@


1.20
log
@fix miscommit, oops
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.19 2009/01/18 18:47:06 tg Exp $ */
d48 1
a48 1
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.19 2009/01/18 18:47:06 tg Exp $");
d657 5
a661 1
	cd9660_bothendian_dword(pxinfo->inode->st.st_mode,
d665 1
a665 1
	cd9660_bothendian_dword(rrip_squash_ugid ? 0 : pxinfo->inode->st.st_uid,
d667 1
a667 1
	cd9660_bothendian_dword(rrip_squash_ugid ? 0 : pxinfo->inode->st.st_gid,
@


1.19
log
@fix another violation of ECMA 119 (ISO 9660):
directory records must be a multiple of two octets; the system use area
needs to be padded with a NUL byte to make it so (shortcut: the stuff
_before_ the system use area is always even, so we “just” need to align
the SUSP stuff with a NUL byte if needed)

fixes the use of GNU GRUB 0.9x on our cd9660+RR images
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.18 2008/11/06 18:13:23 tg Exp $ */
d48 1
a48 1
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.18 2008/11/06 18:13:23 tg Exp $");
d661 1
a661 1
	cd9660_bothendian_dword(pxinfo->inode->st.st_uid,
d663 1
a663 1
	cd9660_bothendian_dword(pxinfo->inode->st.st_gid,
@


1.18
log
@assign virtual inode numbers just like the hard link count stuff in pax(1),
make sure that directories are hardlinked to their dot entries as well,
and use the serial numbers for the PX records
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.17 2008/11/04 00:29:37 tg Exp $ */
d48 1
a48 1
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.17 2008/11/04 00:29:37 tg Exp $");
d288 2
a289 1
	node->susp_entry_size = susp_used;
@


1.17
log
@fix the PL code, it was looking at node->rr_real_parent, but “node” in
the PL code is actually “node->dot_node” in the RE code, so we must
use node->parent->rr_real_parent to look at instead
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.16 2008/11/04 00:21:11 tg Exp $ */
d48 1
a48 1
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.16 2008/11/04 00:21:11 tg Exp $");
d664 1
a664 3
	/* XXX works only with 32-bit inode numbers */
	/* XXX maybe use a path cache like paxmirabilis? */
	cd9660_bothendian_dword(pxinfo->inode->st.st_ino,
@


1.16
log
@remove the damaged PL again, because the “broken” behaviour is back
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.15 2008/11/04 00:11:31 tg Exp $ */
d48 1
a48 1
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.15 2008/11/04 00:11:31 tg Exp $");
d234 1
a234 1
			if (node->rr_real_parent == NULL)
d237 1
a237 1
			    node->rr_real_parent->fileDataSector,
@


1.15
log
@you cannot just enter the same memory object into two TAILQs at once,
because the pointers are stored inside the object… duh! students!
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.14 2008/11/03 23:11:28 tg Exp $ */
d48 1
a48 1
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.14 2008/11/03 23:11:28 tg Exp $");
a463 4
			current = cd9660node_susp_create_node(SUSP_TYPE_RRIP,
				SUSP_ENTRY_RRIP_PL, "PL", SUSP_LOC_DOTDOT);
			cd9660_rrip_PL(current,node->dot_dot_record);
			TAILQ_INSERT_TAIL(&node->head, current, rr_ll);
@


1.14
log
@make PX entries conform to the standard
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.13 2008/11/03 22:44:55 tg Exp $ */
d48 1
a48 1
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.13 2008/11/03 22:44:55 tg Exp $");
d464 3
@


1.13
log
@bring back the nōnstandard PL entry into the moved directory record;
it seems to be needed by current implementations.

without, mc misbehaves (cannot enter the deep directory at all, rather
jumps to / out of a sudden), and traversal does not succeed:

tg@@bleu:/tmp $ find /mnt -ls
 40960    4 drwxr-xr-x    3 tg       wheel        2048 Nov  3 19:38 /mnt
 43008    4 drwxr-xr-x    3 tg       wheel        2048 Nov  3 19:38 /mnt/b
 45056    4 drwxr-xr-x    3 tg       wheel        2048 Nov  3 19:38 /mnt/b/c
 47104    4 drwxr-xr-x    3 tg       wheel        2048 Nov  3 19:38 /mnt/b/c/d
 49152    4 drwxr-xr-x    3 tg       wheel        2048 Nov  3 19:38 /mnt/b/c/d/e
 51200    4 drwxr-xr-x    3 tg       wheel        2048 Nov  3 19:38 /mnt/b/c/d/e/f
 53248    4 drwxr-xr-x    3 tg       wheel        2048 Nov  3 19:38 /mnt/b/c/d/e/f/g
 55296    4 drwxr-xr-x    3 tg       wheel        2048 Nov  3 19:38 /mnt/b/c/d/e/f/g/h
 59392    4 drwxr-xr-x    3 tg       wheel        2048 Nov  3 19:38 /mnt/b/c/d/e/f/g/h/i
 61440    4 drwxr-xr-x    2 tg       wheel        2048 Nov  3 19:38 /mnt/b/c/d/e/f/g/h/i/j
 61580    0 -rw-r--r--    1 tg       wheel           4 Nov  3 19:38 /mnt/b/c/d/e/f/g/h/i/j/k
tg@@bleu:/tmp $ find /mnt/.rr_moved -ls
 57344    4 drwxr-xr-x    3 tg       wheel        2048 Nov  3 19:38 /mnt/.rr_moved
 59392    4 drwxr-xr-x    3 tg       wheel        2048 Nov  3 19:38 /mnt/.rr_moved/i
 61440    4 drwxr-xr-x    2 tg       wheel        2048 Nov  3 19:38 /mnt/.rr_moved/i/j
 61580    0 -rw-r--r--    1 tg       wheel           4 Nov  3 19:38 /mnt/.rr_moved/i/j/k

with it, mc behaves more sanely and exactly the same as find:

tg@@bleu:/tmp $ find /mnt -ls
 40960    4 drwxr-xr-x    3 tg       wheel        2048 Nov  3 19:38 /mnt
 43008    4 drwxr-xr-x    3 tg       wheel        2048 Nov  3 19:38 /mnt/b
 45056    4 drwxr-xr-x    3 tg       wheel        2048 Nov  3 19:38 /mnt/b/c
 47104    4 drwxr-xr-x    3 tg       wheel        2048 Nov  3 19:38 /mnt/b/c/d
 49152    4 drwxr-xr-x    3 tg       wheel        2048 Nov  3 19:38 /mnt/b/c/d/e
 51200    4 drwxr-xr-x    3 tg       wheel        2048 Nov  3 19:38 /mnt/b/c/d/e/f
 53248    4 drwxr-xr-x    3 tg       wheel        2048 Nov  3 19:38 /mnt/b/c/d/e/f/g
 55296    4 drwxr-xr-x    3 tg       wheel        2048 Nov  3 19:38 /mnt/b/c/d/e/f/g/h
 59392    4 drwxr-xr-x    3 tg       wheel        2048 Nov  3 19:38 /mnt/b/c/d/e/f/g/h/i
 61440    4 drwxr-xr-x    2 tg       wheel        2048 Nov  3 19:38 /mnt/b/c/d/e/f/g/h/i/j
 61580    0 -rw-r--r--    1 tg       wheel           4 Nov  3 19:38 /mnt/b/c/d/e/f/g/h/i/j/k
 57344    4 drwxr-xr-x    3 tg       wheel        2048 Nov  3 19:38 /mnt/.rr_moved
 55296    4 drwxr-xr-x    3 tg       wheel        2048 Nov  3 19:38 /mnt/.rr_moved/i
 59392    4 drwxr-xr-x    3 tg       wheel        2048 Nov  3 19:38 /mnt/.rr_moved/i/i
 61440    4 drwxr-xr-x    2 tg       wheel        2048 Nov  3 19:38 /mnt/.rr_moved/i/i/j
 61580    0 -rw-r--r--    1 tg       wheel           4 Nov  3 19:38 /mnt/.rr_moved/i/i/j/k

I guess .rr_moved has to be hidden from RR thusly.
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.11 2008/11/03 21:26:48 tg Exp $ */
d48 1
a48 1
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.11 2008/11/03 21:26:48 tg Exp $");
d655 1
a655 1
	v->attr.rr_entry.PX.h.length[0] = 36;
d665 4
a669 1
	/* Ignoring the serial number for now */
@


1.12
log
@move SUSP entries from the root node to its dot node (in a somewhat
twisted implementation) because the root node entry is only 34 bytes
and thusly has no space for _any_ SUSP entries to exist

⇒ fixes TF and PX (timestamp and owner information) on the filesystem root
@
text
@d464 1
@


1.11
log
@Never, ever, believe comments such as this one:
                /* This will automatically insert at the appropriate location */
Hah! As if!
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.10 2008/11/03 20:54:55 tg Exp $ */
d48 1
a48 1
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.10 2008/11/03 20:54:55 tg Exp $");
d57 1
a57 1
    cd9660node *grandparent)
d65 5
d88 38
d137 3
a139 1
		if ((r = cd9660_susp_initialize(cn, node, parent)) < 0)
@


1.10
log
@revamp the RR_MOVED handling code for good:
• enable extra output #ifdef DEBUG, for discovering if there
  are duplicate SUSP entries
• as per IEEE P1282, the PL entry only belongs to the dotdot record
  of the moved directory, not to the entry of the moved directory
• new convenience function cd9660_name_iso_dir_record() to assist in
  renaming a struct _iso_directory_record_cd9660: zero out name,
  set name_len *AND* set record length! (also, better rounding than TNF)
• use cd9660_name_iso_dir_record in cd9660_populate_iso_dir_record
• use cd9660_name_iso_dir_record at the end of cd9660_rrip_move_directory
  to set the new name of the moved directory (otherwise, it would have
  been stuck with the wrong size)
• use cd9660_name_iso_dir_record too to retain the ORIGINAL name of the
  moved directory for the virtual file we create (otherwise, it would’ve
  been appended a dot and a “;1” version number)
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.9 2008/10/31 23:04:08 tg Exp $ */
d48 1
a48 1
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.9 2008/10/31 23:04:08 tg Exp $");
d207 3
a209 1
	/* printf("There are %i bytes to work with\n",working); */
a213 2
		if (working < 0)
			break;
d224 2
a225 1
		}
d233 1
a233 2
		/* This will automatically insert at the appropriate location */
		TAILQ_INSERT_TAIL(&node->head, CE, rr_ll);
@


1.9
log
@use calloc instead of malloc + memset
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.8 2008/10/31 22:55:17 tg Exp $ */
d48 1
a48 1
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.8 2008/10/31 22:55:17 tg Exp $");
d214 6
a219 4
		/*
		 * printf("SUSP Entry found, length is %i\n",
		 * CD9660_SUSP_ENTRY_SIZE(temp));
		 */
a418 1
			TAILQ_INSERT_TAIL(&node->head, current, rr_ll);
@


1.8
log
@better safe than sorry: bzero after malloc
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.7 2008/10/31 22:19:12 tg Exp $ */
d48 1
a48 1
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.7 2008/10/31 22:19:12 tg Exp $");
d429 1
a429 1
	if ((temp = malloc(sizeof(struct ISO_SUSP_ATTRIBUTES))) == NULL) {
a432 1
	memset(temp, '\0', sizeof (struct ISO_SUSP_ATTRIBUTES));
@


1.7
log
@fix Rock Ridge device node information: struct stat.st_rdev not st_dev…
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.6 2008/10/31 21:31:37 tg Exp $ */
d48 1
a48 1
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.6 2008/10/31 21:31:37 tg Exp $");
d433 1
@


1.6
log
@kill sprintf(3)
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.5 2008/10/31 20:56:49 tg Exp $ */
d48 1
a48 1
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.5 2008/10/31 20:56:49 tg Exp $");
d629 2
a630 2
	if (sizeof (fnode->inode->st.st_dev) > 32)
		cd9660_bothendian_dword((uint64_t)fnode->inode->st.st_dev >> 32,
d635 1
a635 1
	cd9660_bothendian_dword(fnode->inode->st.st_dev & 0xffffffff,
@


1.5
log
@… and fix a mis-order of structure entries in the very same code area,
determined by reading Rock Ridge (IEEE P1282 draft standard 1.12) PDF
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.4 2008/10/31 20:55:16 tg Exp $ */
d48 1
a48 1
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.4 2008/10/31 20:55:16 tg Exp $");
d647 3
a649 1
	sprintf(p->attr.rr_entry.NM.altname, "%s", file_node->isoDirRecord->name);
@


1.4
log
@work around a false positive in the sizeof code
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.3 2008/10/31 20:42:29 tg Exp $ */
d48 1
a48 1
__IDSTRING(mbsdid, "$MirOS: src/usr.sbin/makefs/cd9660/iso9660_rrip.c,v 1.3 2008/10/31 20:42:29 tg Exp $");
d665 2
a666 2
		u_char ts_atime		 [ISODCL ( 5, 11)];
		u_char ts_mtime		 [ISODCL (12, 18)];
d684 1
a684 1
	cd9660_time_915(_node->inode->st.st_atime, tfp->ts_atime);
d687 1
a687 1
	cd9660_time_915(_node->inode->st.st_mtime, tfp->ts_mtime);
@


1.3
log
@remove explicit casts to (unsigned char *) so that the sizeof stuff works
@
text
@d1 1
a1 1
/**	$MirOS$ */
d48 1
a48 1
__IDSTRING(mbsdid, "$MirOS$");
d658 20
a677 3
	p->attr.rr_entry.TF.flags[0] = TF_MODIFY | TF_ACCESS | TF_ATTRIBUTES;
	p->attr.rr_entry.TF.h.length[0] = 4;
	p->attr.rr_entry.TF.h.version[0] = 1;
d684 8
a691 11
	cd9660_time_915(_node->inode->st.st_atime,
	    p->attr.rr_entry.TF.timestamp);
	p->attr.rr_entry.TF.h.length[0] += 7;

	cd9660_time_915(_node->inode->st.st_mtime,
	    p->attr.rr_entry.TF.timestamp + 7);
	p->attr.rr_entry.TF.h.length[0] += 7;

	cd9660_time_915(_node->inode->st.st_ctime,
	    p->attr.rr_entry.TF.timestamp + 14);
	p->attr.rr_entry.TF.h.length[0] += 7;
@


1.2
log
@switch argument order of cd9660_time_8426 and cd9660_time_915 to
match the prototype of the other ISO 9660 data type functions
@
text
@d1 1
d48 1
d184 2
a185 3
				node->rr_relocated->fileDataSector,
				(unsigned char *)
				    t->attr.rr_entry.CL.dir_loc);
d192 2
a193 3
				node->rr_real_parent->fileDataSector,
				(unsigned char *)
				    t->attr.rr_entry.PL.dir_loc);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: iso9660_rrip.c,v 1.3 2005/10/30 03:10:28 dyoung Exp $	*/
d46 1
a46 1
__RCSID("$NetBSD: iso9660_rrip.c,v 1.3 2005/10/30 03:10:28 dyoung Exp $");
d452 1
a452 1
cd9660_rrip_PL(struct ISO_SUSP_ATTRIBUTES* p, cd9660node *node)
d460 1
a460 1
cd9660_rrip_CL(struct ISO_SUSP_ATTRIBUTES *p, cd9660node *node)
d468 1
a468 1
cd9660_rrip_RE(struct ISO_SUSP_ATTRIBUTES *p, cd9660node *node)
d667 2
a668 2
	cd9660_time_915(p->attr.rr_entry.TF.timestamp,
		_node->inode->st.st_atime);
d671 2
a672 2
	cd9660_time_915(p->attr.rr_entry.TF.timestamp + 7,
		_node->inode->st.st_mtime);
d675 2
a676 2
	cd9660_time_915(p->attr.rr_entry.TF.timestamp + 14,
		_node->inode->st.st_ctime);
d682 1
a682 1
cd9660_susp_sp(struct ISO_SUSP_ATTRIBUTES *p, cd9660node *spinfo)
d693 1
a693 1
cd9660_susp_st(struct ISO_SUSP_ATTRIBUTES *p, cd9660node *stinfo)
d703 1
a703 1
cd9660_susp_ce(struct ISO_SUSP_ATTRIBUTES *p, cd9660node *spinfo)
d712 1
a712 1
cd9660_susp_pd(struct ISO_SUSP_ATTRIBUTES *p, int length)
d804 1
a804 1
cd9660_susp_ES(struct ISO_SUSP_ATTRIBUTES *last, cd9660node *node)
@


1.1.3.1
log
@Time to hack on makefs, from TNF
@
text
@@


1.1.3.2
log
@Import NetBSD®-current (just after or at the 5.0 branch) makefs(8)
and subtree required to build it in MirBSD
@
text
@d1 1
a1 1
/*	$NetBSD: iso9660_rrip.c,v 1.4 2006/12/18 21:03:29 christos Exp $	*/
d46 1
a46 1
__RCSID("$NetBSD: iso9660_rrip.c,v 1.4 2006/12/18 21:03:29 christos Exp $");
d452 1
a452 1
cd9660_rrip_PL(struct ISO_SUSP_ATTRIBUTES* p, cd9660node *node __unused)
d460 1
a460 1
cd9660_rrip_CL(struct ISO_SUSP_ATTRIBUTES *p, cd9660node *node __unused)
d468 1
a468 1
cd9660_rrip_RE(struct ISO_SUSP_ATTRIBUTES *p, cd9660node *node __unused)
d682 1
a682 1
cd9660_susp_sp(struct ISO_SUSP_ATTRIBUTES *p, cd9660node *spinfo __unused)
d693 1
a693 1
cd9660_susp_st(struct ISO_SUSP_ATTRIBUTES *p, cd9660node *stinfo __unused)
d703 1
a703 1
cd9660_susp_ce(struct ISO_SUSP_ATTRIBUTES *p, cd9660node *spinfo __unused)
d712 1
a712 1
cd9660_susp_pd(struct ISO_SUSP_ATTRIBUTES *p __unused, int length __unused)
d804 1
a804 1
cd9660_susp_ES(struct ISO_SUSP_ATTRIBUTES *last __unused, cd9660node *node __unused)
@


1.1.3.3
log
@import newer makefs from TNF (with Acorn Archimedes support)
@
text
@d1 1
a1 1
/*	$NetBSD: iso9660_rrip.c,v 1.8 2009/01/10 22:06:29 bjh21 Exp $	*/
d46 1
a46 1
__RCSID("$NetBSD: iso9660_rrip.c,v 1.8 2009/01/10 22:06:29 bjh21 Exp $");
d203 2
a204 2
	int ca_used, susp_used, susp_used_pre_ce, working;
	struct ISO_SUSP_ATTRIBUTES *temp, *pre_ce, *last, *CE, *ST;
a205 1
	pre_ce = last = NULL;
a206 3
	if (node->su_tail_size > 0)
		/* Allow 4 bytes for "ST" record. */
		working -= node->su_tail_size + 4;
d209 1
a209 1
	susp_used_pre_ce = susp_used = 0;
d219 1
a219 1
		if (working >= 0) {
a222 8
		if (working >= 28) {
			/*
			 * Remember the last entry after which we
			 * could insert a "CE" entry.
			 */
			pre_ce = last;
			susp_used_pre_ce = susp_used;
		}
d231 3
a233 6
		if (pre_ce != NULL)
			TAILQ_INSERT_AFTER(&node->head, pre_ce, CE, rr_ll);
		else
			TAILQ_INSERT_HEAD(&node->head, CE, rr_ll);
		last = CE;
		susp_used = susp_used_pre_ce + 28;
d235 1
a235 1
		for (temp = TAILQ_NEXT(last, rr_ll); temp != NULL;
a240 15
	/* An ST entry is needed */
	if (node->su_tail_size > 0) {
		ST = cd9660node_susp_create_node(SUSP_TYPE_SUSP,
		    SUSP_ENTRY_SUSP_ST, "ST", SUSP_LOC_ENTRY);
		cd9660_susp_st(ST, node);
		if (last != NULL)
			TAILQ_INSERT_AFTER(&node->head, last, ST, rr_ll);
		else
			TAILQ_INSERT_HEAD(&node->head, ST, rr_ll);
		last = ST;
		susp_used += 4;
	}
	if (last != NULL)
		last->last_in_suf = 1;

a435 1
	temp->last_in_suf = 0;
@


