head	1.22;
access;
symbols
	MIRBSD_10:1.17.0.2
	MIRBSD_10_BASE:1.17
	MIRBSD_9_BASE:1.7
	MIRBSD_8:1.4.0.2
	MIRBSD_8_BASE:1.4
	cvs-200507211800:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2011.11.21.20.49.39;	author tg;	state Exp;
branches;
next	1.21;
commitid	1004ECAB97840AE2593;

1.21
date	2011.11.20.22.02.42;	author tg;	state Exp;
branches;
next	1.20;
commitid	1004EC9791917D34AD7;

1.20
date	2010.07.03.18.33.57;	author tg;	state Exp;
branches;
next	1.19;
commitid	1004C2F828601C66EBF;

1.19
date	2009.12.24.11.41.23;	author tg;	state Exp;
branches;
next	1.18;
commitid	1004B3351E651CE01AF;

1.18
date	2009.08.01.13.55.30;	author tg;	state Exp;
branches;
next	1.17;
commitid	1004A7449484CB467F0;

1.17
date	2007.08.17.15.03.01;	author tg;	state Exp;
branches;
next	1.16;
commitid	10046C5B8BB4880962E;

1.16
date	2007.08.16.10.38.29;	author tg;	state Exp;
branches;
next	1.15;
commitid	10046C428EB50B824CD;

1.15
date	2007.08.10.23.56.12;	author tg;	state Exp;
branches;
next	1.14;
commitid	10046BCFACD1DE927E3;

1.14
date	2007.08.10.23.52.24;	author tg;	state Exp;
branches;
next	1.13;
commitid	10046BCFA4E557A719B;

1.13
date	2007.08.10.23.43.14;	author tg;	state Exp;
branches;
next	1.12;
commitid	10046BCF81D414AEAC7;

1.12
date	2007.08.10.23.04.42;	author tg;	state Exp;
branches;
next	1.11;
commitid	10046BCEF2137274E70;

1.11
date	2007.08.10.23.01.02;	author tg;	state Exp;
branches;
next	1.10;
commitid	10046BCEE3D44DE3A31;

1.10
date	2007.07.05.22.32.25;	author tg;	state Exp;
branches;
next	1.9;
commitid	100468D718636DA3635;

1.9
date	2007.05.14.22.06.51;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004648DD5A2275F914;

1.8
date	2006.08.28.13.15.43;	author tg;	state Exp;
branches;
next	1.7;
commitid	10044F2EC8D774FC8BB;

1.7
date	2006.06.09.20.58.09;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004489E0F23F902B89;

1.6
date	2006.05.29.23.38.31;	author tg;	state Exp;
branches;
next	1.5;
commitid	100447B85B916A0A64A;

1.5
date	2006.05.09.08.57.58;	author tg;	state Exp;
branches;
next	1.4;
commitid	100446059A96502C280;

1.4
date	2005.12.04.15.02.31;	author tg;	state Exp;
branches;
next	1.3;
commitid	3de943930506ef14;

1.3
date	2005.10.27.11.58.39;	author tg;	state Exp;
branches;
next	1.2;
commitid	77604360c0d42ca3;

1.2
date	2005.03.13.19.17.21;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.31.06;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.31.06;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.07.21.21.03.50;	author tg;	state Exp;
branches;
next	;
commitid	560042e0092f571e;


desc
@@


1.22
log
@refactoro
@
text
@/*	$OpenBSD: ntp.c,v 1.27 2004/10/26 09:48:59 henning Exp $	*/

/*
 * Copyright (c) 2002, 2004, 2005, 2006, 2007, 2009, 2011
 *	Thorsten Glaser <tg@@mirbsd.org>
 * Copyright (c) 1996, 1997 by N.M. Maclaren. All rights reserved.
 * Copyright (c) 1996, 1997 by University of Cambridge. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the author nor the university may be used to
 *    endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <float.h>
#include <inttypes.h>
#include <limits.h>
#include <math.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "rdate.h"

__RCSID("$MirOS: src/usr.sbin/rdate/ntp.c,v 1.21 2011/11/20 22:02:42 tg Exp $");

/*
 * NTP definitions.  Note that these assume 8-bit bytes - sigh.  There
 * is little point in parameterising everything, as it is neither
 * feasible nor useful.  It would be very useful if more fields could
 * be defined as unspecified.  The NTP packet-handling routines
 * contain a lot of extra assumptions.
 */

#define NTP_SCALE  4294967296.0		/* 2^32, of course! */

#define NTP_MODE_CLIENT       3		/* NTP client mode */
#define NTP_MODE_SERVER       4		/* NTP server mode */
#define NTP_VERSION           4		/* The current version */
#define NTP_VERSION_MIN       1		/* The minum valid version */
#define NTP_VERSION_MAX       4		/* The maximum valid version */
#define NTP_STRATUM_MAX      14		/* The maximum valid stratum */
#define NTP_INSANITY     3600.0		/* Errors beyond this are hopeless */

#define NTP_PACKET_MIN       48		/* Without authentication */
#define NTP_PACKET_MAX       68		/* With authentication (ignored) */

#define NTP_DISP_FIELD        8		/* Offset of dispersion field */
#define NTP_REFERENCE        16		/* Offset of reference timestamp */
#define NTP_ORIGINATE        24		/* Offset of originate timestamp */
#define NTP_RECEIVE          32		/* Offset of receive timestamp */
#define NTP_TRANSMIT         40		/* Offset of transmit timestamp */

#define STATUS_NOWARNING      0		/* No Leap Indicator */
#define STATUS_LEAPHIGH       1		/* Last Minute Has 61 Seconds */
#define STATUS_LEAPLOW        2		/* Last Minute Has 59 Seconds */
#define STATUS_ALARM          3		/* Server Clock Not Synchronized */

#define MAX_QUERIES         25
#define MAX_DELAY           15

#define MILLION_L    1000000l		/* For conversion to/from timeval */
#define MILLION_D       1.0e6		/* Must be equal to MILLION_L */

struct ntp_data {
	double		receive;
	double		transmit;
	double		current;
	double		originate;
	u_int64_t	xmitck;
	u_int64_t	recvck;
	u_int32_t	refid;
	u_char		status;
	u_char		version;
	u_char		mode;
	u_char		stratum;
};

static int sync_ntp(int, const struct sockaddr *, double *, double *, int);
static int write_packet(int, struct ntp_data *, int);
static int read_packet(int, struct ntp_data *, double *, double *);
static void unpack_ntp(struct ntp_data *, u_char *);
static void create_timeval(double, struct timeval *, struct timeval *);
static void debug_packet(const struct ntp_data *);
static double dabs(double);

static double
dabs(double v)
{
	return (v < 0 ? -v : v);
}

void
ntp_client(const char *hostname, int family, struct timeval *new,
    struct timeval *adjust, int sport, int nversion)
{
	struct addrinfo hints, *res0, *res;
	double offset = 0, error = 0;
	int accepts = 0, ret, s, ierror;
	union {
		struct sockaddr *s_sa;
		struct sockaddr_in *s_in;
		struct sockaddr_in6 *s_in6;
	} sun;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = family;
	hints.ai_socktype = SOCK_DGRAM;
	ierror = getaddrinfo(hostname, "ntp", &hints, &res0);
	if (ierror) {
		errx(1, "%s: %s", hostname, gai_strerror(ierror));
		/*NOTREACHED*/
	}

	s = -1;
	for (res = res0; res; res = res->ai_next) {
		if (sport) {
			sun.s_sa = res->ai_addr;
			switch (sun.s_sa->sa_family) {
			case AF_INET:
				sun.s_in->sin_port = htons(sport);
				break;
			case AF_INET6:
				sun.s_in6->sin6_port = htons(sport);
				break;
			}
		}

		if (debug)
			fprintf(stderr, "Remote IP:   %s\n",
			    log_sockaddr(res->ai_addr));

		s = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
		if (s < 0) {
			if (debug)
				perror("Skipped:     socket");
			continue;
		}

		ret = sync_ntp(s, res->ai_addr, &offset, &error, nversion);
		if (ret < 0) {
			if (debug)
				fprintf(stderr, "Skipped:     try the next address\n");
			close(s);
			s = -1;
			continue;
		}

		accepts++;
		break;
	}
	freeaddrinfo(res0);

	if (debug)
		fprintf(stderr, "Correction:  %.6f +/- %.6f\n", offset, error);

	if (accepts < 1)
		errx(1, "Unable to get a reasonable time estimate");

	create_timeval(offset, new, adjust);
}

int
sync_ntp(int fd, const struct sockaddr *peer, double *offset, double *error,
    int nver)
{
	int attempts = 0, accepts = 0, rejects = 0;
	int delay = MAX_DELAY, ret;
	double deadline;
	double a, b, x = 0, y = 0;
	double minerr = 0.1;		/* Maximum ignorable variation */
	struct ntp_data data;

	deadline = gettime() + delay;
	*offset = 0.0;
	*error = NTP_INSANITY;

	if (connect(fd, peer, SA_LEN(peer)) < 0) {
		warn("Failed to connect to server");
		return (-1);
	}

	while (accepts < MAX_QUERIES && attempts < 2 * MAX_QUERIES) {
		memset(&data, 0, sizeof(data));

		if (gettime() > deadline) {
			warnx("Not enough valid responses received in time");
			return (-1);
		}

		if (write_packet(fd, &data, nver) < 0)
			return (-1);

		ret = read_packet(fd, &data, &x, &y);
		if (debug > 1)
			debug_packet(&data);

		if (ret < 0)
			return (-1);
		else if (ret > 0) {
			if (debug == 1)
				debug_packet(&data);
			if (++rejects > MAX_QUERIES) {
				warnx("Too many bad or lost packets");
				return (-1);
			} else
				continue;
		} else
			++accepts;

		if (debug)
			fprintf(stderr, "Offset:      %.6f +/- %.6f\n", x, y);

		if ((a = x - *offset) < 0.0)
			a = -a;
		if (accepts <= 1)
			a = 0.0;
		b = *error + y;
		if (y < *error) {
			*offset = x;
			*error = y;
		}

		if (debug)
			fprintf(stderr, "Best:        %.6f +/- %.6f\n", *offset,
			    *error);

		if (a > b) {
			warnx("Inconsistent times received from NTP server");
			return (-1);
		}

		if (*error <= minerr)
			break;
	}

	return (accepts);
}

/* Send out NTP packet. */
int
write_packet(int fd, struct ntp_data *data, int nver)
{
	u_char	packet[NTP_PACKET_MIN];
	ssize_t	length;

	memset(packet, 0, sizeof(packet));

	packet[0] = ((nver ? nver : NTP_VERSION) << 3) | (NTP_MODE_CLIENT);

	data->xmitck = (u_int64_t)arc4random() << 32 | arc4random();

	/*
	 * Send out a random 64-bit number as our transmit time.  The NTP
	 * server will copy said number into the originate field on the
	 * response that it sends us.  This is totally legal per the SNTP spec.
	 *
	 * The impact of this is two fold: we no longer send out the current
	 * system time for the world to see (which may aid an attacker), and
	 * it gives us a (not very secure) way of knowing that we're not
	 * getting spoofed by an attacker that can't capture our traffic
	 * but can spoof packets from the NTP server we're communicating with.
	 *
	 * No endian concerns here.  Since we're running as a strict
	 * unicast client, we don't have to worry about anyone else finding
	 * the transmit field intelligible.
	 */

	memcpy(packet + NTP_TRANSMIT, &data->xmitck, sizeof (u_int64_t));

	data->originate = gettime();

	length = write(fd, packet, sizeof(packet));

	if (length != sizeof(packet)) {
		warn("Unable to send NTP packet to server");
		return (-1);
	}

	return (0);
}

/*
 * Check the packet and work out the offset and optionally the error.
 * Note that this contains more checking than xntp does. Return 0 for
 * success, 1 for failure. Note that it must not change its arguments
 * if it fails.
 */
int
read_packet(int fd, struct ntp_data *data, double *off, double *error)
{
	u_char	receive[NTP_PACKET_MAX];
	struct	timeval tv;
	double	x, y;
	int	length, r;
	fd_set	*rfds;
	static int nosync = 0;

	rfds = calloc(howmany(fd + 1, NFDBITS), sizeof(fd_mask));
	if (rfds == NULL)
		err(1, "calloc");

	FD_SET(fd, rfds);

retry:
	tv.tv_sec = 0;
	tv.tv_usec = 1000000 * MAX_DELAY / MAX_QUERIES;

	r = select(fd + 1, rfds, NULL, NULL, &tv);

	if (r < 0) {
		if (errno == EINTR)
			goto retry;
		else
			warn("select");

		free(rfds);
		return (r);
	}

	if (r != 1 || !FD_ISSET(fd, rfds)) {
		free(rfds);
		return (1);
	}

	free(rfds);

	length = read(fd, receive, NTP_PACKET_MAX);

	if (length < 0) {
		warn("Unable to receive NTP packet from server");
		return (-1);
	}

	if (length < NTP_PACKET_MIN || length > NTP_PACKET_MAX) {
		warnx("Invalid NTP packet size, packet rejected");
		return (1);
	}

	unpack_ntp(data, receive);

	if (data->recvck != data->xmitck) {
		warnx("Invalid cookie received, packet rejected");
		return (1);
	}

	if (data->version < NTP_VERSION_MIN ||
	    data->version > NTP_VERSION_MAX) {
		warnx("Received NTP version %u, need %u or lower",
		    data->version, NTP_VERSION);
		return (1);
	}

	if (data->mode != NTP_MODE_SERVER) {
		warnx("Invalid NTP server mode, packet rejected");
		return (1);
	}

	if (data->stratum > NTP_STRATUM_MAX) {
		warnx("Invalid stratum received, packet rejected");
		return (1);
	}

	if (data->transmit == 0.0) {
		warnx("Server clock invalid, packet rejected");
		return (1);
	}

	if (!nosync && (data->status == 3)) {
		warnx("Alarm condition - server not synched yet?");
		nosync = 1;
	}

	x = data->receive - data->originate;
	y = data->transmit - data->current;

	*off = (x + y) / 2;
	*error = dabs(x - y);

	x = dabs((data->current - data->originate) / 2);

	if (x > *error)
		*error = x;

	return (0);
}

/*
 * Unpack the essential data from an NTP packet, bypassing struct
 * layout and endian problems.  Note that it ignores fields irrelevant
 * to SNTP.
 */
void
unpack_ntp(struct ntp_data *data, u_char *packet)
{
	int32_t i;
	double d;

	data->current = gettime();

	data->status = (packet[0] >> 6);
	data->version = (packet[0] >> 3) & 0x07;
	data->mode = packet[0] & 0x07;
	data->stratum = packet[1];

	memcpy(&data->refid, packet + 12, 4);
	data->refid = ntohl(data->refid);

	for (i = 0, d = 0.0; i < 8; ++i)
	    d = 256.0*d+packet[NTP_RECEIVE+i];

	data->receive = d / NTP_SCALE;

	for (i = 0, d = 0.0; i < 8; ++i)
	    d = 256.0*d+packet[NTP_TRANSMIT+i];

	data->transmit = d / NTP_SCALE;

	/* See write_packet for why this isn't an endian problem. */
	memcpy(&data->recvck, packet + NTP_ORIGINATE, sizeof (u_int64_t));
}

/*
 * Change offset into current UTC time. This is portable, even if
 * struct timeval uses an unsigned long for tv_sec.
 */
void
create_timeval(double difference, struct timeval *new, struct timeval *adjust)
{
	struct timeval old;
	long n;

	/* Start by converting to timeval format. Note that we have to
	 * cater for negative, unsigned values. */
	if ((n = (long) difference) > difference)
		--n;
	adjust->tv_sec = n;
	adjust->tv_usec = (long) (MILLION_D * (difference-n));
	errno = 0;
	if (gettimeofday(&old, NULL))
		err(1, "Could not get local time of day");
	new->tv_sec = old.tv_sec + adjust->tv_sec;
	new->tv_usec = (n = (long) old.tv_usec + (long) adjust->tv_usec);

	if (n < 0) {
		new->tv_usec += MILLION_L;
		--new->tv_sec;
	} else if (n >= MILLION_L) {
		new->tv_usec -= MILLION_L;
		++new->tv_sec;
	}
}

void
debug_packet(const struct ntp_data *data)
{
	printf("status:      %u\n", data->status);
	printf("version:     %u\n", data->version);
	printf("mode:        %u\n", data->mode);
	printf("stratum:     %u\n", data->stratum);
	printf("reference:   0x%08X (%d.%d.%d.%d)\n",
	    data->refid,
	    data->refid >> 24, (data->refid >> 16) & 0xFF,
	    (data->refid >> 8) & 0xFF, data->refid & 0xFF);
	printf("originate:   %f\n", data->originate);
	printf("receive:     %f\n", data->receive);
	printf("transmit:    %f\n", data->transmit);
	printf("current:     %f\n", data->current);
	printf("xmitck:      0x%0llX\n", data->xmitck);
	printf("recvck:      0x%0llX\n", data->recvck);
	printf("Delay:       %f\n", (data->current - data->originate) -
	    (data->transmit - data->receive));
}

#ifndef SYSKERN_MIRTIME_H
/*
 * Converts a time_t measured in kernel ticks into POSIX time_t
 * using leap second information stored in /etc/localtime or an
 * equivalent indicator (e.g. the TZ environment variable).
 * If the kernel time is already measured POSIXly brok^Wcorrect
 * and a POSIX conformant time zone is set, this is a no-op.
 * Algorithm partially from Dan J. Bernstein.
 */
time_t
timet2posix(time_t kerneltick)
{
	struct tm *tm;
	int64_t day;
	int x, y, sec;

	tm = localtime(&kerneltick);

	/* get the seconds out first */
	sec = tm->tm_sec + 60 * tm->tm_min + 3600 * tm->tm_hour -
	    tm->tm_gmtoff;

	/* pull the year; adjust for year 0 not existing */
	if ((day = tm->tm_year + 1900LL) < 0)
		++day;

	/* split year into y(ear in Gregorian Period) and convenient day */
	y = day % 400;
	day /= 400;
	day *= 146097;
	day -= 678882;
	/* add day of month */
	day += tm->tm_mday;

	/* normalise seconds into days */
	while (sec < 0) {
		--day;
		sec += 86400;
	}
	while (sec > 86400) {
		++day;
		sec -= 86400;
	}

	/* assign x the month and normalise into years */
	x = tm->tm_mon;
	while (x < 0) {
		--y;
		x += 12;
	}
	y += x / 12;
	x %= 12;

	/* calculate x as month since march, adjust year for it */
	if (x < 2) {
		x += 10;
		--y;
	} else
		x -= 2;

	/* add length of month since march by fixed-point arithmetic */
	day += (306 * x + 5) / 10;

	/* normalise 400-year cycles again */
	while (y < 0) {
		day -= 146097;
		y += 400;
	}
	day += 146097 * (y / 400);
	y %= 400;

	/* add by year, 4 years, 100 years, 400 years */
	day += 365 * (y % 4);
	y /= 4;
	day += 1461 * (y % 25);
	day += 36524 * (y / 25);

	/* convert to POSIX timestamp */
	day -= 40587;
	day *= 86400;
	day += sec > 86399 ? 86399 : sec;
	return (day);
}
#endif
@


1.21
log
@convert to MirTime API
@
text
@d56 1
a56 1
__RCSID("$MirOS: src/usr.sbin/rdate/ntp.c,v 1.20 2010/07/03 18:33:57 tg Exp $");
a65 1
#define JAN_1970   2208988800.0		/* 1970 - 1900 in seconds */
a113 1
static double current_time(void);
a117 4
#ifndef SYSKERN_MIRTIME_H
time_t timet2posix(time_t);
#endif

d205 1
a205 1
	deadline = current_time() + JAN_1970 + delay;
d217 1
a217 1
		if ((current_time() + JAN_1970) > deadline) {
d302 1
a302 1
	data->originate = current_time() + JAN_1970;
d430 1
a430 1
	data->current = current_time() + JAN_1970;
a454 17
 * Get the current time in POSIX notation
 */
static double
current_time(void)
{
	register double d;
	struct timeval tv;

	if (gettimeofday(&tv, NULL))
		err(1, "Could not get local time of day");
	d = tv.tv_usec;
	d /= 1000000;
	d += timet2posix(tv.tv_sec);
	return (d);
}

/*
@


1.20
log
@• put log_sockaddr() into a shared file (XXX share more rdate⇐⇒ntpd)
• make rdate -d output the destination IP sending packets to
@
text
@d4 2
a5 1
 * Copyright (c) 2002, 2004, 2005, 2006, 2007, 2009 by Thorsten Glaser.
a34 3
#if defined(MirBSD) && (MirBSD> 0x09AC)
#include <sys/taitime.h>
#endif
d44 1
d56 1
a56 1
__RCSID("$MirOS: src/usr.sbin/rdate/ntp.c,v 1.19 2009/12/24 11:41:23 tg Exp $");
d115 1
a115 1
static double current_time(double);
d120 4
d211 1
a211 1
	deadline = current_time(JAN_1970) + delay;
d223 1
a223 1
		if (current_time(JAN_1970) > deadline) {
d308 1
a308 1
	data->originate = current_time(JAN_1970);
d436 1
a436 1
	data->current = current_time(JAN_1970);
d461 1
a461 2
 * Get the current UTC time in seconds since the Epoch plus an offset
 * (usually the time from the beginning of the century to the Epoch)
d463 2
a464 2
double
current_time(double offset)
d466 2
a467 1
	struct timeval current;
d469 1
a469 1
	if (gettimeofday(&current, NULL))
d471 4
a474 2

	return (offset + tick2utc(current.tv_sec) + 1.0e-6 * current.tv_usec);
d528 85
@


1.19
log
@• calculate and display the delay as well
• errors are absolute values
• indent output properly
@
text
@d57 1
a57 1
__RCSID("$MirOS: src/usr.sbin/rdate/ntp.c,v 1.18 2009/08/01 13:55:30 tg Exp $");
a150 4
		s = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
		if (s < 0)
			continue;

d163 11
d177 1
a177 1
				fprintf(stderr, "try the next address\n");
@


1.18
log
@fix -Wall -Wextra from:
gcc version 4.5.0 20090718 (experimental) [trunk revision 149777] (Debian 20090718-1)

they are almost to be not fired, but… shut up gcc
@
text
@d57 1
a57 1
__RCSID("$MirOS: src/usr.sbin/rdate/ntp.c,v 1.17 2007/08/17 15:03:01 tg Exp $");
d119 7
d182 1
a182 1
		fprintf(stderr, "Correction: %.6f +/- %.6f\n", offset, error);
d239 1
a239 1
			fprintf(stderr, "Offset: %.6f +/- %.6f\n", x, y);
d252 1
a252 1
			fprintf(stderr, "Best: %.6f +/- %.6f\n", *offset,
d405 1
a405 1
	*error = x - y;
d407 1
a407 1
	x = (data->current - data->originate) / 2;
d513 2
@


1.17
log
@fix endianness issues
@
text
@d4 1
a4 1
 * Copyright (c) 2002, 2004, 2005, 2006, 2007 by Thorsten Glaser.
d57 1
a57 1
__RCSID("$MirOS: src/usr.sbin/rdate/ntp.c,v 1.16 2007/08/16 10:38:29 tg Exp $");
d125 1
a125 1
	double offset, error;
d190 1
a190 1
	double a, b, x, y;
@


1.16
log
@• add option -3 to use (S)NTPv3 – we just change the version field for now,
  no idea if that’s ok with the RFC, but it WFM
• fix displaying of IPv4-address-decoded refid
@
text
@d57 1
a57 1
__RCSID("$MirOS: src/usr.sbin/rdate/ntp.c,v 1.15 2007/08/10 23:56:12 tg Exp $");
d427 1
d497 1
a497 1
	    ntohl(data->refid),
@


1.15
log
@fix portability: <sys/taitime.h> is MirOS-only
@
text
@d57 1
a57 1
__RCSID("$MirOS: src/usr.sbin/rdate/ntp.c,v 1.14 2007/08/10 23:52:24 tg Exp $");
d112 2
a113 2
static int sync_ntp(int, const struct sockaddr *, double *, double *);
static int write_packet(int, struct ntp_data *);
d122 1
a122 1
    struct timeval *adjust, int sport)
d160 1
a160 1
		ret = sync_ntp(s, res->ai_addr, &offset, &error);
d184 2
a185 1
sync_ntp(int fd, const struct sockaddr *peer, double *offset, double *error)
d211 1
a211 1
		if (write_packet(fd, &data) < 0)
d262 1
a262 1
write_packet(int fd, struct ntp_data *data)
d269 1
a269 1
	packet[0] = (NTP_VERSION << 3) | (NTP_MODE_CLIENT);
d426 1
a426 2
	memcpy(&i, packet + 12, 4);
	data->refid = ntohl(i);
d495 2
a496 1
	printf("reference:   0x%08X (%d.%d.%d.%d)\n", data->refid,
@


1.14
log
@told ya it needs a .h file
@
text
@d34 1
d36 1
d57 1
a57 1
__RCSID("$MirOS: src/usr.sbin/rdate/ntp.c,v 1.13 2007/08/10 23:43:14 tg Exp $");
@


1.13
log
@add support for debug-outputting the refid
@
text
@d53 1
a53 1
__RCSID("$MirOS: src/usr.sbin/rdate/ntp.c,v 1.12 2007/08/10 23:04:42 tg Exp $");
d55 1
a55 19
/* This macro is not implemented on all operating systems */
#ifndef	SA_LEN
#define	SA_LEN(x)	(((x)->sa_family == AF_INET6) ? \
			    sizeof(struct sockaddr_in6) : \
			    (((x)->sa_family == AF_INET) ? \
				sizeof(struct sockaddr_in) : \
				sizeof(struct sockaddr)))
#endif

#ifdef EXT_A4R
extern u_int32_t arc4random(void);
#endif

#ifdef __MirBSD__
#define tick2utc(tv)	tai2utc(timet2tai(tv))
#else
/* from ntpleaps.c */
extern time_t tick2utc(time_t);
#endif
d110 6
a115 8
void	ntp_client(const char *, int, struct timeval *, struct timeval *, int);
int	sync_ntp(int, const struct sockaddr *, double *, double *);
int	write_packet(int, struct ntp_data *);
int	read_packet(int, struct ntp_data *, double *, double *);
void	unpack_ntp(struct ntp_data *, u_char *);
double	current_time(double);
void	create_timeval(double, struct timeval *, struct timeval *);

a117 2
extern int debug;

@


1.12
log
@caste alignment; bug from obsd only this time
@
text
@d53 1
a53 1
__RCSID("$MirOS: src/usr.sbin/rdate/ntp.c,v 1.11 2007/08/10 23:01:02 tg Exp $");
a114 4
	u_char		status;
	u_char		version;
	u_char		mode;
	u_char		stratum;
a117 3
	u_int64_t	recvck;

	/* Local State */
d120 6
d435 1
a435 1
	int i;
d445 3
d515 3
@


1.11
log
@ntp port support here too
XXX needs a .h file…
@
text
@d53 1
a53 1
__RCSID("$MirOS: src/usr.sbin/rdate/ntp.c,v 1.10 2007/07/05 22:32:25 tg Exp $");
d309 1
a309 1
	*(u_int64_t *)(packet + NTP_TRANSMIT) = data->xmitck;
d457 1
a457 1
	data->recvck = *(u_int64_t *)(packet + NTP_ORIGINATE);
@


1.10
log
@on MirBSD, use libc functions instead of ntpleaps.c
@
text
@d34 1
d53 1
a53 1
__RCSID("$MirOS: src/usr.sbin/rdate/ntp.c,v 1.9 2007/05/14 22:06:51 tg Exp $");
d129 1
a129 1
void	ntp_client(const char *, int, struct timeval *, struct timeval *);
d143 1
a143 1
    struct timeval *adjust)
d148 5
d169 12
@


1.9
log
@• merge ntpleaps.h into ntp.c, ntpleaps.c
• update ntpleaps.c to latest licence template
• portability: don't use __dead
• portability: add ifdef for external arc4random
• add GNUmakefile to be used on e.g. Debian GNU/Linux and Debian GNU/kFreeBSD
• BSDmakefile: remove GNU stuff
@
text
@d52 1
a52 1
__RCSID("$MirOS: src/usr.sbin/rdate/ntp.c,v 1.8 2006/08/28 13:15:43 tg Exp $");
d67 3
d72 1
@


1.8
log
@I need my debug modus (rdate -nd[d]p)
@
text
@d4 1
a4 1
 * Copyright (c) 2002, 2004, 2005, 2006 by Thorsten Glaser.
d52 1
a52 3
#include "ntpleaps.h"

__RCSID("$MirOS: src/usr.sbin/rdate/ntp.c,v 1.7 2006/06/09 20:58:09 tg Exp $");
d63 7
@


1.7
log
@doesn't make sense to rename these files
@
text
@d54 1
a54 1
__RCSID("$MirOS: src/usr.sbin/rdate/ntp.c,v 1.6 2006/05/29 23:38:31 tg Exp $");
d127 3
a129 3
#ifdef DEBUG
void	print_packet(const struct ntp_data *);
#endif
d156 2
a157 3
#ifdef DEBUG
			fprintf(stderr, "try the next address\n");
#endif
d168 2
a169 3
#ifdef DEBUG
	fprintf(stderr, "Correction: %.6f +/- %.6f\n", offset, error);
#endif
d208 2
d214 2
a215 4
#ifdef DEBUG
			print_packet(&data);
#endif

d224 2
a225 3
#ifdef DEBUG
		fprintf(stderr, "Offset: %.6f +/- %.6f\n", x, y);
#endif
d237 3
a239 3
#ifdef DEBUG
		fprintf(stderr, "Best: %.6f +/- %.6f\n", *offset, *error);
#endif
a478 1
#ifdef DEBUG
d480 1
a480 1
print_packet(const struct ntp_data *data)
d492 1
a492 2
};
#endif
@


1.6
log
@use libtz for determining whether we should correct leap
seconds, instead of relying on the user to provide -c, and
use it to know the exact amount of leap seconds to correct
for (if any)

we only lose one thing: RFC 868 leap second correction (but
then, you don't want to use that anyway, and if you use it,
you better know whether the server you're synching against
is using a POSIX or "right" timezone)
@
text
@d52 1
a52 1
#include "leapsecs.h"
d54 1
a54 1
__RCSID("$MirOS: src/usr.sbin/rdate/ntp.c,v 1.5 2006/05/09 08:57:58 tg Exp $");
@


1.5
log
@fix __CRAZY=Yes
@
text
@d4 1
a4 1
 * Copyright (c) 2002, 2004, 2005 by Thorsten Glaser.
d52 1
a52 1
#include "ntpleaps.h"
d54 10
a63 1
__RCSID("$MirOS: src/usr.sbin/rdate/ntp.c,v 1.4 2005/12/04 15:02:31 tg Exp $");
d119 1
a119 1
void	ntp_client(const char *, int, struct timeval *, struct timeval *, int);
a130 2
int	corrleaps;

d133 1
a133 1
    struct timeval *adjust, int leapflag)
a147 4
	corrleaps = leapflag;
	if (corrleaps)
		ntpleaps_init();

a443 1
	u_int64_t t;
d448 1
a448 10
	/*
	 * At this point, current has the current TAI time.
	 * Now subtract leap seconds to set the posix tick.
	 */

	t = SEC_TO_TAI64(current.tv_sec);
	if (corrleaps)
		ntpleaps_sub(&t);

	return (offset + TAI64_TO_SEC(t) + 1.0e-6 * current.tv_usec);
@


1.4
log
@fastmerge usr.sbin except tcpdump and httpd
@
text
@d54 1
a54 1
__RCSID("$MirOS: src/usr.sbin/rdate/ntp.c,v 1.3 2005/10/27 11:58:39 tg Exp $");
d118 1
a118 1
#if DEBUG
d130 1
a130 1
	int accept = 0, ret, s, ierror;
d161 1
a161 1
		accept++;
d170 1
a170 1
	if (accept < 1)
@


1.3
log
@* merge OpenBSD import
* rewrite tai2utc from libc:taitime.c
* please __CRAZY=yes
* reduce diff against OpenBSD
* retain some functionality
@
text
@d54 1
a54 1
__RCSID("$MirOS: src/usr.sbin/rdate/ntp.c,v 1.2 2005/03/13 19:17:21 tg Exp $");
d118 1
a118 1
#ifdef DEBUG
d130 1
a130 1
	int accepted = 0, ret, s, ierror;
d161 1
a161 1
		accepted++;
d170 1
a170 1
	if (accepted < 1)
@


1.2
log
@fast merge src/usr.sbin
@
text
@d1 1
a1 2
/**	$MirOS$ */
/*	$OpenBSD: ntp.c,v 1.15 2004/02/16 21:25:41 jakob Exp $	*/
d4 1
a4 1
 * Copyright (c) 2002, 2004 by Thorsten Glaser.
d54 1
a54 1
__RCSID("$MirOS$");
d69 1
a69 1
#define NTP_VERSION           3		/* The current version */
d72 1
a72 2
#define NTP_STRATUM_MIN       1		/* The minum valid stratum */
#define NTP_STRATUM_MAX      15		/* The maximum valid stratum */
d84 5
d96 12
a107 12
	u_char	status;
	u_char	version;
	u_char	mode;
	u_char	stratum;
	u_char	polling;
	u_char	precision;
	double	dispersion;
	double	reference;
	double	originate;
	double	receive;
	double	transmit;
	double	current;
d112 3
a114 5
void	make_packet(struct ntp_data *);
int	write_packet(int, const struct sockaddr *, struct ntp_data *);
int	read_packet(int, struct ntp_data *, double *, double *, double *);
void	pack_ntp(u_char *, int, struct ntp_data *);
void	unpack_ntp(struct ntp_data *, u_char *, int);
d118 4
d130 1
a130 1
	int packets = 0, s, ierror;
d151 2
a152 2
		packets = sync_ntp(s, res->ai_addr, &offset, &error);
		if (packets == 0) {
d160 2
a161 4
		if (error > NTP_INSANITY) {
			/* should we try the next address instead? */
			errx(1, "Unable to get a reasonable time estimate");
		}
d167 1
a167 1
	fprintf(stderr,"Correction: %.6f +/- %.6f\n", offset,error);
d170 3
d180 1
a180 1
	int delay = MAX_DELAY;
a183 1
	double dispersion = 0.0;	/* The source dispersion in seconds */
d187 27
a213 2
        *offset = 0.0;
        *error = NTP_INSANITY;
d215 5
a219 12
        while (accepts < MAX_QUERIES && attempts < 2 * MAX_QUERIES) {
		if (current_time(JAN_1970) > deadline)
			errx(1, "Not enough valid responses received in time");

		make_packet(&data);
		write_packet(fd, peer, &data);

		if (read_packet(fd, &data, &x, &y, &dispersion)) {
			if (++rejects > MAX_QUERIES)
				errx(1, "Too many bad or lost packets");
			else
			  continue;
d224 1
a224 2
		fprintf(stderr,"Offset: %.6f +/- %.6f disp=%.6f\n",
		    x, y, dispersion);
d238 1
a238 1
		fprintf(stderr,"Best: %.6f +/- %.6f\n", *offset, *error);
d241 4
a244 2
		if (a > b)
			errx(1, "Inconsistent times received from NTP server");
d248 1
a248 1
        }
d250 1
a250 1
	return accepts;
d253 3
a255 3
/* Create an outgoing NTP packet */
void
make_packet(struct ntp_data *data)
d257 28
a284 10
	data->status = 0;
	data->version = NTP_VERSION;
	data->mode = NTP_MODE_CLIENT;
	data->stratum = 0;
	data->polling = 0;
	data->precision = 0;
	data->reference = data->dispersion = 0.0;
	data->receive = data->originate = 0.0;
	data->current = data->transmit = current_time(JAN_1970);
}
d286 1
a286 5
int
write_packet(int fd, const struct sockaddr *peer, struct ntp_data *data)
{
	u_char	transmit[NTP_PACKET_MIN];
	int	length;
d288 3
a290 5
	pack_ntp(transmit, NTP_PACKET_MIN, data);
	length = sendto(fd, transmit, NTP_PACKET_MIN, 0, peer, SA_LEN(peer));
	if (length <= 0) {
		warnx("Unable to send NTP packet to server");
		return 1;
d293 1
a293 1
	return 0;
d303 1
a303 2
read_packet(int fd, struct ntp_data *data, double *off, double *error,
    double *dispersion)
d305 3
a307 2
	u_char	receive[NTP_PACKET_MAX+1];
	double	delay1, delay2, x, y;
d310 1
a310 1
	struct	timeval tv;
d312 3
a314 5
	rfds = (fd_set *)calloc(howmany(fd + 1, NFDBITS), sizeof(fd_mask));
	if (!rfds) {
		warnx("calloc() failed");
		return 1;
	}
d323 12
a334 7
	if (r < 1 || !FD_ISSET(fd, rfds)) {
		if (r < 0) {
			if (errno == EINTR)
				goto retry;
			else
				warnx("select() failed");
		}
d336 1
a336 1
		return 1;
d338 1
d341 2
a342 1
	length = recvfrom(fd, receive, NTP_PACKET_MAX + 1, 0, NULL, 0);
d344 2
a345 2
		warnx("Unable to receive NTP packet from server");
		return 1;
d349 2
a350 2
		warnx("Invalid NTP packet size, packet reject");
	        return 1;
d353 6
a358 1
	unpack_ntp(data, receive, length);
d362 3
a364 2
		warnx("Invalid NTP version, packet rejected");
		return 1;
d369 1
a369 1
		return 1;
d372 9
a380 8
	/*
	 * Note that the conventions are very poorly defined in the NTP
	 * protocol, so we have to guess.  Any full NTP server perpetrating
	 * completely unsynchronised packets is an abomination, anyway, so
	 * reject it.
	 */
	delay1 = data->transmit - data->receive;
	delay2 = data->current - data->originate;
d382 1
a382 1
	if (data->status == 3) {
d384 1
a384 1
		return 1;
d387 2
a388 23
	if (data->reference == 0.0 ||
	    data->transmit == 0.0 ||
	    data->receive == 0.0 ||
	    (data->reference != 0.0 && data->receive < data->reference) ||
	    delay1 < 0.0 ||
	    delay1 > NTP_INSANITY ||
	    delay2 < 0.0 ||
	    delay2 > NTP_INSANITY ||
	    data->dispersion > NTP_INSANITY) {
		warnx("Incomprehensible NTP packet rejected");
		return 1;
	}

	if (*dispersion < data->dispersion)
		*dispersion = data->dispersion;

        x = data->receive - data->originate;
        y = (data->transmit == 0.0 ? 0.0 : data->transmit-data->current);
        *off = 0.5*(x+y);
        *error = x-y;
        x = data->current - data->originate;
        if (0.5*x > *error)
		*error = 0.5*x;
d390 2
a391 2
	return 0;
}
d393 1
a393 10
/*
 * Pack the essential data into an NTP packet, bypassing struct layout
 * and endian problems.  Note that it ignores fields irrelevant to
 * SNTP.
 */
void
pack_ntp(u_char	*packet, int length, struct ntp_data *data)
{
	int i, k;
	double d;
d395 2
a396 1
	memset(packet,0, (size_t)length);
d398 1
a398 25
	packet[0] = (data->status<<6)|(data->version<<3)|data->mode;
	packet[1] = data->stratum;
	packet[2] = data->polling;
	packet[3] = data->precision;

	d = data->originate/NTP_SCALE;
	for (i = 0; i < 8; ++i) {
		if ((k = (int)(d *= 256.0)) >= 256) k = 255;
		packet[NTP_ORIGINATE+i] = k;
		d -= k;
	}

	d = data->receive/NTP_SCALE;
	for (i = 0; i < 8; ++i) {
		if ((k = (int)(d *= 256.0)) >= 256) k = 255;
		packet[NTP_RECEIVE+i] = k;
		d -= k;
	}

	d = data->transmit/NTP_SCALE;
	for (i = 0; i < 8; ++i) {
		if ((k = (int)(d *= 256.0)) >= 256) k = 255;
		packet[NTP_TRANSMIT+i] = k;
		d -= k;
	}
d407 1
a407 1
unpack_ntp(struct ntp_data *data, u_char *packet, int length)
d415 2
a416 2
	data->version = (packet[0] >> 3)&0x07;
	data->mode = packet[0]&0x07;
a417 2
	data->polling = packet[2];
	data->precision = packet[3];
d419 2
a420 3
	for (i = 0, d = 0.0; i < 4; ++i)
	    d = 256.0*d+packet[NTP_DISP_FIELD+i];
	data->dispersion = d/65536.0;
d422 1
a422 3
	for (i = 0, d = 0.0; i < 8; ++i)
	    d = 256.0*d+packet[NTP_REFERENCE+i];
	data->reference = d/NTP_SCALE;
d425 1
a425 2
	    d = 256.0*d+packet[NTP_ORIGINATE+i];
	data->originate = d/NTP_SCALE;
d427 1
a427 3
	for (i = 0, d = 0.0; i < 8; ++i)
	    d = 256.0*d+packet[NTP_RECEIVE+i];
	data->receive = d/NTP_SCALE;
d429 2
a430 3
	for (i = 0, d = 0.0; i < 8; ++i)
	    d = 256.0*d+packet[NTP_TRANSMIT+i];
	data->transmit = d/NTP_SCALE;
d455 1
a455 1
	return offset + TAI64_TO_SEC(t) + 1.0e-6 * current.tv_usec;
d497 6
a502 8
	printf("polling:     %u\n", data->polling);
	printf("precision:   %u\n", data->precision);
	printf("dispersion:  %e\n", data->dispersion);
	printf("reference:   %e\n", data->reference);
	printf("originate:   %e\n", data->originate);
	printf("receive:     %e\n", data->receive);
	printf("transmit:    %e\n", data->transmit);
	printf("current:     %e\n", data->current);
@


1.1
log
@Initial revision
@
text
@d1 1
d5 1
a7 1
 * Copyright (c) 2002 by Thorsten "mirabile" Glaser.
d55 2
d334 5
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.27 2004/10/26 09:48:59 henning Exp $	*/
d67 1
a67 1
#define NTP_VERSION           4		/* The current version */
d70 2
a71 1
#define NTP_STRATUM_MAX      14		/* The maximum valid stratum */
a82 5
#define STATUS_NOWARNING      0		/* No Leap Indicator */
#define STATUS_LEAPHIGH       1		/* Last Minute Has 61 Seconds */
#define STATUS_LEAPLOW        2		/* Last Minute Has 59 Seconds */
#define STATUS_ALARM          3		/* Server Clock Not Synchronized */

d90 12
a101 12
	u_char		status;
	u_char		version;
	u_char		mode;
	u_char		stratum;
	double		receive;
	double		transmit;
	double		current;
	u_int64_t	recvck;

	/* Local State */
	double		originate;
	u_int64_t	xmitck;
d106 5
a110 3
int	write_packet(int, struct ntp_data *);
int	read_packet(int, struct ntp_data *, double *, double *);
void	unpack_ntp(struct ntp_data *, u_char *);
a113 4
#if DEBUG
void	print_packet(const struct ntp_data *);
#endif

d122 1
a122 1
	int accept = 0, ret, s, ierror;
d143 2
a144 2
		ret = sync_ntp(s, res->ai_addr, &offset, &error);
		if (ret < 0) {
d152 4
a155 2

		accept++;
d161 1
a161 1
	fprintf(stderr, "Correction: %.6f +/- %.6f\n", offset, error);
a163 3
	if (accept < 1)
		errx(1, "Unable to get a reasonable time estimate");

d171 1
a171 1
	int delay = MAX_DELAY, ret;
d175 1
d179 2
a180 27
	*offset = 0.0;
	*error = NTP_INSANITY;

	if (connect(fd, peer, SA_LEN(peer)) < 0) {
		warn("Failed to connect to server");
		return (-1);
	}

	while (accepts < MAX_QUERIES && attempts < 2 * MAX_QUERIES) {
		memset(&data, 0, sizeof(data));

		if (current_time(JAN_1970) > deadline) {
			warnx("Not enough valid responses received in time");
			return (-1);
		}

		if (write_packet(fd, &data) < 0)
			return (-1);

		ret = read_packet(fd, &data, &x, &y);

		if (ret < 0)
			return (-1);
		else if (ret > 0) {
#ifdef DEBUG
			print_packet(&data);
#endif
d182 12
a193 5
			if (++rejects > MAX_QUERIES) {
				warnx("Too many bad or lost packets");
				return (-1);
			} else
				continue;
d198 2
a199 1
		fprintf(stderr, "Offset: %.6f +/- %.6f\n", x, y);
d213 1
a213 1
		fprintf(stderr, "Best: %.6f +/- %.6f\n", *offset, *error);
d216 2
a217 4
		if (a > b) {
			warnx("Inconsistent times received from NTP server");
			return (-1);
		}
d221 4
a224 1
	}
d226 13
a238 1
	return (accepts);
a240 1
/* Send out NTP packet. */
d242 1
a242 1
write_packet(int fd, struct ntp_data *data)
d244 2
a245 6
	u_char	packet[NTP_PACKET_MIN];
	ssize_t	length;

	memset(packet, 0, sizeof(packet));

	packet[0] = (NTP_VERSION << 3) | (NTP_MODE_CLIENT);
d247 5
a251 27
	data->xmitck = (u_int64_t)arc4random() << 32 | arc4random();

	/*
	 * Send out a random 64-bit number as our transmit time.  The NTP
	 * server will copy said number into the originate field on the
	 * response that it sends us.  This is totally legal per the SNTP spec.
	 *
	 * The impact of this is two fold: we no longer send out the current
	 * system time for the world to see (which may aid an attacker), and
	 * it gives us a (not very secure) way of knowing that we're not
	 * getting spoofed by an attacker that can't capture our traffic
	 * but can spoof packets from the NTP server we're communicating with.
	 *
	 * No endian concerns here.  Since we're running as a strict
	 * unicast client, we don't have to worry about anyone else finding
	 * the transmit field intelligible.
	 */

	*(u_int64_t *)(packet + NTP_TRANSMIT) = data->xmitck;

	data->originate = current_time(JAN_1970);

	length = write(fd, packet, sizeof(packet));

	if (length != sizeof(packet)) {
		warn("Unable to send NTP packet to server");
		return (-1);
d254 1
a254 1
	return (0);
d264 2
a265 1
read_packet(int fd, struct ntp_data *data, double *off, double *error)
d267 2
a268 3
	u_char	receive[NTP_PACKET_MAX];
	struct	timeval tv;
	double	x, y;
d271 1
d273 5
a277 3
	rfds = calloc(howmany(fd + 1, NFDBITS), sizeof(fd_mask));
	if (rfds == NULL)
		err(1, "calloc");
d286 7
a292 12

	if (r < 0) {
		if (errno == EINTR)
			goto retry;
		else
			warn("select");

		free(rfds);
		return (r);
	}

	if (r != 1 || !FD_ISSET(fd, rfds)) {
d294 1
a294 1
		return (1);
a295 1

d298 1
a298 2
	length = read(fd, receive, NTP_PACKET_MAX);

d300 2
a301 2
		warn("Unable to receive NTP packet from server");
		return (-1);
d305 2
a306 2
		warnx("Invalid NTP packet size, packet rejected");
		return (1);
d309 1
a309 6
	unpack_ntp(data, receive);

	if (data->recvck != data->xmitck) {
		warnx("Invalid cookie received, packet rejected");
		return (1);
	}
d313 2
a314 3
		warnx("Received NTP version %u, need %u or lower",
		    data->version, NTP_VERSION);
		return (1);
d319 1
a319 1
		return (1);
d322 8
a329 9
	if (data->stratum > NTP_STRATUM_MAX) {
		warnx("Invalid stratum received, packet rejected");
		return (1);
	}

	if (data->transmit == 0.0) {
		warnx("Server clock invalid, packet rejected");
		return (1);
	}
d331 23
a353 2
	x = data->receive - data->originate;
	y = data->transmit - data->current;
d355 2
a356 2
	*off = (x + y) / 2;
	*error = x - y;
d358 10
a367 1
	x = (data->current - data->originate) / 2;
d369 1
a369 2
	if (x > *error)
		*error = x;
d371 25
a395 1
	return (0);
d404 1
a404 1
unpack_ntp(struct ntp_data *data, u_char *packet)
d412 2
a413 2
	data->version = (packet[0] >> 3) & 0x07;
	data->mode = packet[0] & 0x07;
d415 14
d432 1
a432 2

	data->receive = d / NTP_SCALE;
d436 1
a436 5

	data->transmit = d / NTP_SCALE;

	/* See write_packet for why this isn't an endian problem. */
	data->recvck = *(u_int64_t *)(packet + NTP_ORIGINATE);
d461 1
a461 1
	return (offset + TAI64_TO_SEC(t) + 1.0e-6 * current.tv_usec);
d503 8
a510 6
	printf("originate:   %f\n", data->originate);
	printf("receive:     %f\n", data->receive);
	printf("transmit:    %f\n", data->transmit);
	printf("current:     %f\n", data->current);
	printf("xmitck:      0x%0llX\n", data->xmitck);
	printf("recvck:      0x%0llX\n", data->recvck);
@

