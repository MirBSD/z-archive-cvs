head	1.6;
access;
symbols
	MIRBSD_10:1.6.0.2
	MIRBSD_10_BASE:1.6
	cvs-200703091200:1.1.1.4
	cvs-200702170300:1.1.1.3
	MIRBSD_9_BASE:1.3
	MIRBSD_8:1.3.0.2
	MIRBSD_8_BASE:1.3
	cvs-200507211800:1.1.1.2
	cvs-200504170300:1.1.1.2
	cvs-200503231815:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2007.03.09.13.05.10;	author tg;	state Exp;
branches;
next	1.5;
commitid	10045F15B4849447B32;

1.5
date	2007.02.17.03.28.30;	author tg;	state Exp;
branches;
next	1.4;
commitid	10045D676750FFD4961;

1.4
date	2006.06.30.20.58.59;	author tg;	state Exp;
branches;
next	1.3;
commitid	10044A590916A489828;

1.3
date	2005.03.23.18.19.41;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.13.19.17.27;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.31.09;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.31.09;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.03.23.18.17.01;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.02.17.03.06.14;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	10045D67134732A8703;

1.1.1.4
date	2007.03.09.12.34.07;	author tg;	state Exp;
branches;
next	;
commitid	10045F1544D56DA4889;


desc
@@


1.6
log
@sync spamd upgrades and libpcap, and some /etc stuff; read
• http://undeadly.org/cgi?action=article&sid=20070304035922&mode=expanded
• http://www.openbsd.org/faq/current.html#20070226
for details. In short:
• change rc.conf[.local]
• spamd.conf now lies in /etc/mail/
• greylisting is on by default
• the database has a new format
• there's some database sync stuff
@
text
@/**	$MirOS: src/usr.sbin/spamdb/spamdb.c,v 1.5 2007/02/17 03:28:30 tg Exp $ */
/*	$OpenBSD: spamdb.c,v 1.22 2007/02/27 16:22:11 otto Exp $	*/

/*
 * Copyright (c) 2004 Bob Beck.  All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <db.h>
#include <err.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <netdb.h>
#include <ctype.h>
#include <errno.h>

#include "grey.h"

__RCSID("$MirOS: src/usr.sbin/spamdb/spamdb.c,v 1.5 2007/02/17 03:28:30 tg Exp $");

/* things we may add/delete from the db */
#define WHITE 0
#define TRAPHIT 1
#define SPAMTRAP 2

int	dblist(DB *);
int	dbupdate(DB *, char *, int, int);

int
dbupdate(DB *db, char *ip, int add, int type)
{
	DBT		dbk, dbd;
	struct gdata	gd;
	time_t		now;
	int		r;
	struct addrinfo hints, *res;

	now = time(NULL);
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = PF_UNSPEC;
	hints.ai_socktype = SOCK_DGRAM;	/*dummy*/
	hints.ai_flags = AI_NUMERICHOST;
	if (add && (type == TRAPHIT || type == WHITE)) {
		if (getaddrinfo(ip, NULL, &hints, &res) != 0) {
			warnx("invalid ip address %s", ip);
			goto bad;
		}
		freeaddrinfo(res);
	}
	memset(&dbk, 0, sizeof(dbk));
	dbk.size = strlen(ip);
	dbk.data = ip;
	memset(&dbd, 0, sizeof(dbd));
	if (!add) {
		/* remove entry */
		r = db->get(db, &dbk, &dbd, 0);
		if (r == -1) {
			warn("db->get failed");
			goto bad;
		}
		if (r) {
			warnx("no entry for %s", ip);
			goto bad;
		} else if (db->del(db, &dbk, 0)) {
			warn("db->del failed");
			goto bad;
		}
	} else {
		/* add or update entry */
		r = db->get(db, &dbk, &dbd, 0);
		if (r == -1) {
			warn("db->get failed");
			goto bad;
		}
		if (r) {
			int i;

			/* new entry */
			memset(&gd, 0, sizeof(gd));
			gd.first = now;
			gd.bcount = 1;
			switch (type) {
			case WHITE:
				gd.pass = now;
				gd.expire = now + WHITEEXP;
				break;
			case TRAPHIT:
				gd.expire = now + TRAPEXP;
				gd.pcount = -1;
				break;
			case SPAMTRAP:
				gd.expire = 0;
				gd.pcount = -2;
				/* ensure address is lower case*/
				for (i = 0; ip[i] != '\0'; i++)
					if (isupper(ip[i]))
						ip[i] = (char)tolower(ip[i]);
				break;
			default:
				errx(-1, "unknown type %d", type);
			}
			memset(&dbk, 0, sizeof(dbk));
			dbk.size = strlen(ip);
			dbk.data = ip;
			memset(&dbd, 0, sizeof(dbd));
			dbd.size = sizeof(gd);
			dbd.data = &gd;
			r = db->put(db, &dbk, &dbd, 0);
			if (r) {
				warn("db->put failed");
				goto bad;
			}
		} else {
			if (dbd.size != sizeof(gd)) {
				/* whatever this is, it doesn't belong */
				db->del(db, &dbk, 0);
				goto bad;
			}
			memcpy(&gd, dbd.data, sizeof(gd));
			gd.pcount++;
			switch (type) {
			case WHITE:
				gd.pass = now;
				gd.expire = now + WHITEEXP;
				break;
			case TRAPHIT:
				gd.expire = now + TRAPEXP;
				gd.pcount = -1;
				break;
			case SPAMTRAP:
				gd.expire = 0; /* XXX */
				gd.pcount = -2;
				break;
			default:
				errx(-1, "unknown type %d", type);
			}

			memset(&dbk, 0, sizeof(dbk));
			dbk.size = strlen(ip);
			dbk.data = ip;
			memset(&dbd, 0, sizeof(dbd));
			dbd.size = sizeof(gd);
			dbd.data = &gd;
			r = db->put(db, &dbk, &dbd, 0);
			if (r) {
				warn("db->put failed");
				goto bad;
			}
		}
	}
	return (0);
 bad:
	return (1);
}

int
dblist(DB *db)
{
	DBT		dbk, dbd;
	struct gdata	gd;
	int		r;

	/* walk db, list in text format */
	memset(&dbk, 0, sizeof(dbk));
	memset(&dbd, 0, sizeof(dbd));
	for (r = db->seq(db, &dbk, &dbd, R_FIRST); !r;
	    r = db->seq(db, &dbk, &dbd, R_NEXT)) {
		char *a, *cp;

		if ((dbk.size < 1) || dbd.size != sizeof(struct gdata)) {
			db->close(db);
			errx(1, "bogus size db entry - bad db file?");
		}
		memcpy(&gd, dbd.data, sizeof(gd));
		a = malloc(dbk.size + 1);
		if (a == NULL)
			err(1, "malloc");
		memcpy(a, dbk.data, dbk.size);
		a[dbk.size]='\0';
		cp = strchr(a, '\n');
		if (cp == NULL) {
			/* this is a non-greylist entry */
			switch (gd.pcount) {
			case -1: /* spamtrap hit, with expiry time */
				printf("TRAPPED|%s|%lld\n", a, (int64_t)gd.expire);
				break;
			case -2: /* spamtrap address */
				printf("SPAMTRAP|%s\n", a);
				break;
			default: /* whitelist */
				printf("WHITE|%s|||%lld|%lld|%lld|%d|%d\n", a,
				    (int64_t)gd.first, (int64_t)gd.pass,
				    (int64_t)gd.expire, gd.bcount,
				    gd.pcount);
				break;
			}
		} else {
			char *helo, *from, *to;

			/* greylist entry */
			*cp = '\0';
			helo = cp + 1;
			from = strchr(helo, '\n');
			if (from == NULL) {
				warnx("No from part in grey key %s", a);
				free(a);
				goto bad;
			}
			*from = '\0';
			from++;
			to = strchr(from, '\n');
			if (to == NULL) {
				/* probably old format - print it the
				 * with an empty HELO field instead 
				 * of erroring out.
				 */			  
				printf("GREY|%s|%s|%s|%s|%lld|%lld|%lld|%d|%d\n",
				    a, "", helo, from, (int64_t)gd.first,
				    (int64_t)gd.pass, (int64_t)gd.expire,
				    gd.bcount, gd.pcount);
			
			} else {
				*to = '\0';
				to++;
				printf("GREY|%s|%s|%s|%s|%lld|%lld|%lld|%d|%d\n",
				    a, helo, from, to, (int64_t)gd.first,
				    (int64_t)gd.pass, (int64_t)gd.expire,
				    gd.bcount, gd.pcount);
			}
		}
		free(a);
	}
	db->close(db);
	db = NULL;
	return (0);
 bad:
	db->close(db);
	db = NULL;
	errx(1, "incorrect db format entry");
	/* NOTREACHED */
	return (1);
}

extern char *__progname;

static int
usage(void)
{
	fprintf(stderr, "usage: %s [[-Tt] -a keys] [[-Tt] -d keys]\n", __progname);
	exit(1);
	/* NOTREACHED */
}

int
main(int argc, char **argv)
{
	int i, ch, action = 0, type = WHITE, r = 0;
	HASHINFO	hashinfo;
	DB		*db;

	while ((ch = getopt(argc, argv, "adtT")) != -1) {
		switch (ch) {
		case 'a':
			action = 1;
			break;
		case 'd':
			action = 2;
			break;
		case 't':
			type = TRAPHIT;
			break;
		case 'T':
			type = SPAMTRAP;
			break;
		default:
			usage();
			break;
		}
	}
	argc -= optind;
	argv += optind;
	if (action == 0 && type != WHITE)
		usage();
	
	memset(&hashinfo, 0, sizeof(hashinfo));
	db = dbopen(PATH_SPAMD_DB, O_EXLOCK | (action ? O_RDWR : O_RDONLY),
	    0600, DB_HASH, &hashinfo);
	if (db == NULL) {
		if (errno == EFTYPE)	
			err(1,
			    "%s is old, run current spamd to convert it",
			    PATH_SPAMD_DB);
		else 
			err(1, "cannot open %s for %s", PATH_SPAMD_DB,
			    action ? "writing" : "reading");
	}

	switch (action) {
	case 0:
		return dblist(db);
	case 1:
		for (i=0; i<argc; i++)
			r += dbupdate(db, argv[i], 1, type);
		break;
	case 2:
		for (i=0; i<argc; i++)
			r += dbupdate(db, argv[i], 0, type);
		break;
	default:
		errx(-1, "bad action");
	}
	db->close(db);
	return (r);
}
@


1.5
log
@automerge spamd update
@
text
@d1 2
a2 2
/**	$MirOS: src/usr.sbin/spamdb/spamdb.c,v 1.4 2006/06/30 20:58:59 tg Exp $ */
/*	$OpenBSD: spamdb.c,v 1.19 2007/01/04 21:41:37 beck Exp $	*/
d37 1
a37 1
__RCSID("$MirOS: src/usr.sbin/spamdb/spamdb.c,v 1.4 2006/06/30 20:58:59 tg Exp $");
d216 1
a216 1
			char *from, *to;
d220 3
a222 3
			from = cp + 1;
			to = strchr(from, '\n');
			if (to == NULL) {
d227 21
a247 9
			*to = '\0';
			to++;
#ifdef _BSD_TIME_T_IS_64_BIT
			printf("GREY|%s|%s|%s|%lld|%lld|%lld|%d|%d\n",
#else
			printf("GREY|%s|%s|%s|%d|%d|%d|%d|%d\n",
#endif
			    a, from, to, gd.first, gd.pass, gd.expire,
			    gd.bcount, gd.pcount);
d300 2
d304 2
a305 2
	db = dbopen(PATH_SPAMD_DB, O_EXLOCK|O_RDWR, 0600, DB_HASH,
	    &hashinfo);
d312 2
a313 1
			err(1, "cannot open %s for writing", PATH_SPAMD_DB);
@


1.4
log
@build this on sparc w/o EXPERIMENTAL=yes (untested)
@
text
@d1 2
a2 2
/**	$MirOS: src/usr.sbin/spamdb/spamdb.c,v 1.3 2005/03/23 18:19:41 tg Exp $ */
/*	$OpenBSD: spamdb.c,v 1.14 2005/03/11 23:45:45 beck Exp $	*/
d33 1
d37 1
a37 1
__RCSID("$MirOS: src/usr.sbin/spamdb/spamdb.c,v 1.3 2005/03/23 18:19:41 tg Exp $");
d44 3
d48 1
a48 1
dbupdate(char *dbname, char *ip, int add, int type)
a49 1
	BTREEINFO	btreeinfo;
a50 1
	DB		*db;
a56 4
	memset(&btreeinfo, 0, sizeof(btreeinfo));
	db = dbopen(dbname, O_EXLOCK|O_RDWR, 0600, DB_BTREE, &btreeinfo);
	if (db == NULL)
		err(1, "cannot open %s for writing", dbname);
d61 1
a61 1
	if (type == TRAPHIT || type == WHITE) {
d115 1
a115 1
						ip[i] = tolower(ip[i]);
a168 2
	db->close(db);
	db = NULL;
a170 2
	db->close(db);
	db = NULL;
d175 1
a175 1
dblist(char *dbname)
a176 1
	BTREEINFO	btreeinfo;
a177 1
	DB		*db;
a181 4
	memset(&btreeinfo, 0, sizeof(btreeinfo));
	db = dbopen(dbname, O_EXLOCK|O_RDONLY, 0600, DB_BTREE, &btreeinfo);
	if (db == NULL)
		err(1, "cannot open %s for reading", dbname);
d255 1
a255 1
	fprintf(stderr, "usage: %s [-Tt] [-a key] [-d key]\n", __progname);
d257 1
d263 3
a265 2
	int ch, action = 0, type = WHITE;
	char *ip = NULL;
d267 1
a267 1
	while ((ch = getopt(argc, argv, "a:d:tT")) != -1) {
a270 1
			ip = optarg;
a273 1
			ip = optarg;
d286 14
d303 1
a303 1
		return dblist(PATH_SPAMD_DB);
d305 3
a307 1
		return dbupdate(PATH_SPAMD_DB, ip, 1, type);
d309 3
a311 1
		return dbupdate(PATH_SPAMD_DB, ip, 0, type);
d315 2
a316 2
	/* NOT REACHED */
	return (0);
@


1.3
log
@merge
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/spamdb/spamdb.c,v 1.2 2005/03/13 19:17:27 tg Exp $ */
d36 1
a36 1
__RCSID("$MirOS: src/usr.sbin/spamdb/spamdb.c,v 1.2 2005/03/13 19:17:27 tg Exp $");
d241 1
d243 3
@


1.2
log
@fast merge src/usr.sbin
@
text
@d1 2
a2 2
/**	$MirOS$ */
/*	$OpenBSD: spamdb.c,v 1.11 2004/04/27 21:25:11 itojun Exp $	*/
d32 1
d36 6
a41 1
__RCSID("$MirOS$");
d44 1
a44 1
dbupdate(char *dbname, char *ip, int add)
d63 6
a68 3
	if (getaddrinfo(ip, NULL, &hints, &res) != 0) {
		warnx("invalid ip address %s", ip);
		goto bad;
a69 1
	freeaddrinfo(res);
d75 1
a75 1
		/* remove whitelist entry */
d89 1
a89 1
		/* add or update whitelist entry */
d96 2
d102 20
a121 2
			gd.pass = now;
			gd.expire = now + WHITEEXP;
d141 17
a157 1
			gd.expire = now + WHITEEXP;
d211 17
a227 5
		if (cp == NULL)
			/* this is a whitelist entry */
			printf("WHITE|%s|||%lld|%lld|%lld|%d|%d\n", a, gd.first,
			    gd.pass, gd.expire, gd.bcount, gd.pcount);
		else {
d263 1
a263 1
	fprintf(stderr, "usage: %s [-a ip] [-d ip]\n", __progname);
d270 1
a270 1
	int ch, action = 0;
d273 1
a273 1
	while ((ch = getopt(argc, argv, "a:d:")) != -1) {
d283 6
d299 1
a299 1
		return dbupdate(PATH_SPAMD_DB, ip, 1);
d301 1
a301 1
		return dbupdate(PATH_SPAMD_DB, ip, 0);
@


1.1
log
@Initial revision
@
text
@d1 1
d35 2
d169 1
a169 1
			printf("WHITE|%s|||%d|%d|%d|%d|%d\n", a, gd.first,
d185 1
a185 1
			printf("GREY|%s|%s|%s|%d|%d|%d|%d|%d\n",
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@first off, update spamd to openbsd 3.7-current state
@
text
@d1 1
a1 1
/*	$OpenBSD: spamdb.c,v 1.14 2005/03/11 23:45:45 beck Exp $	*/
a30 1
#include <ctype.h>
a33 5
/* things we may add/delete from the db */
#define WHITE 0
#define TRAPHIT 1
#define SPAMTRAP 2

d35 1
a35 1
dbupdate(char *dbname, char *ip, int add, int type)
d54 3
a56 6
	if (type == TRAPHIT || type == WHITE) {
		if (getaddrinfo(ip, NULL, &hints, &res) != 0) {
			warnx("invalid ip address %s", ip);
			goto bad;
		}
		freeaddrinfo(res);
d58 1
d64 1
a64 1
		/* remove entry */
d78 1
a78 1
		/* add or update entry */
a84 2
			int i;

d89 2
a90 20
			switch (type) {
			case WHITE:
				gd.pass = now;
				gd.expire = now + WHITEEXP;
				break;
			case TRAPHIT:
				gd.expire = now + TRAPEXP;
				gd.pcount = -1;
				break;
			case SPAMTRAP:
				gd.expire = 0;
				gd.pcount = -2;
				/* ensure address is lower case*/
				for (i = 0; ip[i] != '\0'; i++)
					if (isupper(ip[i]))
						ip[i] = tolower(ip[i]);
				break;
			default:
				errx(-1, "unknown type %d", type);
			}
d110 1
a110 17
			switch (type) {
			case WHITE:
				gd.pass = now;
				gd.expire = now + WHITEEXP;
				break;
			case TRAPHIT:
				gd.expire = now + TRAPEXP;
				gd.pcount = -1;
				break;
			case SPAMTRAP:
				gd.expire = 0; /* XXX */
				gd.pcount = -2;
				break;
			default:
				errx(-1, "unknown type %d", type);
			}

d164 5
a168 16
		if (cp == NULL) {
			/* this is a non-greylist entry */
			switch (gd.pcount) {
			case -1: /* spamtrap hit, with expiry time */
				printf("TRAPPED|%s|%d\n", a, gd.expire);
				break;
			case -2: /* spamtrap address */
				printf("SPAMTRAP|%s\n", a);
				break;
			default: /* whitelist */
				printf("WHITE|%s|||%d|%d|%d|%d|%d\n", a,
				    gd.first, gd.pass, gd.expire, gd.bcount,
				    gd.pcount);
				break;
			}
		} else {
d204 1
a204 1
	fprintf(stderr, "usage: %s [-Tt] [-a key] [-d key]\n", __progname);
d211 1
a211 1
	int ch, action = 0, type = WHITE;
d214 1
a214 1
	while ((ch = getopt(argc, argv, "a:d:tT")) != -1) {
a223 6
		case 't':
			type = TRAPHIT;
			break;
		case 'T':
			type = SPAMTRAP;
			break;
d234 1
a234 1
		return dbupdate(PATH_SPAMD_DB, ip, 1, type);
d236 1
a236 1
		return dbupdate(PATH_SPAMD_DB, ip, 0, type);
@


1.1.1.3
log
@Import spamd and dhclient from OpenBSD-current
@
text
@d1 1
a1 1
/*	$OpenBSD: spamdb.c,v 1.19 2007/01/04 21:41:37 beck Exp $	*/
a31 1
#include <errno.h>
a39 3
int	dblist(DB *);
int	dbupdate(DB *, char *, int, int);

d41 1
a41 1
dbupdate(DB *db, char *ip, int add, int type)
d43 1
d45 1
d52 4
d60 1
a60 1
	if (add && (type == TRAPHIT || type == WHITE)) {
d114 1
a114 1
						ip[i] = (char)tolower(ip[i]);
d168 2
d172 2
d178 1
a178 1
dblist(DB *db)
d180 1
d182 1
d187 4
d259 1
a259 1
	fprintf(stderr, "usage: %s [[-Tt] -a keys] [[-Tt] -d keys]\n", __progname);
a260 1
	/* NOTREACHED */
d266 2
a267 3
	int i, ch, action = 0, type = WHITE, r = 0;
	HASHINFO	hashinfo;
	DB		*db;
d269 1
a269 1
	while ((ch = getopt(argc, argv, "adtT")) != -1) {
d273 1
d277 1
a289 14
	argc -= optind;
	argv += optind;
	
	memset(&hashinfo, 0, sizeof(hashinfo));
	db = dbopen(PATH_SPAMD_DB, O_EXLOCK|O_RDWR, 0600, DB_HASH,
	    &hashinfo);
	if (db == NULL) {
		if (errno == EFTYPE)	
			err(1,
			    "%s is old, run current spamd to convert it",
			    PATH_SPAMD_DB);
		else 
			err(1, "cannot open %s for writing", PATH_SPAMD_DB);
	}
d293 1
a293 1
		return dblist(db);
d295 1
a295 3
		for (i=0; i<argc; i++)
			r += dbupdate(db, argv[i], 1, type);
		break;
d297 1
a297 3
		for (i=0; i<argc; i++)
			r += dbupdate(db, argv[i], 0, type);
		break;
d301 2
a302 2
	db->close(db);
	return (r);
@


1.1.1.4
log
@import openbsd-current spamd code
@
text
@d1 1
a1 1
/*	$OpenBSD: spamdb.c,v 1.22 2007/02/27 16:22:11 otto Exp $	*/
d212 1
a212 1
			char *helo, *from, *to;
d216 3
a218 3
			helo = cp + 1;
			from = strchr(helo, '\n');
			if (from == NULL) {
d223 5
a227 19
			*from = '\0';
			from++;
			to = strchr(from, '\n');
			if (to == NULL) {
				/* probably old format - print it the
				 * with an empty HELO field instead 
				 * of erroring out.
				 */			  
				printf("GREY|%s|%s|%s|%s|%d|%d|%d|%d|%d\n",
				    a, "", helo, from, gd.first, gd.pass,
				    gd.expire, gd.bcount, gd.pcount);
			
			} else {
				*to = '\0';
				to++;
				printf("GREY|%s|%s|%s|%s|%d|%d|%d|%d|%d\n",
				    a, helo, from, to, gd.first, gd.pass,
				    gd.expire, gd.bcount, gd.pcount);
			}
a279 2
	if (action == 0 && type != WHITE)
		usage();
d282 2
a283 2
	db = dbopen(PATH_SPAMD_DB, O_EXLOCK | (action ? O_RDWR : O_RDONLY),
	    0600, DB_HASH, &hashinfo);
d290 1
a290 2
			err(1, "cannot open %s for %s", PATH_SPAMD_DB,
			    action ? "writing" : "reading");
@


