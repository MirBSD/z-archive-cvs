head	1.4;
access;
symbols
	MIRBSD_10:1.2.0.2
	MIRBSD_10_BASE:1.2
	MIRBSD_9_BASE:1.1.1.1
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200507211800:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2010.07.25.16.31.08;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004C4C66B4083A50C4;

1.3
date	2008.06.13.15.12.33;	author tg;	state Exp;
branches;
next	1.2;
commitid	10048528E7265FA5FDF;

1.2
date	2007.02.19.03.11.20;	author tg;	state Exp;
branches;
next	1.1;
commitid	10045D9156E777E94DE;

1.1
date	2005.02.05.17.30.24;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.30.24;	author tg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@let modload(8) check the version of the running kernel with the version
of the kernel image and error out if they fail

something like “which kernel has been loaded” passed by the bootloader
would be better, of course, but this is failsafe unless someone manually
manipulates the version strings willingly
@
text
@/*	$OpenBSD: exec_elf.c,v 1.10 2004/01/04 18:30:05 deraadt Exp $ */

/*
 * Copyright (c) 1999 Mats O Jansson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <nlist.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/exec.h>
#include <sys/exec_elf.h>
#include <sys/types.h>

#include "ukc.h"
#include "config.h"

__RCSID("$MirOS: src/usr.sbin/config/exec_elf.c,v 1.3 2008/06/13 15:12:33 tg Exp $");

caddr_t		ptr, rest, pre;
Elf_Ehdr	elf_ex;
Elf_Phdr	*elf_phdr;
Elf_Shdr	*elf_shdr;
char		*elf_total;
char		*elf_shstrtab;
off_t		elf_size;

caddr_t		elf_adjust(caddr_t);
caddr_t		elf_readjust(caddr_t);
int		elf_check(const char *);
void		elf_loadkernel(const char *);
void		elf_savekernel(const char *);

caddr_t
elf_adjust(caddr_t x)
{
	int i;
	Elf_Shdr *s;
	unsigned long y = 0;

	s = elf_shdr;

	for (i = 0; i < elf_ex.e_shnum; i++) {
		if (s[i].sh_addr == 0)
			continue;
		if (((unsigned long)x >= s[i].sh_addr) &&
		    ((unsigned long)x < (s[i].sh_addr+s[i].sh_size))) {
			y = (unsigned long)&elf_total[(unsigned long)x -
			    s[i].sh_addr + s[i].sh_offset];
			break;
		}
	}

	return((caddr_t)y);
}

caddr_t
elf_readjust(caddr_t x)
{
	int i;
	Elf_Shdr *s;
	unsigned long y = 0;

	s = elf_shdr;

	for (i = 0; i < elf_ex.e_shnum; i++) {
		if (s[i].sh_addr == 0)
			continue;
		if (((Elf_Off)(x - elf_total) >= s[i].sh_offset) &&
		    ((Elf_Off)(x - elf_total) <= (s[i].sh_offset + s[i].sh_size)))
			y = (unsigned long)x - (unsigned long)elf_total +
			    (unsigned long)s[i].sh_addr - s[i].sh_offset;
	}

	return((caddr_t)y);
}

int
elf_check(const char *file)
{
	int fd, ret = 1;

	if ((fd = open(file, O_RDONLY | O_EXLOCK, 0)) < 0)
		return (0);

	if (read(fd, (char *)&elf_ex, sizeof(elf_ex)) != sizeof(elf_ex))
		ret = 0;

	if (ret) {
		if (!IS_ELF(elf_ex))
			ret = 0;
	}

	close(fd);
	return (ret);
}

void
elf_loadkernel(const char *file)
{
	int fd;

	if ((fd = open(file, O_RDONLY | O_EXLOCK, 0)) < 0)
		err(1, "%s", file);

	if (read(fd, (char *)&elf_ex, sizeof(elf_ex)) != sizeof(elf_ex))
		errx(1, "can't read elf header");

	if (!IS_ELF(elf_ex))
		errx(1, "bad elf magic");

	elf_size = lseek(fd, (off_t)0, SEEK_END);
	(void)lseek(fd, (off_t)0, SEEK_SET);
	elf_total = emalloc((size_t)elf_size);

	if (read(fd, elf_total, (size_t)elf_size) != elf_size)
		errx(1, "can't read elf kernel");

	elf_phdr = (Elf_Phdr *)&elf_total[elf_ex.e_phoff];
	elf_shdr = (Elf_Shdr *)&elf_total[elf_ex.e_shoff];

	elf_shstrtab = &elf_total[elf_shdr[elf_ex.e_shstrndx].sh_offset];

	close(fd);
}

void
elf_savekernel(const char *outfile)
{
	int fd;

	if ((fd = open(outfile, O_WRONLY | O_CREAT | O_TRUNC, 0755)) < 0)
		err(1, "%s", outfile);

	if (write(fd, elf_total, (size_t)elf_size) != elf_size)
		errx(1, "can't write file %s", outfile);

	close(fd);
}
@


1.3
log
@warning cleanup
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/usr.sbin/config/exec_elf.c,v 1.2 2007/02/19 03:11:20 tg Exp $");
d53 3
a55 3
int		elf_check(char *);
void		elf_loadkernel(char *);
void		elf_savekernel(char *);
d102 1
a102 1
elf_check(char *file)
d122 1
a122 1
elf_loadkernel(char *file)
d151 1
a151 1
elf_savekernel(char *outfile)
@


1.2
log
@rcsids
@
text
@d41 1
a41 1
__RCSID("$MirOS$");
d92 2
a93 2
		if (((x - elf_total) >= s[i].sh_offset) &&
		    ((x - elf_total) <= (s[i].sh_offset + s[i].sh_size)))
@


1.1
log
@Initial revision
@
text
@a26 4
#ifndef LINT
static char rcsid[] = "$OpenBSD: exec_elf.c,v 1.10 2004/01/04 18:30:05 deraadt Exp $";
#endif

d41 2
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@
