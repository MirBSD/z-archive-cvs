head	1.24;
access;
symbols
	tg-ntpd-sigusr1-branch:1.16.0.2
	MIRBSD_10:1.14.0.2
	MIRBSD_10_BASE:1.14
	MIRBSD_9_BASE:1.8
	MIRBSD_8:1.8.0.2
	MIRBSD_8_BASE:1.8
	cvs-200512032330:1.1.1.5
	cvs-200510270930:1.1.1.5
	cvs-200507211800:1.1.1.4
	cvs-200504291700:1.1.1.3
	cvs-200504141900:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2014.03.13.05.48.25;	author tg;	state Exp;
branches;
next	1.23;
commitid	100532146A3061EE0CD;

1.23
date	2014.03.12.23.43.00;	author tg;	state Exp;
branches;
next	1.22;
commitid	1005320F11C6DC81D52;

1.22
date	2013.10.31.20.07.28;	author tg;	state Exp;
branches;
next	1.21;
commitid	1005272B7081B0E5655;

1.21
date	2011.11.21.20.49.38;	author tg;	state Exp;
branches;
next	1.20;
commitid	1004ECAB97840AE2593;

1.20
date	2011.01.30.03.06.04;	author tg;	state Exp;
branches;
next	1.19;
commitid	1004D44D5A76D4F4A64;

1.19
date	2009.12.24.11.40.38;	author tg;	state Exp;
branches;
next	1.18;
commitid	1004B3351E651CE01AF;

1.18
date	2009.05.07.19.09.37;	author tg;	state Exp;
branches;
next	1.17;
commitid	1004A0331C965150DFC;

1.17
date	2008.06.04.18.28.37;	author tg;	state Exp;
branches;
next	1.16;
commitid	1004846DED961752C7C;

1.16
date	2008.06.04.16.56.26;	author tg;	state Exp;
branches
	1.16.2.1;
next	1.15;
commitid	1004846C9477B3D8195;

1.15
date	2008.05.13.12.20.06;	author tg;	state Exp;
branches;
next	1.14;
commitid	10048298767192BDE03;

1.14
date	2007.10.08.12.04.33;	author tg;	state Exp;
branches;
next	1.13;
commitid	100470A1C1009540C55;

1.13
date	2007.10.03.22.52.58;	author tg;	state Exp;
branches;
next	1.12;
commitid	10047041D4B1252A4C1;

1.12
date	2007.10.03.21.08.13;	author tg;	state Exp;
branches;
next	1.11;
commitid	100470404CE4044E2A1;

1.11
date	2007.07.31.20.32.47;	author tg;	state Exp;
branches;
next	1.10;
commitid	10046AF9C7520F41804;

1.10
date	2007.07.31.19.57.02;	author tg;	state Exp;
branches;
next	1.9;
commitid	10046AF9304601393BC;

1.9
date	2006.08.12.23.53.35;	author tg;	state Exp;
branches;
next	1.8;
commitid	10044DE6A0737B2F23F;

1.8
date	2005.12.04.14.14.47;	author tg;	state Exp;
branches;
next	1.7;
commitid	2c8c4392f9e1e19a;

1.7
date	2005.10.27.10.44.01;	author tg;	state Exp;
branches;
next	1.6;
commitid	51004360af7d9055;

1.6
date	2005.10.27.09.35.29;	author tg;	state Exp;
branches;
next	1.5;
commitid	30b343609f776f28;

1.5
date	2005.07.26.12.40.45;	author tg;	state Exp;
branches;
next	1.4;
commitid	95b42e62f3df8e2;

1.4
date	2005.04.29.18.35.13;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2005.04.14.21.18.48;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.13.19.17.10;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.30.58;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.16.2.1
date	2008.06.04.17.51.00;	author tg;	state Exp;
branches;
next	1.16.2.2;
commitid	1004846D5E55DFD9109;

1.16.2.2
date	2008.06.04.18.20.08;	author tg;	state Exp;
branches;
next	1.16.2.3;
commitid	1004846DCE717AD9058;

1.16.2.3
date	2008.06.04.18.21.57;	author tg;	state Exp;
branches;
next	;
commitid	1004846DD580C13F66D;

1.1.1.1
date	2005.02.05.17.30.58;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.14.21.05.29;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.04.29.17.06.47;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2005.07.21.21.03.20;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	560042e0092f571e;

1.1.1.5
date	2005.10.27.09.33.17;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	734143609eed10f3;

1.1.1.6
date	2007.10.03.21.02.42;	author tg;	state Exp;
branches;
next	;
commitid	1004704037C0828759F;


desc
@@


1.24
log
@meh, stop already with exposing libc interna like that
just invent our own private interface for RNG state hackery if needed
@
text
@/**	$MirOS: src/usr.sbin/ntpd/ntpd.h,v 1.23 2014/03/12 23:43:00 tg Exp $ */
/*	$OpenBSD: ntpd.h,v 1.70 2006/06/04 18:58:13 otto Exp $ */

/*
 * Copyright © 2007, 2008, 2009, 2011, 2013, 2014
 *	Thorsten “mirabilos” Glaser <tg@@mirbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/uio.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <sys/time.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <stdarg.h>
#include <stdbool.h>

#include "ntp.h"

#define	NTPD_USER	"_ntp"
#define	CONFFILE	"/etc/ntpd.conf"

#define	READ_BUF_SIZE		4096

#define	NTPD_OPT_VERBOSE	0x0001
#define	NTPD_OPT_VERBOSE2	0x0002

#define	INTERVAL_QUERY_NORMAL		30	/* sync to peers every n secs */
#define	INTERVAL_QUERY_PATHETIC		60
#define	INTERVAL_QUERY_AGRESSIVE	5

#define	TRUSTLEVEL_BADPEER		6
#define	TRUSTLEVEL_PATHETIC		2
#define	TRUSTLEVEL_AGRESSIVE		8
#define	TRUSTLEVEL_MAX			10
#define	TRUSTLEVEL_RESET		(TRUSTLEVEL_AGRESSIVE - 1)

#define	MAX_SERVERS_DNS			8

#define	QSCALE_OFF_MIN			0.05
#define	QSCALE_OFF_MAX			0.50

#define	QUERYTIME_MAX		15	/* single query might take n secs max */
#define	OFFSET_ARRAY_SIZE	4	/* min. 3, recommended 6, max. 8 */
#define	SETTIME_MIN_OFFSET	180	/* min offset for settime at start */
#define	SETTIME_TIMEOUT		15	/* max seconds to wait with -s */
#define	LOG_NEGLIGEE		125	/* negligible drift to not log (ms) */

/**
 * While various sources state that the delay can never be negative,
 * here is an example where it actually can be, with good reason:
 *
 * Assume an NTP server with a low- to medium precision clock (for
 * purposes of this example, we assume 10 ms), and an NTP client
 * with a high-precision clock. Assume they sit on a LAN which has
 * a transaction time of 1 ms. They are 100 ms apart initially. We
 * can observe the following sample values over two requests with
 * no adjustment applied in between:
 *
 *		Request 1	Request 2	Comment
 * T1		1000		2000
 * T2		1101		2101		In Req2, a tick increasement
 * T3		1101		2111		happens between T2 and T3
 * T4		1002		2002
 *
 * This leaves us with the following results:
 * Req1:	d =  2		t = 100		v =  2
 * Req2:	d = -8		t = 105		v = -8
 *
 * According to Mark Martinec, the true delay can only be observed
 * by averaging delays, including negative ones. However, if one end
 * is a VM or another low-resolution device, and the other end has
 * a HPET or similar, chances are that most replies have negative
 * delays. For this reason, MirBSD OpenNTPD 2009-12-24 ignores delays
 * below DELAY_NEGLIGEE which defaults to 10 ms (keep it over 1 ms to
 * accomodate systems without sub-millisecond precision), as most sy-
 * stems use 100 Hz ticks; set to 0 to revert to the previous behaviour.
 */
#define DELAY_NEGLIGEE	(-0.010)	/* minimum xfer delay accepted */


enum client_state {
	STATE_NONE,
	STATE_DNS_INPROGRESS,
	STATE_DNS_TEMPFAIL,
	STATE_DNS_DONE,
	STATE_QUERY_SENT,
	STATE_REPLY_RECEIVED
};

struct listen_addr {
	TAILQ_ENTRY(listen_addr)	 entry;
	struct sockaddr_storage		 sa;
	int				 fd;
};

struct ntp_addr {
	struct ntp_addr		*next;
	struct sockaddr_storage	 ss;
};

struct ntp_addr_wrap {
	char			*name;
	struct ntp_addr		*a;
	u_int8_t		 pool;
};

struct ntp_status {
	double		rootdelay;
	double		rootdispersion;
	double		reftime;
	u_int32_t	refid;
	u_int32_t	refid4;
	u_int8_t	synced;
	u_int8_t	leap;
	int8_t		precision;
	u_int8_t	poll;
	u_int8_t	stratum;
};

struct ntp_offset {
	struct ntp_status	status;
	double			offset;
	double			delay;
	double			error;
	time_t			rcvd;
	int			good;
};

struct ntp_peer {
	TAILQ_ENTRY(ntp_peer)		 entry;
	struct ntp_addr_wrap		 addr_head;
	struct ntp_addr			*addr;
	struct ntp_query		*query;
	struct ntp_offset		 reply[OFFSET_ARRAY_SIZE];
	struct ntp_offset		 update;
	time_t				 next;
	time_t				 deadline;
	int				 lasterror;
	enum client_state		 state;
	u_int32_t			 id;
	u_int8_t			 shift;
	u_int8_t			 trustlevel;
	u_int8_t			 stratum_offset;
};

struct ntpd_conf {
	TAILQ_HEAD(listen_addrs, listen_addr)	listen_addrs;
	TAILQ_HEAD(ntp_peers, ntp_peer)		ntp_peers;
	struct ntp_status			status;
	u_int32_t				scale;
	u_int8_t				listen_all;
	u_int8_t				settime;
	u_int8_t				debug;
	u_int8_t				trace;
};

struct buf {
	TAILQ_ENTRY(buf)	 entry;
	u_char			*buf;
	size_t			 size;
	size_t			 wpos;
	size_t			 rpos;
};

struct msgbuf {
	TAILQ_HEAD(, buf)	 bufs;
	u_int32_t		 queued;
	int			 fd;
};

struct buf_read {
	size_t			 wpos;
	u_char			 buf[READ_BUF_SIZE];
	u_char			*rptr;
};

/* ipc messages */

#define	IMSG_HEADER_SIZE	sizeof(struct imsg_hdr)
#define	MAX_IMSGSIZE		8192

struct imsgbuf {
	int			fd;
	pid_t			pid;
	struct buf_read		r;
	struct msgbuf		w;
};

enum imsg_type {
	IMSG_NONE,
	IMSG_RESET,
	IMSG_ADJTIME,
	IMSG_SETTIME,
	IMSG_HOST_DNS
};

struct imsg_hdr {
	enum imsg_type	type;
	u_int32_t	peerid;
	pid_t		pid;
	u_int16_t	len;
};

struct imsg {
	struct imsg_hdr	 hdr;
	void		*data;
};

/* prototypes */
/* log.c */
void		 log_init(int);
void		 vlog(int, const char *, va_list)
    __attribute__((__format__(__syslog__, 2, 0)))
    __attribute__((__format__(__printf__, 2, 0)))
    __attribute__((__nonnull__(2)));
void		 log_warn(const char *, ...)
    __attribute__((__format__(__syslog__, 1, 2)))
    __attribute__((__format__(__printf__, 1, 2)))
    __attribute__((__nonnull__(1)));
void		 log_warnx(const char *, ...)
    __attribute__((__format__(__syslog__, 1, 2)))
    __attribute__((__format__(__printf__, 1, 2)))
    __attribute__((__nonnull__(1)));
void		 log_info(const char *, ...)
    __attribute__((__format__(__syslog__, 1, 2)))
    __attribute__((__format__(__printf__, 1, 2)))
    __attribute__((__nonnull__(1)));
void		 log_debug(const char *, ...)
    __attribute__((__format__(__syslog__, 1, 2)))
    __attribute__((__format__(__printf__, 1, 2)))
    __attribute__((__nonnull__(1)));
__dead void	 fatal(const char *);
__dead void	 fatalx(const char *);

/* buffer.c */
struct buf	*buf_open(size_t);
int		 buf_add(struct buf *, void *, size_t);
int		 buf_close(struct msgbuf *, struct buf *);
void		 buf_free(struct buf *);
void		 msgbuf_init(struct msgbuf *);
void		 msgbuf_clear(struct msgbuf *);
int		 msgbuf_write(struct msgbuf *);

/* imsg.c */
void	 imsg_init(struct imsgbuf *, int);
int	 imsg_read(struct imsgbuf *);
int	 imsg_get(struct imsgbuf *, struct imsg *);
int	 imsg_compose(struct imsgbuf *, enum imsg_type, u_int32_t, pid_t,
	    void *, u_int16_t);
struct buf	*imsg_create(struct imsgbuf *, enum imsg_type, u_int32_t, pid_t,
		    u_int16_t);
int	 imsg_add(struct buf *, void *, u_int16_t);
int	 imsg_close(struct imsgbuf *, struct buf *);
void	 imsg_free(struct imsg *);

/* ntp.c */
pid_t	 ntp_main(int[2], struct ntpd_conf *);
int	 priv_adjtime(void);
void	 priv_settime(double);
void	 priv_host_dns(char *, u_int32_t);
void	 chpeertrust(struct ntp_peer *, bool);

/* parse.y */
int	 parse_config(const char *, struct ntpd_conf *);

/* config.c */
int		 host(const char *, struct ntp_addr **);
int		 host_dns(const char *, struct ntp_addr **);
struct ntp_peer	*new_peer(void);

/* ntp_msg.c */
int	ntp_getmsg(struct sockaddr *, char *, ssize_t, struct ntp_msg *);
int	ntp_sendmsg(int, struct sockaddr *, struct ntp_msg *, ssize_t, int);

/* server.c */
int	setup_listeners(struct servent *, struct ntpd_conf *, u_int *);
int	ntp_reply(int, struct sockaddr *, struct ntp_msg *, int);
int	server_dispatch(int, struct ntpd_conf *);

/* client.c */
int	client_peer_init(struct ntp_peer *);
int	client_addr_init(struct ntp_peer *);
int	client_nextaddr(struct ntp_peer *);
int	client_query(struct ntp_peer *);
int	client_dispatch(struct ntp_peer *, u_int8_t, uint8_t);
void	client_log_error(struct ntp_peer *, const char *, int);
void	update_scale(double);
time_t	scale_interval(time_t);
time_t	error_interval(void);
void	set_next(struct ntp_peer *, time_t);

/* util.c */
void			d_to_tv(double, struct timeval *);
double			lfp_to_d(struct l_fixedpt);
struct l_fixedpt	d_to_lfp(double);
double			sfp_to_d(struct s_fixedpt);
struct s_fixedpt	d_to_sfp(double);

/* ../rdate/cutil.c */
const char *log_sockaddr(struct sockaddr *);
double gettime(void);
@


1.23
log
@stop using arc4random_stir in ntpd; same hack as in init
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/ntpd/ntpd.h,v 1.22 2013/10/31 20:07:28 tg Exp $ */
a226 10
/*
 * We are allowed to do this, says mirabilos.
 */
extern void arc4random_stir_locked(pid_t);
#define arc4random_stir_lcl() do {	\
	_ARC4_LOCK();			\
	arc4random_stir_locked(0);	\
	_ARC4_UNLOCK();			\
} while (/* CONSTCOND */ 0)

@


1.22
log
@adapt most __attribute__((…)) occurrences to new KNF style(9)
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/ntpd/ntpd.h,v 1.21 2011/11/21 20:49:38 tg Exp $ */
d5 1
a5 1
 * Copyright © 2007, 2008, 2009, 2011, 2013
d227 10
@


1.21
log
@refactoro
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/ntpd/ntpd.h,v 1.20 2011/01/30 03:06:04 tg Exp $ */
d5 2
a6 1
 * Copyright (c) 2007, 2008, 2009, 2011 Thorsten Glaser <tg@@mirbsd.org>
d231 3
a233 3
    __attribute__((format (syslog, 2, 0)))
    __attribute__((format (printf, 2, 0)))
    __attribute__((nonnull (2)));
d235 3
a237 3
    __attribute__((format (syslog, 1, 2)))
    __attribute__((format (printf, 1, 2)))
    __attribute__((nonnull (1)));
d239 3
a241 3
    __attribute__((format (syslog, 1, 2)))
    __attribute__((format (printf, 1, 2)))
    __attribute__((nonnull (1)));
d243 3
a245 3
    __attribute__((format (syslog, 1, 2)))
    __attribute__((format (printf, 1, 2)))
    __attribute__((nonnull (1)));
d247 3
a249 3
    __attribute__((format (syslog, 1, 2)))
    __attribute__((format (printf, 1, 2)))
    __attribute__((nonnull (1)));
@


1.20
log
@most systems use 100 Hz; from reading logs, this sounds acceptable
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/ntpd/ntpd.h,v 1.19 2009/12/24 11:40:38 tg Exp $ */
a250 1
const char *	 log_sockaddr(struct sockaddr *);
a309 1
double			gettime(void);
d315 4
@


1.19
log
@There is a reason why negative delays can happen, outlined in the comments
and http://lists.ntp.isc.org/pipermail/hackers/2003-September/000349.html

Work around by allowing a certain amount of negative delay as minimum per-
mitted delay, so systems with a PXA27x or VM on one side and a 64-bit HPET
Linux system on the other side can still work together. The minimum chosen
was minus one millisecond, to accomodate systems without a sub-millisecond
precision timekeep; the amount needed for VMs is undefined, for PXA27x see
http://www.mail-archive.com/misc%40openbsd.org/msg02393.html and TFM.

This change should significantly improve reaction of OpenNTPD once ported
to my DEB and RPM builds. However, #380737 (Debian) is still an issue; I
guess the adjustment syscalls fail to accept larger values, but wonder how
xntpd manages that (although it fails as well often enough).

This research driven by tarent GmbH and need for working time on domUs.
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/ntpd/ntpd.h,v 1.18 2009/05/07 19:09:37 tg Exp $ */
d5 1
a5 1
 * Copyright (c) 2007, 2008, 2009 Thorsten Glaser <tg@@mirbsd.org>
d91 3
a93 3
 * below DELAY_NEGLIGEE which defaults to 1 ms (to accomodate systems
 * without sub-millisecond precision); set to 0 to revert to the pre-
 * vious behaviour.
d95 1
a95 1
#define DELAY_NEGLIGEE	(-0.001)	/* minimum xfer delay accepted */
@


1.18
log
@experimental (but tested): track the total # of valid peers
so that things like ntpmonitor can restart ntpd if it has
been down to 0 valid peers for 5 minutes or so

XXX need to debug what I believe is internal data structure corruption
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/ntpd/ntpd.h,v 1.17 2008/06/04 18:28:37 tg Exp $ */
d65 33
@


1.17
log
@merge and add some (yet commented out) stuff to catch invalid IMSGs
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/ntpd/ntpd.h,v 1.16.2.3 2008/06/04 18:21:57 tg Exp $ */
d5 1
a5 1
 * Copyright (c) 2007, 2008 Thorsten Glaser <tg@@mirbsd.org>
d32 1
d246 1
@


1.16
log
@sort the struct slots by size, to avoid some padding
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/ntpd/ntpd.h,v 1.15 2008/05/13 12:20:06 tg Exp $ */
d51 1
d174 1
@


1.16.2.1
log
@experimental support for resetting the peers, until SIGHUP is in:
- currently, you must SIGUSR1 the child
- currently, if you SIGUSR1 the parent, ntpd exits in error
- the trustlevel isn't correctly re-set
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/ntpd/ntpd.h,v 1.16 2008/06/04 16:56:26 tg Exp $ */
a50 1
#define	TRUSTLEVEL_RESET		(TRUSTLEVEL_AGRESSIVE - 2)
@


1.16.2.2
log
@attempt to use IMSG and have parent handle things
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/ntpd/ntpd.h,v 1.16.2.1 2008/06/04 17:51:00 tg Exp $ */
a173 1
	IMSG_RESET,
@


1.16.2.3
log
@only burst twice
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/ntpd/ntpd.h,v 1.16.2.2 2008/06/04 18:20:08 tg Exp $ */
d51 1
a51 1
#define	TRUSTLEVEL_RESET		(TRUSTLEVEL_AGRESSIVE - 1)
@


1.15
log
@Improve accuracy (and maybe speed, despite running the loop twice now) of
the algorithm that calculates the adjustment delta slightly (I hope) by
reducing the number of floating point operations
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/ntpd/ntpd.h,v 1.14 2007/10/08 12:04:33 tg Exp $ */
a117 1
	enum client_state		 state;
d120 2
d125 1
a125 2
	uint8_t				 stratum_offset;
	int				 lasterror;
d132 1
d136 1
a136 2
	uint8_t					trace;
	u_int32_t				scale;
@


1.14
log
@reduce the number of probes in the clock filter down to 4, so that adjtime
is called at least approx. 3 times a hour, greatly helping us to reduce the
size of the spikes for systems with clock drift (but increasing susceptibi-
lity to latency-induced low-quality responses)

tested on herc/rant with a value of 3 (adjust about 4 times an hour)

XXX this should be made an ntpd.conf option instead of a define ASAP
XXX this should be reverted once we have adjfreq(2)
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/ntpd/ntpd.h,v 1.13 2007/10/03 22:52:58 tg Exp $ */
d5 1
a5 1
 * Copyright (c) 2007 Thorsten Glaser <tg@@mirbsd.org>
d108 1
a108 1
	u_int8_t		good;
@


1.13
log
@reduce number of queries to pick the best from,
in order to make ntpd(8) adjtime(2) more often…
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/ntpd/ntpd.h,v 1.12 2007/10/03 21:08:13 tg Exp $ */
d58 1
a58 1
#define	OFFSET_ARRAY_SIZE	6
@


1.12
log
@merge and beautify
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/ntpd/ntpd.h,v 1.11 2007/07/31 20:32:47 tg Exp $ */
d58 1
a58 1
#define	OFFSET_ARRAY_SIZE	8
@


1.11
log
@rejoice! tracing! use -t for adjtime tracing, -tt for recv tracing too
@
text
@d1 2
a2 2
/**	$MirOS: src/usr.sbin/ntpd/ntpd.h,v 1.10 2007/07/31 19:57:02 tg Exp $ */
/*	$OpenBSD: ntpd.h,v 1.61 2005/09/24 00:32:03 dtucker Exp $ */
d240 1
a240 1
void	 priv_adjtime(void);
@


1.10
log
@introduce a most controversial feature (that's why not even documented):
the “serverloop” keyword.

What it does: act like “server” except that the stratum isn't, like nor-
mally when the peer's stratum is taken for our reply, increased by one.

What its use is: Imagine a home network of ≥2 boxen, connected to the
outside via a shared uplink (possibly IPv4 and IPv6, or two uplinks).
The boxen will each (this part is important!) configure at least one¹
server from outside using “server”, as usual, and each other (i.e. them-
selves, the boxen from the same LAN) using “serverloop” to stay syncho-
nised if the uplink(s) go away without having the stratum go rooftop.
¹) Using either 2 or 3 (or an even higher number) to make the total
number of usable servers odd (i.e. not even) is highly suggested.

Why people will hate me for it: it violates the (S)NTP RFCs.

What you should do instead of using it: get an udcf(4) or mbg(4) device
and do a local master using the sensors framework. Oops. Well, soonish.
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/ntpd/ntpd.h,v 1.9 2006/08/12 23:53:35 tg Exp $ */
d135 1
d266 1
a266 1
int	client_dispatch(struct ntp_peer *, u_int8_t);
@


1.9
log
@__CRAZY=Yes cleanliness. Really crazy in this case. Use subset, gcc!
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/ntpd/ntpd.h,v 1.8 2005/12/04 14:14:47 tg Exp $ */
d5 1
d124 1
@


1.8
log
@remove "quiet mode" again, it's not really needed and only bloats
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/ntpd/ntpd.h,v 1.6 2005/10/27 09:35:29 tg Exp $ */
d191 1
d195 1
d199 1
d203 1
d207 1
@


1.7
log
@first attempt at a "quiet mode"
@
text
@d60 1
a60 2
#define	LOG_NEGLIGEE1		125	/* negligible drift to not log (ms) */
#define	LOG_NEGLIGEE2		2000	/* same for quiet mode */
@


1.6
log
@merge
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/ntpd/ntpd.h,v 1.5 2005/07/26 12:40:45 tg Exp $ */
d60 2
a61 1
#define	LOG_NEGLIGEE		125	/* negligible drift to not log (ms) */
@


1.5
log
@* merge OpenBSD
* clean up
* bring back not logging of minimal adjustments unless debug
* format spring cleanup
* passes __CRAZY build now
@
text
@d1 2
a2 2
/**	$MirOS: src/usr.sbin/ntpd/ntpd.h,v 1.4 2005/04/29 18:35:13 tg Exp $ */
/*	$OpenBSD: ntpd.h,v 1.59 2005/07/15 03:37:15 henning Exp $ */
d94 1
d245 1
a245 1
int	ntp_getmsg(char *, ssize_t, struct ntp_msg *);
@


1.4
log
@(tentative) merge, more to come
@
text
@d1 2
a2 2
/**	$MirOS: src/usr.sbin/ntpd/ntpd.h,v 1.3 2005/04/14 21:18:48 tg Exp $ */
/*	$OpenBSD: ntpd.h,v 1.55 2005/04/26 15:18:22 henning Exp $ */
d37 1
a37 1
#define	READ_BUF_SIZE		65535
d59 2
d64 3
d93 1
d189 17
a205 7
void		 vlog(int, const char *, va_list);
void		 log_warn(const char *, ...);
void		 log_warnx(const char *, ...);
void		 log_info(const char *, ...);
void		 log_debug(const char *, ...);
void		 fatal(const char *);
void		 fatalx(const char *);
@


1.3
log
@merge and reduce diff
@
text
@d1 2
a2 2
/**	$MirOS: src/usr.sbin/ntpd/ntpd.h,v 1.2 2005/03/13 19:17:10 tg Exp $ */
/*	$OpenBSD: ntpd.h,v 1.54 2005/03/23 10:42:04 henning Exp $ */
d130 1
a130 1
	TAILQ_ENTRY(buf)	 entries;
d138 1
a138 1
	TAILQ_HEAD(bufs, buf)	 bufs;
@


1.2
log
@fast merge src/usr.sbin
@
text
@d1 2
a2 2
/**	$MirOS$ */
/*	$OpenBSD: ntpd.h,v 1.48 2004/12/16 00:38:59 dtucker Exp $ */
d42 3
a44 5
#define INTERVAL_MANIPULATOR		(4 - (rand() / (RAND_MAX >> 3)))
/* sync to peers every n secs */
#define	INTERVAL_QUERY_NORMAL		(30 + INTERVAL_MANIPULATOR)
#define	INTERVAL_QUERY_PATHETIC		(60 + INTERVAL_MANIPULATOR)
#define	INTERVAL_QUERY_AGRESSIVE	(5 + (INTERVAL_MANIPULATOR / 3))
d116 1
d126 1
d132 3
a134 3
	ssize_t			 size;
	ssize_t			 wpos;
	ssize_t			 rpos;
d144 1
a144 1
	ssize_t			 wpos;
d193 2
a194 2
struct buf	*buf_open(ssize_t);
int		 buf_add(struct buf *, void *, ssize_t);
d242 5
@


1.1
log
@Initial revision
@
text
@d1 1
d42 5
a46 3
#define	INTERVAL_QUERY_NORMAL		30	/* sync to peers every n secs */
#define	INTERVAL_QUERY_PATHETIC		60
#define	INTERVAL_QUERY_AGRESSIVE	5
a60 1
#define	LOG_NEGLIGEE		128	/* negligible drift to not log (ms) */
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@we like OpenNTPD so much we want to have current one
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.54 2005/03/23 10:42:04 henning Exp $ */
a115 1
	int				 lasterror;
a124 1
	u_int32_t				scale;
d130 3
a132 3
	size_t			 size;
	size_t			 wpos;
	size_t			 rpos;
d142 1
a142 1
	size_t			 wpos;
d191 2
a192 2
struct buf	*buf_open(size_t);
int		 buf_add(struct buf *, void *, size_t);
a239 5
void	client_log_error(struct ntp_peer *, const char *, int);
void	update_scale(double);
time_t	scale_interval(time_t);
time_t	error_interval(void);
void	set_next(struct ntp_peer *, time_t);
@


1.1.1.3
log
@improve my Frankenstein OS (*wink* you know who you are) further
sans wchar_t of course

this is the essence of reading >1200 commit messages which suck
due to not having the new format of ours...
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.55 2005/04/26 15:18:22 henning Exp $ */
d130 1
a130 1
	TAILQ_ENTRY(buf)	 entry;
d138 1
a138 1
	TAILQ_HEAD(, buf)	 bufs;
@


1.1.1.4
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.59 2005/07/15 03:37:15 henning Exp $ */
d36 1
a36 1
#define	READ_BUF_SIZE		4096
a57 1
#define	SETTIME_TIMEOUT		15	/* max seconds to wait with -s */
a61 3
	STATE_DNS_INPROGRESS,
	STATE_DNS_TEMPFAIL,
	STATE_DNS_DONE,
a87 1
	u_int32_t	refid4;
@


1.1.1.5
log
@current OpenNTPD
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.61 2005/09/24 00:32:03 dtucker Exp $ */
a92 1
	u_int8_t	synced;
d233 1
a233 1
int	ntp_getmsg(struct sockaddr *, char *, ssize_t, struct ntp_msg *);
@


1.1.1.6
log
@   Revision [134]1.70 / ([135]download) - [136]annotate - [137][select for diffs] , Sun Jun 4 18:58:13 2006
   UTC (15 months, 4 weeks ago) by otto
Only invalidate stored replies if an adjustment was really made.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.h,v 1.70 2006/06/04 18:58:13 otto Exp $ */
d221 1
a221 1
int	 priv_adjtime(void);
@


