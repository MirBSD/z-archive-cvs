head	1.23;
access;
symbols
	tg-ntpd-sigusr1-branch:1.17.0.2
	MIRBSD_10:1.16.0.2
	MIRBSD_10_BASE:1.16
	MIRBSD_9_BASE:1.9
	MIRBSD_8:1.9.0.2
	MIRBSD_8_BASE:1.9
	cvs-200512032330:1.1.1.5
	cvs-200510270930:1.1.1.5
	cvs-200507211800:1.1.1.4
	cvs-200504291700:1.1.1.3
	cvs-200504141900:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2014.03.13.05.48.24;	author tg;	state Exp;
branches;
next	1.22;
commitid	100532146A3061EE0CD;

1.22
date	2014.03.12.23.43.00;	author tg;	state Exp;
branches;
next	1.21;
commitid	1005320F11C6DC81D52;

1.21
date	2011.11.20.20.08.37;	author tg;	state Exp;
branches;
next	1.20;
commitid	1004EC95E5D0694C164;

1.20
date	2011.02.19.00.23.46;	author tg;	state Exp;
branches;
next	1.19;
commitid	1004D5F0D70761368B7;

1.19
date	2008.11.08.23.04.56;	author tg;	state Exp;
branches;
next	1.18;
commitid	10049161AB22DF5DFC5;

1.18
date	2008.06.04.18.28.36;	author tg;	state Exp;
branches;
next	1.17;
commitid	1004846DED961752C7C;

1.17
date	2008.05.13.20.50.00;	author tg;	state Exp;
branches
	1.17.2.1;
next	1.16;
commitid	1004829FF00045977FB;

1.16
date	2007.09.26.12.44.47;	author tg;	state Exp;
branches;
next	1.15;
commitid	10046FA54414A95A3AD;

1.15
date	2007.07.31.20.32.47;	author tg;	state Exp;
branches;
next	1.14;
commitid	10046AF9C7520F41804;

1.14
date	2007.04.16.19.03.10;	author tg;	state Exp;
branches;
next	1.13;
commitid	1004623C8853820E8B1;

1.13
date	2007.04.16.09.40.15;	author tg;	state Exp;
branches;
next	1.12;
commitid	1004623448D546EA9FF;

1.12
date	2007.02.08.01.27.38;	author tg;	state Exp;
branches;
next	1.11;
commitid	10045CA7CA10FCBD22E;

1.11
date	2006.08.12.23.41.27;	author tg;	state Exp;
branches;
next	1.10;
commitid	10044DE673905AFC437;

1.10
date	2006.08.12.23.39.40;	author tg;	state Exp;
branches;
next	1.9;
commitid	10044DE66CC31B511AE;

1.9
date	2005.12.04.14.14.47;	author tg;	state Exp;
branches;
next	1.8;
commitid	2c8c4392f9e1e19a;

1.8
date	2005.10.27.10.44.01;	author tg;	state Exp;
branches;
next	1.7;
commitid	51004360af7d9055;

1.7
date	2005.10.27.09.35.29;	author tg;	state Exp;
branches;
next	1.6;
commitid	30b343609f776f28;

1.6
date	2005.07.26.12.40.45;	author tg;	state Exp;
branches;
next	1.5;
commitid	95b42e62f3df8e2;

1.5
date	2005.04.29.18.35.13;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2005.04.14.21.18.48;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2005.03.28.21.32.23;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.13.19.17.10;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.30.58;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.17.2.1
date	2008.06.04.18.20.08;	author tg;	state Exp;
branches;
next	;
commitid	1004846DCE717AD9058;

1.1.1.1
date	2005.02.05.17.30.58;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.14.21.05.29;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.04.29.17.06.47;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2005.07.21.21.03.20;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	560042e0092f571e;

1.1.1.5
date	2005.10.27.09.33.16;	author tg;	state Exp;
branches;
next	;
commitid	734143609eed10f3;


desc
@@


1.23
log
@meh, stop already with exposing libc interna like that
just invent our own private interface for RNG state hackery if needed
@
text
@/*	$OpenBSD: ntpd.c,v 1.40 2005/09/06 21:27:10 wvdputte Exp $ */

/*-
 * Copyright (c) 2004, 2005, 2007, 2008, 2011, 2014
 *	Thorsten "mirabilos" Glaser <tg@@mirbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <netinet/in.h>
#include <errno.h>
#include <poll.h>
#include <pwd.h>
#include <resolv.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "ntpd.h"

__RCSID("$MirOS: src/usr.sbin/ntpd/ntpd.c,v 1.22 2014/03/12 23:43:00 tg Exp $");

extern void arc4random_ctl(unsigned int);

void		sighdlr(int);
__dead void	usage(void);
int		main(int, char *[]);
int		check_child(pid_t, const char *);
int		dispatch_imsg(struct ntpd_conf *);
void		reset_adjtime(void);
int		ntpd_adjtime(double, int);
void		ntpd_settime(double);

volatile sig_atomic_t	 quit = 0;
volatile sig_atomic_t	 reconfig = 0;
volatile sig_atomic_t	 sigchld = 0;
volatile sig_atomic_t	 sigusr1 = 0;
volatile sig_atomic_t	 arc4push = 0;
struct imsgbuf		*ibuf;

void
sighdlr(int sig)
{
	switch (sig) {
	case SIGTERM:
	case SIGINT:
		quit = 1;
		break;
	case SIGCHLD:
		sigchld = 1;
		arc4push = 1;
		break;
	case SIGHUP:
		reconfig = 1;
		arc4push = 1;
		break;
	case SIGUSR1:
		sigusr1 = 1;
		arc4push = 1;
		break;
	}
}

void
usage(void)
{
	extern const char *__progname;

	fprintf(stderr, "usage: %s [-dSst] [-f file]\n", __progname);
	exit(1);
}

#define POLL_MAX		8
#define PFD_PIPE		0

int
main(int argc, char *argv[])
{
	struct ntpd_conf	 conf;
	struct pollfd		 pfd[POLL_MAX];
	pid_t			 chld_pid = 0, pid;
	const char		*conffile;
	int			 ch, nfds, timeout = INFTIM;
	int			 pipe_chld[2];

	conffile = CONFFILE;

	bzero(&conf, sizeof(conf));

	log_init(1);		/* log to stderr until daemonized */
	res_init();		/* XXX */

	while ((ch = getopt(argc, argv, "df:sSt")) != -1) {
		switch (ch) {
		case 'd':
			conf.debug = 1;
			break;
		case 'f':
			conffile = optarg;
			break;
		case 's':
			conf.settime = 1;
			break;
		case 'S':
			conf.settime = 0;
			break;
		case 't':
			conf.trace++;
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	}

	if (parse_config(conffile, &conf))
		exit(1);

	if (geteuid()) {
		fprintf(stderr, "ntpd: need root privileges\n");
		exit(1);
	}

	if (getpwnam(NTPD_USER) == NULL) {
		fprintf(stderr, "ntpd: unknown user %s\n", NTPD_USER);
		exit(1);
	}
	endpwent();

	reset_adjtime();
	if (!conf.settime) {
		log_init(conf.debug);
		if (!conf.debug)
			if (daemon(1, 0))
				fatal("daemon");
	} else
		timeout = SETTIME_TIMEOUT * 1000;

	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_chld) == -1)
		fatal("socketpair");

	signal(SIGCHLD, sighdlr);
	/* fork child process */
	chld_pid = ntp_main(pipe_chld, &conf);

	setproctitle("[priv]");

	signal(SIGUSR1, sighdlr);
	signal(SIGTERM, sighdlr);
	signal(SIGINT, sighdlr);
	signal(SIGHUP, sighdlr);

	close(pipe_chld[1]);

	if ((ibuf = malloc(sizeof(struct imsgbuf))) == NULL)
		fatal(NULL);
	imsg_init(ibuf, pipe_chld[0]);

	while (quit == 0) {
		pfd[PFD_PIPE].fd = ibuf->fd;
		pfd[PFD_PIPE].events = POLLIN;
		if (ibuf->w.queued)
			pfd[PFD_PIPE].events |= POLLOUT;

		if ((nfds = poll(pfd, 1, timeout)) == -1)
			if (errno != EINTR) {
				log_warn("poll error");
				quit = 1;
			}

		if (nfds == 0 && conf.settime) {
			conf.settime = 0;
			timeout = INFTIM;
			log_init(conf.debug);
			log_debug("no reply received in time, skipping initial "
			    "time setting");
			if (!conf.debug)
				if (daemon(1, 0))
					fatal("daemon");
		}

		if (nfds > 0 && (pfd[PFD_PIPE].revents & POLLOUT))
			if (msgbuf_write(&ibuf->w) < 0) {
				log_warn("pipe write error (to child)");
				quit = 1;
			}

		if (nfds > 0 && pfd[PFD_PIPE].revents & POLLIN) {
			nfds--;
			if (dispatch_imsg(&conf) == -1)
				quit = 1;
		}

		if (arc4push) {
			arc4random_ctl(2);
			arc4push = 0;
		}

		if (sigchld) {
			if (check_child(chld_pid, "child")) {
				quit = 1;
				chld_pid = 0;
			}
			sigchld = 0;
		}

		if (sigusr1) {
			int n = 0;	/* maybe use 1 for SIGHUP? */

			log_info("throwing away all received deltas");
			imsg_compose(ibuf, IMSG_RESET, 0, 0, &n, sizeof (n));
			sigusr1 = 0;
		}
	}

	signal(SIGCHLD, SIG_DFL);

	if (chld_pid)
		kill(chld_pid, SIGTERM);

	do {
		if ((pid = wait(NULL)) == -1 &&
		    errno != EINTR && errno != ECHILD)
			fatal("wait");
	} while (pid != -1 || (pid == -1 && errno == EINTR));

	msgbuf_clear(&ibuf->w);
	free(ibuf);
	log_info("Terminating");
	return (0);
}

int
check_child(pid_t pid, const char *pname)
{
	int	 status, sig;
	const char *signame;

	if (waitpid(pid, &status, WNOHANG) > 0) {
		if (WIFEXITED(status)) {
			log_warnx("Lost child: %s exited", pname);
			return (1);
		}
		if (WIFSIGNALED(status)) {
			sig = WTERMSIG(status);
			signame = strsignal(sig) ? strsignal(sig) : "unknown";
			log_warnx("Lost child: %s terminated; signal %d (%s)",
			    pname, sig, signame);
			return (1);
		}
	}

	return (0);
}

int
dispatch_imsg(struct ntpd_conf *conf)
{
	struct imsg		 imsg;
	int			 n, cnt;
	double			 d;
	char			*name;
	struct ntp_addr		*h, *hn;
	struct buf		*buf;

	if ((n = imsg_read(ibuf)) == -1)
		return (-1);

	if (n == 0) {	/* connection closed */
		log_warnx("dispatch_imsg in main: pipe closed");
		return (-1);
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			return (-1);

		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_ADJTIME:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(d))
				fatalx("invalid IMSG_ADJTIME received");
			memcpy(&d, imsg.data, sizeof(d));
			n = ntpd_adjtime(d, conf->trace);
			imsg_compose(ibuf, IMSG_ADJTIME, 0, 0, &n, sizeof(n));
			break;
		case IMSG_SETTIME:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(d))
				fatalx("invalid IMSG_SETTIME received");
			if (!conf->settime)
				break;
			log_init(conf->debug);
			memcpy(&d, imsg.data, sizeof(d));
			ntpd_settime(d);
			/* daemonize now */
			if (!conf->debug)
				if (daemon(1, 0))
					fatal("daemon");
			conf->settime = 0;
			break;
		case IMSG_HOST_DNS:
			name = imsg.data;
			if (imsg.hdr.len < 1 + IMSG_HEADER_SIZE)
				fatalx("invalid IMSG_HOST_DNS received");
			imsg.hdr.len -= 1 + IMSG_HEADER_SIZE;
			if (name[imsg.hdr.len] != '\0' ||
			    strlen(name) != imsg.hdr.len)
				fatalx("invalid IMSG_HOST_DNS received");
			if ((cnt = host_dns(name, &hn)) == -1)
				break;
			buf = imsg_create(ibuf, IMSG_HOST_DNS,
			    imsg.hdr.peerid, 0,
			    cnt * sizeof(struct sockaddr_storage));
			if (buf == NULL)
				break;
			if (cnt > 0)
				for (h = hn; h != NULL; h = h->next)
					imsg_add(buf, &h->ss, sizeof(h->ss));

			imsg_close(ibuf, buf);
			break;
		case IMSG_RESET:
			log_warn("invalid IMSG_RESET received");
			break;
		default:
			break;
		}
		imsg_free(&imsg);
	}
	return (0);
}

void
reset_adjtime(void)
{
	struct timeval	tv;

	tv.tv_sec = 0;
	tv.tv_usec = 0;
	if (adjtime(&tv, NULL) == -1)
		log_warn("reset adjtime failed");
}

int
ntpd_adjtime(double d, int trace)
{
	struct timeval	tv, olddelta;
	double		o;
	int		synced = 0, rv;
	static int	firstadj = 1;

	d_to_tv(d, &tv);
	rv = adjtime(&tv, &olddelta);
	o = (double)olddelta.tv_sec + (double)olddelta.tv_usec / 1000000.;
	if (trace || d >= LOG_NEGLIGEE / 1000. || d <= LOG_NEGLIGEE / -1000.)
		log_info("adjusting local clock by %fs, old drift %fs", d, o);
	else
		log_debug("adjusting local clock by %fs, old drift %fs", d, o);
	if (rv == -1)
		log_warn("adjtime failed");
	else if (!firstadj && olddelta.tv_sec == 0 && olddelta.tv_usec == 0)
		synced = 1;
	firstadj = 0;
	return (synced);
}

void
ntpd_settime(double d)
{
	struct timeval	curtime, tv;
	char		buf[80];

	/* if the offset is small, don't call settimeofday */
	if (d < SETTIME_MIN_OFFSET && d > -SETTIME_MIN_OFFSET)
		return;

	d_to_tv(d, &tv);
	gettimeofday(&curtime, NULL);
	curtime.tv_sec += tv.tv_sec;
	curtime.tv_usec += tv.tv_usec;
	while (curtime.tv_usec > 999999) {
		curtime.tv_sec++;
		curtime.tv_usec -= 1000000;
	}

	if (settimeofday(&curtime, NULL) == -1) {
		log_warn("settimeofday");
		return;
	}
	strftime(buf, sizeof (buf), "%a %b %e %H:%M:%S %Z %Y",
	    localtime(&curtime.tv_sec));
	log_info("set local clock to %s (offset %fs)", buf, d);
}
@


1.22
log
@stop using arc4random_stir in ntpd; same hack as in init
@
text
@a35 1
#include "thread_private.h"
d37 3
a39 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntpd.c,v 1.21 2011/11/20 20:08:37 tg Exp $");
d211 1
a211 1
			arc4random_stir_lcl();
@


1.21
log
@convert to MirTime API
@
text
@d4 1
a4 1
 * Copyright (c) 2004, 2005, 2007, 2008, 2011
d36 1
d38 1
a38 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntpd.c,v 1.20 2011/02/19 00:23:46 tg Exp $");
d210 1
a210 1
			arc4random_stir();
@


1.20
log
@force arc4random_stir() (i.e. pushb_fast → kernel transfer) on SIGHUP
(and others), since init(8) issues that as first kill signal
@
text
@a22 1
#include <sys/taitime.h>
d37 1
a37 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntpd.c,v 1.19 2008/11/08 23:04:56 tg Exp $");
d386 1
a386 1
	struct timeval	curtime;
a387 1
	tai64na_t	t;
d393 8
a400 7
	d_to_tv(d, &curtime);
	taina_time(&t);
	curtime.tv_usec += t.nano / 1000 + /* borrow */ 1000000;
	curtime.tv_sec = tai2timet(utc2tai(tai2utc(t.secs)
	    + curtime.tv_sec - /* pay */ 1
	    + (curtime.tv_usec / 1000000)));
	curtime.tv_usec %= 1000000;
@


1.19
log
@more mass conversions, including ancient eMail addresses
@
text
@d4 1
a4 1
 * Copyright (c) 2004, 2005, 2007, 2008
d38 1
a38 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntpd.c,v 1.18 2008/06/04 18:28:36 tg Exp $");
d53 1
d66 1
d70 1
d74 1
d209 5
@


1.18
log
@merge and add some (yet commented out) stuff to catch invalid IMSGs
@
text
@d5 1
a5 1
 *	Thorsten "mirabilos" Glaser <tg@@66h.42h.de>
d38 1
a38 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntpd.c,v 1.17 2008/05/13 20:50:00 tg Exp $");
@


1.17
log
@if -t (tracing), also log adjustments smaller than the negligée
@
text
@d4 1
a4 1
 * Copyright (c) 2004, 2005, 2007
d38 1
a38 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntpd.c,v 1.16 2007/09/26 12:44:47 tg Exp $");
d52 1
d69 3
d159 1
d213 7
d330 3
@


1.17.2.1
log
@attempt to use IMSG and have parent handle things
@
text
@d4 1
a4 1
 * Copyright (c) 2004, 2005, 2007, 2008
d38 1
a38 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntpd.c,v 1.17 2008/05/13 20:50:00 tg Exp $");
a51 1
volatile sig_atomic_t	 sigusr1 = 0;
a67 3
	case SIGUSR1:
		sigusr1 = 1;
		break;
a154 1
	signal(SIGUSR1, sighdlr);
a207 7
		if (sigusr1) {
			int n = 0;	/* maybe use 1 for SIGHUP? */

			log_info("SIGUSR1 received");
			imsg_compose(ibuf, IMSG_RESET, 0, 0, &n, sizeof (n));
			sigusr1 = 0;
		}
a317 3
		case IMSG_RESET:
			log_warn("invalid IMSG_RESET received");
			break;
@


1.16
log
@• mention -dtt is redundant (-dt or -tt are ok)
• sync usage
@
text
@d38 1
a38 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntpd.c,v 1.15 2007/07/31 20:32:47 tg Exp $");
d46 1
a46 1
int		ntpd_adjtime(double);
d280 1
a280 1
			n = ntpd_adjtime(d);
d338 1
a338 1
ntpd_adjtime(double d)
d348 1
a348 1
	if (d >= LOG_NEGLIGEE / 1000. || d <= LOG_NEGLIGEE / -1000.)
@


1.15
log
@rejoice! tracing! use -t for adjtime tracing, -tt for recv tracing too
@
text
@d38 1
a38 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntpd.c,v 1.14 2007/04/16 19:03:10 tg Exp $");
d71 1
a71 1
__dead void
d76 1
a76 1
	fprintf(stderr, "usage: %s [-dSs] [-f file]\n", __progname);
@


1.14
log
@+const
@
text
@d38 1
a38 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntpd.c,v 1.13 2007/04/16 09:40:15 tg Exp $");
d100 1
a100 1
	while ((ch = getopt(argc, argv, "df:sS")) != -1) {
d114 3
@


1.13
log
@from openntpd:

Reset adjtime() on startup; having an adjtime() active while starting
up causes overcompensation and confusing debug log entries; noticed
@
text
@d38 1
a38 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntpd.c,v 1.12 2007/02/08 01:27:38 tg Exp $");
d74 1
a74 1
	extern char *__progname;
@


1.12
log
@missing <sys/taitime.h>
@
text
@a0 1
/**	$MirOS: src/usr.sbin/ntpd/ntpd.c,v 1.11 2006/08/12 23:41:27 tg Exp $ */
d38 1
a38 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntpd.c,v 1.11 2006/08/12 23:41:27 tg Exp $");
d45 1
d134 1
d323 11
@


1.11
log
@openbsd r1.41 - handle dns fail
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/ntpd/ntpd.c,v 1.10 2006/08/12 23:39:40 tg Exp $ */
d5 2
a6 2
 * Copyright (c) 2004, 2005
 *	Thorsten "mirabile" Glaser <tg@@66h.42h.de>
d24 1
d39 1
a39 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntpd.c,v 1.10 2006/08/12 23:39:40 tg Exp $");
@


1.10
log
@openbsd r1.44 - avoid child signal race
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/ntpd/ntpd.c,v 1.9 2005/12/04 14:14:47 tg Exp $ */
d38 1
a38 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntpd.c,v 1.9 2005/12/04 14:14:47 tg Exp $");
d300 2
a301 1
			cnt = host_dns(name, &hn);
@


1.9
log
@remove "quiet mode" again, it's not really needed and only bloats
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/ntpd/ntpd.c,v 1.7 2005/10/27 09:35:29 tg Exp $ */
d38 1
a38 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntpd.c,v 1.7 2005/10/27 09:35:29 tg Exp $");
d144 1
a151 1
	signal(SIGCHLD, sighdlr);
@


1.8
log
@first attempt at a "quiet mode"
@
text
@a51 1
int			 LOG_NEGLIGEE = LOG_NEGLIGEE1;
d99 1
a99 1
	while ((ch = getopt(argc, argv, "df:qsS")) != -1) {
a102 1
			LOG_NEGLIGEE = LOG_NEGLIGEE1;
a106 3
		case 'q':
			LOG_NEGLIGEE = LOG_NEGLIGEE2;
			break;
@


1.7
log
@merge
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/ntpd/ntpd.c,v 1.6 2005/07/26 12:40:45 tg Exp $ */
d38 1
a38 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntpd.c,v 1.6 2005/07/26 12:40:45 tg Exp $");
d52 1
d100 1
a100 1
	while ((ch = getopt(argc, argv, "df:sS")) != -1) {
d104 1
d109 3
@


1.6
log
@* merge OpenBSD
* clean up
* bring back not logging of minimal adjustments unless debug
* format spring cleanup
* passes __CRAZY build now
@
text
@d1 2
a2 2
/**	$MirOS: src/usr.sbin/ntpd/ntpd.c,v 1.5 2005/04/29 18:35:13 tg Exp $ */
/*	$OpenBSD: ntpd.c,v 1.39 2005/07/11 08:08:06 dtucker Exp $ */
d38 1
a38 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntpd.c,v 1.5 2005/04/29 18:35:13 tg Exp $");
d283 1
a286 1
			log_init(conf->debug);
@


1.5
log
@(tentative) merge, more to come
@
text
@d1 2
a2 2
/**	$MirOS: src/usr.sbin/ntpd/ntpd.c,v 1.4 2005/04/14 21:18:48 tg Exp $ */
/*	$OpenBSD: ntpd.c,v 1.35 2005/04/18 20:46:02 henning Exp $ */
d38 1
a38 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntpd.c,v 1.4 2005/04/14 21:18:48 tg Exp $");
d45 1
a45 1
void		ntpd_adjtime(double);
d139 1
a139 1
		timeout = 15 * 1000;
d176 2
a177 2
			log_debug("no reply received, skipping initial time "
			    "setting");
d225 2
a226 1
	int	status;
d234 4
a237 2
			log_warnx("Lost child: %s terminated; signal %d",
			    pname, WTERMSIG(status));
d275 2
a276 1
			ntpd_adjtime(d);
d300 8
a307 7
			if ((cnt = host_dns(name, &hn)) > 0) {
				buf = imsg_create(ibuf, IMSG_HOST_DNS,
				    imsg.hdr.peerid, 0,
				    cnt * sizeof(struct sockaddr_storage));
				if (buf == NULL)
					break;
				for (h = hn; h != NULL; h = h->next) {
d309 2
a310 3
				}
				imsg_close(ibuf, buf);
			}
d320 1
a320 1
void
d323 4
a326 2
	struct timeval	tv, otv;
	int		rv;
d329 6
a334 3
	rv = adjtime(&tv, &otv);
	log_info("adjusting local clock by %fs, old adjust %fs", d,
	    (double)otv.tv_sec + (double)otv.tv_usec / 1000000.);
d337 4
a353 4
	if (gettimeofday(&curtime, NULL) == -1) {
		log_warn("gettimeofday");
		return;
	}
d356 1
a356 1
	curtime.tv_usec += t.nano / 1000 + 1000000;
d358 2
a359 2
	    + curtime.tv_sec
	    - 1 + (curtime.tv_usec / 1000000)));
d366 1
a366 1
	strftime(buf, sizeof(buf), "%a %b %e %H:%M:%S %Z %Y",
@


1.4
log
@merge and reduce diff
@
text
@d1 2
a2 2
/**	$MirOS: src/usr.sbin/ntpd/ntpd.c,v 1.3 2005/03/28 21:32:23 tg Exp $ */
/*	$OpenBSD: ntpd.c,v 1.34 2005/03/31 17:02:43 henning Exp $ */
d38 1
a38 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntpd.c,v 1.3 2005/03/28 21:32:23 tg Exp $");
d290 5
a294 1
			if (imsg.hdr.len != strlen(name) + 1 + IMSG_HEADER_SIZE)
@


1.3
log
@tzset() now handles initialisation
@
text
@d1 2
a2 2
/**	$MirOS: src/usr.sbin/ntpd/ntpd.c,v 1.2 2005/03/13 19:17:10 tg Exp $ */
/*	$OpenBSD: ntpd.c,v 1.27 2004/12/22 16:04:11 henning Exp $ */
a25 1
#include <arpa/inet.h>
a26 1
#include <fcntl.h>
d29 1
d38 1
a38 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntpd.c,v 1.2 2005/03/13 19:17:10 tg Exp $");
d40 7
a46 7
void	sighdlr(int);
void	usage(void);
int	main(int, char *[]);
int	check_child(pid_t, const char *);
int	dispatch_imsg(struct ntpd_conf *);
void	ntpd_adjtime(double);
void	ntpd_settime(double);
d70 1
a70 1
void
a95 2
	srand((double)arc4random() / (((double)(0xFFFFFFFFUL)) / RAND_MAX));

d97 1
d136 2
a137 1
			daemon(1, 0);
d144 1
a144 1
	/* fork children */
a172 2
			log_debug("no reply received, skipping initial time "
			    "setting");
d176 2
d179 2
a180 1
				daemon(1, 0);
d270 1
a270 1
				fatal("invalid IMSG_ADJTIME received");
d276 1
a276 1
				fatal("invalid IMSG_SETTIME received");
d284 2
a285 1
				daemon(1, 0);
d291 1
a291 1
				fatal("invalid IMSG_HOST_DNS received");
d337 4
d343 9
a351 6
	t.secs = utc2tai(tai2utc(t.secs) + curtime.tv_sec);
	curtime.tv_sec = tai2timet(t.secs);
	curtime.tv_usec += t.nano / 1000;
	while (curtime.tv_usec > 1000000) {
		curtime.tv_sec++;
		curtime.tv_usec -= 1000000;
a352 2
	if (settimeofday(&curtime, NULL) == -1)
		log_warn("settimeofday");
@


1.2
log
@fast merge src/usr.sbin
@
text
@d1 1
a1 1
/**	$MirOS$ */
d4 2
a5 2
/*
 * Copyright (c) 2004
d39 1
a39 1
__RCSID("$MirOS$");
a96 1
	(void) tai_leaps();	/* initialise leap second table early */
@


1.1
log
@Initial revision
@
text
@d1 1
d5 2
d39 2
d97 3
d315 2
a316 1
	struct timeval	tv;
a317 5
	if (d >= (double)LOG_NEGLIGEE / 1000 ||
	    d <= -1 * (double)LOG_NEGLIGEE / 1000)
		log_info("adjusting local clock by %fs", d);
	else
		log_debug("adjusting local clock by %fs", d);
d319 4
a322 1
	if (adjtime(&tv, NULL) == -1)
d329 1
a329 1
	struct timeval	tv, curtime;
d331 1
a331 1
	time_t		tval;
d337 6
a342 6
	d_to_tv(d, &tv);
	if (gettimeofday(&curtime, NULL) == -1)
		log_warn("gettimeofday");
	curtime.tv_sec += tv.tv_sec;
	curtime.tv_usec += tv.tv_usec;
	if (curtime.tv_usec > 1000000) {
a347 1
	tval = curtime.tv_sec;
d349 1
a349 1
	    localtime(&tval));
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@we like OpenNTPD so much we want to have current one
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.34 2005/03/31 17:02:43 henning Exp $ */
d23 1
d25 1
a27 1
#include <resolv.h>
d36 7
a42 7
void		sighdlr(int);
__dead void	usage(void);
int		main(int, char *[]);
int		check_child(pid_t, const char *);
int		dispatch_imsg(struct ntpd_conf *);
void		ntpd_adjtime(double);
void		ntpd_settime(double);
d66 1
a66 1
__dead void
a92 1
	res_init();		/* XXX */
d131 1
a131 2
			if (daemon(1, 0))
				fatal("daemon");
d138 1
a138 1
	/* fork child process */
d167 2
a171 2
			log_debug("no reply received, skipping initial time "
			    "setting");
d173 1
a173 2
				if (daemon(1, 0))
					fatal("daemon");
d263 1
a263 1
				fatalx("invalid IMSG_ADJTIME received");
d269 1
a269 1
				fatalx("invalid IMSG_SETTIME received");
d277 1
a277 2
				if (daemon(1, 0))
					fatal("daemon");
d283 1
a283 1
				fatalx("invalid IMSG_HOST_DNS received");
d330 2
a331 1
	if (gettimeofday(&curtime, NULL) == -1) {
d333 5
a337 1
		return;
d339 1
a339 6
	d_to_tv(d, &tv);
	curtime.tv_usec += tv.tv_usec + 1000000;
	curtime.tv_sec += tv.tv_sec - 1 + (curtime.tv_usec / 1000000);
	curtime.tv_usec %= 1000000;

	if (settimeofday(&curtime, NULL) == -1) {
a340 2
		return;
	}
@


1.1.1.3
log
@improve my Frankenstein OS (*wink* you know who you are) further
sans wchar_t of course

this is the essence of reading >1200 commit messages which suck
due to not having the new format of ours...
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.35 2005/04/18 20:46:02 henning Exp $ */
d285 1
a285 5
			if (imsg.hdr.len < 1 + IMSG_HEADER_SIZE)
				fatalx("invalid IMSG_HOST_DNS received");
			imsg.hdr.len -= 1 + IMSG_HEADER_SIZE;
			if (name[imsg.hdr.len] != '\0' ||
			    strlen(name) != imsg.hdr.len)
@


1.1.1.4
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.39 2005/07/11 08:08:06 dtucker Exp $ */
d40 1
a40 1
int		ntpd_adjtime(double);
d134 1
a134 1
		timeout = SETTIME_TIMEOUT * 1000;
d171 2
a172 2
			log_debug("no reply received in time, skipping initial "
			    "time setting");
d220 1
a220 2
	int	 status, sig;
	char 	*signame;
d228 2
a229 4
			sig = WTERMSIG(status);
			signame = strsignal(sig) ? strsignal(sig) : "unknown";
			log_warnx("Lost child: %s terminated; signal %d (%s)",
			    pname, sig, signame);
d267 1
a267 2
			n = ntpd_adjtime(d);
			imsg_compose(ibuf, IMSG_ADJTIME, 0, 0, &n, sizeof(n));
d291 7
a297 8
			cnt = host_dns(name, &hn);
			buf = imsg_create(ibuf, IMSG_HOST_DNS,
			    imsg.hdr.peerid, 0,
			    cnt * sizeof(struct sockaddr_storage));
			if (buf == NULL)
				break;
			if (cnt > 0)
				for (h = hn; h != NULL; h = h->next)
d299 3
a301 2

			imsg_close(ibuf, buf);
d311 1
a311 1
int
d314 1
a314 3
	struct timeval	tv, olddelta;
	int		synced = 0;
	static int	firstadj = 1;
d322 1
a322 1
	if (adjtime(&tv, &olddelta) == -1)
a323 4
	else if (!firstadj && olddelta.tv_sec == 0 && olddelta.tv_usec == 0)
		synced = 1;
	firstadj = 0;
	return (synced);
@


1.1.1.5
log
@current OpenNTPD
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpd.c,v 1.40 2005/09/06 21:27:10 wvdputte Exp $ */
a277 1
			log_init(conf->debug);
d281 1
@


