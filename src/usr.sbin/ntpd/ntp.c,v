head	1.30;
access;
symbols
	tg-ntpd-sigusr1-branch:1.21.0.2
	MIRBSD_10:1.18.0.2
	MIRBSD_10_BASE:1.18
	MIRBSD_9_BASE:1.2
	MIRBSD_8:1.1.1.5.0.2
	MIRBSD_8_BASE:1.1.1.5
	cvs-200512032330:1.1.1.5
	cvs-200510270930:1.1.1.5
	cvs-200507211800:1.1.1.4
	cvs-200504291700:1.1.1.3
	cvs-200504141900:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2014.03.13.05.48.24;	author tg;	state Exp;
branches;
next	1.29;
commitid	100532146A3061EE0CD;

1.29
date	2014.03.12.23.43.00;	author tg;	state Exp;
branches;
next	1.28;
commitid	1005320F11C6DC81D52;

1.28
date	2011.02.19.00.23.46;	author tg;	state Exp;
branches;
next	1.27;
commitid	1004D5F0D70761368B7;

1.27
date	2010.09.24.22.23.49;	author tg;	state Exp;
branches;
next	1.26;
commitid	1004C9D24FA323C89FF;

1.26
date	2010.09.24.22.19.22;	author tg;	state Exp;
branches;
next	1.25;
commitid	1004C9D24016E32A316;

1.25
date	2010.09.21.21.24.46;	author tg;	state Exp;
branches;
next	1.24;
commitid	1004C992261692DCA0F;

1.24
date	2009.05.07.19.09.36;	author tg;	state Exp;
branches;
next	1.23;
commitid	1004A0331C965150DFC;

1.23
date	2008.06.04.18.34.12;	author tg;	state Exp;
branches;
next	1.22;
commitid	1004846E03611D9AFEA;

1.22
date	2008.06.04.18.28.36;	author tg;	state Exp;
branches;
next	1.21;
commitid	1004846DED961752C7C;

1.21
date	2008.05.13.21.08.00;	author tg;	state Exp;
branches
	1.21.2.1;
next	1.20;
commitid	100482A0346039FDD8B;

1.20
date	2008.05.13.20.58.02;	author tg;	state Exp;
branches;
next	1.19;
commitid	100482A00DF10FBD945;

1.19
date	2008.05.13.12.20.05;	author tg;	state Exp;
branches;
next	1.18;
commitid	10048298767192BDE03;

1.18
date	2007.10.09.13.28.09;	author tg;	state Exp;
branches;
next	1.17;
commitid	100470B81ED2599A682;

1.17
date	2007.10.03.22.50.58;	author tg;	state Exp;
branches;
next	1.16;
commitid	10047041CD3352DEB4B;

1.16
date	2007.10.03.22.03.06;	author tg;	state Exp;
branches;
next	1.15;
commitid	100470411971D43A5AB;

1.15
date	2007.10.03.21.51.08;	author tg;	state Exp;
branches;
next	1.14;
commitid	10047040EE22B8D41AB;

1.14
date	2007.10.03.21.41.46;	author tg;	state Exp;
branches;
next	1.13;
commitid	10047040CAE42B79497;

1.13
date	2007.10.03.21.35.15;	author tg;	state Exp;
branches;
next	1.12;
commitid	10047040B240EEE90C0;

1.12
date	2007.10.03.21.15.18;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004704067A0FD8C33C;

1.11
date	2007.10.03.21.08.13;	author tg;	state Exp;
branches;
next	1.10;
commitid	100470404CE4044E2A1;

1.10
date	2007.10.03.20.54.54;	author tg;	state Exp;
branches;
next	1.9;
commitid	100470401A70A43D517;

1.9
date	2007.09.26.12.38.47;	author tg;	state Exp;
branches;
next	1.8;
commitid	10046FA52D54C7D5A97;

1.8
date	2007.08.10.23.33.31;	author tg;	state Exp;
branches;
next	1.7;
commitid	10046BCF567677FCC76;

1.7
date	2007.07.31.20.32.46;	author tg;	state Exp;
branches;
next	1.6;
commitid	10046AF9C7520F41804;

1.6
date	2006.12.23.06.05.05;	author tg;	state Exp;
branches;
next	1.5;
commitid	100458CC6F8151B2244;

1.5
date	2006.12.21.22.57.13;	author tg;	state Exp;
branches;
next	1.4;
commitid	100458B0EEF3663782C;

1.4
date	2006.12.21.22.44.41;	author tg;	state Exp;
branches;
next	1.3;
commitid	100458B0D744A36EDB6;

1.3
date	2006.10.10.17.31.19;	author tg;	state Exp;
branches;
next	1.2;
commitid	100452BD8F55B68992C;

1.2
date	2006.05.29.21.55.37;	author tg;	state Exp;
branches;
next	1.1;
commitid	100447B6DE83727E950;

1.1
date	2005.02.05.17.30.58;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.21.2.1
date	2008.06.04.17.51.00;	author tg;	state Exp;
branches;
next	1.21.2.2;
commitid	1004846D5E55DFD9109;

1.21.2.2
date	2008.06.04.17.53.45;	author tg;	state Exp;
branches;
next	1.21.2.3;
commitid	1004846D6AF305B2618;

1.21.2.3
date	2008.06.04.17.57.43;	author tg;	state Exp;
branches;
next	1.21.2.4;
commitid	1004846D7A4074AAF35;

1.21.2.4
date	2008.06.04.18.01.31;	author tg;	state Exp;
branches;
next	1.21.2.5;
commitid	1004846D8840691E142;

1.21.2.5
date	2008.06.04.18.08.15;	author tg;	state Exp;
branches;
next	1.21.2.6;
commitid	1004846DA216755121F;

1.21.2.6
date	2008.06.04.18.13.10;	author tg;	state Exp;
branches;
next	1.21.2.7;
commitid	1004846DB4272E9A2BE;

1.21.2.7
date	2008.06.04.18.20.07;	author tg;	state Exp;
branches;
next	;
commitid	1004846DCE717AD9058;

1.1.1.1
date	2005.02.05.17.30.58;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.14.21.05.29;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.04.29.17.06.47;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2005.07.21.21.03.20;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	560042e0092f571e;

1.1.1.5
date	2005.10.27.09.33.16;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	734143609eed10f3;

1.1.1.6
date	2007.10.03.21.02.42;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	1004704037C0828759F;

1.1.1.7
date	2007.10.03.21.03.25;	author tg;	state Exp;
branches;
next	1.1.1.8;
commitid	100470403A61EA39E71;

1.1.1.8
date	2007.10.03.21.09.16;	author tg;	state Exp;
branches;
next	;
commitid	100470405136467D5AB;


desc
@@


1.30
log
@meh, stop already with exposing libc interna like that
just invent our own private interface for RNG state hackery if needed
@
text
@/*	$OpenBSD: ntp.c,v 1.92 2006/10/21 07:30:58 henning Exp $ */

/*
 * Copyright (c) 2006, 2007, 2008, 2009, 2010, 2011, 2014
 *	Thorsten Glaser <tg@@mirbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2004 Alexander Guy <alexander.guy@@andern.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * The following disclaimer must also be retained:
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 */

#include <sys/param.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <poll.h>
#include <pwd.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "ntpd.h"
#include "ntp.h"

__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.29 2014/03/12 23:43:00 tg Exp $");

extern void arc4random_ctl(unsigned int);

#define	PFD_PIPE_MAIN	0
#define	PFD_MAX		1

volatile sig_atomic_t	 ntp_quit = 0;
volatile sig_atomic_t	 ntp_arc4push = 0;
struct imsgbuf		*ibuf_main;
struct ntpd_conf	*conf;
u_int			 peer_cnt;

void	ntp_sighdlr(int);
int	ntp_dispatch_imsg(void);
void	peer_add(struct ntp_peer *);
void	peer_remove(struct ntp_peer *);
int	offset_compare(const void *, const void *);

void
ntp_sighdlr(int sig)
{
	switch (sig) {
	case SIGINT:
	case SIGTERM:
		ntp_quit = 1;
		break;
	case SIGHUP:
	case SIGUSR1:
		ntp_arc4push = 1;
		break;
	}
}

pid_t
ntp_main(int pipe_prnt[2], struct ntpd_conf *nconf)
{
	int			 a, b, nfds, i, j, idx_peers, timeout, nullfd;
	u_int			 pfd_elms = 0, idx2peer_elms = 0;
	u_int			 listener_cnt, new_cnt, sent_cnt, trial_cnt;
	pid_t			 pid;
	struct pollfd		*pfd = NULL;
	struct passwd		*pw;
	struct servent		*se;
	struct listen_addr	*la;
	struct ntp_peer		*p;
	struct ntp_peer		**idx2peer = NULL;
	struct timespec		 tp;
	struct stat		 stb;
	time_t			 nextaction;
	void			*newp;
	time_t			 nextstir, nextshuf, now;

	switch (pid = fork()) {
	case -1:
		fatal("cannot fork");
		break;
	case 0:
		break;
	default:
		return (pid);
	}

	/* force re-stir directly after fork, before chroot */
	(void)arc4random();
	nextstir = (now = time(NULL)) + 5400;
	nextshuf = now + 120;

	if ((se = getservbyname("ntp", "udp")) == NULL)
		fatal("getservbyname");

	if ((pw = getpwnam(NTPD_USER)) == NULL)
		fatal("getpwnam");

	if ((nullfd = open(_PATH_DEVNULL, O_RDWR, 0)) == -1)
		fatal(NULL);

	if (stat(pw->pw_dir, &stb) == -1)
		fatal("stat");
	if (stb.st_uid != 0 || (stb.st_mode & (S_IWGRP|S_IWOTH)) != 0)
		fatal("bad privsep dir permissions");
	if (chroot(pw->pw_dir) == -1)
		fatal("chroot");
	if (chdir("/") == -1)
		fatal("chdir(\"/\")");

	if (!nconf->debug) {
		dup2(nullfd, STDIN_FILENO);
		dup2(nullfd, STDOUT_FILENO);
		dup2(nullfd, STDERR_FILENO);
	}
	close(nullfd);

	setproctitle("ntp engine");

	conf = nconf;
	setup_listeners(se, conf, &listener_cnt);

	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("can't drop privileges");

	endservent();

	signal(SIGTERM, ntp_sighdlr);
	signal(SIGINT, ntp_sighdlr);
	signal(SIGPIPE, SIG_IGN);
	signal(SIGUSR1, ntp_sighdlr);
	signal(SIGHUP, ntp_sighdlr);

	close(pipe_prnt[0]);
	if ((ibuf_main = malloc(sizeof(struct imsgbuf))) == NULL)
		fatal(NULL);
	imsg_init(ibuf_main, pipe_prnt[1]);

	TAILQ_FOREACH(p, &conf->ntp_peers, entry)
		client_peer_init(p);

	bzero(&conf->status, sizeof(conf->status));
	conf->status.synced = 0;
	clock_getres(CLOCK_REALTIME, &tp);
	b = 1000000000 / tp.tv_nsec;	/* convert to Hz */
	for (a = 0; b > 1; a--, b >>= 1)
		;
	conf->status.precision = a;
	conf->scale = 1;

	log_info("ntp engine ready");

	peer_cnt = 0;
	TAILQ_FOREACH(p, &conf->ntp_peers, entry)
		peer_cnt++;

	while (ntp_quit == 0) {
		if (ntp_arc4push) {
			nextstir = 0;
			ntp_arc4push = 0;
		}

		if (nextstir < (now = time(NULL))) {
			/* 1.5 hours after start, then every 2 hrs */
			arc4random_ctl(2);
			nextstir = now + 7200;
			nextshuf = now + 600;
		} else if (nextshuf < now) {
			/* 2min after start, then every 5min except past stir */
			arc4random_ctl(0);
			nextshuf = now + 300;
		}

		if (peer_cnt > idx2peer_elms) {
			if ((newp = realloc(idx2peer, sizeof(void *) *
			    peer_cnt)) == NULL) {
				/* panic for now */
				log_warn("could not resize idx2peer from %u -> "
				    "%u entries", idx2peer_elms, peer_cnt);
				fatalx("exiting");
			}
			idx2peer = newp;
			idx2peer_elms = peer_cnt;
		}

		new_cnt = PFD_MAX + peer_cnt + listener_cnt;
		if (new_cnt > pfd_elms) {
			if ((newp = realloc(pfd, sizeof(struct pollfd) *
			    new_cnt)) == NULL) {
				/* panic for now */
				log_warn("could not resize pfd from %u -> "
				    "%u entries", pfd_elms, new_cnt);
				fatalx("exiting");
			}
			pfd = newp;
			pfd_elms = new_cnt;
		}

		bzero(pfd, sizeof(struct pollfd) * pfd_elms);
		bzero(idx2peer, sizeof(void *) * idx2peer_elms);
		nextaction = now + 3600;
		pfd[PFD_PIPE_MAIN].fd = ibuf_main->fd;
		pfd[PFD_PIPE_MAIN].events = POLLIN;

		i = 1;
		TAILQ_FOREACH(la, &conf->listen_addrs, entry) {
			pfd[i].fd = la->fd;
			pfd[i].events = POLLIN;
			i++;
		}

		idx_peers = i;
		sent_cnt = trial_cnt = 0;
		TAILQ_FOREACH(p, &conf->ntp_peers, entry) {
			if (p->next > 0 && p->next <= now) {
				if (p->state > STATE_DNS_INPROGRESS)
					trial_cnt++;
				if (client_query(p) == 0)
					sent_cnt++;
			}
			if (p->next > 0 && p->next < nextaction)
				nextaction = p->next;

			if (p->deadline > 0 && p->deadline < nextaction)
				nextaction = p->deadline;
			if (p->deadline > 0 && p->deadline <= now) {
				timeout = error_interval();
				log_debug("no reply from %s received in time, "
				    "next query %ds", log_sockaddr(
				    (struct sockaddr *)&p->addr->ss), timeout);
				if (p->trustlevel >= TRUSTLEVEL_BADPEER &&
				    (p->trustlevel /= 2) < TRUSTLEVEL_BADPEER)
					chpeertrust(p, false);
				client_nextaddr(p);
				set_next(p, timeout);
			}

			if (p->state == STATE_QUERY_SENT &&
			    p->query->fd != -1) {
				pfd[i].fd = p->query->fd;
				pfd[i].events = POLLIN;
				idx2peer[i - idx_peers] = p;
				i++;
			}
		}

		if (conf->settime &&
		    ((trial_cnt > 0 && sent_cnt == 0) || peer_cnt == 0))
			priv_settime(0);	/* no good peers, don't wait */

		if (ibuf_main->w.queued > 0)
			pfd[PFD_PIPE_MAIN].events |= POLLOUT;

		timeout = nextaction - now;
		if (timeout < 0)
			timeout = 0;

		if ((nfds = poll(pfd, i, timeout * 1000)) == -1)
			if (errno != EINTR) {
				log_warn("poll error");
				ntp_quit = 1;
			}

		if (nfds > 0 && (pfd[PFD_PIPE_MAIN].revents & POLLOUT))
			if (msgbuf_write(&ibuf_main->w) < 0) {
				log_warn("pipe write error (to parent)");
				ntp_quit = 1;
			}

		if (nfds > 0 && pfd[PFD_PIPE_MAIN].revents & (POLLIN|POLLERR)) {
			nfds--;
			if (ntp_dispatch_imsg() == -1)
				ntp_quit = 1;
		}

		for (j = 1; nfds > 0 && j < idx_peers; j++)
			if (pfd[j].revents & (POLLIN|POLLERR)) {
				nfds--;
				if (server_dispatch(pfd[j].fd, conf) == -1)
					ntp_quit = 1;
			}

		for (; nfds > 0 && j < i; j++)
			if (pfd[j].revents & (POLLIN|POLLERR)) {
				nfds--;
				if (client_dispatch(idx2peer[j - idx_peers],
				    conf->settime, conf->trace) == -1)
					ntp_quit = 1;
			}
	}

	msgbuf_write(&ibuf_main->w);
	msgbuf_clear(&ibuf_main->w);
	free(ibuf_main);

	log_info("ntp engine exiting");
	_exit(0);
}

int
ntp_dispatch_imsg(void)
{
	struct imsg		 imsg;
	int			 n;
	struct ntp_peer		*peer, *npeer;
	u_int16_t		 dlen;
	u_char			*p;
	struct ntp_addr		*h;

	if ((n = imsg_read(ibuf_main)) == -1)
		return (-1);

	if (n == 0) {	/* connection closed */
		log_warnx("ntp_dispatch_imsg in ntp engine: pipe closed");
		return (-1);
	}

	for (;;) {
		if ((n = imsg_get(ibuf_main, &imsg)) == -1)
			return (-1);

		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_ADJTIME:
			memcpy(&n, imsg.data, sizeof(n));
			if (n == 1 && !conf->status.synced) {
				log_info("clock is now synced");
				conf->status.synced = 1;
			} else if (n == 0 && conf->status.synced) {
				log_info("clock is now unsynced");
				conf->status.synced = 0;
			}
			break;
		case IMSG_HOST_DNS:
			TAILQ_FOREACH(peer, &conf->ntp_peers, entry)
				if (peer->id == imsg.hdr.peerid)
					break;
			if (peer == NULL) {
				log_warnx("IMSG_HOST_DNS with invalid peerID");
				break;
			}
			if (peer->addr != NULL) {
				log_warnx("IMSG_HOST_DNS but addr != NULL!");
				break;
			}

			dlen = imsg.hdr.len - IMSG_HEADER_SIZE;
			if (dlen == 0) {	/* no data -> temp error */
				peer->state = STATE_DNS_TEMPFAIL;
				break;
			}

			p = (u_char *)imsg.data;
			while (dlen >= sizeof(struct sockaddr_storage)) {
				if ((h = calloc(1, sizeof(struct ntp_addr))) ==
				    NULL)
					fatal(NULL);
				memcpy(&h->ss, p, sizeof(h->ss));
				p += sizeof(h->ss);
				dlen -= sizeof(h->ss);
				if (peer->addr_head.pool) {
					npeer = new_peer();
					h->next = NULL;
					npeer->addr = h;
					npeer->addr_head.a = h;
					client_peer_init(npeer);
					npeer->state = STATE_DNS_DONE;
					peer_add(npeer);
				} else {
					h->next = peer->addr;
					peer->addr = h;
					peer->addr_head.a = peer->addr;
					peer->state = STATE_DNS_DONE;
				}
			}
			if (dlen != 0)
				fatalx("IMSG_HOST_DNS: dlen != 0");
			if (peer->addr_head.pool)
				peer_remove(peer);
			else
				client_addr_init(peer);
			break;
		case IMSG_RESET:
#if 0	/* XXX maybe use type 1 (n == 1) for SIGHUP? */
			memcpy(&n, imsg.data, sizeof(n));
			if (n) {
				log_warn("invalid IMSG_RESET(%u) received", n);
				break;
			}
#endif
			conf->scale = 1;
			TAILQ_FOREACH(peer, &conf->ntp_peers, entry) {
				bzero(peer->reply, sizeof (peer->reply));
				peer->shift = 0;
				if (peer->trustlevel > TRUSTLEVEL_RESET)
					peer->trustlevel = TRUSTLEVEL_RESET;
				set_next(peer, -1);
			}
			break;
		default:
			break;
		}
		imsg_free(&imsg);
	}
	return (0);
}

void
peer_add(struct ntp_peer *p)
{
	TAILQ_INSERT_TAIL(&conf->ntp_peers, p, entry);
	peer_cnt++;
}

void
peer_remove(struct ntp_peer *p)
{
	TAILQ_REMOVE(&conf->ntp_peers, p, entry);
	free(p);
	peer_cnt--;
}

int
priv_adjtime(void)
{
	struct ntp_peer	 *p;
	int		  offset_cnt = 0, i = 0;
	struct ntp_peer	**peers;
	double		  offset_median;
	int		  weight_cnt, weight_half;

	TAILQ_FOREACH(p, &conf->ntp_peers, entry) {
		if (conf->trace > 5)
			log_info("priv_adjtime, #%02d %s peer, trust %d %s,"
			    " st %2d dst %3dms ofs %6.1fms addr %s",
			    offset_cnt,
			    p->update.good ? "good" : "bad ",
			    p->trustlevel,
			    p->trustlevel < TRUSTLEVEL_BADPEER ? "bad" : "ok",
			    p->update.status.stratum,
			    (int)((p->update.delay + .0005) * 1000.),
			    p->update.offset * 1000.,
			    log_sockaddr((struct sockaddr *)&p->addr->ss));
		else if (conf->trace > 3)
			log_info("priv_adjtime, #%02d, peer"
			    " trustlevel %d %s, %sgood",
			    offset_cnt,
			    p->trustlevel,
			    p->trustlevel < TRUSTLEVEL_BADPEER ? "bad" : "ok",
			    p->update.good ? "" : "not ");

		if (p->trustlevel < TRUSTLEVEL_BADPEER)
			continue;
		if (!p->update.good)
			return (1);
		offset_cnt++;
	}

	if (offset_cnt == 0) {
		if (conf->trace > 2)
			log_info("priv_adjtime, no peers");
		return (1);
	}

	if ((peers = calloc(offset_cnt, sizeof(struct ntp_peer *))) == NULL)
		fatal("calloc priv_adjtime");

	TAILQ_FOREACH(p, &conf->ntp_peers, entry) {
		if (p->trustlevel < TRUSTLEVEL_BADPEER)
			continue;
		peers[i++] = p;
	}

	qsort(peers, offset_cnt, sizeof(struct ntp_peer *), offset_compare);

	if (conf->trace > 2)
		log_info("priv_adjtime, %d peers", offset_cnt);

	weight_cnt = 0;
	weight_half = 0;
	offset_median = peers[offset_cnt / 2]->update.offset;
	for (i = 0; i < offset_cnt; ++i) {
		int peer_weight = (i + 1) * (offset_cnt - i);
		double peer_delta;

		if (weight_half) {
			/* even number of samples, II. median sample */
			peer_weight += weight_half;
			weight_half = 0;
		} else if ((i + 1) * 2 == offset_cnt) {
			/* even number of samples, I. median sample */
			weight_half = weight_cnt;
			peer_weight += weight_half;
		} else if (i * 2 + 1 == offset_cnt) {
			/* uneven number of samples, median sample */
			peer_weight += 2 * weight_cnt;
		}

		/* ignore false-tickers (off by a second from median) */
		peer_delta = offset_median - peers[i]->update.offset;
		if (peer_delta > 1. || peer_delta < -1.)
			peer_weight = 0;

		/* this is safe here despite shallow copy */
		peers[i]->update.good = peer_weight;
		weight_cnt += peer_weight;
	}
	offset_median = 0.0;
	for (i = 0; i < offset_cnt; ++i)
		if (peers[i]->update.good)
			offset_median += peers[i]->update.offset *
			    ((double)(peers[i]->update.good) / weight_cnt);

	if (conf->trace > 4 || (conf->trace && conf->debug))
		for (i = 0; i < offset_cnt; ++i)
			log_info("peer %2d: trust %s (%d) st %2d dst %3dms"
			    " ofs %6.1fms weight %4d addr %s", i,
			    peers[i]->trustlevel < TRUSTLEVEL_BADPEER ?
			    "bad" : "good", peers[i]->trustlevel,
			    peers[i]->update.status.stratum,
			    (int)((peers[i]->update.delay + .0005) * 1000.),
			    peers[i]->update.offset * 1000.,
			    peers[i]->update.good,
			    log_sockaddr((struct sockaddr *)&peers[i]->addr->ss));

	if (offset_cnt > 1 && offset_cnt % 2 == 0) {
		conf->status.rootdelay =
		    (peers[offset_cnt / 2 - 1]->update.delay +
		    peers[offset_cnt / 2]->update.delay) / 2;
		conf->status.stratum = MAX(
		    peers[offset_cnt / 2 - 1]->update.status.stratum,
		    peers[offset_cnt / 2]->update.status.stratum);
		if (conf->trace)
			log_info("adj%c stc %d dst %3d ofs %6.1f srv %s", '1',
			    peers[offset_cnt / 2 - 1]->update.status.stratum,
			    (int)((peers[offset_cnt / 2 - 1]->update.delay + .0005) * 1000.),
			    peers[offset_cnt / 2 - 1]->update.offset * 1000.,
			    log_sockaddr((struct sockaddr *)&peers[offset_cnt / 2 - 1]->addr->ss));
	} else {
		conf->status.rootdelay =
		    peers[offset_cnt / 2]->update.delay;
		conf->status.stratum =
		    peers[offset_cnt / 2]->update.status.stratum;
	}
	if (conf->trace)
		log_info("adj%c stc %d dst %3d ofs %6.1f srv %s",
		    (offset_cnt > 1 && offset_cnt % 2 == 0) ? '2' : 'x',
		    peers[offset_cnt / 2]->update.status.stratum,
		    (int)((peers[offset_cnt / 2]->update.delay + .0005) * 1000.),
		    peers[offset_cnt / 2]->update.offset * 1000.,
		    log_sockaddr((struct sockaddr *)&peers[offset_cnt / 2]->addr->ss));
	conf->status.leap = peers[offset_cnt / 2]->update.status.leap;

	imsg_compose(ibuf_main, IMSG_ADJTIME, 0, 0,
	    &offset_median, sizeof(offset_median));

	conf->status.reftime = gettime();
	/* one more than selected peer, but cap */
	conf->status.stratum = MIN(conf->status.stratum, 254) + 1;
	update_scale(offset_median);

	conf->status.refid4 =
	    peers[offset_cnt / 2]->update.status.refid4;
	if (peers[offset_cnt / 2]->addr->ss.ss_family == AF_INET)
		conf->status.refid = ((struct sockaddr_in *)
		    &peers[offset_cnt / 2]->addr->ss)->sin_addr.s_addr;
	else
		conf->status.refid = conf->status.refid4;
	if (peers[offset_cnt / 2]->update.status.stratum < 1)
		conf->status.refid =
		    peers[offset_cnt / 2]->update.status.refid;

	free(peers);

	TAILQ_FOREACH(p, &conf->ntp_peers, entry)
		p->update.good = 0;

	return (0);
}

int
offset_compare(const void *aa, const void *bb)
{
	const struct ntp_peer * const *a;
	const struct ntp_peer * const *b;

	a = aa;
	b = bb;

	if ((*a)->update.offset < (*b)->update.offset)
		return (-1);
	else if ((*a)->update.offset > (*b)->update.offset)
		return (1);
	else
		return (0);
}

void
priv_settime(double offset)
{
	struct ntp_peer *p;

	imsg_compose(ibuf_main, IMSG_SETTIME, 0, 0, &offset, sizeof(offset));
	conf->settime = 0;

	TAILQ_FOREACH(p, &conf->ntp_peers, entry) {
		if (p->next)
			p->next -= offset;
		if (p->deadline)
			p->deadline -= offset;
	}
}

void
priv_host_dns(char *name, u_int32_t peerid)
{
	u_int16_t	dlen;

	dlen = strlen(name) + 1;
	imsg_compose(ibuf_main, IMSG_HOST_DNS, peerid, 0, name, dlen);
}

void
update_scale(double offset)
{
	if (offset < 0)
		offset = -offset;

	if (offset > QSCALE_OFF_MAX)
		conf->scale = 1;
	else if (offset < QSCALE_OFF_MIN)
		conf->scale = QSCALE_OFF_MAX / QSCALE_OFF_MIN;
	else
		conf->scale = QSCALE_OFF_MAX / offset;
}

time_t
scale_interval(time_t requested)
{
	double interval = requested, r;

	r = (interval *= conf->scale) / 10.;
	if (r > 7.)
		r = 7.;
	return (interval + arc4random_uniform((int)(r + .5)) - (r / 2.));
}

time_t
error_interval(void)
{
	double interval = INTERVAL_QUERY_PATHETIC, r;

	r = (interval *= QSCALE_OFF_MAX / QSCALE_OFF_MIN) / 10.;
	return (interval + arc4random_uniform((int)(r + .5)) - (r / 2.));
}

void
chpeertrust(struct ntp_peer *p, bool nowvalid)
{
	static u_int nvpeers;
	const char *s = "";

	if (nowvalid)
		++nvpeers;
	else {
		if (nvpeers)
			--nvpeers;
		else
			log_warn("trying to decrease nvpeers below 0");
		s = "in";
	}

	log_info("peer %s now %svalid, %u valid peers total",
	    log_sockaddr((struct sockaddr *)&p->addr->ss),
	    s, nvpeers);
}
@


1.29
log
@stop using arc4random_stir in ntpd; same hack as in init
@
text
@a40 1
#include "thread_private.h"
d42 3
a44 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.28 2011/02/19 00:23:46 tg Exp $");
d93 1
a93 1
	time_t			 nextstir, now;
d107 2
a108 1
	nextstir = time(NULL) + 5400;
d184 1
a184 1
			arc4random_stir_lcl();
d186 5
@


1.28
log
@force arc4random_stir() (i.e. pushb_fast → kernel transfer) on SIGHUP
(and others), since init(8) issues that as first kill signal
@
text
@d4 1
a4 1
 * Copyright (c) 2006, 2007, 2008, 2009, 2010, 2011
d41 1
d43 1
a43 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.27 2010/09/24 22:23:49 tg Exp $");
d105 1
a105 1
	arc4random_stir();
d182 1
a182 1
			arc4random_stir();
@


1.27
log
@userspace stir has always done it directly, good, so remove redundancy
@
text
@d4 1
a4 1
 * Copyright (c) 2006, 2007, 2008, 2009, 2010
d42 1
a42 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.26 2010/09/24 22:19:22 tg Exp $");
d48 1
d67 4
d147 2
a148 2
	signal(SIGUSR1, SIG_IGN);
	signal(SIGHUP, SIG_IGN);
d174 5
@


1.26
log
@ntpd is very long-running which is trouble as its entropy, added
using arc4random_pushb_fast, will last typically for >22000 peer
requests, that’s why force periodic re-stirs which also exchange
the userspace local pushpool with both kernel and userspace arc4
@
text
@d42 1
a42 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.25 2010/09/21 21:24:46 tg Exp $");
a99 1
	(void)arc4random();
@


1.25
log
@use arc4random() a bit more efficiently
@
text
@d4 2
a5 1
 * Copyright (c) 2006, 2007, 2008, 2009 Thorsten Glaser <tg@@mirbsd.org>
d42 1
a42 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.24 2009/05/07 19:09:36 tg Exp $");
d86 1
d98 5
d170 6
d203 1
a203 1
		nextaction = time(NULL) + 3600;
d217 1
a217 1
			if (p->next > 0 && p->next <= time(NULL)) {
d228 1
a228 1
			if (p->deadline > 0 && p->deadline <= time(NULL)) {
d256 1
a256 1
		timeout = nextaction - time(NULL);
@


1.24
log
@experimental (but tested): track the total # of valid peers
so that things like ntpmonitor can restart ntpd if it has
been down to 0 valid peers for 5 minutes or so

XXX need to debug what I believe is internal data structure corruption
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.23 2008/06/04 18:34:12 tg Exp $");
d636 1
a636 1
	return (interval + (arc4random() % (int)(r + .5)) - (r / 2.));
d645 1
a645 1
	return (interval + (arc4random() % (int)(r + .5)) - (r / 2.));
@


1.23
log
@improve trace msg
@
text
@d4 1
a4 1
 * Copyright (c) 2006, 2007, 2008 Thorsten Glaser <tg@@mirbsd.de>
d41 1
a41 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.22 2008/06/04 18:28:36 tg Exp $");
d222 1
a222 3
					log_info("peer %s now invalid",
					    log_sockaddr(
					    (struct sockaddr *)&p->addr->ss));
d647 21
@


1.22
log
@merge and add some (yet commented out) stuff to catch invalid IMSGs
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.21 2008/05/13 21:08:00 tg Exp $");
d509 1
a509 1
			log_info("peer %2d: trust %d st %2d dst %3dms"
d511 2
a512 1
			    peers[i]->trustlevel < TRUSTLEVEL_BADPEER ? 0 : 1,
@


1.21
log
@this bug has prevented the adj code from ever working... simple pasto
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.20 2008/05/13 20:58:02 tg Exp $");
d136 1
d376 17
@


1.21.2.1
log
@experimental support for resetting the peers, until SIGHUP is in:
- currently, you must SIGUSR1 the child
- currently, if you SIGUSR1 the parent, ntpd exits in error
- the trustlevel isn't correctly re-set
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.21 2008/05/13 21:08:00 tg Exp $");
a46 1
volatile sig_atomic_t	 ntp_usr1 = 0;
a64 2
	case SIGUSR1:
		ntp_usr1 = 1;
a132 1
	signal(SIGUSR1, ntp_sighdlr);
a253 16
		if (ntp_usr1) {
			log_info("ntp engine reset");
			for (j = idx_peers; j < i; j++) {
				bzero(idx2peer[j - idx_peers]->reply,
				    sizeof (idx2peer[j - idx_peers]->reply));
				idx2peer[j - idx_peers]->shift = 0;
				if (idx2peer[j - idx_peers]->trustlevel >
				    TRUSTLEVEL_RESET)
					/* the next 2 queries are fast */
					idx2peer[j - idx_peers]->trustlevel =
					    TRUSTLEVEL_RESET;
				set_next(idx2peer[j - idx_peers], -1);
			}
			ntp_usr1 = 0;
		}

@


1.21.2.2
log
@make this code readable

XXX who thought ‘i’ was a nice name for something like peer_cnt?
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.21.2.1 2008/06/04 17:51:00 tg Exp $");
d261 5
a265 5
				struct ntp_peer *p = idx2peer[j - idx_peers];

				bzero(p->reply, sizeof (p->reply));
				p->shift = 0;
				if (p->trustlevel > TRUSTLEVEL_RESET)
d267 3
a269 2
					p->trustlevel = TRUSTLEVEL_RESET;
				set_next(p, -1);
@


1.21.2.3
log
@add tracing and do not shadow previous locals
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.21.2.2 2008/06/04 17:53:45 tg Exp $");
d261 2
a262 1
				p = idx2peer[j - idx_peers];
a264 5
				if (conf->trace > 3)
					log_info("reset peer #%02d trust %d%s",
					   j - idx_peers, p->trustlevel,
					   p->trustlevel > TRUSTLEVEL_RESET ?
					   ", capping" : " (low enough)");
@


1.21.2.4
log
@use a TAILQ_FOREACH… maybe this time.
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.21.2.3 2008/06/04 17:57:43 tg Exp $");
d260 2
a261 2
			j = 0;
			TAILQ_FOREACH(p, &conf->ntp_peers, entry) {
d266 1
a266 1
					   j++, p->trustlevel,
@


1.21.2.5
log
@maybe resetting conf->scale helps
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.21.2.4 2008/06/04 18:01:31 tg Exp $");
a259 1
			conf->scale = 1;
@


1.21.2.6
log
@actually, the next 3 queries seem to be bursted
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.21.2.5 2008/06/04 18:08:15 tg Exp $");
d261 1
d265 5
d271 1
a271 1
					/* burst the next few queries */
@


1.21.2.7
log
@attempt to use IMSG and have parent handle things
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.21.2.6 2008/06/04 18:13:10 tg Exp $");
d47 1
d66 2
d136 1
a139 1
	signal(SIGUSR1, SIG_IGN);
d258 14
a392 11
		case IMSG_RESET:
			log_info("ntp engine reset");
			conf->scale = 1;
			TAILQ_FOREACH(peer, &conf->ntp_peers, entry) {
				bzero(peer->reply, sizeof (peer->reply));
				peer->shift = 0;
				if (peer->trustlevel > TRUSTLEVEL_RESET)
					peer->trustlevel = TRUSTLEVEL_RESET;
				set_next(peer, -1);
			}
			break;
@


1.20
log
@improve debugging output (at that place, all peers are "good", so
log the weigt instead)
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.19 2008/05/13 12:20:05 tg Exp $");
d476 1
a476 1
		if (peer_delta > 1. || peer_delta < 1.)
@


1.19
log
@Improve accuracy (and maybe speed, despite running the loop twice now) of
the algorithm that calculates the adjustment delta slightly (I hope) by
reducing the number of floating point operations
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.18 2007/10/09 13:28:09 tg Exp $");
a452 10
	if (conf->trace > 4 || (conf->trace && conf->debug))
		for (i = 0; i < offset_cnt; ++i)
			log_info("peer %2d: %s, trust %d "
			    " st %2d dst %3dms ofs %6.1fms addr %s", i,
			    peers[i]->update.good ? "good" : "bad ",
			    peers[i]->trustlevel < TRUSTLEVEL_BADPEER ? 0 : 1,
			    peers[i]->update.status.stratum,
			    (int)((peers[i]->update.delay + .0005) * 1000.),
			    peers[i]->update.offset * 1000.,
			    log_sockaddr((struct sockaddr *)&peers[i]->addr->ss));
d489 11
@


1.18
log
@ignore peers which are off the median by more than one second in the
weighted mapping
@
text
@d4 1
a4 1
 * Copyright (c) 2006, 2007 Thorsten Glaser <tg@@mirbsd.de>
d41 1
a41 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.17 2007/10/03 22:50:58 tg Exp $");
d405 1
a405 2
	double weight_cnt = 0.0;
	int weight_half = 0;
d464 3
a466 1
	offset_median = 0.0;
d468 3
a470 2
		double j = (i + 1) * (offset_cnt - i);
		double k = peers[offset_cnt / 2]->update.offset;
d472 2
a473 1
			j += weight_half;
d476 1
d478 14
a491 8
			j += weight_half;
		} else if (i * 2 + 1 == offset_cnt)
			j += 2.0 * weight_cnt;
		k -= peers[i]->update.offset;
		if (k > 1. || k < -1.)
			continue;	/* ignore false-tickers */
		offset_median += j * peers[i]->update.offset;
		weight_cnt += j;
d493 5
a497 1
	offset_median /= weight_cnt;
@


1.17
log
@I learned lots about ntpd(8) tonight…
improve the randomisation of the poll intervals
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.16 2007/10/03 22:03:06 tg Exp $");
d468 1
d477 3
@


1.16
log
@log the sorted peers list if debug&trace or trace=5‥n
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.15 2007/10/03 21:51:08 tg Exp $");
d595 1
a595 1
	time_t interval, r;
d597 4
a600 3
	interval = requested * conf->scale;
	r = arc4random() % MAX(5, interval / 10);
	return (interval + r);
d606 1
a606 1
	time_t interval, r;
d608 2
a609 3
	interval = INTERVAL_QUERY_PATHETIC * QSCALE_OFF_MAX / QSCALE_OFF_MIN;
	r = arc4random() % (interval / 10);
	return (interval + r);
@


1.15
log
@even better
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.14 2007/10/03 21:41:46 tg Exp $");
d454 1
a454 1
	if (conf->trace > 4)
@


1.14
log
@better logging
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.13 2007/10/03 21:35:15 tg Exp $");
d410 1
a410 1
			log_info("priv_adjtime, %s peer, trust %d %s,"
d412 1
d421 3
a423 1
			log_info("priv_adjtime, peer trustlevel %d %s, %sgood",
@


1.13
log
@mooooore tracing (oO)
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.12 2007/10/03 21:15:18 tg Exp $");
d410 4
a413 4
			log_info("priv_adjtime, peer st %2d trust %d %s,"
			    " st %2d dst %3dms ofs %6.1fms good %d addr %s",
			    p->stratum_offset,
			    p->trustlevel ? 1 : 0,
a417 1
			    p->update.good ? 1 : 0,
d453 4
a456 4
			log_info("peer %2d: st %2d trust %d"
			    " st %2d dst %3dms ofs %6.1fms good %d addr %s",
			    i, peers[i]->stratum_offset,
			    peers[i]->trustlevel ? 1 : 0,
a459 1
			    peers[i]->update.good ? 1 : 0,
@


1.12
log
@merge and fix
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.11 2007/10/03 21:08:13 tg Exp $");
d409 12
a420 1
		if (conf->trace > 3)
d452 11
@


1.11
log
@merge and beautify
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.10 2007/10/03 20:54:54 tg Exp $");
d405 2
d437 1
a437 3
	if (offset_cnt > 2)
		qsort(peers, offset_cnt, sizeof(struct ntp_peer *),
		    offset_compare);
d442 25
a466 25
	if (offset_cnt > 0) {
		double weight_cnt = 0.0;
		int weight_half = 0;

		offset_median = 0.0;
		for (i = 0; i < offset_cnt; ++i) {
			double j = (i + 1) * (offset_cnt - i);
			if (weight_half) {
				j += weight_half;
				weight_half = 0;
			} else if ((i + 1) * 2 == offset_cnt) {
				weight_half = weight_cnt;
				j += weight_half;
			} else if (i * 2 + 1 == offset_cnt)
				j += 2.0 * weight_cnt;
			offset_median += j * peers[i]->update.offset;
			weight_cnt += j;
		}
		offset_median /= weight_cnt;

		if (offset_cnt > 1 && offset_cnt % 2 == 0) {
			conf->status.rootdelay =
			    (peers[offset_cnt / 2 - 1]->update.delay +
			    peers[offset_cnt / 2]->update.delay) / 2;
			conf->status.stratum = MAX(
d468 36
a503 41
			    peers[offset_cnt / 2]->update.status.stratum);
			if (conf->trace)
				log_info("adj%c stc %d dst %3d ofs %6.1f srv %s", '1',
				    peers[offset_cnt / 2 - 1]->update.status.stratum,
				    (int)((peers[offset_cnt / 2 - 1]->update.delay + .0005) * 1000.),
				    peers[offset_cnt / 2 - 1]->update.offset * 1000.,
				    log_sockaddr((struct sockaddr *)&peers[offset_cnt / 2 - 1]->addr->ss));
		} else {
			conf->status.rootdelay =
			    peers[offset_cnt / 2]->update.delay;
			conf->status.stratum =
			    peers[offset_cnt / 2]->update.status.stratum;
		}
		if (conf->trace)
			log_info("adj%c stc %d dst %3d ofs %6.1f srv %s",
			    (offset_cnt > 1 && offset_cnt % 2 == 0) ? '2' : 'x',
			    peers[offset_cnt / 2]->update.status.stratum,
			    (int)((peers[offset_cnt / 2]->update.delay + .0005) * 1000.),
			    peers[offset_cnt / 2]->update.offset * 1000.,
			    log_sockaddr((struct sockaddr *)&peers[offset_cnt / 2]->addr->ss));
		conf->status.leap = peers[offset_cnt / 2]->update.status.leap;

		imsg_compose(ibuf_main, IMSG_ADJTIME, 0, 0,
		    &offset_median, sizeof(offset_median));

		conf->status.reftime = gettime();
		/* one more than selected peer, but cap */
		conf->status.stratum = MIN(conf->status.stratum, 254) + 1;
		update_scale(offset_median);

		conf->status.refid4 =
		    peers[offset_cnt / 2]->update.status.refid4;
		if (peers[offset_cnt / 2]->addr->ss.ss_family == AF_INET)
			conf->status.refid = ((struct sockaddr_in *)
			    &peers[offset_cnt / 2]->addr->ss)->sin_addr.s_addr;
		else
			conf->status.refid = conf->status.refid4;
		if (peers[offset_cnt / 2]->update.status.stratum < 1)
			conf->status.refid =
			    peers[offset_cnt / 2]->update.status.refid;
	}
d509 2
@


1.10
log
@add more traces
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.67 2005/08/10 13:48:36 dtucker Exp $ */
d41 1
a41 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.9 2007/09/26 12:38:47 tg Exp $");
d228 2
a229 1
			if (p->state == STATE_QUERY_SENT) {
d398 1
a398 1
void
d416 1
a416 1
			return;
d420 6
@


1.9
log
@improve the output from -t option to reduce my own confusion
@
text
@d4 1
a4 1
 * Copyright (c) 2006 Thorsten Glaser <tg@@mirbsd.de>
d41 1
a41 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.8 2007/08/10 23:33:31 tg Exp $");
d406 6
d432 3
@


1.8
log
@sanitise refid handling:
• per RFC for SNTP4 and NTP4 draft, even NTP4 Stratum-1 requests use the
  ASCII string as reference ID, like NTP3
• fix an endianness problem for NTP3 refids
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.7 2007/07/31 20:32:46 tg Exp $");
d454 1
a454 1
				log_info("adj%c strat-c %d dst %f peer %s", '1',
d456 2
a457 1
				    peers[offset_cnt / 2 - 1]->update.delay,
d466 1
a466 1
			log_info("adj%c strat-c %d dst %f peer %s",
d469 2
a470 1
			    peers[offset_cnt / 2]->update.delay,
@


1.7
log
@rejoice! tracing! use -t for adjtime tracing, -tt for recv tracing too
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.6 2006/12/23 06:05:05 tg Exp $");
d487 3
@


1.6
log
@remove debugging code. preliminary results, under load and idle:
mean of 6.9 ms
most 0.1-2.1 ms
max 25.5 ms
most below 15 ms
(with hand-selected peers and one on LAN); that's reasonable enough
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.5 2006/12/21 22:57:13 tg Exp $");
d276 1
a276 1
				    conf->settime) == -1)
d453 5
d464 6
@


1.5
log
@modify the algorithm originally based on an idea of bsiegert@@ in IRC
to make the value(s) _originally_ picked weigh MUCH more than the sides
(their own value plus the value of its half, or twice that on odds)
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.4 2006/12/21 22:44:41 tg Exp $");
a446 4
			log_info("measured value %fs adjusted to %fs",
			    (peers[offset_cnt / 2 - 1]->update.offset +
			    peers[offset_cnt / 2]->update.offset) / 2,
			    offset_median);
a453 3
			log_info("measured value %fs adjusted to %fs",
			    peers[offset_cnt / 2]->update.offset,
			    offset_median);
@


1.4
log
@instead of only taking the "best" value for the peers,
let all other peers be taken into account as well, but
with much less account than the "best" value, and also
reducing spike effects
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/usr.sbin/ntpd/ntp.c,v 1.3 2006/10/10 17:31:19 tg Exp $");
d428 1
d433 8
@


1.3
log
@cap the stratum at the top, to prevent integer overflow
@
text
@d4 1
d12 10
a21 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d41 1
a41 1
__RCSID("$MirOS$");
d427 10
d438 1
a438 1
			offset_median =
d440 2
a441 1
			    peers[offset_cnt / 2]->update.offset) / 2;
d449 3
a451 1
			offset_median = peers[offset_cnt / 2]->update.offset;
@


1.2
log
@sorting only makes sense if 3 or above peers
@
text
@d37 2
d446 2
a447 1
		conf->status.stratum++;	/* one more than selected peer */
a539 1

@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.46 2004/12/23 16:10:10 henning Exp $ */
d67 1
a67 1
	u_int			 listener_cnt, new_cnt;
d83 1
d121 2
a122 2
	    setegid(pw->pw_gid) || setgid(pw->pw_gid) ||
	    seteuid(pw->pw_uid) || setuid(pw->pw_uid))
a124 1
	endpwent();
d141 1
a141 1
	conf->status.leap = LI_ALARM;
d144 2
a145 1
	for (a = 0; b > 1; a--, b >>= 1);
d147 1
d195 1
d197 6
a204 2
			if (p->next > 0 && p->next <= time(NULL))
				client_query(p);
d209 4
a212 3
				log_debug("no reply from %s received in time",
				    log_sockaddr(
				    (struct sockaddr *)&p->addr->ss));
d219 1
a219 1
				client_query(p);
d230 4
d309 10
d331 1
d333 5
d352 1
d358 1
d362 1
a362 1
				fatal("IMSG_HOST_DNS: dlen != 0");
d408 1
a408 1
		fatal("calloc ntp_adjtime");
d416 3
a418 1
	qsort(peers, offset_cnt, sizeof(struct ntp_peer *), offset_compare);
d438 1
a443 1
		conf->status.leap = LI_NOWARNING;
d445 1
d447 2
d452 2
d482 2
d486 7
d503 35
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@we like OpenNTPD so much we want to have current one
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.55 2005/03/24 14:50:07 henning Exp $ */
d67 1
a67 1
	u_int			 listener_cnt, new_cnt, sent_cnt, trial_cnt;
a82 1
		break;
d144 1
a144 2
	for (a = 0; b > 1; a--, b >>= 1)
		;
a145 1
	conf->scale = 1;
a192 1
		sent_cnt = trial_cnt = 0;
d196 2
a197 5
			if (p->next > 0 && p->next <= time(NULL)) {
				trial_cnt++;
				if (client_query(p) == 0)
					sent_cnt++;
			}
d202 3
a204 4
				timeout = error_interval();
				log_debug("no reply from %s received in time, "
				    "next query %ds", log_sockaddr(
				    (struct sockaddr *)&p->addr->ss), timeout);
d211 1
a211 1
				set_next(p, timeout);
a221 3
		if (trial_cnt > 0 && sent_cnt == 0 && conf->settime)
			priv_settime(0);	/* no good peers, don't wait */

d332 1
a332 1
				fatalx("IMSG_HOST_DNS: dlen != 0");
a412 1
		update_scale(offset_median);
a456 35

void
update_scale(double offset)
{
	if (offset < 0)
		offset = -offset;

	if (offset > QSCALE_OFF_MAX)
		conf->scale = 1;
	else if (offset < QSCALE_OFF_MIN)
		conf->scale = QSCALE_OFF_MAX / QSCALE_OFF_MIN;
	else
		conf->scale = QSCALE_OFF_MAX / offset;
}

time_t
scale_interval(time_t requested)
{
	time_t interval, r;

	interval = requested * conf->scale;
	r = arc4random() % MAX(5, interval / 10);
	return (interval + r);
}

time_t
error_interval(void)
{
	time_t interval, r;

	interval = INTERVAL_QUERY_PATHETIC * QSCALE_OFF_MAX / QSCALE_OFF_MIN;
	r = arc4random() % (interval / 10);
	return (interval + r);
}

@


1.1.1.3
log
@improve my Frankenstein OS (*wink* you know who you are) further
sans wchar_t of course

this is the essence of reading >1200 commit messages which suck
due to not having the new format of ours...
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.57 2005/04/18 14:12:50 henning Exp $ */
a456 2
	struct ntp_peer *p;

a458 7

	TAILQ_FOREACH(p, &conf->ntp_peers, entry) {
		if (p->next)
			p->next -= offset;
		if (p->deadline)
			p->deadline -= offset;
	}
@


1.1.1.4
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.65 2005/07/15 03:36:10 henning Exp $ */
d121 2
a122 2
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
d125 1
d198 2
d201 1
a201 2
				if (p->state > STATE_DNS_INPROGRESS)
					trial_cnt++;
a204 2
			if (p->next > 0 && p->next < nextaction)
				nextaction = p->next;
a307 10
		case IMSG_ADJTIME:
			memcpy(&n, imsg.data, sizeof(n));
			if (n == 1 && conf->status.leap == LI_ALARM) {
				log_info("clock is now synced");
				conf->status.leap = LI_NOWARNING;
			} else if (n == 0 && conf->status.leap != LI_ALARM) {
				log_info("clock is now unsynced");
				conf->status.leap = LI_ALARM;
			}
			break;
a319 1

a320 5
			if (dlen == 0) {	/* no data -> temp error */
				peer->state = STATE_DNS_TEMPFAIL;
				break;
			}

a334 1
					npeer->state = STATE_DNS_DONE;
a339 1
					peer->state = STATE_DNS_DONE;
d389 1
a389 1
		fatal("calloc priv_adjtime");
d422 1
a425 2
		conf->status.refid4 =
		    peers[offset_cnt / 2]->update.status.refid4;
a428 2
		else
			conf->status.refid = conf->status.refid4;
@


1.1.1.5
log
@current OpenNTPD
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.67 2005/08/10 13:48:36 dtucker Exp $ */
d141 1
a141 1
	conf->status.synced = 0;
d230 1
a230 2
		if (conf->settime &&
		    ((trial_cnt > 0 && sent_cnt == 0) || peer_cnt == 0))
d310 1
a310 1
			if (n == 1 && !conf->status.synced) {
d312 2
a313 2
				conf->status.synced = 1;
			} else if (n == 0 && conf->status.synced) {
d315 1
a315 1
				conf->status.synced = 0;
a434 1
		conf->status.leap = peers[offset_cnt / 2]->update.status.leap;
@


1.1.1.6
log
@   Revision [134]1.70 / ([135]download) - [136]annotate - [137][select for diffs] , Sun Jun 4 18:58:13 2006
   UTC (15 months, 4 weeks ago) by otto
Only invalidate stored replies if an adjustment was really made.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.83 2006/06/04 18:58:13 otto Exp $ */
d391 1
a391 1
int
d403 1
a403 1
			return (1);
a406 3
	if (offset_cnt == 0)
		return (1);

@


1.1.1.7
log
@   Revision  [62]1.92  /  ([63]download) - [64]annotate - [65][select for diffs] , Sat Oct 21 07:30:58 2006
   UTC (11 months, 1 week ago) by henning
        Found that even if client fd (i.e to NTP source) is set to
        -1 because of error, it may still participate in poll()
        causing poll() to repeatedly wake up on error fd.
so make sure w edon't add -1 fds to pollevents to avoid unnecessary wakeups
From: [69]amandal@@entrisphere.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.92 2006/10/21 07:30:58 henning Exp $ */
d222 1
a222 2
			if (p->state == STATE_QUERY_SENT &&
			    p->query->fd != -1) {
@


1.1.1.8
log
@second part of that diff
@
text
@d422 34
a455 16
	if (offset_cnt > 1 && offset_cnt % 2 == 0) {
		offset_median =
		    (peers[offset_cnt / 2 - 1]->update.offset +
		    peers[offset_cnt / 2]->update.offset) / 2;
		conf->status.rootdelay =
		    (peers[offset_cnt / 2 - 1]->update.delay +
		    peers[offset_cnt / 2]->update.delay) / 2;
		conf->status.stratum = MAX(
		    peers[offset_cnt / 2 - 1]->update.status.stratum,
		    peers[offset_cnt / 2]->update.status.stratum);
	} else {
		offset_median = peers[offset_cnt / 2]->update.offset;
		conf->status.rootdelay =
		    peers[offset_cnt / 2]->update.delay;
		conf->status.stratum =
		    peers[offset_cnt / 2]->update.status.stratum;
a456 16
	conf->status.leap = peers[offset_cnt / 2]->update.status.leap;

	imsg_compose(ibuf_main, IMSG_ADJTIME, 0, 0,
	    &offset_median, sizeof(offset_median));

	conf->status.reftime = gettime();
	conf->status.stratum++;	/* one more than selected peer */
	update_scale(offset_median);

	conf->status.refid4 =
	    peers[offset_cnt / 2]->update.status.refid4;
	if (peers[offset_cnt / 2]->addr->ss.ss_family == AF_INET)
		conf->status.refid = ((struct sockaddr_in *)
		    &peers[offset_cnt / 2]->addr->ss)->sin_addr.s_addr;
	else
		conf->status.refid = conf->status.refid4;
@


