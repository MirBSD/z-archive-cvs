head	1.20;
access;
symbols
	tg-ntpd-sigusr1-branch:1.15.0.4
	MIRBSD_10:1.15.0.2
	MIRBSD_10_BASE:1.15
	MIRBSD_9_BASE:1.4
	MIRBSD_8:1.4.0.2
	MIRBSD_8_BASE:1.4
	cvs-200512032330:1.1.1.5
	cvs-200510270930:1.1.1.5
	cvs-200507211800:1.1.1.4
	cvs-200504291700:1.1.1.3
	cvs-200504141900:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2011.10.04.10.04.15;	author tg;	state Exp;
branches;
next	1.19;
commitid	1004E8ADA2C085A89DD;

1.19
date	2009.12.24.11.40.38;	author tg;	state Exp;
branches;
next	1.18;
commitid	1004B3351E651CE01AF;

1.18
date	2009.05.16.11.53.08;	author tg;	state Exp;
branches;
next	1.17;
commitid	1004A0EA92E58AD2C4B;

1.17
date	2009.05.16.11.52.31;	author tg;	state Exp;
branches;
next	1.16;
commitid	1004A0EA9117F520CB0;

1.16
date	2009.05.07.19.09.36;	author tg;	state Exp;
branches;
next	1.15;
commitid	1004A0331C965150DFC;

1.15
date	2007.10.03.22.52.00;	author tg;	state Exp;
branches;
next	1.14;
commitid	10047041D2145A88E16;

1.14
date	2007.10.03.21.17.31;	author tg;	state Exp;
branches;
next	1.13;
commitid	10047040702450C1DBB;

1.13
date	2007.10.03.21.16.31;	author tg;	state Exp;
branches;
next	1.12;
commitid	100470406C60200F2EA;

1.12
date	2007.10.03.21.15.17;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004704067A0FD8C33C;

1.11
date	2007.10.03.21.08.13;	author tg;	state Exp;
branches;
next	1.10;
commitid	100470404CE4044E2A1;

1.10
date	2007.10.03.20.54.54;	author tg;	state Exp;
branches;
next	1.9;
commitid	100470401A70A43D517;

1.9
date	2007.09.26.12.38.47;	author tg;	state Exp;
branches;
next	1.8;
commitid	10046FA52D54C7D5A97;

1.8
date	2007.08.17.16.20.01;	author tg;	state Exp;
branches;
next	1.7;
commitid	10046C5CAC070F196DC;

1.7
date	2007.08.10.22.22.02;	author tg;	state Exp;
branches;
next	1.6;
commitid	10046BCE5054BBA756D;

1.6
date	2007.07.31.20.32.45;	author tg;	state Exp;
branches;
next	1.5;
commitid	10046AF9C7520F41804;

1.5
date	2007.07.31.19.57.02;	author tg;	state Exp;
branches;
next	1.4;
commitid	10046AF9304601393BC;

1.4
date	2005.12.18.00.59.36;	author tg;	state Exp;
branches;
next	1.3;
commitid	10043A4B485278F31B2;

1.3
date	2005.10.27.09.35.29;	author tg;	state Exp;
branches;
next	1.2;
commitid	30b343609f776f28;

1.2
date	2005.07.26.12.40.44;	author tg;	state Exp;
branches;
next	1.1;
commitid	95b42e62f3df8e2;

1.1
date	2005.02.05.17.30.58;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.30.58;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.14.21.05.29;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.04.29.17.06.47;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2005.07.21.21.03.19;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	560042e0092f571e;

1.1.1.5
date	2005.10.27.09.33.16;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	734143609eed10f3;

1.1.1.6
date	2007.10.03.20.56.57;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	100470402121D132085;

1.1.1.7
date	2007.10.03.21.02.42;	author tg;	state Exp;
branches;
next	;
commitid	1004704037C0828759F;


desc
@@


1.20
log
@change from 05.01.2010: KNF aka style(9)
@
text
@/*	$OpenBSD: client.c,v 1.69 2006/06/04 18:58:13 otto Exp $ */

/*
 * Copyright (c) 2007, 2009, 2010 Thorsten Glaser <tg@@mirbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2004 Alexander Guy <alexander.guy@@andern.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "ntpd.h"

__RCSID("$MirOS: src/usr.sbin/ntpd/client.c,v 1.19 2009/12/24 11:40:38 tg Exp $");

#ifdef DDEBUG
#define log_reply	log_info
#else
#define log_reply	log_debug
#endif

int	client_update(struct ntp_peer *, int);
void	set_deadline(struct ntp_peer *, time_t);

void
set_next(struct ntp_peer *p, time_t t)
{
	p->next = time(NULL) + t;
	p->deadline = 0;
}

void
set_deadline(struct ntp_peer *p, time_t t)
{
	p->deadline = time(NULL) + t;
	p->next = 0;
}

int
client_peer_init(struct ntp_peer *p)
{
	if ((p->query = calloc(1, sizeof(struct ntp_query))) == NULL)
		fatal("client_peer_init calloc");
	p->query->fd = -1;
	p->query->msg.status = MODE_CLIENT | (NTP_VERSION << 3);
	p->state = STATE_NONE;
	p->shift = 0;
	p->trustlevel = TRUSTLEVEL_PATHETIC;
	p->lasterror = 0;

	return (client_addr_init(p));
}

int
client_addr_init(struct ntp_peer *p)
{
	struct sockaddr_in	*sa_in;
	struct sockaddr_in6	*sa_in6;
	struct ntp_addr		*h;

	for (h = p->addr; h != NULL; h = h->next) {
		switch (h->ss.ss_family) {
		case AF_INET:
			sa_in = (struct sockaddr_in *)&h->ss;
			if (ntohs(sa_in->sin_port) == 0)
				sa_in->sin_port = htons(123);
			p->state = STATE_DNS_DONE;
			break;
		case AF_INET6:
			sa_in6 = (struct sockaddr_in6 *)&h->ss;
			if (ntohs(sa_in6->sin6_port) == 0)
				sa_in6->sin6_port = htons(123);
			p->state = STATE_DNS_DONE;
			break;
		default:
			fatal("king bula sez: wrong AF in client_addr_init");
			/* NOTREACHED */
		}
	}

	p->query->fd = -1;
	set_next(p, 0);

	return (0);
}

int
client_nextaddr(struct ntp_peer *p)
{
	close(p->query->fd);
	p->query->fd = -1;

	if (p->addr_head.a == NULL) {
		priv_host_dns(p->addr_head.name, p->id);
		p->state = STATE_DNS_INPROGRESS;
		return (-1);
	}

	if ((p->addr = p->addr->next) == NULL)
		p->addr = p->addr_head.a;

	p->shift = 0;
	p->trustlevel = TRUSTLEVEL_PATHETIC;

	return (0);
}

int
client_query(struct ntp_peer *p)
{
	int	tos = IPTOS_LOWDELAY;
	int	result;

	if (p->addr == NULL && client_nextaddr(p) == -1) {
		set_next(p, error_interval());
		return (0);
	}

	if (p->state < STATE_DNS_DONE || p->addr == NULL)
		return (-1);

	if (p->query->fd == -1) {
		struct sockaddr *sa = (struct sockaddr *)&p->addr->ss;

		if ((p->query->fd = socket(p->addr->ss.ss_family, SOCK_DGRAM,
		    0)) == -1) {
			if (errno == EAFNOSUPPORT) {
				log_warn("client_query socket");
				client_nextaddr(p);
				set_next(p, error_interval());
				return (-1);
			}
			fatal("client_query socket");
		}

		if (connect(p->query->fd, sa, SA_LEN(sa)) == -1) {
			if (errno == ECONNREFUSED || errno == ENETUNREACH ||
			    errno == EHOSTUNREACH) {
				client_nextaddr(p);
				set_next(p, error_interval());
				return (-1);
			} else
				fatal("client_query connect");
		}
		if (p->addr->ss.ss_family == AF_INET && setsockopt(p->query->fd,
		    IPPROTO_IP, IP_TOS, &tos, sizeof(tos)) == -1)
			log_warn("setsockopt IPTOS_LOWDELAY");
	}

	/*
	 * Send out a random 64-bit number as our transmit time.  The NTP
	 * server will copy said number into the originate field on the
	 * response that it sends us.  This is totally legal per the SNTP spec.
	 *
	 * The impact of this is two fold: we no longer send out the current
	 * system time for the world to see (which may aid an attacker), and
	 * it gives us a (not very secure) way of knowing that we're not
	 * getting spoofed by an attacker that can't capture our traffic
	 * but can spoof packets from the NTP server we're communicating with.
	 *
	 * Save the real transmit timestamp locally.
	 */

	p->query->msg.xmttime.int_partl = arc4random();
	p->query->msg.xmttime.fractionl = arc4random();
	p->query->xmttime = gettime();

	if ((result = ntp_sendmsg(p->query->fd, NULL, &p->query->msg,
	    NTP_MSGSIZE_NOAUTH, 0)) < 0) {
		set_next(p, INTERVAL_QUERY_PATHETIC);
		if (result == -2) {
			/*
			 * got EINVAL in sendto(), probably the local socket
			 * address got invalidated -> force re-connect()
			 */
			close(p->query->fd);
			p->query->fd = -1;
		}
		return (-1);
	}

	p->state = STATE_QUERY_SENT;
	set_deadline(p, QUERYTIME_MAX);

	return (0);
}

int
client_dispatch(struct ntp_peer *p, u_int8_t settime, uint8_t trace)
{
	char			 buf[NTP_MSGSIZE];
	ssize_t			 size;
	struct ntp_msg		 msg;
	double			 T1, T2, T3, T4;
	time_t			 interval;

	if ((size = recvfrom(p->query->fd, &buf, sizeof(buf), 0,
	    NULL, NULL)) == -1) {
		if (errno == EHOSTUNREACH || errno == EHOSTDOWN ||
		    errno == ENETUNREACH || errno == ENETDOWN ||
		    errno == ECONNREFUSED || errno == EADDRNOTAVAIL) {
			client_log_error(p, "recvfrom", errno);
			set_next(p, error_interval());
			return (0);
		} else
			fatal("recvfrom");
	}

	T4 = gettime();

	ntp_getmsg((struct sockaddr *)&p->addr->ss, buf, size, &msg);

	if (msg.orgtime.int_partl != p->query->msg.xmttime.int_partl ||
	    msg.orgtime.fractionl != p->query->msg.xmttime.fractionl)
		return (0);

	if ((msg.status & LI_ALARM) == LI_ALARM || msg.stratum == 0 ||
	    msg.stratum > NTP_MAXSTRATUM) {
		interval = error_interval();
		set_next(p, interval);
		log_info("reply from %s: not synced, next query %ds",
		    log_sockaddr((struct sockaddr *)&p->addr->ss),
		    (int)interval);
		return (0);
	}

	/**
	 * From RFC 2030 (with a correction to the delay math) and rdate(8):
	 *
	 *     Timestamp Name          ID   When Generated
	 *     ------------------------------------------------------------
	 *     Originate Timestamp     T1   time request sent by client
	 *     Receive Timestamp       T2   time request received by server
	 *     Transmit Timestamp      T3   time reply sent by server
	 *     Destination Timestamp   T4   time reply received by client
	 *
	 *  The roundtrip delay d, local clock offset t, and adjustment
	 *  error v are defined as:
	 *
	 *	d = (T4 - T1) - (T3 - T2)
	 *	t = ((T2 - T1) + (T3 - T4)) / 2
	 *	v = |(T2 - T1) - (T3 - T4)|
	 */

	T1 = p->query->xmttime;
	T2 = lfp_to_d(msg.rectime);
	T3 = lfp_to_d(msg.xmttime);

	p->reply[p->shift].offset = ((T2 - T1) + (T3 - T4)) / 2;
	p->reply[p->shift].delay = (T4 - T1) - (T3 - T2);
	if (p->reply[p->shift].delay < DELAY_NEGLIGEE) {
		interval = error_interval();
		set_next(p, interval);
		log_info("reply from %s: negative delay %fs, "
		    "next query %ds",
		    log_sockaddr((struct sockaddr *)&p->addr->ss),
		    p->reply[p->shift].delay, (int)interval);
		return (0);
	}
	p->reply[p->shift].error = (T2 - T1) - (T3 - T4);
	if (p->reply[p->shift].error < 0)
		p->reply[p->shift].error = -p->reply[p->shift].error;
	p->reply[p->shift].rcvd = time(NULL);
	p->reply[p->shift].good = 1;

	p->reply[p->shift].status.leap = (msg.status & LIMASK);
	p->reply[p->shift].status.precision = msg.precision;
	p->reply[p->shift].status.rootdelay = sfp_to_d(msg.rootdelay);
	p->reply[p->shift].status.rootdispersion = sfp_to_d(msg.dispersion);
	p->reply[p->shift].status.refid = msg.refid;
	p->reply[p->shift].status.refid4 = htonl(msg.xmttime.fractionl);
	p->reply[p->shift].status.reftime = lfp_to_d(msg.reftime);
	p->reply[p->shift].status.poll = msg.ppoll;
	p->reply[p->shift].status.stratum = msg.stratum - p->stratum_offset;

	if (p->trustlevel < TRUSTLEVEL_PATHETIC)
		interval = scale_interval(INTERVAL_QUERY_PATHETIC);
	else if (p->trustlevel < TRUSTLEVEL_AGRESSIVE)
		interval = scale_interval(INTERVAL_QUERY_AGRESSIVE);
	else
		interval = scale_interval(INTERVAL_QUERY_NORMAL);

	set_next(p, interval);
	p->state = STATE_REPLY_RECEIVED;

	if (trace > 1)
		log_info("rcvd str %d dst %3d ofs %6.1f srv %s",
		    msg.stratum, (int)((p->reply[p->shift].delay + .0005) * 1000.),
		    p->reply[p->shift].offset * 1000.,
		    log_sockaddr((struct sockaddr *)&p->addr->ss));

	/* every received reply which we do not discard increases trust */
	if (p->trustlevel < TRUSTLEVEL_MAX &&
	    ++p->trustlevel == TRUSTLEVEL_BADPEER)
		chpeertrust(p, true);

	log_reply("reply from %s: offset %fs delay %fs, "
	    "next query %ds", log_sockaddr((struct sockaddr *)&p->addr->ss),
	    p->reply[p->shift].offset, p->reply[p->shift].delay,
	    (int)interval);

	client_update(p, trace);
	if (settime)
		priv_settime(p->reply[p->shift].offset);

	if (++p->shift >= OFFSET_ARRAY_SIZE)
		p->shift = 0;

	return (0);
}

int
client_update(struct ntp_peer *p, int trace)
{
	int	i, best = 0, good = 0;

	/*
	 * clock filter
	 * find the offset which arrived with the lowest delay
	 * use that as the peer update
	 * invalidate it and all older ones
	 */

	for (i = 0; good == 0 && i < OFFSET_ARRAY_SIZE; i++)
		if (p->reply[i].good) {
			good++;
			best = i;
		}

	for (; i < OFFSET_ARRAY_SIZE; i++)
		if (p->reply[i].good) {
			good++;
			if (p->reply[i].delay < p->reply[best].delay)
				best = i;
		}

	if (trace > 2)
		log_info("client_update, %d good, best = %3dms delay", good,
		    (int)((p->reply[best].delay + .0005) * 1000.));

	if (good < OFFSET_ARRAY_SIZE)
		return (-1);

	memcpy(&p->update, &p->reply[best], sizeof(p->update));
	if (priv_adjtime() == 0) {
		for (i = 0; i < OFFSET_ARRAY_SIZE; i++)
			if (p->reply[i].rcvd <= p->reply[best].rcvd)
				p->reply[i].good = 0;
	}
	return (0);
}

void
client_log_error(struct ntp_peer *peer, const char *operation, int error)
{
	const char *address;

	address = log_sockaddr((struct sockaddr *)&peer->addr->ss);
	if (peer->lasterror == error) {
		log_debug("%s %s: %s", operation, address, strerror(error));
		return;
	}
	peer->lasterror = error;
	log_warn("%s %s", operation, address);
}
@


1.19
log
@There is a reason why negative delays can happen, outlined in the comments
and http://lists.ntp.isc.org/pipermail/hackers/2003-September/000349.html

Work around by allowing a certain amount of negative delay as minimum per-
mitted delay, so systems with a PXA27x or VM on one side and a 64-bit HPET
Linux system on the other side can still work together. The minimum chosen
was minus one millisecond, to accomodate systems without a sub-millisecond
precision timekeep; the amount needed for VMs is undefined, for PXA27x see
http://www.mail-archive.com/misc%40openbsd.org/msg02393.html and TFM.

This change should significantly improve reaction of OpenNTPD once ported
to my DEB and RPM builds. However, #380737 (Debian) is still an issue; I
guess the adjustment syscalls fail to accept larger values, but wonder how
xntpd manages that (although it fails as well often enough).

This research driven by tarent GmbH and need for working time on domUs.
@
text
@d4 1
a4 1
 * Copyright (c) 2007, 2009 Thorsten Glaser <tg@@mirbsd.org>
d30 1
a30 1
__RCSID("$MirOS: src/usr.sbin/ntpd/client.c,v 1.18 2009/05/16 11:53:08 tg Exp $");
d143 6
a148 9

		   if (errno == EAFNOSUPPORT) {
		      log_warn("client_query socket");
		      client_nextaddr(p);
		      set_next(p, error_interval());
		      return (-1);
		   }
		   else
		   {
d150 1
a150 2
		   }
                }
@


1.18
log
@Stefan Praszalowicz <stefan.praszalowicz@@avedya.com>

DP: Rather than fail on IPv4 only networks when seeing an IPv6 DNS
record, just give a warning (Closes: #500676).
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/usr.sbin/ntpd/client.c,v 1.17 2009/05/16 11:52:31 tg Exp $");
d247 2
a248 2
	/*
	 * From RFC 2030 (with a correction to the delay math):
d257 2
a258 1
	 *  The roundtrip delay d and local clock offset t are defined as
d260 3
a262 1
	 *    d = (T4 - T1) - (T3 - T2)     t = ((T2 - T1) + (T3 - T4)) / 2.
d271 1
a271 1
	if (p->reply[p->shift].delay < 0) {
d281 2
@


1.17
log
@02-reconnect.dpatch by Kurt Roeckx <kurt@@roeckx.be>

DP: Reconnect after an EINVAL to make it work with dynamic IP addresses.
DP: (Closes: #392250)
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/usr.sbin/ntpd/client.c,v 1.16 2009/05/07 19:09:36 tg Exp $");
d142 10
a151 1
		    0)) == -1)
d153 3
@


1.16
log
@experimental (but tested): track the total # of valid peers
so that things like ntpmonitor can restart ntpd if it has
been down to 0 valid peers for 5 minutes or so

XXX need to debug what I believe is internal data structure corruption
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/usr.sbin/ntpd/client.c,v 1.15 2007/10/03 22:52:00 tg Exp $");
d128 1
d176 2
a177 2
	if (ntp_sendmsg(p->query->fd, NULL, &p->query->msg,
	    NTP_MSGSIZE_NOAUTH, 0) == -1) {
d179 8
@


1.15
log
@fix: use the correct constant
@
text
@d4 1
a4 1
 * Copyright (c) 2007 Thorsten Glaser <tg@@mirbsd.de>
d30 1
a30 1
__RCSID("$MirOS: src/usr.sbin/ntpd/client.c,v 1.14 2007/10/03 21:17:31 tg Exp $");
d287 3
a289 7
	if (p->trustlevel < TRUSTLEVEL_MAX) {
		if (p->trustlevel < TRUSTLEVEL_BADPEER &&
		    p->trustlevel + 1 >= TRUSTLEVEL_BADPEER)
			log_info("peer %s now valid",
			    log_sockaddr((struct sockaddr *)&p->addr->ss));
		p->trustlevel++;
	}
@


1.14
log
@spacing
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/usr.sbin/ntpd/client.c,v 1.13 2007/10/03 21:16:31 tg Exp $");
d339 1
a339 1
	if (good < 8)
@


1.13
log
@wording
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/usr.sbin/ntpd/client.c,v 1.12 2007/10/03 21:15:17 tg Exp $");
d336 1
a336 1
		log_info("client_update, %d good, best = %dms delay", good,
@


1.12
log
@merge and fix
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/usr.sbin/ntpd/client.c,v 1.11 2007/10/03 21:08:13 tg Exp $");
d336 1
a336 1
		log_info("client_update, %d good, best = %dms", good,
@


1.11
log
@merge and beautify
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/usr.sbin/ntpd/client.c,v 1.10 2007/10/03 20:54:54 tg Exp $");
d220 1
a220 1
		log_info("reply from %s: not synced, next query %llds",
d222 1
a222 1
		    (int64_t)interval);
d253 1
a253 1
		    p->reply[p->shift].delay, interval);
d296 1
a296 1
	    "next query %llds", log_sockaddr((struct sockaddr *)&p->addr->ss),
d298 1
a298 1
	    (int64_t)interval);
@


1.10
log
@add more traces
@
text
@d1 1
a1 2
/**	$MirOS: src/usr.sbin/ntpd/client.c,v 1.9 2007/09/26 12:38:47 tg Exp $ */
/*	$OpenBSD: client.c,v 1.66 2005/09/24 00:32:03 dtucker Exp $ */
d30 1
a30 1
__RCSID("$MirOS: src/usr.sbin/ntpd/client.c,v 1.9 2007/09/26 12:38:47 tg Exp $");
d250 2
a251 1
		log_info("reply from %s: negative delay %f",
d253 1
a253 1
		    p->reply[p->shift].delay);
d295 1
a295 1
	log_reply("reply from %s: offset %f delay %f, "
d336 2
a337 2
		log_info("client_update, %d good, best = %f", good,
		    p->reply[best].delay);
d343 5
a347 6
	priv_adjtime();

	for (i = 0; i < OFFSET_ARRAY_SIZE; i++)
		if (p->reply[i].rcvd <= p->reply[best].rcvd)
			p->reply[i].good = 0;

@


1.9
log
@improve the output from -t option to reduce my own confusion
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/ntpd/client.c,v 1.8 2007/08/17 16:20:01 tg Exp $ */
d31 1
a31 1
__RCSID("$MirOS: src/usr.sbin/ntpd/client.c,v 1.8 2007/08/17 16:20:01 tg Exp $");
d39 1
a39 1
int	client_update(struct ntp_peer *);
d300 1
a300 1
	client_update(p);
d311 1
a311 1
client_update(struct ntp_peer *p)
d335 4
@


1.8
log
@fix the other half of the endianness problem
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/ntpd/client.c,v 1.7 2007/08/10 22:22:02 tg Exp $ */
d31 1
a31 1
__RCSID("$MirOS: src/usr.sbin/ntpd/client.c,v 1.7 2007/08/10 22:22:02 tg Exp $");
d281 3
a283 2
		log_info("rcvd stratum %d dst %f peer %s",
		    msg.stratum, p->reply[p->shift].delay,
@


1.7
log
@new feature: use other UDP ports than 123 for peers or listening
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/ntpd/client.c,v 1.6 2007/07/31 20:32:45 tg Exp $ */
d31 1
a31 1
__RCSID("$MirOS: src/usr.sbin/ntpd/client.c,v 1.6 2007/07/31 20:32:45 tg Exp $");
d264 2
a265 2
	p->reply[p->shift].status.refid = ntohl(msg.refid);
	p->reply[p->shift].status.refid4 = msg.xmttime.fractionl;
@


1.6
log
@rejoice! tracing! use -t for adjtime tracing, -tt for recv tracing too
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/ntpd/client.c,v 1.5 2007/07/31 19:57:02 tg Exp $ */
d31 1
a31 1
__RCSID("$MirOS: src/usr.sbin/ntpd/client.c,v 1.5 2007/07/31 19:57:02 tg Exp $");
d94 1
a94 1
			/* not reached */
@


1.5
log
@introduce a most controversial feature (that's why not even documented):
the “serverloop” keyword.

What it does: act like “server” except that the stratum isn't, like nor-
mally when the peer's stratum is taken for our reply, increased by one.

What its use is: Imagine a home network of ≥2 boxen, connected to the
outside via a shared uplink (possibly IPv4 and IPv6, or two uplinks).
The boxen will each (this part is important!) configure at least one¹
server from outside using “server”, as usual, and each other (i.e. them-
selves, the boxen from the same LAN) using “serverloop” to stay syncho-
nised if the uplink(s) go away without having the stratum go rooftop.
¹) Using either 2 or 3 (or an even higher number) to make the total
number of usable servers odd (i.e. not even) is highly suggested.

Why people will hate me for it: it violates the (S)NTP RFCs.

What you should do instead of using it: get an udcf(4) or mbg(4) device
and do a local master using the sensors framework. Oops. Well, soonish.
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/ntpd/client.c,v 1.4 2005/12/18 00:59:36 tg Exp $ */
d31 1
a31 1
__RCSID("$MirOS: src/usr.sbin/ntpd/client.c,v 1.4 2005/12/18 00:59:36 tg Exp $");
d189 1
a189 1
client_dispatch(struct ntp_peer *p, u_int8_t settime)
d280 5
@


1.4
log
@add some compile-time reply debugging option
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/ntpd/client.c,v 1.3 2005/10/27 09:35:29 tg Exp $ */
d5 1
d31 1
a31 1
__RCSID("$MirOS: src/usr.sbin/ntpd/client.c,v 1.3 2005/10/27 09:35:29 tg Exp $");
d268 1
a268 1
	p->reply[p->shift].status.stratum = msg.stratum;
@


1.3
log
@merge
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.sbin/ntpd/client.c,v 1.2 2005/07/26 12:40:44 tg Exp $ */
d30 7
a36 1
__RCSID("$MirOS: src/usr.sbin/ntpd/client.c,v 1.2 2005/07/26 12:40:44 tg Exp $");
d288 1
a288 1
	log_debug("reply from %s: offset %f delay %f, "
@


1.2
log
@* merge OpenBSD
* clean up
* bring back not logging of minimal adjustments unless debug
* format spring cleanup
* passes __CRAZY build now
@
text
@d1 2
a2 2
/**	$MirOS$ */
/*	$OpenBSD: client.c,v 1.64 2005/07/11 08:04:28 dtucker Exp $ */
d30 1
a30 1
__RCSID("$MirOS$");
d204 1
a204 1
	ntp_getmsg(buf, size, &msg);
d253 1
a253 1
	p->reply[p->shift].status.leap = (msg.status & LIMASK) >> 6;
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$OpenBSD: client.c,v 1.51 2004/12/15 12:29:25 dtucker Exp $ */
d30 2
a32 1
void	set_next(struct ntp_peer *, time_t);
a33 1
time_t	scale_interval(time_t, double);
a48 14
time_t
scale_interval(time_t requested, double offset)
{
	if (offset < 0)
		offset = -offset;

	if (offset > QSCALE_OFF_MAX)
		return (requested);
	else if (offset < QSCALE_OFF_MIN)
		return (requested * (QSCALE_OFF_MAX / QSCALE_OFF_MIN));
	else
		return (requested * (QSCALE_OFF_MAX / offset));
}

d53 1
a53 1
		fatal("client_query calloc");
d59 1
d77 1
d83 1
d105 1
d124 5
a128 1
		set_next(p, INTERVAL_QUERY_PATHETIC);
a129 1
	}
d141 1
a141 1
				set_next(p, INTERVAL_QUERY_PATHETIC);
d193 4
a196 5
		    errno == ENETDOWN || errno == ECONNREFUSED) {
			log_warn("recvfrom %s",
			    log_sockaddr((struct sockaddr *)&p->addr->ss));
			interval = scale_interval(INTERVAL_QUERY_PATHETIC, 0.0);
			set_next(p, interval);
d212 1
a212 1
		interval = scale_interval(INTERVAL_QUERY_PATHETIC, 0.0);
d214 3
a216 2
		log_info("reply from %s: not synced, next query %ds",
		    log_sockaddr((struct sockaddr *)&p->addr->ss), interval);
d241 8
d258 1
d264 1
a264 1
		interval = INTERVAL_QUERY_PATHETIC;
d266 1
a266 1
		interval = INTERVAL_QUERY_AGRESSIVE;
d268 1
a268 2
		interval = scale_interval(INTERVAL_QUERY_NORMAL,
		    p->reply[p->shift].offset);
d282 5
a290 4
	log_debug("reply from %s: offset %f delay %f, "
	    "next query %ds", log_sockaddr((struct sockaddr *)&p->addr->ss),
	    p->reply[p->shift].offset, p->reply[p->shift].delay, interval);

d334 14
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@we like OpenNTPD so much we want to have current one
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.58 2005/03/08 12:31:40 henning Exp $ */
d30 1
d32 1
d48 14
d66 1
a66 1
		fatal("client_peer_init calloc");
a71 1
	p->lasterror = 0;
d133 2
a134 2
		set_next(p, error_interval());
		return (0);
d147 1
a147 1
				set_next(p, error_interval());
d199 5
a203 4
		    errno == ENETUNREACH || errno == ENETDOWN ||
		    errno == ECONNREFUSED) {
			client_log_error(p, "recvfrom", errno);
			set_next(p, error_interval());
d219 1
a219 1
		interval = error_interval();
d261 1
a261 1
		interval = scale_interval(INTERVAL_QUERY_PATHETIC);
d263 1
a263 1
		interval = scale_interval(INTERVAL_QUERY_AGRESSIVE);
d265 2
a266 1
		interval = scale_interval(INTERVAL_QUERY_NORMAL);
a330 14

void
client_log_error(struct ntp_peer *peer, const char *operation, int error)
{
	const char *address;

	address = log_sockaddr((struct sockaddr *)&peer->addr->ss);
	if (peer->lasterror == error) {
		log_debug("%s %s", operation, address);
		return;
	}
	peer->lasterror = error;
	log_warn("%s %s", operation, address);
}
@


1.1.1.3
log
@improve my Frankenstein OS (*wink* you know who you are) further
sans wchar_t of course

this is the essence of reading >1200 commit messages which suck
due to not having the new format of ours...
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.60 2005/04/19 11:08:41 henning Exp $ */
a230 8
	if (p->reply[p->shift].delay < 0) {
		interval = error_interval();
		set_next(p, interval);
		log_info("reply from %s: negative delay %f",
		    log_sockaddr((struct sockaddr *)&p->addr->ss),
		    p->reply[p->shift].delay);
		return (0);
	}
d263 4
a270 4
	client_update(p);
	if (settime)
		priv_settime(p->reply[p->shift].offset);

@


1.1.1.4
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.64 2005/07/11 08:04:28 dtucker Exp $ */
a73 1
			p->state = STATE_DNS_DONE;
a78 1
			p->state = STATE_DNS_DONE;
a99 1
		p->state = STATE_DNS_INPROGRESS;
a121 3
	if (p->state < STATE_DNS_DONE || p->addr == NULL)
		return (-1);

d185 1
a185 1
		    errno == ECONNREFUSED || errno == EADDRNOTAVAIL) {
a247 1
	p->reply[p->shift].status.refid4 = msg.xmttime.fractionl;
d330 1
a330 1
		log_debug("%s %s: %s", operation, address, strerror(error));
@


1.1.1.5
log
@current OpenNTPD
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.66 2005/09/24 00:32:03 dtucker Exp $ */
d201 1
a201 1
	ntp_getmsg((struct sockaddr *)&p->addr->ss, buf, size, &msg);
d249 1
a249 1
	p->reply[p->shift].status.leap = (msg.status & LIMASK);
@


1.1.1.6
log
@   Revision  [74]1.68  /  ([75]download) - [76]annotate - [77][select for diffs] , Mon May 29 20:51:54 2006
   UTC (16 months ago) by ckuethe
When ntpd backs off polling due to a negative delay, tell the user how long
it will wait until the next poll.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.68 2006/05/29 20:51:54 ckuethe Exp $ */
d240 1
a240 2
		log_info("reply from %s: negative delay %fs, "
		    "next query %ds",
d242 1
a242 1
		    p->reply[p->shift].delay, interval);
@


1.1.1.7
log
@   Revision [134]1.70 / ([135]download) - [136]annotate - [137][select for diffs] , Sun Jun 4 18:58:13 2006
   UTC (15 months, 4 weeks ago) by otto
Only invalidate stored replies if an adjustment was really made.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.69 2006/06/04 18:58:13 otto Exp $ */
d322 6
a327 5
	if (priv_adjtime() == 0) {
		for (i = 0; i < OFFSET_ARRAY_SIZE; i++)
			if (p->reply[i].rcvd <= p->reply[best].rcvd)
				p->reply[i].good = 0;
	}
@


