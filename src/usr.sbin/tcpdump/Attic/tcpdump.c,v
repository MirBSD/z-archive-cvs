head	1.6;
access;
symbols
	MIRBSD_9_BASE:1.4
	MIRBSD_8:1.4.0.2
	MIRBSD_8_BASE:1.4
	cvs-200507211800:1.1.1.4
	cvs-200504170300:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2007.07.09.18.34.38;	author tg;	state dead;
branches;
next	1.5;
commitid	10046927EFA5F897708;

1.5
date	2007.03.09.18.22.20;	author tg;	state Exp;
branches;
next	1.4;
commitid	10045F1A5886DC7AD6D;

1.4
date	2005.12.19.23.32.52;	author tg;	state Exp;
branches;
next	1.3;
commitid	10043A743396DFBA42A;

1.3
date	2005.12.04.15.47.56;	author tg;	state Exp;
branches;
next	1.2;
commitid	43543930fc1815f;

1.2
date	2005.04.19.15.22.51;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.31.12;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.31.12;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.17.03.33.09;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.04.19.15.19.31;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2005.07.21.21.04.09;	author tg;	state Exp;
branches;
next	;
commitid	560042e0092f571e;


desc
@@


1.6
log
@remove tcpdump, as I don't want to be in violation of the
new §202c StGB (German penal code), which I hereby oppose
but still have to formally obey.

I hope this is the only thing in base we could offend the
criminal persecutors with; we'll provide a port for it as
a way to shoot yourself into the foot but will not be le-
gally able to provide it ourselves. (As far as I'm infor-
med, existing installations and historic codebases aren't
affected as the law has yet to become effective.) It's an
utterly stupid law passed against experts' opinions, but…

Anyway, this code was ugly and a security nightmare.
@
text
@/*	$OpenBSD: tcpdump.c,v 1.46 2005/05/28 09:01:52 reyk Exp $	*/

/*
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#ifndef lint
static const char copyright[] =
    "@@(#) Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997\n\
The Regents of the University of California.  All rights reserved.\n";
static const char rcsid[] =
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.46 2005/05/28 09:01:52 reyk Exp $ (LBL)";
#endif

/*
 * tcpdump - monitor tcp/ip traffic on an ethernet.
 *
 * First written in 1987 by Van Jacobson, Lawrence Berkeley Laboratory.
 * Mercilessly hacked and occasionally improved since then via the
 * combined efforts of Van, Steve McCanne and Craig Leres of LBL.
 */

#include <sys/param.h>
#include <sys/time.h>
#include <sys/ioctl.h>
#include <sys/wait.h>

#include <netinet/in.h>

#include <pcap.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <ctype.h>
#include <err.h>
#include <errno.h>

#include "interface.h"
#include "addrtoname.h"
#include "machdep.h"
#include "setsignal.h"
#include "gmt2local.h"

#include <sys/socket.h>
#include <net/if.h>
#include <netinet/in.h>
#include <net/pfvar.h>
#include "pfctl.h"
#include "pfctl_parser.h"
#include "privsep.h"

__RCSID("$MirOS: src/usr.sbin/tcpdump/tcpdump.c,v 1.5 2007/03/09 18:22:20 tg Exp $");

int aflag;			/* translate network and broadcast addresses */
int dflag;			/* print filter code */
int eflag;			/* print ethernet header */
int fflag;			/* don't translate "foreign" IP address */
int Lflag;			/* List available link types */
int nflag;			/* leave addresses as numbers */
int Nflag;			/* remove domains from printed host names */
int Oflag = 1;			/* run filter code optimizer */
int oflag;			/* print passive OS fingerprints */
int pflag;			/* don't go promiscuous */
int qflag;			/* quick (shorter) output */
int Sflag;			/* print raw TCP sequence numbers */
int tflag = 1;			/* print packet arrival time */
int vflag;			/* verbose */
int xflag;			/* print packet in hex */
int Xflag;			/* print packet in emacs-hexl style */

int packettype;

char *program_name;

int32_t thiszone;		/* seconds offset from gmt to local time */

extern volatile pid_t child_pid;

/* Externs */
extern void bpf_dump(struct bpf_program *, int);
extern int esp_init(char *);

/* Forwards */
RETSIGTYPE cleanup(int);
RETSIGTYPE gotchld(int);
extern __dead void usage(void);

/* Length of saved portion of packet. */
int snaplen = DEFAULT_SNAPLEN;

struct printer {
	pcap_handler f;
	int type;
};

/* XXX needed if using old bpf.h */
#ifndef DLT_ATM_RFC1483
#define DLT_ATM_RFC1483 11
#endif

static struct printer printers[] = {
	{ ether_if_print,		DLT_EN10MB },
	{ ether_if_print,		DLT_IEEE802 },
	{ sl_if_print,			DLT_SLIP },
	{ sl_bsdos_if_print,		DLT_SLIP_BSDOS },
	{ ppp_if_print,			DLT_PPP },
	{ fddi_if_print,		DLT_FDDI },
	{ null_if_print,		DLT_NULL },
	{ raw_if_print,			DLT_RAW },
	{ atm_if_print,			DLT_ATM_RFC1483 },
	{ loop_if_print,		DLT_LOOP },
	{ enc_if_print,			DLT_ENC },
	{ pflog_if_print,		DLT_PFLOG },
	{ pflog_old_if_print,		DLT_OLD_PFLOG },
	{ pfsync_if_print,		DLT_PFSYNC },
	{ ppp_ether_if_print,		DLT_PPP_ETHER },
	{ NULL,				0 },
};

static pcap_handler
lookup_printer(int type)
{
	struct printer *p;

	for (p = printers; p->f; ++p)
		if (type == p->type)
			return p->f;

	error("unknown data link type 0x%x", type);
	/* NOTREACHED */
}

static int
init_pfosfp(void)
{
	pf_osfp_initialize();
	if (pfctl_file_fingerprints(-1,
	    PF_OPT_QUIET|PF_OPT_NOACTION, PF_OSFP_FILE) == 0)
		return 1;
	return 0;
}

static pcap_t *pd;

/* Multiple DLT support */
void		 pcap_list_linktypes(pcap_t *);
void		 pcap_print_linktype(u_int);

const struct pcap_linktype {
	u_int dlt_id;
	const char *dlt_name;
} pcap_linktypes[] = {
	{ DLT_NULL,		"NULL" },
	{ DLT_EN10MB,		"EN10MB" },
	{ DLT_EN3MB,		"EN3MB" },
	{ DLT_AX25,		"AX25" },
	{ DLT_PRONET,		"PRONET" },
	{ DLT_CHAOS,		"CHAOS" },
	{ DLT_IEEE802,		"IEEE802" },
	{ DLT_ARCNET,		"ARCNET" },
	{ DLT_SLIP,		"SLIP" },
	{ DLT_PPP,		"PPP" },
	{ DLT_FDDI,		"FDDI" },
	{ DLT_ATM_RFC1483,	"ATM_RFC1483" },
	{ DLT_LOOP,		"LOOP" },
	{ DLT_ENC,		"ENC" },
	{ DLT_RAW,		"RAW" },
	{ DLT_SLIP_BSDOS,	"SLIP_BSDOS" },
	{ DLT_PPP_BSDOS,	"PPP_BSDOS" },
	{ DLT_OLD_PFLOG,	"OLD_PFLOG" },
	{ DLT_PFSYNC,		"PFSYNC" },
	{ DLT_PPP_ETHER,	"PPP_ETHER" },
	{ DLT_IEEE802_11,	"IEEE802_11" },
	{ DLT_PFLOG,		"PFLOG" },
	{ 0,			NULL }
};

void
pcap_print_linktype(u_int dlt)
{
	const char *name;

	if ((name = pcap_datalink_val_to_name(dlt)) != NULL)
		fprintf(stderr, "%s\n", name);
	else
		fprintf(stderr, "<unknown: %u>\n", dlt);
}

extern int optind;
extern int opterr;
extern char *optarg;

int
main(int argc, char **argv)
{
	register int cnt, op, i;
	bpf_u_int32 localnet, netmask;
	register char *cp, *infile, *device, *RFileName, *WFileName;
	pcap_handler printer;
	struct bpf_program *fcode;
	RETSIGTYPE (*oldhandler)(int);
	u_char *pcap_userdata;
	char ebuf[PCAP_ERRBUF_SIZE];

	fprintf(stderr, "*** THIS IS AN EVIL HACK, DO NOT USE ***\n");

	cnt = -1;
	device = NULL;
	infile = NULL;
	RFileName = NULL;
	WFileName = NULL;

	if (priv_init(argc, argv))
		error("Failed to setup privsep");

	/* state: STATE_INIT */
	if ((cp = strrchr(argv[0], '/')) != NULL)
		program_name = cp + 1;
	else
		program_name = argv[0];

	if (abort_on_misalignment(ebuf, sizeof(ebuf)) < 0)
		error("%s", ebuf);

	opterr = 0;
	while ((op = getopt(argc, argv,
	    "ac:deE:fF:i:lLnNOopqr:s:StT:vw:xXy:Y")) != -1)
		switch (op) {

		case 'a':
			++aflag;
			break;

		case 'c':
			cnt = atoi(optarg);
			if (cnt <= 0)
				error("invalid packet count %s", optarg);
			break;

		case 'd':
			++dflag;
			break;

		case 'e':
			++eflag;
			break;

		case 'f':
			++fflag;
			break;

		case 'F':
			infile = optarg;
			break;

		case 'i':
			device = optarg;
			break;

		case 'l':
#ifdef HAVE_SETLINEBUF
			setlinebuf(stdout);
#else
			setvbuf(stdout, NULL, _IOLBF, 0);
#endif
			break;
		case 'L':
			++Lflag;
			break;
		case 'n':
			++nflag;
			break;

		case 'N':
			++Nflag;
			break;

		case 'O':
			Oflag = 0;
			break;

		case 'o':
				oflag = 1;
			break;

		case 'p':
			++pflag;
			break;

		case 'q':
			++qflag;
			break;

		case 'r':
			RFileName = optarg;
			break;

		case 's':
			snaplen = atoi(optarg);
			if (snaplen <= 0)
				error("invalid snaplen %s", optarg);
			break;

		case 'S':
			++Sflag;
			break;

		case 't':
			--tflag;
			break;

		case 'T':
			if (strcasecmp(optarg, "vat") == 0)
				packettype = PT_VAT;
			else if (strcasecmp(optarg, "wb") == 0)
				packettype = PT_WB;
			else if (strcasecmp(optarg, "rpc") == 0)
				packettype = PT_RPC;
			else if (strcasecmp(optarg, "rtp") == 0)
				packettype = PT_RTP;
			else if (strcasecmp(optarg, "rtcp") == 0)
				packettype = PT_RTCP;
			else if (strcasecmp(optarg, "cnfp") == 0)
				packettype = PT_CNFP;
			else if (strcasecmp(optarg, "vrrp") == 0)
				packettype = PT_VRRP;
			else if (strcasecmp(optarg, "tcp") == 0)
				packettype = PT_TCP;
			else if (strcasecmp(optarg, "sack") == 0)
				snaplen = SACK_SNAPLEN;
			else
				error("unknown packet type `%s'", optarg);
			break;

		case 'v':
			++vflag;
			break;

		case 'w':
			WFileName = optarg;
			break;
#ifdef YYDEBUG
		case 'Y':
			{
			/* Undocumented flag */
			extern int yydebug;
			yydebug = 1;
			}
			break;
#endif
		case 'x':
			++xflag;
			break;

		case 'X':
			++Xflag;
			if (xflag == 0) ++xflag;
			break;

		case 'E':
			if (esp_init(optarg) < 0)
				error("bad esp specification `%s'", optarg);
			break;

		default:
			usage();
			/* NOTREACHED */
		}

	if (snaplen == 0) {
			snaplen = DEFAULT_SNAPLEN;
	}

	if (aflag && nflag)
		error("-a and -n options are incompatible");

	if (RFileName != NULL) {
		pd = priv_pcap_offline(RFileName, ebuf);
		if (pd == NULL)
			error("%s", ebuf);

		/* state: STATE_BPF */
		localnet = 0;
		netmask = 0;
		if (fflag != 0)
			error("-f and -r options are incompatible");
	} else {
		if (device == NULL) {
			device = pcap_lookupdev(ebuf);
			if (device == NULL)
				error("%s", ebuf);
		}
		pd = priv_pcap_live(device, snaplen, !pflag, 1000, ebuf, 0);
		if (pd == NULL)
			error("%s", ebuf);

		/* state: STATE_BPF */
		i = pcap_snapshot(pd);
		if (snaplen < i) {
			warning("snaplen raised from %d to %d", snaplen, i);
			snaplen = i;
		}

		if (pcap_lookupnet(device, &localnet, &netmask, ebuf)) {
			warning("%s", ebuf);
			localnet = 0;
			netmask = 0;
		}
	}

	fcode = priv_pcap_setfilter(pd, Oflag, netmask);
	/* state: STATE_FILTER */
	if (fcode == NULL)
		error("%s", pcap_geterr(pd));
	if (dflag) {
		bpf_dump(fcode, dflag);
		exit(0);
	}
	init_addrtoname(localnet, netmask);

	setsignal(SIGTERM, cleanup);
	setsignal(SIGINT, cleanup);
	setsignal(SIGCHLD, gotchld);
	/* Cooperate with nohup(1) XXX is this still necessary/working? */
	if ((oldhandler = setsignal(SIGHUP, cleanup)) != SIG_DFL)
		(void)setsignal(SIGHUP, oldhandler);

	if (WFileName) {
		pcap_dumper_t *p;

		p = priv_pcap_dump_open(pd, WFileName);
		/* state: STATE_RUN */
		if (p == NULL)
			error("%s", pcap_geterr(pd));
		{
			FILE *fp = (FILE *)p;	/* XXX touching pcap guts! */
			fflush(fp);
			setvbuf(fp, NULL, _IONBF, 0);
		}
		printer = pcap_dump;
		pcap_userdata = (u_char *)p;
	} else {
		printer = lookup_printer(pcap_datalink(pd));
		pcap_userdata = 0;
		priv_init_done();
		/* state: STATE_RUN */
	}
	if (RFileName == NULL) {
		(void)fprintf(stderr, "%s: listening on %s\n",
		    program_name, device);
		(void)fflush(stderr);
	}

	if (oflag)
		oflag = init_pfosfp();
	if (tflag > 0)
		thiszone = gmt2local(0);


	if (pcap_loop(pd, cnt, printer, pcap_userdata) < 0) {
		(void)fprintf(stderr, "%s: pcap_loop: %s\n",
		    program_name, pcap_geterr(pd));
		exit(1);
	}
	pcap_close(pd);
	exit(0);
}

/* make a clean exit on interrupts */
RETSIGTYPE
cleanup(int signo)
{
	struct pcap_stat stat;
	sigset_t allsigs;
	char buf[1024];

	sigfillset(&allsigs);
	sigprocmask(SIG_BLOCK, &allsigs, NULL);

	/* Can't print the summary if reading from a savefile */
	(void)write(STDERR_FILENO, "\n", 1);
	if (pd != NULL && pcap_file(pd) == NULL) {
		if (pcap_stats(pd, &stat) < 0) {
			(void)snprintf(buf, sizeof buf,
			    "pcap_stats: %s\n", pcap_geterr(pd));
			write(STDOUT_FILENO, buf, strlen(buf));
		} else {
			(void)snprintf(buf, sizeof buf,
			    "%d packets received by filter\n", stat.ps_recv);
			write(STDOUT_FILENO, buf, strlen(buf));
			(void)snprintf(buf, sizeof buf,
			    "%d packets dropped by kernel\n", stat.ps_drop);
			write(STDOUT_FILENO, buf, strlen(buf));
		}
	}
	_exit(0);
}

RETSIGTYPE
gotchld(int signo)
{
	pid_t pid;
	int status;
	int save_err = errno;

	do {
		pid = waitpid(child_pid, &status, WNOHANG);
		if (pid > 0 && (WIFEXITED(status) || WIFSIGNALED(status)))
			cleanup(0);
	} while (pid == -1 && errno == EINTR);

	if (pid == -1)
		_exit(1);

	errno = save_err;
}

/* dump the buffer in `emacs-hexl' style */
void
default_print_hexl(const u_char *cp, unsigned int length, unsigned int offset)
{
	unsigned int i, j, jm;
	int c;
	char ln[128], buf[128];

	printf("\n");
	for (i = 0; i < length; i += 0x10) {
		snprintf(ln, sizeof(ln), "  %04x: ",
		    (unsigned int)(i + offset));
		jm = length - i;
		jm = jm > 16 ? 16 : jm;

		for (j = 0; j < jm; j++) {
			if ((j % 2) == 1)
				snprintf(buf, sizeof(buf), "%02x ",
				    (unsigned int)cp[i+j]);
			else
				snprintf(buf, sizeof(buf), "%02x",
				    (unsigned int)cp[i+j]);
			strlcat(ln, buf, sizeof ln);
		}
		for (; j < 16; j++) {
			if ((j % 2) == 1)
				snprintf(buf, sizeof buf, "   ");
			else
				snprintf(buf, sizeof buf, "  ");
			strlcat(ln, buf, sizeof ln);
		}

		strlcat(ln, " ", sizeof ln);
		for (j = 0; j < jm; j++) {
			c = cp[i+j];
			c = isprint(c) ? c : '.';
			buf[0] = c;
			buf[1] = '\0';
			strlcat(ln, buf, sizeof ln);
		}
		printf("%s\n", ln);
	}
}

/* Like default_print() but data need not be aligned */
void
default_print_unaligned(register const u_char *cp, register u_int length)
{
	register u_int i, s;
	register int nshorts;

	if (Xflag) {
		/* dump the buffer in `emacs-hexl' style */
		default_print_hexl(cp, length, 0);
	} else {
		/* dump the buffer in old tcpdump style */
		nshorts = (u_int) length / sizeof(u_short);
		i = 0;
		while (--nshorts >= 0) {
			if ((i++ % 8) == 0)
				(void)printf("\n\t\t\t");
			s = *cp++;
			(void)printf(" %02x%02x", s, *cp++);
		}
		if (length & 1) {
			if ((i % 8) == 0)
				(void)printf("\n\t\t\t");
			(void)printf(" %02x", *cp);
		}
	}
}

void
default_print(register const u_char *bp, register u_int length)
{
	register const u_short *sp;
	register u_int i;
	register int nshorts;

	if (Xflag) {
		/* dump the buffer in `emacs-hexl' style */
		default_print_hexl(bp, length, 0);
	} else {
		/* dump the buffer in old tcpdump style */
		if ((long)bp & 1) {
			default_print_unaligned(bp, length);
			return;
		}
		sp = (u_short *)bp;
		nshorts = (u_int) length / sizeof(u_short);
		i = 0;
		while (--nshorts >= 0) {
			if ((i++ % 8) == 0)
				(void)printf("\n\t\t\t");
			(void)printf(" %04x", ntohs(*sp++));
		}
		if (length & 1) {
			if ((i % 8) == 0)
				(void)printf("\n\t\t\t");
			(void)printf(" %02x", *(u_char *)sp);
		}
	}
}

__dead void
usage(void)
{
	extern char version[];
	extern char pcap_version[];

	(void)fprintf(stderr, "%s version %s\n", program_name, version);
	(void)fprintf(stderr, "libpcap version %s\n", pcap_version);
	(void)fprintf(stderr,
"Usage: %s [-adefLlNnOopqStvXx] [-c count] [-E [espalg:]espkey] [-F file]\n",
	    program_name);
	(void)fprintf(stderr,
"\t\t[-i interface] [-r file] [-s snaplen] [-T type] [-w file]\n");
	(void)fprintf(stderr,
"\t\t[expression]\n");
	exit(1);
}
@


1.5
log
@unbreak after libpcap update
@
text
@d71 1
a71 1
__RCSID("$MirOS: src/usr.sbin/tcpdump/tcpdump.c,v 1.4 2005/12/19 23:32:52 tg Exp $");
@


1.4
log
@make tcpdump(8) build again, even if it is just scary
@
text
@d71 1
a71 1
__RCSID("$MirOS$");
a166 2
int		 pcap_datalink_name_to_val(const char *);
const char	*pcap_datalink_val_to_name(u_int);
a196 26
int
pcap_datalink_name_to_val(const char *name)
{
	int i;

	for (i = 0; pcap_linktypes[i].dlt_name != NULL; i++) {
		if (strcasecmp(pcap_linktypes[i].dlt_name, name) == 0)
			return (pcap_linktypes[i].dlt_id);
	}

	return (-1);
}

const char *
pcap_datalink_val_to_name(u_int dlt)
{
	int i;

	for (i = 0; pcap_linktypes[i].dlt_name != NULL; i++) {
		if (pcap_linktypes[i].dlt_id == dlt)
			return (pcap_linktypes[i].dlt_name);
	}

	return (NULL);
}

@


1.3
log
@merge (for now...)
@
text
@d40 1
a40 1
#include <sys/types.h>
d71 2
@


1.2
log
@revert the import, postpone for MirOS #9
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.39 2004/09/16 11:29:51 markus Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.39 2004/09/16 11:29:51 markus Exp $ (LBL)";
d42 2
d54 2
d75 1
d94 2
d102 1
d119 16
a134 16
	{ ether_if_print,	DLT_EN10MB },
	{ ether_if_print,	DLT_IEEE802 },
	{ sl_if_print,		DLT_SLIP },
	{ sl_bsdos_if_print,	DLT_SLIP_BSDOS },
	{ ppp_if_print,		DLT_PPP },
	{ fddi_if_print,	DLT_FDDI },
	{ null_if_print,	DLT_NULL },
	{ raw_if_print,		DLT_RAW },
	{ atm_if_print,		DLT_ATM_RFC1483 },
	{ loop_if_print, 	DLT_LOOP },
	{ enc_if_print, 	DLT_ENC },
	{ pflog_if_print, 	DLT_PFLOG },
	{ pflog_old_if_print, 	DLT_OLD_PFLOG },
	{ pfsync_if_print, 	DLT_PFSYNC },
	{ ppp_ether_if_print,	DLT_PPP_ETHER },
	{ NULL,			0 },
d162 72
d250 2
d271 2
a272 1
	while ((op = getopt(argc, argv, "ac:deE:fF:i:lnNOopqr:s:StT:vw:xXY")) != -1)
d312 3
a314 1

d415 4
d438 1
a438 1
		pd = priv_pcap_live(device, snaplen, !pflag, 1000, ebuf);
d468 1
d519 1
d522 3
d526 1
a527 4
#if 0
		(void)fflush(stdout);	/* XXX unsafe */
#endif
		(void)write(STDERR_FILENO, "\n", 1);
d544 19
d676 1
a676 1
"Usage: %s [-adeflnNoOpqStvxX] [-c count] [-E [espalg:]espkey] [-F file]\n",
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@some more updates/fixes from obsd
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.44 2005/03/30 22:13:54 moritz Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.44 2005/03/30 22:13:54 moritz Exp $ (LBL)";
a41 1
#include <sys/ioctl.h>
a51 1
#include <err.h>
a70 1
int Lflag;			/* List available link types */
d98 1
a98 1
int snaplen = 0;
d111 16
a126 18
	{ ether_if_print,		DLT_EN10MB },
	{ ether_if_print,		DLT_IEEE802 },
	{ sl_if_print,			DLT_SLIP },
	{ sl_bsdos_if_print,		DLT_SLIP_BSDOS },
	{ ppp_if_print,			DLT_PPP },
	{ fddi_if_print,		DLT_FDDI },
	{ null_if_print,		DLT_NULL },
	{ raw_if_print,			DLT_RAW },
	{ atm_if_print,			DLT_ATM_RFC1483 },
	{ loop_if_print,		DLT_LOOP },
	{ enc_if_print,			DLT_ENC },
	{ pflog_if_print,		DLT_PFLOG },
	{ pflog_old_if_print,		DLT_OLD_PFLOG },
	{ pfsync_if_print,		DLT_PFSYNC },
	{ ppp_ether_if_print,		DLT_PPP_ETHER },
	{ ieee802_11_if_print,		DLT_IEEE802_11 },
	{ ieee802_11_radio_if_print,	DLT_IEEE802_11_RADIO },
	{ NULL,				0 },
d134 1
a134 1
	for (p = printers; p->f; ++p) {
a136 1
	}
a153 101
/* Multiple DLT support */
void		 pcap_list_linktypes(pcap_t *);
void		 pcap_print_linktype(u_int);
int		 pcap_datalink_name_to_val(const char *);
const char	*pcap_datalink_val_to_name(u_int);

const struct pcap_linktype {
	u_int dlt_id;
	const char *dlt_name;
} pcap_linktypes[] = {
	{ DLT_NULL,		"NULL" },
	{ DLT_EN10MB,		"EN10MB" },
	{ DLT_EN3MB,		"EN3MB" },
	{ DLT_AX25,		"AX25" },
	{ DLT_PRONET,		"PRONET" },
	{ DLT_CHAOS,		"CHAOS" },
	{ DLT_IEEE802,		"IEEE802" },
	{ DLT_ARCNET,		"ARCNET" },
	{ DLT_SLIP,		"SLIP" },
	{ DLT_PPP,		"PPP" },
	{ DLT_FDDI,		"FDDI" },
	{ DLT_ATM_RFC1483,	"ATM_RFC1483" },
	{ DLT_LOOP,		"LOOP" },
	{ DLT_ENC,		"ENC" },
	{ DLT_RAW,		"RAW" },
	{ DLT_SLIP_BSDOS,	"SLIP_BSDOS" },
	{ DLT_PPP_BSDOS,	"PPP_BSDOS" },
	{ DLT_OLD_PFLOG,	"OLD_PFLOG" },
	{ DLT_PFSYNC,		"PFSYNC" },
	{ DLT_PPP_ETHER,	"PPP_ETHER" },
	{ DLT_IEEE802_11,	"IEEE802_11" },
	{ DLT_PFLOG,		"PFLOG" },
	{ DLT_IEEE802_11_RADIO,	"IEEE802_11_RADIO" },
	{ 0,			NULL }
};

int
pcap_datalink_name_to_val(const char *name)
{
	int i;

	for (i = 0; pcap_linktypes[i].dlt_name != NULL; i++) {
		if (strcasecmp(pcap_linktypes[i].dlt_name, name) == 0)
			return (pcap_linktypes[i].dlt_id);
	}

	return (-1);
}

const char *
pcap_datalink_val_to_name(u_int dlt)
{
	int i;

	for (i = 0; pcap_linktypes[i].dlt_name != NULL; i++) {
		if (pcap_linktypes[i].dlt_id == dlt)
			return (pcap_linktypes[i].dlt_name);
	}

	return (NULL);
}

void
pcap_print_linktype(u_int dlt)
{
	const char *name;

	if ((name = pcap_datalink_val_to_name(dlt)) != NULL)
		fprintf(stderr, "%s\n", name);
	else
		fprintf(stderr, "<unknown: %u>\n", dlt);
}

void
pcap_list_linktypes(pcap_t *p)
{
	int fd = p->fd;
	u_int n;

#define MAXDLT	100

	u_int dltlist[MAXDLT];
	struct bpf_dltlist dl = {MAXDLT, dltlist};

	if (fd < 0)
		error("Invalid bpf descriptor");

	if (ioctl(fd, BIOCGDLTLIST, &dl) < 0)
		err(1, "BIOCGDLTLIST");

	if (dl.bfl_len > MAXDLT)
		error("Invalid number of linktypes: %u\n", dl.bfl_len);

	fprintf(stderr, "%d link types supported:\n", dl.bfl_len);

	for (n = 0; n < dl.bfl_len; n++) {
		fprintf(stderr, "\t");
		pcap_print_linktype(dltlist[n]);
	}
}

a168 1
	u_int dlt = (u_int) -1;
d189 1
a189 2
	while ((op = getopt(argc, argv,
	    "ac:deE:fF:i:lLnNOopqr:s:StT:vw:xXy:Y")) != -1)
d205 1
d229 1
a229 3
		case 'L':
			++Lflag;
			break;
a310 7
		case 'y':
			i = pcap_datalink_name_to_val(optarg);
			if (i < 0)
				error("invalid data link type: %s", optarg);
			dlt = (u_int)i;
			break;

a329 11
	if (snaplen == 0) {
		switch (dlt) {
		case DLT_IEEE802_11_RADIO:
			snaplen = RADIOTAP_SNAPLEN;
			break;
		default:
			snaplen = DEFAULT_SNAPLEN;
			break;
		}
	}

d337 1
d349 1
a349 1
		pd = priv_pcap_live(device, snaplen, !pflag, 1000, ebuf, dlt);
a366 5
	if (Lflag) {
		pcap_list_linktypes(pd);
		exit(0);
	}

d404 1
a404 1
		(void)fprintf(stderr, "%s: listening on %s, link-type ",
a405 1
		pcap_print_linktype(pd->linktype);
d440 1
a440 1
			write(STDERR_FILENO, buf, strlen(buf));
d444 1
a444 1
			write(STDERR_FILENO, buf, strlen(buf));
d447 1
a447 1
			write(STDERR_FILENO, buf, strlen(buf));
d566 1
a566 1
"Usage: %s [-adefLlNnOopqStvXx] [-c count] [-E [espalg:]espkey] [-F file]\n",
d571 1
a571 1
"\t\t[-y datalinktype] [expression]\n");
@


1.1.1.3
log
@some "not yet"s
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.39 2004/09/16 11:29:51 markus Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.39 2004/09/16 11:29:51 markus Exp $ (LBL)";
d73 1
a129 1
#ifdef DLT_IEEE802_11_RADIO
a130 1
#endif
d161 1
a191 1
#ifdef DLT_IEEE802_11_RADIO
a192 1
#endif
d233 28
d298 1
a298 1
	    "ac:deE:fF:i:lnNOopqr:s:StT:vw:xXy:Y")) != -1)
d337 3
a339 1

a448 1
#ifdef DLT_IEEE802_11_RADIO
a451 1
#endif
d494 5
d699 1
a699 1
"Usage: %s [-adeflNnOopqStvXx] [-c count] [-E [espalg:]espkey] [-F file]\n",
@


1.1.1.4
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.46 2005/05/28 09:01:52 reyk Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.46 2005/05/28 09:01:52 reyk Exp $ (LBL)";
a42 1
#include <sys/wait.h>
a53 1
#include <errno.h>
a72 1
int Lflag;			/* List available link types */
a90 2
extern volatile pid_t child_pid;

a96 1
RETSIGTYPE gotchld(int);
d129 1
d131 1
a161 1
void		 pcap_list_linktypes(pcap_t *);
d192 1
d194 1
a234 28
void
pcap_list_linktypes(pcap_t *p)
{
	int fd = p->fd;
	u_int n;

#define MAXDLT	100

	u_int dltlist[MAXDLT];
	struct bpf_dltlist dl = {MAXDLT, dltlist};

	if (fd < 0)
		error("Invalid bpf descriptor");

	if (ioctl(fd, BIOCGDLTLIST, &dl) < 0)
		err(1, "BIOCGDLTLIST");

	if (dl.bfl_len > MAXDLT)
		error("Invalid number of linktypes: %u\n", dl.bfl_len);

	fprintf(stderr, "%d link types supported:\n", dl.bfl_len);

	for (n = 0; n < dl.bfl_len; n++) {
		fprintf(stderr, "\t");
		pcap_print_linktype(dltlist[n]);
	}
}

d272 1
a272 1
	    "ac:deE:fF:i:lLnNOopqr:s:StT:vw:xXy:Y")) != -1)
d311 1
a311 3
		case 'L':
			++Lflag;
			break;
d421 1
a421 3
		case DLT_IEEE802_11:
			snaplen = IEEE802_11_SNAPLEN;
			break;
d423 1
a423 1
			snaplen = IEEE802_11_RADIO_SNAPLEN;
d425 1
a467 5
	if (Lflag) {
		pcap_list_linktypes(pd);
		exit(0);
	}

a479 1
	setsignal(SIGCHLD, gotchld);
a530 1
	sigset_t allsigs;
a532 3
	sigfillset(&allsigs);
	sigprocmask(SIG_BLOCK, &allsigs, NULL);

a533 1
	(void)write(STDERR_FILENO, "\n", 1);
d535 4
a554 19
RETSIGTYPE
gotchld(int signo)
{
	pid_t pid;
	int status;
	int save_err = errno;

	do {
		pid = waitpid(child_pid, &status, WNOHANG);
		if (pid > 0 && (WIFEXITED(status) || WIFSIGNALED(status)))
			cleanup(0);
	} while (pid == -1 && errno == EINTR);

	if (pid == -1)
		_exit(1);

	errno = save_err;
}

d668 1
a668 1
"Usage: %s [-adefLlNnOopqStvXx] [-c count] [-E [espalg:]espkey] [-F file]\n",
@


