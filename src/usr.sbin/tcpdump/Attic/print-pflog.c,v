head	1.6;
access;
symbols
	MIRBSD_9_BASE:1.5
	MIRBSD_8:1.5.0.2
	MIRBSD_8_BASE:1.5
	cvs-200512191930:1.1.1.4
	cvs-200507211800:1.1.1.3
	cvs-200504170300:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2007.07.09.18.34.31;	author tg;	state dead;
branches;
next	1.5;
commitid	10046927EFA5F897708;

1.5
date	2005.12.20.19.41.56;	author tg;	state Exp;
branches;
next	1.4;
commitid	10043A85DFB227044E6;

1.4
date	2005.12.19.20.06.00;	author tg;	state Exp;
branches;
next	1.3;
commitid	10043A712514EE19ACA;

1.3
date	2005.12.04.15.47.56;	author tg;	state Exp;
branches;
next	1.2;
commitid	43543930fc1815f;

1.2
date	2005.04.19.15.22.50;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.31.12;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.31.12;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.17.03.33.06;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.07.21.21.04.06;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	560042e0092f571e;

1.1.1.4
date	2005.12.19.19.38.30;	author tg;	state Exp;
branches;
next	;
commitid	10043A70C2C02EA4B14;


desc
@@


1.6
log
@remove tcpdump, as I don't want to be in violation of the
new §202c StGB (German penal code), which I hereby oppose
but still have to formally obey.

I hope this is the only thing in base we could offend the
criminal persecutors with; we'll provide a port for it as
a way to shoot yourself into the foot but will not be le-
gally able to provide it ourselves. (As far as I'm infor-
med, existing installations and historic codebases aren't
affected as the law has yet to become effective.) It's an
utterly stupid law passed against experts' opinions, but…

Anyway, this code was ugly and a security nightmare.
@
text
@/*	$OpenBSD: print-pflog.c,v 1.16 2005/05/27 17:22:41 dhartmei Exp $	*/

/*
 * Copyright (c) 1990, 1991, 1993, 1994, 1995, 1996
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#ifndef lint
static const char rcsid[] =
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pflog.c,v 1.17 2005/11/23 22:33:11 cloder Exp $ (LBL)";
#endif

#include <sys/param.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/mbuf.h>
#include <sys/proc.h>

#ifndef NO_PID
#define NO_PID	(32766+1)
#endif

struct rtentry;
#include <net/if.h>
#include <net/if_pflog.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>

#include <net/pfvar.h>

#include <ctype.h>
#include <netdb.h>
#include <pcap.h>
#include <signal.h>
#include <stdio.h>

#include "interface.h"
#include "addrtoname.h"

char *pf_reasons[PFRES_MAX+2] = PFRES_NAMES;

void
pflog_if_print(u_char *user, const struct pcap_pkthdr *h,
     register const u_char *p)
{
	u_int length = h->len;
	u_int hdrlen;
	u_int caplen = h->caplen;
	const struct ip *ip;
#ifdef INET6
	const struct ip6_hdr *ip6;
#endif
	const struct pfloghdr *hdr;
	u_int32_t res;
	char reason[128], *why;
	u_int8_t af;

	ts_print(&h->ts);

	// check length
	if (caplen < sizeof(u_int8_t)) {
		printf("[|pflog]");
		goto out;
	}

#define MIN_PFLOG_HDRLEN	45
	hdr = (struct pfloghdr *)p;
	if (hdr->length < MIN_PFLOG_HDRLEN) {
		printf("[pflog: invalid header length!]");
		goto out;
	}
	hdrlen = BPF_WORDALIGN(hdr->length);

	if (caplen < hdrlen) {
		printf("[|pflog]");
		goto out;
	}

	/*
	 * Some printers want to get back at the link level addresses,
	 * and/or check that they're not walking off the end of the packet.
	 * Rather than pass them all the way down, we set these globals.
	 */
	packetp = p;
	snapend = p + caplen;

	hdr = (struct pfloghdr *)p;
	if (eflag) {
		res = hdr->reason;
		why = (res < PFRES_MAX) ? pf_reasons[res] : "unkn";

		snprintf(reason, sizeof(reason), "%d(%s)", res, why);

		if (ntohl(hdr->subrulenr) == (u_int32_t) -1)
			printf("rule %u/%s: ",
			   ntohl(hdr->rulenr), reason);
		else
			printf("rule %u.%s.%u/%s: ", ntohl(hdr->rulenr),
			    hdr->ruleset, ntohl(hdr->subrulenr), reason);

		switch (hdr->action) {
		case PF_SCRUB:
			printf("scrub");
			break;
		case PF_PASS:
			printf("pass");
			break;
		case PF_DROP:
			printf("block");
			break;
		case PF_NAT:
		case PF_NONAT:
			printf("nat");
			break;
		case PF_BINAT:
		case PF_NOBINAT:
			printf("binat");
			break;
		case PF_RDR:
		case PF_NORDR:
			printf("rdr");
			break;
		}
		printf(" %s on %s: ",
		    hdr->dir == PF_OUT ? "out" : "in",
		    hdr->ifname);
	}
	af = hdr->af;
	length -= hdrlen;
	if (af == AF_INET) {
		ip = (struct ip *)(p + hdrlen);
		ip_print((const u_char *)ip, length);
		if (xflag)
			default_print((const u_char *)ip,
			    caplen - hdrlen);
	} else {
#ifdef INET6
		ip6 = (struct ip6_hdr *)(p + hdrlen);
		ip6_print((const u_char *)ip6, length);
		if (xflag)
			default_print((const u_char *)ip6,
			    caplen - hdrlen);
#endif
	}

out:
	putchar('\n');
}


void
pflog_old_if_print(u_char *user, const struct pcap_pkthdr *h,
     register const u_char *p)
{
	u_int length = h->len;
	u_int caplen = h->caplen;
	const struct ip *ip;
#ifdef INET6
	const struct ip6_hdr *ip6;
#endif
	const struct old_pfloghdr *hdr;
	u_short res;
	char reason[128], *why;
	u_int8_t af;

	ts_print(&h->ts);

	if (caplen < OLD_PFLOG_HDRLEN) {
		printf("[|pflog]");
		goto out;
	}

	/*
	 * Some printers want to get back at the link level addresses,
	 * and/or check that they're not walking off the end of the packet.
	 * Rather than pass them all the way down, we set these globals.
	 */
	packetp = p;
	snapend = p + caplen;

	hdr = (struct old_pfloghdr *)p;
	if (eflag) {
		res = ntohs(hdr->reason);
		why = (res < PFRES_MAX) ? pf_reasons[res] : "unkn";

		snprintf(reason, sizeof(reason), "%d(%s)", res, why);

		printf("rule %d/%s: ",
		    (short)ntohs(hdr->rnr), reason);
		switch (ntohs(hdr->action)) {
		case PF_SCRUB:
			printf("scrub");
			break;
		case PF_PASS:
			printf("pass");
			break;
		case PF_DROP:
			printf("block");
			break;
		case PF_NAT:
		case PF_NONAT:
			printf("nat");
			break;
		case PF_BINAT:
		case PF_NOBINAT:
			printf("binat");
			break;
		case PF_RDR:
		case PF_NORDR:
			printf("rdr");
			break;
		}
		printf(" %s on %s: ",
		    ntohs(hdr->dir) == PF_OUT ? "out" : "in",
		    hdr->ifname);
	}
	af = ntohl(hdr->af);
	length -= OLD_PFLOG_HDRLEN;
	if (af == AF_INET) {
		ip = (struct ip *)(p + OLD_PFLOG_HDRLEN);
		ip_print((const u_char *)ip, length);
		if (xflag)
			default_print((const u_char *)ip,
			    caplen - OLD_PFLOG_HDRLEN);
	} else {
#ifdef INET6
		ip6 = (struct ip6_hdr *)(p + OLD_PFLOG_HDRLEN);
		ip6_print((const u_char *)ip6, length);
		if (xflag)
			default_print((const u_char *)ip6,
			    caplen - OLD_PFLOG_HDRLEN);
#endif
	}

out:
	putchar('\n');
}
@


1.5
log
@Revert almost everything of the diff which updated PF.

Reason: pppoe(4) did not work any more (and HERC crashed, too).
Probable cause: the interface groups code.

I do not have time to look into this.
@
text
@@


1.4
log
@* fastmerge
* reduce diff against OpenBSD
  - re-introduce the "antispoof" keyword
  - re-introduce dynamic addresses (hope they work now)
  - re-introduce the 1000s units (kb Mb Gb)
* tweak sample pf.conf
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.17 2005/11/23 22:33:11 cloder Exp $	*/
d74 2
d80 1
a80 1
	/* check length */
d109 8
a116 15
		printf("rule ");
		if (ntohl(hdr->rulenr) == (u_int32_t) -1)
			printf("def");
		else {
			printf("%u", ntohl(hdr->rulenr));
			if (hdr->ruleset[0]) {
				printf(".%s", hdr->ruleset);
				if (ntohl(hdr->subrulenr) == (u_int32_t) -1)
					printf(".def");
				else
					printf(".%u", ntohl(hdr->subrulenr));
			}
		}
		if (hdr->reason < PFRES_MAX)
			printf("/(%s) ", pf_reasons[hdr->reason]);
d118 2
a119 4
			printf("/(unkn %u) ", (unsigned)hdr->reason);
		if (vflag)
			printf("[uid %u, pid %u] ", (unsigned)hdr->rule_uid,
			    (unsigned)hdr->rule_pid);
a146 3
		if (vflag && hdr->pid != NO_PID)
			printf("[uid %u, pid %u] ", (unsigned)hdr->uid,
			    (unsigned)hdr->pid);
@


1.3
log
@merge (for now...)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.16 2005/05/27 17:22:41 dhartmei Exp $	*/
d24 5
a73 2
	u_int32_t res;
	char reason[128], *why;
d78 1
a78 1
	// check length
d107 15
a121 8
		res = hdr->reason;
		why = (res < PFRES_MAX) ? pf_reasons[res] : "unkn";

		snprintf(reason, sizeof(reason), "%d(%s)", res, why);

		if (ntohl(hdr->subrulenr) == (u_int32_t) -1)
			printf("rule %u/%s: ",
			   ntohl(hdr->rulenr), reason);
d123 4
a126 2
			printf("rule %u.%s.%u/%s: ", ntohl(hdr->rulenr),
			    hdr->ruleset, ntohl(hdr->subrulenr), reason);
d154 3
@


1.2
log
@revert the import, postpone for MirOS #9
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.14 2003/06/21 21:01:15 dhartmei Exp $	*/
a23 5
#ifndef lint
static const char rcsid[] =
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pflog.c,v 1.14 2003/06/21 21:01:15 dhartmei Exp $ (LBL)";
#endif

d30 5
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@some more updates/fixes from obsd
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.15 2005/03/11 15:54:11 dhartmei Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pflog.c,v 1.15 2005/03/11 15:54:11 dhartmei Exp $ (LBL)";
d69 2
d104 8
a111 15
		printf("rule ");
		if (ntohl(hdr->rulenr) == (u_int32_t) -1)
			printf("def");
		else {
			printf("%u", ntohl(hdr->rulenr));
			if (hdr->ruleset[0]) {
				printf(".%s", hdr->ruleset);
				if (ntohl(hdr->subrulenr) == (u_int32_t) -1)
					printf(".def");
				else
					printf(".%u", ntohl(hdr->subrulenr));
			}
		}
		if (hdr->reason < PFRES_MAX)
			printf("/(%s) ", pf_reasons[hdr->reason]);
d113 2
a114 1
			printf("/(unkn %u) ", (unsigned)hdr->reason);
@


1.1.1.3
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.16 2005/05/27 17:22:41 dhartmei Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pflog.c,v 1.16 2005/05/27 17:22:41 dhartmei Exp $ (LBL)";
a34 5
#include <sys/proc.h>

#ifndef NO_PID
#define NO_PID	(32766+1)
#endif
a118 3
		if (vflag)
			printf("[uid %u, pid %u] ", (unsigned)hdr->rule_uid,
			    (unsigned)hdr->rule_pid);
a145 3
		if (vflag && hdr->pid != NO_PID)
			printf("[uid %u, pid %u] ", (unsigned)hdr->uid,
			    (unsigned)hdr->pid);
@


1.1.1.4
log
@For ftp-proxy(8) we need newer OpenIPF. I think it's time to import
pf-current from OpenBSD, since it's so buggy anyway... but I tagged
the old files in case something goes wrong.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.17 2005/11/23 22:33:11 cloder Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pflog.c,v 1.17 2005/11/23 22:33:11 cloder Exp $ (LBL)";
d78 1
a78 1
	/* check length */
@


