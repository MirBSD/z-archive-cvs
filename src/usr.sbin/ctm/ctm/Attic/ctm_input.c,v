head	1.3;
access;
symbols
	MIRBSD_8:1.2.0.2
	MIRBSD_8_BASE:1.2
	freebsd:1.1.9;
locks; strict;
comment	@ * @;


1.3
date	2006.06.09.00.55.26;	author tg;	state dead;
branches;
next	1.2;
commitid	1004488C6C72BD56C3F;

1.2
date	2005.03.13.19.16.20;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.01.38.31;	author tg;	state Exp;
branches
	1.1.9.1;
next	;

1.1.9.1
date	2005.02.05.01.38.31;	author tg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@* remove ctm, we don't use/support it at the moment,
  unslack base, and the code isn't audited anyway
* remove netgroup_mkdb, it doesn't suit MirOS' target
  audience (only makes sense in large/YP? environments)
* comment out ifstated, people might use ifwatchd instead,
  ifstated can't be used for pppoe(8) anyway; will be back
  on complaints, nuked else
@
text
@/* $MirOS: src/usr.sbin/ctm/ctm/ctm_input.c,v 1.2 2005/03/13 19:16:20 tg Exp $ */
/*
 * ----------------------------------------------------------------------------
 * "THE BEER-WARE LICENSE" (Revision 42):
 * <phk@@FreeBSD.org> wrote this file.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp
 * ----------------------------------------------------------------------------
 *
 * $FreeBSD: src/usr.sbin/ctm/ctm/ctm_input.c,v 1.10 2003/04/07 08:09:53 mckay Exp $
 *
 */

#include "ctm.h"

/*---------------------------------------------------------------------------*/
void
Fatal_(int ln, char *fn, char *kind)
{
    if(Verbose > 2)
	fprintf(stderr,"Fatal error. (%s:%d)\n",fn,ln);
    fprintf(stderr,"%s Fatal error: %s\n",FileName, kind);
}
#define Fatal(foo) Fatal_(__LINE__,__FILE__,foo)
#define Assert() Fatal_(__LINE__,__FILE__,"Assert failed.")

/*---------------------------------------------------------------------------*/
/* get next field, check that the terminating whitespace is what we expect */
u_char *
Ffield(FILE *fd, MD5_CTX *ctx,u_char term)
{
    static u_char buf[BUFSIZ];
    int i,l;

    for(l=0;;) {
	if((i=getc(fd)) == EOF) {
	    Fatal("Truncated patch.");
	    return 0;
	}
	buf[l++] = i;
	if(isspace(i))
	    break;
	if(l >= sizeof buf) {
	    Fatal("Corrupt patch.");
	    printf("Token is too long.\n");
	    return 0;
	}
    }
    buf[l] = '\0';
    MD5Update(ctx,buf,l);
    if(buf[l-1] != term) {
        Fatal("Corrupt patch.");
	fprintf(stderr,"Expected \"%s\" but didn't find it {%02x}.\n",
	    term == '\n' ? "\\n" : " ",buf[l-1]);
	if(Verbose > 4)
	    fprintf(stderr,"{%s}\n",buf);
	return 0;
    }
    buf[--l] = '\0';
    if(Verbose > 4)
        fprintf(stderr,"<%s>\n",buf);
    return buf;
}

int
Fbytecnt(FILE *fd, MD5_CTX *ctx, u_char term)
{
    u_char *p,*q;
    int u_chars=0;

    p = Ffield(fd,ctx,term);
    if(!p) return -1;
    for(q=p;*q;q++) {
	if(!isdigit(*q)) {
	    Fatal("Bytecount contains non-digit.");
	    return -1;
	}
	u_chars *= 10;
	u_chars += (*q - '0');
    }
    return u_chars;
}

u_char *
Fdata(FILE *fd, int u_chars, MD5_CTX *ctx)
{
    u_char *p = Malloc(u_chars+1);

    if(u_chars+1 != fread(p,1,u_chars+1,fd)) {
	Fatal("Truncated patch.");
	return 0;
    }
    MD5Update(ctx,p,u_chars+1);
    if(p[u_chars] != '\n') {
	if(Verbose > 3)
	    printf("FileData wasn't followed by a newline.\n");
        Fatal("Corrupt patch.");
	return 0;
    }
    p[u_chars] = '\0';
    return p;
}

/*---------------------------------------------------------------------------*/
/* get the filename in the next field, prepend BaseDir and give back the result
   strings. The sustitute filename is return (the one with the suffix SUBSUFF) 
   if it exists and the qualifier contains CTM_Q_Name_Subst
   NOTA: Buffer is already initialize with BaseDir, CatPtr is the insertion
   point on this buffer + the length test in Ffield() is enough for Fname() */

u_char *
Fname(FILE *fd, MD5_CTX *ctx,u_char term,int qual, int verbose)
{
    u_char * p;
    struct stat st;

    if ((p = Ffield(fd,ctx,term)) == NULL) return(NULL);

    strlcpy(CatPtr, p, CatPtrLen);

    if (!(qual & CTM_Q_Name_Subst)) return(Buffer);

    p = Buffer + strlen(Buffer);

    strlcat(Buffer, SUBSUFF, BUFSIZ);

    if ( -1 == stat(Buffer, &st) ) {
	*p = '\0';
    } else {
	if(verbose > 2)
	    fprintf(stderr,"Using %s as substitute file\n", Buffer);
    }

    return (Buffer);
}
@


1.2
log
@fast merge src/usr.sbin
@
text
@d1 1
a1 1
/* $MirOS$ */
@


1.1
log
@Initial revision
@
text
@d1 1
d119 1
a119 1
    strcpy(CatPtr, p);
d125 1
a125 1
    strcat(Buffer, SUBSUFF);
@


1.1.9.1
log
@And that's what we've got from FreeBSD.
@
text
@@
