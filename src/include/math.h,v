head	1.11;
access;
symbols
	MIRBSD_10:1.7.0.2
	MIRBSD_10_BASE:1.7
	cvs-200611031400:1.1.3.1
	netbsd:1.1.3
	MIRBSD_9_BASE:1.4
	MIRBSD_8:1.4.0.2
	MIRBSD_8_BASE:1.4
	cvs-200509221800:1.1.1.1
	cvs-200507211800:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2012.09.04.18.04.54;	author tg;	state Exp;
branches;
next	1.10;
commitid	100504642D44CBE5067;

1.10
date	2012.09.04.17.55.23;	author tg;	state Exp;
branches;
next	1.9;
commitid	100504640A23147FE2A;

1.9
date	2008.11.11.03.57.17;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004919029A2A70933D;

1.8
date	2008.11.10.21.09.12;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004918A3056B05023F;

1.7
date	2006.11.03.18.10.40;	author tg;	state Exp;
branches;
next	1.6;
commitid	100454B862956081199;

1.6
date	2006.11.03.01.47.11;	author tg;	state Exp;
branches;
next	1.5;
commitid	100454A9FB070E2B455;

1.5
date	2006.11.03.01.41.38;	author tg;	state Exp;
branches;
next	1.4;
commitid	100454A9E664DB00C95;

1.4
date	2005.11.21.19.47.07;	author tg;	state Exp;
branches;
next	1.3;
commitid	2ab3438224310040;

1.3
date	2005.11.21.19.46.18;	author tg;	state Exp;
branches;
next	1.2;
commitid	77d7438224189c30;

1.2
date	2005.11.21.19.45.59;	author tg;	state Exp;
branches;
next	1.1;
commitid	264043822402ef0c;

1.1
date	2005.02.05.17.24.34;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.3.1;
next	;

1.1.1.1
date	2005.02.05.17.24.34;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.11.03.01.33.23;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	100454A9C75705F73D8;

1.1.1.3
date	2006.11.03.01.46.48;	author tg;	state Exp;
branches;
next	;
commitid	100454A9F974047C905;

1.1.3.1
date	2006.11.03.14.20.59;	author tg;	state Exp;
branches;
next	;
commitid	100454B505850533E95;


desc
@@


1.11
log
@mostly sync with TNF (we don't have tgamma() yet)
@
text
@/**	$MirOS: src/include/math.h,v 1.9 2008/11/11 03:57:17 tg Exp $ */
/*	$NetBSD: math.h,v 1.58 2012/05/05 22:07:57 christos Exp $	*/
/*	$OpenBSD: math.h,v 1.14 2006/07/12 07:26:07 brad Exp $	*/

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/*
 * @@(#)fdlibm.h 5.1 93/09/24
 */

#ifndef _MATH_H_
#define _MATH_H_ "$MirOS: src/include/math.h,v 1.9 2008/11/11 03:57:17 tg Exp $"

#include <sys/cdefs.h>
#ifdef __NetBSD__
#include <sys/featuretest.h>
#endif

union __float_u {
	unsigned char __dummy[sizeof(float)];
	float __val;
};

union __double_u {
	unsigned char __dummy[sizeof(double)];
	double __val;
};

#ifndef __MirBSD__
union __long_double_u {
	unsigned char __dummy[sizeof(long double)];
	long double __val;
};
#else
#ifdef __HAVE_LONG_DOUBLE
# warning Huh, long double on MirBSD, since when?
#endif
#endif

#include <machine/math.h>		/* may use __float_u, __double_u,
					   or __long_double_u */

#ifdef __HAVE_LONG_DOUBLE
#define	__fpmacro_unary_floating(__name, __arg0)			\
	/* LINTED */							\
	((sizeof (__arg0) == sizeof (float))				\
	?	__ ## __name ## f (__arg0)				\
	: (sizeof (__arg0) == sizeof (double))				\
	?	__ ## __name ## d (__arg0)				\
	:	__ ## __name ## l (__arg0))
#else
#define	__fpmacro_unary_floating(__name, __arg0)			\
	/* LINTED */							\
	((sizeof (__arg0) == sizeof (float))				\
	?	__ ## __name ## f (__arg0)				\
	:	__ ## __name ## d (__arg0))
#endif /* __HAVE_LONG_DOUBLE */

/*
 * ANSI/POSIX
 */
/* 7.12#3 HUGE_VAL, HUGELF, HUGE_VALL */
#if __GNUC_PREREQ__(3, 3)
#define HUGE_VAL	__builtin_huge_val()
#else
extern const union __double_u __infinity;
#define HUGE_VAL	__infinity.__val
#endif

/*
 * ISO C99
 */
#if !defined(_ANSI_SOURCE) && !defined(_POSIX_C_SOURCE) && \
    !defined(_XOPEN_SOURCE) || \
    ((__STDC_VERSION__ - 0) >= 199901L) || \
    ((_POSIX_C_SOURCE - 0) >= 200112L) || \
    ((_XOPEN_SOURCE  - 0) >= 600) || \
    defined(_ISOC99_SOURCE) || defined(_NETBSD_SOURCE) || __OPENBSD_VISIBLE
/* 7.12#3 HUGE_VAL, HUGELF, HUGE_VALL */
#if __GNUC_PREREQ__(3, 3)
#define	HUGE_VALF	__builtin_huge_valf()
#define	HUGE_VALL	__builtin_huge_vall()
#else
extern const union __float_u __infinityf;
#define	HUGE_VALF	__infinityf.__val

#ifdef __HAVE_LONG_DOUBLE
extern const union __long_double_u __infinityl;
#define	HUGE_VALL	__infinityl.__val
#endif
#endif

/* 7.12#4 INFINITY */
#if defined(__INFINITY)
#define	INFINITY	__INFINITY	/* float constant which overflows */
#elif __GNUC_PREREQ__(3, 3)
#define	INFINITY	__builtin_inff()
#else
#define	INFINITY	HUGE_VALF	/* positive infinity */
#endif /* __INFINITY */

/* 7.12#5 NAN: a quiet NaN, if supported */
#ifdef __HAVE_NANF
#if __GNUC_PREREQ__(3,3)
#define	NAN	__builtin_nanf("")
#else
extern const union __float_u __nanf;
#define	NAN		__nanf.__val
#endif
#endif /* __HAVE_NANF */

/* 7.12#6 number classification macros */
#define	FP_INFINITE	0x00
#define	FP_NAN		0x01
#define	FP_NORMAL	0x02
#define	FP_SUBNORMAL	0x03
#define	FP_ZERO		0x04
/* NetBSD extensions */
#define	_FP_LOMD	0x80		/* range for machine-specific classes */
#define	_FP_HIMD	0xff

#endif /* !_ANSI_SOURCE && ... */

/*
 * C99
 */

/* XXX just appease the committee for now, needs proper defs... */

typedef float float_t;
typedef double double_t;
#define FLT_EVAL_METHOD (-1)

/*
 * XOPEN/SVID
 */
#if !defined(_ANSI_SOURCE) && !defined(_POSIX_SOURCE)
#define	M_E		2.7182818284590452354	/* e */
#define	M_LOG2E		1.4426950408889634074	/* log 2e */
#define	M_LOG10E	0.43429448190325182765	/* log 10e */
#define	M_LN2		0.69314718055994530942	/* log e2 */
#define	M_LN10		2.30258509299404568402	/* log e10 */
#define	M_PI		3.14159265358979323846	/* pi */
#define	M_PI_2		1.57079632679489661923	/* pi/2 */
#define	M_PI_4		0.78539816339744830962	/* pi/4 */
#define	M_1_PI		0.31830988618379067154	/* 1/pi */
#define	M_2_PI		0.63661977236758134308	/* 2/pi */
#define	M_2_SQRTPI	1.12837916709551257390	/* 2/sqrt(pi) */
#define	M_SQRT2		1.41421356237309504880	/* sqrt(2) */
#define	M_SQRT1_2	0.70710678118654752440	/* 1/sqrt(2) */

#ifdef __vax__
#define	MAXFLOAT        ((float)1.70141173319264430e+38)
#else
#define	MAXFLOAT	((float)3.40282346638528860e+38)
#endif

extern int signgam;

#if !defined(_XOPEN_SOURCE)
enum fdversion {fdlibm_ieee = -1, fdlibm_svid, fdlibm_xopen, fdlibm_posix};

#define _LIB_VERSION_TYPE enum fdversion
#define _LIB_VERSION _fdlib_version

/* if global variable _LIB_VERSION is not desirable, one may
 * change the following to be a constant by:
 *	#define _LIB_VERSION_TYPE const enum version
 * In that case, after one initializes the value _LIB_VERSION (see
 * s_lib_version.c) during compile time, it cannot be modified
 * in the middle of a program
 */
extern  _LIB_VERSION_TYPE  _LIB_VERSION;

#define _IEEE_  fdlibm_ieee
#define _SVID_  fdlibm_svid
#define _XOPEN_ fdlibm_xopen
#define _POSIX_ fdlibm_posix

#ifndef __cplusplus
struct exception {
	int type;
	const char *name;
	double arg1;
	double arg2;
	double retval;
};
#endif

#define	HUGE		MAXFLOAT

/*
 * set X_TLOSS = pi*2**52, which is possibly defined in <values.h>
 * (one may replace the following line by "#include <values.h>")
 */

#define X_TLOSS		1.41484755040568800000e+16

#define	DOMAIN		1
#define	SING		2
#define	OVERFLOW	3
#define	UNDERFLOW	4
#define	TLOSS		5
#define	PLOSS		6

#endif /* !_XOPEN_SOURCE */
#endif /* !_ANSI_SOURCE && !_POSIX_SOURCE */

__BEGIN_DECLS
/*
 * ANSI/POSIX
 */
double	acos(double);
double	asin(double);
double	atan(double);
double	atan2(double, double);
double	cos(double);
double	sin(double);
double	tan(double);

double	cosh(double);
double	sinh(double);
double	tanh(double);

double	exp(double);
double	exp2(double);
double	frexp(double, int *);
double	ldexp(double, int);
double	log(double);
double	log2(double);
double	log10(double);
double	modf(double, double *);

double	pow(double, double);
double	sqrt(double);

double	ceil(double);
double	fabs(double);
double	floor(double);
double	fmod(double, double);

#if !defined(_ANSI_SOURCE) && !defined(_POSIX_SOURCE)
double	erf(double);
double	erfc(double);
double	gamma(double);
double	hypot(double, double);
int	finite(double);
double	j0(double);
double	j1(double);
double	jn(int, double);
double	lgamma(double);
double	y0(double);
double	y1(double);
double	yn(int, double);

#if !defined(_XOPEN_SOURCE)
double	acosh(double);
double	asinh(double);
double	atanh(double);
double	cbrt(double);
double	expm1(double);
int	ilogb(double);
double	log1p(double);
double	logb(double);
double	nextafter(double, double);
double	remainder(double, double);
double	rint(double);
double	scalb(double, double);
#endif /* (_XOPEN_SOURCE - 0) >= 500 || defined(_NETBSD_SOURCE)*/
#endif /* _XOPEN_SOURCE || _NETBSD_SOURCE */

/*
 * ISO C99
 */
#if !defined(_ANSI_SOURCE) && !defined(_POSIX_C_SOURCE) && \
    !defined(_XOPEN_SOURCE) || \
    ((__STDC_VERSION__ - 0) >= 199901L) || \
    ((_POSIX_C_SOURCE - 0) >= 200112L) || \
    ((_XOPEN_SOURCE  - 0) >= 600) || \
    defined(_ISOC99_SOURCE) || defined(_NETBSD_SOURCE) || __OPENBSD_VISIBLE
/* 7.12.3.1 int fpclassify(real-floating x) */
#define	fpclassify(__x)	__fpmacro_unary_floating(fpclassify, __x)

/* 7.12.3.2 int isfinite(real-floating x) */
#define	isfinite(__x)	__fpmacro_unary_floating(isfinite, __x)

/* 7.12.3.5 int isnormal(real-floating x) */
#define	isnormal(__x)	(fpclassify(__x) == FP_NORMAL)

/* 7.12.3.6 int signbit(real-floating x) */
#define	signbit(__x)	__fpmacro_unary_floating(signbit, __x)

/* 7.12.4 trigonometric */

float	acosf(float);
float	asinf(float);
float	atanf(float);
float	atan2f(float, float);
float	cosf(float);
float	sinf(float);
float	tanf(float);

/* 7.12.5 hyperbolic */

float	acoshf(float);
float	asinhf(float);
float	atanhf(float);
float	coshf(float);
float	sinhf(float);
float	tanhf(float);

/* 7.12.6 exp / log */

float	expf(float);
float	exp2f(float);
float	expm1f(float);
float	frexpf(float, int *);
int	ilogbf(float);
float	ldexpf(float, int);
float	logf(float);
float	log2f(float);
float	log10f(float);
float	log1pf(float);
float	logbf(float);
float	modff(float, float *);
float	scalbnf(float, int);

/* 7.12.7 power / absolute */

float	cbrtf(float);
float	fabsf(float);
float	hypotf(float, float);
float	powf(float, float);
float	sqrtf(float);

/* 7.12.8 error / gamma */

float	erff(float);
float	erfcf(float);
float	lgammaf(float);

/* 7.12.9 nearest integer */

float	ceilf(float);
float	floorf(float);
float	rintf(float);
double	round(double);
float	roundf(float);
double	trunc(double);
float	truncf(float);
long int	lrint(double);
long int	lrintf(float);
/* LONGLONG */
long long int	llrint(double);
/* LONGLONG */
long long int	llrintf(float);
long int	lround(double);
long int	lroundf(float);
/* LONGLONG */
long long int	llround(double);
/* LONGLONG */
long long int	llroundf(float);

/* 7.12.10 remainder */

float	fmodf(float, float);
float	remainderf(float, float);

/* 7.12.10.3 The remquo functions */
double	remquo(double, double, int *);
float	remquof(float, float, int *);

/* 7.12.11 manipulation */

float	copysignf(float, float);
double	nan(const char *);
float	nanf(const char *);
float	nextafterf(float, float);

/* 7.12.14 comparison */

#define isunordered(x, y)	(isnan(x) || isnan(y))
#define isgreater(x, y)		(!isunordered((x), (y)) && (x) > (y))
#define isgreaterequal(x, y)	(!isunordered((x), (y)) && (x) >= (y))
#define isless(x, y)		(!isunordered((x), (y)) && (x) < (y))
#define islessequal(x, y)	(!isunordered((x), (y)) && (x) <= (y))
#define islessgreater(x, y)	(!isunordered((x), (y)) && \
				 ((x) > (y) || (y) > (x)))
double	fdim(double, double);
double	fmax(double, double);
double	fmin(double, double);
float	fdimf(float, float);
float	fmaxf(float, float);
float	fminf(float, float);

#endif /* !_ANSI_SOURCE && ... */

#if !defined(_ANSI_SOURCE) && !defined(_POSIX_C_SOURCE) || \
    !defined(_XOPEN_SOURCE) || \
    ((__STDC_VERSION__ - 0) >= 199901L) || \
    ((_POSIX_C_SOURCE - 0) >= 200112L) || \
    defined(_ISOC99_SOURCE) || defined(_NETBSD_SOURCE) || __OPENBSD_VISIBLE
/* 7.12.3.3 int isinf(real-floating x) */
#ifdef __isinf
#define	isinf(__x)	__isinf(__x)
#else
#define	isinf(__x)	__fpmacro_unary_floating(isinf, __x)
#endif

/* 7.12.3.4 int isnan(real-floating x) */
#ifdef __isnan
#define	isnan(__x)	__isnan(__x)
#else
#define	isnan(__x)	__fpmacro_unary_floating(isnan, __x)
#endif
#endif /* !_ANSI_SOURCE && ... */

#if defined(_NETBSD_SOURCE) || __OPENBSD_VISIBLE
#ifndef __cplusplus
int	matherr(struct exception *);
#endif

/*
 * IEEE Test Vector
 */
double	significand(double);

/*
 * Functions callable from C, intended to support IEEE arithmetic.
 */
double	copysign(double, double);
double	scalbn(double, int);

/*
 * BSD math library entry points
 */
#ifndef __MATH_PRIVATE__
double	cabs(/* struct complex { double r; double i; } */);
#endif
double	drem(double, double);

#endif /* _NETBSD_SOURCE */

#if defined(_NETBSD_SOURCE) || defined(_REENTRANT) || __OPENBSD_VISIBLE
/*
 * Reentrant version of gamma & lgamma; passes signgam back by reference
 * as the second argument; user must allocate space for signgam.
 */
double	gamma_r(double, int *);
double	lgamma_r(double, int *);
#endif /* _NETBSD_SOURCE || _REENTRANT */


#if defined(_NETBSD_SOURCE) || __OPENBSD_VISIBLE

/* float versions of ANSI/POSIX functions */

float	gammaf(float);
int	isinff(float);
int	isnanf(float);
int	finitef(float);
float	j0f(float);
float	j1f(float);
float	jnf(int, float);
float	y0f(float);
float	y1f(float);
float	ynf(int, float);

float	scalbf(float, float);

/*
 * float version of IEEE Test Vector
 */
float	significandf(float);

/*
 * float versions of BSD math library entry points
 */
#ifndef __MATH_PRIVATE__
float	cabsf(/* struct complex { float r; float i; } */);
#endif
float	dremf(float, float);
#endif /* _NETBSD_SOURCE */

#if defined(_NETBSD_SOURCE) || defined(_REENTRANT) || __OPENBSD_VISIBLE
/*
 * Float versions of reentrant version of gamma & lgamma; passes
 * signgam back by reference as the second argument; user must
 * allocate space for signgam.
 */
float	gammaf_r(float, int *);
float	lgammaf_r(float, int *);
#endif /* !... || _REENTRANT */

/*
 * Library implementation
 */
int	__fpclassifyf(float);
int	__fpclassifyd(double);
int	__isfinitef(float);
int	__isfinited(double);
int	__isinff(float);
int	__isinfd(double);
int	__isnanf(float);
int	__isnand(double);
int	__signbitf(float);
int	__signbitd(double);

#ifdef __HAVE_LONG_DOUBLE
int	__fpclassifyl(long double);
int	__isfinitel(long double);
int	__isinfl(long double);
int	__isnanl(long double);
int	__signbitl(long double);
#endif
__END_DECLS

#endif /* _MATH_H_ */
@


1.10
log
@let this pass __CRAZY=Yes building
@
text
@d2 1
a3 1
/*	$NetBSD: math.h,v 1.44 2006/03/25 16:41:11 xtraeme Exp $	*/
d72 3
d77 1
d89 4
d100 1
d103 1
a103 1
#ifdef __INFINITY
d105 2
d113 3
d118 1
d382 1
a382 1
/* 7.2.11 manipulation */
@


1.9
log
@let _GNU_SOURCE and _ALL_SOURCE stuff see the _NETBSD_SOURCE stuff too

XXX what do we do about copysignl nowâ€¦ I wonder
@
text
@d1 1
a1 1
/**	$MirOS: src/include/math.h,v 1.8 2008/11/10 21:09:12 tg Exp $ */
d21 1
a21 1
#define _MATH_H_ "$MirOS: src/include/math.h,v 1.8 2008/11/10 21:09:12 tg Exp $"
d38 1
d43 5
d88 1
d91 1
d220 1
d309 1
d363 4
a369 1
long double copysignl(long double, long double);
a371 1
long double	nanl(const char *);
d374 15
@


1.8
log
@fake copysignl() to make libgfortran link
@
text
@d1 1
a1 1
/**	$MirOS: src/include/math.h,v 1.7 2006/11/03 18:10:40 tg Exp $ */
d21 1
a21 1
#define _MATH_H_ "$MirOS: src/include/math.h,v 1.7 2006/11/03 18:10:40 tg Exp $"
d77 1
a77 1
    defined(_ISOC99_SOURCE) || defined(_NETBSD_SOURCE)
d265 1
a265 1
    defined(_ISOC99_SOURCE) || defined(_NETBSD_SOURCE)
d369 1
a369 1
    defined(_ISOC99_SOURCE) || defined(_NETBSD_SOURCE)
d385 1
a385 1
#if defined(_NETBSD_SOURCE)
d411 1
a411 1
#if defined(_NETBSD_SOURCE) || defined(_REENTRANT)
d421 1
a421 1
#if defined(_NETBSD_SOURCE)
d452 1
a452 1
#if defined(_NETBSD_SOURCE) || defined(_REENTRANT)
@


1.7
log
@Switch to NetBSD libm
@
text
@d1 1
a1 1
/**	$MirOS: src/include/math.h,v 1.5 2006/11/03 01:41:38 tg Exp $ */
d21 1
a21 1
#define _MATH_H_ "$MirOS$"
d356 1
@


1.6
log
@unmerge visibility stuff
@
text
@d3 2
d17 1
a17 1
 * from: @@(#)fdlibm.h 5.1 93/09/24
d21 1
a21 1
#define _MATH_H_
d24 37
d65 44
a108 4
extern char __infinity[];
#ifndef HUGE_VAL
#define HUGE_VAL	(*(double *)(void *)__infinity)
#endif
d166 2
a167 2
#ifdef __LIBM_PRIVATE
struct __libm_exception {
d169 1
a169 1
	char *name;
d199 27
a225 29
extern double acos(double);
extern double asin(double);
extern double atan(double);
extern double atan2(double, double);
extern double cos(double);
extern double sin(double);
extern double tan(double);

extern double cosh(double);
extern double sinh(double);
extern double tanh(double);

extern double exp(double);
extern double frexp(double, int *);
extern double ldexp(double, int);
extern double log(double);
extern double log10(double);
extern double modf(double, double *);

extern double pow(double, double);
extern double sqrt(double);

extern double ceil(double);
extern double fabs(double);
extern double floor(double);
extern double fmod(double, double);

extern double round(double);
extern double trunc(double);
d228 12
a239 14
extern double erf(double);
extern double erfc(double);
extern double gamma(double);
extern double hypot(double, double);
extern int isinf(double);
extern int isnan(double);
extern int finite(double);
extern double j0(double);
extern double j1(double);
extern double jn(int, double);
extern double lgamma(double);
extern double y0(double);
extern double y1(double);
extern double yn(int, double);
d242 133
a374 8
extern double acosh(double);
extern double asinh(double);
extern double atanh(double);
extern double cbrt(double);
extern double logb(double);
extern double nextafter(double, double);
extern double remainder(double, double);
extern double scalb(double, double);
d376 11
a386 2
#ifdef __LIBM_PRIVATE
extern int matherr(struct __libm_exception *);
d392 1
a392 1
extern double significand(double);
d397 2
a398 8
extern double copysign(double, double);
extern int ilogb(double);
extern double rint(double);
extern long int lrint(double);
extern long int lround(double);
extern long long int llrint(double);
extern long long int llround(double);
extern double scalbn(double, int);
d403 4
a406 3
extern double drem(double, double);
extern double expm1(double);
extern double log1p(double);
d408 3
d415 4
a418 4
#ifdef _REENTRANT
extern double gamma_r(double, int *);
extern double lgamma_r(double, int *);
#endif /* _REENTRANT */
d420 1
d423 13
a435 53
extern float acosf(float);
extern float asinf(float);
extern float atanf(float);
extern float atan2f(float, float);
extern float cosf(float);
extern float sinf(float);
extern float tanf(float);

extern float coshf(float);
extern float sinhf(float);
extern float tanhf(float);

extern float expf(float);
extern float frexpf(float, int *);
extern float ldexpf(float, int);
extern float logf(float);
extern float log10f(float);
extern float modff(float, float *);

extern float powf(float, float);
extern float sqrtf(float);

extern float ceilf(float);
extern float fabsf(float);
extern float floorf(float);
extern float fmodf(float, float);

extern float roundf(float);
extern float truncf(float);

extern float erff(float);
extern float erfcf(float);
extern float gammaf(float);
extern float hypotf(float, float);
extern int isinff(float);
extern int isnanf(float);
extern int finitef(float);
extern float j0f(float);
extern float j1f(float);
extern float jnf(int, float);
extern float lgammaf(float);
extern float y0f(float);
extern float y1f(float);
extern float ynf(int, float);

extern float acoshf(float);
extern float asinhf(float);
extern float atanhf(float);
extern float cbrtf(float);
extern float logbf(float);
extern float nextafterf(float, float);
extern float remainderf(float, float);
extern float scalbf(float, float);
d440 1
a440 14
extern float significandf(float);

/*
 * Float versions of functions callable from C, intended to support
 * IEEE arithmetic.
 */
extern float copysignf(float, float);
extern int ilogbf(float);
extern float rintf(float);
extern long int lrintf(float);
extern long int lroundf(float);
extern long long int llrintf(float);
extern long long int llroundf(float);
extern float scalbnf(float, int);
d445 5
a449 3
extern float dremf(float, float);
extern float expm1f(float);
extern float log1pf(float);
d451 1
d457 25
a481 7
#ifdef _REENTRANT
extern float gammaf_r(float, int *);
extern float lgammaf_r(float, int *);
#endif	/* _REENTRANT */

#endif /* !_XOPEN_SOURCE */
#endif /* !_ANSI_SOURCE && !_POSIX_SOURCE */
@


1.5
log
@merge libm
@
text
@d1 1
a1 1
/**	$MirOS: src/include/math.h,v 1.4 2005/11/21 19:47:07 tg Exp $ */
d44 1
a44 1
#if __BSD_VISIBLE || __XPG_VISIBLE
a65 1
#endif /* __BSD_VISIBLE || __XPG_VISIBLE */
d67 1
a67 1
#if __BSD_VISIBLE
d113 2
a114 1
#endif /* __BSD_VISIBLE */
d150 1
a150 1
#if __BSD_VISIBLE || __XPG_VISIBLE
d166 1
a166 1
#if __BSD_VISIBLE || __XPG_VISIBLE >= 500
d208 1
a208 1
#if __BSD_VISIBLE || defined(_REENTRANT)
d211 1
a211 1
#endif /* __BSD_VISIBLE || _REENTRANT */
d299 1
a299 1
#if __BSD_VISIBLE || defined(_REENTRANT)
d302 1
a302 1
#endif /* __BSD_VISIBLE || _REENTRANT */
d304 2
a305 2
#endif /* __BSD_VISIBLE || __XPG_VISIBLE >= 500 */
#endif /* __BSD_VISIBLE || __XPG_VISIBLE */
@


1.4
log
@"exception" is a reserved keyword in C++
@
text
@d1 2
a2 2
/**	$MirOS: src/include/math.h,v 1.3 2005/11/21 19:46:18 tg Exp $ */
/*	$OpenBSD: math.h,v 1.9 2005/01/06 20:36:23 espie Exp $	*/
d21 2
d28 1
a28 1
#define HUGE_VAL	(*(double *) __infinity)
d44 1
a44 1
#if !defined(_ANSI_SOURCE) && !defined(_POSIX_SOURCE)
d66 1
d68 1
a68 1
#if !defined(_XOPEN_SOURCE)
d114 1
a114 3
#endif /* !_XOPEN_SOURCE */
#endif /* !_ANSI_SOURCE && !_POSIX_SOURCE */

a115 1
#include <sys/cdefs.h>
d147 4
a150 1
#if !defined(_ANSI_SOURCE) && !defined(_POSIX_SOURCE)
d166 1
a166 1
#if !defined(_XOPEN_SOURCE)
d191 4
d208 1
a208 1
#ifdef _REENTRANT
d211 1
a211 1
#endif /* _REENTRANT */
d242 3
d281 4
a289 1
extern float cabsf ();
d299 1
a299 1
#ifdef _REENTRANT
d302 1
a302 1
#endif	/* _REENTRANT */
d304 2
a305 2
#endif /* !_XOPEN_SOURCE */
#endif /* !_ANSI_SOURCE && !_POSIX_SOURCE */
@


1.3
log
@C99 doesn't come with our "broken" cabs()
@
text
@d1 1
a1 1
/**	$MirOS: src/include/math.h,v 1.2 2005/11/21 19:45:59 tg Exp $ */
d85 2
a86 2
#ifndef __cplusplus
struct exception {
d174 1
a174 1
extern int matherr(struct exception *);
@


1.2
log
@appease gcc: only #define HUGE_VAL if not yet defined
@
text
@d1 1
a1 1
/**	$MirOS$ */
a192 1
extern double cabs();
@


1.1
log
@Initial revision
@
text
@d1 1
d9 1
a9 1
 * software is freely granted, provided that this notice 
d25 1
d27 1
d29 1
a29 1
/* 
d69 1
a69 1
#define _LIB_VERSION _fdlib_version  
d71 2
a72 2
/* if global variable _LIB_VERSION is not desirable, one may 
 * change the following to be a constant by: 
d77 1
a77 1
 */ 
d97 1
a97 1
/* 
d102 1
a102 1
#define X_TLOSS		1.41484755040568800000e+16 
@


1.1.3.1
log
@Laugh at OpenBSD's libm and import NetBSD's
@
text
@d1 1
a1 2
/*	$NetBSD: math.h,v 1.44 2006/03/25 16:41:11 xtraeme Exp $	*/

d8 1
a8 1
 * software is freely granted, provided that this notice
d14 1
a14 1
 * @@(#)fdlibm.h 5.1 93/09/24
a19 37
#include <sys/cdefs.h>
#include <sys/featuretest.h>

union __float_u {
	unsigned char __dummy[sizeof(float)];
	float __val;
};

union __double_u {
	unsigned char __dummy[sizeof(double)];
	double __val;
};

union __long_double_u {
	unsigned char __dummy[sizeof(long double)];
	long double __val;
};

#include <machine/math.h>		/* may use __float_u, __double_u,
					   or __long_double_u */

#ifdef __HAVE_LONG_DOUBLE
#define	__fpmacro_unary_floating(__name, __arg0)			\
	/* LINTED */							\
	((sizeof (__arg0) == sizeof (float))				\
	?	__ ## __name ## f (__arg0)				\
	: (sizeof (__arg0) == sizeof (double))				\
	?	__ ## __name ## d (__arg0)				\
	:	__ ## __name ## l (__arg0))
#else
#define	__fpmacro_unary_floating(__name, __arg0)			\
	/* LINTED */							\
	((sizeof (__arg0) == sizeof (float))				\
	?	__ ## __name ## f (__arg0)				\
	:	__ ## __name ## d (__arg0))
#endif /* __HAVE_LONG_DOUBLE */

d23 6
a28 26
/* 7.12#3 HUGE_VAL, HUGELF, HUGE_VALL */
extern const union __double_u __infinity;
#define HUGE_VAL	__infinity.__val

/*
 * ISO C99
 */
#if !defined(_ANSI_SOURCE) && !defined(_POSIX_C_SOURCE) && \
    !defined(_XOPEN_SOURCE) || \
    ((__STDC_VERSION__ - 0) >= 199901L) || \
    ((_POSIX_C_SOURCE - 0) >= 200112L) || \
    ((_XOPEN_SOURCE  - 0) >= 600) || \
    defined(_ISOC99_SOURCE) || defined(_NETBSD_SOURCE)
/* 7.12#3 HUGE_VAL, HUGELF, HUGE_VALL */
extern const union __float_u __infinityf;
#define	HUGE_VALF	__infinityf.__val

extern const union __long_double_u __infinityl;
#define	HUGE_VALL	__infinityl.__val

/* 7.12#4 INFINITY */
#ifdef __INFINITY
#define	INFINITY	__INFINITY	/* float constant which overflows */
#else
#define	INFINITY	HUGE_VALF	/* positive infinity */
#endif /* __INFINITY */
d30 1
a30 15
/* 7.12#5 NAN: a quiet NaN, if supported */
#ifdef __HAVE_NANF
extern const union __float_u __nanf;
#define	NAN		__nanf.__val
#endif /* __HAVE_NANF */

/* 7.12#6 number classification macros */
#define	FP_INFINITE	0x00
#define	FP_NAN		0x01
#define	FP_NORMAL	0x02
#define	FP_SUBNORMAL	0x03
#define	FP_ZERO		0x04
/* NetBSD extensions */
#define	_FP_LOMD	0x80		/* range for machine-specific classes */
#define	_FP_HIMD	0xff
d32 3
a34 1
#endif /* !_ANSI_SOURCE && ... */
d39 1
a39 1
#if defined(_XOPEN_SOURCE) || defined(_NETBSD_SOURCE)
d54 3
d58 2
a60 1
#endif /* _XOPEN_SOURCE || _NETBSD_SOURCE */
d62 1
a62 1
#if defined(_NETBSD_SOURCE)
d66 1
a66 1
#define _LIB_VERSION _fdlib_version
d68 2
a69 2
/* if global variable _LIB_VERSION is not desirable, one may
 * change the following to be a constant by:
d74 1
a74 1
 */
d94 1
a94 1
/*
d99 1
a99 1
#define X_TLOSS		1.41484755040568800000e+16
d108 2
a109 1
#endif /* _NETBSD_SOURCE */
d111 2
d117 52
a168 184
double	acos(double);
double	asin(double);
double	atan(double);
double	atan2(double, double);
double	cos(double);
double	sin(double);
double	tan(double);

double	cosh(double);
double	sinh(double);
double	tanh(double);

double	exp(double);
double	frexp(double, int *);
double	ldexp(double, int);
double	log(double);
double	log2(double);
double	log10(double);
double	modf(double, double *);

double	pow(double, double);
double	sqrt(double);

double	ceil(double);
double	fabs(double);
double	floor(double);
double	fmod(double, double);

#if defined(_XOPEN_SOURCE) || defined(_NETBSD_SOURCE)
double	erf(double);
double	erfc(double);
double	gamma(double);
double	hypot(double, double);
int	finite(double);
double	j0(double);
double	j1(double);
double	jn(int, double);
double	lgamma(double);
double	y0(double);
double	y1(double);
double	yn(int, double);

#if (_XOPEN_SOURCE - 0) >= 500 || defined(_NETBSD_SOURCE)
double	acosh(double);
double	asinh(double);
double	atanh(double);
double	cbrt(double);
double	expm1(double);
int	ilogb(double);
double	log1p(double);
double	logb(double);
double	nextafter(double, double);
double	remainder(double, double);
double	rint(double);
double	scalb(double, double);
#endif /* (_XOPEN_SOURCE - 0) >= 500 || defined(_NETBSD_SOURCE)*/
#endif /* _XOPEN_SOURCE || _NETBSD_SOURCE */

/*
 * ISO C99
 */
#if !defined(_ANSI_SOURCE) && !defined(_POSIX_C_SOURCE) && \
    !defined(_XOPEN_SOURCE) || \
    ((__STDC_VERSION__ - 0) >= 199901L) || \
    ((_POSIX_C_SOURCE - 0) >= 200112L) || \
    ((_XOPEN_SOURCE  - 0) >= 600) || \
    defined(_ISOC99_SOURCE) || defined(_NETBSD_SOURCE)
/* 7.12.3.1 int fpclassify(real-floating x) */
#define	fpclassify(__x)	__fpmacro_unary_floating(fpclassify, __x)

/* 7.12.3.2 int isfinite(real-floating x) */
#define	isfinite(__x)	__fpmacro_unary_floating(isfinite, __x)

/* 7.12.3.5 int isnormal(real-floating x) */
#define	isnormal(__x)	(fpclassify(__x) == FP_NORMAL)

/* 7.12.3.6 int signbit(real-floating x) */
#define	signbit(__x)	__fpmacro_unary_floating(signbit, __x)

/* 7.12.4 trigonometric */

float	acosf(float);
float	asinf(float);
float	atanf(float);
float	atan2f(float, float);
float	cosf(float);
float	sinf(float);
float	tanf(float);

/* 7.12.5 hyperbolic */

float	acoshf(float);
float	asinhf(float);
float	atanhf(float);
float	coshf(float);
float	sinhf(float);
float	tanhf(float);

/* 7.12.6 exp / log */

float	expf(float);
float	expm1f(float);
float	frexpf(float, int *);
int	ilogbf(float);
float	ldexpf(float, int);
float	logf(float);
float	log2f(float);
float	log10f(float);
float	log1pf(float);
float	logbf(float);
float	modff(float, float *);
float	scalbnf(float, int);

/* 7.12.7 power / absolute */

float	cbrtf(float);
float	fabsf(float);
float	hypotf(float, float);
float	powf(float, float);
float	sqrtf(float);

/* 7.12.8 error / gamma */

float	erff(float);
float	erfcf(float);
float	lgammaf(float);

/* 7.12.9 nearest integer */

float	ceilf(float);
float	floorf(float);
float	rintf(float);
double	round(double);
float	roundf(float);
double	trunc(double);
float	truncf(float);
long int	lrint(double);
long int	lrintf(float);
/* LONGLONG */
long long int	llrint(double);
/* LONGLONG */
long long int	llrintf(float);
long int	lround(double);
long int	lroundf(float);
/* LONGLONG */
long long int	llround(double);
/* LONGLONG */
long long int	llroundf(float);

/* 7.12.10 remainder */

float	fmodf(float, float);
float	remainderf(float, float);

/* 7.2.11 manipulation */

float	copysignf(float, float);
double	nan(const char *);
float	nanf(const char *);
long double	nanl(const char *);
float	nextafterf(float, float);


#endif /* !_ANSI_SOURCE && ... */

#if !defined(_ANSI_SOURCE) && !defined(_POSIX_C_SOURCE) || \
    !defined(_XOPEN_SOURCE) || \
    ((__STDC_VERSION__ - 0) >= 199901L) || \
    ((_POSIX_C_SOURCE - 0) >= 200112L) || \
    defined(_ISOC99_SOURCE) || defined(_NETBSD_SOURCE)
/* 7.12.3.3 int isinf(real-floating x) */
#ifdef __isinf
#define	isinf(__x)	__isinf(__x)
#else
#define	isinf(__x)	__fpmacro_unary_floating(isinf, __x)
#endif

/* 7.12.3.4 int isnan(real-floating x) */
#ifdef __isnan
#define	isnan(__x)	__isnan(__x)
#else
#define	isnan(__x)	__fpmacro_unary_floating(isnan, __x)
#endif
#endif /* !_ANSI_SOURCE && ... */
d170 2
a171 3
#if defined(_NETBSD_SOURCE)
#ifndef __cplusplus
int	matherr(struct exception *);
d177 1
a177 1
double	significand(double);
d182 4
a185 2
double	copysign(double, double);
double	scalbn(double, int);
d190 4
a193 6
#ifndef __MATH_PRIVATE__
double	cabs(/* struct complex { double r; double i; } */);
#endif
double	drem(double, double);

#endif /* _NETBSD_SOURCE */
a194 1
#if defined(_NETBSD_SOURCE) || defined(_REENTRANT)
d199 4
a202 3
double	gamma_r(double, int *);
double	lgamma_r(double, int *);
#endif /* _NETBSD_SOURCE || _REENTRANT */
a204 2
#if defined(_NETBSD_SOURCE)

d206 50
d257 4
a260 12
float	gammaf(float);
int	isinff(float);
int	isnanf(float);
int	finitef(float);
float	j0f(float);
float	j1f(float);
float	jnf(int, float);
float	y0f(float);
float	y1f(float);
float	ynf(int, float);

float	scalbf(float, float);
d263 2
a264 1
 * float version of IEEE Test Vector
d266 4
a269 1
float	significandf(float);
d274 4
a277 5
#ifndef __MATH_PRIVATE__
float	cabsf(/* struct complex { float r; float i; } */);
#endif
float	dremf(float, float);
#endif /* _NETBSD_SOURCE */
a278 1
#if defined(_NETBSD_SOURCE) || defined(_REENTRANT)
d284 7
a290 25
float	gammaf_r(float, int *);
float	lgammaf_r(float, int *);
#endif /* !... || _REENTRANT */

/*
 * Library implementation
 */
int	__fpclassifyf(float);
int	__fpclassifyd(double);
int	__isfinitef(float);
int	__isfinited(double);
int	__isinff(float);
int	__isinfd(double);
int	__isnanf(float);
int	__isnand(double);
int	__signbitf(float);
int	__signbitd(double);

#ifdef __HAVE_LONG_DOUBLE
int	__fpclassifyl(long double);
int	__isfinitel(long double);
int	__isinfl(long double);
int	__isnanl(long double);
int	__signbitl(long double);
#endif
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import OpenBSD 4.0's libm
@
text
@d1 1
a1 1
/*	$OpenBSD: math.h,v 1.14 2006/07/12 07:26:07 brad Exp $	*/
a19 2
#include <sys/cdefs.h>

d24 1
a24 1
#define HUGE_VAL	(*(double *)(void *)__infinity)
d39 1
a39 1
#if __BSD_VISIBLE || __XPG_VISIBLE
a60 1
#endif /* __BSD_VISIBLE || __XPG_VISIBLE */
d62 1
a62 1
#if __BSD_VISIBLE
d108 3
a110 1
#endif /* __BSD_VISIBLE */
d112 1
d144 1
a144 4
extern double round(double);
extern double trunc(double);

#if __BSD_VISIBLE || __XPG_VISIBLE
d160 1
a160 1
#if __BSD_VISIBLE || __XPG_VISIBLE >= 500
a184 4
extern long int lrint(double);
extern long int lround(double);
extern long long int llrint(double);
extern long long int llround(double);
d199 1
a199 1
#if __BSD_VISIBLE || defined(_REENTRANT)
d202 1
a202 1
#endif /* __BSD_VISIBLE || _REENTRANT */
a232 3
extern float roundf(float);
extern float truncf(float);

a268 4
extern long int lrintf(float);
extern long int lroundf(float);
extern long long int llrintf(float);
extern long long int llroundf(float);
d284 1
a284 1
#if __BSD_VISIBLE || defined(_REENTRANT)
d287 1
a287 1
#endif /* __BSD_VISIBLE || _REENTRANT */
d289 2
a290 2
#endif /* __BSD_VISIBLE || __XPG_VISIBLE >= 500 */
#endif /* __BSD_VISIBLE || __XPG_VISIBLE */
@


1.1.1.3
log
@we don't really have __BSD_VISIBLE &c. yet
@
text
@d41 1
a41 1
#if !defined(_ANSI_SOURCE) && !defined(_POSIX_SOURCE)
d63 1
d65 1
a65 1
#if !defined(_XOPEN_SOURCE)
d111 1
a111 2
#endif /* !_XOPEN_SOURCE */
#endif /* !_ANSI_SOURCE && !_POSIX_SOURCE */
d147 1
a147 1
#if !defined(_ANSI_SOURCE) && !defined(_POSIX_SOURCE)
d163 1
a163 1
#if !defined(_XOPEN_SOURCE)
d206 1
a206 1
#ifdef _REENTRANT
d209 1
a209 1
#endif /* _REENTRANT */
d298 1
a298 1
#ifdef _REENTRANT
d301 1
a301 1
#endif	/* _REENTRANT */
d303 2
a304 2
#endif /* !_XOPEN_SOURCE */
#endif /* !_ANSI_SOURCE && !_POSIX_SOURCE */
@


