head	1.19;
access;
symbols
	MIRBSD_10:1.17.0.2
	MIRBSD_10_BASE:1.17
	MIRBSD_9_BASE:1.1.1.2
	MIRBSD_8:1.1.1.2.0.2
	MIRBSD_8_BASE:1.1.1.2
	cvs-200509221800:1.1.1.2
	cvs-200507211800:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2008.11.30.13.08.49;	author tg;	state Exp;
branches;
next	1.18;
commitid	100493290663125FF1F;

1.18
date	2008.03.22.21.10.35;	author tg;	state Exp;
branches;
next	1.17;
commitid	10047E575A244F9EDED;

1.17
date	2007.05.07.13.05.16;	author tg;	state Exp;
branches;
next	1.16;
commitid	100463F23E61B6C1395;

1.16
date	2007.03.22.03.57.49;	author tg;	state Exp;
branches;
next	1.15;
commitid	1004601FEAC02F93D70;

1.15
date	2007.03.22.03.06.48;	author tg;	state Exp;
branches;
next	1.14;
commitid	1004601F2D82B9C3378;

1.14
date	2007.02.08.04.34.47;	author tg;	state Exp;
branches;
next	1.13;
commitid	10045CAA874146DB790;

1.13
date	2007.02.08.04.31.02;	author tg;	state Exp;
branches;
next	1.12;
commitid	10045CAA7926900CB49;

1.12
date	2007.02.02.21.09.06;	author tg;	state Exp;
branches;
next	1.11;
commitid	10045C3A8841DC90DBB;

1.11
date	2007.02.02.21.06.16;	author tg;	state Exp;
branches;
next	1.10;
commitid	10045C3A79F53A9E808;

1.10
date	2007.02.02.19.22.37;	author tg;	state Exp;
branches;
next	1.9;
commitid	10045C38F6C12A5AF3B;

1.9
date	2007.02.02.17.53.55;	author tg;	state Exp;
branches;
next	1.8;
commitid	10045C379432B3162B9;

1.8
date	2006.12.11.23.54.56;	author tg;	state Exp;
branches;
next	1.7;
commitid	100457DEFC626A6A05C;

1.7
date	2006.11.02.13.52.15;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004549F81F30B2F582;

1.6
date	2006.11.02.13.36.31;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004549F3D0532921E6;

1.5
date	2006.11.02.01.35.48;	author tg;	state Exp;
branches;
next	1.4;
commitid	10045494B815DC07FB5;

1.4
date	2006.11.02.01.20.38;	author tg;	state Exp;
branches;
next	1.3;
commitid	100454947F5275A1E5B;

1.3
date	2006.11.02.00.07.06;	author tg;	state Exp;
branches;
next	1.2;
commitid	100454936BC10C66408;

1.2
date	2006.11.01.19.49.32;	author tg;	state Exp;
branches;
next	1.1;
commitid	1004548F9C65A1BC3D7;

1.1
date	2005.02.05.17.24.33;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.24.33;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.09.22.18.26.22;	author tg;	state Exp;
branches;
next	;
commitid	34fa4332f75ae8f7;


desc
@@


1.19
log
@if upper|lower, then title

still waiting for answer from Bruno Haible, though...
@
text
@/* $MirOS: src/include/ctype.h,v 1.18 2008/03/22 21:10:35 tg Exp $ */

/*-
 * Copyright (c) 2006, 2007, 2008
 *	Thorsten Glaser <tg@@mirbsd.de>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 */

#ifndef _CTYPE_H_
#define _CTYPE_H_

#include <sys/cdefs.h>

/* from src/lib/libc/include/mir18n.h,v 1.18 */
#define _ctp_alnum	0x000C
#define _ctp_alpha	0x0004
#define _ctp_blank	0x0040
#define _ctp_cntrl	0x0080
#define _ctp_digit	0x0408
#define _ctp_graph	0x1020
#define _ctp_lower	0x0102
#define _ctp_print	0x0020
#define _ctp_punct	0x1C20
#define _ctp_space	0x0010
#define _ctp_title	0x0003
#define _ctp_upper	0x0201
#define _ctp_xdigit	0x0008

__BEGIN_DECLS
int	isalnum(int);
int	isalpha(int);
int	iscntrl(int);
int	isdigit(int);
int	isgraph(int);
int	islower(int);
int	isprint(int);
int	ispunct(int);
int	isspace(int);
int	istitle(int);
int	isupper(int);
int	isxdigit(int);
int	tolower(int);
int	totitle(int);
int	toupper(int);

#if !defined(_ANSI_SOURCE) && !defined(_POSIX_SOURCE)
int	isascii(int);
#if __OPENBSD_VISIBLE
int	isbinry(int);
#endif
int	isblank(int);
int	toascii(int);
#endif /* !_ANSI_SOURCE && !_POSIX_SOURCE */

#if !defined(lint)

extern const unsigned char __C_attribute_table_pg[256];

#ifdef __GNUC__
#define __CTYPE_IMPL(c,t) __extension__({				\
	unsigned __CTYPE_Ic = (c);					\
									\
	(__CTYPE_Ic > 127) ? 0 :					\
	 ((__C_attribute_table_pg[__CTYPE_Ic] & (_ctp_ ## t & 0xFF)) &&	\
	 !(__C_attribute_table_pg[__CTYPE_Ic] & (_ctp_ ## t >> 8)));	\
})
#else
#define __CTYPE_IMPL(c,t)				\
	((((unsigned)(c)) > 127) ? 0 :			\
	 ((__C_attribute_table_pg[((unsigned)(c))] &	\
	    (_ctp_ ## t & 0xFF)) &&			\
	 !(__C_attribute_table_pg[((unsigned)(c))] &	\
	    (_ctp_ ## t >> 8))))
#endif

#define isalnum(c)	__CTYPE_IMPL((c),alnum)
#define isalpha(c)	__CTYPE_IMPL((c),alpha)
#define iscntrl(c)	__CTYPE_IMPL((c),cntrl)
#define isdigit(c)	__CTYPE_IMPL((c),digit)
#define isgraph(c)	__CTYPE_IMPL((c),graph)
#define islower(c)	__CTYPE_IMPL((c),lower)
#define isprint(c)	__CTYPE_IMPL((c),print)
#define ispunct(c)	__CTYPE_IMPL((c),punct)
#define isspace(c)	__CTYPE_IMPL((c),space)
#define istitle(c)	0
#define isupper(c)	__CTYPE_IMPL((c),upper)
#define isxdigit(c)	__CTYPE_IMPL((c),xdigit)

#ifdef __GNUC__
#define tolower(c)	__extension__({			\
	int __CTYPE_Tl = (c);				\
							\
	(__CTYPE_Tl >= 'A') && (__CTYPE_Tl <= 'Z') ?	\
	    __CTYPE_Tl - 'A' + 'a' : __CTYPE_Tl;	\
})
#define toupper(c)	__extension__({			\
	int __CTYPE_Tu = (c);				\
							\
	(__CTYPE_Tu >= 'a') && (__CTYPE_Tu <= 'z') ?	\
	    __CTYPE_Tu - 'a' + 'A' : __CTYPE_Tu;	\
})
#else
#define tolower(c)	(((c) >= 'A') && ((c) <= 'Z') ? (c) - 'A' + 'a' : (c))
#define toupper(c)	(((c) >= 'a') && ((c) <= 'z') ? (c) - 'a' + 'A' : (c))
#endif
#define totitle(c)	toupper(c)

#if !defined(_ANSI_SOURCE) && !defined(_POSIX_SOURCE)
#define isascii(c)	((unsigned)(c) < 0x80)
#define isblank(c)	__CTYPE_IMPL((c),blank)
#define toascii(c)	((c) & 0x7F)

#define _tolower(c)	((c) | 0x20)
#define _toupper(c)	((c) & 0xDF)
#endif /* !_ANSI_SOURCE && !_POSIX_SOURCE */

#if __OPENBSD_VISIBLE
#define isbinry(c)	__extension__({				\
	uint8_t __CTYPE_Ic = (c);				\
								\
	((__CTYPE_Ic == 0x00) || (__CTYPE_Ic == 0xC0) ||	\
	    (__CTYPE_Ic == 0xC1) || (__CTYPE_Ic > 0xEF));	\
})
#endif

#endif /* !lint */

__END_DECLS

#endif /* !_CTYPE_H_ */
@


1.18
log
@optimise a little
from a Jabber discussion with Jonathan Schleifer

you should write
| if (_toupper(c) == 'E')
instead of
| if (c == 'e' || c == 'E')
we agreed on (not that _toupper() only gives meaningful results for letters)
@
text
@d1 1
a1 1
/* $MirOS: src/include/ctype.h,v 1.17 2007/05/07 13:05:16 tg Exp $ */
d28 1
a28 1
/* from src/lib/libc/include/mir18n.h,v 1.14 */
d35 1
a35 1
#define _ctp_lower	0x0002
d39 2
a40 1
#define _ctp_upper	0x0001
d53 1
d57 1
d99 1
d120 1
@


1.17
log
@for __extension__({ type macros, the internal variable names MUST NOT match
anything that could ever be passed as argument, and the arguments SHALL NOT
be used when we already copy them to an internal variable

also fix some indenting

this was cause for segfault in bash-2.05b libglob xmbsrtowcs
@
text
@d1 1
a1 1
/* $MirOS: src/include/ctype.h,v 1.16 2007/03/22 03:57:49 tg Exp $ */
d4 1
a4 1
 * Copyright (c) 2006, 2007
d122 2
a123 2
#define _tolower(c)	((c) - 'A' + 'a')
#define _toupper(c)	((c) - 'a' + 'A')
@


1.16
log
@fix isbinry(3) implementation:
• gcc (correctly) tells me that an uint8_t is always <=0xFF
• “c” ./. “ch” confusion typo/thinko
@
text
@d1 1
a1 1
/* $MirOS: src/include/ctype.h,v 1.15 2007/03/22 03:06:48 tg Exp $ */
d73 1
d102 1
d108 1
d127 5
a131 4
#define isbinry(ch)	__extension__({	\
	uint8_t c = (ch);		\
	((c == 0x00) || (c == 0xC0) ||	\
	    (c == 0xC1) || (c > 0xEF));	\
@


1.15
log
@new: isbinry(), implemented as a macro in <ctype.h> (MirOS extension,
only visible with -D_ALL_SOURCE et al.) and in libc for lint only

returns true if its argument is one of the octets that aren't used in
CESU-8 text (C0, C1, F0..FF) or the NUL byte, 0 otherwise
@
text
@d1 1
a1 1
/* $MirOS: src/include/ctype.h,v 1.14 2007/02/08 04:34:47 tg Exp $ */
d124 4
a127 5
#define isbinry(ch)	__extension__({		\
	uint8_t c = (ch);			\
	((ch == 0x00) ||			\
	    (ch == 0xC0) || (ch == 0xC1) ||	\
	    ((ch >= 0xF0) && (ch <= 0xFF)));	\
@


1.14
log
@use unsigned instead of int where it makes sense to simplify
@
text
@d1 1
a1 1
/* $MirOS: src/include/ctype.h,v 1.13 2007/02/08 04:31:02 tg Exp $ */
d59 3
d123 9
@


1.13
log
@oops, prototype mismatch only cought by cvs configure
@
text
@d1 1
a1 1
/* $MirOS: src/include/ctype.h,v 1.12 2007/02/02 21:09:06 tg Exp $ */
d75 6
a80 4
#define __CTYPE_IMPL(c,t)						\
	(((((int)(c)) < 0) || (((int)(c)) > 127)) ? 0 :			\
	 ((__C_attribute_table_pg[((int)(c))] & (_ctp_ ## t & 0xFF)) &&	\
	 !(__C_attribute_table_pg[((int)(c))] & (_ctp_ ## t >> 8))))
d112 1
a112 1
#define isascii(c)	((unsigned int)(c) < 0x80)
@


1.12
log
@simplify #if stuff
@
text
@d1 1
a1 1
/* $MirOS: src/include/ctype.h,v 1.11 2007/02/02 21:06:16 tg Exp $ */
d95 1
a95 1
	char __CTYPE_Tl = (c);				\
d100 1
a100 1
	char __CTYPE_Tu = (c);				\
@


1.11
log
@switch to a one-locale system; "the" locale is UTF-8 encoded 'C' now;
inline many simpler functions for reduced code size / imports / speed
and optimise a little - XXX untested
@
text
@d1 1
a1 1
/* $MirOS: src/include/ctype.h,v 1.10 2007/02/02 19:22:37 tg Exp $ */
a42 3
extern const unsigned char __C_attribute_table_pg[256];

#if defined(__GNUC__) || defined(_ANSI_LIBRARY) || defined(lint)
d63 1
a63 1
#endif /* __GNUC__ || _ANSI_LIBRARY || lint */
d65 1
a65 1
#if !defined(_ANSI_LIBRARY) && !defined(lint)
a115 1

d118 1
a118 1
#endif /* !_ANSI_LIBRARY && !lint */
@


1.10
log
@first step towards Plan 9¾: we'll always use UTF-8, eventually,
agreed bsiegert@@, so begin removing the ISO-8859-1 compat cruft
@
text
@d1 1
a1 1
/* $MirOS: src/include/ctype.h,v 1.9 2007/02/02 17:53:55 tg Exp $ */
d28 1
a28 1
/* Idea from Bruno Haible's libutf8 */
d95 1
d113 1
a113 1
#define isascii(c)	((unsigned int)(c) <= 0177)
d115 1
a115 1
#define toascii(c)	((c) & 0177)
@


1.9
log
@* provide tolower(), toupper() as macros too, but side-effect-safe
* shrink _tolower() and _toupper() to the only required functionality
@
text
@d1 1
a1 1
/* $MirOS: src/share/misc/licence.template,v 1.20 2006/12/11 21:04:56 tg Rel $ */
a69 10
/*
 * Kludge for the macro version:
 * ANSI requires that only the 7-bit ASCII range is letters.
 * With ISO-8859-1, 0x80..0x9F are cntrl, and 0xA0..0xFF are
 * print, but with UTF-8, they are neither cntrl, nor print.
 * So I decided to have a pure ISO_646.irv:1991 macro imple-
 * mentation, and the function implementation return cntrl /
 * print if MIR18N_C_CSET == 2, 0 otherwise, for 8bit chars.
 */

@


1.8
log
@mostly administrative licence sync w/ current template
@
text
@d4 1
a4 1
 * Copyright (c) 2006
d105 15
d126 2
a127 3
/* SUSv3 says these are always macros */
#define _tolower(c)	(((c) >= 'A') && ((c) <= 'Z') ? (c) - 'A' + 'a' : (c))
#define _toupper(c)	(((c) >= 'a') && ((c) <= 'z') ? (c) - 'a' + 'A' : (c))
@


1.7
log
@slightly less invasive macro version ;)
@
text
@d1 1
a1 1
/* $MirOS: src/include/ctype.h,v 1.6 2006/11/02 13:36:31 tg Exp $ */
d7 5
a11 6
 * Licensee is hereby permitted to deal in this work without restric-
 * tion, including unlimited rights to use, publicly perform, modify,
 * merge, distribute, sell, give away or sublicence, provided all co-
 * pyright notices above, these terms and the disclaimer are retained
 * in all redistributions or reproduced in accompanying documentation
 * or other materials provided with binary redistributions.
d13 8
a20 8
 * Licensor offers the work "AS IS" and WITHOUT WARRANTY of any kind,
 * express, or implied, to the maximum extent permitted by applicable
 * law, without malicious intent or gross negligence; in no event may
 * licensor, an author or contributor be held liable for any indirect
 * or other damage, or direct damage except proven a consequence of a
 * direct error of said person and intended use of this work, loss or
 * other issues arising in any way out of its use, even if advised of
 * the possibility of such damage or existence of a defect.
@


1.6
log
@this actually sucks
we are mandated to be 7bit in e.g. islower(3)
for latin1, 0x80..0x9F are cntrl and 0xA0..0xFF are print,
for utf-8, they all are neither cntrl nor print since they
are multibyte sequence components (0xA0 != U+00A0; the se-
cond one would be handled by iswlower(3) instead).

=> macro version returns 0 for octets >0x7F
=> function version ditto, unless MIR18N_C_CSET == 2
=> function version of iscntrl(3) and isprint(3)
   return latin1 values if MIR18N_C_CSET == 2
@
text
@d1 1
a1 1
/* $MirOS: src/include/ctype.h,v 1.5 2006/11/02 01:35:48 tg Exp $ */
d113 2
a114 2
#define _tolower(c)	((c) - 'A' + 'a')
#define _toupper(c)	((c) - 'a' + 'A')
@


1.5
log
@put back things after fixing: namespace issues (d'oh)
@
text
@d1 1
a1 1
/* $MirOS: src/include/ctype.h,v 1.3 2006/11/02 00:07:06 tg Exp $ */
d71 10
d84 1
a84 1
	(__CTYPE_Ic > 255) ? 0 :					\
d90 1
a90 1
	(((((int)(c)) < 0) || (((int)(c)) > 255)) ? 0 :			\
@


1.4
log
@ok, now that was weird. and it broke things.
@
text
@d71 13
a83 4
#define __CTYPE_IMPL(c,t)						     \
	((((unsigned)(c)) > 255) ? 0 :					     \
	 ((__C_attribute_table_pg[((unsigned)(c))] & (_ctp_ ## t & 0xFF)) && \
	 !(__C_attribute_table_pg[((unsigned)(c))] & (_ctp_ ## t >> 8))))
@


1.3
log
@make them inline even easier
@
text
@d1 1
a1 1
/* $MirOS: src/include/ctype.h,v 1.2 2006/11/01 19:49:32 tg Exp $ */
d71 4
a74 13
#ifdef __GNUC__
#define __CTYPE_IMPL(ch,t) __extension__({			\
	unsigned c = (ch);					\
	(c > 255) ? 0 :						\
	 ((__C_attribute_table_pg[c] & (_ctp_ ## t & 0xFF)) &&	\
	 !(__C_attribute_table_pg[c] & (_ctp_ ## t >> 8)));	\
})
#else
#define __CTYPE_IMPL(c,t)						\
	(((((int)(c)) < 0) || (((int)(c)) > 255)) ? 0 :			\
	 ((__C_attribute_table_pg[((int)(c))] & (_ctp_ ## t & 0xFF)) &&	\
	 !(__C_attribute_table_pg[((int)(c))] & (_ctp_ ## t >> 8))))
#endif
@


1.2
log
@* the non-wide ctype stuff now also uses the wctype structure
  (saves duplicate rodata) and has been rewritten from scratch
* the non-inline version of the non-wide ctype stuff honours
  the MIR18N_C_CSET definition now as well
* tolower/toupper also rewritten from scratch, honouring the
  MIR18N_C_CSET definition (there is no inline version, and
  _tolower/_toupper are same stupid as usual), much smaller
@
text
@d1 1
a1 1
/* $MirOS: src/share/misc/licence.template,v 1.14 2006/08/09 19:35:23 tg Rel $ */
a70 1
/* extern __inline is a GNU C extension */
d72 6
a77 1
#define	__CTYPE_INLINE	extern __inline
d79 4
a82 1
#define	__CTYPE_INLINE	static __inline
d85 11
a95 20
#define __CTYPE_IMPL(t)							     \
	__CTYPE_INLINE int is ## t (int c)				     \
	{								     \
		if ((c < 0) || (c > 255))				     \
			return (0);					     \
		return ((__C_attribute_table_pg[c] & (_ctp_ ## t & 0xFF)) && \
		    !(__C_attribute_table_pg[c] & (_ctp_ ## t >> 8)));	     \
	}

__CTYPE_IMPL(alnum)
__CTYPE_IMPL(alpha)
__CTYPE_IMPL(cntrl)
__CTYPE_IMPL(digit)
__CTYPE_IMPL(graph)
__CTYPE_IMPL(lower)
__CTYPE_IMPL(print)
__CTYPE_IMPL(punct)
__CTYPE_IMPL(space)
__CTYPE_IMPL(upper)
__CTYPE_IMPL(xdigit)
d98 3
a100 11
__CTYPE_INLINE int isascii(int c)
{
	return ((unsigned int)c <= 0177);
}

__CTYPE_IMPL(blank)

__CTYPE_INLINE int toascii(int c)
{
	return (c & 0177);
}
a107 3
#undef __CTYPE_IMPL
#undef __CTYPE_INLINE

@


1.1
log
@Initial revision
@
text
@d1 1
a1 2
/*	$OpenBSD: ctype.h,v 1.17 2004/04/02 22:37:12 avsm Exp $	*/
/*	$NetBSD: ctype.h,v 1.14 1994/10/26 00:55:47 cgd Exp $	*/
d3 3
a5 8
/*
 * Copyright (c) 1989 The Regents of the University of California.
 * All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
d7 6
a12 11
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d14 8
a21 13
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ctype.h	5.3 (Berkeley) 4/3/91
d26 1
d29 13
a41 8
#define	_U	0x01
#define	_L	0x02
#define	_N	0x04
#define	_S	0x08
#define	_P	0x10
#define	_C	0x20
#define	_X	0x40
#define	_B	0x80
d44 1
a44 11

extern const char	*_ctype_;
extern const short	*_tolower_tab_;
extern const short	*_toupper_tab_;

/* extern __inline is a GNU C extension */
#ifdef __GNUC__
#define	__CTYPE_INLINE	extern __inline
#else
#define	__CTYPE_INLINE	static __inline
#endif
d62 1
a63 1
int	isascii(int);
a64 2
int	_tolower(int);
int	_toupper(int);
d71 6
a76 14
__CTYPE_INLINE int isalnum(int c)
{
	return (c == -1 ? 0 : ((_ctype_ + 1)[(unsigned char)c] & (_U|_L|_N)));
}

__CTYPE_INLINE int isalpha(int c)
{
	return (c == -1 ? 0 : ((_ctype_ + 1)[(unsigned char)c] & (_U|_L)));
}

__CTYPE_INLINE int iscntrl(int c)
{
	return (c == -1 ? 0 : ((_ctype_ + 1)[(unsigned char)c] & _C));
}
d78 20
a97 53
__CTYPE_INLINE int isdigit(int c)
{
	return (c == -1 ? 0 : ((_ctype_ + 1)[(unsigned char)c] & _N));
}

__CTYPE_INLINE int isgraph(int c)
{
	return (c == -1 ? 0 : ((_ctype_ + 1)[(unsigned char)c] & (_P|_U|_L|_N)));
}

__CTYPE_INLINE int islower(int c)
{
	return (c == -1 ? 0 : ((_ctype_ + 1)[(unsigned char)c] & _L));
}

__CTYPE_INLINE int isprint(int c)
{
	return (c == -1 ? 0 : ((_ctype_ + 1)[(unsigned char)c] & (_P|_U|_L|_N|_B)));
}

__CTYPE_INLINE int ispunct(int c)
{
	return (c == -1 ? 0 : ((_ctype_ + 1)[(unsigned char)c] & _P));
}

__CTYPE_INLINE int isspace(int c)
{
	return (c == -1 ? 0 : ((_ctype_ + 1)[(unsigned char)c] & _S));
}

__CTYPE_INLINE int isupper(int c)
{
	return (c == -1 ? 0 : ((_ctype_ + 1)[(unsigned char)c] & _U));
}

__CTYPE_INLINE int isxdigit(int c)
{
	return (c == -1 ? 0 : ((_ctype_ + 1)[(unsigned char)c] & (_N|_X)));
}

__CTYPE_INLINE int tolower(int c)
{
	if ((unsigned int)c > 0177)
		return (c);
	return ((_tolower_tab_ + 1)[c]);
}

__CTYPE_INLINE int toupper(int c)
{
	if ((unsigned int)c > 0177)
		return (c);
	return ((_toupper_tab_ + 1)[c]);
}
a99 5
__CTYPE_INLINE int isblank(int c)
{
	return (c == ' ' || c == '\t');
}

d105 2
d112 3
a114 4
__CTYPE_INLINE int _tolower(int c)
{
	return (c - 'A' + 'a');
}
a115 4
__CTYPE_INLINE int _toupper(int c)
{
	return (c - 'a' + 'A');
}
d118 3
a124 2
#undef __CTYPE_INLINE

@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import includes alongside with libc this time...
@
text
@d1 1
a1 1
/*	$OpenBSD: ctype.h,v 1.18 2005/08/08 05:53:00 espie Exp $	*/
d150 1
a150 1
	if ((unsigned int)c > 255)
d157 1
a157 1
	if ((unsigned int)c > 255)
@

