head	1.7;
access;
symbols
	pcc_cpp:1.6.0.2
	cvs-20081118:1.1.121.1
	pcc:1.1.121
	reiser_cccp:1.4.0.4
	MIRBSD_10:1.4.0.2
	MIRBSD_10_BASE:1.4
	MIRBSD_9_BASE:1.3
	MIRBSD_8:1.3.0.2
	MIRBSD_8_BASE:1.3
	tg:1.1.201;
locks; strict;
comment	@ * @;


1.7
date	2008.11.22.13.06.43;	author tg;	state Exp;
branches;
next	1.6;
commitid	100492803F07424968F;

1.6
date	2008.11.18.20.58.32;	author tg;	state Exp;
branches;
next	1.5;
commitid	10049232C8B39BFB045;

1.5
date	2008.11.18.19.51.52;	author tg;	state Exp;
branches;
next	1.4;
commitid	10049231CD61DED021C;

1.4
date	2007.08.24.14.20.04;	author tg;	state Exp;
branches
	1.4.4.1;
next	1.3;
commitid	10046CEE8E817DEC27F;

1.3
date	2005.07.01.12.10.16;	author tg;	state Exp;
branches;
next	1.2;
commitid	676f42c532b35ba9;

1.2
date	2005.03.06.19.23.59;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.01.42.56;	author tg;	state Exp;
branches
	1.1.121.1
	1.1.201.1;
next	;

1.4.4.1
date	2008.11.20.15.18.24;	author tg;	state Exp;
branches;
next	1.4.4.2;
commitid	10049257FBE037944CE;

1.4.4.2
date	2008.11.22.12.31.45;	author tg;	state Exp;
branches;
next	;
commitid	1004927FBC36782C688;

1.1.121.1
date	2008.11.18.19.01.05;	author tg;	state Exp;
branches;
next	;
commitid	100492310FE49616AA5;

1.1.201.1
date	2005.02.05.01.42.56;	author tg;	state Exp;
branches;
next	;


desc
@@


1.7
log
@switch MAIN branch back to Reiser CCCP (for now)
@
text
@#ifdef FLEXNAMES
#define	NCPS	128
#else
#define	NCPS	8
#endif

#include <sys/param.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <paths.h>

__SCCSID("@@(#)cpp.c	1.22 11/7/90");
__RCSID("$MirOS: src/libexec/cpp/cpp.c,v 1.4.4.2 2008/11/22 12:31:45 tg Exp $");

/* C command
/* written by John F. Reiser
/* July/August 1978
*/

#define STATIC

#define FIRSTOPEN -2
#define STDIN 0
#define READ 0
#define WRITE 1
#define SALT '#'
#if !defined BUFSIZ || BUFSIZ < 8192
#undef BUFSIZ
#define BUFSIZ 8192
#endif

char *pbeg,*pbuf,*pend;
char *outp,*inp;
char *newp;
char cinit;

/* some code depends on whether characters are sign or zero extended */
/*	#if '\377' < 0		not used here, old cpp doesn't understand */
#if pdp11 | vax | mc68000 | tahoe
#define COFF 128
#else
#define COFF 0
#endif

# if gcos
#define ALFSIZ 512	/* alphabet size */
# else
#define ALFSIZ 256	/* alphabet size */
# endif
char macbit[ALFSIZ+11];
char toktyp[ALFSIZ];
#define BLANK 1
#define IDENT 2
#define NUMBR 3

/* a superimposed code is used to reduce the number of calls to the
/* symbol table lookup routine.  (if the kth character of an identifier
/* is 'a' and there are no macro names whose kth character is 'a'
/* then the identifier cannot be a macro name, hence there is no need
/* to look in the symbol table.)  'scw1' enables the test based on
/* single characters and their position in the identifier.  'scw2'
/* enables the test based on adjacent pairs of characters and their
/* position in the identifier.  scw1 typically costs 1 indexed fetch,
/* an AND, and a jump per character of identifier, until the identifier
/* is known as a non-macro name or until the end of the identifier.
/* scw1 is inexpensive.  scw2 typically costs 4 indexed fetches,
/* an add, an AND, and a jump per character of identifier, but it is also
/* slightly more effective at reducing symbol table searches.
/* scw2 usually costs too much because the symbol table search is
/* usually short; but if symbol table search should become expensive,
/* the code is here.
/* using both scw1 and scw2 is of dubious value.
*/
#define scw1 1
#define scw2 0

#if scw2
char t21[ALFSIZ],t22[ALFSIZ],t23[ALFSIZ+NCPS];
#endif

#if scw1
#define b0 1
#define b1 2
#define b2 4
#define b3 8
#define b4 16
#define b5 32
#define b6 64
#define b7 128
#endif

#define IB 1
#define SB 2
#define NB 4
#define CB 8
#define QB 16
#define WB 32
char fastab[ALFSIZ];
char slotab[ALFSIZ];
char *ptrtab;
#define isslo (ptrtab==(slotab+COFF))
#define isid(a)  ((fastab+COFF)[a]&IB)
#define isspc(a) (ptrtab[a]&SB)
#define isnum(a) ((fastab+COFF)[a]&NB)
#define iscom(a) ((fastab+COFF)[a]&CB)
#define isquo(a) ((fastab+COFF)[a]&QB)
#define iswarn(a) ((fastab+COFF)[a]&WB)

#define eob(a) ((a)>=pend)
#define bob(a) (pbeg>=(a))

# define cputc(a,b)	if(!flslvl) putc(a,b)

char buffer[NCPS+BUFSIZ+BUFSIZ+NCPS];

char	*lastcopy;

# define DROP 0xFE	/* special character not legal ASCII or EBCDIC */
# define WARN DROP
# define SAME 0
# define MAXINC 15
# define MAXFRE 14	/* max buffers of macro pushback */
# define MAXFRM 31	/* max number of formals/actuals to a macro */

static char warnc = WARN;

int mactop,fretop;
char *instack[MAXFRE],*bufstack[MAXFRE],*endbuf[MAXFRE];

int plvl;	/* parenthesis level during scan for macro actuals */
int maclin;	/* line number of macro call requiring actuals */
char *macfil;	/* file name of macro call requiring actuals */
char *macnam;	/* name of macro requiring actuals */
int maclvl;	/* # calls since last decrease in nesting level */
char *macforw;	/* pointer which must be exceeded to decrease nesting level */
int macdam;	/* offset to macforw due to buffer shifting */

#if tgp
int tgpscan;	/* flag for dump(); */
#endif

STATIC	int	inctop[MAXINC];
STATIC	char	*fnames[MAXINC];
STATIC	char	*dirnams[MAXINC];	/* actual directory of #include files */
STATIC	int	fins[MAXINC];
STATIC	int	lineno[MAXINC];

STATIC	char	*dirs[10];	/* -I and <> directories */
char *strdex(), *copy(), *subst(), *trmdir();
struct symtab *stsym();
STATIC	int	fin	= FIRSTOPEN;
STATIC	FILE	*fout	= stdout;
STATIC	int	nd	= 1;
STATIC	int	pflag;	/* don't put out lines "# 12 foo.c" */
int	passcom;	/* &1=don't delete comments &2=even in macros */
int	incomment;	/* True if parsing a comment */
STATIC	int rflag;	/* allow macro recursion */
STATIC	int mflag;	/* generate makefile dependencies */
int	uflag = 0;	/* -undef passed */
STATIC	char *infile;	/* name of .o file to build dependencies from */
STATIC 	FILE *mout;	/* file to place dependencies on */
#define START 1
#define CONT  2
#define BACK  3
STATIC	int	ifno;
# define NPREDEF 130
STATIC	char *prespc[NPREDEF];
STATIC	char **predef = prespc;
STATIC	char *punspc[NPREDEF];
STATIC	char **prund = punspc;
STATIC	int	exfail;
struct symtab {
	char	*name;
	char	*value;
} *lastsym, *lookup(), *slookup();

# if gcos
#include <setjmp.h>
static jmp_buf env;
# define main	mainpp
# undef exit
# define exit(S)	longjmp(env, 1)
# define open(S,D)	fileno(fopen(S, "r"))
# define close(F)	fclose(_f[F])
extern FILE *_f[];
# define symsiz 500
# else
# define symsiz 5000		/* std = 500, wnj aug 1979 */
# endif
STATIC	struct symtab stab[symsiz];

STATIC	struct symtab *defloc;
STATIC	struct symtab *udfloc;
STATIC	struct symtab *incloc;
STATIC	struct symtab *ifloc;
STATIC	struct symtab *elsloc;
STATIC	struct symtab *eifloc;
STATIC	struct symtab *ifdloc;
STATIC	struct symtab *ifnloc;
STATIC	struct symtab *ysysloc;
STATIC	struct symtab *varloc;
STATIC	struct symtab *lneloc;
STATIC	struct symtab *ulnloc;
STATIC	struct symtab *uflloc;
STATIC	struct symtab *identloc;	/* Sys 5r3 compatibility */
STATIC	int	trulvl;
STATIC	int	flslvl;

int
sayline(int where)
{
	if (mflag && where==START) fprintf(mout, "%s: %s\n", infile, fnames[ifno]);
	if (pflag==0) fprintf(fout,"# %d \"%s\"\n", lineno[ifno], fnames[ifno]);
}

/* data structure guide
/*
/* most of the scanning takes place in the buffer:
/*
/*  (low address)                                             (high address)
/*  pbeg                           pbuf                                 pend
/*  |      <-- BUFSIZ chars -->      |         <-- BUFSIZ chars -->        |
/*  _______________________________________________________________________
/* |_______________________________________________________________________|
/*          |               |               |
/*          |<-- waiting -->|               |<-- waiting -->
/*          |    to be      |<-- current -->|    to be
/*          |    written    |    token      |    scanned
/*          |               |               |
/*          outp            inp             p
/*
/*  *outp   first char not yet written to output file
/*  *inp    first char of current token
/*  *p      first char not yet scanned
/*
/* macro expansion: write from *outp to *inp (chars waiting to be written),
/* ignore from *inp to *p (chars of the macro call), place generated
/* characters in front of *p (in reverse order), update pointers,
/* resume scanning.
/*
/* symbol table pointers point to just beyond the end of macro definitions;
/* the first preceding character is the number of formal parameters.
/* the appearance of a formal in the body of a definition is marked by
/* 2 chars: the char WARN, and a char containing the parameter number.
/* the first char of a definition is preceded by a zero character.
/*
/* when macro expansion attempts to back up over the beginning of the
/* buffer, some characters preceding *pend are saved in a side buffer,
/* the address of the side buffer is put on 'instack', and the rest
/* of the main buffer is moved to the right.  the end of the saved buffer
/* is kept in 'endbuf' since there may be nulls in the saved buffer.
/*
/* similar action is taken when an 'include' statement is processed,
/* except that the main buffer must be completely emptied.  the array
/* element 'inctop[ifno]' records the last side buffer saved when
/* file 'ifno' was included.  these buffers remain dormant while
/* the file is being read, and are reactivated at end-of-file.
/*
/* instack[0 : mactop] holds the addresses of all pending side buffers.
/* instack[inctop[ifno]+1 : mactop-1] holds the addresses of the side
/* buffers which are "live"; the side buffers instack[0 : inctop[ifno]]
/* are dormant, waiting for end-of-file on the current file.
/*
/* space for side buffers is obtained from 'malloc' and is never returned.
/* bufstack[0:fretop-1] holds addresses of side buffers which
/* are available for use.
*/

void
dump(void) {
/* write part of buffer which lies between  outp  and  inp .
/* this should be a direct call to 'write', but the system slows to a crawl
/* if it has to do an unaligned copy.  thus we buffer.  this silly loop
/* is 15% of the total time, thus even the 'putc' macro is too slow.
*/
	register char *p1,*p2; register FILE *f;
	if ((p1=outp)==inp || flslvl!=0) return;
#if tgp
#define MAXOUT 80
	if (!tgpscan) {/* scan again to insure <= MAXOUT chars between linefeeds */
		register char c,*pblank; char savc,stopc,brk;
		tgpscan=1; brk=stopc=pblank=0; p2=inp; savc= *p2; *p2='\0';
		while (c= *p1++) {
			if (c=='\\') c= *p1++;
			if (stopc==c) stopc=0;
			else if (c=='"' || c=='\'') stopc=c;
			if (p1-outp>MAXOUT && pblank!=0) {
				*pblank++='\n'; inp=pblank; dump(); brk=1; pblank=0;
			}
			if (c==' ' && stopc==0) pblank=p1-1;
		}
		if (brk) sayline(CONT);
		*p2=savc; inp=p2; p1=outp; tgpscan=0;
	}
#endif
	f=fout;
# if gcos
/* filter out "$ program c" card if first line of input */
/* gmatch is a simple pattern matcher in the GCOS Standard Library */
{	static int gmfirst = 0;
	if (!gmfirst) {
		++gmfirst;
		if (gmatch(p1, "^$*program[ \t]*c*"))
			p1 = strdex(p1, '\n');
	}
}
# endif
	while (p1<inp) putc(*p1++,f);
	outp=p1;
}

char *
refill(p) register char *p; {
/* dump buffer.  save chars from inp to p.  read into buffer at pbuf,
/* contiguous with p.  update pointers, return new p.
*/
	register char *np,*op; register int ninbuf;
	dump(); np=pbuf-(p-inp); op=inp;
	if (bob(np+1)) {pperror("token too long"); np=pbeg; p=inp+BUFSIZ;}
	macdam += np-inp; outp=inp=np;
	while (op<p) *np++= *op++;
	p=np;
	for (;;) {
		if (mactop>inctop[ifno]) {/* retrieve hunk of pushed-back macro text */
			op=instack[--mactop]; np=pbuf;
			do {while (*np++= *op++);} while (op<endbuf[mactop]); pend=np-1;
			/* make buffer space avail for 'include' processing */
			if (fretop<MAXFRE) bufstack[fretop++]=instack[mactop];
			return(p);
		} else {/* get more text from file(s) */
			maclvl=0;
			if (0<(ninbuf=read(fin,pbuf,BUFSIZ))) {
				pend=pbuf+ninbuf; *pend='\0';
				return(p);
			}
			/* end of #include file */
			if (ifno==0) {/* end of input */
				if (plvl!=0) {
					int n=plvl,tlin=lineno[ifno]; char *tfil=fnames[ifno];
					lineno[ifno]=maclin; fnames[ifno]=macfil;
					pperror("%s: unterminated macro call",macnam);
					lineno[ifno]=tlin; fnames[ifno]=tfil;
					np=p; *np++='\n';	/* shut off unterminated quoted string */
					while (--n>=0) *np++=')';	/* supply missing parens */
					pend=np; *np='\0'; if (plvl<0) plvl=0;
					return(p);
				}
				if (trulvl || flslvl)
					if (incomment)
						pperror("unterminated comment");
					else
						pperror("missing endif");
				inp=p; dump(); exit(exfail);
			}
			close(fin); fin=fins[--ifno]; dirs[0]=dirnams[ifno]; sayline(BACK);
		}
	}
}

#define BEG 0
#define LF 1

char *
cotoken(p) register char *p; {
	register int c,i; char quoc;
	static int state = BEG;

	if (state!=BEG) goto prevlf;
for (;;) {
again:
	while (!isspc(*p++));
	switch (*(inp=p-1)) {
	case 0: {
		if (eob(--p)) {p=refill(p); goto again;}
		else ++p; /* ignore null byte */
	} break;
	case '|': case '&': for (;;) {/* sloscan only */
		if (*p++== *inp) break;
		if (eob(--p)) p=refill(p);
		else break;
	} break;
	case '=': case '!': for (;;) {/* sloscan only */
		if (*p++=='=') break;
		if (eob(--p)) p=refill(p);
		else break;
	} break;
	case '<': case '>': for (;;) {/* sloscan only */
		if (*p++=='=' || p[-2]==p[-1]) break;
		if (eob(--p)) p=refill(p);
		else break;
	} break;
	case '\\': for (;;) {
		if (*p++=='\n') {++lineno[ifno]; break;}
		if (eob(--p)) p=refill(p);
		else {++p; break;}
	} break;
	case '/': for (;;) {
		if (*p++=='*') {/* comment */
			incomment++;
			if (!passcom) {inp=p-2; dump(); ++flslvl;}
			for (;;) {
				while (!iscom(*p++));
				if (p[-1]=='*') for (;;) {
					if (*p++=='/') goto endcom;
					if (eob(--p)) {
						if (!passcom) {inp=p; p=refill(p);}
						else if ((p-inp)>=BUFSIZ) {/* split long comment */
							inp=p; p=refill(p);	/* last char written is '*' */
							cputc('/',fout);	/* terminate first part */
							/* and fake start of 2nd */
							outp=inp=p-=3; *p++='/'; *p++='*'; *p++='*';
						} else p=refill(p);
					} else break;
				} else if (p[-1]=='\n') {
					++lineno[ifno]; if (!passcom) putc('\n',fout);
				} else if (eob(--p)) {
					if (!passcom) {inp=p; p=refill(p);}
					else if ((p-inp)>=BUFSIZ) {/* split long comment */
						inp=p; p=refill(p);
						cputc('*',fout); cputc('/',fout);
						outp=inp=p-=2; *p++='/'; *p++='*';
					} else p=refill(p);
				} else ++p; /* ignore null byte */
			}
		endcom:
			incomment--;
			if (!passcom) {outp=inp=p; --flslvl; goto again;}
			break;
		}
		if (eob(--p)) p=refill(p);
		else break;
	} break;
# if gcos
	case '`':
# endif
	case '"': case '\'': {
		quoc=p[-1];
		for (;;) {
			while (!isquo(*p++));
			if (p[-1]==quoc) break;
			if (p[-1]=='\n') {--p; break;} /* bare \n terminates quotation */
			if (p[-1]=='\\') for (;;) {
				if (*p++=='\n') {++lineno[ifno]; break;} /* escaped \n ignored */
				if (eob(--p)) p=refill(p);
				else {++p; break;}
			} else if (eob(--p)) p=refill(p);
			else ++p;	/* it was a different quote character */
		}
	} break;
	case '\n': {
		++lineno[ifno]; if (isslo) {state=LF; return(p);}
prevlf:
		state=BEG;
		for (;;) {
			if (*p++=='#') return(p);
			if (eob(inp= --p)) p=refill(p);
			else goto again;
		}
	} break;
	case '0': case '1': case '2': case '3': case '4':
	case '5': case '6': case '7': case '8': case '9':
	for (;;) {
		while (isnum(*p++));
		if (eob(--p)) p=refill(p);
		else break;
	} break;
	case 'A': case 'B': case 'C': case 'D': case 'E':
	case 'F': case 'G': case 'H': case 'I': case 'J':
	case 'K': case 'L': case 'M': case 'N': case 'O':
	case 'P': case 'Q': case 'R': case 'S': case 'T':
	case 'U': case 'V': case 'W': case 'X': case 'Y':
	case 'Z': case '_':
	case 'a': case 'b': case 'c': case 'd': case 'e':
	case 'f': case 'g': case 'h': case 'i': case 'j':
	case 'k': case 'l': case 'm': case 'n': case 'o':
	case 'p': case 'q': case 'r': case 's': case 't':
	case 'u': case 'v': case 'w': case 'x': case 'y':
	case 'z':
#if scw1
#define tmac1(c,bit) if (!xmac1(c,bit,&)) goto nomac
#define xmac1(c,bit,op) ((macbit+COFF)[c] op (bit))
#else
#define tmac1(c,bit)
#define xmac1(c,bit,op)
#endif

#if scw2
#define tmac2(c0,c1,cpos) if (!xmac2(c0,c1,cpos,&)) goto nomac
#define xmac2(c0,c1,cpos,op)\
	((macbit+COFF)[(t21+COFF)[c0]+(t22+COFF)[c1]] op (t23+COFF+cpos)[c0])
#else
#define tmac2(c0,c1,cpos)
#define xmac2(c0,c1,cpos,op)
#endif

	if (flslvl) goto nomac;
	for (;;) {
		c= p[-1];                          tmac1(c,b0);
		i= *p++; if (!isid(i)) goto endid; tmac1(i,b1); tmac2(c,i,0);
		c= *p++; if (!isid(c)) goto endid; tmac1(c,b2); tmac2(i,c,1);
		i= *p++; if (!isid(i)) goto endid; tmac1(i,b3); tmac2(c,i,2);
		c= *p++; if (!isid(c)) goto endid; tmac1(c,b4); tmac2(i,c,3);
		i= *p++; if (!isid(i)) goto endid; tmac1(i,b5); tmac2(c,i,4);
		c= *p++; if (!isid(c)) goto endid; tmac1(c,b6); tmac2(i,c,5);
		i= *p++; if (!isid(i)) goto endid; tmac1(i,b7); tmac2(c,i,6);
		                                                tmac2(i,0,7);
		while (isid(*p++));
		if (eob(--p)) {refill(p); p=inp+1; continue;}
		goto lokid;
	endid:
		if (eob(--p)) {refill(p); p=inp+1; continue;}
		tmac2(p[-1],0,-1+(p-inp));
	lokid:
		slookup(inp,p,0); if (newp) {p=newp; goto again;}
		else break;
	nomac:
		while (isid(*p++));
		if (eob(--p)) {p=refill(p); goto nomac;}
		else break;
	} break;
	} /* end of switch */
	
	if (isslo) return(p);
} /* end of infinite loop */
}

char *
skipbl(p) register char *p; {/* get next non-blank token */
	do {outp=inp=p; p=cotoken(p);} while ((toktyp+COFF)[*inp]==BLANK);
	return(p);
}

char *
unfill(p) register char *p; {
/* take <= BUFSIZ chars from right end of buffer and put them on instack .
/* slide rest of buffer to the right, update pointers, return new p.
*/
	register char *np,*op; register int d;
	if (mactop>=MAXFRE) {
		pperror("%s: too much pushback",macnam);
		p=inp=pend; dump();	/* begin flushing pushback */
		while (mactop>inctop[ifno]) {p=refill(p); p=inp=pend; dump();}
	}
	if (fretop>0) np=bufstack[--fretop];
	else {
		np=malloc(BUFSIZ+1);
		if (np==NULL) {pperror("no space"); exit(exfail);}
		np[BUFSIZ]='\0';
	}
	instack[mactop]=np; op=pend-BUFSIZ; if (op<p) op=p;
	for (;;) {while (*np++= *op++); if (eob(op)) break;} /* out with old */
	endbuf[mactop++]=np;	/* mark end of saved text */
	np=pbuf+BUFSIZ; op=pend-BUFSIZ; pend=np; if (op<p) op=p;
	while (outp<op) *--np= *--op; /* slide over new */
	if (bob(np)) pperror("token too long");
	d=np-outp; outp+=d; inp+=d; macdam+=d; return(p+d);
}

char *
doincl(p) register char *p; {
	int filok,inctype;
	register char *cp; char **dirp,*nfil; char filname[BUFSIZ];

	p=skipbl(p); cp=filname;
	if (*inp++=='<') {/* special <> syntax */
		inctype=1;
		++flslvl;	/* prevent macro expansion */
		for (;;) {
			outp=inp=p; p=cotoken(p);
			if (*inp=='\n') {--p; *cp='\0'; break;}
			if (*inp=='>') {      *cp='\0'; break;}
# ifdef gimpel
			if (*inp=='.' && !intss()) *inp='#';
# endif
			while (inp<p) *cp++= *inp++;
		}
		--flslvl;	/* reenable macro expansion */
	} else if (inp[-1]=='"') {/* regular "" syntax */
		inctype=0;
# ifdef gimpel
		while (inp<p) {if (*inp=='.' && !intss()) *inp='#'; *cp++= *inp++;}
# else
		while (inp<p) *cp++= *inp++;
# endif
		if (*--cp=='"') *cp='\0';
	} else {pperror("bad include syntax",0); inctype=2;}
	/* flush current file to \n , then write \n */
	++flslvl; do {outp=inp=p; p=cotoken(p);} while (*inp!='\n'); --flslvl;
	inp=p; dump(); if (inctype==2) return(p);
	/* look for included file */
	if (ifno+1 >=MAXINC) {
		pperror("Unreasonable include nesting",0); return(p);
	}
	if((nfil=malloc(BUFSIZ))==NULL) {pperror("no space"); exit(exfail);}
	filok=0;
	for (dirp=dirs+inctype; *dirp; ++dirp) {
		if (
# if gcos
			strdex(filname, '/')
# else
			filname[0]=='/' 
# endif
				|| **dirp=='\0') strlcpy(nfil,filname,BUFSIZ);
		else {
			strlcpy(nfil,*dirp,BUFSIZ);
# if unix || gcos
			strlcat(nfil,"/",BUFSIZ);
# endif
#ifdef ibm
#ifndef gimpel
			strlcat(nfil,".",BUFSIZ);
#endif
#endif
			strlcat(nfil,filname,BUFSIZ);
		}
		if (0<(fins[ifno+1]=open(nfil,READ))) {
			filok=1; fin=fins[++ifno]; break;
		}
	}
	if(filok==0){pperror("Can't find include file %s",filname);free(nfil);}
	else {
		nfil=realloc(nfil,strlen(nfil)+1);
		lineno[ifno]=1; fnames[ifno]=nfil;
		dirnams[ifno]=dirs[0]=trmdir(copy(nfil));
		sayline(START);
		/* save current contents of buffer */
		while (!eob(p)) p=unfill(p);
		inctop[ifno]=mactop;
	}
	return(p);
}

equfrm(a,p1,p2) register char *a,*p1,*p2; {
	register char c; int flag;
	c= *p2; *p2='\0';
	flag=strcmp(a,p1); *p2=c; return(flag==SAME);
}

char *
dodef(p) char *p; {/* process '#define' */
	register char *pin,*psav,*cf;
	char **pf,**qf; int b,c,params; struct symtab *np;
	char *oldval;
	char *space, *newspace;
	char *formal[MAXFRM]; /* formal[n] is name of nth formal */
	char formtxt[BUFSIZ]; /* space for formal names */
	int opt_passcom=passcom;

	if (!(passcom & 2))
		passcom=0;	/* don't put comments in macro expansions */

	++flslvl; /* prevent macro expansion during 'define' */
	p=skipbl(p); pin=inp;
	if ((toktyp+COFF)[*pin]!=IDENT) {
		ppwarn("illegal macro name"); while (*inp!='\n') p=skipbl(p);
		passcom=opt_passcom; return(p);
	}
	np=slookup(pin,p,1);
	if (oldval=np->value) free(lastcopy);	/* was previously defined */
	b=1; cf=pin;
	while (cf<p) {/* update macbit */
		c= *cf++; xmac1(c,b,|=); b=(b+b)&0xFF;
		if (cf!=p) xmac2(c,*cf,-1+(cf-pin),|=);
		else xmac2(c,0,-1+(cf-pin),|=);
	}
	params=0; outp=inp=p; p=cotoken(p); pin=inp;
	if (*pin=='(') {/* with parameters; identify the formals */
		cf=formtxt; pf=formal;
		for (;;) {
			p=skipbl(p); pin=inp;
			if (*pin=='\n') {
				--lineno[ifno]; --p; pperror("%s: missing )",np->name); break;
			}
			if (*pin==')') break;
			if (*pin==',') continue;
			if ((toktyp+COFF)[*pin]!=IDENT) {
				c= *p; *p='\0'; pperror("bad formal: %s",pin); *p=c;
			} else if (pf>= &formal[MAXFRM]) {
				c= *p; *p='\0'; pperror("too many formals: %s",pin); *p=c;
			} else {
				*pf++=cf; while (pin<p) *cf++= *pin++; *cf++='\0'; ++params;
			}
		}
		if (params==0) --params; /* #define foo() ... */
	} else if (*pin=='\n') {--lineno[ifno]; --p;}
	/* remember beginning of macro body, so that we can
	/* warn if a redefinition is different from old value.
	*/
	space=psav=malloc(BUFSIZ);
	if (space==NULL) {
		pperror("too much defining");
		passcom=opt_passcom;
		return(p);
	}
	*psav++ = '\0';
	for (;;) {/* accumulate definition until linefeed */
		outp=inp=p; p=cotoken(p); pin=inp;
		if (*pin=='\\' && pin[1]=='\n') {putc('\n',fout); continue;}	/* ignore escaped lf */
		if (*pin=='\n') break;
		if (params) {/* mark the appearance of formals in the definiton */
			if ((toktyp+COFF)[*pin]==IDENT) {
				for (qf=pf; --qf>=formal; ) {
					if (equfrm(*qf,pin,p)) {
						*psav++=qf-formal+1; *psav++=WARN; pin=p; break;
					}
				}
			} else if (*pin=='"' || *pin=='\''
# if gcos
					|| *pin=='`'
# endif
						) {/* inside quotation marks, too */
				char quoc= *pin;
				for (*psav++= *pin++; pin<p && *pin!=quoc; ) {
					while (pin<p && !isid(*pin)) *psav++= *pin++;
					cf=pin; while (cf<p && isid(*cf)) ++cf;
					for (qf=pf; --qf>=formal; ) {
						if (equfrm(*qf,pin,cf)) {
							*psav++=qf-formal+1; *psav++=WARN; pin=cf; break;
						}
					}
					while (pin<cf) *psav++= *pin++;
				}
			}
		}
		while (pin<p) *psav++= *pin++;
	}
	*psav++=params; *psav++='\0';
	if ((cf=oldval)!=NULL) {/* redefinition */
		--cf;	/* skip no. of params, which may be zero */
		while (*--cf);	/* go back to the beginning */
		if (0!=strcmp(++cf,space+1)) {/* redefinition different from old */
			--lineno[ifno]; ppwarn("%s redefined",np->name); ++lineno[ifno];
			np->value=psav-1;
		} else free(space); /* identical redef.; reclaim space */
	} else np->value=psav-1;
	--flslvl; inp=pin;
	if (np->value == psav-1) {
		newspace = realloc(space, psav-space);
		if (newspace==NULL) {pperror("no space"); exit(exfail);}
		/*
		 * Adjust pointer in case this moved.
		 */
		np->value += newspace-space;
	}
	passcom=opt_passcom;
	return(p);
}

#define fasscan() ptrtab=fastab+COFF
#define sloscan() ptrtab=slotab+COFF

char *
control(p) register char *p; {/* find and handle preprocessor control lines */
	register struct symtab *np;
for (;;) {
	fasscan(); p=cotoken(p); if (*inp=='\n') ++inp; dump();
	sloscan(); p=skipbl(p);
	*--inp=SALT; outp=inp; ++flslvl; np=slookup(inp,p,0); --flslvl;
	if (np==defloc) {/* define */
		if (flslvl==0) {p=dodef(p); continue;}
	} else if (np==incloc) {/* include */
		if (flslvl==0) {p=doincl(p); continue;}
	} else if (np==ifnloc) {/* ifndef */
		++flslvl; p=skipbl(p); np=slookup(inp,p,0); --flslvl;
		if (flslvl==0 && np->value==0) ++trulvl;
		else ++flslvl;
	} else if (np==ifdloc) {/* ifdef */
		++flslvl; p=skipbl(p); np=slookup(inp,p,0); --flslvl;
		if (flslvl==0 && np->value!=0) ++trulvl;
		else ++flslvl;
	} else if (np==eifloc) {/* endif */
		if (flslvl) {if (--flslvl==0) sayline(CONT);}
		else if (trulvl) --trulvl;
		else pperror("If-less endif",0);
	} else if (np==elsloc) {/* else */
		if (flslvl) {
			if (--flslvl!=0) ++flslvl;
			else {++trulvl; sayline(CONT);}
		}
		else if (trulvl) {++flslvl; --trulvl;}
		else pperror("If-less else",0);
	} else if (np==udfloc) {/* undefine */
		if (flslvl==0) {
			++flslvl; p=skipbl(p); slookup(inp,p,DROP); --flslvl;
		}
	} else if (np==ifloc) {/* if */
#if tgp
		pperror(" IF not implemented, true assumed", 0);
		if (flslvl==0) ++trulvl; else ++flslvl;
#else
		newp=p;
		if (flslvl==0 && yyparse()) ++trulvl; else ++flslvl;
		p=newp;
#endif
	} else if (np==lneloc) {/* line */
		if (flslvl==0 && pflag==0) {
			char *savestring();
			char filename[BUFSIZ], *cp = filename;
			outp=inp=p; *--outp='#';
			/* Find the line number.. */
			do {
				p = cotoken(p);
			} while (!isnum(*inp) && *inp != '\n');
			if (isnum(*inp))
				lineno[ifno] = atoi(inp)-1;
			/* Skip over the blank token */
			inp = p;
			if (*inp != '\n') {
				p = cotoken(p); inp = p;
			}
			/* Add a quote if missing..  */
			if (*inp != '\n') {
				p = cotoken(p);
				/* Add a quote if missing..  */
				if (*inp == '"')
					inp++;
				else {
					dump();
					*--outp = '"';
				}
				while (*inp != '\n') {
					while (inp < p && *inp != '"' &&
						cp < filename+sizeof(filename))
						*cp++ = *inp++;
					if (*inp == '"')
						break;
					inp = p; p = cotoken(p);
				}
				fnames[ifno] = savestring(filename, cp);
				/* Add a quote if missing..  */
				if (*inp != '"') {
					dump();
					*--outp = '"';
				}
			}
			while (*inp != '\n')
				p = cotoken(p);
			continue;
		}
	} else if (np==identloc) {/* ident (for Sys 5r3 compat) */
		while(*inp!='\n') p=cotoken(p);
	} else if (*++inp=='\n') outp=inp;	/* allows blank line after # */
	else pperror("undefined control",0);
	/* flush to lf */
	++flslvl; while (*inp!='\n') {outp=inp=p; p=cotoken(p);} --flslvl;
}
}

char *
savestring(start, finish)
	register char *start, *finish;
{
	char *retbuf;
	register char *cp;

	retbuf = (char *) calloc(finish - start + 1, sizeof (char));
	cp = retbuf;
	while (start < finish)
		*cp++ = *start++;
	*cp = 0;
	return(retbuf);
}

struct symtab *
stsym(s) register char *s; {
	char buf[BUFSIZ]; register char *p;

	/* make definition look exactly like end of #define line */
	/* copy to avoid running off end of world when param list is at end */
	p=buf; while (*p++= *s++);
	p=buf; while (isid(*p++)); /* skip first identifier */
	if (*--p=='=') {*p++=' '; while (*p++);}
	else {s=" 1"; while (*p++= *s++);}
	pend=p; *--p='\n';
	sloscan(); dodef(buf); return(lastsym);
}

struct symtab *
ppsym(s) char *s; {/* kluge */
	register struct symtab *sp;
	register char *name;
	size_t len;

	cinit=SALT; sp=stsym(s);
	len = strlen(sp->name) + 2;
	name = malloc(len);
	name[0] = '#';
	name[1] = '\0';
	strlcat(name, sp->name, len);
	sp->name = name;
	cinit=0; return(sp);
}

/* VARARGS1 */
pperror(s,x,y) char *s; {
	if (fnames[ifno][0]) fprintf(stderr,
# if gcos
			"*%c*   \"%s\", line ", exfail >= 0 ? 'F' : 'W',
# else
			"%s: ",
# endif
				 fnames[ifno]);
	fprintf(stderr, "%d: ",lineno[ifno]);
	fprintf(stderr, s, x, y);
	fprintf(stderr,"\n");
	++exfail;
}

yyerror(s,a,b) char *s; {
	pperror(s,a,b);
}

ppwarn(s,x) char *s; {
	int fail = exfail;
	exfail = -1;
	pperror(s,x);
	exfail = fail;
}

struct symtab *
lookup(namep, enterf)
char *namep;
{
	register char *np, *snp;
	register int c, i; int around;
	register struct symtab *sp;

	/* namep had better not be too long (currently, <=NCPS chars) */
	np=namep; around=0; i=cinit;
	while (c= *np++) i += i+c; c=i;	/* c=i for register usage on pdp11 */
	c %= symsiz; if (c<0) c += symsiz;
	sp = &stab[c];
	while (snp=sp->name) {
		np = namep;
		while (*snp++ == *np) if (*np++ == '\0') {
				if (enterf==DROP) {sp->name[0]= DROP; sp->value=0;}
				return(lastsym=sp);
			}
		if (--sp < &stab[0])
			if (around) {pperror("too many defines", 0); exit(exfail);}
			else {++around; sp = &stab[symsiz-1];}
	}
	if (enterf==1) sp->name=namep;
	return(lastsym=sp);
}

struct symtab *
slookup(p1,p2,enterf) register char *p1,*p2; int enterf;{
	register char *p3; char c2,c3; struct symtab *np;
	         c2= *p2; *p2='\0';	/* mark end of token */
	if ((p2-p1)>NCPS) p3=p1+NCPS; else p3=p2;
			 c3= *p3; *p3='\0';	/* truncate to NCPS chars or less */
	if (enterf==1) p1=copy(p1);
	np=lookup(p1,enterf); *p3=c3; *p2=c2;
	if (np->value!=0 && flslvl==0) newp=subst(p2,np);
	else newp=0;
	return(np);
}

char *
subst(p,sp) register char *p; struct symtab *sp; {
	static char match[]="%s: argument mismatch";
	register char *ca,*vp; int params;
	char *actual[MAXFRM]; /* actual[n] is text of nth actual   */
	char actused[MAXFRM]; /* for newline processing in actuals */
	char acttxt[BUFSIZ];  /* space for actuals */
	int  nlines = 0;

	if (0==(vp=sp->value)) return(p);
	if ((p-macforw)<=macdam) {
		if (++maclvl>symsiz && !rflag) {
			pperror("%s: macro recursion",sp->name); return(p);
		}
	} else maclvl=0;	/* level decreased */
	macforw=p; macdam=0;	/* new target for decrease in level */
	macnam=sp->name;
	dump();
	if (sp==ulnloc) {
		vp=acttxt; *vp++='\0';
		(void)snprintf(vp,BUFSIZ,"%d",lineno[ifno]); while (*vp++);
	} else if (sp==uflloc) {
		vp=acttxt; *vp++='\0';
		(void)snprintf(vp,BUFSIZ,"\"%s\"",fnames[ifno]); while (*vp++);
	}
	if (0!=(params= *--vp&0xFF)) {/* definition calls for params */
		register char **pa;
		ca=acttxt; pa=actual;
		if (params==0xFF) params=1;	/* #define foo() ... */
		sloscan(); ++flslvl; /* no expansion during search for actuals */
		plvl= -1;
		do p=skipbl(p); while (*inp=='\n');	/* skip \n too */
		if (*inp=='(') {
			maclin=lineno[ifno]; macfil=fnames[ifno];
			for (plvl=1; plvl!=0; ) {
				*ca++='\0';
				for (;;) {
					outp=inp=p; p=cotoken(p);
					if (*inp=='(') ++plvl;
					if (*inp==')' && --plvl==0) {--params; break;}
					if (plvl==1 && *inp==',') {--params; break;}
					while (inp<p) *ca++= *inp++;
					if (ca> &acttxt[BUFSIZ])
						pperror("%s: actuals too long",sp->name);
				}
				if (pa>= &actual[MAXFRM]) ppwarn(match,sp->name);
				else { actused[pa-actual]=0; *pa++=ca; }
			}
			nlines = lineno[ifno] - maclin;
			lineno[ifno] = maclin; /* don't count newlines here */
		}
		if (params!=0) ppwarn(match,sp->name);
		while (--params>=0) *pa++=""+1;	/* null string for missing actuals */
		--flslvl; fasscan();
	}
	for (;;) {/* push definition onto front of input stack */
		while (!iswarn(*--vp)) {
			if (bob(p)) {outp=inp=p; p=unfill(p);}
			*--p= *vp;
		}
		if (*vp==warnc) {/* insert actual param */
			ca=actual[*--vp-1];
			while (*--ca) {
				if (bob(p)) {outp=inp=p; p=unfill(p);}
				/* Actuals with newlines confuse line numbering */
				if (*ca == '\n' && actused[*vp-1])
					if (*(ca-1) == '\\') ca--;
					else *--p = ' ';
				else { *--p= *ca; if (*ca == '\n') nlines--; }
			}
			actused[*vp-1] = 1;
		} else {
			if (nlines > 0 )
				while (nlines-- > 0)
					*--p = '\n';
			break;
		}
	}
	outp=inp=p;
	return(p);
}




char *
trmdir(s) register char *s; {
	register char *p = s;
	while (*p++); --p; while (p>s && *--p!='/');
# if unix
	if (p==s) *p++='.';
# endif
	*p='\0';
	return(s);
}

STATIC char *
copy(s) register char *s; {
	register char *old;

	old = malloc(strlen(s)+1);
	if (old==NULL) {pperror("no space"); exit(exfail);}
	strlcpy(old, s, strlen(s)+1);
	return(lastcopy=old);
}

char *
strdex(s,c) char *s,c; {
	while (*s) if (*s++==c) return(--s);
	return(0);
}

yywrap(){ return(1); }

main(argc,argv)
	char *argv[];
{
	register int i,c;
	register char *p;
	char *tf,**cp2;

# if gcos
	if (setjmp(env)) return (exfail);
# endif
	p="_$ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
		i=0;
		while (c= *p++) {
			(fastab+COFF)[c] |= IB|NB|SB; (toktyp+COFF)[c]=IDENT;
#if scw2
			/* 53 == 63-10; digits rarely appear in identifiers,
			/* and can never be the first char of an identifier.
			/* 11 == 53*53/sizeof(macbit) .
			*/
			++i; (t21+COFF)[c]=(53*i)/11; (t22+COFF)[c]=i%11;
#endif
		}
	p="0123456789.";
		while (c= *p++) {(fastab+COFF)[c] |= NB|SB; (toktyp+COFF)[c]=NUMBR;}
# if gcos
	p="\n\"'`/\\";
# else
	p="\n\"'/\\";
# endif
		while (c= *p++) (fastab+COFF)[c] |= SB;
# if gcos
	p="\n\"'`\\";
# else
	p="\n\"'\\";
# endif
		while (c= *p++) (fastab+COFF)[c] |= QB;
	p="*\n"; while (c= *p++) (fastab+COFF)[c] |= CB;
	(fastab+COFF)[warnc] |= WB;
	(fastab+COFF)['\0'] |= CB|QB|SB|WB;
	for (i=ALFSIZ; --i>=0; ) slotab[i]=fastab[i]|SB;
	p=" \t\013\f\r";	/* note no \n;	\v not legal for vertical tab? */
		while (c= *p++) (toktyp+COFF)[c]=BLANK;
#if scw2
	for ((t23+COFF)[i=ALFSIZ+7-COFF]=1; --i>=-COFF; )
		if (((t23+COFF)[i]=(t23+COFF+1)[i]<<1)==0) (t23+COFF)[i]=1;
#endif

# if unix
	fnames[ifno=0] = ""; dirnams[0]=dirs[0]=".";
# endif
# if ibm
	fnames[ifno=0] = "";
# endif
# if gcos
	if (inquire(stdin, _TTY)) freopen("*src", "rt", stdin);
# endif
# if gimpel || gcos
	fnames[ifno=0] = (char *)inquire(stdin, _FILENAME);
	dirnams[0] = dirs[0] = trmdir(copy(fnames[0]));
# endif
	for(i=1; i<argc; i++)
		{
		switch(argv[i][0])
			{
			case '-':
# if gcos
			switch(toupper(argv[i][1])) { /* case-independent on GCOS */
# else
			switch(argv[i][1]) {
# endif
				case 'M': mflag++;
				case 'P': pflag++;
				case 'E': continue;
				case 'R': ++rflag; continue;
				case 'C':
					passcom = argv[i][2] == 'C' ? 3 : 1;
					continue;
				case 'D':
					if (predef>prespc+NPREDEF) {
						pperror("too many -D options, ignoring %s",argv[i]);
						continue;
					}
					/* ignore plain "-D" (no argument) */
					if (*(argv[i]+2)) *predef++ = argv[i]+2;
					continue;
				case 'U':
					if (prund>punspc+NPREDEF) {
						pperror("too many -U options, ignoring %s",argv[i]);
						continue;
					}
					*prund++ = argv[i]+2;
					continue;
				case 'I':
					if (nd>8) pperror("excessive -I file (%s) ignored",argv[i]);
					else dirs[nd++] = argv[i]+2;
					continue;
				case 't':
				case '\0':
					continue;
				case 'u':
					++uflag;
					continue;
				default: 
					pperror("unknown flag %s", argv[i]);
					continue;
				}
			default:
				if (fin==FIRSTOPEN) {
					if (0>(fin=open(argv[i], READ))) {
						pperror("No source file %s",argv[i]); exit(8);
					}
					fnames[ifno]=copy(argv[i]);
					infile=copy(argv[i]);
					dirs[0]=dirnams[ifno]=trmdir(argv[i]);
# ifndef gcos
/* too dangerous to have file name in same syntactic position
   be input or output file depending on file redirections,
   so force output to stdout, willy-nilly
	[i don't see what the problem is.  jfr]
*/
				} else if (fout==stdout) {
					if (NULL==(fout=fopen(argv[i], "w"))) {
						pperror("Can't create %s", argv[i]); exit(8);
					} else fclose(stdout);
# endif
				} else pperror("extraneous name %s", argv[i]);
			}
		}
	if (fin == FIRSTOPEN)
		fin = STDIN;

	if (mflag) {
		if (infile==(char *)0) {
			fprintf(stderr,
				"no input file specified with -M flag\n");
			exit(8);
		}
		tf=(char *)rindex(infile, '.');
		if (tf==0) {
			fprintf(stderr, "missing component name on %s\n",
				infile);
			exit(8);
		}
		tf[1]='o';
		tf=(char *)rindex(infile, '/');
		if (tf!=(char *)0)
			infile = tf + 1;
		mout=fout;
		if (NULL==(fout=fopen(_PATH_DEVNULL, "w"))) {
			fprintf(stderr, "cpp: can't open %s\n", _PATH_DEVNULL);
			exit(8);
		}
	}
	fins[ifno]=fin;
	exfail = 0;
		/* after user -I files here are the standard include libraries */
#if defined(__MirBSD__)
	dirs[nd++] = "/usr/include";
#else
# if unix
	dirs[nd++] = _PATH_INCLUDES;
# endif
# if gcos
	dirs[nd++] = "cc/include";
# endif
# if ibm
# ifndef gimpel
	dirs[nd++] = "BTL$CLIB";
# endif
# endif
# ifdef gimpel
	dirs[nd++] = intss() ?  "SYS3.C." : "" ;
# endif
#endif
	/* dirs[nd++] = "/compool"; */
	dirs[nd++] = 0;
	defloc=ppsym("define");
	udfloc=ppsym("undef");
	incloc=ppsym("include");
	elsloc=ppsym("else");
	eifloc=ppsym("endif");
	ifdloc=ppsym("ifdef");
	ifnloc=ppsym("ifndef");
	ifloc=ppsym("if");
	lneloc=ppsym("line");
	identloc=ppsym("ident");	/* Sys 5r3 compatibility */
	for (i=sizeof(macbit)/sizeof(macbit[0]); --i>=0; ) macbit[i]=0;
	if (!uflag) {
# if unix
		ysysloc=stsym("unix");
# endif
		ysysloc=stsym(MACHINE);
	}
	ulnloc=stsym ("__LINE__");
	uflloc=stsym ("__FILE__");

	tf=fnames[ifno]; fnames[ifno]="command line"; lineno[ifno]=1;
	cp2=prespc;
	while (cp2<predef) stsym(*cp2++);
	cp2=punspc;
	while (cp2<prund) {
		if (p=strdex(*cp2, '=')) *p++='\0';
		lookup(*cp2++, DROP);
	}
	fnames[ifno]=tf;
	pbeg=buffer+NCPS; pbuf=pbeg+BUFSIZ; pend=pbuf+BUFSIZ;

	trulvl = 0; flslvl = 0;
	lineno[0] = 1; sayline(START);
	outp=inp=pend;
	control(pend);
	return (exfail);
}
@


1.6
log
@__CRAZY cleanliness
@
text
@d1 4
a4 72
/*	$Id: cpp.c,v 1.93 2008/08/18 20:50:43 ragge Exp $	*/

/*
 * Copyright (c) 2004 Anders Magnusson (ragge@@ludd.luth.se).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright(C) Caldera International Inc. 2001-2002. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * Redistributions of source code and documentation must retain the above
 * copyright notice, this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 * 	This product includes software developed or owned by Caldera
 *	International, Inc.
 * Neither the name of Caldera International, Inc. nor the names of other
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * USE OF THE SOFTWARE PROVIDED FOR UNDER THIS LICENSE BY CALDERA
 * INTERNATIONAL, INC. AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL CALDERA INTERNATIONAL, INC. BE LIABLE
 * FOR ANY DIRECT, INDIRECT INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OFLIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * The C preprocessor.
 * This code originates from the V6 preprocessor with some additions
 * from V7 cpp, and at last ansi/c99 support.
 */

#include "config.h"

#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
d7 1
a8 3
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
a9 1
#include <stdarg.h>
a11 1
#include <time.h>
d13 4
d18 15
a32 2
#ifndef __MirBSD__
#include "compat.h"
a33 2
#include "cpp.h"
#include "cpy.h"
d35 9
a43 13
__RCSID("$MirOS: src/libexec/cpp/cpp.c,v 1.5 2008/11/18 19:51:52 tg Exp $");

#define	MAXARG	250	/* # of args to a macro, limited by char value */
#define	SBSIZE	600000

static usch	sbf[SBSIZE];
/* C command */

int tflag;	/* traditional cpp syntax */
#ifdef CPP_DEBUG
int dflag;	/* debug printouts */
#define	DPRINT(x) if (dflag) printf x
#define	DDPRINT(x) if (dflag > 1) printf x
d45 1
a45 2
#define DPRINT(x)
#define DDPRINT(x)
d48 31
a78 1
#define	GCC_VARI
d80 3
a82 30
int ofd;
usch outbuf[CPPBUF];
int obufp, istty, inmac;
int Cflag, Mflag, dMflag, Pflag;
usch *Mfile;
struct initar *initar;
int readmac;

/* avoid recursion */
struct recur {
	struct recur *next;
	struct symtab *sp;
};

/* include dirs */
struct incs {
	struct incs *next;
	usch *dir;
} *incdir[2];
#define	INCINC 0
#define	SYSINC 1

static struct symtab *filloc;
static struct symtab *linloc;
static struct symtab *pragloc;
int	trulvl;
int	flslvl;
int	elflvl;
int	elslvl;
usch *stringbuf = sbf;
d84 9
a92 43
/*
 * Macro replacement list syntax:
 * - For object-type macros, replacement strings are stored as-is.
 * - For function-type macros, macro args are substituted for the
 *   character WARN followed by the argument number.
 * - The value element points to the end of the string, to simplify
 *   pushback onto the input queue.
 * 
 * The first character (from the end) in the replacement list is
 * the number of arguments:
 *   VARG  - ends with ellipsis, next char is argcount without ellips.
 *   OBJCT - object-type macro
 *   0 	   - empty parenthesis, foo()
 *   1->   - number of args.
 */

#define	GCCARG	0xfd	/* has gcc varargs that may be replaced with 0 */
#define	VARG	0xfe	/* has varargs */
#define	OBJCT	0xff
#define	WARN	1	/* SOH, not legal char */
#define	CONC	2	/* STX, not legal char */
#define	SNUFF	3	/* ETX, not legal char */
#define	NOEXP	4	/* EOT, not legal char */
#define	EXPAND	5	/* ENQ, not legal char */
#define	PRAGS	6	/* start of converted pragma */
#define	PRAGE	14	/* end of converted pragma */

/* args for lookup() */
#define	FIND	0
#define	ENTER	1

static void expdef(usch *proto, struct recur *, int gotwarn);
void define(void);
static int canexpand(struct recur *, struct symtab *np);
void include(void);
void flbuf(void);
void usage(void) __dead;
usch *xstrdup(char *str);
const usch *prtprag(const usch *opb);

usch nullusch[] = "";
#ifdef GCC_VARI
usch zerousch[] = "0";
d95 45
a139 25
int
main(int argc, char **argv)
{
	struct initar *it;
	struct incs *w, *w2;
	struct symtab *nl;
	register int ch;

	while ((ch = getopt(argc, argv, "CD:I:MPS:U:d:i:tvV?")) != -1)
		switch (ch) {
		case 'C': /* Do not discard comments */
			Cflag++;
			break;

		case 'i': /* include */
		case 'U': /* undef */
		case 'D': /* define something */
			/* XXX should not need malloc() here */
			if ((it = malloc(sizeof(struct initar))) == NULL)
				error("couldn't apply -%c %s", ch, optarg);
			it->type = ch;
			it->str = optarg;
			it->next = initar;
			initar = it;
			break;
d141 2
a142 26
		case 'M': /* Generate dependencies for make */
			Mflag++;
			break;

		case 'P': /* Inhibit generation of line numbers */
			Pflag++;
			break;

		case 'S':
		case 'I':
			if ((w = calloc(sizeof(struct incs), 1)) == NULL)
				error("couldn't apply -%c %s", ch, optarg);
			w->dir = (usch *)optarg;
			w2 = incdir[ch == 'I' ? INCINC : SYSINC];
			if (w2 != NULL) {
				while (w2->next)
					w2 = w2->next;
				w2->next = w;
			} else
				incdir[ch == 'I' ? INCINC : SYSINC] = w;
			break;

#ifdef CPP_DEBUG
		case 'V':
			dflag++;
			break;
a143 10
		case 'v':
			printf("cpp: %s\n", VERSSTR);
			break;
		case 'd':
			if (optarg[0] == 'M') {
				dMflag = 1;
				Mflag = 1;
			}
			/* ignore others */
			break;
d145 66
a210 3
		case 't':
			tflag = 1;
			break;
d212 5
a216 70
		case '?':
			usage();
		default:
			error("bad arg %c\n", ch);
		}
	argc -= optind;
	argv += optind;

	filloc = lookup((const usch *)"__FILE__", ENTER);
	linloc = lookup((const usch *)"__LINE__", ENTER);
	pragloc = lookup((const usch *)"_Pragma", ENTER);
	filloc->value = linloc->value = nullusch; /* Just something */
	pragloc->value = nullusch;

	if (tflag == 0) {
		time_t t = time(NULL);
		usch *n = (usch *)ctime(&t);

		/*
		 * Manually move in the predefined macros.
		 */
		nl = lookup((const usch *)"__TIME__", ENTER);
		savch(0); savch('"');  n[19] = 0; savstr(&n[11]); savch('"');
		savch(OBJCT);
		nl->value = stringbuf-1;

		nl = lookup((const usch *)"__DATE__", ENTER);
		savch(0); savch('"'); n[24] = n[11] = 0; savstr(&n[4]);
		savstr(&n[20]); savch('"'); savch(OBJCT);
		nl->value = stringbuf-1;

		nl = lookup((const usch *)"__STDC__", ENTER);
		savch(0); savch('1'); savch(OBJCT);
		nl->value = stringbuf-1;

		nl = lookup((const usch *)"__STDC_VERSION__", ENTER);
		savch(0); savstr((const usch *)"199901L"); savch(OBJCT);
		nl->value = stringbuf-1;
	}

	if (Mflag && !dMflag) {
		usch *c;

		if (argc < 1)
			error("-M and no infile");
		if ((c = (usch *)strrchr(argv[0], '/')) == NULL)
			c = (usch *)argv[0];
		else
			c++;
		Mfile = stringbuf;
		savstr(c); savch(0);
		if ((c = (usch *)strrchr((char *)Mfile, '.')) == NULL)
			error("-M and no extension: ");
		c[1] = 'o';
		c[2] = 0;
	}

	if (argc == 2) {
		if ((ofd = open(argv[1], O_WRONLY|O_CREAT, 0600)) < 0)
			error("Can't creat %s", argv[1]);
	} else
		ofd = 1; /* stdout */
	istty = isatty(ofd);

	if (pushfile((usch *)(argc && strcmp(argv[0], "-") ? argv[0] : NULL)))
		error("cannot open %s", argv[0]);

	flbuf();
	close(ofd);
	return 0;
d219 24
d244 48
a291 31
 * Expand the symbol nl read from input.
 * Return a pointer to the fully expanded result.
 * It is the responsibility of the caller to reset the heap usage.
 */
usch *
gotident(struct symtab *nl)
{
	struct symtab *thisnl;
	usch *osp, *ss2, *base;
	int c;

	thisnl = NULL;
	slow = 1;
	readmac++;
	base = osp = stringbuf;
	goto found;

	while ((c = yylex()) != 0) {
		switch (c) {
		case IDENT:
			if (flslvl)
				break;
			osp = stringbuf;

			DPRINT(("IDENT0: %s\n", yytext));
			nl = lookup((usch *)yytext, FIND);
			if (nl == 0 || thisnl == 0)
				goto found;
			if (thisnl == nl) {
				nl = 0;
				goto found;
d293 57
a349 18
			ss2 = stringbuf;
			if ((c = yylex()) == WSPACE) {
				savstr((usch *)yytext);
				c = yylex();
			}
			if (c != EXPAND) {
				unpstr((usch *)yytext);
				if (ss2 != stringbuf)
					unpstr(ss2);
				unpstr(nl->namep);
				(void)yylex(); /* get yytext correct */
				nl = 0; /* ignore */
			} else {
				thisnl = NULL;
				if (nl->value[0] == OBJCT) {
					unpstr(nl->namep);
					(void)yylex(); /* get yytext correct */
					nl = 0;
d351 6
d358 1
a358 48
			stringbuf = ss2;

found:			if (nl == 0 || subst(nl, NULL) == 0) {
				if (nl)
					savstr(nl->namep);
				else
					savstr((usch *)yytext);
			} else if (osp != stringbuf) {
				DPRINT(("IDENT1: unput osp %p stringbuf %p\n",
				    osp, stringbuf));
				ss2 = stringbuf;
				cunput(EXPAND);
				while (ss2 > osp)
					cunput(*--ss2);
				thisnl = nl;
				stringbuf = osp; /* clean up heap */
			}
			break;

		case EXPAND:
			DPRINT(("EXPAND!\n"));
			thisnl = NULL;
			break;

		case CMNT:
			getcmnt();
			break;

		case STRING:
		case '\n':
		case NUMBER:
		case FPOINT:
		case WSPACE:
			savstr((usch *)yytext);
			break;

		default:
			if (c < 256)
				savch(c);
			else
				savstr((usch *)yytext);
			break;
		}
		if (thisnl == NULL) {
			slow = 0;
			readmac--;
			savch(0);
			return base;
a360 3
	error("premature EOF");
	/* NOTREACHED */
	return NULL; /* XXX gcc */
d363 2
a364 38
void
line(void)
{
	static usch *lbuf;
	static int llen;
	int c;

	slow = 1;
	if (yylex() != WSPACE)
		goto bad;
	if ((c = yylex()) != IDENT || !isdigit((int)yytext[0]))
		goto bad;
	ifiles->lineno = atoi(yytext);

	if ((c = yylex()) != '\n' && c != WSPACE)
		goto bad;
	if (c == '\n') {
		slow = 0;
		return;
	}
	if (yylex() != STRING || yytext[0] == 'L')
		goto bad;
	c = strlen((char *)yytext);
	if (llen < c) {
		/* XXX may loose heap space */
		lbuf = stringbuf;
		stringbuf += c;
		llen = c;
	}
	yytext[strlen(yytext)-1] = 0;
	if (strlcpy((char *)lbuf, &yytext[1], SBSIZE) >= SBSIZE)
		error("line exceeded buffer size");

	ifiles->fname = lbuf;
	if (yylex() != '\n')
		goto bad;
	slow = 0;
	return;
d366 4
a369 2
bad:	error("bad line directive");
}
d371 2
a372 18
/*
 * Include a file. Include order:
 * - For <...> files, first search -I directories, then system directories.
 * - For "..." files, first search "current" dir, then as <...> files.
 */
void
include(void)
{
	struct incs *w;
	struct symtab *nl;
	usch *osp;
	usch *fn, *safefn;
	int i, c, it;

	if (flslvl)
		return;
	osp = stringbuf;
	slow = 1;
d374 115
a488 53
	if ((c = yylex()) == WSPACE)
		c = yylex();
	if (c != STRING && c != '<' && c != IDENT)
		goto bad;

	if (c == IDENT) {
		if ((nl = lookup((usch *)yytext, FIND)) == NULL)
			goto bad;
		if (subst(nl, NULL) == 0)
			goto bad;
		savch('\0');
		unpstr(osp);
		goto again;
	} else if (c == '<') {
		fn = stringbuf;
		while ((c = yylex()) != '>' && c != '\n') {
			if (c == '\n')
				goto bad;
			savstr((usch *)yytext);
		}
		savch('\0');
		while ((c = yylex()) == WSPACE)
			;
		if (c != '\n')
			goto bad;
		it = SYSINC;
		safefn = fn;
	} else {
		usch *nm = stringbuf;

		yytext[strlen(yytext)-1] = 0;
		fn = (usch *)&yytext[1];
		/* first try to open file relative to previous file */
		/* but only if it is not an absolute path */
		if (*fn != '/') {
			savstr(ifiles->orgfn);
			if ((stringbuf =
			    (usch *)strrchr((char *)nm, '/')) == NULL)
				stringbuf = nm;
			else
				stringbuf++;
		}
		safefn = stringbuf;
		savstr(fn); savch(0);
		while ((c = yylex()) == WSPACE)
			;
		if (c != '\n')
			goto bad;
		slow = 0;
		if (pushfile(nm) == 0)
			return;
		/* XXX may loose stringbuf space */
	}
d490 8
a497 15
	/* create search path and try to open file */
	slow = 0;
	for (i = 0; i < 2; i++) {
		for (w = incdir[i]; w; w = w->next) {
			usch *nm = stringbuf;

			savstr(w->dir); savch('/');
			savstr(safefn); savch(0);
			if (pushfile(nm) == 0)
				return;
			stringbuf = nm;
		}
	}
	error("cannot find '%s'", safefn);
	/* error() do not return */
d499 29
a527 2
bad:	error("bad include");
	/* error() do not return */
d530 91
a620 27
static int
definp(void)
{
	int c;

	do
		c = yylex();
	while (c == WSPACE);
	return c;
}

void
getcmnt(void)
{
	int c;

	savstr((usch *)yytext);
	for (;;) {
		c = cinput();
		if (c == '*') {
			c = cinput();
			if (c == '/') {
				savstr((const usch *)"*/");
				return;
			}
			cunput(c);
			c = '*';
a621 28
		savch(c);
	}
}

/*
 * Compare two replacement lists, taking in account comments etc.
 */
static int
cmprepl(usch *o, usch *n)
{
	for (; *o; o--, n--) {
		/* comment skip */
		if (*o == '/' && o[-1] == '*') {
			while (*o != '*' || o[-1] != '/')
				o--;
			o -= 2;
		}
		if (*n == '/' && n[-1] == '*') {
			while (*n != '*' || n[-1] != '/')
				n--;
			n -= 2;
		}
		while (*o == ' ' || *o == '\t')
			o--;
		while (*n == ' ' || *n == '\t')
			n--;
		if (*o != *n)
			return 1;
d623 49
a671 34
	return 0;
}

void
define(void)
{
	struct symtab *np;
	usch *args[MAXARG], *ubuf, *sbeg;
	int c, i, redef;
	int mkstr = 0, narg = -1;
	int ellips = 0;
#ifdef GCC_VARI
	usch *gccvari = NULL;
	int wascon;
#endif

	if (flslvl)
		return;
	slow = 1;
	if (yylex() != WSPACE || yylex() != IDENT)
		goto bad;

	if (isdigit((int)yytext[0]))
		goto bad;

	np = lookup((usch *)yytext, ENTER);
	redef = np->value != NULL;

	readmac = 1;
	sbeg = stringbuf;
	if ((c = yylex()) == '(') {
		narg = 0;
		/* function-like macros, deal with identifiers */
		c = definp();
d673 12
a684 7
			if (c == ')')
				break;
			if (c == ELLIPS) {
				ellips = 1;
				if (definp() != ')')
					goto bad;
				break;
d686 23
a708 11
			if (c == IDENT) {
				/* make sure there is no arg of same name */
				for (i = 0; i < narg; i++)
					if (!strcmp((char *) args[i], yytext))
						error("Duplicate macro "
						  "parameter \"%s\"", yytext);
				args[narg++] = xstrdup(yytext);
				if ((c = definp()) == ',') {
					if ((c = definp()) == ')')
						goto bad;
					continue;
d710 15
a724 6
#ifdef GCC_VARI
				if (c == ELLIPS) {
					if (definp() != ')')
						goto bad;
					gccvari = args[--narg];
					break;
a725 3
#endif
				if (c == ')')
					break;
a726 1
			goto bad;
d728 26
a753 40
		c = yylex();
	} else if (c == '\n') {
		/* #define foo */
		;
	} else if (c != WSPACE)
		goto bad;

	while (c == WSPACE)
		c = yylex();

	/* replacement list cannot start with ## operator */
	if (c == CONCAT)
		goto bad;

	/* parse replacement-list, substituting arguments */
	savch('\0');
	while (c != '\n') {
#ifdef GCC_VARI
		wascon = 0;
loop:
#endif
		switch (c) {
		case WSPACE:
			/* remove spaces if it surrounds a ## directive */
			ubuf = stringbuf;
			savstr((usch *)yytext);
			c = yylex();
			if (c == CONCAT) {
				stringbuf = ubuf;
				savch(CONC);
				if ((c = yylex()) == WSPACE)
					c = yylex();
#ifdef GCC_VARI
				if (c == '\n')
					break;
				wascon = 1;
				goto loop;
#endif
			}
			continue;
d755 38
a792 10
		case CONCAT:
			/* No spaces before concat op */
			savch(CONC);
			if ((c = yylex()) == WSPACE)
				c = yylex();
#ifdef GCC_VARI
			if (c == '\n')
				break;
			wascon = 1;
			goto loop;
d794 3
a796 1
			continue;
d798 39
a836 32

		case MKSTR:
			if (narg < 0) {
				/* no meaning in object-type macro */
				savch('#');
				break;
			}
			/* remove spaces between # and arg */
			savch(SNUFF);
			if ((c = yylex()) == WSPACE)
				c = yylex(); /* whitespace, ignore */
			mkstr = 1;
			if (c == VA_ARGS)
				continue;

			/* FALLTHROUGH */
		case IDENT:
			if (narg < 0)
				goto id; /* just add it if object */
			/* check if its an argument */
			for (i = 0; i < narg; i++)
				if (strcmp(yytext, (char *)args[i]) == 0)
					break;
			if (i == narg) {
#ifdef GCC_VARI
				if (gccvari &&
				    strcmp(yytext, (char *)gccvari) == 0) {
					savch(wascon ? GCCARG : VARG);
					savch(WARN);
					if (mkstr)
						savch(SNUFF), mkstr = 0;
					break;
a837 4
#endif
				if (mkstr)
					error("not argument");
				goto id;
d839 3
a841 22
			savch(i);
			savch(WARN);
			if (mkstr)
				savch(SNUFF), mkstr = 0;
			break;

		case VA_ARGS:
			if (ellips == 0)
				error("unwanted %s", yytext);
			savch(VARG);
			savch(WARN);
			if (mkstr)
				savch(SNUFF), mkstr = 0;
			break;

		case CMNT: /* save comments */
			getcmnt();
			break;

		default:
id:			savstr((usch *)yytext);
			break;
d843 7
a849 58
		c = yylex();
	}
	readmac = 0;
	/* remove trailing whitespace */
	while (stringbuf > sbeg) {
		if (stringbuf[-1] == ' ' || stringbuf[-1] == '\t')
			stringbuf--;
		/* replacement list cannot end with ## operator */
		else if (stringbuf[-1] == CONC)
			goto bad;
		else
			break;
	}
#ifdef GCC_VARI
	if (gccvari) {
		savch(narg);
		savch(VARG);
	} else
#endif
	if (ellips) {
		savch(narg);
		savch(VARG);
	} else
		savch(narg < 0 ? OBJCT : narg);
	if (redef) {
		if (cmprepl(np->value, stringbuf-1))
			error("%s redefined\nprevious define: %s:%d",
			    np->namep, np->file, np->line);
		stringbuf = sbeg;  /* forget this space */
	} else
		np->value = stringbuf-1;

#ifdef CPP_DEBUG
	if (dflag) {
		usch *w = np->value;

		printf("!define: ");
		if (*w == OBJCT)
			printf("[object]");
		else if (*w == VARG)
			printf("[VARG%d]", *--w);
		while (*--w) {
			switch (*w) {
			case WARN: printf("<%d>", *--w); break;
			case CONC: printf("<##>"); break;
			case SNUFF: printf("<\">"); break;
			default: putchar(*w); break;
			}
		}
		putchar('\n');
	}
#endif
	slow = 0;
	for (i = 0; i < narg; i++)
		free(args[i]);
	return;

bad:	error("bad define");
d852 13
a864 15
void
xwarning(usch *s)
{
	usch *t;
	usch *sb = stringbuf;

	flbuf();
	savch(0);
	if (ifiles != NULL) {
		t = sheap("%s:%d: warning: ", ifiles->fname, ifiles->lineno);
		write (2, t, strlen((char *)t));
	}
	write (2, s, strlen((char *)s));
	write (2, "\n", 1);
	stringbuf = sb;
d867 3
a869 4
void
xerror(usch *s)
{
	usch *t;
d871 8
a878 9
	flbuf();
	savch(0);
	if (ifiles != NULL) {
		t = sheap("%s:%d: error: ", ifiles->fname, ifiles->lineno);
		write (2, t, strlen((char *)t));
	}
	write (2, s, strlen((char *)s));
	write (2, "\n", 1);
	exit(1);
d881 40
a920 12
/*
 * store a character into the "define" buffer.
 */
void
savch(int c)
{
	if (stringbuf-sbf < SBSIZE) {
		*stringbuf++ = c;
	} else {
		stringbuf = sbf; /* need space to write error message */
		error("Too much defining");
	} 
d923 3
a925 5
/*
 * convert _Pragma to #pragma for output.
 */
static void
pragoper(void)
d927 18
a944 36
	usch *opb;
	int t, plev;

	slow++;
	if ((t = yylex()) == WSPACE)
		t = yylex();
	if (t != '(')
		goto bad;
	if ((t = yylex()) == WSPACE)
		t = yylex();
	opb = stringbuf;
	for (plev = 0; ; t = yylex()) {
		if (t == '(')
			plev++;
		if (t == ')')
			plev--;
		if (plev < 0)
			break;
		savstr((usch *)yytext);
	}

	savch(0);
	cunput(WARN);
	unpstr(opb);
	stringbuf = opb;
	expmac(NULL);
	cunput('\n');
	while (stringbuf > opb)
		cunput(*--stringbuf);
	savch(PRAGS);
	while ((t = yylex()) != '\n') {
		if (t == WSPACE)
			continue;
		if (t != STRING)
			goto bad;
		savstr((usch *)yytext);
d946 2
a947 7

	savch(PRAGE);
	while (stringbuf > opb)
		cunput(*--stringbuf);
	slow--;
	return;
bad:	error("bad pragma operator");
d950 60
a1009 44
/*
 * substitute namep for sp->value.
 */
int
subst(struct symtab *sp, struct recur *rp)
{
	struct recur rp2;
	register usch *vp, *cp, *obp;
	int c, nl;

	DPRINT(("subst: %s\n", sp->namep));
	/*
	 * First check for special macros.
	 */
	if (sp == filloc) {
		(void)sheap("\"%s\"", ifiles->fname);
		return 1;
	} else if (sp == linloc) {
		(void)sheap("%d", ifiles->lineno);
		return 1;
	} else if (sp == pragloc) {
		pragoper();
		return 1;
	}
	vp = sp->value;

	rp2.next = rp;
	rp2.sp = sp;

	if (*vp-- != OBJCT) {
		int gotwarn = 0;

		/* should we be here at all? */
		/* check if identifier is followed by parentheses */

		obp = stringbuf;
		nl = 0;
		do {
			c = cinput();
			*stringbuf++ = c;
			if (c == WARN) {
				gotwarn++;
				if (rp == NULL)
					break;
d1011 2
a1012 28
			if (c == '\n')
				nl++;
		} while (c == ' ' || c == '\t' || c == '\n' || 
			    c == '\r' || c == WARN);

		DPRINT(("c %d\n", c));
		if (c == '(' ) {
			cunput(c);
			stringbuf = obp;
			ifiles->lineno += nl;
			expdef(vp, &rp2, gotwarn);
			return 1;
		} else {
	 		*stringbuf = 0;
			unpstr(obp);
			unpstr(sp->namep);
			if ((c = yylex()) != IDENT)
				error("internal sync error");
			stringbuf = obp;
			return 0;
		}
	} else {
		cunput(WARN);
		cp = vp;
		while (*cp) {
			if (*cp != CONC)
				cunput(*cp);
			cp--;
d1014 18
a1031 85
		expmac(&rp2);
	}
	return 1;
}

/*
 * do macro-expansion until WARN character read.
 * read from lex buffer and store result on heap.
 * will recurse into lookup() for recursive expansion.
 * when returning all expansions on the token list is done.
 */
void
expmac(struct recur *rp)
{
	struct symtab *nl;
	int c, noexp = 0, orgexp;
	usch *och, *stksv;

#ifdef CPP_DEBUG
	if (dflag) {
		struct recur *rp2 = rp;
		printf("\nexpmac\n");
		while (rp2) {
			printf("do not expand %s\n", rp2->sp->namep);
			rp2 = rp2->next;
		}
	}
#endif
	readmac++;
	while ((c = yylex()) != WARN) {
		switch (c) {
		case NOEXP: noexp++; break;
		case EXPAND: noexp--; break;

		case IDENT:
			/*
			 * Handle argument concatenation here.
			 * If an identifier is found and directly 
			 * after EXPAND or NOEXP then push the
			 * identifier back on the input stream and
			 * call yylex() again.
			 * Be careful to keep the noexp balance.
			 */
			och = stringbuf;
			savstr((usch *)yytext);
			DDPRINT(("id: str %s\n", och));

			orgexp = 0;
			while ((c = yylex()) == EXPAND || c == NOEXP)
				if (c == EXPAND)
					orgexp--;
				else
					orgexp++;

			DDPRINT(("id1: typ %d noexp %d orgexp %d\n",
			    c, noexp, orgexp));
			if (c == IDENT) { /* XXX numbers? */
				DDPRINT(("id2: str %s\n", yytext));
				/* OK to always expand here? */
				savstr((usch *)yytext);
				switch (orgexp) {
				case 0: /* been EXP+NOEXP */
					if (noexp == 0)
						break;
					if (noexp != 1)
						error("case 0");
					cunput(NOEXP);
					noexp = 0;
					break;
				case -1: /* been EXP */
					if (noexp != 1)
						error("case -1");
					noexp = 0;
					break;
				case 1:
					if (noexp != 0)
						error("case 1");
					cunput(NOEXP);
					break;
				default:
					error("orgexp = %d", orgexp);
				}
				unpstr(och);
				stringbuf = och;
				continue; /* New longer identifier */
d1033 5
a1037 74
			unpstr((usch *)yytext);
			if (orgexp == -1)
				cunput(EXPAND);
			else if (orgexp == -2)
				cunput(EXPAND), cunput(EXPAND);
			else if (orgexp == 1)
				cunput(NOEXP);
			unpstr(och);
			stringbuf = och;


			yylex(); /* XXX reget last identifier */

			if ((nl = lookup((usch *)yytext, FIND)) == NULL)
				goto def;

			if (canexpand(rp, nl) == 0)
				goto def;
			/*
			 * If noexp == 0 then expansion of any macro is 
			 * allowed.  If noexp == 1 then expansion of a
			 * fun-like macro is allowed iff there is an 
			 * EXPAND between the identifier and the '('.
			 */
			if (noexp == 0) {
				if ((c = subst(nl, rp)) == 0)
					goto def;
				break;
			}
//printf("noexp1 %d nl->namep %s\n", noexp, nl->namep);
//if (noexp > 1) goto def;
			if (noexp != 1)
				error("bad noexp %d", noexp);
			stksv = NULL;
			if ((c = yylex()) == WSPACE) {
				stksv = xstrdup(yytext);
				c = yylex();
			}
			/* only valid for expansion if fun macro */
			if (c == EXPAND && *nl->value != OBJCT) {
				noexp--;
				if (subst(nl, rp))
					break;
				savstr(nl->namep);
				if (stksv)
					savstr(stksv);
			} else {
				unpstr((usch *)yytext);
				if (stksv)
					unpstr(stksv);
				savstr(nl->namep);
			}
			if (stksv)
				free(stksv);
			break;

		case CMNT:
			getcmnt();
			break;

		case STRING:
			/* remove EXPAND/NOEXP from strings */
			if (yytext[1] == NOEXP) {
				savch('"');
				och = (usch *)&yytext[2];
				while (*och != EXPAND)
					savch(*och++);
				savch('"');
				break;
			}
			/* FALLTHROUGH */

def:		default:
			savstr((usch *)yytext);
d1041 2
a1042 4
	if (noexp)
		error("expmac noexp=%d", noexp);
	readmac--;
	DPRINT(("return from expmac\n"));
a1044 181
/*
 * expand a function-like macro.
 * vp points to end of replacement-list
 * reads function arguments from yylex()
 * result is written on top of heap
 */
void
expdef(usch *vp, struct recur *rp, int gotwarn)
{
	usch **args, *sptr, *ap, *bp, *sp;
	int narg, c, i, plev, snuff, instr;
	int ellips = 0;

	DPRINT(("expdef rp %s\n", (rp ? (char *)rp->sp->namep : "")));
	if ((c = yylex()) != '(')
		error("got %c, expected (", c);
	if (vp[1] == VARG) {
		narg = *vp--;
		ellips = 1;
	} else
		narg = vp[1];
	if ((args = malloc(sizeof(usch *) * (narg+ellips))) == NULL)
		error("expdef: out of mem");

	/*
	 * read arguments and store them on heap.
	 * will be removed just before return from this function.
	 */
	inmac = 1;
	sptr = stringbuf;
	instr = 0;
	for (i = 0; i < narg && c != ')'; i++) {
		args[i] = stringbuf;
		plev = 0;
		while ((c = yylex()) == WSPACE || c == '\n')
			;
		DDPRINT((":AAA (%d)", c));
		if (instr == -1)
			savch(NOEXP), instr = 1;
		if (c == NOEXP)
			instr = 1;
		for (;;) {
			if (plev == 0 && (c == ')' || c == ','))
				break;
			if (c == '(')
				plev++;
			if (c == ')')
				plev--;
			savstr((usch *)yytext);
			while ((c = yylex()) == '\n')
				savch('\n');
			while (c == CMNT) {
				getcmnt();
				c = yylex();
			}
			if (c == EXPAND)
				instr = 0;
			if (c == 0)
				error("eof in macro");
		}
		while (args[i] < stringbuf &&
		    (stringbuf[-1] == ' ' || stringbuf[-1] == '\t'))
			stringbuf--;
		if (instr == 1)
			savch(EXPAND), instr = -1;
		savch('\0');
	}
	if (ellips)
		args[i] = nullusch;
	if (ellips && c != ')') {
		args[i] = stringbuf;
		plev = 0;
		instr = 0;
		while ((c = yylex()) == WSPACE)
			;
		if (c == NOEXP)
			instr++;
		DDPRINT((":AAY (%d)", c));
		for (;;) {
			if (plev == 0 && c == ')')
				break;
			if (c == '(')
				plev++;
			if (c == ')')
				plev--;
			if (plev == 0 && c == ',' && instr) {
				savch(EXPAND);
				savch(',');
				savch(NOEXP);
			} else
				savstr((usch *)yytext);
			while ((c = yylex()) == '\n')
				savch('\n');
			if (c == EXPAND)
				instr--;
		}
		while (args[i] < stringbuf &&
		    (stringbuf[-1] == ' ' || stringbuf[-1] == '\t'))
			stringbuf--;
		savch('\0');
		
	}
	if (narg == 0 && ellips == 0)
		while ((c = yylex()) == WSPACE || c == '\n')
			;

	if (c != ')' || (i != narg && ellips == 0) || (i < narg && ellips == 1))
		error("wrong arg count");

	inmac = 0;
	while (gotwarn--)
		cunput(WARN);

	sp = vp;
	instr = snuff = 0;

	/*
	 * push-back replacement-list onto lex buffer while replacing
	 * arguments. 
	 */
	cunput(WARN);
	while (*sp != 0) {
		if (*sp == SNUFF)
			cunput('\"'), snuff ^= 1;
		else if (*sp == CONC)
			;
		else if (*sp == WARN) {

			if (sp[-1] == VARG) {
				bp = ap = args[narg];
				sp--;
#ifdef GCC_VARI
			} else if (sp[-1] == GCCARG) {
				ap = args[narg];
				if (ap[0] == 0)
					ap = zerousch;
				bp = ap;
				sp--;
#endif
			} else
				bp = ap = args[(int)*--sp];
			if (sp[2] != CONC && !snuff && sp[-1] != CONC) {
				cunput(WARN);
				while (*bp)
					bp++;
				while (bp > ap)
					cunput(*--bp);
				DPRINT(("expand arg %d string %s\n", *sp, ap));
				bp = ap = stringbuf;
				savch(NOEXP);
				expmac(NULL);
				savch(EXPAND);
				savch('\0');
			}
			while (*bp)
				bp++;
			while (bp > ap) {
				bp--;
				if (snuff && !instr && 
				    (*bp == ' ' || *bp == '\t' || *bp == '\n')){
					while (*bp == ' ' || *bp == '\t' ||
					    *bp == '\n') {
						bp--;
					}
					cunput(' ');
				}
				cunput(*bp);
				if ((*bp == '\'' || *bp == '"')
				     && bp[-1] != '\\' && snuff) {
					instr ^= 1;
					if (instr == 0 && *bp == '"')
						cunput('\\');
				}
				if (instr && (*bp == '\\' || *bp == '"'))
					cunput('\\');
			}
		} else
			cunput(*sp);
		sp--;
	}
	stringbuf = sptr;
a1045 4
	/* scan the input buffer (until WARN) and save result on heap */
	expmac(rp);
	free(args);
}
a1046 4
usch *
savstr(const usch *str)
{
	usch *rv = stringbuf;
d1048 9
a1056 8
	do {
		if (stringbuf >= &sbf[SBSIZE])   {
			stringbuf = sbf; /* need space to write error message */
			error("out of macro space!");
		}
	} while ((*stringbuf++ = *str++));
	stringbuf--;
	return rv;
d1059 3
a1061 4
int
canexpand(struct recur *rp, struct symtab *np)
{
	struct recur *w;
d1063 4
a1066 5
	for (w = rp; w && w->sp != np; w = w->next)
		;
	if (w != NULL)
		return 0;
	return 1;
d1069 4
a1072 10
void
unpstr(usch *c)
{
	usch *d = c;

	while (*d)
		d++;
	while (d > c) {
		cunput(*--d);
	}
d1075 1
a1075 9
void
flbuf(void)
{
	if (obufp == 0)
		return;
	if (Mflag == 0 && write(ofd, outbuf, obufp) < 0)
		error("obuf write error");
	obufp = 0;
}
d1077 2
a1078 2
void
putch(int ch)
d1080 3
a1082 4
	outbuf[obufp++] = ch;
	if (obufp == CPPBUF || (istty && ch == '\n'))
		flbuf();
}
d1084 14
a1097 7
void
putstr(const usch *s)
{
	for (; *s; s++) {
		if (*s == PRAGS) {
			s = prtprag(s);
			continue;
d1099 24
a1122 5
		outbuf[obufp++] = *s;
		if (obufp == CPPBUF || (istty && *s == '\n'))
			flbuf();
	}
}
d1124 59
a1182 45
/*
 * convert a number to an ascii string. Store it on the heap.
 */
static void
num2str(int num)
{
	static usch buf[12];
	usch *b = buf;
	int m = 0;
	
	if (num < 0)
		num = -num, m = 1;
	do {
		*b++ = num % 10 + '0', num /= 10;
	} while (num);
	if (m)
		*b++ = '-';
	while (b > buf)
		savch(*--b);
}

/*
 * similar to sprintf, but only handles %s and %d. 
 * saves result on heap.
 */
usch *
sheap(const char *fmt, ...)
{
	va_list ap;
	usch *op = stringbuf;

	va_start(ap, fmt);
	for (; *fmt; fmt++) {
		if (*fmt == '%') {
			fmt++;
			switch (*fmt) {
			case 's':
				savstr(va_arg(ap, usch *));
				break;
			case 'd':
				num2str(va_arg(ap, int));
				break;
			case 'c':
				savch(va_arg(ap, int));
				break;
d1184 66
a1249 27
				break; /* cannot call error() here */
			}
		} else
			savch(*fmt);
	}
	va_end(ap);
	*stringbuf = 0;
	return op;
}

void
usage(void)
{
	error("Usage: cpp [-Cdt] [-Dvar=val] [-Uvar] [-Ipath] [-Spath]");
}

#ifdef notyet
/*
 * Symbol table stuff.
 * The data structure used is a patricia tree implementation using only
 * bytes to store offsets.  
 * The information stored is (lower address to higher):
 *
 *	unsigned char bitno[2]; bit number in the string
 *	unsigned char left[3];	offset from base to left element
 *	unsigned char right[3];	offset from base to right element
 */
d1251 38
a1288 183

/*
 * This patricia implementation is more-or-less the same as
 * used in ccom for string matching.
 */
struct tree {
	int bitno;
	struct tree *lr[2];
};

#define BITNO(x)		((x) & ~(LEFT_IS_LEAF|RIGHT_IS_LEAF))
#define LEFT_IS_LEAF		0x80000000
#define RIGHT_IS_LEAF		0x40000000
#define IS_LEFT_LEAF(x)		(((x) & LEFT_IS_LEAF) != 0)
#define IS_RIGHT_LEAF(x)	(((x) & RIGHT_IS_LEAF) != 0)
#define P_BIT(key, bit)		(key[bit >> 3] >> (bit & 7)) & 1
#define CHECKBITS		8

static struct tree *sympole;
static int numsyms;

/*
 * Allocate a symtab struct and store the string.
 */
static struct symtab *
getsymtab(const usch *str)
{
	struct symtab *sp = malloc(sizeof(struct symtab));

	if (sp == NULL)
		error("getsymtab: couldn't allocate symtab");
	sp->namep = savstr(str);
	savch('\0');
	sp->value = NULL;
	sp->file = ifiles ? ifiles->orgfn : (const usch *)"<initial>";
	sp->line = ifiles ? ifiles->lineno : 0;
	return sp;
}

/*
 * Do symbol lookup in a patricia tree.
 * Only do full string matching, no pointer optimisations.
 */
struct symtab *
lookup(const usch *key, int enterf)
{
	struct symtab *sp;
	struct tree *w, *new, *last;
	int len, cix, bit, fbit, svbit, ix, bitno;
	const usch *k;
	usch *m, *sm;

	/* Count full string length */
	for (k = key, len = 0; *k; k++, len++)
		;

	switch (numsyms) {
	case 0: /* no symbols yet */
		if (enterf != ENTER)
			return NULL;
		sympole = (struct tree *)getsymtab(key);
		numsyms++;
		return (struct symtab *)sympole;

	case 1:
		w = sympole;
		svbit = 0; /* XXX gcc */
		break;

	default:
		w = sympole;
		bitno = len * CHECKBITS;
		for (;;) {
			bit = BITNO(w->bitno);
			fbit = bit > bitno ? 0 : P_BIT(key, bit);
			svbit = fbit ? IS_RIGHT_LEAF(w->bitno) :
			    IS_LEFT_LEAF(w->bitno);
			w = w->lr[fbit];
			if (svbit)
				break;
		}
	}

	sp = (struct symtab *)w;

	sm = m = sp->namep;
	k = key;

	/* Check for correct string and return */
	for (cix = 0; *m && *k && *m == *k; m++, k++, cix += CHECKBITS)
		;
	if (*m == 0 && *k == 0) {
		if (enterf != ENTER && sp->value == NULL)
			return NULL;
		return sp;
	}

	if (enterf != ENTER)
		return NULL; /* no string found and do not enter */

	ix = *m ^ *k;
	while ((ix & 1) == 0)
		ix >>= 1, cix++;

	/* Create new node */
	if ((new = malloc(sizeof *new)) == NULL)
		error("getree: couldn't allocate tree");
	bit = P_BIT(key, cix);
	new->bitno = cix | (bit ? RIGHT_IS_LEAF : LEFT_IS_LEAF);
	new->lr[bit] = (struct tree *)getsymtab(key);

	if (numsyms++ == 1) {
		new->lr[!bit] = sympole;
		new->bitno |= (bit ? LEFT_IS_LEAF : RIGHT_IS_LEAF);
		sympole = new;
		return (struct symtab *)new->lr[bit];
	}

	w = sympole;
	last = NULL;
	for (;;) {
		fbit = w->bitno;
		bitno = BITNO(w->bitno);
		if (bitno == cix)
			error("bitno == cix");
		if (bitno > cix)
			break;
		svbit = P_BIT(key, bitno);
		last = w;
		w = w->lr[svbit];
		if (fbit & (svbit ? RIGHT_IS_LEAF : LEFT_IS_LEAF))
			break;
	}

	new->lr[!bit] = w;
	if (last == NULL) {
		sympole = new;
	} else {
		last->lr[svbit] = new;
		last->bitno &= ~(svbit ? RIGHT_IS_LEAF : LEFT_IS_LEAF);
	}
	if (bitno < cix)
		new->bitno |= (bit ? LEFT_IS_LEAF : RIGHT_IS_LEAF);
	return (struct symtab *)new->lr[bit];
}

usch *
xstrdup(char *str)
{
	size_t len = strlen(str)+1;
	usch *rv;

	if ((rv = malloc(len)) == NULL)
		error("xstrdup: out of mem");
	strlcpy((char *)rv, str, len);
	return rv;
}

const usch *
prtprag(const usch *s)
{
	int ch;

	s++;
	putstr((const usch *)"\n#pragma ");
	while (*s != PRAGE) {
		if (*s == 'L')
			s++;
		if (*s == '\"') {
			s++;
			while ((ch = *s++) != '\"') {
				if (ch == '\\' && (*s == '\"' || *s == '\\'))
					ch = *s++;
				putch(ch);
			}
		} else {
			s++;
			putch(*s);
		}
	}
	putstr((const usch *)"\n");
	prtline();
	return ++s;
@


1.5
log
@introduce pcc-cpp instead of Reiser CCCP
passes all but 2 regression tests (whitespace issues)
@
text
@d92 1
a92 1
__RCSID("$MirOS$");
a177 1
void line(void);
d179 1
a179 1
void usage(void);
d181 1
a181 1
usch *prtprag(usch *opb);
d183 4
d264 5
a268 5
	filloc = lookup((usch *)"__FILE__", ENTER);
	linloc = lookup((usch *)"__LINE__", ENTER);
	pragloc = lookup((usch *)"_Pragma", ENTER);
	filloc->value = linloc->value = (usch *)""; /* Just something */
	pragloc->value = (usch *)"";
d277 1
a277 1
		nl = lookup((usch *)"__TIME__", ENTER);
d282 1
a282 1
		nl = lookup((usch *)"__DATE__", ENTER);
d287 1
a287 1
		nl = lookup((usch *)"__STDC__", ENTER);
d291 2
a292 2
		nl = lookup((usch *)"__STDC_VERSION__", ENTER);
		savch(0); savstr((usch *)"199901L"); savch(OBJCT);
d437 1
a437 1
line()
d484 1
a484 1
include()
d593 1
a593 1
				savstr((usch *)"*/");
d632 1
a632 1
define()
d974 1
a974 3
subst(sp, rp)
struct symtab *sp;
struct recur *rp;
d1281 1
a1281 1
		args[i] = (usch *)"";
d1348 1
a1348 1
					ap = (usch *)"0";
d1401 1
a1401 1
savstr(usch *str)
d1440 1
a1440 1
flbuf()
d1458 1
a1458 1
putstr(usch *s)
d1497 1
a1497 1
sheap(char *fmt, ...)
d1528 1
a1528 1
usage()
d1570 1
a1570 1
getsymtab(usch *str)
d1579 1
a1579 1
	sp->file = ifiles ? ifiles->orgfn : (usch *)"<initial>";
d1589 1
a1589 1
lookup(usch *key, int enterf)
d1594 2
a1595 1
	usch *k, *m, *sm;
d1703 2
a1704 2
usch *
prtprag(usch *s)
d1709 1
a1709 1
	putstr((usch *)"\n#pragma ");
d1725 1
a1725 1
	putstr((usch *)"\n");
@


1.4
log
@• add -std=gnu99 to default CFLAGS
• first round of assorted fixes
@
text
@d1 72
a72 4
#ifdef FLEXNAMES
#define	NCPS	128
#else
#define	NCPS	8
a74 1
#include <sys/param.h>
d76 3
d80 1
d83 1
a84 1
#include <paths.h>
d86 7
a92 2
__SCCSID("@@(#)cpp.c	1.22 11/7/90");
__RCSID("$MirOS: src/libexec/cpp/cpp.c,v 1.3 2005/07/01 12:10:16 tg Exp $");
d94 2
a95 16
/* C command
/* written by John F. Reiser
/* July/August 1978
*/

#define STATIC

#define FIRSTOPEN -2
#define STDIN 0
#define READ 0
#define WRITE 1
#define SALT '#'
#if !defined BUFSIZ || BUFSIZ < 8192
#undef BUFSIZ
#define BUFSIZ 8192
#endif
d97 8
a104 9
char *pbeg,*pbuf,*pend;
char *outp,*inp;
char *newp;
char cinit;

/* some code depends on whether characters are sign or zero extended */
/*	#if '\377' < 0		not used here, old cpp doesn't understand */
#if pdp11 | vax | mc68000 | tahoe
#define COFF 128
d106 2
a107 1
#define COFF 0
d110 88
a197 31
# if gcos
#define ALFSIZ 512	/* alphabet size */
# else
#define ALFSIZ 256	/* alphabet size */
# endif
char macbit[ALFSIZ+11];
char toktyp[ALFSIZ];
#define BLANK 1
#define IDENT 2
#define NUMBR 3

/* a superimposed code is used to reduce the number of calls to the
/* symbol table lookup routine.  (if the kth character of an identifier
/* is 'a' and there are no macro names whose kth character is 'a'
/* then the identifier cannot be a macro name, hence there is no need
/* to look in the symbol table.)  'scw1' enables the test based on
/* single characters and their position in the identifier.  'scw2'
/* enables the test based on adjacent pairs of characters and their
/* position in the identifier.  scw1 typically costs 1 indexed fetch,
/* an AND, and a jump per character of identifier, until the identifier
/* is known as a non-macro name or until the end of the identifier.
/* scw1 is inexpensive.  scw2 typically costs 4 indexed fetches,
/* an add, an AND, and a jump per character of identifier, but it is also
/* slightly more effective at reducing symbol table searches.
/* scw2 usually costs too much because the symbol table search is
/* usually short; but if symbol table search should become expensive,
/* the code is here.
/* using both scw1 and scw2 is of dubious value.
*/
#define scw1 1
#define scw2 0
d199 38
a236 2
#if scw2
char t21[ALFSIZ],t22[ALFSIZ],t23[ALFSIZ+NCPS];
d238 54
d293 103
a395 10
#if scw1
#define b0 1
#define b1 2
#define b2 4
#define b3 8
#define b4 16
#define b5 32
#define b6 64
#define b7 128
#endif
d397 4
a400 45
#define IB 1
#define SB 2
#define NB 4
#define CB 8
#define QB 16
#define WB 32
char fastab[ALFSIZ];
char slotab[ALFSIZ];
char *ptrtab;
#define isslo (ptrtab==(slotab+COFF))
#define isid(a)  ((fastab+COFF)[a]&IB)
#define isspc(a) (ptrtab[a]&SB)
#define isnum(a) ((fastab+COFF)[a]&NB)
#define iscom(a) ((fastab+COFF)[a]&CB)
#define isquo(a) ((fastab+COFF)[a]&QB)
#define iswarn(a) ((fastab+COFF)[a]&WB)

#define eob(a) ((a)>=pend)
#define bob(a) (pbeg>=(a))

# define cputc(a,b)	if(!flslvl) putc(a,b)

char buffer[NCPS+BUFSIZ+BUFSIZ+NCPS];

char	*lastcopy;

# define DROP 0xFE	/* special character not legal ASCII or EBCDIC */
# define WARN DROP
# define SAME 0
# define MAXINC 15
# define MAXFRE 14	/* max buffers of macro pushback */
# define MAXFRM 31	/* max number of formals/actuals to a macro */

static char warnc = WARN;

int mactop,fretop;
char *instack[MAXFRE],*bufstack[MAXFRE],*endbuf[MAXFRE];

int plvl;	/* parenthesis level during scan for macro actuals */
int maclin;	/* line number of macro call requiring actuals */
char *macfil;	/* file name of macro call requiring actuals */
char *macnam;	/* name of macro requiring actuals */
int maclvl;	/* # calls since last decrease in nesting level */
char *macforw;	/* pointer which must be exceeded to decrease nesting level */
int macdam;	/* offset to macforw due to buffer shifting */
d402 11
a412 3
#if tgp
int tgpscan;	/* flag for dump(); */
#endif
d414 18
a431 66
STATIC	int	inctop[MAXINC];
STATIC	char	*fnames[MAXINC];
STATIC	char	*dirnams[MAXINC];	/* actual directory of #include files */
STATIC	int	fins[MAXINC];
STATIC	int	lineno[MAXINC];

STATIC	char	*dirs[10];	/* -I and <> directories */
char *strdex(), *copy(), *subst(), *trmdir();
struct symtab *stsym();
STATIC	int	fin	= FIRSTOPEN;
STATIC	FILE	*fout	= stdout;
STATIC	int	nd	= 1;
STATIC	int	pflag;	/* don't put out lines "# 12 foo.c" */
int	passcom;	/* don't delete comments */
int	incomment;	/* True if parsing a comment */
STATIC	int rflag;	/* allow macro recursion */
STATIC	int mflag;	/* generate makefile dependencies */
int	uflag = 0;	/* -undef passed */
STATIC	char *infile;	/* name of .o file to build dependencies from */
STATIC 	FILE *mout;	/* file to place dependencies on */
#define START 1
#define CONT  2
#define BACK  3
STATIC	int	ifno;
# define NPREDEF 50
STATIC	char *prespc[NPREDEF];
STATIC	char **predef = prespc;
STATIC	char *punspc[NPREDEF];
STATIC	char **prund = punspc;
STATIC	int	exfail;
struct symtab {
	char	*name;
	char	*value;
} *lastsym, *lookup(), *slookup();

# if gcos
#include <setjmp.h>
static jmp_buf env;
# define main	mainpp
# undef exit
# define exit(S)	longjmp(env, 1)
# define open(S,D)	fileno(fopen(S, "r"))
# define close(F)	fclose(_f[F])
extern FILE *_f[];
# define symsiz 500
# else
# define symsiz 5000		/* std = 500, wnj aug 1979 */
# endif
STATIC	struct symtab stab[symsiz];

STATIC	struct symtab *defloc;
STATIC	struct symtab *udfloc;
STATIC	struct symtab *incloc;
STATIC	struct symtab *ifloc;
STATIC	struct symtab *elsloc;
STATIC	struct symtab *eifloc;
STATIC	struct symtab *ifdloc;
STATIC	struct symtab *ifnloc;
STATIC	struct symtab *ysysloc;
STATIC	struct symtab *varloc;
STATIC	struct symtab *lneloc;
STATIC	struct symtab *ulnloc;
STATIC	struct symtab *uflloc;
STATIC	struct symtab *identloc;	/* Sys 5r3 compatibility */
STATIC	int	trulvl;
STATIC	int	flslvl;
d433 2
a434 2
int
sayline(int where)
d436 37
a472 2
	if (mflag && where==START) fprintf(mout, "%s: %s\n", infile, fnames[ifno]);
	if (pflag==0) fprintf(fout,"# %d \"%s\"\n", lineno[ifno], fnames[ifno]);
a474 1
/* data structure guide
d476 71
a546 50
/* most of the scanning takes place in the buffer:
/*
/*  (low address)                                             (high address)
/*  pbeg                           pbuf                                 pend
/*  |      <-- BUFSIZ chars -->      |         <-- BUFSIZ chars -->        |
/*  _______________________________________________________________________
/* |_______________________________________________________________________|
/*          |               |               |
/*          |<-- waiting -->|               |<-- waiting -->
/*          |    to be      |<-- current -->|    to be
/*          |    written    |    token      |    scanned
/*          |               |               |
/*          outp            inp             p
/*
/*  *outp   first char not yet written to output file
/*  *inp    first char of current token
/*  *p      first char not yet scanned
/*
/* macro expansion: write from *outp to *inp (chars waiting to be written),
/* ignore from *inp to *p (chars of the macro call), place generated
/* characters in front of *p (in reverse order), update pointers,
/* resume scanning.
/*
/* symbol table pointers point to just beyond the end of macro definitions;
/* the first preceding character is the number of formal parameters.
/* the appearance of a formal in the body of a definition is marked by
/* 2 chars: the char WARN, and a char containing the parameter number.
/* the first char of a definition is preceded by a zero character.
/*
/* when macro expansion attempts to back up over the beginning of the
/* buffer, some characters preceding *pend are saved in a side buffer,
/* the address of the side buffer is put on 'instack', and the rest
/* of the main buffer is moved to the right.  the end of the saved buffer
/* is kept in 'endbuf' since there may be nulls in the saved buffer.
/*
/* similar action is taken when an 'include' statement is processed,
/* except that the main buffer must be completely emptied.  the array
/* element 'inctop[ifno]' records the last side buffer saved when
/* file 'ifno' was included.  these buffers remain dormant while
/* the file is being read, and are reactivated at end-of-file.
/*
/* instack[0 : mactop] holds the addresses of all pending side buffers.
/* instack[inctop[ifno]+1 : mactop-1] holds the addresses of the side
/* buffers which are "live"; the side buffers instack[0 : inctop[ifno]]
/* are dormant, waiting for end-of-file on the current file.
/*
/* space for side buffers is obtained from 'malloc' and is never returned.
/* bufstack[0:fretop-1] holds addresses of side buffers which
/* are available for use.
*/
d548 11
a558 22
void
dump(void) {
/* write part of buffer which lies between  outp  and  inp .
/* this should be a direct call to 'write', but the system slows to a crawl
/* if it has to do an unaligned copy.  thus we buffer.  this silly loop
/* is 15% of the total time, thus even the 'putc' macro is too slow.
*/
	register char *p1,*p2; register FILE *f;
	if ((p1=outp)==inp || flslvl!=0) return;
#if tgp
#define MAXOUT 80
	if (!tgpscan) {/* scan again to insure <= MAXOUT chars between linefeeds */
		register char c,*pblank; char savc,stopc,brk;
		tgpscan=1; brk=stopc=pblank=0; p2=inp; savc= *p2; *p2='\0';
		while (c= *p1++) {
			if (c=='\\') c= *p1++;
			if (stopc==c) stopc=0;
			else if (c=='"' || c=='\'') stopc=c;
			if (p1-outp>MAXOUT && pblank!=0) {
				*pblank++='\n'; inp=pblank; dump(); brk=1; pblank=0;
			}
			if (c==' ' && stopc==0) pblank=p1-1;
a559 2
		if (brk) sayline(CONT);
		*p2=savc; inp=p2; p1=outp; tgpscan=0;
d561 24
a584 28
#endif
	f=fout;
# if gcos
/* filter out "$ program c" card if first line of input */
/* gmatch is a simple pattern matcher in the GCOS Standard Library */
{	static int gmfirst = 0;
	if (!gmfirst) {
		++gmfirst;
		if (gmatch(p1, "^$*program[ \t]*c*"))
			p1 = strdex(p1, '\n');
	}
}
# endif
	while (p1<inp) putc(*p1++,f);
	outp=p1;
}

char *
refill(p) register char *p; {
/* dump buffer.  save chars from inp to p.  read into buffer at pbuf,
/* contiguous with p.  update pointers, return new p.
*/
	register char *np,*op; register int ninbuf;
	dump(); np=pbuf-(p-inp); op=inp;
	if (bob(np+1)) {pperror("token too long"); np=pbeg; p=inp+BUFSIZ;}
	macdam += np-inp; outp=inp=np;
	while (op<p) *np++= *op++;
	p=np;
d586 6
a591 30
		if (mactop>inctop[ifno]) {/* retrieve hunk of pushed-back macro text */
			op=instack[--mactop]; np=pbuf;
			do {while (*np++= *op++);} while (op<endbuf[mactop]); pend=np-1;
			/* make buffer space avail for 'include' processing */
			if (fretop<MAXFRE) bufstack[fretop++]=instack[mactop];
			return(p);
		} else {/* get more text from file(s) */
			maclvl=0;
			if (0<(ninbuf=read(fin,pbuf,BUFSIZ))) {
				pend=pbuf+ninbuf; *pend='\0';
				return(p);
			}
			/* end of #include file */
			if (ifno==0) {/* end of input */
				if (plvl!=0) {
					int n=plvl,tlin=lineno[ifno]; char *tfil=fnames[ifno];
					lineno[ifno]=maclin; fnames[ifno]=macfil;
					pperror("%s: unterminated macro call",macnam);
					lineno[ifno]=tlin; fnames[ifno]=tfil;
					np=p; *np++='\n';	/* shut off unterminated quoted string */
					while (--n>=0) *np++=')';	/* supply missing parens */
					pend=np; *np='\0'; if (plvl<0) plvl=0;
					return(p);
				}
				if (trulvl || flslvl)
					if (incomment)
						pperror("unterminated comment");
					else
						pperror("missing endif");
				inp=p; dump(); exit(exfail);
d593 2
a594 1
			close(fin); fin=fins[--ifno]; dirs[0]=dirnams[ifno]; sayline(BACK);
d596 1
d600 27
a626 2
#define BEG 0
#define LF 1
d628 12
a639 4
char *
cotoken(p) register char *p; {
	register int c,i; char quoc;
	static int state = BEG;
d641 18
a658 70
	if (state!=BEG) goto prevlf;
for (;;) {
again:
	while (!isspc(*p++));
	switch (*(inp=p-1)) {
	case 0: {
		if (eob(--p)) {p=refill(p); goto again;}
		else ++p; /* ignore null byte */
	} break;
	case '|': case '&': for (;;) {/* sloscan only */
		if (*p++== *inp) break;
		if (eob(--p)) p=refill(p);
		else break;
	} break;
	case '=': case '!': for (;;) {/* sloscan only */
		if (*p++=='=') break;
		if (eob(--p)) p=refill(p);
		else break;
	} break;
	case '<': case '>': for (;;) {/* sloscan only */
		if (*p++=='=' || p[-2]==p[-1]) break;
		if (eob(--p)) p=refill(p);
		else break;
	} break;
	case '\\': for (;;) {
		if (*p++=='\n') {++lineno[ifno]; break;}
		if (eob(--p)) p=refill(p);
		else {++p; break;}
	} break;
	case '/': for (;;) {
		if (*p++=='*') {/* comment */
			incomment++;
			if (!passcom) {inp=p-2; dump(); ++flslvl;}
			for (;;) {
				while (!iscom(*p++));
				if (p[-1]=='*') for (;;) {
					if (*p++=='/') goto endcom;
					if (eob(--p)) {
						if (!passcom) {inp=p; p=refill(p);}
						else if ((p-inp)>=BUFSIZ) {/* split long comment */
							inp=p; p=refill(p);	/* last char written is '*' */
							cputc('/',fout);	/* terminate first part */
							/* and fake start of 2nd */
							outp=inp=p-=3; *p++='/'; *p++='*'; *p++='*';
						} else p=refill(p);
					} else break;
				} else if (p[-1]=='\n') {
					++lineno[ifno]; if (!passcom) putc('\n',fout);
				} else if (eob(--p)) {
					if (!passcom) {inp=p; p=refill(p);}
					else if ((p-inp)>=BUFSIZ) {/* split long comment */
						inp=p; p=refill(p);
						cputc('*',fout); cputc('/',fout);
						outp=inp=p-=2; *p++='/'; *p++='*';
					} else p=refill(p);
				} else ++p; /* ignore null byte */
			}
		endcom:
			incomment--;
			if (!passcom) {outp=inp=p; --flslvl; goto again;}
			break;
		}
		if (eob(--p)) p=refill(p);
		else break;
	} break;
# if gcos
	case '`':
# endif
	case '"': case '\'': {
		quoc=p[-1];
d660 84
a743 43
			while (!isquo(*p++));
			if (p[-1]==quoc) break;
			if (p[-1]=='\n') {--p; break;} /* bare \n terminates quotation */
			if (p[-1]=='\\') for (;;) {
				if (*p++=='\n') {++lineno[ifno]; break;} /* escaped \n ignored */
				if (eob(--p)) p=refill(p);
				else {++p; break;}
			} else if (eob(--p)) p=refill(p);
			else ++p;	/* it was a different quote character */
		}
	} break;
	case '\n': {
		++lineno[ifno]; if (isslo) {state=LF; return(p);}
prevlf:
		state=BEG;
		for (;;) {
			if (*p++=='#') return(p);
			if (eob(inp= --p)) p=refill(p);
			else goto again;
		}
	} break;
	case '0': case '1': case '2': case '3': case '4':
	case '5': case '6': case '7': case '8': case '9':
	for (;;) {
		while (isnum(*p++));
		if (eob(--p)) p=refill(p);
		else break;
	} break;
	case 'A': case 'B': case 'C': case 'D': case 'E':
	case 'F': case 'G': case 'H': case 'I': case 'J':
	case 'K': case 'L': case 'M': case 'N': case 'O':
	case 'P': case 'Q': case 'R': case 'S': case 'T':
	case 'U': case 'V': case 'W': case 'X': case 'Y':
	case 'Z': case '_':
	case 'a': case 'b': case 'c': case 'd': case 'e':
	case 'f': case 'g': case 'h': case 'i': case 'j':
	case 'k': case 'l': case 'm': case 'n': case 'o':
	case 'p': case 'q': case 'r': case 's': case 't':
	case 'u': case 'v': case 'w': case 'x': case 'y':
	case 'z':
#if scw1
#define tmac1(c,bit) if (!xmac1(c,bit,&)) goto nomac
#define xmac1(c,bit,op) ((macbit+COFF)[c] op (bit))
d745 1
a745 2
#define tmac1(c,bit)
#define xmac1(c,bit,op)
d748 32
a779 7
#if scw2
#define tmac2(c0,c1,cpos) if (!xmac2(c0,c1,cpos,&)) goto nomac
#define xmac2(c0,c1,cpos,op)\
	((macbit+COFF)[(t21+COFF)[c0]+(t22+COFF)[c1]] op (t23+COFF+cpos)[c0])
#else
#define tmac2(c0,c1,cpos)
#define xmac2(c0,c1,cpos,op)
d781 9
d791 12
a802 30
	if (flslvl) goto nomac;
	for (;;) {
		c= p[-1];                          tmac1(c,b0);
		i= *p++; if (!isid(i)) goto endid; tmac1(i,b1); tmac2(c,i,0);
		c= *p++; if (!isid(c)) goto endid; tmac1(c,b2); tmac2(i,c,1);
		i= *p++; if (!isid(i)) goto endid; tmac1(i,b3); tmac2(c,i,2);
		c= *p++; if (!isid(c)) goto endid; tmac1(c,b4); tmac2(i,c,3);
		i= *p++; if (!isid(i)) goto endid; tmac1(i,b5); tmac2(c,i,4);
		c= *p++; if (!isid(c)) goto endid; tmac1(c,b6); tmac2(i,c,5);
		i= *p++; if (!isid(i)) goto endid; tmac1(i,b7); tmac2(c,i,6);
		                                                tmac2(i,0,7);
		while (isid(*p++));
		if (eob(--p)) {refill(p); p=inp+1; continue;}
		goto lokid;
	endid:
		if (eob(--p)) {refill(p); p=inp+1; continue;}
		tmac2(p[-1],0,-1+(p-inp));
	lokid:
		slookup(inp,p,0); if (newp) {p=newp; goto again;}
		else break;
	nomac:
		while (isid(*p++));
		if (eob(--p)) {p=refill(p); goto nomac;}
		else break;
	} break;
	} /* end of switch */
	
	if (isslo) return(p);
} /* end of infinite loop */
}
d804 22
a825 85
char *
skipbl(p) register char *p; {/* get next non-blank token */
	do {outp=inp=p; p=cotoken(p);} while ((toktyp+COFF)[*inp]==BLANK);
	return(p);
}

char *
unfill(p) register char *p; {
/* take <= BUFSIZ chars from right end of buffer and put them on instack .
/* slide rest of buffer to the right, update pointers, return new p.
*/
	register char *np,*op; register int d;
	if (mactop>=MAXFRE) {
		pperror("%s: too much pushback",macnam);
		p=inp=pend; dump();	/* begin flushing pushback */
		while (mactop>inctop[ifno]) {p=refill(p); p=inp=pend; dump();}
	}
	if (fretop>0) np=bufstack[--fretop];
	else {
		np=malloc(BUFSIZ+1);
		if (np==NULL) {pperror("no space"); exit(exfail);}
		np[BUFSIZ]='\0';
	}
	instack[mactop]=np; op=pend-BUFSIZ; if (op<p) op=p;
	for (;;) {while (*np++= *op++); if (eob(op)) break;} /* out with old */
	endbuf[mactop++]=np;	/* mark end of saved text */
	np=pbuf+BUFSIZ; op=pend-BUFSIZ; pend=np; if (op<p) op=p;
	while (outp<op) *--np= *--op; /* slide over new */
	if (bob(np)) pperror("token too long");
	d=np-outp; outp+=d; inp+=d; macdam+=d; return(p+d);
}

char *
doincl(p) register char *p; {
	int filok,inctype;
	register char *cp; char **dirp,*nfil; char filname[BUFSIZ];

	p=skipbl(p); cp=filname;
	if (*inp++=='<') {/* special <> syntax */
		inctype=1;
		++flslvl;	/* prevent macro expansion */
		for (;;) {
			outp=inp=p; p=cotoken(p);
			if (*inp=='\n') {--p; *cp='\0'; break;}
			if (*inp=='>') {      *cp='\0'; break;}
# ifdef gimpel
			if (*inp=='.' && !intss()) *inp='#';
# endif
			while (inp<p) *cp++= *inp++;
		}
		--flslvl;	/* reenable macro expansion */
	} else if (inp[-1]=='"') {/* regular "" syntax */
		inctype=0;
# ifdef gimpel
		while (inp<p) {if (*inp=='.' && !intss()) *inp='#'; *cp++= *inp++;}
# else
		while (inp<p) *cp++= *inp++;
# endif
		if (*--cp=='"') *cp='\0';
	} else {pperror("bad include syntax",0); inctype=2;}
	/* flush current file to \n , then write \n */
	++flslvl; do {outp=inp=p; p=cotoken(p);} while (*inp!='\n'); --flslvl;
	inp=p; dump(); if (inctype==2) return(p);
	/* look for included file */
	if (ifno+1 >=MAXINC) {
		pperror("Unreasonable include nesting",0); return(p);
	}
	if((nfil=malloc(BUFSIZ))==NULL) {pperror("no space"); exit(exfail);}
	filok=0;
	for (dirp=dirs+inctype; *dirp; ++dirp) {
		if (
# if gcos
			strdex(filname, '/')
# else
			filname[0]=='/' 
# endif
				|| **dirp=='\0') strlcpy(nfil,filname,BUFSIZ);
		else {
			strlcpy(nfil,*dirp,BUFSIZ);
# if unix || gcos
			strlcat(nfil,"/",BUFSIZ);
# endif
#ifdef ibm
#ifndef gimpel
			strlcat(nfil,".",BUFSIZ);
d827 32
d860 182
a1041 1
			strlcat(nfil,filname,BUFSIZ);
d1043 25
a1067 2
		if (0<(fins[ifno+1]=open(nfil,READ))) {
			filok=1; fin=fins[++ifno]; break;
d1070 105
a1174 59
	if(filok==0){pperror("Can't find include file %s",filname);free(nfil);}
	else {
		nfil=realloc(nfil,strlen(nfil)+1);
		lineno[ifno]=1; fnames[ifno]=nfil;
		dirnams[ifno]=dirs[0]=trmdir(copy(nfil));
		sayline(START);
		/* save current contents of buffer */
		while (!eob(p)) p=unfill(p);
		inctop[ifno]=mactop;
	}
	return(p);
}

equfrm(a,p1,p2) register char *a,*p1,*p2; {
	register char c; int flag;
	c= *p2; *p2='\0';
	flag=strcmp(a,p1); *p2=c; return(flag==SAME);
}

char *
dodef(p) char *p; {/* process '#define' */
	register char *pin,*psav,*cf;
	char **pf,**qf; int b,c,params; struct symtab *np;
	char *oldval;
	char *space, *newspace;
	char *formal[MAXFRM]; /* formal[n] is name of nth formal */
	char formtxt[BUFSIZ]; /* space for formal names */
	int opt_passcom=passcom;

	passcom=0;	/* don't put comments in macro expansions */

	++flslvl; /* prevent macro expansion during 'define' */
	p=skipbl(p); pin=inp;
	if ((toktyp+COFF)[*pin]!=IDENT) {
		ppwarn("illegal macro name"); while (*inp!='\n') p=skipbl(p);
		passcom=opt_passcom; return(p);
	}
	np=slookup(pin,p,1);
	if (oldval=np->value) free(lastcopy);	/* was previously defined */
	b=1; cf=pin;
	while (cf<p) {/* update macbit */
		c= *cf++; xmac1(c,b,|=); b=(b+b)&0xFF;
		if (cf!=p) xmac2(c,*cf,-1+(cf-pin),|=);
		else xmac2(c,0,-1+(cf-pin),|=);
	}
	params=0; outp=inp=p; p=cotoken(p); pin=inp;
	if (*pin=='(') {/* with parameters; identify the formals */
		cf=formtxt; pf=formal;
		for (;;) {
			p=skipbl(p); pin=inp;
			if (*pin=='\n') {
				--lineno[ifno]; --p; pperror("%s: missing )",np->name); break;
			}
			if (*pin==')') break;
			if (*pin==',') continue;
			if ((toktyp+COFF)[*pin]!=IDENT) {
				c= *p; *p='\0'; pperror("bad formal: %s",pin); *p=c;
			} else if (pf>= &formal[MAXFRM]) {
				c= *p; *p='\0'; pperror("too many formals: %s",pin); *p=c;
d1176 22
a1197 1
				*pf++=cf; while (pin<p) *cf++= *pin++; *cf++='\0'; ++params;
d1199 5
d1205 170
a1374 21
		if (params==0) --params; /* #define foo() ... */
	} else if (*pin=='\n') {--lineno[ifno]; --p;}
	/* remember beginning of macro body, so that we can
	/* warn if a redefinition is different from old value.
	*/
	space=psav=malloc(BUFSIZ);
	if (space==NULL) {
		pperror("too much defining");
		passcom=opt_passcom;
		return(p);
	}
	*psav++ = '\0';
	for (;;) {/* accumulate definition until linefeed */
		outp=inp=p; p=cotoken(p); pin=inp;
		if (*pin=='\\' && pin[1]=='\n') {putc('\n',fout); continue;}	/* ignore escaped lf */
		if (*pin=='\n') break;
		if (params) {/* mark the appearance of formals in the definiton */
			if ((toktyp+COFF)[*pin]==IDENT) {
				for (qf=pf; --qf>=formal; ) {
					if (equfrm(*qf,pin,p)) {
						*psav++=qf-formal+1; *psav++=WARN; pin=p; break;
d1376 1
d1378 6
a1383 15
			} else if (*pin=='"' || *pin=='\''
# if gcos
					|| *pin=='`'
# endif
						) {/* inside quotation marks, too */
				char quoc= *pin;
				for (*psav++= *pin++; pin<p && *pin!=quoc; ) {
					while (pin<p && !isid(*pin)) *psav++= *pin++;
					cf=pin; while (cf<p && isid(*cf)) ++cf;
					for (qf=pf; --qf>=formal; ) {
						if (equfrm(*qf,pin,cf)) {
							*psav++=qf-formal+1; *psav++=WARN; pin=cf; break;
						}
					}
					while (pin<cf) *psav++= *pin++;
d1385 2
d1388 3
a1390 2
		}
		while (pin<p) *psav++= *pin++;
d1392 43
a1434 17
	*psav++=params; *psav++='\0';
	if ((cf=oldval)!=NULL) {/* redefinition */
		--cf;	/* skip no. of params, which may be zero */
		while (*--cf);	/* go back to the beginning */
		if (0!=strcmp(++cf,space+1)) {/* redefinition different from old */
			--lineno[ifno]; ppwarn("%s redefined",np->name); ++lineno[ifno];
			np->value=psav-1;
		} else free(space); /* identical redef.; reclaim space */
	} else np->value=psav-1;
	--flslvl; inp=pin;
	if (np->value == psav-1) {
		newspace = realloc(space, psav-space);
		if (newspace==NULL) {pperror("no space"); exit(exfail);}
		/*
		 * Adjust pointer in case this moved.
		 */
		np->value += newspace-space;
a1435 2
	passcom=opt_passcom;
	return(p);
d1438 17
a1454 2
#define fasscan() ptrtab=fastab+COFF
#define sloscan() ptrtab=slotab+COFF
d1456 6
a1461 86
char *
control(p) register char *p; {/* find and handle preprocessor control lines */
	register struct symtab *np;
for (;;) {
	fasscan(); p=cotoken(p); if (*inp=='\n') ++inp; dump();
	sloscan(); p=skipbl(p);
	*--inp=SALT; outp=inp; ++flslvl; np=slookup(inp,p,0); --flslvl;
	if (np==defloc) {/* define */
		if (flslvl==0) {p=dodef(p); continue;}
	} else if (np==incloc) {/* include */
		if (flslvl==0) {p=doincl(p); continue;}
	} else if (np==ifnloc) {/* ifndef */
		++flslvl; p=skipbl(p); np=slookup(inp,p,0); --flslvl;
		if (flslvl==0 && np->value==0) ++trulvl;
		else ++flslvl;
	} else if (np==ifdloc) {/* ifdef */
		++flslvl; p=skipbl(p); np=slookup(inp,p,0); --flslvl;
		if (flslvl==0 && np->value!=0) ++trulvl;
		else ++flslvl;
	} else if (np==eifloc) {/* endif */
		if (flslvl) {if (--flslvl==0) sayline(CONT);}
		else if (trulvl) --trulvl;
		else pperror("If-less endif",0);
	} else if (np==elsloc) {/* else */
		if (flslvl) {
			if (--flslvl!=0) ++flslvl;
			else {++trulvl; sayline(CONT);}
		}
		else if (trulvl) {++flslvl; --trulvl;}
		else pperror("If-less else",0);
	} else if (np==udfloc) {/* undefine */
		if (flslvl==0) {
			++flslvl; p=skipbl(p); slookup(inp,p,DROP); --flslvl;
		}
	} else if (np==ifloc) {/* if */
#if tgp
		pperror(" IF not implemented, true assumed", 0);
		if (flslvl==0) ++trulvl; else ++flslvl;
#else
		newp=p;
		if (flslvl==0 && yyparse()) ++trulvl; else ++flslvl;
		p=newp;
#endif
	} else if (np==lneloc) {/* line */
		if (flslvl==0 && pflag==0) {
			char *savestring();
			char filename[BUFSIZ], *cp = filename;
			outp=inp=p; *--outp='#';
			/* Find the line number.. */
			do {
				p = cotoken(p);
			} while (!isnum(*inp) && *inp != '\n');
			if (isnum(*inp))
				lineno[ifno] = atoi(inp)-1;
			/* Skip over the blank token */
			inp = p;
			if (*inp != '\n') {
				p = cotoken(p); inp = p;
			}
			/* Add a quote if missing..  */
			if (*inp != '\n') {
				p = cotoken(p);
				/* Add a quote if missing..  */
				if (*inp == '"')
					inp++;
				else {
					dump();
					*--outp = '"';
				}
				while (*inp != '\n') {
					while (inp < p && *inp != '"' &&
						cp < filename+sizeof(filename))
						*cp++ = *inp++;
					if (*inp == '"')
						break;
					inp = p; p = cotoken(p);
				}
				fnames[ifno] = savestring(filename, cp);
				/* Add a quote if missing..  */
				if (*inp != '"') {
					dump();
					*--outp = '"';
				}
			}
			while (*inp != '\n')
				p = cotoken(p);
d1464 4
a1467 7
	} else if (np==identloc) {/* ident (for Sys 5r3 compat) */
		while(*inp!='\n') p=cotoken(p);
	} else if (*++inp=='\n') outp=inp;	/* allows blank line after # */
	else pperror("undefined control",0);
	/* flush to lf */
	++flslvl; while (*inp!='\n') {outp=inp=p; p=cotoken(p);} --flslvl;
}
d1470 19
a1488 13
char *
savestring(start, finish)
	register char *start, *finish;
{
	char *retbuf;
	register char *cp;

	retbuf = (char *) calloc(finish - start + 1, sizeof (char));
	cp = retbuf;
	while (start < finish)
		*cp++ = *start++;
	*cp = 0;
	return(retbuf);
d1491 9
a1499 3
struct symtab *
stsym(s) register char *s; {
	char buf[BUFSIZ]; register char *p;
d1501 23
a1523 8
	/* make definition look exactly like end of #define line */
	/* copy to avoid running off end of world when param list is at end */
	p=buf; while (*p++= *s++);
	p=buf; while (isid(*p++)); /* skip first identifier */
	if (*--p=='=') {*p++=' '; while (*p++);}
	else {s=" 1"; while (*p++= *s++);}
	pend=p; *--p='\n';
	sloscan(); dodef(buf); return(lastsym);
d1526 4
a1529 40
struct symtab *
ppsym(s) char *s; {/* kluge */
	register struct symtab *sp;
	register char *name;
	size_t len;

	cinit=SALT; sp=stsym(s);
	len = strlen(sp->name) + 2;
	name = malloc(len);
	name[0] = '#';
	name[1] = '\0';
	strlcat(name, sp->name, len);
	sp->name = name;
	cinit=0; return(sp);
}

/* VARARGS1 */
pperror(s,x,y) char *s; {
	if (fnames[ifno][0]) fprintf(stderr,
# if gcos
			"*%c*   \"%s\", line ", exfail >= 0 ? 'F' : 'W',
# else
			"%s: ",
# endif
				 fnames[ifno]);
	fprintf(stderr, "%d: ",lineno[ifno]);
	fprintf(stderr, s, x, y);
	fprintf(stderr,"\n");
	++exfail;
}

yyerror(s,a,b) char *s; {
	pperror(s,a,b);
}

ppwarn(s,x) char *s; {
	int fail = exfail;
	exfail = -1;
	pperror(s,x);
	exfail = fail;
d1532 38
a1569 3
struct symtab *
lookup(namep, enterf)
char *namep;
d1571 10
a1580 21
	register char *np, *snp;
	register int c, i; int around;
	register struct symtab *sp;

	/* namep had better not be too long (currently, <=NCPS chars) */
	np=namep; around=0; i=cinit;
	while (c= *np++) i += i+c; c=i;	/* c=i for register usage on pdp11 */
	c %= symsiz; if (c<0) c += symsiz;
	sp = &stab[c];
	while (snp=sp->name) {
		np = namep;
		while (*snp++ == *np) if (*np++ == '\0') {
				if (enterf==DROP) {sp->name[0]= DROP; sp->value=0;}
				return(lastsym=sp);
			}
		if (--sp < &stab[0])
			if (around) {pperror("too many defines", 0); exit(exfail);}
			else {++around; sp = &stab[symsiz-1];}
	}
	if (enterf==1) sp->name=namep;
	return(lastsym=sp);
d1583 4
d1588 35
a1622 88
slookup(p1,p2,enterf) register char *p1,*p2; int enterf;{
	register char *p3; char c2,c3; struct symtab *np;
	         c2= *p2; *p2='\0';	/* mark end of token */
	if ((p2-p1)>NCPS) p3=p1+NCPS; else p3=p2;
			 c3= *p3; *p3='\0';	/* truncate to NCPS chars or less */
	if (enterf==1) p1=copy(p1);
	np=lookup(p1,enterf); *p3=c3; *p2=c2;
	if (np->value!=0 && flslvl==0) newp=subst(p2,np);
	else newp=0;
	return(np);
}

char *
subst(p,sp) register char *p; struct symtab *sp; {
	static char match[]="%s: argument mismatch";
	register char *ca,*vp; int params;
	char *actual[MAXFRM]; /* actual[n] is text of nth actual   */
	char actused[MAXFRM]; /* for newline processing in actuals */
	char acttxt[BUFSIZ];  /* space for actuals */
	int  nlines = 0;

	if (0==(vp=sp->value)) return(p);
	if ((p-macforw)<=macdam) {
		if (++maclvl>symsiz && !rflag) {
			pperror("%s: macro recursion",sp->name); return(p);
		}
	} else maclvl=0;	/* level decreased */
	macforw=p; macdam=0;	/* new target for decrease in level */
	macnam=sp->name;
	dump();
	if (sp==ulnloc) {
		vp=acttxt; *vp++='\0';
		(void)snprintf(vp,BUFSIZ,"%d",lineno[ifno]); while (*vp++);
	} else if (sp==uflloc) {
		vp=acttxt; *vp++='\0';
		(void)snprintf(vp,BUFSIZ,"\"%s\"",fnames[ifno]); while (*vp++);
	}
	if (0!=(params= *--vp&0xFF)) {/* definition calls for params */
		register char **pa;
		ca=acttxt; pa=actual;
		if (params==0xFF) params=1;	/* #define foo() ... */
		sloscan(); ++flslvl; /* no expansion during search for actuals */
		plvl= -1;
		do p=skipbl(p); while (*inp=='\n');	/* skip \n too */
		if (*inp=='(') {
			maclin=lineno[ifno]; macfil=fnames[ifno];
			for (plvl=1; plvl!=0; ) {
				*ca++='\0';
				for (;;) {
					outp=inp=p; p=cotoken(p);
					if (*inp=='(') ++plvl;
					if (*inp==')' && --plvl==0) {--params; break;}
					if (plvl==1 && *inp==',') {--params; break;}
					while (inp<p) *ca++= *inp++;
					if (ca> &acttxt[BUFSIZ])
						pperror("%s: actuals too long",sp->name);
				}
				if (pa>= &actual[MAXFRM]) ppwarn(match,sp->name);
				else { actused[pa-actual]=0; *pa++=ca; }
			}
			nlines = lineno[ifno] - maclin;
			lineno[ifno] = maclin; /* don't count newlines here */
		}
		if (params!=0) ppwarn(match,sp->name);
		while (--params>=0) *pa++=""+1;	/* null string for missing actuals */
		--flslvl; fasscan();
	}
	for (;;) {/* push definition onto front of input stack */
		while (!iswarn(*--vp)) {
			if (bob(p)) {outp=inp=p; p=unfill(p);}
			*--p= *vp;
		}
		if (*vp==warnc) {/* insert actual param */
			ca=actual[*--vp-1];
			while (*--ca) {
				if (bob(p)) {outp=inp=p; p=unfill(p);}
				/* Actuals with newlines confuse line numbering */
				if (*ca == '\n' && actused[*vp-1])
					if (*(ca-1) == '\\') ca--;
					else *--p = ' ';
				else { *--p= *ca; if (*ca == '\n') nlines--; }
			}
			actused[*vp-1] = 1;
		} else {
			if (nlines > 0 )
				while (nlines-- > 0)
					*--p = '\n';
			break;
a1624 3
	outp=inp=p;
	return(p);
}
d1626 4
d1631 8
d1640 2
d1643 17
a1659 10
char *
trmdir(s) register char *s; {
	register char *p = s;
	while (*p++); --p; while (p>s && *--p!='/');
# if unix
	if (p==s) *p++='.';
# endif
	*p='\0';
	return(s);
}
d1661 15
a1675 3
STATIC char *
copy(s) register char *s; {
	register char *old;
d1677 10
a1686 4
	old = malloc(strlen(s)+1);
	if (old==NULL) {pperror("no space"); exit(exfail);}
	strlcpy(old, s, strlen(s)+1);
	return(lastcopy=old);
d1689 10
a1698 4
char *
strdex(s,c) char *s,c; {
	while (*s) if (*s++==c) return(--s);
	return(0);
d1701 2
a1702 4
yywrap(){ return(1); }

main(argc,argv)
	char *argv[];
d1704 1
a1704 3
	register int i,c;
	register char *p;
	char *tf,**cp2;
d1706 15
a1720 14
# if gcos
	if (setjmp(env)) return (exfail);
# endif
	p="_$ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
		i=0;
		while (c= *p++) {
			(fastab+COFF)[c] |= IB|NB|SB; (toktyp+COFF)[c]=IDENT;
#if scw2
			/* 53 == 63-10; digits rarely appear in identifiers,
			/* and can never be the first char of an identifier.
			/* 11 == 53*53/sizeof(macbit) .
			*/
			++i; (t21+COFF)[c]=(53*i)/11; (t22+COFF)[c]=i%11;
#endif
d1722 4
a1725 188
	p="0123456789.";
		while (c= *p++) {(fastab+COFF)[c] |= NB|SB; (toktyp+COFF)[c]=NUMBR;}
# if gcos
	p="\n\"'`/\\";
# else
	p="\n\"'/\\";
# endif
		while (c= *p++) (fastab+COFF)[c] |= SB;
# if gcos
	p="\n\"'`\\";
# else
	p="\n\"'\\";
# endif
		while (c= *p++) (fastab+COFF)[c] |= QB;
	p="*\n"; while (c= *p++) (fastab+COFF)[c] |= CB;
	(fastab+COFF)[warnc] |= WB;
	(fastab+COFF)['\0'] |= CB|QB|SB|WB;
	for (i=ALFSIZ; --i>=0; ) slotab[i]=fastab[i]|SB;
	p=" \t\013\f\r";	/* note no \n;	\v not legal for vertical tab? */
		while (c= *p++) (toktyp+COFF)[c]=BLANK;
#if scw2
	for ((t23+COFF)[i=ALFSIZ+7-COFF]=1; --i>=-COFF; )
		if (((t23+COFF)[i]=(t23+COFF+1)[i]<<1)==0) (t23+COFF)[i]=1;
#endif

# if unix
	fnames[ifno=0] = ""; dirnams[0]=dirs[0]=".";
# endif
# if ibm
	fnames[ifno=0] = "";
# endif
# if gcos
	if (inquire(stdin, _TTY)) freopen("*src", "rt", stdin);
# endif
# if gimpel || gcos
	fnames[ifno=0] = (char *)inquire(stdin, _FILENAME);
	dirnams[0] = dirs[0] = trmdir(copy(fnames[0]));
# endif
	for(i=1; i<argc; i++)
		{
		switch(argv[i][0])
			{
			case '-':
# if gcos
			switch(toupper(argv[i][1])) { /* case-independent on GCOS */
# else
			switch(argv[i][1]) {
# endif
				case 'M': mflag++;
				case 'P': pflag++;
				case 'E': continue;
				case 'R': ++rflag; continue;
				case 'C': passcom++; continue;
				case 'D':
					if (predef>prespc+NPREDEF) {
						pperror("too many -D options, ignoring %s",argv[i]);
						continue;
					}
					/* ignore plain "-D" (no argument) */
					if (*(argv[i]+2)) *predef++ = argv[i]+2;
					continue;
				case 'U':
					if (prund>punspc+NPREDEF) {
						pperror("too many -U options, ignoring %s",argv[i]);
						continue;
					}
					*prund++ = argv[i]+2;
					continue;
				case 'I':
					if (nd>8) pperror("excessive -I file (%s) ignored",argv[i]);
					else dirs[nd++] = argv[i]+2;
					continue;
				case 't':
				case '\0':
					continue;
				case 'u':
					++uflag;
					continue;
				default: 
					pperror("unknown flag %s", argv[i]);
					continue;
				}
			default:
				if (fin==FIRSTOPEN) {
					if (0>(fin=open(argv[i], READ))) {
						pperror("No source file %s",argv[i]); exit(8);
					}
					fnames[ifno]=copy(argv[i]);
					infile=copy(argv[i]);
					dirs[0]=dirnams[ifno]=trmdir(argv[i]);
# ifndef gcos
/* too dangerous to have file name in same syntactic position
   be input or output file depending on file redirections,
   so force output to stdout, willy-nilly
	[i don't see what the problem is.  jfr]
*/
				} else if (fout==stdout) {
					if (NULL==(fout=fopen(argv[i], "w"))) {
						pperror("Can't create %s", argv[i]); exit(8);
					} else fclose(stdout);
# endif
				} else pperror("extraneous name %s", argv[i]);
			}
		}
	if (fin == FIRSTOPEN)
		fin = STDIN;

	if (mflag) {
		if (infile==(char *)0) {
			fprintf(stderr,
				"no input file specified with -M flag\n");
			exit(8);
		}
		tf=(char *)rindex(infile, '.');
		if (tf==0) {
			fprintf(stderr, "missing component name on %s\n",
				infile);
			exit(8);
		}
		tf[1]='o';
		tf=(char *)rindex(infile, '/');
		if (tf!=(char *)0)
			infile = tf + 1;
		mout=fout;
		if (NULL==(fout=fopen(_PATH_DEVNULL, "w"))) {
			fprintf(stderr, "cpp: can't open %s\n", _PATH_DEVNULL);
			exit(8);
		}
	}
	fins[ifno]=fin;
	exfail = 0;
		/* after user -I files here are the standard include libraries */
#if defined(__MirBSD__)
	dirs[nd++] = "/usr/include";
#else
# if unix
	dirs[nd++] = _PATH_INCLUDES;
# endif
# if gcos
	dirs[nd++] = "cc/include";
# endif
# if ibm
# ifndef gimpel
	dirs[nd++] = "BTL$CLIB";
# endif
# endif
# ifdef gimpel
	dirs[nd++] = intss() ?  "SYS3.C." : "" ;
# endif
#endif
	/* dirs[nd++] = "/compool"; */
	dirs[nd++] = 0;
	defloc=ppsym("define");
	udfloc=ppsym("undef");
	incloc=ppsym("include");
	elsloc=ppsym("else");
	eifloc=ppsym("endif");
	ifdloc=ppsym("ifdef");
	ifnloc=ppsym("ifndef");
	ifloc=ppsym("if");
	lneloc=ppsym("line");
	identloc=ppsym("ident");	/* Sys 5r3 compatibility */
	for (i=sizeof(macbit)/sizeof(macbit[0]); --i>=0; ) macbit[i]=0;
	if (!uflag) {
# if unix
		ysysloc=stsym("unix");
# endif
		ysysloc=stsym(MACHINE);
	}
	ulnloc=stsym ("__LINE__");
	uflloc=stsym ("__FILE__");

	tf=fnames[ifno]; fnames[ifno]="command line"; lineno[ifno]=1;
	cp2=prespc;
	while (cp2<predef) stsym(*cp2++);
	cp2=punspc;
	while (cp2<prund) {
		if (p=strdex(*cp2, '=')) *p++='\0';
		lookup(*cp2++, DROP);
	}
	fnames[ifno]=tf;
	pbeg=buffer+NCPS; pbuf=pbeg+BUFSIZ; pend=pbuf+BUFSIZ;

	trulvl = 0; flslvl = 0;
	lineno[0] = 1; sayline(START);
	outp=inp=pend;
	control(pend);
	return (exfail);
@


1.4.4.1
log
@raise number of -D arguments allowed on command line,
makes Reiser CCCP suitable for use with xrdb(1)… in
contrast to pcc cpp…
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/libexec/cpp/cpp.c,v 1.4 2007/08/24 14:20:04 tg Exp $");
d169 1
a169 1
# define NPREDEF 130
@


1.4.4.2
log
@-CC support for Reiser CCCP
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/libexec/cpp/cpp.c,v 1.4.4.1 2008/11/20 15:18:24 tg Exp $");
d158 1
a158 1
int	passcom;	/* &1=don't delete comments &2=even in macros */
d652 1
a652 2
	if (!(passcom & 2))
		passcom=0;	/* don't put comments in macro expansions */
d1150 1
a1150 3
				case 'C':
					passcom = argv[i][2] == 'C' ? 3 : 1;
					continue;
@


1.3
log
@add -undef (well, -u here) flag
will be needed for X11 soonish
@
text
@d8 1
d11 1
d16 1
a16 1
__RCSID("$MirOS: src/libexec/cpp/cpp.c,v 1.2 2005/03/06 19:23:59 tg Exp $");
d212 2
a213 2
sayline(where)
	int where;
d272 2
a273 1
dump() {
@


1.2
log
@merge src/libexec
@
text
@d14 1
a14 1
__RCSID("$MirOS$");
d160 1
d1170 3
d1258 1
d1260 1
a1260 1
	ysysloc=stsym("unix");
d1262 2
a1263 1
	ysysloc=stsym(MACHINE);
@


1.1
log
@Initial revision
@
text
@a0 4
#ifndef lint
static char sccsid[] = "@@(#)cpp.c	1.22 11/7/90";
#endif lint

d9 1
d11 4
a14 1
#include "pathnames.h"
a118 2
char *malloc(), *realloc();

d602 1
a602 1
				|| **dirp=='\0') strcpy(nfil,filname);
d604 1
a604 1
			strcpy(nfil,*dirp);
d606 1
a606 1
			strcat(nfil,"/");
d610 1
a610 1
			strcat(nfil,".");
d613 1
a613 1
			strcat(nfil,filname);
d880 1
d882 7
a888 2
	cinit=SALT; sp=stsym(s); name = malloc(strlen(sp->name)+1+1);
	name[0] = '#'; strcpy(name+1, sp->name); sp->name = name;
d978 1
a978 1
		(void)sprintf(vp,"%d",lineno[ifno]); while (*vp++);
d981 1
a981 1
		(void)sprintf(vp,"\"%s\"",fnames[ifno]); while (*vp++);
d1060 1
a1060 1
	strcpy(old, s);
d1166 3
a1168 1
				case '\0': continue;
d1223 3
d1240 1
@


1.1.121.1
log
@somewhat C99 capable cpp from pcc
@
text
@d1 3
a3 1
/*	$Id: cpp.c,v 1.93 2008/08/18 20:50:43 ragge Exp $	*/
d5 4
a8 70
/*
 * Copyright (c) 2004 Anders Magnusson (ragge@@ludd.luth.se).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright(C) Caldera International Inc. 2001-2002. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * Redistributions of source code and documentation must retain the above
 * copyright notice, this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 * 	This product includes software developed or owned by Caldera
 *	International, Inc.
 * Neither the name of Caldera International, Inc. nor the names of other
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * USE OF THE SOFTWARE PROVIDED FOR UNDER THIS LICENSE BY CALDERA
 * INTERNATIONAL, INC. AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL CALDERA INTERNATIONAL, INC. BE LIABLE
 * FOR ANY DIRECT, INDIRECT INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OFLIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * The C preprocessor.
 * This code originates from the V6 preprocessor with some additions
 * from V7 cpp, and at last ansi/c99 support.
 */

#include "config.h"

#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
d11 1
a11 4
#include <fcntl.h>
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
a12 4
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
d14 18
d33 9
a41 15
#include "compat.h"
#include "cpp.h"
#include "y.tab.h"

#define	MAXARG	250	/* # of args to a macro, limited by char value */
#define	SBSIZE	600000

static usch	sbf[SBSIZE];
/* C command */

int tflag;	/* traditional cpp syntax */
#ifdef CPP_DEBUG
int dflag;	/* debug printouts */
#define	DPRINT(x) if (dflag) printf x
#define	DDPRINT(x) if (dflag > 1) printf x
d43 1
a43 2
#define DPRINT(x)
#define DDPRINT(x)
d46 31
a76 1
#define	GCC_VARI
d78 3
a80 30
int ofd;
usch outbuf[CPPBUF];
int obufp, istty, inmac;
int Cflag, Mflag, dMflag, Pflag;
usch *Mfile;
struct initar *initar;
int readmac;

/* avoid recursion */
struct recur {
	struct recur *next;
	struct symtab *sp;
};

/* include dirs */
struct incs {
	struct incs *next;
	usch *dir;
} *incdir[2];
#define	INCINC 0
#define	SYSINC 1

static struct symtab *filloc;
static struct symtab *linloc;
static struct symtab *pragloc;
int	trulvl;
int	flslvl;
int	elflvl;
int	elslvl;
usch *stringbuf = sbf;
d82 10
a91 40
/*
 * Macro replacement list syntax:
 * - For object-type macros, replacement strings are stored as-is.
 * - For function-type macros, macro args are substituted for the
 *   character WARN followed by the argument number.
 * - The value element points to the end of the string, to simplify
 *   pushback onto the input queue.
 * 
 * The first character (from the end) in the replacement list is
 * the number of arguments:
 *   VARG  - ends with ellipsis, next char is argcount without ellips.
 *   OBJCT - object-type macro
 *   0 	   - empty parenthesis, foo()
 *   1->   - number of args.
 */

#define	GCCARG	0xfd	/* has gcc varargs that may be replaced with 0 */
#define	VARG	0xfe	/* has varargs */
#define	OBJCT	0xff
#define	WARN	1	/* SOH, not legal char */
#define	CONC	2	/* STX, not legal char */
#define	SNUFF	3	/* ETX, not legal char */
#define	NOEXP	4	/* EOT, not legal char */
#define	EXPAND	5	/* ENQ, not legal char */
#define	PRAGS	6	/* start of converted pragma */
#define	PRAGE	14	/* end of converted pragma */

/* args for lookup() */
#define	FIND	0
#define	ENTER	1

static void expdef(usch *proto, struct recur *, int gotwarn);
void define(void);
static int canexpand(struct recur *, struct symtab *np);
void include(void);
void line(void);
void flbuf(void);
void usage(void);
usch *xstrdup(char *str);
usch *prtprag(usch *opb);
d93 47
d141 2
a142 52
int
main(int argc, char **argv)
{
	struct initar *it;
	struct incs *w, *w2;
	struct symtab *nl;
	register int ch;

	while ((ch = getopt(argc, argv, "CD:I:MPS:U:d:i:tvV?")) != -1)
		switch (ch) {
		case 'C': /* Do not discard comments */
			Cflag++;
			break;

		case 'i': /* include */
		case 'U': /* undef */
		case 'D': /* define something */
			/* XXX should not need malloc() here */
			if ((it = malloc(sizeof(struct initar))) == NULL)
				error("couldn't apply -%c %s", ch, optarg);
			it->type = ch;
			it->str = optarg;
			it->next = initar;
			initar = it;
			break;

		case 'M': /* Generate dependencies for make */
			Mflag++;
			break;

		case 'P': /* Inhibit generation of line numbers */
			Pflag++;
			break;

		case 'S':
		case 'I':
			if ((w = calloc(sizeof(struct incs), 1)) == NULL)
				error("couldn't apply -%c %s", ch, optarg);
			w->dir = (usch *)optarg;
			w2 = incdir[ch == 'I' ? INCINC : SYSINC];
			if (w2 != NULL) {
				while (w2->next)
					w2 = w2->next;
				w2->next = w;
			} else
				incdir[ch == 'I' ? INCINC : SYSINC] = w;
			break;

#ifdef CPP_DEBUG
		case 'V':
			dflag++;
			break;
a143 10
		case 'v':
			printf("cpp: %s\n", VERSSTR);
			break;
		case 'd':
			if (optarg[0] == 'M') {
				dMflag = 1;
				Mflag = 1;
			}
			/* ignore others */
			break;
d145 65
a209 3
		case 't':
			tflag = 1;
			break;
d211 5
a215 70
		case '?':
			usage();
		default:
			error("bad arg %c\n", ch);
		}
	argc -= optind;
	argv += optind;

	filloc = lookup((usch *)"__FILE__", ENTER);
	linloc = lookup((usch *)"__LINE__", ENTER);
	pragloc = lookup((usch *)"_Pragma", ENTER);
	filloc->value = linloc->value = (usch *)""; /* Just something */
	pragloc->value = (usch *)"";

	if (tflag == 0) {
		time_t t = time(NULL);
		usch *n = (usch *)ctime(&t);

		/*
		 * Manually move in the predefined macros.
		 */
		nl = lookup((usch *)"__TIME__", ENTER);
		savch(0); savch('"');  n[19] = 0; savstr(&n[11]); savch('"');
		savch(OBJCT);
		nl->value = stringbuf-1;

		nl = lookup((usch *)"__DATE__", ENTER);
		savch(0); savch('"'); n[24] = n[11] = 0; savstr(&n[4]);
		savstr(&n[20]); savch('"'); savch(OBJCT);
		nl->value = stringbuf-1;

		nl = lookup((usch *)"__STDC__", ENTER);
		savch(0); savch('1'); savch(OBJCT);
		nl->value = stringbuf-1;

		nl = lookup((usch *)"__STDC_VERSION__", ENTER);
		savch(0); savstr((usch *)"199901L"); savch(OBJCT);
		nl->value = stringbuf-1;
	}

	if (Mflag && !dMflag) {
		usch *c;

		if (argc < 1)
			error("-M and no infile");
		if ((c = (usch *)strrchr(argv[0], '/')) == NULL)
			c = (usch *)argv[0];
		else
			c++;
		Mfile = stringbuf;
		savstr(c); savch(0);
		if ((c = (usch *)strrchr((char *)Mfile, '.')) == NULL)
			error("-M and no extension: ");
		c[1] = 'o';
		c[2] = 0;
	}

	if (argc == 2) {
		if ((ofd = open(argv[1], O_WRONLY|O_CREAT, 0600)) < 0)
			error("Can't creat %s", argv[1]);
	} else
		ofd = 1; /* stdout */
	istty = isatty(ofd);

	if (pushfile((usch *)(argc && strcmp(argv[0], "-") ? argv[0] : NULL)))
		error("cannot open %s", argv[0]);

	flbuf();
	close(ofd);
	return 0;
d218 47
d266 24
a289 31
 * Expand the symbol nl read from input.
 * Return a pointer to the fully expanded result.
 * It is the responsibility of the caller to reset the heap usage.
 */
usch *
gotident(struct symtab *nl)
{
	struct symtab *thisnl;
	usch *osp, *ss2, *base;
	int c;

	thisnl = NULL;
	slow = 1;
	readmac++;
	base = osp = stringbuf;
	goto found;

	while ((c = yylex()) != 0) {
		switch (c) {
		case IDENT:
			if (flslvl)
				break;
			osp = stringbuf;

			DPRINT(("IDENT0: %s\n", yytext));
			nl = lookup((usch *)yytext, FIND);
			if (nl == 0 || thisnl == 0)
				goto found;
			if (thisnl == nl) {
				nl = 0;
				goto found;
d291 57
a347 18
			ss2 = stringbuf;
			if ((c = yylex()) == WSPACE) {
				savstr((usch *)yytext);
				c = yylex();
			}
			if (c != EXPAND) {
				unpstr((usch *)yytext);
				if (ss2 != stringbuf)
					unpstr(ss2);
				unpstr(nl->namep);
				(void)yylex(); /* get yytext correct */
				nl = 0; /* ignore */
			} else {
				thisnl = NULL;
				if (nl->value[0] == OBJCT) {
					unpstr(nl->namep);
					(void)yylex(); /* get yytext correct */
					nl = 0;
d349 6
d356 1
a356 48
			stringbuf = ss2;

found:			if (nl == 0 || subst(nl, NULL) == 0) {
				if (nl)
					savstr(nl->namep);
				else
					savstr((usch *)yytext);
			} else if (osp != stringbuf) {
				DPRINT(("IDENT1: unput osp %p stringbuf %p\n",
				    osp, stringbuf));
				ss2 = stringbuf;
				cunput(EXPAND);
				while (ss2 > osp)
					cunput(*--ss2);
				thisnl = nl;
				stringbuf = osp; /* clean up heap */
			}
			break;

		case EXPAND:
			DPRINT(("EXPAND!\n"));
			thisnl = NULL;
			break;

		case CMNT:
			getcmnt();
			break;

		case STRING:
		case '\n':
		case NUMBER:
		case FPOINT:
		case WSPACE:
			savstr((usch *)yytext);
			break;

		default:
			if (c < 256)
				savch(c);
			else
				savstr((usch *)yytext);
			break;
		}
		if (thisnl == NULL) {
			slow = 0;
			readmac--;
			savch(0);
			return base;
a358 3
	error("premature EOF");
	/* NOTREACHED */
	return NULL; /* XXX gcc */
d361 2
a362 38
void
line()
{
	static usch *lbuf;
	static int llen;
	int c;

	slow = 1;
	if (yylex() != WSPACE)
		goto bad;
	if ((c = yylex()) != IDENT || !isdigit((int)yytext[0]))
		goto bad;
	ifiles->lineno = atoi(yytext);

	if ((c = yylex()) != '\n' && c != WSPACE)
		goto bad;
	if (c == '\n') {
		slow = 0;
		return;
	}
	if (yylex() != STRING || yytext[0] == 'L')
		goto bad;
	c = strlen((char *)yytext);
	if (llen < c) {
		/* XXX may loose heap space */
		lbuf = stringbuf;
		stringbuf += c;
		llen = c;
	}
	yytext[strlen(yytext)-1] = 0;
	if (strlcpy((char *)lbuf, &yytext[1], SBSIZE) >= SBSIZE)
		error("line exceeded buffer size");

	ifiles->fname = lbuf;
	if (yylex() != '\n')
		goto bad;
	slow = 0;
	return;
d364 4
a367 2
bad:	error("bad line directive");
}
d369 2
a370 18
/*
 * Include a file. Include order:
 * - For <...> files, first search -I directories, then system directories.
 * - For "..." files, first search "current" dir, then as <...> files.
 */
void
include()
{
	struct incs *w;
	struct symtab *nl;
	usch *osp;
	usch *fn, *safefn;
	int i, c, it;

	if (flslvl)
		return;
	osp = stringbuf;
	slow = 1;
d372 115
a486 53
	if ((c = yylex()) == WSPACE)
		c = yylex();
	if (c != STRING && c != '<' && c != IDENT)
		goto bad;

	if (c == IDENT) {
		if ((nl = lookup((usch *)yytext, FIND)) == NULL)
			goto bad;
		if (subst(nl, NULL) == 0)
			goto bad;
		savch('\0');
		unpstr(osp);
		goto again;
	} else if (c == '<') {
		fn = stringbuf;
		while ((c = yylex()) != '>' && c != '\n') {
			if (c == '\n')
				goto bad;
			savstr((usch *)yytext);
		}
		savch('\0');
		while ((c = yylex()) == WSPACE)
			;
		if (c != '\n')
			goto bad;
		it = SYSINC;
		safefn = fn;
	} else {
		usch *nm = stringbuf;

		yytext[strlen(yytext)-1] = 0;
		fn = (usch *)&yytext[1];
		/* first try to open file relative to previous file */
		/* but only if it is not an absolute path */
		if (*fn != '/') {
			savstr(ifiles->orgfn);
			if ((stringbuf =
			    (usch *)strrchr((char *)nm, '/')) == NULL)
				stringbuf = nm;
			else
				stringbuf++;
		}
		safefn = stringbuf;
		savstr(fn); savch(0);
		while ((c = yylex()) == WSPACE)
			;
		if (c != '\n')
			goto bad;
		slow = 0;
		if (pushfile(nm) == 0)
			return;
		/* XXX may loose stringbuf space */
	}
d488 8
a495 15
	/* create search path and try to open file */
	slow = 0;
	for (i = 0; i < 2; i++) {
		for (w = incdir[i]; w; w = w->next) {
			usch *nm = stringbuf;

			savstr(w->dir); savch('/');
			savstr(safefn); savch(0);
			if (pushfile(nm) == 0)
				return;
			stringbuf = nm;
		}
	}
	error("cannot find '%s'", safefn);
	/* error() do not return */
d497 29
a525 2
bad:	error("bad include");
	/* error() do not return */
d528 91
a618 27
static int
definp(void)
{
	int c;

	do
		c = yylex();
	while (c == WSPACE);
	return c;
}

void
getcmnt(void)
{
	int c;

	savstr((usch *)yytext);
	for (;;) {
		c = cinput();
		if (c == '*') {
			c = cinput();
			if (c == '/') {
				savstr((usch *)"*/");
				return;
			}
			cunput(c);
			c = '*';
a619 28
		savch(c);
	}
}

/*
 * Compare two replacement lists, taking in account comments etc.
 */
static int
cmprepl(usch *o, usch *n)
{
	for (; *o; o--, n--) {
		/* comment skip */
		if (*o == '/' && o[-1] == '*') {
			while (*o != '*' || o[-1] != '/')
				o--;
			o -= 2;
		}
		if (*n == '/' && n[-1] == '*') {
			while (*n != '*' || n[-1] != '/')
				n--;
			n -= 2;
		}
		while (*o == ' ' || *o == '\t')
			o--;
		while (*n == ' ' || *n == '\t')
			n--;
		if (*o != *n)
			return 1;
d621 48
a668 34
	return 0;
}

void
define()
{
	struct symtab *np;
	usch *args[MAXARG], *ubuf, *sbeg;
	int c, i, redef;
	int mkstr = 0, narg = -1;
	int ellips = 0;
#ifdef GCC_VARI
	usch *gccvari = NULL;
	int wascon;
#endif

	if (flslvl)
		return;
	slow = 1;
	if (yylex() != WSPACE || yylex() != IDENT)
		goto bad;

	if (isdigit((int)yytext[0]))
		goto bad;

	np = lookup((usch *)yytext, ENTER);
	redef = np->value != NULL;

	readmac = 1;
	sbeg = stringbuf;
	if ((c = yylex()) == '(') {
		narg = 0;
		/* function-like macros, deal with identifiers */
		c = definp();
d670 12
a681 7
			if (c == ')')
				break;
			if (c == ELLIPS) {
				ellips = 1;
				if (definp() != ')')
					goto bad;
				break;
d683 23
a705 11
			if (c == IDENT) {
				/* make sure there is no arg of same name */
				for (i = 0; i < narg; i++)
					if (!strcmp((char *) args[i], yytext))
						error("Duplicate macro "
						  "parameter \"%s\"", yytext);
				args[narg++] = xstrdup(yytext);
				if ((c = definp()) == ',') {
					if ((c = definp()) == ')')
						goto bad;
					continue;
d707 15
a721 6
#ifdef GCC_VARI
				if (c == ELLIPS) {
					if (definp() != ')')
						goto bad;
					gccvari = args[--narg];
					break;
a722 3
#endif
				if (c == ')')
					break;
a723 1
			goto bad;
d725 26
a750 40
		c = yylex();
	} else if (c == '\n') {
		/* #define foo */
		;
	} else if (c != WSPACE)
		goto bad;

	while (c == WSPACE)
		c = yylex();

	/* replacement list cannot start with ## operator */
	if (c == CONCAT)
		goto bad;

	/* parse replacement-list, substituting arguments */
	savch('\0');
	while (c != '\n') {
#ifdef GCC_VARI
		wascon = 0;
loop:
#endif
		switch (c) {
		case WSPACE:
			/* remove spaces if it surrounds a ## directive */
			ubuf = stringbuf;
			savstr((usch *)yytext);
			c = yylex();
			if (c == CONCAT) {
				stringbuf = ubuf;
				savch(CONC);
				if ((c = yylex()) == WSPACE)
					c = yylex();
#ifdef GCC_VARI
				if (c == '\n')
					break;
				wascon = 1;
				goto loop;
#endif
			}
			continue;
d752 38
a789 10
		case CONCAT:
			/* No spaces before concat op */
			savch(CONC);
			if ((c = yylex()) == WSPACE)
				c = yylex();
#ifdef GCC_VARI
			if (c == '\n')
				break;
			wascon = 1;
			goto loop;
d791 3
a793 1
			continue;
d795 39
a833 32

		case MKSTR:
			if (narg < 0) {
				/* no meaning in object-type macro */
				savch('#');
				break;
			}
			/* remove spaces between # and arg */
			savch(SNUFF);
			if ((c = yylex()) == WSPACE)
				c = yylex(); /* whitespace, ignore */
			mkstr = 1;
			if (c == VA_ARGS)
				continue;

			/* FALLTHROUGH */
		case IDENT:
			if (narg < 0)
				goto id; /* just add it if object */
			/* check if its an argument */
			for (i = 0; i < narg; i++)
				if (strcmp(yytext, (char *)args[i]) == 0)
					break;
			if (i == narg) {
#ifdef GCC_VARI
				if (gccvari &&
				    strcmp(yytext, (char *)gccvari) == 0) {
					savch(wascon ? GCCARG : VARG);
					savch(WARN);
					if (mkstr)
						savch(SNUFF), mkstr = 0;
					break;
a834 4
#endif
				if (mkstr)
					error("not argument");
				goto id;
d836 3
a838 22
			savch(i);
			savch(WARN);
			if (mkstr)
				savch(SNUFF), mkstr = 0;
			break;

		case VA_ARGS:
			if (ellips == 0)
				error("unwanted %s", yytext);
			savch(VARG);
			savch(WARN);
			if (mkstr)
				savch(SNUFF), mkstr = 0;
			break;

		case CMNT: /* save comments */
			getcmnt();
			break;

		default:
id:			savstr((usch *)yytext);
			break;
d840 7
a846 58
		c = yylex();
	}
	readmac = 0;
	/* remove trailing whitespace */
	while (stringbuf > sbeg) {
		if (stringbuf[-1] == ' ' || stringbuf[-1] == '\t')
			stringbuf--;
		/* replacement list cannot end with ## operator */
		else if (stringbuf[-1] == CONC)
			goto bad;
		else
			break;
	}
#ifdef GCC_VARI
	if (gccvari) {
		savch(narg);
		savch(VARG);
	} else
#endif
	if (ellips) {
		savch(narg);
		savch(VARG);
	} else
		savch(narg < 0 ? OBJCT : narg);
	if (redef) {
		if (cmprepl(np->value, stringbuf-1))
			error("%s redefined\nprevious define: %s:%d",
			    np->namep, np->file, np->line);
		stringbuf = sbeg;  /* forget this space */
	} else
		np->value = stringbuf-1;

#ifdef CPP_DEBUG
	if (dflag) {
		usch *w = np->value;

		printf("!define: ");
		if (*w == OBJCT)
			printf("[object]");
		else if (*w == VARG)
			printf("[VARG%d]", *--w);
		while (*--w) {
			switch (*w) {
			case WARN: printf("<%d>", *--w); break;
			case CONC: printf("<##>"); break;
			case SNUFF: printf("<\">"); break;
			default: putchar(*w); break;
			}
		}
		putchar('\n');
	}
#endif
	slow = 0;
	for (i = 0; i < narg; i++)
		free(args[i]);
	return;

bad:	error("bad define");
d849 13
a861 15
void
xwarning(usch *s)
{
	usch *t;
	usch *sb = stringbuf;

	flbuf();
	savch(0);
	if (ifiles != NULL) {
		t = sheap("%s:%d: warning: ", ifiles->fname, ifiles->lineno);
		write (2, t, strlen((char *)t));
	}
	write (2, s, strlen((char *)s));
	write (2, "\n", 1);
	stringbuf = sb;
d864 3
a866 4
void
xerror(usch *s)
{
	usch *t;
d868 8
a875 9
	flbuf();
	savch(0);
	if (ifiles != NULL) {
		t = sheap("%s:%d: error: ", ifiles->fname, ifiles->lineno);
		write (2, t, strlen((char *)t));
	}
	write (2, s, strlen((char *)s));
	write (2, "\n", 1);
	exit(1);
d878 34
a911 12
/*
 * store a character into the "define" buffer.
 */
void
savch(c)
{
	if (stringbuf-sbf < SBSIZE) {
		*stringbuf++ = c;
	} else {
		stringbuf = sbf; /* need space to write error message */
		error("Too much defining");
	} 
d914 3
a916 5
/*
 * convert _Pragma to #pragma for output.
 */
static void
pragoper(void)
d918 18
a935 19
	usch *opb;
	int t, plev;

	slow++;
	if ((t = yylex()) == WSPACE)
		t = yylex();
	if (t != '(')
		goto bad;
	if ((t = yylex()) == WSPACE)
		t = yylex();
	opb = stringbuf;
	for (plev = 0; ; t = yylex()) {
		if (t == '(')
			plev++;
		if (t == ')')
			plev--;
		if (plev < 0)
			break;
		savstr((usch *)yytext);
d937 2
a938 24

	savch(0);
	cunput(WARN);
	unpstr(opb);
	stringbuf = opb;
	expmac(NULL);
	cunput('\n');
	while (stringbuf > opb)
		cunput(*--stringbuf);
	savch(PRAGS);
	while ((t = yylex()) != '\n') {
		if (t == WSPACE)
			continue;
		if (t != STRING)
			goto bad;
		savstr((usch *)yytext);
	}

	savch(PRAGE);
	while (stringbuf > opb)
		cunput(*--stringbuf);
	slow--;
	return;
bad:	error("bad pragma operator");
d941 60
a1000 46
/*
 * substitute namep for sp->value.
 */
int
subst(sp, rp)
struct symtab *sp;
struct recur *rp;
{
	struct recur rp2;
	register usch *vp, *cp, *obp;
	int c, nl;

	DPRINT(("subst: %s\n", sp->namep));
	/*
	 * First check for special macros.
	 */
	if (sp == filloc) {
		(void)sheap("\"%s\"", ifiles->fname);
		return 1;
	} else if (sp == linloc) {
		(void)sheap("%d", ifiles->lineno);
		return 1;
	} else if (sp == pragloc) {
		pragoper();
		return 1;
	}
	vp = sp->value;

	rp2.next = rp;
	rp2.sp = sp;

	if (*vp-- != OBJCT) {
		int gotwarn = 0;

		/* should we be here at all? */
		/* check if identifier is followed by parentheses */

		obp = stringbuf;
		nl = 0;
		do {
			c = cinput();
			*stringbuf++ = c;
			if (c == WARN) {
				gotwarn++;
				if (rp == NULL)
					break;
d1002 2
a1003 28
			if (c == '\n')
				nl++;
		} while (c == ' ' || c == '\t' || c == '\n' || 
			    c == '\r' || c == WARN);

		DPRINT(("c %d\n", c));
		if (c == '(' ) {
			cunput(c);
			stringbuf = obp;
			ifiles->lineno += nl;
			expdef(vp, &rp2, gotwarn);
			return 1;
		} else {
	 		*stringbuf = 0;
			unpstr(obp);
			unpstr(sp->namep);
			if ((c = yylex()) != IDENT)
				error("internal sync error");
			stringbuf = obp;
			return 0;
		}
	} else {
		cunput(WARN);
		cp = vp;
		while (*cp) {
			if (*cp != CONC)
				cunput(*cp);
			cp--;
d1005 18
a1022 85
		expmac(&rp2);
	}
	return 1;
}

/*
 * do macro-expansion until WARN character read.
 * read from lex buffer and store result on heap.
 * will recurse into lookup() for recursive expansion.
 * when returning all expansions on the token list is done.
 */
void
expmac(struct recur *rp)
{
	struct symtab *nl;
	int c, noexp = 0, orgexp;
	usch *och, *stksv;

#ifdef CPP_DEBUG
	if (dflag) {
		struct recur *rp2 = rp;
		printf("\nexpmac\n");
		while (rp2) {
			printf("do not expand %s\n", rp2->sp->namep);
			rp2 = rp2->next;
		}
	}
#endif
	readmac++;
	while ((c = yylex()) != WARN) {
		switch (c) {
		case NOEXP: noexp++; break;
		case EXPAND: noexp--; break;

		case IDENT:
			/*
			 * Handle argument concatenation here.
			 * If an identifier is found and directly 
			 * after EXPAND or NOEXP then push the
			 * identifier back on the input stream and
			 * call yylex() again.
			 * Be careful to keep the noexp balance.
			 */
			och = stringbuf;
			savstr((usch *)yytext);
			DDPRINT(("id: str %s\n", och));

			orgexp = 0;
			while ((c = yylex()) == EXPAND || c == NOEXP)
				if (c == EXPAND)
					orgexp--;
				else
					orgexp++;

			DDPRINT(("id1: typ %d noexp %d orgexp %d\n",
			    c, noexp, orgexp));
			if (c == IDENT) { /* XXX numbers? */
				DDPRINT(("id2: str %s\n", yytext));
				/* OK to always expand here? */
				savstr((usch *)yytext);
				switch (orgexp) {
				case 0: /* been EXP+NOEXP */
					if (noexp == 0)
						break;
					if (noexp != 1)
						error("case 0");
					cunput(NOEXP);
					noexp = 0;
					break;
				case -1: /* been EXP */
					if (noexp != 1)
						error("case -1");
					noexp = 0;
					break;
				case 1:
					if (noexp != 0)
						error("case 1");
					cunput(NOEXP);
					break;
				default:
					error("orgexp = %d", orgexp);
				}
				unpstr(och);
				stringbuf = och;
				continue; /* New longer identifier */
d1024 5
a1028 74
			unpstr((usch *)yytext);
			if (orgexp == -1)
				cunput(EXPAND);
			else if (orgexp == -2)
				cunput(EXPAND), cunput(EXPAND);
			else if (orgexp == 1)
				cunput(NOEXP);
			unpstr(och);
			stringbuf = och;


			yylex(); /* XXX reget last identifier */

			if ((nl = lookup((usch *)yytext, FIND)) == NULL)
				goto def;

			if (canexpand(rp, nl) == 0)
				goto def;
			/*
			 * If noexp == 0 then expansion of any macro is 
			 * allowed.  If noexp == 1 then expansion of a
			 * fun-like macro is allowed iff there is an 
			 * EXPAND between the identifier and the '('.
			 */
			if (noexp == 0) {
				if ((c = subst(nl, rp)) == 0)
					goto def;
				break;
			}
//printf("noexp1 %d nl->namep %s\n", noexp, nl->namep);
//if (noexp > 1) goto def;
			if (noexp != 1)
				error("bad noexp %d", noexp);
			stksv = NULL;
			if ((c = yylex()) == WSPACE) {
				stksv = xstrdup(yytext);
				c = yylex();
			}
			/* only valid for expansion if fun macro */
			if (c == EXPAND && *nl->value != OBJCT) {
				noexp--;
				if (subst(nl, rp))
					break;
				savstr(nl->namep);
				if (stksv)
					savstr(stksv);
			} else {
				unpstr((usch *)yytext);
				if (stksv)
					unpstr(stksv);
				savstr(nl->namep);
			}
			if (stksv)
				free(stksv);
			break;

		case CMNT:
			getcmnt();
			break;

		case STRING:
			/* remove EXPAND/NOEXP from strings */
			if (yytext[1] == NOEXP) {
				savch('"');
				och = (usch *)&yytext[2];
				while (*och != EXPAND)
					savch(*och++);
				savch('"');
				break;
			}
			/* FALLTHROUGH */

def:		default:
			savstr((usch *)yytext);
d1032 2
a1033 193
	if (noexp)
		error("expmac noexp=%d", noexp);
	readmac--;
	DPRINT(("return from expmac\n"));
}

/*
 * expand a function-like macro.
 * vp points to end of replacement-list
 * reads function arguments from yylex()
 * result is written on top of heap
 */
void
expdef(vp, rp, gotwarn)
	usch *vp;
	struct recur *rp;
{
	usch **args, *sptr, *ap, *bp, *sp;
	int narg, c, i, plev, snuff, instr;
	int ellips = 0;

	DPRINT(("expdef rp %s\n", (rp ? (char *)rp->sp->namep : "")));
	if ((c = yylex()) != '(')
		error("got %c, expected (", c);
	if (vp[1] == VARG) {
		narg = *vp--;
		ellips = 1;
	} else
		narg = vp[1];
	if ((args = malloc(sizeof(usch *) * (narg+ellips))) == NULL)
		error("expdef: out of mem");

	/*
	 * read arguments and store them on heap.
	 * will be removed just before return from this function.
	 */
	inmac = 1;
	sptr = stringbuf;
	instr = 0;
	for (i = 0; i < narg && c != ')'; i++) {
		args[i] = stringbuf;
		plev = 0;
		while ((c = yylex()) == WSPACE || c == '\n')
			;
		DDPRINT((":AAA (%d)", c));
		if (instr == -1)
			savch(NOEXP), instr = 1;
		if (c == NOEXP)
			instr = 1;
		for (;;) {
			if (plev == 0 && (c == ')' || c == ','))
				break;
			if (c == '(')
				plev++;
			if (c == ')')
				plev--;
			savstr((usch *)yytext);
			while ((c = yylex()) == '\n')
				savch('\n');
			while (c == CMNT) {
				getcmnt();
				c = yylex();
			}
			if (c == EXPAND)
				instr = 0;
			if (c == 0)
				error("eof in macro");
		}
		while (args[i] < stringbuf &&
		    (stringbuf[-1] == ' ' || stringbuf[-1] == '\t'))
			stringbuf--;
		if (instr == 1)
			savch(EXPAND), instr = -1;
		savch('\0');
	}
	if (ellips)
		args[i] = (usch *)"";
	if (ellips && c != ')') {
		args[i] = stringbuf;
		plev = 0;
		instr = 0;
		while ((c = yylex()) == WSPACE)
			;
		if (c == NOEXP)
			instr++;
		DDPRINT((":AAY (%d)", c));
		for (;;) {
			if (plev == 0 && c == ')')
				break;
			if (c == '(')
				plev++;
			if (c == ')')
				plev--;
			if (plev == 0 && c == ',' && instr) {
				savch(EXPAND);
				savch(',');
				savch(NOEXP);
			} else
				savstr((usch *)yytext);
			while ((c = yylex()) == '\n')
				savch('\n');
			if (c == EXPAND)
				instr--;
		}
		while (args[i] < stringbuf &&
		    (stringbuf[-1] == ' ' || stringbuf[-1] == '\t'))
			stringbuf--;
		savch('\0');
		
	}
	if (narg == 0 && ellips == 0)
		while ((c = yylex()) == WSPACE || c == '\n')
			;

	if (c != ')' || (i != narg && ellips == 0) || (i < narg && ellips == 1))
		error("wrong arg count");

	inmac = 0;
	while (gotwarn--)
		cunput(WARN);

	sp = vp;
	instr = snuff = 0;

	/*
	 * push-back replacement-list onto lex buffer while replacing
	 * arguments. 
	 */
	cunput(WARN);
	while (*sp != 0) {
		if (*sp == SNUFF)
			cunput('\"'), snuff ^= 1;
		else if (*sp == CONC)
			;
		else if (*sp == WARN) {

			if (sp[-1] == VARG) {
				bp = ap = args[narg];
				sp--;
#ifdef GCC_VARI
			} else if (sp[-1] == GCCARG) {
				ap = args[narg];
				if (ap[0] == 0)
					ap = (usch *)"0";
				bp = ap;
				sp--;
#endif
			} else
				bp = ap = args[(int)*--sp];
			if (sp[2] != CONC && !snuff && sp[-1] != CONC) {
				cunput(WARN);
				while (*bp)
					bp++;
				while (bp > ap)
					cunput(*--bp);
				DPRINT(("expand arg %d string %s\n", *sp, ap));
				bp = ap = stringbuf;
				savch(NOEXP);
				expmac(NULL);
				savch(EXPAND);
				savch('\0');
			}
			while (*bp)
				bp++;
			while (bp > ap) {
				bp--;
				if (snuff && !instr && 
				    (*bp == ' ' || *bp == '\t' || *bp == '\n')){
					while (*bp == ' ' || *bp == '\t' ||
					    *bp == '\n') {
						bp--;
					}
					cunput(' ');
				}
				cunput(*bp);
				if ((*bp == '\'' || *bp == '"')
				     && bp[-1] != '\\' && snuff) {
					instr ^= 1;
					if (instr == 0 && *bp == '"')
						cunput('\\');
				}
				if (instr && (*bp == '\\' || *bp == '"'))
					cunput('\\');
			}
		} else
			cunput(*sp);
		sp--;
	}
	stringbuf = sptr;

	/* scan the input buffer (until WARN) and save result on heap */
	expmac(rp);
	free(args);
a1035 26
usch *
savstr(usch *str)
{
	usch *rv = stringbuf;

	do {
		if (stringbuf >= &sbf[SBSIZE])   {
			stringbuf = sbf; /* need space to write error message */
			error("out of macro space!");
		}
	} while ((*stringbuf++ = *str++));
	stringbuf--;
	return rv;
}

int
canexpand(struct recur *rp, struct symtab *np)
{
	struct recur *w;

	for (w = rp; w && w->sp != np; w = w->next)
		;
	if (w != NULL)
		return 0;
	return 1;
}
a1036 4
void
unpstr(usch *c)
{
	usch *d = c;
a1037 6
	while (*d)
		d++;
	while (d > c) {
		cunput(*--d);
	}
}
d1039 9
a1047 8
void
flbuf()
{
	if (obufp == 0)
		return;
	if (Mflag == 0 && write(ofd, outbuf, obufp) < 0)
		error("obuf write error");
	obufp = 0;
d1050 3
a1052 7
void
putch(int ch)
{
	outbuf[obufp++] = ch;
	if (obufp == CPPBUF || (istty && ch == '\n'))
		flbuf();
}
d1054 4
a1057 12
void
putstr(usch *s)
{
	for (; *s; s++) {
		if (*s == PRAGS) {
			s = prtprag(s);
			continue;
		}
		outbuf[obufp++] = *s;
		if (obufp == CPPBUF || (istty && *s == '\n'))
			flbuf();
	}
d1060 4
a1063 19
/*
 * convert a number to an ascii string. Store it on the heap.
 */
static void
num2str(int num)
{
	static usch buf[12];
	usch *b = buf;
	int m = 0;
	
	if (num < 0)
		num = -num, m = 1;
	do {
		*b++ = num % 10 + '0', num /= 10;
	} while (num);
	if (m)
		*b++ = '-';
	while (b > buf)
		savch(*--b);
d1066 1
a1066 34
/*
 * similar to sprintf, but only handles %s and %d. 
 * saves result on heap.
 */
usch *
sheap(char *fmt, ...)
{
	va_list ap;
	usch *op = stringbuf;

	va_start(ap, fmt);
	for (; *fmt; fmt++) {
		if (*fmt == '%') {
			fmt++;
			switch (*fmt) {
			case 's':
				savstr(va_arg(ap, usch *));
				break;
			case 'd':
				num2str(va_arg(ap, int));
				break;
			case 'c':
				savch(va_arg(ap, int));
				break;
			default:
				break; /* cannot call error() here */
			}
		} else
			savch(*fmt);
	}
	va_end(ap);
	*stringbuf = 0;
	return op;
}
d1068 2
a1069 2
void
usage()
d1071 3
a1073 2
	error("Usage: cpp [-Cdt] [-Dvar=val] [-Uvar] [-Ipath] [-Spath]");
}
d1075 13
a1087 11
#ifdef notyet
/*
 * Symbol table stuff.
 * The data structure used is a patricia tree implementation using only
 * bytes to store offsets.  
 * The information stored is (lower address to higher):
 *
 *	unsigned char bitno[2]; bit number in the string
 *	unsigned char left[3];	offset from base to left element
 *	unsigned char right[3];	offset from base to right element
 */
a1088 79

/*
 * This patricia implementation is more-or-less the same as
 * used in ccom for string matching.
 */
struct tree {
	int bitno;
	struct tree *lr[2];
};

#define BITNO(x)		((x) & ~(LEFT_IS_LEAF|RIGHT_IS_LEAF))
#define LEFT_IS_LEAF		0x80000000
#define RIGHT_IS_LEAF		0x40000000
#define IS_LEFT_LEAF(x)		(((x) & LEFT_IS_LEAF) != 0)
#define IS_RIGHT_LEAF(x)	(((x) & RIGHT_IS_LEAF) != 0)
#define P_BIT(key, bit)		(key[bit >> 3] >> (bit & 7)) & 1
#define CHECKBITS		8

static struct tree *sympole;
static int numsyms;

/*
 * Allocate a symtab struct and store the string.
 */
static struct symtab *
getsymtab(usch *str)
{
	struct symtab *sp = malloc(sizeof(struct symtab));

	if (sp == NULL)
		error("getsymtab: couldn't allocate symtab");
	sp->namep = savstr(str);
	savch('\0');
	sp->value = NULL;
	sp->file = ifiles ? ifiles->orgfn : (usch *)"<initial>";
	sp->line = ifiles ? ifiles->lineno : 0;
	return sp;
}

/*
 * Do symbol lookup in a patricia tree.
 * Only do full string matching, no pointer optimisations.
 */
struct symtab *
lookup(usch *key, int enterf)
{
	struct symtab *sp;
	struct tree *w, *new, *last;
	int len, cix, bit, fbit, svbit, ix, bitno;
	usch *k, *m, *sm;

	/* Count full string length */
	for (k = key, len = 0; *k; k++, len++)
		;

	switch (numsyms) {
	case 0: /* no symbols yet */
		if (enterf != ENTER)
			return NULL;
		sympole = (struct tree *)getsymtab(key);
		numsyms++;
		return (struct symtab *)sympole;

	case 1:
		w = sympole;
		svbit = 0; /* XXX gcc */
		break;

	default:
		w = sympole;
		bitno = len * CHECKBITS;
		for (;;) {
			bit = BITNO(w->bitno);
			fbit = bit > bitno ? 0 : P_BIT(key, bit);
			svbit = fbit ? IS_RIGHT_LEAF(w->bitno) :
			    IS_LEFT_LEAF(w->bitno);
			w = w->lr[fbit];
			if (svbit)
				break;
d1090 24
a1113 1
	}
d1115 152
a1266 100
	sp = (struct symtab *)w;

	sm = m = sp->namep;
	k = key;

	/* Check for correct string and return */
	for (cix = 0; *m && *k && *m == *k; m++, k++, cix += CHECKBITS)
		;
	if (*m == 0 && *k == 0) {
		if (enterf != ENTER && sp->value == NULL)
			return NULL;
		return sp;
	}

	if (enterf != ENTER)
		return NULL; /* no string found and do not enter */

	ix = *m ^ *k;
	while ((ix & 1) == 0)
		ix >>= 1, cix++;

	/* Create new node */
	if ((new = malloc(sizeof *new)) == NULL)
		error("getree: couldn't allocate tree");
	bit = P_BIT(key, cix);
	new->bitno = cix | (bit ? RIGHT_IS_LEAF : LEFT_IS_LEAF);
	new->lr[bit] = (struct tree *)getsymtab(key);

	if (numsyms++ == 1) {
		new->lr[!bit] = sympole;
		new->bitno |= (bit ? LEFT_IS_LEAF : RIGHT_IS_LEAF);
		sympole = new;
		return (struct symtab *)new->lr[bit];
	}

	w = sympole;
	last = NULL;
	for (;;) {
		fbit = w->bitno;
		bitno = BITNO(w->bitno);
		if (bitno == cix)
			error("bitno == cix");
		if (bitno > cix)
			break;
		svbit = P_BIT(key, bitno);
		last = w;
		w = w->lr[svbit];
		if (fbit & (svbit ? RIGHT_IS_LEAF : LEFT_IS_LEAF))
			break;
	}

	new->lr[!bit] = w;
	if (last == NULL) {
		sympole = new;
	} else {
		last->lr[svbit] = new;
		last->bitno &= ~(svbit ? RIGHT_IS_LEAF : LEFT_IS_LEAF);
	}
	if (bitno < cix)
		new->bitno |= (bit ? LEFT_IS_LEAF : RIGHT_IS_LEAF);
	return (struct symtab *)new->lr[bit];
}

usch *
xstrdup(char *str)
{
	size_t len = strlen(str)+1;
	usch *rv;

	if ((rv = malloc(len)) == NULL)
		error("xstrdup: out of mem");
	strlcpy((char *)rv, str, len);
	return rv;
}

usch *
prtprag(usch *s)
{
	int ch;

	s++;
	putstr((usch *)"\n#pragma ");
	while (*s != PRAGE) {
		if (*s == 'L')
			s++;
		if (*s == '\"') {
			s++;
			while ((ch = *s++) != '\"') {
				if (ch == '\\' && (*s == '\"' || *s == '\\'))
					ch = *s++;
				putch(ch);
			}
		} else {
			s++;
			putch(*s);
		}
	}
	putstr((usch *)"\n");
	prtline();
	return ++s;
@


1.1.201.1
log
@Reiser CPP
@
text
@@
