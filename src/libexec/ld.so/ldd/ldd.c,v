head	1.3;
access;
symbols
	MIRBSD_10:1.3.0.2
	MIRBSD_10_BASE:1.3
	cvs-200611210330:1.1.1.1
	cvs-200606301800:1.1.1.1
	MIRBSD_9_BASE:1.1.1.1
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200511231542:1.1.1.1
	cvs-200507211800:1.1.1.1
	cvs-200504170300:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2006.08.30.03.52.53;	author tg;	state Exp;
branches;
next	1.2;
commitid	10044F50B9C662ACEF9;

1.2
date	2006.08.30.03.46.13;	author tg;	state Exp;
branches;
next	1.1;
commitid	10044F50A1163CD5DC7;

1.1
date	2005.02.05.17.26.21;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.26.21;	author tg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@fix missing __dead function attribute and some other glitches
@
text
@/**	$MirOS: src/libexec/ld.so/ldd/ldd.c,v 1.2 2006/08/30 03:46:13 tg Exp $ */
/*	$OpenBSD: ldd.c,v 1.11 2003/07/10 00:04:28 david Exp $	*/
/*
 * Copyright (c) 2001 Artur Grabowski <art@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/wait.h>

#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>
#include <elf_abi.h>
#include <err.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>

__RCSID("$MirOS: src/libexec/ld.so/ldd/ldd.c,v 1.2 2006/08/30 03:46:13 tg Exp $");

__dead int usage(void);
int doit(char *);

int
main(int argc, char **argv)
{
	int c, xflag, ret;

	xflag = 0;
	while ((c = getopt(argc, argv, "x")) != -1) {
		switch (c) {
		case 'x':
			xflag = 1;
			break;
		default:
			usage();
			/*NOTREACHED*/
		}
	}

	if (xflag)
		errx(1, "-x not yet implemented");

	argc -= optind;
	argv += optind;

	if (argc == 0)
		usage();

	if (setenv("LD_TRACE_LOADED_OBJECTS", "true", 1) < 0)
		err(1, "setenv(LD_TRACE_LOADED_OBJECTS)");

	ret = 0;
	while (argc--) {
		ret |= doit(*argv);
		argv++;
	}

	return ret;
}

int
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "Usage: %s [-x] <filename> ...\n", __progname);
	exit(1);
}


int
doit(char *name)
{
	Elf_Ehdr ehdr;
	Elf_Phdr *phdr;
	int fd, i, size, status;
	char buf[MAXPATHLEN];
	void *dlhandle;

	if ((fd = open(name, O_RDONLY)) < 0) {
		warn("%s", name);
		return 1;
	}

	if (read(fd, &ehdr, sizeof(ehdr)) < 0) {
		warn("read(%s)", name);
		close(fd);
		return 1;
	}

	if (memcmp(ehdr.e_ident, ELFMAG, SELFMAG) ||
	    ehdr.e_machine != ELF_TARG_MACH) {
		warnx("%s: not an ELF executable", name);
		close(fd);
		return 1;
	}

	if (ehdr.e_type == ET_DYN) {
		printf("%s:\n", name);
		if (realpath(name, buf) == NULL) {
			warn("realpath(%s)", name);
			return (1);
		}
		fflush(stdout);
		if ((dlhandle = dlopen(buf, RTLD_TRACE)) == NULL) {
			printf("%s\n", dlerror());
			return (1);
		}
		close(fd);
		return (0);
	}

	size = ehdr.e_phnum * sizeof(Elf_Phdr);
	if ((phdr = malloc(size)) == NULL)
		err(1, "malloc");

	if (pread(fd, phdr, size, ehdr.e_phoff) != size) {
		warn("read(%s)", name);
		close(fd);
		free(phdr);
		return 1;
	}
	for (i = 0; i < ehdr.e_phnum; i++)
		if (phdr[i].p_type == PT_DYNAMIC)
			break;
	close(fd);
	free(phdr);

	if (i == ehdr.e_phnum) {
		warnx("%s: not a dynamic executable", name);
		return 1;
	}

	printf("%s:\n", name);
	fflush(stdout);
	switch (fork()) {
	case -1:
		err(1, "fork");
	case 0:
		execl(name, name, (char *)NULL);
		perror(name);
		_exit(1);
	default:
		if (wait(&status) < 0) {
			warn("wait");
			return 1;
		}
		if (WIFSIGNALED(status)) {
			fprintf(stderr, "%s: signal %d\n", name,
			    WTERMSIG(status));
			return 1;
		}
		if (WEXITSTATUS(status)) {
			fprintf(stderr, "%s: exit status %d\n", name,
			    WEXITSTATUS(status));
			return 1;
		}
	}

	return 0;
}
@


1.2
log
@cluefully apply the ldd-for-shlibs patch
From: Matt Provost <mprovost@@termcap.net>
@
text
@d1 1
a1 1
/**	$MirOS$ */
d42 1
a42 1
__RCSID("$MirOS$");
d44 1
a44 1
int usage(void);
@


1.1
log
@Initial revision
@
text
@d1 1
d28 5
d35 1
d42 1
a42 3
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/wait.h>
d101 2
a102 2

	printf("%s:\n", name);
d122 15
d158 1
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@
