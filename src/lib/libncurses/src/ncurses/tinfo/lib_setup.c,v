head	1.7;
access;
symbols
	MIRBSD_10:1.4.0.2
	MIRBSD_10_BASE:1.4
	ncurses-devel:1.1.109.1.0.2
	ncurses-5_5:1.1.109.1
	lynx:1.1.109;
locks; strict;
comment	@ * @;


1.7
date	2016.01.02.21.33.03;	author tg;	state Exp;
branches;
next	1.6;
commitid	10056884200442406AA;

1.6
date	2009.09.06.13.46.36;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004AA3BCA2415FF513;

1.5
date	2009.09.06.12.46.46;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004AA3AF394030A9CC;

1.4
date	2007.07.05.23.09.35;	author tg;	state Exp;
branches;
next	1.3;
commitid	100468D7A224CDB6D5A;

1.3
date	2006.10.27.16.13.44;	author tg;	state Exp;
branches;
next	1.2;
commitid	10045423016752CB2FA;

1.2
date	2006.06.08.23.48.22;	author tg;	state dead;
branches;
next	1.1;
commitid	1004488B5EE329FB78D;

1.1
date	2006.06.04.23.37.14;	author tg;	state Exp;
branches
	1.1.109.1;
next	;
commitid	10044836EA64DB61E09;

1.1.109.1
date	2006.06.04.23.37.14;	author tg;	state Exp;
branches;
next	;
commitid	10044836EA64DB61E09;


desc
@@


1.7
log
@remove #ifndef __MirBSD__ before setlocale(); related changes
@
text
@/****************************************************************************
 * Copyright (c) 1998-2004,2005 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 *     and: Thomas E. Dickey 1996-2003                                      *
 ****************************************************************************/

/*
 * Terminal setup routines common to termcap and terminfo:
 *
 *		use_env(bool)
 *		setupterm(char *, int, int *)
 */

#include <curses.priv.h>
#include <tic.h>		/* for MAX_NAME_SIZE */
#include <term_entry.h>

#if SVR4_TERMIO && !defined(_POSIX_SOURCE)
#define _POSIX_SOURCE
#endif

#if HAVE_LOCALE_H
#include <locale.h>
#endif

#include <term.h>		/* lines, columns, cur_term */

MODULE_ID("$Id: lib_setup.c,v 1.88 2005/03/12 19:41:45 tom Exp $")
#ifdef __MirBSD__
__RCSID("$MirOS: src/lib/libncurses/src/ncurses/tinfo/lib_setup.c,v 1.6 2009/09/06 13:46:36 tg Exp $");
#endif

/****************************************************************************
 *
 * Terminal size computation
 *
 ****************************************************************************/

#if HAVE_SIZECHANGE
# if !defined(sun) || !TERMIOS
#  if HAVE_SYS_IOCTL_H
#   include <sys/ioctl.h>
#  endif
# endif
#endif

#if NEED_PTEM_H
 /* On SCO, they neglected to define struct winsize in termios.h -- it's only
  * in termio.h and ptem.h (the former conflicts with other definitions).
  */
# include <sys/stream.h>
# include <sys/ptem.h>
#endif

#if HAVE_LANGINFO_CODESET
#include <langinfo.h>
#endif

/*
 * SCO defines TIOCGSIZE and the corresponding struct.  Other systems (SunOS,
 * Solaris, IRIX) define TIOCGWINSZ and struct winsize.
 */
#ifdef TIOCGSIZE
# define IOCTL_WINSIZE TIOCGSIZE
# define STRUCT_WINSIZE struct ttysize
# define WINSIZE_ROWS(n) (int)n.ts_lines
# define WINSIZE_COLS(n) (int)n.ts_cols
#else
# ifdef TIOCGWINSZ
#  define IOCTL_WINSIZE TIOCGWINSZ
#  define STRUCT_WINSIZE struct winsize
#  define WINSIZE_ROWS(n) (int)n.ws_row
#  define WINSIZE_COLS(n) (int)n.ws_col
# endif
#endif

NCURSES_EXPORT_VAR(char) ttytype[NAMESIZE] = "";
NCURSES_EXPORT_VAR(int) LINES = 0;
NCURSES_EXPORT_VAR(int) COLS = 0;
NCURSES_EXPORT_VAR(int) TABSIZE = 0;

static int _use_env = TRUE;

NCURSES_EXPORT(void)
use_env(bool f)
{
    T((T_CALLED("use_env()")));
    _use_env = f;
    returnVoid;
}

static void
_nc_get_screensize(int *linep, int *colp)
/* Obtain lines/columns values from the environment and/or terminfo entry */
{
    /* figure out the size of the screen */
    T(("screen size: terminfo lines = %d columns = %d", lines, columns));

    if (!_use_env) {
	*linep = (int) lines;
	*colp = (int) columns;
    } else {			/* usually want to query LINES and COLUMNS from environment */
	int value;

	*linep = *colp = 0;

	/* first, look for environment variables */
	if ((value = _nc_getenv_num("LINES")) > 0) {
	    *linep = value;
	}
	if ((value = _nc_getenv_num("COLUMNS")) > 0) {
	    *colp = value;
	}
	T(("screen size: environment LINES = %d COLUMNS = %d", *linep, *colp));

#ifdef __EMX__
	if (*linep <= 0 || *colp <= 0) {
	    int screendata[2];
	    _scrsize(screendata);
	    *colp = screendata[0];
	    *linep = screendata[1];
	    T(("EMX screen size: environment LINES = %d COLUMNS = %d",
	       *linep, *colp));
	}
#endif
#if HAVE_SIZECHANGE
	/* if that didn't work, maybe we can try asking the OS */
	if (*linep <= 0 || *colp <= 0) {
	    if (isatty(cur_term->Filedes)) {
		STRUCT_WINSIZE size;

		errno = 0;
		do {
		    if (ioctl(cur_term->Filedes, IOCTL_WINSIZE, &size) < 0
			&& errno != EINTR)
			goto failure;
		} while
		    (errno == EINTR);

		/*
		 * Solaris lets users override either dimension with an
		 * environment variable.
		 */
		if (*linep <= 0)
		    *linep = WINSIZE_ROWS(size);
		if (*colp <= 0)
		    *colp = WINSIZE_COLS(size);
	    }
	    /* FALLTHRU */
	  failure:;
	}
#endif /* HAVE_SIZECHANGE */

	/* if we can't get dynamic info about the size, use static */
	if (*linep <= 0) {
	    *linep = (int) lines;
	}
	if (*colp <= 0) {
	    *colp = (int) columns;
	}

	/* the ultimate fallback, assume fixed 24x80 size */
	if (*linep <= 0) {
	    *linep = 24;
	}
	if (*colp <= 0) {
	    *colp = 80;
	}

	/*
	 * Put the derived values back in the screen-size caps, so
	 * tigetnum() and tgetnum() will do the right thing.
	 */
	lines = (short) (*linep);
	columns = (short) (*colp);
    }

    T(("screen size is %dx%d", *linep, *colp));

    if (VALID_NUMERIC(init_tabs))
	TABSIZE = (int) init_tabs;
    else
	TABSIZE = 8;
    T(("TABSIZE = %d", TABSIZE));
}

#if USE_SIZECHANGE
NCURSES_EXPORT(void)
_nc_update_screensize(void)
{
    int old_lines = lines;
    int new_lines;
    int old_cols = columns;
    int new_cols;

    _nc_get_screensize(&new_lines, &new_cols);

    /*
     * See is_term_resized() and resizeterm().
     * We're doing it this way because those functions belong to the upper
     * ncurses library, while this resides in the lower terminfo library.
     */
    if (SP != 0
	&& SP->_resize != 0) {
	if ((new_lines != old_lines) || (new_cols != old_cols))
	    SP->_resize(new_lines, new_cols);
	SP->_sig_winch = FALSE;
    }
}
#endif

/****************************************************************************
 *
 * Terminal setup
 *
 ****************************************************************************/

#define ret_error(code, fmt, arg)	if (errret) {\
					    *errret = code;\
					    returnCode(ERR);\
					} else {\
					    fprintf(stderr, fmt, arg);\
					    exit(EXIT_FAILURE);\
					}

#define ret_error0(code, msg)		if (errret) {\
					    *errret = code;\
					    returnCode(ERR);\
					} else {\
					    fprintf(stderr, msg);\
					    exit(EXIT_FAILURE);\
					}

#if USE_DATABASE || USE_TERMCAP
static int
grab_entry(const char *const tn, TERMTYPE *const tp)
/* return 1 if entry found, 0 if not found, -1 if database not accessible */
{
#if USE_DATABASE
    char filename[PATH_MAX];
#endif
    int status;

    /*
     * $TERM shouldn't contain pathname delimiters.
     */
    if (strchr(tn, '/'))
	return 0;

#if USE_DATABASE
    if ((status = _nc_read_entry(tn, filename, tp)) != 1) {

#if !PURE_TERMINFO
	/*
	 * Try falling back on the termcap file.
	 * Note:  allowing this call links the entire terminfo/termcap
	 * compiler into the startup code.  It's preferable to build a
	 * real terminfo database and use that.
	 */
	status = _nc_read_termcap_entry(tn, tp);
#endif /* PURE_TERMINFO */

    }
#else
    status = _nc_read_termcap_entry(tn, tp);
#endif

    /*
     * If we have an entry, force all of the cancelled strings to null
     * pointers so we don't have to test them in the rest of the library.
     * (The terminfo compiler bypasses this logic, since it must know if
     * a string is cancelled, for merging entries).
     */
    if (status == 1) {
	unsigned n;
	for_each_boolean(n, tp) {
	    if (!VALID_BOOLEAN(tp->Booleans[n]))
		tp->Booleans[n] = FALSE;
	}
	for_each_string(n, tp) {
	    if (tp->Strings[n] == CANCELLED_STRING)
		tp->Strings[n] = ABSENT_STRING;
	}
    }
    return (status);
}
#endif

/*
**	do_prototype()
**
**	Take the real command character out of the CC environment variable
**	and substitute it in for the prototype given in 'command_character'.
**
*/
static void
do_prototype(void)
{
    int i;
    char CC;
    char proto;
    char *tmp;

    tmp = getenv("CC");
    CC = *tmp;
    proto = *command_character;

    for_each_string(i, &(cur_term->type)) {
	for (tmp = cur_term->type.Strings[i]; *tmp; tmp++) {
	    if (*tmp == proto)
		*tmp = CC;
	}
    }
}

/*
 * Override the locale which is in effect.
 */
static char *_nc_locale_string = NULL;
static int _nc_locale_isutf8;

NCURSES_EXPORT(int)
_nc_overridden_locale(void)
{
	return (_nc_locale_string == NULL ? 0 : 1);
}

NCURSES_EXPORT(void)
_nc_set_locale(char *newlocale)
{
	if ((_nc_locale_string = newlocale) != NULL) {
		if (strstr(newlocale, "UTF-8") != NULL ||
		    strstr(newlocale, "utf-8") != NULL ||
		    strstr(newlocale, "UTF8") != NULL ||
		    strstr(newlocale, "utf8") != NULL)
			_nc_locale_isutf8 = 1;
		else
			_nc_locale_isutf8 = 0;
	}
}

/*
 * Find the locale which is in effect.
 */

NCURSES_EXPORT(char *)
_nc_get_locale(void)
{
    char *env;

    if (_nc_overridden_locale()) {
	env = _nc_locale_string;
	goto _nc_get_locale_out;
    }

#if HAVE_LOCALE_H
    /*
     * This is preferable to using getenv() since it ensures that we are using
     * the locale which was actually initialized by the application.
     */
    env = setlocale(LC_CTYPE, 0);
#else
    if (((env = getenv("LC_ALL")) != 0 && *env != '\0')
	|| ((env = getenv("LC_CTYPE")) != 0 && *env != '\0')
	|| ((env = getenv("LANG")) != 0 && *env != '\0')) {
	;
    }
#endif
 _nc_get_locale_out:
    T(("_nc_get_locale %s", _nc_visbuf(env)));
    return env;
}

/*
 * Check if we are running in a UTF-8 locale.
 */
NCURSES_EXPORT(int)
_nc_unicode_locale(void)
{
    int result = 0;
    char *env;

    if (_nc_overridden_locale())
	return (_nc_locale_isutf8);

#if HAVE_LANGINFO_CODESET
    env = nl_langinfo(CODESET);
    result = !strcmp(env, "UTF-8");
    T(("_nc_unicode_locale(%s) ->%d", env, result));
#else
    env = _nc_get_locale();
    if (env != 0) {
	if (strstr(env, ".UTF-8") != 0) {
	    result = 1;
	    T(("_nc_unicode_locale(%s) ->%d", env, result));
	}
    }
#endif
    return result;
}

#define CONTROL_N(s) ((s) != 0 && strstr(s, "\016") != 0)
#define CONTROL_O(s) ((s) != 0 && strstr(s, "\017") != 0)

/*
 * Check for known broken cases where a UTF-8 locale breaks the alternate
 * character set.
 */
NCURSES_EXPORT(int)
_nc_locale_breaks_acs(void)
{
    char *env;

    if ((env = getenv("NCURSES_NO_UTF8_ACS")) != 0) {
	return atoi(env);
    } else if ((env = getenv("TERM")) != 0) {
	if (strstr(env, "linux"))
	    return 1;		/* always broken */
	if (strstr(env, "screen") != 0
	    && ((env = getenv("TERMCAP")) != 0
		&& strstr(env, "screen") != 0)
	    && strstr(env, "hhII00") != 0) {
	    if (CONTROL_N(enter_alt_charset_mode) ||
		CONTROL_O(enter_alt_charset_mode) ||
		CONTROL_N(set_attributes) ||
		CONTROL_O(set_attributes))
		return 1;
	}
    }
    return 0;
}

/*
 * This entrypoint is called from tgetent() to allow special a case of reusing
 * the same TERMINAL data (see comment).
 */
NCURSES_EXPORT(int)
_nc_setupterm(NCURSES_CONST char *tname, int Filedes, int *errret, bool reuse)
{
    int status;

    START_TRACE();
    T((T_CALLED("setupterm(%s,%d,%p)"), _nc_visbuf(tname), Filedes, errret));

    if (tname == 0) {
	tname = getenv("TERM");
	if (tname == 0 || *tname == '\0') {
	    ret_error0(-1, "TERM environment variable not set.\n");
	}
    }
    if (strlen(tname) > MAX_NAME_SIZE) {
	ret_error(-1, "TERM environment must be <= %d characters.\n",
		  MAX_NAME_SIZE);
    }

    T(("your terminal name is %s", tname));

    /*
     * Allow output redirection.  This is what SVr3 does.  If stdout is
     * directed to a file, screen updates go to standard error.
     */
    if (Filedes == STDOUT_FILENO && !isatty(Filedes))
	Filedes = STDERR_FILENO;

    /*
     * Check if we have already initialized to use this terminal.  If so, we
     * do not need to re-read the terminfo entry, or obtain TTY settings.
     *
     * This is an improvement on SVr4 curses.  If an application mixes curses
     * and termcap calls, it may call both initscr and tgetent.  This is not
     * really a good thing to do, but can happen if someone tries using ncurses
     * with the readline library.  The problem we are fixing is that when
     * tgetent calls setupterm, the resulting Ottyb struct in cur_term is
     * zeroed.  A subsequent call to endwin uses the zeroed terminal settings
     * rather than the ones saved in initscr.  So we check if cur_term appears
     * to contain terminal settings for the same output file as our current
     * call - and copy those terminal settings.  (SVr4 curses does not do this,
     * however applications that are working around the problem will still work
     * properly with this feature).
     */
    if (reuse
	&& cur_term != 0
	&& cur_term->Filedes == Filedes
	&& cur_term->_termname != 0
	&& !strcmp(cur_term->_termname, tname)
	&& _nc_name_match(cur_term->type.term_names, tname, "|")) {
	T(("reusing existing terminal information and mode-settings"));
    } else {
	TERMINAL *term_ptr;

	term_ptr = typeCalloc(TERMINAL, 1);

	if (term_ptr == 0) {
	    ret_error0(-1,
		       "Not enough memory to create terminal structure.\n");
	}
#if USE_DATABASE || USE_TERMCAP
	status = grab_entry(tname, &term_ptr->type);
#else
	status = 0;
#endif

	/* try fallback list if entry on disk */
	if (status != 1) {
	    const TERMTYPE *fallback = _nc_fallback(tname);

	    if (fallback) {
		term_ptr->type = *fallback;
		status = 1;
	    }
	}

	if (status <= 0) {
	    del_curterm(term_ptr);
	    if (status == -1) {
		ret_error0(-1, "terminals database is inaccessible\n");
	    } else if (status == 0) {
		ret_error(0, "'%s': unknown terminal type.\n", tname);
	    }
	}

	set_curterm(term_ptr);

	if (command_character && getenv("CC"))
	    do_prototype();

	strncpy(ttytype, cur_term->type.term_names, NAMESIZE - 1);
	ttytype[NAMESIZE - 1] = '\0';

	cur_term->Filedes = Filedes;
	cur_term->_termname = strdup(tname);

	/*
	 * If an application calls setupterm() rather than initscr() or
	 * newterm(), we will not have the def_prog_mode() call in
	 * _nc_setupscreen().  Do it now anyway, so we can initialize the
	 * baudrate.
	 */
	if (isatty(Filedes)) {
	    def_prog_mode();
	    baudrate();
	}
    }

    /*
     * We should always check the screensize, just in case.
     */
    _nc_get_screensize(&LINES, &COLS);

    if (errret)
	*errret = 1;

    T((T_CREATE("screen %s %dx%d"), tname, LINES, COLS));

    if (generic_type) {
	ret_error(0, "'%s': I need something more specific.\n", tname);
    }
    if (hard_copy) {
	ret_error(1, "'%s': I can't handle hardcopy terminals.\n", tname);
    }
    returnCode(OK);
}

/*
 *	setupterm(termname, Filedes, errret)
 *
 *	Find and read the appropriate object file for the terminal
 *	Make cur_term point to the structure.
 *
 */

NCURSES_EXPORT(int)
setupterm(NCURSES_CONST char *tname, int Filedes, int *errret)
{
    return _nc_setupterm(tname, Filedes, errret, FALSE);
}
@


1.6
log
@Implement two new exported but hidden functions:
• void _nc_set_locale(char *arg);
  ‣ override the locale to 「arg」 and match it with *@@([Uu][Tt][Ff]?(-)8)*
  ‣ if arg == NULL, un-override the locale
• int _nc_overridden_locale(void);
  ‣ return 1 if the locale is overridden via _nc_set_locale, 0 otherwise
• #define _nc_set_locale _nc_set_locale
  ‣ feature check in <ncurses.h>

If the locale is overridden and not UTF-8, legacy encoding is assumed,
which means, wc*tomb* and mb*towc* functions aren’t called, but wcwidth()
on the assumed-to-be-latin1 value of a single-byte character is.
@
text
@d58 1
a58 1
__RCSID("$MirOS$");
a372 3
#ifdef __MirBSD__
static char _nc_get_locale_storage[16];
#endif
a383 4
#ifdef __MirBSD__
    /* this result is constant in MirBSD */
    memcpy(env = _nc_get_locale_storage, "en_US.UTF-8", 12);
#else
a396 1
#endif
a407 1
#ifndef __MirBSD__
a409 1
#endif
a413 3
#ifdef __MirBSD__
    return (1);
#else
a427 1
#endif
@


1.5
log
@• let ncurses compile with __CRAZY=Yes
• ensure RCS IDs are there ☺
@
text
@d345 26
d373 4
d380 7
d388 2
a389 3
    static char lcl[] = "en_US.UTF-8";

    return (lcl);
a390 1
    char *env;
d404 2
a407 1
#endif
d416 8
a426 1
    int result = 0;
d428 1
a428 1
    char *env = nl_langinfo(CODESET);
d432 1
a432 1
    char *env = _nc_get_locale();
@


1.4
log
@• #ifdef __MirBSD__
  do not use setlocale() and nl_langinfo(), hardcode it
  #endif
• rcs ids

should greatly reduce space usage of ramdisc
@
text
@d57 3
d351 1
a351 1
    static const char lcl[] = "en_US.UTF-8";
d353 1
a353 1
    return ((char *)lcl);
@


1.3
log
@resurrect branch
@
text
@d347 5
d368 1
d377 3
d395 1
@


1.2
log
@remove "new" libncurses:
* libncurses can do about the same things as our current libcurses,
  with about the same bugs regarding japanese character positions
  and cursor positioning in an uxterm (and lynx width bugs)
* libncurses cannot, however, make use of terminfo.db and neither
  do I want to restrict it to termcap nor do we want the zillions
  of files under /usr/share/terminfo like the clueless leenocksers
  (except if we had reiserfs)
* libncursesw suffers from the same limitations as libncurses
* libncursesw does not correctly display any text in an uxterm
  except for some links in lynx (but not ordinary text) - this
  might have something to do with "fancy curses" though
* libmenu has not yet been ported, is easy though
* libpanel neither

thus the developers decided it's not worth to continue
investing work into it until these flaws are found and
fixed

furthermore, upgrading our curses is not easily possible,
nor is it possible at all to get hands on a distfile of
ncurses-5.2-20010224 so we can't diff against the vendor;
thus millert@@openbsd.org is the only person who can solve
this dilemma, I think
@
text
@@


1.1
log
@Initial revision
@
text
@@


1.1.109.1
log
@Import Tom Dickey's ncurses 5.5 (quite stripped down)
@
text
@@
