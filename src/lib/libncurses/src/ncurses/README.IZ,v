head	1.3;
access;
symbols
	MIRBSD_10:1.3.0.2
	MIRBSD_10_BASE:1.3
	ncurses-devel:1.1.109.1.0.2
	ncurses-5_5:1.1.109.1
	lynx:1.1.109;
locks; strict;
comment	@# @;


1.3
date	2006.10.27.16.13.27;	author tg;	state Exp;
branches;
next	1.2;
commitid	10045423016752CB2FA;

1.2
date	2006.06.08.23.47.57;	author tg;	state dead;
branches;
next	1.1;
commitid	1004488B5EE329FB78D;

1.1
date	2006.06.04.23.37.12;	author tg;	state Exp;
branches
	1.1.109.1;
next	;
commitid	10044836EA64DB61E09;

1.1.109.1
date	2006.06.04.23.37.12;	author tg;	state Exp;
branches;
next	;
commitid	10044836EA64DB61E09;


desc
@@


1.3
log
@resurrect branch
@
text
@Here is the patch.  I did no testing whatsoever with event watching
requests present (I need some applications which exersize this before
this, probably lynx ;-), but the code looks working "the normal way".

I had no way to test that the poll() branch compiles/works...

Here is the API: 

*) two new functions wgetch_events() wgetstrn_event() are introduced,
   which allow an event-watch specification given as the last argument;

*) if the last argument is NULL, they behave as wgetch() and
   wgetstrn() (TESTED!);

*) the event specification is a pointer to _nc_eventlist, which
   contains bookkeeping elements (count and the summary of results),
   and an array of pointers to _nc_event;

*) each _nc_event is a typed union, with two types supported "as
   shipped": _NC_EVENT_TIMEOUT_MSEC, _NC_EVENT_FILE.  For
   _NC_EVENT_FILE the fields are fd, flag, and the output field.

*) The only supported flag "as shipped" is _NC_EVENT_FILE_READABLE.
   If the file was found readable, the return field is set to this,
   otherwise to 0;

*) If these functions return KEY_EVENT, this means that the return
   fields in both the _nc_eventlist and _nc_event structures make
   sense.  The field result_flags of _nc_eventlist may have a
   combination of bits _NC_EVENT_TIMEOUT_MSEC and _NC_EVENT_FILE_READABLE
   set;

*) The timeout_msec field of _NC_EVENT_TIMEOUT_MSEC _nc_event's is
   updated on return, even if the return is not KEY_EVENT.  However,
   the change in the value represents only the amount of time spent in
   waiting for events, not the amount of time spent bookkeeping;

*) the return KEY_EVENT of wgetstrn_event() means that the output
   string includes the user input typed so far, but the user did not have
   a chance to press ENTER (or whatever).  This call should be
   repeated (with "shifted" pointer to a buffer, of course) to
   complete the input;

*) The presence of this extension can be checked via inspecting
   #ifdef NCURSES_EVENT_VERSION.  This symbol is not defined on BeOS,
   since there is no support for this on BeOS.

Known issues:  calls interrupted by KEY_EVENT reset the ESCDELAY
timer.  This is not entirely new, since other synthetic events behave
the same (see "if (ch >= KEY_MIN)" branch of kgetch()).  However,
KEY_EVENT may be generated in a continuous stream (say, when
downloading a file), thus this may be more important than with other
synthetic keys.  An additional field in window structure which keeps
timestamp of the first raw key in the queue may be needed to
circumvent this.

Another possible issue: KEY_EVENT has a preference over a user input,
so a stream of KEY_EVENT's can make input hard.  Maybe use
result_flags as in input parameter too, which specifies whether the
user input should have higher precedence?

Also: I took an opportunity to document kgetch() better.

Enjoy,
Ilya
@


1.2
log
@remove "new" libncurses:
* libncurses can do about the same things as our current libcurses,
  with about the same bugs regarding japanese character positions
  and cursor positioning in an uxterm (and lynx width bugs)
* libncurses cannot, however, make use of terminfo.db and neither
  do I want to restrict it to termcap nor do we want the zillions
  of files under /usr/share/terminfo like the clueless leenocksers
  (except if we had reiserfs)
* libncursesw suffers from the same limitations as libncurses
* libncursesw does not correctly display any text in an uxterm
  except for some links in lynx (but not ordinary text) - this
  might have something to do with "fancy curses" though
* libmenu has not yet been ported, is easy though
* libpanel neither

thus the developers decided it's not worth to continue
investing work into it until these flaws are found and
fixed

furthermore, upgrading our curses is not easily possible,
nor is it possible at all to get hands on a distfile of
ncurses-5.2-20010224 so we can't diff against the vendor;
thus millert@@openbsd.org is the only person who can solve
this dilemma, I think
@
text
@@


1.1
log
@Initial revision
@
text
@@


1.1.109.1
log
@Import Tom Dickey's ncurses 5.5 (quite stripped down)
@
text
@@
