head	1.8;
access;
symbols
	cvs-201210191930:1.1.1.7
	MIRBSD_10:1.5.0.2
	MIRBSD_10_BASE:1.5
	cvs-200705171630:1.1.1.6
	cvs-200702051630:1.1.1.5
	MIRBSD_9_BASE:1.1.1.4
	MIRBSD_8:1.1.1.4.0.2
	MIRBSD_8_BASE:1.1.1.4
	cvs-200507211800:1.1.1.4
	cvs-200505050030:1.1.1.3
	cvs-200504291700:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.10.31.13.23.21;	author tg;	state Exp;
branches;
next	1.7;
commitid	10054538D515357904D;

1.7
date	2013.10.31.20.06.29;	author tg;	state Exp;
branches;
next	1.6;
commitid	1005272B7081B0E5655;

1.6
date	2012.10.19.19.58.16;	author tg;	state Exp;
branches;
next	1.5;
commitid	1005081B0E54727ACCA;

1.5
date	2007.05.17.17.15.34;	author tg;	state Exp;
branches;
next	1.4;
commitid	100464C8DC46A1A51B5;

1.4
date	2007.05.17.16.48.21;	author tg;	state Exp;
branches;
next	1.3;
commitid	100464C876417B6519F;

1.3
date	2007.05.17.16.40.57;	author tg;	state Exp;
branches;
next	1.2;
commitid	100464C85AF54416520;

1.2
date	2007.02.05.16.47.51;	author tg;	state Exp;
branches;
next	1.1;
commitid	10045C75FC72C669FF3;

1.1
date	2005.02.05.17.25.14;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.25.14;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.29.17.05.23;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.05.05.00.32.58;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	48e9427969c07d49;

1.1.1.4
date	2005.07.21.20.53.51;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	560042e0092f571e;

1.1.1.5
date	2007.02.05.16.38.51;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	10045C75DA6486B10AC;

1.1.1.6
date	2007.05.17.16.38.22;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	100464C84A31EC59432;

1.1.1.7
date	2012.10.19.19.33.47;	author tg;	state Exp;
branches;
next	;
commitid	1005081AB336FC5E505;


desc
@@


1.8
log
@fix accidental <evutil.h> bleeding into <event.h>, from gmane.os.openbsd.tech
@
text
@/*	$OpenBSD: event.h,v 1.25 2012/08/28 09:09:56 pascal Exp $	*/

/*
 * Copyright © 2013, 2014
 *	Thorsten “mirabilos” Glaser <tg@@mirbsd.org>
 * Copyright (c) 2000-2007 Niels Provos <provos@@citi.umich.edu>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#ifndef _EVENT_H_
#define _EVENT_H_ "$MirOS$"

/** @@mainpage

  @@section intro Introduction

  libevent is an event notification library for developing scalable network
  servers.  The libevent API provides a mechanism to execute a callback
  function when a specific event occurs on a file descriptor or after a
  timeout has been reached. Furthermore, libevent also support callbacks due
  to signals or regular timeouts.

  libevent is meant to replace the event loop found in event driven network
  servers. An application just needs to call event_dispatch() and then add or
  remove events dynamically without having to change the event loop.

  Currently, libevent supports /dev/poll, kqueue(2), select(2), poll(2) and
  epoll(4). It also has experimental support for real-time signals. The
  internal event mechanism is completely independent of the exposed event API,
  and a simple update of libevent can provide new functionality without having
  to redesign the applications. As a result, Libevent allows for portable
  application development and provides the most scalable event notification
  mechanism available on an operating system. Libevent can also be used for
  multi-threaded applications; see Steven Grimm's explanation. Libevent should
  compile on Linux, *BSD, Mac OS X, Solaris and Windows.

  @@section usage Standard usage

  Every program that uses libevent must include the <event.h> header, and pass
  the -levent flag to the linker.  Before using any of the functions in the
  library, you must call event_init() or event_base_new() to perform one-time
  initialization of the libevent library.

  @@section event Event notification

  For each file descriptor that you wish to monitor, you must declare an event
  structure and call event_set() to initialize the members of the structure.
  To enable notification, you add the structure to the list of monitored
  events by calling event_add().  The event structure must remain allocated as
  long as it is active, so it should be allocated on the heap. Finally, you
  call event_dispatch() to loop and dispatch events.

  @@section bufferevent I/O Buffers

  libevent provides an abstraction on top of the regular event callbacks. This
  abstraction is called a buffered event. A buffered event provides input and
  output buffers that get filled and drained automatically. The user of a
  buffered event no longer deals directly with the I/O, but instead is reading
  from input and writing to output buffers.

  Once initialized via bufferevent_new(), the bufferevent structure can be
  used repeatedly with bufferevent_enable() and bufferevent_disable().
  Instead of reading and writing directly to a socket, you would call
  bufferevent_read() and bufferevent_write().

  When read enabled the bufferevent will try to read from the file descriptor
  and call the read callback. The write callback is executed whenever the
  output buffer is drained below the write low watermark, which is 0 by
  default.

  @@section timers Timers

  libevent can also be used to create timers that invoke a callback after a
  certain amount of time has expired. The evtimer_set() function prepares an
  event struct to be used as a timer. To activate the timer, call
  evtimer_add(). Timers can be deactivated by calling evtimer_del().

  @@section timeouts Timeouts

  In addition to simple timers, libevent can assign timeout events to file
  descriptors that are triggered whenever a certain amount of time has passed
  with no activity on a file descriptor.  The timeout_set() function
  initializes an event struct for use as a timeout. Once initialized, the
  event must be activated by using timeout_add().  To cancel the timeout, call
  timeout_del().

  @@section evdns Asynchronous DNS resolution

  libevent provides an asynchronous DNS resolver that should be used instead
  of the standard DNS resolver functions.  These functions can be imported by
  including the <evdns.h> header in your program. Before using any of the
  resolver functions, you must call evdns_init() to initialize the library. To
  convert a hostname to an IP address, you call the evdns_resolve_ipv4()
  function.  To perform a reverse lookup, you would call the
  evdns_resolve_reverse() function.  All of these functions use callbacks to
  avoid blocking while the lookup is performed.

  @@section evhttp Event-driven HTTP servers

  libevent provides a very simple event-driven HTTP server that can be
  embedded in your program and used to service HTTP requests.

  To use this capability, you need to include the <evhttp.h> header in your
  program.  You create the server by calling evhttp_new(). Add addresses and
  ports to listen on with evhttp_bind_socket(). You then register one or more
  callbacks to handle incoming requests.  Each URI can be assigned a callback
  via the evhttp_set_cb() function.  A generic callback function can also be
  registered via evhttp_set_gencb(); this callback will be invoked if no other
  callbacks have been registered for a given URI.

  @@section evrpc A framework for RPC servers and clients
 
  libevents provides a framework for creating RPC servers and clients.  It
  takes care of marshaling and unmarshaling all data structures.

  @@section api API Reference

  To browse the complete documentation of the libevent API, click on any of
  the following links.

  event.h
  The primary libevent header

  evdns.h
  Asynchronous DNS resolution

  evhttp.h
  An embedded libevent-based HTTP server

  evrpc.h
  A framework for creating RPC servers and clients

 */

/** @@file event.h

  A library for writing event-driven network servers

 */

#ifdef __cplusplus
extern "C" {
#endif

#include <sys/types.h>
#include <sys/time.h>
#include <sys/queue.h>

#include <stdarg.h>
#include <stdint.h>

#ifndef ev_inttypes_defined
#define ev_uint64_t uint64_t
#define ev_int64_t int64_t
#define ev_uint32_t uint32_t
#define ev_uint16_t uint16_t
#define ev_uint8_t uint8_t
#define ev_inttypes_defined
#endif

#define EVLIST_TIMEOUT	0x01
#define EVLIST_INSERTED	0x02
#define EVLIST_SIGNAL	0x04
#define EVLIST_ACTIVE	0x08
#define EVLIST_INTERNAL	0x10
#define EVLIST_INIT	0x80

/* EVLIST_X_ Private space: 0x1000-0xf000 */
#define EVLIST_ALL	(0xf000 | 0x9f)

#define EV_TIMEOUT	0x01
#define EV_READ		0x02
#define EV_WRITE	0x04
#define EV_SIGNAL	0x08
#define EV_PERSIST	0x10	/* Persistent event */

struct event_base;
#ifndef EVENT_NO_STRUCT
struct event {
	TAILQ_ENTRY (event) ev_next;
	TAILQ_ENTRY (event) ev_active_next;
	TAILQ_ENTRY (event) ev_signal_next;
	unsigned int min_heap_idx;	/* for managing timeouts */

	struct event_base *ev_base;

	int ev_fd;
	short ev_events;
	short ev_ncalls;
	short *ev_pncalls;	/* Allows deletes in callback */

	struct timeval ev_timeout;

	int ev_pri;		/* smaller numbers are higher priority */

	void (*ev_callback)(int, short, void *arg);
	void *ev_arg;

	int ev_res;		/* result passed to event callback */
	int ev_flags;
};
#else
struct event;
#endif

#define EVENT_SIGNAL(ev)	(int)(ev)->ev_fd
#define EVENT_FD(ev)		(int)(ev)->ev_fd

/*
 * Key-Value pairs.  Can be used for HTTP headers but also for
 * query argument parsing.
 */
struct evkeyval {
	TAILQ_ENTRY(evkeyval) next;

	char *key;
	char *value;
};

TAILQ_HEAD (event_list, event);
TAILQ_HEAD (evkeyvalq, evkeyval);

/**
  Initialize the event API.

  Use event_base_new() to initialize a new event base, but does not set
  the current_base global.   If using only event_base_new(), each event
  added must have an event base set with event_base_set()

  @@see event_base_set(), event_base_free(), event_init()
 */
struct event_base *event_base_new(void);

/**
  Initialize the event API.

  The event API needs to be initialized with event_init() before it can be
  used.  Sets the current_base global representing the default base for
  events that have no base associated with them.

  @@see event_base_set(), event_base_new()
 */
struct event_base *event_init(void);

/**
  Reinitialized the event base after a fork

  Some event mechanisms do not survive across fork.   The event base needs
  to be reinitialized with the event_reinit() function.

  @@param base the event base that needs to be re-initialized
  @@return 0 if successful, or -1 if some events could not be re-added.
  @@see event_base_new(), event_init()
*/
int event_reinit(struct event_base *base);

/**
  Loop to process events.

  In order to process events, an application needs to call
  event_dispatch().  This function only returns on error, and should
  replace the event core of the application program.

  @@see event_base_dispatch()
 */
int event_dispatch(void);


/**
  Threadsafe event dispatching loop.

  @@param eb the event_base structure returned by event_init()
  @@see event_init(), event_dispatch()
 */
int event_base_dispatch(struct event_base *);


/**
 Get the kernel event notification mechanism used by libevent.
 
 @@param eb the event_base structure returned by event_base_new()
 @@return a string identifying the kernel event mechanism (kqueue, epoll, etc.)
 */
const char *event_base_get_method(struct event_base *);
        
        
/**
  Deallocate all memory associated with an event_base, and free the base.

  Note that this function will not close any fds or free any memory passed
  to event_set as the argument to callback.

  @@param eb an event_base to be freed
 */
void event_base_free(struct event_base *);


#define _EVENT_LOG_DEBUG 0
#define _EVENT_LOG_MSG   1
#define _EVENT_LOG_WARN  2
#define _EVENT_LOG_ERR   3
typedef void (*event_log_cb)(int severity, const char *msg);
/**
  Redirect libevent's log messages.

  @@param cb a function taking two arguments: an integer severity between
     _EVENT_LOG_DEBUG and _EVENT_LOG_ERR, and a string.  If cb is NULL,
	 then the default log is used.
  */
void event_set_log_callback(event_log_cb cb);

/**
  Associate a different event base with an event.

  @@param eb the event base
  @@param ev the event
 */
int event_base_set(struct event_base *, struct event *);

/**
 event_loop() flags
 */
/*@@{*/
#define EVLOOP_ONCE	0x01	/**< Block at most once. */
#define EVLOOP_NONBLOCK	0x02	/**< Do not block. */
/*@@}*/

/**
  Handle events.

  This is a more flexible version of event_dispatch().

  @@param flags any combination of EVLOOP_ONCE | EVLOOP_NONBLOCK
  @@return 0 if successful, -1 if an error occurred, or 1 if no events were
    registered.
  @@see event_loopexit(), event_base_loop()
*/
int event_loop(int);

/**
  Handle events (threadsafe version).

  This is a more flexible version of event_base_dispatch().

  @@param eb the event_base structure returned by event_init()
  @@param flags any combination of EVLOOP_ONCE | EVLOOP_NONBLOCK
  @@return 0 if successful, -1 if an error occurred, or 1 if no events were
    registered.
  @@see event_loopexit(), event_base_loop()
  */
int event_base_loop(struct event_base *, int);

/**
  Exit the event loop after the specified time.

  The next event_loop() iteration after the given timer expires will
  complete normally (handling all queued events) then exit without
  blocking for events again.

  Subsequent invocations of event_loop() will proceed normally.

  @@param tv the amount of time after which the loop should terminate.
  @@return 0 if successful, or -1 if an error occurred
  @@see event_loop(), event_base_loop(), event_base_loopexit()
  */
int event_loopexit(const struct timeval *);


/**
  Exit the event loop after the specified time (threadsafe variant).

  The next event_base_loop() iteration after the given timer expires will
  complete normally (handling all queued events) then exit without
  blocking for events again.

  Subsequent invocations of event_base_loop() will proceed normally.

  @@param eb the event_base structure returned by event_init()
  @@param tv the amount of time after which the loop should terminate.
  @@return 0 if successful, or -1 if an error occurred
  @@see event_loopexit()
 */
int event_base_loopexit(struct event_base *, const struct timeval *);

/**
  Abort the active event_loop() immediately.

  event_loop() will abort the loop after the next event is completed;
  event_loopbreak() is typically invoked from this event's callback.
  This behavior is analogous to the "break;" statement.

  Subsequent invocations of event_loop() will proceed normally.

  @@return 0 if successful, or -1 if an error occurred
  @@see event_base_loopbreak(), event_loopexit()
 */
int event_loopbreak(void);

/**
  Abort the active event_base_loop() immediately.

  event_base_loop() will abort the loop after the next event is completed;
  event_base_loopbreak() is typically invoked from this event's callback.
  This behavior is analogous to the "break;" statement.

  Subsequent invocations of event_loop() will proceed normally.

  @@param eb the event_base structure returned by event_init()
  @@return 0 if successful, or -1 if an error occurred
  @@see event_base_loopexit
 */
int event_base_loopbreak(struct event_base *);


/**
  Add a timer event.

  @@param ev the event struct
  @@param tv timeval struct
 */
#define evtimer_add(ev, tv)		event_add(ev, tv)


/**
  Define a timer event.

  @@param ev event struct to be modified
  @@param cb callback function
  @@param arg argument that will be passed to the callback function
 */
#define evtimer_set(ev, cb, arg)	event_set(ev, -1, 0, cb, arg)


/**
 * Delete a timer event.
 *
 * @@param ev the event struct to be disabled
 */
#define evtimer_del(ev)			event_del(ev)
#define evtimer_pending(ev, tv)		event_pending(ev, EV_TIMEOUT, tv)
#define evtimer_initialized(ev)		((ev)->ev_flags & EVLIST_INIT)

#ifdef EVENT_DEPRECATED
/*
 * timeout_* are collision-prone names for macros, and they are
 * deprecated. Define EVENT_DEPRECATED to expose them anyway.
 *
 * It is recommended evtimer_* be used instead.
 */

/**
 * Add a timeout event.
 *
 * @@param ev the event struct to be disabled
 * @@param tv the timeout value, in seconds
 */
#define timeout_add(ev, tv)		event_add(ev, tv)


/**
 * Define a timeout event.
 *
 * @@param ev the event struct to be defined
 * @@param cb the callback to be invoked when the timeout expires
 * @@param arg the argument to be passed to the callback
 */
#define timeout_set(ev, cb, arg)	event_set(ev, -1, 0, cb, arg)


/**
 * Disable a timeout event.
 *
 * @@param ev the timeout event to be disabled
 */
#define timeout_del(ev)			event_del(ev)

#define timeout_pending(ev, tv)		event_pending(ev, EV_TIMEOUT, tv)
#define timeout_initialized(ev)		((ev)->ev_flags & EVLIST_INIT)

#endif /* EVENT_DEPRECATED */

#define signal_add(ev, tv)		event_add(ev, tv)
#define signal_set(ev, x, cb, arg)	\
	event_set(ev, x, EV_SIGNAL|EV_PERSIST, cb, arg)
#define signal_del(ev)			event_del(ev)
#define signal_pending(ev, tv)		event_pending(ev, EV_SIGNAL, tv)
#define signal_initialized(ev)		((ev)->ev_flags & EVLIST_INIT)

/**
  Prepare an event structure to be added.

  The function event_set() prepares the event structure ev to be used in
  future calls to event_add() and event_del().  The event will be prepared to
  call the function specified by the fn argument with an int argument
  indicating the file descriptor, a short argument indicating the type of
  event, and a void * argument given in the arg argument.  The fd indicates
  the file descriptor that should be monitored for events.  The events can be
  either EV_READ, EV_WRITE, or both.  Indicating that an application can read
  or write from the file descriptor respectively without blocking.

  The function fn will be called with the file descriptor that triggered the
  event and the type of event which will be either EV_TIMEOUT, EV_SIGNAL,
  EV_READ, or EV_WRITE.  The additional flag EV_PERSIST makes an event_add()
  persistent until event_del() has been called.

  @@param ev an event struct to be modified
  @@param fd the file descriptor to be monitored
  @@param event desired events to monitor; can be EV_READ and/or EV_WRITE
  @@param fn callback function to be invoked when the event occurs
  @@param arg an argument to be passed to the callback function

  @@see event_add(), event_del(), event_once()

 */
void event_set(struct event *, int, short, void (*)(int, short, void *), void *);

/**
  Schedule a one-time event to occur.

  The function event_once() is similar to event_set().  However, it schedules
  a callback to be called exactly once and does not require the caller to
  prepare an event structure.

  @@param fd a file descriptor to monitor
  @@param events event(s) to monitor; can be any of EV_TIMEOUT | EV_READ |
         EV_WRITE
  @@param callback callback function to be invoked when the event occurs
  @@param arg an argument to be passed to the callback function
  @@param timeout the maximum amount of time to wait for the event, or NULL
         to wait forever
  @@return 0 if successful, or -1 if an error occurred
  @@see event_set()

 */
int event_once(int, short, void (*)(int, short, void *), void *,
    const struct timeval *);


/**
  Schedule a one-time event (threadsafe variant)

  The function event_base_once() is similar to event_set().  However, it
  schedules a callback to be called exactly once and does not require the
  caller to prepare an event structure.

  @@param base an event_base returned by event_init()
  @@param fd a file descriptor to monitor
  @@param events event(s) to monitor; can be any of EV_TIMEOUT | EV_READ |
         EV_WRITE
  @@param callback callback function to be invoked when the event occurs
  @@param arg an argument to be passed to the callback function
  @@param timeout the maximum amount of time to wait for the event, or NULL
         to wait forever
  @@return 0 if successful, or -1 if an error occurred
  @@see event_once()
 */
int event_base_once(struct event_base *base, int fd, short events,
    void (*callback)(int, short, void *), void *arg,
    const struct timeval *timeout);


/**
  Add an event to the set of monitored events.

  The function event_add() schedules the execution of the ev event when the
  event specified in event_set() occurs or in at least the time specified in
  the tv.  If tv is NULL, no timeout occurs and the function will only be
  called if a matching event occurs on the file descriptor.  The event in the
  ev argument must be already initialized by event_set() and may not be used
  in calls to event_set() until it has timed out or been removed with
  event_del().  If the event in the ev argument already has a scheduled
  timeout, the old timeout will be replaced by the new one.

  @@param ev an event struct initialized via event_set()
  @@param timeout the maximum amount of time to wait for the event, or NULL
         to wait forever
  @@return 0 if successful, or -1 if an error occurred
  @@see event_del(), event_set()
  */
int event_add(struct event *ev, const struct timeval *timeout);


/**
  Remove an event from the set of monitored events.

  The function event_del() will cancel the event in the argument ev.  If the
  event has already executed or has never been added the call will have no
  effect.

  @@param ev an event struct to be removed from the working set
  @@return 0 if successful, or -1 if an error occurred
  @@see event_add()
 */
int event_del(struct event *);

void event_active(struct event *, int, short);


/**
  Checks if a specific event is pending or scheduled.

  @@param ev an event struct previously passed to event_add()
  @@param event the requested event type; any of EV_TIMEOUT|EV_READ|
         EV_WRITE|EV_SIGNAL
  @@param tv an alternate timeout (FIXME - is this true?)

  @@return 1 if the event is pending, or 0 if the event has not occurred

 */
int event_pending(struct event *ev, short event, struct timeval *tv);


/**
  Test if an event structure has been initialized.

  The event_initialized() macro can be used to check if an event has been
  initialized.

  @@param ev an event structure to be tested
  @@return 1 if the structure has been initialized, or 0 if it has not been
          initialized
 */
#ifdef WIN32
#define event_initialized(ev)		((ev)->ev_flags & EVLIST_INIT && (ev)->ev_fd != (int)INVALID_HANDLE_VALUE)
#else
#define event_initialized(ev)		((ev)->ev_flags & EVLIST_INIT)
#endif


/**
  Get the libevent version number.

  @@return a string containing the version number of libevent
 */
const char *event_get_version(void);


/**
  Get the kernel event notification mechanism used by libevent.

  @@return a string identifying the kernel event mechanism (kqueue, epoll, etc.)
 */
const char *event_get_method(void);


/**
  Set the number of different event priorities.

  By default libevent schedules all active events with the same priority.
  However, some time it is desirable to process some events with a higher
  priority than others.  For that reason, libevent supports strict priority
  queues.  Active events with a lower priority are always processed before
  events with a higher priority.

  The number of different priorities can be set initially with the
  event_priority_init() function.  This function should be called before the
  first call to event_dispatch().  The event_priority_set() function can be
  used to assign a priority to an event.  By default, libevent assigns the
  middle priority to all events unless their priority is explicitly set.

  @@param npriorities the maximum number of priorities
  @@return 0 if successful, or -1 if an error occurred
  @@see event_base_priority_init(), event_priority_set()

 */
int	event_priority_init(int);


/**
  Set the number of different event priorities (threadsafe variant).

  See the description of event_priority_init() for more information.

  @@param eb the event_base structure returned by event_init()
  @@param npriorities the maximum number of priorities
  @@return 0 if successful, or -1 if an error occurred
  @@see event_priority_init(), event_priority_set()
 */
int	event_base_priority_init(struct event_base *, int);


/**
  Assign a priority to an event.

  @@param ev an event struct
  @@param priority the new priority to be assigned
  @@return 0 if successful, or -1 if an error occurred
  @@see event_priority_init()
  */
int	event_priority_set(struct event *, int);


/* These functions deal with buffering input and output */

struct evbuffer {
	u_char *buffer;
	u_char *orig_buffer;

	size_t misalign;
	size_t totallen;
	size_t off;

	void (*cb)(struct evbuffer *, size_t, size_t, void *);
	void *cbarg;
};

/* Just for error reporting - use other constants otherwise */
#define EVBUFFER_READ		0x01
#define EVBUFFER_WRITE		0x02
#define EVBUFFER_EOF		0x10
#define EVBUFFER_ERROR		0x20
#define EVBUFFER_TIMEOUT	0x40

struct bufferevent;
typedef void (*evbuffercb)(struct bufferevent *, void *);
typedef void (*everrorcb)(struct bufferevent *, short what, void *);

struct event_watermark {
	size_t low;
	size_t high;
};

#ifndef EVENT_NO_STRUCT
struct bufferevent {
	struct event_base *ev_base;

	struct event ev_read;
	struct event ev_write;

	struct evbuffer *input;
	struct evbuffer *output;

	struct event_watermark wm_read;
	struct event_watermark wm_write;

	evbuffercb readcb;
	evbuffercb writecb;
	everrorcb errorcb;
	void *cbarg;

	int timeout_read;	/* in seconds */
	int timeout_write;	/* in seconds */

	short enabled;	/* events that are currently enabled */
};
#endif

/**
  Create a new bufferevent.

  libevent provides an abstraction on top of the regular event callbacks.
  This abstraction is called a buffered event.  A buffered event provides
  input and output buffers that get filled and drained automatically.  The
  user of a buffered event no longer deals directly with the I/O, but
  instead is reading from input and writing to output buffers.

  Once initialized, the bufferevent structure can be used repeatedly with
  bufferevent_enable() and bufferevent_disable().

  When read enabled the bufferevent will try to read from the file descriptor
  and call the read callback.  The write callback is executed whenever the
  output buffer is drained below the write low watermark, which is 0 by
  default.

  If multiple bases are in use, bufferevent_base_set() must be called before
  enabling the bufferevent for the first time.

  @@param fd the file descriptor from which data is read and written to.
  		This file descriptor is not allowed to be a pipe(2).
  @@param readcb callback to invoke when there is data to be read, or NULL if
         no callback is desired
  @@param writecb callback to invoke when the file descriptor is ready for
         writing, or NULL if no callback is desired
  @@param errorcb callback to invoke when there is an error on the file
         descriptor
  @@param cbarg an argument that will be supplied to each of the callbacks
         (readcb, writecb, and errorcb)
  @@return a pointer to a newly allocated bufferevent struct, or NULL if an
          error occurred
  @@see bufferevent_base_set(), bufferevent_free()
  */
struct bufferevent *bufferevent_new(int fd,
    evbuffercb readcb, evbuffercb writecb, everrorcb errorcb, void *cbarg);


/**
  Assign a bufferevent to a specific event_base.

  @@param base an event_base returned by event_init()
  @@param bufev a bufferevent struct returned by bufferevent_new()
  @@return 0 if successful, or -1 if an error occurred
  @@see bufferevent_new()
 */
int bufferevent_base_set(struct event_base *base, struct bufferevent *bufev);


/**
  Assign a priority to a bufferevent.

  @@param bufev a bufferevent struct
  @@param pri the priority to be assigned
  @@return 0 if successful, or -1 if an error occurred
  */
int bufferevent_priority_set(struct bufferevent *bufev, int pri);


/**
  Deallocate the storage associated with a bufferevent structure.

  @@param bufev the bufferevent structure to be freed.
  */
void bufferevent_free(struct bufferevent *bufev);


/**
  Changes the callbacks for a bufferevent.

  @@param bufev the bufferevent object for which to change callbacks
  @@param readcb callback to invoke when there is data to be read, or NULL if
         no callback is desired
  @@param writecb callback to invoke when the file descriptor is ready for
         writing, or NULL if no callback is desired
  @@param errorcb callback to invoke when there is an error on the file
         descriptor
  @@param cbarg an argument that will be supplied to each of the callbacks
         (readcb, writecb, and errorcb)
  @@see bufferevent_new()
  */
void bufferevent_setcb(struct bufferevent *bufev,
    evbuffercb readcb, evbuffercb writecb, everrorcb errorcb, void *cbarg);

/**
  Changes the file descriptor on which the bufferevent operates.

  @@param bufev the bufferevent object for which to change the file descriptor
  @@param fd the file descriptor to operate on
*/
void bufferevent_setfd(struct bufferevent *bufev, int fd);

/**
  Write data to a bufferevent buffer.

  The bufferevent_write() function can be used to write data to the file
  descriptor.  The data is appended to the output buffer and written to the
  descriptor automatically as it becomes available for writing.

  @@param bufev the bufferevent to be written to
  @@param data a pointer to the data to be written
  @@param size the length of the data, in bytes
  @@return 0 if successful, or -1 if an error occurred
  @@see bufferevent_write_buffer()
  */
int bufferevent_write(struct bufferevent *bufev,
    const void *data, size_t size);


/**
  Write data from an evbuffer to a bufferevent buffer.  The evbuffer is
  being drained as a result.

  @@param bufev the bufferevent to be written to
  @@param buf the evbuffer to be written
  @@return 0 if successful, or -1 if an error occurred
  @@see bufferevent_write()
 */
int bufferevent_write_buffer(struct bufferevent *bufev, struct evbuffer *buf);


/**
  Read data from a bufferevent buffer.

  The bufferevent_read() function is used to read data from the input buffer.

  @@param bufev the bufferevent to be read from
  @@param data pointer to a buffer that will store the data
  @@param size the size of the data buffer, in bytes
  @@return the amount of data read, in bytes.
 */
size_t bufferevent_read(struct bufferevent *bufev, void *data, size_t size);

/**
  Enable a bufferevent.

  @@param bufev the bufferevent to be enabled
  @@param event any combination of EV_READ | EV_WRITE.
  @@return 0 if successful, or -1 if an error occurred
  @@see bufferevent_disable()
 */
int bufferevent_enable(struct bufferevent *bufev, short event);


/**
  Disable a bufferevent.

  @@param bufev the bufferevent to be disabled
  @@param event any combination of EV_READ | EV_WRITE.
  @@return 0 if successful, or -1 if an error occurred
  @@see bufferevent_enable()
 */
int bufferevent_disable(struct bufferevent *bufev, short event);


/**
  Set the read and write timeout for a buffered event.

  @@param bufev the bufferevent to be modified
  @@param timeout_read the read timeout
  @@param timeout_write the write timeout
 */
void bufferevent_settimeout(struct bufferevent *bufev,
    int timeout_read, int timeout_write);


/**
  Sets the watermarks for read and write events.

  On input, a bufferevent does not invoke the user read callback unless
  there is at least low watermark data in the buffer.   If the read buffer
  is beyond the high watermark, the buffevent stops reading from the network.

  On output, the user write callback is invoked whenever the buffered data
  falls below the low watermark.

  @@param bufev the bufferevent to be modified
  @@param events EV_READ, EV_WRITE or both
  @@param lowmark the lower watermark to set
  @@param highmark the high watermark to set
*/

void bufferevent_setwatermark(struct bufferevent *bufev, short events,
    size_t lowmark, size_t highmark);

#define EVBUFFER_LENGTH(x)	(x)->off
#define EVBUFFER_DATA(x)	(x)->buffer
#define EVBUFFER_INPUT(x)	(x)->input
#define EVBUFFER_OUTPUT(x)	(x)->output


/**
  Allocate storage for a new evbuffer.

  @@return a pointer to a newly allocated evbuffer struct, or NULL if an error
          occurred
 */
struct evbuffer *evbuffer_new(void);


/**
  Deallocate storage for an evbuffer.

  @@param pointer to the evbuffer to be freed
 */
void evbuffer_free(struct evbuffer *);


/**
  Expands the available space in an event buffer.

  Expands the available space in the event buffer to at least datlen

  @@param buf the event buffer to be expanded
  @@param datlen the new minimum length requirement
  @@return 0 if successful, or -1 if an error occurred
*/
int evbuffer_expand(struct evbuffer *, size_t);


/**
  Append data to the end of an evbuffer.

  @@param buf the event buffer to be appended to
  @@param data pointer to the beginning of the data buffer
  @@param datlen the number of bytes to be copied from the data buffer
 */
int evbuffer_add(struct evbuffer *, const void *, size_t);



/**
  Read data from an event buffer and drain the bytes read.

  @@param buf the event buffer to be read from
  @@param data the destination buffer to store the result
  @@param datlen the maximum size of the destination buffer
  @@return the number of bytes read
 */
int evbuffer_remove(struct evbuffer *, void *, size_t);


/**
 * Read a single line from an event buffer.
 *
 * Reads a line terminated by either '\r\n', '\n\r' or '\r' or '\n'.
 * The returned buffer needs to be freed by the caller.
 *
 * @@param buffer the evbuffer to read from
 * @@return pointer to a single line, or NULL if an error occurred
 */
char *evbuffer_readline(struct evbuffer *);


/** Used to tell evbuffer_readln what kind of line-ending to look for.
 */
enum evbuffer_eol_style {
	/** Any sequence of CR and LF characters is acceptable as an EOL. */
	EVBUFFER_EOL_ANY,
	/** An EOL is an LF, optionally preceded by a CR.  This style is
	 * most useful for implementing text-based internet protocols. */
	EVBUFFER_EOL_CRLF,
	/** An EOL is a CR followed by an LF. */
	EVBUFFER_EOL_CRLF_STRICT,
	/** An EOL is a LF. */
        EVBUFFER_EOL_LF
};

/**
 * Read a single line from an event buffer.
 *
 * Reads a line terminated by an EOL as determined by the evbuffer_eol_style
 * argument.  Returns a newly allocated nul-terminated string; the caller must
 * free the returned value.  The EOL is not included in the returned string.
 *
 * @@param buffer the evbuffer to read from
 * @@param n_read_out if non-NULL, points to a size_t that is set to the
 *       number of characters in the returned string.  This is useful for
 *       strings that can contain NUL characters.
 * @@param eol_style the style of line-ending to use.
 * @@return pointer to a single line, or NULL if an error occurred
 */
char *evbuffer_readln(struct evbuffer *buffer, size_t *n_read_out,
    enum evbuffer_eol_style eol_style);


/**
  Move data from one evbuffer into another evbuffer.

  This is a destructive add.  The data from one buffer moves into
  the other buffer. The destination buffer is expanded as needed.

  @@param outbuf the output buffer
  @@param inbuf the input buffer
  @@return 0 if successful, or -1 if an error occurred
 */
int evbuffer_add_buffer(struct evbuffer *, struct evbuffer *);


/**
  Append a formatted string to the end of an evbuffer.

  @@param buf the evbuffer that will be appended to
  @@param fmt a format string
  @@param ... arguments that will be passed to printf(3)
  @@return The number of bytes added if successful, or -1 if an error occurred.
 */
int evbuffer_add_printf(struct evbuffer *, const char *fmt, ...)
#ifdef __GNUC__
  __attribute__((__format__(__printf__, 2, 3)))
#endif
;


/**
  Append a va_list formatted string to the end of an evbuffer.

  @@param buf the evbuffer that will be appended to
  @@param fmt a format string
  @@param ap a varargs va_list argument array that will be passed to vprintf(3)
  @@return The number of bytes added if successful, or -1 if an error occurred.
 */
int evbuffer_add_vprintf(struct evbuffer *, const char *fmt, va_list ap)
#ifdef __GNUC__
    __attribute__((__format__(__printf__, 2, 0)))
#endif
;


/**
  Remove a specified number of bytes data from the beginning of an evbuffer.

  @@param buf the evbuffer to be drained
  @@param len the number of bytes to drain from the beginning of the buffer
 */
void evbuffer_drain(struct evbuffer *, size_t);


/**
  Write the contents of an evbuffer to a file descriptor.

  The evbuffer will be drained after the bytes have been successfully written.

  @@param buffer the evbuffer to be written and drained
  @@param fd the file descriptor to be written to
  @@return the number of bytes written, or -1 if an error occurred
  @@see evbuffer_read()
 */
int evbuffer_write(struct evbuffer *, int);


/**
  Read from a file descriptor and store the result in an evbuffer.

  @@param buf the evbuffer to store the result
  @@param fd the file descriptor to read from
  @@param howmuch the number of bytes to be read
  @@return the number of bytes read, or -1 if an error occurred
  @@see evbuffer_write()
 */
int evbuffer_read(struct evbuffer *, int, int);


/**
  Find a string within an evbuffer.

  @@param buffer the evbuffer to be searched
  @@param what the string to be searched for
  @@param len the length of the search string
  @@return a pointer to the beginning of the search string, or NULL if the search failed.
 */
u_char *evbuffer_find(struct evbuffer *, const u_char *, size_t);

/**
  Set a callback to invoke when the evbuffer is modified.

  @@param buffer the evbuffer to be monitored
  @@param cb the callback function to invoke when the evbuffer is modified
  @@param cbarg an argument to be provided to the callback function
 */
void evbuffer_setcb(struct evbuffer *, void (*)(struct evbuffer *, size_t, size_t, void *), void *);

/*
 * Marshaling tagged data - We assume that all tags are inserted in their
 * numeric order - so that unknown tags will always be higher than the
 * known ones - and we can just ignore the end of an event buffer.
 */

void evtag_init(void);

void evtag_marshal(struct evbuffer *evbuf, ev_uint32_t tag, const void *data,
    ev_uint32_t len);

/**
  Encode an integer and store it in an evbuffer.

  We encode integer's by nibbles; the first nibble contains the number
  of significant nibbles - 1;  this allows us to encode up to 64-bit
  integers.  This function is byte-order independent.

  @@param evbuf evbuffer to store the encoded number
  @@param number a 32-bit integer
 */
void encode_int(struct evbuffer *evbuf, ev_uint32_t number);

void evtag_marshal_int(struct evbuffer *evbuf, ev_uint32_t tag,
    ev_uint32_t integer);

void evtag_marshal_string(struct evbuffer *buf, ev_uint32_t tag,
    const char *string);

void evtag_marshal_timeval(struct evbuffer *evbuf, ev_uint32_t tag,
    struct timeval *tv);

int evtag_unmarshal(struct evbuffer *src, ev_uint32_t *ptag,
    struct evbuffer *dst);
int evtag_peek(struct evbuffer *evbuf, ev_uint32_t *ptag);
int evtag_peek_length(struct evbuffer *evbuf, ev_uint32_t *plength);
int evtag_payload_length(struct evbuffer *evbuf, ev_uint32_t *plength);
int evtag_consume(struct evbuffer *evbuf);

int evtag_unmarshal_int(struct evbuffer *evbuf, ev_uint32_t need_tag,
    ev_uint32_t *pinteger);

int evtag_unmarshal_fixed(struct evbuffer *src, ev_uint32_t need_tag,
    void *data, size_t len);

int evtag_unmarshal_string(struct evbuffer *evbuf, ev_uint32_t need_tag,
    char **pstring);

int evtag_unmarshal_timeval(struct evbuffer *evbuf, ev_uint32_t need_tag,
    struct timeval *ptv);

#define _EVENT_VERSION "1.4.14b-stable"

#ifdef __cplusplus
}
#endif

#endif /* _EVENT_H_ */
@


1.7
log
@adapt most __attribute__((…)) occurrences to new KNF style(9)
@
text
@a0 1
/*	$MirOS$ */
d4 1
a4 1
 * Copyright © 2013
d32 1
a32 1
#define _EVENT_H_
d173 8
a180 2
/* For int types. */
#include <evutil.h>
@


1.6
log
@merge latest stable-1.4 libevent
@
text
@d1 1
d5 2
d1073 1
a1073 1
  __attribute__((format(printf, 2, 3)))
d1088 1
a1088 1
    __attribute__((__format__ (__printf__, 2, 0)))
@


1.5
log
@__CRAZY=Yes clean, fixes a few real bugs
@
text
@d1 1
a1 1
/*	$OpenBSD: event.h,v 1.18 2007/03/19 15:12:49 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 2000-2004 Niels Provos <provos@@citi.umich.edu>
d30 129
a158 1
#define _EVENT_H_	"$MirOS: src/lib/libevent/event.h,v 1.4 2007/05/17 16:48:21 tg Exp $"
d164 4
d169 1
d171 2
a172 9
#ifdef WIN32
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#undef WIN32_LEAN_AND_MEAN
typedef unsigned char u_char;
typedef unsigned short u_short;
#endif

#define LIBEVENT_VERSION	"1.3b"
d188 1
a188 21
#define EV_PERSIST	0x10	/* Persistant event */

/* Fix so that ppl dont have to run with <sys/queue.h> */
#ifndef TAILQ_ENTRY
#define _EVENT_DEFINED_TQENTRY
#define TAILQ_ENTRY(type)						\
struct {								\
	struct type *tqe_next;	/* next element */			\
	struct type **tqe_prev;	/* address of previous next element */	\
}
#endif /* !TAILQ_ENTRY */
#ifndef RB_ENTRY
#define _EVENT_DEFINED_RBENTRY
#define RB_ENTRY(type)							\
struct {								\
	struct type *rbe_left;		/* left element */		\
	struct type *rbe_right;		/* right element */		\
	struct type *rbe_parent;	/* parent element */		\
	int rbe_color;			/* node color */		\
}
#endif /* !RB_ENTRY */
d191 1
d196 1
a196 1
	RB_ENTRY (event) ev_timeout_node;
d199 1
d215 3
a232 6
#ifdef _EVENT_DEFINED_TQENTRY
#undef TAILQ_ENTRY
struct event_list;
struct evkeyvalq;
#undef _EVENT_DEFINED_TQENTRY
#else
a234 15
#endif /* _EVENT_DEFINED_TQENTRY */
#ifdef _EVENT_DEFINED_RBENTRY
#undef RB_ENTRY
#undef _EVENT_DEFINED_RBENTRY
#endif /* _EVENT_DEFINED_RBENTRY */

struct eventop {
	const char *name;
	void *(*init)(void);
	int (*add)(void *, struct event *);
	int (*del)(void *, struct event *);
	int (*recalc)(struct event_base *, void *, int);
	int (*dispatch)(struct event_base *, void *, struct timeval *);
	void (*dealloc)(void *);
};
d236 40
a275 1
#define TIMEOUT_DEFAULT	{5, 0}
d277 2
a278 1
void *event_init(void);
d280 8
d289 19
d310 1
d316 7
d325 6
a330 1
/* Associate a different event base with an event */
d333 18
a350 2
#define EVLOOP_ONCE	0x01
#define EVLOOP_NONBLOCK	0x02
d352 12
a364 2
int event_loopexit(struct timeval *);	/* Causes the loop to exit */
int event_base_loopexit(struct event_base *, struct timeval *);
d366 68
d435 9
d445 7
d456 39
d502 26
a528 1
int event_once(int, short, void (*)(int, short, void *), void *, struct timeval *);
d530 77
a606 1
int event_add(struct event *, struct timeval *);
d608 1
a610 1
int event_pending(struct event *, short, struct timeval *);
d612 24
d642 6
a647 1
/* Some simple debugging functions */
d649 7
a657 1
/* These functions deal with event priorities */
d659 20
d680 12
d693 10
d705 1
d736 1
d738 2
d759 4
d764 31
d797 10
d808 9
d818 7
d826 53
a878 1
int bufferevent_write(struct bufferevent *bufev, void *data, size_t size);
d880 12
d893 9
d903 10
d914 9
d926 20
d951 7
d959 7
d967 11
d979 9
d989 11
d1001 11
d1013 44
d1058 10
d1069 14
a1082 1
    __attribute__((format (printf, 2, 3)));
d1084 12
a1095 1
    __attribute__((format (printf, 2, 0)));
d1097 12
d1110 11
d1122 10
d1133 8
d1151 5
a1155 2
void evtag_marshal(struct evbuffer *evbuf, u_int8_t tag, const void *data,
    u_int32_t len);
d1157 3
a1159 1
void encode_int(struct evbuffer *evbuf, u_int32_t number);
d1161 7
a1167 2
void evtag_marshal_int(struct evbuffer *evbuf, u_int8_t tag,
    u_int32_t integer);
d1169 1
a1169 1
void evtag_marshal_string(struct evbuffer *buf, u_int8_t tag,
d1172 1
a1172 1
void evtag_marshal_timeval(struct evbuffer *evbuf, u_int8_t tag,
d1175 1
a1175 3
void evtag_test(void);

int evtag_unmarshal(struct evbuffer *src, u_int8_t *ptag,
d1177 3
a1179 3
int evtag_peek(struct evbuffer *evbuf, u_int8_t *ptag);
int evtag_peek_length(struct evbuffer *evbuf, u_int32_t *plength);
int evtag_payload_length(struct evbuffer *evbuf, u_int32_t *plength);
d1182 2
a1183 2
int evtag_unmarshal_int(struct evbuffer *evbuf, u_int8_t need_tag,
    u_int32_t *pinteger);
d1185 2
a1186 2
int evtag_unmarshal_fixed(struct evbuffer *src, u_int8_t need_tag, void *data,
    size_t len);
d1188 1
a1188 1
int evtag_unmarshal_string(struct evbuffer *evbuf, u_int8_t need_tag,
d1191 1
a1191 1
int evtag_unmarshal_timeval(struct evbuffer *evbuf, u_int8_t need_tag,
d1194 2
@


1.4
log
@• how could they ever build this?
• rcsids
@
text
@d30 1
a30 1
#define _EVENT_H_	"$MirOS$"
d137 1
a137 1
	char *name;
a258 1
int bufferevent_base_set(struct event_base *base, struct bufferevent *bufev);
d284 4
a287 2
int evbuffer_add_printf(struct evbuffer *, const char *fmt, ...);
int evbuffer_add_vprintf(struct evbuffer *, const char *fmt, va_list ap);
@


1.3
log
@fastmerge
@
text
@d30 1
a30 1
#define _EVENT_H_
@


1.2
log
@add missing proto
XXX add it to event.3 too
@
text
@d1 1
a1 1
/*	$OpenBSD: event.h,v 1.16 2007/02/04 18:59:12 millert Exp $	*/
d43 1
d46 1
a46 1
#define LIBEVENT_VERSION	"1.1b"
d108 13
a120 2
#define EVENT_SIGNAL(ev)	(int)ev->ev_fd
#define EVENT_FD(ev)		(int)ev->ev_fd
d124 2
d129 1
d193 1
a193 1
#define event_initialized(ev)		((ev)->ev_flags & EVLIST_INIT && (ev)->ev_fd != INVALID_HANDLE_VALUE)
d262 1
d281 1
a281 1
int evbuffer_add(struct evbuffer *, void *, size_t);
d293 43
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: event.h,v 1.5 2004/04/28 06:53:12 brad Exp $	*/
d36 2
d39 1
d41 2
d45 2
d51 1
d55 1
a55 1
#define EVLIST_ALL	(0xf000 | 0x8f)
d83 1
d90 1
a90 4
#ifdef WIN32
	HANDLE ev_fd;
	OVERLAPPED overlap;
#else
a91 1
#endif
d98 2
d126 3
a128 2
	int (*recalc)(void *, int);
	int (*dispatch)(void *, struct timeval *);
d133 1
a133 1
void event_init(void);
d135 12
d151 1
d153 1
a153 4

int timeout_next(struct timeval *);
void timeout_correct(struct timeval *);
void timeout_process(void);
a160 6
#define timeout_add(ev, tv)		event_add(ev, tv)
#define timeout_set(ev, cb, arg)	event_set(ev, -1, 0, cb, arg)
#define timeout_del(ev)			event_del(ev)
#define timeout_pending(ev, tv)		event_pending(ev, EV_TIMEOUT, tv)
#define timeout_initialized(ev)		((ev)->ev_flags & EVLIST_INIT)

d183 10
d197 1
d199 1
d244 1
d247 1
d264 4
a267 1
int evbuffer_add(struct evbuffer *, u_char *, size_t);
d269 2
a270 1
int evbuffer_add_printf(struct evbuffer *, char *fmt, ...);
d274 1
a274 1
u_char *evbuffer_find(struct evbuffer *, u_char *, size_t);
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@improve my Frankenstein OS (*wink* you know who you are) further
sans wchar_t of course

this is the essence of reading >1200 commit messages which suck
due to not having the new format of ours...
@
text
@d1 1
a1 1
/*	$OpenBSD: event.h,v 1.9 2005/04/22 00:56:25 brad Exp $	*/
a36 1
#define WIN32_LEAN_AND_MEAN
a37 2
#undef WIN32_LEAN_AND_MEAN
typedef unsigned char u_char;
a39 2
#define LIBEVENT_VERSION	"1.0c"

a43 1
#define EVLIST_INTERNAL	0x10
d47 1
a47 1
#define EVLIST_ALL	(0xf000 | 0x9f)
a74 1
struct event_base;
d81 4
a84 1
	struct event_base *ev_base;
d86 1
a92 2
	int ev_pri;		/* smaller numbers are higher priority */

d119 2
a120 2
	int (*recalc)(struct event_base *, void *, int);
	int (*dispatch)(struct event_base *, void *, struct timeval *);
d125 1
a125 1
void *event_init(void);
a126 11
int event_base_dispatch(struct event_base *);

#define _EVENT_LOG_DEBUG 0
#define _EVENT_LOG_MSG   1
#define _EVENT_LOG_WARN  2
#define _EVENT_LOG_ERR   3
typedef void (*event_log_cb)(int severity, const char *msg);
void event_set_log_callback(event_log_cb cb);

/* Associate a different event base with an event */
int event_base_set(struct event_base *, struct event *);
a130 1
int event_base_loop(struct event_base *, int);
d132 4
a135 1
int event_base_loopexit(struct event_base *, struct timeval *);
d143 6
a170 10
/* Some simple debugging functions */
const char *event_get_version(void);
const char *event_get_method(void);

/* These functions deal with event priorities */

int	event_priority_init(int);
int	event_base_priority_init(struct event_base *, int);
int	event_priority_set(struct event *, int);

a174 1
	u_char *orig_buffer;
a175 1
	size_t misalign;
a221 1
int bufferevent_priority_set(struct bufferevent *bufev, int pri);
d238 1
a238 3
int evbuffer_expand(struct evbuffer *, size_t);
int evbuffer_add(struct evbuffer *, void *, size_t);
int evbuffer_remove(struct evbuffer *, void *, size_t);
@


1.1.1.3
log
@latest fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: event.h,v 1.10 2005/05/04 03:17:48 brad Exp $	*/
d43 1
a43 1
#define LIBEVENT_VERSION	"1.0d"
a261 1
char *evbuffer_readline(struct evbuffer *);
@


1.1.1.4
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d1 1
a1 1
/*	$OpenBSD: event.h,v 1.12 2005/06/18 01:52:22 brad Exp $	*/
d43 1
a43 1
#define LIBEVENT_VERSION	"1.1a"
@


1.1.1.5
log
@Import libevent 1.1b+fixes from OpenBSD-current, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: event.h,v 1.16 2007/02/04 18:59:12 millert Exp $	*/
a35 2
#include <stdarg.h>

d43 1
a43 1
#define LIBEVENT_VERSION	"1.1b"
a125 1
	void (*dealloc)(void *);
a132 1
void event_base_free(struct event_base *);
d264 1
a264 2
int evbuffer_add_printf(struct evbuffer *, const char *fmt, ...);
int evbuffer_add_vprintf(struct evbuffer *, const char *fmt, va_list ap);
d268 1
a268 1
u_char *evbuffer_find(struct evbuffer *, const u_char *, size_t);
@


1.1.1.6
log
@import latest libevent via openbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: event.h,v 1.18 2007/03/19 15:12:49 millert Exp $	*/
a42 1
typedef unsigned short u_short;
d45 1
a45 1
#define LIBEVENT_VERSION	"1.3b"
d107 2
a108 13
#define EVENT_SIGNAL(ev)	(int)(ev)->ev_fd
#define EVENT_FD(ev)		(int)(ev)->ev_fd

/*
 * Key-Value pairs.  Can be used for HTTP headers but also for
 * query argument parsing.
 */
struct evkeyval {
	TAILQ_ENTRY(evkeyval) next;

	char *key;
	char *value;
};
a111 2
struct event_list;
struct evkeyvalq;
a114 1
TAILQ_HEAD (evkeyvalq, evkeyval);
d178 1
a178 1
#define event_initialized(ev)		((ev)->ev_flags & EVLIST_INIT && (ev)->ev_fd != (int)INVALID_HANDLE_VALUE)
a245 1
int bufferevent_base_set(struct event_base *base, struct bufferevent *bufev);
d264 1
a264 1
int evbuffer_add(struct evbuffer *, const void *, size_t);
a275 43
/*
 * Marshaling tagged data - We assume that all tags are inserted in their
 * numeric order - so that unknown tags will always be higher than the
 * known ones - and we can just ignore the end of an event buffer.
 */

void evtag_init(void);

void evtag_marshal(struct evbuffer *evbuf, u_int8_t tag, const void *data,
    u_int32_t len);

void encode_int(struct evbuffer *evbuf, u_int32_t number);

void evtag_marshal_int(struct evbuffer *evbuf, u_int8_t tag,
    u_int32_t integer);

void evtag_marshal_string(struct evbuffer *buf, u_int8_t tag,
    const char *string);

void evtag_marshal_timeval(struct evbuffer *evbuf, u_int8_t tag,
    struct timeval *tv);

void evtag_test(void);

int evtag_unmarshal(struct evbuffer *src, u_int8_t *ptag,
    struct evbuffer *dst);
int evtag_peek(struct evbuffer *evbuf, u_int8_t *ptag);
int evtag_peek_length(struct evbuffer *evbuf, u_int32_t *plength);
int evtag_payload_length(struct evbuffer *evbuf, u_int32_t *plength);
int evtag_consume(struct evbuffer *evbuf);

int evtag_unmarshal_int(struct evbuffer *evbuf, u_int8_t need_tag,
    u_int32_t *pinteger);

int evtag_unmarshal_fixed(struct evbuffer *src, u_int8_t need_tag, void *data,
    size_t len);

int evtag_unmarshal_string(struct evbuffer *evbuf, u_int8_t need_tag,
    char **pstring);

int evtag_unmarshal_timeval(struct evbuffer *evbuf, u_int8_t need_tag,
    struct timeval *ptv);

@


1.1.1.7
log
@import latest stable 1.4 libevent, in the OpenBSD version (diff against portable version reviewed-okay)
@
text
@d1 1
a1 1
/*	$OpenBSD: event.h,v 1.25 2012/08/28 09:09:56 pascal Exp $	*/
d4 1
a4 1
 * Copyright (c) 2000-2007 Niels Provos <provos@@citi.umich.edu>
a31 128
/** @@mainpage

  @@section intro Introduction

  libevent is an event notification library for developing scalable network
  servers.  The libevent API provides a mechanism to execute a callback
  function when a specific event occurs on a file descriptor or after a
  timeout has been reached. Furthermore, libevent also support callbacks due
  to signals or regular timeouts.

  libevent is meant to replace the event loop found in event driven network
  servers. An application just needs to call event_dispatch() and then add or
  remove events dynamically without having to change the event loop.

  Currently, libevent supports /dev/poll, kqueue(2), select(2), poll(2) and
  epoll(4). It also has experimental support for real-time signals. The
  internal event mechanism is completely independent of the exposed event API,
  and a simple update of libevent can provide new functionality without having
  to redesign the applications. As a result, Libevent allows for portable
  application development and provides the most scalable event notification
  mechanism available on an operating system. Libevent can also be used for
  multi-threaded applications; see Steven Grimm's explanation. Libevent should
  compile on Linux, *BSD, Mac OS X, Solaris and Windows.

  @@section usage Standard usage

  Every program that uses libevent must include the <event.h> header, and pass
  the -levent flag to the linker.  Before using any of the functions in the
  library, you must call event_init() or event_base_new() to perform one-time
  initialization of the libevent library.

  @@section event Event notification

  For each file descriptor that you wish to monitor, you must declare an event
  structure and call event_set() to initialize the members of the structure.
  To enable notification, you add the structure to the list of monitored
  events by calling event_add().  The event structure must remain allocated as
  long as it is active, so it should be allocated on the heap. Finally, you
  call event_dispatch() to loop and dispatch events.

  @@section bufferevent I/O Buffers

  libevent provides an abstraction on top of the regular event callbacks. This
  abstraction is called a buffered event. A buffered event provides input and
  output buffers that get filled and drained automatically. The user of a
  buffered event no longer deals directly with the I/O, but instead is reading
  from input and writing to output buffers.

  Once initialized via bufferevent_new(), the bufferevent structure can be
  used repeatedly with bufferevent_enable() and bufferevent_disable().
  Instead of reading and writing directly to a socket, you would call
  bufferevent_read() and bufferevent_write().

  When read enabled the bufferevent will try to read from the file descriptor
  and call the read callback. The write callback is executed whenever the
  output buffer is drained below the write low watermark, which is 0 by
  default.

  @@section timers Timers

  libevent can also be used to create timers that invoke a callback after a
  certain amount of time has expired. The evtimer_set() function prepares an
  event struct to be used as a timer. To activate the timer, call
  evtimer_add(). Timers can be deactivated by calling evtimer_del().

  @@section timeouts Timeouts

  In addition to simple timers, libevent can assign timeout events to file
  descriptors that are triggered whenever a certain amount of time has passed
  with no activity on a file descriptor.  The timeout_set() function
  initializes an event struct for use as a timeout. Once initialized, the
  event must be activated by using timeout_add().  To cancel the timeout, call
  timeout_del().

  @@section evdns Asynchronous DNS resolution

  libevent provides an asynchronous DNS resolver that should be used instead
  of the standard DNS resolver functions.  These functions can be imported by
  including the <evdns.h> header in your program. Before using any of the
  resolver functions, you must call evdns_init() to initialize the library. To
  convert a hostname to an IP address, you call the evdns_resolve_ipv4()
  function.  To perform a reverse lookup, you would call the
  evdns_resolve_reverse() function.  All of these functions use callbacks to
  avoid blocking while the lookup is performed.

  @@section evhttp Event-driven HTTP servers

  libevent provides a very simple event-driven HTTP server that can be
  embedded in your program and used to service HTTP requests.

  To use this capability, you need to include the <evhttp.h> header in your
  program.  You create the server by calling evhttp_new(). Add addresses and
  ports to listen on with evhttp_bind_socket(). You then register one or more
  callbacks to handle incoming requests.  Each URI can be assigned a callback
  via the evhttp_set_cb() function.  A generic callback function can also be
  registered via evhttp_set_gencb(); this callback will be invoked if no other
  callbacks have been registered for a given URI.

  @@section evrpc A framework for RPC servers and clients
 
  libevents provides a framework for creating RPC servers and clients.  It
  takes care of marshaling and unmarshaling all data structures.

  @@section api API Reference

  To browse the complete documentation of the libevent API, click on any of
  the following links.

  event.h
  The primary libevent header

  evdns.h
  Asynchronous DNS resolution

  evhttp.h
  An embedded libevent-based HTTP server

  evrpc.h
  A framework for creating RPC servers and clients

 */

/** @@file event.h

  A library for writing event-driven network servers

 */

d36 1
a36 3
#include <sys/types.h>
#include <sys/time.h>
#include <sys/queue.h>
d38 7
a44 2
#include <stdarg.h>
#include <stdint.h>
d46 1
a46 2
/* For int types. */
#include <evutil.h>
d62 21
a82 1
#define EV_PERSIST	0x10	/* Persistent event */
a84 1
#ifndef EVENT_NO_STRUCT
d89 1
a89 1
	unsigned int min_heap_idx;	/* for managing timeouts */
a91 1

a106 3
#else
struct event;
#endif
d122 6
d130 15
d146 1
a146 27
/**
  Initialize the event API.

  Use event_base_new() to initialize a new event base, but does not set
  the current_base global.   If using only event_base_new(), each event
  added must have an event base set with event_base_set()

  @@see event_base_set(), event_base_free(), event_init()
 */
struct event_base *event_base_new(void);

/**
  Initialize the event API.

  The event API needs to be initialized with event_init() before it can be
  used.  Sets the current_base global representing the default base for
  events that have no base associated with them.

  @@see event_base_set(), event_base_new()
 */
struct event_base *event_init(void);

/**
  Reinitialized the event base after a fork

  Some event mechanisms do not survive across fork.   The event base needs
  to be reinitialized with the event_reinit() function.
d148 1
a148 15
  @@param base the event base that needs to be re-initialized
  @@return 0 if successful, or -1 if some events could not be re-added.
  @@see event_base_new(), event_init()
*/
int event_reinit(struct event_base *base);

/**
  Loop to process events.

  In order to process events, an application needs to call
  event_dispatch().  This function only returns on error, and should
  replace the event core of the application program.

  @@see event_base_dispatch()
 */
a149 8


/**
  Threadsafe event dispatching loop.

  @@param eb the event_base structure returned by event_init()
  @@see event_init(), event_dispatch()
 */
a150 19


/**
 Get the kernel event notification mechanism used by libevent.
 
 @@param eb the event_base structure returned by event_base_new()
 @@return a string identifying the kernel event mechanism (kqueue, epoll, etc.)
 */
const char *event_base_get_method(struct event_base *);
        
        
/**
  Deallocate all memory associated with an event_base, and free the base.

  Note that this function will not close any fds or free any memory passed
  to event_set as the argument to callback.

  @@param eb an event_base to be freed
 */
a152 1

a157 7
/**
  Redirect libevent's log messages.

  @@param cb a function taking two arguments: an integer severity between
     _EVENT_LOG_DEBUG and _EVENT_LOG_ERR, and a string.  If cb is NULL,
	 then the default log is used.
  */
d160 1
a160 6
/**
  Associate a different event base with an event.

  @@param eb the event base
  @@param ev the event
 */
d163 2
a164 18
/**
 event_loop() flags
 */
/*@@{*/
#define EVLOOP_ONCE	0x01	/**< Block at most once. */
#define EVLOOP_NONBLOCK	0x02	/**< Do not block. */
/*@@}*/

/**
  Handle events.

  This is a more flexible version of event_dispatch().

  @@param flags any combination of EVLOOP_ONCE | EVLOOP_NONBLOCK
  @@return 0 if successful, -1 if an error occurred, or 1 if no events were
    registered.
  @@see event_loopexit(), event_base_loop()
*/
a165 12

/**
  Handle events (threadsafe version).

  This is a more flexible version of event_base_dispatch().

  @@param eb the event_base structure returned by event_init()
  @@param flags any combination of EVLOOP_ONCE | EVLOOP_NONBLOCK
  @@return 0 if successful, -1 if an error occurred, or 1 if no events were
    registered.
  @@see event_loopexit(), event_base_loop()
  */
d167 2
a169 68
/**
  Exit the event loop after the specified time.

  The next event_loop() iteration after the given timer expires will
  complete normally (handling all queued events) then exit without
  blocking for events again.

  Subsequent invocations of event_loop() will proceed normally.

  @@param tv the amount of time after which the loop should terminate.
  @@return 0 if successful, or -1 if an error occurred
  @@see event_loop(), event_base_loop(), event_base_loopexit()
  */
int event_loopexit(const struct timeval *);


/**
  Exit the event loop after the specified time (threadsafe variant).

  The next event_base_loop() iteration after the given timer expires will
  complete normally (handling all queued events) then exit without
  blocking for events again.

  Subsequent invocations of event_base_loop() will proceed normally.

  @@param eb the event_base structure returned by event_init()
  @@param tv the amount of time after which the loop should terminate.
  @@return 0 if successful, or -1 if an error occurred
  @@see event_loopexit()
 */
int event_base_loopexit(struct event_base *, const struct timeval *);

/**
  Abort the active event_loop() immediately.

  event_loop() will abort the loop after the next event is completed;
  event_loopbreak() is typically invoked from this event's callback.
  This behavior is analogous to the "break;" statement.

  Subsequent invocations of event_loop() will proceed normally.

  @@return 0 if successful, or -1 if an error occurred
  @@see event_base_loopbreak(), event_loopexit()
 */
int event_loopbreak(void);

/**
  Abort the active event_base_loop() immediately.

  event_base_loop() will abort the loop after the next event is completed;
  event_base_loopbreak() is typically invoked from this event's callback.
  This behavior is analogous to the "break;" statement.

  Subsequent invocations of event_loop() will proceed normally.

  @@param eb the event_base structure returned by event_init()
  @@return 0 if successful, or -1 if an error occurred
  @@see event_base_loopexit
 */
int event_base_loopbreak(struct event_base *);


/**
  Add a timer event.

  @@param ev the event struct
  @@param tv timeval struct
 */
a170 9


/**
  Define a timer event.

  @@param ev event struct to be modified
  @@param cb callback function
  @@param arg argument that will be passed to the callback function
 */
a171 7


/**
 * Delete a timer event.
 *
 * @@param ev the event struct to be disabled
 */
a175 39
#ifdef EVENT_DEPRECATED
/*
 * timeout_* are collision-prone names for macros, and they are
 * deprecated. Define EVENT_DEPRECATED to expose them anyway.
 *
 * It is recommended evtimer_* be used instead.
 */

/**
 * Add a timeout event.
 *
 * @@param ev the event struct to be disabled
 * @@param tv the timeout value, in seconds
 */
#define timeout_add(ev, tv)		event_add(ev, tv)


/**
 * Define a timeout event.
 *
 * @@param ev the event struct to be defined
 * @@param cb the callback to be invoked when the timeout expires
 * @@param arg the argument to be passed to the callback
 */
#define timeout_set(ev, cb, arg)	event_set(ev, -1, 0, cb, arg)


/**
 * Disable a timeout event.
 *
 * @@param ev the timeout event to be disabled
 */
#define timeout_del(ev)			event_del(ev)

#define timeout_pending(ev, tv)		event_pending(ev, EV_TIMEOUT, tv)
#define timeout_initialized(ev)		((ev)->ev_flags & EVLIST_INIT)

#endif /* EVENT_DEPRECATED */

a182 26
/**
  Prepare an event structure to be added.

  The function event_set() prepares the event structure ev to be used in
  future calls to event_add() and event_del().  The event will be prepared to
  call the function specified by the fn argument with an int argument
  indicating the file descriptor, a short argument indicating the type of
  event, and a void * argument given in the arg argument.  The fd indicates
  the file descriptor that should be monitored for events.  The events can be
  either EV_READ, EV_WRITE, or both.  Indicating that an application can read
  or write from the file descriptor respectively without blocking.

  The function fn will be called with the file descriptor that triggered the
  event and the type of event which will be either EV_TIMEOUT, EV_SIGNAL,
  EV_READ, or EV_WRITE.  The additional flag EV_PERSIST makes an event_add()
  persistent until event_del() has been called.

  @@param ev an event struct to be modified
  @@param fd the file descriptor to be monitored
  @@param event desired events to monitor; can be EV_READ and/or EV_WRITE
  @@param fn callback function to be invoked when the event occurs
  @@param arg an argument to be passed to the callback function

  @@see event_add(), event_del(), event_once()

 */
d184 1
d186 1
a186 77
/**
  Schedule a one-time event to occur.

  The function event_once() is similar to event_set().  However, it schedules
  a callback to be called exactly once and does not require the caller to
  prepare an event structure.

  @@param fd a file descriptor to monitor
  @@param events event(s) to monitor; can be any of EV_TIMEOUT | EV_READ |
         EV_WRITE
  @@param callback callback function to be invoked when the event occurs
  @@param arg an argument to be passed to the callback function
  @@param timeout the maximum amount of time to wait for the event, or NULL
         to wait forever
  @@return 0 if successful, or -1 if an error occurred
  @@see event_set()

 */
int event_once(int, short, void (*)(int, short, void *), void *,
    const struct timeval *);


/**
  Schedule a one-time event (threadsafe variant)

  The function event_base_once() is similar to event_set().  However, it
  schedules a callback to be called exactly once and does not require the
  caller to prepare an event structure.

  @@param base an event_base returned by event_init()
  @@param fd a file descriptor to monitor
  @@param events event(s) to monitor; can be any of EV_TIMEOUT | EV_READ |
         EV_WRITE
  @@param callback callback function to be invoked when the event occurs
  @@param arg an argument to be passed to the callback function
  @@param timeout the maximum amount of time to wait for the event, or NULL
         to wait forever
  @@return 0 if successful, or -1 if an error occurred
  @@see event_once()
 */
int event_base_once(struct event_base *base, int fd, short events,
    void (*callback)(int, short, void *), void *arg,
    const struct timeval *timeout);


/**
  Add an event to the set of monitored events.

  The function event_add() schedules the execution of the ev event when the
  event specified in event_set() occurs or in at least the time specified in
  the tv.  If tv is NULL, no timeout occurs and the function will only be
  called if a matching event occurs on the file descriptor.  The event in the
  ev argument must be already initialized by event_set() and may not be used
  in calls to event_set() until it has timed out or been removed with
  event_del().  If the event in the ev argument already has a scheduled
  timeout, the old timeout will be replaced by the new one.

  @@param ev an event struct initialized via event_set()
  @@param timeout the maximum amount of time to wait for the event, or NULL
         to wait forever
  @@return 0 if successful, or -1 if an error occurred
  @@see event_del(), event_set()
  */
int event_add(struct event *ev, const struct timeval *timeout);


/**
  Remove an event from the set of monitored events.

  The function event_del() will cancel the event in the argument ev.  If the
  event has already executed or has never been added the call will have no
  effect.

  @@param ev an event struct to be removed from the working set
  @@return 0 if successful, or -1 if an error occurred
  @@see event_add()
 */
a187 1

d190 1
a191 24
/**
  Checks if a specific event is pending or scheduled.

  @@param ev an event struct previously passed to event_add()
  @@param event the requested event type; any of EV_TIMEOUT|EV_READ|
         EV_WRITE|EV_SIGNAL
  @@param tv an alternate timeout (FIXME - is this true?)

  @@return 1 if the event is pending, or 0 if the event has not occurred

 */
int event_pending(struct event *ev, short event, struct timeval *tv);


/**
  Test if an event structure has been initialized.

  The event_initialized() macro can be used to check if an event has been
  initialized.

  @@param ev an event structure to be tested
  @@return 1 if the structure has been initialized, or 0 if it has not been
          initialized
 */
d198 1
a198 6

/**
  Get the libevent version number.

  @@return a string containing the version number of libevent
 */
a199 7


/**
  Get the kernel event notification mechanism used by libevent.

  @@return a string identifying the kernel event mechanism (kqueue, epoll, etc.)
 */
d202 1
a203 20
/**
  Set the number of different event priorities.

  By default libevent schedules all active events with the same priority.
  However, some time it is desirable to process some events with a higher
  priority than others.  For that reason, libevent supports strict priority
  queues.  Active events with a lower priority are always processed before
  events with a higher priority.

  The number of different priorities can be set initially with the
  event_priority_init() function.  This function should be called before the
  first call to event_dispatch().  The event_priority_set() function can be
  used to assign a priority to an event.  By default, libevent assigns the
  middle priority to all events unless their priority is explicitly set.

  @@param npriorities the maximum number of priorities
  @@return 0 if successful, or -1 if an error occurred
  @@see event_base_priority_init(), event_priority_set()

 */
a204 12


/**
  Set the number of different event priorities (threadsafe variant).

  See the description of event_priority_init() for more information.

  @@param eb the event_base structure returned by event_init()
  @@param npriorities the maximum number of priorities
  @@return 0 if successful, or -1 if an error occurred
  @@see event_priority_init(), event_priority_set()
 */
a205 10


/**
  Assign a priority to an event.

  @@param ev an event struct
  @@param priority the new priority to be assigned
  @@return 0 if successful, or -1 if an error occurred
  @@see event_priority_init()
  */
a207 1

a237 1
#ifndef EVENT_NO_STRUCT
a238 2
	struct event_base *ev_base;

a257 1
#endif
a258 34
/**
  Create a new bufferevent.

  libevent provides an abstraction on top of the regular event callbacks.
  This abstraction is called a buffered event.  A buffered event provides
  input and output buffers that get filled and drained automatically.  The
  user of a buffered event no longer deals directly with the I/O, but
  instead is reading from input and writing to output buffers.

  Once initialized, the bufferevent structure can be used repeatedly with
  bufferevent_enable() and bufferevent_disable().

  When read enabled the bufferevent will try to read from the file descriptor
  and call the read callback.  The write callback is executed whenever the
  output buffer is drained below the write low watermark, which is 0 by
  default.

  If multiple bases are in use, bufferevent_base_set() must be called before
  enabling the bufferevent for the first time.

  @@param fd the file descriptor from which data is read and written to.
  		This file descriptor is not allowed to be a pipe(2).
  @@param readcb callback to invoke when there is data to be read, or NULL if
         no callback is desired
  @@param writecb callback to invoke when the file descriptor is ready for
         writing, or NULL if no callback is desired
  @@param errorcb callback to invoke when there is an error on the file
         descriptor
  @@param cbarg an argument that will be supplied to each of the callbacks
         (readcb, writecb, and errorcb)
  @@return a pointer to a newly allocated bufferevent struct, or NULL if an
          error occurred
  @@see bufferevent_base_set(), bufferevent_free()
  */
a260 10


/**
  Assign a bufferevent to a specific event_base.

  @@param base an event_base returned by event_init()
  @@param bufev a bufferevent struct returned by bufferevent_new()
  @@return 0 if successful, or -1 if an error occurred
  @@see bufferevent_new()
 */
a261 9


/**
  Assign a priority to a bufferevent.

  @@param bufev a bufferevent struct
  @@param pri the priority to be assigned
  @@return 0 if successful, or -1 if an error occurred
  */
a262 7


/**
  Deallocate the storage associated with a bufferevent structure.

  @@param bufev the bufferevent structure to be freed.
  */
d264 1
a264 53


/**
  Changes the callbacks for a bufferevent.

  @@param bufev the bufferevent object for which to change callbacks
  @@param readcb callback to invoke when there is data to be read, or NULL if
         no callback is desired
  @@param writecb callback to invoke when the file descriptor is ready for
         writing, or NULL if no callback is desired
  @@param errorcb callback to invoke when there is an error on the file
         descriptor
  @@param cbarg an argument that will be supplied to each of the callbacks
         (readcb, writecb, and errorcb)
  @@see bufferevent_new()
  */
void bufferevent_setcb(struct bufferevent *bufev,
    evbuffercb readcb, evbuffercb writecb, everrorcb errorcb, void *cbarg);

/**
  Changes the file descriptor on which the bufferevent operates.

  @@param bufev the bufferevent object for which to change the file descriptor
  @@param fd the file descriptor to operate on
*/
void bufferevent_setfd(struct bufferevent *bufev, int fd);

/**
  Write data to a bufferevent buffer.

  The bufferevent_write() function can be used to write data to the file
  descriptor.  The data is appended to the output buffer and written to the
  descriptor automatically as it becomes available for writing.

  @@param bufev the bufferevent to be written to
  @@param data a pointer to the data to be written
  @@param size the length of the data, in bytes
  @@return 0 if successful, or -1 if an error occurred
  @@see bufferevent_write_buffer()
  */
int bufferevent_write(struct bufferevent *bufev,
    const void *data, size_t size);


/**
  Write data from an evbuffer to a bufferevent buffer.  The evbuffer is
  being drained as a result.

  @@param bufev the bufferevent to be written to
  @@param buf the evbuffer to be written
  @@return 0 if successful, or -1 if an error occurred
  @@see bufferevent_write()
 */
a265 12


/**
  Read data from a bufferevent buffer.

  The bufferevent_read() function is used to read data from the input buffer.

  @@param bufev the bufferevent to be read from
  @@param data pointer to a buffer that will store the data
  @@param size the size of the data buffer, in bytes
  @@return the amount of data read, in bytes.
 */
a266 9

/**
  Enable a bufferevent.

  @@param bufev the bufferevent to be enabled
  @@param event any combination of EV_READ | EV_WRITE.
  @@return 0 if successful, or -1 if an error occurred
  @@see bufferevent_disable()
 */
a267 10


/**
  Disable a bufferevent.

  @@param bufev the bufferevent to be disabled
  @@param event any combination of EV_READ | EV_WRITE.
  @@return 0 if successful, or -1 if an error occurred
  @@see bufferevent_enable()
 */
a268 9


/**
  Set the read and write timeout for a buffered event.

  @@param bufev the bufferevent to be modified
  @@param timeout_read the read timeout
  @@param timeout_write the write timeout
 */
a271 20

/**
  Sets the watermarks for read and write events.

  On input, a bufferevent does not invoke the user read callback unless
  there is at least low watermark data in the buffer.   If the read buffer
  is beyond the high watermark, the buffevent stops reading from the network.

  On output, the user write callback is invoked whenever the buffered data
  falls below the low watermark.

  @@param bufev the bufferevent to be modified
  @@param events EV_READ, EV_WRITE or both
  @@param lowmark the lower watermark to set
  @@param highmark the high watermark to set
*/

void bufferevent_setwatermark(struct bufferevent *bufev, short events,
    size_t lowmark, size_t highmark);

a276 7

/**
  Allocate storage for a new evbuffer.

  @@return a pointer to a newly allocated evbuffer struct, or NULL if an error
          occurred
 */
a277 7


/**
  Deallocate storage for an evbuffer.

  @@param pointer to the evbuffer to be freed
 */
a278 11


/**
  Expands the available space in an event buffer.

  Expands the available space in the event buffer to at least datlen

  @@param buf the event buffer to be expanded
  @@param datlen the new minimum length requirement
  @@return 0 if successful, or -1 if an error occurred
*/
a279 9


/**
  Append data to the end of an evbuffer.

  @@param buf the event buffer to be appended to
  @@param data pointer to the beginning of the data buffer
  @@param datlen the number of bytes to be copied from the data buffer
 */
a280 11



/**
  Read data from an event buffer and drain the bytes read.

  @@param buf the event buffer to be read from
  @@param data the destination buffer to store the result
  @@param datlen the maximum size of the destination buffer
  @@return the number of bytes read
 */
a281 11


/**
 * Read a single line from an event buffer.
 *
 * Reads a line terminated by either '\r\n', '\n\r' or '\r' or '\n'.
 * The returned buffer needs to be freed by the caller.
 *
 * @@param buffer the evbuffer to read from
 * @@return pointer to a single line, or NULL if an error occurred
 */
a282 44


/** Used to tell evbuffer_readln what kind of line-ending to look for.
 */
enum evbuffer_eol_style {
	/** Any sequence of CR and LF characters is acceptable as an EOL. */
	EVBUFFER_EOL_ANY,
	/** An EOL is an LF, optionally preceded by a CR.  This style is
	 * most useful for implementing text-based internet protocols. */
	EVBUFFER_EOL_CRLF,
	/** An EOL is a CR followed by an LF. */
	EVBUFFER_EOL_CRLF_STRICT,
	/** An EOL is a LF. */
        EVBUFFER_EOL_LF
};

/**
 * Read a single line from an event buffer.
 *
 * Reads a line terminated by an EOL as determined by the evbuffer_eol_style
 * argument.  Returns a newly allocated nul-terminated string; the caller must
 * free the returned value.  The EOL is not included in the returned string.
 *
 * @@param buffer the evbuffer to read from
 * @@param n_read_out if non-NULL, points to a size_t that is set to the
 *       number of characters in the returned string.  This is useful for
 *       strings that can contain NUL characters.
 * @@param eol_style the style of line-ending to use.
 * @@return pointer to a single line, or NULL if an error occurred
 */
char *evbuffer_readln(struct evbuffer *buffer, size_t *n_read_out,
    enum evbuffer_eol_style eol_style);


/**
  Move data from one evbuffer into another evbuffer.

  This is a destructive add.  The data from one buffer moves into
  the other buffer. The destination buffer is expanded as needed.

  @@param outbuf the output buffer
  @@param inbuf the input buffer
  @@return 0 if successful, or -1 if an error occurred
 */
d284 1
a284 25


/**
  Append a formatted string to the end of an evbuffer.

  @@param buf the evbuffer that will be appended to
  @@param fmt a format string
  @@param ... arguments that will be passed to printf(3)
  @@return The number of bytes added if successful, or -1 if an error occurred.
 */
int evbuffer_add_printf(struct evbuffer *, const char *fmt, ...)
#ifdef __GNUC__
  __attribute__((format(printf, 2, 3)))
#endif
;


/**
  Append a va_list formatted string to the end of an evbuffer.

  @@param buf the evbuffer that will be appended to
  @@param fmt a format string
  @@param ap a varargs va_list argument array that will be passed to vprintf(3)
  @@return The number of bytes added if successful, or -1 if an error occurred.
 */
a285 8


/**
  Remove a specified number of bytes data from the beginning of an evbuffer.

  @@param buf the evbuffer to be drained
  @@param len the number of bytes to drain from the beginning of the buffer
 */
a286 12


/**
  Write the contents of an evbuffer to a file descriptor.

  The evbuffer will be drained after the bytes have been successfully written.

  @@param buffer the evbuffer to be written and drained
  @@param fd the file descriptor to be written to
  @@return the number of bytes written, or -1 if an error occurred
  @@see evbuffer_read()
 */
a287 11


/**
  Read from a file descriptor and store the result in an evbuffer.

  @@param buf the evbuffer to store the result
  @@param fd the file descriptor to read from
  @@param howmuch the number of bytes to be read
  @@return the number of bytes read, or -1 if an error occurred
  @@see evbuffer_write()
 */
a288 10


/**
  Find a string within an evbuffer.

  @@param buffer the evbuffer to be searched
  @@param what the string to be searched for
  @@param len the length of the search string
  @@return a pointer to the beginning of the search string, or NULL if the search failed.
 */
a289 8

/**
  Set a callback to invoke when the evbuffer is modified.

  @@param buffer the evbuffer to be monitored
  @@param cb the callback function to invoke when the evbuffer is modified
  @@param cbarg an argument to be provided to the callback function
 */
d300 2
a301 5
void evtag_marshal(struct evbuffer *evbuf, ev_uint32_t tag, const void *data,
    ev_uint32_t len);

/**
  Encode an integer and store it in an evbuffer.
d303 1
a303 3
  We encode integer's by nibbles; the first nibble contains the number
  of significant nibbles - 1;  this allows us to encode up to 64-bit
  integers.  This function is byte-order independent.
d305 2
a306 7
  @@param evbuf evbuffer to store the encoded number
  @@param number a 32-bit integer
 */
void encode_int(struct evbuffer *evbuf, ev_uint32_t number);

void evtag_marshal_int(struct evbuffer *evbuf, ev_uint32_t tag,
    ev_uint32_t integer);
d308 1
a308 1
void evtag_marshal_string(struct evbuffer *buf, ev_uint32_t tag,
d311 1
a311 1
void evtag_marshal_timeval(struct evbuffer *evbuf, ev_uint32_t tag,
d314 3
a316 1
int evtag_unmarshal(struct evbuffer *src, ev_uint32_t *ptag,
d318 3
a320 3
int evtag_peek(struct evbuffer *evbuf, ev_uint32_t *ptag);
int evtag_peek_length(struct evbuffer *evbuf, ev_uint32_t *plength);
int evtag_payload_length(struct evbuffer *evbuf, ev_uint32_t *plength);
d323 2
a324 2
int evtag_unmarshal_int(struct evbuffer *evbuf, ev_uint32_t need_tag,
    ev_uint32_t *pinteger);
d326 2
a327 2
int evtag_unmarshal_fixed(struct evbuffer *src, ev_uint32_t need_tag,
    void *data, size_t len);
d329 1
a329 1
int evtag_unmarshal_string(struct evbuffer *evbuf, ev_uint32_t need_tag,
d332 1
a332 1
int evtag_unmarshal_timeval(struct evbuffer *evbuf, ev_uint32_t need_tag,
a334 2
#define _EVENT_VERSION "1.4.14b-stable"

@


