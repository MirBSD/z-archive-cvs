head	1.8;
access;
symbols
	cvs-201210191930:1.1.1.6
	MIRBSD_10:1.6.0.2
	MIRBSD_10_BASE:1.6
	cvs-200705171630:1.1.1.5
	cvs-200702051630:1.1.1.4
	MIRBSD_9_BASE:1.2
	MIRBSD_8:1.2.0.2
	MIRBSD_8_BASE:1.2
	cvs-200507211800:1.1.1.3
	cvs-200505050030:1.1.1.2
	cvs-200504291700:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.03.12.23.45.11;	author tg;	state Exp;
branches;
next	1.7;
commitid	1005320F19F6D6A9E6E;

1.7
date	2012.10.19.19.58.20;	author tg;	state Exp;
branches;
next	1.6;
commitid	1005081B0E54727ACCA;

1.6
date	2007.05.17.17.15.35;	author tg;	state Exp;
branches;
next	1.5;
commitid	100464C8DC46A1A51B5;

1.5
date	2007.05.17.16.48.21;	author tg;	state Exp;
branches;
next	1.4;
commitid	100464C876417B6519F;

1.4
date	2007.05.17.16.40.57;	author tg;	state Exp;
branches;
next	1.3;
commitid	100464C85AF54416520;

1.3
date	2007.02.05.16.42.30;	author tg;	state Exp;
branches;
next	1.2;
commitid	10045C75E8B3A2257F9;

1.2
date	2005.10.21.11.02.43;	author tg;	state Exp;
branches;
next	1.1;
commitid	6c0b4358cac0ef88;

1.1
date	2005.02.05.17.25.14;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.25.14;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.29.17.05.23;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.07.21.20.53.52;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	560042e0092f571e;

1.1.1.4
date	2007.02.05.16.38.53;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	10045C75DA6486B10AC;

1.1.1.5
date	2007.05.17.16.38.22;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	100464C84A31EC59432;

1.1.1.6
date	2012.10.19.19.33.47;	author tg;	state Exp;
branches;
next	;
commitid	1005081AB336FC5E505;


desc
@@


1.8
log
@eek! use arc4random_uniform()!
@
text
@/*	$OpenBSD: select.c,v 1.16 2010/04/21 21:02:47 nicm Exp $	*/

/*
 * Copyright 2000-2002 Niels Provos <provos@@citi.umich.edu>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <sys/types.h>
#ifdef HAVE_SYS_TIME_H
#include <sys/time.h>
#else
#include <sys/_libevent_time.h>
#endif
#ifdef HAVE_SYS_SELECT_H
#include <sys/select.h>
#endif
#include <sys/queue.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#ifdef CHECK_INVARIANTS
#include <assert.h>
#endif

#include "event.h"
#include "evutil.h"
#include "event-internal.h"
#include "evsignal.h"
#include "log.h"

__RCSID("$MirOS: src/lib/libevent/select.c,v 1.7 2012/10/19 19:58:20 tg Exp $");

#ifndef howmany
#define        howmany(x, y)   (((x)+((y)-1))/(y))
#endif

#ifndef HAVE_FD_MASK
/* This type is mandatory, but Android doesn't define it. */
#undef NFDBITS
#define NFDBITS (sizeof(long)*8)
typedef unsigned long fd_mask;
#endif

struct selectop {
	fd_set *event_readset_in;
	fd_set *event_writeset_in;
	fd_set *event_readset_out;
	fd_set *event_writeset_out;
	struct event **event_r_by_fd;
	struct event **event_w_by_fd;
	size_t event_fdsz;
	int event_fds;		/* Highest fd in fd set */
};

static void *select_init	(struct event_base *);
static int select_add		(void *, struct event *);
static int select_del		(void *, struct event *);
static int select_dispatch	(struct event_base *, void *, struct timeval *);
static void select_dealloc     (struct event_base *, void *);

const struct eventop selectops = {
	"select",
	select_init,
	select_add,
	select_del,
	select_dispatch,
	select_dealloc,
	0
};

static int select_resize(struct selectop *sop, size_t fdsz);

static void *
select_init(struct event_base *base)
{
	struct selectop *sop;

	/* Disable select when this environment variable is set */
	if (evutil_getenv("EVENT_NOSELECT"))
		return (NULL);

	if (!(sop = calloc(1, sizeof(struct selectop))))
		return (NULL);

	select_resize(sop, howmany(32 + 1, NFDBITS)*sizeof(fd_mask));

	evsignal_init(base);

	return (sop);
}

#ifdef CHECK_INVARIANTS
static void
check_selectop(struct selectop *sop)
{
	int i;
	for (i = 0; i <= sop->event_fds; ++i) {
		if (FD_ISSET(i, sop->event_readset_in)) {
			assert(sop->event_r_by_fd[i]);
			assert(sop->event_r_by_fd[i]->ev_events & EV_READ);
			assert(sop->event_r_by_fd[i]->ev_fd == i);
		} else {
			assert(! sop->event_r_by_fd[i]);
		}
		if (FD_ISSET(i, sop->event_writeset_in)) {
			assert(sop->event_w_by_fd[i]);
			assert(sop->event_w_by_fd[i]->ev_events & EV_WRITE);
			assert(sop->event_w_by_fd[i]->ev_fd == i);
		} else {
			assert(! sop->event_w_by_fd[i]);
		}
	}

}
#else
#define check_selectop(sop) do { (void) sop; } while (0)
#endif

static int
select_dispatch(struct event_base *base, void *arg, struct timeval *tv)
{
	int res, i, j;
	struct selectop *sop = arg;

	check_selectop(sop);

	memcpy(sop->event_readset_out, sop->event_readset_in,
	       sop->event_fdsz);
	memcpy(sop->event_writeset_out, sop->event_writeset_in,
	       sop->event_fdsz);

	res = select(sop->event_fds + 1, sop->event_readset_out,
	    sop->event_writeset_out, NULL, tv);

	check_selectop(sop);

	if (res == -1) {
		if (errno != EINTR) {
			event_warn("select");
			return (-1);
		}

		evsignal_process(base);
		return (0);
	} else if (base->sig.evsignal_caught) {
		evsignal_process(base);
	}

	event_debug(("%s: select reports %d", __func__, res));

	check_selectop(sop);
	i = arc4random_uniform(sop->event_fds + 1);
	for (j = 0; j <= sop->event_fds; ++j) {
		struct event *r_ev = NULL, *w_ev = NULL;
		if (++i >= sop->event_fds+1)
			i = 0;

		res = 0;
		if (FD_ISSET(i, sop->event_readset_out)) {
			r_ev = sop->event_r_by_fd[i];
			res |= EV_READ;
		}
		if (FD_ISSET(i, sop->event_writeset_out)) {
			w_ev = sop->event_w_by_fd[i];
			res |= EV_WRITE;
		}
		if (r_ev && (res & r_ev->ev_events)) {
			event_active(r_ev, res & r_ev->ev_events, 1);
		}
		if (w_ev && w_ev != r_ev && (res & w_ev->ev_events)) {
			event_active(w_ev, res & w_ev->ev_events, 1);
		}
	}
	check_selectop(sop);

	return (0);
}


static int
select_resize(struct selectop *sop, size_t fdsz)
{
	int n_events, n_events_old;

	fd_set *readset_in = NULL;
	fd_set *writeset_in = NULL;
	fd_set *readset_out = NULL;
	fd_set *writeset_out = NULL;
	struct event **r_by_fd = NULL;
	struct event **w_by_fd = NULL;

	n_events = (fdsz/sizeof(fd_mask)) * NFDBITS;
	n_events_old = (sop->event_fdsz/sizeof(fd_mask)) * NFDBITS;

	if (sop->event_readset_in)
		check_selectop(sop);

	if ((readset_in = realloc(sop->event_readset_in, fdsz)) == NULL)
		goto error;
	sop->event_readset_in = readset_in;
	if ((readset_out = realloc(sop->event_readset_out, fdsz)) == NULL)
		goto error;
	sop->event_readset_out = readset_out;
	if ((writeset_in = realloc(sop->event_writeset_in, fdsz)) == NULL)
		goto error;
	sop->event_writeset_in = writeset_in;
	if ((writeset_out = realloc(sop->event_writeset_out, fdsz)) == NULL)
		goto error;
	sop->event_writeset_out = writeset_out;
	if ((r_by_fd = realloc(sop->event_r_by_fd,
		 n_events*sizeof(struct event*))) == NULL)
		goto error;
	sop->event_r_by_fd = r_by_fd;
	if ((w_by_fd = realloc(sop->event_w_by_fd,
		 n_events * sizeof(struct event*))) == NULL)
		goto error;
	sop->event_w_by_fd = w_by_fd;

	memset((char *)sop->event_readset_in + sop->event_fdsz, 0,
	    fdsz - sop->event_fdsz);
	memset((char *)sop->event_writeset_in + sop->event_fdsz, 0,
	    fdsz - sop->event_fdsz);
	memset(sop->event_r_by_fd + n_events_old, 0,
	    (n_events-n_events_old) * sizeof(struct event*));
	memset(sop->event_w_by_fd + n_events_old, 0,
	    (n_events-n_events_old) * sizeof(struct event*));

	sop->event_fdsz = fdsz;
	check_selectop(sop);

	return (0);

 error:
	event_warn("malloc");
	return (-1);
}


static int
select_add(void *arg, struct event *ev)
{
	struct selectop *sop = arg;

	if (ev->ev_events & EV_SIGNAL)
		return (evsignal_add(ev));

	check_selectop(sop);
	/*
	 * Keep track of the highest fd, so that we can calculate the size
	 * of the fd_sets for select(2)
	 */
	if (sop->event_fds < ev->ev_fd) {
		size_t fdsz = sop->event_fdsz;

		if (fdsz < sizeof(fd_mask))
			fdsz = sizeof(fd_mask);

		while (fdsz <
		    (howmany(ev->ev_fd + 1, NFDBITS) * sizeof(fd_mask)))
			fdsz *= 2;

		if (fdsz != sop->event_fdsz) {
			if (select_resize(sop, fdsz)) {
				check_selectop(sop);
				return (-1);
			}
		}

		sop->event_fds = ev->ev_fd;
	}

	if (ev->ev_events & EV_READ) {
		FD_SET(ev->ev_fd, sop->event_readset_in);
		sop->event_r_by_fd[ev->ev_fd] = ev;
	}
	if (ev->ev_events & EV_WRITE) {
		FD_SET(ev->ev_fd, sop->event_writeset_in);
		sop->event_w_by_fd[ev->ev_fd] = ev;
	}
	check_selectop(sop);

	return (0);
}

/*
 * Nothing to be done here.
 */

static int
select_del(void *arg, struct event *ev)
{
	struct selectop *sop = arg;

	check_selectop(sop);
	if (ev->ev_events & EV_SIGNAL)
		return (evsignal_del(ev));

	if (sop->event_fds < ev->ev_fd) {
		check_selectop(sop);
		return (0);
	}

	if (ev->ev_events & EV_READ) {
		FD_CLR(ev->ev_fd, sop->event_readset_in);
		sop->event_r_by_fd[ev->ev_fd] = NULL;
	}

	if (ev->ev_events & EV_WRITE) {
		FD_CLR(ev->ev_fd, sop->event_writeset_in);
		sop->event_w_by_fd[ev->ev_fd] = NULL;
	}

	check_selectop(sop);
	return (0);
}

static void
select_dealloc(struct event_base *base, void *arg)
{
	struct selectop *sop = arg;

	evsignal_dealloc(base);
	if (sop->event_readset_in)
		free(sop->event_readset_in);
	if (sop->event_writeset_in)
		free(sop->event_writeset_in);
	if (sop->event_readset_out)
		free(sop->event_readset_out);
	if (sop->event_writeset_out)
		free(sop->event_writeset_out);
	if (sop->event_r_by_fd)
		free(sop->event_r_by_fd);
	if (sop->event_w_by_fd)
		free(sop->event_w_by_fd);

	memset(sop, 0, sizeof(struct selectop));
	free(sop);
}
@


1.7
log
@merge latest stable-1.4 libevent
@
text
@d59 1
a59 1
__RCSID("$MirOS$");
d180 1
a180 1
	i = random() % (sop->event_fds+1);
@


1.6
log
@__CRAZY=Yes clean, fixes a few real bugs
@
text
@d1 1
a1 1
/*	$OpenBSD: select.c,v 1.13 2007/03/19 15:12:49 millert Exp $	*/
d37 4
a40 1
#include <sys/_time.h>
a42 1
#include <sys/tree.h>
d54 1
d59 1
a59 1
__RCSID("$MirOS: src/lib/libevent/select.c,v 1.5 2007/05/17 16:48:21 tg Exp $");
d65 6
a70 1
extern volatile sig_atomic_t evsignal_caught;
a72 2
	int event_fds;		/* Highest fd in fd set */
	int event_fdsz;
d79 2
a80 1
	sigset_t evsigmask;
d83 5
a87 6
void *select_init	(void);
int select_add		(void *, struct event *);
int select_del		(void *, struct event *);
int select_recalc	(struct event_base *, void *, int);
int select_dispatch	(struct event_base *, void *, struct timeval *);
void select_dealloc     (void *);
a93 1
	select_recalc,
d95 2
a96 1
	select_dealloc
d99 1
a99 1
static int select_resize(struct selectop *sop, int fdsz);
d101 2
a102 2
void *
select_init(void)
d107 1
a107 1
	if (!issetugid() && getenv("EVENT_NOSELECT"))
d115 1
a115 1
	evsignal_init(&sop->evsigmask);
d125 1
a125 1
	for (i=0;i<=sop->event_fds;++i) {
d147 2
a148 8
/*
 * Called with the highest fd that we know about.  If it is 0, completely
 * recalculate everything.
 */

int
select_recalc(struct event_base *base __attribute__((unused)),
    void *arg, int max __attribute__((unused)))
d150 1
a150 12
	struct selectop *sop = arg;

	check_selectop(sop);

	return (evsignal_recalc(&sop->evsigmask));
}

int
select_dispatch(struct event_base *base __attribute__((unused)),
    void *arg, struct timeval *tv)
{
	int res, i;
a159 3
	if (evsignal_deliver(&sop->evsigmask) == -1)
		return (-1);

a163 2
	if (evsignal_recalc(&sop->evsigmask) == -1)
		return (-1);
d171 1
a171 1
		evsignal_process();
d173 3
a175 2
	} else if (evsignal_caught)
		evsignal_process();
d180 2
a181 1
	for (i = 0; i <= sop->event_fds; ++i) {
d183 3
a195 2
			if (!(r_ev->ev_events & EV_PERSIST))
				event_del(r_ev);
a198 2
			if (!(w_ev->ev_events & EV_PERSIST))
				event_del(w_ev);
d209 1
a209 1
select_resize(struct selectop *sop, int fdsz)
d267 1
a267 1
int
d273 1
a273 1
		return (evsignal_add(&sop->evsigmask, ev));
d290 1
a290 1
		if ((int)fdsz != sop->event_fdsz) {
d317 1
a317 1
int
d324 1
a324 1
		return (evsignal_del(&sop->evsigmask, ev));
d345 2
a346 2
void
select_dealloc(void *arg)
d350 1
@


1.5
log
@• how could they ever build this?
• rcsids
@
text
@d56 1
a56 1
__RCSID("$MirOS$");
d147 2
a148 1
select_recalc(struct event_base *base, void *arg, int max)
d158 2
a159 1
select_dispatch(struct event_base *base, void *arg, struct timeval *tv)
@


1.4
log
@fastmerge
@
text
@d56 2
@


1.3
log
@merge libevent
@
text
@d1 1
a1 1
/*	$OpenBSD: select.c,v 1.12 2006/03/30 06:32:36 brad Exp $	*/
d136 1
a136 1
#define check_selectop(sop)
@


1.2
log
@* merge bin and lib completely
* convert some ancient RCSID styles etc. to more modern stuff
* fix use of CDIAGFLAGS+=, CFLAGS+= and COPTS+= to the correct
  variant (include bsd.own.mk _then_ COPTS+=) so they're added
  after any user-specified flags
  (this is probably lurking in more places than I can imagine)
* fix some indenting, comments, etc.
* make stuff compile (fix warnings/errors)
* add script to review _all_ shlib_version after an openbsd import
* remove two more obsolete /usr/lib/debug/ references
* bin/ps: comment out some SMP code
@
text
@d1 1
a1 2
/**	$MirOS$ */
/*	$OpenBSD: select.c,v 1.11 2005/06/18 01:52:22 brad Exp $	*/
d79 1
d87 2
a88 1
	select_dispatch
d355 22
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$OpenBSD: select.c,v 1.6 2004/04/28 06:53:12 brad Exp $	*/
d41 1
d48 2
a49 7
#include <err.h>

#ifdef USE_LOG
#include "log.h"
#else
#define LOG_DBG(x)
#define log_error(x)	perror(x)
d53 1
d55 1
a55 2

extern struct event_list eventqueue;
d66 6
a71 2
	fd_set *event_readset;
	fd_set *event_writeset;
d73 1
a73 1
} sop;
d78 2
a79 2
int select_recalc	(void *, int);
int select_dispatch	(void *, struct timeval *);
d90 2
d95 3
a97 1
	/* Disable kqueue when this environment variable is set */
d101 4
a104 1
	memset(&sop, 0, sizeof(sop));
d106 1
a106 1
	evsignal_init(&sop.evsigmask);
d108 1
a108 1
	return (&sop);
d111 27
d144 1
a144 1
select_recalc(void *arg, int max)
a146 25
	fd_set *readset, *writeset;
	struct event *ev;
	int fdsz;

	if (sop->event_fds < max)
		sop->event_fds = max;

	if (!sop->event_fds) {
		TAILQ_FOREACH(ev, &eventqueue, ev_next)
			if (ev->ev_fd > sop->event_fds)
				sop->event_fds = ev->ev_fd;
	}

	fdsz = howmany(sop->event_fds + 1, NFDBITS) * sizeof(fd_mask);
	if (fdsz > sop->event_fdsz) {
		if ((readset = realloc(sop->event_readset, fdsz)) == NULL) {
			log_error("malloc");
			return (-1);
		}

		if ((writeset = realloc(sop->event_writeset, fdsz)) == NULL) {
			log_error("malloc");
			free(readset);
			return (-1);
		}
d148 1
a148 9
		memset((char *)readset + sop->event_fdsz, 0,
		    fdsz - sop->event_fdsz);
		memset((char *)writeset + sop->event_fdsz, 0,
		    fdsz - sop->event_fdsz);

		sop->event_readset = readset;
		sop->event_writeset = writeset;
		sop->event_fdsz = fdsz;
	}
d154 1
a154 1
select_dispatch(void *arg, struct timeval *tv)
d156 1
a156 2
	int maxfd, res;
	struct event *ev, *next;
d159 1
a159 2
	memset(sop->event_readset, 0, sop->event_fdsz);
	memset(sop->event_writeset, 0, sop->event_fdsz);
d161 4
a164 6
	TAILQ_FOREACH(ev, &eventqueue, ev_next) {
		if (ev->ev_events & EV_WRITE)
			FD_SET(ev->ev_fd, sop->event_writeset);
		if (ev->ev_events & EV_READ)
			FD_SET(ev->ev_fd, sop->event_readset);
	}
d169 2
a170 2
	res = select(sop->event_fds + 1, sop->event_readset, 
	    sop->event_writeset, NULL, tv);
d172 1
d178 1
a178 1
			log_error("select");
d187 1
a187 5
	LOG_DBG((LOG_MISC, 80, "%s: select reports %d", __func__, res));

	maxfd = 0;
	for (ev = TAILQ_FIRST(&eventqueue); ev != NULL; ev = next) {
		next = TAILQ_NEXT(ev, ev_next);
d189 3
d193 2
a194 1
		if (FD_ISSET(ev->ev_fd, sop->event_readset))
d196 3
a198 1
		if (FD_ISSET(ev->ev_fd, sop->event_writeset))
d200 17
a216 1
		res &= ev->ev_events;
d218 47
a264 7
		if (res) {
			if (!(ev->ev_events & EV_PERSIST))
				event_del(ev);
			event_active(ev, res, 1);
		} else if (ev->ev_fd > maxfd)
			maxfd = ev->ev_fd;
	}
d266 2
a267 1
	sop->event_fds = maxfd;
d270 4
d276 1
d285 2
a286 1
	/* 
d290 17
a306 1
	if (sop->event_fds < ev->ev_fd)
d308 11
d332 6
a337 1
	if (!(ev->ev_events & EV_SIGNAL))
d339 6
d346 7
a352 1
	return (evsignal_del(&sop->evsigmask, ev));
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@improve my Frankenstein OS (*wink* you know who you are) further
sans wchar_t of course

this is the essence of reading >1200 commit messages which suck
due to not having the new format of ours...
@
text
@d1 1
a1 1
/*	$OpenBSD: select.c,v 1.9 2005/04/22 00:56:25 brad Exp $	*/
a39 1
#include <sys/tree.h>
d46 8
a55 1
#include "event-internal.h"
d57 2
a58 1
#include "log.h"
d72 1
a72 1
};
d77 2
a78 2
int select_recalc	(struct event_base *, void *, int);
int select_dispatch	(struct event_base *, void *, struct timeval *);
a91 2
	struct selectop *sop;

d96 1
a96 2
	if (!(sop = calloc(1, sizeof(struct selectop))))
		return (NULL);
d98 1
a98 1
	evsignal_init(&sop->evsigmask);
d100 1
a100 1
	return (sop);
d109 1
a109 1
select_recalc(struct event_base *base, void *arg, int max)
d120 1
a120 1
		TAILQ_FOREACH(ev, &base->eventqueue, ev_next)
d128 1
a128 1
			event_warn("malloc");
d133 1
a133 1
			event_warn("malloc");
d152 1
a152 1
select_dispatch(struct event_base *base, void *arg, struct timeval *tv)
d161 1
a161 1
	TAILQ_FOREACH(ev, &base->eventqueue, ev_next) {
d179 1
a179 1
			event_warn("select");
d188 1
a188 1
	event_debug(("%s: select reports %d", __func__, res));
d191 1
a191 1
	for (ev = TAILQ_FIRST(&base->eventqueue); ev != NULL; ev = next) {
a203 2
			else if (ev->ev_fd > maxfd)
				maxfd = ev->ev_fd;
@


1.1.1.3
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d1 1
a1 1
/*	$OpenBSD: select.c,v 1.11 2005/06/18 01:52:22 brad Exp $	*/
a46 3
#ifdef CHECK_INVARIANTS
#include <assert.h>
#endif
d62 2
a63 6
	fd_set *event_readset_in;
	fd_set *event_writeset_in;
	fd_set *event_readset_out;
	fd_set *event_writeset_out;
	struct event **event_r_by_fd;
	struct event **event_w_by_fd;
a81 2
static int select_resize(struct selectop *sop, int fdsz);

d87 1
a87 1
	/* Disable select when this environment variable is set */
a93 2
	select_resize(sop, howmany(32 + 1, NFDBITS)*sizeof(fd_mask));

a98 27
#ifdef CHECK_INVARIANTS
static void
check_selectop(struct selectop *sop)
{
	int i;
	for (i=0;i<=sop->event_fds;++i) {
		if (FD_ISSET(i, sop->event_readset_in)) {
			assert(sop->event_r_by_fd[i]);
			assert(sop->event_r_by_fd[i]->ev_events & EV_READ);
			assert(sop->event_r_by_fd[i]->ev_fd == i);
		} else {
			assert(! sop->event_r_by_fd[i]);
		}
		if (FD_ISSET(i, sop->event_writeset_in)) {
			assert(sop->event_w_by_fd[i]);
			assert(sop->event_w_by_fd[i]->ev_events & EV_WRITE);
			assert(sop->event_w_by_fd[i]->ev_fd == i);
		} else {
			assert(! sop->event_w_by_fd[i]);
		}
	}

}
#else
#define check_selectop(sop)
#endif

d108 25
d134 9
a142 1
	check_selectop(sop);
d150 2
a151 1
	int res, i;
d154 2
a155 1
	check_selectop(sop);
d157 6
a162 4
	memcpy(sop->event_readset_out, sop->event_readset_in,
	       sop->event_fdsz);
	memcpy(sop->event_writeset_out, sop->event_writeset_in,
	       sop->event_fdsz);
d167 2
a168 2
	res = select(sop->event_fds + 1, sop->event_readset_out,
	    sop->event_writeset_out, NULL, tv);
a169 1
	check_selectop(sop);
d186 4
a189 3
	check_selectop(sop);
	for (i = 0; i <= sop->event_fds; ++i) {
		struct event *r_ev = NULL, *w_ev = NULL;
d191 1
a191 2
		if (FD_ISSET(i, sop->event_readset_out)) {
			r_ev = sop->event_r_by_fd[i];
d193 1
a193 3
		}
		if (FD_ISSET(i, sop->event_writeset_out)) {
			w_ev = sop->event_w_by_fd[i];
d195 10
a204 11
		}
		if (r_ev && (res & r_ev->ev_events)) {
			if (!(r_ev->ev_events & EV_PERSIST))
				event_del(r_ev);
			event_active(r_ev, res & r_ev->ev_events, 1);
		}
		if (w_ev && w_ev != r_ev && (res & w_ev->ev_events)) {
			if (!(w_ev->ev_events & EV_PERSIST))
				event_del(w_ev);
			event_active(w_ev, res & w_ev->ev_events, 1);
		}
a205 1
	check_selectop(sop);
d207 1
a207 54
	return (0);
}


static int
select_resize(struct selectop *sop, int fdsz)
{
	int n_events, n_events_old;

	fd_set *readset_in = NULL;
	fd_set *writeset_in = NULL;
	fd_set *readset_out = NULL;
	fd_set *writeset_out = NULL;
	struct event **r_by_fd = NULL;
	struct event **w_by_fd = NULL;

	n_events = (fdsz/sizeof(fd_mask)) * NFDBITS;
	n_events_old = (sop->event_fdsz/sizeof(fd_mask)) * NFDBITS;

	if (sop->event_readset_in)
		check_selectop(sop);

	if ((readset_in = realloc(sop->event_readset_in, fdsz)) == NULL)
		goto error;
	sop->event_readset_in = readset_in;
	if ((readset_out = realloc(sop->event_readset_out, fdsz)) == NULL)
		goto error;
	sop->event_readset_out = readset_out;
	if ((writeset_in = realloc(sop->event_writeset_in, fdsz)) == NULL)
		goto error;
	sop->event_writeset_in = writeset_in;
	if ((writeset_out = realloc(sop->event_writeset_out, fdsz)) == NULL)
		goto error;
	sop->event_writeset_out = writeset_out;
	if ((r_by_fd = realloc(sop->event_r_by_fd,
		 n_events*sizeof(struct event*))) == NULL)
		goto error;
	sop->event_r_by_fd = r_by_fd;
	if ((w_by_fd = realloc(sop->event_w_by_fd,
		 n_events * sizeof(struct event*))) == NULL)
		goto error;
	sop->event_w_by_fd = w_by_fd;

	memset((char *)sop->event_readset_in + sop->event_fdsz, 0,
	    fdsz - sop->event_fdsz);
	memset((char *)sop->event_writeset_in + sop->event_fdsz, 0,
	    fdsz - sop->event_fdsz);
	memset(sop->event_r_by_fd + n_events_old, 0,
	    (n_events-n_events_old) * sizeof(struct event*));
	memset(sop->event_w_by_fd + n_events_old, 0,
	    (n_events-n_events_old) * sizeof(struct event*));

	sop->event_fdsz = fdsz;
	check_selectop(sop);
a209 4

 error:
	event_warn("malloc");
	return (-1);
a211 1

d220 1
a220 2
	check_selectop(sop);
	/*
d224 1
a224 17
	if (sop->event_fds < ev->ev_fd) {
		int fdsz = sop->event_fdsz;

		if (fdsz < sizeof(fd_mask))
			fdsz = sizeof(fd_mask);

		while (fdsz <
		    (howmany(ev->ev_fd + 1, NFDBITS) * sizeof(fd_mask)))
			fdsz *= 2;

		if (fdsz != sop->event_fdsz) {
			if (select_resize(sop, fdsz)) {
				check_selectop(sop);
				return (-1);
			}
		}

a225 11
	}

	if (ev->ev_events & EV_READ) {
		FD_SET(ev->ev_fd, sop->event_readset_in);
		sop->event_r_by_fd[ev->ev_fd] = ev;
	}
	if (ev->ev_events & EV_WRITE) {
		FD_SET(ev->ev_fd, sop->event_writeset_in);
		sop->event_w_by_fd[ev->ev_fd] = ev;
	}
	check_selectop(sop);
d239 1
a239 6
	check_selectop(sop);
	if (ev->ev_events & EV_SIGNAL)
		return (evsignal_del(&sop->evsigmask, ev));

	if (sop->event_fds < ev->ev_fd) {
		check_selectop(sop);
a240 6
	}

	if (ev->ev_events & EV_READ) {
		FD_CLR(ev->ev_fd, sop->event_readset_in);
		sop->event_r_by_fd[ev->ev_fd] = NULL;
	}
d242 1
a242 7
	if (ev->ev_events & EV_WRITE) {
		FD_CLR(ev->ev_fd, sop->event_writeset_in);
		sop->event_w_by_fd[ev->ev_fd] = NULL;
	}

	check_selectop(sop);
	return (0);
@


1.1.1.4
log
@Import libevent 1.1b+fixes from OpenBSD-current, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: select.c,v 1.12 2006/03/30 06:32:36 brad Exp $	*/
a78 1
void select_dealloc     (void *);
d86 1
a86 2
	select_dispatch,
	select_dealloc
a352 22

void
select_dealloc(void *arg)
{
	struct selectop *sop = arg;

	if (sop->event_readset_in)
		free(sop->event_readset_in);
	if (sop->event_writeset_in)
		free(sop->event_writeset_in);
	if (sop->event_readset_out)
		free(sop->event_readset_out);
	if (sop->event_writeset_out)
		free(sop->event_writeset_out);
	if (sop->event_r_by_fd)
		free(sop->event_r_by_fd);
	if (sop->event_w_by_fd)
		free(sop->event_w_by_fd);

	memset(sop, 0, sizeof(struct selectop));
	free(sop);
}
@


1.1.1.5
log
@import latest libevent via openbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: select.c,v 1.13 2007/03/19 15:12:49 millert Exp $	*/
d136 1
a136 1
#define check_selectop(sop) do { (void) sop; } while (0)
@


1.1.1.6
log
@import latest stable 1.4 libevent, in the OpenBSD version (diff against portable version reviewed-okay)
@
text
@d1 1
a1 1
/*	$OpenBSD: select.c,v 1.16 2010/04/21 21:02:47 nicm Exp $	*/
d37 1
a37 4
#include <sys/_libevent_time.h>
#endif
#ifdef HAVE_SYS_SELECT_H
#include <sys/select.h>
d40 1
a51 1
#include "evutil.h"
d60 1
a60 6
#ifndef HAVE_FD_MASK
/* This type is mandatory, but Android doesn't define it. */
#undef NFDBITS
#define NFDBITS (sizeof(long)*8)
typedef unsigned long fd_mask;
#endif
d71 1
d74 6
a79 5
static void *select_init	(struct event_base *);
static int select_add		(void *, struct event *);
static int select_del		(void *, struct event *);
static int select_dispatch	(struct event_base *, void *, struct timeval *);
static void select_dealloc     (struct event_base *, void *);
d86 1
d88 1
a88 2
	select_dealloc,
	0
d93 2
a94 2
static void *
select_init(struct event_base *base)
d99 1
a99 1
	if (evutil_getenv("EVENT_NOSELECT"))
d107 1
a107 1
	evsignal_init(base);
d117 1
a117 1
	for (i = 0; i <= sop->event_fds; ++i) {
d139 16
a154 1
static int
d157 1
a157 1
	int res, i, j;
d167 3
d174 2
d183 1
a183 1
		evsignal_process(base);
d185 2
a186 3
	} else if (base->sig.evsignal_caught) {
		evsignal_process(base);
	}
d191 1
a191 2
	i = random() % (sop->event_fds+1);
	for (j = 0; j <= sop->event_fds; ++j) {
a192 3
		if (++i >= sop->event_fds+1)
			i = 0;

d203 2
d208 2
d278 1
a278 1
static int
d284 1
a284 1
		return (evsignal_add(ev));
d328 1
a328 1
static int
d335 1
a335 1
		return (evsignal_del(ev));
d356 2
a357 2
static void
select_dealloc(struct event_base *base, void *arg)
a360 1
	evsignal_dealloc(base);
@


