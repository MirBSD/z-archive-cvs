head	1.7;
access;
symbols
	cvs-201210191930:1.1.1.7
	MIRBSD_10:1.6.0.2
	MIRBSD_10_BASE:1.6
	cvs-200705171630:1.1.1.6
	cvs-200702051630:1.1.1.5
	MIRBSD_9_BASE:1.2
	MIRBSD_8:1.2.0.2
	MIRBSD_8_BASE:1.2
	cvs-200507211800:1.1.1.4
	cvs-200505050030:1.1.1.3
	cvs-200504291700:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2012.10.19.19.58.18;	author tg;	state Exp;
branches;
next	1.6;
commitid	1005081B0E54727ACCA;

1.6
date	2007.05.17.17.15.35;	author tg;	state Exp;
branches;
next	1.5;
commitid	100464C8DC46A1A51B5;

1.5
date	2007.05.17.16.48.21;	author tg;	state Exp;
branches;
next	1.4;
commitid	100464C876417B6519F;

1.4
date	2007.05.17.16.40.57;	author tg;	state Exp;
branches;
next	1.3;
commitid	100464C85AF54416520;

1.3
date	2007.02.05.16.42.30;	author tg;	state Exp;
branches;
next	1.2;
commitid	10045C75E8B3A2257F9;

1.2
date	2005.10.21.11.02.43;	author tg;	state Exp;
branches;
next	1.1;
commitid	6c0b4358cac0ef88;

1.1
date	2005.02.05.17.25.14;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.25.14;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.29.17.05.23;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.05.05.00.32.58;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	48e9427969c07d49;

1.1.1.4
date	2005.07.21.20.53.51;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	560042e0092f571e;

1.1.1.5
date	2007.02.05.16.38.52;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	10045C75DA6486B10AC;

1.1.1.6
date	2007.05.17.16.38.22;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	100464C84A31EC59432;

1.1.1.7
date	2012.10.19.19.33.47;	author tg;	state Exp;
branches;
next	;
commitid	1005081AB336FC5E505;


desc
@@


1.7
log
@merge latest stable-1.4 libevent
@
text
@/*	$OpenBSD: kqueue.c,v 1.28 2012/02/08 09:01:00 nicm Exp $	*/

/*
 * Copyright 2000-2002 Niels Provos <provos@@citi.umich.edu>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#define _GNU_SOURCE 1

#include <sys/types.h>
#ifdef HAVE_SYS_TIME_H
#include <sys/time.h>
#else
#include <sys/_libevent_time.h>
#endif
#include <sys/queue.h>
#include <sys/event.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <assert.h>
#ifdef HAVE_INTTYPES_H
#include <inttypes.h>
#endif

/* Some platforms apparently define the udata field of struct kevent as
 * intptr_t, whereas others define it as void*.  There doesn't seem to be an
 * easy way to tell them apart via autoconf, so we need to use OS macros. */
#if defined(HAVE_INTTYPES_H) && !defined(__OpenBSD__) && !defined(__FreeBSD__) && !defined(__darwin__) && !defined(__APPLE__)
#define PTR_TO_UDATA(x)	((intptr_t)(x))
#else
#define PTR_TO_UDATA(x)	(x)
#endif

#include "event.h"
#include "event-internal.h"
#include "log.h"
#include "evsignal.h"

__RCSID("$MirOS$");

#define EVLIST_X_KQINKERNEL	0x1000

#define NEVENT		64

struct kqop {
	struct kevent *changes;
	int nchanges;
	struct kevent *events;
	struct event_list evsigevents[NSIG];
	int nevents;
	int kq;
	pid_t pid;
};

static void *kq_init	(struct event_base *);
static int kq_add	(void *, struct event *);
static int kq_del	(void *, struct event *);
static int kq_dispatch	(struct event_base *, void *, struct timeval *);
static int kq_insert	(struct kqop *, struct kevent *);
static void kq_dealloc (struct event_base *, void *);

const struct eventop kqops = {
	"kqueue",
	kq_init,
	kq_add,
	kq_del,
	kq_dispatch,
	kq_dealloc,
	1 /* need reinit */
};

static void *
kq_init(struct event_base *base __unused)
{
	int i, kq;
	struct kqop *kqueueop;

	/* Disable kqueue when this environment variable is set */
	if (evutil_getenv("EVENT_NOKQUEUE"))
		return (NULL);

	if (!(kqueueop = calloc(1, sizeof(struct kqop))))
		return (NULL);

	/* Initalize the kernel queue */
	
	if ((kq = kqueue()) == -1) {
		event_warn("kqueue");
		free (kqueueop);
		return (NULL);
	}

	kqueueop->kq = kq;

	kqueueop->pid = getpid();

	/* Initalize fields */
	kqueueop->changes = calloc(NEVENT, sizeof(struct kevent));
	if (kqueueop->changes == NULL) {
		free (kqueueop);
		return (NULL);
	}
	kqueueop->events = calloc(NEVENT, sizeof(struct kevent));
	if (kqueueop->events == NULL) {
		free (kqueueop->changes);
		free (kqueueop);
		return (NULL);
	}
	kqueueop->nevents = NEVENT;

	/* we need to keep track of multiple events per signal */
	for (i = 0; i < NSIG; ++i) {
		TAILQ_INIT(&kqueueop->evsigevents[i]);
	}

	/* Check for Mac OS X kqueue bug. */
	kqueueop->changes[0].ident = -1;
	kqueueop->changes[0].filter = EVFILT_READ;
	kqueueop->changes[0].flags = EV_ADD;
	/* 
	 * If kqueue works, then kevent will succeed, and it will
	 * stick an error in events[0].  If kqueue is broken, then
	 * kevent will fail.
	 */
	if (kevent(kq,
		kqueueop->changes, 1, kqueueop->events, NEVENT, NULL) != 1 ||
	    kqueueop->events[0].ident != (u_int)-1 ||
	    kqueueop->events[0].flags != EV_ERROR) {
		event_warn("%s: detected broken kqueue; not using.", __func__);
		free(kqueueop->changes);
		free(kqueueop->events);
		free(kqueueop);
		close(kq);
		return (NULL);
	}

	return (kqueueop);
}

static int
kq_insert(struct kqop *kqop, struct kevent *kev)
{
	int nevents = kqop->nevents;

	if (kqop->nchanges == nevents) {
		struct kevent *newchange;
		struct kevent *newresult;

		nevents *= 2;

		newchange = realloc(kqop->changes,
				    nevents * sizeof(struct kevent));
		if (newchange == NULL) {
			event_warn("%s: malloc", __func__);
			return (-1);
		}
		kqop->changes = newchange;

		newresult = realloc(kqop->events,
				    nevents * sizeof(struct kevent));

		/*
		 * If we fail, we don't have to worry about freeing,
		 * the next realloc will pick it up.
		 */
		if (newresult == NULL) {
			event_warn("%s: malloc", __func__);
			return (-1);
		}
		kqop->events = newresult;

		kqop->nevents = nevents;
	}

	memcpy(&kqop->changes[kqop->nchanges++], kev, sizeof(struct kevent));

	event_debug(("%s: fd %d %s%s",
		__func__, (int)kev->ident, 
		kev->filter == EVFILT_READ ? "EVFILT_READ" : "EVFILT_WRITE",
		kev->flags == EV_DELETE ? " (del)" : ""));

	return (0);
}

static void
kq_sighandler(int sig __unused)
{
	/* Do nothing here */
}

static int
kq_dispatch(struct event_base *base __unused, void *arg, struct timeval *tv)
{
	struct kqop *kqop = arg;
	struct kevent *changes = kqop->changes;
	struct kevent *events = kqop->events;
	struct event *ev;
	struct timespec ts, *ts_p = NULL;
	int i, res;

	if (tv != NULL) {
		TIMEVAL_TO_TIMESPEC(tv, &ts);
		ts_p = &ts;
	}

	res = kevent(kqop->kq, changes, kqop->nchanges,
	    events, kqop->nevents, ts_p);
	kqop->nchanges = 0;
	if (res == -1) {
		if (errno != EINTR) {
                        event_warn("kevent");
			return (-1);
		}

		return (0);
	}

	event_debug(("%s: kevent reports %d", __func__, res));

	for (i = 0; i < res; i++) {
		int which = 0;

		if (events[i].flags & EV_ERROR) {
			switch (events[i].data) {

			/* Can occur on delete if we are not currently
			 * watching any events on this fd.  That can
			 * happen when the fd was closed and another
			 * file was opened with that fd. */
			case ENOENT:
			/* Can occur for reasons not fully understood
			 * on FreeBSD. */
			case EINVAL:
				continue;
			/* Can occur on a delete if the fd is closed.  Can
			 * occur on an add if the fd was one side of a pipe,
			 * and the other side was closed. */
			case EBADF:
				continue;
			/* These two can occur on an add if the fd was one side
			 * of a pipe, and the other side was closed. */
			case EPERM:
			case EPIPE:
				/* Report read events, if we're listening for
				 * them, so that the user can learn about any
				 * add errors.  (If the operation was a
				 * delete, then udata should be cleared.) */
				if (events[i].udata) {
					/* The operation was an add:
					 * report the error as a read. */
					which |= EV_READ;
					break;
				} else {
					/* The operation was a del:
					 * report nothing. */
					continue;
				}

			/* Other errors shouldn't occur. */
			default:
				errno = events[i].data;
				return (-1);
			}
		} else if (events[i].filter == EVFILT_READ) {
			which |= EV_READ;
		} else if (events[i].filter == EVFILT_WRITE) {
			which |= EV_WRITE;
		} else if (events[i].filter == EVFILT_SIGNAL) {
			which |= EV_SIGNAL;
		}

		if (!which)
			continue;

		if (events[i].filter == EVFILT_SIGNAL) {
			struct event_list *head =
			    (struct event_list *)events[i].udata;
			TAILQ_FOREACH(ev, head, ev_signal_next) {
				event_active(ev, which, events[i].data);
			}
		} else {
			ev = (struct event *)events[i].udata;

			if (!(ev->ev_events & EV_PERSIST))
				ev->ev_flags &= ~EVLIST_X_KQINKERNEL;

			event_active(ev, which, 1);
		}
	}

	return (0);
}


static int
kq_add(void *arg, struct event *ev)
{
	struct kqop *kqop = arg;
	struct kevent kev;

	if (ev->ev_events & EV_SIGNAL) {
		int nsignal = EVENT_SIGNAL(ev);

		assert(nsignal >= 0 && nsignal < NSIG);
		if (TAILQ_EMPTY(&kqop->evsigevents[nsignal])) {
			struct timespec timeout = { 0, 0 };
			
			memset(&kev, 0, sizeof(kev));
			kev.ident = nsignal;
			kev.filter = EVFILT_SIGNAL;
			kev.flags = EV_ADD;
			kev.udata = PTR_TO_UDATA(&kqop->evsigevents[nsignal]);
			
			/* Be ready for the signal if it is sent any
			 * time between now and the next call to
			 * kq_dispatch. */
			if (kevent(kqop->kq, &kev, 1, NULL, 0, &timeout) == -1)
				return (-1);

			if (_evsignal_set_handler(ev->ev_base, nsignal,
				kq_sighandler) == -1)
				return (-1);
		}

		TAILQ_INSERT_TAIL(&kqop->evsigevents[nsignal], ev,
		    ev_signal_next);
		ev->ev_flags |= EVLIST_X_KQINKERNEL;
		return (0);
	}

	if (ev->ev_events & EV_READ) {
 		memset(&kev, 0, sizeof(kev));
		kev.ident = ev->ev_fd;
		kev.filter = EVFILT_READ;
#ifdef NOTE_EOF
		/* Make it behave like select() and poll() */
		kev.fflags = NOTE_EOF;
#endif
		kev.flags = EV_ADD;
		if (!(ev->ev_events & EV_PERSIST))
			kev.flags |= EV_ONESHOT;
		kev.udata = PTR_TO_UDATA(ev);
		
		if (kq_insert(kqop, &kev) == -1)
			return (-1);

		ev->ev_flags |= EVLIST_X_KQINKERNEL;
	}

	if (ev->ev_events & EV_WRITE) {
 		memset(&kev, 0, sizeof(kev));
		kev.ident = ev->ev_fd;
		kev.filter = EVFILT_WRITE;
		kev.flags = EV_ADD;
		if (!(ev->ev_events & EV_PERSIST))
			kev.flags |= EV_ONESHOT;
		kev.udata = PTR_TO_UDATA(ev);
		
		if (kq_insert(kqop, &kev) == -1)
			return (-1);

		ev->ev_flags |= EVLIST_X_KQINKERNEL;
	}

	return (0);
}

static int
kq_del(void *arg, struct event *ev)
{
	struct kqop *kqop = arg;
	struct kevent kev;

	if (!(ev->ev_flags & EVLIST_X_KQINKERNEL))
		return (0);

	if (ev->ev_events & EV_SIGNAL) {
		int nsignal = EVENT_SIGNAL(ev);
		struct timespec timeout = { 0, 0 };

		assert(nsignal >= 0 && nsignal < NSIG);
		TAILQ_REMOVE(&kqop->evsigevents[nsignal], ev, ev_signal_next);
		if (TAILQ_EMPTY(&kqop->evsigevents[nsignal])) {
			memset(&kev, 0, sizeof(kev));
			kev.ident = nsignal;
			kev.filter = EVFILT_SIGNAL;
			kev.flags = EV_DELETE;
		
			/* Because we insert signal events
			 * immediately, we need to delete them
			 * immediately, too */
			if (kevent(kqop->kq, &kev, 1, NULL, 0, &timeout) == -1)
				return (-1);

			if (_evsignal_restore_handler(ev->ev_base,
				nsignal) == -1)
				return (-1);
		}

		ev->ev_flags &= ~EVLIST_X_KQINKERNEL;
		return (0);
	}

	if (ev->ev_events & EV_READ) {
 		memset(&kev, 0, sizeof(kev));
		kev.ident = ev->ev_fd;
		kev.filter = EVFILT_READ;
		kev.flags = EV_DELETE;
		
		if (kq_insert(kqop, &kev) == -1)
			return (-1);

		ev->ev_flags &= ~EVLIST_X_KQINKERNEL;
	}

	if (ev->ev_events & EV_WRITE) {
 		memset(&kev, 0, sizeof(kev));
		kev.ident = ev->ev_fd;
		kev.filter = EVFILT_WRITE;
		kev.flags = EV_DELETE;
		
		if (kq_insert(kqop, &kev) == -1)
			return (-1);

		ev->ev_flags &= ~EVLIST_X_KQINKERNEL;
	}

	return (0);
}

static void
kq_dealloc(struct event_base *base, void *arg)
{
	struct kqop *kqop = arg;

	evsignal_dealloc(base);

	if (kqop->changes)
		free(kqop->changes);
	if (kqop->events)
		free(kqop->events);
	if (kqop->kq >= 0 && kqop->pid == getpid())
		close(kqop->kq);

	memset(kqop, 0, sizeof(struct kqop));
	free(kqop);
}
@


1.6
log
@__CRAZY=Yes clean, fixes a few real bugs
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.22 2007/03/19 15:12:49 millert Exp $	*/
d33 2
d39 1
a39 1
#include <sys/_time.h>
d49 1
d54 5
a58 2
#if defined(HAVE_INTTYPES_H) && !defined(__OpenBSD__) && !defined(__FreeBSD__)
#define INTPTR(x)	(intptr_t)x
d60 1
a60 1
#define INTPTR(x)	x
d64 1
d66 1
d68 1
a68 1
__RCSID("$MirOS: src/lib/libevent/kqueue.c,v 1.5 2007/05/17 16:48:21 tg Exp $");
d78 1
d81 1
d84 6
a89 7
void *kq_init	(void);
int kq_add	(void *, struct event *);
int kq_del	(void *, struct event *);
int kq_recalc	(struct event_base *, void *, int);
int kq_dispatch	(struct event_base *, void *, struct timeval *);
int kq_insert	(struct kqop *, struct kevent *);
void kq_dealloc (void *);
a95 1
	kq_recalc,
d97 2
a98 1
	kq_dealloc
d101 2
a102 2
void *
kq_init(void)
d104 1
a104 1
	int kq;
d108 1
a108 1
	if (!issetugid() && getenv("EVENT_NOKQUEUE"))
d115 1
a115 1

d124 2
d127 1
a127 1
	kqueueop->changes = malloc(NEVENT * sizeof(struct kevent));
d132 1
a132 1
	kqueueop->events = malloc(NEVENT * sizeof(struct kevent));
d140 5
d149 1
a149 1
	/*
d169 1
a169 8
int
kq_recalc(struct event_base *base __attribute__((unused)),
    void *arg __attribute__((unused)), int max __attribute__((unused)))
{
	return (0);
}

int
d207 3
a209 3
		 __func__, kev->ident,
		 kev->filter == EVFILT_READ ? "EVFILT_READ" : "EVFILT_WRITE",
		 kev->flags == EV_DELETE ? " (del)" : ""));
d215 1
a215 1
kq_sighandler(int sig __attribute__((unused)))
d220 2
a221 3
int
kq_dispatch(struct event_base *base __attribute__((unused)),
    void *arg, struct timeval *tv)
d227 1
a227 1
	struct timespec ts;
d230 4
a233 1
	TIMEVAL_TO_TIMESPEC(tv, &ts);
d236 1
a236 1
	    events, kqop->nevents, &ts);
d253 10
a262 15
			/*
			 * Error messages that can happen, when a delete fails.
			 *   EBADF happens when the file discriptor has been
			 *   closed,
			 *   ENOENT when the file discriptor was closed and
			 *   then reopened.
			 *   EINVAL for some reasons not understood; EINVAL
			 *   should not be returned ever; but FreeBSD does :-\
			 * An error is also indicated when a callback deletes
			 * an event we are still processing.  In that case
			 * the data field is set to ENOENT.
			 */
			if (events[i].data == EBADF ||
			    events[i].data == EINVAL ||
			    events[i].data == ENOENT)
d264 30
a293 7
			errno = events[i].data;
			return (-1);
		}

		ev = (struct event *)events[i].udata;

		if (events[i].filter == EVFILT_READ) {
d304 11
a314 2
		if (!(ev->ev_events & EV_PERSIST))
			event_del(ev);
d316 2
a317 2
		event_active(ev, which,
		    ev->ev_events & EV_SIGNAL ? events[i].data : 1);
d324 1
a324 1
int
d333 20
a352 13
 		memset(&kev, 0, sizeof(kev));
		kev.ident = nsignal;
		kev.filter = EVFILT_SIGNAL;
		kev.flags = EV_ADD;
		if (!(ev->ev_events & EV_PERSIST))
			kev.flags |= EV_ONESHOT;
		kev.udata = INTPTR(ev);

		if (kq_insert(kqop, &kev) == -1)
			return (-1);

		if (signal(nsignal, kq_sighandler) == SIG_ERR)
			return (-1);
d354 2
d371 2
a372 2
		kev.udata = INTPTR(ev);

d386 2
a387 2
		kev.udata = INTPTR(ev);

d397 1
a397 1
int
d408 1
d410 18
a427 10
 		memset(&kev, 0, sizeof(kev));
		kev.ident = nsignal;
		kev.filter = EVFILT_SIGNAL;
		kev.flags = EV_DELETE;

		if (kq_insert(kqop, &kev) == -1)
			return (-1);

		if (signal(nsignal, SIG_DFL) == SIG_ERR)
			return (-1);
d438 1
a438 1

d450 1
a450 1

d460 2
a461 2
void
kq_dealloc(void *arg)
d465 2
d471 1
a471 1
	if (kqop->kq)
d473 1
@


1.5
log
@• how could they ever build this?
• rcsids
@
text
@d60 1
a60 1
__RCSID("$MirOS$");
d154 2
a155 1
kq_recalc(struct event_base *base, void *arg, int max)
d206 1
a206 1
kq_sighandler(int sig)
d212 2
a213 1
kq_dispatch(struct event_base *base, void *arg, struct timeval *tv)
@


1.4
log
@fastmerge
@
text
@d60 2
@


1.3
log
@merge libevent
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.21 2006/11/05 17:07:07 brad Exp $	*/
d104 1
a104 1
	
d298 1
a298 1
		
d321 1
a321 1
		
d336 1
a336 1
		
d362 1
a362 1
		
d378 1
a378 1
		
d390 1
a390 1
		
@


1.2
log
@* merge bin and lib completely
* convert some ancient RCSID styles etc. to more modern stuff
* fix use of CDIAGFLAGS+=, CFLAGS+= and COPTS+= to the correct
  variant (include bsd.own.mk _then_ COPTS+=) so they're added
  after any user-specified flags
  (this is probably lurking in more places than I can imagine)
* fix some indenting, comments, etc.
* make stuff compile (fix warnings/errors)
* add script to review _all_ shlib_version after an openbsd import
* remove two more obsolete /usr/lib/debug/ references
* bin/ps: comment out some SMP code
@
text
@d1 1
a1 2
/**	$MirOS$ */
/*	$OpenBSD: kqueue.c,v 1.18 2005/07/02 07:15:13 grunk Exp $	*/
d78 1
d86 2
a87 1
	kq_dispatch
d271 1
a271 2
		if (!(ev->ev_events & EV_PERSIST)) {
			ev->ev_flags &= ~EVLIST_X_KQINKERNEL;
a272 1
		}
d359 1
a359 1
		kev.ident = (int)signal;
d399 15
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$OpenBSD: kqueue.c,v 1.12 2004/04/28 06:53:12 brad Exp $	*/
a47 1
#include <err.h>
d52 1
a52 8
#ifdef USE_LOG
#include "log.h"
#else
#define LOG_DBG(x)
#define log_error	warn
#endif

#if defined(HAVE_INTTYPES_H) && !defined(__OpenBSD__)
d59 1
a59 4

extern struct event_list timequeue;
extern struct event_list eventqueue;
extern struct event_list addqueue;
d71 1
a71 1
} kqueueop;
d76 2
a77 2
int kq_recalc	(void *, int);
int kq_dispatch	(void *, struct timeval *);
d93 1
d99 2
a100 1
	memset(&kqueueop, 0, sizeof(kqueueop));
d105 2
a106 1
		log_error("kqueue");
d110 1
a110 1
	kqueueop.kq = kq;
d113 9
a121 2
	kqueueop.changes = malloc(NEVENT * sizeof(struct kevent));
	if (kqueueop.changes == NULL)
d123 21
a143 3
	kqueueop.events = malloc(NEVENT * sizeof(struct kevent));
	if (kqueueop.events == NULL) {
		free (kqueueop.changes);
a145 1
	kqueueop.nevents = NEVENT;
d147 1
a147 1
	return (&kqueueop);
d151 1
a151 1
kq_recalc(void *arg, int max)
d170 1
a170 1
			log_error("%s: malloc", __func__);
d183 1
a183 1
			log_error("%s: malloc", __func__);
d193 2
a194 2
	LOG_DBG((LOG_MISC, 70, "%s: fd %d %s%s",
		 __func__, kev->ident, 
d208 1
a208 1
kq_dispatch(void *arg, struct timeval *tv)
d224 1
a224 1
			log_error("kevent");
d231 1
a231 1
	LOG_DBG((LOG_MISC, 80, "%s: kevent reports %d", __func__, res));
d237 1
a237 1
			/* 
d243 2
d250 1
d253 1
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@improve my Frankenstein OS (*wink* you know who you are) further
sans wchar_t of course

this is the essence of reading >1200 commit messages which suck
due to not having the new format of ours...
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.15 2005/04/22 00:56:25 brad Exp $	*/
d47 1
d52 8
a59 1
#if defined(HAVE_INTTYPES_H) && !defined(__OpenBSD__) && !defined(__FreeBSD__)
d66 4
a69 1
#include "log.h"
d81 1
a81 1
};
d86 2
a87 2
int kq_recalc	(struct event_base *, void *, int);
int kq_dispatch	(struct event_base *, void *, struct timeval *);
a102 1
	struct kqop *kqueueop;
d108 1
a108 2
	if (!(kqueueop = calloc(1, sizeof(struct kqop))))
		return (NULL);
d113 1
a113 2
		event_warn("kqueue");
		free (kqueueop);
d117 1
a117 1
	kqueueop->kq = kq;
d120 2
a121 3
	kqueueop->changes = malloc(NEVENT * sizeof(struct kevent));
	if (kqueueop->changes == NULL) {
		free (kqueueop);
d123 3
a125 5
	}
	kqueueop->events = malloc(NEVENT * sizeof(struct kevent));
	if (kqueueop->events == NULL) {
		free (kqueueop->changes);
		free (kqueueop);
d128 1
a128 1
	kqueueop->nevents = NEVENT;
d130 1
a130 1
	return (kqueueop);
d134 1
a134 1
kq_recalc(struct event_base *base, void *arg, int max)
d153 1
a153 1
			event_warn("%s: malloc", __func__);
d166 1
a166 1
			event_warn("%s: malloc", __func__);
d176 1
a176 1
	event_debug(("%s: fd %d %s%s",
d191 1
a191 1
kq_dispatch(struct event_base *base, void *arg, struct timeval *tv)
d207 1
a207 1
                        event_warn("kevent");
d214 1
a214 1
	event_debug(("%s: kevent reports %d", __func__, res));
@


1.1.1.3
log
@latest fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.16 2005/05/04 03:17:48 brad Exp $	*/
a227 1
			errno = events[i].data;
@


1.1.1.4
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.18 2005/07/02 07:15:13 grunk Exp $	*/
a124 21
	/* Check for Mac OS X kqueue bug. */
	kqueueop->changes[0].ident = -1;
	kqueueop->changes[0].filter = EVFILT_READ;
	kqueueop->changes[0].flags = EV_ADD;
	/*
	 * If kqueue works, then kevent will succeed, and it will
	 * stick an error in events[0].  If kqueue is broken, then
	 * kevent will fail.
	 */
	if (kevent(kq,
		kqueueop->changes, 1, kqueueop->events, NEVENT, NULL) != 1 ||
	    kqueueop->events[0].ident != -1 ||
	    kqueueop->events[0].flags != EV_ERROR) {
		event_warn("%s: detected broken kqueue; not using.", __func__);
		free(kqueueop->changes);
		free(kqueueop->events);
		free(kqueueop);
		close(kq);
		return (NULL);
	}

d172 1
a172 1
		 __func__, kev->ident,
d215 1
a215 1
			/*
a220 2
			 *   EINVAL for some reasons not understood; EINVAL
			 *   should not be returned ever; but FreeBSD does :-\
a225 1
			    events[i].data == EINVAL ||
@


1.1.1.5
log
@Import libevent 1.1b+fixes from OpenBSD-current, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.21 2006/11/05 17:07:07 brad Exp $	*/
a77 1
void kq_dealloc (void *);
d85 1
a85 2
	kq_dispatch,
	kq_dealloc
d269 2
a270 1
		if (!(ev->ev_events & EV_PERSIST))
d272 1
d359 1
a359 1
		kev.ident = nsignal;
a398 15

void
kq_dealloc(void *arg)
{
	struct kqop *kqop = arg;

	if (kqop->changes)
		free(kqop->changes);
	if (kqop->events)
		free(kqop->events);
	if (kqop->kq)
		close(kqop->kq);
	memset(kqop, 0, sizeof(struct kqop));
	free(kqop);
}
@


1.1.1.6
log
@import latest libevent via openbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.22 2007/03/19 15:12:49 millert Exp $	*/
d104 1
a104 1

d298 1
a298 1

d321 1
a321 1

d336 1
a336 1

d362 1
a362 1

d378 1
a378 1

d390 1
a390 1

@


1.1.1.7
log
@import latest stable 1.4 libevent, in the OpenBSD version (diff against portable version reviewed-okay)
@
text
@d1 1
a1 1
/*	$OpenBSD: kqueue.c,v 1.28 2012/02/08 09:01:00 nicm Exp $	*/
a32 2
#define _GNU_SOURCE 1

d37 1
a37 1
#include <sys/_libevent_time.h>
a46 1
#include <assert.h>
d51 2
a52 5
/* Some platforms apparently define the udata field of struct kevent as
 * intptr_t, whereas others define it as void*.  There doesn't seem to be an
 * easy way to tell them apart via autoconf, so we need to use OS macros. */
#if defined(HAVE_INTTYPES_H) && !defined(__OpenBSD__) && !defined(__FreeBSD__) && !defined(__darwin__) && !defined(__APPLE__)
#define PTR_TO_UDATA(x)	((intptr_t)(x))
d54 1
a54 1
#define PTR_TO_UDATA(x)	(x)
a57 1
#include "event-internal.h"
a58 1
#include "evsignal.h"
a67 1
	struct event_list evsigevents[NSIG];
a69 1
	pid_t pid;
d72 7
a78 6
static void *kq_init	(struct event_base *);
static int kq_add	(void *, struct event *);
static int kq_del	(void *, struct event *);
static int kq_dispatch	(struct event_base *, void *, struct timeval *);
static int kq_insert	(struct kqop *, struct kevent *);
static void kq_dealloc (struct event_base *, void *);
d85 1
d87 1
a87 2
	kq_dealloc,
	1 /* need reinit */
d90 2
a91 2
static void *
kq_init(struct event_base *base)
d93 1
a93 1
	int i, kq;
d97 1
a97 1
	if (evutil_getenv("EVENT_NOKQUEUE"))
d104 1
a104 1
	
a112 2
	kqueueop->pid = getpid();

d114 1
a114 1
	kqueueop->changes = calloc(NEVENT, sizeof(struct kevent));
d119 1
a119 1
	kqueueop->events = calloc(NEVENT, sizeof(struct kevent));
a126 5
	/* we need to keep track of multiple events per signal */
	for (i = 0; i < NSIG; ++i) {
		TAILQ_INIT(&kqueueop->evsigevents[i]);
	}

d131 1
a131 1
	/* 
d151 7
a157 1
static int
d195 3
a197 3
		__func__, (int)kev->ident, 
		kev->filter == EVFILT_READ ? "EVFILT_READ" : "EVFILT_WRITE",
		kev->flags == EV_DELETE ? " (del)" : ""));
d208 1
a208 1
static int
d215 1
a215 1
	struct timespec ts, *ts_p = NULL;
d218 1
a218 4
	if (tv != NULL) {
		TIMEVAL_TO_TIMESPEC(tv, &ts);
		ts_p = &ts;
	}
d221 1
a221 1
	    events, kqop->nevents, ts_p);
d238 21
a258 1
			switch (events[i].data) {
d260 1
a260 39
			/* Can occur on delete if we are not currently
			 * watching any events on this fd.  That can
			 * happen when the fd was closed and another
			 * file was opened with that fd. */
			case ENOENT:
			/* Can occur for reasons not fully understood
			 * on FreeBSD. */
			case EINVAL:
				continue;
			/* Can occur on a delete if the fd is closed.  Can
			 * occur on an add if the fd was one side of a pipe,
			 * and the other side was closed. */
			case EBADF:
				continue;
			/* These two can occur on an add if the fd was one side
			 * of a pipe, and the other side was closed. */
			case EPERM:
			case EPIPE:
				/* Report read events, if we're listening for
				 * them, so that the user can learn about any
				 * add errors.  (If the operation was a
				 * delete, then udata should be cleared.) */
				if (events[i].udata) {
					/* The operation was an add:
					 * report the error as a read. */
					which |= EV_READ;
					break;
				} else {
					/* The operation was a del:
					 * report nothing. */
					continue;
				}

			/* Other errors shouldn't occur. */
			default:
				errno = events[i].data;
				return (-1);
			}
		} else if (events[i].filter == EVFILT_READ) {
d271 2
a272 8
		if (events[i].filter == EVFILT_SIGNAL) {
			struct event_list *head =
			    (struct event_list *)events[i].udata;
			TAILQ_FOREACH(ev, head, ev_signal_next) {
				event_active(ev, which, events[i].data);
			}
		} else {
			ev = (struct event *)events[i].udata;
d274 2
a275 5
			if (!(ev->ev_events & EV_PERSIST))
				ev->ev_flags &= ~EVLIST_X_KQINKERNEL;

			event_active(ev, which, 1);
		}
d282 1
a282 1
static int
d291 13
a303 20
		assert(nsignal >= 0 && nsignal < NSIG);
		if (TAILQ_EMPTY(&kqop->evsigevents[nsignal])) {
			struct timespec timeout = { 0, 0 };
			
			memset(&kev, 0, sizeof(kev));
			kev.ident = nsignal;
			kev.filter = EVFILT_SIGNAL;
			kev.flags = EV_ADD;
			kev.udata = PTR_TO_UDATA(&kqop->evsigevents[nsignal]);
			
			/* Be ready for the signal if it is sent any
			 * time between now and the next call to
			 * kq_dispatch. */
			if (kevent(kqop->kq, &kev, 1, NULL, 0, &timeout) == -1)
				return (-1);

			if (_evsignal_set_handler(ev->ev_base, nsignal,
				kq_sighandler) == -1)
				return (-1);
		}
a304 2
		TAILQ_INSERT_TAIL(&kqop->evsigevents[nsignal], ev,
		    ev_signal_next);
d320 2
a321 2
		kev.udata = PTR_TO_UDATA(ev);
		
d335 2
a336 2
		kev.udata = PTR_TO_UDATA(ev);
		
d346 1
a346 1
static int
a356 1
		struct timespec timeout = { 0, 0 };
d358 10
a367 18
		assert(nsignal >= 0 && nsignal < NSIG);
		TAILQ_REMOVE(&kqop->evsigevents[nsignal], ev, ev_signal_next);
		if (TAILQ_EMPTY(&kqop->evsigevents[nsignal])) {
			memset(&kev, 0, sizeof(kev));
			kev.ident = nsignal;
			kev.filter = EVFILT_SIGNAL;
			kev.flags = EV_DELETE;
		
			/* Because we insert signal events
			 * immediately, we need to delete them
			 * immediately, too */
			if (kevent(kqop->kq, &kev, 1, NULL, 0, &timeout) == -1)
				return (-1);

			if (_evsignal_restore_handler(ev->ev_base,
				nsignal) == -1)
				return (-1);
		}
d378 1
a378 1
		
d390 1
a390 1
		
d400 2
a401 2
static void
kq_dealloc(struct event_base *base, void *arg)
a404 2
	evsignal_dealloc(base);

d409 1
a409 1
	if (kqop->kq >= 0 && kqop->pid == getpid())
a410 1

@


