head	1.17;
access;
symbols
	MIRBSD_10:1.9.0.2
	MIRBSD_10_BASE:1.9
	MIRBSD_9_BASE:1.4
	MIRBSD_8:1.3.0.2
	MIRBSD_8_BASE:1.3
	cvs-200509212000:1.1.1.3
	cvs-200507211800:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2019.01.05.16.26.19;	author tg;	state Exp;
branches;
next	1.16;
commitid	1005C30DAC0602FB328;

1.16
date	2019.01.05.16.22.52;	author tg;	state Exp;
branches;
next	1.15;
commitid	1005C30D9E545760466;

1.15
date	2010.10.08.17.57.00;	author tg;	state Exp;
branches;
next	1.14;
commitid	1004CAF5B5A6D74E1C9;

1.14
date	2010.09.14.21.26.04;	author tg;	state Exp;
branches;
next	1.13;
commitid	1004C8FE654576B0E25;

1.13
date	2010.09.14.20.25.10;	author tg;	state Exp;
branches;
next	1.12;
commitid	1004C8FDA3E04899130;

1.12
date	2009.06.10.18.12.42;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004A2FF7913BD44883;

1.11
date	2009.04.07.18.41.43;	author tg;	state Exp;
branches;
next	1.10;
commitid	10049DB9E493037411A;

1.10
date	2008.04.19.16.27.23;	author tg;	state Exp;
branches;
next	1.9;
commitid	100480A1D1B7780C422;

1.9
date	2007.10.25.15.13.39;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004720B2A43C982AA6;

1.8
date	2007.03.04.03.47.14;	author tg;	state Exp;
branches;
next	1.7;
commitid	10045EA414E6729B66F;

1.7
date	2007.03.04.03.46.41;	author tg;	state Exp;
branches;
next	1.6;
commitid	10045EA41377C592444;

1.6
date	2006.11.08.23.18.04;	author tg;	state Exp;
branches;
next	1.5;
commitid	100455265BA276A4271;

1.5
date	2006.07.03.12.13.52;	author tg;	state Exp;
branches;
next	1.4;
commitid	10044A909E705B2FD8A;

1.4
date	2006.01.29.20.59.09;	author tg;	state Exp;
branches;
next	1.3;
commitid	10043DD2CA86C72A634;

1.3
date	2005.09.22.20.40.00;	author tg;	state Exp;
branches;
next	1.2;
commitid	2258433316aba805;

1.2
date	2005.03.06.20.28.41;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.24.45;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.24.45;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.07.21.20.52.34;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	560042e0092f571e;

1.1.1.3
date	2005.09.21.20.34.20;	author tg;	state Exp;
branches;
next	;
commitid	20cd4331c3c732a2;


desc
@@


1.17
log
@meh, keep SCCSID and just define it in d/rules
@
text
@/*	$OpenBSD: setmode.c,v 1.17 2005/08/08 08:05:34 espie Exp $	*/
/*	$NetBSD: setmode.c,v 1.15 1997/02/07 22:21:06 christos Exp $	*/

/*
 * Copyright (c) 1989, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Dave Borman at Cray Research, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>

#include <ctype.h>
#include <errno.h>
#include <signal.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

#ifdef SETMODE_DEBUG
#include <stdio.h>
#endif

__SCCSID("@@(#)setmode.c	8.2 (Berkeley) 3/25/94");
__RCSID("$MirOS: src/lib/libc/gen/setmode.c,v 1.15 2010/10/08 17:57:00 tg Exp $");

#ifdef GNUPORT
mode_t getmode(const void *, mode_t);
void *setmode(const char *);
#endif

#define	SET_LEN		6	/* initial # of bitcmd struct to malloc */
#define	SET_LEN_INCR	4	/* # of bitcmd structs to add as needed */

typedef struct bitcmd {
	mode_t	bits;
	char	cmd;
	char	cmd2;
} BITCMD;

#define	CMD2_CLR	0x01
#define	CMD2_SET	0x02
#define	CMD2_GBITS	0x04
#define	CMD2_OBITS	0x08
#define	CMD2_UBITS	0x10

static BITCMD	*addcmd(BITCMD *, int, int, int, u_int);
static void	 compress_mode(BITCMD *);
#ifdef SETMODE_DEBUG
static void	 dumpmode(BITCMD *);
#endif

/*
 * Given the old mode and an array of bitcmd structures, apply the operations
 * described in the bitcmd structures to the old mode, and return the new mode.
 * Note that there is no '=' command; a strict assignment is just a '-' (clear
 * bits) followed by a '+' (set bits).
 */
mode_t
getmode(const void *bbox, mode_t omode)
{
	const BITCMD *set;
	mode_t clrval, newmode, value;

	set = (const BITCMD *)bbox;
	newmode = omode;
	for (value = 0;; set++)
		switch(set->cmd) {
		/*
		 * When copying the user, group or other bits around, we "know"
		 * where the bits are in the mode so that we can do shifts to
		 * copy them around.  If we don't use shifts, it gets real
		 * grundgy with lots of single bit checks and bit sets.
		 */
		case 'u':
			value = (newmode & S_IRWXU) >> 6;
			goto common;

		case 'g':
			value = (newmode & S_IRWXG) >> 3;
			goto common;

		case 'o':
			value = newmode & S_IRWXO;
 common:
			if (set->cmd2 & CMD2_CLR) {
				clrval =
				    (set->cmd2 & CMD2_SET) ?  S_IRWXO : value;
				if (set->cmd2 & CMD2_UBITS)
					newmode &= ~((clrval<<6) & set->bits);
				if (set->cmd2 & CMD2_GBITS)
					newmode &= ~((clrval<<3) & set->bits);
				if (set->cmd2 & CMD2_OBITS)
					newmode &= ~(clrval & set->bits);
			}
			if (set->cmd2 & CMD2_SET) {
				if (set->cmd2 & CMD2_UBITS)
					newmode |= (value<<6) & set->bits;
				if (set->cmd2 & CMD2_GBITS)
					newmode |= (value<<3) & set->bits;
				if (set->cmd2 & CMD2_OBITS)
					newmode |= value & set->bits;
			}
			break;

		case '+':
			newmode |= set->bits;
			break;

		case '-':
			newmode &= ~set->bits;
			break;

		case 'X':
			if (omode & (S_IFDIR|S_IXUSR|S_IXGRP|S_IXOTH))
				newmode |= set->bits;
			break;

		case '\0':
		default:
#ifdef SETMODE_DEBUG
			(void)printf("getmode:%04o -> %04o\n", omode, newmode);
#endif
			return (newmode);
		}
}

#define notoktomul(a, b)	((a) && (b) && (SIZE_MAX / (a) < (b)))

#define	ADDCMD(a, b, c, d)						\
	if (set >= endset) {						\
		BITCMD *newset;						\
		setlen += SET_LEN_INCR;					\
		if (notoktomul(setlen, sizeof(BITCMD)) ||		\
		    (newset = realloc(saveset, setlen *			\
		    sizeof(BITCMD))) == NULL) {				\
			free(saveset);					\
			return (NULL);					\
		}							\
		set = newset + (set - saveset);				\
		saveset = newset;					\
		endset = newset + (setlen - 2);				\
	}								\
	set = addcmd(set, (a), (b), (c), (d))

#define	STANDARD_BITS	(S_ISUID|S_ISGID|S_IRWXU|S_IRWXG|S_IRWXO)

void *
setmode(const char *p)
{
	int perm, who;
	char op, *ep;
	BITCMD *set, *saveset, *endset;
	sigset_t signset, sigoset;
	mode_t mask;
	int equalopdone = 0, permXbits, setlen;
	u_long perml;

	if (!*p)
		return (NULL);

	/*
	 * Get a copy of the mask for the permissions that are mask relative.
	 * Flip the bits, we want what's not set.  Since it's possible that
	 * the caller is opening files inside a signal handler, protect them
	 * as best we can.
	 */
	sigfillset(&signset);
	(void)sigprocmask(SIG_BLOCK, &signset, &sigoset);
	(void)umask(mask = umask(0));
	mask = ~mask;
	(void)sigprocmask(SIG_SETMASK, &sigoset, NULL);

	setlen = SET_LEN + 2;
	
	if (notoktomul(setlen, sizeof(BITCMD)) ||
	    (set = malloc(setlen * sizeof(BITCMD))) == NULL)
		return (NULL);
	saveset = set;
	endset = set + (setlen - 2);

	/*
	 * If an absolute number, get it and return; disallow non-octal digits
	 * or illegal bits.
	 */
	if (isdigit((unsigned char)*p)) {
		perml = strtoul(p, &ep, 8);
		/* The test on perml will also catch overflow. */
		if (*ep != '\0' || (perml & ~(STANDARD_BITS|S_ISTXT))) {
			free(saveset);
			errno = ERANGE;
			return (NULL);
		}
		perm = (mode_t)perml;
		ADDCMD('=', (STANDARD_BITS|S_ISTXT), perm, mask);
		set->cmd = 0;
		return (saveset);
	}

	/*
	 * Build list of structures to set/clear/copy bits as described by
	 * each clause of the symbolic mode.
	 */
	for (;;) {
		/* First, find out which bits might be modified. */
		for (who = 0;; ++p) {
			switch (*p) {
			case 'a':
				who |= STANDARD_BITS;
				break;
			case 'u':
				who |= S_ISUID|S_IRWXU;
				break;
			case 'g':
				who |= S_ISGID|S_IRWXG;
				break;
			case 'o':
				who |= S_IRWXO;
				break;
			default:
				goto getop;
			}
		}

 getop:
		if ((op = *p++) != '+' && op != '-' && op != '=') {
			free(saveset);
			return (NULL);
		}
		if (op == '=')
			equalopdone = 0;

		who &= ~S_ISTXT;
		for (perm = 0, permXbits = 0;; ++p) {
			switch (*p) {
			case 'r':
				perm |= S_IRUSR|S_IRGRP|S_IROTH;
				break;
			case 's':
				/*
				 * If specific bits where requested and
				 * only "other" bits ignore set-id.
				 */
				if (who == 0 || (who & ~S_IRWXO))
					perm |= S_ISUID|S_ISGID;
				break;
			case 't':
				/*
				 * If specific bits where requested and
				 * only "other" bits ignore sticky.
				 */
				if (who == 0 || (who & ~S_IRWXO)) {
					who |= S_ISTXT;
					perm |= S_ISTXT;
				}
				break;
			case 'w':
				perm |= S_IWUSR|S_IWGRP|S_IWOTH;
				break;
			case 'X':
				permXbits = S_IXUSR|S_IXGRP|S_IXOTH;
				break;
			case 'x':
				perm |= S_IXUSR|S_IXGRP|S_IXOTH;
				break;
			case 'u':
			case 'g':
			case 'o':
				/*
				 * When ever we hit 'u', 'g', or 'o', we have
				 * to flush out any partial mode that we have,
				 * and then do the copying of the mode bits.
				 */
				if (perm) {
					ADDCMD(op, who, perm, mask);
					perm = 0;
				}
				if (op == '=')
					equalopdone = 1;
				if (op == '+' && permXbits) {
					ADDCMD('X', who, permXbits, mask);
					permXbits = 0;
				}
				ADDCMD(*p, who, op, mask);
				break;

			default:
				/*
				 * Add any permissions that we haven't already
				 * done.
				 */
				if (perm || (op == '=' && !equalopdone)) {
					if (op == '=')
						equalopdone = 1;
					ADDCMD(op, who, perm, mask);
					perm = 0;
				}
				if (permXbits) {
					ADDCMD('X', who, permXbits, mask);
					permXbits = 0;
				}
				goto apply;
			}
		}

 apply:
		if (!*p)
			break;
		if (*p != ',')
			goto getop;
		++p;
	}
	set->cmd = 0;
#ifdef SETMODE_DEBUG
	(void)printf("Before compress_mode()\n");
	dumpmode(saveset);
#endif
	compress_mode(saveset);
#ifdef SETMODE_DEBUG
	(void)printf("After compress_mode()\n");
	dumpmode(saveset);
#endif
	return (saveset);
}

static BITCMD *
addcmd(BITCMD *set, int op, int who, int oparg, u_int mask)
{
	switch (op) {
	case '=':
		set->cmd = '-';
		set->bits = who ? who : STANDARD_BITS;
		set++;

		op = '+';
		/* FALLTHROUGH */
	case '+':
	case '-':
	case 'X':
		set->cmd = op;
		set->bits = (who ? who : (int)mask) & oparg;
		break;

	case 'u':
	case 'g':
	case 'o':
		set->cmd = op;
		if (who) {
			set->cmd2 = ((who & S_IRUSR) ? CMD2_UBITS : 0) |
				    ((who & S_IRGRP) ? CMD2_GBITS : 0) |
				    ((who & S_IROTH) ? CMD2_OBITS : 0);
			set->bits = (mode_t)~0;
		} else {
			set->cmd2 = CMD2_UBITS | CMD2_GBITS | CMD2_OBITS;
			set->bits = mask;
		}
	
		if (oparg == '+')
			set->cmd2 |= CMD2_SET;
		else if (oparg == '-')
			set->cmd2 |= CMD2_CLR;
		else if (oparg == '=')
			set->cmd2 |= CMD2_SET|CMD2_CLR;
		break;
	}
	return (set + 1);
}

#ifdef SETMODE_DEBUG
static void
dumpmode(BITCMD *set)
{
	for (; set->cmd; ++set)
		(void)printf("cmd: '%c' bits %04o%s%s%s%s%s%s\n",
		    set->cmd, set->bits, set->cmd2 ? " cmd2:" : "",
		    set->cmd2 & CMD2_CLR ? " CLR" : "",
		    set->cmd2 & CMD2_SET ? " SET" : "",
		    set->cmd2 & CMD2_UBITS ? " UBITS" : "",
		    set->cmd2 & CMD2_GBITS ? " GBITS" : "",
		    set->cmd2 & CMD2_OBITS ? " OBITS" : "");
}
#endif

/*
 * Given an array of bitcmd structures, compress by compacting consecutive
 * '+', '-' and 'X' commands into at most 3 commands, one of each.  The 'u',
 * 'g' and 'o' commands continue to be separate.  They could probably be
 * compacted, but it's not worth the effort.
 */
static void
compress_mode(BITCMD *set)
{
	BITCMD *nset;
	int setbits, clrbits, Xbits, op;

	for (nset = set;;) {
		/* Copy over any 'u', 'g' and 'o' commands. */
		while ((op = nset->cmd) != '+' && op != '-' && op != 'X') {
			*set++ = *nset++;
			if (!op)
				return;
		}

		for (setbits = clrbits = Xbits = 0;; nset++) {
			if ((op = nset->cmd) == '-') {
				clrbits |= nset->bits;
				setbits &= ~nset->bits;
				Xbits &= ~nset->bits;
			} else if (op == '+') {
				setbits |= nset->bits;
				clrbits &= ~nset->bits;
				Xbits &= ~nset->bits;
			} else if (op == 'X')
				Xbits |= nset->bits & ~setbits;
			else
				break;
		}
		if (clrbits) {
			set->cmd = '-';
			set->cmd2 = 0;
			set->bits = clrbits;
			set++;
		}
		if (setbits) {
			set->cmd = '+';
			set->cmd2 = 0;
			set->bits = setbits;
			set++;
		}
		if (Xbits) {
			set->cmd = 'X';
			set->cmd2 = 0;
			set->bits = Xbits;
			set++;
		}
	}
}
@


1.16
log
@more missing prototypes and __SCCSID
@
text
@d50 3
a55 2
#undef __SCCSID
#define __SCCSID(x) /* nothing */
a57 3
__SCCSID("@@(#)setmode.c	8.2 (Berkeley) 3/25/94");
__RCSID("$MirOS: src/lib/libc/gen/setmode.c,v 1.15 2010/10/08 17:57:00 tg Exp $");

@


1.15
log
@mknod’s now demoted and only used as special-case builtin, in MirBSD only
built for the installer, to save time, as the original OpenBSD hack wanted
@
text
@d50 7
d58 1
a58 1
__RCSID("$MirOS: src/lib/libc/gen/setmode.c,v 1.14 2010/09/14 21:26:04 tg Exp $");
@


1.14
log
@• Address concerns of Chris Palmer from the Android security team
  – possible integer overflows in memory allocation, mostly
    ‣ multiplication: all are checked now
    ‣ addition: reviewed them, most were “proven” or guessed to be
      “almost” impossible to run over (e.g. when we have a string
      whose length is taken it is assumed that the length will be
      more than only a few bytes below SIZE_MAX, since code and
      stack have to fit); some are checked now (e.g. when one of
      the summands is an off_t); most of the unchecked ones are
      annotated now
    ⇒ cost (MirBSD/i386 static): +76 .text
    ⇒ cost (Debian sid/i386): +779 .text  -4 .data
  – on Linux targets, setuid() setresuid() setresgid() can fail
    with EAGAIN; check for that and, if so, warn once and retry
    infinitely (other targets to be added later once we know that
    they are “insane”)
    ⇒ cost (Debian sid/i386): +192 .text (includes .rodata)
• setmode.c: Do overflow checking for realloc() too; switch back
  from calloc() to a checked malloc() for simplification while there
• define -DIN_MKSH and let setmode.c look a tad nicer while here
@
text
@a35 5
#ifdef IN_MKSH
#include "sh.h"
#undef SETMODE_DEBUG
#else

d42 1
a49 2
#endif

d51 1
a51 25
__RCSID("$MirOS: src/lib/libc/gen/setmode.c,v 1.12 2009/06/10 18:12:42 tg Exp $");

#ifdef IN_MKSH

#ifdef ksh_isdigit
#undef isdigit
#define isdigit		ksh_isdigit
#endif

#else

#ifndef S_ISTXT
#define S_ISTXT		0001000
#endif

#ifndef SIZE_MAX
#ifdef SIZE_T_MAX
#define SIZE_MAX	SIZE_T_MAX
#else
#define SIZE_MAX	((size_t)-1)
#endif
#endif

#endif

d68 1
a68 1
static BITCMD	*addcmd(BITCMD *, int, int, int, unsigned int);
d93 1
a93 1
		 * copy them around. If we don't use shifts, it gets real
d109 1
a109 1
				    (set->cmd2 & CMD2_SET) ? S_IRWXO : value;
d178 1
a178 1
	unsigned long perml;
d185 1
a185 1
	 * Flip the bits, we want what's not set. Since it's possible that
d196 1
a196 1

d348 1
a348 1
addcmd(BITCMD *set, int op, int who, int oparg, unsigned int mask)
d378 1
a378 1

d407 2
a408 2
 * '+', '-' and 'X' commands into at most 3 commands, one of each. The 'u',
 * 'g' and 'o' commands continue to be separate. They could probably be
@


1.13
log
@nicer
@
text
@d36 3
a38 4
#if defined(HAVE_CONFIG_H) && HAVE_CONFIG_H
/* usually when packaged with third-party software */
#ifdef CONFIG_H_FILENAME
#include CONFIG_H_FILENAME
a39 3
#include "config.h"
#endif
#endif
d54 2
d59 2
a60 1
/* for mksh */
d66 2
d72 11
d179 2
d185 3
a187 2
		newset = realloc(saveset, sizeof(BITCMD) * setlen);	\
		if (newset == NULL) {					\
d227 2
a228 1
	if ((set = calloc(sizeof(BITCMD), setlen)) == NULL)
@


1.12
log
@more KNF, mostly whitespace, this time more manual labour applying style(9)
@
text
@d36 1
a36 1
#if defined(HAVE_CONFIG_H) && (HAVE_CONFIG_H != 0)
d59 1
a59 1
__RCSID("$MirOS: src/lib/libc/gen/setmode.c,v 1.11 2009/04/07 18:41:43 tg Exp $");
@


1.11
log
@try to do some optimum struct packing
(pointers, longs, size_t first; time_t next; int etc. then enum, bool)
@
text
@a0 1
/**	$MirOS: src/lib/libc/gen/setmode.c,v 1.10 2008/04/19 16:27:23 tg Exp $ */
d59 1
a59 1
__RCSID("$MirOS: src/lib/libc/gen/setmode.c,v 1.10 2008/04/19 16:27:23 tg Exp $");
d64 1
a64 1
#define isdigit 	ksh_isdigit
d111 1
a111 1
		 * copy them around.  If we don't use shifts, it gets real
d127 1
a127 1
				    (set->cmd2 & CMD2_SET) ?  S_IRWXO : value;
d200 1
a200 1
	 * Flip the bits, we want what's not set.  Since it's possible that
d421 2
a422 2
 * '+', '-' and 'X' commands into at most 3 commands, one of each.  The 'u',
 * 'g' and 'o' commands continue to be separate.  They could probably be
@


1.10
log
@• unsigned → unsigned int (like in oksh)
• integrate mksh portability definitions
@
text
@d1 1
a1 1
/**	$MirOS: src/lib/libc/gen/setmode.c,v 1.9 2007/10/25 15:13:39 tg Exp $ */
d60 1
a60 1
__RCSID("$MirOS: src/lib/libc/gen/setmode.c,v 1.9 2007/10/25 15:13:39 tg Exp $");
d76 1
a78 1
	mode_t	bits;
@


1.9
log
@• get rid of u_int, u_long
• use calloc(x, y) ipv malloc(x*y)
@
text
@d1 1
a1 1
/**	$MirOS: src/lib/libc/gen/setmode.c,v 1.8 2007/03/04 03:47:14 tg Exp $ */
d60 1
a60 1
__RCSID("$MirOS: src/lib/libc/gen/setmode.c,v 1.8 2007/03/04 03:47:14 tg Exp $");
d65 1
a65 1
#define isdigit ksh_isdigit
d68 6
a73 2
#define	SET_LEN	6		/* initial # of bitcmd struct to malloc */
#define	SET_LEN_INCR 4		/* # of bitcmd structs to add as needed */
d87 1
a87 1
static BITCMD	*addcmd(BITCMD *, int, int, int, unsigned);
d363 1
a363 1
addcmd(BITCMD *set, int op, int who, int oparg, unsigned mask)
@


1.8
log
@apparently, sigset is a global on Debian, unshadow
@
text
@d1 1
a1 1
/**	$MirOS: src/lib/libc/gen/setmode.c,v 1.7 2007/03/04 03:46:41 tg Exp $ */
d60 1
a60 1
__RCSID("$MirOS: src/lib/libc/gen/setmode.c,v 1.7 2007/03/04 03:46:41 tg Exp $");
d83 1
a83 1
static BITCMD	*addcmd(BITCMD *, int, int, int, u_int);
d190 1
a190 1
	u_long perml;
d209 1
a209 1
	if ((set = malloc((u_int)(sizeof(BITCMD) * setlen))) == NULL)
d359 1
a359 1
addcmd(BITCMD *set, int op, int who, int oparg, u_int mask)
@


1.7
log
@reduce diff to mksh
@
text
@d1 1
a1 1
/**	$MirOS: src/lib/libc/gen/setmode.c,v 1.6 2006/11/08 23:18:04 tg Exp $ */
d60 1
a60 1
__RCSID("$MirOS: src/lib/libc/gen/setmode.c,v 1.6 2006/11/08 23:18:04 tg Exp $");
d187 1
a187 1
	sigset_t sigset, sigoset;
d201 2
a202 2
	sigfillset(&sigset);
	(void)sigprocmask(SIG_BLOCK, &sigset, &sigoset);
@


1.6
log
@the "- 0" syntax doesn't work with crazy warnings
@
text
@d1 1
a1 1
/**	$MirOS: src/lib/libc/gen/setmode.c,v 1.5 2006/07/03 12:13:52 tg Exp $ */
d60 7
a66 1
__RCSID("$MirOS: src/lib/libc/gen/setmode.c,v 1.5 2006/07/03 12:13:52 tg Exp $");
@


1.5
log
@on Solaris 8 (and some other "standards-compliant" systems), isTYPE(c)
from <ctype.h> takes an unsigned char, and gcc complains when given a
char, because that's not necessarily signed or unsigned.
@
text
@d1 1
a1 1
/**	$MirOS: src/lib/libc/gen/setmode.c,v 1.4 2006/01/29 20:59:09 tg Exp $ */
d37 9
d60 1
a60 1
__RCSID("$MirOS: src/lib/libc/gen/setmode.c,v 1.4 2006/01/29 20:59:09 tg Exp $");
d115 2
a116 1
common:			if (set->cmd2 & CMD2_CLR) {
d251 2
a252 1
getop:		if ((op = *p++) != '+' && op != '-' && op != '=') {
d332 2
a333 1
apply:		if (!*p)
@


1.4
log
@gcc version 4.0.3 20051201 (prerelease) (Debian 4.0.2-5)
complains about signed vs unsigned
@
text
@d1 1
a1 1
/**	$MirOS: src/lib/libc/gen/setmode.c,v 1.3 2005/09/22 20:40:00 tg Exp $ */
d51 1
a51 1
__RCSID("$MirOS: src/lib/libc/gen/setmode.c,v 1.3 2005/09/22 20:40:00 tg Exp $");
d202 1
a202 1
	if (isdigit(*p)) {
@


1.3
log
@merge
@
text
@d1 1
a1 1
/**	$MirOS: src/lib/libc/gen/setmode.c,v 1.2 2005/03/06 20:28:41 tg Exp $ */
d51 1
a51 1
__RCSID("$MirOS: src/lib/libc/gen/setmode.c,v 1.2 2005/03/06 20:28:41 tg Exp $");
d355 1
a355 1
		set->bits = (who ? who : mask) & oparg;
@


1.2
log
@merge src/lib
@
text
@d1 2
a2 2
/**	$MirOS$ */
/*	$OpenBSD: setmode.c,v 1.15 2004/07/02 13:58:06 otto Exp $	*/
d51 1
a51 1
__RCSID("$MirOS$");
d206 1
a207 1
			free(saveset);
@


1.1
log
@Initial revision
@
text
@d1 1
a36 8
#if defined(LIBC_SCCS) && !defined(lint)
#if 0
static char sccsid[] = "@@(#)setmode.c	8.2 (Berkeley) 3/25/94";
#else
static char rcsid[] = "$OpenBSD: setmode.c,v 1.15 2004/07/02 13:58:06 otto Exp $";
#endif
#endif /* LIBC_SCCS and not lint */

d50 3
d173 1
a173 1
	int equalopdone, permXbits, setlen;
d192 1
a192 1
	
d371 1
a371 1
	
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d1 1
a1 1
/*	$OpenBSD: setmode.c,v 1.16 2005/03/01 13:51:47 miod Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: setmode.c,v 1.16 2005/03/01 13:51:47 miod Exp $";
d210 1
a211 1
			errno = ERANGE;
@


1.1.1.3
log
@Import OpenBSD's libc as of today, minus some of the locale stuff,
and with brk malloc instead of mmap malloc
@
text
@d1 1
a1 1
/*	$OpenBSD: setmode.c,v 1.17 2005/08/08 08:05:34 espie Exp $	*/
d36 8
@


