head	1.5;
access;
symbols
	MIRBSD_10:1.4.0.4
	MIRBSD_10_BASE:1.4
	MIRBSD_9_BASE:1.4
	MIRBSD_8:1.4.0.2
	MIRBSD_8_BASE:1.4
	cvs-200509212000:1.1.1.3
	cvs-200507211800:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2009.11.09.21.30.50;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004AF88A0F18F30769;

1.4
date	2005.09.22.20.40.02;	author tg;	state Exp;
branches;
next	1.3;
commitid	2258433316aba805;

1.3
date	2005.07.09.13.23.31;	author tg;	state Exp;
branches;
next	1.2;
commitid	156f42cfcfe741cc;

1.2
date	2005.03.06.20.28.42;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.24.49;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.24.49;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.07.09.13.04.58;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	500642cfcb8db32b;

1.1.1.3
date	2005.09.21.20.34.22;	author tg;	state Exp;
branches;
next	;
commitid	20cd4331c3c732a2;


desc
@@


1.5
log
@fix __CRAZY=Yes build (or work around bugs we canâ€™t fix atm)
@
text
@/*	$OpenBSD: getnetnamadr.c,v 1.26 2005/08/06 20:30:03 espie Exp $	*/

/*
 * Copyright (c) 1997, Jason Downs.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/* Copyright (c) 1993 Carlos Leandro and Rui Salgueiro
 *	Dep. Matematica Universidade de Coimbra, Portugal, Europe
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 */
/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <arpa/nameser.h>

#include <stdio.h>
#include <netdb.h>
#include <resolv.h>
#include <ctype.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>

#include "thread_private.h"

__RCSID("$MirOS: src/lib/libc/net/getnetnamadr.c,v 1.4 2005/09/22 20:40:02 tg Exp $");

struct netent *_getnetbyaddr(in_addr_t net, int type);
struct netent *_getnetbyname(const char *name);

int _hokchar(const char *);

#define BYADDR 0
#define BYNAME 1
#define	MAXALIASES	35

#define	MAXPACKET	(64*1024)

typedef union {
	HEADER	hdr;
	u_char	buf[MAXPACKET];
} querybuf;

typedef union {
	long	al;
	char	ac;
} align;

static struct netent *
getnetanswer(querybuf *answer, int anslen, int net_i)
{

	HEADER *hp;
	u_char *cp;
	int n;
	u_char *eom;
	int type, class, ancount, qdcount, haveanswer, i, nchar;
	char aux1[MAXHOSTNAMELEN], aux2[MAXHOSTNAMELEN], ans[MAXHOSTNAMELEN];
	char *in, *st, *pauxt, *bp, **ap, *ep;
	char *paux1 = &aux1[0], *paux2 = &aux2[0];
	static	struct netent net_entry;
	static	char *net_aliases[MAXALIASES], netbuf[BUFSIZ+1];

	/*
	 * find first satisfactory answer
	 *
	 *      answer --> +------------+  ( MESSAGE )
	 *		   |   Header   |
	 *		   +------------+
	 *		   |  Question  | the question for the name server
	 *		   +------------+
	 *		   |   Answer   | RRs answering the question
	 *		   +------------+
	 *		   | Authority  | RRs pointing toward an authority
	 *		   | Additional | RRs holding additional information
	 *		   +------------+
	 */
	eom = answer->buf + anslen;
	hp = &answer->hdr;
	ancount = ntohs(hp->ancount); /* #/records in the answer section */
	qdcount = ntohs(hp->qdcount); /* #/entries in the question section */
	bp = netbuf;
	ep = netbuf + sizeof(netbuf);
	cp = answer->buf + HFIXEDSZ;
	if (!qdcount) {
		if (hp->aa)
			h_errno = HOST_NOT_FOUND;
		else
			h_errno = TRY_AGAIN;
		return (NULL);
	}
	while (qdcount-- > 0) {
		n = __dn_skipname(cp, eom);
		if (n < 0 || (cp + n + QFIXEDSZ) > eom) {
			h_errno = NO_RECOVERY;
			return(NULL);
		}
		cp += n + QFIXEDSZ;
	}
	ap = net_aliases;
	*ap = NULL;
	net_entry.n_aliases = net_aliases;
	haveanswer = 0;
	while (--ancount >= 0 && cp < eom) {
		n = dn_expand(answer->buf, eom, cp, bp, ep - bp);
#ifdef USE_RESOLV_NAME_OK
		if ((n < 0) || !res_dnok(bp))
#else
		if ((n < 0) || !_hokchar(bp))
#endif
			break;
		cp += n;
		ans[0] = '\0';
		strlcpy(&ans[0], bp, sizeof ans);
		GETSHORT(type, cp);
		GETSHORT(class, cp);
		cp += INT32SZ;		/* TTL */
		GETSHORT(n, cp);
		if (class == C_IN && type == T_PTR) {
			n = dn_expand(answer->buf, eom, cp, bp, ep - bp);
#ifdef USE_RESOLV_NAME_OK
			if ((n < 0) || !res_hnok(bp))
#else
			if ((n < 0) || !_hokchar(bp))
#endif
			{
				cp += n;
				return (NULL);
			}
			cp += n;
			if ((ap + 2) < &net_aliases[MAXALIASES]) {
				*ap++ = bp;
				bp += strlen(bp) + 1;
				net_entry.n_addrtype =
					(class == C_IN) ? AF_INET : AF_UNSPEC;
				haveanswer++;
			}
		}
	}
	if (haveanswer) {
		*ap = NULL;
		switch (net_i) {
		case BYADDR:
			net_entry.n_name = *net_entry.n_aliases;
			net_entry.n_net = 0L;
			break;
		case BYNAME:
			ap = net_entry.n_aliases;
		next_alias:
			in = *ap++;
			if (in == NULL) {
				h_errno = HOST_NOT_FOUND;
				return (NULL);
			}
			net_entry.n_name = ans;
			aux2[0] = '\0';
			for (i = 0; i < 4; i++) {
				for (st = in, nchar = 0;
				     isdigit((unsigned char)*st);
				     st++, nchar++)
					;
				if (*st != '.' || nchar == 0 || nchar > 3)
					goto next_alias;
				if (i != 0)
					nchar++;
				strlcpy(paux1, in, nchar+1);
				strlcat(paux1, paux2, MAXHOSTNAMELEN);
				pauxt = paux2;
				paux2 = paux1;
				paux1 = pauxt;
				in = ++st;
			}
			if (strcasecmp(in, "IN-ADDR.ARPA") != 0)
				goto next_alias;
			net_entry.n_net = inet_network(paux2);
			break;
		}
		net_entry.n_aliases++;
		return (&net_entry);
	}
	h_errno = TRY_AGAIN;
	return (NULL);
}

struct netent *
getnetbyaddr(in_addr_t net, int net_type)
{
	struct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);
	unsigned int netbr[4];
	int nn, anslen;
	querybuf *buf;
	char qbuf[MAXDNAME];
	in_addr_t net2;
	struct netent *net_entry = NULL;
	char lookups[MAXDNSLUS];
	int i;

	if (_res_init(0) == -1)
		return(_getnetbyaddr(net, net_type));

	memmove(lookups, _resp->lookups, sizeof lookups);
	if (lookups[0] == '\0')
		strlcpy(lookups, "bf", sizeof lookups);

	for (i = 0; i < MAXDNSLUS && lookups[i]; i++) {
		switch (lookups[i]) {
		case 'b':
			if (net_type != AF_INET)
				break;	/* DNS only supports AF_INET? */

			for (nn = 4, net2 = net; net2; net2 >>= 8)
				netbr[--nn] = net2 & 0xff;
			switch (nn) {
			case 3: 	/* Class A */
				snprintf(qbuf, sizeof(qbuf),
				    "0.0.0.%u.in-addr.arpa", netbr[3]);
				break;
			case 2: 	/* Class B */
				snprintf(qbuf, sizeof(qbuf),
				    "0.0.%u.%u.in-addr.arpa",
		    		    netbr[3], netbr[2]);
				break;
			case 1: 	/* Class C */
				snprintf(qbuf, sizeof(qbuf),
				    "0.%u.%u.%u.in-addr.arpa",
		    		    netbr[3], netbr[2], netbr[1]);
				break;
			case 0: 	/* Class D - E */
				snprintf(qbuf, sizeof(qbuf),
				    "%u.%u.%u.%u.in-addr.arpa",
				    netbr[3], netbr[2], netbr[1], netbr[0]);
				break;
			}
			buf = malloc(sizeof(*buf));
			if (buf == NULL)
				break;
			anslen = res_query(qbuf, C_IN, T_PTR, buf->buf,
			    sizeof(buf->buf));
			if (anslen < 0) {
				free(buf);
#ifdef DEBUG
				if (_resp->options & RES_DEBUG)
					printf("res_query failed\n");
#endif
				break;
			}
			net_entry = getnetanswer(buf, anslen, BYADDR);
			free(buf);
			if (net_entry != NULL) {
				unsigned u_net = net;	/* maybe net should be unsigned ? */

				/* Strip trailing zeros */
				while ((u_net & 0xff) == 0 && u_net != 0)
					u_net >>= 8;
				net_entry->n_net = u_net;
				return (net_entry);
			}
			break;
		case 'f':
			net_entry = _getnetbyaddr(net, net_type);
			if (net_entry != NULL)
				return (net_entry);
		}
	}

	/* Nothing matched. */
	return (NULL);
}

struct netent *
getnetbyname(const char *net)
{
	struct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);
	int anslen;
	querybuf *buf;
	char qbuf[MAXDNAME];
	struct netent *net_entry = NULL;
	char lookups[MAXDNSLUS];
	int i;

	if (_res_init(0) == -1)
		return (_getnetbyname(net));

	memmove(lookups, _resp->lookups, sizeof lookups);
	if (lookups[0] == '\0')
		strlcpy(lookups, "bf", sizeof lookups);

	for (i = 0; i < MAXDNSLUS && lookups[i]; i++) {
		switch (lookups[i]) {
		case 'b':
			strlcpy(qbuf, net, sizeof qbuf);
			buf = malloc(sizeof(*buf));
			if (buf == NULL)
				break;
			anslen = res_search(qbuf, C_IN, T_PTR, buf->buf,
			    sizeof(buf->buf));
			if (anslen < 0) {
				free(buf);
#ifdef DEBUG
				if (_resp->options & RES_DEBUG)
					printf("res_query failed\n");
#endif
				break;
			}
			net_entry = getnetanswer(buf, anslen, BYNAME);
			free(buf);
			if (net_entry != NULL)
				return (net_entry);
			break;
		case 'f':
			net_entry = _getnetbyname(net);
			if (net_entry != NULL)
				return (net_entry);
			break;
		}
	}

	/* Nothing matched. */
	return (NULL);
}
@


1.4
log
@merge
@
text
@a0 1
/**	$MirOS: src/lib/libc/net/getnetnamadr.c,v 1.3 2005/07/09 13:23:31 tg Exp $	*/
d79 1
a79 3
__RCSID("$MirOS: src/lib/libc/net/getnetnamadr.c,v 1.3 2005/07/09 13:23:31 tg Exp $");

extern int h_errno;
@


1.3
log
@merge
@
text
@d1 2
a2 2
/**	$MirOS: src/lib/libc/net/getnetnamadr.c,v 1.2 2005/03/06 20:28:42 tg Exp $	*/
/*	$OpenBSD: getnetnamadr.c,v 1.25 2005/03/30 02:58:28 tedu Exp $	*/
a63 7
#if 0
static char sccsid[] = "@@(#)getnetbyaddr.c	8.1 (Berkeley) 6/4/93";
static char sccsid_[] = "from getnetnamadr.c	1.4 (Coimbra) 93/06/03";
static char rcsid[] = "$From: getnetnamadr.c,v 8.7 1996/08/05 08:31:35 vixie Exp $";
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.25 2005/03/30 02:58:28 tedu Exp $";
#endif /* LIBC_SCCS and not lint */

d80 1
a80 1
__RCSID("$MirOS$");
@


1.2
log
@merge src/lib
@
text
@d1 2
a2 2
/**	$MirOS$	*/
/*	$OpenBSD: getnetnamadr.c,v 1.23 2003/06/03 21:09:00 deraadt Exp $	*/
a63 1
#if defined(LIBC_SCCS) && !defined(lint)
d68 1
a68 4
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.23 2003/06/03 21:09:00 deraadt Exp $";
#else
static char rcsid[] = "$MirOS$";
#endif
a70 1
#include <sys/types.h>
d87 2
d113 1
a113 4
getnetanswer(answer, anslen, net_i)
	querybuf *answer;
	int anslen;
	int net_i;
d116 3
a118 3
	register HEADER *hp;
	register u_char *cp;
	register int n;
d249 1
a249 3
getnetbyaddr(net, net_type)
	register in_addr_t net;
	register int net_type;
d261 1
a261 1
	if ((_resp->options & RES_INIT) == 0 && res_init() == -1)
d334 1
a334 2
getnetbyname(net)
	register const char *net;
d344 1
a344 1
	if ((_resp->options & RES_INIT) == 0 && res_init() == -1)
@


1.1
log
@Initial revision
@
text
@d1 1
d69 1
d71 1
a71 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.23 2003/06/03 21:09:00 deraadt Exp $";
d199 1
a199 1
			cp += n; 
d241 1
a241 1
			}		  
d272 1
a272 1
	bcopy(_resp->lookups, lookups, sizeof lookups);
a277 5
#ifdef YP
		case 'y':
			/* There is no YP support. */
			break;
#endif	/* YP */
d356 1
a356 1
	bcopy(_resp->lookups, lookups, sizeof lookups);
a361 5
#ifdef YP
		case 'y':
			/* There is no YP support. */
			break;
#endif	/* YP */
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@sync resolver code with OpenBSD (better)
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.25 2005/03/30 02:58:28 tedu Exp $	*/
d69 1
a69 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.25 2005/03/30 02:58:28 tedu Exp $";
d114 4
a117 1
getnetanswer(querybuf *answer, int anslen, int net_i)
d120 3
a122 3
	HEADER *hp;
	u_char *cp;
	int n;
d253 3
a255 1
getnetbyaddr(in_addr_t net, int net_type)
d267 1
a267 1
	if (_res_init(0) == -1)
d345 2
a346 1
getnetbyname(const char *net)
d356 1
a356 1
	if (_res_init(0) == -1)
@


1.1.1.3
log
@Import OpenBSD's libc as of today, minus some of the locale stuff,
and with brk malloc instead of mmap malloc
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.26 2005/08/06 20:30:03 espie Exp $	*/
d63 10
@


