head	1.6;
access;
symbols
	tnf-r1_33:1.1.3.2
	tnf-r1_12:1.1.3.1
	netbsd:1.1.3
	cvs-200905301730:1.1.1.3
	MIRBSD_10:1.3.0.4
	MIRBSD_10_BASE:1.3
	MIRBSD_9_BASE:1.3
	MIRBSD_8:1.3.0.2
	MIRBSD_8_BASE:1.3
	cvs-200509212000:1.1.1.2
	cvs-200507211800:1.1.1.1
	cvs-200504170300:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2011.11.20.19.32.10;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004EC955C66D88B191;

1.5
date	2009.08.09.17.42.49;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004A7F0A9C05A39D92;

1.4
date	2009.05.30.18.42.38;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004A217E0E1CE23BFC;

1.3
date	2005.09.22.20.33.01;	author tg;	state Exp;
branches;
next	1.2;
commitid	678e43331511a1e1;

1.2
date	2005.03.06.20.28.50;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.25.01;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.3.1;
next	;

1.1.1.1
date	2005.02.05.17.25.01;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.09.21.20.34.32;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	20cd4331c3c732a2;

1.1.1.3
date	2009.05.30.17.39.55;	author tg;	state Exp;
branches;
next	;
commitid	1004A216F7F7B5499B1;

1.1.3.1
date	2009.05.30.17.40.32;	author tg;	state Exp;
branches;
next	1.1.3.2;
commitid	1004A216FA203375E87;

1.1.3.2
date	2009.05.30.17.41.30;	author tg;	state Exp;
branches;
next	;
commitid	1004A216FD665C08577;


desc
@@


1.6
log
@drop more taitime users; fix a bit in %J handling (needs testing!)
@
text
@/**	$MirOS: src/lib/libc/time/strptime.c,v 1.5 2009/08/09 17:42:49 tg Exp $ */
/*	$OpenBSD: strptime.c,v 1.12 2008/06/26 05:42:05 ray Exp $ */
/*	$NetBSD: strptime.c,v 1.12 1998/01/20 21:39:40 mycroft Exp $	*/

/*-
 * Copyright (c) 1997, 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code was contributed to The NetBSD Foundation by Klaus Klein.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/cdefs.h>
#include <sys/localedef.h>
#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <locale.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <tzfile.h>

__RCSID("$MirOS: src/lib/libc/time/strptime.c,v 1.5 2009/08/09 17:42:49 tg Exp $");

/*
 * Evil hack for const correctness due to API brokenness
 */
union mksh_cchack {
	char *rw;
	const char *ro;
};

#define	_ctloc(x)		(_DefaultTimeLocale.x)

/*
 * We do not implement alternate representations. However, we always
 * check whether a given modifier is allowed for a certain conversion.
 */
#define _ALT_E			0x01
#define _ALT_O			0x02
#define	_LEGAL_ALT(x)		{ if (alt_format & ~(x)) return (0); }


static	int _conv_num(const unsigned char **, int *, int, int);
static	char *_strptime(const char *, const char *, struct tm *, int);


char *
strptime(const char *buf, const char *fmt, struct tm *tm)
{
	return(_strptime(buf, fmt, tm, 1));
}

static char *
_strptime(const char *buf, const char *fmt, struct tm *tm, int initialize)
{
	unsigned char c;
	const unsigned char *bp;
	size_t len = 0;
	int alt_format, i;
	static int century, relyear;
	union mksh_cchack rv;

	if (initialize) {
		century = TM_YEAR_BASE;
		relyear = -1;
	}

	bp = (const unsigned char *)buf;
	while ((c = *fmt) != '\0') {
		/* Clear `alternate' modifier prior to new conversion. */
		alt_format = 0;

		/* Eat up white-space. */
		if (isspace(c)) {
			while (isspace(*bp))
				bp++;

			fmt++;
			continue;
		}

		if ((c = *fmt++) != '%')
			goto literal;


again:		switch (c = *fmt++) {
		case '%':	/* "%%" is converted to "%". */
literal:
		if (c != *bp++)
			return (NULL);

		break;

		/*
		 * "Alternative" modifiers. Just set the appropriate flag
		 * and start over again.
		 */
		case 'E':	/* "%E?" alternative conversion modifier. */
			_LEGAL_ALT(0);
			alt_format |= _ALT_E;
			goto again;

		case 'O':	/* "%O?" alternative conversion modifier. */
			_LEGAL_ALT(0);
			alt_format |= _ALT_O;
			goto again;

		/*
		 * "Complex" conversion rules, implemented through recursion.
		 */
		case 'c':	/* Date and time, using the locale's format. */
			_LEGAL_ALT(_ALT_E);
			if (!(bp = _strptime(bp, _ctloc(d_t_fmt), tm, 0)))
				return (NULL);
			break;

		case 'D':	/* The date as "%m/%d/%y". */
			_LEGAL_ALT(0);
			if (!(bp = _strptime(bp, "%m/%d/%y", tm, 0)))
				return (NULL);
			break;

		case 'F':	/* The date as "%Y-%m-%d". */
			_LEGAL_ALT(0);
			if (!(bp = _strptime(bp, "%Y-%m-%d", tm, 0)))
				return (NULL);
			break;

		case 'R':	/* The time as "%H:%M". */
			_LEGAL_ALT(0);
			if (!(bp = _strptime(bp, "%H:%M", tm, 0)))
				return (NULL);
			break;

		case 'r':	/* The time as "%I:%M:%S %p". */
			_LEGAL_ALT(0);
			if (!(bp = _strptime(bp, "%I:%M:%S %p", tm, 0)))
				return (NULL);
			break;

		case 'T':	/* The time as "%H:%M:%S". */
			_LEGAL_ALT(0);
			if (!(bp = _strptime(bp, "%H:%M:%S", tm, 0)))
				return (NULL);
			break;

		case 'X':	/* The time, using the locale's format. */
			_LEGAL_ALT(_ALT_E);
			if (!(bp = _strptime(bp, _ctloc(t_fmt), tm, 0)))
				return (NULL);
			break;

		case 'x':	/* The date, using the locale's format. */
			_LEGAL_ALT(_ALT_E);
			if (!(bp = _strptime(bp, _ctloc(d_fmt), tm, 0)))
				return (NULL);
			break;

		/*
		 * "Elementary" conversion rules.
		 */
		case 'A':	/* The day of week, using the locale's form. */
		case 'a':
			_LEGAL_ALT(0);
			for (i = 0; i < 7; i++) {
				/* Full name. */
				len = strlen(_ctloc(day[i]));
				if (strncasecmp(_ctloc(day[i]), bp, len) == 0)
					break;

				/* Abbreviated name. */
				len = strlen(_ctloc(abday[i]));
				if (strncasecmp(_ctloc(abday[i]), bp, len) == 0)
					break;
			}

			/* Nothing matched. */
			if (i == 7)
				return (NULL);

			tm->tm_wday = i;
			bp += len;
			break;

		case 'B':	/* The month, using the locale's form. */
		case 'b':
		case 'h':
			_LEGAL_ALT(0);
			for (i = 0; i < 12; i++) {
				/* Full name. */
				len = strlen(_ctloc(mon[i]));
				if (strncasecmp(_ctloc(mon[i]), bp, len) == 0)
					break;

				/* Abbreviated name. */
				len = strlen(_ctloc(abmon[i]));
				if (strncasecmp(_ctloc(abmon[i]), bp, len) == 0)
					break;
			}

			/* Nothing matched. */
			if (i == 12)
				return (NULL);

			tm->tm_mon = i;
			bp += len;
			break;

		case 'C':	/* The century number. */
			_LEGAL_ALT(_ALT_E);
			if (!(_conv_num(&bp, &i, 0, 99)))
				return (NULL);

			century = i * 100;
			break;

		case 'd':	/* The day of month. */
		case 'e':
			_LEGAL_ALT(_ALT_O);
			if (!(_conv_num(&bp, &tm->tm_mday, 1, 31)))
				return (NULL);
			break;

		case 'k':	/* The hour (24-hour clock representation). */
			_LEGAL_ALT(0);
			/* FALLTHROUGH */
		case 'H':
			_LEGAL_ALT(_ALT_O);
			if (!(_conv_num(&bp, &tm->tm_hour, 0, 23)))
				return (NULL);
			break;

		case 'l':	/* The hour (12-hour clock representation). */
			_LEGAL_ALT(0);
			/* FALLTHROUGH */
		case 'I':
			_LEGAL_ALT(_ALT_O);
			if (!(_conv_num(&bp, &tm->tm_hour, 1, 12)))
				return (NULL);
			break;

		case 'J': {	/* Julian Date */
			/* Modified Julian Date */
			mirtime_mjd t_mjd;
			/* julian date, as per http://tycho.usno.navy.mil/mjd.html */
			double t_jd;
			char cvb[24], *cp;
			size_t cvbp = 0;
			int gotdot = 0, saved_errno;

			if (*bp == '-')
				cvb[cvbp++] = *bp++;

			if (*bp != '.' && (*bp < '0' || *bp > '9'))
				return (NULL);

			while (cvbp < sizeof(cvb) - 1)
				if ((!gotdot && *bp == '.') ||
				    (*bp >= '0' && *bp <= '9')) {
					if (*bp == '.')
						gotdot = 1;
					cvb[cvbp++] = *bp++;
				} else
					break;
			cvb[cvbp] = '\0';

			saved_errno = errno;
			errno = 0;
			t_jd = strtod(cvb, &cp);
			if (errno == ERANGE)
				cp = NULL;
			errno = saved_errno;
			if (cp == NULL || *cp != '\0')
				return (NULL);

			t_jd -= 2400000.5;		/* JD -> MJD */
			t_mjd.mjd = (time_t)t_jd;	/* day part */
			if (t_mjd.mjd < 0)
				--t_mjd.mjd;		/* make seconds positive */
			t_jd -= t_mjd.mjd;		/* frac. seconds part */
			/* how many seconds does this day have? */
			t_mjd.sec = 86399;
			t_jd *= mirtime_isleap(mjd2timet(&t_mjd) + 1) ?
			    86401 : 86400;
			t_mjd.sec = t_jd;		/* int. seconds part */
			/* return the value */
			mjd_explode(tm, &t_mjd);
			break;
		}

		case 'j':	/* The day of year. */
			_LEGAL_ALT(0);
			if (!(_conv_num(&bp, &tm->tm_yday, 1, 366)))
				return (NULL);
			tm->tm_yday--;
			break;

		case 'M':	/* The minute. */
			_LEGAL_ALT(_ALT_O);
			if (!(_conv_num(&bp, &tm->tm_min, 0, 59)))
				return (NULL);
			break;

		case 'm':	/* The month. */
			_LEGAL_ALT(_ALT_O);
			if (!(_conv_num(&bp, &tm->tm_mon, 1, 12)))
				return (NULL);
			tm->tm_mon--;
			break;

		case 'p':	/* The locale's equivalent of AM/PM. */
			_LEGAL_ALT(0);
			/* AM? */
			len = strlen(_ctloc(am_pm[0]));
			if (strncasecmp(_ctloc(am_pm[0]), bp, len) == 0) {
				if (tm->tm_hour > 12)	/* i.e., 13:00 AM ?! */
					return (NULL);
				else if (tm->tm_hour == 12)
					tm->tm_hour = 0;

				bp += len;
				break;
			}
			/* PM? */
			len = strlen(_ctloc(am_pm[1]));
			if (strncasecmp(_ctloc(am_pm[1]), bp, len) == 0) {
				if (tm->tm_hour > 12)	/* i.e., 13:00 PM ?! */
					return (NULL);
				else if (tm->tm_hour < 12)
					tm->tm_hour += 12;

				bp += len;
				break;
			}

			/* Nothing matched. */
			return (NULL);

		case 'S':	/* The seconds. */
			_LEGAL_ALT(_ALT_O);
			if (!(_conv_num(&bp, &tm->tm_sec, 0, 61)))
				return (NULL);
			break;

#ifndef TIME_MAX
#ifdef _BSD_TIME_T_IS_64_BIT
#define TIME_MAX	INT64_MAX
#else
#define TIME_MAX	INT32_MAX
#endif
#endif
		case 's':	/* seconds since the epoch */
			{
				time_t sse = 0;
				uint64_t rulim = TIME_MAX;

				if (*bp < '0' || *bp > '9')
					return (NULL);

				do {
					sse *= 10;
					sse += *bp++ - '0';
					rulim /= 10;
				} while ((sse <= TIME_MAX / 10) &&
					 rulim && *bp >= '0' && *bp <= '9');

				if (sse < 0 || (uint64_t)sse > TIME_MAX)
					return (NULL);

				if (localtime_r(&sse, tm) == NULL)
					return (NULL);
			}
			break;

		case 'U':	/* The week of year, beginning on sunday. */
		case 'W':	/* The week of year, beginning on monday. */
			_LEGAL_ALT(_ALT_O);
			/*
			 * XXX This is bogus, as we can not assume any valid
			 * information present in the tm structure at this
			 * point to calculate a real value, so just check the
			 * range for now.
			 */
			 if (!(_conv_num(&bp, &i, 0, 53)))
				return (NULL);
			 break;

		case 'w':	/* The day of week, beginning on sunday. */
			_LEGAL_ALT(_ALT_O);
			if (!(_conv_num(&bp, &tm->tm_wday, 0, 6)))
				return (NULL);
			break;

		case 'Y':	/* The year. */
			_LEGAL_ALT(_ALT_E);
			if (!(_conv_num(&bp, &i, 0, 9999)))
				return (NULL);

			relyear = -1;
			tm->tm_year = i - TM_YEAR_BASE;
			break;

		case 'y':	/* The year within the century (2 digits). */
			_LEGAL_ALT(_ALT_E | _ALT_O);
			if (!(_conv_num(&bp, &relyear, 0, 99)))
				return (NULL);
			break;

		/*
		 * Miscellaneous conversions.
		 */
		case 'n':	/* Any kind of white-space. */
		case 't':
			_LEGAL_ALT(0);
			while (isspace(*bp))
				bp++;
			break;


		default:	/* Unknown/unsupported conversion. */
			return (NULL);
		}


	}

	/*
	 * We need to evaluate the two digit year spec (%y)
	 * last as we can get a century spec (%C) at any time.
	 */
	if (relyear != -1) {
		if (century == TM_YEAR_BASE) {
			if (relyear <= 68)
				tm->tm_year = relyear + 2000 - TM_YEAR_BASE;
			else
				tm->tm_year = relyear + 1900 - TM_YEAR_BASE;
		} else {
			tm->tm_year = relyear + century - TM_YEAR_BASE;
		}
	}

	rv.ro = bp;
	return (rv.rw);
}


static int
_conv_num(const unsigned char **buf, int *dest, int llim, int ulim)
{
	int result = 0;
	int rulim = ulim;

	if (**buf < '0' || **buf > '9')
		return (0);

	/* we use rulim to break out of the loop when we run out of digits */
	do {
		result *= 10;
		result += *(*buf)++ - '0';
		rulim /= 10;
	} while ((result * 10 <= ulim) && rulim && **buf >= '0' && **buf <= '9');

	if (result < llim || result > ulim)
		return (0);

	*dest = result;
	return (1);
}
@


1.5
log
@• fix a rather embarassing reverse logic error
• while here, __CRAZY=Yes (würg around broken API)
@
text
@d1 1
a1 1
/**	$MirOS: src/lib/libc/time/strptime.c,v 1.4 2009/05/30 18:42:38 tg Exp $ */
a34 1
#include <sys/taitime.h>
d45 1
a45 1
__RCSID("$MirOS: src/lib/libc/time/strptime.c,v 1.4 2009/05/30 18:42:38 tg Exp $");
d266 2
a267 2
			/* modified julian date, as per DJB */
			mjd_t t_mjd;
d270 1
a270 2
			/* like _conv(), width from SQLite3 */
			char cvb[20], *cp;
d274 3
d298 1
d304 4
a307 3
			/* how many seconds has our day? */
			t_mjd.sec = 86400;
			t_jd *= ((mjd2tm(t_mjd).tm_sec == 60) ? 86401 : 86400);
d310 1
a310 1
			*tm = mjd2tm(t_mjd);
@


1.4
log
@• sync with OpenBSD
• add from TNF: Add %s (seconds since the Epoch) to strptime(3) for
  symmetry with strftime(3). [ginsbach…
• Add %J for symmetry too [tg] ☺
@
text
@d1 1
a1 1
/**	$MirOS: src/lib/libc/time/strptime.c,v 1.3 2005/09/22 20:33:01 tg Exp $ */
d46 9
a54 1
__RCSID("$MirOS: src/lib/libc/time/strptime.c,v 1.3 2005/09/22 20:33:01 tg Exp $");
d85 1
d367 2
a369 2
#else
#define TIME_MAX	INT64_MAX
d462 2
a463 1
	return ((char *)bp);
@


1.3
log
@merge and hope it does not break
@
text
@d1 2
a2 2
/**	$MirOS: src/lib/libc/time/strptime.c,v 1.2 2005/03/06 20:28:50 tg Exp $ */
/*	$OpenBSD: strptime.c,v 1.11 2005/08/08 08:05:38 espie Exp $ */
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
d35 1
d37 2
d40 2
d46 1
a46 1
__RCSID("$MirOS: src/lib/libc/time/strptime.c,v 1.2 2005/03/06 20:28:50 tg Exp $");
d74 1
a74 1
	size_t len;
d83 1
a83 1
	bp = (unsigned char *)buf;
d138 6
d257 45
d356 30
@


1.2
log
@merge src/lib
@
text
@d1 2
a2 1
/**	$MirOS$ */
a39 4
#if 0
static char rcsid[] = "$OpenBSD: strptime.c,v 1.10 2004/09/15 19:01:58 deraadt Exp $";
#endif /* LIBC_SCCS and not lint */

d48 1
a48 1
__RCSID("$MirOS$");
@


1.1
log
@Initial revision
@
text
@d1 1
d39 1
a39 1
#if defined(LIBC_SCCS) && !defined(lint)
d43 1
d51 3
a53 1
#define	_ctloc(x)		(_CurrentTimeLocale->x)
d101 1
a101 1
				
d127 1
a127 1
			
d142 1
a142 1
	
@


1.1.3.1
log
@import nbsd base of obsd on this file
@
text
@a37 1
#include <sys/cdefs.h>
d39 2
a40 2
__RCSID("$NetBSD: strptime.c,v 1.12 1998/01/20 21:39:40 mycroft Exp $");
#endif
a41 1
#include "namespace.h"
d49 1
a49 5
#ifdef __weak_alias
__weak_alias(strptime,_strptime);
#endif

#define	_ctloc(x)		__CONCAT(_CurrentTimeLocale->,x)
d60 2
a61 1
static	int _conv_num __P((const char **, int *, int, int));
d65 1
a65 3
strptime(buf, fmt, tm)
	const char *buf, *fmt;
	struct tm *tm;
d67 2
a68 3
	char c;
	const char *bp;
	int alt_format, i, len;
d70 13
a82 1
	bp = buf;
d84 1
d106 1
a106 1
			return (0);
d129 2
a130 2
			if (!(bp = strptime(bp, _ctloc(d_t_fmt), tm)))
				return (0);
d135 2
a136 2
			if (!(bp = strptime(bp, "%m/%d/%y", tm)))
				return (0);
d141 2
a142 2
			if (!(bp = strptime(bp, "%H:%M", tm)))
				return (0);
d145 1
a145 1
		case 'r':	/* The time in 12-hour clock representation. */
d147 2
a148 2
			if (!(bp = strptime(bp, _ctloc(t_fmt_ampm), tm)))
				return (0);
d153 2
a154 2
			if (!(bp = strptime(bp, "%H:%M:%S", tm)))
				return (0);
d159 2
a160 2
			if (!(bp = strptime(bp, _ctloc(t_fmt), tm)))
				return (0);
d165 2
a166 2
			if (!(bp = strptime(bp, _ctloc(d_fmt), tm)))
				return (0);
d178 1
a178 1
				if (strncmp(_ctloc(day[i]), bp, len) == 0)
d183 1
a183 1
				if (strncmp(_ctloc(abday[i]), bp, len) == 0)
d189 1
a189 1
				return (0);
d202 1
a202 1
				if (strncmp(_ctloc(mon[i]), bp, len) == 0)
d207 1
a207 1
				if (strncmp(_ctloc(abmon[i]), bp, len) == 0)
d213 1
a213 1
				return (0);
d222 1
a222 1
				return (0);
d224 1
a224 1
			tm->tm_year = i * 100;
d231 1
a231 1
				return (0);
d240 1
a240 1
				return (0);
d248 2
a249 2
			if (!(_conv_num(&bp, &tm->tm_hour, 0, 11)))
				return (0);
d255 2
a256 1
				return (0);
d262 1
a262 1
				return (0);
d268 2
a269 1
				return (0);
d275 2
a276 1
			if (strcmp(_ctloc(am_pm[0]), bp) == 0) {
d278 1
a278 1
					return (0);
d282 1
a282 1
				bp += strlen(_ctloc(am_pm[0]));
d286 2
a287 1
			else if (strcmp(_ctloc(am_pm[1]), bp) == 0) {
d289 1
a289 1
					return (0);
d293 1
a293 1
				bp += strlen(_ctloc(am_pm[1]));
d298 1
a298 1
			return (0);
d302 2
a303 2
			if (!(_conv_num(&bp, &tm->tm_sec, 1, 61)))
				return (0);
d316 1
a316 1
				return (0);
d322 1
a322 1
				return (0);
d327 2
a328 2
			if (!(_conv_num(&bp, &i, 0, INT_MAX)))
				return (0);
d330 1
d334 1
a334 1
		case 'y':	/* The year within 100 years of the epoch. */
d336 2
a337 7
			if (!(_conv_num(&bp, &i, 0, 99)))
				return (0);

			if (i <= 68)
				tm->tm_year = i + 2000 - TM_YEAR_BASE;
			else
				tm->tm_year = i + 1900 - TM_YEAR_BASE;
d352 1
a352 1
			return (0);
d358 15
d378 1
a378 4
_conv_num(buf, dest, llim, ulim)
	const char **buf;
	int *dest;
	int llim, ulim;
d380 2
a381 1
	*dest = 0;
d386 1
d388 4
a391 3
		*dest *= 10;
		*dest += *(*buf)++ - '0';
	} while ((*dest * 10 <= ulim) && **buf >= '0' && **buf <= '9');
d393 1
a393 1
	if (*dest < llim || *dest > ulim)
d396 1
@


1.1.3.2
log
@import TNF-current cvs-200905301740 on this file
@
text
@d1 1
a1 1
/*	$NetBSD: strptime.c,v 1.33 2009/05/24 02:25:43 ginsbach Exp $	*/
d4 1
a4 1
 * Copyright (c) 1997, 1998, 2005, 2008 The NetBSD Foundation, Inc.
a7 1
 * Heavily optimised by David Laight
d17 7
d40 1
a40 1
__RCSID("$NetBSD: strptime.c,v 1.33 2009/05/24 02:25:43 ginsbach Exp $");
a49 1
#include "private.h"
d52 1
a52 1
__weak_alias(strptime,_strptime)
d55 1
a55 1
#define	_ctloc(x)		(_CurrentTimeLocale->x)
d61 6
a66 17
#define ALT_E			0x01
#define ALT_O			0x02
#define	LEGAL_ALT(x)		{ if (alt_format & ~(x)) return NULL; }

static char gmt[] = { "GMT" };
static char utc[] = { "UTC" };
/* RFC-822/RFC-2822 */
static const char * const nast[5] = {
       "EST",    "CST",    "MST",    "PST",    "\0\0\0"
};
static const char * const nadt[5] = {
       "EDT",    "CDT",    "MDT",    "PDT",    "\0\0\0"
};

static const u_char *conv_num(const unsigned char *, int *, uint, uint);
static const u_char *find_string(const u_char *, int *, const char * const *,
	const char * const *, int);
d70 3
a72 1
strptime(const char *buf, const char *fmt, struct tm *tm)
d74 3
a76 4
	unsigned char c;
	const unsigned char *bp, *ep;
	int alt_format, i, split_year = 0, neg = 0, offs;
	const char *new_fmt;
d78 1
a78 1
	bp = (const u_char *)buf;
d80 1
a80 1
	while (bp != NULL && (c = *fmt++) != '\0') {
a82 1
		i = 0;
d88 2
d92 2
a93 2

		if (c != '%')
d100 4
a103 4
			if (c != *bp++)
				return NULL;
			LEGAL_ALT(0);
			continue;
d110 2
a111 2
			LEGAL_ALT(0);
			alt_format |= ALT_E;
d115 2
a116 2
			LEGAL_ALT(0);
			alt_format |= ALT_O;
d118 1
a118 1

d123 4
a126 2
			new_fmt = _ctloc(d_t_fmt);
			goto recurse;
d129 5
a133 9
			new_fmt = "%m/%d/%y";
			LEGAL_ALT(0);
			goto recurse;

		case 'F':	/* The date as "%Y-%m-%d". */
			new_fmt = "%Y-%m-%d";
			LEGAL_ALT(0);
			goto recurse;

d135 4
a138 3
			new_fmt = "%H:%M";
			LEGAL_ALT(0);
			goto recurse;
d141 4
a144 3
			new_fmt =_ctloc(t_fmt_ampm);
			LEGAL_ALT(0);
			goto recurse;
d147 4
a150 3
			new_fmt = "%H:%M:%S";
			LEGAL_ALT(0);
			goto recurse;
d153 4
a156 2
			new_fmt =_ctloc(t_fmt);
			goto recurse;
d159 4
a162 6
			new_fmt =_ctloc(d_fmt);
		    recurse:
			bp = (const u_char *)strptime((const char *)bp,
							    new_fmt, tm);
			LEGAL_ALT(ALT_E);
			continue;
d169 20
a188 4
			bp = find_string(bp, &tm->tm_wday, _ctloc(day),
					_ctloc(abday), 7);
			LEGAL_ALT(0);
			continue;
d193 20
a212 4
			bp = find_string(bp, &tm->tm_mon, _ctloc(mon),
					_ctloc(abmon), 12);
			LEGAL_ALT(0);
			continue;
d215 3
a217 2
			i = 20;
			bp = conv_num(bp, &i, 0, 99);
d219 2
a220 7
			i = i * 100 - TM_YEAR_BASE;
			if (split_year)
				i += tm->tm_year % 100;
			split_year = 1;
			tm->tm_year = i;
			LEGAL_ALT(ALT_E);
			continue;
d224 4
a227 3
			bp = conv_num(bp, &tm->tm_mday, 1, 31);
			LEGAL_ALT(ALT_O);
			continue;
d230 1
a230 1
			LEGAL_ALT(0);
d233 4
a236 3
			bp = conv_num(bp, &tm->tm_hour, 0, 23);
			LEGAL_ALT(ALT_O);
			continue;
d239 1
a239 1
			LEGAL_ALT(0);
d242 4
a245 5
			bp = conv_num(bp, &tm->tm_hour, 1, 12);
			if (tm->tm_hour == 12)
				tm->tm_hour = 0;
			LEGAL_ALT(ALT_O);
			continue;
d248 4
a251 5
			i = 1;
			bp = conv_num(bp, &i, 1, 366);
			tm->tm_yday = i - 1;
			LEGAL_ALT(0);
			continue;
d254 4
a257 3
			bp = conv_num(bp, &tm->tm_min, 0, 59);
			LEGAL_ALT(ALT_O);
			continue;
d260 4
a263 5
			i = 1;
			bp = conv_num(bp, &i, 1, 12);
			tm->tm_mon = i - 1;
			LEGAL_ALT(ALT_O);
			continue;
d266 17
a282 6
			bp = find_string(bp, &i, _ctloc(am_pm), NULL, 2);
			if (tm->tm_hour > 11)
				return NULL;
			tm->tm_hour += i * 12;
			LEGAL_ALT(0);
			continue;
d284 3
a286 4
		case 'S':	/* The seconds. */
			bp = conv_num(bp, &tm->tm_sec, 0, 61);
			LEGAL_ALT(ALT_O);
			continue;
d288 2
a289 24
#ifndef TIME_MAX
#define TIME_MAX	INT64_MAX
#endif
		case 's':	/* seconds since the epoch */
			{
				time_t sse = 0;
				uint64_t rulim = TIME_MAX;

				if (*bp < '0' || *bp > '9') {
					bp = NULL;
					continue;
				}

				do {
					sse *= 10;
					sse += *bp++ - '0';
					rulim /= 10;
				} while ((sse * 10 <= TIME_MAX) &&
					 rulim && *bp >= '0' && *bp <= '9');

				if (sse < 0 || (uint64_t)sse > TIME_MAX) {
					bp = NULL;
					continue;
				}
d291 5
a295 4
				if (localtime_r(&sse, tm) == NULL)
					bp = NULL;
			}
			continue;
d299 1
d306 3
a308 3
			 bp = conv_num(bp, &i, 0, 53);
			 LEGAL_ALT(ALT_O);
			 continue;
d311 4
a314 3
			bp = conv_num(bp, &tm->tm_wday, 0, 6);
			LEGAL_ALT(ALT_O);
			continue;
d316 4
a319 19
		case 'u':	/* The day of week, monday = 1. */
			bp = conv_num(bp, &i, 1, 7);
			tm->tm_wday = i % 7;
			LEGAL_ALT(ALT_O);
			continue;

		case 'g':	/* The year corresponding to the ISO week
				 * number but without the century.
				 */
			bp = conv_num(bp, &i, 0, 99);
			continue;

		case 'G':	/* The year corresponding to the ISO week
				 * number with century.
				 */
			do
				bp++;
			while (isdigit(*bp));
			continue;
a320 7
		case 'V':	/* The ISO 8601:1988 week number as decimal */
			bp = conv_num(bp, &i, 0, 53);
			continue;

		case 'Y':	/* The year. */
			i = TM_YEAR_BASE;	/* just for data sanity... */
			bp = conv_num(bp, &i, 0, 9999);
d322 1
a322 2
			LEGAL_ALT(ALT_E);
			continue;
d325 9
a333 172
			/* LEGAL_ALT(ALT_E | ALT_O); */
			bp = conv_num(bp, &i, 0, 99);

			if (split_year)
				/* preserve century */
				i += (tm->tm_year / 100) * 100;
			else {
				split_year = 1;
				if (i <= 68)
					i = i + 2000 - TM_YEAR_BASE;
				else
					i = i + 1900 - TM_YEAR_BASE;
			}
			tm->tm_year = i;
			continue;

		case 'Z':
			tzset();
			if (strncmp((const char *)bp, gmt, 3) == 0) {
				tm->tm_isdst = 0;
#ifdef TM_GMTOFF
				tm->TM_GMTOFF = 0;
#endif
#ifdef TM_ZONE
				tm->TM_ZONE = gmt;
#endif
				bp += 3;
			} else {
				ep = find_string(bp, &i,
					       	 (const char * const *)tzname,
					       	  NULL, 2);
				if (ep != NULL) {
					tm->tm_isdst = i;
#ifdef TM_GMTOFF
					tm->TM_GMTOFF = -(timezone);
#endif
#ifdef TM_ZONE
					tm->TM_ZONE = tzname[i];
#endif
				}
				bp = ep;
			}
			continue;

		case 'z':
			/*
			 * We recognize all ISO 8601 formats:
			 * Z	= Zulu time/UTC
			 * [+-]hhmm
			 * [+-]hh:mm
			 * [+-]hh
			 * We recognize all RFC-822/RFC-2822 formats:
			 * UT|GMT
			 *          North American : UTC offsets
			 * E[DS]T = Eastern : -4 | -5
			 * C[DS]T = Central : -5 | -6
			 * M[DS]T = Mountain: -6 | -7
			 * P[DS]T = Pacific : -7 | -8
			 *          Military
			 * [A-IL-M] = -1 ... -9 (J not used)
			 * [N-Y]  = +1 ... +12
			 */
			while (isspace(*bp))
				bp++;

			switch (*bp++) {
			case 'G':
				if (*bp++ != 'M')
					return NULL;
				/*FALLTHROUGH*/
			case 'U':
				if (*bp++ != 'T')
					return NULL;
				/*FALLTHROUGH*/
			case 'Z':
				tm->tm_isdst = 0;
#ifdef TM_GMTOFF
				tm->TM_GMTOFF = 0;
#endif
#ifdef TM_ZONE
				tm->TM_ZONE = utc;
#endif
				continue;
			case '+':
				neg = 0;
				break;
			case '-':
				neg = 1;
				break;
			default:
				--bp;
				ep = find_string(bp, &i, nast, NULL, 4);
				if (ep != NULL) {
#ifdef TM_GMTOFF
					tm->TM_GMTOFF = -5 - i;
#endif
#ifdef TM_ZONE
					tm->TM_ZONE = __UNCONST(nast[i]);
#endif
					bp = ep;
					continue;
				}
				ep = find_string(bp, &i, nadt, NULL, 4);
				if (ep != NULL) {
					tm->tm_isdst = 1;
#ifdef TM_GMTOFF
					tm->TM_GMTOFF = -4 - i;
#endif
#ifdef TM_ZONE
					tm->TM_ZONE = __UNCONST(nadt[i]);
#endif
					bp = ep;
					continue;
				}

				if ((*bp >= 'A' && *bp <= 'I') ||
				    (*bp >= 'L' && *bp <= 'Y')) {
#ifdef TM_GMTOFF
					/* Argh! No 'J'! */
					if (*bp >= 'A' && *bp <= 'I')
						tm->TM_GMTOFF =
						    ('A' - 1) - (int)*bp;
					else if (*bp >= 'L' && *bp <= 'M')
						tm->TM_GMTOFF = 'A' - (int)*bp;
					else if (*bp >= 'N' && *bp <= 'Y')
						tm->TM_GMTOFF = (int)*bp - 'M';
#endif
#ifdef TM_ZONE
					tm->TM_ZONE = NULL; /* XXX */
#endif
					bp++;
					continue;
				}
				return NULL;
			}
			offs = 0;
			for (i = 0; i < 4; ) {
				if (isdigit(*bp)) {
					offs = offs * 10 + (*bp++ - '0');
					i++;
					continue;
				}
				if (i == 2 && *bp == ':') {
					bp++;
					continue;
				}
				break;
			}
			switch (i) {
			case 2:
				offs *= 100;
				break;
			case 4:
				i = offs % 100;
				if (i >= 60)
					return NULL;
				/* Convert minutes into decimal */
				offs = (offs / 100) * 100 + (i * 50) / 30;
				break;
			default:
				return NULL;
			}
			if (neg)
				offs = -offs;
			tm->tm_isdst = 0;	/* XXX */
#ifdef TM_GMTOFF
			tm->TM_GMTOFF = offs;
#endif
#ifdef TM_ZONE
			tm->TM_ZONE = NULL;	/* XXX */
#endif
			continue;
d340 1
d343 1
a343 2
			LEGAL_ALT(0);
			continue;
d347 1
a347 1
			return NULL;
d349 2
d353 1
a353 1
	return __UNCONST(bp);
d357 5
a361 2
static const u_char *
conv_num(const unsigned char *buf, int *dest, uint llim, uint ulim)
d363 1
a363 5
	uint result = 0;
	unsigned char ch;

	/* The limit also determines the number of valid digits. */
	uint rulim = ulim;
d365 2
a366 3
	ch = *buf;
	if (ch < '0' || ch > '9')
		return NULL;
d369 3
a371 12
		result *= 10;
		result += ch - '0';
		rulim /= 10;
		ch = *++buf;
	} while ((result * 10 <= ulim) && rulim && ch >= '0' && ch <= '9');

	if (result < llim || result > ulim)
		return NULL;

	*dest = result;
	return buf;
}
d373 2
a374 17
static const u_char *
find_string(const u_char *bp, int *tgt, const char * const *n1,
		const char * const *n2, int c)
{
	int i;
	unsigned int len;

	/* check full name - then abbreviated ones */
	for (; n1 != NULL; n1 = n2, n2 = NULL) {
		for (i = 0; i < c; i++, n1++) {
			len = strlen(*n1);
			if (strncasecmp(*n1, (const char *)bp, len) == 0) {
				*tgt = i;
				return bp + len;
			}
		}
	}
d376 1
a376 2
	/* Nothing matched */
	return NULL;
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import OpenBSD's libc as of today, minus some of the locale stuff,
and with brk malloc instead of mmap malloc
@
text
@a0 1
/*	$OpenBSD: strptime.c,v 1.11 2005/08/08 08:05:38 espie Exp $ */
d38 4
@


1.1.1.3
log
@sync with obsd
@
text
@d1 1
a1 1
/*	$OpenBSD: strptime.c,v 1.12 2008/06/26 05:42:05 ray Exp $ */
d18 7
@


