head	1.10;
access;
symbols
	MIRBSD_9_BASE:1.6
	MIRBSD_8:1.3.0.2
	MIRBSD_8_BASE:1.3
	mirbsd:1.1.7;
locks; strict;
comment	@ * @;


1.10
date	2007.02.07.20.43.25;	author tg;	state dead;
branches;
next	1.9;
commitid	10045CA39907FBE4A06;

1.9
date	2006.12.20.17.15.34;	author tg;	state Exp;
branches;
next	1.8;
commitid	10045896F7A1E60E08B;

1.8
date	2006.12.20.17.09.42;	author tg;	state Exp;
branches;
next	1.7;
commitid	10045896E3036BB4196;

1.7
date	2006.11.01.20.01.21;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004548FD236EA4946C;

1.6
date	2006.06.12.21.50.11;	author tg;	state Exp;
branches;
next	1.5;
commitid	100448DE1A3287F9079;

1.5
date	2006.06.12.21.41.31;	author tg;	state Exp;
branches;
next	1.4;
commitid	100448DDF9F541EF8CF;

1.4
date	2006.06.02.02.29.56;	author tg;	state Exp;
branches;
next	1.3;
commitid	100447FA28346FF91C0;

1.3
date	2005.12.17.05.46.16;	author tg;	state Exp;
branches;
next	1.2;
commitid	10043A3A3E65E20A413;

1.2
date	2005.04.17.01.36.06;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.06.16.33.39;	author tg;	state Exp;
branches
	1.1.7.1;
next	;

1.1.7.1
date	2005.03.06.16.33.39;	author tg;	state Exp;
branches;
next	;


desc
@@


1.10
log
@* attempt to move taitime(3) functions from libc and kernel to kernbase,
  its prototypes from <time.h> and <sys/time.h> (which includes <time.h>)
  and <lib/libkern/taitime.h> to <sys/taitime.h>, split between indepen-
  dent and dependent (kernel/userland different leap table initialisation;
  userland additional tai_time(), taina_time(), importtai(), exporttai()),
  reduce required headers; reduce diff from headers to upstream
* move kernel tai leap second table from kernel objects to libkern
@
text
@/* $MirOS: src/lib/libc/time/taitime.c,v 1.9 2006/12/20 17:15:34 tg Exp $ */

/*-
 * Copyright (c) 2004, 2005, 2006
 *	Thorsten Glaser <tg@@mirbsd.de>
 * Based upon code placed into the public domain by
 *	Dan J. Bernstein <djb@@cr.yp.to>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * Advertising materials mentioning features or use of this work must
 * display the following acknowledgement:
 *	This product includes material provided by Thorsten Glaser.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 */

#include <sys/param.h>
#include <stdint.h>
#include "private.h"
#include "tzfile.h"

__RCSID("$MirOS: src/lib/libc/time/taitime.c,v 1.9 2006/12/20 17:15:34 tg Exp $");

/* private interface */
tai64_t _leaps[TZ_MAX_LEAPS + 1] = {0};
int _leaps_initialised = 0;

/* private interface */
void _pushleap(time_t);

/* XXX which GNUC_PREREQ to use? */
#ifndef __GNUC__
/* private interface */
static __inline tai64_t *_tai_leaps(void);
static __inline tai64_t *
_tai_leaps(void)
{
	extern void _initialise_leaps(void);

	if (__predict_false(!_leaps_initialised)) {
		_leaps_initialised = 1;
		_initialise_leaps();
	}
	return (_leaps);
}
#else
extern void _initialise_leaps(void);
#define _tai_leaps() __extension__({				\
		if (__predict_false(!_leaps_initialised)) {	\
			_leaps_initialised = 1;			\
			_initialise_leaps();			\
		}						\
		_leaps;						\
	})
#endif

tai64_t
tai_time(tai64_t *v)
{
	register int64_t t;
	struct timeval tv;

	/*
	 * We expect the kernel to count absolute seconds
	 * since the epoch 1970-01-01 00:00:00 UTC.
	 */
	gettimeofday(&tv, NULL);

	t = tv.tv_sec + __TAI64_BIAS;
	if (__predict_false(v != NULL))
		*v = t;

	return (t);
}

void
taina_time(tai64na_t *t)
{
	struct timespec tp;

	if (__predict_false(t == NULL))
		return;

	t->atto = 0;
	clock_gettime(CLOCK_REALTIME, &tp);
	t->secs = tp.tv_sec + __TAI64_BIAS;
	t->nano = (int32_t)tp.tv_nsec;
}

void
exporttai(uint8_t *dst, tai64na_t *src)
{
	struct {
		uint64_t secs;
		uint32_t nano;
		uint32_t atto;
	} *target = (void *)dst;

	if (__predict_false((src == NULL) || (dst == NULL)))
		return;

	target->secs = htobe64(__BOUNDINT0(0x7FFFFFFFFFFFFFFFLL, src->secs));
	target->nano = htobe32(__BOUNDINTU(999999999, src->nano));
	target->atto = htobe32(__BOUNDINTU(999999999, src->atto));
}

void
importtai(uint8_t *src, tai64na_t *dst)
{
	struct {
		uint64_t secs;
		uint32_t nano;
		uint32_t atto;
	} *source = (void *)src;

	if (__predict_false((src == NULL) || (dst == NULL)))
		return;

	dst->secs = betoh64(source->secs);
	dst->nano = __BOUNDINTU(999999999, betoh32(source->nano));
	dst->atto = __BOUNDINTU(999999999, betoh32(source->atto));
}

tai64_t
utc2tai(int64_t u)
{
	tai64_t t = u + __TAI64_BIAS;
	tai64_t *s = _tai_leaps();

	if (__predict_true(u > 0))
		while (__predict_true((*s) && (t >= *s))) {
			++t;
			++s;
		}
	return (t);
}

int64_t
tai2utc(tai64_t t)
{
	int64_t u = t - __TAI64_BIAS;
	tai64_t *s = _tai_leaps();

	if (__predict_true(u > 0))
		while (__predict_true((*s) && (t >= *s))) {
			--u;
			++s;
		}

	return (u);
}

/* private interface */
void
_pushleap(time_t leap)
{
	tai64_t *t = _leaps;

	while (__predict_true(*t))
		++t;
	*t++ = timet2tai(leap);
	*t = 0;
}

tai64_t *
tai_leaps(void)
{
	return (_tai_leaps());
}

int
tai_isleap(tai64_t x)
{
	tai64_t *t;

	t = _tai_leaps();
	while (__predict_true(*t))
		if (__predict_false((*t) == x))
			return (1);
		else if (__predict_false((*t) > x))
			return (0);
		else
			++t;
	return (0);
}

/* !!! make sure no timet2tai() or tai2timet() calls below this line !!! */

/* normally a macro */
#undef timet2tai
tai64_t
timet2tai(time_t x)
{
	return (((uint64_t)x < 0x4000000000000000ULL)
	    ? ((tai64_t)((uint64_t)x + __TAI64_BIAS))
	    : (((uint64_t)x < 0x8000000000000000ULL)
	    ? ((tai64_t)0x7FFFFFFFFFFFFFFFULL)
	    : (((uint64_t)x < 0xC000000000000000ULL)
	    ? ((tai64_t)0ULL)
	    : ((tai64_t)((uint64_t)x + __TAI64_BIAS)))));
}

/* normally a macro */
#undef tai2timet
time_t
tai2timet(tai64_t x)
{
	return (((uint64_t)x & 0x8000000000000000ULL)
	    ? 0
	    : ((uint64_t)x - __TAI64_BIAS));
}

tai64_t
mjd2tai(mjd_t m)
{
	int64_t x = (m.mjd - 40587LL) * 86400LL;
	tai64_t t;

	x += (m.sec > 86399) ? 86399 : m.sec;
	t = utc2tai(x);
	if (m.sec > 86399)
		++t;

	return (t);
}

mjd_t
tai2mjd(tai64_t tai)
{
	int64_t x = tai2utc(tai);
	mjd_t m;

	m.sec = (int32_t)(x % 86400LL);
	m.mjd = (x / 86400LL) + 40587LL;

	while (__predict_false(m.sec < 0)) {
		m.sec += 86400;
		--m.mjd;
	}

	if (__predict_false(tai_isleap(tai)))
		++m.sec;

	return (m);
}

/*
 * For more information on DJB products, such as libtai,
 * please go to http://cr.yp.to/
 */

/* from caldate_frommjd libtai-0.60 */
/* hacked up for time_t-64 support */

struct tm
mjd2tm(mjd_t m)
{
	time_t year;
	int month, day, yday, wday, sec, leap;
	struct tm res;

	bzero(&res, sizeof(res));

	year = m.mjd;
	sec = m.sec;

	while (sec < 0) {
		sec += 86400;
		--year;
	}

	while (sec > 86400) {
		sec -= 86400;
		++year;
	}

	if (__predict_false(leap = ((sec == 86400) ? 1 : 0)))
		--sec;

	day = (int32_t)(year % 146097LL) + 678881;
	year /= 146097LL;
	while (__predict_false(day >= 146097)) {
		day -= 146097;
		++year;
	}

	/* year * 146097 + day - 678881 is MJD; 0 <= day < 146097 */
	/* 2000-03-01, MJD 51604, is year 5, day 0 */

	wday = (day + 3) % 7;

	year *= 4;
	if (__predict_false(day == 146096)) {
		year += 3;
		day = 36524;
	} else {
		year += day / 36524LL;
		day %= 36524;
	}
	year *= 25;
	year += day / 1461;
	day %= 1461;
	year *= 4;

	yday = (day < 306);
	if (__predict_false(day == 1460)) {
		year += 3;
		day = 365;
	} else {
		year += day / 365;
		day %= 365;
	}
	yday += day;

	day *= 10;
	month = (day + 5) / 306;
	day = (day + 5) % 306;
	day /= 10;
	if (__predict_false(month >= 10)) {
		yday -= 306;
		++year;
		month -= 10;
	} else {
		yday += 59;
		month += 2;
	}
	if (__predict_false(year < 1))
		--year;

	res.tm_sec = (sec % 60) + leap;
	sec /= 60;
	res.tm_min = (sec % 60);
	res.tm_hour = (sec / 60);
	res.tm_mday = day + 1;
	res.tm_mon = month;
	res.tm_year = year - 1900;
	res.tm_wday = wday;
	res.tm_yday = yday;

	return (res);
}

/* from caldate_mjd libtai-0.60 */
/* hacked up for time_t-64 support */

mjd_t
tm2mjd(struct tm tm)
{
	static unsigned long times365[4] = {
		0, 365, 730, 1095
	};
	static unsigned long times36524[4] = {
		0, 36524UL, 73048UL, 109572UL
	};
	static unsigned long montab[12] = {
		0, 31, 61, 92, 122, 153, 184, 214, 245, 275, 306, 337
	};
	/* month length after february is (306 * m + 5) / 10 */

	time_t d = tm.tm_year + 1900LL;
	int m = tm.tm_mon;
	int y;
	mjd_t res;

	if (__predict_false(d < 0))
		++d;
	y = (int)(d % 400LL);
	d = 146097LL * (d / 400) + tm.tm_mday - 678882LL;
	res.sec = tm.tm_sec + 60 * tm.tm_min + 3600 * tm.tm_hour
	    - tm.tm_gmtoff;

	while (__predict_false(res.sec < 0L)) {
		res.sec += 86400L;
		--d;
	}
	while (__predict_false(res.sec > 86400L)) {
		res.sec -= 86400L;
		++d;
	}

	if (m >= 2) {
		m -= 2;
	} else {
		m += 10;
		--y;
	}

	y += (m / 12);
	m %= 12;
	if (__predict_false(m < 0)) {
		m += 12;
		--y;
	}
	d += montab[m];

	d += 146097LL * (y / 400LL);
	y %= 400;
	while (__predict_false(y < 0)) {
		y += 400;
		d -= 146097LL;
	}

	d += times365[y & 3];
	y /= 4;

	d += 1461LL * (y % 25);
	y /= 25;

	res.mjd = d + times36524[y & 3];

	return (res);
}
@


1.9
log
@* [uninitialised local variable] plus
  [assignment of (variable plus constant) to local variable]
  is faster than
  [initialised local variable to constant] plus
  [increment of local variable with variable]
* shave another local variable off a function
@
text
@d1 1
a1 1
/* $MirOS: src/lib/libc/time/taitime.c,v 1.8 2006/12/20 17:09:42 tg Exp $ */
d34 1
a34 1
__RCSID("$MirOS: src/lib/libc/time/taitime.c,v 1.8 2006/12/20 17:09:42 tg Exp $");
@


1.8
log
@* with gcc, use a statement-expression macro instead of a
  static inline function for _tai_leaps() to make sure the
  code is always inlined [it's time critical]
* add a comment about uses of tai2timet and timet2tai in this file
@
text
@d1 1
a1 1
/* $MirOS: src/share/misc/licence.template,v 1.20 2006/12/11 21:04:56 tg Rel $ */
d34 1
a34 1
__RCSID("$MirOS: src/lib/libc/time/taitime.c,v 1.7 2006/11/01 20:01:21 tg Exp $");
d72 1
a73 1
	register int64_t t = __TAI64_BIAS;
d81 1
a81 1
	t += tv.tv_sec;
a169 1
	tai64_t i = timet2tai(leap);
d173 1
a173 1
	*t++ = i;
@


1.7
log
@sync licences, minor wcwidth KNF
@
text
@d1 1
a1 1
/* $MirOS: src/lib/libc/time/taitime.c,v 1.6 2006/06/12 21:50:11 tg Exp $ */
d9 5
a13 6
 * Licensee is hereby permitted to deal in this work without restric-
 * tion, including unlimited rights to use, publicly perform, modify,
 * merge, distribute, sell, give away or sublicence, provided all co-
 * pyright notices above, these terms and the disclaimer are retained
 * in all redistributions or reproduced in accompanying documentation
 * or other materials provided with binary redistributions.
d19 8
a26 8
 * Licensor offers the work "AS IS" and WITHOUT WARRANTY of any kind,
 * express, or implied, to the maximum extent permitted by applicable
 * law, without malicious intent or gross negligence; in no event may
 * licensor, an author or contributor be held liable for any indirect
 * or other damage, or direct damage except proven a consequence of a
 * direct error of said person and intended use of this work, loss or
 * other issues arising in any way out of its use, even if advised of
 * the possibility of such damage or existence of a defect.
d34 5
a38 1
__RCSID("$MirOS: src/lib/libc/time/taitime.c,v 1.6 2006/06/12 21:50:11 tg Exp $");
d42 4
d47 21
a165 4
tai64_t _leaps[TZ_MAX_LEAPS + 1] = {0};
int _leaps_initialised = 0;

/* private interface */
a177 13
/* private interface */
static __inline tai64_t *
_tai_leaps(void)
{
	extern void _initialise_leaps(void);

	if (__predict_false(!_leaps_initialised)) {
		_leaps_initialised = 1;
		_initialise_leaps();
	}
	return (_leaps);
}

d200 2
@


1.6
log
@whitespace
@
text
@d1 1
a1 1
/* $MirOS: src/lib/libc/time/taitime.c,v 1.5 2006/06/12 21:41:31 tg Exp $ */
d6 2
a7 1
 * Based upon code placed into the public domain by Dan J. Bernstein.
d16 2
a17 2
 * All advertising materials mentioning features or use of this soft-
 * ware must display the following acknowledgement:
d27 1
a27 1
 * the possibility of such damage or existence of a nontrivial bug.
d35 1
a35 1
__RCSID("$MirOS: src/lib/libc/time/taitime.c,v 1.5 2006/06/12 21:41:31 tg Exp $");
@


1.5
log
@KNF, optimise
@
text
@d1 1
a1 1
/* $MirOS: src/share/misc/licence.template,v 1.7 2006/04/09 22:08:49 tg Rel $ */
d34 1
a34 1
__RCSID("$MirOS: src/lib/libc/time/taitime.c,v 1.4 2006/06/02 02:29:56 tg Exp $");
a72 1

a106 1

a135 1

@


1.4
log
@__CRAZY cleanliness for most of libc
not: net/rpc/etc., time, thread, sys
@
text
@d1 1
a1 1
/* $MirOS: src/lib/libc/time/taitime.c,v 1.3 2005/12/17 05:46:16 tg Exp $ */
d4 3
a6 2
 * Copyright (c) 2004, 2005
 *	Thorsten "mirabile" Glaser <tg@@66h.42h.de>
d34 1
a34 1
__RCSID("$MirOS: src/lib/libc/time/taitime.c,v 1.3 2005/12/17 05:46:16 tg Exp $");
d36 2
a39 1

d56 1
a56 1
	return t;
d75 1
a75 1
exporttai(u_int8_t *dst, tai64na_t *src)
d78 4
a81 4
		u_int64_t secs;
		u_int32_t nano;
		u_int32_t atto;
	}     *target = (void *)dst;
d92 1
a92 1
importtai(u_int8_t *src, tai64na_t *dst)
d95 4
a98 4
		u_int64_t secs;
		u_int32_t nano;
		u_int32_t atto;
	}     *source = (void *)src;
d115 6
a120 8
	if (__predict_false(u < 0))
		return t;

	while (__predict_true((*s) && (t >= *s))) {
		++t;
		++s;
	}
	return t;
d135 1
a135 1
	return u;
a143 1
void _pushleap(time_t);
d166 1
a166 1
	return _leaps;
d172 1
a172 1
	return _tai_leaps();
d183 1
a183 1
			return 1;
d185 1
a185 1
			return 0;
d188 1
a188 1
	return 0;
d192 1
a192 1
#ifndef timet2tai
d196 3
a198 3
	return (((u_int64_t)x < 0x4000000000000000ULL)
	    ? ((tai64_t)((u_int64_t)x + __TAI64_BIAS))
	    : (((u_int64_t)x < 0x8000000000000000ULL)
d200 1
a200 1
	    : (((u_int64_t)x < 0xC000000000000000ULL)
d202 1
a202 1
	    : ((tai64_t)((u_int64_t)x + __TAI64_BIAS)))));
a203 1
#endif
d206 1
a206 1
#ifndef tai2timet
d210 1
a210 1
	return (((u_int64_t)x & 0x8000000000000000ULL)
d212 1
a212 1
	    : ((u_int64_t)x - __TAI64_BIAS));
a213 1
#endif
d226 1
a226 1
	return t;
d246 1
a246 1
	return m;
d264 1
a264 1
	memset(&res, 0, sizeof(res));
d279 1
a279 2
	leap = (sec == 86400);
	if (__predict_false(leap))
d332 1
a332 3
	res.tm_sec = (sec % 60);
	if (__predict_false(leap))
		++res.tm_sec;
d342 1
a342 1
	return res;
a364 1
	long sec;
d371 2
a372 1
	sec = tm.tm_sec - tm.tm_gmtoff + 60 * (tm.tm_min + 60 * tm.tm_hour);
d374 2
a375 2
	while (__predict_false(sec < 0L)) {
		sec += 86400L;
d378 2
a379 2
	while (__predict_false(sec > 86400L)) {
		sec -= 86400L;
d411 1
a411 4
	d += times36524[y & 3];

	res.mjd = d;
	res.sec = (int32_t)sec;
d413 1
a413 1
	return res;
@


1.3
log
@big fat licence update (I left some which are bsiegert@@'s alone though)
also, remove licence boilerplate from some .h files who don't deserve it
and remove and add some advertising clauses because I say so
@
text
@d1 1
a1 1
/* $MirOS: src/lib/libc/time/taitime.c,v 1.2 2005/04/17 01:36:06 tg Exp $ */
d33 1
a33 1
__RCSID("$MirOS: src/lib/libc/time/taitime.c,v 1.2 2005/04/17 01:36:06 tg Exp $");
d144 1
@


1.2
log
@here, lint found an actual error (thinko? typo?)
I hope this is the correct fix
@
text
@d1 1
a1 1
/* $MirOS: src/lib/libc/time/taitime.c,v 1.1.7.1 2005/03/06 16:33:39 tg Exp $ */
d18 8
a25 7
 * Licensor hereby provides this work "AS IS" and WITHOUT WARRANTY of
 * any kind, expressed or implied, to the maximum extent permitted by
 * applicable law, but with the warranty of being written without ma-
 * licious intent or gross negligence; in no event shall licensor, an
 * author or contributor be held liable for any damage, direct, indi-
 * rect or other, however caused, arising in any way out of the usage
 * of this work, even if advised of the possibility of such damage.
d33 1
a33 1
__RCSID("$MirOS: src/lib/libc/time/taitime.c,v 1.1.7.1 2005/03/06 16:33:39 tg Exp $");
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $MirOS: src/share/misc/licence.template,v 1.2 2005/03/03 19:43:30 tg Rel $ */
d32 1
a32 1
__RCSID("$MirOS$");
d112 1
a112 1
	if (__predict_false(s < 0))
@


1.1.7.1
log
@Add some missing files, such as some ISDN4BSD stuff,
documentation, tmac and tab files, TAI64 etc.
@
text
@@
