head	1.18;
access;
symbols
	MIRBSD_10:1.13.0.2
	MIRBSD_10_BASE:1.13
	MIRBSD_9_BASE:1.10
	MIRBSD_8:1.10.0.2
	MIRBSD_8_BASE:1.10
	cvs-200509212000:1.1.1.3
	cvs-200507211800:1.1.1.2
	cvs-200504170300:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2011.11.20.21.30.56;	author tg;	state Exp;
branches;
next	1.17;
commitid	1004EC971A1401F3127;

1.17
date	2011.11.20.04.57.12;	author tg;	state Exp;
branches;
next	1.16;
commitid	1004EC8880406A80564;

1.16
date	2009.11.09.21.30.56;	author tg;	state Exp;
branches;
next	1.15;
commitid	1004AF88A0F18F30769;

1.15
date	2008.04.05.21.53.57;	author tg;	state Exp;
branches;
next	1.14;
commitid	10047F7F4F0613A5C38;

1.14
date	2008.04.05.21.26.17;	author tg;	state Exp;
branches;
next	1.13;
commitid	10047F7EE6E0E8D01ED;

1.13
date	2007.02.07.21.08.20;	author tg;	state Exp;
branches;
next	1.12;
commitid	10045CA3FC2477ABB3D;

1.12
date	2007.02.07.20.43.24;	author tg;	state Exp;
branches;
next	1.11;
commitid	10045CA39907FBE4A06;

1.11
date	2006.11.01.20.01.21;	author tg;	state Exp;
branches;
next	1.10;
commitid	1004548FD236EA4946C;

1.10
date	2005.12.18.16.36.53;	author tg;	state Exp;
branches;
next	1.9;
commitid	10043A58BE830AFB807;

1.9
date	2005.12.18.01.04.32;	author tg;	state Exp;
branches;
next	1.8;
commitid	10043A4B57E7825132D;

1.8
date	2005.12.17.05.46.15;	author tg;	state Exp;
branches;
next	1.7;
commitid	10043A3A3E65E20A413;

1.7
date	2005.10.20.12.46.28;	author tg;	state Exp;
branches;
next	1.6;
commitid	19ed435791aa5678;

1.6
date	2005.09.22.20.33.01;	author tg;	state Exp;
branches;
next	1.5;
commitid	678e43331511a1e1;

1.5
date	2005.03.29.16.53.46;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2005.03.29.16.50.32;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2005.03.28.21.21.50;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.06.20.28.50;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.25.01;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.25.01;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.07.21.20.53.26;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	560042e0092f571e;

1.1.1.3
date	2005.09.21.20.34.32;	author tg;	state Exp;
branches;
next	;
commitid	20cd4331c3c732a2;


desc
@@


1.18
log
@finish implementation
@
text
@/*-
 * Copyright (c) 2004, 2005, 2007, 2011
 *	Thorsten Glaser <tg@@mirbsd.org>
 * Based upon work placed in the public domain 1996-06-05 by
 *	Arthur David Olson (arthur_david_olson@@nih.gov)
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 */

#include <sys/param.h>

__SCCSID("@@(#)localtime.c	7.80");
__RCSID("$MirOS: src/lib/libc/time/localtime.c,v 1.17 2011/11/20 04:57:12 tg Exp $");

struct tm *offtime(const time_t * const, const long);

/*
** Leap second handling from Bradley White (bww@@k.gp.cs.cmu.edu).
** POSIX-style TZ environment variable handling from Guy Harris
** (guy@@auspex.com).
*/

/* LINTLIBRARY */

#include <syskern/mirtime.h>
#include "private.h"
#include "tzfile.h"
#include "fcntl.h"
#include "float.h"	/* for FLT_MAX and DBL_MAX */
#include "thread_private.h"

#ifndef TZ_ABBR_MAX_LEN
#define TZ_ABBR_MAX_LEN	16
#endif /* !defined TZ_ABBR_MAX_LEN */

#ifndef TZ_ABBR_CHAR_SET
#define TZ_ABBR_CHAR_SET \
	"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 :+-._"
#endif /* !defined TZ_ABBR_CHAR_SET */

#ifndef TZ_ABBR_ERR_CHAR
#define TZ_ABBR_ERR_CHAR	'_'
#endif /* !defined TZ_ABBR_ERR_CHAR */

/*
** SunOS 4.1.1 headers lack O_BINARY.
*/

#ifdef O_BINARY
#define OPEN_MODE	(O_RDONLY | O_BINARY)
#else
#define OPEN_MODE	O_RDONLY
#endif

#ifndef WILDABBR
/*
** Someone might make incorrect use of a time zone abbreviation:
**	1.	They might reference tzname[0] before calling tzset (explicitly
**		or implicitly).
**	2.	They might reference tzname[1] before calling tzset (explicitly
**		or implicitly).
**	3.	They might reference tzname[1] after setting to a time zone
**		in which Daylight Saving Time is never observed.
**	4.	They might reference tzname[0] after setting to a time zone
**		in which Standard Time is never observed.
**	5.	They might reference tm.TM_ZONE after calling offtime.
** What's best to do in the above cases is open to debate;
** for now, we just set things up so that in any of the five cases
** WILDABBR is used. Another possibility: initialize tzname[0] to the
** string "tzname[0] used before set", and similarly for the other cases.
** And another: initialize tzname[0] to "ERA", with an explanation in the
** manual page of what this "time zone abbreviation" means (doing this so
** that tzname[0] has the "normal" length of three characters).
*/
#define WILDABBR	"   "
#endif

static char wildabbr[] = WILDABBR;
static const char gmt[] = "UTC";

/*
** The DST rules to use if TZ has no rules and we can't load TZDEFRULES.
** We default to US rules as of 1999-08-17.
** POSIX 1003.1 section 8.1.1 says that the default DST rules are
** implementation dependent; for historical reasons, US rules are a
** common default.
*/
#ifndef TZDEFRULESTRING
#define TZDEFRULESTRING ",M4.1.0,M10.5.0"
#endif

struct ttinfo {				/* time type information */
	long tt_gmtoff;			/* UTC offset in seconds */
	int tt_isdst;			/* used to set tm_isdst */
	int tt_abbrind;			/* abbreviation list index */
	int tt_ttisstd;			/* TRUE if transition is std time */
	int tt_ttisgmt;			/* TRUE if transition is UTC */
};

struct lsinfo {				/* leap second information */
	time_t ls_trans;		/* transition time */
	long ls_corr;			/* correction to apply */
};

#ifdef TZNAME_MAX
#define MY_TZNAME_MAX	TZNAME_MAX
#else
#define MY_TZNAME_MAX	255
#endif

struct state {
	int leapcnt;
	int timecnt;
	int typecnt;
	int charcnt;
	time_t ats[TZ_MAX_TIMES];
	unsigned char types[TZ_MAX_TIMES];
	struct ttinfo ttis[TZ_MAX_TYPES];
	/* CONSTCOND */
	char chars[MAX(MAX(TZ_MAX_CHARS + 1, sizeof gmt),
	         (2 * (MY_TZNAME_MAX + 1)))];
	struct lsinfo lsis[TZ_MAX_LEAPS];
};

struct rule {
	int r_type;			/* type of rule--see below */
	int r_day;			/* day number of rule */
	int r_week;			/* week number of rule */
	int r_mon;			/* month number of rule */
	long r_time;			/* transition time of rule */
};

#define JULIAN_DAY		0	/* Jn - Julian day */
#define DAY_OF_YEAR		1	/* n - day of year */
#define MONTH_NTH_DAY_OF_WEEK	2	/* Mm.n.d - month, week, day of week */

/*
** Prototypes for static functions.
*/

static long detzcode(const char *codep);
static const char *getzname(const char *strp);
static const char *getqzname(const char * strp, const char delim);
static const char *getnum(const char *strp, int *nump, int min, int max);
static const char *getsecs(const char *strp, long *secsp);
static const char *getoffset(const char *strp, long *offsetp);
static const char *getrule(const char *strp, struct rule *rulep);
static void gmtload(struct state *sp);
static struct tm *gmtsub(const time_t *timep, long offset, struct tm *tmp);
static struct tm *localsub(const time_t *timep, long offset, struct tm *tmp);
static int increment_overflow(int *number, int delta);
static int leaps_thru_end_of(int y);
static int long_increment_overflow(time_t *number, time_t delta);
static int long_normalize_overflow(time_t *tensptr, int *unitsptr, int base);
static int normalize_overflow(int *tensptr, int *unitsptr, int base);
static void settzname(void);
static time_t time1(struct tm *tmp, struct tm *(*funcp) (const time_t *, long, struct tm *), long offset);
static time_t time2(struct tm *tmp, struct tm *(*funcp) (const time_t *, long, struct tm *), long offset, int *okayp);
static time_t time2sub(struct tm *tmp, struct tm *(*funcp) (const time_t *, long, struct tm *), long offset, int *okayp, int do_norm_secs);
static struct tm *timesub(const time_t *timep, long offset, const struct state *sp, struct tm *tmp);
static int tmcomp(const struct tm *atmp, const struct tm *btmp);
static time_t transtime(time_t janfirst, int year, const struct rule *rulep, long offset);
static int tzload(const char *name, struct state *sp);
static int tzparse(const char *name, struct state *sp, int lastditch);

static struct state lclmem;
static struct state gmtmem;
#define lclptr		(&lclmem)
#define gmtptr		(&gmtmem)

#ifndef TZ_STRLEN_MAX
#define TZ_STRLEN_MAX 255
#endif

static char lcl_TZname[TZ_STRLEN_MAX + 1];
static int lcl_is_set;
static int gmt_is_set;
_THREAD_PRIVATE_MUTEX(lcl);
_THREAD_PRIVATE_MUTEX(gmt);

char *tzname[2] = {
	wildabbr,
	wildabbr
};

/*
** Section 4.12.3 of X3.159-1989 requires that
**	Except for the strftime function, these functions [asctime,
**	ctime, gmtime, localtime] return values in one of two static
**	objects: a broken-down time structure and an array of char.
** Thanks to Paul Eggert (eggert@@twinsun.com) for noting this.
*/

static struct tm tm;

static long
detzcode(codep)
	const char *const codep;
{
	long result;
	int i;

	result = (codep[0] & 0x80) ? ~0L : 0L;
	for (i = 0; i < 4; ++i)
		result = (result << 8) | (codep[i] & 0xff);
	return result;
}

static void
settzname(void)
{
	struct state *const sp = lclptr;
	int i;

	tzname[0] = wildabbr;
	tzname[1] = wildabbr;
	for (i = 0; i < sp->typecnt; ++i) {
		const struct ttinfo *const ttisp = &sp->ttis[i];

		tzname[ttisp->tt_isdst] =
		    &sp->chars[ttisp->tt_abbrind];
	}
	/*
	** And to get the latest zone names into tzname. . .
	*/
	for (i = 0; i < sp->timecnt; ++i) {
		const struct ttinfo *const ttisp =
		&sp->ttis[
		    sp->types[i]];

		tzname[ttisp->tt_isdst] =
		    &sp->chars[ttisp->tt_abbrind];
	}
	/*
	** Finally, scrub the abbreviations.
	** First, replace bogus characters.
	*/
	for (i = 0; i < sp->charcnt; ++i)
		if (strchr(TZ_ABBR_CHAR_SET, sp->chars[i]) == NULL)
			sp->chars[i] = TZ_ABBR_ERR_CHAR;
	/*
	** Second, truncate long abbreviations.
	*/
	for (i = 0; i < sp->typecnt; ++i) {
		register const struct ttinfo * const	ttisp = &sp->ttis[i];
		register char *				cp = &sp->chars[ttisp->tt_abbrind];

		if (strlen(cp) > TZ_ABBR_MAX_LEN &&
			strcmp(cp, GRANDPARENTED) != 0)
				*(cp + TZ_ABBR_MAX_LEN) = '\0';
	}
}

static int
tzload(name, sp)
	const char *name;
	struct state *const sp;
{
	const char *p;
	int i;
	int fid;

	if (name != NULL && issetugid() != 0)
		if ((name[0] == ':' && (strchr(name, '/') || strstr(name, ".."))) ||
		    name[0] == '/' || strchr(name, '.'))
			name = NULL;
	if (name == NULL && (name = TZDEFAULT) == NULL)
		return -1;
	{
		int doaccess;
		/*
		** Section 4.9.1 of the C standard says that
		** "FILENAME_MAX expands to an integral constant expression
		** that is the size needed for an array of char large enough
		** to hold the longest file name string that the implementation
		** guarantees can be opened."
		*/
		char fullname[FILENAME_MAX];

		if (name[0] == ':')
			++name;
		doaccess = name[0] == '/';
		if (!doaccess) {
			if ((p = TZDIR) == NULL)
				return -1;
			if ((strlen(p) + strlen(name) + 1) >= sizeof fullname)
				return -1;
			(void)strlcpy(fullname, p, sizeof fullname);
			(void)strlcat(fullname, "/", sizeof fullname);
			(void)strlcat(fullname, name, sizeof fullname);
			/*
			** Set doaccess if '.' (as in "../") shows up in name.
			*/
			if (strchr(name, '.') != NULL)
				doaccess = TRUE;
			name = fullname;
		}
		if (doaccess && access(name, R_OK) != 0)
			return -1;
		if ((fid = open(name, OPEN_MODE)) == -1)
			return -1;
	}
	{
		struct tzhead *tzhp;
		union {
			struct tzhead tzhead;
			char buf[sizeof *sp + sizeof *tzhp];
		}     u;
		int ttisstdcnt;
		int ttisgmtcnt;

		i = read(fid, u.buf, sizeof u.buf);
		if (close(fid) != 0)
			return -1;
		ttisstdcnt = (int)detzcode(u.tzhead.tzh_ttisstdcnt);
		ttisgmtcnt = (int)detzcode(u.tzhead.tzh_ttisgmtcnt);
		sp->leapcnt = (int)detzcode(u.tzhead.tzh_leapcnt);
		sp->timecnt = (int)detzcode(u.tzhead.tzh_timecnt);
		sp->typecnt = (int)detzcode(u.tzhead.tzh_typecnt);
		sp->charcnt = (int)detzcode(u.tzhead.tzh_charcnt);
		p = u.tzhead.tzh_charcnt + sizeof u.tzhead.tzh_charcnt;
		if (sp->leapcnt < 0 || sp->leapcnt > TZ_MAX_LEAPS ||
		    sp->typecnt <= 0 || sp->typecnt > TZ_MAX_TYPES ||
		    sp->timecnt < 0 || sp->timecnt > TZ_MAX_TIMES ||
		    sp->charcnt < 0 || sp->charcnt > TZ_MAX_CHARS ||
		    (ttisstdcnt != sp->typecnt && ttisstdcnt != 0) ||
		    (ttisgmtcnt != sp->typecnt && ttisgmtcnt != 0))
			return -1;
		if (i - (p - u.buf)<sp->timecnt * 4 +	/* ats */
		    sp->timecnt +	/* types */
		    sp->typecnt * (4 + 2) +	/* ttinfos */
		    sp->charcnt +	/* chars */
		    sp->leapcnt * (4 + 4) +	/* lsinfos */
		    ttisstdcnt +	/* ttisstds */
		    ttisgmtcnt)		/* ttisgmts */
			return -1;
		for (i = 0; i < sp->timecnt; ++i) {
			sp->ats[i] = detzcode(p);
			p += 4;
		}
		for (i = 0; i < sp->timecnt; ++i) {
			sp->types[i] = (unsigned char)*p++;
			if (sp->types[i] >= sp->typecnt)
				return -1;
		}
		for (i = 0; i < sp->typecnt; ++i) {
			struct ttinfo *ttisp;

			ttisp = &sp->ttis[i];
			ttisp->tt_gmtoff = detzcode(p);
			p += 4;
			ttisp->tt_isdst = (unsigned char)*p++;
			if (ttisp->tt_isdst != 0 && ttisp->tt_isdst != 1)
				return -1;
			ttisp->tt_abbrind = (unsigned char)*p++;
			if (ttisp->tt_abbrind < 0 ||
			    ttisp->tt_abbrind > sp->charcnt)
				return -1;
		}
		for (i = 0; i < sp->charcnt; ++i)
			sp->chars[i] = *p++;
		sp->chars[i] = '\0';	/* ensure '\0' at end */
		for (i = 0; i < sp->leapcnt; ++i) {
			struct lsinfo *lsisp;

			lsisp = &sp->lsis[i];
			lsisp->ls_trans = detzcode(p);
			p += 4;
			lsisp->ls_corr = detzcode(p);
			p += 4;
		}
		for (i = 0; i < sp->typecnt; ++i) {
			struct ttinfo *ttisp;

			ttisp = &sp->ttis[i];
			if (ttisstdcnt == 0)
				ttisp->tt_ttisstd = FALSE;
			else {
				ttisp->tt_ttisstd = *p++;
				if (ttisp->tt_ttisstd != TRUE &&
				    ttisp->tt_ttisstd != FALSE)
					return -1;
			}
		}
		for (i = 0; i < sp->typecnt; ++i) {
			struct ttinfo *ttisp;

			ttisp = &sp->ttis[i];
			if (ttisgmtcnt == 0)
				ttisp->tt_ttisgmt = FALSE;
			else {
				ttisp->tt_ttisgmt = *p++;
				if (ttisp->tt_ttisgmt != TRUE &&
				    ttisp->tt_ttisgmt != FALSE)
					return -1;
			}
		}
		/*
		** Out-of-sort ats should mean we're running on a
		** signed time_t system but using a data file with
		** unsigned values (or vice versa).
		*/
		for (i = 0; i < sp->timecnt - 2; ++i)
			if (sp->ats[i] > sp->ats[i + 1]) {
				++i;
				if (TYPE_SIGNED(time_t)) {
					/*
					** Ignore the end (easy).
					*/
					sp->timecnt = i;
				} else {
					/*
					** Ignore the beginning (harder).
					*/
					register int	j;

					for (j = 0; j + i < sp->timecnt; ++j) {
						sp->ats[j] = sp->ats[j + i];
						sp->types[j] = sp->types[j + i];
					}
					sp->timecnt = j;
				}
				break;
			}
	}
#ifdef SKIP_LEAPSECS
	for (i = 0; i < sp->leapcnt; ++i) {
		struct lsinfo *lsisp;

		lsisp = &sp->lsis[i];
		lsisp->ls_trans = 0;
		lsisp->ls_corr = 0;
	}
	sp->leapcnt = 0;
#undef SKIPPED_LEAPSECS
#define SKIPPED_LEAPSECS 1
#endif
	return 0;
}

static const int mon_lengths[2][MONSPERYEAR] = {
	{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
	{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
};

static const int year_lengths[2] = {
	DAYSPERNYEAR, DAYSPERLYEAR
};

/*
** Given a pointer into a time zone string, scan until a character that is not
** a valid character in a zone name is found. Return a pointer to that
** character.
*/

static const char *
getzname(strp)
	const char *strp;
{
	char c;

	while ((c = *strp) != '\0' && !is_digit(c) && c != ',' && c != '-' &&
	    c != '+')
		++strp;
	return strp;
}

/*
** Given a pointer into an extended time zone string, scan until the ending
** delimiter of the zone name is located.   Return a pointer to the delimiter.
**
** As with getzname above, the legal character set is actually quite
** restricted, with other characters producing undefined results.
** We choose not to care - allowing almost anything to be in the zone abbrev.
*/

static const char *
getqzname(strp, delim)
register const char *	strp;
const char		delim;
{
	register char	c;

	while ((c = *strp) != '\0' && c != delim)
		++strp;
	return strp;
}

/*
** Given a pointer into a time zone string, extract a number from that string.
** Check that the number is within a specified range; if it is not, return
** NULL.
** Otherwise, return a pointer to the first character not part of the number.
*/

static const char *
getnum(strp, nump, min, max)
	const char *strp;
	int *const nump;
	const int min;
	const int max;
{
	char c;
	int num;

	if (strp == NULL || !is_digit(c = *strp))
		return NULL;
	num = 0;
	do {
		num = num * 10 + (c - '0');
		if (num > max)
			return NULL;	/* illegal value */
		c = *++strp;
	} while (is_digit(c));
	if (num < min)
		return NULL;		/* illegal value */
	*nump = num;
	return strp;
}

/*
** Given a pointer into a time zone string, extract a number of seconds,
** in hh[:mm[:ss]] form, from the string.
** If any error occurs, return NULL.
** Otherwise, return a pointer to the first character not part of the number
** of seconds.
*/

static const char *
getsecs(strp, secsp)
	const char *strp;
	long *const secsp;
{
	int num;

	/*
	** `HOURSPERDAY * DAYSPERWEEK - 1' allows quasi-Posix rules like
	** "M10.4.6/26", which does not conform to Posix,
	** but which specifies the equivalent of
	** ``02:00 on the first Sunday on or after 23 Oct''.
	*/
	strp = getnum(strp, &num, 0, HOURSPERDAY * DAYSPERWEEK - 1);
	if (strp == NULL)
		return NULL;
	*secsp = num * (long)SECSPERHOUR;
	if (*strp == ':') {
		++strp;
		strp = getnum(strp, &num, 0, MINSPERHOUR - 1);
		if (strp == NULL)
			return NULL;
		*secsp += num * SECSPERMIN;
		if (*strp == ':') {
			++strp;
			/* `SECSPERMIN' allows for leap seconds. */
			strp = getnum(strp, &num, 0, SECSPERMIN);
			if (strp == NULL)
				return NULL;
			*secsp += num;
		}
	}
	return strp;
}

/*
** Given a pointer into a time zone string, extract an offset, in
** [+-]hh[:mm[:ss]] form, from the string.
** If any error occurs, return NULL.
** Otherwise, return a pointer to the first character not part of the time.
*/

static const char *
getoffset(strp, offsetp)
	const char *strp;
	long *const offsetp;
{
	int neg = 0;

	if (*strp == '-') {
		neg = 1;
		++strp;
	} else if (*strp == '+')
		++strp;
	strp = getsecs(strp, offsetp);
	if (strp == NULL)
		return NULL;		/* illegal time */
	if (neg)
		*offsetp = -*offsetp;
	return strp;
}

/*
** Given a pointer into a time zone string, extract a rule in the form
** date[/time]. See POSIX section 8 for the format of "date" and "time".
** If a valid rule is not found, return NULL.
** Otherwise, return a pointer to the first character not part of the rule.
*/

static const char *
getrule(strp, rulep)
	const char *strp;
	struct rule *const rulep;
{
	if (*strp == 'J') {
		/*
		** Julian day.
		*/
		rulep->r_type = JULIAN_DAY;
		++strp;
		strp = getnum(strp, &rulep->r_day, 1, DAYSPERNYEAR);
	} else if (*strp == 'M') {
		/*
		** Month, week, day.
		*/
		rulep->r_type = MONTH_NTH_DAY_OF_WEEK;
		++strp;
		strp = getnum(strp, &rulep->r_mon, 1, MONSPERYEAR);
		if (strp == NULL)
			return NULL;
		if (*strp++ != '.')
			return NULL;
		strp = getnum(strp, &rulep->r_week, 1, 5);
		if (strp == NULL)
			return NULL;
		if (*strp++ != '.')
			return NULL;
		strp = getnum(strp, &rulep->r_day, 0, DAYSPERWEEK - 1);
	} else if (is_digit(*strp)) {
		/*
		** Day of year.
		*/
		rulep->r_type = DAY_OF_YEAR;
		strp = getnum(strp, &rulep->r_day, 0, DAYSPERLYEAR - 1);
	} else
		return NULL;		/* invalid format */
	if (strp == NULL)
		return NULL;
	if (*strp == '/') {
		/*
		** Time specified.
		*/
		++strp;
		strp = getsecs(strp, &rulep->r_time);
	} else
		rulep->r_time = 2 * SECSPERHOUR;	/* default = 2:00:00 */
	return strp;
}

/*
** Given the Epoch-relative time of January 1, 00:00:00 UTC, in a year, the
** year, a rule, and the offset from UTC at the time that rule takes effect,
** calculate the Epoch-relative time that rule takes effect.
*/

static time_t
transtime(janfirst, year, rulep, offset)
	const time_t janfirst;
	const int year;
	const struct rule *const rulep;
	const long offset;
{
	int leapyear;
	time_t value;
	int i;
	int d, m1, yy0, yy1, yy2, dow;

	INITIALIZE(value);
	leapyear = isleap(year);
	switch (rulep->r_type) {

	case JULIAN_DAY:
		/*
		** Jn - Julian day, 1 == January 1, 60 == March 1 even in leap
		** years.
		** In non-leap years, or if the day number is 59 or less, just
		** add SECSPERDAY times the day number-1 to the time of
		** January 1, midnight, to get the day.
		*/
		value = janfirst + (rulep->r_day - 1) * SECSPERDAY;
		if (leapyear && rulep->r_day >= 60)
			value += SECSPERDAY;
		break;

	case DAY_OF_YEAR:
		/*
		** n - day of year.
		** Just add SECSPERDAY times the day number to the time of
		** January 1, midnight, to get the day.
		*/
		value = janfirst + rulep->r_day * SECSPERDAY;
		break;

	case MONTH_NTH_DAY_OF_WEEK:
		/*
		** Mm.n.d - nth "dth day" of month m.
		*/
		value = janfirst;
		for (i = 0; i < rulep->r_mon - 1; ++i)
			value += mon_lengths[leapyear][i] * SECSPERDAY;

		/*
		** Use Zeller's Congruence to get day-of-week of first day of
		** month.
		*/
		m1 = (rulep->r_mon + 9) % 12 + 1;
		yy0 = (rulep->r_mon <= 2) ? (year - 1) : year;
		yy1 = yy0 / 100;
		yy2 = yy0 % 100;
		dow = ((26 * m1 - 2) / 10 +
		    1 + yy2 + yy2 / 4 + yy1 / 4 - 2 * yy1) % 7;
		if (dow < 0)
			dow += DAYSPERWEEK;

		/*
		** "dow" is the day-of-week of the first day of the month. Get
		** the day-of-month (zero-origin) of the first "dow" day of the
		** month.
		*/
		d = rulep->r_day - dow;
		if (d < 0)
			d += DAYSPERWEEK;
		for (i = 1; i < rulep->r_week; ++i) {
			if (d + DAYSPERWEEK >=
			    mon_lengths[leapyear][rulep->r_mon - 1])
				break;
			d += DAYSPERWEEK;
		}

		/*
		** "d" is the day-of-month (zero-origin) of the day we want.
		*/
		value += d * SECSPERDAY;
		break;
	}

	/*
	** "value" is the Epoch-relative time of 00:00:00 UTC on the day in
	** question. To get the Epoch-relative time of the specified local
	** time on that day, add the transition time and the current offset
	** from UTC.
	*/
	return value + rulep->r_time + offset;
}

/*
** Given a POSIX section 8-style TZ string, fill in the rule tables as
** appropriate.
*/

static int
tzparse(name, sp, lastditch)
	const char *name;
	struct state *const sp;
	const int lastditch;
{
	const char *stdname;
	const char *dstname;
	size_t stdlen;
	size_t dstlen;
	long stdoffset;
	long dstoffset;
	time_t *atp;
	unsigned char *typep;
	char *cp;
	int load_result;

	INITIALIZE(dstname);
	stdname = name;
	if (lastditch) {
		stdlen = strlen(name);	/* length of standard zone name */
		name += stdlen;
		if (stdlen >= sizeof sp->chars)
			stdlen = (sizeof sp->chars) - 1;
		stdoffset = 0;
	} else {
		if (*name == '<') {
			name++;
			stdname = name;
			name = getqzname(name, '>');
			if (*name != '>')
				return (-1);
			stdlen = name - stdname;
			name++;
		} else {
			name = getzname(name);
			stdlen = name - stdname;
		}
		if (*name == '\0')
			return -1;
		name = getoffset(name, &stdoffset);
		if (name == NULL)
			return -1;
	}
	load_result = tzload(TZDEFRULES, sp);
	if (load_result != 0)
		sp->leapcnt = 0;	/* so, we're off a little */
	if (*name != '\0') {
		if (*name == '<') {
			dstname = ++name;
			name = getqzname(name, '>');
			if (*name != '>')
				return -1;
			dstlen = name - dstname;
			name++;
		} else {
			dstname = name;
			name = getzname(name);
			dstlen = name - dstname; /* length of DST zone name */
		}
		if (*name != '\0' && *name != ',' && *name != ';') {
			name = getoffset(name, &dstoffset);
			if (name == NULL)
				return -1;
		} else
			dstoffset = stdoffset - SECSPERHOUR;
		if (*name == '\0' && load_result != 0)
			name = TZDEFRULESTRING;
		if (*name == ',' || *name == ';') {
			struct rule start;
			struct rule end;
			int year;
			time_t janfirst;
			time_t starttime;
			time_t endtime;

			++name;
			if ((name = getrule(name, &start)) == NULL)
				return -1;
			if (*name++ != ',')
				return -1;
			if ((name = getrule(name, &end)) == NULL)
				return -1;
			if (*name != '\0')
				return -1;
			sp->typecnt = 2;/* standard time and DST */
			/*
			** Two transitions per year, from EPOCH_YEAR to 2037.
			*/
			sp->timecnt = 2 * (2037 - EPOCH_YEAR + 1);
			if (sp->timecnt > TZ_MAX_TIMES)
				return -1;
			sp->ttis[0].tt_gmtoff = -dstoffset;
			sp->ttis[0].tt_isdst = 1;
			sp->ttis[0].tt_abbrind = stdlen + 1;
			sp->ttis[1].tt_gmtoff = -stdoffset;
			sp->ttis[1].tt_isdst = 0;
			sp->ttis[1].tt_abbrind = 0;
			atp = sp->ats;
			typep = sp->types;
			janfirst = 0;
			for (year = EPOCH_YEAR; year <= 2037; ++year) {
				starttime = transtime(janfirst, year, &start,
				    stdoffset);
				endtime = transtime(janfirst, year, &end,
				    dstoffset);
				if (starttime > endtime) {
					*atp++ = endtime;
					*typep++ = 1;	/* DST ends */
					*atp++ = starttime;
					*typep++ = 0;	/* DST begins */
				} else {
					*atp++ = starttime;
					*typep++ = 0;	/* DST begins */
					*atp++ = endtime;
					*typep++ = 1;	/* DST ends */
				}
				janfirst += year_lengths[isleap(year)] *
				    SECSPERDAY;
			}
		} else {
			long theirstdoffset;
			long theirdstoffset;
			long theiroffset;
			int isdst;
			int i;
			int j;

			if (*name != '\0')
				return -1;
			/*
			** Initial values of theirstdoffset and theirdstoffset.
			*/
			theirstdoffset = 0;
			for (i = 0; i < sp->timecnt; ++i) {
				j = sp->types[i];
				if (!sp->ttis[j].tt_isdst) {
					theirstdoffset =
					    -sp->ttis[j].tt_gmtoff;
					break;
				}
			}
			theirdstoffset = 0;
			for (i = 0; i < sp->timecnt; ++i) {
				j = sp->types[i];
				if (sp->ttis[j].tt_isdst) {
					theirdstoffset =
					    -sp->ttis[j].tt_gmtoff;
					break;
				}
			}
			/*
			** Initially we're assumed to be in standard time.
			*/
			isdst = FALSE;
			theiroffset = theirstdoffset;
			/*
			** Now juggle transition times and types
			** tracking offsets as you do.
			*/
			for (i = 0; i < sp->timecnt; ++i) {
				j = sp->types[i];
				sp->types[i] = sp->ttis[j].tt_isdst;
				if (sp->ttis[j].tt_ttisgmt) {
					/* No adjustment to transition time */
				} else {
					/*
					** If summer time is in effect, and the
					** transition time was not specified as
					** standard time, add the summer time
					** offset to the transition time;
					** otherwise, add the standard time
					** offset to the transition time.
					*/
					/*
					** Transitions from DST to DDST
					** will effectively disappear since
					** POSIX provides for only one DST
					** offset.
					*/
					if (isdst && !sp->ttis[j].tt_ttisstd) {
						sp->ats[i] += dstoffset -
						    theirdstoffset;
					} else {
						sp->ats[i] += stdoffset -
						    theirstdoffset;
					}
				}
				theiroffset = -sp->ttis[j].tt_gmtoff;
				if (sp->ttis[j].tt_isdst)
					theirdstoffset = theiroffset;
				else
					theirstdoffset = theiroffset;
			}
			/*
			** Finally, fill in ttis.
			** ttisstd and ttisgmt need not be handled.
			*/
			sp->ttis[0].tt_gmtoff = -stdoffset;
			sp->ttis[0].tt_isdst = FALSE;
			sp->ttis[0].tt_abbrind = 0;
			sp->ttis[1].tt_gmtoff = -dstoffset;
			sp->ttis[1].tt_isdst = TRUE;
			sp->ttis[1].tt_abbrind = stdlen + 1;
			sp->typecnt = 2;
		}
	} else {
		dstlen = 0;
		sp->typecnt = 1;	/* only standard time */
		sp->timecnt = 0;
		sp->ttis[0].tt_gmtoff = -stdoffset;
		sp->ttis[0].tt_isdst = 0;
		sp->ttis[0].tt_abbrind = 0;
	}
	sp->charcnt = stdlen + 1;
	if (dstlen != 0)
		sp->charcnt += dstlen + 1;
	if ((size_t)sp->charcnt > sizeof sp->chars)
		return -1;
	cp = sp->chars;
	strlcpy(cp, stdname, stdlen + 1);
	cp += stdlen + 1;
	if (dstlen != 0) {
		strlcpy(cp, dstname, dstlen + 1);
	}
	return 0;
}

static void
gmtload(sp)
	struct state *const sp;
{
	if (tzload(gmt, sp) != 0)
		(void)tzparse(gmt, sp, TRUE);
}
static
void
tzsetwall_basic(void)
{
	if (lcl_is_set < 0)
		return;
	lcl_is_set = -1;

	if (tzload((char *)NULL, lclptr) != 0)
		gmtload(lclptr);
	settzname();
}

void
tzsetwall(void)
{
	_THREAD_PRIVATE_MUTEX_LOCK(lcl);
	tzsetwall_basic();
	_THREAD_PRIVATE_MUTEX_UNLOCK(lcl);
}

static
void
tzset_basic(void)
{
	const char *name;

	name = getenv("TZ");
	if (name == NULL) {
		tzsetwall_basic();
		return;
	}
	if (lcl_is_set > 0 && strcmp(lcl_TZname, name) == 0)
		return;
	lcl_is_set = strlen(name) < sizeof lcl_TZname;
	if (lcl_is_set)
		(void)strlcpy(lcl_TZname, name, sizeof lcl_TZname);

	if (*name == '\0') {
		/*
		** User wants it fast rather than right.
		*/
		lclptr->leapcnt = 0;	/* so, we're off a little */
		lclptr->timecnt = 0;
		lclptr->typecnt = 0;
		lclptr->ttis[0].tt_isdst = 0;
		lclptr->ttis[0].tt_gmtoff = 0;
		lclptr->ttis[0].tt_abbrind = 0;
		(void)strlcpy(lclptr->chars, gmt, sizeof lclptr->chars);
	} else if (tzload(name, lclptr) != 0)
		if (name[0] == ':' || tzparse(name, lclptr, FALSE) != 0)
			(void)gmtload(lclptr);
	settzname();
}

void
tzset(void)
{
	_THREAD_PRIVATE_MUTEX_LOCK(lcl);
	tzset_basic();
	_THREAD_PRIVATE_MUTEX_UNLOCK(lcl);
	mirtime_getleaps();
}

/*
** The easy way to behave "as if no library function calls" localtime
** is to not call it--so we drop its guts into "localsub", which can be
** freely called. (And no, the PANS doesn't require the above behavior--
** but it *is* desirable.)
**
** The unused offset argument is for the benefit of mktime variants.
*/

/*ARGSUSED*/
static struct tm *
localsub(const time_t * const timep, const long offset __unused,
    struct tm * const tmp)
{
	register struct state *		sp;
	register const struct ttinfo *	ttisp;
	register int			i;
	register struct tm *		result;
	const time_t			t = *timep;

	sp = lclptr;
	if (sp->timecnt == 0 || t < sp->ats[0]) {
		i = 0;
		while (sp->ttis[i].tt_isdst)
			if (++i >= sp->typecnt) {
				i = 0;
				break;
			}
	} else {
		for (i = 1; i < sp->timecnt; ++i)
			if (t < sp->ats[i])
				break;
		i = (int) sp->types[i - 1];
	}
	ttisp = &sp->ttis[i];
	/*
	** To get (wrong) behavior that's compatible with System V Release 2.0
	** you'd replace the statement below with
	**	t += ttisp->tt_gmtoff;
	**	timesub(&t, 0L, sp, tmp);
	*/
	result = timesub(&t, ttisp->tt_gmtoff, sp, tmp);
	tmp->tm_isdst = ttisp->tt_isdst;
	tzname[tmp->tm_isdst] = &sp->chars[ttisp->tt_abbrind];
#ifdef TM_ZONE
	tmp->TM_ZONE = &sp->chars[ttisp->tt_abbrind];
#endif /* defined TM_ZONE */
	return result;
}

/*
** Re-entrant version of localtime.
*/

struct tm *
localtime_r(timep, p_tm)
	const time_t *const timep;
	struct tm *p_tm;
{
	_THREAD_PRIVATE_MUTEX_LOCK(lcl);
	tzset_basic();
	p_tm = localsub(timep, 0L, p_tm);
	_THREAD_PRIVATE_MUTEX_UNLOCK(lcl);
	return p_tm;
}

struct tm *
localtime(timep)
	const time_t *const timep;
{
	_THREAD_PRIVATE_KEY(localtime);
	struct tm *p_tm = (struct tm *)_THREAD_PRIVATE(localtime, tm, NULL);

	if (p_tm == NULL)
		return NULL;
	return localtime_r(timep, p_tm);
}

/*
** gmtsub is to gmtime as localsub is to localtime.
*/

static struct tm *
gmtsub(timep, offset, tmp)
	const time_t *const timep;
	const long offset;
	struct tm *const tmp;
{
	register struct tm *	result;

	_THREAD_PRIVATE_MUTEX_LOCK(gmt);
	if (!gmt_is_set) {
		gmt_is_set = TRUE;
		gmtload(gmtptr);
	}
	_THREAD_PRIVATE_MUTEX_UNLOCK(gmt);
	result = timesub(timep, offset, gmtptr, tmp);
#ifdef TM_ZONE
	/*
	** Could get fancy here and deliver something such as
	** "UTC+xxxx" or "UTC-xxxx" if offset is non-zero,
	** but this is no time for a treasure hunt.
	*/
	if (offset != 0)
		tmp->TM_ZONE = wildabbr;
	else {
		tmp->TM_ZONE = gmtptr->chars;
	}
#endif /* defined TM_ZONE */
	return result;
}

/*
** Re-entrant version of gmtime.
*/

struct tm *
gmtime_r(timep, p_tm)
	const time_t *timep;
	struct tm *p_tm;
{
	gmtsub(timep, 0L, p_tm);
	return p_tm;
}

struct tm *
gmtime(timep)
	const time_t *const timep;
{
	_THREAD_PRIVATE_KEY(gmtime);
	struct tm *p_tm = (struct tm *)_THREAD_PRIVATE(gmtime, tm, NULL);

	if (p_tm == NULL)
		return NULL;
	return gmtime_r(timep, p_tm);

}

struct tm *
offtime(const time_t * const timep, const long offset)
{
	return gmtsub(timep, offset, &tm);
}

/*
** Return the number of leap years through the end of the given year
** where, to make the math easy, the answer for year zero is defined as zero.
*/
static int
leaps_thru_end_of(y)
register const int	y;
{
	return (y >= 0) ? (y / 4 - y / 100 + y / 400) :
		-(leaps_thru_end_of(-(y + 1)) + 1);
}

static struct tm *
timesub(timep, offset, sp, tmp)
	const time_t *const timep;
	const long offset;
	const struct state *const sp;
	struct tm *const tmp;
{
	const struct lsinfo *lp;
	time_t days;
	long rem, corr;
	int i, hit;	/* hit: leap second bit */
	mirtime_mjd tmjd;

	corr = 0;
	hit = 0;
	i = sp->leapcnt;
	while (--i >= 0) {
		lp = &sp->lsis[i];
		if (*timep >= lp->ls_trans) {
			if (*timep == lp->ls_trans) {
				hit = ((i == 0 && lp->ls_corr > 0) ||
				    lp->ls_corr > sp->lsis[i - 1].ls_corr);
				if (hit)
					while (i > 0 &&
					    sp->lsis[i].ls_trans ==
					    sp->lsis[i - 1].ls_trans + 1 &&
					    sp->lsis[i].ls_corr ==
					    sp->lsis[i - 1].ls_corr + 1) {
						++hit;
						--i;
					}
			}
			corr = lp->ls_corr;
			break;
		}
	}
	days = *timep / SECSPERDAY;
	rem = (int32_t)(*timep % SECSPERDAY);
#ifdef mc68k
	if (*timep == 0x80000000) {
		/*
		** A 3B1 muffs the division on the most negative number.
		*/
		days = -24855;
		rem = -11648;
	}
#endif /* defined mc68k */
	rem += (offset - corr);
	while (rem < 0) {
		rem += SECSPERDAY;
		--days;
	}
	while (rem >= SECSPERDAY) {
		rem -= SECSPERDAY;
		++days;
	}

	tmjd.mjd = days + 40587;
	tmjd.sec = (int32_t)rem;
	mjd_explode(tmp, &tmjd);
	tmp->tm_gmtoff = offset;
	tmp->tm_sec += hit;
	return (tmp);
}

char *
ctime(timep)
	const time_t *const timep;
{
/*
** Section 4.12.3.2 of X3.159-1989 requires that
**	The ctime function converts the calendar time pointed to by timer
**	to local time in the form of a string. It is equivalent to
**		asctime(localtime(timer))
*/
	return asctime(localtime(timep));
}

char *
ctime_r(timep, buf)
	const time_t *const timep;
	char *buf;
{
	struct tm	mytm;

	return asctime_r(localtime_r(timep, &mytm), buf);
}

/*
** Adapted from code provided by Robert Elz, who writes:
**	The "best" way to do mktime I think is based on an idea of Bob
**	Kridle's (so its said...) from a long time ago.
**	[kridle@@xinet.com as of 1996-01-16.]
**	It does a binary search of the time_t space. Since time_t's are
**	just 32 bits, its a max of 32 iterations (even at 64 bits it
**	would still be very reasonable).
*/

#ifndef WRONG
#define WRONG	(-1)
#endif /* !defined WRONG */

/*
** Simplified normalize logic courtesy Paul Eggert (eggert@@twinsun.com).
*/

static int
increment_overflow(number, delta)
	int *number;
	int delta;
{
	int number0;

	number0 = *number;
	*number += delta;
	return (*number < number0) != (delta < 0);
}

static int
long_increment_overflow(number, delta)
	time_t *number;
	time_t delta;
{
	time_t number0;

	number0 = *number;
	*number += delta;
	return (*number < number0) != (delta < 0);
}

static int
normalize_overflow(tensptr, unitsptr, base)
	int *const tensptr;
	int *const unitsptr;
	const int base;
{
	int tensdelta;

	tensdelta = (*unitsptr >= 0) ?
	    (*unitsptr / base) :
	    (-1 - (-1 - *unitsptr) / base);
	*unitsptr -= tensdelta * base;
	return increment_overflow(tensptr, tensdelta);
}

static int
long_normalize_overflow(tensptr, unitsptr, base)
	time_t *const tensptr;
	int *const unitsptr;
	const int base;
{
	time_t tensdelta;

	tensdelta = (*unitsptr >= 0) ?
	    (*unitsptr / base) :
	    (-1 - (-1 - *unitsptr) / base);
	*unitsptr -= (int)(tensdelta) * base;
	return long_increment_overflow(tensptr, tensdelta);
}

static int
tmcomp(atmp, btmp)
	const struct tm *const atmp;
	const struct tm *const btmp;
{
	int result;
	time_t resyr = atmp->tm_year - btmp->tm_year;

	if (resyr > 0)
		return 1;
	else if (resyr < 0)
		return -1;

	if ((result = (atmp->tm_mon - btmp->tm_mon)) == 0 &&
	    (result = (atmp->tm_mday - btmp->tm_mday)) == 0 &&
	    (result = (atmp->tm_hour - btmp->tm_hour)) == 0 &&
	    (result = (atmp->tm_min - btmp->tm_min)) == 0)
		result = atmp->tm_sec - btmp->tm_sec;
	return result;
}

static time_t
time2sub(tmp, funcp, offset, okayp, do_norm_secs)
struct tm * const	tmp;
struct tm * (* const	funcp) P((const time_t*, long, struct tm*));
const long		offset;
int * const		okayp;
const int		do_norm_secs;
{
	register const struct state *	sp;
	register int			dir;
	register int			i, j;
	register int			saved_seconds;
	register long			li;
	register time_t			lo;
	register time_t			hi;
	time_t				y;
	time_t				newt;
	time_t				t;
	struct tm			yourtm, mytm;

	*okayp = FALSE;
	yourtm = *tmp;
	if (do_norm_secs) {
		if (normalize_overflow(&yourtm.tm_min, &yourtm.tm_sec,
			SECSPERMIN))
				return WRONG;
	}
	if (normalize_overflow(&yourtm.tm_hour, &yourtm.tm_min, MINSPERHOUR))
		return WRONG;
	if (normalize_overflow(&yourtm.tm_mday, &yourtm.tm_hour, HOURSPERDAY))
		return WRONG;
	y = yourtm.tm_year;
	if (long_normalize_overflow(&y, &yourtm.tm_mon, MONSPERYEAR))
		return WRONG;
	/*
	** Turn y into an actual year number for now.
	** It is converted back to an offset from TM_YEAR_BASE later.
	*/
	if (long_increment_overflow(&y, (time_t)TM_YEAR_BASE))
		return WRONG;
	while (yourtm.tm_mday <= 0) {
		if (long_increment_overflow(&y, (time_t)-1))
			return WRONG;
		li = y + (1 < yourtm.tm_mon);
		yourtm.tm_mday += year_lengths[isleap(li)];
	}
	while (yourtm.tm_mday > DAYSPERLYEAR) {
		if (long_increment_overflow(&y, (time_t)1))
			return WRONG;
		li = y + (1 < yourtm.tm_mon);
		yourtm.tm_mday -= year_lengths[isleap(li)];
	}
	for ( ; ; ) {
		i = mon_lengths[isleap((y < 0) ? y+1 : y)][yourtm.tm_mon];
		if (yourtm.tm_mday <= i)
			break;
		yourtm.tm_mday -= i;
		if (++yourtm.tm_mon >= MONSPERYEAR) {
			yourtm.tm_mon = 0;
			if (long_increment_overflow(&y, (time_t)1))
				return WRONG;
		}
	}
	if (long_increment_overflow(&y, (time_t)-TM_YEAR_BASE))
		return WRONG;
	yourtm.tm_year = y;
	if (yourtm.tm_year != y)
		return WRONG;
	if (yourtm.tm_sec >= 0 && yourtm.tm_sec < SECSPERMIN)
		saved_seconds = 0;
	else if (y + TM_YEAR_BASE < EPOCH_YEAR) {
		/*
		** We can't set tm_sec to 0, because that might push the
		** time below the minimum representable time.
		** Set tm_sec to 59 instead.
		** This assumes that the minimum representable time is
		** not in the same minute that a leap second was deleted from,
		** which is a safer assumption than using 58 would be.
		*/
		if (increment_overflow(&yourtm.tm_sec, 1 - SECSPERMIN))
			return WRONG;
		saved_seconds = yourtm.tm_sec;
		yourtm.tm_sec = SECSPERMIN - 1;
	} else {
		saved_seconds = yourtm.tm_sec;
		yourtm.tm_sec = 0;
	}
	/*
	** Do a binary search (this works whatever time_t's type is).
	*/
	if (!TYPE_SIGNED(time_t)) {
		lo = 0;
		hi = lo - 1;
	} else if (!TYPE_INTEGRAL(time_t)) {
		if (sizeof(time_t) > sizeof(float))
			hi = (time_t) DBL_MAX;
		else	hi = (time_t) FLT_MAX;
		lo = -hi;
	} else {
		lo = 1;
		for (i = 0; i < (int) TYPE_BIT(time_t) - 1; ++i)
			lo *= 2;
		hi = -(lo + 1);
	}
	for ( ; ; ) {
		t = lo / 2 + hi / 2;
		if (t < lo)
			t = lo;
		else if (t > hi)
			t = hi;
		if ((*funcp)(&t, offset, &mytm) == NULL) {
			/*
			** Assume that t is too extreme to be represented in
			** a struct tm; arrange things so that it is less
			** extreme on the next pass.
			*/
			dir = (t > 0) ? 1 : -1;
		} else	dir = tmcomp(&mytm, &yourtm);
		if (dir != 0) {
			if (t == lo) {
				++t;
				++lo;
			} else if (t == hi) {
				--t;
				--hi;
			}
			if (lo > hi)
				return WRONG;
			if (dir > 0)
				hi = t;
			else	lo = t;
			continue;
		}
		if (yourtm.tm_isdst < 0 || mytm.tm_isdst == yourtm.tm_isdst)
			break;
		/*
		** Right time, wrong type.
		** Hunt for right time, right type.
		** It's okay to guess wrong since the guess
		** gets checked.
		*/
		/*
		** The (void *) casts are the benefit of SunOS 3.3 on Sun 2's.
		*/
		sp = (const struct state *)
			(((void *) funcp == (void *) localsub) ?
			lclptr : gmtptr);
		for (i = sp->typecnt - 1; i >= 0; --i) {
			if (sp->ttis[i].tt_isdst != yourtm.tm_isdst)
				continue;
			for (j = sp->typecnt - 1; j >= 0; --j) {
				if (sp->ttis[j].tt_isdst == yourtm.tm_isdst)
					continue;
				newt = t + sp->ttis[j].tt_gmtoff -
					sp->ttis[i].tt_gmtoff;
				if ((*funcp)(&newt, offset, &mytm) == NULL)
					continue;
				if (tmcomp(&mytm, &yourtm) != 0)
					continue;
				if (mytm.tm_isdst != yourtm.tm_isdst)
					continue;
				/*
				** We have a match.
				*/
				t = newt;
				goto label;
			}
		}
		return WRONG;
	}
label:
	newt = t + saved_seconds;
	if ((newt < t) != (saved_seconds < 0))
		return WRONG;
	t = newt;
	if ((*funcp)(&t, offset, tmp))
		*okayp = TRUE;
	return t;
}

static time_t
time2(tmp, funcp, offset, okayp)
	struct tm *const tmp;
	struct tm *(*const funcp) (const time_t *, long, struct tm *);
	const long offset;
	int *const okayp;
{
	time_t t;

	/*
	** First try without normalization of seconds
	** (in case tm_sec contains a value associated with a leap second).
	** If that fails, try with normalization of seconds.
	*/
	t = time2sub(tmp, funcp, offset, okayp, FALSE);
	return *okayp ? t : time2sub(tmp, funcp, offset, okayp, TRUE);
}

static time_t
time1(tmp, funcp, offset)
	struct tm *const tmp;
	struct tm *(*const funcp) (const time_t *, long, struct tm *);
	const long offset;
{
	time_t t;
	const struct state *sp;
	int samei, otheri;
	int sameind, otherind;
	int i;
	int nseen;
	int seen[TZ_MAX_TYPES];
	int types[TZ_MAX_TYPES];
	int okay;

	if (tmp->tm_isdst > 1)
		tmp->tm_isdst = 1;
	t = time2(tmp, funcp, offset, &okay);
	/*
	** PCTS code courtesy Grant Sullivan (grant@@osf.org).
	*/
	if (okay)
		return t;
	if (tmp->tm_isdst < 0)
		tmp->tm_isdst = 0;	/* reset to std and try again */
	/*
	** We're supposed to assume that somebody took a time of one type
	** and did some math on it that yielded a "struct tm" that's bad.
	** We try to divine the type they started from and adjust to the
	** type they need.
	*/
	/*
	** The (void *) casts are the benefit of SunOS 3.3 on Sun 2's.
	*/
	sp = (const struct state *)(((void *)funcp == (void *)localsub) ?
	    lclptr : gmtptr);
	for (i = 0; i < sp->typecnt; ++i)
		seen[i] = FALSE;
	nseen = 0;
	for (i = sp->timecnt - 1; i >= 0; --i)
		if (!seen[sp->types[i]]) {
			seen[sp->types[i]] = TRUE;
			types[nseen++] = sp->types[i];
		}
	for (sameind = 0; sameind < nseen; ++sameind) {
		samei = types[sameind];
		if (sp->ttis[samei].tt_isdst != tmp->tm_isdst)
			continue;
		for (otherind = 0; otherind < nseen; ++otherind) {
			otheri = types[otherind];
			if (sp->ttis[otheri].tt_isdst == tmp->tm_isdst)
				continue;
			tmp->tm_sec += (int)(sp->ttis[otheri].tt_gmtoff -
			    sp->ttis[samei].tt_gmtoff);
			tmp->tm_isdst = !tmp->tm_isdst;
			t = time2(tmp, funcp, offset, &okay);
			if (okay)
				return t;
			tmp->tm_sec -= (int)(sp->ttis[otheri].tt_gmtoff -
			    sp->ttis[samei].tt_gmtoff);
			tmp->tm_isdst = !tmp->tm_isdst;
		}
	}
	return WRONG;
}

time_t
mktime(tmp)
	struct tm *tmp;
{
	time_t ret;

	_THREAD_PRIVATE_MUTEX_LOCK(lcl);
	tzset_basic();
	ret = time1(tmp, localsub, 0L);
	_THREAD_PRIVATE_MUTEX_UNLOCK(lcl);
	return ret;
}

time_t
timelocal(tmp)
	struct tm *const tmp;
{
	tmp->tm_isdst = -1;		/* in case it wasn't initialized */
	return mktime(tmp);
}

time_t
timegm(tmp)
	struct tm *const tmp;
{
	tmp->tm_isdst = 0;
	return time1(tmp, gmtsub, 0L);
}

time_t
timeoff(tmp, offset)
	struct tm *const tmp;
	const long offset;
{
	tmp->tm_isdst = 0;
	return time1(tmp, gmtsub, offset);
}

const time_t *
mirtime_getleaps(void)
{
#ifdef SKIP_LEAPSECS
	static time_t noleaps = 0;

	return (&noleaps);
#else
	static int initialised = 0;
	static time_t leaps[TZ_MAX_LEAPS + 1];

	if (__predict_false(!initialised)) {
		int i;
		struct state sp;

		memset(leaps, 0, sizeof(leaps));

		/* load leap seconds for UTC */
		gmtload(&sp);

		/* sanity check */
		if ((sp.leapcnt > 0) && (sp.leapcnt <= TZ_MAX_LEAPS) &&
		    (sp.lsis[0].ls_trans == 78796800)) {
			/* add leap seconds to table */
			for (i = 0; i < sp.leapcnt; ++i)
				leaps[i] = sp.lsis[i].ls_trans;
			initialised = 1;
		}
	}
	return (leaps);
#endif
}
@


1.17
log
@first steps toward a new time API
• no DJB code (actual code) any more, only reimplementation of algorithms
  whose code is placed in USA PD
• no struct returns any more
• skip the extra tai_t step
• no _t suffix for types I define
• try to be a bit more elegant – I learned a lot since then, after all

the old ABI is still provided until we bump libc major
‣ the new API might wander off libc into libmbfun then, _too_

goal is functional equivalence (after all, it’s been proven correct)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/lib/libc/time/localtime.c,v 1.16 2009/11/09 21:30:56 tg Exp $");
d1228 1
a1228 1
	mjd_t tmjd;
d1276 1
a1276 1
	*tmp = mjd2tm(tmjd);
@


1.16
log
@fix __CRAZY=Yes build (or work around bugs we can’t fix atm)
@
text
@d2 2
a3 2
 * Copyright (c) 2004, 2005, 2007
 *	Thorsten Glaser <tg@@mirbsd.de>
a12 4
 * Advertising materials mentioning features or use of this work must
 * display the following acknowledgement:
 *	This product includes material provided by Thorsten Glaser.
 *
d24 1
d26 1
a26 1
__RCSID("$MirOS: src/lib/libc/time/localtime.c,v 1.15 2008/04/05 21:53:57 tg Exp $");
d38 1
a38 2
#include <sys/taitime.h>
#include <stdbool.h>
a177 7
time_t *tm_getleaps(void);
void _initialise_leaps(void);

/* private interface; sync with taileaps.c */
extern bool _leaps_initialised;
extern tai64_t _leaps[];
extern void _pushleap(time_t);
a1051 3
/*
** This function also cleans the leap second table first.
*/
d1058 1
a1058 6

	if (!_leaps_initialised) {
		_leaps[0] = (tai64_t)0;
		_leaps_initialised = true;
		_initialise_leaps();
	}
d1205 4
d1701 2
a1702 3
/* private interface */
void
_initialise_leaps(void)
d1704 2
a1705 2
	struct state sp;
	int i;
d1707 4
a1710 2
	/* load leap seconds for UTC */
	gmtload(&sp);
d1712 17
a1728 5
	/* sanity */
	if ((!sp.leapcnt) || (sp.lsis[0].ls_trans != 78796800)
	    || (sp.leapcnt > TZ_MAX_LEAPS)) {
		_leaps_initialised = false;
		return;
d1730 2
a1731 6

	/* copy over */
	for (i = 0; i < sp.leapcnt; ++i)
		/* XXX this does not handle negative leap seconds */
		/* XXX should abort(3) if they occur */
		_pushleap(sp.lsis[i].ls_trans);
@


1.15
log
@add a version check (if the two files actually can do it together)
@
text
@a0 2
/* $MirOS: src/lib/libc/time/localtime.c,v 1.14 2008/04/05 21:26:17 tg Exp $ */

d29 3
a31 1
__RCSID("$MirOS: src/lib/libc/time/localtime.c,v 1.14 2008/04/05 21:26:17 tg Exp $");
d1091 2
a1092 4
localsub(timep, offset, tmp)
const time_t * const	timep;
const long		offset;
struct tm * const	tmp;
d1219 1
a1219 3
offtime(timep, offset)
	const time_t *const timep;
	const long offset;
d1461 1
a1463 1
			return WRONG;
@


1.14
log
@sometimes, 23 second offsets in regression tests annoy me
provide a way around it (POSIX sucks and is illegal in Germany,
so this is not the default, nor is there a way to enable it by default)
@
text
@d1 1
a1 1
/* $MirOS: src/lib/libc/time/localtime.c,v 1.13 2007/02/07 21:08:20 tg Exp $ */
d31 1
a31 1
__RCSID("$MirOS: src/lib/libc/time/localtime.c,v 1.13 2007/02/07 21:08:20 tg Exp $");
d459 2
@


1.13
log
@#include "…" needs it to be in the current directory;
split between tailibc.c (multi) and taileaps.c (single)
@
text
@d1 1
a1 1
/* $MirOS: src/lib/libc/time/localtime.c,v 1.12 2007/02/07 20:43:24 tg Exp $ */
d31 1
a31 1
__RCSID("$MirOS: src/lib/libc/time/localtime.c,v 1.12 2007/02/07 20:43:24 tg Exp $");
d450 10
@


1.12
log
@* attempt to move taitime(3) functions from libc and kernel to kernbase,
  its prototypes from <time.h> and <sys/time.h> (which includes <time.h>)
  and <lib/libkern/taitime.h> to <sys/taitime.h>, split between indepen-
  dent and dependent (kernel/userland different leap table initialisation;
  userland additional tai_time(), taina_time(), importtai(), exporttai()),
  reduce required headers; reduce diff from headers to upstream
* move kernel tai leap second table from kernel objects to libkern
@
text
@d1 1
a1 1
/* $MirOS: src/share/misc/licence.template,v 1.20 2006/12/11 21:04:56 tg Rel $ */
d31 1
a31 1
__RCSID("$MirOS: src/lib/libc/time/localtime.c,v 1.11 2006/11/01 20:01:21 tg Exp $");
d185 1
a185 1
/* private interface; sync with tailibc.c */
@


1.11
log
@sync licences, minor wcwidth KNF
@
text
@d1 1
a1 1
/* $MirOS: src/lib/libc/time/localtime.c,v 1.10 2005/12/18 16:36:53 tg Exp $ */
d4 2
a5 2
 * Copyright (c) 2004, 2005
 *	Thorsten "mirabile" Glaser <tg@@66h.42h.de>
d9 5
a13 6
 * Licensee is hereby permitted to deal in this work without restric-
 * tion, including unlimited rights to use, publicly perform, modify,
 * merge, distribute, sell, give away or sublicence, provided all co-
 * pyright notices above, these terms and the disclaimer are retained
 * in all redistributions or reproduced in accompanying documentation
 * or other materials provided with binary redistributions.
d19 8
a26 11
 * Licensor offers the work "AS IS" and WITHOUT WARRANTY of any kind,
 * express, or implied, to the maximum extent permitted by applicable
 * law, without malicious intent or gross negligence; in no event may
 * licensor, an author or contributor be held liable for any indirect
 * or other damage, or direct damage except proven a consequence of a
 * direct error of said person and intended use of this work, loss or
 * other issues arising in any way out of its use, even if advised of
 * the possibility of such damage or existence of a defect.
 *-
 * based upon public domain implementation from
 * 1996-06-05 by Arthur David Olson (arthur_david_olson@@nih.gov)
d31 1
a31 1
__RCSID("$MirOS: src/lib/libc/time/localtime.c,v 1.10 2005/12/18 16:36:53 tg Exp $");
d41 2
d185 5
a1052 1
** The externs are a private interface; sync with taitime.c
a1056 3
	extern int _leaps_initialised;
	extern tai64_t _leaps[];

d1063 1
a1063 1
		_leaps_initialised = 1;
a1711 2
	extern int _leaps_initialised;
	extern void _pushleap(time_t);
d1721 1
a1721 1
		_leaps_initialised = 0;
@


1.10
log
@Part 2 of the big commit:
* www/vbegin.php: don't output the UTF-8 BOM for now
* ports/Setup.sh: change order in which path is divined [1]
* ports/books/mirex: convert to CVS_DISTF
* ports/comms/ssfe: increase line length limit and history buffer size
* ports/infrastructure/install/setup.sh: sync path order with Setup.sh [1]
* ports/infrastructure/mk/bsd.port.mk: (_PORTPATH) sync default PATH [1]
* ports/infrastructure/mk/bsd.port.mk: (_UPGRADE_FLAGS) new, default to -a
* ports/infrastructure/mk/bsd.port.mk: (_upgrade) use it
* ports/infrastructure/mk/bsd.port.mk: (reupgrade) new target, set to -a -f
* ports/infrastructure/scripts/mkmcz: don't use $LOCALBASE, trust in PATH
* ports/infrastructure/mk/bsd.port.mk: (_CVS_FETCH) use _PORTPATH
* ports/infrastructure/pkgtools/create: treat /usr/info same as /usr/man
* ports/infrastructure/pkgtools/upgrade: fix path to temp +REQUIRED_BY
* ports/www/firesomething: break, suggest Opera-Linux/K-Meleon/Safari
* src/Makefile, src/gcc/Makefile.lang: if build GCJ, check if X11 installed
* src/Makefile, src/gnu/usr.bin/perl/Makefile.bsd-wrapper: defer h2ph
  execution to end of build
* src/distrib/lists: sync with pre-h2ph change
* src/etc/services: add openvpn, from IANA
* src/gcc/Makefile.inc, Makefile.lang: fragment out NO_*= stuff
* src/gcc/libjava/Makefile.bsd-wrapper: DEBUGPROGS is gone
* src/gnu/usr.bin/perl/Makefile.bsd-wrapper: flesh out h2ph, fix perms
* src/lib/libc/time/localtime.c: fix undefined extern
* ports/net/sirc/Makefile: automatically insert version into CTCP VERSION
* ports/net/sirc/dist/PROGRAMMING: document capab hooks
* ports/net/sirc/dist/dsircp: several hours of perl hacking with Club-Mate
  - publish $msgchannel, $talkserver [2]
  - support for CAPAB: publish $has_capab, $capab_cmd, $capab_response;
    add "capab" hook in reply
  - support for CAPAB IDENTIFY-MSG: publish $has_identifymsg; new
    $unverified, $unverified_m; enable automatically if present;
    change <...> [...] -...- to ... [[...]] ...
  - /describe nick now looks [*] (or [[*]]) instead of *, /me now looks
    # instead of * if identified, to facilitate this conversion
  - fix abuse of U+0060
  - sort /names [2]
  - fix ^B ^_ ^V [2]
  - remove trailing whitespace on outgoing msgs [2]
  - remove trailing whitespace on incoming msgs
  - fix indentation
  - auto-split overlong lines (partially [2])
  - in NOTICE make nick bold too [2]
  - disable DCC since it crashes
  - beautify CTCP TIME replies
  - add ACCEPT command (for ratbox-ircd, e.g. Freeforge)
* ports/net/sirc/pkg/DESCR: summarise new features

[1] all for the sake of bsiegert@@ wanting to not have to souce a
    SetEnv.sh or SetEnv.csh before building in "default MirPorts"
    (i.e. LOCALBASE=/usr/mpkg SYSCONFDIR=/etc BINOWN=root SUDO=sudo)
[2] adapted from http://co.ordinate.org/sirc/
@
text
@d1 1
a1 1
/* $MirOS: src/lib/libc/time/localtime.c,v 1.9 2005/12/18 01:04:32 tg Exp $ */
d6 2
d16 2
a17 2
 * All advertising materials mentioning features or use of this soft-
 * ware must display the following acknowledgement:
d27 1
a27 1
 * the possibility of such damage or existence of a nontrivial bug.
d35 1
a35 1
__RCSID("$MirOS: src/lib/libc/time/localtime.c,v 1.9 2005/12/18 01:04:32 tg Exp $");
@


1.9
log
@* (tzset) initialise leap second table only once, not if it's already been
  set up correctly
* (_initialise_leaps) if the gmtload call doesn't offer a sane table keep
  state as not yet initialised
@
text
@d1 1
a1 1
/* $MirOS: src/lib/libc/time/localtime.c,v 1.8 2005/12/17 05:46:15 tg Exp $ */
d33 1
a33 1
__RCSID("$MirOS: src/lib/libc/time/localtime.c,v 1.8 2005/12/17 05:46:15 tg Exp $");
d1711 1
@


1.8
log
@big fat licence update (I left some which are bsiegert@@'s alone though)
also, remove licence boilerplate from some .h files who don't deserve it
and remove and add some advertising clauses because I say so
@
text
@d1 1
a1 1
/* $MirOS: src/lib/libc/time/localtime.c,v 1.7 2005/10/20 12:46:28 tg Exp $ */
d33 1
a33 1
__RCSID("$MirOS: src/lib/libc/time/localtime.c,v 1.7 2005/10/20 12:46:28 tg Exp $");
d1060 5
a1064 3
	_leaps[0] = (tai64_t)0;
	_leaps_initialised = 1;
	_initialise_leaps();
d1720 2
a1721 1
	    || (sp.leapcnt > TZ_MAX_LEAPS))
d1723 1
@


1.7
log
@- timesub (localtime, gmtime): fix buglet preventing leap seconds from
  appearing in the struct tm generated
- time2sub (mktime): revert to Olson function (saves us some TAI/MJD arith)
- time2sub (mktime): fix leap year detection for negative years
- overall: #ifdef and comment cleanup

=> we now pass GNU CVS configure test for "working mktime"
@
text
@d1 1
a1 1
/* $MirOS: src/lib/libc/time/localtime.c,v 1.6 2005/09/22 20:33:01 tg Exp $ */
d18 8
a25 7
 * Licensor hereby provides this work "AS IS" and WITHOUT WARRANTY of
 * any kind, expressed or implied, to the maximum extent permitted by
 * applicable law, but with the warranty of being written without ma-
 * licious intent or gross negligence; in no event shall licensor, an
 * author or contributor be held liable for any damage, direct, indi-
 * rect or other, however caused, arising in any way out of the usage
 * of this work, even if advised of the possibility of such damage.
d33 1
a33 1
__RCSID("$MirOS: src/lib/libc/time/localtime.c,v 1.6 2005/09/22 20:33:01 tg Exp $");
@


1.6
log
@merge and hope it does not break
@
text
@d1 1
a1 1
/* $MirOS: src/lib/libc/time/localtime.c,v 1.5 2005/03/29 16:53:46 tg Exp $ */
d26 2
a27 2
 * based upon public domain implementation by
 * 1996-06-05 by Arthur David Olson (arthur_david_olson@@nih.gov).
d32 1
a32 1
__RCSID("$MirOS: src/lib/libc/time/localtime.c,v 1.5 2005/03/29 16:53:46 tg Exp $");
d1230 1
a1230 1
	int hit, i;
d1280 2
a1281 3
#ifdef TM_GMTOFF
	tmp->TM_GMTOFF = offset;
#endif /* defined TM_GMTOFF */
d1402 6
a1407 2
time2sub(struct tm *const tmp, struct tm *(*const funcp) (const time_t *, long,
    struct tm *), const long offset, int *const okayp, const int do_norm_secs)
d1409 11
a1419 9
	const struct state *sp;
	int dir;
	int bits;
	int i, j;
	time_t li;
	time_t y;
	time_t newt;
	time_t t;
	struct tm yourtm, mytm;
a1422 2
	yourtm.tm_zone = NULL;
	yourtm.tm_gmtoff = 0;
d1425 2
a1426 2
		    SECSPERMIN))
			return WRONG;
a1440 2
	if (y < 0)
		++y;
d1444 2
a1445 1
		yourtm.tm_mday += year_lengths[isleap(y + (1 < yourtm.tm_mon))];
a1447 1
		yourtm.tm_mday -= year_lengths[isleap(y + (1 < yourtm.tm_mon))];
d1449 2
d1453 2
a1454 2
	for (;;) {
		i = mon_lengths[isleap(y)][yourtm.tm_mon];
a1465 2
	if (y < 1)
		--y;
d1467 103
a1569 11

	t = tai2timet(mjd2tai(tm2mjd(yourtm)));
	(*funcp) (&t, offset, &mytm);
	mytm.tm_zone = NULL;
	mytm.tm_gmtoff = 0;
	t += (t - tai2timet(mjd2tai(tm2mjd(mytm))));
	(*funcp) (&t, offset, &mytm);

	if (tmcomp(&mytm, &yourtm)) {
		t -= 3600;
		(*funcp) (&t, offset, &mytm);
d1571 3
a1573 1
	if (tmcomp(&mytm, &yourtm))
d1575 3
a1577 3

	*tmp = mytm;
	*okayp = TRUE;
@


1.5
log
@document better
@
text
@d1 1
a1 1
/* $MirOS: src/lib/libc/time/localtime.c,v 1.4 2005/03/29 16:50:32 tg Exp $ */
d32 1
a32 1
__RCSID("$MirOS: src/lib/libc/time/localtime.c,v 1.4 2005/03/29 16:50:32 tg Exp $");
d45 1
d48 13
d85 1
a85 1
** WILDABBR is used.  Another possibility:  initialize tzname[0] to the
d87 1
a87 1
** And another:  initialize tzname[0] to "ERA", with an explanation in the
d94 1
a94 1
static char wildabbr[] = "WILDABBR";
d159 1
d165 2
a166 2
static void gmtsub(const time_t *timep, long offset, struct tm *tmp);
static void localsub(const time_t *timep, long offset, struct tm *tmp);
d168 1
d173 4
a176 4
static time_t time1(struct tm *tmp, void (*funcp) (const time_t *, long, struct tm *), long offset);
static time_t time2(struct tm *tmp, void (*funcp) (const time_t *, long, struct tm *), long offset, int *okayp);
static time_t time2sub(struct tm *tmp, void (*funcp) (const time_t *, long, struct tm *), long offset, int *okayp, int do_norm_secs);
static void timesub(const time_t *timep, long offset, const struct state *sp, struct tm *tmp);
d252 18
d416 27
d458 1
a458 1
** a valid character in a zone name is found.  Return a pointer to that
d475 21
d560 1
a560 1
			/* `SECSPERMIN' allows for leap seconds.  */
d599 1
a599 1
** date[/time].  See POSIX section 8 for the format of "date" and "time".
d720 1
a720 1
		** "dow" is the day-of-week of the first day of the month.  Get
d743 1
a743 1
	** question.  To get the Epoch-relative time of the specified local
d781 12
a792 4
		name = getzname(name);
		stdlen = name - stdname;
		if (stdlen < 3)
			return -1;
d803 12
a814 5
		dstname = name;
		name = getzname(name);
		dstlen = name - dstname;/* length of DST zone name */
		if (dstlen < 3)
			return -1;
d1067 1
a1067 1
** freely called.  (And no, the PANS doesn't require the above behavior--
d1074 1
a1074 1
static void
d1076 9
a1084 8
	const time_t *const timep;
	const long offset __attribute__((unused));
	struct tm *const tmp;
{
	struct state *sp;
	const struct ttinfo *ttisp;
	int i;
	const time_t t = *timep;
d1098 1
a1098 1
		i = sp->types[i - 1];
d1107 1
a1107 1
	timesub(&t, ttisp->tt_gmtoff, sp, tmp);
d1113 1
d1127 1
a1127 1
	localsub(timep, 0L, p_tm);
d1148 1
a1148 1
static void
d1154 2
d1162 1
a1162 1
	timesub(timep, offset, gmtptr, tmp);
d1175 1
d1209 9
a1217 2
	gmtsub(timep, offset, &tm);
	return &tm;
d1220 1
a1220 1
static void
d1283 1
d1293 1
a1293 1
**	to local time in the form of a string.  It is equivalent to
d1304 1
a1304 1
	struct tm ctime_tm;
d1306 1
a1306 1
	return asctime_r(localtime_r(timep, &ctime_tm), buf);
d1314 1
a1314 1
**	It does a binary search of the time_t space.  Since time_t's are
d1403 1
a1403 1
time2sub(struct tm *const tmp, void (*const funcp) (const time_t *, long,
d1489 1
a1489 1
	void (*const funcp) (const time_t *, long, struct tm *);
d1507 1
a1507 1
	void (*const funcp) (const time_t *, long, struct tm *);
@


1.4
log
@arrays are no pointers, and pointers are no arrows
@
text
@d1 1
a1 1
/* $MirOS: src/lib/libc/time/localtime.c,v 1.3 2005/03/28 21:21:50 tg Exp $ */
d32 1
a32 1
__RCSID("$MirOS: src/lib/libc/time/localtime.c,v 1.3 2005/03/28 21:21:50 tg Exp $");
d948 4
@


1.3
log
@tzset(3) is now the preferred method for initialising the
TAI leap second table as well
@
text
@d1 1
a1 1
/* $MirOS: src/lib/libc/time/localtime.c,v 1.2 2005/03/06 20:28:50 tg Exp $ */
d32 1
a32 1
__RCSID("$MirOS: src/lib/libc/time/localtime.c,v 1.2 2005/03/06 20:28:50 tg Exp $");
d952 1
a952 1
	extern tai64_t *_leaps;
d958 1
a958 1
	*_leaps = (tai64_t)0;
@


1.2
log
@merge src/lib
@
text
@d1 1
a1 1
/* $MirOS$ */
d4 1
a4 1
 * Copyright (c) 2004
d32 1
a32 1
__RCSID("$MirOS$");
d166 1
d951 3
d957 4
d1165 1
a1165 1
	tmjd.sec = rem;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 4
/*
** This file is in the public domain, so clarified as of
** 1996-06-05 by Arthur David Olson (arthur_david_olson@@nih.gov).
*/
d3 30
a32 4
#if defined(LIBC_SCCS) && !defined(lint) && !defined(NOID)
static char elsieid[] = "@@(#)localtime.c	7.80";
static char rcsid[] = "$OpenBSD: localtime.c,v 1.25 2004/10/18 22:33:43 millert Exp $";
#endif /* LIBC_SCCS and not lint */
d40 1
a40 1
/*LINTLIBRARY*/
d53 1
a53 2
#endif /* defined O_BINARY */
#ifndef O_BINARY
d55 1
a55 1
#endif /* !defined O_BINARY */
d78 1
a78 1
#endif /* !defined WILDABBR */
d80 2
a81 3
static char		wildabbr[] = "WILDABBR";

static const char	gmt[] = "GMT";
d92 1
a92 1
#endif /* !defined TZDEFDST */
d95 5
a99 5
	long		tt_gmtoff;	/* UTC offset in seconds */
	int		tt_isdst;	/* used to set tm_isdst */
	int		tt_abbrind;	/* abbreviation list index */
	int		tt_ttisstd;	/* TRUE if transition is std time */
	int		tt_ttisgmt;	/* TRUE if transition is UTC */
d103 2
a104 2
	time_t		ls_trans;	/* transition time */
	long		ls_corr;	/* correction to apply */
a106 2
#define BIGGEST(a, b)	(((a) > (b)) ? (a) : (b))

d109 1
a109 2
#endif /* defined TZNAME_MAX */
#ifndef TZNAME_MAX
d111 1
a111 1
#endif /* !defined TZNAME_MAX */
d114 11
a124 10
	int		leapcnt;
	int		timecnt;
	int		typecnt;
	int		charcnt;
	time_t		ats[TZ_MAX_TIMES];
	unsigned char	types[TZ_MAX_TIMES];
	struct ttinfo	ttis[TZ_MAX_TYPES];
	char		chars[BIGGEST(BIGGEST(TZ_MAX_CHARS + 1, sizeof gmt),
				(2 * (MY_TZNAME_MAX + 1)))];
	struct lsinfo	lsis[TZ_MAX_LEAPS];
d128 5
a132 5
	int		r_type;		/* type of rule--see below */
	int		r_day;		/* day number of rule */
	int		r_week;		/* week number of rule */
	int		r_mon;		/* month number of rule */
	long		r_time;		/* transition time of rule */
d143 26
a168 49
static long		detzcode P((const char * codep));
static const char *	getzname P((const char * strp));
static const char *	getnum P((const char * strp, int * nump, int min,
				int max));
static const char *	getsecs P((const char * strp, long * secsp));
static const char *	getoffset P((const char * strp, long * offsetp));
static const char *	getrule P((const char * strp, struct rule * rulep));
static void		gmtload P((struct state * sp));
static void		gmtsub P((const time_t * timep, long offset,
				struct tm * tmp));
static void		localsub P((const time_t * timep, long offset,
				struct tm * tmp));
static int		increment_overflow P((int * number, int delta));
static int		long_increment_overflow P((long * number, int delta));
static int		long_normalize_overflow P((long * tensptr,
				int * unitsptr, int base));
static int		normalize_overflow P((int * tensptr, int * unitsptr,
				int base));
static void		settzname P((void));
static time_t		time1 P((struct tm * tmp,
				void(*funcp) P((const time_t *,
				long, struct tm *)),
				long offset));
static time_t		time2 P((struct tm *tmp,
				void(*funcp) P((const time_t *,
				long, struct tm*)),
				long offset, int * okayp));
static time_t		time2sub P((struct tm *tmp,
				void(*funcp) P((const time_t *,
				long, struct tm*)),
				long offset, int * okayp, int do_norm_secs));
static void		timesub P((const time_t * timep, long offset,
				const struct state * sp, struct tm * tmp));
static int		tmcomp P((const struct tm * atmp,
				const struct tm * btmp));
static time_t		transtime P((time_t janfirst, int year,
				const struct rule * rulep, long offset));
static int		tzload P((const char * name, struct state * sp));
static int		tzparse P((const char * name, struct state * sp,
				int lastditch));

#ifdef ALL_STATE
static struct state *	lclptr;
static struct state *	gmtptr;
#endif /* defined ALL_STATE */

#ifndef ALL_STATE
static struct state	lclmem;
static struct state	gmtmem;
a170 1
#endif /* State Farm */
d174 1
a174 1
#endif /* !defined TZ_STRLEN_MAX */
d176 3
a178 3
static char		lcl_TZname[TZ_STRLEN_MAX + 1];
static int		lcl_is_set;
static int		gmt_is_set;
d182 1
a182 1
char *			tzname[2] = {
d195 1
a195 10
static struct tm	tm;

#ifdef USG_COMPAT
time_t			timezone = 0;
int			daylight = 0;
#endif /* defined USG_COMPAT */

#ifdef ALTZONE
time_t			altzone = 0;
#endif /* defined ALTZONE */
d199 1
a199 1
const char * const	codep;
d201 2
a202 2
	register long	result;
	register int	i;
d211 1
a211 1
settzname P((void))
d213 2
a214 2
	register struct state * const	sp = lclptr;
	register int			i;
a217 13
#ifdef USG_COMPAT
	daylight = 0;
	timezone = 0;
#endif /* defined USG_COMPAT */
#ifdef ALTZONE
	altzone = 0;
#endif /* defined ALTZONE */
#ifdef ALL_STATE
	if (sp == NULL) {
		tzname[0] = tzname[1] = gmt;
		return;
	}
#endif /* defined ALL_STATE */
d219 1
a219 1
		register const struct ttinfo * const	ttisp = &sp->ttis[i];
d222 1
a222 11
			&sp->chars[ttisp->tt_abbrind];
#ifdef USG_COMPAT
		if (ttisp->tt_isdst)
			daylight = 1;
		if (i == 0 || !ttisp->tt_isdst)
			timezone = -(ttisp->tt_gmtoff);
#endif /* defined USG_COMPAT */
#ifdef ALTZONE
		if (i == 0 || ttisp->tt_isdst)
			altzone = -(ttisp->tt_gmtoff);
#endif /* defined ALTZONE */
d228 3
a230 3
		register const struct ttinfo * const	ttisp =
							&sp->ttis[
								sp->types[i]];
d233 1
a233 1
			&sp->chars[ttisp->tt_abbrind];
d239 2
a240 2
register const char *		name;
register struct state * const	sp;
d242 3
a244 3
	register const char *	p;
	register int		i;
	register int		fid;
d253 1
a253 1
		register int	doaccess;
d261 1
a261 1
		char		fullname[FILENAME_MAX];
d271 3
a273 3
			(void) strlcpy(fullname, p, sizeof fullname);
			(void) strlcat(fullname, "/", sizeof fullname);
			(void) strlcat(fullname, name, sizeof fullname);
d287 1
a287 1
		struct tzhead *	tzhp;
d289 5
a293 5
			struct tzhead	tzhead;
			char		buf[sizeof *sp + sizeof *tzhp];
		} u;
		int		ttisstdcnt;
		int		ttisgmtcnt;
d298 6
a303 6
		ttisstdcnt = (int) detzcode(u.tzhead.tzh_ttisstdcnt);
		ttisgmtcnt = (int) detzcode(u.tzhead.tzh_ttisgmtcnt);
		sp->leapcnt = (int) detzcode(u.tzhead.tzh_leapcnt);
		sp->timecnt = (int) detzcode(u.tzhead.tzh_timecnt);
		sp->typecnt = (int) detzcode(u.tzhead.tzh_typecnt);
		sp->charcnt = (int) detzcode(u.tzhead.tzh_charcnt);
d306 14
a319 14
			sp->typecnt <= 0 || sp->typecnt > TZ_MAX_TYPES ||
			sp->timecnt < 0 || sp->timecnt > TZ_MAX_TIMES ||
			sp->charcnt < 0 || sp->charcnt > TZ_MAX_CHARS ||
			(ttisstdcnt != sp->typecnt && ttisstdcnt != 0) ||
			(ttisgmtcnt != sp->typecnt && ttisgmtcnt != 0))
				return -1;
		if (i - (p - u.buf) < sp->timecnt * 4 +	/* ats */
			sp->timecnt +			/* types */
			sp->typecnt * (4 + 2) +		/* ttinfos */
			sp->charcnt +			/* chars */
			sp->leapcnt * (4 + 4) +		/* lsinfos */
			ttisstdcnt +			/* ttisstds */
			ttisgmtcnt)			/* ttisgmts */
				return -1;
d325 1
a325 1
			sp->types[i] = (unsigned char) *p++;
d330 1
a330 1
			register struct ttinfo *	ttisp;
d335 1
a335 1
			ttisp->tt_isdst = (unsigned char) *p++;
d338 1
a338 1
			ttisp->tt_abbrind = (unsigned char) *p++;
d340 2
a341 2
				ttisp->tt_abbrind > sp->charcnt)
					return -1;
d347 1
a347 1
			register struct lsinfo *	lsisp;
d356 1
a356 1
			register struct ttinfo *	ttisp;
d364 2
a365 2
					ttisp->tt_ttisstd != FALSE)
						return -1;
d369 1
a369 1
			register struct ttinfo *	ttisp;
d377 2
a378 2
					ttisp->tt_ttisgmt != FALSE)
						return -1;
d385 3
a387 3
static const int	mon_lengths[2][MONSPERYEAR] = {
	{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
	{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
d390 1
a390 1
static const int	year_lengths[2] = {
d402 1
a402 1
register const char *	strp;
d404 1
a404 1
	register char	c;
d407 2
a408 2
		c != '+')
			++strp;
d421 4
a424 4
register const char *	strp;
int * const		nump;
const int		min;
const int		max;
d426 2
a427 2
	register char	c;
	register int	num;
d454 2
a455 2
register const char *	strp;
long * const		secsp;
d457 1
a457 1
	int	num;
d468 1
a468 1
	*secsp = num * (long) SECSPERHOUR;
d496 2
a497 2
register const char *	strp;
long * const		offsetp;
d499 1
a499 1
	register int	neg = 0;
d523 2
a524 2
const char *			strp;
register struct rule * const	rulep;
d556 2
a557 1
	} else	return NULL;		/* invalid format */
d566 2
a567 1
	} else	rulep->r_time = 2 * SECSPERHOUR;	/* default = 2:00:00 */
d579 9
a587 9
const time_t				janfirst;
const int				year;
register const struct rule * const	rulep;
const long				offset;
{
	register int	leapyear;
	register time_t	value;
	register int	i;
	int		d, m1, yy0, yy1, yy2, dow;
d632 1
a632 1
			1 + yy2 + yy2 / 4 + yy1 / 4 - 2 * yy1) % 7;
d646 2
a647 2
				mon_lengths[leapyear][rulep->r_mon - 1])
					break;
d674 14
a687 14
const char *			name;
register struct state * const	sp;
const int			lastditch;
{
	const char *			stdname;
	const char *			dstname;
	size_t				stdlen;
	size_t				dstlen;
	long				stdoffset;
	long				dstoffset;
	register time_t *		atp;
	register unsigned char *	typep;
	register char *			cp;
	register int			load_result;
d710 1
a710 1
		sp->leapcnt = 0;		/* so, we're off a little */
d714 1
a714 1
		dstlen = name - dstname;	/* length of DST zone name */
d721 2
a722 1
		} else	dstoffset = stdoffset - SECSPERHOUR;
d726 6
a731 6
			struct rule	start;
			struct rule	end;
			register int	year;
			register time_t	janfirst;
			time_t		starttime;
			time_t		endtime;
d742 1
a742 1
			sp->typecnt = 2;	/* standard time and DST */
d760 1
a760 1
					stdoffset);
d762 1
a762 1
					dstoffset);
d775 1
a775 1
					SECSPERDAY;
d778 6
a783 6
			register long	theirstdoffset;
			register long	theirdstoffset;
			register long	theiroffset;
			register int	isdst;
			register int	i;
			register int	j;
d795 1
a795 1
						-sp->ttis[j].tt_gmtoff;
d804 1
a804 1
						-sp->ttis[j].tt_gmtoff;
d839 1
a839 1
							theirdstoffset;
d842 1
a842 1
							theirstdoffset;
d848 2
a849 1
				else	theirstdoffset = theiroffset;
d865 1
a865 1
		sp->typecnt = 1;		/* only standard time */
d874 1
a874 1
	if ((size_t) sp->charcnt > sizeof sp->chars)
d887 1
a887 1
struct state * const	sp;
d890 1
a890 1
		(void) tzparse(gmt, sp, TRUE);
d894 1
a894 1
tzsetwall_basic P((void))
d900 1
a900 10
#ifdef ALL_STATE
	if (lclptr == NULL) {
		lclptr = (struct state *) malloc(sizeof *lclptr);
		if (lclptr == NULL) {
			settzname();	/* all we can do */
			return;
		}
	}
#endif /* defined ALL_STATE */
	if (tzload((char *) NULL, lclptr) != 0)
a904 7
#ifndef STD_INSPIRED
/*
** A non-static declaration of tzsetwall in a system header file
** may cause a warning about this upcoming static declaration...
*/
static
#endif /* !defined STD_INSPIRED */
d906 1
a906 1
tzsetwall P((void))
d915 1
a915 1
tzset_basic P((void))
d917 1
a917 1
	register const char *	name;
a923 1

d928 1
a928 1
		(void) strlcpy(lcl_TZname, name, sizeof lcl_TZname);
a929 9
#ifdef ALL_STATE
	if (lclptr == NULL) {
		lclptr = (struct state *) malloc(sizeof *lclptr);
		if (lclptr == NULL) {
			settzname();	/* all we can do */
			return;
		}
	}
#endif /* defined ALL_STATE */
d934 1
a934 1
		lclptr->leapcnt = 0;		/* so, we're off a little */
d940 1
a940 1
		(void) strlcpy(lclptr->chars, gmt, sizeof lclptr->chars);
d943 1
a943 1
			(void) gmtload(lclptr);
d948 1
a948 1
tzset P((void))
d967 8
a974 8
const time_t * const	timep;
const long		offset;
struct tm * const	tmp;
{
	register struct state *		sp;
	register const struct ttinfo *	ttisp;
	register int			i;
	const time_t			t = *timep;
a976 6
#ifdef ALL_STATE
	if (sp == NULL) {
		gmtsub(timep, offset, tmp);
		return;
	}
#endif /* defined ALL_STATE */
d1011 2
a1012 2
const time_t * const	timep;
struct tm *p_tm;
d1023 1
a1023 1
const time_t * const	timep;
d1026 1
a1026 1
	struct tm * p_tm = (struct tm*)_THREAD_PRIVATE(localtime, tm, NULL);
d1039 3
a1041 3
const time_t * const	timep;
const long		offset;
struct tm * const	tmp;
d1046 1
a1046 5
#ifdef ALL_STATE
		gmtptr = (struct state *) malloc(sizeof *gmtptr);
		if (gmtptr != NULL)
#endif /* defined ALL_STATE */
			gmtload(gmtptr);
a1058 6
#ifdef ALL_STATE
		if (gmtptr == NULL)
			tmp->TM_ZONE = gmt;
		else	tmp->TM_ZONE = gmtptr->chars;
#endif /* defined ALL_STATE */
#ifndef ALL_STATE
a1059 1
#endif /* State Farm */
d1070 2
a1071 2
const time_t *		timep;
struct tm *		p_tm;
d1079 1
a1079 1
const time_t * const	timep;
d1082 1
a1082 1
	struct tm * p_tm = (struct tm*) _THREAD_PRIVATE(gmtime, tm, NULL);
a1089 2
#ifdef STD_INSPIRED

d1092 2
a1093 2
const time_t * const	timep;
const long		offset;
a1098 2
#endif /* defined STD_INSPIRED */

d1101 10
a1110 14
const time_t * const			timep;
const long				offset;
register const struct state * const	sp;
register struct tm * const		tmp;
{
	register const struct lsinfo *	lp;
	register long			days;
	register long			rem;
	register long			y;
	register int			yleap;
	register const int *		ip;
	register long			corr;
	register int			hit;
	register int			i;
a1113 4
#ifdef ALL_STATE
	i = (sp == NULL) ? 0 : sp->leapcnt;
#endif /* defined ALL_STATE */
#ifndef ALL_STATE
a1114 1
#endif /* State Farm */
d1120 1
a1120 1
					lp->ls_corr > sp->lsis[i - 1].ls_corr);
d1123 6
a1128 6
						sp->lsis[i].ls_trans ==
						sp->lsis[i - 1].ls_trans + 1 &&
						sp->lsis[i].ls_corr ==
						sp->lsis[i - 1].ls_corr + 1) {
							++hit;
							--i;
d1136 1
a1136 1
	rem = *timep % SECSPERDAY;
d1155 4
a1158 31
	tmp->tm_hour = (int) (rem / SECSPERHOUR);
	rem = rem % SECSPERHOUR;
	tmp->tm_min = (int) (rem / SECSPERMIN);
	/*
	** A positive leap second requires a special
	** representation.  This uses "... ??:59:60" et seq.
	*/
	tmp->tm_sec = (int) (rem % SECSPERMIN) + hit;
	tmp->tm_wday = (int) ((EPOCH_WDAY + days) % DAYSPERWEEK);
	if (tmp->tm_wday < 0)
		tmp->tm_wday += DAYSPERWEEK;
	y = EPOCH_YEAR;
#define LEAPS_THRU_END_OF(y)	((y) / 4 - (y) / 100 + (y) / 400)
	while (days < 0 || days >= (long) year_lengths[yleap = isleap(y)]) {
		register long	newy;

		newy = y + days / DAYSPERNYEAR;
		if (days < 0)
			--newy;
		days -= (newy - y) * DAYSPERNYEAR +
			LEAPS_THRU_END_OF(newy - 1) -
			LEAPS_THRU_END_OF(y - 1);
		y = newy;
	}
	tmp->tm_year = y - TM_YEAR_BASE;
	tmp->tm_yday = (int) days;
	ip = mon_lengths[yleap];
	for (tmp->tm_mon = 0; days >= (long) ip[tmp->tm_mon]; ++(tmp->tm_mon))
		days = days - (long) ip[tmp->tm_mon];
	tmp->tm_mday = (int) (days + 1);
	tmp->tm_isdst = 0;
d1166 1
a1166 1
const time_t * const	timep;
d1179 2
a1180 2
const time_t * const	timep;
char *			buf;
d1182 1
a1182 1
	struct tm	tm;
d1184 1
a1184 1
	return asctime_r(localtime_r(timep, &tm), buf);
d1207 2
a1208 2
int *	number;
int	delta;
d1210 1
a1210 1
	int	number0;
d1219 2
a1220 2
long *	number;
int	delta;
d1222 1
a1222 1
	long	number0;
d1231 3
a1233 3
int * const	tensptr;
int * const	unitsptr;
const int	base;
d1235 1
a1235 1
	register int	tensdelta;
d1238 2
a1239 2
		(*unitsptr / base) :
		(-1 - (-1 - *unitsptr) / base);
d1246 3
a1248 3
long * const	tensptr;
int * const	unitsptr;
const int	base;
d1250 1
a1250 1
	register int	tensdelta;
d1253 3
a1255 3
		(*unitsptr / base) :
		(-1 - (-1 - *unitsptr) / base);
	*unitsptr -= tensdelta * base;
d1261 2
a1262 2
register const struct tm * const atmp;
register const struct tm * const btmp;
d1264 7
a1270 1
	register int	result;
d1272 5
a1276 6
	if ((result = (atmp->tm_year - btmp->tm_year)) == 0 &&
		(result = (atmp->tm_mon - btmp->tm_mon)) == 0 &&
		(result = (atmp->tm_mday - btmp->tm_mday)) == 0 &&
		(result = (atmp->tm_hour - btmp->tm_hour)) == 0 &&
		(result = (atmp->tm_min - btmp->tm_min)) == 0)
			result = atmp->tm_sec - btmp->tm_sec;
d1281 12
a1292 17
time2sub(tmp, funcp, offset, okayp, do_norm_secs)
struct tm * const	tmp;
void (* const		funcp) P((const time_t*, long, struct tm*));
const long		offset;
int * const		okayp;
const int		do_norm_secs;
{
	register const struct state *	sp;
	register int			dir;
	register int			bits;
	register int			i, j;
	register int			saved_seconds;
	register long			li;
	long				y;
	time_t				newt;
	time_t				t;
	struct tm			yourtm, mytm;
d1296 2
d1300 2
a1301 2
			SECSPERMIN))
				return WRONG;
d1314 1
a1314 1
	if (long_increment_overflow(&y, TM_YEAR_BASE))
d1316 2
d1319 1
a1319 1
		if (long_increment_overflow(&y, -1))
d1321 1
a1321 2
		li = y + (1 < yourtm.tm_mon);
		yourtm.tm_mday += year_lengths[isleap(li)];
d1324 2
a1325 3
		li = y + (1 < yourtm.tm_mon);
		yourtm.tm_mday -= year_lengths[isleap(li)];
		if (long_increment_overflow(&y, 1))
d1328 1
a1328 1
	for ( ; ; ) {
d1335 1
a1335 1
			if (long_increment_overflow(&y, 1))
d1339 1
a1339 1
	if (long_increment_overflow(&y, -TM_YEAR_BASE))
d1341 2
d1344 11
a1354 84
	if (yourtm.tm_year != y)
 		return WRONG;
	if (yourtm.tm_sec >= 0 && yourtm.tm_sec < SECSPERMIN)
		saved_seconds = 0;
	else if (y + TM_YEAR_BASE < EPOCH_YEAR) {
		/*
		** We can't set tm_sec to 0, because that might push the
		** time below the minimum representable time.
		** Set tm_sec to 59 instead.
		** This assumes that the minimum representable time is
		** not in the same minute that a leap second was deleted from,
		** which is a safer assumption than using 58 would be.
		*/
		if (increment_overflow(&yourtm.tm_sec, 1 - SECSPERMIN))
			return WRONG;
		saved_seconds = yourtm.tm_sec;
		yourtm.tm_sec = SECSPERMIN - 1;
	} else {
		saved_seconds = yourtm.tm_sec;
		yourtm.tm_sec = 0;
	}
	/*
	** Divide the search space in half
	** (this works whether time_t is signed or unsigned).
	*/
	bits = TYPE_BIT(time_t) - 1;
	/*
	** If time_t is signed, then 0 is just above the median,
	** assuming two's complement arithmetic.
	** If time_t is unsigned, then (1 << bits) is just above the median.
	*/
	t = TYPE_SIGNED(time_t) ? 0 : (((time_t) 1) << bits);
	for ( ; ; ) {
		(*funcp)(&t, offset, &mytm);
		dir = tmcomp(&mytm, &yourtm);
		if (dir != 0) {
			if (bits-- < 0)
				return WRONG;
			if (bits < 0)
				--t; /* may be needed if new t is minimal */
			else if (dir > 0)
				t -= ((time_t) 1) << bits;
			else	t += ((time_t) 1) << bits;
			continue;
		}
		if (yourtm.tm_isdst < 0 || mytm.tm_isdst == yourtm.tm_isdst)
			break;
		/*
		** Right time, wrong type.
		** Hunt for right time, right type.
		** It's okay to guess wrong since the guess
		** gets checked.
		*/
		/*
		** The (void *) casts are the benefit of SunOS 3.3 on Sun 2's.
		*/
		sp = (const struct state *)
			(((void *) funcp == (void *) localsub) ?
			lclptr : gmtptr);
#ifdef ALL_STATE
		if (sp == NULL)
			return WRONG;
#endif /* defined ALL_STATE */
		for (i = sp->typecnt - 1; i >= 0; --i) {
			if (sp->ttis[i].tt_isdst != yourtm.tm_isdst)
				continue;
			for (j = sp->typecnt - 1; j >= 0; --j) {
				if (sp->ttis[j].tt_isdst == yourtm.tm_isdst)
					continue;
				newt = t + sp->ttis[j].tt_gmtoff -
					sp->ttis[i].tt_gmtoff;
				(*funcp)(&newt, offset, &mytm);
				if (tmcomp(&mytm, &yourtm) != 0)
					continue;
				if (mytm.tm_isdst != yourtm.tm_isdst)
					continue;
				/*
				** We have a match.
				*/
				t = newt;
				goto label;
			}
		}
		return WRONG;
d1356 1
a1356 3
label:
	newt = t + saved_seconds;
	if ((newt < t) != (saved_seconds < 0))
d1358 2
a1359 2
	t = newt;
	(*funcp)(&t, offset, tmp);
d1366 4
a1369 4
struct tm * const	tmp;
void (* const		funcp) P((const time_t*, long, struct tm*));
const long		offset;
int * const		okayp;
d1371 1
a1371 1
	time_t	t;
d1384 13
a1396 13
struct tm * const	tmp;
void (* const		funcp) P((const time_t *, long, struct tm *));
const long		offset;
{
	register time_t			t;
	register const struct state *	sp;
	register int			samei, otheri;
	register int			sameind, otherind;
	register int			i;
	register int			nseen;
	int				seen[TZ_MAX_TYPES];
	int				types[TZ_MAX_TYPES];
	int				okay;
a1400 1
#ifdef PCTS
a1407 5
#endif /* defined PCTS */
#ifndef PCTS
	if (okay || tmp->tm_isdst < 0)
		return t;
#endif /* !defined PCTS */
d1417 2
a1418 6
	sp = (const struct state *) (((void *) funcp == (void *) localsub) ?
		lclptr : gmtptr);
#ifdef ALL_STATE
	if (sp == NULL)
		return WRONG;
#endif /* defined ALL_STATE */
d1435 2
a1436 2
			tmp->tm_sec += sp->ttis[otheri].tt_gmtoff -
					sp->ttis[samei].tt_gmtoff;
d1441 2
a1442 2
			tmp->tm_sec -= sp->ttis[otheri].tt_gmtoff -
					sp->ttis[samei].tt_gmtoff;
d1451 1
a1451 1
struct tm * const	tmp;
a1461 2
#ifdef STD_INSPIRED

d1464 1
a1464 1
struct tm * const	tmp;
d1466 1
a1466 1
	tmp->tm_isdst = -1;	/* in case it wasn't initialized */
d1472 1
a1472 1
struct tm * const	tmp;
d1480 2
a1481 2
struct tm * const	tmp;
const long		offset;
d1487 3
a1489 12
#endif /* defined STD_INSPIRED */

#ifdef CMUCS

/*
** The following is supplied for compatibility with
** previous versions of the CMUCS runtime library.
*/

long
gtime(tmp)
struct tm * const	tmp;
d1491 11
a1501 1
	const time_t	t = mktime(tmp);
d1503 5
a1507 3
	if (t == WRONG)
		return -1;
	return t;
a1508 78

#endif /* defined CMUCS */

/*
** XXX--is the below the right way to conditionalize??
*/

#ifdef STD_INSPIRED

/*
** IEEE Std 1003.1-1988 (POSIX) legislates that 536457599
** shall correspond to "Wed Dec 31 23:59:59 UTC 1986", which
** is not the case if we are accounting for leap seconds.
** So, we provide the following conversion routines for use
** when exchanging timestamps with POSIX conforming systems.
*/

static long
leapcorr(timep)
time_t *	timep;
{
	register struct state *		sp;
	register struct lsinfo *	lp;
	register int			i;

	sp = lclptr;
	i = sp->leapcnt;
	while (--i >= 0) {
		lp = &sp->lsis[i];
		if (*timep >= lp->ls_trans)
			return lp->ls_corr;
	}
	return 0;
}

time_t
time2posix(t)
time_t	t;
{
	tzset();
	return t - leapcorr(&t);
}

time_t
posix2time(t)
time_t	t;
{
	time_t	x;
	time_t	y;

	tzset();
	/*
	** For a positive leap second hit, the result
	** is not unique.  For a negative leap second
	** hit, the corresponding time doesn't exist,
	** so we return an adjacent second.
	*/
	x = t + leapcorr(&t);
	y = x - leapcorr(&x);
	if (y < t) {
		do {
			x++;
			y = x - leapcorr(&x);
		} while (y < t);
		if (t != y)
			return x - 1;
	} else if (y > t) {
		do {
			--x;
			y = x - leapcorr(&x);
		} while (y > t);
		if (t != y)
			return x + 1;
	}
	return x;
}

#endif /* defined STD_INSPIRED */
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d7 2
a8 2
static char elsieid[] = "@@(#)localtime.c	7.95";
static char rcsid[] = "$OpenBSD: localtime.c,v 1.26 2005/07/05 13:40:51 millert Exp $";
a21 1
#include "float.h"	/* for FLT_MAX and DBL_MAX */
a23 13
#ifndef TZ_ABBR_MAX_LEN
#define TZ_ABBR_MAX_LEN	16
#endif /* !defined TZ_ABBR_MAX_LEN */

#ifndef TZ_ABBR_CHAR_SET
#define TZ_ABBR_CHAR_SET \
	"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 :+-._"
#endif /* !defined TZ_ABBR_CHAR_SET */

#ifndef TZ_ABBR_ERR_CHAR
#define TZ_ABBR_ERR_CHAR	'_'
#endif /* !defined TZ_ABBR_ERR_CHAR */

d49 1
a49 1
** WILDABBR is used. Another possibility: initialize tzname[0] to the
d51 1
a51 1
** And another: initialize tzname[0] to "ERA", with an explanation in the
d58 1
a58 1
static char		wildabbr[] = WILDABBR;
a125 1
static const char *	getqzname P((const char * strp, const char delim));
d132 1
a132 1
static struct tm *	gmtsub P((const time_t * timep, long offset,
d134 1
a134 1
static struct tm *	localsub P((const time_t * timep, long offset,
a136 1
static int		leaps_thru_end_of P((int y));
d144 1
a144 1
				struct tm * (*funcp) P((const time_t *,
d148 1
a148 1
				struct tm * (*funcp) P((const time_t *,
d152 1
a152 1
				struct tm * (*funcp) P((const time_t *,
d155 1
a155 1
static struct tm *	timesub P((const time_t * timep, long offset,
a271 18
	/*
	** Finally, scrub the abbreviations.
	** First, replace bogus characters.
	*/
	for (i = 0; i < sp->charcnt; ++i)
		if (strchr(TZ_ABBR_CHAR_SET, sp->chars[i]) == NULL)
			sp->chars[i] = TZ_ABBR_ERR_CHAR;
	/*
	** Second, truncate long abbreviations.
	*/
	for (i = 0; i < sp->typecnt; ++i) {
		register const struct ttinfo * const	ttisp = &sp->ttis[i];
		register char *				cp = &sp->chars[ttisp->tt_abbrind];

		if (strlen(cp) > TZ_ABBR_MAX_LEN &&
			strcmp(cp, GRANDPARENTED) != 0)
				*(cp + TZ_ABBR_MAX_LEN) = '\0';
	}
a417 27
		/*
		** Out-of-sort ats should mean we're running on a
		** signed time_t system but using a data file with
		** unsigned values (or vice versa).
		*/
		for (i = 0; i < sp->timecnt - 2; ++i)
			if (sp->ats[i] > sp->ats[i + 1]) {
				++i;
				if (TYPE_SIGNED(time_t)) {
					/*
					** Ignore the end (easy).
					*/
					sp->timecnt = i;
				} else {
					/*
					** Ignore the beginning (harder).
					*/
					register int	j;

					for (j = 0; j + i < sp->timecnt; ++j) {
						sp->ats[j] = sp->ats[j + i];
						sp->types[j] = sp->types[j + i];
					}
					sp->timecnt = j;
				}
				break;
			}
d433 1
a433 1
** a valid character in a zone name is found. Return a pointer to that
a449 21
** Given a pointer into an extended time zone string, scan until the ending
** delimiter of the zone name is located.   Return a pointer to the delimiter.
**
** As with getzname above, the legal character set is actually quite
** restricted, with other characters producing undefined results.
** We choose not to care - allowing almost anything to be in the zone abbrev.
*/

static const char *
getqzname(strp, delim)
register const char *	strp;
const char		delim;
{
	register char	c;

	while ((c = *strp) != '\0' && c != delim)
		++strp;
	return strp;
}

/*
d514 1
a514 1
			/* `SECSPERMIN' allows for leap seconds. */
d553 1
a553 1
** date[/time]. See POSIX section 8 for the format of "date" and "time".
d672 1
a672 1
		** "dow" is the day-of-week of the first day of the month. Get
d695 1
a695 1
	** question. To get the Epoch-relative time of the specified local
d733 4
a736 12
		if (*name == '<') {
			name++;
			stdname = name;
			name = getqzname(name, '>');
			if (*name != '>')
				return (-1);
			stdlen = name - stdname;
			name++;
		} else {
			name = getzname(name);
			stdlen = name - stdname;
		}
d747 5
a751 12
		if (*name == '<') {
			dstname = ++name;
			name = getqzname(name, '>');
			if (*name != '>')
				return -1;
			dstlen = name - dstname;
			name++;
		} else {
			dstname = name;
			name = getzname(name);
			dstlen = name - dstname; /* length of DST zone name */
		}
d1017 1
a1017 1
** freely called. (And no, the PANS doesn't require the above behavior--
d1024 1
a1024 1
static struct tm *
a1032 1
	register struct tm *		result;
d1037 4
a1040 2
	if (sp == NULL)
		return gmtsub(timep, offset, tmp);
d1053 1
a1053 1
		i = (int) sp->types[i - 1];
d1062 1
a1062 1
	result = timesub(&t, ttisp->tt_gmtoff, sp, tmp);
a1067 1
	return result;
d1102 1
a1102 1
static struct tm *
a1107 2
	register struct tm *	result;

d1118 1
a1118 1
	result = timesub(timep, offset, gmtptr, tmp);
a1137 1
	return result;
d1173 2
a1174 1
	return gmtsub(timep, offset, &tm);
d1179 1
a1179 14
/*
** Return the number of leap years through the end of the given year
** where, to make the math easy, the answer for year zero is defined as zero.
*/

static int
leaps_thru_end_of(y)
register const int	y;
{
	return (y >= 0) ? (y / 4 - y / 100 + y / 400) :
		-(leaps_thru_end_of(-(y + 1)) + 1);
}

static struct tm *
d1187 1
a1187 2
	register time_t			tdays;
	register int			idays;	/* unsigned would be so 2003 */
d1189 2
a1190 1
	int				y;
d1224 9
a1232 23
	y = EPOCH_YEAR;
	tdays = *timep / SECSPERDAY;
	rem = *timep - tdays * SECSPERDAY;
	while (tdays < 0 || tdays >= year_lengths[isleap(y)]) {
		int		newy;
		register time_t	tdelta;
		register int	idelta;
		register int	leapdays;

		tdelta = tdays / DAYSPERLYEAR;
		idelta = tdelta;
		if (tdelta - idelta >= 1 || idelta - tdelta >= 1)
			return NULL;
		if (idelta == 0)
			idelta = (tdays < 0) ? -1 : 1;
		newy = y;
		if (increment_overflow(&newy, idelta))
			return NULL;
		leapdays = leaps_thru_end_of(newy - 1) -
			leaps_thru_end_of(y - 1);
		tdays -= ((time_t) newy - y) * DAYSPERNYEAR;
		tdays -= leapdays;
		y = newy;
d1234 2
a1235 12
	{
		register long	seconds;

		seconds = tdays * SECSPERDAY + 0.5;
		tdays = seconds / SECSPERDAY;
		rem += seconds - tdays * SECSPERDAY;
	}
	/*
	** Given the range, we can now fearlessly cast...
	*/
	idays = tdays;
	rem += offset - corr;
d1238 1
a1238 1
		--idays;
d1242 1
a1242 1
		++idays;
a1243 26
	while (idays < 0) {
		if (increment_overflow(&y, -1))
			return NULL;
		idays += year_lengths[isleap(y)];
	}
	while (idays >= year_lengths[isleap(y)]) {
		idays -= year_lengths[isleap(y)];
		if (increment_overflow(&y, 1))
			return NULL;
	}
	tmp->tm_year = y;
	if (increment_overflow(&tmp->tm_year, -TM_YEAR_BASE))
		return NULL;
	tmp->tm_yday = idays;
	/*
	** The "extra" mods below avoid overflow problems.
	*/
	tmp->tm_wday = EPOCH_WDAY +
		((y - EPOCH_YEAR) % DAYSPERWEEK) *
		(DAYSPERNYEAR % DAYSPERWEEK) +
		leaps_thru_end_of(y - 1) -
		leaps_thru_end_of(EPOCH_YEAR - 1) +
		idays;
	tmp->tm_wday %= DAYSPERWEEK;
	if (tmp->tm_wday < 0)
		tmp->tm_wday += DAYSPERWEEK;
d1245 1
a1245 1
	rem %= SECSPERHOUR;
d1249 1
a1249 1
	** representation. This uses "... ??:59:60" et seq.
d1252 22
a1273 4
	ip = mon_lengths[isleap(y)];
	for (tmp->tm_mon = 0; idays >= ip[tmp->tm_mon]; ++(tmp->tm_mon))
		idays -= ip[tmp->tm_mon];
	tmp->tm_mday = (int) (idays + 1);
a1277 1
	return tmp;
d1287 1
a1287 1
**	to local time in the form of a string. It is equivalent to
d1298 1
a1298 1
	struct tm	mytm;
d1300 1
a1300 1
	return asctime_r(localtime_r(timep, &mytm), buf);
d1308 1
a1308 1
**	It does a binary search of the time_t space. Since time_t's are
d1394 1
a1394 1
struct tm * (* const	funcp) P((const time_t*, long, struct tm*));
d1401 1
a1404 2
	register time_t			lo;
	register time_t			hi;
d1457 1
a1457 1
		return WRONG;
d1478 2
a1479 1
	** Do a binary search (this works whatever time_t's type is).
d1481 7
a1487 14
	if (!TYPE_SIGNED(time_t)) {
		lo = 0;
		hi = lo - 1;
	} else if (!TYPE_INTEGRAL(time_t)) {
		if (sizeof(time_t) > sizeof(float))
			hi = (time_t) DBL_MAX;
		else	hi = (time_t) FLT_MAX;
		lo = -hi;
	} else {
		lo = 1;
		for (i = 0; i < (int) TYPE_BIT(time_t) - 1; ++i)
			lo *= 2;
		hi = -(lo + 1);
	}
d1489 2
a1490 13
		t = lo / 2 + hi / 2;
		if (t < lo)
			t = lo;
		else if (t > hi)
			t = hi;
		if ((*funcp)(&t, offset, &mytm) == NULL) {
			/*
			** Assume that t is too extreme to be represented in
			** a struct tm; arrange things so that it is less
			** extreme on the next pass.
			*/
			dir = (t > 0) ? 1 : -1;
		} else	dir = tmcomp(&mytm, &yourtm);
d1492 1
a1492 8
			if (t == lo) {
				++t;
				++lo;
			} else if (t == hi) {
				--t;
				--hi;
			}
			if (lo > hi)
d1494 5
a1498 3
			if (dir > 0)
				hi = t;
			else	lo = t;
d1527 1
a1527 2
				if ((*funcp)(&newt, offset, &mytm) == NULL)
					continue;
d1546 2
a1547 2
	if ((*funcp)(&t, offset, tmp))
		*okayp = TRUE;
d1554 1
a1554 1
struct tm * (* const	funcp) P((const time_t*, long, struct tm*));
d1572 1
a1572 1
struct tm * (* const	funcp) P((const time_t *, long, struct tm *));
d1758 1
a1758 1
	** is not unique. For a negative leap second
@


1.1.1.3
log
@Import OpenBSD's libc as of today, minus some of the locale stuff,
and with brk malloc instead of mmap malloc
@
text
@a0 1
/*	$OpenBSD: localtime.c,v 1.30 2005/08/09 16:12:12 millert Exp $ */
d6 5
d1178 1
a1178 1
	p_tm = localsub(timep, 0L, p_tm);
a1656 2
				if (t <= lo)
					return WRONG;
a1659 2
				if (t >= hi)
					return WRONG;
@


