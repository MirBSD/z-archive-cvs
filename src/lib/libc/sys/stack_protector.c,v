head	1.14;
access;
symbols
	MIRBSD_10:1.6.0.2
	MIRBSD_10_BASE:1.6
	MIRBSD_9_BASE:1.5
	MIRBSD_8:1.5.0.2
	MIRBSD_8_BASE:1.5
	cvs-200509212000:1.1.1.2
	cvs-200507211800:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2014.02.19.22.47.52;	author tg;	state Exp;
branches;
next	1.12;
commitid	100530534A75525C011;

1.12
date	2013.10.31.20.06.27;	author tg;	state Exp;
branches;
next	1.11;
commitid	1005272B7081B0E5655;

1.11
date	2011.04.27.21.54.07;	author tg;	state Exp;
branches;
next	1.10;
commitid	1004DB88FF975BA0012;

1.10
date	2011.02.19.01.38.32;	author tg;	state Exp;
branches;
next	1.9;
commitid	1004D5F1F1D5C364ABF;

1.9
date	2011.02.19.01.27.51;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004D5F1CA83EA8824C;

1.8
date	2009.01.20.21.49.34;	author tg;	state Exp;
branches;
next	1.7;
commitid	100497646F0513196AE;

1.7
date	2008.10.16.14.45.57;	author tg;	state Exp;
branches;
next	1.6;
commitid	10048F753B807A354E2;

1.6
date	2006.09.30.20.37.12;	author tg;	state Exp;
branches;
next	1.5;
commitid	100451ED58E1E0AEA44;

1.5
date	2005.09.22.20.48.50;	author tg;	state Exp;
branches;
next	1.4;
commitid	29a4433318c2c2f5;

1.4
date	2005.09.22.20.17.49;	author tg;	state Exp;
branches;
next	1.3;
commitid	35454333118224b0;

1.3
date	2005.04.17.01.42.22;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.06.20.28.49;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.25.00;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.25.00;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.09.21.20.34.31;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	20cd4331c3c732a2;

1.1.1.3
date	2006.09.30.20.24.36;	author tg;	state Exp;
branches;
next	;
commitid	100451ED297277FE479;


desc
@@


1.14
log
@improve initialisation of SSP guard
@
text
@/*	$OpenBSD: stack_protector.c,v 1.10 2006/03/31 05:34:44 deraadt Exp $	*/

/*
 * Copyright © 2009, 2011, 2013, 2014
 *	Thorsten “mirabilos” Glaser <tg@@mirbsd.org>
 * Copyright (c) 2002 Hiroaki Etoh, Federico G. Schwindt, and Miodrag Vallat.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>

__RCSID("$MirOS: src/lib/libc/sys/stack_protector.c,v 1.12 2013/10/31 20:06:27 tg Exp $");

#if (defined(__SSP__) || defined(__SSP_ALL__)) && \
    !defined(__IN_MKDEP) && !defined(lint)
#error "You must compile this file with -fno-stack-protector"
#endif

#ifdef lint
#define	CONSTRUCTOR
#elif defined(__PCC__)
#define	CONSTRUCTOR	_Pragma("init")
#else
#define	CONSTRUCTOR	static __attribute__((__constructor__))
#endif

extern void _thread_sys__exit__(int) __dead;
extern void arc4random_atexit(void);

long __guard[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };	/* gcc (3.4 ProPolice) */
int __stack_chk_guard = 0;			/* gcc4 libssp and pcc */
CONSTRUCTOR void __guard_setup(void);
__dead void __stack_smash_handler(const char func[], int damaged);
__dead void __stack_chk_fail(void);

static const char message[] = "stack overflow in function %s (damaged: %d)";

CONSTRUCTOR void
__guard_setup(void)
{
	uint8_t newguard[MAX(sizeof(__guard), sizeof(__stack_chk_guard))];

	while (__stack_chk_guard == 0) {
		arc4random_buf(newguard, sizeof(__stack_chk_guard));
		memcpy(&__stack_chk_guard, newguard, sizeof(__stack_chk_guard));
	}

	while (__guard[0] == 0) {
		arc4random_buf(newguard, sizeof(__guard));
		newguard[17] = 0;
		newguard[18] = '\n';
		newguard[19] = 255;
		memcpy(__guard, newguard, sizeof(__guard));
	}
}

/* ARGSUSED1 */
void
__stack_smash_handler(const char func[], int damaged)
{
	struct syslog_data sdata = SYSLOG_DATA_INIT;
	struct sigaction sa;
	sigset_t mask;

	/* Immediately block all signal handlers from running code */
	sigfillset(&mask);
	sigdelset(&mask, SIGABRT);
	sigprocmask(SIG_BLOCK, &mask, NULL);

	/* This may fail on a chroot jail... */
	syslog_r(LOG_CRIT, &sdata, message, func, damaged);

	memset(&sa, 0, sizeof(struct sigaction));
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;
	sa.sa_handler = SIG_DFL;
	sigaction(SIGABRT, &sa, NULL);

	arc4random_atexit();

	kill(getpid(), SIGABRT);

	_thread_sys__exit__(127);
}

void
__stack_chk_fail(void)
{
	__stack_smash_handler("unknown (libssp or pcc)", 0);
}
@


1.12
log
@adapt most __attribute__((…)) occurrences to new KNF style(9)
@
text
@d4 1
a4 1
 * Copyright © 2009, 2011, 2013
d39 1
a39 1
__RCSID("$MirOS: src/lib/libc/sys/stack_protector.c,v 1.11 2011/04/27 21:54:07 tg Exp $");
d57 2
a58 2
long __guard[8] = {0, 0, 0, 0, 0, 0, 0, 0};	/* gcc (3.4 ProPolice) */
int __stack_chk_guard;				/* gcc4 libssp and pcc */
d70 4
a73 2
	if (__guard[0] != 0)
		return;
d76 1
a76 1
		arc4random_buf(newguard, sizeof(newguard));
a81 4
	while (__stack_chk_guard == 0) {
		arc4random_buf(newguard, sizeof(__stack_chk_guard));
		memcpy(&__stack_chk_guard, newguard, sizeof(__stack_chk_guard));
	}
@


1.11
log
@• since we just ensured arc4random_atexit() is safe (as it calls only
  arc4random_roundhash which we just made safe, sysctl which is a
  syscall, and arcfour_byte which is safe (unsigned integer operations
  are defined as modulo in C), and bzero and dummy locking macros that
  expand to nothing in libc), we can call it from within the smash handler
• __stack_chk_guard and __stack_chk_fail aren’t just pcc; gcc 4 libssp
  seems to use them too, and they’re a freestandards.org API
• are we kidding? make message[] static!
@
text
@a0 1
/**	$MirOS: src/lib/libc/sys/stack_protector.c,v 1.10 2011/02/19 01:38:32 tg Exp $ */
d4 2
a5 1
 * Copyright (c) 2009, 2011 Thorsten Glaser
d39 1
a39 1
__RCSID("$MirOS: src/lib/libc/sys/stack_protector.c,v 1.10 2011/02/19 01:38:32 tg Exp $");
d51 1
a51 1
#define	CONSTRUCTOR	static __attribute__((constructor))
@


1.10
log
@… but since crt0/csu already includes arc4random fully, we can use it in setup
@
text
@d1 1
a1 1
/**	$MirOS: src/lib/libc/sys/stack_protector.c,v 1.9 2011/02/19 01:27:51 tg Exp $ */
d39 1
a39 1
__RCSID("$MirOS: src/lib/libc/sys/stack_protector.c,v 1.9 2011/02/19 01:27:51 tg Exp $");
d55 1
d57 2
a58 2
long __guard[8] = {0, 0, 0, 0, 0, 0, 0, 0};	/* gcc */
int __stack_chk_guard;				/* pcc */
d63 1
a63 1
const char message[] = "stack overflow in function %s (damaged: %d)";
d108 2
d118 1
a118 1
	__stack_smash_handler("unknown (pcc)", 0);
@


1.9
log
@this shouldn't run the atexit code
@
text
@d1 1
a1 1
/**	$MirOS: src/lib/libc/sys/stack_protector.c,v 1.8 2009/01/20 21:49:34 tg Exp $ */
a32 1
#include <sys/sysctl.h>
d34 1
d39 1
a39 1
__RCSID("$MirOS: src/lib/libc/sys/stack_protector.c,v 1.8 2009/01/20 21:49:34 tg Exp $");
a53 1
extern int __sysctl(int *, u_int, void *, size_t *, void *, size_t);
d67 1
a67 3
	int mib[2];
	size_t len;
	unsigned char *guard = (void *)__guard;
d72 10
a81 11
	mib[0] = CTL_KERN;
	mib[1] = KERN_ARND;

	len = sizeof(__guard);
	if (__sysctl(mib, 2, __guard, &len, NULL, 0) == -1 ||
	    (len != sizeof(__guard)) || (__guard[0] == 0)) {
		/* If sysctl was unsuccessful, use the "terminator canary". */
		guard[0] = 0;
		guard[1] = 0;
		guard[2] = '\n';
		guard[3] = 255;
a82 1
	memcpy(&__stack_chk_guard, guard, sizeof (__stack_chk_guard));
@


1.8
log
@bonus for the snapshot: pcc SSP functions in libc, too
why they didn’t use the gcc SSP ones… I’ll never understand gmcgarry
@
text
@d1 1
a1 1
/**	$MirOS: src/lib/libc/sys/stack_protector.c,v 1.7 2008/10/16 14:45:57 tg Exp $ */
d5 1
a5 1
 * Copyright (c) 2009 Thorsten Glaser
d39 1
a39 1
__RCSID("$MirOS: src/lib/libc/sys/stack_protector.c,v 1.7 2008/10/16 14:45:57 tg Exp $");
d55 1
d63 2
d92 1
a92 1
__stack_smash_handler(const char func[], __unused int damaged)
a94 1
	const char message[] = "stack overflow in function %s";
d104 1
a104 1
	syslog_r(LOG_CRIT, &sdata, message, func);
d114 1
a114 1
	_exit(127);
@


1.7
log
@much better
@
text
@d1 1
a1 1
/**	$MirOS: src/lib/libc/sys/stack_protector.c,v 1.6 2006/09/30 20:37:12 tg Exp $ */
d5 1
d39 1
a39 1
__RCSID("$MirOS: src/lib/libc/sys/stack_protector.c,v 1.6 2006/09/30 20:37:12 tg Exp $");
d48 2
d51 1
a51 1
#define	CONSTRUCTOR	static
d56 5
a60 3
long __guard[8] = {0, 0, 0, 0, 0, 0, 0, 0};
CONSTRUCTOR void __guard_setup(void) __attribute__((constructor));
__dead void __stack_smash_handler(char func[], int damaged);
d84 1
d89 1
a89 1
__stack_smash_handler(char func[], __unused int damaged)
d114 6
@


1.6
log
@merge speedup
@
text
@d1 1
a1 1
/**	$MirOS: src/lib/libc/sys/stack_protector.c,v 1.5 2005/09/22 20:48:50 tg Exp $ */
d38 1
a38 1
__RCSID("$MirOS: src/lib/libc/sys/stack_protector.c,v 1.5 2006/09/22 20:48:50 tg Exp $");
d40 3
a42 2
#if defined(__SSP_ALL__) && !defined(__IN_MKDEP) && !defined(lint)
 #error "You must compile this file with -fno-stack-protector-all"
@


1.5
log
@no #error if __IN_MKDEP
@
text
@d1 2
a2 2
/**	$MirOS: src/lib/libc/sys/stack_protector.c,v 1.4 2005/09/22 20:17:49 tg Exp $ */
/*	$OpenBSD: stack_protector.c,v 1.8 2005/08/08 08:05:37 espie Exp $	*/
d38 1
a38 1
__RCSID("$MirOS: src/lib/libc/sys/stack_protector.c,v 1.4 2005/09/22 20:17:49 tg Exp $");
d40 1
a40 1
#if defined(__SSP_ALL__) && !defined(__IN_MKDEP)
d53 2
a54 2
CONSTRUCTOR void __guard_setup(void) __attribute__ ((constructor));
void __stack_smash_handler(char func[], int damaged __attribute__((unused)));
d59 1
a59 1
	int i, mib[2];
d69 3
a71 9
	len = 4;
	for (i = 0; i < sizeof(__guard) / 4; i++) {
		if (__sysctl(mib, 2, guard,
		    &len, NULL, 0) == -1)
			break;
		guard += 4;
	}

	if (i < sizeof(__guard) / 4) {
d82 1
a82 1
__stack_smash_handler(char func[], int damaged)
@


1.4
log
@merge
@
text
@d1 1
a1 1
/**	$MirOS: src/lib/libc/sys/stack_protector.c,v 1.3 2005/04/17 01:42:22 tg Exp $ */
d38 1
a38 1
__RCSID("$MirOS: src/lib/libc/sys/stack_protector.c,v 1.3 2005/04/17 01:42:22 tg Exp $");
d40 1
a40 1
#ifdef __SSP_ALL__
@


1.3
log
@delint
@
text
@d1 2
a2 2
/**	$MirOS: src/lib/libc/sys/stack_protector.c,v 1.2 2005/03/06 20:28:49 tg Exp $ */
/*	$OpenBSD: stack_protector.c,v 1.7 2004/09/14 22:19:30 deraadt Exp $	*/
d38 1
a38 1
__RCSID("$MirOS: src/lib/libc/sys/stack_protector.c,v 1.2 2005/03/06 20:28:49 tg Exp $");
@


1.2
log
@merge src/lib
@
text
@d1 1
a1 1
/**	$MirOS$ */
d38 1
a38 1
__RCSID("$MirOS$");
d41 7
a47 1
#error "You must compile this file with -fno-stack-protector-all"
d53 1
a53 1
static void __guard_setup(void) __attribute__ ((constructor));
d56 1
a56 1
static void
d61 1
d71 1
a71 1
		if (__sysctl(mib, 2, (char *)&((int *)__guard)[i],
d74 1
d79 4
a82 4
		((unsigned char *)__guard)[0] = 0;
		((unsigned char *)__guard)[1] = 0;
		((unsigned char *)__guard)[2] = '\n';
		((unsigned char *)__guard)[3] = 255;
d86 1
@


1.1
log
@Initial revision
@
text
@d1 1
a30 4
#if defined(LIBC_SCCS) && !defined(list)
static char rcsid[] = "$OpenBSD: stack_protector.c,v 1.7 2004/09/14 22:19:30 deraadt Exp $";
#endif

d38 6
d94 1
a94 1
	bzero(&sa, sizeof(struct sigaction));
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import OpenBSD's libc as of today, minus some of the locale stuff,
and with brk malloc instead of mmap malloc
@
text
@d1 1
a1 1
/*	$OpenBSD: stack_protector.c,v 1.8 2005/08/08 08:05:37 espie Exp $	*/
d30 4
@


1.1.1.3
log
@sync with OpenBSD 4.0
@
text
@d1 1
a1 1
/*	$OpenBSD: stack_protector.c,v 1.10 2006/03/31 05:34:44 deraadt Exp $	*/
d46 1
a46 1
	int mib[2];
d55 8
a62 3
	len = sizeof(__guard);
	if (__sysctl(mib, 2, __guard, &len, NULL, 0) == -1 ||
	    len != sizeof(__guard)) {
a70 1
/*ARGSUSED*/
@


