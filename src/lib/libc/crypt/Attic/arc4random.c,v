head	1.31;
access;
symbols
	MIRBSD_10:1.12.0.2
	MIRBSD_10_BASE:1.12
	MIRBSD_9_BASE:1.5
	MIRBSD_8:1.3.0.2
	MIRBSD_8_BASE:1.3
	cvs-200509212000:1.1.1.2
	cvs-200507211800:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2010.09.12.17.10.52;	author tg;	state dead;
branches;
next	1.30;
commitid	1004C8D0939027D8BE7;

1.30
date	2010.09.12.12.24.29;	author tg;	state Exp;
branches;
next	1.29;
commitid	1004C8CC69150D1B4BD;

1.29
date	2010.01.16.20.29.41;	author tg;	state Exp;
branches;
next	1.28;
commitid	1004B5221B01604F5E4;

1.28
date	2010.01.06.19.11.54;	author tg;	state Exp;
branches;
next	1.27;
commitid	1004B44E03412A89242;

1.27
date	2010.01.06.17.52.32;	author tg;	state Exp;
branches;
next	1.26;
commitid	1004B44CDF76EA71CDB;

1.26
date	2009.11.29.15.29.25;	author tg;	state Exp;
branches;
next	1.25;
commitid	1004B1293503FBA3433;

1.25
date	2009.11.29.14.57.01;	author tg;	state Exp;
branches;
next	1.24;
commitid	1004B128BD37E8B48DA;

1.24
date	2009.11.09.22.35.50;	author tg;	state Exp;
branches;
next	1.23;
commitid	1004AF8995013E8DF46;

1.23
date	2009.11.09.21.58.39;	author tg;	state Exp;
branches;
next	1.22;
commitid	1004AF8909940C73519;

1.22
date	2009.01.21.19.41.37;	author tg;	state Exp;
branches;
next	1.21;
commitid	10049777A7F4BE988B2;

1.21
date	2009.01.21.19.38.45;	author tg;	state Exp;
branches;
next	1.20;
commitid	100497779C62F46751A;

1.20
date	2009.01.21.19.33.24;	author tg;	state Exp;
branches;
next	1.19;
commitid	10049777882582BA13F;

1.19
date	2008.12.27.21.17.54;	author tg;	state Exp;
branches;
next	1.18;
commitid	10049569B9439744217;

1.18
date	2008.12.06.18.05.33;	author tg;	state Exp;
branches;
next	1.17;
commitid	100493ABE6F284D4E41;

1.17
date	2008.10.20.10.41.52;	author tg;	state Exp;
branches;
next	1.16;
commitid	10048FC605C604CB3F7;

1.16
date	2008.07.06.15.34.46;	author tg;	state Exp;
branches;
next	1.15;
commitid	1004870E619397F7B3E;

1.15
date	2008.04.07.20.57.52;	author tg;	state Exp;
branches;
next	1.14;
commitid	10047FA8AD7422D7EAB;

1.14
date	2008.04.07.20.55.49;	author tg;	state Exp;
branches;
next	1.13;
commitid	10047FA8A6407F5792D;

1.13
date	2008.04.07.20.51.05;	author tg;	state Exp;
branches;
next	1.12;
commitid	10047FA893862D432E9;

1.12
date	2007.08.09.17.47.15;	author tg;	state Exp;
branches;
next	1.11;
commitid	10046BB533A4B4E48C7;

1.11
date	2007.08.09.17.28.55;	author tg;	state Exp;
branches;
next	1.10;
commitid	10046BB4EEE102748DC;

1.10
date	2007.08.09.17.13.09;	author tg;	state Exp;
branches;
next	1.9;
commitid	10046BB4AE668786D10;

1.9
date	2007.02.07.21.16.58;	author tg;	state Exp;
branches;
next	1.8;
commitid	10045CA41E17D3F4271;

1.8
date	2007.01.15.02.19.25;	author tg;	state Exp;
branches;
next	1.7;
commitid	10045AAE4AB103BEF0F;

1.7
date	2006.08.19.02.03.08;	author tg;	state Exp;
branches;
next	1.6;
commitid	10044E6716A6772EFD9;

1.6
date	2006.08.18.13.02.17;	author tg;	state Exp;
branches;
next	1.5;
commitid	10044E5BA6E310A62DF;

1.5
date	2006.06.09.10.02.53;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004489475038030224;

1.4
date	2006.06.02.02.29.45;	author tg;	state Exp;
branches;
next	1.3;
commitid	100447FA28346FF91C0;

1.3
date	2005.09.22.20.06.58;	author tg;	state Exp;
branches;
next	1.2;
commitid	696c43330ef70acb;

1.2
date	2005.03.06.20.28.34;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.24.38;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.24.38;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.07.21.20.52.19;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	560042e0092f571e;

1.1.1.3
date	2008.12.27.20.18.10;	author tg;	state Exp;
branches;
next	;
commitid	10049568D936F09B8CD;


desc
@@


1.31
log
@new implementation of arc4random(3) API (except arc4random_uniform(3),
which though has been split off earlier today)

deprecate arc4random_push arc4random_pushb arc4random_pushk
in favour of arc4random_pushb_fast as well

hide internal symbols from user with a version script (only some,
until the next major bump)

make deprecated functions into macros already

switch some kernel code to use the new shared code already; rewrite
of kernel arc4random(9) will come next/later
@
text
@/*	$OpenBSD: arc4random.c,v 1.20 2008/10/03 18:46:04 otto Exp $	*/

/*
 * Copyright (c) 2006, 2007, 2008, 2009, 2010
 *	Thorsten Glaser <tg@@mirbsd.org>
 * Copyright (c) 1996, David Mazieres <dm@@uun.org>
 * Copyright (c) 2008, Damien Miller <djm@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Arc4 random number generator for OpenBSD.
 *
 * This code is derived from section 17.1 of Applied Cryptography,
 * second edition, which describes a stream cipher allegedly
 * compatible with RSA Labs "RC4" cipher (the actual description of
 * which is a trade secret).  The same algorithm is used as a stream
 * cipher called "arcfour" in Tatu Ylonen's ssh package.
 *
 * Here the stream cipher has been modified always to include the time
 * when initializing the state.  That makes it impossible to
 * regenerate the same random sequence twice, so this can't be used
 * for encryption, but will generate good random numbers.
 *
 * RC4 is a registered trademark of RSA Laboratories.
 */

#include <sys/param.h>
#include <sys/sysctl.h>
#include <sys/taitime.h>
#include <fcntl.h>
#include <limits.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <syskern/libckern.h>
#include "thread_private.h"

__RCSID("$MirOS: src/lib/libc/crypt/arc4random.c,v 1.30 2010/09/12 12:24:29 tg Exp $");

struct arc4_stream {
	u_int8_t i;
	u_int8_t j;
	u_int8_t s[256];
};

static bool rs_initialized;
static struct arc4_stream rs;
static pid_t arc4_stir_pid;
static int arc4_count;

#if 0
static void arc4_add_lazy(const uint8_t *, size_t)
    __attribute__((__bounded__ (__string__,1,2)));
#endif
static uint8_t arc4_getbyte(void);
void arc4random_atexit(void);

void
arc4random_atexit(void)
{
	struct {
		pid_t spid;
		u_int cnt;
		u_int8_t carr[240];
	} buf;
	int mib[2];

	_ARC4_LOCK();
#if 0
	arc4_add_lazy(NULL, 0);		/* flush buffer */
#endif
	mib[0] = 0;
	while (mib[0] < 240)
		buf.carr[mib[0]++] = arc4_getbyte();
	buf.spid = arc4_stir_pid;
	buf.cnt = (u_int)arc4_count | (rs_initialized ? 0 : 0x80000000);
	_ARC4_UNLOCK();

	mib[0] = CTL_KERN;
	mib[1] = KERN_ARND;
	sysctl(mib, 2, NULL, NULL, &buf, sizeof (buf));
}

static void
arc4_init(void)
{
	int n;

	for (n = 0; n < 256; n++)
		rs.s[n] = (uint8_t)n;
	rs.i = 0;
	rs.j = 0;
}

static void
arc4_addrandom(const u_char *dat, size_t datlen)
{
	size_t n = 0;
	uint8_t si;

	rs.i--;
	while (n < 256) {
		rs.i++;
		si = rs.s[rs.i];
		rs.j = (uint8_t)(rs.j + si + dat[n++ % datlen]);
		rs.s[rs.i] = rs.s[rs.j];
		rs.s[rs.j] = si;
	}
	rs.i++;
	rs.j = rs.i;
}

static void
arc4_stir(void)
{
	int mib[2];
	size_t len;
	union {
		uint8_t charbuf[128];
		uint32_t intbuf[32];
		struct {
			tai64na_t wtime;
			struct timespec vtime;
			struct timespec ptime;
			struct timespec ntime;
			pid_t thepid;
		} alignedbuf;
	} sbuf;
	volatile uint8_t carryover;

	if (!rs_initialized) {
		arc4_init();
		rs_initialized = true;
	}

	carryover ^= (arc4_getbyte() & 0x0F);
	taina_time(&sbuf.alignedbuf.wtime);
	sbuf.alignedbuf.thepid = arc4_stir_pid = getpid();
	clock_gettime(CLOCK_VIRTUAL, &sbuf.alignedbuf.vtime);
	clock_gettime(CLOCK_PROF, &sbuf.alignedbuf.ptime);
	clock_gettime(CLOCK_MONOTONIC, &sbuf.alignedbuf.ntime);
	arc4_addrandom(sbuf.charbuf, sizeof (sbuf.alignedbuf));
	carryover ^= (arc4_getbyte() & 0xF0);

	mib[0] = CTL_KERN;
	mib[1] = KERN_ARND;

	len = sizeof (sbuf);
	sysctl(mib, 2, sbuf.charbuf, &len, NULL, 0);

	/* discard by a randomly fuzzed factor as well */
	len = 256 * 4 + (arc4_getbyte() & 0x0F) + carryover;
	arc4_addrandom(sbuf.charbuf, sizeof (sbuf));

	/*
	 * Discard early keystream, as per recommendations in:
	 * http://www.wisdom.weizmann.ac.il/~itsik/RC4/Papers/Rc4_ksa.ps
	 */
	while (len--)
		(void)arc4_getbyte();
	arc4_count = 1600000;
}

static uint8_t
arc4_getbyte(void)
{
	uint8_t si, sj;

	rs.i++;
	si = rs.s[rs.i];
	rs.j = (uint8_t)(rs.j + si);
	sj = rs.s[rs.j];
	rs.s[rs.i] = sj;
	rs.s[rs.j] = si;
	return (rs.s[(si + sj) & 0xff]);
}

static uint32_t
arc4_getword(void)
{
	uint32_t val;
	val = (uint32_t)arc4_getbyte() << 24;
	val |= (uint32_t)arc4_getbyte() << 16;
	val |= (uint32_t)arc4_getbyte() << 8;
	val |= (uint32_t)arc4_getbyte();
	return (val);
}

void
arc4random_stir(void)
{
	_ARC4_LOCK();
	arc4_stir();
	_ARC4_UNLOCK();
}

void
arc4random_addrandom(u_char *dat, int datlen)
{
	_ARC4_LOCK();
	if (!rs_initialized)
		arc4_stir();
	arc4_addrandom(dat, datlen);
	_ARC4_UNLOCK();
}

#if 0
/* len=0: flush; len=1..128: normal operation; 128..~238: inval/possible */
static void
arc4_add_lazy(const uint8_t *buf, size_t len)
{
	static uint8_t arc4_lazybuf[256];
	static uint8_t arc4_lazyfree = 0;
	static struct timeval arc4_lazytv = { 0, 0 };
	struct timeval curtv;

	/* assert(len <= 128); */

	if (arc4_lazyfree == 0) {
 arc4_lazy_start:
		if (len == 0)
			return;
		arc4_lazybuf[0] = arc4_getbyte();
		arc4_lazyfree = 255;
	}

	if (len == 0 || (len + sizeof(uint64_t)) > arc4_lazyfree) {
		int i = 256 - arc4_lazyfree, j;

		j = 256 + (arc4_getbyte() & 0x0F);
		/* diffusion, so that input is weighted the same */
		while (i < 256)
			arc4_lazybuf[i++] = arc4_getbyte();
		arc4_addrandom(arc4_lazybuf, 256);
		j += arc4_getbyte() & 0x0F;
		/* throw away some; fewer than normal stir though */
		while (j--)
			(void)arc4_getbyte();
		/* reset pool and re-do */
		goto arc4_lazy_start;
	}

	if (!gettimeofday(&curtv, NULL)) {
		struct timeval deltatv;
		uint64_t deltaval;

		timersub(&curtv, &arc4_lazytv, &deltatv);
		deltaval = deltatv.tv_sec * 1000000 + deltatv.tv_usec;
		arc4_lazytv = curtv;
		while (deltaval) {
			arc4_lazybuf[256 - arc4_lazyfree--] = deltaval & 0xFF;
			deltaval >>= 8;
		}
	}

	memcpy(arc4_lazybuf + 256 - arc4_lazyfree, buf, len);
	arc4_lazyfree -= len;
}

void
arc4random_add_lazy(const void *buf, size_t len)
{
	_ARC4_LOCK();
	if (!rs_initialized)
		arc4_stir();
	_ARC4_UNLOCK();

	while (len > 128) {
		_ARC4_LOCK();
		arc4_addrandom(buf, 128);
		_ARC4_UNLOCK();
		buf = (const char *)buf + 128;
		len -= 128;
	}

	if (len) {
		_ARC4_LOCK();
		arc4_add_lazy(buf, len);
		_ARC4_UNLOCK();
	}
}
#endif

u_int32_t
arc4random(void)
{
	u_int32_t val;
	_ARC4_LOCK();
	arc4_count -= 4;
	if (arc4_count <= 0 || !rs_initialized || arc4_stir_pid != getpid())
		arc4_stir();
	if (arc4_getbyte() & 1)
		(void)arc4_getbyte();
	val = arc4_getword();
	_ARC4_UNLOCK();
	return val;
}

void
arc4random_buf(void *_buf, size_t n)
{
	u_char *buf = (u_char *)_buf;
	_ARC4_LOCK();
	if (!rs_initialized || arc4_stir_pid != getpid())
		arc4_stir();
	buf[0] = arc4_getbyte() % 3;
	while (buf[0]--)
		(void)arc4_getbyte();
	while (n--) {
		if (--arc4_count <= 0)
			arc4_stir();
		buf[n] = arc4_getbyte();
	}
	_ARC4_UNLOCK();
}

void
arc4random_push(int n)
{
	arc4random_pushb(&n, sizeof (int));
}

uint32_t
arc4random_pushb(const void *buf, size_t len)
{
	size_t j;
	int mib[2];
	union {
		uint8_t buf[256];
		struct {
			tai64na_t tai64tm;
			const void *sp, *dp;
			size_t sz;
			uint32_t vu;
		} s;
	} uu;
	struct {
		uint32_t h;
		uint16_t u;
		uint8_t k[10];
	} av;

	{
		register uint32_t h;
		register size_t n = 0;
		register uint8_t c;

		av.u = arc4random() & 0xFFFF;
		uu.s.sp = &uu;
		uu.s.dp = buf;
		uu.s.sz = len;
		uu.s.vu = arc4random();
		taina_time(&uu.s.tai64tm);

		h = OAAT0Update(arc4random() & 0xFFFFFF00,
		    (void *)&uu, sizeof(uu.s));
		j = MAX(len, sizeof(uu.s));

		while (n < j) {
			c = ((const uint8_t *)buf)[n % len];
			uu.buf[n % sizeof(uu.buf)] ^= c;
			h += c;
			h += h << 10;
			h ^= h >> 6;
			++n;
		}

		len = MIN(sizeof(uu), j);
		av.h = OAAT0Final(h);
	}

	mib[0] = CTL_KERN;
	mib[1] = KERN_ARND;
	j = sizeof(av.k);

	av.u += sysctl(mib, 2, av.k, &j, &uu, len);

	_ARC4_LOCK();
	arc4_addrandom((void *)&av, sizeof(av));
	if (arc4_getbyte() & 1)
		(void)arc4_getbyte();
	av.h = arc4_getword();
	_ARC4_UNLOCK();

	return (av.h);
}

#if 0
/*-------- Test code for i386 --------*/
#include <stdio.h>
#include <machine/pctr.h>
int
main(int argc, char **argv)
{
	const int iter = 1000000;
	int     i;
	pctrval v;

	v = rdtsc();
	for (i = 0; i < iter; i++)
		arc4random();
	v = rdtsc() - v;
	v /= iter;

	printf("%qd cycles\n", v);
}
#endif
@


1.30
log
@• kern/c/arc4random_uniform.c, kern/include/libckern.h: move
  arc4random_uniform(3) implementation here
• kern/c/Makefile.inc: build arc4random_uniform.c kernel/user
• lib/libc/crypt/arc4random.c, sys/dev/rnd.c: remove implementation here
• sys/dev/rndvar.h: prototype is now in <libckern.h>
• contrib/code/Snippets/arc4random.c: sync with master implementation
@
text
@d51 1
a51 1
__RCSID("$MirOS: src/lib/libc/crypt/arc4random.c,v 1.29 2010/01/16 20:29:41 tg Exp $");
@


1.29
log
@add (if 0’d) arc4random_add_lazy – will be added when we really need/use
it, maybe with a push_lazy variant as well – and a small bugfix
@
text
@d51 1
a51 1
__RCSID("$MirOS: src/lib/libc/crypt/arc4random.c,v 1.28 2010/01/06 19:11:54 tg Exp $");
a329 54
/*
 * Calculate a uniformly distributed random number less than upper_bound
 * avoiding "modulo bias".
 *
 * Uniformity is achieved by generating new random numbers until the one
 * returned is outside the range [0, 2**32 % upper_bound).  This
 * guarantees the selected random number will be inside
 * [2**32 % upper_bound, 2**32) which maps back to [0, upper_bound)
 * after reduction modulo upper_bound.
 */
u_int32_t
arc4random_uniform(u_int32_t upper_bound)
{
	u_int32_t r, min;

	if (upper_bound < 2)
		return 0;

#if (ULONG_MAX > 0xFFFFFFFFUL)
	min = 0x100000000UL % upper_bound;
#else
	/* Calculate (2**32 % upper_bound) avoiding 64-bit math */
	if (upper_bound > 0x80000000U)
		/* 2**32 - upper_bound (only one "value area") */
		min = 1 + ~upper_bound;
	else
		/* (2**32 - x) % x == 2**32 % x when x <= 2**31 */
		min = (0xFFFFFFFFU - upper_bound + 1) % upper_bound;
#endif

	/*
	 * This could theoretically loop forever but each retry has
	 * p > 0.5 (worst case, usually far better) of selecting a
	 * number inside the range we need, so it should rarely need
	 * to re-roll.
	 */
	_ARC4_LOCK();
	if (!rs_initialized || arc4_stir_pid != getpid())
		arc4_stir();
	if (arc4_getbyte() & 1)
		(void)arc4_getbyte();
	for (;;) {
		arc4_count -= 4;
		if (arc4_count <= 0)
			arc4_stir();
		r = arc4_getword();
		if (r >= min)
			break;
	}
	_ARC4_UNLOCK();

	return r % upper_bound;
}

@


1.28
log
@With the test programme below, I also have double-checked the
arc4random_uniform interna. Thus, sync it across all the dif-
ferent implemementations for better comprehension.

begin 644 test.c.gz
M'XL(```````"`UV036O#,`R&S_:O>-=1L)MN)$X(A7X<=^JUL,-@@C"6EAM0=
M:=(:UNRW3[83ME076=*C5[(>M?FLVJ+$ZMP4^O1\V'"N3<./']J(RTD7DG]S
MUE(JS]X;V#GJ/%N&3*I<)E642]6QK;Q?<LXLUH@@)NAYT54)$D<4*L4WBWG;;
MK03),M)RZ*B"*2SU,A*FFG_J/80+-X0N!C(HL#":R-KS"2+\6+<&8QW*ZES>
M84+$]J6W'9Z"\`Q04E)K(MWXT,Z"XC^><$>/L:Y?T/WE(:QQN^$OHK'2J7W5
M=+*]F-CU-%Z\(L^"3]5,#2_OW\QD[J_JFD`FAEM+$AW=6M)\&E^735L;6I3B
+CO\"?M$\_-(!````
`
end
@
text
@d51 1
a51 1
__RCSID("$MirOS: src/lib/libc/crypt/arc4random.c,v 1.27 2010/01/06 17:52:32 tg Exp $");
d64 4
d82 3
d89 1
a89 1
	buf.cnt = (u_int)arc4_count | rs_initialized ? 0 : 0x80000000;
d220 77
@


1.27
log
@fix a coding error in the KSA found by myself reading several descriptions of aRC4
@
text
@d4 2
a5 1
 * Copyright (c) 2006, 2007, 2008, 2009 Thorsten Glaser <tg@@mirbsd.org>
d51 1
a51 1
__RCSID("$MirOS: src/lib/libc/crypt/arc4random.c,v 1.26 2009/11/29 15:29:25 tg Exp $");
d264 1
a264 1
#if (ULONG_MAX > 0xffffffffUL)
d268 6
a273 6
	if (upper_bound > 0x80000000)
		min = 1 + ~upper_bound;		/* 2**32 - upper_bound */
	else {
		/* (2**32 - (x * 2)) % x == 2**32 % x when x <= 2**31 */
		min = ((0xffffffff - (upper_bound * 2)) + 1) % upper_bound;
	}
@


1.26
log
@make things const that should be const where we can,
complain about things where we cannot change the API
designed by const-dirty OpenBSDdiots
@
text
@d50 1
a50 1
__RCSID("$MirOS: src/lib/libc/crypt/arc4random.c,v 1.25 2009/11/29 14:57:01 tg Exp $");
d114 1
@


1.25
log
@again, improved entropy pass behaviour in arc4random_pushb (and pushk,
which has been the same for quite a while)
@
text
@d50 1
a50 1
__RCSID("$MirOS: src/lib/libc/crypt/arc4random.c,v 1.24 2009/11/09 22:35:50 tg Exp $");
d101 1
a101 1
arc4_addrandom(u_char *dat, int datlen)
d103 1
a103 1
	int n;
d107 1
a107 1
	for (n = 0; n < 256; n++) {
d110 1
a110 1
		rs.j = (uint8_t)(rs.j + si + dat[n % datlen]);
@


1.24
log
@feature- and style-sync Snippets/arc4random.c and libc’s with each other
@
text
@d50 1
a50 1
__RCSID("$MirOS: src/lib/libc/crypt/arc4random.c,v 1.23 2009/11/09 21:58:39 tg Exp $");
a306 1
	uint32_t h, vu, vk;
a310 1
		tai64na_t tai64tm;
d312 1
d315 1
a316 3
		struct {
			uint32_t h, v;
		} u;
d318 10
d329 19
a347 5
	vu = arc4random();
	uu.s.sp = &uu;
	uu.s.dp = buf;
	uu.s.sz = len;
	h = OAAT0Update(arc4random() & 0xFFFFFF00, (void *)&uu, sizeof(uu.s));
d349 2
a350 9
	taina_time(&uu.tai64tm);
	for (j = 0; j < len; ++j) {
		register uint8_t c;

		c = ((const uint8_t *)buf)[j];
		uu.buf[j % 256] ^= c;
		h += c;
		h += h << 10;
		h ^= h >> 6;
a351 1
	len = MIN(256, len);
d355 1
a355 1
	j = sizeof(vk);
d357 1
a357 2
	if (sysctl(mib, 2, &vk, &j, &uu, len) != 0)
		vk = 0;
a358 2
	uu.u.h = OAAT0Final(h);
	uu.u.v = (vk & 0xFFFF0000) | (vu & 0x0000FFFF);
d360 4
a363 1
	arc4_addrandom((void *)&uu, sizeof(uu.u));
a364 2
	if (/* kernel failed */ !vk)
		vk = arc4random();
d366 1
a366 1
	return ((vk & 0x0000FFFF) ^ (vu & 0xFFFF0000) ^ (uu.u.h & 0x00073000));
@


1.23
log
@reword arc4random_pushb(3) – cleaner, leaner, hashier
@
text
@d50 1
a50 7
__RCSID("$MirOS: src/lib/libc/crypt/arc4random.c,v 1.22 2009/01/21 19:41:37 tg Exp $");

#ifdef __GNUC__
#define inline __inline
#else				/* !__GNUC__ */
#define inline
#endif				/* !__GNUC__ */
d63 1
a63 1
static inline u_int8_t arc4_getbyte(void);
d89 1
a89 1
static inline void
d92 1
a92 1
	int     n;
d95 1
a95 1
		rs.s[n] = n;
d100 1
a100 1
static inline void
d103 2
a104 2
	int     n;
	u_int8_t si;
d108 1
a108 1
		rs.i = (rs.i + 1);
d110 1
a110 1
		rs.j = (rs.j + si + dat[n % datlen]);
d168 1
a168 1
static u_int8_t
d171 1
a171 1
	u_int8_t si, sj;
d173 1
a173 1
	rs.i = (rs.i + 1);
d175 1
a175 1
	rs.j = (rs.j + si);
d182 1
a182 1
static inline u_int32_t
d185 6
a190 6
	u_int32_t val;
	val = arc4_getbyte() << 24;
	val |= arc4_getbyte() << 16;
	val |= arc4_getbyte() << 8;
	val |= arc4_getbyte();
	return val;
@


1.22
log
@throw away before, not after (more PFS)
@
text
@d47 1
d50 1
a50 1
__RCSID("$MirOS: src/lib/libc/crypt/arc4random.c,v 1.21 2009/01/21 19:38:45 tg Exp $");
d313 1
a313 1
	uint32_t v, i, k, tr;
d319 14
a332 2
		uint32_t xbuf[2];
	} idat;
d334 1
a334 3
	tr = arc4random();
	v = (rand() << 16) + len;
	taina_time(&idat.tai64tm);
d339 4
a342 2
		v += c;
		idat.buf[j % 256] ^= c;
d344 1
a344 4
	j = MAX(sizeof (tai64na_t), 2 * sizeof (uint32_t));
	len = MIN(256, MAX(j, len));
	v += (k = arc4random()) & 3;
	v += (intptr_t)buf & 0xFFFFFFFF;
d348 4
a351 1
	j = sizeof (i);
d353 2
a354 10
	idat.xbuf[1] ^= tr;
	if (sysctl(mib, 2, &i, &j, &idat.buf[0], len) != 0)
		i = idat.xbuf[0] ^
		    (((v & 1) + 1) * (rand() & 0xFF)) ^ arc4random();
	/* idat.xbuf[1] ^= tr; // dead because of the following line: */

	taina_time(&idat.tai64tm);
	idat.xbuf[0] ^= v;
	idat.xbuf[1] ^= i ^ (k & 12);
	j = MAX(sizeof (tai64na_t), 2 * sizeof (uint32_t));
d356 1
a356 1
	arc4_addrandom(&idat.buf[0], j);
d358 2
d361 1
a361 1
	return ((k & ~15) ^ i);
@


1.21
log
@throw away single arc4_getbyte()s at random on request, as we do in kernel
@
text
@d49 1
a49 1
__RCSID("$MirOS: src/lib/libc/crypt/arc4random.c,v 1.20 2009/01/21 19:33:24 tg Exp $");
a223 1
	val = arc4_getword();
d226 1
d238 3
a245 3
	n = arc4_getbyte() % 3;
	while (n--)
		(void)arc4_getbyte();
d288 2
a297 2
	if (arc4_getbyte() & 1)
		(void)arc4_getbyte();
@


1.20
log
@• remove a dead line of code
• ensure some more fuzz in initial keystream throwaway
@
text
@d49 1
a49 1
__RCSID("$MirOS: src/lib/libc/crypt/arc4random.c,v 1.19 2008/12/27 21:17:54 tg Exp $");
d173 1
a173 1
static inline u_int8_t
d225 2
d243 3
d285 3
d289 4
a292 1
		r = arc4random();
d296 3
@


1.19
log
@merge and wrap exec/exit functions better
@
text
@d4 1
a4 1
 * Copyright (c) 2006, 2007, 2008 Thorsten Glaser <tg@@mirbsd.de>
d49 1
a49 1
__RCSID("$MirOS: src/lib/libc/crypt/arc4random.c,v 1.18 2008/12/06 18:05:33 tg Exp $");
d138 1
d145 1
d152 1
d161 1
a161 1
	len = 256 * 4 + (arc4_getbyte() & 0x0F);
d330 1
a330 1
	idat.xbuf[1] ^= tr;
@


1.18
log
@use user-space programmes as a sort of fifth entropy pool by pushing
entropy to kernel atexit(3) - imperfect (could do better by using the
entire state information plus time and pid, calculate space better, etc.)
and pending an arc4random.c total rewrite, but for that I'd like to add
the new APIs from obsd-current (_bytes and _uniform) first and read the
books mentioned, so we do this "el cheapo" for now => increases amount
of entropy in overall system circulation and modelling difficulty raises
@
text
@d1 1
a1 2
/**	$MirOS: src/lib/libc/crypt/arc4random.c,v 1.17 2008/10/20 10:41:52 tg Exp $ */
/*	$OpenBSD: arc4random.c,v 1.14 2005/06/06 14:57:59 kjell Exp $	*/
d6 1
d12 7
a18 10
 * The following disclaimer must also be retained:
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
d42 2
d47 1
d49 1
a49 1
__RCSID("$MirOS: src/lib/libc/crypt/arc4random.c,v 1.17 2008/10/20 10:41:52 tg Exp $");
d63 1
a63 1
static int rs_initialized;
d68 2
a69 2
static inline u_int8_t arc4_getbyte(struct arc4_stream *);
static void arc4_atexit(void);
d71 2
a72 2
static void
arc4_atexit(void)
d76 1
a76 1
		int cnt;
d81 1
d84 1
a84 1
		buf.carr[mib[0]++] = arc4_getbyte(&rs);
d86 2
a87 1
	buf.cnt = arc4_count;
d95 1
a95 1
arc4_init(struct arc4_stream *as)
d100 3
a102 3
		as->s[n] = n;
	as->i = 0;
	as->j = 0;
d106 1
a106 1
arc4_addrandom(struct arc4_stream *as, uint8_t *dat, int datlen)
d111 1
a111 1
	as->i--;
d113 5
a117 5
		as->i = (as->i + 1);
		si = as->s[as->i];
		as->j = (as->j + si + dat[n % datlen]);
		as->s[as->i] = as->s[as->j];
		as->s[as->j] = si;
d119 1
a119 1
	as->j = as->i;
d123 1
a123 1
arc4_stir(struct arc4_stream *as)
d125 1
a125 1
	int     mib[2];
d139 5
d149 1
a149 1
	arc4_addrandom(as, sbuf.charbuf, sizeof (sbuf.alignedbuf));
d154 3
a156 11
	len = 128;
	if (sysctl(mib, 2, &sbuf.charbuf, &len, NULL, 0) == -1) {
		size_t i;

		for (i = 0; i < 32; i++) {
			len = 4;
			if (sysctl(mib, 2, &sbuf.intbuf[i], &len,
			    NULL, 0) == -1)
				break;
		}
	}
d158 2
a159 2
	len = 256 * 4 + (arc4_getbyte(as) & 0x0F);
	arc4_addrandom(as, sbuf.charbuf, sizeof (sbuf));
d166 2
a167 2
		(void)arc4_getbyte(as);
	arc4_count = 400000;
d171 1
a171 1
arc4_getbyte(struct arc4_stream *as)
d175 7
a181 7
	as->i = (as->i + 1);
	si = as->s[as->i];
	as->j = (as->j + si);
	sj = as->s[as->j];
	as->s[as->i] = sj;
	as->s[as->j] = si;
	return (as->s[(si + sj) & 0xff]);
d185 1
a185 1
arc4_getword(struct arc4_stream *as)
d188 4
a191 4
	val = arc4_getbyte(as) << 24;
	val |= arc4_getbyte(as) << 16;
	val |= arc4_getbyte(as) << 8;
	val |= arc4_getbyte(as);
d198 3
a200 6
	if (!rs_initialized) {
		arc4_init(&rs);
		rs_initialized = 1;
		atexit(arc4_atexit);
	}
	arc4_stir(&rs);
d206 1
d208 3
a210 2
		arc4random_stir();
	arc4_addrandom(&rs, dat, datlen);
d216 68
a283 3
	if (--arc4_count == 0 || !rs_initialized || arc4_stir_pid != getpid())
		arc4random_stir();
	return arc4_getword(&rs);
d333 3
a335 1
	arc4_addrandom(&rs, &idat.buf[0], j);
d339 21
@


1.17
log
@discarding the initial key stream wants us to get rid of
256 “long words” of 32 bit, not of 256 bytes… (plus that
fuzzy factor of ours I added)

spotted while improving contrib/code/Snippets/arc4random.c
@
text
@d1 1
a1 1
/**	$MirOS: src/lib/libc/crypt/arc4random.c,v 1.16 2008/07/06 15:34:46 tg Exp $ */
d49 1
a49 1
__RCSID("$MirOS: src/lib/libc/crypt/arc4random.c,v 1.16 2008/07/06 15:34:46 tg Exp $");
d69 22
d202 1
@


1.16
log
@add a little uncertainty to the arc4random_pushb(3) functionality
@
text
@d1 1
a1 1
/**	$MirOS: src/lib/libc/crypt/arc4random.c,v 1.15 2008/04/07 20:57:52 tg Exp $ */
d49 1
a49 1
__RCSID("$MirOS: src/lib/libc/crypt/arc4random.c,v 1.15 2008/04/07 20:57:52 tg Exp $");
d102 1
a102 1
	size_t	i, len;
d127 2
d137 1
a137 1
	len = 256 + (arc4_getbyte(as) & 0x0F);
d144 1
a144 1
	for (i = 0; i < len; i++)
@


1.15
log
@even better and fix a bug when passing >256 args *sigh*
*gets a coffee*
@
text
@d1 1
a1 1
/**	$MirOS: src/lib/libc/crypt/arc4random.c,v 1.14 2008/04/07 20:55:49 tg Exp $ */
d5 1
a5 1
 * Copyright (c) 2006, 2007 Thorsten Glaser <tg@@mirbsd.de>
d49 1
a49 1
__RCSID("$MirOS: src/lib/libc/crypt/arc4random.c,v 1.14 2008/04/07 20:55:49 tg Exp $");
d207 1
a207 1
	uint32_t v, i, k;
d216 1
d235 1
d239 1
@


1.14
log
@I knew it… a revision 1.13 is bad luck
@
text
@d1 1
a1 1
/**	$MirOS: src/lib/libc/crypt/arc4random.c,v 1.13 2008/04/07 20:51:05 tg Exp $ */
d49 1
a49 1
__RCSID("$MirOS: src/lib/libc/crypt/arc4random.c,v 1.13 2008/04/07 20:51:05 tg Exp $");
d225 2
a226 4
	while (j < 256) {
		idat.buf[j] ^= ((const uint8_t *)buf)[j % len];
		j++;
	}
@


1.13
log
@make arc4random_pushb internally a little more KISS like arc4random_pushk;
also allows more than 256 bytes of argument (they get folded then)
@
text
@d1 1
a1 1
/**	$MirOS: src/lib/libc/crypt/arc4random.c,v 1.12 2007/08/09 17:47:15 tg Exp $ */
d49 1
a49 1
__RCSID("$MirOS: src/lib/libc/crypt/arc4random.c,v 1.12 2007/08/09 17:47:15 tg Exp $");
d225 1
a225 1
	while (j < 256)
d227 2
@


1.12
log
@while time isn’t a secret, it certainly helps sometimes; I’d add truerand() to the mix but it’s too hard from within libc
@
text
@d1 1
a1 1
/**	$MirOS: src/lib/libc/crypt/arc4random.c,v 1.11 2007/08/09 17:28:55 tg Exp $ */
d49 1
a49 1
__RCSID("$MirOS: src/lib/libc/crypt/arc4random.c,v 1.11 2007/08/09 17:28:55 tg Exp $");
d210 5
a214 2
	uint8_t sbuf[256];
	tai64na_t tai64tm;
d217 10
a226 3
	for (j = 0; j < len; ++j)
		v += ((const uint8_t *)buf)[j];
	len = MAX(MIN(len, 256), sizeof (tai64na_t));
a227 2
	memmove(sbuf, buf, len);
	taina_time(&tai64tm);
a228 2
	for (j = 0; j < sizeof (tai64na_t); ++j)
		sbuf[j] ^= ((uint8_t *)&tai64tm)[j];
d234 9
a242 9
	if (sysctl(mib, 2, &i, &j, sbuf, len) != 0) {
		memcpy(&i, sbuf + len - 1 - sizeof (i), sizeof (i));
		i ^= (((v & 1) + 1) * (rand() & 0xFF)) ^ arc4random();
	}

	memcpy(sbuf, &v, sizeof (uint32_t));
	memcpy(sbuf + sizeof (uint32_t), &i, sizeof (uint32_t));
	memcpy(sbuf + 2 * sizeof (uint32_t), &tai64tm, sizeof (tai64na_t));
	arc4_addrandom(&rs, sbuf, 2 * sizeof (uint32_t) + sizeof (tai64na_t));
d244 1
a244 1
	return ((k & ~3) ^ i);
@


1.11
log
@solve alignment issues (on sparc and with __CRAZY=Yes) by use of a union
@
text
@d1 1
a1 1
/**	$MirOS: src/lib/libc/crypt/arc4random.c,v 1.10 2007/08/09 17:13:09 tg Exp $ */
d49 1
a49 1
__RCSID("$MirOS: src/lib/libc/crypt/arc4random.c,v 1.10 2007/08/09 17:13:09 tg Exp $");
d107 4
a110 1
			tai64na_t thetime;
d115 1
a115 1
	taina_time(&sbuf.alignedbuf.thetime);
d117 4
a120 1
	arc4_addrandom(as, sbuf.charbuf, sizeof (tai64na_t) + sizeof (pid_t));
@


1.10
log
@• take pid and time more/better into account when stirring or a4_pushb, and
  throw away less information supplied by the user on the latter
• __CRAZY=Yes clean
@
text
@d1 1
a1 1
/**	$MirOS: src/lib/libc/crypt/arc4random.c,v 1.9 2007/02/07 21:16:58 tg Exp $ */
d49 1
a49 1
__RCSID("$MirOS: src/lib/libc/crypt/arc4random.c,v 1.9 2007/02/07 21:16:58 tg Exp $");
d82 1
a82 1
arc4_addrandom(struct arc4_stream *as, u_char *dat, int datlen)
d103 12
a114 7
	u_char rnd[128] __attribute__((aligned (16)));

	len = sizeof (tai64na_t);
	taina_time((tai64na_t *)&rnd);
	*((pid_t *)(rnd + len)) = arc4_stir_pid = getpid();
	len += sizeof (pid_t);
	arc4_addrandom(as, rnd, len);
d119 5
a123 5
	len = sizeof(rnd);
	if (sysctl(mib, 2, rnd, &len, NULL, 0) == -1) {
		for (i = 0; i < sizeof(rnd) / sizeof(u_int); i ++) {
			len = sizeof(u_int);
			if (sysctl(mib, 2, &rnd[i * sizeof(u_int)], &len,
d130 1
a130 1
	arc4_addrandom(as, rnd, sizeof(rnd));
d222 4
a225 3
	if (sysctl(mib, 2, &i, &j, sbuf, len) != 0)
		i = (((v & 1) + 1) * (rand() & 0xFF)) ^ arc4random() ^
		    *((uint32_t *)(sbuf + (len - 4)));
@


1.9
log
@taitime.h missing include
@
text
@d1 1
a1 1
/**	$MirOS: src/lib/libc/crypt/arc4random.c,v 1.8 2007/01/15 02:19:25 tg Exp $ */
d49 1
a49 1
__RCSID("$MirOS: src/lib/libc/crypt/arc4random.c,v 1.8 2007/01/15 02:19:25 tg Exp $");
d103 1
a103 2
	u_char rnd[128];
	tai64na_t tm;
d105 5
a109 2
	taina_time(&tm);
	arc4_addrandom(as, (void *)&tm, sizeof (tm));
d123 2
a124 2

	arc4_stir_pid = getpid();
d131 1
a131 1
	for (i = 0; i < 256; i++)
d200 1
d204 2
a205 2
		v += ((uint8_t *)buf)[j];
	len = MIN(len, 256 - sizeof (tai64na_t));
d207 2
a208 3
	memmove(sbuf + sizeof (tai64na_t), buf, len);
	taina_time((void *)sbuf);
	len += sizeof (tai64na_t);
d210 2
d221 4
a224 4
	len = sizeof (uint32_t);
	memmove(sbuf, &v, len);
	memmove(sbuf + len, &i, len);
	arc4_addrandom(&rs, sbuf, 2 * len);
@


1.8
log
@oops, rand() not random() where we deliberately use
non-strong data from other sources; shrinks this some
@
text
@d1 1
a1 1
/**	$MirOS: src/lib/libc/crypt/arc4random.c,v 1.7 2006/08/19 02:03:08 tg Exp $ */
d43 1
a46 1
#include <time.h>
d49 1
a49 1
__RCSID("$MirOS: src/lib/libc/crypt/arc4random.c,v 1.7 2006/08/19 02:03:08 tg Exp $");
@


1.7
log
@the implementation was good, the specification lacked a const...
@
text
@d1 1
a1 1
/**	$MirOS: src/lib/libc/crypt/arc4random.c,v 1.6 2006/08/18 13:02:17 tg Exp $ */
d5 1
a5 1
 * Copyright (c) 2006 Thorsten Glaser <tg@@mirbsd.de>
d12 10
a21 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d49 1
a49 1
__RCSID("$MirOS: src/lib/libc/crypt/arc4random.c,v 1.6 2006/08/18 13:02:17 tg Exp $");
d199 1
a199 1
	v = (random() << 16) + len;
d214 2
a215 2
		i = (((v & 1) + 1) * (random() & 0xFF)) ^ arc4random()
		    ^ *((uint32_t *)(sbuf + (len - 4)));
@


1.6
log
@implement new arc4random_pushb(3) API
@
text
@d1 1
a1 1
/**	$MirOS: src/lib/libc/crypt/arc4random.c,v 1.5 2006/06/09 10:02:53 tg Exp $ */
d46 1
a46 1
__RCSID("$MirOS: src/lib/libc/crypt/arc4random.c,v 1.5 2006/06/09 10:02:53 tg Exp $");
d189 1
a189 1
arc4random_pushb(void *buf, size_t len)
@


1.5
log
@_do_ stir with the current time as well
@
text
@d1 1
a1 1
/**	$MirOS: src/lib/libc/crypt/arc4random.c,v 1.4 2006/06/02 02:29:45 tg Exp $ */
d5 1
d42 1
d46 1
a46 1
__RCSID("$MirOS: src/lib/libc/crypt/arc4random.c,v 1.4 2006/06/02 02:29:45 tg Exp $");
d185 20
a204 2
	int     i, mib[2];
	size_t	len = sizeof(int);
d208 10
d219 1
a219 7
	/* supply n to kernel and get back another random int */
	if (!sysctl(mib, 2, &i, &len, &n, sizeof(int)))
		/*
		 * do not add the n, but rather the kernel-supplied
		 * new random value to our local arc4 generator
		 */
		arc4_addrandom(&rs, (u_char *)&i, len);
@


1.4
log
@__CRAZY cleanliness for most of libc
not: net/rpc/etc., time, thread, sys
@
text
@d1 1
a1 1
/**	$MirOS: src/lib/libc/crypt/arc4random.c,v 1.3 2005/09/22 20:06:58 tg Exp $ */
a37 1
#include <sys/time.h>
d41 1
d44 1
a44 1
__RCSID("$MirOS: src/lib/libc/crypt/arc4random.c,v 1.3 2005/09/22 20:06:58 tg Exp $");
d99 4
@


1.3
log
@merge
@
text
@d1 1
a1 1
/**	$MirOS: src/lib/libc/crypt/arc4random.c,v 1.2 2005/03/06 20:28:34 tg Exp $ */
d44 1
a44 1
__RCSID("$MirOS: src/lib/libc/crypt/arc4random.c,v 1.2 2005/03/06 20:28:34 tg Exp $");
d96 2
a97 2
	int     i, mib[2];
	size_t	len;
d191 1
a191 1
		arc4_addrandom(&rs, (char *)&i, len);
@


1.2
log
@merge src/lib
@
text
@d1 2
a2 2
/**	$MirOS$ */
/*	$OpenBSD: arc4random.c,v 1.10 2003/11/26 21:40:08 djm Exp $	*/
d5 5
a9 2
 * Arc4 random number generator for OpenBSD.
 * Copyright 1996 David Mazieres <dm@@lcs.mit.edu>.
d11 7
a17 3
 * Modification and redistribution in source and binary forms is
 * permitted provided that due credit is given to the author and the
 * OpenBSD project by leaving this copyright notice intact.
d21 2
d44 1
a44 1
__RCSID("$MirOS$");
d61 1
d98 1
a98 4
	struct {
		struct timeval tv;
		u_int rnd[(128 - sizeof(struct timeval)) / sizeof(u_int)];
	}       rdat;
a99 1
	gettimeofday(&rdat.tv, NULL);
d103 8
a110 4
	for (i = 0; i < sizeof(rdat.rnd) / sizeof(u_int); i ++) {
		len = sizeof(u_int);
		if (sysctl(mib, 2, &rdat.rnd[i], &len, NULL, 0) == -1)
			break;
d114 1
a114 1
	arc4_addrandom(as, (void *) &rdat, sizeof(rdat));
d121 2
a122 1
		(void) arc4_getbyte(as);
d171 1
a171 1
	if (!rs_initialized || arc4_stir_pid != getpid())
@


1.1
log
@Initial revision
@
text
@d1 1
d28 3
d34 2
a35 4
#include <sys/types.h>
#include <sys/param.h>
#include <sys/time.h>
#include <sys/sysctl.h>
d165 8
a172 16
#if 0
/*-------- Test code for i386 --------*/
#include <stdio.h>
#include <machine/pctr.h>
int
main(int argc, char **argv)
{
	const int iter = 1000000;
	int     i;
	pctrval v;

	v = rdtsc();
	for (i = 0; i < iter; i++)
		arc4random();
	v = rdtsc() - v;
	v /= iter;
d174 7
a180 1
	printf("%qd cycles\n", v);
a181 1
#endif
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.14 2005/06/06 14:57:59 kjell Exp $	*/
d4 2
a5 5
 * Copyright (c) 1996, David Mazieres <dm@@uun.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
d7 3
a9 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
a12 2
 * Arc4 random number generator for OpenBSD.
 *
a49 1
static int arc4_count;
d86 4
a89 1
	u_char rnd[128];
d91 1
d95 4
a98 8
	len = sizeof(rnd);
	if (sysctl(mib, 2, rnd, &len, NULL, 0) == -1) {
		for (i = 0; i < sizeof(rnd) / sizeof(u_int); i ++) {
			len = sizeof(u_int);
			if (sysctl(mib, 2, &rnd[i * sizeof(u_int)], &len,
			    NULL, 0) == -1)
				break;
		}
d102 1
a102 1
	arc4_addrandom(as, rnd, sizeof(rnd));
d109 1
a109 2
		(void)arc4_getbyte(as);
	arc4_count = 400000;
d158 1
a158 1
	if (--arc4_count == 0 || !rs_initialized || arc4_stir_pid != getpid())
@


1.1.1.3
log
@import OpenBSD-current
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.20 2008/10/03 18:46:04 otto Exp $	*/
a4 1
 * Copyright (c) 2008, Damien Miller <djm@@openbsd.org>
a36 1
#include <limits.h>
a42 1
#include "thread_private.h"
d61 1
a61 1
static inline u_int8_t arc4_getbyte(void);
d64 1
a64 1
arc4_init(void)
d69 3
a71 3
		rs.s[n] = n;
	rs.i = 0;
	rs.j = 0;
d75 1
a75 1
arc4_addrandom(u_char *dat, int datlen)
d80 1
a80 1
	rs.i--;
d82 5
a86 5
		rs.i = (rs.i + 1);
		si = rs.s[rs.i];
		rs.j = (rs.j + si + dat[n % datlen]);
		rs.s[rs.i] = rs.s[rs.j];
		rs.s[rs.j] = si;
d88 1
a88 1
	rs.j = rs.i;
d92 1
a92 1
arc4_stir(void)
a97 5
	if (!rs_initialized) {
		arc4_init();
		rs_initialized = 1;
	}

d102 8
a109 1
	sysctl(mib, 2, rnd, &len, NULL, 0);
d112 1
a112 1
	arc4_addrandom(rnd, sizeof(rnd));
d119 2
a120 2
		(void)arc4_getbyte();
	arc4_count = 1600000;
d124 1
a124 1
arc4_getbyte(void)
d128 7
a134 7
	rs.i = (rs.i + 1);
	si = rs.s[rs.i];
	rs.j = (rs.j + si);
	sj = rs.s[rs.j];
	rs.s[rs.i] = sj;
	rs.s[rs.j] = si;
	return (rs.s[(si + sj) & 0xff]);
d138 1
a138 1
arc4_getword(void)
d141 4
a144 4
	val = arc4_getbyte() << 24;
	val |= arc4_getbyte() << 16;
	val |= arc4_getbyte() << 8;
	val |= arc4_getbyte();
d151 5
a155 3
	_ARC4_LOCK();
	arc4_stir();
	_ARC4_UNLOCK();
a160 1
	_ARC4_LOCK();
d162 2
a163 3
		arc4_stir();
	arc4_addrandom(dat, datlen);
	_ARC4_UNLOCK();
d169 3
a171 68
	u_int32_t val;
	_ARC4_LOCK();
	arc4_count -= 4;
	if (arc4_count <= 0 || !rs_initialized || arc4_stir_pid != getpid())
		arc4_stir();
	val = arc4_getword();
	_ARC4_UNLOCK();
	return val;
}

void
arc4random_buf(void *_buf, size_t n)
{
	u_char *buf = (u_char *)_buf;
	_ARC4_LOCK();
	if (!rs_initialized || arc4_stir_pid != getpid())
		arc4_stir();
	while (n--) {
		if (--arc4_count <= 0)
			arc4_stir();
		buf[n] = arc4_getbyte();
	}
	_ARC4_UNLOCK();
}

/*
 * Calculate a uniformly distributed random number less than upper_bound
 * avoiding "modulo bias".
 *
 * Uniformity is achieved by generating new random numbers until the one
 * returned is outside the range [0, 2**32 % upper_bound).  This
 * guarantees the selected random number will be inside
 * [2**32 % upper_bound, 2**32) which maps back to [0, upper_bound)
 * after reduction modulo upper_bound.
 */
u_int32_t
arc4random_uniform(u_int32_t upper_bound)
{
	u_int32_t r, min;

	if (upper_bound < 2)
		return 0;

#if (ULONG_MAX > 0xffffffffUL)
	min = 0x100000000UL % upper_bound;
#else
	/* Calculate (2**32 % upper_bound) avoiding 64-bit math */
	if (upper_bound > 0x80000000)
		min = 1 + ~upper_bound;		/* 2**32 - upper_bound */
	else {
		/* (2**32 - (x * 2)) % x == 2**32 % x when x <= 2**31 */
		min = ((0xffffffff - (upper_bound * 2)) + 1) % upper_bound;
	}
#endif

	/*
	 * This could theoretically loop forever but each retry has
	 * p > 0.5 (worst case, usually far better) of selecting a
	 * number inside the range we need, so it should rarely need
	 * to re-roll.
	 */
	for (;;) {
		r = arc4random();
		if (r >= min)
			break;
	}

	return r % upper_bound;
@


