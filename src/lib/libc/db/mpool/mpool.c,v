head	1.3;
access;
symbols
	MIRBSD_10:1.2.0.2
	MIRBSD_10_BASE:1.2
	MIRBSD_9_BASE:1.2
	MIRBSD_8:1.1.1.3.0.2
	MIRBSD_8_BASE:1.1.1.3
	cvs-200509212000:1.1.1.3
	cvs-200507211800:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2013.10.31.20.06.17;	author tg;	state Exp;
branches;
next	1.2;
commitid	1005272B7081B0E5655;

1.2
date	2006.06.02.02.29.47;	author tg;	state Exp;
branches;
next	1.1;
commitid	100447FA28346FF91C0;

1.1
date	2005.02.05.17.24.39;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.24.39;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.07.21.20.52.24;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	560042e0092f571e;

1.1.1.3
date	2005.09.21.20.34.17;	author tg;	state Exp;
branches;
next	;
commitid	20cd4331c3c732a2;


desc
@@


1.3
log
@adapt most __attribute__((…)) occurrences to new KNF style(9)
@
text
@/*	$OpenBSD: mpool.c,v 1.14 2005/08/05 13:03:00 espie Exp $	*/

/*-
 * Copyright © 2013
 *	Thorsten “mirabilos” Glaser <tg@@mirbsd.org>
 * Copyright (c) 1990, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/queue.h>
#include <sys/stat.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <db.h>

__RCSID("$MirOS$");

#define	__MPOOLINTERFACE_PRIVATE
#include <mpool.h>

static BKT *mpool_bkt(MPOOL *);
static BKT *mpool_look(MPOOL *, pgno_t);
static int  mpool_write(MPOOL *, BKT *);

/*
 * mpool_open --
 *	Initialize a memory pool.
 */
/* ARGSUSED */
MPOOL *
mpool_open(void *key __attribute__((__unused__)), int fd, pgno_t pagesize,
    pgno_t maxcache)
{
	struct stat sb;
	MPOOL *mp;
	int entry;

	/*
	 * Get information about the file.
	 *
	 * XXX
	 * We don't currently handle pipes, although we should.
	 */
	if (fstat(fd, &sb))
		return (NULL);
	if (!S_ISREG(sb.st_mode)) {
		errno = ESPIPE;
		return (NULL);
	}

	/* Allocate and initialize the MPOOL cookie. */
	if ((mp = (MPOOL *)calloc(1, sizeof(MPOOL))) == NULL)
		return (NULL);
	CIRCLEQ_INIT(&mp->lqh);
	for (entry = 0; entry < HASHSIZE; ++entry)
		CIRCLEQ_INIT(&mp->hqh[entry]);
	mp->maxcache = maxcache;
	mp->npages = sb.st_size / pagesize;
	mp->pagesize = pagesize;
	mp->fd = fd;
	return (mp);
}

/*
 * mpool_filter --
 *	Initialize input/output filters.
 */
void
mpool_filter(MPOOL *mp, void (*pgin) (void *, pgno_t, void *),
    void (*pgout) (void *, pgno_t, void *), void *pgcookie)
{
	mp->pgin = pgin;
	mp->pgout = pgout;
	mp->pgcookie = pgcookie;
}
	
/*
 * mpool_new --
 *	Get a new page of memory.
 */
void *
mpool_new(MPOOL *mp, pgno_t *pgnoaddr, u_int flags)
{
	struct _hqh *head;
	BKT *bp;

	if (mp->npages == MAX_PAGE_NUMBER) {
		(void)fprintf(stderr, "mpool_new: page allocation overflow.\n");
		abort();
	}
#ifdef STATISTICS
	++mp->pagenew;
#endif
	/*
	 * Get a BKT from the cache.  Assign a new page number, attach
	 * it to the head of the hash chain, the tail of the lru chain,
	 * and return.
	 */
	if ((bp = mpool_bkt(mp)) == NULL)
		return (NULL);
	if (flags == MPOOL_PAGE_REQUEST) {
		mp->npages++;
		bp->pgno = *pgnoaddr;
	} else
		bp->pgno = *pgnoaddr = mp->npages++;

	bp->flags = MPOOL_PINNED | MPOOL_INUSE;

	head = &mp->hqh[HASHKEY(bp->pgno)];
	CIRCLEQ_INSERT_HEAD(head, bp, hq);
	CIRCLEQ_INSERT_TAIL(&mp->lqh, bp, q);
	return (bp->page);
}

int
mpool_delete(MPOOL *mp, void *page)
{
	struct _hqh *head;
	BKT *bp;

	bp = (BKT *)((char *)page - sizeof(BKT));

#ifdef DEBUG
	if (!(bp->flags & MPOOL_PINNED)) {
		(void)fprintf(stderr,
		    "mpool_delete: page %d not pinned\n", bp->pgno);
		abort();
	}
#endif

	/* Remove from the hash and lru queues. */
	head = &mp->hqh[HASHKEY(bp->pgno)];
	CIRCLEQ_REMOVE(head, bp, hq);
	CIRCLEQ_REMOVE(&mp->lqh, bp, q);

	free(bp);
	return (RET_SUCCESS);
}	
	
/*
 * mpool_get
 *	Get a page.
 */
/* ARGSUSED */
void *
mpool_get(MPOOL *mp, pgno_t pgno,
    u_int flags)		/* XXX not used? */
{
	struct _hqh *head;
	BKT *bp;
	off_t off;
	int nr;

#ifdef STATISTICS
	++mp->pageget;
#endif

	/* Check for a page that is cached. */
	if ((bp = mpool_look(mp, pgno)) != NULL) {
#ifdef DEBUG
		if (!(flags & MPOOL_IGNOREPIN) && bp->flags & MPOOL_PINNED) {
			(void)fprintf(stderr,
			    "mpool_get: page %d already pinned\n", bp->pgno);
			abort();
		}
#endif
		/*
		 * Move the page to the head of the hash chain and the tail
		 * of the lru chain.
		 */
		head = &mp->hqh[HASHKEY(bp->pgno)];
		CIRCLEQ_REMOVE(head, bp, hq);
		CIRCLEQ_INSERT_HEAD(head, bp, hq);
		CIRCLEQ_REMOVE(&mp->lqh, bp, q);
		CIRCLEQ_INSERT_TAIL(&mp->lqh, bp, q);

		/* Return a pinned page. */
		bp->flags |= MPOOL_PINNED;
		return (bp->page);
	}

	/* Get a page from the cache. */
	if ((bp = mpool_bkt(mp)) == NULL)
		return (NULL);

	/* Read in the contents. */
#ifdef STATISTICS
	++mp->pageread;
#endif
	off = mp->pagesize * pgno;
	if ((off_t)(nr = pread(mp->fd, bp->page, mp->pagesize, off)) != mp->pagesize) {
		switch (nr) {
		case -1:
			/* errno is set for us by pread(). */
			return (NULL);
		case 0:
			/*
			 * A zero-length read means you need to create a
			 * new page.
			 */
			memset(bp->page, 0, mp->pagesize);
		default:
			/* A partial read is definitely bad. */
			errno = EINVAL;
			return (NULL);
		}
	}

	/* Set the page number, pin the page. */
	bp->pgno = pgno;
	if (!(flags & MPOOL_IGNOREPIN))
		bp->flags = MPOOL_PINNED;
	bp->flags |= MPOOL_INUSE;

	/*
	 * Add the page to the head of the hash chain and the tail
	 * of the lru chain.
	 */
	head = &mp->hqh[HASHKEY(bp->pgno)];
	CIRCLEQ_INSERT_HEAD(head, bp, hq);
	CIRCLEQ_INSERT_TAIL(&mp->lqh, bp, q);

	/* Run through the user's filter. */
	if (mp->pgin != NULL)
		(mp->pgin)(mp->pgcookie, bp->pgno, bp->page);

	return (bp->page);
}

/*
 * mpool_put
 *	Return a page.
 */
/* ARGSUSED */
int
mpool_put(MPOOL *mp __attribute__((__unused__)), void *page, u_int flags)
{
	BKT *bp;

#ifdef STATISTICS
	++mp->pageput;
#endif
	bp = (BKT *)((char *)page - sizeof(BKT));
#ifdef DEBUG
	if (!(bp->flags & MPOOL_PINNED)) {
		(void)fprintf(stderr,
		    "mpool_put: page %d not pinned\n", bp->pgno);
		abort();
	}
#endif
	bp->flags &= ~MPOOL_PINNED;
	if (flags & MPOOL_DIRTY)
		bp->flags |= flags & MPOOL_DIRTY;
	return (RET_SUCCESS);
}

/*
 * mpool_close
 *	Close the buffer pool.
 */
int
mpool_close(MPOOL *mp)
{
	BKT *bp;

	/* Free up any space allocated to the lru pages. */
	while ((bp = mp->lqh.cqh_first) != (void *)&mp->lqh) {
		CIRCLEQ_REMOVE(&mp->lqh, mp->lqh.cqh_first, q);
		free(bp);
	}

	/* Free the MPOOL cookie. */
	free(mp);
	return (RET_SUCCESS);
}

/*
 * mpool_sync
 *	Sync the pool to disk.
 */
int
mpool_sync(MPOOL *mp)
{
	BKT *bp;

	/* Walk the lru chain, flushing any dirty pages to disk. */
	for (bp = mp->lqh.cqh_first;
	    bp != (void *)&mp->lqh; bp = bp->q.cqe_next)
		if (bp->flags & MPOOL_DIRTY &&
		    mpool_write(mp, bp) == RET_ERROR)
			return (RET_ERROR);

	/* Sync the file descriptor. */
	return (fsync(mp->fd) ? RET_ERROR : RET_SUCCESS);
}

/*
 * mpool_bkt
 *	Get a page from the cache (or create one).
 */
static BKT *
mpool_bkt(MPOOL *mp)
{
	struct _hqh *head;
	BKT *bp;

	/* If under the max cached, always create a new page. */
	if (mp->curcache < mp->maxcache)
		goto new;

	/*
	 * If the cache is max'd out, walk the lru list for a buffer we
	 * can flush.  If we find one, write it (if necessary) and take it
	 * off any lists.  If we don't find anything we grow the cache anyway.
	 * The cache never shrinks.
	 */
	for (bp = mp->lqh.cqh_first;
	    bp != (void *)&mp->lqh; bp = bp->q.cqe_next)
		if (!(bp->flags & MPOOL_PINNED)) {
			/* Flush if dirty. */
			if (bp->flags & MPOOL_DIRTY &&
			    mpool_write(mp, bp) == RET_ERROR)
				return (NULL);
#ifdef STATISTICS
			++mp->pageflush;
#endif
			/* Remove from the hash and lru queues. */
			head = &mp->hqh[HASHKEY(bp->pgno)];
			CIRCLEQ_REMOVE(head, bp, hq);
			CIRCLEQ_REMOVE(&mp->lqh, bp, q);
#ifdef DEBUG
			{ void *spage;
				spage = bp->page;
				memset(bp, 0xff, sizeof(BKT) + mp->pagesize);
				bp->page = spage;
			}
#endif
			bp->flags = 0;
			return (bp);
		}

new:	if ((bp = (BKT *)malloc(sizeof(BKT) + mp->pagesize)) == NULL)
		return (NULL);
#ifdef STATISTICS
	++mp->pagealloc;
#endif
	memset(bp, 0xff, sizeof(BKT) + mp->pagesize);
	bp->page = (char *)bp + sizeof(BKT);
	bp->flags = 0;
	++mp->curcache;
	return (bp);
}

/*
 * mpool_write
 *	Write a page to disk.
 */
static int
mpool_write(MPOOL *mp, BKT *bp)
{
	off_t off;

#ifdef STATISTICS
	++mp->pagewrite;
#endif

	/* Run through the user's filter. */
	if (mp->pgout)
		(mp->pgout)(mp->pgcookie, bp->pgno, bp->page);

	off = mp->pagesize * bp->pgno;
	if ((off_t)pwrite(mp->fd, bp->page, mp->pagesize, off) != mp->pagesize)
		return (RET_ERROR);

	/*
	 * Re-run through the input filter since this page may soon be
	 * accessed via the cache, and whatever the user's output filter
	 * did may screw things up if we don't let the input filter
	 * restore the in-core copy.
	 */
	if (mp->pgin)
		(mp->pgin)(mp->pgcookie, bp->pgno, bp->page);

	bp->flags &= ~MPOOL_DIRTY;
	return (RET_SUCCESS);
}

/*
 * mpool_look
 *	Lookup a page in the cache.
 */
static BKT *
mpool_look(MPOOL *mp, pgno_t pgno)
{
	struct _hqh *head;
	BKT *bp;

	head = &mp->hqh[HASHKEY(pgno)];
	for (bp = head->cqh_first; bp != (void *)head; bp = bp->hq.cqe_next)
		if ((bp->pgno == pgno) &&
			((bp->flags & MPOOL_INUSE) == MPOOL_INUSE)) {
#ifdef STATISTICS
			++mp->cachehit;
#endif
			return (bp);
		}
#ifdef STATISTICS
	++mp->cachemiss;
#endif
	return (NULL);
}

#ifdef STATISTICS
/*
 * mpool_stat
 *	Print out cache statistics.
 */
void
mpool_stat(MPOOL *mp)
{
	BKT *bp;
	int cnt;
	char *sep;

	(void)fprintf(stderr, "%lu pages in the file\n", mp->npages);
	(void)fprintf(stderr,
	    "page size %lu, cacheing %lu pages of %lu page max cache\n",
	    mp->pagesize, mp->curcache, mp->maxcache);
	(void)fprintf(stderr, "%lu page puts, %lu page gets, %lu page new\n",
	    mp->pageput, mp->pageget, mp->pagenew);
	(void)fprintf(stderr, "%lu page allocs, %lu page flushes\n",
	    mp->pagealloc, mp->pageflush);
	if (mp->cachehit + mp->cachemiss)
		(void)fprintf(stderr,
		    "%.0f%% cache hit rate (%lu hits, %lu misses)\n", 
		    ((double)mp->cachehit / (mp->cachehit + mp->cachemiss))
		    * 100, mp->cachehit, mp->cachemiss);
	(void)fprintf(stderr, "%lu page reads, %lu page writes\n",
	    mp->pageread, mp->pagewrite);

	sep = "";
	cnt = 0;
	for (bp = mp->lqh.cqh_first;
	    bp != (void *)&mp->lqh; bp = bp->q.cqe_next) {
		(void)fprintf(stderr, "%s%d", sep, bp->pgno);
		if (bp->flags & MPOOL_DIRTY)
			(void)fprintf(stderr, "d");
		if (bp->flags & MPOOL_PINNED)
			(void)fprintf(stderr, "P");
		if (++cnt == 10) {
			sep = "\n";
			cnt = 0;
		} else
			sep = ", ";
			
	}
	(void)fprintf(stderr, "\n");
}
#endif
@


1.2
log
@__CRAZY cleanliness for most of libc
not: net/rpc/etc., time, thread, sys
@
text
@d4 2
d46 2
d61 1
a61 1
mpool_open(void *key __attribute__((unused)), int fd, pgno_t pagesize,
d266 1
a266 1
mpool_put(MPOOL *mp __attribute__((unused)), void *page, u_int flags)
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: mpool.c,v 1.12 2003/06/02 20:18:34 millert Exp $	*/
a31 8
#if defined(LIBC_SCCS) && !defined(lint)
#if 0
static char sccsid[] = "@@(#)mpool.c	8.7 (Berkeley) 11/2/95";
#else
static const char rcsid[] = "$OpenBSD: mpool.c,v 1.12 2003/06/02 20:18:34 millert Exp $";
#endif
#endif /* LIBC_SCCS and not lint */

d57 2
a58 4
mpool_open(key, fd, pagesize, maxcache)
	void *key;
	int fd;
	pgno_t pagesize, maxcache;
d95 2
a96 5
mpool_filter(mp, pgin, pgout, pgcookie)
	MPOOL *mp;
	void (*pgin)(void *, pgno_t, void *);
	void (*pgout)(void *, pgno_t, void *);
	void *pgcookie;
d108 1
a108 4
mpool_new(mp, pgnoaddr, flags)
	MPOOL *mp;
	pgno_t *pgnoaddr;
	u_int flags;
d142 1
a142 3
mpool_delete(mp, page)
	MPOOL *mp;
	void *page;
d172 2
a173 4
mpool_get(mp, pgno, flags)
	MPOOL *mp;
	pgno_t pgno;
	u_int flags;				/* XXX not used? */
d217 1
a217 1
	if ((nr = pread(mp->fd, bp->page, mp->pagesize, off)) != mp->pagesize) {
d262 1
a262 4
mpool_put(mp, page, flags)
	MPOOL *mp;
	void *page;
	u_int flags;
d288 1
a288 2
mpool_close(mp)
	MPOOL *mp;
d308 1
a308 2
mpool_sync(mp)
	MPOOL *mp;
d328 1
a328 2
mpool_bkt(mp)
	MPOOL *mp;
d385 1
a385 3
mpool_write(mp, bp)
	MPOOL *mp;
	BKT *bp;
d398 1
a398 1
	if (pwrite(mp->fd, bp->page, mp->pagesize, off) != mp->pagesize)
d419 1
a419 3
mpool_look(mp, pgno)
	MPOOL *mp;
	pgno_t pgno;
d445 1
a445 2
mpool_stat(mp)
	MPOOL *mp;
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d1 1
a1 1
/*	$OpenBSD: mpool.c,v 1.13 2005/03/23 19:34:59 otto Exp $	*/
d36 1
a36 1
static const char rcsid[] = "$OpenBSD: mpool.c,v 1.13 2005/03/23 19:34:59 otto Exp $";
d65 4
a68 1
mpool_open(void *key, int fd, pgno_t pagesize, pgno_t maxcache)
d105 5
a109 2
mpool_filter(MPOOL *mp, void (*pgin) (void *, pgno_t, void *),
    void (*pgout) (void *, pgno_t, void *), void *pgcookie)
d121 4
a124 1
mpool_new(MPOOL *mp, pgno_t *pgnoaddr, u_int flags)
d158 3
a160 1
mpool_delete(MPOOL *mp, void *page)
d190 4
a193 2
mpool_get(MPOOL *mp, pgno_t pgno,
    u_int flags)		/* XXX not used? */
d282 4
a285 1
mpool_put(MPOOL *mp, void *page, u_int flags)
d311 2
a312 1
mpool_close(MPOOL *mp)
d332 2
a333 1
mpool_sync(MPOOL *mp)
d353 2
a354 1
mpool_bkt(MPOOL *mp)
d411 3
a413 1
mpool_write(MPOOL *mp, BKT *bp)
d447 3
a449 1
mpool_look(MPOOL *mp, pgno_t pgno)
d475 2
a476 1
mpool_stat(MPOOL *mp)
@


1.1.1.3
log
@Import OpenBSD's libc as of today, minus some of the locale stuff,
and with brk malloc instead of mmap malloc
@
text
@d1 1
a1 1
/*	$OpenBSD: mpool.c,v 1.14 2005/08/05 13:03:00 espie Exp $	*/
d32 8
@


