head	1.9;
access;
symbols
	cvs-201212212100:1.1.1.6
	MIRBSD_10:1.3.0.2
	MIRBSD_10_BASE:1.3
	MIRBSD_9_BASE:1.3
	cvs-200601311221:1.1.1.4
	MIRBSD_8:1.1.1.3.0.2
	MIRBSD_8_BASE:1.1.1.3
	cvs-200509212000:1.1.1.3
	cvs-200507211800:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@.\" @;


1.9
date	2016.10.22.23.45.52;	author tg;	state Exp;
branches;
next	1.8;
commitid	100580BFA3A7A351E27;

1.8
date	2015.07.07.17.56.18;	author tg;	state Exp;
branches;
next	1.7;
commitid	100559C12D32913AA6D;

1.7
date	2014.11.30.21.30.56;	author tg;	state Exp;
branches;
next	1.6;
commitid	100547B8BEB4A8A38F2;

1.6
date	2014.03.02.14.45.04;	author tg;	state Exp;
branches;
next	1.5;
commitid	100531343E3026DCF4B;

1.5
date	2012.12.21.21.49.18;	author tg;	state Exp;
branches;
next	1.4;
commitid	10050D4D97113AFAA4C;

1.4
date	2010.12.23.18.33.33;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004D13961111145958;

1.3
date	2006.03.30.18.36.02;	author tg;	state Exp;
branches;
next	1.2;
commitid	100442C24BC2AB55E5D;

1.2
date	2006.01.31.12.31.57;	author tg;	state Exp;
branches;
next	1.1;
commitid	10043DF58CE32E8D583;

1.1
date	2005.02.05.17.24.55;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.24.55;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.07.21.20.53.04;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	560042e0092f571e;

1.1.1.3
date	2005.09.21.20.34.27;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	20cd4331c3c732a2;

1.1.1.4
date	2006.01.31.12.24.10;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	10043DF56F07E3206F9;

1.1.1.5
date	2010.12.23.18.15.21;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	1004D1391A219ED34CC;

1.1.1.6
date	2012.12.21.21.29.59;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	10050D4D4EF0FE0A228;

1.1.1.7
date	2014.03.02.14.42.31;	author tg;	state Exp;
branches;
next	1.1.1.8;
commitid	1005313436C7852F9BE;

1.1.1.8
date	2014.11.30.20.56.07;	author tg;	state Exp;
branches;
next	;
commitid	100547B84752A8D319C;


desc
@@


1.9
log
@explicitly note UB after realloc* succeeds and after any call to free
@
text
@.\"
.\" Copyright (c) 1980, 1991, 1993
.\"	The Regents of the University of California.  All rights reserved.
.\"
.\" This code is derived from software contributed to Berkeley by
.\" the American National Standards Committee X3, on Information
.\" Processing Systems.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"	$MirOS: src/lib/libc/stdlib/malloc.3,v 1.7 2014/11/30 21:30:56 tg Exp $
.\"	$OpenBSD: malloc.3,v 1.85 2014/10/30 21:47:47 deraadt Exp $
.\"
.Dd $Mdocdate: November 30 2014 $
.Dt MALLOC 3
.Os
.Sh NAME
.Nm malloc ,
.Nm calloc ,
.Nm reallocarray ,
.Nm realloc ,
.Nm free ,
.Nm cfree
.Nd memory allocation and deallocation
.Sh SYNOPSIS
.In stdlib.h
.Ft void *
.Fn malloc "size_t size"
.Ft void *
.Fn calloc "size_t nmemb" "size_t size"
.Ft void *
.Fn reallocarray "void *ptr" "size_t nmemb" "size_t size"
.Ft void *
.Fn realloc "void *ptr" "size_t size"
.Ft void
.Fn free "void *ptr"
.Ft void
.Fn cfree "void *ptr"
.Vt char * Ns Va malloc_options ;
.Sh DESCRIPTION
Note: if using
.Xr brk 2
malloc or
.Xr mmap 2
malloc instead of
.Nm omalloc ,
this manual page is inaccurate,
especially regarding the protection functions.
.Pp
The
.Fn malloc
function allocates uninitialised space for an object of
the specified
.Fa size .
.Fn malloc
maintains multiple lists of free blocks according to size, allocating
space from the appropriate list.
The allocated space is suitably aligned (after possible pointer coercion) for
storage of any type of object.
If the space is of
.Em pagesize
or larger, the memory returned will be page-aligned.
.Pp
The
.Fn calloc
function allocates space for an array of
.Fa nmemb
objects, each of the specified
.Fa size .
The space is initialised to zero.
.Pp
The
.Fn realloc
function changes the size of the object pointed to by
.Fa ptr
to
.Fa size
bytes and returns a pointer to the (possibly moved) object.
The contents of the object are unchanged up to the lesser
of the new and old sizes.
If the new size is larger, the value of the newly allocated portion
of the object is indeterminate and uninitialised.
If the space cannot be allocated, the object
pointed to by
.Fa ptr
is unchanged.
If
.Fa ptr
is
.Dv NULL ,
.Fn realloc
behaves like
.Fn malloc
and allocates a new object.
.Pp
The
.Fn reallocarray
function is similar to
.Fn realloc
except it operates on
.Fa nmemb
members of size
.Fa size
and checks for integer overflow in the calculation
.Fa nmemb
*
.Fa size .
.Pp
The
.Fn free
function causes the space pointed to by
.Fa ptr
to be either placed on a list of free pages to make it available for future
allocation or, if required, to be returned to the kernel using
.Xr munmap 2 .
If
.Fa ptr
is a
.Dv NULL
pointer, no action occurs.
If
.Fa ptr
was previously freed by
.Fn free ,
.Fn realloc
or
.Fn reallocarray ,
the behavior is undefined, and the double free is a security concern.
.Pp
A
.Fn cfree
function is also provided for compatibility with old systems and other
.Nm malloc
libraries; it is simply an alias for
.Fn free .
.Sh RETURN VALUES
Upon successful completion, the functions
.Fn malloc ,
.Fn calloc ,
.Fn realloc
and
.Fn reallocarray
return a pointer to the allocated space; otherwise, a
.Dv NULL
pointer is returned and
.Va errno
is set to
.Er ENOMEM .
.Pp
If
.Fa size
or
.Fa nmemb
is equal to 0, a unique pointer to an access protected,
zero sized object is returned.
Access via this pointer will generate a
.Dv SIGSEGV
exception.
.Pp
If multiplying
.Fa nmemb
and
.Fa size
results in integer overflow,
.Fn calloc
and
.Fn reallocarray
return
.Dv NULL
and set
.Va errno
to
.Er ENOMEM .
.Pp
The
.Fn free
and
.Fn cfree
functions return no value.
.Sh IDIOMS
Consider
.Fn calloc
or the extension
.Fn reallocarray
when there is multiplication in the
.Fa size
argument of
.Fn malloc
or
.Fn realloc .
For example, avoid this common idiom as it may lead to integer overflow:
.Bd -literal -offset indent
if ((p = malloc(num * size)) == NULL)
	err(1, "malloc");
.Ed
.Pp
A drop-in replacement is the
.Ox
extension
.Fn reallocarray :
.Bd -literal -offset indent
if ((p = reallocarray(NULL, num, size)) == NULL)
	err(1, "reallocarray");
.Ed
.Pp
Alternatively,
.Fn calloc
may be used at the cost of possible initialisation overhead.
.Pp
When using
.Fn realloc ,
be careful to avoid the following idiom:
.Bd -literal -offset indent
size += 50;
if ((p = realloc(p, size)) == NULL)
	return (NULL);
.Ed
.Pp
Do not adjust the variable describing how much memory has been allocated
until the allocation has been successful.
This can cause aberrant program behavior if the incorrect size value is used.
In most cases, the above sample will also result in a leak of memory.
As stated earlier, a return value of
.Dv NULL
indicates that the old object still remains allocated.
Better code looks like this:
.Bd -literal -offset indent
newsize = size + 50;
if ((newp = realloc(p, newsize)) == NULL) {
	free(p);
	p = NULL;
	size = 0;
	return (NULL);
}
p = newp;
size = newsize;
.Ed
.Pp
As with
.Fn malloc ,
it is important to ensure the new size value will not overflow;
i.e. avoid allocations like the following:
.Bd -literal -offset indent
if ((newp = realloc(p, num * size)) == NULL) {
	...
.Ed
.Pp
Instead, use
.Fn reallocarray :
.Bd -literal -offset indent
if ((newp = reallocarray(p, num, size)) == NULL) {
	...
.Ed
.Pp
Calling
.Fn realloc
with a
.Dv NULL
.Fa ptr
is equivalent to calling
.Fn malloc .
Instead of this idiom:
.Bd -literal -offset indent
if (p == NULL)
	newp = malloc(newsize);
else
	newp = realloc(p, newsize);
.Ed
.Pp
Use the following:
.Bd -literal -offset indent
newp = realloc(p, newsize);
.Ed
.Sh ENVIRONMENT
.Bl -tag -width Ev
.It Ev MALLOC_OPTIONS
See below.
.El
.Sh FILES
.Bl -tag -width "/etc/malloc.conf"
.It Pa /etc/malloc.conf
symbolic link to filename containing option flags
.El
.Sh EXAMPLES
If
.Fn malloc
must be used with multiplication, be sure to test for overflow:
.Bd -literal -offset indent
size_t num, size;
\&...

/* Check for size_t overflow */
if (size && num > SIZE_MAX / size)
	errc(1, EOVERFLOW, "overflow");

if ((p = malloc(size * num)) == NULL)
	err(1, "malloc");
.Ed
.Pp
The above test is not sufficient in all cases.
For example, multiplying signed integers requires a different set of checks:
.Bd -literal -offset indent
int num, size;
\&...

/* Avoid invalid requests */
if (size < 0 || num < 0)
	errc(1, EOVERFLOW, "overflow");

/* Check for signed int overflow */
if (size && num > INT_MAX / size)
	errc(1, EOVERFLOW, "overflow");

if ((p = malloc(size * num)) == NULL)
	err(1, "malloc");
.Ed
.Pp
Assuming the implementation checks for integer overflow as
.Ox
does, it is much easier to use
.Fn calloc
or
.Fn reallocarray .
.Pp
The above examples could be simplified to:
.Bd -literal -offset indent
if ((p = reallocarray(NULL, num, size)) == NULL)
	err(1, "reallocarray");
.Ed
.Pp
or, at the cost of possible initialisation:
.Bd -literal -offset indent
if ((p = calloc(num, size)) == NULL)
	err(1, "calloc");
.Ed
.Sh DIAGNOSTICS
If
.Fn malloc ,
.Fn calloc ,
.Fn realloc ,
.Fn reallocarray
or
.Fn free
detect an error condition,
a message will be printed to file descriptor
2 (not using stdio).
Errors will result in the process being aborted,
unless the
.Cm a
option has been specified.
.Pp
Here is a brief description of the error messages and what they mean:
.Bl -tag -width Ds
.It Dq out of memory
If the
.Cm X
option is specified it is an error for
.Fn malloc ,
.Fn calloc ,
.Fn realloc
or
.Fn reallocarray
to return
.Dv NULL .
.It Dq malloc init mmap failed
This is a rather weird condition that is most likely to indicate a
seriously overloaded system or a ulimit restriction.
.It Dq bogus pointer (double free?)
An attempt to
.Fn free ,
.Fn realloc
or
.Fn reallocarray
an unallocated pointer was made.
.It Dq chunk is already free
There was an attempt to free a chunk that had already been freed.
.It Dq modified chunk-pointer
The pointer passed to
.Fn free ,
.Fn realloc
or
.Fn reallocarray
has been modified.
.It Dq recursive call
An attempt was made to call recursively into these functions, i.e., from a
signal handler.
This behavior is not supported.
In particular, signal handlers should
.Em not
use any of the
.Fn malloc
functions nor utilise any other functions which may call
.Fn malloc
(e.g.,
.Xr stdio 3
routines).
.It Dq unknown char in MALLOC_OPTIONS
We found something we didn't understand.
.It Dq malloc cache overflow/underflow
The internal malloc page cache has been corrupted.
.It Dq malloc free slot lost
The internal malloc page cache has been corrupted.
.It Dq guard size
An inconsistent guard size was detected.
.It any other error
.Fn malloc
detected an internal error;
consult sources and/or wizards.
.El
.Sh MALLOC_OPTIONS
Malloc will first look for a symbolic link called
.Pa /etc/malloc.conf
and next check the environment for a variable called
.Ev MALLOC_OPTIONS
and finally for the global variable
.Va malloc_options
and scan them for flags in that order.
Flags are single letters, uppercase means on, lowercase means off.
.Bl -tag -width indent
.It Cm A
.Dq Abort .
.Fn malloc
will coredump the process, rather than tolerate internal
inconsistencies or incorrect usage.
This is the default and a very handy debugging aid,
since the core file represents the time of failure,
rather than when the bogus pointer was used.
.It Cm D
.Dq Dump .
.Fn malloc
will dump statistics to the file
.Pa ./malloc.out ,
if it already exists,
at exit.
This option requires the library to have been compiled with -DMALLOC_STATS in
order to have any effect.
.It Cm F
.Dq Freeguard .
Enable use after free detection.
Unused pages on the freelist are read and write protected to
cause a segmentation fault upon access.
This will also switch off the delayed freeing of chunks,
reducing random behaviour but detecting double
.Fn free
calls as early as possible.
This option is intended for debugging rather than improved security
(use the
.Cm U
option for security).
.It Cm G
.Dq Guard .
Enable guard pages.
Each page size or larger allocation is followed by a guard page that will
cause a segmentation fault upon any access.
.It Cm H
.Dq Hint .
Pass a hint to the kernel about pages we don't use.
If the machine is paging a lot this may help a bit.
.It Cm J
.Dq Junk .
Fill some junk into the area allocated.
Currently junk is bytes of 0xd0 when allocating; this is pronounced
.Dq Duh .
\&:-)
Freed chunks are filled with 0xdf.
.It Cm j
.Dq Don't Junk .
By default, small chunks are always junked, and the first part of pages
is junked after free.
This option ensures that no junking is performed.
.It Cm P
.Dq Move allocations within a page.
Allocations larger than half a page but smaller than a page
are aligned to the end of a page to catch buffer overruns in more
cases.
This is the default.
.It Cm R
.Dq realloc .
Always reallocate when
.Fn realloc
is called, even if the initial allocation was big enough.
This can substantially aid in compacting memory.
.\".Pp
.\".It Cm U
.\".Dq utrace .
.\"Generate entries for
.\".Xr ktrace 1
.\"for all operations.
.\"Consult the source for this one.
.It Cm S
Enable all options suitable for security auditing.
.It Cm U
.Dq Free unmap .
Enable use after free protection for larger allocations.
Unused pages on the freelist are read and write protected to
cause a segmentation fault upon access.
.It Cm X
.Dq xmalloc .
Rather than return failure,
.Xr abort 3
the program with a diagnostic message on stderr.
It is the intention that this option be set at compile time by
including in the source:
.Bd -literal -offset indent
extern char *malloc_options;
malloc_options = "X";
.Ed
.Pp
Note that this will cause code that is supposed to handle
out-of-memory conditions gracefully to abort instead.
.It Cm <
.Dq Half the cache size .
Decrease the size of the free page cache by a factor of two.
.It Cm >
.Dq Double the cache size .
Increase the size of the free page cache by a factor of two.
.El
.Pp
So to set a systemwide reduction of the cache to a quarter of the
default size and use guard pages:
.Dl # ln -s 'G<<' /etc/malloc.conf
.Pp
The flags are mostly for testing and debugging.
If a program changes behavior if any of these options (except
.Cm X )
are used,
it is buggy.
.Pp
The default number of free pages cached is 64.
.Sh SEE ALSO
.Xr brk 2 ,
.Xr mmap 2 ,
.Xr munmap 2 ,
.Xr alloca 3 ,
.Xr getpagesize 3 ,
.Xr posix_memalign 3 ,
.Xr sysconf 3
.Sh STANDARDS
The
.Fn malloc ,
.Fn calloc ,
.Fn realloc
and
.Fn free
functions conform to
.St -ansiC .
.Pp
If
.Fa size
or
.Fa nmemb
are 0, the return value is implementation defined;
other conforming implementations may return
.Dv NULL
in this case.
.Pp
The standard does not require
.Fn calloc
to check for integer overflow,
but most modern implementations provide this check.
.Pp
The
.Ev MALLOC_OPTIONS
environment variable, the file
.Pa /etc/malloc.conf ,
and the
.Sx DIAGNOSTICS
output are extensions to the standard.
.Sh HISTORY
A
.Fn free
internal kernel function and a antecessor to
.Fn malloc ,
.Fn alloc ,
first appeared in
.At v1 .
C library functions
.Fn alloc
and
.Fn free
appeared in
.At v6 .
The functions
.Fn malloc ,
.Fn calloc
and
.Fn realloc
first appeared in
.At v7 .
.Pp
A new implementation by Chris Kingsley was introduced in
.Bx 4.2 ,
followed by a complete rewrite by Poul-Henning Kamp which appeared in
.Fx 2.2
and was included in
.Ox 2.0 .
These implementations were all
.Xr sbrk 2
based.
In
.Ox 3.8 ,
Thierry Deval rewrote
.Nm
to use the
.Xr mmap 2
system call,
making the page addresses returned by
.Nm
random.
A rewrite by Otto Moerbeek introducing a new central data structure and more
randomisation appeared in
.Ox 4.4 .
.Pp
The
.Fn reallocarray
function appeared in
.Ox 5.6 .
.Pp
The
.Fn cfree
function appeared in SunOS 4.x.
.Sh CAVEATS
It should be noted explicitly that the pointer passed to
.Fn realloc
.Pq and Fn reallocarray
is invalid, and any attempt to use it Undefined Behaviour,
after the function succeeded, and after all calls to
.Fn free .
.Pp
When using
.Fn malloc ,
be wary of signed integer and
.Vt size_t
overflow especially when there is multiplication in the
.Fa size
argument.
.Pp
Signed integer overflow will cause undefined behavior which compilers
typically handle by wrapping back around to negative numbers.
Depending on the input, this can result in allocating more or less
memory than intended.
.Pp
An unsigned overflow has defined behavior which will wrap back around and
return less memory than intended.
.Pp
A signed or unsigned integer overflow is a
.Em security
risk if less memory is returned than intended.
Subsequent code may corrupt the heap by writing beyond the memory that was
allocated.
An attacker may be able to leverage this heap corruption to execute arbitrary
code.
.Pp
Consider using
.Fn calloc
or
.Fn reallocarray
instead of using multiplication in
.Fn malloc
and
.Fn realloc
to avoid these problems on
.Ox .
@


1.8
log
@antecedere
@
text
@d147 1
a147 1
.Fn realloc ,
d150 1
a150 1
the behavior is undefined and the double free is a security concern.
d162 1
a162 1
.Fn realloc ,
d363 1
a363 1
.Fn reallocarray ,
d382 1
a382 1
.Fn realloc ,
d393 1
a393 1
.Fn realloc ,
d402 1
a402 1
.Fn realloc ,
d564 1
a564 1
.Fn realloc ,
d607 1
a607 1
.Fn calloc ,
d645 7
@


1.7
log
@• timingsafe_memcmp is not the same as timingsafe_bcmp, remove
• remove timingsafe_bcmp from libkern
• (re-)add timingsafe_bcmp and timingsafe_memcmp to libc
• update omalloc
• newly add reallocarray to libc
• add strnlen to libc, fix strndup to not read beyond size with that
• update manpages and add MLINKS: strndup, strnlen, timingsafe_*cmp
@
text
@d33 1
a33 1
.\"	$MirOS: src/lib/libc/stdlib/malloc.3,v 1.6 2014/03/02 14:45:04 tg Exp $
d594 1
a594 1
internal kernel function and a predecessor to
@


1.6
log
@merge omalloc update

XXX keep arc4random result caching (for now), the benefits of not using
XXX getpid() here overweigh the issues
@
text
@d33 2
a34 2
.\"	$MirOS: src/lib/libc/stdlib/malloc.3,v 1.5 2012/12/21 21:49:18 tg Exp $
.\"	$OpenBSD: malloc.3,v 1.73 2013/07/18 10:14:49 schwarze Exp $
d36 1
a36 1
.Dd $Mdocdate: March 2 2014 $
d42 1
d54 2
d61 1
a61 2
.Ft char *
.Va malloc_options ;
d74 2
a75 2
function allocates uninitialized space for an object whose
size is specified by
a76 1
The
d78 1
a78 1
function maintains multiple lists of free blocks according to size, allocating
d80 2
a81 4
.Pp
The allocated space is
suitably aligned (after possible pointer
coercion) for storage of any type of object.
d86 1
a86 19
Allocation of a zero size object returns a pointer to a zero size object.
This zero size object is access protected, so any access to it will
generate an exception (SIGSEGV).
Many zero-sized objects can be placed consecutively in shared
protected pages.
The minimum size of the protection on each object is suitably aligned and
sized as previously stated, but the protection may extend further depending
on where in a protected zone the object lands.
.Pp
When using
.Fn malloc
be careful to avoid the following idiom:
.Bd -literal -offset indent
if ((p = malloc(num * size)) == NULL)
	err(1, "malloc");
.Ed
.Pp
The multiplication may lead to an integer overflow.
To avoid this,
d88 5
a92 1
is recommended.
d94 15
d110 5
d116 1
a116 7
must be used, be sure to test for overflow:
.Bd -literal -offset indent
if (size && num > SIZE_MAX / size) {
	errno = ENOMEM;
	err(1, "overflow");
}
.Ed
d119 8
a126 2
.Fn calloc
function allocates space for an array of
d128 1
a128 1
objects, each of whose size is
a129 5
The space is initialized to zero.
The use of
.Fn calloc
is strongly encouraged when allocating multiple sized objects
in order to avoid possible integer overflows.
d140 11
a150 1
is a null pointer, no action occurs.
d158 38
d198 10
a207 4
.Fn realloc
function changes the size of the object pointed to by
.Fa ptr
to
d209 1
a209 10
bytes and returns a pointer to the (possibly moved) object.
The contents of the object are unchanged up to the lesser
of the new and old sizes.
If the new size is larger, the value of the newly allocated portion
of the object is indeterminate and uninitialized.
If
.Fa ptr
is a null pointer, the
.Fn realloc
function behaves like the
d211 20
a230 11
function for the specified size.
If the space cannot be allocated, the object
pointed to by
.Fa ptr
is unchanged.
If
.Fa size
is zero and
.Fa ptr
is not a null pointer, the object it points to is freed and a new zero size
object is returned.
d233 1
a233 1
.Fn realloc
d262 1
a262 1
.Fn malloc
d269 163
d488 5
a532 5
.It Cm Z
.Dq Zero .
Fill some junk into the area allocated (see
.Cm J ) ,
except for the exact length the user asked for, which is zeroed.
d543 1
a543 1
.Dl # ln -s 'G\*(Lt\*(Lt' /etc/malloc.conf
a551 104
.Sh RETURN VALUES
The
.Fn malloc
and
.Fn calloc
functions return a pointer to the allocated space if successful; otherwise,
a null pointer is returned and
.Va errno
is set to
.Er ENOMEM .
.Pp
The
.Fn free
and
.Fn cfree
functions return no value.
.Pp
The
.Fn realloc
function returns a pointer to the (possibly moved) allocated space
if successful; otherwise, a null pointer is returned and
.Va errno
is set to
.Er ENOMEM .
.Sh ENVIRONMENT
.Bl -tag -width Ev
.It Ev MALLOC_OPTIONS
See above.
.El
.Sh FILES
.Bl -tag -width "/etc/malloc.conf"
.It Pa /etc/malloc.conf
symbolic link to filename containing option flags
.El
.Sh DIAGNOSTICS
If
.Fn malloc ,
.Fn calloc ,
.Fn realloc ,
or
.Fn free
detect an error condition,
a message will be printed to file descriptor
2 (not using stdio).
Errors will result in the process being aborted,
unless the
.Cm a
option has been specified.
.Pp
Here is a brief description of the error messages and what they mean:
.Bl -tag -width Ds
.It Dq out of memory
If the
.Cm X
option is specified it is an error for
.Fn malloc ,
.Fn calloc ,
or
.Fn realloc
to return
.Dv NULL .
.It Dq malloc init mmap failed
This is a rather weird condition that is most likely to indicate a
seriously overloaded system or a ulimit restriction.
.It Dq bogus pointer (double free?)
An attempt to
.Fn free
or
.Fn realloc
an unallocated pointer was made.
.It Dq chunk is already free
There was an attempt to free a chunk that had already been freed.
.It Dq modified chunk-pointer
The pointer passed to
.Fn free
or
.Fn realloc
has been modified.
.It Dq recursive call
An attempt was made to call recursively into these functions, i.e., from a
signal handler.
This behavior is not supported.
In particular, signal handlers should
.Em not
use any of the
.Fn malloc
functions nor utilize any other functions which may call
.Fn malloc
(e.g.,
.Xr stdio 3
routines).
.It Dq unknown char in MALLOC_OPTIONS
We found something we didn't understand.
.It Dq malloc cache overflow/underflow
The internal malloc page cache has been corrupted.
.It Dq malloc free slot lost
The internal malloc page cache has been corrupted.
.It Dq guard size
An inconsistent guard size was detected.
.It any other error
.Fn malloc
detected an internal error;
consult sources and/or wizards.
.El
d558 2
a559 1
.Xr posix_memalign 3
d562 6
a567 2
.Fn malloc
function conforms to
d569 22
d633 1
a633 1
randomization appeared in
d635 44
@


1.5
log
@merge omalloc update + bugfix it
@
text
@d33 2
a34 2
.\"	$MirOS: src/lib/libc/stdlib/malloc.3,v 1.4 2010/12/23 18:33:33 tg Exp $
.\"	$OpenBSD: malloc.3,v 1.71 2012/11/02 18:18:15 djm Exp $
d36 1
a36 1
.Dd $Mdocdate: December 21 2012 $
d47 1
a47 1
.Fd #include <stdlib.h>
d452 19
a470 3
The
.Nm
family of functions first appeared in
d472 1
@


1.4
log
@merge omalloc but don’t make it default just yet
@
text
@d33 2
a34 2
.\"	$MirOS: src/lib/libc/stdlib/malloc.3,v 1.3 2006/03/30 18:36:02 tg Exp $
.\"	$OpenBSD: malloc.3,v 1.68 2010/05/26 08:22:11 jmc Exp $
d36 1
a36 1
.Dd $Mdocdate: December 23 2010 $
d215 1
a215 1
.Pp
d244 1
a244 1
Enable use after free protection.
d251 4
d292 5
d324 3
a326 2
So to set a systemwide reduction of cache size and use guard pages:
.Dl # ln -s 'G\*(Lt' /etc/malloc.conf
@


1.3
log
@* let the user decide which malloc (mmap or brk) he wants;
  default to mmap (secure); for formal releases, probably,
  we'll default to brk again
  ok bsiegert@@
* note in malloc(3) man page that it's inaccurate for brk
* merge latest mmap and brk malloc versions from openbsd
* start warnings cleanup in brk malloc (but give up, mmap
  is even worse tho)
* sync brk and mmap malloc where possible (whitespace and
  KNF in the early file)
@
text
@d33 2
a34 2
.\"	$MirOS: src/lib/libc/stdlib/malloc.3,v 1.2 2006/01/31 12:31:57 tg Exp $
.\"	$OpenBSD: malloc.3,v 1.42 2006/01/18 06:36:05 jakemsr Exp $
d36 1
a36 1
.Dd August 27, 1996
d63 2
d66 2
a67 2
.Xr mmap 2
malloc, this manual page is inaccurate,
d96 23
d125 5
a129 1
The space is initialized to all bits zero.
d135 3
a137 3
to be deallocated, that is, at least made available for further allocation,
but if possible, it will be passed back to the kernel with
.Xr sbrk 2 .
d180 1
a180 1
one must be careful to avoid the following idiom:
d188 1
a188 1
until one knows the allocation has been successful.
d207 9
d228 5
a232 3
will coredump the process, rather than tolerate failure.
This is a very handy debugging aid, since the core file will represent the
time of failure, rather than when the null pointer was accessed.
d236 3
a238 2
will dump statistics in a file called
.Pa malloc.out
d247 4
d253 1
a253 1
Enable guard pages and chunk randomization.
a255 1
Smaller than page size chunks are returned in a random order.
d263 1
a263 1
Currently junk is bytes of 0xd0; this is pronounced
d266 1
a266 3
.It Cm N
Do not output warning messages when encountering possible corruption
or bad pointers.
d268 5
a272 3
.Dq Pointer Protection .
Pointer sized allocations are aligned to the end of a page to catch
sizeof(ptr) errors where sizeof(*ptr) is meant.
d286 2
d299 3
d309 1
a309 1
Reduce the size of the cache by a factor of two.
d312 1
a312 1
Double the size of the cache by a factor of two.
d315 2
a316 3
So to set a systemwide reduction of cache size and coredumps on problems
one would:
.Li ln -s 'A<' /etc/malloc.conf
d318 4
a321 6
The
.Cm J
and
.Cm Z
flags are mostly for testing and debugging.
If a program changes behavior if either of these options are used,
d324 1
a324 1
The default cache size is 16 pages.
d366 1
a366 1
detect an error or warning condition,
d369 4
a372 7
Errors will always result in the process being
.Xr abort 3 'ed.
If the
.Cm A
option has been specified, warnings will also
.Xr abort 3
the process.
d376 1
a376 7
.It Dq (ES): mumble mumble mumble
.Fn malloc
has been compiled with
.Dv \&-DEXTRA_SANITY
and something looks fishy in there.
Consult sources and/or wizards.
.It Dq allocation failed
d378 1
a378 1
.Cm A
d386 1
a386 1
.It Dq mmap(2) failed, check limits.
d388 8
a395 11
seriously overloaded system or a
.Xr ulimit 1
restriction.
.It Dq freelist is destroyed.
.Fn malloc Ns 's
internal freelist has been stomped on.
.El
.Pp
Here is a brief description of the warning messages and what they mean:
.Bl -tag -width Ds
.It Dq chunk/page is already free.
d397 1
a397 18
.It Dq junk pointer, too high to make sense.
The pointer doesn't make sense.
It's above the area of memory that
.Fn malloc
knows something about.
This could be a pointer from some
.Xr mmap 2 'ed
memory.
.It Dq junk pointer, too low to make sense.
The pointer doesn't make sense.
It's below the area of memory that
.Fn malloc
knows something about.
This pointer probably came from your data or bss segments.
.It Dq malloc() has never been called.
Nothing has ever been allocated, yet something is being freed or
realloc'ed.
.It Dq modified (chunk-/page-) pointer.
d403 1
a403 6
.It Dq pointer to wrong page.
The pointer that
.Fn malloc
is trying to free is not pointing to
a sensible page.
.It Dq recursive call.
d418 10
d432 1
d434 2
a435 1
.Xr getpagesize 3
d442 26
a467 23
The present implementation of
.Fn malloc
started out as a filesystem on a drum
attached to a 20-bit binary challenged computer built with discrete germanium
transistors, and it has since graduated to handle primary storage rather than
secondary.
.Pp
The main difference from other
.Fn malloc
implementations are believed to be that
the free pages are not accessed until allocated.
Most
.Fn malloc
implementations will store a data structure containing a,
possibly double-, linked list in the free chunks of memory, used to tie
all the free memory together.
That is a quite suboptimal thing to do.
Every time the free-list is traversed, all the otherwise unused, and very
likely paged out, pages get faulted into primary memory, just to see what
lies after them in the list.
.Pp
On systems which are paging, this can increase the page-faults
of a process by a factor of five.
@


1.2
log
@mmap malloc. Enjoy!
@
text
@d33 1
a33 1
.\"	$MirOS$
d61 7
@


1.1
log
@Initial revision
@
text
@d33 2
a34 1
.\"	$OpenBSD: malloc.3,v 1.37 2004/07/02 10:42:55 jmc Exp $
d100 1
a100 1
but if possible, it will passed back to the kernel with
a185 1
.Pp
a193 1
.Pp
a198 1
.Pp
a204 1
.Pp
a208 1
.Pp
a214 1
.Pp
d218 4
a221 1
.Pp
a234 1
.Pp
a245 1
.Pp
a250 1
.Pp
a253 1
.Pp
d297 2
d300 1
d325 1
a325 1
.Bl -tag -width Fl
d353 1
a353 1
.Bl -tag -width Fl
d374 5
a378 1
The pointer passed to free or realloc has been modified.
d402 1
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d33 1
a33 1
.\"	$OpenBSD: malloc.3,v 1.40 2005/06/07 09:04:42 jmc Exp $
d185 1
d194 1
d200 1
d207 1
d212 1
d219 1
d223 1
a223 4
.It Cm P
.Dq Pointer Protection .
Pointer sized allocations are aligned to the end of a page to catch
sizeof(ptr) errors where sizeof(*ptr) is meant.
d237 1
d249 1
d255 1
d259 1
@


1.1.1.3
log
@Import OpenBSD's libc as of today, minus some of the locale stuff,
and with brk malloc instead of mmap malloc
@
text
@d33 1
a33 1
.\"	$OpenBSD: malloc.3,v 1.41 2005/07/26 04:20:23 jaredy Exp $
a295 2
.Bl -tag -width Ev
.It Ev MALLOC_OPTIONS
a296 1
.El
d321 1
a321 1
.Bl -tag -width Ds
d349 1
a349 1
.Bl -tag -width Ds
d370 1
a370 5
The pointer passed to
.Fn free
or
.Fn realloc
has been modified.
@


1.1.1.4
log
@Import mmap(2) malloc(3)
@
text
@d33 1
a33 1
.\"	$OpenBSD: malloc.3,v 1.42 2006/01/18 06:36:05 jakemsr Exp $
d99 1
a99 1
but if possible, it will be passed back to the kernel with
@


1.1.1.5
log
@say hello to omalloc
@
text
@d33 1
a33 1
.\"	$OpenBSD: malloc.3,v 1.68 2010/05/26 08:22:11 jmc Exp $
d35 1
a35 1
.Dd $Mdocdate: May 26 2010 $
a85 23
When using
.Fn malloc
be careful to avoid the following idiom:
.Bd -literal -offset indent
if ((p = malloc(num * size)) == NULL)
	err(1, "malloc");
.Ed
.Pp
The multiplication may lead to an integer overflow.
To avoid this,
.Fn calloc
is recommended.
.Pp
If
.Fn malloc
must be used, be sure to test for overflow:
.Bd -literal -offset indent
if (size && num > SIZE_MAX / size) {
	errno = ENOMEM;
	err(1, "overflow");
}
.Ed
.Pp
d92 1
a92 5
The space is initialized to zero.
The use of
.Fn calloc
is strongly encouraged when allocating multiple sized objects
in order to avoid possible integer overflows.
d98 3
a100 3
to be either placed on a list of free pages to make it available for future
allocation or, if required, to be returned to the kernel using
.Xr munmap 2 .
d143 1
a143 1
be careful to avoid the following idiom:
d151 1
a151 1
until the allocation has been successful.
a169 9
As with
.Fn malloc
it is important to ensure the new size value will not overflow;
i.e. avoid allocations like the following:
.Bd -literal -offset indent
if ((newp = realloc(p, num * size)) == NULL) {
	...
.Ed
.Pp
d182 3
a184 5
will coredump the process, rather than tolerate internal
inconsistencies or incorrect usage.
This is the default and a very handy debugging aid,
since the core file represents the time of failure,
rather than when the bogus pointer was used.
d188 2
a189 3
will dump statistics to the file
.Pa ./malloc.out ,
if it already exists,
a197 4
This will also switch off the delayed freeing of chunks,
reducing random behaviour but detecting double
.Fn free
calls as early as possible.
d200 1
a200 1
Enable guard pages.
d203 1
d211 1
a211 1
Currently junk is bytes of 0xd0 when allocating; this is pronounced
d214 3
a216 1
Freed chunks are filled with 0xdf.
d218 3
a220 5
.Dq Move allocations within a page.
Allocations larger than half a page but smaller than a page
are aligned to the end of a page to catch buffer overruns in more
cases.
This is the default.
a233 2
.It Cm S
Enable all options suitable for security auditing.
a244 3
.Pp
Note that this will cause code that is supposed to handle
out-of-memory conditions gracefully to abort instead.
d252 1
a252 1
Decrease the size of the free page cache by a factor of two.
d255 1
a255 1
Increase the size of the free page cache by a factor of two.
d258 3
a260 2
So to set a systemwide reduction of cache size and use guard pages:
.Dl # ln -s 'G\*(Lt' /etc/malloc.conf
d262 6
a267 4
The flags are mostly for testing and debugging.
If a program changes behavior if any of these options (except
.Cm X )
are used,
d270 1
a270 1
The default number of free pages cached is 64.
d312 1
a312 1
detect an error condition,
d315 7
a321 4
Errors will result in the process being aborted,
unless the
.Cm a
option has been specified.
d325 7
a331 1
.It Dq out of memory
d333 1
a333 1
.Cm X
d341 1
a341 1
.It Dq malloc init mmap failed
d343 11
a353 8
seriously overloaded system or a ulimit restriction.
.It Dq bogus pointer (double free?)
An attempt to
.Fn free
or
.Fn realloc
an unallocated pointer was made.
.It Dq chunk is already free
d355 18
a372 1
.It Dq modified chunk-pointer
d378 6
a383 1
.It Dq recursive call
a397 10
.It Dq malloc cache overflow/underflow
The internal malloc page cache has been corrupted.
.It Dq malloc free slot lost
The internal malloc page cache has been corrupted.
.It Dq guard size
An inconsistent guard size was detected.
.It any other error
.Fn malloc
detected an internal error;
consult sources and/or wizards.
a400 2
.Xr mmap 2 ,
.Xr munmap 2 ,
d402 1
a402 2
.Xr getpagesize 3 ,
.Xr posix_memalign 3
d409 23
a431 26
The
.Nm
family of functions first appeared in
.At v7 .
A new implementation by Chris Kingsley was introduced in
.Bx 4.2 ,
followed by a complete rewrite by Poul-Henning Kamp which appeared in
.Fx 2.2
and was included in
.Ox 2.0 .
These implementations were all
.Xr sbrk 2
based.
In
.Ox 3.8 ,
Thierry Deval rewrote
.Nm
to use the
.Xr mmap 2
system call,
making the page addresses returned by
.Nm
random.
A rewrite by Otto Moerbeek introducing a new central data structure and more
randomization appeared in
.Ox 4.4 .
@


1.1.1.6
log
@update omalloc
@
text
@d33 1
a33 1
.\"	$OpenBSD: malloc.3,v 1.71 2012/11/02 18:18:15 djm Exp $
d35 1
a35 1
.Dd $Mdocdate: November 2 2012 $
d205 1
a205 1
.Sh MALLOC_OPTIONS
d234 1
a234 1
Enable use after free detection.
a240 4
This option is intended for debugging rather than improved security
(use the
.Cm U
option for security).
a277 5
.It Cm U
.Dq Free unmap .
Enable use after free protection for larger allocations.
Unused pages on the freelist are read and write protected to
cause a segmentation fault upon access.
d305 2
a306 3
So to set a systemwide reduction of the cache to a quarter of the
default size and use guard pages:
.Dl # ln -s 'G\*(Lt\*(Lt' /etc/malloc.conf
@


1.1.1.7
log
@update omalloc
@
text
@d33 1
a33 1
.\"	$OpenBSD: malloc.3,v 1.73 2013/07/18 10:14:49 schwarze Exp $
d35 1
a35 1
.Dd $Mdocdate: July 18 2013 $
d46 1
a46 1
.In stdlib.h
d442 3
a444 19
A
.Fn free
internal kernel function and a predecessor to
.Fn malloc ,
.Fn alloc ,
first appeared in
.At v1 .
C library functions
.Fn alloc
and
.Fn free
appeared in
.At v6 .
The functions
.Fn malloc ,
.Fn calloc ,
and
.Fn realloc
first appeared in
a445 1
.Pp
@


1.1.1.8
log
@update malloc from obsd, except the last thread commit
@
text
@d33 1
a33 1
.\"	$OpenBSD: malloc.3,v 1.85 2014/10/30 21:47:47 deraadt Exp $
d35 1
a35 1
.Dd $Mdocdate: October 30 2014 $
a40 1
.Nm reallocarray ,
a51 2
.Fn reallocarray "void *ptr" "size_t nmemb" "size_t size"
.Ft void *
d57 1
a57 1
.Ft char * Ns
d62 2
a63 2
function allocates uninitialized space for an object of
the specified
d65 1
d67 1
a67 1
maintains multiple lists of free blocks according to size, allocating
d69 4
a72 2
The allocated space is suitably aligned (after possible pointer coercion) for
storage of any type of object.
d77 19
a95 1
The
d97 1
a97 5
function allocates space for an array of
.Fa nmemb
objects, each of the specified
.Fa size .
The space is initialized to zero.
a98 15
The
.Fn realloc
function changes the size of the object pointed to by
.Fa ptr
to
.Fa size
bytes and returns a pointer to the (possibly moved) object.
The contents of the object are unchanged up to the lesser
of the new and old sizes.
If the new size is larger, the value of the newly allocated portion
of the object is indeterminate and uninitialized.
If the space cannot be allocated, the object
pointed to by
.Fa ptr
is unchanged.
a99 5
.Fa ptr
is
.Dv NULL ,
.Fn realloc
behaves like
d101 7
a107 1
and allocates a new object.
d110 2
a111 8
.Fn reallocarray
function is similar to
.Fn realloc
except it operates on
.Fa nmemb
members of size
.Fa size
and checks for integer overflow in the calculation
d113 1
a113 1
*
d115 5
d130 1
a130 11
is a
.Dv NULL
pointer, no action occurs.
If
.Fa ptr
was previously freed by
.Fn free
.Fn realloc ,
or
.Fn reallocarray ,
the behavior is undefined and the double free is a security concern.
a137 13
.Sh RETURN VALUES
Upon successful completion, the functions
.Fn malloc ,
.Fn calloc ,
.Fn realloc ,
and
.Fn reallocarray
return a pointer to the allocated space; otherwise, a
.Dv NULL
pointer is returned and
.Va errno
is set to
.Er ENOMEM .
d139 4
a142 22
If
.Fa size
or
.Fa nmemb
is equal to 0, a unique pointer to an access protected,
zero sized object is returned.
Access via this pointer will generate a
.Dv SIGSEGV
exception.
.Pp
If multiplying
.Fa nmemb
and
.Fa size
results in integer overflow,
.Fn calloc
and
.Fn reallocarray
return
.Dv NULL
and set
.Va errno
a143 13
.Er ENOMEM .
.Pp
The
.Fn free
and
.Fn cfree
functions return no value.
.Sh IDIOMS
Consider
.Fn calloc
or the extension
.Fn reallocarray
when there is multiplication in the
d145 10
a154 1
argument of
d156 11
a166 20
or
.Fn realloc .
For example, avoid this common idiom as it may lead to integer overflow:
.Bd -literal -offset indent
if ((p = malloc(num * size)) == NULL)
	err(1, "malloc");
.Ed
.Pp
A drop-in replacement is the
.Ox
extension
.Fn reallocarray :
.Bd -literal -offset indent
if ((p = reallocarray(NULL, num, size)) == NULL)
	err(1, "reallocarray");
.Ed
.Pp
Alternatively,
.Fn calloc
may be used at the cost of initialization overhead.
d169 1
a169 1
.Fn realloc ,
d198 1
a198 1
.Fn malloc ,
a204 163
.Pp
Instead, use
.Fn reallocarray :
.Bd -literal -offset indent
if ((newp = reallocarray(p, num, size)) == NULL) {
	...
.Ed
.Pp
Calling
.Fn realloc
with a
.Dv NULL
.Fa ptr
is equivalent to calling
.Fn malloc .
Instead of this idiom:
.Bd -literal -offset indent
if (p == NULL)
	newp = malloc(newsize);
else
	newp = realloc(p, newsize);
.Ed
.Pp
Use the following:
.Bd -literal -offset indent
newp = realloc(p, newsize);
.Ed
.Sh ENVIRONMENT
.Bl -tag -width Ev
.It Ev MALLOC_OPTIONS
See below.
.El
.Sh FILES
.Bl -tag -width "/etc/malloc.conf"
.It Pa /etc/malloc.conf
symbolic link to filename containing option flags
.El
.Sh EXAMPLES
If
.Fn malloc
must be used with multiplication, be sure to test for overflow:
.Bd -literal -offset indent
size_t num, size;
\&...

/* Check for size_t overflow */
if (size && num > SIZE_MAX / size)
	errc(1, EOVERFLOW, "overflow");

if ((p = malloc(size * num)) == NULL)
	err(1, "malloc");
.Ed
.Pp
The above test is not sufficient in all cases.
For example, multiplying ints requires a different set of checks:
.Bd -literal -offset indent
int num, size;
\&...

/* Avoid invalid requests */
if (size < 0 || num < 0)
	errc(1, EOVERFLOW, "overflow");

/* Check for signed int overflow */
if (size && num > INT_MAX / size)
	errc(1, EOVERFLOW, "overflow");

if ((p = malloc(size * num)) == NULL)
	err(1, "malloc");
.Ed
.Pp
Assuming the implementation checks for integer overflow as
.Ox
does, it is much easier to use
.Fn calloc
or
.Fn reallocarray .
.Pp
The above examples could be simplified to:
.Bd -literal -offset indent
if ((p = reallocarray(NULL, num, size)) == NULL)
	err(1, "reallocarray");
.Ed
.Pp
or at the cost of initialization:
.Bd -literal -offset indent
if ((p = calloc(num, size)) == NULL)
	err(1, "calloc");
.Ed
.Sh DIAGNOSTICS
If
.Fn malloc ,
.Fn calloc ,
.Fn realloc ,
.Fn reallocarray ,
or
.Fn free
detect an error condition,
a message will be printed to file descriptor
2 (not using stdio).
Errors will result in the process being aborted,
unless the
.Cm a
option has been specified.
.Pp
Here is a brief description of the error messages and what they mean:
.Bl -tag -width Ds
.It Dq out of memory
If the
.Cm X
option is specified it is an error for
.Fn malloc ,
.Fn calloc ,
.Fn realloc ,
or
.Fn reallocarray
to return
.Dv NULL .
.It Dq malloc init mmap failed
This is a rather weird condition that is most likely to indicate a
seriously overloaded system or a ulimit restriction.
.It Dq bogus pointer (double free?)
An attempt to
.Fn free ,
.Fn realloc ,
or
.Fn reallocarray
an unallocated pointer was made.
.It Dq chunk is already free
There was an attempt to free a chunk that had already been freed.
.It Dq modified chunk-pointer
The pointer passed to
.Fn free ,
.Fn realloc ,
or
.Fn reallocarray
has been modified.
.It Dq recursive call
An attempt was made to call recursively into these functions, i.e., from a
signal handler.
This behavior is not supported.
In particular, signal handlers should
.Em not
use any of the
.Fn malloc
functions nor utilize any other functions which may call
.Fn malloc
(e.g.,
.Xr stdio 3
routines).
.It Dq unknown char in MALLOC_OPTIONS
We found something we didn't understand.
.It Dq malloc cache overflow/underflow
The internal malloc page cache has been corrupted.
.It Dq malloc free slot lost
The internal malloc page cache has been corrupted.
.It Dq guard size
An inconsistent guard size was detected.
.It any other error
.Fn malloc
detected an internal error;
consult sources and/or wizards.
.El
a260 5
.It Cm j
.Dq Don't Junk .
By default, small chunks are always junked, and the first part of pages
is junked after free.
This option ensures that no junking is performed.
d301 5
d316 1
a316 1
.Dl # ln -s 'G<<' /etc/malloc.conf
d325 104
d435 1
a435 2
.Xr posix_memalign 3 ,
.Xr sysconf 3
d438 2
a439 6
.Fn malloc ,
.Fn calloc ,
.Fn realloc ,
and
.Fn free
functions conform to
a440 22
.Pp
If
.Fa size
or
.Fa nmemb
are 0, the return value is implementation defined;
other conforming implementations may return
.Dv NULL
in this case.
.Pp
The standard does not require
.Fn calloc
to check for integer overflow,
but most modern implementations provide this check.
.Pp
The
.Ev MALLOC_OPTIONS
environment variable, the file
.Pa /etc/malloc.conf ,
and the
.Sx DIAGNOSTICS
output are extensions to the standard.
a484 44
.Pp
The
.Fn reallocarray
function appeared in
.Ox 5.6 .
.Pp
The
.Fn cfree
function appeared in SunOS 4.x.
.Sh CAVEATS
When using
.Fn malloc ,
be wary of signed integer and
.Vt size_t
overflow especially when there is multiplication in the
.Fa size
argument.
.Pp
Signed integer overflow will cause undefined behavior which compilers
typically handle by wrapping back around to negative numbers.
Depending on the input, this can result in allocating more or less
memory than intended.
.Pp
An unsigned overflow has defined behavior which will wrap back around and
return less memory than intended.
.Pp
A signed or unsigned integer overflow is a
.Em security
risk if less memory is returned than intended.
Subsequent code may corrupt the heap by writing beyond the memory that was
allocated.
An attacker may be able to leverage this heap corruption to execute arbitrary
code.
.Pp
Consider using
.Fn calloc
or
.Fn reallocarray
instead of using multiplication in
.Fn malloc
and
.Fn realloc
to avoid these problems on
.Ox .
@


