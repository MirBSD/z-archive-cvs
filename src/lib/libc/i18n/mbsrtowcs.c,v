head	1.15;
access;
symbols
	MIRBSD_10:1.9.0.2
	MIRBSD_10_BASE:1.9
	MIRBSD_9_BASE:1.3;
locks; strict;
comment	@ * @;


1.15
date	2019.12.07.15.21.01;	author tg;	state Exp;
branches;
next	1.14;
commitid	1005DEBC37177F93D08;

1.14
date	2014.02.09.22.35.52;	author tg;	state Exp;
branches;
next	1.13;
commitid	10052F802DB25EB293D;

1.13
date	2008.11.22.11.23.22;	author tg;	state Exp;
branches;
next	1.12;
commitid	1004927EBB46A430F45;

1.12
date	2008.08.17.00.19.08;	author tg;	state Exp;
branches;
next	1.11;
commitid	10048A76D6E14FD6E0B;

1.11
date	2008.08.16.23.51.13;	author tg;	state Exp;
branches;
next	1.10;
commitid	10048A767FA1A05A8CE;

1.10
date	2008.08.01.23.37.46;	author tg;	state Exp;
branches;
next	1.9;
commitid	10048939E5F6024C670;

1.9
date	2007.02.02.21.06.21;	author tg;	state Exp;
branches;
next	1.8;
commitid	10045C3A79F53A9E808;

1.8
date	2007.02.02.19.28.33;	author tg;	state Exp;
branches;
next	1.7;
commitid	10045C390D6140801E9;

1.7
date	2006.11.20.23.50.48;	author tg;	state Exp;
branches;
next	1.6;
commitid	10045623E721D637299;

1.6
date	2006.11.19.22.05.11;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004560D5040EA5698C;

1.5
date	2006.11.19.15.51.41;	author tg;	state Exp;
branches;
next	1.4;
commitid	10045607D9634C76ED7;

1.4
date	2006.11.01.20.01.19;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004548FD236EA4946C;

1.3
date	2006.06.03.21.52.51;	author tg;	state Exp;
branches;
next	1.2;
commitid	100448204C540F70216;

1.2
date	2006.06.03.21.30.03;	author tg;	state Exp;
branches;
next	1.1;
commitid	1004481FF6D4B5DB1E1;

1.1
date	2006.06.01.22.17.20;	author tg;	state Exp;
branches;
next	;
commitid	100447F676243262322;


desc
@@


1.15
log
@fix missing prototypes in libmbfun
@
text
@/*-
 * Copyright (c) 2008, 2019
 *	mirabilos <m@@mirbsd.org>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 *
 * The author reserves the right to steward the OPTU encoding forms.
 */

#include <mbfun.h>
#include <wchar.h>

__RCSID("$MirOS: src/lib/libc/i18n/mbsrtowcs.c,v 1.14 2014/02/09 22:35:52 tg Exp $");

#ifdef MBSNRTOWCSVIS
#undef mbsnrtowcs
#undef optu8to16
#define mbsnrtowcs mbsnrtowcsvis
#define optu8to16 optu8to16vis
#define MBSNRTOWCS
#endif

#ifdef MBSNRTOWCS
size_t
mbsnrtowcs(wchar_t *pwcs, const char **s, size_t max, size_t n, mbstate_t *ps)
#else
#define max MB_CUR_MAX
size_t
mbsrtowcs(wchar_t *pwcs, const char **s, size_t n, mbstate_t *ps)
#endif
{
	static mbstate_t internal_mbstate = { 0, 0 };
	size_t rv = 0, fr;
	wchar_t wc;
	const char * src = *s;

	if (__predict_false(ps == NULL))
		ps = &internal_mbstate;

#ifdef MBSNRTOWCS
	if (!max) {
		while (!pwcs || n) {
			if (optu8to16(&wc, NULL, 0, ps) != 0)
				break;
			if (pwcs)
				*pwcs++ = wc;
			++rv;
			--n;
		}
		goto done;
	}
#endif

 loop:
#ifdef MBSNRTOWCS
	if (!max)
		goto done;
#endif
	if (pwcs && !n)
		goto done;
	if ((fr = optu8to16(&wc, src, max, ps)) == (size_t)-2) {
		src += max;
		goto done;
	}
	/* fr == (size_t)-1 can never happen */
	src += fr;
#ifdef MBSNRTOWCS
	max -= fr;
#endif
	if (pwcs)
		*pwcs++ = wc;
	++rv;
	--n;
	if (wc)
		goto loop;
	src = NULL;
	--rv;

 done:
	if (pwcs)
		*s = src;
	return (rv);
}
@


1.14
log
@nuke the restrict qualifiers; C99 says this makes no externally visible difference and is only a compiler hint and a limitation to the interface implementor
@
text
@d2 2
a3 2
 * Copyright (c) 2008
 *	Thorsten Glaser <tg@@mirbsd.org>
d23 1
d26 1
a26 1
__RCSID("$MirOS: src/lib/libc/i18n/mbsrtowcs.c,v 1.13 2008/11/22 11:23:22 tg Exp $");
@


1.13
log
@add comment about the MirOS OPTU encoding stewardship (mine!!!)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/lib/libc/i18n/mbsrtowcs.c,v 1.12 2008/08/17 00:19:08 tg Exp $");
d37 1
a37 2
mbsnrtowcs(wchar_t * restrict pwcs, const char ** restrict s,
    size_t max, size_t n, mbstate_t * restrict ps)
d41 1
a41 2
mbsrtowcs(wchar_t * restrict pwcs, const char ** restrict s,
    size_t n, mbstate_t * restrict ps)
@


1.12
log
@extended conversion functions: “forgiving” variants of mbrtowc¹ and
mbsnrtowcs² encoding raw octets as if they were from codepage 1252,
or ISO-8859-1, into Unicode, instead of the PUA OPTU-16 range.

① called optu8to16vis with semantics of optu8to16
② called mbsnrtowcsvis with semantics of mbsnrtowcs

Note: mbtowc, mbstowcs and mbsrtowcs can be emulated by calling
mbrtowc(vis) and mbsnrtowcs(vis), respectively, with appropriate
arguments. The semantics have been chosen to not exactly match
the standard since the extensions are reasonably easy to use and
granted since these functions are not standardised anyway.
@
text
@d19 2
d25 1
a25 1
__RCSID("$MirOS: src/lib/libc/i18n/mbsrtowcs.c,v 1.11 2008/08/16 23:51:13 tg Exp $");
@


1.11
log
@optu-based mbsrtowcs(3) and mbsnrtowcs(3)
@
text
@d23 9
a31 1
__RCSID("$MirOS$");
@


1.10
log
@shaddap gcc
@
text
@a0 2
/* $MirOS: src/lib/libc/i18n/mbsrtowcs.c,v 1.9 2007/02/02 21:06:21 tg Exp $ */

d2 2
a3 2
 * Copyright (c) 2006, 2007
 *	Thorsten Glaser <tg@@mirbsd.de>
a10 4
 * Advertising materials mentioning features or use of this work must
 * display the following acknowledgement:
 *	This product includes material provided by Thorsten Glaser.
 *
a20 1
#include <errno.h>
d23 1
a23 1
__RCSID("$MirOS: src/lib/libc/i18n/mbsrtowcs.c,v 1.9 2007/02/02 21:06:21 tg Exp $");
d27 2
a28 2
mbsnrtowcs(wchar_t *__restrict__ dst, const char **__restrict__ src,
    size_t max, size_t len, mbstate_t *__restrict__ ps)
d30 1
d32 2
a33 2
mbsrtowcs(wchar_t *__restrict__ dst, const char **__restrict__ src,
    size_t len, mbstate_t *__restrict__ ps)
d37 3
a39 8
	const unsigned char *s = (const unsigned char *)(*src);
	wchar_t *d = dst;
	wint_t c, wc /* shut up gcc */ = 0;
	uint8_t count;

	/* make sure we can at least write one output wide character */
	if ((dst != NULL) && (len == 0))
		return (0);
a43 6
	if ((count = ps->count)) {
		wc = ps->value << 6;
		goto conv_state;
	}

 conv_first:
d45 8
a52 8
	if (s >= (*(const unsigned char **)src + max)) {
		/* wc is unimportant here since count == 0 */
 empty_buf:
		if (dst != NULL) {
			/* ps is only updated if we really write! */
			ps->count = count;
			ps->value = wc >> 6;
			*src = (const char *)s;
d54 1
a54 1
		return (d - dst);
a56 20
	wc = *s++;
	if (__predict_true(wc < 0x80)) {
		/* count == 0 already */
		;
	} else if (wc < 0xC2) {
		/* < 0xC0: spurious second byte */
		/* < 0xC2: non-minimalistic mapping error in 2-byte seqs */
 ilseq:
		errno = EILSEQ;
		return ((size_t)(-1));
	} else if (wc < 0xE0) {
		count = 1; /* one byte follows */
		wc = (wc & 0x1F) << 6;
	} else if (wc < 0xF0) {
		count = 2; /* two bytes follow */
		wc = (wc & 0x0F) << 12;
	} else {
		/* we don't support more than UCS-2 */
		goto ilseq;
	}
d58 1
a58 2
 conv_state:
	while (__predict_false(count)) {
d60 2
a61 2
		if (s >= (*(const unsigned char **)src + max))
			goto empty_buf;	/* here, we store wc and count */
d63 5
a67 8
		if (((c = *s++) & 0xC0) != 0x80)
			goto ilseq;
		c &= 0x3F;
		wc |= c << (6 * --count);

		/* Check for non-minimalistic mapping error in 3-byte seqs */
		if (__predict_false(count && (wc < 0x0800)))
			goto ilseq;
d69 18
a86 18

	if (__predict_false(wc > WCHAR_MAX))
		goto ilseq;

	if (dst != NULL)
		*d = wc;
	if (wc != L'\0') {
		++d;
		if ((dst == NULL) || (--len))
			goto conv_first;
	} else
		s = NULL;

	if (dst != NULL) {
		*src = (const char *)s;
		ps->count = 0;
	}
	return (d - dst);
@


1.9
log
@switch to a one-locale system; "the" locale is UTF-8 encoded 'C' now;
inline many simpler functions for reduced code size / imports / speed
and optimise a little - XXX untested
@
text
@d1 1
a1 1
/* $MirOS: src/share/misc/licence.template,v 1.20 2006/12/11 21:04:56 tg Rel $ */
d30 1
a30 1
__RCSID("$MirOS: src/lib/libc/i18n/mbsrtowcs.c,v 1.8 2007/02/02 19:28:33 tg Exp $");
d45 1
a45 1
	wint_t c, wc;
@


1.8
log
@second step: get rid of all the MIR18N_* configurable constants
@
text
@d1 1
a1 1
/* $MirOS: src/lib/libc/i18n/mbsrtowcs.c,v 1.7 2006/11/20 23:50:48 tg Exp $ */
d4 1
a4 1
 * Copyright (c) 2006
d7 5
a11 6
 * Licensee is hereby permitted to deal in this work without restric-
 * tion, including unlimited rights to use, publicly perform, modify,
 * merge, distribute, sell, give away or sublicence, provided all co-
 * pyright notices above, these terms and the disclaimer are retained
 * in all redistributions or reproduced in accompanying documentation
 * or other materials provided with binary redistributions.
d17 8
a24 8
 * Licensor offers the work "AS IS" and WITHOUT WARRANTY of any kind,
 * express, or implied, to the maximum extent permitted by applicable
 * law, without malicious intent or gross negligence; in no event may
 * licensor, an author or contributor be held liable for any indirect
 * or other damage, or direct damage except proven a consequence of a
 * direct error of said person and intended use of this work, loss or
 * other issues arising in any way out of its use, even if advised of
 * the possibility of such damage or existence of a defect.
d30 1
a30 3
#include "mir18n.h"

__RCSID("$MirOS: src/lib/libc/i18n/mbsrtowcs.c,v 1.7 2006/11/20 23:50:48 tg Exp $");
d46 1
a46 1
	unsigned count;
d55 1
a55 1
	if ((count = __locale_is_utf8 ? ps->count : 0)) {
d75 1
a75 6
	if (__predict_true(!__locale_is_utf8 || (wc < 0x80))) {
		if (__predict_false(wc > 0x7F)) {
 ilseq:
			errno = EILSEQ;
			return ((size_t)(-1));
		}
d77 1
d81 3
a83 1
		goto ilseq;
@


1.7
log
@implement mbsnrtowcs(3) and wcsnrtombs(3) - including manual pages

these are only visible if any of
	_GNU_SOURCE and not __STRICT_ANSI__ (gcc -ansi)
	(_OPENBSD_SOURCE or _NETBSD_SOURCE) and none of (_ANSI_SOURCE,
	    XPG and POSIX stuff) and not __STRICT_ANSI__ (gcc -ansi)
	_ALL_SOURCE and not __STRICT_ANSI__ (gcc -ansi)
are defined, since they're GNU (and MirOS) extensions
@
text
@d1 1
a1 1
/* $MirOS: src/lib/libc/i18n/mbsrtowcs.c,v 1.6 2006/11/19 22:05:11 tg Exp $ */
d33 1
a33 1
__RCSID("$MirOS: src/lib/libc/i18n/mbsrtowcs.c,v 1.6 2006/11/19 22:05:11 tg Exp $");
d79 1
a79 1
		if (__predict_false(wc > MIR18N_SB_CVT)) {
d116 1
a116 1
	if (__predict_false(wc > MIR18N_MB_MAX))
@


1.6
log
@revert the last change; this is really an API problem
(and who of you dares to tell me that standards don't suck?)

the correct solution for the conversion case is to add a new function:
http://www.gnu.org/software/libc/manual/html_node/Converting-Strings.html
http://www.freestandards.org/spec/booksets/LSB-Core-generic/LSB-Core-generic/baselib-mbsnrtowcs-3.html
unless one wants to use the iconv(3) interface
@
text
@d1 1
a1 1
/* $MirOS: src/lib/libc/i18n/mbsrtowcs.c,v 1.4 2006/11/01 20:01:19 tg Exp $ */
d33 1
a33 1
__RCSID("$MirOS: src/lib/libc/i18n/mbsrtowcs.c,v 1.4 2006/11/01 20:01:19 tg Exp $");
d35 5
d43 1
d64 13
d102 4
@


1.5
log
@implement restartability, which I had, apparently, forgotten
oops
@
text
@d83 1
a83 8
		if ((c = *s++) == 0) {
			ps->count = count;
			ps->value = wc >> 6;
			if (dst != NULL)
				*src = NULL;
			return (d - dst);
		}
		if ((c & 0xC0) != 0x80)
@


1.4
log
@sync licences, minor wcwidth KNF
@
text
@d1 1
a1 1
/* $MirOS: src/lib/libc/i18n/mbsrtowcs.c,v 1.3 2006/06/03 21:52:51 tg Exp $ */
d33 1
a33 1
__RCSID("$MirOS: src/lib/libc/i18n/mbsrtowcs.c,v 1.3 2006/06/03 21:52:51 tg Exp $");
d83 8
a90 1
		if (((c = *s++) & 0xC0) != 0x80)
@


1.3
log
@sync; reduce amount of gotos in the code
@
text
@d1 1
a1 1
/* $MirOS: src/lib/libc/i18n/mbsrtowcs.c,v 1.2 2006/06/03 21:30:03 tg Exp $ */
d14 2
a15 2
 * All advertising materials mentioning features or use of this soft-
 * ware must display the following acknowledgement:
d25 1
a25 1
 * the possibility of such damage or existence of a nontrivial bug.
d33 1
a33 1
__RCSID("$MirOS: src/lib/libc/i18n/mbsrtowcs.c,v 1.2 2006/06/03 21:30:03 tg Exp $");
@


1.2
log
@make this a little more readable, too
@
text
@d1 1
a1 1
/* $MirOS: src/lib/libc/i18n/mbsrtowcs.c,v 1.1 2006/06/01 22:17:20 tg Exp $ */
d33 1
a33 1
__RCSID("$MirOS: src/lib/libc/i18n/mbsrtowcs.c,v 1.1 2006/06/01 22:17:20 tg Exp $");
d68 1
a68 1
		/* < 0xC2: would map to 0x80 */
d82 1
a82 2
	if (__predict_false(count)) {
		/* process the second byte in 2- or 3-byte sequences */
a86 9
	}

	if (__predict_false(count)) {
		/* process the third byte in 3-byte sequences */
		if (((c = *s++) & 0xC0) != 0x80)
			goto ilseq;
		c &= 0x3F;
		wc |= c & 0x3F;
		count = 0;
d88 2
a89 2
		/* Check for non-minimalistic mapping encoding error */
		if (__predict_false(wc < 0x800))
@


1.1
log
@move freely licenced functions from libhaible into libc;
add missing wcsxfrm(3); sort and style; remove some stubs
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/libhaible/mbsrtowcs.c,v 1.14 2006/05/30 23:06:34 tg Exp $ */
d33 1
a33 1
__RCSID("$MirOS: contrib/code/libhaible/mbsrtowcs.c,v 1.14 2006/05/30 23:06:34 tg Exp $");
d36 2
a37 2
mbsrtowcs(wchar_t *__restrict__ pwcs, const char **__restrict__ sb,
    size_t n, mbstate_t *__restrict__ ps)
d40 8
a47 3
	const unsigned char *s = (const unsigned char *)(*sb);
	wint_t c, w;
	size_t frag, numb = 0;
d52 4
a55 1
	frag = __locale_is_utf8 ? ps->count : 0;
d57 4
a60 7
	while (((pwcs == NULL) ? 1 : n--) > 0) {
		if (__predict_true(frag == 0)) {
			if ((w = *s++) == L'\0')
				goto one_char;
			if (__predict_true(!__locale_is_utf8)) {
				if (__predict_true(w <= MIR18N_SB_CVT))
					goto one_char;
d62 18
a79 21
				errno = EILSEQ;
				return ((size_t)(-1));
			}
			if (w < 0x80) {
				goto one_char;
			} else if (w < 0xC2) {
				/* < 0xC0: spurious second byte */
				/* < 0xC2: would map to 0x80 */
				goto ilseq;
			} else if (w < 0xE0) {
				frag = 1; /* one byte follows */
				w = (w & 0x1F) << 6;
			} else if (w < 0xF0) {
				frag = 2; /* two bytes follow */
				w = (w & 0x0F) << 12;
			} else {
				/* we don't support more than UCS-2 */
				goto ilseq;
			}
		} else
			w = ps->value << 6;
d81 3
a83 1
 conv_byte:
d87 2
a88 1
		w |= c << (6 * --frag);
d90 7
a96 8
		if (__predict_false(frag)) {
			/* Check for non-minimalistic mapping
			 * encoding error in 3-byte sequences */
			if (__predict_false(w < 0x800))
				goto ilseq;
			else
				goto conv_byte;
		}
d98 2
a99 1
		if (__predict_false(w > MIR18N_MB_MAX))
d101 4
d106 11
a116 11
 one_char:
		if (pwcs != NULL)
			pwcs[numb] = w;
		if (w == L'\0') {
			s = NULL;
			break;
		}
		numb++;
	}
	if (pwcs != NULL) {
		*sb = (const char *)s;
d119 1
a119 1
	return (numb);
@

