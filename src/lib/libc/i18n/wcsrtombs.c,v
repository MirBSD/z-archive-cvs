head	1.10;
access;
symbols
	MIRBSD_10:1.6.0.2
	MIRBSD_10_BASE:1.6
	MIRBSD_9_BASE:1.2;
locks; strict;
comment	@ * @;


1.10
date	2014.02.09.22.35.53;	author tg;	state Exp;
branches;
next	1.9;
commitid	10052F802DB25EB293D;

1.9
date	2008.11.22.11.23.22;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004927EBB46A430F45;

1.8
date	2008.11.22.11.22.10;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004927EB6F7D7FA1B7;

1.7
date	2008.08.01.23.37.46;	author tg;	state Exp;
branches;
next	1.6;
commitid	10048939E5F6024C670;

1.6
date	2007.02.02.21.06.22;	author tg;	state Exp;
branches;
next	1.5;
commitid	10045C3A79F53A9E808;

1.5
date	2007.02.02.19.28.34;	author tg;	state Exp;
branches;
next	1.4;
commitid	10045C390D6140801E9;

1.4
date	2006.11.20.23.50.48;	author tg;	state Exp;
branches;
next	1.3;
commitid	10045623E721D637299;

1.3
date	2006.11.01.20.01.20;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004548FD236EA4946C;

1.2
date	2006.06.03.13.25.06;	author tg;	state Exp;
branches;
next	1.1;
commitid	10044818DA655FD2E78;

1.1
date	2006.06.01.22.17.21;	author tg;	state Exp;
branches;
next	;
commitid	100447F676243262322;


desc
@@


1.10
log
@nuke the restrict qualifiers; C99 says this makes no externally visible difference and is only a compiler hint and a limitation to the interface implementor
@
text
@/*-
 * Copyright (c) 2006, 2007, 2008
 *	Thorsten Glaser <tg@@mirbsd.org>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 *
 * The author reserves the right to steward the OPTU encoding forms.
 */

#include <errno.h>
#include <wchar.h>

__RCSID("$MirOS: src/lib/libc/i18n/wcsrtombs.c,v 1.9 2008/11/22 11:23:22 tg Exp $");

#ifdef WCSNRTOMBS
size_t
wcsnrtombs(char *dst, const wchar_t **src, size_t max, size_t len, mbstate_t *ps)
#else
size_t
wcsrtombs(char *dst, const wchar_t **src, size_t len, mbstate_t *ps)
#endif
{
	static mbstate_t internal_mbstate = { 0, 0 };	/* if ps == NULL */
	const wchar_t *s = *src;
	unsigned char *d = (unsigned char *)dst;
	wint_t wc /* shut up gcc */ = 0;
	uint8_t count;

	/* make sure we can at least write one output byte */
	if ((dst != NULL) && (len == 0))
		return (0);

	if (__predict_false(ps == NULL))
		ps = &internal_mbstate;

	if ((count = ps->count)) {
		wc = ps->value;
		/* process remnants */
		goto process_state;
	}

 process_firstbyte:
	/* count is zero here; devour an input wide character */
#ifdef WCSNRTOMBS
	if (s >= (*src + max))
		goto empty_buf;
#endif
	wc = *s++;
	/* create the first output byte and state information from it */
	if (__predict_false(wc > WCHAR_MAX)) {
		errno = EILSEQ;
		return ((size_t)(-1));
	} else if (__predict_true(wc < 0x80 || iswoctet(wc))) {
		if (dst != NULL)
			*d = wc & 0xFF;
		/* count is already 0 */
	} else if (wc < 0x0800) {
		if (dst != NULL)
			*d = (wc >> 6) | 0xC0;
		count = 1;
	} else {
		if (dst != NULL)
			*d = (wc >> 12) | 0xE0;
		count = 2;
	}
	/* account the output byte, except if it's the terminating NUL */
	if (wc > 0)
		++d;
	/* at this point, we have written an output byte */
	--len;

 process_state:
	/* entering with len >= 0, count + wc containing state info */
	while (__predict_false((count > 0) && ((len > 0) || (dst == NULL)))) {
		--count;
		if (dst != NULL)
			*d = ((wc >> (6 * count)) & 0x3F) | 0x80;
		++d;
		--len;
	}

	/* here: either len == 0 or count == 0 (or both!) */
	if (__predict_false(wc == 0))
		/* last character was a terminating NUL, count == 0 */
		s = NULL;
	else if (__predict_true(count == 0))
		/* so, if there's still output space left or we ignore it */
		if ((len > 0) || (dst == NULL))
			/* loop on to the next full input wide character */
			goto process_firstbyte;

#ifdef WCSNRTOMBS
 empty_buf:
#endif
	if (dst != NULL) {
		*src = s;
		/* save state information for restarting */
		ps->count = count;
		ps->value = wc;
	}
	return ((char *)d - dst);
}
@


1.9
log
@add comment about the MirOS OPTU encoding stewardship (mine!!!)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/lib/libc/i18n/wcsrtombs.c,v 1.8 2008/11/22 11:22:10 tg Exp $");
d30 1
a30 2
wcsnrtombs(char *__restrict__ dst, const wchar_t **__restrict__ src,
    size_t max, size_t len, mbstate_t *__restrict__ ps)
d33 1
a33 2
wcsrtombs(char *__restrict__ dst, const wchar_t **__restrict__ src,
    size_t len, mbstate_t *__restrict__ ps)
@


1.8
log
@OPTU-16 to OPTU-8 wcsrtombs(3)
@
text
@d19 2
d26 1
a26 1
__RCSID("$MirOS: src/lib/libc/i18n/wcsrtombs.c,v 1.7 2008/08/01 23:37:46 tg Exp $");
@


1.7
log
@shaddap gcc
@
text
@a0 2
/* $MirOS: src/lib/libc/i18n/wcsrtombs.c,v 1.6 2007/02/02 21:06:22 tg Exp $ */

d2 2
a3 2
 * Copyright (c) 2006, 2007
 *	Thorsten Glaser <tg@@mirbsd.de>
a10 4
 * Advertising materials mentioning features or use of this work must
 * display the following acknowledgement:
 *	This product includes material provided by Thorsten Glaser.
 *
d24 1
a24 1
__RCSID("$MirOS: src/lib/libc/i18n/wcsrtombs.c,v 1.6 2007/02/02 21:06:22 tg Exp $");
d66 1
a66 1
	} else if (__predict_true(wc < 0x80)) {
d68 1
a68 1
			*d = wc;
@


1.6
log
@switch to a one-locale system; "the" locale is UTF-8 encoded 'C' now;
inline many simpler functions for reduced code size / imports / speed
and optimise a little - XXX untested
@
text
@d1 1
a1 1
/* $MirOS: src/share/misc/licence.template,v 1.20 2006/12/11 21:04:56 tg Rel $ */
d30 1
a30 1
__RCSID("$MirOS: src/lib/libc/i18n/wcsrtombs.c,v 1.5 2007/02/02 19:28:34 tg Exp $");
d45 1
a45 1
	wint_t wc;
@


1.5
log
@second step: get rid of all the MIR18N_* configurable constants
@
text
@d1 1
a1 1
/* $MirOS: src/lib/libc/i18n/wcsrtombs.c,v 1.4 2006/11/20 23:50:48 tg Exp $ */
d4 1
a4 1
 * Copyright (c) 2006
d7 5
a11 6
 * Licensee is hereby permitted to deal in this work without restric-
 * tion, including unlimited rights to use, publicly perform, modify,
 * merge, distribute, sell, give away or sublicence, provided all co-
 * pyright notices above, these terms and the disclaimer are retained
 * in all redistributions or reproduced in accompanying documentation
 * or other materials provided with binary redistributions.
d17 8
a24 8
 * Licensor offers the work "AS IS" and WITHOUT WARRANTY of any kind,
 * express, or implied, to the maximum extent permitted by applicable
 * law, without malicious intent or gross negligence; in no event may
 * licensor, an author or contributor be held liable for any indirect
 * or other damage, or direct damage except proven a consequence of a
 * direct error of said person and intended use of this work, loss or
 * other issues arising in any way out of its use, even if advised of
 * the possibility of such damage or existence of a defect.
d30 1
a30 3
#include "mir18n.h"

__RCSID("$MirOS: src/lib/libc/i18n/wcsrtombs.c,v 1.4 2006/11/20 23:50:48 tg Exp $");
d45 2
a46 2
	wint_t wc, wc_max;
	unsigned count;
d55 1
a55 5
	/* highest allowed wide character to convert */
	wc_max = __locale_is_utf8 ? WCHAR_MAX : 0x7F;

	/* in the 'C' locale, the mbstate information is ignored */
	if ((count = __locale_is_utf8 ? ps->count : 0)) {
d69 1
a69 1
	if (__predict_false(wc > wc_max)) {
d72 1
a72 1
	} else if (__predict_true((wc < 0x80) || !__locale_is_utf8)) {
d75 1
@


1.4
log
@implement mbsnrtowcs(3) and wcsnrtombs(3) - including manual pages

these are only visible if any of
	_GNU_SOURCE and not __STRICT_ANSI__ (gcc -ansi)
	(_OPENBSD_SOURCE or _NETBSD_SOURCE) and none of (_ANSI_SOURCE,
	    XPG and POSIX stuff) and not __STRICT_ANSI__ (gcc -ansi)
	_ALL_SOURCE and not __STRICT_ANSI__ (gcc -ansi)
are defined, since they're GNU (and MirOS) extensions
@
text
@d1 1
a1 1
/* $MirOS: src/lib/libc/i18n/wcsrtombs.c,v 1.3 2006/11/01 20:01:20 tg Exp $ */
d33 1
a33 1
__RCSID("$MirOS: src/lib/libc/i18n/wcsrtombs.c,v 1.3 2006/11/01 20:01:20 tg Exp $");
d59 1
a59 1
	wc_max = __locale_is_utf8 ? MIR18N_MB_MAX : MIR18N_SB_CVT;
@


1.3
log
@sync licences, minor wcwidth KNF
@
text
@d1 1
a1 1
/* $MirOS: src/lib/libc/i18n/wcsrtombs.c,v 1.2 2006/06/03 13:25:06 tg Exp $ */
d33 1
a33 1
__RCSID("$MirOS: src/lib/libc/i18n/wcsrtombs.c,v 1.2 2006/06/03 13:25:06 tg Exp $");
d35 5
d43 1
d70 4
d117 3
@


1.2
log
@* rewrite from scratch (different algo, found in the restroom ;)
  to fix regression test errors, is now fully restarting, properly
* heavily optimise (even shrinks code size)
@
text
@d1 1
a1 1
/* $MirOS: src/lib/libc/i18n/wcsrtombs.c,v 1.1 2006/06/01 22:17:21 tg Exp $ */
d14 2
a15 2
 * All advertising materials mentioning features or use of this soft-
 * ware must display the following acknowledgement:
d25 1
a25 1
 * the possibility of such damage or existence of a nontrivial bug.
d33 1
a33 1
__RCSID("$MirOS: src/lib/libc/i18n/wcsrtombs.c,v 1.1 2006/06/01 22:17:21 tg Exp $");
@


1.1
log
@move freely licenced functions from libhaible into libc;
add missing wcsxfrm(3); sort and style; remove some stubs
@
text
@d1 1
a1 1
/* $MirOS: contrib/code/libhaible/wcsrtombs.c,v 1.1 2006/05/31 00:25:52 tg Exp $ */
d33 1
a33 1
__RCSID("$MirOS: contrib/code/libhaible/wcsrtombs.c,v 1.1 2006/05/31 00:25:52 tg Exp $");
d39 1
a39 1
	static mbstate_t internal_mbstate = { 0, 0 };
d42 6
a47 2
	size_t numb = 0;
	wint_t w;
d52 8
a59 9
	/* first process any hanging bytes */
	while (__locale_is_utf8 && __predict_false(ps->count)) {
		if (d != NULL) {
			if (len-- == 0)
				return (numb);
			d[numb] = ((ps->value >> (6 * --ps->count)) & 0x3F)
			    | 0x80;
		}
		++numb;
d62 14
a75 32
	/* now process the string */
 loop:
	w = *s++;
	if (!__locale_is_utf8 || (w < 0x80)) {
		if (!__locale_is_utf8 && __predict_false(w > MIR18N_SB_CVT)) {
 ilseq:
			errno = EILSEQ;
			return ((size_t)(-1));
		}
		if (d != NULL) {
			if (len-- == 0) {
				*src = --s;
				return (numb);
			}
			d[numb] = w;
		}
		if (w == 0) {
			*src = NULL;
			return (numb);
		}
	} else if (w < 0x0800) {
		ps->count = 1;
		ps->value = w;
		if (d != NULL) {
			if (len-- == 0) {
				*src = --s;
				return (numb);
			}
			d[numb] = (w >> 6) | 0xC0;
		}
	} else if (__predict_false(w > MIR18N_MB_MAX)) {
		goto ilseq;
d77 18
a94 9
		ps->count = 2;
		ps->value = w;
		if (d != NULL) {
			if (len-- == 0) {
				*src = --s;
				return (numb);
			}
			d[numb] = (w >> 12) | 0xE0;
		}
a95 1
	++numb;
d97 15
a111 9
	while (__predict_false(ps->count)) {
		if (d != NULL) {
			if (len-- == 0) {
				*src = s;
				return (numb);
			}
			d[numb] = ((w >> (6 * --ps->count)) & 0x3F) | 0x80;
		}
		++numb;
d113 1
a113 2

	goto loop;
@

