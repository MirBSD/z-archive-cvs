head	1.6;
access;
symbols
	MIRBSD_10:1.6.0.2
	MIRBSD_10_BASE:1.6
	MIRBSD_9_BASE:1.6
	expat-2_0_0:1.1.105.2
	MIRBSD_8:1.4.0.2
	MIRBSD_8_BASE:1.4
	expat-1_95_8:1.1.105.1
	expat:1.1.105;
locks; strict;
comment	@ * @;


1.6
date	2006.06.02.02.35.46;	author tg;	state Exp;
branches;
next	1.5;
commitid	100447FA41531D42A6E;

1.5
date	2006.06.01.23.31.17;	author tg;	state Exp;
branches;
next	1.4;
commitid	100447F78D90B0CC9DD;

1.4
date	2005.11.03.22.28.14;	author tg;	state Exp;
branches;
next	1.3;
commitid	7afc436a8eca13dd;

1.3
date	2005.10.21.11.33.35;	author tg;	state dead;
branches;
next	1.2;
commitid	275f4358cfde0f84;

1.2
date	2005.03.06.20.29.06;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.06.15.14.58;	author tg;	state Exp;
branches
	1.1.105.1;
next	;

1.1.105.1
date	2005.03.06.15.14.58;	author tg;	state Exp;
branches;
next	1.1.105.2;

1.1.105.2
date	2006.06.01.23.29.19;	author tg;	state Exp;
branches;
next	;
commitid	100447F78577DEBD528;


desc
@@


1.6
log
@clean up after merge
@
text
@/* Copyright (c) 1998, 1999 Thai Open Source Software Center Ltd
   See the file COPYING for copying permission.
*/

#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>

#include "expat.h"
#include "codepage.h"
#include "xmlfile.h"
#include "xmltchar.h"

#ifdef _MSC_VER
#include <crtdbg.h>
#endif

#ifdef AMIGA_SHARED_LIB
#include <proto/expat.h>
#endif

/* This ensures proper sorting. */

#define NSSEP T('\001')

static void XMLCALL
characterData(void *userData, const XML_Char *s, int len)
{
  FILE *fp = (FILE *)userData;
  for (; len > 0; --len, ++s) {
    switch (*s) {
    case T('&'):
      fputts(T("&amp;"), fp);
      break;
    case T('<'):
      fputts(T("&lt;"), fp);
      break;
    case T('>'):
      fputts(T("&gt;"), fp);
      break;
#ifdef W3C14N
    case 13:
      fputts(T("&#xD;"), fp);
      break;
#else
    case T('"'):
      fputts(T("&quot;"), fp);
      break;
    case 9:
    case 10:
    case 13:
      ftprintf(fp, T("&#%d;"), *s);
      break;
#endif
    default:
      puttc(*s, fp);
      break;
    }
  }
}

static void
attributeValue(FILE *fp, const XML_Char *s)
{
  puttc(T('='), fp);
  puttc(T('"'), fp);
  for (;;) {
    switch (*s) {
    case 0:
    case NSSEP:
      puttc(T('"'), fp);
      return;
    case T('&'):
      fputts(T("&amp;"), fp);
      break;
    case T('<'):
      fputts(T("&lt;"), fp);
      break;
    case T('"'):
      fputts(T("&quot;"), fp);
      break;
#ifdef W3C14N
    case 9:
      fputts(T("&#x9;"), fp);
      break;
    case 10:
      fputts(T("&#xA;"), fp);
      break;
    case 13:
      fputts(T("&#xD;"), fp);
      break;
#else
    case T('>'):
      fputts(T("&gt;"), fp);
      break;
    case 9:
    case 10:
    case 13:
      ftprintf(fp, T("&#%d;"), *s);
      break;
#endif
    default:
      puttc(*s, fp);
      break;
    }
    s++;
  }
}

/* Lexicographically comparing UTF-8 encoded attribute values,
is equivalent to lexicographically comparing based on the character number. */

static int
attcmp(const void *att1, const void *att2)
{
  return tcscmp(*(const XML_Char **)att1, *(const XML_Char **)att2);
}

static void XMLCALL
startElement(void *userData, const XML_Char *name, const XML_Char **atts)
{
  int nAtts;
  const XML_Char **p;
  FILE *fp = (FILE *)userData;
  puttc(T('<'), fp);
  fputts(name, fp);

  p = atts;
  while (*p)
    ++p;
  nAtts = (p - atts) >> 1;
  if (nAtts > 1)
    qsort((void *)atts, nAtts, sizeof(XML_Char *) * 2, attcmp);
  while (*atts) {
    puttc(T(' '), fp);
    fputts(*atts++, fp);
    attributeValue(fp, *atts);
    atts++;
  }
  puttc(T('>'), fp);
}

static void XMLCALL
endElement(void *userData, const XML_Char *name)
{
  FILE *fp = (FILE *)userData;
  puttc(T('<'), fp);
  puttc(T('/'), fp);
  fputts(name, fp);
  puttc(T('>'), fp);
}

static int
nsattcmp(const void *p1, const void *p2)
{
  const XML_Char *att1 = *(const XML_Char **)p1;
  const XML_Char *att2 = *(const XML_Char **)p2;
  int sep1 = (tcsrchr(att1, NSSEP) != 0);
  int sep2 = (tcsrchr(att1, NSSEP) != 0);
  if (sep1 != sep2)
    return sep1 - sep2;
  return tcscmp(att1, att2);
}

static void XMLCALL
startElementNS(void *userData, const XML_Char *name, const XML_Char **atts)
{
  int nAtts;
  int nsi;
  const XML_Char **p;
  FILE *fp = (FILE *)userData;
  const XML_Char *sep;
  puttc(T('<'), fp);

  sep = tcsrchr(name, NSSEP);
  if (sep) {
    fputts(T("n1:"), fp);
    fputts(sep + 1, fp);
    fputts(T(" xmlns:n1"), fp);
    attributeValue(fp, name);
    nsi = 2;
  }
  else {
    fputts(name, fp);
    nsi = 1;
  }

  p = atts;
  while (*p)
    ++p;
  nAtts = (p - atts) >> 1;
  if (nAtts > 1)
    qsort((void *)atts, nAtts, sizeof(XML_Char *) * 2, nsattcmp);
  while (*atts) {
    name = *atts++;
    sep = tcsrchr(name, NSSEP);
    puttc(T(' '), fp);
    if (sep) {
      ftprintf(fp, T("n%d:"), nsi);
      fputts(sep + 1, fp);
    }
    else
      fputts(name, fp);
    attributeValue(fp, *atts);
    if (sep) {
      ftprintf(fp, T(" xmlns:n%d"), nsi++);
      attributeValue(fp, name);
    }
    atts++;
  }
  puttc(T('>'), fp);
}

static void XMLCALL
endElementNS(void *userData, const XML_Char *name)
{
  FILE *fp = (FILE *)userData;
  const XML_Char *sep;
  puttc(T('<'), fp);
  puttc(T('/'), fp);
  sep = tcsrchr(name, NSSEP);
  if (sep) {
    fputts(T("n1:"), fp);
    fputts(sep + 1, fp);
  }
  else
    fputts(name, fp);
  puttc(T('>'), fp);
}

#ifndef W3C14N

static void XMLCALL
processingInstruction(void *userData, const XML_Char *target,
                      const XML_Char *data)
{
  FILE *fp = (FILE *)userData;
  puttc(T('<'), fp);
  puttc(T('?'), fp);
  fputts(target, fp);
  puttc(T(' '), fp);
  fputts(data, fp);
  puttc(T('?'), fp);
  puttc(T('>'), fp);
}

#endif /* not W3C14N */

static void XMLCALL
defaultCharacterData(void *userData, const XML_Char *s, int len)
{
  XML_DefaultCurrent((XML_Parser) userData);
}

static void XMLCALL
defaultStartElement(void *userData, const XML_Char *name,
                    const XML_Char **atts)
{
  XML_DefaultCurrent((XML_Parser) userData);
}

static void XMLCALL
defaultEndElement(void *userData, const XML_Char *name)
{
  XML_DefaultCurrent((XML_Parser) userData);
}

static void XMLCALL
defaultProcessingInstruction(void *userData, const XML_Char *target,
                             const XML_Char *data)
{
  XML_DefaultCurrent((XML_Parser) userData);
}

static void XMLCALL
nopCharacterData(void *userData, const XML_Char *s, int len)
{
}

static void XMLCALL
nopStartElement(void *userData, const XML_Char *name, const XML_Char **atts)
{
}

static void XMLCALL
nopEndElement(void *userData, const XML_Char *name)
{
}

static void XMLCALL
nopProcessingInstruction(void *userData, const XML_Char *target,
                         const XML_Char *data)
{
}

static void XMLCALL
markup(void *userData, const XML_Char *s, int len)
{
  FILE *fp = (FILE *)XML_GetUserData((XML_Parser) userData);
  for (; len > 0; --len, ++s)
    puttc(*s, fp);
}

static void
metaLocation(XML_Parser parser)
{
  const XML_Char *uri = XML_GetBase(parser);
  if (uri)
    ftprintf((FILE *)XML_GetUserData(parser), T(" uri=\"%s\""), uri);
  ftprintf((FILE *)XML_GetUserData(parser),
           T(" byte=\"%" XML_FMT_INT_MOD "d\" nbytes=\"%d\" \
			 line=\"%" XML_FMT_INT_MOD "u\" col=\"%" XML_FMT_INT_MOD "u\""),
           XML_GetCurrentByteIndex(parser),
           XML_GetCurrentByteCount(parser),
           XML_GetCurrentLineNumber(parser),
           XML_GetCurrentColumnNumber(parser));
}

static void
metaStartDocument(void *userData)
{
  fputts(T("<document>\n"), (FILE *)XML_GetUserData((XML_Parser) userData));
}

static void
metaEndDocument(void *userData)
{
  fputts(T("</document>\n"), (FILE *)XML_GetUserData((XML_Parser) userData));
}

static void XMLCALL
metaStartElement(void *userData, const XML_Char *name,
                 const XML_Char **atts)
{
  XML_Parser parser = (XML_Parser) userData;
  FILE *fp = (FILE *)XML_GetUserData(parser);
  const XML_Char **specifiedAttsEnd
    = atts + XML_GetSpecifiedAttributeCount(parser);
  const XML_Char **idAttPtr;
  int idAttIndex = XML_GetIdAttributeIndex(parser);
  if (idAttIndex < 0)
    idAttPtr = 0;
  else
    idAttPtr = atts + idAttIndex;
    
  ftprintf(fp, T("<starttag name=\"%s\""), name);
  metaLocation(parser);
  if (*atts) {
    fputts(T(">\n"), fp);
    do {
      ftprintf(fp, T("<attribute name=\"%s\" value=\""), atts[0]);
      characterData(fp, atts[1], tcslen(atts[1]));
      if (atts >= specifiedAttsEnd)
        fputts(T("\" defaulted=\"yes\"/>\n"), fp);
      else if (atts == idAttPtr)
        fputts(T("\" id=\"yes\"/>\n"), fp);
      else
        fputts(T("\"/>\n"), fp);
    } while (*(atts += 2));
    fputts(T("</starttag>\n"), fp);
  }
  else
    fputts(T("/>\n"), fp);
}

static void XMLCALL
metaEndElement(void *userData, const XML_Char *name)
{
  XML_Parser parser = (XML_Parser) userData;
  FILE *fp = (FILE *)XML_GetUserData(parser);
  ftprintf(fp, T("<endtag name=\"%s\""), name);
  metaLocation(parser);
  fputts(T("/>\n"), fp);
}

static void XMLCALL
metaProcessingInstruction(void *userData, const XML_Char *target,
                          const XML_Char *data)
{
  XML_Parser parser = (XML_Parser) userData;
  FILE *fp = (FILE *)XML_GetUserData(parser);
  ftprintf(fp, T("<pi target=\"%s\" data=\""), target);
  characterData(fp, data, tcslen(data));
  puttc(T('"'), fp);
  metaLocation(parser);
  fputts(T("/>\n"), fp);
}

static void XMLCALL
metaComment(void *userData, const XML_Char *data)
{
  XML_Parser parser = (XML_Parser) userData;
  FILE *fp = (FILE *)XML_GetUserData(parser);
  fputts(T("<comment data=\""), fp);
  characterData(fp, data, tcslen(data));
  puttc(T('"'), fp);
  metaLocation(parser);
  fputts(T("/>\n"), fp);
}

static void XMLCALL
metaStartCdataSection(void *userData)
{
  XML_Parser parser = (XML_Parser) userData;
  FILE *fp = (FILE *)XML_GetUserData(parser);
  fputts(T("<startcdata"), fp);
  metaLocation(parser);
  fputts(T("/>\n"), fp);
}

static void XMLCALL
metaEndCdataSection(void *userData)
{
  XML_Parser parser = (XML_Parser) userData;
  FILE *fp = (FILE *)XML_GetUserData(parser);
  fputts(T("<endcdata"), fp);
  metaLocation(parser);
  fputts(T("/>\n"), fp);
}

static void XMLCALL
metaCharacterData(void *userData, const XML_Char *s, int len)
{
  XML_Parser parser = (XML_Parser) userData;
  FILE *fp = (FILE *)XML_GetUserData(parser);
  fputts(T("<chars str=\""), fp);
  characterData(fp, s, len);
  puttc(T('"'), fp);
  metaLocation(parser);
  fputts(T("/>\n"), fp);
}

static void XMLCALL
metaStartDoctypeDecl(void *userData,
                     const XML_Char *doctypeName,
                     const XML_Char *sysid,
                     const XML_Char *pubid,
                     int has_internal_subset)
{
  XML_Parser parser = (XML_Parser) userData;
  FILE *fp = (FILE *)XML_GetUserData(parser);
  ftprintf(fp, T("<startdoctype name=\"%s\""), doctypeName);
  metaLocation(parser);
  fputts(T("/>\n"), fp);
}

static void XMLCALL
metaEndDoctypeDecl(void *userData)
{
  XML_Parser parser = (XML_Parser) userData;
  FILE *fp = (FILE *)XML_GetUserData(parser);
  fputts(T("<enddoctype"), fp);
  metaLocation(parser);
  fputts(T("/>\n"), fp);
}

static void XMLCALL
metaNotationDecl(void *userData,
                 const XML_Char *notationName,
                 const XML_Char *base,
                 const XML_Char *systemId,
                 const XML_Char *publicId)
{
  XML_Parser parser = (XML_Parser) userData;
  FILE *fp = (FILE *)XML_GetUserData(parser);
  ftprintf(fp, T("<notation name=\"%s\""), notationName);
  if (publicId)
    ftprintf(fp, T(" public=\"%s\""), publicId);
  if (systemId) {
    fputts(T(" system=\""), fp);
    characterData(fp, systemId, tcslen(systemId));
    puttc(T('"'), fp);
  }
  metaLocation(parser);
  fputts(T("/>\n"), fp);
}


static void XMLCALL
metaEntityDecl(void *userData,
               const XML_Char *entityName,
               int  is_param,
               const XML_Char *value,
               int  value_length,
               const XML_Char *base,
               const XML_Char *systemId,
               const XML_Char *publicId,
               const XML_Char *notationName)
{
  XML_Parser parser = (XML_Parser) userData;
  FILE *fp = (FILE *)XML_GetUserData(parser);

  if (value) {
    ftprintf(fp, T("<entity name=\"%s\""), entityName);
    metaLocation(parser);
    puttc(T('>'), fp);
    characterData(fp, value, value_length);
    fputts(T("</entity/>\n"), fp);
  }
  else if (notationName) {
    ftprintf(fp, T("<entity name=\"%s\""), entityName);
    if (publicId)
      ftprintf(fp, T(" public=\"%s\""), publicId);
    fputts(T(" system=\""), fp);
    characterData(fp, systemId, tcslen(systemId));
    puttc(T('"'), fp);
    ftprintf(fp, T(" notation=\"%s\""), notationName);
    metaLocation(parser);
    fputts(T("/>\n"), fp);
  }
  else {
    ftprintf(fp, T("<entity name=\"%s\""), entityName);
    if (publicId)
      ftprintf(fp, T(" public=\"%s\""), publicId);
    fputts(T(" system=\""), fp);
    characterData(fp, systemId, tcslen(systemId));
    puttc(T('"'), fp);
    metaLocation(parser);
    fputts(T("/>\n"), fp);
  }
}

static void XMLCALL
metaStartNamespaceDecl(void *userData,
                       const XML_Char *prefix,
                       const XML_Char *uri)
{
  XML_Parser parser = (XML_Parser) userData;
  FILE *fp = (FILE *)XML_GetUserData(parser);
  fputts(T("<startns"), fp);
  if (prefix)
    ftprintf(fp, T(" prefix=\"%s\""), prefix);
  if (uri) {
    fputts(T(" ns=\""), fp);
    characterData(fp, uri, tcslen(uri));
    fputts(T("\"/>\n"), fp);
  }
  else
    fputts(T("/>\n"), fp);
}

static void XMLCALL
metaEndNamespaceDecl(void *userData, const XML_Char *prefix)
{
  XML_Parser parser = (XML_Parser) userData;
  FILE *fp = (FILE *)XML_GetUserData(parser);
  if (!prefix)
    fputts(T("<endns/>\n"), fp);
  else
    ftprintf(fp, T("<endns prefix=\"%s\"/>\n"), prefix);
}

static int XMLCALL
unknownEncodingConvert(void *data, const char *p)
{
  return codepageConvert(*(int *)data, p);
}

static int XMLCALL
unknownEncoding(void *userData, const XML_Char *name, XML_Encoding *info)
{
  int cp;
  static const XML_Char prefixL[] = T("windows-");
  static const XML_Char prefixU[] = T("WINDOWS-");
  int i;

  for (i = 0; prefixU[i]; i++)
    if (name[i] != prefixU[i] && name[i] != prefixL[i])
      return 0;
  
  cp = 0;
  for (; name[i]; i++) {
    static const XML_Char digits[] = T("0123456789");
    const XML_Char *s = tcschr(digits, name[i]);
    if (!s)
      return 0;
    cp *= 10;
    cp += s - digits;
    if (cp >= 0x10000)
      return 0;
  }
  if (!codepageMap(cp, info->map))
    return 0;
  info->convert = unknownEncodingConvert;
  /* We could just cast the code page integer to a void *,
  and avoid the use of release. */
  info->release = free;
  info->data = malloc(sizeof(int));
  if (!info->data)
    return 0;
  *(int *)info->data = cp;
  return 1;
}

static int XMLCALL
notStandalone(void *userData)
{
  return 0;
}

static void
showVersion(XML_Char *prog)
{
  XML_Char *s = prog;
  XML_Char ch;
  const XML_Feature *features = XML_GetFeatureList();
  while ((ch = *s) != 0) {
    if (ch == '/'
#ifdef WIN32
        || ch == '\\'
#endif
        )
      prog = s + 1;
    ++s;
  }
  ftprintf(stdout, T("%s using %s\n"), prog, XML_ExpatVersion());
  if (features != NULL && features[0].feature != XML_FEATURE_END) {
    int i = 1;
    ftprintf(stdout, T("%s"), features[0].name);
    if (features[0].value)
      ftprintf(stdout, T("=%ld"), features[0].value);
    while (features[i].feature != XML_FEATURE_END) {
      ftprintf(stdout, T(", %s"), features[i].name);
      if (features[i].value)
        ftprintf(stdout, T("=%ld"), features[i].value);
      ++i;
    }
    ftprintf(stdout, T("\n"));
  }
}

static void
usage(const XML_Char *prog, int rc)
{
  ftprintf(stderr,
           T("usage: %s [-n] [-p] [-r] [-s] [-w] [-x] [-d output-dir] "
             "[-e encoding] file ...\n"), prog);
  exit(rc);
}

#ifdef AMIGA_SHARED_LIB
int
amiga_main(int argc, char *argv[])
#else
int
tmain(int argc, XML_Char **argv)
#endif
{
  int i, j;
  const XML_Char *outputDir = NULL;
  const XML_Char *encoding = NULL;
  unsigned processFlags = XML_MAP_FILE;
  int windowsCodePages = 0;
  int outputType = 0;
  int useNamespaces = 0;
  int requireStandalone = 0;
  enum XML_ParamEntityParsing paramEntityParsing = 
    XML_PARAM_ENTITY_PARSING_NEVER;
  int useStdin = 0;

#ifdef _MSC_VER
  _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
#endif

  i = 1;
  j = 0;
  while (i < argc) {
    if (j == 0) {
      if (argv[i][0] != T('-'))
        break;
      if (argv[i][1] == T('-') && argv[i][2] == T('\0')) {
        i++;
        break;
      }
      j++;
    }
    switch (argv[i][j]) {
    case T('r'):
      processFlags &= ~XML_MAP_FILE;
      j++;
      break;
    case T('s'):
      requireStandalone = 1;
      j++;
      break;
    case T('n'):
      useNamespaces = 1;
      j++;
      break;
    case T('p'):
      paramEntityParsing = XML_PARAM_ENTITY_PARSING_ALWAYS;
      /* fall through */
    case T('x'):
      processFlags |= XML_EXTERNAL_ENTITIES;
      j++;
      break;
    case T('w'):
      windowsCodePages = 1;
      j++;
      break;
    case T('m'):
      outputType = 'm';
      j++;
      break;
    case T('c'):
      outputType = 'c';
      useNamespaces = 0;
      j++;
      break;
    case T('t'):
      outputType = 't';
      j++;
      break;
    case T('d'):
      if (argv[i][j + 1] == T('\0')) {
        if (++i == argc)
          usage(argv[0], 2);
        outputDir = argv[i];
      }
      else
        outputDir = argv[i] + j + 1;
      i++;
      j = 0;
      break;
    case T('e'):
      if (argv[i][j + 1] == T('\0')) {
        if (++i == argc)
          usage(argv[0], 2);
        encoding = argv[i];
      }
      else
        encoding = argv[i] + j + 1;
      i++;
      j = 0;
      break;
    case T('h'):
      usage(argv[0], 0);
      return 0;
    case T('v'):
      showVersion(argv[0]);
      return 0;
    case T('\0'):
      if (j > 1) {
        i++;
        j = 0;
        break;
      }
      /* fall through */
    default:
      usage(argv[0], 2);
    }
  }
  if (i == argc) {
    useStdin = 1;
    processFlags &= ~XML_MAP_FILE;
    i--;
  }
  for (; i < argc; i++) {
    FILE *fp = 0;
    XML_Char *outName = 0;
    int result;
    XML_Parser parser;
    if (useNamespaces)
      parser = XML_ParserCreateNS(encoding, NSSEP);
    else
      parser = XML_ParserCreate(encoding);
    if (requireStandalone)
      XML_SetNotStandaloneHandler(parser, notStandalone);
    XML_SetParamEntityParsing(parser, paramEntityParsing);
    if (outputType == 't') {
      /* This is for doing timings; this gives a more realistic estimate of
         the parsing time. */
      outputDir = 0;
      XML_SetElementHandler(parser, nopStartElement, nopEndElement);
      XML_SetCharacterDataHandler(parser, nopCharacterData);
      XML_SetProcessingInstructionHandler(parser, nopProcessingInstruction);
    }
    else if (outputDir) {
      size_t outNameLen;
      const XML_Char *file = useStdin ? T("STDIN") : argv[i];
      if (tcsrchr(file, T('/')))
        file = tcsrchr(file, T('/')) + 1;
#ifdef WIN32
      if (tcsrchr(file, T('\\')))
        file = tcsrchr(file, T('\\')) + 1;
#endif
      outName = (XML_Char *)malloc(outNameLen=((tcslen(outputDir) + tcslen(file) + 2)
                       * sizeof(XML_Char)));
      tcscpy(outName, outputDir, outNameLen);
      tcscat(outName, T("/"), outNameLen);
      tcscat(outName, file, outNameLen);
      fp = tfopen(outName, T("wb"));
      if (!fp) {
        tperror(outName);
        exit(1);
      }
      setvbuf(fp, NULL, _IOFBF, 16384);
#ifdef XML_UNICODE
      puttc(0xFEFF, fp);
#endif
      XML_SetUserData(parser, fp);
      switch (outputType) {
      case 'm':
        XML_UseParserAsHandlerArg(parser);
        XML_SetElementHandler(parser, metaStartElement, metaEndElement);
        XML_SetProcessingInstructionHandler(parser, metaProcessingInstruction);
        XML_SetCommentHandler(parser, metaComment);
        XML_SetCdataSectionHandler(parser, metaStartCdataSection,
                                   metaEndCdataSection);
        XML_SetCharacterDataHandler(parser, metaCharacterData);
        XML_SetDoctypeDeclHandler(parser, metaStartDoctypeDecl,
                                  metaEndDoctypeDecl);
        XML_SetEntityDeclHandler(parser, metaEntityDecl);
        XML_SetNotationDeclHandler(parser, metaNotationDecl);
        XML_SetNamespaceDeclHandler(parser, metaStartNamespaceDecl,
                                    metaEndNamespaceDecl);
        metaStartDocument(parser);
        break;
      case 'c':
        XML_UseParserAsHandlerArg(parser);
        XML_SetDefaultHandler(parser, markup);
        XML_SetElementHandler(parser, defaultStartElement, defaultEndElement);
        XML_SetCharacterDataHandler(parser, defaultCharacterData);
        XML_SetProcessingInstructionHandler(parser,
                                            defaultProcessingInstruction);
        break;
      default:
        if (useNamespaces)
          XML_SetElementHandler(parser, startElementNS, endElementNS);
        else
          XML_SetElementHandler(parser, startElement, endElement);
        XML_SetCharacterDataHandler(parser, characterData);
#ifndef W3C14N
        XML_SetProcessingInstructionHandler(parser, processingInstruction);
#endif /* not W3C14N */
        break;
      }
    }
    if (windowsCodePages)
      XML_SetUnknownEncodingHandler(parser, unknownEncoding, 0);
    result = XML_ProcessFile(parser, useStdin ? NULL : argv[i], processFlags);
    if (outputDir) {
      if (outputType == 'm')
        metaEndDocument(parser);
      fclose(fp);
      if (!result)
        tremove(outName);
      free(outName);
    }
    XML_ParserFree(parser);
  }
  return 0;
}
@


1.5
log
@fastmerge
@
text
@a0 2
/* $MirOS: src/lib/libexpat/xmlwf/xmlwf.c,v 1.4 2005/11/03 22:28:14 tg Exp $ */

d780 1
a780 1
      size_t nlen;
d788 5
a792 5
      outName = (XML_Char *)malloc((tcslen(outputDir) + tcslen(file) + 2)
                       * sizeof(XML_Char));
      tcscpy(outName, outputDir);
      tcscat(outName, T("/"));
      tcscat(outName, file);
@


1.4
log
@revive expat, after "discovering" it's being used by XFree86®...

The plan is that, after the release, when the base system (including
X11 and GCC) is split up into several ports, we'll just have a depen-
dency on expat in X11 ports where needed, and until then, we'll just
keep it in base.
@
text
@d1 1
a1 1
/* $MirOS: src/lib/libexpat/xmlwf/xmlwf.c,v 1.2 2005/03/06 20:29:06 tg Exp $ */
d21 4
d32 1
a32 1
  FILE *fp = userData;
d127 1
a127 1
  FILE *fp = userData;
d149 1
a149 1
  FILE *fp = userData;
d174 1
a174 1
  FILE *fp = userData;
d220 1
a220 1
  FILE *fp = userData;
d240 1
a240 1
  FILE *fp = userData;
d302 1
a302 1
  FILE *fp = XML_GetUserData((XML_Parser) userData);
d312 4
a315 3
    ftprintf(XML_GetUserData(parser), T(" uri=\"%s\""), uri);
  ftprintf(XML_GetUserData(parser),
           T(" byte=\"%ld\" nbytes=\"%d\" line=\"%d\" col=\"%d\""),
d325 1
a325 1
  fputts(T("<document>\n"), XML_GetUserData((XML_Parser) userData));
d331 1
a331 1
  fputts(T("</document>\n"), XML_GetUserData((XML_Parser) userData));
d339 1
a339 1
  FILE *fp = XML_GetUserData(parser);
d373 1
a373 1
  FILE *fp = XML_GetUserData(parser);
d384 1
a384 1
  FILE *fp = XML_GetUserData(parser);
d396 1
a396 1
  FILE *fp = XML_GetUserData(parser);
d408 1
a408 1
  FILE *fp = XML_GetUserData(parser);
d418 1
a418 1
  FILE *fp = XML_GetUserData(parser);
d428 1
a428 1
  FILE *fp = XML_GetUserData(parser);
d444 1
a444 1
  FILE *fp = XML_GetUserData(parser);
d454 1
a454 1
  FILE *fp = XML_GetUserData(parser);
d468 1
a468 1
  FILE *fp = XML_GetUserData(parser);
d494 1
a494 1
  FILE *fp = XML_GetUserData(parser);
d532 1
a532 1
  FILE *fp = XML_GetUserData(parser);
d549 1
a549 1
  FILE *fp = XML_GetUserData(parser);
d644 4
d650 1
d660 2
a661 1
  int paramEntityParsing = XML_PARAM_ENTITY_PARSING_NEVER;
d790 5
a794 5
      nlen = (tcslen(outputDir) + tcslen(file) + 2) * sizeof(XML_Char);
      outName = malloc(nlen);
      tcscpy(outName, outputDir, nlen);
      tcscat(outName, T("/"), nlen);
      tcscat(outName, file, nlen);
@


1.3
log
@* un-hook bin/ksh, usr.bin/xmlwf and lib/libexpat from the build
  - expat as discussed with bsiegert@@ today on the phone
  - ksh as announced earlier on the lists
* un-hook lib/libexpat from make includes
* remove /usr/include/{,open}ssl upgrade workaround from includes/Makefile
* nuke old bin/ksh
* nuke libexpat and xmlwf
@
text
@@


1.2
log
@merge src/lib
@
text
@d1 1
a1 1
/* $MirOS$ */
@


1.1
log
@Initial revision
@
text
@d1 2
d771 1
d779 5
a783 5
      outName = malloc((tcslen(outputDir) + tcslen(file) + 2)
                       * sizeof(XML_Char));
      tcscpy(outName, outputDir);
      tcscat(outName, T("/"));
      tcscat(outName, file);
@


1.1.105.1
log
@expat-1_95_8 with the following directories removed:
- bcb5
- conftools
- examples
- tests
- vms
- win32
@
text
@@


1.1.105.2
log
@update to expat 2.0.0
@
text
@a18 4
#ifdef AMIGA_SHARED_LIB
#include <proto/expat.h>
#endif

d26 1
a26 1
  FILE *fp = (FILE *)userData;
d121 1
a121 1
  FILE *fp = (FILE *)userData;
d143 1
a143 1
  FILE *fp = (FILE *)userData;
d168 1
a168 1
  FILE *fp = (FILE *)userData;
d214 1
a214 1
  FILE *fp = (FILE *)userData;
d234 1
a234 1
  FILE *fp = (FILE *)userData;
d296 1
a296 1
  FILE *fp = (FILE *)XML_GetUserData((XML_Parser) userData);
d306 3
a308 4
    ftprintf((FILE *)XML_GetUserData(parser), T(" uri=\"%s\""), uri);
  ftprintf((FILE *)XML_GetUserData(parser),
           T(" byte=\"%" XML_FMT_INT_MOD "d\" nbytes=\"%d\" \
			 line=\"%" XML_FMT_INT_MOD "u\" col=\"%" XML_FMT_INT_MOD "u\""),
d318 1
a318 1
  fputts(T("<document>\n"), (FILE *)XML_GetUserData((XML_Parser) userData));
d324 1
a324 1
  fputts(T("</document>\n"), (FILE *)XML_GetUserData((XML_Parser) userData));
d332 1
a332 1
  FILE *fp = (FILE *)XML_GetUserData(parser);
d366 1
a366 1
  FILE *fp = (FILE *)XML_GetUserData(parser);
d377 1
a377 1
  FILE *fp = (FILE *)XML_GetUserData(parser);
d389 1
a389 1
  FILE *fp = (FILE *)XML_GetUserData(parser);
d401 1
a401 1
  FILE *fp = (FILE *)XML_GetUserData(parser);
d411 1
a411 1
  FILE *fp = (FILE *)XML_GetUserData(parser);
d421 1
a421 1
  FILE *fp = (FILE *)XML_GetUserData(parser);
d437 1
a437 1
  FILE *fp = (FILE *)XML_GetUserData(parser);
d447 1
a447 1
  FILE *fp = (FILE *)XML_GetUserData(parser);
d461 1
a461 1
  FILE *fp = (FILE *)XML_GetUserData(parser);
d487 1
a487 1
  FILE *fp = (FILE *)XML_GetUserData(parser);
d525 1
a525 1
  FILE *fp = (FILE *)XML_GetUserData(parser);
d542 1
a542 1
  FILE *fp = (FILE *)XML_GetUserData(parser);
a636 4
#ifdef AMIGA_SHARED_LIB
int
amiga_main(int argc, char *argv[])
#else
a638 1
#endif
d648 1
a648 2
  enum XML_ParamEntityParsing paramEntityParsing = 
    XML_PARAM_ENTITY_PARSING_NEVER;
d776 1
a776 1
      outName = (XML_Char *)malloc((tcslen(outputDir) + tcslen(file) + 2)
@

