head	1.5;
access;
symbols
	MIRBSD_10:1.5.0.2
	MIRBSD_10_BASE:1.5
	MIRBSD_9_BASE:1.5
	expat-2_0_0:1.1.105.2
	MIRBSD_8:1.4.0.2
	MIRBSD_8_BASE:1.4
	expat-1_95_8:1.1.105.1
	expat:1.1.105;
locks; strict;
comment	@ * @;


1.5
date	2006.06.01.23.31.17;	author tg;	state Exp;
branches;
next	1.4;
commitid	100447F78D90B0CC9DD;

1.4
date	2005.11.03.22.28.14;	author tg;	state Exp;
branches;
next	1.3;
commitid	7afc436a8eca13dd;

1.3
date	2005.10.21.11.33.35;	author tg;	state dead;
branches;
next	1.2;
commitid	275f4358cfde0f84;

1.2
date	2005.03.06.20.29.06;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.06.15.14.58;	author tg;	state Exp;
branches
	1.1.105.1;
next	;

1.1.105.1
date	2005.03.06.15.14.58;	author tg;	state Exp;
branches;
next	1.1.105.2;

1.1.105.2
date	2006.06.01.23.29.18;	author tg;	state Exp;
branches;
next	;
commitid	100447F78577DEBD528;


desc
@@


1.5
log
@fastmerge
@
text
@/* $MirOS: src/lib/libexpat/xmlwf/xmlfile.c,v 1.4 2005/11/03 22:28:14 tg Exp $ */

/* Copyright (c) 1998, 1999 Thai Open Source Software Center Ltd
   See the file COPYING for copying permission.
*/

#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <fcntl.h>

#ifdef COMPILED_FROM_DSP
#include "winconfig.h"
#elif defined(MACOS_CLASSIC)
#include "macconfig.h"
#elif defined(__amigaos4__)
#include "amigaconfig.h"
#elif defined(HAVE_EXPAT_CONFIG_H)
#include <expat_config.h>
#endif /* ndef COMPILED_FROM_DSP */

#include "expat.h"
#include "xmlfile.h"
#include "xmltchar.h"
#include "filemap.h"

#ifdef _MSC_VER
#include <io.h>
#endif

#ifdef AMIGA_SHARED_LIB
#include <proto/expat.h>
#endif

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#ifndef O_BINARY
#ifdef _O_BINARY
#define O_BINARY _O_BINARY
#else
#define O_BINARY 0
#endif
#endif

#ifdef _DEBUG
#define READ_SIZE 16
#else
#define READ_SIZE (1024*8)
#endif


typedef struct {
  XML_Parser parser;
  int *retPtr;
} PROCESS_ARGS;

static void
reportError(XML_Parser parser, const XML_Char *filename)
{
  enum XML_Error code = XML_GetErrorCode(parser);
  const XML_Char *message = XML_ErrorString(code);
  if (message)
    ftprintf(stdout, T("%s:%" XML_FMT_INT_MOD "u:%" XML_FMT_INT_MOD "u: %s\n"),
             filename,
             XML_GetErrorLineNumber(parser),
             XML_GetErrorColumnNumber(parser),
             message);
  else
    ftprintf(stderr, T("%s: (unknown message %d)\n"), filename, code);
}

static void
processFile(const void *data, size_t size,
            const XML_Char *filename, void *args)
{
  XML_Parser parser = ((PROCESS_ARGS *)args)->parser;
  int *retPtr = ((PROCESS_ARGS *)args)->retPtr;
  if (XML_Parse(parser, (const char *)data, size, 1) == XML_STATUS_ERROR) {
    reportError(parser, filename);
    *retPtr = 0;
  }
  else
    *retPtr = 1;
}

#ifdef WIN32

static int
isAsciiLetter(XML_Char c)
{
  return (T('a') <= c && c <= T('z')) || (T('A') <= c && c <= T('Z'));
}

#endif /* WIN32 */

static const XML_Char *
resolveSystemId(const XML_Char *base, const XML_Char *systemId,
                XML_Char **toFree)
{
  size_t nlen;
  XML_Char *s;
  *toFree = 0;
  if (!base
      || *systemId == T('/')
#ifdef WIN32
      || *systemId == T('\\')
      || (isAsciiLetter(systemId[0]) && systemId[1] == T(':'))
#endif
     )
    return systemId;
  nlen = (tcslen(base) + tcslen(systemId) + 2) * sizeof(XML_Char);
  *toFree = (XML_Char *)malloc(nlen);
  if (!*toFree)
    return systemId;
  tcscpy(*toFree, base, nlen);
  s = *toFree;
  if (tcsrchr(s, T('/')))
    s = tcsrchr(s, T('/')) + 1;
#ifdef WIN32
  if (tcsrchr(s, T('\\')))
    s = tcsrchr(s, T('\\')) + 1;
#endif
  tcscpy(s, systemId, nlen - (s - *toFree));
  return *toFree;
}

static int
externalEntityRefFilemap(XML_Parser parser,
                         const XML_Char *context,
                         const XML_Char *base,
                         const XML_Char *systemId,
                         const XML_Char *publicId)
{
  int result;
  XML_Char *s;
  const XML_Char *filename;
  XML_Parser entParser = XML_ExternalEntityParserCreate(parser, context, 0);
  PROCESS_ARGS args;
  args.retPtr = &result;
  args.parser = entParser;
  filename = resolveSystemId(base, systemId, &s);
  XML_SetBase(entParser, filename);
  if (!filemap(filename, processFile, &args))
    result = 0;
  free(s);
  XML_ParserFree(entParser);
  return result;
}

static int
processStream(const XML_Char *filename, XML_Parser parser)
{
  /* passing NULL for filename means read intput from stdin */
  int fd = 0;   /* 0 is the fileno for stdin */

  if (filename != NULL) {
    fd = topen(filename, O_BINARY|O_RDONLY);
    if (fd < 0) {
      tperror(filename);
      return 0;
    }
  }
  for (;;) {
    int nread;
    char *buf = (char *)XML_GetBuffer(parser, READ_SIZE);
    if (!buf) {
      if (filename != NULL)
        close(fd);
      ftprintf(stderr, T("%s: out of memory\n"),
               filename != NULL ? filename : "xmlwf");
      return 0;
    }
    nread = read(fd, buf, READ_SIZE);
    if (nread < 0) {
      tperror(filename != NULL ? filename : "STDIN");
      if (filename != NULL)
        close(fd);
      return 0;
    }
    if (XML_ParseBuffer(parser, nread, nread == 0) == XML_STATUS_ERROR) {
      reportError(parser, filename != NULL ? filename : "STDIN");
      if (filename != NULL)
        close(fd);
      return 0;
    }
    if (nread == 0) {
      if (filename != NULL)
        close(fd);
      break;;
    }
  }
  return 1;
}

static int
externalEntityRefStream(XML_Parser parser,
                        const XML_Char *context,
                        const XML_Char *base,
                        const XML_Char *systemId,
                        const XML_Char *publicId)
{
  XML_Char *s;
  const XML_Char *filename;
  int ret;
  XML_Parser entParser = XML_ExternalEntityParserCreate(parser, context, 0);
  filename = resolveSystemId(base, systemId, &s);
  XML_SetBase(entParser, filename);
  ret = processStream(filename, entParser);
  free(s);
  XML_ParserFree(entParser);
  return ret;
}

int
XML_ProcessFile(XML_Parser parser,
                const XML_Char *filename,
                unsigned flags)
{
  int result;

  if (!XML_SetBase(parser, filename)) {
    ftprintf(stderr, T("%s: out of memory"), filename);
    exit(1);
  }

  if (flags & XML_EXTERNAL_ENTITIES)
      XML_SetExternalEntityRefHandler(parser,
                                      (flags & XML_MAP_FILE)
                                      ? externalEntityRefFilemap
                                      : externalEntityRefStream);
  if (flags & XML_MAP_FILE) {
    PROCESS_ARGS args;
    args.retPtr = &result;
    args.parser = parser;
    if (!filemap(filename, processFile, &args))
      result = 0;
  }
  else
    result = processStream(filename, parser);
  return result;
}
@


1.4
log
@revive expat, after "discovering" it's being used by XFree86®...

The plan is that, after the release, when the base system (including
X11 and GCC) is split up into several ports, we'll just have a depen-
dency on expat in X11 ports where needed, and until then, we'll just
keep it in base.
@
text
@d1 1
a1 1
/* $MirOS: src/lib/libexpat/xmlwf/xmlfile.c,v 1.2 2005/03/06 20:29:06 tg Exp $ */
d12 1
a12 1
#include <unistd.h>
d15 8
a22 5
#else
#ifdef HAVE_EXPAT_CONFIG_H
#include "expat_config.h"
#endif
#endif
d32 4
d63 1
a63 1
  int code = XML_GetErrorCode(parser);
d66 1
a66 1
    ftprintf(stdout, T("%s:%d:%d: %s\n"),
d81 1
a81 1
  if (XML_Parse(parser, data, size, 1) == XML_STATUS_ERROR) {
d168 1
a168 1
    char *buf = XML_GetBuffer(parser, READ_SIZE);
@


1.3
log
@* un-hook bin/ksh, usr.bin/xmlwf and lib/libexpat from the build
  - expat as discussed with bsiegert@@ today on the phone
  - ksh as announced earlier on the lists
* un-hook lib/libexpat from make includes
* remove /usr/include/{,open}ssl upgrade workaround from includes/Makefile
* nuke old bin/ksh
* nuke libexpat and xmlwf
@
text
@@


1.2
log
@merge src/lib
@
text
@d1 1
a1 1
/* $MirOS$ */
@


1.1
log
@Initial revision
@
text
@d1 2
d12 1
d96 1
d107 2
a108 2
  *toFree = (XML_Char *)malloc((tcslen(base) + tcslen(systemId) + 2)
                               * sizeof(XML_Char));
d111 1
a111 1
  tcscpy(*toFree, base);
d119 1
a119 1
  tcscpy(s, systemId);
@


1.1.105.1
log
@expat-1_95_8 with the following directories removed:
- bcb5
- conftools
- examples
- tests
- vms
- win32
@
text
@@


1.1.105.2
log
@update to expat 2.0.0
@
text
@a9 1

d12 5
a16 8
#elif defined(MACOS_CLASSIC)
#include "macconfig.h"
#elif defined(__amigaos4__)
#include "amigaconfig.h"
#elif defined(HAVE_EXPAT_CONFIG_H)
#include <expat_config.h>
#endif /* ndef COMPILED_FROM_DSP */

a25 4
#ifdef AMIGA_SHARED_LIB
#include <proto/expat.h>
#endif

d53 1
a53 1
  enum XML_Error code = XML_GetErrorCode(parser);
d56 1
a56 1
    ftprintf(stdout, T("%s:%" XML_FMT_INT_MOD "u:%" XML_FMT_INT_MOD "u: %s\n"),
d71 1
a71 1
  if (XML_Parse(parser, (const char *)data, size, 1) == XML_STATUS_ERROR) {
d157 1
a157 1
    char *buf = (char *)XML_GetBuffer(parser, READ_SIZE);
@

