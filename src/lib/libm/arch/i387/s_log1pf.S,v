head	1.2;
access;
symbols
	cvs-201110182115:1.1.3.1
	MIRBSD_10:1.2.0.2
	MIRBSD_10_BASE:1.2
	cvs-200611031400:1.1.3.1
	netbsd:1.1.3
	OPENBSD_4_0:1.1.1.2
	MIRBSD_9_BASE:1.1.1.1
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200507211800:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2006.11.03.18.10.47;	author tg;	state Exp;
branches;
next	1.1;
commitid	100454B862956081199;

1.1
date	2005.02.05.17.25.18;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.3.1;
next	;

1.1.1.1
date	2005.02.05.17.25.18;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.11.03.01.33.22;	author tg;	state Exp;
branches;
next	;
commitid	100454A9C75705F73D8;

1.1.3.1
date	2006.11.03.14.20.58;	author tg;	state Exp;
branches;
next	;
commitid	100454B505850533E95;


desc
@@


1.2
log
@Switch to NetBSD libm
@
text
@/*
 * Written by J.T. Conklin <jtc@@NetBSD.org>.
 * Public domain.
 */

/*
 * Modified by Lex Wennmacher <wennmach@@NetBSD.org>
 * Still public domain.
 */

#include <machine/asm.h>

#include "abi.h"

RCSID("$NetBSD: s_log1pf.S,v 1.10 2003/09/16 18:17:11 wennmach Exp $")

/*
 * The log1pf() function is provided to compute an accurate value of
 * log(1 + x), even for tiny values of x. The i387 FPU provides the
 * fyl2xp1 instruction for this purpose. However, the range of this
 * instruction is limited to:
 * 		-(1 - (sqrt(2) / 2)) <= x <= sqrt(2) - 1
 *                         -0.292893 <= x <= 0.414214
 * at least on older processor versions.
 *
 * log1pf() is implemented by testing the range of the argument.
 * If it is appropriate for fyl2xp1, this instruction is used.
 * Else, we compute log1pf(x) = ln(2)*ld(1 + x) the traditional way
 * (using fyl2x).
 *
 * The range testing costs speed, but as the rationale for the very
 * existence of this function is accuracy, we accept that.
 *
 * In order to reduce the cost for testing the range, we check if
 * the argument is in the range
 *                             -0.25 <= x <= 0.25
 * which can be done with just one conditional branch. If x is
 * inside this range, we use fyl2xp1. Outside of this range,
 * the use of fyl2x is accurate enough.
 * 
 */

.text
	.align	4
ENTRY(log1pf)
	XMM_ONE_ARG_FLOAT_PROLOGUE
	flds	ARG_FLOAT_ONE
	fabs
	fld1				/* ... x 1 */
	fadd	%st(0)			/* ... x 2 */
	fadd	%st(0)			/* ... x 4 */
	fld1				/* ... 4 1 */
	fdivp				/* ... x 0.25 */
	fcompp
	fnstsw	%ax
	andb	$69,%ah
	jne	use_fyl2x
	jmp	use_fyl2xp1

	.align	4
use_fyl2x:
	fldln2
        flds	ARG_FLOAT_ONE
        fld1
        faddp
        fyl2x
	XMM_FLOAT_EPILOGUE
        ret

	.align	4
use_fyl2xp1:
	fldln2
	flds	ARG_FLOAT_ONE
	fyl2xp1
	XMM_FLOAT_EPILOGUE
	ret
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Written by J.T. Conklin <jtc@@netbsd.org>.
d6 5
d13 3
a15 1
RCSID("$NetBSD: s_log1pf.S,v 1.4 1995/05/09 00:13:05 jtc Exp $")
d18 23
a40 3
 * Since the fyl2xp1 instruction has such a limited range:
 *	-(1 - (sqrt(2) / 2)) <= x <= sqrt(2) - 1
 * it's not worth trying to use it.  
d43 2
d46 26
d73 3
a75 4
	flds 4(%esp)
	fld1
	faddp
	fyl2x
@


1.1.3.1
log
@Laugh at OpenBSD's libm and import NetBSD's
@
text
@d2 1
a2 1
 * Written by J.T. Conklin <jtc@@NetBSD.org>.
a5 5
/*
 * Modified by Lex Wennmacher <wennmach@@NetBSD.org>
 * Still public domain.
 */

d8 1
a8 3
#include "abi.h"

RCSID("$NetBSD: s_log1pf.S,v 1.10 2003/09/16 18:17:11 wennmach Exp $")
d11 3
a13 23
 * The log1pf() function is provided to compute an accurate value of
 * log(1 + x), even for tiny values of x. The i387 FPU provides the
 * fyl2xp1 instruction for this purpose. However, the range of this
 * instruction is limited to:
 * 		-(1 - (sqrt(2) / 2)) <= x <= sqrt(2) - 1
 *                         -0.292893 <= x <= 0.414214
 * at least on older processor versions.
 *
 * log1pf() is implemented by testing the range of the argument.
 * If it is appropriate for fyl2xp1, this instruction is used.
 * Else, we compute log1pf(x) = ln(2)*ld(1 + x) the traditional way
 * (using fyl2x).
 *
 * The range testing costs speed, but as the rationale for the very
 * existence of this function is accuracy, we accept that.
 *
 * In order to reduce the cost for testing the range, we check if
 * the argument is in the range
 *                             -0.25 <= x <= 0.25
 * which can be done with just one conditional branch. If x is
 * inside this range, we use fyl2xp1. Outside of this range,
 * the use of fyl2x is accurate enough.
 * 
a15 2
.text
	.align	4
a16 26
	XMM_ONE_ARG_FLOAT_PROLOGUE
	flds	ARG_FLOAT_ONE
	fabs
	fld1				/* ... x 1 */
	fadd	%st(0)			/* ... x 2 */
	fadd	%st(0)			/* ... x 4 */
	fld1				/* ... 4 1 */
	fdivp				/* ... x 0.25 */
	fcompp
	fnstsw	%ax
	andb	$69,%ah
	jne	use_fyl2x
	jmp	use_fyl2xp1

	.align	4
use_fyl2x:
	fldln2
        flds	ARG_FLOAT_ONE
        fld1
        faddp
        fyl2x
	XMM_FLOAT_EPILOGUE
        ret

	.align	4
use_fyl2xp1:
d18 4
a21 3
	flds	ARG_FLOAT_ONE
	fyl2xp1
	XMM_FLOAT_EPILOGUE
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import OpenBSD 4.0's libm
@
text
@a0 1
/*	$OpenBSD: s_log1pf.S,v 1.2 2005/08/02 11:17:31 espie Exp $ */
d8 2
@

