head	1.5;
access;
symbols
	cvs-201110182115:1.1.3.2
	MIRBSD_10:1.3.0.2
	MIRBSD_10_BASE:1.3
	cvs-200611031400:1.1.3.1
	netbsd:1.1.3
	OPENBSD_4_0:1.1.1.1
	MIRBSD_9_BASE:1.1.1.1
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200507211800:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@.\" @;


1.5
date	2011.10.18.20.58.25;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004E9DE886695D1C6D;

1.4
date	2011.10.18.19.46.22;	author bsiegert;	state Exp;
branches;
next	1.3;
commitid	1004E9DD78368B8F2A9;

1.3
date	2006.11.03.18.10.51;	author tg;	state Exp;
branches;
next	1.2;
commitid	100454B862956081199;

1.2
date	2006.11.03.01.41.38;	author tg;	state Exp;
branches;
next	1.1;
commitid	100454A9E664DB00C95;

1.1
date	2005.02.05.17.25.18;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.3.1;
next	;

1.1.1.1
date	2005.02.05.17.25.18;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2006.11.03.14.20.58;	author tg;	state Exp;
branches;
next	1.1.3.2;
commitid	100454B505850533E95;

1.1.3.2
date	2011.10.18.19.20.32;	author bsiegert;	state Exp;
branches;
next	;
commitid	1004E9DD18376042FF5;


desc
@@


1.5
log
@mostly fix manpages
@
text
@.\"	$NetBSD: math.3,v 1.25 2011/09/22 18:14:09 njoly Exp $
.\"
.\" Copyright (c) 1985 Regents of the University of California.
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"	from: @@(#)math.3	6.10 (Berkeley) 5/6/91
.\"
.Dd February 23, 2007
.Dt MATH 3
.Os
.ds If Infinity
.if t .ds If \(if
.Sh NAME
.Nm math
.Nd introduction to mathematical library functions
.Sh LIBRARY
.Lb libm
.Sh SYNOPSIS
.In math.h
.Sh DESCRIPTION
These functions constitute the C
.Nm libm .
Declarations for these functions may be obtained from the include file
.In math.h .
.\" The Fortran math library is described in ``man 3f intro''.
.Ss List of Functions
.Bl -column "copysignX" "gammaX3XX" "inverse trigonometric funcX"
.It Sy Name Ta Sy Man page Ta Sy Description Ta Sy Error Bound Dv ( ULP Ns No s)
.It acos Ta Xr acos 3 Ta inverse trigonometric function Ta 3
.It acosh Ta Xr acosh 3 Ta inverse hyperbolic function Ta 3
.It asin Ta Xr asin 3 Ta inverse trigonometric function Ta 3
.It asinh Ta Xr asinh 3 Ta inverse hyperbolic function Ta 3
.It atan Ta Xr atan 3 Ta inverse trigonometric function Ta 1
.It atanh Ta Xr atanh 3 Ta inverse hyperbolic function Ta 3
.It atan2 Ta Xr atan2 3 Ta inverse trigonometric function Ta 2
.It cbrt Ta Xr sqrt 3 Ta cube root Ta 1
.It ceil Ta Xr ceil 3 Ta integer no less than Ta 0
.It copysign Ta Xr copysign 3 Ta copy sign bit Ta 0
.It cos Ta Xr cos 3 Ta trigonometric function Ta 1
.It cosh Ta Xr cosh 3 Ta hyperbolic function Ta 3
.It erf Ta Xr erf 3 Ta error function Ta ???
.It erfc Ta Xr erf 3 Ta complementary error function Ta ???
.It exp Ta Xr exp 3 Ta exponential Ta 1
.It expm1 Ta Xr exp 3 Ta exp(x)\-1 Ta 1
.It fabs Ta Xr fabs 3 Ta absolute value Ta 0
.It finite Ta Xr finite 3 Ta test for finity Ta 0
.It floor Ta Xr floor 3 Ta integer no greater than Ta 0
.It fmod Ta Xr fmod 3 Ta remainder Ta ???
.It hypot Ta Xr hypot 3 Ta Euclidean distance Ta 1
.It ilogb Ta Xr ilogb 3 Ta exponent extraction Ta 0
.It isinf Ta Xr isinf 3 Ta test for infinity Ta 0
.It isnan Ta Xr isnan 3 Ta test for not-a-number Ta 0
.It j0 Ta Xr j0 3 Ta Bessel function Ta ???
.It j1 Ta Xr j0 3 Ta Bessel function Ta ???
.It jn Ta Xr j0 3 Ta Bessel function Ta ???
.It lgamma Ta Xr lgamma 3 Ta log gamma function Ta ???
.It log Ta Xr log 3 Ta natural logarithm Ta 1
.It log10 Ta Xr log 3 Ta logarithm to base 10 Ta 3
.It log1p Ta Xr log 3 Ta log(1+x) Ta 1
.It nan Ta Xr nan 3 Ta return quiet \*(Na Ta 0
.It nextafter Ta Xr nextafter 3 Ta next representable number Ta 0
.It pow Ta Xr pow 3 Ta exponential x**y Ta 60\-500
.It remainder Ta Xr remainder 3 Ta remainder Ta 0
.It rint Ta Xr rint 3 Ta round to nearest integer Ta 0
.It scalbn Ta Xr scalbn 3 Ta exponent adjustment Ta 0
.It sin Ta Xr sin 3 Ta trigonometric function Ta 1
.It sinh Ta Xr sinh 3 Ta hyperbolic function Ta 3
.It sqrt Ta Xr sqrt 3 Ta square root Ta 1
.It tan Ta Xr tan 3 Ta trigonometric function Ta 3
.It tanh Ta Xr tanh 3 Ta hyperbolic function Ta 3
.It trunc Ta Xr trunc 3 Ta nearest integral value Ta 3
.It y0 Ta Xr j0 3 Ta Bessel function Ta ???
.It y1 Ta Xr j0 3 Ta Bessel function Ta ???
.It yn Ta Xr j0 3 Ta Bessel function Ta ???
.El
.Ss List of Defined Values
.Bl -column "M_2_SQRTPIXX" "1.12837916709551257390XX" "2/sqrt(pi)XXX"
.It Sy Name Ta Sy Value Ta Sy Description
.It M_E	2.7182818284590452354	e
.It M_LOG2E	1.4426950408889634074	log 2e
.It M_LOG10E	0.43429448190325182765	log 10e
.It M_LN2	0.69314718055994530942	log e2
.It M_LN10	2.30258509299404568402	log e10
.It M_PI	3.14159265358979323846	pi
.It M_PI_2	1.57079632679489661923	pi/2
.It M_PI_4	0.78539816339744830962	pi/4
.It M_1_PI	0.31830988618379067154	1/pi
.It M_2_PI	0.63661977236758134308	2/pi
.It M_2_SQRTPI	1.12837916709551257390	2/sqrt(pi)
.It M_SQRT2	1.41421356237309504880	sqrt(2)
.It M_SQRT1_2	0.70710678118654752440	1/sqrt(2)
.El
.Sh NOTES
In 4.3 BSD, distributed from the University of California
in late 1985, most of the foregoing functions come in two
versions, one for the double\-precision "D" format in the
DEC VAX\-11 family of computers, another for double\-precision
arithmetic conforming to the IEEE Standard 754 for Binary
Floating\-Point Arithmetic.
The two versions behave very
similarly, as should be expected from programs more accurate
and robust than was the norm when UNIX was born.
For instance, the programs are accurate to within the numbers
of
.Dv ULPs
tabulated above; an
.Dv ULP
is one Unit in the Last Place.
And the programs have been cured of anomalies that
afflicted the older math library
in which incidents like
the following had been reported:
.Bd -literal -offset indent
sqrt(\-1.0) = 0.0 and log(\-1.0) = \-1.7e38.
cos(1.0e\-11) \*(Gt cos(0.0) \*(Gt 1.0.
pow(x,1.0) \(!= x when x = 2.0, 3.0, 4.0, ..., 9.0.
pow(\-1.0,1.0e10) trapped on Integer Overflow.
sqrt(1.0e30) and sqrt(1.0e\-30) were very slow.
.Ed
However the two versions do differ in ways that have to be
explained, to which end the following notes are provided.
.Ss DEC VAX\-11 D_floating\-point
This is the format for which the original math library
was developed, and to which this manual is still principally dedicated.
It is
.Em the
double\-precision format for the PDP\-11
and the earlier VAX\-11 machines; VAX\-11s after 1983 were
provided with an optional "G" format closer to the IEEE
double\-precision format.
The earlier DEC MicroVAXs have no D format, only G double\-precision.
(Why?
Why not?)
.Pp
Properties of D_floating\-point:
.Bl -hang -offset indent
.It Wordsize :
64 bits, 8 bytes.
.It Radix :
Binary.
.It Precision :
56 significant bits, roughly like 17 significant decimals.
If x and x' are consecutive positive D_floating\-point
numbers (they differ by 1
.Dv ULP ) ,
then
.Dl 1.3e\-17 \*(Lt 0.5**56 \*(Lt (x'\-x)/x \*(Le 0.5**55 \*(Lt 2.8e\-17.
.It Range :
.Bl -column "Underflow thresholdX" "2.0**127X"
.It Overflow threshold	= 2.0**127	= 1.7e38.
.It Underflow threshold	= 0.5**128	= 2.9e\-39.
.El
.Em NOTE: THIS RANGE IS COMPARATIVELY NARROW.
.Pp
Overflow customarily stops computation.
Underflow is customarily flushed quietly to zero.
.Em CAUTION :
It is possible to have x
\(!=
y and yet x\-y = 0 because of underflow.
Similarly x \*(Gt y \*(Gt 0 cannot prevent either x\(**y = 0
or y/x = 0 from happening without warning.
.It Zero is represented ambiguously :
Although 2**55 different representations of zero are accepted by
the hardware, only the obvious representation is ever produced.
There is no \-0 on a VAX.
.It \*(If is not part of the VAX architecture .
.It Reserved operands :
of the 2**55 that the hardware
recognizes, only one of them is ever produced.
Any floating\-point operation upon a reserved
operand, even a MOVF or MOVD, customarily stops
computation, so they are not much used.
.It Exceptions :
Divisions by zero and operations that
overflow are invalid operations that customarily
stop computation or, in earlier machines, produce
reserved operands that will stop computation.
.It Rounding :
Every rational operation  (+, \-, \(**, /) on a
VAX (but not necessarily on a PDP\-11), if not an
over/underflow nor division by zero, is rounded to
within half an
.Dv ULP ,
and when the rounding error is
exactly half an
.Dv ULP
then rounding is away from 0.
.El
.Pp
Except for its narrow range, D_floating\-point is one of the
better computer arithmetics designed in the 1960's.
Its properties are reflected fairly faithfully in the elementary
functions for a VAX distributed in 4.3 BSD.
They over/underflow only if their results have to lie out of range
or very nearly so, and then they behave much as any rational
arithmetic operation that over/underflowed would behave.
Similarly, expressions like log(0) and atanh(1) behave
like 1/0; and sqrt(\-3) and acos(3) behave like 0/0;
they all produce reserved operands and/or stop computation!
The situation is described in more detail in manual pages.
.Pp
.Em This response seems excessively punitive, so it is destined
.Em to be replaced at some time in the foreseeable future by a
.Em more flexible but still uniform scheme being developed to
.Em handle all floating\-point arithmetic exceptions neatly.
.Pp
How do the functions in 4.3 BSD's new math library for UNIX
compare with their counterparts in DEC's VAX/VMS library?
Some of the VMS functions are a little faster, some are
a little more accurate, some are more puritanical about
exceptions (like pow(0.0,0.0) and atan2(0.0,0.0)),
and most occupy much more memory than their counterparts in
libm.
The VMS codes interpolate in large table to achieve
speed and accuracy; the libm codes use tricky formulas
compact enough that all of them may some day fit into a ROM.
.Pp
More important, DEC regards the VMS codes as proprietary
and guards them zealously against unauthorized use.
But the libm codes in 4.3 BSD are intended for the public domain;
they may be copied freely provided their provenance is always
acknowledged, and provided users assist the authors in their
researches by reporting experience with the codes.
Therefore no user of UNIX on a machine whose arithmetic resembles
VAX D_floating\-point need use anything worse than the new libm.
.Ss IEEE STANDARD 754 Floating\-Point Arithmetic
This standard is on its way to becoming more widely adopted
than any other design for computer arithmetic.
VLSI chips that conform to some version of that standard have been
produced by a host of manufacturers, among them ...
.Bl -column "Intel i8070, i80287XX"
.It Intel i8087, i80287	National Semiconductor  32081
.It 68881	Weitek WTL-1032, ... , -1165
.It Zilog Z8070	Western Electric (AT\*(AmT) WE32106.
.El
Other implementations range from software, done thoroughly
in the Apple Macintosh, through VLSI in the Hewlett\-Packard
9000 series, to the ELXSI 6400 running ECL at 3 Megaflops.
Several other companies have adopted the formats
of IEEE 754 without, alas, adhering to the standard's way
of handling rounding and exceptions like over/underflow.
The DEC VAX G_floating\-point format is very similar to the IEEE
754 Double format, so similar that the C programs for the
IEEE versions of most of the elementary functions listed
above could easily be converted to run on a MicroVAX, though
nobody has volunteered to do that yet.
.Pp
The codes in 4.3 BSD's libm for machines that conform to
IEEE 754 are intended primarily for the National Semiconductor 32081
and WTL 1164/65.
To use these codes with the Intel or Zilog
chips, or with the Apple Macintosh or ELXSI 6400, is to
forego the use of better codes provided (perhaps freely) by
those companies and designed by some of the authors of the
codes above.
Except for
.Fn atan ,
.Fn cbrt ,
.Fn erf ,
.Fn erfc ,
.Fn hypot ,
.Fn j0-jn ,
.Fn lgamma ,
.Fn pow ,
and
.Fn y0\-yn ,
the Motorola 68881 has all the functions in libm on chip,
and faster and more accurate;
it, Apple, the i8087, Z8070 and WE32106 all use 64 significant bits.
The main virtue of 4.3 BSD's
libm codes is that they are intended for the public domain;
they may be copied freely provided their provenance is always
acknowledged, and provided users assist the authors in their
researches by reporting experience with the codes.
Therefore no user of UNIX on a machine that conforms to
IEEE 754 need use anything worse than the new libm.
.Pp
Properties of IEEE 754 Double\-Precision:
.Bl -hang -offset indent
.It Wordsize :
64 bits, 8 bytes.
.It Radix :
Binary.
.It Precision :
53 significant bits, roughly like 16 significant decimals.
If x and x' are consecutive positive Double\-Precision
numbers (they differ by 1
.Dv ULP ) ,
then
.Dl 1.1e\-16 \*(Lt 0.5**53 \*(Lt (x'\-x)/x \*(Le 0.5**52 \*(Lt 2.3e\-16.
.It Range :
.Bl -column "Underflow thresholdX" "2.0**1024X"
.It Overflow threshold	= 2.0**1024	= 1.8e308
.It Underflow threshold	= 0.5**1022	= 2.2e\-308
.El
Overflow goes by default to a signed \*(If.
Underflow is
.Sy Gradual ,
rounding to the nearest
integer multiple of 0.5**1074 = 4.9e\-324.
.It Zero is represented ambiguously as +0 or \-0:
Its sign transforms correctly through multiplication or
division, and is preserved by addition of zeros
with like signs; but x\-x yields +0 for every
finite x.
The only operations that reveal zero's
sign are division by zero and copysign(x,\(+-0).
In particular, comparison (x \*(Gt y, x \*(Ge y, etc.)
cannot be affected by the sign of zero; but if
finite x = y then \*(If
\&= 1/(x\-y)
\(!=
\-1/(y\-x) =
\- \*(If .
.It \*(If is signed :
it persists when added to itself
or to any finite number.
Its sign transforms
correctly through multiplication and division, and
\*(If (finite)/\(+- \0=\0\(+-0
(nonzero)/0 =
\(+- \*(If.
But
\(if\-\(if, \(if\(**0 and \(if/\(if
are, like 0/0 and sqrt(\-3),
invalid operations that produce \*(Na.
.It Reserved operands :
there are 2**53\-2 of them, all
called \*(Na (Not A Number).
Some, called Signaling \*(Nas, trap any floating\-point operation
performed upon them; they are used to mark missing
or uninitialized values, or nonexistent elements of arrays.
The rest are Quiet \*(Nas; they are
the default results of Invalid Operations, and
propagate through subsequent arithmetic operations.
If x
\(!=
x then x is \*(Na; every other predicate
(x \*(Gt y, x = y, x \*(Lt y, ...) is FALSE if \*(Na is involved.
.Pp
.Em NOTE :
Trichotomy is violated by \*(Na.
Besides being FALSE, predicates that entail ordered
comparison, rather than mere (in)equality,
signal Invalid Operation when \*(Na is involved.
.It Rounding :
Every algebraic operation (+, \-, \(**, /,
\(sr)
is rounded by default to within half an
.Dv ULP ,
and when the rounding error is exactly half an
.Dv ULP
then the rounded value's least significant bit is zero.
This kind of rounding is usually the best kind,
sometimes provably so; for instance, for every
x = 1.0, 2.0, 3.0, 4.0, ..., 2.0**52, we find
(x/3.0)\(**3.0 == x and (x/10.0)\(**10.0 == x and ...
despite that both the quotients and the products
have been rounded.
Only rounding like IEEE 754 can do that.
But no single kind of rounding can be
proved best for every circumstance, so IEEE 754
provides rounding towards zero or towards
+\*(If
or towards
\-\*(If
at the programmer's option.
And the same kinds of rounding are specified for
Binary\-Decimal Conversions, at least for magnitudes
between roughly 1.0e\-10 and 1.0e37.
.It Exceptions :
IEEE 754 recognizes five kinds of floating\-point exceptions,
listed below in declining order of probable importance.
.Bl -column "Invalid OperationX" "Gradual OverflowX"
.It Sy Exception Ta Sy Default Result
.It Invalid Operation	\*(Na, or FALSE
.It Overflow	\(+-\(if
.It Divide by Zero	\(+-\(if
.It Underflow	Gradual Underflow
.It Inexact	Rounded value
.El
.Pp
.Em NOTE :
An Exception is not an Error unless handled badly.
What makes a class of exceptions exceptional
is that no single default response can be satisfactory
in every instance.
On the other hand, if a default
response will serve most instances satisfactorily,
the unsatisfactory instances cannot justify aborting
computation every time the exception occurs.
.El
.Pp
For each kind of floating\-point exception, IEEE 754
provides a Flag that is raised each time its exception
is signaled, and stays raised until the program resets it.
Programs may also test, save and restore a flag.
Thus, IEEE 754 provides three ways by which programs
may cope with exceptions for which the default result
might be unsatisfactory:
.Bl -enum
.It
Test for a condition that might cause an exception
later, and branch to avoid the exception.
.It
Test a flag to see whether an exception has occurred
since the program last reset its flag.
.It
Test a result to see whether it is a value that only
an exception could have produced.
.Em CAUTION :
The only reliable ways to discover
whether Underflow has occurred are to test whether
products or quotients lie closer to zero than the
underflow threshold, or to test the Underflow flag.
(Sums and differences cannot underflow in
IEEE 754; if x
\(!=
y then x\-y is correct to
full precision and certainly nonzero regardless of
how tiny it may be.)
Products and quotients that
underflow gradually can lose accuracy gradually
without vanishing, so comparing them with zero
(as one might on a VAX) will not reveal the loss.
Fortunately, if a gradually underflowed value is
destined to be added to something bigger than the
underflow threshold, as is almost always the case,
digits lost to gradual underflow will not be missed
because they would have been rounded off anyway.
So gradual underflows are usually
.Em provably
ignorable.
The same cannot be said of underflows flushed to 0.
.Pp
At the option of an implementor conforming to IEEE 754,
other ways to cope with exceptions may be provided:
.It
ABORT.
This mechanism classifies an exception in
advance as an incident to be handled by means
traditionally associated with error\-handling
statements like "ON ERROR GO TO ...".
Different languages offer different forms of this statement,
but most share the following characteristics:
.Bl -dash
.It
No means is provided to substitute a value for
the offending operation's result and resume
computation from what may be the middle of an expression.
An exceptional result is abandoned.
.It
In a subprogram that lacks an error\-handling
statement, an exception causes the subprogram to
abort within whatever program called it, and so
on back up the chain of calling subprograms until
an error\-handling statement is encountered or the
whole task is aborted and memory is dumped.
.El
.It
STOP.
This mechanism, requiring an interactive
debugging environment, is more for the programmer
than the program.
It classifies an exception in
advance as a symptom of a programmer's error; the
exception suspends execution as near as it can to
the offending operation so that the programmer can
look around to see how it happened.
Quite often
the first several exceptions turn out to be quite
unexceptionable, so the programmer ought ideally
to be able to resume execution after each one as if
execution had not been stopped.
.It
\&... Other ways lie beyond the scope of this document.
.El
.Pp
The crucial problem for exception handling is the problem of
Scope, and the problem's solution is understood, but not
enough manpower was available to implement it fully in time
to be distributed in 4.3 BSD's libm.
Ideally, each elementary function should act
as if it were indivisible, or atomic, in the sense that ...
.Bl -enum
.It
No exception should be signaled that is not deserved by
the data supplied to that function.
.It
Any exception signaled should be identified with that
function rather than with one of its subroutines.
.It
The internal behavior of an atomic function should not
be disrupted when a calling program changes from
one to another of the five or so ways of handling
exceptions listed above, although the definition
of the function may be correlated intentionally
with exception handling.
.El
.Pp
Ideally, every programmer should be able
.Em conveniently
to turn a debugged subprogram into one that appears atomic to
its users.
But simulating all three characteristics of an
atomic function is still a tedious affair, entailing hosts
of tests and saves\-restores; work is under way to ameliorate
the inconvenience.
.Pp
Meanwhile, the functions in libm are only approximately atomic.
They signal no inappropriate exception except possibly ...
.Bl -ohang -offset indent
.It Over/Underflow
when a result, if properly computed, might have lain barely within range, and
.It Inexact in Fn cbrt , Fn hypot , Fn log10 and Fn pow
when it happens to be exact, thanks to fortuitous cancellation of errors.
.El
Otherwise, ...
.Bl -ohang -offset indent
.It Invalid Operation is signaled only when
any result but \*(Na would probably be misleading.
.It Overflow is signaled only when
the exact result would be finite but beyond the overflow threshold.
.It Divide\-by\-Zero is signaled only when
a function takes exactly infinite values at finite operands.
.It Underflow is signaled only when
the exact result would be nonzero but tinier than the underflow threshold.
.It Inexact is signaled only when
greater range or precision would be needed to represent the exact result.
.El
.\" .Sh FILES
.\" .Bl -tag -width /usr/lib/libm_p.a -compact
.\" .It Pa /usr/lib/libm.a
.\" the static math library
.\" .It Pa /usr/lib/libm.so
.\" the dynamic math library
.\" .It Pa /usr/lib/libm_p.a
.\" the static math library compiled for profiling
.\" .El
.Sh SEE ALSO
An explanation of IEEE 754 and its proposed extension p854
was published in the IEEE magazine MICRO in August 1984 under
the title "A Proposed Radix\- and Word\-length\-independent
Standard for Floating\-point Arithmetic" by W. J. Cody et al.
The manuals for Pascal, C and BASIC on the Apple Macintosh
document the features of IEEE 754 pretty well.
Articles in the IEEE magazine COMPUTER vol. 14 no. 3 (Mar. 1981),
and in the ACM SIGNUM Newsletter Special Issue of
Oct. 1979, may be helpful although they pertain to
superseded drafts of the standard.
.Sh BUGS
When signals are appropriate, they are emitted by certain
operations within the codes, so a subroutine\-trace may be
needed to identify the function with its signal in case
method 5) above is in use.
And the codes all take the
IEEE 754 defaults for granted; this means that a decision to
trap all divisions by zero could disrupt a code that would
otherwise get correct results despite division by zero.
@


1.4
log
@Merge NetBSD libm. Makefile needs more work, I think.
@
text
@d35 2
d46 1
a46 1
.Lb libm .
a138 1
.br
d140 1
a140 8
.br
pow(x,1.0)
.if n \
!=
.if t \
\(!=
x when x = 2.0, 3.0, 4.0, ..., 9.0.
.br
d168 11
a178 12
numbers (they differ by 1 \*(up), then
.br
1.3e\-17 \*(Lt 0.5**56 \*(Lt (x'\-x)/x \*(Le 0.5**55 \*(Lt 2.8e\-17.
.RE
.nf
.ta \w'Range:'u+1n +\w'Underflow threshold'u+1n +\w'= 2.0**127'u+1n
Range:	Overflow threshold	= 2.0**127	= 1.7e38.
	Underflow threshold	= 0.5**128	= 2.9e\-39.
	NOTE:  THIS RANGE IS COMPARATIVELY NARROW.
.ta
.fi
.RS
d184 1
a184 2
y and yet
x\-y = 0 because of underflow.
d186 2
a187 5
or  y/x = 0 from happening without warning.
.RE
.RE
Zero is represented ambiguously.
.RS
d256 5
a260 7
.nf
.ta 0.5i +\w'Intel i8070, i80287'u+6n
	Intel i8087, i80287	National Semiconductor  32081
	Motorola 68881	Weitek WTL-1032, ... , -1165
	Zilog Z8070	Western Electric (AT\*(AmT) WE32106.
.ta
.fi
d312 13
a324 15
numbers (they differ by 1 \*(up), then
.br
1.1e\-16 \*(Lt 0.5**53 \*(Lt (x'\-x)/x \*(Le 0.5**52 \*(Lt 2.3e\-16.
.RE
.nf
.ta \w'Range:'u+1n +\w'Underflow threshold'u+1n +\w'= 2.0**1024'u+1n
Range:	Overflow threshold	= 2.0**1024	= 1.8e308
	Underflow threshold	= 0.5**1022	= 2.2e\-308
.ta
.fi
.RS
Overflow goes by default to a signed
.If "" .
.br
Underflow is \fIGradual,\fR rounding to the nearest
d355 1
a355 1
Some, called Signaling \*[Na]s, trap any floating\-point operation
d358 1
a358 1
The rest are Quiet \*[Na]s; they are
d363 5
a367 5
x then x is \*(nn; every other predicate
(x \*(Gt y, x = y, x \*(Lt y, ...) is FALSE if \*(nn is involved.
.br
NOTE: Trichotomy is violated by \*(nn.
.RS
d403 1
a403 1
.It Divide by Zero	\(+-\(if \}
@


1.3
log
@Switch to NetBSD libm
@
text
@d1 1
a1 1
.\"	$NetBSD: math.3,v 1.21 2006/03/26 02:02:38 xtraeme Exp $
d32 13
a44 16
.TH MATH 3 "March 26, 2006"
.UC 4
.ds up \fIulp\fR
.ds nn \fINaN\fR
.de If
.if n \\
\\$1Infinity\\$2
.if t \\
\\$1\\(if\\$2
..
.SH NAME
math \- introduction to mathematical library functions
.SH DESCRIPTION
These functions constitute the C math library,
.I libm.
The link editor searches this library under the \*(lq\-lm\*(rq option.
d46 1
a46 1
.RI \*(Lt math.h \*(Gt.
d48 68
a115 79
.SH "LIST OF FUNCTIONS"
.sp 2
.nf
.ta \w'copysign'u+2n +\w'lgamma.3'u+10n +\w'inverse trigonometric func'u
\fIName\fP	\fIAppears on Page\fP	\fIDescription\fP	\fIError Bound (ULPs)\fP
.ta \w'copysign'u+4n +\w'lgamma.3'u+4n +\w'inverse trigonometric function'u+6nC
.sp 5p
acos	acos.3	inverse trigonometric function	3
acosh	acosh.3	inverse hyperbolic function	3
asin	asin.3	inverse trigonometric function	3
asinh	asinh.3	inverse hyperbolic function	3
atan	atan.3	inverse trigonometric function	1
atanh	atanh.3	inverse hyperbolic function	3
atan2	atan2.3	inverse trigonometric function	2
cabs	hypot.3	complex absolute value	1
cbrt	sqrt.3	cube root	1
ceil	ceil.3	integer no less than	0
copysign	ieee.3	copy sign bit	0
cos	cos.3	trigonometric function	1
cosh	cosh.3	hyperbolic function	3
erf	erf.3	error function	???
erfc	erf.3	complementary error function	???
exp	exp.3	exponential	1
expm1	exp.3	exp(x)\-1	1
fabs	fabs.3	absolute value	0
finite	ieee.3	test for finity	0
floor	floor.3	integer no greater than	0
fmod	fmod.3	remainder	???
hypot	hypot.3	Euclidean distance	1
ilogb	ieee.3	exponent extraction	0
isinf	isinf.3	test for infinity	0
isnan	isnan.3	test for not-a-number	0
j0	j0.3	Bessel function	???
j1	j0.3	Bessel function	???
jn	j0.3	Bessel function	???
lgamma	lgamma.3	log gamma function	???
log	exp.3	natural logarithm	1
log10	exp.3	logarithm to base 10	3
log1p	exp.3	log(1+x)	1
nan	nan.3	return quiet \*(nn	0
nextafter	ieee.3	next representable number	0
pow	exp.3	exponential x**y	60\-500
remainder	ieee.3	remainder	0
rint	rint.3	round to nearest integer	0
scalbn	ieee.3	exponent adjustment	0
sin	sin.3	trigonometric function	1
sinh	sinh.3	hyperbolic function	3
sqrt	sqrt.3	square root	1
tan	tan.3	trigonometric function	3
tanh	tanh.3	hyperbolic function	3
trunc	trunc.3	nearest integral value	3
y0	j0.3	Bessel function	???
y1	j0.3	Bessel function	???
yn	j0.3	Bessel function	???
.ta
.fi
.SH "LIST OF DEFINED VALUES"
.sp 2
.nf
.ta \w'M_2_SQRTPI'u+2n +\w'1.12837916709551257390'u+4n +\w'2/sqrt(pi)'u+6nC
\fIName\fP	\fIValue\fP	\fIDescription\fP
.ta \w'M_2_SQRTPI'u+2n +\w'1.12837916709551257390'u+4n +\w'2/sqrt(pi)'u+6nC
.sp 3p
M_E	2.7182818284590452354	e
M_LOG2E	1.4426950408889634074	log 2e
M_LOG10E	0.43429448190325182765	log 10e
M_LN2	0.69314718055994530942	log e2
M_LN10	2.30258509299404568402	log e10
M_PI	3.14159265358979323846	pi
M_PI_2	1.57079632679489661923	pi/2
M_PI_4	0.78539816339744830962	pi/4
M_1_PI	0.31830988618379067154	1/pi
M_2_PI	0.63661977236758134308	2/pi
M_2_SQRTPI	1.12837916709551257390	2/sqrt(pi)
M_SQRT2	1.41421356237309504880	sqrt(2)
M_SQRT1_2	0.70710678118654752440	1/sqrt(2)
.ta
.fi
.SH NOTES
d126 5
a130 2
of \*(ups tabulated above; an \*(up is one \fIU\fRnit in the \fIL\fRast
\fIP\fRlace.
d132 2
a133 1
afflicted the older math library \fIlibm\fR in which incidents like
d135 1
a135 1
.RS
a147 1
.br
d149 1
a149 1
.RE
d152 2
a153 4
.PP
\fBDEC VAX\-11 D_floating\-point:\fR
.PP
This is the format for which the original math library \fIlibm\fR
d155 3
a157 1
It is \fIthe\fR double\-precision format for the PDP\-11
d164 1
a164 1
.PP
d166 7
a172 16
.RS
Wordsize: 64 bits, 8 bytes.
Radix: Binary.
.br
Precision: 56
.if n \
sig.
.if t \
significant
bits, roughly like 17
.if n \
sig.
.if t \
significant
decimals.
.RS
a186 1
.br
d188 1
a188 3
.br
CAUTION:
.RS
a189 3
.if n \
!=
.if t \
d202 2
a203 6
.RE
.If
is not part of the VAX architecture.
.br
Reserved operands:
.RS
d209 1
a209 3
.RE
Exceptions:
.RS
d214 1
a214 3
.RE
Rounding:
.RS
d218 8
a225 5
within half an \*(up, and when the rounding error is
exactly half an \*(up then rounding is away from 0.
.RE
.RE
.PP
d237 7
a243 10
.RS
.ll -0.5i
\fIThis response seems excessively punitive, so it is destined
to be replaced at some time in the foreseeable future by a
more flexible but still uniform scheme being developed to
handle all floating\-point arithmetic exceptions neatly.\fR
.ll +0.5i
.RE
.PP
How do the functions in 4.3 BSD's new \fIlibm\fR for UNIX
d249 1
a249 1
\fIlibm\fR.
d251 1
a251 1
speed and accuracy; the \fIlibm\fR codes use tricky formulas
d253 1
a253 1
.PP
d256 1
a256 1
But the \fIlibm\fR codes in 4.3 BSD are intended for the public domain;
d261 2
a262 4
VAX D_floating\-point need use anything worse than the new \fIlibm\fR.
.PP
\fBIEEE STANDARD 754 Floating\-Point Arithmetic:\fR
.PP
d285 3
a287 3
.PP
The codes in 4.3 BSD's \fIlibm\fR for machines that conform to
IEEE 754 are intended primarily for the National Semi. 32081
d294 12
a305 4
Except for \fIatan\fR, \fIcabs\fR, \fIcbrt\fR, \fIerf\fR,
\fIerfc\fR, \fIhypot\fR, \fIj0\-jn\fR, \fIlgamma\fR, \fIpow\fR
and \fIy0\-yn\fR,
the Motorola 68881 has all the functions in \fIlibm\fR on chip,
d307 1
a307 6
it, Apple, the i8087, Z8070 and WE32106 all use 64
.if n \
sig.
.if t \
significant
bits.
d309 1
a309 1
\fIlibm\fR codes is that they are intended for the public domain;
d314 2
a315 2
IEEE 754 need use anything worse than the new \fIlibm\fR.
.PP
d317 7
a323 16
.RS
Wordsize: 64 bits, 8 bytes.
Radix: Binary.
.br
Precision: 53
.if n \
sig.
.if t \
significant
bits, roughly like 16
.if n \
sig.
.if t \
significant
decimals.
.RS
d341 1
a341 3
.RE
Zero is represented ambiguously as +0 or \-0.
.RS
d350 1
a350 2
finite x = y then
.If
a351 3
.if n \
!=
.if t \
d354 2
a355 5
.If \- .
.RE
.If
is signed.
.RS
d360 1
a360 1
.If (finite)/\(+- \0=\0\(+-0
d362 1
a362 1
.If \(+- .
a363 3
.if n \
Infinity\-Infinity, Infinity\(**0 and Infinity/Infinity
.if t \
d366 2
a367 4
invalid operations that produce \*(nn. ...
.RE
Reserved operands:
.RS
d369 2
a370 2
called \*(nn (\fIN\fRot \fIa N\fRumber).
Some, called Signaling \*(nns, trap any floating\-point operation
d373 1
a373 1
The rest are Quiet \*(nns; they are
a376 3
.if n \
!=
.if t \
d385 2
a386 5
signal Invalid Operation when \*(nn is involved.
.RE
.RE
Rounding:
.RS
a387 3
.if n \
sqrt)
.if t \
d389 5
a393 3
is rounded by default to within half an \*(up, and
when the rounding error is exactly half an \*(up then
the rounded value's least significant bit is zero.
d404 1
a404 1
.If +
d406 1
a406 1
.If \-
d411 1
a411 3
.RE
Exceptions:
.RS
d414 11
a424 20
.RS
.nf
.ta \w'Invalid Operation'u+6n +\w'Gradual Underflow'u+2n
Exception	Default Result
.tc \(ru

.tc
Invalid Operation	\*(nn, or FALSE
.if n \{\
Overflow	\(+-Infinity
Divide by Zero	\(+-Infinity \}
.if t \{\
Overflow	\(+-\(if
Divide by Zero	\(+-\(if \}
Underflow	Gradual Underflow
Inexact	Rounded value
.ta
.fi
.RE
NOTE:  An Exception is not an Error unless handled badly.
d432 2
a433 2
.RE
.PP
d441 2
a442 1
.IP 1) \w'\0\0\0\0'u
d445 1
a445 1
.IP 2) \w'\0\0\0\0'u
d448 1
a448 1
.IP 3) \w'\0\0\0\0'u
d451 2
a452 2
.RS
CAUTION: The only reliable ways to discover
a457 3
.if n \
!=
.if t \
d471 3
a473 1
So gradual underflows are usually \fIprovably\fR ignorable.
d475 1
a475 2
.RE
.PP
d478 1
a478 1
.IP 4) \w'\0\0\0\0'u
d486 2
a487 1
.IP \(em \w'\0\0\0\0'u
d492 1
a492 1
.IP \(em \w'\0\0\0\0'u
d499 2
a500 1
.IP 5) \w'\0\0\0\0'u
d515 1
a515 1
.IP 6) \w'\0\0\0\0'u
d517 2
a518 2
.RE
.PP
d522 1
a522 1
to be distributed in 4.3 BSD's \fIlibm\fR.
d525 2
a526 1
.IP i) \w'iii)'u+2n
d529 1
a529 1
.IP ii) \w'iii)'u+2n
d532 1
a532 1
.IP iii) \w'iii)'u+2n
d539 5
a543 3
.PP
Ideally, every programmer should be able \fIconveniently\fR to
turn a debugged subprogram into one that appears atomic to
d549 2
a550 2
.PP
Meanwhile, the functions in \fIlibm\fR are only approximately atomic.
d552 2
a553 3
.RS
Over/Underflow
.RS
d555 1
a555 3
.RE
Inexact in \fIcabs\fR, \fIcbrt\fR, \fIhypot\fR, \fIlog10\fR and \fIpow\fR
.RS
d557 1
a557 2
.RE
.RE
d559 4
a562 7
.RS
Invalid Operation is signaled only when
.RS
any result but \*(nn would probably be misleading.
.RE
Overflow is signaled only when
.RS
d564 1
a564 3
.RE
Divide\-by\-Zero is signaled only when
.RS
d566 1
a566 3
.RE
Underflow is signaled only when
.RS
d568 1
a568 3
.RE
Inexact is signaled only when
.RS
d570 1
a570 2
.RE
.RE
d580 1
a580 1
.SH SEE ALSO
d591 1
a591 1
.SH BUGS
@


1.2
log
@merge libm
@
text
@d1 2
a2 2
.\"	$MirOS$
.\"	$OpenBSD: math.3,v 1.20 2004/01/23 23:08:46 jmc Exp $
d32 13
a44 10
.if n \
.ds Si sig.
.if t \
.ds Si significant
.Dd November 2, 2006
.Dt MATH 3
.Sh NAME
.Nm math
.Nd introduction to mathematical library functions
.Sh DESCRIPTION
d46 2
a47 4
.Em libm .
The link editor searches this library under the
.Dq -lm
option.
d49 82
a130 50
.Aq Pa math.h .
.Sh LIST OF FUNCTIONS
.Bl -column "copysign" "lgamma(3)" "inverse trigonometric function" "ULPs"
.It \fIName\fP Ta \fIManual\fP Ta \fIDescription\fP Ta "\fIULPs\fP"
.It acos Ta acos(3) Ta "inverse trigonometric function" Ta 3
.It acosh Ta acosh(3) Ta "inverse hyperbolic function" Ta 3
.It asin Ta asin(3) Ta "inverse trigonometric function" Ta 3
.It asinh Ta asinh(3) Ta "inverse hyperbolic function" Ta 3
.It atan Ta tan(3) Ta "inverse trigonometric function" Ta 1
.It atanh Ta atanh(3) Ta "inverse hyperbolic function" Ta 3
.It atan2 Ta tan2(3) Ta "inverse trigonometric function" Ta 2
.It cbrt Ta sqrt(3) Ta "cube root" Ta 1
.It ceil Ta floor(3) Ta "integer no less than" Ta 0
.It copysign Ta ieee(3) Ta "copy sign bit" Ta 0
.It cos Ta sin(3) Ta "trigonometric function" Ta 1
.It cosh Ta sinh(3) Ta "hyperbolic function" Ta 3
.It erf Ta erf(3) Ta "error function" Ta ???
.It erfc Ta erf(3) Ta "complementary error function" Ta ???
.It exp Ta exp(3) Ta "exponential" Ta 1
.It expm1 Ta exp(3) Ta "exp(x)-1" Ta 1
.It fabs Ta fabs(3) Ta "absolute value" Ta 0
.It floor Ta floor(3) Ta "integer no greater than" Ta 0
.It hypot Ta hypot(3) Ta "Euclidean distance" Ta 1
.It ilogb Ta ieee(3) Ta "exponent extraction" Ta 0
.It isinf Ta isinf(3) Ta "check exceptions"
.It isnan Ta isnan(3) Ta "check exceptions"
.It j0 Ta j0(3) Ta "Bessel function" Ta ???
.It j1 Ta j0(3) Ta "Bessel function" Ta ???
.It jn Ta j0(3) Ta "Bessel function" Ta ???
.It lgamma Ta lgamma(3) Ta "log gamma function" Ta ???
.It log Ta exp(3) Ta "natural logarithm" Ta 1
.It log10 Ta exp(3) Ta "logarithm to base 10" Ta 3
.It log1p Ta exp(3) Ta "log(1+x)" Ta 1
.It pow Ta exp(3) Ta "exponential x**y" Ta 60-500
.It remainder Ta ieee(3) Ta "remainder" Ta 0
.It rint Ta rint(3) Ta "round to nearest integer" Ta 0
.It scalbn Ta ieee(3) Ta "exponent adjustment" Ta 0
.It sin Ta sin(3) Ta "trigonometric function" Ta 1
.It sinh Ta sinh(3) Ta "hyperbolic function" Ta 3
.It sqrt Ta sqrt(3) Ta "square root" Ta 1
.It tan Ta tan(3) Ta "trigonometric function" Ta 3
.It tanh Ta tanh(3) Ta "hyperbolic function" Ta 3
.It y0 Ta j0(3) Ta "Bessel function" Ta ???
.It y1 Ta j0(3) Ta "Bessel function" Ta ???
.It yn Ta j0(3) Ta "Bessel function" Ta ???
.El
.Sh NOTES
In
.Bx 4.3 ,
distributed from the University of California
d132 4
a135 7
versions, one for the double-precision
.Dq D
format in the
.Tn DEC VAX-11
family of computers, another for double-precision
arithmetic conforming to
.St -ieee754 .
d138 6
a143 15
and robust than was the norm when
.Ux
was born.
For
instance, the programs are accurate to within the number of
.Em ulp Ns s
tabulated above; a
.Em ulp
is one
.Em U Ns nit
in the
.Em L Ns ast
.Em P Ns lace .
The functions have been cured of anomalies that
afflicted the older math library in which incidents like
d145 11
a155 40
.Bd -unfilled -compact -offset indent
sqrt(-1.0) = 0.0 and log(-1.0) = -1.7e38.
cos(1.0e-11) > cos(0.0) > 1.0.
pow(x,1.0) \*(Ne x when x = 2.0, 3.0, 4.0, ..., 9.0.
pow(-1.0,1.0e10) trapped on Integer Overflow.
sqrt(1.0e30) and sqrt(1.0e-30) were very slow.
.Ed
However, the two versions do differ in ways that have to be
explained, to which end the following notes are provided.
.Ss DEC VAX-11 D_floating-point:
This is the format for which the original math library
was developed, and to which this manual is still principally
dedicated.
It is
.Em the
double-precision format for the PDP-11
and the earlier VAX-11 machines; VAX-11s after 1983 were
provided with an optional
.Dq G
format closer to the
.Tn IEEE
double-precision format.
The earlier
.Tn DEC MicroVAXs
have no D format, only G double-precision.
(Why? Why not?)
.Pp
Properties of D_floating-point:
.Bl -tag -width "Precision:" -offset indent -compact
.It Wordsize:
64 bits, 8 bytes.
.It Radix:
Binary.
.It Precision:
56 \*(Si bits, roughly 17 \*(Si decimal digits.
If x and x' are consecutive positive D_floating-point
numbers (they differ by 1 \fIulp\fR), then
.Li 1.3e-17 < 0.5**56 < (x'-x)/x \*(Le 0.5**55 < 2.8e-17.
.It Range:
Overflow threshold = 2.0**127 = 1.7e38.
d157 1
a157 1
Underflow threshold = 0.5**128 = 2.9e-39.
d159 21
a179 1
NOTE: THIS RANGE IS COMPARATIVELY NARROW.
d181 25
d211 14
a224 6
.Bd -filled -offset indent -compact
It is possible to have x \*(Ne y and yet x-y = 0 because of underflow.
Similarly x > y > 0 cannot prevent either x\(**y = 0
or y/x = 0 from happening without warning.
.Ed
.It Zero is represented ambiguously.
d227 8
a234 4
There is no -0 on a VAX.
.It \*(If is not part of the VAX architecture.
.It Reserved operands:
Of the 2**55 that the hardware
d236 1
a236 1
Any floating-point operation upon a reserved
d239 3
a241 1
.It Exceptions:
d246 5
a250 3
.It Rounding:
Every rational operation (+, -, \(**, /) on a
VAX (but not necessarily on a PDP-11), if not an
d252 6
a257 5
within half a \fIulp\fR, and when the rounding error is
exactly half a \fIulp\fR then rounding is away from 0.
.El
.Pp
Except for its narrow range, D_floating-point is one of the
d260 1
a260 2
functions for a VAX distributed in
.Bx 4.3 .
d265 1
a265 1
like 1/0; and sqrt(-3) and acos(3) behave like 0/0;
d268 2
a269 1
.Bd -filled -offset indent
d273 7
a279 16
handle all floating-point arithmetic exceptions neatly.
See
.Xr infnan 3
for the present state of affairs.\fR
.Ed
.Pp
How do the functions in
.Bx 4.3 's
new
.Em libm
for UNIX compare with their counterparts in
.Tn DEC's VAX/VMS
library?
Some of the
.Tn VMS
functions are a little faster, some are
d283 18
a300 29
.Em libm .
The
.Tn VMS
implementations interpolate in large table to achieve
speed and accuracy; the
.Em libm
implementations use tricky formulas compact enough that all of them may some
day fit into a ROM.
.Pp
More importantly,
.Tn DEC
considers the
.Tn VMS
implementation proprietary and guards it zealously against unauthorized use.
In contrast, the
.Em libm
included in
.Bx 4.3
is freely distributable;
it may be copied freely provided their provenance is always
acknowledged.
Therefore, no user of
.Ux
on a machine whose arithmetic resembles VAX D_floating-point need use
anything worse than the new
.Em libm .
.Pp
.Ss IEEE STANDARD 754 Floating-Point Arithmetic:
This is the most widely adopted standard for computer arithmetic.
d302 8
a309 6
produced by a host of manufacturers, among them:
.Bl -column -offset indent -compact "Intel i8070, i80287" "Western Electric (AT&T) WE32106"
.It "Intel i8087, i80287" Ta "National Semiconductor 32081"
.It "Motorola 68881" Ta "Weitek WTL-1032, ... , -1165"
.It "Zilog Z8070" Ta "Western Electric (AT&T) WE32106"
.El
d311 1
a311 1
for the Apple Macintosh, through VLSI in the Hewlett-Packard
d313 73
a385 81
Several other companies have adopted the formats of
.St -ieee754
without, alas, adhering to the standard's method
of handling rounding and exceptions such as over/underflow.
The
.Tn DEC VAX
G_floating-point format is very similar to
.St -ieee754
Double format.
It is so similar that the C programs for the
.Tn IEEE
versions of most of the elementary functions listed
above could easily be converted to run on a
.Tn MicroVAX ,
though nobody has volunteered to do that yet.
.Pp
The code in
.Bx 4.3 's
.Em libm
for machines that conform to
.St -ieee754
is intended primarily for the National Semi. 32081 and WTL 1164/65.
To use this code with the Intel or Zilog chips, or with the Apple
Macintosh or ELXSI 6400, is to forego the use of better code
provided (perhaps for free) by those companies and designed by some
of the authors of the code above.
Except for
.Fn atan ,
.Fn cbrt ,
.Fn erf ,
.Fn erfc ,
.Fn hypot ,
.Fn j0-jn ,
.Fn lgamma ,
.Fn pow
and
.Fn y0
-
.Fn yn ,
the Motorola 68881 has all the functions in
.Em libm
on chip, and is faster and more accurate to boot;
it, Apple, the i8087, Z8070 and WE32106 all use 64 \*(Si bits.
The main virtue of
.Bx 4.3 's
.Em libm
is that it is freely distributable;
it may be copied freely provided its provenance is always acknowledged.
Therefore no user of
.Ux
on a machine that conforms to
.St -ieee754
need use anything worse than the new
.Em libm .
.Pp
Properties of
.St -ieee754
Double-Precision:
.Bl -tag -width "Precision:" -offset indent -compact
.It Wordsize:
64 bits, 8 bytes.
.It Radix:
Binary.
.It Precision:
53 \*(Si bits, roughly equivalent to 16 \*(Si decimals.
.br
If x and x' are consecutive positive Double-Precision
numbers (they differ by 1 \fIulp\fR, then
.br
.Li 1.1e-16 < 0.5**53 < (x'-x)/x \*(Le 0.5**52 < 2.3e-16.
.It Range:
Overflow threshold = 2.0**1024 = 1.8e308
.br
Underflow threshold = 0.5**1022 = 2.2e-308
.br
Overflow goes by default to a signed \*(If.
.br
Underflow is
.Em Gradual ,
rounding to the nearest integer multiple of 0.5**1074 = 4.9e-324.
.It Zero is represented ambiguously as +0 or -0.
d388 1
a388 1
with like signs; but x-x yields +0 for every
d391 2
a392 2
sign are division by zero and copysign(x,\*(Pm0).
In particular, comparison (x > y, x \*(Ge y, etc.)
d394 48
a441 21
finite x = y then \*(If \&= 1/(x-y) \*(Ne -1/(y-x) = -\*(If.
.It \*(If is signed.
It persists when added to itself or to any finite number.
Its sign transforms correctly through multiplication and division, and
(finite)/\*(Pm\*(If \0=\0\*(Pm0 (nonzero)/0 = \*(Pm\*(If.
But \*(If-\*(If, \*(If\(**0 and \*(If/\*(If are, like 0/0 and sqrt(-3),
invalid operations that produce \*(Na.
.It Reserved operands:
There are 2**53-2 of them, all
called \*(Na (\fIN\fRot \fIa N\fRumber).
Some, called Signaling \*(Nas, trap any floating-point operation
performed upon them; they are used to mark missing or uninitialized values,
or nonexistent elements of arrays.
The rest are Quiet \*(Nas; they are the default results of Invalid Operations,
and propagate through subsequent arithmetic operations.
If x \*(Ne x then x is \*(Na; every other predicate
(x > y, x = y, x < y, ...) is FALSE if \*(Na is involved.
.br
.Bl -tag -width "NOTE:" -compact
.It NOTE:
Trichotomy is violated by \*(Na.
d444 6
a449 4
signal Invalid Operation when \*(Na is involved.
.El
.It Rounding:
Every algebraic operation (+, -, \(**, /,
d454 3
a456 3
is rounded by default to within half a \fIulp\fR, and
when the rounding error is exactly half a \fIulp\fR then
the rounded value's least \*(Si bit is zero.
d458 1
a458 2
sometimes provably so.
For instance, for every
d463 1
a463 3
Only rounding like
.St -ieee754
can do that.
d465 13
a477 10
proved best for every circumstance, so
.St -ieee754
provides rounding towards zero or towards +\*(If or
towards -\*(If at the programmer's discretion.
The same kinds of rounding are specified for
Binary-Decimal Conversions, at least for magnitudes
between roughly 1.0e-10 and 1.0e37.
.It Exceptions:
.St -ieee754
recognizes five kinds of floating-point exceptions,
d479 20
a498 10
.Bl -column -offset indent -compact "Invalid Operation" "Gradual Underflow"
.It Em Exception Ta Em Default Result
.It "Invalid Operation" Ta "\*(Na, or FALSE"
.It "Overflow" Ta "\*(Pm\*(If"
.It "Divide by Zero" Ta "\*(Pm\*(If"
.It "Underflow" Ta "Gradual Underflow"
.It "Inexact" Ta "Rounded value"
.El
NOTE: An Exception is not an Error unless handled
badly.
d506 4
a509 7
.El
.Pp
For each kind of floating-point exception,
.St -ieee754
provides a
.Em flag
that is raised each time its exception
d512 4
a515 6
Thus,
.St -ieee754
provides three ways by which programs may cope with exceptions for
which the default result might be unsatisfactory:
.Bl -tag -width XXX
.It 1)
d518 1
a518 1
.It 2)
d521 1
a521 1
.It 3)
d524 1
a524 1
.Bd -filled
d528 1
a528 2
underflow threshold, or to test the Underflow
flag.
d530 6
a535 2
.St -ieee754 ;
if x \*(Ne y then x-y is correct to
d538 4
a541 4
Products and quotients that underflow gradually can lose accuracy gradually
without vanishing, so comparing them with zero (as one might on a
.Tn VAX )
will not reveal the loss.
d549 3
a551 6
.Ed
.El
.Pp
.Bl -tag -width XXX
At the option of an implementor conforming to
.St -ieee754 ,
d553 1
a553 1
.It 4)
d557 1
a557 1
traditionally associated with error-handling
d561 1
a561 2
.Bl -dash
.It
d564 1
a564 2
computation from what may be the middle of an
expression.
d566 2
a567 2
.It
In a subprogram that lacks an error-handling
d571 1
a571 1
an error-handling statement is encountered or the
d573 1
a573 2
.El
.It 5)
d575 10
a584 6
This mechanism, requiring an interactive debugging environment, is more
for the programmer than the program.
It classifies an exception in advance as a symptom of a programmer's error;
the exception suspends execution as near as it can to the offending operation
so that the programmer can look around to see how it happened.
Often times the first several exceptions turn out to be quite
d588 1
a588 1
.It 6)
d590 2
a591 2
.El
.Pp
d595 4
a598 7
to be distributed in
.Bx 4.3 's
.Em libm .
Ideally, each elementary function should act as if it were indivisible,
or atomic, in the sense that ...
.Bl -tag -width Ds -offset XXXX
.It i)
d601 1
a601 1
.It ii)
d604 1
a604 1
.It iii)
d611 14
a624 15
.El
.Pp
Ideally, every programmer should be able to
.Em conveniently
turn a debugged subprogram into one that appears atomic to its users.
But simulating all three characteristics of an atomic function is still
a tedious affair, entailing hosts of tests and saves-restores;
work is under way to ameliorate the inconvenience.
.Pp
Meanwhile, the functions in
.Em libm
are only approximately atomic.
They signal no inappropriate exception except possibly:
.Bl -tag -width Ds -offset indent -compact
.It Over/Underflow
d626 3
a628 1
.It Inexact in \fIcbrt\fR, \fIhypot\fR, \fIlog10\fR and \fIpow\fR
d630 10
a639 6
.El
Otherwise:
.Bl -tag -width Ds -offset indent -compact
.It Invalid Operation is signaled only when
any result but \*(Na would probably be misleading.
.It Overflow is signaled only when
d641 3
a643 1
.It Divide-by-Zero is signaled only when
d645 3
a647 1
.It Underflow is signaled only when
d649 3
a651 1
.It Inexact is signaled only when
d653 16
a668 119
.El
.Pp
Properties of
.St -ieee754
Single-Precision:
.Bl -tag -width "Precision:" -offset indent -compact
.It Wordsize:
32 bits, 4 bytes.
.It Radix:
Binary.
.It Precision:
24 \*(Si bits, roughly equivalent to 7 \*(Si decimals.
.br
If x and x' are consecutive positive Double-Precision
numbers (they differ by 1 \fIulp\fR, then
.br
.Li 6.0e-8 < 0.5**24 < (x'-x)/x \*(Le 0.5**23 < 1.2e-7.
.It Range:
Overflow threshold = 2.0**128 = 3.4e38.
.br
Underflow threshold = 0.5**126 = 1.2e-38
.br
Overflow goes by default to a signed \*(If.
.br
Underflow is
.Em Gradual ,
rounding to the nearest integer multiple of 0.5**149 = 1.4e-45.
.It Zero is represented ambiguously as +0 or -0.
Its sign transforms correctly through multiplication or
division, and is preserved by addition of zeros
with like signs; but x-x yields +0 for every
finite x.
The only operations that reveal zero's
sign are division by zero and copysign(x,\*(Pm0).
In particular, comparison (x > y, x \*(Ge y, etc.)
cannot be affected by the sign of zero; but if
finite x = y then \*(If \&= 1/(x-y) \*(Ne -1/(y-x) = -\*(If.
.It \*(If is signed.
It persists when added to itself or to any finite number.
Its sign transforms correctly through multiplication and division, and
(finite)/\*(Pm\*(If \0=\0\*(Pm0 (nonzero)/0 = \*(Pm\*(If.
But \*(If-\*(If, \*(If\(**0 and \*(If/\*(If are, like 0/0 and sqrt(-3),
invalid operations that produce \*(Na.
.It Reserved operands:
There are 2**24-2 of them, all
called \*(Na (\fIN\fRot \fIa N\fRumber).
Some, called Signaling \*(Nas, trap any floating-point operation
performed upon them; they are used to mark missing or uninitialized values,
or nonexistent elements of arrays.
The rest are Quiet \*(Nas; they are the default results of Invalid Operations,
and propagate through subsequent arithmetic operations.
If x \*(Ne x then x is \*(Na; every other predicate
(x > y, x = y, x < y, ...) is FALSE if \*(Na is involved.
.br
.Bl -tag -width "NOTE:" -compact
.It NOTE:
Trichotomy is violated by \*(Na.
Besides being FALSE, predicates that entail ordered
comparison, rather than mere (in)equality,
signal Invalid Operation when \*(Na is involved.
.El
.It Rounding:
Every algebraic operation (+, -, \(**, /,
.if n \
sqrt)
.if t \
\(sr)
is rounded by default to within half a \fIulp\fR, and
when the rounding error is exactly half a \fIulp\fR then
the rounded value's least \*(Si bit is zero.
This kind of rounding is usually the best kind,
sometimes provably so.
For instance, for every
x = 1.0, 2.0, 3.0, 4.0, ..., 2.0**52, we find
(x/3.0)\(**3.0 == x and (x/10.0)\(**10.0 == x and ...
despite that both the quotients and the products
have been rounded.
Only rounding like
.St -ieee754
can do that.
But no single kind of rounding can be
proved best for every circumstance, so
.St -ieee754
provides rounding towards zero or towards +\*(If or
towards -\*(If at the programmer's discretion.
The same kinds of rounding are specified for
Binary-Decimal Conversions, at least for magnitudes
between roughly 1.0e-10 and 1.0e37.
.It Exceptions:
.St -ieee754
recognizes five kinds of floating-point exceptions,
listed below in declining order of probable importance.
.Bl -column -offset indent -compact "Invalid Operation" "Gradual Underflow"
.It Em Exception Ta Em Default Result
.It "Invalid Operation" Ta "\*(Na, or FALSE"
.It "Overflow" Ta "\*(Pm\*(If"
.It "Divide by Zero" Ta "\*(Pm\*(If"
.It "Underflow" Ta "Gradual Underflow"
.It "Inexact" Ta "Rounded value"
.El
NOTE: An Exception is not an Error unless handled
badly.
What makes a class of exceptions exceptional
is that no single default response can be satisfactory
in every instance.
On the other hand, if a default
response will serve most instances satisfactorily,
the unsatisfactory instances cannot justify aborting
computation every time the exception occurs.
.El
.Sh SEE ALSO
An explanation of
.St -ieee754
and its proposed extension p854
was published in the
.Tn IEEE
magazine MICRO in August 1984 under
the title "A Proposed Radix- and Word-length-independent
Standard for Floating-point Arithmetic" by W. J. Cody et al.
d670 4
a673 8
document the features of
.St -ieee754
pretty well.
Articles in the
.Tn IEEE
magazine COMPUTER vol. 14 no. 3 (Mar. 1981), and in the
.Tn ACM SIGNUM
Newsletter Special Issue of Oct. 1979, may be helpful although they pertain to
d675 1
a675 1
.Sh BUGS
d677 7
a683 11
operations within
.Em libm ,
so a subroutine-trace may be needed to identify the function with its
signal in case method 5) above is in use.
All the code in
.Em libm
takes the
.St -ieee754
defaults for granted; this means that a decision to
trap all divisions by zero could disrupt a function that would
otherwise get a correct result despite division by zero.
@


1.1
log
@Initial revision
@
text
@d1 1
d36 1
a36 1
.Dd May 6, 1991
a58 1
.It cabs Ta hypot(3) Ta "complex absolute value" Ta 1
a304 1
.Fn cabs ,
d567 1
a567 1
.It Inexact in \fIcabs\fR, \fIcbrt\fR, \fIhypot\fR, \fIlog10\fR and \fIpow\fR
@


1.1.3.1
log
@Laugh at OpenBSD's libm and import NetBSD's
@
text
@d1 1
a1 2
.\"	$NetBSD: math.3,v 1.21 2006/03/26 02:02:38 xtraeme Exp $
.\"
d31 10
a40 13
.TH MATH 3 "March 26, 2006"
.UC 4
.ds up \fIulp\fR
.ds nn \fINaN\fR
.de If
.if n \\
\\$1Infinity\\$2
.if t \\
\\$1\\(if\\$2
..
.SH NAME
math \- introduction to mathematical library functions
.SH DESCRIPTION
d42 4
a45 2
.I libm.
The link editor searches this library under the \*(lq\-lm\*(rq option.
d47 51
a97 82
.RI \*[Lt] math.h \*[Gt].
.\" The Fortran math library is described in ``man 3f intro''.
.SH "LIST OF FUNCTIONS"
.sp 2
.nf
.ta \w'copysign'u+2n +\w'lgamma.3'u+10n +\w'inverse trigonometric func'u
\fIName\fP	\fIAppears on Page\fP	\fIDescription\fP	\fIError Bound (ULPs)\fP
.ta \w'copysign'u+4n +\w'lgamma.3'u+4n +\w'inverse trigonometric function'u+6nC
.sp 5p
acos	acos.3	inverse trigonometric function	3
acosh	acosh.3	inverse hyperbolic function	3
asin	asin.3	inverse trigonometric function	3
asinh	asinh.3	inverse hyperbolic function	3
atan	atan.3	inverse trigonometric function	1
atanh	atanh.3	inverse hyperbolic function	3
atan2	atan2.3	inverse trigonometric function	2
cabs	hypot.3	complex absolute value	1
cbrt	sqrt.3	cube root	1
ceil	ceil.3	integer no less than	0
copysign	ieee.3	copy sign bit	0
cos	cos.3	trigonometric function	1
cosh	cosh.3	hyperbolic function	3
erf	erf.3	error function	???
erfc	erf.3	complementary error function	???
exp	exp.3	exponential	1
expm1	exp.3	exp(x)\-1	1
fabs	fabs.3	absolute value	0
finite	ieee.3	test for finity	0
floor	floor.3	integer no greater than	0
fmod	fmod.3	remainder	???
hypot	hypot.3	Euclidean distance	1
ilogb	ieee.3	exponent extraction	0
isinf	isinf.3	test for infinity	0
isnan	isnan.3	test for not-a-number	0
j0	j0.3	Bessel function	???
j1	j0.3	Bessel function	???
jn	j0.3	Bessel function	???
lgamma	lgamma.3	log gamma function	???
log	exp.3	natural logarithm	1
log10	exp.3	logarithm to base 10	3
log1p	exp.3	log(1+x)	1
nan	nan.3	return quiet \*(nn	0
nextafter	ieee.3	next representable number	0
pow	exp.3	exponential x**y	60\-500
remainder	ieee.3	remainder	0
rint	rint.3	round to nearest integer	0
scalbn	ieee.3	exponent adjustment	0
sin	sin.3	trigonometric function	1
sinh	sinh.3	hyperbolic function	3
sqrt	sqrt.3	square root	1
tan	tan.3	trigonometric function	3
tanh	tanh.3	hyperbolic function	3
trunc	trunc.3	nearest integral value	3
y0	j0.3	Bessel function	???
y1	j0.3	Bessel function	???
yn	j0.3	Bessel function	???
.ta
.fi
.SH "LIST OF DEFINED VALUES"
.sp 2
.nf
.ta \w'M_2_SQRTPI'u+2n +\w'1.12837916709551257390'u+4n +\w'2/sqrt(pi)'u+6nC
\fIName\fP	\fIValue\fP	\fIDescription\fP
.ta \w'M_2_SQRTPI'u+2n +\w'1.12837916709551257390'u+4n +\w'2/sqrt(pi)'u+6nC
.sp 3p
M_E	2.7182818284590452354	e
M_LOG2E	1.4426950408889634074	log 2e
M_LOG10E	0.43429448190325182765	log 10e
M_LN2	0.69314718055994530942	log e2
M_LN10	2.30258509299404568402	log e10
M_PI	3.14159265358979323846	pi
M_PI_2	1.57079632679489661923	pi/2
M_PI_4	0.78539816339744830962	pi/4
M_1_PI	0.31830988618379067154	1/pi
M_2_PI	0.63661977236758134308	2/pi
M_2_SQRTPI	1.12837916709551257390	2/sqrt(pi)
M_SQRT2	1.41421356237309504880	sqrt(2)
M_SQRT1_2	0.70710678118654752440	1/sqrt(2)
.ta
.fi
.SH NOTES
In 4.3 BSD, distributed from the University of California
d99 7
a105 4
versions, one for the double\-precision "D" format in the
DEC VAX\-11 family of computers, another for double\-precision
arithmetic conforming to the IEEE Standard 754 for Binary
Floating\-Point Arithmetic.
d108 15
a122 6
and robust than was the norm when UNIX was born.
For instance, the programs are accurate to within the numbers
of \*(ups tabulated above; an \*(up is one \fIU\fRnit in the \fIL\fRast
\fIP\fRlace.
And the programs have been cured of anomalies that
afflicted the older math library \fIlibm\fR in which incidents like
d124 40
a163 11
.RS
sqrt(\-1.0) = 0.0 and log(\-1.0) = \-1.7e38.
.br
cos(1.0e\-11) \*[Gt] cos(0.0) \*[Gt] 1.0.
.br
pow(x,1.0)
.if n \
!=
.if t \
\(!=
x when x = 2.0, 3.0, 4.0, ..., 9.0.
d165 1
a165 1
pow(\-1.0,1.0e10) trapped on Integer Overflow.
d167 1
a167 21
sqrt(1.0e30) and sqrt(1.0e\-30) were very slow.
.RE
However the two versions do differ in ways that have to be
explained, to which end the following notes are provided.
.PP
\fBDEC VAX\-11 D_floating\-point:\fR
.PP
This is the format for which the original math library \fIlibm\fR
was developed, and to which this manual is still principally dedicated.
It is \fIthe\fR double\-precision format for the PDP\-11
and the earlier VAX\-11 machines; VAX\-11s after 1983 were
provided with an optional "G" format closer to the IEEE
double\-precision format.
The earlier DEC MicroVAXs have no D format, only G double\-precision.
(Why?
Why not?)
.PP
Properties of D_floating\-point:
.RS
Wordsize: 64 bits, 8 bytes.
Radix: Binary.
a168 25
Precision: 56
.if n \
sig.
.if t \
significant
bits, roughly like 17
.if n \
sig.
.if t \
significant
decimals.
.RS
If x and x' are consecutive positive D_floating\-point
numbers (they differ by 1 \*(up), then
.br
1.3e\-17 \*[Lt] 0.5**56 \*[Lt] (x'\-x)/x \*[Le] 0.5**55 \*[Lt] 2.8e\-17.
.RE
.nf
.ta \w'Range:'u+1n +\w'Underflow threshold'u+1n +\w'= 2.0**127'u+1n
Range:	Overflow threshold	= 2.0**127	= 1.7e38.
	Underflow threshold	= 0.5**128	= 2.9e\-39.
	NOTE:  THIS RANGE IS COMPARATIVELY NARROW.
.ta
.fi
.RS
d174 6
a179 14
.RS
It is possible to have x
.if n \
!=
.if t \
\(!=
y and yet
x\-y = 0 because of underflow.
Similarly x \*[Gt] y \*[Gt] 0 cannot prevent either x\(**y = 0
or  y/x = 0 from happening without warning.
.RE
.RE
Zero is represented ambiguously.
.RS
d182 4
a185 8
There is no \-0 on a VAX.
.RE
.If
is not part of the VAX architecture.
.br
Reserved operands:
.RS
of the 2**55 that the hardware
d187 1
a187 1
Any floating\-point operation upon a reserved
d190 1
a190 3
.RE
Exceptions:
.RS
d195 3
a197 5
.RE
Rounding:
.RS
Every rational operation  (+, \-, \(**, /) on a
VAX (but not necessarily on a PDP\-11), if not an
d199 5
a203 6
within half an \*(up, and when the rounding error is
exactly half an \*(up then rounding is away from 0.
.RE
.RE
.PP
Except for its narrow range, D_floating\-point is one of the
d206 2
a207 1
functions for a VAX distributed in 4.3 BSD.
d212 1
a212 1
like 1/0; and sqrt(\-3) and acos(3) behave like 0/0;
d215 1
a215 2
.RS
.ll -0.5i
d219 16
a234 7
handle all floating\-point arithmetic exceptions neatly.\fR
.ll +0.5i
.RE
.PP
How do the functions in 4.3 BSD's new \fIlibm\fR for UNIX
compare with their counterparts in DEC's VAX/VMS library?
Some of the VMS functions are a little faster, some are
d238 29
a266 18
\fIlibm\fR.
The VMS codes interpolate in large table to achieve
speed and accuracy; the \fIlibm\fR codes use tricky formulas
compact enough that all of them may some day fit into a ROM.
.PP
More important, DEC regards the VMS codes as proprietary
and guards them zealously against unauthorized use.
But the \fIlibm\fR codes in 4.3 BSD are intended for the public domain;
they may be copied freely provided their provenance is always
acknowledged, and provided users assist the authors in their
researches by reporting experience with the codes.
Therefore no user of UNIX on a machine whose arithmetic resembles
VAX D_floating\-point need use anything worse than the new \fIlibm\fR.
.PP
\fBIEEE STANDARD 754 Floating\-Point Arithmetic:\fR
.PP
This standard is on its way to becoming more widely adopted
than any other design for computer arithmetic.
d268 6
a273 8
produced by a host of manufacturers, among them ...
.nf
.ta 0.5i +\w'Intel i8070, i80287'u+6n
	Intel i8087, i80287	National Semiconductor  32081
	Motorola 68881	Weitek WTL-1032, ... , -1165
	Zilog Z8070	Western Electric (AT\*[Am]T) WE32106.
.ta
.fi
d275 1
a275 1
in the Apple Macintosh, through VLSI in the Hewlett\-Packard
d277 82
a358 73
Several other companies have adopted the formats
of IEEE 754 without, alas, adhering to the standard's way
of handling rounding and exceptions like over/underflow.
The DEC VAX G_floating\-point format is very similar to the IEEE
754 Double format, so similar that the C programs for the
IEEE versions of most of the elementary functions listed
above could easily be converted to run on a MicroVAX, though
nobody has volunteered to do that yet.
.PP
The codes in 4.3 BSD's \fIlibm\fR for machines that conform to
IEEE 754 are intended primarily for the National Semi. 32081
and WTL 1164/65.
To use these codes with the Intel or Zilog
chips, or with the Apple Macintosh or ELXSI 6400, is to
forego the use of better codes provided (perhaps freely) by
those companies and designed by some of the authors of the
codes above.
Except for \fIatan\fR, \fIcabs\fR, \fIcbrt\fR, \fIerf\fR,
\fIerfc\fR, \fIhypot\fR, \fIj0\-jn\fR, \fIlgamma\fR, \fIpow\fR
and \fIy0\-yn\fR,
the Motorola 68881 has all the functions in \fIlibm\fR on chip,
and faster and more accurate;
it, Apple, the i8087, Z8070 and WE32106 all use 64
.if n \
sig.
.if t \
significant
bits.
The main virtue of 4.3 BSD's
\fIlibm\fR codes is that they are intended for the public domain;
they may be copied freely provided their provenance is always
acknowledged, and provided users assist the authors in their
researches by reporting experience with the codes.
Therefore no user of UNIX on a machine that conforms to
IEEE 754 need use anything worse than the new \fIlibm\fR.
.PP
Properties of IEEE 754 Double\-Precision:
.RS
Wordsize: 64 bits, 8 bytes.
Radix: Binary.
.br
Precision: 53
.if n \
sig.
.if t \
significant
bits, roughly like 16
.if n \
sig.
.if t \
significant
decimals.
.RS
If x and x' are consecutive positive Double\-Precision
numbers (they differ by 1 \*(up), then
.br
1.1e\-16 \*[Lt] 0.5**53 \*[Lt] (x'\-x)/x \*[Le] 0.5**52 \*[Lt] 2.3e\-16.
.RE
.nf
.ta \w'Range:'u+1n +\w'Underflow threshold'u+1n +\w'= 2.0**1024'u+1n
Range:	Overflow threshold	= 2.0**1024	= 1.8e308
	Underflow threshold	= 0.5**1022	= 2.2e\-308
.ta
.fi
.RS
Overflow goes by default to a signed
.If "" .
.br
Underflow is \fIGradual,\fR rounding to the nearest
integer multiple of 0.5**1074 = 4.9e\-324.
.RE
Zero is represented ambiguously as +0 or \-0.
.RS
d361 1
a361 1
with like signs; but x\-x yields +0 for every
d364 2
a365 2
sign are division by zero and copysign(x,\(+-0).
In particular, comparison (x \*[Gt] y, x \*[Ge] y, etc.)
d367 21
a387 48
finite x = y then
.If
\&= 1/(x\-y)
.if n \
!=
.if t \
\(!=
\-1/(y\-x) =
.If \- .
.RE
.If
is signed.
.RS
it persists when added to itself
or to any finite number.
Its sign transforms
correctly through multiplication and division, and
.If (finite)/\(+- \0=\0\(+-0
(nonzero)/0 =
.If \(+- .
But
.if n \
Infinity\-Infinity, Infinity\(**0 and Infinity/Infinity
.if t \
\(if\-\(if, \(if\(**0 and \(if/\(if
are, like 0/0 and sqrt(\-3),
invalid operations that produce \*(nn. ...
.RE
Reserved operands:
.RS
there are 2**53\-2 of them, all
called \*(nn (\fIN\fRot \fIa N\fRumber).
Some, called Signaling \*(nns, trap any floating\-point operation
performed upon them; they are used to mark missing
or uninitialized values, or nonexistent elements of arrays.
The rest are Quiet \*(nns; they are
the default results of Invalid Operations, and
propagate through subsequent arithmetic operations.
If x
.if n \
!=
.if t \
\(!=
x then x is \*(nn; every other predicate
(x \*[Gt] y, x = y, x \*[Lt] y, ...) is FALSE if \*(nn is involved.
.br
NOTE: Trichotomy is violated by \*(nn.
.RS
d390 4
a393 6
signal Invalid Operation when \*(nn is involved.
.RE
.RE
Rounding:
.RS
Every algebraic operation (+, \-, \(**, /,
d398 3
a400 3
is rounded by default to within half an \*(up, and
when the rounding error is exactly half an \*(up then
the rounded value's least significant bit is zero.
d402 2
a403 1
sometimes provably so; for instance, for every
d408 3
a410 1
Only rounding like IEEE 754 can do that.
d412 10
a421 13
proved best for every circumstance, so IEEE 754
provides rounding towards zero or towards
.If +
or towards
.If \-
at the programmer's option.
And the same kinds of rounding are specified for
Binary\-Decimal Conversions, at least for magnitudes
between roughly 1.0e\-10 and 1.0e37.
.RE
Exceptions:
.RS
IEEE 754 recognizes five kinds of floating\-point exceptions,
d423 10
a432 20
.RS
.nf
.ta \w'Invalid Operation'u+6n +\w'Gradual Underflow'u+2n
Exception	Default Result
.tc \(ru

.tc
Invalid Operation	\*(nn, or FALSE
.if n \{\
Overflow	\(+-Infinity
Divide by Zero	\(+-Infinity \}
.if t \{\
Overflow	\(+-\(if
Divide by Zero	\(+-\(if \}
Underflow	Gradual Underflow
Inexact	Rounded value
.ta
.fi
.RE
NOTE:  An Exception is not an Error unless handled badly.
d440 7
a446 4
.RE
.PP
For each kind of floating\-point exception, IEEE 754
provides a Flag that is raised each time its exception
d449 6
a454 4
Thus, IEEE 754 provides three ways by which programs
may cope with exceptions for which the default result
might be unsatisfactory:
.IP 1) \w'\0\0\0\0'u
d457 1
a457 1
.IP 2) \w'\0\0\0\0'u
d460 1
a460 1
.IP 3) \w'\0\0\0\0'u
d463 1
a463 1
.RS
d467 2
a468 1
underflow threshold, or to test the Underflow flag.
d470 2
a471 6
IEEE 754; if x
.if n \
!=
.if t \
\(!=
y then x\-y is correct to
d474 4
a477 4
Products and quotients that
underflow gradually can lose accuracy gradually
without vanishing, so comparing them with zero
(as one might on a VAX) will not reveal the loss.
d485 6
a490 3
.RE
.PP
At the option of an implementor conforming to IEEE 754,
d492 1
a492 1
.IP 4) \w'\0\0\0\0'u
d496 1
a496 1
traditionally associated with error\-handling
d500 2
a501 1
.IP \(em \w'\0\0\0\0'u
d504 2
a505 1
computation from what may be the middle of an expression.
d507 2
a508 2
.IP \(em \w'\0\0\0\0'u
In a subprogram that lacks an error\-handling
d512 1
a512 1
an error\-handling statement is encountered or the
d514 2
a515 1
.IP 5) \w'\0\0\0\0'u
d517 6
a522 10
This mechanism, requiring an interactive
debugging environment, is more for the programmer
than the program.
It classifies an exception in
advance as a symptom of a programmer's error; the
exception suspends execution as near as it can to
the offending operation so that the programmer can
look around to see how it happened.
Quite often
the first several exceptions turn out to be quite
d526 1
a526 1
.IP 6) \w'\0\0\0\0'u
d528 2
a529 2
.RE
.PP
d533 7
a539 4
to be distributed in 4.3 BSD's \fIlibm\fR.
Ideally, each elementary function should act
as if it were indivisible, or atomic, in the sense that ...
.IP i) \w'iii)'u+2n
d542 1
a542 1
.IP ii) \w'iii)'u+2n
d545 1
a545 1
.IP iii) \w'iii)'u+2n
d552 15
a566 14
.PP
Ideally, every programmer should be able \fIconveniently\fR to
turn a debugged subprogram into one that appears atomic to
its users.
But simulating all three characteristics of an
atomic function is still a tedious affair, entailing hosts
of tests and saves\-restores; work is under way to ameliorate
the inconvenience.
.PP
Meanwhile, the functions in \fIlibm\fR are only approximately atomic.
They signal no inappropriate exception except possibly ...
.RS
Over/Underflow
.RS
d568 1
a568 3
.RE
Inexact in \fIcabs\fR, \fIcbrt\fR, \fIhypot\fR, \fIlog10\fR and \fIpow\fR
.RS
d570 6
a575 10
.RE
.RE
Otherwise, ...
.RS
Invalid Operation is signaled only when
.RS
any result but \*(nn would probably be misleading.
.RE
Overflow is signaled only when
.RS
d577 1
a577 3
.RE
Divide\-by\-Zero is signaled only when
.RS
d579 1
a579 3
.RE
Underflow is signaled only when
.RS
d581 1
a581 3
.RE
Inexact is signaled only when
.RS
d583 119
a701 16
.RE
.RE
.\" .Sh FILES
.\" .Bl -tag -width /usr/lib/libm_p.a -compact
.\" .It Pa /usr/lib/libm.a
.\" the static math library
.\" .It Pa /usr/lib/libm.so
.\" the dynamic math library
.\" .It Pa /usr/lib/libm_p.a
.\" the static math library compiled for profiling
.\" .El
.SH SEE ALSO
An explanation of IEEE 754 and its proposed extension p854
was published in the IEEE magazine MICRO in August 1984 under
the title "A Proposed Radix\- and Word\-length\-independent
Standard for Floating\-point Arithmetic" by W. J. Cody et al.
d703 8
a710 4
document the features of IEEE 754 pretty well.
Articles in the IEEE magazine COMPUTER vol. 14 no. 3 (Mar. 1981),
and in the ACM SIGNUM Newsletter Special Issue of
Oct. 1979, may be helpful although they pertain to
d712 1
a712 1
.SH BUGS
d714 11
a724 7
operations within the codes, so a subroutine\-trace may be
needed to identify the function with its signal in case
method 5) above is in use.
And the codes all take the
IEEE 754 defaults for granted; this means that a decision to
trap all divisions by zero could disrupt a code that would
otherwise get correct results despite division by zero.
@


1.1.3.2
log
@Import current libm from NetBSD, with the directories complex, noieee_src, arch/!i387 removed.

The idea is to get fmin and fmax, which are needed by some newer software.
@
text
@d1 1
a1 1
.\"	$NetBSD: math.3,v 1.25 2011/09/22 18:14:09 njoly Exp $
d32 16
a47 13
.Dd February 23, 2007
.Dt MATH 3
.Os
.Sh NAME
.Nm math
.Nd introduction to mathematical library functions
.Sh LIBRARY
.Lb libm
.Sh SYNOPSIS
.In math.h
.Sh DESCRIPTION
These functions constitute the C
.Lb libm .
d49 1
a49 1
.In math.h .
d51 79
a129 68
.Ss List of Functions
.Bl -column "copysignX" "gammaX3XX" "inverse trigonometric funcX"
.It Sy Name Ta Sy Man page Ta Sy Description Ta Sy Error Bound Dv ( ULP Ns No s)
.It acos Ta Xr acos 3 Ta inverse trigonometric function Ta 3
.It acosh Ta Xr acosh 3 Ta inverse hyperbolic function Ta 3
.It asin Ta Xr asin 3 Ta inverse trigonometric function Ta 3
.It asinh Ta Xr asinh 3 Ta inverse hyperbolic function Ta 3
.It atan Ta Xr atan 3 Ta inverse trigonometric function Ta 1
.It atanh Ta Xr atanh 3 Ta inverse hyperbolic function Ta 3
.It atan2 Ta Xr atan2 3 Ta inverse trigonometric function Ta 2
.It cbrt Ta Xr sqrt 3 Ta cube root Ta 1
.It ceil Ta Xr ceil 3 Ta integer no less than Ta 0
.It copysign Ta Xr copysign 3 Ta copy sign bit Ta 0
.It cos Ta Xr cos 3 Ta trigonometric function Ta 1
.It cosh Ta Xr cosh 3 Ta hyperbolic function Ta 3
.It erf Ta Xr erf 3 Ta error function Ta ???
.It erfc Ta Xr erf 3 Ta complementary error function Ta ???
.It exp Ta Xr exp 3 Ta exponential Ta 1
.It expm1 Ta Xr exp 3 Ta exp(x)\-1 Ta 1
.It fabs Ta Xr fabs 3 Ta absolute value Ta 0
.It finite Ta Xr finite 3 Ta test for finity Ta 0
.It floor Ta Xr floor 3 Ta integer no greater than Ta 0
.It fmod Ta Xr fmod 3 Ta remainder Ta ???
.It hypot Ta Xr hypot 3 Ta Euclidean distance Ta 1
.It ilogb Ta Xr ilogb 3 Ta exponent extraction Ta 0
.It isinf Ta Xr isinf 3 Ta test for infinity Ta 0
.It isnan Ta Xr isnan 3 Ta test for not-a-number Ta 0
.It j0 Ta Xr j0 3 Ta Bessel function Ta ???
.It j1 Ta Xr j0 3 Ta Bessel function Ta ???
.It jn Ta Xr j0 3 Ta Bessel function Ta ???
.It lgamma Ta Xr lgamma 3 Ta log gamma function Ta ???
.It log Ta Xr log 3 Ta natural logarithm Ta 1
.It log10 Ta Xr log 3 Ta logarithm to base 10 Ta 3
.It log1p Ta Xr log 3 Ta log(1+x) Ta 1
.It nan Ta Xr nan 3 Ta return quiet \*(Na Ta 0
.It nextafter Ta Xr nextafter 3 Ta next representable number Ta 0
.It pow Ta Xr pow 3 Ta exponential x**y Ta 60\-500
.It remainder Ta Xr remainder 3 Ta remainder Ta 0
.It rint Ta Xr rint 3 Ta round to nearest integer Ta 0
.It scalbn Ta Xr scalbn 3 Ta exponent adjustment Ta 0
.It sin Ta Xr sin 3 Ta trigonometric function Ta 1
.It sinh Ta Xr sinh 3 Ta hyperbolic function Ta 3
.It sqrt Ta Xr sqrt 3 Ta square root Ta 1
.It tan Ta Xr tan 3 Ta trigonometric function Ta 3
.It tanh Ta Xr tanh 3 Ta hyperbolic function Ta 3
.It trunc Ta Xr trunc 3 Ta nearest integral value Ta 3
.It y0 Ta Xr j0 3 Ta Bessel function Ta ???
.It y1 Ta Xr j0 3 Ta Bessel function Ta ???
.It yn Ta Xr j0 3 Ta Bessel function Ta ???
.El
.Ss List of Defined Values
.Bl -column "M_2_SQRTPIXX" "1.12837916709551257390XX" "2/sqrt(pi)XXX"
.It Sy Name Ta Sy Value Ta Sy Description
.It M_E	2.7182818284590452354	e
.It M_LOG2E	1.4426950408889634074	log 2e
.It M_LOG10E	0.43429448190325182765	log 10e
.It M_LN2	0.69314718055994530942	log e2
.It M_LN10	2.30258509299404568402	log e10
.It M_PI	3.14159265358979323846	pi
.It M_PI_2	1.57079632679489661923	pi/2
.It M_PI_4	0.78539816339744830962	pi/4
.It M_1_PI	0.31830988618379067154	1/pi
.It M_2_PI	0.63661977236758134308	2/pi
.It M_2_SQRTPI	1.12837916709551257390	2/sqrt(pi)
.It M_SQRT2	1.41421356237309504880	sqrt(2)
.It M_SQRT1_2	0.70710678118654752440	1/sqrt(2)
.El
.Sh NOTES
d140 2
a141 5
of
.Dv ULPs
tabulated above; an
.Dv ULP
is one Unit in the Last Place.
d143 1
a143 2
afflicted the older math library
in which incidents like
d145 1
a145 1
.Bd -literal -offset indent
d147 1
d149 8
a156 1
pow(x,1.0) \(!= x when x = 2.0, 3.0, 4.0, ..., 9.0.
d158 1
d160 1
a160 1
.Ed
d163 4
a166 2
.Ss DEC VAX\-11 D_floating\-point
This is the format for which the original math library
d168 1
a168 3
It is
.Em the
double\-precision format for the PDP\-11
d175 1
a175 1
.Pp
d177 16
a192 7
.Bl -hang -offset indent
.It Wordsize :
64 bits, 8 bytes.
.It Radix :
Binary.
.It Precision :
56 significant bits, roughly like 17 significant decimals.
d194 12
a205 11
numbers (they differ by 1
.Dv ULP ) ,
then
.Dl 1.3e\-17 \*[Lt] 0.5**56 \*[Lt] (x'\-x)/x \*[Le] 0.5**55 \*[Lt] 2.8e\-17.
.It Range :
.Bl -column "Underflow thresholdX" "2.0**127X"
.It Overflow threshold	= 2.0**127	= 1.7e38.
.It Underflow threshold	= 0.5**128	= 2.9e\-39.
.El
.Em NOTE: THIS RANGE IS COMPARATIVELY NARROW.
.Pp
d207 1
d209 3
a211 1
.Em CAUTION :
d213 3
d217 2
a218 1
y and yet x\-y = 0 because of underflow.
d220 5
a224 2
or y/x = 0 from happening without warning.
.It Zero is represented ambiguously :
d228 6
a233 2
.It \*(If is not part of the VAX architecture .
.It Reserved operands :
d239 3
a241 1
.It Exceptions :
d246 3
a248 1
.It Rounding :
d252 5
a256 8
within half an
.Dv ULP ,
and when the rounding error is
exactly half an
.Dv ULP
then rounding is away from 0.
.El
.Pp
d268 10
a277 7
.Pp
.Em This response seems excessively punitive, so it is destined
.Em to be replaced at some time in the foreseeable future by a
.Em more flexible but still uniform scheme being developed to
.Em handle all floating\-point arithmetic exceptions neatly.
.Pp
How do the functions in 4.3 BSD's new math library for UNIX
d283 1
a283 1
libm.
d285 1
a285 1
speed and accuracy; the libm codes use tricky formulas
d287 1
a287 1
.Pp
d290 1
a290 1
But the libm codes in 4.3 BSD are intended for the public domain;
d295 4
a298 2
VAX D_floating\-point need use anything worse than the new libm.
.Ss IEEE STANDARD 754 Floating\-Point Arithmetic
d303 7
a309 5
.Bl -column "Intel i8070, i80287XX"
.It Intel i8087, i80287	National Semiconductor  32081
.It 68881	Weitek WTL-1032, ... , -1165
.It Zilog Z8070	Western Electric (AT\*[Am]T) WE32106.
.El
d321 3
a323 3
.Pp
The codes in 4.3 BSD's libm for machines that conform to
IEEE 754 are intended primarily for the National Semiconductor 32081
d330 4
a333 12
Except for
.Fn atan ,
.Fn cbrt ,
.Fn erf ,
.Fn erfc ,
.Fn hypot ,
.Fn j0-jn ,
.Fn lgamma ,
.Fn pow ,
and
.Fn y0\-yn ,
the Motorola 68881 has all the functions in libm on chip,
d335 6
a340 1
it, Apple, the i8087, Z8070 and WE32106 all use 64 significant bits.
d342 1
a342 1
libm codes is that they are intended for the public domain;
d347 2
a348 2
IEEE 754 need use anything worse than the new libm.
.Pp
d350 16
a365 7
.Bl -hang -offset indent
.It Wordsize :
64 bits, 8 bytes.
.It Radix :
Binary.
.It Precision :
53 significant bits, roughly like 16 significant decimals.
d367 15
a381 13
numbers (they differ by 1
.Dv ULP ) ,
then
.Dl 1.1e\-16 \*[Lt] 0.5**53 \*[Lt] (x'\-x)/x \*[Le] 0.5**52 \*[Lt] 2.3e\-16.
.It Range :
.Bl -column "Underflow thresholdX" "2.0**1024X"
.It Overflow threshold	= 2.0**1024	= 1.8e308
.It Underflow threshold	= 0.5**1022	= 2.2e\-308
.El
Overflow goes by default to a signed \*(If.
Underflow is
.Sy Gradual ,
rounding to the nearest
d383 3
a385 1
.It Zero is represented ambiguously as +0 or \-0:
d394 2
a395 1
finite x = y then \*(If
d397 3
d402 5
a406 2
\- \*(If .
.It \*(If is signed :
d411 1
a411 1
\*(If (finite)/\(+- \0=\0\(+-0
d413 1
a413 1
\(+- \*(If.
d415 3
d420 4
a423 2
invalid operations that produce \*(Na.
.It Reserved operands :
d425 2
a426 2
called \*(Na (Not A Number).
Some, called Signaling \*[Na]s, trap any floating\-point operation
d429 1
a429 1
The rest are Quiet \*[Na]s; they are
d433 3
d437 5
a441 5
x then x is \*(Na; every other predicate
(x \*[Gt] y, x = y, x \*[Lt] y, ...) is FALSE if \*(Na is involved.
.Pp
.Em NOTE :
Trichotomy is violated by \*(Na.
d444 5
a448 2
signal Invalid Operation when \*(Na is involved.
.It Rounding :
d450 3
d454 3
a456 5
is rounded by default to within half an
.Dv ULP ,
and when the rounding error is exactly half an
.Dv ULP
then the rounded value's least significant bit is zero.
d467 1
a467 1
+\*(If
d469 1
a469 1
\-\*(If
d474 3
a476 1
.It Exceptions :
d479 20
a498 11
.Bl -column "Invalid OperationX" "Gradual OverflowX"
.It Sy Exception Ta Sy Default Result
.It Invalid Operation	\*(Na, or FALSE
.It Overflow	\(+-\(if
.It Divide by Zero	\(+-\(if \}
.It Underflow	Gradual Underflow
.It Inexact	Rounded value
.El
.Pp
.Em NOTE :
An Exception is not an Error unless handled badly.
d506 2
a507 2
.El
.Pp
d515 1
a515 2
.Bl -enum
.It
d518 1
a518 1
.It
d521 1
a521 1
.It
d524 2
a525 2
.Em CAUTION :
The only reliable ways to discover
d531 3
d547 1
a547 3
So gradual underflows are usually
.Em provably
ignorable.
d549 2
a550 1
.Pp
d553 1
a553 1
.It
d561 1
a561 2
.Bl -dash
.It
d566 1
a566 1
.It
d573 1
a573 2
.El
.It
d588 1
a588 1
.It
d590 2
a591 2
.El
.Pp
d595 1
a595 1
to be distributed in 4.3 BSD's libm.
d598 1
a598 2
.Bl -enum
.It
d601 1
a601 1
.It
d604 1
a604 1
.It
d611 3
a613 5
.El
.Pp
Ideally, every programmer should be able
.Em conveniently
to turn a debugged subprogram into one that appears atomic to
d619 2
a620 2
.Pp
Meanwhile, the functions in libm are only approximately atomic.
d622 3
a624 2
.Bl -ohang -offset indent
.It Over/Underflow
d626 3
a628 1
.It Inexact in Fn cbrt , Fn hypot , Fn log10 and Fn pow
d630 2
a631 1
.El
d633 7
a639 4
.Bl -ohang -offset indent
.It Invalid Operation is signaled only when
any result but \*(Na would probably be misleading.
.It Overflow is signaled only when
d641 3
a643 1
.It Divide\-by\-Zero is signaled only when
d645 3
a647 1
.It Underflow is signaled only when
d649 3
a651 1
.It Inexact is signaled only when
d653 2
a654 1
.El
d664 1
a664 1
.Sh SEE ALSO
d675 1
a675 1
.Sh BUGS
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@
