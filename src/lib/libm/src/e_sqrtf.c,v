head	1.2;
access;
symbols
	cvs-201110182115:1.1.3.1
	MIRBSD_10:1.2.0.2
	MIRBSD_10_BASE:1.2
	cvs-200611031400:1.1.3.1
	netbsd:1.1.3
	OPENBSD_4_0:1.1.1.1
	MIRBSD_9_BASE:1.1.1.1
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200507211800:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2006.11.03.18.10.55;	author tg;	state Exp;
branches;
next	1.1;
commitid	100454B862956081199;

1.1
date	2005.02.05.17.25.18;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.3.1;
next	;

1.1.1.1
date	2005.02.05.17.25.18;	author tg;	state Exp;
branches;
next	;

1.1.3.1
date	2006.11.03.14.20.59;	author tg;	state Exp;
branches;
next	;
commitid	100454B505850533E95;


desc
@@


1.2
log
@Switch to NetBSD libm
@
text
@/* e_sqrtf.c -- float version of e_sqrt.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#include <sys/cdefs.h>
#if defined(LIBM_SCCS) && !defined(lint)
__RCSID("$NetBSD: e_sqrtf.c,v 1.7 2002/05/26 22:01:53 wiz Exp $");
#endif

#include "math.h"
#include "math_private.h"

static	const float	one	= 1.0, tiny=1.0e-30;

float
__ieee754_sqrtf(float x)
{
	float z;
	int32_t sign = (int)0x80000000;
	int32_t ix,s,q,m,t,i;
	u_int32_t r;

	GET_FLOAT_WORD(ix,x);

    /* take care of Inf and NaN */
	if((ix&0x7f800000)==0x7f800000) {
	    return x*x+x;		/* sqrt(NaN)=NaN, sqrt(+inf)=+inf
					   sqrt(-inf)=sNaN */
	}
    /* take care of zero */
	if(ix<=0) {
	    if((ix&(~sign))==0) return x;/* sqrt(+-0) = +-0 */
	    else if(ix<0)
		return (x-x)/(x-x);		/* sqrt(-ve) = sNaN */
	}
    /* normalize x */
	m = (ix>>23);
	if(m==0) {				/* subnormal x */
	    for(i=0;(ix&0x00800000)==0;i++) ix<<=1;
	    m -= i-1;
	}
	m -= 127;	/* unbias exponent */
	ix = (ix&0x007fffff)|0x00800000;
	if(m&1)	/* odd m, double x to make it even */
	    ix += ix;
	m >>= 1;	/* m = [m/2] */

    /* generate sqrt(x) bit by bit */
	ix += ix;
	q = s = 0;		/* q = sqrt(x) */
	r = 0x01000000;		/* r = moving bit from right to left */

	while(r!=0) {
	    t = s+r;
	    if(t<=ix) {
		s    = t+r;
		ix  -= t;
		q   += r;
	    }
	    ix += ix;
	    r>>=1;
	}

    /* use floating add to find out rounding direction */
	if(ix!=0) {
	    z = one-tiny; /* trigger inexact flag */
	    if (z>=one) {
	        z = one+tiny;
		if (z>one)
		    q += 2;
		else
		    q += (q&1);
	    }
	}
	ix = (q>>1)+0x3f000000;
	ix += (m <<23);
	SET_FLOAT_WORD(z,ix);
	return z;
}
@


1.1
log
@Initial revision
@
text
@d11 1
a11 1
 * software is freely granted, provided that this notice 
d16 1
d18 1
a18 1
static char rcsid[] = "$NetBSD: e_sqrtf.c,v 1.4 1995/05/10 20:46:19 jtc Exp $";
d30 1
a30 1
	int32_t sign = (int)0x80000000; 
d37 1
a37 1
	if((ix&0x7f800000)==0x7f800000) {			
d40 1
a40 1
	} 
d65 6
a70 6
	    t = s+r; 
	    if(t<=ix) { 
		s    = t+r; 
		ix  -= t; 
		q   += r; 
	    } 
@


1.1.3.1
log
@Laugh at OpenBSD's libm and import NetBSD's
@
text
@d11 1
a11 1
 * software is freely granted, provided that this notice
a15 1
#include <sys/cdefs.h>
d17 1
a17 1
__RCSID("$NetBSD: e_sqrtf.c,v 1.7 2002/05/26 22:01:53 wiz Exp $");
d29 1
a29 1
	int32_t sign = (int)0x80000000;
d36 1
a36 1
	if((ix&0x7f800000)==0x7f800000) {
d39 1
a39 1
	}
d64 6
a69 6
	    t = s+r;
	    if(t<=ix) {
		s    = t+r;
		ix  -= t;
		q   += r;
	    }
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@
