head	1.8;
access;
symbols
	cvs-200804031830:1.1.1.1
	MIRBSD_10:1.4.0.2
	MIRBSD_10_BASE:1.4
	cvs-200706161500:1.1.1.1
	cvs-200705171600:1.1.1.1
	OPENBSD_4_0:1.1.1.1
	MIRBSD_9_BASE:1.2
	MIRBSD_8:1.2.0.2
	MIRBSD_8_BASE:1.2
	cvs-200512060130:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.06.05.13.26.35;	author tg;	state Exp;
branches;
next	1.7;
commitid	100539070127B1C96CD;

1.7
date	2008.07.06.16.08.03;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004870EDE560FC7E49;

1.6
date	2008.07.06.15.44.50;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004870E88316FD11F0;

1.5
date	2008.05.22.22.00.40;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004835ECD70F4172B2;

1.4
date	2007.09.28.12.41.53;	author tg;	state Exp;
branches;
next	1.3;
commitid	10046FCF6683BF48EA5;

1.3
date	2007.09.28.12.12.57;	author tg;	state Exp;
branches;
next	1.2;
commitid	10046FCEFA52BF98B14;

1.2
date	2005.03.06.20.29.27;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.25.39;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.25.39;	author tg;	state Exp;
branches;
next	;


desc
@@


1.8
log
@merge most relevant changes from 0.9.8za

thanks to lewellyn for noticing me
@
text
@/* apps/s_cb.c - callback functions used by s_client, s_server, and s_time */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stdio.h>
#include <stdlib.h>
#define USE_SOCKETS
#define NON_MAIN
#include "apps.h"
#undef NON_MAIN
#undef USE_SOCKETS
#include <openssl/err.h>
#include <openssl/x509.h>
#include <openssl/ssl.h>
#include "s_apps.h"

__RCSID("$MirOS: src/lib/libssl/src/apps/s_cb.c,v 1.7 2008/07/06 16:08:03 tg Exp $");

int verify_depth=0;
int verify_error=X509_V_OK;

int MS_CALLBACK verify_callback(int ok, X509_STORE_CTX *ctx)
	{
	char buf[256];
	X509 *err_cert;
	int err,depth;

	app_RAND_pushback((uint32_t)ok, (uint32_t)ctx, 0, 0);

	err_cert=X509_STORE_CTX_get_current_cert(ctx);
	err=	X509_STORE_CTX_get_error(ctx);
	depth=	X509_STORE_CTX_get_error_depth(ctx);

	X509_NAME_oneline(X509_get_subject_name(err_cert),buf,sizeof buf);
	BIO_printf(bio_err,"depth=%d %s\n",depth,buf);
	if (!ok)
		{
		BIO_printf(bio_err,"verify error:num=%d:%s\n",err,
			X509_verify_cert_error_string(err));
		if (verify_depth >= depth)
			{
			ok=1;
			verify_error=X509_V_OK;
			}
		else
			{
			ok=0;
			verify_error=X509_V_ERR_CERT_CHAIN_TOO_LONG;
			}
		}
	switch (ctx->error)
		{
	case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:
		X509_NAME_oneline(X509_get_issuer_name(ctx->current_cert),buf,sizeof buf);
		BIO_printf(bio_err,"issuer= %s\n",buf);
		break;
	case X509_V_ERR_CERT_NOT_YET_VALID:
	case X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD:
		BIO_printf(bio_err,"notBefore=");
		ASN1_TIME_print(bio_err,X509_get_notBefore(ctx->current_cert));
		BIO_printf(bio_err,"\n");
		break;
	case X509_V_ERR_CERT_HAS_EXPIRED:
	case X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD:
		BIO_printf(bio_err,"notAfter=");
		ASN1_TIME_print(bio_err,X509_get_notAfter(ctx->current_cert));
		BIO_printf(bio_err,"\n");
		break;
		}
	BIO_printf(bio_err,"verify return:%d\n",ok);
	return(ok);
	}

int set_cert_stuff(SSL_CTX *ctx, char *cert_file, char *key_file)
	{
	app_RAND_pushback((uint32_t)ctx, (uint32_t)cert_file, (uint32_t)key_file, 0);
	if (cert_file != NULL)
		{
		/*
		SSL *ssl;
		X509 *x509;
		*/

		if (SSL_CTX_use_certificate_file(ctx,cert_file,
			SSL_FILETYPE_PEM) <= 0)
			{
			BIO_printf(bio_err,"unable to get certificate from '%s'\n",cert_file);
			ERR_print_errors(bio_err);
			return(0);
			}
		if (key_file == NULL) key_file=cert_file;
		if (SSL_CTX_use_PrivateKey_file(ctx,key_file,
			SSL_FILETYPE_PEM) <= 0)
			{
			BIO_printf(bio_err,"unable to get private key from '%s'\n",key_file);
			ERR_print_errors(bio_err);
			return(0);
			}

		/*
		In theory this is no longer needed
		ssl=SSL_new(ctx);
		x509=SSL_get_certificate(ssl);

		if (x509 != NULL) {
			EVP_PKEY *pktmp;
			pktmp = X509_get_pubkey(x509);
			EVP_PKEY_copy_parameters(pktmp,
						SSL_get_privatekey(ssl));
			EVP_PKEY_free(pktmp);
		}
		SSL_free(ssl);
		*/

		/* If we are using DSA, we can copy the parameters from
		 * the private key */


		/* Now we know that a key and cert have been set against
		 * the SSL context */
		if (!SSL_CTX_check_private_key(ctx))
			{
			BIO_printf(bio_err,"Private key does not match the certificate public key\n");
			return(0);
			}
		}
	return(1);
	}

long MS_CALLBACK bio_dump_cb(BIO *bio, int cmd, const char *argp, int argi,
	     long argl, long ret)
	{
	BIO *out;

	app_RAND_pushback((uint32_t)bio, (uint32_t)argp, cmd^argi, (uint32_t)(argl^ret));

	out=(BIO *)BIO_get_callback_arg(bio);
	if (out == NULL) return(ret);

	if (cmd == (BIO_CB_READ|BIO_CB_RETURN))
		{
		BIO_printf(out,"read from %08lX [%08lX] (%d bytes => %ld (0x%lX))\n",
			(long)bio,(long)argp,argi,ret,ret);
		BIO_dump(out,argp,(int)ret);
		return(ret);
		}
	else if (cmd == (BIO_CB_WRITE|BIO_CB_RETURN))
		{
		BIO_printf(out,"write to %08lX [%08lX] (%d bytes => %ld (0x%lX))\n",
			(long)bio,(long)argp,argi,ret,ret);
		BIO_dump(out,argp,(int)ret);
		}
	return(ret);
	}

void MS_CALLBACK apps_ssl_info_callback(const SSL *s, int where, int ret)
	{
	char *str;
	int w;

	app_RAND_pushback((uint32_t)s, where, ret, w);

	w=where& ~SSL_ST_MASK;

	if (w & SSL_ST_CONNECT) str="SSL_connect";
	else if (w & SSL_ST_ACCEPT) str="SSL_accept";
	else str="undefined";

	if (where & SSL_CB_LOOP)
		{
		BIO_printf(bio_err,"%s:%s\n",str,SSL_state_string_long(s));
		}
	else if (where & SSL_CB_ALERT)
		{
		str=(where & SSL_CB_READ)?"read":"write";
		BIO_printf(bio_err,"SSL3 alert %s:%s:%s\n",
			str,
			SSL_alert_type_string_long(ret),
			SSL_alert_desc_string_long(ret));
		}
	else if (where & SSL_CB_EXIT)
		{
		if (ret == 0)
			BIO_printf(bio_err,"%s:failed in %s\n",
				str,SSL_state_string_long(s));
		else if (ret < 0)
			{
			BIO_printf(bio_err,"%s:error in %s\n",
				str,SSL_state_string_long(s));
			}
		}
	}


void MS_CALLBACK msg_cb(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg)
	{
	BIO *bio = arg;
	const char *str_write_p, *str_version, *str_content_type = "", *str_details1 = "", *str_details2= "";

	app_RAND_pushback((uint32_t)(write_p^version^content_type)^(uint32_t)len, (uint32_t)buf, (uint32_t)ssl, (uint32_t)arg);

	str_write_p = write_p ? ">>>" : "<<<";

	switch (version)
		{
	case SSL2_VERSION:
		str_version = "SSL 2.0";
		break;
	case SSL3_VERSION:
		str_version = "SSL 3.0 ";
		break;
	case TLS1_VERSION:
		str_version = "TLS 1.0 ";
		break;
	default:
		str_version = "???";
		}

	if (version == SSL2_VERSION)
		{
		str_details1 = "???";

		if (len > 0)
			{
			switch (((unsigned char*)buf)[0])
				{
				case 0:
					str_details1 = ", ERROR:";
					str_details2 = " ???";
					if (len >= 3)
						{
						unsigned err = (((unsigned char*)buf)[1]<<8) + ((unsigned char*)buf)[2];

						switch (err)
							{
						case 0x0001:
							str_details2 = " NO-CIPHER-ERROR";
							break;
						case 0x0002:
							str_details2 = " NO-CERTIFICATE-ERROR";
							break;
						case 0x0004:
							str_details2 = " BAD-CERTIFICATE-ERROR";
							break;
						case 0x0006:
							str_details2 = " UNSUPPORTED-CERTIFICATE-TYPE-ERROR";
							break;
							}
						}

					break;
				case 1:
					str_details1 = ", CLIENT-HELLO";
					break;
				case 2:
					str_details1 = ", CLIENT-MASTER-KEY";
					break;
				case 3:
					str_details1 = ", CLIENT-FINISHED";
					break;
				case 4:
					str_details1 = ", SERVER-HELLO";
					break;
				case 5:
					str_details1 = ", SERVER-VERIFY";
					break;
				case 6:
					str_details1 = ", SERVER-FINISHED";
					break;
				case 7:
					str_details1 = ", REQUEST-CERTIFICATE";
					break;
				case 8:
					str_details1 = ", CLIENT-CERTIFICATE";
					break;
				}
			}
		}

	if (version == SSL3_VERSION || version == TLS1_VERSION)
		{
		switch (content_type)
			{
		case 20:
			str_content_type = "ChangeCipherSpec";
			break;
		case 21:
			str_content_type = "Alert";
			break;
		case 22:
			str_content_type = "Handshake";
			break;
			}

		if (content_type == 21) /* Alert */
			{
			str_details1 = ", ???";

			if (len == 2)
				{
				switch (((unsigned char*)buf)[0])
					{
				case 1:
					str_details1 = ", warning";
					break;
				case 2:
					str_details1 = ", fatal";
					break;
					}

				str_details2 = " ???";
				switch (((unsigned char*)buf)[1])
					{
				case 0:
					str_details2 = " close_notify";
					break;
				case 10:
					str_details2 = " unexpected_message";
					break;
				case 20:
					str_details2 = " bad_record_mac";
					break;
				case 21:
					str_details2 = " decryption_failed";
					break;
				case 22:
					str_details2 = " record_overflow";
					break;
				case 30:
					str_details2 = " decompression_failure";
					break;
				case 40:
					str_details2 = " handshake_failure";
					break;
				case 42:
					str_details2 = " bad_certificate";
					break;
				case 43:
					str_details2 = " unsupported_certificate";
					break;
				case 44:
					str_details2 = " certificate_revoked";
					break;
				case 45:
					str_details2 = " certificate_expired";
					break;
				case 46:
					str_details2 = " certificate_unknown";
					break;
				case 47:
					str_details2 = " illegal_parameter";
					break;
				case 48:
					str_details2 = " unknown_ca";
					break;
				case 49:
					str_details2 = " access_denied";
					break;
				case 50:
					str_details2 = " decode_error";
					break;
				case 51:
					str_details2 = " decrypt_error";
					break;
				case 60:
					str_details2 = " export_restriction";
					break;
				case 70:
					str_details2 = " protocol_version";
					break;
				case 71:
					str_details2 = " insufficient_security";
					break;
				case 80:
					str_details2 = " internal_error";
					break;
				case 90:
					str_details2 = " user_canceled";
					break;
				case 100:
					str_details2 = " no_renegotiation";
					break;
				case 110:
					str_details2 = " unsupported_extension";
					break;
				case 111:
					str_details2 = " certificate_unobtainable";
					break;
				case 112:
					str_details2 = " unrecognized_name";
					break;
				case 113:
					str_details2 = " bad_certificate_status_response";
					break;
				case 114:
					str_details2 = " bad_certificate_hash_value";
					break;
				case 115:
					str_details2 = " unknown_psk_identity";
					break;
					}
				}
			}

		if (content_type == 22) /* Handshake */
			{
			str_details1 = "???";

			if (len > 0)
				{
				switch (((unsigned char*)buf)[0])
					{
				case 0:
					str_details1 = ", HelloRequest";
					break;
				case 1:
					str_details1 = ", ClientHello";
					break;
				case 2:
					str_details1 = ", ServerHello";
					break;
				case 11:
					str_details1 = ", Certificate";
					break;
				case 12:
					str_details1 = ", ServerKeyExchange";
					break;
				case 13:
					str_details1 = ", CertificateRequest";
					break;
				case 14:
					str_details1 = ", ServerHelloDone";
					break;
				case 15:
					str_details1 = ", CertificateVerify";
					break;
				case 16:
					str_details1 = ", ClientKeyExchange";
					break;
				case 20:
					str_details1 = ", Finished";
					break;
					}
				}
			}
		}

	BIO_printf(bio, "%s %s%s [length %04lx]%s%s\n", str_write_p, str_version, str_content_type, (unsigned long)len, str_details1, str_details2);

	if (len > 0)
		{
		size_t num, i;

		BIO_printf(bio, "   ");
		num = len;
#if 0
		if (num > 16)
			num = 16;
#endif
		for (i = 0; i < num; i++)
			{
			if (i % 16 == 0 && i > 0)
				BIO_printf(bio, "\n   ");
			BIO_printf(bio, " %02x", ((unsigned char*)buf)[i]);
			}
		if (i < len)
			BIO_printf(bio, " ...");
		BIO_printf(bio, "\n");
		}
	BIO_flush(bio);
	}
@


1.7
log
@change key_gen_callback to match app_RAND_pushback and enhance first
key_gen_callback then also app_RAND_pushback to xor in additional entropy
@
text
@d124 1
a124 1
__RCSID("$MirOS: src/lib/libssl/src/apps/s_cb.c,v 1.6 2008/07/06 15:44:50 tg Exp $");
d490 18
@


1.6
log
@convert applications to use app_RAND_pushback()
@
text
@d124 1
a124 1
__RCSID("$MirOS: src/lib/libssl/src/apps/s_cb.c,v 1.5 2008/05/22 22:00:40 tg Exp $");
d135 1
a135 1
	app_RAND_pushback();
d183 1
a183 1
	app_RAND_pushback();
d242 1
a242 1
	app_RAND_pushback();
d268 1
a268 1
	app_RAND_pushback();
d307 1
a307 1
	app_RAND_pushback();
@


1.5
log
@RAND_add(3) takes its third argument in bytes, not in bits
⇒ estimate calculation of entropy added additionally-automatically
(but not initial entropy or extra -rand arguments) was wrong (not
really bad because OpenSSL doesn’t track entropy after reaching
ENTROPY_NEEDED bytes anyway, that’s why no MFC required)
@
text
@d124 1
a124 1
__RCSID("$MirOS: src/lib/libssl/src/apps/s_cb.c,v 1.4 2007/09/28 12:41:53 tg Exp $");
d135 1
a135 9
#ifdef MBSD_CB_ARND
	{
		uint32_t oldentropy, newentropy;

		RAND_bytes((u_char *)&oldentropy, sizeof (uint32_t));
		newentropy = arc4random_pushb(&oldentropy, sizeof (uint32_t));
		RAND_add(&newentropy, 4, 3.9);
	}
#endif
d183 1
a183 9
#ifdef MBSD_CB_ARND
	{
		uint32_t oldentropy, newentropy;

		RAND_bytes((u_char *)&oldentropy, sizeof (uint32_t));
		newentropy = arc4random_pushb(&oldentropy, sizeof (uint32_t));
		RAND_add(&newentropy, 4, 3.9);
	}
#endif
d242 1
a242 9
#ifdef MBSD_CB_ARND
	{
		uint32_t oldentropy, newentropy;

		RAND_bytes((u_char *)&oldentropy, sizeof (uint32_t));
		newentropy = arc4random_pushb(&oldentropy, sizeof (uint32_t));
		RAND_add(&newentropy, 4, 3.9);
	}
#endif
d268 1
a268 9
#ifdef MBSD_CB_ARND
	{
		uint32_t oldentropy, newentropy;

		RAND_bytes((u_char *)&oldentropy, sizeof (uint32_t));
		newentropy = arc4random_pushb(&oldentropy, sizeof (uint32_t));
		RAND_add(&newentropy, 4, 3.9);
	}
#endif
d307 1
a307 9
#ifdef MBSD_CB_ARND
	{
		uint32_t oldentropy, newentropy;

		RAND_bytes((u_char *)&oldentropy, sizeof (uint32_t));
		newentropy = arc4random_pushb(&oldentropy, sizeof (uint32_t));
		RAND_add(&newentropy, 4, 3.9);
	}
#endif
@


1.4
log
@• circumvent libc’s arc4random stuff usually, directly use KERN_ARND, since
  it has greater throughput (and entropy if the app doesn’t use it itself –
  which almost no openssl-app does)
• feed arc4random_pushb(3) results to RAND_add(3) as well
• RCS IDs
@
text
@d124 1
a124 1
__RCSID("$MirOS$");
a137 2
		int mib[2];
		size_t nlen;
d140 2
a141 11
		mib[0] = CTL_KERN;
		mib[1] = KERN_ARND;
		nlen = sizeof (uint32_t);
		sysctl(mib, 2, &newentropy, &nlen, &oldentropy,
		    sizeof (uint32_t));
		if (nlen == 0) {
			newentropy = arc4random_pushb(&oldentropy,
			    sizeof (uint32_t));
			nlen = 4;
		}
		RAND_add(&newentropy, nlen, nlen * 7.8);
a193 2
		int mib[2];
		size_t nlen;
d196 2
a197 11
		mib[0] = CTL_KERN;
		mib[1] = KERN_ARND;
		nlen = sizeof (uint32_t);
		sysctl(mib, 2, &newentropy, &nlen, &oldentropy,
		    sizeof (uint32_t));
		if (nlen == 0) {
			newentropy = arc4random_pushb(&oldentropy,
			    sizeof (uint32_t));
			nlen = 4;
		}
		RAND_add(&newentropy, nlen, nlen * 7.8);
a260 2
		int mib[2];
		size_t nlen;
d263 2
a264 11
		mib[0] = CTL_KERN;
		mib[1] = KERN_ARND;
		nlen = sizeof (uint32_t);
		sysctl(mib, 2, &newentropy, &nlen, &oldentropy,
		    sizeof (uint32_t));
		if (nlen == 0) {
			newentropy = arc4random_pushb(&oldentropy,
			    sizeof (uint32_t));
			nlen = 4;
		}
		RAND_add(&newentropy, nlen, nlen * 7.8);
a294 2
		int mib[2];
		size_t nlen;
d297 2
a298 11
		mib[0] = CTL_KERN;
		mib[1] = KERN_ARND;
		nlen = sizeof (uint32_t);
		sysctl(mib, 2, &newentropy, &nlen, &oldentropy,
		    sizeof (uint32_t));
		if (nlen == 0) {
			newentropy = arc4random_pushb(&oldentropy,
			    sizeof (uint32_t));
			nlen = 4;
		}
		RAND_add(&newentropy, nlen, nlen * 7.8);
a341 2
		int mib[2];
		size_t nlen;
d344 2
a345 11
		mib[0] = CTL_KERN;
		mib[1] = KERN_ARND;
		nlen = sizeof (uint32_t);
		sysctl(mib, 2, &newentropy, &nlen, &oldentropy,
		    sizeof (uint32_t));
		if (nlen == 0) {
			newentropy = arc4random_pushb(&oldentropy,
			    sizeof (uint32_t));
			nlen = 4;
		}
		RAND_add(&newentropy, nlen, nlen * 7.8);
@


1.3
log
@use the callback functions to push additional entropy into the OpenSSL-in-
ternal PRNG from (and, using arc4random_pushb(3), to) the BSD arcfour PRNG.
@
text
@a0 2
/* $MirOS: src/lib/libssl/src/apps/s_cb.c,v 1.2 2005/03/06 20:29:27 tg Exp $ */

d124 2
d135 1
a135 1
#ifdef HAVE_ARC4RANDOM
d137 16
a152 9
		uint32_t newentropy;

#ifdef HAVE_ARC4RANDOM_PUSHB
		RAND_bytes((u_char *)&newentropy, sizeof (newentropy));
		newentropy = arc4random_pushb(&newentropy, sizeof (newentropy));
#else
		newentropy = arc4random();
#endif
		RAND_add(&newentropy, sizeof (newentropy), 31.2);
d202 1
a202 1
#ifdef HAVE_ARC4RANDOM
d204 16
a219 9
		uint32_t newentropy;

#ifdef HAVE_ARC4RANDOM_PUSHB
		RAND_bytes((u_char *)&newentropy, sizeof (newentropy));
		newentropy = arc4random_pushb(&newentropy, sizeof (newentropy));
#else
		newentropy = arc4random();
#endif
		RAND_add(&newentropy, sizeof (newentropy), 31.2);
d280 1
a280 1
#ifdef HAVE_ARC4RANDOM
d282 16
a297 9
		uint32_t newentropy;

#ifdef HAVE_ARC4RANDOM_PUSHB
		RAND_bytes((u_char *)&newentropy, sizeof (newentropy));
		newentropy = arc4random_pushb(&newentropy, sizeof (newentropy));
#else
		newentropy = arc4random();
#endif
		RAND_add(&newentropy, sizeof (newentropy), 31.2);
d325 1
a325 1
#ifdef HAVE_ARC4RANDOM
d327 16
a342 9
		uint32_t newentropy;

#ifdef HAVE_ARC4RANDOM_PUSHB
		RAND_bytes((u_char *)&newentropy, sizeof (newentropy));
		newentropy = arc4random_pushb(&newentropy, sizeof (newentropy));
#else
		newentropy = arc4random();
#endif
		RAND_add(&newentropy, sizeof (newentropy), 31.2);
d383 1
a383 1
#ifdef HAVE_ARC4RANDOM
d385 16
a400 9
		uint32_t newentropy;

#ifdef HAVE_ARC4RANDOM_PUSHB
		RAND_bytes((u_char *)&newentropy, sizeof (newentropy));
		newentropy = arc4random_pushb(&newentropy, sizeof (newentropy));
#else
		newentropy = arc4random();
#endif
		RAND_add(&newentropy, sizeof (newentropy), 31.2);
@


1.2
log
@merge src/lib
@
text
@d1 1
a1 1
/* $MirOS$ */
d135 14
d195 13
d266 14
d304 14
d355 14
@


1.1
log
@Initial revision
@
text
@d1 2
d10 1
a10 1
 * 
d17 1
a17 1
 * 
d24 1
a24 1
 * 
d39 1
a39 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d42 1
a42 1
 * 
d54 1
a54 1
 * 
d68 1
a68 1
 *    notice, this list of conditions and the following disclaimer. 
d205 1
a205 1
		In theory this is no longer needed 
d221 2
a222 2
		
		
d244 2
a245 2
		BIO_printf(out,"read from %08X [%08lX] (%d bytes => %ld (0x%X))\n",
			bio,argp,argi,ret,ret);
d251 2
a252 2
		BIO_printf(out,"write to %08X [%08lX] (%d bytes => %ld (0x%X))\n",
			bio,argp,argi,ret,ret);
d299 1
a299 1
	
d331 1
a331 1
						
d396 1
a396 1
			
d484 1
a484 1
		
d533 1
a533 1
		
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@
