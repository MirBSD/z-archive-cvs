head	1.1;
branch	1.1.1;
access;
symbols
	cvs-200804031830:1.1.1.3
	MIRBSD_10:1.1.1.3.0.2
	MIRBSD_10_BASE:1.1.1.3
	cvs-200706161500:1.1.1.3
	cvs-200705171600:1.1.1.3
	OPENBSD_4_0:1.1.1.3
	MIRBSD_9_BASE:1.1.1.2
	MIRBSD_8:1.1.1.2.0.2
	MIRBSD_8_BASE:1.1.1.2
	cvs-200512060130:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2005.02.05.17.25.34;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.25.34;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.29.13.38.39;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.09.20.19.06.54;	author tg;	state Exp;
branches;
next	;
commitid	10045119150397FC669;


desc
@@


1.1
log
@Initial revision
@
text
@#!/bin/sh
#
# CA - wrapper around ca to make it easier to use ... basically ca requires
#      some setup stuff to be done before you can use it and this makes
#      things easier between now and when Eric is convinced to fix it :-)
#
# CA -newca ... will setup the right stuff
# CA -newreq ... will generate a certificate request 
# CA -sign ... will sign the generated request and output 
#
# At the end of that grab newreq.pem and newcert.pem (one has the key 
# and the other the certificate) and cat them together and that is what
# you want/need ... I'll make even this a little cleaner later.
#
#
# 12-Jan-96 tjh    Added more things ... including CA -signcert which
#                  converts a certificate to a request and then signs it.
# 10-Jan-96 eay    Fixed a few more bugs and added the SSLEAY_CONFIG
#		   environment variable so this can be driven from
#		   a script.
# 25-Jul-96 eay    Cleaned up filenames some more.
# 11-Jun-96 eay    Fixed a few filename missmatches.
# 03-May-96 eay    Modified to use 'ssleay cmd' instead of 'cmd'.
# 18-Apr-96 tjh    Original hacking
#
# Tim Hudson
# tjh@@cryptsoft.com
#

# default openssl.cnf file has setup as per the following
# demoCA ... where everything is stored

DAYS="-days 365"
REQ="openssl req $SSLEAY_CONFIG"
CA="openssl ca $SSLEAY_CONFIG"
VERIFY="openssl verify"
X509="openssl x509"

CATOP=./demoCA
CAKEY=./cakey.pem
CACERT=./cacert.pem

for i
do
case $i in
-\?|-h|-help)
    echo "usage: CA -newcert|-newreq|-newca|-sign|-verify" >&2
    exit 0
    ;;
-newcert) 
    # create a certificate
    $REQ -new -x509 -keyout newreq.pem -out newreq.pem $DAYS
    RET=$?
    echo "Certificate (and private key) is in newreq.pem"
    ;;
-newreq) 
    # create a certificate request
    $REQ -new -keyout newreq.pem -out newreq.pem $DAYS
    RET=$?
    echo "Request (and private key) is in newreq.pem"
    ;;
-newca)     
    # if explicitly asked for or it doesn't exist then setup the directory
    # structure that Eric likes to manage things 
    NEW="1"
    if [ "$NEW" -o ! -f ${CATOP}/serial ]; then
	# create the directory hierarchy
	mkdir ${CATOP} 
	mkdir ${CATOP}/certs 
	mkdir ${CATOP}/crl 
	mkdir ${CATOP}/newcerts
	mkdir ${CATOP}/private
	echo "01" > ${CATOP}/serial
	touch ${CATOP}/index.txt
    fi
    if [ ! -f ${CATOP}/private/$CAKEY ]; then
	echo "CA certificate filename (or enter to create)"
	read FILE

	# ask user for existing CA certificate
	if [ "$FILE" ]; then
	    cp $FILE ${CATOP}/private/$CAKEY
	    RET=$?
	else
	    echo "Making CA certificate ..."
	    $REQ -new -x509 -keyout ${CATOP}/private/$CAKEY \
			   -out ${CATOP}/$CACERT $DAYS
	    RET=$?
	fi
    fi
    ;;
-xsign)
    $CA -policy policy_anything -infiles newreq.pem 
    RET=$?
    ;;
-sign|-signreq) 
    $CA -policy policy_anything -out newcert.pem -infiles newreq.pem
    RET=$?
    cat newcert.pem
    echo "Signed certificate is in newcert.pem"
    ;;
-signcert) 
    echo "Cert passphrase will be requested twice - bug?"
    $X509 -x509toreq -in newreq.pem -signkey newreq.pem -out tmp.pem
    $CA -policy policy_anything -out newcert.pem -infiles tmp.pem
    cat newcert.pem
    echo "Signed certificate is in newcert.pem"
    ;;
-verify) 
    shift
    if [ -z "$1" ]; then
	    $VERIFY -CAfile $CATOP/$CACERT newcert.pem
	    RET=$?
    else
	for j
	do
	    $VERIFY -CAfile $CATOP/$CACERT $j
	    if [ $? != 0 ]; then
		    RET=$?
	    fi
	done
    fi
    exit 0
    ;;
*)
    echo "Unknown arg $i";
    exit 1
    ;;
esac
done
exit $RET

@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@sure enough they updated OpenSSL late
but thanks mates, so I need not do it myself
@
text
@a32 2
if [ -z "$OPENSSL" ]; then OPENSSL=openssl; fi

d34 4
a37 4
REQ="$OPENSSL req $SSLEAY_CONFIG"
CA="$OPENSSL ca $SSLEAY_CONFIG"
VERIFY="$OPENSSL verify"
X509="$OPENSSL x509"
@


1.1.1.3
log
@import a few security-wise relevant changes right now
@
text
@d54 1
a54 1
    $REQ -new -x509 -keyout newkey.pem -out newcert.pem $DAYS
d56 1
a56 1
    echo "Certificate is in newcert.pem, private key is in newkey.pem"
d60 1
a60 1
    $REQ -new -keyout newkey.pem -out newreq.pem $DAYS
d62 1
a62 1
    echo "Request is in newreq.pem, private key is in newkey.pem"
@


