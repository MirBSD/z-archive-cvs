head	1.2;
access;
symbols
	cvs-200804031830:1.1.1.2
	MIRBSD_10:1.1.1.2.0.4
	MIRBSD_10_BASE:1.1.1.2
	cvs-200706161500:1.1.1.2
	cvs-200705171600:1.1.1.2
	OPENBSD_4_0:1.1.1.2
	MIRBSD_9_BASE:1.1.1.2
	MIRBSD_8:1.1.1.2.0.2
	MIRBSD_8_BASE:1.1.1.2
	cvs-200512060130:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2014.11.30.00.23.24;	author tg;	state dead;
branches;
next	1.1;
commitid	100547A638E1B32DC52;

1.1
date	2005.02.05.17.26.00;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.26.00;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.26.14.54.14;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@â€¦ and for RIPEMD160
@
text
@RIPEMD-160
http://www.esat.kuleuven.ac.be/~bosselae/ripemd160.html

This is my implementation of RIPEMD-160.  The pentium assember is a little
off the pace since I only get 1050 cycles, while the best is 1013.
I have a few ideas for how to get another 20 or so cycles, but at
this point I will not bother right now.  I belive the trick will be
to remove my 'copy X array onto stack' until inside the RIP1() finctions the
first time round.  To do this I need another register and will only have one
temporary one.  A bit tricky....  I can also cleanup the saving of the 5 words
after the first half of the calculation.  I should read the origional
value, add then write.  Currently I just save the new and read the origioal.
I then read both at the end.  Bad.

eric (20-Jan-1998)
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@latest fixes from OpenBSD, last update for #8 if nothing weird happens
@
text
@d7 1
a7 1
this point I will not bother right now.  I believe the trick will be
@

