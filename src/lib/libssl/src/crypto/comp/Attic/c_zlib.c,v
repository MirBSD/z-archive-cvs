head	1.5;
access;
symbols
	cvs-200804031830:1.1.1.3
	MIRBSD_10:1.2.0.2
	MIRBSD_10_BASE:1.2
	cvs-200706161500:1.1.1.3
	cvs-200705171600:1.1.1.3
	OPENBSD_4_0:1.1.1.3
	MIRBSD_9_BASE:1.1.1.2
	MIRBSD_8:1.1.1.2.0.2
	MIRBSD_8_BASE:1.1.1.2
	cvs-200512060130:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2014.11.26.19.52.51;	author tg;	state dead;
branches;
next	1.4;
commitid	10054762FA77E4200D6;

1.4
date	2013.08.06.17.06.23;	author tg;	state Exp;
branches;
next	1.3;
commitid	10052012D144F7753C5;

1.3
date	2013.08.05.22.06.13;	author tg;	state Exp;
branches;
next	1.2;
commitid	100520021D16E80D23B;

1.2
date	2007.05.08.21.52.55;	author tg;	state Exp;
branches;
next	1.1;
commitid	1004640F14A456E3051;

1.1
date	2005.02.05.17.25.47;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.25.47;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.29.13.39.08;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.09.20.19.07.01;	author tg;	state Exp;
branches;
next	;
commitid	10045119150397FC669;


desc
@@


1.5
log
@drop compression
@
text
@#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/objects.h>
#include <openssl/comp.h>
#include <openssl/err.h>

COMP_METHOD *COMP_zlib(void );

static COMP_METHOD zlib_method_nozlib={
	NID_undef,
	"(undef)",
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	};

#ifndef ZLIB
#undef ZLIB_SHARED
#else

#include <zlib.h>

static int zlib_compress_block(COMP_CTX *ctx, unsigned char *out,
	unsigned int olen, unsigned char *in, unsigned int ilen);
static int zlib_expand_block(COMP_CTX *ctx, unsigned char *out,
	unsigned int olen, unsigned char *in, unsigned int ilen);

static int zz_uncompress(Bytef *dest, uLongf *destLen, const Bytef *source,
	uLong sourceLen);

static COMP_METHOD zlib_method={
	NID_zlib_compression,
	LN_zlib_compression,
	NULL,
	NULL,
	zlib_compress_block,
	zlib_expand_block,
	NULL,
	NULL,
	};

/* 
 * When OpenSSL is built on Windows, we do not want to require that
 * the ZLIB.DLL be available in order for the OpenSSL DLLs to
 * work.  Therefore, all ZLIB routines are loaded at run time
 * and we do not link to a .LIB file.
 */
#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_WIN32)
# include <windows.h>
#endif /* !(OPENSSL_SYS_WINDOWS || OPENSSL_SYS_WIN32) */

#ifdef ZLIB_SHARED
#include <openssl/dso.h>

/* Function pointers */
typedef int (*compress_ft)(Bytef *dest,uLongf *destLen,
	const Bytef *source, uLong sourceLen);
typedef int (*inflateEnd_ft)(z_streamp strm);
typedef int (*inflate_ft)(z_streamp strm, int flush);
typedef int (*inflateInit__ft)(z_streamp strm,
	const char * version, int stream_size);
static compress_ft	p_compress=NULL;
static inflateEnd_ft	p_inflateEnd=NULL;
static inflate_ft	p_inflate=NULL;
static inflateInit__ft	p_inflateInit_=NULL;

static int zlib_loaded = 0;     /* only attempt to init func pts once */
static DSO *zlib_dso = NULL;

#define compress                p_compress
#define inflateEnd              p_inflateEnd
#define inflate                 p_inflate
#define inflateInit_            p_inflateInit_
#endif /* ZLIB_SHARED */

static int zlib_compress_block(COMP_CTX *ctx, unsigned char *out,
	     unsigned int olen, unsigned char *in, unsigned int ilen)
	{
	unsigned long l;
	int i;
	int clear=1;

	if (ilen > 128)
		{
		out[0]=1;
		l=olen-1;
		i=compress(&(out[1]),&l,in,(unsigned long)ilen);
		if (i != Z_OK)
			return(-1);
		if (ilen > l)
			{
			clear=0;
			l++;
			}
		}
	if (clear)
		{
		out[0]=0;
		memcpy(&(out[1]),in,ilen);
		l=ilen+1;
		}
#ifdef DEBUG_ZLIB
	fprintf(stderr,"compress(%4d)->%4d %s\n",
		ilen,(int)l,(clear)?"clear":"zlib");
#endif
	return((int)l);
	}

static int zlib_expand_block(COMP_CTX *ctx, unsigned char *out,
	     unsigned int olen, unsigned char *in, unsigned int ilen)
	{
	unsigned long l;
	int i;

	if (in[0])
		{
		l=olen;
		i=zz_uncompress(out,&l,&(in[1]),(unsigned long)ilen-1);
		if (i != Z_OK)
			return(-1);
		}
	else
		{
		memcpy(out,&(in[1]),ilen-1);
		l=ilen-1;
		}
#ifdef DEBUG_ZLIB
        fprintf(stderr,"expand  (%4d)->%4d %s\n",
		ilen,(int)l,in[0]?"zlib":"clear");
#endif
	return((int)l);
	}

static int zz_uncompress (Bytef *dest, uLongf *destLen, const Bytef *source,
	     uLong sourceLen)
{
    z_stream stream;
    int err;

    stream.next_in = (Bytef*)source;
    stream.avail_in = (uInt)sourceLen;
    /* Check for source > 64K on 16-bit machine: */
    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;

    stream.next_out = dest;
    stream.avail_out = (uInt)*destLen;
    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;

    stream.zalloc = (alloc_func)0;
    stream.zfree = (free_func)0;

    err = inflateInit(&stream);
    if (err != Z_OK) return err;

    err = inflate(&stream, Z_FINISH);
    if (err != Z_STREAM_END) {
        inflateEnd(&stream);
        return err;
    }
    *destLen = stream.total_out;

    err = inflateEnd(&stream);
    return err;
}

#endif

COMP_METHOD *COMP_zlib(void)
	{
	COMP_METHOD *meth = &zlib_method_nozlib;

#ifdef ZLIB_SHARED
	if (!zlib_loaded)
		{
#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_WIN32)
		zlib_dso = DSO_load(NULL, "ZLIB1", NULL, 0);
#else
		zlib_dso = DSO_load(NULL, "z", NULL, 0);
#endif
		if (zlib_dso != NULL)
			{
			p_compress
				= (compress_ft) DSO_bind_func(zlib_dso,
					"compress");
			p_inflateEnd
				= (inflateEnd_ft) DSO_bind_func(zlib_dso,
					"inflateEnd");
			p_inflate
				= (inflate_ft) DSO_bind_func(zlib_dso,
					"inflate");
			p_inflateInit_
				= (inflateInit__ft) DSO_bind_func(zlib_dso,
					"inflateInit_");

			if (p_compress && p_inflateEnd && p_inflate
				&& p_inflateInit_)
				zlib_loaded++;
			}
		}

#endif
#ifdef ZLIB_SHARED
	if (zlib_loaded)
#endif
#if defined(ZLIB) || defined(ZLIB_SHARED)
		meth = &zlib_method;
#endif

	return(meth);
	}

@


1.4
log
@get rid of the now useless ZLIB_CONST
@
text
@@


1.3
log
@-DZCONST=const â†’ -DZLIB_CONST

XXX sys/conf/Makefile.inc does it twice?
@
text
@a24 1
#define ZLIB_CONST
@


1.2
log
@ZCONST
@
text
@d25 1
a25 1
#define ZCONST const
@


1.1
log
@Initial revision
@
text
@d6 1
d25 1
a54 5

# define Z_CALLCONV _stdcall
# define ZLIB_SHARED
#else
# define Z_CALLCONV
a59 8
/* Prototypes for built in stubs */
static int stub_compress(Bytef *dest,uLongf *destLen,
	const Bytef *source, uLong sourceLen);
static int stub_inflateEnd(z_streamp strm);
static int stub_inflate(z_streamp strm, int flush);
static int stub_inflateInit_(z_streamp strm, const char * version,
	int stream_size);

d61 1
a61 1
typedef int (Z_CALLCONV *compress_ft)(Bytef *dest,uLongf *destLen,
d63 3
a65 3
typedef int (Z_CALLCONV *inflateEnd_ft)(z_streamp strm);
typedef int (Z_CALLCONV *inflate_ft)(z_streamp strm, int flush);
typedef int (Z_CALLCONV *inflateInit__ft)(z_streamp strm,
d75 4
a78 4
#define compress                stub_compress
#define inflateEnd              stub_inflateEnd
#define inflate                 stub_inflate
#define inflateInit_            stub_inflateInit_
d181 1
a181 1
		zlib_dso = DSO_load(NULL, "ZLIB", NULL, 0);
d199 4
a202 1
			zlib_loaded++;
d207 3
d211 1
a211 1
	meth = &zlib_method;
a216 39
#ifdef ZLIB_SHARED
/* Stubs for each function to be dynamicly loaded */
static int 
stub_compress(Bytef *dest,uLongf *destLen,const Bytef *source, uLong sourceLen)
	{
	if (p_compress)
		return(p_compress(dest,destLen,source,sourceLen));
	else
		return(Z_MEM_ERROR);
	}

static int
stub_inflateEnd(z_streamp strm)
	{
	if ( p_inflateEnd )
		return(p_inflateEnd(strm));
	else
		return(Z_MEM_ERROR);
	}

static int
stub_inflate(z_streamp strm, int flush)
	{
	if ( p_inflate )
		return(p_inflate(strm,flush));
	else
		return(Z_MEM_ERROR);
	}

static int
stub_inflateInit_(z_streamp strm, const char * version, int stream_size)
	{
	if ( p_inflateInit_ )
		return(p_inflateInit_(strm,version,stream_size));
	else
		return(Z_MEM_ERROR);
	}

#endif /* ZLIB_SHARED */
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@sure enough they updated OpenSSL late
but thanks mates, so I need not do it myself
@
text
@a5 1
#include <openssl/err.h>
d192 1
a192 11
		zlib_dso = DSO_load(NULL, "ZLIB1", NULL, 0);
		if (!zlib_dso)
			{
			zlib_dso = DSO_load(NULL, "ZLIB", NULL, 0);
			if (zlib_dso)
				{
				/* Clear the errors from the first failed
				   DSO_load() */
				ERR_clear_error();
				}
			}
@


1.1.1.3
log
@import a few security-wise relevant changes right now
@
text
@d54 5
d64 8
d73 1
a73 1
typedef int (*compress_ft)(Bytef *dest,uLongf *destLen,
d75 3
a77 3
typedef int (*inflateEnd_ft)(z_streamp strm);
typedef int (*inflate_ft)(z_streamp strm, int flush);
typedef int (*inflateInit__ft)(z_streamp strm,
d87 4
a90 4
#define compress                p_compress
#define inflateEnd              p_inflateEnd
#define inflate                 p_inflate
#define inflateInit_            p_inflateInit_
d194 10
d221 1
a221 4

			if (p_compress && p_inflateEnd && p_inflate
				&& p_inflateInit_)
				zlib_loaded++;
a225 3
#ifdef ZLIB_SHARED
	if (zlib_loaded)
#endif
d227 1
a227 1
		meth = &zlib_method;
d233 39
@


