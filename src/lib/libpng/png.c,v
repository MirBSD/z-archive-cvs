head	1.13;
access;
symbols
	png-1_2_57:1.1.107.10
	png-1_2_50:1.1.107.9
	png-1_2_35:1.1.107.8
	png-1_2_32:1.1.107.7
	png-1_2_26:1.1.107.6
	png-1_2_25:1.1.107.5
	MIRBSD_10:1.7.0.2
	MIRBSD_10_BASE:1.7
	png-1_2_18:1.1.107.4
	png-1_2_12:1.1.107.3
	MIRBSD_9_BASE:1.5
	png-1_2_10:1.1.107.2
	MIRBSD_8:1.3.0.2
	MIRBSD_8_BASE:1.3
	png-1_2_8:1.1.107.1
	libpng:1.1.107;
locks; strict;
comment	@ * @;


1.13
date	2017.04.15.15.26.46;	author tg;	state Exp;
branches;
next	1.12;
commitid	10058F23BCC5ED04858;

1.12
date	2013.08.06.18.49.27;	author tg;	state Exp;
branches;
next	1.11;
commitid	1005201454765C5CF06;

1.11
date	2009.03.15.20.08.44;	author tg;	state Exp;
branches;
next	1.10;
commitid	10049BD605834002F74;

1.10
date	2008.10.22.19.11.49;	author tg;	state Exp;
branches;
next	1.9;
commitid	10048FF7AEF54F9B169;

1.9
date	2008.04.07.19.54.33;	author tg;	state Exp;
branches;
next	1.8;
commitid	10047FA7C0D12C807EE;

1.8
date	2008.03.23.17.54.53;	author tg;	state Exp;
branches;
next	1.7;
commitid	10047E6997C6BB35CA9;

1.7
date	2007.05.22.20.46.17;	author tg;	state Exp;
branches;
next	1.6;
commitid	100465356AC5C1E9A9B;

1.6
date	2006.06.29.17.14.23;	author tg;	state Exp;
branches;
next	1.5;
commitid	10044A40A7D396C3456;

1.5
date	2006.06.09.00.34.46;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004488C2360A50620C;

1.4
date	2006.06.09.00.30.27;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004488C1225295157F;

1.3
date	2005.12.17.05.46.17;	author tg;	state Exp;
branches;
next	1.2;
commitid	10043A3A3E65E20A413;

1.2
date	2005.03.06.20.29.15;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.06.15.16.18;	author tg;	state Exp;
branches
	1.1.107.1;
next	;

1.1.107.1
date	2005.03.06.15.16.18;	author tg;	state Exp;
branches;
next	1.1.107.2;

1.1.107.2
date	2006.06.09.00.13.04;	author tg;	state Exp;
branches;
next	1.1.107.3;
commitid	1004488BD054F510AF1;

1.1.107.3
date	2006.06.29.17.08.58;	author tg;	state Exp;
branches;
next	1.1.107.4;
commitid	10044A409367518C911;

1.1.107.4
date	2007.05.22.20.25.37;	author tg;	state Exp;
branches;
next	1.1.107.5;
commitid	100465351CF4103214A;

1.1.107.5
date	2008.03.23.17.15.17;	author tg;	state Exp;
branches;
next	1.1.107.6;
commitid	10047E69020419198D8;

1.1.107.6
date	2008.04.07.19.51.02;	author tg;	state Exp;
branches;
next	1.1.107.7;
commitid	10047FA7B332B97228B;

1.1.107.7
date	2008.10.22.18.55.39;	author tg;	state Exp;
branches;
next	1.1.107.8;
commitid	10048FF773834003AB5;

1.1.107.8
date	2009.03.15.19.57.25;	author tg;	state Exp;
branches;
next	1.1.107.9;
commitid	10049BD5DB90DBE42DE;

1.1.107.9
date	2013.08.06.17.35.04;	author tg;	state Exp;
branches;
next	1.1.107.10;
commitid	100520133D730551D16;

1.1.107.10
date	2017.04.15.15.00.14;	author tg;	state Exp;
branches;
next	;
commitid	10058F2359276DB0E16;


desc
@@


1.13
log
@a rather slow fastmergeâ€¦
@
text
@#include <sys/cdefs.h>
__RCSID("$MirOS: src/lib/libpng/png.c,v 1.12 2013/08/06 18:49:27 tg Exp $");

/* png.c - location for general purpose libpng functions
 *
 * Last changed in libpng 1.2.57 [December 29, 2016]
 * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 */

#define PNG_INTERNAL
#define PNG_NO_EXTERN
#define PNG_NO_PEDANTIC_WARNINGS
#include "png.h"

/* Generate a compiler error if there is an old png.h in the search path. */
typedef version_1_2_57 Your_png_h_is_not_version_1_2_57;

/* Version information for C files.  This had better match the version
 * string defined in png.h.
 */

#ifdef PNG_USE_GLOBAL_ARRAYS
/* png_libpng_ver was changed to a function in version 1.0.5c */
PNG_CONST char png_libpng_ver[18] = PNG_LIBPNG_VER_STRING;

#ifdef PNG_READ_SUPPORTED

/* png_sig was changed to a function in version 1.0.5c */
/* Place to hold the signature string for a PNG file. */
PNG_CONST png_byte FARDATA png_sig[8] = {137, 80, 78, 71, 13, 10, 26, 10};
#endif /* PNG_READ_SUPPORTED */

/* Invoke global declarations for constant strings for known chunk types */
PNG_IHDR;
PNG_IDAT;
PNG_IEND;
PNG_PLTE;
PNG_bKGD;
PNG_cHRM;
PNG_gAMA;
PNG_hIST;
PNG_iCCP;
PNG_iTXt;
PNG_oFFs;
PNG_pCAL;
PNG_sCAL;
PNG_pHYs;
PNG_sBIT;
PNG_sPLT;
PNG_sRGB;
PNG_tEXt;
PNG_tIME;
PNG_tRNS;
PNG_zTXt;

#ifdef PNG_READ_SUPPORTED
/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */

/* Start of interlace block */
PNG_CONST int FARDATA png_pass_start[] = {0, 4, 0, 2, 0, 1, 0};

/* Offset to next interlace block */
PNG_CONST int FARDATA png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1};

/* Start of interlace block in the y direction */
PNG_CONST int FARDATA png_pass_ystart[] = {0, 0, 4, 0, 2, 0, 1};

/* Offset to next interlace block in the y direction */
PNG_CONST int FARDATA png_pass_yinc[] = {8, 8, 8, 4, 4, 2, 2};

/* Height of interlace block.  This is not currently used - if you need
 * it, uncomment it here and in png.h
PNG_CONST int FARDATA png_pass_height[] = {8, 8, 4, 4, 2, 2, 1};
*/

/* Mask to determine which pixels are valid in a pass */
PNG_CONST int FARDATA png_pass_mask[] =
    {0x80, 0x08, 0x88, 0x22, 0xaa, 0x55, 0xff};

/* Mask to determine which pixels to overwrite while displaying */
PNG_CONST int FARDATA png_pass_dsp_mask[]
   = {0xff, 0x0f, 0xff, 0x33, 0xff, 0x55, 0xff};

#endif /* PNG_READ_SUPPORTED */
#endif /* PNG_USE_GLOBAL_ARRAYS */

/* Tells libpng that we have already handled the first "num_bytes" bytes
 * of the PNG file signature.  If the PNG data is embedded into another
 * stream we can set num_bytes = 8 so that libpng will not attempt to read
 * or write any of the magic bytes before it starts on the IHDR.
 */

#ifdef PNG_READ_SUPPORTED
void PNGAPI
png_set_sig_bytes(png_structp png_ptr, int num_bytes)
{
   png_debug(1, "in png_set_sig_bytes");

   if (png_ptr == NULL)
      return;

   if (num_bytes > 8)
      png_error(png_ptr, "Too many bytes for PNG signature.");

   png_ptr->sig_bytes = (png_byte)(num_bytes < 0 ? 0 : num_bytes);
}

/* Checks whether the supplied bytes match the PNG signature.  We allow
 * checking less than the full 8-byte signature so that those apps that
 * already read the first few bytes of a file to determine the file type
 * can simply check the remaining bytes for extra assurance.  Returns
 * an integer less than, equal to, or greater than zero if sig is found,
 * respectively, to be less than, to match, or be greater than the correct
 * PNG signature (this is the same behaviour as strcmp, memcmp, etc).
 */
int PNGAPI
png_sig_cmp(png_bytep sig, png_size_t start, png_size_t num_to_check)
{
   png_byte png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};
   if (num_to_check > 8)
      num_to_check = 8;
   else if (num_to_check < 1)
      return (-1);

   if (start > 7)
      return (-1);

   if (start + num_to_check > 8)
      num_to_check = 8 - start;

   return ((int)(png_memcmp(&sig[start], &png_signature[start], num_to_check)));
}

#if defined(PNG_1_0_X) || defined(PNG_1_2_X)
/* (Obsolete) function to check signature bytes.  It does not allow one
 * to check a partial signature.  This function might be removed in the
 * future - use png_sig_cmp().  Returns true (nonzero) if the file is PNG.
 */
int PNGAPI
png_check_sig(png_bytep sig, int num)
{
  return ((int)!png_sig_cmp(sig, (png_size_t)0, (png_size_t)num));
}
#endif
#endif /* PNG_READ_SUPPORTED */

#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
/* Function to allocate memory for zlib and clear it to 0. */
#ifdef PNG_1_0_X
voidpf PNGAPI
#else
voidpf /* PRIVATE */
#endif
png_zalloc(voidpf png_ptr, uInt items, uInt size)
{
   png_voidp ptr;
   png_structp p;
   png_uint_32 save_flags;
   png_uint_32 num_bytes;

   if (png_ptr == NULL)
      return (NULL);

   p=(png_structp)png_ptr;
   save_flags=p->flags;

   if (items > PNG_UINT_32_MAX/size)
   {
     png_warning (p, "Potential overflow in png_zalloc()");
     return (NULL);
   }
   num_bytes = (png_uint_32)items * size;

   p->flags|=PNG_FLAG_MALLOC_NULL_MEM_OK;
   ptr = (png_voidp)png_malloc((png_structp)png_ptr, num_bytes);
   p->flags=save_flags;

#if defined(PNG_1_0_X) && !defined(PNG_NO_ZALLOC_ZERO)
   if (ptr == NULL)
       return ((voidpf)ptr);

   if (num_bytes > (png_uint_32)0x8000L)
   {
      png_memset(ptr, 0, (png_size_t)0x8000L);
      png_memset((png_bytep)ptr + (png_size_t)0x8000L, 0,
         (png_size_t)(num_bytes - (png_uint_32)0x8000L));
   }
   else
   {
      png_memset(ptr, 0, (png_size_t)num_bytes);
   }
#endif
   return ((voidpf)ptr);
}

/* Function to free memory for zlib */
#ifdef PNG_1_0_X
void PNGAPI
#else
void /* PRIVATE */
#endif
png_zfree(voidpf png_ptr, voidpf ptr)
{
   png_free((png_structp)png_ptr, (png_voidp)ptr);
}

/* Reset the CRC variable to 32 bits of 1's.  Care must be taken
 * in case CRC is > 32 bits to leave the top bits 0.
 */
void /* PRIVATE */
png_reset_crc(png_structp png_ptr)
{
   png_ptr->crc = crc32(0, Z_NULL, 0);
}

/* Calculate the CRC over a section of data.  We can only pass as
 * much data to this routine as the largest single buffer size.  We
 * also check that this data will actually be used before going to the
 * trouble of calculating it.
 */
void /* PRIVATE */
png_calculate_crc(png_structp png_ptr, png_bytep ptr, png_size_t length)
{
   int need_crc = 1;

   if (png_ptr->chunk_name[0] & 0x20)                     /* ancillary */
   {
      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==
          (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))
         need_crc = 0;
   }
   else                                                    /* critical */
   {
      if (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE)
         need_crc = 0;
   }

   if (need_crc)
      png_ptr->crc = crc32(png_ptr->crc, ptr, (uInt)length);
}

/* Allocate the memory for an info_struct for the application.  We don't
 * really need the png_ptr, but it could potentially be useful in the
 * future.  This should be used in favour of malloc(png_sizeof(png_info))
 * and png_info_init() so that applications that want to use a shared
 * libpng don't have to be recompiled if png_info changes size.
 */
png_infop PNGAPI
png_create_info_struct(png_structp png_ptr)
{
   png_infop info_ptr;

   png_debug(1, "in png_create_info_struct");

   if (png_ptr == NULL)
      return (NULL);

#ifdef PNG_USER_MEM_SUPPORTED
   info_ptr = (png_infop)png_create_struct_2(PNG_STRUCT_INFO,
      png_ptr->malloc_fn, png_ptr->mem_ptr);
#else
   info_ptr = (png_infop)png_create_struct(PNG_STRUCT_INFO);
#endif
   if (info_ptr != NULL)
      png_info_init_3(&info_ptr, png_sizeof(png_info));

   return (info_ptr);
}

/* This function frees the memory associated with a single info struct.
 * Normally, one would use either png_destroy_read_struct() or
 * png_destroy_write_struct() to free an info struct, but this may be
 * useful for some applications.
 */
void PNGAPI
png_destroy_info_struct(png_structp png_ptr, png_infopp info_ptr_ptr)
{
   png_infop info_ptr = NULL;

   png_debug(1, "in png_destroy_info_struct");

   if (png_ptr == NULL)
      return;

   if (info_ptr_ptr != NULL)
      info_ptr = *info_ptr_ptr;

   if (info_ptr != NULL)
   {
      png_info_destroy(png_ptr, info_ptr);

#ifdef PNG_USER_MEM_SUPPORTED
      png_destroy_struct_2((png_voidp)info_ptr, png_ptr->free_fn,
          png_ptr->mem_ptr);
#else
      png_destroy_struct((png_voidp)info_ptr);
#endif
      *info_ptr_ptr = NULL;
   }
}

/* Initialize the info structure.  This is now an internal function (0.89)
 * and applications using it are urged to use png_create_info_struct()
 * instead.
 */
#if defined(PNG_1_0_X) || defined(PNG_1_2_X)
#undef png_info_init
void PNGAPI
png_info_init(png_infop info_ptr)
{
   /* We only come here via pre-1.0.12-compiled applications */
   png_info_init_3(&info_ptr, 0);
}
#endif

void PNGAPI
png_info_init_3(png_infopp ptr_ptr, png_size_t png_info_struct_size)
{
   png_infop info_ptr = *ptr_ptr;

   png_debug(1, "in png_info_init_3");

   if (info_ptr == NULL)
      return;

   if (png_sizeof(png_info) > png_info_struct_size)
   {
      png_destroy_struct(info_ptr);
      info_ptr = (png_infop)png_create_struct(PNG_STRUCT_INFO);
      *ptr_ptr = info_ptr;
      if (info_ptr == NULL)
         return;
   }

   /* Set everything to 0 */
   png_memset(info_ptr, 0, png_sizeof(png_info));
}

#ifdef PNG_FREE_ME_SUPPORTED
void PNGAPI
png_data_freer(png_structp png_ptr, png_infop info_ptr,
   int freer, png_uint_32 mask)
{
   png_debug(1, "in png_data_freer");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   if (freer == PNG_DESTROY_WILL_FREE_DATA)
      info_ptr->free_me |= mask;
   else if (freer == PNG_USER_WILL_FREE_DATA)
      info_ptr->free_me &= ~mask;
   else
      png_warning(png_ptr,
         "Unknown freer parameter in png_data_freer.");
}
#endif

void PNGAPI
png_free_data(png_structp png_ptr, png_infop info_ptr, png_uint_32 mask,
   int num)
{
   png_debug(1, "in png_free_data");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

#ifdef PNG_TEXT_SUPPORTED
   /* Free text item num or (if num == -1) all text items */
#ifdef PNG_FREE_ME_SUPPORTED
   if ((mask & PNG_FREE_TEXT) & info_ptr->free_me)
#else
   if (mask & PNG_FREE_TEXT)
#endif
   {
      if (num != -1)
      {
         if (info_ptr->text && info_ptr->text[num].key)
         {
            png_free(png_ptr, info_ptr->text[num].key);
            info_ptr->text[num].key = NULL;
         }
      }
      else
      {
         int i;
         for (i = 0; i < info_ptr->num_text; i++)
             png_free_data(png_ptr, info_ptr, PNG_FREE_TEXT, i);
         png_free(png_ptr, info_ptr->text);
         info_ptr->text = NULL;
         info_ptr->num_text=0;
         info_ptr->max_text=0;
      }
   }
#endif

#ifdef PNG_tRNS_SUPPORTED
   /* Free any tRNS entry */
#ifdef PNG_FREE_ME_SUPPORTED
   if ((mask & PNG_FREE_TRNS) & info_ptr->free_me)
#else
   if ((mask & PNG_FREE_TRNS) && (png_ptr->flags & PNG_FLAG_FREE_TRNS))
#endif
   {
      png_free(png_ptr, info_ptr->trans);
      info_ptr->trans = NULL;
      info_ptr->valid &= ~PNG_INFO_tRNS;
#ifndef PNG_FREE_ME_SUPPORTED
      png_ptr->flags &= ~PNG_FLAG_FREE_TRNS;
#endif
   }
#endif

#ifdef PNG_sCAL_SUPPORTED
   /* Free any sCAL entry */
#ifdef PNG_FREE_ME_SUPPORTED
   if ((mask & PNG_FREE_SCAL) & info_ptr->free_me)
#else
   if (mask & PNG_FREE_SCAL)
#endif
   {
#if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)
      png_free(png_ptr, info_ptr->scal_s_width);
      png_free(png_ptr, info_ptr->scal_s_height);
      info_ptr->scal_s_width = NULL;
      info_ptr->scal_s_height = NULL;
#endif
      info_ptr->valid &= ~PNG_INFO_sCAL;
   }
#endif

#ifdef PNG_pCAL_SUPPORTED
   /* Free any pCAL entry */
#ifdef PNG_FREE_ME_SUPPORTED
   if ((mask & PNG_FREE_PCAL) & info_ptr->free_me)
#else
   if (mask & PNG_FREE_PCAL)
#endif
   {
      png_free(png_ptr, info_ptr->pcal_purpose);
      png_free(png_ptr, info_ptr->pcal_units);
      info_ptr->pcal_purpose = NULL;
      info_ptr->pcal_units = NULL;
      if (info_ptr->pcal_params != NULL)
         {
            int i;
            for (i = 0; i < (int)info_ptr->pcal_nparams; i++)
            {
               png_free(png_ptr, info_ptr->pcal_params[i]);
               info_ptr->pcal_params[i] = NULL;
            }
            png_free(png_ptr, info_ptr->pcal_params);
            info_ptr->pcal_params = NULL;
         }
      info_ptr->valid &= ~PNG_INFO_pCAL;
   }
#endif

#ifdef PNG_iCCP_SUPPORTED
   /* Free any iCCP entry */
#ifdef PNG_FREE_ME_SUPPORTED
   if ((mask & PNG_FREE_ICCP) & info_ptr->free_me)
#else
   if (mask & PNG_FREE_ICCP)
#endif
   {
      png_free(png_ptr, info_ptr->iccp_name);
      png_free(png_ptr, info_ptr->iccp_profile);
      info_ptr->iccp_name = NULL;
      info_ptr->iccp_profile = NULL;
      info_ptr->valid &= ~PNG_INFO_iCCP;
   }
#endif

#ifdef PNG_sPLT_SUPPORTED
   /* Free a given sPLT entry, or (if num == -1) all sPLT entries */
#ifdef PNG_FREE_ME_SUPPORTED
   if ((mask & PNG_FREE_SPLT) & info_ptr->free_me)
#else
   if (mask & PNG_FREE_SPLT)
#endif
   {
      if (num != -1)
      {
         if (info_ptr->splt_palettes)
         {
            png_free(png_ptr, info_ptr->splt_palettes[num].name);
            png_free(png_ptr, info_ptr->splt_palettes[num].entries);
            info_ptr->splt_palettes[num].name = NULL;
            info_ptr->splt_palettes[num].entries = NULL;
         }
      }
      else
      {
         if (info_ptr->splt_palettes_num)
         {
            int i;
            for (i = 0; i < (int)info_ptr->splt_palettes_num; i++)
               png_free_data(png_ptr, info_ptr, PNG_FREE_SPLT, i);

            png_free(png_ptr, info_ptr->splt_palettes);
            info_ptr->splt_palettes = NULL;
            info_ptr->splt_palettes_num = 0;
         }
         info_ptr->valid &= ~PNG_INFO_sPLT;
      }
   }
#endif

#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED
   if (png_ptr->unknown_chunk.data)
   {
      png_free(png_ptr, png_ptr->unknown_chunk.data);
      png_ptr->unknown_chunk.data = NULL;
   }

#ifdef PNG_FREE_ME_SUPPORTED
   if ((mask & PNG_FREE_UNKN) & info_ptr->free_me)
#else
   if (mask & PNG_FREE_UNKN)
#endif
   {
      if (num != -1)
      {
          if (info_ptr->unknown_chunks)
          {
             png_free(png_ptr, info_ptr->unknown_chunks[num].data);
             info_ptr->unknown_chunks[num].data = NULL;
          }
      }
      else
      {
         int i;

         if (info_ptr->unknown_chunks_num)
         {
            for (i = 0; i < (int)info_ptr->unknown_chunks_num; i++)
               png_free_data(png_ptr, info_ptr, PNG_FREE_UNKN, i);

            png_free(png_ptr, info_ptr->unknown_chunks);
            info_ptr->unknown_chunks = NULL;
            info_ptr->unknown_chunks_num = 0;
         }
      }
   }
#endif

#ifdef PNG_hIST_SUPPORTED
   /* Free any hIST entry */
#ifdef PNG_FREE_ME_SUPPORTED
   if ((mask & PNG_FREE_HIST)  & info_ptr->free_me)
#else
   if ((mask & PNG_FREE_HIST) && (png_ptr->flags & PNG_FLAG_FREE_HIST))
#endif
   {
      png_free(png_ptr, info_ptr->hist);
      info_ptr->hist = NULL;
      info_ptr->valid &= ~PNG_INFO_hIST;
#ifndef PNG_FREE_ME_SUPPORTED
      png_ptr->flags &= ~PNG_FLAG_FREE_HIST;
#endif
   }
#endif

   /* Free any PLTE entry that was internally allocated */
#ifdef PNG_FREE_ME_SUPPORTED
   if ((mask & PNG_FREE_PLTE) & info_ptr->free_me)
#else
   if ((mask & PNG_FREE_PLTE) && (png_ptr->flags & PNG_FLAG_FREE_PLTE))
#endif
   {
      png_zfree(png_ptr, info_ptr->palette);
      info_ptr->palette = NULL;
      info_ptr->valid &= ~PNG_INFO_PLTE;
#ifndef PNG_FREE_ME_SUPPORTED
      png_ptr->flags &= ~PNG_FLAG_FREE_PLTE;
#endif
      info_ptr->num_palette = 0;
   }

#ifdef PNG_INFO_IMAGE_SUPPORTED
   /* Free any image bits attached to the info structure */
#ifdef PNG_FREE_ME_SUPPORTED
   if ((mask & PNG_FREE_ROWS) & info_ptr->free_me)
#else
   if (mask & PNG_FREE_ROWS)
#endif
   {
      if (info_ptr->row_pointers)
      {
         int row;
         for (row = 0; row < (int)info_ptr->height; row++)
         {
            png_free(png_ptr, info_ptr->row_pointers[row]);
            info_ptr->row_pointers[row] = NULL;
         }
         png_free(png_ptr, info_ptr->row_pointers);
         info_ptr->row_pointers = NULL;
      }
      info_ptr->valid &= ~PNG_INFO_IDAT;
   }
#endif

#ifdef PNG_FREE_ME_SUPPORTED
   if (num == -1)
      info_ptr->free_me &= ~mask;
   else
      info_ptr->free_me &= ~(mask & ~PNG_FREE_MUL);
#endif
}

/* This is an internal routine to free any memory that the info struct is
 * pointing to before re-using it or freeing the struct itself.  Recall
 * that png_free() checks for NULL pointers for us.
 */
void /* PRIVATE */
png_info_destroy(png_structp png_ptr, png_infop info_ptr)
{
   png_debug(1, "in png_info_destroy");

   png_free_data(png_ptr, info_ptr, PNG_FREE_ALL, -1);

#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
   if (png_ptr->num_chunk_list)
   {
      png_free(png_ptr, png_ptr->chunk_list);
      png_ptr->chunk_list = NULL;
      png_ptr->num_chunk_list = 0;
   }
#endif

   png_info_init_3(&info_ptr, png_sizeof(png_info));
}
#endif /* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */

/* This function returns a pointer to the io_ptr associated with the user
 * functions.  The application should free any memory associated with this
 * pointer before png_write_destroy() or png_read_destroy() are called.
 */
png_voidp PNGAPI
png_get_io_ptr(png_structp png_ptr)
{
   if (png_ptr == NULL)
      return (NULL);
   return (png_ptr->io_ptr);
}

#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
#ifdef PNG_STDIO_SUPPORTED
/* Initialize the default input/output functions for the PNG file.  If you
 * use your own read or write routines, you can call either png_set_read_fn()
 * or png_set_write_fn() instead of png_init_io().  If you have defined
 * PNG_NO_STDIO, you must use a function of your own because "FILE *" isn't
 * necessarily available.
 */
void PNGAPI
png_init_io(png_structp png_ptr, png_FILE_p fp)
{
   png_debug(1, "in png_init_io");

   if (png_ptr == NULL)
      return;

   png_ptr->io_ptr = (png_voidp)fp;
}
#endif

#ifdef PNG_TIME_RFC1123_SUPPORTED
/* Convert the supplied time into an RFC 1123 string suitable for use in
 * a "Creation Time" or other text-based time string.
 */
png_charp PNGAPI
png_convert_to_rfc1123(png_structp png_ptr, png_timep ptime)
{
   static PNG_CONST char short_months[12][4] =
        {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
         "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};

   if (png_ptr == NULL)
      return (NULL);

   if (png_ptr->time_buffer == NULL)
   {
      png_ptr->time_buffer = (png_charp)png_malloc(png_ptr, (png_uint_32)(29*
         png_sizeof(char)));
   }

#ifdef _WIN32_WCE
   {
      wchar_t time_buf[29];
      wsprintf(time_buf, TEXT("%d %S %d %02d:%02d:%02d +0000"),
          ptime->day % 32, short_months[(ptime->month - 1U) % 12],
        ptime->year, ptime->hour % 24, ptime->minute % 60,
          ptime->second % 61);
      WideCharToMultiByte(CP_ACP, 0, time_buf, -1, png_ptr->time_buffer,
          29, NULL, NULL);
   }
#else
#ifdef USE_FAR_KEYWORD
   {
      char near_time_buf[29];
      png_snprintf6(near_time_buf, 29, "%d %s %d %02d:%02d:%02d +0000",
          ptime->day % 32, short_months[(ptime->month - 1U) % 12],
          ptime->year, ptime->hour % 24, ptime->minute % 60,
          ptime->second % 61);
      png_memcpy(png_ptr->time_buffer, near_time_buf,
          29*png_sizeof(char));
   }
#else
   png_snprintf6(png_ptr->time_buffer, 29, "%d %s %d %02d:%02d:%02d +0000",
       ptime->day % 32, short_months[(ptime->month - 1U) % 12],
       ptime->year, ptime->hour % 24, ptime->minute % 60,
       ptime->second % 61);
#endif
#endif /* _WIN32_WCE */
   return ((png_charp)png_ptr->time_buffer);
}
#endif /* PNG_TIME_RFC1123_SUPPORTED */

#endif /* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */

png_charp PNGAPI
png_get_copyright(png_structp png_ptr)
{
   static char png_get_copyright_[] = PNG_STRING_NEWLINE \
     "libpng version 1.2.57-MirOS - December 29, 2016" PNG_STRING_NEWLINE \
     "Copyright (c) 2004-2017 The MirOS Project - http://mirbsd.de/" PNG_STRING_NEWLINE \
     "Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson" \
     PNG_STRING_NEWLINE \
     "Copyright (c) 1996-1997 Andreas Dilger" PNG_STRING_NEWLINE \
     "Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc." \
     PNG_STRING_NEWLINE;

   png_ptr = png_ptr;  /* Silence compiler warning about unused png_ptr */

   return ((png_charp)png_get_copyright_);
}

/* The following return the library version as a short string in the
 * format 1.0.0 through 99.99.99zz.  To get the version of *.h files
 * used with your application, print out PNG_LIBPNG_VER_STRING, which
 * is defined in png.h.
 * Note: now there is no difference between png_get_libpng_ver() and
 * png_get_header_ver().  Due to the version_nn_nn_nn typedef guard,
 * it is guaranteed that png.c uses the correct version of png.h.
 */
png_charp PNGAPI
png_get_libpng_ver(png_structp png_ptr)
{
   static char PNG_LIBPNG_VER_STRING_[] = PNG_LIBPNG_VER_STRING;

   /* Version of *.c files used when building libpng */
   PNG_UNUSED(png_ptr)  /* Silence compiler warning about unused png_ptr */
   return ((png_charp) PNG_LIBPNG_VER_STRING_);
}

png_charp PNGAPI
png_get_header_ver(png_structp png_ptr)
{
   static char PNG_LIBPNG_VER_STRING_[] = PNG_LIBPNG_VER_STRING;

   /* Version of *.h files used when building libpng */
   PNG_UNUSED(png_ptr)  /* Silence compiler warning about unused png_ptr */
   return ((png_charp) PNG_LIBPNG_VER_STRING_);
}

png_charp PNGAPI
png_get_header_version(png_structp png_ptr)
{
   static char PNG_HEADER_VERSION_STRING_[] = PNG_HEADER_VERSION_STRING
#ifndef PNG_READ_SUPPORTED
   "     (NO READ SUPPORT)"
#endif
   PNG_STRING_NEWLINE;

   /* Returns longer string containing both version and date */
   PNG_UNUSED(png_ptr) /* Silence compiler warning about unused png_ptr */
   return ((png_charp) PNG_HEADER_VERSION_STRING_);
}

#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
int PNGAPI
png_handle_as_unknown(png_structp png_ptr, png_bytep chunk_name)
{
   /* Check chunk_name and return "keep" value if it's on the list, else 0 */
   int i;
   png_bytep p;
   if (png_ptr == NULL || chunk_name == NULL || png_ptr->num_chunk_list<=0)
      return 0;
   p = png_ptr->chunk_list + png_ptr->num_chunk_list*5 - 5;
   for (i = png_ptr->num_chunk_list; i; i--, p -= 5)
      if (!png_memcmp(chunk_name, p, 4))
        return ((int)*(p + 4));
   return 0;
}
#endif

/* This function, added to libpng-1.0.6g, is untested. */
int PNGAPI
png_reset_zstream(png_structp png_ptr)
{
   if (png_ptr == NULL)
      return Z_STREAM_ERROR;
   return (inflateReset(&png_ptr->zstream));
}
#endif /* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */

/* This function was added to libpng-1.0.7 */
png_uint_32 PNGAPI
png_access_version_number(void)
{
   /* Version of *.c files used when building libpng */
   return((png_uint_32) PNG_LIBPNG_VER);
}


#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
#ifdef PNG_SIZE_T
/* Added at libpng version 1.2.6 */
   PNG_EXTERN png_size_t PNGAPI png_convert_size PNGARG((size_t size));
png_size_t PNGAPI
png_convert_size(size_t size)
{
   if (size > (png_size_t)-1)
      PNG_ABORT();  /* We haven't got access to png_ptr, so no png_error() */
   return ((png_size_t)size);
}
#endif /* PNG_SIZE_T */

/* Added at libpng version 1.2.34 and 1.4.0 (moved from pngset.c) */
#ifdef PNG_cHRM_SUPPORTED
#ifdef PNG_CHECK_cHRM_SUPPORTED

/*
 *    Multiply two 32-bit numbers, V1 and V2, using 32-bit
 *    arithmetic, to produce a 64 bit result in the HI/LO words.
 *
 *                  A B
 *                x C D
 *               ------
 *              AD || BD
 *        AC || CB || 0
 *
 *    where A and B are the high and low 16-bit words of V1,
 *    C and D are the 16-bit words of V2, AD is the product of
 *    A and D, and X || Y is (X << 16) + Y.
*/

void /* PRIVATE */
png_64bit_product (long v1, long v2, unsigned long *hi_product,
   unsigned long *lo_product)
{
   int a, b, c, d;
   long lo, hi, x, y;

   a = (v1 >> 16) & 0xffff;
   b = v1 & 0xffff;
   c = (v2 >> 16) & 0xffff;
   d = v2 & 0xffff;

   lo = b * d;                   /* BD */
   x = a * d + c * b;            /* AD + CB */
   y = ((lo >> 16) & 0xffff) + x;

   lo = (lo & 0xffff) | ((y & 0xffff) << 16);
   hi = (y >> 16) & 0xffff;

   hi += a * c;                  /* AC */

   *hi_product = (unsigned long)hi;
   *lo_product = (unsigned long)lo;
}

int /* PRIVATE */
png_check_cHRM_fixed(png_structp png_ptr,
   png_fixed_point white_x, png_fixed_point white_y, png_fixed_point red_x,
   png_fixed_point red_y, png_fixed_point green_x, png_fixed_point green_y,
   png_fixed_point blue_x, png_fixed_point blue_y)
{
   int ret = 1;
   unsigned long xy_hi,xy_lo,yx_hi,yx_lo;

   png_debug(1, "in function png_check_cHRM_fixed");

   if (png_ptr == NULL)
      return 0;

   if (white_x < 0 || white_y <= 0 ||
         red_x < 0 ||   red_y <  0 ||
       green_x < 0 || green_y <  0 ||
        blue_x < 0 ||  blue_y <  0)
   {
      png_warning(png_ptr,
        "Ignoring attempt to set negative chromaticity value");
      ret = 0;
   }
   if (white_x > (png_fixed_point) PNG_UINT_31_MAX ||
       white_y > (png_fixed_point) PNG_UINT_31_MAX ||
         red_x > (png_fixed_point) PNG_UINT_31_MAX ||
         red_y > (png_fixed_point) PNG_UINT_31_MAX ||
       green_x > (png_fixed_point) PNG_UINT_31_MAX ||
       green_y > (png_fixed_point) PNG_UINT_31_MAX ||
        blue_x > (png_fixed_point) PNG_UINT_31_MAX ||
        blue_y > (png_fixed_point) PNG_UINT_31_MAX )
   {
      png_warning(png_ptr,
        "Ignoring attempt to set chromaticity value exceeding 21474.83");
      ret = 0;
   }
   if (white_x > 100000L - white_y)
   {
      png_warning(png_ptr, "Invalid cHRM white point");
      ret = 0;
   }
   if (red_x > 100000L - red_y)
   {
      png_warning(png_ptr, "Invalid cHRM red point");
      ret = 0;
   }
   if (green_x > 100000L - green_y)
   {
      png_warning(png_ptr, "Invalid cHRM green point");
      ret = 0;
   }
   if (blue_x > 100000L - blue_y)
   {
      png_warning(png_ptr, "Invalid cHRM blue point");
      ret = 0;
   }

   png_64bit_product(green_x - red_x, blue_y - red_y, &xy_hi, &xy_lo);
   png_64bit_product(green_y - red_y, blue_x - red_x, &yx_hi, &yx_lo);

   if (xy_hi == yx_hi && xy_lo == yx_lo)
   {
      png_warning(png_ptr,
         "Ignoring attempt to set cHRM RGB triangle with zero area");
      ret = 0;
   }

   return ret;
}
#endif /* PNG_CHECK_cHRM_SUPPORTED */
#endif /* PNG_cHRM_SUPPORTED */

void /* PRIVATE */
png_check_IHDR(png_structp png_ptr,
   png_uint_32 width, png_uint_32 height, int bit_depth,
   int color_type, int interlace_type, int compression_type,
   int filter_type)
{
   int error = 0;

   /* Check for width and height valid values */
   if (width == 0)
   {
      png_warning(png_ptr, "Image width is zero in IHDR");
      error = 1;
   }

   if (height == 0)
   {
      png_warning(png_ptr, "Image height is zero in IHDR");
      error = 1;
   }

#ifdef PNG_SET_USER_LIMITS_SUPPORTED
   if (width > png_ptr->user_width_max || width > PNG_USER_WIDTH_MAX)
#else
   if (width > PNG_USER_WIDTH_MAX)
#endif
   {
      png_warning(png_ptr, "Image width exceeds user limit in IHDR");
      error = 1;
   }

#ifdef PNG_SET_USER_LIMITS_SUPPORTED
   if (height > png_ptr->user_height_max || height > PNG_USER_HEIGHT_MAX)
#else
   if (height > PNG_USER_HEIGHT_MAX)
#endif
   {
      png_warning(png_ptr, "Image height exceeds user limit in IHDR");
      error = 1;
   }

   if (width > PNG_UINT_31_MAX)
   {
      png_warning(png_ptr, "Invalid image width in IHDR");
      error = 1;
   }

   if ( height > PNG_UINT_31_MAX)
   {
      png_warning(png_ptr, "Invalid image height in IHDR");
      error = 1;
   }

   /* Check other values */
   if (bit_depth != 1 && bit_depth != 2 && bit_depth != 4 &&
       bit_depth != 8 && bit_depth != 16)
   {
      png_warning(png_ptr, "Invalid bit depth in IHDR");
      error = 1;
   }

   if (color_type < 0 || color_type == 1 ||
       color_type == 5 || color_type > 6)
   {
      png_warning(png_ptr, "Invalid color type in IHDR");
      error = 1;
   }

   if (((color_type == PNG_COLOR_TYPE_PALETTE) && bit_depth > 8) ||
       ((color_type == PNG_COLOR_TYPE_RGB ||
         color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||
         color_type == PNG_COLOR_TYPE_RGB_ALPHA) && bit_depth < 8))
   {
      png_warning(png_ptr, "Invalid color type/bit depth combination in IHDR");
      error = 1;
   }

   if (interlace_type >= PNG_INTERLACE_LAST)
   {
      png_warning(png_ptr, "Unknown interlace method in IHDR");
      error = 1;
   }

   if (compression_type != PNG_COMPRESSION_TYPE_BASE)
   {
      png_warning(png_ptr, "Unknown compression method in IHDR");
      error = 1;
   }

#ifdef PNG_MNG_FEATURES_SUPPORTED
   /* Accept filter_method 64 (intrapixel differencing) only if
    * 1. Libpng was compiled with PNG_MNG_FEATURES_SUPPORTED and
    * 2. Libpng did not read a PNG signature (this filter_method is only
    *    used in PNG datastreams that are embedded in MNG datastreams) and
    * 3. The application called png_permit_mng_features with a mask that
    *    included PNG_FLAG_MNG_FILTER_64 and
    * 4. The filter_method is 64 and
    * 5. The color_type is RGB or RGBA
    */
   if ((png_ptr->mode & PNG_HAVE_PNG_SIGNATURE) &&
       png_ptr->mng_features_permitted)
      png_warning(png_ptr, "MNG features are not allowed in a PNG datastream");

   if (filter_type != PNG_FILTER_TYPE_BASE)
   {
      if (!((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&
         (filter_type == PNG_INTRAPIXEL_DIFFERENCING) &&
         ((png_ptr->mode & PNG_HAVE_PNG_SIGNATURE) == 0) &&
         (color_type == PNG_COLOR_TYPE_RGB ||
         color_type == PNG_COLOR_TYPE_RGB_ALPHA)))
      {
         png_warning(png_ptr, "Unknown filter method in IHDR");
         error = 1;
      }

      if (png_ptr->mode & PNG_HAVE_PNG_SIGNATURE)
      {
         png_warning(png_ptr, "Invalid filter method in IHDR");
         error = 1;
      }
   }

#else
   if (filter_type != PNG_FILTER_TYPE_BASE)
   {
      png_warning(png_ptr, "Unknown filter method in IHDR");
      error = 1;
   }
#endif

   if (error == 1)
      png_error(png_ptr, "Invalid IHDR data");
}
#endif /* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */
@


1.12
log
@merge, rebase/minify, fix
@
text
@d2 1
a2 1
__RCSID("$MirOS: src/lib/libpng/png.c,v 1.11 2009/03/15 20:08:44 tg Exp $");
d6 2
a7 2
 * Last changed in libpng 1.2.46 [February 25, 2011]
 * Copyright (c) 1998-2011 Glenn Randers-Pehrson
d22 1
a22 1
typedef version_1_2_50 Your_png_h_is_not_version_1_2_50;
d163 2
a164 2
   png_structp p=(png_structp)png_ptr;
   png_uint_32 save_flags=p->flags;
d169 4
d337 2
d398 1
d687 1
d698 1
a698 1
          ptime->day % 32, short_months[(ptime->month - 1) % 12],
d709 1
a709 1
          ptime->day % 32, short_months[(ptime->month - 1) % 12],
d717 1
a717 1
       ptime->day % 32, short_months[(ptime->month - 1) % 12],
d732 4
a735 3
     "libpng version 1.2.50-MirOS - July 10, 2012" PNG_STRING_NEWLINE \
     "Copyright (c) 2004-2013 The MirOS Project - http://mirbsd.de/" PNG_STRING_NEWLINE \
     "Copyright (c) 1998-2011 Glenn Randers-Pehrson" PNG_STRING_NEWLINE \
d759 1
a759 1
   png_ptr = png_ptr;  /* Silence compiler warning about unused png_ptr */
d769 1
a769 1
   png_ptr = png_ptr;  /* Silence compiler warning about unused png_ptr */
d783 1
a783 1
   png_ptr = png_ptr;  /* Silence compiler warning about unused png_ptr */
a1005 8
   if ( width > (PNG_UINT_32_MAX
                 >> 3)      /* 8-byte RGBA pixels */
                 - 64       /* bigrowbuf hack */
                 - 1        /* filter byte */
                 - 7*8      /* rounding of width to multiple of 8 pixels */
                 - 8)       /* extra max_pixel_depth pad */
      png_warning(png_ptr, "Width is too large for libpng to process pixels");

@


1.11
log
@SECURITY update; prodded by bsiegert@@
@
text
@d2 1
a2 1
__RCSID("$MirOS: src/lib/libpng/png.c,v 1.10 2008/10/22 19:11:49 tg Exp $");
d6 2
a7 3
 * Last changed in libpng 1.2.34 [December 18, 2008]
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1998-2008 Glenn Randers-Pehrson
d10 4
d18 1
d22 1
a22 1
typedef version_1_2_35 Your_png_h_is_not_version_1_2_35;
d25 2
a26 1
 * string defined in png.h.  */
d30 1
a30 1
const char png_libpng_ver[18] = PNG_LIBPNG_VER_STRING;
d36 1
a36 1
const png_byte png_sig[8] = {137, 80, 78, 71, 13, 10, 26, 10};
d63 1
a63 1
/* arrays to facilitate easy interlacing - use pass (0 - 6) as index */
d65 2
a66 2
/* start of interlace block */
const int png_pass_start[] = {0, 4, 0, 2, 0, 1, 0};
d68 2
a69 2
/* offset to next interlace block */
const int png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1};
d71 2
a72 2
/* start of interlace block in the y direction */
const int png_pass_ystart[] = {0, 0, 4, 0, 2, 0, 1};
d74 2
a75 2
/* offset to next interlace block in the y direction */
const int png_pass_yinc[] = {8, 8, 8, 4, 4, 2, 2};
d79 1
a79 1
const int png_pass_height[] = {8, 8, 4, 4, 2, 2, 1};
d83 2
a84 1
const int png_pass_mask[] = {0x80, 0x08, 0x88, 0x22, 0xaa, 0x55, 0xff};
d87 1
a87 1
const int png_pass_dsp_mask[]
a102 1
   if (png_ptr == NULL) return;
d104 4
d158 1
a158 1
voidpf /* private */
d167 2
a168 1
   if (png_ptr == NULL) return (NULL);
d198 1
a198 1
/* function to free memory for zlib */
d202 1
a202 1
void /* private */
d256 4
a259 1
   if (png_ptr == NULL) return (NULL);
a280 1
   if (png_ptr == NULL) return;
d283 4
d323 1
a323 1
   if (info_ptr == NULL) return;
d325 2
a326 1
   png_debug(1, "in png_info_init_3");
d329 5
a333 5
     {
       png_destroy_struct(info_ptr);
       info_ptr = (png_infop)png_create_struct(PNG_STRUCT_INFO);
       *ptr_ptr = info_ptr;
     }
d335 1
a335 1
   /* set everything to 0 */
d345 1
d348 1
d364 1
d368 2
a369 2
#if defined(PNG_TEXT_SUPPORTED)
/* free text item num or (if num == -1) all text items */
d371 1
a371 1
if ((mask & PNG_FREE_TEXT) & info_ptr->free_me)
d373 1
a373 1
if (mask & PNG_FREE_TEXT)
a374 2
{
   if (num != -1)
d376 17
a392 14
     if (info_ptr->text && info_ptr->text[num].key)
     {
         png_free(png_ptr, info_ptr->text[num].key);
         info_ptr->text[num].key = NULL;
     }
   }
   else
   {
       int i;
       for (i = 0; i < info_ptr->num_text; i++)
           png_free_data(png_ptr, info_ptr, PNG_FREE_TEXT, i);
       png_free(png_ptr, info_ptr->text);
       info_ptr->text = NULL;
       info_ptr->num_text=0;
a393 1
}
d396 2
a397 2
#if defined(PNG_tRNS_SUPPORTED)
/* free any tRNS entry */
d399 1
a399 1
if ((mask & PNG_FREE_TRNS) & info_ptr->free_me)
d401 1
a401 1
if ((mask & PNG_FREE_TRNS) && (png_ptr->flags & PNG_FLAG_FREE_TRNS))
d403 4
a406 4
{
    png_free(png_ptr, info_ptr->trans);
    info_ptr->trans = NULL;
    info_ptr->valid &= ~PNG_INFO_tRNS;
d408 1
a408 1
    png_ptr->flags &= ~PNG_FLAG_FREE_TRNS;
d410 1
a410 1
}
d413 2
a414 2
#if defined(PNG_sCAL_SUPPORTED)
/* free any sCAL entry */
d416 1
a416 1
if ((mask & PNG_FREE_SCAL) & info_ptr->free_me)
d418 1
a418 1
if (mask & PNG_FREE_SCAL)
d420 1
a420 1
{
d422 4
a425 4
    png_free(png_ptr, info_ptr->scal_s_width);
    png_free(png_ptr, info_ptr->scal_s_height);
    info_ptr->scal_s_width = NULL;
    info_ptr->scal_s_height = NULL;
d427 2
a428 2
    info_ptr->valid &= ~PNG_INFO_sCAL;
}
d431 2
a432 2
#if defined(PNG_pCAL_SUPPORTED)
/* free any pCAL entry */
d434 1
a434 1
if ((mask & PNG_FREE_PCAL) & info_ptr->free_me)
d436 1
a436 1
if (mask & PNG_FREE_PCAL)
d438 18
a455 18
{
    png_free(png_ptr, info_ptr->pcal_purpose);
    png_free(png_ptr, info_ptr->pcal_units);
    info_ptr->pcal_purpose = NULL;
    info_ptr->pcal_units = NULL;
    if (info_ptr->pcal_params != NULL)
    {
        int i;
        for (i = 0; i < (int)info_ptr->pcal_nparams; i++)
        {
          png_free(png_ptr, info_ptr->pcal_params[i]);
          info_ptr->pcal_params[i]=NULL;
        }
        png_free(png_ptr, info_ptr->pcal_params);
        info_ptr->pcal_params = NULL;
    }
    info_ptr->valid &= ~PNG_INFO_pCAL;
}
d458 2
a459 2
#if defined(PNG_iCCP_SUPPORTED)
/* free any iCCP entry */
d461 1
a461 1
if ((mask & PNG_FREE_ICCP) & info_ptr->free_me)
d463 1
a463 1
if (mask & PNG_FREE_ICCP)
d465 7
a471 7
{
    png_free(png_ptr, info_ptr->iccp_name);
    png_free(png_ptr, info_ptr->iccp_profile);
    info_ptr->iccp_name = NULL;
    info_ptr->iccp_profile = NULL;
    info_ptr->valid &= ~PNG_INFO_iCCP;
}
d474 2
a475 2
#if defined(PNG_sPLT_SUPPORTED)
/* free a given sPLT entry, or (if num == -1) all sPLT entries */
d477 1
a477 1
if ((mask & PNG_FREE_SPLT) & info_ptr->free_me)
d479 1
a479 1
if (mask & PNG_FREE_SPLT)
a480 2
{
   if (num != -1)
d482 1
a482 1
      if (info_ptr->splt_palettes)
d484 21
a504 4
          png_free(png_ptr, info_ptr->splt_palettes[num].name);
          png_free(png_ptr, info_ptr->splt_palettes[num].entries);
          info_ptr->splt_palettes[num].name = NULL;
          info_ptr->splt_palettes[num].entries = NULL;
d507 4
a510 1
   else
d512 2
a513 11
       if (info_ptr->splt_palettes_num)
       {
         int i;
         for (i = 0; i < (int)info_ptr->splt_palettes_num; i++)
            png_free_data(png_ptr, info_ptr, PNG_FREE_SPLT, i);

         png_free(png_ptr, info_ptr->splt_palettes);
         info_ptr->splt_palettes = NULL;
         info_ptr->splt_palettes_num = 0;
       }
       info_ptr->valid &= ~PNG_INFO_sPLT;
a514 9
}
#endif

#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
  if (png_ptr->unknown_chunk.data)
  {
    png_free(png_ptr, png_ptr->unknown_chunk.data);
    png_ptr->unknown_chunk.data = NULL;
  }
d517 1
a517 1
if ((mask & PNG_FREE_UNKN) & info_ptr->free_me)
d519 1
a519 1
if (mask & PNG_FREE_UNKN)
a520 2
{
   if (num != -1)
d522 11
a532 9
       if (info_ptr->unknown_chunks)
       {
          png_free(png_ptr, info_ptr->unknown_chunks[num].data);
          info_ptr->unknown_chunks[num].data = NULL;
       }
   }
   else
   {
       int i;
d534 10
a543 9
       if (info_ptr->unknown_chunks_num)
       {
         for (i = 0; i < (int)info_ptr->unknown_chunks_num; i++)
            png_free_data(png_ptr, info_ptr, PNG_FREE_UNKN, i);

         png_free(png_ptr, info_ptr->unknown_chunks);
         info_ptr->unknown_chunks = NULL;
         info_ptr->unknown_chunks_num = 0;
       }
a544 1
}
d547 2
a548 2
#if defined(PNG_hIST_SUPPORTED)
/* free any hIST entry */
d550 1
a550 1
if ((mask & PNG_FREE_HIST)  & info_ptr->free_me)
d552 1
a552 1
if ((mask & PNG_FREE_HIST) && (png_ptr->flags & PNG_FLAG_FREE_HIST))
d554 4
a557 4
{
    png_free(png_ptr, info_ptr->hist);
    info_ptr->hist = NULL;
    info_ptr->valid &= ~PNG_INFO_hIST;
d559 1
a559 1
    png_ptr->flags &= ~PNG_FLAG_FREE_HIST;
d561 1
a561 1
}
d564 1
a564 1
/* free any PLTE entry that was internally allocated */
d566 1
a566 1
if ((mask & PNG_FREE_PLTE) & info_ptr->free_me)
d568 1
a568 1
if ((mask & PNG_FREE_PLTE) && (png_ptr->flags & PNG_FLAG_FREE_PLTE))
d570 4
a573 4
{
    png_zfree(png_ptr, info_ptr->palette);
    info_ptr->palette = NULL;
    info_ptr->valid &= ~PNG_INFO_PLTE;
d575 1
a575 1
    png_ptr->flags &= ~PNG_FLAG_FREE_PLTE;
d577 2
a578 2
    info_ptr->num_palette = 0;
}
d580 2
a581 2
#if defined(PNG_INFO_IMAGE_SUPPORTED)
/* free any image bits attached to the info structure */
d583 1
a583 1
if ((mask & PNG_FREE_ROWS) & info_ptr->free_me)
d585 1
a585 1
if (mask & PNG_FREE_ROWS)
d587 14
a600 14
{
    if (info_ptr->row_pointers)
    {
       int row;
       for (row = 0; row < (int)info_ptr->height; row++)
       {
          png_free(png_ptr, info_ptr->row_pointers[row]);
          info_ptr->row_pointers[row]=NULL;
       }
       png_free(png_ptr, info_ptr->row_pointers);
       info_ptr->row_pointers=NULL;
    }
    info_ptr->valid &= ~PNG_INFO_IDAT;
}
d605 1
a605 1
     info_ptr->free_me &= ~mask;
d607 1
a607 1
     info_ptr->free_me &= ~(mask & ~PNG_FREE_MUL);
d622 1
a622 1
#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
d625 3
a627 3
       png_free(png_ptr, png_ptr->chunk_list);
       png_ptr->chunk_list=NULL;
       png_ptr->num_chunk_list = 0;
d642 2
a643 1
   if (png_ptr == NULL) return (NULL);
d648 1
a648 1
#if !defined(PNG_NO_STDIO)
d659 4
a662 1
   if (png_ptr == NULL) return;
d667 1
a667 1
#if defined(PNG_TIME_RFC1123_SUPPORTED)
d674 1
a674 1
   static const char short_months[12][4] =
d678 2
a679 1
   if (png_ptr == NULL) return (NULL);
d686 1
a686 1
#if defined(_WIN32_WCE)
d693 2
a694 2
      WideCharToMultiByte(CP_ACP, 0, time_buf, -1, png_ptr->time_buffer, 29,
          NULL, NULL);
d723 11
a733 6
   png_ptr = png_ptr;  /* silence compiler warning about unused png_ptr */
   return ((png_charp) "\n libpng version 1.2.35-MirOS - February 14, 2009\n\
   Copyright (c) 2004-2008 The MirOS Project - http://mirbsd.de/\n\
   Copyright (c) 1998-2008 Glenn Randers-Pehrson\n\
   Copyright (c) 1996-1997 Andreas Dilger\n\
   Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.\n");
d747 2
d750 2
a751 2
   png_ptr = png_ptr;  /* silence compiler warning about unused png_ptr */
   return ((png_charp) PNG_LIBPNG_VER_STRING);
d757 2
d760 2
a761 2
   png_ptr = png_ptr;  /* silence compiler warning about unused png_ptr */
   return ((png_charp) PNG_LIBPNG_VER_STRING);
d767 1
a767 3
   /* Returns longer string containing both version and date */
   png_ptr = png_ptr;  /* silence compiler warning about unused png_ptr */
   return ((png_charp) PNG_HEADER_VERSION_STRING
d771 5
a775 1
   "\n");
d783 1
a783 1
   /* check chunk_name and return "keep" value if it's on the list, else 0 */
d800 2
a801 1
   if (png_ptr == NULL) return Z_STREAM_ERROR;
d822 3
a824 3
  if (size > (png_size_t)-1)
     PNG_ABORT();  /* We haven't got access to png_ptr, so no png_error() */
  return ((png_size_t)size);
d829 3
a831 2
#if defined(PNG_cHRM_SUPPORTED)
#if !defined(PNG_NO_CHECK_cHRM)
d833 12
a844 12
 Multiply two 32-bit numbers, V1 and V2, using 32-bit
 arithmetic, to produce a 64 bit result in the HI/LO words.

          A B
        x C D
       ------
      AD || BD
AC || CB || 0

 where A and B are the high and low 16-bit words of V1,
 C and D are the 16-bit words of V2, AD is the product of
 A and D, and X || Y is (X << 16) + Y.
d847 2
a848 1
void png_64bit_product (long v1, long v2, unsigned long *hi_product,
d851 2
a852 2
 int a, b, c, d;
 long lo, hi, x, y;
d854 4
a857 4
 a = (v1 >> 16) & 0xffff;
 b = v1 & 0xffff;
 c = (v2 >> 16) & 0xffff;
 d = v2 & 0xffff;
d859 3
a861 3
 lo = b * d;                   /* BD */
 x = a * d + c * b;            /* AD + CB */
 y = ((lo >> 16) & 0xffff) + x;
d863 2
a864 2
 lo = (lo & 0xffff) | ((y & 0xffff) << 16);
 hi = (y >> 16) & 0xffff;
d866 1
a866 1
 hi += a * c;                  /* AC */
d868 2
a869 2
 *hi_product = (unsigned long)hi;
 *lo_product = (unsigned long)lo;
d871 2
a872 1
int /* private */
d882 1
d941 1
a941 1
#endif /* NO_PNG_CHECK_cHRM */
d943 142
@


1.10
log
@merge libpng upgrade

major version bump because function signature of png_decompress_chunk
changed (return value to void)
@
text
@d2 1
a2 1
__RCSID("$MirOS: src/lib/libpng/png.c,v 1.9 2008/04/07 19:54:33 tg Exp $");
d6 1
a6 1
 * Last changed in libpng 1.2.30 [August 15, 2008]
d18 1
a18 1
typedef version_1_2_32 Your_png_h_is_not_version_1_2_32;
d98 1
a98 1
   png_debug(1, "in png_set_sig_bytes\n");
d245 1
a245 1
   png_debug(1, "in png_create_info_struct\n");
d270 1
a270 1
   png_debug(1, "in png_destroy_info_struct\n");
d309 1
a309 1
   png_debug(1, "in png_info_init_3\n");
d327 1
a327 1
   png_debug(1, "in png_data_freer\n");
d344 1
a344 1
   png_debug(1, "in png_free_data\n");
d598 1
a598 1
   png_debug(1, "in png_info_destroy\n");
d637 1
a637 1
   png_debug(1, "in png_init_io\n");
d699 1
a699 1
   return ((png_charp) "\n libpng version 1.2.32-MirOS - September 18, 2008\n\
d790 112
@


1.9
log
@fastmerge
@
text
@d2 1
a2 1
__RCSID("$MirOS: src/lib/libpng/png.c,v 1.8 2008/03/23 17:54:53 tg Exp $");
d6 1
a6 1
 * Last changed in libpng 1.2.21 October 4, 2007
d8 1
a8 1
 * Copyright (c) 1998-2007 Glenn Randers-Pehrson
d18 1
a18 1
typedef version_1_2_26 Your_png_h_is_not_version_1_2_26;
d97 1
a97 1
   if(png_ptr == NULL) return;
d158 1
a158 1
   if(png_ptr == NULL) return (NULL);
d246 1
a246 1
   if(png_ptr == NULL) return (NULL);
d268 1
a268 1
   if(png_ptr == NULL) return;
d307 1
a307 1
   if(info_ptr == NULL) return;
d311 1
a311 1
   if(png_sizeof(png_info) > png_info_struct_size)
d319 1
a319 1
   png_memset(info_ptr, 0, png_sizeof (png_info));
d330 1
a330 1
   if(freer == PNG_DESTROY_WILL_FREE_DATA)
d332 1
a332 1
   else if(freer == PNG_USER_WILL_FREE_DATA)
d385 1
a389 1
    info_ptr->trans = NULL;
d464 1
a464 1
      if(info_ptr->splt_palettes)
d474 1
a474 1
       if(info_ptr->splt_palettes_num)
d490 1
a490 1
  if(png_ptr->unknown_chunk.data)
d495 1
d504 1
a504 1
       if(info_ptr->unknown_chunks)
d514 1
a514 1
       if(info_ptr->unknown_chunks_num)
d568 1
a568 1
    if(info_ptr->row_pointers)
d584 1
a584 1
   if(num == -1)
d607 1
a607 1
       png_ptr->num_chunk_list=0;
d622 1
a622 1
   if(png_ptr == NULL) return (NULL);
d638 1
a638 1
   if(png_ptr == NULL) return;
d654 1
a654 1
   if(png_ptr == NULL) return (NULL);
d675 1
a675 1
      png_snprintf6(near_time_buf,29,"%d %s %d %02d:%02d:%02d +0000",
d683 1
a683 1
   png_snprintf6(png_ptr->time_buffer,29,"%d %s %d %02d:%02d:%02d +0000",
d699 1
a699 1
   return ((png_charp) "\n libpng version 1.2.26-MirOS - April 2, 2008\n\
d750 1
a750 1
   if(png_ptr == NULL || chunk_name == NULL || png_ptr->num_chunk_list<=0)
d752 2
a753 2
   p=png_ptr->chunk_list+png_ptr->num_chunk_list*5-5;
   for (i = png_ptr->num_chunk_list; i; i--, p-=5)
d755 1
a755 1
        return ((int)*(p+4));
@


1.8
log
@merge and fix for __CRAZY=Yes
@
text
@d2 1
a2 1
__RCSID("$MirOS: src/lib/libpng/png.c,v 1.7 2007/05/22 20:46:17 tg Exp $");
d18 1
a18 1
typedef version_1_2_25 Your_png_h_is_not_version_1_2_25;
d698 1
a698 1
   return ((png_charp) "\n libpng version 1.2.25-MirOS - February 18, 2008\n\
@


1.7
log
@merge and validate
@
text
@d2 1
a2 1
__RCSID("$MirOS: src/lib/libpng/png.c,v 1.6 2006/06/29 17:14:23 tg Exp $");
d6 1
a6 1
 * Last changed in libpng 1.2.17 May 15, 2007
d18 1
a18 1
typedef version_1_2_18 Your_png_h_is_not_version_1_2_18;
a71 5
/* width of interlace block (used in assembler routines only) */
#ifdef PNG_HAVE_MMX_COMBINE_ROW
const int png_pass_width[] = {8, 4, 4, 2, 2, 1, 1};
#endif

d134 1
a134 1
 * future - use png_sig_cmp().  Returns true (nonzero) if the file is a PNG.
d649 1
a649 1
   static PNG_CONST char short_months[12][4] =
d674 1
a674 1
      sprintf(near_time_buf, "%d %s %d %02d:%02d:%02d +0000",
d682 1
a682 1
   sprintf(png_ptr->time_buffer, "%d %s %d %02d:%02d:%02d +0000",
a691 8
#if 0
/* Signature string for a PNG file. */
png_bytep PNGAPI
png_sig_bytes(void)
{
   return ((png_bytep)"\211\120\116\107\015\012\032\012");
}
#endif
d697 4
a700 4
   if (&png_ptr != NULL)  /* silence compiler warning about unused png_ptr */
   return ((png_charp) "\n libpng version 1.2.18-MirOS - May 15, 2007\n\
   Copyright (c) 2004-2007 The MirOS Project - http://mirbsd.de/\n\
   Copyright (c) 1998-2007 Glenn Randers-Pehrson\n\
a702 1
   return ((png_charp) "");
d717 2
a718 3
   if (&png_ptr != NULL)  /* silence compiler warning about unused png_ptr */
      return ((png_charp) PNG_LIBPNG_VER_STRING);
   return ((png_charp) "");
d725 2
a726 3
   if (&png_ptr != NULL)  /* silence compiler warning about unused png_ptr */
      return ((png_charp) PNG_LIBPNG_VER_STRING);
   return ((png_charp) "");
d733 6
a738 3
   if (&png_ptr != NULL)  /* silence compiler warning about unused png_ptr */
      return ((png_charp) PNG_HEADER_VERSION_STRING);
   return ((png_charp) "");
d749 1
a749 1
   if((png_ptr == NULL && chunk_name == NULL) || png_ptr->num_chunk_list<=0)
a776 14
#if defined(PNG_READ_SUPPORTED) /*&& defined(PNG_ASSEMBLER_CODE_SUPPORTED)*/
#if !defined(PNG_1_0_X)
/* this function was added to libpng 1.2.0 */
#if !defined(PNG_USE_PNGGCCRD) && \
    !(defined(PNG_MMX_CODE_SUPPORTED) && defined(PNG_USE_PNGVCRD))
int PNGAPI
png_mmx_support(void)
{
    return -1;
}
#endif
#endif /* PNG_1_0_X  && PNG_ASSEMBLER_CODE_SUPPORTED */
#endif /* PNG_READ_SUPPORTED */

@


1.6
log
@merge libpng-1.2.12
@
text
@d2 1
a2 1
__RCSID("$MirOS: src/lib/libpng/png.c,v 1.5 2006/06/09 00:34:46 tg Exp $");
d6 1
a6 1
 * Last changed in libpng 1.2.9 April 14, 2006
d8 1
a8 1
 * Copyright (c) 1998-2006 Glenn Randers-Pehrson
d18 1
a18 1
typedef version_1_2_12 Your_png_h_is_not_version_1_2_12;
d73 1
a73 1
#ifdef PNG_HAVE_ASSEMBLER_COMBINE_ROW
d102 1
d159 1
a159 1
   png_structp p=png_ptr;
d163 1
d166 1
a166 1
     png_warning (png_ptr, "Potential overflow in png_zalloc()");
d273 1
d312 2
d495 5
d626 1
d642 1
d658 1
d711 3
a713 3
   return ((png_charp) "\n libpng version 1.2.12-MirOS - June 27, 2006\n\
   Copyright (c) 2004-2006 The MirOS Project - http://mirbsd.de/\n\
   Copyright (c) 1998-2006 Glenn Randers-Pehrson\n\
d776 1
d790 1
a790 1
#if defined(PNG_READ_SUPPORTED)
d793 2
d800 2
a801 1
#endif /* PNG_1_0_X */
@


1.5
log
@shuffle legal bs around (shrink)
@
text
@d2 1
a2 1
__RCSID("$MirOS: src/lib/libpng/png.c,v 1.4 2006/06/09 00:30:27 tg Exp $");
d18 1
a18 1
typedef version_1_2_10 Your_png_h_is_not_version_1_2_10;
d698 1
a698 1
   return ((png_charp) "\n libpng version 1.2.10-MirOS - June 9, 2006\n\
@


1.4
log
@sync, fix CPPFLAGS
no shlib vsn change (only change local data->rodata, no external syms)
@
text
@a0 23
/* $MirOS: src/lib/libpng/png.c,v 1.3 2005/12/17 05:46:17 tg Exp $ */

/*-
 * Copyright (c) 2004, 2005
 *	Thorsten "mirabile" Glaser <tg@@66h.42h.de>
 *
 * Licensee is hereby permitted to deal in this work without restric-
 * tion, including unlimited rights to use, publicly perform, modify,
 * merge, distribute, sell, give away or sublicence, provided all co-
 * pyright notices above, these terms and the disclaimer are retained
 * in all redistributions or reproduced in accompanying documentation
 * or other materials provided with binary redistributions.
 *
 * Licensor offers the work "AS IS" and WITHOUT WARRANTY of any kind,
 * express, or implied, to the maximum extent permitted by applicable
 * law, without malicious intent or gross negligence; in no event may
 * licensor, an author or contributor be held liable for any indirect
 * or other damage, or direct damage except proven a consequence of a
 * direct error of said person and intended use of this work, loss or
 * other issues arising in any way out of its use, even if advised of
 * the possibility of such damage or existence of a nontrivial bug.
 */

d2 1
a2 1
__RCSID("$MirOS: src/lib/libpng/png.c,v 1.3 2005/12/17 05:46:17 tg Exp $");
@


1.3
log
@big fat licence update (I left some which are bsiegert@@'s alone though)
also, remove licence boilerplate from some .h files who don't deserve it
and remove and add some advertising clauses because I say so
@
text
@d1 1
a1 1
/* $MirOS: src/lib/libpng/png.c,v 1.2 2005/03/06 20:29:15 tg Exp $ */
d25 1
a25 1
__RCSID("$MirOS: src/lib/libpng/png.c,v 1.2 2005/03/06 20:29:15 tg Exp $");
d29 1
a29 1
 * libpng version 1.2.8 - December 3, 2004
d31 1
a31 1
 * Copyright (c) 1998-2004 Glenn Randers-Pehrson
d41 1
a41 1
typedef version_1_2_8 Your_png_h_is_not_version_1_2_8;
d50 2
d55 1
d80 1
d112 1
d121 1
d147 1
a147 1
      return (0);
d150 1
a150 1
      return (0);
d158 1
d168 2
d171 1
d317 1
a317 1
#if defined(PNG_1_0_X) || defined (PNG_1_2_X)
d630 1
d642 1
d715 1
d721 3
a723 3
   return ((png_charp) "\n libpng version 1.2.8-MirOS - December 3, 2004\n\
   Copyright (c) 2004-2005 The MirOS Project - http://mirbsd.de/\n\
   Copyright (c) 1998-2004 Glenn Randers-Pehrson\n\
d764 1
d788 1
d799 1
d808 1
d810 1
d822 1
@


1.2
log
@merge src/lib
@
text
@d1 1
a1 1
/* $MirOS$ */
d14 8
a21 7
 * Licensor hereby provides this work "AS IS" and WITHOUT WARRANTY of
 * any kind, expressed or implied, to the maximum extent permitted by
 * applicable law, but with the warranty of being written without ma-
 * licious intent or gross negligence; in no event shall licensor, an
 * author or contributor be held liable for any damage, direct, indi-
 * rect or other, however caused, arising in any way out of the usage
 * of this work, even if advised of the possibility of such damage.
d25 1
a25 1
__RCSID("$MirOS$");
@


1.1
log
@Initial revision
@
text
@d1 24
d51 1
a51 1
const png_byte FARDATA png_sig[8] = {137, 80, 78, 71, 13, 10, 26, 10};
d79 1
a79 1
const int FARDATA png_pass_start[] = {0, 4, 0, 2, 0, 1, 0};
d82 1
a82 1
const int FARDATA png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1};
d85 1
a85 1
const int FARDATA png_pass_ystart[] = {0, 0, 4, 0, 2, 0, 1};
d88 1
a88 1
const int FARDATA png_pass_yinc[] = {8, 8, 8, 4, 4, 2, 2};
d92 1
a92 1
const int FARDATA png_pass_width[] = {8, 4, 4, 2, 2, 1, 1};
d97 1
a97 1
const int FARDATA png_pass_height[] = {8, 8, 4, 4, 2, 2, 1};
d101 1
a101 1
const int FARDATA png_pass_mask[] = {0x80, 0x08, 0x88, 0x22, 0xaa, 0x55, 0xff};
d104 1
a104 1
const int FARDATA png_pass_dsp_mask[]
d707 2
a708 1
   return ((png_charp) "\n libpng version 1.2.8 - December 3, 2004\n\
a783 48
#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
    /* GRR:  could add this:   && defined(PNG_MMX_CODE_SUPPORTED) */
/* this INTERNAL function was added to libpng 1.2.0 */
void /* PRIVATE */
png_init_mmx_flags (png_structp png_ptr)
{
    png_ptr->mmx_rowbytes_threshold = 0;
    png_ptr->mmx_bitdepth_threshold = 0;

#  if (defined(PNG_USE_PNGVCRD) || defined(PNG_USE_PNGGCCRD))

    png_ptr->asm_flags |= PNG_ASM_FLAG_MMX_SUPPORT_COMPILED;

    if (png_mmx_support() > 0) {
        png_ptr->asm_flags |= PNG_ASM_FLAG_MMX_SUPPORT_IN_CPU
#    ifdef PNG_HAVE_ASSEMBLER_COMBINE_ROW
                              | PNG_ASM_FLAG_MMX_READ_COMBINE_ROW
#    endif
#    ifdef PNG_HAVE_ASSEMBLER_READ_INTERLACE
                              | PNG_ASM_FLAG_MMX_READ_INTERLACE
#    endif
#    ifndef PNG_HAVE_ASSEMBLER_READ_FILTER_ROW
                              ;
#    else
                              | PNG_ASM_FLAG_MMX_READ_FILTER_SUB
                              | PNG_ASM_FLAG_MMX_READ_FILTER_UP
                              | PNG_ASM_FLAG_MMX_READ_FILTER_AVG
                              | PNG_ASM_FLAG_MMX_READ_FILTER_PAETH ;

        png_ptr->mmx_rowbytes_threshold = PNG_MMX_ROWBYTES_THRESHOLD_DEFAULT;
        png_ptr->mmx_bitdepth_threshold = PNG_MMX_BITDEPTH_THRESHOLD_DEFAULT;
#    endif
    } else {
        png_ptr->asm_flags &= ~( PNG_ASM_FLAG_MMX_SUPPORT_IN_CPU
                               | PNG_MMX_READ_FLAGS
                               | PNG_MMX_WRITE_FLAGS );
    }

#  else /* !((PNGVCRD || PNGGCCRD) && PNG_ASSEMBLER_CODE_SUPPORTED)) */

    /* clear all MMX flags; no support is compiled in */
    png_ptr->asm_flags &= ~( PNG_MMX_FLAGS );

#  endif /* ?(PNGVCRD || PNGGCCRD) */
}

#endif /* !(PNG_ASSEMBLER_CODE_SUPPORTED) */

a784 2
#if !defined(PNG_USE_PNGGCCRD) && \
    !(defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_USE_PNGVCRD))
a789 1
#endif
@


1.1.107.1
log
@libpng-1_2_8 with the following directories removed:
- contrib
- projects
- scripts
@
text
@@


1.1.107.2
log
@there's a newer libpng out there
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.9 April 14, 2006
d6 1
a6 1
 * Copyright (c) 1998-2006 Glenn Randers-Pehrson
d16 1
a16 1
typedef version_1_2_10 Your_png_h_is_not_version_1_2_10;
a24 2
#ifdef PNG_READ_SUPPORTED

a27 1
#endif /* PNG_READ_SUPPORTED */
a51 1
#ifdef PNG_READ_SUPPORTED
a82 1
#endif /* PNG_READ_SUPPORTED */
a90 1
#ifdef PNG_READ_SUPPORTED
d116 1
a116 1
      return (-1);
d119 1
a119 1
      return (-1);
a126 1
#if defined(PNG_1_0_X) || defined(PNG_1_2_X)
a135 2
#endif
#endif /* PNG_READ_SUPPORTED */
a136 1
#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
d282 1
a282 1
#if defined(PNG_1_0_X) || defined(PNG_1_2_X)
a594 1
#endif /* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */
a605 1
#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
a677 1
#endif /* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */
d683 2
a684 2
   return ((png_charp) "\n libpng version 1.2.10 - April 23, 2006\n\
   Copyright (c) 1998-2006 Glenn Randers-Pehrson\n\
a724 1
#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
a747 1
#endif /* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */
a757 1
#if defined(PNG_READ_SUPPORTED)
a816 1
#endif /* PNG_READ_SUPPORTED */
a817 1
#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
a828 1
#endif /* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */
@


1.1.107.3
log
@Import libpng 1.2.12, fixes at least three vulnerabilities
@
text
@d16 1
a16 1
typedef version_1_2_12 Your_png_h_is_not_version_1_2_12;
d696 1
a696 1
   return ((png_charp) "\n libpng version 1.2.12 - June 27, 2006\n\
@


1.1.107.4
log
@Upgrade libpng (fixes some holes)
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.17 May 15, 2007
d6 1
a6 1
 * Copyright (c) 1998-2007 Glenn Randers-Pehrson
d16 1
a16 1
typedef version_1_2_18 Your_png_h_is_not_version_1_2_18;
d71 1
a71 1
#ifdef PNG_HAVE_MMX_COMBINE_ROW
a99 1
   if(png_ptr == NULL) return;
d156 1
a156 1
   png_structp p=(png_structp)png_ptr;
a159 1
   if(png_ptr == NULL) return (NULL);
d162 1
a162 1
     png_warning (p, "Potential overflow in png_zalloc()");
a268 1
   if(png_ptr == NULL) return;
a306 2
   if(info_ptr == NULL) return;

a487 5
  if(png_ptr->unknown_chunk.data)
  {
    png_free(png_ptr, png_ptr->unknown_chunk.data);
    png_ptr->unknown_chunk.data = NULL;
  }
a613 1
   if(png_ptr == NULL) return (NULL);
a628 1
   if(png_ptr == NULL) return;
a643 1
   if(png_ptr == NULL) return (NULL);
d696 2
a697 2
   return ((png_charp) "\n libpng version 1.2.18 - May 15, 2007\n\
   Copyright (c) 1998-2007 Glenn Randers-Pehrson\n\
a759 1
   if (png_ptr == NULL) return Z_STREAM_ERROR;
d773 1
a773 1
#if defined(PNG_READ_SUPPORTED) && defined(PNG_ASSEMBLER_CODE_SUPPORTED)
d775 2
a776 1
#if defined(PNG_MMX_CODE_SUPPORTED)
a780 1
    if(png_ptr == NULL) return;
d790 1
a790 1
#    ifdef PNG_HAVE_MMX_COMBINE_ROW
d793 1
a793 1
#    ifdef PNG_HAVE_MMX_READ_INTERLACE
d796 1
a796 1
#    ifndef PNG_HAVE_MMX_READ_FILTER_ROW
d813 1
a813 1
#  else /* !(PNGVCRD || PNGGCCRD) */
d821 1
a821 1
#endif /* !(PNG_MMX_CODE_SUPPORTED) */
d825 1
a825 1
    !(defined(PNG_MMX_CODE_SUPPORTED) && defined(PNG_USE_PNGVCRD))
d832 1
a832 1
#endif /* PNG_1_0_X  && PNG_ASSEMBLER_CODE_SUPPORTED */
@


1.1.107.5
log
@Import libpng-1.2.25 with the following change log.
Requested by bsiegert@@ due to security fix relevance.

version 1.2.19beta1 [May 18, 2007]
  Changed "const static" to "static PNG_CONST" everywhere, mostly undoing
    change of libpng-1.2.17beta2.  Changed other "const" to "PNG_CONST"
  Changed some handling of unused parameters, to avoid compiler warnings.
    "if (unused == NULL) return;" becomes "unused = unused".

version 1.2.19beta2 [May 18, 2007]
  Only use the valid bits of tRNS value in png_do_expand() (Brian Cartier)

version 1.2.19beta3 [May 19, 2007]
  Add some "png_byte" typecasts in png_check_keyword() and write new_key
  instead of key in zTXt chunk (Kevin Ryde).

version 1.2.19beta4 [May 21, 2007]
  Add png_snprintf() function and use it in place of sprint() for improved
    defense against buffer overflows.

version 1.2.19beta5 [May 21, 2007]
  Fixed png_handle_tRNS() to only use the valid bits of tRNS value.
  Changed handling of more unused parameters, to avoid compiler warnings.
  Removed some PNG_CONST in pngwutil.c to avoid compiler warnings.

version 1.2.19beta6 [May 22, 2007]
  Added some #ifdef PNG_MMX_CODE_SUPPORTED where needed in pngvcrd.c
  Added a special "_MSC_VER" case that defines png_snprintf to _snprintf

version 1.2.19beta7 [May 22, 2007]
  Squelched png_squelch_warnings() in pnggccrd.c and added an
    #ifdef PNG_MMX_CODE_SUPPORTED block around the declarations that caused
    the warnings that png_squelch_warnings was squelching.

version 1.2.19beta8 [May 22, 2007]
  Removed __MMX__ from test in pngconf.h.

version 1.2.19beta9 [May 23, 2007]
  Made png_squelch_warnings() available via PNG_SQUELCH_WARNINGS macro.
  Revised png_squelch_warnings() so it might work.
  Updated makefile.sgcc and makefile.solaris; added makefile.solaris-x86.

version 1.2.19beta10 [May 24, 2007]
  Resquelched png_squelch_warnings(), use "__attribute__((used))" instead.

version 1.2.19beta11 [May 28, 2007]
  Return 0 from png_get_sPLT() and png_get_unknown_chunks() if png_ptr is NULL;
    changed three remaining instances of png_strcpy() to png_strncpy() (David
    Hill).
  Make test for NULL row_buf at the beginning of png_do_read_transformations
    unconditional.

version 1.2.19beta12 [May 28, 2007]
  Revised pnggccrd.c.

version 1.2.19beta13 [June 14, 2007]
  Prefer PNG_USE_PNGVCRD when _MSC_VER is defined in pngconf.h

version 1.2.19beta14 [June 16, 2007]
  Fix bug with handling of 16-bit transparency, introduced in 1.2.19beta2

version 1.2.19beta15 [June 17, 2007]
  Revised pnggccrd.c.

version 1.2.19beta16 [June 18, 2007]
  Revised pnggccrd.c again.
  Updated contrib/gregbook.
  Changed '#include "pnggccrd.c"' to 'include "$srcdir/pnggccrd.c"'
    in configure.ac

version 1.2.19beta17 [June 19, 2007]
  Revised many of the makefiles, to set -DPNG_NO_MMX_CODE where needed
    and to not use -O3 unless -DPNG_NO_MMX_CODE is also set.

version 1.2.19beta18 [June 23, 2007]
  Replaced some C++ style comments with C style comments in pnggccrd.c.
  Copied optimized C code from pnggccrd.c to pngrutil.c, removed dependency
    on pnggccrd.o from many makefiles.
  Added sl and dylib to list of extensions be installed by Makefile.am

version 1.2.19beta19 [June 28, 2007]
  Fixed testing PNG_RGB_TO_GRAY_ERR & PNG_RGB_TO_GRAY_WARN in pngrtran.c
  More cleanup of pnggccrd.c and pngvcrd.c

version 1.2.19beta20 [June 29, 2007]
  Rebuilt Makefile.in and configure using libtool-1.5.24.
  Fixed typo in pnggccrd.c

version 1.2.19beta21 [June 30, 2007]
  More revision of pnggccrd.c
  Added "test" target to Makefile.in and Makefile.am

version 1.2.19beta22 [July 3, 2007]
  Added info about pngrutil/pnggccrd/pngvcrd to png_get_header_version()
  Fix type definition of dummy_value_a, b in pnggccrd.c

version 1.2.19beta23 [July 10, 2007]
  Revert change to type definition of dummy_value_a, b in pnggccrd.c
  Make sure __PIC__ is defined in pnggccrd.c when PIC is defined.
  Require gcc-4.1 or better to use PNG_HAVE_MMX_FILTER_ROW on x86_64 platforms

version 1.2.19beta24 [July 14, 2007]
  Added PNG_NO_READ_FILTER, PNG_NO_WRITE_FILTER, PNG_NO_WARNING macros.
  Added contrib/pngminim to demonstrate building minimal encoder and decoder

version 1.2.19beta25 [July 15, 2007]
  Removed the new PNG_NO_READ_FILTER macro since it would make the library
    unable to read valid PNG files, and filtering is at the heart of the
    PNG format.

version 1.2.19beta26 [July 16, 2007]
  Changed "png_free(str)" to "png_free(png_ptr,str)" in pngrutil.c WinCE
    code (Yves Piguet).  This bug was introduced in libpng-1.2.14.
  Updated scripts/CMakeLists.txt
  Relocated a misplaced #endif in pnggccrd.c

version 1.2.19beta27 [July 17, 2007]
  Fixed incorrect stride and number of bytes copied (was 4 instead of
    6 bytes) in the cleanup loop of pnggccrd.c and pngvcrd.c for handling
    the end of 48-bit interlaced rows (Glenn R-P).

version 1.2.19beta28 [July 19, 2007]
  Removed requirement for gcc-4.1 or better to use PNG_HAVE_MMX_FILTER_ROW
    on x86_64 platforms
  Added png_warning() in pngrutil.c for short iCCP, iTXt, sPLT, or zTXT chunks.
  Revised pngtest.c so warnings are displayed regardless of PNG_NO_STDIO.

version 1.2.19beta29 [July 20, 2007]
  Fix typo in pnggccrd.c (%%eax should be %%ax in secondloop48)

version 1.2.19beta30 [July 26, 2007]
  Revised pnggccrd.c

version 1.2.19beta31 [July 27, 2007]
  Fix typos in pnggccrd.c

version 1.0.27rc1 and 1.2.19rc1 [July 31, 2007]
  Disable PNG_MMX_CODE_SUPPORTED when PNG_ASSEMBLER_CODE_SUPPORTED is off.
  Enable PNG_MMX_READ_FILTER_* by default, except when gcc-3.x is being
    used (they were inadvertently disabled in libpng-1.2.19beta23).
  Fix some debugging statements in pnggccrd.c and pngrutil.c
  Added information about disabling the MMX code in libpng documentation.

version 1.0.27rc2 and 1.2.19rc2 [August 4, 2007]
  Removed some "#if 0" blocks.
  Made a global struct local in pngvcrd.c to make it thread safe.
  Issue a png_error() if application attempts to transform a row tht
    has not been initialized.

version 1.0.27rc3 and 1.2.19rc3 [August 9, 2007]
  Slightly revised pngvcrd.c

version 1.0.27rc4 and 1.2.19rc4 [August 9, 2007]
  Revised pnggccrd.c debugging change of rc1, which was broken.
  Revised scripts/CMakeLists.txt
  Change default to PNG_NO_GLOBAL_ARRAYS for MSVC.
  Turn off PNG_FLAG_ROW_INIT flag when setting transforms that expand pixels.

version 1.0.27rc5 and 1.2.19rc5 [August 10, 2007]
  Fix typo (missing '"') in pnggccrd.c
  Revise handling of png_strtod in recent versions of WINCE

version 1.0.27rc6 and 1.2.19rc6 [August 15, 2007]
  Fix typo (missing ',') in contrib/gregbook/readpng2.c
  Undid row initialization error exit added to rc2 and rc4.

version 1.0.27 and 1.2.19 [August 18, 2007]
  Conditionally restored row initialization error exit.

version 1.2.20beta01 [August 19, 2007]
  Fixed problem with compiling pnggccrd.c on Intel-Apple platforms.
  Changed png_malloc() to png_malloc_warn() in png_set_sPLT().
  Added PNG_NO_ERROR_TEXT feature, with demo in contrib/pngminim
  Removed define PNG_WARN_UNINITIALIZED_ROW 1 /* 0: warning; 1: error */
    because it caused some trouble.

version 1.2.20beta02 [August 20, 2007]
  Avoid compiling pnggccrd.c on Intel-Apple platforms.

version 1.2.20beta03 [August 20, 2007]
  Added "/D PNG_NO_MMX_CODE" to the non-mmx builds of projects/visualc6
    and visualc71.

version 1.2.20beta04 [August 21, 2007]
  Revised pngvcrd.c for improved efficiency (Steve Snyder).

version 1.2.20rc1 [August 23, 2007]
  Revised pngconf.h to set PNG_NO_MMX_CODE for gcc-3.x compilers.

version 1.2.20rc2 [August 27, 2007]
  Revised scripts/CMakeLists.txt
  Revised #ifdefs to ensure one and only one of pnggccrd.c, pngvcrd.c,
    or part of pngrutil.c is selected.

version 1.2.20rc3 [August 30, 2007]
  Remove a little more code in pngwutil.c when PNG_NO_WRITE_FILTER is selected.
  Added /D _CRT_SECURE_NO_WARNINGS to visual6c and visualc71 projects.
  Compile png_mmx_support() in png.c even when PNG_NO_MMX_CODE is defined.
  Restored a "superfluous" #ifdef that was removed from 1.2.20rc2 pnggccrd.c,
    breaking the png_mmx_support() function.

version 1.2.20rc4 [September 1, 2007]
  Removed Intel contributions (MMX, Optimized C).

version 1.2.20rc5 [September 2, 2007]
  Restored configure and Makefile.in to rc3 and put a snippet of code in
    pnggccrd.c, to ensure configure makes the same PNG_NO_MMX_CODE selection

version 1.2.20rc6 [September 2, 2007]
  Fixed bugs in scripts/CMakeLists.txt
  Removed pngvcrd.c references from msvc projects.

version 1.0.28 and 1.2.20 [September 8, 2007]
  Removed "(NO READ SUPPORT)" from png_get_header_version() string.

version 1.2.21beta1 [September 14, 2007]
  Fixed various mistakes reported by George Cook and Jeff Phillips:
  logical vs bitwise NOT in pngrtran.c, bug introduced in 1.2.19rc2
  16-bit cheap transparency expansion, bug introduced in 1.2.19beta2
  errors with sizeof(unknown_chunk.name), bugs introduced in 1.2.19beta11
  <= compare with unsigned var in pngset.c, should be ==.

version 1.2.21beta2 [September 18, 2007]
  Removed some extraneous typecasts.

version 1.2.21rc1 [September 25, 2007]
  Fixed potential out-of-bounds reads in png_handle_pCAL() and
    png_handle_ztXt() ("flayer" results reported by Tavis Ormandy).

version 1.2.21rc2 [September 26, 2007]
  Fixed potential out-of-bounds reads in png_handle_sCAL(),
    png_handle_iTXt(), and png_push_read_tEXt().
  Remove some PNG_CONST declarations from pngwutil.c to avoid compiler warnings
  Revised makefiles to update paths in libpng.pc properly.

version 1.2.21rc3 [September 27, 2007]
  Revised makefiles to update "Libs" in libpng.pc properly.

version 1.0.29 and 1.2.21rc3 [October 4, 2007]
  No changes.

version 1.2.22beta1 [October 4, 2007]
  Again, fixed logical vs bitwise NOT in pngrtran.c, bug introduced
    in 1.2.19rc2

version 1.2.22beta2 [October 5, 2007]
  Fixed string length error in pngset.c (caused crashes while decoding iCCP)
  Add terminating NULL after each instance of png_strncpy().

version 1.2.22beta3 [October 6, 2007]
  Fix two off-by-one terminating NULL after png_strncpy().

version 1.2.22beta4 [October 7, 2007]
  Changed some 0 to '\0'.

version 1.0.30rc1 and 1.2.22rc1 [October 8, 2007]
  No changes.

version 1.0.30 and 1.2.22 [October 13, 2007]
  No changes.

version 1.2.23beta01 [October 15, 2007]
  Reduced number of invocations of png_strlen() in pngset.c.
  Changed [azAZ09_] to [_abcde...89] in Makefile.am for better localization.

version 1.2.23beta02 [October 16, 2007]
  Eliminated png_strncpy() and png_strcpy() (Pierre Poissinger)
  Changed $AN to $(AN) in Makefile.am.

version 1.2.23beta03 [October 16, 2007]
  Fixed off-by-one error in pngset.c
  Restore statement to set last character of buffer to \0 in pngerror.c

version 1.2.23beta04 [October 23, 2007]
  Reject attempt to set all-zero cHRM values.

version 1.2.23beta05 [October 26, 2007]
  Add missing quotes in projects/visualc6, lost in version 1.2.20rc3

version 1.2.23rc01 [November 2, 2007]
  No changes.

version 1.2.23 [November 6, 2007]
  No changes.

version 1.2.24beta01 [November 19, 2007]
  Moved misplaced test for malloc failure in png_set_sPLT().  This bug was
    introduced in libpng-1.2.20beta01.
  Ifdef out avg_row etc from png.h and pngwrite.c when PNG_NO_WRITE_FILTER
  Do not use png_ptr->free_fn and png_ptr->mem_fn in png_destroy_read_struct()
    when png_ptr is NULL (Marshall Clow).
  Updated handling of symbol prefixes in Makefile.am and configure.ac (Mike
    Frysinger).

version 1.2.24beta02 [November 30, 2007]
  Removed a useless test and fixed incorrect test in png_set_cHRM_fixed()
    (David Hill).

version 1.2.24rc01 [December 7, 2007]
  No changes.

version 1.2.24     [December 14, 2007]
  Make sure not to redefine _BSD_SOURCE in pngconf.h
  Revised gather.sh and makefile.std in contrib/pngminim to avoid compiling
    unused files.

version 1.2.25beta01 [January 7, 2008]
  Fixed bug with unknown chunk handling, introduced in version 1.2.17rc2

version 1.2.25beta02 [January 10, 2008]
  Prevent gamma from being applied twice.

version 1.2.25rc01 [January 17, 2008]
  No changes.

version 1.2.25beta03 [January 22, 2008]
  Fixed some continue-after-malloc-failure errors in pngset.c (David Hill)
  Check for info_ptr == NULL in png_read_info() and png_process_data().
  Check for possible use of NULL user_png_ver[] in png_create_read_struct().
  Change "if (swidth == NULL)" to "if (sheight == NULL)" in png_handle_sCAL
    (bug introduced in libpng-1.2.4/1.0.13).
  Return from png_destroy_read_struct() if png_ptr_ptr is NULL.
  Fix overflow of "msg" in png_decompres_chunk().

version 1.2.25beta04 [January 26, 2008]
  Work around Coverity bug report by slightly refactoring
    png_read_push_finish_row()

version 1.2.25beta05 [January 31, 2008]
  Added libpng-1.2.25beta05.tar.lzma to distribution.  Get the lzma codec
    from <http://tukaani.org/lzma>.
  Added lp1225b05.7z to distribution.  Get the 7-zip decoder from
    from <http://www.7-zip.org>.
  Fixed some broken links in the README file.

version 1.2.25beta06 [February 6, 2008]
  Refactored png_read_push_finish_row() again, trying to satisfy Coverity.
  Fixed potential NULL dereference of png_ptr in png_destroy_write_struct();
  clarified potential NULL dereference of png_ptr in png_destroy_read_struct();
  fixed potential NULL dereference of info_ptr in png_handle_bKGD();
  fixed potential NULL dereference of user_png_ver[] in
    png_create_write_struct_2(). (Coverity)

version 1.2.25rc02 [February 10, 2008]
  Reset png_ptr->pass in png_read_push_finish_row() before break.
  Changed "pass" from png_byte to int.

version 1.2.25 and 1.0.31 [February 18, 2008]
  No changes.
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.21 October 4, 2007
d16 1
a16 1
typedef version_1_2_25 Your_png_h_is_not_version_1_2_25;
d23 1
a23 1
PNG_CONST char png_libpng_ver[18] = PNG_LIBPNG_VER_STRING;
d29 1
a29 1
PNG_CONST png_byte FARDATA png_sig[8] = {137, 80, 78, 71, 13, 10, 26, 10};
d59 1
a59 1
PNG_CONST int FARDATA png_pass_start[] = {0, 4, 0, 2, 0, 1, 0};
d62 1
a62 1
PNG_CONST int FARDATA png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1};
d65 1
a65 1
PNG_CONST int FARDATA png_pass_ystart[] = {0, 0, 4, 0, 2, 0, 1};
d68 6
a73 1
PNG_CONST int FARDATA png_pass_yinc[] = {8, 8, 8, 4, 4, 2, 2};
d77 1
a77 1
PNG_CONST int FARDATA png_pass_height[] = {8, 8, 4, 4, 2, 2, 1};
d81 1
a81 1
PNG_CONST int FARDATA png_pass_mask[] = {0x80, 0x08, 0x88, 0x22, 0xaa, 0x55, 0xff};
d84 1
a84 1
PNG_CONST int FARDATA png_pass_dsp_mask[]
d137 1
a137 1
 * future - use png_sig_cmp().  Returns true (nonzero) if the file is PNG.
d677 1
a677 1
      png_snprintf6(near_time_buf,29,"%d %s %d %02d:%02d:%02d +0000",
d685 1
a685 1
   png_snprintf6(png_ptr->time_buffer,29,"%d %s %d %02d:%02d:%02d +0000",
d695 8
d708 3
a710 3
   png_ptr = png_ptr;  /* silence compiler warning about unused png_ptr */
   return ((png_charp) "\n libpng version 1.2.25 - February 18, 2008\n\
   Copyright (c) 1998-2008 Glenn Randers-Pehrson\n\
d713 1
d728 3
a730 2
   png_ptr = png_ptr;  /* silence compiler warning about unused png_ptr */
   return ((png_charp) PNG_LIBPNG_VER_STRING);
d737 3
a739 2
   png_ptr = png_ptr;  /* silence compiler warning about unused png_ptr */
   return ((png_charp) PNG_LIBPNG_VER_STRING);
d746 3
a748 6
   png_ptr = png_ptr;  /* silence compiler warning about unused png_ptr */
   return ((png_charp) PNG_HEADER_VERSION_STRING
#ifndef PNG_READ_SUPPORTED
   "     (NO READ SUPPORT)"
#endif
   "\n");
d759 1
a759 1
   if(png_ptr == NULL || chunk_name == NULL || png_ptr->num_chunk_list<=0)
d789 48
d838 2
a842 1
   /* obsolete, to be removed from libpng-1.4.0 */
d845 3
a847 2
#endif /* PNG_1_0_X */
#endif /* PNG_READ_SUPPORTED && PNG_ASSEMBLER_CODE_SUPPORTED */
@


1.1.107.6
log
@*sigh*

sync with MirPortsâ€¦ they had another update
@
text
@d16 1
a16 1
typedef version_1_2_26 Your_png_h_is_not_version_1_2_26;
d696 1
a696 1
   return ((png_charp) "\n libpng version 1.2.26 - April 2, 2008\n\
@


1.1.107.7
log
@SECURITY update of libpng to 1.2.32
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.30 [August 15, 2008]
d6 1
a6 1
 * Copyright (c) 1998-2008 Glenn Randers-Pehrson
d16 1
a16 1
typedef version_1_2_32 Your_png_h_is_not_version_1_2_32;
d95 1
a95 1
   if (png_ptr == NULL) return;
d156 1
a156 1
   if (png_ptr == NULL) return (NULL);
d244 1
a244 1
   if (png_ptr == NULL) return (NULL);
d266 1
a266 1
   if (png_ptr == NULL) return;
d305 1
a305 1
   if (info_ptr == NULL) return;
d309 1
a309 1
   if (png_sizeof(png_info) > png_info_struct_size)
d317 1
a317 1
   png_memset(info_ptr, 0, png_sizeof(png_info));
d328 1
a328 1
   if (freer == PNG_DESTROY_WILL_FREE_DATA)
d330 1
a330 1
   else if (freer == PNG_USER_WILL_FREE_DATA)
a382 1
    info_ptr->trans = NULL;
d387 1
d462 1
a462 1
      if (info_ptr->splt_palettes)
d472 1
a472 1
       if (info_ptr->splt_palettes_num)
d488 1
a488 1
  if (png_ptr->unknown_chunk.data)
a492 1

d501 1
a501 1
       if (info_ptr->unknown_chunks)
d511 1
a511 1
       if (info_ptr->unknown_chunks_num)
d565 1
a565 1
    if (info_ptr->row_pointers)
d581 1
a581 1
   if (num == -1)
d604 1
a604 1
       png_ptr->num_chunk_list = 0;
d619 1
a619 1
   if (png_ptr == NULL) return (NULL);
d635 1
a635 1
   if (png_ptr == NULL) return;
d651 1
a651 1
   if (png_ptr == NULL) return (NULL);
d672 1
a672 1
      png_snprintf6(near_time_buf, 29, "%d %s %d %02d:%02d:%02d +0000",
d680 1
a680 1
   png_snprintf6(png_ptr->time_buffer, 29, "%d %s %d %02d:%02d:%02d +0000",
d696 1
a696 1
   return ((png_charp) "\n libpng version 1.2.32 - September 18, 2008\n\
d746 1
a746 1
   if (png_ptr == NULL || chunk_name == NULL || png_ptr->num_chunk_list<=0)
d748 2
a749 2
   p = png_ptr->chunk_list + png_ptr->num_chunk_list*5 - 5;
   for (i = png_ptr->num_chunk_list; i; i--, p -= 5)
d751 1
a751 1
        return ((int)*(p + 4));
@


1.1.107.8
log
@libpng 1.2.35
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.34 [December 18, 2008]
d16 1
a16 1
typedef version_1_2_35 Your_png_h_is_not_version_1_2_35;
d96 1
a96 1
   png_debug(1, "in png_set_sig_bytes");
d243 1
a243 1
   png_debug(1, "in png_create_info_struct");
d268 1
a268 1
   png_debug(1, "in png_destroy_info_struct");
d307 1
a307 1
   png_debug(1, "in png_info_init_3");
d325 1
a325 1
   png_debug(1, "in png_data_freer");
d342 1
a342 1
   png_debug(1, "in png_free_data");
d596 1
a596 1
   png_debug(1, "in png_info_destroy");
d635 1
a635 1
   png_debug(1, "in png_init_io");
d697 1
a697 1
   return ((png_charp) "\n libpng version 1.2.35 - February 14, 2009\n\
a798 112

/* Added at libpng version 1.2.34 and 1.4.0 (moved from pngset.c) */
#if defined(PNG_cHRM_SUPPORTED)
#if !defined(PNG_NO_CHECK_cHRM)
/*
 Multiply two 32-bit numbers, V1 and V2, using 32-bit
 arithmetic, to produce a 64 bit result in the HI/LO words.

          A B
        x C D
       ------
      AD || BD
AC || CB || 0

 where A and B are the high and low 16-bit words of V1,
 C and D are the 16-bit words of V2, AD is the product of
 A and D, and X || Y is (X << 16) + Y.
*/

void png_64bit_product (long v1, long v2, unsigned long *hi_product,
   unsigned long *lo_product)
{
 int a, b, c, d;
 long lo, hi, x, y;

 a = (v1 >> 16) & 0xffff;
 b = v1 & 0xffff;
 c = (v2 >> 16) & 0xffff;
 d = v2 & 0xffff;

 lo = b * d;                   /* BD */
 x = a * d + c * b;            /* AD + CB */
 y = ((lo >> 16) & 0xffff) + x;

 lo = (lo & 0xffff) | ((y & 0xffff) << 16);
 hi = (y >> 16) & 0xffff;

 hi += a * c;                  /* AC */

 *hi_product = (unsigned long)hi;
 *lo_product = (unsigned long)lo;
}
int /* private */
png_check_cHRM_fixed(png_structp png_ptr,
   png_fixed_point white_x, png_fixed_point white_y, png_fixed_point red_x,
   png_fixed_point red_y, png_fixed_point green_x, png_fixed_point green_y,
   png_fixed_point blue_x, png_fixed_point blue_y)
{
   int ret = 1;
   unsigned long xy_hi,xy_lo,yx_hi,yx_lo;

   png_debug(1, "in function png_check_cHRM_fixed");
   if (png_ptr == NULL)
      return 0;

   if (white_x < 0 || white_y <= 0 ||
         red_x < 0 ||   red_y <  0 ||
       green_x < 0 || green_y <  0 ||
        blue_x < 0 ||  blue_y <  0)
   {
      png_warning(png_ptr,
        "Ignoring attempt to set negative chromaticity value");
      ret = 0;
   }
   if (white_x > (png_fixed_point) PNG_UINT_31_MAX ||
       white_y > (png_fixed_point) PNG_UINT_31_MAX ||
         red_x > (png_fixed_point) PNG_UINT_31_MAX ||
         red_y > (png_fixed_point) PNG_UINT_31_MAX ||
       green_x > (png_fixed_point) PNG_UINT_31_MAX ||
       green_y > (png_fixed_point) PNG_UINT_31_MAX ||
        blue_x > (png_fixed_point) PNG_UINT_31_MAX ||
        blue_y > (png_fixed_point) PNG_UINT_31_MAX )
   {
      png_warning(png_ptr,
        "Ignoring attempt to set chromaticity value exceeding 21474.83");
      ret = 0;
   }
   if (white_x > 100000L - white_y)
   {
      png_warning(png_ptr, "Invalid cHRM white point");
      ret = 0;
   }
   if (red_x > 100000L - red_y)
   {
      png_warning(png_ptr, "Invalid cHRM red point");
      ret = 0;
   }
   if (green_x > 100000L - green_y)
   {
      png_warning(png_ptr, "Invalid cHRM green point");
      ret = 0;
   }
   if (blue_x > 100000L - blue_y)
   {
      png_warning(png_ptr, "Invalid cHRM blue point");
      ret = 0;
   }

   png_64bit_product(green_x - red_x, blue_y - red_y, &xy_hi, &xy_lo);
   png_64bit_product(green_y - red_y, blue_x - red_x, &yx_hi, &yx_lo);

   if (xy_hi == yx_hi && xy_lo == yx_lo)
   {
      png_warning(png_ptr,
         "Ignoring attempt to set cHRM RGB triangle with zero area");
      ret = 0;
   }

   return ret;
}
#endif /* NO_PNG_CHECK_cHRM */
#endif /* PNG_cHRM_SUPPORTED */
@


1.1.107.9
log
@Update libpng in the base system, too
@
text
@d4 3
a6 2
 * Last changed in libpng 1.2.46 [February 25, 2011]
 * Copyright (c) 1998-2011 Glenn Randers-Pehrson
a8 4
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
a12 1
#define PNG_NO_PEDANTIC_WARNINGS
d16 1
a16 1
typedef version_1_2_50 Your_png_h_is_not_version_1_2_50;
d19 1
a19 2
 * string defined in png.h.
 */
d56 1
a56 1
/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
d58 1
a58 1
/* Start of interlace block */
d61 1
a61 1
/* Offset to next interlace block */
d64 1
a64 1
/* Start of interlace block in the y direction */
d67 1
a67 1
/* Offset to next interlace block in the y direction */
d76 1
a76 2
PNG_CONST int FARDATA png_pass_mask[] =
    {0x80, 0x08, 0x88, 0x22, 0xaa, 0x55, 0xff};
d95 1
a96 4

   if (png_ptr == NULL)
      return;

d147 1
a147 1
voidpf /* PRIVATE */
d156 1
a156 2
   if (png_ptr == NULL)
      return (NULL);
d186 1
a186 1
/* Function to free memory for zlib */
d190 1
a190 1
void /* PRIVATE */
d244 1
a244 4

   if (png_ptr == NULL)
      return (NULL);

d266 1
a268 4

   if (png_ptr == NULL)
      return;

d305 2
a308 3
   if (info_ptr == NULL)
      return;

d310 5
a314 5
   {
      png_destroy_struct(info_ptr);
      info_ptr = (png_infop)png_create_struct(PNG_STRUCT_INFO);
      *ptr_ptr = info_ptr;
   }
d316 1
a316 1
   /* Set everything to 0 */
a325 1

a327 1

a342 1

d346 2
a347 2
#ifdef PNG_TEXT_SUPPORTED
   /* Free text item num or (if num == -1) all text items */
d349 1
a349 1
   if ((mask & PNG_FREE_TEXT) & info_ptr->free_me)
d351 1
a351 1
   if (mask & PNG_FREE_TEXT)
d353 10
d364 6
a369 17
      if (num != -1)
      {
         if (info_ptr->text && info_ptr->text[num].key)
         {
            png_free(png_ptr, info_ptr->text[num].key);
            info_ptr->text[num].key = NULL;
         }
      }
      else
      {
         int i;
         for (i = 0; i < info_ptr->num_text; i++)
             png_free_data(png_ptr, info_ptr, PNG_FREE_TEXT, i);
         png_free(png_ptr, info_ptr->text);
         info_ptr->text = NULL;
         info_ptr->num_text=0;
      }
d371 1
d374 2
a375 2
#ifdef PNG_tRNS_SUPPORTED
   /* Free any tRNS entry */
d377 1
a377 1
   if ((mask & PNG_FREE_TRNS) & info_ptr->free_me)
d379 1
a379 1
   if ((mask & PNG_FREE_TRNS) && (png_ptr->flags & PNG_FLAG_FREE_TRNS))
d381 4
a384 4
   {
      png_free(png_ptr, info_ptr->trans);
      info_ptr->trans = NULL;
      info_ptr->valid &= ~PNG_INFO_tRNS;
d386 1
a386 1
      png_ptr->flags &= ~PNG_FLAG_FREE_TRNS;
d388 1
a388 1
   }
d391 2
a392 2
#ifdef PNG_sCAL_SUPPORTED
   /* Free any sCAL entry */
d394 1
a394 1
   if ((mask & PNG_FREE_SCAL) & info_ptr->free_me)
d396 1
a396 1
   if (mask & PNG_FREE_SCAL)
d398 1
a398 1
   {
d400 4
a403 4
      png_free(png_ptr, info_ptr->scal_s_width);
      png_free(png_ptr, info_ptr->scal_s_height);
      info_ptr->scal_s_width = NULL;
      info_ptr->scal_s_height = NULL;
d405 2
a406 2
      info_ptr->valid &= ~PNG_INFO_sCAL;
   }
d409 2
a410 2
#ifdef PNG_pCAL_SUPPORTED
   /* Free any pCAL entry */
d412 1
a412 1
   if ((mask & PNG_FREE_PCAL) & info_ptr->free_me)
d414 1
a414 1
   if (mask & PNG_FREE_PCAL)
d416 18
a433 18
   {
      png_free(png_ptr, info_ptr->pcal_purpose);
      png_free(png_ptr, info_ptr->pcal_units);
      info_ptr->pcal_purpose = NULL;
      info_ptr->pcal_units = NULL;
      if (info_ptr->pcal_params != NULL)
         {
            int i;
            for (i = 0; i < (int)info_ptr->pcal_nparams; i++)
            {
               png_free(png_ptr, info_ptr->pcal_params[i]);
               info_ptr->pcal_params[i] = NULL;
            }
            png_free(png_ptr, info_ptr->pcal_params);
            info_ptr->pcal_params = NULL;
         }
      info_ptr->valid &= ~PNG_INFO_pCAL;
   }
d436 2
a437 2
#ifdef PNG_iCCP_SUPPORTED
   /* Free any iCCP entry */
d439 1
a439 1
   if ((mask & PNG_FREE_ICCP) & info_ptr->free_me)
d441 1
a441 1
   if (mask & PNG_FREE_ICCP)
d443 7
a449 7
   {
      png_free(png_ptr, info_ptr->iccp_name);
      png_free(png_ptr, info_ptr->iccp_profile);
      info_ptr->iccp_name = NULL;
      info_ptr->iccp_profile = NULL;
      info_ptr->valid &= ~PNG_INFO_iCCP;
   }
d452 2
a453 2
#ifdef PNG_sPLT_SUPPORTED
   /* Free a given sPLT entry, or (if num == -1) all sPLT entries */
d455 1
a455 1
   if ((mask & PNG_FREE_SPLT) & info_ptr->free_me)
d457 1
a457 1
   if (mask & PNG_FREE_SPLT)
d459 2
d462 1
a462 1
      if (num != -1)
d464 4
a467 21
         if (info_ptr->splt_palettes)
         {
            png_free(png_ptr, info_ptr->splt_palettes[num].name);
            png_free(png_ptr, info_ptr->splt_palettes[num].entries);
            info_ptr->splt_palettes[num].name = NULL;
            info_ptr->splt_palettes[num].entries = NULL;
         }
      }
      else
      {
         if (info_ptr->splt_palettes_num)
         {
            int i;
            for (i = 0; i < (int)info_ptr->splt_palettes_num; i++)
               png_free_data(png_ptr, info_ptr, PNG_FREE_SPLT, i);

            png_free(png_ptr, info_ptr->splt_palettes);
            info_ptr->splt_palettes = NULL;
            info_ptr->splt_palettes_num = 0;
         }
         info_ptr->valid &= ~PNG_INFO_sPLT;
d470 15
d487 6
a492 6
#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED
   if (png_ptr->unknown_chunk.data)
   {
      png_free(png_ptr, png_ptr->unknown_chunk.data);
      png_ptr->unknown_chunk.data = NULL;
   }
d495 1
a495 1
   if ((mask & PNG_FREE_UNKN) & info_ptr->free_me)
d497 1
a497 1
   if (mask & PNG_FREE_UNKN)
d499 10
d510 6
a515 11
      if (num != -1)
      {
          if (info_ptr->unknown_chunks)
          {
             png_free(png_ptr, info_ptr->unknown_chunks[num].data);
             info_ptr->unknown_chunks[num].data = NULL;
          }
      }
      else
      {
         int i;
d517 4
a520 10
         if (info_ptr->unknown_chunks_num)
         {
            for (i = 0; i < (int)info_ptr->unknown_chunks_num; i++)
               png_free_data(png_ptr, info_ptr, PNG_FREE_UNKN, i);

            png_free(png_ptr, info_ptr->unknown_chunks);
            info_ptr->unknown_chunks = NULL;
            info_ptr->unknown_chunks_num = 0;
         }
      }
d522 1
d525 2
a526 2
#ifdef PNG_hIST_SUPPORTED
   /* Free any hIST entry */
d528 1
a528 1
   if ((mask & PNG_FREE_HIST)  & info_ptr->free_me)
d530 1
a530 1
   if ((mask & PNG_FREE_HIST) && (png_ptr->flags & PNG_FLAG_FREE_HIST))
d532 4
a535 4
   {
      png_free(png_ptr, info_ptr->hist);
      info_ptr->hist = NULL;
      info_ptr->valid &= ~PNG_INFO_hIST;
d537 1
a537 1
      png_ptr->flags &= ~PNG_FLAG_FREE_HIST;
d539 1
a539 1
   }
d542 1
a542 1
   /* Free any PLTE entry that was internally allocated */
d544 1
a544 1
   if ((mask & PNG_FREE_PLTE) & info_ptr->free_me)
d546 1
a546 1
   if ((mask & PNG_FREE_PLTE) && (png_ptr->flags & PNG_FLAG_FREE_PLTE))
d548 4
a551 4
   {
      png_zfree(png_ptr, info_ptr->palette);
      info_ptr->palette = NULL;
      info_ptr->valid &= ~PNG_INFO_PLTE;
d553 1
a553 1
      png_ptr->flags &= ~PNG_FLAG_FREE_PLTE;
d555 2
a556 2
      info_ptr->num_palette = 0;
   }
d558 2
a559 2
#ifdef PNG_INFO_IMAGE_SUPPORTED
   /* Free any image bits attached to the info structure */
d561 1
a561 1
   if ((mask & PNG_FREE_ROWS) & info_ptr->free_me)
d563 1
a563 1
   if (mask & PNG_FREE_ROWS)
d565 14
a578 14
   {
      if (info_ptr->row_pointers)
      {
         int row;
         for (row = 0; row < (int)info_ptr->height; row++)
         {
            png_free(png_ptr, info_ptr->row_pointers[row]);
            info_ptr->row_pointers[row] = NULL;
         }
         png_free(png_ptr, info_ptr->row_pointers);
         info_ptr->row_pointers = NULL;
      }
      info_ptr->valid &= ~PNG_INFO_IDAT;
   }
d583 1
a583 1
      info_ptr->free_me &= ~mask;
d585 1
a585 1
      info_ptr->free_me &= ~(mask & ~PNG_FREE_MUL);
d600 1
a600 1
#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
d603 3
a605 3
      png_free(png_ptr, png_ptr->chunk_list);
      png_ptr->chunk_list = NULL;
      png_ptr->num_chunk_list = 0;
d620 1
a620 2
   if (png_ptr == NULL)
      return (NULL);
d625 1
a625 1
#ifdef PNG_STDIO_SUPPORTED
d636 1
a636 4

   if (png_ptr == NULL)
      return;

d641 1
a641 1
#ifdef PNG_TIME_RFC1123_SUPPORTED
d652 1
a652 2
   if (png_ptr == NULL)
      return (NULL);
d659 1
a659 1
#ifdef _WIN32_WCE
d666 2
a667 2
      WideCharToMultiByte(CP_ACP, 0, time_buf, -1, png_ptr->time_buffer,
          29, NULL, NULL);
d696 5
a700 18
   png_ptr = png_ptr;  /* Silence compiler warning about unused png_ptr */
#ifdef PNG_STRING_COPYRIGHT
      return PNG_STRING_COPYRIGHT
#else
#ifdef __STDC__
   return ((png_charp) PNG_STRING_NEWLINE \
     "libpng version 1.2.50 - July 10, 2012" PNG_STRING_NEWLINE \
     "Copyright (c) 1998-2011 Glenn Randers-Pehrson" PNG_STRING_NEWLINE \
     "Copyright (c) 1996-1997 Andreas Dilger" PNG_STRING_NEWLINE \
     "Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc." \
     PNG_STRING_NEWLINE);
#else
      return ((png_charp) "libpng version 1.2.50 - July 10, 2012\
      Copyright (c) 1998-2011 Glenn Randers-Pehrson\
      Copyright (c) 1996-1997 Andreas Dilger\
      Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.");
#endif
#endif
d715 1
a715 1
   png_ptr = png_ptr;  /* Silence compiler warning about unused png_ptr */
d723 1
a723 1
   png_ptr = png_ptr;  /* Silence compiler warning about unused png_ptr */
d731 1
a731 2
   png_ptr = png_ptr;  /* Silence compiler warning about unused png_ptr */
#ifdef __STDC__
d736 1
a736 4
   PNG_STRING_NEWLINE);
#else
   return ((png_charp) PNG_HEADER_VERSION_STRING);
#endif
d744 1
a744 1
   /* Check chunk_name and return "keep" value if it's on the list, else 0 */
d761 1
a761 2
   if (png_ptr == NULL)
      return Z_STREAM_ERROR;
d776 2
a777 2
#ifndef PNG_1_0_X
/* This function was added to libpng 1.2.0 */
d781 1
a781 1
   /* Obsolete, to be removed from libpng-1.4.0 */
d794 3
a796 3
   if (size > (png_size_t)-1)
      PNG_ABORT();  /* We haven't got access to png_ptr, so no png_error() */
   return ((png_size_t)size);
d801 5
a805 2
#ifdef PNG_cHRM_SUPPORTED
#ifdef PNG_CHECK_cHRM_SUPPORTED
d807 9
a815 13
/*
 *    Multiply two 32-bit numbers, V1 and V2, using 32-bit
 *    arithmetic, to produce a 64 bit result in the HI/LO words.
 *
 *                  A B
 *                x C D
 *               ------
 *              AD || BD
 *        AC || CB || 0
 *
 *    where A and B are the high and low 16-bit words of V1,
 *    C and D are the 16-bit words of V2, AD is the product of
 *    A and D, and X || Y is (X << 16) + Y.
d818 1
a818 2
void /* PRIVATE */
png_64bit_product (long v1, long v2, unsigned long *hi_product,
d821 2
a822 2
   int a, b, c, d;
   long lo, hi, x, y;
d824 4
a827 4
   a = (v1 >> 16) & 0xffff;
   b = v1 & 0xffff;
   c = (v2 >> 16) & 0xffff;
   d = v2 & 0xffff;
d829 3
a831 3
   lo = b * d;                   /* BD */
   x = a * d + c * b;            /* AD + CB */
   y = ((lo >> 16) & 0xffff) + x;
d833 2
a834 2
   lo = (lo & 0xffff) | ((y & 0xffff) << 16);
   hi = (y >> 16) & 0xffff;
d836 1
a836 1
   hi += a * c;                  /* AC */
d838 2
a839 2
   *hi_product = (unsigned long)hi;
   *lo_product = (unsigned long)lo;
d841 1
a841 2

int /* PRIVATE */
a850 1

d909 1
a909 1
#endif /* PNG_CHECK_cHRM_SUPPORTED */
a910 142

void /* PRIVATE */
png_check_IHDR(png_structp png_ptr,
   png_uint_32 width, png_uint_32 height, int bit_depth,
   int color_type, int interlace_type, int compression_type,
   int filter_type)
{
   int error = 0;

   /* Check for width and height valid values */
   if (width == 0)
   {
      png_warning(png_ptr, "Image width is zero in IHDR");
      error = 1;
   }

   if (height == 0)
   {
      png_warning(png_ptr, "Image height is zero in IHDR");
      error = 1;
   }

#ifdef PNG_SET_USER_LIMITS_SUPPORTED
   if (width > png_ptr->user_width_max || width > PNG_USER_WIDTH_MAX)
#else
   if (width > PNG_USER_WIDTH_MAX)
#endif
   {
      png_warning(png_ptr, "Image width exceeds user limit in IHDR");
      error = 1;
   }

#ifdef PNG_SET_USER_LIMITS_SUPPORTED
   if (height > png_ptr->user_height_max || height > PNG_USER_HEIGHT_MAX)
#else
   if (height > PNG_USER_HEIGHT_MAX)
#endif
   {
      png_warning(png_ptr, "Image height exceeds user limit in IHDR");
      error = 1;
   }

   if (width > PNG_UINT_31_MAX)
   {
      png_warning(png_ptr, "Invalid image width in IHDR");
      error = 1;
   }

   if ( height > PNG_UINT_31_MAX)
   {
      png_warning(png_ptr, "Invalid image height in IHDR");
      error = 1;
   }

   if ( width > (PNG_UINT_32_MAX
                 >> 3)      /* 8-byte RGBA pixels */
                 - 64       /* bigrowbuf hack */
                 - 1        /* filter byte */
                 - 7*8      /* rounding of width to multiple of 8 pixels */
                 - 8)       /* extra max_pixel_depth pad */
      png_warning(png_ptr, "Width is too large for libpng to process pixels");

   /* Check other values */
   if (bit_depth != 1 && bit_depth != 2 && bit_depth != 4 &&
       bit_depth != 8 && bit_depth != 16)
   {
      png_warning(png_ptr, "Invalid bit depth in IHDR");
      error = 1;
   }

   if (color_type < 0 || color_type == 1 ||
       color_type == 5 || color_type > 6)
   {
      png_warning(png_ptr, "Invalid color type in IHDR");
      error = 1;
   }

   if (((color_type == PNG_COLOR_TYPE_PALETTE) && bit_depth > 8) ||
       ((color_type == PNG_COLOR_TYPE_RGB ||
         color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||
         color_type == PNG_COLOR_TYPE_RGB_ALPHA) && bit_depth < 8))
   {
      png_warning(png_ptr, "Invalid color type/bit depth combination in IHDR");
      error = 1;
   }

   if (interlace_type >= PNG_INTERLACE_LAST)
   {
      png_warning(png_ptr, "Unknown interlace method in IHDR");
      error = 1;
   }

   if (compression_type != PNG_COMPRESSION_TYPE_BASE)
   {
      png_warning(png_ptr, "Unknown compression method in IHDR");
      error = 1;
   }

#ifdef PNG_MNG_FEATURES_SUPPORTED
   /* Accept filter_method 64 (intrapixel differencing) only if
    * 1. Libpng was compiled with PNG_MNG_FEATURES_SUPPORTED and
    * 2. Libpng did not read a PNG signature (this filter_method is only
    *    used in PNG datastreams that are embedded in MNG datastreams) and
    * 3. The application called png_permit_mng_features with a mask that
    *    included PNG_FLAG_MNG_FILTER_64 and
    * 4. The filter_method is 64 and
    * 5. The color_type is RGB or RGBA
    */
   if ((png_ptr->mode & PNG_HAVE_PNG_SIGNATURE) &&
       png_ptr->mng_features_permitted)
      png_warning(png_ptr, "MNG features are not allowed in a PNG datastream");

   if (filter_type != PNG_FILTER_TYPE_BASE)
   {
      if (!((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&
         (filter_type == PNG_INTRAPIXEL_DIFFERENCING) &&
         ((png_ptr->mode & PNG_HAVE_PNG_SIGNATURE) == 0) &&
         (color_type == PNG_COLOR_TYPE_RGB ||
         color_type == PNG_COLOR_TYPE_RGB_ALPHA)))
      {
         png_warning(png_ptr, "Unknown filter method in IHDR");
         error = 1;
      }

      if (png_ptr->mode & PNG_HAVE_PNG_SIGNATURE)
      {
         png_warning(png_ptr, "Invalid filter method in IHDR");
         error = 1;
      }
   }

#else
   if (filter_type != PNG_FILTER_TYPE_BASE)
   {
      png_warning(png_ptr, "Unknown filter method in IHDR");
      error = 1;
   }
#endif

   if (error == 1)
      png_error(png_ptr, "Invalid IHDR data");
}
@


1.1.107.10
log
@update libpng
@
text
@d4 2
a5 2
 * Last changed in libpng 1.2.57 [December 29, 2016]
 * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
d20 1
a20 1
typedef version_1_2_57 Your_png_h_is_not_version_1_2_57;
d161 2
a162 2
   png_structp p;
   png_uint_32 save_flags;
a166 4

   p=(png_structp)png_ptr;
   save_flags=p->flags;

a330 2
      if (info_ptr == NULL)
         return;
a389 1
         info_ptr->max_text=0;
a677 1

d688 1
a688 1
          ptime->day % 32, short_months[(ptime->month - 1U) % 12],
d699 1
a699 1
          ptime->day % 32, short_months[(ptime->month - 1U) % 12],
d707 1
a707 1
       ptime->day % 32, short_months[(ptime->month - 1U) % 12],
d721 1
a721 1
   PNG_UNUSED(png_ptr)  /* Silence compiler warning about unused png_ptr */
d727 2
a728 3
     "libpng version 1.2.57 - December 29, 2016" PNG_STRING_NEWLINE \
     "Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson" \
     PNG_STRING_NEWLINE \
d733 2
a734 2
   return ((png_charp) "libpng version 1.2.57 - December 29, 2016\
      Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson\
d753 1
a753 1
   PNG_UNUSED(png_ptr)  /* Silence compiler warning about unused png_ptr */
d761 1
a761 1
   PNG_UNUSED(png_ptr)  /* Silence compiler warning about unused png_ptr */
d769 1
a769 1
   PNG_UNUSED(png_ptr) /* Silence compiler warning about unused png_ptr */
d1012 8
@


