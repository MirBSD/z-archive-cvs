head	1.6;
access;
symbols
	png-1_2_57:1.1.107.8
	png-1_2_50:1.1.107.7
	png-1_2_35:1.1.107.6
	png-1_2_32:1.1.107.5
	png-1_2_26:1.1.107.4
	png-1_2_25:1.1.107.4
	MIRBSD_10:1.1.107.3.0.2
	MIRBSD_10_BASE:1.1.107.3
	png-1_2_18:1.1.107.3
	png-1_2_12:1.1.107.2
	MIRBSD_9_BASE:1.1.107.2
	png-1_2_10:1.1.107.2
	MIRBSD_8:1.1.107.1.0.2
	MIRBSD_8_BASE:1.1.107.1
	png-1_2_8:1.1.107.1
	libpng:1.1.107;
locks; strict;
comment	@ * @;


1.6
date	2017.04.15.15.26.50;	author tg;	state Exp;
branches;
next	1.5;
commitid	10058F23BCC5ED04858;

1.5
date	2013.08.06.18.49.32;	author tg;	state Exp;
branches;
next	1.4;
commitid	1005201454765C5CF06;

1.4
date	2009.03.15.20.08.47;	author tg;	state Exp;
branches;
next	1.3;
commitid	10049BD605834002F74;

1.3
date	2008.10.22.19.11.52;	author tg;	state Exp;
branches;
next	1.2;
commitid	10048FF7AEF54F9B169;

1.2
date	2008.03.23.17.54.56;	author tg;	state Exp;
branches;
next	1.1;
commitid	10047E6997C6BB35CA9;

1.1
date	2005.03.06.15.16.20;	author tg;	state Exp;
branches
	1.1.107.1;
next	;

1.1.107.1
date	2005.03.06.15.16.20;	author tg;	state Exp;
branches;
next	1.1.107.2;

1.1.107.2
date	2006.06.09.00.13.10;	author tg;	state Exp;
branches;
next	1.1.107.3;
commitid	1004488BD054F510AF1;

1.1.107.3
date	2007.05.22.20.25.38;	author tg;	state Exp;
branches;
next	1.1.107.4;
commitid	100465351CF4103214A;

1.1.107.4
date	2008.03.23.17.15.18;	author tg;	state Exp;
branches;
next	1.1.107.5;
commitid	10047E69020419198D8;

1.1.107.5
date	2008.10.22.18.55.39;	author tg;	state Exp;
branches;
next	1.1.107.6;
commitid	10048FF773834003AB5;

1.1.107.6
date	2009.03.15.19.57.25;	author tg;	state Exp;
branches;
next	1.1.107.7;
commitid	10049BD5DB90DBE42DE;

1.1.107.7
date	2013.08.06.17.35.02;	author tg;	state Exp;
branches;
next	1.1.107.8;
commitid	100520133D730551D16;

1.1.107.8
date	2017.04.15.15.00.12;	author tg;	state Exp;
branches;
next	;
commitid	10058F2359276DB0E16;


desc
@@


1.6
log
@a rather slow fastmergeâ€¦
@
text
@
/* pngset.c - storage of image information into info struct
 *
 * Last changed in libpng 1.2.56 [December 17, 2015]
 * Copyright (c) 1998-2002,2004,2006-2015 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 *
 * The functions here are used during reads to store data from the file
 * into the info struct, and during writes to store application data
 * into the info struct for writing into the file.  This abstracts the
 * info struct and allows us to change the structure in the future.
 */

#define PNG_INTERNAL
#define PNG_NO_PEDANTIC_WARNINGS
#include "png.h"
#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)

#ifdef PNG_bKGD_SUPPORTED
void PNGAPI
png_set_bKGD(png_structp png_ptr, png_infop info_ptr, png_color_16p background)
{
   png_debug1(1, "in %s storage function", "bKGD");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   png_memcpy(&(info_ptr->background), background, png_sizeof(png_color_16));
   info_ptr->valid |= PNG_INFO_bKGD;
}
#endif

#ifdef PNG_cHRM_SUPPORTED
#ifdef PNG_FLOATING_POINT_SUPPORTED
void PNGAPI
png_set_cHRM(png_structp png_ptr, png_infop info_ptr,
   double white_x, double white_y, double red_x, double red_y,
   double green_x, double green_y, double blue_x, double blue_y)
{
   png_debug1(1, "in %s storage function", "cHRM");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   info_ptr->x_white = (float)white_x;
   info_ptr->y_white = (float)white_y;
   info_ptr->x_red   = (float)red_x;
   info_ptr->y_red   = (float)red_y;
   info_ptr->x_green = (float)green_x;
   info_ptr->y_green = (float)green_y;
   info_ptr->x_blue  = (float)blue_x;
   info_ptr->y_blue  = (float)blue_y;
#ifdef PNG_FIXED_POINT_SUPPORTED
   info_ptr->int_x_white = (png_fixed_point)(white_x*100000.+0.5);
   info_ptr->int_y_white = (png_fixed_point)(white_y*100000.+0.5);
   info_ptr->int_x_red   = (png_fixed_point)(  red_x*100000.+0.5);
   info_ptr->int_y_red   = (png_fixed_point)(  red_y*100000.+0.5);
   info_ptr->int_x_green = (png_fixed_point)(green_x*100000.+0.5);
   info_ptr->int_y_green = (png_fixed_point)(green_y*100000.+0.5);
   info_ptr->int_x_blue  = (png_fixed_point)( blue_x*100000.+0.5);
   info_ptr->int_y_blue  = (png_fixed_point)( blue_y*100000.+0.5);
#endif
   info_ptr->valid |= PNG_INFO_cHRM;
}
#endif /* PNG_FLOATING_POINT_SUPPORTED */

#ifdef PNG_FIXED_POINT_SUPPORTED
void PNGAPI
png_set_cHRM_fixed(png_structp png_ptr, png_infop info_ptr,
   png_fixed_point white_x, png_fixed_point white_y, png_fixed_point red_x,
   png_fixed_point red_y, png_fixed_point green_x, png_fixed_point green_y,
   png_fixed_point blue_x, png_fixed_point blue_y)
{
   png_debug1(1, "in %s storage function", "cHRM fixed");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

#ifdef PNG_CHECK_cHRM_SUPPORTED
   if (png_check_cHRM_fixed(png_ptr,
      white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y))
#endif
   {
      info_ptr->int_x_white = white_x;
      info_ptr->int_y_white = white_y;
      info_ptr->int_x_red   = red_x;
      info_ptr->int_y_red   = red_y;
      info_ptr->int_x_green = green_x;
      info_ptr->int_y_green = green_y;
      info_ptr->int_x_blue  = blue_x;
      info_ptr->int_y_blue  = blue_y;
#ifdef  PNG_FLOATING_POINT_SUPPORTED
      info_ptr->x_white = (float)(white_x/100000.);
      info_ptr->y_white = (float)(white_y/100000.);
      info_ptr->x_red   = (float)(  red_x/100000.);
      info_ptr->y_red   = (float)(  red_y/100000.);
      info_ptr->x_green = (float)(green_x/100000.);
      info_ptr->y_green = (float)(green_y/100000.);
      info_ptr->x_blue  = (float)( blue_x/100000.);
      info_ptr->y_blue  = (float)( blue_y/100000.);
#endif
      info_ptr->valid |= PNG_INFO_cHRM;
   }
}
#endif /* PNG_FIXED_POINT_SUPPORTED */
#endif /* PNG_cHRM_SUPPORTED */

#ifdef PNG_gAMA_SUPPORTED
#ifdef PNG_FLOATING_POINT_SUPPORTED
void PNGAPI
png_set_gAMA(png_structp png_ptr, png_infop info_ptr, double file_gamma)
{
   double png_gamma;

   png_debug1(1, "in %s storage function", "gAMA");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   /* Check for overflow */
   if (file_gamma > 21474.83)
   {
      png_warning(png_ptr, "Limiting gamma to 21474.83");
      png_gamma=21474.83;
   }
   else
      png_gamma = file_gamma;
   info_ptr->gamma = (float)png_gamma;
#ifdef PNG_FIXED_POINT_SUPPORTED
   info_ptr->int_gamma = (int)(png_gamma*100000.+.5);
#endif
   info_ptr->valid |= PNG_INFO_gAMA;
   if (png_gamma == 0.0)
      png_warning(png_ptr, "Setting gamma=0");
}
#endif
void PNGAPI
png_set_gAMA_fixed(png_structp png_ptr, png_infop info_ptr, png_fixed_point
   int_gamma)
{
   png_fixed_point png_gamma;

   png_debug1(1, "in %s storage function", "gAMA");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   if (int_gamma > (png_fixed_point)PNG_UINT_31_MAX)
   {
      png_warning(png_ptr, "Limiting gamma to 21474.83");
      png_gamma=PNG_UINT_31_MAX;
   }
   else
   {
      if (int_gamma < 0)
      {
         png_warning(png_ptr, "Setting negative gamma to zero");
         png_gamma = 0;
      }
      else
         png_gamma = int_gamma;
   }
#ifdef PNG_FLOATING_POINT_SUPPORTED
   info_ptr->gamma = (float)(png_gamma/100000.);
#endif
#ifdef PNG_FIXED_POINT_SUPPORTED
   info_ptr->int_gamma = png_gamma;
#endif
   info_ptr->valid |= PNG_INFO_gAMA;
   if (png_gamma == 0)
      png_warning(png_ptr, "Setting gamma=0");
}
#endif

#ifdef PNG_hIST_SUPPORTED
void PNGAPI
png_set_hIST(png_structp png_ptr, png_infop info_ptr, png_uint_16p hist)
{
   int i;

   png_debug1(1, "in %s storage function", "hIST");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   if (info_ptr->num_palette == 0 || info_ptr->num_palette
       > PNG_MAX_PALETTE_LENGTH)
   {
      png_warning(png_ptr,
         "Invalid palette size, hIST allocation skipped.");
      return;
   }

#ifdef PNG_FREE_ME_SUPPORTED
   png_free_data(png_ptr, info_ptr, PNG_FREE_HIST, 0);
#endif
   /* Changed from info->num_palette to PNG_MAX_PALETTE_LENGTH in
    * version 1.2.1
    */
   png_ptr->hist = (png_uint_16p)png_malloc_warn(png_ptr,
      (png_uint_32)(PNG_MAX_PALETTE_LENGTH * png_sizeof(png_uint_16)));
   if (png_ptr->hist == NULL)
   {
      png_warning(png_ptr, "Insufficient memory for hIST chunk data.");
      return;
   }

   for (i = 0; i < info_ptr->num_palette; i++)
      png_ptr->hist[i] = hist[i];
   info_ptr->hist = png_ptr->hist;
   info_ptr->valid |= PNG_INFO_hIST;

#ifdef PNG_FREE_ME_SUPPORTED
   info_ptr->free_me |= PNG_FREE_HIST;
#else
   png_ptr->flags |= PNG_FLAG_FREE_HIST;
#endif
}
#endif

void PNGAPI
png_set_IHDR(png_structp png_ptr, png_infop info_ptr,
   png_uint_32 width, png_uint_32 height, int bit_depth,
   int color_type, int interlace_type, int compression_type,
   int filter_type)
{
   png_debug1(1, "in %s storage function", "IHDR");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   info_ptr->width = width;
   info_ptr->height = height;
   info_ptr->bit_depth = (png_byte)bit_depth;
   info_ptr->color_type = (png_byte)color_type;
   info_ptr->compression_type = (png_byte)compression_type;
   info_ptr->filter_type = (png_byte)filter_type;
   info_ptr->interlace_type = (png_byte)interlace_type;

   png_check_IHDR (png_ptr, info_ptr->width, info_ptr->height,
       info_ptr->bit_depth, info_ptr->color_type, info_ptr->interlace_type,
       info_ptr->compression_type, info_ptr->filter_type);

   if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      info_ptr->channels = 1;
   else if (info_ptr->color_type & PNG_COLOR_MASK_COLOR)
      info_ptr->channels = 3;
   else
      info_ptr->channels = 1;
   if (info_ptr->color_type & PNG_COLOR_MASK_ALPHA)
      info_ptr->channels++;
   info_ptr->pixel_depth = (png_byte)(info_ptr->channels * info_ptr->bit_depth);

   /* Check for potential overflow */
   if (width > (PNG_UINT_32_MAX
                 >> 3)      /* 8-byte RGBA pixels */
                 - 64       /* bigrowbuf hack */
                 - 1        /* filter byte */
                 - 7*8      /* rounding of width to multiple of 8 pixels */
                 - 8)       /* extra max_pixel_depth pad */
   {
      info_ptr->rowbytes = (png_size_t)0;
      png_error(png_ptr, "Image width is too large for this architecture");
   }
   else
      info_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth, width);
}

#ifdef PNG_oFFs_SUPPORTED
void PNGAPI
png_set_oFFs(png_structp png_ptr, png_infop info_ptr,
   png_int_32 offset_x, png_int_32 offset_y, int unit_type)
{
   png_debug1(1, "in %s storage function", "oFFs");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   info_ptr->x_offset = offset_x;
   info_ptr->y_offset = offset_y;
   info_ptr->offset_unit_type = (png_byte)unit_type;
   info_ptr->valid |= PNG_INFO_oFFs;
}
#endif

#ifdef PNG_pCAL_SUPPORTED
void PNGAPI
png_set_pCAL(png_structp png_ptr, png_infop info_ptr,
   png_charp purpose, png_int_32 X0, png_int_32 X1, int type, int nparams,
   png_charp units, png_charpp params)
{
   png_uint_32 length;
   int i;

   png_debug1(1, "in %s storage function", "pCAL");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   length = png_strlen(purpose) + 1;
   png_debug1(3, "allocating purpose for info (%lu bytes)",
     (unsigned long)length);
   info_ptr->pcal_purpose = (png_charp)png_malloc_warn(png_ptr, length);
   if (info_ptr->pcal_purpose == NULL)
   {
      png_warning(png_ptr, "Insufficient memory for pCAL purpose.");
      return;
   }
   png_memcpy(info_ptr->pcal_purpose, purpose, (png_size_t)length);

   png_debug(3, "storing X0, X1, type, and nparams in info");
   info_ptr->pcal_X0 = X0;
   info_ptr->pcal_X1 = X1;
   info_ptr->pcal_type = (png_byte)type;
   info_ptr->pcal_nparams = (png_byte)nparams;

   length = png_strlen(units) + 1;
   png_debug1(3, "allocating units for info (%lu bytes)",
     (unsigned long)length);
   info_ptr->pcal_units = (png_charp)png_malloc_warn(png_ptr, length);
   if (info_ptr->pcal_units == NULL)
   {
      png_warning(png_ptr, "Insufficient memory for pCAL units.");
      return;
   }
   png_memcpy(info_ptr->pcal_units, units, (png_size_t)length);

   info_ptr->pcal_params = (png_charpp)png_malloc_warn(png_ptr,
      (png_uint_32)((nparams + 1) * png_sizeof(png_charp)));
   if (info_ptr->pcal_params == NULL)
   {
      png_warning(png_ptr, "Insufficient memory for pCAL params.");
      return;
   }

   png_memset(info_ptr->pcal_params, 0, (nparams + 1) * png_sizeof(png_charp));

   for (i = 0; i < nparams; i++)
   {
      length = png_strlen(params[i]) + 1;
      png_debug2(3, "allocating parameter %d for info (%lu bytes)", i,
        (unsigned long)length);
      info_ptr->pcal_params[i] = (png_charp)png_malloc_warn(png_ptr, length);
      if (info_ptr->pcal_params[i] == NULL)
      {
         png_warning(png_ptr, "Insufficient memory for pCAL parameter.");
         return;
      }
      png_memcpy(info_ptr->pcal_params[i], params[i], (png_size_t)length);
   }

   info_ptr->valid |= PNG_INFO_pCAL;
#ifdef PNG_FREE_ME_SUPPORTED
   info_ptr->free_me |= PNG_FREE_PCAL;
#endif
}
#endif

#if defined(PNG_READ_sCAL_SUPPORTED) || defined(PNG_WRITE_sCAL_SUPPORTED)
#ifdef PNG_FLOATING_POINT_SUPPORTED
void PNGAPI
png_set_sCAL(png_structp png_ptr, png_infop info_ptr,
             int unit, double width, double height)
{
   png_debug1(1, "in %s storage function", "sCAL");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   info_ptr->scal_unit = (png_byte)unit;
   info_ptr->scal_pixel_width = width;
   info_ptr->scal_pixel_height = height;

   info_ptr->valid |= PNG_INFO_sCAL;
}
#else
#ifdef PNG_FIXED_POINT_SUPPORTED
void PNGAPI
png_set_sCAL_s(png_structp png_ptr, png_infop info_ptr,
             int unit, png_charp swidth, png_charp sheight)
{
   png_uint_32 length;

   png_debug1(1, "in %s storage function", "sCAL");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   info_ptr->scal_unit = (png_byte)unit;

   length = png_strlen(swidth) + 1;
   png_debug1(3, "allocating unit for info (%u bytes)",
      (unsigned int)length);
   info_ptr->scal_s_width = (png_charp)png_malloc_warn(png_ptr, length);
   if (info_ptr->scal_s_width == NULL)
   {
      png_warning(png_ptr,
         "Memory allocation failed while processing sCAL.");
      return;
   }
   png_memcpy(info_ptr->scal_s_width, swidth, (png_size_t)length);

   length = png_strlen(sheight) + 1;
   png_debug1(3, "allocating unit for info (%u bytes)",
      (unsigned int)length);
   info_ptr->scal_s_height = (png_charp)png_malloc_warn(png_ptr, length);
   if (info_ptr->scal_s_height == NULL)
   {
      png_free (png_ptr, info_ptr->scal_s_width);
      info_ptr->scal_s_width = NULL;
      png_warning(png_ptr,
         "Memory allocation failed while processing sCAL.");
      return;
   }
   png_memcpy(info_ptr->scal_s_height, sheight, (png_size_t)length);
   info_ptr->valid |= PNG_INFO_sCAL;
#ifdef PNG_FREE_ME_SUPPORTED
   info_ptr->free_me |= PNG_FREE_SCAL;
#endif
}
#endif
#endif
#endif

#ifdef PNG_pHYs_SUPPORTED
void PNGAPI
png_set_pHYs(png_structp png_ptr, png_infop info_ptr,
   png_uint_32 res_x, png_uint_32 res_y, int unit_type)
{
   png_debug1(1, "in %s storage function", "pHYs");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   info_ptr->x_pixels_per_unit = res_x;
   info_ptr->y_pixels_per_unit = res_y;
   info_ptr->phys_unit_type = (png_byte)unit_type;
   info_ptr->valid |= PNG_INFO_pHYs;
}
#endif

void PNGAPI
png_set_PLTE(png_structp png_ptr, png_infop info_ptr,
   png_colorp palette, int num_palette)
{

   png_uint_32 max_palette_length;

   png_debug1(1, "in %s storage function", "PLTE");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   max_palette_length = (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) ?
      (1 << info_ptr->bit_depth) : PNG_MAX_PALETTE_LENGTH;

   if (num_palette < 0 || num_palette > (int) max_palette_length)
   {
      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
         png_error(png_ptr, "Invalid palette length");
      else
      {
         png_warning(png_ptr, "Invalid palette length");
         return;
      }
   }

   /* It may not actually be necessary to set png_ptr->palette here;
    * we do it for backward compatibility with the way the png_handle_tRNS
    * function used to do the allocation.
    */
#ifdef PNG_FREE_ME_SUPPORTED
   png_free_data(png_ptr, info_ptr, PNG_FREE_PLTE, 0);
#endif

   /* Changed in libpng-1.2.1 to allocate PNG_MAX_PALETTE_LENGTH instead
    * of num_palette entries, in case of an invalid PNG file or incorrect
    * call to png_set_PLTE() with too-large sample values.
    */
   png_ptr->palette = (png_colorp)png_calloc(png_ptr,
      PNG_MAX_PALETTE_LENGTH * png_sizeof(png_color));
   png_memcpy(png_ptr->palette, palette, num_palette * png_sizeof(png_color));
   info_ptr->palette = png_ptr->palette;
   info_ptr->num_palette = png_ptr->num_palette = (png_uint_16)num_palette;

#ifdef PNG_FREE_ME_SUPPORTED
   info_ptr->free_me |= PNG_FREE_PLTE;
#else
   png_ptr->flags |= PNG_FLAG_FREE_PLTE;
#endif

   info_ptr->valid |= PNG_INFO_PLTE;
}

#ifdef PNG_sBIT_SUPPORTED
void PNGAPI
png_set_sBIT(png_structp png_ptr, png_infop info_ptr,
   png_color_8p sig_bit)
{
   png_debug1(1, "in %s storage function", "sBIT");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   png_memcpy(&(info_ptr->sig_bit), sig_bit, png_sizeof(png_color_8));
   info_ptr->valid |= PNG_INFO_sBIT;
}
#endif

#ifdef PNG_sRGB_SUPPORTED
void PNGAPI
png_set_sRGB(png_structp png_ptr, png_infop info_ptr, int intent)
{
   png_debug1(1, "in %s storage function", "sRGB");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   info_ptr->srgb_intent = (png_byte)intent;
   info_ptr->valid |= PNG_INFO_sRGB;
}

void PNGAPI
png_set_sRGB_gAMA_and_cHRM(png_structp png_ptr, png_infop info_ptr,
   int intent)
{
#ifdef PNG_gAMA_SUPPORTED
#ifdef PNG_FLOATING_POINT_SUPPORTED
   float file_gamma;
#endif
#ifdef PNG_FIXED_POINT_SUPPORTED
   png_fixed_point int_file_gamma;
#endif
#endif
#ifdef PNG_cHRM_SUPPORTED
#ifdef PNG_FLOATING_POINT_SUPPORTED
   float white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y;
#endif
#ifdef PNG_FIXED_POINT_SUPPORTED
   png_fixed_point int_white_x, int_white_y, int_red_x, int_red_y, int_green_x,
      int_green_y, int_blue_x, int_blue_y;
#endif
#endif
   png_debug1(1, "in %s storage function", "sRGB_gAMA_and_cHRM");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   png_set_sRGB(png_ptr, info_ptr, intent);

#ifdef PNG_gAMA_SUPPORTED
#ifdef PNG_FLOATING_POINT_SUPPORTED
   file_gamma = (float).45455;
   png_set_gAMA(png_ptr, info_ptr, file_gamma);
#endif
#ifdef PNG_FIXED_POINT_SUPPORTED
   int_file_gamma = 45455L;
   png_set_gAMA_fixed(png_ptr, info_ptr, int_file_gamma);
#endif
#endif

#ifdef PNG_cHRM_SUPPORTED
#  ifdef PNG_FIXED_POINT_SUPPORTED
   int_white_x = 31270L;
   int_white_y = 32900L;
   int_red_x   = 64000L;
   int_red_y   = 33000L;
   int_green_x = 30000L;
   int_green_y = 60000L;
   int_blue_x  = 15000L;
   int_blue_y  =  6000L;
   png_set_cHRM_fixed(png_ptr, info_ptr,
       int_white_x, int_white_y, int_red_x, int_red_y, int_green_x,
       int_green_y, int_blue_x, int_blue_y);
#  endif

#  ifdef PNG_FLOATING_POINT_SUPPORTED
   white_x = (float).3127;
   white_y = (float).3290;
   red_x   = (float).64;
   red_y   = (float).33;
   green_x = (float).30;
   green_y = (float).60;
   blue_x  = (float).15;
   blue_y  = (float).06;
   png_set_cHRM(png_ptr, info_ptr,
       white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y);
#  endif
#endif /* cHRM */
}
#endif /* sRGB */


#ifdef PNG_iCCP_SUPPORTED
void PNGAPI
png_set_iCCP(png_structp png_ptr, png_infop info_ptr,
             png_charp name, int compression_type,
             png_charp profile, png_uint_32 proflen)
{
   png_charp new_iccp_name;
   png_charp new_iccp_profile;
   png_uint_32 length;

   png_debug1(1, "in %s storage function", "iCCP");

   if (png_ptr == NULL || info_ptr == NULL || name == NULL || profile == NULL)
      return;

   length = png_strlen(name)+1;
   new_iccp_name = (png_charp)png_malloc_warn(png_ptr, length);
   if (new_iccp_name == NULL)
   {
        png_warning(png_ptr, "Insufficient memory to process iCCP chunk.");
      return;
   }
   png_memcpy(new_iccp_name, name, length);
   new_iccp_profile = (png_charp)png_malloc_warn(png_ptr, proflen);
   if (new_iccp_profile == NULL)
   {
      png_free (png_ptr, new_iccp_name);
      png_warning(png_ptr,
          "Insufficient memory to process iCCP profile.");
      return;
   }
   png_memcpy(new_iccp_profile, profile, (png_size_t)proflen);

   png_free_data(png_ptr, info_ptr, PNG_FREE_ICCP, 0);

   info_ptr->iccp_proflen = proflen;
   info_ptr->iccp_name = new_iccp_name;
   info_ptr->iccp_profile = new_iccp_profile;
   /* Compression is always zero but is here so the API and info structure
    * does not have to change if we introduce multiple compression types
    */
   info_ptr->iccp_compression = (png_byte)compression_type;
#ifdef PNG_FREE_ME_SUPPORTED
   info_ptr->free_me |= PNG_FREE_ICCP;
#endif
   info_ptr->valid |= PNG_INFO_iCCP;
}
#endif

#ifdef PNG_TEXT_SUPPORTED
void PNGAPI
png_set_text(png_structp png_ptr, png_infop info_ptr, png_textp text_ptr,
             int num_text)
{
   int ret;
   ret = png_set_text_2(png_ptr, info_ptr, text_ptr, num_text);
   if (ret)
      png_error(png_ptr, "Insufficient memory to store text");
}

int /* PRIVATE */
png_set_text_2(png_structp png_ptr, png_infop info_ptr, png_textp text_ptr,
               int num_text)
{
   int i;

   png_debug1(1, "in %s storage function", ((png_ptr == NULL ||
      png_ptr->chunk_name[0] == '\0') ?
      "text" : (png_const_charp)png_ptr->chunk_name));

   if (png_ptr == NULL || info_ptr == NULL || num_text == 0)
      return(0);

   /* Make sure we have enough space in the "text" array in info_struct
    * to hold all of the incoming text_ptr objects.
    */
   if (info_ptr->num_text + num_text > info_ptr->max_text)
   {
      int old_max_text = info_ptr->max_text;
      int old_num_text = info_ptr->num_text;

      if (info_ptr->text != NULL)
      {
         png_textp old_text;

         info_ptr->max_text = info_ptr->num_text + num_text + 8;
         old_text = info_ptr->text;

         info_ptr->text = (png_textp)png_malloc_warn(png_ptr,
            (png_uint_32)(info_ptr->max_text * png_sizeof(png_text)));
         if (info_ptr->text == NULL)
         {
            /* Restore to previous condition */
            info_ptr->max_text = old_max_text;
            info_ptr->text = old_text;
            return(1);
         }
         png_memcpy(info_ptr->text, old_text, (png_size_t)(old_max_text *
            png_sizeof(png_text)));
         png_free(png_ptr, old_text);
      }
      else
      {
         info_ptr->max_text = num_text + 8;
         info_ptr->num_text = 0;
         info_ptr->text = (png_textp)png_malloc_warn(png_ptr,
            (png_uint_32)(info_ptr->max_text * png_sizeof(png_text)));
         if (info_ptr->text == NULL)
         {
            /* Restore to previous condition */
            info_ptr->num_text = old_num_text;
            info_ptr->max_text = old_max_text;
            return(1);
         }
#ifdef PNG_FREE_ME_SUPPORTED
         info_ptr->free_me |= PNG_FREE_TEXT;
#endif
      }
      png_debug1(3, "allocated %d entries for info_ptr->text",
         info_ptr->max_text);
   }

   for (i = 0; i < num_text; i++)
   {
      png_size_t text_length, key_len;
      png_size_t lang_len, lang_key_len;
      png_textp textp = &(info_ptr->text[info_ptr->num_text]);

      if (text_ptr[i].key == NULL)
          continue;

      key_len = png_strlen(text_ptr[i].key);

      if (text_ptr[i].compression <= 0)
      {
         lang_len = 0;
         lang_key_len = 0;
      }

      else
#ifdef PNG_iTXt_SUPPORTED
      {
         /* Set iTXt data */

         if (text_ptr[i].lang != NULL)
            lang_len = png_strlen(text_ptr[i].lang);
         else
            lang_len = 0;
         if (text_ptr[i].lang_key != NULL)
            lang_key_len = png_strlen(text_ptr[i].lang_key);
         else
            lang_key_len = 0;
      }
#else /* PNG_iTXt_SUPPORTED */
      {
         png_warning(png_ptr, "iTXt chunk not supported.");
         continue;
      }
#endif

      if (text_ptr[i].text == NULL || text_ptr[i].text[0] == '\0')
      {
         text_length = 0;
#ifdef PNG_iTXt_SUPPORTED
         if (text_ptr[i].compression > 0)
            textp->compression = PNG_ITXT_COMPRESSION_NONE;
         else
#endif
            textp->compression = PNG_TEXT_COMPRESSION_NONE;
      }

      else
      {
         text_length = png_strlen(text_ptr[i].text);
         textp->compression = text_ptr[i].compression;
      }

      textp->key = (png_charp)png_malloc_warn(png_ptr,
         (png_uint_32)
         (key_len + text_length + lang_len + lang_key_len + 4));
      if (textp->key == NULL)
         return(1);
      png_debug2(2, "Allocated %lu bytes at %p in png_set_text",
                 (png_uint_32)
                 (key_len + lang_len + lang_key_len + text_length + 4),
                 textp->key);

      png_memcpy(textp->key, text_ptr[i].key,(png_size_t)(key_len));
      *(textp->key + key_len) = '\0';
#ifdef PNG_iTXt_SUPPORTED
      if (text_ptr[i].compression > 0)
      {
         textp->lang = textp->key + key_len + 1;
         png_memcpy(textp->lang, text_ptr[i].lang, lang_len);
         *(textp->lang + lang_len) = '\0';
         textp->lang_key = textp->lang + lang_len + 1;
         png_memcpy(textp->lang_key, text_ptr[i].lang_key, lang_key_len);
         *(textp->lang_key + lang_key_len) = '\0';
         textp->text = textp->lang_key + lang_key_len + 1;
      }
      else
#endif
      {
#ifdef PNG_iTXt_SUPPORTED
         textp->lang=NULL;
         textp->lang_key=NULL;
#endif
         textp->text = textp->key + key_len + 1;
      }
      if (text_length)
         png_memcpy(textp->text, text_ptr[i].text,
            (png_size_t)(text_length));
      *(textp->text + text_length) = '\0';

#ifdef PNG_iTXt_SUPPORTED
      if (textp->compression > 0)
      {
         textp->text_length = 0;
         textp->itxt_length = text_length;
      }
      else
#endif

      {
         textp->text_length = text_length;
#ifdef PNG_iTXt_SUPPORTED
         textp->itxt_length = 0;
#endif
      }
      info_ptr->num_text++;
      png_debug1(3, "transferred text chunk %d", info_ptr->num_text);
   }
   return(0);
}
#endif

#ifdef PNG_tIME_SUPPORTED
void PNGAPI
png_set_tIME(png_structp png_ptr, png_infop info_ptr, png_timep mod_time)
{
   png_debug1(1, "in %s storage function", "tIME");

   if (png_ptr == NULL || info_ptr == NULL ||
       (png_ptr->mode & PNG_WROTE_tIME))
      return;

   if (mod_time->month == 0   || mod_time->month > 12  ||
       mod_time->day   == 0   || mod_time->day   > 31  ||
       mod_time->hour  > 23   || mod_time->minute > 59 ||
       mod_time->second > 60)
   {
      png_warning(png_ptr, "Ignoring invalid time value");
      return;
   }

   png_memcpy(&(info_ptr->mod_time), mod_time, png_sizeof(png_time));
   info_ptr->valid |= PNG_INFO_tIME;
}
#endif

#ifdef PNG_tRNS_SUPPORTED
void PNGAPI
png_set_tRNS(png_structp png_ptr, png_infop info_ptr,
   png_bytep trans, int num_trans, png_color_16p trans_values)
{
   png_debug1(1, "in %s storage function", "tRNS");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   if (num_trans < 0 || num_trans > PNG_MAX_PALETTE_LENGTH)
      {
        png_warning(png_ptr, "Ignoring invalid num_trans value");
        return;
      }

   if (trans != NULL)
   {
       /* It may not actually be necessary to set png_ptr->trans here;
        * we do it for backward compatibility with the way the png_handle_tRNS
        * function used to do the allocation.
        */

#ifdef PNG_FREE_ME_SUPPORTED
       png_free_data(png_ptr, info_ptr, PNG_FREE_TRNS, 0);
#endif

       /* Changed from num_trans to PNG_MAX_PALETTE_LENGTH in version 1.2.1 */
       png_ptr->trans = info_ptr->trans = (png_bytep)png_malloc(png_ptr,
           (png_uint_32)PNG_MAX_PALETTE_LENGTH);
       if (num_trans > 0 && num_trans <= PNG_MAX_PALETTE_LENGTH)
          png_memcpy(info_ptr->trans, trans, (png_size_t)num_trans);
   }

   if (trans_values != NULL)
   {
      int sample_max = (1 << info_ptr->bit_depth);
      if ((info_ptr->color_type == PNG_COLOR_TYPE_GRAY &&
          (int)trans_values->gray > sample_max) ||
          (info_ptr->color_type == PNG_COLOR_TYPE_RGB &&
          ((int)trans_values->red > sample_max ||
          (int)trans_values->green > sample_max ||
          (int)trans_values->blue > sample_max)))
         png_warning(png_ptr,
            "tRNS chunk has out-of-range samples for bit_depth");
      png_memcpy(&(info_ptr->trans_values), trans_values,
         png_sizeof(png_color_16));
      if (num_trans == 0)
         num_trans = 1;
   }

   info_ptr->num_trans = (png_uint_16)num_trans;
   if (num_trans != 0)
   {
      info_ptr->valid |= PNG_INFO_tRNS;
#ifdef PNG_FREE_ME_SUPPORTED
      info_ptr->free_me |= PNG_FREE_TRNS;
#else
      png_ptr->flags |= PNG_FLAG_FREE_TRNS;
#endif
   }
}
#endif

#ifdef PNG_sPLT_SUPPORTED
void PNGAPI
png_set_sPLT(png_structp png_ptr,
             png_infop info_ptr, png_sPLT_tp entries, int nentries)
/*
 *  entries        - array of png_sPLT_t structures
 *                   to be added to the list of palettes
 *                   in the info structure.
 *  nentries       - number of palette structures to be
 *                   added.
 */
{
   png_sPLT_tp np;
   int i;

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   np = (png_sPLT_tp)png_malloc_warn(png_ptr,
       (info_ptr->splt_palettes_num + nentries) *
        (png_uint_32)png_sizeof(png_sPLT_t));
   if (np == NULL)
   {
      png_warning(png_ptr, "No memory for sPLT palettes.");
      return;
   }

   png_memcpy(np, info_ptr->splt_palettes,
       info_ptr->splt_palettes_num * png_sizeof(png_sPLT_t));
   png_free(png_ptr, info_ptr->splt_palettes);
   info_ptr->splt_palettes=NULL;

   for (i = 0; i < nentries; i++)
   {
      png_sPLT_tp to = np + info_ptr->splt_palettes_num + i;
      png_sPLT_tp from = entries + i;
      png_uint_32 length;

      length = png_strlen(from->name) + 1;
      to->name = (png_charp)png_malloc_warn(png_ptr, length);
      if (to->name == NULL)
      {
         png_warning(png_ptr,
           "Out of memory while processing sPLT chunk");
         continue;
      }
      png_memcpy(to->name, from->name, length);
      to->entries = (png_sPLT_entryp)png_malloc_warn(png_ptr,
          (png_uint_32)(from->nentries * png_sizeof(png_sPLT_entry)));
      if (to->entries == NULL)
      {
         png_warning(png_ptr,
           "Out of memory while processing sPLT chunk");
         png_free(png_ptr, to->name);
         to->name = NULL;
         continue;
      }
      png_memcpy(to->entries, from->entries,
          from->nentries * png_sizeof(png_sPLT_entry));
      to->nentries = from->nentries;
      to->depth = from->depth;
   }

   info_ptr->splt_palettes = np;
   info_ptr->splt_palettes_num += nentries;
   info_ptr->valid |= PNG_INFO_sPLT;
#ifdef PNG_FREE_ME_SUPPORTED
   info_ptr->free_me |= PNG_FREE_SPLT;
#endif
}
#endif /* PNG_sPLT_SUPPORTED */

#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED
void PNGAPI
png_set_unknown_chunks(png_structp png_ptr,
   png_infop info_ptr, png_unknown_chunkp unknowns, int num_unknowns)
{
   png_unknown_chunkp np;
   int i;

   if (png_ptr == NULL || info_ptr == NULL || num_unknowns == 0)
      return;

   np = (png_unknown_chunkp)png_malloc_warn(png_ptr,
       (png_uint_32)((info_ptr->unknown_chunks_num + num_unknowns) *
       png_sizeof(png_unknown_chunk)));
   if (np == NULL)
   {
      png_warning(png_ptr,
          "Out of memory while processing unknown chunk.");
      return;
   }

   png_memcpy(np, info_ptr->unknown_chunks,
       info_ptr->unknown_chunks_num * png_sizeof(png_unknown_chunk));
   png_free(png_ptr, info_ptr->unknown_chunks);
   info_ptr->unknown_chunks = NULL;

   for (i = 0; i < num_unknowns; i++)
   {
      png_unknown_chunkp to = np + info_ptr->unknown_chunks_num + i;
      png_unknown_chunkp from = unknowns + i;

      png_memcpy((png_charp)to->name, (png_charp)from->name,
          png_sizeof(from->name));
      to->name[png_sizeof(to->name)-1] = '\0';
      to->size = from->size;
      /* Note our location in the read or write sequence */
      to->location = (png_byte)(png_ptr->mode & 0xff);

      if (from->size == 0)
         to->data=NULL;
      else
      {
         to->data = (png_bytep)png_malloc_warn(png_ptr,
           (png_uint_32)from->size);
         if (to->data == NULL)
         {
            png_warning(png_ptr,
             "Out of memory while processing unknown chunk.");
            to->size = 0;
         }
         else
            png_memcpy(to->data, from->data, from->size);
      }
   }

   info_ptr->unknown_chunks = np;
   info_ptr->unknown_chunks_num += num_unknowns;
#ifdef PNG_FREE_ME_SUPPORTED
   info_ptr->free_me |= PNG_FREE_UNKN;
#endif
}
void PNGAPI
png_set_unknown_chunk_location(png_structp png_ptr, png_infop info_ptr,
   int chunk, int location)
{
   if (png_ptr != NULL && info_ptr != NULL && chunk >= 0 && chunk <
       (int)info_ptr->unknown_chunks_num)
      info_ptr->unknown_chunks[chunk].location = (png_byte)location;
}
#endif

#if defined(PNG_1_0_X) || defined(PNG_1_2_X)
#if defined(PNG_READ_EMPTY_PLTE_SUPPORTED) || \
    defined(PNG_WRITE_EMPTY_PLTE_SUPPORTED)
void PNGAPI
png_permit_empty_plte (png_structp png_ptr, int empty_plte_permitted)
{
   /* This function is deprecated in favor of png_permit_mng_features()
      and will be removed from libpng-1.3.0 */

   png_debug(1, "in png_permit_empty_plte, DEPRECATED.");

   if (png_ptr == NULL)
      return;
   png_ptr->mng_features_permitted = (png_byte)
     ((png_ptr->mng_features_permitted & (~PNG_FLAG_MNG_EMPTY_PLTE)) |
     ((empty_plte_permitted & PNG_FLAG_MNG_EMPTY_PLTE)));
}
#endif
#endif

#ifdef PNG_MNG_FEATURES_SUPPORTED
png_uint_32 PNGAPI
png_permit_mng_features (png_structp png_ptr, png_uint_32 mng_features)
{
   png_debug(1, "in png_permit_mng_features");

   if (png_ptr == NULL)
      return (png_uint_32)0;
   png_ptr->mng_features_permitted =
     (png_byte)(mng_features & PNG_ALL_MNG_FEATURES);
   return (png_uint_32)png_ptr->mng_features_permitted;
}
#endif

#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
void PNGAPI
png_set_keep_unknown_chunks(png_structp png_ptr, int keep, png_bytep
   chunk_list, int num_chunks)
{
   png_bytep new_list, p;
   int i, old_num_chunks;
   if (png_ptr == NULL)
      return;
   if (num_chunks == 0)
   {
      if (keep == PNG_HANDLE_CHUNK_ALWAYS || keep == PNG_HANDLE_CHUNK_IF_SAFE)
         png_ptr->flags |= PNG_FLAG_KEEP_UNKNOWN_CHUNKS;
      else
         png_ptr->flags &= ~PNG_FLAG_KEEP_UNKNOWN_CHUNKS;

      if (keep == PNG_HANDLE_CHUNK_ALWAYS)
         png_ptr->flags |= PNG_FLAG_KEEP_UNSAFE_CHUNKS;
      else
         png_ptr->flags &= ~PNG_FLAG_KEEP_UNSAFE_CHUNKS;
      return;
   }
   if (chunk_list == NULL)
      return;
   old_num_chunks = png_ptr->num_chunk_list;
   new_list=(png_bytep)png_malloc(png_ptr,
      (png_uint_32)
       (5*(num_chunks + old_num_chunks)));
   if (png_ptr->chunk_list != NULL)
   {
      png_memcpy(new_list, png_ptr->chunk_list,
          (png_size_t)(5*old_num_chunks));
      png_free(png_ptr, png_ptr->chunk_list);
      png_ptr->chunk_list=NULL;
   }
   png_memcpy(new_list + 5*old_num_chunks, chunk_list,
       (png_size_t)(5*num_chunks));
   for (p = new_list + 5*old_num_chunks + 4, i = 0; i<num_chunks; i++, p += 5)
      *p=(png_byte)keep;
   png_ptr->num_chunk_list = old_num_chunks + num_chunks;
   png_ptr->chunk_list = new_list;
#ifdef PNG_FREE_ME_SUPPORTED
   png_ptr->free_me |= PNG_FREE_LIST;
#endif
}
#endif

#ifdef PNG_READ_USER_CHUNKS_SUPPORTED
void PNGAPI
png_set_read_user_chunk_fn(png_structp png_ptr, png_voidp user_chunk_ptr,
   png_user_chunk_ptr read_user_chunk_fn)
{
   png_debug(1, "in png_set_read_user_chunk_fn");

   if (png_ptr == NULL)
      return;

   png_ptr->read_user_chunk_fn = read_user_chunk_fn;
   png_ptr->user_chunk_ptr = user_chunk_ptr;
}
#endif

#ifdef PNG_INFO_IMAGE_SUPPORTED
void PNGAPI
png_set_rows(png_structp png_ptr, png_infop info_ptr, png_bytepp row_pointers)
{
   png_debug1(1, "in %s storage function", "rows");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   if (info_ptr->row_pointers && (info_ptr->row_pointers != row_pointers))
      png_free_data(png_ptr, info_ptr, PNG_FREE_ROWS, 0);
   info_ptr->row_pointers = row_pointers;
   if (row_pointers)
      info_ptr->valid |= PNG_INFO_IDAT;
}
#endif

void PNGAPI
png_set_compression_buffer_size(png_structp png_ptr,
    png_uint_32 size)
{
    if (png_ptr == NULL)
       return;
    png_free(png_ptr, png_ptr->zbuf);
    png_ptr->zbuf_size = (png_size_t)size;
    png_ptr->zbuf = (png_bytep)png_malloc(png_ptr, size);
    png_ptr->zstream.next_out = png_ptr->zbuf;
    png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
}

void PNGAPI
png_set_invalid(png_structp png_ptr, png_infop info_ptr, int mask)
{
   if (png_ptr && info_ptr)
      info_ptr->valid &= ~mask;
}


#ifndef PNG_1_0_X
#ifdef PNG_ASSEMBLER_CODE_SUPPORTED
/* Function was added to libpng 1.2.0 and should always exist by default */
void PNGAPI
png_set_asm_flags (png_structp png_ptr, png_uint_32 asm_flags)
{
/* Obsolete as of libpng-1.2.20 and will be removed from libpng-1.4.0 */
    if (png_ptr != NULL)
    png_ptr->asm_flags = 0;
    PNG_UNUSED(asm_flags) /* Quiet the compiler */
}

/* This function was added to libpng 1.2.0 */
void PNGAPI
png_set_mmx_thresholds (png_structp png_ptr,
                        png_byte mmx_bitdepth_threshold,
                        png_uint_32 mmx_rowbytes_threshold)
{
/* Obsolete as of libpng-1.2.20 and will be removed from libpng-1.4.0 */
    if (png_ptr == NULL)
       return;
    /* Quiet the compiler */
    PNG_UNUSED(mmx_bitdepth_threshold)
    PNG_UNUSED(mmx_rowbytes_threshold)
}
#endif /* ?PNG_ASSEMBLER_CODE_SUPPORTED */

#ifdef PNG_SET_USER_LIMITS_SUPPORTED
/* This function was added to libpng 1.2.6 */
void PNGAPI
png_set_user_limits (png_structp png_ptr, png_uint_32 user_width_max,
    png_uint_32 user_height_max)
{
   /* Images with dimensions larger than these limits will be
    * rejected by png_set_IHDR().  To accept any PNG datastream
    * regardless of dimensions, set both limits to 0x7fffffffL.
    */
   if (png_ptr == NULL)
      return;
   png_ptr->user_width_max = user_width_max;
   png_ptr->user_height_max = user_height_max;
}
#endif /* ?PNG_SET_USER_LIMITS_SUPPORTED */


#ifdef PNG_BENIGN_ERRORS_SUPPORTED
void PNGAPI
png_set_benign_errors(png_structp png_ptr, int allowed)
{
   png_debug(1, "in png_set_benign_errors");

   if (allowed)
      png_ptr->flags |= PNG_FLAG_BENIGN_ERRORS_WARN;
   else
      png_ptr->flags &= ~PNG_FLAG_BENIGN_ERRORS_WARN;
}
#endif /* PNG_BENIGN_ERRORS_SUPPORTED */
#endif /* ?PNG_1_0_X */

#if defined(PNG_WRITE_TEXT_SUPPORTED) || defined(PNG_WRITE_pCAL_SUPPORTED) || \
    defined(PNG_WRITE_iCCP_SUPPORTED) || defined(PNG_WRITE_sPLT_SUPPORTED)
/* Check that the tEXt or zTXt keyword is valid per PNG 1.0 specification,
 * and if invalid, correct the keyword rather than discarding the entire
 * chunk.  The PNG 1.0 specification requires keywords 1-79 characters in
 * length, forbids leading or trailing whitespace, multiple internal spaces,
 * and the non-break space (0x80) from ISO 8859-1.  Returns keyword length.
 *
 * The new_key is allocated to hold the corrected keyword and must be freed
 * by the calling routine.  This avoids problems with trying to write to
 * static keywords without having to have duplicate copies of the strings.
 */
png_size_t /* PRIVATE */
png_check_keyword(png_structp png_ptr, png_charp key, png_charpp new_key)
{
   png_size_t key_len;
   png_charp kp, dp;
   int kflag;
   int kwarn=0;

   png_debug(1, "in png_check_keyword");

   *new_key = NULL;

   if (key == NULL || (key_len = png_strlen(key)) == 0)
   {
      png_warning(png_ptr, "zero length keyword");
      return ((png_size_t)0);
   }

   png_debug1(2, "Keyword to be checked is '%s'", key);

   *new_key = (png_charp)png_malloc_warn(png_ptr, (png_uint_32)(key_len + 2));
   if (*new_key == NULL)
   {
      png_warning(png_ptr, "Out of memory while procesing keyword");
      return ((png_size_t)0);
   }

   /* Replace non-printing characters with a blank and print a warning */
   for (kp = key, dp = *new_key; *kp != '\0'; kp++, dp++)
   {
      if ((png_byte)*kp < 0x20 ||
         ((png_byte)*kp > 0x7E && (png_byte)*kp < 0xA1))
      {
#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)
         char msg[40];

         png_snprintf(msg, 40,
           "invalid keyword character 0x%02X", (png_byte)*kp);
         png_warning(png_ptr, msg);
#else
         png_warning(png_ptr, "invalid character in keyword");
#endif
         *dp = ' ';
      }
      else
      {
         *dp = *kp;
      }
   }
   *dp = '\0';

   /* Remove any trailing white space. */
   kp = *new_key + key_len - 1;
   if (*kp == ' ')
   {
      png_warning(png_ptr, "trailing spaces removed from keyword");

      while (key_len && *kp == ' ')
      {
         *(kp--) = '\0';
         key_len--;
      }
   }

   /* Remove any leading white space. */
   kp = *new_key;
   if (*kp == ' ')
   {
      png_warning(png_ptr, "leading spaces removed from keyword");

      while (*kp == ' ')
      {
         kp++;
         key_len--;
      }
   }

   png_debug1(2, "Checking for multiple internal spaces in '%s'", kp);

   /* Remove multiple internal spaces. */
   for (kflag = 0, dp = *new_key; *kp != '\0'; kp++)
   {
      if (*kp == ' ' && kflag == 0)
      {
         *(dp++) = *kp;
         kflag = 1;
      }
      else if (*kp == ' ')
      {
         key_len--;
         kwarn=1;
      }
      else
      {
         *(dp++) = *kp;
         kflag = 0;
      }
   }
   *dp = '\0';
   if (kwarn)
      png_warning(png_ptr, "extra interior spaces removed from keyword");

   if (key_len == 0)
   {
      png_free(png_ptr, *new_key);
       *new_key=NULL;
      png_warning(png_ptr, "Zero length keyword");
   }

   if (key_len > 79)
   {
      png_warning(png_ptr, "keyword length must be 1 - 79 characters");
      (*new_key)[79] = '\0';
      key_len = 79;
   }

   return (key_len);
}
#endif /* WRITE_TEXT || WRITE_pCAL) || WRITE_iCCP || WRITE_sPLT */
#endif /* PNG_READ_SUPPORTED || PNG_WRITE_SUPPORTED */
@


1.5
log
@merge, rebase/minify, fix
@
text
@d4 2
a5 2
 * Last changed in libpng 1.2.49 [March 29, 2012]
 * Copyright (c) 1998-2012 Glenn Randers-Pehrson
d266 1
d268 2
d452 2
d459 4
a462 1
   if (num_palette < 0 || num_palette > PNG_MAX_PALETTE_LENGTH)
d482 2
a483 2
    * of num_palette entries, in case of an invalid PNG file that has
    * too-large sample values.
d544 1
d548 1
d568 1
d577 4
d582 1
a582 1
#ifdef PNG_FLOATING_POINT_SUPPORTED
a590 8
#endif

#ifdef PNG_FIXED_POINT_SUPPORTED
   png_set_cHRM_fixed(png_ptr, info_ptr,
       int_white_x, int_white_y, int_red_x, int_red_y, int_green_x,
       int_green_y, int_blue_x, int_blue_y);
#endif
#ifdef PNG_FLOATING_POINT_SUPPORTED
d593 1
a593 1
#endif
d781 1
a781 1
      png_debug2(2, "Allocated %lu bytes at %x in png_set_text",
d784 1
a784 1
                 (int)textp->key);
d845 9
d869 6
d1209 1
a1209 1
    asm_flags = asm_flags; /* Quiet the compiler */
d1222 2
a1223 2
    mmx_bitdepth_threshold = mmx_bitdepth_threshold;
    mmx_rowbytes_threshold = mmx_rowbytes_threshold;
d1235 1
a1235 1
    * regardless of dimensions, set both limits to 0x7ffffffL.
d1258 132
@


1.4
log
@SECURITY update; prodded by bsiegert@@
@
text
@d4 2
a5 3
 * Last changed in libpng 1.2.35 [February 14, 2009]
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1998-2009 Glenn Randers-Pehrson
d9 4
d20 1
d24 1
a24 1
#if defined(PNG_bKGD_SUPPORTED)
d29 1
d38 1
a38 1
#if defined(PNG_cHRM_SUPPORTED)
d46 1
d80 1
d84 1
a84 1
#if !defined(PNG_NO_CHECK_cHRM)
d89 17
a105 17
     info_ptr->int_x_white = white_x;
     info_ptr->int_y_white = white_y;
     info_ptr->int_x_red   = red_x;
     info_ptr->int_y_red   = red_y;
     info_ptr->int_x_green = green_x;
     info_ptr->int_y_green = green_y;
     info_ptr->int_x_blue  = blue_x;
     info_ptr->int_y_blue  = blue_y;
#ifdef PNG_FLOATING_POINT_SUPPORTED
     info_ptr->x_white = (float)(white_x/100000.);
     info_ptr->y_white = (float)(white_y/100000.);
     info_ptr->x_red   = (float)(  red_x/100000.);
     info_ptr->y_red   = (float)(  red_y/100000.);
     info_ptr->x_green = (float)(green_x/100000.);
     info_ptr->y_green = (float)(green_y/100000.);
     info_ptr->x_blue  = (float)( blue_x/100000.);
     info_ptr->y_blue  = (float)( blue_y/100000.);
d107 1
a107 1
     info_ptr->valid |= PNG_INFO_cHRM;
d113 1
a113 1
#if defined(PNG_gAMA_SUPPORTED)
d118 2
a119 1
   double ourgamma;
d121 1
d129 1
a129 1
      ourgamma=21474.83;
d132 2
a133 2
      ourgamma = file_gamma;
   info_ptr->gamma = (float)ourgamma;
d135 1
a135 1
   info_ptr->int_gamma = (int)(ourgamma*100000.+.5);
d138 1
a138 1
   if (ourgamma == 0.0)
d146 1
a146 1
   png_fixed_point ourgamma;
d149 1
d153 1
a153 1
   if (int_gamma > (png_fixed_point) PNG_UINT_31_MAX)
d155 2
a156 2
     png_warning(png_ptr, "Limiting gamma to 21474.83");
     ourgamma=PNG_UINT_31_MAX;
d160 7
a166 7
     if (int_gamma < 0)
     {
       png_warning(png_ptr, "Setting negative gamma to zero");
       ourgamma = 0;
     }
     else
       ourgamma = int_gamma;
d169 1
a169 1
   info_ptr->gamma = (float)(ourgamma/100000.);
d172 1
a172 1
   info_ptr->int_gamma = ourgamma;
d175 1
a175 1
   if (ourgamma == 0)
d180 1
a180 1
#if defined(PNG_hIST_SUPPORTED)
d187 1
d190 1
d194 3
a196 3
       png_warning(png_ptr,
          "Invalid palette size, hIST allocation skipped.");
       return;
d202 3
a204 2
   /* Changed from info->num_palette to PNG_MAX_PALETTE_LENGTH in version
      1.2.1 */
d208 4
a211 4
     {
       png_warning(png_ptr, "Insufficient memory for hIST chunk data.");
       return;
     }
d214 1
a214 1
       png_ptr->hist[i] = hist[i];
d233 1
a236 69
   /* check for width and height valid values */
   if (width == 0 || height == 0)
      png_error(png_ptr, "Image width or height is zero in IHDR");
#ifdef PNG_SET_USER_LIMITS_SUPPORTED
   if (width > png_ptr->user_width_max || height > png_ptr->user_height_max)
      png_error(png_ptr, "image size exceeds user limits in IHDR");
#else
   if (width > PNG_USER_WIDTH_MAX || height > PNG_USER_HEIGHT_MAX)
      png_error(png_ptr, "image size exceeds user limits in IHDR");
#endif
   if (width > PNG_UINT_31_MAX || height > PNG_UINT_31_MAX)
      png_error(png_ptr, "Invalid image size in IHDR");
   if ( width > (PNG_UINT_32_MAX
                 >> 3)      /* 8-byte RGBA pixels */
                 - 64       /* bigrowbuf hack */
                 - 1        /* filter byte */
                 - 7*8      /* rounding of width to multiple of 8 pixels */
                 - 8)       /* extra max_pixel_depth pad */
      png_warning(png_ptr, "Width is too large for libpng to process pixels");

   /* check other values */
   if (bit_depth != 1 && bit_depth != 2 && bit_depth != 4 &&
      bit_depth != 8 && bit_depth != 16)
      png_error(png_ptr, "Invalid bit depth in IHDR");

   if (color_type < 0 || color_type == 1 ||
      color_type == 5 || color_type > 6)
      png_error(png_ptr, "Invalid color type in IHDR");

   if (((color_type == PNG_COLOR_TYPE_PALETTE) && bit_depth > 8) ||
       ((color_type == PNG_COLOR_TYPE_RGB ||
         color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||
         color_type == PNG_COLOR_TYPE_RGB_ALPHA) && bit_depth < 8))
      png_error(png_ptr, "Invalid color type/bit depth combination in IHDR");

   if (interlace_type >= PNG_INTERLACE_LAST)
      png_error(png_ptr, "Unknown interlace method in IHDR");

   if (compression_type != PNG_COMPRESSION_TYPE_BASE)
      png_error(png_ptr, "Unknown compression method in IHDR");

#if defined(PNG_MNG_FEATURES_SUPPORTED)
   /* Accept filter_method 64 (intrapixel differencing) only if
    * 1. Libpng was compiled with PNG_MNG_FEATURES_SUPPORTED and
    * 2. Libpng did not read a PNG signature (this filter_method is only
    *    used in PNG datastreams that are embedded in MNG datastreams) and
    * 3. The application called png_permit_mng_features with a mask that
    *    included PNG_FLAG_MNG_FILTER_64 and
    * 4. The filter_method is 64 and
    * 5. The color_type is RGB or RGBA
    */
   if ((png_ptr->mode&PNG_HAVE_PNG_SIGNATURE)&&png_ptr->mng_features_permitted)
      png_warning(png_ptr, "MNG features are not allowed in a PNG datastream");
   if (filter_type != PNG_FILTER_TYPE_BASE)
   {
     if (!((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&
        (filter_type == PNG_INTRAPIXEL_DIFFERENCING) &&
        ((png_ptr->mode&PNG_HAVE_PNG_SIGNATURE) == 0) &&
        (color_type == PNG_COLOR_TYPE_RGB ||
         color_type == PNG_COLOR_TYPE_RGB_ALPHA)))
        png_error(png_ptr, "Unknown filter method in IHDR");
     if (png_ptr->mode&PNG_HAVE_PNG_SIGNATURE)
        png_warning(png_ptr, "Invalid filter method in IHDR");
   }
#else
   if (filter_type != PNG_FILTER_TYPE_BASE)
      png_error(png_ptr, "Unknown filter method in IHDR");
#endif

d240 1
a240 1
   info_ptr->color_type =(png_byte) color_type;
d244 5
d259 1
a259 1
   /* check for potential overflow */
d271 1
a271 1
#if defined(PNG_oFFs_SUPPORTED)
d277 1
d288 1
a288 1
#if defined(PNG_pCAL_SUPPORTED)
d298 1
d308 1
a308 1
       png_warning(png_ptr, "Insufficient memory for pCAL purpose.");
d325 1
a325 1
       png_warning(png_ptr, "Insufficient memory for pCAL units.");
d334 1
a334 1
       png_warning(png_ptr, "Insufficient memory for pCAL params.");
a337 4
#ifdef PNG_FREE_ME_SUPPORTED
   info_ptr->free_me |= PNG_FREE_PCAL;
#endif

d348 2
a349 2
          png_warning(png_ptr, "Insufficient memory for pCAL parameter.");
          return;
d355 3
d368 1
d387 1
d400 1
a400 1
       "Memory allocation failed while processing sCAL.");
d414 1
a414 1
       "Memory allocation failed while processing sCAL.");
d427 1
a427 1
#if defined(PNG_pHYs_SUPPORTED)
d433 1
d450 1
d455 2
a456 2
     {
       if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
d458 2
a459 2
       else
       {
d462 2
a463 2
       }
     }
d465 1
a465 2
   /*
    * It may not actually be necessary to set png_ptr->palette here;
d474 4
a477 3
      of num_palette entries,
      in case of an invalid PNG file that has too-large sample values. */
   png_ptr->palette = (png_colorp)png_malloc(png_ptr,
a478 2
   png_memset(png_ptr->palette, 0, PNG_MAX_PALETTE_LENGTH *
      png_sizeof(png_color));
d492 1
a492 1
#if defined(PNG_sBIT_SUPPORTED)
d498 1
d507 1
a507 1
#if defined(PNG_sRGB_SUPPORTED)
d512 1
d524 1
a524 1
#if defined(PNG_gAMA_SUPPORTED)
d532 1
a532 1
#if defined(PNG_cHRM_SUPPORTED)
d540 1
d546 1
a546 1
#if defined(PNG_gAMA_SUPPORTED)
d557 1
a557 1
#if defined(PNG_cHRM_SUPPORTED)
a577 6
#if !defined(PNG_NO_CHECK_cHRM)
   if (png_check_cHRM_fixed(png_ptr,
      int_white_x, int_white_y, int_red_x, int_red_y, int_green_x,
      int_green_y, int_blue_x, int_blue_y))
#endif
   {
d579 3
a581 3
     png_set_cHRM_fixed(png_ptr, info_ptr,
        int_white_x, int_white_y, int_red_x, int_red_y, int_green_x,
        int_green_y, int_blue_x, int_blue_y);
d584 2
a585 2
      png_set_cHRM(png_ptr, info_ptr,
         white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y);
a586 1
   }
d592 1
a592 1
#if defined(PNG_iCCP_SUPPORTED)
d603 1
d611 1
a611 1
      png_warning(png_ptr, "Insufficient memory to process iCCP chunk.");
d620 1
a620 1
      "Insufficient memory to process iCCP profile.");
d631 2
a632 1
    * does not have to change if we introduce multiple compression types */
d641 1
a641 1
#if defined(PNG_TEXT_SUPPORTED)
d644 1
a644 1
   int num_text)
d649 1
a649 1
     png_error(png_ptr, "Insufficient memory to store text");
d654 1
a654 1
   int num_text)
d658 2
a659 1
   png_debug1(1, "in %s storage function", (png_ptr->chunk_name[0] == '\0' ?
d670 3
a675 1
         int old_max;
a676 1
         old_max = info_ptr->max_text;
d679 1
d683 7
a689 5
           {
             png_free(png_ptr, old_text);
             return(1);
           }
         png_memcpy(info_ptr->text, old_text, (png_size_t)(old_max *
d700 6
a705 1
           return(1);
d713 1
d727 2
a728 2
        lang_len = 0;
        lang_key_len = 0;
d730 1
d734 10
a743 9
        /* set iTXt data */
        if (text_ptr[i].lang != NULL)
          lang_len = png_strlen(text_ptr[i].lang);
        else
          lang_len = 0;
        if (text_ptr[i].lang_key != NULL)
          lang_key_len = png_strlen(text_ptr[i].lang_key);
        else
          lang_key_len = 0;
d745 1
a745 1
#else
d747 2
a748 2
        png_warning(png_ptr, "iTXt chunk not supported.");
        continue;
d762 1
d773 1
a773 1
        return(1);
d775 3
a777 3
         (png_uint_32)
         (key_len + lang_len + lang_key_len + text_length + 4),
         (int)textp->key);
d779 1
a779 2
      png_memcpy(textp->key, text_ptr[i].key,
         (png_size_t)(key_len));
d814 1
d828 1
a828 1
#if defined(PNG_tIME_SUPPORTED)
d833 1
d843 1
a843 1
#if defined(PNG_tRNS_SUPPORTED)
d849 1
d855 1
a855 2
       /*
        * It may not actually be necessary to set png_ptr->trans here;
d868 1
a868 1
         png_memcpy(info_ptr->trans, trans, (png_size_t)num_trans);
d880 2
a881 2
        png_warning(png_ptr,
           "tRNS chunk has out-of-range samples for bit_depth");
d885 1
a885 1
        num_trans = 1;
d901 1
a901 1
#if defined(PNG_sPLT_SUPPORTED)
d913 2
a914 2
    png_sPLT_tp np;
    int i;
d916 2
a917 2
    if (png_ptr == NULL || info_ptr == NULL)
       return;
d919 2
a920 2
    np = (png_sPLT_tp)png_malloc_warn(png_ptr,
        (info_ptr->splt_palettes_num + nentries) *
d922 2
a923 2
    if (np == NULL)
    {
d926 1
a926 1
    }
d928 4
a931 2
    png_memcpy(np, info_ptr->splt_palettes,
           info_ptr->splt_palettes_num * png_sizeof(png_sPLT_t));
d933 30
a962 2
    png_free(png_ptr, info_ptr->splt_palettes);
    info_ptr->splt_palettes=NULL;
d964 3
a966 34
    for (i = 0; i < nentries; i++)
    {
        png_sPLT_tp to = np + info_ptr->splt_palettes_num + i;
        png_sPLT_tp from = entries + i;
        png_uint_32 length;

        length = png_strlen(from->name) + 1;
        to->name = (png_charp)png_malloc_warn(png_ptr, length);
        if (to->name == NULL)
        {
           png_warning(png_ptr,
             "Out of memory while processing sPLT chunk");
           continue;
        }
        png_memcpy(to->name, from->name, length);
        to->entries = (png_sPLT_entryp)png_malloc_warn(png_ptr,
            (png_uint_32)(from->nentries * png_sizeof(png_sPLT_entry)));
        if (to->entries == NULL)
        {
           png_warning(png_ptr,
             "Out of memory while processing sPLT chunk");
           png_free(png_ptr, to->name);
           to->name = NULL;
           continue;
        }
        png_memcpy(to->entries, from->entries,
            from->nentries * png_sizeof(png_sPLT_entry));
        to->nentries = from->nentries;
        to->depth = from->depth;
    }

    info_ptr->splt_palettes = np;
    info_ptr->splt_palettes_num += nentries;
    info_ptr->valid |= PNG_INFO_sPLT;
d968 1
a968 1
    info_ptr->free_me |= PNG_FREE_SPLT;
d973 1
a973 1
#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
d978 2
a979 2
    png_unknown_chunkp np;
    int i;
d981 2
a982 2
    if (png_ptr == NULL || info_ptr == NULL || num_unknowns == 0)
        return;
d984 6
a989 6
    np = (png_unknown_chunkp)png_malloc_warn(png_ptr,
        (png_uint_32)((info_ptr->unknown_chunks_num + num_unknowns) *
        png_sizeof(png_unknown_chunk)));
    if (np == NULL)
    {
       png_warning(png_ptr,
d991 12
a1002 2
       return;
    }
d1004 6
a1009 34
    png_memcpy(np, info_ptr->unknown_chunks,
           info_ptr->unknown_chunks_num * png_sizeof(png_unknown_chunk));
    png_free(png_ptr, info_ptr->unknown_chunks);
    info_ptr->unknown_chunks=NULL;

    for (i = 0; i < num_unknowns; i++)
    {
       png_unknown_chunkp to = np + info_ptr->unknown_chunks_num + i;
       png_unknown_chunkp from = unknowns + i;

       png_memcpy((png_charp)to->name, 
                  (png_charp)from->name, 
                  png_sizeof(from->name));
       to->name[png_sizeof(to->name)-1] = '\0';
       to->size = from->size;
       /* note our location in the read or write sequence */
       to->location = (png_byte)(png_ptr->mode & 0xff);

       if (from->size == 0)
          to->data=NULL;
       else
       {
          to->data = (png_bytep)png_malloc_warn(png_ptr,
            (png_uint_32)from->size);
          if (to->data == NULL)
          {
             png_warning(png_ptr,
              "Out of memory while processing unknown chunk.");
             to->size = 0;
          }
          else
             png_memcpy(to->data, from->data, from->size);
       }
    }
d1011 19
a1029 2
    info_ptr->unknown_chunks = np;
    info_ptr->unknown_chunks_num += num_unknowns;
d1031 1
a1031 1
    info_ptr->free_me |= PNG_FREE_UNKN;
d1039 1
a1039 1
         (int)info_ptr->unknown_chunks_num)
d1052 1
d1054 1
d1064 1
a1064 1
#if defined(PNG_MNG_FEATURES_SUPPORTED)
d1069 1
d1078 1
a1078 1
#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
d1083 6
a1088 6
    png_bytep new_list, p;
    int i, old_num_chunks;
    if (png_ptr == NULL)
       return;
    if (num_chunks == 0)
    {
d1090 1
a1090 1
        png_ptr->flags |= PNG_FLAG_KEEP_UNKNOWN_CHUNKS;
d1092 1
a1092 1
        png_ptr->flags &= ~PNG_FLAG_KEEP_UNKNOWN_CHUNKS;
d1095 1
a1095 1
        png_ptr->flags |= PNG_FLAG_KEEP_UNSAFE_CHUNKS;
d1097 1
a1097 1
        png_ptr->flags &= ~PNG_FLAG_KEEP_UNSAFE_CHUNKS;
d1099 2
a1100 2
    }
    if (chunk_list == NULL)
d1102 3
a1104 3
    old_num_chunks = png_ptr->num_chunk_list;
    new_list=(png_bytep)png_malloc(png_ptr,
       (png_uint_32)
d1106 3
a1108 3
    if (png_ptr->chunk_list != NULL)
    {
       png_memcpy(new_list, png_ptr->chunk_list,
d1110 4
a1113 4
       png_free(png_ptr, png_ptr->chunk_list);
       png_ptr->chunk_list=NULL;
    }
    png_memcpy(new_list + 5*old_num_chunks, chunk_list,
d1115 4
a1118 4
    for (p = new_list + 5*old_num_chunks + 4, i = 0; i<num_chunks; i++, p += 5)
       *p=(png_byte)keep;
    png_ptr->num_chunk_list = old_num_chunks + num_chunks;
    png_ptr->chunk_list = new_list;
d1120 1
a1120 1
    png_ptr->free_me |= PNG_FREE_LIST;
d1125 1
a1125 1
#if defined(PNG_READ_USER_CHUNKS_SUPPORTED)
d1131 1
d1134 1
d1140 1
a1140 1
#if defined(PNG_INFO_IMAGE_SUPPORTED)
a1156 1
#ifdef PNG_WRITE_SUPPORTED
a1168 1
#endif
d1179 26
d1206 1
a1206 1
/* this function was added to libpng 1.2.6 */
d1211 8
a1218 7
    /* Images with dimensions larger than these limits will be
     * rejected by png_set_IHDR().  To accept any PNG datastream
     * regardless of dimensions, set both limits to 0x7ffffffL.
     */
    if (png_ptr == NULL) return;
    png_ptr->user_width_max = user_width_max;
    png_ptr->user_height_max = user_height_max;
d1222 13
@


1.3
log
@merge libpng upgrade

major version bump because function signature of png_decompress_chunk
changed (return value to void)
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.30 [August 15, 2008]
d6 1
a6 1
 * Copyright (c) 1998-2008 Glenn Randers-Pehrson
d24 1
a24 1
   png_debug1(1, "in %s storage function\n", "bKGD");
d40 1
a40 1
   png_debug1(1, "in %s storage function\n", "cHRM");
a42 25
   if (!(white_x || white_y || red_x || red_y || green_x || green_y ||
       blue_x || blue_y))
   {
      png_warning(png_ptr,
        "Ignoring attempt to set all-zero chromaticity values");
      return;
   }
   if (white_x < 0.0 || white_y < 0.0 ||
         red_x < 0.0 ||   red_y < 0.0 ||
       green_x < 0.0 || green_y < 0.0 ||
        blue_x < 0.0 ||  blue_y < 0.0)
   {
      png_warning(png_ptr,
        "Ignoring attempt to set negative chromaticity value");
      return;
   }
   if (white_x > 21474.83 || white_y > 21474.83 ||
         red_x > 21474.83 ||   red_y > 21474.83 ||
       green_x > 21474.83 || green_y > 21474.83 ||
        blue_x > 21474.83 ||  blue_y > 21474.83)
   {
      png_warning(png_ptr,
        "Ignoring attempt to set chromaticity value exceeding 21474.83");
      return;
   }
d64 2
a65 1
#endif
d73 1
a73 1
   png_debug1(1, "in %s storage function\n", "cHRM");
d77 4
a80 11
   if (!(white_x || white_y || red_x || red_y || green_x || green_y ||
       blue_x || blue_y))
   {
      png_warning(png_ptr,
        "Ignoring attempt to set all-zero chromaticity values");
      return;
   }
   if (white_x < 0 || white_y < 0 ||
         red_x < 0 ||   red_y < 0 ||
       green_x < 0 || green_y < 0 ||
        blue_x < 0 ||  blue_y < 0)
d82 8
a89 25
      png_warning(png_ptr,
        "Ignoring attempt to set negative chromaticity value");
      return;
   }
   if (white_x > (png_fixed_point) PNG_UINT_31_MAX ||
       white_y > (png_fixed_point) PNG_UINT_31_MAX ||
         red_x > (png_fixed_point) PNG_UINT_31_MAX ||
         red_y > (png_fixed_point) PNG_UINT_31_MAX ||
       green_x > (png_fixed_point) PNG_UINT_31_MAX ||
       green_y > (png_fixed_point) PNG_UINT_31_MAX ||
        blue_x > (png_fixed_point) PNG_UINT_31_MAX ||
        blue_y > (png_fixed_point) PNG_UINT_31_MAX )
   {
      png_warning(png_ptr,
        "Ignoring attempt to set chromaticity value exceeding 21474.83");
      return;
   }
   info_ptr->int_x_white = white_x;
   info_ptr->int_y_white = white_y;
   info_ptr->int_x_red   = red_x;
   info_ptr->int_y_red   = red_y;
   info_ptr->int_x_green = green_x;
   info_ptr->int_y_green = green_y;
   info_ptr->int_x_blue  = blue_x;
   info_ptr->int_y_blue  = blue_y;
d91 8
a98 8
   info_ptr->x_white = (float)(white_x/100000.);
   info_ptr->y_white = (float)(white_y/100000.);
   info_ptr->x_red   = (float)(  red_x/100000.);
   info_ptr->y_red   = (float)(  red_y/100000.);
   info_ptr->x_green = (float)(green_x/100000.);
   info_ptr->y_green = (float)(green_y/100000.);
   info_ptr->x_blue  = (float)( blue_x/100000.);
   info_ptr->y_blue  = (float)( blue_y/100000.);
d100 2
a101 1
   info_ptr->valid |= PNG_INFO_cHRM;
d103 2
a104 2
#endif
#endif
d112 1
a112 1
   png_debug1(1, "in %s storage function\n", "gAMA");
d139 1
a139 1
   png_debug1(1, "in %s storage function\n", "gAMA");
d176 1
a176 1
   png_debug1(1, "in %s storage function\n", "hIST");
d219 1
a219 1
   png_debug1(1, "in %s storage function\n", "IHDR");
d326 1
a326 1
   png_debug1(1, "in %s storage function\n", "oFFs");
d346 1
a346 1
   png_debug1(1, "in %s storage function\n", "pCAL");
d351 1
a351 1
   png_debug1(3, "allocating purpose for info (%lu bytes)\n",
d361 1
a361 1
   png_debug(3, "storing X0, X1, type, and nparams in info\n");
d368 1
a368 1
   png_debug1(3, "allocating units for info (%lu bytes)\n",
d386 5
a390 1
   info_ptr->pcal_params[nparams] = NULL;
d395 1
a395 1
      png_debug2(3, "allocating parameter %d for info (%lu bytes)\n", i,
a406 3
#ifdef PNG_FREE_ME_SUPPORTED
   info_ptr->free_me |= PNG_FREE_PCAL;
#endif
d416 1
a416 1
   png_debug1(1, "in %s storage function\n", "sCAL");
d434 1
a434 1
   png_debug1(1, "in %s storage function\n", "sCAL");
d441 1
a441 1
   png_debug1(3, "allocating unit for info (%u bytes)\n",
d453 1
a453 1
   png_debug1(3, "allocating unit for info (%u bytes)\n",
d479 1
a479 1
   png_debug1(1, "in %s storage function\n", "pHYs");
d495 1
a495 1
   png_debug1(1, "in %s storage function\n", "PLTE");
d544 1
a544 1
   png_debug1(1, "in %s storage function\n", "sBIT");
d557 1
a557 1
   png_debug1(1, "in %s storage function\n", "sRGB");
a580 1
#ifdef PNG_FIXED_POINT_SUPPORTED
d584 1
a584 2
#endif
   png_debug1(1, "in %s storage function\n", "sRGB_gAMA_and_cHRM");
a601 1
#ifdef PNG_FIXED_POINT_SUPPORTED
a610 4
   png_set_cHRM_fixed(png_ptr, info_ptr,
      int_white_x, int_white_y, int_red_x, int_red_y, int_green_x, int_green_y,
      int_blue_x, int_blue_y);
#endif
d620 1
d622 10
a631 2
   png_set_cHRM(png_ptr, info_ptr,
      white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y);
d633 3
d637 2
d640 1
a640 1
#endif
d653 1
a653 1
   png_debug1(1, "in %s storage function\n", "iCCP");
d707 1
a707 1
   png_debug1(1, "in %s storage function\n", (png_ptr->chunk_name[0] == '\0' ?
d749 1
a749 1
      png_debug1(3, "allocated %d entries for info_ptr->text\n",
d809 1
a809 1
      png_debug2(2, "Allocated %lu bytes at %x in png_set_text\n",
d857 1
a857 1
      png_debug1(3, "transferred text chunk %d\n", info_ptr->num_text);
d867 1
a867 1
   png_debug1(1, "in %s storage function\n", "tIME");
d882 1
a882 1
   png_debug1(1, "in %s storage function\n", "tRNS");
d964 1
d1088 1
a1088 1
   png_debug(1, "in png_permit_empty_plte, DEPRECATED.\n");
d1102 1
a1102 1
   png_debug(1, "in png_permit_mng_features\n");
d1163 1
a1163 1
   png_debug(1, "in png_set_read_user_chunk_fn\n");
d1175 1
a1175 1
   png_debug1(1, "in %s storage function\n", "rows");
@


1.2
log
@merge and fix for __CRAZY=Yes
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.25 [February 18, 2008]
a17 1

d170 1
a170 1
      ourgamma=file_gamma;
d176 1
a176 1
   if(ourgamma == 0.0)
d200 1
a200 1
       ourgamma=0;
d203 1
a203 1
       ourgamma=int_gamma;
d212 1
a212 1
   if(ourgamma == 0)
d240 1
a240 1
      (png_uint_32)(PNG_MAX_PALETTE_LENGTH * png_sizeof (png_uint_16)));
d321 3
a323 3
   if((png_ptr->mode&PNG_HAVE_PNG_SIGNATURE)&&png_ptr->mng_features_permitted)
      png_warning(png_ptr,"MNG features are not allowed in a PNG datastream");
   if(filter_type != PNG_FILTER_TYPE_BASE)
d325 1
a325 1
     if(!((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&
d331 1
a331 1
     if(png_ptr->mode&PNG_HAVE_PNG_SIGNATURE)
d335 1
a335 1
   if(filter_type != PNG_FILTER_TYPE_BASE)
d365 1
a365 1
      info_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth,width);
d398 2
a399 1
   png_debug1(3, "allocating purpose for info (%lu bytes)\n", length);
d402 1
a402 1
     {
d404 2
a405 2
       return;
     }
d415 2
a416 1
   png_debug1(3, "allocating units for info (%lu bytes)\n", length);
d419 1
a419 1
     {
d421 2
a422 2
       return;
     }
d428 1
a428 1
     {
d430 2
a431 2
       return;
     }
d438 2
a439 1
      png_debug2(3, "allocating parameter %d for info (%lu bytes)\n", i, length);
d442 1
a442 1
        {
d445 1
a445 1
        }
d487 2
a488 1
   png_debug1(3, "allocating unit for info (%d bytes)\n", length);
d499 2
a500 1
   png_debug1(3, "allocating unit for info (%d bytes)\n", length);
d505 1
d572 1
a572 1
   png_memcpy(png_ptr->palette, palette, num_palette * png_sizeof (png_color));
d594 1
a594 1
   png_memcpy(&(info_ptr->sig_bit), sig_bit, png_sizeof (png_color_8));
d708 2
a709 1
      png_warning(png_ptr, "Insufficient memory to process iCCP profile.");
d735 1
a735 1
   ret=png_set_text_2(png_ptr, info_ptr, text_ptr, num_text);
d766 1
a766 1
            (png_uint_32)(info_ptr->max_text * png_sizeof (png_text)));
d781 1
a781 1
            (png_uint_32)(info_ptr->max_text * png_sizeof (png_text)));
d793 2
a794 2
      png_size_t text_length,key_len;
      png_size_t lang_len,lang_key_len;
d802 1
a802 1
      if(text_ptr[i].compression <= 0)
d831 1
a831 1
         if(text_ptr[i].compression > 0)
d844 2
a845 1
         (png_uint_32)(key_len + text_length + lang_len + lang_key_len + 4));
d849 2
a850 1
         (png_uint_32)(key_len + lang_len + lang_key_len + text_length + 4),
d855 1
a855 1
      *(textp->key+key_len) = '\0';
d859 1
a859 1
         textp->lang=textp->key + key_len + 1;
d861 2
a862 2
         *(textp->lang+lang_len) = '\0';
         textp->lang_key=textp->lang + lang_len + 1;
d864 2
a865 2
         *(textp->lang_key+lang_key_len) = '\0';
         textp->text=textp->lang_key + lang_key_len + 1;
d874 1
a874 1
         textp->text=textp->key + key_len + 1;
d876 1
a876 1
      if(text_length)
d879 1
a879 1
      *(textp->text+text_length) = '\0';
d882 1
a882 1
      if(textp->compression > 0)
d911 1
a911 1
   png_memcpy(&(info_ptr->mod_time), mod_time, png_sizeof (png_time));
d932 1
d936 1
d940 1
a940 1
       if (num_trans <= PNG_MAX_PALETTE_LENGTH)
a941 5
#ifdef PNG_FREE_ME_SUPPORTED
       info_ptr->free_me |= PNG_FREE_TRNS;
#else
       png_ptr->flags |= PNG_FLAG_FREE_TRNS;
#endif
d946 9
d960 1
d962 9
a970 1
   info_ptr->valid |= PNG_INFO_tRNS;
d978 7
d993 2
a994 1
        (info_ptr->splt_palettes_num + nentries) * png_sizeof(png_sPLT_t));
d1022 1
a1022 1
            from->nentries * png_sizeof(png_sPLT_entry));
d1027 1
a1027 1
           png_free(png_ptr,to->name);
d1058 2
a1059 2
        (info_ptr->unknown_chunks_num + num_unknowns) *
        png_sizeof(png_unknown_chunk));
d1074 2
a1075 2
        png_unknown_chunkp to = np + info_ptr->unknown_chunks_num + i;
        png_unknown_chunkp from = unknowns + i;
d1077 7
a1083 4
        png_memcpy((png_charp)to->name, 
                   (png_charp)from->name, 
                   png_sizeof(from->name));
        to->name[png_sizeof(to->name)-1] = '\0';
d1085 9
a1093 4
        to->data = (png_bytep)png_malloc_warn(png_ptr, from->size);
        if (to->data == NULL)
        {
           png_warning(png_ptr,
d1095 5
a1099 9
        }
        else
        {
           png_memcpy(to->data, from->data, from->size);
           to->size = from->size;

           /* note our location in the read or write sequence */
           to->location = (png_byte)(png_ptr->mode & 0xff);
        }
d1112 1
a1112 1
   if(png_ptr != NULL && info_ptr != NULL && chunk >= 0 && chunk <
d1160 1
a1160 1
      if(keep == PNG_HANDLE_CHUNK_ALWAYS || keep == PNG_HANDLE_CHUNK_IF_SAFE)
d1165 1
a1165 1
      if(keep == PNG_HANDLE_CHUNK_ALWAYS)
d1173 1
a1173 1
    old_num_chunks=png_ptr->num_chunk_list;
d1175 3
a1177 2
       (png_uint_32)(5*(num_chunks+old_num_chunks)));
    if(png_ptr->chunk_list != NULL)
d1184 1
a1184 1
    png_memcpy(new_list+5*old_num_chunks, chunk_list,
d1186 1
a1186 1
    for (p=new_list+5*old_num_chunks+4, i=0; i<num_chunks; i++, p+=5)
d1188 2
a1189 2
    png_ptr->num_chunk_list=old_num_chunks+num_chunks;
    png_ptr->chunk_list=new_list;
d1218 1
a1218 1
   if(info_ptr->row_pointers && (info_ptr->row_pointers != row_pointers))
d1221 1
a1221 1
   if(row_pointers)
d1228 2
a1229 1
png_set_compression_buffer_size(png_structp png_ptr, png_uint_32 size)
d1233 1
a1233 2
    if(png_ptr->zbuf)
       png_free(png_ptr, png_ptr->zbuf);
d1260 1
a1260 1
    if(png_ptr == NULL) return;
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
 * libpng 1.2.8 - December 3, 2004
d6 1
a6 1
 * Copyright (c) 1998-2004 Glenn Randers-Pehrson
d19 2
d44 7
a50 1

d102 7
d118 8
a125 8
   if (white_x > (double) PNG_UINT_31_MAX ||
       white_y > (double) PNG_UINT_31_MAX ||
         red_x > (double) PNG_UINT_31_MAX ||
         red_y > (double) PNG_UINT_31_MAX ||
       green_x > (double) PNG_UINT_31_MAX ||
       green_y > (double) PNG_UINT_31_MAX ||
        blue_x > (double) PNG_UINT_31_MAX ||
        blue_y > (double) PNG_UINT_31_MAX)
d159 1
a159 1
   double gamma;
d168 1
a168 1
      gamma=21474.83;
d171 2
a172 2
      gamma=file_gamma;
   info_ptr->gamma = (float)gamma;
d174 1
a174 1
   info_ptr->int_gamma = (int)(gamma*100000.+.5);
d177 1
a177 1
   if(gamma == 0.0)
d185 1
a185 1
   png_fixed_point gamma;
d194 1
a194 1
     gamma=PNG_UINT_31_MAX;
d201 1
a201 1
       gamma=0;
d204 1
a204 1
       gamma=int_gamma;
d207 1
a207 1
   info_ptr->gamma = (float)(gamma/100000.);
d210 1
a210 1
   info_ptr->int_gamma = gamma;
d213 1
a213 1
   if(gamma == 0)
d227 2
a228 1
   if (info_ptr->num_palette == 0)
d231 1
a231 1
          "Palette size 0, hIST allocation skipped.");
d238 2
a239 1
   /* Changed from info->num_palette to 256 in version 1.2.1 */
d241 1
a241 1
      (png_uint_32)(256 * png_sizeof (png_uint_16)));
d323 1
a323 1
      png_warning(png_ptr,"MNG features are not allowed in a PNG datastream\n");
d329 1
a329 1
        (color_type == PNG_COLOR_TYPE_RGB || 
d358 1
a358 1
   if ( width > (PNG_UINT_32_MAX
d489 3
a491 1
      png_warning(png_ptr, "Memory allocation failed while processing sCAL.");
d501 3
a503 1
      png_warning(png_ptr, "Memory allocation failed while processing sCAL.");
a505 1

d540 11
d560 2
a561 1
   /* Changed in libpng-1.2.1 to allocate 256 instead of num_palette entries,
d564 3
a566 2
      256 * png_sizeof(png_color));
   png_memset(png_ptr->palette, 0, 256 * png_sizeof(png_color));
d685 1
d691 2
a692 1
   new_iccp_name = (png_charp)png_malloc_warn(png_ptr, png_strlen(name)+1);
d698 1
a698 1
   png_strcpy(new_iccp_name, name);
a886 1
      info_ptr->text[info_ptr->num_text]= *textp;
d927 1
a927 1
       /* Changed from num_trans to 256 in version 1.2.1 */
d929 3
a931 2
           (png_uint_32)256);
       png_memcpy(info_ptr->trans, trans, (png_size_t)num_trans);
d959 3
d979 1
d981 19
a999 7
        to->name = (png_charp)png_malloc(png_ptr,
            png_strlen(from->name) + 1);
        /* TODO: use png_malloc_warn */
        png_strcpy(to->name, from->name);
        to->entries = (png_sPLT_entryp)png_malloc(png_ptr,
            from->nentries * png_sizeof(png_sPLT_t));
        /* TODO: use png_malloc_warn */
d1001 1
a1001 1
            from->nentries * png_sizeof(png_sPLT_t));
d1031 2
a1032 1
       png_warning(png_ptr, "Out of memory while processing unknown chunk.");
d1046 5
a1050 1
        png_strncpy((png_charp)to->name, (png_charp)from->name, 5);
d1054 2
a1055 1
           png_warning(png_ptr, "Out of memory processing unknown chunk.");
d1083 1
d1090 1
a1090 1
      and will be removed from libpng-2.0.0 */
d1095 1
a1095 1
     ((png_ptr->mng_features_permitted & (~(PNG_FLAG_MNG_EMPTY_PLTE))) |
d1099 1
d1121 2
d1166 2
d1194 2
d1209 1
a1209 1
      info_ptr->valid &= ~(mask);
a1213 55
#ifdef PNG_ASSEMBLER_CODE_SUPPORTED
/* this function was added to libpng 1.2.0 and should always exist by default */
void PNGAPI
png_set_asm_flags (png_structp png_ptr, png_uint_32 asm_flags)
{
    png_uint_32 settable_asm_flags;
    png_uint_32 settable_mmx_flags;

    settable_mmx_flags =
#ifdef PNG_HAVE_ASSEMBLER_COMBINE_ROW
                         PNG_ASM_FLAG_MMX_READ_COMBINE_ROW  |
#endif
#ifdef PNG_HAVE_ASSEMBLER_READ_INTERLACE
                         PNG_ASM_FLAG_MMX_READ_INTERLACE    |
#endif
#ifdef PNG_HAVE_ASSEMBLER_READ_FILTER_ROW
                         PNG_ASM_FLAG_MMX_READ_FILTER_SUB   |
                         PNG_ASM_FLAG_MMX_READ_FILTER_UP    |
                         PNG_ASM_FLAG_MMX_READ_FILTER_AVG   |
                         PNG_ASM_FLAG_MMX_READ_FILTER_PAETH |
#endif
                         0;

    /* could be some non-MMX ones in the future, but not currently: */
    settable_asm_flags = settable_mmx_flags;

    if (!(png_ptr->asm_flags & PNG_ASM_FLAG_MMX_SUPPORT_COMPILED) ||
        !(png_ptr->asm_flags & PNG_ASM_FLAG_MMX_SUPPORT_IN_CPU))
    {
        /* clear all MMX flags if MMX isn't supported */
        settable_asm_flags &= ~settable_mmx_flags;
        png_ptr->asm_flags &= ~settable_mmx_flags;
    }

    /* we're replacing the settable bits with those passed in by the user,
     * so first zero them out of the master copy, then logical-OR in the
     * allowed subset that was requested */

    png_ptr->asm_flags &= ~settable_asm_flags;               /* zero them */
    png_ptr->asm_flags |= (asm_flags & settable_asm_flags);  /* set them */
}
#endif /* ?PNG_ASSEMBLER_CODE_SUPPORTED */

#ifdef PNG_ASSEMBLER_CODE_SUPPORTED
/* this function was added to libpng 1.2.0 */
void PNGAPI
png_set_mmx_thresholds (png_structp png_ptr,
                        png_byte mmx_bitdepth_threshold,
                        png_uint_32 mmx_rowbytes_threshold)
{
    png_ptr->mmx_bitdepth_threshold = mmx_bitdepth_threshold;
    png_ptr->mmx_rowbytes_threshold = mmx_rowbytes_threshold;
}
#endif /* ?PNG_ASSEMBLER_CODE_SUPPORTED */

d1224 1
d1231 1
@


1.1.107.1
log
@libpng-1_2_8 with the following directories removed:
- contrib
- projects
- scripts
@
text
@@


1.1.107.2
log
@there's a newer libpng out there
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.9 April 14, 2006
d6 1
a6 1
 * Copyright (c) 1998-2006 Glenn Randers-Pehrson
a18 2
#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)

a102 1
#ifdef PNG_FLOATING_POINT_SUPPORTED
a110 10
#else
   if (white_x > (png_fixed_point) PNG_UINT_31_MAX/100000L ||
       white_y > (png_fixed_point) PNG_UINT_31_MAX/100000L ||
         red_x > (png_fixed_point) PNG_UINT_31_MAX/100000L ||
         red_y > (png_fixed_point) PNG_UINT_31_MAX/100000L ||
       green_x > (png_fixed_point) PNG_UINT_31_MAX/100000L ||
       green_y > (png_fixed_point) PNG_UINT_31_MAX/100000L ||
        blue_x > (png_fixed_point) PNG_UINT_31_MAX/100000L ||
        blue_y > (png_fixed_point) PNG_UINT_31_MAX/100000L)
#endif
d212 1
a212 2
   if (info_ptr->num_palette <= 0 || info_ptr->num_palette
       > PNG_MAX_PALETTE_LENGTH)
d215 1
a215 1
          "Invalid palette size, hIST allocation skipped.");
d222 1
a222 2
   /* Changed from info->num_palette to PNG_MAX_PALETTE_LENGTH in version
      1.2.1 */
d224 1
a224 1
      (png_uint_32)(PNG_MAX_PALETTE_LENGTH * png_sizeof (png_uint_16)));
d306 1
a306 1
      png_warning(png_ptr,"MNG features are not allowed in a PNG datastream");
d312 1
a312 1
        (color_type == PNG_COLOR_TYPE_RGB ||
a519 11
   if (num_palette < 0 || num_palette > PNG_MAX_PALETTE_LENGTH)
     {
       if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
         png_error(png_ptr, "Invalid palette length");
       else
       {
         png_warning(png_ptr, "Invalid palette length");
         return;
       }
     }

d529 1
a529 2
   /* Changed in libpng-1.2.1 to allocate PNG_MAX_PALETTE_LENGTH instead
      of num_palette entries,
d532 2
a533 3
      PNG_MAX_PALETTE_LENGTH * png_sizeof(png_color));
   png_memset(png_ptr->palette, 0, PNG_MAX_PALETTE_LENGTH *
      png_sizeof(png_color));
d893 1
a893 1
       /* Changed from num_trans to PNG_MAX_PALETTE_LENGTH in version 1.2.1 */
d895 2
a896 3
           (png_uint_32)PNG_MAX_PALETTE_LENGTH);
       if (num_trans <= PNG_MAX_PALETTE_LENGTH)
         png_memcpy(info_ptr->trans, trans, (png_size_t)num_trans);
a923 3
    if (png_ptr == NULL || info_ptr == NULL)
       return;

a1025 1
#if defined(PNG_1_0_X) || defined(PNG_1_2_X)
d1032 1
a1032 1
      and will be removed from libpng-1.3.0 */
a1040 1
#endif
a1061 2
    if (png_ptr == NULL)
       return;
a1104 2
   if (png_ptr == NULL)
      return;
a1130 2
    if (png_ptr == NULL)
       return;
a1156 3
    if (png_ptr == NULL)
       return;

a1198 2
    if (png_ptr == NULL)
       return;
a1219 1
#endif /* PNG_READ_SUPPORTED || PNG_WRITE_SUPPORTED */
@


1.1.107.3
log
@Upgrade libpng (fixes some holes)
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.17 May 15, 2007
d6 1
a6 1
 * Copyright (c) 1998-2007 Glenn Randers-Pehrson
a879 1
#if 0 /* appears to be redundant; */
a880 1
#endif
d979 1
a979 1
            from->nentries * png_sizeof(png_sPLT_entry));
d982 1
a982 1
            from->nentries * png_sizeof(png_sPLT_entry));
a1193 1
#ifdef PNG_MMX_CODE_SUPPORTED
d1196 1
a1196 1
#endif
a1198 1
#ifdef PNG_MMX_CODE_SUPPORTED
d1201 1
a1201 1
#ifdef PNG_HAVE_MMX_COMBINE_ROW
d1204 1
a1204 1
#ifdef PNG_HAVE_MMX_READ_INTERLACE
d1207 1
a1207 1
#ifdef PNG_HAVE_MMX_READ_FILTER_ROW
d1227 1
a1227 1
     * so first zero them out of the master copy, then bitwise-OR in the
a1231 1
#endif /* ?PNG_MMX_CODE_SUPPORTED */
d1233 1
d1235 1
a1243 1
#ifdef PNG_MMX_CODE_SUPPORTED
a1245 1
#endif /* ?PNG_MMX_CODE_SUPPORTED */
a1258 1
    if(png_ptr == NULL) return;
@


1.1.107.4
log
@Import libpng-1.2.25 with the following change log.
Requested by bsiegert@@ due to security fix relevance.

version 1.2.19beta1 [May 18, 2007]
  Changed "const static" to "static PNG_CONST" everywhere, mostly undoing
    change of libpng-1.2.17beta2.  Changed other "const" to "PNG_CONST"
  Changed some handling of unused parameters, to avoid compiler warnings.
    "if (unused == NULL) return;" becomes "unused = unused".

version 1.2.19beta2 [May 18, 2007]
  Only use the valid bits of tRNS value in png_do_expand() (Brian Cartier)

version 1.2.19beta3 [May 19, 2007]
  Add some "png_byte" typecasts in png_check_keyword() and write new_key
  instead of key in zTXt chunk (Kevin Ryde).

version 1.2.19beta4 [May 21, 2007]
  Add png_snprintf() function and use it in place of sprint() for improved
    defense against buffer overflows.

version 1.2.19beta5 [May 21, 2007]
  Fixed png_handle_tRNS() to only use the valid bits of tRNS value.
  Changed handling of more unused parameters, to avoid compiler warnings.
  Removed some PNG_CONST in pngwutil.c to avoid compiler warnings.

version 1.2.19beta6 [May 22, 2007]
  Added some #ifdef PNG_MMX_CODE_SUPPORTED where needed in pngvcrd.c
  Added a special "_MSC_VER" case that defines png_snprintf to _snprintf

version 1.2.19beta7 [May 22, 2007]
  Squelched png_squelch_warnings() in pnggccrd.c and added an
    #ifdef PNG_MMX_CODE_SUPPORTED block around the declarations that caused
    the warnings that png_squelch_warnings was squelching.

version 1.2.19beta8 [May 22, 2007]
  Removed __MMX__ from test in pngconf.h.

version 1.2.19beta9 [May 23, 2007]
  Made png_squelch_warnings() available via PNG_SQUELCH_WARNINGS macro.
  Revised png_squelch_warnings() so it might work.
  Updated makefile.sgcc and makefile.solaris; added makefile.solaris-x86.

version 1.2.19beta10 [May 24, 2007]
  Resquelched png_squelch_warnings(), use "__attribute__((used))" instead.

version 1.2.19beta11 [May 28, 2007]
  Return 0 from png_get_sPLT() and png_get_unknown_chunks() if png_ptr is NULL;
    changed three remaining instances of png_strcpy() to png_strncpy() (David
    Hill).
  Make test for NULL row_buf at the beginning of png_do_read_transformations
    unconditional.

version 1.2.19beta12 [May 28, 2007]
  Revised pnggccrd.c.

version 1.2.19beta13 [June 14, 2007]
  Prefer PNG_USE_PNGVCRD when _MSC_VER is defined in pngconf.h

version 1.2.19beta14 [June 16, 2007]
  Fix bug with handling of 16-bit transparency, introduced in 1.2.19beta2

version 1.2.19beta15 [June 17, 2007]
  Revised pnggccrd.c.

version 1.2.19beta16 [June 18, 2007]
  Revised pnggccrd.c again.
  Updated contrib/gregbook.
  Changed '#include "pnggccrd.c"' to 'include "$srcdir/pnggccrd.c"'
    in configure.ac

version 1.2.19beta17 [June 19, 2007]
  Revised many of the makefiles, to set -DPNG_NO_MMX_CODE where needed
    and to not use -O3 unless -DPNG_NO_MMX_CODE is also set.

version 1.2.19beta18 [June 23, 2007]
  Replaced some C++ style comments with C style comments in pnggccrd.c.
  Copied optimized C code from pnggccrd.c to pngrutil.c, removed dependency
    on pnggccrd.o from many makefiles.
  Added sl and dylib to list of extensions be installed by Makefile.am

version 1.2.19beta19 [June 28, 2007]
  Fixed testing PNG_RGB_TO_GRAY_ERR & PNG_RGB_TO_GRAY_WARN in pngrtran.c
  More cleanup of pnggccrd.c and pngvcrd.c

version 1.2.19beta20 [June 29, 2007]
  Rebuilt Makefile.in and configure using libtool-1.5.24.
  Fixed typo in pnggccrd.c

version 1.2.19beta21 [June 30, 2007]
  More revision of pnggccrd.c
  Added "test" target to Makefile.in and Makefile.am

version 1.2.19beta22 [July 3, 2007]
  Added info about pngrutil/pnggccrd/pngvcrd to png_get_header_version()
  Fix type definition of dummy_value_a, b in pnggccrd.c

version 1.2.19beta23 [July 10, 2007]
  Revert change to type definition of dummy_value_a, b in pnggccrd.c
  Make sure __PIC__ is defined in pnggccrd.c when PIC is defined.
  Require gcc-4.1 or better to use PNG_HAVE_MMX_FILTER_ROW on x86_64 platforms

version 1.2.19beta24 [July 14, 2007]
  Added PNG_NO_READ_FILTER, PNG_NO_WRITE_FILTER, PNG_NO_WARNING macros.
  Added contrib/pngminim to demonstrate building minimal encoder and decoder

version 1.2.19beta25 [July 15, 2007]
  Removed the new PNG_NO_READ_FILTER macro since it would make the library
    unable to read valid PNG files, and filtering is at the heart of the
    PNG format.

version 1.2.19beta26 [July 16, 2007]
  Changed "png_free(str)" to "png_free(png_ptr,str)" in pngrutil.c WinCE
    code (Yves Piguet).  This bug was introduced in libpng-1.2.14.
  Updated scripts/CMakeLists.txt
  Relocated a misplaced #endif in pnggccrd.c

version 1.2.19beta27 [July 17, 2007]
  Fixed incorrect stride and number of bytes copied (was 4 instead of
    6 bytes) in the cleanup loop of pnggccrd.c and pngvcrd.c for handling
    the end of 48-bit interlaced rows (Glenn R-P).

version 1.2.19beta28 [July 19, 2007]
  Removed requirement for gcc-4.1 or better to use PNG_HAVE_MMX_FILTER_ROW
    on x86_64 platforms
  Added png_warning() in pngrutil.c for short iCCP, iTXt, sPLT, or zTXT chunks.
  Revised pngtest.c so warnings are displayed regardless of PNG_NO_STDIO.

version 1.2.19beta29 [July 20, 2007]
  Fix typo in pnggccrd.c (%%eax should be %%ax in secondloop48)

version 1.2.19beta30 [July 26, 2007]
  Revised pnggccrd.c

version 1.2.19beta31 [July 27, 2007]
  Fix typos in pnggccrd.c

version 1.0.27rc1 and 1.2.19rc1 [July 31, 2007]
  Disable PNG_MMX_CODE_SUPPORTED when PNG_ASSEMBLER_CODE_SUPPORTED is off.
  Enable PNG_MMX_READ_FILTER_* by default, except when gcc-3.x is being
    used (they were inadvertently disabled in libpng-1.2.19beta23).
  Fix some debugging statements in pnggccrd.c and pngrutil.c
  Added information about disabling the MMX code in libpng documentation.

version 1.0.27rc2 and 1.2.19rc2 [August 4, 2007]
  Removed some "#if 0" blocks.
  Made a global struct local in pngvcrd.c to make it thread safe.
  Issue a png_error() if application attempts to transform a row tht
    has not been initialized.

version 1.0.27rc3 and 1.2.19rc3 [August 9, 2007]
  Slightly revised pngvcrd.c

version 1.0.27rc4 and 1.2.19rc4 [August 9, 2007]
  Revised pnggccrd.c debugging change of rc1, which was broken.
  Revised scripts/CMakeLists.txt
  Change default to PNG_NO_GLOBAL_ARRAYS for MSVC.
  Turn off PNG_FLAG_ROW_INIT flag when setting transforms that expand pixels.

version 1.0.27rc5 and 1.2.19rc5 [August 10, 2007]
  Fix typo (missing '"') in pnggccrd.c
  Revise handling of png_strtod in recent versions of WINCE

version 1.0.27rc6 and 1.2.19rc6 [August 15, 2007]
  Fix typo (missing ',') in contrib/gregbook/readpng2.c
  Undid row initialization error exit added to rc2 and rc4.

version 1.0.27 and 1.2.19 [August 18, 2007]
  Conditionally restored row initialization error exit.

version 1.2.20beta01 [August 19, 2007]
  Fixed problem with compiling pnggccrd.c on Intel-Apple platforms.
  Changed png_malloc() to png_malloc_warn() in png_set_sPLT().
  Added PNG_NO_ERROR_TEXT feature, with demo in contrib/pngminim
  Removed define PNG_WARN_UNINITIALIZED_ROW 1 /* 0: warning; 1: error */
    because it caused some trouble.

version 1.2.20beta02 [August 20, 2007]
  Avoid compiling pnggccrd.c on Intel-Apple platforms.

version 1.2.20beta03 [August 20, 2007]
  Added "/D PNG_NO_MMX_CODE" to the non-mmx builds of projects/visualc6
    and visualc71.

version 1.2.20beta04 [August 21, 2007]
  Revised pngvcrd.c for improved efficiency (Steve Snyder).

version 1.2.20rc1 [August 23, 2007]
  Revised pngconf.h to set PNG_NO_MMX_CODE for gcc-3.x compilers.

version 1.2.20rc2 [August 27, 2007]
  Revised scripts/CMakeLists.txt
  Revised #ifdefs to ensure one and only one of pnggccrd.c, pngvcrd.c,
    or part of pngrutil.c is selected.

version 1.2.20rc3 [August 30, 2007]
  Remove a little more code in pngwutil.c when PNG_NO_WRITE_FILTER is selected.
  Added /D _CRT_SECURE_NO_WARNINGS to visual6c and visualc71 projects.
  Compile png_mmx_support() in png.c even when PNG_NO_MMX_CODE is defined.
  Restored a "superfluous" #ifdef that was removed from 1.2.20rc2 pnggccrd.c,
    breaking the png_mmx_support() function.

version 1.2.20rc4 [September 1, 2007]
  Removed Intel contributions (MMX, Optimized C).

version 1.2.20rc5 [September 2, 2007]
  Restored configure and Makefile.in to rc3 and put a snippet of code in
    pnggccrd.c, to ensure configure makes the same PNG_NO_MMX_CODE selection

version 1.2.20rc6 [September 2, 2007]
  Fixed bugs in scripts/CMakeLists.txt
  Removed pngvcrd.c references from msvc projects.

version 1.0.28 and 1.2.20 [September 8, 2007]
  Removed "(NO READ SUPPORT)" from png_get_header_version() string.

version 1.2.21beta1 [September 14, 2007]
  Fixed various mistakes reported by George Cook and Jeff Phillips:
  logical vs bitwise NOT in pngrtran.c, bug introduced in 1.2.19rc2
  16-bit cheap transparency expansion, bug introduced in 1.2.19beta2
  errors with sizeof(unknown_chunk.name), bugs introduced in 1.2.19beta11
  <= compare with unsigned var in pngset.c, should be ==.

version 1.2.21beta2 [September 18, 2007]
  Removed some extraneous typecasts.

version 1.2.21rc1 [September 25, 2007]
  Fixed potential out-of-bounds reads in png_handle_pCAL() and
    png_handle_ztXt() ("flayer" results reported by Tavis Ormandy).

version 1.2.21rc2 [September 26, 2007]
  Fixed potential out-of-bounds reads in png_handle_sCAL(),
    png_handle_iTXt(), and png_push_read_tEXt().
  Remove some PNG_CONST declarations from pngwutil.c to avoid compiler warnings
  Revised makefiles to update paths in libpng.pc properly.

version 1.2.21rc3 [September 27, 2007]
  Revised makefiles to update "Libs" in libpng.pc properly.

version 1.0.29 and 1.2.21rc3 [October 4, 2007]
  No changes.

version 1.2.22beta1 [October 4, 2007]
  Again, fixed logical vs bitwise NOT in pngrtran.c, bug introduced
    in 1.2.19rc2

version 1.2.22beta2 [October 5, 2007]
  Fixed string length error in pngset.c (caused crashes while decoding iCCP)
  Add terminating NULL after each instance of png_strncpy().

version 1.2.22beta3 [October 6, 2007]
  Fix two off-by-one terminating NULL after png_strncpy().

version 1.2.22beta4 [October 7, 2007]
  Changed some 0 to '\0'.

version 1.0.30rc1 and 1.2.22rc1 [October 8, 2007]
  No changes.

version 1.0.30 and 1.2.22 [October 13, 2007]
  No changes.

version 1.2.23beta01 [October 15, 2007]
  Reduced number of invocations of png_strlen() in pngset.c.
  Changed [azAZ09_] to [_abcde...89] in Makefile.am for better localization.

version 1.2.23beta02 [October 16, 2007]
  Eliminated png_strncpy() and png_strcpy() (Pierre Poissinger)
  Changed $AN to $(AN) in Makefile.am.

version 1.2.23beta03 [October 16, 2007]
  Fixed off-by-one error in pngset.c
  Restore statement to set last character of buffer to \0 in pngerror.c

version 1.2.23beta04 [October 23, 2007]
  Reject attempt to set all-zero cHRM values.

version 1.2.23beta05 [October 26, 2007]
  Add missing quotes in projects/visualc6, lost in version 1.2.20rc3

version 1.2.23rc01 [November 2, 2007]
  No changes.

version 1.2.23 [November 6, 2007]
  No changes.

version 1.2.24beta01 [November 19, 2007]
  Moved misplaced test for malloc failure in png_set_sPLT().  This bug was
    introduced in libpng-1.2.20beta01.
  Ifdef out avg_row etc from png.h and pngwrite.c when PNG_NO_WRITE_FILTER
  Do not use png_ptr->free_fn and png_ptr->mem_fn in png_destroy_read_struct()
    when png_ptr is NULL (Marshall Clow).
  Updated handling of symbol prefixes in Makefile.am and configure.ac (Mike
    Frysinger).

version 1.2.24beta02 [November 30, 2007]
  Removed a useless test and fixed incorrect test in png_set_cHRM_fixed()
    (David Hill).

version 1.2.24rc01 [December 7, 2007]
  No changes.

version 1.2.24     [December 14, 2007]
  Make sure not to redefine _BSD_SOURCE in pngconf.h
  Revised gather.sh and makefile.std in contrib/pngminim to avoid compiling
    unused files.

version 1.2.25beta01 [January 7, 2008]
  Fixed bug with unknown chunk handling, introduced in version 1.2.17rc2

version 1.2.25beta02 [January 10, 2008]
  Prevent gamma from being applied twice.

version 1.2.25rc01 [January 17, 2008]
  No changes.

version 1.2.25beta03 [January 22, 2008]
  Fixed some continue-after-malloc-failure errors in pngset.c (David Hill)
  Check for info_ptr == NULL in png_read_info() and png_process_data().
  Check for possible use of NULL user_png_ver[] in png_create_read_struct().
  Change "if (swidth == NULL)" to "if (sheight == NULL)" in png_handle_sCAL
    (bug introduced in libpng-1.2.4/1.0.13).
  Return from png_destroy_read_struct() if png_ptr_ptr is NULL.
  Fix overflow of "msg" in png_decompres_chunk().

version 1.2.25beta04 [January 26, 2008]
  Work around Coverity bug report by slightly refactoring
    png_read_push_finish_row()

version 1.2.25beta05 [January 31, 2008]
  Added libpng-1.2.25beta05.tar.lzma to distribution.  Get the lzma codec
    from <http://tukaani.org/lzma>.
  Added lp1225b05.7z to distribution.  Get the 7-zip decoder from
    from <http://www.7-zip.org>.
  Fixed some broken links in the README file.

version 1.2.25beta06 [February 6, 2008]
  Refactored png_read_push_finish_row() again, trying to satisfy Coverity.
  Fixed potential NULL dereference of png_ptr in png_destroy_write_struct();
  clarified potential NULL dereference of png_ptr in png_destroy_read_struct();
  fixed potential NULL dereference of info_ptr in png_handle_bKGD();
  fixed potential NULL dereference of user_png_ver[] in
    png_create_write_struct_2(). (Coverity)

version 1.2.25rc02 [February 10, 2008]
  Reset png_ptr->pass in png_read_push_finish_row() before break.
  Changed "pass" from png_byte to int.

version 1.2.25 and 1.0.31 [February 18, 2008]
  No changes.
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.25 [February 18, 2008]
d6 1
a6 1
 * Copyright (c) 1998-2008 Glenn Randers-Pehrson
d44 1
a44 7
   if (!(white_x || white_y || red_x || red_y || green_x || green_y ||
       blue_x || blue_y))
   {
      png_warning(png_ptr,
        "Ignoring attempt to set all-zero chromaticity values");
      return;
   }
a95 7
   if (!(white_x || white_y || red_x || red_y || green_x || green_y ||
       blue_x || blue_y))
   {
      png_warning(png_ptr,
        "Ignoring attempt to set all-zero chromaticity values");
      return;
   }
d105 19
a123 8
   if (white_x > (png_fixed_point) PNG_UINT_31_MAX ||
       white_y > (png_fixed_point) PNG_UINT_31_MAX ||
         red_x > (png_fixed_point) PNG_UINT_31_MAX ||
         red_y > (png_fixed_point) PNG_UINT_31_MAX ||
       green_x > (png_fixed_point) PNG_UINT_31_MAX ||
       green_y > (png_fixed_point) PNG_UINT_31_MAX ||
        blue_x > (png_fixed_point) PNG_UINT_31_MAX ||
        blue_y > (png_fixed_point) PNG_UINT_31_MAX )
d225 1
a225 1
   if (info_ptr->num_palette == 0 || info_ptr->num_palette
d356 1
a356 1
   if (width > (PNG_UINT_32_MAX
d487 1
a487 3
      png_warning(png_ptr,
       "Memory allocation failed while processing sCAL.");
      return;
d497 1
a497 3
      png_warning(png_ptr,
       "Memory allocation failed while processing sCAL.");
      return;
d500 1
a679 1
   png_uint_32 length;
d685 1
a685 2
   length = png_strlen(name)+1;
   new_iccp_name = (png_charp)png_malloc_warn(png_ptr, length);
d691 1
a691 1
   png_memcpy(new_iccp_name, name, length);
d880 3
a974 1
        png_uint_32 length;
d976 5
a980 10
        length = png_strlen(from->name) + 1;
        to->name = (png_charp)png_malloc_warn(png_ptr, length);
        if (to->name == NULL)
        {
           png_warning(png_ptr,
             "Out of memory while processing sPLT chunk");
           continue;
        }
        png_memcpy(to->name, from->name, length);
        to->entries = (png_sPLT_entryp)png_malloc_warn(png_ptr,
d982 1
a982 8
        if (to->entries == NULL)
        {
           png_warning(png_ptr,
             "Out of memory while processing sPLT chunk");
           png_free(png_ptr,to->name);
           to->name = NULL;
           continue;
        }
d1014 1
a1014 2
       png_warning(png_ptr,
          "Out of memory while processing unknown chunk.");
d1028 1
a1028 5
        png_memcpy((png_charp)to->name, 
                   (png_charp)from->name, 
                   png_sizeof(from->name));
        to->name[png_sizeof(to->name)-1] = '\0';

d1032 1
a1032 2
           png_warning(png_ptr,
              "Out of memory while processing unknown chunk.");
d1072 1
a1072 1
     ((png_ptr->mng_features_permitted & (~PNG_FLAG_MNG_EMPTY_PLTE)) |
d1186 1
a1186 1
      info_ptr->valid &= ~mask;
d1192 1
a1192 1
/* function was added to libpng 1.2.0 and should always exist by default */
d1196 41
a1236 3
/* Obsolete as of libpng-1.2.20 and will be removed from libpng-1.4.0 */
    if (png_ptr != NULL)
    png_ptr->asm_flags = 0;
a1244 1
/* Obsolete as of libpng-1.2.20 and will be removed from libpng-1.4.0 */
d1247 4
@


1.1.107.5
log
@SECURITY update of libpng to 1.2.32
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.30 [August 15, 2008]
d18 1
d171 1
a171 1
      gamma = file_gamma;
d177 1
a177 1
   if (gamma == 0.0)
d201 1
a201 1
       gamma = 0;
d204 1
a204 1
       gamma = int_gamma;
d213 1
a213 1
   if (gamma == 0)
d241 1
a241 1
      (png_uint_32)(PNG_MAX_PALETTE_LENGTH * png_sizeof(png_uint_16)));
d322 3
a324 3
   if ((png_ptr->mode&PNG_HAVE_PNG_SIGNATURE)&&png_ptr->mng_features_permitted)
      png_warning(png_ptr, "MNG features are not allowed in a PNG datastream");
   if (filter_type != PNG_FILTER_TYPE_BASE)
d326 1
a326 1
     if (!((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&
d332 1
a332 1
     if (png_ptr->mode&PNG_HAVE_PNG_SIGNATURE)
d336 1
a336 1
   if (filter_type != PNG_FILTER_TYPE_BASE)
d366 1
a366 1
      info_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth, width);
d399 1
a399 2
   png_debug1(3, "allocating purpose for info (%lu bytes)\n",
     (unsigned long)length);
d402 1
a402 1
   {
d404 2
a405 2
      return;
   }
d415 1
a415 2
   png_debug1(3, "allocating units for info (%lu bytes)\n",
     (unsigned long)length);
d418 1
a418 1
   {
d420 2
a421 2
      return;
   }
d427 1
a427 1
   {
d429 2
a430 2
      return;
   }
d437 1
a437 2
      png_debug2(3, "allocating parameter %d for info (%lu bytes)\n", i,
        (unsigned long)length);
d440 1
a440 1
      {
d443 1
a443 1
      }
d485 1
a485 2
   png_debug1(3, "allocating unit for info (%u bytes)\n",
      (unsigned int)length);
d496 1
a496 2
   png_debug1(3, "allocating unit for info (%u bytes)\n",
      (unsigned int)length);
a500 1
      info_ptr->scal_s_width = NULL;
d567 1
a567 1
   png_memcpy(png_ptr->palette, palette, num_palette * png_sizeof(png_color));
d589 1
a589 1
   png_memcpy(&(info_ptr->sig_bit), sig_bit, png_sizeof(png_color_8));
d703 1
a703 2
      png_warning(png_ptr,
      "Insufficient memory to process iCCP profile.");
d729 1
a729 1
   ret = png_set_text_2(png_ptr, info_ptr, text_ptr, num_text);
d760 1
a760 1
            (png_uint_32)(info_ptr->max_text * png_sizeof(png_text)));
d775 1
a775 1
            (png_uint_32)(info_ptr->max_text * png_sizeof(png_text)));
d787 2
a788 2
      png_size_t text_length, key_len;
      png_size_t lang_len, lang_key_len;
d796 1
a796 1
      if (text_ptr[i].compression <= 0)
d825 1
a825 1
         if (text_ptr[i].compression > 0)
d838 1
a838 2
         (png_uint_32)
         (key_len + text_length + lang_len + lang_key_len + 4));
d842 1
a842 2
         (png_uint_32)
         (key_len + lang_len + lang_key_len + text_length + 4),
d847 1
a847 1
      *(textp->key + key_len) = '\0';
d851 1
a851 1
         textp->lang = textp->key + key_len + 1;
d853 2
a854 2
         *(textp->lang + lang_len) = '\0';
         textp->lang_key = textp->lang + lang_len + 1;
d856 2
a857 2
         *(textp->lang_key + lang_key_len) = '\0';
         textp->text = textp->lang_key + lang_key_len + 1;
d866 1
a866 1
         textp->text = textp->key + key_len + 1;
d868 1
a868 1
      if (text_length)
d871 1
a871 1
      *(textp->text + text_length) = '\0';
d874 1
a874 1
      if (textp->compression > 0)
d903 1
a903 1
   png_memcpy(&(info_ptr->mod_time), mod_time, png_sizeof(png_time));
a923 1

a926 1

d930 1
a930 1
       if (num_trans > 0 && num_trans <= PNG_MAX_PALETTE_LENGTH)
d932 5
a940 9
      int sample_max = (1 << info_ptr->bit_depth);
      if ((info_ptr->color_type == PNG_COLOR_TYPE_GRAY &&
          (int)trans_values->gray > sample_max) ||
          (info_ptr->color_type == PNG_COLOR_TYPE_RGB &&
          ((int)trans_values->red > sample_max ||
          (int)trans_values->green > sample_max ||
          (int)trans_values->blue > sample_max)))
        png_warning(png_ptr,
           "tRNS chunk has out-of-range samples for bit_depth");
a945 1

d947 1
a947 9
   if (num_trans != 0)
   {
      info_ptr->valid |= PNG_INFO_tRNS;
#ifdef PNG_FREE_ME_SUPPORTED
      info_ptr->free_me |= PNG_FREE_TRNS;
#else
      png_ptr->flags |= PNG_FLAG_FREE_TRNS;
#endif
   }
a954 7
/*
 *  entries        - array of png_sPLT_t structures
 *                   to be added to the list of palettes
 *                   in the info structure.
 *  nentries       - number of palette structures to be
 *                   added.
 */
d963 1
a963 2
        (info_ptr->splt_palettes_num + nentries) *
        (png_uint_32)png_sizeof(png_sPLT_t));
d991 1
a991 1
            (png_uint_32)(from->nentries * png_sizeof(png_sPLT_entry)));
d996 1
a996 1
           png_free(png_ptr, to->name);
d1027 2
a1028 2
        (png_uint_32)((info_ptr->unknown_chunks_num + num_unknowns) *
        png_sizeof(png_unknown_chunk)));
d1043 2
a1044 2
       png_unknown_chunkp to = np + info_ptr->unknown_chunks_num + i;
       png_unknown_chunkp from = unknowns + i;
d1046 4
a1049 7
       png_memcpy((png_charp)to->name, 
                  (png_charp)from->name, 
                  png_sizeof(from->name));
       to->name[png_sizeof(to->name)-1] = '\0';
       to->size = from->size;
       /* note our location in the read or write sequence */
       to->location = (png_byte)(png_ptr->mode & 0xff);
d1051 4
a1054 9
       if (from->size == 0)
          to->data=NULL;
       else
       {
          to->data = (png_bytep)png_malloc_warn(png_ptr,
            (png_uint_32)from->size);
          if (to->data == NULL)
          {
             png_warning(png_ptr,
d1056 9
a1064 5
             to->size = 0;
          }
          else
             png_memcpy(to->data, from->data, from->size);
       }
d1077 1
a1077 1
   if (png_ptr != NULL && info_ptr != NULL && chunk >= 0 && chunk <
d1125 1
a1125 1
      if (keep == PNG_HANDLE_CHUNK_ALWAYS || keep == PNG_HANDLE_CHUNK_IF_SAFE)
d1130 1
a1130 1
      if (keep == PNG_HANDLE_CHUNK_ALWAYS)
d1138 1
a1138 1
    old_num_chunks = png_ptr->num_chunk_list;
d1140 2
a1141 3
       (png_uint_32)
       (5*(num_chunks + old_num_chunks)));
    if (png_ptr->chunk_list != NULL)
d1148 1
a1148 1
    png_memcpy(new_list + 5*old_num_chunks, chunk_list,
d1150 1
a1150 1
    for (p = new_list + 5*old_num_chunks + 4, i = 0; i<num_chunks; i++, p += 5)
d1152 2
a1153 2
    png_ptr->num_chunk_list = old_num_chunks + num_chunks;
    png_ptr->chunk_list = new_list;
d1182 1
a1182 1
   if (info_ptr->row_pointers && (info_ptr->row_pointers != row_pointers))
d1185 1
a1185 1
   if (row_pointers)
d1192 1
a1192 2
png_set_compression_buffer_size(png_structp png_ptr,
    png_uint_32 size)
d1196 2
a1197 1
    png_free(png_ptr, png_ptr->zbuf);
a1221 1
    asm_flags = asm_flags; /* Quiet the compiler */
a1232 3
    /* Quiet the compiler */
    mmx_bitdepth_threshold = mmx_bitdepth_threshold;
    mmx_rowbytes_threshold = mmx_rowbytes_threshold;
d1246 1
a1246 1
    if (png_ptr == NULL) return;
@


1.1.107.6
log
@libpng 1.2.35
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.35 [February 14, 2009]
d6 1
a6 1
 * Copyright (c) 1998-2009 Glenn Randers-Pehrson
d24 1
a24 1
   png_debug1(1, "in %s storage function", "bKGD");
d40 1
a40 1
   png_debug1(1, "in %s storage function", "cHRM");
d43 25
d89 1
a89 2
#endif /* PNG_FLOATING_POINT_SUPPORTED */

d97 1
a97 1
   png_debug1(1, "in %s storage function", "cHRM fixed");
d101 24
a124 4
#if !defined(PNG_NO_CHECK_cHRM)
   if (png_check_cHRM_fixed(png_ptr,
      white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y))
#endif
d126 12
a137 8
     info_ptr->int_x_white = white_x;
     info_ptr->int_y_white = white_y;
     info_ptr->int_x_red   = red_x;
     info_ptr->int_y_red   = red_y;
     info_ptr->int_x_green = green_x;
     info_ptr->int_y_green = green_y;
     info_ptr->int_x_blue  = blue_x;
     info_ptr->int_y_blue  = blue_y;
d139 8
a146 8
     info_ptr->x_white = (float)(white_x/100000.);
     info_ptr->y_white = (float)(white_y/100000.);
     info_ptr->x_red   = (float)(  red_x/100000.);
     info_ptr->y_red   = (float)(  red_y/100000.);
     info_ptr->x_green = (float)(green_x/100000.);
     info_ptr->y_green = (float)(green_y/100000.);
     info_ptr->x_blue  = (float)( blue_x/100000.);
     info_ptr->y_blue  = (float)( blue_y/100000.);
d148 1
a148 2
     info_ptr->valid |= PNG_INFO_cHRM;
   }
d150 2
a151 2
#endif /* PNG_FIXED_POINT_SUPPORTED */
#endif /* PNG_cHRM_SUPPORTED */
d159 1
a159 1
   png_debug1(1, "in %s storage function", "gAMA");
d186 1
a186 1
   png_debug1(1, "in %s storage function", "gAMA");
d223 1
a223 1
   png_debug1(1, "in %s storage function", "hIST");
d266 1
a266 1
   png_debug1(1, "in %s storage function", "IHDR");
d373 1
a373 1
   png_debug1(1, "in %s storage function", "oFFs");
d393 1
a393 1
   png_debug1(1, "in %s storage function", "pCAL");
d398 1
a398 1
   png_debug1(3, "allocating purpose for info (%lu bytes)",
d408 1
a408 1
   png_debug(3, "storing X0, X1, type, and nparams in info");
d415 1
a415 1
   png_debug1(3, "allocating units for info (%lu bytes)",
d433 1
a433 5
#ifdef PNG_FREE_ME_SUPPORTED
   info_ptr->free_me |= PNG_FREE_PCAL;
#endif

   png_memset(info_ptr->pcal_params, 0, (nparams + 1) * png_sizeof(png_charp));
d438 1
a438 1
      png_debug2(3, "allocating parameter %d for info (%lu bytes)", i,
d450 3
d462 1
a462 1
   png_debug1(1, "in %s storage function", "sCAL");
d480 1
a480 1
   png_debug1(1, "in %s storage function", "sCAL");
d487 1
a487 1
   png_debug1(3, "allocating unit for info (%u bytes)",
d499 1
a499 1
   png_debug1(3, "allocating unit for info (%u bytes)",
d525 1
a525 1
   png_debug1(1, "in %s storage function", "pHYs");
d541 1
a541 1
   png_debug1(1, "in %s storage function", "PLTE");
d590 1
a590 1
   png_debug1(1, "in %s storage function", "sBIT");
d603 1
a603 1
   png_debug1(1, "in %s storage function", "sRGB");
d627 1
d631 2
a632 1
   png_debug1(1, "in %s storage function", "sRGB_gAMA_and_cHRM");
d650 1
d660 4
a672 1
#endif
d674 2
a675 10
#if !defined(PNG_NO_CHECK_cHRM)
   if (png_check_cHRM_fixed(png_ptr,
      int_white_x, int_white_y, int_red_x, int_red_y, int_green_x,
      int_green_y, int_blue_x, int_blue_y))
#endif
   {
#ifdef PNG_FIXED_POINT_SUPPORTED
     png_set_cHRM_fixed(png_ptr, info_ptr,
        int_white_x, int_white_y, int_red_x, int_red_y, int_green_x,
        int_green_y, int_blue_x, int_blue_y);
a676 3
#ifdef PNG_FLOATING_POINT_SUPPORTED
      png_set_cHRM(png_ptr, info_ptr,
         white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y);
a677 2
   }
#endif /* cHRM */
d679 1
a679 1
#endif /* sRGB */
d692 1
a692 1
   png_debug1(1, "in %s storage function", "iCCP");
d746 1
a746 1
   png_debug1(1, "in %s storage function", (png_ptr->chunk_name[0] == '\0' ?
d788 1
a788 1
      png_debug1(3, "allocated %d entries for info_ptr->text",
d848 1
a848 1
      png_debug2(2, "Allocated %lu bytes at %x in png_set_text",
d896 1
a896 1
      png_debug1(3, "transferred text chunk %d", info_ptr->num_text);
d906 1
a906 1
   png_debug1(1, "in %s storage function", "tIME");
d921 1
a921 1
   png_debug1(1, "in %s storage function", "tRNS");
a1002 1

d1126 1
a1126 1
   png_debug(1, "in png_permit_empty_plte, DEPRECATED.");
d1140 1
a1140 1
   png_debug(1, "in png_permit_mng_features");
d1201 1
a1201 1
   png_debug(1, "in png_set_read_user_chunk_fn");
d1213 1
a1213 1
   png_debug1(1, "in %s storage function", "rows");
@


1.1.107.7
log
@Update libpng in the base system, too
@
text
@d4 3
a6 2
 * Last changed in libpng 1.2.49 [March 29, 2012]
 * Copyright (c) 1998-2012 Glenn Randers-Pehrson
a9 4
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 *
a16 1
#define PNG_NO_PEDANTIC_WARNINGS
d20 1
a20 1
#ifdef PNG_bKGD_SUPPORTED
a24 1

d33 1
a33 1
#ifdef PNG_cHRM_SUPPORTED
a40 1

a73 1

d77 1
a77 1
#ifdef PNG_CHECK_cHRM_SUPPORTED
d82 17
a98 17
      info_ptr->int_x_white = white_x;
      info_ptr->int_y_white = white_y;
      info_ptr->int_x_red   = red_x;
      info_ptr->int_y_red   = red_y;
      info_ptr->int_x_green = green_x;
      info_ptr->int_y_green = green_y;
      info_ptr->int_x_blue  = blue_x;
      info_ptr->int_y_blue  = blue_y;
#ifdef  PNG_FLOATING_POINT_SUPPORTED
      info_ptr->x_white = (float)(white_x/100000.);
      info_ptr->y_white = (float)(white_y/100000.);
      info_ptr->x_red   = (float)(  red_x/100000.);
      info_ptr->y_red   = (float)(  red_y/100000.);
      info_ptr->x_green = (float)(green_x/100000.);
      info_ptr->y_green = (float)(green_y/100000.);
      info_ptr->x_blue  = (float)( blue_x/100000.);
      info_ptr->y_blue  = (float)( blue_y/100000.);
d100 1
a100 1
      info_ptr->valid |= PNG_INFO_cHRM;
d106 1
a106 1
#ifdef PNG_gAMA_SUPPORTED
d111 1
a111 2
   double png_gamma;

a112 1

d120 1
a120 1
      png_gamma=21474.83;
d123 2
a124 2
      png_gamma = file_gamma;
   info_ptr->gamma = (float)png_gamma;
d126 1
a126 1
   info_ptr->int_gamma = (int)(png_gamma*100000.+.5);
d129 1
a129 1
   if (png_gamma == 0.0)
d137 1
a137 1
   png_fixed_point png_gamma;
a139 1

d143 1
a143 1
   if (int_gamma > (png_fixed_point)PNG_UINT_31_MAX)
d145 2
a146 2
      png_warning(png_ptr, "Limiting gamma to 21474.83");
      png_gamma=PNG_UINT_31_MAX;
d150 7
a156 7
      if (int_gamma < 0)
      {
         png_warning(png_ptr, "Setting negative gamma to zero");
         png_gamma = 0;
      }
      else
         png_gamma = int_gamma;
d159 1
a159 1
   info_ptr->gamma = (float)(png_gamma/100000.);
d162 1
a162 1
   info_ptr->int_gamma = png_gamma;
d165 1
a165 1
   if (png_gamma == 0)
d170 1
a170 1
#ifdef PNG_hIST_SUPPORTED
a176 1

a178 1

d182 3
a184 3
      png_warning(png_ptr,
         "Invalid palette size, hIST allocation skipped.");
      return;
d190 2
a191 3
   /* Changed from info->num_palette to PNG_MAX_PALETTE_LENGTH in
    * version 1.2.1
    */
d195 4
a198 4
   {
      png_warning(png_ptr, "Insufficient memory for hIST chunk data.");
      return;
   }
d201 1
a201 1
      png_ptr->hist[i] = hist[i];
a219 1

d223 69
d295 1
a295 1
   info_ptr->color_type = (png_byte)color_type;
a298 5

   png_check_IHDR (png_ptr, info_ptr->width, info_ptr->height,
       info_ptr->bit_depth, info_ptr->color_type, info_ptr->interlace_type,
       info_ptr->compression_type, info_ptr->filter_type);

d309 1
a309 1
   /* Check for potential overflow */
d321 1
a321 1
#ifdef PNG_oFFs_SUPPORTED
a326 1

d337 1
a337 1
#ifdef PNG_pCAL_SUPPORTED
a346 1

d356 1
a356 1
      png_warning(png_ptr, "Insufficient memory for pCAL purpose.");
d373 1
a373 1
      png_warning(png_ptr, "Insufficient memory for pCAL units.");
d382 1
a382 1
      png_warning(png_ptr, "Insufficient memory for pCAL params.");
d386 4
d400 2
a401 2
         png_warning(png_ptr, "Insufficient memory for pCAL parameter.");
         return;
a406 3
#ifdef PNG_FREE_ME_SUPPORTED
   info_ptr->free_me |= PNG_FREE_PCAL;
#endif
a416 1

a434 1

d447 1
a447 1
         "Memory allocation failed while processing sCAL.");
d461 1
a461 1
         "Memory allocation failed while processing sCAL.");
d474 1
a474 1
#ifdef PNG_pHYs_SUPPORTED
a479 1

a495 1

d500 2
a501 2
   {
      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
d503 2
a504 2
      else
      {
d507 2
a508 2
      }
   }
d510 2
a511 1
   /* It may not actually be necessary to set png_ptr->palette here;
d520 3
a522 4
    * of num_palette entries, in case of an invalid PNG file that has
    * too-large sample values.
    */
   png_ptr->palette = (png_colorp)png_calloc(png_ptr,
d524 2
d539 1
a539 1
#ifdef PNG_sBIT_SUPPORTED
a544 1

d553 1
a553 1
#ifdef PNG_sRGB_SUPPORTED
a557 1

d569 1
a569 1
#ifdef PNG_gAMA_SUPPORTED
d577 1
a577 1
#ifdef PNG_cHRM_SUPPORTED
a584 1

d590 1
a590 1
#ifdef PNG_gAMA_SUPPORTED
d601 1
a601 1
#ifdef PNG_cHRM_SUPPORTED
d622 6
d629 3
a631 3
   png_set_cHRM_fixed(png_ptr, info_ptr,
       int_white_x, int_white_y, int_red_x, int_red_y, int_green_x,
       int_green_y, int_blue_x, int_blue_y);
d634 2
a635 2
   png_set_cHRM(png_ptr, info_ptr,
       white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y);
d637 1
d643 1
a643 1
#ifdef PNG_iCCP_SUPPORTED
a653 1

d661 1
a661 1
        png_warning(png_ptr, "Insufficient memory to process iCCP chunk.");
d670 1
a670 1
          "Insufficient memory to process iCCP profile.");
d681 1
a681 2
    * does not have to change if we introduce multiple compression types
    */
d690 1
a690 1
#ifdef PNG_TEXT_SUPPORTED
d693 1
a693 1
             int num_text)
d698 1
a698 1
      png_error(png_ptr, "Insufficient memory to store text");
d703 1
a703 1
               int num_text)
d707 1
a707 2
   png_debug1(1, "in %s storage function", ((png_ptr == NULL ||
      png_ptr->chunk_name[0] == '\0') ?
a717 3
      int old_max_text = info_ptr->max_text;
      int old_num_text = info_ptr->num_text;

d721 1
d723 1
a725 1

d729 5
a733 7
         {
            /* Restore to previous condition */
            info_ptr->max_text = old_max_text;
            info_ptr->text = old_text;
            return(1);
         }
         png_memcpy(info_ptr->text, old_text, (png_size_t)(old_max_text *
d744 1
a744 6
         {
            /* Restore to previous condition */
            info_ptr->num_text = old_num_text;
            info_ptr->max_text = old_max_text;
            return(1);
         }
a751 1

d765 2
a766 2
         lang_len = 0;
         lang_key_len = 0;
a767 1

d771 9
a779 10
         /* Set iTXt data */

         if (text_ptr[i].lang != NULL)
            lang_len = png_strlen(text_ptr[i].lang);
         else
            lang_len = 0;
         if (text_ptr[i].lang_key != NULL)
            lang_key_len = png_strlen(text_ptr[i].lang_key);
         else
            lang_key_len = 0;
d781 1
a781 1
#else /* PNG_iTXt_SUPPORTED */
d783 2
a784 2
         png_warning(png_ptr, "iTXt chunk not supported.");
         continue;
a797 1

d808 1
a808 1
         return(1);
d810 3
a812 3
                 (png_uint_32)
                 (key_len + lang_len + lang_key_len + text_length + 4),
                 (int)textp->key);
d814 2
a815 1
      png_memcpy(textp->key, text_ptr[i].key,(png_size_t)(key_len));
a849 1

d863 1
a863 1
#ifdef PNG_tIME_SUPPORTED
a867 1

d877 1
a877 1
#ifdef PNG_tRNS_SUPPORTED
a882 1

d888 2
a889 1
       /* It may not actually be necessary to set png_ptr->trans here;
d902 1
a902 1
          png_memcpy(info_ptr->trans, trans, (png_size_t)num_trans);
d914 2
a915 2
         png_warning(png_ptr,
            "tRNS chunk has out-of-range samples for bit_depth");
d919 1
a919 1
         num_trans = 1;
d935 1
a935 1
#ifdef PNG_sPLT_SUPPORTED
d947 2
a948 2
   png_sPLT_tp np;
   int i;
d950 2
a951 2
   if (png_ptr == NULL || info_ptr == NULL)
      return;
d953 2
a954 2
   np = (png_sPLT_tp)png_malloc_warn(png_ptr,
       (info_ptr->splt_palettes_num + nentries) *
d956 2
a957 2
   if (np == NULL)
   {
d960 1
a960 1
   }
d962 2
a963 4
   png_memcpy(np, info_ptr->splt_palettes,
       info_ptr->splt_palettes_num * png_sizeof(png_sPLT_t));
   png_free(png_ptr, info_ptr->splt_palettes);
   info_ptr->splt_palettes=NULL;
d965 2
a966 30
   for (i = 0; i < nentries; i++)
   {
      png_sPLT_tp to = np + info_ptr->splt_palettes_num + i;
      png_sPLT_tp from = entries + i;
      png_uint_32 length;

      length = png_strlen(from->name) + 1;
      to->name = (png_charp)png_malloc_warn(png_ptr, length);
      if (to->name == NULL)
      {
         png_warning(png_ptr,
           "Out of memory while processing sPLT chunk");
         continue;
      }
      png_memcpy(to->name, from->name, length);
      to->entries = (png_sPLT_entryp)png_malloc_warn(png_ptr,
          (png_uint_32)(from->nentries * png_sizeof(png_sPLT_entry)));
      if (to->entries == NULL)
      {
         png_warning(png_ptr,
           "Out of memory while processing sPLT chunk");
         png_free(png_ptr, to->name);
         to->name = NULL;
         continue;
      }
      png_memcpy(to->entries, from->entries,
          from->nentries * png_sizeof(png_sPLT_entry));
      to->nentries = from->nentries;
      to->depth = from->depth;
   }
d968 34
a1001 3
   info_ptr->splt_palettes = np;
   info_ptr->splt_palettes_num += nentries;
   info_ptr->valid |= PNG_INFO_sPLT;
d1003 1
a1003 1
   info_ptr->free_me |= PNG_FREE_SPLT;
d1008 1
a1008 1
#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED
d1013 2
a1014 2
   png_unknown_chunkp np;
   int i;
d1016 2
a1017 2
   if (png_ptr == NULL || info_ptr == NULL || num_unknowns == 0)
      return;
d1019 6
a1024 6
   np = (png_unknown_chunkp)png_malloc_warn(png_ptr,
       (png_uint_32)((info_ptr->unknown_chunks_num + num_unknowns) *
       png_sizeof(png_unknown_chunk)));
   if (np == NULL)
   {
      png_warning(png_ptr,
d1026 2
a1027 7
      return;
   }

   png_memcpy(np, info_ptr->unknown_chunks,
       info_ptr->unknown_chunks_num * png_sizeof(png_unknown_chunk));
   png_free(png_ptr, info_ptr->unknown_chunks);
   info_ptr->unknown_chunks = NULL;
d1029 34
a1062 4
   for (i = 0; i < num_unknowns; i++)
   {
      png_unknown_chunkp to = np + info_ptr->unknown_chunks_num + i;
      png_unknown_chunkp from = unknowns + i;
d1064 2
a1065 26
      png_memcpy((png_charp)to->name, (png_charp)from->name,
          png_sizeof(from->name));
      to->name[png_sizeof(to->name)-1] = '\0';
      to->size = from->size;
      /* Note our location in the read or write sequence */
      to->location = (png_byte)(png_ptr->mode & 0xff);

      if (from->size == 0)
         to->data=NULL;
      else
      {
         to->data = (png_bytep)png_malloc_warn(png_ptr,
           (png_uint_32)from->size);
         if (to->data == NULL)
         {
            png_warning(png_ptr,
             "Out of memory while processing unknown chunk.");
            to->size = 0;
         }
         else
            png_memcpy(to->data, from->data, from->size);
      }
   }

   info_ptr->unknown_chunks = np;
   info_ptr->unknown_chunks_num += num_unknowns;
d1067 1
a1067 1
   info_ptr->free_me |= PNG_FREE_UNKN;
d1075 1
a1075 1
       (int)info_ptr->unknown_chunks_num)
a1087 1

a1088 1

d1098 1
a1098 1
#ifdef PNG_MNG_FEATURES_SUPPORTED
a1102 1

d1111 1
a1111 1
#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
d1116 6
a1121 6
   png_bytep new_list, p;
   int i, old_num_chunks;
   if (png_ptr == NULL)
      return;
   if (num_chunks == 0)
   {
d1123 1
a1123 1
         png_ptr->flags |= PNG_FLAG_KEEP_UNKNOWN_CHUNKS;
d1125 1
a1125 1
         png_ptr->flags &= ~PNG_FLAG_KEEP_UNKNOWN_CHUNKS;
d1128 1
a1128 1
         png_ptr->flags |= PNG_FLAG_KEEP_UNSAFE_CHUNKS;
d1130 1
a1130 1
         png_ptr->flags &= ~PNG_FLAG_KEEP_UNSAFE_CHUNKS;
d1132 2
a1133 2
   }
   if (chunk_list == NULL)
d1135 3
a1137 3
   old_num_chunks = png_ptr->num_chunk_list;
   new_list=(png_bytep)png_malloc(png_ptr,
      (png_uint_32)
d1139 3
a1141 3
   if (png_ptr->chunk_list != NULL)
   {
      png_memcpy(new_list, png_ptr->chunk_list,
d1143 4
a1146 4
      png_free(png_ptr, png_ptr->chunk_list);
      png_ptr->chunk_list=NULL;
   }
   png_memcpy(new_list + 5*old_num_chunks, chunk_list,
d1148 4
a1151 4
   for (p = new_list + 5*old_num_chunks + 4, i = 0; i<num_chunks; i++, p += 5)
      *p=(png_byte)keep;
   png_ptr->num_chunk_list = old_num_chunks + num_chunks;
   png_ptr->chunk_list = new_list;
d1153 1
a1153 1
   png_ptr->free_me |= PNG_FREE_LIST;
d1158 1
a1158 1
#ifdef PNG_READ_USER_CHUNKS_SUPPORTED
a1163 1

a1165 1

d1171 1
a1171 1
#ifdef PNG_INFO_IMAGE_SUPPORTED
d1188 1
d1201 1
d1213 1
a1213 1
/* Function was added to libpng 1.2.0 and should always exist by default */
d1223 1
a1223 1
/* This function was added to libpng 1.2.0 */
d1239 1
a1239 1
/* This function was added to libpng 1.2.6 */
d1244 7
a1250 8
   /* Images with dimensions larger than these limits will be
    * rejected by png_set_IHDR().  To accept any PNG datastream
    * regardless of dimensions, set both limits to 0x7ffffffL.
    */
   if (png_ptr == NULL)
      return;
   png_ptr->user_width_max = user_width_max;
   png_ptr->user_height_max = user_height_max;
a1253 13

#ifdef PNG_BENIGN_ERRORS_SUPPORTED
void PNGAPI
png_set_benign_errors(png_structp png_ptr, int allowed)
{
   png_debug(1, "in png_set_benign_errors");

   if (allowed)
      png_ptr->flags |= PNG_FLAG_BENIGN_ERRORS_WARN;
   else
      png_ptr->flags &= ~PNG_FLAG_BENIGN_ERRORS_WARN;
}
#endif /* PNG_BENIGN_ERRORS_SUPPORTED */
@


1.1.107.8
log
@update libpng
@
text
@d4 2
a5 2
 * Last changed in libpng 1.2.56 [December 17, 2015]
 * Copyright (c) 1998-2002,2004,2006-2015 Glenn Randers-Pehrson
a265 1
   {
a266 2
      png_error(png_ptr, "Image width is too large for this architecture");
   }
a448 2
   png_uint_32 max_palette_length;

d454 1
a454 4
   max_palette_length = (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) ?
      (1 << info_ptr->bit_depth) : PNG_MAX_PALETTE_LENGTH;

   if (num_palette < 0 || num_palette > (int) max_palette_length)
d474 2
a475 2
    * of num_palette entries, in case of an invalid PNG file or incorrect
    * call to png_set_PLTE() with too-large sample values.
a535 1
#ifdef PNG_FIXED_POINT_SUPPORTED
a538 1
#endif
a557 1
#  ifdef PNG_FIXED_POINT_SUPPORTED
a565 4
   png_set_cHRM_fixed(png_ptr, info_ptr,
       int_white_x, int_white_y, int_red_x, int_red_y, int_green_x,
       int_green_y, int_blue_x, int_blue_y);
#  endif
d567 1
a567 1
#  ifdef PNG_FLOATING_POINT_SUPPORTED
d576 8
d586 1
a586 1
#  endif
d774 1
a774 1
      png_debug2(2, "Allocated %lu bytes at %p in png_set_text",
d777 1
a777 1
                 textp->key);
a837 9
   if (mod_time->month == 0   || mod_time->month > 12  ||
       mod_time->day   == 0   || mod_time->day   > 31  ||
       mod_time->hour  > 23   || mod_time->minute > 59 ||
       mod_time->second > 60)
   {
      png_warning(png_ptr, "Ignoring invalid time value");
      return;
   }

a852 6
   if (num_trans < 0 || num_trans > PNG_MAX_PALETTE_LENGTH)
      {
        png_warning(png_ptr, "Ignoring invalid num_trans value");
        return;
      }

d1187 1
a1187 1
    PNG_UNUSED(asm_flags) /* Quiet the compiler */
d1200 2
a1201 2
    PNG_UNUSED(mmx_bitdepth_threshold)
    PNG_UNUSED(mmx_rowbytes_threshold)
d1213 1
a1213 1
    * regardless of dimensions, set both limits to 0x7fffffffL.
a1235 132

#if defined(PNG_WRITE_TEXT_SUPPORTED) || defined(PNG_WRITE_pCAL_SUPPORTED) || \
    defined(PNG_WRITE_iCCP_SUPPORTED) || defined(PNG_WRITE_sPLT_SUPPORTED)
/* Check that the tEXt or zTXt keyword is valid per PNG 1.0 specification,
 * and if invalid, correct the keyword rather than discarding the entire
 * chunk.  The PNG 1.0 specification requires keywords 1-79 characters in
 * length, forbids leading or trailing whitespace, multiple internal spaces,
 * and the non-break space (0x80) from ISO 8859-1.  Returns keyword length.
 *
 * The new_key is allocated to hold the corrected keyword and must be freed
 * by the calling routine.  This avoids problems with trying to write to
 * static keywords without having to have duplicate copies of the strings.
 */
png_size_t /* PRIVATE */
png_check_keyword(png_structp png_ptr, png_charp key, png_charpp new_key)
{
   png_size_t key_len;
   png_charp kp, dp;
   int kflag;
   int kwarn=0;

   png_debug(1, "in png_check_keyword");

   *new_key = NULL;

   if (key == NULL || (key_len = png_strlen(key)) == 0)
   {
      png_warning(png_ptr, "zero length keyword");
      return ((png_size_t)0);
   }

   png_debug1(2, "Keyword to be checked is '%s'", key);

   *new_key = (png_charp)png_malloc_warn(png_ptr, (png_uint_32)(key_len + 2));
   if (*new_key == NULL)
   {
      png_warning(png_ptr, "Out of memory while procesing keyword");
      return ((png_size_t)0);
   }

   /* Replace non-printing characters with a blank and print a warning */
   for (kp = key, dp = *new_key; *kp != '\0'; kp++, dp++)
   {
      if ((png_byte)*kp < 0x20 ||
         ((png_byte)*kp > 0x7E && (png_byte)*kp < 0xA1))
      {
#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)
         char msg[40];

         png_snprintf(msg, 40,
           "invalid keyword character 0x%02X", (png_byte)*kp);
         png_warning(png_ptr, msg);
#else
         png_warning(png_ptr, "invalid character in keyword");
#endif
         *dp = ' ';
      }
      else
      {
         *dp = *kp;
      }
   }
   *dp = '\0';

   /* Remove any trailing white space. */
   kp = *new_key + key_len - 1;
   if (*kp == ' ')
   {
      png_warning(png_ptr, "trailing spaces removed from keyword");

      while (key_len && *kp == ' ')
      {
         *(kp--) = '\0';
         key_len--;
      }
   }

   /* Remove any leading white space. */
   kp = *new_key;
   if (*kp == ' ')
   {
      png_warning(png_ptr, "leading spaces removed from keyword");

      while (*kp == ' ')
      {
         kp++;
         key_len--;
      }
   }

   png_debug1(2, "Checking for multiple internal spaces in '%s'", kp);

   /* Remove multiple internal spaces. */
   for (kflag = 0, dp = *new_key; *kp != '\0'; kp++)
   {
      if (*kp == ' ' && kflag == 0)
      {
         *(dp++) = *kp;
         kflag = 1;
      }
      else if (*kp == ' ')
      {
         key_len--;
         kwarn=1;
      }
      else
      {
         *(dp++) = *kp;
         kflag = 0;
      }
   }
   *dp = '\0';
   if (kwarn)
      png_warning(png_ptr, "extra interior spaces removed from keyword");

   if (key_len == 0)
   {
      png_free(png_ptr, *new_key);
       *new_key=NULL;
      png_warning(png_ptr, "Zero length keyword");
   }

   if (key_len > 79)
   {
      png_warning(png_ptr, "keyword length must be 1 - 79 characters");
      (*new_key)[79] = '\0';
      key_len = 79;
   }

   return (key_len);
}
#endif /* WRITE_TEXT || WRITE_pCAL) || WRITE_iCCP || WRITE_sPLT */
@


