head	1.14;
access;
symbols
	png-1_2_57:1.1.107.12
	png-1_2_50:1.1.107.11
	png-1_2_35:1.1.107.10
	png-1_2_32:1.1.107.7
	png-1_2_26:1.1.107.6
	png-1_2_25:1.1.107.5
	MIRBSD_10:1.5.0.2
	MIRBSD_10_BASE:1.5
	png-1_2_18:1.1.107.4
	png-1_2_12:1.1.107.3
	MIRBSD_9_BASE:1.3
	png-1_2_10:1.1.107.2
	MIRBSD_8:1.2.0.2
	MIRBSD_8_BASE:1.2
	png-1_2_8:1.1.107.1
	libpng:1.1.107;
locks; strict;
comment	@ * @;


1.14
date	2017.04.15.15.30.04;	author tg;	state Exp;
branches;
next	1.12;
commitid	10058F23C965930E132;

1.12
date	2017.04.15.15.26.49;	author tg;	state Exp;
branches;
next	1.11;
commitid	10058F23BCC5ED04858;

1.11
date	2013.08.06.18.49.31;	author tg;	state Exp;
branches;
next	1.10;
commitid	1005201454765C5CF06;

1.10
date	2009.03.15.20.08.46;	author tg;	state Exp;
branches;
next	1.9;
commitid	10049BD605834002F74;

1.9
date	2008.12.16.22.21.54;	author tg;	state Exp;
branches;
next	1.8;
commitid	10049482A185868EF97;

1.8
date	2008.10.22.19.11.52;	author tg;	state Exp;
branches;
next	1.7;
commitid	10048FF7AEF54F9B169;

1.7
date	2008.04.07.19.54.34;	author tg;	state Exp;
branches;
next	1.6;
commitid	10047FA7C0D12C807EE;

1.6
date	2008.03.23.17.54.56;	author tg;	state Exp;
branches;
next	1.5;
commitid	10047E6997C6BB35CA9;

1.5
date	2007.05.22.20.46.19;	author tg;	state Exp;
branches;
next	1.4;
commitid	100465356AC5C1E9A9B;

1.4
date	2006.06.29.17.14.25;	author tg;	state Exp;
branches;
next	1.3;
commitid	10044A40A7D396C3456;

1.3
date	2006.06.09.00.30.28;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004488C1225295157F;

1.2
date	2005.03.06.20.29.18;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.06.15.16.20;	author tg;	state Exp;
branches
	1.1.107.1;
next	;

1.1.107.1
date	2005.03.06.15.16.20;	author tg;	state Exp;
branches;
next	1.1.107.2;

1.1.107.2
date	2006.06.09.00.13.09;	author tg;	state Exp;
branches;
next	1.1.107.3;
commitid	1004488BD054F510AF1;

1.1.107.3
date	2006.06.29.17.08.59;	author tg;	state Exp;
branches;
next	1.1.107.4;
commitid	10044A409367518C911;

1.1.107.4
date	2007.05.22.20.25.37;	author tg;	state Exp;
branches;
next	1.1.107.5;
commitid	100465351CF4103214A;

1.1.107.5
date	2008.03.23.17.15.18;	author tg;	state Exp;
branches;
next	1.1.107.6;
commitid	10047E69020419198D8;

1.1.107.6
date	2008.04.07.19.51.02;	author tg;	state Exp;
branches;
next	1.1.107.7;
commitid	10047FA7B332B97228B;

1.1.107.7
date	2008.10.22.18.55.39;	author tg;	state Exp;
branches;
next	1.1.107.8;
commitid	10048FF773834003AB5;

1.1.107.8
date	2008.12.16.22.20.53;	author tg;	state Exp;
branches;
next	1.1.107.9;
commitid	100494829C735047ABF;

1.1.107.9
date	2009.03.15.19.51.23;	author tg;	state Exp;
branches;
next	1.1.107.10;
commitid	10049BD5C4D5AF21E5D;

1.1.107.10
date	2009.03.15.19.57.25;	author tg;	state Exp;
branches;
next	1.1.107.11;
commitid	10049BD5DB90DBE42DE;

1.1.107.11
date	2013.08.06.17.35.00;	author tg;	state Exp;
branches;
next	1.1.107.12;
commitid	100520133D730551D16;

1.1.107.12
date	2017.04.15.15.00.12;	author tg;	state Exp;
branches;
next	;
commitid	10058F2359276DB0E16;


desc
@@


1.14
log
@â€¦
@
text
@#include <sys/cdefs.h>
__RCSID("$MirOS: src/lib/libpng/pngrutil.c,v 1.11 2013/08/06 18:49:31 tg Exp $");

/* pngrutil.c - utilities to read a PNG file
 *
 * Last changed in libpng 1.2.55 [December 6, 2015]
 * Copyright (c) 1998-2002,2004,2006-2015 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 *
 * This file contains routines that are only called from within
 * libpng itself during the course of reading an image.
 */

#define PNG_INTERNAL
#define PNG_NO_PEDANTIC_WARNINGS
#include "png.h"
#ifdef PNG_READ_SUPPORTED

#if defined(_WIN32_WCE) && (_WIN32_WCE<0x500)
#  define WIN32_WCE_OLD
#endif

#ifdef PNG_FLOATING_POINT_SUPPORTED
#  ifdef WIN32_WCE_OLD
/* The strtod() function is not supported on WindowsCE */
__inline double png_strtod(png_structp png_ptr, PNG_CONST char *nptr,
    char **endptr)
{
   double result = 0;
   int len;
   wchar_t *str, *end;

   len = MultiByteToWideChar(CP_ACP, 0, nptr, -1, NULL, 0);
   str = (wchar_t *)png_malloc(png_ptr, len * png_sizeof(wchar_t));
   if ( NULL != str )
   {
      MultiByteToWideChar(CP_ACP, 0, nptr, -1, str, len);
      result = wcstod(str, &end);
      len = WideCharToMultiByte(CP_ACP, 0, end, -1, NULL, 0, NULL, NULL);
      *endptr = (char *)nptr + (png_strlen(nptr) - len + 1);
      png_free(png_ptr, str);
   }
   return result;
}
#  else
#    define png_strtod(p,a,b) strtod(a,b)
#  endif
#endif

png_uint_32 PNGAPI
png_get_uint_31(png_structp png_ptr, png_bytep buf)
{
#ifdef PNG_READ_BIG_ENDIAN_SUPPORTED
   png_uint_32 i = png_get_uint_32(buf);
#else
   /* Avoid an extra function call by inlining the result. */
   png_uint_32 i = ((png_uint_32)((*(buf    )) & 0xff) << 24) +
                   ((png_uint_32)((*(buf + 1)) & 0xff) << 16) +
                   ((png_uint_32)((*(buf + 2)) & 0xff) <<  8) +
                   ((png_uint_32)((*(buf + 3)) & 0xff)      );
#endif
   if (i > PNG_UINT_31_MAX)
      png_error(png_ptr, "PNG unsigned integer out of range.");
   return (i);
}
#ifndef PNG_READ_BIG_ENDIAN_SUPPORTED
/* Grab an unsigned 32-bit integer from a buffer in big-endian format. */
png_uint_32 PNGAPI
png_get_uint_32(png_bytep buf)
{
   png_uint_32 i = ((png_uint_32)((*(buf    )) & 0xff) << 24) +
                   ((png_uint_32)((*(buf + 1)) & 0xff) << 16) +
                   ((png_uint_32)((*(buf + 2)) & 0xff) <<  8) +
                   ((png_uint_32)((*(buf + 3)) & 0xff)      );

   return (i);
}

/* Grab a signed 32-bit integer from a buffer in big-endian format.  The
 * data is stored in the PNG file in two's complement format, and it is
 * assumed that the machine format for signed integers is the same.
 */
png_int_32 PNGAPI
png_get_int_32(png_bytep buf)
{
   png_int_32 i = ((png_int_32)((*(buf    )) & 0xff) << 24) +
                  ((png_int_32)((*(buf + 1)) & 0xff) << 16) +
                  ((png_int_32)((*(buf + 2)) & 0xff) <<  8) +
                  ((png_int_32)((*(buf + 3)) & 0xff)      );

   return (i);
}

/* Grab an unsigned 16-bit integer from a buffer in big-endian format. */
png_uint_16 PNGAPI
png_get_uint_16(png_bytep buf)
{
   png_uint_16 i = ((png_uint_16)((*(buf     )) & 0xff) << 8) +
                   ((png_uint_16)((*(buf +  1)) & 0xff)     );

   return (i);
}
#endif /* PNG_READ_BIG_ENDIAN_SUPPORTED */

/* Read the chunk header (length + type name).
 * Put the type name into png_ptr->chunk_name, and return the length.
 */
png_uint_32 /* PRIVATE */
png_read_chunk_header(png_structp png_ptr)
{
   png_byte buf[8];
   png_uint_32 length;

   /* Read the length and the chunk name */
   png_read_data(png_ptr, buf, 8);
   length = png_get_uint_31(png_ptr, buf);

   /* Put the chunk name into png_ptr->chunk_name */
   png_memcpy(png_ptr->chunk_name, buf + 4, 4);

   png_debug2(0, "Reading %s chunk, length = %lu",
      png_ptr->chunk_name, length);

   /* Reset the crc and run it over the chunk name */
   png_reset_crc(png_ptr);
   png_calculate_crc(png_ptr, png_ptr->chunk_name, 4);

   /* Check to see if chunk name is valid */
   png_check_chunk_name(png_ptr, png_ptr->chunk_name);

   return length;
}

/* Read data, and (optionally) run it through the CRC. */
void /* PRIVATE */
png_crc_read(png_structp png_ptr, png_bytep buf, png_size_t length)
{
   if (png_ptr == NULL)
      return;
   png_read_data(png_ptr, buf, length);
   png_calculate_crc(png_ptr, buf, length);
}

/* Optionally skip data and then check the CRC.  Depending on whether we
 * are reading a ancillary or critical chunk, and how the program has set
 * things up, we may calculate the CRC on the data and print a message.
 * Returns '1' if there was a CRC error, '0' otherwise.
 */
int /* PRIVATE */
png_crc_finish(png_structp png_ptr, png_uint_32 skip)
{
   png_size_t i;
   png_size_t istop = png_ptr->zbuf_size;

   for (i = (png_size_t)skip; i > istop; i -= istop)
   {
      png_crc_read(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size);
   }
   if (i)
   {
      png_crc_read(png_ptr, png_ptr->zbuf, i);
   }

   if (png_crc_error(png_ptr))
   {
      if (((png_ptr->chunk_name[0] & 0x20) &&                /* Ancillary */
          !(png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN)) ||
          (!(png_ptr->chunk_name[0] & 0x20) &&             /* Critical  */
          (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_USE)))
      {
         png_chunk_warning(png_ptr, "CRC error");
      }
      else
      {
         png_chunk_error(png_ptr, "CRC error");
      }
      return (1);
   }

   return (0);
}

/* Compare the CRC stored in the PNG file with that calculated by libpng from
 * the data it has read thus far.
 */
int /* PRIVATE */
png_crc_error(png_structp png_ptr)
{
   png_byte crc_bytes[4];
   png_uint_32 crc;
   int need_crc = 1;

   if (png_ptr->chunk_name[0] & 0x20)                     /* ancillary */
   {
      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==
          (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))
         need_crc = 0;
   }
   else                                                    /* critical */
   {
      if (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE)
         need_crc = 0;
   }

   png_read_data(png_ptr, crc_bytes, 4);

   if (need_crc)
   {
      crc = png_get_uint_32(crc_bytes);
      return ((int)(crc != png_ptr->crc));
   }
   else
      return (0);
}

#if defined(PNG_READ_zTXt_SUPPORTED) || defined(PNG_READ_iTXt_SUPPORTED) || \
    defined(PNG_READ_iCCP_SUPPORTED)
static png_size_t
png_inflate(png_structp png_ptr, const png_byte *data, png_size_t size,
        png_bytep output, png_size_t output_size)
{
   png_size_t count = 0;
   union {
	void *u;
	const void *c;
   } abi_workaround;

   abi_workaround.c = data;
   png_ptr->zstream.next_in = (png_bytep)abi_workaround.u; /* const_cast: VALID */
   png_ptr->zstream.avail_in = size;

   while (1)
   {
      int ret, avail;

      /* Reset the output buffer each time round - we empty it
       * after every inflate call.
       */
      png_ptr->zstream.next_out = png_ptr->zbuf;
      png_ptr->zstream.avail_out = png_ptr->zbuf_size;

      ret = inflate(&png_ptr->zstream, Z_NO_FLUSH);
      avail = png_ptr->zbuf_size - png_ptr->zstream.avail_out;

      /* First copy/count any new output - but only if we didn't
       * get an error code.
       */
      if ((ret == Z_OK || ret == Z_STREAM_END) && avail > 0)
      {
         if (output != 0 && output_size > count)
         {
            png_size_t copy = output_size - count;
            if ((png_size_t) avail < copy) copy = (png_size_t) avail;
            png_memcpy(output + count, png_ptr->zbuf, copy);
         }
         count += avail;
      }

      if (ret == Z_OK)
         continue;

      /* Termination conditions - always reset the zstream, it
       * must be left in inflateInit state.
       */
      png_ptr->zstream.avail_in = 0;
      inflateReset(&png_ptr->zstream);

      if (ret == Z_STREAM_END)
         return count; /* NOTE: may be zero. */

      /* Now handle the error codes - the API always returns 0
       * and the error message is dumped into the uncompressed
       * buffer if available.
       */
      {
         PNG_CONST char *msg;
         if (png_ptr->zstream.msg != 0)
            msg = png_ptr->zstream.msg;
         else
         {
#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)
            char umsg[52];

            switch (ret)
            {
               case Z_BUF_ERROR:
                  msg = "Buffer error in compressed datastream in %s chunk";
                  break;
               case Z_DATA_ERROR:
                  msg = "Data error in compressed datastream in %s chunk";
                  break;
               default:
                  msg = "Incomplete compressed datastream in %s chunk";
                  break;
            }

            png_snprintf(umsg, sizeof umsg, msg, png_ptr->chunk_name);
            msg = umsg;
            png_warning(png_ptr, msg);
#else
            msg = "Damaged compressed datastream in chunk other than IDAT";
#endif
         }

#ifndef PNG_STDIO_SUPPORTED
         png_warning(png_ptr, msg);
#endif
      }

      /* 0 means an error - notice that this code simple ignores
       * zero length compressed chunks as a result.
       */
      return 0;
   }
}

/*
 * Decompress trailing data in a chunk.  The assumption is that chunkdata
 * points at an allocated area holding the contents of a chunk with a
 * trailing compressed part.  What we get back is an allocated area
 * holding the original prefix part and an uncompressed version of the
 * trailing part (the malloc area passed in is freed).
 */
void /* PRIVATE */
png_decompress_chunk(png_structp png_ptr, int comp_type,
    png_size_t chunklength,
    png_size_t prefix_size, png_size_t *newlength)
{
   /* The caller should guarantee this */
   if (prefix_size > chunklength)
   {
      /* The recovery is to delete the chunk. */
      png_warning(png_ptr, "invalid chunklength");
      prefix_size = 0; /* To delete everything */
   }

   else if (comp_type == PNG_COMPRESSION_TYPE_BASE)
   {
      png_size_t expanded_size = png_inflate(png_ptr,
                (png_bytep)(png_ptr->chunkdata + prefix_size),
                chunklength - prefix_size,
                0/*output*/, 0/*output size*/);

      /* Now check the limits on this chunk - if the limit fails the
       * compressed data will be removed, the prefix will remain.
       */
      if (prefix_size >= (~(png_size_t)0) - 1 ||
         expanded_size >= (~(png_size_t)0) - 1 - prefix_size
#ifdef PNG_USER_CHUNK_MALLOC_MAX
         || ((PNG_USER_CHUNK_MALLOC_MAX > 0) &&
          prefix_size + expanded_size >= PNG_USER_CHUNK_MALLOC_MAX - 1)
#endif
          )
         png_warning(png_ptr, "Exceeded size limit while expanding chunk");

      /* If the size is zero either there was an error and a message
       * has already been output (warning) or the size really is zero
       * and we have nothing to do - the code will exit through the
       * error case below.
       */
      else if (expanded_size > 0)
      {
         /* Success (maybe) - really uncompress the chunk. */
         png_size_t new_size = 0;

         png_charp text = png_malloc_warn(png_ptr,
             prefix_size + expanded_size + 1);

         if (text != NULL)
         {
            png_memcpy(text, png_ptr->chunkdata, prefix_size);
            new_size = png_inflate(png_ptr,
                (png_bytep)(png_ptr->chunkdata + prefix_size),
                chunklength - prefix_size,
                (png_bytep)(text + prefix_size), expanded_size);
            text[prefix_size + expanded_size] = 0; /* just in case */

            if (new_size == expanded_size)
            {
               png_free(png_ptr, png_ptr->chunkdata);
               png_ptr->chunkdata = text;
               *newlength = prefix_size + expanded_size;
               return; /* The success return! */
            }

            png_warning(png_ptr, "png_inflate logic error");
            png_free(png_ptr, text);
         }
         else
          png_warning(png_ptr, "Not enough memory to decompress chunk.");
      }
   }

   else /* if (comp_type != PNG_COMPRESSION_TYPE_BASE) */
   {
#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)
      char umsg[50];

      png_snprintf(umsg, sizeof umsg, "Unknown zTXt compression type %d",
          comp_type);
      png_warning(png_ptr, umsg);
#else
      png_warning(png_ptr, "Unknown zTXt compression type");
#endif

      /* The recovery is to simply drop the data. */
   }

   /* Generic error return - leave the prefix, delete the compressed
    * data, reallocate the chunkdata to remove the potentially large
    * amount of compressed data.
    */
   {
      png_charp text = png_malloc_warn(png_ptr, prefix_size + 1);
      if (text != NULL)
      {
         if (prefix_size > 0)
            png_memcpy(text, png_ptr->chunkdata, prefix_size);
         png_free(png_ptr, png_ptr->chunkdata);
         png_ptr->chunkdata = text;

         /* This is an extra zero in the 'uncompressed' part. */
         *(png_ptr->chunkdata + prefix_size) = 0x00;
      }
      /* Ignore a malloc error here - it is safe. */
   }

   *newlength = prefix_size;
}
#endif

/* Read and check the IDHR chunk */
void /* PRIVATE */
png_handle_IHDR(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_byte buf[13];
   png_uint_32 width, height;
   int bit_depth, color_type, compression_type, filter_type;
   int interlace_type;

   png_debug(1, "in png_handle_IHDR");

   if (png_ptr->mode & PNG_HAVE_IHDR)
      png_error(png_ptr, "Out of place IHDR");

   /* Check the length */
   if (length != 13)
      png_error(png_ptr, "Invalid IHDR chunk");

   png_ptr->mode |= PNG_HAVE_IHDR;

   png_crc_read(png_ptr, buf, 13);
   png_crc_finish(png_ptr, 0);

   width = png_get_uint_31(png_ptr, buf);
   height = png_get_uint_31(png_ptr, buf + 4);
   bit_depth = buf[8];
   color_type = buf[9];
   compression_type = buf[10];
   filter_type = buf[11];
   interlace_type = buf[12];

   /* Set internal variables */
   png_ptr->width = width;
   png_ptr->height = height;
   png_ptr->bit_depth = (png_byte)bit_depth;
   png_ptr->interlaced = (png_byte)interlace_type;
   png_ptr->color_type = (png_byte)color_type;
#ifdef PNG_MNG_FEATURES_SUPPORTED
   png_ptr->filter_type = (png_byte)filter_type;
#endif
   png_ptr->compression_type = (png_byte)compression_type;

   /* Find number of channels */
   switch (png_ptr->color_type)
   {
      case PNG_COLOR_TYPE_GRAY:
      case PNG_COLOR_TYPE_PALETTE:
         png_ptr->channels = 1;
         break;

      case PNG_COLOR_TYPE_RGB:
         png_ptr->channels = 3;
         break;

      case PNG_COLOR_TYPE_GRAY_ALPHA:
         png_ptr->channels = 2;
         break;

      case PNG_COLOR_TYPE_RGB_ALPHA:
         png_ptr->channels = 4;
         break;
   }

   /* Set up other useful info */
   png_ptr->pixel_depth = (png_byte)(png_ptr->bit_depth *
   png_ptr->channels);
   png_ptr->rowbytes = PNG_ROWBYTES(png_ptr->pixel_depth, png_ptr->width);
   png_debug1(3, "bit_depth = %d", png_ptr->bit_depth);
   png_debug1(3, "channels = %d", png_ptr->channels);
   png_debug1(3, "rowbytes = %lu", png_ptr->rowbytes);
   png_set_IHDR(png_ptr, info_ptr, width, height, bit_depth,
      color_type, interlace_type, compression_type, filter_type);
}

/* Read and check the palette */
void /* PRIVATE */
png_handle_PLTE(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_color palette[PNG_MAX_PALETTE_LENGTH];
   int max_palette_length, num, i;
#ifdef PNG_POINTER_INDEXING_SUPPORTED
   png_colorp pal_ptr;
#endif

   png_debug(1, "in png_handle_PLTE");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before PLTE");

   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid PLTE after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }

   else if (png_ptr->mode & PNG_HAVE_PLTE)
      png_error(png_ptr, "Duplicate PLTE chunk");

   png_ptr->mode |= PNG_HAVE_PLTE;

   if (!(png_ptr->color_type&PNG_COLOR_MASK_COLOR))
   {
      png_warning(png_ptr,
        "Ignoring PLTE chunk in grayscale PNG");
      png_crc_finish(png_ptr, length);
      return;
   }
#ifndef PNG_READ_OPT_PLTE_SUPPORTED
   if (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE)
   {
      png_crc_finish(png_ptr, length);
      return;
   }
#endif

   if (length > 3*PNG_MAX_PALETTE_LENGTH || length % 3)
   {
      if (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE)
      {
         png_warning(png_ptr, "Invalid palette chunk");
         png_crc_finish(png_ptr, length);
         return;
      }

      else
      {
         png_error(png_ptr, "Invalid palette chunk");
      }
   }

   /* The cast is safe because 'length' is less than 3*PNG_MAX_PALETTE_LENGTH */
   num = (int)length / 3;

   /* If the palette has 256 or fewer entries but is too large for the bit
    * depth, we don't issue an error, to preserve the behavior of previous
    * libpng versions. We silently truncate the unused extra palette entries
    * here.
    */
   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      max_palette_length = (1 << png_ptr->bit_depth);
   else
      max_palette_length = PNG_MAX_PALETTE_LENGTH;

   if (num > max_palette_length)
      num = max_palette_length;

#ifdef PNG_POINTER_INDEXING_SUPPORTED
   for (i = 0, pal_ptr = palette; i < num; i++, pal_ptr++)
   {
      png_byte buf[3];

      png_crc_read(png_ptr, buf, 3);
      pal_ptr->red = buf[0];
      pal_ptr->green = buf[1];
      pal_ptr->blue = buf[2];
   }
#else
   for (i = 0; i < num; i++)
   {
      png_byte buf[3];

      png_crc_read(png_ptr, buf, 3);
      /* Don't depend upon png_color being any order */
      palette[i].red = buf[0];
      palette[i].green = buf[1];
      palette[i].blue = buf[2];
   }
#endif

   /* If we actually NEED the PLTE chunk (ie for a paletted image), we do
    * whatever the normal CRC configuration tells us.  However, if we
    * have an RGB image, the PLTE can be considered ancillary, so
    * we will act as though it is.
    */
#ifndef PNG_READ_OPT_PLTE_SUPPORTED
   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
#endif
   {
      png_crc_finish(png_ptr, (int) length - num * 3);
   }
#ifndef PNG_READ_OPT_PLTE_SUPPORTED
   else if (png_crc_error(png_ptr))  /* Only if we have a CRC error */
   {
      /* If we don't want to use the data from an ancillary chunk,
         we have two options: an error abort, or a warning and we
         ignore the data in this chunk (which should be OK, since
         it's considered ancillary for a RGB or RGBA image). */
      if (!(png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_USE))
      {
         if (png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN)
         {
            png_chunk_error(png_ptr, "CRC error");
         }
         else
         {
            png_chunk_warning(png_ptr, "CRC error");
            return;
         }
      }
      /* Otherwise, we (optionally) emit a warning and use the chunk. */
      else if (!(png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN))
      {
         png_chunk_warning(png_ptr, "CRC error");
      }
   }
#endif

   png_set_PLTE(png_ptr, info_ptr, palette, num);

#ifdef PNG_READ_tRNS_SUPPORTED
   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
   {
      if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS))
      {
         if (png_ptr->num_trans > (png_uint_16)num)
         {
            png_warning(png_ptr, "Truncating incorrect tRNS chunk length");
            png_ptr->num_trans = (png_uint_16)num;
         }
         if (info_ptr->num_trans > (png_uint_16)num)
         {
            png_warning(png_ptr, "Truncating incorrect info tRNS chunk length");
            info_ptr->num_trans = (png_uint_16)num;
         }
      }
   }
#endif

}

void /* PRIVATE */
png_handle_IEND(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_debug(1, "in png_handle_IEND");

   if (!(png_ptr->mode & PNG_HAVE_IHDR) || !(png_ptr->mode & PNG_HAVE_IDAT))
   {
      png_error(png_ptr, "No image in file");
   }

   png_ptr->mode |= (PNG_AFTER_IDAT | PNG_HAVE_IEND);

   if (length != 0)
   {
      png_warning(png_ptr, "Incorrect IEND chunk length");
   }
   png_crc_finish(png_ptr, length);

   PNG_UNUSED(info_ptr) /* Quiet compiler warnings about unused info_ptr */
}

#ifdef PNG_READ_gAMA_SUPPORTED
void /* PRIVATE */
png_handle_gAMA(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_fixed_point igamma;
#ifdef PNG_FLOATING_POINT_SUPPORTED
   float file_gamma;
#endif
   png_byte buf[4];

   png_debug(1, "in png_handle_gAMA");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before gAMA");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid gAMA after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (png_ptr->mode & PNG_HAVE_PLTE)
      /* Should be an error, but we can cope with it */
      png_warning(png_ptr, "Out of place gAMA chunk");

   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_gAMA)
#ifdef PNG_READ_sRGB_SUPPORTED
      && !(info_ptr->valid & PNG_INFO_sRGB)
#endif
      )
   {
      png_warning(png_ptr, "Duplicate gAMA chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   if (length != 4)
   {
      png_warning(png_ptr, "Incorrect gAMA chunk length");
      png_crc_finish(png_ptr, length);
      return;
   }

   png_crc_read(png_ptr, buf, 4);
   if (png_crc_finish(png_ptr, 0))
      return;

   igamma = (png_fixed_point)png_get_uint_32(buf);
   /* Check for zero gamma */
   if (igamma == 0)
      {
         png_warning(png_ptr,
           "Ignoring gAMA chunk with gamma=0");
         return;
      }

#ifdef PNG_READ_sRGB_SUPPORTED
   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sRGB))
      if (PNG_OUT_OF_RANGE(igamma, 45500L, 500))
      {
         png_warning(png_ptr,
           "Ignoring incorrect gAMA value when sRGB is also present");
#ifdef PNG_CONSOLE_IO_SUPPORTED
         fprintf(stderr, "gamma = (%d/100000)", (int)igamma);
#endif
         return;
      }
#endif /* PNG_READ_sRGB_SUPPORTED */

#ifdef PNG_FLOATING_POINT_SUPPORTED
   file_gamma = (float)igamma / (float)100000.0;
#  ifdef PNG_READ_GAMMA_SUPPORTED
     png_ptr->gamma = file_gamma;
#  endif
     png_set_gAMA(png_ptr, info_ptr, file_gamma);
#endif
#ifdef PNG_FIXED_POINT_SUPPORTED
   png_set_gAMA_fixed(png_ptr, info_ptr, igamma);
#endif
}
#endif

#ifdef PNG_READ_sBIT_SUPPORTED
void /* PRIVATE */
png_handle_sBIT(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_size_t truelen;
   png_byte buf[4];

   png_debug(1, "in png_handle_sBIT");

   buf[0] = buf[1] = buf[2] = buf[3] = 0;

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before sBIT");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid sBIT after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (png_ptr->mode & PNG_HAVE_PLTE)
   {
      /* Should be an error, but we can cope with it */
      png_warning(png_ptr, "Out of place sBIT chunk");
   }
   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sBIT))
   {
      png_warning(png_ptr, "Duplicate sBIT chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      truelen = 3;
   else
      truelen = (png_size_t)png_ptr->channels;

   if (length != truelen || length > 4)
   {
      png_warning(png_ptr, "Incorrect sBIT chunk length");
      png_crc_finish(png_ptr, length);
      return;
   }

   png_crc_read(png_ptr, buf, truelen);
   if (png_crc_finish(png_ptr, 0))
      return;

   if (png_ptr->color_type & PNG_COLOR_MASK_COLOR)
   {
      png_ptr->sig_bit.red = buf[0];
      png_ptr->sig_bit.green = buf[1];
      png_ptr->sig_bit.blue = buf[2];
      png_ptr->sig_bit.alpha = buf[3];
   }
   else
   {
      png_ptr->sig_bit.gray = buf[0];
      png_ptr->sig_bit.red = buf[0];
      png_ptr->sig_bit.green = buf[0];
      png_ptr->sig_bit.blue = buf[0];
      png_ptr->sig_bit.alpha = buf[1];
   }
   png_set_sBIT(png_ptr, info_ptr, &(png_ptr->sig_bit));
}
#endif

#ifdef PNG_READ_cHRM_SUPPORTED
void /* PRIVATE */
png_handle_cHRM(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_byte buf[32];
#ifdef PNG_FLOATING_POINT_SUPPORTED
   float white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y;
#endif
   png_fixed_point int_x_white, int_y_white, int_x_red, int_y_red, int_x_green,
      int_y_green, int_x_blue, int_y_blue;

   png_uint_32 uint_x, uint_y;

   png_debug(1, "in png_handle_cHRM");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before cHRM");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid cHRM after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (png_ptr->mode & PNG_HAVE_PLTE)
      /* Should be an error, but we can cope with it */
      png_warning(png_ptr, "Missing PLTE before cHRM");

   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM)
#ifdef PNG_READ_sRGB_SUPPORTED
      && !(info_ptr->valid & PNG_INFO_sRGB)
#endif
      )
   {
      png_warning(png_ptr, "Duplicate cHRM chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   if (length != 32)
   {
      png_warning(png_ptr, "Incorrect cHRM chunk length");
      png_crc_finish(png_ptr, length);
      return;
   }

   png_crc_read(png_ptr, buf, 32);
   if (png_crc_finish(png_ptr, 0))
      return;

   uint_x = png_get_uint_32(buf);
   uint_y = png_get_uint_32(buf + 4);
   int_x_white = (png_fixed_point)uint_x;
   int_y_white = (png_fixed_point)uint_y;

   uint_x = png_get_uint_32(buf + 8);
   uint_y = png_get_uint_32(buf + 12);
   int_x_red = (png_fixed_point)uint_x;
   int_y_red = (png_fixed_point)uint_y;

   uint_x = png_get_uint_32(buf + 16);
   uint_y = png_get_uint_32(buf + 20);
   int_x_green = (png_fixed_point)uint_x;
   int_y_green = (png_fixed_point)uint_y;

   uint_x = png_get_uint_32(buf + 24);
   uint_y = png_get_uint_32(buf + 28);
   int_x_blue = (png_fixed_point)uint_x;
   int_y_blue = (png_fixed_point)uint_y;

#ifdef PNG_FLOATING_POINT_SUPPORTED
   white_x = (float)int_x_white / (float)100000.0;
   white_y = (float)int_y_white / (float)100000.0;
   red_x   = (float)int_x_red   / (float)100000.0;
   red_y   = (float)int_y_red   / (float)100000.0;
   green_x = (float)int_x_green / (float)100000.0;
   green_y = (float)int_y_green / (float)100000.0;
   blue_x  = (float)int_x_blue  / (float)100000.0;
   blue_y  = (float)int_y_blue  / (float)100000.0;
#endif

#ifdef PNG_READ_sRGB_SUPPORTED
   if ((info_ptr != NULL) && (info_ptr->valid & PNG_INFO_sRGB))
      {
      if (PNG_OUT_OF_RANGE(int_x_white, 31270,  1000) ||
          PNG_OUT_OF_RANGE(int_y_white, 32900,  1000) ||
          PNG_OUT_OF_RANGE(int_x_red,   64000L, 1000) ||
          PNG_OUT_OF_RANGE(int_y_red,   33000,  1000) ||
          PNG_OUT_OF_RANGE(int_x_green, 30000,  1000) ||
          PNG_OUT_OF_RANGE(int_y_green, 60000L, 1000) ||
          PNG_OUT_OF_RANGE(int_x_blue,  15000,  1000) ||
          PNG_OUT_OF_RANGE(int_y_blue,   6000,  1000))
         {
            png_warning(png_ptr,
              "Ignoring incorrect cHRM value when sRGB is also present");
#ifdef PNG_CONSOLE_IO_SUPPORTED
#ifdef PNG_FLOATING_POINT_SUPPORTED
            fprintf(stderr, "wx=%f, wy=%f, rx=%f, ry=%f\n",
               white_x, white_y, red_x, red_y);
            fprintf(stderr, "gx=%f, gy=%f, bx=%f, by=%f\n",
               green_x, green_y, blue_x, blue_y);
#else
            fprintf(stderr, "wx=%ld, wy=%ld, rx=%ld, ry=%ld\n",
               (long)int_x_white, (long)int_y_white,
               (long)int_x_red, (long)int_y_red);
            fprintf(stderr, "gx=%ld, gy=%ld, bx=%ld, by=%ld\n",
               (long)int_x_green, (long)int_y_green,
               (long)int_x_blue, (long)int_y_blue);
#endif
#endif /* PNG_CONSOLE_IO_SUPPORTED */
         }
         return;
      }
#endif /* PNG_READ_sRGB_SUPPORTED */

#ifdef PNG_FLOATING_POINT_SUPPORTED
   png_set_cHRM(png_ptr, info_ptr,
      white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y);
#endif
#ifdef PNG_FIXED_POINT_SUPPORTED
   png_set_cHRM_fixed(png_ptr, info_ptr,
      int_x_white, int_y_white, int_x_red, int_y_red, int_x_green,
      int_y_green, int_x_blue, int_y_blue);
#endif
}
#endif

#ifdef PNG_READ_sRGB_SUPPORTED
void /* PRIVATE */
png_handle_sRGB(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   int intent;
   png_byte buf[1];

   png_debug(1, "in png_handle_sRGB");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before sRGB");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid sRGB after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (png_ptr->mode & PNG_HAVE_PLTE)
      /* Should be an error, but we can cope with it */
      png_warning(png_ptr, "Out of place sRGB chunk");

   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sRGB))
   {
      png_warning(png_ptr, "Duplicate sRGB chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   if (length != 1)
   {
      png_warning(png_ptr, "Incorrect sRGB chunk length");
      png_crc_finish(png_ptr, length);
      return;
   }

   png_crc_read(png_ptr, buf, 1);
   if (png_crc_finish(png_ptr, 0))
      return;

   intent = buf[0];
   /* Check for bad intent */
   if (intent >= PNG_sRGB_INTENT_LAST)
   {
      png_warning(png_ptr, "Unknown sRGB intent");
      return;
   }

#if defined(PNG_READ_gAMA_SUPPORTED) && defined(PNG_READ_GAMMA_SUPPORTED)
   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_gAMA))
   {
   png_fixed_point igamma;
#ifdef PNG_FIXED_POINT_SUPPORTED
      igamma=info_ptr->int_gamma;
#else
#  ifdef PNG_FLOATING_POINT_SUPPORTED
      igamma=(png_fixed_point)(info_ptr->gamma * 100000.);
#  endif
#endif
      if (PNG_OUT_OF_RANGE(igamma, 45500L, 500))
      {
         png_warning(png_ptr,
           "Ignoring incorrect gAMA value when sRGB is also present");
#ifdef PNG_CONSOLE_IO_SUPPORTED
#  ifdef PNG_FIXED_POINT_SUPPORTED
         fprintf(stderr, "incorrect gamma=(%d/100000)\n",
            (int)png_ptr->int_gamma);
#  else
#    ifdef PNG_FLOATING_POINT_SUPPORTED
         fprintf(stderr, "incorrect gamma=%f\n", png_ptr->gamma);
#    endif
#  endif
#endif
      }
   }
#endif /* PNG_READ_gAMA_SUPPORTED */

#ifdef PNG_READ_cHRM_SUPPORTED
#ifdef PNG_FIXED_POINT_SUPPORTED
   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM))
      if (PNG_OUT_OF_RANGE(info_ptr->int_x_white, 31270,  1000) ||
          PNG_OUT_OF_RANGE(info_ptr->int_y_white, 32900,  1000) ||
          PNG_OUT_OF_RANGE(info_ptr->int_x_red,   64000L, 1000) ||
          PNG_OUT_OF_RANGE(info_ptr->int_y_red,   33000,  1000) ||
          PNG_OUT_OF_RANGE(info_ptr->int_x_green, 30000,  1000) ||
          PNG_OUT_OF_RANGE(info_ptr->int_y_green, 60000L, 1000) ||
          PNG_OUT_OF_RANGE(info_ptr->int_x_blue,  15000,  1000) ||
          PNG_OUT_OF_RANGE(info_ptr->int_y_blue,   6000,  1000))
         {
            png_warning(png_ptr,
              "Ignoring incorrect cHRM value when sRGB is also present");
         }
#endif /* PNG_FIXED_POINT_SUPPORTED */
#endif /* PNG_READ_cHRM_SUPPORTED */

   png_set_sRGB_gAMA_and_cHRM(png_ptr, info_ptr, intent);
}
#endif /* PNG_READ_sRGB_SUPPORTED */

#ifdef PNG_READ_iCCP_SUPPORTED
void /* PRIVATE */
png_handle_iCCP(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
/* Note: this does not properly handle chunks that are > 64K under DOS */
{
   png_byte compression_type;
   png_bytep pC;
   png_charp profile;
   png_uint_32 skip = 0;
   png_uint_32 profile_size, profile_length;
   png_size_t slength, prefix_length, data_length;

   png_debug(1, "in png_handle_iCCP");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before iCCP");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid iCCP after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (png_ptr->mode & PNG_HAVE_PLTE)
      /* Should be an error, but we can cope with it */
      png_warning(png_ptr, "Out of place iCCP chunk");

   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_iCCP))
   {
      png_warning(png_ptr, "Duplicate iCCP chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

#ifdef PNG_MAX_MALLOC_64K
   if (length > (png_uint_32)65535L)
   {
      png_warning(png_ptr, "iCCP chunk too large to fit in memory");
      skip = length - (png_uint_32)65535L;
      length = (png_uint_32)65535L;
   }
#endif

   png_free(png_ptr, png_ptr->chunkdata);
   png_ptr->chunkdata = (png_charp)png_malloc(png_ptr, length + 1);
   slength = (png_size_t)length;
   png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);

   if (png_crc_finish(png_ptr, skip))
   {
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
      return;
   }

   png_ptr->chunkdata[slength] = 0x00;

   for (profile = png_ptr->chunkdata; *profile; profile++)
      /* Empty loop to find end of name */ ;

   ++profile;

   /* There should be at least one zero (the compression type byte)
    * following the separator, and we should be on it
    */
   if (slength < 1U ||  profile >= png_ptr->chunkdata + slength - 1U)
   {
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
      png_warning(png_ptr, "Malformed iCCP chunk");
      return;
   }

   /* Compression_type should always be zero */
   compression_type = *profile++;
   if (compression_type)
   {
      png_warning(png_ptr, "Ignoring nonzero compression type in iCCP chunk");
      compression_type = 0x00;  /* Reset it to zero (libpng-1.0.6 through 1.0.8
                                 wrote nonzero) */
   }

   prefix_length = profile - png_ptr->chunkdata;
   png_decompress_chunk(png_ptr, compression_type,
     slength, prefix_length, &data_length);

   profile_length = data_length - prefix_length;

   if ( prefix_length > data_length || profile_length < 4)
   {
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
      png_warning(png_ptr, "Profile size field missing from iCCP chunk");
      return;
   }

   /* Check the profile_size recorded in the first 32 bits of the ICC profile */
   pC = (png_bytep)(png_ptr->chunkdata + prefix_length);
   profile_size = ((png_uint_32) (*(pC    )<<24)) |
                  ((png_uint_32) (*(pC + 1)<<16)) |
                  ((png_uint_32) (*(pC + 2)<< 8)) |
                  ((png_uint_32) (*(pC + 3)    ));

   if (profile_size < profile_length)
      profile_length = profile_size;

   if (profile_size > profile_length)
   {
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
      png_warning(png_ptr, "Ignoring truncated iCCP profile.");
      return;
   }

   png_set_iCCP(png_ptr, info_ptr, png_ptr->chunkdata,
     compression_type, png_ptr->chunkdata + prefix_length, profile_length);
   png_free(png_ptr, png_ptr->chunkdata);
   png_ptr->chunkdata = NULL;
}
#endif /* PNG_READ_iCCP_SUPPORTED */

#ifdef PNG_READ_sPLT_SUPPORTED
void /* PRIVATE */
png_handle_sPLT(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
/* Note: this does not properly handle chunks that are > 64K under DOS */
{
   png_bytep entry_start;
   png_sPLT_t new_palette;
#ifdef PNG_POINTER_INDEXING_SUPPORTED
   png_sPLT_entryp pp;
#endif
   int data_length, entry_size, i;
   png_uint_32 skip = 0;
   png_size_t slength;

   png_debug(1, "in png_handle_sPLT");

#ifdef PNG_USER_LIMITS_SUPPORTED

   if (png_ptr->user_chunk_cache_max != 0)
   {
      if (png_ptr->user_chunk_cache_max == 1)
      {
         png_crc_finish(png_ptr, length);
         return;
      }
      if (--png_ptr->user_chunk_cache_max == 1)
      {
         png_warning(png_ptr, "No space in chunk cache for sPLT");
         png_crc_finish(png_ptr, length);
         return;
      }
   }
#endif

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before sPLT");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid sPLT after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }

#ifdef PNG_MAX_MALLOC_64K
   if (length > (png_uint_32)65535L)
   {
      png_warning(png_ptr, "sPLT chunk too large to fit in memory");
      skip = length - (png_uint_32)65535L;
      length = (png_uint_32)65535L;
   }
#endif

   png_free(png_ptr, png_ptr->chunkdata);
   png_ptr->chunkdata = (png_charp)png_malloc(png_ptr, length + 1);
   slength = (png_size_t)length;
   png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);

   if (png_crc_finish(png_ptr, skip))
   {
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
      return;
   }

   png_ptr->chunkdata[slength] = 0x00;

   for (entry_start = (png_bytep)png_ptr->chunkdata; *entry_start;
       entry_start++)
      /* Empty loop to find end of name */ ;
   ++entry_start;

   /* A sample depth should follow the separator, and we should be on it  */
   if (slength < 2U ||
       entry_start > (png_bytep)png_ptr->chunkdata + slength - 2U)
   {
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
      png_warning(png_ptr, "malformed sPLT chunk");
      return;
   }

   new_palette.depth = *entry_start++;
   entry_size = (new_palette.depth == 8 ? 6 : 10);
   data_length = (slength - (entry_start - (png_bytep)png_ptr->chunkdata));

   /* Integrity-check the data length */
   if (data_length % entry_size)
   {
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
      png_warning(png_ptr, "sPLT chunk has bad length");
      return;
   }

   new_palette.nentries = (png_int_32) ( data_length / entry_size);
   if ((png_uint_32) new_palette.nentries >
       (png_uint_32) (PNG_SIZE_MAX / png_sizeof(png_sPLT_entry)))
   {
       png_warning(png_ptr, "sPLT chunk too long");
       return;
   }
   new_palette.entries = (png_sPLT_entryp)png_malloc_warn(
       png_ptr, new_palette.nentries * png_sizeof(png_sPLT_entry));
   if (new_palette.entries == NULL)
   {
       png_warning(png_ptr, "sPLT chunk requires too much memory");
       return;
   }

#ifdef PNG_POINTER_INDEXING_SUPPORTED
   for (i = 0; i < new_palette.nentries; i++)
   {
      pp = new_palette.entries + i;

      if (new_palette.depth == 8)
      {
          pp->red = *entry_start++;
          pp->green = *entry_start++;
          pp->blue = *entry_start++;
          pp->alpha = *entry_start++;
      }
      else
      {
          pp->red   = png_get_uint_16(entry_start); entry_start += 2;
          pp->green = png_get_uint_16(entry_start); entry_start += 2;
          pp->blue  = png_get_uint_16(entry_start); entry_start += 2;
          pp->alpha = png_get_uint_16(entry_start); entry_start += 2;
      }
      pp->frequency = png_get_uint_16(entry_start); entry_start += 2;
   }
#else
   pp = new_palette.entries;
   for (i = 0; i < new_palette.nentries; i++)
   {

      if (new_palette.depth == 8)
      {
          pp[i].red   = *entry_start++;
          pp[i].green = *entry_start++;
          pp[i].blue  = *entry_start++;
          pp[i].alpha = *entry_start++;
      }
      else
      {
          pp[i].red   = png_get_uint_16(entry_start); entry_start += 2;
          pp[i].green = png_get_uint_16(entry_start); entry_start += 2;
          pp[i].blue  = png_get_uint_16(entry_start); entry_start += 2;
          pp[i].alpha = png_get_uint_16(entry_start); entry_start += 2;
      }
      pp->frequency = png_get_uint_16(entry_start); entry_start += 2;
   }
#endif

   /* Discard all chunk data except the name and stash that */
   new_palette.name = png_ptr->chunkdata;

   png_set_sPLT(png_ptr, info_ptr, &new_palette, 1);

   png_free(png_ptr, png_ptr->chunkdata);
   png_ptr->chunkdata = NULL;
   png_free(png_ptr, new_palette.entries);
}
#endif /* PNG_READ_sPLT_SUPPORTED */

#ifdef PNG_READ_tRNS_SUPPORTED
void /* PRIVATE */
png_handle_tRNS(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_byte readbuf[PNG_MAX_PALETTE_LENGTH];

   png_debug(1, "in png_handle_tRNS");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before tRNS");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid tRNS after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS))
   {
      png_warning(png_ptr, "Duplicate tRNS chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)
   {
      png_byte buf[2];

      if (length != 2)
      {
         png_warning(png_ptr, "Incorrect tRNS chunk length");
         png_crc_finish(png_ptr, length);
         return;
      }

      png_crc_read(png_ptr, buf, 2);
      png_ptr->num_trans = 1;
      png_ptr->trans_values.gray = png_get_uint_16(buf);
   }
   else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)
   {
      png_byte buf[6];

      if (length != 6)
      {
         png_warning(png_ptr, "Incorrect tRNS chunk length");
         png_crc_finish(png_ptr, length);
         return;
      }
      png_crc_read(png_ptr, buf, (png_size_t)length);
      png_ptr->num_trans = 1;
      png_ptr->trans_values.red = png_get_uint_16(buf);
      png_ptr->trans_values.green = png_get_uint_16(buf + 2);
      png_ptr->trans_values.blue = png_get_uint_16(buf + 4);
   }
   else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
   {
      if (!(png_ptr->mode & PNG_HAVE_PLTE))
      {
         /* Should be an error, but we can cope with it. */
         png_warning(png_ptr, "Missing PLTE before tRNS");
      }
      if (length > (png_uint_32)png_ptr->num_palette ||
          length > PNG_MAX_PALETTE_LENGTH)
      {
         png_warning(png_ptr, "Incorrect tRNS chunk length");
         png_crc_finish(png_ptr, length);
         return;
      }
      if (length == 0)
      {
         png_warning(png_ptr, "Zero length tRNS chunk");
         png_crc_finish(png_ptr, length);
         return;
      }
      png_crc_read(png_ptr, readbuf, (png_size_t)length);
      png_ptr->num_trans = (png_uint_16)length;
   }
   else
   {
      png_warning(png_ptr, "tRNS chunk not allowed with alpha channel");
      png_crc_finish(png_ptr, length);
      return;
   }

   if (png_crc_finish(png_ptr, 0))
   {
      png_ptr->num_trans = 0;
      return;
   }

   png_set_tRNS(png_ptr, info_ptr, readbuf, png_ptr->num_trans,
      &(png_ptr->trans_values));
}
#endif

#ifdef PNG_READ_bKGD_SUPPORTED
void /* PRIVATE */
png_handle_bKGD(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_size_t truelen;
   png_byte buf[6];

   png_debug(1, "in png_handle_bKGD");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before bKGD");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid bKGD after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
            !(png_ptr->mode & PNG_HAVE_PLTE))
   {
      png_warning(png_ptr, "Missing PLTE before bKGD");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_bKGD))
   {
      png_warning(png_ptr, "Duplicate bKGD chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      truelen = 1;
   else if (png_ptr->color_type & PNG_COLOR_MASK_COLOR)
      truelen = 6;
   else
      truelen = 2;

   if (length != truelen)
   {
      png_warning(png_ptr, "Incorrect bKGD chunk length");
      png_crc_finish(png_ptr, length);
      return;
   }

   png_crc_read(png_ptr, buf, truelen);
   if (png_crc_finish(png_ptr, 0))
      return;

   /* We convert the index value into RGB components so that we can allow
    * arbitrary RGB values for background when we have transparency, and
    * so it is easy to determine the RGB values of the background color
    * from the info_ptr struct. */
   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
   {
      png_ptr->background.index = buf[0];
      if (info_ptr && info_ptr->num_palette)
      {
          if (buf[0] >= info_ptr->num_palette)
          {
             png_warning(png_ptr, "Incorrect bKGD chunk index value");
             return;
          }
          png_ptr->background.red =
             (png_uint_16)png_ptr->palette[buf[0]].red;
          png_ptr->background.green =
             (png_uint_16)png_ptr->palette[buf[0]].green;
          png_ptr->background.blue =
             (png_uint_16)png_ptr->palette[buf[0]].blue;
      }
   }
   else if (!(png_ptr->color_type & PNG_COLOR_MASK_COLOR)) /* GRAY */
   {
      png_ptr->background.red =
      png_ptr->background.green =
      png_ptr->background.blue =
      png_ptr->background.gray = png_get_uint_16(buf);
   }
   else
   {
      png_ptr->background.red = png_get_uint_16(buf);
      png_ptr->background.green = png_get_uint_16(buf + 2);
      png_ptr->background.blue = png_get_uint_16(buf + 4);
   }

   png_set_bKGD(png_ptr, info_ptr, &(png_ptr->background));
}
#endif

#ifdef PNG_READ_hIST_SUPPORTED
void /* PRIVATE */
png_handle_hIST(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   unsigned int num, i;
   png_uint_16 readbuf[PNG_MAX_PALETTE_LENGTH];

   png_debug(1, "in png_handle_hIST");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before hIST");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid hIST after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (!(png_ptr->mode & PNG_HAVE_PLTE))
   {
      png_warning(png_ptr, "Missing PLTE before hIST");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_hIST))
   {
      png_warning(png_ptr, "Duplicate hIST chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   if (length > 2*PNG_MAX_PALETTE_LENGTH ||
       length != (unsigned int) (2*png_ptr->num_palette))
   {
      png_warning(png_ptr, "Incorrect hIST chunk length");
      png_crc_finish(png_ptr, length);
      return;
   }

   num = length / 2 ;

   for (i = 0; i < num; i++)
   {
      png_byte buf[2];

      png_crc_read(png_ptr, buf, 2);
      readbuf[i] = png_get_uint_16(buf);
   }

   if (png_crc_finish(png_ptr, 0))
      return;

   png_set_hIST(png_ptr, info_ptr, readbuf);
}
#endif

#ifdef PNG_READ_pHYs_SUPPORTED
void /* PRIVATE */
png_handle_pHYs(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_byte buf[9];
   png_uint_32 res_x, res_y;
   int unit_type;

   png_debug(1, "in png_handle_pHYs");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before pHYs");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid pHYs after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_pHYs))
   {
      png_warning(png_ptr, "Duplicate pHYs chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   if (length != 9)
   {
      png_warning(png_ptr, "Incorrect pHYs chunk length");
      png_crc_finish(png_ptr, length);
      return;
   }

   png_crc_read(png_ptr, buf, 9);
   if (png_crc_finish(png_ptr, 0))
      return;

   res_x = png_get_uint_32(buf);
   res_y = png_get_uint_32(buf + 4);
   unit_type = buf[8];
   png_set_pHYs(png_ptr, info_ptr, res_x, res_y, unit_type);
}
#endif

#ifdef PNG_READ_oFFs_SUPPORTED
void /* PRIVATE */
png_handle_oFFs(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_byte buf[9];
   png_int_32 offset_x, offset_y;
   int unit_type;

   png_debug(1, "in png_handle_oFFs");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before oFFs");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid oFFs after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_oFFs))
   {
      png_warning(png_ptr, "Duplicate oFFs chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   if (length != 9)
   {
      png_warning(png_ptr, "Incorrect oFFs chunk length");
      png_crc_finish(png_ptr, length);
      return;
   }

   png_crc_read(png_ptr, buf, 9);
   if (png_crc_finish(png_ptr, 0))
      return;

   offset_x = png_get_int_32(buf);
   offset_y = png_get_int_32(buf + 4);
   unit_type = buf[8];
   png_set_oFFs(png_ptr, info_ptr, offset_x, offset_y, unit_type);
}
#endif

#ifdef PNG_READ_pCAL_SUPPORTED
/* Read the pCAL chunk (described in the PNG Extensions document) */
void /* PRIVATE */
png_handle_pCAL(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_int_32 X0, X1;
   png_byte type, nparams;
   png_charp buf, units, endptr;
   png_charpp params;
   png_size_t slength;
   int i;

   png_debug(1, "in png_handle_pCAL");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before pCAL");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid pCAL after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_pCAL))
   {
      png_warning(png_ptr, "Duplicate pCAL chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   png_debug1(2, "Allocating and reading pCAL chunk data (%lu bytes)",
      length + 1);
   png_free(png_ptr, png_ptr->chunkdata);
   png_ptr->chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);
   if (png_ptr->chunkdata == NULL)
     {
       png_warning(png_ptr, "No memory for pCAL purpose.");
       return;
     }
   slength = (png_size_t)length;
   png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);

   if (png_crc_finish(png_ptr, 0))
   {
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
      return;
   }

   png_ptr->chunkdata[slength] = 0x00; /* Null terminate the last string */

   png_debug(3, "Finding end of pCAL purpose string");
   for (buf = png_ptr->chunkdata; *buf; buf++)
      /* Empty loop */ ;

   endptr = png_ptr->chunkdata + slength;

   /* We need to have at least 12 bytes after the purpose string
      in order to get the parameter information. */
   if (slength < 12U || endptr - buf <= 12)
   {
      png_warning(png_ptr, "Invalid pCAL data");
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
      return;
   }

   png_debug(3, "Reading pCAL X0, X1, type, nparams, and units");
   X0 = png_get_int_32((png_bytep)buf+1);
   X1 = png_get_int_32((png_bytep)buf+5);
   type = buf[9];
   nparams = buf[10];
   units = buf + 11;

   png_debug(3, "Checking pCAL equation type and number of parameters");
   /* Check that we have the right number of parameters for known
      equation types. */
   if ((type == PNG_EQUATION_LINEAR && nparams != 2) ||
       (type == PNG_EQUATION_BASE_E && nparams != 3) ||
       (type == PNG_EQUATION_ARBITRARY && nparams != 3) ||
       (type == PNG_EQUATION_HYPERBOLIC && nparams != 4))
   {
      png_warning(png_ptr, "Invalid pCAL parameters for equation type");
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
      return;
   }
   else if (type >= PNG_EQUATION_LAST)
   {
      png_warning(png_ptr, "Unrecognized equation type for pCAL chunk");
   }

   for (buf = units; *buf; buf++)
      /* Empty loop to move past the units string. */ ;

   png_debug(3, "Allocating pCAL parameters array");
   params = (png_charpp)png_malloc_warn(png_ptr,
      (png_uint_32)(nparams * png_sizeof(png_charp))) ;
   if (params == NULL)
     {
       png_free(png_ptr, png_ptr->chunkdata);
       png_ptr->chunkdata = NULL;
       png_warning(png_ptr, "No memory for pCAL params.");
       return;
     }

   /* Get pointers to the start of each parameter string. */
   for (i = 0; i < (int)nparams; i++)
   {
      buf++; /* Skip the null string terminator from previous parameter. */

      png_debug1(3, "Reading pCAL parameter %d", i);
      for (params[i] = buf; buf <= endptr && *buf != 0x00; buf++)
         /* Empty loop to move past each parameter string */ ;

      /* Make sure we haven't run out of data yet */
      if (buf > endptr)
      {
         png_warning(png_ptr, "Invalid pCAL data");
         png_free(png_ptr, png_ptr->chunkdata);
         png_ptr->chunkdata = NULL;
         png_free(png_ptr, params);
         return;
      }
   }

   png_set_pCAL(png_ptr, info_ptr, png_ptr->chunkdata, X0, X1, type, nparams,
      units, params);

   png_free(png_ptr, png_ptr->chunkdata);
   png_ptr->chunkdata = NULL;
   png_free(png_ptr, params);
}
#endif

#ifdef PNG_READ_sCAL_SUPPORTED
/* Read the sCAL chunk */
void /* PRIVATE */
png_handle_sCAL(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_charp ep;
#ifdef PNG_FLOATING_POINT_SUPPORTED
   double width, height;
   png_charp vp;
#else
#ifdef PNG_FIXED_POINT_SUPPORTED
   png_charp swidth, sheight;
#endif
#endif
   png_size_t slength;

   png_debug(1, "in png_handle_sCAL");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before sCAL");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid sCAL after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sCAL))
   {
      png_warning(png_ptr, "Duplicate sCAL chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   /* Need unit type, width, \0, height: minimum 4 bytes */
   else if (length < 4)
   {
      png_warning(png_ptr, "sCAL chunk too short");
      png_crc_finish(png_ptr, length);
      return;
   }

   png_debug1(2, "Allocating and reading sCAL chunk data (%lu bytes)",
      length + 1);
   png_ptr->chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);
   if (png_ptr->chunkdata == NULL)
   {
      png_warning(png_ptr, "Out of memory while processing sCAL chunk");
      png_crc_finish(png_ptr, length);
      return;
   }
   slength = (png_size_t)length;
   png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);

   if (png_crc_finish(png_ptr, 0))
   {
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
      return;
   }

   png_ptr->chunkdata[slength] = 0x00; /* Null terminate the last string */

   ep = png_ptr->chunkdata + 1;        /* Skip unit byte */

#ifdef PNG_FLOATING_POINT_SUPPORTED
   width = png_strtod(png_ptr, ep, &vp);
   if (*vp)
   {
      png_warning(png_ptr, "malformed width string in sCAL chunk");
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
      return;
   }
#else
#ifdef PNG_FIXED_POINT_SUPPORTED
   swidth = (png_charp)png_malloc_warn(png_ptr, png_strlen(ep) + 1);
   if (swidth == NULL)
   {
      png_warning(png_ptr, "Out of memory while processing sCAL chunk width");
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
      return;
   }
   png_memcpy(swidth, ep, (png_size_t)png_strlen(ep) + 1);
#endif
#endif

   for (ep = png_ptr->chunkdata + 1; *ep; ep++)
      /* Empty loop */ ;
   ep++;

   if (png_ptr->chunkdata + slength < ep)
   {
      png_warning(png_ptr, "Truncated sCAL chunk");
#if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)
      png_free(png_ptr, swidth);
#endif
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
      return;
   }

#ifdef PNG_FLOATING_POINT_SUPPORTED
   height = png_strtod(png_ptr, ep, &vp);
   if (*vp)
   {
      png_warning(png_ptr, "malformed height string in sCAL chunk");
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
#if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)
      png_free(png_ptr, swidth);
#endif
      return;
   }
#else
#ifdef PNG_FIXED_POINT_SUPPORTED
   sheight = (png_charp)png_malloc_warn(png_ptr, png_strlen(ep) + 1);
   if (sheight == NULL)
   {
      png_warning(png_ptr, "Out of memory while processing sCAL chunk height");
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
#if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)
      png_free(png_ptr, swidth);
#endif
      return;
   }
   png_memcpy(sheight, ep, (png_size_t)png_strlen(ep) + 1);
#endif
#endif

   if (png_ptr->chunkdata + slength < ep
#ifdef PNG_FLOATING_POINT_SUPPORTED
      || width <= 0. || height <= 0.
#endif
      )
   {
      png_warning(png_ptr, "Invalid sCAL data");
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
#if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)
      png_free(png_ptr, swidth);
      png_free(png_ptr, sheight);
#endif
      return;
   }


#ifdef PNG_FLOATING_POINT_SUPPORTED
   png_set_sCAL(png_ptr, info_ptr, png_ptr->chunkdata[0], width, height);
#else
#ifdef PNG_FIXED_POINT_SUPPORTED
   png_set_sCAL_s(png_ptr, info_ptr, png_ptr->chunkdata[0], swidth, sheight);
#endif
#endif

   png_free(png_ptr, png_ptr->chunkdata);
   png_ptr->chunkdata = NULL;
#if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)
   png_free(png_ptr, swidth);
   png_free(png_ptr, sheight);
#endif
}
#endif

#ifdef PNG_READ_tIME_SUPPORTED
void /* PRIVATE */
png_handle_tIME(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_byte buf[7];
   png_time mod_time;

   png_debug(1, "in png_handle_tIME");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Out of place tIME chunk");
   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tIME))
   {
      png_warning(png_ptr, "Duplicate tIME chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   if (png_ptr->mode & PNG_HAVE_IDAT)
      png_ptr->mode |= PNG_AFTER_IDAT;

   if (length != 7)
   {
      png_warning(png_ptr, "Incorrect tIME chunk length");
      png_crc_finish(png_ptr, length);
      return;
   }

   png_crc_read(png_ptr, buf, 7);
   if (png_crc_finish(png_ptr, 0))
      return;

   mod_time.second = buf[6];
   mod_time.minute = buf[5];
   mod_time.hour = buf[4];
   mod_time.day = buf[3];
   mod_time.month = buf[2];
   mod_time.year = png_get_uint_16(buf);

   png_set_tIME(png_ptr, info_ptr, &mod_time);
}
#endif

#ifdef PNG_READ_tEXt_SUPPORTED
/* Note: this does not properly handle chunks that are > 64K under DOS */
void /* PRIVATE */
png_handle_tEXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_textp text_ptr;
   png_charp key;
   png_charp text;
   png_uint_32 skip = 0;
   png_size_t slength;
   int ret;

   png_debug(1, "in png_handle_tEXt");

#ifdef PNG_USER_LIMITS_SUPPORTED
   if (png_ptr->user_chunk_cache_max != 0)
   {
      if (png_ptr->user_chunk_cache_max == 1)
      {
         png_crc_finish(png_ptr, length);
         return;
      }
      if (--png_ptr->user_chunk_cache_max == 1)
      {
         png_warning(png_ptr, "No space in chunk cache for tEXt");
         png_crc_finish(png_ptr, length);
         return;
      }
   }
#endif

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before tEXt");

   if (png_ptr->mode & PNG_HAVE_IDAT)
      png_ptr->mode |= PNG_AFTER_IDAT;

#ifdef PNG_MAX_MALLOC_64K
   if (length > (png_uint_32)65535L)
   {
      png_warning(png_ptr, "tEXt chunk too large to fit in memory");
      skip = length - (png_uint_32)65535L;
      length = (png_uint_32)65535L;
   }
#endif

   png_free(png_ptr, png_ptr->chunkdata);

   png_ptr->chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);
   if (png_ptr->chunkdata == NULL)
   {
     png_warning(png_ptr, "No memory to process text chunk.");
     return;
   }
   slength = (png_size_t)length;
   png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);

   if (png_crc_finish(png_ptr, skip))
   {
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
      return;
   }

   key = png_ptr->chunkdata;

   key[slength] = 0x00;

   for (text = key; *text; text++)
      /* Empty loop to find end of key */ ;

   if (text != key + slength)
      text++;

   text_ptr = (png_textp)png_malloc_warn(png_ptr,
      (png_uint_32)png_sizeof(png_text));
   if (text_ptr == NULL)
   {
     png_warning(png_ptr, "Not enough memory to process text chunk.");
     png_free(png_ptr, png_ptr->chunkdata);
     png_ptr->chunkdata = NULL;
     return;
   }
   text_ptr->compression = PNG_TEXT_COMPRESSION_NONE;
   text_ptr->key = key;
#ifdef PNG_iTXt_SUPPORTED
   text_ptr->lang = NULL;
   text_ptr->lang_key = NULL;
   text_ptr->itxt_length = 0;
#endif
   text_ptr->text = text;
   text_ptr->text_length = png_strlen(text);

   ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);

   png_free(png_ptr, png_ptr->chunkdata);
   png_ptr->chunkdata = NULL;
   png_free(png_ptr, text_ptr);
   if (ret)
     png_warning(png_ptr, "Insufficient memory to process text chunk.");
}
#endif

#ifdef PNG_READ_zTXt_SUPPORTED
/* Note: this does not correctly handle chunks that are > 64K under DOS */
void /* PRIVATE */
png_handle_zTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_textp text_ptr;
   png_charp text;
   int comp_type;
   int ret;
   png_size_t slength, prefix_len, data_len;

   png_debug(1, "in png_handle_zTXt");

#ifdef PNG_USER_LIMITS_SUPPORTED
   if (png_ptr->user_chunk_cache_max != 0)
   {
      if (png_ptr->user_chunk_cache_max == 1)
      {
         png_crc_finish(png_ptr, length);
         return;
      }
      if (--png_ptr->user_chunk_cache_max == 1)
      {
         png_warning(png_ptr, "No space in chunk cache for zTXt");
         png_crc_finish(png_ptr, length);
         return;
      }
   }
#endif

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before zTXt");

   if (png_ptr->mode & PNG_HAVE_IDAT)
      png_ptr->mode |= PNG_AFTER_IDAT;

#ifdef PNG_MAX_MALLOC_64K
   /* We will no doubt have problems with chunks even half this size, but
      there is no hard and fast rule to tell us where to stop. */
   if (length > (png_uint_32)65535L)
   {
     png_warning(png_ptr, "zTXt chunk too large to fit in memory");
     png_crc_finish(png_ptr, length);
     return;
   }
#endif

   png_free(png_ptr, png_ptr->chunkdata);
   png_ptr->chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);
   if (png_ptr->chunkdata == NULL)
   {
     png_warning(png_ptr, "Out of memory processing zTXt chunk.");
     return;
   }
   slength = (png_size_t)length;
   png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);
   if (png_crc_finish(png_ptr, 0))
   {
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
      return;
   }

   png_ptr->chunkdata[slength] = 0x00;

   for (text = png_ptr->chunkdata; *text; text++)
      /* Empty loop */ ;

   /* zTXt must have some text after the chunkdataword */
   if (slength < 2U || text >= png_ptr->chunkdata + slength - 2U)
   {
      png_warning(png_ptr, "Truncated zTXt chunk");
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
      return;
   }
   else
   {
       comp_type = *(++text);
       if (comp_type != PNG_TEXT_COMPRESSION_zTXt)
       {
          png_warning(png_ptr, "Unknown compression type in zTXt chunk");
          comp_type = PNG_TEXT_COMPRESSION_zTXt;
       }
       text++;        /* Skip the compression_method byte */
   }
   prefix_len = text - png_ptr->chunkdata;

   png_decompress_chunk(png_ptr, comp_type,
     (png_size_t)length, prefix_len, &data_len);

   text_ptr = (png_textp)png_malloc_warn(png_ptr,
      (png_uint_32)png_sizeof(png_text));
   if (text_ptr == NULL)
   {
     png_warning(png_ptr, "Not enough memory to process zTXt chunk.");
     png_free(png_ptr, png_ptr->chunkdata);
     png_ptr->chunkdata = NULL;
     return;
   }
   text_ptr->compression = comp_type;
   text_ptr->key = png_ptr->chunkdata;
#ifdef PNG_iTXt_SUPPORTED
   text_ptr->lang = NULL;
   text_ptr->lang_key = NULL;
   text_ptr->itxt_length = 0;
#endif
   text_ptr->text = png_ptr->chunkdata + prefix_len;
   text_ptr->text_length = data_len;

   ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);

   png_free(png_ptr, text_ptr);
   png_free(png_ptr, png_ptr->chunkdata);
   png_ptr->chunkdata = NULL;
   if (ret)
     png_error(png_ptr, "Insufficient memory to store zTXt chunk.");
}
#endif

#ifdef PNG_READ_iTXt_SUPPORTED
/* Note: this does not correctly handle chunks that are > 64K under DOS */
void /* PRIVATE */
png_handle_iTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_textp text_ptr;
   png_charp key, lang, text, lang_key;
   int comp_flag;
   int comp_type = 0;
   int ret;
   png_size_t slength, prefix_len, data_len;

   png_debug(1, "in png_handle_iTXt");

#ifdef PNG_USER_LIMITS_SUPPORTED
   if (png_ptr->user_chunk_cache_max != 0)
   {
      if (png_ptr->user_chunk_cache_max == 1)
      {
         png_crc_finish(png_ptr, length);
         return;
      }
      if (--png_ptr->user_chunk_cache_max == 1)
      {
         png_warning(png_ptr, "No space in chunk cache for iTXt");
         png_crc_finish(png_ptr, length);
         return;
      }
   }
#endif

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before iTXt");

   if (png_ptr->mode & PNG_HAVE_IDAT)
      png_ptr->mode |= PNG_AFTER_IDAT;

#ifdef PNG_MAX_MALLOC_64K
   /* We will no doubt have problems with chunks even half this size, but
      there is no hard and fast rule to tell us where to stop. */
   if (length > (png_uint_32)65535L)
   {
     png_warning(png_ptr, "iTXt chunk too large to fit in memory");
     png_crc_finish(png_ptr, length);
     return;
   }
#endif

   png_free(png_ptr, png_ptr->chunkdata);
   png_ptr->chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);
   if (png_ptr->chunkdata == NULL)
   {
     png_warning(png_ptr, "No memory to process iTXt chunk.");
     return;
   }
   slength = (png_size_t)length;
   png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);
   if (png_crc_finish(png_ptr, 0))
   {
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
      return;
   }

   png_ptr->chunkdata[slength] = 0x00;

   for (lang = png_ptr->chunkdata; *lang; lang++)
      /* Empty loop */ ;
   lang++;        /* Skip NUL separator */

   /* iTXt must have a language tag (possibly empty), two compression bytes,
    * translated keyword (possibly empty), and possibly some text after the
    * keyword
    */

   if (slength < 3U || lang >= png_ptr->chunkdata + slength - 3U)
   {
      png_warning(png_ptr, "Truncated iTXt chunk");
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
      return;
   }
   else
   {
       comp_flag = *lang++;
       comp_type = *lang++;
   }

   for (lang_key = lang; *lang_key; lang_key++)
      /* Empty loop */ ;
   lang_key++;        /* Skip NUL separator */

   if (lang_key >= png_ptr->chunkdata + slength)
   {
      png_warning(png_ptr, "Truncated iTXt chunk");
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
      return;
   }

   for (text = lang_key; *text; text++)
      /* Empty loop */ ;
   text++;        /* Skip NUL separator */
   if (text >= png_ptr->chunkdata + slength)
   {
      png_warning(png_ptr, "Malformed iTXt chunk");
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
      return;
   }

   prefix_len = text - png_ptr->chunkdata;

   key=png_ptr->chunkdata;
   if (comp_flag)
       png_decompress_chunk(png_ptr, comp_type,
         (size_t)length, prefix_len, &data_len);
   else
       data_len = png_strlen(png_ptr->chunkdata + prefix_len);
   text_ptr = (png_textp)png_malloc_warn(png_ptr,
      (png_uint_32)png_sizeof(png_text));
   if (text_ptr == NULL)
   {
     png_warning(png_ptr, "Not enough memory to process iTXt chunk.");
     png_free(png_ptr, png_ptr->chunkdata);
     png_ptr->chunkdata = NULL;
     return;
   }
   text_ptr->compression = (int)comp_flag + 1;
   text_ptr->lang_key = png_ptr->chunkdata + (lang_key - key);
   text_ptr->lang = png_ptr->chunkdata + (lang - key);
   text_ptr->itxt_length = data_len;
   text_ptr->text_length = 0;
   text_ptr->key = png_ptr->chunkdata;
   text_ptr->text = png_ptr->chunkdata + prefix_len;

   ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);

   png_free(png_ptr, text_ptr);
   png_free(png_ptr, png_ptr->chunkdata);
   png_ptr->chunkdata = NULL;
   if (ret)
     png_error(png_ptr, "Insufficient memory to store iTXt chunk.");
}
#endif

/* This function is called when we haven't found a handler for a
   chunk.  If there isn't a problem with the chunk itself (ie bad
   chunk name, CRC, or a critical chunk), the chunk is silently ignored
   -- unless the PNG_FLAG_UNKNOWN_CHUNKS_SUPPORTED flag is on in which
   case it will be saved away to be written out later. */
void /* PRIVATE */
png_handle_unknown(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_uint_32 skip = 0;

   png_debug(1, "in png_handle_unknown");

#ifdef PNG_USER_LIMITS_SUPPORTED
   if (png_ptr->user_chunk_cache_max != 0)
   {
      if (png_ptr->user_chunk_cache_max == 1)
      {
         png_crc_finish(png_ptr, length);
         return;
      }
      if (--png_ptr->user_chunk_cache_max == 1)
      {
         png_warning(png_ptr, "No space in chunk cache for unknown chunk");
         png_crc_finish(png_ptr, length);
         return;
      }
   }
#endif

   if (png_ptr->mode & PNG_HAVE_IDAT)
   {
#ifdef PNG_USE_LOCAL_ARRAYS
      PNG_CONST PNG_IDAT;
#endif
      if (png_memcmp(png_ptr->chunk_name, png_IDAT, 4))  /* Not an IDAT */
         png_ptr->mode |= PNG_AFTER_IDAT;
   }

   if (!(png_ptr->chunk_name[0] & 0x20))
   {
#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
      if (png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
           PNG_HANDLE_CHUNK_ALWAYS
#ifdef PNG_READ_USER_CHUNKS_SUPPORTED
           && png_ptr->read_user_chunk_fn == NULL
#endif
        )
#endif
          png_chunk_error(png_ptr, "unknown critical chunk");
   }

#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
   if ((png_ptr->flags & PNG_FLAG_KEEP_UNKNOWN_CHUNKS)
#ifdef PNG_READ_USER_CHUNKS_SUPPORTED
       || (png_ptr->read_user_chunk_fn != NULL)
#endif
        )
   {
#ifdef PNG_MAX_MALLOC_64K
       if (length > (png_uint_32)65535L)
       {
           png_warning(png_ptr, "unknown chunk too large to fit in memory");
           skip = length - (png_uint_32)65535L;
           length = (png_uint_32)65535L;
       }
#endif
       png_memcpy((png_charp)png_ptr->unknown_chunk.name,
                  (png_charp)png_ptr->chunk_name,
                  png_sizeof(png_ptr->unknown_chunk.name));
       png_ptr->unknown_chunk.name[png_sizeof(png_ptr->unknown_chunk.name)-1]
           = '\0';
       png_ptr->unknown_chunk.size = (png_size_t)length;
       if (length == 0)
         png_ptr->unknown_chunk.data = NULL;
       else
       {
         png_ptr->unknown_chunk.data = (png_bytep)png_malloc(png_ptr, length);
         png_crc_read(png_ptr, (png_bytep)png_ptr->unknown_chunk.data, length);
       }
#ifdef PNG_READ_USER_CHUNKS_SUPPORTED
       if (png_ptr->read_user_chunk_fn != NULL)
       {
          /* Callback to user unknown chunk handler */
          int ret;
          ret = (*(png_ptr->read_user_chunk_fn))
            (png_ptr, &png_ptr->unknown_chunk);
          if (ret < 0)
             png_chunk_error(png_ptr, "error in user chunk");
          if (ret == 0)
          {
             if (!(png_ptr->chunk_name[0] & 0x20))
#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
                if (png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
                     PNG_HANDLE_CHUNK_ALWAYS)
#endif
                   png_chunk_error(png_ptr, "unknown critical chunk");
             png_set_unknown_chunks(png_ptr, info_ptr,
               &png_ptr->unknown_chunk, 1);
          }
       }
       else
#endif
       png_set_unknown_chunks(png_ptr, info_ptr, &png_ptr->unknown_chunk, 1);
       png_free(png_ptr, png_ptr->unknown_chunk.data);
       png_ptr->unknown_chunk.data = NULL;
   }
   else
#endif
      skip = length;

   png_crc_finish(png_ptr, skip);

#ifndef PNG_READ_USER_CHUNKS_SUPPORTED
   PNG_UNUSED(info_ptr) /* Quiet compiler warnings about unused info_ptr */
#endif
}

/* This function is called to verify that a chunk name is valid.
   This function can't have the "critical chunk check" incorporated
   into it, since in the future we will need to be able to call user
   functions to handle unknown critical chunks after we check that
   the chunk name itself is valid. */

#define isnonalpha(c) ((c) < 65 || (c) > 122 || ((c) > 90 && (c) < 97))

void /* PRIVATE */
png_check_chunk_name(png_structp png_ptr, png_bytep chunk_name)
{
   png_debug(1, "in png_check_chunk_name");
   if (isnonalpha(chunk_name[0]) || isnonalpha(chunk_name[1]) ||
       isnonalpha(chunk_name[2]) || isnonalpha(chunk_name[3]))
   {
      png_chunk_error(png_ptr, "invalid chunk type");
   }
}

/* Combines the row recently read in with the existing pixels in the
   row.  This routine takes care of alpha and transparency if requested.
   This routine also handles the two methods of progressive display
   of interlaced images, depending on the mask value.
   The mask value describes which pixels are to be combined with
   the row.  The pattern always repeats every 8 pixels, so just 8
   bits are needed.  A one indicates the pixel is to be combined,
   a zero indicates the pixel is to be skipped.  This is in addition
   to any alpha or transparency value associated with the pixel.  If
   you want all pixels to be combined, pass 0xff (255) in mask.  */

void /* PRIVATE */
png_combine_row(png_structp png_ptr, png_bytep row, int mask)
{
   png_debug(1, "in png_combine_row");
   if (mask == 0xff)
   {
      png_memcpy(row, png_ptr->row_buf + 1,
         PNG_ROWBYTES(png_ptr->row_info.pixel_depth, png_ptr->width));
   }
   else
   {
      switch (png_ptr->row_info.pixel_depth)
      {
         case 1:
         {
            png_bytep sp = png_ptr->row_buf + 1;
            png_bytep dp = row;
            int s_inc, s_start, s_end;
            int m = 0x80;
            int shift;
            png_uint_32 i;
            png_uint_32 row_width = png_ptr->width;

#ifdef PNG_READ_PACKSWAP_SUPPORTED
            if (png_ptr->transformations & PNG_PACKSWAP)
            {
                s_start = 0;
                s_end = 7;
                s_inc = 1;
            }
            else
#endif
            {
                s_start = 7;
                s_end = 0;
                s_inc = -1;
            }

            shift = s_start;

            for (i = 0; i < row_width; i++)
            {
               if (m & mask)
               {
                  int value;

                  value = (*sp >> shift) & 0x01;
                  *dp &= (png_byte)((0x7f7f >> (7 - shift)) & 0xff);
                  *dp |= (png_byte)(value << shift);
               }

               if (shift == s_end)
               {
                  shift = s_start;
                  sp++;
                  dp++;
               }
               else
                  shift += s_inc;

               if (m == 1)
                  m = 0x80;
               else
                  m >>= 1;
            }
            break;
         }
         case 2:
         {
            png_bytep sp = png_ptr->row_buf + 1;
            png_bytep dp = row;
            int s_start, s_end, s_inc;
            int m = 0x80;
            int shift;
            png_uint_32 i;
            png_uint_32 row_width = png_ptr->width;
            int value;

#ifdef PNG_READ_PACKSWAP_SUPPORTED
            if (png_ptr->transformations & PNG_PACKSWAP)
            {
               s_start = 0;
               s_end = 6;
               s_inc = 2;
            }
            else
#endif
            {
               s_start = 6;
               s_end = 0;
               s_inc = -2;
            }

            shift = s_start;

            for (i = 0; i < row_width; i++)
            {
               if (m & mask)
               {
                  value = (*sp >> shift) & 0x03;
                  *dp &= (png_byte)((0x3f3f >> (6 - shift)) & 0xff);
                  *dp |= (png_byte)(value << shift);
               }

               if (shift == s_end)
               {
                  shift = s_start;
                  sp++;
                  dp++;
               }
               else
                  shift += s_inc;
               if (m == 1)
                  m = 0x80;
               else
                  m >>= 1;
            }
            break;
         }
         case 4:
         {
            png_bytep sp = png_ptr->row_buf + 1;
            png_bytep dp = row;
            int s_start, s_end, s_inc;
            int m = 0x80;
            int shift;
            png_uint_32 i;
            png_uint_32 row_width = png_ptr->width;
            int value;

#ifdef PNG_READ_PACKSWAP_SUPPORTED
            if (png_ptr->transformations & PNG_PACKSWAP)
            {
               s_start = 0;
               s_end = 4;
               s_inc = 4;
            }
            else
#endif
            {
               s_start = 4;
               s_end = 0;
               s_inc = -4;
            }
            shift = s_start;

            for (i = 0; i < row_width; i++)
            {
               if (m & mask)
               {
                  value = (*sp >> shift) & 0xf;
                  *dp &= (png_byte)((0xf0f >> (4 - shift)) & 0xff);
                  *dp |= (png_byte)(value << shift);
               }

               if (shift == s_end)
               {
                  shift = s_start;
                  sp++;
                  dp++;
               }
               else
                  shift += s_inc;
               if (m == 1)
                  m = 0x80;
               else
                  m >>= 1;
            }
            break;
         }
         default:
         {
            png_bytep sp = png_ptr->row_buf + 1;
            png_bytep dp = row;
            png_size_t pixel_bytes = (png_ptr->row_info.pixel_depth >> 3);
            png_uint_32 i;
            png_uint_32 row_width = png_ptr->width;
            png_byte m = 0x80;


            for (i = 0; i < row_width; i++)
            {
               if (m & mask)
               {
                  png_memcpy(dp, sp, pixel_bytes);
               }

               sp += pixel_bytes;
               dp += pixel_bytes;

               if (m == 1)
                  m = 0x80;
               else
                  m >>= 1;
            }
            break;
         }
      }
   }
}

#ifdef PNG_READ_INTERLACING_SUPPORTED
/* OLD pre-1.0.9 interface:
void png_do_read_interlace(png_row_infop row_info, png_bytep row, int pass,
   png_uint_32 transformations)
 */
void /* PRIVATE */
png_do_read_interlace(png_structp png_ptr)
{
   png_row_infop row_info = &(png_ptr->row_info);
   png_bytep row = png_ptr->row_buf + 1;
   int pass = png_ptr->pass;
   png_uint_32 transformations = png_ptr->transformations;
   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
   /* Offset to next interlace block */
#ifndef PNG_USE_GLOBAL_ARRAYS
   PNG_CONST int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
#endif

   png_debug(1, "in png_do_read_interlace");
   if (row != NULL && row_info != NULL)
   {
      png_uint_32 final_width;

      final_width = row_info->width * png_pass_inc[pass];

      switch (row_info->pixel_depth)
      {
         case 1:
         {
            png_bytep sp = row + (png_size_t)((row_info->width - 1) >> 3);
            png_bytep dp = row + (png_size_t)((final_width - 1) >> 3);
            int sshift, dshift;
            int s_start, s_end, s_inc;
            int jstop = png_pass_inc[pass];
            png_byte v;
            png_uint_32 i;
            int j;

#ifdef PNG_READ_PACKSWAP_SUPPORTED
            if (transformations & PNG_PACKSWAP)
            {
                sshift = (int)((row_info->width + 7) & 0x07);
                dshift = (int)((final_width + 7) & 0x07);
                s_start = 7;
                s_end = 0;
                s_inc = -1;
            }
            else
#endif
            {
                sshift = 7 - (int)((row_info->width + 7) & 0x07);
                dshift = 7 - (int)((final_width + 7) & 0x07);
                s_start = 0;
                s_end = 7;
                s_inc = 1;
            }

            for (i = 0; i < row_info->width; i++)
            {
               v = (png_byte)((*sp >> sshift) & 0x01);
               for (j = 0; j < jstop; j++)
               {
                  *dp &= (png_byte)((0x7f7f >> (7 - dshift)) & 0xff);
                  *dp |= (png_byte)(v << dshift);
                  if (dshift == s_end)
                  {
                     dshift = s_start;
                     dp--;
                  }
                  else
                     dshift += s_inc;
               }
               if (sshift == s_end)
               {
                  sshift = s_start;
                  sp--;
               }
               else
                  sshift += s_inc;
            }
            break;
         }
         case 2:
         {
            png_bytep sp = row + (png_uint_32)((row_info->width - 1) >> 2);
            png_bytep dp = row + (png_uint_32)((final_width - 1) >> 2);
            int sshift, dshift;
            int s_start, s_end, s_inc;
            int jstop = png_pass_inc[pass];
            png_uint_32 i;

#ifdef PNG_READ_PACKSWAP_SUPPORTED
            if (transformations & PNG_PACKSWAP)
            {
               sshift = (int)(((row_info->width + 3) & 0x03) << 1);
               dshift = (int)(((final_width + 3) & 0x03) << 1);
               s_start = 6;
               s_end = 0;
               s_inc = -2;
            }
            else
#endif
            {
               sshift = (int)((3 - ((row_info->width + 3) & 0x03)) << 1);
               dshift = (int)((3 - ((final_width + 3) & 0x03)) << 1);
               s_start = 0;
               s_end = 6;
               s_inc = 2;
            }

            for (i = 0; i < row_info->width; i++)
            {
               png_byte v;
               int j;

               v = (png_byte)((*sp >> sshift) & 0x03);
               for (j = 0; j < jstop; j++)
               {
                  *dp &= (png_byte)((0x3f3f >> (6 - dshift)) & 0xff);
                  *dp |= (png_byte)(v << dshift);
                  if (dshift == s_end)
                  {
                     dshift = s_start;
                     dp--;
                  }
                  else
                     dshift += s_inc;
               }
               if (sshift == s_end)
               {
                  sshift = s_start;
                  sp--;
               }
               else
                  sshift += s_inc;
            }
            break;
         }
         case 4:
         {
            png_bytep sp = row + (png_size_t)((row_info->width - 1) >> 1);
            png_bytep dp = row + (png_size_t)((final_width - 1) >> 1);
            int sshift, dshift;
            int s_start, s_end, s_inc;
            png_uint_32 i;
            int jstop = png_pass_inc[pass];

#ifdef PNG_READ_PACKSWAP_SUPPORTED
            if (transformations & PNG_PACKSWAP)
            {
               sshift = (int)(((row_info->width + 1) & 0x01) << 2);
               dshift = (int)(((final_width + 1) & 0x01) << 2);
               s_start = 4;
               s_end = 0;
               s_inc = -4;
            }
            else
#endif
            {
               sshift = (int)((1 - ((row_info->width + 1) & 0x01)) << 2);
               dshift = (int)((1 - ((final_width + 1) & 0x01)) << 2);
               s_start = 0;
               s_end = 4;
               s_inc = 4;
            }

            for (i = 0; i < row_info->width; i++)
            {
               png_byte v = (png_byte)((*sp >> sshift) & 0xf);
               int j;

               for (j = 0; j < jstop; j++)
               {
                  *dp &= (png_byte)((0xf0f >> (4 - dshift)) & 0xff);
                  *dp |= (png_byte)(v << dshift);
                  if (dshift == s_end)
                  {
                     dshift = s_start;
                     dp--;
                  }
                  else
                     dshift += s_inc;
               }
               if (sshift == s_end)
               {
                  sshift = s_start;
                  sp--;
               }
               else
                  sshift += s_inc;
            }
            break;
         }
         default:
         {
            png_size_t pixel_bytes = (row_info->pixel_depth >> 3);
            png_bytep sp = row + (png_size_t)(row_info->width - 1)
                * pixel_bytes;
            png_bytep dp = row + (png_size_t)(final_width - 1) * pixel_bytes;

            int jstop = png_pass_inc[pass];
            png_uint_32 i;

            for (i = 0; i < row_info->width; i++)
            {
               png_byte v[8];
               int j;

               png_memcpy(v, sp, pixel_bytes);
               for (j = 0; j < jstop; j++)
               {
                  png_memcpy(dp, v, pixel_bytes);
                  dp -= pixel_bytes;
               }
               sp -= pixel_bytes;
            }
            break;
         }
      }
      row_info->width = final_width;
      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, final_width);
   }
#ifndef PNG_READ_PACKSWAP_SUPPORTED
   PNG_UNUSED(transformations) /* Silence compiler warning */
#endif
}
#endif /* PNG_READ_INTERLACING_SUPPORTED */

void /* PRIVATE */
png_read_filter_row(png_structp png_ptr, png_row_infop row_info, png_bytep row,
   png_bytep prev_row, int filter)
{
   png_debug(1, "in png_read_filter_row");
   png_debug2(2, "row = %lu, filter = %d", png_ptr->row_number, filter);
   switch (filter)
   {
      case PNG_FILTER_VALUE_NONE:
         break;
      case PNG_FILTER_VALUE_SUB:
      {
         png_uint_32 i;
         png_uint_32 istop = row_info->rowbytes;
         png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
         png_bytep rp = row + bpp;
         png_bytep lp = row;

         for (i = bpp; i < istop; i++)
         {
            *rp = (png_byte)(((int)(*rp) + (int)(*lp++)) & 0xff);
            rp++;
         }
         break;
      }
      case PNG_FILTER_VALUE_UP:
      {
         png_uint_32 i;
         png_uint_32 istop = row_info->rowbytes;
         png_bytep rp = row;
         png_bytep pp = prev_row;

         for (i = 0; i < istop; i++)
         {
            *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
            rp++;
         }
         break;
      }
      case PNG_FILTER_VALUE_AVG:
      {
         png_uint_32 i;
         png_bytep rp = row;
         png_bytep pp = prev_row;
         png_bytep lp = row;
         png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
         png_uint_32 istop = row_info->rowbytes - bpp;

         for (i = 0; i < bpp; i++)
         {
            *rp = (png_byte)(((int)(*rp) +
               ((int)(*pp++) / 2 )) & 0xff);
            rp++;
         }

         for (i = 0; i < istop; i++)
         {
            *rp = (png_byte)(((int)(*rp) +
               (int)(*pp++ + *lp++) / 2 ) & 0xff);
            rp++;
         }
         break;
      }
      case PNG_FILTER_VALUE_PAETH:
      {
         png_uint_32 i;
         png_bytep rp = row;
         png_bytep pp = prev_row;
         png_bytep lp = row;
         png_bytep cp = prev_row;
         png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
         png_uint_32 istop=row_info->rowbytes - bpp;

         for (i = 0; i < bpp; i++)
         {
            *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
            rp++;
         }

         for (i = 0; i < istop; i++)   /* Use leftover rp,pp */
         {
            int a, b, c, pa, pb, pc, p;

            a = *lp++;
            b = *pp++;
            c = *cp++;

            p = b - c;
            pc = a - c;

#ifdef PNG_USE_ABS
            pa = abs(p);
            pb = abs(pc);
            pc = abs(p + pc);
#else
            pa = p < 0 ? -p : p;
            pb = pc < 0 ? -pc : pc;
            pc = (p + pc) < 0 ? -(p + pc) : p + pc;
#endif

            /*
               if (pa <= pb && pa <= pc)
                  p = a;
               else if (pb <= pc)
                  p = b;
               else
                  p = c;
             */

            p = (pa <= pb && pa <= pc) ? a : (pb <= pc) ? b : c;

            *rp = (png_byte)(((int)(*rp) + p) & 0xff);
            rp++;
         }
         break;
      }
      default:
         png_warning(png_ptr, "Ignoring bad adaptive filter type");
         *row = 0;
         break;
   }
}

#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
void /* PRIVATE */
png_read_finish_row(png_structp png_ptr)
{
#ifdef PNG_READ_INTERLACING_SUPPORTED
#ifndef PNG_USE_GLOBAL_ARRAYS
   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */

   /* Start of interlace block */
   PNG_CONST int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};

   /* Offset to next interlace block */
   PNG_CONST int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};

   /* Start of interlace block in the y direction */
   PNG_CONST int png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};

   /* Offset to next interlace block in the y direction */
   PNG_CONST int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
#endif
#endif /* PNG_READ_INTERLACING_SUPPORTED */

   png_debug(1, "in png_read_finish_row");
   png_ptr->row_number++;
   if (png_ptr->row_number < png_ptr->num_rows)
      return;

#ifdef PNG_READ_INTERLACING_SUPPORTED
   if (png_ptr->interlaced)
   {
      png_ptr->row_number = 0;
      png_memset_check(png_ptr, png_ptr->prev_row, 0,
         png_ptr->rowbytes + 1);
      do
      {
         png_ptr->pass++;
         if (png_ptr->pass >= 7)
            break;
         png_ptr->iwidth = (png_ptr->width +
            png_pass_inc[png_ptr->pass] - 1 -
            png_pass_start[png_ptr->pass]) /
            png_pass_inc[png_ptr->pass];

         if (!(png_ptr->transformations & PNG_INTERLACE))
         {
            png_ptr->num_rows = (png_ptr->height +
               png_pass_yinc[png_ptr->pass] - 1 -
               png_pass_ystart[png_ptr->pass]) /
               png_pass_yinc[png_ptr->pass];
            if (!(png_ptr->num_rows))
               continue;
         }
         else  /* if (png_ptr->transformations & PNG_INTERLACE) */
            break;
      } while (png_ptr->iwidth == 0);

      if (png_ptr->pass < 7)
         return;
   }
#endif /* PNG_READ_INTERLACING_SUPPORTED */

   if (!(png_ptr->flags & PNG_FLAG_ZLIB_FINISHED))
   {
#ifdef PNG_USE_LOCAL_ARRAYS
      PNG_CONST PNG_IDAT;
#endif
      char extra;
      int ret;

      png_ptr->zstream.next_out = (Byte *)&extra;
      png_ptr->zstream.avail_out = (uInt)1;
      for (;;)
      {
         if (!(png_ptr->zstream.avail_in))
         {
            while (!png_ptr->idat_size)
            {
               png_byte chunk_length[4];

               png_crc_finish(png_ptr, 0);

               png_read_data(png_ptr, chunk_length, 4);
               png_ptr->idat_size = png_get_uint_31(png_ptr, chunk_length);
               png_reset_crc(png_ptr);
               png_crc_read(png_ptr, png_ptr->chunk_name, 4);
               if (png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
                  png_error(png_ptr, "Not enough image data");

            }
            png_ptr->zstream.avail_in = (uInt)png_ptr->zbuf_size;
            png_ptr->zstream.next_in = png_ptr->zbuf;
            if (png_ptr->zbuf_size > png_ptr->idat_size)
               png_ptr->zstream.avail_in = (uInt)png_ptr->idat_size;
            png_crc_read(png_ptr, png_ptr->zbuf, png_ptr->zstream.avail_in);
            png_ptr->idat_size -= png_ptr->zstream.avail_in;
         }
         ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);
         if (ret == Z_STREAM_END)
         {
            if (!(png_ptr->zstream.avail_out) || png_ptr->zstream.avail_in ||
               png_ptr->idat_size)
               png_warning(png_ptr, "Extra compressed data.");
            png_ptr->mode |= PNG_AFTER_IDAT;
            png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
            break;
         }
         if (ret != Z_OK)
            png_error(png_ptr, png_ptr->zstream.msg ? png_ptr->zstream.msg :
                      "Decompression Error");

         if (!(png_ptr->zstream.avail_out))
         {
            png_warning(png_ptr, "Extra compressed data.");
            png_ptr->mode |= PNG_AFTER_IDAT;
            png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
            break;
         }

      }
      png_ptr->zstream.avail_out = 0;
   }

   if (png_ptr->idat_size || png_ptr->zstream.avail_in)
      png_warning(png_ptr, "Extra compression data.");

   inflateReset(&png_ptr->zstream);

   png_ptr->mode |= PNG_AFTER_IDAT;
}
#endif /* PNG_SEQUENTIAL_READ_SUPPORTED */

void /* PRIVATE */
png_read_start_row(png_structp png_ptr)
{
#ifdef PNG_READ_INTERLACING_SUPPORTED
#ifndef PNG_USE_GLOBAL_ARRAYS
   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */

   /* Start of interlace block */
   PNG_CONST int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};

   /* Offset to next interlace block */
   PNG_CONST int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};

   /* Start of interlace block in the y direction */
   PNG_CONST int png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};

   /* Offset to next interlace block in the y direction */
   PNG_CONST int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
#endif
#endif

   int max_pixel_depth;
   png_size_t row_bytes;

   png_debug(1, "in png_read_start_row");
   png_ptr->zstream.avail_in = 0;
   png_init_read_transformations(png_ptr);
#ifdef PNG_READ_INTERLACING_SUPPORTED
   if (png_ptr->interlaced)
   {
      if (!(png_ptr->transformations & PNG_INTERLACE))
         png_ptr->num_rows = (png_ptr->height + png_pass_yinc[0] - 1 -
            png_pass_ystart[0]) / png_pass_yinc[0];
      else
         png_ptr->num_rows = png_ptr->height;

      png_ptr->iwidth = (png_ptr->width +
         png_pass_inc[png_ptr->pass] - 1 -
         png_pass_start[png_ptr->pass]) /
         png_pass_inc[png_ptr->pass];
   }
   else
#endif /* PNG_READ_INTERLACING_SUPPORTED */
   {
      png_ptr->num_rows = png_ptr->height;
      png_ptr->iwidth = png_ptr->width;
   }
   max_pixel_depth = png_ptr->pixel_depth;

#ifdef PNG_READ_PACK_SUPPORTED
   if ((png_ptr->transformations & PNG_PACK) && png_ptr->bit_depth < 8)
      max_pixel_depth = 8;
#endif

#ifdef PNG_READ_EXPAND_SUPPORTED
   if (png_ptr->transformations & PNG_EXPAND)
   {
      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      {
         if (png_ptr->num_trans)
            max_pixel_depth = 32;
         else
            max_pixel_depth = 24;
      }
      else if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)
      {
         if (max_pixel_depth < 8)
            max_pixel_depth = 8;
         if (png_ptr->num_trans)
            max_pixel_depth *= 2;
      }
      else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)
      {
         if (png_ptr->num_trans)
         {
            max_pixel_depth *= 4;
            max_pixel_depth /= 3;
         }
      }
   }
#endif

#ifdef PNG_READ_FILLER_SUPPORTED
   if (png_ptr->transformations & (PNG_FILLER))
   {
      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
         max_pixel_depth = 32;
      else if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)
      {
         if (max_pixel_depth <= 8)
            max_pixel_depth = 16;
         else
            max_pixel_depth = 32;
      }
      else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)
      {
         if (max_pixel_depth <= 32)
            max_pixel_depth = 32;
         else
            max_pixel_depth = 64;
      }
   }
#endif

#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
   if (png_ptr->transformations & PNG_GRAY_TO_RGB)
   {
      if (
#ifdef PNG_READ_EXPAND_SUPPORTED
        (png_ptr->num_trans && (png_ptr->transformations & PNG_EXPAND)) ||
#endif
#ifdef PNG_READ_FILLER_SUPPORTED
        (png_ptr->transformations & (PNG_FILLER)) ||
#endif
        png_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
      {
         if (max_pixel_depth <= 16)
            max_pixel_depth = 32;
         else
            max_pixel_depth = 64;
      }
      else
      {
         if (max_pixel_depth <= 8)
           {
             if (png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
               max_pixel_depth = 32;
             else
               max_pixel_depth = 24;
           }
         else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
            max_pixel_depth = 64;
         else
            max_pixel_depth = 48;
      }
   }
#endif

#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) && \
defined(PNG_USER_TRANSFORM_PTR_SUPPORTED)
   if (png_ptr->transformations & PNG_USER_TRANSFORM)
     {
       int user_pixel_depth = png_ptr->user_transform_depth*
         png_ptr->user_transform_channels;
       if (user_pixel_depth > max_pixel_depth)
         max_pixel_depth=user_pixel_depth;
     }
#endif

   /* Align the width on the next larger 8 pixels.  Mainly used
    * for interlacing
    */
   row_bytes = ((png_ptr->width + 7) & ~((png_uint_32)7));
   /* Calculate the maximum bytes needed, adding a byte and a pixel
    * for safety's sake
    */
   row_bytes = PNG_ROWBYTES(max_pixel_depth, row_bytes) +
      1 + ((max_pixel_depth + 7) >> 3);
#ifdef PNG_MAX_MALLOC_64K
   if (row_bytes > (png_uint_32)65536L)
      png_error(png_ptr, "This image requires a row greater than 64KB");
#endif

   if (row_bytes + 64 > png_ptr->old_big_row_buf_size)
   {
     png_free(png_ptr, png_ptr->big_row_buf);
     if (png_ptr->interlaced)
        png_ptr->big_row_buf = (png_bytep)png_calloc(png_ptr,
            row_bytes + 64);
     else
        png_ptr->big_row_buf = (png_bytep)png_malloc(png_ptr,
            row_bytes + 64);
     png_ptr->old_big_row_buf_size = row_bytes + 64;

     /* Use 32 bytes of padding before and after row_buf. */
     png_ptr->row_buf = png_ptr->big_row_buf + 32;
     png_ptr->old_big_row_buf_size = row_bytes + 64;
   }

#ifdef PNG_MAX_MALLOC_64K
   if ((png_uint_32)row_bytes + 1 > (png_uint_32)65536L)
      png_error(png_ptr, "This image requires a row greater than 64KB");
#endif
   if ((png_uint_32)row_bytes > (png_uint_32)(PNG_SIZE_MAX - 1))
      png_error(png_ptr, "Row has too many bytes to allocate in memory.");

   if (row_bytes + 1 > png_ptr->old_prev_row_size)
   {
      png_free(png_ptr, png_ptr->prev_row);
      png_ptr->prev_row = (png_bytep)png_malloc(png_ptr, (png_uint_32)(
        row_bytes + 1));
      png_memset_check(png_ptr, png_ptr->prev_row, 0, row_bytes + 1);
      png_ptr->old_prev_row_size = row_bytes + 1;
   }

   png_ptr->rowbytes = row_bytes;

   png_debug1(3, "width = %lu,", png_ptr->width);
   png_debug1(3, "height = %lu,", png_ptr->height);
   png_debug1(3, "iwidth = %lu,", png_ptr->iwidth);
   png_debug1(3, "num_rows = %lu,", png_ptr->num_rows);
   png_debug1(3, "rowbytes = %lu,", png_ptr->rowbytes);
   png_debug1(3, "irowbytes = %lu",
       PNG_ROWBYTES(png_ptr->pixel_depth, png_ptr->iwidth) + 1);

   png_ptr->flags |= PNG_FLAG_ROW_INIT;
}
#endif /* PNG_READ_SUPPORTED */
@


1.12
log
@a rather slow fastmergeâ€¦
@
text
@a2739 1
#ifndef PNG_USE_GLOBAL_ARRAYS
a3086 1
#ifndef PNG_USE_GLOBAL_ARRAYS
a3216 1
#ifndef PNG_USE_GLOBAL_ARRAYS
@


1.11
log
@merge, rebase/minify, fix
@
text
@d2 1
a2 1
__RCSID("$MirOS: src/lib/libpng/png.c,v 1.11 2009/03/15 20:08:44 tg Exp $");
d6 2
a7 2
 * Last changed in libpng 1.2.48 [March 8, 2012]
 * Copyright (c) 1998-2012 Glenn Randers-Pehrson
d62 4
a65 4
   png_uint_32 i = ((png_uint_32)(*buf) << 24) +
      ((png_uint_32)(*(buf + 1)) << 16) +
      ((png_uint_32)(*(buf + 2)) << 8) +
      (png_uint_32)(*(buf + 3));
d68 1
a68 1
     png_error(png_ptr, "PNG unsigned integer out of range.");
d76 4
a79 4
   png_uint_32 i = ((png_uint_32)(*buf) << 24) +
      ((png_uint_32)(*(buf + 1)) << 16) +
      ((png_uint_32)(*(buf + 2)) << 8) +
      (png_uint_32)(*(buf + 3));
d91 4
a94 4
   png_int_32 i = ((png_int_32)(*buf) << 24) +
      ((png_int_32)(*(buf + 1)) << 16) +
      ((png_int_32)(*(buf + 2)) << 8) +
      (png_int_32)(*(buf + 3));
d103 2
a104 2
   png_uint_16 i = (png_uint_16)(((png_uint_16)(*buf) << 8) +
      (png_uint_16)(*(buf + 1)));
d304 1
d310 1
d312 1
d516 1
a516 1
   int num, i;
d568 1
d571 13
d616 1
a616 1
      png_crc_finish(png_ptr, 0);
d686 1
a686 1
   info_ptr = info_ptr; /* Quiet compiler warnings about unused info_ptr */
d1124 1
a1124 1
   if ( profile >= png_ptr->chunkdata + slength - 1)
d1157 4
a1160 4
   profile_size = ((*(pC    ))<<24) |
                  ((*(pC + 1))<<16) |
                  ((*(pC + 2))<< 8) |
                  ((*(pC + 3))    );
d1252 2
a1253 1
   if (entry_start > (png_bytep)png_ptr->chunkdata + slength - 2)
d1727 1
a1727 1
   if (endptr <= buf + 12)
d2183 1
a2183 1
   if (text >= png_ptr->chunkdata + slength - 2)
d2309 1
a2309 1
   if (lang >= png_ptr->chunkdata + slength - 3)
d2493 1
a2493 1
   info_ptr = info_ptr; /* Quiet compiler warnings about unused info_ptr */
d2743 1
d2952 1
a2952 1
   transformations = transformations; /* Silence compiler warning */
d3085 1
d3216 1
@


1.10
log
@SECURITY update; prodded by bsiegert@@
@
text
@d1 2
d6 2
a7 3
 * Last changed in libpng 1.2.34 [December 18, 2008]
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1998-2008 Glenn Randers-Pehrson
d11 4
d20 1
d22 1
a22 1
#if defined(PNG_READ_SUPPORTED)
d29 22
d52 1
d86 2
a87 1
 * assumed that the machine format for signed integers is the same. */
d119 1
a119 1
   /* read the length and the chunk name */
d123 1
a123 1
   /* put the chunk name into png_ptr->chunk_name */
d129 1
a129 1
   /* reset the crc and run it over the chunk name */
d133 1
a133 1
   /* check to see if chunk name is valid */
d143 2
a144 1
   if (png_ptr == NULL) return;
d150 4
a153 3
   are reading a ancillary or critical chunk, and how the program has set
   things up, we may calculate the CRC on the data and print a message.
   Returns '1' if there was a CRC error, '0' otherwise. */
d172 1
a172 1
           !(png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN)) ||
d189 2
a190 1
   the data it has read thus far. */
d223 96
d328 2
a329 2
                              png_size_t chunklength,
                              png_size_t prefix_size, png_size_t *newlength)
d331 2
a332 5
   static const char msg[] = "Error decoding compressed text";
   png_charp text;
   png_size_t text_size;

   if (comp_type == PNG_COMPRESSION_TYPE_BASE)
d334 33
a366 5
      int ret = Z_OK;
      png_ptr->zstream.next_in = (png_bytep)(png_ptr->chunkdata + prefix_size);
      png_ptr->zstream.avail_in = (uInt)(chunklength - prefix_size);
      png_ptr->zstream.next_out = png_ptr->zbuf;
      png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
d368 2
a369 2
      text_size = 0;
      text = NULL;
d371 1
a371 4
      while (png_ptr->zstream.avail_in)
      {
         ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);
         if (ret != Z_OK && ret != Z_STREAM_END)
d373 13
a385 48
            if (png_ptr->zstream.msg != NULL)
               png_warning(png_ptr, png_ptr->zstream.msg);
            else
               png_warning(png_ptr, msg);
            inflateReset(&png_ptr->zstream);
            png_ptr->zstream.avail_in = 0;

            if (text ==  NULL)
            {
               text_size = prefix_size + png_sizeof(msg) + 1;
               text = (png_charp)png_malloc_warn(png_ptr, text_size);
               if (text ==  NULL)
                 {
                    png_free(png_ptr, png_ptr->chunkdata);
                    png_ptr->chunkdata = NULL;
                    png_error(png_ptr, "Not enough memory to decompress chunk");
                 }
               png_memcpy(text, png_ptr->chunkdata, prefix_size);
            }

            text[text_size - 1] = 0x00;

            /* Copy what we can of the error message into the text chunk */
            text_size = (png_size_t)(chunklength -
              (text - png_ptr->chunkdata) - 1);
            if (text_size > png_sizeof(msg))
               text_size = png_sizeof(msg);
            png_memcpy(text + prefix_size, msg, text_size);
            break;
         }
         if (!png_ptr->zstream.avail_out || ret == Z_STREAM_END)
         {
            if (text == NULL)
            {
               text_size = prefix_size +
                   png_ptr->zbuf_size - png_ptr->zstream.avail_out;
               text = (png_charp)png_malloc_warn(png_ptr, text_size + 1);
               if (text ==  NULL)
               {
                  png_free(png_ptr, png_ptr->chunkdata);
                  png_ptr->chunkdata = NULL;
                  png_error(png_ptr,
                    "Not enough memory to decompress chunk.");
               }
               png_memcpy(text + prefix_size, png_ptr->zbuf,
                    text_size - prefix_size);
               png_memcpy(text, png_ptr->chunkdata, prefix_size);
               *(text + text_size) = 0x00;
a386 3
            else
            {
               png_charp tmp;
d388 2
a389 26
               tmp = text;
               text = (png_charp)png_malloc_warn(png_ptr,
                  (png_uint_32)(text_size +
                  png_ptr->zbuf_size - png_ptr->zstream.avail_out + 1));
               if (text == NULL)
               {
                  png_free(png_ptr, tmp);
                  png_free(png_ptr, png_ptr->chunkdata);
                  png_ptr->chunkdata = NULL;
                  png_error(png_ptr,
                    "Not enough memory to decompress chunk..");
               }
               png_memcpy(text, tmp, text_size);
               png_free(png_ptr, tmp);
               png_memcpy(text + text_size, png_ptr->zbuf,
                  (png_ptr->zbuf_size - png_ptr->zstream.avail_out));
               text_size += png_ptr->zbuf_size - png_ptr->zstream.avail_out;
               *(text + text_size) = 0x00;
            }
            if (ret == Z_STREAM_END)
               break;
            else
            {
               png_ptr->zstream.next_out = png_ptr->zbuf;
               png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
            }
a390 14
      }
      if (ret != Z_STREAM_END)
      {
#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)
         char umsg[52];

         if (ret == Z_BUF_ERROR)
            png_snprintf(umsg, 52,
                "Buffer error in compressed datastream in %s chunk",
                png_ptr->chunk_name);
         else if (ret == Z_DATA_ERROR)
            png_snprintf(umsg, 52,
                "Data error in compressed datastream in %s chunk",
                png_ptr->chunk_name);
d392 1
a392 21
            png_snprintf(umsg, 52,
                "Incomplete compressed datastream in %s chunk",
                png_ptr->chunk_name);
         png_warning(png_ptr, umsg);
#else
         png_warning(png_ptr,
            "Incomplete compressed datastream in chunk other than IDAT");
#endif
         text_size = prefix_size;
         if (text ==  NULL)
         {
            text = (png_charp)png_malloc_warn(png_ptr, text_size+1);
            if (text == NULL)
              {
                png_free(png_ptr, png_ptr->chunkdata);
                png_ptr->chunkdata = NULL;
                png_error(png_ptr, "Not enough memory for text.");
              }
            png_memcpy(text, png_ptr->chunkdata, prefix_size);
         }
         *(text + text_size) = 0x00;
d394 1
a395 7
      inflateReset(&png_ptr->zstream);
      png_ptr->zstream.avail_in = 0;

      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = text;
      *newlength=text_size;
   }
d398 1
a398 1
#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)
d401 2
a402 1
      png_snprintf(umsg, 50, "Unknown zTXt compression type %d", comp_type);
d408 20
a427 2
      *(png_ptr->chunkdata + prefix_size) = 0x00;
      *newlength = prefix_size;
d429 2
d434 1
a434 1
/* read and check the IDHR chunk */
d448 1
a448 1
   /* check the length */
d465 1
a465 1
   /* set internal variables */
d471 1
a471 1
#if defined(PNG_MNG_FEATURES_SUPPORTED)
d476 1
a476 1
   /* find number of channels */
d483 1
d487 1
d491 1
d497 1
a497 1
   /* set up other useful info */
d508 1
a508 1
/* read and check the palette */
d514 1
a514 1
#ifndef PNG_NO_POINTER_INDEXING
d522 1
d529 1
d542 1
a542 1
#if !defined(PNG_READ_OPT_PLTE_SUPPORTED)
d558 1
d567 1
a567 1
#ifndef PNG_NO_POINTER_INDEXING
d583 1
a583 1
      /* don't depend upon png_color being any order */
d591 5
a595 4
      whatever the normal CRC configuration tells us.  However, if we
      have an RGB image, the PLTE can be considered ancillary, so
      we will act as though it is. */
#if !defined(PNG_READ_OPT_PLTE_SUPPORTED)
d601 1
a601 1
#if !defined(PNG_READ_OPT_PLTE_SUPPORTED)
d630 1
a630 1
#if defined(PNG_READ_tRNS_SUPPORTED)
d669 1
a669 1
   info_ptr = info_ptr; /* quiet compiler warnings about unused info_ptr */
d672 1
a672 1
#if defined(PNG_READ_gAMA_SUPPORTED)
d697 1
a697 1
#if defined(PNG_READ_sRGB_SUPPORTED)
d719 1
a719 1
   /* check for zero gamma */
d727 1
a727 1
#if defined(PNG_READ_sRGB_SUPPORTED)
d733 1
a733 1
#ifndef PNG_NO_CONSOLE_IO
d753 1
a753 1
#if defined(PNG_READ_sBIT_SUPPORTED)
d819 1
a819 1
#if defined(PNG_READ_cHRM_SUPPORTED)
d847 1
a847 1
#if defined(PNG_READ_sRGB_SUPPORTED)
d899 1
a899 1
#if defined(PNG_READ_sRGB_SUPPORTED)
d913 1
a913 1
#ifndef PNG_NO_CONSOLE_IO
d921 2
a922 1
               int_x_white, int_y_white, int_x_red, int_y_red);
d924 2
a925 1
               int_x_green, int_y_green, int_x_blue, int_y_blue);
d927 1
a927 1
#endif /* PNG_NO_CONSOLE_IO */
d945 1
a945 1
#if defined(PNG_READ_sRGB_SUPPORTED)
d985 1
a985 1
   /* check for bad intent */
d1007 1
a1007 1
#ifndef PNG_NO_CONSOLE_IO
d1043 1
a1043 1
#if defined(PNG_READ_iCCP_SUPPORTED)
d1100 1
a1100 1
      /* empty loop to find end of name */ ;
d1104 3
a1106 2
   /* there should be at least one zero (the compression type byte)
      following the separator, and we should be on it  */
d1115 1
a1115 1
   /* compression_type should always be zero */
d1163 1
a1163 1
#if defined(PNG_READ_sPLT_SUPPORTED)
d1170 1
a1170 1
#ifdef PNG_NO_POINTER_INDEXING
d1179 17
d1229 3
a1231 2
   for (entry_start = (png_bytep)png_ptr->chunkdata; *entry_start; entry_start++)
      /* empty loop to find end of name */ ;
d1234 1
a1234 1
   /* a sample depth should follow the separator, and we should be on it  */
d1247 1
a1247 1
   /* integrity-check the data length */
d1271 1
a1271 1
#ifndef PNG_NO_POINTER_INDEXING
d1274 1
a1274 1
      png_sPLT_entryp pp = new_palette.entries + i;
d1315 1
a1315 1
   /* discard all chunk data except the name and stash that */
d1326 1
a1326 1
#if defined(PNG_READ_tRNS_SUPPORTED)
d1421 1
a1421 1
#if defined(PNG_READ_bKGD_SUPPORTED)
d1510 1
a1510 1
#if defined(PNG_READ_hIST_SUPPORTED)
d1540 2
a1541 3
   num = length / 2 ;
   if (num != (unsigned int) png_ptr->num_palette || num >
      (unsigned int) PNG_MAX_PALETTE_LENGTH)
d1548 2
d1565 1
a1565 1
#if defined(PNG_READ_pHYs_SUPPORTED)
d1608 1
a1608 1
#if defined(PNG_READ_oFFs_SUPPORTED)
d1651 2
a1652 2
#if defined(PNG_READ_pCAL_SUPPORTED)
/* read the pCAL chunk (described in the PNG Extensions document) */
d1699 1
a1699 1
   png_ptr->chunkdata[slength] = 0x00; /* null terminate the last string */
d1703 1
a1703 1
      /* empty loop */ ;
d1785 2
a1786 2
#if defined(PNG_READ_sCAL_SUPPORTED)
/* read the sCAL chunk */
d1818 8
d1832 1
d1845 1
a1845 1
   png_ptr->chunkdata[slength] = 0x00; /* null terminate the last string */
d1847 1
a1847 1
   ep = png_ptr->chunkdata + 1;        /* skip unit byte */
d1854 2
d1864 2
d1868 1
a1868 1
   png_memcpy(swidth, ep, (png_size_t)png_strlen(ep));
d1872 2
a1873 2
   for (ep = png_ptr->chunkdata; *ep; ep++)
      /* empty loop */ ;
d1879 1
a1879 2
#if defined(PNG_FIXED_POINT_SUPPORTED) && \
    !defined(PNG_FLOATING_POINT_SUPPORTED)
d1892 5
d1905 5
d1912 1
a1912 1
   png_memcpy(sheight, ep, (png_size_t)png_strlen(ep));
d1950 1
a1950 1
#if defined(PNG_READ_tIME_SUPPORTED)
d1993 1
a1993 1
#if defined(PNG_READ_tEXt_SUPPORTED)
d2007 16
d2062 1
a2062 1
      /* empty loop to find end of key */ ;
d2096 2
a2097 2
#if defined(PNG_READ_zTXt_SUPPORTED)
/* note: this does not correctly handle chunks that are > 64K under DOS */
d2109 16
d2162 1
a2162 1
      /* empty loop */ ;
d2180 1
a2180 1
       text++;        /* skip the compression_method byte */
d2216 2
a2217 2
#if defined(PNG_READ_iTXt_SUPPORTED)
/* note: this does not correctly handle chunks that are > 64K under DOS */
d2230 16
d2283 2
a2284 2
      /* empty loop */ ;
   lang++;        /* skip NUL separator */
d2287 3
a2289 2
      translated keyword (possibly empty), and possibly some text after the
      keyword */
d2305 2
a2306 2
      /* empty loop */ ;
   lang_key++;        /* skip NUL separator */
d2317 2
a2318 2
      /* empty loop */ ;
   text++;        /* skip NUL separator */
d2374 16
d2394 1
a2394 1
      const PNG_IDAT;
d2396 1
a2396 1
      if (png_memcmp(png_ptr->chunk_name, png_IDAT, 4))  /* not an IDAT */
d2402 1
a2402 1
#if defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)
d2405 1
a2405 1
#if defined(PNG_READ_USER_CHUNKS_SUPPORTED)
d2413 6
a2418 3
#if defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)
   if ((png_ptr->flags & PNG_FLAG_KEEP_UNKNOWN_CHUNKS) ||
       (png_ptr->read_user_chunk_fn != NULL))
d2429 1
a2429 1
                  (png_charp)png_ptr->chunk_name, 
d2431 2
a2432 1
       png_ptr->unknown_chunk.name[png_sizeof(png_ptr->unknown_chunk.name)-1] = '\0';
d2441 1
a2441 1
#if defined(PNG_READ_USER_CHUNKS_SUPPORTED)
d2444 1
a2444 1
          /* callback to user unknown chunk handler */
d2453 1
d2456 1
d2474 2
a2475 2
#if !defined(PNG_READ_USER_CHUNKS_SUPPORTED)
   info_ptr = info_ptr; /* quiet compiler warnings about unused info_ptr */
d2532 1
a2532 1
#if defined(PNG_READ_PACKSWAP_SUPPORTED)
d2587 1
a2587 1
#if defined(PNG_READ_PACKSWAP_SUPPORTED)
d2639 1
a2639 1
#if defined(PNG_READ_PACKSWAP_SUPPORTED)
d2722 4
a2725 4
#ifdef PNG_USE_LOCAL_ARRAYS
   /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */
   /* offset to next interlace block */
   const int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
d2748 1
a2748 1
#if defined(PNG_READ_PACKSWAP_SUPPORTED)
d2801 1
a2801 1
#if defined(PNG_READ_PACKSWAP_SUPPORTED)
d2857 1
a2857 1
#if defined(PNG_READ_PACKSWAP_SUPPORTED)
d2906 2
a2907 1
            png_bytep sp = row + (png_size_t)(row_info->width - 1) * pixel_bytes;
d2932 2
a2933 2
#if !defined(PNG_READ_PACKSWAP_SUPPORTED)
   transformations = transformations; /* silence compiler warning */
d3017 1
a3017 1
         for (i = 0; i < istop; i++)   /* use leftover rp,pp */
d3061 1
a3064 1
#ifdef PNG_USE_LOCAL_ARRAYS
d3066 1
a3066 1
   /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */
d3068 3
a3070 2
   /* start of interlace block */
   const int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
d3072 2
a3073 2
   /* offset to next interlace block */
   const int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
d3075 2
a3076 2
   /* start of interlace block in the y direction */
   const int png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
d3078 3
a3080 2
   /* offset to next interlace block in the y direction */
   const int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
a3081 1
#endif
a3103 3
         png_ptr->irowbytes = PNG_ROWBYTES(png_ptr->pixel_depth,
            png_ptr->iwidth) + 1;

d3125 1
a3125 1
      const PNG_IDAT;
d3162 1
a3162 1
               png_warning(png_ptr, "Extra compressed data");
d3184 1
a3184 1
      png_warning(png_ptr, "Extra compression data");
d3190 1
a3194 1
#ifdef PNG_USE_LOCAL_ARRAYS
d3196 1
a3196 1
   /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */
d3198 3
a3200 2
   /* start of interlace block */
   const int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
d3202 2
a3203 2
   /* offset to next interlace block */
   const int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
d3205 2
a3206 2
   /* start of interlace block in the y direction */
   const int png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
d3208 2
a3209 2
   /* offset to next interlace block in the y direction */
   const int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
a3231 3

         png_ptr->irowbytes =
            PNG_ROWBYTES(png_ptr->pixel_depth, png_ptr->iwidth) + 1;
a3237 1
      png_ptr->irowbytes = png_ptr->rowbytes + 1;
d3241 1
a3241 1
#if defined(PNG_READ_PACK_SUPPORTED)
d3246 1
a3246 1
#if defined(PNG_READ_EXPAND_SUPPORTED)
d3274 1
a3274 1
#if defined(PNG_READ_FILLER_SUPPORTED)
d3296 1
a3296 1
#if defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
d3300 1
a3300 1
#if defined(PNG_READ_EXPAND_SUPPORTED)
d3303 1
a3303 1
#if defined(PNG_READ_FILLER_SUPPORTED)
d3341 3
a3343 2
   /* align the width on the next larger 8 pixels.  Mainly used
      for interlacing */
d3345 3
a3347 2
   /* calculate the maximum bytes needed, adding a byte and a pixel
      for safety's sake */
d3358 11
a3368 3
     png_ptr->big_row_buf = (png_bytep)png_malloc(png_ptr, row_bytes+64);
     png_ptr->row_buf = png_ptr->big_row_buf+32;
     png_ptr->old_big_row_buf_size = row_bytes+64;
d3372 1
a3372 1
   if ((png_uint_32)png_ptr->rowbytes + 1 > (png_uint_32)65536L)
d3375 1
a3375 1
   if ((png_uint_32)png_ptr->rowbytes > (png_uint_32)(PNG_SIZE_MAX - 1))
d3378 1
a3378 1
   if (png_ptr->rowbytes+1 > png_ptr->old_prev_row_size)
d3380 5
a3384 4
     png_free(png_ptr, png_ptr->prev_row);
     png_ptr->prev_row = (png_bytep)png_malloc(png_ptr, (png_uint_32)(
        png_ptr->rowbytes + 1));
     png_ptr->old_prev_row_size = png_ptr->rowbytes+1;
d3387 1
a3387 1
   png_memset_check(png_ptr, png_ptr->prev_row, 0, png_ptr->rowbytes + 1);
d3394 2
a3395 1
   png_debug1(3, "irowbytes = %lu", png_ptr->irowbytes);
@


1.9
log
@merge
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.33 [October 31, 2008]
d96 1
a96 1
   png_debug2(0, "Reading %s chunk, length = %lu\n",
d373 1
a373 1
   png_debug(1, "in png_handle_IHDR\n");
d428 3
a430 3
   png_debug1(3, "bit_depth = %d\n", png_ptr->bit_depth);
   png_debug1(3, "channels = %d\n", png_ptr->channels);
   png_debug1(3, "rowbytes = %lu\n", png_ptr->rowbytes);
d445 1
a445 1
   png_debug(1, "in png_handle_PLTE\n");
d577 1
a577 1
   png_debug(1, "in png_handle_IEND\n");
d605 1
a605 1
   png_debug(1, "in png_handle_gAMA\n");
d657 1
a657 1
         fprintf(stderr, "gamma = (%d/100000)\n", (int)igamma);
d683 1
a683 1
   png_debug(1, "in png_handle_sBIT\n");
d755 1
a755 1
   png_debug(1, "in png_handle_cHRM\n");
a792 6
   if (uint_x > 80000L || uint_y > 80000L ||
      uint_x + uint_y > 100000L)
   {
      png_warning(png_ptr, "Invalid cHRM white point");
      return;
   }
a797 5
   if (uint_x + uint_y > 100000L)
   {
      png_warning(png_ptr, "Invalid cHRM red point");
      return;
   }
a802 5
   if (uint_x + uint_y > 100000L)
   {
      png_warning(png_ptr, "Invalid cHRM green point");
      return;
   }
a807 5
   if (uint_x + uint_y > 100000L)
   {
      png_warning(png_ptr, "Invalid cHRM blue point");
      return;
   }
d873 1
a873 1
   png_debug(1, "in png_handle_sRGB\n");
d976 1
a976 1
   png_debug(1, "in png_handle_iCCP\n");
d1097 2
a1098 1
   png_debug(1, "in png_handle_sPLT\n");
d1234 1
a1234 1
   png_debug(1, "in png_handle_tRNS\n");
d1330 1
a1330 1
   png_debug(1, "in png_handle_bKGD\n");
d1381 1
a1381 1
          if (buf[0] > info_ptr->num_palette)
d1419 1
a1419 1
   png_debug(1, "in png_handle_hIST\n");
d1474 1
a1474 1
   png_debug(1, "in png_handle_pHYs\n");
d1517 1
a1517 1
   png_debug(1, "in png_handle_oFFs\n");
d1564 1
a1564 1
   png_debug(1, "in png_handle_pCAL\n");
d1581 1
a1581 1
   png_debug1(2, "Allocating and reading pCAL chunk data (%lu bytes)\n",
d1602 1
a1602 1
   png_debug(3, "Finding end of pCAL purpose string\n");
d1618 1
a1618 1
   png_debug(3, "Reading pCAL X0, X1, type, nparams, and units\n");
d1625 1
a1625 1
   png_debug(3, "Checking pCAL equation type and number of parameters\n");
d1646 1
a1646 1
   png_debug(3, "Allocating pCAL parameters array\n");
d1662 1
a1662 1
      png_debug1(3, "Reading pCAL parameter %d\n", i);
d1702 1
a1702 1
   png_debug(1, "in png_handle_sCAL\n");
d1719 1
a1719 1
   png_debug1(2, "Allocating and reading sCAL chunk data (%lu bytes)\n",
d1836 1
a1836 1
   png_debug(1, "in png_handle_tIME\n");
d1884 2
a1885 1
   png_debug(1, "in png_handle_tEXt\n");
d1903 1
d1921 1
d1970 3
a1972 1
   png_debug(1, "in png_handle_zTXt\n");
d2075 2
a2076 1
   png_debug(1, "in png_handle_iTXt\n");
d2202 2
a2203 1
   png_debug(1, "in png_handle_unknown\n");
d2298 1
a2298 1
   png_debug(1, "in png_check_chunk_name\n");
d2320 1
a2320 1
   png_debug(1, "in png_combine_row\n");
d2536 1
a2536 1
   png_debug(1, "in png_do_read_interlace\n");
d2749 2
a2750 2
   png_debug(1, "in png_read_filter_row\n");
   png_debug2(2, "row = %lu, filter = %d\n", png_ptr->row_number, filter);
d2889 1
a2889 1
   png_debug(1, "in png_read_finish_row\n");
d3024 1
a3024 1
   png_debug(1, "in png_read_start_row\n");
d3190 6
a3195 6
   png_debug1(3, "width = %lu,\n", png_ptr->width);
   png_debug1(3, "height = %lu,\n", png_ptr->height);
   png_debug1(3, "iwidth = %lu,\n", png_ptr->iwidth);
   png_debug1(3, "num_rows = %lu\n", png_ptr->num_rows);
   png_debug1(3, "rowbytes = %lu,\n", png_ptr->rowbytes);
   png_debug1(3, "irowbytes = %lu,\n", png_ptr->irowbytes);
@


1.8
log
@merge libpng upgrade

major version bump because function signature of png_decompress_chunk
changed (return value to void)
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.31 [August 19, 2008]
d1921 3
a1923 2
   key = (png_charp)png_malloc_warn(png_ptr, length + 1);
   if (key == NULL)
d1929 1
a1929 1
   png_crc_read(png_ptr, (png_bytep)key, slength);
d1933 2
a1934 1
      png_free(png_ptr, key);
d1938 1
d1952 2
a1953 1
     png_free(png_ptr, key);
d1968 2
a1969 1
   png_free(png_ptr, key);
d2005 1
a2005 1
   png_free(png_ptr,png_ptr->chunkdata);
@


1.7
log
@fastmerge
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.26 [April 2, 2008]
a15 1

d29 1
d31 7
d80 29
d113 1
a113 1
   if(png_ptr == NULL) return;
d197 1
a197 1
png_charp /* PRIVATE */
d199 1
a199 1
                              png_charp chunkdata, png_size_t chunklength,
d209 1
a209 1
      png_ptr->zstream.next_in = (png_bytep)(chunkdata + prefix_size);
d235 3
a237 2
                    png_free(png_ptr,chunkdata);
                    png_error(png_ptr,"Not enough memory to decompress chunk");
d239 1
a239 1
               png_memcpy(text, chunkdata, prefix_size);
d245 4
a248 3
            text_size = (png_size_t)(chunklength - (text - chunkdata) - 1);
            text_size = png_sizeof(msg) > text_size ? text_size :
               png_sizeof(msg);
d260 6
a265 4
                 {
                    png_free(png_ptr,chunkdata);
                    png_error(png_ptr,"Not enough memory to decompress chunk.");
                 }
d268 1
a268 1
               png_memcpy(text, chunkdata, prefix_size);
d282 4
a285 2
                  png_free(png_ptr, chunkdata);
                  png_error(png_ptr,"Not enough memory to decompress chunk..");
d325 1
a325 1
         text_size=prefix_size;
d331 3
a333 2
                png_free(png_ptr, chunkdata);
                png_error(png_ptr,"Not enough memory for text.");
d335 1
a335 1
            png_memcpy(text, chunkdata, prefix_size);
d343 2
a344 2
      png_free(png_ptr, chunkdata);
      chunkdata = text;
d352 1
a352 2
      png_snprintf(umsg, 50,
         "Unknown zTXt compression type %d", comp_type);
d358 2
a359 2
      *(chunkdata + prefix_size) = 0x00;
      *newlength=prefix_size;
a360 2

   return chunkdata;
d427 4
a430 4
   png_ptr->rowbytes = PNG_ROWBYTES(png_ptr->pixel_depth,png_ptr->width);
   png_debug1(3,"bit_depth = %d\n", png_ptr->bit_depth);
   png_debug1(3,"channels = %d\n", png_ptr->channels);
   png_debug1(3,"rowbytes = %lu\n", png_ptr->rowbytes);
d592 1
a592 1
   info_ptr =info_ptr; /* quiet compiler warnings about unused info_ptr */
d746 1
a746 1
   png_byte buf[4];
d787 4
a790 1
   png_crc_read(png_ptr, buf, 4);
d792 1
a792 4

   png_crc_read(png_ptr, buf, 4);
   uint_y = png_get_uint_32(buf);

a796 1
      png_crc_finish(png_ptr, 24);
d802 2
a803 6
   png_crc_read(png_ptr, buf, 4);
   uint_x = png_get_uint_32(buf);

   png_crc_read(png_ptr, buf, 4);
   uint_y = png_get_uint_32(buf);

a806 1
      png_crc_finish(png_ptr, 16);
d812 2
a813 6
   png_crc_read(png_ptr, buf, 4);
   uint_x = png_get_uint_32(buf);

   png_crc_read(png_ptr, buf, 4);
   uint_y = png_get_uint_32(buf);

a816 1
      png_crc_finish(png_ptr, 8);
d822 2
a823 6
   png_crc_read(png_ptr, buf, 4);
   uint_x = png_get_uint_32(buf);

   png_crc_read(png_ptr, buf, 4);
   uint_y = png_get_uint_32(buf);

a826 1
      png_crc_finish(png_ptr, 0);
d859 1
a859 1
            fprintf(stderr,"wx=%f, wy=%f, rx=%f, ry=%f\n",
d861 1
a861 1
            fprintf(stderr,"gx=%f, gy=%f, bx=%f, by=%f\n",
d864 1
a864 1
            fprintf(stderr,"wx=%ld, wy=%ld, rx=%ld, ry=%ld\n",
d866 1
a866 1
            fprintf(stderr,"gx=%ld, gy=%ld, bx=%ld, by=%ld\n",
a870 1
         png_crc_finish(png_ptr, 0);
a883 2
   if (png_crc_finish(png_ptr, 0))
      return;
d951 2
a952 1
         fprintf(stderr,"incorrect gamma=(%d/100000)\n",(int)png_ptr->int_gamma);
d955 1
a955 1
         fprintf(stderr,"incorrect gamma=%f\n",png_ptr->gamma);
a989 1
   png_charp chunkdata;
d1027 2
a1028 1
   chunkdata = (png_charp)png_malloc(png_ptr, length + 1);
d1030 1
a1030 1
   png_crc_read(png_ptr, (png_bytep)chunkdata, slength);
d1034 2
a1035 1
      png_free(png_ptr, chunkdata);
d1039 1
a1039 1
   chunkdata[slength] = 0x00;
d1041 1
a1041 1
   for (profile = chunkdata; *profile; profile++)
d1048 1
a1048 1
   if ( profile >= chunkdata + slength - 1)
d1050 2
a1051 1
      png_free(png_ptr, chunkdata);
d1061 1
a1061 1
      compression_type=0x00;  /* Reset it to zero (libpng-1.0.6 through 1.0.8
d1065 3
a1067 3
   prefix_length = profile - chunkdata;
   chunkdata = png_decompress_chunk(png_ptr, compression_type, chunkdata,
                                    slength, prefix_length, &data_length);
d1073 2
a1074 1
      png_free(png_ptr, chunkdata);
d1080 5
a1084 5
   pC = (png_bytep)(chunkdata+prefix_length);
   profile_size = ((*(pC  ))<<24) |
                  ((*(pC+1))<<16) |
                  ((*(pC+2))<< 8) |
                  ((*(pC+3))    );
d1086 1
a1086 1
   if(profile_size < profile_length)
d1089 1
a1089 1
   if(profile_size > profile_length)
d1091 2
a1092 1
      png_free(png_ptr, chunkdata);
d1097 4
a1100 3
   png_set_iCCP(png_ptr, info_ptr, chunkdata, compression_type,
                chunkdata + prefix_length, profile_length);
   png_free(png_ptr, chunkdata);
a1108 1
   png_bytep chunkdata;
d1138 2
a1139 1
   chunkdata = (png_bytep)png_malloc(png_ptr, length + 1);
d1141 1
a1141 1
   png_crc_read(png_ptr, (png_bytep)chunkdata, slength);
d1145 2
a1146 1
      png_free(png_ptr, chunkdata);
d1150 1
a1150 1
   chunkdata[slength] = 0x00;
d1152 1
a1152 1
   for (entry_start = chunkdata; *entry_start; entry_start++)
d1157 1
a1157 1
   if (entry_start > chunkdata + slength - 2)
d1159 2
a1160 1
      png_free(png_ptr, chunkdata);
d1167 1
a1167 1
   data_length = (slength - (entry_start - chunkdata));
d1172 2
a1173 1
      png_free(png_ptr, chunkdata);
d1179 2
a1180 2
   if ((png_uint_32) new_palette.nentries > (png_uint_32) (PNG_SIZE_MAX /
       png_sizeof(png_sPLT_entry)))
d1238 1
a1238 1
   new_palette.name = (png_charp)chunkdata;
d1242 2
a1243 1
   png_free(png_ptr, chunkdata);
a1252 1
   int bit_mask;
a1255 5
   /* For non-indexed color, mask off any bits in the tRNS value that
    * exceed the bit depth.  Some creators were writing extra bits there.
    * This is not needed for indexed color. */
   bit_mask = (1 << png_ptr->bit_depth) - 1;

d1284 1
a1284 1
      png_ptr->trans_values.gray = png_get_uint_16(buf) & bit_mask;
d1298 3
a1300 3
      png_ptr->trans_values.red = png_get_uint_16(buf) & bit_mask;
      png_ptr->trans_values.green = png_get_uint_16(buf + 2) & bit_mask;
      png_ptr->trans_values.blue = png_get_uint_16(buf + 4) & bit_mask;
d1401 1
a1401 1
          if(buf[0] > info_ptr->num_palette)
a1576 1
   png_charp purpose;
d1603 3
a1605 2
   purpose = (png_charp)png_malloc_warn(png_ptr, length + 1);
   if (purpose == NULL)
d1611 1
a1611 1
   png_crc_read(png_ptr, (png_bytep)purpose, slength);
d1615 2
a1616 1
      png_free(png_ptr, purpose);
d1620 1
a1620 1
   purpose[slength] = 0x00; /* null terminate the last string */
d1623 1
a1623 1
   for (buf = purpose; *buf; buf++)
d1626 1
a1626 1
   endptr = purpose + slength;
d1633 2
a1634 1
      png_free(png_ptr, purpose);
d1654 2
a1655 1
      png_free(png_ptr, purpose);
d1667 2
a1668 2
   params = (png_charpp)png_malloc_warn(png_ptr, (png_uint_32)(nparams
      *png_sizeof(png_charp))) ;
d1671 2
a1672 1
       png_free(png_ptr, purpose);
d1690 2
a1691 1
         png_free(png_ptr, purpose);
d1697 1
a1697 1
   png_set_pCAL(png_ptr, info_ptr, purpose, X0, X1, type, nparams,
d1700 2
a1701 1
   png_free(png_ptr, purpose);
d1711 1
a1711 1
   png_charp buffer, ep;
d1741 6
a1746 6
   buffer = (png_charp)png_malloc_warn(png_ptr, length + 1);
   if (buffer == NULL)
     {
       png_warning(png_ptr, "Out of memory while processing sCAL chunk");
       return;
     }
d1748 1
a1748 1
   png_crc_read(png_ptr, (png_bytep)buffer, slength);
d1752 2
a1753 1
      png_free(png_ptr, buffer);
d1757 1
a1757 1
   buffer[slength] = 0x00; /* null terminate the last string */
d1759 1
a1759 1
   ep = buffer + 1;        /* skip unit byte */
d1765 2
a1766 2
       png_warning(png_ptr, "malformed width string in sCAL chunk");
       return;
d1772 4
a1775 4
     {
       png_warning(png_ptr, "Out of memory while processing sCAL chunk width");
       return;
     }
d1780 1
a1780 1
   for (ep = buffer; *ep; ep++)
d1784 1
a1784 1
   if (buffer + slength < ep)
d1786 1
a1786 1
       png_warning(png_ptr, "Truncated sCAL chunk");
d1789 1
a1789 1
       png_free(png_ptr, swidth);
d1791 3
a1793 2
      png_free(png_ptr, buffer);
       return;
d1800 2
a1801 2
       png_warning(png_ptr, "malformed height string in sCAL chunk");
       return;
d1807 4
a1810 4
     {
       png_warning(png_ptr, "Out of memory while processing sCAL chunk height");
       return;
     }
d1815 1
a1815 1
   if (buffer + slength < ep
d1822 2
a1823 1
      png_free(png_ptr, buffer);
d1833 1
a1833 1
   png_set_sCAL(png_ptr, info_ptr, buffer[0], width, height);
d1836 1
a1836 1
   png_set_sCAL_s(png_ptr, info_ptr, buffer[0], swidth, sheight);
d1840 2
a1841 1
   png_free(png_ptr, buffer);
d1962 1
a1962 1
   ret=png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
a1976 1
   png_charp chunkdata;
d1994 1
a1994 1
     png_warning(png_ptr,"zTXt chunk too large to fit in memory");
d2000 3
a2002 2
   chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);
   if (chunkdata == NULL)
d2004 1
a2004 1
     png_warning(png_ptr,"Out of memory processing zTXt chunk.");
d2008 1
a2008 1
   png_crc_read(png_ptr, (png_bytep)chunkdata, slength);
d2011 2
a2012 1
      png_free(png_ptr, chunkdata);
d2016 1
a2016 1
   chunkdata[slength] = 0x00;
d2018 1
a2018 1
   for (text = chunkdata; *text; text++)
d2022 1
a2022 1
   if (text >= chunkdata + slength - 2)
d2025 2
a2026 1
      png_free(png_ptr, chunkdata);
d2039 1
a2039 1
   prefix_len = text - chunkdata;
d2041 2
a2042 2
   chunkdata = (png_charp)png_decompress_chunk(png_ptr, comp_type, chunkdata,
                                    (png_size_t)length, prefix_len, &data_len);
d2045 1
a2045 1
     (png_uint_32)png_sizeof(png_text));
d2048 3
a2050 2
     png_warning(png_ptr,"Not enough memory to process zTXt chunk.");
     png_free(png_ptr, chunkdata);
d2054 1
a2054 1
   text_ptr->key = chunkdata;
d2060 1
a2060 1
   text_ptr->text = chunkdata + prefix_len;
d2063 1
a2063 1
   ret=png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
d2066 2
a2067 1
   png_free(png_ptr, chunkdata);
a2078 1
   png_charp chunkdata;
d2098 1
a2098 1
     png_warning(png_ptr,"iTXt chunk too large to fit in memory");
d2104 3
a2106 2
   chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);
   if (chunkdata == NULL)
d2112 1
a2112 1
   png_crc_read(png_ptr, (png_bytep)chunkdata, slength);
d2115 2
a2116 1
      png_free(png_ptr, chunkdata);
d2120 1
a2120 1
   chunkdata[slength] = 0x00;
d2122 1
a2122 1
   for (lang = chunkdata; *lang; lang++)
d2130 1
a2130 1
   if (lang >= chunkdata + slength - 3)
d2133 2
a2134 1
      png_free(png_ptr, chunkdata);
d2147 1
a2147 1
   if (lang_key >= chunkdata + slength)
d2150 2
a2151 1
      png_free(png_ptr, chunkdata);
d2158 1
a2158 1
   if (text >= chunkdata + slength)
d2161 2
a2162 1
      png_free(png_ptr, chunkdata);
d2166 1
a2166 1
   prefix_len = text - chunkdata;
d2168 1
a2168 1
   key=chunkdata;
d2170 2
a2171 2
       chunkdata = png_decompress_chunk(png_ptr, comp_type, chunkdata,
          (size_t)length, prefix_len, &data_len);
d2173 1
a2173 1
       data_len=png_strlen(chunkdata + prefix_len);
d2178 3
a2180 2
     png_warning(png_ptr,"Not enough memory to process iTXt chunk.");
     png_free(png_ptr, chunkdata);
d2184 2
a2185 2
   text_ptr->lang_key = chunkdata+(lang_key-key);
   text_ptr->lang = chunkdata+(lang-key);
d2188 2
a2189 2
   text_ptr->key = chunkdata;
   text_ptr->text = chunkdata + prefix_len;
d2191 1
a2191 1
   ret=png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
d2194 2
a2195 1
   png_free(png_ptr, chunkdata);
a2221 2
   png_check_chunk_name(png_ptr, png_ptr->chunk_name);

d2225 1
a2225 1
      if(png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
a2250 1
       png_ptr->unknown_chunk.data = (png_bytep)png_malloc(png_ptr, length);
d2252 7
a2258 1
       png_crc_read(png_ptr, (png_bytep)png_ptr->unknown_chunk.data, length);
d2260 1
a2260 1
       if(png_ptr->read_user_chunk_fn != NULL)
d2271 1
a2271 1
                if(png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
d2280 1
a2280 1
         png_set_unknown_chunks(png_ptr, info_ptr, &png_ptr->unknown_chunk, 1);
d2328 1
a2328 1
   png_debug(1,"in png_combine_row\n");
d2544 1
a2544 1
   png_debug(1,"in png_do_read_interlace\n");
d2745 1
a2745 1
      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,final_width);
d2758 1
a2758 1
   png_debug2(2,"row = %lu, filter = %d\n", png_ptr->row_number, filter);
d2862 1
a2862 1
            p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;
d2871 1
a2871 1
         *row=0;
d2949 1
a2949 1
      for(;;)
d3030 1
a3030 1
   png_uint_32 row_bytes;
d3049 2
a3050 5
         row_bytes = PNG_ROWBYTES(png_ptr->pixel_depth,png_ptr->iwidth) + 1;

         png_ptr->irowbytes = (png_size_t)row_bytes;
         if((png_uint_32)png_ptr->irowbytes != row_bytes)
            png_error(png_ptr, "Rowbytes overflow in png_read_start_row");
d3152 1
a3152 1
   if(png_ptr->transformations & PNG_USER_TRANSFORM)
d3154 1
a3154 1
       int user_pixel_depth=png_ptr->user_transform_depth*
d3156 1
a3156 1
       if(user_pixel_depth > max_pixel_depth)
d3166 1
a3166 1
   row_bytes = PNG_ROWBYTES(max_pixel_depth,row_bytes) +
d3173 1
a3173 1
   if(row_bytes + 64 > png_ptr->old_big_row_buf_size)
d3175 1
a3175 2
     if (png_ptr->big_row_buf)
        png_free(png_ptr,png_ptr->big_row_buf);
d3188 1
a3188 1
   if(png_ptr->rowbytes+1 > png_ptr->old_prev_row_size)
d3190 1
a3190 2
     if (png_ptr->prev_row)
        png_free(png_ptr,png_ptr->prev_row);
@


1.6
log
@merge and fix for __CRAZY=Yes
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.25 [February 18, 2008]
d2832 1
d2846 1
d2854 1
d2889 1
d2964 1
d2979 1
d2987 1
d3008 1
d3127 9
a3135 2
   png_ptr->big_row_buf = (png_bytep)png_malloc(png_ptr, row_bytes+64);
   png_ptr->row_buf = png_ptr->big_row_buf+32;
d3143 9
a3151 2
   png_ptr->prev_row = (png_bytep)png_malloc(png_ptr, (png_uint_32)(
      png_ptr->rowbytes + 1));
@


1.5
log
@merge and validate
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.17 May 15, 2007
d6 1
a6 1
 * Copyright (c) 1998-2007 Glenn Randers-Pehrson
d19 4
d166 1
a166 1
   const static char msg[] = "Error decoding compressed text";
d211 1
a211 1
            png_memcpy(text + prefix_size, msg, text_size + 1);
d267 2
a268 1
            sprintf(umsg,"Buffer error in compressed datastream in %s chunk",
d271 2
a272 1
            sprintf(umsg,"Data error in compressed datastream in %s chunk",
d275 2
a276 1
            sprintf(umsg,"Incomplete compressed datastream in %s chunk",
d309 2
a310 1
      sprintf(umsg, "Unknown zTXt compression type %d", comp_type);
d552 1
a552 2
   if (&info_ptr == NULL) /* quiet compiler warnings about unused info_ptr */
      return;
d1025 1
a1025 1
   if ( profile >= chunkdata + slength)
d1129 1
a1129 1
   if (entry_start > chunkdata + slength)
d1222 1
d1226 5
d1259 1
a1259 1
      png_ptr->trans_values.gray = png_get_uint_16(buf);
d1273 3
a1275 3
      png_ptr->trans_values.red = png_get_uint_16(buf);
      png_ptr->trans_values.green = png_get_uint_16(buf + 2);
      png_ptr->trans_values.blue = png_get_uint_16(buf + 4);
d1374 1
a1374 1
      if(info_ptr->num_palette)
d1654 1
a1654 1
      for (params[i] = buf; *buf != 0x00 && buf <= endptr; buf++)
d1752 11
d1773 1
a1773 1
   if (swidth == NULL)
d1986 1
a1986 1
   if (text == chunkdata + slength)
d1988 3
a1990 2
      comp_type = PNG_TEXT_COMPRESSION_NONE;
      png_warning(png_ptr, "Zero length zTXt chunk");
d2090 1
a2090 1
   if (lang >= chunkdata + slength)
d2092 3
a2094 2
      comp_flag = PNG_TEXT_COMPRESSION_NONE;
      png_warning(png_ptr, "Zero length iTXt chunk");
d2106 7
d2116 6
d2171 1
a2171 1
      PNG_IDAT;
d2204 4
a2207 2
       png_strcpy((png_charp)png_ptr->unknown_chunk.name,
         (png_charp)png_ptr->chunk_name);
d2230 1
a2230 2
#else
       png_set_unknown_chunks(png_ptr, info_ptr, &png_ptr->unknown_chunk, 1);
d2232 1
d2243 1
a2243 2
   if (&info_ptr == NULL) /* quiet compiler warnings about unused info_ptr */
      return;
d2276 1
a2276 1
#ifndef PNG_HAVE_MMX_COMBINE_ROW
a2476 1
#endif /* !PNG_HAVE_MMX_COMBINE_ROW */
a2478 1
#ifndef PNG_HAVE_MMX_READ_INTERLACE   /* else in pngvcrd.c, pnggccrd.c */
d2496 1
a2496 1
   png_debug(1,"in png_do_read_interlace (stock C version)\n");
d2700 1
a2700 2
   if (&transformations == NULL) /* silence compiler warning */
      return;
a2702 1
#endif /* !PNG_HAVE_MMX_READ_INTERLACE */
a2704 1
#ifndef PNG_HAVE_MMX_READ_FILTER_ROW
a2826 1
#endif /* !PNG_HAVE_MMX_READ_FILTER_ROW */
d2855 2
a2856 1
      png_memset_check(png_ptr, png_ptr->prev_row, 0, png_ptr->rowbytes + 1);
d2890 1
a2890 1
      PNG_IDAT;
d2911 1
a2911 1
               if (png_memcmp(png_ptr->chunk_name, (png_bytep)png_IDAT, 4))
a3120 3
#if defined(PNG_DEBUG) && defined(PNG_USE_PNGGCCRD)
   png_ptr->row_buf_size = row_bytes;
#endif
@


1.4
log
@merge libpng-1.2.12
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.11 June 4, 2006
d6 1
a6 1
 * Copyright (c) 1998-2006 Glenn Randers-Pehrson
d19 4
d73 1
d162 1
a162 1
   static char msg[] = "Error decoding compressed text";
d1295 2
d1298 1
d1717 1
a1717 1
   width = strtod(ep, &vp);
d1740 1
a1740 1
   height = strtod(ep, &vp);
a2156 2
       png_unknown_chunk chunk;

d2165 5
a2169 4
       png_strcpy((png_charp)chunk.name, (png_charp)png_ptr->chunk_name);
       chunk.data = (png_bytep)png_malloc(png_ptr, length);
       chunk.size = (png_size_t)length;
       png_crc_read(png_ptr, (png_bytep)chunk.data, length);
d2174 6
a2179 1
          if ((*(png_ptr->read_user_chunk_fn)) (png_ptr, &chunk) <= 0)
a2183 2
                 {
                   png_free(png_ptr, chunk.data);
d2185 2
a2186 2
                 }
             png_set_unknown_chunks(png_ptr, info_ptr, &chunk, 1);
d2189 2
a2190 1
       else
d2192 2
a2193 2
          png_set_unknown_chunks(png_ptr, info_ptr, &chunk, 1);
       png_free(png_ptr, chunk.data);
d2236 1
a2236 1
#ifndef PNG_HAVE_ASSEMBLER_COMBINE_ROW
d2437 1
a2437 1
#endif /* !PNG_HAVE_ASSEMBLER_COMBINE_ROW */
d2440 1
a2440 1
#ifndef PNG_HAVE_ASSEMBLER_READ_INTERLACE   /* else in pngvcrd.c, pnggccrd.c */
d2666 1
a2666 1
#endif /* !PNG_HAVE_ASSEMBLER_READ_INTERLACE */
d2669 1
a2669 1
#ifndef PNG_HAVE_ASSEMBLER_READ_FILTER_ROW
d2792 1
a2792 1
#endif /* !PNG_HAVE_ASSEMBLER_READ_FILTER_ROW */
d3094 1
a3094 1
   if ((png_uint_32)png_ptr->rowbytes > PNG_SIZE_MAX - 1)
@


1.3
log
@sync, fix CPPFLAGS
no shlib vsn change (only change local data->rodata, no external syms)
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.9 April 14, 2006
d255 1
a255 1
         char umsg[50];
d808 1
a808 1
   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sRGB))
a818 1

@


1.2
log
@merge src/lib
@
text
@d1 1
d4 1
a4 1
 * libpng version 1.2.8 - December 3, 2004
d6 1
a6 1
 * Copyright (c) 1998-2004 Glenn Randers-Pehrson
d17 3
a19 1
png_uint_32 /* PRIVATE */
d24 1
a24 1
     png_error(png_ptr, "PNG unsigned integer out of range.\n");
d29 1
a29 1
png_uint_32 /* PRIVATE */
a39 1
#if defined(PNG_READ_pCAL_SUPPORTED) || defined(PNG_READ_oFFs_SUPPORTED)
d43 1
a43 1
png_int_32 /* PRIVATE */
a52 1
#endif /* PNG_READ_pCAL_SUPPORTED */
d55 1
a55 1
png_uint_16 /* PRIVATE */
d599 1
a599 1
   if (info_ptr->valid & PNG_INFO_sRGB)
d757 1
a757 2
   if (uint_x > 80000L || uint_y > 80000L ||
      uint_x + uint_y > 100000L)
d772 1
a772 2
   if (uint_x > 80000L || uint_y > 80000L ||
      uint_x + uint_y > 100000L)
d787 1
a787 2
   if (uint_x > 80000L || uint_y > 80000L ||
      uint_x + uint_y > 100000L)
d808 1
a808 1
   if (info_ptr->valid & PNG_INFO_sRGB)
d903 1
a903 1
   if ((info_ptr->valid & PNG_INFO_gAMA))
d932 1
a932 1
   if (info_ptr->valid & PNG_INFO_cHRM)
d1056 1
a1056 1
      png_warning(png_ptr, "Ignoring truncated iCCP profile.\n");
d1137 1
a1137 1
   new_palette.nentries = (png_uint_32) (data_length / entry_size);
d2147 2
a2148 1
   if (png_ptr->flags & PNG_FLAG_KEEP_UNKNOWN_CHUNKS)
d3100 1
@


1.1
log
@Initial revision
@
text
@a15 24
#if defined(_WIN32_WCE)
/* strtod() function is not supported on WindowsCE */
#  ifdef PNG_FLOATING_POINT_SUPPORTED
__inline double strtod(const char *nptr, char **endptr)
{
   double result = 0;
   int len;
   wchar_t *str, *end;

   len = MultiByteToWideChar(CP_ACP, 0, nptr, -1, NULL, 0);
   str = (wchar_t *)malloc(len * sizeof(wchar_t));
   if ( NULL != str )
   {
      MultiByteToWideChar(CP_ACP, 0, nptr, -1, str, len);
      result = wcstod(str, &end);
      len = WideCharToMultiByte(CP_ACP, 0, end, -1, NULL, 0, NULL, NULL);
      *endptr = (char *)nptr + (png_strlen(nptr) - len + 1);
      free(str);
   }
   return result;
}
#  endif
#endif

@


1.1.107.1
log
@libpng-1_2_8 with the following directories removed:
- contrib
- projects
- scripts
@
text
@@


1.1.107.2
log
@there's a newer libpng out there
@
text
@a0 1

d3 1
a3 1
 * Last changed in libpng 1.2.9 April 14, 2006
d5 1
a5 1
 * Copyright (c) 1998-2006 Glenn Randers-Pehrson
a15 2
#if defined(PNG_READ_SUPPORTED)

d40 1
a40 1
png_uint_32 PNGAPI
d45 1
a45 1
     png_error(png_ptr, "PNG unsigned integer out of range.");
d50 1
a50 1
png_uint_32 PNGAPI
d61 1
d65 1
a65 1
png_int_32 PNGAPI
d75 1
d78 1
a78 1
png_uint_16 PNGAPI
d622 1
a622 1
   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sRGB))
d780 2
a781 1
   if (uint_x + uint_y > 100000L)
d796 2
a797 1
   if (uint_x + uint_y > 100000L)
d812 2
a813 1
   if (uint_x + uint_y > 100000L)
d834 1
a834 1
   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sRGB))
d929 1
a929 1
   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_gAMA))
d958 1
a958 1
   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM))
d1082 1
a1082 1
      png_warning(png_ptr, "Ignoring truncated iCCP profile.");
d1163 1
a1163 1
   new_palette.nentries = (png_int_32) ( data_length / entry_size);
d2173 1
a2173 2
   if ((png_ptr->flags & PNG_FLAG_KEEP_UNKNOWN_CHUNKS) ||
       (png_ptr->read_user_chunk_fn != NULL))
a3124 1
#endif /* PNG_READ_SUPPORTED */
@


1.1.107.3
log
@Import libpng 1.2.12, fixes at least three vulnerabilities
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.11 June 4, 2006
d279 1
a279 1
         char umsg[52];
d832 1
a832 1
   if ((info_ptr != NULL) && (info_ptr->valid & PNG_INFO_sRGB))
d843 1
@


1.1.107.4
log
@Upgrade libpng (fixes some holes)
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.17 May 15, 2007
d6 1
a6 1
 * Copyright (c) 1998-2007 Glenn Randers-Pehrson
d19 1
a19 2
#ifdef PNG_FLOATING_POINT_SUPPORTED
#  if defined(_WIN32_WCE)
d21 2
a22 1
__inline double png_strtod(png_structp png_ptr, const char *nptr, char **endptr)
d29 1
a29 1
   str = (wchar_t *)png_malloc(png_ptr, len * sizeof(wchar_t));
d36 1
a36 1
      png_free(str);
a39 2
#  else
#    define png_strtod(p,a,b) strtod(a,b)
a92 1
   if(png_ptr == NULL) return;
d181 1
a181 1
   const static char msg[] = "Error decoding compressed text";
a1313 2
   {
      png_ptr->num_trans = 0;
a1314 1
   }
d1733 1
a1733 1
   width = png_strtod(png_ptr, ep, &vp);
d1756 1
a1756 1
   height = png_strtod(png_ptr, ep, &vp);
d2173 2
d2183 4
a2186 5
       png_strcpy((png_charp)png_ptr->unknown_chunk.name,
         (png_charp)png_ptr->chunk_name);
       png_ptr->unknown_chunk.data = (png_bytep)png_malloc(png_ptr, length);
       png_ptr->unknown_chunk.size = (png_size_t)length;
       png_crc_read(png_ptr, (png_bytep)png_ptr->unknown_chunk.data, length);
d2191 1
a2191 6
          int ret;
          ret = (*(png_ptr->read_user_chunk_fn))
            (png_ptr, &png_ptr->unknown_chunk);
          if (ret < 0)
             png_chunk_error(png_ptr, "error in user chunk");
          if (ret == 0)
d2196 2
d2199 2
a2200 2
             png_set_unknown_chunks(png_ptr, info_ptr,
               &png_ptr->unknown_chunk, 1);
d2203 1
a2203 2
#else
       png_set_unknown_chunks(png_ptr, info_ptr, &png_ptr->unknown_chunk, 1);
d2205 2
a2206 2
       png_free(png_ptr, png_ptr->unknown_chunk.data);
       png_ptr->unknown_chunk.data = NULL;
d2249 1
a2249 1
#ifndef PNG_HAVE_MMX_COMBINE_ROW
d2450 1
a2450 1
#endif /* !PNG_HAVE_MMX_COMBINE_ROW */
d2453 1
a2453 1
#ifndef PNG_HAVE_MMX_READ_INTERLACE   /* else in pngvcrd.c, pnggccrd.c */
d2679 1
a2679 1
#endif /* !PNG_HAVE_MMX_READ_INTERLACE */
d2682 1
a2682 1
#ifndef PNG_HAVE_MMX_READ_FILTER_ROW
d2805 1
a2805 1
#endif /* !PNG_HAVE_MMX_READ_FILTER_ROW */
d3107 1
a3107 1
   if ((png_uint_32)png_ptr->rowbytes > (png_uint_32)(PNG_SIZE_MAX - 1))
@


1.1.107.5
log
@Import libpng-1.2.25 with the following change log.
Requested by bsiegert@@ due to security fix relevance.

version 1.2.19beta1 [May 18, 2007]
  Changed "const static" to "static PNG_CONST" everywhere, mostly undoing
    change of libpng-1.2.17beta2.  Changed other "const" to "PNG_CONST"
  Changed some handling of unused parameters, to avoid compiler warnings.
    "if (unused == NULL) return;" becomes "unused = unused".

version 1.2.19beta2 [May 18, 2007]
  Only use the valid bits of tRNS value in png_do_expand() (Brian Cartier)

version 1.2.19beta3 [May 19, 2007]
  Add some "png_byte" typecasts in png_check_keyword() and write new_key
  instead of key in zTXt chunk (Kevin Ryde).

version 1.2.19beta4 [May 21, 2007]
  Add png_snprintf() function and use it in place of sprint() for improved
    defense against buffer overflows.

version 1.2.19beta5 [May 21, 2007]
  Fixed png_handle_tRNS() to only use the valid bits of tRNS value.
  Changed handling of more unused parameters, to avoid compiler warnings.
  Removed some PNG_CONST in pngwutil.c to avoid compiler warnings.

version 1.2.19beta6 [May 22, 2007]
  Added some #ifdef PNG_MMX_CODE_SUPPORTED where needed in pngvcrd.c
  Added a special "_MSC_VER" case that defines png_snprintf to _snprintf

version 1.2.19beta7 [May 22, 2007]
  Squelched png_squelch_warnings() in pnggccrd.c and added an
    #ifdef PNG_MMX_CODE_SUPPORTED block around the declarations that caused
    the warnings that png_squelch_warnings was squelching.

version 1.2.19beta8 [May 22, 2007]
  Removed __MMX__ from test in pngconf.h.

version 1.2.19beta9 [May 23, 2007]
  Made png_squelch_warnings() available via PNG_SQUELCH_WARNINGS macro.
  Revised png_squelch_warnings() so it might work.
  Updated makefile.sgcc and makefile.solaris; added makefile.solaris-x86.

version 1.2.19beta10 [May 24, 2007]
  Resquelched png_squelch_warnings(), use "__attribute__((used))" instead.

version 1.2.19beta11 [May 28, 2007]
  Return 0 from png_get_sPLT() and png_get_unknown_chunks() if png_ptr is NULL;
    changed three remaining instances of png_strcpy() to png_strncpy() (David
    Hill).
  Make test for NULL row_buf at the beginning of png_do_read_transformations
    unconditional.

version 1.2.19beta12 [May 28, 2007]
  Revised pnggccrd.c.

version 1.2.19beta13 [June 14, 2007]
  Prefer PNG_USE_PNGVCRD when _MSC_VER is defined in pngconf.h

version 1.2.19beta14 [June 16, 2007]
  Fix bug with handling of 16-bit transparency, introduced in 1.2.19beta2

version 1.2.19beta15 [June 17, 2007]
  Revised pnggccrd.c.

version 1.2.19beta16 [June 18, 2007]
  Revised pnggccrd.c again.
  Updated contrib/gregbook.
  Changed '#include "pnggccrd.c"' to 'include "$srcdir/pnggccrd.c"'
    in configure.ac

version 1.2.19beta17 [June 19, 2007]
  Revised many of the makefiles, to set -DPNG_NO_MMX_CODE where needed
    and to not use -O3 unless -DPNG_NO_MMX_CODE is also set.

version 1.2.19beta18 [June 23, 2007]
  Replaced some C++ style comments with C style comments in pnggccrd.c.
  Copied optimized C code from pnggccrd.c to pngrutil.c, removed dependency
    on pnggccrd.o from many makefiles.
  Added sl and dylib to list of extensions be installed by Makefile.am

version 1.2.19beta19 [June 28, 2007]
  Fixed testing PNG_RGB_TO_GRAY_ERR & PNG_RGB_TO_GRAY_WARN in pngrtran.c
  More cleanup of pnggccrd.c and pngvcrd.c

version 1.2.19beta20 [June 29, 2007]
  Rebuilt Makefile.in and configure using libtool-1.5.24.
  Fixed typo in pnggccrd.c

version 1.2.19beta21 [June 30, 2007]
  More revision of pnggccrd.c
  Added "test" target to Makefile.in and Makefile.am

version 1.2.19beta22 [July 3, 2007]
  Added info about pngrutil/pnggccrd/pngvcrd to png_get_header_version()
  Fix type definition of dummy_value_a, b in pnggccrd.c

version 1.2.19beta23 [July 10, 2007]
  Revert change to type definition of dummy_value_a, b in pnggccrd.c
  Make sure __PIC__ is defined in pnggccrd.c when PIC is defined.
  Require gcc-4.1 or better to use PNG_HAVE_MMX_FILTER_ROW on x86_64 platforms

version 1.2.19beta24 [July 14, 2007]
  Added PNG_NO_READ_FILTER, PNG_NO_WRITE_FILTER, PNG_NO_WARNING macros.
  Added contrib/pngminim to demonstrate building minimal encoder and decoder

version 1.2.19beta25 [July 15, 2007]
  Removed the new PNG_NO_READ_FILTER macro since it would make the library
    unable to read valid PNG files, and filtering is at the heart of the
    PNG format.

version 1.2.19beta26 [July 16, 2007]
  Changed "png_free(str)" to "png_free(png_ptr,str)" in pngrutil.c WinCE
    code (Yves Piguet).  This bug was introduced in libpng-1.2.14.
  Updated scripts/CMakeLists.txt
  Relocated a misplaced #endif in pnggccrd.c

version 1.2.19beta27 [July 17, 2007]
  Fixed incorrect stride and number of bytes copied (was 4 instead of
    6 bytes) in the cleanup loop of pnggccrd.c and pngvcrd.c for handling
    the end of 48-bit interlaced rows (Glenn R-P).

version 1.2.19beta28 [July 19, 2007]
  Removed requirement for gcc-4.1 or better to use PNG_HAVE_MMX_FILTER_ROW
    on x86_64 platforms
  Added png_warning() in pngrutil.c for short iCCP, iTXt, sPLT, or zTXT chunks.
  Revised pngtest.c so warnings are displayed regardless of PNG_NO_STDIO.

version 1.2.19beta29 [July 20, 2007]
  Fix typo in pnggccrd.c (%%eax should be %%ax in secondloop48)

version 1.2.19beta30 [July 26, 2007]
  Revised pnggccrd.c

version 1.2.19beta31 [July 27, 2007]
  Fix typos in pnggccrd.c

version 1.0.27rc1 and 1.2.19rc1 [July 31, 2007]
  Disable PNG_MMX_CODE_SUPPORTED when PNG_ASSEMBLER_CODE_SUPPORTED is off.
  Enable PNG_MMX_READ_FILTER_* by default, except when gcc-3.x is being
    used (they were inadvertently disabled in libpng-1.2.19beta23).
  Fix some debugging statements in pnggccrd.c and pngrutil.c
  Added information about disabling the MMX code in libpng documentation.

version 1.0.27rc2 and 1.2.19rc2 [August 4, 2007]
  Removed some "#if 0" blocks.
  Made a global struct local in pngvcrd.c to make it thread safe.
  Issue a png_error() if application attempts to transform a row tht
    has not been initialized.

version 1.0.27rc3 and 1.2.19rc3 [August 9, 2007]
  Slightly revised pngvcrd.c

version 1.0.27rc4 and 1.2.19rc4 [August 9, 2007]
  Revised pnggccrd.c debugging change of rc1, which was broken.
  Revised scripts/CMakeLists.txt
  Change default to PNG_NO_GLOBAL_ARRAYS for MSVC.
  Turn off PNG_FLAG_ROW_INIT flag when setting transforms that expand pixels.

version 1.0.27rc5 and 1.2.19rc5 [August 10, 2007]
  Fix typo (missing '"') in pnggccrd.c
  Revise handling of png_strtod in recent versions of WINCE

version 1.0.27rc6 and 1.2.19rc6 [August 15, 2007]
  Fix typo (missing ',') in contrib/gregbook/readpng2.c
  Undid row initialization error exit added to rc2 and rc4.

version 1.0.27 and 1.2.19 [August 18, 2007]
  Conditionally restored row initialization error exit.

version 1.2.20beta01 [August 19, 2007]
  Fixed problem with compiling pnggccrd.c on Intel-Apple platforms.
  Changed png_malloc() to png_malloc_warn() in png_set_sPLT().
  Added PNG_NO_ERROR_TEXT feature, with demo in contrib/pngminim
  Removed define PNG_WARN_UNINITIALIZED_ROW 1 /* 0: warning; 1: error */
    because it caused some trouble.

version 1.2.20beta02 [August 20, 2007]
  Avoid compiling pnggccrd.c on Intel-Apple platforms.

version 1.2.20beta03 [August 20, 2007]
  Added "/D PNG_NO_MMX_CODE" to the non-mmx builds of projects/visualc6
    and visualc71.

version 1.2.20beta04 [August 21, 2007]
  Revised pngvcrd.c for improved efficiency (Steve Snyder).

version 1.2.20rc1 [August 23, 2007]
  Revised pngconf.h to set PNG_NO_MMX_CODE for gcc-3.x compilers.

version 1.2.20rc2 [August 27, 2007]
  Revised scripts/CMakeLists.txt
  Revised #ifdefs to ensure one and only one of pnggccrd.c, pngvcrd.c,
    or part of pngrutil.c is selected.

version 1.2.20rc3 [August 30, 2007]
  Remove a little more code in pngwutil.c when PNG_NO_WRITE_FILTER is selected.
  Added /D _CRT_SECURE_NO_WARNINGS to visual6c and visualc71 projects.
  Compile png_mmx_support() in png.c even when PNG_NO_MMX_CODE is defined.
  Restored a "superfluous" #ifdef that was removed from 1.2.20rc2 pnggccrd.c,
    breaking the png_mmx_support() function.

version 1.2.20rc4 [September 1, 2007]
  Removed Intel contributions (MMX, Optimized C).

version 1.2.20rc5 [September 2, 2007]
  Restored configure and Makefile.in to rc3 and put a snippet of code in
    pnggccrd.c, to ensure configure makes the same PNG_NO_MMX_CODE selection

version 1.2.20rc6 [September 2, 2007]
  Fixed bugs in scripts/CMakeLists.txt
  Removed pngvcrd.c references from msvc projects.

version 1.0.28 and 1.2.20 [September 8, 2007]
  Removed "(NO READ SUPPORT)" from png_get_header_version() string.

version 1.2.21beta1 [September 14, 2007]
  Fixed various mistakes reported by George Cook and Jeff Phillips:
  logical vs bitwise NOT in pngrtran.c, bug introduced in 1.2.19rc2
  16-bit cheap transparency expansion, bug introduced in 1.2.19beta2
  errors with sizeof(unknown_chunk.name), bugs introduced in 1.2.19beta11
  <= compare with unsigned var in pngset.c, should be ==.

version 1.2.21beta2 [September 18, 2007]
  Removed some extraneous typecasts.

version 1.2.21rc1 [September 25, 2007]
  Fixed potential out-of-bounds reads in png_handle_pCAL() and
    png_handle_ztXt() ("flayer" results reported by Tavis Ormandy).

version 1.2.21rc2 [September 26, 2007]
  Fixed potential out-of-bounds reads in png_handle_sCAL(),
    png_handle_iTXt(), and png_push_read_tEXt().
  Remove some PNG_CONST declarations from pngwutil.c to avoid compiler warnings
  Revised makefiles to update paths in libpng.pc properly.

version 1.2.21rc3 [September 27, 2007]
  Revised makefiles to update "Libs" in libpng.pc properly.

version 1.0.29 and 1.2.21rc3 [October 4, 2007]
  No changes.

version 1.2.22beta1 [October 4, 2007]
  Again, fixed logical vs bitwise NOT in pngrtran.c, bug introduced
    in 1.2.19rc2

version 1.2.22beta2 [October 5, 2007]
  Fixed string length error in pngset.c (caused crashes while decoding iCCP)
  Add terminating NULL after each instance of png_strncpy().

version 1.2.22beta3 [October 6, 2007]
  Fix two off-by-one terminating NULL after png_strncpy().

version 1.2.22beta4 [October 7, 2007]
  Changed some 0 to '\0'.

version 1.0.30rc1 and 1.2.22rc1 [October 8, 2007]
  No changes.

version 1.0.30 and 1.2.22 [October 13, 2007]
  No changes.

version 1.2.23beta01 [October 15, 2007]
  Reduced number of invocations of png_strlen() in pngset.c.
  Changed [azAZ09_] to [_abcde...89] in Makefile.am for better localization.

version 1.2.23beta02 [October 16, 2007]
  Eliminated png_strncpy() and png_strcpy() (Pierre Poissinger)
  Changed $AN to $(AN) in Makefile.am.

version 1.2.23beta03 [October 16, 2007]
  Fixed off-by-one error in pngset.c
  Restore statement to set last character of buffer to \0 in pngerror.c

version 1.2.23beta04 [October 23, 2007]
  Reject attempt to set all-zero cHRM values.

version 1.2.23beta05 [October 26, 2007]
  Add missing quotes in projects/visualc6, lost in version 1.2.20rc3

version 1.2.23rc01 [November 2, 2007]
  No changes.

version 1.2.23 [November 6, 2007]
  No changes.

version 1.2.24beta01 [November 19, 2007]
  Moved misplaced test for malloc failure in png_set_sPLT().  This bug was
    introduced in libpng-1.2.20beta01.
  Ifdef out avg_row etc from png.h and pngwrite.c when PNG_NO_WRITE_FILTER
  Do not use png_ptr->free_fn and png_ptr->mem_fn in png_destroy_read_struct()
    when png_ptr is NULL (Marshall Clow).
  Updated handling of symbol prefixes in Makefile.am and configure.ac (Mike
    Frysinger).

version 1.2.24beta02 [November 30, 2007]
  Removed a useless test and fixed incorrect test in png_set_cHRM_fixed()
    (David Hill).

version 1.2.24rc01 [December 7, 2007]
  No changes.

version 1.2.24     [December 14, 2007]
  Make sure not to redefine _BSD_SOURCE in pngconf.h
  Revised gather.sh and makefile.std in contrib/pngminim to avoid compiling
    unused files.

version 1.2.25beta01 [January 7, 2008]
  Fixed bug with unknown chunk handling, introduced in version 1.2.17rc2

version 1.2.25beta02 [January 10, 2008]
  Prevent gamma from being applied twice.

version 1.2.25rc01 [January 17, 2008]
  No changes.

version 1.2.25beta03 [January 22, 2008]
  Fixed some continue-after-malloc-failure errors in pngset.c (David Hill)
  Check for info_ptr == NULL in png_read_info() and png_process_data().
  Check for possible use of NULL user_png_ver[] in png_create_read_struct().
  Change "if (swidth == NULL)" to "if (sheight == NULL)" in png_handle_sCAL
    (bug introduced in libpng-1.2.4/1.0.13).
  Return from png_destroy_read_struct() if png_ptr_ptr is NULL.
  Fix overflow of "msg" in png_decompres_chunk().

version 1.2.25beta04 [January 26, 2008]
  Work around Coverity bug report by slightly refactoring
    png_read_push_finish_row()

version 1.2.25beta05 [January 31, 2008]
  Added libpng-1.2.25beta05.tar.lzma to distribution.  Get the lzma codec
    from <http://tukaani.org/lzma>.
  Added lp1225b05.7z to distribution.  Get the 7-zip decoder from
    from <http://www.7-zip.org>.
  Fixed some broken links in the README file.

version 1.2.25beta06 [February 6, 2008]
  Refactored png_read_push_finish_row() again, trying to satisfy Coverity.
  Fixed potential NULL dereference of png_ptr in png_destroy_write_struct();
  clarified potential NULL dereference of png_ptr in png_destroy_read_struct();
  fixed potential NULL dereference of info_ptr in png_handle_bKGD();
  fixed potential NULL dereference of user_png_ver[] in
    png_create_write_struct_2(). (Coverity)

version 1.2.25rc02 [February 10, 2008]
  Reset png_ptr->pass in png_read_push_finish_row() before break.
  Changed "pass" from png_byte to int.

version 1.2.25 and 1.0.31 [February 18, 2008]
  No changes.
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.25 [February 18, 2008]
d6 1
a6 1
 * Copyright (c) 1998-2008 Glenn Randers-Pehrson
a18 4
#if defined(_WIN32_WCE) && (_WIN32_WCE<0x500)
#  define WIN32_WCE_OLD
#endif

d20 1
a20 1
#  if defined(WIN32_WCE_OLD)
d22 1
a22 1
__inline double png_strtod(png_structp png_ptr, PNG_CONST char *nptr, char **endptr)
d36 1
a36 1
      png_free(png_ptr, str);
d184 1
a184 1
   static PNG_CONST char msg[] = "Error decoding compressed text";
d229 1
a229 1
            png_memcpy(text + prefix_size, msg, text_size);
d285 1
a285 2
            png_snprintf(umsg, 52,
                "Buffer error in compressed datastream in %s chunk",
d288 1
a288 2
            png_snprintf(umsg, 52,
                "Data error in compressed datastream in %s chunk",
d291 1
a291 2
            png_snprintf(umsg, 52,
                "Incomplete compressed datastream in %s chunk",
d324 1
a324 2
      png_snprintf(umsg, 50,
         "Unknown zTXt compression type %d", comp_type);
d566 2
a567 1
   info_ptr =info_ptr; /* quiet compiler warnings about unused info_ptr */
d1040 1
a1040 1
   if ( profile >= chunkdata + slength - 1)
d1144 1
a1144 1
   if (entry_start > chunkdata + slength - 2)
a1236 1
   int bit_mask;
a1239 5
   /* For non-indexed color, mask off any bits in the tRNS value that
    * exceed the bit depth.  Some creators were writing extra bits there.
    * This is not needed for indexed color. */
   bit_mask = (1 << png_ptr->bit_depth) - 1;

d1268 1
a1268 1
      png_ptr->trans_values.gray = png_get_uint_16(buf) & bit_mask;
d1282 3
a1284 3
      png_ptr->trans_values.red = png_get_uint_16(buf) & bit_mask;
      png_ptr->trans_values.green = png_get_uint_16(buf + 2) & bit_mask;
      png_ptr->trans_values.blue = png_get_uint_16(buf + 4) & bit_mask;
d1383 1
a1383 1
      if (info_ptr && info_ptr->num_palette)
d1663 1
a1663 1
      for (params[i] = buf; buf <= endptr && *buf != 0x00; buf++)
a1760 11
   if (buffer + slength < ep)
   {
       png_warning(png_ptr, "Truncated sCAL chunk");
#if defined(PNG_FIXED_POINT_SUPPORTED) && \
    !defined(PNG_FLOATING_POINT_SUPPORTED)
       png_free(png_ptr, swidth);
#endif
      png_free(png_ptr, buffer);
       return;
   }

d1771 1
a1771 1
   if (sheight == NULL)
d1984 1
a1984 1
   if (text >= chunkdata + slength - 2)
d1986 2
a1987 3
      png_warning(png_ptr, "Truncated zTXt chunk");
      png_free(png_ptr, chunkdata);
      return;
d2087 1
a2087 1
   if (lang >= chunkdata + slength - 3)
d2089 2
a2090 3
      png_warning(png_ptr, "Truncated iTXt chunk");
      png_free(png_ptr, chunkdata);
      return;
a2101 7
   if (lang_key >= chunkdata + slength)
   {
      png_warning(png_ptr, "Truncated iTXt chunk");
      png_free(png_ptr, chunkdata);
      return;
   }

a2104 6
   if (text >= chunkdata + slength)
   {
      png_warning(png_ptr, "Malformed iTXt chunk");
      png_free(png_ptr, chunkdata);
      return;
   }
d2154 1
a2154 1
      PNG_CONST PNG_IDAT;
d2187 2
a2188 4
       png_memcpy((png_charp)png_ptr->unknown_chunk.name,
                  (png_charp)png_ptr->chunk_name, 
                  png_sizeof(png_ptr->unknown_chunk.name));
       png_ptr->unknown_chunk.name[png_sizeof(png_ptr->unknown_chunk.name)-1] = '\0';
d2211 2
a2212 1
       else
a2213 1
         png_set_unknown_chunks(png_ptr, info_ptr, &png_ptr->unknown_chunk, 1);
d2224 2
a2225 1
   info_ptr = info_ptr; /* quiet compiler warnings about unused info_ptr */
d2258 1
a2258 1

d2459 1
d2462 1
d2477 1
a2477 1
   PNG_CONST int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
d2480 1
a2480 1
   png_debug(1,"in png_do_read_interlace\n");
d2684 2
a2685 1
   transformations = transformations; /* silence compiler warning */
d2688 1
d2691 1
d2814 1
d2823 1
a2823 1
   PNG_CONST int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
d2826 1
a2826 1
   PNG_CONST int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
d2829 1
a2829 1
   PNG_CONST int png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
d2832 1
a2832 1
   PNG_CONST int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
d2843 1
a2843 2
      png_memset_check(png_ptr, png_ptr->prev_row, 0,
         png_ptr->rowbytes + 1);
d2877 1
a2877 1
      PNG_CONST PNG_IDAT;
d2898 1
a2898 1
               if (png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
d2950 1
a2950 1
   PNG_CONST int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
d2953 1
a2953 1
   PNG_CONST int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
d2956 1
a2956 1
   PNG_CONST int png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
d2959 1
a2959 1
   PNG_CONST int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
d3108 3
@


1.1.107.6
log
@*sigh*

sync with MirPortsâ€¦ they had another update
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.26 [April 2, 2008]
a2853 1
#ifdef PNG_READ_INTERLACING_SUPPORTED
a2866 1
#endif /* PNG_READ_INTERLACING_SUPPORTED */
a2873 1
#ifdef PNG_READ_INTERLACING_SUPPORTED
a2907 1
#endif /* PNG_READ_INTERLACING_SUPPORTED */
a2981 1
#ifdef PNG_READ_INTERLACING_SUPPORTED
a2995 1
#endif
a3002 1
#ifdef PNG_READ_INTERLACING_SUPPORTED
a3022 1
#endif /* PNG_READ_INTERLACING_SUPPORTED */
d3141 2
a3142 9

   if(row_bytes + 64 > png_ptr->old_big_row_buf_size)
   {
     if (png_ptr->big_row_buf)
        png_free(png_ptr,png_ptr->big_row_buf);
     png_ptr->big_row_buf = (png_bytep)png_malloc(png_ptr, row_bytes+64);
     png_ptr->row_buf = png_ptr->big_row_buf+32;
     png_ptr->old_big_row_buf_size = row_bytes+64;
   }
d3150 2
a3151 9

   if(png_ptr->rowbytes+1 > png_ptr->old_prev_row_size)
   {
     if (png_ptr->prev_row)
        png_free(png_ptr,png_ptr->prev_row);
     png_ptr->prev_row = (png_bytep)png_malloc(png_ptr, (png_uint_32)(
        png_ptr->rowbytes + 1));
     png_ptr->old_prev_row_size = png_ptr->rowbytes+1;
   }
@


1.1.107.7
log
@SECURITY update of libpng to 1.2.32
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.31 [August 19, 2008]
d16 1
d33 1
a33 1
   str = (wchar_t *)png_malloc(png_ptr, len * png_sizeof(wchar_t));
a51 1
#ifdef PNG_READ_BIG_ENDIAN_SUPPORTED
a52 7
#else
   /* Avoid an extra function call by inlining the result. */
   png_uint_32 i = ((png_uint_32)(*buf) << 24) +
      ((png_uint_32)(*(buf + 1)) << 16) +
      ((png_uint_32)(*(buf + 2)) << 8) +
      (png_uint_32)(*(buf + 3));
#endif
a94 29
/* Read the chunk header (length + type name).
 * Put the type name into png_ptr->chunk_name, and return the length.
 */
png_uint_32 /* PRIVATE */
png_read_chunk_header(png_structp png_ptr)
{
   png_byte buf[8];
   png_uint_32 length;

   /* read the length and the chunk name */
   png_read_data(png_ptr, buf, 8);
   length = png_get_uint_31(png_ptr, buf);

   /* put the chunk name into png_ptr->chunk_name */
   png_memcpy(png_ptr->chunk_name, buf + 4, 4);

   png_debug2(0, "Reading %s chunk, length = %lu\n",
      png_ptr->chunk_name, length);

   /* reset the crc and run it over the chunk name */
   png_reset_crc(png_ptr);
   png_calculate_crc(png_ptr, png_ptr->chunk_name, 4);

   /* check to see if chunk name is valid */
   png_check_chunk_name(png_ptr, png_ptr->chunk_name);

   return length;
}

d99 1
a99 1
   if (png_ptr == NULL) return;
d183 1
a183 1
void /* PRIVATE */
d185 1
a185 1
                              png_size_t chunklength,
d195 1
a195 1
      png_ptr->zstream.next_in = (png_bytep)(png_ptr->chunkdata + prefix_size);
d221 2
a222 3
                    png_free(png_ptr, png_ptr->chunkdata);
                    png_ptr->chunkdata = NULL;
                    png_error(png_ptr, "Not enough memory to decompress chunk");
d224 1
a224 1
               png_memcpy(text, png_ptr->chunkdata, prefix_size);
d230 3
a232 4
            text_size = (png_size_t)(chunklength -
              (text - png_ptr->chunkdata) - 1);
            if (text_size > png_sizeof(msg))
               text_size = png_sizeof(msg);
d244 4
a247 6
               {
                  png_free(png_ptr, png_ptr->chunkdata);
                  png_ptr->chunkdata = NULL;
                  png_error(png_ptr,
                    "Not enough memory to decompress chunk.");
               }
d250 1
a250 1
               png_memcpy(text, png_ptr->chunkdata, prefix_size);
d264 2
a265 4
                  png_free(png_ptr, png_ptr->chunkdata);
                  png_ptr->chunkdata = NULL;
                  png_error(png_ptr,
                    "Not enough memory to decompress chunk..");
d305 1
a305 1
         text_size = prefix_size;
d311 2
a312 3
                png_free(png_ptr, png_ptr->chunkdata);
                png_ptr->chunkdata = NULL;
                png_error(png_ptr, "Not enough memory for text.");
d314 1
a314 1
            png_memcpy(text, png_ptr->chunkdata, prefix_size);
d322 2
a323 2
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = text;
d331 2
a332 1
      png_snprintf(umsg, 50, "Unknown zTXt compression type %d", comp_type);
d338 2
a339 2
      *(png_ptr->chunkdata + prefix_size) = 0x00;
      *newlength = prefix_size;
d341 2
d409 4
a412 4
   png_ptr->rowbytes = PNG_ROWBYTES(png_ptr->pixel_depth, png_ptr->width);
   png_debug1(3, "bit_depth = %d\n", png_ptr->bit_depth);
   png_debug1(3, "channels = %d\n", png_ptr->channels);
   png_debug1(3, "rowbytes = %lu\n", png_ptr->rowbytes);
d574 1
a574 1
   info_ptr = info_ptr; /* quiet compiler warnings about unused info_ptr */
d728 1
a728 1
   png_byte buf[32];
d769 5
a773 3
   png_crc_read(png_ptr, buf, 32);
   if (png_crc_finish(png_ptr, 0))
      return;
a774 2
   uint_x = png_get_uint_32(buf);
   uint_y = png_get_uint_32(buf + 4);
d779 1
d785 6
a790 2
   uint_x = png_get_uint_32(buf + 8);
   uint_y = png_get_uint_32(buf + 12);
d794 1
d800 6
a805 2
   uint_x = png_get_uint_32(buf + 16);
   uint_y = png_get_uint_32(buf + 20);
d809 1
d815 6
a820 2
   uint_x = png_get_uint_32(buf + 24);
   uint_y = png_get_uint_32(buf + 28);
d824 1
d857 1
a857 1
            fprintf(stderr, "wx=%f, wy=%f, rx=%f, ry=%f\n",
d859 1
a859 1
            fprintf(stderr, "gx=%f, gy=%f, bx=%f, by=%f\n",
d862 1
a862 1
            fprintf(stderr, "wx=%ld, wy=%ld, rx=%ld, ry=%ld\n",
d864 1
a864 1
            fprintf(stderr, "gx=%ld, gy=%ld, bx=%ld, by=%ld\n",
d869 1
d883 2
d952 1
a952 2
         fprintf(stderr, "incorrect gamma=(%d/100000)\n",
            (int)png_ptr->int_gamma);
d955 1
a955 1
         fprintf(stderr, "incorrect gamma=%f\n", png_ptr->gamma);
d990 1
d1028 1
a1028 2
   png_free(png_ptr, png_ptr->chunkdata);
   png_ptr->chunkdata = (png_charp)png_malloc(png_ptr, length + 1);
d1030 1
a1030 1
   png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);
d1034 1
a1034 2
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
d1038 1
a1038 1
   png_ptr->chunkdata[slength] = 0x00;
d1040 1
a1040 1
   for (profile = png_ptr->chunkdata; *profile; profile++)
d1047 1
a1047 1
   if ( profile >= png_ptr->chunkdata + slength - 1)
d1049 1
a1049 2
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
d1059 1
a1059 1
      compression_type = 0x00;  /* Reset it to zero (libpng-1.0.6 through 1.0.8
d1063 3
a1065 3
   prefix_length = profile - png_ptr->chunkdata;
   png_decompress_chunk(png_ptr, compression_type,
     slength, prefix_length, &data_length);
d1071 1
a1071 2
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
d1077 5
a1081 5
   pC = (png_bytep)(png_ptr->chunkdata + prefix_length);
   profile_size = ((*(pC    ))<<24) |
                  ((*(pC + 1))<<16) |
                  ((*(pC + 2))<< 8) |
                  ((*(pC + 3))    );
d1083 1
a1083 1
   if (profile_size < profile_length)
d1086 1
a1086 1
   if (profile_size > profile_length)
d1088 1
a1088 2
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
d1093 3
a1095 4
   png_set_iCCP(png_ptr, info_ptr, png_ptr->chunkdata,
     compression_type, png_ptr->chunkdata + prefix_length, profile_length);
   png_free(png_ptr, png_ptr->chunkdata);
   png_ptr->chunkdata = NULL;
d1104 1
d1134 1
a1134 2
   png_free(png_ptr, png_ptr->chunkdata);
   png_ptr->chunkdata = (png_charp)png_malloc(png_ptr, length + 1);
d1136 1
a1136 1
   png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);
d1140 1
a1140 2
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
d1144 1
a1144 1
   png_ptr->chunkdata[slength] = 0x00;
d1146 1
a1146 1
   for (entry_start = (png_bytep)png_ptr->chunkdata; *entry_start; entry_start++)
d1151 1
a1151 1
   if (entry_start > (png_bytep)png_ptr->chunkdata + slength - 2)
d1153 1
a1153 2
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
d1160 1
a1160 1
   data_length = (slength - (entry_start - (png_bytep)png_ptr->chunkdata));
d1165 1
a1165 2
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
d1171 2
a1172 2
   if ((png_uint_32) new_palette.nentries >
       (png_uint_32) (PNG_SIZE_MAX / png_sizeof(png_sPLT_entry)))
d1230 1
a1230 1
   new_palette.name = png_ptr->chunkdata;
d1234 1
a1234 2
   png_free(png_ptr, png_ptr->chunkdata);
   png_ptr->chunkdata = NULL;
d1244 1
d1248 5
d1281 1
a1281 1
      png_ptr->trans_values.gray = png_get_uint_16(buf);
d1295 3
a1297 3
      png_ptr->trans_values.red = png_get_uint_16(buf);
      png_ptr->trans_values.green = png_get_uint_16(buf + 2);
      png_ptr->trans_values.blue = png_get_uint_16(buf + 4);
d1398 1
a1398 1
          if (buf[0] > info_ptr->num_palette)
d1574 1
d1601 2
a1602 3
   png_free(png_ptr, png_ptr->chunkdata);
   png_ptr->chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);
   if (png_ptr->chunkdata == NULL)
d1608 1
a1608 1
   png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);
d1612 1
a1612 2
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
d1616 1
a1616 1
   png_ptr->chunkdata[slength] = 0x00; /* null terminate the last string */
d1619 1
a1619 1
   for (buf = png_ptr->chunkdata; *buf; buf++)
d1622 1
a1622 1
   endptr = png_ptr->chunkdata + slength;
d1629 1
a1629 2
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
d1649 1
a1649 2
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
d1661 2
a1662 2
   params = (png_charpp)png_malloc_warn(png_ptr,
      (png_uint_32)(nparams * png_sizeof(png_charp))) ;
d1665 1
a1665 2
       png_free(png_ptr, png_ptr->chunkdata);
       png_ptr->chunkdata = NULL;
d1683 1
a1683 2
         png_free(png_ptr, png_ptr->chunkdata);
         png_ptr->chunkdata = NULL;
d1689 1
a1689 1
   png_set_pCAL(png_ptr, info_ptr, png_ptr->chunkdata, X0, X1, type, nparams,
d1692 1
a1692 2
   png_free(png_ptr, png_ptr->chunkdata);
   png_ptr->chunkdata = NULL;
d1702 1
a1702 1
   png_charp ep;
d1732 6
a1737 6
   png_ptr->chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);
   if (png_ptr->chunkdata == NULL)
   {
      png_warning(png_ptr, "Out of memory while processing sCAL chunk");
      return;
   }
d1739 1
a1739 1
   png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);
d1743 1
a1743 2
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
d1747 1
a1747 1
   png_ptr->chunkdata[slength] = 0x00; /* null terminate the last string */
d1749 1
a1749 1
   ep = png_ptr->chunkdata + 1;        /* skip unit byte */
d1755 2
a1756 2
      png_warning(png_ptr, "malformed width string in sCAL chunk");
      return;
d1762 4
a1765 4
   {
      png_warning(png_ptr, "Out of memory while processing sCAL chunk width");
      return;
   }
d1770 1
a1770 1
   for (ep = png_ptr->chunkdata; *ep; ep++)
d1774 1
a1774 1
   if (png_ptr->chunkdata + slength < ep)
d1776 1
a1776 1
      png_warning(png_ptr, "Truncated sCAL chunk");
d1779 1
a1779 1
      png_free(png_ptr, swidth);
d1781 2
a1782 3
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
      return;
d1789 2
a1790 2
      png_warning(png_ptr, "malformed height string in sCAL chunk");
      return;
d1796 4
a1799 4
   {
      png_warning(png_ptr, "Out of memory while processing sCAL chunk height");
      return;
   }
d1804 1
a1804 1
   if (png_ptr->chunkdata + slength < ep
d1811 1
a1811 2
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
d1821 1
a1821 1
   png_set_sCAL(png_ptr, info_ptr, png_ptr->chunkdata[0], width, height);
d1824 1
a1824 1
   png_set_sCAL_s(png_ptr, info_ptr, png_ptr->chunkdata[0], swidth, sheight);
d1828 1
a1828 2
   png_free(png_ptr, png_ptr->chunkdata);
   png_ptr->chunkdata = NULL;
d1949 1
a1949 1
   ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
d1964 1
d1982 1
a1982 1
     png_warning(png_ptr, "zTXt chunk too large to fit in memory");
d1988 2
a1989 3
   png_free(png_ptr,png_ptr->chunkdata);
   png_ptr->chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);
   if (png_ptr->chunkdata == NULL)
d1991 1
a1991 1
     png_warning(png_ptr, "Out of memory processing zTXt chunk.");
d1995 1
a1995 1
   png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);
d1998 1
a1998 2
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
d2002 1
a2002 1
   png_ptr->chunkdata[slength] = 0x00;
d2004 1
a2004 1
   for (text = png_ptr->chunkdata; *text; text++)
d2008 1
a2008 1
   if (text >= png_ptr->chunkdata + slength - 2)
d2011 1
a2011 2
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
d2024 1
a2024 1
   prefix_len = text - png_ptr->chunkdata;
d2026 2
a2027 2
   png_decompress_chunk(png_ptr, comp_type,
     (png_size_t)length, prefix_len, &data_len);
d2030 1
a2030 1
      (png_uint_32)png_sizeof(png_text));
d2033 2
a2034 3
     png_warning(png_ptr, "Not enough memory to process zTXt chunk.");
     png_free(png_ptr, png_ptr->chunkdata);
     png_ptr->chunkdata = NULL;
d2038 1
a2038 1
   text_ptr->key = png_ptr->chunkdata;
d2044 1
a2044 1
   text_ptr->text = png_ptr->chunkdata + prefix_len;
d2047 1
a2047 1
   ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
d2050 1
a2050 2
   png_free(png_ptr, png_ptr->chunkdata);
   png_ptr->chunkdata = NULL;
d2062 1
d2082 1
a2082 1
     png_warning(png_ptr, "iTXt chunk too large to fit in memory");
d2088 2
a2089 3
   png_free(png_ptr, png_ptr->chunkdata);
   png_ptr->chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);
   if (png_ptr->chunkdata == NULL)
d2095 1
a2095 1
   png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);
d2098 1
a2098 2
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
d2102 1
a2102 1
   png_ptr->chunkdata[slength] = 0x00;
d2104 1
a2104 1
   for (lang = png_ptr->chunkdata; *lang; lang++)
d2112 1
a2112 1
   if (lang >= png_ptr->chunkdata + slength - 3)
d2115 1
a2115 2
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
d2128 1
a2128 1
   if (lang_key >= png_ptr->chunkdata + slength)
d2131 1
a2131 2
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
d2138 1
a2138 1
   if (text >= png_ptr->chunkdata + slength)
d2141 1
a2141 2
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
d2145 1
a2145 1
   prefix_len = text - png_ptr->chunkdata;
d2147 1
a2147 1
   key=png_ptr->chunkdata;
d2149 2
a2150 2
       png_decompress_chunk(png_ptr, comp_type,
         (size_t)length, prefix_len, &data_len);
d2152 1
a2152 1
       data_len = png_strlen(png_ptr->chunkdata + prefix_len);
d2157 2
a2158 3
     png_warning(png_ptr, "Not enough memory to process iTXt chunk.");
     png_free(png_ptr, png_ptr->chunkdata);
     png_ptr->chunkdata = NULL;
d2162 2
a2163 2
   text_ptr->lang_key = png_ptr->chunkdata + (lang_key - key);
   text_ptr->lang = png_ptr->chunkdata + (lang - key);
d2166 2
a2167 2
   text_ptr->key = png_ptr->chunkdata;
   text_ptr->text = png_ptr->chunkdata + prefix_len;
d2169 1
a2169 1
   ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
d2172 1
a2172 2
   png_free(png_ptr, png_ptr->chunkdata);
   png_ptr->chunkdata = NULL;
d2199 2
d2204 1
a2204 1
      if (png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
d2230 1
d2232 1
a2232 7
       if (length == 0)
         png_ptr->unknown_chunk.data = NULL;
       else
       {
         png_ptr->unknown_chunk.data = (png_bytep)png_malloc(png_ptr, length);
         png_crc_read(png_ptr, (png_bytep)png_ptr->unknown_chunk.data, length);
       }
d2234 1
a2234 1
       if (png_ptr->read_user_chunk_fn != NULL)
d2245 1
a2245 1
                if (png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
d2254 1
a2254 1
       png_set_unknown_chunks(png_ptr, info_ptr, &png_ptr->unknown_chunk, 1);
d2302 1
a2302 1
   png_debug(1, "in png_combine_row\n");
d2518 1
a2518 1
   png_debug(1, "in png_do_read_interlace\n");
d2719 1
a2719 1
      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, final_width);
d2732 1
a2732 1
   png_debug2(2, "row = %lu, filter = %d\n", png_ptr->row_number, filter);
d2836 1
a2836 1
            p = (pa <= pb && pa <= pc) ? a : (pb <= pc) ? b : c;
d2845 1
a2845 1
         *row = 0;
d2923 1
a2923 1
      for (;;)
d3004 1
a3004 1
   png_size_t row_bytes;
d3023 5
a3027 2
         png_ptr->irowbytes =
            PNG_ROWBYTES(png_ptr->pixel_depth, png_ptr->iwidth) + 1;
d3129 1
a3129 1
   if (png_ptr->transformations & PNG_USER_TRANSFORM)
d3131 1
a3131 1
       int user_pixel_depth = png_ptr->user_transform_depth*
d3133 1
a3133 1
       if (user_pixel_depth > max_pixel_depth)
d3143 1
a3143 1
   row_bytes = PNG_ROWBYTES(max_pixel_depth, row_bytes) +
d3150 1
a3150 1
   if (row_bytes + 64 > png_ptr->old_big_row_buf_size)
d3152 2
a3153 1
     png_free(png_ptr, png_ptr->big_row_buf);
d3166 1
a3166 1
   if (png_ptr->rowbytes+1 > png_ptr->old_prev_row_size)
d3168 2
a3169 1
     png_free(png_ptr, png_ptr->prev_row);
@


1.1.107.8
log
@merge fix from libpng 1.2.33:
+  Changed remaining "key" to "png_ptr->chunkdata" in png_handle_tEXt()
+    to avoid memory leak after memory failure while reading tEXt chunk.
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.33 [October 31, 2008]
d1943 2
a1944 3
   png_free(png_ptr, png_ptr->chunkdata);
   png_ptr->chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);
   if (png_ptr->chunkdata == NULL)
d1950 1
a1950 1
   png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);
d1954 1
a1954 2
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
a1957 1
   key = png_ptr->chunkdata;
d1971 1
a1971 2
     png_free(png_ptr, png_ptr->chunkdata);
     png_ptr->chunkdata = NULL;
d1986 1
a1986 2
   png_free(png_ptr, png_ptr->chunkdata);
   png_ptr->chunkdata = NULL;
d2022 1
a2022 1
   png_free(png_ptr, png_ptr->chunkdata);
@


1.1.107.9
log
@libpng 1.2.35
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.31 [August 19, 2008]
d1943 3
a1945 2
   key = (png_charp)png_malloc_warn(png_ptr, length + 1);
   if (key == NULL)
d1951 1
a1951 1
   png_crc_read(png_ptr, (png_bytep)key, slength);
d1955 2
a1956 1
      png_free(png_ptr, key);
d1960 1
d1974 2
a1975 1
     png_free(png_ptr, key);
d1990 2
a1991 1
   png_free(png_ptr, key);
d2027 1
a2027 1
   png_free(png_ptr,png_ptr->chunkdata);
@


1.1.107.10
log
@libpng 1.2.35
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.34 [December 18, 2008]
d118 1
a118 1
   png_debug2(0, "Reading %s chunk, length = %lu",
d395 1
a395 1
   png_debug(1, "in png_handle_IHDR");
d450 3
a452 3
   png_debug1(3, "bit_depth = %d", png_ptr->bit_depth);
   png_debug1(3, "channels = %d", png_ptr->channels);
   png_debug1(3, "rowbytes = %lu", png_ptr->rowbytes);
d467 1
a467 1
   png_debug(1, "in png_handle_PLTE");
d599 1
a599 1
   png_debug(1, "in png_handle_IEND");
d627 1
a627 1
   png_debug(1, "in png_handle_gAMA");
d679 1
a679 1
         fprintf(stderr, "gamma = (%d/100000)", (int)igamma);
d705 1
a705 1
   png_debug(1, "in png_handle_sBIT");
d777 1
a777 1
   png_debug(1, "in png_handle_cHRM");
d815 6
d826 5
d836 5
d846 5
d916 1
a916 1
   png_debug(1, "in png_handle_sRGB");
d1019 1
a1019 1
   png_debug(1, "in png_handle_iCCP");
d1140 1
a1140 2
   png_debug(1, "in png_handle_sPLT");

d1276 1
a1276 1
   png_debug(1, "in png_handle_tRNS");
d1372 1
a1372 1
   png_debug(1, "in png_handle_bKGD");
d1423 1
a1423 1
          if (buf[0] >= info_ptr->num_palette)
d1461 1
a1461 1
   png_debug(1, "in png_handle_hIST");
d1516 1
a1516 1
   png_debug(1, "in png_handle_pHYs");
d1559 1
a1559 1
   png_debug(1, "in png_handle_oFFs");
d1606 1
a1606 1
   png_debug(1, "in png_handle_pCAL");
d1623 1
a1623 1
   png_debug1(2, "Allocating and reading pCAL chunk data (%lu bytes)",
d1644 1
a1644 1
   png_debug(3, "Finding end of pCAL purpose string");
d1660 1
a1660 1
   png_debug(3, "Reading pCAL X0, X1, type, nparams, and units");
d1667 1
a1667 1
   png_debug(3, "Checking pCAL equation type and number of parameters");
d1688 1
a1688 1
   png_debug(3, "Allocating pCAL parameters array");
d1704 1
a1704 1
      png_debug1(3, "Reading pCAL parameter %d", i);
d1744 1
a1744 1
   png_debug(1, "in png_handle_sCAL");
d1761 1
a1761 1
   png_debug1(2, "Allocating and reading sCAL chunk data (%lu bytes)",
d1878 1
a1878 1
   png_debug(1, "in png_handle_tIME");
d1926 1
a1926 2
   png_debug(1, "in png_handle_tEXt");

d1943 2
a1944 4
   png_free(png_ptr, png_ptr->chunkdata);

   png_ptr->chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);
   if (png_ptr->chunkdata == NULL)
d1950 1
a1950 1
   png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength);
d1954 1
a1954 2
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
a1957 2
   key = png_ptr->chunkdata;

d1971 1
a1971 2
     png_free(png_ptr, png_ptr->chunkdata);
     png_ptr->chunkdata = NULL;
d1986 1
a1986 2
   png_free(png_ptr, png_ptr->chunkdata);
   png_ptr->chunkdata = NULL;
d2004 1
a2004 3
   png_debug(1, "in png_handle_zTXt");


d2022 1
a2022 1
   png_free(png_ptr, png_ptr->chunkdata);
d2107 1
a2107 2
   png_debug(1, "in png_handle_iTXt");

d2233 1
a2233 2
   png_debug(1, "in png_handle_unknown");

d2328 1
a2328 1
   png_debug(1, "in png_check_chunk_name");
d2350 1
a2350 1
   png_debug(1, "in png_combine_row");
d2566 1
a2566 1
   png_debug(1, "in png_do_read_interlace");
d2779 2
a2780 2
   png_debug(1, "in png_read_filter_row");
   png_debug2(2, "row = %lu, filter = %d", png_ptr->row_number, filter);
d2919 1
a2919 1
   png_debug(1, "in png_read_finish_row");
d3054 1
a3054 1
   png_debug(1, "in png_read_start_row");
d3220 6
a3225 6
   png_debug1(3, "width = %lu,", png_ptr->width);
   png_debug1(3, "height = %lu,", png_ptr->height);
   png_debug1(3, "iwidth = %lu,", png_ptr->iwidth);
   png_debug1(3, "num_rows = %lu,", png_ptr->num_rows);
   png_debug1(3, "rowbytes = %lu,", png_ptr->rowbytes);
   png_debug1(3, "irowbytes = %lu", png_ptr->irowbytes);
@


1.1.107.11
log
@Update libpng in the base system, too
@
text
@d4 3
a6 2
 * Last changed in libpng 1.2.48 [March 8, 2012]
 * Copyright (c) 1998-2012 Glenn Randers-Pehrson
a9 4
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 *
a14 1
#define PNG_NO_PEDANTIC_WARNINGS
d16 1
a16 1
#ifdef PNG_READ_SUPPORTED
d23 3
a25 4
#  ifdef WIN32_WCE_OLD
/* The strtod() function is not supported on WindowsCE */
__inline double png_strtod(png_structp png_ptr, PNG_CONST char *nptr,
    char **endptr)
d79 1
a79 2
 * assumed that the machine format for signed integers is the same.
 */
d111 1
a111 1
   /* Read the length and the chunk name */
d115 1
a115 1
   /* Put the chunk name into png_ptr->chunk_name */
d121 1
a121 1
   /* Reset the crc and run it over the chunk name */
d125 1
a125 1
   /* Check to see if chunk name is valid */
d135 1
a135 2
   if (png_ptr == NULL)
      return;
d141 3
a143 4
 * are reading a ancillary or critical chunk, and how the program has set
 * things up, we may calculate the CRC on the data and print a message.
 * Returns '1' if there was a CRC error, '0' otherwise.
 */
d162 1
a162 1
          !(png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN)) ||
d179 1
a179 2
 * the data it has read thus far.
 */
d212 11
a222 3
static png_size_t
png_inflate(png_structp png_ptr, const png_byte *data, png_size_t size,
        png_bytep output, png_size_t output_size)
d224 3
a226 1
   png_size_t count = 0;
d228 1
a228 4
   png_ptr->zstream.next_in = (png_bytep)data; /* const_cast: VALID */
   png_ptr->zstream.avail_in = size;

   while (1)
d230 3
a232 5
      int ret, avail;

      /* Reset the output buffer each time round - we empty it
       * after every inflate call.
       */
d234 1
a234 1
      png_ptr->zstream.avail_out = png_ptr->zbuf_size;
d236 2
a237 2
      ret = inflate(&png_ptr->zstream, Z_NO_FLUSH);
      avail = png_ptr->zbuf_size - png_ptr->zstream.avail_out;
d239 1
a239 4
      /* First copy/count any new output - but only if we didn't
       * get an error code.
       */
      if ((ret == Z_OK || ret == Z_STREAM_END) && avail > 0)
d241 2
a242 1
         if (output != 0 && output_size > count)
d244 29
a272 3
            png_size_t copy = output_size - count;
            if ((png_size_t) avail < copy) copy = (png_size_t) avail;
            png_memcpy(output + count, png_ptr->zbuf, copy);
d274 1
a274 24
         count += avail;
      }

      if (ret == Z_OK)
         continue;

      /* Termination conditions - always reset the zstream, it
       * must be left in inflateInit state.
       */
      png_ptr->zstream.avail_in = 0;
      inflateReset(&png_ptr->zstream);

      if (ret == Z_STREAM_END)
         return count; /* NOTE: may be zero. */

      /* Now handle the error codes - the API always returns 0
       * and the error message is dumped into the uncompressed
       * buffer if available.
       */
      {
         PNG_CONST char *msg;
         if (png_ptr->zstream.msg != 0)
            msg = png_ptr->zstream.msg;
         else
d276 20
a295 2
#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)
            char umsg[52];
d297 22
a318 1
            switch (ret)
d320 2
a321 9
               case Z_BUF_ERROR:
                  msg = "Buffer error in compressed datastream in %s chunk";
                  break;
               case Z_DATA_ERROR:
                  msg = "Data error in compressed datastream in %s chunk";
                  break;
               default:
                  msg = "Incomplete compressed datastream in %s chunk";
                  break;
a322 6

            png_snprintf(umsg, sizeof umsg, msg, png_ptr->chunk_name);
            msg = umsg;
#else
            msg = "Damaged compressed datastream in chunk other than IDAT";
#endif
a323 2

         png_warning(png_ptr, msg);
d325 1
a325 53

      /* 0 means an error - notice that this code simple ignores
       * zero length compressed chunks as a result.
       */
      return 0;
   }
}

/*
 * Decompress trailing data in a chunk.  The assumption is that chunkdata
 * points at an allocated area holding the contents of a chunk with a
 * trailing compressed part.  What we get back is an allocated area
 * holding the original prefix part and an uncompressed version of the
 * trailing part (the malloc area passed in is freed).
 */
void /* PRIVATE */
png_decompress_chunk(png_structp png_ptr, int comp_type,
    png_size_t chunklength,
    png_size_t prefix_size, png_size_t *newlength)
{
   /* The caller should guarantee this */
   if (prefix_size > chunklength)
   {
      /* The recovery is to delete the chunk. */
      png_warning(png_ptr, "invalid chunklength");
      prefix_size = 0; /* To delete everything */
   }

   else if (comp_type == PNG_COMPRESSION_TYPE_BASE)
   {
      png_size_t expanded_size = png_inflate(png_ptr,
                (png_bytep)(png_ptr->chunkdata + prefix_size),
                chunklength - prefix_size,
                0/*output*/, 0/*output size*/);

      /* Now check the limits on this chunk - if the limit fails the
       * compressed data will be removed, the prefix will remain.
       */
      if (prefix_size >= (~(png_size_t)0) - 1 ||
         expanded_size >= (~(png_size_t)0) - 1 - prefix_size
#ifdef PNG_USER_CHUNK_MALLOC_MAX
         || ((PNG_USER_CHUNK_MALLOC_MAX > 0) &&
          prefix_size + expanded_size >= PNG_USER_CHUNK_MALLOC_MAX - 1)
#endif
          )
         png_warning(png_ptr, "Exceeded size limit while expanding chunk");

      /* If the size is zero either there was an error and a message
       * has already been output (warning) or the size really is zero
       * and we have nothing to do - the code will exit through the
       * error case below.
       */
      else if (expanded_size > 0)
d327 2
a328 2
         /* Success (maybe) - really uncompress the chunk. */
         png_size_t new_size = 0;
d330 19
a348 4
         png_charp text = png_malloc_warn(png_ptr,
             prefix_size + expanded_size + 1);

         if (text != NULL)
d350 7
a357 16
            new_size = png_inflate(png_ptr,
                (png_bytep)(png_ptr->chunkdata + prefix_size),
                chunklength - prefix_size,
                (png_bytep)(text + prefix_size), expanded_size);
            text[prefix_size + expanded_size] = 0; /* just in case */

            if (new_size == expanded_size)
            {
               png_free(png_ptr, png_ptr->chunkdata);
               png_ptr->chunkdata = text;
               *newlength = prefix_size + expanded_size;
               return; /* The success return! */
            }

            png_warning(png_ptr, "png_inflate logic error");
            png_free(png_ptr, text);
d359 1
a359 2
         else
          png_warning(png_ptr, "Not enough memory to decompress chunk.");
d361 7
a368 1

d371 1
a371 1
#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)
d374 1
a374 2
      png_snprintf(umsg, sizeof umsg, "Unknown zTXt compression type %d",
          comp_type);
d380 2
a381 20
      /* The recovery is to simply drop the data. */
   }

   /* Generic error return - leave the prefix, delete the compressed
    * data, reallocate the chunkdata to remove the potentially large
    * amount of compressed data.
    */
   {
      png_charp text = png_malloc_warn(png_ptr, prefix_size + 1);
      if (text != NULL)
      {
         if (prefix_size > 0)
            png_memcpy(text, png_ptr->chunkdata, prefix_size);
         png_free(png_ptr, png_ptr->chunkdata);
         png_ptr->chunkdata = text;

         /* This is an extra zero in the 'uncompressed' part. */
         *(png_ptr->chunkdata + prefix_size) = 0x00;
      }
      /* Ignore a malloc error here - it is safe. */
a382 2

   *newlength = prefix_size;
d386 1
a386 1
/* Read and check the IDHR chunk */
d400 1
a400 1
   /* Check the length */
d417 1
a417 1
   /* Set internal variables */
d423 1
a423 1
#ifdef PNG_MNG_FEATURES_SUPPORTED
d428 1
a428 1
   /* Find number of channels */
a434 1

a437 1

a440 1

d446 1
a446 1
   /* Set up other useful info */
d457 1
a457 1
/* Read and check the palette */
d463 1
a463 1
#ifdef PNG_POINTER_INDEXING_SUPPORTED
a470 1

a476 1

d489 1
a489 1
#ifndef PNG_READ_OPT_PLTE_SUPPORTED
a504 1

d513 1
a513 1
#ifdef PNG_POINTER_INDEXING_SUPPORTED
d529 1
a529 1
      /* Don't depend upon png_color being any order */
d537 4
a540 5
    * whatever the normal CRC configuration tells us.  However, if we
    * have an RGB image, the PLTE can be considered ancillary, so
    * we will act as though it is.
    */
#ifndef PNG_READ_OPT_PLTE_SUPPORTED
d546 1
a546 1
#ifndef PNG_READ_OPT_PLTE_SUPPORTED
d575 1
a575 1
#ifdef PNG_READ_tRNS_SUPPORTED
d614 1
a614 1
   info_ptr = info_ptr; /* Quiet compiler warnings about unused info_ptr */
d617 1
a617 1
#ifdef PNG_READ_gAMA_SUPPORTED
d642 1
a642 1
#ifdef PNG_READ_sRGB_SUPPORTED
d664 1
a664 1
   /* Check for zero gamma */
d672 1
a672 1
#ifdef PNG_READ_sRGB_SUPPORTED
d678 1
a678 1
#ifdef PNG_CONSOLE_IO_SUPPORTED
d698 1
a698 1
#ifdef PNG_READ_sBIT_SUPPORTED
d764 1
a764 1
#ifdef PNG_READ_cHRM_SUPPORTED
d792 1
a792 1
#ifdef PNG_READ_sRGB_SUPPORTED
d844 1
a844 1
#ifdef PNG_READ_sRGB_SUPPORTED
d858 1
a858 1
#ifdef PNG_CONSOLE_IO_SUPPORTED
d866 1
a866 2
               (long)int_x_white, (long)int_y_white,
               (long)int_x_red, (long)int_y_red);
d868 1
a868 2
               (long)int_x_green, (long)int_y_green,
               (long)int_x_blue, (long)int_y_blue);
d870 1
a870 1
#endif /* PNG_CONSOLE_IO_SUPPORTED */
d888 1
a888 1
#ifdef PNG_READ_sRGB_SUPPORTED
d928 1
a928 1
   /* Check for bad intent */
d950 1
a950 1
#ifdef PNG_CONSOLE_IO_SUPPORTED
d986 1
a986 1
#ifdef PNG_READ_iCCP_SUPPORTED
d1043 1
a1043 1
      /* Empty loop to find end of name */ ;
d1047 2
a1048 3
   /* There should be at least one zero (the compression type byte)
    * following the separator, and we should be on it
    */
d1057 1
a1057 1
   /* Compression_type should always be zero */
d1105 1
a1105 1
#ifdef PNG_READ_sPLT_SUPPORTED
d1112 1
a1112 1
#ifdef PNG_POINTER_INDEXING_SUPPORTED
a1120 17
#ifdef PNG_USER_LIMITS_SUPPORTED

   if (png_ptr->user_chunk_cache_max != 0)
   {
      if (png_ptr->user_chunk_cache_max == 1)
      {
         png_crc_finish(png_ptr, length);
         return;
      }
      if (--png_ptr->user_chunk_cache_max == 1)
      {
         png_warning(png_ptr, "No space in chunk cache for sPLT");
         png_crc_finish(png_ptr, length);
         return;
      }
   }
#endif
d1154 2
a1155 3
   for (entry_start = (png_bytep)png_ptr->chunkdata; *entry_start;
       entry_start++)
      /* Empty loop to find end of name */ ;
d1158 1
a1158 1
   /* A sample depth should follow the separator, and we should be on it  */
d1171 1
a1171 1
   /* Integrity-check the data length */
d1195 1
a1195 1
#ifdef PNG_POINTER_INDEXING_SUPPORTED
d1198 1
a1198 1
      pp = new_palette.entries + i;
d1239 1
a1239 1
   /* Discard all chunk data except the name and stash that */
d1250 1
a1250 1
#ifdef PNG_READ_tRNS_SUPPORTED
d1345 1
a1345 1
#ifdef PNG_READ_bKGD_SUPPORTED
d1434 1
a1434 1
#ifdef PNG_READ_hIST_SUPPORTED
d1464 3
a1466 2
   if (length > 2*PNG_MAX_PALETTE_LENGTH ||
       length != (unsigned int) (2*png_ptr->num_palette))
a1472 2
   num = length / 2 ;

d1488 1
a1488 1
#ifdef PNG_READ_pHYs_SUPPORTED
d1531 1
a1531 1
#ifdef PNG_READ_oFFs_SUPPORTED
d1574 2
a1575 2
#ifdef PNG_READ_pCAL_SUPPORTED
/* Read the pCAL chunk (described in the PNG Extensions document) */
d1622 1
a1622 1
   png_ptr->chunkdata[slength] = 0x00; /* Null terminate the last string */
d1626 1
a1626 1
      /* Empty loop */ ;
d1708 2
a1709 2
#ifdef PNG_READ_sCAL_SUPPORTED
/* Read the sCAL chunk */
a1740 8
   /* Need unit type, width, \0, height: minimum 4 bytes */
   else if (length < 4)
   {
      png_warning(png_ptr, "sCAL chunk too short");
      png_crc_finish(png_ptr, length);
      return;
   }

a1746 1
      png_crc_finish(png_ptr, length);
d1759 1
a1759 1
   png_ptr->chunkdata[slength] = 0x00; /* Null terminate the last string */
d1761 1
a1761 1
   ep = png_ptr->chunkdata + 1;        /* Skip unit byte */
a1767 2
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
a1775 2
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
d1778 1
a1778 1
   png_memcpy(swidth, ep, (png_size_t)png_strlen(ep) + 1);
d1782 2
a1783 2
   for (ep = png_ptr->chunkdata + 1; *ep; ep++)
      /* Empty loop */ ;
d1789 2
a1790 1
#if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)
a1802 5
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
#if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)
      png_free(png_ptr, swidth);
#endif
a1810 5
      png_free(png_ptr, png_ptr->chunkdata);
      png_ptr->chunkdata = NULL;
#if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)
      png_free(png_ptr, swidth);
#endif
d1813 1
a1813 1
   png_memcpy(sheight, ep, (png_size_t)png_strlen(ep) + 1);
d1851 1
a1851 1
#ifdef PNG_READ_tIME_SUPPORTED
d1894 1
a1894 1
#ifdef PNG_READ_tEXt_SUPPORTED
a1907 16
#ifdef PNG_USER_LIMITS_SUPPORTED
   if (png_ptr->user_chunk_cache_max != 0)
   {
      if (png_ptr->user_chunk_cache_max == 1)
      {
         png_crc_finish(png_ptr, length);
         return;
      }
      if (--png_ptr->user_chunk_cache_max == 1)
      {
         png_warning(png_ptr, "No space in chunk cache for tEXt");
         png_crc_finish(png_ptr, length);
         return;
      }
   }
#endif
d1947 1
a1947 1
      /* Empty loop to find end of key */ ;
d1981 2
a1982 2
#ifdef PNG_READ_zTXt_SUPPORTED
/* Note: this does not correctly handle chunks that are > 64K under DOS */
a1993 16
#ifdef PNG_USER_LIMITS_SUPPORTED
   if (png_ptr->user_chunk_cache_max != 0)
   {
      if (png_ptr->user_chunk_cache_max == 1)
      {
         png_crc_finish(png_ptr, length);
         return;
      }
      if (--png_ptr->user_chunk_cache_max == 1)
      {
         png_warning(png_ptr, "No space in chunk cache for zTXt");
         png_crc_finish(png_ptr, length);
         return;
      }
   }
#endif
d2031 1
a2031 1
      /* Empty loop */ ;
d2049 1
a2049 1
       text++;        /* Skip the compression_method byte */
d2085 2
a2086 2
#ifdef PNG_READ_iTXt_SUPPORTED
/* Note: this does not correctly handle chunks that are > 64K under DOS */
a2098 16
#ifdef PNG_USER_LIMITS_SUPPORTED
   if (png_ptr->user_chunk_cache_max != 0)
   {
      if (png_ptr->user_chunk_cache_max == 1)
      {
         png_crc_finish(png_ptr, length);
         return;
      }
      if (--png_ptr->user_chunk_cache_max == 1)
      {
         png_warning(png_ptr, "No space in chunk cache for iTXt");
         png_crc_finish(png_ptr, length);
         return;
      }
   }
#endif
d2136 2
a2137 2
      /* Empty loop */ ;
   lang++;        /* Skip NUL separator */
d2140 2
a2141 3
    * translated keyword (possibly empty), and possibly some text after the
    * keyword
    */
d2157 2
a2158 2
      /* Empty loop */ ;
   lang_key++;        /* Skip NUL separator */
d2169 2
a2170 2
      /* Empty loop */ ;
   text++;        /* Skip NUL separator */
a2225 16
#ifdef PNG_USER_LIMITS_SUPPORTED
   if (png_ptr->user_chunk_cache_max != 0)
   {
      if (png_ptr->user_chunk_cache_max == 1)
      {
         png_crc_finish(png_ptr, length);
         return;
      }
      if (--png_ptr->user_chunk_cache_max == 1)
      {
         png_warning(png_ptr, "No space in chunk cache for unknown chunk");
         png_crc_finish(png_ptr, length);
         return;
      }
   }
#endif
d2232 1
a2232 1
      if (png_memcmp(png_ptr->chunk_name, png_IDAT, 4))  /* Not an IDAT */
d2238 1
a2238 1
#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
d2241 1
a2241 1
#ifdef PNG_READ_USER_CHUNKS_SUPPORTED
d2249 3
a2251 6
#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
   if ((png_ptr->flags & PNG_FLAG_KEEP_UNKNOWN_CHUNKS)
#ifdef PNG_READ_USER_CHUNKS_SUPPORTED
       || (png_ptr->read_user_chunk_fn != NULL)
#endif
        )
d2262 1
a2262 1
                  (png_charp)png_ptr->chunk_name,
d2264 1
a2264 2
       png_ptr->unknown_chunk.name[png_sizeof(png_ptr->unknown_chunk.name)-1]
           = '\0';
d2273 1
a2273 1
#ifdef PNG_READ_USER_CHUNKS_SUPPORTED
d2276 1
a2276 1
          /* Callback to user unknown chunk handler */
a2284 1
#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
a2286 1
#endif
d2304 2
a2305 2
#ifndef PNG_READ_USER_CHUNKS_SUPPORTED
   info_ptr = info_ptr; /* Quiet compiler warnings about unused info_ptr */
d2362 1
a2362 1
#ifdef PNG_READ_PACKSWAP_SUPPORTED
d2417 1
a2417 1
#ifdef PNG_READ_PACKSWAP_SUPPORTED
d2469 1
a2469 1
#ifdef PNG_READ_PACKSWAP_SUPPORTED
d2552 3
a2554 2
   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
   /* Offset to next interlace block */
d2556 1
d2578 1
a2578 1
#ifdef PNG_READ_PACKSWAP_SUPPORTED
d2631 1
a2631 1
#ifdef PNG_READ_PACKSWAP_SUPPORTED
d2687 1
a2687 1
#ifdef PNG_READ_PACKSWAP_SUPPORTED
d2736 1
a2736 2
            png_bytep sp = row + (png_size_t)(row_info->width - 1)
                * pixel_bytes;
d2761 2
a2762 2
#ifndef PNG_READ_PACKSWAP_SUPPORTED
   transformations = transformations; /* Silence compiler warning */
d2846 1
a2846 1
         for (i = 0; i < istop; i++)   /* Use leftover rp,pp */
a2889 1
#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
d2893 1
d2895 1
a2895 1
   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
d2897 1
a2897 1
   /* Start of interlace block */
d2900 1
a2900 1
   /* Offset to next interlace block */
d2903 1
a2903 1
   /* Start of interlace block in the y direction */
d2906 1
a2906 1
   /* Offset to next interlace block in the y direction */
d2909 1
d2932 3
d2993 1
a2993 1
               png_warning(png_ptr, "Extra compressed data.");
d3015 1
a3015 1
      png_warning(png_ptr, "Extra compression data.");
a3020 1
#endif /* PNG_SEQUENTIAL_READ_SUPPORTED */
d3025 1
d3027 1
a3027 1
   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
d3029 1
a3029 1
   /* Start of interlace block */
d3032 1
a3032 1
   /* Offset to next interlace block */
d3035 1
a3035 1
   /* Start of interlace block in the y direction */
d3038 1
a3038 1
   /* Offset to next interlace block in the y direction */
d3041 1
d3062 3
d3071 1
d3075 1
a3075 1
#ifdef PNG_READ_PACK_SUPPORTED
d3080 1
a3080 1
#ifdef PNG_READ_EXPAND_SUPPORTED
d3108 1
a3108 1
#ifdef PNG_READ_FILLER_SUPPORTED
d3130 1
a3130 1
#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
d3134 1
a3134 1
#ifdef PNG_READ_EXPAND_SUPPORTED
d3137 1
a3137 1
#ifdef PNG_READ_FILLER_SUPPORTED
d3175 2
a3176 3
   /* Align the width on the next larger 8 pixels.  Mainly used
    * for interlacing
    */
d3178 2
a3179 3
   /* Calculate the maximum bytes needed, adding a byte and a pixel
    * for safety's sake
    */
d3190 3
a3192 11
     if (png_ptr->interlaced)
        png_ptr->big_row_buf = (png_bytep)png_calloc(png_ptr,
            row_bytes + 64);
     else
        png_ptr->big_row_buf = (png_bytep)png_malloc(png_ptr,
            row_bytes + 64);
     png_ptr->old_big_row_buf_size = row_bytes + 64;

     /* Use 32 bytes of padding before and after row_buf. */
     png_ptr->row_buf = png_ptr->big_row_buf + 32;
     png_ptr->old_big_row_buf_size = row_bytes + 64;
d3196 1
a3196 1
   if ((png_uint_32)row_bytes + 1 > (png_uint_32)65536L)
d3199 1
a3199 1
   if ((png_uint_32)row_bytes > (png_uint_32)(PNG_SIZE_MAX - 1))
d3202 1
a3202 1
   if (row_bytes + 1 > png_ptr->old_prev_row_size)
d3204 4
a3207 5
      png_free(png_ptr, png_ptr->prev_row);
      png_ptr->prev_row = (png_bytep)png_malloc(png_ptr, (png_uint_32)(
        row_bytes + 1));
      png_memset_check(png_ptr, png_ptr->prev_row, 0, row_bytes + 1);
      png_ptr->old_prev_row_size = row_bytes + 1;
d3210 1
a3210 1
   png_ptr->rowbytes = row_bytes;
d3217 1
a3217 2
   png_debug1(3, "irowbytes = %lu",
       PNG_ROWBYTES(png_ptr->pixel_depth, png_ptr->iwidth) + 1);
@


1.1.107.12
log
@update libpng
@
text
@d4 2
a5 2
 * Last changed in libpng 1.2.55 [December 6, 2015]
 * Copyright (c) 1998-2002,2004,2006-2015 Glenn Randers-Pehrson
d60 4
a63 4
   png_uint_32 i = ((png_uint_32)((*(buf    )) & 0xff) << 24) +
                   ((png_uint_32)((*(buf + 1)) & 0xff) << 16) +
                   ((png_uint_32)((*(buf + 2)) & 0xff) <<  8) +
                   ((png_uint_32)((*(buf + 3)) & 0xff)      );
d66 1
a66 1
      png_error(png_ptr, "PNG unsigned integer out of range.");
d74 4
a77 4
   png_uint_32 i = ((png_uint_32)((*(buf    )) & 0xff) << 24) +
                   ((png_uint_32)((*(buf + 1)) & 0xff) << 16) +
                   ((png_uint_32)((*(buf + 2)) & 0xff) <<  8) +
                   ((png_uint_32)((*(buf + 3)) & 0xff)      );
d89 4
a92 4
   png_int_32 i = ((png_int_32)((*(buf    )) & 0xff) << 24) +
                  ((png_int_32)((*(buf + 1)) & 0xff) << 16) +
                  ((png_int_32)((*(buf + 2)) & 0xff) <<  8) +
                  ((png_int_32)((*(buf + 3)) & 0xff)      );
d101 2
a102 2
   png_uint_16 i = ((png_uint_16)((*(buf     )) & 0xff) << 8) +
                   ((png_uint_16)((*(buf +  1)) & 0xff)     );
a296 1
            png_warning(png_ptr, msg);
a301 1
#ifndef PNG_STDIO_SUPPORTED
a302 1
#endif
d506 1
a506 1
   int max_palette_length, num, i;
a557 1
   /* The cast is safe because 'length' is less than 3*PNG_MAX_PALETTE_LENGTH */
a559 13
   /* If the palette has 256 or fewer entries but is too large for the bit
    * depth, we don't issue an error, to preserve the behavior of previous
    * libpng versions. We silently truncate the unused extra palette entries
    * here.
    */
   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      max_palette_length = (1 << png_ptr->bit_depth);
   else
      max_palette_length = PNG_MAX_PALETTE_LENGTH;

   if (num > max_palette_length)
      num = max_palette_length;

d592 1
a592 1
      png_crc_finish(png_ptr, (int) length - num * 3);
d662 1
a662 1
   PNG_UNUSED(info_ptr) /* Quiet compiler warnings about unused info_ptr */
d1100 1
a1100 1
   if (slength < 1U ||  profile >= png_ptr->chunkdata + slength - 1U)
d1133 4
a1136 4
   profile_size = ((png_uint_32) (*(pC    )<<24)) |
                  ((png_uint_32) (*(pC + 1)<<16)) |
                  ((png_uint_32) (*(pC + 2)<< 8)) |
                  ((png_uint_32) (*(pC + 3)    ));
d1228 1
a1228 2
   if (slength < 2U ||
       entry_start > (png_bytep)png_ptr->chunkdata + slength - 2U)
d1702 1
a1702 1
   if (slength < 12U || endptr - buf <= 12)
d2158 1
a2158 1
   if (slength < 2U || text >= png_ptr->chunkdata + slength - 2U)
d2284 1
a2284 1
   if (slength < 3U || lang >= png_ptr->chunkdata + slength - 3U)
d2468 1
a2468 1
   PNG_UNUSED(info_ptr) /* Quiet compiler warnings about unused info_ptr */
a2716 1
#ifndef PNG_USE_GLOBAL_ARRAYS
a2717 1
#endif
d2924 1
a2924 1
   PNG_UNUSED(transformations) /* Silence compiler warning */
a3056 1
#ifndef PNG_USE_GLOBAL_ARRAYS
a3069 1
#endif
a3184 1
#ifndef PNG_USE_GLOBAL_ARRAYS
a3198 1
#endif
@


