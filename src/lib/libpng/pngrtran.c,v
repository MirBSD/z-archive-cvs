head	1.10;
access;
symbols
	png-1_2_57:1.1.107.9
	png-1_2_50:1.1.107.8
	png-1_2_35:1.1.107.7
	png-1_2_32:1.1.107.6
	png-1_2_26:1.1.107.5
	png-1_2_25:1.1.107.5
	MIRBSD_10:1.5.0.2
	MIRBSD_10_BASE:1.5
	png-1_2_18:1.1.107.4
	png-1_2_12:1.1.107.3
	MIRBSD_9_BASE:1.3
	png-1_2_10:1.1.107.2
	MIRBSD_8:1.2.0.2
	MIRBSD_8_BASE:1.2
	png-1_2_8:1.1.107.1
	libpng:1.1.107;
locks; strict;
comment	@ * @;


1.10
date	2017.04.15.15.26.48;	author tg;	state Exp;
branches;
next	1.9;
commitid	10058F23BCC5ED04858;

1.9
date	2013.08.06.18.49.30;	author tg;	state Exp;
branches;
next	1.8;
commitid	1005201454765C5CF06;

1.8
date	2009.03.15.20.08.46;	author tg;	state Exp;
branches;
next	1.7;
commitid	10049BD605834002F74;

1.7
date	2008.10.22.19.11.51;	author tg;	state Exp;
branches;
next	1.6;
commitid	10048FF7AEF54F9B169;

1.6
date	2008.03.23.17.54.55;	author tg;	state Exp;
branches;
next	1.5;
commitid	10047E6997C6BB35CA9;

1.5
date	2007.05.22.20.46.18;	author tg;	state Exp;
branches;
next	1.4;
commitid	100465356AC5C1E9A9B;

1.4
date	2006.06.29.17.14.25;	author tg;	state Exp;
branches;
next	1.3;
commitid	10044A40A7D396C3456;

1.3
date	2006.06.09.00.30.28;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004488C1225295157F;

1.2
date	2005.03.06.20.29.16;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.06.15.16.20;	author tg;	state Exp;
branches
	1.1.107.1;
next	;

1.1.107.1
date	2005.03.06.15.16.20;	author tg;	state Exp;
branches;
next	1.1.107.2;

1.1.107.2
date	2006.06.09.00.13.07;	author tg;	state Exp;
branches;
next	1.1.107.3;
commitid	1004488BD054F510AF1;

1.1.107.3
date	2006.06.29.17.08.59;	author tg;	state Exp;
branches;
next	1.1.107.4;
commitid	10044A409367518C911;

1.1.107.4
date	2007.05.22.20.25.37;	author tg;	state Exp;
branches;
next	1.1.107.5;
commitid	100465351CF4103214A;

1.1.107.5
date	2008.03.23.17.15.18;	author tg;	state Exp;
branches;
next	1.1.107.6;
commitid	10047E69020419198D8;

1.1.107.6
date	2008.10.22.18.55.40;	author tg;	state Exp;
branches;
next	1.1.107.7;
commitid	10048FF773834003AB5;

1.1.107.7
date	2009.03.15.19.57.26;	author tg;	state Exp;
branches;
next	1.1.107.8;
commitid	10049BD5DB90DBE42DE;

1.1.107.8
date	2013.08.06.17.35.05;	author tg;	state Exp;
branches;
next	1.1.107.9;
commitid	100520133D730551D16;

1.1.107.9
date	2017.04.15.15.00.14;	author tg;	state Exp;
branches;
next	;
commitid	10058F2359276DB0E16;


desc
@@


1.10
log
@a rather slow fastmergeâ€¦
@
text
@
/* pngrtran.c - transforms the data in a row for PNG readers
 *
 * Last changed in libpng 1.2.53 [February 26, 2015]
 * Copyright (c) 1998-2002,2004,2006-2015 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 *
 * This file contains functions optionally called by an application
 * in order to tell libpng how to handle data when reading a PNG.
 * Transformations that are used in both reading and writing are
 * in pngtrans.c.
 */

#define PNG_INTERNAL
#define PNG_NO_PEDANTIC_WARNINGS
#include "png.h"
#ifdef PNG_READ_SUPPORTED

/* Set the action on getting a CRC error for an ancillary or critical chunk. */
void PNGAPI
png_set_crc_action(png_structp png_ptr, int crit_action, int ancil_action)
{
   png_debug(1, "in png_set_crc_action");
 
   if (png_ptr == NULL)
      return;

   /* Tell libpng how we react to CRC errors in critical chunks */
   switch (crit_action)
   {
      case PNG_CRC_NO_CHANGE:                        /* Leave setting as is */
         break;

      case PNG_CRC_WARN_USE:                               /* Warn/use data */
         png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
         png_ptr->flags |= PNG_FLAG_CRC_CRITICAL_USE;
         break;

      case PNG_CRC_QUIET_USE:                             /* Quiet/use data */
         png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
         png_ptr->flags |= PNG_FLAG_CRC_CRITICAL_USE |
                           PNG_FLAG_CRC_CRITICAL_IGNORE;
         break;

      case PNG_CRC_WARN_DISCARD:    /* Not a valid action for critical data */
         png_warning(png_ptr,
            "Can't discard critical data on CRC error.");
      case PNG_CRC_ERROR_QUIT:                                /* Error/quit */

      case PNG_CRC_DEFAULT:
      default:
         png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
         break;
   }

   /* Tell libpng how we react to CRC errors in ancillary chunks */
   switch (ancil_action)
   {
      case PNG_CRC_NO_CHANGE:                       /* Leave setting as is */
         break;

      case PNG_CRC_WARN_USE:                              /* Warn/use data */
         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
         png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_USE;
         break;

      case PNG_CRC_QUIET_USE:                            /* Quiet/use data */
         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
         png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_USE |
                           PNG_FLAG_CRC_ANCILLARY_NOWARN;
         break;

      case PNG_CRC_ERROR_QUIT:                               /* Error/quit */
         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
         png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_NOWARN;
         break;

      case PNG_CRC_WARN_DISCARD:                      /* Warn/discard data */

      case PNG_CRC_DEFAULT:
      default:
         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
         break;
   }
}

#if defined(PNG_READ_BACKGROUND_SUPPORTED) && \
    defined(PNG_FLOATING_POINT_SUPPORTED)
/* Handle alpha and tRNS via a background color */
void PNGAPI
png_set_background(png_structp png_ptr,
   png_color_16p background_color, int background_gamma_code,
   int need_expand, double background_gamma)
{
   png_debug(1, "in png_set_background");
 
   if (png_ptr == NULL)
      return;
   if (background_gamma_code == PNG_BACKGROUND_GAMMA_UNKNOWN)
   {
      png_warning(png_ptr, "Application must supply a known background gamma");
      return;
   }

   png_ptr->transformations |= PNG_BACKGROUND;
   png_memcpy(&(png_ptr->background), background_color,
      png_sizeof(png_color_16));
   png_ptr->background_gamma = (float)background_gamma;
   png_ptr->background_gamma_type = (png_byte)(background_gamma_code);
   png_ptr->transformations |= (need_expand ? PNG_BACKGROUND_EXPAND : 0);
}
#endif

#ifdef PNG_READ_16_TO_8_SUPPORTED
/* Strip 16 bit depth files to 8 bit depth */
void PNGAPI
png_set_strip_16(png_structp png_ptr)
{
   png_debug(1, "in png_set_strip_16");

   if (png_ptr == NULL)
      return;
   png_ptr->transformations |= PNG_16_TO_8;
}
#endif

#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
void PNGAPI
png_set_strip_alpha(png_structp png_ptr)
{
   png_debug(1, "in png_set_strip_alpha");

   if (png_ptr == NULL)
      return;
   png_ptr->flags |= PNG_FLAG_STRIP_ALPHA;
}
#endif

#ifdef PNG_READ_DITHER_SUPPORTED
/* Dither file to 8 bit.  Supply a palette, the current number
 * of elements in the palette, the maximum number of elements
 * allowed, and a histogram if possible.  If the current number
 * of colors is greater then the maximum number, the palette will be
 * modified to fit in the maximum number.  "full_dither" indicates
 * whether we need a dithering cube set up for RGB images, or if we
 * simply are reducing the number of colors in a paletted image.
 */

typedef struct png_dsort_struct
{
   struct png_dsort_struct FAR * next;
   png_byte left;
   png_byte right;
} png_dsort;
typedef png_dsort FAR *       png_dsortp;
typedef png_dsort FAR * FAR * png_dsortpp;

void PNGAPI
png_set_dither(png_structp png_ptr, png_colorp palette,
   int num_palette, int maximum_colors, png_uint_16p histogram,
   int full_dither)
{
   png_debug(1, "in png_set_dither");

   if (png_ptr == NULL)
      return;
   png_ptr->transformations |= PNG_DITHER;

   if (!full_dither)
   {
      int i;

      png_ptr->dither_index = (png_bytep)png_malloc(png_ptr,
         (png_uint_32)(num_palette * png_sizeof(png_byte)));
      for (i = 0; i < num_palette; i++)
         png_ptr->dither_index[i] = (png_byte)i;
   }

   if (num_palette > maximum_colors)
   {
      if (histogram != NULL)
      {
         /* This is easy enough, just throw out the least used colors.
          * Perhaps not the best solution, but good enough.
          */

         int i;

         /* Initialize an array to sort colors */
         png_ptr->dither_sort = (png_bytep)png_malloc(png_ptr,
            (png_uint_32)(num_palette * png_sizeof(png_byte)));

         /* Initialize the dither_sort array */
         for (i = 0; i < num_palette; i++)
            png_ptr->dither_sort[i] = (png_byte)i;

         /* Find the least used palette entries by starting a
          * bubble sort, and running it until we have sorted
          * out enough colors.  Note that we don't care about
          * sorting all the colors, just finding which are
          * least used.
          */

         for (i = num_palette - 1; i >= maximum_colors; i--)
         {
            int done; /* To stop early if the list is pre-sorted */
            int j;

            done = 1;
            for (j = 0; j < i; j++)
            {
               if (histogram[png_ptr->dither_sort[j]]
                   < histogram[png_ptr->dither_sort[j + 1]])
               {
                  png_byte t;

                  t = png_ptr->dither_sort[j];
                  png_ptr->dither_sort[j] = png_ptr->dither_sort[j + 1];
                  png_ptr->dither_sort[j + 1] = t;
                  done = 0;
               }
            }
            if (done)
               break;
         }

         /* Swap the palette around, and set up a table, if necessary */
         if (full_dither)
         {
            int j = num_palette;

            /* Put all the useful colors within the max, but don't
             * move the others.
             */
            for (i = 0; i < maximum_colors; i++)
            {
               if ((int)png_ptr->dither_sort[i] >= maximum_colors)
               {
                  do
                     j--;
                  while ((int)png_ptr->dither_sort[j] >= maximum_colors);
                  palette[i] = palette[j];
               }
            }
         }
         else
         {
            int j = num_palette;

            /* Move all the used colors inside the max limit, and
             * develop a translation table.
             */
            for (i = 0; i < maximum_colors; i++)
            {
               /* Only move the colors we need to */
               if ((int)png_ptr->dither_sort[i] >= maximum_colors)
               {
                  png_color tmp_color;

                  do
                     j--;
                  while ((int)png_ptr->dither_sort[j] >= maximum_colors);

                  tmp_color = palette[j];
                  palette[j] = palette[i];
                  palette[i] = tmp_color;
                  /* Indicate where the color went */
                  png_ptr->dither_index[j] = (png_byte)i;
                  png_ptr->dither_index[i] = (png_byte)j;
               }
            }

            /* Find closest color for those colors we are not using */
            for (i = 0; i < num_palette; i++)
            {
               if ((int)png_ptr->dither_index[i] >= maximum_colors)
               {
                  int min_d, k, min_k, d_index;

                  /* Find the closest color to one we threw out */
                  d_index = png_ptr->dither_index[i];
                  min_d = PNG_COLOR_DIST(palette[d_index], palette[0]);
                  for (k = 1, min_k = 0; k < maximum_colors; k++)
                  {
                     int d;

                     d = PNG_COLOR_DIST(palette[d_index], palette[k]);

                     if (d < min_d)
                     {
                        min_d = d;
                        min_k = k;
                     }
                  }
                  /* Point to closest color */
                  png_ptr->dither_index[i] = (png_byte)min_k;
               }
            }
         }
         png_free(png_ptr, png_ptr->dither_sort);
         png_ptr->dither_sort = NULL;
      }
      else
      {
         /* This is much harder to do simply (and quickly).  Perhaps
          * we need to go through a median cut routine, but those
          * don't always behave themselves with only a few colors
          * as input.  So we will just find the closest two colors,
          * and throw out one of them (chosen somewhat randomly).
          * [We don't understand this at all, so if someone wants to
          *  work on improving it, be our guest - AED, GRP]
          */
         int i;
         int max_d;
         int num_new_palette;
         png_dsortp t;
         png_dsortpp hash;

         t = NULL;

         /* Initialize palette index arrays */
         png_ptr->index_to_palette = (png_bytep)png_malloc(png_ptr,
            (png_uint_32)(num_palette * png_sizeof(png_byte)));
         png_ptr->palette_to_index = (png_bytep)png_malloc(png_ptr,
            (png_uint_32)(num_palette * png_sizeof(png_byte)));

         /* Initialize the sort array */
         for (i = 0; i < num_palette; i++)
         {
            png_ptr->index_to_palette[i] = (png_byte)i;
            png_ptr->palette_to_index[i] = (png_byte)i;
         }

         hash = (png_dsortpp)png_calloc(png_ptr, (png_uint_32)(769 *
            png_sizeof(png_dsortp)));

         num_new_palette = num_palette;

         /* Initial wild guess at how far apart the farthest pixel
          * pair we will be eliminating will be.  Larger
          * numbers mean more areas will be allocated, Smaller
          * numbers run the risk of not saving enough data, and
          * having to do this all over again.
          *
          * I have not done extensive checking on this number.
          */
         max_d = 96;

         while (num_new_palette > maximum_colors)
         {
            for (i = 0; i < num_new_palette - 1; i++)
            {
               int j;

               for (j = i + 1; j < num_new_palette; j++)
               {
                  int d;

                  d = PNG_COLOR_DIST(palette[i], palette[j]);

                  if (d <= max_d)
                  {

                     t = (png_dsortp)png_malloc_warn(png_ptr,
                         (png_uint_32)(png_sizeof(png_dsort)));
                     if (t == NULL)
                         break;
                     t->next = hash[d];
                     t->left = (png_byte)i;
                     t->right = (png_byte)j;
                     hash[d] = t;
                  }
               }
               if (t == NULL)
                  break;
            }

            if (t != NULL)
            for (i = 0; i <= max_d; i++)
            {
               if (hash[i] != NULL)
               {
                  png_dsortp p;

                  for (p = hash[i]; p; p = p->next)
                  {
                     if ((int)png_ptr->index_to_palette[p->left]
                        < num_new_palette &&
                        (int)png_ptr->index_to_palette[p->right]
                        < num_new_palette)
                     {
                        int j, next_j;

                        if (num_new_palette & 0x01)
                        {
                           j = p->left;
                           next_j = p->right;
                        }
                        else
                        {
                           j = p->right;
                           next_j = p->left;
                        }

                        num_new_palette--;
                        palette[png_ptr->index_to_palette[j]]
                          = palette[num_new_palette];
                        if (!full_dither)
                        {
                           int k;

                           for (k = 0; k < num_palette; k++)
                           {
                              if (png_ptr->dither_index[k] ==
                                 png_ptr->index_to_palette[j])
                                 png_ptr->dither_index[k] =
                                    png_ptr->index_to_palette[next_j];
                              if ((int)png_ptr->dither_index[k] ==
                                 num_new_palette)
                                 png_ptr->dither_index[k] =
                                    png_ptr->index_to_palette[j];
                           }
                        }

                        png_ptr->index_to_palette[png_ptr->palette_to_index
                           [num_new_palette]] = png_ptr->index_to_palette[j];
                        png_ptr->palette_to_index[png_ptr->index_to_palette[j]]
                           = png_ptr->palette_to_index[num_new_palette];

                        png_ptr->index_to_palette[j] =
                            (png_byte)num_new_palette;
                        png_ptr->palette_to_index[num_new_palette] =
                            (png_byte)j;
                     }
                     if (num_new_palette <= maximum_colors)
                        break;
                  }
                  if (num_new_palette <= maximum_colors)
                     break;
               }
            }

            for (i = 0; i < 769; i++)
            {
               if (hash[i] != NULL)
               {
                  png_dsortp p = hash[i];
                  while (p)
                  {
                     t = p->next;
                     png_free(png_ptr, p);
                     p = t;
                  }
               }
               hash[i] = 0;
            }
            max_d += 96;
         }
         png_free(png_ptr, hash);
         png_free(png_ptr, png_ptr->palette_to_index);
         png_free(png_ptr, png_ptr->index_to_palette);
         png_ptr->palette_to_index = NULL;
         png_ptr->index_to_palette = NULL;
      }
      num_palette = maximum_colors;
   }
   if (png_ptr->palette == NULL)
   {
      png_ptr->palette = palette;
   }
   png_ptr->num_palette = (png_uint_16)num_palette;

   if (full_dither)
   {
      int i;
      png_bytep distance;
      int total_bits = PNG_DITHER_RED_BITS + PNG_DITHER_GREEN_BITS +
         PNG_DITHER_BLUE_BITS;
      int num_red = (1 << PNG_DITHER_RED_BITS);
      int num_green = (1 << PNG_DITHER_GREEN_BITS);
      int num_blue = (1 << PNG_DITHER_BLUE_BITS);
      png_size_t num_entries = ((png_size_t)1 << total_bits);

      png_ptr->palette_lookup = (png_bytep )png_calloc(png_ptr,
         (png_uint_32)(num_entries * png_sizeof(png_byte)));

      distance = (png_bytep)png_malloc(png_ptr, (png_uint_32)(num_entries *
         png_sizeof(png_byte)));
      png_memset(distance, 0xff, num_entries * png_sizeof(png_byte));

      for (i = 0; i < num_palette; i++)
      {
         int ir, ig, ib;
         int r = (palette[i].red >> (8 - PNG_DITHER_RED_BITS));
         int g = (palette[i].green >> (8 - PNG_DITHER_GREEN_BITS));
         int b = (palette[i].blue >> (8 - PNG_DITHER_BLUE_BITS));

         for (ir = 0; ir < num_red; ir++)
         {
            /* int dr = abs(ir - r); */
            int dr = ((ir > r) ? ir - r : r - ir);
            int index_r = (ir << (PNG_DITHER_BLUE_BITS +
                PNG_DITHER_GREEN_BITS));

            for (ig = 0; ig < num_green; ig++)
            {
               /* int dg = abs(ig - g); */
               int dg = ((ig > g) ? ig - g : g - ig);
               int dt = dr + dg;
               int dm = ((dr > dg) ? dr : dg);
               int index_g = index_r | (ig << PNG_DITHER_BLUE_BITS);

               for (ib = 0; ib < num_blue; ib++)
               {
                  int d_index = index_g | ib;
                  /* int db = abs(ib - b); */
                  int db = ((ib > b) ? ib - b : b - ib);
                  int dmax = ((dm > db) ? dm : db);
                  int d = dmax + dt + db;

                  if (d < (int)distance[d_index])
                  {
                     distance[d_index] = (png_byte)d;
                     png_ptr->palette_lookup[d_index] = (png_byte)i;
                  }
               }
            }
         }
      }

      png_free(png_ptr, distance);
   }
}
#endif

#if defined(PNG_READ_GAMMA_SUPPORTED) && defined(PNG_FLOATING_POINT_SUPPORTED)
/* Transform the image from the file_gamma to the screen_gamma.  We
 * only do transformations on images where the file_gamma and screen_gamma
 * are not close reciprocals, otherwise it slows things down slightly, and
 * also needlessly introduces small errors.
 *
 * We will turn off gamma transformation later if no semitransparent entries
 * are present in the tRNS array for palette images.  We can't do it here
 * because we don't necessarily have the tRNS chunk yet.
 */
void PNGAPI
png_set_gamma(png_structp png_ptr, double scrn_gamma, double file_gamma)
{
   png_debug(1, "in png_set_gamma");

   if (png_ptr == NULL)
      return;

   if ((fabs(scrn_gamma * file_gamma - 1.0) > PNG_GAMMA_THRESHOLD) ||
       (png_ptr->color_type & PNG_COLOR_MASK_ALPHA) ||
       (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE))
     png_ptr->transformations |= PNG_GAMMA;
   png_ptr->gamma = (float)file_gamma;
   png_ptr->screen_gamma = (float)scrn_gamma;
}
#endif

#ifdef PNG_READ_EXPAND_SUPPORTED
/* Expand paletted images to RGB, expand grayscale images of
 * less than 8-bit depth to 8-bit depth, and expand tRNS chunks
 * to alpha channels.
 */
void PNGAPI
png_set_expand(png_structp png_ptr)
{
   png_debug(1, "in png_set_expand");

   if (png_ptr == NULL)
      return;

   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
   png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
}

/* GRR 19990627:  the following three functions currently are identical
 *  to png_set_expand().  However, it is entirely reasonable that someone
 *  might wish to expand an indexed image to RGB but *not* expand a single,
 *  fully transparent palette entry to a full alpha channel--perhaps instead
 *  convert tRNS to the grayscale/RGB format (16-bit RGB value), or replace
 *  the transparent color with a particular RGB value, or drop tRNS entirely.
 *  IOW, a future version of the library may make the transformations flag
 *  a bit more fine-grained, with separate bits for each of these three
 *  functions.
 *
 *  More to the point, these functions make it obvious what libpng will be
 *  doing, whereas "expand" can (and does) mean any number of things.
 *
 *  GRP 20060307: In libpng-1.2.9, png_set_gray_1_2_4_to_8() was modified
 *  to expand only the sample depth but not to expand the tRNS to alpha
 *  and its name was changed to png_set_expand_gray_1_2_4_to_8().
 */

/* Expand paletted images to RGB. */
void PNGAPI
png_set_palette_to_rgb(png_structp png_ptr)
{
   png_debug(1, "in png_set_palette_to_rgb");

   if (png_ptr == NULL)
      return;

   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
   png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
}

#ifndef PNG_1_0_X
/* Expand grayscale images of less than 8-bit depth to 8 bits. */
void PNGAPI
png_set_expand_gray_1_2_4_to_8(png_structp png_ptr)
{
   png_debug(1, "in png_set_expand_gray_1_2_4_to_8");

   if (png_ptr == NULL)
      return;

   png_ptr->transformations |= PNG_EXPAND;
   png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
}
#endif

#if defined(PNG_1_0_X) || defined(PNG_1_2_X)
/* Expand grayscale images of less than 8-bit depth to 8 bits. */
/* Deprecated as of libpng-1.2.9 */
void PNGAPI
png_set_gray_1_2_4_to_8(png_structp png_ptr)
{
   png_debug(1, "in png_set_gray_1_2_4_to_8");

   if (png_ptr == NULL)
      return;

   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
}
#endif


/* Expand tRNS chunks to alpha channels. */
void PNGAPI
png_set_tRNS_to_alpha(png_structp png_ptr)
{
   png_debug(1, "in png_set_tRNS_to_alpha");

   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
   png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
}
#endif /* defined(PNG_READ_EXPAND_SUPPORTED) */

#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
void PNGAPI
png_set_gray_to_rgb(png_structp png_ptr)
{
   png_debug(1, "in png_set_gray_to_rgb");

   png_ptr->transformations |= PNG_GRAY_TO_RGB;
   png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
}
#endif

#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
#ifdef PNG_FLOATING_POINT_SUPPORTED
/* Convert a RGB image to a grayscale of the same width.  This allows us,
 * for example, to convert a 24 bpp RGB image into an 8 bpp grayscale image.
 */

void PNGAPI
png_set_rgb_to_gray(png_structp png_ptr, int error_action, double red,
   double green)
{
   int red_fixed, green_fixed;
   if (png_ptr == NULL)
      return;
   if (red > 21474.83647 || red < -21474.83648 ||
       green > 21474.83647 || green < -21474.83648)
   {
      png_warning(png_ptr, "ignoring out of range rgb_to_gray coefficients");
      red_fixed = -1;
      green_fixed = -1;
   }
   else
   {
      red_fixed = (int)((float)red*100000.0 + 0.5);
      green_fixed = (int)((float)green*100000.0 + 0.5);
   }
   png_set_rgb_to_gray_fixed(png_ptr, error_action, red_fixed, green_fixed);
}
#endif

void PNGAPI
png_set_rgb_to_gray_fixed(png_structp png_ptr, int error_action,
   png_fixed_point red, png_fixed_point green)
{
   png_debug(1, "in png_set_rgb_to_gray");

   if (png_ptr == NULL)
      return;

   switch(error_action)
   {
      case 1: png_ptr->transformations |= PNG_RGB_TO_GRAY;
              break;

      case 2: png_ptr->transformations |= PNG_RGB_TO_GRAY_WARN;
              break;

      case 3: png_ptr->transformations |= PNG_RGB_TO_GRAY_ERR;
   }
   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
#ifdef PNG_READ_EXPAND_SUPPORTED
      png_ptr->transformations |= PNG_EXPAND;
#else
   {
      png_warning(png_ptr,
        "Cannot do RGB_TO_GRAY without EXPAND_SUPPORTED.");
      png_ptr->transformations &= ~PNG_RGB_TO_GRAY;
   }
#endif
   {
      png_uint_16 red_int, green_int;
      if (red < 0 || green < 0)
      {
         red_int   =  6968; /* .212671 * 32768 + .5 */
         green_int = 23434; /* .715160 * 32768 + .5 */
      }
      else if (red + green < 100000L)
      {
         red_int = (png_uint_16)(((png_uint_32)red*32768L)/100000L);
         green_int = (png_uint_16)(((png_uint_32)green*32768L)/100000L);
      }
      else
      {
         png_warning(png_ptr, "ignoring out of range rgb_to_gray coefficients");
         red_int   =  6968;
         green_int = 23434;
      }
      png_ptr->rgb_to_gray_red_coeff   = red_int;
      png_ptr->rgb_to_gray_green_coeff = green_int;
      png_ptr->rgb_to_gray_blue_coeff  =
         (png_uint_16)(32768 - red_int - green_int);
   }
}
#endif

#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
    defined(PNG_LEGACY_SUPPORTED) || \
    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
void PNGAPI
png_set_read_user_transform_fn(png_structp png_ptr, png_user_transform_ptr
   read_user_transform_fn)
{
   png_debug(1, "in png_set_read_user_transform_fn");

   if (png_ptr == NULL)
      return;

#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
   png_ptr->transformations |= PNG_USER_TRANSFORM;
   png_ptr->read_user_transform_fn = read_user_transform_fn;
#endif
#ifdef PNG_LEGACY_SUPPORTED
   if (read_user_transform_fn)
      png_warning(png_ptr,
        "This version of libpng does not support user transforms");
#endif
}
#endif

/* Initialize everything needed for the read.  This includes modifying
 * the palette.
 */
void /* PRIVATE */
png_init_read_transformations(png_structp png_ptr)
{
   png_debug(1, "in png_init_read_transformations");

#ifdef PNG_USELESS_TESTS_SUPPORTED
  if (png_ptr != NULL)
#endif
  {
#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \
    defined(PNG_READ_SHIFT_SUPPORTED) || \
    defined(PNG_READ_GAMMA_SUPPORTED)
   int color_type = png_ptr->color_type;
#endif

#if defined(PNG_READ_EXPAND_SUPPORTED) && defined(PNG_READ_BACKGROUND_SUPPORTED)

#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
   /* Detect gray background and attempt to enable optimization
    * for gray --> RGB case
    *
    * Note:  if PNG_BACKGROUND_EXPAND is set and color_type is either RGB or
    * RGB_ALPHA (in which case need_expand is superfluous anyway), the
    * background color might actually be gray yet not be flagged as such.
    * This is not a problem for the current code, which uses
    * PNG_BACKGROUND_IS_GRAY only to decide when to do the
    * png_do_gray_to_rgb() transformation.
    */
   if ((png_ptr->transformations & PNG_BACKGROUND_EXPAND) &&
       !(color_type & PNG_COLOR_MASK_COLOR))
   {
          png_ptr->mode |= PNG_BACKGROUND_IS_GRAY;
   } else if ((png_ptr->transformations & PNG_BACKGROUND) &&
              !(png_ptr->transformations & PNG_BACKGROUND_EXPAND) &&
              (png_ptr->transformations & PNG_GRAY_TO_RGB) &&
              png_ptr->background.red == png_ptr->background.green &&
              png_ptr->background.red == png_ptr->background.blue)
   {
          png_ptr->mode |= PNG_BACKGROUND_IS_GRAY;
          png_ptr->background.gray = png_ptr->background.red;
   }
#endif

   if ((png_ptr->transformations & PNG_BACKGROUND_EXPAND) &&
       (png_ptr->transformations & PNG_EXPAND))
   {
      if (!(color_type & PNG_COLOR_MASK_COLOR))  /* i.e., GRAY or GRAY_ALPHA */
      {
         /* Expand background and tRNS chunks */
         switch (png_ptr->bit_depth)
         {
            case 1:
               png_ptr->background.gray *= (png_uint_16)0xff;
               png_ptr->background.red = png_ptr->background.green
                 =  png_ptr->background.blue = png_ptr->background.gray;
               if (!(png_ptr->transformations & PNG_EXPAND_tRNS))
               {
                 png_ptr->trans_values.gray *= (png_uint_16)0xff;
                 png_ptr->trans_values.red = png_ptr->trans_values.green
                   = png_ptr->trans_values.blue = png_ptr->trans_values.gray;
               }
               break;

            case 2:
               png_ptr->background.gray *= (png_uint_16)0x55;
               png_ptr->background.red = png_ptr->background.green
                 = png_ptr->background.blue = png_ptr->background.gray;
               if (!(png_ptr->transformations & PNG_EXPAND_tRNS))
               {
                 png_ptr->trans_values.gray *= (png_uint_16)0x55;
                 png_ptr->trans_values.red = png_ptr->trans_values.green
                   = png_ptr->trans_values.blue = png_ptr->trans_values.gray;
               }
               break;

            case 4:
               png_ptr->background.gray *= (png_uint_16)0x11;
               png_ptr->background.red = png_ptr->background.green
                 = png_ptr->background.blue = png_ptr->background.gray;
               if (!(png_ptr->transformations & PNG_EXPAND_tRNS))
               {
                 png_ptr->trans_values.gray *= (png_uint_16)0x11;
                 png_ptr->trans_values.red = png_ptr->trans_values.green
                   = png_ptr->trans_values.blue = png_ptr->trans_values.gray;
               }
               break;

            case 8:

            case 16:
               png_ptr->background.red = png_ptr->background.green
                 = png_ptr->background.blue = png_ptr->background.gray;
               break;
         }
      }
      else if (color_type == PNG_COLOR_TYPE_PALETTE)
      {
         png_ptr->background.red   =
            png_ptr->palette[png_ptr->background.index].red;
         png_ptr->background.green =
            png_ptr->palette[png_ptr->background.index].green;
         png_ptr->background.blue  =
            png_ptr->palette[png_ptr->background.index].blue;

#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
        if (png_ptr->transformations & PNG_INVERT_ALPHA)
        {
#ifdef PNG_READ_EXPAND_SUPPORTED
           if (!(png_ptr->transformations & PNG_EXPAND_tRNS))
#endif
           {
           /* Invert the alpha channel (in tRNS) unless the pixels are
            * going to be expanded, in which case leave it for later
            */
              int i, istop;
              istop=(int)png_ptr->num_trans;
              for (i=0; i<istop; i++)
                 png_ptr->trans[i] = (png_byte)(255 - png_ptr->trans[i]);
           }
        }
#endif

      }
   }
#endif

#if defined(PNG_READ_BACKGROUND_SUPPORTED) && defined(PNG_READ_GAMMA_SUPPORTED)
   png_ptr->background_1 = png_ptr->background;
#endif
#if defined(PNG_READ_GAMMA_SUPPORTED) && defined(PNG_FLOATING_POINT_SUPPORTED)

   if ((color_type == PNG_COLOR_TYPE_PALETTE && png_ptr->num_trans != 0)
       && (fabs(png_ptr->screen_gamma * png_ptr->gamma - 1.0)
         < PNG_GAMMA_THRESHOLD))
   {
    int i, k;
    k=0;
    for (i=0; i<png_ptr->num_trans; i++)
    {
      if (png_ptr->trans[i] != 0 && png_ptr->trans[i] != 0xff)
      {
        k=1; /* Partial transparency is present */
        break;
      }
    }
    if (k == 0)
      png_ptr->transformations &= ~PNG_GAMMA;
   }

   if ((png_ptr->transformations & (PNG_GAMMA | PNG_RGB_TO_GRAY)) &&
        png_ptr->gamma != 0.0)
   {
      png_build_gamma_table(png_ptr);

#ifdef PNG_READ_BACKGROUND_SUPPORTED
      if (png_ptr->transformations & PNG_BACKGROUND)
      {
         if (color_type == PNG_COLOR_TYPE_PALETTE)
         {
           /* Could skip if no transparency */
            png_color back, back_1;
            png_colorp palette = png_ptr->palette;
            int num_palette = png_ptr->num_palette;
            int i;
            if (png_ptr->background_gamma_type == PNG_BACKGROUND_GAMMA_FILE)
            {
               back.red = png_ptr->gamma_table[png_ptr->background.red];
               back.green = png_ptr->gamma_table[png_ptr->background.green];
               back.blue = png_ptr->gamma_table[png_ptr->background.blue];

               back_1.red = png_ptr->gamma_to_1[png_ptr->background.red];
               back_1.green = png_ptr->gamma_to_1[png_ptr->background.green];
               back_1.blue = png_ptr->gamma_to_1[png_ptr->background.blue];
            }
            else
            {
               double g, gs;

               switch (png_ptr->background_gamma_type)
               {
                  case PNG_BACKGROUND_GAMMA_SCREEN:
                     g = (png_ptr->screen_gamma);
                     gs = 1.0;
                     break;

                  case PNG_BACKGROUND_GAMMA_FILE:
                     g = 1.0 / (png_ptr->gamma);
                     gs = 1.0 / (png_ptr->gamma * png_ptr->screen_gamma);
                     break;

                  case PNG_BACKGROUND_GAMMA_UNIQUE:
                     g = 1.0 / (png_ptr->background_gamma);
                     gs = 1.0 / (png_ptr->background_gamma *
                                 png_ptr->screen_gamma);
                     break;
                  default:
                     g = 1.0;    /* back_1 */
                     gs = 1.0;   /* back */
               }

               if ( fabs(gs - 1.0) < PNG_GAMMA_THRESHOLD)
               {
                  back.red   = (png_byte)png_ptr->background.red;
                  back.green = (png_byte)png_ptr->background.green;
                  back.blue  = (png_byte)png_ptr->background.blue;
               }
               else
               {
                  back.red = (png_byte)(pow(
                     (double)png_ptr->background.red/255, gs) * 255.0 + .5);
                  back.green = (png_byte)(pow(
                     (double)png_ptr->background.green/255, gs) * 255.0
                         + .5);
                  back.blue = (png_byte)(pow(
                     (double)png_ptr->background.blue/255, gs) * 255.0 + .5);
               }

               back_1.red = (png_byte)(pow(
                  (double)png_ptr->background.red/255, g) * 255.0 + .5);
               back_1.green = (png_byte)(pow(
                  (double)png_ptr->background.green/255, g) * 255.0 + .5);
               back_1.blue = (png_byte)(pow(
                  (double)png_ptr->background.blue/255, g) * 255.0 + .5);
            }
            for (i = 0; i < num_palette; i++)
            {
               if (i < (int)png_ptr->num_trans && png_ptr->trans[i] != 0xff)
               {
                  if (png_ptr->trans[i] == 0)
                  {
                     palette[i] = back;
                  }
                  else /* if (png_ptr->trans[i] != 0xff) */
                  {
                     png_byte v, w;

                     v = png_ptr->gamma_to_1[palette[i].red];
                     png_composite(w, v, png_ptr->trans[i], back_1.red);
                     palette[i].red = png_ptr->gamma_from_1[w];

                     v = png_ptr->gamma_to_1[palette[i].green];
                     png_composite(w, v, png_ptr->trans[i], back_1.green);
                     palette[i].green = png_ptr->gamma_from_1[w];

                     v = png_ptr->gamma_to_1[palette[i].blue];
                     png_composite(w, v, png_ptr->trans[i], back_1.blue);
                     palette[i].blue = png_ptr->gamma_from_1[w];
                  }
               }
               else
               {
                  palette[i].red = png_ptr->gamma_table[palette[i].red];
                  palette[i].green = png_ptr->gamma_table[palette[i].green];
                  palette[i].blue = png_ptr->gamma_table[palette[i].blue];
               }
            }
            /* Prevent the transformations being done again, and make sure
             * that the now spurious alpha channel is stripped - the code
             * has just reduced background composition and gamma correction
             * to a simple alpha channel strip.
             */
            png_ptr->transformations &= ~PNG_BACKGROUND;
            png_ptr->transformations &= ~PNG_GAMMA;
            png_ptr->transformations |= PNG_STRIP_ALPHA;
         }
         /* if (png_ptr->background_gamma_type!=PNG_BACKGROUND_GAMMA_UNKNOWN) */
         else
         /* color_type != PNG_COLOR_TYPE_PALETTE */
         {
            double m = (double)(((png_uint_32)1 << png_ptr->bit_depth) - 1);
            double g = 1.0;
            double gs = 1.0;

            switch (png_ptr->background_gamma_type)
            {
               case PNG_BACKGROUND_GAMMA_SCREEN:
                  g = (png_ptr->screen_gamma);
                  gs = 1.0;
                  break;

               case PNG_BACKGROUND_GAMMA_FILE:
                  g = 1.0 / (png_ptr->gamma);
                  gs = 1.0 / (png_ptr->gamma * png_ptr->screen_gamma);
                  break;

               case PNG_BACKGROUND_GAMMA_UNIQUE:
                  g = 1.0 / (png_ptr->background_gamma);
                  gs = 1.0 / (png_ptr->background_gamma *
                     png_ptr->screen_gamma);
                  break;
            }

            png_ptr->background_1.gray = (png_uint_16)(pow(
               (double)png_ptr->background.gray / m, g) * m + .5);
            png_ptr->background.gray = (png_uint_16)(pow(
               (double)png_ptr->background.gray / m, gs) * m + .5);

            if ((png_ptr->background.red != png_ptr->background.green) ||
                (png_ptr->background.red != png_ptr->background.blue) ||
                (png_ptr->background.red != png_ptr->background.gray))
            {
               /* RGB or RGBA with color background */
               png_ptr->background_1.red = (png_uint_16)(pow(
                  (double)png_ptr->background.red / m, g) * m + .5);
               png_ptr->background_1.green = (png_uint_16)(pow(
                  (double)png_ptr->background.green / m, g) * m + .5);
               png_ptr->background_1.blue = (png_uint_16)(pow(
                  (double)png_ptr->background.blue / m, g) * m + .5);
               png_ptr->background.red = (png_uint_16)(pow(
                  (double)png_ptr->background.red / m, gs) * m + .5);
               png_ptr->background.green = (png_uint_16)(pow(
                  (double)png_ptr->background.green / m, gs) * m + .5);
               png_ptr->background.blue = (png_uint_16)(pow(
                  (double)png_ptr->background.blue / m, gs) * m + .5);
            }
            else
            {
               /* GRAY, GRAY ALPHA, RGB, or RGBA with gray background */
               png_ptr->background_1.red = png_ptr->background_1.green
                 = png_ptr->background_1.blue = png_ptr->background_1.gray;
               png_ptr->background.red = png_ptr->background.green
                 = png_ptr->background.blue = png_ptr->background.gray;
            }
         }
      }
      else
      /* Transformation does not include PNG_BACKGROUND */
#endif /* PNG_READ_BACKGROUND_SUPPORTED */
      if (color_type == PNG_COLOR_TYPE_PALETTE)
      {
         png_colorp palette = png_ptr->palette;
         int num_palette = png_ptr->num_palette;
         int i;

         for (i = 0; i < num_palette; i++)
         {
            palette[i].red = png_ptr->gamma_table[palette[i].red];
            palette[i].green = png_ptr->gamma_table[palette[i].green];
            palette[i].blue = png_ptr->gamma_table[palette[i].blue];
         }

         /* Done the gamma correction. */
         png_ptr->transformations &= ~PNG_GAMMA;
      }
   }
#ifdef PNG_READ_BACKGROUND_SUPPORTED
   else
#endif
#endif /* PNG_READ_GAMMA_SUPPORTED && PNG_FLOATING_POINT_SUPPORTED */
#ifdef PNG_READ_BACKGROUND_SUPPORTED
   /* No GAMMA transformation */
   if ((png_ptr->transformations & PNG_BACKGROUND) &&
       (color_type == PNG_COLOR_TYPE_PALETTE))
   {
      int i;
      int istop = (int)png_ptr->num_trans;
      png_color back;
      png_colorp palette = png_ptr->palette;

      back.red   = (png_byte)png_ptr->background.red;
      back.green = (png_byte)png_ptr->background.green;
      back.blue  = (png_byte)png_ptr->background.blue;

      for (i = 0; i < istop; i++)
      {
         if (png_ptr->trans[i] == 0)
         {
            palette[i] = back;
         }
         else if (png_ptr->trans[i] != 0xff)
         {
            /* The png_composite() macro is defined in png.h */
            png_composite(palette[i].red, palette[i].red,
               png_ptr->trans[i], back.red);
            png_composite(palette[i].green, palette[i].green,
               png_ptr->trans[i], back.green);
            png_composite(palette[i].blue, palette[i].blue,
               png_ptr->trans[i], back.blue);
         }
      }

      /* Handled alpha, still need to strip the channel. */
      png_ptr->transformations &= ~PNG_BACKGROUND;
      png_ptr->transformations |= PNG_STRIP_ALPHA;
   }
#endif /* PNG_READ_BACKGROUND_SUPPORTED */

#ifdef PNG_READ_SHIFT_SUPPORTED
   if ((png_ptr->transformations & PNG_SHIFT) &&
      !(png_ptr->transformations & PNG_EXPAND) &&
      (color_type == PNG_COLOR_TYPE_PALETTE))
   {
      png_uint_16 i;
      png_uint_16 istop = png_ptr->num_palette;
      int sr = 8 - png_ptr->sig_bit.red;
      int sg = 8 - png_ptr->sig_bit.green;
      int sb = 8 - png_ptr->sig_bit.blue;

      if (sr < 0 || sr > 8)
         sr = 0;
      if (sg < 0 || sg > 8)
         sg = 0;
      if (sb < 0 || sb > 8)
         sb = 0;
      for (i = 0; i < istop; i++)
      {
         png_ptr->palette[i].red >>= sr;
         png_ptr->palette[i].green >>= sg;
         png_ptr->palette[i].blue >>= sb;
      }

      png_ptr->transformations &= ~PNG_SHIFT;
   }
#endif  /* PNG_READ_SHIFT_SUPPORTED */
 }
#if !defined(PNG_READ_GAMMA_SUPPORTED) && !defined(PNG_READ_SHIFT_SUPPORTED) \
 && !defined(PNG_READ_BACKGROUND_SUPPORTED)
   if (png_ptr)
      return;
#endif
}

/* Modify the info structure to reflect the transformations.  The
 * info should be updated so a PNG file could be written with it,
 * assuming the transformations result in valid PNG data.
 */
void /* PRIVATE */
png_read_transform_info(png_structp png_ptr, png_infop info_ptr)
{
   png_debug(1, "in png_read_transform_info");

#ifdef PNG_READ_EXPAND_SUPPORTED
   if (png_ptr->transformations & PNG_EXPAND)
   {
      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      {
         if (png_ptr->num_trans)
            info_ptr->color_type = PNG_COLOR_TYPE_RGB_ALPHA;
         else
            info_ptr->color_type = PNG_COLOR_TYPE_RGB;
         info_ptr->bit_depth = 8;
         info_ptr->num_trans = 0;
      }
      else
      {
         if (png_ptr->num_trans)
         {
            if (png_ptr->transformations & PNG_EXPAND_tRNS)
              info_ptr->color_type |= PNG_COLOR_MASK_ALPHA;
         }
         if (info_ptr->bit_depth < 8)
            info_ptr->bit_depth = 8;
         info_ptr->num_trans = 0;
      }
   }
#endif

#ifdef PNG_READ_BACKGROUND_SUPPORTED
   if (png_ptr->transformations & PNG_BACKGROUND)
   {
      info_ptr->color_type &= ~PNG_COLOR_MASK_ALPHA;
      info_ptr->num_trans = 0;
      info_ptr->background = png_ptr->background;
   }
#endif

#ifdef PNG_READ_GAMMA_SUPPORTED
   if (png_ptr->transformations & PNG_GAMMA)
   {
#ifdef PNG_FLOATING_POINT_SUPPORTED
      info_ptr->gamma = png_ptr->gamma;
#endif
#ifdef PNG_FIXED_POINT_SUPPORTED
      info_ptr->int_gamma = png_ptr->int_gamma;
#endif
   }
#endif

#ifdef PNG_READ_16_TO_8_SUPPORTED
   if ((png_ptr->transformations & PNG_16_TO_8) && (info_ptr->bit_depth == 16))
      info_ptr->bit_depth = 8;
#endif

#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
   if (png_ptr->transformations & PNG_GRAY_TO_RGB)
      info_ptr->color_type |= PNG_COLOR_MASK_COLOR;
#endif

#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
   if (png_ptr->transformations & PNG_RGB_TO_GRAY)
      info_ptr->color_type &= ~PNG_COLOR_MASK_COLOR;
#endif

#ifdef PNG_READ_DITHER_SUPPORTED
   if (png_ptr->transformations & PNG_DITHER)
   {
      if (((info_ptr->color_type == PNG_COLOR_TYPE_RGB) ||
          (info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)) &&
          png_ptr->palette_lookup && info_ptr->bit_depth == 8)
      {
         info_ptr->color_type = PNG_COLOR_TYPE_PALETTE;
      }
   }
#endif

#ifdef PNG_READ_PACK_SUPPORTED
   if ((png_ptr->transformations & PNG_PACK) && (info_ptr->bit_depth < 8))
      info_ptr->bit_depth = 8;
#endif

   if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      info_ptr->channels = 1;
   else if (info_ptr->color_type & PNG_COLOR_MASK_COLOR)
      info_ptr->channels = 3;
   else
      info_ptr->channels = 1;

#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
   if (png_ptr->flags & PNG_FLAG_STRIP_ALPHA)
      info_ptr->color_type &= ~PNG_COLOR_MASK_ALPHA;
#endif

   if (info_ptr->color_type & PNG_COLOR_MASK_ALPHA)
      info_ptr->channels++;

#ifdef PNG_READ_FILLER_SUPPORTED
   /* STRIP_ALPHA and FILLER allowed:  MASK_ALPHA bit stripped above */
   if ((png_ptr->transformations & PNG_FILLER) &&
       ((info_ptr->color_type == PNG_COLOR_TYPE_RGB) ||
       (info_ptr->color_type == PNG_COLOR_TYPE_GRAY)))
   {
      info_ptr->channels++;
      /* If adding a true alpha channel not just filler */
#ifndef PNG_1_0_X
      if (png_ptr->transformations & PNG_ADD_ALPHA)
        info_ptr->color_type |= PNG_COLOR_MASK_ALPHA;
#endif
   }
#endif

#if defined(PNG_USER_TRANSFORM_PTR_SUPPORTED) && \
defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
   if (png_ptr->transformations & PNG_USER_TRANSFORM)
     {
       if (info_ptr->bit_depth < png_ptr->user_transform_depth)
         info_ptr->bit_depth = png_ptr->user_transform_depth;
       if (info_ptr->channels < png_ptr->user_transform_channels)
         info_ptr->channels = png_ptr->user_transform_channels;
     }
#endif

   info_ptr->pixel_depth = (png_byte)(info_ptr->channels *
      info_ptr->bit_depth);

   info_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth, info_ptr->width);

#ifndef PNG_READ_EXPAND_SUPPORTED
   if (png_ptr)
      return;
#endif
}

/* Transform the row.  The order of transformations is significant,
 * and is very touchy.  If you add a transformation, take care to
 * decide how it fits in with the other transformations here.
 */
void /* PRIVATE */
png_do_read_transformations(png_structp png_ptr)
{
   png_debug(1, "in png_do_read_transformations");

   if (png_ptr->row_buf == NULL)
   {
#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)
      char msg[50];

      png_snprintf2(msg, 50,
         "NULL row buffer for row %ld, pass %d", (long)png_ptr->row_number,
         png_ptr->pass);
      png_error(png_ptr, msg);
#else
      png_error(png_ptr, "NULL row buffer");
#endif
   }
#ifdef PNG_WARN_UNINITIALIZED_ROW
   if (!(png_ptr->flags & PNG_FLAG_ROW_INIT))
      /* Application has failed to call either png_read_start_image()
       * or png_read_update_info() after setting transforms that expand
       * pixels.  This check added to libpng-1.2.19
       */
#if (PNG_WARN_UNINITIALIZED_ROW==1)
      png_error(png_ptr, "Uninitialized row");
#else
      png_warning(png_ptr, "Uninitialized row");
#endif
#endif

#ifdef PNG_READ_EXPAND_SUPPORTED
   if (png_ptr->transformations & PNG_EXPAND)
   {
      if (png_ptr->row_info.color_type == PNG_COLOR_TYPE_PALETTE)
      {
         if (png_ptr->palette == NULL)
            png_error (png_ptr, "Palette is NULL in indexed image");

         png_do_expand_palette(&(png_ptr->row_info), png_ptr->row_buf + 1,
            png_ptr->palette, png_ptr->trans, png_ptr->num_trans);
      }
      else
      {
         if (png_ptr->num_trans &&
             (png_ptr->transformations & PNG_EXPAND_tRNS))
            png_do_expand(&(png_ptr->row_info), png_ptr->row_buf + 1,
               &(png_ptr->trans_values));
         else
            png_do_expand(&(png_ptr->row_info), png_ptr->row_buf + 1,
               NULL);
      }
   }
#endif

#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
   if (png_ptr->flags & PNG_FLAG_STRIP_ALPHA)
      png_do_strip_filler(&(png_ptr->row_info), png_ptr->row_buf + 1,
         PNG_FLAG_FILLER_AFTER | (png_ptr->flags & PNG_FLAG_STRIP_ALPHA));
#endif

#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
   if (png_ptr->transformations & PNG_RGB_TO_GRAY)
   {
      int rgb_error =
         png_do_rgb_to_gray(png_ptr, &(png_ptr->row_info),
             png_ptr->row_buf + 1);
      if (rgb_error)
      {
         png_ptr->rgb_to_gray_status=1;
         if ((png_ptr->transformations & PNG_RGB_TO_GRAY) ==
             PNG_RGB_TO_GRAY_WARN)
            png_warning(png_ptr, "png_do_rgb_to_gray found nongray pixel");
         if ((png_ptr->transformations & PNG_RGB_TO_GRAY) ==
             PNG_RGB_TO_GRAY_ERR)
            png_error(png_ptr, "png_do_rgb_to_gray found nongray pixel");
      }
   }
#endif

/* From Andreas Dilger e-mail to png-implement, 26 March 1998:
 *
 *   In most cases, the "simple transparency" should be done prior to doing
 *   gray-to-RGB, or you will have to test 3x as many bytes to check if a
 *   pixel is transparent.  You would also need to make sure that the
 *   transparency information is upgraded to RGB.
 *
 *   To summarize, the current flow is:
 *   - Gray + simple transparency -> compare 1 or 2 gray bytes and composite
 *                                   with background "in place" if transparent,
 *                                   convert to RGB if necessary
 *   - Gray + alpha -> composite with gray background and remove alpha bytes,
 *                                   convert to RGB if necessary
 *
 *   To support RGB backgrounds for gray images we need:
 *   - Gray + simple transparency -> convert to RGB + simple transparency,
 *                                   compare 3 or 6 bytes and composite with
 *                                   background "in place" if transparent
 *                                   (3x compare/pixel compared to doing
 *                                   composite with gray bkgrnd)
 *   - Gray + alpha -> convert to RGB + alpha, composite with background and
 *                                   remove alpha bytes (3x float
 *                                   operations/pixel compared with composite
 *                                   on gray background)
 *
 *  Greg's change will do this.  The reason it wasn't done before is for
 *  performance, as this increases the per-pixel operations.  If we would check
 *  in advance if the background was gray or RGB, and position the gray-to-RGB
 *  transform appropriately, then it would save a lot of work/time.
 */

#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
   /* If gray -> RGB, do so now only if background is non-gray; else do later
    * for performance reasons
    */
   if ((png_ptr->transformations & PNG_GRAY_TO_RGB) &&
       !(png_ptr->mode & PNG_BACKGROUND_IS_GRAY))
      png_do_gray_to_rgb(&(png_ptr->row_info), png_ptr->row_buf + 1);
#endif

#ifdef PNG_READ_BACKGROUND_SUPPORTED
   if ((png_ptr->transformations & PNG_BACKGROUND) &&
      ((png_ptr->num_trans != 0 ) ||
      (png_ptr->color_type & PNG_COLOR_MASK_ALPHA)))
      png_do_background(&(png_ptr->row_info), png_ptr->row_buf + 1,
         &(png_ptr->trans_values), &(png_ptr->background)
#ifdef PNG_READ_GAMMA_SUPPORTED
         , &(png_ptr->background_1),
         png_ptr->gamma_table, png_ptr->gamma_from_1,
         png_ptr->gamma_to_1, png_ptr->gamma_16_table,
         png_ptr->gamma_16_from_1, png_ptr->gamma_16_to_1,
         png_ptr->gamma_shift
#endif
);
#endif

#ifdef PNG_READ_GAMMA_SUPPORTED
   if ((png_ptr->transformations & PNG_GAMMA) &&
#ifdef PNG_READ_BACKGROUND_SUPPORTED
       !((png_ptr->transformations & PNG_BACKGROUND) &&
       ((png_ptr->num_trans != 0) ||
       (png_ptr->color_type & PNG_COLOR_MASK_ALPHA))) &&
#endif
       (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE))
      png_do_gamma(&(png_ptr->row_info), png_ptr->row_buf + 1,
          png_ptr->gamma_table, png_ptr->gamma_16_table,
          png_ptr->gamma_shift);
#endif

#ifdef PNG_READ_16_TO_8_SUPPORTED
   if (png_ptr->transformations & PNG_16_TO_8)
      png_do_chop(&(png_ptr->row_info), png_ptr->row_buf + 1);
#endif

#ifdef PNG_READ_DITHER_SUPPORTED
   if (png_ptr->transformations & PNG_DITHER)
   {
      png_do_dither((png_row_infop)&(png_ptr->row_info), png_ptr->row_buf + 1,
         png_ptr->palette_lookup, png_ptr->dither_index);
      if (png_ptr->row_info.rowbytes == (png_uint_32)0)
         png_error(png_ptr, "png_do_dither returned rowbytes=0");
   }
#endif

#ifdef PNG_READ_INVERT_SUPPORTED
   if (png_ptr->transformations & PNG_INVERT_MONO)
      png_do_invert(&(png_ptr->row_info), png_ptr->row_buf + 1);
#endif

#ifdef PNG_READ_SHIFT_SUPPORTED
   if (png_ptr->transformations & PNG_SHIFT)
      png_do_unshift(&(png_ptr->row_info), png_ptr->row_buf + 1,
         &(png_ptr->shift));
#endif

#ifdef PNG_READ_PACK_SUPPORTED
   if (png_ptr->transformations & PNG_PACK)
      png_do_unpack(&(png_ptr->row_info), png_ptr->row_buf + 1);
#endif

#ifdef PNG_READ_BGR_SUPPORTED
   if (png_ptr->transformations & PNG_BGR)
      png_do_bgr(&(png_ptr->row_info), png_ptr->row_buf + 1);
#endif

#ifdef PNG_READ_PACKSWAP_SUPPORTED
   if (png_ptr->transformations & PNG_PACKSWAP)
      png_do_packswap(&(png_ptr->row_info), png_ptr->row_buf + 1);
#endif

#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
   /* If gray -> RGB, do so now only if we did not do so above */
   if ((png_ptr->transformations & PNG_GRAY_TO_RGB) &&
       (png_ptr->mode & PNG_BACKGROUND_IS_GRAY))
      png_do_gray_to_rgb(&(png_ptr->row_info), png_ptr->row_buf + 1);
#endif

#ifdef PNG_READ_FILLER_SUPPORTED
   if (png_ptr->transformations & PNG_FILLER)
      png_do_read_filler(&(png_ptr->row_info), png_ptr->row_buf + 1,
         (png_uint_32)png_ptr->filler, png_ptr->flags);
#endif

#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
   if (png_ptr->transformations & PNG_INVERT_ALPHA)
      png_do_read_invert_alpha(&(png_ptr->row_info), png_ptr->row_buf + 1);
#endif

#ifdef PNG_READ_SWAP_ALPHA_SUPPORTED
   if (png_ptr->transformations & PNG_SWAP_ALPHA)
      png_do_read_swap_alpha(&(png_ptr->row_info), png_ptr->row_buf + 1);
#endif

#ifdef PNG_READ_SWAP_SUPPORTED
   if (png_ptr->transformations & PNG_SWAP_BYTES)
      png_do_swap(&(png_ptr->row_info), png_ptr->row_buf + 1);
#endif

#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
   if (png_ptr->transformations & PNG_USER_TRANSFORM)
    {
      if (png_ptr->read_user_transform_fn != NULL)
         (*(png_ptr->read_user_transform_fn)) /* User read transform function */
            (png_ptr,                    /* png_ptr */
               &(png_ptr->row_info),     /* row_info: */
               /*  png_uint_32 width;       width of row */
               /*  png_uint_32 rowbytes;    number of bytes in row */
               /*  png_byte color_type;     color type of pixels */
               /*  png_byte bit_depth;      bit depth of samples */
               /*  png_byte channels;       number of channels (1-4) */
               /*  png_byte pixel_depth;    bits per pixel (depth*channels) */
               png_ptr->row_buf + 1);    /* start of pixel data for row */
#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED
      if (png_ptr->user_transform_depth)
         png_ptr->row_info.bit_depth = png_ptr->user_transform_depth;
      if (png_ptr->user_transform_channels)
         png_ptr->row_info.channels = png_ptr->user_transform_channels;
#endif
      png_ptr->row_info.pixel_depth = (png_byte)(png_ptr->row_info.bit_depth *
         png_ptr->row_info.channels);
      png_ptr->row_info.rowbytes = PNG_ROWBYTES(png_ptr->row_info.pixel_depth,
         png_ptr->row_info.width);
   }
#endif

}

#ifdef PNG_READ_PACK_SUPPORTED
/* Unpack pixels of 1, 2, or 4 bits per pixel into 1 byte per pixel,
 * without changing the actual values.  Thus, if you had a row with
 * a bit depth of 1, you would end up with bytes that only contained
 * the numbers 0 or 1.  If you would rather they contain 0 and 255, use
 * png_do_shift() after this.
 */
void /* PRIVATE */
png_do_unpack(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_unpack");

#ifdef PNG_USELESS_TESTS_SUPPORTED
   if (row != NULL && row_info != NULL && row_info->bit_depth < 8)
#else
   if (row_info->bit_depth < 8)
#endif
   {
      png_uint_32 i;
      png_uint_32 row_width=row_info->width;

      switch (row_info->bit_depth)
      {
         case 1:
         {
            png_bytep sp = row + (png_size_t)((row_width - 1) >> 3);
            png_bytep dp = row + (png_size_t)row_width - 1;
            png_uint_32 shift = 7 - (int)((row_width + 7) & 0x07);
            for (i = 0; i < row_width; i++)
            {
               *dp = (png_byte)((*sp >> shift) & 0x01);
               if (shift == 7)
               {
                  shift = 0;
                  sp--;
               }
               else
                  shift++;

               dp--;
            }
            break;
         }

         case 2:
         {

            png_bytep sp = row + (png_size_t)((row_width - 1) >> 2);
            png_bytep dp = row + (png_size_t)row_width - 1;
            png_uint_32 shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);
            for (i = 0; i < row_width; i++)
            {
               *dp = (png_byte)((*sp >> shift) & 0x03);
               if (shift == 6)
               {
                  shift = 0;
                  sp--;
               }
               else
                  shift += 2;

               dp--;
            }
            break;
         }

         case 4:
         {
            png_bytep sp = row + (png_size_t)((row_width - 1) >> 1);
            png_bytep dp = row + (png_size_t)row_width - 1;
            png_uint_32 shift = (int)((1 - ((row_width + 1) & 0x01)) << 2);
            for (i = 0; i < row_width; i++)
            {
               *dp = (png_byte)((*sp >> shift) & 0x0f);
               if (shift == 4)
               {
                  shift = 0;
                  sp--;
               }
               else
                  shift = 4;

               dp--;
            }
            break;
         }
      }
      row_info->bit_depth = 8;
      row_info->pixel_depth = (png_byte)(8 * row_info->channels);
      row_info->rowbytes = row_width * row_info->channels;
   }
}
#endif

#ifdef PNG_READ_SHIFT_SUPPORTED
/* Reverse the effects of png_do_shift.  This routine merely shifts the
 * pixels back to their significant bits values.  Thus, if you have
 * a row of bit depth 8, but only 5 are significant, this will shift
 * the values back to 0 through 31.
 */
void /* PRIVATE */
png_do_unshift(png_row_infop row_info, png_bytep row, png_color_8p sig_bits)
{
   png_debug(1, "in png_do_unshift");

   if (
#ifdef PNG_USELESS_TESTS_SUPPORTED
       row != NULL && row_info != NULL && sig_bits != NULL &&
#endif
       row_info->color_type != PNG_COLOR_TYPE_PALETTE)
   {
      int shift[4];
      int channels = 0;
      int c;
      png_uint_16 value = 0;
      png_uint_32 row_width = row_info->width;

      if (row_info->color_type & PNG_COLOR_MASK_COLOR)
      {
         shift[channels++] = row_info->bit_depth - sig_bits->red;
         shift[channels++] = row_info->bit_depth - sig_bits->green;
         shift[channels++] = row_info->bit_depth - sig_bits->blue;
      }
      else
      {
         shift[channels++] = row_info->bit_depth - sig_bits->gray;
      }
      if (row_info->color_type & PNG_COLOR_MASK_ALPHA)
      {
         shift[channels++] = row_info->bit_depth - sig_bits->alpha;
      }

      for (c = 0; c < channels; c++)
      {
         if (shift[c] <= 0)
            shift[c] = 0;
         else
            value = 1;
      }

      if (!value)
         return;

      switch (row_info->bit_depth)
      {
         case 2:
         {
            png_bytep bp;
            png_uint_32 i;
            png_uint_32 istop = row_info->rowbytes;

            for (bp = row, i = 0; i < istop; i++)
            {
               *bp >>= 1;
               *bp++ &= 0x55;
            }
            break;
         }

         case 4:
         {
            png_bytep bp = row;
            png_uint_32 i;
            png_uint_32 istop = row_info->rowbytes;
            png_byte mask = (png_byte)((((int)0xf0 >> shift[0]) & (int)0xf0) |
               (png_byte)((int)0xf >> shift[0]));

            for (i = 0; i < istop; i++)
            {
               *bp >>= shift[0];
               *bp++ &= mask;
            }
            break;
         }

         case 8:
         {
            png_bytep bp = row;
            png_uint_32 i;
            png_uint_32 istop = row_width * channels;

            for (i = 0; i < istop; i++)
            {
               *bp++ >>= shift[i%channels];
            }
            break;
         }

         case 16:
         {
            png_bytep bp = row;
            png_uint_32 i;
            png_uint_32 istop = channels * row_width;

            for (i = 0; i < istop; i++)
            {
               value = (png_uint_16)((*bp << 8) + *(bp + 1));
               value >>= shift[i%channels];
               *bp++ = (png_byte)(value >> 8);
               *bp++ = (png_byte)(value & 0xff);
            }
            break;
         }
      }
   }
}
#endif

#ifdef PNG_READ_16_TO_8_SUPPORTED
/* Chop rows of bit depth 16 down to 8 */
void /* PRIVATE */
png_do_chop(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_chop");

#ifdef PNG_USELESS_TESTS_SUPPORTED
   if (row != NULL && row_info != NULL && row_info->bit_depth == 16)
#else
   if (row_info->bit_depth == 16)
#endif
   {
      png_bytep sp = row;
      png_bytep dp = row;
      png_uint_32 i;
      png_uint_32 istop = row_info->width * row_info->channels;

      for (i = 0; i<istop; i++, sp += 2, dp++)
      {
#ifdef PNG_READ_16_TO_8_ACCURATE_SCALE_SUPPORTED
      /* This does a more accurate scaling of the 16-bit color
       * value, rather than a simple low-byte truncation.
       *
       * What the ideal calculation should be:
       *   *dp = (((((png_uint_32)(*sp) << 8) |
       *          (png_uint_32)(*(sp + 1))) * 255 + 127)
       *          / (png_uint_32)65535L;
       *
       * GRR: no, I think this is what it really should be:
       *   *dp = (((((png_uint_32)(*sp) << 8) |
       *           (png_uint_32)(*(sp + 1))) + 128L)
       *           / (png_uint_32)257L;
       *
       * GRR: here's the exact calculation with shifts:
       *   temp = (((png_uint_32)(*sp) << 8) |
       *           (png_uint_32)(*(sp + 1))) + 128L;
       *   *dp = (temp - (temp >> 8)) >> 8;
       *
       * Approximate calculation with shift/add instead of multiply/divide:
       *   *dp = ((((png_uint_32)(*sp) << 8) |
       *          (png_uint_32)((int)(*(sp + 1)) - *sp)) + 128) >> 8;
       *
       * What we actually do to avoid extra shifting and conversion:
       */

         *dp = *sp + ((((int)(*(sp + 1)) - *sp) > 128) ? 1 : 0);
#else
       /* Simply discard the low order byte */
         *dp = *sp;
#endif
      }
      row_info->bit_depth = 8;
      row_info->pixel_depth = (png_byte)(8 * row_info->channels);
      row_info->rowbytes = row_info->width * row_info->channels;
   }
}
#endif

#ifdef PNG_READ_SWAP_ALPHA_SUPPORTED
void /* PRIVATE */
png_do_read_swap_alpha(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_read_swap_alpha");

#ifdef PNG_USELESS_TESTS_SUPPORTED
   if (row != NULL && row_info != NULL)
#endif
   {
      png_uint_32 row_width = row_info->width;
      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
      {
         /* This converts from RGBA to ARGB */
         if (row_info->bit_depth == 8)
         {
            png_bytep sp = row + row_info->rowbytes;
            png_bytep dp = sp;
            png_byte save;
            png_uint_32 i;

            for (i = 0; i < row_width; i++)
            {
               save = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = save;
            }
         }
         /* This converts from RRGGBBAA to AARRGGBB */
         else
         {
            png_bytep sp = row + row_info->rowbytes;
            png_bytep dp = sp;
            png_byte save[2];
            png_uint_32 i;

            for (i = 0; i < row_width; i++)
            {
               save[0] = *(--sp);
               save[1] = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = save[0];
               *(--dp) = save[1];
            }
         }
      }
      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
      {
         /* This converts from GA to AG */
         if (row_info->bit_depth == 8)
         {
            png_bytep sp = row + row_info->rowbytes;
            png_bytep dp = sp;
            png_byte save;
            png_uint_32 i;

            for (i = 0; i < row_width; i++)
            {
               save = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = save;
            }
         }
         /* This converts from GGAA to AAGG */
         else
         {
            png_bytep sp = row + row_info->rowbytes;
            png_bytep dp = sp;
            png_byte save[2];
            png_uint_32 i;

            for (i = 0; i < row_width; i++)
            {
               save[0] = *(--sp);
               save[1] = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = save[0];
               *(--dp) = save[1];
            }
         }
      }
   }
}
#endif

#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
void /* PRIVATE */
png_do_read_invert_alpha(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_read_invert_alpha");

#ifdef PNG_USELESS_TESTS_SUPPORTED
   if (row != NULL && row_info != NULL)
#endif
   {
      png_uint_32 row_width = row_info->width;
      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
      {
         /* This inverts the alpha channel in RGBA */
         if (row_info->bit_depth == 8)
         {
            png_bytep sp = row + row_info->rowbytes;
            png_bytep dp = sp;
            png_uint_32 i;

            for (i = 0; i < row_width; i++)
            {
               *(--dp) = (png_byte)(255 - *(--sp));

/*             This does nothing:
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               We can replace it with:
*/
               sp-=3;
               dp=sp;
            }
         }
         /* This inverts the alpha channel in RRGGBBAA */
         else
         {
            png_bytep sp = row + row_info->rowbytes;
            png_bytep dp = sp;
            png_uint_32 i;

            for (i = 0; i < row_width; i++)
            {
               *(--dp) = (png_byte)(255 - *(--sp));
               *(--dp) = (png_byte)(255 - *(--sp));

/*             This does nothing:
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               We can replace it with:
*/
               sp-=6;
               dp=sp;
            }
         }
      }
      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
      {
         /* This inverts the alpha channel in GA */
         if (row_info->bit_depth == 8)
         {
            png_bytep sp = row + row_info->rowbytes;
            png_bytep dp = sp;
            png_uint_32 i;

            for (i = 0; i < row_width; i++)
            {
               *(--dp) = (png_byte)(255 - *(--sp));
               *(--dp) = *(--sp);
            }
         }
         /* This inverts the alpha channel in GGAA */
         else
         {
            png_bytep sp  = row + row_info->rowbytes;
            png_bytep dp = sp;
            png_uint_32 i;

            for (i = 0; i < row_width; i++)
            {
               *(--dp) = (png_byte)(255 - *(--sp));
               *(--dp) = (png_byte)(255 - *(--sp));
/*
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
*/
               sp-=2;
               dp=sp;
            }
         }
      }
   }
}
#endif

#ifdef PNG_READ_FILLER_SUPPORTED
/* Add filler channel if we have RGB color */
void /* PRIVATE */
png_do_read_filler(png_row_infop row_info, png_bytep row,
   png_uint_32 filler, png_uint_32 flags)
{
   png_uint_32 i;
   png_uint_32 row_width = row_info->width;

   png_byte hi_filler = (png_byte)((filler>>8) & 0xff);
   png_byte lo_filler = (png_byte)(filler & 0xff);

   png_debug(1, "in png_do_read_filler");

   if (
#ifdef PNG_USELESS_TESTS_SUPPORTED
       row != NULL  && row_info != NULL &&
#endif
       row_info->color_type == PNG_COLOR_TYPE_GRAY)
   {
      if (row_info->bit_depth == 8)
      {
         /* This changes the data from G to GX */
         if (flags & PNG_FLAG_FILLER_AFTER)
         {
            png_bytep sp = row + (png_size_t)row_width;
            png_bytep dp =  sp + (png_size_t)row_width;
            for (i = 1; i < row_width; i++)
            {
               *(--dp) = lo_filler;
               *(--dp) = *(--sp);
            }
            *(--dp) = lo_filler;
            row_info->channels = 2;
            row_info->pixel_depth = 16;
            row_info->rowbytes = row_width * 2;
         }
      /* This changes the data from G to XG */
         else
         {
            png_bytep sp = row + (png_size_t)row_width;
            png_bytep dp = sp  + (png_size_t)row_width;
            for (i = 0; i < row_width; i++)
            {
               *(--dp) = *(--sp);
               *(--dp) = lo_filler;
            }
            row_info->channels = 2;
            row_info->pixel_depth = 16;
            row_info->rowbytes = row_width * 2;
         }
      }
      else if (row_info->bit_depth == 16)
      {
         /* This changes the data from GG to GGXX */
         if (flags & PNG_FLAG_FILLER_AFTER)
         {
            png_bytep sp = row + (png_size_t)row_width * 2;
            png_bytep dp = sp  + (png_size_t)row_width * 2;
            for (i = 1; i < row_width; i++)
            {
               *(--dp) = hi_filler;
               *(--dp) = lo_filler;
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
            }
            *(--dp) = hi_filler;
            *(--dp) = lo_filler;
            row_info->channels = 2;
            row_info->pixel_depth = 32;
            row_info->rowbytes = row_width * 4;
         }
         /* This changes the data from GG to XXGG */
         else
         {
            png_bytep sp = row + (png_size_t)row_width * 2;
            png_bytep dp = sp  + (png_size_t)row_width * 2;
            for (i = 0; i < row_width; i++)
            {
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = hi_filler;
               *(--dp) = lo_filler;
            }
            row_info->channels = 2;
            row_info->pixel_depth = 32;
            row_info->rowbytes = row_width * 4;
         }
      }
   } /* COLOR_TYPE == GRAY */
   else if (row_info->color_type == PNG_COLOR_TYPE_RGB)
   {
      if (row_info->bit_depth == 8)
      {
         /* This changes the data from RGB to RGBX */
         if (flags & PNG_FLAG_FILLER_AFTER)
         {
            png_bytep sp = row + (png_size_t)row_width * 3;
            png_bytep dp = sp  + (png_size_t)row_width;
            for (i = 1; i < row_width; i++)
            {
               *(--dp) = lo_filler;
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
            }
            *(--dp) = lo_filler;
            row_info->channels = 4;
            row_info->pixel_depth = 32;
            row_info->rowbytes = row_width * 4;
         }
      /* This changes the data from RGB to XRGB */
         else
         {
            png_bytep sp = row + (png_size_t)row_width * 3;
            png_bytep dp = sp + (png_size_t)row_width;
            for (i = 0; i < row_width; i++)
            {
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = lo_filler;
            }
            row_info->channels = 4;
            row_info->pixel_depth = 32;
            row_info->rowbytes = row_width * 4;
         }
      }
      else if (row_info->bit_depth == 16)
      {
         /* This changes the data from RRGGBB to RRGGBBXX */
         if (flags & PNG_FLAG_FILLER_AFTER)
         {
            png_bytep sp = row + (png_size_t)row_width * 6;
            png_bytep dp = sp  + (png_size_t)row_width * 2;
            for (i = 1; i < row_width; i++)
            {
               *(--dp) = hi_filler;
               *(--dp) = lo_filler;
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
            }
            *(--dp) = hi_filler;
            *(--dp) = lo_filler;
            row_info->channels = 4;
            row_info->pixel_depth = 64;
            row_info->rowbytes = row_width * 8;
         }
         /* This changes the data from RRGGBB to XXRRGGBB */
         else
         {
            png_bytep sp = row + (png_size_t)row_width * 6;
            png_bytep dp = sp  + (png_size_t)row_width * 2;
            for (i = 0; i < row_width; i++)
            {
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = hi_filler;
               *(--dp) = lo_filler;
            }
            row_info->channels = 4;
            row_info->pixel_depth = 64;
            row_info->rowbytes = row_width * 8;
         }
      }
   } /* COLOR_TYPE == RGB */
}
#endif

#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
/* Expand grayscale files to RGB, with or without alpha */
void /* PRIVATE */
png_do_gray_to_rgb(png_row_infop row_info, png_bytep row)
{
   png_uint_32 i;
   png_uint_32 row_width = row_info->width;

   png_debug(1, "in png_do_gray_to_rgb");

   if (row_info->bit_depth >= 8 &&
#ifdef PNG_USELESS_TESTS_SUPPORTED
       row != NULL && row_info != NULL &&
#endif
      !(row_info->color_type & PNG_COLOR_MASK_COLOR))
   {
      if (row_info->color_type == PNG_COLOR_TYPE_GRAY)
      {
         if (row_info->bit_depth == 8)
         {
            png_bytep sp = row + (png_size_t)row_width - 1;
            png_bytep dp = sp  + (png_size_t)row_width * 2;
            for (i = 0; i < row_width; i++)
            {
               *(dp--) = *sp;
               *(dp--) = *sp;
               *(dp--) = *(sp--);
            }
         }
         else
         {
            png_bytep sp = row + (png_size_t)row_width * 2 - 1;
            png_bytep dp = sp  + (png_size_t)row_width * 4;
            for (i = 0; i < row_width; i++)
            {
               *(dp--) = *sp;
               *(dp--) = *(sp - 1);
               *(dp--) = *sp;
               *(dp--) = *(sp - 1);
               *(dp--) = *(sp--);
               *(dp--) = *(sp--);
            }
         }
      }
      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
      {
         if (row_info->bit_depth == 8)
         {
            png_bytep sp = row + (png_size_t)row_width * 2 - 1;
            png_bytep dp = sp  + (png_size_t)row_width * 2;
            for (i = 0; i < row_width; i++)
            {
               *(dp--) = *(sp--);
               *(dp--) = *sp;
               *(dp--) = *sp;
               *(dp--) = *(sp--);
            }
         }
         else
         {
            png_bytep sp = row + (png_size_t)row_width * 4 - 1;
            png_bytep dp = sp  + (png_size_t)row_width * 4;
            for (i = 0; i < row_width; i++)
            {
               *(dp--) = *(sp--);
               *(dp--) = *(sp--);
               *(dp--) = *sp;
               *(dp--) = *(sp - 1);
               *(dp--) = *sp;
               *(dp--) = *(sp - 1);
               *(dp--) = *(sp--);
               *(dp--) = *(sp--);
            }
         }
      }
      row_info->channels += (png_byte)2;
      row_info->color_type |= PNG_COLOR_MASK_COLOR;
      row_info->pixel_depth = (png_byte)(row_info->channels *
         row_info->bit_depth);
      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
   }
}
#endif

#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
/* Reduce RGB files to grayscale, with or without alpha
 * using the equation given in Poynton's ColorFAQ at
 * <http://www.inforamp.net/~poynton/>  (THIS LINK IS DEAD June 2008)
 * New link:
 * <http://www.poynton.com/notes/colour_and_gamma/>
 * Charles Poynton poynton at poynton.com
 *
 *     Y = 0.212671 * R + 0.715160 * G + 0.072169 * B
 *
 *  We approximate this with
 *
 *     Y = 0.21268 * R    + 0.7151 * G    + 0.07217 * B
 *
 *  which can be expressed with integers as
 *
 *     Y = (6969 * R + 23434 * G + 2365 * B)/32768
 *
 *  The calculation is to be done in a linear colorspace.
 *
 *  Other integer coefficents can be used via png_set_rgb_to_gray().
 */
int /* PRIVATE */
png_do_rgb_to_gray(png_structp png_ptr, png_row_infop row_info, png_bytep row)

{
   png_uint_32 i;

   png_uint_32 row_width = row_info->width;
   int rgb_error = 0;

   png_debug(1, "in png_do_rgb_to_gray");

   if (
#ifdef PNG_USELESS_TESTS_SUPPORTED
       row != NULL && row_info != NULL &&
#endif
      (row_info->color_type & PNG_COLOR_MASK_COLOR))
   {
      png_uint_32 rc = png_ptr->rgb_to_gray_red_coeff;
      png_uint_32 gc = png_ptr->rgb_to_gray_green_coeff;
      png_uint_32 bc = png_ptr->rgb_to_gray_blue_coeff;

      if (row_info->color_type == PNG_COLOR_TYPE_RGB)
      {
         if (row_info->bit_depth == 8)
         {
#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
            if (png_ptr->gamma_from_1 != NULL && png_ptr->gamma_to_1 != NULL)
            {
               png_bytep sp = row;
               png_bytep dp = row;

               for (i = 0; i < row_width; i++)
               {
                  png_byte red   = png_ptr->gamma_to_1[*(sp++)];
                  png_byte green = png_ptr->gamma_to_1[*(sp++)];
                  png_byte blue  = png_ptr->gamma_to_1[*(sp++)];
                  if (red != green || red != blue)
                  {
                     rgb_error |= 1;
                     *(dp++) = png_ptr->gamma_from_1[
                       (rc*red + gc*green + bc*blue)>>15];
                  }
                  else
                     *(dp++) = *(sp - 1);
               }
            }
            else
#endif
            {
               png_bytep sp = row;
               png_bytep dp = row;
               for (i = 0; i < row_width; i++)
               {
                  png_byte red   = *(sp++);
                  png_byte green = *(sp++);
                  png_byte blue  = *(sp++);
                  if (red != green || red != blue)
                  {
                     rgb_error |= 1;
                     *(dp++) = (png_byte)((rc*red + gc*green + bc*blue)>>15);
                  }
                  else
                     *(dp++) = *(sp - 1);
               }
            }
         }

         else /* RGB bit_depth == 16 */
         {
#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
            if (png_ptr->gamma_16_to_1 != NULL &&
                png_ptr->gamma_16_from_1 != NULL)
            {
               png_bytep sp = row;
               png_bytep dp = row;
               for (i = 0; i < row_width; i++)
               {
                  png_uint_16 red, green, blue, w;
                  png_byte hi,lo;

                  hi=*(sp)++; lo=*(sp)++;
                  red   = (png_uint_16)((hi << 8) | (lo));
                  hi=*(sp)++; lo=*(sp)++;
                  green = (png_uint_16)((hi << 8) | (lo));
                  hi=*(sp)++; lo=*(sp)++;
                  blue  = (png_uint_16)((hi << 8) | (lo));

                  if (red == green && red == blue)
                     w = red;
                  else
                  {
                     png_uint_16 red_1   = png_ptr->gamma_16_to_1[(red&0xff) >>
                                  png_ptr->gamma_shift][red>>8];
                     png_uint_16 green_1 =
                         png_ptr->gamma_16_to_1[(green&0xff) >>
                                  png_ptr->gamma_shift][green>>8];
                     png_uint_16 blue_1  = png_ptr->gamma_16_to_1[(blue&0xff) >>
                                  png_ptr->gamma_shift][blue>>8];
                     png_uint_16 gray16  = (png_uint_16)((rc*red_1 + gc*green_1
                                  + bc*blue_1)>>15);
                     w = png_ptr->gamma_16_from_1[(gray16&0xff) >>
                         png_ptr->gamma_shift][gray16 >> 8];
                     rgb_error |= 1;
                  }

                  *(dp++) = (png_byte)((w>>8) & 0xff);
                  *(dp++) = (png_byte)(w & 0xff);
               }
            }
            else
#endif
            {
               png_bytep sp = row;
               png_bytep dp = row;
               for (i = 0; i < row_width; i++)
               {
                  png_uint_16 red, green, blue, gray16;
                  png_byte hi,lo;

                  hi=*(sp)++; lo=*(sp)++;
                  red   = (png_uint_16)((hi << 8) | (lo));
                  hi=*(sp)++; lo=*(sp)++;
                  green = (png_uint_16)((hi << 8) | (lo));
                  hi=*(sp)++; lo=*(sp)++;
                  blue  = (png_uint_16)((hi << 8) | (lo));

                  if (red != green || red != blue)
                     rgb_error |= 1;
                  gray16  = (png_uint_16)((rc*red + gc*green + bc*blue)>>15);
                  *(dp++) = (png_byte)((gray16>>8) & 0xff);
                  *(dp++) = (png_byte)(gray16 & 0xff);
               }
            }
         }
      }
      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
      {
         if (row_info->bit_depth == 8)
         {
#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
            if (png_ptr->gamma_from_1 != NULL && png_ptr->gamma_to_1 != NULL)
            {
               png_bytep sp = row;
               png_bytep dp = row;
               for (i = 0; i < row_width; i++)
               {
                  png_byte red   = png_ptr->gamma_to_1[*(sp++)];
                  png_byte green = png_ptr->gamma_to_1[*(sp++)];
                  png_byte blue  = png_ptr->gamma_to_1[*(sp++)];
                  if (red != green || red != blue)
                     rgb_error |= 1;
                  *(dp++) =  png_ptr->gamma_from_1
                             [(rc*red + gc*green + bc*blue)>>15];
                  *(dp++) = *(sp++);  /* alpha */
               }
            }
            else
#endif
            {
               png_bytep sp = row;
               png_bytep dp = row;
               for (i = 0; i < row_width; i++)
               {
                  png_byte red   = *(sp++);
                  png_byte green = *(sp++);
                  png_byte blue  = *(sp++);
                  if (red != green || red != blue)
                     rgb_error |= 1;
                  *(dp++) =  (png_byte)((rc*red + gc*green + bc*blue)>>15);
                  *(dp++) = *(sp++);  /* alpha */
               }
            }
         }
         else /* RGBA bit_depth == 16 */
         {
#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
            if (png_ptr->gamma_16_to_1 != NULL &&
                png_ptr->gamma_16_from_1 != NULL)
            {
               png_bytep sp = row;
               png_bytep dp = row;
               for (i = 0; i < row_width; i++)
               {
                  png_uint_16 red, green, blue, w;
                  png_byte hi,lo;

                  hi=*(sp)++; lo=*(sp)++;
                  red   = (png_uint_16)((hi << 8) | (lo));
                  hi=*(sp)++; lo=*(sp)++;
                  green = (png_uint_16)((hi << 8) | (lo));
                  hi=*(sp)++; lo=*(sp)++;
                  blue  = (png_uint_16)((hi << 8) | (lo));

                  if (red == green && red == blue)
                     w = red;
                  else
                  {
                     png_uint_16 red_1   = png_ptr->gamma_16_to_1[(red&0xff) >>
                         png_ptr->gamma_shift][red>>8];
                     png_uint_16 green_1 =
                         png_ptr->gamma_16_to_1[(green&0xff) >>
                         png_ptr->gamma_shift][green>>8];
                     png_uint_16 blue_1  = png_ptr->gamma_16_to_1[(blue&0xff) >>
                         png_ptr->gamma_shift][blue>>8];
                     png_uint_16 gray16  = (png_uint_16)((rc * red_1
                         + gc * green_1 + bc * blue_1)>>15);
                     w = png_ptr->gamma_16_from_1[(gray16&0xff) >>
                         png_ptr->gamma_shift][gray16 >> 8];
                     rgb_error |= 1;
                  }

                  *(dp++) = (png_byte)((w>>8) & 0xff);
                  *(dp++) = (png_byte)(w & 0xff);
                  *(dp++) = *(sp++);  /* alpha */
                  *(dp++) = *(sp++);
               }
            }
            else
#endif
            {
               png_bytep sp = row;
               png_bytep dp = row;
               for (i = 0; i < row_width; i++)
               {
                  png_uint_16 red, green, blue, gray16;
                  red   = (png_uint_16)((*(sp)<<8) | *(sp+1)); sp+=2;
                  green = (png_uint_16)((*(sp)<<8) | *(sp+1)); sp+=2;
                  blue  = (png_uint_16)((*(sp)<<8) | *(sp+1)); sp+=2;
                  if (red != green || red != blue)
                     rgb_error |= 1;
                  gray16  = (png_uint_16)((rc*red + gc*green + bc*blue)>>15);
                  *(dp++) = (png_byte)((gray16>>8) & 0xff);
                  *(dp++) = (png_byte)(gray16 & 0xff);
                  *(dp++) = *(sp++);  /* alpha */
                  *(dp++) = *(sp++);
               }
            }
         }
      }
   row_info->channels -= (png_byte)2;
      row_info->color_type &= ~PNG_COLOR_MASK_COLOR;
      row_info->pixel_depth = (png_byte)(row_info->channels *
         row_info->bit_depth);
      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
   }
   return rgb_error;
}
#endif

/* Build a grayscale palette.  Palette is assumed to be 1 << bit_depth
 * large of png_color.  This lets grayscale images be treated as
 * paletted.  Most useful for gamma correction and simplification
 * of code.
 */
void PNGAPI
png_build_grayscale_palette(int bit_depth, png_colorp palette)
{
   int num_palette;
   int color_inc;
   int i;
   int v;

   png_debug(1, "in png_do_build_grayscale_palette");

   if (palette == NULL)
      return;

   switch (bit_depth)
   {
      case 1:
         num_palette = 2;
         color_inc = 0xff;
         break;

      case 2:
         num_palette = 4;
         color_inc = 0x55;
         break;

      case 4:
         num_palette = 16;
         color_inc = 0x11;
         break;

      case 8:
         num_palette = 256;
         color_inc = 1;
         break;

      default:
         num_palette = 0;
         color_inc = 0;
         break;
   }

   for (i = 0, v = 0; i < num_palette; i++, v += color_inc)
   {
      palette[i].red = (png_byte)v;
      palette[i].green = (png_byte)v;
      palette[i].blue = (png_byte)v;
   }
}

/* This function is currently unused.  Do we really need it? */
#if defined(PNG_READ_DITHER_SUPPORTED) && \
  defined(PNG_CORRECT_PALETTE_SUPPORTED)
void /* PRIVATE */
png_correct_palette(png_structp png_ptr, png_colorp palette,
   int num_palette)
{
   png_debug(1, "in png_correct_palette");

#if defined(PNG_READ_BACKGROUND_SUPPORTED) && \
    defined(PNG_READ_GAMMA_SUPPORTED) && \
  defined(PNG_FLOATING_POINT_SUPPORTED)
   if (png_ptr->transformations & (PNG_GAMMA | PNG_BACKGROUND))
   {
      png_color back, back_1;

      if (png_ptr->background_gamma_type == PNG_BACKGROUND_GAMMA_FILE)
      {
         back.red = png_ptr->gamma_table[png_ptr->background.red];
         back.green = png_ptr->gamma_table[png_ptr->background.green];
         back.blue = png_ptr->gamma_table[png_ptr->background.blue];

         back_1.red = png_ptr->gamma_to_1[png_ptr->background.red];
         back_1.green = png_ptr->gamma_to_1[png_ptr->background.green];
         back_1.blue = png_ptr->gamma_to_1[png_ptr->background.blue];
      }
      else
      {
         double g;

         g = 1.0 / (png_ptr->background_gamma * png_ptr->screen_gamma);

         if (png_ptr->background_gamma_type == PNG_BACKGROUND_GAMMA_SCREEN
             || fabs(g - 1.0) < PNG_GAMMA_THRESHOLD)
         {
            back.red = png_ptr->background.red;
            back.green = png_ptr->background.green;
            back.blue = png_ptr->background.blue;
         }
         else
         {
            back.red =
               (png_byte)(pow((double)png_ptr->background.red/255, g) *
                255.0 + 0.5);
            back.green =
               (png_byte)(pow((double)png_ptr->background.green/255, g) *
                255.0 + 0.5);
            back.blue =
               (png_byte)(pow((double)png_ptr->background.blue/255, g) *
                255.0 + 0.5);
         }

         g = 1.0 / png_ptr->background_gamma;

         back_1.red =
            (png_byte)(pow((double)png_ptr->background.red/255, g) *
             255.0 + 0.5);
         back_1.green =
            (png_byte)(pow((double)png_ptr->background.green/255, g) *
             255.0 + 0.5);
         back_1.blue =
            (png_byte)(pow((double)png_ptr->background.blue/255, g) *
             255.0 + 0.5);
      }

      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      {
         png_uint_32 i;

         for (i = 0; i < (png_uint_32)num_palette; i++)
         {
            if (i < png_ptr->num_trans && png_ptr->trans[i] == 0)
            {
               palette[i] = back;
            }
            else if (i < png_ptr->num_trans && png_ptr->trans[i] != 0xff)
            {
               png_byte v, w;

               v = png_ptr->gamma_to_1[png_ptr->palette[i].red];
               png_composite(w, v, png_ptr->trans[i], back_1.red);
               palette[i].red = png_ptr->gamma_from_1[w];

               v = png_ptr->gamma_to_1[png_ptr->palette[i].green];
               png_composite(w, v, png_ptr->trans[i], back_1.green);
               palette[i].green = png_ptr->gamma_from_1[w];

               v = png_ptr->gamma_to_1[png_ptr->palette[i].blue];
               png_composite(w, v, png_ptr->trans[i], back_1.blue);
               palette[i].blue = png_ptr->gamma_from_1[w];
            }
            else
            {
               palette[i].red = png_ptr->gamma_table[palette[i].red];
               palette[i].green = png_ptr->gamma_table[palette[i].green];
               palette[i].blue = png_ptr->gamma_table[palette[i].blue];
            }
         }
      }
      else
      {
         int i;

         for (i = 0; i < num_palette; i++)
         {
            if (palette[i].red == (png_byte)png_ptr->trans_values.gray)
            {
               palette[i] = back;
            }
            else
            {
               palette[i].red = png_ptr->gamma_table[palette[i].red];
               palette[i].green = png_ptr->gamma_table[palette[i].green];
               palette[i].blue = png_ptr->gamma_table[palette[i].blue];
            }
         }
      }
   }
   else
#endif
#ifdef PNG_READ_GAMMA_SUPPORTED
   if (png_ptr->transformations & PNG_GAMMA)
   {
      int i;

      for (i = 0; i < num_palette; i++)
      {
         palette[i].red = png_ptr->gamma_table[palette[i].red];
         palette[i].green = png_ptr->gamma_table[palette[i].green];
         palette[i].blue = png_ptr->gamma_table[palette[i].blue];
      }
   }
#ifdef PNG_READ_BACKGROUND_SUPPORTED
   else
#endif
#endif
#ifdef PNG_READ_BACKGROUND_SUPPORTED
   if (png_ptr->transformations & PNG_BACKGROUND)
   {
      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      {
         png_color back;

         back.red   = (png_byte)png_ptr->background.red;
         back.green = (png_byte)png_ptr->background.green;
         back.blue  = (png_byte)png_ptr->background.blue;

         for (i = 0; i < (int)png_ptr->num_trans; i++)
         {
            if (png_ptr->trans[i] == 0)
            {
               palette[i].red = back.red;
               palette[i].green = back.green;
               palette[i].blue = back.blue;
            }
            else if (png_ptr->trans[i] != 0xff)
            {
               png_composite(palette[i].red, png_ptr->palette[i].red,
                  png_ptr->trans[i], back.red);
               png_composite(palette[i].green, png_ptr->palette[i].green,
                  png_ptr->trans[i], back.green);
               png_composite(palette[i].blue, png_ptr->palette[i].blue,
                  png_ptr->trans[i], back.blue);
            }
         }
      }
      else /* Assume grayscale palette (what else could it be?) */
      {
         int i;

         for (i = 0; i < num_palette; i++)
         {
            if (i == (png_byte)png_ptr->trans_values.gray)
            {
               palette[i].red = (png_byte)png_ptr->background.red;
               palette[i].green = (png_byte)png_ptr->background.green;
               palette[i].blue = (png_byte)png_ptr->background.blue;
            }
         }
      }
   }
#endif
}
#endif

#ifdef PNG_READ_BACKGROUND_SUPPORTED
/* Replace any alpha or transparency with the supplied background color.
 * "background" is already in the screen gamma, while "background_1" is
 * at a gamma of 1.0.  Paletted files have already been taken care of.
 */
void /* PRIVATE */
png_do_background(png_row_infop row_info, png_bytep row,
   png_color_16p trans_values, png_color_16p background
#ifdef PNG_READ_GAMMA_SUPPORTED
   , png_color_16p background_1,
   png_bytep gamma_table, png_bytep gamma_from_1, png_bytep gamma_to_1,
   png_uint_16pp gamma_16, png_uint_16pp gamma_16_from_1,
   png_uint_16pp gamma_16_to_1, int gamma_shift
#endif
   )
{
   png_bytep sp, dp;
   png_uint_32 i;
   png_uint_32 row_width=row_info->width;
   int shift;

   png_debug(1, "in png_do_background");

   if (background != NULL &&
#ifdef PNG_USELESS_TESTS_SUPPORTED
       row != NULL && row_info != NULL &&
#endif
      (!(row_info->color_type & PNG_COLOR_MASK_ALPHA) ||
      (row_info->color_type != PNG_COLOR_TYPE_PALETTE && trans_values)))
   {
      switch (row_info->color_type)
      {
         case PNG_COLOR_TYPE_GRAY:
         {
            switch (row_info->bit_depth)
            {
               case 1:
               {
                  sp = row;
                  shift = 7;
                  for (i = 0; i < row_width; i++)
                  {
                     if ((png_uint_16)((*sp >> shift) & 0x01)
                        == trans_values->gray)
                     {
                        *sp &= (png_byte)((0x7f7f >> (7 - shift)) & 0xff);
                        *sp |= (png_byte)(background->gray << shift);
                     }
                     if (!shift)
                     {
                        shift = 7;
                        sp++;
                     }
                     else
                        shift--;
                  }
                  break;
               }

               case 2:
               {
#ifdef PNG_READ_GAMMA_SUPPORTED
                  if (gamma_table != NULL)
                  {
                     sp = row;
                     shift = 6;
                     for (i = 0; i < row_width; i++)
                     {
                        if ((png_uint_16)((*sp >> shift) & 0x03)
                            == trans_values->gray)
                        {
                           *sp &= (png_byte)((0x3f3f >> (6 - shift)) & 0xff);
                           *sp |= (png_byte)(background->gray << shift);
                        }
                        else
                        {
                           png_byte p = (png_byte)((*sp >> shift) & 0x03);
                           png_byte g = (png_byte)((gamma_table [p | (p << 2) |
                               (p << 4) | (p << 6)] >> 6) & 0x03);
                           *sp &= (png_byte)((0x3f3f >> (6 - shift)) & 0xff);
                           *sp |= (png_byte)(g << shift);
                        }
                        if (!shift)
                        {
                           shift = 6;
                           sp++;
                        }
                        else
                           shift -= 2;
                     }
                  }
                  else
#endif
                  {
                     sp = row;
                     shift = 6;
                     for (i = 0; i < row_width; i++)
                     {
                        if ((png_uint_16)((*sp >> shift) & 0x03)
                            == trans_values->gray)
                        {
                           *sp &= (png_byte)((0x3f3f >> (6 - shift)) & 0xff);
                           *sp |= (png_byte)(background->gray << shift);
                        }
                        if (!shift)
                        {
                           shift = 6;
                           sp++;
                        }
                        else
                           shift -= 2;
                     }
                  }
                  break;
               }

               case 4:
               {
#ifdef PNG_READ_GAMMA_SUPPORTED
                  if (gamma_table != NULL)
                  {
                     sp = row;
                     shift = 4;
                     for (i = 0; i < row_width; i++)
                     {
                        if ((png_uint_16)((*sp >> shift) & 0x0f)
                            == trans_values->gray)
                        {
                           *sp &= (png_byte)((0xf0f >> (4 - shift)) & 0xff);
                           *sp |= (png_byte)(background->gray << shift);
                        }
                        else
                        {
                           png_byte p = (png_byte)((*sp >> shift) & 0x0f);
                           png_byte g = (png_byte)((gamma_table[p |
                             (p << 4)] >> 4) & 0x0f);
                           *sp &= (png_byte)((0xf0f >> (4 - shift)) & 0xff);
                           *sp |= (png_byte)(g << shift);
                        }
                        if (!shift)
                        {
                           shift = 4;
                           sp++;
                        }
                        else
                           shift -= 4;
                     }
                  }
                  else
#endif
                  {
                     sp = row;
                     shift = 4;
                     for (i = 0; i < row_width; i++)
                     {
                        if ((png_uint_16)((*sp >> shift) & 0x0f)
                            == trans_values->gray)
                        {
                           *sp &= (png_byte)((0xf0f >> (4 - shift)) & 0xff);
                           *sp |= (png_byte)(background->gray << shift);
                        }
                        if (!shift)
                        {
                           shift = 4;
                           sp++;
                        }
                        else
                           shift -= 4;
                     }
                  }
                  break;
               }

               case 8:
               {
#ifdef PNG_READ_GAMMA_SUPPORTED
                  if (gamma_table != NULL)
                  {
                     sp = row;
                     for (i = 0; i < row_width; i++, sp++)
                     {
                        if (*sp == trans_values->gray)
                        {
                           *sp = (png_byte)background->gray;
                        }
                        else
                        {
                           *sp = gamma_table[*sp];
                        }
                     }
                  }
                  else
#endif
                  {
                     sp = row;
                     for (i = 0; i < row_width; i++, sp++)
                     {
                        if (*sp == trans_values->gray)
                        {
                           *sp = (png_byte)background->gray;
                        }
                     }
                  }
                  break;
               }

               case 16:
               {
#ifdef PNG_READ_GAMMA_SUPPORTED
                  if (gamma_16 != NULL)
                  {
                     sp = row;
                     for (i = 0; i < row_width; i++, sp += 2)
                     {
                        png_uint_16 v;

                        v = (png_uint_16)(((*sp) << 8) + *(sp + 1));
                        if (v == trans_values->gray)
                        {
                           /* Background is already in screen gamma */
                           *sp = (png_byte)((background->gray >> 8) & 0xff);
                           *(sp + 1) = (png_byte)(background->gray & 0xff);
                        }
                        else
                        {
                           v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
                           *sp = (png_byte)((v >> 8) & 0xff);
                           *(sp + 1) = (png_byte)(v & 0xff);
                        }
                     }
                  }
                  else
#endif
                  {
                     sp = row;
                     for (i = 0; i < row_width; i++, sp += 2)
                     {
                        png_uint_16 v;

                        v = (png_uint_16)(((*sp) << 8) + *(sp + 1));
                        if (v == trans_values->gray)
                        {
                           *sp = (png_byte)((background->gray >> 8) & 0xff);
                           *(sp + 1) = (png_byte)(background->gray & 0xff);
                        }
                     }
                  }
                  break;
               }
            }
            break;
         }

         case PNG_COLOR_TYPE_RGB:
         {
            if (row_info->bit_depth == 8)
            {
#ifdef PNG_READ_GAMMA_SUPPORTED
               if (gamma_table != NULL)
               {
                  sp = row;
                  for (i = 0; i < row_width; i++, sp += 3)
                  {
                     if (*sp == trans_values->red &&
                        *(sp + 1) == trans_values->green &&
                        *(sp + 2) == trans_values->blue)
                     {
                        *sp = (png_byte)background->red;
                        *(sp + 1) = (png_byte)background->green;
                        *(sp + 2) = (png_byte)background->blue;
                     }
                     else
                     {
                        *sp = gamma_table[*sp];
                        *(sp + 1) = gamma_table[*(sp + 1)];
                        *(sp + 2) = gamma_table[*(sp + 2)];
                     }
                  }
               }
               else
#endif
               {
                  sp = row;
                  for (i = 0; i < row_width; i++, sp += 3)
                  {
                     if (*sp == trans_values->red &&
                        *(sp + 1) == trans_values->green &&
                        *(sp + 2) == trans_values->blue)
                     {
                        *sp = (png_byte)background->red;
                        *(sp + 1) = (png_byte)background->green;
                        *(sp + 2) = (png_byte)background->blue;
                     }
                  }
               }
            }
            else /* if (row_info->bit_depth == 16) */
            {
#ifdef PNG_READ_GAMMA_SUPPORTED
               if (gamma_16 != NULL)
               {
                  sp = row;
                  for (i = 0; i < row_width; i++, sp += 6)
                  {
                     png_uint_16 r = (png_uint_16)(((*sp) << 8) + *(sp + 1));
                     png_uint_16 g = (png_uint_16)(((*(sp+2)) << 8) + *(sp+3));
                     png_uint_16 b = (png_uint_16)(((*(sp+4)) << 8) + *(sp+5));
                     if (r == trans_values->red && g == trans_values->green &&
                        b == trans_values->blue)
                     {
                        /* Background is already in screen gamma */
                        *sp = (png_byte)((background->red >> 8) & 0xff);
                        *(sp + 1) = (png_byte)(background->red & 0xff);
                        *(sp + 2) = (png_byte)((background->green >> 8) & 0xff);
                        *(sp + 3) = (png_byte)(background->green & 0xff);
                        *(sp + 4) = (png_byte)((background->blue >> 8) & 0xff);
                        *(sp + 5) = (png_byte)(background->blue & 0xff);
                     }
                     else
                     {
                        png_uint_16 v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
                        *sp = (png_byte)((v >> 8) & 0xff);
                        *(sp + 1) = (png_byte)(v & 0xff);
                        v = gamma_16[*(sp + 3) >> gamma_shift][*(sp + 2)];
                        *(sp + 2) = (png_byte)((v >> 8) & 0xff);
                        *(sp + 3) = (png_byte)(v & 0xff);
                        v = gamma_16[*(sp + 5) >> gamma_shift][*(sp + 4)];
                        *(sp + 4) = (png_byte)((v >> 8) & 0xff);
                        *(sp + 5) = (png_byte)(v & 0xff);
                     }
                  }
               }
               else
#endif
               {
                  sp = row;
                  for (i = 0; i < row_width; i++, sp += 6)
                  {
                     png_uint_16 r = (png_uint_16)(((*sp) << 8) + *(sp+1));
                     png_uint_16 g = (png_uint_16)(((*(sp+2)) << 8) + *(sp+3));
                     png_uint_16 b = (png_uint_16)(((*(sp+4)) << 8) + *(sp+5));

                     if (r == trans_values->red && g == trans_values->green &&
                        b == trans_values->blue)
                     {
                        *sp = (png_byte)((background->red >> 8) & 0xff);
                        *(sp + 1) = (png_byte)(background->red & 0xff);
                        *(sp + 2) = (png_byte)((background->green >> 8) & 0xff);
                        *(sp + 3) = (png_byte)(background->green & 0xff);
                        *(sp + 4) = (png_byte)((background->blue >> 8) & 0xff);
                        *(sp + 5) = (png_byte)(background->blue & 0xff);
                     }
                  }
               }
            }
            break;
         }

         case PNG_COLOR_TYPE_GRAY_ALPHA:
         {
            if (row_info->bit_depth == 8)
            {
#ifdef PNG_READ_GAMMA_SUPPORTED
               if (gamma_to_1 != NULL && gamma_from_1 != NULL &&
                   gamma_table != NULL)
               {
                  sp = row;
                  dp = row;
                  for (i = 0; i < row_width; i++, sp += 2, dp++)
                  {
                     png_uint_16 a = *(sp + 1);

                     if (a == 0xff)
                     {
                        *dp = gamma_table[*sp];
                     }
                     else if (a == 0)
                     {
                        /* Background is already in screen gamma */
                        *dp = (png_byte)background->gray;
                     }
                     else
                     {
                        png_byte v, w;

                        v = gamma_to_1[*sp];
                        png_composite(w, v, a, background_1->gray);
                        *dp = gamma_from_1[w];
                     }
                  }
               }
               else
#endif
               {
                  sp = row;
                  dp = row;
                  for (i = 0; i < row_width; i++, sp += 2, dp++)
                  {
                     png_byte a = *(sp + 1);

                     if (a == 0xff)
                     {
                        *dp = *sp;
                     }
#ifdef PNG_READ_GAMMA_SUPPORTED
                     else if (a == 0)
                     {
                        *dp = (png_byte)background->gray;
                     }
                     else
                     {
                        png_composite(*dp, *sp, a, background_1->gray);
                     }
#else
                     *dp = (png_byte)background->gray;
#endif
                  }
               }
            }
            else /* if (png_ptr->bit_depth == 16) */
            {
#ifdef PNG_READ_GAMMA_SUPPORTED
               if (gamma_16 != NULL && gamma_16_from_1 != NULL &&
                   gamma_16_to_1 != NULL)
               {
                  sp = row;
                  dp = row;
                  for (i = 0; i < row_width; i++, sp += 4, dp += 2)
                  {
                     png_uint_16 a = (png_uint_16)(((*(sp+2)) << 8) + *(sp+3));

                     if (a == (png_uint_16)0xffff)
                     {
                        png_uint_16 v;

                        v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
                        *dp = (png_byte)((v >> 8) & 0xff);
                        *(dp + 1) = (png_byte)(v & 0xff);
                     }
#ifdef PNG_READ_GAMMA_SUPPORTED
                     else if (a == 0)
#else
                     else
#endif
                     {
                        /* Background is already in screen gamma */
                        *dp = (png_byte)((background->gray >> 8) & 0xff);
                        *(dp + 1) = (png_byte)(background->gray & 0xff);
                     }
#ifdef PNG_READ_GAMMA_SUPPORTED
                     else
                     {
                        png_uint_16 g, v, w;

                        g = gamma_16_to_1[*(sp + 1) >> gamma_shift][*sp];
                        png_composite_16(v, g, a, background_1->gray);
                        w = gamma_16_from_1[(v&0xff) >> gamma_shift][v >> 8];
                        *dp = (png_byte)((w >> 8) & 0xff);
                        *(dp + 1) = (png_byte)(w & 0xff);
                     }
#endif
                  }
               }
               else
#endif
               {
                  sp = row;
                  dp = row;
                  for (i = 0; i < row_width; i++, sp += 4, dp += 2)
                  {
                     png_uint_16 a = (png_uint_16)(((*(sp+2)) << 8) + *(sp+3));
                     if (a == (png_uint_16)0xffff)
                     {
                        png_memcpy(dp, sp, 2);
                     }
#ifdef PNG_READ_GAMMA_SUPPORTED
                     else if (a == 0)
#else
                     else
#endif
                     {
                        *dp = (png_byte)((background->gray >> 8) & 0xff);
                        *(dp + 1) = (png_byte)(background->gray & 0xff);
                     }
#ifdef PNG_READ_GAMMA_SUPPORTED
                     else
                     {
                        png_uint_16 g, v;

                        g = (png_uint_16)(((*sp) << 8) + *(sp + 1));
                        png_composite_16(v, g, a, background_1->gray);
                        *dp = (png_byte)((v >> 8) & 0xff);
                        *(dp + 1) = (png_byte)(v & 0xff);
                     }
#endif
                  }
               }
            }
            break;
         }

         case PNG_COLOR_TYPE_RGB_ALPHA:
         {
            if (row_info->bit_depth == 8)
            {
#ifdef PNG_READ_GAMMA_SUPPORTED
               if (gamma_to_1 != NULL && gamma_from_1 != NULL &&
                   gamma_table != NULL)
               {
                  sp = row;
                  dp = row;
                  for (i = 0; i < row_width; i++, sp += 4, dp += 3)
                  {
                     png_byte a = *(sp + 3);

                     if (a == 0xff)
                     {
                        *dp = gamma_table[*sp];
                        *(dp + 1) = gamma_table[*(sp + 1)];
                        *(dp + 2) = gamma_table[*(sp + 2)];
                     }
                     else if (a == 0)
                     {
                        /* Background is already in screen gamma */
                        *dp = (png_byte)background->red;
                        *(dp + 1) = (png_byte)background->green;
                        *(dp + 2) = (png_byte)background->blue;
                     }
                     else
                     {
                        png_byte v, w;

                        v = gamma_to_1[*sp];
                        png_composite(w, v, a, background_1->red);
                        *dp = gamma_from_1[w];
                        v = gamma_to_1[*(sp + 1)];
                        png_composite(w, v, a, background_1->green);
                        *(dp + 1) = gamma_from_1[w];
                        v = gamma_to_1[*(sp + 2)];
                        png_composite(w, v, a, background_1->blue);
                        *(dp + 2) = gamma_from_1[w];
                     }
                  }
               }
               else
#endif
               {
                  sp = row;
                  dp = row;
                  for (i = 0; i < row_width; i++, sp += 4, dp += 3)
                  {
                     png_byte a = *(sp + 3);

                     if (a == 0xff)
                     {
                        *dp = *sp;
                        *(dp + 1) = *(sp + 1);
                        *(dp + 2) = *(sp + 2);
                     }
                     else if (a == 0)
                     {
                        *dp = (png_byte)background->red;
                        *(dp + 1) = (png_byte)background->green;
                        *(dp + 2) = (png_byte)background->blue;
                     }
                     else
                     {
                        png_composite(*dp, *sp, a, background->red);
                        png_composite(*(dp + 1), *(sp + 1), a,
                           background->green);
                        png_composite(*(dp + 2), *(sp + 2), a,
                           background->blue);
                     }
                  }
               }
            }
            else /* if (row_info->bit_depth == 16) */
            {
#ifdef PNG_READ_GAMMA_SUPPORTED
               if (gamma_16 != NULL && gamma_16_from_1 != NULL &&
                   gamma_16_to_1 != NULL)
               {
                  sp = row;
                  dp = row;
                  for (i = 0; i < row_width; i++, sp += 8, dp += 6)
                  {
                     png_uint_16 a = (png_uint_16)(((png_uint_16)(*(sp + 6))
                         << 8) + (png_uint_16)(*(sp + 7)));
                     if (a == (png_uint_16)0xffff)
                     {
                        png_uint_16 v;

                        v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
                        *dp = (png_byte)((v >> 8) & 0xff);
                        *(dp + 1) = (png_byte)(v & 0xff);
                        v = gamma_16[*(sp + 3) >> gamma_shift][*(sp + 2)];
                        *(dp + 2) = (png_byte)((v >> 8) & 0xff);
                        *(dp + 3) = (png_byte)(v & 0xff);
                        v = gamma_16[*(sp + 5) >> gamma_shift][*(sp + 4)];
                        *(dp + 4) = (png_byte)((v >> 8) & 0xff);
                        *(dp + 5) = (png_byte)(v & 0xff);
                     }
                     else if (a == 0)
                     {
                        /* Background is already in screen gamma */
                        *dp = (png_byte)((background->red >> 8) & 0xff);
                        *(dp + 1) = (png_byte)(background->red & 0xff);
                        *(dp + 2) = (png_byte)((background->green >> 8) & 0xff);
                        *(dp + 3) = (png_byte)(background->green & 0xff);
                        *(dp + 4) = (png_byte)((background->blue >> 8) & 0xff);
                        *(dp + 5) = (png_byte)(background->blue & 0xff);
                     }
                     else
                     {
                        png_uint_16 v, w, x;

                        v = gamma_16_to_1[*(sp + 1) >> gamma_shift][*sp];
                        png_composite_16(w, v, a, background_1->red);
                        x = gamma_16_from_1[((w&0xff) >> gamma_shift)][w >> 8];
                        *dp = (png_byte)((x >> 8) & 0xff);
                        *(dp + 1) = (png_byte)(x & 0xff);
                        v = gamma_16_to_1[*(sp + 3) >> gamma_shift][*(sp + 2)];
                        png_composite_16(w, v, a, background_1->green);
                        x = gamma_16_from_1[((w&0xff) >> gamma_shift)][w >> 8];
                        *(dp + 2) = (png_byte)((x >> 8) & 0xff);
                        *(dp + 3) = (png_byte)(x & 0xff);
                        v = gamma_16_to_1[*(sp + 5) >> gamma_shift][*(sp + 4)];
                        png_composite_16(w, v, a, background_1->blue);
                        x = gamma_16_from_1[(w & 0xff) >> gamma_shift][w >> 8];
                        *(dp + 4) = (png_byte)((x >> 8) & 0xff);
                        *(dp + 5) = (png_byte)(x & 0xff);
                     }
                  }
               }
               else
#endif
               {
                  sp = row;
                  dp = row;
                  for (i = 0; i < row_width; i++, sp += 8, dp += 6)
                  {
                     png_uint_16 a = (png_uint_16)(((png_uint_16)(*(sp + 6))
                        << 8) + (png_uint_16)(*(sp + 7)));
                     if (a == (png_uint_16)0xffff)
                     {
                        png_memcpy(dp, sp, 6);
                     }
                     else if (a == 0)
                     {
                        *dp = (png_byte)((background->red >> 8) & 0xff);
                        *(dp + 1) = (png_byte)(background->red & 0xff);
                        *(dp + 2) = (png_byte)((background->green >> 8) & 0xff);
                        *(dp + 3) = (png_byte)(background->green & 0xff);
                        *(dp + 4) = (png_byte)((background->blue >> 8) & 0xff);
                        *(dp + 5) = (png_byte)(background->blue & 0xff);
                     }
                     else
                     {
                        png_uint_16 v;

                        png_uint_16 r = (png_uint_16)(((*sp) << 8) + *(sp + 1));
                        png_uint_16 g = (png_uint_16)(((*(sp + 2)) << 8)
                            + *(sp + 3));
                        png_uint_16 b = (png_uint_16)(((*(sp + 4)) << 8)
                            + *(sp + 5));

                        png_composite_16(v, r, a, background->red);
                        *dp = (png_byte)((v >> 8) & 0xff);
                        *(dp + 1) = (png_byte)(v & 0xff);
                        png_composite_16(v, g, a, background->green);
                        *(dp + 2) = (png_byte)((v >> 8) & 0xff);
                        *(dp + 3) = (png_byte)(v & 0xff);
                        png_composite_16(v, b, a, background->blue);
                        *(dp + 4) = (png_byte)((v >> 8) & 0xff);
                        *(dp + 5) = (png_byte)(v & 0xff);
                     }
                  }
               }
            }
            break;
         }
      }

      if (row_info->color_type & PNG_COLOR_MASK_ALPHA)
      {
         row_info->color_type &= ~PNG_COLOR_MASK_ALPHA;
         row_info->channels--;
         row_info->pixel_depth = (png_byte)(row_info->channels *
            row_info->bit_depth);
         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
      }
   }
}
#endif

#ifdef PNG_READ_GAMMA_SUPPORTED
/* Gamma correct the image, avoiding the alpha channel.  Make sure
 * you do this after you deal with the transparency issue on grayscale
 * or RGB images. If your bit depth is 8, use gamma_table, if it
 * is 16, use gamma_16_table and gamma_shift.  Build these with
 * build_gamma_table().
 */
void /* PRIVATE */
png_do_gamma(png_row_infop row_info, png_bytep row,
   png_bytep gamma_table, png_uint_16pp gamma_16_table,
   int gamma_shift)
{
   png_bytep sp;
   png_uint_32 i;
   png_uint_32 row_width=row_info->width;

   png_debug(1, "in png_do_gamma");

   if (
#ifdef PNG_USELESS_TESTS_SUPPORTED
       row != NULL && row_info != NULL &&
#endif
       ((row_info->bit_depth <= 8 && gamma_table != NULL) ||
        (row_info->bit_depth == 16 && gamma_16_table != NULL)))
   {
      switch (row_info->color_type)
      {
         case PNG_COLOR_TYPE_RGB:
         {
            if (row_info->bit_depth == 8)
            {
               sp = row;
               for (i = 0; i < row_width; i++)
               {
                  *sp = gamma_table[*sp];
                  sp++;
                  *sp = gamma_table[*sp];
                  sp++;
                  *sp = gamma_table[*sp];
                  sp++;
               }
            }
            else /* if (row_info->bit_depth == 16) */
            {
               sp = row;
               for (i = 0; i < row_width; i++)
               {
                  png_uint_16 v;

                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
                  *sp = (png_byte)((v >> 8) & 0xff);
                  *(sp + 1) = (png_byte)(v & 0xff);
                  sp += 2;
                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
                  *sp = (png_byte)((v >> 8) & 0xff);
                  *(sp + 1) = (png_byte)(v & 0xff);
                  sp += 2;
                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
                  *sp = (png_byte)((v >> 8) & 0xff);
                  *(sp + 1) = (png_byte)(v & 0xff);
                  sp += 2;
               }
            }
            break;
         }

         case PNG_COLOR_TYPE_RGB_ALPHA:
         {
            if (row_info->bit_depth == 8)
            {
               sp = row;
               for (i = 0; i < row_width; i++)
               {
                  *sp = gamma_table[*sp];
                  sp++;
                  *sp = gamma_table[*sp];
                  sp++;
                  *sp = gamma_table[*sp];
                  sp++;
                  sp++;
               }
            }
            else /* if (row_info->bit_depth == 16) */
            {
               sp = row;
               for (i = 0; i < row_width; i++)
               {
                  png_uint_16 v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
                  *sp = (png_byte)((v >> 8) & 0xff);
                  *(sp + 1) = (png_byte)(v & 0xff);
                  sp += 2;
                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
                  *sp = (png_byte)((v >> 8) & 0xff);
                  *(sp + 1) = (png_byte)(v & 0xff);
                  sp += 2;
                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
                  *sp = (png_byte)((v >> 8) & 0xff);
                  *(sp + 1) = (png_byte)(v & 0xff);
                  sp += 4;
               }
            }
            break;
         }

         case PNG_COLOR_TYPE_GRAY_ALPHA:
         {
            if (row_info->bit_depth == 8)
            {
               sp = row;
               for (i = 0; i < row_width; i++)
               {
                  *sp = gamma_table[*sp];
                  sp += 2;
               }
            }
            else /* if (row_info->bit_depth == 16) */
            {
               sp = row;
               for (i = 0; i < row_width; i++)
               {
                  png_uint_16 v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
                  *sp = (png_byte)((v >> 8) & 0xff);
                  *(sp + 1) = (png_byte)(v & 0xff);
                  sp += 4;
               }
            }
            break;
         }

         case PNG_COLOR_TYPE_GRAY:
         {
            if (row_info->bit_depth == 2)
            {
               sp = row;
               for (i = 0; i < row_width; i += 4)
               {
                  int a = *sp & 0xc0;
                  int b = *sp & 0x30;
                  int c = *sp & 0x0c;
                  int d = *sp & 0x03;

                  *sp = (png_byte)(
                      ((((int)gamma_table[a|(a>>2)|(a>>4)|(a>>6)])   ) & 0xc0)|
                      ((((int)gamma_table[(b<<2)|b|(b>>2)|(b>>4)])>>2) & 0x30)|
                      ((((int)gamma_table[(c<<4)|(c<<2)|c|(c>>2)])>>4) & 0x0c)|
                      ((((int)gamma_table[(d<<6)|(d<<4)|(d<<2)|d])>>6) ));
                  sp++;
               }
            }

            if (row_info->bit_depth == 4)
            {
               sp = row;
               for (i = 0; i < row_width; i += 2)
               {
                  int msb = *sp & 0xf0;
                  int lsb = *sp & 0x0f;

                  *sp = (png_byte)((((int)gamma_table[msb | (msb >> 4)]) & 0xf0)
                      | (((int)gamma_table[(lsb << 4) | lsb]) >> 4));
                  sp++;
               }
            }

            else if (row_info->bit_depth == 8)
            {
               sp = row;
               for (i = 0; i < row_width; i++)
               {
                  *sp = gamma_table[*sp];
                  sp++;
               }
            }

            else if (row_info->bit_depth == 16)
            {
               sp = row;
               for (i = 0; i < row_width; i++)
               {
                  png_uint_16 v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
                  *sp = (png_byte)((v >> 8) & 0xff);
                  *(sp + 1) = (png_byte)(v & 0xff);
                  sp += 2;
               }
            }
            break;
         }
      }
   }
}
#endif

#ifdef PNG_READ_EXPAND_SUPPORTED
/* Expands a palette row to an RGB or RGBA row depending
 * upon whether you supply trans and num_trans.
 */
void /* PRIVATE */
png_do_expand_palette(png_row_infop row_info, png_bytep row,
   png_colorp palette, png_bytep trans, int num_trans)
{
   int shift, value;
   png_bytep sp, dp;
   png_uint_32 i;
   png_uint_32 row_width=row_info->width;

   png_debug(1, "in png_do_expand_palette");

   if (
#ifdef PNG_USELESS_TESTS_SUPPORTED
       row != NULL && row_info != NULL &&
#endif
       row_info->color_type == PNG_COLOR_TYPE_PALETTE)
   {
      if (row_info->bit_depth < 8)
      {
         switch (row_info->bit_depth)
         {
            case 1:
            {
               sp = row + (png_size_t)((row_width - 1) >> 3);
               dp = row + (png_size_t)row_width - 1;
               shift = 7 - (int)((row_width + 7) & 0x07);
               for (i = 0; i < row_width; i++)
               {
                  if ((*sp >> shift) & 0x01)
                     *dp = 1;
                  else
                     *dp = 0;
                  if (shift == 7)
                  {
                     shift = 0;
                     sp--;
                  }
                  else
                     shift++;

                  dp--;
               }
               break;
            }

            case 2:
            {
               sp = row + (png_size_t)((row_width - 1) >> 2);
               dp = row + (png_size_t)row_width - 1;
               shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);
               for (i = 0; i < row_width; i++)
               {
                  value = (*sp >> shift) & 0x03;
                  *dp = (png_byte)value;
                  if (shift == 6)
                  {
                     shift = 0;
                     sp--;
                  }
                  else
                     shift += 2;

                  dp--;
               }
               break;
            }

            case 4:
            {
               sp = row + (png_size_t)((row_width - 1) >> 1);
               dp = row + (png_size_t)row_width - 1;
               shift = (int)((row_width & 0x01) << 2);
               for (i = 0; i < row_width; i++)
               {
                  value = (*sp >> shift) & 0x0f;
                  *dp = (png_byte)value;
                  if (shift == 4)
                  {
                     shift = 0;
                     sp--;
                  }
                  else
                     shift += 4;

                  dp--;
               }
               break;
            }
         }
         row_info->bit_depth = 8;
         row_info->pixel_depth = 8;
         row_info->rowbytes = row_width;
      }
      switch (row_info->bit_depth)
      {
         case 8:
         {
            if (trans != NULL)
            {
               sp = row + (png_size_t)row_width - 1;
               dp = row + (png_size_t)(row_width << 2) - 1;

               for (i = 0; i < row_width; i++)
               {
                  if ((int)(*sp) >= num_trans)
                     *dp-- = 0xff;
                  else
                     *dp-- = trans[*sp];
                  *dp-- = palette[*sp].blue;
                  *dp-- = palette[*sp].green;
                  *dp-- = palette[*sp].red;
                  sp--;
               }
               row_info->bit_depth = 8;
               row_info->pixel_depth = 32;
               row_info->rowbytes = row_width * 4;
               row_info->color_type = 6;
               row_info->channels = 4;
            }
            else
            {
               sp = row + (png_size_t)row_width - 1;
               dp = row + (png_size_t)(row_width * 3) - 1;

               for (i = 0; i < row_width; i++)
               {
                  *dp-- = palette[*sp].blue;
                  *dp-- = palette[*sp].green;
                  *dp-- = palette[*sp].red;
                  sp--;
               }

               row_info->bit_depth = 8;
               row_info->pixel_depth = 24;
               row_info->rowbytes = row_width * 3;
               row_info->color_type = 2;
               row_info->channels = 3;
            }
            break;
         }
      }
   }
}

/* If the bit depth < 8, it is expanded to 8.  Also, if the already
 * expanded transparency value is supplied, an alpha channel is built.
 */
void /* PRIVATE */
png_do_expand(png_row_infop row_info, png_bytep row,
   png_color_16p trans_value)
{
   int shift, value;
   png_bytep sp, dp;
   png_uint_32 i;
   png_uint_32 row_width=row_info->width;

   png_debug(1, "in png_do_expand");

#ifdef PNG_USELESS_TESTS_SUPPORTED
   if (row != NULL && row_info != NULL)
#endif
   {
      if (row_info->color_type == PNG_COLOR_TYPE_GRAY)
      {
         png_uint_16 gray = (png_uint_16)(trans_value ? trans_value->gray : 0);

         if (row_info->bit_depth < 8)
         {
            switch (row_info->bit_depth)
            {
               case 1:
               {
                  gray = (png_uint_16)((gray&0x01)*0xff);
                  sp = row + (png_size_t)((row_width - 1) >> 3);
                  dp = row + (png_size_t)row_width - 1;
                  shift = 7 - (int)((row_width + 7) & 0x07);
                  for (i = 0; i < row_width; i++)
                  {
                     if ((*sp >> shift) & 0x01)
                        *dp = 0xff;
                     else
                        *dp = 0;
                     if (shift == 7)
                     {
                        shift = 0;
                        sp--;
                     }
                     else
                        shift++;

                     dp--;
                  }
                  break;
               }

               case 2:
               {
                  gray = (png_uint_16)((gray&0x03)*0x55);
                  sp = row + (png_size_t)((row_width - 1) >> 2);
                  dp = row + (png_size_t)row_width - 1;
                  shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);
                  for (i = 0; i < row_width; i++)
                  {
                     value = (*sp >> shift) & 0x03;
                     *dp = (png_byte)(value | (value << 2) | (value << 4) |
                        (value << 6));
                     if (shift == 6)
                     {
                        shift = 0;
                        sp--;
                     }
                     else
                        shift += 2;

                     dp--;
                  }
                  break;
               }

               case 4:
               {
                  gray = (png_uint_16)((gray&0x0f)*0x11);
                  sp = row + (png_size_t)((row_width - 1) >> 1);
                  dp = row + (png_size_t)row_width - 1;
                  shift = (int)((1 - ((row_width + 1) & 0x01)) << 2);
                  for (i = 0; i < row_width; i++)
                  {
                     value = (*sp >> shift) & 0x0f;
                     *dp = (png_byte)(value | (value << 4));
                     if (shift == 4)
                     {
                        shift = 0;
                        sp--;
                     }
                     else
                        shift = 4;

                     dp--;
                  }
                  break;
               }
            }

            row_info->bit_depth = 8;
            row_info->pixel_depth = 8;
            row_info->rowbytes = row_width;
         }

         if (trans_value != NULL)
         {
            if (row_info->bit_depth == 8)
            {
               gray = gray & 0xff;
               sp = row + (png_size_t)row_width - 1;
               dp = row + (png_size_t)(row_width << 1) - 1;
               for (i = 0; i < row_width; i++)
               {
                  if (*sp == gray)
                     *dp-- = 0;
                  else
                     *dp-- = 0xff;
                  *dp-- = *sp--;
               }
            }

            else if (row_info->bit_depth == 16)
            {
               png_byte gray_high = (gray >> 8) & 0xff;
               png_byte gray_low = gray & 0xff;
               sp = row + row_info->rowbytes - 1;
               dp = row + (row_info->rowbytes << 1) - 1;
               for (i = 0; i < row_width; i++)
               {
                  if (*(sp - 1) == gray_high && *(sp) == gray_low)
                  {
                     *dp-- = 0;
                     *dp-- = 0;
                  }
                  else
                  {
                     *dp-- = 0xff;
                     *dp-- = 0xff;
                  }
                  *dp-- = *sp--;
                  *dp-- = *sp--;
               }
            }

            row_info->color_type = PNG_COLOR_TYPE_GRAY_ALPHA;
            row_info->channels = 2;
            row_info->pixel_depth = (png_byte)(row_info->bit_depth << 1);
            row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,
               row_width);
         }
      }
      else if (row_info->color_type == PNG_COLOR_TYPE_RGB && trans_value)
      {
         if (row_info->bit_depth == 8)
         {
            png_byte red = trans_value->red & 0xff;
            png_byte green = trans_value->green & 0xff;
            png_byte blue = trans_value->blue & 0xff;
            sp = row + (png_size_t)row_info->rowbytes - 1;
            dp = row + (png_size_t)(row_width << 2) - 1;
            for (i = 0; i < row_width; i++)
            {
               if (*(sp - 2) == red && *(sp - 1) == green && *(sp) == blue)
                  *dp-- = 0;
               else
                  *dp-- = 0xff;
               *dp-- = *sp--;
               *dp-- = *sp--;
               *dp-- = *sp--;
            }
         }
         else if (row_info->bit_depth == 16)
         {
            png_byte red_high = (trans_value->red >> 8) & 0xff;
            png_byte green_high = (trans_value->green >> 8) & 0xff;
            png_byte blue_high = (trans_value->blue >> 8) & 0xff;
            png_byte red_low = trans_value->red & 0xff;
            png_byte green_low = trans_value->green & 0xff;
            png_byte blue_low = trans_value->blue & 0xff;
            sp = row + row_info->rowbytes - 1;
            dp = row + (png_size_t)(row_width << 3) - 1;
            for (i = 0; i < row_width; i++)
            {
               if (*(sp - 5) == red_high &&
                  *(sp - 4) == red_low &&
                  *(sp - 3) == green_high &&
                  *(sp - 2) == green_low &&
                  *(sp - 1) == blue_high &&
                  *(sp    ) == blue_low)
               {
                  *dp-- = 0;
                  *dp-- = 0;
               }
               else
               {
                  *dp-- = 0xff;
                  *dp-- = 0xff;
               }
               *dp-- = *sp--;
               *dp-- = *sp--;
               *dp-- = *sp--;
               *dp-- = *sp--;
               *dp-- = *sp--;
               *dp-- = *sp--;
            }
         }
         row_info->color_type = PNG_COLOR_TYPE_RGB_ALPHA;
         row_info->channels = 4;
         row_info->pixel_depth = (png_byte)(row_info->bit_depth << 2);
         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
      }
   }
}
#endif

#ifdef PNG_READ_DITHER_SUPPORTED
void /* PRIVATE */
png_do_dither(png_row_infop row_info, png_bytep row,
    png_bytep palette_lookup, png_bytep dither_lookup)
{
   png_bytep sp, dp;
   png_uint_32 i;
   png_uint_32 row_width=row_info->width;

   png_debug(1, "in png_do_dither");

#ifdef PNG_USELESS_TESTS_SUPPORTED
   if (row != NULL && row_info != NULL)
#endif
   {
      if (row_info->color_type == PNG_COLOR_TYPE_RGB &&
         palette_lookup && row_info->bit_depth == 8)
      {
         int r, g, b, p;
         sp = row;
         dp = row;
         for (i = 0; i < row_width; i++)
         {
            r = *sp++;
            g = *sp++;
            b = *sp++;

            /* This looks real messy, but the compiler will reduce
             * it down to a reasonable formula.  For example, with
             * 5 bits per color, we get:
             * p = (((r >> 3) & 0x1f) << 10) |
             *    (((g >> 3) & 0x1f) << 5) |
             *    ((b >> 3) & 0x1f);
             */
            p = (((r >> (8 - PNG_DITHER_RED_BITS)) &
               ((1 << PNG_DITHER_RED_BITS) - 1)) <<
               (PNG_DITHER_GREEN_BITS + PNG_DITHER_BLUE_BITS)) |
               (((g >> (8 - PNG_DITHER_GREEN_BITS)) &
               ((1 << PNG_DITHER_GREEN_BITS) - 1)) <<
               (PNG_DITHER_BLUE_BITS)) |
               ((b >> (8 - PNG_DITHER_BLUE_BITS)) &
               ((1 << PNG_DITHER_BLUE_BITS) - 1));

            *dp++ = palette_lookup[p];
         }
         row_info->color_type = PNG_COLOR_TYPE_PALETTE;
         row_info->channels = 1;
         row_info->pixel_depth = row_info->bit_depth;
         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
      }
      else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA &&
         palette_lookup != NULL && row_info->bit_depth == 8)
      {
         int r, g, b, p;
         sp = row;
         dp = row;
         for (i = 0; i < row_width; i++)
         {
            r = *sp++;
            g = *sp++;
            b = *sp++;
            sp++;

            p = (((r >> (8 - PNG_DITHER_RED_BITS)) &
               ((1 << PNG_DITHER_RED_BITS) - 1)) <<
               (PNG_DITHER_GREEN_BITS + PNG_DITHER_BLUE_BITS)) |
               (((g >> (8 - PNG_DITHER_GREEN_BITS)) &
               ((1 << PNG_DITHER_GREEN_BITS) - 1)) <<
               (PNG_DITHER_BLUE_BITS)) |
               ((b >> (8 - PNG_DITHER_BLUE_BITS)) &
               ((1 << PNG_DITHER_BLUE_BITS) - 1));

            *dp++ = palette_lookup[p];
         }
         row_info->color_type = PNG_COLOR_TYPE_PALETTE;
         row_info->channels = 1;
         row_info->pixel_depth = row_info->bit_depth;
         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
      }
      else if (row_info->color_type == PNG_COLOR_TYPE_PALETTE &&
         dither_lookup && row_info->bit_depth == 8)
      {
         sp = row;
         for (i = 0; i < row_width; i++, sp++)
         {
            *sp = dither_lookup[*sp];
         }
      }
   }
}
#endif

#ifdef PNG_FLOATING_POINT_SUPPORTED
#ifdef PNG_READ_GAMMA_SUPPORTED
static PNG_CONST int png_gamma_shift[] =
   {0x10, 0x21, 0x42, 0x84, 0x110, 0x248, 0x550, 0xff0, 0x00};

/* We build the 8- or 16-bit gamma tables here.  Note that for 16-bit
 * tables, we don't make a full table if we are reducing to 8-bit in
 * the future.  Note also how the gamma_16 tables are segmented so that
 * we don't need to allocate > 64K chunks for a full 16-bit table.
 *
 * See the PNG extensions document for an integer algorithm for creating
 * the gamma tables.  Maybe we will implement that here someday.
 *
 * We should only reach this point if
 *
 *      the file_gamma is known (i.e., the gAMA or sRGB chunk is present,
 *      or the application has provided a file_gamma)
 *
 *   AND
 *      {
 *         the screen_gamma is known
 *      OR
 *
 *         RGB_to_gray transformation is being performed
 *      }
 *
 *   AND
 *      {
 *         the screen_gamma is different from the reciprocal of the
 *         file_gamma by more than the specified threshold
 *
 *      OR
 *
 *         a background color has been specified and the file_gamma
 *         and screen_gamma are not 1.0, within the specified threshold.
 *      }
 */

void /* PRIVATE */
png_build_gamma_table(png_structp png_ptr)
{
  png_debug(1, "in png_build_gamma_table");

  if (png_ptr->bit_depth <= 8)
  {
     int i;
     double g;

     if (png_ptr->screen_gamma > .000001)
        g = 1.0 / (png_ptr->gamma * png_ptr->screen_gamma);

     else
        g = 1.0;

     png_ptr->gamma_table = (png_bytep)png_malloc(png_ptr,
        (png_uint_32)256);

     for (i = 0; i < 256; i++)
     {
        png_ptr->gamma_table[i] = (png_byte)(pow((double)i / 255.0,
           g) * 255.0 + .5);
     }

#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \
   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
     if (png_ptr->transformations & ((PNG_BACKGROUND) | PNG_RGB_TO_GRAY))
     {

        g = 1.0 / (png_ptr->gamma);

        png_ptr->gamma_to_1 = (png_bytep)png_malloc(png_ptr,
           (png_uint_32)256);

        for (i = 0; i < 256; i++)
        {
           png_ptr->gamma_to_1[i] = (png_byte)(pow((double)i / 255.0,
              g) * 255.0 + .5);
        }


        png_ptr->gamma_from_1 = (png_bytep)png_malloc(png_ptr,
           (png_uint_32)256);

        if (png_ptr->screen_gamma > 0.000001)
           g = 1.0 / png_ptr->screen_gamma;

        else
           g = png_ptr->gamma;   /* Probably doing rgb_to_gray */

        for (i = 0; i < 256; i++)
        {
           png_ptr->gamma_from_1[i] = (png_byte)(pow((double)i / 255.0,
              g) * 255.0 + .5);

        }
     }
#endif /* PNG_READ_BACKGROUND_SUPPORTED || PNG_RGB_TO_GRAY_SUPPORTED */
  }
  else
  {
     double g;
     int i, j, shift, num;
     int sig_bit;
     png_uint_32 ig;

     if (png_ptr->color_type & PNG_COLOR_MASK_COLOR)
     {
        sig_bit = (int)png_ptr->sig_bit.red;

        if ((int)png_ptr->sig_bit.green > sig_bit)
           sig_bit = png_ptr->sig_bit.green;

        if ((int)png_ptr->sig_bit.blue > sig_bit)
           sig_bit = png_ptr->sig_bit.blue;
     }
     else
     {
        sig_bit = (int)png_ptr->sig_bit.gray;
     }

     if (sig_bit > 0)
        shift = 16 - sig_bit;

     else
        shift = 0;

     if (png_ptr->transformations & PNG_16_TO_8)
     {
        if (shift < (16 - PNG_MAX_GAMMA_8))
           shift = (16 - PNG_MAX_GAMMA_8);
     }

     if (shift > 8)
        shift = 8;

     if (shift < 0)
        shift = 0;

     png_ptr->gamma_shift = (png_byte)shift;

     num = (1 << (8 - shift));

     if (png_ptr->screen_gamma > .000001)
        g = 1.0 / (png_ptr->gamma * png_ptr->screen_gamma);
     else
        g = 1.0;

     png_ptr->gamma_16_table = (png_uint_16pp)png_calloc(png_ptr,
        (png_uint_32)(num * png_sizeof(png_uint_16p)));

     if (png_ptr->transformations & (PNG_16_TO_8 | PNG_BACKGROUND))
     {
        double fin, fout;
        png_uint_32 last, max;

        for (i = 0; i < num; i++)
        {
           png_ptr->gamma_16_table[i] = (png_uint_16p)png_malloc(png_ptr,
              (png_uint_32)(256 * png_sizeof(png_uint_16)));
        }

        g = 1.0 / g;
        last = 0;
        for (i = 0; i < 256; i++)
        {
           fout = ((double)i + 0.5) / 256.0;
           fin = pow(fout, g);
           max = (png_uint_32)(fin * (double)((png_uint_32)num << 8));
           while (last <= max)
           {
              png_ptr->gamma_16_table[(int)(last & (0xff >> shift))]
                 [(int)(last >> (8 - shift))] = (png_uint_16)(
                 (png_uint_16)i | ((png_uint_16)i << 8));
              last++;
           }
        }
        while (last < ((png_uint_32)num << 8))
        {
           png_ptr->gamma_16_table[(int)(last & (0xff >> shift))]
              [(int)(last >> (8 - shift))] = (png_uint_16)65535L;
           last++;
        }
     }
     else
     {
        for (i = 0; i < num; i++)
        {
           png_ptr->gamma_16_table[i] = (png_uint_16p)png_malloc(png_ptr,
              (png_uint_32)(256 * png_sizeof(png_uint_16)));

           ig = (((png_uint_32)i * (png_uint_32)png_gamma_shift[shift]) >> 4);

           for (j = 0; j < 256; j++)
           {
              png_ptr->gamma_16_table[i][j] =
                 (png_uint_16)(pow((double)(ig + ((png_uint_32)j << 8)) /
                    65535.0, g) * 65535.0 + .5);
           }
        }
     }

#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \
   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
     if (png_ptr->transformations & (PNG_BACKGROUND | PNG_RGB_TO_GRAY))
     {

        g = 1.0 / (png_ptr->gamma);

        png_ptr->gamma_16_to_1 = (png_uint_16pp)png_calloc(png_ptr,
           (png_uint_32)(num * png_sizeof(png_uint_16p )));

        for (i = 0; i < num; i++)
        {
           png_ptr->gamma_16_to_1[i] = (png_uint_16p)png_malloc(png_ptr,
              (png_uint_32)(256 * png_sizeof(png_uint_16)));

           ig = (((png_uint_32)i *
              (png_uint_32)png_gamma_shift[shift]) >> 4);
           for (j = 0; j < 256; j++)
           {
              png_ptr->gamma_16_to_1[i][j] =
                 (png_uint_16)(pow((double)(ig + ((png_uint_32)j << 8)) /
                    65535.0, g) * 65535.0 + .5);
           }
        }

        if (png_ptr->screen_gamma > 0.000001)
           g = 1.0 / png_ptr->screen_gamma;

        else
           g = png_ptr->gamma;   /* Probably doing rgb_to_gray */

        png_ptr->gamma_16_from_1 = (png_uint_16pp)png_calloc(png_ptr,
           (png_uint_32)(num * png_sizeof(png_uint_16p)));

        for (i = 0; i < num; i++)
        {
           png_ptr->gamma_16_from_1[i] = (png_uint_16p)png_malloc(png_ptr,
              (png_uint_32)(256 * png_sizeof(png_uint_16)));

           ig = (((png_uint_32)i *
              (png_uint_32)png_gamma_shift[shift]) >> 4);

           for (j = 0; j < 256; j++)
           {
              png_ptr->gamma_16_from_1[i][j] =
                 (png_uint_16)(pow((double)(ig + ((png_uint_32)j << 8)) /
                    65535.0, g) * 65535.0 + .5);
           }
        }
     }
#endif /* PNG_READ_BACKGROUND_SUPPORTED || PNG_RGB_TO_GRAY_SUPPORTED */
  }
}
#endif
/* To do: install integer version of png_build_gamma_table here */
#endif

#ifdef PNG_MNG_FEATURES_SUPPORTED
/* Undoes intrapixel differencing  */
void /* PRIVATE */
png_do_read_intrapixel(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_read_intrapixel");

   if (
#ifdef PNG_USELESS_TESTS_SUPPORTED
       row != NULL && row_info != NULL &&
#endif
       (row_info->color_type & PNG_COLOR_MASK_COLOR))
   {
      int bytes_per_pixel;
      png_uint_32 row_width = row_info->width;
      if (row_info->bit_depth == 8)
      {
         png_bytep rp;
         png_uint_32 i;

         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
            bytes_per_pixel = 3;

         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
            bytes_per_pixel = 4;

         else
            return;

         for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)
         {
            *(rp) = (png_byte)((256 + *rp + *(rp+1))&0xff);
            *(rp+2) = (png_byte)((256 + *(rp+2) + *(rp+1))&0xff);
         }
      }
      else if (row_info->bit_depth == 16)
      {
         png_bytep rp;
         png_uint_32 i;

         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
            bytes_per_pixel = 6;

         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
            bytes_per_pixel = 8;

         else
            return;

         for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)
         {
            png_uint_32 s0   = (*(rp    ) << 8) | *(rp + 1);
            png_uint_32 s1   = (*(rp + 2) << 8) | *(rp + 3);
            png_uint_32 s2   = (*(rp + 4) << 8) | *(rp + 5);
            png_uint_32 red  = (png_uint_32)((s0 + s1 + 65536L) & 0xffffL);
            png_uint_32 blue = (png_uint_32)((s2 + s1 + 65536L) & 0xffffL);
            *(rp  ) = (png_byte)((red >> 8) & 0xff);
            *(rp+1) = (png_byte)(red & 0xff);
            *(rp+4) = (png_byte)((blue >> 8) & 0xff);
            *(rp+5) = (png_byte)(blue & 0xff);
         }
      }
   }
}
#endif /* PNG_MNG_FEATURES_SUPPORTED */
#endif /* PNG_READ_SUPPORTED */
@


1.9
log
@merge, rebase/minify, fix
@
text
@d4 2
a5 2
 * Last changed in libpng 1.2.49 [March 29, 2012]
 * Copyright (c) 1998-2012 Glenn Randers-Pehrson
d920 1
d922 2
d1382 3
d2413 1
d2415 6
a2420 3
                  red   = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;
                  green = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;
                  blue  = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;
d2452 1
d2454 6
a2459 3
                  red   = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;
                  green = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;
                  blue  = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;
d2519 1
d2521 6
a2526 3
                  red   = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;
                  green = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;
                  blue  = (png_uint_16)(((*(sp))<<8) | *(sp+1)); sp+=2;
@


1.8
log
@SECURITY update; prodded by bsiegert@@
@
text
@d4 2
a5 3
 * Last changed in libpng 1.2.35 [February 14, 2009]
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1998-2009 Glenn Randers-Pehrson
d9 4
d20 1
d22 1
a22 1
#if defined(PNG_READ_SUPPORTED)
d29 4
a33 1
   if (png_ptr == NULL) return;
d36 1
a36 1
      case PNG_CRC_NO_CHANGE:                        /* leave setting as is */
d38 2
a39 1
      case PNG_CRC_WARN_USE:                               /* warn/use data */
d43 2
a44 1
      case PNG_CRC_QUIET_USE:                             /* quiet/use data */
d49 2
a50 1
      case PNG_CRC_WARN_DISCARD:    /* not a valid action for critical data */
d53 2
a54 1
      case PNG_CRC_ERROR_QUIT:                                /* error/quit */
d61 1
d64 1
a64 1
      case PNG_CRC_NO_CHANGE:                       /* leave setting as is */
d66 2
a67 1
      case PNG_CRC_WARN_USE:                              /* warn/use data */
d71 2
a72 1
      case PNG_CRC_QUIET_USE:                            /* quiet/use data */
d77 2
a78 1
      case PNG_CRC_ERROR_QUIT:                               /* error/quit */
d82 3
a84 1
      case PNG_CRC_WARN_DISCARD:                      /* warn/discard data */
d94 1
a94 1
/* handle alpha and tRNS via a background color */
d101 3
a103 1
   if (png_ptr == NULL) return;
d119 2
a120 2
#if defined(PNG_READ_16_TO_8_SUPPORTED)
/* strip 16 bit depth files to 8 bit depth */
d125 3
a127 1
   if (png_ptr == NULL) return;
d132 1
a132 1
#if defined(PNG_READ_STRIP_ALPHA_SUPPORTED)
d137 3
a139 1
   if (png_ptr == NULL) return;
d144 1
a144 1
#if defined(PNG_READ_DITHER_SUPPORTED)
d169 3
a171 1
   if (png_ptr == NULL) return;
d189 2
a190 1
            Perhaps not the best solution, but good enough. */
d194 1
a194 1
         /* initialize an array to sort colors */
d198 1
a198 1
         /* initialize the dither_sort array */
d203 5
a207 4
            bubble sort, and running it until we have sorted
            out enough colors.  Note that we don't care about
            sorting all the colors, just finding which are
            least used. */
d211 1
a211 1
            int done; /* to stop early if the list is pre-sorted */
d232 1
a232 1
         /* swap the palette around, and set up a table, if necessary */
d237 3
a239 2
            /* put all the useful colors within the max, but don't
               move the others */
d255 3
a257 2
            /* move all the used colors inside the max limit, and
               develop a translation table */
d260 1
a260 1
               /* only move the colors we need to */
d272 1
a272 1
                  /* indicate where the color went */
d278 1
a278 1
            /* find closest color for those colors we are not using */
d285 1
a285 1
                  /* find the closest color to one we threw out */
d300 1
a300 1
                  /* point to closest color */
d311 7
a317 7
            we need to go through a median cut routine, but those
            don't always behave themselves with only a few colors
            as input.  So we will just find the closest two colors,
            and throw out one of them (chosen somewhat randomly).
            [We don't understand this at all, so if someone wants to
             work on improving it, be our guest - AED, GRP]
            */
d326 1
a326 1
         /* initialize palette index arrays */
d332 1
a332 1
         /* initialize the sort array */
d339 1
a339 1
         hash = (png_dsortpp)png_malloc(png_ptr, (png_uint_32)(769 *
a340 1
         png_memset(hash, 0, 769 * png_sizeof(png_dsortp));
d344 8
a351 8
         /* initial wild guess at how far apart the farthest pixel
            pair we will be eliminating will be.  Larger
            numbers mean more areas will be allocated, Smaller
            numbers run the risk of not saving enough data, and
            having to do this all over again.

            I have not done extensive checking on this number.
            */
d435 4
a438 2
                        png_ptr->index_to_palette[j] = (png_byte)num_new_palette;
                        png_ptr->palette_to_index[num_new_palette] = (png_byte)j;
d489 1
a489 1
      png_ptr->palette_lookup = (png_bytep )png_malloc(png_ptr,
a491 3
      png_memset(png_ptr->palette_lookup, 0, num_entries *
         png_sizeof(png_byte));

a493 1

d507 2
a508 1
            int index_r = (ir << (PNG_DITHER_BLUE_BITS + PNG_DITHER_GREEN_BITS));
d555 4
a558 1
   if (png_ptr == NULL) return;
d568 1
a568 1
#if defined(PNG_READ_EXPAND_SUPPORTED)
d577 4
a580 1
   if (png_ptr == NULL) return;
d598 3
a600 2
 *  GRP 20060307: In libpng-1.4.0, png_set_gray_1_2_4_to_8() was modified
 *  to expand only the sample depth but not to expand the tRNS to alpha.
d608 4
a611 1
   if (png_ptr == NULL) return;
d616 1
a616 1
#if !defined(PNG_1_0_X)
d622 4
a625 1
   if (png_ptr == NULL) return;
d638 4
a641 1
   if (png_ptr == NULL) return;
d652 1
d658 1
a658 1
#if defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
d663 1
d669 2
a670 2
#if defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
#if defined(PNG_FLOATING_POINT_SUPPORTED)
d679 16
a694 4
      int red_fixed = (int)((float)red*100000.0 + 0.5);
      int green_fixed = (int)((float)green*100000.0 + 0.5);
      if (png_ptr == NULL) return;
      png_set_rgb_to_gray_fixed(png_ptr, error_action, red_fixed, green_fixed);
d703 4
a706 1
   if (png_ptr == NULL) return;
d711 1
d714 1
d718 1
a718 1
#if defined(PNG_READ_EXPAND_SUPPORTED)
d736 2
a737 2
        red_int = (png_uint_16)(((png_uint_32)red*32768L)/100000L);
        green_int = (png_uint_16)(((png_uint_32)green*32768L)/100000L);
d754 2
a755 2
    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED) || \
    defined(PNG_LEGACY_SUPPORTED)
d761 5
a765 2
   if (png_ptr == NULL) return;
#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
d784 3
a786 2
#if defined(PNG_USELESS_TESTS_SUPPORTED)
   if (png_ptr != NULL)
d789 3
a791 2
#if defined(PNG_READ_BACKGROUND_SUPPORTED) || defined(PNG_READ_SHIFT_SUPPORTED) \
 || defined(PNG_READ_GAMMA_SUPPORTED)
d797 1
a797 1
#if defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
d799 3
a801 2
    * for gray --> RGB case */
   /* Note:  if PNG_BACKGROUND_EXPAND is set and color_type is either RGB or
d828 1
a828 1
         /* expand background and tRNS chunks */
d842 1
d854 1
d866 1
d868 1
d884 1
a884 1
#if defined(PNG_READ_INVERT_ALPHA_SUPPORTED)
d887 1
a887 1
#if defined(PNG_READ_EXPAND_SUPPORTED)
d891 3
a893 2
           /* invert the alpha channel (in tRNS) unless the pixels are
              going to be expanded, in which case leave it for later */
d920 1
a920 1
        k=1; /* partial transparency is present */
d930 2
a931 1
#if defined(PNG_READ_BACKGROUND_SUPPORTED)
d936 1
a936 2
           /* could skip if no transparency and
           */
d961 1
d966 1
d988 2
a989 1
                     (double)png_ptr->background.green/255, gs) * 255.0 + .5);
d1033 8
a1040 8
	    /* Prevent the transformations being done again, and make sure
	     * that the now spurious alpha channel is stripped - the code
	     * has just reduced background composition and gamma correction
	     * to a simple alpha channel strip.
	     */
	    png_ptr->transformations &= ~PNG_BACKGROUND;
	    png_ptr->transformations &= ~PNG_GAMMA;
	    png_ptr->transformations |= PNG_STRIP_ALPHA;
d1056 1
d1061 1
d1103 1
a1103 1
      /* transformation does not include PNG_BACKGROUND */
d1118 2
a1119 2
	 /* Done the gamma correction. */
	 png_ptr->transformations &= ~PNG_GAMMA;
d1122 1
a1122 1
#if defined(PNG_READ_BACKGROUND_SUPPORTED)
d1126 1
a1126 1
#if defined(PNG_READ_BACKGROUND_SUPPORTED)
d1164 1
a1164 1
#if defined(PNG_READ_SHIFT_SUPPORTED)
d1166 1
d1187 2
d1207 2
a1208 1
#if defined(PNG_READ_EXPAND_SUPPORTED)
d1213 1
a1213 2
         if (png_ptr->num_trans &&
              (png_ptr->transformations & PNG_EXPAND_tRNS))
a1225 4
#if 0 /* Removed from libpng-1.2.27 */
            else
              info_ptr->color_type |= PNG_COLOR_MASK_COLOR;
#endif
d1234 1
a1234 1
#if defined(PNG_READ_BACKGROUND_SUPPORTED)
d1243 1
a1243 1
#if defined(PNG_READ_GAMMA_SUPPORTED)
d1255 1
a1255 1
#if defined(PNG_READ_16_TO_8_SUPPORTED)
d1260 1
a1260 1
#if defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
d1265 1
a1265 1
#if defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
d1270 1
a1270 1
#if defined(PNG_READ_DITHER_SUPPORTED)
d1274 2
a1275 2
         (info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)) &&
         png_ptr->palette_lookup && info_ptr->bit_depth == 8)
d1282 1
a1282 1
#if defined(PNG_READ_PACK_SUPPORTED)
d1294 1
a1294 1
#if defined(PNG_READ_STRIP_ALPHA_SUPPORTED)
d1302 1
a1302 1
#if defined(PNG_READ_FILLER_SUPPORTED)
d1309 2
a1310 2
      /* if adding a true alpha channel not just filler */
#if !defined(PNG_1_0_X)
d1333 1
a1333 1
#if !defined(PNG_READ_EXPAND_SUPPORTED)
d1347 1
d1350 1
a1350 1
#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)
d1365 2
a1366 1
       * pixels.  This check added to libpng-1.2.19 */
d1374 1
a1374 1
#if defined(PNG_READ_EXPAND_SUPPORTED)
d1395 1
a1395 1
#if defined(PNG_READ_STRIP_ALPHA_SUPPORTED)
d1401 1
a1401 1
#if defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
d1405 2
a1406 1
         png_do_rgb_to_gray(png_ptr, &(png_ptr->row_info), png_ptr->row_buf + 1);
d1420 29
a1448 28
/*
From Andreas Dilger e-mail to png-implement, 26 March 1998:

  In most cases, the "simple transparency" should be done prior to doing
  gray-to-RGB, or you will have to test 3x as many bytes to check if a
  pixel is transparent.  You would also need to make sure that the
  transparency information is upgraded to RGB.

  To summarize, the current flow is:
  - Gray + simple transparency -> compare 1 or 2 gray bytes and composite
                                  with background "in place" if transparent,
                                  convert to RGB if necessary
  - Gray + alpha -> composite with gray background and remove alpha bytes,
                                  convert to RGB if necessary

  To support RGB backgrounds for gray images we need:
  - Gray + simple transparency -> convert to RGB + simple transparency, compare
                                  3 or 6 bytes and composite with background
                                  "in place" if transparent (3x compare/pixel
                                  compared to doing composite with gray bkgrnd)
  - Gray + alpha -> convert to RGB + alpha, composite with background and
                                  remove alpha bytes (3x float operations/pixel
                                  compared with composite on gray background)

  Greg's change will do this.  The reason it wasn't done before is for
  performance, as this increases the per-pixel operations.  If we would check
  in advance if the background was gray or RGB, and position the gray-to-RGB
  transform appropriately, then it would save a lot of work/time.
d1451 4
a1454 3
#if defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
   /* if gray -> RGB, do so now only if background is non-gray; else do later
    * for performance reasons */
d1460 1
a1460 1
#if defined(PNG_READ_BACKGROUND_SUPPORTED)
d1466 1
a1466 1
#if defined(PNG_READ_GAMMA_SUPPORTED)
d1476 1
a1476 1
#if defined(PNG_READ_GAMMA_SUPPORTED)
d1478 4
a1481 4
#if defined(PNG_READ_BACKGROUND_SUPPORTED)
      !((png_ptr->transformations & PNG_BACKGROUND) &&
      ((png_ptr->num_trans != 0) ||
      (png_ptr->color_type & PNG_COLOR_MASK_ALPHA))) &&
d1483 1
a1483 1
      (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE))
d1485 2
a1486 2
         png_ptr->gamma_table, png_ptr->gamma_16_table,
         png_ptr->gamma_shift);
d1489 1
a1489 1
#if defined(PNG_READ_16_TO_8_SUPPORTED)
d1494 1
a1494 1
#if defined(PNG_READ_DITHER_SUPPORTED)
d1504 1
a1504 1
#if defined(PNG_READ_INVERT_SUPPORTED)
d1509 1
a1509 1
#if defined(PNG_READ_SHIFT_SUPPORTED)
d1515 1
a1515 1
#if defined(PNG_READ_PACK_SUPPORTED)
d1520 1
a1520 1
#if defined(PNG_READ_BGR_SUPPORTED)
d1525 1
a1525 1
#if defined(PNG_READ_PACKSWAP_SUPPORTED)
d1530 2
a1531 2
#if defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
   /* if gray -> RGB, do so now only if we did not do so above */
d1537 1
a1537 1
#if defined(PNG_READ_FILLER_SUPPORTED)
d1543 1
a1543 1
#if defined(PNG_READ_INVERT_ALPHA_SUPPORTED)
d1548 1
a1548 1
#if defined(PNG_READ_SWAP_ALPHA_SUPPORTED)
d1553 1
a1553 1
#if defined(PNG_READ_SWAP_SUPPORTED)
d1558 1
a1558 1
#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
d1562 11
a1572 11
        (*(png_ptr->read_user_transform_fn)) /* user read transform function */
          (png_ptr,                    /* png_ptr */
           &(png_ptr->row_info),       /* row_info:     */
             /*  png_uint_32 width;          width of row */
             /*  png_uint_32 rowbytes;       number of bytes in row */
             /*  png_byte color_type;        color type of pixels */
             /*  png_byte bit_depth;         bit depth of samples */
             /*  png_byte channels;          number of channels (1-4) */
             /*  png_byte pixel_depth;       bits per pixel (depth*channels) */
           png_ptr->row_buf + 1);      /* start of pixel data for row */
#if defined(PNG_USER_TRANSFORM_PTR_SUPPORTED)
d1587 1
a1587 1
#if defined(PNG_READ_PACK_SUPPORTED)
d1598 2
a1599 1
#if defined(PNG_USELESS_TESTS_SUPPORTED)
d1630 1
d1652 1
d1681 1
a1681 1
#if defined(PNG_READ_SHIFT_SUPPORTED)
d1691 1
d1693 1
a1693 1
#if defined(PNG_USELESS_TESTS_SUPPORTED)
d1745 1
d1761 1
d1774 1
d1795 2
a1796 2
#if defined(PNG_READ_16_TO_8_SUPPORTED)
/* chop rows of bit depth 16 down to 8 */
d1801 2
a1802 1
#if defined(PNG_USELESS_TESTS_SUPPORTED)
d1815 1
a1815 1
#if defined(PNG_READ_16_TO_8_ACCURATE_SCALE_SUPPORTED)
d1821 2
a1822 1
       *          (png_uint_32)(*(sp + 1))) * 255 + 127) / (png_uint_32)65535L;
d1826 2
a1827 1
       *           (png_uint_32)(*(sp + 1))) + 128L) / (png_uint_32)257L;
d1830 2
a1831 1
       *   temp = (((png_uint_32)(*sp) << 8) | (png_uint_32)(*(sp + 1))) + 128L;
d1854 1
a1854 1
#if defined(PNG_READ_SWAP_ALPHA_SUPPORTED)
d1859 2
a1860 1
#if defined(PNG_USELESS_TESTS_SUPPORTED)
d1947 1
a1947 1
#if defined(PNG_READ_INVERT_ALPHA_SUPPORTED)
d1952 2
a1953 1
#if defined(PNG_USELESS_TESTS_SUPPORTED)
d2046 1
a2046 1
#if defined(PNG_READ_FILLER_SUPPORTED)
d2059 1
d2061 1
a2061 1
#if defined(PNG_USELESS_TESTS_SUPPORTED)
d2223 2
a2224 2
#if defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
/* expand grayscale files to RGB, with or without alpha */
d2232 1
d2234 1
a2234 1
#if defined(PNG_USELESS_TESTS_SUPPORTED)
d2307 2
a2308 2
#if defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
/* reduce RGB files to grayscale, with or without alpha
d2339 1
d2341 1
a2341 1
#if defined(PNG_USELESS_TESTS_SUPPORTED)
d2418 2
a2419 1
                     png_uint_16 green_1 = png_ptr->gamma_16_to_1[(green&0xff) >>
d2515 4
a2518 3
                                  png_ptr->gamma_shift][red>>8];
                     png_uint_16 green_1 = png_ptr->gamma_16_to_1[(green&0xff) >>
                                  png_ptr->gamma_shift][green>>8];
d2520 1
a2520 1
                                  png_ptr->gamma_shift][blue>>8];
d2522 1
a2522 1
                                  + gc * green_1 + bc * blue_1)>>15);
d2580 1
d2590 1
d2595 1
d2600 1
d2605 1
d2621 2
a2622 1
#if defined(PNG_READ_DITHER_SUPPORTED) && defined(PNG_CORRECT_PALETTE_SUPPORTED)
d2628 1
d2630 2
a2631 1
    defined(PNG_READ_GAMMA_SUPPORTED) && defined(PNG_FLOATING_POINT_SUPPORTED)
d2652 2
a2653 2
         if (png_ptr->background_gamma_type == PNG_BACKGROUND_GAMMA_SCREEN ||
             fabs(g - 1.0) < PNG_GAMMA_THRESHOLD)
d2740 1
a2740 1
#if defined(PNG_READ_GAMMA_SUPPORTED)
d2752 1
a2752 1
#if defined(PNG_READ_BACKGROUND_SUPPORTED)
d2756 1
a2756 1
#if defined(PNG_READ_BACKGROUND_SUPPORTED)
d2786 1
a2786 1
      else /* assume grayscale palette (what else could it be?) */
d2805 1
a2805 1
#if defined(PNG_READ_BACKGROUND_SUPPORTED)
d2813 1
a2813 1
#if defined(PNG_READ_GAMMA_SUPPORTED)
d2827 1
d2829 1
a2829 1
#if defined(PNG_USELESS_TESTS_SUPPORTED)
d2863 1
d2866 1
a2866 1
#if defined(PNG_READ_GAMMA_SUPPORTED)
d2920 1
d2923 1
a2923 1
#if defined(PNG_READ_GAMMA_SUPPORTED)
d2977 1
d2980 1
a2980 1
#if defined(PNG_READ_GAMMA_SUPPORTED)
d3010 1
d3013 1
a3013 1
#if defined(PNG_READ_GAMMA_SUPPORTED)
d3024 1
a3024 1
                           /* background is already in screen gamma */
d3057 1
d3062 1
a3062 1
#if defined(PNG_READ_GAMMA_SUPPORTED)
d3103 1
a3103 1
#if defined(PNG_READ_GAMMA_SUPPORTED)
d3115 1
a3115 1
                        /* background is already in screen gamma */
d3162 1
d3167 1
a3167 1
#if defined(PNG_READ_GAMMA_SUPPORTED)
d3183 1
a3183 1
                        /* background is already in screen gamma */
d3209 1
a3209 1
#if defined(PNG_READ_GAMMA_SUPPORTED)
d3226 1
a3226 1
#if defined(PNG_READ_GAMMA_SUPPORTED)
d3244 1
a3244 1
#if defined(PNG_READ_GAMMA_SUPPORTED)
d3250 1
a3250 1
                        /* background is already in screen gamma */
d3254 1
a3254 1
#if defined(PNG_READ_GAMMA_SUPPORTED)
d3280 1
a3280 1
#if defined(PNG_READ_GAMMA_SUPPORTED)
d3289 1
a3289 1
#if defined(PNG_READ_GAMMA_SUPPORTED)
d3305 1
d3310 1
a3310 1
#if defined(PNG_READ_GAMMA_SUPPORTED)
d3328 1
a3328 1
                        /* background is already in screen gamma */
d3383 1
a3383 1
#if defined(PNG_READ_GAMMA_SUPPORTED)
d3409 1
a3409 1
                        /* background is already in screen gamma */
d3500 1
a3500 1
#if defined(PNG_READ_GAMMA_SUPPORTED)
d3517 1
d3519 1
a3519 1
#if defined(PNG_USELESS_TESTS_SUPPORTED)
d3565 1
d3603 1
d3628 1
d3642 4
a3645 4
                        ((((int)gamma_table[a|(a>>2)|(a>>4)|(a>>6)])   ) & 0xc0)|
                        ((((int)gamma_table[(b<<2)|b|(b>>2)|(b>>4)])>>2) & 0x30)|
                        ((((int)gamma_table[(c<<4)|(c<<2)|c|(c>>2)])>>4) & 0x0c)|
                        ((((int)gamma_table[(d<<6)|(d<<4)|(d<<2)|d])>>6) ));
d3649 1
d3659 1
a3659 1
                          | (((int)gamma_table[(lsb << 4) | lsb]) >> 4));
d3663 1
d3673 1
d3692 1
a3692 1
#if defined(PNG_READ_EXPAND_SUPPORTED)
d3706 1
d3708 1
a3708 1
#if defined(PNG_USELESS_TESTS_SUPPORTED)
d3740 1
d3762 1
d3827 1
d3853 2
a3854 1
#if defined(PNG_USELESS_TESTS_SUPPORTED)
d3890 1
d3914 1
d3938 1
d3960 1
d3983 1
d4055 1
a4055 1
#if defined(PNG_READ_DITHER_SUPPORTED)
d4065 2
a4066 1
#if defined(PNG_USELESS_TESTS_SUPPORTED)
d4082 7
a4088 7
            /* this looks real messy, but the compiler will reduce
               it down to a reasonable formula.  For example, with
               5 bits per color, we get:
               p = (((r >> 3) & 0x1f) << 10) |
                  (((g >> 3) & 0x1f) << 5) |
                  ((b >> 3) & 0x1f);
               */
d4148 2
a4149 2
#if defined(PNG_READ_GAMMA_SUPPORTED)
static const int png_gamma_shift[] =
d4156 27
d4184 1
d4197 1
d4232 1
d4234 1
a4234 1
           g = png_ptr->gamma;   /* probably doing rgb_to_gray */
d4255 1
d4258 1
d4269 1
d4281 1
d4294 1
a4294 1
     png_ptr->gamma_16_table = (png_uint_16pp)png_malloc(png_ptr,
a4301 2
        png_memset(png_ptr->gamma_16_table, 0, num * png_sizeof(png_uint_16p)); 

d4338 1
d4355 1
a4355 1
        png_ptr->gamma_16_to_1 = (png_uint_16pp)png_malloc(png_ptr,
a4357 2
        png_memset(png_ptr->gamma_16_to_1, 0, num * png_sizeof(png_uint_16p)); 

d4375 1
d4377 1
a4377 1
           g = png_ptr->gamma;   /* probably doing rgb_to_gray */
d4379 1
a4379 1
        png_ptr->gamma_16_from_1 = (png_uint_16pp)png_malloc(png_ptr,
a4381 3
        png_memset(png_ptr->gamma_16_from_1, 0,
           num * png_sizeof(png_uint_16p)); 

d4389 1
d4405 2
a4406 2
#if defined(PNG_MNG_FEATURES_SUPPORTED)
/* undoes intrapixel differencing  */
d4411 1
d4413 1
a4413 1
#if defined(PNG_USELESS_TESTS_SUPPORTED)
d4427 1
d4430 1
d4447 1
d4450 1
@


1.7
log
@merge libpng upgrade

major version bump because function signature of png_decompress_chunk
changed (return value to void)
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.30 [August 15, 2008]
d6 1
a6 1
 * Copyright (c) 1998-2008 Glenn Randers-Pehrson
d24 1
a24 1
   png_debug(1, "in png_set_crc_action\n");
d83 1
a83 1
   png_debug(1, "in png_set_background\n");
d105 1
a105 1
   png_debug(1, "in png_set_strip_16\n");
d115 1
a115 1
   png_debug(1, "in png_set_strip_alpha\n");
d145 1
a145 1
   png_debug(1, "in png_set_dither\n");
d312 1
a312 3
         for (i = 0; i < 769; i++)
            hash[i] = NULL;
/*         png_memset(hash, 0, 769 * png_sizeof(png_dsortp)); */
d527 1
a527 1
   png_debug(1, "in png_set_gamma\n");
d546 1
a546 1
   png_debug(1, "in png_set_expand\n");
d573 1
a573 1
   png_debug(1, "in png_set_palette_to_rgb\n");
d584 1
a584 1
   png_debug(1, "in png_set_expand_gray_1_2_4_to_8\n");
d597 1
a597 1
   png_debug(1, "in png_set_gray_1_2_4_to_8\n");
d608 1
a608 1
   png_debug(1, "in png_set_tRNS_to_alpha\n");
d618 1
a618 1
   png_debug(1, "in png_set_gray_to_rgb\n");
d645 1
a645 1
   png_debug(1, "in png_set_rgb_to_gray\n");
d685 1
a685 1
      png_ptr->rgb_to_gray_blue_coeff  = 
d698 1
a698 1
   png_debug(1, "in png_set_read_user_transform_fn\n");
d718 1
a718 1
   png_debug(1, "in png_init_read_transformations\n");
d1125 1
a1125 1
   png_debug(1, "in png_read_transform_info\n");
d1269 1
a1269 1
   png_debug(1, "in png_do_read_transformations\n");
d1330 1
a1330 1
         if ((png_ptr->transformations & PNG_RGB_TO_GRAY) == 
d1515 1
a1515 1
   png_debug(1, "in png_do_unpack\n");
d1605 1
a1605 1
   png_debug(1, "in png_do_unshift\n");
d1711 1
a1711 1
   png_debug(1, "in png_do_chop\n");
d1765 1
a1765 1
   png_debug(1, "in png_do_read_swap_alpha\n");
d1857 1
a1857 1
   png_debug(1, "in png_do_read_invert_alpha\n");
d1963 1
a1963 1
   png_debug(1, "in png_do_read_filler\n");
d2135 1
a2135 1
   png_debug(1, "in png_do_gray_to_rgb\n");
d2241 1
a2241 1
   png_debug(1, "in png_do_rgb_to_gray\n");
d2479 1
a2479 1
   png_debug(1, "in png_do_build_grayscale_palette\n");
d2521 1
a2521 1
   png_debug(1, "in png_correct_palette\n");
d2718 1
a2718 1
   png_debug(1, "in png_do_background\n");
d3400 1
a3400 1
   png_debug(1, "in png_do_gamma\n");
d3582 1
a3582 1
   png_debug(1, "in png_do_expand_palette\n");
d3725 1
a3725 1
   png_debug(1, "in png_do_expand\n");
d3837 1
a3837 1
                  if (*(sp - 1) == gray_high && *(sp) == gray_low) 
d3931 1
a3931 1
   png_debug(1, "in png_do_dither\n");
d4026 1
a4026 1
  png_debug(1, "in png_build_gamma_table\n");
d4134 2
d4191 2
d4216 3
d4246 1
a4246 1
   png_debug(1, "in png_do_read_intrapixel\n");
@


1.6
log
@merge and fix for __CRAZY=Yes
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.25 [February 18, 2008]
a17 1

d26 1
a26 1
   if(png_ptr == NULL) return;
d41 2
a42 1
         png_warning(png_ptr, "Can't discard critical data on CRC error.");
d84 1
a84 1
   if(png_ptr == NULL) return;
d106 1
a106 1
   if(png_ptr == NULL) return;
d116 1
a116 1
   if(png_ptr == NULL) return;
d146 1
a146 1
   if(png_ptr == NULL) return;
d154 1
a154 1
         (png_uint_32)(num_palette * png_sizeof (png_byte)));
d170 1
a170 1
            (png_uint_32)(num_palette * png_sizeof (png_byte)));
d277 1
a277 1
         png_ptr->dither_sort=NULL;
d295 1
a295 1
         t=NULL;
d299 1
a299 1
            (png_uint_32)(num_palette * png_sizeof (png_byte)));
d301 1
a301 1
            (png_uint_32)(num_palette * png_sizeof (png_byte)));
d311 1
a311 1
            png_sizeof (png_dsortp)));
d314 1
a314 1
/*         png_memset(hash, 0, 769 * png_sizeof (png_dsortp)); */
d439 2
a440 2
         png_ptr->palette_to_index=NULL;
         png_ptr->index_to_palette=NULL;
d462 1
a462 1
         (png_uint_32)(num_entries * png_sizeof (png_byte)));
d465 1
a465 1
         png_sizeof (png_byte));
d530 1
a530 1
   if(png_ptr == NULL) return;
d549 1
a549 1
   if(png_ptr == NULL) return;
a550 1
#ifdef PNG_WARN_UNINITIALIZED_ROW
a551 1
#endif
d576 1
a576 1
   if(png_ptr == NULL) return;
a577 1
#ifdef PNG_WARN_UNINITIALIZED_ROW
a578 1
#endif
d587 1
a587 1
   if(png_ptr == NULL) return;
a588 1
#ifdef PNG_WARN_UNINITIALIZED_ROW
a589 1
#endif
d600 1
a600 1
   if(png_ptr == NULL) return;
a611 1
#ifdef PNG_WARN_UNINITIALIZED_ROW
a612 1
#endif
a621 1
#ifdef PNG_WARN_UNINITIALIZED_ROW
a622 1
#endif
d638 1
a638 1
      if(png_ptr == NULL) return;
d648 1
a648 1
   if(png_ptr == NULL) return;
d662 2
a663 1
      png_warning(png_ptr, "Cannot do RGB_TO_GRAY without EXPAND_SUPPORTED.");
d669 1
a669 1
      if(red < 0 || green < 0)
d674 1
a674 1
      else if(red + green < 100000L)
d687 2
a688 1
      png_ptr->rgb_to_gray_blue_coeff  = (png_uint_16)(32768-red_int-green_int);
d701 1
a701 1
   if(png_ptr == NULL) return;
d707 1
a707 1
   if(read_user_transform_fn)
d722 1
a722 1
   if(png_ptr != NULL)
d823 1
a823 1
              int i,istop;
d844 1
a844 1
    int i,k;
d962 1
a962 1
	     * to a simply alpha channel strip.
d1115 1
a1115 1
   if(png_ptr)
d1133 2
a1134 1
         if (png_ptr->num_trans && (png_ptr->transformations & PNG_EXPAND_tRNS))
d1147 1
d1150 1
d1244 1
a1244 1
   if(png_ptr->transformations & PNG_USER_TRANSFORM)
d1246 1
a1246 1
       if(info_ptr->bit_depth < png_ptr->user_transform_depth)
d1248 1
a1248 1
       if(info_ptr->channels < png_ptr->user_transform_channels)
d1256 1
a1256 1
   info_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth,info_ptr->width);
d1259 1
a1259 1
   if(png_ptr)
d1278 2
a1279 3
         "NULL row buffer for row %ld, pass %d",
	 (long)png_ptr->row_number,
         (int)png_ptr->pass);
d1329 1
a1329 1
      if(rgb_error)
d1332 1
a1332 1
         if((png_ptr->transformations & PNG_RGB_TO_GRAY) == 
d1335 1
a1335 1
         if((png_ptr->transformations & PNG_RGB_TO_GRAY) ==
d1419 1
a1419 1
      if(png_ptr->row_info.rowbytes == (png_uint_32)0)
d1481 1
a1481 1
      if(png_ptr->read_user_transform_fn != NULL)
d1493 1
a1493 1
      if(png_ptr->user_transform_depth)
d1495 1
a1495 1
      if(png_ptr->user_transform_channels)
d1972 1
a1972 1
      if(row_info->bit_depth == 8)
d2004 1
a2004 1
      else if(row_info->bit_depth == 16)
d2044 1
a2044 1
      if(row_info->bit_depth == 8)
d2080 1
a2080 1
      else if(row_info->bit_depth == 16)
d2207 1
a2207 1
      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,row_width);
d2215 4
a2218 2
 * <http://www.inforamp.net/~poynton/>
 * Copyright (c) 1998-01-04 Charles Poynton poynton at inforamp.net
d2269 1
a2269 1
                  if(red != green || red != blue)
d2273 1
a2273 1
                       (rc*red+gc*green+bc*blue)>>15];
d2276 1
a2276 1
                     *(dp++) = *(sp-1);
d2289 1
a2289 1
                  if(red != green || red != blue)
d2292 1
a2292 1
                     *(dp++) = (png_byte)((rc*red+gc*green+bc*blue)>>15);
d2295 1
a2295 1
                     *(dp++) = *(sp-1);
d2316 1
a2316 1
                  if(red == green && red == blue)
d2350 1
a2350 1
                  if(red != green || red != blue)
d2373 1
a2373 1
                  if(red != green || red != blue)
d2390 1
a2390 1
                  if(red != green || red != blue)
d2413 1
a2413 1
                  if(red == green && red == blue)
d2447 1
a2447 1
                  if(red != green || red != blue)
d2462 1
a2462 1
      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,row_width);
d3380 1
a3380 1
         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,row_width);
d3839 1
a3839 1
                  if (*(sp-1) == gray_high && *(sp) == gray_low) 
d3918 1
a3918 1
         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,row_width);
d3971 1
a3971 1
         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,row_width);
d4000 1
a4000 1
         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,row_width);
d4069 1
a4069 1
        if(png_ptr->screen_gamma > 0.000001)
d4129 1
a4129 1
        (png_uint_32)(num * png_sizeof (png_uint_16p)));
d4139 1
a4139 1
              (png_uint_32)(256 * png_sizeof (png_uint_16)));
d4169 1
a4169 1
              (png_uint_32)(256 * png_sizeof (png_uint_16)));
d4189 1
a4189 1
           (png_uint_32)(num * png_sizeof (png_uint_16p )));
d4194 1
a4194 1
              (png_uint_32)(256 * png_sizeof (png_uint_16)));
d4206 1
a4206 1
        if(png_ptr->screen_gamma > 0.000001)
d4212 1
a4212 1
           (png_uint_32)(num * png_sizeof (png_uint_16p)));
d4217 1
a4217 1
              (png_uint_32)(256 * png_sizeof (png_uint_16)));
d4282 5
a4286 5
            png_uint_32 s0   = (*(rp  ) << 8) | *(rp+1);
            png_uint_32 s1   = (*(rp+2) << 8) | *(rp+3);
            png_uint_32 s2   = (*(rp+4) << 8) | *(rp+5);
            png_uint_32 red  = (png_uint_32)((s0+s1+65536L) & 0xffffL);
            png_uint_32 blue = (png_uint_32)((s2+s1+65536L) & 0xffffL);
@


1.5
log
@merge and validate
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.15 January 5, 2007
d6 1
a6 1
 * Copyright (c) 1998-2007 Glenn Randers-Pehrson
d551 3
d580 3
d593 3
d616 1
a616 1
   png_debug(1, "in png_set_expand\n");
d618 3
d630 3
d860 1
a860 1
      png_ptr->transformations &= (~PNG_GAMMA);
d967 8
d1049 3
d1089 4
a1276 1
#if !defined(PNG_USELESS_TESTS_SUPPORTED)
d1282 4
a1285 2
      snprintf(msg, 50, "NULL row buffer for row %ld, pass %d",
	 (long)png_ptr->row_number, (int)png_ptr->pass);
d1291 10
d1313 2
a1314 1
         if (png_ptr->num_trans && (png_ptr->transformations & PNG_EXPAND_tRNS))
d1338 2
a1339 1
         if(png_ptr->transformations & PNG_RGB_TO_GRAY_WARN)
d1341 2
a1342 1
         if(png_ptr->transformations & PNG_RGB_TO_GRAY_ERR)
d3746 1
a3746 1
                  gray = (png_uint_16)(gray*0xff);
d3770 1
a3770 1
                  gray = (png_uint_16)(gray*0x55);
d3793 1
a3793 1
                  gray = (png_uint_16)(gray*0x11);
d3823 1
d3837 2
d3843 1
a3843 2
                  if (((png_uint_16)*(sp) |
                     ((png_uint_16)*(sp - 1) << 8)) == gray)
d3868 3
d3875 1
a3875 3
               if (*(sp - 2) == trans_value->red &&
                  *(sp - 1) == trans_value->green &&
                  *(sp - 0) == trans_value->blue)
d3886 6
d3896 6
a3901 6
               if ((((png_uint_16)*(sp - 4) |
                  ((png_uint_16)*(sp - 5) << 8)) == trans_value->red) &&
                  (((png_uint_16)*(sp - 2) |
                  ((png_uint_16)*(sp - 3) << 8)) == trans_value->green) &&
                  (((png_uint_16)*(sp - 0) |
                  ((png_uint_16)*(sp - 1) << 8)) == trans_value->blue))
d4021 1
a4021 1
const static int png_gamma_shift[] =
@


1.4
log
@merge libpng-1.2.12
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.11 June 15, 2006
d6 1
a6 1
 * Copyright (c) 1998-2006 Glenn Randers-Pehrson
d27 1
d84 1
a96 11

   /* Note:  if need_expand is set and color_type is either RGB or RGB_ALPHA
    * (in which case need_expand is superfluous anyway), the background color
    * might actually be gray yet not be flagged as such. This is not a problem
    * for the current code, which uses PNG_BACKGROUND_IS_GRAY only to
    * decide when to do the png_do_gray_to_rgb() transformation.
    */
   if ((need_expand && !(png_ptr->color_type & PNG_COLOR_MASK_COLOR)) ||
       (!need_expand && background_color->red == background_color->green &&
        background_color->red == background_color->blue))
      png_ptr->mode |= PNG_BACKGROUND_IS_GRAY;
d106 1
d116 1
d146 1
d530 1
d549 1
d575 1
d585 2
a586 1
   png_ptr->transformations |= PNG_EXPAND_tRNS;
d597 1
d633 1
d643 1
d694 1
d724 26
d1296 1
a1296 1
         if(png_ptr->transformations == PNG_RGB_TO_GRAY_WARN)
d1298 1
a1298 1
         if(png_ptr->transformations == PNG_RGB_TO_GRAY_ERR)
d3968 1
a3968 1
static int png_gamma_shift[] =
@


1.3
log
@sync, fix CPPFLAGS
no shlib vsn change (only change local data->rodata, no external syms)
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.9 April 14, 2006
d3941 1
a3941 1
   {0x10, 0x21, 0x42, 0x84, 0x110, 0x248, 0x550, 0xff0};
@


1.2
log
@merge src/lib
@
text
@d4 1
a4 1
 * libpng version  1.2.8 - December 3, 2004
d6 1
a6 1
 * Copyright (c) 1998-2004 Glenn Randers-Pehrson
d19 2
d554 1
a554 1
   png_ptr->transformations |= PNG_EXPAND;
d569 3
d578 11
a588 2
   png_debug(1, "in png_set_expand\n");
   png_ptr->transformations |= PNG_EXPAND;
d590 1
d592 1
d594 1
d598 2
a599 2
   png_debug(1, "in png_set_expand\n");
   png_ptr->transformations |= PNG_EXPAND;
d601 2
d609 1
a609 1
   png_ptr->transformations |= PNG_EXPAND;
d727 1
a727 1
         /* expand background chunk. */
d734 6
d745 6
d756 6
d783 1
a783 1
           if (!(png_ptr->transformations & PNG_EXPAND))
d820 2
a821 1
   if (png_ptr->transformations & (PNG_GAMMA | PNG_RGB_TO_GRAY))
d829 1
a829 1
           /* could skip if no transparency and 
d1083 1
a1083 1
         if (png_ptr->num_trans)
d1093 6
a1098 1
            info_ptr->color_type |= PNG_COLOR_MASK_ALPHA;
d1132 10
a1158 10
#if defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
   if (png_ptr->transformations & PNG_GRAY_TO_RGB)
      info_ptr->color_type |= PNG_COLOR_MASK_COLOR;
#endif

#if defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
   if (png_ptr->transformations & PNG_RGB_TO_GRAY)
      info_ptr->color_type &= ~PNG_COLOR_MASK_COLOR;
#endif

d1244 1
a1244 1
         if (png_ptr->num_trans)
d3647 2
a3648 2
/* If the bit depth < 8, it is expanded to 8.  Also, if the
 * transparency value is supplied, an alpha channel is built.
d3952 2
a3953 1
  if(png_ptr->gamma != 0.0)
d3955 2
a3956 4
   if (png_ptr->bit_depth <= 8)
   {
      int i;
      double g;
d3958 4
a3961 4
      if (png_ptr->screen_gamma > .000001)
         g = 1.0 / (png_ptr->gamma * png_ptr->screen_gamma);
      else
         g = 1.0;
d3963 2
a3964 2
      png_ptr->gamma_table = (png_bytep)png_malloc(png_ptr,
         (png_uint_32)256);
d3966 5
a3970 5
      for (i = 0; i < 256; i++)
      {
         png_ptr->gamma_table[i] = (png_byte)(pow((double)i / 255.0,
            g) * 255.0 + .5);
      }
d3973 3
a3975 3
    defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
      if (png_ptr->transformations & ((PNG_BACKGROUND) | PNG_RGB_TO_GRAY))
      {
d3977 1
a3977 1
         g = 1.0 / (png_ptr->gamma);
d3979 2
a3980 2
         png_ptr->gamma_to_1 = (png_bytep)png_malloc(png_ptr,
            (png_uint_32)256);
d3982 5
a3986 5
         for (i = 0; i < 256; i++)
         {
            png_ptr->gamma_to_1[i] = (png_byte)(pow((double)i / 255.0,
               g) * 255.0 + .5);
         }
d3989 2
a3990 2
         png_ptr->gamma_from_1 = (png_bytep)png_malloc(png_ptr,
            (png_uint_32)256);
d3992 4
a3995 4
         if(png_ptr->screen_gamma > 0.000001)
            g = 1.0 / png_ptr->screen_gamma;
         else
            g = png_ptr->gamma;   /* probably doing rgb_to_gray */
d3997 4
a4000 4
         for (i = 0; i < 256; i++)
         {
            png_ptr->gamma_from_1[i] = (png_byte)(pow((double)i / 255.0,
               g) * 255.0 + .5);
d4002 2
a4003 2
         }
      }
d4005 20
a4024 20
   }
   else
   {
      double g;
      int i, j, shift, num;
      int sig_bit;
      png_uint_32 ig;

      if (png_ptr->color_type & PNG_COLOR_MASK_COLOR)
      {
         sig_bit = (int)png_ptr->sig_bit.red;
         if ((int)png_ptr->sig_bit.green > sig_bit)
            sig_bit = png_ptr->sig_bit.green;
         if ((int)png_ptr->sig_bit.blue > sig_bit)
            sig_bit = png_ptr->sig_bit.blue;
      }
      else
      {
         sig_bit = (int)png_ptr->sig_bit.gray;
      }
d4026 4
a4029 4
      if (sig_bit > 0)
         shift = 16 - sig_bit;
      else
         shift = 0;
d4031 5
a4035 5
      if (png_ptr->transformations & PNG_16_TO_8)
      {
         if (shift < (16 - PNG_MAX_GAMMA_8))
            shift = (16 - PNG_MAX_GAMMA_8);
      }
d4037 4
a4040 4
      if (shift > 8)
         shift = 8;
      if (shift < 0)
         shift = 0;
d4042 1
a4042 1
      png_ptr->gamma_shift = (png_byte)shift;
d4044 1
a4044 1
      num = (1 << (8 - shift));
d4046 4
a4049 4
      if (png_ptr->screen_gamma > .000001)
         g = 1.0 / (png_ptr->gamma * png_ptr->screen_gamma);
      else
         g = 1.0;
d4051 2
a4052 2
      png_ptr->gamma_16_table = (png_uint_16pp)png_malloc(png_ptr,
         (png_uint_32)(num * png_sizeof (png_uint_16p)));
d4054 4
a4057 4
      if (png_ptr->transformations & (PNG_16_TO_8 | PNG_BACKGROUND))
      {
         double fin, fout;
         png_uint_32 last, max;
d4059 5
a4063 5
         for (i = 0; i < num; i++)
         {
            png_ptr->gamma_16_table[i] = (png_uint_16p)png_malloc(png_ptr,
               (png_uint_32)(256 * png_sizeof (png_uint_16)));
         }
d4065 28
a4092 28
         g = 1.0 / g;
         last = 0;
         for (i = 0; i < 256; i++)
         {
            fout = ((double)i + 0.5) / 256.0;
            fin = pow(fout, g);
            max = (png_uint_32)(fin * (double)((png_uint_32)num << 8));
            while (last <= max)
            {
               png_ptr->gamma_16_table[(int)(last & (0xff >> shift))]
                  [(int)(last >> (8 - shift))] = (png_uint_16)(
                  (png_uint_16)i | ((png_uint_16)i << 8));
               last++;
            }
         }
         while (last < ((png_uint_32)num << 8))
         {
            png_ptr->gamma_16_table[(int)(last & (0xff >> shift))]
               [(int)(last >> (8 - shift))] = (png_uint_16)65535L;
            last++;
         }
      }
      else
      {
         for (i = 0; i < num; i++)
         {
            png_ptr->gamma_16_table[i] = (png_uint_16p)png_malloc(png_ptr,
               (png_uint_32)(256 * png_sizeof (png_uint_16)));
d4094 9
a4102 9
            ig = (((png_uint_32)i * (png_uint_32)png_gamma_shift[shift]) >> 4);
            for (j = 0; j < 256; j++)
            {
               png_ptr->gamma_16_table[i][j] =
                  (png_uint_16)(pow((double)(ig + ((png_uint_32)j << 8)) /
                     65535.0, g) * 65535.0 + .5);
            }
         }
      }
d4105 3
a4107 3
    defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
      if (png_ptr->transformations & (PNG_BACKGROUND | PNG_RGB_TO_GRAY))
      {
d4109 1
a4109 1
         g = 1.0 / (png_ptr->gamma);
d4111 2
a4112 2
         png_ptr->gamma_16_to_1 = (png_uint_16pp)png_malloc(png_ptr,
            (png_uint_32)(num * png_sizeof (png_uint_16p )));
d4114 4
a4117 4
         for (i = 0; i < num; i++)
         {
            png_ptr->gamma_16_to_1[i] = (png_uint_16p)png_malloc(png_ptr,
               (png_uint_32)(256 * png_sizeof (png_uint_16)));
d4119 9
a4127 9
            ig = (((png_uint_32)i *
               (png_uint_32)png_gamma_shift[shift]) >> 4);
            for (j = 0; j < 256; j++)
            {
               png_ptr->gamma_16_to_1[i][j] =
                  (png_uint_16)(pow((double)(ig + ((png_uint_32)j << 8)) /
                     65535.0, g) * 65535.0 + .5);
            }
         }
d4129 4
a4132 4
         if(png_ptr->screen_gamma > 0.000001)
            g = 1.0 / png_ptr->screen_gamma;
         else
            g = png_ptr->gamma;   /* probably doing rgb_to_gray */
d4134 2
a4135 2
         png_ptr->gamma_16_from_1 = (png_uint_16pp)png_malloc(png_ptr,
            (png_uint_32)(num * png_sizeof (png_uint_16p)));
d4137 4
a4140 4
         for (i = 0; i < num; i++)
         {
            png_ptr->gamma_16_from_1[i] = (png_uint_16p)png_malloc(png_ptr,
               (png_uint_32)(256 * png_sizeof (png_uint_16)));
d4142 10
a4151 10
            ig = (((png_uint_32)i *
               (png_uint_32)png_gamma_shift[shift]) >> 4);
            for (j = 0; j < 256; j++)
            {
               png_ptr->gamma_16_from_1[i][j] =
                  (png_uint_16)(pow((double)(ig + ((png_uint_32)j << 8)) /
                     65535.0, g) * 65535.0 + .5);
            }
         }
      }
d4153 1
a4153 2
   }
 }
d4219 1
@


1.1
log
@Initial revision
@
text
@d1182 2
a1183 2
      sprintf(msg, "NULL row buffer for row %ld, pass %d", png_ptr->row_number,
         png_ptr->pass);
@


1.1.107.1
log
@libpng-1_2_8 with the following directories removed:
- contrib
- projects
- scripts
@
text
@@


1.1.107.2
log
@there's a newer libpng out there
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.9 April 14, 2006
d6 1
a6 1
 * Copyright (c) 1998-2006 Glenn Randers-Pehrson
a18 2
#if defined(PNG_READ_SUPPORTED)

d552 1
a552 1
   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
a566 3
 *
 *  GRP 20060307: In libpng-1.4.0, png_set_gray_1_2_4_to_8() was modified
 *  to expand only the sample depth but not to expand the tRNS to alpha.
d573 2
a574 11
   png_debug(1, "in png_set_palette_to_rgb\n");
   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
}

#if !defined(PNG_1_0_X)
/* Expand grayscale images of less than 8-bit depth to 8 bits. */
void PNGAPI
png_set_expand_gray_1_2_4_to_8(png_structp png_ptr)
{
   png_debug(1, "in png_set_expand_gray_1_2_4_to_8\n");
   png_ptr->transformations |= PNG_EXPAND_tRNS;
a575 1
#endif
a576 1
#if defined(PNG_1_0_X) || defined(PNG_1_2_X)
a577 1
/* Deprecated as of libpng-1.2.9 */
d581 2
a582 2
   png_debug(1, "in png_set_gray_1_2_4_to_8\n");
   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
a583 2
#endif

d590 1
a590 1
   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
d708 1
a708 1
         /* expand background and tRNS chunks */
a714 6
               if (!(png_ptr->transformations & PNG_EXPAND_tRNS))
               {
                 png_ptr->trans_values.gray *= (png_uint_16)0xff;
                 png_ptr->trans_values.red = png_ptr->trans_values.green
                   = png_ptr->trans_values.blue = png_ptr->trans_values.gray;
               }
a719 6
               if (!(png_ptr->transformations & PNG_EXPAND_tRNS))
               {
                 png_ptr->trans_values.gray *= (png_uint_16)0x55;
                 png_ptr->trans_values.red = png_ptr->trans_values.green
                   = png_ptr->trans_values.blue = png_ptr->trans_values.gray;
               }
a724 6
               if (!(png_ptr->transformations & PNG_EXPAND_tRNS))
               {
                 png_ptr->trans_values.gray *= (png_uint_16)0x11;
                 png_ptr->trans_values.red = png_ptr->trans_values.green
                   = png_ptr->trans_values.blue = png_ptr->trans_values.gray;
               }
d746 1
a746 1
           if (!(png_ptr->transformations & PNG_EXPAND_tRNS))
d783 1
a783 2
   if ((png_ptr->transformations & (PNG_GAMMA | PNG_RGB_TO_GRAY)) &&
        png_ptr->gamma != 0.0)
d791 1
a791 1
           /* could skip if no transparency and
d1045 1
a1045 1
         if (png_ptr->num_trans && (png_ptr->transformations & PNG_EXPAND_tRNS))
d1055 1
a1055 6
         {
            if (png_ptr->transformations & PNG_EXPAND_tRNS)
              info_ptr->color_type |= PNG_COLOR_MASK_ALPHA;
            else
              info_ptr->color_type |= PNG_COLOR_MASK_COLOR;
         }
a1088 10
#if defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
   if (png_ptr->transformations & PNG_GRAY_TO_RGB)
      info_ptr->color_type |= PNG_COLOR_MASK_COLOR;
#endif

#if defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
   if (png_ptr->transformations & PNG_RGB_TO_GRAY)
      info_ptr->color_type &= ~PNG_COLOR_MASK_COLOR;
#endif

d1106 10
d1201 1
a1201 1
         if (png_ptr->num_trans && (png_ptr->transformations & PNG_EXPAND_tRNS))
d3604 2
a3605 2
/* If the bit depth < 8, it is expanded to 8.  Also, if the already
 * expanded transparency value is supplied, an alpha channel is built.
d3909 1
a3909 2

  if (png_ptr->bit_depth <= 8)
d3911 4
a3914 2
     int i;
     double g;
d3916 4
a3919 4
     if (png_ptr->screen_gamma > .000001)
        g = 1.0 / (png_ptr->gamma * png_ptr->screen_gamma);
     else
        g = 1.0;
d3921 2
a3922 2
     png_ptr->gamma_table = (png_bytep)png_malloc(png_ptr,
        (png_uint_32)256);
d3924 5
a3928 5
     for (i = 0; i < 256; i++)
     {
        png_ptr->gamma_table[i] = (png_byte)(pow((double)i / 255.0,
           g) * 255.0 + .5);
     }
d3931 3
a3933 3
   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
     if (png_ptr->transformations & ((PNG_BACKGROUND) | PNG_RGB_TO_GRAY))
     {
d3935 1
a3935 1
        g = 1.0 / (png_ptr->gamma);
d3937 2
a3938 2
        png_ptr->gamma_to_1 = (png_bytep)png_malloc(png_ptr,
           (png_uint_32)256);
d3940 5
a3944 5
        for (i = 0; i < 256; i++)
        {
           png_ptr->gamma_to_1[i] = (png_byte)(pow((double)i / 255.0,
              g) * 255.0 + .5);
        }
d3947 2
a3948 2
        png_ptr->gamma_from_1 = (png_bytep)png_malloc(png_ptr,
           (png_uint_32)256);
d3950 4
a3953 4
        if(png_ptr->screen_gamma > 0.000001)
           g = 1.0 / png_ptr->screen_gamma;
        else
           g = png_ptr->gamma;   /* probably doing rgb_to_gray */
d3955 4
a3958 4
        for (i = 0; i < 256; i++)
        {
           png_ptr->gamma_from_1[i] = (png_byte)(pow((double)i / 255.0,
              g) * 255.0 + .5);
d3960 2
a3961 2
        }
     }
d3963 20
a3982 7
  }
  else
  {
     double g;
     int i, j, shift, num;
     int sig_bit;
     png_uint_32 ig;
d3984 4
a3987 12
     if (png_ptr->color_type & PNG_COLOR_MASK_COLOR)
     {
        sig_bit = (int)png_ptr->sig_bit.red;
        if ((int)png_ptr->sig_bit.green > sig_bit)
           sig_bit = png_ptr->sig_bit.green;
        if ((int)png_ptr->sig_bit.blue > sig_bit)
           sig_bit = png_ptr->sig_bit.blue;
     }
     else
     {
        sig_bit = (int)png_ptr->sig_bit.gray;
     }
d3989 5
a3993 4
     if (sig_bit > 0)
        shift = 16 - sig_bit;
     else
        shift = 0;
d3995 4
a3998 5
     if (png_ptr->transformations & PNG_16_TO_8)
     {
        if (shift < (16 - PNG_MAX_GAMMA_8))
           shift = (16 - PNG_MAX_GAMMA_8);
     }
d4000 1
a4000 4
     if (shift > 8)
        shift = 8;
     if (shift < 0)
        shift = 0;
d4002 1
a4002 1
     png_ptr->gamma_shift = (png_byte)shift;
d4004 4
a4007 1
     num = (1 << (8 - shift));
d4009 2
a4010 4
     if (png_ptr->screen_gamma > .000001)
        g = 1.0 / (png_ptr->gamma * png_ptr->screen_gamma);
     else
        g = 1.0;
d4012 4
a4015 2
     png_ptr->gamma_16_table = (png_uint_16pp)png_malloc(png_ptr,
        (png_uint_32)(num * png_sizeof (png_uint_16p)));
d4017 5
a4021 4
     if (png_ptr->transformations & (PNG_16_TO_8 | PNG_BACKGROUND))
     {
        double fin, fout;
        png_uint_32 last, max;
d4023 28
a4050 5
        for (i = 0; i < num; i++)
        {
           png_ptr->gamma_16_table[i] = (png_uint_16p)png_malloc(png_ptr,
              (png_uint_32)(256 * png_sizeof (png_uint_16)));
        }
d4052 9
a4060 38
        g = 1.0 / g;
        last = 0;
        for (i = 0; i < 256; i++)
        {
           fout = ((double)i + 0.5) / 256.0;
           fin = pow(fout, g);
           max = (png_uint_32)(fin * (double)((png_uint_32)num << 8));
           while (last <= max)
           {
              png_ptr->gamma_16_table[(int)(last & (0xff >> shift))]
                 [(int)(last >> (8 - shift))] = (png_uint_16)(
                 (png_uint_16)i | ((png_uint_16)i << 8));
              last++;
           }
        }
        while (last < ((png_uint_32)num << 8))
        {
           png_ptr->gamma_16_table[(int)(last & (0xff >> shift))]
              [(int)(last >> (8 - shift))] = (png_uint_16)65535L;
           last++;
        }
     }
     else
     {
        for (i = 0; i < num; i++)
        {
           png_ptr->gamma_16_table[i] = (png_uint_16p)png_malloc(png_ptr,
              (png_uint_32)(256 * png_sizeof (png_uint_16)));

           ig = (((png_uint_32)i * (png_uint_32)png_gamma_shift[shift]) >> 4);
           for (j = 0; j < 256; j++)
           {
              png_ptr->gamma_16_table[i][j] =
                 (png_uint_16)(pow((double)(ig + ((png_uint_32)j << 8)) /
                    65535.0, g) * 65535.0 + .5);
           }
        }
     }
d4063 3
a4065 3
   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
     if (png_ptr->transformations & (PNG_BACKGROUND | PNG_RGB_TO_GRAY))
     {
d4067 1
a4067 1
        g = 1.0 / (png_ptr->gamma);
d4069 2
a4070 2
        png_ptr->gamma_16_to_1 = (png_uint_16pp)png_malloc(png_ptr,
           (png_uint_32)(num * png_sizeof (png_uint_16p )));
d4072 4
a4075 4
        for (i = 0; i < num; i++)
        {
           png_ptr->gamma_16_to_1[i] = (png_uint_16p)png_malloc(png_ptr,
              (png_uint_32)(256 * png_sizeof (png_uint_16)));
d4077 9
a4085 9
           ig = (((png_uint_32)i *
              (png_uint_32)png_gamma_shift[shift]) >> 4);
           for (j = 0; j < 256; j++)
           {
              png_ptr->gamma_16_to_1[i][j] =
                 (png_uint_16)(pow((double)(ig + ((png_uint_32)j << 8)) /
                    65535.0, g) * 65535.0 + .5);
           }
        }
d4087 4
a4090 4
        if(png_ptr->screen_gamma > 0.000001)
           g = 1.0 / png_ptr->screen_gamma;
        else
           g = png_ptr->gamma;   /* probably doing rgb_to_gray */
d4092 2
a4093 2
        png_ptr->gamma_16_from_1 = (png_uint_16pp)png_malloc(png_ptr,
           (png_uint_32)(num * png_sizeof (png_uint_16p)));
d4095 4
a4098 4
        for (i = 0; i < num; i++)
        {
           png_ptr->gamma_16_from_1[i] = (png_uint_16p)png_malloc(png_ptr,
              (png_uint_32)(256 * png_sizeof (png_uint_16)));
d4100 10
a4109 10
           ig = (((png_uint_32)i *
              (png_uint_32)png_gamma_shift[shift]) >> 4);
           for (j = 0; j < 256; j++)
           {
              png_ptr->gamma_16_from_1[i][j] =
                 (png_uint_16)(pow((double)(ig + ((png_uint_32)j << 8)) /
                    65535.0, g) * 65535.0 + .5);
           }
        }
     }
d4111 2
a4112 1
  }
a4177 1
#endif /* PNG_READ_SUPPORTED */
@


1.1.107.3
log
@Import libpng 1.2.12, fixes at least three vulnerabilities
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.11 June 15, 2006
d3941 1
a3941 1
   {0x10, 0x21, 0x42, 0x84, 0x110, 0x248, 0x550, 0xff0, 0x00};
@


1.1.107.4
log
@Upgrade libpng (fixes some holes)
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.15 January 5, 2007
d6 1
a6 1
 * Copyright (c) 1998-2007 Glenn Randers-Pehrson
a26 1
   if(png_ptr == NULL) return;
a82 1
   if(png_ptr == NULL) return;
d95 11
a114 1
   if(png_ptr == NULL) return;
a123 1
   if(png_ptr == NULL) return;
a152 1
   if(png_ptr == NULL) return;
a535 1
   if(png_ptr == NULL) return;
a553 1
   if(png_ptr == NULL) return;
a578 1
   if(png_ptr == NULL) return;
d588 1
a588 2
   if(png_ptr == NULL) return;
   png_ptr->transformations |= PNG_EXPAND;
a598 1
   if(png_ptr == NULL) return;
a633 1
      if(png_ptr == NULL) return;
a642 1
   if(png_ptr == NULL) return;
a692 1
   if(png_ptr == NULL) return;
a721 26

#if defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
   /* Detect gray background and attempt to enable optimization
    * for gray --> RGB case */
   /* Note:  if PNG_BACKGROUND_EXPAND is set and color_type is either RGB or
    * RGB_ALPHA (in which case need_expand is superfluous anyway), the
    * background color might actually be gray yet not be flagged as such.
    * This is not a problem for the current code, which uses
    * PNG_BACKGROUND_IS_GRAY only to decide when to do the
    * png_do_gray_to_rgb() transformation.
    */
   if ((png_ptr->transformations & PNG_BACKGROUND_EXPAND) &&
       !(color_type & PNG_COLOR_MASK_COLOR))
   {
          png_ptr->mode |= PNG_BACKGROUND_IS_GRAY;
   } else if ((png_ptr->transformations & PNG_BACKGROUND) &&
              !(png_ptr->transformations & PNG_BACKGROUND_EXPAND) &&
              (png_ptr->transformations & PNG_GRAY_TO_RGB) &&
              png_ptr->background.red == png_ptr->background.green &&
              png_ptr->background.red == png_ptr->background.blue)
   {
          png_ptr->mode |= PNG_BACKGROUND_IS_GRAY;
          png_ptr->background.gray = png_ptr->background.red;
   }
#endif

d1268 1
a1268 1
         if(png_ptr->transformations & PNG_RGB_TO_GRAY_WARN)
d1270 1
a1270 1
         if(png_ptr->transformations & PNG_RGB_TO_GRAY_ERR)
d3940 1
a3940 1
const static int png_gamma_shift[] =
@


1.1.107.5
log
@Import libpng-1.2.25 with the following change log.
Requested by bsiegert@@ due to security fix relevance.

version 1.2.19beta1 [May 18, 2007]
  Changed "const static" to "static PNG_CONST" everywhere, mostly undoing
    change of libpng-1.2.17beta2.  Changed other "const" to "PNG_CONST"
  Changed some handling of unused parameters, to avoid compiler warnings.
    "if (unused == NULL) return;" becomes "unused = unused".

version 1.2.19beta2 [May 18, 2007]
  Only use the valid bits of tRNS value in png_do_expand() (Brian Cartier)

version 1.2.19beta3 [May 19, 2007]
  Add some "png_byte" typecasts in png_check_keyword() and write new_key
  instead of key in zTXt chunk (Kevin Ryde).

version 1.2.19beta4 [May 21, 2007]
  Add png_snprintf() function and use it in place of sprint() for improved
    defense against buffer overflows.

version 1.2.19beta5 [May 21, 2007]
  Fixed png_handle_tRNS() to only use the valid bits of tRNS value.
  Changed handling of more unused parameters, to avoid compiler warnings.
  Removed some PNG_CONST in pngwutil.c to avoid compiler warnings.

version 1.2.19beta6 [May 22, 2007]
  Added some #ifdef PNG_MMX_CODE_SUPPORTED where needed in pngvcrd.c
  Added a special "_MSC_VER" case that defines png_snprintf to _snprintf

version 1.2.19beta7 [May 22, 2007]
  Squelched png_squelch_warnings() in pnggccrd.c and added an
    #ifdef PNG_MMX_CODE_SUPPORTED block around the declarations that caused
    the warnings that png_squelch_warnings was squelching.

version 1.2.19beta8 [May 22, 2007]
  Removed __MMX__ from test in pngconf.h.

version 1.2.19beta9 [May 23, 2007]
  Made png_squelch_warnings() available via PNG_SQUELCH_WARNINGS macro.
  Revised png_squelch_warnings() so it might work.
  Updated makefile.sgcc and makefile.solaris; added makefile.solaris-x86.

version 1.2.19beta10 [May 24, 2007]
  Resquelched png_squelch_warnings(), use "__attribute__((used))" instead.

version 1.2.19beta11 [May 28, 2007]
  Return 0 from png_get_sPLT() and png_get_unknown_chunks() if png_ptr is NULL;
    changed three remaining instances of png_strcpy() to png_strncpy() (David
    Hill).
  Make test for NULL row_buf at the beginning of png_do_read_transformations
    unconditional.

version 1.2.19beta12 [May 28, 2007]
  Revised pnggccrd.c.

version 1.2.19beta13 [June 14, 2007]
  Prefer PNG_USE_PNGVCRD when _MSC_VER is defined in pngconf.h

version 1.2.19beta14 [June 16, 2007]
  Fix bug with handling of 16-bit transparency, introduced in 1.2.19beta2

version 1.2.19beta15 [June 17, 2007]
  Revised pnggccrd.c.

version 1.2.19beta16 [June 18, 2007]
  Revised pnggccrd.c again.
  Updated contrib/gregbook.
  Changed '#include "pnggccrd.c"' to 'include "$srcdir/pnggccrd.c"'
    in configure.ac

version 1.2.19beta17 [June 19, 2007]
  Revised many of the makefiles, to set -DPNG_NO_MMX_CODE where needed
    and to not use -O3 unless -DPNG_NO_MMX_CODE is also set.

version 1.2.19beta18 [June 23, 2007]
  Replaced some C++ style comments with C style comments in pnggccrd.c.
  Copied optimized C code from pnggccrd.c to pngrutil.c, removed dependency
    on pnggccrd.o from many makefiles.
  Added sl and dylib to list of extensions be installed by Makefile.am

version 1.2.19beta19 [June 28, 2007]
  Fixed testing PNG_RGB_TO_GRAY_ERR & PNG_RGB_TO_GRAY_WARN in pngrtran.c
  More cleanup of pnggccrd.c and pngvcrd.c

version 1.2.19beta20 [June 29, 2007]
  Rebuilt Makefile.in and configure using libtool-1.5.24.
  Fixed typo in pnggccrd.c

version 1.2.19beta21 [June 30, 2007]
  More revision of pnggccrd.c
  Added "test" target to Makefile.in and Makefile.am

version 1.2.19beta22 [July 3, 2007]
  Added info about pngrutil/pnggccrd/pngvcrd to png_get_header_version()
  Fix type definition of dummy_value_a, b in pnggccrd.c

version 1.2.19beta23 [July 10, 2007]
  Revert change to type definition of dummy_value_a, b in pnggccrd.c
  Make sure __PIC__ is defined in pnggccrd.c when PIC is defined.
  Require gcc-4.1 or better to use PNG_HAVE_MMX_FILTER_ROW on x86_64 platforms

version 1.2.19beta24 [July 14, 2007]
  Added PNG_NO_READ_FILTER, PNG_NO_WRITE_FILTER, PNG_NO_WARNING macros.
  Added contrib/pngminim to demonstrate building minimal encoder and decoder

version 1.2.19beta25 [July 15, 2007]
  Removed the new PNG_NO_READ_FILTER macro since it would make the library
    unable to read valid PNG files, and filtering is at the heart of the
    PNG format.

version 1.2.19beta26 [July 16, 2007]
  Changed "png_free(str)" to "png_free(png_ptr,str)" in pngrutil.c WinCE
    code (Yves Piguet).  This bug was introduced in libpng-1.2.14.
  Updated scripts/CMakeLists.txt
  Relocated a misplaced #endif in pnggccrd.c

version 1.2.19beta27 [July 17, 2007]
  Fixed incorrect stride and number of bytes copied (was 4 instead of
    6 bytes) in the cleanup loop of pnggccrd.c and pngvcrd.c for handling
    the end of 48-bit interlaced rows (Glenn R-P).

version 1.2.19beta28 [July 19, 2007]
  Removed requirement for gcc-4.1 or better to use PNG_HAVE_MMX_FILTER_ROW
    on x86_64 platforms
  Added png_warning() in pngrutil.c for short iCCP, iTXt, sPLT, or zTXT chunks.
  Revised pngtest.c so warnings are displayed regardless of PNG_NO_STDIO.

version 1.2.19beta29 [July 20, 2007]
  Fix typo in pnggccrd.c (%%eax should be %%ax in secondloop48)

version 1.2.19beta30 [July 26, 2007]
  Revised pnggccrd.c

version 1.2.19beta31 [July 27, 2007]
  Fix typos in pnggccrd.c

version 1.0.27rc1 and 1.2.19rc1 [July 31, 2007]
  Disable PNG_MMX_CODE_SUPPORTED when PNG_ASSEMBLER_CODE_SUPPORTED is off.
  Enable PNG_MMX_READ_FILTER_* by default, except when gcc-3.x is being
    used (they were inadvertently disabled in libpng-1.2.19beta23).
  Fix some debugging statements in pnggccrd.c and pngrutil.c
  Added information about disabling the MMX code in libpng documentation.

version 1.0.27rc2 and 1.2.19rc2 [August 4, 2007]
  Removed some "#if 0" blocks.
  Made a global struct local in pngvcrd.c to make it thread safe.
  Issue a png_error() if application attempts to transform a row tht
    has not been initialized.

version 1.0.27rc3 and 1.2.19rc3 [August 9, 2007]
  Slightly revised pngvcrd.c

version 1.0.27rc4 and 1.2.19rc4 [August 9, 2007]
  Revised pnggccrd.c debugging change of rc1, which was broken.
  Revised scripts/CMakeLists.txt
  Change default to PNG_NO_GLOBAL_ARRAYS for MSVC.
  Turn off PNG_FLAG_ROW_INIT flag when setting transforms that expand pixels.

version 1.0.27rc5 and 1.2.19rc5 [August 10, 2007]
  Fix typo (missing '"') in pnggccrd.c
  Revise handling of png_strtod in recent versions of WINCE

version 1.0.27rc6 and 1.2.19rc6 [August 15, 2007]
  Fix typo (missing ',') in contrib/gregbook/readpng2.c
  Undid row initialization error exit added to rc2 and rc4.

version 1.0.27 and 1.2.19 [August 18, 2007]
  Conditionally restored row initialization error exit.

version 1.2.20beta01 [August 19, 2007]
  Fixed problem with compiling pnggccrd.c on Intel-Apple platforms.
  Changed png_malloc() to png_malloc_warn() in png_set_sPLT().
  Added PNG_NO_ERROR_TEXT feature, with demo in contrib/pngminim
  Removed define PNG_WARN_UNINITIALIZED_ROW 1 /* 0: warning; 1: error */
    because it caused some trouble.

version 1.2.20beta02 [August 20, 2007]
  Avoid compiling pnggccrd.c on Intel-Apple platforms.

version 1.2.20beta03 [August 20, 2007]
  Added "/D PNG_NO_MMX_CODE" to the non-mmx builds of projects/visualc6
    and visualc71.

version 1.2.20beta04 [August 21, 2007]
  Revised pngvcrd.c for improved efficiency (Steve Snyder).

version 1.2.20rc1 [August 23, 2007]
  Revised pngconf.h to set PNG_NO_MMX_CODE for gcc-3.x compilers.

version 1.2.20rc2 [August 27, 2007]
  Revised scripts/CMakeLists.txt
  Revised #ifdefs to ensure one and only one of pnggccrd.c, pngvcrd.c,
    or part of pngrutil.c is selected.

version 1.2.20rc3 [August 30, 2007]
  Remove a little more code in pngwutil.c when PNG_NO_WRITE_FILTER is selected.
  Added /D _CRT_SECURE_NO_WARNINGS to visual6c and visualc71 projects.
  Compile png_mmx_support() in png.c even when PNG_NO_MMX_CODE is defined.
  Restored a "superfluous" #ifdef that was removed from 1.2.20rc2 pnggccrd.c,
    breaking the png_mmx_support() function.

version 1.2.20rc4 [September 1, 2007]
  Removed Intel contributions (MMX, Optimized C).

version 1.2.20rc5 [September 2, 2007]
  Restored configure and Makefile.in to rc3 and put a snippet of code in
    pnggccrd.c, to ensure configure makes the same PNG_NO_MMX_CODE selection

version 1.2.20rc6 [September 2, 2007]
  Fixed bugs in scripts/CMakeLists.txt
  Removed pngvcrd.c references from msvc projects.

version 1.0.28 and 1.2.20 [September 8, 2007]
  Removed "(NO READ SUPPORT)" from png_get_header_version() string.

version 1.2.21beta1 [September 14, 2007]
  Fixed various mistakes reported by George Cook and Jeff Phillips:
  logical vs bitwise NOT in pngrtran.c, bug introduced in 1.2.19rc2
  16-bit cheap transparency expansion, bug introduced in 1.2.19beta2
  errors with sizeof(unknown_chunk.name), bugs introduced in 1.2.19beta11
  <= compare with unsigned var in pngset.c, should be ==.

version 1.2.21beta2 [September 18, 2007]
  Removed some extraneous typecasts.

version 1.2.21rc1 [September 25, 2007]
  Fixed potential out-of-bounds reads in png_handle_pCAL() and
    png_handle_ztXt() ("flayer" results reported by Tavis Ormandy).

version 1.2.21rc2 [September 26, 2007]
  Fixed potential out-of-bounds reads in png_handle_sCAL(),
    png_handle_iTXt(), and png_push_read_tEXt().
  Remove some PNG_CONST declarations from pngwutil.c to avoid compiler warnings
  Revised makefiles to update paths in libpng.pc properly.

version 1.2.21rc3 [September 27, 2007]
  Revised makefiles to update "Libs" in libpng.pc properly.

version 1.0.29 and 1.2.21rc3 [October 4, 2007]
  No changes.

version 1.2.22beta1 [October 4, 2007]
  Again, fixed logical vs bitwise NOT in pngrtran.c, bug introduced
    in 1.2.19rc2

version 1.2.22beta2 [October 5, 2007]
  Fixed string length error in pngset.c (caused crashes while decoding iCCP)
  Add terminating NULL after each instance of png_strncpy().

version 1.2.22beta3 [October 6, 2007]
  Fix two off-by-one terminating NULL after png_strncpy().

version 1.2.22beta4 [October 7, 2007]
  Changed some 0 to '\0'.

version 1.0.30rc1 and 1.2.22rc1 [October 8, 2007]
  No changes.

version 1.0.30 and 1.2.22 [October 13, 2007]
  No changes.

version 1.2.23beta01 [October 15, 2007]
  Reduced number of invocations of png_strlen() in pngset.c.
  Changed [azAZ09_] to [_abcde...89] in Makefile.am for better localization.

version 1.2.23beta02 [October 16, 2007]
  Eliminated png_strncpy() and png_strcpy() (Pierre Poissinger)
  Changed $AN to $(AN) in Makefile.am.

version 1.2.23beta03 [October 16, 2007]
  Fixed off-by-one error in pngset.c
  Restore statement to set last character of buffer to \0 in pngerror.c

version 1.2.23beta04 [October 23, 2007]
  Reject attempt to set all-zero cHRM values.

version 1.2.23beta05 [October 26, 2007]
  Add missing quotes in projects/visualc6, lost in version 1.2.20rc3

version 1.2.23rc01 [November 2, 2007]
  No changes.

version 1.2.23 [November 6, 2007]
  No changes.

version 1.2.24beta01 [November 19, 2007]
  Moved misplaced test for malloc failure in png_set_sPLT().  This bug was
    introduced in libpng-1.2.20beta01.
  Ifdef out avg_row etc from png.h and pngwrite.c when PNG_NO_WRITE_FILTER
  Do not use png_ptr->free_fn and png_ptr->mem_fn in png_destroy_read_struct()
    when png_ptr is NULL (Marshall Clow).
  Updated handling of symbol prefixes in Makefile.am and configure.ac (Mike
    Frysinger).

version 1.2.24beta02 [November 30, 2007]
  Removed a useless test and fixed incorrect test in png_set_cHRM_fixed()
    (David Hill).

version 1.2.24rc01 [December 7, 2007]
  No changes.

version 1.2.24     [December 14, 2007]
  Make sure not to redefine _BSD_SOURCE in pngconf.h
  Revised gather.sh and makefile.std in contrib/pngminim to avoid compiling
    unused files.

version 1.2.25beta01 [January 7, 2008]
  Fixed bug with unknown chunk handling, introduced in version 1.2.17rc2

version 1.2.25beta02 [January 10, 2008]
  Prevent gamma from being applied twice.

version 1.2.25rc01 [January 17, 2008]
  No changes.

version 1.2.25beta03 [January 22, 2008]
  Fixed some continue-after-malloc-failure errors in pngset.c (David Hill)
  Check for info_ptr == NULL in png_read_info() and png_process_data().
  Check for possible use of NULL user_png_ver[] in png_create_read_struct().
  Change "if (swidth == NULL)" to "if (sheight == NULL)" in png_handle_sCAL
    (bug introduced in libpng-1.2.4/1.0.13).
  Return from png_destroy_read_struct() if png_ptr_ptr is NULL.
  Fix overflow of "msg" in png_decompres_chunk().

version 1.2.25beta04 [January 26, 2008]
  Work around Coverity bug report by slightly refactoring
    png_read_push_finish_row()

version 1.2.25beta05 [January 31, 2008]
  Added libpng-1.2.25beta05.tar.lzma to distribution.  Get the lzma codec
    from <http://tukaani.org/lzma>.
  Added lp1225b05.7z to distribution.  Get the 7-zip decoder from
    from <http://www.7-zip.org>.
  Fixed some broken links in the README file.

version 1.2.25beta06 [February 6, 2008]
  Refactored png_read_push_finish_row() again, trying to satisfy Coverity.
  Fixed potential NULL dereference of png_ptr in png_destroy_write_struct();
  clarified potential NULL dereference of png_ptr in png_destroy_read_struct();
  fixed potential NULL dereference of info_ptr in png_handle_bKGD();
  fixed potential NULL dereference of user_png_ver[] in
    png_create_write_struct_2(). (Coverity)

version 1.2.25rc02 [February 10, 2008]
  Reset png_ptr->pass in png_read_push_finish_row() before break.
  Changed "pass" from png_byte to int.

version 1.2.25 and 1.0.31 [February 18, 2008]
  No changes.
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.25 [February 18, 2008]
d6 1
a6 1
 * Copyright (c) 1998-2008 Glenn Randers-Pehrson
a550 3
#ifdef PNG_WARN_UNINITIALIZED_ROW
   png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
#endif
a576 3
#ifdef PNG_WARN_UNINITIALIZED_ROW
   png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
#endif
a586 3
#ifdef PNG_WARN_UNINITIALIZED_ROW
   png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
#endif
d607 1
a607 1
   png_debug(1, "in png_set_tRNS_to_alpha\n");
a608 3
#ifdef PNG_WARN_UNINITIALIZED_ROW
   png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
#endif
a617 3
#ifdef PNG_WARN_UNINITIALIZED_ROW
   png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
#endif
d845 1
a845 1
      png_ptr->transformations &= ~PNG_GAMMA;
a951 8
	    /* Prevent the transformations being done again, and make sure
	     * that the now spurious alpha channel is stripped - the code
	     * has just reduced background composition and gamma correction
	     * to a simply alpha channel strip.
	     */
	    png_ptr->transformations &= ~PNG_BACKGROUND;
	    png_ptr->transformations &= ~PNG_GAMMA;
	    png_ptr->transformations |= PNG_STRIP_ALPHA;
a1025 3

	 /* Done the gamma correction. */
	 png_ptr->transformations &= ~PNG_GAMMA;
a1062 4

      /* Handled alpha, still need to strip the channel. */
      png_ptr->transformations &= ~PNG_BACKGROUND;
      png_ptr->transformations |= PNG_STRIP_ALPHA;
d1247 1
d1253 1
a1253 2
      png_snprintf2(msg, 50,
         "NULL row buffer for row %ld, pass %d", png_ptr->row_number,
a1259 10
#ifdef PNG_WARN_UNINITIALIZED_ROW
   if (!(png_ptr->flags & PNG_FLAG_ROW_INIT))
      /* Application has failed to call either png_read_start_image()
       * or png_read_update_info() after setting transforms that expand
       * pixels.  This check added to libpng-1.2.19 */
#if (PNG_WARN_UNINITIALIZED_ROW==1)
      png_error(png_ptr, "Uninitialized row");
#else
      png_warning(png_ptr, "Uninitialized row");
#endif
d1272 1
a1272 2
         if (png_ptr->num_trans &&
             (png_ptr->transformations & PNG_EXPAND_tRNS))
d1296 1
a1296 2
         if((png_ptr->transformations & PNG_RGB_TO_GRAY) == 
             PNG_RGB_TO_GRAY_WARN)
d1298 1
a1298 2
         if((png_ptr->transformations & PNG_RGB_TO_GRAY) ==
             PNG_RGB_TO_GRAY_ERR)
d3702 1
a3702 1
                  gray = (png_uint_16)((gray&0x01)*0xff);
d3726 1
a3726 1
                  gray = (png_uint_16)((gray&0x03)*0x55);
d3749 1
a3749 1
                  gray = (png_uint_16)((gray&0x0f)*0x11);
a3778 1
               gray = gray & 0xff;
a3791 2
               png_byte gray_high = (gray >> 8) & 0xff;
               png_byte gray_low = gray & 0xff;
d3796 2
a3797 1
                  if (*(sp-1) == gray_high && *(sp) == gray_low) 
a3821 3
            png_byte red = trans_value->red & 0xff;
            png_byte green = trans_value->green & 0xff;
            png_byte blue = trans_value->blue & 0xff;
d3826 3
a3828 1
               if (*(sp - 2) == red && *(sp - 1) == green && *(sp) == blue)
a3838 6
            png_byte red_high = (trans_value->red >> 8) & 0xff;
            png_byte green_high = (trans_value->green >> 8) & 0xff;
            png_byte blue_high = (trans_value->blue >> 8) & 0xff;
            png_byte red_low = trans_value->red & 0xff;
            png_byte green_low = trans_value->green & 0xff;
            png_byte blue_low = trans_value->blue & 0xff;
d3843 6
a3848 6
               if (*(sp - 5) == red_high &&
                  *(sp - 4) == red_low &&
                  *(sp - 3) == green_high &&
                  *(sp - 2) == green_low &&
                  *(sp - 1) == blue_high &&
                  *(sp    ) == blue_low)
d3968 1
a3968 1
static PNG_CONST int png_gamma_shift[] =
@


1.1.107.6
log
@SECURITY update of libpng to 1.2.32
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.30 [August 15, 2008]
d18 1
d27 1
a27 1
   if (png_ptr == NULL) return;
d42 1
a42 2
         png_warning(png_ptr,
            "Can't discard critical data on CRC error.");
d84 1
a84 1
   if (png_ptr == NULL) return;
d106 1
a106 1
   if (png_ptr == NULL) return;
d116 1
a116 1
   if (png_ptr == NULL) return;
d146 1
a146 1
   if (png_ptr == NULL) return;
d154 1
a154 1
         (png_uint_32)(num_palette * png_sizeof(png_byte)));
d170 1
a170 1
            (png_uint_32)(num_palette * png_sizeof(png_byte)));
d277 1
a277 1
         png_ptr->dither_sort = NULL;
d295 1
a295 1
         t = NULL;
d299 1
a299 1
            (png_uint_32)(num_palette * png_sizeof(png_byte)));
d301 1
a301 1
            (png_uint_32)(num_palette * png_sizeof(png_byte)));
d311 1
a311 1
            png_sizeof(png_dsortp)));
d314 1
a314 1
/*         png_memset(hash, 0, 769 * png_sizeof(png_dsortp)); */
d439 2
a440 2
         png_ptr->palette_to_index = NULL;
         png_ptr->index_to_palette = NULL;
d462 1
a462 1
         (png_uint_32)(num_entries * png_sizeof(png_byte)));
d465 1
a465 1
         png_sizeof(png_byte));
d530 1
a530 1
   if (png_ptr == NULL) return;
d549 1
a549 1
   if (png_ptr == NULL) return;
d551 1
d553 1
d578 1
a578 1
   if (png_ptr == NULL) return;
d580 1
d582 1
d591 1
a591 1
   if (png_ptr == NULL) return;
d593 1
d595 1
d606 1
a606 1
   if (png_ptr == NULL) return;
d618 1
d620 1
d630 1
d632 1
d648 1
a648 1
      if (png_ptr == NULL) return;
d658 1
a658 1
   if (png_ptr == NULL) return;
d672 1
a672 2
      png_warning(png_ptr,
        "Cannot do RGB_TO_GRAY without EXPAND_SUPPORTED.");
d678 1
a678 1
      if (red < 0 || green < 0)
d683 1
a683 1
      else if (red + green < 100000L)
d696 1
a696 2
      png_ptr->rgb_to_gray_blue_coeff  = 
         (png_uint_16)(32768 - red_int - green_int);
d709 1
a709 1
   if (png_ptr == NULL) return;
d715 1
a715 1
   if (read_user_transform_fn)
d730 1
a730 1
   if (png_ptr != NULL)
d831 1
a831 1
              int i, istop;
d852 1
a852 1
    int i, k;
d970 1
a970 1
	     * to a simple alpha channel strip.
d1123 1
a1123 1
   if (png_ptr)
d1141 1
a1141 2
         if (png_ptr->num_trans &&
              (png_ptr->transformations & PNG_EXPAND_tRNS))
a1153 1
#if 0 /* Removed from libpng-1.2.27 */
a1155 1
#endif
d1249 1
a1249 1
   if (png_ptr->transformations & PNG_USER_TRANSFORM)
d1251 1
a1251 1
       if (info_ptr->bit_depth < png_ptr->user_transform_depth)
d1253 1
a1253 1
       if (info_ptr->channels < png_ptr->user_transform_channels)
d1261 1
a1261 1
   info_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth, info_ptr->width);
d1264 1
a1264 1
   if (png_ptr)
d1283 1
a1283 1
         "NULL row buffer for row %ld, pass %d", (long)png_ptr->row_number,
d1334 1
a1334 1
      if (rgb_error)
d1337 1
a1337 1
         if ((png_ptr->transformations & PNG_RGB_TO_GRAY) == 
d1340 1
a1340 1
         if ((png_ptr->transformations & PNG_RGB_TO_GRAY) ==
d1424 1
a1424 1
      if (png_ptr->row_info.rowbytes == (png_uint_32)0)
d1486 1
a1486 1
      if (png_ptr->read_user_transform_fn != NULL)
d1498 1
a1498 1
      if (png_ptr->user_transform_depth)
d1500 1
a1500 1
      if (png_ptr->user_transform_channels)
d1977 1
a1977 1
      if (row_info->bit_depth == 8)
d2009 1
a2009 1
      else if (row_info->bit_depth == 16)
d2049 1
a2049 1
      if (row_info->bit_depth == 8)
d2085 1
a2085 1
      else if (row_info->bit_depth == 16)
d2212 1
a2212 1
      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
d2220 2
a2221 4
 * <http://www.inforamp.net/~poynton/>  (THIS LINK IS DEAD June 2008)
 * New link:
 * <http://www.poynton.com/notes/colour_and_gamma/>
 * Charles Poynton poynton at poynton.com
d2272 1
a2272 1
                  if (red != green || red != blue)
d2276 1
a2276 1
                       (rc*red + gc*green + bc*blue)>>15];
d2279 1
a2279 1
                     *(dp++) = *(sp - 1);
d2292 1
a2292 1
                  if (red != green || red != blue)
d2295 1
a2295 1
                     *(dp++) = (png_byte)((rc*red + gc*green + bc*blue)>>15);
d2298 1
a2298 1
                     *(dp++) = *(sp - 1);
d2319 1
a2319 1
                  if (red == green && red == blue)
d2353 1
a2353 1
                  if (red != green || red != blue)
d2376 1
a2376 1
                  if (red != green || red != blue)
d2393 1
a2393 1
                  if (red != green || red != blue)
d2416 1
a2416 1
                  if (red == green && red == blue)
d2450 1
a2450 1
                  if (red != green || red != blue)
d2465 1
a2465 1
      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
d3383 1
a3383 1
         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
d3842 1
a3842 1
                  if (*(sp - 1) == gray_high && *(sp) == gray_low) 
d3921 1
a3921 1
         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
d3974 1
a3974 1
         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
d4003 1
a4003 1
         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
d4072 1
a4072 1
        if (png_ptr->screen_gamma > 0.000001)
d4132 1
a4132 1
        (png_uint_32)(num * png_sizeof(png_uint_16p)));
d4142 1
a4142 1
              (png_uint_32)(256 * png_sizeof(png_uint_16)));
d4172 1
a4172 1
              (png_uint_32)(256 * png_sizeof(png_uint_16)));
d4192 1
a4192 1
           (png_uint_32)(num * png_sizeof(png_uint_16p )));
d4197 1
a4197 1
              (png_uint_32)(256 * png_sizeof(png_uint_16)));
d4209 1
a4209 1
        if (png_ptr->screen_gamma > 0.000001)
d4215 1
a4215 1
           (png_uint_32)(num * png_sizeof(png_uint_16p)));
d4220 1
a4220 1
              (png_uint_32)(256 * png_sizeof(png_uint_16)));
d4285 5
a4289 5
            png_uint_32 s0   = (*(rp    ) << 8) | *(rp + 1);
            png_uint_32 s1   = (*(rp + 2) << 8) | *(rp + 3);
            png_uint_32 s2   = (*(rp + 4) << 8) | *(rp + 5);
            png_uint_32 red  = (png_uint_32)((s0 + s1 + 65536L) & 0xffffL);
            png_uint_32 blue = (png_uint_32)((s2 + s1 + 65536L) & 0xffffL);
@


1.1.107.7
log
@libpng 1.2.35
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.35 [February 14, 2009]
d6 1
a6 1
 * Copyright (c) 1998-2009 Glenn Randers-Pehrson
d24 1
a24 1
   png_debug(1, "in png_set_crc_action");
d83 1
a83 1
   png_debug(1, "in png_set_background");
d105 1
a105 1
   png_debug(1, "in png_set_strip_16");
d115 1
a115 1
   png_debug(1, "in png_set_strip_alpha");
d145 1
a145 1
   png_debug(1, "in png_set_dither");
d312 3
a314 1
         png_memset(hash, 0, 769 * png_sizeof(png_dsortp));
d529 1
a529 1
   png_debug(1, "in png_set_gamma");
d548 1
a548 1
   png_debug(1, "in png_set_expand");
d575 1
a575 1
   png_debug(1, "in png_set_palette_to_rgb");
d586 1
a586 1
   png_debug(1, "in png_set_expand_gray_1_2_4_to_8");
d599 1
a599 1
   png_debug(1, "in png_set_gray_1_2_4_to_8");
d610 1
a610 1
   png_debug(1, "in png_set_tRNS_to_alpha");
d620 1
a620 1
   png_debug(1, "in png_set_gray_to_rgb");
d647 1
a647 1
   png_debug(1, "in png_set_rgb_to_gray");
d687 1
a687 1
      png_ptr->rgb_to_gray_blue_coeff  =
d700 1
a700 1
   png_debug(1, "in png_set_read_user_transform_fn");
d720 1
a720 1
   png_debug(1, "in png_init_read_transformations");
d1127 1
a1127 1
   png_debug(1, "in png_read_transform_info");
d1271 1
a1271 1
   png_debug(1, "in png_do_read_transformations");
d1332 1
a1332 1
         if ((png_ptr->transformations & PNG_RGB_TO_GRAY) ==
d1517 1
a1517 1
   png_debug(1, "in png_do_unpack");
d1607 1
a1607 1
   png_debug(1, "in png_do_unshift");
d1713 1
a1713 1
   png_debug(1, "in png_do_chop");
d1767 1
a1767 1
   png_debug(1, "in png_do_read_swap_alpha");
d1859 1
a1859 1
   png_debug(1, "in png_do_read_invert_alpha");
d1965 1
a1965 1
   png_debug(1, "in png_do_read_filler");
d2137 1
a2137 1
   png_debug(1, "in png_do_gray_to_rgb");
d2243 1
a2243 1
   png_debug(1, "in png_do_rgb_to_gray");
d2481 1
a2481 1
   png_debug(1, "in png_do_build_grayscale_palette");
d2523 1
a2523 1
   png_debug(1, "in png_correct_palette");
d2720 1
a2720 1
   png_debug(1, "in png_do_background");
d3402 1
a3402 1
   png_debug(1, "in png_do_gamma");
d3584 1
a3584 1
   png_debug(1, "in png_do_expand_palette");
d3727 1
a3727 1
   png_debug(1, "in png_do_expand");
d3839 1
a3839 1
                  if (*(sp - 1) == gray_high && *(sp) == gray_low)
d3933 1
a3933 1
   png_debug(1, "in png_do_dither");
d4028 1
a4028 1
  png_debug(1, "in png_build_gamma_table");
a4135 2
        png_memset(png_ptr->gamma_16_table, 0, num * png_sizeof(png_uint_16p)); 

a4190 2
        png_memset(png_ptr->gamma_16_to_1, 0, num * png_sizeof(png_uint_16p)); 

a4213 3
        png_memset(png_ptr->gamma_16_from_1, 0,
           num * png_sizeof(png_uint_16p)); 

d4241 1
a4241 1
   png_debug(1, "in png_do_read_intrapixel");
@


1.1.107.8
log
@Update libpng in the base system, too
@
text
@d4 3
a6 2
 * Last changed in libpng 1.2.49 [March 29, 2012]
 * Copyright (c) 1998-2012 Glenn Randers-Pehrson
a9 4
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 *
a16 1
#define PNG_NO_PEDANTIC_WARNINGS
d18 1
a18 1
#ifdef PNG_READ_SUPPORTED
a24 4
 
   if (png_ptr == NULL)
      return;

d26 1
d29 1
a29 1
      case PNG_CRC_NO_CHANGE:                        /* Leave setting as is */
d31 1
a31 2

      case PNG_CRC_WARN_USE:                               /* Warn/use data */
d35 1
a35 2

      case PNG_CRC_QUIET_USE:                             /* Quiet/use data */
d40 1
a40 2

      case PNG_CRC_WARN_DISCARD:    /* Not a valid action for critical data */
d43 1
a43 2
      case PNG_CRC_ERROR_QUIT:                                /* Error/quit */

a49 1
   /* Tell libpng how we react to CRC errors in ancillary chunks */
d52 1
a52 1
      case PNG_CRC_NO_CHANGE:                       /* Leave setting as is */
d54 1
a54 2

      case PNG_CRC_WARN_USE:                              /* Warn/use data */
d58 1
a58 2

      case PNG_CRC_QUIET_USE:                            /* Quiet/use data */
d63 1
a63 2

      case PNG_CRC_ERROR_QUIT:                               /* Error/quit */
d67 1
a67 3

      case PNG_CRC_WARN_DISCARD:                      /* Warn/discard data */

d77 1
a77 1
/* Handle alpha and tRNS via a background color */
d84 1
a84 3
 
   if (png_ptr == NULL)
      return;
d100 2
a101 2
#ifdef PNG_READ_16_TO_8_SUPPORTED
/* Strip 16 bit depth files to 8 bit depth */
d106 1
a106 3

   if (png_ptr == NULL)
      return;
d111 1
a111 1
#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
d116 1
a116 3

   if (png_ptr == NULL)
      return;
d121 1
a121 1
#ifdef PNG_READ_DITHER_SUPPORTED
d146 1
a146 3

   if (png_ptr == NULL)
      return;
d164 1
a164 2
          * Perhaps not the best solution, but good enough.
          */
d168 1
a168 1
         /* Initialize an array to sort colors */
d172 1
a172 1
         /* Initialize the dither_sort array */
d177 4
a180 5
          * bubble sort, and running it until we have sorted
          * out enough colors.  Note that we don't care about
          * sorting all the colors, just finding which are
          * least used.
          */
d184 1
a184 1
            int done; /* To stop early if the list is pre-sorted */
d205 1
a205 1
         /* Swap the palette around, and set up a table, if necessary */
d210 2
a211 3
            /* Put all the useful colors within the max, but don't
             * move the others.
             */
d227 2
a228 3
            /* Move all the used colors inside the max limit, and
             * develop a translation table.
             */
d231 1
a231 1
               /* Only move the colors we need to */
d243 1
a243 1
                  /* Indicate where the color went */
d249 1
a249 1
            /* Find closest color for those colors we are not using */
d256 1
a256 1
                  /* Find the closest color to one we threw out */
d271 1
a271 1
                  /* Point to closest color */
d282 7
a288 7
          * we need to go through a median cut routine, but those
          * don't always behave themselves with only a few colors
          * as input.  So we will just find the closest two colors,
          * and throw out one of them (chosen somewhat randomly).
          * [We don't understand this at all, so if someone wants to
          *  work on improving it, be our guest - AED, GRP]
          */
d297 1
a297 1
         /* Initialize palette index arrays */
d303 1
a303 1
         /* Initialize the sort array */
d310 1
a310 1
         hash = (png_dsortpp)png_calloc(png_ptr, (png_uint_32)(769 *
d312 1
d316 8
a323 8
         /* Initial wild guess at how far apart the farthest pixel
          * pair we will be eliminating will be.  Larger
          * numbers mean more areas will be allocated, Smaller
          * numbers run the risk of not saving enough data, and
          * having to do this all over again.
          *
          * I have not done extensive checking on this number.
          */
d407 2
a408 4
                        png_ptr->index_to_palette[j] =
                            (png_byte)num_new_palette;
                        png_ptr->palette_to_index[num_new_palette] =
                            (png_byte)j;
d459 1
a459 1
      png_ptr->palette_lookup = (png_bytep )png_calloc(png_ptr,
d462 3
d467 1
d481 1
a481 2
            int index_r = (ir << (PNG_DITHER_BLUE_BITS +
                PNG_DITHER_GREEN_BITS));
d528 1
a528 4

   if (png_ptr == NULL)
      return;

d538 1
a538 1
#ifdef PNG_READ_EXPAND_SUPPORTED
d547 1
a547 4

   if (png_ptr == NULL)
      return;

d565 2
a566 3
 *  GRP 20060307: In libpng-1.2.9, png_set_gray_1_2_4_to_8() was modified
 *  to expand only the sample depth but not to expand the tRNS to alpha
 *  and its name was changed to png_set_expand_gray_1_2_4_to_8().
d574 1
a574 4

   if (png_ptr == NULL)
      return;

d579 1
a579 1
#ifndef PNG_1_0_X
d585 1
a585 4

   if (png_ptr == NULL)
      return;

d598 1
a598 4

   if (png_ptr == NULL)
      return;

a608 1

d614 1
a614 1
#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
a618 1

d624 2
a625 2
#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
#ifdef PNG_FLOATING_POINT_SUPPORTED
d634 4
a637 16
   int red_fixed, green_fixed;
   if (png_ptr == NULL)
      return;
   if (red > 21474.83647 || red < -21474.83648 ||
       green > 21474.83647 || green < -21474.83648)
   {
      png_warning(png_ptr, "ignoring out of range rgb_to_gray coefficients");
      red_fixed = -1;
      green_fixed = -1;
   }
   else
   {
      red_fixed = (int)((float)red*100000.0 + 0.5);
      green_fixed = (int)((float)green*100000.0 + 0.5);
   }
   png_set_rgb_to_gray_fixed(png_ptr, error_action, red_fixed, green_fixed);
d646 1
a646 4

   if (png_ptr == NULL)
      return;

a650 1

a652 1

d656 1
a656 1
#ifdef PNG_READ_EXPAND_SUPPORTED
d674 2
a675 2
         red_int = (png_uint_16)(((png_uint_32)red*32768L)/100000L);
         green_int = (png_uint_16)(((png_uint_32)green*32768L)/100000L);
d692 2
a693 2
    defined(PNG_LEGACY_SUPPORTED) || \
    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
d699 2
a700 5

   if (png_ptr == NULL)
      return;

#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
d719 2
a720 3

#ifdef PNG_USELESS_TESTS_SUPPORTED
  if (png_ptr != NULL)
d723 2
a724 3
#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \
    defined(PNG_READ_SHIFT_SUPPORTED) || \
    defined(PNG_READ_GAMMA_SUPPORTED)
d730 1
a730 1
#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
d732 2
a733 3
    * for gray --> RGB case
    *
    * Note:  if PNG_BACKGROUND_EXPAND is set and color_type is either RGB or
d760 1
a760 1
         /* Expand background and tRNS chunks */
a773 1

a784 1

a795 1

a796 1

d812 1
a812 1
#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
d815 1
a815 1
#ifdef PNG_READ_EXPAND_SUPPORTED
d819 2
a820 3
           /* Invert the alpha channel (in tRNS) unless the pixels are
            * going to be expanded, in which case leave it for later
            */
d847 1
a847 1
        k=1; /* Partial transparency is present */
d857 1
a857 2

#ifdef PNG_READ_BACKGROUND_SUPPORTED
d862 2
a863 1
           /* Could skip if no transparency */
a887 1

a891 1

d913 1
a913 2
                     (double)png_ptr->background.green/255, gs) * 255.0
                         + .5);
d957 8
a964 8
            /* Prevent the transformations being done again, and make sure
             * that the now spurious alpha channel is stripped - the code
             * has just reduced background composition and gamma correction
             * to a simple alpha channel strip.
             */
            png_ptr->transformations &= ~PNG_BACKGROUND;
            png_ptr->transformations &= ~PNG_GAMMA;
            png_ptr->transformations |= PNG_STRIP_ALPHA;
a979 1

a983 1

d1025 1
a1025 1
      /* Transformation does not include PNG_BACKGROUND */
d1040 2
a1041 2
         /* Done the gamma correction. */
         png_ptr->transformations &= ~PNG_GAMMA;
d1044 1
a1044 1
#ifdef PNG_READ_BACKGROUND_SUPPORTED
d1048 1
a1048 1
#ifdef PNG_READ_BACKGROUND_SUPPORTED
d1086 1
a1086 1
#ifdef PNG_READ_SHIFT_SUPPORTED
a1087 1
      !(png_ptr->transformations & PNG_EXPAND) &&
a1107 2

      png_ptr->transformations &= ~PNG_SHIFT;
d1126 1
a1126 2

#ifdef PNG_READ_EXPAND_SUPPORTED
d1131 2
a1132 1
         if (png_ptr->num_trans)
d1145 4
d1157 1
a1157 1
#ifdef PNG_READ_BACKGROUND_SUPPORTED
d1166 1
a1166 1
#ifdef PNG_READ_GAMMA_SUPPORTED
d1178 1
a1178 1
#ifdef PNG_READ_16_TO_8_SUPPORTED
d1183 1
a1183 1
#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
d1188 1
a1188 1
#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
d1193 1
a1193 1
#ifdef PNG_READ_DITHER_SUPPORTED
d1197 2
a1198 2
          (info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)) &&
          png_ptr->palette_lookup && info_ptr->bit_depth == 8)
d1205 1
a1205 1
#ifdef PNG_READ_PACK_SUPPORTED
d1217 1
a1217 1
#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
d1225 1
a1225 1
#ifdef PNG_READ_FILLER_SUPPORTED
d1232 2
a1233 2
      /* If adding a true alpha channel not just filler */
#ifndef PNG_1_0_X
d1256 1
a1256 1
#ifndef PNG_READ_EXPAND_SUPPORTED
a1269 1

d1272 1
a1272 1
#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)
d1287 1
a1287 2
       * pixels.  This check added to libpng-1.2.19
       */
d1295 1
a1295 1
#ifdef PNG_READ_EXPAND_SUPPORTED
d1316 1
a1316 1
#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
d1322 1
a1322 1
#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
d1326 1
a1326 2
         png_do_rgb_to_gray(png_ptr, &(png_ptr->row_info),
             png_ptr->row_buf + 1);
d1340 28
a1367 29
/* From Andreas Dilger e-mail to png-implement, 26 March 1998:
 *
 *   In most cases, the "simple transparency" should be done prior to doing
 *   gray-to-RGB, or you will have to test 3x as many bytes to check if a
 *   pixel is transparent.  You would also need to make sure that the
 *   transparency information is upgraded to RGB.
 *
 *   To summarize, the current flow is:
 *   - Gray + simple transparency -> compare 1 or 2 gray bytes and composite
 *                                   with background "in place" if transparent,
 *                                   convert to RGB if necessary
 *   - Gray + alpha -> composite with gray background and remove alpha bytes,
 *                                   convert to RGB if necessary
 *
 *   To support RGB backgrounds for gray images we need:
 *   - Gray + simple transparency -> convert to RGB + simple transparency,
 *                                   compare 3 or 6 bytes and composite with
 *                                   background "in place" if transparent
 *                                   (3x compare/pixel compared to doing
 *                                   composite with gray bkgrnd)
 *   - Gray + alpha -> convert to RGB + alpha, composite with background and
 *                                   remove alpha bytes (3x float
 *                                   operations/pixel compared with composite
 *                                   on gray background)
 *
 *  Greg's change will do this.  The reason it wasn't done before is for
 *  performance, as this increases the per-pixel operations.  If we would check
 *  in advance if the background was gray or RGB, and position the gray-to-RGB
 *  transform appropriately, then it would save a lot of work/time.
d1370 3
a1372 4
#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
   /* If gray -> RGB, do so now only if background is non-gray; else do later
    * for performance reasons
    */
d1378 1
a1378 1
#ifdef PNG_READ_BACKGROUND_SUPPORTED
d1384 1
a1384 1
#ifdef PNG_READ_GAMMA_SUPPORTED
d1394 1
a1394 1
#ifdef PNG_READ_GAMMA_SUPPORTED
d1396 4
a1399 4
#ifdef PNG_READ_BACKGROUND_SUPPORTED
       !((png_ptr->transformations & PNG_BACKGROUND) &&
       ((png_ptr->num_trans != 0) ||
       (png_ptr->color_type & PNG_COLOR_MASK_ALPHA))) &&
d1401 1
a1401 1
       (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE))
d1403 2
a1404 2
          png_ptr->gamma_table, png_ptr->gamma_16_table,
          png_ptr->gamma_shift);
d1407 1
a1407 1
#ifdef PNG_READ_16_TO_8_SUPPORTED
d1412 1
a1412 1
#ifdef PNG_READ_DITHER_SUPPORTED
d1422 1
a1422 1
#ifdef PNG_READ_INVERT_SUPPORTED
d1427 1
a1427 1
#ifdef PNG_READ_SHIFT_SUPPORTED
d1433 1
a1433 1
#ifdef PNG_READ_PACK_SUPPORTED
d1438 1
a1438 1
#ifdef PNG_READ_BGR_SUPPORTED
d1443 1
a1443 1
#ifdef PNG_READ_PACKSWAP_SUPPORTED
d1448 2
a1449 2
#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
   /* If gray -> RGB, do so now only if we did not do so above */
d1455 1
a1455 1
#ifdef PNG_READ_FILLER_SUPPORTED
d1461 1
a1461 1
#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
d1466 1
a1466 1
#ifdef PNG_READ_SWAP_ALPHA_SUPPORTED
d1471 1
a1471 1
#ifdef PNG_READ_SWAP_SUPPORTED
d1476 1
a1476 1
#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
d1480 11
a1490 11
         (*(png_ptr->read_user_transform_fn)) /* User read transform function */
            (png_ptr,                    /* png_ptr */
               &(png_ptr->row_info),     /* row_info: */
               /*  png_uint_32 width;       width of row */
               /*  png_uint_32 rowbytes;    number of bytes in row */
               /*  png_byte color_type;     color type of pixels */
               /*  png_byte bit_depth;      bit depth of samples */
               /*  png_byte channels;       number of channels (1-4) */
               /*  png_byte pixel_depth;    bits per pixel (depth*channels) */
               png_ptr->row_buf + 1);    /* start of pixel data for row */
#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED
d1505 1
a1505 1
#ifdef PNG_READ_PACK_SUPPORTED
d1516 1
a1516 2

#ifdef PNG_USELESS_TESTS_SUPPORTED
a1546 1

a1567 1

d1596 1
a1596 1
#ifdef PNG_READ_SHIFT_SUPPORTED
a1605 1

d1607 1
a1607 1
#ifdef PNG_USELESS_TESTS_SUPPORTED
a1658 1

a1673 1

a1685 1

d1706 2
a1707 2
#ifdef PNG_READ_16_TO_8_SUPPORTED
/* Chop rows of bit depth 16 down to 8 */
d1712 1
a1712 2

#ifdef PNG_USELESS_TESTS_SUPPORTED
d1725 1
a1725 1
#ifdef PNG_READ_16_TO_8_ACCURATE_SCALE_SUPPORTED
d1731 1
a1731 2
       *          (png_uint_32)(*(sp + 1))) * 255 + 127)
       *          / (png_uint_32)65535L;
d1735 1
a1735 2
       *           (png_uint_32)(*(sp + 1))) + 128L)
       *           / (png_uint_32)257L;
d1738 1
a1738 2
       *   temp = (((png_uint_32)(*sp) << 8) |
       *           (png_uint_32)(*(sp + 1))) + 128L;
d1761 1
a1761 1
#ifdef PNG_READ_SWAP_ALPHA_SUPPORTED
d1766 1
a1766 2

#ifdef PNG_USELESS_TESTS_SUPPORTED
d1853 1
a1853 1
#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
d1858 1
a1858 2

#ifdef PNG_USELESS_TESTS_SUPPORTED
d1951 1
a1951 1
#ifdef PNG_READ_FILLER_SUPPORTED
a1963 1

d1965 1
a1965 1
#ifdef PNG_USELESS_TESTS_SUPPORTED
d2127 2
a2128 2
#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
/* Expand grayscale files to RGB, with or without alpha */
a2135 1

d2137 1
a2137 1
#ifdef PNG_USELESS_TESTS_SUPPORTED
d2210 2
a2211 2
#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
/* Reduce RGB files to grayscale, with or without alpha
a2241 1

d2243 1
a2243 1
#ifdef PNG_USELESS_TESTS_SUPPORTED
d2320 1
a2320 2
                     png_uint_16 green_1 =
                         png_ptr->gamma_16_to_1[(green&0xff) >>
d2416 3
a2418 4
                         png_ptr->gamma_shift][red>>8];
                     png_uint_16 green_1 =
                         png_ptr->gamma_16_to_1[(green&0xff) >>
                         png_ptr->gamma_shift][green>>8];
d2420 1
a2420 1
                         png_ptr->gamma_shift][blue>>8];
d2422 1
a2422 1
                         + gc * green_1 + bc * blue_1)>>15);
a2479 1

a2488 1

a2492 1

a2496 1

a2500 1

d2516 1
a2516 2
#if defined(PNG_READ_DITHER_SUPPORTED) && \
  defined(PNG_CORRECT_PALETTE_SUPPORTED)
a2521 1

d2523 1
a2523 2
    defined(PNG_READ_GAMMA_SUPPORTED) && \
  defined(PNG_FLOATING_POINT_SUPPORTED)
d2544 2
a2545 2
         if (png_ptr->background_gamma_type == PNG_BACKGROUND_GAMMA_SCREEN
             || fabs(g - 1.0) < PNG_GAMMA_THRESHOLD)
d2632 1
a2632 1
#ifdef PNG_READ_GAMMA_SUPPORTED
d2644 1
a2644 1
#ifdef PNG_READ_BACKGROUND_SUPPORTED
d2648 1
a2648 1
#ifdef PNG_READ_BACKGROUND_SUPPORTED
d2678 1
a2678 1
      else /* Assume grayscale palette (what else could it be?) */
d2697 1
a2697 1
#ifdef PNG_READ_BACKGROUND_SUPPORTED
d2705 1
a2705 1
#ifdef PNG_READ_GAMMA_SUPPORTED
a2718 1

d2720 1
a2720 1
#ifdef PNG_USELESS_TESTS_SUPPORTED
a2753 1

d2756 1
a2756 1
#ifdef PNG_READ_GAMMA_SUPPORTED
a2809 1

d2812 1
a2812 1
#ifdef PNG_READ_GAMMA_SUPPORTED
a2865 1

d2868 1
a2868 1
#ifdef PNG_READ_GAMMA_SUPPORTED
a2897 1

d2900 1
a2900 1
#ifdef PNG_READ_GAMMA_SUPPORTED
d2911 1
a2911 1
                           /* Background is already in screen gamma */
a2943 1

d2948 1
a2948 1
#ifdef PNG_READ_GAMMA_SUPPORTED
d2989 1
a2989 1
#ifdef PNG_READ_GAMMA_SUPPORTED
d3001 1
a3001 1
                        /* Background is already in screen gamma */
a3047 1

d3052 1
a3052 1
#ifdef PNG_READ_GAMMA_SUPPORTED
d3068 1
a3068 1
                        /* Background is already in screen gamma */
d3094 1
a3094 1
#ifdef PNG_READ_GAMMA_SUPPORTED
d3111 1
a3111 1
#ifdef PNG_READ_GAMMA_SUPPORTED
d3129 1
a3129 1
#ifdef PNG_READ_GAMMA_SUPPORTED
d3135 1
a3135 1
                        /* Background is already in screen gamma */
d3139 1
a3139 1
#ifdef PNG_READ_GAMMA_SUPPORTED
d3165 1
a3165 1
#ifdef PNG_READ_GAMMA_SUPPORTED
d3174 1
a3174 1
#ifdef PNG_READ_GAMMA_SUPPORTED
a3189 1

d3194 1
a3194 1
#ifdef PNG_READ_GAMMA_SUPPORTED
d3212 1
a3212 1
                        /* Background is already in screen gamma */
d3267 1
a3267 1
#ifdef PNG_READ_GAMMA_SUPPORTED
d3293 1
a3293 1
                        /* Background is already in screen gamma */
d3384 1
a3384 1
#ifdef PNG_READ_GAMMA_SUPPORTED
a3400 1

d3402 1
a3402 1
#ifdef PNG_USELESS_TESTS_SUPPORTED
a3447 1

a3484 1

a3508 1

d3522 4
a3525 4
                      ((((int)gamma_table[a|(a>>2)|(a>>4)|(a>>6)])   ) & 0xc0)|
                      ((((int)gamma_table[(b<<2)|b|(b>>2)|(b>>4)])>>2) & 0x30)|
                      ((((int)gamma_table[(c<<4)|(c<<2)|c|(c>>2)])>>4) & 0x0c)|
                      ((((int)gamma_table[(d<<6)|(d<<4)|(d<<2)|d])>>6) ));
a3528 1

d3538 1
a3538 1
                      | (((int)gamma_table[(lsb << 4) | lsb]) >> 4));
a3541 1

a3550 1

d3569 1
a3569 1
#ifdef PNG_READ_EXPAND_SUPPORTED
a3582 1

d3584 1
a3584 1
#ifdef PNG_USELESS_TESTS_SUPPORTED
a3615 1

a3636 1

a3700 1

d3726 1
a3726 2

#ifdef PNG_USELESS_TESTS_SUPPORTED
a3761 1

a3784 1

a3807 1

a3828 1

a3850 1

d3922 1
a3922 1
#ifdef PNG_READ_DITHER_SUPPORTED
d3932 1
a3932 2

#ifdef PNG_USELESS_TESTS_SUPPORTED
d3948 7
a3954 7
            /* This looks real messy, but the compiler will reduce
             * it down to a reasonable formula.  For example, with
             * 5 bits per color, we get:
             * p = (((r >> 3) & 0x1f) << 10) |
             *    (((g >> 3) & 0x1f) << 5) |
             *    ((b >> 3) & 0x1f);
             */
d4014 1
a4014 1
#ifdef PNG_READ_GAMMA_SUPPORTED
a4021 27
 *
 * See the PNG extensions document for an integer algorithm for creating
 * the gamma tables.  Maybe we will implement that here someday.
 *
 * We should only reach this point if
 *
 *      the file_gamma is known (i.e., the gAMA or sRGB chunk is present,
 *      or the application has provided a file_gamma)
 *
 *   AND
 *      {
 *         the screen_gamma is known
 *      OR
 *
 *         RGB_to_gray transformation is being performed
 *      }
 *
 *   AND
 *      {
 *         the screen_gamma is different from the reciprocal of the
 *         file_gamma by more than the specified threshold
 *
 *      OR
 *
 *         a background color has been specified and the file_gamma
 *         and screen_gamma are not 1.0, within the specified threshold.
 *      }
a4022 1

a4034 1

a4068 1

d4070 1
a4070 1
           g = png_ptr->gamma;   /* Probably doing rgb_to_gray */
a4090 1

a4092 1

a4102 1

a4113 1

d4126 1
a4126 1
     png_ptr->gamma_16_table = (png_uint_16pp)png_calloc(png_ptr,
d4134 2
a4171 1

d4188 1
a4188 1
        png_ptr->gamma_16_to_1 = (png_uint_16pp)png_calloc(png_ptr,
d4191 2
a4209 1

d4211 1
a4211 1
           g = png_ptr->gamma;   /* Probably doing rgb_to_gray */
d4213 1
a4213 1
        png_ptr->gamma_16_from_1 = (png_uint_16pp)png_calloc(png_ptr,
d4216 3
a4225 1

d4241 2
a4242 2
#ifdef PNG_MNG_FEATURES_SUPPORTED
/* Undoes intrapixel differencing  */
a4246 1

d4248 1
a4248 1
#ifdef PNG_USELESS_TESTS_SUPPORTED
a4261 1

a4263 1

a4279 1

a4281 1

@


1.1.107.9
log
@update libpng
@
text
@d4 2
a5 2
 * Last changed in libpng 1.2.53 [February 26, 2015]
 * Copyright (c) 1998-2002,2004,2006-2015 Glenn Randers-Pehrson
a919 1
      {
a920 2
        break;
      }
a1378 3
         if (png_ptr->palette == NULL)
            png_error (png_ptr, "Palette is NULL in indexed image");

a2406 1
                  png_byte hi,lo;
d2408 3
a2410 6
                  hi=*(sp)++; lo=*(sp)++;
                  red   = (png_uint_16)((hi << 8) | (lo));
                  hi=*(sp)++; lo=*(sp)++;
                  green = (png_uint_16)((hi << 8) | (lo));
                  hi=*(sp)++; lo=*(sp)++;
                  blue  = (png_uint_16)((hi << 8) | (lo));
a2441 1
                  png_byte hi,lo;
d2443 3
a2445 6
                  hi=*(sp)++; lo=*(sp)++;
                  red   = (png_uint_16)((hi << 8) | (lo));
                  hi=*(sp)++; lo=*(sp)++;
                  green = (png_uint_16)((hi << 8) | (lo));
                  hi=*(sp)++; lo=*(sp)++;
                  blue  = (png_uint_16)((hi << 8) | (lo));
a2504 1
                  png_byte hi,lo;
d2506 3
a2508 6
                  hi=*(sp)++; lo=*(sp)++;
                  red   = (png_uint_16)((hi << 8) | (lo));
                  hi=*(sp)++; lo=*(sp)++;
                  green = (png_uint_16)((hi << 8) | (lo));
                  hi=*(sp)++; lo=*(sp)++;
                  blue  = (png_uint_16)((hi << 8) | (lo));
@


