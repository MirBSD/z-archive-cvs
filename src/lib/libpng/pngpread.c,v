head	1.10;
access;
symbols
	png-1_2_57:1.1.107.9
	png-1_2_50:1.1.107.8
	png-1_2_35:1.1.107.7
	png-1_2_32:1.1.107.7
	png-1_2_26:1.1.107.6
	png-1_2_25:1.1.107.5
	MIRBSD_10:1.5.0.2
	MIRBSD_10_BASE:1.5
	png-1_2_18:1.1.107.4
	png-1_2_12:1.1.107.3
	MIRBSD_9_BASE:1.3
	png-1_2_10:1.1.107.2
	MIRBSD_8:1.2.0.2
	MIRBSD_8_BASE:1.2
	png-1_2_8:1.1.107.1
	libpng:1.1.107;
locks; strict;
comment	@ * @;


1.10
date	2017.04.15.15.26.48;	author tg;	state Exp;
branches;
next	1.9;
commitid	10058F23BCC5ED04858;

1.9
date	2013.08.06.18.49.29;	author tg;	state Exp;
branches;
next	1.8;
commitid	1005201454765C5CF06;

1.8
date	2008.10.22.19.11.51;	author tg;	state Exp;
branches;
next	1.7;
commitid	10048FF7AEF54F9B169;

1.7
date	2008.04.07.19.54.34;	author tg;	state Exp;
branches;
next	1.6;
commitid	10047FA7C0D12C807EE;

1.6
date	2008.03.23.17.54.54;	author tg;	state Exp;
branches;
next	1.5;
commitid	10047E6997C6BB35CA9;

1.5
date	2007.05.22.20.46.18;	author tg;	state Exp;
branches;
next	1.4;
commitid	100465356AC5C1E9A9B;

1.4
date	2006.06.29.17.14.24;	author tg;	state Exp;
branches;
next	1.3;
commitid	10044A40A7D396C3456;

1.3
date	2006.06.09.00.30.27;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004488C1225295157F;

1.2
date	2005.03.06.20.29.16;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.06.15.16.20;	author tg;	state Exp;
branches
	1.1.107.1;
next	;

1.1.107.1
date	2005.03.06.15.16.20;	author tg;	state Exp;
branches;
next	1.1.107.2;

1.1.107.2
date	2006.06.09.00.13.06;	author tg;	state Exp;
branches;
next	1.1.107.3;
commitid	1004488BD054F510AF1;

1.1.107.3
date	2006.06.29.17.08.58;	author tg;	state Exp;
branches;
next	1.1.107.4;
commitid	10044A409367518C911;

1.1.107.4
date	2007.05.22.20.25.37;	author tg;	state Exp;
branches;
next	1.1.107.5;
commitid	100465351CF4103214A;

1.1.107.5
date	2008.03.23.17.15.18;	author tg;	state Exp;
branches;
next	1.1.107.6;
commitid	10047E69020419198D8;

1.1.107.6
date	2008.04.07.19.51.01;	author tg;	state Exp;
branches;
next	1.1.107.7;
commitid	10047FA7B332B97228B;

1.1.107.7
date	2008.10.22.18.55.40;	author tg;	state Exp;
branches;
next	1.1.107.8;
commitid	10048FF773834003AB5;

1.1.107.8
date	2013.08.06.17.35.03;	author tg;	state Exp;
branches;
next	1.1.107.9;
commitid	100520133D730551D16;

1.1.107.9
date	2017.04.15.15.00.13;	author tg;	state Exp;
branches;
next	;
commitid	10058F2359276DB0E16;


desc
@@


1.10
log
@a rather slow fastmergeâ€¦
@
text
@
/* pngpread.c - read a png file in push mode
 *
 * Last changed in libpng 1.2.57 [(TO BE RELEASED)]
 * Copyright (c) 1998-2002,2004,2006-2010,2016 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 */

#define PNG_INTERNAL
#define PNG_NO_PEDANTIC_WARNINGS
#include "png.h"
#ifdef PNG_PROGRESSIVE_READ_SUPPORTED

/* Push model modes */
#define PNG_READ_SIG_MODE   0
#define PNG_READ_CHUNK_MODE 1
#define PNG_READ_IDAT_MODE  2
#define PNG_SKIP_MODE       3
#define PNG_READ_tEXt_MODE  4
#define PNG_READ_zTXt_MODE  5
#define PNG_READ_DONE_MODE  6
#define PNG_READ_iTXt_MODE  7
#define PNG_ERROR_MODE      8

void PNGAPI
png_process_data(png_structp png_ptr, png_infop info_ptr,
   png_bytep buffer, png_size_t buffer_size)
{
   if (png_ptr == NULL || info_ptr == NULL)
      return;

   png_push_restore_buffer(png_ptr, buffer, buffer_size);

   while (png_ptr->buffer_size)
   {
      png_process_some_data(png_ptr, info_ptr);
   }
}

/* What we do with the incoming data depends on what we were previously
 * doing before we ran out of data...
 */
void /* PRIVATE */
png_process_some_data(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr == NULL)
      return;

   switch (png_ptr->process_mode)
   {
      case PNG_READ_SIG_MODE:
      {
         png_push_read_sig(png_ptr, info_ptr);
         break;
      }

      case PNG_READ_CHUNK_MODE:
      {
         png_push_read_chunk(png_ptr, info_ptr);
         break;
      }

      case PNG_READ_IDAT_MODE:
      {
         png_push_read_IDAT(png_ptr);
         break;
      }

      case PNG_SKIP_MODE:
      {
         png_push_crc_finish(png_ptr);
         break;
      }

      default:
      {
         png_ptr->buffer_size = 0;
         break;
      }
   }
}

/* Read any remaining signature bytes from the stream and compare them with
 * the correct PNG signature.  It is possible that this routine is called
 * with bytes already read from the signature, either because they have been
 * checked by the calling application, or because of multiple calls to this
 * routine.
 */
void /* PRIVATE */
png_push_read_sig(png_structp png_ptr, png_infop info_ptr)
{
   png_size_t num_checked = png_ptr->sig_bytes,
             num_to_check = 8 - num_checked;

   if (png_ptr->buffer_size < num_to_check)
   {
      num_to_check = png_ptr->buffer_size;
   }

   png_push_fill_buffer(png_ptr, &(info_ptr->signature[num_checked]),
      num_to_check);
   png_ptr->sig_bytes = (png_byte)(png_ptr->sig_bytes + num_to_check);

   if (png_sig_cmp(info_ptr->signature, num_checked, num_to_check))
   {
      if (num_checked < 4 &&
          png_sig_cmp(info_ptr->signature, num_checked, num_to_check - 4))
         png_error(png_ptr, "Not a PNG file");
      else
         png_error(png_ptr, "PNG file corrupted by ASCII conversion");
   }
   else
   {
      if (png_ptr->sig_bytes >= 8)
      {
         png_ptr->process_mode = PNG_READ_CHUNK_MODE;
      }
   }
}

void /* PRIVATE */
png_push_read_chunk(png_structp png_ptr, png_infop info_ptr)
{
#ifdef PNG_USE_LOCAL_ARRAYS
      PNG_CONST PNG_IHDR;
      PNG_CONST PNG_IDAT;
      PNG_CONST PNG_IEND;
      PNG_CONST PNG_PLTE;
#ifdef PNG_READ_bKGD_SUPPORTED
      PNG_CONST PNG_bKGD;
#endif
#ifdef PNG_READ_cHRM_SUPPORTED
      PNG_CONST PNG_cHRM;
#endif
#ifdef PNG_READ_gAMA_SUPPORTED
      PNG_CONST PNG_gAMA;
#endif
#ifdef PNG_READ_hIST_SUPPORTED
      PNG_CONST PNG_hIST;
#endif
#ifdef PNG_READ_iCCP_SUPPORTED
      PNG_CONST PNG_iCCP;
#endif
#ifdef PNG_READ_iTXt_SUPPORTED
      PNG_CONST PNG_iTXt;
#endif
#ifdef PNG_READ_oFFs_SUPPORTED
      PNG_CONST PNG_oFFs;
#endif
#ifdef PNG_READ_pCAL_SUPPORTED
      PNG_CONST PNG_pCAL;
#endif
#ifdef PNG_READ_pHYs_SUPPORTED
      PNG_CONST PNG_pHYs;
#endif
#ifdef PNG_READ_sBIT_SUPPORTED
      PNG_CONST PNG_sBIT;
#endif
#ifdef PNG_READ_sCAL_SUPPORTED
      PNG_CONST PNG_sCAL;
#endif
#ifdef PNG_READ_sRGB_SUPPORTED
      PNG_CONST PNG_sRGB;
#endif
#ifdef PNG_READ_sPLT_SUPPORTED
      PNG_CONST PNG_sPLT;
#endif
#ifdef PNG_READ_tEXt_SUPPORTED
      PNG_CONST PNG_tEXt;
#endif
#ifdef PNG_READ_tIME_SUPPORTED
      PNG_CONST PNG_tIME;
#endif
#ifdef PNG_READ_tRNS_SUPPORTED
      PNG_CONST PNG_tRNS;
#endif
#ifdef PNG_READ_zTXt_SUPPORTED
      PNG_CONST PNG_zTXt;
#endif
#endif /* PNG_USE_LOCAL_ARRAYS */

   /* First we make sure we have enough data for the 4 byte chunk name
    * and the 4 byte chunk length before proceeding with decoding the
    * chunk data.  To fully decode each of these chunks, we also make
    * sure we have enough data in the buffer for the 4 byte CRC at the
    * end of every chunk (except IDAT, which is handled separately).
    */
   if (!(png_ptr->mode & PNG_HAVE_CHUNK_HEADER))
   {
      png_byte chunk_length[4];

      if (png_ptr->buffer_size < 8)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_push_fill_buffer(png_ptr, chunk_length, 4);
      png_ptr->push_length = png_get_uint_31(png_ptr, chunk_length);
      png_reset_crc(png_ptr);
      png_crc_read(png_ptr, png_ptr->chunk_name, 4);
      png_check_chunk_name(png_ptr, png_ptr->chunk_name);
      png_ptr->mode |= PNG_HAVE_CHUNK_HEADER;
   }

   if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
     if (png_ptr->mode & PNG_AFTER_IDAT)
        png_ptr->mode |= PNG_HAVE_CHUNK_AFTER_IDAT;

   if (!png_memcmp(png_ptr->chunk_name, png_IHDR, 4))
   {
      if (png_ptr->push_length != 13)
         png_error(png_ptr, "Invalid IHDR length");

      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_IHDR(png_ptr, info_ptr, png_ptr->push_length);
   }

   else if (!png_memcmp(png_ptr->chunk_name, png_IEND, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_IEND(png_ptr, info_ptr, png_ptr->push_length);

      png_ptr->process_mode = PNG_READ_DONE_MODE;
      png_push_have_end(png_ptr, info_ptr);
   }

#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
   else if (png_handle_as_unknown(png_ptr, png_ptr->chunk_name))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
         png_ptr->mode |= PNG_HAVE_IDAT;

      png_handle_unknown(png_ptr, info_ptr, png_ptr->push_length);

      if (!png_memcmp(png_ptr->chunk_name, png_PLTE, 4))
         png_ptr->mode |= PNG_HAVE_PLTE;

      else if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
      {
         if (!(png_ptr->mode & PNG_HAVE_IHDR))
            png_error(png_ptr, "Missing IHDR before IDAT");

         else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
                  !(png_ptr->mode & PNG_HAVE_PLTE))
            png_error(png_ptr, "Missing PLTE before IDAT");
      }
   }

#endif
   else if (!png_memcmp(png_ptr->chunk_name, png_PLTE, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }
      png_handle_PLTE(png_ptr, info_ptr, png_ptr->push_length);
   }

   else if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
   {
      /* If we reach an IDAT chunk, this means we have read all of the
       * header chunks, and we can start reading the image (or if this
       * is called after the image has been read - we have an error).
       */

      if (!(png_ptr->mode & PNG_HAVE_IHDR))
         png_error(png_ptr, "Missing IHDR before IDAT");

      else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
          !(png_ptr->mode & PNG_HAVE_PLTE))
         png_error(png_ptr, "Missing PLTE before IDAT");

      if (png_ptr->mode & PNG_HAVE_IDAT)
      {
         if (!(png_ptr->mode & PNG_HAVE_CHUNK_AFTER_IDAT))
            if (png_ptr->push_length == 0)
               return;

         if (png_ptr->mode & PNG_AFTER_IDAT)
            png_error(png_ptr, "Too many IDAT's found");
      }

      png_ptr->idat_size = png_ptr->push_length;
      png_ptr->mode |= PNG_HAVE_IDAT;
      png_ptr->process_mode = PNG_READ_IDAT_MODE;
      png_push_have_info(png_ptr, info_ptr);
      png_ptr->zstream.avail_out =
          (uInt) PNG_ROWBYTES(png_ptr->pixel_depth,
          png_ptr->iwidth) + 1;
      png_ptr->zstream.next_out = png_ptr->row_buf;
      return;
   }

#ifdef PNG_READ_gAMA_SUPPORTED
   else if (!png_memcmp(png_ptr->chunk_name, png_gAMA, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_gAMA(png_ptr, info_ptr, png_ptr->push_length);
   }

#endif
#ifdef PNG_READ_sBIT_SUPPORTED
   else if (!png_memcmp(png_ptr->chunk_name, png_sBIT, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_sBIT(png_ptr, info_ptr, png_ptr->push_length);
   }

#endif
#ifdef PNG_READ_cHRM_SUPPORTED
   else if (!png_memcmp(png_ptr->chunk_name, png_cHRM, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_cHRM(png_ptr, info_ptr, png_ptr->push_length);
   }

#endif
#ifdef PNG_READ_sRGB_SUPPORTED
   else if (!png_memcmp(png_ptr->chunk_name, png_sRGB, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_sRGB(png_ptr, info_ptr, png_ptr->push_length);
   }

#endif
#ifdef PNG_READ_iCCP_SUPPORTED
   else if (!png_memcmp(png_ptr->chunk_name, png_iCCP, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_iCCP(png_ptr, info_ptr, png_ptr->push_length);
   }

#endif
#ifdef PNG_READ_sPLT_SUPPORTED
   else if (!png_memcmp(png_ptr->chunk_name, png_sPLT, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_sPLT(png_ptr, info_ptr, png_ptr->push_length);
   }

#endif
#ifdef PNG_READ_tRNS_SUPPORTED
   else if (!png_memcmp(png_ptr->chunk_name, png_tRNS, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_tRNS(png_ptr, info_ptr, png_ptr->push_length);
   }

#endif
#ifdef PNG_READ_bKGD_SUPPORTED
   else if (!png_memcmp(png_ptr->chunk_name, png_bKGD, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_bKGD(png_ptr, info_ptr, png_ptr->push_length);
   }

#endif
#ifdef PNG_READ_hIST_SUPPORTED
   else if (!png_memcmp(png_ptr->chunk_name, png_hIST, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_hIST(png_ptr, info_ptr, png_ptr->push_length);
   }

#endif
#ifdef PNG_READ_pHYs_SUPPORTED
   else if (!png_memcmp(png_ptr->chunk_name, png_pHYs, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_pHYs(png_ptr, info_ptr, png_ptr->push_length);
   }

#endif
#ifdef PNG_READ_oFFs_SUPPORTED
   else if (!png_memcmp(png_ptr->chunk_name, png_oFFs, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_oFFs(png_ptr, info_ptr, png_ptr->push_length);
   }
#endif

#ifdef PNG_READ_pCAL_SUPPORTED
   else if (!png_memcmp(png_ptr->chunk_name, png_pCAL, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_pCAL(png_ptr, info_ptr, png_ptr->push_length);
   }

#endif
#ifdef PNG_READ_sCAL_SUPPORTED
   else if (!png_memcmp(png_ptr->chunk_name, png_sCAL, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_sCAL(png_ptr, info_ptr, png_ptr->push_length);
   }

#endif
#ifdef PNG_READ_tIME_SUPPORTED
   else if (!png_memcmp(png_ptr->chunk_name, png_tIME, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_tIME(png_ptr, info_ptr, png_ptr->push_length);
   }

#endif
#ifdef PNG_READ_tEXt_SUPPORTED
   else if (!png_memcmp(png_ptr->chunk_name, png_tEXt, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_tEXt(png_ptr, info_ptr, png_ptr->push_length);
   }

#endif
#ifdef PNG_READ_zTXt_SUPPORTED
   else if (!png_memcmp(png_ptr->chunk_name, png_zTXt, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_zTXt(png_ptr, info_ptr, png_ptr->push_length);
   }

#endif
#ifdef PNG_READ_iTXt_SUPPORTED
   else if (!png_memcmp(png_ptr->chunk_name, png_iTXt, 4))
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_handle_iTXt(png_ptr, info_ptr, png_ptr->push_length);
   }

#endif
   else
   {
      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
      {
         png_push_save_buffer(png_ptr);
         return;
      }
      png_handle_unknown(png_ptr, info_ptr, png_ptr->push_length);
   }

   png_ptr->mode &= ~PNG_HAVE_CHUNK_HEADER;
}

void /* PRIVATE */
png_push_crc_skip(png_structp png_ptr, png_uint_32 skip)
{
   png_ptr->process_mode = PNG_SKIP_MODE;
   png_ptr->skip_length = skip;
}

void /* PRIVATE */
png_push_crc_finish(png_structp png_ptr)
{
   if (png_ptr->skip_length && png_ptr->save_buffer_size)
   {
      png_size_t save_size;

      if (png_ptr->skip_length < (png_uint_32)png_ptr->save_buffer_size)
         save_size = (png_size_t)png_ptr->skip_length;
      else
         save_size = png_ptr->save_buffer_size;

      png_calculate_crc(png_ptr, png_ptr->save_buffer_ptr, save_size);

      png_ptr->skip_length -= save_size;
      png_ptr->buffer_size -= save_size;
      png_ptr->save_buffer_size -= save_size;
      png_ptr->save_buffer_ptr += save_size;
   }
   if (png_ptr->skip_length && png_ptr->current_buffer_size)
   {
      png_size_t save_size;

      if (png_ptr->skip_length < (png_uint_32)png_ptr->current_buffer_size)
         save_size = (png_size_t)png_ptr->skip_length;
      else
         save_size = png_ptr->current_buffer_size;

      png_calculate_crc(png_ptr, png_ptr->current_buffer_ptr, save_size);

      png_ptr->skip_length -= save_size;
      png_ptr->buffer_size -= save_size;
      png_ptr->current_buffer_size -= save_size;
      png_ptr->current_buffer_ptr += save_size;
   }
   if (!png_ptr->skip_length)
   {
      if (png_ptr->buffer_size < 4)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_crc_finish(png_ptr, 0);
      png_ptr->process_mode = PNG_READ_CHUNK_MODE;
   }
}

void PNGAPI
png_push_fill_buffer(png_structp png_ptr, png_bytep buffer, png_size_t length)
{
   png_bytep ptr;

   if (png_ptr == NULL)
      return;

   ptr = buffer;
   if (png_ptr->save_buffer_size)
   {
      png_size_t save_size;

      if (length < png_ptr->save_buffer_size)
         save_size = length;
      else
         save_size = png_ptr->save_buffer_size;

      png_memcpy(ptr, png_ptr->save_buffer_ptr, save_size);
      length -= save_size;
      ptr += save_size;
      png_ptr->buffer_size -= save_size;
      png_ptr->save_buffer_size -= save_size;
      png_ptr->save_buffer_ptr += save_size;
   }
   if (length && png_ptr->current_buffer_size)
   {
      png_size_t save_size;

      if (length < png_ptr->current_buffer_size)
         save_size = length;

      else
         save_size = png_ptr->current_buffer_size;

      png_memcpy(ptr, png_ptr->current_buffer_ptr, save_size);
      png_ptr->buffer_size -= save_size;
      png_ptr->current_buffer_size -= save_size;
      png_ptr->current_buffer_ptr += save_size;
   }
}

void /* PRIVATE */
png_push_save_buffer(png_structp png_ptr)
{
   if (png_ptr->save_buffer_size)
   {
      if (png_ptr->save_buffer_ptr != png_ptr->save_buffer)
      {
         png_size_t i, istop;
         png_bytep sp;
         png_bytep dp;

         istop = png_ptr->save_buffer_size;
         for (i = 0, sp = png_ptr->save_buffer_ptr, dp = png_ptr->save_buffer;
            i < istop; i++, sp++, dp++)
         {
            *dp = *sp;
         }
      }
   }
   if (png_ptr->save_buffer_size + png_ptr->current_buffer_size >
      png_ptr->save_buffer_max)
   {
      png_size_t new_max;
      png_bytep old_buffer;

      if (png_ptr->save_buffer_size > PNG_SIZE_MAX -
         (png_ptr->current_buffer_size + 256))
      {
        png_error(png_ptr, "Potential overflow of save_buffer");
      }

      new_max = png_ptr->save_buffer_size + png_ptr->current_buffer_size + 256;
      old_buffer = png_ptr->save_buffer;
      png_ptr->save_buffer = (png_bytep)png_malloc_warn(png_ptr,
         (png_uint_32)new_max);
      if (png_ptr->save_buffer == NULL)
      {
        png_free(png_ptr, old_buffer);
        png_error(png_ptr, "Insufficient memory for save_buffer");
      }
      else
      {
        if (old_buffer)
          png_memcpy(png_ptr->save_buffer, old_buffer,
             png_ptr->save_buffer_size);
        else if (png_ptr->save_buffer_size)
          png_error(png_ptr, "save_buffer error");
        png_free(png_ptr, old_buffer);
        png_ptr->save_buffer_max = new_max;
      }
   }
   if (png_ptr->current_buffer_size)
   {
      png_memcpy(png_ptr->save_buffer + png_ptr->save_buffer_size,
         png_ptr->current_buffer_ptr, png_ptr->current_buffer_size);
      png_ptr->save_buffer_size += png_ptr->current_buffer_size;
      png_ptr->current_buffer_size = 0;
   }
   png_ptr->save_buffer_ptr = png_ptr->save_buffer;
   png_ptr->buffer_size = 0;
}

void /* PRIVATE */
png_push_restore_buffer(png_structp png_ptr, png_bytep buffer,
   png_size_t buffer_length)
{
   png_ptr->current_buffer = buffer;
   png_ptr->current_buffer_size = buffer_length;
   png_ptr->buffer_size = buffer_length + png_ptr->save_buffer_size;
   png_ptr->current_buffer_ptr = png_ptr->current_buffer;
}

void /* PRIVATE */
png_push_read_IDAT(png_structp png_ptr)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_CONST PNG_IDAT;
#endif
   if (!(png_ptr->mode & PNG_HAVE_CHUNK_HEADER))
   {
      png_byte chunk_length[4];

      if (png_ptr->buffer_size < 8)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_push_fill_buffer(png_ptr, chunk_length, 4);
      png_ptr->push_length = png_get_uint_31(png_ptr, chunk_length);
      png_reset_crc(png_ptr);
      png_crc_read(png_ptr, png_ptr->chunk_name, 4);
      png_ptr->mode |= PNG_HAVE_CHUNK_HEADER;

      if (png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
      {
         png_ptr->process_mode = PNG_READ_CHUNK_MODE;
         if (!(png_ptr->flags & PNG_FLAG_ZLIB_FINISHED))
            png_error(png_ptr, "Not enough compressed data");
         return;
      }

      png_ptr->idat_size = png_ptr->push_length;
   }
   if (png_ptr->idat_size && png_ptr->save_buffer_size)
   {
      png_size_t save_size;

      if (png_ptr->idat_size < (png_uint_32)png_ptr->save_buffer_size)
      {
         save_size = (png_size_t)png_ptr->idat_size;

         /* Check for overflow */
         if ((png_uint_32)save_size != png_ptr->idat_size)
            png_error(png_ptr, "save_size overflowed in pngpread");
      }
      else
         save_size = png_ptr->save_buffer_size;

      png_calculate_crc(png_ptr, png_ptr->save_buffer_ptr, save_size);

      png_process_IDAT_data(png_ptr, png_ptr->save_buffer_ptr, save_size);

      png_ptr->idat_size -= save_size;
      png_ptr->buffer_size -= save_size;
      png_ptr->save_buffer_size -= save_size;
      png_ptr->save_buffer_ptr += save_size;
   }
   if (png_ptr->idat_size && png_ptr->current_buffer_size)
   {
      png_size_t save_size;

      if (png_ptr->idat_size < (png_uint_32)png_ptr->current_buffer_size)
      {
         save_size = (png_size_t)png_ptr->idat_size;

         /* Check for overflow */
         if ((png_uint_32)save_size != png_ptr->idat_size)
            png_error(png_ptr, "save_size overflowed in pngpread");
      }
      else
         save_size = png_ptr->current_buffer_size;

      png_calculate_crc(png_ptr, png_ptr->current_buffer_ptr, save_size);

      png_process_IDAT_data(png_ptr, png_ptr->current_buffer_ptr, save_size);

      png_ptr->idat_size -= save_size;
      png_ptr->buffer_size -= save_size;
      png_ptr->current_buffer_size -= save_size;
      png_ptr->current_buffer_ptr += save_size;
   }
   if (!png_ptr->idat_size)
   {
      if (png_ptr->buffer_size < 4)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_crc_finish(png_ptr, 0);
      png_ptr->mode &= ~PNG_HAVE_CHUNK_HEADER;
      png_ptr->mode |= PNG_AFTER_IDAT;
   }
}

void /* PRIVATE */
png_process_IDAT_data(png_structp png_ptr, png_bytep buffer,
   png_size_t buffer_length)
{
   /* The caller checks for a non-zero buffer length. */
   if (!(buffer_length > 0) || buffer == NULL)
      png_error(png_ptr, "No IDAT data (internal error)");

   /* This routine must process all the data it has been given
    * before returning, calling the row callback as required to
    * handle the uncompressed results.
    */
   png_ptr->zstream.next_in = buffer;
   png_ptr->zstream.avail_in = (uInt)buffer_length;

   /* Keep going until the decompressed data is all processed
    * or the stream marked as finished.
    */
   while (png_ptr->zstream.avail_in > 0 &&
	  !(png_ptr->flags & PNG_FLAG_ZLIB_FINISHED))
   {
      int ret;

      /* We have data for zlib, but we must check that zlib
       * has somewhere to put the results.  It doesn't matter
       * if we don't expect any results -- it may be the input
       * data is just the LZ end code.
       */
      if (!(png_ptr->zstream.avail_out > 0))
      {
         png_ptr->zstream.avail_out =
             (uInt) PNG_ROWBYTES(png_ptr->pixel_depth,
             png_ptr->iwidth) + 1;
         png_ptr->zstream.next_out = png_ptr->row_buf;
      }

      /* Using Z_SYNC_FLUSH here means that an unterminated
       * LZ stream can still be handled (a stream with a missing
       * end code), otherwise (Z_NO_FLUSH) a future zlib
       * implementation might defer output and, therefore,
       * change the current behavior.  (See comments in inflate.c
       * for why this doesn't happen at present with zlib 1.2.5.)
       */
      ret = inflate(&png_ptr->zstream, Z_SYNC_FLUSH);

      /* Check for any failure before proceeding. */
      if (ret != Z_OK && ret != Z_STREAM_END)
      {
	 /* Terminate the decompression. */
	 png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;

         /* This may be a truncated stream (missing or
	  * damaged end code).  Treat that as a warning.
	  */
         if (png_ptr->row_number >= png_ptr->num_rows ||
	     png_ptr->pass > 6)
	    png_warning(png_ptr, "Truncated compressed data in IDAT");
	 else
	    png_error(png_ptr, "Decompression error in IDAT");

	 /* Skip the check on unprocessed input */
         return;
      }

      /* Did inflate output any data? */
      if (png_ptr->zstream.next_out != png_ptr->row_buf)
      {
	 /* Is this unexpected data after the last row?
	  * If it is, artificially terminate the LZ output
	  * here.
	  */
         if (png_ptr->row_number >= png_ptr->num_rows ||
	     png_ptr->pass > 6)
         {
	    /* Extra data. */
	    png_warning(png_ptr, "Extra compressed data in IDAT");
            png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
	    /* Do no more processing; skip the unprocessed
	     * input check below.
	     */
            return;
	 }

	 /* Do we have a complete row? */
	 if (png_ptr->zstream.avail_out == 0)
	    png_push_process_row(png_ptr);
      }

      /* And check for the end of the stream. */
      if (ret == Z_STREAM_END)
	 png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
   }

   /* All the data should have been processed, if anything
    * is left at this point we have bytes of IDAT data
    * after the zlib end code.
    */
   if (png_ptr->zstream.avail_in > 0)
      png_warning(png_ptr, "Extra compression data");
}

void /* PRIVATE */
png_push_process_row(png_structp png_ptr)
{
   png_ptr->row_info.color_type = png_ptr->color_type;
   png_ptr->row_info.width = png_ptr->iwidth;
   png_ptr->row_info.channels = png_ptr->channels;
   png_ptr->row_info.bit_depth = png_ptr->bit_depth;
   png_ptr->row_info.pixel_depth = png_ptr->pixel_depth;

   png_ptr->row_info.rowbytes = PNG_ROWBYTES(png_ptr->row_info.pixel_depth,
       png_ptr->row_info.width);

   png_read_filter_row(png_ptr, &(png_ptr->row_info),
       png_ptr->row_buf + 1, png_ptr->prev_row + 1,
       (int)(png_ptr->row_buf[0]));

   png_memcpy_check(png_ptr, png_ptr->prev_row, png_ptr->row_buf,
      png_ptr->rowbytes + 1);

   if (png_ptr->transformations || (png_ptr->flags&PNG_FLAG_STRIP_ALPHA))
      png_do_read_transformations(png_ptr);

#ifdef PNG_READ_INTERLACING_SUPPORTED
   /* Blow up interlaced rows to full size */
   if (png_ptr->interlaced && (png_ptr->transformations & PNG_INTERLACE))
   {
      if (png_ptr->pass < 6)
/*       old interface (pre-1.0.9):
         png_do_read_interlace(&(png_ptr->row_info),
             png_ptr->row_buf + 1, png_ptr->pass, png_ptr->transformations);
 */
         png_do_read_interlace(png_ptr);

    switch (png_ptr->pass)
    {
         case 0:
         {
            int i;
            for (i = 0; i < 8 && png_ptr->pass == 0; i++)
            {
               png_push_have_row(png_ptr, png_ptr->row_buf + 1);
               png_read_push_finish_row(png_ptr); /* Updates png_ptr->pass */
            }

            if (png_ptr->pass == 2) /* Pass 1 might be empty */
            {
               for (i = 0; i < 4 && png_ptr->pass == 2; i++)
               {
                  png_push_have_row(png_ptr, png_bytep_NULL);
                  png_read_push_finish_row(png_ptr);
               }
            }

            if (png_ptr->pass == 4 && png_ptr->height <= 4)
            {
               for (i = 0; i < 2 && png_ptr->pass == 4; i++)
               {
                  png_push_have_row(png_ptr, png_bytep_NULL);
                  png_read_push_finish_row(png_ptr);
               }
            }

            if (png_ptr->pass == 6 && png_ptr->height <= 4)
            {
                  png_push_have_row(png_ptr, png_bytep_NULL);
                png_read_push_finish_row(png_ptr);
            }

            break;
         }

         case 1:
         {
            int i;
            for (i = 0; i < 8 && png_ptr->pass == 1; i++)
            {
               png_push_have_row(png_ptr, png_ptr->row_buf + 1);
               png_read_push_finish_row(png_ptr);
            }

            if (png_ptr->pass == 2) /* Skip top 4 generated rows */
            {
               for (i = 0; i < 4 && png_ptr->pass == 2; i++)
               {
                  png_push_have_row(png_ptr, png_bytep_NULL);
                  png_read_push_finish_row(png_ptr);
               }
            }

            break;
         }

         case 2:
         {
            int i;

            for (i = 0; i < 4 && png_ptr->pass == 2; i++)
            {
               png_push_have_row(png_ptr, png_ptr->row_buf + 1);
               png_read_push_finish_row(png_ptr);
            }

            for (i = 0; i < 4 && png_ptr->pass == 2; i++)
            {
                  png_push_have_row(png_ptr, png_bytep_NULL);
               png_read_push_finish_row(png_ptr);
            }

            if (png_ptr->pass == 4) /* Pass 3 might be empty */
            {
               for (i = 0; i < 2 && png_ptr->pass == 4; i++)
               {
                  png_push_have_row(png_ptr, png_bytep_NULL);
                  png_read_push_finish_row(png_ptr);
               }
            }

            break;
         }

         case 3:
         {
            int i;

            for (i = 0; i < 4 && png_ptr->pass == 3; i++)
            {
               png_push_have_row(png_ptr, png_ptr->row_buf + 1);
               png_read_push_finish_row(png_ptr);
            }

            if (png_ptr->pass == 4) /* Skip top two generated rows */
            {
               for (i = 0; i < 2 && png_ptr->pass == 4; i++)
               {
                  png_push_have_row(png_ptr, png_bytep_NULL);
                  png_read_push_finish_row(png_ptr);
               }
            }

            break;
         }

         case 4:
         {
            int i;

            for (i = 0; i < 2 && png_ptr->pass == 4; i++)
            {
               png_push_have_row(png_ptr, png_ptr->row_buf + 1);
               png_read_push_finish_row(png_ptr);
            }

            for (i = 0; i < 2 && png_ptr->pass == 4; i++)
            {
                  png_push_have_row(png_ptr, png_bytep_NULL);
               png_read_push_finish_row(png_ptr);
            }

            if (png_ptr->pass == 6) /* Pass 5 might be empty */
            {
                  png_push_have_row(png_ptr, png_bytep_NULL);
               png_read_push_finish_row(png_ptr);
            }

            break;
         }

         case 5:
         {
            int i;

            for (i = 0; i < 2 && png_ptr->pass == 5; i++)
            {
               png_push_have_row(png_ptr, png_ptr->row_buf + 1);
               png_read_push_finish_row(png_ptr);
            }

            if (png_ptr->pass == 6) /* Skip top generated row */
            {
                  png_push_have_row(png_ptr, png_bytep_NULL);
               png_read_push_finish_row(png_ptr);
            }

            break;
         }
         case 6:
         {
            png_push_have_row(png_ptr, png_ptr->row_buf + 1);
            png_read_push_finish_row(png_ptr);

            if (png_ptr->pass != 6)
               break;

                  png_push_have_row(png_ptr, png_bytep_NULL);
            png_read_push_finish_row(png_ptr);
         }
      }
   }
   else
#endif
   {
      png_push_have_row(png_ptr, png_ptr->row_buf + 1);
      png_read_push_finish_row(png_ptr);
   }
}

void /* PRIVATE */
png_read_push_finish_row(png_structp png_ptr)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */

   /* Start of interlace block */
   PNG_CONST int FARDATA png_pass_start[] = {0, 4, 0, 2, 0, 1, 0};

   /* Offset to next interlace block */
   PNG_CONST int FARDATA png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1};

   /* Start of interlace block in the y direction */
   PNG_CONST int FARDATA png_pass_ystart[] = {0, 0, 4, 0, 2, 0, 1};

   /* Offset to next interlace block in the y direction */
   PNG_CONST int FARDATA png_pass_yinc[] = {8, 8, 8, 4, 4, 2, 2};

   /* Height of interlace block.  This is not currently used - if you need
    * it, uncomment it here and in png.h
   PNG_CONST int FARDATA png_pass_height[] = {8, 8, 4, 4, 2, 2, 1};
   */
#endif

   png_ptr->row_number++;
   if (png_ptr->row_number < png_ptr->num_rows)
      return;

#ifdef PNG_READ_INTERLACING_SUPPORTED
   if (png_ptr->interlaced)
   {
      png_ptr->row_number = 0;
      png_memset_check(png_ptr, png_ptr->prev_row, 0,
         png_ptr->rowbytes + 1);
      do
      {
         png_ptr->pass++;
         if ((png_ptr->pass == 1 && png_ptr->width < 5) ||
             (png_ptr->pass == 3 && png_ptr->width < 3) ||
             (png_ptr->pass == 5 && png_ptr->width < 2))
           png_ptr->pass++;

         if (png_ptr->pass > 7)
            png_ptr->pass--;

         if (png_ptr->pass >= 7)
            break;

         png_ptr->iwidth = (png_ptr->width +
            png_pass_inc[png_ptr->pass] - 1 -
            png_pass_start[png_ptr->pass]) /
            png_pass_inc[png_ptr->pass];

         if (png_ptr->transformations & PNG_INTERLACE)
            break;

         png_ptr->num_rows = (png_ptr->height +
            png_pass_yinc[png_ptr->pass] - 1 -
            png_pass_ystart[png_ptr->pass]) /
            png_pass_yinc[png_ptr->pass];

      } while (png_ptr->iwidth == 0 || png_ptr->num_rows == 0);
   }
#endif /* PNG_READ_INTERLACING_SUPPORTED */
}

void /* PRIVATE */
png_push_have_info(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr->info_fn != NULL)
      (*(png_ptr->info_fn))(png_ptr, info_ptr);
}

void /* PRIVATE */
png_push_have_end(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr->end_fn != NULL)
      (*(png_ptr->end_fn))(png_ptr, info_ptr);
}

void /* PRIVATE */
png_push_have_row(png_structp png_ptr, png_bytep row)
{
   if (png_ptr->row_fn != NULL)
      (*(png_ptr->row_fn))(png_ptr, row, png_ptr->row_number,
         (int)png_ptr->pass);
}

void PNGAPI
png_progressive_combine_row (png_structp png_ptr,
   png_bytep old_row, png_bytep new_row)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_CONST int FARDATA png_pass_dsp_mask[7] =
      {0xff, 0x0f, 0xff, 0x33, 0xff, 0x55, 0xff};
#endif

   if (png_ptr == NULL)
      return;

   if (new_row != NULL)    /* new_row must == png_ptr->row_buf here. */
      png_combine_row(png_ptr, old_row, png_pass_dsp_mask[png_ptr->pass]);
}

void PNGAPI
png_set_progressive_read_fn(png_structp png_ptr, png_voidp progressive_ptr,
   png_progressive_info_ptr info_fn, png_progressive_row_ptr row_fn,
   png_progressive_end_ptr end_fn)
{
   if (png_ptr == NULL)
      return;

   png_ptr->info_fn = info_fn;
   png_ptr->row_fn = row_fn;
   png_ptr->end_fn = end_fn;

   png_set_read_fn(png_ptr, progressive_ptr, png_push_fill_buffer);
}

png_voidp PNGAPI
png_get_progressive_ptr(png_structp png_ptr)
{
   if (png_ptr == NULL)
      return (NULL);

   return png_ptr->io_ptr;
}
#endif /* PNG_PROGRESSIVE_READ_SUPPORTED */
@


1.9
log
@merge, rebase/minify, fix
@
text
@d4 2
a5 2
 * Last changed in libpng 1.2.44 [June 26, 2010]
 * Copyright (c) 1998-2010 Glenn Randers-Pehrson
d688 10
a697 3
      png_memcpy(png_ptr->save_buffer, old_buffer, png_ptr->save_buffer_size);
      png_free(png_ptr, old_buffer);
      png_ptr->save_buffer_max = new_max;
@


1.8
log
@merge libpng upgrade

major version bump because function signature of png_decompress_chunk
changed (return value to void)
@
text
@d4 2
a5 3
 * Last changed in libpng 1.2.32 [September 18, 2008]
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1998-2008 Glenn Randers-Pehrson
d8 4
d15 1
d19 1
a19 1
/* push model modes */
d34 3
a36 1
   if (png_ptr == NULL || info_ptr == NULL) return;
d51 3
a53 1
   if (png_ptr == NULL) return;
d61 1
d67 1
d73 1
a73 21
#if defined(PNG_READ_tEXt_SUPPORTED)
      case PNG_READ_tEXt_MODE:
      {
         png_push_read_tEXt(png_ptr, info_ptr);
         break;
      }
#endif
#if defined(PNG_READ_zTXt_SUPPORTED)
      case PNG_READ_zTXt_MODE:
      {
         png_push_read_zTXt(png_ptr, info_ptr);
         break;
      }
#endif
#if defined(PNG_READ_iTXt_SUPPORTED)
      case PNG_READ_iTXt_MODE:
      {
         png_push_read_iTXt(png_ptr, info_ptr);
         break;
      }
#endif
d79 1
d130 6
a135 6
      const PNG_IHDR;
      const PNG_IDAT;
      const PNG_IEND;
      const PNG_PLTE;
#if defined(PNG_READ_bKGD_SUPPORTED)
      const PNG_bKGD;
d137 2
a138 2
#if defined(PNG_READ_cHRM_SUPPORTED)
      const PNG_cHRM;
d140 2
a141 2
#if defined(PNG_READ_gAMA_SUPPORTED)
      const PNG_gAMA;
d143 2
a144 2
#if defined(PNG_READ_hIST_SUPPORTED)
      const PNG_hIST;
d146 2
a147 2
#if defined(PNG_READ_iCCP_SUPPORTED)
      const PNG_iCCP;
d149 2
a150 2
#if defined(PNG_READ_iTXt_SUPPORTED)
      const PNG_iTXt;
d152 2
a153 2
#if defined(PNG_READ_oFFs_SUPPORTED)
      const PNG_oFFs;
d155 2
a156 2
#if defined(PNG_READ_pCAL_SUPPORTED)
      const PNG_pCAL;
d158 2
a159 2
#if defined(PNG_READ_pHYs_SUPPORTED)
      const PNG_pHYs;
d161 2
a162 2
#if defined(PNG_READ_sBIT_SUPPORTED)
      const PNG_sBIT;
d164 2
a165 2
#if defined(PNG_READ_sCAL_SUPPORTED)
      const PNG_sCAL;
d167 2
a168 2
#if defined(PNG_READ_sRGB_SUPPORTED)
      const PNG_sRGB;
d170 2
a171 2
#if defined(PNG_READ_sPLT_SUPPORTED)
      const PNG_sPLT;
d173 2
a174 2
#if defined(PNG_READ_tEXt_SUPPORTED)
      const PNG_tEXt;
d176 2
a177 2
#if defined(PNG_READ_tIME_SUPPORTED)
      const PNG_tIME;
d179 2
a180 2
#if defined(PNG_READ_tRNS_SUPPORTED)
      const PNG_tRNS;
d182 2
a183 2
#if defined(PNG_READ_zTXt_SUPPORTED)
      const PNG_zTXt;
d186 1
d219 1
d225 1
d228 1
d236 1
d242 1
d251 1
d254 1
d256 1
d259 1
d264 1
d270 1
d281 1
d288 7
a294 5
     if (!(png_ptr->mode & PNG_HAVE_IHDR))
       png_error(png_ptr, "Missing IHDR before IDAT");
     else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
         !(png_ptr->mode & PNG_HAVE_PLTE))
       png_error(png_ptr, "Missing PLTE before IDAT");
d299 2
a300 2
           if (png_ptr->push_length == 0)
              return;
d310 3
a312 1
      png_ptr->zstream.avail_out = (uInt)png_ptr->irowbytes;
d316 2
a317 1
#if defined(PNG_READ_gAMA_SUPPORTED)
d325 1
d328 1
d330 1
a330 1
#if defined(PNG_READ_sBIT_SUPPORTED)
d338 1
d341 1
d343 1
a343 1
#if defined(PNG_READ_cHRM_SUPPORTED)
d351 1
d354 1
d356 1
a356 1
#if defined(PNG_READ_sRGB_SUPPORTED)
d364 1
d367 1
d369 1
a369 1
#if defined(PNG_READ_iCCP_SUPPORTED)
d377 1
d380 1
d382 1
a382 1
#if defined(PNG_READ_sPLT_SUPPORTED)
d390 1
d393 1
d395 1
a395 1
#if defined(PNG_READ_tRNS_SUPPORTED)
d403 1
d406 1
d408 1
a408 1
#if defined(PNG_READ_bKGD_SUPPORTED)
d416 1
d419 1
d421 1
a421 1
#if defined(PNG_READ_hIST_SUPPORTED)
d429 1
d432 1
d434 1
a434 1
#if defined(PNG_READ_pHYs_SUPPORTED)
d442 1
d445 1
d447 1
a447 1
#if defined(PNG_READ_oFFs_SUPPORTED)
d455 1
d459 2
a460 1
#if defined(PNG_READ_pCAL_SUPPORTED)
d468 1
d471 1
d473 1
a473 1
#if defined(PNG_READ_sCAL_SUPPORTED)
d481 1
d484 1
d486 1
a486 1
#if defined(PNG_READ_tIME_SUPPORTED)
d494 1
d497 1
d499 1
a499 1
#if defined(PNG_READ_tEXt_SUPPORTED)
d507 2
a508 1
      png_push_handle_tEXt(png_ptr, info_ptr, png_ptr->push_length);
d510 1
d512 1
a512 1
#if defined(PNG_READ_zTXt_SUPPORTED)
d520 2
a521 1
      png_push_handle_zTXt(png_ptr, info_ptr, png_ptr->push_length);
d523 1
d525 1
a525 1
#if defined(PNG_READ_iTXt_SUPPORTED)
d533 2
a534 1
      png_push_handle_iTXt(png_ptr, info_ptr, png_ptr->push_length);
d536 1
d545 1
a545 1
      png_push_handle_unknown(png_ptr, info_ptr, png_ptr->push_length);
d611 3
a613 1
   if (png_ptr == NULL) return;
d637 1
d678 1
d681 1
a681 1
      png_ptr->save_buffer = (png_bytep)png_malloc(png_ptr,
d683 5
d717 1
a717 1
   const PNG_IDAT;
d752 2
a753 1
         /* check for overflow */
d761 3
a763 2
      if (!(png_ptr->flags & PNG_FLAG_ZLIB_FINISHED))
         png_process_IDAT_data(png_ptr, png_ptr->save_buffer_ptr, save_size);
d776 2
a777 1
         /* check for overflow */
d785 2
a786 2
      if (!(png_ptr->flags & PNG_FLAG_ZLIB_FINISHED))
        png_process_IDAT_data(png_ptr, png_ptr->current_buffer_ptr, save_size);
d811 8
a818 5
   int ret;

   if ((png_ptr->flags & PNG_FLAG_ZLIB_FINISHED) && buffer_length)
      png_error(png_ptr, "Extra compression data");

d821 6
a826 1
   for (;;)
d828 8
a835 2
      ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);
      if (ret != Z_OK)
d837 29
a865 8
         if (ret == Z_STREAM_END)
         {
            if (png_ptr->zstream.avail_in)
               png_error(png_ptr, "Extra compressed data");
            if (!(png_ptr->zstream.avail_out))
            {
               png_push_process_row(png_ptr);
            }
d867 2
a868 8
            png_ptr->mode |= PNG_AFTER_IDAT;
            png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
            break;
         }
         else if (ret == Z_BUF_ERROR)
            break;
         else
            png_error(png_ptr, "Decompression Error");
d870 3
a872 1
      if (!(png_ptr->zstream.avail_out))
d874 6
a879 6
         if ((
#if defined(PNG_READ_INTERLACING_SUPPORTED)
             png_ptr->interlaced && png_ptr->pass > 6) ||
             (!png_ptr->interlaced &&
#endif
             png_ptr->row_number == png_ptr->num_rows))
d881 12
a892 8
           if (png_ptr->zstream.avail_in)
             png_warning(png_ptr, "Too much data in IDAT chunks");
           png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
           break;
         }
         png_push_process_row(png_ptr);
         png_ptr->zstream.avail_out = (uInt)png_ptr->irowbytes;
         png_ptr->zstream.next_out = png_ptr->row_buf;
d894 4
a897 2
      else
         break;
d899 7
d921 2
a922 2
      png_ptr->row_buf + 1, png_ptr->prev_row + 1,
      (int)(png_ptr->row_buf[0]));
d930 2
a931 2
#if defined(PNG_READ_INTERLACING_SUPPORTED)
   /* blow up interlaced rows to full size */
d937 1
a937 1
            png_ptr->row_buf + 1, png_ptr->pass, png_ptr->transformations);
d949 1
a949 1
               png_read_push_finish_row(png_ptr); /* updates png_ptr->pass */
d951 2
a952 1
            if (png_ptr->pass == 2) /* pass 1 might be empty */
d960 1
d969 1
d972 1
a972 1
                png_push_have_row(png_ptr, png_bytep_NULL);
d975 1
d978 1
d987 2
a988 1
            if (png_ptr->pass == 2) /* skip top 4 generated rows */
d996 1
d999 1
d1003 1
d1009 1
d1012 1
a1012 1
               png_push_have_row(png_ptr, png_bytep_NULL);
d1015 2
a1016 1
            if (png_ptr->pass == 4) /* pass 3 might be empty */
d1024 1
d1027 1
d1031 1
d1037 2
a1038 1
            if (png_ptr->pass == 4) /* skip top two generated rows */
d1046 1
d1049 1
d1053 1
d1059 1
d1062 1
a1062 1
               png_push_have_row(png_ptr, png_bytep_NULL);
d1065 2
a1066 1
            if (png_ptr->pass == 6) /* pass 5 might be empty */
d1068 1
a1068 1
               png_push_have_row(png_ptr, png_bytep_NULL);
d1071 1
d1074 1
d1078 1
d1084 2
a1085 1
            if (png_ptr->pass == 6) /* skip top generated row */
d1087 1
a1087 1
               png_push_have_row(png_ptr, png_bytep_NULL);
d1090 1
d1097 1
d1100 2
a1101 1
            png_push_have_row(png_ptr, png_bytep_NULL);
d1118 1
a1118 1
   /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */
d1120 2
a1121 2
   /* start of interlace block */
   const int png_pass_start[] = {0, 4, 0, 2, 0, 1, 0};
d1123 2
a1124 2
   /* offset to next interlace block */
   const int png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1};
d1126 2
a1127 2
   /* start of interlace block in the y direction */
   const int png_pass_ystart[] = {0, 0, 4, 0, 2, 0, 1};
d1129 2
a1130 2
   /* offset to next interlace block in the y direction */
   const int png_pass_yinc[] = {8, 8, 8, 4, 4, 2, 2};
d1134 1
a1134 1
   const int png_pass_height[] = {8, 8, 4, 4, 2, 2, 1};
d1142 1
d1158 1
a1166 3
         png_ptr->irowbytes = PNG_ROWBYTES(png_ptr->pixel_depth,
            png_ptr->iwidth) + 1;

d1177 1
a1177 486
}

#if defined(PNG_READ_tEXt_SUPPORTED)
void /* PRIVATE */
png_push_handle_tEXt(png_structp png_ptr, png_infop info_ptr, png_uint_32
   length)
{
   if (!(png_ptr->mode & PNG_HAVE_IHDR) || (png_ptr->mode & PNG_HAVE_IEND))
      {
         png_error(png_ptr, "Out of place tEXt");
         info_ptr = info_ptr; /* to quiet some compiler warnings */
      }

#ifdef PNG_MAX_MALLOC_64K
   png_ptr->skip_length = 0;  /* This may not be necessary */

   if (length > (png_uint_32)65535L) /* Can't hold entire string in memory */
   {
      png_warning(png_ptr, "tEXt chunk too large to fit in memory");
      png_ptr->skip_length = length - (png_uint_32)65535L;
      length = (png_uint_32)65535L;
   }
#endif

   png_ptr->current_text = (png_charp)png_malloc(png_ptr,
      (png_uint_32)(length + 1));
   png_ptr->current_text[length] = '\0';
   png_ptr->current_text_ptr = png_ptr->current_text;
   png_ptr->current_text_size = (png_size_t)length;
   png_ptr->current_text_left = (png_size_t)length;
   png_ptr->process_mode = PNG_READ_tEXt_MODE;
}

void /* PRIVATE */
png_push_read_tEXt(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr->buffer_size && png_ptr->current_text_left)
   {
      png_size_t text_size;

      if (png_ptr->buffer_size < png_ptr->current_text_left)
         text_size = png_ptr->buffer_size;
      else
         text_size = png_ptr->current_text_left;
      png_crc_read(png_ptr, (png_bytep)png_ptr->current_text_ptr, text_size);
      png_ptr->current_text_left -= text_size;
      png_ptr->current_text_ptr += text_size;
   }
   if (!(png_ptr->current_text_left))
   {
      png_textp text_ptr;
      png_charp text;
      png_charp key;
      int ret;

      if (png_ptr->buffer_size < 4)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_push_crc_finish(png_ptr);

#if defined(PNG_MAX_MALLOC_64K)
      if (png_ptr->skip_length)
         return;
#endif

      key = png_ptr->current_text;

      for (text = key; *text; text++)
         /* empty loop */ ;

      if (text < key + png_ptr->current_text_size)
         text++;

      text_ptr = (png_textp)png_malloc(png_ptr,
         (png_uint_32)png_sizeof(png_text));
      text_ptr->compression = PNG_TEXT_COMPRESSION_NONE;
      text_ptr->key = key;
#ifdef PNG_iTXt_SUPPORTED
      text_ptr->lang = NULL;
      text_ptr->lang_key = NULL;
#endif
      text_ptr->text = text;

      ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);

      png_free(png_ptr, key);
      png_free(png_ptr, text_ptr);
      png_ptr->current_text = NULL;

      if (ret)
        png_warning(png_ptr, "Insufficient memory to store text chunk.");
   }
}
#endif

#if defined(PNG_READ_zTXt_SUPPORTED)
void /* PRIVATE */
png_push_handle_zTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32
   length)
{
   if (!(png_ptr->mode & PNG_HAVE_IHDR) || (png_ptr->mode & PNG_HAVE_IEND))
      {
         png_error(png_ptr, "Out of place zTXt");
         info_ptr = info_ptr; /* to quiet some compiler warnings */
      }

#ifdef PNG_MAX_MALLOC_64K
   /* We can't handle zTXt chunks > 64K, since we don't have enough space
    * to be able to store the uncompressed data.  Actually, the threshold
    * is probably around 32K, but it isn't as definite as 64K is.
    */
   if (length > (png_uint_32)65535L)
   {
      png_warning(png_ptr, "zTXt chunk too large to fit in memory");
      png_push_crc_skip(png_ptr, length);
      return;
   }
#endif

   png_ptr->current_text = (png_charp)png_malloc(png_ptr,
      (png_uint_32)(length + 1));
   png_ptr->current_text[length] = '\0';
   png_ptr->current_text_ptr = png_ptr->current_text;
   png_ptr->current_text_size = (png_size_t)length;
   png_ptr->current_text_left = (png_size_t)length;
   png_ptr->process_mode = PNG_READ_zTXt_MODE;
}

void /* PRIVATE */
png_push_read_zTXt(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr->buffer_size && png_ptr->current_text_left)
   {
      png_size_t text_size;

      if (png_ptr->buffer_size < (png_uint_32)png_ptr->current_text_left)
         text_size = png_ptr->buffer_size;
      else
         text_size = png_ptr->current_text_left;
      png_crc_read(png_ptr, (png_bytep)png_ptr->current_text_ptr, text_size);
      png_ptr->current_text_left -= text_size;
      png_ptr->current_text_ptr += text_size;
   }
   if (!(png_ptr->current_text_left))
   {
      png_textp text_ptr;
      png_charp text;
      png_charp key;
      int ret;
      png_size_t text_size, key_size;

      if (png_ptr->buffer_size < 4)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_push_crc_finish(png_ptr);

      key = png_ptr->current_text;

      for (text = key; *text; text++)
         /* empty loop */ ;

      /* zTXt can't have zero text */
      if (text >= key + png_ptr->current_text_size)
      {
         png_ptr->current_text = NULL;
         png_free(png_ptr, key);
         return;
      }

      text++;

      if (*text != PNG_TEXT_COMPRESSION_zTXt) /* check compression byte */
      {
         png_ptr->current_text = NULL;
         png_free(png_ptr, key);
         return;
      }

      text++;

      png_ptr->zstream.next_in = (png_bytep )text;
      png_ptr->zstream.avail_in = (uInt)(png_ptr->current_text_size -
         (text - key));
      png_ptr->zstream.next_out = png_ptr->zbuf;
      png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;

      key_size = text - key;
      text_size = 0;
      text = NULL;
      ret = Z_STREAM_END;

      while (png_ptr->zstream.avail_in)
      {
         ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);
         if (ret != Z_OK && ret != Z_STREAM_END)
         {
            inflateReset(&png_ptr->zstream);
            png_ptr->zstream.avail_in = 0;
            png_ptr->current_text = NULL;
            png_free(png_ptr, key);
            png_free(png_ptr, text);
            return;
         }
         if (!(png_ptr->zstream.avail_out) || ret == Z_STREAM_END)
         {
            if (text == NULL)
            {
               text = (png_charp)png_malloc(png_ptr,
                     (png_uint_32)(png_ptr->zbuf_size
                     - png_ptr->zstream.avail_out + key_size + 1));
               png_memcpy(text + key_size, png_ptr->zbuf,
                  png_ptr->zbuf_size - png_ptr->zstream.avail_out);
               png_memcpy(text, key, key_size);
               text_size = key_size + png_ptr->zbuf_size -
                  png_ptr->zstream.avail_out;
               *(text + text_size) = '\0';
            }
            else
            {
               png_charp tmp;

               tmp = text;
               text = (png_charp)png_malloc(png_ptr, text_size +
                  (png_uint_32)(png_ptr->zbuf_size 
                  - png_ptr->zstream.avail_out + 1));
               png_memcpy(text, tmp, text_size);
               png_free(png_ptr, tmp);
               png_memcpy(text + text_size, png_ptr->zbuf,
                  png_ptr->zbuf_size - png_ptr->zstream.avail_out);
               text_size += png_ptr->zbuf_size - png_ptr->zstream.avail_out;
               *(text + text_size) = '\0';
            }
            if (ret != Z_STREAM_END)
            {
               png_ptr->zstream.next_out = png_ptr->zbuf;
               png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
            }
         }
         else
         {
            break;
         }

         if (ret == Z_STREAM_END)
            break;
      }

      inflateReset(&png_ptr->zstream);
      png_ptr->zstream.avail_in = 0;

      if (ret != Z_STREAM_END)
      {
         png_ptr->current_text = NULL;
         png_free(png_ptr, key);
         png_free(png_ptr, text);
         return;
      }

      png_ptr->current_text = NULL;
      png_free(png_ptr, key);
      key = text;
      text += key_size;

      text_ptr = (png_textp)png_malloc(png_ptr,
          (png_uint_32)png_sizeof(png_text));
      text_ptr->compression = PNG_TEXT_COMPRESSION_zTXt;
      text_ptr->key = key;
#ifdef PNG_iTXt_SUPPORTED
      text_ptr->lang = NULL;
      text_ptr->lang_key = NULL;
#endif
      text_ptr->text = text;

      ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);

      png_free(png_ptr, key);
      png_free(png_ptr, text_ptr);

      if (ret)
        png_warning(png_ptr, "Insufficient memory to store text chunk.");
   }
}
#endif

#if defined(PNG_READ_iTXt_SUPPORTED)
void /* PRIVATE */
png_push_handle_iTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32
   length)
{
   if (!(png_ptr->mode & PNG_HAVE_IHDR) || (png_ptr->mode & PNG_HAVE_IEND))
      {
         png_error(png_ptr, "Out of place iTXt");
         info_ptr = info_ptr; /* to quiet some compiler warnings */
      }

#ifdef PNG_MAX_MALLOC_64K
   png_ptr->skip_length = 0;  /* This may not be necessary */

   if (length > (png_uint_32)65535L) /* Can't hold entire string in memory */
   {
      png_warning(png_ptr, "iTXt chunk too large to fit in memory");
      png_ptr->skip_length = length - (png_uint_32)65535L;
      length = (png_uint_32)65535L;
   }
#endif

   png_ptr->current_text = (png_charp)png_malloc(png_ptr,
      (png_uint_32)(length + 1));
   png_ptr->current_text[length] = '\0';
   png_ptr->current_text_ptr = png_ptr->current_text;
   png_ptr->current_text_size = (png_size_t)length;
   png_ptr->current_text_left = (png_size_t)length;
   png_ptr->process_mode = PNG_READ_iTXt_MODE;
}

void /* PRIVATE */
png_push_read_iTXt(png_structp png_ptr, png_infop info_ptr)
{

   if (png_ptr->buffer_size && png_ptr->current_text_left)
   {
      png_size_t text_size;

      if (png_ptr->buffer_size < png_ptr->current_text_left)
         text_size = png_ptr->buffer_size;
      else
         text_size = png_ptr->current_text_left;
      png_crc_read(png_ptr, (png_bytep)png_ptr->current_text_ptr, text_size);
      png_ptr->current_text_left -= text_size;
      png_ptr->current_text_ptr += text_size;
   }
   if (!(png_ptr->current_text_left))
   {
      png_textp text_ptr;
      png_charp key;
      int comp_flag;
      png_charp lang;
      png_charp lang_key;
      png_charp text;
      int ret;

      if (png_ptr->buffer_size < 4)
      {
         png_push_save_buffer(png_ptr);
         return;
      }

      png_push_crc_finish(png_ptr);

#if defined(PNG_MAX_MALLOC_64K)
      if (png_ptr->skip_length)
         return;
#endif

      key = png_ptr->current_text;

      for (lang = key; *lang; lang++)
         /* empty loop */ ;

      if (lang < key + png_ptr->current_text_size - 3)
         lang++;

      comp_flag = *lang++;
      lang++;     /* skip comp_type, always zero */

      for (lang_key = lang; *lang_key; lang_key++)
         /* empty loop */ ;
      lang_key++;        /* skip NUL separator */

      text=lang_key;
      if (lang_key < key + png_ptr->current_text_size - 1)
      {
        for (; *text; text++)
           /* empty loop */ ;
      }

      if (text < key + png_ptr->current_text_size)
         text++;

      text_ptr = (png_textp)png_malloc(png_ptr,
         (png_uint_32)png_sizeof(png_text));
      text_ptr->compression = comp_flag + 2;
      text_ptr->key = key;
      text_ptr->lang = lang;
      text_ptr->lang_key = lang_key;
      text_ptr->text = text;
      text_ptr->text_length = 0;
      text_ptr->itxt_length = png_strlen(text);

      ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);

      png_ptr->current_text = NULL;

      png_free(png_ptr, text_ptr);
      if (ret)
        png_warning(png_ptr, "Insufficient memory to store iTXt chunk.");
   }
}
#endif

/* This function is called when we haven't found a handler for this
 * chunk.  If there isn't a problem with the chunk itself (ie a bad chunk
 * name or a critical chunk), the chunk is (currently) silently ignored.
 */
void /* PRIVATE */
png_push_handle_unknown(png_structp png_ptr, png_infop info_ptr, png_uint_32
   length)
{
   png_uint_32 skip = 0;

   if (!(png_ptr->chunk_name[0] & 0x20))
   {
#if defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)
      if (png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
         PNG_HANDLE_CHUNK_ALWAYS
#if defined(PNG_READ_USER_CHUNKS_SUPPORTED)
         && png_ptr->read_user_chunk_fn == NULL
#endif
         )
#endif
         png_chunk_error(png_ptr, "unknown critical chunk");

      info_ptr = info_ptr; /* to quiet some compiler warnings */
   }

#if defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)
   if (png_ptr->flags & PNG_FLAG_KEEP_UNKNOWN_CHUNKS)
   {
#ifdef PNG_MAX_MALLOC_64K
      if (length > (png_uint_32)65535L)
      {
          png_warning(png_ptr, "unknown chunk too large to fit in memory");
          skip = length - (png_uint_32)65535L;
          length = (png_uint_32)65535L;
      }
#endif
      png_memcpy((png_charp)png_ptr->unknown_chunk.name,
                 (png_charp)png_ptr->chunk_name, 
                 png_sizeof(png_ptr->unknown_chunk.name));
      png_ptr->unknown_chunk.name[png_sizeof(png_ptr->unknown_chunk.name) - 1]
        = '\0';

      png_ptr->unknown_chunk.size = (png_size_t)length;
      if (length == 0)
         png_ptr->unknown_chunk.data = NULL;
      else
      {
         png_ptr->unknown_chunk.data = (png_bytep)png_malloc(png_ptr,
       (png_uint_32)length);
         png_crc_read(png_ptr, (png_bytep)png_ptr->unknown_chunk.data, length);
      }
#if defined(PNG_READ_USER_CHUNKS_SUPPORTED)
      if (png_ptr->read_user_chunk_fn != NULL)
      {
         /* callback to user unknown chunk handler */
         int ret;
         ret = (*(png_ptr->read_user_chunk_fn))
           (png_ptr, &png_ptr->unknown_chunk);
         if (ret < 0)
            png_chunk_error(png_ptr, "error in user chunk");
         if (ret == 0)
         {
            if (!(png_ptr->chunk_name[0] & 0x20))
               if (png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
                    PNG_HANDLE_CHUNK_ALWAYS)
                  png_chunk_error(png_ptr, "unknown critical chunk");
            png_set_unknown_chunks(png_ptr, info_ptr,
               &png_ptr->unknown_chunk, 1);
         }
      }
      else
#endif
        png_set_unknown_chunks(png_ptr, info_ptr, &png_ptr->unknown_chunk, 1);
      png_free(png_ptr, png_ptr->unknown_chunk.data);
      png_ptr->unknown_chunk.data = NULL;
   }
   else
#endif
      skip=length;
   png_push_crc_skip(png_ptr, skip);
d1207 1
a1207 1
   const int png_pass_dsp_mask[7] =
d1210 4
a1213 1
   if (png_ptr == NULL) return;
d1223 3
a1225 1
   if (png_ptr == NULL) return;
d1236 3
a1238 1
   if (png_ptr == NULL) return (NULL);
@


1.7
log
@fastmerge
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.26 [April 2, 2008]
a12 1

d30 1
a30 1
   if(png_ptr == NULL || info_ptr == NULL) return;
d45 1
a45 1
   if(png_ptr == NULL) return;
d116 1
a116 1
   png_ptr->sig_bytes = (png_byte)(png_ptr->sig_bytes+num_to_check);
d212 1
a212 1
      png_ptr->push_length = png_get_uint_31(png_ptr,chunk_length);
d215 1
d220 1
a220 1
     if(png_ptr->mode & PNG_AFTER_IDAT)
d225 2
a228 2
         if (png_ptr->push_length != 13)
            png_error(png_ptr, "Invalid IHDR length");
d568 1
a568 1
   if(png_ptr == NULL) return;
d609 1
a609 1
         png_size_t i,istop;
d678 1
a678 1
      png_ptr->push_length = png_get_uint_31(png_ptr,chunk_length);
d701 1
a701 1
         if((png_uint_32)save_size != png_ptr->idat_size)
d723 1
a723 1
         if((png_uint_32)save_size != png_ptr->idat_size)
d763 1
a763 1
   for(;;)
d1023 26
a1048 31
         int pass;
         pass = png_ptr->pass;
         pass++;
         if ((pass == 1 && png_ptr->width < 5) ||
             (pass == 3 && png_ptr->width < 3) ||
             (pass == 5 && png_ptr->width < 2))
           pass++;

         if (pass > 7)
            pass--;
         png_ptr->pass = (png_byte) pass;
         if (pass < 7)
           {
             png_ptr->iwidth = (png_ptr->width +
                png_pass_inc[pass] - 1 -
                png_pass_start[pass]) /
                png_pass_inc[pass];

             png_ptr->irowbytes = PNG_ROWBYTES(png_ptr->pixel_depth,
                png_ptr->iwidth) + 1;

             if (png_ptr->transformations & PNG_INTERLACE)
                break;

             png_ptr->num_rows = (png_ptr->height +
                png_pass_yinc[pass] - 1 -
                png_pass_ystart[pass]) /
                png_pass_yinc[pass];
           }
         else
           break;
d1077 1
a1077 1
         (png_uint_32)(length+1));
d1175 1
a1175 1
       (png_uint_32)(length+1));
d1266 2
a1267 2
                  (png_uint_32)(png_ptr->zbuf_size - png_ptr->zstream.avail_out
                     + key_size + 1));
d1281 2
a1282 2
                  (png_uint_32)(png_ptr->zbuf_size - png_ptr->zstream.avail_out
                   + 1));
d1365 1
a1365 1
         (png_uint_32)(length+1));
d1466 1
a1466 2
   png_uint_32 skip=0;
   png_check_chunk_name(png_ptr, png_ptr->chunk_name);
d1471 2
a1472 2
     if(png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
          PNG_HANDLE_CHUNK_ALWAYS
d1474 1
a1474 1
          && png_ptr->read_user_chunk_fn == NULL
d1476 1
a1476 1
        )
d1478 1
a1478 1
        png_chunk_error(png_ptr, "unknown critical chunk");
d1480 1
a1480 1
     info_ptr = info_ptr; /* to quiet some compiler warnings */
d1497 2
a1498 1
      png_ptr->unknown_chunk.name[png_sizeof(png_ptr->unknown_chunk.name)-1]='\0';
a1499 1
      png_ptr->unknown_chunk.data = (png_bytep)png_malloc(png_ptr, length);
d1501 8
a1508 1
      png_crc_read(png_ptr, (png_bytep)png_ptr->unknown_chunk.data, length);
d1510 1
a1510 1
      if(png_ptr->read_user_chunk_fn != NULL)
d1521 1
a1521 1
               if(png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
d1570 1
a1570 1
   if(png_ptr == NULL) return;
d1580 1
a1580 1
   if(png_ptr == NULL) return;
d1591 1
a1591 1
   if(png_ptr == NULL) return (NULL);
@


1.6
log
@merge and fix for __CRAZY=Yes
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.25 [February 18, 2008]
d227 2
@


1.5
log
@merge and validate
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.17 May 15, 2007
d6 1
a6 1
 * Copyright (c) 1998-2007 Glenn Randers-Pehrson
d31 1
a31 1
   if(png_ptr == NULL) return;
d140 4
a143 4
      PNG_IHDR;
      PNG_IDAT;
      PNG_IEND;
      PNG_PLTE;
d145 1
a145 1
      PNG_bKGD;
d148 1
a148 1
      PNG_cHRM;
d151 1
a151 1
      PNG_gAMA;
d154 1
a154 1
      PNG_hIST;
d157 1
a157 1
      PNG_iCCP;
d160 1
a160 1
      PNG_iTXt;
d163 1
a163 1
      PNG_oFFs;
d166 1
a166 1
      PNG_pCAL;
d169 1
a169 1
      PNG_pHYs;
d172 1
a172 1
      PNG_sBIT;
d175 1
a175 1
      PNG_sCAL;
d178 1
a178 1
      PNG_sRGB;
d181 1
a181 1
      PNG_sPLT;
d184 1
a184 1
      PNG_tEXt;
d187 1
a187 1
      PNG_tIME;
d190 1
a190 1
      PNG_tRNS;
d193 1
a193 1
      PNG_zTXt;
d219 1
a219 1
   if (!png_memcmp(png_ptr->chunk_name, (png_bytep)png_IDAT, 4))
d276 1
a276 1
   else if (!png_memcmp(png_ptr->chunk_name, (png_bytep)png_IDAT, 4))
d663 1
a663 1
   PNG_IDAT;
d681 1
a681 1
      if (png_memcmp(png_ptr->chunk_name, (png_bytep)png_IDAT, 4))
a1003 5
   /* Width of interlace block.  This is not currently used - if you need
    * it, uncomment it here and in png.h
   const int png_pass_width[] = {8, 4, 4, 2, 2, 1, 1};
   */

d1021 31
a1051 26
         png_ptr->pass++;
         if ((png_ptr->pass == 1 && png_ptr->width < 5) ||
             (png_ptr->pass == 3 && png_ptr->width < 3) ||
             (png_ptr->pass == 5 && png_ptr->width < 2))
           png_ptr->pass++;

         if (png_ptr->pass > 7)
            png_ptr->pass--;
         if (png_ptr->pass >= 7)
            break;

         png_ptr->iwidth = (png_ptr->width +
            png_pass_inc[png_ptr->pass] - 1 -
            png_pass_start[png_ptr->pass]) /
            png_pass_inc[png_ptr->pass];

         png_ptr->irowbytes = PNG_ROWBYTES(png_ptr->pixel_depth,
            png_ptr->iwidth) + 1;

         if (png_ptr->transformations & PNG_INTERLACE)
            break;

         png_ptr->num_rows = (png_ptr->height +
            png_pass_yinc[png_ptr->pass] - 1 -
            png_pass_ystart[png_ptr->pass]) /
            png_pass_yinc[png_ptr->pass];
d1065 1
a1065 2
         /* to quiet some compiler warnings */
         if(info_ptr == NULL) return;
d1128 1
a1128 1
      if (text != key + png_ptr->current_text_size)
d1161 1
a1161 2
         /* to quiet some compiler warnings */
         if(info_ptr == NULL) return;
d1223 1
a1223 1
      if (text == key + png_ptr->current_text_size)
d1353 1
a1353 2
         /* to quiet some compiler warnings */
         if(info_ptr == NULL) return;
d1420 1
a1420 1
      if (lang != key + png_ptr->current_text_size)
d1430 6
a1435 2
      for (text = lang_key; *text; text++)
         /* empty loop */ ;
d1437 1
a1437 1
      if (text != key + png_ptr->current_text_size)
d1475 2
a1476 2
      if(png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
           PNG_HANDLE_CHUNK_ALWAYS
d1478 1
a1478 1
           && png_ptr->read_user_chunk_fn == NULL
d1480 1
a1480 1
         )
d1482 1
a1482 1
         png_chunk_error(png_ptr, "unknown critical chunk");
d1484 1
a1484 3
      /* to quiet compiler warnings about unused info_ptr */
      if (info_ptr == NULL)
         return;
d1491 15
a1505 12
       if (length > (png_uint_32)65535L)
       {
           png_warning(png_ptr, "unknown chunk too large to fit in memory");
           skip = length - (png_uint_32)65535L;
           length = (png_uint_32)65535L;
       }
#endif
       png_strcpy((png_charp)png_ptr->unknown_chunk.name,
         (png_charp)png_ptr->chunk_name);
       png_ptr->unknown_chunk.data = (png_bytep)png_malloc(png_ptr, length);
       png_ptr->unknown_chunk.size = (png_size_t)length;
       png_crc_read(png_ptr, (png_bytep)png_ptr->unknown_chunk.data, length);
d1507 19
a1525 20
       if(png_ptr->read_user_chunk_fn != NULL)
       {
          /* callback to user unknown chunk handler */
          int ret;
          ret = (*(png_ptr->read_user_chunk_fn))
            (png_ptr, &png_ptr->unknown_chunk);
          if (ret < 0)
             png_chunk_error(png_ptr, "error in user chunk");
          if (ret == 0)
          {
             if (!(png_ptr->chunk_name[0] & 0x20))
                if(png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
                     PNG_HANDLE_CHUNK_ALWAYS)
                   png_chunk_error(png_ptr, "unknown critical chunk");
                png_set_unknown_chunks(png_ptr, info_ptr,
                   &png_ptr->unknown_chunk, 1);
          }
       }
#else
       png_set_unknown_chunks(png_ptr, info_ptr, &png_ptr->unknown_chunk, 1);
d1527 3
a1529 2
       png_free(png_ptr, png_ptr->unknown_chunk.data);
       png_ptr->unknown_chunk.data = NULL;
@


1.4
log
@merge libpng-1.2.12
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.11 - June 7, 2004
d6 1
a6 1
 * Copyright (c) 1998-2006 Glenn Randers-Pehrson
d31 1
d46 1
d566 1
a1490 2
       png_unknown_chunk chunk;

d1499 5
a1503 5

       png_strcpy((png_charp)chunk.name, (png_charp)png_ptr->chunk_name);
       chunk.data = (png_bytep)png_malloc(png_ptr, length);
       png_crc_read(png_ptr, chunk.data, length);
       chunk.size = length;
d1508 6
a1513 1
          if ((*(png_ptr->read_user_chunk_fn)) (png_ptr, &chunk) <= 0)
d1519 2
a1521 1
             png_set_unknown_chunks(png_ptr, info_ptr, &chunk, 1);
d1523 2
a1524 1
       else
d1526 2
a1527 2
          png_set_unknown_chunks(png_ptr, info_ptr, &chunk, 1);
       png_free(png_ptr, chunk.data);
d1565 1
d1575 1
d1586 1
@


1.3
log
@sync, fix CPPFLAGS
no shlib vsn change (only change local data->rodata, no external syms)
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.8 - December 3, 2004
d6 1
a6 1
 * Copyright (c) 1998-2004 Glenn Randers-Pehrson
d217 4
d288 3
a290 2
         if (png_ptr->push_length == 0)
            return;
@


1.2
log
@merge src/lib
@
text
@d4 1
a4 1
 * libpng version 1.2.8 - December 3, 2004
d617 1
a617 1
      if (png_ptr->save_buffer_size > PNG_SIZE_MAX - 
@


1.1
log
@Initial revision
@
text
@d985 1
a985 1
   const int FARDATA png_pass_start[] = {0, 4, 0, 2, 0, 1, 0};
d988 1
a988 1
   const int FARDATA png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1};
d991 1
a991 1
   const int FARDATA png_pass_ystart[] = {0, 0, 4, 0, 2, 0, 1};
d994 1
a994 1
   const int FARDATA png_pass_yinc[] = {8, 8, 8, 4, 4, 2, 2};
d998 1
a998 1
   const int FARDATA png_pass_width[] = {8, 4, 4, 2, 2, 1, 1};
d1003 1
a1003 1
   const int FARDATA png_pass_height[] = {8, 8, 4, 4, 2, 2, 1};
d1549 1
a1549 1
   const int FARDATA png_pass_dsp_mask[7] =
@


1.1.107.1
log
@libpng-1_2_8 with the following directories removed:
- contrib
- projects
- scripts
@
text
@@


1.1.107.2
log
@there's a newer libpng out there
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.8 - December 3, 2004
d617 1
a617 1
      if (png_ptr->save_buffer_size > PNG_SIZE_MAX -
@


1.1.107.3
log
@Import libpng 1.2.12, fixes at least three vulnerabilities
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.11 - June 7, 2004
d6 1
a6 1
 * Copyright (c) 1998-2006 Glenn Randers-Pehrson
a216 4
   if (!png_memcmp(png_ptr->chunk_name, (png_bytep)png_IDAT, 4))
     if(png_ptr->mode & PNG_AFTER_IDAT)
        png_ptr->mode |= PNG_HAVE_CHUNK_AFTER_IDAT;

d284 2
a285 3
         if (!(png_ptr->mode & PNG_HAVE_CHUNK_AFTER_IDAT))
           if (png_ptr->push_length == 0)
              return;
@


1.1.107.4
log
@Upgrade libpng (fixes some holes)
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.17 May 15, 2007
d6 1
a6 1
 * Copyright (c) 1998-2007 Glenn Randers-Pehrson
a30 1
   if(png_ptr == NULL) return;
a44 1
   if(png_ptr == NULL) return;
a563 1
   if(png_ptr == NULL) return;
d1488 2
d1498 5
a1502 5
       png_strcpy((png_charp)png_ptr->unknown_chunk.name,
         (png_charp)png_ptr->chunk_name);
       png_ptr->unknown_chunk.data = (png_bytep)png_malloc(png_ptr, length);
       png_ptr->unknown_chunk.size = (png_size_t)length;
       png_crc_read(png_ptr, (png_bytep)png_ptr->unknown_chunk.data, length);
d1507 1
a1507 6
          int ret;
          ret = (*(png_ptr->read_user_chunk_fn))
            (png_ptr, &png_ptr->unknown_chunk);
          if (ret < 0)
             png_chunk_error(png_ptr, "error in user chunk");
          if (ret == 0)
a1512 2
                png_set_unknown_chunks(png_ptr, info_ptr,
                   &png_ptr->unknown_chunk, 1);
d1514 1
d1516 1
a1516 2
#else
       png_set_unknown_chunks(png_ptr, info_ptr, &png_ptr->unknown_chunk, 1);
d1518 2
a1519 2
       png_free(png_ptr, png_ptr->unknown_chunk.data);
       png_ptr->unknown_chunk.data = NULL;
a1556 1
   if(png_ptr == NULL) return;
a1565 1
   if(png_ptr == NULL) return;
a1575 1
   if(png_ptr == NULL) return (NULL);
@


1.1.107.5
log
@Import libpng-1.2.25 with the following change log.
Requested by bsiegert@@ due to security fix relevance.

version 1.2.19beta1 [May 18, 2007]
  Changed "const static" to "static PNG_CONST" everywhere, mostly undoing
    change of libpng-1.2.17beta2.  Changed other "const" to "PNG_CONST"
  Changed some handling of unused parameters, to avoid compiler warnings.
    "if (unused == NULL) return;" becomes "unused = unused".

version 1.2.19beta2 [May 18, 2007]
  Only use the valid bits of tRNS value in png_do_expand() (Brian Cartier)

version 1.2.19beta3 [May 19, 2007]
  Add some "png_byte" typecasts in png_check_keyword() and write new_key
  instead of key in zTXt chunk (Kevin Ryde).

version 1.2.19beta4 [May 21, 2007]
  Add png_snprintf() function and use it in place of sprint() for improved
    defense against buffer overflows.

version 1.2.19beta5 [May 21, 2007]
  Fixed png_handle_tRNS() to only use the valid bits of tRNS value.
  Changed handling of more unused parameters, to avoid compiler warnings.
  Removed some PNG_CONST in pngwutil.c to avoid compiler warnings.

version 1.2.19beta6 [May 22, 2007]
  Added some #ifdef PNG_MMX_CODE_SUPPORTED where needed in pngvcrd.c
  Added a special "_MSC_VER" case that defines png_snprintf to _snprintf

version 1.2.19beta7 [May 22, 2007]
  Squelched png_squelch_warnings() in pnggccrd.c and added an
    #ifdef PNG_MMX_CODE_SUPPORTED block around the declarations that caused
    the warnings that png_squelch_warnings was squelching.

version 1.2.19beta8 [May 22, 2007]
  Removed __MMX__ from test in pngconf.h.

version 1.2.19beta9 [May 23, 2007]
  Made png_squelch_warnings() available via PNG_SQUELCH_WARNINGS macro.
  Revised png_squelch_warnings() so it might work.
  Updated makefile.sgcc and makefile.solaris; added makefile.solaris-x86.

version 1.2.19beta10 [May 24, 2007]
  Resquelched png_squelch_warnings(), use "__attribute__((used))" instead.

version 1.2.19beta11 [May 28, 2007]
  Return 0 from png_get_sPLT() and png_get_unknown_chunks() if png_ptr is NULL;
    changed three remaining instances of png_strcpy() to png_strncpy() (David
    Hill).
  Make test for NULL row_buf at the beginning of png_do_read_transformations
    unconditional.

version 1.2.19beta12 [May 28, 2007]
  Revised pnggccrd.c.

version 1.2.19beta13 [June 14, 2007]
  Prefer PNG_USE_PNGVCRD when _MSC_VER is defined in pngconf.h

version 1.2.19beta14 [June 16, 2007]
  Fix bug with handling of 16-bit transparency, introduced in 1.2.19beta2

version 1.2.19beta15 [June 17, 2007]
  Revised pnggccrd.c.

version 1.2.19beta16 [June 18, 2007]
  Revised pnggccrd.c again.
  Updated contrib/gregbook.
  Changed '#include "pnggccrd.c"' to 'include "$srcdir/pnggccrd.c"'
    in configure.ac

version 1.2.19beta17 [June 19, 2007]
  Revised many of the makefiles, to set -DPNG_NO_MMX_CODE where needed
    and to not use -O3 unless -DPNG_NO_MMX_CODE is also set.

version 1.2.19beta18 [June 23, 2007]
  Replaced some C++ style comments with C style comments in pnggccrd.c.
  Copied optimized C code from pnggccrd.c to pngrutil.c, removed dependency
    on pnggccrd.o from many makefiles.
  Added sl and dylib to list of extensions be installed by Makefile.am

version 1.2.19beta19 [June 28, 2007]
  Fixed testing PNG_RGB_TO_GRAY_ERR & PNG_RGB_TO_GRAY_WARN in pngrtran.c
  More cleanup of pnggccrd.c and pngvcrd.c

version 1.2.19beta20 [June 29, 2007]
  Rebuilt Makefile.in and configure using libtool-1.5.24.
  Fixed typo in pnggccrd.c

version 1.2.19beta21 [June 30, 2007]
  More revision of pnggccrd.c
  Added "test" target to Makefile.in and Makefile.am

version 1.2.19beta22 [July 3, 2007]
  Added info about pngrutil/pnggccrd/pngvcrd to png_get_header_version()
  Fix type definition of dummy_value_a, b in pnggccrd.c

version 1.2.19beta23 [July 10, 2007]
  Revert change to type definition of dummy_value_a, b in pnggccrd.c
  Make sure __PIC__ is defined in pnggccrd.c when PIC is defined.
  Require gcc-4.1 or better to use PNG_HAVE_MMX_FILTER_ROW on x86_64 platforms

version 1.2.19beta24 [July 14, 2007]
  Added PNG_NO_READ_FILTER, PNG_NO_WRITE_FILTER, PNG_NO_WARNING macros.
  Added contrib/pngminim to demonstrate building minimal encoder and decoder

version 1.2.19beta25 [July 15, 2007]
  Removed the new PNG_NO_READ_FILTER macro since it would make the library
    unable to read valid PNG files, and filtering is at the heart of the
    PNG format.

version 1.2.19beta26 [July 16, 2007]
  Changed "png_free(str)" to "png_free(png_ptr,str)" in pngrutil.c WinCE
    code (Yves Piguet).  This bug was introduced in libpng-1.2.14.
  Updated scripts/CMakeLists.txt
  Relocated a misplaced #endif in pnggccrd.c

version 1.2.19beta27 [July 17, 2007]
  Fixed incorrect stride and number of bytes copied (was 4 instead of
    6 bytes) in the cleanup loop of pnggccrd.c and pngvcrd.c for handling
    the end of 48-bit interlaced rows (Glenn R-P).

version 1.2.19beta28 [July 19, 2007]
  Removed requirement for gcc-4.1 or better to use PNG_HAVE_MMX_FILTER_ROW
    on x86_64 platforms
  Added png_warning() in pngrutil.c for short iCCP, iTXt, sPLT, or zTXT chunks.
  Revised pngtest.c so warnings are displayed regardless of PNG_NO_STDIO.

version 1.2.19beta29 [July 20, 2007]
  Fix typo in pnggccrd.c (%%eax should be %%ax in secondloop48)

version 1.2.19beta30 [July 26, 2007]
  Revised pnggccrd.c

version 1.2.19beta31 [July 27, 2007]
  Fix typos in pnggccrd.c

version 1.0.27rc1 and 1.2.19rc1 [July 31, 2007]
  Disable PNG_MMX_CODE_SUPPORTED when PNG_ASSEMBLER_CODE_SUPPORTED is off.
  Enable PNG_MMX_READ_FILTER_* by default, except when gcc-3.x is being
    used (they were inadvertently disabled in libpng-1.2.19beta23).
  Fix some debugging statements in pnggccrd.c and pngrutil.c
  Added information about disabling the MMX code in libpng documentation.

version 1.0.27rc2 and 1.2.19rc2 [August 4, 2007]
  Removed some "#if 0" blocks.
  Made a global struct local in pngvcrd.c to make it thread safe.
  Issue a png_error() if application attempts to transform a row tht
    has not been initialized.

version 1.0.27rc3 and 1.2.19rc3 [August 9, 2007]
  Slightly revised pngvcrd.c

version 1.0.27rc4 and 1.2.19rc4 [August 9, 2007]
  Revised pnggccrd.c debugging change of rc1, which was broken.
  Revised scripts/CMakeLists.txt
  Change default to PNG_NO_GLOBAL_ARRAYS for MSVC.
  Turn off PNG_FLAG_ROW_INIT flag when setting transforms that expand pixels.

version 1.0.27rc5 and 1.2.19rc5 [August 10, 2007]
  Fix typo (missing '"') in pnggccrd.c
  Revise handling of png_strtod in recent versions of WINCE

version 1.0.27rc6 and 1.2.19rc6 [August 15, 2007]
  Fix typo (missing ',') in contrib/gregbook/readpng2.c
  Undid row initialization error exit added to rc2 and rc4.

version 1.0.27 and 1.2.19 [August 18, 2007]
  Conditionally restored row initialization error exit.

version 1.2.20beta01 [August 19, 2007]
  Fixed problem with compiling pnggccrd.c on Intel-Apple platforms.
  Changed png_malloc() to png_malloc_warn() in png_set_sPLT().
  Added PNG_NO_ERROR_TEXT feature, with demo in contrib/pngminim
  Removed define PNG_WARN_UNINITIALIZED_ROW 1 /* 0: warning; 1: error */
    because it caused some trouble.

version 1.2.20beta02 [August 20, 2007]
  Avoid compiling pnggccrd.c on Intel-Apple platforms.

version 1.2.20beta03 [August 20, 2007]
  Added "/D PNG_NO_MMX_CODE" to the non-mmx builds of projects/visualc6
    and visualc71.

version 1.2.20beta04 [August 21, 2007]
  Revised pngvcrd.c for improved efficiency (Steve Snyder).

version 1.2.20rc1 [August 23, 2007]
  Revised pngconf.h to set PNG_NO_MMX_CODE for gcc-3.x compilers.

version 1.2.20rc2 [August 27, 2007]
  Revised scripts/CMakeLists.txt
  Revised #ifdefs to ensure one and only one of pnggccrd.c, pngvcrd.c,
    or part of pngrutil.c is selected.

version 1.2.20rc3 [August 30, 2007]
  Remove a little more code in pngwutil.c when PNG_NO_WRITE_FILTER is selected.
  Added /D _CRT_SECURE_NO_WARNINGS to visual6c and visualc71 projects.
  Compile png_mmx_support() in png.c even when PNG_NO_MMX_CODE is defined.
  Restored a "superfluous" #ifdef that was removed from 1.2.20rc2 pnggccrd.c,
    breaking the png_mmx_support() function.

version 1.2.20rc4 [September 1, 2007]
  Removed Intel contributions (MMX, Optimized C).

version 1.2.20rc5 [September 2, 2007]
  Restored configure and Makefile.in to rc3 and put a snippet of code in
    pnggccrd.c, to ensure configure makes the same PNG_NO_MMX_CODE selection

version 1.2.20rc6 [September 2, 2007]
  Fixed bugs in scripts/CMakeLists.txt
  Removed pngvcrd.c references from msvc projects.

version 1.0.28 and 1.2.20 [September 8, 2007]
  Removed "(NO READ SUPPORT)" from png_get_header_version() string.

version 1.2.21beta1 [September 14, 2007]
  Fixed various mistakes reported by George Cook and Jeff Phillips:
  logical vs bitwise NOT in pngrtran.c, bug introduced in 1.2.19rc2
  16-bit cheap transparency expansion, bug introduced in 1.2.19beta2
  errors with sizeof(unknown_chunk.name), bugs introduced in 1.2.19beta11
  <= compare with unsigned var in pngset.c, should be ==.

version 1.2.21beta2 [September 18, 2007]
  Removed some extraneous typecasts.

version 1.2.21rc1 [September 25, 2007]
  Fixed potential out-of-bounds reads in png_handle_pCAL() and
    png_handle_ztXt() ("flayer" results reported by Tavis Ormandy).

version 1.2.21rc2 [September 26, 2007]
  Fixed potential out-of-bounds reads in png_handle_sCAL(),
    png_handle_iTXt(), and png_push_read_tEXt().
  Remove some PNG_CONST declarations from pngwutil.c to avoid compiler warnings
  Revised makefiles to update paths in libpng.pc properly.

version 1.2.21rc3 [September 27, 2007]
  Revised makefiles to update "Libs" in libpng.pc properly.

version 1.0.29 and 1.2.21rc3 [October 4, 2007]
  No changes.

version 1.2.22beta1 [October 4, 2007]
  Again, fixed logical vs bitwise NOT in pngrtran.c, bug introduced
    in 1.2.19rc2

version 1.2.22beta2 [October 5, 2007]
  Fixed string length error in pngset.c (caused crashes while decoding iCCP)
  Add terminating NULL after each instance of png_strncpy().

version 1.2.22beta3 [October 6, 2007]
  Fix two off-by-one terminating NULL after png_strncpy().

version 1.2.22beta4 [October 7, 2007]
  Changed some 0 to '\0'.

version 1.0.30rc1 and 1.2.22rc1 [October 8, 2007]
  No changes.

version 1.0.30 and 1.2.22 [October 13, 2007]
  No changes.

version 1.2.23beta01 [October 15, 2007]
  Reduced number of invocations of png_strlen() in pngset.c.
  Changed [azAZ09_] to [_abcde...89] in Makefile.am for better localization.

version 1.2.23beta02 [October 16, 2007]
  Eliminated png_strncpy() and png_strcpy() (Pierre Poissinger)
  Changed $AN to $(AN) in Makefile.am.

version 1.2.23beta03 [October 16, 2007]
  Fixed off-by-one error in pngset.c
  Restore statement to set last character of buffer to \0 in pngerror.c

version 1.2.23beta04 [October 23, 2007]
  Reject attempt to set all-zero cHRM values.

version 1.2.23beta05 [October 26, 2007]
  Add missing quotes in projects/visualc6, lost in version 1.2.20rc3

version 1.2.23rc01 [November 2, 2007]
  No changes.

version 1.2.23 [November 6, 2007]
  No changes.

version 1.2.24beta01 [November 19, 2007]
  Moved misplaced test for malloc failure in png_set_sPLT().  This bug was
    introduced in libpng-1.2.20beta01.
  Ifdef out avg_row etc from png.h and pngwrite.c when PNG_NO_WRITE_FILTER
  Do not use png_ptr->free_fn and png_ptr->mem_fn in png_destroy_read_struct()
    when png_ptr is NULL (Marshall Clow).
  Updated handling of symbol prefixes in Makefile.am and configure.ac (Mike
    Frysinger).

version 1.2.24beta02 [November 30, 2007]
  Removed a useless test and fixed incorrect test in png_set_cHRM_fixed()
    (David Hill).

version 1.2.24rc01 [December 7, 2007]
  No changes.

version 1.2.24     [December 14, 2007]
  Make sure not to redefine _BSD_SOURCE in pngconf.h
  Revised gather.sh and makefile.std in contrib/pngminim to avoid compiling
    unused files.

version 1.2.25beta01 [January 7, 2008]
  Fixed bug with unknown chunk handling, introduced in version 1.2.17rc2

version 1.2.25beta02 [January 10, 2008]
  Prevent gamma from being applied twice.

version 1.2.25rc01 [January 17, 2008]
  No changes.

version 1.2.25beta03 [January 22, 2008]
  Fixed some continue-after-malloc-failure errors in pngset.c (David Hill)
  Check for info_ptr == NULL in png_read_info() and png_process_data().
  Check for possible use of NULL user_png_ver[] in png_create_read_struct().
  Change "if (swidth == NULL)" to "if (sheight == NULL)" in png_handle_sCAL
    (bug introduced in libpng-1.2.4/1.0.13).
  Return from png_destroy_read_struct() if png_ptr_ptr is NULL.
  Fix overflow of "msg" in png_decompres_chunk().

version 1.2.25beta04 [January 26, 2008]
  Work around Coverity bug report by slightly refactoring
    png_read_push_finish_row()

version 1.2.25beta05 [January 31, 2008]
  Added libpng-1.2.25beta05.tar.lzma to distribution.  Get the lzma codec
    from <http://tukaani.org/lzma>.
  Added lp1225b05.7z to distribution.  Get the 7-zip decoder from
    from <http://www.7-zip.org>.
  Fixed some broken links in the README file.

version 1.2.25beta06 [February 6, 2008]
  Refactored png_read_push_finish_row() again, trying to satisfy Coverity.
  Fixed potential NULL dereference of png_ptr in png_destroy_write_struct();
  clarified potential NULL dereference of png_ptr in png_destroy_read_struct();
  fixed potential NULL dereference of info_ptr in png_handle_bKGD();
  fixed potential NULL dereference of user_png_ver[] in
    png_create_write_struct_2(). (Coverity)

version 1.2.25rc02 [February 10, 2008]
  Reset png_ptr->pass in png_read_push_finish_row() before break.
  Changed "pass" from png_byte to int.

version 1.2.25 and 1.0.31 [February 18, 2008]
  No changes.
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.25 [February 18, 2008]
d6 1
a6 1
 * Copyright (c) 1998-2008 Glenn Randers-Pehrson
d31 1
a31 1
   if(png_ptr == NULL || info_ptr == NULL) return;
d140 4
a143 4
      PNG_CONST PNG_IHDR;
      PNG_CONST PNG_IDAT;
      PNG_CONST PNG_IEND;
      PNG_CONST PNG_PLTE;
d145 1
a145 1
      PNG_CONST PNG_bKGD;
d148 1
a148 1
      PNG_CONST PNG_cHRM;
d151 1
a151 1
      PNG_CONST PNG_gAMA;
d154 1
a154 1
      PNG_CONST PNG_hIST;
d157 1
a157 1
      PNG_CONST PNG_iCCP;
d160 1
a160 1
      PNG_CONST PNG_iTXt;
d163 1
a163 1
      PNG_CONST PNG_oFFs;
d166 1
a166 1
      PNG_CONST PNG_pCAL;
d169 1
a169 1
      PNG_CONST PNG_pHYs;
d172 1
a172 1
      PNG_CONST PNG_sBIT;
d175 1
a175 1
      PNG_CONST PNG_sCAL;
d178 1
a178 1
      PNG_CONST PNG_sRGB;
d181 1
a181 1
      PNG_CONST PNG_sPLT;
d184 1
a184 1
      PNG_CONST PNG_tEXt;
d187 1
a187 1
      PNG_CONST PNG_tIME;
d190 1
a190 1
      PNG_CONST PNG_tRNS;
d193 1
a193 1
      PNG_CONST PNG_zTXt;
d219 1
a219 1
   if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
d276 1
a276 1
   else if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
d663 1
a663 1
   PNG_CONST PNG_IDAT;
d681 1
a681 1
      if (png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
d993 1
a993 1
   PNG_CONST int FARDATA png_pass_start[] = {0, 4, 0, 2, 0, 1, 0};
d996 1
a996 1
   PNG_CONST int FARDATA png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1};
d999 1
a999 1
   PNG_CONST int FARDATA png_pass_ystart[] = {0, 0, 4, 0, 2, 0, 1};
d1002 6
a1007 1
   PNG_CONST int FARDATA png_pass_yinc[] = {8, 8, 8, 4, 4, 2, 2};
d1011 1
a1011 1
   PNG_CONST int FARDATA png_pass_height[] = {8, 8, 4, 4, 2, 2, 1};
d1026 26
a1051 31
         int pass;
         pass = png_ptr->pass;
         pass++;
         if ((pass == 1 && png_ptr->width < 5) ||
             (pass == 3 && png_ptr->width < 3) ||
             (pass == 5 && png_ptr->width < 2))
           pass++;

         if (pass > 7)
            pass--;
         png_ptr->pass = (png_byte) pass;
         if (pass < 7)
           {
             png_ptr->iwidth = (png_ptr->width +
                png_pass_inc[pass] - 1 -
                png_pass_start[pass]) /
                png_pass_inc[pass];

             png_ptr->irowbytes = PNG_ROWBYTES(png_ptr->pixel_depth,
                png_ptr->iwidth) + 1;

             if (png_ptr->transformations & PNG_INTERLACE)
                break;

             png_ptr->num_rows = (png_ptr->height +
                png_pass_yinc[pass] - 1 -
                png_pass_ystart[pass]) /
                png_pass_yinc[pass];
           }
         else
           break;
d1065 2
a1066 1
         info_ptr = info_ptr; /* to quiet some compiler warnings */
d1129 1
a1129 1
      if (text < key + png_ptr->current_text_size)
d1162 2
a1163 1
         info_ptr = info_ptr; /* to quiet some compiler warnings */
d1225 1
a1225 1
      if (text >= key + png_ptr->current_text_size)
d1355 2
a1356 1
         info_ptr = info_ptr; /* to quiet some compiler warnings */
d1423 1
a1423 1
      if (lang < key + png_ptr->current_text_size - 3)
d1433 2
a1434 6
      text=lang_key;
      if (lang_key < key + png_ptr->current_text_size - 1)
      {
        for (; *text; text++)
           /* empty loop */ ;
      }
d1436 1
a1436 1
      if (text < key + png_ptr->current_text_size)
d1474 2
a1475 2
     if(png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
          PNG_HANDLE_CHUNK_ALWAYS
d1477 1
a1477 1
          && png_ptr->read_user_chunk_fn == NULL
d1479 1
a1479 1
        )
d1481 1
a1481 1
        png_chunk_error(png_ptr, "unknown critical chunk");
d1483 3
a1485 1
     info_ptr = info_ptr; /* to quiet some compiler warnings */
d1492 12
a1503 15
      if (length > (png_uint_32)65535L)
      {
          png_warning(png_ptr, "unknown chunk too large to fit in memory");
          skip = length - (png_uint_32)65535L;
          length = (png_uint_32)65535L;
      }
#endif
      png_memcpy((png_charp)png_ptr->unknown_chunk.name,
                 (png_charp)png_ptr->chunk_name, 
                 png_sizeof(png_ptr->unknown_chunk.name));
      png_ptr->unknown_chunk.name[png_sizeof(png_ptr->unknown_chunk.name)-1]='\0';

      png_ptr->unknown_chunk.data = (png_bytep)png_malloc(png_ptr, length);
      png_ptr->unknown_chunk.size = (png_size_t)length;
      png_crc_read(png_ptr, (png_bytep)png_ptr->unknown_chunk.data, length);
d1505 20
a1524 19
      if(png_ptr->read_user_chunk_fn != NULL)
      {
         /* callback to user unknown chunk handler */
         int ret;
         ret = (*(png_ptr->read_user_chunk_fn))
           (png_ptr, &png_ptr->unknown_chunk);
         if (ret < 0)
            png_chunk_error(png_ptr, "error in user chunk");
         if (ret == 0)
         {
            if (!(png_ptr->chunk_name[0] & 0x20))
               if(png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
                    PNG_HANDLE_CHUNK_ALWAYS)
                  png_chunk_error(png_ptr, "unknown critical chunk");
            png_set_unknown_chunks(png_ptr, info_ptr,
               &png_ptr->unknown_chunk, 1);
         }
      }
      else
d1526 2
a1527 3
        png_set_unknown_chunks(png_ptr, info_ptr, &png_ptr->unknown_chunk, 1);
      png_free(png_ptr, png_ptr->unknown_chunk.data);
      png_ptr->unknown_chunk.data = NULL;
d1562 1
a1562 1
   PNG_CONST int FARDATA png_pass_dsp_mask[7] =
@


1.1.107.6
log
@*sigh*

sync with MirPortsâ€¦ they had another update
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.26 [April 2, 2008]
a226 2
         if (png_ptr->push_length != 13)
            png_error(png_ptr, "Invalid IHDR length");
@


1.1.107.7
log
@SECURITY update of libpng to 1.2.32
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.32 [September 18, 2008]
d13 1
d31 1
a31 1
   if (png_ptr == NULL || info_ptr == NULL) return;
d46 1
a46 1
   if (png_ptr == NULL) return;
d117 1
a117 1
   png_ptr->sig_bytes = (png_byte)(png_ptr->sig_bytes + num_to_check);
d213 1
a213 1
      png_ptr->push_length = png_get_uint_31(png_ptr, chunk_length);
a215 1
      png_check_chunk_name(png_ptr, png_ptr->chunk_name);
d220 1
a220 1
     if (png_ptr->mode & PNG_AFTER_IDAT)
a224 2
      if (png_ptr->push_length != 13)
         png_error(png_ptr, "Invalid IHDR length");
d227 2
d568 1
a568 1
   if (png_ptr == NULL) return;
d609 1
a609 1
         png_size_t i, istop;
d678 1
a678 1
      png_ptr->push_length = png_get_uint_31(png_ptr, chunk_length);
d701 1
a701 1
         if ((png_uint_32)save_size != png_ptr->idat_size)
d723 1
a723 1
         if ((png_uint_32)save_size != png_ptr->idat_size)
d763 1
a763 1
   for (;;)
d1023 31
a1053 26
         png_ptr->pass++;
         if ((png_ptr->pass == 1 && png_ptr->width < 5) ||
             (png_ptr->pass == 3 && png_ptr->width < 3) ||
             (png_ptr->pass == 5 && png_ptr->width < 2))
           png_ptr->pass++;

         if (png_ptr->pass > 7)
            png_ptr->pass--;
         if (png_ptr->pass >= 7)
            break;

         png_ptr->iwidth = (png_ptr->width +
            png_pass_inc[png_ptr->pass] - 1 -
            png_pass_start[png_ptr->pass]) /
            png_pass_inc[png_ptr->pass];

         png_ptr->irowbytes = PNG_ROWBYTES(png_ptr->pixel_depth,
            png_ptr->iwidth) + 1;

         if (png_ptr->transformations & PNG_INTERLACE)
            break;

         png_ptr->num_rows = (png_ptr->height +
            png_pass_yinc[png_ptr->pass] - 1 -
            png_pass_ystart[png_ptr->pass]) /
            png_pass_yinc[png_ptr->pass];
d1082 1
a1082 1
      (png_uint_32)(length + 1));
d1180 1
a1180 1
      (png_uint_32)(length + 1));
d1271 2
a1272 2
                     (png_uint_32)(png_ptr->zbuf_size
                     - png_ptr->zstream.avail_out + key_size + 1));
d1286 2
a1287 2
                  (png_uint_32)(png_ptr->zbuf_size 
                  - png_ptr->zstream.avail_out + 1));
d1370 1
a1370 1
      (png_uint_32)(length + 1));
d1471 2
a1472 1
   png_uint_32 skip = 0;
d1477 2
a1478 2
      if (png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
         PNG_HANDLE_CHUNK_ALWAYS
d1480 1
a1480 1
         && png_ptr->read_user_chunk_fn == NULL
d1482 1
a1482 1
         )
d1484 1
a1484 1
         png_chunk_error(png_ptr, "unknown critical chunk");
d1486 1
a1486 1
      info_ptr = info_ptr; /* to quiet some compiler warnings */
d1503 1
a1503 2
      png_ptr->unknown_chunk.name[png_sizeof(png_ptr->unknown_chunk.name) - 1]
        = '\0';
d1505 1
d1507 1
a1507 8
      if (length == 0)
         png_ptr->unknown_chunk.data = NULL;
      else
      {
         png_ptr->unknown_chunk.data = (png_bytep)png_malloc(png_ptr,
       (png_uint_32)length);
         png_crc_read(png_ptr, (png_bytep)png_ptr->unknown_chunk.data, length);
      }
d1509 1
a1509 1
      if (png_ptr->read_user_chunk_fn != NULL)
d1520 1
a1520 1
               if (png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
d1569 1
a1569 1
   if (png_ptr == NULL) return;
d1579 1
a1579 1
   if (png_ptr == NULL) return;
d1590 1
a1590 1
   if (png_ptr == NULL) return (NULL);
@


1.1.107.8
log
@Update libpng in the base system, too
@
text
@d4 3
a6 2
 * Last changed in libpng 1.2.44 [June 26, 2010]
 * Copyright (c) 1998-2010 Glenn Randers-Pehrson
a8 4
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
a11 1
#define PNG_NO_PEDANTIC_WARNINGS
d15 1
a15 1
/* Push model modes */
d30 1
a30 3
   if (png_ptr == NULL || info_ptr == NULL)
      return;

d45 1
a45 3
   if (png_ptr == NULL)
      return;

a52 1

a57 1

d63 21
a83 1

a88 1

d143 1
a143 1
#ifdef PNG_READ_bKGD_SUPPORTED
d146 1
a146 1
#ifdef PNG_READ_cHRM_SUPPORTED
d149 1
a149 1
#ifdef PNG_READ_gAMA_SUPPORTED
d152 1
a152 1
#ifdef PNG_READ_hIST_SUPPORTED
d155 1
a155 1
#ifdef PNG_READ_iCCP_SUPPORTED
d158 1
a158 1
#ifdef PNG_READ_iTXt_SUPPORTED
d161 1
a161 1
#ifdef PNG_READ_oFFs_SUPPORTED
d164 1
a164 1
#ifdef PNG_READ_pCAL_SUPPORTED
d167 1
a167 1
#ifdef PNG_READ_pHYs_SUPPORTED
d170 1
a170 1
#ifdef PNG_READ_sBIT_SUPPORTED
d173 1
a173 1
#ifdef PNG_READ_sCAL_SUPPORTED
d176 1
a176 1
#ifdef PNG_READ_sRGB_SUPPORTED
d179 1
a179 1
#ifdef PNG_READ_sPLT_SUPPORTED
d182 1
a182 1
#ifdef PNG_READ_tEXt_SUPPORTED
d185 1
a185 1
#ifdef PNG_READ_tIME_SUPPORTED
d188 1
a188 1
#ifdef PNG_READ_tRNS_SUPPORTED
d191 1
a191 1
#ifdef PNG_READ_zTXt_SUPPORTED
a194 1

a226 1

a231 1

a233 1

a240 1

a245 1

a253 1

a255 1

a256 1

a258 1

a262 1

a267 1

a277 1

d284 5
a288 7

      if (!(png_ptr->mode & PNG_HAVE_IHDR))
         png_error(png_ptr, "Missing IHDR before IDAT");

      else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
          !(png_ptr->mode & PNG_HAVE_PLTE))
         png_error(png_ptr, "Missing PLTE before IDAT");
d293 2
a294 2
            if (png_ptr->push_length == 0)
               return;
d304 1
a304 3
      png_ptr->zstream.avail_out =
          (uInt) PNG_ROWBYTES(png_ptr->pixel_depth,
          png_ptr->iwidth) + 1;
d308 1
a308 2

#ifdef PNG_READ_gAMA_SUPPORTED
a315 1

a317 1

d319 1
a319 1
#ifdef PNG_READ_sBIT_SUPPORTED
a326 1

a328 1

d330 1
a330 1
#ifdef PNG_READ_cHRM_SUPPORTED
a337 1

a339 1

d341 1
a341 1
#ifdef PNG_READ_sRGB_SUPPORTED
a348 1

a350 1

d352 1
a352 1
#ifdef PNG_READ_iCCP_SUPPORTED
a359 1

a361 1

d363 1
a363 1
#ifdef PNG_READ_sPLT_SUPPORTED
a370 1

a372 1

d374 1
a374 1
#ifdef PNG_READ_tRNS_SUPPORTED
a381 1

a383 1

d385 1
a385 1
#ifdef PNG_READ_bKGD_SUPPORTED
a392 1

a394 1

d396 1
a396 1
#ifdef PNG_READ_hIST_SUPPORTED
a403 1

a405 1

d407 1
a407 1
#ifdef PNG_READ_pHYs_SUPPORTED
a414 1

a416 1

d418 1
a418 1
#ifdef PNG_READ_oFFs_SUPPORTED
a425 1

d429 1
a429 2

#ifdef PNG_READ_pCAL_SUPPORTED
a436 1

a438 1

d440 1
a440 1
#ifdef PNG_READ_sCAL_SUPPORTED
a447 1

a449 1

d451 1
a451 1
#ifdef PNG_READ_tIME_SUPPORTED
a458 1

a460 1

d462 1
a462 1
#ifdef PNG_READ_tEXt_SUPPORTED
d470 1
a470 2

      png_handle_tEXt(png_ptr, info_ptr, png_ptr->push_length);
a471 1

d473 1
a473 1
#ifdef PNG_READ_zTXt_SUPPORTED
d481 1
a481 2

      png_handle_zTXt(png_ptr, info_ptr, png_ptr->push_length);
a482 1

d484 1
a484 1
#ifdef PNG_READ_iTXt_SUPPORTED
d492 1
a492 2

      png_handle_iTXt(png_ptr, info_ptr, png_ptr->push_length);
a493 1

d502 1
a502 1
      png_handle_unknown(png_ptr, info_ptr, png_ptr->push_length);
d568 1
a568 3
   if (png_ptr == NULL)
      return;

a591 1

a631 1

d634 1
a634 1
      png_ptr->save_buffer = (png_bytep)png_malloc_warn(png_ptr,
a635 5
      if (png_ptr->save_buffer == NULL)
      {
        png_free(png_ptr, old_buffer);
        png_error(png_ptr, "Insufficient memory for save_buffer");
      }
d700 1
a700 2

         /* Check for overflow */
d708 2
a709 3

      png_process_IDAT_data(png_ptr, png_ptr->save_buffer_ptr, save_size);

d722 1
a722 2

         /* Check for overflow */
d730 2
a731 2

      png_process_IDAT_data(png_ptr, png_ptr->current_buffer_ptr, save_size);
d756 5
a760 8
   /* The caller checks for a non-zero buffer length. */
   if (!(buffer_length > 0) || buffer == NULL)
      png_error(png_ptr, "No IDAT data (internal error)");

   /* This routine must process all the data it has been given
    * before returning, calling the row callback as required to
    * handle the uncompressed results.
    */
d763 1
a763 6

   /* Keep going until the decompressed data is all processed
    * or the stream marked as finished.
    */
   while (png_ptr->zstream.avail_in > 0 &&
	  !(png_ptr->flags & PNG_FLAG_ZLIB_FINISHED))
d765 2
a766 8
      int ret;

      /* We have data for zlib, but we must check that zlib
       * has somewhere to put the results.  It doesn't matter
       * if we don't expect any results -- it may be the input
       * data is just the LZ end code.
       */
      if (!(png_ptr->zstream.avail_out > 0))
d768 8
a775 5
         png_ptr->zstream.avail_out =
             (uInt) PNG_ROWBYTES(png_ptr->pixel_depth,
             png_ptr->iwidth) + 1;
         png_ptr->zstream.next_out = png_ptr->row_buf;
      }
d777 8
a784 26
      /* Using Z_SYNC_FLUSH here means that an unterminated
       * LZ stream can still be handled (a stream with a missing
       * end code), otherwise (Z_NO_FLUSH) a future zlib
       * implementation might defer output and, therefore,
       * change the current behavior.  (See comments in inflate.c
       * for why this doesn't happen at present with zlib 1.2.5.)
       */
      ret = inflate(&png_ptr->zstream, Z_SYNC_FLUSH);

      /* Check for any failure before proceeding. */
      if (ret != Z_OK && ret != Z_STREAM_END)
      {
	 /* Terminate the decompression. */
	 png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;

         /* This may be a truncated stream (missing or
	  * damaged end code).  Treat that as a warning.
	  */
         if (png_ptr->row_number >= png_ptr->num_rows ||
	     png_ptr->pass > 6)
	    png_warning(png_ptr, "Truncated compressed data in IDAT");
	 else
	    png_error(png_ptr, "Decompression error in IDAT");

	 /* Skip the check on unprocessed input */
         return;
d786 1
a786 3

      /* Did inflate output any data? */
      if (png_ptr->zstream.next_out != png_ptr->row_buf)
d788 6
a793 6
	 /* Is this unexpected data after the last row?
	  * If it is, artificially terminate the LZ output
	  * here.
	  */
         if (png_ptr->row_number >= png_ptr->num_rows ||
	     png_ptr->pass > 6)
d795 8
a802 12
	    /* Extra data. */
	    png_warning(png_ptr, "Extra compressed data in IDAT");
            png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
	    /* Do no more processing; skip the unprocessed
	     * input check below.
	     */
            return;
	 }

	 /* Do we have a complete row? */
	 if (png_ptr->zstream.avail_out == 0)
	    png_push_process_row(png_ptr);
d804 2
a805 4

      /* And check for the end of the stream. */
      if (ret == Z_STREAM_END)
	 png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
a806 7

   /* All the data should have been processed, if anything
    * is left at this point we have bytes of IDAT data
    * after the zlib end code.
    */
   if (png_ptr->zstream.avail_in > 0)
      png_warning(png_ptr, "Extra compression data");
d822 2
a823 2
       png_ptr->row_buf + 1, png_ptr->prev_row + 1,
       (int)(png_ptr->row_buf[0]));
d831 2
a832 2
#ifdef PNG_READ_INTERLACING_SUPPORTED
   /* Blow up interlaced rows to full size */
d838 1
a838 1
             png_ptr->row_buf + 1, png_ptr->pass, png_ptr->transformations);
d850 1
a850 1
               png_read_push_finish_row(png_ptr); /* Updates png_ptr->pass */
d852 1
a852 2

            if (png_ptr->pass == 2) /* Pass 1 might be empty */
a859 1

a867 1

d870 1
a870 1
                  png_push_have_row(png_ptr, png_bytep_NULL);
a872 1

a874 1

d883 1
a883 2

            if (png_ptr->pass == 2) /* Skip top 4 generated rows */
a890 1

a892 1

a895 1

a900 1

d903 1
a903 1
                  png_push_have_row(png_ptr, png_bytep_NULL);
d906 1
a906 2

            if (png_ptr->pass == 4) /* Pass 3 might be empty */
a913 1

a915 1

a918 1

d924 1
a924 2

            if (png_ptr->pass == 4) /* Skip top two generated rows */
a931 1

a933 1

a936 1

a941 1

d944 1
a944 1
                  png_push_have_row(png_ptr, png_bytep_NULL);
d947 1
a947 2

            if (png_ptr->pass == 6) /* Pass 5 might be empty */
d949 1
a949 1
                  png_push_have_row(png_ptr, png_bytep_NULL);
a951 1

a953 1

a956 1

d962 1
a962 2

            if (png_ptr->pass == 6) /* Skip top generated row */
d964 1
a964 1
                  png_push_have_row(png_ptr, png_bytep_NULL);
a966 1

a972 1

d975 1
a975 2

                  png_push_have_row(png_ptr, png_bytep_NULL);
d992 1
a992 1
   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
d994 1
a994 1
   /* Start of interlace block */
d997 1
a997 1
   /* Offset to next interlace block */
d1000 1
a1000 1
   /* Start of interlace block in the y direction */
d1003 1
a1003 1
   /* Offset to next interlace block in the y direction */
a1015 1
#ifdef PNG_READ_INTERLACING_SUPPORTED
a1030 1

d1039 3
d1052 486
a1537 1
#endif /* PNG_READ_INTERLACING_SUPPORTED */
d1570 1
a1570 4

   if (png_ptr == NULL)
      return;

d1580 1
a1580 3
   if (png_ptr == NULL)
      return;

d1591 1
a1591 3
   if (png_ptr == NULL)
      return (NULL);

@


1.1.107.9
log
@update libpng
@
text
@d4 2
a5 2
 * Last changed in libpng 1.2.57 [(TO BE RELEASED)]
 * Copyright (c) 1998-2002,2004,2006-2010,2016 Glenn Randers-Pehrson
d688 3
a690 10
      else
      {
        if (old_buffer)
          png_memcpy(png_ptr->save_buffer, old_buffer,
             png_ptr->save_buffer_size);
        else if (png_ptr->save_buffer_size)
          png_error(png_ptr, "save_buffer error");
        png_free(png_ptr, old_buffer);
        png_ptr->save_buffer_max = new_max;
      }
@


