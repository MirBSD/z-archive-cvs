head	1.6;
access;
symbols
	png-1_2_57:1.1.107.8
	png-1_2_50:1.1.107.7
	png-1_2_35:1.1.107.6
	png-1_2_32:1.1.107.5
	png-1_2_26:1.1.107.4
	png-1_2_25:1.1.107.4
	MIRBSD_10:1.1.107.3.0.2
	MIRBSD_10_BASE:1.1.107.3
	png-1_2_18:1.1.107.3
	png-1_2_12:1.1.107.2
	MIRBSD_9_BASE:1.1.107.2
	png-1_2_10:1.1.107.2
	MIRBSD_8:1.1.107.1.0.2
	MIRBSD_8_BASE:1.1.107.1
	png-1_2_8:1.1.107.1
	libpng:1.1.107;
locks; strict;
comment	@ * @;


1.6
date	2017.04.15.15.26.47;	author tg;	state Exp;
branches;
next	1.5;
commitid	10058F23BCC5ED04858;

1.5
date	2013.08.06.18.49.29;	author tg;	state Exp;
branches;
next	1.4;
commitid	1005201454765C5CF06;

1.4
date	2009.03.15.20.08.45;	author tg;	state Exp;
branches;
next	1.3;
commitid	10049BD605834002F74;

1.3
date	2008.10.22.19.11.51;	author tg;	state Exp;
branches;
next	1.2;
commitid	10048FF7AEF54F9B169;

1.2
date	2008.03.23.17.54.54;	author tg;	state Exp;
branches;
next	1.1;
commitid	10047E6997C6BB35CA9;

1.1
date	2005.03.06.15.16.19;	author tg;	state Exp;
branches
	1.1.107.1;
next	;

1.1.107.1
date	2005.03.06.15.16.19;	author tg;	state Exp;
branches;
next	1.1.107.2;

1.1.107.2
date	2006.06.09.00.13.05;	author tg;	state Exp;
branches;
next	1.1.107.3;
commitid	1004488BD054F510AF1;

1.1.107.3
date	2007.05.22.20.25.37;	author tg;	state Exp;
branches;
next	1.1.107.4;
commitid	100465351CF4103214A;

1.1.107.4
date	2008.03.23.17.15.18;	author tg;	state Exp;
branches;
next	1.1.107.5;
commitid	10047E69020419198D8;

1.1.107.5
date	2008.10.22.18.55.40;	author tg;	state Exp;
branches;
next	1.1.107.6;
commitid	10048FF773834003AB5;

1.1.107.6
date	2009.03.15.19.57.25;	author tg;	state Exp;
branches;
next	1.1.107.7;
commitid	10049BD5DB90DBE42DE;

1.1.107.7
date	2013.08.06.17.35.04;	author tg;	state Exp;
branches;
next	1.1.107.8;
commitid	100520133D730551D16;

1.1.107.8
date	2017.04.15.15.00.13;	author tg;	state Exp;
branches;
next	;
commitid	10058F2359276DB0E16;


desc
@@


1.6
log
@a rather slow fastmergeâ€¦
@
text
@
/* pngget.c - retrieval of values from info struct
 *
 * Last changed in libpng 1.2.53 [February 26, 2015]
 * Copyright (c) 1998-2002,2004,2006-2015 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 *
 */

#define PNG_INTERNAL
#define PNG_NO_PEDANTIC_WARNINGS
#include "png.h"
#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)

png_uint_32 PNGAPI
png_get_valid(png_structp png_ptr, png_infop info_ptr, png_uint_32 flag)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return(info_ptr->valid & flag);

   else
      return(0);
}

png_uint_32 PNGAPI
png_get_rowbytes(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return(info_ptr->rowbytes);

   else
      return(0);
}

#ifdef PNG_INFO_IMAGE_SUPPORTED
png_bytepp PNGAPI
png_get_rows(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return(info_ptr->row_pointers);

   else
      return(0);
}
#endif

#ifdef PNG_EASY_ACCESS_SUPPORTED
/* Easy access to info, added in libpng-0.99 */
png_uint_32 PNGAPI
png_get_image_width(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return info_ptr->width;

   return (0);
}

png_uint_32 PNGAPI
png_get_image_height(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return info_ptr->height;

   return (0);
}

png_byte PNGAPI
png_get_bit_depth(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return info_ptr->bit_depth;

   return (0);
}

png_byte PNGAPI
png_get_color_type(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return info_ptr->color_type;

   return (0);
}

png_byte PNGAPI
png_get_filter_type(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return info_ptr->filter_type;

   return (0);
}

png_byte PNGAPI
png_get_interlace_type(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return info_ptr->interlace_type;

   return (0);
}

png_byte PNGAPI
png_get_compression_type(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return info_ptr->compression_type;

   return (0);
}

png_uint_32 PNGAPI
png_get_x_pixels_per_meter(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
#ifdef PNG_pHYs_SUPPORTED
   if (info_ptr->valid & PNG_INFO_pHYs)
   {
      png_debug1(1, "in %s retrieval function", "png_get_x_pixels_per_meter");

      if (info_ptr->phys_unit_type != PNG_RESOLUTION_METER)
          return (0);

      else
          return (info_ptr->x_pixels_per_unit);
   }
#else
   return (0);
#endif
   return (0);
}

png_uint_32 PNGAPI
png_get_y_pixels_per_meter(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
#ifdef PNG_pHYs_SUPPORTED
   if (info_ptr->valid & PNG_INFO_pHYs)
   {
      png_debug1(1, "in %s retrieval function", "png_get_y_pixels_per_meter");

      if (info_ptr->phys_unit_type != PNG_RESOLUTION_METER)
          return (0);

      else
          return (info_ptr->y_pixels_per_unit);
   }
#else
   return (0);
#endif
   return (0);
}

png_uint_32 PNGAPI
png_get_pixels_per_meter(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
#ifdef PNG_pHYs_SUPPORTED
   if (info_ptr->valid & PNG_INFO_pHYs)
   {
      png_debug1(1, "in %s retrieval function", "png_get_pixels_per_meter");

      if (info_ptr->phys_unit_type != PNG_RESOLUTION_METER ||
         info_ptr->x_pixels_per_unit != info_ptr->y_pixels_per_unit)
          return (0);

      else
          return (info_ptr->x_pixels_per_unit);
   }
#else
   return (0);
#endif
   return (0);
}

#ifdef PNG_FLOATING_POINT_SUPPORTED
float PNGAPI
png_get_pixel_aspect_ratio(png_structp png_ptr, png_infop info_ptr)
   {
   if (png_ptr != NULL && info_ptr != NULL)
#ifdef PNG_pHYs_SUPPORTED

   if (info_ptr->valid & PNG_INFO_pHYs)
   {
      png_debug1(1, "in %s retrieval function", "png_get_aspect_ratio");

      if (info_ptr->x_pixels_per_unit == 0)
         return ((float)0.0);

      else
         return ((float)((float)info_ptr->y_pixels_per_unit
            /(float)info_ptr->x_pixels_per_unit));
   }
#else
      return (0.0);
#endif
   return ((float)0.0);
}
#endif

png_int_32 PNGAPI
png_get_x_offset_microns(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
#ifdef PNG_oFFs_SUPPORTED

   if (info_ptr->valid & PNG_INFO_oFFs)
   {
      png_debug1(1, "in %s retrieval function", "png_get_x_offset_microns");

      if (info_ptr->offset_unit_type != PNG_OFFSET_MICROMETER)
          return (0);

      else
          return (info_ptr->x_offset);
   }
#else
      return (0);
#endif
   return (0);
}

png_int_32 PNGAPI
png_get_y_offset_microns(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)

#ifdef PNG_oFFs_SUPPORTED
   if (info_ptr->valid & PNG_INFO_oFFs)
   {
      png_debug1(1, "in %s retrieval function", "png_get_y_offset_microns");

      if (info_ptr->offset_unit_type != PNG_OFFSET_MICROMETER)
          return (0);

      else
          return (info_ptr->y_offset);
   }
#else
   return (0);
#endif
   return (0);
}

png_int_32 PNGAPI
png_get_x_offset_pixels(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)

#ifdef PNG_oFFs_SUPPORTED
   if (info_ptr->valid & PNG_INFO_oFFs)
   {
      png_debug1(1, "in %s retrieval function", "png_get_x_offset_microns");

      if (info_ptr->offset_unit_type != PNG_OFFSET_PIXEL)
          return (0);

      else
          return (info_ptr->x_offset);
   }
#else
   return (0);
#endif
   return (0);
}

png_int_32 PNGAPI
png_get_y_offset_pixels(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)

#ifdef PNG_oFFs_SUPPORTED
   if (info_ptr->valid & PNG_INFO_oFFs)
   {
      png_debug1(1, "in %s retrieval function", "png_get_y_offset_microns");

      if (info_ptr->offset_unit_type != PNG_OFFSET_PIXEL)
          return (0);

      else
          return (info_ptr->y_offset);
   }
#else
   return (0);
#endif
   return (0);
}

#if defined(PNG_INCH_CONVERSIONS) && defined(PNG_FLOATING_POINT_SUPPORTED)
png_uint_32 PNGAPI
png_get_pixels_per_inch(png_structp png_ptr, png_infop info_ptr)
{
   return ((png_uint_32)((float)png_get_pixels_per_meter(png_ptr, info_ptr)
     *.0254 +.5));
}

png_uint_32 PNGAPI
png_get_x_pixels_per_inch(png_structp png_ptr, png_infop info_ptr)
{
   return ((png_uint_32)((float)png_get_x_pixels_per_meter(png_ptr, info_ptr)
     *.0254 +.5));
}

png_uint_32 PNGAPI
png_get_y_pixels_per_inch(png_structp png_ptr, png_infop info_ptr)
{
   return ((png_uint_32)((float)png_get_y_pixels_per_meter(png_ptr, info_ptr)
     *.0254 +.5));
}

float PNGAPI
png_get_x_offset_inches(png_structp png_ptr, png_infop info_ptr)
{
   return ((float)png_get_x_offset_microns(png_ptr, info_ptr)
     *.00003937);
}

float PNGAPI
png_get_y_offset_inches(png_structp png_ptr, png_infop info_ptr)
{
   return ((float)png_get_y_offset_microns(png_ptr, info_ptr)
     *.00003937);
}

#ifdef PNG_pHYs_SUPPORTED
png_uint_32 PNGAPI
png_get_pHYs_dpi(png_structp png_ptr, png_infop info_ptr,
   png_uint_32 *res_x, png_uint_32 *res_y, int *unit_type)
{
   png_uint_32 retval = 0;

   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_pHYs))
   {
      png_debug1(1, "in %s retrieval function", "pHYs");

      if (res_x != NULL)
      {
         *res_x = info_ptr->x_pixels_per_unit;
         retval |= PNG_INFO_pHYs;
      }
      if (res_y != NULL)
      {
         *res_y = info_ptr->y_pixels_per_unit;
         retval |= PNG_INFO_pHYs;
      }
      if (unit_type != NULL)
      {
         *unit_type = (int)info_ptr->phys_unit_type;
         retval |= PNG_INFO_pHYs;
         if (*unit_type == 1)
         {
            if (res_x != NULL) *res_x = (png_uint_32)(*res_x * .0254 + .50);
            if (res_y != NULL) *res_y = (png_uint_32)(*res_y * .0254 + .50);
         }
      }
   }
   return (retval);
}
#endif /* PNG_pHYs_SUPPORTED */
#endif  /* PNG_INCH_CONVERSIONS && PNG_FLOATING_POINT_SUPPORTED */

/* png_get_channels really belongs in here, too, but it's been around longer */

#endif  /* PNG_EASY_ACCESS_SUPPORTED */

png_byte PNGAPI
png_get_channels(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return(info_ptr->channels);
   else
      return (0);
}

png_bytep PNGAPI
png_get_signature(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return(info_ptr->signature);
   else
      return (NULL);
}

#ifdef PNG_bKGD_SUPPORTED
png_uint_32 PNGAPI
png_get_bKGD(png_structp png_ptr, png_infop info_ptr,
   png_color_16p *background)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_bKGD)
      && background != NULL)
   {
      png_debug1(1, "in %s retrieval function", "bKGD");

      *background = &(info_ptr->background);
      return (PNG_INFO_bKGD);
   }
   return (0);
}
#endif

#ifdef PNG_cHRM_SUPPORTED
#ifdef PNG_FLOATING_POINT_SUPPORTED
png_uint_32 PNGAPI
png_get_cHRM(png_structp png_ptr, png_infop info_ptr,
   double *white_x, double *white_y, double *red_x, double *red_y,
   double *green_x, double *green_y, double *blue_x, double *blue_y)
{
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM))
   {
      png_debug1(1, "in %s retrieval function", "cHRM");

      if (white_x != NULL)
         *white_x = (double)info_ptr->x_white;
      if (white_y != NULL)
         *white_y = (double)info_ptr->y_white;
      if (red_x != NULL)
         *red_x = (double)info_ptr->x_red;
      if (red_y != NULL)
         *red_y = (double)info_ptr->y_red;
      if (green_x != NULL)
         *green_x = (double)info_ptr->x_green;
      if (green_y != NULL)
         *green_y = (double)info_ptr->y_green;
      if (blue_x != NULL)
         *blue_x = (double)info_ptr->x_blue;
      if (blue_y != NULL)
         *blue_y = (double)info_ptr->y_blue;
      return (PNG_INFO_cHRM);
   }
   return (0);
}
#endif
#ifdef PNG_FIXED_POINT_SUPPORTED
png_uint_32 PNGAPI
png_get_cHRM_fixed(png_structp png_ptr, png_infop info_ptr,
   png_fixed_point *white_x, png_fixed_point *white_y, png_fixed_point *red_x,
   png_fixed_point *red_y, png_fixed_point *green_x, png_fixed_point *green_y,
   png_fixed_point *blue_x, png_fixed_point *blue_y)
{
   png_debug1(1, "in %s retrieval function", "cHRM");

   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM))
   {
      if (white_x != NULL)
         *white_x = info_ptr->int_x_white;
      if (white_y != NULL)
         *white_y = info_ptr->int_y_white;
      if (red_x != NULL)
         *red_x = info_ptr->int_x_red;
      if (red_y != NULL)
         *red_y = info_ptr->int_y_red;
      if (green_x != NULL)
         *green_x = info_ptr->int_x_green;
      if (green_y != NULL)
         *green_y = info_ptr->int_y_green;
      if (blue_x != NULL)
         *blue_x = info_ptr->int_x_blue;
      if (blue_y != NULL)
         *blue_y = info_ptr->int_y_blue;
      return (PNG_INFO_cHRM);
   }
   return (0);
}
#endif
#endif

#ifdef PNG_gAMA_SUPPORTED
#ifdef PNG_FLOATING_POINT_SUPPORTED
png_uint_32 PNGAPI
png_get_gAMA(png_structp png_ptr, png_infop info_ptr, double *file_gamma)
{
   png_debug1(1, "in %s retrieval function", "gAMA");

   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_gAMA)
      && file_gamma != NULL)
   {
      *file_gamma = (double)info_ptr->gamma;
      return (PNG_INFO_gAMA);
   }
   return (0);
}
#endif
#ifdef PNG_FIXED_POINT_SUPPORTED
png_uint_32 PNGAPI
png_get_gAMA_fixed(png_structp png_ptr, png_infop info_ptr,
    png_fixed_point *int_file_gamma)
{
   png_debug1(1, "in %s retrieval function", "gAMA");

   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_gAMA)
      && int_file_gamma != NULL)
   {
      *int_file_gamma = info_ptr->int_gamma;
      return (PNG_INFO_gAMA);
   }
   return (0);
}
#endif
#endif

#ifdef PNG_sRGB_SUPPORTED
png_uint_32 PNGAPI
png_get_sRGB(png_structp png_ptr, png_infop info_ptr, int *file_srgb_intent)
{
   png_debug1(1, "in %s retrieval function", "sRGB");

   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_sRGB)
      && file_srgb_intent != NULL)
   {
      *file_srgb_intent = (int)info_ptr->srgb_intent;
      return (PNG_INFO_sRGB);
   }
   return (0);
}
#endif

#ifdef PNG_iCCP_SUPPORTED
png_uint_32 PNGAPI
png_get_iCCP(png_structp png_ptr, png_infop info_ptr,
             png_charpp name, int *compression_type,
             png_charpp profile, png_uint_32 *proflen)
{
   png_debug1(1, "in %s retrieval function", "iCCP");

   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_iCCP)
      && name != NULL && profile != NULL && proflen != NULL)
   {
      *name = info_ptr->iccp_name;
      *profile = info_ptr->iccp_profile;
      /* Compression_type is a dummy so the API won't have to change
       * if we introduce multiple compression types later.
       */
      *proflen = (int)info_ptr->iccp_proflen;
      *compression_type = (int)info_ptr->iccp_compression;
      return (PNG_INFO_iCCP);
   }
   return (0);
}
#endif

#ifdef PNG_sPLT_SUPPORTED
png_uint_32 PNGAPI
png_get_sPLT(png_structp png_ptr, png_infop info_ptr,
             png_sPLT_tpp spalettes)
{
   if (png_ptr != NULL && info_ptr != NULL && spalettes != NULL)
   {
     *spalettes = info_ptr->splt_palettes;
     return ((png_uint_32)info_ptr->splt_palettes_num);
   }
   return (0);
}
#endif

#ifdef PNG_hIST_SUPPORTED
png_uint_32 PNGAPI
png_get_hIST(png_structp png_ptr, png_infop info_ptr, png_uint_16p *hist)
{
   png_debug1(1, "in %s retrieval function", "hIST");

   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_hIST)
      && hist != NULL)
   {
      *hist = info_ptr->hist;
      return (PNG_INFO_hIST);
   }
   return (0);
}
#endif

png_uint_32 PNGAPI
png_get_IHDR(png_structp png_ptr, png_infop info_ptr,
   png_uint_32 *width, png_uint_32 *height, int *bit_depth,
   int *color_type, int *interlace_type, int *compression_type,
   int *filter_type)

{
   png_debug1(1, "in %s retrieval function", "IHDR");

   if (png_ptr == NULL || info_ptr == NULL || width == NULL ||
       height == NULL || bit_depth == NULL || color_type == NULL)
      return (0);

   *width = info_ptr->width;
   *height = info_ptr->height;
   *bit_depth = info_ptr->bit_depth;
   *color_type = info_ptr->color_type;

   if (compression_type != NULL)
      *compression_type = info_ptr->compression_type;

   if (filter_type != NULL)
      *filter_type = info_ptr->filter_type;

   if (interlace_type != NULL)
      *interlace_type = info_ptr->interlace_type;

   /* This is redundant if we can be sure that the info_ptr values were all
    * assigned in png_set_IHDR().  We do the check anyhow in case an
    * application has ignored our advice not to mess with the members
    * of info_ptr directly.
    */
   png_check_IHDR (png_ptr, info_ptr->width, info_ptr->height,
       info_ptr->bit_depth, info_ptr->color_type, info_ptr->interlace_type,
       info_ptr->compression_type, info_ptr->filter_type);

   return (1);
}

#ifdef PNG_oFFs_SUPPORTED
png_uint_32 PNGAPI
png_get_oFFs(png_structp png_ptr, png_infop info_ptr,
   png_int_32 *offset_x, png_int_32 *offset_y, int *unit_type)
{
   png_debug1(1, "in %s retrieval function", "oFFs");

   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_oFFs)
      && offset_x != NULL && offset_y != NULL && unit_type != NULL)
   {
      *offset_x = info_ptr->x_offset;
      *offset_y = info_ptr->y_offset;
      *unit_type = (int)info_ptr->offset_unit_type;
      return (PNG_INFO_oFFs);
   }
   return (0);
}
#endif

#ifdef PNG_pCAL_SUPPORTED
png_uint_32 PNGAPI
png_get_pCAL(png_structp png_ptr, png_infop info_ptr,
   png_charp *purpose, png_int_32 *X0, png_int_32 *X1, int *type, int *nparams,
   png_charp *units, png_charpp *params)
{
   png_debug1(1, "in %s retrieval function", "pCAL");

   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_pCAL)
       && purpose != NULL && X0 != NULL && X1 != NULL && type != NULL &&
       nparams != NULL && units != NULL && params != NULL)
   {
      *purpose = info_ptr->pcal_purpose;
      *X0 = info_ptr->pcal_X0;
      *X1 = info_ptr->pcal_X1;
      *type = (int)info_ptr->pcal_type;
      *nparams = (int)info_ptr->pcal_nparams;
      *units = info_ptr->pcal_units;
      *params = info_ptr->pcal_params;
      return (PNG_INFO_pCAL);
   }
   return (0);
}
#endif

#ifdef PNG_sCAL_SUPPORTED
#ifdef PNG_FLOATING_POINT_SUPPORTED
png_uint_32 PNGAPI
png_get_sCAL(png_structp png_ptr, png_infop info_ptr,
             int *unit, double *width, double *height)
{
    if (png_ptr != NULL && info_ptr != NULL &&
        (info_ptr->valid & PNG_INFO_sCAL))
    {
        *unit = info_ptr->scal_unit;
        *width = info_ptr->scal_pixel_width;
        *height = info_ptr->scal_pixel_height;
        return (PNG_INFO_sCAL);
    }
    return(0);
}
#else
#ifdef PNG_FIXED_POINT_SUPPORTED
png_uint_32 PNGAPI
png_get_sCAL_s(png_structp png_ptr, png_infop info_ptr,
             int *unit, png_charpp width, png_charpp height)
{
    if (png_ptr != NULL && info_ptr != NULL &&
        (info_ptr->valid & PNG_INFO_sCAL))
    {
        *unit = info_ptr->scal_unit;
        *width = info_ptr->scal_s_width;
        *height = info_ptr->scal_s_height;
        return (PNG_INFO_sCAL);
    }
    return(0);
}
#endif
#endif
#endif

#ifdef PNG_pHYs_SUPPORTED
png_uint_32 PNGAPI
png_get_pHYs(png_structp png_ptr, png_infop info_ptr,
   png_uint_32 *res_x, png_uint_32 *res_y, int *unit_type)
{
   png_uint_32 retval = 0;

   png_debug1(1, "in %s retrieval function", "pHYs");

   if (png_ptr != NULL && info_ptr != NULL &&
      (info_ptr->valid & PNG_INFO_pHYs))
   {
      if (res_x != NULL)
      {
         *res_x = info_ptr->x_pixels_per_unit;
         retval |= PNG_INFO_pHYs;
      }

      if (res_y != NULL)
      {
         *res_y = info_ptr->y_pixels_per_unit;
         retval |= PNG_INFO_pHYs;
      }

      if (unit_type != NULL)
      {
         *unit_type = (int)info_ptr->phys_unit_type;
         retval |= PNG_INFO_pHYs;
      }
   }
   return (retval);
}
#endif

png_uint_32 PNGAPI
png_get_PLTE(png_structp png_ptr, png_infop info_ptr, png_colorp *palette,
   int *num_palette)
{
   png_debug1(1, "in %s retrieval function", "PLTE");

   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_PLTE)
       && palette != NULL)
   {
      *palette = info_ptr->palette;
      *num_palette = info_ptr->num_palette;
      png_debug1(3, "num_palette = %d", *num_palette);
      return (PNG_INFO_PLTE);
   }
   return (0);
}

#ifdef PNG_sBIT_SUPPORTED
png_uint_32 PNGAPI
png_get_sBIT(png_structp png_ptr, png_infop info_ptr, png_color_8p *sig_bit)
{
   png_debug1(1, "in %s retrieval function", "sBIT");

   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_sBIT)
      && sig_bit != NULL)
   {
      *sig_bit = &(info_ptr->sig_bit);
      return (PNG_INFO_sBIT);
   }
   return (0);
}
#endif

#ifdef PNG_TEXT_SUPPORTED
png_uint_32 PNGAPI
png_get_text(png_structp png_ptr, png_infop info_ptr, png_textp *text_ptr,
   int *num_text)
{
   if (png_ptr != NULL && info_ptr != NULL && info_ptr->num_text > 0)
   {
      png_debug1(1, "in %s retrieval function",
         (png_ptr->chunk_name[0] == '\0' ? "text"
             : (png_const_charp)png_ptr->chunk_name));

      if (text_ptr != NULL)
         *text_ptr = info_ptr->text;

      if (num_text != NULL)
         *num_text = info_ptr->num_text;

      return ((png_uint_32)info_ptr->num_text);
   }
   if (num_text != NULL)
     *num_text = 0;
   return(0);
}
#endif

#ifdef PNG_tIME_SUPPORTED
png_uint_32 PNGAPI
png_get_tIME(png_structp png_ptr, png_infop info_ptr, png_timep *mod_time)
{
   png_debug1(1, "in %s retrieval function", "tIME");

   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_tIME)
       && mod_time != NULL)
   {
      *mod_time = &(info_ptr->mod_time);
      return (PNG_INFO_tIME);
   }
   return (0);
}
#endif

#ifdef PNG_tRNS_SUPPORTED
png_uint_32 PNGAPI
png_get_tRNS(png_structp png_ptr, png_infop info_ptr,
   png_bytep *trans, int *num_trans, png_color_16p *trans_values)
{
   png_uint_32 retval = 0;
   if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS))
   {
      png_debug1(1, "in %s retrieval function", "tRNS");

      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      {
          if (trans != NULL)
          {
             *trans = info_ptr->trans;
             retval |= PNG_INFO_tRNS;
          }

          if (trans_values != NULL)
             *trans_values = &(info_ptr->trans_values);
      }
      else /* if (info_ptr->color_type != PNG_COLOR_TYPE_PALETTE) */
      {
          if (trans_values != NULL)
          {
             *trans_values = &(info_ptr->trans_values);
             retval |= PNG_INFO_tRNS;
          }

          if (trans != NULL)
             *trans = NULL;
      }
      if (num_trans != NULL)
      {
         *num_trans = info_ptr->num_trans;
         retval |= PNG_INFO_tRNS;
      }
   }
   return (retval);
}
#endif

#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED
png_uint_32 PNGAPI
png_get_unknown_chunks(png_structp png_ptr, png_infop info_ptr,
             png_unknown_chunkpp unknowns)
{
   if (png_ptr != NULL && info_ptr != NULL && unknowns != NULL)
   {
     *unknowns = info_ptr->unknown_chunks;
     return ((png_uint_32)info_ptr->unknown_chunks_num);
   }
   return (0);
}
#endif

#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
png_byte PNGAPI
png_get_rgb_to_gray_status (png_structp png_ptr)
{
   return (png_byte)(png_ptr? png_ptr->rgb_to_gray_status : 0);
}
#endif

#ifdef PNG_USER_CHUNKS_SUPPORTED
png_voidp PNGAPI
png_get_user_chunk_ptr(png_structp png_ptr)
{
   return (png_ptr? png_ptr->user_chunk_ptr : NULL);
}
#endif

png_uint_32 PNGAPI
png_get_compression_buffer_size(png_structp png_ptr)
{
   return (png_uint_32)(png_ptr? png_ptr->zbuf_size : 0L);
}

#ifdef PNG_SET_USER_LIMITS_SUPPORTED
/* These functions were added to libpng 1.2.6 but not enabled
* by default. They will be enabled in libpng-1.4.0 */
png_uint_32 PNGAPI
png_get_user_width_max (png_structp png_ptr)
{
    return (png_ptr? png_ptr->user_width_max : 0);
}
png_uint_32 PNGAPI
png_get_user_height_max (png_structp png_ptr)
{
    return (png_ptr? png_ptr->user_height_max : 0);
}
#endif /* ?PNG_SET_USER_LIMITS_SUPPORTED */

#endif /* PNG_READ_SUPPORTED || PNG_WRITE_SUPPORTED */
@


1.5
log
@merge, rebase/minify, fix
@
text
@d4 2
a5 2
 * Last changed in libpng 1.2.43 [February 25, 2010]
 * Copyright (c) 1998-2010 Glenn Randers-Pehrson
@


1.4
log
@SECURITY update; prodded by bsiegert@@
@
text
@d4 2
a5 3
 * Last changed in libpng 1.2.30 [August 15, 2008]
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1998-2008 Glenn Randers-Pehrson
d8 5
d16 1
d25 1
d35 1
d40 1
a40 1
#if defined(PNG_INFO_IMAGE_SUPPORTED)
d46 1
d53 1
a53 1
/* easy access to info, added in libpng-0.99 */
a57 1
   {
d59 1
a59 1
   }
a66 1
   {
d68 1
a68 1
   }
a75 1
   {
d77 1
a77 1
   }
a84 1
   {
d86 1
a86 1
   }
a93 1
   {
d95 1
a95 1
   }
a102 1
   {
d104 1
a104 1
   }
a111 1
   {
d113 1
a113 1
   }
d121 1
a121 1
#if defined(PNG_pHYs_SUPPORTED)
d125 1
d128 3
a130 1
      else return (info_ptr->x_pixels_per_unit);
d142 1
a142 1
#if defined(PNG_pHYs_SUPPORTED)
d146 1
d149 3
a151 1
      else return (info_ptr->y_pixels_per_unit);
d163 1
a163 1
#if defined(PNG_pHYs_SUPPORTED)
d167 1
d171 3
a173 1
      else return (info_ptr->x_pixels_per_unit);
d186 2
a187 1
#if defined(PNG_pHYs_SUPPORTED)
d191 1
d194 1
d200 1
a200 1
   return (0.0);
d210 2
a211 1
#if defined(PNG_oFFs_SUPPORTED)
d215 1
d218 3
a220 1
      else return (info_ptr->x_offset);
d223 1
a223 1
   return (0);
d232 2
a233 1
#if defined(PNG_oFFs_SUPPORTED)
d237 1
d240 3
a242 1
      else return (info_ptr->y_offset);
d254 2
a255 1
#if defined(PNG_oFFs_SUPPORTED)
d259 1
d262 3
a264 1
      else return (info_ptr->x_offset);
d276 2
a277 1
#if defined(PNG_oFFs_SUPPORTED)
d281 1
d284 3
a286 1
      else return (info_ptr->y_offset);
d330 1
a330 1
#if defined(PNG_pHYs_SUPPORTED)
d340 1
d389 1
a389 1
#if defined(PNG_bKGD_SUPPORTED)
d398 1
d406 1
a406 1
#if defined(PNG_cHRM_SUPPORTED)
d416 1
d445 2
a448 1
      png_debug1(1, "in %s retrieval function", "cHRM");
d472 1
a472 1
#if defined(PNG_gAMA_SUPPORTED)
d477 2
a481 1
      png_debug1(1, "in %s retrieval function", "gAMA");
d493 2
a497 1
      png_debug1(1, "in %s retrieval function", "gAMA");
d506 1
a506 1
#if defined(PNG_sRGB_SUPPORTED)
d510 2
a514 1
      png_debug1(1, "in %s retrieval function", "sRGB");
d522 1
a522 1
#if defined(PNG_iCCP_SUPPORTED)
d528 2
a532 1
      png_debug1(1, "in %s retrieval function", "iCCP");
d535 3
a537 2
      /* compression_type is a dummy so the API won't have to change
         if we introduce multiple compression types later. */
d546 1
a546 1
#if defined(PNG_sPLT_SUPPORTED)
d560 1
a560 1
#if defined(PNG_hIST_SUPPORTED)
d564 2
a568 1
      png_debug1(1, "in %s retrieval function", "hIST");
d583 30
a612 37
   if (png_ptr != NULL && info_ptr != NULL && width != NULL && height != NULL &&
      bit_depth != NULL && color_type != NULL)
   {
      png_debug1(1, "in %s retrieval function", "IHDR");
      *width = info_ptr->width;
      *height = info_ptr->height;
      *bit_depth = info_ptr->bit_depth;
      if (info_ptr->bit_depth < 1 || info_ptr->bit_depth > 16)
        png_error(png_ptr, "Invalid bit depth");
      *color_type = info_ptr->color_type;
      if (info_ptr->color_type > 6)
        png_error(png_ptr, "Invalid color type");
      if (compression_type != NULL)
         *compression_type = info_ptr->compression_type;
      if (filter_type != NULL)
         *filter_type = info_ptr->filter_type;
      if (interlace_type != NULL)
         *interlace_type = info_ptr->interlace_type;

      /* check for potential overflow of rowbytes */
      if (*width == 0 || *width > PNG_UINT_31_MAX)
        png_error(png_ptr, "Invalid image width");
      if (*height == 0 || *height > PNG_UINT_31_MAX)
        png_error(png_ptr, "Invalid image height");
      if (info_ptr->width > (PNG_UINT_32_MAX
                 >> 3)      /* 8-byte RGBA pixels */
                 - 64       /* bigrowbuf hack */
                 - 1        /* filter byte */
                 - 7*8      /* rounding of width to multiple of 8 pixels */
                 - 8)       /* extra max_pixel_depth pad */
      {
         png_warning(png_ptr,
            "Width too large for libpng to process image data.");
      }
      return (1);
   }
   return (0);
d615 1
a615 1
#if defined(PNG_oFFs_SUPPORTED)
d620 2
a624 1
      png_debug1(1, "in %s retrieval function", "oFFs");
d634 1
a634 1
#if defined(PNG_pCAL_SUPPORTED)
d640 2
d643 2
a644 2
      && purpose != NULL && X0 != NULL && X1 != NULL && type != NULL &&
      nparams != NULL && units != NULL && params != NULL)
a645 1
      png_debug1(1, "in %s retrieval function", "pCAL");
d659 1
a659 1
#if defined(PNG_sCAL_SUPPORTED)
d666 1
a666 1
       (info_ptr->valid & PNG_INFO_sCAL))
d682 1
a682 1
       (info_ptr->valid & PNG_INFO_sCAL))
d695 1
a695 1
#if defined(PNG_pHYs_SUPPORTED)
d702 2
a706 1
      png_debug1(1, "in %s retrieval function", "pHYs");
d712 1
d718 1
d733 2
a737 1
      png_debug1(1, "in %s retrieval function", "PLTE");
d746 1
a746 1
#if defined(PNG_sBIT_SUPPORTED)
d750 2
a754 1
      png_debug1(1, "in %s retrieval function", "sBIT");
d762 1
a762 1
#if defined(PNG_TEXT_SUPPORTED)
d772 1
d775 1
d778 1
d787 1
a787 1
#if defined(PNG_tIME_SUPPORTED)
d791 2
a795 1
      png_debug1(1, "in %s retrieval function", "tIME");
d803 1
a803 1
#if defined(PNG_tRNS_SUPPORTED)
d812 1
d820 1
d831 1
d845 1
a845 1
#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
d859 1
a859 1
#if defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
d867 1
a867 1
#if defined(PNG_USER_CHUNKS_SUPPORTED)
a874 1
#ifdef PNG_WRITE_SUPPORTED
a879 1
#endif
d882 2
a883 1
/* These functions were added to libpng 1.2.6 */
a894 1
 
@


1.3
log
@merge libpng upgrade

major version bump because function signature of png_decompress_chunk
changed (return value to void)
@
text
@d123 1
a123 1
      png_debug1(1, "in %s retrieval function\n", "png_get_x_pixels_per_meter");
d141 1
a141 1
      png_debug1(1, "in %s retrieval function\n", "png_get_y_pixels_per_meter");
d159 1
a159 1
      png_debug1(1, "in %s retrieval function\n", "png_get_pixels_per_meter");
d179 1
a179 1
      png_debug1(1, "in %s retrieval function\n", "png_get_aspect_ratio");
d200 1
a200 1
      png_debug1(1, "in %s retrieval function\n", "png_get_x_offset_microns");
d218 1
a218 1
      png_debug1(1, "in %s retrieval function\n", "png_get_y_offset_microns");
d236 1
a236 1
      png_debug1(1, "in %s retrieval function\n", "png_get_x_offset_microns");
d254 1
a254 1
      png_debug1(1, "in %s retrieval function\n", "png_get_y_offset_microns");
d310 1
a310 1
      png_debug1(1, "in %s retrieval function\n", "pHYs");
d367 1
a367 1
      png_debug1(1, "in %s retrieval function\n", "bKGD");
d384 1
a384 1
      png_debug1(1, "in %s retrieval function\n", "cHRM");
d415 1
a415 1
      png_debug1(1, "in %s retrieval function\n", "cHRM");
d447 1
a447 1
      png_debug1(1, "in %s retrieval function\n", "gAMA");
d462 1
a462 1
      png_debug1(1, "in %s retrieval function\n", "gAMA");
d478 1
a478 1
      png_debug1(1, "in %s retrieval function\n", "sRGB");
d495 1
a495 1
      png_debug1(1, "in %s retrieval function\n", "iCCP");
d529 1
a529 1
      png_debug1(1, "in %s retrieval function\n", "hIST");
d547 1
a547 1
      png_debug1(1, "in %s retrieval function\n", "IHDR");
d591 1
a591 1
      png_debug1(1, "in %s retrieval function\n", "oFFs");
d611 1
a611 1
      png_debug1(1, "in %s retrieval function\n", "pCAL");
d671 1
a671 1
      png_debug1(1, "in %s retrieval function\n", "pHYs");
d699 1
a699 1
      png_debug1(1, "in %s retrieval function\n", "PLTE");
d702 1
a702 1
      png_debug1(3, "num_palette = %d\n", *num_palette);
d715 1
a715 1
      png_debug1(1, "in %s retrieval function\n", "sBIT");
d730 1
a730 1
      png_debug1(1, "in %s retrieval function\n",
d752 1
a752 1
      png_debug1(1, "in %s retrieval function\n", "tIME");
d768 1
a768 1
      png_debug1(1, "in %s retrieval function\n", "tRNS");
d838 1
a838 1
/* these functions were added to libpng 1.2.6 */
@


1.2
log
@merge and fix for __CRAZY=Yes
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.15 January 5, 2007
d6 1
a6 1
 * Copyright (c) 1998-2007 Glenn Randers-Pehrson
a12 1

d124 1
a124 1
      if(info_ptr->phys_unit_type != PNG_RESOLUTION_METER)
d142 1
a142 1
      if(info_ptr->phys_unit_type != PNG_RESOLUTION_METER)
d160 1
a160 1
      if(info_ptr->phys_unit_type != PNG_RESOLUTION_METER ||
d201 1
a201 1
      if(info_ptr->offset_unit_type != PNG_OFFSET_MICROMETER)
d219 1
a219 1
      if(info_ptr->offset_unit_type != PNG_OFFSET_MICROMETER)
d237 1
a237 1
      if(info_ptr->offset_unit_type != PNG_OFFSET_PIXEL)
d255 1
a255 1
      if(info_ptr->offset_unit_type != PNG_OFFSET_PIXEL)
d325 1
a325 1
         if(*unit_type == 1)
d786 1
a786 1
          if(trans != NULL)
d789 1
a789 1
      if(num_trans != NULL)
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
 * libpng 1.2.8 - December 3, 2004
d6 1
a6 1
 * Copyright (c) 1998-2004 Glenn Randers-Pehrson
d14 2
d515 1
d517 3
a519 1
   return ((png_uint_32)info_ptr->splt_palettes_num);
d806 1
d808 3
a810 1
   return ((png_uint_32)info_ptr->unknown_chunks_num);
a837 90
#ifndef PNG_1_0_X
#ifdef PNG_ASSEMBLER_CODE_SUPPORTED
/* this function was added to libpng 1.2.0 and should exist by default */
png_uint_32 PNGAPI
png_get_asm_flags (png_structp png_ptr)
{
    return (png_uint_32)(png_ptr? png_ptr->asm_flags : 0L);
}

/* this function was added to libpng 1.2.0 and should exist by default */
png_uint_32 PNGAPI
png_get_asm_flagmask (int flag_select)
{
    png_uint_32 settable_asm_flags = 0;

    if (flag_select & PNG_SELECT_READ)
        settable_asm_flags |=
          PNG_ASM_FLAG_MMX_READ_COMBINE_ROW  |
          PNG_ASM_FLAG_MMX_READ_INTERLACE    |
          PNG_ASM_FLAG_MMX_READ_FILTER_SUB   |
          PNG_ASM_FLAG_MMX_READ_FILTER_UP    |
          PNG_ASM_FLAG_MMX_READ_FILTER_AVG   |
          PNG_ASM_FLAG_MMX_READ_FILTER_PAETH ;
          /* no non-MMX flags yet */

#if 0
    /* GRR:  no write-flags yet, either, but someday... */
    if (flag_select & PNG_SELECT_WRITE)
        settable_asm_flags |=
          PNG_ASM_FLAG_MMX_WRITE_ [whatever] ;
#endif /* 0 */

    return settable_asm_flags;  /* _theoretically_ settable capabilities only */
}
#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */


#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
    /* GRR:  could add this:   && defined(PNG_MMX_CODE_SUPPORTED) */
/* this function was added to libpng 1.2.0 */
png_uint_32 PNGAPI
png_get_mmx_flagmask (int flag_select, int *compilerID)
{
    png_uint_32 settable_mmx_flags = 0;

    if (flag_select & PNG_SELECT_READ)
        settable_mmx_flags |=
          PNG_ASM_FLAG_MMX_READ_COMBINE_ROW  |
          PNG_ASM_FLAG_MMX_READ_INTERLACE    |
          PNG_ASM_FLAG_MMX_READ_FILTER_SUB   |
          PNG_ASM_FLAG_MMX_READ_FILTER_UP    |
          PNG_ASM_FLAG_MMX_READ_FILTER_AVG   |
          PNG_ASM_FLAG_MMX_READ_FILTER_PAETH ;
#if 0
    /* GRR:  no MMX write support yet, but someday... */
    if (flag_select & PNG_SELECT_WRITE)
        settable_mmx_flags |=
          PNG_ASM_FLAG_MMX_WRITE_ [whatever] ;
#endif /* 0 */

    if (compilerID != NULL) {
#ifdef PNG_USE_PNGVCRD
        *compilerID = 1;    /* MSVC */
#else
#ifdef PNG_USE_PNGGCCRD
        *compilerID = 2;    /* gcc/gas */
#else
        *compilerID = -1;   /* unknown (i.e., no asm/MMX code compiled) */
#endif
#endif
    }

    return settable_mmx_flags;  /* _theoretically_ settable capabilities only */
}

/* this function was added to libpng 1.2.0 */
png_byte PNGAPI
png_get_mmx_bitdepth_threshold (png_structp png_ptr)
{
    return (png_byte)(png_ptr? png_ptr->mmx_bitdepth_threshold : 0);
}

/* this function was added to libpng 1.2.0 */
png_uint_32 PNGAPI
png_get_mmx_rowbytes_threshold (png_structp png_ptr)
{
    return (png_uint_32)(png_ptr? png_ptr->mmx_rowbytes_threshold : 0L);
}
#endif /* ?PNG_ASSEMBLER_CODE_SUPPORTED */

d851 1
d853 1
a853 1
#endif /* ?PNG_1_0_X */
@


1.1.107.1
log
@libpng-1_2_8 with the following directories removed:
- contrib
- projects
- scripts
@
text
@@


1.1.107.2
log
@there's a newer libpng out there
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.9 April 14, 2006
d6 1
a6 1
 * Copyright (c) 1998-2006 Glenn Randers-Pehrson
a13 2
#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)

a918 1
#endif /* ?PNG_1_0_X */
d934 1
a934 1
#endif /* PNG_READ_SUPPORTED || PNG_WRITE_SUPPORTED */
@


1.1.107.3
log
@Upgrade libpng (fixes some holes)
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.15 January 5, 2007
d6 1
a6 1
 * Copyright (c) 1998-2007 Glenn Randers-Pehrson
d832 1
a833 1
#ifndef PNG_1_0_X
a837 1
#ifdef PNG_MMX_CODE_SUPPORTED
a838 3
#else
    return (png_ptr? 0L: 0L);
#endif
a844 1
#ifdef PNG_MMX_CODE_SUPPORTED
a864 3
#else
    return (0L);
#endif /* PNG_MMX_CODE_SUPPORTED */
d866 1
d869 1
a874 1
#if defined(PNG_MMX_CODE_SUPPORTED)
a904 3
#else
    return (0L);
#endif /* ?PNG_MMX_CODE_SUPPORTED */
a910 1
#if defined(PNG_MMX_CODE_SUPPORTED)
a911 3
#else
    return (png_ptr? 0: 0);
#endif /* ?PNG_MMX_CODE_SUPPORTED */
a917 1
#if defined(PNG_MMX_CODE_SUPPORTED)
a918 3
#else
    return (png_ptr? 0L: 0L);
#endif /* ?PNG_MMX_CODE_SUPPORTED */
d920 1
a921 1
#endif /* ?PNG_ASSEMBLER_CODE_SUPPORTED */
@


1.1.107.4
log
@Import libpng-1.2.25 with the following change log.
Requested by bsiegert@@ due to security fix relevance.

version 1.2.19beta1 [May 18, 2007]
  Changed "const static" to "static PNG_CONST" everywhere, mostly undoing
    change of libpng-1.2.17beta2.  Changed other "const" to "PNG_CONST"
  Changed some handling of unused parameters, to avoid compiler warnings.
    "if (unused == NULL) return;" becomes "unused = unused".

version 1.2.19beta2 [May 18, 2007]
  Only use the valid bits of tRNS value in png_do_expand() (Brian Cartier)

version 1.2.19beta3 [May 19, 2007]
  Add some "png_byte" typecasts in png_check_keyword() and write new_key
  instead of key in zTXt chunk (Kevin Ryde).

version 1.2.19beta4 [May 21, 2007]
  Add png_snprintf() function and use it in place of sprint() for improved
    defense against buffer overflows.

version 1.2.19beta5 [May 21, 2007]
  Fixed png_handle_tRNS() to only use the valid bits of tRNS value.
  Changed handling of more unused parameters, to avoid compiler warnings.
  Removed some PNG_CONST in pngwutil.c to avoid compiler warnings.

version 1.2.19beta6 [May 22, 2007]
  Added some #ifdef PNG_MMX_CODE_SUPPORTED where needed in pngvcrd.c
  Added a special "_MSC_VER" case that defines png_snprintf to _snprintf

version 1.2.19beta7 [May 22, 2007]
  Squelched png_squelch_warnings() in pnggccrd.c and added an
    #ifdef PNG_MMX_CODE_SUPPORTED block around the declarations that caused
    the warnings that png_squelch_warnings was squelching.

version 1.2.19beta8 [May 22, 2007]
  Removed __MMX__ from test in pngconf.h.

version 1.2.19beta9 [May 23, 2007]
  Made png_squelch_warnings() available via PNG_SQUELCH_WARNINGS macro.
  Revised png_squelch_warnings() so it might work.
  Updated makefile.sgcc and makefile.solaris; added makefile.solaris-x86.

version 1.2.19beta10 [May 24, 2007]
  Resquelched png_squelch_warnings(), use "__attribute__((used))" instead.

version 1.2.19beta11 [May 28, 2007]
  Return 0 from png_get_sPLT() and png_get_unknown_chunks() if png_ptr is NULL;
    changed three remaining instances of png_strcpy() to png_strncpy() (David
    Hill).
  Make test for NULL row_buf at the beginning of png_do_read_transformations
    unconditional.

version 1.2.19beta12 [May 28, 2007]
  Revised pnggccrd.c.

version 1.2.19beta13 [June 14, 2007]
  Prefer PNG_USE_PNGVCRD when _MSC_VER is defined in pngconf.h

version 1.2.19beta14 [June 16, 2007]
  Fix bug with handling of 16-bit transparency, introduced in 1.2.19beta2

version 1.2.19beta15 [June 17, 2007]
  Revised pnggccrd.c.

version 1.2.19beta16 [June 18, 2007]
  Revised pnggccrd.c again.
  Updated contrib/gregbook.
  Changed '#include "pnggccrd.c"' to 'include "$srcdir/pnggccrd.c"'
    in configure.ac

version 1.2.19beta17 [June 19, 2007]
  Revised many of the makefiles, to set -DPNG_NO_MMX_CODE where needed
    and to not use -O3 unless -DPNG_NO_MMX_CODE is also set.

version 1.2.19beta18 [June 23, 2007]
  Replaced some C++ style comments with C style comments in pnggccrd.c.
  Copied optimized C code from pnggccrd.c to pngrutil.c, removed dependency
    on pnggccrd.o from many makefiles.
  Added sl and dylib to list of extensions be installed by Makefile.am

version 1.2.19beta19 [June 28, 2007]
  Fixed testing PNG_RGB_TO_GRAY_ERR & PNG_RGB_TO_GRAY_WARN in pngrtran.c
  More cleanup of pnggccrd.c and pngvcrd.c

version 1.2.19beta20 [June 29, 2007]
  Rebuilt Makefile.in and configure using libtool-1.5.24.
  Fixed typo in pnggccrd.c

version 1.2.19beta21 [June 30, 2007]
  More revision of pnggccrd.c
  Added "test" target to Makefile.in and Makefile.am

version 1.2.19beta22 [July 3, 2007]
  Added info about pngrutil/pnggccrd/pngvcrd to png_get_header_version()
  Fix type definition of dummy_value_a, b in pnggccrd.c

version 1.2.19beta23 [July 10, 2007]
  Revert change to type definition of dummy_value_a, b in pnggccrd.c
  Make sure __PIC__ is defined in pnggccrd.c when PIC is defined.
  Require gcc-4.1 or better to use PNG_HAVE_MMX_FILTER_ROW on x86_64 platforms

version 1.2.19beta24 [July 14, 2007]
  Added PNG_NO_READ_FILTER, PNG_NO_WRITE_FILTER, PNG_NO_WARNING macros.
  Added contrib/pngminim to demonstrate building minimal encoder and decoder

version 1.2.19beta25 [July 15, 2007]
  Removed the new PNG_NO_READ_FILTER macro since it would make the library
    unable to read valid PNG files, and filtering is at the heart of the
    PNG format.

version 1.2.19beta26 [July 16, 2007]
  Changed "png_free(str)" to "png_free(png_ptr,str)" in pngrutil.c WinCE
    code (Yves Piguet).  This bug was introduced in libpng-1.2.14.
  Updated scripts/CMakeLists.txt
  Relocated a misplaced #endif in pnggccrd.c

version 1.2.19beta27 [July 17, 2007]
  Fixed incorrect stride and number of bytes copied (was 4 instead of
    6 bytes) in the cleanup loop of pnggccrd.c and pngvcrd.c for handling
    the end of 48-bit interlaced rows (Glenn R-P).

version 1.2.19beta28 [July 19, 2007]
  Removed requirement for gcc-4.1 or better to use PNG_HAVE_MMX_FILTER_ROW
    on x86_64 platforms
  Added png_warning() in pngrutil.c for short iCCP, iTXt, sPLT, or zTXT chunks.
  Revised pngtest.c so warnings are displayed regardless of PNG_NO_STDIO.

version 1.2.19beta29 [July 20, 2007]
  Fix typo in pnggccrd.c (%%eax should be %%ax in secondloop48)

version 1.2.19beta30 [July 26, 2007]
  Revised pnggccrd.c

version 1.2.19beta31 [July 27, 2007]
  Fix typos in pnggccrd.c

version 1.0.27rc1 and 1.2.19rc1 [July 31, 2007]
  Disable PNG_MMX_CODE_SUPPORTED when PNG_ASSEMBLER_CODE_SUPPORTED is off.
  Enable PNG_MMX_READ_FILTER_* by default, except when gcc-3.x is being
    used (they were inadvertently disabled in libpng-1.2.19beta23).
  Fix some debugging statements in pnggccrd.c and pngrutil.c
  Added information about disabling the MMX code in libpng documentation.

version 1.0.27rc2 and 1.2.19rc2 [August 4, 2007]
  Removed some "#if 0" blocks.
  Made a global struct local in pngvcrd.c to make it thread safe.
  Issue a png_error() if application attempts to transform a row tht
    has not been initialized.

version 1.0.27rc3 and 1.2.19rc3 [August 9, 2007]
  Slightly revised pngvcrd.c

version 1.0.27rc4 and 1.2.19rc4 [August 9, 2007]
  Revised pnggccrd.c debugging change of rc1, which was broken.
  Revised scripts/CMakeLists.txt
  Change default to PNG_NO_GLOBAL_ARRAYS for MSVC.
  Turn off PNG_FLAG_ROW_INIT flag when setting transforms that expand pixels.

version 1.0.27rc5 and 1.2.19rc5 [August 10, 2007]
  Fix typo (missing '"') in pnggccrd.c
  Revise handling of png_strtod in recent versions of WINCE

version 1.0.27rc6 and 1.2.19rc6 [August 15, 2007]
  Fix typo (missing ',') in contrib/gregbook/readpng2.c
  Undid row initialization error exit added to rc2 and rc4.

version 1.0.27 and 1.2.19 [August 18, 2007]
  Conditionally restored row initialization error exit.

version 1.2.20beta01 [August 19, 2007]
  Fixed problem with compiling pnggccrd.c on Intel-Apple platforms.
  Changed png_malloc() to png_malloc_warn() in png_set_sPLT().
  Added PNG_NO_ERROR_TEXT feature, with demo in contrib/pngminim
  Removed define PNG_WARN_UNINITIALIZED_ROW 1 /* 0: warning; 1: error */
    because it caused some trouble.

version 1.2.20beta02 [August 20, 2007]
  Avoid compiling pnggccrd.c on Intel-Apple platforms.

version 1.2.20beta03 [August 20, 2007]
  Added "/D PNG_NO_MMX_CODE" to the non-mmx builds of projects/visualc6
    and visualc71.

version 1.2.20beta04 [August 21, 2007]
  Revised pngvcrd.c for improved efficiency (Steve Snyder).

version 1.2.20rc1 [August 23, 2007]
  Revised pngconf.h to set PNG_NO_MMX_CODE for gcc-3.x compilers.

version 1.2.20rc2 [August 27, 2007]
  Revised scripts/CMakeLists.txt
  Revised #ifdefs to ensure one and only one of pnggccrd.c, pngvcrd.c,
    or part of pngrutil.c is selected.

version 1.2.20rc3 [August 30, 2007]
  Remove a little more code in pngwutil.c when PNG_NO_WRITE_FILTER is selected.
  Added /D _CRT_SECURE_NO_WARNINGS to visual6c and visualc71 projects.
  Compile png_mmx_support() in png.c even when PNG_NO_MMX_CODE is defined.
  Restored a "superfluous" #ifdef that was removed from 1.2.20rc2 pnggccrd.c,
    breaking the png_mmx_support() function.

version 1.2.20rc4 [September 1, 2007]
  Removed Intel contributions (MMX, Optimized C).

version 1.2.20rc5 [September 2, 2007]
  Restored configure and Makefile.in to rc3 and put a snippet of code in
    pnggccrd.c, to ensure configure makes the same PNG_NO_MMX_CODE selection

version 1.2.20rc6 [September 2, 2007]
  Fixed bugs in scripts/CMakeLists.txt
  Removed pngvcrd.c references from msvc projects.

version 1.0.28 and 1.2.20 [September 8, 2007]
  Removed "(NO READ SUPPORT)" from png_get_header_version() string.

version 1.2.21beta1 [September 14, 2007]
  Fixed various mistakes reported by George Cook and Jeff Phillips:
  logical vs bitwise NOT in pngrtran.c, bug introduced in 1.2.19rc2
  16-bit cheap transparency expansion, bug introduced in 1.2.19beta2
  errors with sizeof(unknown_chunk.name), bugs introduced in 1.2.19beta11
  <= compare with unsigned var in pngset.c, should be ==.

version 1.2.21beta2 [September 18, 2007]
  Removed some extraneous typecasts.

version 1.2.21rc1 [September 25, 2007]
  Fixed potential out-of-bounds reads in png_handle_pCAL() and
    png_handle_ztXt() ("flayer" results reported by Tavis Ormandy).

version 1.2.21rc2 [September 26, 2007]
  Fixed potential out-of-bounds reads in png_handle_sCAL(),
    png_handle_iTXt(), and png_push_read_tEXt().
  Remove some PNG_CONST declarations from pngwutil.c to avoid compiler warnings
  Revised makefiles to update paths in libpng.pc properly.

version 1.2.21rc3 [September 27, 2007]
  Revised makefiles to update "Libs" in libpng.pc properly.

version 1.0.29 and 1.2.21rc3 [October 4, 2007]
  No changes.

version 1.2.22beta1 [October 4, 2007]
  Again, fixed logical vs bitwise NOT in pngrtran.c, bug introduced
    in 1.2.19rc2

version 1.2.22beta2 [October 5, 2007]
  Fixed string length error in pngset.c (caused crashes while decoding iCCP)
  Add terminating NULL after each instance of png_strncpy().

version 1.2.22beta3 [October 6, 2007]
  Fix two off-by-one terminating NULL after png_strncpy().

version 1.2.22beta4 [October 7, 2007]
  Changed some 0 to '\0'.

version 1.0.30rc1 and 1.2.22rc1 [October 8, 2007]
  No changes.

version 1.0.30 and 1.2.22 [October 13, 2007]
  No changes.

version 1.2.23beta01 [October 15, 2007]
  Reduced number of invocations of png_strlen() in pngset.c.
  Changed [azAZ09_] to [_abcde...89] in Makefile.am for better localization.

version 1.2.23beta02 [October 16, 2007]
  Eliminated png_strncpy() and png_strcpy() (Pierre Poissinger)
  Changed $AN to $(AN) in Makefile.am.

version 1.2.23beta03 [October 16, 2007]
  Fixed off-by-one error in pngset.c
  Restore statement to set last character of buffer to \0 in pngerror.c

version 1.2.23beta04 [October 23, 2007]
  Reject attempt to set all-zero cHRM values.

version 1.2.23beta05 [October 26, 2007]
  Add missing quotes in projects/visualc6, lost in version 1.2.20rc3

version 1.2.23rc01 [November 2, 2007]
  No changes.

version 1.2.23 [November 6, 2007]
  No changes.

version 1.2.24beta01 [November 19, 2007]
  Moved misplaced test for malloc failure in png_set_sPLT().  This bug was
    introduced in libpng-1.2.20beta01.
  Ifdef out avg_row etc from png.h and pngwrite.c when PNG_NO_WRITE_FILTER
  Do not use png_ptr->free_fn and png_ptr->mem_fn in png_destroy_read_struct()
    when png_ptr is NULL (Marshall Clow).
  Updated handling of symbol prefixes in Makefile.am and configure.ac (Mike
    Frysinger).

version 1.2.24beta02 [November 30, 2007]
  Removed a useless test and fixed incorrect test in png_set_cHRM_fixed()
    (David Hill).

version 1.2.24rc01 [December 7, 2007]
  No changes.

version 1.2.24     [December 14, 2007]
  Make sure not to redefine _BSD_SOURCE in pngconf.h
  Revised gather.sh and makefile.std in contrib/pngminim to avoid compiling
    unused files.

version 1.2.25beta01 [January 7, 2008]
  Fixed bug with unknown chunk handling, introduced in version 1.2.17rc2

version 1.2.25beta02 [January 10, 2008]
  Prevent gamma from being applied twice.

version 1.2.25rc01 [January 17, 2008]
  No changes.

version 1.2.25beta03 [January 22, 2008]
  Fixed some continue-after-malloc-failure errors in pngset.c (David Hill)
  Check for info_ptr == NULL in png_read_info() and png_process_data().
  Check for possible use of NULL user_png_ver[] in png_create_read_struct().
  Change "if (swidth == NULL)" to "if (sheight == NULL)" in png_handle_sCAL
    (bug introduced in libpng-1.2.4/1.0.13).
  Return from png_destroy_read_struct() if png_ptr_ptr is NULL.
  Fix overflow of "msg" in png_decompres_chunk().

version 1.2.25beta04 [January 26, 2008]
  Work around Coverity bug report by slightly refactoring
    png_read_push_finish_row()

version 1.2.25beta05 [January 31, 2008]
  Added libpng-1.2.25beta05.tar.lzma to distribution.  Get the lzma codec
    from <http://tukaani.org/lzma>.
  Added lp1225b05.7z to distribution.  Get the 7-zip decoder from
    from <http://www.7-zip.org>.
  Fixed some broken links in the README file.

version 1.2.25beta06 [February 6, 2008]
  Refactored png_read_push_finish_row() again, trying to satisfy Coverity.
  Fixed potential NULL dereference of png_ptr in png_destroy_write_struct();
  clarified potential NULL dereference of png_ptr in png_destroy_read_struct();
  fixed potential NULL dereference of info_ptr in png_handle_bKGD();
  fixed potential NULL dereference of user_png_ver[] in
    png_create_write_struct_2(). (Coverity)

version 1.2.25rc02 [February 10, 2008]
  Reset png_ptr->pass in png_read_push_finish_row() before break.
  Changed "pass" from png_byte to int.

version 1.2.25 and 1.0.31 [February 18, 2008]
  No changes.
@
text
@a514 1
   {
d516 1
a516 3
     return ((png_uint_32)info_ptr->splt_palettes_num);
   }
   return (0);
a802 1
   {
d804 1
a804 3
     return ((png_uint_32)info_ptr->unknown_chunks_num);
   }
   return (0);
d838 3
a840 1
    /* obsolete, to be removed from libpng-1.4.0 */
d842 1
d849 24
a872 3
    /* obsolete, to be removed from libpng-1.4.0 */
    flag_select=flag_select;
    return 0L;
d875 1
d881 34
a914 4
    /* obsolete, to be removed from libpng-1.4.0 */
    flag_select=flag_select;
    *compilerID = -1;   /* unknown (i.e., no asm/MMX code compiled) */
    return 0L;
d921 3
a923 1
    /* obsolete, to be removed from libpng-1.4.0 */
d925 1
d932 3
a934 1
    /* obsolete, to be removed from libpng-1.4.0 */
d936 1
a953 1
 
@


1.1.107.5
log
@SECURITY update of libpng to 1.2.32
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.30 [August 15, 2008]
d6 1
a6 1
 * Copyright (c) 1998-2008 Glenn Randers-Pehrson
d13 1
d125 1
a125 1
      if (info_ptr->phys_unit_type != PNG_RESOLUTION_METER)
d143 1
a143 1
      if (info_ptr->phys_unit_type != PNG_RESOLUTION_METER)
d161 1
a161 1
      if (info_ptr->phys_unit_type != PNG_RESOLUTION_METER ||
d202 1
a202 1
      if (info_ptr->offset_unit_type != PNG_OFFSET_MICROMETER)
d220 1
a220 1
      if (info_ptr->offset_unit_type != PNG_OFFSET_MICROMETER)
d238 1
a238 1
      if (info_ptr->offset_unit_type != PNG_OFFSET_PIXEL)
d256 1
a256 1
      if (info_ptr->offset_unit_type != PNG_OFFSET_PIXEL)
d326 1
a326 1
         if (*unit_type == 1)
d787 1
a787 1
          if (trans != NULL)
d790 1
a790 1
      if (num_trans != NULL)
@


1.1.107.6
log
@libpng 1.2.35
@
text
@d123 1
a123 1
      png_debug1(1, "in %s retrieval function", "png_get_x_pixels_per_meter");
d141 1
a141 1
      png_debug1(1, "in %s retrieval function", "png_get_y_pixels_per_meter");
d159 1
a159 1
      png_debug1(1, "in %s retrieval function", "png_get_pixels_per_meter");
d179 1
a179 1
      png_debug1(1, "in %s retrieval function", "png_get_aspect_ratio");
d200 1
a200 1
      png_debug1(1, "in %s retrieval function", "png_get_x_offset_microns");
d218 1
a218 1
      png_debug1(1, "in %s retrieval function", "png_get_y_offset_microns");
d236 1
a236 1
      png_debug1(1, "in %s retrieval function", "png_get_x_offset_microns");
d254 1
a254 1
      png_debug1(1, "in %s retrieval function", "png_get_y_offset_microns");
d310 1
a310 1
      png_debug1(1, "in %s retrieval function", "pHYs");
d367 1
a367 1
      png_debug1(1, "in %s retrieval function", "bKGD");
d384 1
a384 1
      png_debug1(1, "in %s retrieval function", "cHRM");
d415 1
a415 1
      png_debug1(1, "in %s retrieval function", "cHRM");
d447 1
a447 1
      png_debug1(1, "in %s retrieval function", "gAMA");
d462 1
a462 1
      png_debug1(1, "in %s retrieval function", "gAMA");
d478 1
a478 1
      png_debug1(1, "in %s retrieval function", "sRGB");
d495 1
a495 1
      png_debug1(1, "in %s retrieval function", "iCCP");
d529 1
a529 1
      png_debug1(1, "in %s retrieval function", "hIST");
d547 1
a547 1
      png_debug1(1, "in %s retrieval function", "IHDR");
d591 1
a591 1
      png_debug1(1, "in %s retrieval function", "oFFs");
d611 1
a611 1
      png_debug1(1, "in %s retrieval function", "pCAL");
d671 1
a671 1
      png_debug1(1, "in %s retrieval function", "pHYs");
d699 1
a699 1
      png_debug1(1, "in %s retrieval function", "PLTE");
d702 1
a702 1
      png_debug1(3, "num_palette = %d", *num_palette);
d715 1
a715 1
      png_debug1(1, "in %s retrieval function", "sBIT");
d730 1
a730 1
      png_debug1(1, "in %s retrieval function",
d752 1
a752 1
      png_debug1(1, "in %s retrieval function", "tIME");
d768 1
a768 1
      png_debug1(1, "in %s retrieval function", "tRNS");
d886 1
a886 1
/* These functions were added to libpng 1.2.6 */
@


1.1.107.7
log
@Update libpng in the base system, too
@
text
@d4 3
a6 2
 * Last changed in libpng 1.2.43 [February 25, 2010]
 * Copyright (c) 1998-2010 Glenn Randers-Pehrson
a8 5
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 *
a11 1
#define PNG_NO_PEDANTIC_WARNINGS
a19 1

a28 1

d33 1
a33 1
#ifdef PNG_INFO_IMAGE_SUPPORTED
a38 1

d45 1
a45 1
/* Easy access to info, added in libpng-0.99 */
d50 1
d52 1
a52 1

d60 1
d62 1
a62 1

d70 1
d72 1
a72 1

d80 1
d82 1
a82 1

d90 1
d92 1
a92 1

d100 1
d102 1
a102 1

d110 1
d112 1
a112 1

d120 1
a120 1
#ifdef PNG_pHYs_SUPPORTED
a123 1

d126 1
a126 3

      else
          return (info_ptr->x_pixels_per_unit);
d138 1
a138 1
#ifdef PNG_pHYs_SUPPORTED
a141 1

d144 1
a144 3

      else
          return (info_ptr->y_pixels_per_unit);
d156 1
a156 1
#ifdef PNG_pHYs_SUPPORTED
a159 1

d163 1
a163 3

      else
          return (info_ptr->x_pixels_per_unit);
d176 1
a176 2
#ifdef PNG_pHYs_SUPPORTED

a179 1

a181 1

d187 1
a187 1
      return (0.0);
d197 1
a197 2
#ifdef PNG_oFFs_SUPPORTED

a200 1

d203 1
a203 3

      else
          return (info_ptr->x_offset);
d206 1
a206 1
      return (0);
d215 1
a215 2

#ifdef PNG_oFFs_SUPPORTED
a218 1

d221 1
a221 3

      else
          return (info_ptr->y_offset);
d233 1
a233 2

#ifdef PNG_oFFs_SUPPORTED
a236 1

d239 1
a239 3

      else
          return (info_ptr->x_offset);
d251 1
a251 2

#ifdef PNG_oFFs_SUPPORTED
a254 1

d257 1
a257 3

      else
          return (info_ptr->y_offset);
d301 1
a301 1
#ifdef PNG_pHYs_SUPPORTED
a310 1

d359 1
a359 1
#ifdef PNG_bKGD_SUPPORTED
a367 1

d375 1
a375 1
#ifdef PNG_cHRM_SUPPORTED
a384 1

a412 2
   png_debug1(1, "in %s retrieval function", "cHRM");

d415 1
d439 1
a439 1
#ifdef PNG_gAMA_SUPPORTED
a443 2
   png_debug1(1, "in %s retrieval function", "gAMA");

d447 1
a458 2
   png_debug1(1, "in %s retrieval function", "gAMA");

d462 1
d471 1
a471 1
#ifdef PNG_sRGB_SUPPORTED
a474 2
   png_debug1(1, "in %s retrieval function", "sRGB");

d478 1
d486 1
a486 1
#ifdef PNG_iCCP_SUPPORTED
a491 2
   png_debug1(1, "in %s retrieval function", "iCCP");

d495 1
d498 2
a499 3
      /* Compression_type is a dummy so the API won't have to change
       * if we introduce multiple compression types later.
       */
d508 1
a508 1
#ifdef PNG_sPLT_SUPPORTED
d522 1
a522 1
#ifdef PNG_hIST_SUPPORTED
a525 2
   png_debug1(1, "in %s retrieval function", "hIST");

d529 1
d544 37
a580 30
   png_debug1(1, "in %s retrieval function", "IHDR");

   if (png_ptr == NULL || info_ptr == NULL || width == NULL ||
       height == NULL || bit_depth == NULL || color_type == NULL)
      return (0);

   *width = info_ptr->width;
   *height = info_ptr->height;
   *bit_depth = info_ptr->bit_depth;
   *color_type = info_ptr->color_type;

   if (compression_type != NULL)
      *compression_type = info_ptr->compression_type;

   if (filter_type != NULL)
      *filter_type = info_ptr->filter_type;

   if (interlace_type != NULL)
      *interlace_type = info_ptr->interlace_type;

   /* This is redundant if we can be sure that the info_ptr values were all
    * assigned in png_set_IHDR().  We do the check anyhow in case an
    * application has ignored our advice not to mess with the members
    * of info_ptr directly.
    */
   png_check_IHDR (png_ptr, info_ptr->width, info_ptr->height,
       info_ptr->bit_depth, info_ptr->color_type, info_ptr->interlace_type,
       info_ptr->compression_type, info_ptr->filter_type);

   return (1);
d583 1
a583 1
#ifdef PNG_oFFs_SUPPORTED
a587 2
   png_debug1(1, "in %s retrieval function", "oFFs");

d591 1
d601 1
a601 1
#ifdef PNG_pCAL_SUPPORTED
a606 2
   png_debug1(1, "in %s retrieval function", "pCAL");

d608 2
a609 2
       && purpose != NULL && X0 != NULL && X1 != NULL && type != NULL &&
       nparams != NULL && units != NULL && params != NULL)
d611 1
d625 1
a625 1
#ifdef PNG_sCAL_SUPPORTED
d632 1
a632 1
        (info_ptr->valid & PNG_INFO_sCAL))
d648 1
a648 1
        (info_ptr->valid & PNG_INFO_sCAL))
d661 1
a661 1
#ifdef PNG_pHYs_SUPPORTED
a667 2
   png_debug1(1, "in %s retrieval function", "pHYs");

d671 1
a676 1

a681 1

a695 2
   png_debug1(1, "in %s retrieval function", "PLTE");

d699 1
d708 1
a708 1
#ifdef PNG_sBIT_SUPPORTED
a711 2
   png_debug1(1, "in %s retrieval function", "sBIT");

d715 1
d723 1
a723 1
#ifdef PNG_TEXT_SUPPORTED
a732 1

a734 1

a736 1

d745 1
a745 1
#ifdef PNG_tIME_SUPPORTED
a748 2
   png_debug1(1, "in %s retrieval function", "tIME");

d752 1
d760 1
a760 1
#ifdef PNG_tRNS_SUPPORTED
a768 1

a775 1

a785 1

d799 1
a799 1
#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED
d813 1
a813 1
#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
d821 1
a821 1
#ifdef PNG_USER_CHUNKS_SUPPORTED
d829 1
d835 1
d839 1
a839 1
/* This function was added to libpng 1.2.0 and should exist by default */
d843 1
a843 1
    /* Obsolete, to be removed from libpng-1.4.0 */
d847 1
a847 1
/* This function was added to libpng 1.2.0 and should exist by default */
d851 1
a851 1
    /* Obsolete, to be removed from libpng-1.4.0 */
d857 1
a857 1
/* This function was added to libpng 1.2.0 */
d861 1
a861 1
    /* Obsolete, to be removed from libpng-1.4.0 */
d867 1
a867 1
/* This function was added to libpng 1.2.0 */
d871 1
a871 1
    /* Obsolete, to be removed from libpng-1.4.0 */
d875 1
a875 1
/* This function was added to libpng 1.2.0 */
d879 1
a879 1
    /* Obsolete, to be removed from libpng-1.4.0 */
d886 1
a886 2
/* These functions were added to libpng 1.2.6 but not enabled
* by default. They will be enabled in libpng-1.4.0 */
d898 1
@


1.1.107.8
log
@update libpng
@
text
@d4 2
a5 2
 * Last changed in libpng 1.2.53 [February 26, 2015]
 * Copyright (c) 1998-2002,2004,2006-2015 Glenn Randers-Pehrson
d888 1
a888 2
    PNG_UNUSED(png_ptr)
    return 0L;
d896 1
a896 1
    PNG_UNUSED(flag_select)
d906 1
a906 1
    PNG_UNUSED(flag_select)
d916 1
a916 2
    PNG_UNUSED(png_ptr)
    return 0L;
d924 1
a924 2
    PNG_UNUSED(png_ptr)
    return 0L;
@


