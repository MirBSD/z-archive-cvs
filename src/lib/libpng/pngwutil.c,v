head	1.14;
access;
symbols
	png-1_2_57:1.1.107.10
	png-1_2_50:1.1.107.9
	png-1_2_35:1.1.107.8
	png-1_2_32:1.1.107.7
	png-1_2_26:1.1.107.6
	png-1_2_25:1.1.107.5
	MIRBSD_10:1.5.0.2
	MIRBSD_10_BASE:1.5
	png-1_2_18:1.1.107.4
	png-1_2_12:1.1.107.3
	MIRBSD_9_BASE:1.3
	png-1_2_10:1.1.107.2
	MIRBSD_8:1.2.0.2
	MIRBSD_8_BASE:1.2
	png-1_2_8:1.1.107.1
	libpng:1.1.107;
locks; strict;
comment	@ * @;


1.14
date	2017.04.15.15.30.04;	author tg;	state Exp;
branches;
next	1.11;
commitid	10058F23C965930E132;

1.11
date	2017.04.15.15.26.50;	author tg;	state Exp;
branches;
next	1.10;
commitid	10058F23BCC5ED04858;

1.10
date	2013.08.06.18.49.33;	author tg;	state Exp;
branches;
next	1.9;
commitid	1005201454765C5CF06;

1.9
date	2009.03.15.20.08.47;	author tg;	state Exp;
branches;
next	1.8;
commitid	10049BD605834002F74;

1.8
date	2008.10.22.19.11.53;	author tg;	state Exp;
branches;
next	1.7;
commitid	10048FF7AEF54F9B169;

1.7
date	2008.04.07.19.54.35;	author tg;	state Exp;
branches;
next	1.6;
commitid	10047FA7C0D12C807EE;

1.6
date	2008.03.23.17.54.56;	author tg;	state Exp;
branches;
next	1.5;
commitid	10047E6997C6BB35CA9;

1.5
date	2007.05.22.20.46.19;	author tg;	state Exp;
branches;
next	1.4;
commitid	100465356AC5C1E9A9B;

1.4
date	2006.06.29.17.14.25;	author tg;	state Exp;
branches;
next	1.3;
commitid	10044A40A7D396C3456;

1.3
date	2006.06.09.00.30.28;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004488C1225295157F;

1.2
date	2005.03.06.20.29.18;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.06.15.16.21;	author tg;	state Exp;
branches
	1.1.107.1;
next	;

1.1.107.1
date	2005.03.06.15.16.21;	author tg;	state Exp;
branches;
next	1.1.107.2;

1.1.107.2
date	2006.06.09.00.13.12;	author tg;	state Exp;
branches;
next	1.1.107.3;
commitid	1004488BD054F510AF1;

1.1.107.3
date	2006.06.29.17.08.59;	author tg;	state Exp;
branches;
next	1.1.107.4;
commitid	10044A409367518C911;

1.1.107.4
date	2007.05.22.20.25.38;	author tg;	state Exp;
branches;
next	1.1.107.5;
commitid	100465351CF4103214A;

1.1.107.5
date	2008.03.23.17.15.18;	author tg;	state Exp;
branches;
next	1.1.107.6;
commitid	10047E69020419198D8;

1.1.107.6
date	2008.04.07.19.51.01;	author tg;	state Exp;
branches;
next	1.1.107.7;
commitid	10047FA7B332B97228B;

1.1.107.7
date	2008.10.22.18.55.40;	author tg;	state Exp;
branches;
next	1.1.107.8;
commitid	10048FF773834003AB5;

1.1.107.8
date	2009.03.15.19.57.26;	author tg;	state Exp;
branches;
next	1.1.107.9;
commitid	10049BD5DB90DBE42DE;

1.1.107.9
date	2013.08.06.17.35.04;	author tg;	state Exp;
branches;
next	1.1.107.10;
commitid	100520133D730551D16;

1.1.107.10
date	2017.04.15.15.00.13;	author tg;	state Exp;
branches;
next	;
commitid	10058F2359276DB0E16;


desc
@@


1.14
log
@â€¦
@
text
@#include <sys/cdefs.h>
__RCSID("$MirOS: src/lib/libpng/pngwutil.c,v 1.10 2013/08/06 18:49:33 tg Exp $");

/* pngwutil.c - utilities to write a PNG file
 *
 * Last changed in libpng 1.2.56 [December 17, 2015]
 * Copyright (c) 1998-2002,2004,2006-2015 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 */

#define PNG_INTERNAL
#define PNG_NO_PEDANTIC_WARNINGS
#include "png.h"
#ifdef PNG_WRITE_SUPPORTED

/* Place a 32-bit number into a buffer in PNG byte order.  We work
 * with unsigned numbers for convenience, although one supported
 * ancillary chunk uses signed (two's complement) numbers.
 */
void PNGAPI
png_save_uint_32(png_bytep buf, png_uint_32 i)
{
   buf[0] = (png_byte)((i >> 24) & 0xff);
   buf[1] = (png_byte)((i >> 16) & 0xff);
   buf[2] = (png_byte)((i >> 8) & 0xff);
   buf[3] = (png_byte)(i & 0xff);
}

/* The png_save_int_32 function assumes integers are stored in two's
 * complement format.  If this isn't the case, then this routine needs to
 * be modified to write data in two's complement format.
 */
void PNGAPI
png_save_int_32(png_bytep buf, png_int_32 i)
{
   buf[0] = (png_byte)((i >> 24) & 0xff);
   buf[1] = (png_byte)((i >> 16) & 0xff);
   buf[2] = (png_byte)((i >> 8) & 0xff);
   buf[3] = (png_byte)(i & 0xff);
}

/* Place a 16-bit number into a buffer in PNG byte order.
 * The parameter is declared unsigned int, not png_uint_16,
 * just to avoid potential problems on pre-ANSI C compilers.
 */
void PNGAPI
png_save_uint_16(png_bytep buf, unsigned int i)
{
   buf[0] = (png_byte)((i >> 8) & 0xff);
   buf[1] = (png_byte)(i & 0xff);
}

/* Simple function to write the signature.  If we have already written
 * the magic bytes of the signature, or more likely, the PNG stream is
 * being embedded into another stream and doesn't need its own signature,
 * we should call png_set_sig_bytes() to tell libpng how many of the
 * bytes have already been written.
 */
void /* PRIVATE */
png_write_sig(png_structp png_ptr)
{
   png_byte png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};

   /* Write the rest of the 8 byte signature */
   png_write_data(png_ptr, &png_signature[png_ptr->sig_bytes],
      (png_size_t)(8 - png_ptr->sig_bytes));
   if (png_ptr->sig_bytes < 3)
      png_ptr->mode |= PNG_HAVE_PNG_SIGNATURE;
}

/* Write a PNG chunk all at once.  The type is an array of ASCII characters
 * representing the chunk name.  The array must be at least 4 bytes in
 * length, and does not need to be null terminated.  To be safe, pass the
 * pre-defined chunk names here, and if you need a new one, define it
 * where the others are defined.  The length is the length of the data.
 * All the data must be present.  If that is not possible, use the
 * png_write_chunk_start(), png_write_chunk_data(), and png_write_chunk_end()
 * functions instead.
 */
void PNGAPI
png_write_chunk(png_structp png_ptr, png_bytep chunk_name,
   png_bytep data, png_size_t length)
{
   if (png_ptr == NULL)
      return;
   png_write_chunk_start(png_ptr, chunk_name, (png_uint_32)length);
   png_write_chunk_data(png_ptr, data, (png_size_t)length);
   png_write_chunk_end(png_ptr);
}

/* Write the start of a PNG chunk.  The type is the chunk type.
 * The total_length is the sum of the lengths of all the data you will be
 * passing in png_write_chunk_data().
 */
void PNGAPI
png_write_chunk_start(png_structp png_ptr, png_bytep chunk_name,
   png_uint_32 length)
{
   png_byte buf[8];

   png_debug2(0, "Writing %s chunk, length = %lu", chunk_name,
      (unsigned long)length);

   if (png_ptr == NULL)
      return;


   /* Write the length and the chunk name */
   png_save_uint_32(buf, length);
   png_memcpy(buf + 4, chunk_name, 4);
   png_write_data(png_ptr, buf, (png_size_t)8);
   /* Put the chunk name into png_ptr->chunk_name */
   png_memcpy(png_ptr->chunk_name, chunk_name, 4);
   /* Reset the crc and run it over the chunk name */
   png_reset_crc(png_ptr);
   png_calculate_crc(png_ptr, chunk_name, (png_size_t)4);
}

/* Write the data of a PNG chunk started with png_write_chunk_start().
 * Note that multiple calls to this function are allowed, and that the
 * sum of the lengths from these calls *must* add up to the total_length
 * given to png_write_chunk_start().
 */
void PNGAPI
png_write_chunk_data(png_structp png_ptr, png_bytep data, png_size_t length)
{
   /* Write the data, and run the CRC over it */
   if (png_ptr == NULL)
      return;
   if (data != NULL && length > 0)
   {
      png_write_data(png_ptr, data, length);
      /* Update the CRC after writing the data,
       * in case that the user I/O routine alters it.
       */
      png_calculate_crc(png_ptr, data, length);
   }
}

/* Finish a chunk started with png_write_chunk_start(). */
void PNGAPI
png_write_chunk_end(png_structp png_ptr)
{
   png_byte buf[4];

   if (png_ptr == NULL) return;

   /* Write the crc in a single operation */
   png_save_uint_32(buf, png_ptr->crc);

   png_write_data(png_ptr, buf, (png_size_t)4);
}

#if defined(PNG_WRITE_TEXT_SUPPORTED) || defined(PNG_WRITE_iCCP_SUPPORTED)
/* This pair of functions encapsulates the operation of (a) compressing a
 * text string, and (b) issuing it later as a series of chunk data writes.
 * The compression_state structure is shared context for these functions
 * set up by the caller in order to make the whole mess thread-safe.
 */

typedef struct
{
   char *input;   /* The uncompressed input data */
   int input_len;   /* Its length */
   int num_output_ptr; /* Number of output pointers used */
   int max_output_ptr; /* Size of output_ptr */
   png_charpp output_ptr; /* Array of pointers to output */
} compression_state;

/* Compress given text into storage in the png_ptr structure */
static int /* PRIVATE */
png_text_compress(png_structp png_ptr,
        png_charp text, png_size_t text_len, int compression,
        compression_state *comp)
{
   int ret;

   comp->num_output_ptr = 0;
   comp->max_output_ptr = 0;
   comp->output_ptr = NULL;
   comp->input = NULL;
   comp->input_len = 0;

   /* We may just want to pass the text right through */
   if (compression == PNG_TEXT_COMPRESSION_NONE)
   {
       comp->input = text;
       comp->input_len = text_len;
       return((int)text_len);
   }

   if (compression >= PNG_TEXT_COMPRESSION_LAST)
   {
#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)
      char msg[50];
      png_snprintf(msg, 50, "Unknown compression type %d", compression);
      png_warning(png_ptr, msg);
#else
      png_warning(png_ptr, "Unknown compression type");
#endif
   }

   /* We can't write the chunk until we find out how much data we have,
    * which means we need to run the compressor first and save the
    * output.  This shouldn't be a problem, as the vast majority of
    * comments should be reasonable, but we will set up an array of
    * malloc'd pointers to be sure.
    *
    * If we knew the application was well behaved, we could simplify this
    * greatly by assuming we can always malloc an output buffer large
    * enough to hold the compressed text ((1001 * text_len / 1000) + 12)
    * and malloc this directly.  The only time this would be a bad idea is
    * if we can't malloc more than 64K and we have 64K of random input
    * data, or if the input string is incredibly large (although this
    * wouldn't cause a failure, just a slowdown due to swapping).
    */

   /* Set up the compression buffers */
   png_ptr->zstream.avail_in = (uInt)text_len;
   png_ptr->zstream.next_in = (Bytef *)text;
   png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
   png_ptr->zstream.next_out = (Bytef *)png_ptr->zbuf;

   /* This is the same compression loop as in png_write_row() */
   do
   {
      /* Compress the data */
      ret = deflate(&png_ptr->zstream, Z_NO_FLUSH);
      if (ret != Z_OK)
      {
         /* Error */
         if (png_ptr->zstream.msg != NULL)
            png_error(png_ptr, png_ptr->zstream.msg);
         else
            png_error(png_ptr, "zlib error");
      }
      /* Check to see if we need more room */
      if (!(png_ptr->zstream.avail_out))
      {
         /* Make sure the output array has room */
         if (comp->num_output_ptr >= comp->max_output_ptr)
         {
            int old_max;

            old_max = comp->max_output_ptr;
            comp->max_output_ptr = comp->num_output_ptr + 4;
            if (comp->output_ptr != NULL)
            {
               png_charpp old_ptr;

               old_ptr = comp->output_ptr;
               comp->output_ptr = (png_charpp)png_malloc(png_ptr,
                  (png_uint_32)
                  (comp->max_output_ptr * png_sizeof(png_charp)));
               png_memcpy(comp->output_ptr, old_ptr, old_max
                  * png_sizeof(png_charp));
               png_free(png_ptr, old_ptr);
            }
            else
               comp->output_ptr = (png_charpp)png_malloc(png_ptr,
                  (png_uint_32)
                  (comp->max_output_ptr * png_sizeof(png_charp)));
         }

         /* Save the data */
         comp->output_ptr[comp->num_output_ptr] =
            (png_charp)png_malloc(png_ptr,
            (png_uint_32)png_ptr->zbuf_size);
         png_memcpy(comp->output_ptr[comp->num_output_ptr], png_ptr->zbuf,
            png_ptr->zbuf_size);
         comp->num_output_ptr++;

         /* and reset the buffer */
         png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
         png_ptr->zstream.next_out = png_ptr->zbuf;
      }
   /* Continue until we don't have any more to compress */
   } while (png_ptr->zstream.avail_in);

   /* Finish the compression */
   do
   {
      /* Tell zlib we are finished */
      ret = deflate(&png_ptr->zstream, Z_FINISH);

      if (ret == Z_OK)
      {
         /* Check to see if we need more room */
         if (!(png_ptr->zstream.avail_out))
         {
            /* Check to make sure our output array has room */
            if (comp->num_output_ptr >= comp->max_output_ptr)
            {
               int old_max;

               old_max = comp->max_output_ptr;
               comp->max_output_ptr = comp->num_output_ptr + 4;
               if (comp->output_ptr != NULL)
               {
                  png_charpp old_ptr;

                  old_ptr = comp->output_ptr;
                  /* This could be optimized to realloc() */
                  comp->output_ptr = (png_charpp)png_malloc(png_ptr,
                     (png_uint_32)(comp->max_output_ptr *
                     png_sizeof(png_charp)));
                  png_memcpy(comp->output_ptr, old_ptr,
                     old_max * png_sizeof(png_charp));
                  png_free(png_ptr, old_ptr);
               }
               else
                  comp->output_ptr = (png_charpp)png_malloc(png_ptr,
                     (png_uint_32)(comp->max_output_ptr *
                     png_sizeof(png_charp)));
            }

            /* Save the data */
            comp->output_ptr[comp->num_output_ptr] =
               (png_charp)png_malloc(png_ptr,
               (png_uint_32)png_ptr->zbuf_size);
            png_memcpy(comp->output_ptr[comp->num_output_ptr], png_ptr->zbuf,
               png_ptr->zbuf_size);
            comp->num_output_ptr++;

            /* and reset the buffer pointers */
            png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
            png_ptr->zstream.next_out = png_ptr->zbuf;
         }
      }
      else if (ret != Z_STREAM_END)
      {
         /* We got an error */
         if (png_ptr->zstream.msg != NULL)
            png_error(png_ptr, png_ptr->zstream.msg);
         else
            png_error(png_ptr, "zlib error");
      }
   } while (ret != Z_STREAM_END);

   /* Text length is number of buffers plus last buffer */
   text_len = png_ptr->zbuf_size * comp->num_output_ptr;
   if (png_ptr->zstream.avail_out < png_ptr->zbuf_size)
      text_len += png_ptr->zbuf_size - (png_size_t)png_ptr->zstream.avail_out;

   return((int)text_len);
}

/* Ship the compressed text out via chunk writes */
static void /* PRIVATE */
png_write_compressed_data_out(png_structp png_ptr, compression_state *comp)
{
   int i;

   /* Handle the no-compression case */
   if (comp->input)
   {
      png_write_chunk_data(png_ptr, (png_bytep)comp->input,
                            (png_size_t)comp->input_len);
      return;
   }

   /* Write saved output buffers, if any */
   for (i = 0; i < comp->num_output_ptr; i++)
   {
      png_write_chunk_data(png_ptr, (png_bytep)comp->output_ptr[i],
         (png_size_t)png_ptr->zbuf_size);
      png_free(png_ptr, comp->output_ptr[i]);
       comp->output_ptr[i]=NULL;
   }
   if (comp->max_output_ptr != 0)
      png_free(png_ptr, comp->output_ptr);
       comp->output_ptr=NULL;
   /* Write anything left in zbuf */
   if (png_ptr->zstream.avail_out < (png_uint_32)png_ptr->zbuf_size)
      png_write_chunk_data(png_ptr, png_ptr->zbuf,
         (png_size_t)(png_ptr->zbuf_size - png_ptr->zstream.avail_out));

   /* Reset zlib for another zTXt/iTXt or image data */
   deflateReset(&png_ptr->zstream);
   png_ptr->zstream.data_type = Z_BINARY;
}
#endif

/* Write the IHDR chunk, and update the png_struct with the necessary
 * information.  Note that the rest of this code depends upon this
 * information being correct.
 */
void /* PRIVATE */
png_write_IHDR(png_structp png_ptr, png_uint_32 width, png_uint_32 height,
   int bit_depth, int color_type, int compression_type, int filter_type,
   int interlace_type)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_IHDR;
#endif
   int ret;

   png_byte buf[13]; /* Buffer to store the IHDR info */

   png_debug(1, "in png_write_IHDR");

   /* Check that we have valid input data from the application info */
   switch (color_type)
   {
      case PNG_COLOR_TYPE_GRAY:
         switch (bit_depth)
         {
            case 1:
            case 2:
            case 4:
            case 8:
            case 16: png_ptr->channels = 1; break;
            default: png_error(png_ptr,
                         "Invalid bit depth for grayscale image");
         }
         break;
      case PNG_COLOR_TYPE_RGB:
         if (bit_depth != 8 && bit_depth != 16)
            png_error(png_ptr, "Invalid bit depth for RGB image");
         png_ptr->channels = 3;
         break;
      case PNG_COLOR_TYPE_PALETTE:
         switch (bit_depth)
         {
            case 1:
            case 2:
            case 4:
            case 8: png_ptr->channels = 1; break;
            default: png_error(png_ptr, "Invalid bit depth for paletted image");
         }
         break;
      case PNG_COLOR_TYPE_GRAY_ALPHA:
         if (bit_depth != 8 && bit_depth != 16)
            png_error(png_ptr, "Invalid bit depth for grayscale+alpha image");
         png_ptr->channels = 2;
         break;
      case PNG_COLOR_TYPE_RGB_ALPHA:
         if (bit_depth != 8 && bit_depth != 16)
            png_error(png_ptr, "Invalid bit depth for RGBA image");
         png_ptr->channels = 4;
         break;
      default:
         png_error(png_ptr, "Invalid image color type specified");
   }

   if (compression_type != PNG_COMPRESSION_TYPE_BASE)
   {
      png_warning(png_ptr, "Invalid compression type specified");
      compression_type = PNG_COMPRESSION_TYPE_BASE;
   }

   /* Write filter_method 64 (intrapixel differencing) only if
    * 1. Libpng was compiled with PNG_MNG_FEATURES_SUPPORTED and
    * 2. Libpng did not write a PNG signature (this filter_method is only
    *    used in PNG datastreams that are embedded in MNG datastreams) and
    * 3. The application called png_permit_mng_features with a mask that
    *    included PNG_FLAG_MNG_FILTER_64 and
    * 4. The filter_method is 64 and
    * 5. The color_type is RGB or RGBA
    */
   if (
#ifdef PNG_MNG_FEATURES_SUPPORTED
      !((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&
      ((png_ptr->mode&PNG_HAVE_PNG_SIGNATURE) == 0) &&
      (color_type == PNG_COLOR_TYPE_RGB ||
       color_type == PNG_COLOR_TYPE_RGB_ALPHA) &&
      (filter_type == PNG_INTRAPIXEL_DIFFERENCING)) &&
#endif
      filter_type != PNG_FILTER_TYPE_BASE)
   {
      png_warning(png_ptr, "Invalid filter type specified");
      filter_type = PNG_FILTER_TYPE_BASE;
   }

#ifdef PNG_WRITE_INTERLACING_SUPPORTED
   if (interlace_type != PNG_INTERLACE_NONE &&
      interlace_type != PNG_INTERLACE_ADAM7)
   {
      png_warning(png_ptr, "Invalid interlace type specified");
      interlace_type = PNG_INTERLACE_ADAM7;
   }
#else
   interlace_type=PNG_INTERLACE_NONE;
#endif

   /* Save the relevent information */
   png_ptr->bit_depth = (png_byte)bit_depth;
   png_ptr->color_type = (png_byte)color_type;
   png_ptr->interlaced = (png_byte)interlace_type;
#ifdef PNG_MNG_FEATURES_SUPPORTED
   png_ptr->filter_type = (png_byte)filter_type;
#endif
   png_ptr->compression_type = (png_byte)compression_type;
   png_ptr->width = width;
   png_ptr->height = height;

   png_ptr->pixel_depth = (png_byte)(bit_depth * png_ptr->channels);
   png_ptr->rowbytes = PNG_ROWBYTES(png_ptr->pixel_depth, width);
   /* Set the usr info, so any transformations can modify it */
   png_ptr->usr_width = png_ptr->width;
   png_ptr->usr_bit_depth = png_ptr->bit_depth;
   png_ptr->usr_channels = png_ptr->channels;

   /* Pack the header information into the buffer */
   png_save_uint_32(buf, width);
   png_save_uint_32(buf + 4, height);
   buf[8] = (png_byte)bit_depth;
   buf[9] = (png_byte)color_type;
   buf[10] = (png_byte)compression_type;
   buf[11] = (png_byte)filter_type;
   buf[12] = (png_byte)interlace_type;

   /* Write the chunk */
   png_write_chunk(png_ptr, (png_bytep)png_IHDR, buf, (png_size_t)13);

   /* Initialize zlib with PNG info */
   png_ptr->zstream.zalloc = png_zalloc;
   png_ptr->zstream.zfree = png_zfree;
   png_ptr->zstream.opaque = (voidpf)png_ptr;
   if (!(png_ptr->do_filter))
   {
      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE ||
         png_ptr->bit_depth < 8)
         png_ptr->do_filter = PNG_FILTER_NONE;
      else
         png_ptr->do_filter = PNG_ALL_FILTERS;
   }
   if (!(png_ptr->flags & PNG_FLAG_ZLIB_CUSTOM_STRATEGY))
   {
      if (png_ptr->do_filter != PNG_FILTER_NONE)
         png_ptr->zlib_strategy = Z_FILTERED;
      else
         png_ptr->zlib_strategy = Z_DEFAULT_STRATEGY;
   }
   if (!(png_ptr->flags & PNG_FLAG_ZLIB_CUSTOM_LEVEL))
      png_ptr->zlib_level = Z_DEFAULT_COMPRESSION;
   if (!(png_ptr->flags & PNG_FLAG_ZLIB_CUSTOM_MEM_LEVEL))
      png_ptr->zlib_mem_level = 8;
   if (!(png_ptr->flags & PNG_FLAG_ZLIB_CUSTOM_WINDOW_BITS))
      png_ptr->zlib_window_bits = 15;
   if (!(png_ptr->flags & PNG_FLAG_ZLIB_CUSTOM_METHOD))
      png_ptr->zlib_method = 8;
   ret = deflateInit2(&png_ptr->zstream, png_ptr->zlib_level,
         png_ptr->zlib_method, png_ptr->zlib_window_bits,
         png_ptr->zlib_mem_level, png_ptr->zlib_strategy);
   if (ret != Z_OK)
   {
      if (ret == Z_VERSION_ERROR) png_error(png_ptr,
          "zlib failed to initialize compressor -- version error");
      if (ret == Z_STREAM_ERROR) png_error(png_ptr,
           "zlib failed to initialize compressor -- stream error");
      if (ret == Z_MEM_ERROR) png_error(png_ptr,
           "zlib failed to initialize compressor -- mem error");
      png_error(png_ptr, "zlib failed to initialize compressor");
   }
   png_ptr->zstream.next_out = png_ptr->zbuf;
   png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
   /* libpng is not interested in zstream.data_type */
   /* Set it to a predefined value, to avoid its evaluation inside zlib */
   png_ptr->zstream.data_type = Z_BINARY;

   png_ptr->mode = PNG_HAVE_IHDR;
}

/* Write the palette.  We are careful not to trust png_color to be in the
 * correct order for PNG, so people can redefine it to any convenient
 * structure.
 */
void /* PRIVATE */
png_write_PLTE(png_structp png_ptr, png_colorp palette, png_uint_32 num_pal)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_PLTE;
#endif
   png_uint_32 max_palette_length, i;
   png_colorp pal_ptr;
   png_byte buf[3];

   png_debug(1, "in png_write_PLTE");

   max_palette_length = (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) ?
      (1 << png_ptr->bit_depth) : PNG_MAX_PALETTE_LENGTH;

   if ((
#ifdef PNG_MNG_FEATURES_SUPPORTED
        !(png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE) &&
#endif
       num_pal == 0) || num_pal > max_palette_length)
   {
     if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
     {
        png_error(png_ptr, "Invalid number of colors in palette");
     }
     else
     {
        png_warning(png_ptr, "Invalid number of colors in palette");
        return;
     }
   }

   if (!(png_ptr->color_type&PNG_COLOR_MASK_COLOR))
   {
      png_warning(png_ptr,
        "Ignoring request to write a PLTE chunk in grayscale PNG");
      return;
   }

   png_ptr->num_palette = (png_uint_16)num_pal;
   png_debug1(3, "num_palette = %d", png_ptr->num_palette);

   png_write_chunk_start(png_ptr, (png_bytep)png_PLTE,
     (png_uint_32)(num_pal * 3));
#ifdef PNG_POINTER_INDEXING_SUPPORTED
   for (i = 0, pal_ptr = palette; i < num_pal; i++, pal_ptr++)
   {
      buf[0] = pal_ptr->red;
      buf[1] = pal_ptr->green;
      buf[2] = pal_ptr->blue;
      png_write_chunk_data(png_ptr, buf, (png_size_t)3);
   }
#else
   /* This is a little slower but some buggy compilers need to do this
    * instead
    */
   pal_ptr=palette;
   for (i = 0; i < num_pal; i++)
   {
      buf[0] = pal_ptr[i].red;
      buf[1] = pal_ptr[i].green;
      buf[2] = pal_ptr[i].blue;
      png_write_chunk_data(png_ptr, buf, (png_size_t)3);
   }
#endif
   png_write_chunk_end(png_ptr);
   png_ptr->mode |= PNG_HAVE_PLTE;
}

/* Write an IDAT chunk */
void /* PRIVATE */
png_write_IDAT(png_structp png_ptr, png_bytep data, png_size_t length)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_IDAT;
#endif

   png_debug(1, "in png_write_IDAT");

   /* Optimize the CMF field in the zlib stream. */
   /* This hack of the zlib stream is compliant to the stream specification. */
   if (!(png_ptr->mode & PNG_HAVE_IDAT) &&
       png_ptr->compression_type == PNG_COMPRESSION_TYPE_BASE)
   {
      unsigned int z_cmf = data[0];  /* zlib compression method and flags */
      if ((z_cmf & 0x0f) == 8 && (z_cmf & 0xf0) <= 0x70)
      {
         /* Avoid memory underflows and multiplication overflows.
          *
          * The conditions below are practically always satisfied;
          * however, they still must be checked.
          */
         if (length >= 2 &&
             png_ptr->height < 16384 && png_ptr->width < 16384)
         {
            png_uint_32 uncompressed_idat_size = png_ptr->height *
               ((png_ptr->width *
               png_ptr->channels * png_ptr->bit_depth + 15) >> 3);
            unsigned int z_cinfo = z_cmf >> 4;
            unsigned int half_z_window_size = 1 << (z_cinfo + 7);
            while (uncompressed_idat_size <= half_z_window_size &&
                   half_z_window_size >= 256)
            {
               z_cinfo--;
               half_z_window_size >>= 1;
            }
            z_cmf = (z_cmf & 0x0f) | (z_cinfo << 4);
            if (data[0] != (png_byte)z_cmf)
            {
               data[0] = (png_byte)z_cmf;
               data[1] &= 0xe0;
               data[1] += (png_byte)(0x1f - ((z_cmf << 8) + data[1]) % 0x1f);
            }
         }
      }
      else
         png_error(png_ptr,
            "Invalid zlib compression method or flags in IDAT");
   }

   png_write_chunk(png_ptr, (png_bytep)png_IDAT, data, length);
   png_ptr->mode |= PNG_HAVE_IDAT;
}

/* Write an IEND chunk */
void /* PRIVATE */
png_write_IEND(png_structp png_ptr)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_IEND;
#endif

   png_debug(1, "in png_write_IEND");

   png_write_chunk(png_ptr, (png_bytep)png_IEND, png_bytep_NULL,
     (png_size_t)0);
   png_ptr->mode |= PNG_HAVE_IEND;
}

#ifdef PNG_WRITE_gAMA_SUPPORTED
/* Write a gAMA chunk */
#ifdef PNG_FLOATING_POINT_SUPPORTED
void /* PRIVATE */
png_write_gAMA(png_structp png_ptr, double file_gamma)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_gAMA;
#endif
   png_uint_32 igamma;
   png_byte buf[4];

   png_debug(1, "in png_write_gAMA");

   /* file_gamma is saved in 1/100,000ths */
   igamma = (png_uint_32)(file_gamma * 100000.0 + 0.5);
   png_save_uint_32(buf, igamma);
   png_write_chunk(png_ptr, (png_bytep)png_gAMA, buf, (png_size_t)4);
}
#endif
#ifdef PNG_FIXED_POINT_SUPPORTED
void /* PRIVATE */
png_write_gAMA_fixed(png_structp png_ptr, png_fixed_point file_gamma)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_gAMA;
#endif
   png_byte buf[4];

   png_debug(1, "in png_write_gAMA");

   /* file_gamma is saved in 1/100,000ths */
   png_save_uint_32(buf, (png_uint_32)file_gamma);
   png_write_chunk(png_ptr, (png_bytep)png_gAMA, buf, (png_size_t)4);
}
#endif
#endif

#ifdef PNG_WRITE_sRGB_SUPPORTED
/* Write a sRGB chunk */
void /* PRIVATE */
png_write_sRGB(png_structp png_ptr, int srgb_intent)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_sRGB;
#endif
   png_byte buf[1];

   png_debug(1, "in png_write_sRGB");

   if (srgb_intent >= PNG_sRGB_INTENT_LAST)
         png_warning(png_ptr,
            "Invalid sRGB rendering intent specified");
   buf[0]=(png_byte)srgb_intent;
   png_write_chunk(png_ptr, (png_bytep)png_sRGB, buf, (png_size_t)1);
}
#endif

#ifdef PNG_WRITE_iCCP_SUPPORTED
/* Write an iCCP chunk */
void /* PRIVATE */
png_write_iCCP(png_structp png_ptr, png_charp name, int compression_type,
   png_charp profile, int profile_len)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_iCCP;
#endif
   png_size_t name_len;
   png_charp new_name;
   compression_state comp;
   int embedded_profile_len = 0;

   png_debug(1, "in png_write_iCCP");

   comp.num_output_ptr = 0;
   comp.max_output_ptr = 0;
   comp.output_ptr = NULL;
   comp.input = NULL;
   comp.input_len = 0;

   if ((name_len = png_check_keyword(png_ptr, name,
      &new_name)) == 0)
      return;

   if (compression_type != PNG_COMPRESSION_TYPE_BASE)
      png_warning(png_ptr, "Unknown compression type in iCCP chunk");

   if (profile == NULL)
      profile_len = 0;

   if (profile_len > 3)
      embedded_profile_len =
          ((*( (png_bytep)profile    ))<<24) |
          ((*( (png_bytep)profile + 1))<<16) |
          ((*( (png_bytep)profile + 2))<< 8) |
          ((*( (png_bytep)profile + 3))    );

   if (embedded_profile_len < 0)
   {
      png_warning(png_ptr,
        "Embedded profile length in iCCP chunk is negative");
      png_free(png_ptr, new_name);
      return;
   }

   if (profile_len < embedded_profile_len)
   {
      png_warning(png_ptr,
        "Embedded profile length too large in iCCP chunk");
      png_free(png_ptr, new_name);
      return;
   }

   if (profile_len > embedded_profile_len)
   {
      png_warning(png_ptr,
        "Truncating profile to actual length in iCCP chunk");
      profile_len = embedded_profile_len;
   }

   if (profile_len)
      profile_len = png_text_compress(png_ptr, profile,
        (png_size_t)profile_len, PNG_COMPRESSION_TYPE_BASE, &comp);

   /* Make sure we include the NULL after the name and the compression type */
   png_write_chunk_start(png_ptr, (png_bytep)png_iCCP,
          (png_uint_32)(name_len + profile_len + 2));
   new_name[name_len + 1] = 0x00;
   png_write_chunk_data(png_ptr, (png_bytep)new_name,
     (png_size_t)(name_len + 2));

   if (profile_len)
      png_write_compressed_data_out(png_ptr, &comp);

   png_write_chunk_end(png_ptr);
   png_free(png_ptr, new_name);
}
#endif

#ifdef PNG_WRITE_sPLT_SUPPORTED
/* Write a sPLT chunk */
void /* PRIVATE */
png_write_sPLT(png_structp png_ptr, png_sPLT_tp spalette)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_sPLT;
#endif
   png_size_t name_len;
   png_charp new_name;
   png_byte entrybuf[10];
   int entry_size = (spalette->depth == 8 ? 6 : 10);
   int palette_size = entry_size * spalette->nentries;
   png_sPLT_entryp ep;
#ifndef PNG_POINTER_INDEXING_SUPPORTED
   int i;
#endif

   png_debug(1, "in png_write_sPLT");

   if ((name_len = png_check_keyword(png_ptr,spalette->name, &new_name))==0)
      return;

   /* Make sure we include the NULL after the name */
   png_write_chunk_start(png_ptr, (png_bytep)png_sPLT,
     (png_uint_32)(name_len + 2 + palette_size));
   png_write_chunk_data(png_ptr, (png_bytep)new_name,
     (png_size_t)(name_len + 1));
   png_write_chunk_data(png_ptr, (png_bytep)&spalette->depth, (png_size_t)1);

   /* Loop through each palette entry, writing appropriately */
#ifdef PNG_POINTER_INDEXING_SUPPORTED
   for (ep = spalette->entries; ep<spalette->entries + spalette->nentries; ep++)
   {
      if (spalette->depth == 8)
      {
          entrybuf[0] = (png_byte)ep->red;
          entrybuf[1] = (png_byte)ep->green;
          entrybuf[2] = (png_byte)ep->blue;
          entrybuf[3] = (png_byte)ep->alpha;
          png_save_uint_16(entrybuf + 4, ep->frequency);
      }
      else
      {
          png_save_uint_16(entrybuf + 0, ep->red);
          png_save_uint_16(entrybuf + 2, ep->green);
          png_save_uint_16(entrybuf + 4, ep->blue);
          png_save_uint_16(entrybuf + 6, ep->alpha);
          png_save_uint_16(entrybuf + 8, ep->frequency);
      }
      png_write_chunk_data(png_ptr, entrybuf, (png_size_t)entry_size);
   }
#else
   ep=spalette->entries;
   for (i=0; i>spalette->nentries; i++)
   {
      if (spalette->depth == 8)
      {
          entrybuf[0] = (png_byte)ep[i].red;
          entrybuf[1] = (png_byte)ep[i].green;
          entrybuf[2] = (png_byte)ep[i].blue;
          entrybuf[3] = (png_byte)ep[i].alpha;
          png_save_uint_16(entrybuf + 4, ep[i].frequency);
      }
      else
      {
          png_save_uint_16(entrybuf + 0, ep[i].red);
          png_save_uint_16(entrybuf + 2, ep[i].green);
          png_save_uint_16(entrybuf + 4, ep[i].blue);
          png_save_uint_16(entrybuf + 6, ep[i].alpha);
          png_save_uint_16(entrybuf + 8, ep[i].frequency);
      }
      png_write_chunk_data(png_ptr, entrybuf, (png_size_t)entry_size);
   }
#endif

   png_write_chunk_end(png_ptr);
   png_free(png_ptr, new_name);
}
#endif

#ifdef PNG_WRITE_sBIT_SUPPORTED
/* Write the sBIT chunk */
void /* PRIVATE */
png_write_sBIT(png_structp png_ptr, png_color_8p sbit, int color_type)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_sBIT;
#endif
   png_byte buf[4];
   png_size_t size;

   png_debug(1, "in png_write_sBIT");

   /* Make sure we don't depend upon the order of PNG_COLOR_8 */
   if (color_type & PNG_COLOR_MASK_COLOR)
   {
      png_byte maxbits;

      maxbits = (png_byte)(color_type==PNG_COLOR_TYPE_PALETTE ? 8 :
                png_ptr->usr_bit_depth);
      if (sbit->red == 0 || sbit->red > maxbits ||
          sbit->green == 0 || sbit->green > maxbits ||
          sbit->blue == 0 || sbit->blue > maxbits)
      {
         png_warning(png_ptr, "Invalid sBIT depth specified");
         return;
      }
      buf[0] = sbit->red;
      buf[1] = sbit->green;
      buf[2] = sbit->blue;
      size = 3;
   }
   else
   {
      if (sbit->gray == 0 || sbit->gray > png_ptr->usr_bit_depth)
      {
         png_warning(png_ptr, "Invalid sBIT depth specified");
         return;
      }
      buf[0] = sbit->gray;
      size = 1;
   }

   if (color_type & PNG_COLOR_MASK_ALPHA)
   {
      if (sbit->alpha == 0 || sbit->alpha > png_ptr->usr_bit_depth)
      {
         png_warning(png_ptr, "Invalid sBIT depth specified");
         return;
      }
      buf[size++] = sbit->alpha;
   }

   png_write_chunk(png_ptr, (png_bytep)png_sBIT, buf, size);
}
#endif

#ifdef PNG_WRITE_cHRM_SUPPORTED
/* Write the cHRM chunk */
#ifdef PNG_FLOATING_POINT_SUPPORTED
void /* PRIVATE */
png_write_cHRM(png_structp png_ptr, double white_x, double white_y,
   double red_x, double red_y, double green_x, double green_y,
   double blue_x, double blue_y)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_cHRM;
#endif
   png_byte buf[32];

   png_fixed_point int_white_x, int_white_y, int_red_x, int_red_y,
      int_green_x, int_green_y, int_blue_x, int_blue_y;

   png_debug(1, "in png_write_cHRM");

   int_white_x = (png_uint_32)(white_x * 100000.0 + 0.5);
   int_white_y = (png_uint_32)(white_y * 100000.0 + 0.5);
   int_red_x   = (png_uint_32)(red_x   * 100000.0 + 0.5);
   int_red_y   = (png_uint_32)(red_y   * 100000.0 + 0.5);
   int_green_x = (png_uint_32)(green_x * 100000.0 + 0.5);
   int_green_y = (png_uint_32)(green_y * 100000.0 + 0.5);
   int_blue_x  = (png_uint_32)(blue_x  * 100000.0 + 0.5);
   int_blue_y  = (png_uint_32)(blue_y  * 100000.0 + 0.5);

#ifdef PNG_CHECK_cHRM_SUPPORTED
   if (png_check_cHRM_fixed(png_ptr, int_white_x, int_white_y,
      int_red_x, int_red_y, int_green_x, int_green_y, int_blue_x, int_blue_y))
#endif
   {
      /* Each value is saved in 1/100,000ths */

      png_save_uint_32(buf, int_white_x);
      png_save_uint_32(buf + 4, int_white_y);

      png_save_uint_32(buf + 8, int_red_x);
      png_save_uint_32(buf + 12, int_red_y);

      png_save_uint_32(buf + 16, int_green_x);
      png_save_uint_32(buf + 20, int_green_y);

      png_save_uint_32(buf + 24, int_blue_x);
      png_save_uint_32(buf + 28, int_blue_y);

      png_write_chunk(png_ptr, (png_bytep)png_cHRM, buf, (png_size_t)32);
   }
}
#endif
#ifdef PNG_FIXED_POINT_SUPPORTED
void /* PRIVATE */
png_write_cHRM_fixed(png_structp png_ptr, png_fixed_point white_x,
   png_fixed_point white_y, png_fixed_point red_x, png_fixed_point red_y,
   png_fixed_point green_x, png_fixed_point green_y, png_fixed_point blue_x,
   png_fixed_point blue_y)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_cHRM;
#endif
   png_byte buf[32];

   png_debug(1, "in png_write_cHRM");

   /* Each value is saved in 1/100,000ths */
#ifdef PNG_CHECK_cHRM_SUPPORTED
   if (png_check_cHRM_fixed(png_ptr, white_x, white_y, red_x, red_y,
      green_x, green_y, blue_x, blue_y))
#endif
   {
      png_save_uint_32(buf, (png_uint_32)white_x);
      png_save_uint_32(buf + 4, (png_uint_32)white_y);

      png_save_uint_32(buf + 8, (png_uint_32)red_x);
      png_save_uint_32(buf + 12, (png_uint_32)red_y);

      png_save_uint_32(buf + 16, (png_uint_32)green_x);
      png_save_uint_32(buf + 20, (png_uint_32)green_y);

      png_save_uint_32(buf + 24, (png_uint_32)blue_x);
      png_save_uint_32(buf + 28, (png_uint_32)blue_y);

      png_write_chunk(png_ptr, (png_bytep)png_cHRM, buf, (png_size_t)32);
   }
}
#endif
#endif

#ifdef PNG_WRITE_tRNS_SUPPORTED
/* Write the tRNS chunk */
void /* PRIVATE */
png_write_tRNS(png_structp png_ptr, png_bytep trans, png_color_16p tran,
   int num_trans, int color_type)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_tRNS;
#endif
   png_byte buf[6];

   png_debug(1, "in png_write_tRNS");

   if (color_type == PNG_COLOR_TYPE_PALETTE)
   {
      if (num_trans <= 0 || num_trans > (int)png_ptr->num_palette)
      {
         png_warning(png_ptr, "Invalid number of transparent colors specified");
         return;
      }
      /* Write the chunk out as it is */
      png_write_chunk(png_ptr, (png_bytep)png_tRNS, trans,
        (png_size_t)num_trans);
   }
   else if (color_type == PNG_COLOR_TYPE_GRAY)
   {
      /* One 16 bit value */
      if (tran->gray >= (1 << png_ptr->bit_depth))
      {
         png_warning(png_ptr,
           "Ignoring attempt to write tRNS chunk out-of-range for bit_depth");
         return;
      }
      png_save_uint_16(buf, tran->gray);
      png_write_chunk(png_ptr, (png_bytep)png_tRNS, buf, (png_size_t)2);
   }
   else if (color_type == PNG_COLOR_TYPE_RGB)
   {
      /* Three 16 bit values */
      png_save_uint_16(buf, tran->red);
      png_save_uint_16(buf + 2, tran->green);
      png_save_uint_16(buf + 4, tran->blue);
      if (png_ptr->bit_depth == 8 && (buf[0] | buf[2] | buf[4]))
      {
         png_warning(png_ptr,
           "Ignoring attempt to write 16-bit tRNS chunk when bit_depth is 8");
         return;
      }
      png_write_chunk(png_ptr, (png_bytep)png_tRNS, buf, (png_size_t)6);
   }
   else
   {
      png_warning(png_ptr, "Can't write tRNS with an alpha channel");
   }
}
#endif

#ifdef PNG_WRITE_bKGD_SUPPORTED
/* Write the background chunk */
void /* PRIVATE */
png_write_bKGD(png_structp png_ptr, png_color_16p back, int color_type)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_bKGD;
#endif
   png_byte buf[6];

   png_debug(1, "in png_write_bKGD");

   if (color_type == PNG_COLOR_TYPE_PALETTE)
   {
      if (
#ifdef PNG_MNG_FEATURES_SUPPORTED
          (png_ptr->num_palette ||
          (!(png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE))) &&
#endif
         back->index >= png_ptr->num_palette)
      {
         png_warning(png_ptr, "Invalid background palette index");
         return;
      }
      buf[0] = back->index;
      png_write_chunk(png_ptr, (png_bytep)png_bKGD, buf, (png_size_t)1);
   }
   else if (color_type & PNG_COLOR_MASK_COLOR)
   {
      png_save_uint_16(buf, back->red);
      png_save_uint_16(buf + 2, back->green);
      png_save_uint_16(buf + 4, back->blue);
      if (png_ptr->bit_depth == 8 && (buf[0] | buf[2] | buf[4]))
      {
         png_warning(png_ptr,
           "Ignoring attempt to write 16-bit bKGD chunk when bit_depth is 8");
         return;
      }
      png_write_chunk(png_ptr, (png_bytep)png_bKGD, buf, (png_size_t)6);
   }
   else
   {
      if (back->gray >= (1 << png_ptr->bit_depth))
      {
         png_warning(png_ptr,
           "Ignoring attempt to write bKGD chunk out-of-range for bit_depth");
         return;
      }
      png_save_uint_16(buf, back->gray);
      png_write_chunk(png_ptr, (png_bytep)png_bKGD, buf, (png_size_t)2);
   }
}
#endif

#ifdef PNG_WRITE_hIST_SUPPORTED
/* Write the histogram */
void /* PRIVATE */
png_write_hIST(png_structp png_ptr, png_uint_16p hist, int num_hist)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_hIST;
#endif
   int i;
   png_byte buf[3];

   png_debug(1, "in png_write_hIST");

   if (num_hist > (int)png_ptr->num_palette)
   {
      png_debug2(3, "num_hist = %d, num_palette = %d", num_hist,
         png_ptr->num_palette);
      png_warning(png_ptr, "Invalid number of histogram entries specified");
      return;
   }

   png_write_chunk_start(png_ptr, (png_bytep)png_hIST,
     (png_uint_32)(num_hist * 2));
   for (i = 0; i < num_hist; i++)
   {
      png_save_uint_16(buf, hist[i]);
      png_write_chunk_data(png_ptr, buf, (png_size_t)2);
   }
   png_write_chunk_end(png_ptr);
}
#endif

#ifdef PNG_WRITE_tEXt_SUPPORTED
/* Write a tEXt chunk */
void /* PRIVATE */
png_write_tEXt(png_structp png_ptr, png_charp key, png_charp text,
   png_size_t text_len)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_tEXt;
#endif
   png_size_t key_len;
   png_charp new_key;

   png_debug(1, "in png_write_tEXt");

   if ((key_len = png_check_keyword(png_ptr, key, &new_key))==0)
      return;

   if (text == NULL || *text == '\0')
      text_len = 0;
   else
      text_len = png_strlen(text);

   /* Make sure we include the 0 after the key */
   png_write_chunk_start(png_ptr, (png_bytep)png_tEXt,
      (png_uint_32)(key_len + text_len + 1));
   /*
    * We leave it to the application to meet PNG-1.0 requirements on the
    * contents of the text.  PNG-1.0 through PNG-1.2 discourage the use of
    * any non-Latin-1 characters except for NEWLINE.  ISO PNG will forbid them.
    * The NUL character is forbidden by PNG-1.0 through PNG-1.2 and ISO PNG.
    */
   png_write_chunk_data(png_ptr, (png_bytep)new_key,
     (png_size_t)(key_len + 1));
   if (text_len)
      png_write_chunk_data(png_ptr, (png_bytep)text, (png_size_t)text_len);

   png_write_chunk_end(png_ptr);
   png_free(png_ptr, new_key);
}
#endif

#ifdef PNG_WRITE_zTXt_SUPPORTED
/* Write a compressed text chunk */
void /* PRIVATE */
png_write_zTXt(png_structp png_ptr, png_charp key, png_charp text,
   png_size_t text_len, int compression)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_zTXt;
#endif
   png_size_t key_len;
   char buf[1];
   png_charp new_key;
   compression_state comp;

   png_debug(1, "in png_write_zTXt");

   comp.num_output_ptr = 0;
   comp.max_output_ptr = 0;
   comp.output_ptr = NULL;
   comp.input = NULL;
   comp.input_len = 0;

   if ((key_len = png_check_keyword(png_ptr, key, &new_key))==0)
   {
      png_free(png_ptr, new_key);
      return;
   }

   if (text == NULL || *text == '\0' || compression==PNG_TEXT_COMPRESSION_NONE)
   {
      png_write_tEXt(png_ptr, new_key, text, (png_size_t)0);
      png_free(png_ptr, new_key);
      return;
   }

   text_len = png_strlen(text);

   /* Compute the compressed data; do it now for the length */
   text_len = png_text_compress(png_ptr, text, text_len, compression,
       &comp);

   /* Write start of chunk */
   png_write_chunk_start(png_ptr, (png_bytep)png_zTXt,
     (png_uint_32)(key_len+text_len + 2));
   /* Write key */
   png_write_chunk_data(png_ptr, (png_bytep)new_key,
     (png_size_t)(key_len + 1));
   png_free(png_ptr, new_key);

   buf[0] = (png_byte)compression;
   /* Write compression */
   png_write_chunk_data(png_ptr, (png_bytep)buf, (png_size_t)1);
   /* Write the compressed data */
   png_write_compressed_data_out(png_ptr, &comp);

   /* Close the chunk */
   png_write_chunk_end(png_ptr);
}
#endif

#ifdef PNG_WRITE_iTXt_SUPPORTED
/* Write an iTXt chunk */
void /* PRIVATE */
png_write_iTXt(png_structp png_ptr, int compression, png_charp key,
    png_charp lang, png_charp lang_key, png_charp text)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_iTXt;
#endif
   png_size_t lang_len, key_len, lang_key_len, text_len;
   png_charp new_lang;
   png_charp new_key = NULL;
   png_byte cbuf[2];
   compression_state comp;

   png_debug(1, "in png_write_iTXt");

   comp.num_output_ptr = 0;
   comp.max_output_ptr = 0;
   comp.output_ptr = NULL;
   comp.input = NULL;

   if ((key_len = png_check_keyword(png_ptr, key, &new_key))==0)
      return;

   if ((lang_len = png_check_keyword(png_ptr, lang, &new_lang))==0)
   {
      png_warning(png_ptr, "Empty language field in iTXt chunk");
      new_lang = NULL;
      lang_len = 0;
   }

   if (lang_key == NULL)
      lang_key_len = 0;
   else
      lang_key_len = png_strlen(lang_key);

   if (text == NULL)
      text_len = 0;
   else
      text_len = png_strlen(text);

   /* Compute the compressed data; do it now for the length */
   text_len = png_text_compress(png_ptr, text, text_len, compression-2,
      &comp);


   /* Make sure we include the compression flag, the compression byte,
    * and the NULs after the key, lang, and lang_key parts */

   png_write_chunk_start(png_ptr, (png_bytep)png_iTXt,
          (png_uint_32)(
        5 /* comp byte, comp flag, terminators for key, lang and lang_key */
        + key_len
        + lang_len
        + lang_key_len
        + text_len));

   /* We leave it to the application to meet PNG-1.0 requirements on the
    * contents of the text.  PNG-1.0 through PNG-1.2 discourage the use of
    * any non-Latin-1 characters except for NEWLINE.  ISO PNG will forbid them.
    * The NUL character is forbidden by PNG-1.0 through PNG-1.2 and ISO PNG.
    */
   png_write_chunk_data(png_ptr, (png_bytep)new_key,
     (png_size_t)(key_len + 1));

   /* Set the compression flag */
   if (compression == PNG_ITXT_COMPRESSION_NONE || \
       compression == PNG_TEXT_COMPRESSION_NONE)
       cbuf[0] = 0;
   else /* compression == PNG_ITXT_COMPRESSION_zTXt */
       cbuf[0] = 1;
   /* Set the compression method */
   cbuf[1] = 0;
   png_write_chunk_data(png_ptr, cbuf, (png_size_t)2);

   cbuf[0] = 0;
   png_write_chunk_data(png_ptr, (new_lang ? (png_bytep)new_lang : cbuf),
     (png_size_t)(lang_len + 1));
   png_write_chunk_data(png_ptr, (lang_key ? (png_bytep)lang_key : cbuf),
     (png_size_t)(lang_key_len + 1));
   png_write_compressed_data_out(png_ptr, &comp);

   png_write_chunk_end(png_ptr);
   png_free(png_ptr, new_key);
   png_free(png_ptr, new_lang);
}
#endif

#ifdef PNG_WRITE_oFFs_SUPPORTED
/* Write the oFFs chunk */
void /* PRIVATE */
png_write_oFFs(png_structp png_ptr, png_int_32 x_offset, png_int_32 y_offset,
   int unit_type)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_oFFs;
#endif
   png_byte buf[9];

   png_debug(1, "in png_write_oFFs");

   if (unit_type >= PNG_OFFSET_LAST)
      png_warning(png_ptr, "Unrecognized unit type for oFFs chunk");

   png_save_int_32(buf, x_offset);
   png_save_int_32(buf + 4, y_offset);
   buf[8] = (png_byte)unit_type;

   png_write_chunk(png_ptr, (png_bytep)png_oFFs, buf, (png_size_t)9);
}
#endif
#ifdef PNG_WRITE_pCAL_SUPPORTED
/* Write the pCAL chunk (described in the PNG extensions document) */
void /* PRIVATE */
png_write_pCAL(png_structp png_ptr, png_charp purpose, png_int_32 X0,
   png_int_32 X1, int type, int nparams, png_charp units, png_charpp params)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_pCAL;
#endif
   png_size_t purpose_len, units_len, total_len;
   png_uint_32p params_len;
   png_byte buf[10];
   png_charp new_purpose;
   int i;

   png_debug1(1, "in png_write_pCAL (%d parameters)", nparams);

   if (type >= PNG_EQUATION_LAST)
      png_warning(png_ptr, "Unrecognized equation type for pCAL chunk");

   purpose_len = png_check_keyword(png_ptr, purpose, &new_purpose) + 1;
   png_debug1(3, "pCAL purpose length = %d", (int)purpose_len);
   units_len = png_strlen(units) + (nparams == 0 ? 0 : 1);
   png_debug1(3, "pCAL units length = %d", (int)units_len);
   total_len = purpose_len + units_len + 10;

   params_len = (png_uint_32p)png_malloc(png_ptr,
      (png_uint_32)(nparams * png_sizeof(png_uint_32)));

   /* Find the length of each parameter, making sure we don't count the
      null terminator for the last parameter. */
   for (i = 0; i < nparams; i++)
   {
      params_len[i] = png_strlen(params[i]) + (i == nparams - 1 ? 0 : 1);
      png_debug2(3, "pCAL parameter %d length = %lu", i,
        (unsigned long) params_len[i]);
      total_len += (png_size_t)params_len[i];
   }

   png_debug1(3, "pCAL total length = %d", (int)total_len);
   png_write_chunk_start(png_ptr, (png_bytep)png_pCAL, (png_uint_32)total_len);
   png_write_chunk_data(png_ptr, (png_bytep)new_purpose,
     (png_size_t)purpose_len);
   png_save_int_32(buf, X0);
   png_save_int_32(buf + 4, X1);
   buf[8] = (png_byte)type;
   buf[9] = (png_byte)nparams;
   png_write_chunk_data(png_ptr, buf, (png_size_t)10);
   png_write_chunk_data(png_ptr, (png_bytep)units, (png_size_t)units_len);

   png_free(png_ptr, new_purpose);

   for (i = 0; i < nparams; i++)
   {
      png_write_chunk_data(png_ptr, (png_bytep)params[i],
         (png_size_t)params_len[i]);
   }

   png_free(png_ptr, params_len);
   png_write_chunk_end(png_ptr);
}
#endif

#ifdef PNG_WRITE_sCAL_SUPPORTED
/* Write the sCAL chunk */
#if defined(PNG_FLOATING_POINT_SUPPORTED) && defined(PNG_STDIO_SUPPORTED)
void /* PRIVATE */
png_write_sCAL(png_structp png_ptr, int unit, double width, double height)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_sCAL;
#endif
   char buf[64];
   png_size_t total_len;

   png_debug(1, "in png_write_sCAL");

   buf[0] = (char)unit;
#ifdef _WIN32_WCE
/* sprintf() function is not supported on WindowsCE */
   {
      wchar_t wc_buf[32];
      size_t wc_len;
      swprintf(wc_buf, TEXT("%12.12e"), width);
      wc_len = wcslen(wc_buf);
      WideCharToMultiByte(CP_ACP, 0, wc_buf, -1, buf + 1, wc_len, NULL,
          NULL);
      total_len = wc_len + 2;
      swprintf(wc_buf, TEXT("%12.12e"), height);
      wc_len = wcslen(wc_buf);
      WideCharToMultiByte(CP_ACP, 0, wc_buf, -1, buf + total_len, wc_len,
         NULL, NULL);
      total_len += wc_len;
   }
#else
   png_snprintf(buf + 1, 63, "%12.12e", width);
   total_len = 1 + png_strlen(buf + 1) + 1;
   png_snprintf(buf + total_len, 64-total_len, "%12.12e", height);
   total_len += png_strlen(buf + total_len);
#endif

   png_debug1(3, "sCAL total length = %u", (unsigned int)total_len);
   png_write_chunk(png_ptr, (png_bytep)png_sCAL, (png_bytep)buf, total_len);
}
#else
#ifdef PNG_FIXED_POINT_SUPPORTED
void /* PRIVATE */
png_write_sCAL_s(png_structp png_ptr, int unit, png_charp width,
   png_charp height)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_sCAL;
#endif
   png_byte buf[64];
   png_size_t wlen, hlen, total_len;

   png_debug(1, "in png_write_sCAL_s");

   wlen = png_strlen(width);
   hlen = png_strlen(height);
   total_len = wlen + hlen + 2;
   if (total_len > 64)
   {
      png_warning(png_ptr, "Can't write sCAL (buffer too small)");
      return;
   }

   buf[0] = (png_byte)unit;
   png_memcpy(buf + 1, width, wlen + 1);      /* Append the '\0' here */
   png_memcpy(buf + wlen + 2, height, hlen);  /* Do NOT append the '\0' here */

   png_debug1(3, "sCAL total length = %u", (unsigned int)total_len);
   png_write_chunk(png_ptr, (png_bytep)png_sCAL, buf, total_len);
}
#endif
#endif
#endif

#ifdef PNG_WRITE_pHYs_SUPPORTED
/* Write the pHYs chunk */
void /* PRIVATE */
png_write_pHYs(png_structp png_ptr, png_uint_32 x_pixels_per_unit,
   png_uint_32 y_pixels_per_unit,
   int unit_type)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_pHYs;
#endif
   png_byte buf[9];

   png_debug(1, "in png_write_pHYs");

   if (unit_type >= PNG_RESOLUTION_LAST)
      png_warning(png_ptr, "Unrecognized unit type for pHYs chunk");

   png_save_uint_32(buf, x_pixels_per_unit);
   png_save_uint_32(buf + 4, y_pixels_per_unit);
   buf[8] = (png_byte)unit_type;

   png_write_chunk(png_ptr, (png_bytep)png_pHYs, buf, (png_size_t)9);
}
#endif

#ifdef PNG_WRITE_tIME_SUPPORTED
/* Write the tIME chunk.  Use either png_convert_from_struct_tm()
 * or png_convert_from_time_t(), or fill in the structure yourself.
 */
void /* PRIVATE */
png_write_tIME(png_structp png_ptr, png_timep mod_time)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_tIME;
#endif
   png_byte buf[7];

   png_debug(1, "in png_write_tIME");

   if (mod_time->month  > 12 || mod_time->month  < 1 ||
       mod_time->day    > 31 || mod_time->day    < 1 ||
       mod_time->hour   > 23 || mod_time->second > 60)
   {
      png_warning(png_ptr, "Invalid time specified for tIME chunk");
      return;
   }

   png_save_uint_16(buf, mod_time->year);
   buf[2] = mod_time->month;
   buf[3] = mod_time->day;
   buf[4] = mod_time->hour;
   buf[5] = mod_time->minute;
   buf[6] = mod_time->second;

   png_write_chunk(png_ptr, (png_bytep)png_tIME, buf, (png_size_t)7);
}
#endif

/* Initializes the row writing capability of libpng */
void /* PRIVATE */
png_write_start_row(png_structp png_ptr)
{
#ifdef PNG_WRITE_INTERLACING_SUPPORTED
#ifndef PNG_USE_GLOBAL_ARRAYS
   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */

   /* Start of interlace block */
   int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};

   /* Offset to next interlace block */
   int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};

   /* Start of interlace block in the y direction */
   int png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};

   /* Offset to next interlace block in the y direction */
   int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
#endif
#endif

   png_size_t buf_size;

   png_debug(1, "in png_write_start_row");

   buf_size = (png_size_t)(PNG_ROWBYTES(
      png_ptr->usr_channels*png_ptr->usr_bit_depth, png_ptr->width) + 1);

   /* Set up row buffer */
   png_ptr->row_buf = (png_bytep)png_malloc(png_ptr,
     (png_uint_32)buf_size);
   png_ptr->row_buf[0] = PNG_FILTER_VALUE_NONE;

#ifdef PNG_WRITE_FILTER_SUPPORTED
   /* Set up filtering buffer, if using this filter */
   if (png_ptr->do_filter & PNG_FILTER_SUB)
   {
      png_ptr->sub_row = (png_bytep)png_malloc(png_ptr,
         (png_uint_32)(png_ptr->rowbytes + 1));
      png_ptr->sub_row[0] = PNG_FILTER_VALUE_SUB;
   }

   /* We only need to keep the previous row if we are using one of these. */
   if (png_ptr->do_filter & (PNG_FILTER_AVG | PNG_FILTER_UP | PNG_FILTER_PAETH))
   {
      /* Set up previous row buffer */
      png_ptr->prev_row = (png_bytep)png_calloc(png_ptr,
         (png_uint_32)buf_size);

      if (png_ptr->do_filter & PNG_FILTER_UP)
      {
         png_ptr->up_row = (png_bytep)png_malloc(png_ptr,
            (png_uint_32)(png_ptr->rowbytes + 1));
         png_ptr->up_row[0] = PNG_FILTER_VALUE_UP;
      }

      if (png_ptr->do_filter & PNG_FILTER_AVG)
      {
         png_ptr->avg_row = (png_bytep)png_malloc(png_ptr,
            (png_uint_32)(png_ptr->rowbytes + 1));
         png_ptr->avg_row[0] = PNG_FILTER_VALUE_AVG;
      }

      if (png_ptr->do_filter & PNG_FILTER_PAETH)
      {
         png_ptr->paeth_row = (png_bytep)png_malloc(png_ptr,
            (png_uint_32)(png_ptr->rowbytes + 1));
         png_ptr->paeth_row[0] = PNG_FILTER_VALUE_PAETH;
      }
   }
#endif /* PNG_WRITE_FILTER_SUPPORTED */

#ifdef PNG_WRITE_INTERLACING_SUPPORTED
   /* If interlaced, we need to set up width and height of pass */
   if (png_ptr->interlaced)
   {
      if (!(png_ptr->transformations & PNG_INTERLACE))
      {
         png_ptr->num_rows = (png_ptr->height + png_pass_yinc[0] - 1 -
            png_pass_ystart[0]) / png_pass_yinc[0];
         png_ptr->usr_width = (png_ptr->width + png_pass_inc[0] - 1 -
            png_pass_start[0]) / png_pass_inc[0];
      }
      else
      {
         png_ptr->num_rows = png_ptr->height;
         png_ptr->usr_width = png_ptr->width;
      }
   }
   else
#endif
   {
      png_ptr->num_rows = png_ptr->height;
      png_ptr->usr_width = png_ptr->width;
   }
   png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
   png_ptr->zstream.next_out = png_ptr->zbuf;
}

/* Internal use only.  Called when finished processing a row of data. */
void /* PRIVATE */
png_write_finish_row(png_structp png_ptr)
{
#ifdef PNG_WRITE_INTERLACING_SUPPORTED
#ifndef PNG_USE_GLOBAL_ARRAYS
   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */

   /* Start of interlace block */
   int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};

   /* Offset to next interlace block */
   int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};

   /* Start of interlace block in the y direction */
   int png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};

   /* Offset to next interlace block in the y direction */
   int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
#endif
#endif

   int ret;

   png_debug(1, "in png_write_finish_row");

   /* Next row */
   png_ptr->row_number++;

   /* See if we are done */
   if (png_ptr->row_number < png_ptr->num_rows)
      return;

#ifdef PNG_WRITE_INTERLACING_SUPPORTED
   /* If interlaced, go to next pass */
   if (png_ptr->interlaced)
   {
      png_ptr->row_number = 0;
      if (png_ptr->transformations & PNG_INTERLACE)
      {
         png_ptr->pass++;
      }
      else
      {
         /* Loop until we find a non-zero width or height pass */
         do
         {
            png_ptr->pass++;
            if (png_ptr->pass >= 7)
               break;
            png_ptr->usr_width = (png_ptr->width +
               png_pass_inc[png_ptr->pass] - 1 -
               png_pass_start[png_ptr->pass]) /
               png_pass_inc[png_ptr->pass];
            png_ptr->num_rows = (png_ptr->height +
               png_pass_yinc[png_ptr->pass] - 1 -
               png_pass_ystart[png_ptr->pass]) /
               png_pass_yinc[png_ptr->pass];
            if (png_ptr->transformations & PNG_INTERLACE)
               break;
         } while (png_ptr->usr_width == 0 || png_ptr->num_rows == 0);

      }

      /* Reset the row above the image for the next pass */
      if (png_ptr->pass < 7)
      {
         if (png_ptr->prev_row != NULL)
            png_memset(png_ptr->prev_row, 0,
               (png_size_t)(PNG_ROWBYTES(png_ptr->usr_channels*
               png_ptr->usr_bit_depth, png_ptr->width)) + 1);
         return;
      }
   }
#endif

   /* If we get here, we've just written the last row, so we need
      to flush the compressor */
   do
   {
      /* Tell the compressor we are done */
      ret = deflate(&png_ptr->zstream, Z_FINISH);
      /* Check for an error */
      if (ret == Z_OK)
      {
         /* Check to see if we need more room */
         if (!(png_ptr->zstream.avail_out))
         {
            png_write_IDAT(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size);
            png_ptr->zstream.next_out = png_ptr->zbuf;
            png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
         }
      }
      else if (ret != Z_STREAM_END)
      {
         if (png_ptr->zstream.msg != NULL)
            png_error(png_ptr, png_ptr->zstream.msg);
         else
            png_error(png_ptr, "zlib error");
      }
   } while (ret != Z_STREAM_END);

   /* Write any extra space */
   if (png_ptr->zstream.avail_out < png_ptr->zbuf_size)
   {
      png_write_IDAT(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size -
         png_ptr->zstream.avail_out);
   }

   deflateReset(&png_ptr->zstream);
   png_ptr->zstream.data_type = Z_BINARY;
}

#ifdef PNG_WRITE_INTERLACING_SUPPORTED
/* Pick out the correct pixels for the interlace pass.
 * The basic idea here is to go through the row with a source
 * pointer and a destination pointer (sp and dp), and copy the
 * correct pixels for the pass.  As the row gets compacted,
 * sp will always be >= dp, so we should never overwrite anything.
 * See the default: case for the easiest code to understand.
 */
void /* PRIVATE */
png_do_write_interlace(png_row_infop row_info, png_bytep row, int pass)
{
   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */

#ifndef PNG_USE_GLOBAL_ARRAYS
   /* Start of interlace block */
   int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};

   /* Offset to next interlace block */
   int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
#endif

   png_debug(1, "in png_do_write_interlace");

   /* We don't have to do anything on the last pass (6) */
#ifdef PNG_USELESS_TESTS_SUPPORTED
   if (row != NULL && row_info != NULL && pass < 6)
#else
   if (pass < 6)
#endif
   {
      /* Each pixel depth is handled separately */
      switch (row_info->pixel_depth)
      {
         case 1:
         {
            png_bytep sp;
            png_bytep dp;
            int shift;
            int d;
            int value;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            dp = row;
            d = 0;
            shift = 7;
            for (i = png_pass_start[pass]; i < row_width;
               i += png_pass_inc[pass])
            {
               sp = row + (png_size_t)(i >> 3);
               value = (int)(*sp >> (7 - (int)(i & 0x07))) & 0x01;
               d |= (value << shift);

               if (shift == 0)
               {
                  shift = 7;
                  *dp++ = (png_byte)d;
                  d = 0;
               }
               else
                  shift--;

            }
            if (shift != 7)
               *dp = (png_byte)d;
            break;
         }
         case 2:
         {
            png_bytep sp;
            png_bytep dp;
            int shift;
            int d;
            int value;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            dp = row;
            shift = 6;
            d = 0;
            for (i = png_pass_start[pass]; i < row_width;
               i += png_pass_inc[pass])
            {
               sp = row + (png_size_t)(i >> 2);
               value = (*sp >> ((3 - (int)(i & 0x03)) << 1)) & 0x03;
               d |= (value << shift);

               if (shift == 0)
               {
                  shift = 6;
                  *dp++ = (png_byte)d;
                  d = 0;
               }
               else
                  shift -= 2;
            }
            if (shift != 6)
                   *dp = (png_byte)d;
            break;
         }
         case 4:
         {
            png_bytep sp;
            png_bytep dp;
            int shift;
            int d;
            int value;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            dp = row;
            shift = 4;
            d = 0;
            for (i = png_pass_start[pass]; i < row_width;
               i += png_pass_inc[pass])
            {
               sp = row + (png_size_t)(i >> 1);
               value = (*sp >> ((1 - (int)(i & 0x01)) << 2)) & 0x0f;
               d |= (value << shift);

               if (shift == 0)
               {
                  shift = 4;
                  *dp++ = (png_byte)d;
                  d = 0;
               }
               else
                  shift -= 4;
            }
            if (shift != 4)
               *dp = (png_byte)d;
            break;
         }
         default:
         {
            png_bytep sp;
            png_bytep dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;
            png_size_t pixel_bytes;

            /* Start at the beginning */
            dp = row;
            /* Find out how many bytes each pixel takes up */
            pixel_bytes = (row_info->pixel_depth >> 3);
            /* Loop through the row, only looking at the pixels that
               matter */
            for (i = png_pass_start[pass]; i < row_width;
               i += png_pass_inc[pass])
            {
               /* Find out where the original pixel is */
               sp = row + (png_size_t)i * pixel_bytes;
               /* Move the pixel */
               if (dp != sp)
                  png_memcpy(dp, sp, pixel_bytes);
               /* Next pixel */
               dp += pixel_bytes;
            }
            break;
         }
      }
      /* Set new row width */
      row_info->width = (row_info->width +
         png_pass_inc[pass] - 1 -
         png_pass_start[pass]) /
         png_pass_inc[pass];
         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,
            row_info->width);
   }
}
#endif

/* This filters the row, chooses which filter to use, if it has not already
 * been specified by the application, and then writes the row out with the
 * chosen filter.
 */
#define PNG_MAXSUM (((png_uint_32)(-1)) >> 1)
#define PNG_HISHIFT 10
#define PNG_LOMASK ((png_uint_32)0xffffL)
#define PNG_HIMASK ((png_uint_32)(~PNG_LOMASK >> PNG_HISHIFT))
void /* PRIVATE */
png_write_find_filter(png_structp png_ptr, png_row_infop row_info)
{
   png_bytep best_row;
#ifdef PNG_WRITE_FILTER_SUPPORTED
   png_bytep prev_row, row_buf;
   png_uint_32 mins, bpp;
   png_byte filter_to_do = png_ptr->do_filter;
   png_uint_32 row_bytes = row_info->rowbytes;

   png_debug(1, "in png_write_find_filter");

   /* Find out how many bytes offset each pixel is */
   bpp = (row_info->pixel_depth + 7) >> 3;

   prev_row = png_ptr->prev_row;
#endif
   best_row = png_ptr->row_buf;
#ifdef PNG_WRITE_FILTER_SUPPORTED
   row_buf = best_row;
   mins = PNG_MAXSUM;

   /* The prediction method we use is to find which method provides the
    * smallest value when summing the absolute values of the distances
    * from zero, using anything >= 128 as negative numbers.  This is known
    * as the "minimum sum of absolute differences" heuristic.  Other
    * heuristics are the "weighted minimum sum of absolute differences"
    * (experimental and can in theory improve compression), and the "zlib
    * predictive" method (not implemented yet), which does test compressions
    * of lines using different filter methods, and then chooses the
    * (series of) filter(s) that give minimum compressed data size (VERY
    * computationally expensive).
    *
    * GRR 980525:  consider also
    *   (1) minimum sum of absolute differences from running average (i.e.,
    *       keep running sum of non-absolute differences & count of bytes)
    *       [track dispersion, too?  restart average if dispersion too large?]
    *  (1b) minimum sum of absolute differences from sliding average, probably
    *       with window size <= deflate window (usually 32K)
    *   (2) minimum sum of squared differences from zero or running average
    *       (i.e., ~ root-mean-square approach)
    */


   /* We don't need to test the 'no filter' case if this is the only filter
    * that has been chosen, as it doesn't actually do anything to the data.
    */
   if ((filter_to_do & PNG_FILTER_NONE) &&
       filter_to_do != PNG_FILTER_NONE)
   {
      png_bytep rp;
      png_uint_32 sum = 0;
      png_uint_32 i;
      int v;

      for (i = 0, rp = row_buf + 1; i < row_bytes; i++, rp++)
      {
         v = *rp;
         sum += (v < 128) ? v : 256 - v;
      }

      mins = sum;
   }

   /* Sub filter */
   if (filter_to_do == PNG_FILTER_SUB)
   /* It's the only filter so no testing is needed */
   {
      png_bytep rp, lp, dp;
      png_uint_32 i;
      for (i = 0, rp = row_buf + 1, dp = png_ptr->sub_row + 1; i < bpp;
           i++, rp++, dp++)
      {
         *dp = *rp;
      }
      for (lp = row_buf + 1; i < row_bytes;
         i++, rp++, lp++, dp++)
      {
         *dp = (png_byte)(((int)*rp - (int)*lp) & 0xff);
      }
      best_row = png_ptr->sub_row;
   }

   else if (filter_to_do & PNG_FILTER_SUB)
   {
      png_bytep rp, dp, lp;
      png_uint_32 sum = 0, lmins = mins;
      png_uint_32 i;
      int v;

      for (i = 0, rp = row_buf + 1, dp = png_ptr->sub_row + 1; i < bpp;
           i++, rp++, dp++)
      {
         v = *dp = *rp;

         sum += (v < 128) ? v : 256 - v;
      }
      for (lp = row_buf + 1; i < row_bytes;
         i++, rp++, lp++, dp++)
      {
         v = *dp = (png_byte)(((int)*rp - (int)*lp) & 0xff);

         sum += (v < 128) ? v : 256 - v;

         if (sum > lmins)  /* We are already worse, don't continue. */
            break;
      }

      if (sum < mins)
      {
         mins = sum;
         best_row = png_ptr->sub_row;
      }
   }

   /* Up filter */
   if (filter_to_do == PNG_FILTER_UP)
   {
      png_bytep rp, dp, pp;
      png_uint_32 i;

      for (i = 0, rp = row_buf + 1, dp = png_ptr->up_row + 1,
           pp = prev_row + 1; i < row_bytes;
           i++, rp++, pp++, dp++)
      {
         *dp = (png_byte)(((int)*rp - (int)*pp) & 0xff);
      }
      best_row = png_ptr->up_row;
   }

   else if (filter_to_do & PNG_FILTER_UP)
   {
      png_bytep rp, dp, pp;
      png_uint_32 sum = 0, lmins = mins;
      png_uint_32 i;
      int v;

      for (i = 0, rp = row_buf + 1, dp = png_ptr->up_row + 1,
           pp = prev_row + 1; i < row_bytes; i++)
      {
         v = *dp++ = (png_byte)(((int)*rp++ - (int)*pp++) & 0xff);

         sum += (v < 128) ? v : 256 - v;

         if (sum > lmins)  /* We are already worse, don't continue. */
            break;
      }

      if (sum < mins)
      {
         mins = sum;
         best_row = png_ptr->up_row;
      }
   }

   /* Avg filter */
   if (filter_to_do == PNG_FILTER_AVG)
   {
      png_bytep rp, dp, pp, lp;
      png_uint_32 i;
      for (i = 0, rp = row_buf + 1, dp = png_ptr->avg_row + 1,
           pp = prev_row + 1; i < bpp; i++)
      {
         *dp++ = (png_byte)(((int)*rp++ - ((int)*pp++ / 2)) & 0xff);
      }
      for (lp = row_buf + 1; i < row_bytes; i++)
      {
         *dp++ = (png_byte)(((int)*rp++ - (((int)*pp++ + (int)*lp++) / 2))
                 & 0xff);
      }
      best_row = png_ptr->avg_row;
   }

   else if (filter_to_do & PNG_FILTER_AVG)
   {
      png_bytep rp, dp, pp, lp;
      png_uint_32 sum = 0, lmins = mins;
      png_uint_32 i;
      int v;

      for (i = 0, rp = row_buf + 1, dp = png_ptr->avg_row + 1,
           pp = prev_row + 1; i < bpp; i++)
      {
         v = *dp++ = (png_byte)(((int)*rp++ - ((int)*pp++ / 2)) & 0xff);

         sum += (v < 128) ? v : 256 - v;
      }
      for (lp = row_buf + 1; i < row_bytes; i++)
      {
         v = *dp++ =
          (png_byte)(((int)*rp++ - (((int)*pp++ + (int)*lp++) / 2)) & 0xff);

         sum += (v < 128) ? v : 256 - v;

         if (sum > lmins)  /* We are already worse, don't continue. */
            break;
      }

      if (sum < mins)
      {
         mins = sum;
         best_row = png_ptr->avg_row;
      }
   }

   /* Paeth filter */
   if (filter_to_do == PNG_FILTER_PAETH)
   {
      png_bytep rp, dp, pp, cp, lp;
      png_uint_32 i;
      for (i = 0, rp = row_buf + 1, dp = png_ptr->paeth_row + 1,
           pp = prev_row + 1; i < bpp; i++)
      {
         *dp++ = (png_byte)(((int)*rp++ - (int)*pp++) & 0xff);
      }

      for (lp = row_buf + 1, cp = prev_row + 1; i < row_bytes; i++)
      {
         int a, b, c, pa, pb, pc, p;

         b = *pp++;
         c = *cp++;
         a = *lp++;

         p = b - c;
         pc = a - c;

#ifdef PNG_USE_ABS
         pa = abs(p);
         pb = abs(pc);
         pc = abs(p + pc);
#else
         pa = p < 0 ? -p : p;
         pb = pc < 0 ? -pc : pc;
         pc = (p + pc) < 0 ? -(p + pc) : p + pc;
#endif

         p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;

         *dp++ = (png_byte)(((int)*rp++ - p) & 0xff);
      }
      best_row = png_ptr->paeth_row;
   }

   else if (filter_to_do & PNG_FILTER_PAETH)
   {
      png_bytep rp, dp, pp, cp, lp;
      png_uint_32 sum = 0, lmins = mins;
      png_uint_32 i;
      int v;

      for (i = 0, rp = row_buf + 1, dp = png_ptr->paeth_row + 1,
           pp = prev_row + 1; i < bpp; i++)
      {
         v = *dp++ = (png_byte)(((int)*rp++ - (int)*pp++) & 0xff);

         sum += (v < 128) ? v : 256 - v;
      }

      for (lp = row_buf + 1, cp = prev_row + 1; i < row_bytes; i++)
      {
         int a, b, c, pa, pb, pc, p;

         b = *pp++;
         c = *cp++;
         a = *lp++;

#ifndef PNG_SLOW_PAETH
         p = b - c;
         pc = a - c;
#ifdef PNG_USE_ABS
         pa = abs(p);
         pb = abs(pc);
         pc = abs(p + pc);
#else
         pa = p < 0 ? -p : p;
         pb = pc < 0 ? -pc : pc;
         pc = (p + pc) < 0 ? -(p + pc) : p + pc;
#endif
         p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;
#else /* PNG_SLOW_PAETH */
         p = a + b - c;
         pa = abs(p - a);
         pb = abs(p - b);
         pc = abs(p - c);
         if (pa <= pb && pa <= pc)
            p = a;
         else if (pb <= pc)
            p = b;
         else
            p = c;
#endif /* PNG_SLOW_PAETH */

         v = *dp++ = (png_byte)(((int)*rp++ - p) & 0xff);

         sum += (v < 128) ? v : 256 - v;

         if (sum > lmins)  /* We are already worse, don't continue. */
            break;
      }

      if (sum < mins)
      {
         best_row = png_ptr->paeth_row;
      }
   }
#endif /* PNG_WRITE_FILTER_SUPPORTED */
   /* Do the actual writing of the filtered row data from the chosen filter. */

   png_write_filtered_row(png_ptr, best_row);
}


/* Do the actual writing of a previously filtered row. */
void /* PRIVATE */
png_write_filtered_row(png_structp png_ptr, png_bytep filtered_row)
{
   png_debug(1, "in png_write_filtered_row");

   png_debug1(2, "filter = %d", filtered_row[0]);
   /* Set up the zlib input buffer */

   png_ptr->zstream.next_in = filtered_row;
   png_ptr->zstream.avail_in = (uInt)png_ptr->row_info.rowbytes + 1;
   /* Repeat until we have compressed all the data */
   do
   {
      int ret; /* Return of zlib */

      /* Compress the data */
      ret = deflate(&png_ptr->zstream, Z_NO_FLUSH);
      /* Check for compression errors */
      if (ret != Z_OK)
      {
         if (png_ptr->zstream.msg != NULL)
            png_error(png_ptr, png_ptr->zstream.msg);
         else
            png_error(png_ptr, "zlib error");
      }

      /* See if it is time to write another IDAT */
      if (!(png_ptr->zstream.avail_out))
      {
         /* Write the IDAT and reset the zlib output buffer */
         png_write_IDAT(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size);
         png_ptr->zstream.next_out = png_ptr->zbuf;
         png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
      }
   /* Repeat until all data has been compressed */
   } while (png_ptr->zstream.avail_in);

   /* Swap the current and previous rows */
   if (png_ptr->prev_row != NULL)
   {
      png_bytep tptr;

      tptr = png_ptr->prev_row;
      png_ptr->prev_row = png_ptr->row_buf;
      png_ptr->row_buf = tptr;
   }

   /* Finish row - updates counters and flushes zlib if last row */
   png_write_finish_row(png_ptr);

#ifdef PNG_WRITE_FLUSH_SUPPORTED
   png_ptr->flush_rows++;

   if (png_ptr->flush_dist > 0 &&
       png_ptr->flush_rows >= png_ptr->flush_dist)
   {
      png_write_flush(png_ptr);
   }
#endif
}
#endif /* PNG_WRITE_SUPPORTED */
@


1.11
log
@a rather slow fastmergeâ€¦
@
text
@a1637 1
#ifndef PNG_USE_GLOBAL_ARRAYS
a1737 1
#ifndef PNG_USE_GLOBAL_ARRAYS
@


1.10
log
@merge, rebase/minify, fix
@
text
@d2 1
a2 1
__RCSID("$MirOS: src/lib/libpng/png.c,v 1.11 2009/03/15 20:08:44 tg Exp $");
d6 2
a7 2
 * Last changed in libpng 1.2.43 [February 25, 2010]
 * Copyright (c) 1998-2010 Glenn Randers-Pehrson
d259 1
a259 1
                  (comp->max_output_ptr * png_sizeof(png_charpp)));
d580 1
a580 1
   png_uint_32 i;
d586 3
d593 1
a593 1
        num_pal == 0) || num_pal > 256)
a1220 132
#if defined(PNG_WRITE_TEXT_SUPPORTED) || defined(PNG_WRITE_pCAL_SUPPORTED) || \
    defined(PNG_WRITE_iCCP_SUPPORTED) || defined(PNG_WRITE_sPLT_SUPPORTED)
/* Check that the tEXt or zTXt keyword is valid per PNG 1.0 specification,
 * and if invalid, correct the keyword rather than discarding the entire
 * chunk.  The PNG 1.0 specification requires keywords 1-79 characters in
 * length, forbids leading or trailing whitespace, multiple internal spaces,
 * and the non-break space (0x80) from ISO 8859-1.  Returns keyword length.
 *
 * The new_key is allocated to hold the corrected keyword and must be freed
 * by the calling routine.  This avoids problems with trying to write to
 * static keywords without having to have duplicate copies of the strings.
 */
png_size_t /* PRIVATE */
png_check_keyword(png_structp png_ptr, png_charp key, png_charpp new_key)
{
   png_size_t key_len;
   png_charp kp, dp;
   int kflag;
   int kwarn=0;

   png_debug(1, "in png_check_keyword");

   *new_key = NULL;

   if (key == NULL || (key_len = png_strlen(key)) == 0)
   {
      png_warning(png_ptr, "zero length keyword");
      return ((png_size_t)0);
   }

   png_debug1(2, "Keyword to be checked is '%s'", key);

   *new_key = (png_charp)png_malloc_warn(png_ptr, (png_uint_32)(key_len + 2));
   if (*new_key == NULL)
   {
      png_warning(png_ptr, "Out of memory while procesing keyword");
      return ((png_size_t)0);
   }

   /* Replace non-printing characters with a blank and print a warning */
   for (kp = key, dp = *new_key; *kp != '\0'; kp++, dp++)
   {
      if ((png_byte)*kp < 0x20 ||
         ((png_byte)*kp > 0x7E && (png_byte)*kp < 0xA1))
      {
#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)
         char msg[40];

         png_snprintf(msg, 40,
           "invalid keyword character 0x%02X", (png_byte)*kp);
         png_warning(png_ptr, msg);
#else
         png_warning(png_ptr, "invalid character in keyword");
#endif
         *dp = ' ';
      }
      else
      {
         *dp = *kp;
      }
   }
   *dp = '\0';

   /* Remove any trailing white space. */
   kp = *new_key + key_len - 1;
   if (*kp == ' ')
   {
      png_warning(png_ptr, "trailing spaces removed from keyword");

      while (*kp == ' ')
      {
         *(kp--) = '\0';
         key_len--;
      }
   }

   /* Remove any leading white space. */
   kp = *new_key;
   if (*kp == ' ')
   {
      png_warning(png_ptr, "leading spaces removed from keyword");

      while (*kp == ' ')
      {
         kp++;
         key_len--;
      }
   }

   png_debug1(2, "Checking for multiple internal spaces in '%s'", kp);

   /* Remove multiple internal spaces. */
   for (kflag = 0, dp = *new_key; *kp != '\0'; kp++)
   {
      if (*kp == ' ' && kflag == 0)
      {
         *(dp++) = *kp;
         kflag = 1;
      }
      else if (*kp == ' ')
      {
         key_len--;
         kwarn=1;
      }
      else
      {
         *(dp++) = *kp;
         kflag = 0;
      }
   }
   *dp = '\0';
   if (kwarn)
      png_warning(png_ptr, "extra interior spaces removed from keyword");

   if (key_len == 0)
   {
      png_free(png_ptr, *new_key);
       *new_key=NULL;
      png_warning(png_ptr, "Zero length keyword");
   }

   if (key_len > 79)
   {
      png_warning(png_ptr, "keyword length must be 1 - 79 characters");
      (*new_key)[79] = '\0';
      key_len = 79;
   }

   return (key_len);
}
#endif

d1635 1
d1736 1
a2033 3
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
   int num_p_filters = (int)png_ptr->num_prev_filters;
#endif 
a2036 8
#ifndef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
  if (png_ptr->row_number == 0 && filter_to_do == PNG_ALL_FILTERS)
  {
      /* These will never be selected so we need not test them. */
      filter_to_do &= ~(PNG_FILTER_UP | PNG_FILTER_PAETH);
  }
#endif 

a2085 35
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         png_uint_32 sumhi, sumlo;
         int j;
         sumlo = sum & PNG_LOMASK;
         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK; /* Gives us some footroom */

         /* Reduce the sum if we match any of the previous rows */
         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_NONE)
            {
               sumlo = (sumlo * png_ptr->filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               sumhi = (sumhi * png_ptr->filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }

         /* Factor in the cost of this filter (this is here for completeness,
          * but it makes no sense to have a "cost" for the NONE filter, as
          * it has the minimum possible computational cost - none).
          */
         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_NONE]) >>
            PNG_COST_SHIFT;
         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_NONE]) >>
            PNG_COST_SHIFT;

         if (sumhi > PNG_HIMASK)
            sum = PNG_MAXSUM;
         else
            sum = (sumhi << PNG_HISHIFT) + sumlo;
      }
#endif
a2114 35
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
      /* We temporarily increase the "minimum sum" by the factor we
       * would reduce the sum of this filter, so that we can do the
       * early exit comparison without scaling the sum each time.
       */
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         int j;
         png_uint_32 lmhi, lmlo;
         lmlo = lmins & PNG_LOMASK;
         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;

         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_SUB)
            {
               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }

         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>
            PNG_COST_SHIFT;
         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>
            PNG_COST_SHIFT;

         if (lmhi > PNG_HIMASK)
            lmins = PNG_MAXSUM;
         else
            lmins = (lmhi << PNG_HISHIFT) + lmlo;
      }
#endif

a2132 31
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         int j;
         png_uint_32 sumhi, sumlo;
         sumlo = sum & PNG_LOMASK;
         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;

         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_SUB)
            {
               sumlo = (sumlo * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               sumhi = (sumhi * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }

         sumlo = (sumlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>
            PNG_COST_SHIFT;
         sumhi = (sumhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>
            PNG_COST_SHIFT;

         if (sumhi > PNG_HIMASK)
            sum = PNG_MAXSUM;
         else
            sum = (sumhi << PNG_HISHIFT) + sumlo;
      }
#endif

a2161 32

#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         int j;
         png_uint_32 lmhi, lmlo;
         lmlo = lmins & PNG_LOMASK;
         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;

         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_UP)
            {
               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }

         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_UP]) >>
            PNG_COST_SHIFT;
         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_UP]) >>
            PNG_COST_SHIFT;

         if (lmhi > PNG_HIMASK)
            lmins = PNG_MAXSUM;
         else
            lmins = (lmhi << PNG_HISHIFT) + lmlo;
      }
#endif

a2172 31
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         int j;
         png_uint_32 sumhi, sumlo;
         sumlo = sum & PNG_LOMASK;
         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;

         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_UP)
            {
               sumlo = (sumlo * png_ptr->filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               sumhi = (sumhi * png_ptr->filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }

         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_UP]) >>
            PNG_COST_SHIFT;
         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_UP]) >>
            PNG_COST_SHIFT;

         if (sumhi > PNG_HIMASK)
            sum = PNG_MAXSUM;
         else
            sum = (sumhi << PNG_HISHIFT) + sumlo;
      }
#endif

a2204 31
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         int j;
         png_uint_32 lmhi, lmlo;
         lmlo = lmins & PNG_LOMASK;
         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;

         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_AVG)
            {
               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }

         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_AVG]) >>
            PNG_COST_SHIFT;
         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_AVG]) >>
            PNG_COST_SHIFT;

         if (lmhi > PNG_HIMASK)
            lmins = PNG_MAXSUM;
         else
            lmins = (lmhi << PNG_HISHIFT) + lmlo;
      }
#endif

a2222 31
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         int j;
         png_uint_32 sumhi, sumlo;
         sumlo = sum & PNG_LOMASK;
         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;

         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_NONE)
            {
               sumlo = (sumlo * png_ptr->filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               sumhi = (sumhi * png_ptr->filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }

         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_AVG]) >>
            PNG_COST_SHIFT;
         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_AVG]) >>
            PNG_COST_SHIFT;

         if (sumhi > PNG_HIMASK)
            sum = PNG_MAXSUM;
         else
            sum = (sumhi << PNG_HISHIFT) + sumlo;
      }
#endif

a2275 31
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         int j;
         png_uint_32 lmhi, lmlo;
         lmlo = lmins & PNG_LOMASK;
         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;

         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_PAETH)
            {
               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }

         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_PAETH]) >>
            PNG_COST_SHIFT;
         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_PAETH]) >>
            PNG_COST_SHIFT;

         if (lmhi > PNG_HIMASK)
            lmins = PNG_MAXSUM;
         else
            lmins = (lmhi << PNG_HISHIFT) + lmlo;
      }
#endif

a2325 31
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         int j;
         png_uint_32 sumhi, sumlo;
         sumlo = sum & PNG_LOMASK;
         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;

         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_PAETH)
            {
               sumlo = (sumlo * png_ptr->filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               sumhi = (sumhi * png_ptr->filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }

         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_PAETH]) >>
            PNG_COST_SHIFT;
         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_PAETH]) >>
            PNG_COST_SHIFT;

         if (sumhi > PNG_HIMASK)
            sum = PNG_MAXSUM;
         else
            sum = (sumhi << PNG_HISHIFT) + sumlo;
      }
#endif

a2334 15

#ifdef PNG_WRITE_FILTER_SUPPORTED
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
   /* Save the type of filter we picked this time for future calculations */
   if (png_ptr->num_prev_filters > 0)
   {
      int j;
      for (j = 1; j < num_p_filters; j++)
      {
         png_ptr->prev_filters[j] = png_ptr->prev_filters[j - 1];
      }
      png_ptr->prev_filters[j] = best_row[0];
   }
#endif
#endif /* PNG_WRITE_FILTER_SUPPORTED */
@


1.9
log
@SECURITY update; prodded by bsiegert@@
@
text
@d1 2
d6 2
a7 3
 * Last changed in libpng 1.2.34 [December 18, 2008]
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1998-2008 Glenn Randers-Pehrson
d10 4
d17 1
d69 1
a69 1
   /* write the rest of the 8 byte signature */
d89 2
a90 1
   if (png_ptr == NULL) return;
a107 1
   if (png_ptr == NULL) return;
d109 5
a113 1
   /* write the length and the chunk name */
d117 1
a117 1
   /* put the chunk name into png_ptr->chunk_name */
d119 1
a119 1
   /* reset the crc and run it over the chunk name */
d132 3
a134 2
   /* write the data, and run the CRC over it */
   if (png_ptr == NULL) return;
d138 1
a138 1
      /* update the CRC after writing the data,
d153 1
a153 1
   /* write the crc in a single operation */
d160 1
a160 2
/*
 * This pair of functions encapsulates the operation of (a) compressing a
d168 5
a172 5
    char *input;   /* the uncompressed input data */
    int input_len;   /* its length */
    int num_output_ptr; /* number of output pointers used */
    int max_output_ptr; /* size of output_ptr */
    png_charpp output_ptr; /* array of pointers to output */
d175 1
a175 1
/* compress given text into storage in the png_ptr structure */
d189 1
a189 1
   /* we may just want to pass the text right through */
d199 1
a199 1
#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)
d223 1
a223 1
   /* set up the compression buffers */
d229 1
a229 1
   /* this is the same compression loop as in png_write_row() */
d232 1
a232 1
      /* compress the data */
d236 1
a236 1
         /* error */
d242 1
a242 1
      /* check to see if we need more room */
d245 1
a245 1
         /* make sure the output array has room */
d270 1
a270 1
         /* save the data */
d282 1
a282 1
   /* continue until we don't have any more to compress */
d285 1
a285 1
   /* finish the compression */
d288 1
a288 1
      /* tell zlib we are finished */
d293 1
a293 1
         /* check to see if we need more room */
d296 1
a296 1
            /* check to make sure our output array has room */
d322 1
a322 1
            /* save off the data */
d337 1
a337 1
         /* we got an error */
d345 1
a345 1
   /* text length is number of buffers plus last buffer */
d353 1
a353 1
/* ship the compressed text out via chunk writes */
d359 1
a359 1
   /* handle the no-compression case */
d362 1
a362 1
       png_write_chunk_data(png_ptr, (png_bytep)comp->input,
d364 1
a364 1
       return;
d367 1
a367 1
   /* write saved output buffers, if any */
d378 1
a378 1
   /* write anything left in zbuf */
d383 1
a383 1
   /* reset zlib for another zTXt/iTXt or image data */
d403 1
a403 1
   png_byte buf[13]; /* buffer to store the IHDR info */
d406 1
d418 2
a419 1
            default: png_error(png_ptr, "Invalid bit depth for grayscale image");
d467 1
a467 1
#if defined(PNG_MNG_FEATURES_SUPPORTED)
d491 1
a491 1
   /* save off the relevent information */
d495 1
a495 1
#if defined(PNG_MNG_FEATURES_SUPPORTED)
d504 1
a504 1
   /* set the usr info, so any transformations can modify it */
d509 1
a509 1
   /* pack the header information into the buffer */
d518 1
a518 1
   /* write the chunk */
d521 1
a521 1
   /* initialize zlib with PNG info */
d564 1
a564 1
   /* set it to a predefined value, to avoid its evaluation inside zlib */
d570 1
a570 1
/* write the palette.  We are careful not to trust png_color to be in the
d585 1
d587 1
a587 1
#if defined(PNG_MNG_FEATURES_SUPPORTED)
d615 1
a615 1
#ifndef PNG_NO_POINTER_INDEXING
d624 3
a626 1
   /* This is a little slower but some buggy compilers need to do this instead */
d640 1
a640 1
/* write an IDAT chunk */
d647 1
d658 5
a662 3
         /* Avoid memory underflows and multiplication overflows. */
         /* The conditions below are practically always satisfied;
            however, they still must be checked. */
d695 1
a695 1
/* write an IEND chunk */
d702 1
d704 1
d710 2
a711 2
#if defined(PNG_WRITE_gAMA_SUPPORTED)
/* write a gAMA chunk */
d723 1
d740 1
d748 2
a749 2
#if defined(PNG_WRITE_sRGB_SUPPORTED)
/* write a sRGB chunk */
d759 1
d768 2
a769 2
#if defined(PNG_WRITE_iCCP_SUPPORTED)
/* write an iCCP chunk */
d807 8
d819 1
d834 1
a834 1
   /* make sure we include the NULL after the name and the compression type */
d849 2
a850 2
#if defined(PNG_WRITE_sPLT_SUPPORTED)
/* write a sPLT chunk */
d863 1
a863 1
#ifdef PNG_NO_POINTER_INDEXING
a867 3
   if ((name_len = png_check_keyword(png_ptr,
      spalette->name, &new_name))==0)
     return;
d869 4
a872 1
   /* make sure we include the NULL after the name */
d879 2
a880 2
   /* loop through each palette entry, writing appropriately */
#ifndef PNG_NO_POINTER_INDEXING
d930 2
a931 2
#if defined(PNG_WRITE_sBIT_SUPPORTED)
/* write the sBIT chunk */
d942 2
a943 1
   /* make sure we don't depend upon the order of PNG_COLOR_8 */
d987 2
a988 2
#if defined(PNG_WRITE_cHRM_SUPPORTED)
/* write the cHRM chunk */
d1014 1
a1014 1
#if !defined(PNG_NO_CHECK_cHRM)
d1019 1
a1019 4
     /* each value is saved in 1/100,000ths */
   
     png_save_uint_32(buf, int_white_x);
     png_save_uint_32(buf + 4, int_white_y);
d1021 2
a1022 2
     png_save_uint_32(buf + 8, int_red_x);
     png_save_uint_32(buf + 12, int_red_y);
d1024 2
a1025 2
     png_save_uint_32(buf + 16, int_green_x);
     png_save_uint_32(buf + 20, int_green_y);
d1027 2
a1028 2
     png_save_uint_32(buf + 24, int_blue_x);
     png_save_uint_32(buf + 28, int_blue_y);
d1030 4
a1033 1
     png_write_chunk(png_ptr, (png_bytep)png_cHRM, buf, (png_size_t)32);
d1050 3
a1052 2
   /* each value is saved in 1/100,000ths */
#if !defined(PNG_NO_CHECK_cHRM)
d1057 2
a1058 2
   png_save_uint_32(buf, (png_uint_32)white_x);
   png_save_uint_32(buf + 4, (png_uint_32)white_y);
d1060 2
a1061 2
   png_save_uint_32(buf + 8, (png_uint_32)red_x);
   png_save_uint_32(buf + 12, (png_uint_32)red_y);
d1063 2
a1064 2
   png_save_uint_32(buf + 16, (png_uint_32)green_x);
   png_save_uint_32(buf + 20, (png_uint_32)green_y);
d1066 2
a1067 2
   png_save_uint_32(buf + 24, (png_uint_32)blue_x);
   png_save_uint_32(buf + 28, (png_uint_32)blue_y);
d1069 1
a1069 1
   png_write_chunk(png_ptr, (png_bytep)png_cHRM, buf, (png_size_t)32);
d1075 2
a1076 2
#if defined(PNG_WRITE_tRNS_SUPPORTED)
/* write the tRNS chunk */
d1087 1
d1095 1
a1095 1
      /* write the chunk out as it is */
d1101 1
a1101 1
      /* one 16 bit value */
d1113 1
a1113 1
      /* three 16 bit values */
d1132 2
a1133 2
#if defined(PNG_WRITE_bKGD_SUPPORTED)
/* write the background chunk */
d1143 1
d1147 1
a1147 1
#if defined(PNG_MNG_FEATURES_SUPPORTED)
d1186 2
a1187 2
#if defined(PNG_WRITE_hIST_SUPPORTED)
/* write the histogram */
d1198 1
d1239 1
d1263 1
a1263 1
#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)
d1289 2
a1290 2
        *(kp--) = '\0';
        key_len--;
d1302 2
a1303 2
        kp++;
        key_len--;
d1350 2
a1351 2
#if defined(PNG_WRITE_tEXt_SUPPORTED)
/* write a tEXt chunk */
d1363 1
d1372 1
a1372 1
   /* make sure we include the 0 after the key */
d1391 2
a1392 2
#if defined(PNG_WRITE_zTXt_SUPPORTED)
/* write a compressed text chunk */
d1428 1
a1428 1
   /* compute the compressed data; do it now for the length */
d1432 1
a1432 1
   /* write start of chunk */
d1435 1
a1435 1
   /* write key */
d1441 1
a1441 1
   /* write compression */
d1443 1
a1443 1
   /* write the compressed data */
d1446 1
a1446 1
   /* close the chunk */
d1451 2
a1452 2
#if defined(PNG_WRITE_iTXt_SUPPORTED)
/* write an iTXt chunk */
d1484 1
a1484 1
     lang_key_len = 0;
d1486 1
a1486 1
     lang_key_len = png_strlen(lang_key);
d1491 1
a1491 1
     text_len = png_strlen(text);
d1493 1
a1493 1
   /* compute the compressed data; do it now for the length */
d1498 1
a1498 1
   /* make sure we include the compression flag, the compression byte,
d1509 1
a1509 2
   /*
    * We leave it to the application to meet PNG-1.0 requirements on the
d1517 1
a1517 1
   /* set the compression flag */
d1523 1
a1523 1
   /* set the compression method */
d1540 2
a1541 2
#if defined(PNG_WRITE_oFFs_SUPPORTED)
/* write the oFFs chunk */
d1552 1
d1563 2
a1564 2
#if defined(PNG_WRITE_pCAL_SUPPORTED)
/* write the pCAL chunk (described in the PNG extensions document) */
d1579 1
d1626 3
a1628 3
#if defined(PNG_WRITE_sCAL_SUPPORTED)
/* write the sCAL chunk */
#if defined(PNG_FLOATING_POINT_SUPPORTED) && !defined(PNG_NO_STDIO)
d1641 1
a1641 1
#if defined(_WIN32_WCE)
d1648 2
a1649 1
      WideCharToMultiByte(CP_ACP, 0, wc_buf, -1, buf + 1, wc_len, NULL, NULL);
d1691 2
a1692 2
   png_memcpy(buf + 1, width, wlen + 1);      /* append the '\0' here */
   png_memcpy(buf + wlen + 2, height, hlen);  /* do NOT append the '\0' here */
d1701 2
a1702 2
#if defined(PNG_WRITE_pHYs_SUPPORTED)
/* write the pHYs chunk */
d1714 1
d1726 1
a1726 1
#if defined(PNG_WRITE_tIME_SUPPORTED)
d1739 1
d1759 1
a1759 1
/* initializes the row writing capability of libpng */
d1764 1
a1764 2
#ifdef PNG_USE_LOCAL_ARRAYS
   /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */
d1766 2
a1767 1
   /* start of interlace block */
d1770 1
a1770 1
   /* offset to next interlace block */
d1773 1
a1773 1
   /* start of interlace block in the y direction */
d1776 1
a1776 1
   /* offset to next interlace block in the y direction */
d1784 1
d1788 1
a1788 1
   /* set up row buffer */
d1793 2
a1794 2
#ifndef PNG_NO_WRITE_FILTER
   /* set up filtering buffer, if using this filter */
d1805 3
a1807 4
     /* set up previous row buffer */
      png_ptr->prev_row = (png_bytep)png_malloc(png_ptr,
        (png_uint_32)buf_size);
      png_memset(png_ptr->prev_row, 0, buf_size);
d1812 1
a1812 1
           (png_uint_32)(png_ptr->rowbytes + 1));
d1819 1
a1819 1
           (png_uint_32)(png_ptr->rowbytes + 1));
d1826 1
a1826 1
           (png_uint_32)(png_ptr->rowbytes + 1));
d1830 1
a1830 1
#endif /* PNG_NO_WRITE_FILTER */
d1833 1
a1833 1
   /* if interlaced, we need to set up width and height of pass */
d1864 1
a1864 2
#ifdef PNG_USE_LOCAL_ARRAYS
   /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */
d1866 2
a1867 1
   /* start of interlace block */
d1870 1
a1870 1
   /* offset to next interlace block */
d1873 1
a1873 1
   /* start of interlace block in the y direction */
d1876 1
a1876 1
   /* offset to next interlace block in the y direction */
d1884 2
a1885 1
   /* next row */
d1888 1
a1888 1
   /* see if we are done */
d1893 1
a1893 1
   /* if interlaced, go to next pass */
d1903 1
a1903 1
         /* loop until we find a non-zero width or height pass */
d1923 1
a1923 1
      /* reset the row above the image for the next pass */
d1935 1
a1935 1
   /* if we get here, we've just written the last row, so we need
d1939 1
a1939 1
      /* tell the compressor we are done */
d1941 1
a1941 1
      /* check for an error */
d1944 1
a1944 1
         /* check to see if we need more room */
d1961 1
a1961 1
   /* write any extra space */
d1972 1
a1972 1
#if defined(PNG_WRITE_INTERLACING_SUPPORTED)
d1983 1
a1983 2
#ifdef PNG_USE_LOCAL_ARRAYS
   /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */
d1985 2
a1986 1
   /* start of interlace block */
d1989 1
a1989 1
   /* offset to next interlace block */
d1994 3
a1996 2
   /* we don't have to do anything on the last pass (6) */
#if defined(PNG_USELESS_TESTS_SUPPORTED)
d2002 1
a2002 1
      /* each pixel depth is handled separately */
d2113 1
a2113 1
            /* start at the beginning */
d2115 1
a2115 1
            /* find out how many bytes each pixel takes up */
d2117 1
a2117 1
            /* loop through the row, only looking at the pixels that
d2122 1
a2122 1
               /* find out where the original pixel is */
d2124 1
a2124 1
               /* move the pixel */
d2127 1
a2127 1
               /* next pixel */
d2133 1
a2133 1
      /* set new row width */
d2156 1
a2156 1
#ifndef PNG_NO_WRITE_FILTER
d2161 1
a2161 1
#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
d2163 1
a2163 1
#endif
d2166 10
a2175 1
   /* find out how many bytes offset each pixel is */
d2181 1
a2181 1
#ifndef PNG_NO_WRITE_FILTER
d2224 1
a2224 1
#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
d2262 1
a2262 1
   /* sub filter */
d2264 1
a2264 1
   /* it's the only filter so no testing is needed */
d2288 1
a2288 1
#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
d2341 1
a2341 1
#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
d2379 1
a2379 1
   /* up filter */
d2402 1
a2402 1
#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
d2444 1
a2444 1
#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
d2482 1
a2482 1
   /* avg filter */
d2507 1
a2507 1
#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
d2556 1
a2556 1
#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
d2640 1
a2640 1
#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
d2721 1
a2721 1
#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
d2757 1
a2757 1
#endif /* PNG_NO_WRITE_FILTER */
d2762 2
a2763 2
#ifndef PNG_NO_WRITE_FILTER
#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
d2775 1
a2775 1
#endif /* PNG_NO_WRITE_FILTER */
d2784 1
d2786 1
a2786 1
   /* set up the zlib input buffer */
d2790 1
a2790 1
   /* repeat until we have compressed all the data */
d2793 1
a2793 1
      int ret; /* return of zlib */
d2795 1
a2795 1
      /* compress the data */
d2797 1
a2797 1
      /* check for compression errors */
d2806 1
a2806 1
      /* see if it is time to write another IDAT */
d2809 1
a2809 1
         /* write the IDAT and reset the zlib output buffer */
d2814 1
a2814 1
   /* repeat until all data has been compressed */
d2817 1
a2817 1
   /* swap the current and previous rows */
d2827 1
a2827 1
   /* finish row - updates counters and flushes zlib if last row */
d2830 1
a2830 1
#if defined(PNG_WRITE_FLUSH_SUPPORTED)
@


1.8
log
@merge libpng upgrade

major version bump because function signature of png_decompress_chunk
changed (return value to void)
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.30 [August 15, 2008]
d99 1
a99 1
   png_debug2(0, "Writing %s chunk, length = %lu\n", chunk_name,
d395 1
a395 1
   png_debug(1, "in png_write_IHDR\n");
d572 1
a572 1
   png_debug(1, "in png_write_PLTE\n");
d598 1
a598 1
   png_debug1(3, "num_palette = %d\n", png_ptr->num_palette);
d632 1
a632 1
   png_debug(1, "in png_write_IDAT\n");
d684 1
a684 1
   png_debug(1, "in png_write_IEND\n");
d702 1
a702 1
   png_debug(1, "in png_write_gAMA\n");
d718 1
a718 1
   png_debug(1, "in png_write_gAMA\n");
d736 1
a736 1
   png_debug(1, "in png_write_sRGB\n");
d759 1
a759 1
   png_debug(1, "in png_write_iCCP\n");
d767 1
a767 1
   if (name == NULL || (name_len = png_check_keyword(png_ptr, name,
a768 2
   {
      png_warning(png_ptr, "Empty keyword in iCCP chunk");
a769 1
   }
d835 2
a836 2
   png_debug(1, "in png_write_sPLT\n");
   if (spalette->name == NULL || (name_len = png_check_keyword(png_ptr,
d838 1
a838 4
   {
      png_warning(png_ptr, "Empty keyword in sPLT chunk");
      return;
   }
d909 1
a909 1
   png_debug(1, "in png_write_sBIT\n");
a965 1
   png_uint_32 itemp;
d967 18
a984 4
   png_debug(1, "in png_write_cHRM\n");
   /* each value is saved in 1/100,000ths */
   if (white_x < 0 || white_x > 0.8 || white_y < 0 || white_y > 0.8 ||
       white_x + white_y > 1.0)
d986 7
a992 10
      png_warning(png_ptr, "Invalid cHRM white point specified");
#if !defined(PNG_NO_CONSOLE_IO)
      fprintf(stderr, "white_x=%f, white_y=%f\n", white_x, white_y);
#endif
      return;
   }
   itemp = (png_uint_32)(white_x * 100000.0 + 0.5);
   png_save_uint_32(buf, itemp);
   itemp = (png_uint_32)(white_y * 100000.0 + 0.5);
   png_save_uint_32(buf + 4, itemp);
d994 2
a995 9
   if (red_x < 0 ||  red_y < 0 || red_x + red_y > 1.0)
   {
      png_warning(png_ptr, "Invalid cHRM red point specified");
      return;
   }
   itemp = (png_uint_32)(red_x * 100000.0 + 0.5);
   png_save_uint_32(buf + 8, itemp);
   itemp = (png_uint_32)(red_y * 100000.0 + 0.5);
   png_save_uint_32(buf + 12, itemp);
d997 2
a998 9
   if (green_x < 0 || green_y < 0 || green_x + green_y > 1.0)
   {
      png_warning(png_ptr, "Invalid cHRM green point specified");
      return;
   }
   itemp = (png_uint_32)(green_x * 100000.0 + 0.5);
   png_save_uint_32(buf + 16, itemp);
   itemp = (png_uint_32)(green_y * 100000.0 + 0.5);
   png_save_uint_32(buf + 20, itemp);
d1000 1
a1000 4
   if (blue_x < 0 || blue_y < 0 || blue_x + blue_y > 1.0)
   {
      png_warning(png_ptr, "Invalid cHRM blue point specified");
      return;
a1001 6
   itemp = (png_uint_32)(blue_x * 100000.0 + 0.5);
   png_save_uint_32(buf + 24, itemp);
   itemp = (png_uint_32)(blue_y * 100000.0 + 0.5);
   png_save_uint_32(buf + 28, itemp);

   png_write_chunk(png_ptr, (png_bytep)png_cHRM, buf, (png_size_t)32);
d1016 1
a1016 1
   png_debug(1, "in png_write_cHRM\n");
d1018 4
a1021 1
   if (white_x > 80000L || white_y > 80000L || white_x + white_y > 100000L)
a1022 7
      png_warning(png_ptr, "Invalid fixed cHRM white point specified");
#if !defined(PNG_NO_CONSOLE_IO)
      fprintf(stderr, "white_x=%ld, white_y=%ld\n", (unsigned long)white_x,
        (unsigned long)white_y);
#endif
      return;
   }
a1025 5
   if (red_x + red_y > 100000L)
   {
      png_warning(png_ptr, "Invalid cHRM fixed red point specified");
      return;
   }
a1028 5
   if (green_x + green_y > 100000L)
   {
      png_warning(png_ptr, "Invalid fixed cHRM green point specified");
      return;
   }
a1031 5
   if (blue_x + blue_y > 100000L)
   {
      png_warning(png_ptr, "Invalid fixed cHRM blue point specified");
      return;
   }
d1036 1
d1052 1
a1052 1
   png_debug(1, "in png_write_tRNS\n");
d1107 1
a1107 1
   png_debug(1, "in png_write_bKGD\n");
d1115 1
a1115 1
         back->index > png_ptr->num_palette)
d1161 1
a1161 1
   png_debug(1, "in png_write_hIST\n");
d1164 1
a1164 1
      png_debug2(3, "num_hist = %d, num_palette = %d\n", num_hist,
d1201 1
a1201 1
   png_debug(1, "in png_check_keyword\n");
d1210 1
a1210 1
   png_debug1(2, "Keyword to be checked is '%s'\n", key);
d1269 1
a1269 1
   png_debug1(2, "Checking for multiple internal spaces in '%s'\n", kp);
d1304 1
a1304 1
      new_key[79] = '\0';
d1324 2
a1325 4
   png_debug(1, "in png_write_tEXt\n");
   if (key == NULL || (key_len = png_check_keyword(png_ptr, key, &new_key))==0)
   {
      png_warning(png_ptr, "Empty keyword in tEXt chunk");
a1326 1
   }
d1366 1
a1366 1
   png_debug(1, "in png_write_zTXt\n");
d1374 1
a1374 1
   if (key == NULL || (key_len = png_check_keyword(png_ptr, key, &new_key))==0)
a1375 1
      png_warning(png_ptr, "Empty keyword in zTXt chunk");
d1422 2
a1423 1
   png_charp new_lang, new_key;
d1427 1
a1427 1
   png_debug(1, "in png_write_iTXt\n");
d1434 1
a1434 3
   if (key == NULL || (key_len = png_check_keyword(png_ptr, key, &new_key))==0)
   {
      png_warning(png_ptr, "Empty keyword in iTXt chunk");
d1436 2
a1437 2
   }
   if (lang == NULL || (lang_len = png_check_keyword(png_ptr, lang, &new_lang))==0)
d1513 1
a1513 1
   png_debug(1, "in png_write_oFFs\n");
d1539 1
a1539 1
   png_debug1(1, "in png_write_pCAL (%d parameters)\n", nparams);
d1544 1
a1544 1
   png_debug1(3, "pCAL purpose length = %d\n", (int)purpose_len);
d1546 1
a1546 1
   png_debug1(3, "pCAL units length = %d\n", (int)units_len);
d1557 1
a1557 1
      png_debug2(3, "pCAL parameter %d length = %lu\n", i,
d1562 1
a1562 1
   png_debug1(3, "pCAL total length = %d\n", (int)total_len);
d1598 1
a1598 1
   png_debug(1, "in png_write_sCAL\n");
d1623 1
a1623 1
   png_debug1(3, "sCAL total length = %u\n", (unsigned int)total_len);
d1638 1
a1638 1
   png_debug(1, "in png_write_sCAL_s\n");
d1653 1
a1653 1
   png_debug1(3, "sCAL total length = %u\n", (unsigned int)total_len);
d1672 1
a1672 1
   png_debug(1, "in png_write_pHYs\n");
d1696 1
a1696 1
   png_debug(1, "in png_write_tIME\n");
d1740 1
a1740 1
   png_debug(1, "in png_write_start_row\n");
d1840 1
a1840 1
   png_debug(1, "in png_write_finish_row\n");
d1949 1
a1949 1
   png_debug(1, "in png_do_write_interlace\n");
d2120 1
a2120 1
   png_debug(1, "in png_write_find_filter\n");
d2729 2
a2730 2
   png_debug(1, "in png_write_filtered_row\n");
   png_debug1(2, "filter = %d\n", filtered_row[0]);
@


1.7
log
@fastmerge
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.26 [April 2, 2008]
d52 18
d83 1
a83 1
   if(png_ptr == NULL) return;
d85 1
a85 1
   png_write_chunk_data(png_ptr, data, length);
d97 5
a101 3
   png_byte buf[4];
   png_debug2(0, "Writing %s chunk (%lu bytes)\n", chunk_name, length);
   if(png_ptr == NULL) return;
d103 1
a103 1
   /* write the length */
d105 4
a108 4
   png_write_data(png_ptr, buf, (png_size_t)4);

   /* write the chunk name */
   png_write_data(png_ptr, chunk_name, (png_size_t)4);
d123 1
a123 1
   if(png_ptr == NULL) return;
d126 4
a130 1
      png_write_data(png_ptr, data, length);
d140 1
a140 1
   if(png_ptr == NULL) return;
d142 1
a142 1
   /* write the crc */
a147 17
/* Simple function to write the signature.  If we have already written
 * the magic bytes of the signature, or more likely, the PNG stream is
 * being embedded into another stream and doesn't need its own signature,
 * we should call png_set_sig_bytes() to tell libpng how many of the
 * bytes have already been written.
 */
void /* PRIVATE */
png_write_sig(png_structp png_ptr)
{
   png_byte png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};
   /* write the rest of the 8 byte signature */
   png_write_data(png_ptr, &png_signature[png_ptr->sig_bytes],
      (png_size_t)8 - png_ptr->sig_bytes);
   if(png_ptr->sig_bytes < 3)
      png_ptr->mode |= PNG_HAVE_PNG_SIGNATURE;
}

d248 2
a249 2
                  (png_uint_32)(comp->max_output_ptr *
                  png_sizeof (png_charpp)));
d251 1
a251 1
                  * png_sizeof (png_charp));
d256 2
a257 2
                  (png_uint_32)(comp->max_output_ptr *
                  png_sizeof (png_charp)));
d261 2
a262 1
         comp->output_ptr[comp->num_output_ptr] = (png_charp)png_malloc(png_ptr,
d301 1
a301 1
                     png_sizeof (png_charpp)));
d303 1
a303 1
                     old_max * png_sizeof (png_charp));
d309 1
a309 1
                     png_sizeof (png_charp)));
d314 2
a315 1
               (png_charp)png_malloc(png_ptr, (png_uint_32)png_ptr->zbuf_size);
d360 2
a361 2
      png_write_chunk_data(png_ptr,(png_bytep)comp->output_ptr[i],
         png_ptr->zbuf_size);
d363 1
a363 1
      comp->output_ptr[i]=NULL;
d367 1
a367 1
      comp->output_ptr=NULL;
d371 1
a371 1
         png_ptr->zbuf_size - png_ptr->zstream.avail_out);
d407 1
a407 1
            default: png_error(png_ptr,"Invalid bit depth for grayscale image");
d507 1
a507 1
   png_write_chunk(png_ptr, png_IHDR, buf, (png_size_t)13);
d600 2
a601 1
   png_write_chunk_start(png_ptr, png_PLTE, num_pal * 3);
d673 1
a673 1
   png_write_chunk(png_ptr, png_IDAT, data, length);
d685 1
a685 1
   png_write_chunk(png_ptr, png_IEND, png_bytep_NULL,
d706 1
a706 1
   png_write_chunk(png_ptr, png_gAMA, buf, (png_size_t)4);
d721 1
a721 1
   png_write_chunk(png_ptr, png_gAMA, buf, (png_size_t)4);
d737 1
a737 1
   if(srgb_intent >= PNG_sRGB_INTENT_LAST)
d741 1
a741 1
   png_write_chunk(png_ptr, png_sRGB, buf, (png_size_t)1);
d782 4
a785 4
          ((*( (png_bytep)profile  ))<<24) |
          ((*( (png_bytep)profile+1))<<16) |
          ((*( (png_bytep)profile+2))<< 8) |
          ((*( (png_bytep)profile+3))    );
d788 5
a792 5
     {
        png_warning(png_ptr,
          "Embedded profile length too large in iCCP chunk");
        return;
     }
d795 5
a799 5
     {
        png_warning(png_ptr,
          "Truncating profile to actual length in iCCP chunk");
        profile_len = embedded_profile_len;
     }
d802 2
a803 2
       profile_len = png_text_compress(png_ptr, profile, (png_size_t)profile_len,
          PNG_COMPRESSION_TYPE_BASE, &comp);
d806 5
a810 4
   png_write_chunk_start(png_ptr, png_iCCP,
          (png_uint_32)name_len+profile_len+2);
   new_name[name_len+1]=0x00;
   png_write_chunk_data(png_ptr, (png_bytep)new_name, name_len + 2);
d847 5
a851 4
   png_write_chunk_start(png_ptr, png_sPLT,
          (png_uint_32)(name_len + 2 + palette_size));
   png_write_chunk_data(png_ptr, (png_bytep)new_name, name_len + 1);
   png_write_chunk_data(png_ptr, (png_bytep)&spalette->depth, 1);
d855 1
a855 1
   for (ep = spalette->entries; ep<spalette->entries+spalette->nentries; ep++)
d857 17
a873 17
       if (spalette->depth == 8)
       {
           entrybuf[0] = (png_byte)ep->red;
           entrybuf[1] = (png_byte)ep->green;
           entrybuf[2] = (png_byte)ep->blue;
           entrybuf[3] = (png_byte)ep->alpha;
           png_save_uint_16(entrybuf + 4, ep->frequency);
       }
       else
       {
           png_save_uint_16(entrybuf + 0, ep->red);
           png_save_uint_16(entrybuf + 2, ep->green);
           png_save_uint_16(entrybuf + 4, ep->blue);
           png_save_uint_16(entrybuf + 6, ep->alpha);
           png_save_uint_16(entrybuf + 8, ep->frequency);
       }
       png_write_chunk_data(png_ptr, entrybuf, (png_size_t)entry_size);
d879 17
a895 17
       if (spalette->depth == 8)
       {
           entrybuf[0] = (png_byte)ep[i].red;
           entrybuf[1] = (png_byte)ep[i].green;
           entrybuf[2] = (png_byte)ep[i].blue;
           entrybuf[3] = (png_byte)ep[i].alpha;
           png_save_uint_16(entrybuf + 4, ep[i].frequency);
       }
       else
       {
           png_save_uint_16(entrybuf + 0, ep[i].red);
           png_save_uint_16(entrybuf + 2, ep[i].green);
           png_save_uint_16(entrybuf + 4, ep[i].blue);
           png_save_uint_16(entrybuf + 6, ep[i].alpha);
           png_save_uint_16(entrybuf + 8, ep[i].frequency);
       }
       png_write_chunk_data(png_ptr, entrybuf, entry_size);
d956 1
a956 1
   png_write_chunk(png_ptr, png_sBIT, buf, size);
d981 1
a981 1
      fprintf(stderr,"white_x=%f, white_y=%f\n",white_x, white_y);
d1020 1
a1020 1
   png_write_chunk(png_ptr, png_cHRM, buf, (png_size_t)32);
d1041 2
a1042 2
      fprintf(stderr, "white_x=%ld, white_y=%ld\n",
	  (long)white_x, (long)white_y);
d1073 1
a1073 1
   png_write_chunk(png_ptr, png_cHRM, buf, (png_size_t)32);
d1094 1
a1094 1
         png_warning(png_ptr,"Invalid number of transparent colors specified");
d1098 2
a1099 1
      png_write_chunk(png_ptr, png_tRNS, trans, (png_size_t)num_trans);
d1104 1
a1104 1
      if(tran->gray >= (1 << png_ptr->bit_depth))
d1111 1
a1111 1
      png_write_chunk(png_ptr, png_tRNS, buf, (png_size_t)2);
d1119 7
a1125 7
      if(png_ptr->bit_depth == 8 && (buf[0] | buf[2] | buf[4]))
         {
            png_warning(png_ptr,
              "Ignoring attempt to write 16-bit tRNS chunk when bit_depth is 8");
            return;
         }
      png_write_chunk(png_ptr, png_tRNS, buf, (png_size_t)6);
d1158 1
a1158 1
      png_write_chunk(png_ptr, png_bKGD, buf, (png_size_t)1);
d1165 7
a1171 7
      if(png_ptr->bit_depth == 8 && (buf[0] | buf[2] | buf[4]))
         {
            png_warning(png_ptr,
              "Ignoring attempt to write 16-bit bKGD chunk when bit_depth is 8");
            return;
         }
      png_write_chunk(png_ptr, png_bKGD, buf, (png_size_t)6);
d1175 1
a1175 1
      if(back->gray >= (1 << png_ptr->bit_depth))
d1182 1
a1182 1
      png_write_chunk(png_ptr, png_bKGD, buf, (png_size_t)2);
d1207 2
a1208 1
   png_write_chunk_start(png_ptr, png_hIST, (png_uint_32)(num_hist * 2));
d1328 1
a1328 1
   if(kwarn)
d1334 1
a1334 1
      *new_key=NULL;
d1374 2
a1375 1
   png_write_chunk_start(png_ptr, png_tEXt, (png_uint_32)key_len+text_len+1);
d1382 2
a1383 1
   png_write_chunk_data(png_ptr, (png_bytep)new_key, key_len + 1);
d1385 1
a1385 1
      png_write_chunk_data(png_ptr, (png_bytep)text, text_len);
d1417 1
d1435 2
a1436 2
   png_write_chunk_start(png_ptr, png_zTXt, (png_uint_32)
      (key_len+text_len+2));
d1438 2
a1439 1
   png_write_chunk_data(png_ptr, (png_bytep)new_key, key_len + 1);
d1504 1
a1504 1
   png_write_chunk_start(png_ptr, png_iTXt,
d1518 2
a1519 1
   png_write_chunk_data(png_ptr, (png_bytep)new_key, key_len + 1);
d1529 1
a1529 1
   png_write_chunk_data(png_ptr, cbuf, 2);
d1532 4
a1535 2
   png_write_chunk_data(png_ptr, (new_lang ? (png_bytep)new_lang : cbuf), lang_len + 1);
   png_write_chunk_data(png_ptr, (lang_key ? (png_bytep)lang_key : cbuf), lang_key_len + 1);
d1540 1
a1540 2
   if (new_lang)
     png_free(png_ptr, new_lang);
d1563 1
a1563 1
   png_write_chunk(png_ptr, png_oFFs, buf, (png_size_t)9);
d1591 2
a1592 2
   params_len = (png_uint_32p)png_malloc(png_ptr, (png_uint_32)(nparams
      *png_sizeof(png_uint_32)));
d1599 2
a1600 1
      png_debug2(3, "pCAL parameter %d length = %lu\n", i, params_len[i]);
d1605 3
a1607 2
   png_write_chunk_start(png_ptr, png_pCAL, (png_uint_32)total_len);
   png_write_chunk_data(png_ptr, (png_bytep)new_purpose, purpose_len);
d1666 1
a1666 1
   png_write_chunk(png_ptr, png_sCAL, (png_bytep)buf, total_len);
d1696 1
a1696 1
   png_write_chunk(png_ptr, png_sCAL, buf, total_len);
d1722 1
a1722 1
   png_write_chunk(png_ptr, png_pHYs, buf, (png_size_t)9);
d1754 1
a1754 1
   png_write_chunk(png_ptr, png_tIME, buf, (png_size_t)7);
d1784 1
a1784 1
      png_ptr->usr_channels*png_ptr->usr_bit_depth,png_ptr->width)+1);
d1787 2
a1788 1
   png_ptr->row_buf = (png_bytep)png_malloc(png_ptr, (png_uint_32)buf_size);
d1791 1
a1791 1
#ifndef PNG_NO_WRITE_FILTERING
d1796 1
a1796 1
         (png_ptr->rowbytes + 1));
d1804 2
a1805 1
      png_ptr->prev_row = (png_bytep)png_malloc(png_ptr, (png_uint_32)buf_size);
d1811 1
a1811 1
            (png_ptr->rowbytes + 1));
d1818 1
a1818 1
            (png_ptr->rowbytes + 1));
d1825 1
a1825 1
            (png_ptr->rowbytes + 1));
a1827 1
#endif /* PNG_NO_WRITE_FILTERING */
d1829 1
d1927 1
a1927 1
               png_ptr->usr_bit_depth,png_ptr->width))+1);
@


1.6
log
@merge and fix for __CRAZY=Yes
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.20 Septhember 3, 2007
d6 1
a6 1
 * Copyright (c) 1998-2007 Glenn Randers-Pehrson
d383 2
d528 13
a540 4
   if (deflateInit2(&png_ptr->zstream, png_ptr->zlib_level,
      png_ptr->zlib_method, png_ptr->zlib_window_bits,
      png_ptr->zlib_mem_level, png_ptr->zlib_strategy) != Z_OK)
       png_error(png_ptr, "zlib failed to initialize compressor");
@


1.5
log
@merge and validate
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.15 January 5, 2007
d185 1
a185 1
      sprintf(msg, "Unknown compression type %d", compression);
d497 1
a497 1
   png_write_chunk(png_ptr, (png_bytep)png_IHDR, buf, (png_size_t)13);
d581 1
a581 1
   png_write_chunk_start(png_ptr, (png_bytep)png_PLTE, num_pal * 3);
d653 1
a653 1
   png_write_chunk(png_ptr, (png_bytep)png_IDAT, data, length);
d665 1
a665 1
   png_write_chunk(png_ptr, (png_bytep)png_IEND, png_bytep_NULL,
d686 1
a686 1
   png_write_chunk(png_ptr, (png_bytep)png_gAMA, buf, (png_size_t)4);
d701 1
a701 1
   png_write_chunk(png_ptr, (png_bytep)png_gAMA, buf, (png_size_t)4);
d721 1
a721 1
   png_write_chunk(png_ptr, (png_bytep)png_sRGB, buf, (png_size_t)1);
d786 1
a786 1
   png_write_chunk_start(png_ptr, (png_bytep)png_iCCP,
d826 1
a826 1
   png_write_chunk_start(png_ptr, (png_bytep)png_sPLT,
d934 1
a934 1
   png_write_chunk(png_ptr, (png_bytep)png_sBIT, buf, size);
d998 1
a998 1
   png_write_chunk(png_ptr, (png_bytep)png_cHRM, buf, (png_size_t)32);
d1051 1
a1051 1
   png_write_chunk(png_ptr, (png_bytep)png_cHRM, buf, (png_size_t)32);
d1076 1
a1076 1
      png_write_chunk(png_ptr, (png_bytep)png_tRNS, trans, (png_size_t)num_trans);
d1088 1
a1088 1
      png_write_chunk(png_ptr, (png_bytep)png_tRNS, buf, (png_size_t)2);
d1102 1
a1102 1
      png_write_chunk(png_ptr, (png_bytep)png_tRNS, buf, (png_size_t)6);
d1135 1
a1135 1
      png_write_chunk(png_ptr, (png_bytep)png_bKGD, buf, (png_size_t)1);
d1148 1
a1148 1
      png_write_chunk(png_ptr, (png_bytep)png_bKGD, buf, (png_size_t)6);
d1159 1
a1159 1
      png_write_chunk(png_ptr, (png_bytep)png_bKGD, buf, (png_size_t)2);
d1184 1
a1184 1
   png_write_chunk_start(png_ptr, (png_bytep)png_hIST, (png_uint_32)(num_hist * 2));
d1235 2
a1236 1
      if (*kp < 0x20 || (*kp > 0x7E && (png_byte)*kp < 0xA1))
d1241 2
a1242 1
         sprintf(msg, "invalid keyword character 0x%02X", *kp);
d1350 1
a1350 1
   png_write_chunk_start(png_ptr, (png_bytep)png_tEXt, (png_uint_32)key_len+text_len+1);
a1402 2
   png_free(png_ptr, new_key);

d1408 1
a1408 1
   png_write_chunk_start(png_ptr, (png_bytep)png_zTXt, (png_uint_32)
d1411 3
a1413 1
   png_write_chunk_data(png_ptr, (png_bytep)key, key_len + 1);
d1476 1
a1476 1
   png_write_chunk_start(png_ptr, (png_bytep)png_iTXt,
d1533 1
a1533 1
   png_write_chunk(png_ptr, (png_bytep)png_oFFs, buf, (png_size_t)9);
a1535 1

d1574 1
a1574 1
   png_write_chunk_start(png_ptr, (png_bytep)png_pCAL, (png_uint_32)total_len);
d1627 1
a1627 1
   sprintf(buf + 1, "%12.12e", width);
d1629 1
a1629 1
   sprintf(buf + total_len, "%12.12e", height);
d1634 1
a1634 1
   png_write_chunk(png_ptr, (png_bytep)png_sCAL, (png_bytep)buf, total_len);
d1664 1
a1664 1
   png_write_chunk(png_ptr, (png_bytep)png_sCAL, buf, total_len);
d1690 1
a1690 1
   png_write_chunk(png_ptr, (png_bytep)png_pHYs, buf, (png_size_t)9);
d1722 1
a1722 1
   png_write_chunk(png_ptr, (png_bytep)png_tIME, buf, (png_size_t)7);
d1730 1
d1746 1
d1758 1
d1776 1
a1776 1
         png_ptr->up_row = (png_bytep )png_malloc(png_ptr,
d1790 1
a1790 1
         png_ptr->paeth_row = (png_bytep )png_malloc(png_ptr,
d1794 1
d1828 1
d1844 1
d2118 3
a2120 1
   png_bytep prev_row, best_row, row_buf;
d2133 4
a2136 1
   best_row = row_buf = png_ptr->row_buf;
d2711 1
a2711 1

d2716 1
d2729 1
@


1.4
log
@merge libpng-1.2.12
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.11 June 4, 2006
d6 1
a6 1
 * Copyright (c) 1998-2006 Glenn Randers-Pehrson
d65 1
d81 1
d103 1
d117 2
d526 1
a526 1
   deflateInit2(&png_ptr->zstream, png_ptr->zlib_level,
d528 2
a529 1
      png_ptr->zlib_mem_level, png_ptr->zlib_strategy);
d737 1
d760 21
@


1.3
log
@sync, fix CPPFLAGS
no shlib vsn change (only change local data->rodata, no external syms)
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.9 April 14, 2006
d1571 1
a1571 1
png_write_sCAL(png_structp png_ptr, int unit, double width,double height)
d1576 1
a1577 2
   char wbuf[32], hbuf[32];
   png_byte bunit = (png_byte)unit;
d1581 1
d1586 1
d1588 3
a1590 1
      WideCharToMultiByte(CP_ACP, 0, wc_buf, -1, wbuf, 32, NULL, NULL);
d1592 4
a1595 1
      WideCharToMultiByte(CP_ACP, 0, wc_buf, -1, hbuf, 32, NULL, NULL);
d1598 4
a1601 2
   sprintf(wbuf, "%12.12e", width);
   sprintf(hbuf, "%12.12e", height);
a1602 1
   total_len = 1 + png_strlen(wbuf)+1 + png_strlen(hbuf);
d1604 2
a1605 7
   png_debug1(3, "sCAL total length = %d\n", (int)total_len);
   png_write_chunk_start(png_ptr, (png_bytep)png_sCAL, (png_uint_32)total_len);
   png_write_chunk_data(png_ptr, (png_bytep)&bunit, 1);
   png_write_chunk_data(png_ptr, (png_bytep)wbuf, png_strlen(wbuf)+1);
   png_write_chunk_data(png_ptr, (png_bytep)hbuf, png_strlen(hbuf));

   png_write_chunk_end(png_ptr);
d1616 2
a1617 3
   png_size_t total_len;
   char wbuf[32], hbuf[32];
   png_byte bunit = unit;
d1621 12
a1632 9
   png_strcpy(wbuf,(const char *)width);
   png_strcpy(hbuf,(const char *)height);
   total_len = 1 + png_strlen(wbuf)+1 + png_strlen(hbuf);

   png_debug1(3, "sCAL total length = %d\n", total_len);
   png_write_chunk_start(png_ptr, (png_bytep)png_sCAL, (png_uint_32)total_len);
   png_write_chunk_data(png_ptr, (png_bytep)&bunit, 1);
   png_write_chunk_data(png_ptr, (png_bytep)wbuf, png_strlen(wbuf)+1);
   png_write_chunk_data(png_ptr, (png_bytep)hbuf, png_strlen(hbuf));
d1634 2
a1635 1
   png_write_chunk_end(png_ptr);
@


1.2
log
@merge src/lib
@
text
@d4 1
a4 1
 * libpng version 1.2.8 - December 3, 2004
d6 1
a6 1
 * Copyright (c) 1998-2004 Glenn Randers-Pehrson
d19 1
a19 1
void /* PRIVATE */
a27 1
#if defined(PNG_WRITE_pCAL_SUPPORTED) || defined(PNG_WRITE_oFFs_SUPPORTED)
d32 1
a32 1
void /* PRIVATE */
a39 1
#endif
d45 1
a45 1
void /* PRIVATE */
d162 2
a163 1
   comp->num_output_ptr = comp->max_output_ptr = 0;
d166 1
d733 7
d940 1
a940 2
   if (red_x < 0 || red_x > 0.8 || red_y < 0 || red_y > 0.8 ||
       red_x + red_y > 1.0)
d950 1
a950 2
   if (green_x < 0 || green_x > 0.8 || green_y < 0 || green_y > 0.8 ||
       green_x + green_y > 1.0)
d960 1
a960 2
   if (blue_x < 0 || blue_x > 0.8 || blue_y < 0 || blue_y > 0.8 ||
       blue_x + blue_y > 1.0)
d999 1
a999 1
   if (red_x > 80000L || red_y > 80000L || red_x + red_y > 100000L)
d1007 1
a1007 1
   if (green_x > 80000L || green_y > 80000L || green_x + green_y > 100000L)
d1015 1
a1015 1
   if (blue_x > 80000L || blue_y > 80000L || blue_x + blue_y > 100000L)
d1352 6
d1411 5
d1578 1
a1578 1
   png_byte bunit = unit;
@


1.1
log
@Initial revision
@
text
@d987 2
a988 1
      fprintf(stderr,"white_x=%ld, white_y=%ld\n",white_x, white_y);
@


1.1.107.1
log
@libpng-1_2_8 with the following directories removed:
- contrib
- projects
- scripts
@
text
@@


1.1.107.2
log
@there's a newer libpng out there
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.9 April 14, 2006
d6 1
a6 1
 * Copyright (c) 1998-2006 Glenn Randers-Pehrson
d19 1
a19 1
void PNGAPI
d28 1
d33 1
a33 1
void PNGAPI
d41 1
d47 1
a47 1
void PNGAPI
d164 1
a164 2
   comp->num_output_ptr = 0;
   comp->max_output_ptr = 0;
a166 1
   comp->input_len = 0;
a732 7

   comp.num_output_ptr = 0;
   comp.max_output_ptr = 0;
   comp.output_ptr = NULL;
   comp.input = NULL;
   comp.input_len = 0;

d933 2
a934 1
   if (red_x < 0 ||  red_y < 0 || red_x + red_y > 1.0)
d944 2
a945 1
   if (green_x < 0 || green_y < 0 || green_x + green_y > 1.0)
d955 2
a956 1
   if (blue_x < 0 || blue_y < 0 || blue_x + blue_y > 1.0)
d994 1
a994 1
   if (red_x + red_y > 100000L)
d1002 1
a1002 1
   if (green_x + green_y > 100000L)
d1010 1
a1010 1
   if (blue_x + blue_y > 100000L)
a1346 6
   comp.num_output_ptr = 0;
   comp.max_output_ptr = 0;
   comp.output_ptr = NULL;
   comp.input = NULL;
   comp.input_len = 0;

a1399 5
   comp.num_output_ptr = 0;
   comp.max_output_ptr = 0;
   comp.output_ptr = NULL;
   comp.input = NULL;

d1562 1
a1562 1
   png_byte bunit = (png_byte)unit;
@


1.1.107.3
log
@Import libpng 1.2.12, fixes at least three vulnerabilities
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.11 June 4, 2006
d1570 1
a1570 1
png_write_sCAL(png_structp png_ptr, int unit, double width, double height)
a1574 1
   char buf[64];
d1576 2
a1580 1
   buf[0] = (char)unit;
a1584 1
      size_t wc_len;
d1586 1
a1586 3
      wc_len = wcslen(wc_buf);
      WideCharToMultiByte(CP_ACP, 0, wc_buf, -1, buf + 1, wc_len, NULL, NULL);
      total_len = wc_len + 2;
d1588 1
a1588 4
      wc_len = wcslen(wc_buf);
      WideCharToMultiByte(CP_ACP, 0, wc_buf, -1, buf + total_len, wc_len,
         NULL, NULL);
      total_len += wc_len;
d1591 2
a1592 4
   sprintf(buf + 1, "%12.12e", width);
   total_len = 1 + png_strlen(buf + 1) + 1;
   sprintf(buf + total_len, "%12.12e", height);
   total_len += png_strlen(buf + total_len);
d1594 1
d1596 7
a1602 2
   png_debug1(3, "sCAL total length = %u\n", (unsigned int)total_len);
   png_write_chunk(png_ptr, (png_bytep)png_sCAL, (png_bytep)buf, total_len);
d1613 3
a1615 2
   png_byte buf[64];
   png_size_t wlen, hlen, total_len;
d1619 9
a1627 12
   wlen = png_strlen(width);
   hlen = png_strlen(height);
   total_len = wlen + hlen + 2;
   if (total_len > 64)
   {
      png_warning(png_ptr, "Can't write sCAL (buffer too small)");
      return;
   }

   buf[0] = (png_byte)unit;
   png_memcpy(buf + 1, width, wlen + 1);      /* append the '\0' here */
   png_memcpy(buf + wlen + 2, height, hlen);  /* do NOT append the '\0' here */
d1629 1
a1629 2
   png_debug1(3, "sCAL total length = %u\n", (unsigned int)total_len);
   png_write_chunk(png_ptr, (png_bytep)png_sCAL, buf, total_len);
@


1.1.107.4
log
@Upgrade libpng (fixes some holes)
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.15 January 5, 2007
d6 1
a6 1
 * Copyright (c) 1998-2007 Glenn Randers-Pehrson
a64 1
   if(png_ptr == NULL) return;
a79 1
   if(png_ptr == NULL) return;
a100 1
   if(png_ptr == NULL) return;
a113 2
   if(png_ptr == NULL) return;

d521 1
a521 1
   if (deflateInit2(&png_ptr->zstream, png_ptr->zlib_level,
d523 1
a523 2
      png_ptr->zlib_mem_level, png_ptr->zlib_strategy) != Z_OK)
       png_error(png_ptr, "zlib failed to initialize compressor");
a730 1
   int embedded_profile_len = 0;
a752 21
   if (profile_len > 3)
      embedded_profile_len =
          ((*( (png_bytep)profile  ))<<24) |
          ((*( (png_bytep)profile+1))<<16) |
          ((*( (png_bytep)profile+2))<< 8) |
          ((*( (png_bytep)profile+3))    );

   if (profile_len < embedded_profile_len)
     {
        png_warning(png_ptr,
          "Embedded profile length too large in iCCP chunk");
        return;
     }

   if (profile_len > embedded_profile_len)
     {
        png_warning(png_ptr,
          "Truncating profile to actual length in iCCP chunk");
        profile_len = embedded_profile_len;
     }

@


1.1.107.5
log
@Import libpng-1.2.25 with the following change log.
Requested by bsiegert@@ due to security fix relevance.

version 1.2.19beta1 [May 18, 2007]
  Changed "const static" to "static PNG_CONST" everywhere, mostly undoing
    change of libpng-1.2.17beta2.  Changed other "const" to "PNG_CONST"
  Changed some handling of unused parameters, to avoid compiler warnings.
    "if (unused == NULL) return;" becomes "unused = unused".

version 1.2.19beta2 [May 18, 2007]
  Only use the valid bits of tRNS value in png_do_expand() (Brian Cartier)

version 1.2.19beta3 [May 19, 2007]
  Add some "png_byte" typecasts in png_check_keyword() and write new_key
  instead of key in zTXt chunk (Kevin Ryde).

version 1.2.19beta4 [May 21, 2007]
  Add png_snprintf() function and use it in place of sprint() for improved
    defense against buffer overflows.

version 1.2.19beta5 [May 21, 2007]
  Fixed png_handle_tRNS() to only use the valid bits of tRNS value.
  Changed handling of more unused parameters, to avoid compiler warnings.
  Removed some PNG_CONST in pngwutil.c to avoid compiler warnings.

version 1.2.19beta6 [May 22, 2007]
  Added some #ifdef PNG_MMX_CODE_SUPPORTED where needed in pngvcrd.c
  Added a special "_MSC_VER" case that defines png_snprintf to _snprintf

version 1.2.19beta7 [May 22, 2007]
  Squelched png_squelch_warnings() in pnggccrd.c and added an
    #ifdef PNG_MMX_CODE_SUPPORTED block around the declarations that caused
    the warnings that png_squelch_warnings was squelching.

version 1.2.19beta8 [May 22, 2007]
  Removed __MMX__ from test in pngconf.h.

version 1.2.19beta9 [May 23, 2007]
  Made png_squelch_warnings() available via PNG_SQUELCH_WARNINGS macro.
  Revised png_squelch_warnings() so it might work.
  Updated makefile.sgcc and makefile.solaris; added makefile.solaris-x86.

version 1.2.19beta10 [May 24, 2007]
  Resquelched png_squelch_warnings(), use "__attribute__((used))" instead.

version 1.2.19beta11 [May 28, 2007]
  Return 0 from png_get_sPLT() and png_get_unknown_chunks() if png_ptr is NULL;
    changed three remaining instances of png_strcpy() to png_strncpy() (David
    Hill).
  Make test for NULL row_buf at the beginning of png_do_read_transformations
    unconditional.

version 1.2.19beta12 [May 28, 2007]
  Revised pnggccrd.c.

version 1.2.19beta13 [June 14, 2007]
  Prefer PNG_USE_PNGVCRD when _MSC_VER is defined in pngconf.h

version 1.2.19beta14 [June 16, 2007]
  Fix bug with handling of 16-bit transparency, introduced in 1.2.19beta2

version 1.2.19beta15 [June 17, 2007]
  Revised pnggccrd.c.

version 1.2.19beta16 [June 18, 2007]
  Revised pnggccrd.c again.
  Updated contrib/gregbook.
  Changed '#include "pnggccrd.c"' to 'include "$srcdir/pnggccrd.c"'
    in configure.ac

version 1.2.19beta17 [June 19, 2007]
  Revised many of the makefiles, to set -DPNG_NO_MMX_CODE where needed
    and to not use -O3 unless -DPNG_NO_MMX_CODE is also set.

version 1.2.19beta18 [June 23, 2007]
  Replaced some C++ style comments with C style comments in pnggccrd.c.
  Copied optimized C code from pnggccrd.c to pngrutil.c, removed dependency
    on pnggccrd.o from many makefiles.
  Added sl and dylib to list of extensions be installed by Makefile.am

version 1.2.19beta19 [June 28, 2007]
  Fixed testing PNG_RGB_TO_GRAY_ERR & PNG_RGB_TO_GRAY_WARN in pngrtran.c
  More cleanup of pnggccrd.c and pngvcrd.c

version 1.2.19beta20 [June 29, 2007]
  Rebuilt Makefile.in and configure using libtool-1.5.24.
  Fixed typo in pnggccrd.c

version 1.2.19beta21 [June 30, 2007]
  More revision of pnggccrd.c
  Added "test" target to Makefile.in and Makefile.am

version 1.2.19beta22 [July 3, 2007]
  Added info about pngrutil/pnggccrd/pngvcrd to png_get_header_version()
  Fix type definition of dummy_value_a, b in pnggccrd.c

version 1.2.19beta23 [July 10, 2007]
  Revert change to type definition of dummy_value_a, b in pnggccrd.c
  Make sure __PIC__ is defined in pnggccrd.c when PIC is defined.
  Require gcc-4.1 or better to use PNG_HAVE_MMX_FILTER_ROW on x86_64 platforms

version 1.2.19beta24 [July 14, 2007]
  Added PNG_NO_READ_FILTER, PNG_NO_WRITE_FILTER, PNG_NO_WARNING macros.
  Added contrib/pngminim to demonstrate building minimal encoder and decoder

version 1.2.19beta25 [July 15, 2007]
  Removed the new PNG_NO_READ_FILTER macro since it would make the library
    unable to read valid PNG files, and filtering is at the heart of the
    PNG format.

version 1.2.19beta26 [July 16, 2007]
  Changed "png_free(str)" to "png_free(png_ptr,str)" in pngrutil.c WinCE
    code (Yves Piguet).  This bug was introduced in libpng-1.2.14.
  Updated scripts/CMakeLists.txt
  Relocated a misplaced #endif in pnggccrd.c

version 1.2.19beta27 [July 17, 2007]
  Fixed incorrect stride and number of bytes copied (was 4 instead of
    6 bytes) in the cleanup loop of pnggccrd.c and pngvcrd.c for handling
    the end of 48-bit interlaced rows (Glenn R-P).

version 1.2.19beta28 [July 19, 2007]
  Removed requirement for gcc-4.1 or better to use PNG_HAVE_MMX_FILTER_ROW
    on x86_64 platforms
  Added png_warning() in pngrutil.c for short iCCP, iTXt, sPLT, or zTXT chunks.
  Revised pngtest.c so warnings are displayed regardless of PNG_NO_STDIO.

version 1.2.19beta29 [July 20, 2007]
  Fix typo in pnggccrd.c (%%eax should be %%ax in secondloop48)

version 1.2.19beta30 [July 26, 2007]
  Revised pnggccrd.c

version 1.2.19beta31 [July 27, 2007]
  Fix typos in pnggccrd.c

version 1.0.27rc1 and 1.2.19rc1 [July 31, 2007]
  Disable PNG_MMX_CODE_SUPPORTED when PNG_ASSEMBLER_CODE_SUPPORTED is off.
  Enable PNG_MMX_READ_FILTER_* by default, except when gcc-3.x is being
    used (they were inadvertently disabled in libpng-1.2.19beta23).
  Fix some debugging statements in pnggccrd.c and pngrutil.c
  Added information about disabling the MMX code in libpng documentation.

version 1.0.27rc2 and 1.2.19rc2 [August 4, 2007]
  Removed some "#if 0" blocks.
  Made a global struct local in pngvcrd.c to make it thread safe.
  Issue a png_error() if application attempts to transform a row tht
    has not been initialized.

version 1.0.27rc3 and 1.2.19rc3 [August 9, 2007]
  Slightly revised pngvcrd.c

version 1.0.27rc4 and 1.2.19rc4 [August 9, 2007]
  Revised pnggccrd.c debugging change of rc1, which was broken.
  Revised scripts/CMakeLists.txt
  Change default to PNG_NO_GLOBAL_ARRAYS for MSVC.
  Turn off PNG_FLAG_ROW_INIT flag when setting transforms that expand pixels.

version 1.0.27rc5 and 1.2.19rc5 [August 10, 2007]
  Fix typo (missing '"') in pnggccrd.c
  Revise handling of png_strtod in recent versions of WINCE

version 1.0.27rc6 and 1.2.19rc6 [August 15, 2007]
  Fix typo (missing ',') in contrib/gregbook/readpng2.c
  Undid row initialization error exit added to rc2 and rc4.

version 1.0.27 and 1.2.19 [August 18, 2007]
  Conditionally restored row initialization error exit.

version 1.2.20beta01 [August 19, 2007]
  Fixed problem with compiling pnggccrd.c on Intel-Apple platforms.
  Changed png_malloc() to png_malloc_warn() in png_set_sPLT().
  Added PNG_NO_ERROR_TEXT feature, with demo in contrib/pngminim
  Removed define PNG_WARN_UNINITIALIZED_ROW 1 /* 0: warning; 1: error */
    because it caused some trouble.

version 1.2.20beta02 [August 20, 2007]
  Avoid compiling pnggccrd.c on Intel-Apple platforms.

version 1.2.20beta03 [August 20, 2007]
  Added "/D PNG_NO_MMX_CODE" to the non-mmx builds of projects/visualc6
    and visualc71.

version 1.2.20beta04 [August 21, 2007]
  Revised pngvcrd.c for improved efficiency (Steve Snyder).

version 1.2.20rc1 [August 23, 2007]
  Revised pngconf.h to set PNG_NO_MMX_CODE for gcc-3.x compilers.

version 1.2.20rc2 [August 27, 2007]
  Revised scripts/CMakeLists.txt
  Revised #ifdefs to ensure one and only one of pnggccrd.c, pngvcrd.c,
    or part of pngrutil.c is selected.

version 1.2.20rc3 [August 30, 2007]
  Remove a little more code in pngwutil.c when PNG_NO_WRITE_FILTER is selected.
  Added /D _CRT_SECURE_NO_WARNINGS to visual6c and visualc71 projects.
  Compile png_mmx_support() in png.c even when PNG_NO_MMX_CODE is defined.
  Restored a "superfluous" #ifdef that was removed from 1.2.20rc2 pnggccrd.c,
    breaking the png_mmx_support() function.

version 1.2.20rc4 [September 1, 2007]
  Removed Intel contributions (MMX, Optimized C).

version 1.2.20rc5 [September 2, 2007]
  Restored configure and Makefile.in to rc3 and put a snippet of code in
    pnggccrd.c, to ensure configure makes the same PNG_NO_MMX_CODE selection

version 1.2.20rc6 [September 2, 2007]
  Fixed bugs in scripts/CMakeLists.txt
  Removed pngvcrd.c references from msvc projects.

version 1.0.28 and 1.2.20 [September 8, 2007]
  Removed "(NO READ SUPPORT)" from png_get_header_version() string.

version 1.2.21beta1 [September 14, 2007]
  Fixed various mistakes reported by George Cook and Jeff Phillips:
  logical vs bitwise NOT in pngrtran.c, bug introduced in 1.2.19rc2
  16-bit cheap transparency expansion, bug introduced in 1.2.19beta2
  errors with sizeof(unknown_chunk.name), bugs introduced in 1.2.19beta11
  <= compare with unsigned var in pngset.c, should be ==.

version 1.2.21beta2 [September 18, 2007]
  Removed some extraneous typecasts.

version 1.2.21rc1 [September 25, 2007]
  Fixed potential out-of-bounds reads in png_handle_pCAL() and
    png_handle_ztXt() ("flayer" results reported by Tavis Ormandy).

version 1.2.21rc2 [September 26, 2007]
  Fixed potential out-of-bounds reads in png_handle_sCAL(),
    png_handle_iTXt(), and png_push_read_tEXt().
  Remove some PNG_CONST declarations from pngwutil.c to avoid compiler warnings
  Revised makefiles to update paths in libpng.pc properly.

version 1.2.21rc3 [September 27, 2007]
  Revised makefiles to update "Libs" in libpng.pc properly.

version 1.0.29 and 1.2.21rc3 [October 4, 2007]
  No changes.

version 1.2.22beta1 [October 4, 2007]
  Again, fixed logical vs bitwise NOT in pngrtran.c, bug introduced
    in 1.2.19rc2

version 1.2.22beta2 [October 5, 2007]
  Fixed string length error in pngset.c (caused crashes while decoding iCCP)
  Add terminating NULL after each instance of png_strncpy().

version 1.2.22beta3 [October 6, 2007]
  Fix two off-by-one terminating NULL after png_strncpy().

version 1.2.22beta4 [October 7, 2007]
  Changed some 0 to '\0'.

version 1.0.30rc1 and 1.2.22rc1 [October 8, 2007]
  No changes.

version 1.0.30 and 1.2.22 [October 13, 2007]
  No changes.

version 1.2.23beta01 [October 15, 2007]
  Reduced number of invocations of png_strlen() in pngset.c.
  Changed [azAZ09_] to [_abcde...89] in Makefile.am for better localization.

version 1.2.23beta02 [October 16, 2007]
  Eliminated png_strncpy() and png_strcpy() (Pierre Poissinger)
  Changed $AN to $(AN) in Makefile.am.

version 1.2.23beta03 [October 16, 2007]
  Fixed off-by-one error in pngset.c
  Restore statement to set last character of buffer to \0 in pngerror.c

version 1.2.23beta04 [October 23, 2007]
  Reject attempt to set all-zero cHRM values.

version 1.2.23beta05 [October 26, 2007]
  Add missing quotes in projects/visualc6, lost in version 1.2.20rc3

version 1.2.23rc01 [November 2, 2007]
  No changes.

version 1.2.23 [November 6, 2007]
  No changes.

version 1.2.24beta01 [November 19, 2007]
  Moved misplaced test for malloc failure in png_set_sPLT().  This bug was
    introduced in libpng-1.2.20beta01.
  Ifdef out avg_row etc from png.h and pngwrite.c when PNG_NO_WRITE_FILTER
  Do not use png_ptr->free_fn and png_ptr->mem_fn in png_destroy_read_struct()
    when png_ptr is NULL (Marshall Clow).
  Updated handling of symbol prefixes in Makefile.am and configure.ac (Mike
    Frysinger).

version 1.2.24beta02 [November 30, 2007]
  Removed a useless test and fixed incorrect test in png_set_cHRM_fixed()
    (David Hill).

version 1.2.24rc01 [December 7, 2007]
  No changes.

version 1.2.24     [December 14, 2007]
  Make sure not to redefine _BSD_SOURCE in pngconf.h
  Revised gather.sh and makefile.std in contrib/pngminim to avoid compiling
    unused files.

version 1.2.25beta01 [January 7, 2008]
  Fixed bug with unknown chunk handling, introduced in version 1.2.17rc2

version 1.2.25beta02 [January 10, 2008]
  Prevent gamma from being applied twice.

version 1.2.25rc01 [January 17, 2008]
  No changes.

version 1.2.25beta03 [January 22, 2008]
  Fixed some continue-after-malloc-failure errors in pngset.c (David Hill)
  Check for info_ptr == NULL in png_read_info() and png_process_data().
  Check for possible use of NULL user_png_ver[] in png_create_read_struct().
  Change "if (swidth == NULL)" to "if (sheight == NULL)" in png_handle_sCAL
    (bug introduced in libpng-1.2.4/1.0.13).
  Return from png_destroy_read_struct() if png_ptr_ptr is NULL.
  Fix overflow of "msg" in png_decompres_chunk().

version 1.2.25beta04 [January 26, 2008]
  Work around Coverity bug report by slightly refactoring
    png_read_push_finish_row()

version 1.2.25beta05 [January 31, 2008]
  Added libpng-1.2.25beta05.tar.lzma to distribution.  Get the lzma codec
    from <http://tukaani.org/lzma>.
  Added lp1225b05.7z to distribution.  Get the 7-zip decoder from
    from <http://www.7-zip.org>.
  Fixed some broken links in the README file.

version 1.2.25beta06 [February 6, 2008]
  Refactored png_read_push_finish_row() again, trying to satisfy Coverity.
  Fixed potential NULL dereference of png_ptr in png_destroy_write_struct();
  clarified potential NULL dereference of png_ptr in png_destroy_read_struct();
  fixed potential NULL dereference of info_ptr in png_handle_bKGD();
  fixed potential NULL dereference of user_png_ver[] in
    png_create_write_struct_2(). (Coverity)

version 1.2.25rc02 [February 10, 2008]
  Reset png_ptr->pass in png_read_push_finish_row() before break.
  Changed "pass" from png_byte to int.

version 1.2.25 and 1.0.31 [February 18, 2008]
  No changes.
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.20 Septhember 3, 2007
d185 1
a185 1
      png_snprintf(msg, 50, "Unknown compression type %d", compression);
d497 1
a497 1
   png_write_chunk(png_ptr, png_IHDR, buf, (png_size_t)13);
d581 1
a581 1
   png_write_chunk_start(png_ptr, png_PLTE, num_pal * 3);
d653 1
a653 1
   png_write_chunk(png_ptr, png_IDAT, data, length);
d665 1
a665 1
   png_write_chunk(png_ptr, png_IEND, png_bytep_NULL,
d686 1
a686 1
   png_write_chunk(png_ptr, png_gAMA, buf, (png_size_t)4);
d701 1
a701 1
   png_write_chunk(png_ptr, png_gAMA, buf, (png_size_t)4);
d721 1
a721 1
   png_write_chunk(png_ptr, png_sRGB, buf, (png_size_t)1);
d786 1
a786 1
   png_write_chunk_start(png_ptr, png_iCCP,
d826 1
a826 1
   png_write_chunk_start(png_ptr, png_sPLT,
d934 1
a934 1
   png_write_chunk(png_ptr, png_sBIT, buf, size);
d998 1
a998 1
   png_write_chunk(png_ptr, png_cHRM, buf, (png_size_t)32);
d1050 1
a1050 1
   png_write_chunk(png_ptr, png_cHRM, buf, (png_size_t)32);
d1075 1
a1075 1
      png_write_chunk(png_ptr, png_tRNS, trans, (png_size_t)num_trans);
d1087 1
a1087 1
      png_write_chunk(png_ptr, png_tRNS, buf, (png_size_t)2);
d1101 1
a1101 1
      png_write_chunk(png_ptr, png_tRNS, buf, (png_size_t)6);
d1134 1
a1134 1
      png_write_chunk(png_ptr, png_bKGD, buf, (png_size_t)1);
d1147 1
a1147 1
      png_write_chunk(png_ptr, png_bKGD, buf, (png_size_t)6);
d1158 1
a1158 1
      png_write_chunk(png_ptr, png_bKGD, buf, (png_size_t)2);
d1183 1
a1183 1
   png_write_chunk_start(png_ptr, png_hIST, (png_uint_32)(num_hist * 2));
d1234 1
a1234 2
      if ((png_byte)*kp < 0x20 ||
         ((png_byte)*kp > 0x7E && (png_byte)*kp < 0xA1))
d1239 1
a1239 2
         png_snprintf(msg, 40,
           "invalid keyword character 0x%02X", (png_byte)*kp);
d1347 1
a1347 1
   png_write_chunk_start(png_ptr, png_tEXt, (png_uint_32)key_len+text_len+1);
d1400 2
d1407 1
a1407 1
   png_write_chunk_start(png_ptr, png_zTXt, (png_uint_32)
d1410 1
a1410 3
   png_write_chunk_data(png_ptr, (png_bytep)new_key, key_len + 1);
   png_free(png_ptr, new_key);

d1473 1
a1473 1
   png_write_chunk_start(png_ptr, png_iTXt,
d1530 1
a1530 1
   png_write_chunk(png_ptr, png_oFFs, buf, (png_size_t)9);
d1533 1
d1572 1
a1572 1
   png_write_chunk_start(png_ptr, png_pCAL, (png_uint_32)total_len);
d1625 1
a1625 1
   png_snprintf(buf + 1, 63, "%12.12e", width);
d1627 1
a1627 1
   png_snprintf(buf + total_len, 64-total_len, "%12.12e", height);
d1632 1
a1632 1
   png_write_chunk(png_ptr, png_sCAL, (png_bytep)buf, total_len);
d1662 1
a1662 1
   png_write_chunk(png_ptr, png_sCAL, buf, total_len);
d1688 1
a1688 1
   png_write_chunk(png_ptr, png_pHYs, buf, (png_size_t)9);
d1720 1
a1720 1
   png_write_chunk(png_ptr, png_tIME, buf, (png_size_t)7);
a1727 1
#ifdef PNG_WRITE_INTERLACING_SUPPORTED
a1742 1
#endif
a1753 1
#ifndef PNG_NO_WRITE_FILTERING
d1771 1
a1771 1
         png_ptr->up_row = (png_bytep)png_malloc(png_ptr,
d1785 1
a1785 1
         png_ptr->paeth_row = (png_bytep)png_malloc(png_ptr,
a1788 1
#endif /* PNG_NO_WRITE_FILTERING */
a1821 1
#ifdef PNG_WRITE_INTERLACING_SUPPORTED
a1836 1
#endif
d2110 1
a2110 3
   png_bytep best_row;
#ifndef PNG_NO_WRITE_FILTER
   png_bytep prev_row, row_buf;
d2123 1
a2123 4
#endif
   best_row = png_ptr->row_buf;
#ifndef PNG_NO_WRITE_FILTER
   row_buf = best_row;
d2698 1
a2698 1
#endif /* PNG_NO_WRITE_FILTER */
a2702 1
#ifndef PNG_NO_WRITE_FILTER
a2714 1
#endif /* PNG_NO_WRITE_FILTER */
@


1.1.107.6
log
@*sigh*

sync with MirPortsâ€¦ they had another update
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.26 [April 2, 2008]
d6 1
a6 1
 * Copyright (c) 1998-2008 Glenn Randers-Pehrson
a382 2
   int ret;

d526 4
a529 13
   ret = deflateInit2(&png_ptr->zstream, png_ptr->zlib_level,
         png_ptr->zlib_method, png_ptr->zlib_window_bits,
         png_ptr->zlib_mem_level, png_ptr->zlib_strategy);
   if (ret != Z_OK)
   {
      if (ret == Z_VERSION_ERROR) png_error(png_ptr,
          "zlib failed to initialize compressor -- version error");
      if (ret == Z_STREAM_ERROR) png_error(png_ptr,
           "zlib failed to initialize compressor -- stream error");
      if (ret == Z_MEM_ERROR) png_error(png_ptr,
           "zlib failed to initialize compressor -- mem error");
      png_error(png_ptr, "zlib failed to initialize compressor");
   }
@


1.1.107.7
log
@SECURITY update of libpng to 1.2.32
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.30 [August 15, 2008]
a51 18
/* Simple function to write the signature.  If we have already written
 * the magic bytes of the signature, or more likely, the PNG stream is
 * being embedded into another stream and doesn't need its own signature,
 * we should call png_set_sig_bytes() to tell libpng how many of the
 * bytes have already been written.
 */
void /* PRIVATE */
png_write_sig(png_structp png_ptr)
{
   png_byte png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};

   /* write the rest of the 8 byte signature */
   png_write_data(png_ptr, &png_signature[png_ptr->sig_bytes],
      (png_size_t)(8 - png_ptr->sig_bytes));
   if (png_ptr->sig_bytes < 3)
      png_ptr->mode |= PNG_HAVE_PNG_SIGNATURE;
}

d65 1
a65 1
   if (png_ptr == NULL) return;
d67 1
a67 1
   png_write_chunk_data(png_ptr, data, (png_size_t)length);
d79 3
a81 1
   png_byte buf[8];
d83 3
a85 3
   png_debug2(0, "Writing %s chunk, length = %lu\n", chunk_name,
      (unsigned long)length);
   if (png_ptr == NULL) return;
d87 2
a88 6
   /* write the length and the chunk name */
   png_save_uint_32(buf, length);
   png_memcpy(buf + 4, chunk_name, 4);
   png_write_data(png_ptr, buf, (png_size_t)8);
   /* put the chunk name into png_ptr->chunk_name */
   png_memcpy(png_ptr->chunk_name, chunk_name, 4);
d103 1
a103 1
   if (png_ptr == NULL) return;
d106 1
a107 4
      /* update the CRC after writing the data,
       * in case that the user I/O routine alters it.
       */
      png_calculate_crc(png_ptr, data, length);
d117 1
a117 1
   if (png_ptr == NULL) return;
d119 1
a119 1
   /* write the crc in a single operation */
d125 17
d242 2
a243 2
                  (png_uint_32)
                  (comp->max_output_ptr * png_sizeof(png_charpp)));
d245 1
a245 1
                  * png_sizeof(png_charp));
d250 2
a251 2
                  (png_uint_32)
                  (comp->max_output_ptr * png_sizeof(png_charp)));
d255 1
a255 2
         comp->output_ptr[comp->num_output_ptr] =
            (png_charp)png_malloc(png_ptr,
d294 1
a294 1
                     png_sizeof(png_charp)));
d296 1
a296 1
                     old_max * png_sizeof(png_charp));
d302 1
a302 1
                     png_sizeof(png_charp)));
d307 1
a307 2
               (png_charp)png_malloc(png_ptr,
               (png_uint_32)png_ptr->zbuf_size);
d352 2
a353 2
      png_write_chunk_data(png_ptr, (png_bytep)comp->output_ptr[i],
         (png_size_t)png_ptr->zbuf_size);
d355 1
a355 1
       comp->output_ptr[i]=NULL;
d359 1
a359 1
       comp->output_ptr=NULL;
d363 1
a363 1
         (png_size_t)(png_ptr->zbuf_size - png_ptr->zstream.avail_out));
d399 1
a399 1
            default: png_error(png_ptr, "Invalid bit depth for grayscale image");
d499 1
a499 1
   png_write_chunk(png_ptr, (png_bytep)png_IHDR, buf, (png_size_t)13);
d592 1
a592 2
   png_write_chunk_start(png_ptr, (png_bytep)png_PLTE,
     (png_uint_32)(num_pal * 3));
d664 1
a664 1
   png_write_chunk(png_ptr, (png_bytep)png_IDAT, data, length);
d676 1
a676 1
   png_write_chunk(png_ptr, (png_bytep)png_IEND, png_bytep_NULL,
d697 1
a697 1
   png_write_chunk(png_ptr, (png_bytep)png_gAMA, buf, (png_size_t)4);
d712 1
a712 1
   png_write_chunk(png_ptr, (png_bytep)png_gAMA, buf, (png_size_t)4);
d728 1
a728 1
   if (srgb_intent >= PNG_sRGB_INTENT_LAST)
d732 1
a732 1
   png_write_chunk(png_ptr, (png_bytep)png_sRGB, buf, (png_size_t)1);
d773 4
a776 4
          ((*( (png_bytep)profile    ))<<24) |
          ((*( (png_bytep)profile + 1))<<16) |
          ((*( (png_bytep)profile + 2))<< 8) |
          ((*( (png_bytep)profile + 3))    );
d779 5
a783 5
   {
      png_warning(png_ptr,
        "Embedded profile length too large in iCCP chunk");
      return;
   }
d786 5
a790 5
   {
      png_warning(png_ptr,
        "Truncating profile to actual length in iCCP chunk");
      profile_len = embedded_profile_len;
   }
d793 2
a794 2
      profile_len = png_text_compress(png_ptr, profile,
        (png_size_t)profile_len, PNG_COMPRESSION_TYPE_BASE, &comp);
d797 4
a800 5
   png_write_chunk_start(png_ptr, (png_bytep)png_iCCP,
          (png_uint_32)(name_len + profile_len + 2));
   new_name[name_len + 1] = 0x00;
   png_write_chunk_data(png_ptr, (png_bytep)new_name,
     (png_size_t)(name_len + 2));
d837 4
a840 5
   png_write_chunk_start(png_ptr, (png_bytep)png_sPLT,
     (png_uint_32)(name_len + 2 + palette_size));
   png_write_chunk_data(png_ptr, (png_bytep)new_name,
     (png_size_t)(name_len + 1));
   png_write_chunk_data(png_ptr, (png_bytep)&spalette->depth, (png_size_t)1);
d844 1
a844 1
   for (ep = spalette->entries; ep<spalette->entries + spalette->nentries; ep++)
d846 17
a862 17
      if (spalette->depth == 8)
      {
          entrybuf[0] = (png_byte)ep->red;
          entrybuf[1] = (png_byte)ep->green;
          entrybuf[2] = (png_byte)ep->blue;
          entrybuf[3] = (png_byte)ep->alpha;
          png_save_uint_16(entrybuf + 4, ep->frequency);
      }
      else
      {
          png_save_uint_16(entrybuf + 0, ep->red);
          png_save_uint_16(entrybuf + 2, ep->green);
          png_save_uint_16(entrybuf + 4, ep->blue);
          png_save_uint_16(entrybuf + 6, ep->alpha);
          png_save_uint_16(entrybuf + 8, ep->frequency);
      }
      png_write_chunk_data(png_ptr, entrybuf, (png_size_t)entry_size);
d868 17
a884 17
      if (spalette->depth == 8)
      {
          entrybuf[0] = (png_byte)ep[i].red;
          entrybuf[1] = (png_byte)ep[i].green;
          entrybuf[2] = (png_byte)ep[i].blue;
          entrybuf[3] = (png_byte)ep[i].alpha;
          png_save_uint_16(entrybuf + 4, ep[i].frequency);
      }
      else
      {
          png_save_uint_16(entrybuf + 0, ep[i].red);
          png_save_uint_16(entrybuf + 2, ep[i].green);
          png_save_uint_16(entrybuf + 4, ep[i].blue);
          png_save_uint_16(entrybuf + 6, ep[i].alpha);
          png_save_uint_16(entrybuf + 8, ep[i].frequency);
      }
      png_write_chunk_data(png_ptr, entrybuf, (png_size_t)entry_size);
d945 1
a945 1
   png_write_chunk(png_ptr, (png_bytep)png_sBIT, buf, size);
d970 1
a970 1
      fprintf(stderr, "white_x=%f, white_y=%f\n", white_x, white_y);
d1009 1
a1009 1
   png_write_chunk(png_ptr, (png_bytep)png_cHRM, buf, (png_size_t)32);
d1030 1
a1030 2
      fprintf(stderr, "white_x=%ld, white_y=%ld\n", (unsigned long)white_x,
        (unsigned long)white_y);
d1061 1
a1061 1
   png_write_chunk(png_ptr, (png_bytep)png_cHRM, buf, (png_size_t)32);
d1082 1
a1082 1
         png_warning(png_ptr, "Invalid number of transparent colors specified");
d1086 1
a1086 2
      png_write_chunk(png_ptr, (png_bytep)png_tRNS, trans,
        (png_size_t)num_trans);
d1091 1
a1091 1
      if (tran->gray >= (1 << png_ptr->bit_depth))
d1098 1
a1098 1
      png_write_chunk(png_ptr, (png_bytep)png_tRNS, buf, (png_size_t)2);
d1106 7
a1112 7
      if (png_ptr->bit_depth == 8 && (buf[0] | buf[2] | buf[4]))
      {
         png_warning(png_ptr,
           "Ignoring attempt to write 16-bit tRNS chunk when bit_depth is 8");
         return;
      }
      png_write_chunk(png_ptr, (png_bytep)png_tRNS, buf, (png_size_t)6);
d1145 1
a1145 1
      png_write_chunk(png_ptr, (png_bytep)png_bKGD, buf, (png_size_t)1);
d1152 7
a1158 7
      if (png_ptr->bit_depth == 8 && (buf[0] | buf[2] | buf[4]))
      {
         png_warning(png_ptr,
           "Ignoring attempt to write 16-bit bKGD chunk when bit_depth is 8");
         return;
      }
      png_write_chunk(png_ptr, (png_bytep)png_bKGD, buf, (png_size_t)6);
d1162 1
a1162 1
      if (back->gray >= (1 << png_ptr->bit_depth))
d1169 1
a1169 1
      png_write_chunk(png_ptr, (png_bytep)png_bKGD, buf, (png_size_t)2);
d1194 1
a1194 2
   png_write_chunk_start(png_ptr, (png_bytep)png_hIST,
     (png_uint_32)(num_hist * 2));
d1314 1
a1314 1
   if (kwarn)
d1320 1
a1320 1
       *new_key=NULL;
d1360 1
a1360 2
   png_write_chunk_start(png_ptr, (png_bytep)png_tEXt,
      (png_uint_32)(key_len + text_len + 1));
d1367 1
a1367 2
   png_write_chunk_data(png_ptr, (png_bytep)new_key,
     (png_size_t)(key_len + 1));
d1369 1
a1369 1
      png_write_chunk_data(png_ptr, (png_bytep)text, (png_size_t)text_len);
a1400 1
      png_free(png_ptr, new_key);
d1418 2
a1419 2
   png_write_chunk_start(png_ptr, (png_bytep)png_zTXt,
     (png_uint_32)(key_len+text_len + 2));
d1421 1
a1421 2
   png_write_chunk_data(png_ptr, (png_bytep)new_key,
     (png_size_t)(key_len + 1));
d1486 1
a1486 1
   png_write_chunk_start(png_ptr, (png_bytep)png_iTXt,
d1500 1
a1500 2
   png_write_chunk_data(png_ptr, (png_bytep)new_key,
     (png_size_t)(key_len + 1));
d1510 1
a1510 1
   png_write_chunk_data(png_ptr, cbuf, (png_size_t)2);
d1513 2
a1514 4
   png_write_chunk_data(png_ptr, (new_lang ? (png_bytep)new_lang : cbuf),
     (png_size_t)(lang_len + 1));
   png_write_chunk_data(png_ptr, (lang_key ? (png_bytep)lang_key : cbuf),
     (png_size_t)(lang_key_len + 1));
d1519 2
a1520 1
   png_free(png_ptr, new_lang);
d1543 1
a1543 1
   png_write_chunk(png_ptr, (png_bytep)png_oFFs, buf, (png_size_t)9);
d1571 2
a1572 2
   params_len = (png_uint_32p)png_malloc(png_ptr,
      (png_uint_32)(nparams * png_sizeof(png_uint_32)));
d1579 1
a1579 2
      png_debug2(3, "pCAL parameter %d length = %lu\n", i,
        (unsigned long) params_len[i]);
d1584 2
a1585 3
   png_write_chunk_start(png_ptr, (png_bytep)png_pCAL, (png_uint_32)total_len);
   png_write_chunk_data(png_ptr, (png_bytep)new_purpose,
     (png_size_t)purpose_len);
d1644 1
a1644 1
   png_write_chunk(png_ptr, (png_bytep)png_sCAL, (png_bytep)buf, total_len);
d1674 1
a1674 1
   png_write_chunk(png_ptr, (png_bytep)png_sCAL, buf, total_len);
d1700 1
a1700 1
   png_write_chunk(png_ptr, (png_bytep)png_pHYs, buf, (png_size_t)9);
d1732 1
a1732 1
   png_write_chunk(png_ptr, (png_bytep)png_tIME, buf, (png_size_t)7);
d1762 1
a1762 1
      png_ptr->usr_channels*png_ptr->usr_bit_depth, png_ptr->width) + 1);
d1765 1
a1765 2
   png_ptr->row_buf = (png_bytep)png_malloc(png_ptr,
     (png_uint_32)buf_size);
d1768 1
a1768 1
#ifndef PNG_NO_WRITE_FILTER
d1773 1
a1773 1
         (png_uint_32)(png_ptr->rowbytes + 1));
d1781 1
a1781 2
      png_ptr->prev_row = (png_bytep)png_malloc(png_ptr,
        (png_uint_32)buf_size);
d1787 1
a1787 1
           (png_uint_32)(png_ptr->rowbytes + 1));
d1794 1
a1794 1
           (png_uint_32)(png_ptr->rowbytes + 1));
d1801 1
a1801 1
           (png_uint_32)(png_ptr->rowbytes + 1));
d1804 1
a1805 1
#endif /* PNG_NO_WRITE_FILTER */
d1903 1
a1903 1
               png_ptr->usr_bit_depth, png_ptr->width)) + 1);
@


1.1.107.8
log
@libpng 1.2.35
@
text
@d4 1
a4 1
 * Last changed in libpng 1.2.34 [December 18, 2008]
d99 1
a99 1
   png_debug2(0, "Writing %s chunk, length = %lu", chunk_name,
d395 1
a395 1
   png_debug(1, "in png_write_IHDR");
d572 1
a572 1
   png_debug(1, "in png_write_PLTE");
d598 1
a598 1
   png_debug1(3, "num_palette = %d", png_ptr->num_palette);
d632 1
a632 1
   png_debug(1, "in png_write_IDAT");
d684 1
a684 1
   png_debug(1, "in png_write_IEND");
d702 1
a702 1
   png_debug(1, "in png_write_gAMA");
d718 1
a718 1
   png_debug(1, "in png_write_gAMA");
d736 1
a736 1
   png_debug(1, "in png_write_sRGB");
d759 1
a759 1
   png_debug(1, "in png_write_iCCP");
d767 1
a767 1
   if ((name_len = png_check_keyword(png_ptr, name,
d769 2
d772 1
d838 2
a839 2
   png_debug(1, "in png_write_sPLT");
   if ((name_len = png_check_keyword(png_ptr,
d841 4
a844 1
     return;
d915 1
a915 1
   png_debug(1, "in png_write_sBIT");
d972 1
d974 15
a988 2
   png_fixed_point int_white_x, int_white_y, int_red_x, int_red_y,
      int_green_x, int_green_y, int_blue_x, int_blue_y;
d990 9
a998 1
   png_debug(1, "in png_write_cHRM");
d1000 9
a1008 8
   int_white_x = (png_uint_32)(white_x * 100000.0 + 0.5);
   int_white_y = (png_uint_32)(white_y * 100000.0 + 0.5);
   int_red_x   = (png_uint_32)(red_x   * 100000.0 + 0.5);
   int_red_y   = (png_uint_32)(red_y   * 100000.0 + 0.5);
   int_green_x = (png_uint_32)(green_x * 100000.0 + 0.5);
   int_green_y = (png_uint_32)(green_y * 100000.0 + 0.5);
   int_blue_x  = (png_uint_32)(blue_x  * 100000.0 + 0.5);
   int_blue_y  = (png_uint_32)(blue_y  * 100000.0 + 0.5);
d1010 1
a1010 4
#if !defined(PNG_NO_CHECK_cHRM)
   if (png_check_cHRM_fixed(png_ptr, int_white_x, int_white_y,
      int_red_x, int_red_y, int_green_x, int_green_y, int_blue_x, int_blue_y))
#endif
d1012 7
a1018 4
     /* each value is saved in 1/100,000ths */
   
     png_save_uint_32(buf, int_white_x);
     png_save_uint_32(buf + 4, int_white_y);
d1020 1
a1020 11
     png_save_uint_32(buf + 8, int_red_x);
     png_save_uint_32(buf + 12, int_red_y);

     png_save_uint_32(buf + 16, int_green_x);
     png_save_uint_32(buf + 20, int_green_y);

     png_save_uint_32(buf + 24, int_blue_x);
     png_save_uint_32(buf + 28, int_blue_y);

     png_write_chunk(png_ptr, (png_bytep)png_cHRM, buf, (png_size_t)32);
   }
d1035 1
a1035 1
   png_debug(1, "in png_write_cHRM");
d1037 6
a1042 3
#if !defined(PNG_NO_CHECK_cHRM)
   if (png_check_cHRM_fixed(png_ptr, white_x, white_y, red_x, red_y,
      green_x, green_y, blue_x, blue_y))
d1044 2
a1045 1
   {
d1049 5
d1057 5
d1065 5
a1073 1
   }
d1089 1
a1089 1
   png_debug(1, "in png_write_tRNS");
d1144 1
a1144 1
   png_debug(1, "in png_write_bKGD");
d1152 1
a1152 1
         back->index >= png_ptr->num_palette)
d1198 1
a1198 1
   png_debug(1, "in png_write_hIST");
d1201 1
a1201 1
      png_debug2(3, "num_hist = %d, num_palette = %d", num_hist,
d1238 1
a1238 1
   png_debug(1, "in png_check_keyword");
d1247 1
a1247 1
   png_debug1(2, "Keyword to be checked is '%s'", key);
d1306 1
a1306 1
   png_debug1(2, "Checking for multiple internal spaces in '%s'", kp);
d1341 1
a1341 1
      (*new_key)[79] = '\0';
d1361 4
a1364 2
   png_debug(1, "in png_write_tEXt");
   if ((key_len = png_check_keyword(png_ptr, key, &new_key))==0)
d1366 1
d1406 1
a1406 1
   png_debug(1, "in png_write_zTXt");
d1414 1
a1414 1
   if ((key_len = png_check_keyword(png_ptr, key, &new_key))==0)
d1416 1
d1463 1
a1463 2
   png_charp new_lang;
   png_charp new_key = NULL;
d1467 1
a1467 1
   png_debug(1, "in png_write_iTXt");
d1474 3
a1476 1
   if ((key_len = png_check_keyword(png_ptr, key, &new_key))==0)
d1478 2
a1479 2

   if ((lang_len = png_check_keyword(png_ptr, lang, &new_lang))==0)
d1555 1
a1555 1
   png_debug(1, "in png_write_oFFs");
d1581 1
a1581 1
   png_debug1(1, "in png_write_pCAL (%d parameters)", nparams);
d1586 1
a1586 1
   png_debug1(3, "pCAL purpose length = %d", (int)purpose_len);
d1588 1
a1588 1
   png_debug1(3, "pCAL units length = %d", (int)units_len);
d1599 1
a1599 1
      png_debug2(3, "pCAL parameter %d length = %lu", i,
d1604 1
a1604 1
   png_debug1(3, "pCAL total length = %d", (int)total_len);
d1640 1
a1640 1
   png_debug(1, "in png_write_sCAL");
d1665 1
a1665 1
   png_debug1(3, "sCAL total length = %u", (unsigned int)total_len);
d1680 1
a1680 1
   png_debug(1, "in png_write_sCAL_s");
d1695 1
a1695 1
   png_debug1(3, "sCAL total length = %u", (unsigned int)total_len);
d1714 1
a1714 1
   png_debug(1, "in png_write_pHYs");
d1738 1
a1738 1
   png_debug(1, "in png_write_tIME");
d1782 1
a1782 1
   png_debug(1, "in png_write_start_row");
d1882 1
a1882 1
   png_debug(1, "in png_write_finish_row");
d1991 1
a1991 1
   png_debug(1, "in png_do_write_interlace");
d2162 1
a2162 1
   png_debug(1, "in png_write_find_filter");
d2771 2
a2772 2
   png_debug(1, "in png_write_filtered_row");
   png_debug1(2, "filter = %d", filtered_row[0]);
@


1.1.107.9
log
@Update libpng in the base system, too
@
text
@d4 3
a6 2
 * Last changed in libpng 1.2.43 [February 25, 2010]
 * Copyright (c) 1998-2010 Glenn Randers-Pehrson
a8 4
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
a11 1
#define PNG_NO_PEDANTIC_WARNINGS
d63 1
a63 1
   /* Write the rest of the 8 byte signature */
d83 1
a83 2
   if (png_ptr == NULL)
      return;
d101 1
d103 1
a103 5
   if (png_ptr == NULL)
      return;


   /* Write the length and the chunk name */
d107 1
a107 1
   /* Put the chunk name into png_ptr->chunk_name */
d109 1
a109 1
   /* Reset the crc and run it over the chunk name */
d122 2
a123 3
   /* Write the data, and run the CRC over it */
   if (png_ptr == NULL)
      return;
d127 1
a127 1
      /* Update the CRC after writing the data,
d142 1
a142 1
   /* Write the crc in a single operation */
d149 2
a150 1
/* This pair of functions encapsulates the operation of (a) compressing a
d158 5
a162 5
   char *input;   /* The uncompressed input data */
   int input_len;   /* Its length */
   int num_output_ptr; /* Number of output pointers used */
   int max_output_ptr; /* Size of output_ptr */
   png_charpp output_ptr; /* Array of pointers to output */
d165 1
a165 1
/* Compress given text into storage in the png_ptr structure */
d179 1
a179 1
   /* We may just want to pass the text right through */
d189 1
a189 1
#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)
d213 1
a213 1
   /* Set up the compression buffers */
d219 1
a219 1
   /* This is the same compression loop as in png_write_row() */
d222 1
a222 1
      /* Compress the data */
d226 1
a226 1
         /* Error */
d232 1
a232 1
      /* Check to see if we need more room */
d235 1
a235 1
         /* Make sure the output array has room */
d260 1
a260 1
         /* Save the data */
d272 1
a272 1
   /* Continue until we don't have any more to compress */
d275 1
a275 1
   /* Finish the compression */
d278 1
a278 1
      /* Tell zlib we are finished */
d283 1
a283 1
         /* Check to see if we need more room */
d286 1
a286 1
            /* Check to make sure our output array has room */
d312 1
a312 1
            /* Save the data */
d327 1
a327 1
         /* We got an error */
d335 1
a335 1
   /* Text length is number of buffers plus last buffer */
d343 1
a343 1
/* Ship the compressed text out via chunk writes */
d349 1
a349 1
   /* Handle the no-compression case */
d352 1
a352 1
      png_write_chunk_data(png_ptr, (png_bytep)comp->input,
d354 1
a354 1
      return;
d357 1
a357 1
   /* Write saved output buffers, if any */
d368 1
a368 1
   /* Write anything left in zbuf */
d373 1
a373 1
   /* Reset zlib for another zTXt/iTXt or image data */
d393 1
a393 1
   png_byte buf[13]; /* Buffer to store the IHDR info */
a395 1

d407 1
a407 2
            default: png_error(png_ptr,
                         "Invalid bit depth for grayscale image");
d455 1
a455 1
#ifdef PNG_MNG_FEATURES_SUPPORTED
d479 1
a479 1
   /* Save the relevent information */
d483 1
a483 1
#ifdef PNG_MNG_FEATURES_SUPPORTED
d492 1
a492 1
   /* Set the usr info, so any transformations can modify it */
d497 1
a497 1
   /* Pack the header information into the buffer */
d506 1
a506 1
   /* Write the chunk */
d509 1
a509 1
   /* Initialize zlib with PNG info */
d552 1
a552 1
   /* Set it to a predefined value, to avoid its evaluation inside zlib */
d558 1
a558 1
/* Write the palette.  We are careful not to trust png_color to be in the
a572 1

d574 1
a574 1
#ifdef PNG_MNG_FEATURES_SUPPORTED
d602 1
a602 1
#ifdef PNG_POINTER_INDEXING_SUPPORTED
d611 1
a611 3
   /* This is a little slower but some buggy compilers need to do this
    * instead
    */
d625 1
a625 1
/* Write an IDAT chunk */
a631 1

d642 3
a644 5
         /* Avoid memory underflows and multiplication overflows.
          *
          * The conditions below are practically always satisfied;
          * however, they still must be checked.
          */
d677 1
a677 1
/* Write an IEND chunk */
a683 1

a684 1

d690 2
a691 2
#ifdef PNG_WRITE_gAMA_SUPPORTED
/* Write a gAMA chunk */
a702 1

a718 1

d726 2
a727 2
#ifdef PNG_WRITE_sRGB_SUPPORTED
/* Write a sRGB chunk */
a736 1

d745 2
a746 2
#ifdef PNG_WRITE_iCCP_SUPPORTED
/* Write an iCCP chunk */
a783 8
   if (embedded_profile_len < 0)
   {
      png_warning(png_ptr,
        "Embedded profile length in iCCP chunk is negative");
      png_free(png_ptr, new_name);
      return;
   }

a787 1
      png_free(png_ptr, new_name);
d802 1
a802 1
   /* Make sure we include the NULL after the name and the compression type */
d817 2
a818 2
#ifdef PNG_WRITE_sPLT_SUPPORTED
/* Write a sPLT chunk */
d831 1
a831 1
#ifndef PNG_POINTER_INDEXING_SUPPORTED
d836 3
d840 1
a840 4
   if ((name_len = png_check_keyword(png_ptr,spalette->name, &new_name))==0)
      return;

   /* Make sure we include the NULL after the name */
d847 2
a848 2
   /* Loop through each palette entry, writing appropriately */
#ifdef PNG_POINTER_INDEXING_SUPPORTED
d898 2
a899 2
#ifdef PNG_WRITE_sBIT_SUPPORTED
/* Write the sBIT chunk */
d910 1
a910 2

   /* Make sure we don't depend upon the order of PNG_COLOR_8 */
d954 2
a955 2
#ifdef PNG_WRITE_cHRM_SUPPORTED
/* Write the cHRM chunk */
d981 1
a981 1
#ifdef PNG_CHECK_cHRM_SUPPORTED
d986 4
a989 4
      /* Each value is saved in 1/100,000ths */

      png_save_uint_32(buf, int_white_x);
      png_save_uint_32(buf + 4, int_white_y);
d991 2
a992 2
      png_save_uint_32(buf + 8, int_red_x);
      png_save_uint_32(buf + 12, int_red_y);
d994 2
a995 2
      png_save_uint_32(buf + 16, int_green_x);
      png_save_uint_32(buf + 20, int_green_y);
d997 2
a998 2
      png_save_uint_32(buf + 24, int_blue_x);
      png_save_uint_32(buf + 28, int_blue_y);
d1000 1
a1000 1
      png_write_chunk(png_ptr, (png_bytep)png_cHRM, buf, (png_size_t)32);
d1017 2
a1018 3

   /* Each value is saved in 1/100,000ths */
#ifdef PNG_CHECK_cHRM_SUPPORTED
d1023 2
a1024 2
      png_save_uint_32(buf, (png_uint_32)white_x);
      png_save_uint_32(buf + 4, (png_uint_32)white_y);
d1026 2
a1027 2
      png_save_uint_32(buf + 8, (png_uint_32)red_x);
      png_save_uint_32(buf + 12, (png_uint_32)red_y);
d1029 2
a1030 2
      png_save_uint_32(buf + 16, (png_uint_32)green_x);
      png_save_uint_32(buf + 20, (png_uint_32)green_y);
d1032 2
a1033 2
      png_save_uint_32(buf + 24, (png_uint_32)blue_x);
      png_save_uint_32(buf + 28, (png_uint_32)blue_y);
d1035 1
a1035 1
      png_write_chunk(png_ptr, (png_bytep)png_cHRM, buf, (png_size_t)32);
d1041 2
a1042 2
#ifdef PNG_WRITE_tRNS_SUPPORTED
/* Write the tRNS chunk */
a1052 1

d1060 1
a1060 1
      /* Write the chunk out as it is */
d1066 1
a1066 1
      /* One 16 bit value */
d1078 1
a1078 1
      /* Three 16 bit values */
d1097 2
a1098 2
#ifdef PNG_WRITE_bKGD_SUPPORTED
/* Write the background chunk */
a1107 1

d1111 1
a1111 1
#ifdef PNG_MNG_FEATURES_SUPPORTED
d1150 2
a1151 2
#ifdef PNG_WRITE_hIST_SUPPORTED
/* Write the histogram */
a1161 1

a1201 1

d1225 1
a1225 1
#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)
d1251 2
a1252 2
         *(kp--) = '\0';
         key_len--;
d1264 2
a1265 2
         kp++;
         key_len--;
d1312 2
a1313 2
#ifdef PNG_WRITE_tEXt_SUPPORTED
/* Write a tEXt chunk */
a1324 1

d1333 1
a1333 1
   /* Make sure we include the 0 after the key */
d1352 2
a1353 2
#ifdef PNG_WRITE_zTXt_SUPPORTED
/* Write a compressed text chunk */
d1389 1
a1389 1
   /* Compute the compressed data; do it now for the length */
d1393 1
a1393 1
   /* Write start of chunk */
d1396 1
a1396 1
   /* Write key */
d1402 1
a1402 1
   /* Write compression */
d1404 1
a1404 1
   /* Write the compressed data */
d1407 1
a1407 1
   /* Close the chunk */
d1412 2
a1413 2
#ifdef PNG_WRITE_iTXt_SUPPORTED
/* Write an iTXt chunk */
d1445 1
a1445 1
      lang_key_len = 0;
d1447 1
a1447 1
      lang_key_len = png_strlen(lang_key);
d1452 1
a1452 1
      text_len = png_strlen(text);
d1454 1
a1454 1
   /* Compute the compressed data; do it now for the length */
d1459 1
a1459 1
   /* Make sure we include the compression flag, the compression byte,
d1470 2
a1471 1
   /* We leave it to the application to meet PNG-1.0 requirements on the
d1479 1
a1479 1
   /* Set the compression flag */
d1485 1
a1485 1
   /* Set the compression method */
d1502 2
a1503 2
#ifdef PNG_WRITE_oFFs_SUPPORTED
/* Write the oFFs chunk */
a1513 1

d1524 2
a1525 2
#ifdef PNG_WRITE_pCAL_SUPPORTED
/* Write the pCAL chunk (described in the PNG extensions document) */
a1539 1

d1586 3
a1588 3
#ifdef PNG_WRITE_sCAL_SUPPORTED
/* Write the sCAL chunk */
#if defined(PNG_FLOATING_POINT_SUPPORTED) && defined(PNG_STDIO_SUPPORTED)
d1601 1
a1601 1
#ifdef _WIN32_WCE
d1608 1
a1608 2
      WideCharToMultiByte(CP_ACP, 0, wc_buf, -1, buf + 1, wc_len, NULL,
          NULL);
d1650 2
a1651 2
   png_memcpy(buf + 1, width, wlen + 1);      /* Append the '\0' here */
   png_memcpy(buf + wlen + 2, height, hlen);  /* Do NOT append the '\0' here */
d1660 2
a1661 2
#ifdef PNG_WRITE_pHYs_SUPPORTED
/* Write the pHYs chunk */
a1672 1

d1684 1
a1684 1
#ifdef PNG_WRITE_tIME_SUPPORTED
a1696 1

d1716 1
a1716 1
/* Initializes the row writing capability of libpng */
d1721 2
a1722 1
   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
d1724 1
a1724 1
   /* Start of interlace block */
d1727 1
a1727 1
   /* Offset to next interlace block */
d1730 1
a1730 1
   /* Start of interlace block in the y direction */
d1733 1
a1733 1
   /* Offset to next interlace block in the y direction */
d1736 1
a1740 1

d1744 1
a1744 1
   /* Set up row buffer */
d1749 2
a1750 2
#ifdef PNG_WRITE_FILTER_SUPPORTED
   /* Set up filtering buffer, if using this filter */
d1761 4
a1764 3
      /* Set up previous row buffer */
      png_ptr->prev_row = (png_bytep)png_calloc(png_ptr,
         (png_uint_32)buf_size);
d1769 1
a1769 1
            (png_uint_32)(png_ptr->rowbytes + 1));
d1776 1
a1776 1
            (png_uint_32)(png_ptr->rowbytes + 1));
d1783 1
a1783 1
            (png_uint_32)(png_ptr->rowbytes + 1));
d1787 1
a1787 1
#endif /* PNG_WRITE_FILTER_SUPPORTED */
d1790 1
a1790 1
   /* If interlaced, we need to set up width and height of pass */
d1821 2
a1822 1
   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
d1824 1
a1824 1
   /* Start of interlace block */
d1827 1
a1827 1
   /* Offset to next interlace block */
d1830 1
a1830 1
   /* Start of interlace block in the y direction */
d1833 1
a1833 1
   /* Offset to next interlace block in the y direction */
d1836 1
d1841 1
a1841 2

   /* Next row */
d1844 1
a1844 1
   /* See if we are done */
d1849 1
a1849 1
   /* If interlaced, go to next pass */
d1859 1
a1859 1
         /* Loop until we find a non-zero width or height pass */
d1879 1
a1879 1
      /* Reset the row above the image for the next pass */
d1891 1
a1891 1
   /* If we get here, we've just written the last row, so we need
d1895 1
a1895 1
      /* Tell the compressor we are done */
d1897 1
a1897 1
      /* Check for an error */
d1900 1
a1900 1
         /* Check to see if we need more room */
d1917 1
a1917 1
   /* Write any extra space */
d1928 1
a1928 1
#ifdef PNG_WRITE_INTERLACING_SUPPORTED
d1939 2
a1940 1
   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
d1942 1
a1942 1
   /* Start of interlace block */
d1945 1
a1945 1
   /* Offset to next interlace block */
d1947 1
d1950 2
a1951 3

   /* We don't have to do anything on the last pass (6) */
#ifdef PNG_USELESS_TESTS_SUPPORTED
d1957 1
a1957 1
      /* Each pixel depth is handled separately */
d2068 1
a2068 1
            /* Start at the beginning */
d2070 1
a2070 1
            /* Find out how many bytes each pixel takes up */
d2072 1
a2072 1
            /* Loop through the row, only looking at the pixels that
d2077 1
a2077 1
               /* Find out where the original pixel is */
d2079 1
a2079 1
               /* Move the pixel */
d2082 1
a2082 1
               /* Next pixel */
d2088 1
a2088 1
      /* Set new row width */
d2111 1
a2111 1
#ifdef PNG_WRITE_FILTER_SUPPORTED
d2116 1
a2116 1
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
d2118 1
a2118 1
#endif 
d2121 1
a2121 10

#ifndef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
  if (png_ptr->row_number == 0 && filter_to_do == PNG_ALL_FILTERS)
  {
      /* These will never be selected so we need not test them. */
      filter_to_do &= ~(PNG_FILTER_UP | PNG_FILTER_PAETH);
  }
#endif 

   /* Find out how many bytes offset each pixel is */
d2127 1
a2127 1
#ifdef PNG_WRITE_FILTER_SUPPORTED
d2170 1
a2170 1
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
d2208 1
a2208 1
   /* Sub filter */
d2210 1
a2210 1
   /* It's the only filter so no testing is needed */
d2234 1
a2234 1
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
d2287 1
a2287 1
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
d2325 1
a2325 1
   /* Up filter */
d2348 1
a2348 1
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
d2390 1
a2390 1
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
d2428 1
a2428 1
   /* Avg filter */
d2453 1
a2453 1
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
d2502 1
a2502 1
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
d2586 1
a2586 1
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
d2667 1
a2667 1
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
d2703 1
a2703 1
#endif /* PNG_WRITE_FILTER_SUPPORTED */
d2708 2
a2709 2
#ifdef PNG_WRITE_FILTER_SUPPORTED
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
d2721 1
a2721 1
#endif /* PNG_WRITE_FILTER_SUPPORTED */
a2729 1

d2731 1
a2731 1
   /* Set up the zlib input buffer */
d2735 1
a2735 1
   /* Repeat until we have compressed all the data */
d2738 1
a2738 1
      int ret; /* Return of zlib */
d2740 1
a2740 1
      /* Compress the data */
d2742 1
a2742 1
      /* Check for compression errors */
d2751 1
a2751 1
      /* See if it is time to write another IDAT */
d2754 1
a2754 1
         /* Write the IDAT and reset the zlib output buffer */
d2759 1
a2759 1
   /* Repeat until all data has been compressed */
d2762 1
a2762 1
   /* Swap the current and previous rows */
d2772 1
a2772 1
   /* Finish row - updates counters and flushes zlib if last row */
d2775 1
a2775 1
#ifdef PNG_WRITE_FLUSH_SUPPORTED
@


1.1.107.10
log
@update libpng
@
text
@d4 2
a5 2
 * Last changed in libpng 1.2.56 [December 17, 2015]
 * Copyright (c) 1998-2002,2004,2006-2015 Glenn Randers-Pehrson
d257 1
a257 1
                  (comp->max_output_ptr * png_sizeof(png_charp)));
d578 1
a578 1
   png_uint_32 max_palette_length, i;
a583 3
   max_palette_length = (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) ?
      (1 << png_ptr->bit_depth) : PNG_MAX_PALETTE_LENGTH;

d588 1
a588 1
       num_pal == 0) || num_pal > max_palette_length)
d1216 132
a1761 1
#ifndef PNG_USE_GLOBAL_ARRAYS
a1775 1
#endif
a1859 1
#ifndef PNG_USE_GLOBAL_ARRAYS
a1873 1
#endif
a1978 1
#ifndef PNG_USE_GLOBAL_ARRAYS
a1983 1
#endif
d2153 3
d2159 8
d2216 35
d2280 35
d2333 31
d2393 32
d2436 31
d2499 31
d2548 31
d2632 31
d2713 31
d2753 15
@


