head	1.5;
access;
symbols
	sendmail-8_14_9:1.1.127.3
	sendmail-8_14_7:1.1.127.2
	sendmail-8_14_6:1.1.127.2
	sendmail-8_14_5-ERRATA-1:1.1.127.2
	mbsd-20101220_mergebase:1.4
	sendmail-8_14_5:1.1.127.2
	cvs-201107021500:1.1.1.6
	cvs-20101220:1.1.1.5
	mbsd-20101220:1.4.0.2
	cvs-201012191730:1.1.1.4
	sendmail-8_14_5_Beta0:1.1.127.2
	sendmail-8_14_3:1.1.127.1
	sendmail:1.1.127
	cvs-200812170000:1.1.1.4
	cvs-200805071200:1.1.1.4
	MIRBSD_10:1.2.0.2
	MIRBSD_10_BASE:1.2
	cvs-200803022030:1.1.1.3
	cvs-200707152000:1.1.1.3
	cvs-200704292000:1.1.1.3
	cvs-200702051700:1.1.1.3
	cvs-200609121900:1.1.1.2
	MIRBSD_9_BASE:1.1.1.2
	cvs-200606151800:1.1.1.2
	cvs-200603231300:1.1.1.2
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200507211800:1.1.1.1
	cvs-200504262050:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2014.06.09.15.17.14;	author tg;	state Exp;
branches;
next	1.4;
commitid	1005395CFC65E5646F1;

1.4
date	2010.12.19.17.18.09;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004D0E3E2D1286B3DF;

1.3
date	2008.05.07.13.15.20;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004821AB7510EE48FB;

1.2
date	2008.03.02.21.41.09;	author tg;	state Exp;
branches
	1.2.2.1;
next	1.1;
commitid	10047CB1EE51190ECAF;

1.1
date	2005.02.05.17.24.22;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.127.1;
next	;

1.2.2.1
date	2008.05.17.19.11.53;	author tg;	state Exp;
branches;
next	;
commitid	100482F2DC168C89AEA;

1.1.1.1
date	2005.02.05.17.24.22;	author tg;	state Exp;
branches
	1.1.1.1.2.1;
next	1.1.1.2;

1.1.1.2
date	2006.03.23.13.09.23;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	10044229DEA33D36552;

1.1.1.3
date	2007.02.05.17.05.46;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	10045C763C551AABAF7;

1.1.1.4
date	2008.05.07.12.31.46;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	1004821A13C1FC036E1;

1.1.1.5
date	2011.07.02.14.59.46;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	1004E0F31C5496AB95F;

1.1.1.6
date	2011.07.02.15.17.38;	author tg;	state Exp;
branches;
next	;
commitid	1004E0F36A10B5CA95B;

1.1.1.1.2.1
date	2006.03.30.19.27.43;	author tg;	state Exp;
branches;
next	;
commitid	100442C309C7183FA09;

1.1.127.1
date	2010.12.19.14.45.52;	author tg;	state Exp;
branches;
next	1.1.127.2;
commitid	1004D0E1A94384778FD;

1.1.127.2
date	2010.12.19.14.56.32;	author tg;	state Exp;
branches;
next	1.1.127.3;
commitid	1004D0E1D294DE25888;

1.1.127.3
date	2014.06.09.14.29.24;	author tg;	state Exp;
branches;
next	;
commitid	1005395C4CC1A6DB9EE;


desc
@@


1.5
log
@merge
@
text
@/*
 *  Copyright (c) 1999-2007 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sm/gen.h>
SM_RCSID("@@(#)$Id: listener.c,v 8.127 2013-11-22 20:51:36 ca Exp $")

/*
**  listener.c -- threaded network listener
*/

#include "libmilter.h"
#include <sm/errstring.h>

#include <sys/types.h>
#include <sys/stat.h>


# if NETINET || NETINET6
#  include <arpa/inet.h>
# endif /* NETINET || NETINET6 */
# if SM_CONF_POLL
#  undef SM_FD_OK_SELECT
#  define SM_FD_OK_SELECT(fd)		true
# endif /* SM_CONF_POLL */

static smutex_t L_Mutex;
static int L_family;
static SOCKADDR_LEN_T L_socksize;
static socket_t listenfd = INVALID_SOCKET;

static socket_t mi_milteropen __P((char *, int, bool, char *));
#if !_FFR_WORKERS_POOL
static void *mi_thread_handle_wrapper __P((void *));
#endif /* !_FFR_WORKERS_POOL */

/*
**  MI_OPENSOCKET -- create the socket where this filter and the MTA will meet
**
**	Parameters:
**		conn -- connection description
**		backlog -- listen backlog
**		dbg -- debug level
**		rmsocket -- if true, try to unlink() the socket first
**			(UNIX domain sockets only)
**		smfi -- filter structure to use
**
**	Return value:
**		MI_SUCCESS/MI_FAILURE
*/

int
mi_opensocket(conn, backlog, dbg, rmsocket, smfi)
	char *conn;
	int backlog;
	int dbg;
	bool rmsocket;
	smfiDesc_ptr smfi;
{
	if (smfi == NULL || conn == NULL)
		return MI_FAILURE;

	if (ValidSocket(listenfd))
		return MI_SUCCESS;

	if (dbg > 0)
	{
		smi_log(SMI_LOG_DEBUG,
			"%s: Opening listen socket on conn %s",
			smfi->xxfi_name, conn);
	}
	(void) smutex_init(&L_Mutex);
	(void) smutex_lock(&L_Mutex);
	listenfd = mi_milteropen(conn, backlog, rmsocket, smfi->xxfi_name);
	if (!ValidSocket(listenfd))
	{
		smi_log(SMI_LOG_FATAL,
			"%s: Unable to create listening socket on conn %s",
			smfi->xxfi_name, conn);
		(void) smutex_unlock(&L_Mutex);
		return MI_FAILURE;
	}
	if (!SM_FD_OK_SELECT(listenfd))
	{
		smi_log(SMI_LOG_ERR, "%s: fd %d is larger than FD_SETSIZE %d",
			smfi->xxfi_name, listenfd, FD_SETSIZE);
		(void) smutex_unlock(&L_Mutex);
		return MI_FAILURE;
	}
	(void) smutex_unlock(&L_Mutex);
	return MI_SUCCESS;
}

/*
**  MI_MILTEROPEN -- setup socket to listen on
**
**	Parameters:
**		conn -- connection description
**		backlog -- listen backlog
**		rmsocket -- if true, try to unlink() the socket first
**			(UNIX domain sockets only)
**		name -- name for logging
**
**	Returns:
**		socket upon success, error code otherwise.
**
**	Side effect:
**		sets sockpath if UNIX socket.
*/

#if NETUNIX
static char	*sockpath = NULL;
#endif /* NETUNIX */

static socket_t
mi_milteropen(conn, backlog, rmsocket, name)
	char *conn;
	int backlog;
	bool rmsocket;
	char *name;
{
	socket_t sock;
	int sockopt = 1;
	int fdflags;
	size_t len = 0;
	char *p;
	char *colon;
	char *at;
	SOCKADDR addr;

	if (conn == NULL || conn[0] == '\0')
	{
		smi_log(SMI_LOG_ERR, "%s: empty or missing socket information",
			name);
		return INVALID_SOCKET;
	}
	(void) memset(&addr, '\0', sizeof addr);

	/* protocol:filename or protocol:port@@host */
	p = conn;
	colon = strchr(p, ':');
	if (colon != NULL)
	{
		*colon = '\0';

		if (*p == '\0')
		{
#if NETUNIX
			/* default to AF_UNIX */
			addr.sa.sa_family = AF_UNIX;
			L_socksize = sizeof (struct sockaddr_un);
#else /* NETUNIX */
# if NETINET
			/* default to AF_INET */
			addr.sa.sa_family = AF_INET;
			L_socksize = sizeof addr.sin;
# else /* NETINET */
#  if NETINET6
			/* default to AF_INET6 */
			addr.sa.sa_family = AF_INET6;
			L_socksize = sizeof addr.sin6;
#  else /* NETINET6 */
			/* no protocols available */
			smi_log(SMI_LOG_ERR,
				"%s: no valid socket protocols available",
				name);
			return INVALID_SOCKET;
#  endif /* NETINET6 */
# endif /* NETINET */
#endif /* NETUNIX */
		}
#if NETUNIX
		else if (strcasecmp(p, "unix") == 0 ||
			 strcasecmp(p, "local") == 0)
		{
			addr.sa.sa_family = AF_UNIX;
			L_socksize = sizeof (struct sockaddr_un);
		}
#endif /* NETUNIX */
#if NETINET
		else if (strcasecmp(p, "inet") == 0)
		{
			addr.sa.sa_family = AF_INET;
			L_socksize = sizeof addr.sin;
		}
#endif /* NETINET */
#if NETINET6
		else if (strcasecmp(p, "inet6") == 0)
		{
			addr.sa.sa_family = AF_INET6;
			L_socksize = sizeof addr.sin6;
		}
#endif /* NETINET6 */
		else
		{
			smi_log(SMI_LOG_ERR, "%s: unknown socket type %s",
				name, p);
			return INVALID_SOCKET;
		}
		*colon++ = ':';
	}
	else
	{
		colon = p;
#if NETUNIX
		/* default to AF_UNIX */
		addr.sa.sa_family = AF_UNIX;
		L_socksize = sizeof (struct sockaddr_un);
#else /* NETUNIX */
# if NETINET
		/* default to AF_INET */
		addr.sa.sa_family = AF_INET;
		L_socksize = sizeof addr.sin;
# else /* NETINET */
#  if NETINET6
		/* default to AF_INET6 */
		addr.sa.sa_family = AF_INET6;
		L_socksize = sizeof addr.sin6;
#  else /* NETINET6 */
		smi_log(SMI_LOG_ERR, "%s: unknown socket type %s",
			name, p);
		return INVALID_SOCKET;
#  endif /* NETINET6 */
# endif /* NETINET */
#endif /* NETUNIX */
	}

#if NETUNIX
	if (addr.sa.sa_family == AF_UNIX)
	{
# if 0
		long sff = SFF_SAFEDIRPATH|SFF_OPENASROOT|SFF_NOLINK|SFF_CREAT|SFF_MUSTOWN;
# endif /* 0 */

		at = colon;
		len = strlen(colon) + 1;
		if (len >= sizeof addr.sunix.sun_path)
		{
			errno = EINVAL;
			smi_log(SMI_LOG_ERR, "%s: UNIX socket name %s too long",
				name, colon);
			return INVALID_SOCKET;
		}
		(void) sm_strlcpy(addr.sunix.sun_path, colon,
				sizeof addr.sunix.sun_path);
# if 0
		errno = safefile(colon, RunAsUid, RunAsGid, RunAsUserName, sff,
				 S_IRUSR|S_IWUSR, NULL);

		/* if not safe, don't create */
		if (errno != 0)
		{
			smi_log(SMI_LOG_ERR,
				"%s: UNIX socket name %s unsafe",
				name, colon);
			return INVALID_SOCKET;
		}
# endif /* 0 */
	}
#endif /* NETUNIX */

#if NETINET || NETINET6
	if (
# if NETINET
	    addr.sa.sa_family == AF_INET
# endif /* NETINET */
# if NETINET && NETINET6
	    ||
# endif /* NETINET && NETINET6 */
# if NETINET6
	    addr.sa.sa_family == AF_INET6
# endif /* NETINET6 */
	   )
	{
		unsigned short port;

		/* Parse port@@host */
		at = strchr(colon, '@@');
		if (at == NULL)
		{
			switch (addr.sa.sa_family)
			{
# if NETINET
			  case AF_INET:
				addr.sin.sin_addr.s_addr = INADDR_ANY;
				break;
# endif /* NETINET */

# if NETINET6
			  case AF_INET6:
				addr.sin6.sin6_addr = in6addr_any;
				break;
# endif /* NETINET6 */
			}
		}
		else
			*at = '\0';

		if (isascii(*colon) && isdigit(*colon))
			port = htons((unsigned short) atoi(colon));
		else
		{
# ifdef NO_GETSERVBYNAME
			smi_log(SMI_LOG_ERR, "%s: invalid port number %s",
				name, colon);
			return INVALID_SOCKET;
# else /* NO_GETSERVBYNAME */
			register struct servent *sp;

			sp = getservbyname(colon, "tcp");
			if (sp == NULL)
			{
				smi_log(SMI_LOG_ERR,
					"%s: unknown port name %s",
					name, colon);
				return INVALID_SOCKET;
			}
			port = sp->s_port;
# endif /* NO_GETSERVBYNAME */
		}
		if (at != NULL)
		{
			*at++ = '@@';
			if (*at == '[')
			{
				char *end;

				end = strchr(at, ']');
				if (end != NULL)
				{
					bool found = false;
# if NETINET
					unsigned long hid = INADDR_NONE;
# endif /* NETINET */
# if NETINET6
					struct sockaddr_in6 hid6;
# endif /* NETINET6 */

					*end = '\0';
# if NETINET
					if (addr.sa.sa_family == AF_INET &&
					    (hid = inet_addr(&at[1])) != INADDR_NONE)
					{
						addr.sin.sin_addr.s_addr = hid;
						addr.sin.sin_port = port;
						found = true;
					}
# endif /* NETINET */
# if NETINET6
					(void) memset(&hid6, '\0', sizeof hid6);
					if (addr.sa.sa_family == AF_INET6 &&
					    mi_inet_pton(AF_INET6, &at[1],
							 &hid6.sin6_addr) == 1)
					{
						addr.sin6.sin6_addr = hid6.sin6_addr;
						addr.sin6.sin6_port = port;
						found = true;
					}
# endif /* NETINET6 */
					*end = ']';
					if (!found)
					{
						smi_log(SMI_LOG_ERR,
							"%s: Invalid numeric domain spec \"%s\"",
							name, at);
						return INVALID_SOCKET;
					}
				}
				else
				{
					smi_log(SMI_LOG_ERR,
						"%s: Invalid numeric domain spec \"%s\"",
						name, at);
					return INVALID_SOCKET;
				}
			}
			else
			{
				struct hostent *hp = NULL;

				hp = mi_gethostbyname(at, addr.sa.sa_family);
				if (hp == NULL)
				{
					smi_log(SMI_LOG_ERR,
						"%s: Unknown host name %s",
						name, at);
					return INVALID_SOCKET;
				}
				addr.sa.sa_family = hp->h_addrtype;
				switch (hp->h_addrtype)
				{
# if NETINET
				  case AF_INET:
					(void) memmove(&addr.sin.sin_addr,
						       hp->h_addr,
						       INADDRSZ);
					addr.sin.sin_port = port;
					break;
# endif /* NETINET */

# if NETINET6
				  case AF_INET6:
					(void) memmove(&addr.sin6.sin6_addr,
						       hp->h_addr,
						       IN6ADDRSZ);
					addr.sin6.sin6_port = port;
					break;
# endif /* NETINET6 */

				  default:
					smi_log(SMI_LOG_ERR,
						"%s: Unknown protocol for %s (%d)",
						name, at, hp->h_addrtype);
					return INVALID_SOCKET;
				}
# if NETINET6
				freehostent(hp);
# endif /* NETINET6 */
			}
		}
		else
		{
			switch (addr.sa.sa_family)
			{
# if NETINET
			  case AF_INET:
				addr.sin.sin_port = port;
				break;
# endif /* NETINET */
# if NETINET6
			  case AF_INET6:
				addr.sin6.sin6_port = port;
				break;
# endif /* NETINET6 */
			}
		}
	}
#endif /* NETINET || NETINET6 */

	sock = socket(addr.sa.sa_family, SOCK_STREAM, 0);
	if (!ValidSocket(sock))
	{
		smi_log(SMI_LOG_ERR,
			"%s: Unable to create new socket: %s",
			name, sm_errstring(errno));
		return INVALID_SOCKET;
	}

	if ((fdflags = fcntl(sock, F_GETFD, 0)) == -1 ||
	    fcntl(sock, F_SETFD, fdflags | FD_CLOEXEC) == -1)
	{
		smi_log(SMI_LOG_ERR,
			"%s: Unable to set close-on-exec: %s", name,
			sm_errstring(errno));
		(void) closesocket(sock);
		return INVALID_SOCKET;
	}

	if (
#if NETUNIX
	    addr.sa.sa_family != AF_UNIX &&
#endif /* NETUNIX */
	    setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void *) &sockopt,
		       sizeof(sockopt)) == -1)
	{
		smi_log(SMI_LOG_ERR,
			"%s: set reuseaddr failed (%s)", name,
			sm_errstring(errno));
		(void) closesocket(sock);
		return INVALID_SOCKET;
	}

#if NETUNIX
	if (addr.sa.sa_family == AF_UNIX && rmsocket)
	{
		struct stat s;

		if (stat(colon, &s) != 0)
		{
			if (errno != ENOENT)
			{
				smi_log(SMI_LOG_ERR,
					"%s: Unable to stat() %s: %s",
					name, colon, sm_errstring(errno));
				(void) closesocket(sock);
				return INVALID_SOCKET;
			}
		}
		else if (!S_ISSOCK(s.st_mode))
		{
			smi_log(SMI_LOG_ERR,
				"%s: %s is not a UNIX domain socket",
				name, colon);
			(void) closesocket(sock);
			return INVALID_SOCKET;
		}
		else if (unlink(colon) != 0)
		{
			smi_log(SMI_LOG_ERR,
				"%s: Unable to remove %s: %s",
				name, colon, sm_errstring(errno));
			(void) closesocket(sock);
			return INVALID_SOCKET;
		}
	}
#endif /* NETUNIX */

	if (bind(sock, &addr.sa, L_socksize) < 0)
	{
		smi_log(SMI_LOG_ERR,
			"%s: Unable to bind to port %s: %s",
			name, conn, sm_errstring(errno));
		(void) closesocket(sock);
		return INVALID_SOCKET;
	}

	if (listen(sock, backlog) < 0)
	{
		smi_log(SMI_LOG_ERR,
			"%s: listen call failed: %s", name,
			sm_errstring(errno));
		(void) closesocket(sock);
		return INVALID_SOCKET;
	}

#if NETUNIX
	if (addr.sa.sa_family == AF_UNIX && len > 0)
	{
		/*
		**  Set global variable sockpath so the UNIX socket can be
		**  unlink()ed at exit.
		*/

		sockpath = (char *) malloc(len);
		if (sockpath != NULL)
			(void) sm_strlcpy(sockpath, colon, len);
		else
		{
			smi_log(SMI_LOG_ERR,
				"%s: can't malloc(%d) for sockpath: %s",
				name, (int) len, sm_errstring(errno));
			(void) closesocket(sock);
			return INVALID_SOCKET;
		}
	}
#endif /* NETUNIX */
	L_family = addr.sa.sa_family;
	return sock;
}

#if !_FFR_WORKERS_POOL
/*
**  MI_THREAD_HANDLE_WRAPPER -- small wrapper to handle session
**
**	Parameters:
**		arg -- argument to pass to mi_handle_session()
**
**	Returns:
**		results from mi_handle_session()
*/

static void *
mi_thread_handle_wrapper(arg)
	void *arg;
{
	/*
	**  Note: on some systems this generates a compiler warning:
	**  cast to pointer from integer of different size
	**  You can safely ignore this warning as the result of this function
	**  is not used anywhere.
	*/

	return (void *) mi_handle_session(arg);
}
#endif /* _FFR_WORKERS_POOL */

/*
**  MI_CLOSENER -- close listen socket
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
*/

void
mi_closener()
{
	(void) smutex_lock(&L_Mutex);
	if (ValidSocket(listenfd))
	{
#if NETUNIX
		bool removable;
		struct stat sockinfo;
		struct stat fileinfo;

		removable = sockpath != NULL &&
			    geteuid() != 0 &&
			    fstat(listenfd, &sockinfo) == 0 &&
			    (S_ISFIFO(sockinfo.st_mode)
# ifdef S_ISSOCK
			     || S_ISSOCK(sockinfo.st_mode)
# endif /* S_ISSOCK */
			    );
#endif /* NETUNIX */

		(void) closesocket(listenfd);
		listenfd = INVALID_SOCKET;

#if NETUNIX
		/* XXX sleep() some time before doing this? */
		if (sockpath != NULL)
		{
			if (removable &&
			    stat(sockpath, &fileinfo) == 0 &&
			    ((fileinfo.st_dev == sockinfo.st_dev &&
			      fileinfo.st_ino == sockinfo.st_ino)
# ifdef S_ISSOCK
			     || S_ISSOCK(fileinfo.st_mode)
# endif /* S_ISSOCK */
			    )
			    &&
			    (S_ISFIFO(fileinfo.st_mode)
# ifdef S_ISSOCK
			     || S_ISSOCK(fileinfo.st_mode)
# endif /* S_ISSOCK */
			     ))
				(void) unlink(sockpath);
			free(sockpath);
			sockpath = NULL;
		}
#endif /* NETUNIX */
	}
	(void) smutex_unlock(&L_Mutex);
}

/*
**  MI_LISTENER -- Generic listener harness
**
**	Open up listen port
**	Wait for connections
**
**	Parameters:
**		conn -- connection description
**		dbg -- debug level
**		smfi -- filter structure to use
**		timeout -- timeout for reads/writes
**		backlog -- listen queue backlog size
**
**	Returns:
**		MI_SUCCESS -- Exited normally
**			   (session finished or we were told to exit)
**		MI_FAILURE -- Network initialization failed.
*/

#if BROKEN_PTHREAD_SLEEP

/*
**  Solaris 2.6, perhaps others, gets an internal threads library panic
**  when sleep() is used:
**
**  thread_create() failed, returned 11 (EINVAL)
**  co_enable, thr_create() returned error = 24
**  libthread panic: co_enable failed (PID: 17793 LWP 1)
**  stacktrace:
**	ef526b10
**	ef52646c
**	ef534cbc
**	156a4
**	14644
**	1413c
**	135e0
**	0
*/

# define MI_SLEEP(s)							\
{									\
	int rs = 0;							\
	struct timeval st;						\
									\
	st.tv_sec = (s);						\
	st.tv_usec = 0;							\
	if (st.tv_sec > 0)						\
	{								\
		for (;;)						\
		{							\
			rs = select(0, NULL, NULL, NULL, &st);		\
			if (rs < 0 && errno == EINTR)			\
				continue;				\
			if (rs != 0)					\
			{						\
				smi_log(SMI_LOG_ERR,			\
					"MI_SLEEP(): select() returned non-zero result %d, errno = %d",	\
					rs, errno);			\
			}						\
			break;						\
		}							\
	}								\
}
#else /* BROKEN_PTHREAD_SLEEP */
# define MI_SLEEP(s)	sleep((s))
#endif /* BROKEN_PTHREAD_SLEEP */

int
mi_listener(conn, dbg, smfi, timeout, backlog)
	char *conn;
	int dbg;
	smfiDesc_ptr smfi;
	time_t timeout;
	int backlog;
{
	socket_t connfd = INVALID_SOCKET;
#if _FFR_DUP_FD
	socket_t dupfd = INVALID_SOCKET;
#endif /* _FFR_DUP_FD */
	int sockopt = 1;
	int r, mistop;
	int ret = MI_SUCCESS;
	int mcnt = 0;	/* error count for malloc() failures */
	int tcnt = 0;	/* error count for thread_create() failures */
	int acnt = 0;	/* error count for accept() failures */
	int scnt = 0;	/* error count for select() failures */
	int save_errno = 0;
#if !_FFR_WORKERS_POOL
	sthread_t thread_id;
#endif /* !_FFR_WORKERS_POOL */
	_SOCK_ADDR cliaddr;
	SOCKADDR_LEN_T clilen;
	SMFICTX_PTR ctx;
	FD_RD_VAR(rds, excs);
	struct timeval chktime;

	if (mi_opensocket(conn, backlog, dbg, false, smfi) == MI_FAILURE)
		return MI_FAILURE;

#if _FFR_WORKERS_POOL
	if (mi_pool_controller_init() == MI_FAILURE)
		return MI_FAILURE;
#endif /* _FFR_WORKERS_POOL */

	clilen = L_socksize;
	while ((mistop = mi_stop()) == MILTER_CONT)
	{
		(void) smutex_lock(&L_Mutex);
		if (!ValidSocket(listenfd))
		{
			ret = MI_FAILURE;
			smi_log(SMI_LOG_ERR,
				"%s: listenfd=%d corrupted, terminating, errno=%d",
				smfi->xxfi_name, listenfd, errno);
			(void) smutex_unlock(&L_Mutex);
			break;
		}

		/* select on interface ports */
		FD_RD_INIT(listenfd, rds, excs);
		chktime.tv_sec = MI_CHK_TIME;
		chktime.tv_usec = 0;
		r = FD_RD_READY(listenfd, rds, excs, &chktime);
		if (r == 0)		/* timeout */
		{
			(void) smutex_unlock(&L_Mutex);
			continue;	/* just check mi_stop() */
		}
		if (r < 0)
		{
			save_errno = errno;
			(void) smutex_unlock(&L_Mutex);
			if (save_errno == EINTR)
				continue;
			scnt++;
			smi_log(SMI_LOG_ERR,
				"%s: %s() failed (%s), %s",
				smfi->xxfi_name, MI_POLLSELECT,
				sm_errstring(save_errno),
				scnt >= MAX_FAILS_S ? "abort" : "try again");
			MI_SLEEP(scnt);
			if (scnt >= MAX_FAILS_S)
			{
				ret = MI_FAILURE;
				break;
			}
			continue;
		}
		if (!FD_IS_RD_RDY(listenfd, rds, excs))
		{
			/* some error: just stop for now... */
			ret = MI_FAILURE;
			(void) smutex_unlock(&L_Mutex);
			smi_log(SMI_LOG_ERR,
				"%s: %s() returned exception for socket, abort",
				smfi->xxfi_name, MI_POLLSELECT);
			break;
		}
		scnt = 0;	/* reset error counter for select() */

		(void) memset(&cliaddr, '\0', sizeof cliaddr);
		connfd = accept(listenfd, (struct sockaddr *) &cliaddr,
				&clilen);
		save_errno = errno;
		(void) smutex_unlock(&L_Mutex);

		/*
		**  If remote side closes before accept() finishes,
		**  sockaddr might not be fully filled in.
		*/

		if (ValidSocket(connfd) &&
		    (clilen == 0 ||
# ifdef BSD4_4_SOCKADDR
		     cliaddr.sa.sa_len == 0 ||
# endif /* BSD4_4_SOCKADDR */
		     cliaddr.sa.sa_family != L_family))
		{
			(void) closesocket(connfd);
			connfd = INVALID_SOCKET;
			save_errno = EINVAL;
		}

		/* check if acceptable for select() */
		if (ValidSocket(connfd) && !SM_FD_OK_SELECT(connfd))
		{
			(void) closesocket(connfd);
			connfd = INVALID_SOCKET;
			save_errno = ERANGE;
		}

		if (!ValidSocket(connfd))
		{
			if (save_errno == EINTR
#ifdef EAGAIN
			    || save_errno == EAGAIN
#endif /* EAGAIN */
#ifdef ECONNABORTED
			    || save_errno == ECONNABORTED
#endif /* ECONNABORTED */
#ifdef EMFILE
			    || save_errno == EMFILE
#endif /* EMFILE */
#ifdef ENFILE
			    || save_errno == ENFILE
#endif /* ENFILE */
#ifdef ENOBUFS
			    || save_errno == ENOBUFS
#endif /* ENOBUFS */
#ifdef ENOMEM
			    || save_errno == ENOMEM
#endif /* ENOMEM */
#ifdef ENOSR
			    || save_errno == ENOSR
#endif /* ENOSR */
#ifdef EWOULDBLOCK
			    || save_errno == EWOULDBLOCK
#endif /* EWOULDBLOCK */
			   )
				continue;
			acnt++;
			smi_log(SMI_LOG_ERR,
				"%s: accept() returned invalid socket (%s), %s",
				smfi->xxfi_name, sm_errstring(save_errno),
				acnt >= MAX_FAILS_A ? "abort" : "try again");
			MI_SLEEP(acnt);
			if (acnt >= MAX_FAILS_A)
			{
				ret = MI_FAILURE;
				break;
			}
			continue;
		}
		acnt = 0;	/* reset error counter for accept() */
#if _FFR_DUP_FD
		dupfd = fcntl(connfd, F_DUPFD, 256);
		if (ValidSocket(dupfd) && SM_FD_OK_SELECT(dupfd))
		{
			close(connfd);
			connfd = dupfd;
			dupfd = INVALID_SOCKET;
		}
#endif /* _FFR_DUP_FD */

		if (setsockopt(connfd, SOL_SOCKET, SO_KEEPALIVE,
				(void *) &sockopt, sizeof sockopt) < 0)
		{
			smi_log(SMI_LOG_WARN,
				"%s: set keepalive failed (%s)",
				smfi->xxfi_name, sm_errstring(errno));
			/* XXX: continue? */
		}
		if ((ctx = (SMFICTX_PTR) malloc(sizeof *ctx)) == NULL)
		{
			(void) closesocket(connfd);
			mcnt++;
			smi_log(SMI_LOG_ERR, "%s: malloc(ctx) failed (%s), %s",
				smfi->xxfi_name, sm_errstring(save_errno),
				mcnt >= MAX_FAILS_M ? "abort" : "try again");
			MI_SLEEP(mcnt);
			if (mcnt >= MAX_FAILS_M)
			{
				ret = MI_FAILURE;
				break;
			}
			continue;
		}
		mcnt = 0;	/* reset error counter for malloc() */
		(void) memset(ctx, '\0', sizeof *ctx);
		ctx->ctx_sd = connfd;
		ctx->ctx_dbg = dbg;
		ctx->ctx_timeout = timeout;
		ctx->ctx_smfi = smfi;
		if (smfi->xxfi_connect == NULL)
			ctx->ctx_pflags |= SMFIP_NOCONNECT;
		if (smfi->xxfi_helo == NULL)
			ctx->ctx_pflags |= SMFIP_NOHELO;
		if (smfi->xxfi_envfrom == NULL)
			ctx->ctx_pflags |= SMFIP_NOMAIL;
		if (smfi->xxfi_envrcpt == NULL)
			ctx->ctx_pflags |= SMFIP_NORCPT;
		if (smfi->xxfi_header == NULL)
			ctx->ctx_pflags |= SMFIP_NOHDRS;
		if (smfi->xxfi_eoh == NULL)
			ctx->ctx_pflags |= SMFIP_NOEOH;
		if (smfi->xxfi_body == NULL)
			ctx->ctx_pflags |= SMFIP_NOBODY;
		if (smfi->xxfi_version <= 3 || smfi->xxfi_data == NULL)
			ctx->ctx_pflags |= SMFIP_NODATA;
		if (smfi->xxfi_version <= 2 || smfi->xxfi_unknown == NULL)
			ctx->ctx_pflags |= SMFIP_NOUNKNOWN;

#if _FFR_WORKERS_POOL
# define LOG_CRT_FAIL	"%s: mi_start_session() failed: %d, %s"
		if ((r = mi_start_session(ctx)) != MI_SUCCESS)
#else /* _FFR_WORKERS_POOL */
# define LOG_CRT_FAIL	"%s: thread_create() failed: %d, %s"
		if ((r = thread_create(&thread_id,
					mi_thread_handle_wrapper,
					(void *) ctx)) != 0)
#endif /* _FFR_WORKERS_POOL */
		{
			tcnt++;
			smi_log(SMI_LOG_ERR,
				LOG_CRT_FAIL,
				smfi->xxfi_name,  r,
				tcnt >= MAX_FAILS_T ? "abort" : "try again");
			MI_SLEEP(tcnt);
			(void) closesocket(connfd);
			free(ctx);
			if (tcnt >= MAX_FAILS_T)
			{
				ret = MI_FAILURE;
				break;
			}
			continue;
		}
		tcnt = 0;
	}
	if (ret != MI_SUCCESS)
		mi_stop_milters(MILTER_ABRT);
	else
	{
		if (mistop != MILTER_CONT)
			smi_log(SMI_LOG_INFO, "%s: mi_stop=%d",
				smfi->xxfi_name, mistop);
		mi_closener();
	}
	(void) smutex_destroy(&L_Mutex);
	return ret;
}
@


1.4
log
@merge newer sendmail; fix and correct; reduce upstream diffs; prep for deb
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2007 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Id: listener.c,v 8.126 2009/12/16 16:40:23 ca Exp $")
@


1.3
log
@merge and reduce diffs against upstream
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: listener.c,v 8.124 2007/04/23 22:22:50 ca Exp $")
d780 3
a782 2
				"%s: select() failed (%s), %s",
				smfi->xxfi_name, sm_errstring(save_errno),
@


1.2
log
@upgrade from sendmail 8.14.1 to 8.14.2 ourselves:
> From donotreply@@lists.sendmail.org Fri Nov  2 02:46:04 2007
> From: Claus Assmann <donotreply@@lists.sendmail.org>
Message-ID: <200711020234.lA22YPul046763@@lists.sendmail.org>
To: sendmail-announce@@sendmail.org
Date: Thu, 1 Nov 2007 19:34:25 -0700 (PDT)
Subject: sendmail 8.14.2 available

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Sendmail, Inc., and the Sendmail Consortium announce the availability
of sendmail 8.14.2 which fixes some problems, e.g.,

- - an important bug in the milter function smfi_chgfrom() which could
  cause the loss of a message body.
- - the handling of queued messages with 8 bit characters in From:
  or To: header which could be "mistaken" for internal control
  characters during a queue run and trigger various consistency checks.
- - the handling of lines longer than MAXLINE-1 characters in certain
  cases.

A complete list of changes can be found in the release notes (see
below).

Please send bug reports and general feedback to one of the addresses
listed at: http://www.sendmail.org/email-addresses.html

The version can be found at

ftp://ftp.sendmail.org/pub/sendmail/sendmail.8.14.2.tar.gz
ftp://ftp.sendmail.org/pub/sendmail/sendmail.8.14.2.tar.gz.sig
ftp://ftp.sendmail.org/pub/sendmail/sendmail.8.14.2.tar.Z
ftp://ftp.sendmail.org/pub/sendmail/sendmail.8.14.2.tar.Z.sig

MD5 signatures:
cf784b9f20c32949ae1f38f3eae29875 sendmail.8.14.2.tar.Z
f788d6986f12a81ac958195b045a529d sendmail.8.14.2.tar.Z.sig
1c1472365344ca8061d6453c43c9a831 sendmail.8.14.2.tar.gz
2ae4b6175a08e8a6cda992db20141d81 sendmail.8.14.2.tar.gz.sig

You either need the first two files or the third and fourth, i.e.,
the gzip'ed version or the compressed version and the corresponding
sig file.  The PGP signature was created using the Sendmail Signing
Key/2007, available on the web site (http://www.sendmail.org/) or
on the public key servers.

Since sendmail 8.11 and later includes hooks to cryptography, the
following information from OpenSSL applies to sendmail as well.

   PLEASE REMEMBER THAT EXPORT/IMPORT AND/OR USE OF STRONG CRYPTOGRAPHY
   SOFTWARE, PROVIDING CRYPTOGRAPHY HOOKS OR EVEN JUST COMMUNICATING
   TECHNICAL DETAILS ABOUT CRYPTOGRAPHY SOFTWARE IS ILLEGAL IN SOME
   PARTS OF THE WORLD.  SO, WHEN YOU IMPORT THIS PACKAGE TO YOUR
   COUNTRY, RE-DISTRIBUTE IT FROM THERE OR EVEN JUST EMAIL TECHNICAL
   SUGGESTIONS OR EVEN SOURCE PATCHES TO THE AUTHOR OR OTHER PEOPLE
   YOU ARE STRONGLY ADVISED TO PAY CLOSE ATTENTION TO ANY EXPORT/IMPORT
   AND/OR USE LAWS WHICH APPLY TO YOU. THE AUTHORS ARE NOT LIABLE FOR
   ANY VIOLATIONS YOU MAKE HERE. SO BE CAREFUL, IT IS YOUR RESPONSIBILITY.


			SENDMAIL RELEASE NOTES
      $Id: RELEASE_NOTES,v 8.1909 2007/10/31 16:04:13 ca Exp $


This listing shows the version of the sendmail binary, the version
of the sendmail configuration files, the date of release, and a
summary of the changes in that release.

8.14.2/8.14.2	2007/11/01
	If a message was queued and it contained 8 bit characters in
		a From: or To: header, then those characters could be
		"mistaken" for internal control characters during a queue
		run and trigger various consistency checks.  Problem
		noted by Neil Rickert of Northern Illinois University.
	If MaxMimeHeaderLength is set to a value greater than 0 (which
		it is by default) then even if the Linelimit parameter
		is 0, sendmail corrupted in the non-transfer-encoding
		case every MAXLINE-1 characters.  Patch from John Gardiner
		Myers of Proofpoint.
	Setting the suboption DeliveryMode for DaemonPortOptions did not
		work in earlier 8.14 versions.
	Note: DeliveryMode=interactive is silently converted to
		background if a milter can reject or delete a recipient.
		Prior to 8.14 this happened only if milter could delete
		recipients.
	ClientRate should trigger when the limit was exceeded (as
		documented), not when it was reached.  Patch from
		John Beck of Sun Microsystems.
	Force a queue run for -qGqueuegroup even if no runners are
		specified (R=0) and forking (F=f) is requested.
	When multiple results are requested for a DNS map lookup
		(-z and -Z), return only those that are relevant for
		the query (not also those in the "additional section".)
	If the message transfer time to sendmail (when acting as server)
		exceeds Timeout.queuewarn or Timeout.queuereturn and
		the message is refused (by a milter), sendmail previously
		created a delivery status notification (DSN).  Patch
		from Doug Heath of The Hertz Corporation.
	A code change in Cyrus-SASL 2.1.22 for sasl_decode64() requires
		the MTA to deal with some input (i.e., "=") itself.
		Problem noted by Eliot Lear.
	sendmail counted a delivery as successful if PIPELINING is
		compiled in but not offered by the server and the
		delivery failed temporarily.  Patch from Werner Wiethege.
	If getting the result of an LDAP query times out then close the
		map so it will be reopened on the next lookup.  This
		should help "failover" configurations that specify more
		than one LDAP server.
	If check_compat returns $#discard then a "savemail panic" could
		be triggered under some circumstances (e.g., requiring
		a system which does not have the compile time flag
		HASFLOCK set). Based on patch by Motonori Nakamura
		of National Institute of Informatics, Japan.
	If a milter rejected a recipient, the count for nrcpts= in the
		logfile entry might have been wrong.  Problem found by
		Petra Humann of TU Dresden.
	If a milter invoked smfi_chgfrom() where ESMTP arguments are not
		NULL, the message body was lost.  Patch from Motonori
		Nakamura of National Institute of Informatics, Japan.
	sendmail(8) had a bogus space in -qGname.  Patch from Peng Haitao.
	CONTRIB: buildvirtuser: Preserve ownership and permissions when
		replacing files.
	CONTRIB: buildvirtuser: Skip dot-files (e.g., .cvsignore) when
		reading the /etc/mail/virtusers/ directory.
	CONTRIB: buildvirtuser: Emit warnings instead of exiting where
		appropriate.
	LIBMILTER: Fix ABI backwards compatibility so milters compiled
		against an older libmilter.so shared library can use an
		8.14 libmilter.so shared library.
	LIBMILTER: smfi_version() did not properly extract the patchlevel
		from the version number, however, the returned value was
		correct for the current libmilter version.

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.5 (OpenBSD)

iQCVAwUBRyqEOs8etQMiMnoBAQKNdQP/cQKfjVP7qTi0Ol/OgR7AnvCaerCxiQ5J
y1uxjwXs2s+RemX0u5a4c0agoLscTKU5Ot6uzOdvKvZd0/unr/IkzuXZBF9LsnlZ
X1wS4GXQDXKDfazvwdwOUgxkthMZU1TiVFj/GH5TOfHqVUO5Ho/yRfAQoAn3taFc
5jeg+A3+M9M=
=DJHS
-----END PGP SIGNATURE-----
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: listener.c,v 8.122 2006/11/02 17:54:44 ca Exp $")
@


1.2.2.1
log
@MFC sendmail update to 8.14.3

agreed bsiegert@@
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: listener.c,v 8.124 2007/04/23 22:22:50 ca Exp $")
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2004 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: listener.c,v 8.111 2004/09/20 21:11:15 msk Exp $")
d28 4
d39 1
d41 1
a88 1
#if !SM_CONF_POLL
a95 1
#endif /* !SM_CONF_POLL */
d465 5
a469 1
	if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void *) &sockopt,
d473 1
a473 1
			"%s: Unable to setsockopt: %s", name,
d556 2
d572 7
d581 1
a585 3
**	NOTE: It is assumed that this function is called from a
**	      function that has a mutex lock (currently mi_stop_milters()).
**
d731 1
d733 1
d743 5
d810 2
a811 3
		**  If remote side closes before
		**  accept() finishes, sockaddr
		**  might not be fully filled in.
a825 1
#if !SM_CONF_POLL
a832 1
#endif /* !SM_CONF_POLL */
d879 1
a879 5
		if (ValidSocket(dupfd)
# if !SM_CONF_POLL
		    && SM_FD_OK_SELECT(dupfd)
# endif /* !SM_CONF_POLL */
		   )
d890 2
a891 1
			smi_log(SMI_LOG_WARN, "%s: setsockopt() failed (%s)",
a915 6
#if 0
		if (smfi->xxfi_eoh == NULL)
		if (smfi->xxfi_eom == NULL)
		if (smfi->xxfi_abort == NULL)
		if (smfi->xxfi_close == NULL)
#endif /* 0 */
d930 10
a939 1

d943 1
d947 1
a947 1
				"%s: thread_create() failed: %d, %s",
@


1.1.127.1
log
@Import Sendmail 8.14.3, suitably stripped down by the not yet committed
contrib/samples/import-3rdpty,v 1.35; we have some new and renamed files
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2007 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Id: listener.c,v 8.124 2007/04/23 22:22:50 ca Exp $")
a27 4
# if SM_CONF_POLL
#  undef SM_FD_OK_SELECT
#  define SM_FD_OK_SELECT(fd)		true
# endif /* SM_CONF_POLL */
a34 1
#if !_FFR_WORKERS_POOL
a35 1
#endif /* !_FFR_WORKERS_POOL */
d83 1
d91 1
d461 1
a461 5
	if (
#if NETUNIX
	    addr.sa.sa_family != AF_UNIX &&
#endif /* NETUNIX */
	    setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void *) &sockopt,
d465 1
a465 1
			"%s: set reuseaddr failed (%s)", name,
a547 2

#if !_FFR_WORKERS_POOL
a561 7
	/*
	**  Note: on some systems this generates a compiler warning:
	**  cast to pointer from integer of different size
	**  You can safely ignore this warning as the result of this function
	**  is not used anywhere.
	*/

a563 1
#endif /* _FFR_WORKERS_POOL */
d568 3
a715 1
#if !_FFR_WORKERS_POOL
a716 1
#endif /* !_FFR_WORKERS_POOL */
a725 5
#if _FFR_WORKERS_POOL
	if (mi_pool_controller_init() == MI_FAILURE)
		return MI_FAILURE;
#endif /* _FFR_WORKERS_POOL */

d788 3
a790 2
		**  If remote side closes before accept() finishes,
		**  sockaddr might not be fully filled in.
d805 1
d813 1
d860 5
a864 1
		if (ValidSocket(dupfd) && SM_FD_OK_SELECT(dupfd))
d875 1
a875 2
			smi_log(SMI_LOG_WARN,
				"%s: set keepalive failed (%s)",
d900 6
d920 1
a920 10
		if (smfi->xxfi_version <= 3 || smfi->xxfi_data == NULL)
			ctx->ctx_pflags |= SMFIP_NODATA;
		if (smfi->xxfi_version <= 2 || smfi->xxfi_unknown == NULL)
			ctx->ctx_pflags |= SMFIP_NOUNKNOWN;

#if _FFR_WORKERS_POOL
# define LOG_CRT_FAIL	"%s: mi_start_session() failed: %d, %s"
		if ((r = mi_start_session(ctx)) != MI_SUCCESS)
#else /* _FFR_WORKERS_POOL */
# define LOG_CRT_FAIL	"%s: thread_create() failed: %d, %s"
a923 1
#endif /* _FFR_WORKERS_POOL */
d927 1
a927 1
				LOG_CRT_FAIL,
@


1.1.127.2
log
@Import sendmail.8.14.5.Beta0.tar.gz
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Id: listener.c,v 8.126 2009/12/16 16:40:23 ca Exp $")
d780 2
a781 3
				"%s: %s() failed (%s), %s",
				smfi->xxfi_name, MI_POLLSELECT,
				sm_errstring(save_errno),
@


1.1.127.3
log
@Import sendmail 8.14.9
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2007 Proofpoint, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Id: listener.c,v 8.127 2013-11-22 20:51:36 ca Exp $")
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.1.2.1
log
@MFC most of the recent sendmail updates to MirOS #8-stable
agreed bsiegert@@

This also changes the LOCALBASE stuff, links libmilter not
against LDAP, etc. but doesn't install the FreeBSD 6 confs
nor a shared libmilter in order to pass a no-files-diff:

tg@@maou:/usr/src/gnu/usr.sbin/sendmail $ sudo find / -ls | sort -k11 >~/x1
tg@@maou:/usr/src/gnu/usr.sbin/sendmail $ sudo make install
tg@@maou:/usr/src/gnu/usr.sbin/sendmail/cf/cf $ sudo make distribution
tg@@maou:/usr/src/gnu/usr.sbin/sendmail/cf/cf $ sudo find / -ls | sort -k11 | diff -u ~/x1 - | less

Note: files in /etc/mail/ are also changed, this affects the etc8.ngz set
on fresh installs and cannot(!) be automatically upgraded!
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2006 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: listener.c,v 8.115 2006/01/24 00:48:39 ca Exp $")
d461 1
a461 5
	if (
#if NETUNIX
	    addr.sa.sa_family != AF_UNIX &&
#endif /* NETUNIX */
	    setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void *) &sockopt,
d465 1
a465 1
			"%s: set reuseaddr failed (%s)", name,
d568 3
d875 1
a875 2
			smi_log(SMI_LOG_WARN,
				"%s: set keepalive failed (%s)",
@


1.1.1.2
log
@Update to Sendmail 8.13.6
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2006 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: listener.c,v 8.115 2006/01/24 00:48:39 ca Exp $")
d461 1
a461 5
	if (
#if NETUNIX
	    addr.sa.sa_family != AF_UNIX &&
#endif /* NETUNIX */
	    setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void *) &sockopt,
d465 1
a465 1
			"%s: set reuseaddr failed (%s)", name,
d568 3
d875 1
a875 2
			smi_log(SMI_LOG_WARN,
				"%s: set keepalive failed (%s)",
@


1.1.1.3
log
@Import Sendmail 8.14.0 via OpenBSD
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: listener.c,v 8.122 2006/11/02 17:54:44 ca Exp $")
a27 4
# if SM_CONF_POLL
#  undef SM_FD_OK_SELECT
#  define SM_FD_OK_SELECT(fd)		true
# endif /* SM_CONF_POLL */
a34 1
#if !_FFR_WORKERS_POOL
a35 1
#endif /* !_FFR_WORKERS_POOL */
d83 1
d91 1
a551 2

#if !_FFR_WORKERS_POOL
a565 7
	/*
	**  Note: on some systems this generates a compiler warning:
	**  cast to pointer from integer of different size
	**  You can safely ignore this warning as the result of this function
	**  is not used anywhere.
	*/

a567 1
#endif /* _FFR_WORKERS_POOL */
a716 1
#if !_FFR_WORKERS_POOL
a717 1
#endif /* !_FFR_WORKERS_POOL */
a726 5
#if _FFR_WORKERS_POOL
	if (mi_pool_controller_init() == MI_FAILURE)
		return MI_FAILURE;
#endif /* _FFR_WORKERS_POOL */

d789 3
a791 2
		**  If remote side closes before accept() finishes,
		**  sockaddr might not be fully filled in.
d806 1
d814 1
d861 5
a865 1
		if (ValidSocket(dupfd) && SM_FD_OK_SELECT(dupfd))
d902 6
d922 1
a922 10
		if (smfi->xxfi_data == NULL)
			ctx->ctx_pflags |= SMFIP_NODATA;
		if (smfi->xxfi_unknown == NULL)
			ctx->ctx_pflags |= SMFIP_NOUNKNOWN;

#if _FFR_WORKERS_POOL
# define LOG_CRT_FAIL	"%s: mi_start_session() failed: %d, %s"
		if ((r = mi_start_session(ctx)) != MI_SUCCESS)
#else /* _FFR_WORKERS_POOL */
# define LOG_CRT_FAIL	"%s: thread_create() failed: %d, %s"
a925 1
#endif /* _FFR_WORKERS_POOL */
d929 1
a929 1
				LOG_CRT_FAIL,
@


1.1.1.4
log
@OpenBSD finally has upgraded their sendmail, too…
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2007 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: listener.c,v 8.124 2007/04/23 22:22:50 ca Exp $")
d930 1
a930 1
		if (smfi->xxfi_version <= 3 || smfi->xxfi_data == NULL)
d932 1
a932 1
		if (smfi->xxfi_version <= 2 || smfi->xxfi_unknown == NULL)
@


1.1.1.5
log
@Replace “$Sendmail: ” with “$Id: ” (the latter is used by upstream)
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Id: listener.c,v 8.124 2007/04/23 22:22:50 ca Exp $")
@


1.1.1.6
log
@Import OpenBSD’s sendmail 8.14.5, RCS IDs properly sedded back
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Id: listener.c,v 8.126 2009/12/16 16:40:23 ca Exp $")
d780 2
a781 3
				"%s: %s() failed (%s), %s",
				smfi->xxfi_name, MI_POLLSELECT,
				sm_errstring(save_errno),
@


