head	1.5;
access;
symbols
	sendmail-8_14_9:1.1.127.2
	sendmail-8_14_7:1.1.127.1
	sendmail-8_14_6:1.1.127.1
	sendmail-8_14_5-ERRATA-1:1.1.127.1
	mbsd-20101220_mergebase:1.1.1.4.2.1
	sendmail-8_14_5:1.1.127.1
	cvs-201107021500:1.1.1.5
	cvs-20101220:1.1.1.5
	mbsd-20101220:1.1.1.4.0.2
	cvs-201012191730:1.1.1.4
	sendmail-8_14_5_Beta0:1.1.127.1
	sendmail-8_14_3:1.1.127.1
	sendmail:1.1.127
	cvs-200812170000:1.1.1.4
	cvs-200805071200:1.1.1.4
	MIRBSD_10:1.2.0.2
	MIRBSD_10_BASE:1.2
	cvs-200803022030:1.1.1.3
	cvs-200707152000:1.1.1.3
	cvs-200704292000:1.1.1.3
	cvs-200702051700:1.1.1.3
	cvs-200609121900:1.1.1.2
	MIRBSD_9_BASE:1.1.1.2
	cvs-200606151800:1.1.1.2
	cvs-200603231300:1.1.1.2
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200507211800:1.1.1.1
	cvs-200504262050:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2014.06.09.15.17.15;	author tg;	state Exp;
branches;
next	1.4;
commitid	1005395CFC65E5646F1;

1.4
date	2011.07.02.15.03.41;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004E0F31C5496AB95F;

1.3
date	2008.05.07.13.15.21;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004821AB7510EE48FB;

1.2
date	2008.03.02.21.41.09;	author tg;	state Exp;
branches
	1.2.2.1;
next	1.1;
commitid	10047CB1EE51190ECAF;

1.1
date	2005.02.05.17.24.22;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.127.1;
next	;

1.2.2.1
date	2008.05.17.19.11.54;	author tg;	state Exp;
branches;
next	;
commitid	100482F2DC168C89AEA;

1.1.1.1
date	2005.02.05.17.24.22;	author tg;	state Exp;
branches
	1.1.1.1.2.1;
next	1.1.1.2;

1.1.1.2
date	2006.03.23.13.09.24;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	10044229DEA33D36552;

1.1.1.3
date	2007.02.05.17.05.48;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	10045C763C551AABAF7;

1.1.1.4
date	2008.05.07.12.31.47;	author tg;	state Exp;
branches
	1.1.1.4.2.1;
next	1.1.1.5;
commitid	1004821A13C1FC036E1;

1.1.1.5
date	2011.07.02.14.59.47;	author tg;	state Exp;
branches;
next	;
commitid	1004E0F31C5496AB95F;

1.1.1.1.2.1
date	2006.03.30.19.27.44;	author tg;	state Exp;
branches;
next	;
commitid	100442C309C7183FA09;

1.1.1.4.2.1
date	2011.07.02.15.02.09;	author tg;	state Exp;
branches;
next	;
commitid	1004E0F31C5496AB95F;

1.1.127.1
date	2010.12.19.14.45.52;	author tg;	state Exp;
branches;
next	1.1.127.2;
commitid	1004D0E1A94384778FD;

1.1.127.2
date	2014.06.09.14.29.24;	author tg;	state Exp;
branches;
next	;
commitid	1005395C4CC1A6DB9EE;


desc
@@


1.5
log
@merge
@
text
@/*
 *  Copyright (c) 1999-2007 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sm/gen.h>
SM_RCSID("@@(#)$Id: smfi.c,v 8.84 2013-11-22 20:51:36 ca Exp $")
#include <sm/varargs.h>
#include "libmilter.h"

static int smfi_header __P((SMFICTX *, int, int, char *, char *));
static int myisenhsc __P((const char *, int));

/* for smfi_set{ml}reply, let's be generous. 256/16 should be sufficient */
#define MAXREPLYLEN	980	/* max. length of a reply string */
#define MAXREPLIES	32	/* max. number of reply strings */

/*
**  SMFI_HEADER -- send a header to the MTA
**
**	Parameters:
**		ctx -- Opaque context structure
**		cmd -- Header modification command
**		hdridx -- Header index
**		headerf -- Header field name
**		headerv -- Header field value
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

static int
smfi_header(ctx, cmd, hdridx, headerf, headerv)
	SMFICTX *ctx;
	int cmd;
	int hdridx;
	char *headerf;
	char *headerv;
{
	size_t len, l1, l2, offset;
	int r;
	mi_int32 v;
	char *buf;
	struct timeval timeout;

	if (headerf == NULL || *headerf == '\0' || headerv == NULL)
		return MI_FAILURE;
	timeout.tv_sec = ctx->ctx_timeout;
	timeout.tv_usec = 0;
	l1 = strlen(headerf) + 1;
	l2 = strlen(headerv) + 1;
	len = l1 + l2;
	if (hdridx >= 0)
		len += MILTER_LEN_BYTES;
	buf = malloc(len);
	if (buf == NULL)
		return MI_FAILURE;
	offset = 0;
	if (hdridx >= 0)
	{
		v = htonl(hdridx);
		(void) memcpy(&(buf[0]), (void *) &v, MILTER_LEN_BYTES);
		offset += MILTER_LEN_BYTES;
	}
	(void) memcpy(buf + offset, headerf, l1);
	(void) memcpy(buf + offset + l1, headerv, l2);
	r = mi_wr_cmd(ctx->ctx_sd, &timeout, cmd, buf, len);
	free(buf);
	return r;
}

/*
**  SMFI_ADDHEADER -- send a new header to the MTA
**
**	Parameters:
**		ctx -- Opaque context structure
**		headerf -- Header field name
**		headerv -- Header field value
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_addheader(ctx, headerf, headerv)
	SMFICTX *ctx;
	char *headerf;
	char *headerv;
{
	if (!mi_sendok(ctx, SMFIF_ADDHDRS))
		return MI_FAILURE;

	return smfi_header(ctx, SMFIR_ADDHEADER, -1, headerf, headerv);
}

/*
**  SMFI_INSHEADER -- send a new header to the MTA (to be inserted)
**
**	Parameters:
**		ctx -- Opaque context structure
**  		hdridx -- index into header list where insertion should occur
**		headerf -- Header field name
**		headerv -- Header field value
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_insheader(ctx, hdridx, headerf, headerv)
	SMFICTX *ctx;
	int hdridx;
	char *headerf;
	char *headerv;
{
	if (!mi_sendok(ctx, SMFIF_ADDHDRS) || hdridx < 0)
		return MI_FAILURE;

	return smfi_header(ctx, SMFIR_INSHEADER, hdridx, headerf, headerv);
}

/*
**  SMFI_CHGHEADER -- send a changed header to the MTA
**
**	Parameters:
**		ctx -- Opaque context structure
**		headerf -- Header field name
**		hdridx -- Header index value
**		headerv -- Header field value
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_chgheader(ctx, headerf, hdridx, headerv)
	SMFICTX *ctx;
	char *headerf;
	mi_int32 hdridx;
	char *headerv;
{
	if (!mi_sendok(ctx, SMFIF_CHGHDRS) || hdridx < 0)
		return MI_FAILURE;
	if (headerv == NULL)
		headerv = "";

	return smfi_header(ctx, SMFIR_CHGHEADER, hdridx, headerf, headerv);
}

#if 0
/*
**  BUF_CRT_SEND -- construct buffer to send from arguments
**
**	Parameters:
**		ctx -- Opaque context structure
**		cmd -- command
**		arg0 -- first argument
**		argv -- list of arguments (NULL terminated)
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

static int
buf_crt_send __P((SMFICTX *, int cmd, char *, char **));

static int
buf_crt_send(ctx, cmd, arg0, argv)
	SMFICTX *ctx;
	int cmd;
	char *arg0;
	char **argv;
{
	size_t len, l0, l1, offset;
	int r;
	char *buf, *arg, **argvl;
	struct timeval timeout;

	if (arg0 == NULL || *arg0 == '\0')
		return MI_FAILURE;
	timeout.tv_sec = ctx->ctx_timeout;
	timeout.tv_usec = 0;
	l0 = strlen(arg0) + 1;
	len = l0;
	argvl = argv;
	while (argvl != NULL && (arg = *argv) != NULL && *arg != '\0')
	{
		l1 = strlen(arg) + 1;
		len += l1;
		SM_ASSERT(len > l1);
	}

	buf = malloc(len);
	if (buf == NULL)
		return MI_FAILURE;
	(void) memcpy(buf, arg0, l0);
	offset = l0;

	argvl = argv;
	while (argvl != NULL && (arg = *argv) != NULL && *arg != '\0')
	{
		l1 = strlen(arg) + 1;
		SM_ASSERT(offset < len);
		SM_ASSERT(offset + l1 <= len);
		(void) memcpy(buf + offset, arg, l1);
		offset += l1;
		SM_ASSERT(offset > l1);
	}

	r = mi_wr_cmd(ctx->ctx_sd, &timeout, cmd, buf, len);
	free(buf);
	return r;
}
#endif /* 0 */

/*
**  SEND2 -- construct buffer to send from arguments
**
**	Parameters:
**		ctx -- Opaque context structure
**		cmd -- command
**		arg0 -- first argument
**		argv -- list of arguments (NULL terminated)
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

static int
send2 __P((SMFICTX *, int cmd, char *, char *));

static int
send2(ctx, cmd, arg0, arg1)
	SMFICTX *ctx;
	int cmd;
	char *arg0;
	char *arg1;
{
	size_t len, l0, l1, offset;
	int r;
	char *buf;
	struct timeval timeout;

	if (arg0 == NULL || *arg0 == '\0')
		return MI_FAILURE;
	timeout.tv_sec = ctx->ctx_timeout;
	timeout.tv_usec = 0;
	l0 = strlen(arg0) + 1;
	len = l0;
	if (arg1 != NULL)
	{
		l1 = strlen(arg1) + 1;
		len += l1;
		SM_ASSERT(len > l1);
	}

	buf = malloc(len);
	if (buf == NULL)
		return MI_FAILURE;
	(void) memcpy(buf, arg0, l0);
	offset = l0;

	if (arg1 != NULL)
	{
		l1 = strlen(arg1) + 1;
		SM_ASSERT(offset < len);
		SM_ASSERT(offset + l1 <= len);
		(void) memcpy(buf + offset, arg1, l1);
		offset += l1;
		SM_ASSERT(offset > l1);
	}

	r = mi_wr_cmd(ctx->ctx_sd, &timeout, cmd, buf, len);
	free(buf);
	return r;
}

/*
**  SMFI_CHGFROM -- change enveloper sender ("from") address
**
**	Parameters:
**		ctx -- Opaque context structure
**		from -- new envelope sender address ("MAIL From")
**		args -- ESMTP arguments
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_chgfrom(ctx, from, args)
	SMFICTX *ctx;
	char *from;
	char *args;
{
	if (from == NULL || *from == '\0')
		return MI_FAILURE;
	if (!mi_sendok(ctx, SMFIF_CHGFROM))
		return MI_FAILURE;
	return send2(ctx, SMFIR_CHGFROM, from, args);
}

/*
**  SMFI_SETSYMLIST -- set list of macros that the MTA should send.
**
**	Parameters:
**		ctx -- Opaque context structure
**		where -- SMTP stage
**		macros -- list of macros
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_setsymlist(ctx, where, macros)
	SMFICTX *ctx;
	int where;
	char *macros;
{
	SM_ASSERT(ctx != NULL);

	if (macros == NULL || *macros == '\0')
		return MI_FAILURE;
	if (where < SMFIM_FIRST || where > SMFIM_LAST)
		return MI_FAILURE;
	if (where < 0 || where >= MAX_MACROS_ENTRIES)
		return MI_FAILURE;

	if (ctx->ctx_mac_list[where] != NULL)
		return MI_FAILURE;

	ctx->ctx_mac_list[where] = strdup(macros);
	if (ctx->ctx_mac_list[where] == NULL)
		return MI_FAILURE;

	return MI_SUCCESS;
}

/*
**  SMFI_ADDRCPT_PAR -- send an additional recipient to the MTA
**
**	Parameters:
**		ctx -- Opaque context structure
**		rcpt -- recipient address
**		args -- ESMTP arguments
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_addrcpt_par(ctx, rcpt, args)
	SMFICTX *ctx;
	char *rcpt;
	char *args;
{
	if (rcpt == NULL || *rcpt == '\0')
		return MI_FAILURE;
	if (!mi_sendok(ctx, SMFIF_ADDRCPT_PAR))
		return MI_FAILURE;
	return send2(ctx, SMFIR_ADDRCPT_PAR, rcpt, args);
}

/*
**  SMFI_ADDRCPT -- send an additional recipient to the MTA
**
**	Parameters:
**		ctx -- Opaque context structure
**		rcpt -- recipient address
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_addrcpt(ctx, rcpt)
	SMFICTX *ctx;
	char *rcpt;
{
	size_t len;
	struct timeval timeout;

	if (rcpt == NULL || *rcpt == '\0')
		return MI_FAILURE;
	if (!mi_sendok(ctx, SMFIF_ADDRCPT))
		return MI_FAILURE;
	timeout.tv_sec = ctx->ctx_timeout;
	timeout.tv_usec = 0;
	len = strlen(rcpt) + 1;
	return mi_wr_cmd(ctx->ctx_sd, &timeout, SMFIR_ADDRCPT, rcpt, len);
}

/*
**  SMFI_DELRCPT -- send a recipient to be removed to the MTA
**
**	Parameters:
**		ctx -- Opaque context structure
**		rcpt -- recipient address
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_delrcpt(ctx, rcpt)
	SMFICTX *ctx;
	char *rcpt;
{
	size_t len;
	struct timeval timeout;

	if (rcpt == NULL || *rcpt == '\0')
		return MI_FAILURE;
	if (!mi_sendok(ctx, SMFIF_DELRCPT))
		return MI_FAILURE;
	timeout.tv_sec = ctx->ctx_timeout;
	timeout.tv_usec = 0;
	len = strlen(rcpt) + 1;
	return mi_wr_cmd(ctx->ctx_sd, &timeout, SMFIR_DELRCPT, rcpt, len);
}

/*
**  SMFI_REPLACEBODY -- send a body chunk to the MTA
**
**	Parameters:
**		ctx -- Opaque context structure
**		bodyp -- body chunk
**		bodylen -- length of body chunk
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_replacebody(ctx, bodyp, bodylen)
	SMFICTX *ctx;
	unsigned char *bodyp;
	int bodylen;
{
	int len, off, r;
	struct timeval timeout;

	if (bodylen < 0 ||
	    (bodyp == NULL && bodylen > 0))
		return MI_FAILURE;
	if (!mi_sendok(ctx, SMFIF_CHGBODY))
		return MI_FAILURE;
	timeout.tv_sec = ctx->ctx_timeout;
	timeout.tv_usec = 0;

	/* split body chunk if necessary */
	off = 0;
	do
	{
		len = (bodylen >= MILTER_CHUNK_SIZE) ? MILTER_CHUNK_SIZE :
						       bodylen;
		if ((r = mi_wr_cmd(ctx->ctx_sd, &timeout, SMFIR_REPLBODY,
				(char *) (bodyp + off), len)) != MI_SUCCESS)
			return r;
		off += len;
		bodylen -= len;
	} while (bodylen > 0);
	return MI_SUCCESS;
}

/*
**  SMFI_QUARANTINE -- quarantine an envelope
**
**	Parameters:
**		ctx -- Opaque context structure
**		reason -- why?
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_quarantine(ctx, reason)
	SMFICTX *ctx;
	char *reason;
{
	size_t len;
	int r;
	char *buf;
	struct timeval timeout;

	if (reason == NULL || *reason == '\0')
		return MI_FAILURE;
	if (!mi_sendok(ctx, SMFIF_QUARANTINE))
		return MI_FAILURE;
	timeout.tv_sec = ctx->ctx_timeout;
	timeout.tv_usec = 0;
	len = strlen(reason) + 1;
	buf = malloc(len);
	if (buf == NULL)
		return MI_FAILURE;
	(void) memcpy(buf, reason, len);
	r = mi_wr_cmd(ctx->ctx_sd, &timeout, SMFIR_QUARANTINE, buf, len);
	free(buf);
	return r;
}

/*
**  MYISENHSC -- check whether a string contains an enhanced status code
**
**	Parameters:
**		s -- string with possible enhanced status code.
**		delim -- delim for enhanced status code.
**
**	Returns:
**		0  -- no enhanced status code.
**		>4 -- length of enhanced status code.
**
**	Side Effects:
**		none.
*/

static int
myisenhsc(s, delim)
	const char *s;
	int delim;
{
	int l, h;

	if (s == NULL)
		return 0;
	if (!((*s == '2' || *s == '4' || *s == '5') && s[1] == '.'))
		return 0;
	h = 0;
	l = 2;
	while (h < 3 && isascii(s[l + h]) && isdigit(s[l + h]))
		++h;
	if (h == 0 || s[l + h] != '.')
		return 0;
	l += h + 1;
	h = 0;
	while (h < 3 && isascii(s[l + h]) && isdigit(s[l + h]))
		++h;
	if (h == 0 || s[l + h] != delim)
		return 0;
	return l + h;
}

/*
**  SMFI_SETREPLY -- set the reply code for the next reply to the MTA
**
**	Parameters:
**		ctx -- Opaque context structure
**		rcode -- The three-digit (RFC 821) SMTP reply code.
**		xcode -- The extended (RFC 2034) reply code.
**		message -- The text part of the SMTP reply.
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_setreply(ctx, rcode, xcode, message)
	SMFICTX *ctx;
	char *rcode;
	char *xcode;
	char *message;
{
	size_t len;
	char *buf;

	if (rcode == NULL || ctx == NULL)
		return MI_FAILURE;

	/* ### <sp> \0 */
	len = strlen(rcode) + 2;
	if (len != 5)
		return MI_FAILURE;
	if ((rcode[0] != '4' && rcode[0] != '5') ||
	    !isascii(rcode[1]) || !isdigit(rcode[1]) ||
	    !isascii(rcode[2]) || !isdigit(rcode[2]))
		return MI_FAILURE;
	if (xcode != NULL)
	{
		if (!myisenhsc(xcode, '\0'))
			return MI_FAILURE;
		len += strlen(xcode) + 1;
	}
	if (message != NULL)
	{
		size_t ml;

		/* XXX check also for unprintable chars? */
		if (strpbrk(message, "\r\n") != NULL)
			return MI_FAILURE;
		ml = strlen(message);
		if (ml > MAXREPLYLEN)
			return MI_FAILURE;
		len += ml + 1;
	}
	buf = malloc(len);
	if (buf == NULL)
		return MI_FAILURE;		/* oops */
	(void) sm_strlcpy(buf, rcode, len);
	(void) sm_strlcat(buf, " ", len);
	if (xcode != NULL)
		(void) sm_strlcat(buf, xcode, len);
	if (message != NULL)
	{
		if (xcode != NULL)
			(void) sm_strlcat(buf, " ", len);
		(void) sm_strlcat(buf, message, len);
	}
	if (ctx->ctx_reply != NULL)
		free(ctx->ctx_reply);
	ctx->ctx_reply = buf;
	return MI_SUCCESS;
}

/*
**  SMFI_SETMLREPLY -- set multiline reply code for the next reply to the MTA
**
**	Parameters:
**		ctx -- Opaque context structure
**		rcode -- The three-digit (RFC 821) SMTP reply code.
**		xcode -- The extended (RFC 2034) reply code.
**		txt, ... -- The text part of the SMTP reply,
**			MUST be terminated with NULL.
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
#if SM_VA_STD
smfi_setmlreply(SMFICTX *ctx, const char *rcode, const char *xcode, ...)
#else /* SM_VA_STD */
smfi_setmlreply(ctx, rcode, xcode, va_alist)
	SMFICTX *ctx;
	const char *rcode;
	const char *xcode;
	va_dcl
#endif /* SM_VA_STD */
{
	size_t len;
	size_t rlen;
	int args;
	char *buf, *txt;
	const char *xc;
	char repl[16];
	SM_VA_LOCAL_DECL

	if (rcode == NULL || ctx == NULL)
		return MI_FAILURE;

	/* ### <sp> */
	len = strlen(rcode) + 1;
	if (len != 4)
		return MI_FAILURE;
	if ((rcode[0] != '4' && rcode[0] != '5') ||
	    !isascii(rcode[1]) || !isdigit(rcode[1]) ||
	    !isascii(rcode[2]) || !isdigit(rcode[2]))
		return MI_FAILURE;
	if (xcode != NULL)
	{
		if (!myisenhsc(xcode, '\0'))
			return MI_FAILURE;
		xc = xcode;
	}
	else
	{
		if (rcode[0] == '4')
			xc = "4.0.0";
		else
			xc = "5.0.0";
	}

	/* add trailing space */
	len += strlen(xc) + 1;
	rlen = len;
	args = 0;
	SM_VA_START(ap, xcode);
	while ((txt = SM_VA_ARG(ap, char *)) != NULL)
	{
		size_t tl;

		tl = strlen(txt);
		if (tl > MAXREPLYLEN)
			break;

		/* this text, reply codes, \r\n */
		len += tl + 2 + rlen;
		if (++args > MAXREPLIES)
			break;

		/* XXX check also for unprintable chars? */
		if (strpbrk(txt, "\r\n") != NULL)
			break;
	}
	SM_VA_END(ap);
	if (txt != NULL)
		return MI_FAILURE;

	/* trailing '\0' */
	++len;
	buf = malloc(len);
	if (buf == NULL)
		return MI_FAILURE;		/* oops */
	(void) sm_strlcpyn(buf, len, 3, rcode, args == 1 ? " " : "-", xc);
	(void) sm_strlcpyn(repl, sizeof repl, 4, rcode, args == 1 ? " " : "-",
			   xc, " ");
	SM_VA_START(ap, xcode);
	txt = SM_VA_ARG(ap, char *);
	if (txt != NULL)
	{
		(void) sm_strlcat2(buf, " ", txt, len);
		while ((txt = SM_VA_ARG(ap, char *)) != NULL)
		{
			if (--args <= 1)
				repl[3] = ' ';
			(void) sm_strlcat2(buf, "\r\n", repl, len);
			(void) sm_strlcat(buf, txt, len);
		}
	}
	if (ctx->ctx_reply != NULL)
		free(ctx->ctx_reply);
	ctx->ctx_reply = buf;
	SM_VA_END(ap);
	return MI_SUCCESS;
}

/*
**  SMFI_SETPRIV -- set private data
**
**	Parameters:
**		ctx -- Opaque context structure
**		privatedata -- pointer to private data
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_setpriv(ctx, privatedata)
	SMFICTX *ctx;
	void *privatedata;
{
	if (ctx == NULL)
		return MI_FAILURE;
	ctx->ctx_privdata = privatedata;
	return MI_SUCCESS;
}

/*
**  SMFI_GETPRIV -- get private data
**
**	Parameters:
**		ctx -- Opaque context structure
**
**	Returns:
**		pointer to private data
*/

void *
smfi_getpriv(ctx)
	SMFICTX *ctx;
{
	if (ctx == NULL)
		return NULL;
	return ctx->ctx_privdata;
}

/*
**  SMFI_GETSYMVAL -- get the value of a macro
**
**	See explanation in mfapi.h about layout of the structures.
**
**	Parameters:
**		ctx -- Opaque context structure
**		symname -- name of macro
**
**	Returns:
**		value of macro (NULL in case of failure)
*/

char *
smfi_getsymval(ctx, symname)
	SMFICTX *ctx;
	char *symname;
{
	int i;
	char **s;
	char one[2];
	char braces[4];

	if (ctx == NULL || symname == NULL || *symname == '\0')
		return NULL;

	if (strlen(symname) == 3 && symname[0] == '{' && symname[2] == '}')
	{
		one[0] = symname[1];
		one[1] = '\0';
	}
	else
		one[0] = '\0';
	if (strlen(symname) == 1)
	{
		braces[0] = '{';
		braces[1] = *symname;
		braces[2] = '}';
		braces[3] = '\0';
	}
	else
		braces[0] = '\0';

	/* search backwards through the macro array */
	for (i = MAX_MACROS_ENTRIES - 1 ; i >= 0; --i)
	{
		if ((s = ctx->ctx_mac_ptr[i]) == NULL ||
		    ctx->ctx_mac_buf[i] == NULL)
			continue;
		while (s != NULL && *s != NULL)
		{
			if (strcmp(*s, symname) == 0)
				return *++s;
			if (one[0] != '\0' && strcmp(*s, one) == 0)
				return *++s;
			if (braces[0] != '\0' && strcmp(*s, braces) == 0)
				return *++s;
			++s;	/* skip over macro value */
			++s;	/* points to next macro name */
		}
	}
	return NULL;
}

/*
**  SMFI_PROGRESS -- send "progress" message to the MTA to prevent premature
**		     timeouts during long milter-side operations
**
**	Parameters:
**		ctx -- Opaque context structure
**
**	Return value:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_progress(ctx)
	SMFICTX *ctx;
{
	struct timeval timeout;

	if (ctx == NULL)
		return MI_FAILURE;

	timeout.tv_sec = ctx->ctx_timeout;
	timeout.tv_usec = 0;

	return mi_wr_cmd(ctx->ctx_sd, &timeout, SMFIR_PROGRESS, NULL, 0);
}

/*
**  SMFI_VERSION -- return (runtime) version of libmilter
**
**	Parameters:
**		major -- (pointer to) major version
**		minor -- (pointer to) minor version
**		patchlevel -- (pointer to) patchlevel version
**
**	Return value:
**		MI_SUCCESS
*/

int
smfi_version(major, minor, patchlevel)
	unsigned int *major;
	unsigned int *minor;
	unsigned int *patchlevel;
{
	if (major != NULL)
		*major = SM_LM_VRS_MAJOR(SMFI_VERSION);
	if (minor != NULL)
		*minor = SM_LM_VRS_MINOR(SMFI_VERSION);
	if (patchlevel != NULL)
		*patchlevel = SM_LM_VRS_PLVL(SMFI_VERSION);
	return MI_SUCCESS;
}
@


1.4
log
@Replace “$Sendmail: ” with “$Id: ” (the latter is used by upstream)
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2007 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Id: smfi.c,v 8.83 2007/04/23 16:44:39 ca Exp $")
@


1.3
log
@merge and reduce diffs against upstream
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: smfi.c,v 8.83 2007/04/23 16:44:39 ca Exp $")
@


1.2
log
@upgrade from sendmail 8.14.1 to 8.14.2 ourselves:
> From donotreply@@lists.sendmail.org Fri Nov  2 02:46:04 2007
> From: Claus Assmann <donotreply@@lists.sendmail.org>
Message-ID: <200711020234.lA22YPul046763@@lists.sendmail.org>
To: sendmail-announce@@sendmail.org
Date: Thu, 1 Nov 2007 19:34:25 -0700 (PDT)
Subject: sendmail 8.14.2 available

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Sendmail, Inc., and the Sendmail Consortium announce the availability
of sendmail 8.14.2 which fixes some problems, e.g.,

- - an important bug in the milter function smfi_chgfrom() which could
  cause the loss of a message body.
- - the handling of queued messages with 8 bit characters in From:
  or To: header which could be "mistaken" for internal control
  characters during a queue run and trigger various consistency checks.
- - the handling of lines longer than MAXLINE-1 characters in certain
  cases.

A complete list of changes can be found in the release notes (see
below).

Please send bug reports and general feedback to one of the addresses
listed at: http://www.sendmail.org/email-addresses.html

The version can be found at

ftp://ftp.sendmail.org/pub/sendmail/sendmail.8.14.2.tar.gz
ftp://ftp.sendmail.org/pub/sendmail/sendmail.8.14.2.tar.gz.sig
ftp://ftp.sendmail.org/pub/sendmail/sendmail.8.14.2.tar.Z
ftp://ftp.sendmail.org/pub/sendmail/sendmail.8.14.2.tar.Z.sig

MD5 signatures:
cf784b9f20c32949ae1f38f3eae29875 sendmail.8.14.2.tar.Z
f788d6986f12a81ac958195b045a529d sendmail.8.14.2.tar.Z.sig
1c1472365344ca8061d6453c43c9a831 sendmail.8.14.2.tar.gz
2ae4b6175a08e8a6cda992db20141d81 sendmail.8.14.2.tar.gz.sig

You either need the first two files or the third and fourth, i.e.,
the gzip'ed version or the compressed version and the corresponding
sig file.  The PGP signature was created using the Sendmail Signing
Key/2007, available on the web site (http://www.sendmail.org/) or
on the public key servers.

Since sendmail 8.11 and later includes hooks to cryptography, the
following information from OpenSSL applies to sendmail as well.

   PLEASE REMEMBER THAT EXPORT/IMPORT AND/OR USE OF STRONG CRYPTOGRAPHY
   SOFTWARE, PROVIDING CRYPTOGRAPHY HOOKS OR EVEN JUST COMMUNICATING
   TECHNICAL DETAILS ABOUT CRYPTOGRAPHY SOFTWARE IS ILLEGAL IN SOME
   PARTS OF THE WORLD.  SO, WHEN YOU IMPORT THIS PACKAGE TO YOUR
   COUNTRY, RE-DISTRIBUTE IT FROM THERE OR EVEN JUST EMAIL TECHNICAL
   SUGGESTIONS OR EVEN SOURCE PATCHES TO THE AUTHOR OR OTHER PEOPLE
   YOU ARE STRONGLY ADVISED TO PAY CLOSE ATTENTION TO ANY EXPORT/IMPORT
   AND/OR USE LAWS WHICH APPLY TO YOU. THE AUTHORS ARE NOT LIABLE FOR
   ANY VIOLATIONS YOU MAKE HERE. SO BE CAREFUL, IT IS YOUR RESPONSIBILITY.


			SENDMAIL RELEASE NOTES
      $Id: RELEASE_NOTES,v 8.1909 2007/10/31 16:04:13 ca Exp $


This listing shows the version of the sendmail binary, the version
of the sendmail configuration files, the date of release, and a
summary of the changes in that release.

8.14.2/8.14.2	2007/11/01
	If a message was queued and it contained 8 bit characters in
		a From: or To: header, then those characters could be
		"mistaken" for internal control characters during a queue
		run and trigger various consistency checks.  Problem
		noted by Neil Rickert of Northern Illinois University.
	If MaxMimeHeaderLength is set to a value greater than 0 (which
		it is by default) then even if the Linelimit parameter
		is 0, sendmail corrupted in the non-transfer-encoding
		case every MAXLINE-1 characters.  Patch from John Gardiner
		Myers of Proofpoint.
	Setting the suboption DeliveryMode for DaemonPortOptions did not
		work in earlier 8.14 versions.
	Note: DeliveryMode=interactive is silently converted to
		background if a milter can reject or delete a recipient.
		Prior to 8.14 this happened only if milter could delete
		recipients.
	ClientRate should trigger when the limit was exceeded (as
		documented), not when it was reached.  Patch from
		John Beck of Sun Microsystems.
	Force a queue run for -qGqueuegroup even if no runners are
		specified (R=0) and forking (F=f) is requested.
	When multiple results are requested for a DNS map lookup
		(-z and -Z), return only those that are relevant for
		the query (not also those in the "additional section".)
	If the message transfer time to sendmail (when acting as server)
		exceeds Timeout.queuewarn or Timeout.queuereturn and
		the message is refused (by a milter), sendmail previously
		created a delivery status notification (DSN).  Patch
		from Doug Heath of The Hertz Corporation.
	A code change in Cyrus-SASL 2.1.22 for sasl_decode64() requires
		the MTA to deal with some input (i.e., "=") itself.
		Problem noted by Eliot Lear.
	sendmail counted a delivery as successful if PIPELINING is
		compiled in but not offered by the server and the
		delivery failed temporarily.  Patch from Werner Wiethege.
	If getting the result of an LDAP query times out then close the
		map so it will be reopened on the next lookup.  This
		should help "failover" configurations that specify more
		than one LDAP server.
	If check_compat returns $#discard then a "savemail panic" could
		be triggered under some circumstances (e.g., requiring
		a system which does not have the compile time flag
		HASFLOCK set). Based on patch by Motonori Nakamura
		of National Institute of Informatics, Japan.
	If a milter rejected a recipient, the count for nrcpts= in the
		logfile entry might have been wrong.  Problem found by
		Petra Humann of TU Dresden.
	If a milter invoked smfi_chgfrom() where ESMTP arguments are not
		NULL, the message body was lost.  Patch from Motonori
		Nakamura of National Institute of Informatics, Japan.
	sendmail(8) had a bogus space in -qGname.  Patch from Peng Haitao.
	CONTRIB: buildvirtuser: Preserve ownership and permissions when
		replacing files.
	CONTRIB: buildvirtuser: Skip dot-files (e.g., .cvsignore) when
		reading the /etc/mail/virtusers/ directory.
	CONTRIB: buildvirtuser: Emit warnings instead of exiting where
		appropriate.
	LIBMILTER: Fix ABI backwards compatibility so milters compiled
		against an older libmilter.so shared library can use an
		8.14 libmilter.so shared library.
	LIBMILTER: smfi_version() did not properly extract the patchlevel
		from the version number, however, the returned value was
		correct for the current libmilter version.

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.5 (OpenBSD)

iQCVAwUBRyqEOs8etQMiMnoBAQKNdQP/cQKfjVP7qTi0Ol/OgR7AnvCaerCxiQ5J
y1uxjwXs2s+RemX0u5a4c0agoLscTKU5Ot6uzOdvKvZd0/unr/IkzuXZBF9LsnlZ
X1wS4GXQDXKDfazvwdwOUgxkthMZU1TiVFj/GH5TOfHqVUO5Ho/yRfAQoAn3taFc
5jeg+A3+M9M=
=DJHS
-----END PGP SIGNATURE-----
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: smfi.c,v 8.82 2007/01/20 06:37:19 ca Exp $")
@


1.2.2.1
log
@MFC sendmail update to 8.14.3

agreed bsiegert@@
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: smfi.c,v 8.83 2007/04/23 16:44:39 ca Exp $")
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2004 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: smfi.c,v 8.73 2004/09/20 21:26:57 ca Exp $")
a32 1
**
d155 215
d459 1
a459 1
	while (bodylen > 0)
d468 1
a468 1
	}
d863 27
@


1.1.127.1
log
@Import Sendmail 8.14.3, suitably stripped down by the not yet committed
contrib/samples/import-3rdpty,v 1.35; we have some new and renamed files
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2007 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Id: smfi.c,v 8.83 2007/04/23 16:44:39 ca Exp $")
d33 1
a155 215
#if 0
/*
**  BUF_CRT_SEND -- construct buffer to send from arguments
**
**	Parameters:
**		ctx -- Opaque context structure
**		cmd -- command
**		arg0 -- first argument
**		argv -- list of arguments (NULL terminated)
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

static int
buf_crt_send __P((SMFICTX *, int cmd, char *, char **));

static int
buf_crt_send(ctx, cmd, arg0, argv)
	SMFICTX *ctx;
	int cmd;
	char *arg0;
	char **argv;
{
	size_t len, l0, l1, offset;
	int r;
	char *buf, *arg, **argvl;
	struct timeval timeout;

	if (arg0 == NULL || *arg0 == '\0')
		return MI_FAILURE;
	timeout.tv_sec = ctx->ctx_timeout;
	timeout.tv_usec = 0;
	l0 = strlen(arg0) + 1;
	len = l0;
	argvl = argv;
	while (argvl != NULL && (arg = *argv) != NULL && *arg != '\0')
	{
		l1 = strlen(arg) + 1;
		len += l1;
		SM_ASSERT(len > l1);
	}

	buf = malloc(len);
	if (buf == NULL)
		return MI_FAILURE;
	(void) memcpy(buf, arg0, l0);
	offset = l0;

	argvl = argv;
	while (argvl != NULL && (arg = *argv) != NULL && *arg != '\0')
	{
		l1 = strlen(arg) + 1;
		SM_ASSERT(offset < len);
		SM_ASSERT(offset + l1 <= len);
		(void) memcpy(buf + offset, arg, l1);
		offset += l1;
		SM_ASSERT(offset > l1);
	}

	r = mi_wr_cmd(ctx->ctx_sd, &timeout, cmd, buf, len);
	free(buf);
	return r;
}
#endif /* 0 */

/*
**  SEND2 -- construct buffer to send from arguments
**
**	Parameters:
**		ctx -- Opaque context structure
**		cmd -- command
**		arg0 -- first argument
**		argv -- list of arguments (NULL terminated)
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

static int
send2 __P((SMFICTX *, int cmd, char *, char *));

static int
send2(ctx, cmd, arg0, arg1)
	SMFICTX *ctx;
	int cmd;
	char *arg0;
	char *arg1;
{
	size_t len, l0, l1, offset;
	int r;
	char *buf;
	struct timeval timeout;

	if (arg0 == NULL || *arg0 == '\0')
		return MI_FAILURE;
	timeout.tv_sec = ctx->ctx_timeout;
	timeout.tv_usec = 0;
	l0 = strlen(arg0) + 1;
	len = l0;
	if (arg1 != NULL)
	{
		l1 = strlen(arg1) + 1;
		len += l1;
		SM_ASSERT(len > l1);
	}

	buf = malloc(len);
	if (buf == NULL)
		return MI_FAILURE;
	(void) memcpy(buf, arg0, l0);
	offset = l0;

	if (arg1 != NULL)
	{
		l1 = strlen(arg1) + 1;
		SM_ASSERT(offset < len);
		SM_ASSERT(offset + l1 <= len);
		(void) memcpy(buf + offset, arg1, l1);
		offset += l1;
		SM_ASSERT(offset > l1);
	}

	r = mi_wr_cmd(ctx->ctx_sd, &timeout, cmd, buf, len);
	free(buf);
	return r;
}

/*
**  SMFI_CHGFROM -- change enveloper sender ("from") address
**
**	Parameters:
**		ctx -- Opaque context structure
**		from -- new envelope sender address ("MAIL From")
**		args -- ESMTP arguments
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_chgfrom(ctx, from, args)
	SMFICTX *ctx;
	char *from;
	char *args;
{
	if (from == NULL || *from == '\0')
		return MI_FAILURE;
	if (!mi_sendok(ctx, SMFIF_CHGFROM))
		return MI_FAILURE;
	return send2(ctx, SMFIR_CHGFROM, from, args);
}

/*
**  SMFI_SETSYMLIST -- set list of macros that the MTA should send.
**
**	Parameters:
**		ctx -- Opaque context structure
**		where -- SMTP stage
**		macros -- list of macros
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_setsymlist(ctx, where, macros)
	SMFICTX *ctx;
	int where;
	char *macros;
{
	SM_ASSERT(ctx != NULL);

	if (macros == NULL || *macros == '\0')
		return MI_FAILURE;
	if (where < SMFIM_FIRST || where > SMFIM_LAST)
		return MI_FAILURE;
	if (where < 0 || where >= MAX_MACROS_ENTRIES)
		return MI_FAILURE;

	if (ctx->ctx_mac_list[where] != NULL)
		return MI_FAILURE;

	ctx->ctx_mac_list[where] = strdup(macros);
	if (ctx->ctx_mac_list[where] == NULL)
		return MI_FAILURE;

	return MI_SUCCESS;
}

/*
**  SMFI_ADDRCPT_PAR -- send an additional recipient to the MTA
**
**	Parameters:
**		ctx -- Opaque context structure
**		rcpt -- recipient address
**		args -- ESMTP arguments
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_addrcpt_par(ctx, rcpt, args)
	SMFICTX *ctx;
	char *rcpt;
	char *args;
{
	if (rcpt == NULL || *rcpt == '\0')
		return MI_FAILURE;
	if (!mi_sendok(ctx, SMFIF_ADDRCPT_PAR))
		return MI_FAILURE;
	return send2(ctx, SMFIR_ADDRCPT_PAR, rcpt, args);
}

d245 1
a245 1
	do
d254 1
a254 1
	} while (bodylen > 0);
a648 27

/*
**  SMFI_VERSION -- return (runtime) version of libmilter
**
**	Parameters:
**		major -- (pointer to) major version
**		minor -- (pointer to) minor version
**		patchlevel -- (pointer to) patchlevel version
**
**	Return value:
**		MI_SUCCESS
*/

int
smfi_version(major, minor, patchlevel)
	unsigned int *major;
	unsigned int *minor;
	unsigned int *patchlevel;
{
	if (major != NULL)
		*major = SM_LM_VRS_MAJOR(SMFI_VERSION);
	if (minor != NULL)
		*minor = SM_LM_VRS_MINOR(SMFI_VERSION);
	if (patchlevel != NULL)
		*patchlevel = SM_LM_VRS_PLVL(SMFI_VERSION);
	return MI_SUCCESS;
}
@


1.1.127.2
log
@Import sendmail 8.14.9
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2007 Proofpoint, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Id: smfi.c,v 8.84 2013-11-22 20:51:36 ca Exp $")
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.1.2.1
log
@MFC most of the recent sendmail updates to MirOS #8-stable
agreed bsiegert@@

This also changes the LOCALBASE stuff, links libmilter not
against LDAP, etc. but doesn't install the FreeBSD 6 confs
nor a shared libmilter in order to pass a no-files-diff:

tg@@maou:/usr/src/gnu/usr.sbin/sendmail $ sudo find / -ls | sort -k11 >~/x1
tg@@maou:/usr/src/gnu/usr.sbin/sendmail $ sudo make install
tg@@maou:/usr/src/gnu/usr.sbin/sendmail/cf/cf $ sudo make distribution
tg@@maou:/usr/src/gnu/usr.sbin/sendmail/cf/cf $ sudo find / -ls | sort -k11 | diff -u ~/x1 - | less

Note: files in /etc/mail/ are also changed, this affects the etc8.ngz set
on fresh installs and cannot(!) be automatically upgraded!
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2005 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: smfi.c,v 8.74 2005/03/30 00:44:07 ca Exp $")
d245 1
a245 1
	do
d254 1
a254 1
	} while (bodylen > 0);
@


1.1.1.2
log
@Update to Sendmail 8.13.6
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2005 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: smfi.c,v 8.74 2005/03/30 00:44:07 ca Exp $")
d245 1
a245 1
	do
d254 1
a254 1
	} while (bodylen > 0);
@


1.1.1.3
log
@Import Sendmail 8.14.0 via OpenBSD
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2006 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: smfi.c,v 8.82 2007/01/20 06:37:19 ca Exp $")
d33 1
a155 215
#if 0
/*
**  BUF_CRT_SEND -- construct buffer to send from arguments
**
**	Parameters:
**		ctx -- Opaque context structure
**		cmd -- command
**		arg0 -- first argument
**		argv -- list of arguments (NULL terminated)
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

static int
buf_crt_send __P((SMFICTX *, int cmd, char *, char **));

static int
buf_crt_send(ctx, cmd, arg0, argv)
	SMFICTX *ctx;
	int cmd;
	char *arg0;
	char **argv;
{
	size_t len, l0, l1, offset;
	int r;
	char *buf, *arg, **argvl;
	struct timeval timeout;

	if (arg0 == NULL || *arg0 == '\0')
		return MI_FAILURE;
	timeout.tv_sec = ctx->ctx_timeout;
	timeout.tv_usec = 0;
	l0 = strlen(arg0) + 1;
	len = l0;
	argvl = argv;
	while (argvl != NULL && (arg = *argv) != NULL && *arg != '\0')
	{
		l1 = strlen(arg) + 1;
		len += l1;
		SM_ASSERT(len > l1);
	}

	buf = malloc(len);
	if (buf == NULL)
		return MI_FAILURE;
	(void) memcpy(buf, arg0, l0);
	offset = l0;

	argvl = argv;
	while (argvl != NULL && (arg = *argv) != NULL && *arg != '\0')
	{
		l1 = strlen(arg) + 1;
		SM_ASSERT(offset < len);
		SM_ASSERT(offset + l1 <= len);
		(void) memcpy(buf + offset, arg, l1);
		offset += l1;
		SM_ASSERT(offset > l1);
	}

	r = mi_wr_cmd(ctx->ctx_sd, &timeout, cmd, buf, len);
	free(buf);
	return r;
}
#endif /* 0 */

/*
**  SEND2 -- construct buffer to send from arguments
**
**	Parameters:
**		ctx -- Opaque context structure
**		cmd -- command
**		arg0 -- first argument
**		argv -- list of arguments (NULL terminated)
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

static int
send2 __P((SMFICTX *, int cmd, char *, char *));

static int
send2(ctx, cmd, arg0, arg1)
	SMFICTX *ctx;
	int cmd;
	char *arg0;
	char *arg1;
{
	size_t len, l0, l1, offset;
	int r;
	char *buf;
	struct timeval timeout;

	if (arg0 == NULL || *arg0 == '\0')
		return MI_FAILURE;
	timeout.tv_sec = ctx->ctx_timeout;
	timeout.tv_usec = 0;
	l0 = strlen(arg0) + 1;
	len = l0;
	if (arg1 != NULL)
	{
		l1 = strlen(arg1) + 1;
		len += l1;
		SM_ASSERT(len > l1);
	}

	buf = malloc(len);
	if (buf == NULL)
		return MI_FAILURE;
	(void) memcpy(buf, arg0, l0);
	offset = l0;

	if (arg1 != NULL)
	{
		l1 = strlen(arg1) + 1;
		SM_ASSERT(offset < len);
		SM_ASSERT(offset + l1 <= len);
		(void) memcpy(buf + offset, arg1, l1);
		offset += l1;
		SM_ASSERT(offset > l1);
	}

	r = mi_wr_cmd(ctx->ctx_sd, &timeout, cmd, buf, len);
	free(buf);
	return r;
}

/*
**  SMFI_CHGFROM -- change enveloper sender ("from") address
**
**	Parameters:
**		ctx -- Opaque context structure
**		from -- new envelope sender address ("MAIL From")
**		args -- ESMTP arguments
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_chgfrom(ctx, from, args)
	SMFICTX *ctx;
	char *from;
	char *args;
{
	if (from == NULL || *from == '\0')
		return MI_FAILURE;
	if (!mi_sendok(ctx, SMFIF_CHGFROM))
		return MI_FAILURE;
	return send2(ctx, SMFIR_CHGFROM, from, args);
}

/*
**  SMFI_SETSYMLIST -- set list of macros that the MTA should send.
**
**	Parameters:
**		ctx -- Opaque context structure
**		where -- SMTP stage
**		macros -- list of macros
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_setsymlist(ctx, where, macros)
	SMFICTX *ctx;
	int where;
	char *macros;
{
	SM_ASSERT(ctx != NULL);

	if (macros == NULL || *macros == '\0')
		return MI_FAILURE;
	if (where < SMFIM_FIRST || where > SMFIM_LAST)
		return MI_FAILURE;
	if (where < 0 || where >= MAX_MACROS_ENTRIES)
		return MI_FAILURE;

	if (ctx->ctx_mac_list[where] != NULL)
		return MI_FAILURE;

	ctx->ctx_mac_list[where] = strdup(macros);
	if (ctx->ctx_mac_list[where] == NULL)
		return MI_FAILURE;

	return MI_SUCCESS;
}

/*
**  SMFI_ADDRCPT_PAR -- send an additional recipient to the MTA
**
**	Parameters:
**		ctx -- Opaque context structure
**		rcpt -- recipient address
**		args -- ESMTP arguments
**
**	Returns:
**		MI_SUCCESS/MI_FAILURE
*/

int
smfi_addrcpt_par(ctx, rcpt, args)
	SMFICTX *ctx;
	char *rcpt;
	char *args;
{
	if (rcpt == NULL || *rcpt == '\0')
		return MI_FAILURE;
	if (!mi_sendok(ctx, SMFIF_ADDRCPT_PAR))
		return MI_FAILURE;
	return send2(ctx, SMFIR_ADDRCPT_PAR, rcpt, args);
}

a648 27

/*
**  SMFI_VERSION -- return (runtime) version of libmilter
**
**	Parameters:
**		major -- (pointer to) major version
**		minor -- (pointer to) minor version
**		patchlevel -- (pointer to) patchlevel version
**
**	Return value:
**		MI_SUCCESS
*/

int
smfi_version(major, minor, patchlevel)
	unsigned int *major;
	unsigned int *minor;
	unsigned int *patchlevel;
{
	if (major != NULL)
		*major = SM_LM_VRS_MAJOR(SMFI_VERSION);
	if (minor != NULL)
		*minor = SM_LM_VRS_MINOR(SMFI_VERSION);
	if (patchlevel != NULL)
		*patchlevel = SM_LM_VRS_MINOR(SMFI_VERSION);
	return MI_SUCCESS;
}
@


1.1.1.4
log
@OpenBSD finally has upgraded their sendmail, too…
@
text
@d2 1
a2 1
 *  Copyright (c) 1999-2007 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: smfi.c,v 8.83 2007/04/23 16:44:39 ca Exp $")
d887 1
a887 1
		*patchlevel = SM_LM_VRS_PLVL(SMFI_VERSION);
@


1.1.1.4.2.1
log
@Replace “$Sendmail: ” with “$Id: ” (the latter is used by upstream)
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Id: smfi.c,v 8.83 2007/04/23 16:44:39 ca Exp $")
@


1.1.1.5
log
@Replace “$Sendmail: ” with “$Id: ” (the latter is used by upstream)
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Id: smfi.c,v 8.83 2007/04/23 16:44:39 ca Exp $")
@


