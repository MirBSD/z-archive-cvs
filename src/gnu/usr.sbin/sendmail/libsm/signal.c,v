head	1.3;
access;
symbols
	sendmail-8_14_9:1.1.127.2
	sendmail-8_14_7:1.1.127.1
	sendmail-8_14_6:1.1.127.1
	sendmail-8_14_5-ERRATA-1:1.1.127.1
	mbsd-20101220_mergebase:1.1.1.2.4.1
	sendmail-8_14_5:1.1.127.1
	cvs-201107021500:1.1.1.3
	cvs-20101220:1.1.1.3
	mbsd-20101220:1.1.1.2.0.4
	cvs-201012191730:1.1.1.2
	sendmail-8_14_5_Beta0:1.1.127.1
	sendmail-8_14_3:1.1.127.1
	sendmail:1.1.127
	cvs-200812170000:1.1.1.2
	cvs-200805071200:1.1.1.2
	MIRBSD_10:1.1.1.2.0.2
	MIRBSD_10_BASE:1.1.1.2
	cvs-200803022030:1.1.1.2
	cvs-200707152000:1.1.1.2
	cvs-200704292000:1.1.1.2
	cvs-200702051700:1.1.1.2
	cvs-200609121900:1.1.1.2
	MIRBSD_9_BASE:1.1.1.2
	cvs-200606151800:1.1.1.2
	cvs-200603231300:1.1.1.2
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200507211800:1.1.1.1
	cvs-200504262050:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2014.06.09.15.17.29;	author tg;	state Exp;
branches;
next	1.2;
commitid	1005395CFC65E5646F1;

1.2
date	2011.07.02.15.03.56;	author tg;	state Exp;
branches;
next	1.1;
commitid	1004E0F31C5496AB95F;

1.1
date	2005.02.05.17.24.23;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.127.1;
next	;

1.1.1.1
date	2005.02.05.17.24.23;	author tg;	state Exp;
branches
	1.1.1.1.2.1;
next	1.1.1.2;

1.1.1.2
date	2006.03.23.13.09.37;	author tg;	state Exp;
branches
	1.1.1.2.4.1;
next	1.1.1.3;
commitid	10044229DEA33D36552;

1.1.1.3
date	2011.07.02.15.00.13;	author tg;	state Exp;
branches;
next	;
commitid	1004E0F31C5496AB95F;

1.1.1.1.2.1
date	2006.03.30.19.27.48;	author tg;	state Exp;
branches;
next	;
commitid	100442C309C7183FA09;

1.1.1.2.4.1
date	2011.07.02.15.02.37;	author tg;	state Exp;
branches;
next	;
commitid	1004E0F31C5496AB95F;

1.1.127.1
date	2010.12.19.14.45.49;	author tg;	state Exp;
branches;
next	1.1.127.2;
commitid	1004D0E1A94384778FD;

1.1.127.2
date	2014.06.09.14.29.21;	author tg;	state Exp;
branches;
next	;
commitid	1005395C4CC1A6DB9EE;


desc
@@


1.3
log
@merge
@
text
@/*
 * Copyright (c) 2000-2001 Proofpoint, Inc. and its suppliers.
 *      All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 */

#include <sm/gen.h>
SM_RCSID("@@(#)$Id: signal.c,v 1.18 2013-11-22 20:51:43 ca Exp $")

#if SM_CONF_SETITIMER
# include <sm/time.h>
#endif /* SM_CONF_SETITIMER */
#include <errno.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include <sm/clock.h>
#include <sm/signal.h>
#include <signal.h>
#include <sm/string.h>

unsigned int	volatile InCriticalSection; /* >0 if inside critical section */
int		volatile PendingSignal;	/* pending signal to resend */

/*
**  SM_SIGNAL -- set a signal handler
**
**	This is essentially old BSD "signal(3)".
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/

sigfunc_t
sm_signal(sig, handler)
	int sig;
	sigfunc_t handler;
{
# if defined(SA_RESTART) || (!defined(SYS5SIGNALS) && !defined(BSD4_3))
	struct sigaction n, o;
# endif /* defined(SA_RESTART) || (!defined(SYS5SIGNALS) && !defined(BSD4_3)) */

	/*
	**  First, try for modern signal calls
	**  and restartable syscalls
	*/

# ifdef SA_RESTART
	(void) memset(&n, '\0', sizeof n);
#  if USE_SA_SIGACTION
	n.sa_sigaction = (void(*)(int, siginfo_t *, void *)) handler;
	n.sa_flags = SA_RESTART|SA_SIGINFO;
#  else /* USE_SA_SIGACTION */
	n.sa_handler = handler;
	n.sa_flags = SA_RESTART;
#  endif /* USE_SA_SIGACTION */
	if (sigaction(sig, &n, &o) < 0)
		return SIG_ERR;
	return o.sa_handler;
# else /* SA_RESTART */

	/*
	**  Else check for SYS5SIGNALS or
	**  BSD4_3 signals
	*/

#  if defined(SYS5SIGNALS) || defined(BSD4_3)
#   ifdef BSD4_3
	return signal(sig, handler);
#   else /* BSD4_3 */
	return sigset(sig, handler);
#   endif /* BSD4_3 */
#  else /* defined(SYS5SIGNALS) || defined(BSD4_3) */

	/*
	**  Finally, if nothing else is available,
	**  go for a default
	*/

	(void) memset(&n, '\0', sizeof n);
	n.sa_handler = handler;
	if (sigaction(sig, &n, &o) < 0)
		return SIG_ERR;
	return o.sa_handler;
#  endif /* defined(SYS5SIGNALS) || defined(BSD4_3) */
# endif /* SA_RESTART */
}
/*
**  SM_BLOCKSIGNAL -- hold a signal to prevent delivery
**
**	Parameters:
**		sig -- the signal to block.
**
**	Returns:
**		1 signal was previously blocked
**		0 signal was not previously blocked
**		-1 on failure.
*/

int
sm_blocksignal(sig)
	int sig;
{
# ifdef BSD4_3
#  ifndef sigmask
#   define sigmask(s)	(1 << ((s) - 1))
#  endif /* ! sigmask */
	return (sigblock(sigmask(sig)) & sigmask(sig)) != 0;
# else /* BSD4_3 */
#  ifdef ALTOS_SYSTEM_V
	sigfunc_t handler;

	handler = sigset(sig, SIG_HOLD);
	if (handler == SIG_ERR)
		return -1;
	else
		return handler == SIG_HOLD;
#  else /* ALTOS_SYSTEM_V */
	sigset_t sset, oset;

	(void) sigemptyset(&sset);
	(void) sigaddset(&sset, sig);
	if (sigprocmask(SIG_BLOCK, &sset, &oset) < 0)
		return -1;
	else
		return sigismember(&oset, sig);
#  endif /* ALTOS_SYSTEM_V */
# endif /* BSD4_3 */
}
/*
**  SM_RELEASESIGNAL -- release a held signal
**
**	Parameters:
**		sig -- the signal to release.
**
**	Returns:
**		1 signal was previously blocked
**		0 signal was not previously blocked
**		-1 on failure.
*/

int
sm_releasesignal(sig)
	int sig;
{
# ifdef BSD4_3
	return (sigsetmask(sigblock(0) & ~sigmask(sig)) & sigmask(sig)) != 0;
# else /* BSD4_3 */
#  ifdef ALTOS_SYSTEM_V
	sigfunc_t handler;

	handler = sigset(sig, SIG_HOLD);
	if (sigrelse(sig) < 0)
		return -1;
	else
		return handler == SIG_HOLD;
#  else /* ALTOS_SYSTEM_V */
	sigset_t sset, oset;

	(void) sigemptyset(&sset);
	(void) sigaddset(&sset, sig);
	if (sigprocmask(SIG_UNBLOCK, &sset, &oset) < 0)
		return -1;
	else
		return sigismember(&oset, sig);
#  endif /* ALTOS_SYSTEM_V */
# endif /* BSD4_3 */
}
/*
**  PEND_SIGNAL -- Add a signal to the pending signal list
**
**	Parameters:
**		sig -- signal to add
**
**	Returns:
**		none.
**
**	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
**		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
**		DOING.
*/

void
pend_signal(sig)
	int sig;
{
	int sigbit;
	int save_errno = errno;
#if SM_CONF_SETITIMER
	struct itimerval clr;
#endif /* SM_CONF_SETITIMER */

	/*
	**  Don't want to interrupt something critical, hence delay
	**  the alarm for one second.  Hopefully, by then we
	**  will be out of the critical section.  If not, then
	**  we will just delay again.  The events to be run will
	**  still all be run, maybe just a little bit late.
	*/

	switch (sig)
	{
	  case SIGHUP:
		sigbit = PEND_SIGHUP;
		break;

	  case SIGINT:
		sigbit = PEND_SIGINT;
		break;

	  case SIGTERM:
		sigbit = PEND_SIGTERM;
		break;

	  case SIGUSR1:
		sigbit = PEND_SIGUSR1;
		break;

	  case SIGALRM:
		/* don't have to pend these */
		sigbit = 0;
		break;

	  default:
		/* If we get here, we are in trouble */
		abort();

		/* NOTREACHED */
		/* shut up stupid compiler warning on HP-UX 11 */
		sigbit = 0;
		break;
	}

	if (sigbit != 0)
		PendingSignal |= sigbit;
	(void) sm_signal(SIGALRM, sm_tick);
#if SM_CONF_SETITIMER
	clr.it_interval.tv_sec = 0;
	clr.it_interval.tv_usec = 0;
	clr.it_value.tv_sec = 1;
	clr.it_value.tv_usec = 0;
	(void) setitimer(ITIMER_REAL, &clr, NULL);
#else /* SM_CONF_SETITIMER */
	(void) alarm(1);
#endif /* SM_CONF_SETITIMER */
	errno = save_errno;
}
/*
**  SM_ALLSIGNALS -- act on all signals
**
**	Parameters:
**		block -- whether to block or release all signals.
**
**	Returns:
**		none.
*/

void
sm_allsignals(block)
	bool block;
{
# ifdef BSD4_3
#  ifndef sigmask
#   define sigmask(s)	(1 << ((s) - 1))
#  endif /* ! sigmask */
	if (block)
	{
		int mask = 0;

		mask |= sigmask(SIGALRM);
		mask |= sigmask(SIGCHLD);
		mask |= sigmask(SIGHUP);
		mask |= sigmask(SIGINT);
		mask |= sigmask(SIGTERM);
		mask |= sigmask(SIGUSR1);

		(void) sigblock(mask);
	}
	else
		sigsetmask(0);
# else /* BSD4_3 */
#  ifdef ALTOS_SYSTEM_V
	if (block)
	{
		(void) sigset(SIGALRM, SIG_HOLD);
		(void) sigset(SIGCHLD, SIG_HOLD);
		(void) sigset(SIGHUP, SIG_HOLD);
		(void) sigset(SIGINT, SIG_HOLD);
		(void) sigset(SIGTERM, SIG_HOLD);
		(void) sigset(SIGUSR1, SIG_HOLD);
	}
	else
	{
		(void) sigset(SIGALRM, SIG_DFL);
		(void) sigset(SIGCHLD, SIG_DFL);
		(void) sigset(SIGHUP, SIG_DFL);
		(void) sigset(SIGINT, SIG_DFL);
		(void) sigset(SIGTERM, SIG_DFL);
		(void) sigset(SIGUSR1, SIG_DFL);
	}
#  else /* ALTOS_SYSTEM_V */
	sigset_t sset;

	(void) sigemptyset(&sset);
	(void) sigaddset(&sset, SIGALRM);
	(void) sigaddset(&sset, SIGCHLD);
	(void) sigaddset(&sset, SIGHUP);
	(void) sigaddset(&sset, SIGINT);
	(void) sigaddset(&sset, SIGTERM);
	(void) sigaddset(&sset, SIGUSR1);
	(void) sigprocmask(block ? SIG_BLOCK : SIG_UNBLOCK, &sset, NULL);
#  endif /* ALTOS_SYSTEM_V */
# endif /* BSD4_3 */
}
/*
**  SM_SIGNAL_NOOP -- A signal no-op function
**
**	Parameters:
**		sig -- signal received
**
**	Returns:
**		SIGFUNC_RETURN
*/

/* ARGSUSED */
SIGFUNC_DECL
sm_signal_noop(sig)
	int sig;
{
	int save_errno = errno;

	FIX_SYSV_SIGNAL(sig, sm_signal_noop);
	errno = save_errno;
	return SIGFUNC_RETURN;
}

@


1.2
log
@Replace “$Sendmail: ” with “$Id: ” (the latter is used by upstream)
@
text
@d2 1
a2 1
 * Copyright (c) 2000-2001 Sendmail, Inc. and its suppliers.
d11 1
a11 1
SM_RCSID("@@(#)$Id: signal.c,v 1.17 2005/06/14 23:07:20 ca Exp $")
@


1.1
log
@Initial revision
@
text
@d11 1
a11 1
SM_RCSID("@@(#)$Sendmail: signal.c,v 1.16 2001/09/11 04:04:49 gshapiro Exp $")
d14 1
a14 1
# include <sys/time.h>
@


1.1.127.1
log
@Import Sendmail 8.14.3, suitably stripped down by the not yet committed
contrib/samples/import-3rdpty,v 1.35; we have some new and renamed files
@
text
@d11 1
a11 1
SM_RCSID("@@(#)$Id: signal.c,v 1.17 2005/06/14 23:07:20 ca Exp $")
d14 1
a14 1
# include <sm/time.h>
@


1.1.127.2
log
@Import sendmail 8.14.9
@
text
@d2 1
a2 1
 * Copyright (c) 2000-2001 Proofpoint, Inc. and its suppliers.
d11 1
a11 1
SM_RCSID("@@(#)$Id: signal.c,v 1.18 2013-11-22 20:51:43 ca Exp $")
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.1.2.1
log
@MFC most of the recent sendmail updates to MirOS #8-stable
agreed bsiegert@@

This also changes the LOCALBASE stuff, links libmilter not
against LDAP, etc. but doesn't install the FreeBSD 6 confs
nor a shared libmilter in order to pass a no-files-diff:

tg@@maou:/usr/src/gnu/usr.sbin/sendmail $ sudo find / -ls | sort -k11 >~/x1
tg@@maou:/usr/src/gnu/usr.sbin/sendmail $ sudo make install
tg@@maou:/usr/src/gnu/usr.sbin/sendmail/cf/cf $ sudo make distribution
tg@@maou:/usr/src/gnu/usr.sbin/sendmail/cf/cf $ sudo find / -ls | sort -k11 | diff -u ~/x1 - | less

Note: files in /etc/mail/ are also changed, this affects the etc8.ngz set
on fresh installs and cannot(!) be automatically upgraded!
@
text
@d11 1
a11 1
SM_RCSID("@@(#)$Sendmail: signal.c,v 1.17 2005/06/14 23:07:20 ca Exp $")
d14 1
a14 1
# include <sm/time.h>
@


1.1.1.2
log
@Update to Sendmail 8.13.6
@
text
@d11 1
a11 1
SM_RCSID("@@(#)$Sendmail: signal.c,v 1.17 2005/06/14 23:07:20 ca Exp $")
d14 1
a14 1
# include <sm/time.h>
@


1.1.1.2.4.1
log
@Replace “$Sendmail: ” with “$Id: ” (the latter is used by upstream)
@
text
@d11 1
a11 1
SM_RCSID("@@(#)$Id: signal.c,v 1.17 2005/06/14 23:07:20 ca Exp $")
@


1.1.1.3
log
@Replace “$Sendmail: ” with “$Id: ” (the latter is used by upstream)
@
text
@d11 1
a11 1
SM_RCSID("@@(#)$Id: signal.c,v 1.17 2005/06/14 23:07:20 ca Exp $")
@


