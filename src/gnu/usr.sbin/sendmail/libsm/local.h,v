head	1.3;
access;
symbols
	sendmail-8_14_9:1.1.127.2
	sendmail-8_14_7:1.1.127.1
	sendmail-8_14_6:1.1.127.1
	sendmail-8_14_5-ERRATA-1:1.1.127.1
	mbsd-20101220_mergebase:1.1.1.3.4.1
	sendmail-8_14_5:1.1.127.1
	cvs-201107021500:1.1.1.4
	cvs-20101220:1.1.1.4
	mbsd-20101220:1.1.1.3.0.4
	cvs-201012191730:1.1.1.3
	sendmail-8_14_5_Beta0:1.1.127.1
	sendmail-8_14_3:1.1.127.1
	sendmail:1.1.127
	cvs-200812170000:1.1.1.3
	cvs-200805071200:1.1.1.3
	MIRBSD_10:1.1.1.3.0.2
	MIRBSD_10_BASE:1.1.1.3
	cvs-200803022030:1.1.1.3
	cvs-200707152000:1.1.1.3
	cvs-200704292000:1.1.1.3
	cvs-200702051700:1.1.1.3
	cvs-200609121900:1.1.1.2
	MIRBSD_9_BASE:1.1.1.2
	cvs-200606151800:1.1.1.2
	cvs-200603231300:1.1.1.2
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200507211800:1.1.1.1
	cvs-200504262050:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2014.06.09.15.17.27;	author tg;	state Exp;
branches;
next	1.2;
commitid	1005395CFC65E5646F1;

1.2
date	2011.07.02.15.03.54;	author tg;	state Exp;
branches;
next	1.1;
commitid	1004E0F31C5496AB95F;

1.1
date	2005.02.05.17.24.23;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.127.1;
next	;

1.1.1.1
date	2005.02.05.17.24.23;	author tg;	state Exp;
branches
	1.1.1.1.2.1;
next	1.1.1.2;

1.1.1.2
date	2006.03.23.13.09.35;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	10044229DEA33D36552;

1.1.1.3
date	2007.02.05.17.06.06;	author tg;	state Exp;
branches
	1.1.1.3.4.1;
next	1.1.1.4;
commitid	10045C763C551AABAF7;

1.1.1.4
date	2011.07.02.15.00.09;	author tg;	state Exp;
branches;
next	;
commitid	1004E0F31C5496AB95F;

1.1.1.1.2.1
date	2006.03.30.19.27.47;	author tg;	state Exp;
branches;
next	;
commitid	100442C309C7183FA09;

1.1.1.3.4.1
date	2011.07.02.15.02.34;	author tg;	state Exp;
branches;
next	;
commitid	1004E0F31C5496AB95F;

1.1.127.1
date	2010.12.19.14.45.49;	author tg;	state Exp;
branches;
next	1.1.127.2;
commitid	1004D0E1A94384778FD;

1.1.127.2
date	2014.06.09.14.29.20;	author tg;	state Exp;
branches;
next	;
commitid	1005395C4CC1A6DB9EE;


desc
@@


1.3
log
@merge
@
text
@/*
 * Copyright (c) 2000-2002, 2004-2006 Proofpoint, Inc. and its suppliers.
 *      All rights reserved.
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Chris Torek.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 *	$Id: local.h,v 1.59 2013-11-22 20:51:43 ca Exp $
 */

/*
**  Information local to this implementation of stdio,
**  in particular, macros and private variables.
*/

#include <sm/time.h>
#if !SM_CONF_MEMCHR
# include <memory.h>
#endif /* !SM_CONF_MEMCHR */
#include <sm/heap.h>

int	sm_flush __P((SM_FILE_T *, int *));
SM_FILE_T	*smfp __P((void));
int	sm_refill __P((SM_FILE_T *, int));
void	sm_init __P((void));
void	sm_cleanup __P((void));
void	sm_makebuf __P((SM_FILE_T *));
int	sm_whatbuf __P((SM_FILE_T *, size_t *, int *));
int	sm_fwalk __P((int (*)(SM_FILE_T *, int *), int *));
int	sm_wsetup __P((SM_FILE_T *));
int	sm_flags __P((int));
SM_FILE_T	*sm_fp __P((const SM_FILE_T *, const int, SM_FILE_T *));
int	sm_vprintf __P((int, char const *, va_list));

/* std io functions */
ssize_t	sm_stdread __P((SM_FILE_T *, char *, size_t));
ssize_t	sm_stdwrite __P((SM_FILE_T *, char const *, size_t));
off_t	sm_stdseek __P((SM_FILE_T *, off_t, int));
int	sm_stdclose __P((SM_FILE_T *));
int	sm_stdopen __P((SM_FILE_T *, const void *, int, const void *));
int	sm_stdfdopen __P((SM_FILE_T *, const void *, int, const void *));
int	sm_stdsetinfo __P((SM_FILE_T *, int , void *));
int	sm_stdgetinfo __P((SM_FILE_T *, int , void *));

/* stdio io functions */
ssize_t	sm_stdioread __P((SM_FILE_T *, char *, size_t));
ssize_t	sm_stdiowrite __P((SM_FILE_T *, char const *, size_t));
off_t	sm_stdioseek __P((SM_FILE_T *, off_t, int));
int	sm_stdioclose __P((SM_FILE_T *));
int	sm_stdioopen __P((SM_FILE_T *, const void *, int, const void *));
int	sm_stdiosetinfo __P((SM_FILE_T *, int , void *));
int	sm_stdiogetinfo __P((SM_FILE_T *, int , void *));

/* string io functions */
ssize_t	sm_strread __P((SM_FILE_T *, char *, size_t));
ssize_t	sm_strwrite __P((SM_FILE_T *, char const *, size_t));
off_t	sm_strseek __P((SM_FILE_T *, off_t, int));
int	sm_strclose __P((SM_FILE_T *));
int	sm_stropen __P((SM_FILE_T *, const void *, int, const void *));
int	sm_strsetinfo __P((SM_FILE_T *, int , void *));
int	sm_strgetinfo __P((SM_FILE_T *, int , void *));

/* syslog io functions */
ssize_t	sm_syslogread __P((SM_FILE_T *, char *, size_t));
ssize_t	sm_syslogwrite __P((SM_FILE_T *, char const *, size_t));
off_t	sm_syslogseek __P((SM_FILE_T *, off_t, int));
int	sm_syslogclose __P((SM_FILE_T *));
int	sm_syslogopen __P((SM_FILE_T *, const void *, int, const void *));
int	sm_syslogsetinfo __P((SM_FILE_T *, int , void *));
int	sm_sysloggetinfo __P((SM_FILE_T *, int , void *));

extern bool Sm_IO_DidInit;

/* Return true iff the given SM_FILE_T cannot be written now. */
#define cantwrite(fp) \
	((((fp)->f_flags & SMWR) == 0 || (fp)->f_bf.smb_base == NULL) && \
	 sm_wsetup(fp))

/*
**  Test whether the given stdio file has an active ungetc buffer;
**   release such a buffer, without restoring ordinary unread data.
*/

#define HASUB(fp) ((fp)->f_ub.smb_base != NULL)
#define FREEUB(fp)					\
{							\
	if ((fp)->f_ub.smb_base != (fp)->f_ubuf)	\
		sm_free((char *)(fp)->f_ub.smb_base);	\
	(fp)->f_ub.smb_base = NULL;			\
}

extern const char SmFileMagic[];

#define SM_ALIGN(p)	(((unsigned long)(p) + SM_ALIGN_BITS) & ~SM_ALIGN_BITS)

#define sm_io_flockfile(fp)	((void) 0)
#define sm_io_funlockfile(fp)	((void) 0)

int sm_flags __P((int));

#ifndef FDSET_CAST
# define FDSET_CAST		/* empty cast for fd_set arg to select */
#endif

/*
**  SM_CONVERT_TIME -- convert the API timeout flag for select() usage.
**
**	This takes a 'fp' (a file type pointer) and obtains the "raw"
**	file descriptor (fd) if possible. The 'fd' is needed to possibly
**	switch the mode of the file (blocking/non-blocking) to match
**	the type of timeout. If timeout is SM_TIME_FOREVER then the
**	timeout using select won't be needed and the file is best placed
**	in blocking mode. If there is to be a finite timeout then the file
**	is best placed in non-blocking mode. Then, if not enough can be
**	written, select() can be used to test when something can be written
**	yet still timeout if the wait is too long.
**	If the mode is already in the correct state we don't change it.
**	Iff (yes "iff") the 'fd' is "-1" in value then the mode change
**	will not happen. This situation arises when a late-binding-to-disk
**	file type is in use. An example of this is the sendmail buffered
**	file type (in sendmail/bf.c).
**
**	Parameters
**		fp -- the file pointer the timeout is for
**		fd -- to become the file descriptor value from 'fp'
**		val -- the timeout value to be converted
**		time -- a struct timeval holding the converted value
**
**	Returns
**		nothing, this is flow-through code
**
**	Side Effects:
**		May or may not change the mode of a currently open file.
**		The file mode may be changed to O_NONBLOCK or ~O_NONBLOCK
**		(meaning block). This is done to best match the type of
**		timeout and for (possible) use with select().
*/

# define SM_CONVERT_TIME(fp, fd, val, time) { \
	if (((fd) = sm_io_getinfo(fp, SM_IO_WHAT_FD, NULL)) == -1) \
	{ \
		/* can't get an fd, likely internal 'fake' fp */ \
		errno = 0; \
	} \
	if ((val) == SM_TIME_DEFAULT) \
		(val) = (fp)->f_timeout; \
	if ((val) == SM_TIME_IMMEDIATE || (val) == SM_TIME_FOREVER) \
	{ \
		(time)->tv_sec = 0; \
		(time)->tv_usec = 0; \
	} \
	else \
	{ \
		(time)->tv_sec = (val) / 1000; \
		(time)->tv_usec = ((val) - ((time)->tv_sec * 1000)) * 1000; \
	} \
	if ((val) == SM_TIME_FOREVER) \
	{ \
		if ((fp)->f_timeoutstate == SM_TIME_NONBLOCK && (fd) != -1) \
		{ \
			int ret; \
			ret = fcntl((fd), F_GETFL, 0); \
			if (ret == -1 || fcntl((fd), F_SETFL, \
					       ret & ~O_NONBLOCK) == -1) \
			{ \
				/* errno should be set */ \
				return SM_IO_EOF; \
			} \
			(fp)->f_timeoutstate = SM_TIME_BLOCK; \
			if ((fp)->f_modefp != NULL) \
				(fp)->f_modefp->f_timeoutstate = SM_TIME_BLOCK; \
		} \
	} \
	else { \
		if ((fp)->f_timeoutstate == SM_TIME_BLOCK && (fd) != -1) \
		{ \
			int ret; \
			ret = fcntl((fd), F_GETFL, 0); \
			if (ret == -1 || fcntl((fd), F_SETFL, \
					       ret | O_NONBLOCK) == -1) \
			{ \
				/* errno should be set */ \
				return SM_IO_EOF; \
			} \
			(fp)->f_timeoutstate = SM_TIME_NONBLOCK; \
			if ((fp)->f_modefp != NULL) \
				(fp)->f_modefp->f_timeoutstate = SM_TIME_NONBLOCK; \
		} \
	} \
}

/*
**  SM_IO_WR_TIMEOUT -- setup the timeout for the write
**
**  This #define uses a select() to wait for the 'fd' to become writable.
**  The select() can be active for up to 'to' time. The select may not
**  use all of the the 'to' time. Hence, the amount of "wall-clock" time is
**  measured to decide how much to subtract from 'to' to update it. On some
**  BSD-based/like systems the timeout for a select is updated for the
**  amount of time used. On many/most systems this does not happen. Therefore
**  the updating of 'to' must be done ourselves; a copy of 'to' is passed
**  since a BSD-like system will have updated it and we don't want to
**  double the time used!
**  Note: if a valid 'fd' doesn't exist yet, don't use this (e.g. the
**  sendmail buffered file type in sendmail/bf.c; see fvwrite.c).
**
**	Parameters
**		fd -- a file descriptor for doing select() with
**		timeout -- the original user set value.
**
**	Returns
**		nothing, this is flow through code
**
**	Side Effects:
**		adjusts 'timeout' for time used
*/

#define SM_IO_WR_TIMEOUT(fp, fd, to) { \
	struct timeval sm_io_to_before, sm_io_to_after, sm_io_to_diff; \
	struct timeval sm_io_to; \
	int sm_io_to_sel; \
	fd_set sm_io_to_mask, sm_io_x_mask; \
	errno = 0; \
	if ((to) == SM_TIME_DEFAULT) \
		(to) = (fp)->f_timeout; \
	if ((to) == SM_TIME_IMMEDIATE) \
	{ \
		errno = EAGAIN; \
		return SM_IO_EOF; \
	} \
	else if ((to) == SM_TIME_FOREVER) \
	{ \
		errno = EINVAL; \
		return SM_IO_EOF; \
	} \
	else \
	{ \
		sm_io_to.tv_sec = (to) / 1000; \
		sm_io_to.tv_usec = ((to) - (sm_io_to.tv_sec * 1000)) * 1000; \
	} \
	if (FD_SETSIZE > 0 && (fd) >= FD_SETSIZE) \
	{ \
		errno = EINVAL; \
		return SM_IO_EOF; \
	} \
	FD_ZERO(&sm_io_to_mask); \
	FD_SET((fd), &sm_io_to_mask); \
	FD_ZERO(&sm_io_x_mask); \
	FD_SET((fd), &sm_io_x_mask); \
	if (gettimeofday(&sm_io_to_before, NULL) < 0) \
		return SM_IO_EOF; \
	do \
	{	\
		sm_io_to_sel = select((fd) + 1, NULL, &sm_io_to_mask, \
					&sm_io_x_mask, &sm_io_to); \
	} while (sm_io_to_sel < 0 && errno == EINTR); \
	if (sm_io_to_sel < 0) \
	{ \
		/* something went wrong, errno set */ \
		return SM_IO_EOF; \
	} \
	else if (sm_io_to_sel == 0) \
	{ \
		/* timeout */ \
		errno = EAGAIN; \
		return SM_IO_EOF; \
	} \
	/* else loop again */ \
	if (gettimeofday(&sm_io_to_after, NULL) < 0) \
		return SM_IO_EOF; \
	timersub(&sm_io_to_after, &sm_io_to_before, &sm_io_to_diff); \
	(to) -= (sm_io_to_diff.tv_sec * 1000); \
	(to) -= (sm_io_to_diff.tv_usec / 1000); \
	if ((to) < 0) \
		(to) = 0; \
}

/*
**  If there is no 'fd' just error (we can't timeout). If the timeout
**  is SM_TIME_FOREVER then there is no need to do a timeout with
**  select since this will be a real error.  If the error is not
**  EAGAIN/EWOULDBLOCK (from a nonblocking) then it's a real error.
**  Specify the condition here as macro so it can be used in several places.
*/

#define IS_IO_ERROR(fd, ret, to) \
	((fd) < 0 ||	\
	 ((ret) < 0 && errno != EAGAIN && errno != EWOULDBLOCK) ||	\
	 (to) == SM_TIME_FOREVER)

@


1.2
log
@Replace “$Sendmail: ” with “$Id: ” (the latter is used by upstream)
@
text
@d2 1
a2 1
 * Copyright (c) 2000-2002, 2004-2006 Sendmail, Inc. and its suppliers.
d14 1
a14 1
 *	$Id: local.h,v 1.58 2006/12/19 19:44:23 ca Exp $
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 2000-2002, 2004 Sendmail, Inc. and its suppliers.
d14 1
a14 1
 *	$Sendmail: local.h,v 1.53 2004/01/09 18:34:22 ca Exp $
d22 1
a22 1
#include <sys/time.h>
a77 36
/* should be defined in sys/time.h */
#ifndef timersub
# define timersub(tvp, uvp, vvp)					\
	do								\
	{								\
		(vvp)->tv_sec = (tvp)->tv_sec - (uvp)->tv_sec;		\
		(vvp)->tv_usec = (tvp)->tv_usec - (uvp)->tv_usec;	\
		if ((vvp)->tv_usec < 0)					\
		{							\
			(vvp)->tv_sec--;				\
			(vvp)->tv_usec += 1000000;			\
		}							\
	} while (0)
#endif /* !timersub */

#ifndef timeradd
# define timeradd(tvp, uvp, vvp)					\
	do								\
	{								\
		(vvp)->tv_sec = (tvp)->tv_sec + (uvp)->tv_sec;		\
		(vvp)->tv_usec = (tvp)->tv_usec + (uvp)->tv_usec;	\
		if ((vvp)->tv_usec >= 1000000)				\
		{							\
			(vvp)->tv_sec++;				\
			(vvp)->tv_usec -= 1000000;			\
		}							\
	} while (0)
#endif /* !timeradd */

#ifndef timercmp
# define timercmp(tvp, uvp, cmp)					\
	(((tvp)->tv_sec == (uvp)->tv_sec) ?				\
	    ((tvp)->tv_usec cmp (uvp)->tv_usec) :			\
	    ((tvp)->tv_sec cmp (uvp)->tv_sec))
#endif /* !timercmp */

d105 2
d161 1
a161 1
		(time)->tv_usec = ((val) - ((time)->tv_sec * 1000)) * 10; \
d245 1
a245 1
		sm_io_to.tv_usec = ((to) - (sm_io_to.tv_sec * 1000)) * 10; \
d258 5
a262 2
	sm_io_to_sel = select((fd) + 1, NULL, &sm_io_to_mask, &sm_io_x_mask, \
			      &sm_io_to); \
d277 3
a279 4
	timersub(&sm_io_to_before, &sm_io_to_after, &sm_io_to_diff); \
	timersub(&sm_io_to, &sm_io_to_diff, &sm_io_to); \
	(to) -= (sm_io_to.tv_sec * 1000); \
	(to) -= (sm_io_to.tv_usec / 10); \
@


1.1.127.1
log
@Import Sendmail 8.14.3, suitably stripped down by the not yet committed
contrib/samples/import-3rdpty,v 1.35; we have some new and renamed files
@
text
@d2 1
a2 1
 * Copyright (c) 2000-2002, 2004-2006 Sendmail, Inc. and its suppliers.
d14 1
a14 1
 *	$Id: local.h,v 1.58 2006/12/19 19:44:23 ca Exp $
d22 1
a22 1
#include <sm/time.h>
d78 36
a140 2
int sm_flags __P((int));

d195 1
a195 1
		(time)->tv_usec = ((val) - ((time)->tv_sec * 1000)) * 1000; \
d279 1
a279 1
		sm_io_to.tv_usec = ((to) - (sm_io_to.tv_sec * 1000)) * 1000; \
d292 2
a293 5
	do \
	{	\
		sm_io_to_sel = select((fd) + 1, NULL, &sm_io_to_mask, \
					&sm_io_x_mask, &sm_io_to); \
	} while (sm_io_to_sel < 0 && errno == EINTR); \
d308 4
a311 3
	timersub(&sm_io_to_after, &sm_io_to_before, &sm_io_to_diff); \
	(to) -= (sm_io_to_diff.tv_sec * 1000); \
	(to) -= (sm_io_to_diff.tv_usec / 1000); \
@


1.1.127.2
log
@Import sendmail 8.14.9
@
text
@d2 1
a2 1
 * Copyright (c) 2000-2002, 2004-2006 Proofpoint, Inc. and its suppliers.
d14 1
a14 1
 *	$Id: local.h,v 1.59 2013-11-22 20:51:43 ca Exp $
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.1.2.1
log
@MFC most of the recent sendmail updates to MirOS #8-stable
agreed bsiegert@@

This also changes the LOCALBASE stuff, links libmilter not
against LDAP, etc. but doesn't install the FreeBSD 6 confs
nor a shared libmilter in order to pass a no-files-diff:

tg@@maou:/usr/src/gnu/usr.sbin/sendmail $ sudo find / -ls | sort -k11 >~/x1
tg@@maou:/usr/src/gnu/usr.sbin/sendmail $ sudo make install
tg@@maou:/usr/src/gnu/usr.sbin/sendmail/cf/cf $ sudo make distribution
tg@@maou:/usr/src/gnu/usr.sbin/sendmail/cf/cf $ sudo find / -ls | sort -k11 | diff -u ~/x1 - | less

Note: files in /etc/mail/ are also changed, this affects the etc8.ngz set
on fresh installs and cannot(!) be automatically upgraded!
@
text
@d2 1
a2 1
 * Copyright (c) 2000-2002, 2004-2006 Sendmail, Inc. and its suppliers.
d14 1
a14 1
 *	$Sendmail: local.h,v 1.57 2006/02/28 18:48:25 ca Exp $
d22 1
a22 1
#include <sm/time.h>
d78 36
d195 1
a195 1
		(time)->tv_usec = ((val) - ((time)->tv_sec * 1000)) * 1000; \
d279 1
a279 1
		sm_io_to.tv_usec = ((to) - (sm_io_to.tv_sec * 1000)) * 1000; \
d292 2
a293 5
	do \
	{	\
		sm_io_to_sel = select((fd) + 1, NULL, &sm_io_to_mask, \
					&sm_io_x_mask, &sm_io_to); \
	} while (sm_io_to_sel < 0 && errno == EINTR); \
d308 4
a311 3
	timersub(&sm_io_to_after, &sm_io_to_before, &sm_io_to_diff); \
	(to) -= (sm_io_to_diff.tv_sec * 1000); \
	(to) -= (sm_io_to_diff.tv_usec / 1000); \
@


1.1.1.2
log
@Update to Sendmail 8.13.6
@
text
@d2 1
a2 1
 * Copyright (c) 2000-2002, 2004-2006 Sendmail, Inc. and its suppliers.
d14 1
a14 1
 *	$Sendmail: local.h,v 1.57 2006/02/28 18:48:25 ca Exp $
d22 1
a22 1
#include <sm/time.h>
d78 36
d195 1
a195 1
		(time)->tv_usec = ((val) - ((time)->tv_sec * 1000)) * 1000; \
d279 1
a279 1
		sm_io_to.tv_usec = ((to) - (sm_io_to.tv_sec * 1000)) * 1000; \
d292 2
a293 5
	do \
	{	\
		sm_io_to_sel = select((fd) + 1, NULL, &sm_io_to_mask, \
					&sm_io_x_mask, &sm_io_to); \
	} while (sm_io_to_sel < 0 && errno == EINTR); \
d308 4
a311 3
	timersub(&sm_io_to_after, &sm_io_to_before, &sm_io_to_diff); \
	(to) -= (sm_io_to_diff.tv_sec * 1000); \
	(to) -= (sm_io_to_diff.tv_usec / 1000); \
@


1.1.1.3
log
@Import Sendmail 8.14.0 via OpenBSD
@
text
@d14 1
a14 1
 *	$Sendmail: local.h,v 1.58 2006/12/19 19:44:23 ca Exp $
a104 2
int sm_flags __P((int));

@


1.1.1.3.4.1
log
@Replace “$Sendmail: ” with “$Id: ” (the latter is used by upstream)
@
text
@d14 1
a14 1
 *	$Id: local.h,v 1.58 2006/12/19 19:44:23 ca Exp $
@


1.1.1.4
log
@Replace “$Sendmail: ” with “$Id: ” (the latter is used by upstream)
@
text
@d14 1
a14 1
 *	$Id: local.h,v 1.58 2006/12/19 19:44:23 ca Exp $
@


