head	1.6;
access;
symbols
	sendmail-8_14_9:1.1.127.4
	sendmail-8_14_7:1.1.127.3
	sendmail-8_14_6:1.1.127.2
	sendmail-8_14_5-ERRATA-1:1.1.127.2
	mbsd-20101220_mergebase:1.4
	sendmail-8_14_5:1.1.127.2
	cvs-201107021500:1.1.1.5
	cvs-20101220:1.1.1.4
	mbsd-20101220:1.4.0.2
	cvs-201012191730:1.1.1.3
	sendmail-8_14_5_Beta0:1.1.127.2
	sendmail-8_14_3:1.1.127.1
	sendmail:1.1.127
	cvs-200812170000:1.1.1.3
	cvs-200805071200:1.1.1.3
	MIRBSD_10:1.2.0.2
	MIRBSD_10_BASE:1.2
	cvs-200803022030:1.1.1.2
	cvs-200707152000:1.1.1.2
	cvs-200704292000:1.1.1.2
	cvs-200702051700:1.1.1.2
	cvs-200609121900:1.1.1.1
	MIRBSD_9_BASE:1.1.1.1
	cvs-200606151800:1.1.1.1
	cvs-200603231300:1.1.1.1
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200507211800:1.1.1.1
	cvs-200504262050:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2014.06.09.15.18.04;	author tg;	state Exp;
branches;
next	1.5;
commitid	1005395CFC65E5646F1;

1.5
date	2013.08.06.20.37.34;	author tg;	state Exp;
branches;
next	1.4;
commitid	10052015E562892E658;

1.4
date	2010.12.19.17.18.40;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004D0E3E2D1286B3DF;

1.3
date	2008.05.07.13.15.31;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004821AB7510EE48FB;

1.2
date	2008.03.02.21.41.21;	author tg;	state Exp;
branches
	1.2.2.1;
next	1.1;
commitid	10047CB1EE51190ECAF;

1.1
date	2005.02.05.17.24.33;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.127.1;
next	;

1.2.2.1
date	2008.05.17.19.12.27;	author tg;	state Exp;
branches;
next	;
commitid	100482F2DC168C89AEA;

1.1.1.1
date	2005.02.05.17.24.33;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.02.05.17.06.54;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	10045C763C551AABAF7;

1.1.1.3
date	2008.05.07.12.31.53;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	1004821A13C1FC036E1;

1.1.1.4
date	2011.07.02.15.01.16;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	1004E0F31C5496AB95F;

1.1.1.5
date	2011.07.02.15.17.45;	author tg;	state Exp;
branches;
next	;
commitid	1004E0F36A10B5CA95B;

1.1.127.1
date	2010.12.19.14.45.53;	author tg;	state Exp;
branches;
next	1.1.127.2;
commitid	1004D0E1A94384778FD;

1.1.127.2
date	2010.12.19.14.56.33;	author tg;	state Exp;
branches;
next	1.1.127.3;
commitid	1004D0E1D294DE25888;

1.1.127.3
date	2013.08.06.20.28.07;	author tg;	state Exp;
branches;
next	1.1.127.4;
commitid	10052015BDF0FDDCF84;

1.1.127.4
date	2014.06.09.14.29.25;	author tg;	state Exp;
branches;
next	;
commitid	1005395C4CC1A6DB9EE;


desc
@@


1.6
log
@merge
@
text
@/*
 * Copyright (c) 1999-2002, 2009 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1983, 1987, 1993
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1983 Eric P. Allman.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sm/gen.h>

SM_IDSTR(copyright,
"@@(#) Copyright (c) 1999-2002, 2009 Proofpoint, Inc. and its suppliers.\n\
	All rights reserved.\n\
     Copyright (c) 1983, 1987, 1993\n\
	The Regents of the University of California.  All rights reserved.\n\
     Copyright (c) 1983 Eric P. Allman.  All rights reserved.\n")

SM_IDSTR(id, "@@(#)$Id: vacation.c,v 8.148 2013-11-22 20:52:02 ca Exp $")


#include <ctype.h>
#include <stdlib.h>
#include <syslog.h>
#include <time.h>
#include <unistd.h>
#ifdef EX_OK
# undef EX_OK		/* unistd.h may have another use for this */
#endif /* EX_OK */
#include <sm/sysexits.h>

#include <sm/cf.h>
#include <sm/mbdb.h>
#include "sendmail/sendmail.h"
#include <sendmail/pathnames.h>
#include "libsmdb/smdb.h"

#define ONLY_ONCE	((time_t) 0)	/* send at most one reply */
#define INTERVAL_UNDEF	((time_t) (-1))	/* no value given */

uid_t	RealUid;
gid_t	RealGid;
char	*RealUserName;
uid_t	RunAsUid;
gid_t	RunAsGid;
char	*RunAsUserName;
int	Verbose = 2;
bool	DontInitGroups = false;
uid_t	TrustedUid = 0;
BITMAP256 DontBlameSendmail;

static int readheaders __P((bool));
static bool junkmail __P((char *));
static bool nsearch __P((char *, char *));
static void usage __P((void));
static void setinterval __P((time_t));
static bool recent __P((void));
static void setreply __P((char *, time_t));
static void sendmessage __P((char *, char *, char *));
static void xclude __P((SM_FILE_T *));

/*
**  VACATION -- return a message to the sender when on vacation.
**
**	This program is invoked as a message receiver.  It returns a
**	message specified by the user to whomever sent the mail, taking
**	care not to return a message too often to prevent "I am on
**	vacation" loops.
*/

#define	VDB	".vacation"		/* vacation database */
#define	VMSG	".vacation.msg"		/* vacation message */
#define SECSPERDAY	(60 * 60 * 24)
#define DAYSPERWEEK	7

typedef struct alias
{
	char *name;
	struct alias *next;
} ALIAS;

ALIAS *Names = NULL;

SMDB_DATABASE *Db;

char From[MAXLINE];
bool CloseMBDB = false;

#if defined(__hpux) || defined(__osf__)
# ifndef SM_CONF_SYSLOG_INT
#  define SM_CONF_SYSLOG_INT	1
# endif /* SM_CONF_SYSLOG_INT */
#endif /* defined(__hpux) || defined(__osf__) */

#if SM_CONF_SYSLOG_INT
# define SYSLOG_RET_T	int
# define SYSLOG_RET	return 0
#else /* SM_CONF_SYSLOG_INT */
# define SYSLOG_RET_T	void
# define SYSLOG_RET
#endif /* SM_CONF_SYSLOG_INT */

typedef SYSLOG_RET_T SYSLOG_T __P((int, const char *, ...));
SYSLOG_T *msglog = syslog;
static SYSLOG_RET_T debuglog __P((int, const char *, ...));
static void eatmsg __P((void));
static void listdb __P((void));

/* exit after reading input */
#define EXITIT(excode)			\
{					\
	eatmsg();			\
	if (CloseMBDB)			\
	{				\
		sm_mbdb_terminate();	\
		CloseMBDB = false;	\
	}				\
	return excode;			\
}

#define EXITM(excode)			\
{					\
	if (!initdb && !list)		\
		eatmsg();		\
	if (CloseMBDB)			\
	{				\
		sm_mbdb_terminate();	\
		CloseMBDB = false;	\
	}				\
	exit(excode);			\
}

int
main(argc, argv)
	int argc;
	char **argv;
{
	bool alwaysrespond = false;
	bool initdb, exclude;
	bool runasuser = false;
	bool list = false;
	int mfail = 0, ufail = 0;
	int ch;
	int result;
	long sff;
	time_t interval;
	struct passwd *pw;
	ALIAS *cur;
	char *dbfilename = NULL;
	char *msgfilename = NULL;
	char *cfpath = NULL;
	char *name = NULL;
	char *returnaddr = NULL;
	SMDB_USER_INFO user_info;
	static char rnamebuf[MAXNAME];
	extern int optind, opterr;
	extern char *optarg;

	/* Vars needed to link with smutil */
	clrbitmap(DontBlameSendmail);
	RunAsUid = RealUid = getuid();
	RunAsGid = RealGid = getgid();
	pw = getpwuid(RealUid);
	if (pw != NULL)
	{
		if (strlen(pw->pw_name) > MAXNAME - 1)
			pw->pw_name[MAXNAME] = '\0';
		sm_snprintf(rnamebuf, sizeof rnamebuf, "%s", pw->pw_name);
	}
	else
		sm_snprintf(rnamebuf, sizeof rnamebuf,
			    "Unknown UID %d", (int) RealUid);
	RunAsUserName = RealUserName = rnamebuf;

# ifdef LOG_MAIL
	openlog("vacation", LOG_PID, LOG_MAIL);
# else /* LOG_MAIL */
	openlog("vacation", LOG_PID);
# endif /* LOG_MAIL */

	opterr = 0;
	initdb = false;
	exclude = false;
	interval = INTERVAL_UNDEF;
	*From = '\0';


#define OPTIONS	"a:C:df:Iijlm:R:r:s:t:Uxz"

	while (mfail == 0 && ufail == 0 &&
	       (ch = getopt(argc, argv, OPTIONS)) != -1)
	{
		switch((char)ch)
		{
		  case 'a':			/* alias */
			cur = (ALIAS *) malloc((unsigned int) sizeof(ALIAS));
			if (cur == NULL)
			{
				mfail++;
				break;
			}
			cur->name = optarg;
			cur->next = Names;
			Names = cur;
			break;

		  case 'C':
			cfpath = optarg;
			break;

		  case 'd':			/* debug mode */
			msglog = debuglog;
			break;

		  case 'f':		/* alternate database */
			dbfilename = optarg;
			break;

		  case 'I':			/* backward compatible */
		  case 'i':			/* init the database */
			initdb = true;
			break;

		  case 'j':
			alwaysrespond = true;
			break;

		  case 'l':
			list = true;		/* list the database */
			break;

		  case 'm':		/* alternate message file */
			msgfilename = optarg;
			break;

		  case 'R':
			returnaddr = optarg;
			break;

		  case 'r':
			if (isascii(*optarg) && isdigit(*optarg))
			{
				interval = atol(optarg) * SECSPERDAY;
				if (interval < 0)
					ufail++;
			}
			else
				interval = ONLY_ONCE;
			break;

		  case 's':		/* alternate sender name */
			(void) sm_strlcpy(From, optarg, sizeof From);
			break;

		  case 't':		/* SunOS: -t1d (default expire) */
			break;

		  case 'U':		/* run as single user mode */
			runasuser = true;
			break;

		  case 'x':
			exclude = true;
			break;

		  case 'z':
			returnaddr = "<>";
			break;

		  case '?':
		  default:
			ufail++;
			break;
		}
	}
	argc -= optind;
	argv += optind;

	if (mfail != 0)
	{
		msglog(LOG_NOTICE,
		       "vacation: can't allocate memory for alias.\n");
		EXITM(EX_TEMPFAIL);
	}
	if (ufail != 0)
		usage();

	if (argc != 1)
	{
		if (!initdb && !list && !exclude)
			usage();
		if ((pw = getpwuid(getuid())) == NULL)
		{
			msglog(LOG_ERR,
			       "vacation: no such user uid %u.\n", getuid());
			EXITM(EX_NOUSER);
		}
		name = strdup(pw->pw_name);
		user_info.smdbu_id = pw->pw_uid;
		user_info.smdbu_group_id = pw->pw_gid;
		(void) sm_strlcpy(user_info.smdbu_name, pw->pw_name,
				  SMDB_MAX_USER_NAME_LEN);
		if (chdir(pw->pw_dir) != 0)
		{
			msglog(LOG_NOTICE,
			       "vacation: no such directory %s.\n",
			       pw->pw_dir);
			EXITM(EX_NOINPUT);
		}
	}
	else if (runasuser)
	{
		name = strdup(*argv);
		if (dbfilename == NULL || msgfilename == NULL)
		{
			msglog(LOG_NOTICE,
			       "vacation: -U requires setting both -f and -m\n");
			EXITM(EX_NOINPUT);
		}
		user_info.smdbu_id = pw->pw_uid;
		user_info.smdbu_group_id = pw->pw_gid;
		(void) sm_strlcpy(user_info.smdbu_name, pw->pw_name,
			       SMDB_MAX_USER_NAME_LEN);
	}
	else
	{
		int err;
		SM_CF_OPT_T mbdbname;
		SM_MBDB_T user;

		cfpath = getcfname(0, 0, SM_GET_SENDMAIL_CF, cfpath);
		mbdbname.opt_name = "MailboxDatabase";
		mbdbname.opt_val = "pw";
		(void) sm_cf_getopt(cfpath, 1, &mbdbname);
		err = sm_mbdb_initialize(mbdbname.opt_val);
		if (err != EX_OK)
		{
			msglog(LOG_ERR,
			       "vacation: can't open mailbox database: %s.\n",
			       sm_strexit(err));
			EXITM(err);
		}
		CloseMBDB = true;
		err = sm_mbdb_lookup(*argv, &user);
		if (err == EX_NOUSER)
		{
			msglog(LOG_ERR, "vacation: no such user %s.\n", *argv);
			EXITM(EX_NOUSER);
		}
		if (err != EX_OK)
		{
			msglog(LOG_ERR,
			       "vacation: can't read mailbox database: %s.\n",
			       sm_strexit(err));
			EXITM(err);
		}
		name = strdup(user.mbdb_name);
		if (chdir(user.mbdb_homedir) != 0)
		{
			msglog(LOG_NOTICE,
			       "vacation: no such directory %s.\n",
			       user.mbdb_homedir);
			EXITM(EX_NOINPUT);
		}
		user_info.smdbu_id = user.mbdb_uid;
		user_info.smdbu_group_id = user.mbdb_gid;
		(void) sm_strlcpy(user_info.smdbu_name, user.mbdb_name,
			       SMDB_MAX_USER_NAME_LEN);
	}
	if (name == NULL)
	{
		msglog(LOG_ERR,
		       "vacation: can't allocate memory for username.\n");
		EXITM(EX_OSERR);
	}

	if (dbfilename == NULL)
		dbfilename = VDB;
	if (msgfilename == NULL)
		msgfilename = VMSG;

	sff = SFF_CREAT;
	if (getegid() != getgid())
	{
		/* Allow a set-group-ID vacation binary */
		RunAsGid = user_info.smdbu_group_id = getegid();
		sff |= SFF_OPENASROOT;
	}
	if (getuid() == 0)
	{
		/* Allow root to initialize user's vacation databases */
		sff |= SFF_OPENASROOT|SFF_ROOTOK;

		/* ... safely */
		sff |= SFF_NOSLINK|SFF_NOHLINK|SFF_REGONLY;
	}


	result = smdb_open_database(&Db, dbfilename,
				    O_CREAT|O_RDWR | (initdb ? O_TRUNC : 0),
				    S_IRUSR|S_IWUSR, sff,
				    SMDB_TYPE_DEFAULT, &user_info, NULL);
	if (result != SMDBE_OK)
	{
		msglog(LOG_NOTICE, "vacation: %s: %s\n", dbfilename,
		       sm_errstring(result));
		EXITM(EX_DATAERR);
	}

	if (list)
	{
		listdb();
		(void) Db->smdb_close(Db);
		exit(EX_OK);
	}

	if (interval != INTERVAL_UNDEF)
		setinterval(interval);

	if (initdb && !exclude)
	{
		(void) Db->smdb_close(Db);
		exit(EX_OK);
	}

	if (exclude)
	{
		xclude(smioin);
		(void) Db->smdb_close(Db);
		EXITM(EX_OK);
	}

	if ((cur = (ALIAS *) malloc((unsigned int) sizeof(ALIAS))) == NULL)
	{
		msglog(LOG_NOTICE,
		       "vacation: can't allocate memory for username.\n");
		(void) Db->smdb_close(Db);
		EXITM(EX_OSERR);
	}
	cur->name = name;
	cur->next = Names;
	Names = cur;

	result = readheaders(alwaysrespond);
	if (result == EX_OK && !recent())
	{
		time_t now;

		(void) time(&now);
		setreply(From, now);
		(void) Db->smdb_close(Db);
		sendmessage(name, msgfilename, returnaddr);
	}
	else
		(void) Db->smdb_close(Db);
	if (result == EX_NOUSER)
		result = EX_OK;
	exit(result);
}

/*
** EATMSG -- read stdin till EOF
**
**	Parameters:
**		none.
**
**	Returns:
**		nothing.
**
*/

static void
eatmsg()
{
	/*
	**  read the rest of the e-mail and ignore it to avoid problems
	**  with EPIPE in sendmail
	*/
	while (getc(stdin) != EOF)
		continue;
}

/*
** READHEADERS -- read mail headers
**
**	Parameters:
**		alwaysrespond -- respond regardless of whether msg is to me
**
**	Returns:
**		a exit code: NOUSER if no reply, OK if reply, * if error
**
**	Side Effects:
**		may exit().
**
*/

static int
readheaders(alwaysrespond)
	bool alwaysrespond;
{
	bool tome, cont;
	register char *p;
	register ALIAS *cur;
	char buf[MAXLINE];

	cont = false;
	tome = alwaysrespond;
	while (sm_io_fgets(smioin, SM_TIME_DEFAULT, buf, sizeof(buf)) >= 0 &&
	       *buf != '\n')
	{
		switch(*buf)
		{
		  case 'F':		/* "From " */
			cont = false;
			if (strncmp(buf, "From ", 5) == 0)
			{
				bool quoted = false;

				p = buf + 5;
				while (*p != '\0')
				{
					/* escaped character */
					if (*p == '\\')
					{
						p++;
						if (*p == '\0')
						{
							msglog(LOG_NOTICE,
							       "vacation: badly formatted \"From \" line.\n");
							EXITIT(EX_DATAERR);
						}
					}
					else if (*p == '"')
						quoted = !quoted;
					else if (*p == '\r' || *p == '\n')
						break;
					else if (*p == ' ' && !quoted)
						break;
					p++;
				}
				if (quoted)
				{
					msglog(LOG_NOTICE,
					       "vacation: badly formatted \"From \" line.\n");
					EXITIT(EX_DATAERR);
				}
				*p = '\0';

				/* ok since both strings have MAXLINE length */
				if (*From == '\0')
					(void) sm_strlcpy(From, buf + 5,
							  sizeof From);
				if ((p = strchr(buf + 5, '\n')) != NULL)
					*p = '\0';
				if (junkmail(buf + 5))
					EXITIT(EX_NOUSER);
			}
			break;

		  case 'P':		/* "Precedence:" */
		  case 'p':
			cont = false;
			if (strlen(buf) <= 10 ||
			    strncasecmp(buf, "Precedence", 10) != 0 ||
			    (buf[10] != ':' && buf[10] != ' ' &&
			     buf[10] != '\t'))
				break;
			if ((p = strchr(buf, ':')) == NULL)
				break;
			while (*++p != '\0' && isascii(*p) && isspace(*p));
			if (*p == '\0')
				break;
			if (strncasecmp(p, "junk", 4) == 0 ||
			    strncasecmp(p, "bulk", 4) == 0 ||
			    strncasecmp(p, "list", 4) == 0)
				EXITIT(EX_NOUSER);
			break;

		  case 'C':		/* "Cc:" */
		  case 'c':
			if (strncasecmp(buf, "Cc:", 3) != 0)
				break;
			cont = true;
			goto findme;

		  case 'T':		/* "To:" */
		  case 't':
			if (strncasecmp(buf, "To:", 3) != 0)
				break;
			cont = true;
			goto findme;

		  default:
			if (!isascii(*buf) || !isspace(*buf) || !cont || tome)
			{
				cont = false;
				break;
			}
findme:
			for (cur = Names;
			     !tome && cur != NULL;
			     cur = cur->next)
				tome = nsearch(cur->name, buf);
		}
	}
	if (!tome)
		EXITIT(EX_NOUSER);
	if (*From == '\0')
	{
		msglog(LOG_NOTICE, "vacation: no initial \"From \" line.\n");
		EXITIT(EX_DATAERR);
	}
	EXITIT(EX_OK);
}

/*
** NSEARCH --
**	do a nice, slow, search of a string for a substring.
**
**	Parameters:
**		name -- name to search.
**		str -- string in which to search.
**
**	Returns:
**		is name a substring of str?
**
*/

static bool
nsearch(name, str)
	register char *name, *str;
{
	register size_t len;
	register char *s;

	len = strlen(name);

	for (s = str; *s != '\0'; ++s)
	{
		/*
		**  Check to make sure that the string matches and
		**  the previous character is not an alphanumeric and
		**  the next character after the match is not an alphanumeric.
		**
		**  This prevents matching "eric" to "derick" while still
		**  matching "eric" to "<eric+detail>".
		*/

		if (tolower(*s) == tolower(*name) &&
		    strncasecmp(name, s, len) == 0 &&
		    (s == str || !isascii(*(s - 1)) || !isalnum(*(s - 1))) &&
		    (!isascii(*(s + len)) || !isalnum(*(s + len))))
			return true;
	}
	return false;
}

/*
** JUNKMAIL --
**	read the header and return if automagic/junk/bulk/list mail
**
**	Parameters:
**		from -- sender address.
**
**	Returns:
**		is this some automated/junk/bulk/list mail?
**
*/

struct ignore
{
	char	*name;
	size_t	len;
};

typedef struct ignore IGNORE_T;

#define MAX_USER_LEN 256	/* maximum length of local part (sender) */

/* delimiters for the local part of an address */
#define isdelim(c)	((c) == '%' || (c) == '@@' || (c) == '+')

static bool
junkmail(from)
	char *from;
{
	bool quot;
	char *e;
	size_t len;
	IGNORE_T *cur;
	char sender[MAX_USER_LEN];
	static IGNORE_T ignore[] =
	{
		{ "postmaster",		10	},
		{ "uucp",		4	},
		{ "mailer-daemon",	13	},
		{ "mailer",		6	},
		{ NULL,			0	}
	};

	static IGNORE_T ignorepost[] =
	{
		{ "-request",		8	},
		{ "-relay",		6	},
		{ "-owner",		6	},
		{ NULL,			0	}
	};

	static IGNORE_T ignorepre[] =
	{
		{ "owner-",		6	},
		{ NULL,			0	}
	};

	/*
	**  This is mildly amusing, and I'm not positive it's right; trying
	**  to find the "real" name of the sender, assuming that addresses
	**  will be some variant of:
	**
	**  From site!site!SENDER%site.domain%site.domain@@site.domain
	*/

	quot = false;
	e = from;
	len = 0;
	while (*e != '\0' && (quot || !isdelim(*e)))
	{
		if (*e == '"')
		{
			quot = !quot;
			++e;
			continue;
		}
		if (*e == '\\')
		{
			if (*(++e) == '\0')
			{
				/* '\\' at end of string? */
				break;
			}
			if (len < MAX_USER_LEN)
				sender[len++] = *e;
			++e;
			continue;
		}
		if (*e == '!' && !quot)
		{
			len = 0;
			sender[len] = '\0';
		}
		else
			if (len < MAX_USER_LEN)
				sender[len++] = *e;
		++e;
	}
	if (len < MAX_USER_LEN)
		sender[len] = '\0';
	else
		sender[MAX_USER_LEN - 1] = '\0';

	if (len <= 0)
		return false;
#if 0
	if (quot)
		return false;	/* syntax error... */
#endif /* 0 */

	/* test prefixes */
	for (cur = ignorepre; cur->name != NULL; ++cur)
	{
		if (len >= cur->len &&
		    strncasecmp(cur->name, sender, cur->len) == 0)
			return true;
	}

	/*
	**  If the name is truncated, don't test the rest.
	**	We could extract the "tail" of the sender address and
	**	compare it it ignorepost, however, it seems not worth
	**	the effort.
	**	The address surely can't match any entry in ignore[]
	**	(as long as all of them are shorter than MAX_USER_LEN).
	*/

	if (len > MAX_USER_LEN)
		return false;

	/* test full local parts */
	for (cur = ignore; cur->name != NULL; ++cur)
	{
		if (len == cur->len &&
		    strncasecmp(cur->name, sender, cur->len) == 0)
			return true;
	}

	/* test postfixes */
	for (cur = ignorepost; cur->name != NULL; ++cur)
	{
		if (len >= cur->len &&
		    strncasecmp(cur->name, e - cur->len - 1,
				cur->len) == 0)
			return true;
	}
	return false;
}

#define	VIT	"__VACATION__INTERVAL__TIMER__"

/*
** RECENT --
**	find out if user has gotten a vacation message recently.
**
**	Parameters:
**		none.
**
**	Returns:
**		true iff user has gotten a vacation message recently.
**
*/

static bool
recent()
{
	SMDB_DBENT key, data;
	time_t then, next;
	bool trydomain = false;
	int st;
	char *domain;

	memset(&key, '\0', sizeof key);
	memset(&data, '\0', sizeof data);

	/* get interval time */
	key.data = VIT;
	key.size = sizeof(VIT);

	st = Db->smdb_get(Db, &key, &data, 0);
	if (st != SMDBE_OK)
		next = SECSPERDAY * DAYSPERWEEK;
	else
		memmove(&next, data.data, sizeof(next));

	memset(&data, '\0', sizeof data);

	/* get record for this address */
	key.data = From;
	key.size = strlen(From);

	do
	{
		st = Db->smdb_get(Db, &key, &data, 0);
		if (st == SMDBE_OK)
		{
			memmove(&then, data.data, sizeof(then));
			if (next == ONLY_ONCE || then == ONLY_ONCE ||
			    then + next > time(NULL))
				return true;
		}
		if ((trydomain = !trydomain) &&
		    (domain = strchr(From, '@@')) != NULL)
		{
			key.data = domain;
			key.size = strlen(domain);
		}
	} while (trydomain);
	return false;
}

/*
** SETINTERVAL --
**	store the reply interval
**
**	Parameters:
**		interval -- time interval for replies.
**
**	Returns:
**		nothing.
**
**	Side Effects:
**		stores the reply interval in database.
*/

static void
setinterval(interval)
	time_t interval;
{
	SMDB_DBENT key, data;

	memset(&key, '\0', sizeof key);
	memset(&data, '\0', sizeof data);

	key.data = VIT;
	key.size = sizeof(VIT);
	data.data = (char*) &interval;
	data.size = sizeof(interval);
	(void) (Db->smdb_put)(Db, &key, &data, 0);
}

/*
** SETREPLY --
**	store that this user knows about the vacation.
**
**	Parameters:
**		from -- sender address.
**		when -- last reply time.
**
**	Returns:
**		nothing.
**
**	Side Effects:
**		stores user/time in database.
*/

static void
setreply(from, when)
	char *from;
	time_t when;
{
	SMDB_DBENT key, data;

	memset(&key, '\0', sizeof key);
	memset(&data, '\0', sizeof data);

	key.data = from;
	key.size = strlen(from);
	data.data = (char*) &when;
	data.size = sizeof(when);
	(void) (Db->smdb_put)(Db, &key, &data, 0);
}

/*
** XCLUDE --
**	add users to vacation db so they don't get a reply.
**
**	Parameters:
**		f -- file pointer with list of address to exclude
**
**	Returns:
**		nothing.
**
**	Side Effects:
**		stores users in database.
*/

static void
xclude(f)
	SM_FILE_T *f;
{
	char buf[MAXLINE], *p;

	if (f == NULL)
		return;
	while (sm_io_fgets(f, SM_TIME_DEFAULT, buf, sizeof buf) >= 0)
	{
		if ((p = strchr(buf, '\n')) != NULL)
			*p = '\0';
		setreply(buf, ONLY_ONCE);
	}
}

/*
** SENDMESSAGE --
**	exec sendmail to send the vacation file to sender
**
**	Parameters:
**		myname -- user name.
**		msgfn -- name of file with vacation message.
**		sender -- use as sender address
**
**	Returns:
**		nothing.
**
**	Side Effects:
**		sends vacation reply.
*/

static void
sendmessage(myname, msgfn, sender)
	char *myname;
	char *msgfn;
	char *sender;
{
	SM_FILE_T *mfp, *sfp;
	int i;
	int pvect[2];
	char *pv[8];
	char buf[MAXLINE];

	mfp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, msgfn, SM_IO_RDONLY, NULL);
	if (mfp == NULL)
	{
		if (msgfn[0] == '/')
			msglog(LOG_NOTICE, "vacation: no %s file.\n", msgfn);
		else
			msglog(LOG_NOTICE, "vacation: no ~%s/%s file.\n",
			       myname, msgfn);
		exit(EX_NOINPUT);
	}
	if (pipe(pvect) < 0)
	{
		msglog(LOG_ERR, "vacation: pipe: %s", sm_errstring(errno));
		exit(EX_OSERR);
	}
	pv[0] = "sendmail";
	pv[1] = "-oi";
	pv[2] = "-f";
	if (sender != NULL)
		pv[3] = sender;
	else
		pv[3] = myname;
	pv[4] = "--";
	pv[5] = From;
	pv[6] = NULL;
	i = fork();
	if (i < 0)
	{
		msglog(LOG_ERR, "vacation: fork: %s", sm_errstring(errno));
		exit(EX_OSERR);
	}
	if (i == 0)
	{
		(void) dup2(pvect[0], 0);
		(void) close(pvect[0]);
		(void) close(pvect[1]);
		(void) sm_io_close(mfp, SM_TIME_DEFAULT);
		(void) execv(_PATH_SENDMAIL, pv);
		msglog(LOG_ERR, "vacation: can't exec %s: %s",
			_PATH_SENDMAIL, sm_errstring(errno));
		exit(EX_UNAVAILABLE);
	}
	/* check return status of the following calls? XXX */
	(void) close(pvect[0]);
	if ((sfp = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT,
			      (void *) &(pvect[1]),
			      SM_IO_WRONLY, NULL)) != NULL)
	{
#if _FFR_VAC_WAIT4SM
# ifdef WAITUNION
		union wait st;
# else /* WAITUNION */
		auto int st;
# endif /* WAITUNION */
#endif /* _FFR_VAC_WAIT4SM */

		(void) sm_io_fprintf(sfp, SM_TIME_DEFAULT, "To: %s\n", From);
		(void) sm_io_fprintf(sfp, SM_TIME_DEFAULT,
				     "Auto-Submitted: auto-replied\n");
		while (sm_io_fgets(mfp, SM_TIME_DEFAULT, buf, sizeof buf) >= 0)
			(void) sm_io_fputs(sfp, SM_TIME_DEFAULT, buf);
		(void) sm_io_close(mfp, SM_TIME_DEFAULT);
		(void) sm_io_close(sfp, SM_TIME_DEFAULT);
#if _FFR_VAC_WAIT4SM
		(void) wait(&st);
#endif /* _FFR_VAC_WAIT4SM */
	}
	else
	{
		(void) sm_io_close(mfp, SM_TIME_DEFAULT);
		msglog(LOG_ERR, "vacation: can't open pipe to sendmail");
		exit(EX_UNAVAILABLE);
	}
}

static void
usage()
{
	msglog(LOG_NOTICE,
	       "uid %u: usage: vacation [-a alias] [-C cfpath] [-d] [-f db] [-i] [-j] [-l] [-m msg] [-R returnaddr] [-r interval] [-s sender] [-t time] [-U] [-x] [-z] login\n",
	       getuid());
	exit(EX_USAGE);
}

/*
** LISTDB -- list the contents of the vacation database
**
**	Parameters:
**		none.
**
**	Returns:
**		nothing.
*/

static void
listdb()
{
	int result;
	time_t t;
	SMDB_CURSOR *cursor = NULL;
	SMDB_DBENT db_key, db_value;

	memset(&db_key, '\0', sizeof db_key);
	memset(&db_value, '\0', sizeof db_value);

	result = Db->smdb_cursor(Db, &cursor, 0);
	if (result != SMDBE_OK)
	{
		sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
			      "vacation: set cursor: %s\n",
			      sm_errstring(result));
		return;
	}

	while ((result = cursor->smdbc_get(cursor, &db_key, &db_value,
					   SMDB_CURSOR_GET_NEXT)) == SMDBE_OK)
	{
		char *timestamp;

		/* skip magic VIT entry */
		if (db_key.size == strlen(VIT) + 1 &&
		    strncmp((char *)db_key.data, VIT,
			    (int)db_key.size - 1) == 0)
			continue;

		/* skip bogus values */
		if (db_value.size != sizeof t)
		{
			sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
				      "vacation: %.*s invalid time stamp\n",
				      (int) db_key.size, (char *) db_key.data);
			continue;
		}

		memcpy(&t, db_value.data, sizeof t);

		if (db_key.size > 40)
			db_key.size = 40;

		if (t <= 0)
		{
			/* must be an exclude */
			timestamp = "(exclusion)\n";
		}
		else
		{
			timestamp = ctime(&t);
		}
		sm_io_fprintf(smioout, SM_TIME_DEFAULT, "%-40.*s %-10s",
			      (int) db_key.size, (char *) db_key.data,
			      timestamp);

		memset(&db_key, '\0', sizeof db_key);
		memset(&db_value, '\0', sizeof db_value);
	}

	if (result != SMDBE_OK && result != SMDBE_LAST_ENTRY)
	{
		sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
			      "vacation: get value at cursor: %s\n",
			      sm_errstring(result));
		if (cursor != NULL)
		{
			(void) cursor->smdbc_close(cursor);
			cursor = NULL;
		}
		return;
	}
	(void) cursor->smdbc_close(cursor);
	cursor = NULL;
}

/*
** DEBUGLOG -- write message to standard error
**
**	Append a message to the standard error for the convenience of
**	end-users debugging without access to the syslog messages.
**
**	Parameters:
**		i -- syslog log level
**		fmt -- string format
**
**	Returns:
**		nothing.
*/

/*VARARGS2*/
static SYSLOG_RET_T
#ifdef __STDC__
debuglog(int i, const char *fmt, ...)
#else /* __STDC__ */
debuglog(i, fmt, va_alist)
	int i;
	const char *fmt;
	va_dcl
#endif /* __STDC__ */

{
	SM_VA_LOCAL_DECL

	SM_VA_START(ap, fmt);
	sm_io_vfprintf(smioerr, SM_TIME_DEFAULT, fmt, ap);
	SM_VA_END(ap);
	SYSLOG_RET;
}
@


1.5
log
@merge
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2002, 2009 Sendmail, Inc. and its suppliers.
d17 1
a17 1
"@@(#) Copyright (c) 1999-2002, 2009 Sendmail, Inc. and its suppliers.\n\
d23 1
a23 1
SM_IDSTR(id, "@@(#)$Id: vacation.c,v 8.147 2013/03/12 15:24:56 ca Exp $")
@


1.4
log
@merge newer sendmail; fix and correct; reduce upstream diffs; prep for deb
@
text
@d23 1
a23 1
SM_IDSTR(id, "@@(#)$Id: vacation.c,v 8.146 2009/08/07 21:28:39 ca Exp $")
d512 1
a512 1
	while (sm_io_fgets(smioin, SM_TIME_DEFAULT, buf, sizeof(buf)) &&
d957 1
a957 1
	while (sm_io_fgets(f, SM_TIME_DEFAULT, buf, sizeof buf))
d1052 1
a1052 1
		while (sm_io_fgets(mfp, SM_TIME_DEFAULT, buf, sizeof buf))
@


1.3
log
@merge and reduce diffs against upstream
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2002 Sendmail, Inc. and its suppliers.
d17 1
a17 1
"@@(#) Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.\n\
d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: vacation.c,v 8.144 2007/05/11 18:50:36 ca Exp $")
d156 1
a156 1
	char *name;
d302 1
a302 1
		name = pw->pw_name;
d317 1
a317 1
		name = *argv;
d361 1
a361 1
		name = user.mbdb_name;
d374 6
d1041 8
d1056 3
@


1.2
log
@upgrade from sendmail 8.14.1 to 8.14.2 ourselves:
> From donotreply@@lists.sendmail.org Fri Nov  2 02:46:04 2007
> From: Claus Assmann <donotreply@@lists.sendmail.org>
Message-ID: <200711020234.lA22YPul046763@@lists.sendmail.org>
To: sendmail-announce@@sendmail.org
Date: Thu, 1 Nov 2007 19:34:25 -0700 (PDT)
Subject: sendmail 8.14.2 available

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Sendmail, Inc., and the Sendmail Consortium announce the availability
of sendmail 8.14.2 which fixes some problems, e.g.,

- - an important bug in the milter function smfi_chgfrom() which could
  cause the loss of a message body.
- - the handling of queued messages with 8 bit characters in From:
  or To: header which could be "mistaken" for internal control
  characters during a queue run and trigger various consistency checks.
- - the handling of lines longer than MAXLINE-1 characters in certain
  cases.

A complete list of changes can be found in the release notes (see
below).

Please send bug reports and general feedback to one of the addresses
listed at: http://www.sendmail.org/email-addresses.html

The version can be found at

ftp://ftp.sendmail.org/pub/sendmail/sendmail.8.14.2.tar.gz
ftp://ftp.sendmail.org/pub/sendmail/sendmail.8.14.2.tar.gz.sig
ftp://ftp.sendmail.org/pub/sendmail/sendmail.8.14.2.tar.Z
ftp://ftp.sendmail.org/pub/sendmail/sendmail.8.14.2.tar.Z.sig

MD5 signatures:
cf784b9f20c32949ae1f38f3eae29875 sendmail.8.14.2.tar.Z
f788d6986f12a81ac958195b045a529d sendmail.8.14.2.tar.Z.sig
1c1472365344ca8061d6453c43c9a831 sendmail.8.14.2.tar.gz
2ae4b6175a08e8a6cda992db20141d81 sendmail.8.14.2.tar.gz.sig

You either need the first two files or the third and fourth, i.e.,
the gzip'ed version or the compressed version and the corresponding
sig file.  The PGP signature was created using the Sendmail Signing
Key/2007, available on the web site (http://www.sendmail.org/) or
on the public key servers.

Since sendmail 8.11 and later includes hooks to cryptography, the
following information from OpenSSL applies to sendmail as well.

   PLEASE REMEMBER THAT EXPORT/IMPORT AND/OR USE OF STRONG CRYPTOGRAPHY
   SOFTWARE, PROVIDING CRYPTOGRAPHY HOOKS OR EVEN JUST COMMUNICATING
   TECHNICAL DETAILS ABOUT CRYPTOGRAPHY SOFTWARE IS ILLEGAL IN SOME
   PARTS OF THE WORLD.  SO, WHEN YOU IMPORT THIS PACKAGE TO YOUR
   COUNTRY, RE-DISTRIBUTE IT FROM THERE OR EVEN JUST EMAIL TECHNICAL
   SUGGESTIONS OR EVEN SOURCE PATCHES TO THE AUTHOR OR OTHER PEOPLE
   YOU ARE STRONGLY ADVISED TO PAY CLOSE ATTENTION TO ANY EXPORT/IMPORT
   AND/OR USE LAWS WHICH APPLY TO YOU. THE AUTHORS ARE NOT LIABLE FOR
   ANY VIOLATIONS YOU MAKE HERE. SO BE CAREFUL, IT IS YOUR RESPONSIBILITY.


			SENDMAIL RELEASE NOTES
      $Id: RELEASE_NOTES,v 8.1909 2007/10/31 16:04:13 ca Exp $


This listing shows the version of the sendmail binary, the version
of the sendmail configuration files, the date of release, and a
summary of the changes in that release.

8.14.2/8.14.2	2007/11/01
	If a message was queued and it contained 8 bit characters in
		a From: or To: header, then those characters could be
		"mistaken" for internal control characters during a queue
		run and trigger various consistency checks.  Problem
		noted by Neil Rickert of Northern Illinois University.
	If MaxMimeHeaderLength is set to a value greater than 0 (which
		it is by default) then even if the Linelimit parameter
		is 0, sendmail corrupted in the non-transfer-encoding
		case every MAXLINE-1 characters.  Patch from John Gardiner
		Myers of Proofpoint.
	Setting the suboption DeliveryMode for DaemonPortOptions did not
		work in earlier 8.14 versions.
	Note: DeliveryMode=interactive is silently converted to
		background if a milter can reject or delete a recipient.
		Prior to 8.14 this happened only if milter could delete
		recipients.
	ClientRate should trigger when the limit was exceeded (as
		documented), not when it was reached.  Patch from
		John Beck of Sun Microsystems.
	Force a queue run for -qGqueuegroup even if no runners are
		specified (R=0) and forking (F=f) is requested.
	When multiple results are requested for a DNS map lookup
		(-z and -Z), return only those that are relevant for
		the query (not also those in the "additional section".)
	If the message transfer time to sendmail (when acting as server)
		exceeds Timeout.queuewarn or Timeout.queuereturn and
		the message is refused (by a milter), sendmail previously
		created a delivery status notification (DSN).  Patch
		from Doug Heath of The Hertz Corporation.
	A code change in Cyrus-SASL 2.1.22 for sasl_decode64() requires
		the MTA to deal with some input (i.e., "=") itself.
		Problem noted by Eliot Lear.
	sendmail counted a delivery as successful if PIPELINING is
		compiled in but not offered by the server and the
		delivery failed temporarily.  Patch from Werner Wiethege.
	If getting the result of an LDAP query times out then close the
		map so it will be reopened on the next lookup.  This
		should help "failover" configurations that specify more
		than one LDAP server.
	If check_compat returns $#discard then a "savemail panic" could
		be triggered under some circumstances (e.g., requiring
		a system which does not have the compile time flag
		HASFLOCK set). Based on patch by Motonori Nakamura
		of National Institute of Informatics, Japan.
	If a milter rejected a recipient, the count for nrcpts= in the
		logfile entry might have been wrong.  Problem found by
		Petra Humann of TU Dresden.
	If a milter invoked smfi_chgfrom() where ESMTP arguments are not
		NULL, the message body was lost.  Patch from Motonori
		Nakamura of National Institute of Informatics, Japan.
	sendmail(8) had a bogus space in -qGname.  Patch from Peng Haitao.
	CONTRIB: buildvirtuser: Preserve ownership and permissions when
		replacing files.
	CONTRIB: buildvirtuser: Skip dot-files (e.g., .cvsignore) when
		reading the /etc/mail/virtusers/ directory.
	CONTRIB: buildvirtuser: Emit warnings instead of exiting where
		appropriate.
	LIBMILTER: Fix ABI backwards compatibility so milters compiled
		against an older libmilter.so shared library can use an
		8.14 libmilter.so shared library.
	LIBMILTER: smfi_version() did not properly extract the patchlevel
		from the version number, however, the returned value was
		correct for the current libmilter version.

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.5 (OpenBSD)

iQCVAwUBRyqEOs8etQMiMnoBAQKNdQP/cQKfjVP7qTi0Ol/OgR7AnvCaerCxiQ5J
y1uxjwXs2s+RemX0u5a4c0agoLscTKU5Ot6uzOdvKvZd0/unr/IkzuXZBF9LsnlZ
X1wS4GXQDXKDfazvwdwOUgxkthMZU1TiVFj/GH5TOfHqVUO5Ho/yRfAQoAn3taFc
5jeg+A3+M9M=
=DJHS
-----END PGP SIGNATURE-----
@
text
@d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: vacation.c,v 8.143 2006/12/19 19:00:43 ca Exp $")
@


1.2.2.1
log
@MFC sendmail update to 8.14.3

agreed bsiegert@@
@
text
@d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: vacation.c,v 8.144 2007/05/11 18:50:36 ca Exp $")
@


1.1
log
@Initial revision
@
text
@d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: vacation.c,v 8.142 2004/11/02 18:25:33 ca Exp $")
d49 1
a49 1
uid_t	RunAsGid;
d56 10
a161 7
	extern void usage __P((void));
	extern void setinterval __P((time_t));
	extern int readheaders __P((bool));
	extern bool recent __P((void));
	extern void setreply __P((char *, time_t));
	extern void sendmessage __P((char *, char *, char *));
	extern void xclude __P((SM_FILE_T *));
d495 1
a495 1
int
a502 2
	extern bool junkmail __P((char *));
	extern bool nsearch __P((char *, char *));
d627 1
a627 1
bool
d681 1
a681 1
bool
d819 1
a819 1
bool
d881 1
a881 1
void
d912 1
a912 1
void
d943 1
a943 1
void
d975 1
a975 1
void
d1051 1
a1051 1
void
@


1.1.127.1
log
@Import Sendmail 8.14.3, suitably stripped down by the not yet committed
contrib/samples/import-3rdpty,v 1.35; we have some new and renamed files
@
text
@d23 1
a23 1
SM_IDSTR(id, "@@(#)$Id: vacation.c,v 8.144 2007/05/11 18:50:36 ca Exp $")
d49 1
a49 1
gid_t	RunAsGid;
a55 10
static int readheaders __P((bool));
static bool junkmail __P((char *));
static bool nsearch __P((char *, char *));
static void usage __P((void));
static void setinterval __P((time_t));
static bool recent __P((void));
static void setreply __P((char *, time_t));
static void sendmessage __P((char *, char *, char *));
static void xclude __P((SM_FILE_T *));

d152 7
d492 1
a492 1
static int
d500 2
d626 1
a626 1
static bool
d680 1
a680 1
static bool
d818 1
a818 1
static bool
d880 1
a880 1
static void
d911 1
a911 1
static void
d942 1
a942 1
static void
d974 1
a974 1
static void
d1050 1
a1050 1
static void
@


1.1.127.2
log
@Import sendmail.8.14.5.Beta0.tar.gz
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2002, 2009 Sendmail, Inc. and its suppliers.
d17 1
a17 1
"@@(#) Copyright (c) 1999-2002, 2009 Sendmail, Inc. and its suppliers.\n\
d23 1
a23 1
SM_IDSTR(id, "@@(#)$Id: vacation.c,v 8.146 2009/08/07 21:28:39 ca Exp $")
d156 1
a156 1
	char *name = NULL;
d302 1
a302 1
		name = strdup(pw->pw_name);
d317 1
a317 1
		name = strdup(*argv);
d361 1
a361 1
		name = strdup(user.mbdb_name);
a373 6
	if (name == NULL)
	{
		msglog(LOG_ERR,
		       "vacation: can't allocate memory for username.\n");
		EXITM(EX_OSERR);
	}
a1034 8
#if _FFR_VAC_WAIT4SM
# ifdef WAITUNION
		union wait st;
# else /* WAITUNION */
		auto int st;
# endif /* WAITUNION */
#endif /* _FFR_VAC_WAIT4SM */

a1041 3
#if _FFR_VAC_WAIT4SM
		(void) wait(&st);
#endif /* _FFR_VAC_WAIT4SM */
@


1.1.127.3
log
@Update
@
text
@d23 1
a23 1
SM_IDSTR(id, "@@(#)$Id: vacation.c,v 8.147 2013/03/12 15:24:56 ca Exp $")
d512 1
a512 1
	while (sm_io_fgets(smioin, SM_TIME_DEFAULT, buf, sizeof(buf)) >= 0 &&
d957 1
a957 1
	while (sm_io_fgets(f, SM_TIME_DEFAULT, buf, sizeof buf) >= 0)
d1052 1
a1052 1
		while (sm_io_fgets(mfp, SM_TIME_DEFAULT, buf, sizeof buf) >= 0)
@


1.1.127.4
log
@Import sendmail 8.14.9
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2002, 2009 Proofpoint, Inc. and its suppliers.
d17 1
a17 1
"@@(#) Copyright (c) 1999-2002, 2009 Proofpoint, Inc. and its suppliers.\n\
d23 1
a23 1
SM_IDSTR(id, "@@(#)$Id: vacation.c,v 8.148 2013-11-22 20:52:02 ca Exp $")
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import Sendmail 8.14.0 via OpenBSD
@
text
@d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: vacation.c,v 8.143 2006/12/19 19:00:43 ca Exp $")
a55 10
static int readheaders __P((bool));
static bool junkmail __P((char *));
static bool nsearch __P((char *, char *));
static void usage __P((void));
static void setinterval __P((time_t));
static bool recent __P((void));
static void setreply __P((char *, time_t));
static void sendmessage __P((char *, char *, char *));
static void xclude __P((SM_FILE_T *));

d152 7
d492 1
a492 1
static int
d500 2
d626 1
a626 1
static bool
d680 1
a680 1
static bool
d818 1
a818 1
static bool
d880 1
a880 1
static void
d911 1
a911 1
static void
d942 1
a942 1
static void
d974 1
a974 1
static void
d1050 1
a1050 1
static void
@


1.1.1.3
log
@OpenBSD finally has upgraded their sendmail, too…
@
text
@d23 1
a23 1
SM_IDSTR(id, "@@(#)$Sendmail: vacation.c,v 8.144 2007/05/11 18:50:36 ca Exp $")
d49 1
a49 1
gid_t	RunAsGid;
@


1.1.1.4
log
@Replace “$Sendmail: ” with “$Id: ” (the latter is used by upstream)
@
text
@d23 1
a23 1
SM_IDSTR(id, "@@(#)$Id: vacation.c,v 8.144 2007/05/11 18:50:36 ca Exp $")
@


1.1.1.5
log
@Import OpenBSD’s sendmail 8.14.5, RCS IDs properly sedded back
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2002, 2009 Sendmail, Inc. and its suppliers.
d17 1
a17 1
"@@(#) Copyright (c) 1999-2002, 2009 Sendmail, Inc. and its suppliers.\n\
d23 1
a23 1
SM_IDSTR(id, "@@(#)$Id: vacation.c,v 8.146 2009/08/07 21:28:39 ca Exp $")
d156 1
a156 1
	char *name = NULL;
d302 1
a302 1
		name = strdup(pw->pw_name);
d317 1
a317 1
		name = strdup(*argv);
d361 1
a361 1
		name = strdup(user.mbdb_name);
a373 6
	if (name == NULL)
	{
		msglog(LOG_ERR,
		       "vacation: can't allocate memory for username.\n");
		EXITM(EX_OSERR);
	}
a1034 8
#if _FFR_VAC_WAIT4SM
# ifdef WAITUNION
		union wait st;
# else /* WAITUNION */
		auto int st;
# endif /* WAITUNION */
#endif /* _FFR_VAC_WAIT4SM */

a1041 3
#if _FFR_VAC_WAIT4SM
		(void) wait(&st);
#endif /* _FFR_VAC_WAIT4SM */
@


