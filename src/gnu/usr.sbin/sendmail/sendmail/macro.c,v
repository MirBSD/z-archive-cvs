head	1.6;
access;
symbols
	sendmail-8_14_9:1.1.127.2
	sendmail-8_14_7:1.1.127.1
	sendmail-8_14_6:1.1.127.1
	sendmail-8_14_5-ERRATA-1:1.1.127.1
	mbsd-20101220_mergebase:1.1.1.3.2.1
	sendmail-8_14_5:1.1.127.1
	cvs-201107021500:1.1.1.4
	cvs-20101220:1.1.1.4
	mbsd-20101220:1.1.1.3.0.2
	cvs-201012191730:1.1.1.3
	sendmail-8_14_5_Beta0:1.1.127.1
	sendmail-8_14_3:1.1.127.1
	sendmail:1.1.127
	cvs-200812170000:1.1.1.3
	cvs-200805071200:1.1.1.3
	MIRBSD_10:1.2.0.2
	MIRBSD_10_BASE:1.2
	cvs-200803022030:1.1.1.2
	cvs-200707152000:1.1.1.2
	cvs-200704292000:1.1.1.2
	cvs-200702051700:1.1.1.2
	cvs-200609121900:1.1.1.1
	MIRBSD_9_BASE:1.1.1.1
	cvs-200606151800:1.1.1.1
	cvs-200603231300:1.1.1.1
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200507211800:1.1.1.1
	cvs-200504262050:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2017.04.20.21.12.35;	author tg;	state Exp;
branches;
next	1.5;
commitid	10058F9245072EC1AC2;

1.5
date	2014.06.09.15.17.48;	author tg;	state Exp;
branches;
next	1.4;
commitid	1005395CFC65E5646F1;

1.4
date	2011.07.02.15.04.09;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004E0F31C5496AB95F;

1.3
date	2008.05.07.13.15.26;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004821AB7510EE48FB;

1.2
date	2008.03.02.21.41.14;	author tg;	state Exp;
branches
	1.2.2.1;
next	1.1;
commitid	10047CB1EE51190ECAF;

1.1
date	2005.02.05.17.24.28;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.127.1;
next	;

1.2.2.1
date	2008.05.17.19.12.10;	author tg;	state Exp;
branches;
next	;
commitid	100482F2DC168C89AEA;

1.1.1.1
date	2005.02.05.17.24.28;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.02.05.17.06.30;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	10045C763C551AABAF7;

1.1.1.3
date	2008.05.07.12.31.51;	author tg;	state Exp;
branches
	1.1.1.3.2.1;
next	1.1.1.4;
commitid	1004821A13C1FC036E1;

1.1.1.4
date	2011.07.02.15.00.46;	author tg;	state Exp;
branches;
next	;
commitid	1004E0F31C5496AB95F;

1.1.1.3.2.1
date	2011.07.02.15.02.56;	author tg;	state Exp;
branches;
next	;
commitid	1004E0F31C5496AB95F;

1.1.127.1
date	2010.12.19.14.45.44;	author tg;	state Exp;
branches;
next	1.1.127.2;
commitid	1004D0E1A94384778FD;

1.1.127.2
date	2014.06.09.14.29.16;	author tg;	state Exp;
branches;
next	;
commitid	1005395C4CC1A6DB9EE;


desc
@@


1.6
log
@apply SMTP session reuse bugfix from
Message-ID: <201603011456.u21EuLUA020526@@lists.sendmail.org>
@
text
@/*
 * Copyright (c) 1998-2001, 2003, 2006, 2007 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>

SM_RCSID("@@(#)$Id: macro.c,v 8.108 2013-11-22 20:51:55 ca Exp $")

#include <sm/sendmail.h>
#if MAXMACROID != (BITMAPBITS - 1)
	ERROR Read the comment in conf.h
#endif /* MAXMACROID != (BITMAPBITS - 1) */

static char	*MacroName[MAXMACROID + 1];	/* macro id to name table */

/*
**  Codes for long named macros.
**  See also macname():
	* if not ASCII printable, look up the name *
	if (n <= 0x20 || n > 0x7f)
**  First use 1 to NEXTMACROID_L, then use NEXTMACROID_H to MAXMACROID.
*/

#define NEXTMACROID_L 037
#define NEXTMACROID_H 0240

#if _FFR_MORE_MACROS
/* table for next id in non-printable ASCII range: disallow some value */
static int NextMIdTable[] =
{
	/*  0  nul */	 1,
	/*  1  soh */	 2,
	/*  2  stx */	 3,
	/*  3  etx */	 4,
	/*  4  eot */	 5,
	/*  5  enq */	 6,
	/*  6  ack */	 7,
	/*  7  bel */	 8,
	/*  8  bs  */	14,
	/*  9  ht  */	-1,
	/* 10  nl  */	-1,
	/* 11  vt  */	-1,
	/* 12  np  */	-1,
	/* 13  cr  */	-1,
	/* 14  so  */	15,
	/* 15  si  */	16,
	/* 16  dle */	17,
	/* 17  dc1 */	18,
	/* 18  dc2 */	19,
	/* 19  dc3 */	20,
	/* 20  dc4 */	21,
	/* 21  nak */	22,
	/* 22  syn */	23,
	/* 23  etb */	24,
	/* 24  can */	25,
	/* 25  em  */	26,
	/* 26  sub */	27,
	/* 27  esc */	28,
	/* 28  fs  */	29,
	/* 29  gs  */	30,
	/* 30  rs  */	31,
	/* 31  us  */	32,
	/* 32  sp  */	-1,
};

#define NEXTMACROID(mid)	(		\
	(mid < NEXTMACROID_L) ? (NextMIdTable[mid]) :	\
	((mid < NEXTMACROID_H) ? NEXTMACROID_H : (mid + 1)))

int		NextMacroId = 1;	/* codes for long named macros */
/* see sendmail.h: Special characters in rewriting rules. */
#else /* _FFR_MORE_MACROS */
int		NextMacroId = 0240;	/* codes for long named macros */
#define NEXTMACROID(mid)	((mid) + 1)
#endif /* _FFR_MORE_MACROS */


/*
**  INITMACROS -- initialize the macro system
**
**	This just involves defining some macros that are actually
**	used internally as metasymbols to be themselves.
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		initializes several macros to be themselves.
*/

struct metamac	MetaMacros[] =
{
	/* LHS pattern matching characters */
	{ '*', MATCHZANY },	{ '+', MATCHANY },	{ '-', MATCHONE },
	{ '=', MATCHCLASS },	{ '~', MATCHNCLASS },

	/* these are RHS metasymbols */
	{ '#', CANONNET },	{ '@@', CANONHOST },	{ ':', CANONUSER },
	{ '>', CALLSUBR },

	/* the conditional operations */
	{ '?', CONDIF },	{ '|', CONDELSE },	{ '.', CONDFI },

	/* the hostname lookup characters */
	{ '[', HOSTBEGIN },	{ ']', HOSTEND },
	{ '(', LOOKUPBEGIN },	{ ')', LOOKUPEND },

	/* miscellaneous control characters */
	{ '&', MACRODEXPAND },

	{ '\0', '\0' }
};

#define MACBINDING(name, mid) \
		stab(name, ST_MACRO, ST_ENTER)->s_macro = mid; \
		MacroName[mid] = name;

void
initmacros(e)
	ENVELOPE *e;
{
	struct metamac *m;
	int c;
	char buf[5];

	for (m = MetaMacros; m->metaname != '\0'; m++)
	{
		buf[0] = m->metaval;
		buf[1] = '\0';
		macdefine(&e->e_macro, A_TEMP, m->metaname, buf);
	}
	buf[0] = MATCHREPL;
	buf[2] = '\0';
	for (c = '0'; c <= '9'; c++)
	{
		buf[1] = c;
		macdefine(&e->e_macro, A_TEMP, c, buf);
	}

	/* set defaults for some macros sendmail will use later */
	macdefine(&e->e_macro, A_PERM, 'n', "MAILER-DAEMON");

	/* set up external names for some internal macros */
	MACBINDING("opMode", MID_OPMODE);
	/*XXX should probably add equivalents for all short macros here XXX*/
}

/*
**  EXPAND/DOEXPAND -- macro expand a string using $x escapes.
**
**	After expansion, the expansion will be in external form (that is,
**	there will be no sendmail metacharacters and METAQUOTEs will have
**	been stripped out).
**
**	Parameters:
**		s -- the string to expand.
**		buf -- the place to put the expansion.
**		bufsize -- the size of the buffer.
**		explevel -- the depth of expansion (doexpand only)
**		e -- envelope in which to work.
**
**	Returns:
**		none.
**
**	Side Effects:
**		none.
*/

static void doexpand __P(( char *, char *, size_t, int, ENVELOPE *));

static void
doexpand(s, buf, bufsize, explevel, e)
	char *s;
	char *buf;
	size_t bufsize;
	int explevel;
	ENVELOPE *e;
{
	char *xp;
	char *q;
	bool skipping;		/* set if conditionally skipping output */
	bool recurse;		/* set if recursion required */
	size_t i;
	int skiplev;		/* skipping nesting level */
	int iflev;		/* if nesting level */
	bool quotenext;		/* quote the following character */
	char xbuf[MACBUFSIZE];

	if (tTd(35, 24))
	{
		sm_dprintf("expand(");
		xputs(sm_debug_file(), s);
		sm_dprintf(")\n");
	}

	recurse = false;
	skipping = false;
	skiplev = 0;
	iflev = 0;
	quotenext = false;
	if (s == NULL)
		s = "";
	for (xp = xbuf; *s != '\0'; s++)
	{
		int c;

		/*
		**  Check for non-ordinary (special?) character.
		**	'q' will be the interpolated quantity.
		*/

		q = NULL;
		c = *s & 0377;

		if (quotenext)
		{
			quotenext = false;
			goto simpleinterpolate;
		}

		switch (c)
		{
		  case CONDIF:		/* see if var set */
			iflev++;
			c = *++s & 0377;
			if (skipping)
				skiplev++;
			else
			{
				char *mv;

				mv = macvalue(c, e);
				skipping = (mv == NULL || *mv == '\0');
			}
			continue;

		  case CONDELSE:	/* change state of skipping */
			if (iflev == 0)
				break;	/* XXX: error */
			if (skiplev == 0)
				skipping = !skipping;
			continue;

		  case CONDFI:		/* stop skipping */
			if (iflev == 0)
				break;	/* XXX: error */
			iflev--;
			if (skiplev == 0)
				skipping = false;
			if (skipping)
				skiplev--;
			continue;

		  case MACROEXPAND:	/* macro interpolation */
			c = bitidx(*++s);
			if (c != '\0')
				q = macvalue(c, e);
			else
			{
				s--;
				q = NULL;
			}
			if (q == NULL)
				continue;
			break;

		  case METAQUOTE:
			/* next octet completely quoted */
			quotenext = true;
			break;
		}

		/*
		**  Interpolate q or output one character
		*/

  simpleinterpolate:
		if (skipping || xp >= &xbuf[sizeof(xbuf) - 1])
			continue;
		if (q == NULL)
			*xp++ = c;
		else
		{
			/* copy to end of q or max space remaining in buf */
			bool hiderecurse = false;

			while ((c = *q++) != '\0' &&
				xp < &xbuf[sizeof(xbuf) - 1])
			{
				/* check for any sendmail metacharacters */
				if (!hiderecurse && (c & 0340) == 0200)
					recurse = true;
				*xp++ = c;

				/* give quoted characters a free ride */
				hiderecurse = (c & 0377) == METAQUOTE;
			}
		}
	}
	*xp = '\0';

	if (tTd(35, 28))
	{
		sm_dprintf("expand(%d) ==> ", explevel);
		xputs(sm_debug_file(), xbuf);
		sm_dprintf("\n");
	}

	/* recurse as appropriate */
	if (recurse)
	{
		if (explevel < MaxMacroRecursion)
		{
			doexpand(xbuf, buf, bufsize, explevel + 1, e);
			return;
		}
		syserr("expand: recursion too deep (%d max)",
			MaxMacroRecursion);
	}

	/* copy results out */
	if (explevel == 0)
		(void) sm_strlcpy(buf, xbuf, bufsize);
	else
	{
		/* leave in internal form */
		i = xp - xbuf;
		if (i >= bufsize)
			i = bufsize - 1;
		memmove(buf, xbuf, i);
		buf[i] = '\0';
	}

	if (tTd(35, 24))
	{
		sm_dprintf("expand ==> ");
		xputs(sm_debug_file(), buf);
		sm_dprintf("\n");
	}
}

void
expand(s, buf, bufsize, e)
	char *s;
	char *buf;
	size_t bufsize;
	ENVELOPE *e;
{
	doexpand(s, buf, bufsize, 0, e);
}

/*
**  MACTABCLEAR -- clear entire macro table
**
**     Parameters:
**             mac -- Macro table.
**
**     Returns:
**             none.
**
**     Side Effects:
**             clears entire mac structure including rpool pointer!
*/

void
mactabclear(mac)
	MACROS_T *mac;
{
	int i;

	if (mac->mac_rpool == NULL)
	{
		for (i = 0; i < MAXMACROID; i++)
			SM_FREE_CLR(mac->mac_table[i]);
	}
	memset((char *) mac, '\0', sizeof(*mac));
}

/*
**  MACDEFINE -- bind a macro name to a value
**
**	Set a macro to a value, with fancy storage management.
**	macdefine will make a copy of the value, if required,
**	and will ensure that the storage for the previous value
**	is not leaked.
**
**	Parameters:
**		mac -- Macro table.
**		vclass -- storage class of 'value', ignored if value==NULL.
**			A_HEAP	means that the value was allocated by
**				malloc, and that macdefine owns the storage.
**			A_TEMP	means that value points to temporary storage,
**				and thus macdefine needs to make a copy.
**			A_PERM	means that value points to storage that
**				will remain allocated and unchanged for
**				at least the lifetime of mac.  Use A_PERM if:
**				-- value == NULL,
**				-- value points to a string literal,
**				-- value was allocated from mac->mac_rpool
**				   or (in the case of an envelope macro)
**				   from e->e_rpool,
**				-- in the case of an envelope macro,
**				   value is a string member of the envelope
**				   such as e->e_sender.
**		id -- Macro id.  This is a single character macro name
**			such as 'g', or a value returned by macid().
**		value -- Macro value: either NULL, or a string.
*/

void
#if SM_HEAP_CHECK
macdefine_tagged(mac, vclass, id, value, file, line, grp)
#else /* SM_HEAP_CHECK */
macdefine(mac, vclass, id, value)
#endif /* SM_HEAP_CHECK */
	MACROS_T *mac;
	ARGCLASS_T vclass;
	int id;
	char *value;
#if SM_HEAP_CHECK
	char *file;
	int line;
	int grp;
#endif /* SM_HEAP_CHECK */
{
	char *newvalue;

	if (id < 0 || id > MAXMACROID)
		return;

	if (tTd(35, 9))
	{
		sm_dprintf("%sdefine(%s as ",
			mac->mac_table[id] == NULL ? "" : "re", macname(id));
		xputs(sm_debug_file(), value);
		sm_dprintf(")\n");
	}

	if (mac->mac_rpool == NULL)
	{
		char *freeit = NULL;

		if (mac->mac_table[id] != NULL &&
		    bitnset(id, mac->mac_allocated))
			freeit = mac->mac_table[id];

		if (value == NULL || vclass == A_HEAP)
		{
			sm_heap_checkptr_tagged(value, file, line);
			newvalue = value;
			clrbitn(id, mac->mac_allocated);
		}
		else
		{
#if SM_HEAP_CHECK
			newvalue = sm_strdup_tagged_x(value, file, line, 0);
#else /* SM_HEAP_CHECK */
			newvalue = sm_strdup_x(value);
#endif /* SM_HEAP_CHECK */
			setbitn(id, mac->mac_allocated);
		}
		mac->mac_table[id] = newvalue;
		if (freeit != NULL)
			sm_free(freeit);
	}
	else
	{
		if (value == NULL || vclass == A_PERM)
			newvalue = value;
		else
			newvalue = sm_rpool_strdup_x(mac->mac_rpool, value);
		mac->mac_table[id] = newvalue;
		if (vclass == A_HEAP)
			sm_free(value);
	}

#if _FFR_RESET_MACRO_GLOBALS
	switch (id)
	{
	  case 'j':
		PSTRSET(MyHostName, value);
		break;
	}
#endif /* _FFR_RESET_MACRO_GLOBALS */
}

/*
**  MACSET -- set a named macro to a value (low level)
**
**	No fancy storage management; the caller takes full responsibility.
**	Often used with macget; see also macdefine.
**
**	Parameters:
**		mac -- Macro table.
**		i -- Macro name, specified as an integer offset.
**		value -- Macro value: either NULL, or a string.
*/

void
macset(mac, i, value)
	MACROS_T *mac;
	int i;
	char *value;
{
	if (i < 0 || i > MAXMACROID)
		return;

	if (tTd(35, 9))
	{
		sm_dprintf("macset(%s as ", macname(i));
		xputs(sm_debug_file(), value);
		sm_dprintf(")\n");
	}
	mac->mac_table[i] = value;
}

/*
**  MACVALUE -- return uninterpreted value of a macro.
**
**	Does fancy path searching.
**	The low level counterpart is macget.
**
**	Parameters:
**		n -- the name of the macro.
**		e -- envelope in which to start looking for the macro.
**
**	Returns:
**		The value of n.
**
**	Side Effects:
**		none.
*/

char *
macvalue(n, e)
	int n;
	ENVELOPE *e;
{
	n = bitidx(n);
	if (e != NULL && e->e_mci != NULL)
	{
		char *p = e->e_mci->mci_macro.mac_table[n];

		if (p != NULL)
			return p;
	}
	while (e != NULL)
	{
		char *p = e->e_macro.mac_table[n];

		if (p != NULL)
			return p;
		if (e == e->e_parent)
			break;
		e = e->e_parent;
	}
	return GlobalMacros.mac_table[n];
}

/*
**  MACNAME -- return the name of a macro given its internal id
**
**	Parameter:
**		n -- the id of the macro
**
**	Returns:
**		The name of n.
**
**	Side Effects:
**		none.
**
**	WARNING:
**		Not thread-safe.
*/

char *
macname(n)
	int n;
{
	static char mbuf[2];

	n = (int)(unsigned char)n;
	if (n > MAXMACROID)
		return "***OUT OF RANGE MACRO***";

	/* if not ASCII printable, look up the name */
	if (n <= 0x20 || n > 0x7f)
	{
		char *p = MacroName[n];

		if (p != NULL)
			return p;
		return "***UNDEFINED MACRO***";
	}

	/* if in the ASCII graphic range, just return the id directly */
	mbuf[0] = n;
	mbuf[1] = '\0';
	return mbuf;
}

/*
**  MACID_PARSE -- return id of macro identified by its name
**
**	Parameters:
**		p -- pointer to name string -- either a single
**			character or {name}.
**		ep -- filled in with the pointer to the byte
**			after the name.
**
**	Returns:
**		0 -- An error was detected.
**		1..MAXMACROID -- The internal id code for this macro.
**
**	Side Effects:
**		If this is a new macro name, a new id is allocated.
**		On error, syserr is called.
*/

int
macid_parse(p, ep)
	char *p;
	char **ep;
{
	int mid;
	char *bp;
	char mbuf[MAXMACNAMELEN + 1];

	if (tTd(35, 14))
	{
		sm_dprintf("macid(");
		xputs(sm_debug_file(), p);
		sm_dprintf(") => ");
	}

	if (*p == '\0' || (p[0] == '{' && p[1] == '}'))
	{
		syserr("Name required for macro/class");
		if (ep != NULL)
			*ep = p;
		if (tTd(35, 14))
			sm_dprintf("NULL\n");
		return 0;
	}
	if (*p != '{')
	{
		/* the macro is its own code */
		if (ep != NULL)
			*ep = p + 1;
		if (tTd(35, 14))
		{
			char buf[2];

			buf[0] = *p;
			buf[1] = '\0';
			xputs(sm_debug_file(), buf);
			sm_dprintf("\n");
		}
		return bitidx(*p);
	}
	bp = mbuf;
	while (*++p != '\0' && *p != '}' && bp < &mbuf[sizeof(mbuf) - 1])
	{
		if (isascii(*p) && (isalnum(*p) || *p == '_'))
			*bp++ = *p;
		else
			syserr("Invalid macro/class character %c", *p);
	}
	*bp = '\0';
	mid = -1;
	if (*p == '\0')
	{
		syserr("Unbalanced { on %s", mbuf);	/* missing } */
	}
	else if (*p != '}')
	{
		syserr("Macro/class name ({%s}) too long (%d chars max)",
			mbuf, (int) (sizeof(mbuf) - 1));
	}
	else if (mbuf[1] == '\0' && mbuf[0] >= 0x20)
	{
		/* ${x} == $x */
		mid = bitidx(mbuf[0]);
		p++;
	}
	else
	{
		STAB *s;

		s = stab(mbuf, ST_MACRO, ST_ENTER);
		if (s->s_macro != 0)
			mid = s->s_macro;
		else
		{
			if (NextMacroId > MAXMACROID)
			{
				syserr("Macro/class {%s}: too many long names",
					mbuf);
				s->s_macro = -1;
			}
			else
			{
				MacroName[NextMacroId] = s->s_name;
				s->s_macro = mid = NextMacroId;
				NextMacroId = NEXTMACROID(NextMacroId);
			}
		}
		p++;
	}
	if (ep != NULL)
		*ep = p;
	if (mid < 0 || mid > MAXMACROID)
	{
		syserr("Unable to assign macro/class ID (mid = 0x%x)", mid);
		if (tTd(35, 14))
			sm_dprintf("NULL\n");
		return 0;
	}
	if (tTd(35, 14))
		sm_dprintf("0x%x\n", mid);
	return mid;
}

/*
**  WORDINCLASS -- tell if a word is in a specific class
**
**	Parameters:
**		str -- the name of the word to look up.
**		cl -- the class name.
**
**	Returns:
**		true if str can be found in cl.
**		false otherwise.
*/

bool
wordinclass(str, cl)
	char *str;
	int cl;
{
	STAB *s;

	s = stab(str, ST_CLASS, ST_FIND);
	return s != NULL && bitnset(bitidx(cl), s->s_class);
}
@


1.5
log
@merge
@
text
@d365 27
@


1.4
log
@Replace “$Sendmail: ” with “$Id: ” (the latter is used by upstream)
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001, 2003, 2006, 2007 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Id: macro.c,v 8.107 2007/08/06 22:29:02 ca Exp $")
@


1.3
log
@merge and reduce diffs against upstream
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: macro.c,v 8.107 2007/08/06 22:29:02 ca Exp $")
@


1.2
log
@upgrade from sendmail 8.14.1 to 8.14.2 ourselves:
> From donotreply@@lists.sendmail.org Fri Nov  2 02:46:04 2007
> From: Claus Assmann <donotreply@@lists.sendmail.org>
Message-ID: <200711020234.lA22YPul046763@@lists.sendmail.org>
To: sendmail-announce@@sendmail.org
Date: Thu, 1 Nov 2007 19:34:25 -0700 (PDT)
Subject: sendmail 8.14.2 available

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Sendmail, Inc., and the Sendmail Consortium announce the availability
of sendmail 8.14.2 which fixes some problems, e.g.,

- - an important bug in the milter function smfi_chgfrom() which could
  cause the loss of a message body.
- - the handling of queued messages with 8 bit characters in From:
  or To: header which could be "mistaken" for internal control
  characters during a queue run and trigger various consistency checks.
- - the handling of lines longer than MAXLINE-1 characters in certain
  cases.

A complete list of changes can be found in the release notes (see
below).

Please send bug reports and general feedback to one of the addresses
listed at: http://www.sendmail.org/email-addresses.html

The version can be found at

ftp://ftp.sendmail.org/pub/sendmail/sendmail.8.14.2.tar.gz
ftp://ftp.sendmail.org/pub/sendmail/sendmail.8.14.2.tar.gz.sig
ftp://ftp.sendmail.org/pub/sendmail/sendmail.8.14.2.tar.Z
ftp://ftp.sendmail.org/pub/sendmail/sendmail.8.14.2.tar.Z.sig

MD5 signatures:
cf784b9f20c32949ae1f38f3eae29875 sendmail.8.14.2.tar.Z
f788d6986f12a81ac958195b045a529d sendmail.8.14.2.tar.Z.sig
1c1472365344ca8061d6453c43c9a831 sendmail.8.14.2.tar.gz
2ae4b6175a08e8a6cda992db20141d81 sendmail.8.14.2.tar.gz.sig

You either need the first two files or the third and fourth, i.e.,
the gzip'ed version or the compressed version and the corresponding
sig file.  The PGP signature was created using the Sendmail Signing
Key/2007, available on the web site (http://www.sendmail.org/) or
on the public key servers.

Since sendmail 8.11 and later includes hooks to cryptography, the
following information from OpenSSL applies to sendmail as well.

   PLEASE REMEMBER THAT EXPORT/IMPORT AND/OR USE OF STRONG CRYPTOGRAPHY
   SOFTWARE, PROVIDING CRYPTOGRAPHY HOOKS OR EVEN JUST COMMUNICATING
   TECHNICAL DETAILS ABOUT CRYPTOGRAPHY SOFTWARE IS ILLEGAL IN SOME
   PARTS OF THE WORLD.  SO, WHEN YOU IMPORT THIS PACKAGE TO YOUR
   COUNTRY, RE-DISTRIBUTE IT FROM THERE OR EVEN JUST EMAIL TECHNICAL
   SUGGESTIONS OR EVEN SOURCE PATCHES TO THE AUTHOR OR OTHER PEOPLE
   YOU ARE STRONGLY ADVISED TO PAY CLOSE ATTENTION TO ANY EXPORT/IMPORT
   AND/OR USE LAWS WHICH APPLY TO YOU. THE AUTHORS ARE NOT LIABLE FOR
   ANY VIOLATIONS YOU MAKE HERE. SO BE CAREFUL, IT IS YOUR RESPONSIBILITY.


			SENDMAIL RELEASE NOTES
      $Id: RELEASE_NOTES,v 8.1909 2007/10/31 16:04:13 ca Exp $


This listing shows the version of the sendmail binary, the version
of the sendmail configuration files, the date of release, and a
summary of the changes in that release.

8.14.2/8.14.2	2007/11/01
	If a message was queued and it contained 8 bit characters in
		a From: or To: header, then those characters could be
		"mistaken" for internal control characters during a queue
		run and trigger various consistency checks.  Problem
		noted by Neil Rickert of Northern Illinois University.
	If MaxMimeHeaderLength is set to a value greater than 0 (which
		it is by default) then even if the Linelimit parameter
		is 0, sendmail corrupted in the non-transfer-encoding
		case every MAXLINE-1 characters.  Patch from John Gardiner
		Myers of Proofpoint.
	Setting the suboption DeliveryMode for DaemonPortOptions did not
		work in earlier 8.14 versions.
	Note: DeliveryMode=interactive is silently converted to
		background if a milter can reject or delete a recipient.
		Prior to 8.14 this happened only if milter could delete
		recipients.
	ClientRate should trigger when the limit was exceeded (as
		documented), not when it was reached.  Patch from
		John Beck of Sun Microsystems.
	Force a queue run for -qGqueuegroup even if no runners are
		specified (R=0) and forking (F=f) is requested.
	When multiple results are requested for a DNS map lookup
		(-z and -Z), return only those that are relevant for
		the query (not also those in the "additional section".)
	If the message transfer time to sendmail (when acting as server)
		exceeds Timeout.queuewarn or Timeout.queuereturn and
		the message is refused (by a milter), sendmail previously
		created a delivery status notification (DSN).  Patch
		from Doug Heath of The Hertz Corporation.
	A code change in Cyrus-SASL 2.1.22 for sasl_decode64() requires
		the MTA to deal with some input (i.e., "=") itself.
		Problem noted by Eliot Lear.
	sendmail counted a delivery as successful if PIPELINING is
		compiled in but not offered by the server and the
		delivery failed temporarily.  Patch from Werner Wiethege.
	If getting the result of an LDAP query times out then close the
		map so it will be reopened on the next lookup.  This
		should help "failover" configurations that specify more
		than one LDAP server.
	If check_compat returns $#discard then a "savemail panic" could
		be triggered under some circumstances (e.g., requiring
		a system which does not have the compile time flag
		HASFLOCK set). Based on patch by Motonori Nakamura
		of National Institute of Informatics, Japan.
	If a milter rejected a recipient, the count for nrcpts= in the
		logfile entry might have been wrong.  Problem found by
		Petra Humann of TU Dresden.
	If a milter invoked smfi_chgfrom() where ESMTP arguments are not
		NULL, the message body was lost.  Patch from Motonori
		Nakamura of National Institute of Informatics, Japan.
	sendmail(8) had a bogus space in -qGname.  Patch from Peng Haitao.
	CONTRIB: buildvirtuser: Preserve ownership and permissions when
		replacing files.
	CONTRIB: buildvirtuser: Skip dot-files (e.g., .cvsignore) when
		reading the /etc/mail/virtusers/ directory.
	CONTRIB: buildvirtuser: Emit warnings instead of exiting where
		appropriate.
	LIBMILTER: Fix ABI backwards compatibility so milters compiled
		against an older libmilter.so shared library can use an
		8.14 libmilter.so shared library.
	LIBMILTER: smfi_version() did not properly extract the patchlevel
		from the version number, however, the returned value was
		correct for the current libmilter version.

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.5 (OpenBSD)

iQCVAwUBRyqEOs8etQMiMnoBAQKNdQP/cQKfjVP7qTi0Ol/OgR7AnvCaerCxiQ5J
y1uxjwXs2s+RemX0u5a4c0agoLscTKU5Ot6uzOdvKvZd0/unr/IkzuXZBF9LsnlZ
X1wS4GXQDXKDfazvwdwOUgxkthMZU1TiVFj/GH5TOfHqVUO5Ho/yRfAQoAn3taFc
5jeg+A3+M9M=
=DJHS
-----END PGP SIGNATURE-----
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: macro.c,v 8.102 2006/12/21 23:06:10 ca Exp $")
@


1.2.2.1
log
@MFC sendmail update to 8.14.3

agreed bsiegert@@
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: macro.c,v 8.107 2007/08/06 22:29:02 ca Exp $")
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001, 2003 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: macro.c,v 8.88 2003/09/05 23:11:18 ca Exp $")
d18 1
d24 58
d83 3
d132 1
a132 1
	register ENVELOPE *e;
d134 2
a135 2
	register struct metamac *m;
	register int c;
d159 1
d161 5
a165 1
**  EXPAND -- macro expand a string using $x escapes.
d171 1
d181 6
a186 4
void
expand(s, buf, bufsize, e)
	register char *s;
	register char *buf;
d188 2
a189 1
	register ENVELOPE *e;
d191 2
a192 2
	register char *xp;
	register char *q;
d198 1
a199 1
	static int explevel = 0;
d212 1
d225 9
a233 2
		c = *s;
		switch (c & 0377)
d237 1
a237 1
			c = *++s;
d278 5
d289 2
a290 1
		if (skipping || xp >= &xbuf[sizeof xbuf - 1])
d297 4
a300 1
			while ((c = *q++) != '\0' && xp < &xbuf[sizeof xbuf - 1])
d303 1
a303 1
				if ((c & 0340) == 0200)
d306 3
d314 1
a314 1
	if (tTd(35, 24))
d316 1
a316 1
		sm_dprintf("expand ==> ");
d326 1
a326 3
			explevel++;
			expand(xbuf, buf, bufsize, e);
			explevel--;
d334 28
a361 5
	i = xp - xbuf;
	if (i >= bufsize)
		i = bufsize - 1;
	memmove(buf, xbuf, i);
	buf[i] = '\0';
d522 1
a522 1
	register ENVELOPE *e;
d527 1
a527 1
		register char *p = e->e_mci->mci_macro.mac_table[n];
d534 1
a534 1
		register char *p = e->e_macro.mac_table[n];
d544 1
d556 3
d567 6
a572 2
	n = bitidx(n);
	if (bitset(0200, n))
d580 2
d586 1
d598 1
a598 1
**		1..255 -- The internal id code for this macro.
d607 1
a607 1
	register char *p;
d611 1
a611 1
	register char *bp;
d636 8
a643 1
			sm_dprintf("%c\n", bitidx(*p));
d647 1
a647 1
	while (*++p != '\0' && *p != '}' && bp < &mbuf[sizeof mbuf - 1])
d663 1
a663 1
			mbuf, (int) (sizeof mbuf - 1));
d665 1
a665 1
	else if (mbuf[1] == '\0')
d673 1
a673 1
		register STAB *s;
d689 2
a690 1
				s->s_macro = mid = NextMacroId++;
d708 1
d726 1
a726 1
	register STAB *s;
@


1.1.127.1
log
@Import Sendmail 8.14.3, suitably stripped down by the not yet committed
contrib/samples/import-3rdpty,v 1.35; we have some new and renamed files
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001, 2003, 2006, 2007 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Id: macro.c,v 8.107 2007/08/06 22:29:02 ca Exp $")
a17 1
#include <sm/sendmail.h>
a22 58

/*
**  Codes for long named macros.
**  See also macname():
	* if not ASCII printable, look up the name *
	if (n <= 0x20 || n > 0x7f)
**  First use 1 to NEXTMACROID_L, then use NEXTMACROID_H to MAXMACROID.
*/

#define NEXTMACROID_L 037
#define NEXTMACROID_H 0240

#if _FFR_MORE_MACROS
/* table for next id in non-printable ASCII range: disallow some value */
static int NextMIdTable[] =
{
	/*  0  nul */	 1,
	/*  1  soh */	 2,
	/*  2  stx */	 3,
	/*  3  etx */	 4,
	/*  4  eot */	 5,
	/*  5  enq */	 6,
	/*  6  ack */	 7,
	/*  7  bel */	 8,
	/*  8  bs  */	14,
	/*  9  ht  */	-1,
	/* 10  nl  */	-1,
	/* 11  vt  */	-1,
	/* 12  np  */	-1,
	/* 13  cr  */	-1,
	/* 14  so  */	15,
	/* 15  si  */	16,
	/* 16  dle */	17,
	/* 17  dc1 */	18,
	/* 18  dc2 */	19,
	/* 19  dc3 */	20,
	/* 20  dc4 */	21,
	/* 21  nak */	22,
	/* 22  syn */	23,
	/* 23  etb */	24,
	/* 24  can */	25,
	/* 25  em  */	26,
	/* 26  sub */	27,
	/* 27  esc */	28,
	/* 28  fs  */	29,
	/* 29  gs  */	30,
	/* 30  rs  */	31,
	/* 31  us  */	32,
	/* 32  sp  */	-1,
};

#define NEXTMACROID(mid)	(		\
	(mid < NEXTMACROID_L) ? (NextMIdTable[mid]) :	\
	((mid < NEXTMACROID_H) ? NEXTMACROID_H : (mid + 1)))

int		NextMacroId = 1;	/* codes for long named macros */
/* see sendmail.h: Special characters in rewriting rules. */
#else /* _FFR_MORE_MACROS */
a23 3
#define NEXTMACROID(mid)	((mid) + 1)
#endif /* _FFR_MORE_MACROS */

d70 1
a70 1
	ENVELOPE *e;
d72 2
a73 2
	struct metamac *m;
	int c;
a96 1

d98 1
a98 5
**  EXPAND/DOEXPAND -- macro expand a string using $x escapes.
**
**	After expansion, the expansion will be in external form (that is,
**	there will be no sendmail metacharacters and METAQUOTEs will have
**	been stripped out).
a103 1
**		explevel -- the depth of expansion (doexpand only)
d113 4
a116 6
static void doexpand __P(( char *, char *, size_t, int, ENVELOPE *));

static void
doexpand(s, buf, bufsize, explevel, e)
	char *s;
	char *buf;
d118 1
a118 2
	int explevel;
	ENVELOPE *e;
d120 2
a121 2
	char *xp;
	char *q;
a126 1
	bool quotenext;		/* quote the following character */
d128 1
a140 1
	quotenext = false;
d153 2
a154 9
		c = *s & 0377;

		if (quotenext)
		{
			quotenext = false;
			goto simpleinterpolate;
		}

		switch (c)
d158 1
a158 1
			c = *++s & 0377;
a198 5

		  case METAQUOTE:
			/* next octet completely quoted */
			quotenext = true;
			break;
d205 1
a205 2
  simpleinterpolate:
		if (skipping || xp >= &xbuf[sizeof(xbuf) - 1])
d212 1
a212 4
			bool hiderecurse = false;

			while ((c = *q++) != '\0' &&
				xp < &xbuf[sizeof(xbuf) - 1])
d215 1
a215 1
				if (!hiderecurse && (c & 0340) == 0200)
a217 3

				/* give quoted characters a free ride */
				hiderecurse = (c & 0377) == METAQUOTE;
d223 1
a223 1
	if (tTd(35, 28))
d225 1
a225 1
		sm_dprintf("expand(%d) ==> ", explevel);
d235 3
a237 1
			doexpand(xbuf, buf, bufsize, explevel + 1, e);
d245 5
a249 28
	if (explevel == 0)
		(void) sm_strlcpy(buf, xbuf, bufsize);
	else
	{
		/* leave in internal form */
		i = xp - xbuf;
		if (i >= bufsize)
			i = bufsize - 1;
		memmove(buf, xbuf, i);
		buf[i] = '\0';
	}

	if (tTd(35, 24))
	{
		sm_dprintf("expand ==> ");
		xputs(sm_debug_file(), buf);
		sm_dprintf("\n");
	}
}

void
expand(s, buf, bufsize, e)
	char *s;
	char *buf;
	size_t bufsize;
	ENVELOPE *e;
{
	doexpand(s, buf, bufsize, 0, e);
d410 1
a410 1
	ENVELOPE *e;
d415 1
a415 1
		char *p = e->e_mci->mci_macro.mac_table[n];
d422 1
a422 1
		char *p = e->e_macro.mac_table[n];
a431 1

a442 3
**
**	WARNING:
**		Not thread-safe.
d451 2
a452 6
	n = (int)(unsigned char)n;
	if (n > MAXMACROID)
		return "***OUT OF RANGE MACRO***";

	/* if not ASCII printable, look up the name */
	if (n <= 0x20 || n > 0x7f)
a459 2

	/* if in the ASCII graphic range, just return the id directly */
a463 1

d475 1
a475 1
**		1..MAXMACROID -- The internal id code for this macro.
d484 1
a484 1
	char *p;
d488 1
a488 1
	char *bp;
d513 1
a513 8
		{
			char buf[2];

			buf[0] = *p;
			buf[1] = '\0';
			xputs(sm_debug_file(), buf);
			sm_dprintf("\n");
		}
d517 1
a517 1
	while (*++p != '\0' && *p != '}' && bp < &mbuf[sizeof(mbuf) - 1])
d533 1
a533 1
			mbuf, (int) (sizeof(mbuf) - 1));
d535 1
a535 1
	else if (mbuf[1] == '\0' && mbuf[0] >= 0x20)
d543 1
a543 1
		STAB *s;
d559 1
a559 2
				s->s_macro = mid = NextMacroId;
				NextMacroId = NEXTMACROID(NextMacroId);
a576 1

d594 1
a594 1
	STAB *s;
@


1.1.127.2
log
@Import sendmail 8.14.9
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001, 2003, 2006, 2007 Proofpoint, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Id: macro.c,v 8.108 2013-11-22 20:51:55 ca Exp $")
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import Sendmail 8.14.0 via OpenBSD
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001, 2003, 2006 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: macro.c,v 8.102 2006/12/21 23:06:10 ca Exp $")
a17 1
#include <sm/sendmail.h>
a23 2
/* see sendmail.h: Special characters in rewriting rules. */

d70 1
a70 1
	ENVELOPE *e;
d72 2
a73 2
	struct metamac *m;
	int c;
a96 1

d98 1
a98 5
**  EXPAND/DOEXPAND -- macro expand a string using $x escapes.
**
**	After expansion, the expansion will be in external form (that is,
**	there will be no sendmail metacharacters and METAQUOTEs will have
**	been stripped out).
a103 1
**		explevel -- the depth of expansion (doexpand only)
d113 4
a116 6
static void doexpand __P(( char *, char *, size_t, int, ENVELOPE *));

static void
doexpand(s, buf, bufsize, explevel, e)
	char *s;
	char *buf;
d118 1
a118 2
	int explevel;
	ENVELOPE *e;
d120 2
a121 2
	char *xp;
	char *q;
a126 1
	bool quotenext;		/* quote the following character */
d128 1
a140 1
	quotenext = false;
d153 2
a154 9
		c = *s & 0377;

		if (quotenext)
		{
			quotenext = false;
			goto simpleinterpolate;
		}

		switch (c)
d158 1
a158 1
			c = *++s & 0377;
a198 5

		  case METAQUOTE:
			/* next octet completely quoted */
			quotenext = true;
			break;
d205 1
a205 2
  simpleinterpolate:
		if (skipping || xp >= &xbuf[sizeof(xbuf) - 1])
d212 1
a212 4
			bool hiderecurse = false;

			while ((c = *q++) != '\0' &&
				xp < &xbuf[sizeof(xbuf) - 1])
d215 1
a215 1
				if (!hiderecurse && (c & 0340) == 0200)
a217 3

				/* give quoted characters a free ride */
				hiderecurse = (c & 0377) == METAQUOTE;
d223 1
a223 1
	if (tTd(35, 28))
d225 1
a225 1
		sm_dprintf("expand(%d) ==> ", explevel);
d235 3
a237 1
			doexpand(xbuf, buf, bufsize, explevel + 1, e);
d245 5
a249 28
	if (explevel == 0)
		(void) sm_strlcpy(buf, xbuf, bufsize);
	else
	{
		/* leave in internal form */
		i = xp - xbuf;
		if (i >= bufsize)
			i = bufsize - 1;
		memmove(buf, xbuf, i);
		buf[i] = '\0';
	}

	if (tTd(35, 24))
	{
		sm_dprintf("expand ==> ");
		xputs(sm_debug_file(), buf);
		sm_dprintf("\n");
	}
}

void
expand(s, buf, bufsize, e)
	char *s;
	char *buf;
	size_t bufsize;
	ENVELOPE *e;
{
	doexpand(s, buf, bufsize, 0, e);
d410 1
a410 1
	ENVELOPE *e;
d415 1
a415 1
		char *p = e->e_mci->mci_macro.mac_table[n];
d422 1
a422 1
		char *p = e->e_macro.mac_table[n];
a431 1

a442 3
**
**	WARNING:
**		Not thread-safe.
d451 2
a452 6
	n = (int)(unsigned char)n;
	if (n > MAXMACROID)
		return "***OUT OF RANGE MACRO***";

	/* if not ASCII printable, look up the name */
	if (n <= 0x20 || n > 0x7f)
a459 2

	/* if in the ASCII graphic range, just return the id directly */
a463 1

d475 1
a475 1
**		1..MAXMACROID -- The internal id code for this macro.
d484 1
a484 1
	char *p;
d488 1
a488 1
	char *bp;
d513 1
a513 8
		{
			char buf[2];

			buf[0] = *p;
			buf[1] = '\0';
			xputs(sm_debug_file(), buf);
			sm_dprintf("\n");
		}
d517 1
a517 1
	while (*++p != '\0' && *p != '}' && bp < &mbuf[sizeof(mbuf) - 1])
d533 1
a533 1
			mbuf, (int) (sizeof(mbuf) - 1));
d543 1
a543 1
		STAB *s;
a576 1

d594 1
a594 1
	STAB *s;
@


1.1.1.3
log
@OpenBSD finally has upgraded their sendmail, too…
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001, 2003, 2006, 2007 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: macro.c,v 8.107 2007/08/06 22:29:02 ca Exp $")
d24 1
a24 56

/*
**  Codes for long named macros.
**  See also macname():
	* if not ASCII printable, look up the name *
	if (n <= 0x20 || n > 0x7f)
**  First use 1 to NEXTMACROID_L, then use NEXTMACROID_H to MAXMACROID.
*/

#define NEXTMACROID_L 037
#define NEXTMACROID_H 0240

#if _FFR_MORE_MACROS
/* table for next id in non-printable ASCII range: disallow some value */
static int NextMIdTable[] =
{
	/*  0  nul */	 1,
	/*  1  soh */	 2,
	/*  2  stx */	 3,
	/*  3  etx */	 4,
	/*  4  eot */	 5,
	/*  5  enq */	 6,
	/*  6  ack */	 7,
	/*  7  bel */	 8,
	/*  8  bs  */	14,
	/*  9  ht  */	-1,
	/* 10  nl  */	-1,
	/* 11  vt  */	-1,
	/* 12  np  */	-1,
	/* 13  cr  */	-1,
	/* 14  so  */	15,
	/* 15  si  */	16,
	/* 16  dle */	17,
	/* 17  dc1 */	18,
	/* 18  dc2 */	19,
	/* 19  dc3 */	20,
	/* 20  dc4 */	21,
	/* 21  nak */	22,
	/* 22  syn */	23,
	/* 23  etb */	24,
	/* 24  can */	25,
	/* 25  em  */	26,
	/* 26  sub */	27,
	/* 27  esc */	28,
	/* 28  fs  */	29,
	/* 29  gs  */	30,
	/* 30  rs  */	31,
	/* 31  us  */	32,
	/* 32  sp  */	-1,
};

#define NEXTMACROID(mid)	(		\
	(mid < NEXTMACROID_L) ? (NextMIdTable[mid]) :	\
	((mid < NEXTMACROID_H) ? NEXTMACROID_H : (mid + 1)))

int		NextMacroId = 1;	/* codes for long named macros */
a25 4
#else /* _FFR_MORE_MACROS */
int		NextMacroId = 0240;	/* codes for long named macros */
#define NEXTMACROID(mid)	((mid) + 1)
#endif /* _FFR_MORE_MACROS */
d606 1
a606 1
	else if (mbuf[1] == '\0' && mbuf[0] >= 0x20)
d630 1
a630 2
				s->s_macro = mid = NextMacroId;
				NextMacroId = NEXTMACROID(NextMacroId);
@


1.1.1.3.2.1
log
@Replace “$Sendmail: ” with “$Id: ” (the latter is used by upstream)
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Id: macro.c,v 8.107 2007/08/06 22:29:02 ca Exp $")
@


1.1.1.4
log
@Replace “$Sendmail: ” with “$Id: ” (the latter is used by upstream)
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Id: macro.c,v 8.107 2007/08/06 22:29:02 ca Exp $")
@


