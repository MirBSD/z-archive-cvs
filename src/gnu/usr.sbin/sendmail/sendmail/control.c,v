head	1.4;
access;
symbols
	sendmail-8_14_9:1.1.127.3
	sendmail-8_14_7:1.1.127.2
	sendmail-8_14_6:1.1.127.1
	sendmail-8_14_5-ERRATA-1:1.1.127.1
	mbsd-20101220_mergebase:1.1.1.2.4.1
	sendmail-8_14_5:1.1.127.1
	cvs-201107021500:1.1.1.3
	cvs-20101220:1.1.1.3
	mbsd-20101220:1.1.1.2.0.4
	cvs-201012191730:1.1.1.2
	sendmail-8_14_5_Beta0:1.1.127.1
	sendmail-8_14_3:1.1.127.1
	sendmail:1.1.127
	cvs-200812170000:1.1.1.2
	cvs-200805071200:1.1.1.2
	MIRBSD_10:1.1.1.2.0.2
	MIRBSD_10_BASE:1.1.1.2
	cvs-200803022030:1.1.1.2
	cvs-200707152000:1.1.1.2
	cvs-200704292000:1.1.1.2
	cvs-200702051700:1.1.1.2
	cvs-200609121900:1.1.1.1
	MIRBSD_9_BASE:1.1.1.1
	cvs-200606151800:1.1.1.1
	cvs-200603231300:1.1.1.1
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200507211800:1.1.1.1
	cvs-200504262050:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2014.06.09.15.17.45;	author tg;	state Exp;
branches;
next	1.3;
commitid	1005395CFC65E5646F1;

1.3
date	2013.08.06.20.37.03;	author tg;	state Exp;
branches;
next	1.2;
commitid	10052015E562892E658;

1.2
date	2011.07.02.15.04.08;	author tg;	state Exp;
branches;
next	1.1;
commitid	1004E0F31C5496AB95F;

1.1
date	2005.02.05.17.24.28;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.127.1;
next	;

1.1.1.1
date	2005.02.05.17.24.28;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.02.05.17.06.24;	author tg;	state Exp;
branches
	1.1.1.2.4.1;
next	1.1.1.3;
commitid	10045C763C551AABAF7;

1.1.1.3
date	2011.07.02.15.00.40;	author tg;	state Exp;
branches;
next	;
commitid	1004E0F31C5496AB95F;

1.1.1.2.4.1
date	2011.07.02.15.02.55;	author tg;	state Exp;
branches;
next	;
commitid	1004E0F31C5496AB95F;

1.1.127.1
date	2010.12.19.14.45.44;	author tg;	state Exp;
branches;
next	1.1.127.2;
commitid	1004D0E1A94384778FD;

1.1.127.2
date	2013.08.06.20.26.06;	author tg;	state Exp;
branches;
next	1.1.127.3;
commitid	10052015BDF0FDDCF84;

1.1.127.3
date	2014.06.09.14.29.16;	author tg;	state Exp;
branches;
next	;
commitid	1005395C4CC1A6DB9EE;


desc
@@


1.4
log
@merge
@
text
@/*
 * Copyright (c) 1998-2004, 2006 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>

SM_RCSID("@@(#)$Id: control.c,v 8.130 2013-11-22 20:51:55 ca Exp $")

#include <sm/fdset.h>

/* values for cmd_code */
#define CMDERROR	0	/* bad command */
#define CMDRESTART	1	/* restart daemon */
#define CMDSHUTDOWN	2	/* end daemon */
#define CMDHELP		3	/* help */
#define CMDSTATUS	4	/* daemon status */
#define CMDMEMDUMP	5	/* dump memory, to find memory leaks */
#define CMDMSTAT	6	/* daemon status, more info, tagged data */

struct cmd
{
	char	*cmd_name;	/* command name */
	int	cmd_code;	/* internal code, see below */
};

static struct cmd	CmdTab[] =
{
	{ "help",	CMDHELP		},
	{ "restart",	CMDRESTART	},
	{ "shutdown",	CMDSHUTDOWN	},
	{ "status",	CMDSTATUS	},
	{ "memdump",	CMDMEMDUMP	},
	{ "mstat",	CMDMSTAT	},
	{ NULL,		CMDERROR	}
};



static void	controltimeout __P((int));
int ControlSocket = -1;

/*
**  OPENCONTROLSOCKET -- create/open the daemon control named socket
**
**	Creates and opens a named socket for external control over
**	the sendmail daemon.
**
**	Parameters:
**		none.
**
**	Returns:
**		0 if successful, -1 otherwise
*/

int
opencontrolsocket()
{
# if NETUNIX
	int save_errno;
	int rval;
	long sff = SFF_SAFEDIRPATH|SFF_OPENASROOT|SFF_NOLINK|SFF_CREAT|SFF_MUSTOWN;
	struct sockaddr_un controladdr;

	if (ControlSocketName == NULL || *ControlSocketName == '\0')
		return 0;

	if (strlen(ControlSocketName) >= sizeof(controladdr.sun_path))
	{
		errno = ENAMETOOLONG;
		return -1;
	}

	rval = safefile(ControlSocketName, RunAsUid, RunAsGid, RunAsUserName,
			sff, S_IRUSR|S_IWUSR, NULL);

	/* if not safe, don't create */
	if (rval != 0)
	{
		errno = rval;
		return -1;
	}

	ControlSocket = socket(AF_UNIX, SOCK_STREAM, 0);
	if (ControlSocket < 0)
		return -1;
	if (SM_FD_SETSIZE > 0 && ControlSocket >= SM_FD_SETSIZE)
	{
		clrcontrol();
		errno = EINVAL;
		return -1;
	}

	(void) unlink(ControlSocketName);
	memset(&controladdr, '\0', sizeof(controladdr));
	controladdr.sun_family = AF_UNIX;
	(void) sm_strlcpy(controladdr.sun_path, ControlSocketName,
			  sizeof(controladdr.sun_path));

	if (bind(ControlSocket, (struct sockaddr *) &controladdr,
		 sizeof(controladdr)) < 0)
	{
		save_errno = errno;
		clrcontrol();
		errno = save_errno;
		return -1;
	}

	if (geteuid() == 0)
	{
		uid_t u = 0;

		if (RunAsUid != 0)
			u = RunAsUid;
		else if (TrustedUid != 0)
			u = TrustedUid;

		if (u != 0 &&
		    chown(ControlSocketName, u, -1) < 0)
		{
			save_errno = errno;
			sm_syslog(LOG_ALERT, NOQID,
				  "ownership change on %s to uid %d failed: %s",
				  ControlSocketName, (int) u,
				  sm_errstring(save_errno));
			message("050 ownership change on %s to uid %d failed: %s",
				ControlSocketName, (int) u,
				sm_errstring(save_errno));
			closecontrolsocket(true);
			errno = save_errno;
			return -1;
		}
	}

	if (chmod(ControlSocketName, S_IRUSR|S_IWUSR) < 0)
	{
		save_errno = errno;
		closecontrolsocket(true);
		errno = save_errno;
		return -1;
	}

	if (listen(ControlSocket, 8) < 0)
	{
		save_errno = errno;
		closecontrolsocket(true);
		errno = save_errno;
		return -1;
	}
# endif /* NETUNIX */
	return 0;
}
/*
**  CLOSECONTROLSOCKET -- close the daemon control named socket
**
**	Close a named socket.
**
**	Parameters:
**		fullclose -- if set, close the socket and remove it;
**			     otherwise, just remove it
**
**	Returns:
**		none.
*/

void
closecontrolsocket(fullclose)
	bool fullclose;
{
# if NETUNIX
	long sff = SFF_SAFEDIRPATH|SFF_OPENASROOT|SFF_NOLINK|SFF_CREAT|SFF_MUSTOWN;

	if (ControlSocket >= 0)
	{
		int rval;

		if (fullclose)
		{
			(void) close(ControlSocket);
			ControlSocket = -1;
		}

		rval = safefile(ControlSocketName, RunAsUid, RunAsGid,
				RunAsUserName, sff, S_IRUSR|S_IWUSR, NULL);

		/* if not safe, don't unlink */
		if (rval != 0)
			return;

		if (unlink(ControlSocketName) < 0)
		{
			sm_syslog(LOG_WARNING, NOQID,
				  "Could not remove control socket: %s",
				  sm_errstring(errno));
			return;
		}
	}
# endif /* NETUNIX */
	return;
}
/*
**  CLRCONTROL -- reset the control connection
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		releases any resources used by the control interface.
*/

void
clrcontrol()
{
# if NETUNIX
	if (ControlSocket >= 0)
		(void) close(ControlSocket);
	ControlSocket = -1;
# endif /* NETUNIX */
}
/*
**  CONTROL_COMMAND -- read and process command from named socket
**
**	Read and process the command from the opened socket.
**	Exits when done since it is running in a forked child.
**
**	Parameters:
**		sock -- the opened socket from getrequests()
**		e -- the current envelope
**
**	Returns:
**		none.
*/

static jmp_buf	CtxControlTimeout;

/* ARGSUSED0 */
static void
controltimeout(timeout)
	int timeout;
{
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	errno = ETIMEDOUT;
	longjmp(CtxControlTimeout, 1);
}

void
control_command(sock, e)
	int sock;
	ENVELOPE *e;
{
	volatile int exitstat = EX_OK;
	SM_FILE_T *s = NULL;
	SM_EVENT *ev = NULL;
	SM_FILE_T *traffic;
	SM_FILE_T *oldout;
	char *cmd;
	char *p;
	struct cmd *c;
	char cmdbuf[MAXLINE];
	char inp[MAXLINE];

	sm_setproctitle(false, e, "control cmd read");

	if (TimeOuts.to_control > 0)
	{
		/* handle possible input timeout */
		if (setjmp(CtxControlTimeout) != 0)
		{
			if (LogLevel > 2)
				sm_syslog(LOG_NOTICE, e->e_id,
					  "timeout waiting for input during control command");
			exit(EX_IOERR);
		}
		ev = sm_setevent(TimeOuts.to_control, controltimeout,
				 TimeOuts.to_control);
	}

	s = sm_io_open(SmFtStdiofd, SM_TIME_DEFAULT, (void *) &sock,
		       SM_IO_RDWR, NULL);
	if (s == NULL)
	{
		int save_errno = errno;

		(void) close(sock);
		errno = save_errno;
		exit(EX_IOERR);
	}
	(void) sm_io_setvbuf(s, SM_TIME_DEFAULT, NULL,
			     SM_IO_NBF, SM_IO_BUFSIZ);

	if (sm_io_fgets(s, SM_TIME_DEFAULT, inp, sizeof(inp)) < 0)
	{
		(void) sm_io_close(s, SM_TIME_DEFAULT);
		exit(EX_IOERR);
	}
	(void) sm_io_flush(s, SM_TIME_DEFAULT);

	/* clean up end of line */
	fixcrlf(inp, true);

	sm_setproctitle(false, e, "control: %s", inp);

	/* break off command */
	for (p = inp; isascii(*p) && isspace(*p); p++)
		continue;
	cmd = cmdbuf;
	while (*p != '\0' &&
	       !(isascii(*p) && isspace(*p)) &&
	       cmd < &cmdbuf[sizeof(cmdbuf) - 2])
		*cmd++ = *p++;
	*cmd = '\0';

	/* throw away leading whitespace */
	while (isascii(*p) && isspace(*p))
		p++;

	/* decode command */
	for (c = CmdTab; c->cmd_name != NULL; c++)
	{
		if (sm_strcasecmp(c->cmd_name, cmdbuf) == 0)
			break;
	}

	switch (c->cmd_code)
	{
	  case CMDHELP:		/* get help */
		traffic = TrafficLogFile;
		TrafficLogFile = NULL;
		oldout = OutChannel;
		OutChannel = s;
		help("control", e);
		TrafficLogFile = traffic;
		OutChannel = oldout;
		break;

	  case CMDRESTART:	/* restart the daemon */
		(void) sm_io_fprintf(s, SM_TIME_DEFAULT, "OK\r\n");
		exitstat = EX_RESTART;
		break;

	  case CMDSHUTDOWN:	/* kill the daemon */
		(void) sm_io_fprintf(s, SM_TIME_DEFAULT, "OK\r\n");
		exitstat = EX_SHUTDOWN;
		break;

	  case CMDSTATUS:	/* daemon status */
		proc_list_probe();
		{
			int qgrp;
			long bsize;
			long free;

			/* XXX need to deal with different partitions */
			qgrp = e->e_qgrp;
			if (!ISVALIDQGRP(qgrp))
				qgrp = 0;
			free = freediskspace(Queue[qgrp]->qg_qdir, &bsize);

			/*
			**  Prevent overflow and don't lose
			**  precision (if bsize == 512)
			*/

			if (free > 0)
				free = (long)((double) free *
					      ((double) bsize / 1024));

			(void) sm_io_fprintf(s, SM_TIME_DEFAULT,
					     "%d/%d/%ld/%d\r\n",
					     CurChildren, MaxChildren,
					     free, getla());
		}
		proc_list_display(s, "");
		break;

	  case CMDMSTAT:	/* daemon status, extended, tagged format */
		proc_list_probe();
		(void) sm_io_fprintf(s, SM_TIME_DEFAULT,
				     "C:%d\r\nM:%d\r\nL:%d\r\n",
				     CurChildren, MaxChildren,
				     getla());
		printnqe(s, "Q:");
		disk_status(s, "D:");
		proc_list_display(s, "P:");
		break;

	  case CMDMEMDUMP:	/* daemon memory dump, to find memory leaks */
# if SM_HEAP_CHECK
		/* dump the heap, if we are checking for memory leaks */
		if (sm_debug_active(&SmHeapCheck, 2))
		{
			sm_heap_report(s, sm_debug_level(&SmHeapCheck) - 1);
		}
		else
		{
			(void) sm_io_fprintf(s, SM_TIME_DEFAULT,
					     "Memory dump unavailable.\r\n");
			(void) sm_io_fprintf(s, SM_TIME_DEFAULT,
					     "To fix, run sendmail with -dsm_check_heap.4\r\n");
		}
# else /* SM_HEAP_CHECK */
		(void) sm_io_fprintf(s, SM_TIME_DEFAULT,
				     "Memory dump unavailable.\r\n");
		(void) sm_io_fprintf(s, SM_TIME_DEFAULT,
				     "To fix, rebuild with -DSM_HEAP_CHECK\r\n");
# endif /* SM_HEAP_CHECK */
		break;

	  case CMDERROR:	/* unknown command */
		(void) sm_io_fprintf(s, SM_TIME_DEFAULT,
				     "Bad command (%s)\r\n", cmdbuf);
		break;
	}
	(void) sm_io_close(s, SM_TIME_DEFAULT);
	if (ev != NULL)
		sm_clrevent(ev);
	exit(exitstat);
}
@


1.3
log
@merge
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004, 2006 Sendmail, Inc. and its suppliers.
d13 1
a13 1
SM_RCSID("@@(#)$Id: control.c,v 8.129 2013/03/12 15:24:52 ca Exp $")
@


1.2
log
@Replace “$Sendmail: ” with “$Id: ” (the latter is used by upstream)
@
text
@d13 1
a13 1
SM_RCSID("@@(#)$Id: control.c,v 8.128 2006/08/15 23:24:56 ca Exp $")
d304 1
a304 1
	if (sm_io_fgets(s, SM_TIME_DEFAULT, inp, sizeof(inp)) == NULL)
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004 Sendmail, Inc. and its suppliers.
d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: control.c,v 8.126 2004/08/04 20:54:00 ca Exp $")
d24 1
a24 3
#if _FFR_CONTROL_MSTAT
# define CMDMSTAT	6	/* daemon status, more info, tagged data */
#endif /* _FFR_CONTROL_MSTAT */
a38 1
#if _FFR_CONTROL_MSTAT
a39 1
#endif /* _FFR_CONTROL_MSTAT */
d73 1
a73 1
	if (strlen(ControlSocketName) >= sizeof controladdr.sun_path)
d100 1
a100 1
	memset(&controladdr, '\0', sizeof controladdr);
d103 1
a103 1
			  sizeof controladdr.sun_path);
d106 1
a106 1
		 sizeof controladdr) < 0)
d304 1
a304 1
	if (sm_io_fgets(s, SM_TIME_DEFAULT, inp, sizeof inp) == NULL)
d322 1
a322 1
	       cmd < &cmdbuf[sizeof cmdbuf - 2])
a388 1
# if _FFR_CONTROL_MSTAT
a398 1
# endif /* _FFR_CONTROL_MSTAT */
@


1.1.127.1
log
@Import Sendmail 8.14.3, suitably stripped down by the not yet committed
contrib/samples/import-3rdpty,v 1.35; we have some new and renamed files
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004, 2006 Sendmail, Inc. and its suppliers.
d13 1
a13 1
SM_RCSID("@@(#)$Id: control.c,v 8.128 2006/08/15 23:24:56 ca Exp $")
d24 3
a26 1
#define CMDMSTAT	6	/* daemon status, more info, tagged data */
d41 1
d43 1
d77 1
a77 1
	if (strlen(ControlSocketName) >= sizeof(controladdr.sun_path))
d104 1
a104 1
	memset(&controladdr, '\0', sizeof(controladdr));
d107 1
a107 1
			  sizeof(controladdr.sun_path));
d110 1
a110 1
		 sizeof(controladdr)) < 0)
d308 1
a308 1
	if (sm_io_fgets(s, SM_TIME_DEFAULT, inp, sizeof(inp)) == NULL)
d326 1
a326 1
	       cmd < &cmdbuf[sizeof(cmdbuf) - 2])
d393 1
d404 1
@


1.1.127.2
log
@Update
@
text
@d13 1
a13 1
SM_RCSID("@@(#)$Id: control.c,v 8.129 2013/03/12 15:24:52 ca Exp $")
d304 1
a304 1
	if (sm_io_fgets(s, SM_TIME_DEFAULT, inp, sizeof(inp)) < 0)
@


1.1.127.3
log
@Import sendmail 8.14.9
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004, 2006 Proofpoint, Inc. and its suppliers.
d13 1
a13 1
SM_RCSID("@@(#)$Id: control.c,v 8.130 2013-11-22 20:51:55 ca Exp $")
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import Sendmail 8.14.0 via OpenBSD
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004, 2006 Sendmail, Inc. and its suppliers.
d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: control.c,v 8.128 2006/08/15 23:24:56 ca Exp $")
d24 3
a26 1
#define CMDMSTAT	6	/* daemon status, more info, tagged data */
d41 1
d43 1
d77 1
a77 1
	if (strlen(ControlSocketName) >= sizeof(controladdr.sun_path))
d104 1
a104 1
	memset(&controladdr, '\0', sizeof(controladdr));
d107 1
a107 1
			  sizeof(controladdr.sun_path));
d110 1
a110 1
		 sizeof(controladdr)) < 0)
d308 1
a308 1
	if (sm_io_fgets(s, SM_TIME_DEFAULT, inp, sizeof(inp)) == NULL)
d326 1
a326 1
	       cmd < &cmdbuf[sizeof(cmdbuf) - 2])
d393 1
d404 1
@


1.1.1.2.4.1
log
@Replace “$Sendmail: ” with “$Id: ” (the latter is used by upstream)
@
text
@d13 1
a13 1
SM_RCSID("@@(#)$Id: control.c,v 8.128 2006/08/15 23:24:56 ca Exp $")
@


1.1.1.3
log
@Replace “$Sendmail: ” with “$Id: ” (the latter is used by upstream)
@
text
@d13 1
a13 1
SM_RCSID("@@(#)$Id: control.c,v 8.128 2006/08/15 23:24:56 ca Exp $")
@


