head	1.6;
access;
symbols
	sendmail-8_14_9:1.1.127.4
	sendmail-8_14_7:1.1.127.3
	sendmail-8_14_6:1.1.127.3
	sendmail-8_14_5-ERRATA-1:1.1.127.2
	mbsd-20101220_mergebase:1.4
	sendmail-8_14_5:1.1.127.2
	cvs-201107021500:1.1.1.8
	cvs-20101220:1.1.1.7
	mbsd-20101220:1.4.0.2
	cvs-201012191730:1.1.1.6
	sendmail-8_14_5_Beta0:1.1.127.2
	sendmail-8_14_3:1.1.127.1
	sendmail:1.1.127
	cvs-200812170000:1.1.1.6
	cvs-200805071200:1.1.1.6
	MIRBSD_10:1.2.0.2
	MIRBSD_10_BASE:1.2
	cvs-200803022030:1.1.1.5
	cvs-200707152000:1.1.1.5
	cvs-200704292000:1.1.1.5
	cvs-200702051700:1.1.1.4
	cvs-200609121900:1.1.1.3
	MIRBSD_9_BASE:1.1.1.2
	cvs-200606151800:1.1.1.2
	cvs-200603231300:1.1.1.2
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200507211800:1.1.1.1
	cvs-200504262050:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2014.06.09.15.17.48;	author tg;	state Exp;
branches;
next	1.5;
commitid	1005395CFC65E5646F1;

1.5
date	2012.12.31.21.02.43;	author tg;	state Exp;
branches;
next	1.4;
commitid	10050E1FD6765F66D0C;

1.4
date	2010.12.19.17.18.25;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004D0E3E2D1286B3DF;

1.3
date	2008.05.07.13.15.26;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004821AB7510EE48FB;

1.2
date	2008.03.02.21.41.14;	author tg;	state Exp;
branches
	1.2.2.1;
next	1.1;
commitid	10047CB1EE51190ECAF;

1.1
date	2005.02.05.17.24.28;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.127.1;
next	;

1.2.2.1
date	2008.05.17.19.12.09;	author tg;	state Exp;
branches;
next	;
commitid	100482F2DC168C89AEA;

1.1.1.1
date	2005.02.05.17.24.28;	author tg;	state Exp;
branches
	1.1.1.1.2.1;
next	1.1.1.2;

1.1.1.2
date	2006.03.23.13.09.55;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	10044229DEA33D36552;

1.1.1.3
date	2006.09.12.19.22.24;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	100450708CE5C63A8F5;

1.1.1.4
date	2007.02.05.17.06.30;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	10045C763C551AABAF7;

1.1.1.5
date	2007.04.29.20.07.11;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	1004634FAED5BC54DF0;

1.1.1.6
date	2008.05.07.12.31.50;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	1004821A13C1FC036E1;

1.1.1.7
date	2011.07.02.15.00.45;	author tg;	state Exp;
branches;
next	1.1.1.8;
commitid	1004E0F31C5496AB95F;

1.1.1.8
date	2011.07.02.15.17.42;	author tg;	state Exp;
branches;
next	;
commitid	1004E0F36A10B5CA95B;

1.1.1.1.2.1
date	2006.03.30.19.27.58;	author tg;	state Exp;
branches;
next	;
commitid	100442C309C7183FA09;

1.1.127.1
date	2010.12.19.14.45.44;	author tg;	state Exp;
branches;
next	1.1.127.2;
commitid	1004D0E1A94384778FD;

1.1.127.2
date	2010.12.19.14.56.25;	author tg;	state Exp;
branches;
next	1.1.127.3;
commitid	1004D0E1D294DE25888;

1.1.127.3
date	2012.12.31.20.38.12;	author tg;	state Exp;
branches;
next	1.1.127.4;
commitid	10050E1F79A4182E8EC;

1.1.127.4
date	2014.06.09.14.29.16;	author tg;	state Exp;
branches;
next	;
commitid	1005395C4CC1A6DB9EE;


desc
@@


1.6
log
@merge
@
text
@/*
 * Copyright (c) 1998-2004, 2006, 2007 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>
#include <sm/sendmail.h>

SM_RCSID("@@(#)$Id: headers.c,v 8.320 2013-11-22 20:51:55 ca Exp $")

static HDR	*allocheader __P((char *, char *, int, SM_RPOOL_T *, bool));
static size_t	fix_mime_header __P((HDR *, ENVELOPE *));
static int	priencode __P((char *));
static bool	put_vanilla_header __P((HDR *, char *, MCI *));

/*
**  SETUPHEADERS -- initialize headers in symbol table
**
**	Parameters:
**		none
**
**	Returns:
**		none
*/

void
setupheaders()
{
	struct hdrinfo *hi;
	STAB *s;

	for (hi = HdrInfo; hi->hi_field != NULL; hi++)
	{
		s = stab(hi->hi_field, ST_HEADER, ST_ENTER);
		s->s_header.hi_flags = hi->hi_flags;
		s->s_header.hi_ruleset = NULL;
	}
}

/*
**  DOCHOMPHEADER -- process and save a header line.
**
**	Called by chompheader.
**
**	Parameters:
**		line -- header as a text line.
**		pflag -- flags for chompheader() (from sendmail.h)
**		hdrp -- a pointer to the place to save the header.
**		e -- the envelope including this header.
**
**	Returns:
**		flags for this header.
**
**	Side Effects:
**		The header is saved on the header list.
**		Contents of 'line' are destroyed.
*/

static struct hdrinfo	NormalHeader =	{ NULL, 0, NULL };
static unsigned long	dochompheader __P((char *, int, HDR **, ENVELOPE *));

static unsigned long
dochompheader(line, pflag, hdrp, e)
	char *line;
	int pflag;
	HDR **hdrp;
	ENVELOPE *e;
{
	unsigned char mid = '\0';
	register char *p;
	register HDR *h;
	HDR **hp;
	char *fname;
	char *fvalue;
	bool cond = false;
	bool dropfrom;
	bool headeronly;
	STAB *s;
	struct hdrinfo *hi;
	bool nullheader = false;
	BITMAP256 mopts;

	headeronly = hdrp != NULL;
	if (!headeronly)
		hdrp = &e->e_header;

	/* strip off options */
	clrbitmap(mopts);
	p = line;
	if (!bitset(pflag, CHHDR_USER) && *p == '?')
	{
		int c;
		register char *q;

		q = strchr(++p, '?');
		if (q == NULL)
			goto hse;

		*q = '\0';
		c = *p & 0377;

		/* possibly macro conditional */
		if (c == MACROEXPAND)
		{
			/* catch ?$? */
			if (*++p == '\0')
			{
				*q = '?';
				goto hse;
			}

			mid = (unsigned char) *p++;

			/* catch ?$abc? */
			if (*p != '\0')
			{
				*q = '?';
				goto hse;
			}
		}
		else if (*p == '$')
		{
			/* catch ?$? */
			if (*++p == '\0')
			{
				*q = '?';
				goto hse;
			}

			mid = (unsigned char) macid(p);
			if (bitset(0200, mid))
			{
				p += strlen(macname(mid)) + 2;
				SM_ASSERT(p <= q);
			}
			else
				p++;

			/* catch ?$abc? */
			if (*p != '\0')
			{
				*q = '?';
				goto hse;
			}
		}
		else
		{
			while (*p != '\0')
			{
				if (!isascii(*p))
				{
					*q = '?';
					goto hse;
				}

				setbitn(bitidx(*p), mopts);
				cond = true;
				p++;
			}
		}
		p = q + 1;
	}

	/* find canonical name */
	fname = p;
	while (isascii(*p) && isgraph(*p) && *p != ':')
		p++;
	fvalue = p;
	while (isascii(*p) && isspace(*p))
		p++;
	if (*p++ != ':' || fname == fvalue)
	{
hse:
		syserr("553 5.3.0 header syntax error, line \"%s\"", line);
		return 0;
	}
	*fvalue = '\0';
	fvalue = p;

	/* if the field is null, go ahead and use the default */
	while (isascii(*p) && isspace(*p))
		p++;
	if (*p == '\0')
		nullheader = true;

	/* security scan: long field names are end-of-header */
	if (strlen(fname) > 100)
		return H_EOH;

	/* check to see if it represents a ruleset call */
	if (bitset(pflag, CHHDR_DEF))
	{
		char hbuf[50];

		(void) expand(fvalue, hbuf, sizeof(hbuf), e);
		for (p = hbuf; isascii(*p) && isspace(*p); )
			p++;
		if ((*p++ & 0377) == CALLSUBR)
		{
			auto char *endp;
			bool strc;

			strc = *p == '+';	/* strip comments? */
			if (strc)
				++p;
			if (strtorwset(p, &endp, ST_ENTER) > 0)
			{
				*endp = '\0';
				s = stab(fname, ST_HEADER, ST_ENTER);
				if (LogLevel > 9 &&
				    s->s_header.hi_ruleset != NULL)
					sm_syslog(LOG_WARNING, NOQID,
						  "Warning: redefined ruleset for header=%s, old=%s, new=%s",
						  fname,
						  s->s_header.hi_ruleset, p);
				s->s_header.hi_ruleset = newstr(p);
				if (!strc)
					s->s_header.hi_flags |= H_STRIPCOMM;
			}
			return 0;
		}
	}

	/* see if it is a known type */
	s = stab(fname, ST_HEADER, ST_FIND);
	if (s != NULL)
		hi = &s->s_header;
	else
		hi = &NormalHeader;

	if (tTd(31, 9))
	{
		if (s == NULL)
			sm_dprintf("no header flags match\n");
		else
			sm_dprintf("header match, flags=%lx, ruleset=%s\n",
				   hi->hi_flags,
				   hi->hi_ruleset == NULL ? "<NULL>"
							  : hi->hi_ruleset);
	}

	/* see if this is a resent message */
	if (!bitset(pflag, CHHDR_DEF) && !headeronly &&
	    bitset(H_RESENT, hi->hi_flags))
		e->e_flags |= EF_RESENT;

	/* if this is an Errors-To: header keep track of it now */
	if (UseErrorsTo && !bitset(pflag, CHHDR_DEF) && !headeronly &&
	    bitset(H_ERRORSTO, hi->hi_flags))
		(void) sendtolist(fvalue, NULLADDR, &e->e_errorqueue, 0, e);

	/* if this means "end of header" quit now */
	if (!headeronly && bitset(H_EOH, hi->hi_flags))
		return hi->hi_flags;

	/*
	**  Horrible hack to work around problem with Lotus Notes SMTP
	**  mail gateway, which generates From: headers with newlines in
	**  them and the <address> on the second line.  Although this is
	**  legal RFC 822, many MUAs don't handle this properly and thus
	**  never find the actual address.
	*/

	if (bitset(H_FROM, hi->hi_flags) && SingleLineFromHeader)
	{
		while ((p = strchr(fvalue, '\n')) != NULL)
			*p = ' ';
	}

	/*
	**  If there is a check ruleset, verify it against the header.
	*/

	if (bitset(pflag, CHHDR_CHECK))
	{
		int rscheckflags;
		char *rs;

		rscheckflags = RSF_COUNT;
		if (!bitset(hi->hi_flags, H_FROM|H_RCPT))
			rscheckflags |= RSF_UNSTRUCTURED;

		/* no ruleset? look for default */
		rs = hi->hi_ruleset;
		if (rs == NULL)
		{
			s = stab("*", ST_HEADER, ST_FIND);
			if (s != NULL)
			{
				rs = (&s->s_header)->hi_ruleset;
				if (bitset((&s->s_header)->hi_flags,
					   H_STRIPCOMM))
					rscheckflags |= RSF_RMCOMM;
			}
		}
		else if (bitset(hi->hi_flags, H_STRIPCOMM))
			rscheckflags |= RSF_RMCOMM;
		if (rs != NULL)
		{
			int l, k;
			char qval[MAXNAME];

			l = 0;
			qval[l++] = '"';

			/* - 3 to avoid problems with " at the end */
			/* should be sizeof(qval), not MAXNAME */
			for (k = 0; fvalue[k] != '\0' && l < MAXNAME - 3; k++)
			{
				switch (fvalue[k])
				{
				  /* XXX other control chars? */
				  case '\011': /* ht */
				  case '\012': /* nl */
				  case '\013': /* vt */
				  case '\014': /* np */
				  case '\015': /* cr */
					qval[l++] = ' ';
					break;
				  case '"':
					qval[l++] = '\\';
					/* FALLTHROUGH */
				  default:
					qval[l++] = fvalue[k];
					break;
				}
			}
			qval[l++] = '"';
			qval[l] = '\0';
			k += strlen(fvalue + k);
			if (k >= MAXNAME)
			{
				if (LogLevel > 9)
					sm_syslog(LOG_WARNING, e->e_id,
						  "Warning: truncated header '%s' before check with '%s' len=%d max=%d",
						  fname, rs, k, MAXNAME - 1);
			}
			macdefine(&e->e_macro, A_TEMP,
				macid("{currHeader}"), qval);
			macdefine(&e->e_macro, A_TEMP,
				macid("{hdr_name}"), fname);

			(void) sm_snprintf(qval, sizeof(qval), "%d", k);
			macdefine(&e->e_macro, A_TEMP, macid("{hdrlen}"), qval);
			if (bitset(H_FROM, hi->hi_flags))
				macdefine(&e->e_macro, A_PERM,
					macid("{addr_type}"), "h s");
			else if (bitset(H_RCPT, hi->hi_flags))
				macdefine(&e->e_macro, A_PERM,
					macid("{addr_type}"), "h r");
			else
				macdefine(&e->e_macro, A_PERM,
					macid("{addr_type}"), "h");
			(void) rscheck(rs, fvalue, NULL, e, rscheckflags, 3,
				       NULL, e->e_id, NULL);
		}
	}

	/*
	**  Drop explicit From: if same as what we would generate.
	**  This is to make MH (which doesn't always give a full name)
	**  insert the full name information in all circumstances.
	*/

	dropfrom = false;
	p = "resent-from";
	if (!bitset(EF_RESENT, e->e_flags))
		p += 7;
	if (!bitset(pflag, CHHDR_DEF) && !headeronly &&
	    !bitset(EF_QUEUERUN, e->e_flags) && sm_strcasecmp(fname, p) == 0)
	{
		if (e->e_from.q_paddr != NULL &&
		    e->e_from.q_mailer != NULL &&
		    bitnset(M_LOCALMAILER, e->e_from.q_mailer->m_flags) &&
		    (strcmp(fvalue, e->e_from.q_paddr) == 0 ||
		     strcmp(fvalue, e->e_from.q_user) == 0))
			dropfrom = true;
		if (tTd(31, 2))
		{
			sm_dprintf("comparing header from (%s) against default (%s or %s), drop=%d\n",
				fvalue, e->e_from.q_paddr, e->e_from.q_user,
				dropfrom);
		}
	}

	/* delete default value for this header */
	for (hp = hdrp; (h = *hp) != NULL; hp = &h->h_link)
	{
		if (sm_strcasecmp(fname, h->h_field) == 0 &&
		    !bitset(H_USER, h->h_flags) &&
		    !bitset(H_FORCE, h->h_flags))
		{
			if (nullheader)
			{
				/* user-supplied value was null */
				return 0;
			}
			if (dropfrom)
			{
				/* make this look like the user entered it */
				h->h_flags |= H_USER;

				/*
				**  If the MH hack is selected, allow to turn
				**  it off via a mailer flag to avoid problems
				**  with setups that remove the F flag from
				**  the RCPT mailer.
				*/

		    		if (bitnset(M_NOMHHACK,
					    e->e_from.q_mailer->m_flags))
				{
					h->h_flags &= ~H_CHECK;
				}
				return hi->hi_flags;
			}
			h->h_value = NULL;
			if (!cond)
			{
				/* copy conditions from default case */
				memmove((char *) mopts, (char *) h->h_mflags,
					sizeof(mopts));
			}
			h->h_macro = mid;
		}
	}

	/* create a new node */
	h = (HDR *) sm_rpool_malloc_x(e->e_rpool, sizeof(*h));
	h->h_field = sm_rpool_strdup_x(e->e_rpool, fname);
	h->h_value = sm_rpool_strdup_x(e->e_rpool, fvalue);
	h->h_link = NULL;
	memmove((char *) h->h_mflags, (char *) mopts, sizeof(mopts));
	h->h_macro = mid;
	*hp = h;
	h->h_flags = hi->hi_flags;
	if (bitset(pflag, CHHDR_USER) || bitset(pflag, CHHDR_QUEUE))
		h->h_flags |= H_USER;

	/* strip EOH flag if parsing MIME headers */
	if (headeronly)
		h->h_flags &= ~H_EOH;
	if (bitset(pflag, CHHDR_DEF))
		h->h_flags |= H_DEFAULT;
	if (cond || mid != '\0')
		h->h_flags |= H_CHECK;

	/* hack to see if this is a new format message */
	if (!bitset(pflag, CHHDR_DEF) && !headeronly &&
	    bitset(H_RCPT|H_FROM, h->h_flags) &&
	    (strchr(fvalue, ',') != NULL || strchr(fvalue, '(') != NULL ||
	     strchr(fvalue, '<') != NULL || strchr(fvalue, ';') != NULL))
	{
		e->e_flags &= ~EF_OLDSTYLE;
	}

	return h->h_flags;
}

/*
**  CHOMPHEADER -- process and save a header line.
**
**	Called by collect, readcf, and readqf to deal with header lines.
**	This is just a wrapper for dochompheader().
**
**	Parameters:
**		line -- header as a text line.
**		pflag -- flags for chompheader() (from sendmail.h)
**		hdrp -- a pointer to the place to save the header.
**		e -- the envelope including this header.
**
**	Returns:
**		flags for this header.
**
**	Side Effects:
**		The header is saved on the header list.
**		Contents of 'line' are destroyed.
*/


unsigned long
chompheader(line, pflag, hdrp, e)
	char *line;
	int pflag;
	HDR **hdrp;
	register ENVELOPE *e;
{
	unsigned long rval;

	if (tTd(31, 6))
	{
		sm_dprintf("chompheader: ");
		xputs(sm_debug_file(), line);
		sm_dprintf("\n");
	}

	/* quote this if user (not config file) input */
	if (bitset(pflag, CHHDR_USER))
	{
		char xbuf[MAXLINE];
		char *xbp = NULL;
		int xbufs;

		xbufs = sizeof(xbuf);
		xbp = quote_internal_chars(line, xbuf, &xbufs);
		if (tTd(31, 7))
		{
			sm_dprintf("chompheader: quoted: ");
			xputs(sm_debug_file(), xbp);
			sm_dprintf("\n");
		}
		rval = dochompheader(xbp, pflag, hdrp, e);
		if (xbp != xbuf)
			sm_free(xbp);
	}
	else
		rval = dochompheader(line, pflag, hdrp, e);

	return rval;
}

/*
**  ALLOCHEADER -- allocate a header entry
**
**	Parameters:
**		field -- the name of the header field (will not be copied).
**		value -- the value of the field (will be copied).
**		flags -- flags to add to h_flags.
**		rp -- resource pool for allocations
**		space -- add leading space?
**
**	Returns:
**		Pointer to a newly allocated and populated HDR.
**
**	Notes:
**		o field and value must be in internal format, i.e.,
**		metacharacters must be "quoted", see quote_internal_chars().
**		o maybe add more flags to decide:
**		  - what to copy (field/value)
**		  - whether to convert value to an internal format
*/

static HDR *
allocheader(field, value, flags, rp, space)
	char *field;
	char *value;
	int flags;
	SM_RPOOL_T *rp;
	bool space;
{
	HDR *h;
	STAB *s;

	/* find info struct */
	s = stab(field, ST_HEADER, ST_FIND);

	/* allocate space for new header */
	h = (HDR *) sm_rpool_malloc_x(rp, sizeof(*h));
	h->h_field = field;
	if (space)
	{
		size_t l;
		char *n;

		l = strlen(value);
		SM_ASSERT(l + 2 > l);
		n = sm_rpool_malloc_x(rp, l + 2);
		n[0] = ' ';
		n[1] = '\0';
		sm_strlcpy(n + 1, value, l + 1);
		h->h_value = n;
	}
	else
		h->h_value = sm_rpool_strdup_x(rp, value);
	h->h_flags = flags;
	if (s != NULL)
		h->h_flags |= s->s_header.hi_flags;
	clrbitmap(h->h_mflags);
	h->h_macro = '\0';

	return h;
}

/*
**  ADDHEADER -- add a header entry to the end of the queue.
**
**	This bypasses the special checking of chompheader.
**
**	Parameters:
**		field -- the name of the header field (will not be copied).
**		value -- the value of the field (will be copied).
**		flags -- flags to add to h_flags.
**		e -- envelope.
**		space -- add leading space?
**
**	Returns:
**		none.
**
**	Side Effects:
**		adds the field on the list of headers for this envelope.
**
**	Notes: field and value must be in internal format, i.e.,
**		metacharacters must be "quoted", see quote_internal_chars().
*/

void
addheader(field, value, flags, e, space)
	char *field;
	char *value;
	int flags;
	ENVELOPE *e;
	bool space;
{
	register HDR *h;
	HDR **hp;
	HDR **hdrlist = &e->e_header;

	/* find current place in list -- keep back pointer? */
	for (hp = hdrlist; (h = *hp) != NULL; hp = &h->h_link)
	{
		if (sm_strcasecmp(field, h->h_field) == 0)
			break;
	}

	/* allocate space for new header */
	h = allocheader(field, value, flags, e->e_rpool, space);
	h->h_link = *hp;
	*hp = h;
}

/*
**  INSHEADER -- insert a header entry at the specified index
**	This bypasses the special checking of chompheader.
**
**	Parameters:
**		idx -- index into the header list at which to insert
**		field -- the name of the header field (will be copied).
**		value -- the value of the field (will be copied).
**		flags -- flags to add to h_flags.
**		e -- envelope.
**		space -- add leading space?
**
**	Returns:
**		none.
**
**	Side Effects:
**		inserts the field on the list of headers for this envelope.
**
**	Notes:
**		- field and value must be in internal format, i.e.,
**		metacharacters must be "quoted", see quote_internal_chars().
**		- the header list contains headers that might not be
**		sent "out" (see putheader(): "skip"), hence there is no
**		reliable way to insert a header at an exact position
**		(except at the front or end).
*/

void
insheader(idx, field, value, flags, e, space)
	int idx;
	char *field;
	char *value;
	int flags;
	ENVELOPE *e;
	bool space;
{
	HDR *h, *srch, *last = NULL;

	/* allocate space for new header */
	h = allocheader(field, value, flags, e->e_rpool, space);

	/* find insertion position */
	for (srch = e->e_header; srch != NULL && idx > 0;
	     srch = srch->h_link, idx--)
		last = srch;

	if (e->e_header == NULL)
	{
		e->e_header = h;
		h->h_link = NULL;
	}
	else if (srch == NULL)
	{
		SM_ASSERT(last != NULL);
		last->h_link = h;
		h->h_link = NULL;
	}
	else
	{
		h->h_link = srch->h_link;
		srch->h_link = h;
	}
}

/*
**  HVALUE -- return value of a header.
**
**	Only "real" fields (i.e., ones that have not been supplied
**	as a default) are used.
**
**	Parameters:
**		field -- the field name.
**		header -- the header list.
**
**	Returns:
**		pointer to the value part (internal format).
**		NULL if not found.
**
**	Side Effects:
**		none.
*/

char *
hvalue(field, header)
	char *field;
	HDR *header;
{
	register HDR *h;

	for (h = header; h != NULL; h = h->h_link)
	{
		if (!bitset(H_DEFAULT, h->h_flags) &&
		    sm_strcasecmp(h->h_field, field) == 0)
		{
			char *s;

			s = h->h_value;
			if (s == NULL)
				return NULL;
			while (isascii(*s) && isspace(*s))
				s++;
			return s;
		}
	}
	return NULL;
}

/*
**  ISHEADER -- predicate telling if argument is a header.
**
**	A line is a header if it has a single word followed by
**	optional white space followed by a colon.
**
**	Header fields beginning with two dashes, although technically
**	permitted by RFC822, are automatically rejected in order
**	to make MIME work out.  Without this we could have a technically
**	legal header such as ``--"foo:bar"'' that would also be a legal
**	MIME separator.
**
**	Parameters:
**		h -- string to check for possible headerness.
**
**	Returns:
**		true if h is a header.
**		false otherwise.
**
**	Side Effects:
**		none.
*/

bool
isheader(h)
	char *h;
{
	char *s;

	s = h;
	if (s[0] == '-' && s[1] == '-')
		return false;

	while (*s > ' ' && *s != ':' && *s != '\0')
		s++;

	if (h == s)
		return false;

	/* following technically violates RFC822 */
	while (isascii(*s) && isspace(*s))
		s++;

	return (*s == ':');
}

/*
**  EATHEADER -- run through the stored header and extract info.
**
**	Parameters:
**		e -- the envelope to process.
**		full -- if set, do full processing (e.g., compute
**			message priority).  This should not be set
**			when reading a queue file because some info
**			needed to compute the priority is wrong.
**		log -- call logsender()?
**
**	Returns:
**		none.
**
**	Side Effects:
**		Sets a bunch of global variables from information
**			in the collected header.
*/

void
eatheader(e, full, log)
	register ENVELOPE *e;
	bool full;
	bool log;
{
	register HDR *h;
	register char *p;
	int hopcnt = 0;
	char buf[MAXLINE];

	/*
	**  Set up macros for possible expansion in headers.
	*/

	macdefine(&e->e_macro, A_PERM, 'f', e->e_sender);
	macdefine(&e->e_macro, A_PERM, 'g', e->e_sender);
	if (e->e_origrcpt != NULL && *e->e_origrcpt != '\0')
		macdefine(&e->e_macro, A_PERM, 'u', e->e_origrcpt);
	else
		macdefine(&e->e_macro, A_PERM, 'u', NULL);

	/* full name of from person */
	p = hvalue("full-name", e->e_header);
	if (p != NULL)
	{
		if (!rfc822_string(p))
		{
			/*
			**  Quote a full name with special characters
			**  as a comment so crackaddr() doesn't destroy
			**  the name portion of the address.
			*/

			p = addquotes(p, e->e_rpool);
		}
		macdefine(&e->e_macro, A_PERM, 'x', p);
	}

	if (tTd(32, 1))
		sm_dprintf("----- collected header -----\n");
	e->e_msgid = NULL;
	for (h = e->e_header; h != NULL; h = h->h_link)
	{
		if (tTd(32, 1))
			sm_dprintf("%s:", h->h_field);
		if (h->h_value == NULL)
		{
			if (tTd(32, 1))
				sm_dprintf("<NULL>\n");
			continue;
		}

		/* do early binding */
		if (bitset(H_DEFAULT, h->h_flags) &&
		    !bitset(H_BINDLATE, h->h_flags))
		{
			if (tTd(32, 1))
			{
				sm_dprintf("(");
				xputs(sm_debug_file(), h->h_value);
				sm_dprintf(") ");
			}
			expand(h->h_value, buf, sizeof(buf), e);
			if (buf[0] != '\0' &&
			    (buf[0] != ' ' || buf[1] != '\0'))
			{
				if (bitset(H_FROM, h->h_flags))
					expand(crackaddr(buf, e),
					       buf, sizeof(buf), e);
				h->h_value = sm_rpool_strdup_x(e->e_rpool, buf);
				h->h_flags &= ~H_DEFAULT;
			}
		}
		if (tTd(32, 1))
		{
			xputs(sm_debug_file(), h->h_value);
			sm_dprintf("\n");
		}

		/* count the number of times it has been processed */
		if (bitset(H_TRACE, h->h_flags))
			hopcnt++;

		/* send to this person if we so desire */
		if (GrabTo && bitset(H_RCPT, h->h_flags) &&
		    !bitset(H_DEFAULT, h->h_flags) &&
		    (!bitset(EF_RESENT, e->e_flags) ||
		     bitset(H_RESENT, h->h_flags)))
		{
#if 0
			int saveflags = e->e_flags;
#endif /* 0 */

			(void) sendtolist(denlstring(h->h_value, true, false),
					  NULLADDR, &e->e_sendqueue, 0, e);

#if 0
			/*
			**  Change functionality so a fatal error on an
			**  address doesn't affect the entire envelope.
			*/

			/* delete fatal errors generated by this address */
			if (!bitset(EF_FATALERRS, saveflags))
				e->e_flags &= ~EF_FATALERRS;
#endif /* 0 */
		}

		/* save the message-id for logging */
		p = "resent-message-id";
		if (!bitset(EF_RESENT, e->e_flags))
			p += 7;
		if (sm_strcasecmp(h->h_field, p) == 0)
		{
			e->e_msgid = h->h_value;
			while (isascii(*e->e_msgid) && isspace(*e->e_msgid))
				e->e_msgid++;
			macdefine(&e->e_macro, A_PERM, macid("{msg_id}"),
				  e->e_msgid);
		}
	}
	if (tTd(32, 1))
		sm_dprintf("----------------------------\n");

	/* if we are just verifying (that is, sendmail -t -bv), drop out now */
	if (OpMode == MD_VERIFY)
		return;

	/* store hop count */
	if (hopcnt > e->e_hopcount)
	{
		e->e_hopcount = hopcnt;
		(void) sm_snprintf(buf, sizeof(buf), "%d", e->e_hopcount);
		macdefine(&e->e_macro, A_TEMP, 'c', buf);
	}

	/* message priority */
	p = hvalue("precedence", e->e_header);
	if (p != NULL)
		e->e_class = priencode(p);
	if (e->e_class < 0)
		e->e_timeoutclass = TOC_NONURGENT;
	else if (e->e_class > 0)
		e->e_timeoutclass = TOC_URGENT;
	if (full)
	{
		e->e_msgpriority = e->e_msgsize
				 - e->e_class * WkClassFact
				 + e->e_nrcpts * WkRecipFact;
	}

	/* check for DSN to properly set e_timeoutclass */
	p = hvalue("content-type", e->e_header);
	if (p != NULL)
	{
		bool oldsupr;
		char **pvp;
		char pvpbuf[MAXLINE];
		extern unsigned char MimeTokenTab[256];

		/* tokenize header */
		oldsupr = SuprErrs;
		SuprErrs = true;
		pvp = prescan(p, '\0', pvpbuf, sizeof(pvpbuf), NULL,
			      MimeTokenTab, false);
		SuprErrs = oldsupr;

		/* Check if multipart/report */
		if (pvp != NULL && pvp[0] != NULL &&
		    pvp[1] != NULL && pvp[2] != NULL &&
		    sm_strcasecmp(*pvp++, "multipart") == 0 &&
		    strcmp(*pvp++, "/") == 0 &&
		    sm_strcasecmp(*pvp++, "report") == 0)
		{
			/* Look for report-type=delivery-status */
			while (*pvp != NULL)
			{
				/* skip to semicolon separator */
				while (*pvp != NULL && strcmp(*pvp, ";") != 0)
					pvp++;

				/* skip semicolon */
				if (*pvp++ == NULL || *pvp == NULL)
					break;

				/* look for report-type */
				if (sm_strcasecmp(*pvp++, "report-type") != 0)
					continue;

				/* skip equal */
				if (*pvp == NULL || strcmp(*pvp, "=") != 0)
					continue;

				/* check value */
				if (*++pvp != NULL &&
				    sm_strcasecmp(*pvp,
						  "delivery-status") == 0)
					e->e_timeoutclass = TOC_DSN;

				/* found report-type, no need to continue */
				break;
			}
		}
	}

	/* message timeout priority */
	p = hvalue("priority", e->e_header);
	if (p != NULL)
	{
		/* (this should be in the configuration file) */
		if (sm_strcasecmp(p, "urgent") == 0)
			e->e_timeoutclass = TOC_URGENT;
		else if (sm_strcasecmp(p, "normal") == 0)
			e->e_timeoutclass = TOC_NORMAL;
		else if (sm_strcasecmp(p, "non-urgent") == 0)
			e->e_timeoutclass = TOC_NONURGENT;
		else if (bitset(EF_RESPONSE, e->e_flags))
			e->e_timeoutclass = TOC_DSN;
	}
	else if (bitset(EF_RESPONSE, e->e_flags))
		e->e_timeoutclass = TOC_DSN;

	/* date message originated */
	p = hvalue("posted-date", e->e_header);
	if (p == NULL)
		p = hvalue("date", e->e_header);
	if (p != NULL)
		macdefine(&e->e_macro, A_PERM, 'a', p);

	/* check to see if this is a MIME message */
	if ((e->e_bodytype != NULL &&
	     sm_strcasecmp(e->e_bodytype, "8BITMIME") == 0) ||
	    hvalue("MIME-Version", e->e_header) != NULL)
	{
		e->e_flags |= EF_IS_MIME;
		if (HasEightBits)
			e->e_bodytype = "8BITMIME";
	}
	else if ((p = hvalue("Content-Type", e->e_header)) != NULL)
	{
		/* this may be an RFC 1049 message */
		p = strpbrk(p, ";/");
		if (p == NULL || *p == ';')
		{
			/* yep, it is */
			e->e_flags |= EF_DONT_MIME;
		}
	}

	/*
	**  From person in antiquated ARPANET mode
	**	required by UK Grey Book e-mail gateways (sigh)
	*/

	if (OpMode == MD_ARPAFTP)
	{
		register struct hdrinfo *hi;

		for (hi = HdrInfo; hi->hi_field != NULL; hi++)
		{
			if (bitset(H_FROM, hi->hi_flags) &&
			    (!bitset(H_RESENT, hi->hi_flags) ||
			     bitset(EF_RESENT, e->e_flags)) &&
			    (p = hvalue(hi->hi_field, e->e_header)) != NULL)
				break;
		}
		if (hi->hi_field != NULL)
		{
			if (tTd(32, 2))
				sm_dprintf("eatheader: setsender(*%s == %s)\n",
					hi->hi_field, p);
			setsender(p, e, NULL, '\0', true);
		}
	}

	/*
	**  Log collection information.
	*/

	if (tTd(92, 2))
		sm_dprintf("eatheader: e_id=%s, EF_LOGSENDER=%d, LogLevel=%d, log=%d\n",
			e->e_id, bitset(EF_LOGSENDER, e->e_flags), LogLevel,
			log);
	if (log && bitset(EF_LOGSENDER, e->e_flags) && LogLevel > 4)
	{
		logsender(e, e->e_msgid);
		e->e_flags &= ~EF_LOGSENDER;
	}
}

/*
**  LOGSENDER -- log sender information
**
**	Parameters:
**		e -- the envelope to log
**		msgid -- the message id
**
**	Returns:
**		none
*/

void
logsender(e, msgid)
	register ENVELOPE *e;
	char *msgid;
{
	char *name;
	register char *sbp;
	register char *p;
	char hbuf[MAXNAME + 1];
	char sbuf[MAXLINE + 1];
	char mbuf[MAXNAME + 1];

	/* don't allow newlines in the message-id */
	/* XXX do we still need this? sm_syslog() replaces control chars */
	if (msgid != NULL)
	{
		size_t l;

		l = strlen(msgid);
		if (l > sizeof(mbuf) - 1)
			l = sizeof(mbuf) - 1;
		memmove(mbuf, msgid, l);
		mbuf[l] = '\0';
		p = mbuf;
		while ((p = strchr(p, '\n')) != NULL)
			*p++ = ' ';
	}

	if (bitset(EF_RESPONSE, e->e_flags))
		name = "[RESPONSE]";
	else if ((name = macvalue('_', e)) != NULL)
		/* EMPTY */
		;
	else if (RealHostName == NULL)
		name = "localhost";
	else if (RealHostName[0] == '[')
		name = RealHostName;
	else
	{
		name = hbuf;
		(void) sm_snprintf(hbuf, sizeof(hbuf), "%.80s", RealHostName);
		if (RealHostAddr.sa.sa_family != 0)
		{
			p = &hbuf[strlen(hbuf)];
			(void) sm_snprintf(p, SPACELEFT(hbuf, p),
					   " (%.100s)",
					   anynet_ntoa(&RealHostAddr));
		}
	}

	/* some versions of syslog only take 5 printf args */
#if (SYSLOG_BUFSIZE) >= 256
	sbp = sbuf;
	(void) sm_snprintf(sbp, SPACELEFT(sbuf, sbp),
		"from=%.200s, size=%ld, class=%d, nrcpts=%d",
		e->e_from.q_paddr == NULL ? "<NONE>" : e->e_from.q_paddr,
		PRT_NONNEGL(e->e_msgsize), e->e_class, e->e_nrcpts);
	sbp += strlen(sbp);
	if (msgid != NULL)
	{
		(void) sm_snprintf(sbp, SPACELEFT(sbuf, sbp),
				", msgid=%.100s", mbuf);
		sbp += strlen(sbp);
	}
	if (e->e_bodytype != NULL)
	{
		(void) sm_snprintf(sbp, SPACELEFT(sbuf, sbp),
				", bodytype=%.20s", e->e_bodytype);
		sbp += strlen(sbp);
	}
	p = macvalue('r', e);
	if (p != NULL)
	{
		(void) sm_snprintf(sbp, SPACELEFT(sbuf, sbp),
				", proto=%.20s", p);
		sbp += strlen(sbp);
	}
	p = macvalue(macid("{daemon_name}"), e);
	if (p != NULL)
	{
		(void) sm_snprintf(sbp, SPACELEFT(sbuf, sbp),
				", daemon=%.20s", p);
		sbp += strlen(sbp);
	}
	sm_syslog(LOG_INFO, e->e_id, "%.850s, relay=%s", sbuf, name);

#else /* (SYSLOG_BUFSIZE) >= 256 */

	sm_syslog(LOG_INFO, e->e_id,
		  "from=%s",
		  e->e_from.q_paddr == NULL ? "<NONE>"
					    : shortenstring(e->e_from.q_paddr,
							    83));
	sm_syslog(LOG_INFO, e->e_id,
		  "size=%ld, class=%ld, nrcpts=%d",
		  PRT_NONNEGL(e->e_msgsize), e->e_class, e->e_nrcpts);
	if (msgid != NULL)
		sm_syslog(LOG_INFO, e->e_id,
			  "msgid=%s",
			  shortenstring(mbuf, 83));
	sbp = sbuf;
	*sbp = '\0';
	if (e->e_bodytype != NULL)
	{
		(void) sm_snprintf(sbp, SPACELEFT(sbuf, sbp),
				"bodytype=%.20s, ", e->e_bodytype);
		sbp += strlen(sbp);
	}
	p = macvalue('r', e);
	if (p != NULL)
	{
		(void) sm_snprintf(sbp, SPACELEFT(sbuf, sbp),
				"proto=%.20s, ", p);
		sbp += strlen(sbp);
	}
	sm_syslog(LOG_INFO, e->e_id,
		  "%.400srelay=%s", sbuf, name);
#endif /* (SYSLOG_BUFSIZE) >= 256 */
}

/*
**  PRIENCODE -- encode external priority names into internal values.
**
**	Parameters:
**		p -- priority in ascii.
**
**	Returns:
**		priority as a numeric level.
**
**	Side Effects:
**		none.
*/

static int
priencode(p)
	char *p;
{
	register int i;

	for (i = 0; i < NumPriorities; i++)
	{
		if (sm_strcasecmp(p, Priorities[i].pri_name) == 0)
			return Priorities[i].pri_val;
	}

	/* unknown priority */
	return 0;
}

/*
**  CRACKADDR -- parse an address and turn it into a macro
**
**	This doesn't actually parse the address -- it just extracts
**	it and replaces it with "$g".  The parse is totally ad hoc
**	and isn't even guaranteed to leave something syntactically
**	identical to what it started with.  However, it does leave
**	something semantically identical if possible, else at least
**	syntactically correct.
**
**	For example, it changes "Real Name <real@@example.com> (Comment)"
**	to "Real Name <$g> (Comment)".
**
**	This algorithm has been cleaned up to handle a wider range
**	of cases -- notably quoted and backslash escaped strings.
**	This modification makes it substantially better at preserving
**	the original syntax.
**
**	Parameters:
**		addr -- the address to be cracked.
**		e -- the current envelope.
**
**	Returns:
**		a pointer to the new version.
**
**	Side Effects:
**		none.
**
**	Warning:
**		The return value is saved in local storage and should
**		be copied if it is to be reused.
*/

#define SM_HAVE_ROOM		((bp < buflim) && (buflim <= bufend))

/*
**  Append a character to bp if we have room.
**  If not, punt and return $g.
*/

#define SM_APPEND_CHAR(c)					\
	do							\
	{							\
		if (SM_HAVE_ROOM)				\
			*bp++ = (c);				\
		else						\
			goto returng;				\
	} while (0)

#if MAXNAME < 10
ERROR MAXNAME must be at least 10
#endif /* MAXNAME < 10 */

char *
crackaddr(addr, e)
	register char *addr;
	ENVELOPE *e;
{
	register char *p;
	register char c;
	int cmtlev;			/* comment level in input string */
	int realcmtlev;			/* comment level in output string */
	int anglelev;			/* angle level in input string */
	int copylev;			/* 0 == in address, >0 copying */
	int bracklev;			/* bracket level for IPv6 addr check */
	bool addangle;			/* put closing angle in output */
	bool qmode;			/* quoting in original string? */
	bool realqmode;			/* quoting in output string? */
	bool putgmac = false;		/* already wrote $g */
	bool quoteit = false;		/* need to quote next character */
	bool gotangle = false;		/* found first '<' */
	bool gotcolon = false;		/* found a ':' */
	register char *bp;
	char *buflim;
	char *bufhead;
	char *addrhead;
	char *bufend;
	static char buf[MAXNAME + 1];

	if (tTd(33, 1))
		sm_dprintf("crackaddr(%s)\n", addr);

	buflim = bufend = &buf[sizeof(buf) - 1];
	bp = bufhead = buf;

	/* skip over leading spaces but preserve them */
	while (*addr != '\0' && isascii(*addr) && isspace(*addr))
	{
		SM_APPEND_CHAR(*addr);
		addr++;
	}
	bufhead = bp;

	/*
	**  Start by assuming we have no angle brackets.  This will be
	**  adjusted later if we find them.
	*/

	p = addrhead = addr;
	copylev = anglelev = cmtlev = realcmtlev = 0;
	bracklev = 0;
	qmode = realqmode = addangle = false;

	while ((c = *p++) != '\0')
	{
		/*
		**  Try to keep legal syntax using spare buffer space
		**  (maintained by buflim).
		*/

		if (copylev > 0)
			SM_APPEND_CHAR(c);

		/* check for backslash escapes */
		if (c == '\\')
		{
			/* arrange to quote the address */
			if (cmtlev <= 0 && !qmode)
				quoteit = true;

			if ((c = *p++) == '\0')
			{
				/* too far */
				p--;
				goto putg;
			}
			if (copylev > 0)
				SM_APPEND_CHAR(c);
			goto putg;
		}

		/* check for quoted strings */
		if (c == '"' && cmtlev <= 0)
		{
			qmode = !qmode;
			if (copylev > 0 && SM_HAVE_ROOM)
			{
				if (realqmode)
					buflim--;
				else
					buflim++;
				realqmode = !realqmode;
			}
			continue;
		}
		if (qmode)
			goto putg;

		/* check for comments */
		if (c == '(')
		{
			cmtlev++;

			/* allow space for closing paren */
			if (SM_HAVE_ROOM)
			{
				buflim--;
				realcmtlev++;
				if (copylev++ <= 0)
				{
					if (bp != bufhead)
						SM_APPEND_CHAR(' ');
					SM_APPEND_CHAR(c);
				}
			}
		}
		if (cmtlev > 0)
		{
			if (c == ')')
			{
				cmtlev--;
				copylev--;
				if (SM_HAVE_ROOM)
				{
					realcmtlev--;
					buflim++;
				}
			}
			continue;
		}
		else if (c == ')')
		{
			/* syntax error: unmatched ) */
			if (copylev > 0 && SM_HAVE_ROOM && bp > bufhead)
				bp--;
		}

		/* count nesting on [ ... ] (for IPv6 domain literals) */
		if (c == '[')
			bracklev++;
		else if (c == ']')
			bracklev--;

		/* check for group: list; syntax */
		if (c == ':' && anglelev <= 0 && bracklev <= 0 &&
		    !gotcolon && !ColonOkInAddr)
		{
			register char *q;

			/*
			**  Check for DECnet phase IV ``::'' (host::user)
			**  or DECnet phase V ``:.'' syntaxes.  The latter
			**  covers ``user@@DEC:.tay.myhost'' and
			**  ``DEC:.tay.myhost::user'' syntaxes (bletch).
			*/

			if (*p == ':' || *p == '.')
			{
				if (cmtlev <= 0 && !qmode)
					quoteit = true;
				if (copylev > 0)
				{
					SM_APPEND_CHAR(c);
					SM_APPEND_CHAR(*p);
				}
				p++;
				goto putg;
			}

			gotcolon = true;

			bp = bufhead;
			if (quoteit)
			{
				SM_APPEND_CHAR('"');

				/* back up over the ':' and any spaces */
				--p;
				while (p > addr &&
				       isascii(*--p) && isspace(*p))
					continue;
				p++;
			}
			for (q = addrhead; q < p; )
			{
				c = *q++;
				if (quoteit && c == '"')
					SM_APPEND_CHAR('\\');
				SM_APPEND_CHAR(c);
			}
			if (quoteit)
			{
				if (bp == &bufhead[1])
					bp--;
				else
					SM_APPEND_CHAR('"');
				while ((c = *p++) != ':')
					SM_APPEND_CHAR(c);
				SM_APPEND_CHAR(c);
			}

			/* any trailing white space is part of group: */
			while (isascii(*p) && isspace(*p))
			{
				SM_APPEND_CHAR(*p);
				p++;
			}
			copylev = 0;
			putgmac = quoteit = false;
			bufhead = bp;
			addrhead = p;
			continue;
		}

		if (c == ';' && copylev <= 0 && !ColonOkInAddr)
			SM_APPEND_CHAR(c);

		/* check for characters that may have to be quoted */
		if (strchr(MustQuoteChars, c) != NULL)
		{
			/*
			**  If these occur as the phrase part of a <>
			**  construct, but are not inside of () or already
			**  quoted, they will have to be quoted.  Note that
			**  now (but don't actually do the quoting).
			*/

			if (cmtlev <= 0 && !qmode)
				quoteit = true;
		}

		/* check for angle brackets */
		if (c == '<')
		{
			register char *q;

			/* assume first of two angles is bogus */
			if (gotangle)
				quoteit = true;
			gotangle = true;

			/* oops -- have to change our mind */
			anglelev = 1;
			if (SM_HAVE_ROOM)
			{
				if (!addangle)
					buflim--;
				addangle = true;
			}

			bp = bufhead;
			if (quoteit)
			{
				SM_APPEND_CHAR('"');

				/* back up over the '<' and any spaces */
				--p;
				while (p > addr &&
				       isascii(*--p) && isspace(*p))
					continue;
				p++;
			}
			for (q = addrhead; q < p; )
			{
				c = *q++;
				if (quoteit && c == '"')
				{
					SM_APPEND_CHAR('\\');
					SM_APPEND_CHAR(c);
				}
				else
					SM_APPEND_CHAR(c);
			}
			if (quoteit)
			{
				if (bp == &buf[1])
					bp--;
				else
					SM_APPEND_CHAR('"');
				while ((c = *p++) != '<')
					SM_APPEND_CHAR(c);
				SM_APPEND_CHAR(c);
			}
			copylev = 0;
			putgmac = quoteit = false;
			continue;
		}

		if (c == '>')
		{
			if (anglelev > 0)
			{
				anglelev--;
				if (SM_HAVE_ROOM)
				{
					if (addangle)
						buflim++;
					addangle = false;
				}
			}
			else if (SM_HAVE_ROOM)
			{
				/* syntax error: unmatched > */
				if (copylev > 0 && bp > bufhead)
					bp--;
				quoteit = true;
				continue;
			}
			if (copylev++ <= 0)
				SM_APPEND_CHAR(c);
			continue;
		}

		/* must be a real address character */
	putg:
		if (copylev <= 0 && !putgmac)
		{
			if (bp > buf && bp[-1] == ')')
				SM_APPEND_CHAR(' ');
			SM_APPEND_CHAR(MACROEXPAND);
			SM_APPEND_CHAR('g');
			putgmac = true;
		}
	}

	/* repair any syntactic damage */
	if (realqmode && bp < bufend)
		*bp++ = '"';
	while (realcmtlev-- > 0 && bp < bufend)
		*bp++ = ')';
	if (addangle && bp < bufend)
		*bp++ = '>';
	*bp = '\0';
	if (bp < bufend)
		goto success;

 returng:
	/* String too long, punt */
	buf[0] = '<';
	buf[1] = MACROEXPAND;
	buf[2]= 'g';
	buf[3] = '>';
	buf[4]= '\0';
	sm_syslog(LOG_ALERT, e->e_id,
		  "Dropped invalid comments from header address");

 success:
	if (tTd(33, 1))
	{
		sm_dprintf("crackaddr=>`");
		xputs(sm_debug_file(), buf);
		sm_dprintf("'\n");
	}
	return buf;
}

/*
**  PUTHEADER -- put the header part of a message from the in-core copy
**
**	Parameters:
**		mci -- the connection information.
**		hdr -- the header to put.
**		e -- envelope to use.
**		flags -- MIME conversion flags.
**
**	Returns:
**		true iff header part was written successfully
**
**	Side Effects:
**		none.
*/

bool
putheader(mci, hdr, e, flags)
	register MCI *mci;
	HDR *hdr;
	register ENVELOPE *e;
	int flags;
{
	register HDR *h;
	char buf[SM_MAX(MAXLINE,BUFSIZ)];
	char obuf[MAXLINE];

	if (tTd(34, 1))
		sm_dprintf("--- putheader, mailer = %s ---\n",
			mci->mci_mailer->m_name);

	/*
	**  If we're in MIME mode, we're not really in the header of the
	**  message, just the header of one of the parts of the body of
	**  the message.  Therefore MCIF_INHEADER should not be turned on.
	*/

	if (!bitset(MCIF_INMIME, mci->mci_flags))
		mci->mci_flags |= MCIF_INHEADER;

	for (h = hdr; h != NULL; h = h->h_link)
	{
		register char *p = h->h_value;
		char *q;

		if (tTd(34, 11))
		{
			sm_dprintf("  %s:", h->h_field);
			xputs(sm_debug_file(), p);
		}

		/* Skip empty headers */
		if (h->h_value == NULL)
			continue;

		/* heuristic shortening of MIME fields to avoid MUA overflows */
		if (MaxMimeFieldLength > 0 &&
		    wordinclass(h->h_field,
				macid("{checkMIMEFieldHeaders}")))
		{
			size_t len;

			len = fix_mime_header(h, e);
			if (len > 0)
			{
				sm_syslog(LOG_ALERT, e->e_id,
					  "Truncated MIME %s header due to field size (length = %ld) (possible attack)",
					  h->h_field, (unsigned long) len);
				if (tTd(34, 11))
					sm_dprintf("  truncated MIME %s header due to field size  (length = %ld) (possible attack)\n",
						   h->h_field,
						   (unsigned long) len);
			}
		}

		if (MaxMimeHeaderLength > 0 &&
		    wordinclass(h->h_field,
				macid("{checkMIMETextHeaders}")))
		{
			size_t len;

			len = strlen(h->h_value);
			if (len > (size_t) MaxMimeHeaderLength)
			{
				h->h_value[MaxMimeHeaderLength - 1] = '\0';
				sm_syslog(LOG_ALERT, e->e_id,
					  "Truncated long MIME %s header (length = %ld) (possible attack)",
					  h->h_field, (unsigned long) len);
				if (tTd(34, 11))
					sm_dprintf("  truncated long MIME %s header (length = %ld) (possible attack)\n",
						   h->h_field,
						   (unsigned long) len);
			}
		}

		if (MaxMimeHeaderLength > 0 &&
		    wordinclass(h->h_field,
				macid("{checkMIMEHeaders}")))
		{
			size_t len;

			len = strlen(h->h_value);
			if (shorten_rfc822_string(h->h_value,
						  MaxMimeHeaderLength))
			{
				if (len < MaxMimeHeaderLength)
				{
					/* we only rebalanced a bogus header */
					sm_syslog(LOG_ALERT, e->e_id,
						  "Fixed MIME %s header (possible attack)",
						  h->h_field);
					if (tTd(34, 11))
						sm_dprintf("  fixed MIME %s header (possible attack)\n",
							   h->h_field);
				}
				else
				{
					/* we actually shortened header */
					sm_syslog(LOG_ALERT, e->e_id,
						  "Truncated long MIME %s header (length = %ld) (possible attack)",
						  h->h_field,
						  (unsigned long) len);
					if (tTd(34, 11))
						sm_dprintf("  truncated long MIME %s header (length = %ld) (possible attack)\n",
							   h->h_field,
							   (unsigned long) len);
				}
			}
		}

		/*
		**  Suppress Content-Transfer-Encoding: if we are MIMEing
		**  and we are potentially converting from 8 bit to 7 bit
		**  MIME.  If converting, add a new CTE header in
		**  mime8to7().
		*/

		if (bitset(H_CTE, h->h_flags) &&
		    bitset(MCIF_CVT8TO7|MCIF_CVT7TO8|MCIF_INMIME,
			   mci->mci_flags) &&
		    !bitset(M87F_NO8TO7, flags))
		{
			if (tTd(34, 11))
				sm_dprintf(" (skipped (content-transfer-encoding))\n");
			continue;
		}

		if (bitset(MCIF_INMIME, mci->mci_flags))
		{
			if (tTd(34, 11))
				sm_dprintf("\n");
			if (!put_vanilla_header(h, p, mci))
				goto writeerr;
			continue;
		}

		if (bitset(H_CHECK|H_ACHECK, h->h_flags) &&
		    !bitintersect(h->h_mflags, mci->mci_mailer->m_flags) &&
		    (h->h_macro == '\0' ||
		     (q = macvalue(bitidx(h->h_macro), e)) == NULL ||
		     *q == '\0'))
		{
			if (tTd(34, 11))
				sm_dprintf(" (skipped)\n");
			continue;
		}

		/* handle Resent-... headers specially */
		if (bitset(H_RESENT, h->h_flags) && !bitset(EF_RESENT, e->e_flags))
		{
			if (tTd(34, 11))
				sm_dprintf(" (skipped (resent))\n");
			continue;
		}

		/* suppress return receipts if requested */
		if (bitset(H_RECEIPTTO, h->h_flags) &&
		    (RrtImpliesDsn || bitset(EF_NORECEIPT, e->e_flags)))
		{
			if (tTd(34, 11))
				sm_dprintf(" (skipped (receipt))\n");
			continue;
		}

		/* macro expand value if generated internally */
		if (bitset(H_DEFAULT, h->h_flags) ||
		    bitset(H_BINDLATE, h->h_flags))
		{
			expand(p, buf, sizeof(buf), e);
			p = buf;
			if (*p == '\0')
			{
				if (tTd(34, 11))
					sm_dprintf(" (skipped -- null value)\n");
				continue;
			}
		}

		if (bitset(H_BCC, h->h_flags))
		{
			/* Bcc: field -- either truncate or delete */
			if (bitset(EF_DELETE_BCC, e->e_flags))
			{
				if (tTd(34, 11))
					sm_dprintf(" (skipped -- bcc)\n");
			}
			else
			{
				/* no other recipient headers: truncate value */
				(void) sm_strlcpyn(obuf, sizeof(obuf), 2,
						   h->h_field, ":");
				if (!putline(obuf, mci))
					goto writeerr;
			}
			continue;
		}

		if (tTd(34, 11))
			sm_dprintf("\n");

		if (bitset(H_FROM|H_RCPT, h->h_flags))
		{
			/* address field */
			bool oldstyle = bitset(EF_OLDSTYLE, e->e_flags);

			if (bitset(H_FROM, h->h_flags))
				oldstyle = false;
			commaize(h, p, oldstyle, mci, e,
				 PXLF_HEADER | PXLF_STRIPMQUOTE);
		}
		else
		{
			if (!put_vanilla_header(h, p, mci))
				goto writeerr;
		}
	}

	/*
	**  If we are converting this to a MIME message, add the
	**  MIME headers (but not in MIME mode!).
	*/

#if MIME8TO7
	if (bitset(MM_MIME8BIT, MimeMode) &&
	    bitset(EF_HAS8BIT, e->e_flags) &&
	    !bitset(EF_DONT_MIME, e->e_flags) &&
	    !bitnset(M_8BITS, mci->mci_mailer->m_flags) &&
	    !bitset(MCIF_CVT8TO7|MCIF_CVT7TO8|MCIF_INMIME, mci->mci_flags) &&
	    hvalue("MIME-Version", e->e_header) == NULL)
	{
		if (!putline("MIME-Version: 1.0", mci))
			goto writeerr;
		if (hvalue("Content-Type", e->e_header) == NULL)
		{
			(void) sm_snprintf(obuf, sizeof(obuf),
					"Content-Type: text/plain; charset=%s",
					defcharset(e));
			if (!putline(obuf, mci))
				goto writeerr;
		}
		if (hvalue("Content-Transfer-Encoding", e->e_header) == NULL
		    && !putline("Content-Transfer-Encoding: 8bit", mci))
			goto writeerr;
	}
#endif /* MIME8TO7 */
	return true;

  writeerr:
	return false;
}

/*
**  PUT_VANILLA_HEADER -- output a fairly ordinary header
**
**	Parameters:
**		h -- the structure describing this header
**		v -- the value of this header
**		mci -- the connection info for output
**
**	Returns:
**		true iff header was written successfully
*/

static bool
put_vanilla_header(h, v, mci)
	HDR *h;
	char *v;
	MCI *mci;
{
	register char *nlp;
	register char *obp;
	int putflags;
	char obuf[MAXLINE + 256];	/* additional length for h_field */

	putflags = PXLF_HEADER | PXLF_STRIPMQUOTE;
	if (bitnset(M_7BITHDRS, mci->mci_mailer->m_flags))
		putflags |= PXLF_STRIP8BIT;
	(void) sm_snprintf(obuf, sizeof(obuf), "%.200s:", h->h_field);
	obp = obuf + strlen(obuf);
	while ((nlp = strchr(v, '\n')) != NULL)
	{
		int l;

		l = nlp - v;

		/*
		**  XXX This is broken for SPACELEFT()==0
		**  However, SPACELEFT() is always > 0 unless MAXLINE==1.
		*/

		if (SPACELEFT(obuf, obp) - 1 < (size_t) l)
			l = SPACELEFT(obuf, obp) - 1;

		(void) sm_snprintf(obp, SPACELEFT(obuf, obp), "%.*s", l, v);
		if (!putxline(obuf, strlen(obuf), mci, putflags))
			goto writeerr;
		v += l + 1;
		obp = obuf;
		if (*v != ' ' && *v != '\t')
			*obp++ = ' ';
	}

	/* XXX This is broken for SPACELEFT()==0 */
	(void) sm_snprintf(obp, SPACELEFT(obuf, obp), "%.*s",
			   (int) (SPACELEFT(obuf, obp) - 1), v);
	return putxline(obuf, strlen(obuf), mci, putflags);

  writeerr:
	return false;
}

/*
**  COMMAIZE -- output a header field, making a comma-translated list.
**
**	Parameters:
**		h -- the header field to output.
**		p -- the value to put in it.
**		oldstyle -- true if this is an old style header.
**		mci -- the connection information.
**		e -- the envelope containing the message.
**		putflags -- flags for putxline()
**
**	Returns:
**		true iff header field was written successfully
**
**	Side Effects:
**		outputs "p" to "mci".
*/

bool
commaize(h, p, oldstyle, mci, e, putflags)
	register HDR *h;
	register char *p;
	bool oldstyle;
	register MCI *mci;
	register ENVELOPE *e;
	int putflags;
{
	register char *obp;
	int opos, omax, spaces;
	bool firstone = true;
	char **res;
	char obuf[MAXLINE + 3];

	/*
	**  Output the address list translated by the
	**  mailer and with commas.
	*/

	if (tTd(14, 2))
		sm_dprintf("commaize(%s:%s)\n", h->h_field, p);

	if (bitnset(M_7BITHDRS, mci->mci_mailer->m_flags))
		putflags |= PXLF_STRIP8BIT;

	obp = obuf;
	(void) sm_snprintf(obp, SPACELEFT(obuf, obp), "%.200s:", h->h_field);
	/* opos = strlen(obp); instead of the next 3 lines? */
	opos = strlen(h->h_field) + 1;
	if (opos > 201)
		opos = 201;
	obp += opos;

	spaces = 0;
	while (*p != '\0' && isascii(*p) && isspace(*p))
	{
		++spaces;
		++p;
	}
	if (spaces > 0)
	{
		SM_ASSERT(sizeof(obuf) > opos  * 2);

		/*
		**  Restrict number of spaces to half the length of buffer
		**  so the header field body can be put in here too.
		**  Note: this is a hack...
		*/

		if (spaces > sizeof(obuf) / 2)
			spaces = sizeof(obuf) / 2;
		(void) sm_snprintf(obp, SPACELEFT(obuf, obp), "%*s", spaces,
				"");
		opos += spaces;
		obp += spaces;
		SM_ASSERT(obp < &obuf[MAXLINE]);
	}

	omax = mci->mci_mailer->m_linelimit - 2;
	if (omax < 0 || omax > 78)
		omax = 78;

	/*
	**  Run through the list of values.
	*/

	while (*p != '\0')
	{
		register char *name;
		register int c;
		char savechar;
		int flags;
		auto int status;

		/*
		**  Find the end of the name.  New style names
		**  end with a comma, old style names end with
		**  a space character.  However, spaces do not
		**  necessarily delimit an old-style name -- at
		**  signs mean keep going.
		*/

		/* find end of name */
		while ((isascii(*p) && isspace(*p)) || *p == ',')
			p++;
		name = p;
		res = NULL;
		for (;;)
		{
			auto char *oldp;
			char pvpbuf[PSBUFSIZE];

			res = prescan(p, oldstyle ? ' ' : ',', pvpbuf,
				      sizeof(pvpbuf), &oldp, ExtTokenTab, false);
			p = oldp;
#if _FFR_IGNORE_BOGUS_ADDR
			/* ignore addresses that can't be parsed */
			if (res == NULL)
			{
				name = p;
				continue;
			}
#endif /* _FFR_IGNORE_BOGUS_ADDR */

			/* look to see if we have an at sign */
			while (*p != '\0' && isascii(*p) && isspace(*p))
				p++;

			if (*p != '@@')
			{
				p = oldp;
				break;
			}
			++p;
			while (*p != '\0' && isascii(*p) && isspace(*p))
				p++;
		}
		/* at the end of one complete name */

		/* strip off trailing white space */
		while (p >= name &&
		       ((isascii(*p) && isspace(*p)) || *p == ',' || *p == '\0'))
			p--;
		if (++p == name)
			continue;

		/*
		**  if prescan() failed go a bit backwards; this is a hack,
		**  there should be some better error recovery.
		*/

		if (res == NULL && p > name &&
		    !((isascii(*p) && isspace(*p)) || *p == ',' || *p == '\0'))
			--p;
		savechar = *p;
		*p = '\0';

		/* translate the name to be relative */
		flags = RF_HEADERADDR|RF_ADDDOMAIN;
		if (bitset(H_FROM, h->h_flags))
			flags |= RF_SENDERADDR;
#if USERDB
		else if (e->e_from.q_mailer != NULL &&
			 bitnset(M_UDBRECIPIENT, e->e_from.q_mailer->m_flags))
		{
			char *q;

			q = udbsender(name, e->e_rpool);
			if (q != NULL)
				name = q;
		}
#endif /* USERDB */
		status = EX_OK;
		name = remotename(name, mci->mci_mailer, flags, &status, e);
		if (*name == '\0')
		{
			*p = savechar;
			continue;
		}
		name = denlstring(name, false, true);

		/* output the name with nice formatting */
		opos += strlen(name);
		if (!firstone)
			opos += 2;
		if (opos > omax && !firstone)
		{
			(void) sm_strlcpy(obp, ",\n", SPACELEFT(obuf, obp));
			if (!putxline(obuf, strlen(obuf), mci, putflags))
				goto writeerr;
			obp = obuf;
			(void) sm_strlcpy(obp, "        ", sizeof(obuf));
			opos = strlen(obp);
			obp += opos;
			opos += strlen(name);
		}
		else if (!firstone)
		{
			(void) sm_strlcpy(obp, ", ", SPACELEFT(obuf, obp));
			obp += 2;
		}

		while ((c = *name++) != '\0' && obp < &obuf[MAXLINE])
			*obp++ = c;
		firstone = false;
		*p = savechar;
	}
	if (obp < &obuf[sizeof(obuf)])
		*obp = '\0';
	else
		obuf[sizeof(obuf) - 1] = '\0';
	return putxline(obuf, strlen(obuf), mci, putflags);

  writeerr:
	return false;
}

/*
**  COPYHEADER -- copy header list
**
**	This routine is the equivalent of newstr for header lists
**
**	Parameters:
**		header -- list of header structures to copy.
**		rpool -- resource pool, or NULL
**
**	Returns:
**		a copy of 'header'.
**
**	Side Effects:
**		none.
*/

HDR *
copyheader(header, rpool)
	register HDR *header;
	SM_RPOOL_T *rpool;
{
	register HDR *newhdr;
	HDR *ret;
	register HDR **tail = &ret;

	while (header != NULL)
	{
		newhdr = (HDR *) sm_rpool_malloc_x(rpool, sizeof(*newhdr));
		STRUCTCOPY(*header, *newhdr);
		*tail = newhdr;
		tail = &newhdr->h_link;
		header = header->h_link;
	}
	*tail = NULL;

	return ret;
}

/*
**  FIX_MIME_HEADER -- possibly truncate/rebalance parameters in a MIME header
**
**	Run through all of the parameters of a MIME header and
**	possibly truncate and rebalance the parameter according
**	to MaxMimeFieldLength.
**
**	Parameters:
**		h -- the header to truncate/rebalance
**		e -- the current envelope
**
**	Returns:
**		length of last offending field, 0 if all ok.
**
**	Side Effects:
**		string modified in place
*/

static size_t
fix_mime_header(h, e)
	HDR *h;
	ENVELOPE *e;
{
	char *begin = h->h_value;
	char *end;
	size_t len = 0;
	size_t retlen = 0;

	if (begin == NULL || *begin == '\0')
		return 0;

	/* Split on each ';' */
	/* find_character() never returns NULL */
	while ((end = find_character(begin, ';')) != NULL)
	{
		char save = *end;
		char *bp;

		*end = '\0';

		len = strlen(begin);

		/* Shorten individual parameter */
		if (shorten_rfc822_string(begin, MaxMimeFieldLength))
		{
			if (len < MaxMimeFieldLength)
			{
				/* we only rebalanced a bogus field */
				sm_syslog(LOG_ALERT, e->e_id,
					  "Fixed MIME %s header field (possible attack)",
					  h->h_field);
				if (tTd(34, 11))
					sm_dprintf("  fixed MIME %s header field (possible attack)\n",
						   h->h_field);
			}
			else
			{
				/* we actually shortened the header */
				retlen = len;
			}
		}

		/* Collapse the possibly shortened string with rest */
		bp = begin + strlen(begin);
		if (bp != end)
		{
			char *ep = end;

			*end = save;
			end = bp;

			/* copy character by character due to overlap */
			while (*ep != '\0')
				*bp++ = *ep++;
			*bp = '\0';
		}
		else
			*end = save;
		if (*end == '\0')
			break;

		/* Move past ';' */
		begin = end + 1;
	}
	return retlen;
}
@


1.5
log
@merge sendmail 8.14.6
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004, 2006, 2007 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Id: headers.c,v 8.318 2012/06/14 23:54:02 ca Exp $")
a379 5
		if (tTd(31, 2))
		{
			sm_dprintf("comparing header from (%s) against default (%s or %s)\n",
				fvalue, e->e_from.q_paddr, e->e_from.q_user);
		}
d386 6
d410 13
@


1.4
log
@merge newer sendmail; fix and correct; reduce upstream diffs; prep for deb
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Id: headers.c,v 8.317 2008/08/27 20:11:55 gshapiro Exp $")
d1155 1
a1155 1
		e->e_msgsize, e->e_class, e->e_nrcpts);
d1194 1
a1194 1
		  e->e_msgsize, e->e_class, e->e_nrcpts);
@


1.3
log
@merge and reduce diffs against upstream
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: headers.c,v 8.312 2007/06/19 18:52:11 ca Exp $")
d718 10
a727 1
			return h->h_value;
d1077 4
@


1.2
log
@upgrade from sendmail 8.14.1 to 8.14.2 ourselves:
> From donotreply@@lists.sendmail.org Fri Nov  2 02:46:04 2007
> From: Claus Assmann <donotreply@@lists.sendmail.org>
Message-ID: <200711020234.lA22YPul046763@@lists.sendmail.org>
To: sendmail-announce@@sendmail.org
Date: Thu, 1 Nov 2007 19:34:25 -0700 (PDT)
Subject: sendmail 8.14.2 available

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Sendmail, Inc., and the Sendmail Consortium announce the availability
of sendmail 8.14.2 which fixes some problems, e.g.,

- - an important bug in the milter function smfi_chgfrom() which could
  cause the loss of a message body.
- - the handling of queued messages with 8 bit characters in From:
  or To: header which could be "mistaken" for internal control
  characters during a queue run and trigger various consistency checks.
- - the handling of lines longer than MAXLINE-1 characters in certain
  cases.

A complete list of changes can be found in the release notes (see
below).

Please send bug reports and general feedback to one of the addresses
listed at: http://www.sendmail.org/email-addresses.html

The version can be found at

ftp://ftp.sendmail.org/pub/sendmail/sendmail.8.14.2.tar.gz
ftp://ftp.sendmail.org/pub/sendmail/sendmail.8.14.2.tar.gz.sig
ftp://ftp.sendmail.org/pub/sendmail/sendmail.8.14.2.tar.Z
ftp://ftp.sendmail.org/pub/sendmail/sendmail.8.14.2.tar.Z.sig

MD5 signatures:
cf784b9f20c32949ae1f38f3eae29875 sendmail.8.14.2.tar.Z
f788d6986f12a81ac958195b045a529d sendmail.8.14.2.tar.Z.sig
1c1472365344ca8061d6453c43c9a831 sendmail.8.14.2.tar.gz
2ae4b6175a08e8a6cda992db20141d81 sendmail.8.14.2.tar.gz.sig

You either need the first two files or the third and fourth, i.e.,
the gzip'ed version or the compressed version and the corresponding
sig file.  The PGP signature was created using the Sendmail Signing
Key/2007, available on the web site (http://www.sendmail.org/) or
on the public key servers.

Since sendmail 8.11 and later includes hooks to cryptography, the
following information from OpenSSL applies to sendmail as well.

   PLEASE REMEMBER THAT EXPORT/IMPORT AND/OR USE OF STRONG CRYPTOGRAPHY
   SOFTWARE, PROVIDING CRYPTOGRAPHY HOOKS OR EVEN JUST COMMUNICATING
   TECHNICAL DETAILS ABOUT CRYPTOGRAPHY SOFTWARE IS ILLEGAL IN SOME
   PARTS OF THE WORLD.  SO, WHEN YOU IMPORT THIS PACKAGE TO YOUR
   COUNTRY, RE-DISTRIBUTE IT FROM THERE OR EVEN JUST EMAIL TECHNICAL
   SUGGESTIONS OR EVEN SOURCE PATCHES TO THE AUTHOR OR OTHER PEOPLE
   YOU ARE STRONGLY ADVISED TO PAY CLOSE ATTENTION TO ANY EXPORT/IMPORT
   AND/OR USE LAWS WHICH APPLY TO YOU. THE AUTHORS ARE NOT LIABLE FOR
   ANY VIOLATIONS YOU MAKE HERE. SO BE CAREFUL, IT IS YOUR RESPONSIBILITY.


			SENDMAIL RELEASE NOTES
      $Id: RELEASE_NOTES,v 8.1909 2007/10/31 16:04:13 ca Exp $


This listing shows the version of the sendmail binary, the version
of the sendmail configuration files, the date of release, and a
summary of the changes in that release.

8.14.2/8.14.2	2007/11/01
	If a message was queued and it contained 8 bit characters in
		a From: or To: header, then those characters could be
		"mistaken" for internal control characters during a queue
		run and trigger various consistency checks.  Problem
		noted by Neil Rickert of Northern Illinois University.
	If MaxMimeHeaderLength is set to a value greater than 0 (which
		it is by default) then even if the Linelimit parameter
		is 0, sendmail corrupted in the non-transfer-encoding
		case every MAXLINE-1 characters.  Patch from John Gardiner
		Myers of Proofpoint.
	Setting the suboption DeliveryMode for DaemonPortOptions did not
		work in earlier 8.14 versions.
	Note: DeliveryMode=interactive is silently converted to
		background if a milter can reject or delete a recipient.
		Prior to 8.14 this happened only if milter could delete
		recipients.
	ClientRate should trigger when the limit was exceeded (as
		documented), not when it was reached.  Patch from
		John Beck of Sun Microsystems.
	Force a queue run for -qGqueuegroup even if no runners are
		specified (R=0) and forking (F=f) is requested.
	When multiple results are requested for a DNS map lookup
		(-z and -Z), return only those that are relevant for
		the query (not also those in the "additional section".)
	If the message transfer time to sendmail (when acting as server)
		exceeds Timeout.queuewarn or Timeout.queuereturn and
		the message is refused (by a milter), sendmail previously
		created a delivery status notification (DSN).  Patch
		from Doug Heath of The Hertz Corporation.
	A code change in Cyrus-SASL 2.1.22 for sasl_decode64() requires
		the MTA to deal with some input (i.e., "=") itself.
		Problem noted by Eliot Lear.
	sendmail counted a delivery as successful if PIPELINING is
		compiled in but not offered by the server and the
		delivery failed temporarily.  Patch from Werner Wiethege.
	If getting the result of an LDAP query times out then close the
		map so it will be reopened on the next lookup.  This
		should help "failover" configurations that specify more
		than one LDAP server.
	If check_compat returns $#discard then a "savemail panic" could
		be triggered under some circumstances (e.g., requiring
		a system which does not have the compile time flag
		HASFLOCK set). Based on patch by Motonori Nakamura
		of National Institute of Informatics, Japan.
	If a milter rejected a recipient, the count for nrcpts= in the
		logfile entry might have been wrong.  Problem found by
		Petra Humann of TU Dresden.
	If a milter invoked smfi_chgfrom() where ESMTP arguments are not
		NULL, the message body was lost.  Patch from Motonori
		Nakamura of National Institute of Informatics, Japan.
	sendmail(8) had a bogus space in -qGname.  Patch from Peng Haitao.
	CONTRIB: buildvirtuser: Preserve ownership and permissions when
		replacing files.
	CONTRIB: buildvirtuser: Skip dot-files (e.g., .cvsignore) when
		reading the /etc/mail/virtusers/ directory.
	CONTRIB: buildvirtuser: Emit warnings instead of exiting where
		appropriate.
	LIBMILTER: Fix ABI backwards compatibility so milters compiled
		against an older libmilter.so shared library can use an
		8.14 libmilter.so shared library.
	LIBMILTER: smfi_version() did not properly extract the patchlevel
		from the version number, however, the returned value was
		correct for the current libmilter version.

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.5 (OpenBSD)

iQCVAwUBRyqEOs8etQMiMnoBAQKNdQP/cQKfjVP7qTi0Ol/OgR7AnvCaerCxiQ5J
y1uxjwXs2s+RemX0u5a4c0agoLscTKU5Ot6uzOdvKvZd0/unr/IkzuXZBF9LsnlZ
X1wS4GXQDXKDfazvwdwOUgxkthMZU1TiVFj/GH5TOfHqVUO5Ho/yRfAQoAn3taFc
5jeg+A3+M9M=
=DJHS
-----END PGP SIGNATURE-----
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: headers.c,v 8.310 2007/02/07 22:44:35 ca Exp $")
@


1.2.2.1
log
@MFC sendmail update to 8.14.3

agreed bsiegert@@
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: headers.c,v 8.312 2007/06/19 18:52:11 ca Exp $")
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004 Sendmail, Inc. and its suppliers.
d15 1
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: headers.c,v 8.287 2004/12/03 18:29:51 ca Exp $")
d19 1
a19 1
static HDR	*allocheader __P((char *, char *, int, SM_RPOOL_T *));
d22 1
a22 1
static void	put_vanilla_header __P((HDR *, char *, MCI *));
d47 1
d49 1
a49 1
**  CHOMPHEADER -- process and save a header line.
d51 1
a51 1
**	Called by collect, readcf, and readqf to deal with header lines.
d68 1
d70 2
a71 2
unsigned long
chompheader(line, pflag, hdrp, e)
d75 1
a75 1
	register ENVELOPE *e;
a90 7
	if (tTd(31, 6))
	{
		sm_dprintf("chompheader: ");
		xputs(sm_debug_file(), line);
		sm_dprintf("\n");
	}

a185 4

	/* strip field value on front */
	if (*p == ' ')
		p++;
d203 1
a203 1
		(void) expand(fvalue, hbuf, sizeof hbuf, e);
d351 1
a351 1
			(void) sm_snprintf(qval, sizeof qval, "%d", k);
a352 1
#if _FFR_HDR_TYPE
a359 1
#endif /* _FFR_HDR_TYPE */
d363 1
a363 1
				       NULL, e->e_id);
d416 1
a416 1
					sizeof mopts);
d423 1
a423 1
	h = (HDR *) sm_rpool_malloc_x(e->e_rpool, sizeof *h);
d427 1
a427 1
	memmove((char *) h->h_mflags, (char *) mopts, sizeof mopts);
d453 63
d520 2
a521 2
**		field -- the name of the header field.
**		value -- the value of the field.
d524 1
d528 7
d538 1
a538 1
allocheader(field, value, flags, rp)
d543 1
d552 1
a552 1
	h = (HDR *) sm_rpool_malloc_x(rp, sizeof *h);
d554 15
a568 1
	h->h_value = sm_rpool_strdup_x(rp, value);
d577 1
d584 2
a585 2
**		field -- the name of the header field.
**		value -- the value of the field.
d588 1
d595 3
d601 1
a601 1
addheader(field, value, flags, e)
d606 1
d620 1
a620 1
	h = allocheader(field, value, flags, e->e_rpool);
d624 1
a626 1
**
d631 2
a632 2
**		field -- the name of the header field.
**		value -- the value of the field.
d635 1
d642 8
d653 1
a653 1
insheader(idx, field, value, flags, e)
d659 1
d664 1
a664 1
	h = allocheader(field, value, flags, e->e_rpool);
d688 1
d700 1
a700 1
**		pointer to the value part.
d722 1
d750 1
a750 1
	register char *s = h;
d752 1
d768 1
d833 1
a833 1
			sm_dprintf("%s: ", h->h_field);
d851 3
a853 2
			expand(h->h_value, buf, sizeof buf, e);
			if (buf[0] != '\0')
d857 1
a857 1
					       buf, sizeof buf, e);
d921 1
a921 1
		(void) sm_snprintf(buf, sizeof buf, "%d", e->e_hopcount);
d952 1
a952 1
		pvp = prescan(p, '\0', pvpbuf, sizeof pvpbuf, NULL,
d1074 1
a1093 1
	int l;
d1102 2
d1105 2
a1106 2
		if (l > sizeof mbuf - 1)
			l = sizeof mbuf - 1;
d1126 1
a1126 1
		(void) sm_snprintf(hbuf, sizeof hbuf, "%.80s", RealHostName);
d1205 1
d1234 1
d1317 4
a1320 1
	/* strip leading spaces */
d1322 2
d1325 2
a1332 2
	buflim = bufend = &buf[sizeof(buf) - 1];
	bp = bufhead = buf;
d1640 1
d1651 1
a1651 1
**		none.
d1657 1
a1657 1
void
d1688 1
a1688 1
			sm_dprintf("  %s: ", h->h_field);
d1792 2
a1793 1
			put_vanilla_header(h, p, mci);
d1829 1
a1829 1
			expand(p, buf, sizeof buf, e);
d1850 1
a1850 1
				(void) sm_strlcpyn(obuf, sizeof obuf, 2,
d1852 2
a1853 1
				putline(obuf, mci);
d1868 2
a1869 1
			commaize(h, p, oldstyle, mci, e);
d1873 2
a1874 1
			put_vanilla_header(h, p, mci);
d1891 2
a1892 1
		putline("MIME-Version: 1.0", mci);
d1895 1
a1895 1
			(void) sm_snprintf(obuf, sizeof obuf,
d1898 2
a1899 1
			putline(obuf, mci);
d1901 3
a1903 2
		if (hvalue("Content-Transfer-Encoding", e->e_header) == NULL)
			putline("Content-Transfer-Encoding: 8bit", mci);
d1906 4
d1911 1
d1921 1
a1921 1
**		none.
d1924 1
a1924 1
static void
d1935 1
a1935 1
	putflags = PXLF_HEADER;
d1938 1
a1938 1
	(void) sm_snprintf(obuf, sizeof obuf, "%.200s: ", h->h_field);
d1955 2
a1956 1
		putxline(obuf, strlen(obuf), mci, putflags);
d1966 4
a1969 1
	putxline(obuf, strlen(obuf), mci, putflags);
d1971 1
d1981 1
d1984 1
a1984 1
**		none.
d1987 1
a1987 1
**		outputs "p" to file "fp".
d1990 2
a1991 2
void
commaize(h, p, oldstyle, mci, e)
d1997 1
d2000 1
a2000 2
	int opos;
	int omax;
a2001 1
	int putflags = PXLF_HEADER;
d2011 1
a2011 1
		sm_dprintf("commaize(%s: %s)\n", h->h_field, p);
d2017 31
a2047 2
	(void) sm_snprintf(obp, SPACELEFT(obuf, obp), "%.200s: ",
			h->h_field);
a2048 5
	/* opos = strlen(obp); */
	opos = strlen(h->h_field) + 2;
	if (opos > 202)
		opos = 202;
	obp += opos;
d2084 1
a2084 1
				      sizeof pvpbuf, &oldp, NULL, false);
a2151 7
		/*
		**  record data progress so DNS timeouts
		**  don't cause DATA timeouts
		*/

		DataProgress = true;

d2159 2
a2160 1
			putxline(obuf, strlen(obuf), mci, putflags);
d2162 1
a2162 1
			(void) sm_strlcpy(obp, "        ", sizeof obuf);
d2178 1
a2178 1
	if (obp < &obuf[sizeof obuf])
d2181 5
a2185 2
		obuf[sizeof obuf - 1] = '\0';
	putxline(obuf, strlen(obuf), mci, putflags);
d2187 1
d2215 1
a2215 1
		newhdr = (HDR *) sm_rpool_malloc_x(rpool, sizeof *newhdr);
d2225 1
@


1.1.127.1
log
@Import Sendmail 8.14.3, suitably stripped down by the not yet committed
contrib/samples/import-3rdpty,v 1.35; we have some new and renamed files
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004, 2006, 2007 Sendmail, Inc. and its suppliers.
a14 1
#include <sm/sendmail.h>
d16 1
a16 1
SM_RCSID("@@(#)$Id: headers.c,v 8.312 2007/06/19 18:52:11 ca Exp $")
d18 1
a18 1
static HDR	*allocheader __P((char *, char *, int, SM_RPOOL_T *, bool));
d21 1
a21 1
static bool	put_vanilla_header __P((HDR *, char *, MCI *));
a45 1

d47 1
a47 1
**  DOCHOMPHEADER -- process and save a header line.
d49 1
a49 1
**	Called by chompheader.
a65 1
static unsigned long	dochompheader __P((char *, int, HDR **, ENVELOPE *));
d67 2
a68 2
static unsigned long
dochompheader(line, pflag, hdrp, e)
d72 1
a72 1
	ENVELOPE *e;
d88 7
d190 4
d211 1
a211 1
		(void) expand(fvalue, hbuf, sizeof(hbuf), e);
d359 1
a359 1
			(void) sm_snprintf(qval, sizeof(qval), "%d", k);
d361 1
d369 1
d373 1
a373 1
				       NULL, e->e_id, NULL);
d426 1
a426 1
					sizeof(mopts));
d433 1
a433 1
	h = (HDR *) sm_rpool_malloc_x(e->e_rpool, sizeof(*h));
d437 1
a437 1
	memmove((char *) h->h_mflags, (char *) mopts, sizeof(mopts));
a462 63

/*
**  CHOMPHEADER -- process and save a header line.
**
**	Called by collect, readcf, and readqf to deal with header lines.
**	This is just a wrapper for dochompheader().
**
**	Parameters:
**		line -- header as a text line.
**		pflag -- flags for chompheader() (from sendmail.h)
**		hdrp -- a pointer to the place to save the header.
**		e -- the envelope including this header.
**
**	Returns:
**		flags for this header.
**
**	Side Effects:
**		The header is saved on the header list.
**		Contents of 'line' are destroyed.
*/


unsigned long
chompheader(line, pflag, hdrp, e)
	char *line;
	int pflag;
	HDR **hdrp;
	register ENVELOPE *e;
{
	unsigned long rval;

	if (tTd(31, 6))
	{
		sm_dprintf("chompheader: ");
		xputs(sm_debug_file(), line);
		sm_dprintf("\n");
	}

	/* quote this if user (not config file) input */
	if (bitset(pflag, CHHDR_USER))
	{
		char xbuf[MAXLINE];
		char *xbp = NULL;
		int xbufs;

		xbufs = sizeof(xbuf);
		xbp = quote_internal_chars(line, xbuf, &xbufs);
		if (tTd(31, 7))
		{
			sm_dprintf("chompheader: quoted: ");
			xputs(sm_debug_file(), xbp);
			sm_dprintf("\n");
		}
		rval = dochompheader(xbp, pflag, hdrp, e);
		if (xbp != xbuf)
			sm_free(xbp);
	}
	else
		rval = dochompheader(line, pflag, hdrp, e);

	return rval;
}

d467 2
a468 2
**		field -- the name of the header field (will not be copied).
**		value -- the value of the field (will be copied).
a470 1
**		space -- add leading space?
a473 7
**
**	Notes:
**		o field and value must be in internal format, i.e.,
**		metacharacters must be "quoted", see quote_internal_chars().
**		o maybe add more flags to decide:
**		  - what to copy (field/value)
**		  - whether to convert value to an internal format
d477 1
a477 1
allocheader(field, value, flags, rp, space)
a481 1
	bool space;
d490 1
a490 1
	h = (HDR *) sm_rpool_malloc_x(rp, sizeof(*h));
d492 1
a492 15
	if (space)
	{
		size_t l;
		char *n;

		l = strlen(value);
		SM_ASSERT(l + 2 > l);
		n = sm_rpool_malloc_x(rp, l + 2);
		n[0] = ' ';
		n[1] = '\0';
		sm_strlcpy(n + 1, value, l + 1);
		h->h_value = n;
	}
	else
		h->h_value = sm_rpool_strdup_x(rp, value);
a500 1

d507 2
a508 2
**		field -- the name of the header field (will not be copied).
**		value -- the value of the field (will be copied).
a510 1
**		space -- add leading space?
a516 3
**
**	Notes: field and value must be in internal format, i.e.,
**		metacharacters must be "quoted", see quote_internal_chars().
d520 1
a520 1
addheader(field, value, flags, e, space)
a524 1
	bool space;
d538 1
a538 1
	h = allocheader(field, value, flags, e->e_rpool, space);
a541 1

d544 1
d549 2
a550 2
**		field -- the name of the header field (will be copied).
**		value -- the value of the field (will be copied).
a552 1
**		space -- add leading space?
a558 8
**
**	Notes:
**		- field and value must be in internal format, i.e.,
**		metacharacters must be "quoted", see quote_internal_chars().
**		- the header list contains headers that might not be
**		sent "out" (see putheader(): "skip"), hence there is no
**		reliable way to insert a header at an exact position
**		(except at the front or end).
d562 1
a562 1
insheader(idx, field, value, flags, e, space)
a567 1
	bool space;
d572 1
a572 1
	h = allocheader(field, value, flags, e->e_rpool, space);
a595 1

d607 1
a607 1
**		pointer to the value part (internal format).
a628 1

d656 1
a656 1
	char *s;
a657 1
	s = h;
a672 1

d737 1
a737 1
			sm_dprintf("%s:", h->h_field);
d755 2
a756 3
			expand(h->h_value, buf, sizeof(buf), e);
			if (buf[0] != '\0' &&
			    (buf[0] != ' ' || buf[1] != '\0'))
d760 1
a760 1
					       buf, sizeof(buf), e);
d824 1
a824 1
		(void) sm_snprintf(buf, sizeof(buf), "%d", e->e_hopcount);
d855 1
a855 1
		pvp = prescan(p, '\0', pvpbuf, sizeof(pvpbuf), NULL,
a976 1

d996 1
a1004 2
		size_t l;

d1006 2
a1007 2
		if (l > sizeof(mbuf) - 1)
			l = sizeof(mbuf) - 1;
d1027 1
a1027 1
		(void) sm_snprintf(hbuf, sizeof(hbuf), "%.80s", RealHostName);
a1105 1

a1133 1

d1216 1
a1216 4
	buflim = bufend = &buf[sizeof(buf) - 1];
	bp = bufhead = buf;

	/* skip over leading spaces but preserve them */
a1217 2
	{
		SM_APPEND_CHAR(*addr);
a1218 2
	}
	bufhead = bp;
d1225 2
a1533 1

d1544 1
a1544 1
**		true iff header part was written successfully
d1550 1
a1550 1
bool
d1581 1
a1581 1
			sm_dprintf("  %s:", h->h_field);
d1685 1
a1685 2
			if (!put_vanilla_header(h, p, mci))
				goto writeerr;
d1721 1
a1721 1
			expand(p, buf, sizeof(buf), e);
d1742 1
a1742 1
				(void) sm_strlcpyn(obuf, sizeof(obuf), 2,
d1744 1
a1744 2
				if (!putline(obuf, mci))
					goto writeerr;
d1759 1
a1759 2
			commaize(h, p, oldstyle, mci, e,
				 PXLF_HEADER | PXLF_STRIPMQUOTE);
d1763 1
a1763 2
			if (!put_vanilla_header(h, p, mci))
				goto writeerr;
d1780 1
a1780 2
		if (!putline("MIME-Version: 1.0", mci))
			goto writeerr;
d1783 1
a1783 1
			(void) sm_snprintf(obuf, sizeof(obuf),
d1786 1
a1786 2
			if (!putline(obuf, mci))
				goto writeerr;
d1788 2
a1789 3
		if (hvalue("Content-Transfer-Encoding", e->e_header) == NULL
		    && !putline("Content-Transfer-Encoding: 8bit", mci))
			goto writeerr;
a1791 4
	return true;

  writeerr:
	return false;
a1792 1

d1802 1
a1802 1
**		true iff header was written successfully
d1805 1
a1805 1
static bool
d1816 1
a1816 1
	putflags = PXLF_HEADER | PXLF_STRIPMQUOTE;
d1819 1
a1819 1
	(void) sm_snprintf(obuf, sizeof(obuf), "%.200s:", h->h_field);
d1836 1
a1836 2
		if (!putxline(obuf, strlen(obuf), mci, putflags))
			goto writeerr;
d1846 1
a1846 4
	return putxline(obuf, strlen(obuf), mci, putflags);

  writeerr:
	return false;
a1847 1

a1856 1
**		putflags -- flags for putxline()
d1859 1
a1859 1
**		true iff header field was written successfully
d1862 1
a1862 1
**		outputs "p" to "mci".
d1865 2
a1866 2
bool
commaize(h, p, oldstyle, mci, e, putflags)
a1871 1
	int putflags;
d1874 2
a1875 1
	int opos, omax, spaces;
d1877 1
d1887 1
a1887 1
		sm_dprintf("commaize(%s:%s)\n", h->h_field, p);
d1893 7
a1899 5
	(void) sm_snprintf(obp, SPACELEFT(obuf, obp), "%.200s:", h->h_field);
	/* opos = strlen(obp); instead of the next 3 lines? */
	opos = strlen(h->h_field) + 1;
	if (opos > 201)
		opos = 201;
a1900 26

	spaces = 0;
	while (*p != '\0' && isascii(*p) && isspace(*p))
	{
		++spaces;
		++p;
	}
	if (spaces > 0)
	{
		SM_ASSERT(sizeof(obuf) > opos  * 2);

		/*
		**  Restrict number of spaces to half the length of buffer
		**  so the header field body can be put in here too.
		**  Note: this is a hack...
		*/

		if (spaces > sizeof(obuf) / 2)
			spaces = sizeof(obuf) / 2;
		(void) sm_snprintf(obp, SPACELEFT(obuf, obp), "%*s", spaces,
				"");
		opos += spaces;
		obp += spaces;
		SM_ASSERT(obp < &obuf[MAXLINE]);
	}

d1936 1
a1936 1
				      sizeof(pvpbuf), &oldp, ExtTokenTab, false);
d2004 7
d2018 1
a2018 2
			if (!putxline(obuf, strlen(obuf), mci, putflags))
				goto writeerr;
d2020 1
a2020 1
			(void) sm_strlcpy(obp, "        ", sizeof(obuf));
d2036 1
a2036 1
	if (obp < &obuf[sizeof(obuf)])
d2039 2
a2040 5
		obuf[sizeof(obuf) - 1] = '\0';
	return putxline(obuf, strlen(obuf), mci, putflags);

  writeerr:
	return false;
a2041 1

d2069 1
a2069 1
		newhdr = (HDR *) sm_rpool_malloc_x(rpool, sizeof(*newhdr));
a2078 1

@


1.1.127.2
log
@Import sendmail.8.14.5.Beta0.tar.gz
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Id: headers.c,v 8.317 2008/08/27 20:11:55 gshapiro Exp $")
d718 1
a718 10
		{
			char *s;

			s = h->h_value;
			if (s == NULL)
				return NULL;
			while (isascii(*s) && isspace(*s))
				s++;
			return s;
		}
a1067 4
	if (tTd(92, 2))
		sm_dprintf("eatheader: e_id=%s, EF_LOGSENDER=%d, LogLevel=%d, log=%d\n",
			e->e_id, bitset(EF_LOGSENDER, e->e_flags), LogLevel,
			log);
@


1.1.127.3
log
@Import sendmail 8.14.6 via mircvs://contrib/samples/import-3rdpty
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Id: headers.c,v 8.318 2012/06/14 23:54:02 ca Exp $")
d1155 1
a1155 1
		PRT_NONNEGL(e->e_msgsize), e->e_class, e->e_nrcpts);
d1194 1
a1194 1
		  PRT_NONNEGL(e->e_msgsize), e->e_class, e->e_nrcpts);
@


1.1.127.4
log
@Import sendmail 8.14.9
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004, 2006, 2007 Proofpoint, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Id: headers.c,v 8.320 2013-11-22 20:51:55 ca Exp $")
d380 5
a390 6
		if (tTd(31, 2))
		{
			sm_dprintf("comparing header from (%s) against default (%s or %s), drop=%d\n",
				fvalue, e->e_from.q_paddr, e->e_from.q_user,
				dropfrom);
		}
a408 13

				/*
				**  If the MH hack is selected, allow to turn
				**  it off via a mailer flag to avoid problems
				**  with setups that remove the F flag from
				**  the RCPT mailer.
				*/

		    		if (bitnset(M_NOMHHACK,
					    e->e_from.q_mailer->m_flags))
				{
					h->h_flags &= ~H_CHECK;
				}
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.1.2.1
log
@MFC most of the recent sendmail updates to MirOS #8-stable
agreed bsiegert@@

This also changes the LOCALBASE stuff, links libmilter not
against LDAP, etc. but doesn't install the FreeBSD 6 confs
nor a shared libmilter in order to pass a no-files-diff:

tg@@maou:/usr/src/gnu/usr.sbin/sendmail $ sudo find / -ls | sort -k11 >~/x1
tg@@maou:/usr/src/gnu/usr.sbin/sendmail $ sudo make install
tg@@maou:/usr/src/gnu/usr.sbin/sendmail/cf/cf $ sudo make distribution
tg@@maou:/usr/src/gnu/usr.sbin/sendmail/cf/cf $ sudo find / -ls | sort -k11 | diff -u ~/x1 - | less

Note: files in /etc/mail/ are also changed, this affects the etc8.ngz set
on fresh installs and cannot(!) be automatically upgraded!
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004, 2006 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: headers.c,v 8.290 2006/02/25 02:16:52 ca Exp $")
d21 1
a21 1
static bool	put_vanilla_header __P((HDR *, char *, MCI *));
d996 1
a1004 2
		size_t l;

d1544 1
a1544 1
**		success
d1550 1
a1550 1
bool
d1685 1
a1685 2
			if (!put_vanilla_header(h, p, mci))
				goto writeerr;
d1744 1
a1744 2
				if (!putline(obuf, mci))
					goto writeerr;
d1763 1
a1763 2
			if (!put_vanilla_header(h, p, mci))
				goto writeerr;
d1780 1
a1780 2
		if (!putline("MIME-Version: 1.0", mci))
			goto writeerr;
d1786 1
a1786 2
			if (!putline(obuf, mci))
				goto writeerr;
d1788 2
a1789 3
		if (hvalue("Content-Transfer-Encoding", e->e_header) == NULL
		    && !putline("Content-Transfer-Encoding: 8bit", mci))
			goto writeerr;
a1791 4
	return true;

  writeerr:
	return false;
d1802 1
a1802 1
**		success
d1805 1
a1805 1
static bool
d1836 1
a1836 2
		if (!putxline(obuf, strlen(obuf), mci, putflags))
			goto writeerr;
d1846 1
a1846 4
	return putxline(obuf, strlen(obuf), mci, putflags);

  writeerr:
	return false;
d1859 1
a1859 1
**		success
d1865 1
a1865 1
bool
d2004 7
d2018 1
a2018 2
			if (!putxline(obuf, strlen(obuf), mci, putflags))
				goto writeerr;
d2040 1
a2040 4
	return putxline(obuf, strlen(obuf), mci, putflags);

  writeerr:
	return false;
a2041 1

@


1.1.1.2
log
@Update to Sendmail 8.13.6
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004, 2006 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: headers.c,v 8.290 2006/02/25 02:16:52 ca Exp $")
d21 1
a21 1
static bool	put_vanilla_header __P((HDR *, char *, MCI *));
d996 1
a1004 2
		size_t l;

d1544 1
a1544 1
**		success
d1550 1
a1550 1
bool
d1685 1
a1685 2
			if (!put_vanilla_header(h, p, mci))
				goto writeerr;
d1744 1
a1744 2
				if (!putline(obuf, mci))
					goto writeerr;
d1763 1
a1763 2
			if (!put_vanilla_header(h, p, mci))
				goto writeerr;
d1780 1
a1780 2
		if (!putline("MIME-Version: 1.0", mci))
			goto writeerr;
d1786 1
a1786 2
			if (!putline(obuf, mci))
				goto writeerr;
d1788 2
a1789 3
		if (hvalue("Content-Transfer-Encoding", e->e_header) == NULL
		    && !putline("Content-Transfer-Encoding: 8bit", mci))
			goto writeerr;
a1791 4
	return true;

  writeerr:
	return false;
d1802 1
a1802 1
**		success
d1805 1
a1805 1
static bool
d1836 1
a1836 2
		if (!putxline(obuf, strlen(obuf), mci, putflags))
			goto writeerr;
d1846 1
a1846 4
	return putxline(obuf, strlen(obuf), mci, putflags);

  writeerr:
	return false;
d1859 1
a1859 1
**		success
d1865 1
a1865 1
bool
d2004 7
d2018 1
a2018 2
			if (!putxline(obuf, strlen(obuf), mci, putflags))
				goto writeerr;
d2040 1
a2040 4
	return putxline(obuf, strlen(obuf), mci, putflags);

  writeerr:
	return false;
a2041 1

@


1.1.1.3
log
@Import latest Sendmail
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: headers.c,v 8.291 2006/03/24 01:01:56 ca Exp $")
d1545 1
a1545 1
**		true iff header part was written successfully
d1813 1
a1813 1
**		true iff header was written successfully
d1874 1
a1874 1
**		true iff header field was written successfully
@


1.1.1.4
log
@Import Sendmail 8.14.0 via OpenBSD
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2004, 2006, 2007 Sendmail, Inc. and its suppliers.
a14 1
#include <sm/sendmail.h>
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: headers.c,v 8.309 2007/01/08 23:53:25 ca Exp $")
d18 1
a18 1
static HDR	*allocheader __P((char *, char *, int, SM_RPOOL_T *, bool));
a45 1

d47 1
a47 1
**  DOCHOMPHEADER -- process and save a header line.
d49 1
a49 1
**	Called by chompheader.
a65 1
static unsigned long	dochompheader __P((char *, int, HDR **, ENVELOPE *));
d67 2
a68 2
static unsigned long
dochompheader(line, pflag, hdrp, e)
d72 1
a72 1
	ENVELOPE *e;
d88 7
d190 4
d211 1
a211 1
		(void) expand(fvalue, hbuf, sizeof(hbuf), e);
d359 1
a359 1
			(void) sm_snprintf(qval, sizeof(qval), "%d", k);
d361 1
d369 1
d373 1
a373 1
				       NULL, e->e_id, NULL);
d426 1
a426 1
					sizeof(mopts));
d433 1
a433 1
	h = (HDR *) sm_rpool_malloc_x(e->e_rpool, sizeof(*h));
d437 1
a437 1
	memmove((char *) h->h_mflags, (char *) mopts, sizeof(mopts));
a462 63

/*
**  CHOMPHEADER -- process and save a header line.
**
**	Called by collect, readcf, and readqf to deal with header lines.
**	This is just a wrapper for dochompheader().
**
**	Parameters:
**		line -- header as a text line.
**		pflag -- flags for chompheader() (from sendmail.h)
**		hdrp -- a pointer to the place to save the header.
**		e -- the envelope including this header.
**
**	Returns:
**		flags for this header.
**
**	Side Effects:
**		The header is saved on the header list.
**		Contents of 'line' are destroyed.
*/


unsigned long
chompheader(line, pflag, hdrp, e)
	char *line;
	int pflag;
	HDR **hdrp;
	register ENVELOPE *e;
{
	unsigned long rval;

	if (tTd(31, 6))
	{
		sm_dprintf("chompheader: ");
		xputs(sm_debug_file(), line);
		sm_dprintf("\n");
	}

	/* quote this if user (not config file) input */
	if (bitset(pflag, CHHDR_USER))
	{
		char xbuf[MAXLINE];
		char *xbp = NULL;
		int xbufs;

		xbufs = sizeof(xbuf);
		xbp = quote_internal_chars(line, xbuf, &xbufs);
		if (tTd(31, 7))
		{
			sm_dprintf("chompheader: quoted: ");
			xputs(sm_debug_file(), xbp);
			sm_dprintf("\n");
		}
		rval = dochompheader(xbp, pflag, hdrp, e);
		if (xbp != xbuf)
			sm_free(xbp);
	}
	else
		rval = dochompheader(line, pflag, hdrp, e);

	return rval;
}

d467 2
a468 2
**		field -- the name of the header field (will not be copied).
**		value -- the value of the field (will be copied).
a470 1
**		space -- add leading space?
a473 7
**
**	Notes:
**		o field and value must be in internal format, i.e.,
**		metacharacters must be "quoted", see quote_internal_chars().
**		o maybe add more flags to decide:
**		  - what to copy (field/value)
**		  - whether to convert value to an internal format
d477 1
a477 1
allocheader(field, value, flags, rp, space)
a481 1
	bool space;
d490 1
a490 1
	h = (HDR *) sm_rpool_malloc_x(rp, sizeof(*h));
d492 1
a492 15
	if (space)
	{
		size_t l;
		char *n;

		l = strlen(value);
		SM_ASSERT(l + 2 > l);
		n = sm_rpool_malloc_x(rp, l + 2);
		n[0] = ' ';
		n[1] = '\0';
		sm_strlcpy(n + 1, value, l + 1);
		h->h_value = n;
	}
	else
		h->h_value = sm_rpool_strdup_x(rp, value);
a500 1

d507 2
a508 2
**		field -- the name of the header field (will not be copied).
**		value -- the value of the field (will be copied).
a510 1
**		space -- add leading space?
a516 3
**
**	Notes: field and value must be in internal format, i.e.,
**		metacharacters must be "quoted", see quote_internal_chars().
d520 1
a520 1
addheader(field, value, flags, e, space)
a524 1
	bool space;
d538 1
a538 1
	h = allocheader(field, value, flags, e->e_rpool, space);
a541 1

d544 1
d549 2
a550 2
**		field -- the name of the header field (will be copied).
**		value -- the value of the field (will be copied).
a552 1
**		space -- add leading space?
a558 8
**
**	Notes:
**		- field and value must be in internal format, i.e.,
**		metacharacters must be "quoted", see quote_internal_chars().
**		- the header list contains headers that might not be
**		sent "out" (see putheader(): "skip"), hence there is no
**		reliable way to insert a header at an exact position
**		(except at the front or end).
d562 1
a562 1
insheader(idx, field, value, flags, e, space)
a567 1
	bool space;
d572 1
a572 1
	h = allocheader(field, value, flags, e->e_rpool, space);
a595 1

d607 1
a607 1
**		pointer to the value part (internal format).
a628 1

d656 1
a656 1
	char *s;
a657 1
	s = h;
a672 1

d737 1
a737 1
			sm_dprintf("%s:", h->h_field);
d755 1
a755 1
			expand(h->h_value, buf, sizeof(buf), e);
d760 1
a760 1
					       buf, sizeof(buf), e);
d824 1
a824 1
		(void) sm_snprintf(buf, sizeof(buf), "%d", e->e_hopcount);
d855 1
a855 1
		pvp = prescan(p, '\0', pvpbuf, sizeof(pvpbuf), NULL,
a976 1

d1007 2
a1008 2
		if (l > sizeof(mbuf) - 1)
			l = sizeof(mbuf) - 1;
d1028 1
a1028 1
		(void) sm_snprintf(hbuf, sizeof(hbuf), "%.80s", RealHostName);
a1106 1

a1134 1

d1217 1
a1217 4
	buflim = bufend = &buf[sizeof(buf) - 1];
	bp = bufhead = buf;

	/* skip over leading spaces but preserve them */
a1218 2
	{
		SM_APPEND_CHAR(*addr);
a1219 2
	}
	bufhead = bp;
d1226 2
a1534 1

d1582 1
a1582 1
			sm_dprintf("  %s:", h->h_field);
d1723 1
a1723 1
			expand(p, buf, sizeof(buf), e);
d1744 1
a1744 1
				(void) sm_strlcpyn(obuf, sizeof(obuf), 2,
d1788 1
a1788 1
			(void) sm_snprintf(obuf, sizeof(obuf),
a1803 1

d1827 1
a1827 1
	putflags = PXLF_HEADER | PXLF_STRIPMQUOTE;
d1830 1
a1830 1
	(void) sm_snprintf(obuf, sizeof(obuf), "%.200s:", h->h_field);
a1862 1

d1877 1
a1877 1
**		outputs "p" to "mci".
d1889 2
a1890 1
	int opos, omax, spaces;
d1892 1
a1892 1
	int putflags = PXLF_HEADER | PXLF_STRIPMQUOTE;
d1902 1
a1902 1
		sm_dprintf("commaize(%s:%s)\n", h->h_field, p);
d1908 7
a1914 5
	(void) sm_snprintf(obp, SPACELEFT(obuf, obp), "%.200s:", h->h_field);
	/* opos = strlen(obp); instead of the next 3 lines? */
	opos = strlen(h->h_field) + 1;
	if (opos > 201)
		opos = 201;
a1915 26

	spaces = 0;
	while (*p != '\0' && isascii(*p) && isspace(*p))
	{
		++spaces;
		++p;
	}
	if (spaces > 0)
	{
		SM_ASSERT(sizeof(obuf) > opos  * 2);

		/*
		**  Restrict number of spaces to half the length of buffer
		**  so the header field body can be put in here too.
		**  Note: this is a hack...
		*/

		if (spaces > sizeof(obuf) / 2)
			spaces = sizeof(obuf) / 2;
		(void) sm_snprintf(obp, SPACELEFT(obuf, obp), "%*s", spaces,
				"");
		opos += spaces;
		obp += spaces;
		SM_ASSERT(obp < &obuf[MAXLINE]);
	}

d1951 1
a1951 1
				      sizeof(pvpbuf), &oldp, ExtTokenTab, false);
d2029 1
a2029 1
			(void) sm_strlcpy(obp, "        ", sizeof(obuf));
d2045 1
a2045 1
	if (obp < &obuf[sizeof(obuf)])
d2048 1
a2048 1
		obuf[sizeof(obuf) - 1] = '\0';
d2082 1
a2082 1
		newhdr = (HDR *) sm_rpool_malloc_x(rpool, sizeof(*newhdr));
a2091 1

@


1.1.1.5
log
@import openbsd compress, ssh, perl, sendmail for minor bugfixes
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: headers.c,v 8.310 2007/02/07 22:44:35 ca Exp $")
d852 1
a852 2
			if (buf[0] != '\0' &&
			    (buf[0] != ' ' || buf[1] != '\0'))
@


1.1.1.6
log
@OpenBSD finally has upgraded their sendmail, too…
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: headers.c,v 8.312 2007/06/19 18:52:11 ca Exp $")
d1868 1
a1868 2
			commaize(h, p, oldstyle, mci, e,
				 PXLF_HEADER | PXLF_STRIPMQUOTE);
a1979 1
**		putflags -- flags for putxline()
d1989 1
a1989 1
commaize(h, p, oldstyle, mci, e, putflags)
a1994 1
	int putflags;
d1999 1
@


1.1.1.7
log
@Replace “$Sendmail: ” with “$Id: ” (the latter is used by upstream)
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Id: headers.c,v 8.312 2007/06/19 18:52:11 ca Exp $")
@


1.1.1.8
log
@Import OpenBSD’s sendmail 8.14.5, RCS IDs properly sedded back
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Id: headers.c,v 8.317 2008/08/27 20:11:55 gshapiro Exp $")
d718 1
a718 10
		{
			char *s;

			s = h->h_value;
			if (s == NULL)
				return NULL;
			while (isascii(*s) && isspace(*s))
				s++;
			return s;
		}
a1067 4
	if (tTd(92, 2))
		sm_dprintf("eatheader: e_id=%s, EF_LOGSENDER=%d, LogLevel=%d, log=%d\n",
			e->e_id, bitset(EF_LOGSENDER, e->e_flags), LogLevel,
			log);
@


