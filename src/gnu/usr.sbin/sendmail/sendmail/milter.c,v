head	1.8;
access;
symbols
	sendmail-8_14_9:1.1.127.5
	sendmail-8_14_7:1.1.127.4
	sendmail-8_14_6:1.1.127.3
	sendmail-8_14_5-ERRATA-1:1.1.127.2
	mbsd-20101220_mergebase:1.5
	sendmail-8_14_5:1.1.127.2
	cvs-201107021500:1.1.1.8
	cvs-20101220:1.1.1.7
	mbsd-20101220:1.5.0.2
	cvs-201012191730:1.1.1.6
	sendmail-8_14_5_Beta0:1.1.127.2
	sendmail-8_14_3:1.1.127.1
	sendmail:1.1.127
	cvs-200812170000:1.1.1.6
	cvs-200805071200:1.1.1.6
	MIRBSD_10:1.2.0.2
	MIRBSD_10_BASE:1.2
	cvs-200803022030:1.1.1.5
	cvs-200707152000:1.1.1.5
	cvs-200704292000:1.1.1.5
	cvs-200702051700:1.1.1.4
	cvs-200609121900:1.1.1.3
	MIRBSD_9_BASE:1.1.1.3
	cvs-200606151800:1.1.1.3
	cvs-200603231300:1.1.1.3
	MIRBSD_8:1.1.1.2.0.2
	MIRBSD_8_BASE:1.1.1.2
	cvs-200507211800:1.1.1.2
	cvs-200504262050:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.06.09.15.17.51;	author tg;	state Exp;
branches;
next	1.7;
commitid	1005395CFC65E5646F1;

1.7
date	2013.08.06.20.37.11;	author tg;	state Exp;
branches;
next	1.6;
commitid	10052015E562892E658;

1.6
date	2012.12.31.21.02.47;	author tg;	state Exp;
branches;
next	1.5;
commitid	10050E1FD6765F66D0C;

1.5
date	2010.12.19.17.18.27;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004D0E3E2D1286B3DF;

1.4
date	2009.11.18.08.53.39;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004B03B61970AF200B;

1.3
date	2008.05.07.13.15.27;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004821AB7510EE48FB;

1.2
date	2008.03.02.21.41.16;	author tg;	state Exp;
branches
	1.2.2.1;
next	1.1;
commitid	10047CB1EE51190ECAF;

1.1
date	2005.02.05.17.24.29;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.127.1;
next	;

1.2.2.1
date	2008.05.17.19.12.15;	author tg;	state Exp;
branches;
next	;
commitid	100482F2DC168C89AEA;

1.1.1.1
date	2005.02.05.17.24.29;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.26.20.58.41;	author tg;	state Exp;
branches
	1.1.1.2.2.1;
next	1.1.1.3;

1.1.1.3
date	2006.03.23.13.10.00;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	10044229DEA33D36552;

1.1.1.4
date	2007.02.05.17.06.35;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	10045C763C551AABAF7;

1.1.1.5
date	2007.04.29.20.07.12;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	1004634FAED5BC54DF0;

1.1.1.6
date	2008.05.07.12.31.51;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	1004821A13C1FC036E1;

1.1.1.7
date	2011.07.02.15.00.52;	author tg;	state Exp;
branches;
next	1.1.1.8;
commitid	1004E0F31C5496AB95F;

1.1.1.8
date	2011.07.02.15.17.43;	author tg;	state Exp;
branches;
next	;
commitid	1004E0F36A10B5CA95B;

1.1.1.2.2.1
date	2006.03.30.19.28.02;	author tg;	state Exp;
branches;
next	;
commitid	100442C309C7183FA09;

1.1.127.1
date	2010.12.19.14.45.45;	author tg;	state Exp;
branches;
next	1.1.127.2;
commitid	1004D0E1A94384778FD;

1.1.127.2
date	2010.12.19.14.56.26;	author tg;	state Exp;
branches;
next	1.1.127.3;
commitid	1004D0E1D294DE25888;

1.1.127.3
date	2012.12.31.20.38.22;	author tg;	state Exp;
branches;
next	1.1.127.4;
commitid	10050E1F79A4182E8EC;

1.1.127.4
date	2013.08.06.20.26.20;	author tg;	state Exp;
branches;
next	1.1.127.5;
commitid	10052015BDF0FDDCF84;

1.1.127.5
date	2014.06.09.14.29.17;	author tg;	state Exp;
branches;
next	;
commitid	1005395C4CC1A6DB9EE;


desc
@@


1.8
log
@merge
@
text
@/*
 * Copyright (c) 1999-2009, 2012, 2013 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>

SM_RCSID("$MirOS: src/gnu/usr.sbin/sendmail/sendmail/milter.c,v 1.7 2013/08/06 20:37:11 tg Exp $")
SM_RCSID("@@(#)$Id: milter.c,v 8.281 2013-11-22 20:51:56 ca Exp $")

#if MILTER
# include <sm/sendmail.h>
# include <libmilter/mfapi.h>
# include <libmilter/mfdef.h>

# include <errno.h>
# include <sm/time.h>
# include <sys/uio.h>

# if NETINET || NETINET6
#  include <arpa/inet.h>
#  if MILTER_NO_NAGLE
#   include <netinet/tcp.h>
#  endif /* MILTER_NO_NAGLE */
# endif /* NETINET || NETINET6 */

# include <sm/fdset.h>

static void	milter_connect_timeout __P((int));
static void	milter_error __P((struct milter *, ENVELOPE *));
static int	milter_open __P((struct milter *, bool, ENVELOPE *));
static void	milter_parse_timeouts __P((char *, struct milter *));
static char	*milter_sysread __P((struct milter *, char *, ssize_t, time_t,
			ENVELOPE *, const char *));
static char	*milter_read __P((struct milter *, char *, ssize_t *, time_t,
			ENVELOPE *, const char *));
static char	*milter_write __P((struct milter *, int, char *, ssize_t,
			time_t, ENVELOPE *, const char *));
static char	*milter_send_command __P((struct milter *, int, void *,
			ssize_t, ENVELOPE *, char *, const char *));
static char	*milter_command __P((int, void *, ssize_t, int,
			ENVELOPE *, char *, const char *, bool));
static char	*milter_body __P((struct milter *, ENVELOPE *, char *));
static int	milter_reopen_df __P((ENVELOPE *));
static int	milter_reset_df __P((ENVELOPE *));
static void	milter_quit_filter __P((struct milter *, ENVELOPE *));
static void	milter_abort_filter __P((struct milter *, ENVELOPE *));
static void	milter_send_macros __P((struct milter *, char **, int,
			ENVELOPE *));
static int	milter_negotiate __P((struct milter *, ENVELOPE *,
			milters_T *));
static void	milter_per_connection_check __P((ENVELOPE *));
static char	*milter_headers __P((struct milter *, ENVELOPE *, char *));
static void	milter_addheader __P((struct milter *, char *, ssize_t,
			ENVELOPE *));
static void	milter_insheader __P((struct milter *, char *, ssize_t,
			ENVELOPE *));
static void	milter_changeheader __P((struct milter *, char *, ssize_t,
			ENVELOPE *));
static void	milter_chgfrom __P((char *, ssize_t, ENVELOPE *));
static void	milter_addrcpt __P((char *, ssize_t, ENVELOPE *));
static void	milter_addrcpt_par __P((char *, ssize_t, ENVELOPE *));
static void	milter_delrcpt __P((char *, ssize_t, ENVELOPE *));
static int	milter_replbody __P((char *, ssize_t, bool, ENVELOPE *));
static int	milter_set_macros __P((char *, char **, char *, int));


/* milter states */
# define SMFS_CLOSED		'C'	/* closed for all further actions */
# define SMFS_OPEN		'O'	/* connected to remote milter filter */
# define SMFS_INMSG		'M'	/* currently servicing a message */
# define SMFS_DONE		'D'	/* done with current message */
# define SMFS_CLOSABLE		'Q'	/* done with current connection */
# define SMFS_ERROR		'E'	/* error state */
# define SMFS_READY		'R'	/* ready for action */
# define SMFS_SKIP		'S'	/* skip body */

/*
**  MilterMacros contains the milter macros for each milter and each stage.
**  indices are (in order): stages, milter-index, macro
**  milter-index == 0: "global" macros (not for a specific milter).
*/

static char *MilterMacros[SMFIM_LAST + 1][MAXFILTERS + 1][MAXFILTERMACROS + 1];
static size_t MilterMaxDataSize = MILTER_MAX_DATA_SIZE;

# define MILTER_CHECK_DONE_MSG() \
	if (*state == SMFIR_REPLYCODE || \
	    *state == SMFIR_REJECT || \
	    *state == SMFIR_DISCARD || \
	    *state == SMFIR_TEMPFAIL) \
	{ \
		/* Abort the filters to let them know we are done with msg */ \
		milter_abort(e); \
	}

/* set state in case of an error */
# define MILTER_SET_STATE	\
	if (bitnset(SMF_TEMPFAIL, m->mf_flags)) \
		*state = SMFIR_TEMPFAIL; \
	else if (bitnset(SMF_TEMPDROP, m->mf_flags)) \
		*state = SMFIR_SHUTDOWN; \
	else if (bitnset(SMF_REJECT, m->mf_flags)) \
		*state = SMFIR_REJECT

/* flow through code maybe using continue; don't wrap in do {} while */
# define MILTER_CHECK_ERROR(initial, action) \
	if (!initial && tTd(71, 100)) \
	{ \
		if (e->e_quarmsg == NULL) \
		{ \
			e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, \
							 "filter failure"); \
			macdefine(&e->e_macro, A_PERM, macid("{quarantine}"), \
				  e->e_quarmsg); \
		} \
	} \
	else if (tTd(71, 101)) \
	{ \
		if (e->e_quarmsg == NULL) \
		{ \
			e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, \
							 "filter failure"); \
			macdefine(&e->e_macro, A_PERM, macid("{quarantine}"), \
				  e->e_quarmsg); \
		} \
	} \
	else MILTER_SET_STATE;	\
	else \
		action;

# define MILTER_CHECK_REPLYCODE(default) \
	if (response == NULL || \
	    strlen(response) + 1 != (size_t) rlen || \
	    rlen < 3 || \
	    (response[0] != '4' && response[0] != '5') || \
	    !isascii(response[1]) || !isdigit(response[1]) || \
	    !isascii(response[2]) || !isdigit(response[2])) \
	{ \
		if (response != NULL) \
			sm_free(response); /* XXX */ \
		response = newstr(default); \
	} \
	else \
	{ \
		char *ptr = response; \
 \
		/* Check for unprotected %'s in the string */ \
		while (*ptr != '\0') \
		{ \
			if (*ptr == '%' && *++ptr != '%') \
			{ \
				sm_free(response); /* XXX */ \
				response = newstr(default); \
				break; \
			} \
			ptr++; \
		} \
	}

# define MILTER_DF_ERROR(msg) \
{ \
	int save_errno = errno; \
 \
	if (tTd(64, 5)) \
	{ \
		sm_dprintf(msg, dfname, sm_errstring(save_errno)); \
		sm_dprintf("\n"); \
	} \
	if (MilterLogLevel > 0) \
		sm_syslog(LOG_ERR, e->e_id, msg, dfname, sm_errstring(save_errno)); \
	if (SuperSafe == SAFE_REALLY) \
	{ \
		if (e->e_dfp != NULL) \
		{ \
			(void) sm_io_close(e->e_dfp, SM_TIME_DEFAULT); \
			e->e_dfp = NULL; \
		} \
		e->e_flags &= ~EF_HAS_DF; \
	} \
	errno = save_errno; \
}

/*
**  MILTER_TIMEOUT -- make sure socket is ready in time
**
**	Parameters:
**		routine -- routine name for debug/logging
**		secs -- number of seconds in timeout
**		write -- waiting to read or write?
**		started -- whether this is part of a previous sequence
**
**	Assumes 'm' is a milter structure for the current socket.
*/

# define MILTER_TIMEOUT(routine, secs, write, started, function) \
{ \
	int ret; \
	int save_errno; \
	fd_set fds; \
	struct timeval tv; \
 \
	if (SM_FD_SETSIZE > 0 && m->mf_sock >= SM_FD_SETSIZE) \
	{ \
		if (tTd(64, 5)) \
			sm_dprintf("milter_%s(%s): socket %d is larger than FD_SETSIZE %d\n", \
				   (routine), m->mf_name, m->mf_sock, \
				   SM_FD_SETSIZE); \
		if (MilterLogLevel > 0) \
			sm_syslog(LOG_ERR, e->e_id, \
				  "Milter (%s): socket(%s) %d is larger than FD_SETSIZE %d", \
				  m->mf_name, (routine), m->mf_sock, \
				  SM_FD_SETSIZE); \
		milter_error(m, e); \
		return NULL; \
	} \
 \
	do \
	{ \
		FD_ZERO(&fds); \
		SM_FD_SET(m->mf_sock, &fds); \
		tv.tv_sec = (secs); \
		tv.tv_usec = 0; \
		ret = select(m->mf_sock + 1, \
			     (write) ? NULL : &fds, \
			     (write) ? &fds : NULL, \
			     NULL, &tv); \
	} while (ret < 0 && errno == EINTR); \
 \
	switch (ret) \
	{ \
	  case 0: \
		if (tTd(64, 5)) \
			sm_dprintf("milter_%s(%s): timeout, where=%s\n", \
				(routine), m->mf_name, (function)); \
		if (MilterLogLevel > 0) \
			sm_syslog(LOG_ERR, e->e_id, \
				  "Milter (%s): timeout %s data %s, where=%s", \
				  m->mf_name, \
				  started ? "during" : "before", \
				  (routine), (function)); \
		milter_error(m, e); \
		return NULL; \
 \
	  case -1: \
		save_errno = errno; \
		if (tTd(64, 5)) \
			sm_dprintf("milter_%s(%s): select: %s\n", (routine), \
				   m->mf_name, sm_errstring(save_errno)); \
		if (MilterLogLevel > 0) \
		{ \
			sm_syslog(LOG_ERR, e->e_id, \
				  "Milter (%s): select(%s): %s", \
				  m->mf_name, (routine), \
				  sm_errstring(save_errno)); \
		} \
		milter_error(m, e); \
		return NULL; \
 \
	  default: \
		if (SM_FD_ISSET(m->mf_sock, &fds)) \
			break; \
		if (tTd(64, 5)) \
			sm_dprintf("milter_%s(%s): socket not ready\n", \
				(routine), m->mf_name); \
		if (MilterLogLevel > 0) \
		{ \
			sm_syslog(LOG_ERR, e->e_id, \
				  "Milter (%s): socket(%s) not ready", \
				  m->mf_name, (routine)); \
		} \
		milter_error(m, e); \
		return NULL; \
	} \
}

/*
**  Low level functions
*/

/*
**  MILTER_READ -- read from a remote milter filter
**
**	Parameters:
**		m -- milter to read from.
**		cmd -- return param for command read.
**		rlen -- return length of response string.
**		to -- timeout in seconds.
**		e -- current envelope.
**
**	Returns:
**		response string (may be NULL)
*/

static char *
milter_sysread(m, buf, sz, to, e, where)
	struct milter *m;
	char *buf;
	ssize_t sz;
	time_t to;
	ENVELOPE *e;
	const char *where;
{
	time_t readstart = 0;
	ssize_t len, curl;
	bool started = false;

	curl = 0;

	if (to > 0)
		readstart = curtime();

	for (;;)
	{
		if (to > 0)
		{
			time_t now;

			now = curtime();
			if (now - readstart >= to)
			{
				if (tTd(64, 5))
					sm_dprintf("milter_sys_read (%s): timeout %s data read in %s",
						  m->mf_name,
						  started ? "during" : "before",
						  where);
				if (MilterLogLevel > 0)
					sm_syslog(LOG_ERR, e->e_id,
						  "Milter (%s): timeout %s data read in %s",
						  m->mf_name,
						  started ? "during" : "before",
						  where);
				milter_error(m, e);
				return NULL;
			}
			to -= now - readstart;
			readstart = now;
			MILTER_TIMEOUT("read", to, false, started, where);
		}

		len = read(m->mf_sock, buf + curl, sz - curl);

		if (len < 0)
		{
			int save_errno = errno;

			if (tTd(64, 5))
				sm_dprintf("milter_sys_read(%s): read returned %ld: %s\n",
					m->mf_name, (long) len,
					sm_errstring(save_errno));
			if (MilterLogLevel > 0)
				sm_syslog(LOG_ERR, e->e_id,
					  "Milter (%s): read returned %ld: %s",
					  m->mf_name, (long) len,
					  sm_errstring(save_errno));
			milter_error(m, e);
			return NULL;
		}

		started = true;
		curl += len;
		if (len == 0 || curl >= sz)
			break;

	}

	if (curl != sz)
	{
		if (tTd(64, 5))
			sm_dprintf("milter_sys_read(%s): cmd read returned %ld, expecting %ld\n",
				m->mf_name, (long) curl, (long) sz);
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "milter_sys_read(%s): cmd read returned %ld, expecting %ld",
				  m->mf_name, (long) curl, (long) sz);
		milter_error(m, e);
		return NULL;
	}
	return buf;
}

static char *
milter_read(m, cmd, rlen, to, e, where)
	struct milter *m;
	char *cmd;
	ssize_t *rlen;
	time_t to;
	ENVELOPE *e;
	const char *where;
{
	time_t readstart = 0;
	ssize_t expl;
	mi_int32 i;
# if MILTER_NO_NAGLE && defined(TCP_CORK)
	int cork = 0;
# endif /* MILTER_NO_NAGLE && defined(TCP_CORK) */
	char *buf;
	char data[MILTER_LEN_BYTES + 1];

	if (m->mf_sock < 0)
	{
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "milter_read(%s): socket closed, where=%s",
				  m->mf_name, where);
		milter_error(m, e);
		return NULL;
	}

	*rlen = 0;
	*cmd = '\0';

	if (to > 0)
		readstart = curtime();

# if MILTER_NO_NAGLE && defined(TCP_CORK)
	setsockopt(m->mf_sock, IPPROTO_TCP, TCP_CORK, (char *)&cork,
		   sizeof(cork));
# endif /* MILTER_NO_NAGLE && defined(TCP_CORK) */

	if (milter_sysread(m, data, sizeof(data), to, e, where) == NULL)
		return NULL;

# if MILTER_NO_NAGLE && defined(TCP_CORK)
	cork = 1;
	setsockopt(m->mf_sock, IPPROTO_TCP, TCP_CORK, (char *)&cork,
		   sizeof(cork));
# endif /* MILTER_NO_NAGLE && defined(TCP_CORK) */

	/* reset timeout */
	if (to > 0)
	{
		time_t now;

		now = curtime();
		if (now - readstart >= to)
		{
			if (tTd(64, 5))
				sm_dprintf("milter_read(%s): timeout before data read, where=%s\n",
					m->mf_name, where);
			if (MilterLogLevel > 0)
				sm_syslog(LOG_ERR, e->e_id,
					  "Milter read(%s): timeout before data read, where=%s",
					  m->mf_name, where);
			milter_error(m, e);
			return NULL;
		}
		to -= now - readstart;
	}

	*cmd = data[MILTER_LEN_BYTES];
	data[MILTER_LEN_BYTES] = '\0';
	(void) memcpy(&i, data, MILTER_LEN_BYTES);
	expl = ntohl(i) - 1;

	if (tTd(64, 25))
		sm_dprintf("milter_read(%s): expecting %ld bytes\n",
			m->mf_name, (long) expl);

	if (expl < 0)
	{
		if (tTd(64, 5))
			sm_dprintf("milter_read(%s): read size %ld out of range, where=%s\n",
				m->mf_name, (long) expl, where);
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "milter_read(%s): read size %ld out of range, where=%s",
				  m->mf_name, (long) expl, where);
		milter_error(m, e);
		return NULL;
	}

	if (expl == 0)
		return NULL;

	buf = (char *) xalloc(expl);

	if (milter_sysread(m, buf, expl, to, e, where) == NULL)
	{
		sm_free(buf); /* XXX */
		return NULL;
	}

	if (tTd(64, 50))
		sm_dprintf("milter_read(%s): Returning %*s\n",
			m->mf_name, (int) expl, buf);
	*rlen = expl;
	return buf;
}

/*
**  MILTER_WRITE -- write to a remote milter filter
**
**	Parameters:
**		m -- milter to read from.
**		cmd -- command to send.
**		buf -- optional command data.
**		len -- length of buf.
**		to -- timeout in seconds.
**		e -- current envelope.
**
**	Returns:
**		buf if successful, NULL otherwise
**		Not actually used anywhere but function prototype
**			must match milter_read()
*/

static char *
milter_write(m, cmd, buf, len, to, e, where)
	struct milter *m;
	int cmd;
	char *buf;
	ssize_t len;
	time_t to;
	ENVELOPE *e;
	const char *where;
{
	ssize_t sl, i;
	int num_vectors;
	mi_int32 nl;
	char command = (char) cmd;
	char data[MILTER_LEN_BYTES + 1];
	bool started = false;
	struct iovec vector[2];

	/*
	**  At most two buffers will be written, though
	**  only one may actually be used (see num_vectors).
	**  The first is the size/command and the second is the command data.
	*/

	if (len < 0 || len > MilterMaxDataSize)
	{
		if (tTd(64, 5))
		{
			sm_dprintf("milter_write(%s): length %ld out of range, cmd=%c\n",
				m->mf_name, (long) len, command);
			sm_dprintf("milter_write(%s): buf=%s\n",
				m->mf_name, str2prt(buf));
		}
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "milter_write(%s): length %ld out of range, cmd=%c",
				  m->mf_name, (long) len, command);
		milter_error(m, e);
		return NULL;
	}
	if (m->mf_sock < 0)
	{
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "milter_write(%s): socket closed",
				  m->mf_name);
		milter_error(m, e);
		return NULL;
	}

	if (tTd(64, 20))
		sm_dprintf("milter_write(%s): cmd %c, len %ld\n",
			   m->mf_name, command, (long) len);

	nl = htonl(len + 1);	/* add 1 for the command char */
	(void) memcpy(data, (char *) &nl, MILTER_LEN_BYTES);
	data[MILTER_LEN_BYTES] = command;
	sl = MILTER_LEN_BYTES + 1;

	/* set up the vector for the size / command */
	vector[0].iov_base = (void *) data;
	vector[0].iov_len  = sl;

	/*
	**  Determine if there is command data.  If so, there will be two
	**  vectors.  If not, there will be only one.  The vectors are set
	**  up here and 'num_vectors' and 'sl' are set appropriately.
	*/

	/* NOTE:  len<0 has already been checked for.  Pedantic */
	if (len <= 0 || buf == NULL)
	{
		/* There is no command data -- only a size / command data */
		num_vectors = 1;
	}
	else
	{
		/*
		**  There is both size / command and command data.
		**  Set up the vector for the command data.
		*/

		num_vectors = 2;
		sl += len;
		vector[1].iov_base = (void *) buf;
		vector[1].iov_len  = len;

		if (tTd(64, 50))
			sm_dprintf("milter_write(%s): Sending %*s\n",
				   m->mf_name, (int) len, buf);
	}

	if (to > 0)
		MILTER_TIMEOUT("write", to, true, started, where);

	/* write the vector(s) */
	i = writev(m->mf_sock, vector, num_vectors);
	if (i != sl)
	{
		int save_errno = errno;

		if (tTd(64, 5))
			sm_dprintf("milter_write(%s): write(%c) returned %ld, expected %ld: %s\n",
				   m->mf_name, command, (long) i, (long) sl,
				   sm_errstring(save_errno));
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "Milter (%s): write(%c) returned %ld, expected %ld: %s",
				  m->mf_name, command, (long) i, (long) sl,
				  sm_errstring(save_errno));
		milter_error(m, e);
		return NULL;
	}
	return buf;
}

/*
**  Utility functions
*/

/*
**  MILTER_OPEN -- connect to remote milter filter
**
**	Parameters:
**		m -- milter to connect to.
**		parseonly -- parse but don't connect.
**		e -- current envelope.
**
**	Returns:
**		connected socket if successful && !parseonly,
**		0 upon parse success if parseonly,
**		-1 otherwise.
*/

static jmp_buf	MilterConnectTimeout;

static int
milter_open(m, parseonly, e)
	struct milter *m;
	bool parseonly;
	ENVELOPE *e;
{
	int sock = 0;
	SOCKADDR_LEN_T addrlen = 0;
	int addrno = 0;
	int save_errno;
	char *p;
	char *colon;
	char *at;
	struct hostent *hp = NULL;
	SOCKADDR addr;

	if (m->mf_conn == NULL || m->mf_conn[0] == '\0')
	{
		if (tTd(64, 5))
			sm_dprintf("X%s: empty or missing socket information\n",
				   m->mf_name);
		if (parseonly)
			syserr("X%s: empty or missing socket information",
			       m->mf_name);
		else if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "Milter (%s): empty or missing socket information",
				  m->mf_name);
		milter_error(m, e);
		return -1;
	}

	/* protocol:filename or protocol:port@@host */
	memset(&addr, '\0', sizeof(addr));
	p = m->mf_conn;
	colon = strchr(p, ':');
	if (colon != NULL)
	{
		*colon = '\0';

		if (*p == '\0')
		{
# if NETUNIX
			/* default to AF_UNIX */
			addr.sa.sa_family = AF_UNIX;
# else /* NETUNIX */
#  if NETINET
			/* default to AF_INET */
			addr.sa.sa_family = AF_INET;
#  else /* NETINET */
#   if NETINET6
			/* default to AF_INET6 */
			addr.sa.sa_family = AF_INET6;
#   else /* NETINET6 */
			/* no protocols available */
			if (MilterLogLevel > 0)
				sm_syslog(LOG_ERR, e->e_id,
					  "Milter (%s): no valid socket protocols available",
					  m->mf_name);
			milter_error(m, e);
			return -1;
#   endif /* NETINET6 */
#  endif /* NETINET */
# endif /* NETUNIX */
		}
# if NETUNIX
		else if (sm_strcasecmp(p, "unix") == 0 ||
			 sm_strcasecmp(p, "local") == 0)
			addr.sa.sa_family = AF_UNIX;
# endif /* NETUNIX */
# if NETINET
		else if (sm_strcasecmp(p, "inet") == 0)
			addr.sa.sa_family = AF_INET;
# endif /* NETINET */
# if NETINET6
		else if (sm_strcasecmp(p, "inet6") == 0)
			addr.sa.sa_family = AF_INET6;
# endif /* NETINET6 */
		else
		{
# ifdef EPROTONOSUPPORT
			errno = EPROTONOSUPPORT;
# else /* EPROTONOSUPPORT */
			errno = EINVAL;
# endif /* EPROTONOSUPPORT */
			if (tTd(64, 5))
				sm_dprintf("X%s: unknown socket type %s\n",
					m->mf_name, p);
			if (parseonly)
				syserr("X%s: unknown socket type %s",
				       m->mf_name, p);
			else if (MilterLogLevel > 0)
				sm_syslog(LOG_ERR, e->e_id,
					  "Milter (%s): unknown socket type %s",
					  m->mf_name, p);
			milter_error(m, e);
			return -1;
		}
		*colon++ = ':';
	}
	else
	{
		/* default to AF_UNIX */
		addr.sa.sa_family = AF_UNIX;
		colon = p;
	}

# if NETUNIX
	if (addr.sa.sa_family == AF_UNIX)
	{
		long sff = SFF_SAFEDIRPATH|SFF_OPENASROOT|SFF_NOLINK|SFF_EXECOK;

		at = colon;
		if (strlen(colon) >= sizeof(addr.sunix.sun_path))
		{
			if (tTd(64, 5))
				sm_dprintf("X%s: local socket name %s too long\n",
					m->mf_name, colon);
			errno = EINVAL;
			if (parseonly)
				syserr("X%s: local socket name %s too long",
				       m->mf_name, colon);
			else if (MilterLogLevel > 0)
				sm_syslog(LOG_ERR, e->e_id,
					  "Milter (%s): local socket name %s too long",
					  m->mf_name, colon);
			milter_error(m, e);
			return -1;
		}
		errno = safefile(colon, RunAsUid, RunAsGid, RunAsUserName, sff,
				 S_IRUSR|S_IWUSR, NULL);

		/* if just parsing .cf file, socket doesn't need to exist */
		if (parseonly && errno == ENOENT)
		{
			if (OpMode == MD_DAEMON ||
			    OpMode == MD_FGDAEMON)
				(void) sm_io_fprintf(smioerr, SM_TIME_DEFAULT,
						     "WARNING: X%s: local socket name %s missing\n",
						     m->mf_name, colon);
		}
		else if (errno != 0)
		{
			/* if not safe, don't create */
			save_errno = errno;
			if (tTd(64, 5))
				sm_dprintf("X%s: local socket name %s unsafe\n",
					m->mf_name, colon);
			errno = save_errno;
			if (parseonly)
			{
				if (OpMode == MD_DAEMON ||
				    OpMode == MD_FGDAEMON ||
				    OpMode == MD_SMTP)
					syserr("X%s: local socket name %s unsafe",
					       m->mf_name, colon);
			}
			else if (MilterLogLevel > 0)
				sm_syslog(LOG_ERR, e->e_id,
					  "Milter (%s): local socket name %s unsafe",
					  m->mf_name, colon);
			milter_error(m, e);
			return -1;
		}

		(void) sm_strlcpy(addr.sunix.sun_path, colon,
			       sizeof(addr.sunix.sun_path));
		addrlen = sizeof(struct sockaddr_un);
	}
	else
# endif /* NETUNIX */
# if NETINET || NETINET6
	if (false
#  if NETINET
		 || addr.sa.sa_family == AF_INET
#  endif /* NETINET */
#  if NETINET6
		 || addr.sa.sa_family == AF_INET6
#  endif /* NETINET6 */
		 )
	{
		unsigned short port;

		/* Parse port@@host */
		at = strchr(colon, '@@');
		if (at == NULL)
		{
			if (tTd(64, 5))
				sm_dprintf("X%s: bad address %s (expected port@@host)\n",
					m->mf_name, colon);
			if (parseonly)
				syserr("X%s: bad address %s (expected port@@host)",
				       m->mf_name, colon);
			else if (MilterLogLevel > 0)
				sm_syslog(LOG_ERR, e->e_id,
					  "Milter (%s): bad address %s (expected port@@host)",
					  m->mf_name, colon);
			milter_error(m, e);
			return -1;
		}
		*at = '\0';
		if (isascii(*colon) && isdigit(*colon))
			port = htons((unsigned short) atoi(colon));
		else
		{
#  ifdef NO_GETSERVBYNAME
			if (tTd(64, 5))
				sm_dprintf("X%s: invalid port number %s\n",
					m->mf_name, colon);
			if (parseonly)
				syserr("X%s: invalid port number %s",
				       m->mf_name, colon);
			else if (MilterLogLevel > 0)
				sm_syslog(LOG_ERR, e->e_id,
					  "Milter (%s): invalid port number %s",
					  m->mf_name, colon);
			milter_error(m, e);
			return -1;
#  else /* NO_GETSERVBYNAME */
			struct servent *sp;

			sp = getservbyname(colon, "tcp");
			if (sp == NULL)
			{
				save_errno = errno;
				if (tTd(64, 5))
					sm_dprintf("X%s: unknown port name %s\n",
						m->mf_name, colon);
				errno = save_errno;
				if (parseonly)
					syserr("X%s: unknown port name %s",
					       m->mf_name, colon);
				else if (MilterLogLevel > 0)
					sm_syslog(LOG_ERR, e->e_id,
						  "Milter (%s): unknown port name %s",
						  m->mf_name, colon);
				milter_error(m, e);
				return -1;
			}
			port = sp->s_port;
#  endif /* NO_GETSERVBYNAME */
		}
		*at++ = '@@';
		if (*at == '[')
		{
			char *end;

			end = strchr(at, ']');
			if (end != NULL)
			{
				bool found = false;
#  if NETINET
				unsigned long hid = INADDR_NONE;
#  endif /* NETINET */
#  if NETINET6
				struct sockaddr_in6 hid6;
#  endif /* NETINET6 */

				*end = '\0';
#  if NETINET
				if (addr.sa.sa_family == AF_INET &&
				    (hid = inet_addr(&at[1])) != INADDR_NONE)
				{
					addr.sin.sin_addr.s_addr = hid;
					addr.sin.sin_port = port;
					found = true;
				}
#  endif /* NETINET */
#  if NETINET6
				(void) memset(&hid6, '\0', sizeof(hid6));
				if (addr.sa.sa_family == AF_INET6 &&
				    anynet_pton(AF_INET6, &at[1],
						&hid6.sin6_addr) == 1)
				{
					addr.sin6.sin6_addr = hid6.sin6_addr;
					addr.sin6.sin6_port = port;
					found = true;
				}
#  endif /* NETINET6 */
				*end = ']';
				if (!found)
				{
					if (tTd(64, 5))
						sm_dprintf("X%s: Invalid numeric domain spec \"%s\"\n",
							m->mf_name, at);
					if (parseonly)
						syserr("X%s: Invalid numeric domain spec \"%s\"",
						       m->mf_name, at);
					else if (MilterLogLevel > 0)
						sm_syslog(LOG_ERR, e->e_id,
							  "Milter (%s): Invalid numeric domain spec \"%s\"",
							  m->mf_name, at);
					milter_error(m, e);
					return -1;
				}
			}
			else
			{
				if (tTd(64, 5))
					sm_dprintf("X%s: Invalid numeric domain spec \"%s\"\n",
						m->mf_name, at);
				if (parseonly)
					syserr("X%s: Invalid numeric domain spec \"%s\"",
					       m->mf_name, at);
				else if (MilterLogLevel > 0)
					sm_syslog(LOG_ERR, e->e_id,
						  "Milter (%s): Invalid numeric domain spec \"%s\"",
						  m->mf_name, at);
				milter_error(m, e);
				return -1;
			}
		}
		else
		{
			hp = sm_gethostbyname(at, addr.sa.sa_family);
			if (hp == NULL)
			{
				save_errno = errno;
				if (tTd(64, 5))
					sm_dprintf("X%s: Unknown host name %s\n",
						   m->mf_name, at);
				errno = save_errno;
				if (parseonly)
					syserr("X%s: Unknown host name %s",
					       m->mf_name, at);
				else if (MilterLogLevel > 0)
					sm_syslog(LOG_ERR, e->e_id,
						  "Milter (%s): Unknown host name %s",
						  m->mf_name, at);
				milter_error(m, e);
				return -1;
			}
			addr.sa.sa_family = hp->h_addrtype;
			switch (hp->h_addrtype)
			{
#  if NETINET
			  case AF_INET:
				memmove(&addr.sin.sin_addr,
					hp->h_addr, INADDRSZ);
				addr.sin.sin_port = port;
				addrlen = sizeof(struct sockaddr_in);
				addrno = 1;
				break;
#  endif /* NETINET */

#  if NETINET6
			  case AF_INET6:
				memmove(&addr.sin6.sin6_addr,
					hp->h_addr, IN6ADDRSZ);
				addr.sin6.sin6_port = port;
				addrlen = sizeof(struct sockaddr_in6);
				addrno = 1;
				break;
#  endif /* NETINET6 */

			  default:
				if (tTd(64, 5))
					sm_dprintf("X%s: Unknown protocol for %s (%d)\n",
						   m->mf_name, at,
						   hp->h_addrtype);
				if (parseonly)
					syserr("X%s: Unknown protocol for %s (%d)",
					       m->mf_name, at, hp->h_addrtype);
				else if (MilterLogLevel > 0)
					sm_syslog(LOG_ERR, e->e_id,
						  "Milter (%s): Unknown protocol for %s (%d)",
						  m->mf_name, at,
						  hp->h_addrtype);
				milter_error(m, e);
#  if NETINET6
				freehostent(hp);
#  endif /* NETINET6 */
				return -1;
			}
		}
	}
	else
# endif /* NETINET || NETINET6 */
	{
		if (tTd(64, 5))
			sm_dprintf("X%s: unknown socket protocol\n",
				   m->mf_name);
		if (parseonly)
			syserr("X%s: unknown socket protocol", m->mf_name);
		else if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "Milter (%s): unknown socket protocol",
				  m->mf_name);
		milter_error(m, e);
		return -1;
	}

	/* just parsing through? */
	if (parseonly)
	{
		m->mf_state = SMFS_READY;
# if NETINET6
		if (hp != NULL)
			freehostent(hp);
# endif /* NETINET6 */
		return 0;
	}

	/* sanity check */
	if (m->mf_state != SMFS_READY &&
	    m->mf_state != SMFS_CLOSED)
	{
		/* shouldn't happen */
		if (tTd(64, 1))
			sm_dprintf("Milter (%s): Trying to open filter in state %c\n",
				   m->mf_name, (char) m->mf_state);
		milter_error(m, e);
# if NETINET6
		if (hp != NULL)
			freehostent(hp);
# endif /* NETINET6 */
		return -1;
	}

	/* nope, actually connecting */
	for (;;)
	{
		sock = socket(addr.sa.sa_family, SOCK_STREAM, 0);
		if (sock < 0)
		{
			save_errno = errno;
			if (tTd(64, 5))
				sm_dprintf("Milter (%s): error creating socket: %s\n",
					   m->mf_name,
					   sm_errstring(save_errno));
			if (MilterLogLevel > 0)
				sm_syslog(LOG_ERR, e->e_id,
					  "Milter (%s): error creating socket: %s",
					  m->mf_name, sm_errstring(save_errno));
			milter_error(m, e);
# if NETINET6
			if (hp != NULL)
				freehostent(hp);
# endif /* NETINET6 */
			return -1;
		}

		if (setjmp(MilterConnectTimeout) == 0)
		{
			SM_EVENT *ev = NULL;
			int i;

			if (m->mf_timeout[SMFTO_CONNECT] > 0)
				ev = sm_setevent(m->mf_timeout[SMFTO_CONNECT],
						 milter_connect_timeout, 0);

			i = connect(sock, (struct sockaddr *) &addr, addrlen);
			save_errno = errno;
			if (ev != NULL)
				sm_clrevent(ev);
			errno = save_errno;
			if (i >= 0)
				break;
		}

		/* couldn't connect.... try next address */
		save_errno = errno;
		p = CurHostName;
		CurHostName = at;
		if (tTd(64, 5))
			sm_dprintf("milter_open (%s): open %s failed: %s\n",
				   m->mf_name, at, sm_errstring(save_errno));
		if (MilterLogLevel > 13)
			sm_syslog(LOG_INFO, e->e_id,
				  "Milter (%s): open %s failed: %s",
				  m->mf_name, at, sm_errstring(save_errno));
		CurHostName = p;
		(void) close(sock);

		/* try next address */
		if (hp != NULL && hp->h_addr_list[addrno] != NULL)
		{
			switch (addr.sa.sa_family)
			{
# if NETINET
			  case AF_INET:
				memmove(&addr.sin.sin_addr,
					hp->h_addr_list[addrno++],
					INADDRSZ);
				break;
# endif /* NETINET */

# if NETINET6
			  case AF_INET6:
				memmove(&addr.sin6.sin6_addr,
					hp->h_addr_list[addrno++],
					IN6ADDRSZ);
				break;
# endif /* NETINET6 */

			  default:
				if (tTd(64, 5))
					sm_dprintf("X%s: Unknown protocol for %s (%d)\n",
						   m->mf_name, at,
						   hp->h_addrtype);
				if (MilterLogLevel > 0)
					sm_syslog(LOG_ERR, e->e_id,
						  "Milter (%s): Unknown protocol for %s (%d)",
						  m->mf_name, at,
						  hp->h_addrtype);
				milter_error(m, e);
# if NETINET6
				freehostent(hp);
# endif /* NETINET6 */
				return -1;
			}
			continue;
		}
		p = CurHostName;
		CurHostName = at;
		if (tTd(64, 5))
			sm_dprintf("X%s: error connecting to filter: %s\n",
				   m->mf_name, sm_errstring(save_errno));
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "Milter (%s): error connecting to filter: %s",
				  m->mf_name, sm_errstring(save_errno));
		CurHostName = p;
		milter_error(m, e);
# if NETINET6
		if (hp != NULL)
			freehostent(hp);
# endif /* NETINET6 */
		return -1;
	}
	m->mf_state = SMFS_OPEN;
# if NETINET6
	if (hp != NULL)
	{
		freehostent(hp);
		hp = NULL;
	}
# endif /* NETINET6 */
# if MILTER_NO_NAGLE && !defined(TCP_CORK)
	{
		int nodelay = 1;

		setsockopt(m->mf_sock, IPPROTO_TCP, TCP_NODELAY,
			   (char *)&nodelay, sizeof(nodelay));
	}
# endif /* MILTER_NO_NAGLE && !defined(TCP_CORK) */
	return sock;
}

static void
milter_connect_timeout(ignore)
	int ignore;
{
	/*
	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD
	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE
	**	DOING.
	*/

	errno = ETIMEDOUT;
	longjmp(MilterConnectTimeout, 1);
}

/*
**  MILTER_SETUP -- setup structure for a mail filter
**
**	Parameters:
**		line -- the options line.
**
**	Returns:
**		none
*/

void
milter_setup(line)
	char *line;
{
	char fcode;
	char *p;
	struct milter *m;
	STAB *s;
	static int idx = 0;

	/* collect the filter name */
	for (p = line;
	     *p != '\0' && *p != ',' && !(isascii(*p) && isspace(*p));
	     p++)
		continue;
	if (*p != '\0')
		*p++ = '\0';
	if (line[0] == '\0')
	{
		syserr("name required for mail filter");
		return;
	}
	m = (struct milter *) xalloc(sizeof(*m));
	memset((char *) m, '\0', sizeof(*m));
	m->mf_name = newstr(line);
	m->mf_state = SMFS_READY;
	m->mf_sock = -1;
	m->mf_timeout[SMFTO_CONNECT] = (time_t) 300;
	m->mf_timeout[SMFTO_WRITE] = (time_t) 10;
	m->mf_timeout[SMFTO_READ] = (time_t) 10;
	m->mf_timeout[SMFTO_EOM] = (time_t) 300;
#if _FFR_MILTER_CHECK
	m->mf_mta_prot_version = SMFI_PROT_VERSION;
	m->mf_mta_prot_flags = SMFI_CURR_PROT;
	m->mf_mta_actions = SMFI_CURR_ACTS;
#endif /* _FFR_MILTER_CHECK */

	/* now scan through and assign info from the fields */
	while (*p != '\0')
	{
		char *delimptr;

		while (*p != '\0' &&
		       (*p == ',' || (isascii(*p) && isspace(*p))))
			p++;

		/* p now points to field code */
		fcode = *p;
		while (*p != '\0' && *p != '=' && *p != ',')
			p++;
		if (*p++ != '=')
		{
			syserr("X%s: `=' expected", m->mf_name);
			return;
		}
		while (isascii(*p) && isspace(*p))
			p++;

		/* p now points to the field body */
		p = munchstring(p, &delimptr, ',');

		/* install the field into the filter struct */
		switch (fcode)
		{
		  case 'S':		/* socket */
			if (p == NULL)
				m->mf_conn = NULL;
			else
				m->mf_conn = newstr(p);
			break;

		  case 'F':		/* Milter flags configured on MTA */
			for (; *p != '\0'; p++)
			{
				if (!(isascii(*p) && isspace(*p)))
					setbitn(bitidx(*p), m->mf_flags);
			}
			break;

		  case 'T':		/* timeouts */
			milter_parse_timeouts(p, m);
			break;

#if _FFR_MILTER_CHECK
		  case 'a':
			m->mf_mta_actions = strtoul(p, NULL, 0);
			break;
		  case 'f':
			m->mf_mta_prot_flags = strtoul(p, NULL, 0);
			break;
		  case 'v':
			m->mf_mta_prot_version = strtoul(p, NULL, 0);
			break;
#endif /* _FFR_MILTER_CHECK */

		  default:
			syserr("X%s: unknown filter equate %c=",
			       m->mf_name, fcode);
			break;
		}
		p = delimptr;
	}

	/* early check for errors */
	(void) milter_open(m, true, CurEnv);

	/* enter the filter into the symbol table */
	s = stab(m->mf_name, ST_MILTER, ST_ENTER);
	if (s->s_milter != NULL)
		syserr("X%s: duplicate filter definition", m->mf_name);
	else
	{
		s->s_milter = m;
		m->mf_idx = ++idx;
	}
}

/*
**  MILTER_CONFIG -- parse option list into an array and check config
**
**	Called when reading configuration file.
**
**	Parameters:
**		spec -- the filter list.
**		list -- the array to fill in.
**		max -- the maximum number of entries in list.
**
**	Returns:
**		none
*/

void
milter_config(spec, list, max)
	char *spec;
	struct milter **list;
	int max;
{
	int numitems = 0;
	char *p;

	/* leave one for the NULL signifying the end of the list */
	max--;

	for (p = spec; p != NULL; )
	{
		STAB *s;

		while (isascii(*p) && isspace(*p))
			p++;
		if (*p == '\0')
			break;
		spec = p;

		if (numitems >= max)
		{
			syserr("Too many filters defined, %d max", max);
			if (max > 0)
				list[0] = NULL;
			return;
		}
		p = strpbrk(p, ";,");
		if (p != NULL)
			*p++ = '\0';

		s = stab(spec, ST_MILTER, ST_FIND);
		if (s == NULL)
		{
			syserr("InputFilter %s not defined", spec);
			ExitStat = EX_CONFIG;
			return;
		}
		list[numitems++] = s->s_milter;
	}
	list[numitems] = NULL;

	/* if not set, set to LogLevel */
	if (MilterLogLevel == -1)
		MilterLogLevel = LogLevel;
}

/*
**  MILTER_PARSE_TIMEOUTS -- parse timeout list
**
**	Called when reading configuration file.
**
**	Parameters:
**		spec -- the timeout list.
**		m -- milter to set.
**
**	Returns:
**		none
*/

static void
milter_parse_timeouts(spec, m)
	char *spec;
	struct milter *m;
{
	char fcode;
	int tcode;
	char *p;

	p = spec;

	/* now scan through and assign info from the fields */
	while (*p != '\0')
	{
		char *delimptr;

		while (*p != '\0' &&
		       (*p == ';' || (isascii(*p) && isspace(*p))))
			p++;

		/* p now points to field code */
		fcode = *p;
		while (*p != '\0' && *p != ':')
			p++;
		if (*p++ != ':')
		{
			syserr("X%s, T=: `:' expected", m->mf_name);
			return;
		}
		while (isascii(*p) && isspace(*p))
			p++;

		/* p now points to the field body */
		p = munchstring(p, &delimptr, ';');
		tcode = -1;

		/* install the field into the filter struct */
		switch (fcode)
		{
		  case 'C':
			tcode = SMFTO_CONNECT;
			break;

		  case 'S':
			tcode = SMFTO_WRITE;
			break;

		  case 'R':
			tcode = SMFTO_READ;
			break;

		  case 'E':
			tcode = SMFTO_EOM;
			break;

		  default:
			if (tTd(64, 5))
				sm_dprintf("X%s: %c unknown\n",
					   m->mf_name, fcode);
			syserr("X%s: unknown filter timeout %c",
			       m->mf_name, fcode);
			break;
		}
		if (tcode >= 0)
		{
			m->mf_timeout[tcode] = convtime(p, 's');
			if (tTd(64, 5))
				sm_dprintf("X%s: %c=%ld\n",
					   m->mf_name, fcode,
					   (u_long) m->mf_timeout[tcode]);
		}
		p = delimptr;
	}
}

/*
**  MILTER_SET_MACROS -- set milter macros
**
**	Parameters:
**		name -- name of milter.
**		macros -- where to store macros.
**		val -- the value of the option.
**		nummac -- current number of macros
**
**	Returns:
**		new number of macros
*/

static int
milter_set_macros(name, macros, val, nummac)
	char *name;
	char **macros;
	char *val;
	int nummac;
{
	char *p;

	p = newstr(val);
	while (*p != '\0')
	{
		char *macro;

		/* Skip leading commas, spaces */
		while (*p != '\0' &&
		       (*p == ',' || (isascii(*p) && isspace(*p))))
			p++;

		if (*p == '\0')
			break;

		/* Find end of macro */
		macro = p;
		while (*p != '\0' && *p != ',' &&
		       isascii(*p) && !isspace(*p))
			p++;
		if (*p != '\0')
			*p++ = '\0';

		if (nummac >= MAXFILTERMACROS)
		{
			syserr("milter_set_option: too many macros in Milter.%s (max %d)",
			       name, MAXFILTERMACROS);
			macros[nummac] = NULL;
			return -1;
		}
		macros[nummac++] = macro;
	}
	macros[nummac] = NULL;
	return nummac;
}

/*
**  MILTER_SET_OPTION -- set an individual milter option
**
**	Parameters:
**		name -- the name of the option.
**		val -- the value of the option.
**		sticky -- if set, don't let other setoptions override
**			this value.
**
**	Returns:
**		none.
*/

/* set if Milter sub-option is stuck */
static BITMAP256	StickyMilterOpt;

static struct milteropt
{
	char		*mo_name;	/* long name of milter option */
	unsigned char	mo_code;	/* code for option */
} MilterOptTab[] =
{
	{ "macros.connect",		SMFIM_CONNECT			},
	{ "macros.helo",		SMFIM_HELO			},
	{ "macros.envfrom",		SMFIM_ENVFROM			},
	{ "macros.envrcpt",		SMFIM_ENVRCPT			},
	{ "macros.data",		SMFIM_DATA			},
	{ "macros.eom",			SMFIM_EOM			},
	{ "macros.eoh",			SMFIM_EOH			},

# define MO_LOGLEVEL			0x07
	{ "loglevel",			MO_LOGLEVEL			},
# if _FFR_MAXDATASIZE || _FFR_MDS_NEGOTIATE
#  define MO_MAXDATASIZE		0x08
	{ "maxdatasize",		MO_MAXDATASIZE			},
# endif /* _FFR_MAXDATASIZE || _FFR_MDS_NEGOTIATE */
	{ NULL,				(unsigned char)-1		},
};

void
milter_set_option(name, val, sticky)
	char *name;
	char *val;
	bool sticky;
{
	int nummac, r;
	struct milteropt *mo;
	char **macros = NULL;

	nummac = 0;
	if (tTd(37, 2) || tTd(64, 5))
		sm_dprintf("milter_set_option(%s = %s)", name, val);

	if (name == NULL)
	{
		syserr("milter_set_option: invalid Milter option, must specify suboption");
		return;
	}

	for (mo = MilterOptTab; mo->mo_name != NULL; mo++)
	{
		if (sm_strcasecmp(mo->mo_name, name) == 0)
			break;
	}

	if (mo->mo_name == NULL)
	{
		syserr("milter_set_option: invalid Milter option %s", name);
		return;
	}

	/*
	**  See if this option is preset for us.
	*/

	if (!sticky && bitnset(mo->mo_code, StickyMilterOpt))
	{
		if (tTd(37, 2) || tTd(64,5))
			sm_dprintf(" (ignored)\n");
		return;
	}

	if (tTd(37, 2) || tTd(64,5))
		sm_dprintf("\n");

	switch (mo->mo_code)
	{
	  case MO_LOGLEVEL:
		MilterLogLevel = atoi(val);
		break;

# if _FFR_MAXDATASIZE || _FFR_MDS_NEGOTIATE
	  case MO_MAXDATASIZE:
#  if _FFR_MDS_NEGOTIATE
		MilterMaxDataSize = (size_t)atol(val);
		if (MilterMaxDataSize != MILTER_MDS_64K &&
		    MilterMaxDataSize != MILTER_MDS_256K &&
		    MilterMaxDataSize != MILTER_MDS_1M)
		{
			sm_syslog(LOG_WARNING, NOQID,
				"WARNING: Milter.%s=%d, allowed are only %d, %d, and %d",
				name, MilterMaxDataSize,
				MILTER_MDS_64K, MILTER_MDS_256K,
				MILTER_MDS_1M);
			if (MilterMaxDataSize < MILTER_MDS_64K)
				MilterMaxDataSize = MILTER_MDS_64K;
			else if (MilterMaxDataSize < MILTER_MDS_256K)
				MilterMaxDataSize = MILTER_MDS_256K;
			else
				MilterMaxDataSize = MILTER_MDS_1M;
		}
#  endif /* _FFR_MDS_NEGOTIATE */
		break;
# endif /* _FFR_MAXDATASIZE || _FFR_MDS_NEGOTIATE */

	  case SMFIM_CONNECT:
	  case SMFIM_HELO:
	  case SMFIM_ENVFROM:
	  case SMFIM_ENVRCPT:
	  case SMFIM_EOH:
	  case SMFIM_EOM:
	  case SMFIM_DATA:
		macros = MilterMacros[mo->mo_code][0];

		r = milter_set_macros(name, macros, val, nummac);
		if (r >= 0)
			nummac = r;
		break;

	  default:
		syserr("milter_set_option: invalid Milter option %s", name);
		break;
	}
	if (sticky)
		setbitn(mo->mo_code, StickyMilterOpt);
}

/*
**  MILTER_REOPEN_DF -- open & truncate the data file (for replbody)
**
**	Parameters:
**		e -- current envelope.
**
**	Returns:
**		0 if succesful, -1 otherwise
*/

static int
milter_reopen_df(e)
	ENVELOPE *e;
{
	char dfname[MAXPATHLEN];

	(void) sm_strlcpy(dfname, queuename(e, DATAFL_LETTER), sizeof(dfname));

	/*
	**  In SuperSafe == SAFE_REALLY mode, e->e_dfp is a read-only FP so
	**  close and reopen writable (later close and reopen
	**  read only again).
	**
	**  In SuperSafe != SAFE_REALLY mode, e->e_dfp still points at the
	**  buffered file I/O descriptor, still open for writing so there
	**  isn't any work to do here (except checking for consistency).
	*/

	if (SuperSafe == SAFE_REALLY)
	{
		/* close read-only data file */
		if (bitset(EF_HAS_DF, e->e_flags) && e->e_dfp != NULL)
		{
			(void) sm_io_close(e->e_dfp, SM_TIME_DEFAULT);
			e->e_flags &= ~EF_HAS_DF;
		}

		/* open writable */
		if ((e->e_dfp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, dfname,
					   SM_IO_RDWR_B, NULL)) == NULL)
		{
			MILTER_DF_ERROR("milter_reopen_df: sm_io_open %s: %s");
			return -1;
		}
	}
	else if (e->e_dfp == NULL)
	{
		/* shouldn't happen */
		errno = ENOENT;
		MILTER_DF_ERROR("milter_reopen_df: NULL e_dfp (%s: %s)");
		return -1;
	}
	return 0;
}

/*
**  MILTER_RESET_DF -- re-open read-only the data file (for replbody)
**
**	Parameters:
**		e -- current envelope.
**
**	Returns:
**		0 if succesful, -1 otherwise
*/

static int
milter_reset_df(e)
	ENVELOPE *e;
{
	int afd;
	char dfname[MAXPATHLEN];

	(void) sm_strlcpy(dfname, queuename(e, DATAFL_LETTER), sizeof(dfname));

	if (sm_io_flush(e->e_dfp, SM_TIME_DEFAULT) != 0 ||
	    sm_io_error(e->e_dfp))
	{
		MILTER_DF_ERROR("milter_reset_df: error writing/flushing %s: %s");
		return -1;
	}
	else if (SuperSafe != SAFE_REALLY)
	{
		/* skip next few clauses */
		/* EMPTY */
	}
	else if ((afd = sm_io_getinfo(e->e_dfp, SM_IO_WHAT_FD, NULL)) >= 0
		 && fsync(afd) < 0)
	{
		MILTER_DF_ERROR("milter_reset_df: error sync'ing %s: %s");
		return -1;
	}
	else if (sm_io_close(e->e_dfp, SM_TIME_DEFAULT) < 0)
	{
		MILTER_DF_ERROR("milter_reset_df: error closing %s: %s");
		return -1;
	}
	else if ((e->e_dfp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT, dfname,
					SM_IO_RDONLY_B, NULL)) == NULL)
	{
		MILTER_DF_ERROR("milter_reset_df: error reopening %s: %s");
		return -1;
	}
	else
		e->e_flags |= EF_HAS_DF;
	return 0;
}

/*
**  MILTER_QUIT_FILTER -- close down a single filter
**
**	Parameters:
**		m -- milter structure of filter to close down.
**		e -- current envelope.
**
**	Returns:
**		none
*/

static void
milter_quit_filter(m, e)
	struct milter *m;
	ENVELOPE *e;
{
	if (tTd(64, 10))
		sm_dprintf("milter_quit_filter(%s)\n", m->mf_name);
	if (MilterLogLevel > 18)
		sm_syslog(LOG_INFO, e->e_id, "Milter (%s): quit filter",
			  m->mf_name);

	/* Never replace error state */
	if (m->mf_state == SMFS_ERROR)
		return;

	if (m->mf_sock < 0 ||
	    m->mf_state == SMFS_CLOSED ||
	    m->mf_state == SMFS_READY)
	{
		m->mf_sock = -1;
		m->mf_state = SMFS_CLOSED;
		return;
	}

	(void) milter_write(m, SMFIC_QUIT, (char *) NULL, 0,
			    m->mf_timeout[SMFTO_WRITE], e, "quit_filter");
	if (m->mf_sock >= 0)
	{
		(void) close(m->mf_sock);
		m->mf_sock = -1;
	}
	if (m->mf_state != SMFS_ERROR)
		m->mf_state = SMFS_CLOSED;
}

/*
**  MILTER_ABORT_FILTER -- tell filter to abort current message
**
**	Parameters:
**		m -- milter structure of filter to abort.
**		e -- current envelope.
**
**	Returns:
**		none
*/

static void
milter_abort_filter(m, e)
	struct milter *m;
	ENVELOPE *e;
{
	if (tTd(64, 10))
		sm_dprintf("milter_abort_filter(%s)\n", m->mf_name);
	if (MilterLogLevel > 10)
		sm_syslog(LOG_INFO, e->e_id, "Milter (%s): abort filter",
			  m->mf_name);

	if (m->mf_sock < 0 ||
	    m->mf_state != SMFS_INMSG)
		return;

	(void) milter_write(m, SMFIC_ABORT, (char *) NULL, 0,
			    m->mf_timeout[SMFTO_WRITE], e, "abort_filter");
	if (m->mf_state != SMFS_ERROR)
		m->mf_state = SMFS_DONE;
}

/*
**  MILTER_SEND_MACROS -- provide macros to the filters
**
**	Parameters:
**		m -- milter to send macros to.
**		macros -- macros to send for filter smfi_getsymval().
**		cmd -- which command the macros are associated with.
**		e -- current envelope (for macro access).
**
**	Returns:
**		none
*/

static void
milter_send_macros(m, macros, cmd, e)
	struct milter *m;
	char **macros;
	int cmd;
	ENVELOPE *e;
{
	int i;
	int mid;
	char command = (char) cmd;
	char *v;
	char *buf, *bp;
	char exp[MAXLINE];
	ssize_t s;

	/* sanity check */
	if (macros == NULL || macros[0] == NULL)
		return;

	/* put together data */
	s = 1;			/* for the command character */
	for (i = 0; macros[i] != NULL; i++)
	{
		mid = macid(macros[i]);
		if (mid == 0)
			continue;
		v = macvalue(mid, e);
		if (v == NULL)
			continue;
		expand(v, exp, sizeof(exp), e);
		s += strlen(macros[i]) + 1 + strlen(exp) + 1;
	}

	if (s < 0)
		return;

	buf = (char *) xalloc(s);
	bp = buf;
	*bp++ = command;
	for (i = 0; macros[i] != NULL; i++)
	{
		mid = macid(macros[i]);
		if (mid == 0)
			continue;
		v = macvalue(mid, e);
		if (v == NULL)
			continue;
		expand(v, exp, sizeof(exp), e);

		if (tTd(64, 10))
			sm_dprintf("milter_send_macros(%s, %c): %s=%s\n",
				m->mf_name, command, macros[i], exp);

		(void) sm_strlcpy(bp, macros[i], s - (bp - buf));
		bp += strlen(bp) + 1;
		(void) sm_strlcpy(bp, exp, s - (bp - buf));
		bp += strlen(bp) + 1;
	}
	(void) milter_write(m, SMFIC_MACRO, buf, s,
			    m->mf_timeout[SMFTO_WRITE], e, "send_macros");
	sm_free(buf);
}

/*
**  MILTER_SEND_COMMAND -- send a command and return the response for a filter
**
**	Parameters:
**		m -- current milter filter
**		cmd -- command to send.
**		data -- optional command data.
**		sz -- length of buf.
**		e -- current envelope (for e->e_id).
**		state -- return state word.
**
**	Returns:
**		response string (may be NULL)
*/

static char *
milter_send_command(m, cmd, data, sz, e, state, where)
	struct milter *m;
	int cmd;
	void *data;
	ssize_t sz;
	ENVELOPE *e;
	char *state;
	const char *where;
{
	char rcmd;
	ssize_t rlen;
	unsigned long skipflag;
	unsigned long norespflag = 0;
	char command = (char) cmd;
	char *action;
	char *defresponse;
	char *response;

	if (tTd(64, 10))
		sm_dprintf("milter_send_command(%s): cmd %c len %ld\n",
			m->mf_name, (char) command, (long) sz);

	/* find skip flag and default failure */
	switch (command)
	{
	  case SMFIC_CONNECT:
		skipflag = SMFIP_NOCONNECT;
		norespflag = SMFIP_NR_CONN;
		action = "connect";
		defresponse = "554 Command rejected";
		break;

	  case SMFIC_HELO:
		skipflag = SMFIP_NOHELO;
		norespflag = SMFIP_NR_HELO;
		action = "helo";
		defresponse = "550 Command rejected";
		break;

	  case SMFIC_MAIL:
		skipflag = SMFIP_NOMAIL;
		norespflag = SMFIP_NR_MAIL;
		action = "mail";
		defresponse = "550 5.7.1 Command rejected";
		break;

	  case SMFIC_RCPT:
		skipflag = SMFIP_NORCPT;
		norespflag = SMFIP_NR_RCPT;
		action = "rcpt";
		defresponse = "550 5.7.1 Command rejected";
		break;

	  case SMFIC_HEADER:
		skipflag = SMFIP_NOHDRS;
		norespflag = SMFIP_NR_HDR;
		action = "header";
		defresponse = "550 5.7.1 Command rejected";
		break;

	  case SMFIC_BODY:
		skipflag = SMFIP_NOBODY;
		norespflag = SMFIP_NR_BODY;
		action = "body";
		defresponse = "554 5.7.1 Command rejected";
		break;

	  case SMFIC_EOH:
		skipflag = SMFIP_NOEOH;
		norespflag = SMFIP_NR_EOH;
		action = "eoh";
		defresponse = "550 5.7.1 Command rejected";
		break;

	  case SMFIC_UNKNOWN:
		skipflag = SMFIP_NOUNKNOWN;
		norespflag = SMFIP_NR_UNKN;
		action = "unknown";
		defresponse = "550 5.7.1 Command rejected";
		break;

	  case SMFIC_DATA:
		skipflag = SMFIP_NODATA;
		norespflag = SMFIP_NR_DATA;
		action = "data";
		defresponse = "550 5.7.1 Command rejected";
		break;

	  case SMFIC_BODYEOB:
	  case SMFIC_OPTNEG:
	  case SMFIC_MACRO:
	  case SMFIC_ABORT:
	  case SMFIC_QUIT:
		/* NOTE: not handled by milter_send_command() */
		/* FALLTHROUGH */

	  default:
		skipflag = 0;
		action = "default";
		defresponse = "550 5.7.1 Command rejected";
		break;
	}

	if (tTd(64, 10))
		sm_dprintf("milter_send_command(%s): skip=%lx, pflags=%x\n",
			m->mf_name, skipflag, m->mf_pflags);

	/* check if filter wants this command */
	if (skipflag != 0 && bitset(skipflag, m->mf_pflags))
		return NULL;

	/* send the command to the filter */
	(void) milter_write(m, command, data, sz,
			    m->mf_timeout[SMFTO_WRITE], e, where);
	if (m->mf_state == SMFS_ERROR)
	{
		MILTER_CHECK_ERROR(false, return NULL);
		return NULL;
	}

	/* check if filter sends response to this command */
	if (norespflag != 0 && bitset(norespflag, m->mf_pflags))
		return NULL;

	/* get the response from the filter */
	response = milter_read(m, &rcmd, &rlen,
			       m->mf_timeout[SMFTO_READ], e, where);
	if (m->mf_state == SMFS_ERROR)
	{
		MILTER_CHECK_ERROR(false, return NULL);
		return NULL;
	}

	if (tTd(64, 10))
		sm_dprintf("milter_send_command(%s): returned %c\n",
			   m->mf_name, (char) rcmd);

	switch (rcmd)
	{
	  case SMFIR_REPLYCODE:
		MILTER_CHECK_REPLYCODE(defresponse);
		if (MilterLogLevel > 10)
			sm_syslog(LOG_INFO, e->e_id,
				  "milter=%s, action=%s, reject=%s",
				  m->mf_name, action, response);
		*state = rcmd;
		break;

	  case SMFIR_REJECT:
		if (MilterLogLevel > 10)
			sm_syslog(LOG_INFO, e->e_id,
				  "milter=%s, action=%s, reject",
				  m->mf_name, action);
		*state = rcmd;
		break;

	  case SMFIR_DISCARD:
		if (MilterLogLevel > 10)
			sm_syslog(LOG_INFO, e->e_id,
				  "milter=%s, action=%s, discard",
				  m->mf_name, action);
		*state = rcmd;
		break;

	  case SMFIR_TEMPFAIL:
		if (MilterLogLevel > 10)
			sm_syslog(LOG_INFO, e->e_id,
				  "milter=%s, action=%s, tempfail",
				  m->mf_name, action);
		*state = rcmd;
		break;

	  case SMFIR_ACCEPT:
		/* this filter is done with message/connection */
		if (command == SMFIC_HELO ||
		    command == SMFIC_CONNECT)
			m->mf_state = SMFS_CLOSABLE;
		else
			m->mf_state = SMFS_DONE;
		if (MilterLogLevel > 10)
			sm_syslog(LOG_INFO, e->e_id,
				  "milter=%s, action=%s, accepted",
				  m->mf_name, action);
		break;

	  case SMFIR_CONTINUE:
		/* if MAIL command is ok, filter is in message state */
		if (command == SMFIC_MAIL)
			m->mf_state = SMFS_INMSG;
		if (MilterLogLevel > 12)
			sm_syslog(LOG_INFO, e->e_id,
				  "milter=%s, action=%s, continue",
				  m->mf_name, action);
		break;

	  case SMFIR_SKIP:
		if (MilterLogLevel > 12)
			sm_syslog(LOG_INFO, e->e_id,
				  "milter=%s, action=%s, skip",
				  m->mf_name, action);
		m->mf_state = SMFS_SKIP;
		break;

	  default:
		/* Invalid response to command */
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "milter_send_command(%s): action=%s returned bogus response %c",
				  m->mf_name, action, rcmd);
		milter_error(m, e); /* NO ERROR CHECK? */
		break;
	}

	if (*state != SMFIR_REPLYCODE && response != NULL)
	{
		sm_free(response); /* XXX */
		response = NULL;
	}
	return response;
}

/*
**  MILTER_COMMAND -- send a command and return the response for each filter
**
**	Parameters:
**		cmd -- command to send.
**		data -- optional command data.
**		sz -- length of buf.
**		stage -- index of macros to send for filter smfi_getsymval().
**		e -- current envelope (for macro access).
**		state -- return state word.
**		where -- description of calling function (logging).
**		cmd_error -- did the SMTP command cause an error?
**
**	Returns:
**		response string (may be NULL)
*/

static char *
milter_command(cmd, data, sz, stage, e, state, where, cmd_error)
	int cmd;
	void *data;
	ssize_t sz;
	int stage;
	ENVELOPE *e;
	char *state;
	const char *where;
	bool cmd_error;
{
	int i;
	char command = (char) cmd;
	char *response = NULL;
	time_t tn = 0;

	if (tTd(64, 10))
		sm_dprintf("milter_command: cmd %c len %ld\n",
			command, (long) sz);

	*state = SMFIR_CONTINUE;
	for (i = 0; InputFilters[i] != NULL; i++)
	{
		struct milter *m = InputFilters[i];

		/* previous problem? */
		if (m->mf_state == SMFS_ERROR)
		{
			MILTER_CHECK_ERROR(false, continue);
			break;
		}

		/* sanity check */
		if (m->mf_sock < 0 ||
		    (m->mf_state != SMFS_OPEN && m->mf_state != SMFS_INMSG))
			continue;

		if (stage >= SMFIM_FIRST && stage <= SMFIM_LAST)
		{
			int idx;
			char **macros;

			if ((m->mf_lflags & MI_LFLAGS_SYM(stage)) != 0)
				idx = m->mf_idx;
			else
				idx = 0;
			SM_ASSERT(idx >= 0 && idx <= MAXFILTERS);
			macros = MilterMacros[stage][idx];

			/* send macros (regardless of whether we send cmd) */
			if (macros != NULL && macros[0] != NULL)
			{
				milter_send_macros(m, macros, command, e);
				if (m->mf_state == SMFS_ERROR)
				{
					MILTER_CHECK_ERROR(false, continue);
					break;
				}
			}
		}

		if (MilterLogLevel > 21)
			tn = curtime();

		/*
		**  send the command if
		**	there is no error
		**	or it's RCPT and the client asked for it:
		**	!cmd_error ||
		**	where == "rcpt" && m->mf_pflags & SMFIP_RCPT_REJ != 0
		**  negate that condition and use continue
		*/

		if (cmd_error &&
		    (strcmp(where, "rcpt") != 0 ||
		     (m->mf_pflags & SMFIP_RCPT_REJ) == 0))
			continue;

		response = milter_send_command(m, command, data, sz, e, state,
						where);

		if (MilterLogLevel > 21)
		{
			/* log the time it took for the command per filter */
			sm_syslog(LOG_INFO, e->e_id,
				  "Milter (%s): time command (%c), %d",
				  m->mf_name, command, (int) (tn - curtime()));
		}

		if (*state != SMFIR_CONTINUE)
			break;
	}
	return response;
}

static int milter_getsymlist __P((struct milter *, char *, int, int));

static int
milter_getsymlist(m, buf, rlen, offset)
	struct milter *m;
	char *buf;
	int rlen;
	int offset;
{
	int i, r, nummac;
	mi_int32 v;

	SM_ASSERT(m != NULL);
	SM_ASSERT(buf != NULL);

	while (offset + MILTER_LEN_BYTES < rlen)
	{
		size_t len;
		char **macros;

		nummac = 0;
		(void) memcpy((char *) &v, buf + offset, MILTER_LEN_BYTES);
		i = ntohl(v);
		if (i < SMFIM_FIRST || i > SMFIM_LAST)
			return -1;
		offset += MILTER_LEN_BYTES;
		macros = NULL;

		switch (i)
		{
		  case SMFIM_CONNECT:
		  case SMFIM_HELO:
		  case SMFIM_ENVFROM:
		  case SMFIM_ENVRCPT:
		  case SMFIM_EOH:
		  case SMFIM_EOM:
		  case SMFIM_DATA:
			SM_ASSERT(m->mf_idx > 0 && m->mf_idx < MAXFILTERS);
			macros = MilterMacros[i][m->mf_idx];
			m->mf_lflags |= MI_LFLAGS_SYM(i);
			len = strlen(buf + offset);
			if (len > 0)
			{
				r = milter_set_macros(m->mf_name, macros,
						buf + offset, nummac);
				if (r >= 0)
					nummac = r;
				if (tTd(64, 5))
					sm_dprintf("milter_getsymlist(%s, %s)=%d\n",
						m->mf_name, buf + offset, r);
			}
			break;

		  default:
			return -1;
		}
		if (len == 0)
			return -1;
		offset += len + 1;
	}

	return 0;
}

/*
**  MILTER_NEGOTIATE -- get version and flags from filter
**
**	Parameters:
**		m -- milter filter structure.
**		e -- current envelope.
**		milters -- milters structure.
**
**	Returns:
**		0 on success, -1 otherwise
*/

static int
milter_negotiate(m, e, milters)
	struct milter *m;
	ENVELOPE *e;
	milters_T *milters;
{
	char rcmd;
	mi_int32 fvers, fflags, pflags;
	mi_int32 mta_prot_vers, mta_prot_flags, mta_actions;
	ssize_t rlen;
	char *response;
	char data[MILTER_OPTLEN];

	/* sanity check */
	if (m->mf_sock < 0 || m->mf_state != SMFS_OPEN)
	{
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "Milter (%s): negotiate, impossible state",
				  m->mf_name);
		milter_error(m, e);
		return -1;
	}

#if _FFR_MILTER_CHECK
	mta_prot_vers = m->mf_mta_prot_version;
	mta_prot_flags = m->mf_mta_prot_flags;
	mta_actions = m->mf_mta_actions;
#else /* _FFR_MILTER_CHECK */
	mta_prot_vers = SMFI_PROT_VERSION;
	mta_prot_flags = SMFI_CURR_PROT;
	mta_actions = SMFI_CURR_ACTS;
#endif /* _FFR_MILTER_CHECK */
#if _FFR_MDS_NEGOTIATE
	if (MilterMaxDataSize == MILTER_MDS_256K)
		mta_prot_flags |= SMFIP_MDS_256K;
	else if (MilterMaxDataSize == MILTER_MDS_1M)
		mta_prot_flags |= SMFIP_MDS_1M;
#endif /* _FFR_MDS_NEGOTIATE */

	fvers = htonl(mta_prot_vers);
	pflags = htonl(mta_prot_flags);
	fflags = htonl(mta_actions);
	(void) memcpy(data, (char *) &fvers, MILTER_LEN_BYTES);
	(void) memcpy(data + MILTER_LEN_BYTES,
		      (char *) &fflags, MILTER_LEN_BYTES);
	(void) memcpy(data + (MILTER_LEN_BYTES * 2),
		      (char *) &pflags, MILTER_LEN_BYTES);
	(void) milter_write(m, SMFIC_OPTNEG, data, sizeof(data),
			    m->mf_timeout[SMFTO_WRITE], e, "negotiate");

	if (m->mf_state == SMFS_ERROR)
		return -1;

	if (tTd(64, 5))
		sm_dprintf("milter_negotiate(%s): send: version %lu, fflags 0x%lx, pflags 0x%lx\n",
			m->mf_name, (unsigned long)ntohl(fvers),
			(unsigned long)ntohl(fflags), (unsigned long)ntohl(pflags));

	response = milter_read(m, &rcmd, &rlen, m->mf_timeout[SMFTO_READ], e,
				"negotiate");
	if (m->mf_state == SMFS_ERROR)
		return -1;

	if (rcmd != SMFIC_OPTNEG)
	{
		if (tTd(64, 5))
			sm_dprintf("milter_negotiate(%s): returned %c instead of %c\n",
				m->mf_name, rcmd, SMFIC_OPTNEG);
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "Milter (%s): negotiate: returned %c instead of %c",
				  m->mf_name, rcmd, SMFIC_OPTNEG);
		if (response != NULL)
			sm_free(response); /* XXX */
		milter_error(m, e);
		return -1;
	}

	/* Make sure we have enough bytes for the version */
	if (response == NULL || rlen < MILTER_LEN_BYTES)
	{
		if (tTd(64, 5))
			sm_dprintf("milter_negotiate(%s): did not return valid info\n",
				m->mf_name);
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "Milter (%s): negotiate: did not return valid info",
				  m->mf_name);
		if (response != NULL)
			sm_free(response); /* XXX */
		milter_error(m, e);
		return -1;
	}

	/* extract information */
	(void) memcpy((char *) &fvers, response, MILTER_LEN_BYTES);

	/* Now make sure we have enough for the feature bitmap */
	if (rlen < MILTER_OPTLEN)
	{
		if (tTd(64, 5))
			sm_dprintf("milter_negotiate(%s): did not return enough info\n",
				m->mf_name);
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "Milter (%s): negotiate: did not return enough info",
				  m->mf_name);
		if (response != NULL)
			sm_free(response); /* XXX */
		milter_error(m, e);
		return -1;
	}

	(void) memcpy((char *) &fflags, response + MILTER_LEN_BYTES,
		      MILTER_LEN_BYTES);
	(void) memcpy((char *) &pflags, response + (MILTER_LEN_BYTES * 2),
		      MILTER_LEN_BYTES);

	m->mf_fvers = ntohl(fvers);
	m->mf_fflags = ntohl(fflags);
	m->mf_pflags = ntohl(pflags);

	/* check for version compatibility */
	if (m->mf_fvers == 1 ||
	    m->mf_fvers > SMFI_VERSION)
	{
		if (tTd(64, 5))
			sm_dprintf("milter_negotiate(%s): version %d != MTA milter version %d\n",
				m->mf_name, m->mf_fvers, SMFI_VERSION);
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "Milter (%s): negotiate: version %d != MTA milter version %d",
				  m->mf_name, m->mf_fvers, SMFI_VERSION);
		milter_error(m, e);
		goto error;
	}

	/* check for filter feature mismatch */
	if ((m->mf_fflags & mta_actions) != m->mf_fflags)
	{
		if (tTd(64, 5))
			sm_dprintf("milter_negotiate(%s): filter abilities 0x%x != MTA milter abilities 0x%lx\n",
				m->mf_name, m->mf_fflags,
				(unsigned long) mta_actions);
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "Milter (%s): negotiate: filter abilities 0x%x != MTA milter abilities 0x%lx",
				  m->mf_name, m->mf_fflags,
				  (unsigned long) mta_actions);
		milter_error(m, e);
		goto error;
	}

#if _FFR_MDS_NEGOTIATE
	/* use a table instead of sequence? */
	if (bitset(SMFIP_MDS_1M, m->mf_pflags))
	{
		if (MilterMaxDataSize != MILTER_MDS_1M)
		{
			/* this should not happen... */
			sm_syslog(LOG_WARNING, NOQID,
				  "WARNING: Milter.maxdatasize: configured=%d, set by libmilter=%d",
		    		  MilterMaxDataSize, MILTER_MDS_1M);
			MilterMaxDataSize = MILTER_MDS_1M;
		}
	}
	else if (bitset(SMFIP_MDS_256K, m->mf_pflags))
	{
		if (MilterMaxDataSize != MILTER_MDS_256K)
		{
			sm_syslog(LOG_WARNING, NOQID,
				  "WARNING: Milter.maxdatasize: configured=%d, set by libmilter=%d",
		    		  MilterMaxDataSize, MILTER_MDS_256K);
			MilterMaxDataSize = MILTER_MDS_256K;
		}
	}
	else if (MilterMaxDataSize != MILTER_MDS_64K)
	{
		sm_syslog(LOG_WARNING, NOQID,
			  "WARNING: Milter.maxdatasize: configured=%d, set by libmilter=%d",
	    		  MilterMaxDataSize, MILTER_MDS_64K);
		MilterMaxDataSize = MILTER_MDS_64K;
	}
	m->mf_pflags &= ~SMFI_INTERNAL;
#endif /* _FFR_MDS_NEGOTIATE */

	/* check for protocol feature mismatch */
	if ((m->mf_pflags & mta_prot_flags) != m->mf_pflags)
	{
		if (tTd(64, 5))
			sm_dprintf("milter_negotiate(%s): protocol abilities 0x%x != MTA milter abilities 0x%lx\n",
				m->mf_name, m->mf_pflags,
				(unsigned long) mta_prot_flags);
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "Milter (%s): negotiate: protocol abilities 0x%x != MTA milter abilities 0x%lx",
				  m->mf_name, m->mf_pflags,
				  (unsigned long) mta_prot_flags);
		milter_error(m, e);
		goto error;
	}

	if (m->mf_fvers <= 2)
		m->mf_pflags |= SMFIP_NOUNKNOWN;
	if (m->mf_fvers <= 3)
		m->mf_pflags |= SMFIP_NODATA;

	if (rlen > MILTER_OPTLEN)
	{
		milter_getsymlist(m, response, rlen, MILTER_OPTLEN);
	}

	if (bitset(SMFIF_DELRCPT, m->mf_fflags))
		milters->mis_flags |= MIS_FL_DEL_RCPT;
	if (!bitset(SMFIP_NORCPT, m->mf_pflags) &&
	    !bitset(SMFIP_NR_RCPT, m->mf_pflags))
		milters->mis_flags |= MIS_FL_REJ_RCPT;

	if (tTd(64, 5))
		sm_dprintf("milter_negotiate(%s): received: version %u, fflags 0x%x, pflags 0x%x\n",
			m->mf_name, m->mf_fvers, m->mf_fflags, m->mf_pflags);
	return 0;

  error:
	if (response != NULL)
		sm_free(response); /* XXX */
	return -1;
}

/*
**  MILTER_PER_CONNECTION_CHECK -- checks on per-connection commands
**
**	Reduce code duplication by putting these checks in one place
**
**	Parameters:
**		e -- current envelope.
**
**	Returns:
**		none
*/

static void
milter_per_connection_check(e)
	ENVELOPE *e;
{
	int i;

	/* see if we are done with any of the filters */
	for (i = 0; InputFilters[i] != NULL; i++)
	{
		struct milter *m = InputFilters[i];

		if (m->mf_state == SMFS_CLOSABLE)
			milter_quit_filter(m, e);
	}
}

/*
**  MILTER_ERROR -- Put a milter filter into error state
**
**	Parameters:
**		m -- the broken filter.
**		e -- current envelope.
**
**	Returns:
**		none
*/

static void
milter_error(m, e)
	struct milter *m;
	ENVELOPE *e;
{
	/*
	**  We could send a quit here but we may have gotten here due to
	**  an I/O error so we don't want to try to make things worse.
	*/

	if (m->mf_sock >= 0)
	{
		(void) close(m->mf_sock);
		m->mf_sock = -1;
	}
	m->mf_state = SMFS_ERROR;

	if (MilterLogLevel > 0)
		sm_syslog(LOG_INFO, e->e_id, "Milter (%s): to error state",
			  m->mf_name);
}

/*
**  MILTER_HEADERS -- send headers to a single milter filter
**
**	Parameters:
**		m -- current filter.
**		e -- current envelope.
**		state -- return state from response.
**
**	Returns:
**		response string (may be NULL)
*/

static char *
milter_headers(m, e, state)
	struct milter *m;
	ENVELOPE *e;
	char *state;
{
	char *response = NULL;
	HDR *h;

	if (MilterLogLevel > 17)
		sm_syslog(LOG_INFO, e->e_id, "Milter (%s): headers, send",
			  m->mf_name);

	for (h = e->e_header; h != NULL; h = h->h_link)
	{
		int len_n, len_v, len_t, len_f;
		char *buf, *hv;

		/* don't send over deleted headers */
		if (h->h_value == NULL)
		{
			/* strip H_USER so not counted in milter_changeheader() */
			h->h_flags &= ~H_USER;
			continue;
		}

		/* skip auto-generated */
		if (!bitset(H_USER, h->h_flags))
			continue;

		if (tTd(64, 10))
			sm_dprintf("milter_headers: %s:%s\n",
				h->h_field, h->h_value);
		if (MilterLogLevel > 21)
			sm_syslog(LOG_INFO, e->e_id, "Milter (%s): header, %s",
				  m->mf_name, h->h_field);

		if (bitset(SMFIP_HDR_LEADSPC, m->mf_pflags)
		    || *(h->h_value) != ' ')
			hv = h->h_value;
		else
			hv = h->h_value + 1;
		len_f = strlen(h->h_field) + 1;
		len_t = len_f + strlen(hv) + 1;
		if (len_t < 0)
			continue;
		buf = (char *) xalloc(len_t);

		/*
		**  Note: currently the call to dequote_internal_chars()
		**  is not required as h_field is supposed to be 7-bit US-ASCII.
		*/

		len_n = dequote_internal_chars(h->h_field, buf, len_f);
		SM_ASSERT(len_n < len_f);
		len_v = dequote_internal_chars(hv, buf + len_n + 1,
						len_t - len_n - 1);
		SM_ASSERT(len_t >= len_n + 1 + len_v + 1);
		len_t = len_n + 1 + len_v + 1;

		/* send it over */
		response = milter_send_command(m, SMFIC_HEADER, buf,
					       len_t, e, state, "header");
		sm_free(buf);
		if (m->mf_state == SMFS_ERROR ||
		    m->mf_state == SMFS_DONE ||
		    *state != SMFIR_CONTINUE)
			break;
	}
	if (MilterLogLevel > 17)
		sm_syslog(LOG_INFO, e->e_id, "Milter (%s): headers, sent",
			  m->mf_name);
	return response;
}

/*
**  MILTER_BODY -- send the body to a filter
**
**	Parameters:
**		m -- current filter.
**		e -- current envelope.
**		state -- return state from response.
**
**	Returns:
**		response string (may be NULL)
*/

static char *
milter_body(m, e, state)
	struct milter *m;
	ENVELOPE *e;
	char *state;
{
	char bufchar = '\0';
	char prevchar = '\0';
	int c;
	char *response = NULL;
	char *bp;
	char buf[MILTER_CHUNK_SIZE];

	if (tTd(64, 10))
		sm_dprintf("milter_body\n");

	if (bfrewind(e->e_dfp) < 0)
	{
		ExitStat = EX_IOERR;
		*state = SMFIR_TEMPFAIL;
		syserr("milter_body: %s/%cf%s: rewind error",
		       qid_printqueue(e->e_qgrp, e->e_qdir),
		       DATAFL_LETTER, e->e_id);
		return NULL;
	}

	if (MilterLogLevel > 17)
		sm_syslog(LOG_INFO, e->e_id, "Milter (%s): body, send",
			  m->mf_name);
	bp = buf;
	while ((c = sm_io_getc(e->e_dfp, SM_TIME_DEFAULT)) != SM_IO_EOF)
	{
		/*  Change LF to CRLF */
		if (c == '\n')
		{
#if !_FFR_MILTER_CONVERT_ALL_LF_TO_CRLF
			/* Not a CRLF already? */
			if (prevchar != '\r')
#endif /* !_FFR_MILTER_CONVERT_ALL_LF_TO_CRLF */
			{
				/* Room for CR now? */
				if (bp + 2 > &buf[sizeof(buf)])
				{
					/* No room, buffer LF */
					bufchar = c;

					/* and send CR now */
					c = '\r';
				}
				else
				{
					/* Room to do it now */
					*bp++ = '\r';
					prevchar = '\r';
				}
			}
		}
		*bp++ = (char) c;
		prevchar = c;
		if (bp >= &buf[sizeof(buf)])
		{
			/* send chunk */
			response = milter_send_command(m, SMFIC_BODY, buf,
						       bp - buf, e, state,
							"body chunk");
			bp = buf;
			if (bufchar != '\0')
			{
				*bp++ = bufchar;
				bufchar = '\0';
				prevchar = bufchar;
			}
		}
		if (m->mf_state == SMFS_ERROR ||
		    m->mf_state == SMFS_DONE ||
		    m->mf_state == SMFS_SKIP ||
		    *state != SMFIR_CONTINUE)
			break;
	}

	/* check for read errors */
	if (sm_io_error(e->e_dfp))
	{
		ExitStat = EX_IOERR;
		if (*state == SMFIR_CONTINUE ||
		    *state == SMFIR_ACCEPT ||
		    m->mf_state == SMFS_SKIP)
		{
			*state = SMFIR_TEMPFAIL;
			if (response != NULL)
			{
				sm_free(response); /* XXX */
				response = NULL;
			}
		}
		syserr("milter_body: %s/%cf%s: read error",
		       qid_printqueue(e->e_qgrp, e->e_qdir),
		       DATAFL_LETTER, e->e_id);
		return response;
	}

	/* send last body chunk */
	if (bp > buf &&
	    m->mf_state != SMFS_ERROR &&
	    m->mf_state != SMFS_DONE &&
	    m->mf_state != SMFS_SKIP &&
	    *state == SMFIR_CONTINUE)
	{
		/* send chunk */
		response = milter_send_command(m, SMFIC_BODY, buf, bp - buf,
					       e, state, "last body chunk");
		bp = buf;
	}
	if (MilterLogLevel > 17)
		sm_syslog(LOG_INFO, e->e_id, "Milter (%s): body, sent",
			  m->mf_name);
	if (m->mf_state == SMFS_SKIP)
	{
		*state = SMFIR_CONTINUE;
		m->mf_state = SMFS_READY;
	}

	return response;
}

/*
**  Actions
*/

/*
**  ADDLEADINGSPACE -- Add a leading space to a string
**
**	Parameters:
**		str -- string
**		rp -- resource pool for allocations
**
**	Returns:
**		pointer to new string
*/

static char *addleadingspace __P((char *, SM_RPOOL_T *));

static char *
addleadingspace(str, rp)
	char *str;
	SM_RPOOL_T *rp;
{
	size_t l;
	char *new;

	SM_ASSERT(str != NULL);
	l = strlen(str);
	SM_ASSERT(l + 2 > l);
	new = sm_rpool_malloc_x(rp, l + 2);
	new[0] = ' ';
	new[1] = '\0';
	sm_strlcpy(new + 1, str, l + 1);
	return new;
}

/*
**  MILTER_ADDHEADER -- Add the supplied header to the message
**
**	Parameters:
**		m -- current filter.
**		response -- encoded form of header/value.
**		rlen -- length of response.
**		e -- current envelope.
**
**	Returns:
**		none
*/

static void
milter_addheader(m, response, rlen, e)
	struct milter *m;
	char *response;
	ssize_t rlen;
	ENVELOPE *e;
{
	int mh_v_len;
	char *val, *mh_value;
	HDR *h;

	if (tTd(64, 10))
		sm_dprintf("milter_addheader: ");

	/* sanity checks */
	if (response == NULL)
	{
		if (tTd(64, 10))
			sm_dprintf("NULL response\n");
		return;
	}

	if (rlen < 2 || strlen(response) + 1 >= (size_t) rlen)
	{
		if (tTd(64, 10))
			sm_dprintf("didn't follow protocol (total len %d != rlen %d)\n",
				   (int) strlen(response), (int) (rlen - 1));
		return;
	}

	/* Find separating NUL */
	val = response + strlen(response) + 1;

	/* another sanity check */
	if (strlen(response) + strlen(val) + 2 != (size_t) rlen)
	{
		if (tTd(64, 10))
			sm_dprintf("didn't follow protocol (part len)\n");
		return;
	}

	if (*response == '\0')
	{
		if (tTd(64, 10))
			sm_dprintf("empty field name\n");
		return;
	}

	for (h = e->e_header; h != NULL; h = h->h_link)
	{
		if (sm_strcasecmp(h->h_field, response) == 0 &&
		    !bitset(H_USER, h->h_flags) &&
		    !bitset(H_TRACE, h->h_flags))
			break;
	}

	mh_v_len = 0;
	mh_value = quote_internal_chars(val, NULL, &mh_v_len);

	/* add to e_msgsize */
	e->e_msgsize += strlen(response) + 2 + strlen(val);

	if (h != NULL)
	{
		if (tTd(64, 10))
			sm_dprintf("Replace default header %s value with %s\n",
				   h->h_field, mh_value);
		if (MilterLogLevel > 8)
			sm_syslog(LOG_INFO, e->e_id,
				  "Milter change: default header %s value with %s",
				  h->h_field, mh_value);
		if (bitset(SMFIP_HDR_LEADSPC, m->mf_pflags))
			h->h_value = mh_value;
		else
		{
			h->h_value = addleadingspace(mh_value, e->e_rpool);
			SM_FREE(mh_value);
		}
		h->h_flags |= H_USER;
	}
	else
	{
		if (tTd(64, 10))
			sm_dprintf("Add %s: %s\n", response, mh_value);
		if (MilterLogLevel > 8)
			sm_syslog(LOG_INFO, e->e_id,
				  "Milter add: header: %s: %s",
				  response, mh_value);
		addheader(newstr(response), mh_value, H_USER, e,
			!bitset(SMFIP_HDR_LEADSPC, m->mf_pflags));
		SM_FREE(mh_value);
	}
}

/*
**  MILTER_INSHEADER -- Insert the supplied header
**
**	Parameters:
**		m -- current filter.
**		response -- encoded form of header/value.
**		rlen -- length of response.
**		e -- current envelope.
**
**	Returns:
**		none
**
**	Notes:
**		Unlike milter_addheader(), this does not attempt to determine
**		if the header already exists in the envelope, even a
**		deleted version.  It just blindly inserts.
*/

static void
milter_insheader(m, response, rlen, e)
	struct milter *m;
	char *response;
	ssize_t rlen;
	ENVELOPE *e;
{
	mi_int32 idx, i;
	int mh_v_len;
	char *field, *val, *mh_value;

	if (tTd(64, 10))
		sm_dprintf("milter_insheader: ");

	/* sanity checks */
	if (response == NULL)
	{
		if (tTd(64, 10))
			sm_dprintf("NULL response\n");
		return;
	}

	if (rlen < 2 || strlen(response) + 1 >= (size_t) rlen)
	{
		if (tTd(64, 10))
			sm_dprintf("didn't follow protocol (total len)\n");
		return;
	}

	/* decode */
	(void) memcpy((char *) &i, response, MILTER_LEN_BYTES);
	idx = ntohl(i);
	field = response + MILTER_LEN_BYTES;
	val = field + strlen(field) + 1;

	/* another sanity check */
	if (MILTER_LEN_BYTES + strlen(field) + 1 +
	    strlen(val) + 1 != (size_t) rlen)
	{
		if (tTd(64, 10))
			sm_dprintf("didn't follow protocol (part len)\n");
		return;
	}

	if (*field == '\0')
	{
		if (tTd(64, 10))
			sm_dprintf("empty field name\n");
		return;
	}

	/* add to e_msgsize */
	e->e_msgsize += strlen(response) + 2 + strlen(val);

	if (tTd(64, 10))
		sm_dprintf("Insert (%d) %s: %s\n", idx, field, val);
	if (MilterLogLevel > 8)
		sm_syslog(LOG_INFO, e->e_id,
			  "Milter insert (%d): header: %s: %s",
			  idx, field, val);
	mh_v_len = 0;
	mh_value = quote_internal_chars(val, NULL, &mh_v_len);
	insheader(idx, newstr(field), mh_value, H_USER, e,
		!bitset(SMFIP_HDR_LEADSPC, m->mf_pflags));
	SM_FREE(mh_value);
}

/*
**  MILTER_CHANGEHEADER -- Change the supplied header in the message
**
**	Parameters:
**		m -- current filter.
**		response -- encoded form of header/index/value.
**		rlen -- length of response.
**		e -- current envelope.
**
**	Returns:
**		none
*/

static void
milter_changeheader(m, response, rlen, e)
	struct milter *m;
	char *response;
	ssize_t rlen;
	ENVELOPE *e;
{
	mi_int32 i, index;
	int mh_v_len;
	char *field, *val, *mh_value;
	HDR *h, *sysheader;

	if (tTd(64, 10))
		sm_dprintf("milter_changeheader: ");

	/* sanity checks */
	if (response == NULL)
	{
		if (tTd(64, 10))
			sm_dprintf("NULL response\n");
		return;
	}

	if (rlen < 2 || strlen(response) + 1 >= (size_t) rlen)
	{
		if (tTd(64, 10))
			sm_dprintf("didn't follow protocol (total len)\n");
		return;
	}

	/* Find separating NUL */
	(void) memcpy((char *) &i, response, MILTER_LEN_BYTES);
	index = ntohl(i);
	field = response + MILTER_LEN_BYTES;
	val = field + strlen(field) + 1;

	/* another sanity check */
	if (MILTER_LEN_BYTES + strlen(field) + 1 +
	    strlen(val) + 1 != (size_t) rlen)
	{
		if (tTd(64, 10))
			sm_dprintf("didn't follow protocol (part len)\n");
		return;
	}

	if (*field == '\0')
	{
		if (tTd(64, 10))
			sm_dprintf("empty field name\n");
		return;
	}

	mh_v_len = 0;
	mh_value = quote_internal_chars(val, NULL, &mh_v_len);

	sysheader = NULL;
	for (h = e->e_header; h != NULL; h = h->h_link)
	{
		if (sm_strcasecmp(h->h_field, field) == 0)
		{
			if (bitset(H_USER, h->h_flags) && --index <= 0)
			{
				sysheader = NULL;
				break;
			}
			else if (!bitset(H_USER, h->h_flags) &&
				 !bitset(H_TRACE, h->h_flags))
			{
				/*
				**  DRUMS msg-fmt draft says can only have
				**  multiple occurences of trace fields,
				**  so make sure we replace any non-trace,
				**  non-user field.
				*/

				sysheader = h;
			}
		}
	}

	/* if not found as user-provided header at index, use sysheader */
	if (h == NULL)
		h = sysheader;

	if (h == NULL)
	{
		if (*val == '\0')
		{
			if (tTd(64, 10))
				sm_dprintf("Delete (noop) %s\n", field);
			if (MilterLogLevel > 8)
				sm_syslog(LOG_INFO, e->e_id,
					"Milter delete (noop): header: %s"
					, field);
		}
		else
		{
			/* treat modify value with no existing header as add */
			if (tTd(64, 10))
				sm_dprintf("Add %s: %s\n", field, mh_value);
			if (MilterLogLevel > 8)
				sm_syslog(LOG_INFO, e->e_id,
					"Milter change (add): header: %s: %s"
					, field, mh_value);
			addheader(newstr(field), mh_value, H_USER, e,
				!bitset(SMFIP_HDR_LEADSPC, m->mf_pflags));
		}
		return;
	}

	if (tTd(64, 10))
	{
		if (*val == '\0')
		{
			sm_dprintf("Delete%s %s:%s\n",
				   h == sysheader ? " (default header)" : "",
				   field,
				   h->h_value == NULL ? "<NULL>" : h->h_value);
		}
		else
		{
			sm_dprintf("Change%s %s: from %s to %s\n",
				   h == sysheader ? " (default header)" : "",
				   field,
				   h->h_value == NULL ? "<NULL>" : h->h_value,
				   mh_value);
		}
	}

	if (MilterLogLevel > 8)
	{
		if (*val == '\0')
		{
			sm_syslog(LOG_INFO, e->e_id,
				  "Milter delete: header%s %s:%s",
				  h == sysheader ? " (default header)" : "",
				  field,
				  h->h_value == NULL ? "<NULL>" : h->h_value);
		}
		else
		{
			sm_syslog(LOG_INFO, e->e_id,
				  "Milter change: header%s %s: from %s to %s",
				  h == sysheader ? " (default header)" : "",
				  field,
				  h->h_value == NULL ? "<NULL>" : h->h_value,
				  mh_value);
		}
	}

	if (h != sysheader && h->h_value != NULL)
	{
		size_t l;

		l = strlen(h->h_value);
		if (l > e->e_msgsize)
			e->e_msgsize = 0;
		else
			e->e_msgsize -= l;
		/* rpool, don't free: sm_free(h->h_value); XXX */
	}

	if (*val == '\0')
	{
		/* Remove "Field: " from message size */
		if (h != sysheader)
		{
			size_t l;

			l = strlen(h->h_field) + 2;
			if (l > e->e_msgsize)
				e->e_msgsize = 0;
			else
				e->e_msgsize -= l;
		}
		h->h_value = NULL;
		SM_FREE(mh_value);
	}
	else
	{
		if (bitset(SMFIP_HDR_LEADSPC, m->mf_pflags))
			h->h_value = mh_value;
		else
		{
			h->h_value = addleadingspace(mh_value, e->e_rpool);
			SM_FREE(mh_value);
		}
		h->h_flags |= H_USER;
		e->e_msgsize += strlen(h->h_value);
	}
}

/*
**  MILTER_SPLIT_RESPONSE -- Split response into fields.
**
**	Parameters:
**		response -- encoded repsonse.
**		rlen -- length of response.
**		pargc -- number of arguments (ouput)
**
**	Returns:
**		array of pointers to the individual strings
*/

static char **milter_split_response __P((char *, ssize_t, int *));

static char **
milter_split_response(response, rlen, pargc)
	char *response;
	ssize_t rlen;
	int *pargc;
{
	char **s;
	size_t i;
	int elem, nelem;

	SM_ASSERT(response != NULL);
	SM_ASSERT(pargc != NULL);
	*pargc = 0;
	if (rlen < 2 || strlen(response) >= (size_t) rlen)
	{
		if (tTd(64, 10))
			sm_dprintf("didn't follow protocol (total len %d != rlen %d)\n",
				   (int) strlen(response), (int) (rlen - 1));
		return NULL;
	}

	nelem = 0;
	for (i = 0; i < rlen; i++)
	{
		if (response[i] == '\0')
			++nelem;
	}
	if (nelem == 0)
		return NULL;

	/* last entry is only for the name */
	s = (char **)malloc((nelem + 1) * (sizeof(*s)));
	if (s == NULL)
		return NULL;
	s[0] = response;
	for (i = 0, elem = 0; i < rlen && elem < nelem; i++)
	{
		if (response[i] == '\0')
		{
			++elem;
			if (i + 1 >= rlen)
				s[elem] = NULL;
			else
				s[elem] = &(response[i + 1]);
		}
	}
	*pargc = nelem;

	if (tTd(64, 10))
	{
		for (elem = 0; elem < nelem; elem++)
			sm_dprintf("argv[%d]=\"%s\"\n", elem, s[elem]);
	}

	/* overwrite last entry (already done above, just paranoia) */
	s[elem] = NULL;
	return s;
}

/*
**  MILTER_CHGFROM -- Change the envelope sender address
**
**	Parameters:
**		response -- encoded form of recipient address.
**		rlen -- length of response.
**		e -- current envelope.
**
**	Returns:
**		none
*/

static void
milter_chgfrom(response, rlen, e)
	char *response;
	ssize_t rlen;
	ENVELOPE *e;
{
	int olderrors, argc;
	char **argv;

	if (tTd(64, 10))
		sm_dprintf("milter_chgfrom: ");

	/* sanity checks */
	if (response == NULL)
	{
		if (tTd(64, 10))
			sm_dprintf("NULL response\n");
		return;
	}

	if (*response == '\0' ||
	    strlen(response) + 1 > (size_t) rlen)
	{
		if (tTd(64, 10))
			sm_dprintf("didn't follow protocol (total len %d != rlen %d)\n",
				   (int) strlen(response), (int) (rlen - 1));
		return;
	}

	if (tTd(64, 10))
		sm_dprintf("%s\n", response);
	if (MilterLogLevel > 8)
		sm_syslog(LOG_INFO, e->e_id, "Milter chgfrom: %s", response);
	argv = milter_split_response(response, rlen, &argc);
	if (argc < 1 || argc > 2)
	{
		if (tTd(64, 10))
			sm_dprintf("didn't follow protocol argc=%d\n", argc);
		return;
	}

	olderrors = Errors;
	setsender(argv[0], e, NULL, '\0', false);
	if (argc == 2)
	{
		reset_mail_esmtp_args(e);

		/*
		**  need "features" here: how to get those? via e?
		**  "fake" it for now: allow everything.
		*/

		parse_esmtp_args(e, NULL, argv[0], argv[1], "MAIL", NULL,
				mail_esmtp_args);
	}
	Errors = olderrors;
	return;
}

/*
**  MILTER_ADDRCPT_PAR -- Add the supplied recipient to the message
**
**	Parameters:
**		response -- encoded form of recipient address.
**		rlen -- length of response.
**		e -- current envelope.
**
**	Returns:
**		none
*/

static void
milter_addrcpt_par(response, rlen, e)
	char *response;
	ssize_t rlen;
	ENVELOPE *e;
{
	int olderrors, argc;
	char *delimptr;
	char **argv;
	ADDRESS *a;

	if (tTd(64, 10))
		sm_dprintf("milter_addrcpt_par: ");

	/* sanity checks */
	if (response == NULL)
	{
		if (tTd(64, 10))
			sm_dprintf("NULL response\n");
		return;
	}

	if (tTd(64, 10))
		sm_dprintf("%s\n", response);
	if (MilterLogLevel > 8)
		sm_syslog(LOG_INFO, e->e_id, "Milter add: rcpt: %s", response);

	argv = milter_split_response(response, rlen, &argc);
	if (argc < 1 || argc > 2)
	{
		if (tTd(64, 10))
			sm_dprintf("didn't follow protocol argc=%d\n", argc);
		return;
	}
	olderrors = Errors;

	/* how to set ESMTP arguments? */
	a = parseaddr(argv[0], NULLADDR, RF_COPYALL, ' ', &delimptr, e, true);

	if (a != NULL && olderrors == Errors)
	{
		parse_esmtp_args(e, a, argv[0], argv[1], "RCPT", NULL,
				rcpt_esmtp_args);
		if (olderrors == Errors)
			a = recipient(a, &e->e_sendqueue, 0, e);
		else
			sm_dprintf("olderrors=%d, Errors=%d\n",
				olderrors, Errors);
	}
	else
	{
		sm_dprintf("a=%p, olderrors=%d, Errors=%d\n",
			a, olderrors, Errors);
	}

	Errors = olderrors;
	return;
}

/*
**  MILTER_ADDRCPT -- Add the supplied recipient to the message
**
**	Parameters:
**		response -- encoded form of recipient address.
**		rlen -- length of response.
**		e -- current envelope.
**
**	Returns:
**		none
*/

static void
milter_addrcpt(response, rlen, e)
	char *response;
	ssize_t rlen;
	ENVELOPE *e;
{
	int olderrors;

	if (tTd(64, 10))
		sm_dprintf("milter_addrcpt: ");

	/* sanity checks */
	if (response == NULL)
	{
		if (tTd(64, 10))
			sm_dprintf("NULL response\n");
		return;
	}

	if (*response == '\0' ||
	    strlen(response) + 1 != (size_t) rlen)
	{
		if (tTd(64, 10))
			sm_dprintf("didn't follow protocol (total len %d != rlen %d)\n",
				   (int) strlen(response), (int) (rlen - 1));
		return;
	}

	if (tTd(64, 10))
		sm_dprintf("%s\n", response);
	if (MilterLogLevel > 8)
		sm_syslog(LOG_INFO, e->e_id, "Milter add: rcpt: %s", response);
	olderrors = Errors;
	(void) sendtolist(response, NULLADDR, &e->e_sendqueue, 0, e);
	Errors = olderrors;
	return;
}

/*
**  MILTER_DELRCPT -- Delete the supplied recipient from the message
**
**	Parameters:
**		response -- encoded form of recipient address.
**		rlen -- length of response.
**		e -- current envelope.
**
**	Returns:
**		none
*/

static void
milter_delrcpt(response, rlen, e)
	char *response;
	ssize_t rlen;
	ENVELOPE *e;
{
	if (tTd(64, 10))
		sm_dprintf("milter_delrcpt: ");

	/* sanity checks */
	if (response == NULL)
	{
		if (tTd(64, 10))
			sm_dprintf("NULL response\n");
		return;
	}

	if (*response == '\0' ||
	    strlen(response) + 1 != (size_t) rlen)
	{
		if (tTd(64, 10))
			sm_dprintf("didn't follow protocol (total len %d != rlen %d)\n",
				   (int) strlen(response), (int) (rlen - 1));
		return;
	}

	if (tTd(64, 10))
		sm_dprintf("%s\n", response);
	if (MilterLogLevel > 8)
		sm_syslog(LOG_INFO, e->e_id, "Milter delete: rcpt %s",
			  response);
	(void) removefromlist(response, &e->e_sendqueue, e);
	return;
}

/*
**  MILTER_REPLBODY -- Replace the current data file with new body
**
**	Parameters:
**		response -- encoded form of new body.
**		rlen -- length of response.
**		newfilter -- if first time called by a new filter
**		e -- current envelope.
**
**	Returns:
**		0 upon success, -1 upon failure
*/

static int
milter_replbody(response, rlen, newfilter, e)
	char *response;
	ssize_t rlen;
	bool newfilter;
	ENVELOPE *e;
{
	static char prevchar;
	int i;

	if (tTd(64, 10))
		sm_dprintf("milter_replbody\n");

	/* If a new filter, reset previous character and truncate data file */
	if (newfilter)
	{
		off_t prevsize;
		char dfname[MAXPATHLEN];

		(void) sm_strlcpy(dfname, queuename(e, DATAFL_LETTER),
				  sizeof(dfname));

		/* Reset prevchar */
		prevchar = '\0';

		/* Get the current data file information */
		prevsize = sm_io_getinfo(e->e_dfp, SM_IO_WHAT_SIZE, NULL);
		if (prevsize < 0)
			prevsize = 0;

		/* truncate current data file */
		if (sm_io_getinfo(e->e_dfp, SM_IO_WHAT_ISTYPE, BF_FILE_TYPE))
		{
			if (sm_io_setinfo(e->e_dfp, SM_BF_TRUNCATE, NULL) < 0)
			{
				MILTER_DF_ERROR("milter_replbody: sm_io truncate %s: %s");
				return -1;
			}
		}
		else
		{
			int err;

			err = sm_io_error(e->e_dfp);
			(void) sm_io_flush(e->e_dfp, SM_TIME_DEFAULT);

			/*
			**  Clear error if tried to fflush()
			**  a read-only file pointer and
			**  there wasn't a previous error.
			*/

			if (err == 0)
				sm_io_clearerr(e->e_dfp);

			/* errno is set implicitly by fseek() before return */
			err = sm_io_seek(e->e_dfp, SM_TIME_DEFAULT,
					 0, SEEK_SET);
			if (err < 0)
			{
				MILTER_DF_ERROR("milter_replbody: sm_io_seek %s: %s");
				return -1;
			}
# if NOFTRUNCATE
			/* XXX: Not much we can do except rewind it */
			errno = EINVAL;
			MILTER_DF_ERROR("milter_replbody: ftruncate not available on this platform (%s:%s)");
			return -1;
# else /* NOFTRUNCATE */
			err = ftruncate(sm_io_getinfo(e->e_dfp,
						      SM_IO_WHAT_FD, NULL),
					0);
			if (err < 0)
			{
				MILTER_DF_ERROR("milter_replbody: sm_io ftruncate %s: %s");
				return -1;
			}
# endif /* NOFTRUNCATE */
		}

		if (prevsize > e->e_msgsize)
			e->e_msgsize = 0;
		else
			e->e_msgsize -= prevsize;
	}

	if (newfilter && MilterLogLevel > 8)
		sm_syslog(LOG_INFO, e->e_id, "Milter message: body replaced");

	if (response == NULL)
	{
		/* Flush the buffered '\r' */
		if (prevchar == '\r')
		{
			(void) sm_io_putc(e->e_dfp, SM_TIME_DEFAULT, prevchar);
			e->e_msgsize++;
		}
		return 0;
	}

	for (i = 0; i < rlen; i++)
	{
		/* Buffered char from last chunk */
		if (i == 0 && prevchar == '\r')
		{
			/* Not CRLF, output prevchar */
			if (response[i] != '\n')
			{
				(void) sm_io_putc(e->e_dfp, SM_TIME_DEFAULT,
						  prevchar);
				e->e_msgsize++;
			}
			prevchar = '\0';
		}

		/* Turn CRLF into LF */
		if (response[i] == '\r')
		{
			/* check if at end of chunk */
			if (i + 1 < rlen)
			{
				/* If LF, strip CR */
				if (response[i + 1] == '\n')
					i++;
			}
			else
			{
				/* check next chunk */
				prevchar = '\r';
				continue;
			}
		}
		(void) sm_io_putc(e->e_dfp, SM_TIME_DEFAULT, response[i]);
		e->e_msgsize++;
	}
	return 0;
}

/*
**  MTA callouts
*/

/*
**  MILTER_INIT -- open and negotiate with all of the filters
**
**	Parameters:
**		e -- current envelope.
**		state -- return state from response.
**		milters -- milters structure.
**
**	Returns:
**		true iff at least one filter is active
*/

/* ARGSUSED */
bool
milter_init(e, state, milters)
	ENVELOPE *e;
	char *state;
	milters_T *milters;
{
	int i;

	if (tTd(64, 10))
		sm_dprintf("milter_init\n");

	memset(milters, '\0', sizeof(*milters));
	*state = SMFIR_CONTINUE;
	if (InputFilters[0] == NULL)
	{
		if (MilterLogLevel > 10)
			sm_syslog(LOG_INFO, e->e_id,
				  "Milter: no active filter");
		return false;
	}

	for (i = 0; InputFilters[i] != NULL; i++)
	{
		struct milter *m = InputFilters[i];

		m->mf_sock = milter_open(m, false, e);
		if (m->mf_state == SMFS_ERROR)
		{
			MILTER_CHECK_ERROR(true, continue);
			break;
		}

		if (m->mf_sock < 0 ||
		    milter_negotiate(m, e, milters) < 0 ||
		    m->mf_state == SMFS_ERROR)
		{
			if (tTd(64, 5))
				sm_dprintf("milter_init(%s): failed to %s\n",
					   m->mf_name,
					   m->mf_sock < 0 ? "open" :
							    "negotiate");
			if (MilterLogLevel > 0)
				sm_syslog(LOG_ERR, e->e_id,
					  "Milter (%s): init failed to %s",
					  m->mf_name,
					  m->mf_sock < 0 ? "open" :
							   "negotiate");

			/* if negotiation failure, close socket */
			milter_error(m, e);
			MILTER_CHECK_ERROR(true, continue);
			continue;
		}
		if (MilterLogLevel > 9)
			sm_syslog(LOG_INFO, e->e_id,
				  "Milter (%s): init success to %s",
				  m->mf_name,
				  m->mf_sock < 0 ? "open" : "negotiate");
	}

	/*
	**  If something temp/perm failed with one of the filters,
	**  we won't be using any of them, so clear any existing
	**  connections.
	*/

	if (*state != SMFIR_CONTINUE)
		milter_quit(e);

	return true;
}

/*
**  MILTER_CONNECT -- send connection info to milter filters
**
**	Parameters:
**		hostname -- hostname of remote machine.
**		addr -- address of remote machine.
**		e -- current envelope.
**		state -- return state from response.
**
**	Returns:
**		response string (may be NULL)
*/

char *
milter_connect(hostname, addr, e, state)
	char *hostname;
	SOCKADDR addr;
	ENVELOPE *e;
	char *state;
{
	char family;
	unsigned short port;
	char *buf, *bp;
	char *response;
	char *sockinfo = NULL;
	ssize_t s;
# if NETINET6
	char buf6[INET6_ADDRSTRLEN];
# endif /* NETINET6 */

	if (tTd(64, 10))
		sm_dprintf("milter_connect(%s)\n", hostname);
	if (MilterLogLevel > 9)
		sm_syslog(LOG_INFO, e->e_id, "Milter: connect to filters");

	/* gather data */
	switch (addr.sa.sa_family)
	{
# if NETUNIX
	  case AF_UNIX:
		family = SMFIA_UNIX;
		port = htons(0);
		sockinfo = addr.sunix.sun_path;
		break;
# endif /* NETUNIX */

# if NETINET
	  case AF_INET:
		family = SMFIA_INET;
		port = addr.sin.sin_port;
		sockinfo = (char *) inet_ntoa(addr.sin.sin_addr);
		break;
# endif /* NETINET */

# if NETINET6
	  case AF_INET6:
		if (IN6_IS_ADDR_V4MAPPED(&addr.sin6.sin6_addr))
			family = SMFIA_INET;
		else
			family = SMFIA_INET6;
		port = addr.sin6.sin6_port;
		sockinfo = anynet_ntop(&addr.sin6.sin6_addr, buf6,
				       sizeof(buf6));
		if (sockinfo == NULL)
			sockinfo = "";
		break;
# endif /* NETINET6 */

	  default:
		family = SMFIA_UNKNOWN;
		break;
	}

	s = strlen(hostname) + 1 + sizeof(family);
	if (family != SMFIA_UNKNOWN)
		s += sizeof(port) + strlen(sockinfo) + 1;

	buf = (char *) xalloc(s);
	bp = buf;

	/* put together data */
	(void) memcpy(bp, hostname, strlen(hostname));
	bp += strlen(hostname);
	*bp++ = '\0';
	(void) memcpy(bp, &family, sizeof(family));
	bp += sizeof(family);
	if (family != SMFIA_UNKNOWN)
	{
		(void) memcpy(bp, &port, sizeof(port));
		bp += sizeof(port);

		/* include trailing '\0' */
		(void) memcpy(bp, sockinfo, strlen(sockinfo) + 1);
	}

	response = milter_command(SMFIC_CONNECT, buf, s, SMFIM_CONNECT,
				e, state, "connect", false);
	sm_free(buf); /* XXX */

	/*
	**  If this message connection is done for,
	**  close the filters.
	*/

	if (*state != SMFIR_CONTINUE)
	{
		if (MilterLogLevel > 9)
			sm_syslog(LOG_INFO, e->e_id, "Milter: connect, ending");
		milter_quit(e);
	}
	else
		milter_per_connection_check(e);

	/*
	**  SMFIR_REPLYCODE can't work with connect due to
	**  the requirements of SMTP.  Therefore, ignore the
	**  reply code text but keep the state it would reflect.
	*/

	if (*state == SMFIR_REPLYCODE)
	{
		if (response != NULL &&
		    *response == '4')
		{
			if (strncmp(response, "421 ", 4) == 0)
				*state = SMFIR_SHUTDOWN;
			else
				*state = SMFIR_TEMPFAIL;
		}
		else
			*state = SMFIR_REJECT;
		if (response != NULL)
		{
			sm_free(response); /* XXX */
			response = NULL;
		}
	}
	return response;
}

/*
**  MILTER_HELO -- send SMTP HELO/EHLO command info to milter filters
**
**	Parameters:
**		helo -- argument to SMTP HELO/EHLO command.
**		e -- current envelope.
**		state -- return state from response.
**
**	Returns:
**		response string (may be NULL)
*/

char *
milter_helo(helo, e, state)
	char *helo;
	ENVELOPE *e;
	char *state;
{
	int i;
	char *response;

	if (tTd(64, 10))
		sm_dprintf("milter_helo(%s)\n", helo);

	/* HELO/EHLO can come at any point */
	for (i = 0; InputFilters[i] != NULL; i++)
	{
		struct milter *m = InputFilters[i];

		switch (m->mf_state)
		{
		  case SMFS_INMSG:
			/* abort in message filters */
			milter_abort_filter(m, e);
			/* FALLTHROUGH */

		  case SMFS_DONE:
			/* reset done filters */
			m->mf_state = SMFS_OPEN;
			break;
		}
	}

	response = milter_command(SMFIC_HELO, helo, strlen(helo) + 1,
				  SMFIM_HELO, e, state, "helo", false);
	milter_per_connection_check(e);
	return response;
}

/*
**  MILTER_ENVFROM -- send SMTP MAIL command info to milter filters
**
**	Parameters:
**		args -- SMTP MAIL command args (args[0] == sender).
**		e -- current envelope.
**		state -- return state from response.
**
**	Returns:
**		response string (may be NULL)
*/

char *
milter_envfrom(args, e, state)
	char **args;
	ENVELOPE *e;
	char *state;
{
	int i;
	char *buf, *bp;
	char *response;
	ssize_t s;

	if (tTd(64, 10))
	{
		sm_dprintf("milter_envfrom:");
		for (i = 0; args[i] != NULL; i++)
			sm_dprintf(" %s", args[i]);
		sm_dprintf("\n");
	}

	/* sanity check */
	if (args[0] == NULL)
	{
		*state = SMFIR_REJECT;
		if (MilterLogLevel > 10)
			sm_syslog(LOG_INFO, e->e_id,
				  "Milter: reject, no sender");
		return NULL;
	}

	/* new message, so ... */
	for (i = 0; InputFilters[i] != NULL; i++)
	{
		struct milter *m = InputFilters[i];

		switch (m->mf_state)
		{
		  case SMFS_INMSG:
			/* abort in message filters */
			milter_abort_filter(m, e);
			/* FALLTHROUGH */

		  case SMFS_DONE:
			/* reset done filters */
			m->mf_state = SMFS_OPEN;
			break;
		}
	}

	/* put together data */
	s = 0;
	for (i = 0; args[i] != NULL; i++)
		s += strlen(args[i]) + 1;

	if (s < 0)
	{
		*state = SMFIR_TEMPFAIL;
		return NULL;
	}

	buf = (char *) xalloc(s);
	bp = buf;
	for (i = 0; args[i] != NULL; i++)
	{
		(void) sm_strlcpy(bp, args[i], s - (bp - buf));
		bp += strlen(bp) + 1;
	}

	if (MilterLogLevel > 14)
		sm_syslog(LOG_INFO, e->e_id, "Milter: sender: %s", buf);

	/* send it over */
	response = milter_command(SMFIC_MAIL, buf, s, SMFIM_ENVFROM,
				e, state, "mail", false);
	sm_free(buf); /* XXX */

	/*
	**  If filter rejects/discards a per message command,
	**  abort the other filters since we are done with the
	**  current message.
	*/

	MILTER_CHECK_DONE_MSG();
	if (MilterLogLevel > 10 && *state == SMFIR_REJECT)
		sm_syslog(LOG_INFO, e->e_id, "Milter: reject, sender");
	return response;
}

/*
**  MILTER_ENVRCPT -- send SMTP RCPT command info to milter filters
**
**	Parameters:
**		args -- SMTP MAIL command args (args[0] == recipient).
**		e -- current envelope.
**		state -- return state from response.
**		rcpt_error -- does RCPT have an error?
**
**	Returns:
**		response string (may be NULL)
*/

char *
milter_envrcpt(args, e, state, rcpt_error)
	char **args;
	ENVELOPE *e;
	char *state;
	bool rcpt_error;
{
	int i;
	char *buf, *bp;
	char *response;
	ssize_t s;

	if (tTd(64, 10))
	{
		sm_dprintf("milter_envrcpt:");
		for (i = 0; args[i] != NULL; i++)
			sm_dprintf(" %s", args[i]);
		sm_dprintf("\n");
	}

	/* sanity check */
	if (args[0] == NULL)
	{
		*state = SMFIR_REJECT;
		if (MilterLogLevel > 10)
			sm_syslog(LOG_INFO, e->e_id, "Milter: reject, no rcpt");
		return NULL;
	}

	/* put together data */
	s = 0;
	for (i = 0; args[i] != NULL; i++)
		s += strlen(args[i]) + 1;

	if (s < 0)
	{
		*state = SMFIR_TEMPFAIL;
		return NULL;
	}

	buf = (char *) xalloc(s);
	bp = buf;
	for (i = 0; args[i] != NULL; i++)
	{
		(void) sm_strlcpy(bp, args[i], s - (bp - buf));
		bp += strlen(bp) + 1;
	}

	if (MilterLogLevel > 14)
		sm_syslog(LOG_INFO, e->e_id, "Milter: rcpts: %s", buf);

	/* send it over */
	response = milter_command(SMFIC_RCPT, buf, s, SMFIM_ENVRCPT,
				e, state, "rcpt", rcpt_error);
	sm_free(buf); /* XXX */
	return response;
}

/*
**  MILTER_DATA_CMD -- send SMTP DATA command info to milter filters
**
**	Parameters:
**		e -- current envelope.
**		state -- return state from response.
**
**	Returns:
**		response string (may be NULL)
*/

char *
milter_data_cmd(e, state)
	ENVELOPE *e;
	char *state;
{
	if (tTd(64, 10))
		sm_dprintf("milter_data_cmd\n");

	/* send it over */
	return milter_command(SMFIC_DATA, NULL, 0, SMFIM_DATA,
				e, state, "data", false);
}

/*
**  MILTER_DATA -- send message headers/body and gather final message results
**
**	Parameters:
**		e -- current envelope.
**		state -- return state from response.
**
**	Returns:
**		response string (may be NULL)
**
**	Side effects:
**		- Uses e->e_dfp for access to the body
**		- Can call the various milter action routines to
**		  modify the envelope or message.
*/

/* flow through code using continue; don't wrap in do {} while */
# define MILTER_CHECK_RESULTS() \
	if (m->mf_state == SMFS_ERROR && *state == SMFIR_CONTINUE) \
	{ \
			MILTER_SET_STATE;	\
	} \
	if (*state == SMFIR_ACCEPT || \
	    m->mf_state == SMFS_DONE || \
	    m->mf_state == SMFS_ERROR) \
	{ \
		if (m->mf_state != SMFS_ERROR) \
			m->mf_state = SMFS_DONE; \
		continue;	/* to next filter */ \
	} \
	if (*state != SMFIR_CONTINUE) \
	{ \
		m->mf_state = SMFS_DONE; \
		goto finishup; \
	}

char *
milter_data(e, state)
	ENVELOPE *e;
	char *state;
{
	bool replbody = false;		/* milter_replbody() called? */
	bool replfailed = false;	/* milter_replbody() failed? */
	bool rewind = false;		/* rewind data file? */
	bool dfopen = false;		/* data file open for writing? */
	bool newfilter;			/* reset on each new filter */
	char rcmd;
	int i;
	int save_errno;
	char *response = NULL;
	time_t eomsent;
	ssize_t rlen;

	if (tTd(64, 10))
		sm_dprintf("milter_data\n");

	*state = SMFIR_CONTINUE;

	/*
	**  XXX: Should actually send body chunks to each filter
	**  a chunk at a time instead of sending the whole body to
	**  each filter in turn.  However, only if the filters don't
	**  change the body.
	*/

	for (i = 0; InputFilters[i] != NULL; i++)
	{
		int idx;
		char **macros;
		struct milter *m = InputFilters[i];

		if (*state != SMFIR_CONTINUE &&
		    *state != SMFIR_ACCEPT)
		{
			/*
			**  A previous filter has dealt with the message,
			**  safe to stop processing the filters.
			*/

			break;
		}

		/* Now reset state for later evaluation */
		*state = SMFIR_CONTINUE;
		newfilter = true;

		/* previous problem? */
		if (m->mf_state == SMFS_ERROR)
		{
			MILTER_CHECK_ERROR(false, continue);
			break;
		}

		/* sanity checks */
		if (m->mf_sock < 0 ||
		    (m->mf_state != SMFS_OPEN && m->mf_state != SMFS_INMSG))
			continue;

		m->mf_state = SMFS_INMSG;

		/* check if filter wants the headers */
		if (!bitset(SMFIP_NOHDRS, m->mf_pflags))
		{
			response = milter_headers(m, e, state);
			MILTER_CHECK_RESULTS();
		}

		/* check if filter wants EOH */
		if (!bitset(SMFIP_NOEOH, m->mf_pflags))
		{
			if (tTd(64, 10))
				sm_dprintf("milter_data: eoh\n");

			if ((m->mf_lflags & MI_LFLAGS_SYM(SMFIM_EOH)) != 0)
				idx = m->mf_idx;
			else
				idx = 0;
			SM_ASSERT(idx >= 0 && idx <= MAXFILTERS);
			macros = MilterMacros[SMFIM_EOH][idx];

			if (macros != NULL)
			{
				milter_send_macros(m, macros, SMFIC_EOH, e);
				MILTER_CHECK_RESULTS();
			}

			/* send it over */
			response = milter_send_command(m, SMFIC_EOH, NULL, 0,
						       e, state, "eoh");
			MILTER_CHECK_RESULTS();
		}

		/* check if filter wants the body */
		if (!bitset(SMFIP_NOBODY, m->mf_pflags) &&
		    e->e_dfp != NULL)
		{
			rewind = true;
			response = milter_body(m, e, state);
			MILTER_CHECK_RESULTS();
		}

		if ((m->mf_lflags & MI_LFLAGS_SYM(SMFIM_EOH)) != 0)
			idx = m->mf_idx;
		else
			idx = 0;
		SM_ASSERT(idx >= 0 && idx <= MAXFILTERS);
		macros = MilterMacros[SMFIM_EOM][idx];
		if (macros != NULL)
		{
			milter_send_macros(m, macros, SMFIC_BODYEOB, e);
			MILTER_CHECK_RESULTS();
		}

		/* send the final body chunk */
		(void) milter_write(m, SMFIC_BODYEOB, NULL, 0,
				    m->mf_timeout[SMFTO_WRITE], e, "eom");

		/* Get time EOM sent for timeout */
		eomsent = curtime();

		/* deal with the possibility of multiple responses */
		while (*state == SMFIR_CONTINUE)
		{
			/* Check total timeout from EOM to final ACK/NAK */
			if (m->mf_timeout[SMFTO_EOM] > 0 &&
			    curtime() - eomsent >= m->mf_timeout[SMFTO_EOM])
			{
				if (tTd(64, 5))
					sm_dprintf("milter_data(%s): EOM ACK/NAK timeout\n",
						m->mf_name);
				if (MilterLogLevel > 0)
					sm_syslog(LOG_ERR, e->e_id,
						  "milter_data(%s): EOM ACK/NAK timeout",
						  m->mf_name);
				milter_error(m, e);
				MILTER_CHECK_ERROR(false, break);
				break;
			}

			response = milter_read(m, &rcmd, &rlen,
					       m->mf_timeout[SMFTO_READ], e,
						"eom");
			if (m->mf_state == SMFS_ERROR)
				break;

			if (tTd(64, 10))
				sm_dprintf("milter_data(%s): state %c\n",
					   m->mf_name, (char) rcmd);

			switch (rcmd)
			{
			  case SMFIR_REPLYCODE:
				MILTER_CHECK_REPLYCODE("554 5.7.1 Command rejected");
				if (MilterLogLevel > 12)
					sm_syslog(LOG_INFO, e->e_id, "milter=%s, reject=%s",
						  m->mf_name, response);
				*state = rcmd;
				m->mf_state = SMFS_DONE;
				break;

			  case SMFIR_REJECT: /* log msg at end of function */
				if (MilterLogLevel > 12)
					sm_syslog(LOG_INFO, e->e_id, "milter=%s, reject",
						  m->mf_name);
				*state = rcmd;
				m->mf_state = SMFS_DONE;
				break;

			  case SMFIR_DISCARD:
				if (MilterLogLevel > 12)
					sm_syslog(LOG_INFO, e->e_id, "milter=%s, discard",
						  m->mf_name);
				*state = rcmd;
				m->mf_state = SMFS_DONE;
				break;

			  case SMFIR_TEMPFAIL:
				if (MilterLogLevel > 12)
					sm_syslog(LOG_INFO, e->e_id, "milter=%s, tempfail",
						  m->mf_name);
				*state = rcmd;
				m->mf_state = SMFS_DONE;
				break;

			  case SMFIR_CONTINUE:
			  case SMFIR_ACCEPT:
				/* this filter is done with message */
				if (replfailed)
					*state = SMFIR_TEMPFAIL;
				else
					*state = SMFIR_ACCEPT;
				m->mf_state = SMFS_DONE;
				break;

			  case SMFIR_PROGRESS:
				break;

			  case SMFIR_QUARANTINE:
				if (!bitset(SMFIF_QUARANTINE, m->mf_fflags))
				{
					if (MilterLogLevel > 9)
						sm_syslog(LOG_WARNING, e->e_id,
							  "milter_data(%s): lied about quarantining, honoring request anyway",
							  m->mf_name);
				}
				if (response == NULL)
					response = newstr("");
				if (MilterLogLevel > 3)
					sm_syslog(LOG_INFO, e->e_id,
						  "milter=%s, quarantine=%s",
						  m->mf_name, response);
				e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool,
								 response);
				macdefine(&e->e_macro, A_PERM,
					  macid("{quarantine}"), e->e_quarmsg);
				break;

			  case SMFIR_ADDHEADER:
				if (!bitset(SMFIF_ADDHDRS, m->mf_fflags))
				{
					if (MilterLogLevel > 9)
						sm_syslog(LOG_WARNING, e->e_id,
							  "milter_data(%s): lied about adding headers, honoring request anyway",
							  m->mf_name);
				}
				milter_addheader(m, response, rlen, e);
				break;

			  case SMFIR_INSHEADER:
				if (!bitset(SMFIF_ADDHDRS, m->mf_fflags))
				{
					if (MilterLogLevel > 9)
						sm_syslog(LOG_WARNING, e->e_id,
							  "milter_data(%s): lied about adding headers, honoring request anyway",
							  m->mf_name);
				}
				milter_insheader(m, response, rlen, e);
				break;

			  case SMFIR_CHGHEADER:
				if (!bitset(SMFIF_CHGHDRS, m->mf_fflags))
				{
					if (MilterLogLevel > 9)
						sm_syslog(LOG_WARNING, e->e_id,
							  "milter_data(%s): lied about changing headers, honoring request anyway",
							  m->mf_name);
				}
				milter_changeheader(m, response, rlen, e);
				break;

			  case SMFIR_CHGFROM:
				if (!bitset(SMFIF_CHGFROM, m->mf_fflags))
				{
					if (MilterLogLevel > 9)
						sm_syslog(LOG_WARNING, e->e_id,
							  "milter_data(%s) lied about changing sender, honoring request anyway",
							  m->mf_name);
				}
				milter_chgfrom(response, rlen, e);
				break;

			  case SMFIR_ADDRCPT:
				if (!bitset(SMFIF_ADDRCPT, m->mf_fflags))
				{
					if (MilterLogLevel > 9)
						sm_syslog(LOG_WARNING, e->e_id,
							  "milter_data(%s) lied about adding recipients, honoring request anyway",
							  m->mf_name);
				}
				milter_addrcpt(response, rlen, e);
				break;

			  case SMFIR_ADDRCPT_PAR:
				if (!bitset(SMFIF_ADDRCPT_PAR, m->mf_fflags))
				{
					if (MilterLogLevel > 9)
						sm_syslog(LOG_WARNING, e->e_id,
							  "milter_data(%s) lied about adding recipients with parameters, honoring request anyway",
							  m->mf_name);
				}
				milter_addrcpt_par(response, rlen, e);
				break;

			  case SMFIR_DELRCPT:
				if (!bitset(SMFIF_DELRCPT, m->mf_fflags))
				{
					if (MilterLogLevel > 9)
						sm_syslog(LOG_WARNING, e->e_id,
							  "milter_data(%s): lied about removing recipients, honoring request anyway",
							  m->mf_name);
				}
				milter_delrcpt(response, rlen, e);
				break;

			  case SMFIR_REPLBODY:
				if (!bitset(SMFIF_MODBODY, m->mf_fflags))
				{
					if (MilterLogLevel > 0)
						sm_syslog(LOG_ERR, e->e_id,
							  "milter_data(%s): lied about replacing body, rejecting request and tempfailing message",
							  m->mf_name);
					replfailed = true;
					break;
				}

				/* already failed in attempt */
				if (replfailed)
					break;

				if (!dfopen)
				{
					if (milter_reopen_df(e) < 0)
					{
						replfailed = true;
						break;
					}
					dfopen = true;
					rewind = true;
				}

				if (milter_replbody(response, rlen,
						    newfilter, e) < 0)
					replfailed = true;
				newfilter = false;
				replbody = true;
				break;

			  default:
				/* Invalid response to command */
				if (MilterLogLevel > 0)
					sm_syslog(LOG_ERR, e->e_id,
						  "milter_data(%s): returned bogus response %c",
						  m->mf_name, rcmd);
				milter_error(m, e);
				break;
			}
			if (rcmd != SMFIR_REPLYCODE && response != NULL)
			{
				sm_free(response); /* XXX */
				response = NULL;
			}

			if (m->mf_state == SMFS_ERROR)
				break;
		}

		if (replbody && !replfailed)
		{
			/* flush possible buffered character */
			milter_replbody(NULL, 0, !replbody, e);
			replbody = false;
		}

		if (m->mf_state == SMFS_ERROR)
		{
			MILTER_CHECK_ERROR(false, continue);
			goto finishup;
		}
	}

finishup:
	/* leave things in the expected state if we touched it */
	if (replfailed)
	{
		if (*state == SMFIR_CONTINUE ||
		    *state == SMFIR_ACCEPT)
		{
			*state = SMFIR_TEMPFAIL;
			SM_FREE_CLR(response);
		}

		if (dfopen)
		{
			(void) sm_io_close(e->e_dfp, SM_TIME_DEFAULT);
			e->e_dfp = NULL;
			e->e_flags &= ~EF_HAS_DF;
			dfopen = false;
		}
		rewind = false;
	}

	if ((dfopen && milter_reset_df(e) < 0) ||
	    (rewind && bfrewind(e->e_dfp) < 0))
	{
		save_errno = errno;
		ExitStat = EX_IOERR;

		/*
		**  If filter told us to keep message but we had
		**  an error, we can't really keep it, tempfail it.
		*/

		if (*state == SMFIR_CONTINUE ||
		    *state == SMFIR_ACCEPT)
		{
			*state = SMFIR_TEMPFAIL;
			SM_FREE_CLR(response);
		}

		errno = save_errno;
		syserr("milter_data: %s/%cf%s: read error",
		       qid_printqueue(e->e_qgrp, e->e_qdir),
		       DATAFL_LETTER, e->e_id);
	}

	MILTER_CHECK_DONE_MSG();
	if (MilterLogLevel > 10 && *state == SMFIR_REJECT)
		sm_syslog(LOG_INFO, e->e_id, "Milter: reject, data");
	return response;
}

/*
**  MILTER_UNKNOWN -- send any unrecognized or unimplemented command
**			string to milter filters
**
**	Parameters:
**		smtpcmd -- the string itself.
**		e -- current envelope.
**		state -- return state from response.
**
**
**	Returns:
**		response string (may be NULL)
*/

char *
milter_unknown(smtpcmd, e, state)
	char *smtpcmd;
	ENVELOPE *e;
	char *state;
{
	if (tTd(64, 10))
		sm_dprintf("milter_unknown(%s)\n", smtpcmd);

	return milter_command(SMFIC_UNKNOWN, smtpcmd, strlen(smtpcmd) + 1,
				SMFIM_NOMACROS, e, state, "unknown", false);
}

/*
**  MILTER_QUIT -- informs the filter(s) we are done and closes connection(s)
**
**	Parameters:
**		e -- current envelope.
**
**	Returns:
**		none
*/

void
milter_quit(e)
	ENVELOPE *e;
{
	int i;

	if (tTd(64, 10))
		sm_dprintf("milter_quit(%s)\n", e->e_id);

	for (i = 0; InputFilters[i] != NULL; i++)
		milter_quit_filter(InputFilters[i], e);
}

/*
**  MILTER_ABORT -- informs the filter(s) that we are aborting current message
**
**	Parameters:
**		e -- current envelope.
**
**	Returns:
**		none
*/

void
milter_abort(e)
	ENVELOPE *e;
{
	int i;

	if (tTd(64, 10))
		sm_dprintf("milter_abort\n");

	for (i = 0; InputFilters[i] != NULL; i++)
	{
		struct milter *m = InputFilters[i];

		/* sanity checks */
		if (m->mf_sock < 0 || m->mf_state != SMFS_INMSG)
			continue;

		milter_abort_filter(m, e);
	}
}
#endif /* MILTER */
@


1.7
log
@merge
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2009, 2012, 2013 Sendmail, Inc. and its suppliers.
d13 2
a14 2
SM_RCSID("$MirOS: src/gnu/usr.sbin/sendmail/sendmail/milter.c,v 1.6 2012/12/31 21:02:47 tg Exp $")
SM_RCSID("@@(#)$Id: milter.c,v 8.280 2013/01/16 18:48:36 ca Exp $")
@


1.6
log
@merge sendmail 8.14.6
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2009 Sendmail, Inc. and its suppliers.
d13 2
a14 2
SM_RCSID("$MirOS: src/gnu/usr.sbin/sendmail/sendmail/milter.c,v 1.5 2010/12/19 17:18:27 tg Exp $")
SM_RCSID("@@(#)$Id: milter.c,v 8.279 2012/11/16 20:25:03 ca Exp $")
d2188 1
a2188 1
**		macros -- macros to send for filter smfi_getsymval().
a2331 1

d4052 1
a4052 1
				  SMFIM_EOH, e, state, "helo", false);
@


1.5
log
@merge newer sendmail; fix and correct; reduce upstream diffs; prep for deb
@
text
@d13 2
a14 2
SM_RCSID("$MirOS: src/gnu/usr.sbin/sendmail/sendmail/milter.c,v 1.4 2009/11/18 08:53:39 tg Exp $")
SM_RCSID("@@(#)$Id: milter.c,v 8.277 2009/11/06 00:57:06 ca Exp $")
d46 1
a46 1
static char	*milter_command __P((int, void *, ssize_t, char **,
d83 7
a89 7
static char *MilterConnectMacros[MAXFILTERMACROS + 1];
static char *MilterHeloMacros[MAXFILTERMACROS + 1];
static char *MilterEnvFromMacros[MAXFILTERMACROS + 1];
static char *MilterEnvRcptMacros[MAXFILTERMACROS + 1];
static char *MilterDataMacros[MAXFILTERMACROS + 1];
static char *MilterEOMMacros[MAXFILTERMACROS + 1];
static char *MilterEOHMacros[MAXFILTERMACROS + 1];
d102 10
d133 1
a133 6
	else if (bitnset(SMF_TEMPFAIL, m->mf_flags)) \
		*state = SMFIR_TEMPFAIL; \
	else if (bitnset(SMF_TEMPDROP, m->mf_flags)) \
		*state = SMFIR_SHUTDOWN; \
	else if (bitnset(SMF_REJECT, m->mf_flags)) \
		*state = SMFIR_REJECT; \
d1230 1
d1333 1
d1335 2
d1568 7
a1574 14
# define MO_MACROS_CONNECT		SMFIM_CONNECT
	{ "macros.connect",		MO_MACROS_CONNECT		},
# define MO_MACROS_HELO			SMFIM_HELO
	{ "macros.helo",		MO_MACROS_HELO			},
# define MO_MACROS_ENVFROM		SMFIM_ENVFROM
	{ "macros.envfrom",		MO_MACROS_ENVFROM		},
# define MO_MACROS_ENVRCPT		SMFIM_ENVRCPT
	{ "macros.envrcpt",		MO_MACROS_ENVRCPT		},
# define MO_MACROS_DATA			SMFIM_DATA
	{ "macros.data",		MO_MACROS_DATA			},
# define MO_MACROS_EOM			SMFIM_EOM
	{ "macros.eom",			MO_MACROS_EOM			},
# define MO_MACROS_EOH			SMFIM_EOH
	{ "macros.eoh",			MO_MACROS_EOH			},
d1661 8
a1668 33
	  case MO_MACROS_CONNECT:
		if (macros == NULL)
			macros = MilterConnectMacros;
		/* FALLTHROUGH */

	  case MO_MACROS_HELO:
		if (macros == NULL)
			macros = MilterHeloMacros;
		/* FALLTHROUGH */

	  case MO_MACROS_ENVFROM:
		if (macros == NULL)
			macros = MilterEnvFromMacros;
		/* FALLTHROUGH */

	  case MO_MACROS_ENVRCPT:
		if (macros == NULL)
			macros = MilterEnvRcptMacros;
		/* FALLTHROUGH */

	  case MO_MACROS_EOH:
		if (macros == NULL)
			macros = MilterEOHMacros;
		/* FALLTHROUGH */

	  case MO_MACROS_EOM:
		if (macros == NULL)
			macros = MilterEOMMacros;
		/* FALLTHROUGH */

	  case MO_MACROS_DATA:
		if (macros == NULL)
			macros = MilterDataMacros;
d2169 1
a2169 1
		milter_error(m, e);
d2199 1
a2199 1
milter_command(cmd, data, sz, macros, e, state, where, cmd_error)
d2203 1
a2203 1
	char **macros;
d2235 1
a2235 2
		/* send macros (regardless of whether we send command) */
		if (macros != NULL && macros[0] != NULL)
d2237 12
a2248 2
			milter_send_macros(m, macros, command, e);
			if (m->mf_state == SMFS_ERROR)
d2250 6
a2255 2
				MILTER_CHECK_ERROR(false, continue);
				break;
d2323 9
a2331 33
		  case MO_MACROS_CONNECT:
			if (macros == NULL)
				macros = MilterConnectMacros;
			/* FALLTHROUGH */

		  case MO_MACROS_HELO:
			if (macros == NULL)
				macros = MilterHeloMacros;
			/* FALLTHROUGH */

		  case MO_MACROS_ENVFROM:
			if (macros == NULL)
				macros = MilterEnvFromMacros;
			/* FALLTHROUGH */

		  case MO_MACROS_ENVRCPT:
			if (macros == NULL)
				macros = MilterEnvRcptMacros;
			/* FALLTHROUGH */

		  case MO_MACROS_EOM:
			if (macros == NULL)
				macros = MilterEOMMacros;
			/* FALLTHROUGH */

		  case MO_MACROS_EOH:
			if (macros == NULL)
				macros = MilterEOHMacros;
			/* FALLTHROUGH */

		  case MO_MACROS_DATA:
			if (macros == NULL)
				macros = MilterDataMacros;
d2333 1
d2341 3
d3964 1
a3964 1
	response = milter_command(SMFIC_CONNECT, buf, s, MilterConnectMacros,
d4053 1
a4053 1
				  MilterHeloMacros, e, state, "helo", false);
d4141 1
a4141 1
	response = milter_command(SMFIC_MAIL, buf, s, MilterEnvFromMacros,
d4222 1
a4222 1
	response = milter_command(SMFIC_RCPT, buf, s, MilterEnvRcptMacros,
d4248 2
a4249 2
	return milter_command(SMFIC_DATA, NULL, 0, MilterDataMacros, e, state,
				"data", false);
d4268 1
d4270 4
d4319 2
d4365 8
a4372 1
			if (MilterEOHMacros[0] != NULL)
d4374 1
a4374 2
				milter_send_macros(m, MilterEOHMacros,
					   SMFIC_EOH, e);
d4393 7
a4399 1
		if (MilterEOMMacros[0] != NULL)
d4401 1
a4401 2
			milter_send_macros(m, MilterEOMMacros,
					   SMFIC_BODYEOB, e);
d4727 1
a4727 1
				NULL, e, state, "unknown", false);
@


1.4
log
@fix format strings; discovered at work when finding bogus message IDs
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2006 Sendmail, Inc. and its suppliers.
d13 2
a14 2
SM_RCSID("$MirOS$")
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.269 2007/06/06 17:26:12 ca Exp $")
a517 1
	time_t writestart = (time_t) 0;
d535 6
a540 2
			sm_dprintf("milter_write(%s): length %ld out of range\n",
				m->mf_name, (long) len);
d543 2
a544 2
				  "milter_write(%s): length %ld out of range",
				  m->mf_name, (long) len);
a600 2
	{
		writestart = curtime();
a601 1
	}
d1576 1
a1576 1
# if _FFR_MAXDATASIZE
d1579 1
a1579 1
# endif /* _FFR_MAXDATASIZE */
d1635 1
a1635 1
#if _FFR_MAXDATASIZE
d1637 1
d1639 17
d1657 1
a1657 1
#endif /* _FFR_MAXDATASIZE */
d2433 6
d2554 33
d3038 1
a3038 1
			h->h_value = addleadingspace (mh_value, e->e_rpool);
d3339 1
a3339 1
			h->h_value = addleadingspace (mh_value, e->e_rpool);
d3392 1
a3392 1
	s = (char **)malloc(nelem * (sizeof(*s)));
d3875 1
a3875 1
			/* if negotation failure, close socket */
d4445 1
a4445 1
						"body");
@


1.3
log
@merge and reduce diffs against upstream
@
text
@d13 1
d2432 2
a2433 1
			m->mf_name, ntohl(fvers), ntohl(fflags), ntohl(pflags));
@


1.2
log
@upgrade from sendmail 8.14.1 to 8.14.2 ourselves:
> From donotreply@@lists.sendmail.org Fri Nov  2 02:46:04 2007
> From: Claus Assmann <donotreply@@lists.sendmail.org>
Message-ID: <200711020234.lA22YPul046763@@lists.sendmail.org>
To: sendmail-announce@@sendmail.org
Date: Thu, 1 Nov 2007 19:34:25 -0700 (PDT)
Subject: sendmail 8.14.2 available

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Sendmail, Inc., and the Sendmail Consortium announce the availability
of sendmail 8.14.2 which fixes some problems, e.g.,

- - an important bug in the milter function smfi_chgfrom() which could
  cause the loss of a message body.
- - the handling of queued messages with 8 bit characters in From:
  or To: header which could be "mistaken" for internal control
  characters during a queue run and trigger various consistency checks.
- - the handling of lines longer than MAXLINE-1 characters in certain
  cases.

A complete list of changes can be found in the release notes (see
below).

Please send bug reports and general feedback to one of the addresses
listed at: http://www.sendmail.org/email-addresses.html

The version can be found at

ftp://ftp.sendmail.org/pub/sendmail/sendmail.8.14.2.tar.gz
ftp://ftp.sendmail.org/pub/sendmail/sendmail.8.14.2.tar.gz.sig
ftp://ftp.sendmail.org/pub/sendmail/sendmail.8.14.2.tar.Z
ftp://ftp.sendmail.org/pub/sendmail/sendmail.8.14.2.tar.Z.sig

MD5 signatures:
cf784b9f20c32949ae1f38f3eae29875 sendmail.8.14.2.tar.Z
f788d6986f12a81ac958195b045a529d sendmail.8.14.2.tar.Z.sig
1c1472365344ca8061d6453c43c9a831 sendmail.8.14.2.tar.gz
2ae4b6175a08e8a6cda992db20141d81 sendmail.8.14.2.tar.gz.sig

You either need the first two files or the third and fourth, i.e.,
the gzip'ed version or the compressed version and the corresponding
sig file.  The PGP signature was created using the Sendmail Signing
Key/2007, available on the web site (http://www.sendmail.org/) or
on the public key servers.

Since sendmail 8.11 and later includes hooks to cryptography, the
following information from OpenSSL applies to sendmail as well.

   PLEASE REMEMBER THAT EXPORT/IMPORT AND/OR USE OF STRONG CRYPTOGRAPHY
   SOFTWARE, PROVIDING CRYPTOGRAPHY HOOKS OR EVEN JUST COMMUNICATING
   TECHNICAL DETAILS ABOUT CRYPTOGRAPHY SOFTWARE IS ILLEGAL IN SOME
   PARTS OF THE WORLD.  SO, WHEN YOU IMPORT THIS PACKAGE TO YOUR
   COUNTRY, RE-DISTRIBUTE IT FROM THERE OR EVEN JUST EMAIL TECHNICAL
   SUGGESTIONS OR EVEN SOURCE PATCHES TO THE AUTHOR OR OTHER PEOPLE
   YOU ARE STRONGLY ADVISED TO PAY CLOSE ATTENTION TO ANY EXPORT/IMPORT
   AND/OR USE LAWS WHICH APPLY TO YOU. THE AUTHORS ARE NOT LIABLE FOR
   ANY VIOLATIONS YOU MAKE HERE. SO BE CAREFUL, IT IS YOUR RESPONSIBILITY.


			SENDMAIL RELEASE NOTES
      $Id: RELEASE_NOTES,v 8.1909 2007/10/31 16:04:13 ca Exp $


This listing shows the version of the sendmail binary, the version
of the sendmail configuration files, the date of release, and a
summary of the changes in that release.

8.14.2/8.14.2	2007/11/01
	If a message was queued and it contained 8 bit characters in
		a From: or To: header, then those characters could be
		"mistaken" for internal control characters during a queue
		run and trigger various consistency checks.  Problem
		noted by Neil Rickert of Northern Illinois University.
	If MaxMimeHeaderLength is set to a value greater than 0 (which
		it is by default) then even if the Linelimit parameter
		is 0, sendmail corrupted in the non-transfer-encoding
		case every MAXLINE-1 characters.  Patch from John Gardiner
		Myers of Proofpoint.
	Setting the suboption DeliveryMode for DaemonPortOptions did not
		work in earlier 8.14 versions.
	Note: DeliveryMode=interactive is silently converted to
		background if a milter can reject or delete a recipient.
		Prior to 8.14 this happened only if milter could delete
		recipients.
	ClientRate should trigger when the limit was exceeded (as
		documented), not when it was reached.  Patch from
		John Beck of Sun Microsystems.
	Force a queue run for -qGqueuegroup even if no runners are
		specified (R=0) and forking (F=f) is requested.
	When multiple results are requested for a DNS map lookup
		(-z and -Z), return only those that are relevant for
		the query (not also those in the "additional section".)
	If the message transfer time to sendmail (when acting as server)
		exceeds Timeout.queuewarn or Timeout.queuereturn and
		the message is refused (by a milter), sendmail previously
		created a delivery status notification (DSN).  Patch
		from Doug Heath of The Hertz Corporation.
	A code change in Cyrus-SASL 2.1.22 for sasl_decode64() requires
		the MTA to deal with some input (i.e., "=") itself.
		Problem noted by Eliot Lear.
	sendmail counted a delivery as successful if PIPELINING is
		compiled in but not offered by the server and the
		delivery failed temporarily.  Patch from Werner Wiethege.
	If getting the result of an LDAP query times out then close the
		map so it will be reopened on the next lookup.  This
		should help "failover" configurations that specify more
		than one LDAP server.
	If check_compat returns $#discard then a "savemail panic" could
		be triggered under some circumstances (e.g., requiring
		a system which does not have the compile time flag
		HASFLOCK set). Based on patch by Motonori Nakamura
		of National Institute of Informatics, Japan.
	If a milter rejected a recipient, the count for nrcpts= in the
		logfile entry might have been wrong.  Problem found by
		Petra Humann of TU Dresden.
	If a milter invoked smfi_chgfrom() where ESMTP arguments are not
		NULL, the message body was lost.  Patch from Motonori
		Nakamura of National Institute of Informatics, Japan.
	sendmail(8) had a bogus space in -qGname.  Patch from Peng Haitao.
	CONTRIB: buildvirtuser: Preserve ownership and permissions when
		replacing files.
	CONTRIB: buildvirtuser: Skip dot-files (e.g., .cvsignore) when
		reading the /etc/mail/virtusers/ directory.
	CONTRIB: buildvirtuser: Emit warnings instead of exiting where
		appropriate.
	LIBMILTER: Fix ABI backwards compatibility so milters compiled
		against an older libmilter.so shared library can use an
		8.14 libmilter.so shared library.
	LIBMILTER: smfi_version() did not properly extract the patchlevel
		from the version number, however, the returned value was
		correct for the current libmilter version.

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.5 (OpenBSD)

iQCVAwUBRyqEOs8etQMiMnoBAQKNdQP/cQKfjVP7qTi0Ol/OgR7AnvCaerCxiQ5J
y1uxjwXs2s+RemX0u5a4c0agoLscTKU5Ot6uzOdvKvZd0/unr/IkzuXZBF9LsnlZ
X1wS4GXQDXKDfazvwdwOUgxkthMZU1TiVFj/GH5TOfHqVUO5Ho/yRfAQoAn3taFc
5jeg+A3+M9M=
=DJHS
-----END PGP SIGNATURE-----
@
text
@d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.267 2007/02/27 22:21:12 ca Exp $")
@


1.2.2.1
log
@MFC sendmail update to 8.14.3

agreed bsiegert@@
@
text
@d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.269 2007/06/06 17:26:12 ca Exp $")
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2004 Sendmail, Inc. and its suppliers.
d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.228 2004/11/09 18:54:55 ca Exp $")
d16 1
d21 1
a21 1
# include <sys/time.h>
d26 1
a26 1
#  if _FFR_MILTER_NAGLE
d28 1
a28 1
#  endif /* _FFR_MILTER_NAGLE */
d37 44
d88 1
d195 1
a195 1
# define MILTER_TIMEOUT(routine, secs, write, started) \
d233 2
a234 2
			sm_dprintf("milter_%s(%s): timeout\n", (routine), \
				   m->mf_name); \
d237 2
a238 2
				  "Milter (%s): %s %s %s %s", \
				  m->mf_name, "timeout", \
d240 1
a240 1
				  "data", (routine)); \
d295 1
a295 1
milter_sysread(m, buf, sz, to, e)
d301 1
d322 2
a323 2
					sm_dprintf("milter_read (%s): %s %s %s",
						  m->mf_name, "timeout",
d325 1
a325 1
						  "data read");
d328 2
a329 2
						  "Milter (%s): %s %s %s",
						  m->mf_name, "timeout",
d331 1
a331 1
						  "data read");
d337 1
a337 1
			MILTER_TIMEOUT("read", to, false, started);
d347 1
a347 1
				sm_dprintf("milter_read(%s): read returned %ld: %s\n",
d369 1
a369 1
			sm_dprintf("milter_read(%s): cmd read returned %ld, expecting %ld\n",
d373 1
a373 1
				  "milter_read(%s): cmd read returned %ld, expecting %ld",
d382 1
a382 1
milter_read(m, cmd, rlen, to, e)
d388 1
d393 1
a393 2
# if _FFR_MILTER_NAGLE
#  ifdef TCP_CORK
d395 1
a395 2
#  endif
# endif /* _FFR_MILTER_NAGLE */
d399 10
d415 1
a415 2
# if _FFR_MILTER_NAGLE
#  ifdef TCP_CORK
d418 1
a418 2
#  endif
# endif /* _FFR_MILTER_NAGLE */
d420 1
a420 1
	if (milter_sysread(m, data, sizeof data, to, e) == NULL)
d423 1
a423 2
# if _FFR_MILTER_NAGLE
#  ifdef TCP_CORK
d427 1
a427 2
#  endif
# endif /* _FFR_MILTER_NAGLE */
d438 2
a439 2
				sm_dprintf("milter_read(%s): timeout before data read\n",
					m->mf_name);
d442 2
a443 2
					  "Milter read(%s): timeout before data read",
					  m->mf_name);
d462 2
a463 2
			sm_dprintf("milter_read(%s): read size %ld out of range\n",
				m->mf_name, (long) expl);
d466 2
a467 2
				  "milter_read(%s): read size %ld out of range",
				  m->mf_name, (long) expl);
d477 1
a477 1
	if (milter_sysread(m, buf, expl, to, e) == NULL)
d508 1
a508 1
milter_write(m, cmd, buf, len, to, e)
d510 1
a510 1
	char cmd;
d515 1
d521 1
d544 9
d556 1
a556 1
			   m->mf_name, cmd, (long) len);
d558 1
a558 1
	nl = htonl(len + 1);	/* add 1 for the cmd char */
d560 1
a560 1
	data[MILTER_LEN_BYTES] = cmd;
d599 1
a599 1
		MILTER_TIMEOUT("write", to, true, started);
d610 1
a610 1
				   m->mf_name, cmd, (long) i, (long) sl,
d615 1
a615 1
				  m->mf_name, cmd, (long) i, (long) sl,
d676 1
a676 1
	memset(&addr, '\0', sizeof addr);
d756 1
a756 1
		if (strlen(colon) >= sizeof addr.sunix.sun_path)
d809 2
a810 2
			       sizeof addr.sunix.sun_path);
		addrlen = sizeof (struct sockaddr_un);
d862 1
a862 1
			register struct servent *sp;
d912 1
a912 1
				(void) memset(&hid6, '\0', sizeof hid6);
d983 1
a983 1
				addrlen = sizeof (struct sockaddr_in);
d993 1
a993 1
				addrlen = sizeof (struct sockaddr_in6);
d1181 1
a1181 2
# if _FFR_MILTER_NAGLE
#  ifndef TCP_CORK
d1188 1
a1188 2
#  endif /* TCP_CORK */
# endif /* _FFR_MILTER_NAGLE */
d1205 1
d1221 2
a1222 2
	register char *p;
	register struct milter *m;
d1237 2
a1238 2
	m = (struct milter *) xalloc(sizeof *m);
	memset((char *) m, '\0', sizeof *m);
d1246 5
d1298 12
d1328 1
d1350 1
a1350 1
	register char *p;
d1391 1
d1412 1
a1412 1
	register char *p;
d1479 57
d1558 1
a1558 1
# define MO_MACROS_CONNECT		0x01
d1560 1
a1560 1
# define MO_MACROS_HELO			0x02
d1562 1
a1562 1
# define MO_MACROS_ENVFROM		0x03
d1564 1
a1564 1
# define MO_MACROS_ENVRCPT		0x04
d1566 1
a1566 1
# define MO_MACROS_DATA			0x05
d1568 1
a1568 1
# define MO_MACROS_EOM			0x06
d1570 3
d1576 1
a1576 1
#  define MO_MAXDATASIZE			0x08
d1579 1
a1579 1
	{ NULL,				0				},
d1588 2
a1589 3
	int nummac = 0;
	register struct milteropt *mo;
	char *p;
d1592 1
d1660 5
d1674 3
a1676 31
		p = newstr(val);
		while (*p != '\0')
		{
			char *macro;

			/* Skip leading commas, spaces */
			while (*p != '\0' &&
			       (*p == ',' || (isascii(*p) && isspace(*p))))
				p++;

			if (*p == '\0')
				break;

			/* Find end of macro */
			macro = p;
			while (*p != '\0' && *p != ',' &&
			       isascii(*p) && !isspace(*p))
				p++;
			if (*p != '\0')
				*p++ = '\0';

			if (nummac >= MAXFILTERMACROS)
			{
				syserr("milter_set_option: too many macros in Milter.%s (max %d)",
				       name, MAXFILTERMACROS);
				macros[nummac] = NULL;
				break;
			}
			macros[nummac++] = macro;
		}
		macros[nummac] = NULL;
d1686 1
d1703 1
a1703 1
	(void) sm_strlcpy(dfname, queuename(e, DATAFL_LETTER), sizeof dfname);
d1741 1
d1759 1
a1759 1
	(void) sm_strlcpy(dfname, queuename(e, DATAFL_LETTER), sizeof dfname);
a1792 31
/*
**  MILTER_CAN_DELRCPTS -- can any milter filters delete recipients?
**
**	Parameters:
**		none
**
**	Returns:
**		true if any filter deletes recipients, false otherwise
*/

bool
milter_can_delrcpts()
{
	bool can = false;
	int i;

	if (tTd(64, 10))
		sm_dprintf("milter_can_delrcpts:");

	for (i = 0; InputFilters[i] != NULL; i++)
	{
		struct milter *m = InputFilters[i];

		if (bitset(SMFIF_DELRCPT, m->mf_fflags))
		{
			can = true;
			break;
		}
	}
	if (tTd(64, 10))
		sm_dprintf("%s\n", can ? "true" : "false");
a1793 2
	return can;
}
d1830 1
a1830 1
			    m->mf_timeout[SMFTO_WRITE], e);
d1839 1
d1867 1
a1867 1
			    m->mf_timeout[SMFTO_WRITE], e);
d1871 1
d1889 1
a1889 1
	char cmd;
d1894 1
d1923 1
a1923 1
	*bp++ = cmd;
d1936 1
a1936 1
				m->mf_name, cmd, macros[i], exp);
d1944 2
a1945 2
			    m->mf_timeout[SMFTO_WRITE], e);
	sm_free(buf); /* XXX */
d1953 1
a1953 1
**		command -- command to send.
d1964 1
a1964 1
milter_send_command(m, command, data, sz, e, state)
d1966 1
a1966 1
	char command;
d1971 1
a1975 1
#if _FFR_MILTER_NOHDR_RESP
d1977 1
a1977 1
#endif /* _FFR_MILTER_NOHDR_RESP */
d1991 1
d1998 1
d2005 1
d2012 1
d2019 1
a2019 3
#if _FFR_MILTER_NOHDR_RESP
		norespflag = SMFIP_NOHREPL;
#endif /* _FFR_MILTER_NOHDR_RESP */
d2026 1
d2033 1
a2037 1
#if SMFI_VERSION > 2
d2039 2
d2044 7
a2050 1
#endif /* SMFI_VERSION > 2 */
d2067 4
d2072 1
a2072 2
	if (skipflag != 0 &&
	    bitset(skipflag, m->mf_pflags))
d2077 1
a2077 1
			    m->mf_timeout[SMFTO_WRITE], e);
a2083 1
#if _FFR_MILTER_NOHDR_RESP
a2086 1
#endif /* _FFR_MILTER_NOHDR_RESP */
d2090 1
a2090 1
			       m->mf_timeout[SMFTO_READ], e);
d2106 2
a2107 1
			sm_syslog(LOG_INFO, e->e_id, "milter=%s, action=%s, reject=%s",
d2114 2
a2115 1
			sm_syslog(LOG_INFO, e->e_id, "milter=%s, action=%s, reject",
d2122 2
a2123 1
			sm_syslog(LOG_INFO, e->e_id, "milter=%s, action=%s, discard",
d2130 2
a2131 1
			sm_syslog(LOG_INFO, e->e_id, "milter=%s, action=%s, tempfail",
d2144 2
a2145 1
			sm_syslog(LOG_INFO, e->e_id, "milter=%s, action=%s, accepted",
d2154 2
a2155 1
			sm_syslog(LOG_INFO, e->e_id, "milter=%s, action=%s, continue",
d2159 8
d2177 1
a2177 2
	if (*state != SMFIR_REPLYCODE &&
	    response != NULL)
d2189 1
a2189 1
**		command -- command to send.
d2195 2
d2203 2
a2204 2
milter_command(command, data, sz, macros, e, state)
	char command;
d2210 2
d2214 1
d2220 1
a2220 1
			(char) command, (long) sz);
d2253 16
a2268 1
		response = milter_send_command(m, command, data, sz, e, state);
d2283 86
d2375 1
d2382 1
a2382 1
milter_negotiate(m, e)
d2385 1
d2388 3
a2390 3
	mi_int32 fvers;
	mi_int32 fflags;
	mi_int32 pflags;
a2391 1
	ssize_t rlen;
d2405 13
a2417 3
	fvers = htonl(SMFI_VERSION);
	fflags = htonl(SMFI_CURR_ACTS);
	pflags = htonl(SMFI_CURR_PROT);
d2423 2
a2424 2
	(void) milter_write(m, SMFIC_OPTNEG, data, sizeof data,
			    m->mf_timeout[SMFTO_WRITE], e);
d2429 6
a2434 1
	response = milter_read(m, &rcmd, &rlen, m->mf_timeout[SMFTO_READ], e);
d2473 1
a2473 1
	if (rlen != MILTER_OPTLEN)
a2491 2
	sm_free(response); /* XXX */
	response = NULL;
d2509 1
a2509 1
		return -1;
d2513 1
a2513 1
	if ((m->mf_fflags & SMFI_CURR_ACTS) != m->mf_fflags)
d2518 1
a2518 1
				SMFI_CURR_ACTS);
d2523 1
a2523 1
				  (unsigned long) SMFI_CURR_ACTS);
d2525 1
a2525 1
		return -1;
d2529 1
a2529 1
	if ((m->mf_pflags & SMFI_CURR_PROT) != m->mf_pflags)
d2534 1
a2534 1
				(unsigned long) SMFI_CURR_PROT);
d2539 1
a2539 1
				  (unsigned long) SMFI_CURR_PROT);
d2541 11
a2551 1
		return -1;
d2554 6
d2561 1
a2561 1
		sm_dprintf("milter_negotiate(%s): version %u, fflags 0x%x, pflags 0x%x\n",
d2564 5
d2570 1
d2598 1
d2631 1
d2659 2
a2660 2
		char *buf;
		ssize_t s;
d2675 1
a2675 1
			sm_dprintf("milter_headers: %s: %s\n",
d2681 8
a2688 2
		s = strlen(h->h_field) + 1 + strlen(h->h_value) + 1;
		if (s < 0)
d2690 13
a2702 3
		buf = (char *) xalloc(s);
		(void) sm_snprintf(buf, s, "%s%c%s",
			h->h_field, '\0', h->h_value);
d2706 2
a2707 2
					       s, e, state);
		sm_free(buf); /* XXX */
d2718 1
d2766 1
d2769 1
d2772 1
a2772 1
				if (bp + 2 > &buf[sizeof buf])
d2790 1
a2790 1
		if (bp >= &buf[sizeof buf])
d2794 2
a2795 1
						       bp - buf, e, state);
d2806 1
d2816 2
a2817 1
		    *state == SMFIR_ACCEPT)
d2836 1
d2841 1
a2841 1
					       e, state);
d2847 6
d2861 31
d2895 1
d2905 2
a2906 1
milter_addheader(response, rlen, e)
d2911 2
a2912 1
	char *val;
d2929 2
a2930 1
			sm_dprintf("didn't follow protocol (total len)\n");
d2960 3
d2970 1
a2970 1
				   h->h_field, val);
d2974 8
a2981 2
				  h->h_field, val);
		h->h_value = newstr(val);
d2987 1
a2987 1
			sm_dprintf("Add %s: %s\n", response, val);
d2989 6
a2994 3
			sm_syslog(LOG_INFO, e->e_id, "Milter add: header: %s: %s",
				  response, val);
		addheader(newstr(response), val, H_USER, e);
d2997 1
d3002 1
d3010 4
a3013 4
**  	Notes:
**  		Unlike milter_addheader(), this does not attempt to determine
**  		if the header already exists in the envelope, even a
**  		deleted version.  It just blindly inserts.
d3017 2
a3018 1
milter_insheader(response, rlen, e)
d3024 2
a3025 2
	char *field;
	char *val;
d3071 1
a3071 1
		sm_dprintf("Insert (%d) %s: %s\n", idx, response, val);
d3074 1
a3074 1
		          "Milter insert (%d): header: %s: %s",
d3076 5
a3080 1
	insheader(idx, newstr(field), val, H_USER, e);
d3082 1
d3087 1
d3097 2
a3098 1
milter_changeheader(response, rlen, e)
d3104 2
a3105 1
	char *field, *val;
d3148 3
d3156 1
a3156 2
			if (bitset(H_USER, h->h_flags) &&
			    --index <= 0)
d3195 1
a3195 1
				sm_dprintf("Add %s: %s\n", field, val);
d3199 3
a3201 2
					, field, val);
			addheader(newstr(field), val, H_USER, e);
d3210 1
a3210 1
			sm_dprintf("Delete%s %s: %s\n",
d3221 1
a3221 1
				   val);
d3230 1
a3230 1
				  "Milter delete: header%s %s: %s",
d3242 1
a3242 1
				  val);
d3272 1
d3276 7
a3282 1
		h->h_value = newstr(val);
d3287 216
d3552 1
d3586 2
a3587 1
			sm_dprintf("didn't follow protocol (total len)\n");
d3599 1
d3633 1
a3633 1
				  sizeof dfname);
d3761 1
d3769 1
a3769 1
milter_init(e, state)
d3772 1
d3779 1
d3801 1
a3801 1
		    milter_negotiate(m, e) < 0 ||
d3839 1
d3902 1
a3902 1
				       sizeof buf6);
d3924 2
a3925 2
	(void) memcpy(bp, &family, sizeof family);
	bp += sizeof family;
d3928 2
a3929 2
		(void) memcpy(bp, &port, sizeof port);
		bp += sizeof port;
d3935 2
a3936 2
	response = milter_command(SMFIC_CONNECT, buf, s,
				  MilterConnectMacros, e, state);
d3979 1
d4024 1
a4024 1
				  MilterHeloMacros, e, state);
d4028 1
d4109 1
a4109 1
		sm_syslog(LOG_INFO, e->e_id, "Milter: senders: %s", buf);
d4112 2
a4113 2
	response = milter_command(SMFIC_MAIL, buf, s,
				  MilterEnvFromMacros, e, state);
d4124 1
a4124 1
		sm_syslog(LOG_INFO, e->e_id, "Milter: reject, senders");
d4135 1
d4142 1
a4142 1
milter_envrcpt(args, e, state)
d4146 1
d4193 2
a4194 2
	response = milter_command(SMFIC_RCPT, buf, s,
				  MilterEnvRcptMacros, e, state);
a4198 1
#if SMFI_VERSION > 3
d4219 2
a4220 1
	return milter_command(SMFIC_DATA, NULL, 0, MilterDataMacros, e, state);
a4221 1
#endif /* SMFI_VERSION > 3 */
d4329 7
d4338 1
a4338 1
						       e, state);
d4352 1
d4355 2
d4360 1
a4360 1
				    m->mf_timeout[SMFTO_WRITE], e);
d4385 2
a4386 1
					       m->mf_timeout[SMFTO_READ], e);
d4470 1
a4470 1
				milter_addheader(response, rlen, e);
d4481 1
a4481 1
				milter_insheader(response, rlen, e);
d4492 12
a4503 1
				milter_changeheader(response, rlen, e);
d4517 11
a4655 1
#if SMFI_VERSION > 2
d4661 1
a4661 1
**		cmd -- the string itself.
d4671 2
a4672 2
milter_unknown(cmd, e, state)
	char *cmd;
d4677 1
a4677 1
		sm_dprintf("milter_unknown(%s)\n", cmd);
d4679 2
a4680 2
	return milter_command(SMFIC_UNKNOWN, cmd, strlen(cmd) + 1,
				NULL, e, state);
a4681 1
#endif /* SMFI_VERSION > 2 */
d4705 1
@


1.1.127.1
log
@Import Sendmail 8.14.3, suitably stripped down by the not yet committed
contrib/samples/import-3rdpty,v 1.35; we have some new and renamed files
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2006 Sendmail, Inc. and its suppliers.
d13 1
a13 1
SM_RCSID("@@(#)$Id: milter.c,v 8.269 2007/06/06 17:26:12 ca Exp $")
a15 1
# include <sm/sendmail.h>
d20 1
a20 1
# include <sm/time.h>
d25 1
a25 1
#  if MILTER_NO_NAGLE
d27 1
a27 1
#  endif /* MILTER_NO_NAGLE */
a35 44
static char	*milter_sysread __P((struct milter *, char *, ssize_t, time_t,
			ENVELOPE *, const char *));
static char	*milter_read __P((struct milter *, char *, ssize_t *, time_t,
			ENVELOPE *, const char *));
static char	*milter_write __P((struct milter *, int, char *, ssize_t,
			time_t, ENVELOPE *, const char *));
static char	*milter_send_command __P((struct milter *, int, void *,
			ssize_t, ENVELOPE *, char *, const char *));
static char	*milter_command __P((int, void *, ssize_t, char **,
			ENVELOPE *, char *, const char *, bool));
static char	*milter_body __P((struct milter *, ENVELOPE *, char *));
static int	milter_reopen_df __P((ENVELOPE *));
static int	milter_reset_df __P((ENVELOPE *));
static void	milter_quit_filter __P((struct milter *, ENVELOPE *));
static void	milter_abort_filter __P((struct milter *, ENVELOPE *));
static void	milter_send_macros __P((struct milter *, char **, int,
			ENVELOPE *));
static int	milter_negotiate __P((struct milter *, ENVELOPE *,
			milters_T *));
static void	milter_per_connection_check __P((ENVELOPE *));
static char	*milter_headers __P((struct milter *, ENVELOPE *, char *));
static void	milter_addheader __P((struct milter *, char *, ssize_t,
			ENVELOPE *));
static void	milter_insheader __P((struct milter *, char *, ssize_t,
			ENVELOPE *));
static void	milter_changeheader __P((struct milter *, char *, ssize_t,
			ENVELOPE *));
static void	milter_chgfrom __P((char *, ssize_t, ENVELOPE *));
static void	milter_addrcpt __P((char *, ssize_t, ENVELOPE *));
static void	milter_addrcpt_par __P((char *, ssize_t, ENVELOPE *));
static void	milter_delrcpt __P((char *, ssize_t, ENVELOPE *));
static int	milter_replbody __P((char *, ssize_t, bool, ENVELOPE *));
static int	milter_set_macros __P((char *, char **, char *, int));


/* milter states */
# define SMFS_CLOSED		'C'	/* closed for all further actions */
# define SMFS_OPEN		'O'	/* connected to remote milter filter */
# define SMFS_INMSG		'M'	/* currently servicing a message */
# define SMFS_DONE		'D'	/* done with current message */
# define SMFS_CLOSABLE		'Q'	/* done with current connection */
# define SMFS_ERROR		'E'	/* error state */
# define SMFS_READY		'R'	/* ready for action */
# define SMFS_SKIP		'S'	/* skip body */
a42 1
static char *MilterEOHMacros[MAXFILTERMACROS + 1];
d149 1
a149 1
# define MILTER_TIMEOUT(routine, secs, write, started, function) \
d187 2
a188 2
			sm_dprintf("milter_%s(%s): timeout, where=%s\n", \
				(routine), m->mf_name, (function)); \
d191 2
a192 2
				  "Milter (%s): timeout %s data %s, where=%s", \
				  m->mf_name, \
d194 1
a194 1
				  (routine), (function)); \
d249 1
a249 1
milter_sysread(m, buf, sz, to, e, where)
a254 1
	const char *where;
d275 2
a276 2
					sm_dprintf("milter_sys_read (%s): timeout %s data read in %s",
						  m->mf_name,
d278 1
a278 1
						  where);
d281 2
a282 2
						  "Milter (%s): timeout %s data read in %s",
						  m->mf_name,
d284 1
a284 1
						  where);
d290 1
a290 1
			MILTER_TIMEOUT("read", to, false, started, where);
d300 1
a300 1
				sm_dprintf("milter_sys_read(%s): read returned %ld: %s\n",
d322 1
a322 1
			sm_dprintf("milter_sys_read(%s): cmd read returned %ld, expecting %ld\n",
d326 1
a326 1
				  "milter_sys_read(%s): cmd read returned %ld, expecting %ld",
d335 1
a335 1
milter_read(m, cmd, rlen, to, e, where)
a340 1
	const char *where;
d345 2
a346 1
# if MILTER_NO_NAGLE && defined(TCP_CORK)
d348 2
a349 1
# endif /* MILTER_NO_NAGLE && defined(TCP_CORK) */
a352 10
	if (m->mf_sock < 0)
	{
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "milter_read(%s): socket closed, where=%s",
				  m->mf_name, where);
		milter_error(m, e);
		return NULL;
	}

d359 2
a360 1
# if MILTER_NO_NAGLE && defined(TCP_CORK)
d363 2
a364 1
# endif /* MILTER_NO_NAGLE && defined(TCP_CORK) */
d366 1
a366 1
	if (milter_sysread(m, data, sizeof(data), to, e, where) == NULL)
d369 2
a370 1
# if MILTER_NO_NAGLE && defined(TCP_CORK)
d374 2
a375 1
# endif /* MILTER_NO_NAGLE && defined(TCP_CORK) */
d386 2
a387 2
				sm_dprintf("milter_read(%s): timeout before data read, where=%s\n",
					m->mf_name, where);
d390 2
a391 2
					  "Milter read(%s): timeout before data read, where=%s",
					  m->mf_name, where);
d410 2
a411 2
			sm_dprintf("milter_read(%s): read size %ld out of range, where=%s\n",
				m->mf_name, (long) expl, where);
d414 2
a415 2
				  "milter_read(%s): read size %ld out of range, where=%s",
				  m->mf_name, (long) expl, where);
d425 1
a425 1
	if (milter_sysread(m, buf, expl, to, e, where) == NULL)
d456 1
a456 1
milter_write(m, cmd, buf, len, to, e, where)
d458 1
a458 1
	int cmd;
a462 1
	const char *where;
a467 1
	char command = (char) cmd;
a489 9
	if (m->mf_sock < 0)
	{
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "milter_write(%s): socket closed",
				  m->mf_name);
		milter_error(m, e);
		return NULL;
	}
d493 1
a493 1
			   m->mf_name, command, (long) len);
d495 1
a495 1
	nl = htonl(len + 1);	/* add 1 for the command char */
d497 1
a497 1
	data[MILTER_LEN_BYTES] = command;
d536 1
a536 1
		MILTER_TIMEOUT("write", to, true, started, where);
d547 1
a547 1
				   m->mf_name, command, (long) i, (long) sl,
d552 1
a552 1
				  m->mf_name, command, (long) i, (long) sl,
d613 1
a613 1
	memset(&addr, '\0', sizeof(addr));
d693 1
a693 1
		if (strlen(colon) >= sizeof(addr.sunix.sun_path))
d746 2
a747 2
			       sizeof(addr.sunix.sun_path));
		addrlen = sizeof(struct sockaddr_un);
d799 1
a799 1
			struct servent *sp;
d849 1
a849 1
				(void) memset(&hid6, '\0', sizeof(hid6));
d920 1
a920 1
				addrlen = sizeof(struct sockaddr_in);
d930 1
a930 1
				addrlen = sizeof(struct sockaddr_in6);
d1118 2
a1119 1
# if MILTER_NO_NAGLE && !defined(TCP_CORK)
d1126 2
a1127 1
# endif /* MILTER_NO_NAGLE && !defined(TCP_CORK) */
a1143 1

d1159 2
a1160 2
	char *p;
	struct milter *m;
d1175 2
a1176 2
	m = (struct milter *) xalloc(sizeof(*m));
	memset((char *) m, '\0', sizeof(*m));
a1183 5
#if _FFR_MILTER_CHECK
	m->mf_mta_prot_version = SMFI_PROT_VERSION;
	m->mf_mta_prot_flags = SMFI_CURR_PROT;
	m->mf_mta_actions = SMFI_CURR_ACTS;
#endif /* _FFR_MILTER_CHECK */
a1230 12
#if _FFR_MILTER_CHECK
		  case 'a':
			m->mf_mta_actions = strtoul(p, NULL, 0);
			break;
		  case 'f':
			m->mf_mta_prot_flags = strtoul(p, NULL, 0);
			break;
		  case 'v':
			m->mf_mta_prot_version = strtoul(p, NULL, 0);
			break;
#endif /* _FFR_MILTER_CHECK */

a1248 1

d1270 1
a1270 1
	char *p;
a1310 1

d1331 1
a1331 1
	char *p;
a1397 57

/*
**  MILTER_SET_MACROS -- set milter macros
**
**	Parameters:
**		name -- name of milter.
**		macros -- where to store macros.
**		val -- the value of the option.
**		nummac -- current number of macros
**
**	Returns:
**		new number of macros
*/

static int
milter_set_macros(name, macros, val, nummac)
	char *name;
	char **macros;
	char *val;
	int nummac;
{
	char *p;

	p = newstr(val);
	while (*p != '\0')
	{
		char *macro;

		/* Skip leading commas, spaces */
		while (*p != '\0' &&
		       (*p == ',' || (isascii(*p) && isspace(*p))))
			p++;

		if (*p == '\0')
			break;

		/* Find end of macro */
		macro = p;
		while (*p != '\0' && *p != ',' &&
		       isascii(*p) && !isspace(*p))
			p++;
		if (*p != '\0')
			*p++ = '\0';

		if (nummac >= MAXFILTERMACROS)
		{
			syserr("milter_set_option: too many macros in Milter.%s (max %d)",
			       name, MAXFILTERMACROS);
			macros[nummac] = NULL;
			return -1;
		}
		macros[nummac++] = macro;
	}
	macros[nummac] = NULL;
	return nummac;
}

d1420 1
a1420 1
# define MO_MACROS_CONNECT		SMFIM_CONNECT
d1422 1
a1422 1
# define MO_MACROS_HELO			SMFIM_HELO
d1424 1
a1424 1
# define MO_MACROS_ENVFROM		SMFIM_ENVFROM
d1426 1
a1426 1
# define MO_MACROS_ENVRCPT		SMFIM_ENVRCPT
d1428 1
a1428 1
# define MO_MACROS_DATA			SMFIM_DATA
d1430 1
a1430 1
# define MO_MACROS_EOM			SMFIM_EOM
a1431 3
# define MO_MACROS_EOH			SMFIM_EOH
	{ "macros.eoh",			MO_MACROS_EOH			},

d1435 1
a1435 1
#  define MO_MAXDATASIZE		0x08
d1438 1
a1438 1
	{ NULL,				(unsigned char)-1		},
d1447 3
a1449 2
	int nummac, r;
	struct milteropt *mo;
a1451 1
	nummac = 0;
a1518 5
	  case MO_MACROS_EOH:
		if (macros == NULL)
			macros = MilterEOHMacros;
		/* FALLTHROUGH */

d1528 31
a1558 3
		r = milter_set_macros(name, macros, val, nummac);
		if (r >= 0)
			nummac = r;
a1567 1

d1584 1
a1584 1
	(void) sm_strlcpy(dfname, queuename(e, DATAFL_LETTER), sizeof(dfname));
a1621 1

d1639 1
a1639 1
	(void) sm_strlcpy(dfname, queuename(e, DATAFL_LETTER), sizeof(dfname));
d1673 31
d1705 2
d1743 1
a1743 1
			    m->mf_timeout[SMFTO_WRITE], e, "quit_filter");
a1751 1

d1779 1
a1779 1
			    m->mf_timeout[SMFTO_WRITE], e, "abort_filter");
a1782 1

d1800 1
a1800 1
	int cmd;
a1804 1
	char command = (char) cmd;
d1833 1
a1833 1
	*bp++ = command;
d1846 1
a1846 1
				m->mf_name, command, macros[i], exp);
d1854 2
a1855 2
			    m->mf_timeout[SMFTO_WRITE], e, "send_macros");
	sm_free(buf);
d1863 1
a1863 1
**		cmd -- command to send.
d1874 1
a1874 1
milter_send_command(m, cmd, data, sz, e, state, where)
d1876 1
a1876 1
	int cmd;
a1880 1
	const char *where;
d1885 1
d1887 1
a1887 1
	char command = (char) cmd;
a1900 1
		norespflag = SMFIP_NR_CONN;
a1906 1
		norespflag = SMFIP_NR_HELO;
a1912 1
		norespflag = SMFIP_NR_MAIL;
a1918 1
		norespflag = SMFIP_NR_RCPT;
d1925 3
a1927 1
		norespflag = SMFIP_NR_HDR;
a1933 1
		norespflag = SMFIP_NR_BODY;
a1939 1
		norespflag = SMFIP_NR_EOH;
d1944 1
a1945 2
		skipflag = SMFIP_NOUNKNOWN;
		norespflag = SMFIP_NR_UNKN;
d1949 1
a1949 7

	  case SMFIC_DATA:
		skipflag = SMFIP_NODATA;
		norespflag = SMFIP_NR_DATA;
		action = "data";
		defresponse = "550 5.7.1 Command rejected";
		break;
a1965 4
	if (tTd(64, 10))
		sm_dprintf("milter_send_command(%s): skip=%lx, pflags=%x\n",
			m->mf_name, skipflag, m->mf_pflags);

d1967 2
a1968 1
	if (skipflag != 0 && bitset(skipflag, m->mf_pflags))
d1973 1
a1973 1
			    m->mf_timeout[SMFTO_WRITE], e, where);
d1980 1
d1984 1
d1988 1
a1988 1
			       m->mf_timeout[SMFTO_READ], e, where);
d2004 1
a2004 2
			sm_syslog(LOG_INFO, e->e_id,
				  "milter=%s, action=%s, reject=%s",
d2011 1
a2011 2
			sm_syslog(LOG_INFO, e->e_id,
				  "milter=%s, action=%s, reject",
d2018 1
a2018 2
			sm_syslog(LOG_INFO, e->e_id,
				  "milter=%s, action=%s, discard",
d2025 1
a2025 2
			sm_syslog(LOG_INFO, e->e_id,
				  "milter=%s, action=%s, tempfail",
d2038 1
a2038 2
			sm_syslog(LOG_INFO, e->e_id,
				  "milter=%s, action=%s, accepted",
d2047 1
a2047 2
			sm_syslog(LOG_INFO, e->e_id,
				  "milter=%s, action=%s, continue",
a2050 8
	  case SMFIR_SKIP:
		if (MilterLogLevel > 12)
			sm_syslog(LOG_INFO, e->e_id,
				  "milter=%s, action=%s, skip",
				  m->mf_name, action);
		m->mf_state = SMFS_SKIP;
		break;

d2061 2
a2062 1
	if (*state != SMFIR_REPLYCODE && response != NULL)
d2074 1
a2074 1
**		cmd -- command to send.
a2079 2
**		where -- description of calling function (logging).
**		cmd_error -- did the SMTP command cause an error?
d2086 2
a2087 2
milter_command(cmd, data, sz, macros, e, state, where, cmd_error)
	int cmd;
a2092 2
	const char *where;
	bool cmd_error;
a2094 1
	char command = (char) cmd;
d2100 1
a2100 1
			command, (long) sz);
d2133 1
a2133 16
		/*
		**  send the command if
		**	there is no error
		**	or it's RCPT and the client asked for it:
		**	!cmd_error ||
		**	where == "rcpt" && m->mf_pflags & SMFIP_RCPT_REJ != 0
		**  negate that condition and use continue
		*/

		if (cmd_error &&
		    (strcmp(where, "rcpt") != 0 ||
		     (m->mf_pflags & SMFIP_RCPT_REJ) == 0))
			continue;

		response = milter_send_command(m, command, data, sz, e, state,
						where);
a2147 86

static int milter_getsymlist __P((struct milter *, char *, int, int));

static int
milter_getsymlist(m, buf, rlen, offset)
	struct milter *m;
	char *buf;
	int rlen;
	int offset;
{
	int i, r, nummac;
	mi_int32 v;

	SM_ASSERT(m != NULL);
	SM_ASSERT(buf != NULL);

	while (offset + MILTER_LEN_BYTES < rlen)
	{
		size_t len;
		char **macros;

		nummac = 0;
		(void) memcpy((char *) &v, buf + offset, MILTER_LEN_BYTES);
		i = ntohl(v);
		if (i < SMFIM_FIRST || i > SMFIM_LAST)
			return -1;
		offset += MILTER_LEN_BYTES;
		macros = NULL;

		switch (i)
		{
		  case MO_MACROS_CONNECT:
			if (macros == NULL)
				macros = MilterConnectMacros;
			/* FALLTHROUGH */

		  case MO_MACROS_HELO:
			if (macros == NULL)
				macros = MilterHeloMacros;
			/* FALLTHROUGH */

		  case MO_MACROS_ENVFROM:
			if (macros == NULL)
				macros = MilterEnvFromMacros;
			/* FALLTHROUGH */

		  case MO_MACROS_ENVRCPT:
			if (macros == NULL)
				macros = MilterEnvRcptMacros;
			/* FALLTHROUGH */

		  case MO_MACROS_EOM:
			if (macros == NULL)
				macros = MilterEOMMacros;
			/* FALLTHROUGH */

		  case MO_MACROS_EOH:
			if (macros == NULL)
				macros = MilterEOHMacros;
			/* FALLTHROUGH */

		  case MO_MACROS_DATA:
			if (macros == NULL)
				macros = MilterDataMacros;

			len = strlen(buf + offset);
			if (len > 0)
			{
				r = milter_set_macros(m->mf_name, macros,
						buf + offset, nummac);
				if (r >= 0)
					nummac = r;
			}
			break;

		  default:
			return -1;
		}
		if (len == 0)
			return -1;
		offset += len + 1;
	}

	return 0;
}

a2153 1
**		milters -- milters structure.
d2160 1
a2160 1
milter_negotiate(m, e, milters)
a2162 1
	milters_T *milters;
d2165 4
a2168 2
	mi_int32 fvers, fflags, pflags;
	mi_int32 mta_prot_vers, mta_prot_flags, mta_actions;
a2169 1
	char *response;
d2183 3
a2185 13
#if _FFR_MILTER_CHECK
	mta_prot_vers = m->mf_mta_prot_version;
	mta_prot_flags = m->mf_mta_prot_flags;
	mta_actions = m->mf_mta_actions;
#else /* _FFR_MILTER_CHECK */
	mta_prot_vers = SMFI_PROT_VERSION;
	mta_prot_flags = SMFI_CURR_PROT;
	mta_actions = SMFI_CURR_ACTS;
#endif /* _FFR_MILTER_CHECK */

	fvers = htonl(mta_prot_vers);
	pflags = htonl(mta_prot_flags);
	fflags = htonl(mta_actions);
d2191 2
a2192 2
	(void) milter_write(m, SMFIC_OPTNEG, data, sizeof(data),
			    m->mf_timeout[SMFTO_WRITE], e, "negotiate");
d2197 1
a2197 6
	if (tTd(64, 5))
		sm_dprintf("milter_negotiate(%s): send: version %lu, fflags 0x%lx, pflags 0x%lx\n",
			m->mf_name, ntohl(fvers), ntohl(fflags), ntohl(pflags));

	response = milter_read(m, &rcmd, &rlen, m->mf_timeout[SMFTO_READ], e,
				"negotiate");
d2236 1
a2236 1
	if (rlen < MILTER_OPTLEN)
d2255 2
d2274 1
a2274 1
		goto error;
d2278 1
a2278 1
	if ((m->mf_fflags & mta_actions) != m->mf_fflags)
d2283 1
a2283 1
				(unsigned long) mta_actions);
d2288 1
a2288 1
				  (unsigned long) mta_actions);
d2290 1
a2290 1
		goto error;
d2294 1
a2294 1
	if ((m->mf_pflags & mta_prot_flags) != m->mf_pflags)
d2299 1
a2299 1
				(unsigned long) mta_prot_flags);
d2304 1
a2304 1
				  (unsigned long) mta_prot_flags);
d2306 1
a2306 11
		goto error;
	}

	if (m->mf_fvers <= 2)
		m->mf_pflags |= SMFIP_NOUNKNOWN;
	if (m->mf_fvers <= 3)
		m->mf_pflags |= SMFIP_NODATA;

	if (rlen > MILTER_OPTLEN)
	{
		milter_getsymlist(m, response, rlen, MILTER_OPTLEN);
a2308 6
	if (bitset(SMFIF_DELRCPT, m->mf_fflags))
		milters->mis_flags |= MIS_FL_DEL_RCPT;
	if (!bitset(SMFIP_NORCPT, m->mf_pflags) &&
	    !bitset(SMFIP_NR_RCPT, m->mf_pflags))
		milters->mis_flags |= MIS_FL_REJ_RCPT;

d2310 1
a2310 1
		sm_dprintf("milter_negotiate(%s): received: version %u, fflags 0x%x, pflags 0x%x\n",
a2312 5

  error:
	if (response != NULL)
		sm_free(response); /* XXX */
	return -1;
a2313 1

a2340 1

a2372 1

d2400 2
a2401 2
		int len_n, len_v, len_t, len_f;
		char *buf, *hv;
d2416 1
a2416 1
			sm_dprintf("milter_headers: %s:%s\n",
d2422 2
a2423 8
		if (bitset(SMFIP_HDR_LEADSPC, m->mf_pflags)
		    || *(h->h_value) != ' ')
			hv = h->h_value;
		else
			hv = h->h_value + 1;
		len_f = strlen(h->h_field) + 1;
		len_t = len_f + strlen(hv) + 1;
		if (len_t < 0)
d2425 3
a2427 13
		buf = (char *) xalloc(len_t);

		/*
		**  Note: currently the call to dequote_internal_chars()
		**  is not required as h_field is supposed to be 7-bit US-ASCII.
		*/

		len_n = dequote_internal_chars(h->h_field, buf, len_f);
		SM_ASSERT(len_n < len_f);
		len_v = dequote_internal_chars(hv, buf + len_n + 1,
						len_t - len_n - 1);
		SM_ASSERT(len_t >= len_n + 1 + len_v + 1);
		len_t = len_n + 1 + len_v + 1;
d2431 2
a2432 2
					       len_t, e, state, "header");
		sm_free(buf);
a2442 1

a2489 1
#if !_FFR_MILTER_CONVERT_ALL_LF_TO_CRLF
a2491 1
#endif /* !_FFR_MILTER_CONVERT_ALL_LF_TO_CRLF */
d2494 1
a2494 1
				if (bp + 2 > &buf[sizeof(buf)])
d2512 1
a2512 1
		if (bp >= &buf[sizeof(buf)])
d2516 1
a2516 2
						       bp - buf, e, state,
							"body chunk");
a2526 1
		    m->mf_state == SMFS_SKIP ||
d2536 1
a2536 2
		    *state == SMFIR_ACCEPT ||
		    m->mf_state == SMFS_SKIP)
a2554 1
	    m->mf_state != SMFS_SKIP &&
d2559 1
a2559 1
					       e, state, "last body chunk");
a2564 6
	if (m->mf_state == SMFS_SKIP)
	{
		*state = SMFIR_CONTINUE;
		m->mf_state = SMFS_READY;
	}

a2572 31
**  ADDLEADINGSPACE -- Add a leading space to a string
**
**	Parameters:
**		str -- string
**		rp -- resource pool for allocations
**
**	Returns:
**		pointer to new string
*/

static char *addleadingspace __P((char *, SM_RPOOL_T *));

static char *
addleadingspace(str, rp)
	char *str;
	SM_RPOOL_T *rp;
{
	size_t l;
	char *new;

	SM_ASSERT(str != NULL);
	l = strlen(str);
	SM_ASSERT(l + 2 > l);
	new = sm_rpool_malloc_x(rp, l + 2);
	new[0] = ' ';
	new[1] = '\0';
	sm_strlcpy(new + 1, str, l + 1);
	return new;
}

/*
a2575 1
**		m -- current filter.
d2585 1
a2585 2
milter_addheader(m, response, rlen, e)
	struct milter *m;
d2590 1
a2590 2
	int mh_v_len;
	char *val, *mh_value;
d2607 1
a2607 2
			sm_dprintf("didn't follow protocol (total len %d != rlen %d)\n",
				   (int) strlen(response), (int) (rlen - 1));
a2636 3
	mh_v_len = 0;
	mh_value = quote_internal_chars(val, NULL, &mh_v_len);

d2644 1
a2644 1
				   h->h_field, mh_value);
d2648 2
a2649 8
				  h->h_field, mh_value);
		if (bitset(SMFIP_HDR_LEADSPC, m->mf_pflags))
			h->h_value = mh_value;
		else
		{
			h->h_value = addleadingspace (mh_value, e->e_rpool);
			SM_FREE(mh_value);
		}
d2655 1
a2655 1
			sm_dprintf("Add %s: %s\n", response, mh_value);
d2657 3
a2659 6
			sm_syslog(LOG_INFO, e->e_id,
				  "Milter add: header: %s: %s",
				  response, mh_value);
		addheader(newstr(response), mh_value, H_USER, e,
			!bitset(SMFIP_HDR_LEADSPC, m->mf_pflags));
		SM_FREE(mh_value);
a2661 1

a2665 1
**		m -- current filter.
d2673 4
a2676 4
**	Notes:
**		Unlike milter_addheader(), this does not attempt to determine
**		if the header already exists in the envelope, even a
**		deleted version.  It just blindly inserts.
d2680 1
a2680 2
milter_insheader(m, response, rlen, e)
	struct milter *m;
d2686 2
a2687 2
	int mh_v_len;
	char *field, *val, *mh_value;
d2733 1
a2733 1
		sm_dprintf("Insert (%d) %s: %s\n", idx, field, val);
d2736 1
a2736 1
			  "Milter insert (%d): header: %s: %s",
d2738 1
a2738 5
	mh_v_len = 0;
	mh_value = quote_internal_chars(val, NULL, &mh_v_len);
	insheader(idx, newstr(field), mh_value, H_USER, e,
		!bitset(SMFIP_HDR_LEADSPC, m->mf_pflags));
	SM_FREE(mh_value);
a2739 1

a2743 1
**		m -- current filter.
d2753 1
a2753 2
milter_changeheader(m, response, rlen, e)
	struct milter *m;
d2759 1
a2759 2
	int mh_v_len;
	char *field, *val, *mh_value;
a2801 3
	mh_v_len = 0;
	mh_value = quote_internal_chars(val, NULL, &mh_v_len);

d2807 2
a2808 1
			if (bitset(H_USER, h->h_flags) && --index <= 0)
d2847 1
a2847 1
				sm_dprintf("Add %s: %s\n", field, mh_value);
d2851 2
a2852 3
					, field, mh_value);
			addheader(newstr(field), mh_value, H_USER, e,
				!bitset(SMFIP_HDR_LEADSPC, m->mf_pflags));
d2861 1
a2861 1
			sm_dprintf("Delete%s %s:%s\n",
d2872 1
a2872 1
				   mh_value);
d2881 1
a2881 1
				  "Milter delete: header%s %s:%s",
d2893 1
a2893 1
				  mh_value);
a2922 1
		SM_FREE(mh_value);
d2926 1
a2926 7
		if (bitset(SMFIP_HDR_LEADSPC, m->mf_pflags))
			h->h_value = mh_value;
		else
		{
			h->h_value = addleadingspace (mh_value, e->e_rpool);
			SM_FREE(mh_value);
		}
a2930 216

/*
**  MILTER_SPLIT_RESPONSE -- Split response into fields.
**
**	Parameters:
**		response -- encoded repsonse.
**		rlen -- length of response.
**		pargc -- number of arguments (ouput)
**
**	Returns:
**		array of pointers to the individual strings
*/

static char **milter_split_response __P((char *, ssize_t, int *));

static char **
milter_split_response(response, rlen, pargc)
	char *response;
	ssize_t rlen;
	int *pargc;
{
	char **s;
	size_t i;
	int elem, nelem;

	SM_ASSERT(response != NULL);
	SM_ASSERT(pargc != NULL);
	*pargc = 0;
	if (rlen < 2 || strlen(response) >= (size_t) rlen)
	{
		if (tTd(64, 10))
			sm_dprintf("didn't follow protocol (total len %d != rlen %d)\n",
				   (int) strlen(response), (int) (rlen - 1));
		return NULL;
	}

	nelem = 0;
	for (i = 0; i < rlen; i++)
	{
		if (response[i] == '\0')
			++nelem;
	}
	if (nelem == 0)
		return NULL;

	/* last entry is only for the name */
	s = (char **)malloc(nelem * (sizeof(*s)));
	if (s == NULL)
		return NULL;
	s[0] = response;
	for (i = 0, elem = 0; i < rlen && elem < nelem; i++)
	{
		if (response[i] == '\0')
		{
			++elem;
			if (i + 1 >= rlen)
				s[elem] = NULL;
			else
				s[elem] = &(response[i + 1]);
		}
	}
	*pargc = nelem;

	if (tTd(64, 10))
	{
		for (elem = 0; elem < nelem; elem++)
			sm_dprintf("argv[%d]=\"%s\"\n", elem, s[elem]);
	}

	/* overwrite last entry (already done above, just paranoia) */
	s[elem] = NULL;
	return s;
}

/*
**  MILTER_CHGFROM -- Change the envelope sender address
**
**	Parameters:
**		response -- encoded form of recipient address.
**		rlen -- length of response.
**		e -- current envelope.
**
**	Returns:
**		none
*/

static void
milter_chgfrom(response, rlen, e)
	char *response;
	ssize_t rlen;
	ENVELOPE *e;
{
	int olderrors, argc;
	char **argv;

	if (tTd(64, 10))
		sm_dprintf("milter_chgfrom: ");

	/* sanity checks */
	if (response == NULL)
	{
		if (tTd(64, 10))
			sm_dprintf("NULL response\n");
		return;
	}

	if (*response == '\0' ||
	    strlen(response) + 1 > (size_t) rlen)
	{
		if (tTd(64, 10))
			sm_dprintf("didn't follow protocol (total len %d != rlen %d)\n",
				   (int) strlen(response), (int) (rlen - 1));
		return;
	}

	if (tTd(64, 10))
		sm_dprintf("%s\n", response);
	if (MilterLogLevel > 8)
		sm_syslog(LOG_INFO, e->e_id, "Milter chgfrom: %s", response);
	argv = milter_split_response(response, rlen, &argc);
	if (argc < 1 || argc > 2)
	{
		if (tTd(64, 10))
			sm_dprintf("didn't follow protocol argc=%d\n", argc);
		return;
	}

	olderrors = Errors;
	setsender(argv[0], e, NULL, '\0', false);
	if (argc == 2)
	{
		reset_mail_esmtp_args(e);

		/*
		**  need "features" here: how to get those? via e?
		**  "fake" it for now: allow everything.
		*/

		parse_esmtp_args(e, NULL, argv[0], argv[1], "MAIL", NULL,
				mail_esmtp_args);
	}
	Errors = olderrors;
	return;
}

/*
**  MILTER_ADDRCPT_PAR -- Add the supplied recipient to the message
**
**	Parameters:
**		response -- encoded form of recipient address.
**		rlen -- length of response.
**		e -- current envelope.
**
**	Returns:
**		none
*/

static void
milter_addrcpt_par(response, rlen, e)
	char *response;
	ssize_t rlen;
	ENVELOPE *e;
{
	int olderrors, argc;
	char *delimptr;
	char **argv;
	ADDRESS *a;

	if (tTd(64, 10))
		sm_dprintf("milter_addrcpt_par: ");

	/* sanity checks */
	if (response == NULL)
	{
		if (tTd(64, 10))
			sm_dprintf("NULL response\n");
		return;
	}

	if (tTd(64, 10))
		sm_dprintf("%s\n", response);
	if (MilterLogLevel > 8)
		sm_syslog(LOG_INFO, e->e_id, "Milter add: rcpt: %s", response);

	argv = milter_split_response(response, rlen, &argc);
	if (argc < 1 || argc > 2)
	{
		if (tTd(64, 10))
			sm_dprintf("didn't follow protocol argc=%d\n", argc);
		return;
	}
	olderrors = Errors;

	/* how to set ESMTP arguments? */
	a = parseaddr(argv[0], NULLADDR, RF_COPYALL, ' ', &delimptr, e, true);

	if (a != NULL && olderrors == Errors)
	{
		parse_esmtp_args(e, a, argv[0], argv[1], "RCPT", NULL,
				rcpt_esmtp_args);
		if (olderrors == Errors)
			a = recipient(a, &e->e_sendqueue, 0, e);
		else
			sm_dprintf("olderrors=%d, Errors=%d\n",
				olderrors, Errors);
	}
	else
	{
		sm_dprintf("a=%p, olderrors=%d, Errors=%d\n",
			a, olderrors, Errors);
	}

	Errors = olderrors;
	return;
}

a2979 1

d3013 1
a3013 2
			sm_dprintf("didn't follow protocol (total len %d != rlen %d)\n",
				   (int) strlen(response), (int) (rlen - 1));
a3024 1

d3058 1
a3058 1
				  sizeof(dfname));
a3185 1
**		milters -- milters structure.
d3193 1
a3193 1
milter_init(e, state, milters)
a3195 1
	milters_T *milters;
a3201 1
	memset(milters, '\0', sizeof(*milters));
d3223 1
a3223 1
		    milter_negotiate(m, e, milters) < 0 ||
a3260 1

d3323 1
a3323 1
				       sizeof(buf6));
d3345 2
a3346 2
	(void) memcpy(bp, &family, sizeof(family));
	bp += sizeof(family);
d3349 2
a3350 2
		(void) memcpy(bp, &port, sizeof(port));
		bp += sizeof(port);
d3356 2
a3357 2
	response = milter_command(SMFIC_CONNECT, buf, s, MilterConnectMacros,
				e, state, "connect", false);
a3399 1

d3444 1
a3444 1
				  MilterHeloMacros, e, state, "helo", false);
a3447 1

d3528 1
a3528 1
		sm_syslog(LOG_INFO, e->e_id, "Milter: sender: %s", buf);
d3531 2
a3532 2
	response = milter_command(SMFIC_MAIL, buf, s, MilterEnvFromMacros,
				e, state, "mail", false);
d3543 1
a3543 1
		sm_syslog(LOG_INFO, e->e_id, "Milter: reject, sender");
a3553 1
**		rcpt_error -- does RCPT have an error?
d3560 1
a3560 1
milter_envrcpt(args, e, state, rcpt_error)
a3563 1
	bool rcpt_error;
d3610 2
a3611 2
	response = milter_command(SMFIC_RCPT, buf, s, MilterEnvRcptMacros,
				e, state, "rcpt", rcpt_error);
d3616 1
d3637 1
a3637 2
	return milter_command(SMFIC_DATA, NULL, 0, MilterDataMacros, e, state,
				"data", false);
d3639 1
a3746 7
			if (MilterEOHMacros[0] != NULL)
			{
				milter_send_macros(m, MilterEOHMacros,
					   SMFIC_EOH, e);
				MILTER_CHECK_RESULTS();
			}

d3749 1
a3749 1
						       e, state, "eoh");
a3762 1
		{
a3764 2
			MILTER_CHECK_RESULTS();
		}
d3768 1
a3768 1
				    m->mf_timeout[SMFTO_WRITE], e, "eom");
d3793 1
a3793 2
					       m->mf_timeout[SMFTO_READ], e,
						"body");
d3877 1
a3877 1
				milter_addheader(m, response, rlen, e);
d3888 1
a3888 1
				milter_insheader(m, response, rlen, e);
d3899 1
a3899 12
				milter_changeheader(m, response, rlen, e);
				break;

			  case SMFIR_CHGFROM:
				if (!bitset(SMFIF_CHGFROM, m->mf_fflags))
				{
					if (MilterLogLevel > 9)
						sm_syslog(LOG_WARNING, e->e_id,
							  "milter_data(%s) lied about changing sender, honoring request anyway",
							  m->mf_name);
				}
				milter_chgfrom(response, rlen, e);
a3912 11
			  case SMFIR_ADDRCPT_PAR:
				if (!bitset(SMFIF_ADDRCPT_PAR, m->mf_fflags))
				{
					if (MilterLogLevel > 9)
						sm_syslog(LOG_WARNING, e->e_id,
							  "milter_data(%s) lied about adding recipients with parameters, honoring request anyway",
							  m->mf_name);
				}
				milter_addrcpt_par(response, rlen, e);
				break;

d4041 1
d4047 1
a4047 1
**		smtpcmd -- the string itself.
d4057 2
a4058 2
milter_unknown(smtpcmd, e, state)
	char *smtpcmd;
d4063 1
a4063 1
		sm_dprintf("milter_unknown(%s)\n", smtpcmd);
d4065 2
a4066 2
	return milter_command(SMFIC_UNKNOWN, smtpcmd, strlen(smtpcmd) + 1,
				NULL, e, state, "unknown", false);
d4068 1
a4091 1

@


1.1.127.2
log
@Import sendmail.8.14.5.Beta0.tar.gz
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2009 Sendmail, Inc. and its suppliers.
d13 1
a13 1
SM_RCSID("@@(#)$Id: milter.c,v 8.277 2009/11/06 00:57:06 ca Exp $")
d517 1
d535 2
a536 6
		{
			sm_dprintf("milter_write(%s): length %ld out of range, cmd=%c\n",
				m->mf_name, (long) len, command);
			sm_dprintf("milter_write(%s): buf=%s\n",
				m->mf_name, str2prt(buf));
		}
d539 2
a540 2
				  "milter_write(%s): length %ld out of range, cmd=%c",
				  m->mf_name, (long) len, command);
d597 2
d600 1
d1575 1
a1575 1
# if _FFR_MAXDATASIZE || _FFR_MDS_NEGOTIATE
d1578 1
a1578 1
# endif /* _FFR_MAXDATASIZE || _FFR_MDS_NEGOTIATE */
d1634 1
a1634 1
# if _FFR_MAXDATASIZE || _FFR_MDS_NEGOTIATE
a1635 1
#  if _FFR_MDS_NEGOTIATE
a1636 17
		if (MilterMaxDataSize != MILTER_MDS_64K &&
		    MilterMaxDataSize != MILTER_MDS_256K &&
		    MilterMaxDataSize != MILTER_MDS_1M)
		{
			sm_syslog(LOG_WARNING, NOQID,
				"WARNING: Milter.%s=%d, allowed are only %d, %d, and %d",
				name, MilterMaxDataSize,
				MILTER_MDS_64K, MILTER_MDS_256K,
				MILTER_MDS_1M);
			if (MilterMaxDataSize < MILTER_MDS_64K)
				MilterMaxDataSize = MILTER_MDS_64K;
			else if (MilterMaxDataSize < MILTER_MDS_256K)
				MilterMaxDataSize = MILTER_MDS_256K;
			else
				MilterMaxDataSize = MILTER_MDS_1M;
		}
#  endif /* _FFR_MDS_NEGOTIATE */
d1638 1
a1638 1
# endif /* _FFR_MAXDATASIZE || _FFR_MDS_NEGOTIATE */
a2413 6
#if _FFR_MDS_NEGOTIATE
	if (MilterMaxDataSize == MILTER_MDS_256K)
		mta_prot_flags |= SMFIP_MDS_256K;
	else if (MilterMaxDataSize == MILTER_MDS_1M)
		mta_prot_flags |= SMFIP_MDS_1M;
#endif /* _FFR_MDS_NEGOTIATE */
a2527 33
#if _FFR_MDS_NEGOTIATE
	/* use a table instead of sequence? */
	if (bitset(SMFIP_MDS_1M, m->mf_pflags))
	{
		if (MilterMaxDataSize != MILTER_MDS_1M)
		{
			/* this should not happen... */
			sm_syslog(LOG_WARNING, NOQID,
				  "WARNING: Milter.maxdatasize: configured=%d, set by libmilter=%d",
		    		  MilterMaxDataSize, MILTER_MDS_1M);
			MilterMaxDataSize = MILTER_MDS_1M;
		}
	}
	else if (bitset(SMFIP_MDS_256K, m->mf_pflags))
	{
		if (MilterMaxDataSize != MILTER_MDS_256K)
		{
			sm_syslog(LOG_WARNING, NOQID,
				  "WARNING: Milter.maxdatasize: configured=%d, set by libmilter=%d",
		    		  MilterMaxDataSize, MILTER_MDS_256K);
			MilterMaxDataSize = MILTER_MDS_256K;
		}
	}
	else if (MilterMaxDataSize != MILTER_MDS_64K)
	{
		sm_syslog(LOG_WARNING, NOQID,
			  "WARNING: Milter.maxdatasize: configured=%d, set by libmilter=%d",
	    		  MilterMaxDataSize, MILTER_MDS_64K);
		MilterMaxDataSize = MILTER_MDS_64K;
	}
	m->mf_pflags &= ~SMFI_INTERNAL;
#endif /* _FFR_MDS_NEGOTIATE */

d2979 1
a2979 1
			h->h_value = addleadingspace(mh_value, e->e_rpool);
d3280 1
a3280 1
			h->h_value = addleadingspace(mh_value, e->e_rpool);
d3333 1
a3333 1
	s = (char **)malloc((nelem + 1) * (sizeof(*s)));
d3816 1
a3816 1
			/* if negotiation failure, close socket */
d4386 1
a4386 1
						"eom");
@


1.1.127.3
log
@Import sendmail 8.14.6 via mircvs://contrib/samples/import-3rdpty
@
text
@d13 1
a13 1
SM_RCSID("@@(#)$Id: milter.c,v 8.279 2012/11/16 20:25:03 ca Exp $")
d45 1
a45 1
static char	*milter_command __P((int, void *, ssize_t, int,
d82 7
a88 7
/*
**  MilterMacros contains the milter macros for each milter and each stage.
**  indices are (in order): stages, milter-index, macro
**  milter-index == 0: "global" macros (not for a specific milter).
*/

static char *MilterMacros[SMFIM_LAST + 1][MAXFILTERS + 1][MAXFILTERMACROS + 1];
a100 10
/* set state in case of an error */
# define MILTER_SET_STATE	\
	if (bitnset(SMF_TEMPFAIL, m->mf_flags)) \
		*state = SMFIR_TEMPFAIL; \
	else if (bitnset(SMF_TEMPDROP, m->mf_flags)) \
		*state = SMFIR_SHUTDOWN; \
	else if (bitnset(SMF_REJECT, m->mf_flags)) \
		*state = SMFIR_REJECT

/* flow through code maybe using continue; don't wrap in do {} while */
d122 6
a127 1
	else MILTER_SET_STATE;	\
a1223 1
	static int idx = 0;
a1325 1
	{
a1326 2
		m->mf_idx = ++idx;
	}
d1558 14
a1571 7
	{ "macros.connect",		SMFIM_CONNECT			},
	{ "macros.helo",		SMFIM_HELO			},
	{ "macros.envfrom",		SMFIM_ENVFROM			},
	{ "macros.envrcpt",		SMFIM_ENVRCPT			},
	{ "macros.data",		SMFIM_DATA			},
	{ "macros.eom",			SMFIM_EOM			},
	{ "macros.eoh",			SMFIM_EOH			},
d1658 33
a1690 8
	  case SMFIM_CONNECT:
	  case SMFIM_HELO:
	  case SMFIM_ENVFROM:
	  case SMFIM_ENVRCPT:
	  case SMFIM_EOH:
	  case SMFIM_EOM:
	  case SMFIM_DATA:
		macros = MilterMacros[mo->mo_code][0];
d2191 1
a2191 1
		milter_error(m, e); /* NO ERROR CHECK? */
d2221 1
a2221 1
milter_command(cmd, data, sz, stage, e, state, where, cmd_error)
d2225 1
a2225 1
	int stage;
d2257 2
a2258 1
		if (stage >= SMFIM_FIRST && stage <= SMFIM_LAST)
d2260 2
a2261 12
			int idx;
			char **macros;

			if ((m->mf_lflags & MI_LFLAGS_SYM(stage)) != 0)
				idx = m->mf_idx;
			else
				idx = 0;
			SM_ASSERT(idx >= 0 && idx <= MAXFILTERS);
			macros = MilterMacros[stage][idx];

			/* send macros (regardless of whether we send cmd) */
			if (macros != NULL && macros[0] != NULL)
d2263 2
a2264 6
				milter_send_macros(m, macros, command, e);
				if (m->mf_state == SMFS_ERROR)
				{
					MILTER_CHECK_ERROR(false, continue);
					break;
				}
d2332 33
a2364 9
		  case SMFIM_CONNECT:
		  case SMFIM_HELO:
		  case SMFIM_ENVFROM:
		  case SMFIM_ENVRCPT:
		  case SMFIM_EOH:
		  case SMFIM_EOM:
		  case SMFIM_DATA:
			SM_ASSERT(m->mf_idx > 0 && m->mf_idx < MAXFILTERS);
			macros = MilterMacros[i][m->mf_idx];
a2365 1
			m->mf_lflags |= MI_LFLAGS_SYM(i);
a2372 3
				if (tTd(64, 5))
					sm_dprintf("milter_getsymlist(%s, %s)=%d\n",
						m->mf_name, buf + offset, r);
d3992 1
a3992 1
	response = milter_command(SMFIC_CONNECT, buf, s, SMFIM_CONNECT,
d4081 1
a4081 1
				  SMFIM_EOH, e, state, "helo", false);
d4169 1
a4169 1
	response = milter_command(SMFIC_MAIL, buf, s, SMFIM_ENVFROM,
d4250 1
a4250 1
	response = milter_command(SMFIC_RCPT, buf, s, SMFIM_ENVRCPT,
d4276 2
a4277 2
	return milter_command(SMFIC_DATA, NULL, 0, SMFIM_DATA,
				e, state, "data", false);
a4295 1
/* flow through code using continue; don't wrap in do {} while */
a4296 4
	if (m->mf_state == SMFS_ERROR && *state == SMFIR_CONTINUE) \
	{ \
			MILTER_SET_STATE;	\
	} \
a4341 2
		int idx;
		char **macros;
d4386 1
a4386 8
			if ((m->mf_lflags & MI_LFLAGS_SYM(SMFIM_EOH)) != 0)
				idx = m->mf_idx;
			else
				idx = 0;
			SM_ASSERT(idx >= 0 && idx <= MAXFILTERS);
			macros = MilterMacros[SMFIM_EOH][idx];

			if (macros != NULL)
d4388 2
a4389 1
				milter_send_macros(m, macros, SMFIC_EOH, e);
d4408 1
a4408 7
		if ((m->mf_lflags & MI_LFLAGS_SYM(SMFIM_EOH)) != 0)
			idx = m->mf_idx;
		else
			idx = 0;
		SM_ASSERT(idx >= 0 && idx <= MAXFILTERS);
		macros = MilterMacros[SMFIM_EOM][idx];
		if (macros != NULL)
d4410 2
a4411 1
			milter_send_macros(m, macros, SMFIC_BODYEOB, e);
d4737 1
a4737 1
				SMFIM_NOMACROS, e, state, "unknown", false);
@


1.1.127.4
log
@Update
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2009, 2012, 2013 Sendmail, Inc. and its suppliers.
d13 1
a13 1
SM_RCSID("@@(#)$Id: milter.c,v 8.280 2013/01/16 18:48:36 ca Exp $")
d2187 1
a2187 1
**		stage -- index of macros to send for filter smfi_getsymval().
d2331 1
d4051 1
a4051 1
				  SMFIM_HELO, e, state, "helo", false);
@


1.1.127.5
log
@Import sendmail 8.14.9
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2009, 2012, 2013 Proofpoint, Inc. and its suppliers.
d13 1
a13 1
SM_RCSID("@@(#)$Id: milter.c,v 8.281 2013-11-22 20:51:56 ca Exp $")
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@I persuaded myself to import another fix... though sendmail needed
much less updates/fixes recently than any other MTA (except qmll)
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2005 Sendmail, Inc. and its suppliers.
d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.229 2005/03/02 02:32:34 ca Exp $")
a352 10
	if (m->mf_sock < 0)
	{
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "milter_read(%s): socket closed",
				  m->mf_name);
		milter_error(m, e);
		return NULL;
	}

a489 9
	if (m->mf_sock < 0)
	{
		if (MilterLogLevel > 0)
			sm_syslog(LOG_ERR, e->e_id,
				  "milter_write(%s): socket closed",
				  m->mf_name);
		milter_error(m, e);
		return NULL;
	}
d1855 1
a1855 1
	sm_free(buf);
a3762 1
		{
a3764 2
			MILTER_CHECK_RESULTS();
		}
@


1.1.1.2.2.1
log
@MFC most of the recent sendmail updates to MirOS #8-stable
agreed bsiegert@@

This also changes the LOCALBASE stuff, links libmilter not
against LDAP, etc. but doesn't install the FreeBSD 6 confs
nor a shared libmilter in order to pass a no-files-diff:

tg@@maou:/usr/src/gnu/usr.sbin/sendmail $ sudo find / -ls | sort -k11 >~/x1
tg@@maou:/usr/src/gnu/usr.sbin/sendmail $ sudo make install
tg@@maou:/usr/src/gnu/usr.sbin/sendmail/cf/cf $ sudo make distribution
tg@@maou:/usr/src/gnu/usr.sbin/sendmail/cf/cf $ sudo find / -ls | sort -k11 | diff -u ~/x1 - | less

Note: files in /etc/mail/ are also changed, this affects the etc8.ngz set
on fresh installs and cannot(!) be automatically upgraded!
@
text
@d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.232 2005/08/05 21:49:04 ca Exp $")
d20 1
a20 1
# include <sm/time.h>
a1964 1
		skipflag = SMFIP_NOUNKNOWN;
a1969 8
#if SMFI_VERSION > 3
	  case SMFIC_DATA:
		skipflag = SMFIP_NODATA;
		action = "data";
		defresponse = "550 5.7.1 Command rejected";
		break;
#endif /* SMFI_VERSION > 3 */

d2187 1
a2187 1
	mi_int32 curr_prot;
a2188 1
	char *response;
d2204 1
a2204 12
	curr_prot = SMFI_V2_PROT
#if _FFR_MILTER_NOHDR_RESP
			| SMFIP_NOHREPL
#endif /* _FFR_MILTER_NOHDR_RESP */
#if SMFI_VERSION >= 3
			| SMFIP_NOUNKNOWN
# if SMFI_VERSION >= 4
			| SMFIP_NODATA
# endif /* SMFI_VERSION >= 4 */
#endif /* SMFI_VERSION >= 3 */
			;
	pflags = htonl(curr_prot);
d2313 1
a2313 1
	if ((m->mf_pflags & curr_prot) != m->mf_pflags)
d2318 1
a2318 1
				(unsigned long) curr_prot);
d2323 1
a2323 1
				  (unsigned long) curr_prot);
a2327 5
	if (m->mf_fvers <= 2)
		m->mf_pflags |= SMFIP_NOUNKNOWN;
	if (m->mf_fvers <= 3)
		m->mf_pflags |= SMFIP_NODATA;

d2692 4
a2695 4
**	Notes:
**		Unlike milter_addheader(), this does not attempt to determine
**		if the header already exists in the envelope, even a
**		deleted version.  It just blindly inserts.
d2755 1
a2755 1
			  "Milter insert (%d): header: %s: %s",
@


1.1.1.3
log
@Update to Sendmail 8.13.6
@
text
@d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.232 2005/08/05 21:49:04 ca Exp $")
d20 1
a20 1
# include <sm/time.h>
a1964 1
		skipflag = SMFIP_NOUNKNOWN;
a1969 8
#if SMFI_VERSION > 3
	  case SMFIC_DATA:
		skipflag = SMFIP_NODATA;
		action = "data";
		defresponse = "550 5.7.1 Command rejected";
		break;
#endif /* SMFI_VERSION > 3 */

d2187 1
a2187 1
	mi_int32 curr_prot;
a2188 1
	char *response;
d2204 1
a2204 12
	curr_prot = SMFI_V2_PROT
#if _FFR_MILTER_NOHDR_RESP
			| SMFIP_NOHREPL
#endif /* _FFR_MILTER_NOHDR_RESP */
#if SMFI_VERSION >= 3
			| SMFIP_NOUNKNOWN
# if SMFI_VERSION >= 4
			| SMFIP_NODATA
# endif /* SMFI_VERSION >= 4 */
#endif /* SMFI_VERSION >= 3 */
			;
	pflags = htonl(curr_prot);
d2313 1
a2313 1
	if ((m->mf_pflags & curr_prot) != m->mf_pflags)
d2318 1
a2318 1
				(unsigned long) curr_prot);
d2323 1
a2323 1
				  (unsigned long) curr_prot);
a2327 5
	if (m->mf_fvers <= 2)
		m->mf_pflags |= SMFIP_NOUNKNOWN;
	if (m->mf_fvers <= 3)
		m->mf_pflags |= SMFIP_NODATA;

d2692 4
a2695 4
**	Notes:
**		Unlike milter_addheader(), this does not attempt to determine
**		if the header already exists in the envelope, even a
**		deleted version.  It just blindly inserts.
d2755 1
a2755 1
			  "Milter insert (%d): header: %s: %s",
@


1.1.1.4
log
@Import Sendmail 8.14.0 via OpenBSD
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2006 Sendmail, Inc. and its suppliers.
d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.266 2006/11/29 00:20:41 ca Exp $")
a15 1
# include <sm/sendmail.h>
d25 1
a25 1
#  if MILTER_NO_NAGLE
d27 1
a27 1
#  endif /* MILTER_NO_NAGLE */
a35 43
static char	*milter_sysread __P((struct milter *, char *, ssize_t, time_t,
			ENVELOPE *, const char *));
static char	*milter_read __P((struct milter *, char *, ssize_t *, time_t,
			ENVELOPE *, const char *));
static char	*milter_write __P((struct milter *, int, char *, ssize_t,
			time_t, ENVELOPE *, const char *));
static char	*milter_send_command __P((struct milter *, int, void *,
			ssize_t, ENVELOPE *, char *, const char *));
static char	*milter_command __P((int, void *, ssize_t, char **,
			ENVELOPE *, char *, const char *, bool));
static char	*milter_body __P((struct milter *, ENVELOPE *, char *));
static int	milter_reopen_df __P((ENVELOPE *));
static int	milter_reset_df __P((ENVELOPE *));
static void	milter_quit_filter __P((struct milter *, ENVELOPE *));
static void	milter_abort_filter __P((struct milter *, ENVELOPE *));
static void	milter_send_macros __P((struct milter *, char **, int,
			ENVELOPE *));
static int	milter_negotiate __P((struct milter *, ENVELOPE *));
static void	milter_per_connection_check __P((ENVELOPE *));
static char	*milter_headers __P((struct milter *, ENVELOPE *, char *));
static void	milter_addheader __P((struct milter *, char *, ssize_t,
			ENVELOPE *));
static void	milter_insheader __P((struct milter *, char *, ssize_t,
			ENVELOPE *));
static void	milter_changeheader __P((struct milter *, char *, ssize_t,
			ENVELOPE *));
static void	milter_chgfrom __P((char *, ssize_t, ENVELOPE *));
static void	milter_addrcpt __P((char *, ssize_t, ENVELOPE *));
static void	milter_addrcpt_par __P((char *, ssize_t, ENVELOPE *));
static void	milter_delrcpt __P((char *, ssize_t, ENVELOPE *));
static int	milter_replbody __P((char *, ssize_t, bool, ENVELOPE *));
static int	milter_set_macros __P((char *, char **, char *, int));


/* milter states */
# define SMFS_CLOSED		'C'	/* closed for all further actions */
# define SMFS_OPEN		'O'	/* connected to remote milter filter */
# define SMFS_INMSG		'M'	/* currently servicing a message */
# define SMFS_DONE		'D'	/* done with current message */
# define SMFS_CLOSABLE		'Q'	/* done with current connection */
# define SMFS_ERROR		'E'	/* error state */
# define SMFS_READY		'R'	/* ready for action */
# define SMFS_SKIP		'S'	/* skip body */
a42 1
static char *MilterEOHMacros[MAXFILTERMACROS + 1];
d149 1
a149 1
# define MILTER_TIMEOUT(routine, secs, write, started, function) \
d187 2
a188 2
			sm_dprintf("milter_%s(%s): timeout, where=%s\n", \
				(routine), m->mf_name, (function)); \
d191 2
a192 2
				  "Milter (%s): timeout %s data %s, where=%s", \
				  m->mf_name, \
d194 1
a194 1
				  (routine), (function)); \
d249 1
a249 1
milter_sysread(m, buf, sz, to, e, where)
a254 1
	const char *where;
d275 2
a276 2
					sm_dprintf("milter_sys_read (%s): timeout %s data read in %s",
						  m->mf_name,
d278 1
a278 1
						  where);
d281 2
a282 2
						  "Milter (%s): timeout %s data read in %s",
						  m->mf_name,
d284 1
a284 1
						  where);
d290 1
a290 1
			MILTER_TIMEOUT("read", to, false, started, where);
d300 1
a300 1
				sm_dprintf("milter_sys_read(%s): read returned %ld: %s\n",
d322 1
a322 1
			sm_dprintf("milter_sys_read(%s): cmd read returned %ld, expecting %ld\n",
d326 1
a326 1
				  "milter_sys_read(%s): cmd read returned %ld, expecting %ld",
d335 1
a335 1
milter_read(m, cmd, rlen, to, e, where)
a340 1
	const char *where;
d345 2
a346 1
# if MILTER_NO_NAGLE && defined(TCP_CORK)
d348 2
a349 1
# endif /* MILTER_NO_NAGLE && defined(TCP_CORK) */
d357 2
a358 2
				  "milter_read(%s): socket closed, where=%s",
				  m->mf_name, where);
d369 2
a370 1
# if MILTER_NO_NAGLE && defined(TCP_CORK)
d373 2
a374 1
# endif /* MILTER_NO_NAGLE && defined(TCP_CORK) */
d376 1
a376 1
	if (milter_sysread(m, data, sizeof(data), to, e, where) == NULL)
d379 2
a380 1
# if MILTER_NO_NAGLE && defined(TCP_CORK)
d384 2
a385 1
# endif /* MILTER_NO_NAGLE && defined(TCP_CORK) */
d396 2
a397 2
				sm_dprintf("milter_read(%s): timeout before data read, where=%s\n",
					m->mf_name, where);
d400 2
a401 2
					  "Milter read(%s): timeout before data read, where=%s",
					  m->mf_name, where);
d420 2
a421 2
			sm_dprintf("milter_read(%s): read size %ld out of range, where=%s\n",
				m->mf_name, (long) expl, where);
d424 2
a425 2
				  "milter_read(%s): read size %ld out of range, where=%s",
				  m->mf_name, (long) expl, where);
d435 1
a435 1
	if (milter_sysread(m, buf, expl, to, e, where) == NULL)
d466 1
a466 1
milter_write(m, cmd, buf, len, to, e, where)
d468 1
a468 1
	int cmd;
a472 1
	const char *where;
a477 1
	char command = (char) cmd;
d512 1
a512 1
			   m->mf_name, command, (long) len);
d514 1
a514 1
	nl = htonl(len + 1);	/* add 1 for the command char */
d516 1
a516 1
	data[MILTER_LEN_BYTES] = command;
d555 1
a555 1
		MILTER_TIMEOUT("write", to, true, started, where);
d566 1
a566 1
				   m->mf_name, command, (long) i, (long) sl,
d571 1
a571 1
				  m->mf_name, command, (long) i, (long) sl,
d632 1
a632 1
	memset(&addr, '\0', sizeof(addr));
d712 1
a712 1
		if (strlen(colon) >= sizeof(addr.sunix.sun_path))
d765 2
a766 2
			       sizeof(addr.sunix.sun_path));
		addrlen = sizeof(struct sockaddr_un);
d818 1
a818 1
			struct servent *sp;
d868 1
a868 1
				(void) memset(&hid6, '\0', sizeof(hid6));
d939 1
a939 1
				addrlen = sizeof(struct sockaddr_in);
d949 1
a949 1
				addrlen = sizeof(struct sockaddr_in6);
d1137 2
a1138 1
# if MILTER_NO_NAGLE && !defined(TCP_CORK)
d1145 2
a1146 1
# endif /* MILTER_NO_NAGLE && !defined(TCP_CORK) */
a1162 1

d1178 2
a1179 2
	char *p;
	struct milter *m;
d1194 2
a1195 2
	m = (struct milter *) xalloc(sizeof(*m));
	memset((char *) m, '\0', sizeof(*m));
a1202 5
#if MILTER_CHECK
	m->mf_mta_prot_version = SMFI_PROT_VERSION;
	m->mf_mta_prot_flags = SMFI_CURR_PROT;
	m->mf_mta_actions = SMFI_CURR_ACTS;
#endif /* MILTER_CHECK */
a1249 12
#if MILTER_CHECK
		  case 'a':
			m->mf_mta_actions = strtoul(p, NULL, 0);
			break;
		  case 'f':
			m->mf_mta_prot_flags = strtoul(p, NULL, 0);
			break;
		  case 'v':
			m->mf_mta_prot_version = strtoul(p, NULL, 0);
			break;
#endif /* MILTER_CHECK */

a1267 1

d1289 1
a1289 1
	char *p;
a1329 1

d1350 1
a1350 1
	char *p;
a1416 57

/*
**  MILTER_SET_MACROS -- set milter macros
**
**	Parameters:
**		name -- name of milter.
**		macros -- where to store macros.
**		val -- the value of the option.
**		nummac -- current number of macros
**
**	Returns:
**		new number of macros
*/

static int
milter_set_macros(name, macros, val, nummac)
	char *name;
	char **macros;
	char *val;
	int nummac;
{
	char *p;

	p = newstr(val);
	while (*p != '\0')
	{
		char *macro;

		/* Skip leading commas, spaces */
		while (*p != '\0' &&
		       (*p == ',' || (isascii(*p) && isspace(*p))))
			p++;

		if (*p == '\0')
			break;

		/* Find end of macro */
		macro = p;
		while (*p != '\0' && *p != ',' &&
		       isascii(*p) && !isspace(*p))
			p++;
		if (*p != '\0')
			*p++ = '\0';

		if (nummac >= MAXFILTERMACROS)
		{
			syserr("milter_set_option: too many macros in Milter.%s (max %d)",
			       name, MAXFILTERMACROS);
			macros[nummac] = NULL;
			return -1;
		}
		macros[nummac++] = macro;
	}
	macros[nummac] = NULL;
	return nummac;
}

d1439 1
a1439 1
# define MO_MACROS_CONNECT		SMFIM_CONNECT
d1441 1
a1441 1
# define MO_MACROS_HELO			SMFIM_HELO
d1443 1
a1443 1
# define MO_MACROS_ENVFROM		SMFIM_ENVFROM
d1445 1
a1445 1
# define MO_MACROS_ENVRCPT		SMFIM_ENVRCPT
d1447 1
a1447 1
# define MO_MACROS_DATA			SMFIM_DATA
d1449 1
a1449 1
# define MO_MACROS_EOM			SMFIM_EOM
a1450 3
# define MO_MACROS_EOH			SMFIM_EOH
	{ "macros.eoh",			MO_MACROS_EOH			},

d1454 1
a1454 1
#  define MO_MAXDATASIZE		0x08
d1457 1
a1457 1
	{ NULL,				(unsigned char)-1		},
d1466 3
a1468 2
	int nummac, r;
	struct milteropt *mo;
a1470 1
	nummac = 0;
a1537 5
	  case MO_MACROS_EOH:
		if (macros == NULL)
			macros = MilterEOHMacros;
		/* FALLTHROUGH */

d1547 31
a1577 3
		r = milter_set_macros(name, macros, val, nummac);
		if (r >= 0)
			nummac = r;
a1586 1

d1603 1
a1603 1
	(void) sm_strlcpy(dfname, queuename(e, DATAFL_LETTER), sizeof(dfname));
a1640 1

d1658 1
a1658 1
	(void) sm_strlcpy(dfname, queuename(e, DATAFL_LETTER), sizeof(dfname));
a1691 1

a1725 1

d1762 1
a1762 1
			    m->mf_timeout[SMFTO_WRITE], e, "quit_filter");
a1770 1

d1798 1
a1798 1
			    m->mf_timeout[SMFTO_WRITE], e, "abort_filter");
a1801 1

d1819 1
a1819 1
	int cmd;
a1823 1
	char command = (char) cmd;
d1852 1
a1852 1
	*bp++ = command;
d1865 1
a1865 1
				m->mf_name, command, macros[i], exp);
d1873 1
a1873 1
			    m->mf_timeout[SMFTO_WRITE], e, "send_macros");
d1882 1
a1882 1
**		cmd -- command to send.
d1893 1
a1893 1
milter_send_command(m, cmd, data, sz, e, state, where)
d1895 1
a1895 1
	int cmd;
a1899 1
	const char *where;
d1904 1
d1906 1
a1906 1
	char command = (char) cmd;
a1919 1
		norespflag = SMFIP_NR_CONN;
a1925 1
		norespflag = SMFIP_NR_HELO;
a1931 1
		norespflag = SMFIP_NR_MAIL;
a1937 1
		norespflag = SMFIP_NR_RCPT;
d1944 3
a1946 1
		norespflag = SMFIP_NR_HDR;
a1952 1
		norespflag = SMFIP_NR_BODY;
a1958 1
		norespflag = SMFIP_NR_EOH;
d1963 1
a1965 1
		norespflag = SMFIP_NR_UNKN;
d1969 1
d1971 1
a1973 1
		norespflag = SMFIP_NR_DATA;
d1977 1
a1993 4
	if (tTd(64, 10))
		sm_dprintf("milter_send_command(%s): skip=%lx, pflags=%x\n",
			m->mf_name, skipflag, m->mf_pflags);

d1995 2
a1996 1
	if (skipflag != 0 && bitset(skipflag, m->mf_pflags))
d2001 1
a2001 1
			    m->mf_timeout[SMFTO_WRITE], e, where);
d2008 1
d2012 1
d2016 1
a2016 1
			       m->mf_timeout[SMFTO_READ], e, where);
d2032 1
a2032 2
			sm_syslog(LOG_INFO, e->e_id,
				  "milter=%s, action=%s, reject=%s",
d2039 1
a2039 2
			sm_syslog(LOG_INFO, e->e_id,
				  "milter=%s, action=%s, reject",
d2046 1
a2046 2
			sm_syslog(LOG_INFO, e->e_id,
				  "milter=%s, action=%s, discard",
d2053 1
a2053 2
			sm_syslog(LOG_INFO, e->e_id,
				  "milter=%s, action=%s, tempfail",
d2066 1
a2066 2
			sm_syslog(LOG_INFO, e->e_id,
				  "milter=%s, action=%s, accepted",
d2075 1
a2075 9
			sm_syslog(LOG_INFO, e->e_id,
				  "milter=%s, action=%s, continue",
				  m->mf_name, action);
		break;

	  case SMFIR_SKIP:
		if (MilterLogLevel > 12)
			sm_syslog(LOG_INFO, e->e_id,
				  "milter=%s, action=%s, skip",
a2076 1
		m->mf_state = SMFS_SKIP;
d2089 2
a2090 1
	if (*state != SMFIR_REPLYCODE && response != NULL)
d2102 1
a2102 1
**		cmd -- command to send.
a2107 2
**		where -- description of calling function (logging).
**		cmd_error -- did the SMTP command cause an error?
d2114 2
a2115 2
milter_command(cmd, data, sz, macros, e, state, where, cmd_error)
	int cmd;
a2120 2
	const char *where;
	bool cmd_error;
a2122 1
	char command = (char) cmd;
d2128 1
a2128 1
			command, (long) sz);
d2161 1
a2161 16
		/*
		**  send the command if
		**	there is no error
		**	or it's RCPT and the client asked for it:
		**	!cmd_error ||
		**	where == "rcpt" && m->mf_pflags & SMFIP_RCPT_REJ != 0
		**  negate that condition and use continue
		*/

		if (cmd_error &&
		    (strcmp(where, "rcpt") != 0 ||
		     (m->mf_pflags & SMFIP_RCPT_REJ) == 0))
			continue;

		response = milter_send_command(m, command, data, sz, e, state,
						where);
a2175 86

static int milter_getsymlist __P((struct milter *, char *, int, int));

static int
milter_getsymlist(m, buf, rlen, offset)
	struct milter *m;
	char *buf;
	int rlen;
	int offset;
{
	int i, r, nummac;
	mi_int32 v;

	SM_ASSERT(m != NULL);
	SM_ASSERT(buf != NULL);

	while (offset + MILTER_LEN_BYTES < rlen)
	{
		size_t len;
		char **macros;

		nummac = 0;
		(void) memcpy((char *) &v, buf + offset, MILTER_LEN_BYTES);
		i = ntohl(v);
		if (i < SMFIM_FIRST || i > SMFIM_LAST)
			return -1;
		offset += MILTER_LEN_BYTES;
		macros = NULL;

		switch (i)
		{
		  case MO_MACROS_CONNECT:
			if (macros == NULL)
				macros = MilterConnectMacros;
			/* FALLTHROUGH */

		  case MO_MACROS_HELO:
			if (macros == NULL)
				macros = MilterHeloMacros;
			/* FALLTHROUGH */

		  case MO_MACROS_ENVFROM:
			if (macros == NULL)
				macros = MilterEnvFromMacros;
			/* FALLTHROUGH */

		  case MO_MACROS_ENVRCPT:
			if (macros == NULL)
				macros = MilterEnvRcptMacros;
			/* FALLTHROUGH */

		  case MO_MACROS_EOM:
			if (macros == NULL)
				macros = MilterEOMMacros;
			/* FALLTHROUGH */

		  case MO_MACROS_EOH:
			if (macros == NULL)
				macros = MilterEOHMacros;
			/* FALLTHROUGH */

		  case MO_MACROS_DATA:
			if (macros == NULL)
				macros = MilterDataMacros;

			len = strlen(buf + offset);
			if (len > 0)
			{
				r = milter_set_macros(m->mf_name, macros,
						buf + offset, nummac);
				if (r >= 0)
					nummac = r;
			}
			break;

		  default:
			return -1;
		}
		if (len == 0)
			return -1;
		offset += len + 1;
	}

	return 0;
}

d2193 4
a2196 2
	mi_int32 fvers, fflags, pflags;
	mi_int32 mta_prot_vers, mta_prot_flags, mta_actions;
d2212 14
a2225 13
#if MILTER_CHECK
	mta_prot_vers = m->mf_mta_prot_version;
	mta_prot_flags = m->mf_mta_prot_flags;
	mta_actions = m->mf_mta_actions;
#else /* MILTER_CHECK */
	mta_prot_vers = SMFI_PROT_VERSION;
	mta_prot_flags = SMFI_CURR_PROT;
	mta_actions = SMFI_CURR_ACTS;
#endif /* MILTER_CHECK */

	fvers = htonl(mta_prot_vers);
	pflags = htonl(mta_prot_flags);
	fflags = htonl(mta_actions);
d2231 2
a2232 2
	(void) milter_write(m, SMFIC_OPTNEG, data, sizeof(data),
			    m->mf_timeout[SMFTO_WRITE], e, "negotiate");
d2237 1
a2237 6
	if (tTd(64, 5))
		sm_dprintf("milter_negotiate(%s): send: version %lu, fflags 0x%lx, pflags 0x%lx\n",
			m->mf_name, ntohl(fvers), ntohl(fflags), ntohl(pflags));

	response = milter_read(m, &rcmd, &rlen, m->mf_timeout[SMFTO_READ], e,
				"negotiate");
d2276 1
a2276 1
	if (rlen < MILTER_OPTLEN)
d2295 2
d2314 1
a2314 1
		goto error;
d2318 1
a2318 1
	if ((m->mf_fflags & mta_actions) != m->mf_fflags)
d2323 1
a2323 1
				(unsigned long) mta_actions);
d2328 1
a2328 1
				  (unsigned long) mta_actions);
d2330 1
a2330 1
		goto error;
d2334 1
a2334 1
	if ((m->mf_pflags & mta_prot_flags) != m->mf_pflags)
d2339 1
a2339 1
				(unsigned long) mta_prot_flags);
d2344 1
a2344 1
				  (unsigned long) mta_prot_flags);
d2346 1
a2346 1
		goto error;
a2353 5
	if (rlen > MILTER_OPTLEN)
	{
		milter_getsymlist(m, response, rlen, MILTER_OPTLEN);
	}

d2355 1
a2355 1
		sm_dprintf("milter_negotiate(%s): received: version %u, fflags 0x%x, pflags 0x%x\n",
a2357 5

  error:
	if (response != NULL)
		sm_free(response); /* XXX */
	return -1;
a2358 1

a2385 1

a2417 1

d2445 2
a2446 2
		int len_n, len_v, len_t, len_f;
		char *buf, *hv;
d2461 1
a2461 1
			sm_dprintf("milter_headers: %s:%s\n",
d2467 2
a2468 8
		if (bitset(SMFIP_HDR_LEADSPC, m->mf_pflags)
		    || *(h->h_value) != ' ')
			hv = h->h_value;
		else
			hv = h->h_value + 1;
		len_f = strlen(h->h_field) + 1;
		len_t = len_f + strlen(hv) + 1;
		if (len_t < 0)
d2470 3
a2472 13
		buf = (char *) xalloc(len_t);

		/*
		**  Note: currently the call to dequote_internal_chars()
		**  is not required as h_field is supposed to be 7-bit US-ASCII.
		*/

		len_n = dequote_internal_chars(h->h_field, buf, len_f);
		SM_ASSERT(len_n < len_f);
		len_v = dequote_internal_chars(hv, buf + len_n + 1,
						len_t - len_n - 1);
		SM_ASSERT(len_t >= len_n + 1 + len_v + 1);
		len_t = len_n + 1 + len_v + 1;
d2476 2
a2477 2
					       len_t, e, state, "header");
		sm_free(buf);
a2487 1

a2534 1
#if !_FFR_MILTER_CONVERT_ALL_LF_TO_CRLF
a2536 1
#endif /* !_FFR_MILTER_CONVERT_ALL_LF_TO_CRLF */
d2539 1
a2539 1
				if (bp + 2 > &buf[sizeof(buf)])
d2557 1
a2557 1
		if (bp >= &buf[sizeof(buf)])
d2561 1
a2561 2
						       bp - buf, e, state,
							"body chunk");
a2571 1
		    m->mf_state == SMFS_SKIP ||
d2581 1
a2581 2
		    *state == SMFIR_ACCEPT ||
		    m->mf_state == SMFS_SKIP)
a2599 1
	    m->mf_state != SMFS_SKIP &&
d2604 1
a2604 1
					       e, state, "last body chunk");
a2609 6
	if (m->mf_state == SMFS_SKIP)
	{
		*state = SMFIR_CONTINUE;
		m->mf_state = SMFS_READY;
	}

a2617 31
**  ADDLEADINGSPACE -- Add a leading space to a string
**
**	Parameters:
**		str -- string
**		rp -- resource pool for allocations
**
**	Returns:
**		pointer to new string
*/

static char *addleadingspace __P((char *, SM_RPOOL_T *));

static char *
addleadingspace(str, rp)
	char *str;
	SM_RPOOL_T *rp;
{
	size_t l;
	char *new;

	SM_ASSERT(str != NULL);
	l = strlen(str);
	SM_ASSERT(l + 2 > l);
	new = sm_rpool_malloc_x(rp, l + 2);
	new[0] = ' ';
	new[1] = '\0';
	sm_strlcpy(new + 1, str, l + 1);
	return new;
}

/*
a2620 1
**		m -- current filter.
d2630 1
a2630 2
milter_addheader(m, response, rlen, e)
	struct milter *m;
d2635 1
a2635 2
	int mh_v_len;
	char *val, *mh_value;
d2652 1
a2652 2
			sm_dprintf("didn't follow protocol (total len %d != rlen %d)\n",
				   (int) strlen(response), (int) (rlen - 1));
a2681 3
	mh_v_len = 0;
	mh_value = quote_internal_chars(val, NULL, &mh_v_len);

d2689 1
a2689 1
				   h->h_field, mh_value);
d2693 2
a2694 8
				  h->h_field, mh_value);
		if (bitset(SMFIP_HDR_LEADSPC, m->mf_pflags))
			h->h_value = mh_value;
		else
		{
			h->h_value = addleadingspace (mh_value, e->e_rpool);
			SM_FREE(mh_value);
		}
d2700 1
a2700 1
			sm_dprintf("Add %s: %s\n", response, mh_value);
d2702 3
a2704 6
			sm_syslog(LOG_INFO, e->e_id,
				  "Milter add: header: %s: %s",
				  response, mh_value);
		addheader(newstr(response), mh_value, H_USER, e,
			!bitset(SMFIP_HDR_LEADSPC, m->mf_pflags));
		SM_FREE(mh_value);
a2706 1

a2710 1
**		m -- current filter.
d2725 1
a2725 2
milter_insheader(m, response, rlen, e)
	struct milter *m;
d2731 2
a2732 2
	int mh_v_len;
	char *field, *val, *mh_value;
d2778 1
a2778 1
		sm_dprintf("Insert (%d) %s: %s\n", idx, field, val);
d2783 1
a2783 5
	mh_v_len = 0;
	mh_value = quote_internal_chars(val, NULL, &mh_v_len);
	insheader(idx, newstr(field), mh_value, H_USER, e,
		!bitset(SMFIP_HDR_LEADSPC, m->mf_pflags));
	SM_FREE(mh_value);
a2784 1

a2788 1
**		m -- current filter.
d2798 1
a2798 2
milter_changeheader(m, response, rlen, e)
	struct milter *m;
d2804 1
a2804 2
	int mh_v_len;
	char *field, *val, *mh_value;
a2846 3
	mh_v_len = 0;
	mh_value = quote_internal_chars(val, NULL, &mh_v_len);

d2852 2
a2853 1
			if (bitset(H_USER, h->h_flags) && --index <= 0)
d2892 1
a2892 1
				sm_dprintf("Add %s: %s\n", field, mh_value);
d2896 2
a2897 3
					, field, mh_value);
			addheader(newstr(field), mh_value, H_USER, e,
				!bitset(SMFIP_HDR_LEADSPC, m->mf_pflags));
d2906 1
a2906 1
			sm_dprintf("Delete%s %s:%s\n",
d2917 1
a2917 1
				   mh_value);
d2926 1
a2926 1
				  "Milter delete: header%s %s:%s",
d2938 1
a2938 1
				  mh_value);
a2967 1
		SM_FREE(mh_value);
d2971 1
a2971 7
		if (bitset(SMFIP_HDR_LEADSPC, m->mf_pflags))
			h->h_value = mh_value;
		else
		{
			h->h_value = addleadingspace (mh_value, e->e_rpool);
			SM_FREE(mh_value);
		}
a2975 216

/*
**  MILTER_SPLIT_RESPONSE -- Split response into fields.
**
**	Parameters:
**		response -- encoded repsonse.
**		rlen -- length of response.
**		pargc -- number of arguments (ouput)
**
**	Returns:
**		array of pointers to the individual strings
*/

static char **milter_split_response __P((char *, ssize_t, int *));

static char **
milter_split_response(response, rlen, pargc)
	char *response;
	ssize_t rlen;
	int *pargc;
{
	char **s;
	size_t i;
	int elem, nelem;

	SM_ASSERT(response != NULL);
	SM_ASSERT(pargc != NULL);
	*pargc = 0;
	if (rlen < 2 || strlen(response) >= (size_t) rlen)
	{
		if (tTd(64, 10))
			sm_dprintf("didn't follow protocol (total len %d != rlen %d)\n",
				   (int) strlen(response), (int) (rlen - 1));
		return NULL;
	}

	nelem = 0;
	for (i = 0; i < rlen; i++)
	{
		if (response[i] == '\0')
			++nelem;
	}
	if (nelem == 0)
		return NULL;

	/* last entry is only for the name */
	s = (char **)malloc(nelem * (sizeof(*s)));
	if (s == NULL)
		return NULL;
	s[0] = response;
	for (i = 0, elem = 0; i < rlen && elem < nelem; i++)
	{
		if (response[i] == '\0')
		{
			++elem;
			if (i + 1 >= rlen)
				s[elem] = NULL;
			else
				s[elem] = &(response[i + 1]);
		}
	}
	*pargc = nelem;

	if (tTd(64, 10))
	{
		for (elem = 0; elem < nelem; elem++)
			sm_dprintf("argv[%d]=\"%s\"\n", elem, s[elem]);
	}

	/* overwrite last entry (already done above, just paranoia) */
	s[elem] = NULL;
	return s;
}

/*
**  MILTER_CHGFROM -- Change the envelope sender address
**
**	Parameters:
**		response -- encoded form of recipient address.
**		rlen -- length of response.
**		e -- current envelope.
**
**	Returns:
**		none
*/

static void
milter_chgfrom(response, rlen, e)
	char *response;
	ssize_t rlen;
	ENVELOPE *e;
{
	int olderrors, argc;
	char **argv;

	if (tTd(64, 10))
		sm_dprintf("milter_chgfrom: ");

	/* sanity checks */
	if (response == NULL)
	{
		if (tTd(64, 10))
			sm_dprintf("NULL response\n");
		return;
	}

	if (*response == '\0' ||
	    strlen(response) + 1 > (size_t) rlen)
	{
		if (tTd(64, 10))
			sm_dprintf("didn't follow protocol (total len %d != rlen %d)\n",
				   (int) strlen(response), (int) (rlen - 1));
		return;
	}

	if (tTd(64, 10))
		sm_dprintf("%s\n", response);
	if (MilterLogLevel > 8)
		sm_syslog(LOG_INFO, e->e_id, "Milter chgfrom: %s", response);
	argv = milter_split_response(response, rlen, &argc);
	if (argc < 1 || argc > 2)
	{
		if (tTd(64, 10))
			sm_dprintf("didn't follow protocol argc=%d\n", argc);
		return;
	}

	olderrors = Errors;
	setsender(argv[0], e, NULL, '\0', false);
	if (argc == 2)
	{
		reset_mail_esmtp_args(e);

		/*
		**  need "features" here: how to get those? via e?
		**  "fake" it for now: allow everything.
		*/

		parse_esmtp_args(e, NULL, argv[0], argv[1], "MAIL", NULL,
				mail_esmtp_args);
	}
	Errors = olderrors;
	return;
}

/*
**  MILTER_ADDRCPT_PAR -- Add the supplied recipient to the message
**
**	Parameters:
**		response -- encoded form of recipient address.
**		rlen -- length of response.
**		e -- current envelope.
**
**	Returns:
**		none
*/

static void
milter_addrcpt_par(response, rlen, e)
	char *response;
	ssize_t rlen;
	ENVELOPE *e;
{
	int olderrors, argc;
	char *delimptr;
	char **argv;
	ADDRESS *a;

	if (tTd(64, 10))
		sm_dprintf("milter_addrcpt_par: ");

	/* sanity checks */
	if (response == NULL)
	{
		if (tTd(64, 10))
			sm_dprintf("NULL response\n");
		return;
	}

	if (tTd(64, 10))
		sm_dprintf("%s\n", response);
	if (MilterLogLevel > 8)
		sm_syslog(LOG_INFO, e->e_id, "Milter add: rcpt: %s", response);

	argv = milter_split_response(response, rlen, &argc);
	if (argc < 1 || argc > 2)
	{
		if (tTd(64, 10))
			sm_dprintf("didn't follow protocol argc=%d\n", argc);
		return;
	}
	olderrors = Errors;

	/* how to set ESMTP arguments? */
	a = parseaddr(argv[0], NULLADDR, RF_COPYALL, ' ', &delimptr, e, true);

	if (a != NULL && olderrors == Errors)
	{
		parse_esmtp_args(e, a, argv[0], argv[1], "RCPT", NULL,
				rcpt_esmtp_args);
		if (olderrors == Errors)
			a = recipient(a, &e->e_sendqueue, 0, e);
		else
			sm_dprintf("olderrors=%d, Errors=%d\n",
				olderrors, Errors);
	}
	else
	{
		sm_dprintf("a=%p, olderrors=%d, Errors=%d\n",
			a, olderrors, Errors);
	}

	Errors = olderrors;
	return;
}

a3024 1

d3058 1
a3058 2
			sm_dprintf("didn't follow protocol (total len %d != rlen %d)\n",
				   (int) strlen(response), (int) (rlen - 1));
a3069 1

d3103 1
a3103 1
				  sizeof(dfname));
a3305 1

d3368 1
a3368 1
				       sizeof(buf6));
d3390 2
a3391 2
	(void) memcpy(bp, &family, sizeof(family));
	bp += sizeof(family);
d3394 2
a3395 2
		(void) memcpy(bp, &port, sizeof(port));
		bp += sizeof(port);
d3401 2
a3402 2
	response = milter_command(SMFIC_CONNECT, buf, s, MilterConnectMacros,
				e, state, "connect", false);
a3444 1

d3489 1
a3489 1
				  MilterHeloMacros, e, state, "helo", false);
a3492 1

d3573 1
a3573 1
		sm_syslog(LOG_INFO, e->e_id, "Milter: sender: %s", buf);
d3576 2
a3577 2
	response = milter_command(SMFIC_MAIL, buf, s, MilterEnvFromMacros,
				e, state, "mail", false);
d3588 1
a3588 1
		sm_syslog(LOG_INFO, e->e_id, "Milter: reject, sender");
a3598 1
**		rcpt_error -- does RCPT have an error?
d3605 1
a3605 1
milter_envrcpt(args, e, state, rcpt_error)
a3608 1
	bool rcpt_error;
d3655 2
a3656 2
	response = milter_command(SMFIC_RCPT, buf, s, MilterEnvRcptMacros,
				e, state, "rcpt", rcpt_error);
d3661 1
d3682 1
a3682 2
	return milter_command(SMFIC_DATA, NULL, 0, MilterDataMacros, e, state,
				"data", false);
d3684 1
a3791 7
			if (MilterEOHMacros[0] != NULL)
			{
				milter_send_macros(m, MilterEOHMacros,
					   SMFIC_EOH, e);
				MILTER_CHECK_RESULTS();
			}

d3794 1
a3794 1
						       e, state, "eoh");
d3816 1
a3816 1
				    m->mf_timeout[SMFTO_WRITE], e, "eom");
d3841 1
a3841 2
					       m->mf_timeout[SMFTO_READ], e,
						"body");
d3925 1
a3925 1
				milter_addheader(m, response, rlen, e);
d3936 1
a3936 1
				milter_insheader(m, response, rlen, e);
d3947 1
a3947 12
				milter_changeheader(m, response, rlen, e);
				break;

			  case SMFIR_CHGFROM:
				if (!bitset(SMFIF_CHGFROM, m->mf_fflags))
				{
					if (MilterLogLevel > 9)
						sm_syslog(LOG_WARNING, e->e_id,
							  "milter_data(%s) lied about changing sender, honoring request anyway",
							  m->mf_name);
				}
				milter_chgfrom(response, rlen, e);
a3960 11
			  case SMFIR_ADDRCPT_PAR:
				if (!bitset(SMFIF_ADDRCPT_PAR, m->mf_fflags))
				{
					if (MilterLogLevel > 9)
						sm_syslog(LOG_WARNING, e->e_id,
							  "milter_data(%s) lied about adding recipients with parameters, honoring request anyway",
							  m->mf_name);
				}
				milter_addrcpt_par(response, rlen, e);
				break;

d4089 1
d4095 1
a4095 1
**		smtpcmd -- the string itself.
d4105 2
a4106 2
milter_unknown(smtpcmd, e, state)
	char *smtpcmd;
d4111 1
a4111 1
		sm_dprintf("milter_unknown(%s)\n", smtpcmd);
d4113 2
a4114 2
	return milter_command(SMFIC_UNKNOWN, smtpcmd, strlen(smtpcmd) + 1,
				NULL, e, state, "unknown", false);
d4116 1
a4139 1

@


1.1.1.5
log
@import openbsd compress, ssh, perl, sendmail for minor bugfixes
@
text
@d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.267 2007/02/27 22:21:12 ca Exp $")
d1245 1
a1245 1
#if _FFR_MILTER_CHECK
d1249 1
a1249 1
#endif /* _FFR_MILTER_CHECK */
d1297 1
a1297 1
#if _FFR_MILTER_CHECK
d1307 1
a1307 1
#endif /* _FFR_MILTER_CHECK */
d2437 1
a2437 1
#if _FFR_MILTER_CHECK
d2441 1
a2441 1
#else /* _FFR_MILTER_CHECK */
d2445 1
a2445 1
#endif /* _FFR_MILTER_CHECK */
@


1.1.1.6
log
@OpenBSD finally has upgraded their sendmail, too
@
text
@d13 1
a13 1
SM_RCSID("@@(#)$Sendmail: milter.c,v 8.269 2007/06/06 17:26:12 ca Exp $")
d54 1
a54 2
static int	milter_negotiate __P((struct milter *, ENVELOPE *,
			milters_T *));
d1794 35
a2408 1
**		milters -- milters structure.
d2415 1
a2415 1
milter_negotiate(m, e, milters)
a2417 1
	milters_T *milters;
a2585 6
	if (bitset(SMFIF_DELRCPT, m->mf_fflags))
		milters->mis_flags |= MIS_FL_DEL_RCPT;
	if (!bitset(SMFIP_NORCPT, m->mf_pflags) &&
	    !bitset(SMFIP_NR_RCPT, m->mf_pflags))
		milters->mis_flags |= MIS_FL_REJ_RCPT;

a3786 1
**		milters -- milters structure.
d3794 1
a3794 1
milter_init(e, state, milters)
a3796 1
	milters_T *milters;
a3802 1
	memset(milters, '\0', sizeof(*milters));
d3824 1
a3824 1
		    milter_negotiate(m, e, milters) < 0 ||
@


1.1.1.7
log
@Replace $Sendmail:  with $Id:  (the latter is used by upstream)
@
text
@d13 1
a13 1
SM_RCSID("@@(#)$Id: milter.c,v 8.269 2007/06/06 17:26:12 ca Exp $")
@


1.1.1.8
log
@Import OpenBSDs sendmail 8.14.5, RCS IDs properly sedded back
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2009 Sendmail, Inc. and its suppliers.
d13 1
a13 1
SM_RCSID("@@(#)$Id: milter.c,v 8.277 2009/11/06 00:57:06 ca Exp $")
d517 1
d535 2
a536 6
		{
			sm_dprintf("milter_write(%s): length %ld out of range, cmd=%c\n",
				m->mf_name, (long) len, command);
			sm_dprintf("milter_write(%s): buf=%s\n",
				m->mf_name, str2prt(buf));
		}
d539 2
a540 2
				  "milter_write(%s): length %ld out of range, cmd=%c",
				  m->mf_name, (long) len, command);
d597 2
d600 1
d1575 1
a1575 1
# if _FFR_MAXDATASIZE || _FFR_MDS_NEGOTIATE
d1578 1
a1578 1
# endif /* _FFR_MAXDATASIZE || _FFR_MDS_NEGOTIATE */
d1634 1
a1634 1
# if _FFR_MAXDATASIZE || _FFR_MDS_NEGOTIATE
a1635 1
#  if _FFR_MDS_NEGOTIATE
a1636 17
		if (MilterMaxDataSize != MILTER_MDS_64K &&
		    MilterMaxDataSize != MILTER_MDS_256K &&
		    MilterMaxDataSize != MILTER_MDS_1M)
		{
			sm_syslog(LOG_WARNING, NOQID,
				"WARNING: Milter.%s=%d, allowed are only %d, %d, and %d",
				name, MilterMaxDataSize,
				MILTER_MDS_64K, MILTER_MDS_256K,
				MILTER_MDS_1M);
			if (MilterMaxDataSize < MILTER_MDS_64K)
				MilterMaxDataSize = MILTER_MDS_64K;
			else if (MilterMaxDataSize < MILTER_MDS_256K)
				MilterMaxDataSize = MILTER_MDS_256K;
			else
				MilterMaxDataSize = MILTER_MDS_1M;
		}
#  endif /* _FFR_MDS_NEGOTIATE */
d1638 1
a1638 1
# endif /* _FFR_MAXDATASIZE || _FFR_MDS_NEGOTIATE */
a2413 6
#if _FFR_MDS_NEGOTIATE
	if (MilterMaxDataSize == MILTER_MDS_256K)
		mta_prot_flags |= SMFIP_MDS_256K;
	else if (MilterMaxDataSize == MILTER_MDS_1M)
		mta_prot_flags |= SMFIP_MDS_1M;
#endif /* _FFR_MDS_NEGOTIATE */
a2527 33
#if _FFR_MDS_NEGOTIATE
	/* use a table instead of sequence? */
	if (bitset(SMFIP_MDS_1M, m->mf_pflags))
	{
		if (MilterMaxDataSize != MILTER_MDS_1M)
		{
			/* this should not happen... */
			sm_syslog(LOG_WARNING, NOQID,
				  "WARNING: Milter.maxdatasize: configured=%d, set by libmilter=%d",
		    		  MilterMaxDataSize, MILTER_MDS_1M);
			MilterMaxDataSize = MILTER_MDS_1M;
		}
	}
	else if (bitset(SMFIP_MDS_256K, m->mf_pflags))
	{
		if (MilterMaxDataSize != MILTER_MDS_256K)
		{
			sm_syslog(LOG_WARNING, NOQID,
				  "WARNING: Milter.maxdatasize: configured=%d, set by libmilter=%d",
		    		  MilterMaxDataSize, MILTER_MDS_256K);
			MilterMaxDataSize = MILTER_MDS_256K;
		}
	}
	else if (MilterMaxDataSize != MILTER_MDS_64K)
	{
		sm_syslog(LOG_WARNING, NOQID,
			  "WARNING: Milter.maxdatasize: configured=%d, set by libmilter=%d",
	    		  MilterMaxDataSize, MILTER_MDS_64K);
		MilterMaxDataSize = MILTER_MDS_64K;
	}
	m->mf_pflags &= ~SMFI_INTERNAL;
#endif /* _FFR_MDS_NEGOTIATE */

d2979 1
a2979 1
			h->h_value = addleadingspace(mh_value, e->e_rpool);
d3280 1
a3280 1
			h->h_value = addleadingspace(mh_value, e->e_rpool);
d3333 1
a3333 1
	s = (char **)malloc((nelem + 1) * (sizeof(*s)));
d3816 1
a3816 1
			/* if negotiation failure, close socket */
d4386 1
a4386 1
						"eom");
@


