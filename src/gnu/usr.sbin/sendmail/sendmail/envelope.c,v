head	1.7;
access;
symbols
	sendmail-8_14_9:1.1.127.3
	sendmail-8_14_7:1.1.127.2
	sendmail-8_14_6:1.1.127.2
	sendmail-8_14_5-ERRATA-1:1.1.127.2
	mbsd-20101220_mergebase:1.6
	sendmail-8_14_5:1.1.127.2
	cvs-201107021500:1.1.1.8
	cvs-20101220:1.1.1.7
	mbsd-20101220:1.6.0.2
	cvs-201012191730:1.1.1.6
	sendmail-8_14_5_Beta0:1.1.127.2
	sendmail-8_14_3:1.1.127.1
	sendmail:1.1.127
	cvs-200812170000:1.1.1.6
	cvs-200805071200:1.1.1.6
	MIRBSD_10:1.2.0.2
	MIRBSD_10_BASE:1.2
	cvs-200803022030:1.1.1.5
	cvs-200707152000:1.1.1.5
	cvs-200704292000:1.1.1.5
	cvs-200702051700:1.1.1.5
	cvs-200609121900:1.1.1.4
	MIRBSD_9_BASE:1.1.1.3
	cvs-200606151800:1.1.1.3
	cvs-200603231300:1.1.1.3
	MIRBSD_8:1.1.1.2.0.2
	MIRBSD_8_BASE:1.1.1.2
	cvs-200507211800:1.1.1.2
	cvs-200504262050:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2014.06.09.15.17.48;	author tg;	state Exp;
branches;
next	1.6;
commitid	1005395CFC65E5646F1;

1.6
date	2010.12.19.17.18.24;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004D0E3E2D1286B3DF;

1.5
date	2009.11.18.08.53.39;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004B03B61970AF200B;

1.4
date	2008.05.07.11.57.07;	author tg;	state Exp;
branches;
next	1.3;
commitid	100482198DE5A7916C7;

1.3
date	2008.03.22.20.41.27;	author tg;	state Exp;
branches;
next	1.2;
commitid	10047E56EB42921240A;

1.2
date	2008.03.02.21.41.14;	author tg;	state Exp;
branches
	1.2.2.1;
next	1.1;
commitid	10047CB1EE51190ECAF;

1.1
date	2005.02.05.17.24.28;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.127.1;
next	;

1.2.2.1
date	2008.03.22.20.41.26;	author tg;	state Exp;
branches;
next	1.2.2.2;
commitid	10047E56EB42921240A;

1.2.2.2
date	2008.05.17.19.12.08;	author tg;	state Exp;
branches;
next	;
commitid	100482F2DC168C89AEA;

1.1.1.1
date	2005.02.05.17.24.28;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.26.20.58.37;	author tg;	state Exp;
branches
	1.1.1.2.2.1;
next	1.1.1.3;

1.1.1.3
date	2006.03.23.13.09.55;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	10044229DEA33D36552;

1.1.1.4
date	2006.09.12.19.22.23;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	100450708CE5C63A8F5;

1.1.1.5
date	2007.02.05.17.06.29;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	10045C763C551AABAF7;

1.1.1.6
date	2008.05.07.12.31.50;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	1004821A13C1FC036E1;

1.1.1.7
date	2011.07.02.15.00.44;	author tg;	state Exp;
branches;
next	1.1.1.8;
commitid	1004E0F31C5496AB95F;

1.1.1.8
date	2011.07.02.15.17.42;	author tg;	state Exp;
branches;
next	;
commitid	1004E0F36A10B5CA95B;

1.1.1.2.2.1
date	2006.03.30.19.27.58;	author tg;	state Exp;
branches;
next	;
commitid	100442C309C7183FA09;

1.1.127.1
date	2010.12.19.14.45.44;	author tg;	state Exp;
branches;
next	1.1.127.2;
commitid	1004D0E1A94384778FD;

1.1.127.2
date	2010.12.19.14.56.25;	author tg;	state Exp;
branches;
next	1.1.127.3;
commitid	1004D0E1D294DE25888;

1.1.127.3
date	2014.06.09.14.29.16;	author tg;	state Exp;
branches;
next	;
commitid	1005395C4CC1A6DB9EE;


desc
@@


1.7
log
@merge
@
text
@/*
 * Copyright (c) 1998-2003, 2006 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>

SM_RCSID("$MirOS: src/gnu/usr.sbin/sendmail/sendmail/envelope.c,v 1.6 2010/12/19 17:18:24 tg Exp $")
SM_RCSID("@@(#)$Id: envelope.c,v 8.313 2013-11-22 20:51:55 ca Exp $")

/*
**  CLRSESSENVELOPE -- clear session oriented data in an envelope
**
**	Parameters:
**		e -- the envelope to clear.
**
**	Returns:
**		none.
*/

void
clrsessenvelope(e)
	ENVELOPE *e;
{
#if SASL
	macdefine(&e->e_macro, A_PERM, macid("{auth_type}"), "");
	macdefine(&e->e_macro, A_PERM, macid("{auth_authen}"), "");
	macdefine(&e->e_macro, A_PERM, macid("{auth_author}"), "");
	macdefine(&e->e_macro, A_PERM, macid("{auth_ssf}"), "");
#endif /* SASL */
#if STARTTLS
	macdefine(&e->e_macro, A_PERM, macid("{cert_issuer}"), "");
	macdefine(&e->e_macro, A_PERM, macid("{cert_subject}"), "");
	macdefine(&e->e_macro, A_PERM, macid("{cipher_bits}"), "");
	macdefine(&e->e_macro, A_PERM, macid("{cipher}"), "");
	macdefine(&e->e_macro, A_PERM, macid("{tls_version}"), "");
	macdefine(&e->e_macro, A_PERM, macid("{verify}"), "");
# if _FFR_TLS_1
	macdefine(&e->e_macro, A_PERM, macid("{alg_bits}"), "");
	macdefine(&e->e_macro, A_PERM, macid("{cn_issuer}"), "");
	macdefine(&e->e_macro, A_PERM, macid("{cn_subject}"), "");
# endif /* _FFR_TLS_1 */
#endif /* STARTTLS */
}

/*
**  NEWENVELOPE -- fill in a new envelope
**
**	Supports inheritance.
**
**	Parameters:
**		e -- the new envelope to fill in.
**		parent -- the envelope to be the parent of e.
**		rpool -- either NULL, or a pointer to a resource pool
**			from which envelope memory is allocated, and
**			to which envelope resources are attached.
**
**	Returns:
**		e.
**
**	Side Effects:
**		none.
*/

ENVELOPE *
newenvelope(e, parent, rpool)
	register ENVELOPE *e;
	register ENVELOPE *parent;
	SM_RPOOL_T *rpool;
{
	int sendmode;

	/*
	**  This code used to read:
	**	if (e == parent && e->e_parent != NULL)
	**		parent = e->e_parent;
	**  So if e == parent && e->e_parent == NULL then we would
	**  set e->e_parent = e, which creates a loop in the e_parent chain.
	**  This meant macvalue() could go into an infinite loop.
	*/

	if (parent != NULL)
		sendmode = parent->e_sendmode;
	else
		sendmode = DM_NOTSET;

	if (e == parent)
		parent = e->e_parent;
	clearenvelope(e, true, rpool);
	if (e == CurEnv)
		memmove((char *) &e->e_from,
			(char *) &NullAddress,
			sizeof(e->e_from));
	else
		memmove((char *) &e->e_from,
			(char *) &CurEnv->e_from,
			sizeof(e->e_from));
	e->e_parent = parent;
	assign_queueid(e);
	e->e_ctime = curtime();
#if _FFR_SESSID
	e->e_sessid = e->e_id;
#endif /* _FFR_SESSID */
	if (parent != NULL)
	{
		e->e_msgpriority = parent->e_msgsize;
#if _FFR_SESSID
		if (parent->e_sessid != NULL)
			e->e_sessid = sm_rpool_strdup_x(rpool,
							parent->e_sessid);
#endif /* _FFR_SESSID */

		if (parent->e_quarmsg == NULL)
		{
			e->e_quarmsg = NULL;
			macdefine(&e->e_macro, A_PERM,
				  macid("{quarantine}"), "");
		}
		else
		{
			e->e_quarmsg = sm_rpool_strdup_x(rpool,
							 parent->e_quarmsg);
			macdefine(&e->e_macro, A_PERM,
				  macid("{quarantine}"), e->e_quarmsg);
		}
	}
	e->e_puthdr = putheader;
	e->e_putbody = putbody;
	if (CurEnv->e_xfp != NULL)
		(void) sm_io_flush(CurEnv->e_xfp, SM_TIME_DEFAULT);
	if (sendmode != DM_NOTSET)
		set_delivery_mode(sendmode, e);

	return e;
}

/* values for msg_timeout, see also IS_* below for usage (bit layout) */
#define MSG_T_O		0x01	/* normal timeout */
#define MSG_T_O_NOW	0x02	/* NOW timeout */
#define MSG_NOT_BY	0x04	/* Deliver-By time exceeded, mode R */
#define MSG_WARN	0x10	/* normal queue warning */
#define MSG_WARN_BY	0x20	/* Deliver-By time exceeded, mode N */

#define IS_MSG_ERR(x)	(((x) & 0x0f) != 0)	/* return an error */

/* immediate return */
#define IS_IMM_RET(x)	(((x) & (MSG_T_O_NOW|MSG_NOT_BY)) != 0)
#define IS_MSG_WARN(x)	(((x) & 0xf0) != 0)	/* return a warning */

/*
**  DROPENVELOPE -- deallocate an envelope.
**
**	Parameters:
**		e -- the envelope to deallocate.
**		fulldrop -- if set, do return receipts.
**		split -- if true, split by recipient if message is queued up
**
**	Returns:
**		EX_* status (currently: 0: success, EX_IOERR on panic)
**
**	Side Effects:
**		housekeeping necessary to dispose of an envelope.
**		Unlocks this queue file.
*/

int
dropenvelope(e, fulldrop, split)
	register ENVELOPE *e;
	bool fulldrop;
	bool split;
{
	bool panic = false;
	bool queueit = false;
	int msg_timeout = 0;
	bool failure_return = false;
	bool delay_return = false;
	bool success_return = false;
	bool pmnotify = bitset(EF_PM_NOTIFY, e->e_flags);
	bool done = false;
	register ADDRESS *q;
	char *id = e->e_id;
	time_t now;
	char buf[MAXLINE];

	if (tTd(50, 1))
	{
		sm_dprintf("dropenvelope %p: id=", e);
		xputs(sm_debug_file(), e->e_id);
		sm_dprintf(", flags=");
		printenvflags(e);
		if (tTd(50, 10))
		{
			sm_dprintf("sendq=");
			printaddr(sm_debug_file(), e->e_sendqueue, true);
		}
	}

	if (LogLevel > 84)
		sm_syslog(LOG_DEBUG, id,
			  "dropenvelope, e_flags=0x%lx, OpMode=%c, pid=%d",
			  e->e_flags, OpMode, (int) CurrentPid);

	/* we must have an id to remove disk files */
	if (id == NULL)
		return EX_OK;

	/* if verify-only mode, we can skip most of this */
	if (OpMode == MD_VERIFY)
		goto simpledrop;

	if (tTd(92, 2))
		sm_dprintf("dropenvelope: e_id=%s, EF_LOGSENDER=%d, LogLevel=%d\n",
			e->e_id, bitset(EF_LOGSENDER, e->e_flags), LogLevel);
	if (LogLevel > 4 && bitset(EF_LOGSENDER, e->e_flags))
		logsender(e, NULL);
	e->e_flags &= ~EF_LOGSENDER;

	/* post statistics */
	poststats(StatFile);

	/*
	**  Extract state information from dregs of send list.
	*/

	now = curtime();
	if (now >= e->e_ctime + TimeOuts.to_q_return[e->e_timeoutclass])
		msg_timeout = MSG_T_O;
	if (IS_DLVR_RETURN(e) && e->e_deliver_by > 0 &&
	    now >= e->e_ctime + e->e_deliver_by &&
	    !bitset(EF_RESPONSE, e->e_flags))
	{
		msg_timeout = MSG_NOT_BY;
		e->e_flags |= EF_FATALERRS|EF_CLRQUEUE;
	}
	else if (TimeOuts.to_q_return[e->e_timeoutclass] == NOW &&
		 !bitset(EF_RESPONSE, e->e_flags))
	{
		msg_timeout = MSG_T_O_NOW;
		e->e_flags |= EF_FATALERRS|EF_CLRQUEUE;
	}


	e->e_flags &= ~EF_QUEUERUN;
	for (q = e->e_sendqueue; q != NULL; q = q->q_next)
	{
		if (QS_IS_UNDELIVERED(q->q_state))
			queueit = true;


		/* see if a notification is needed */
		if (bitset(QPINGONFAILURE, q->q_flags) &&
		    ((IS_MSG_ERR(msg_timeout) &&
		      QS_IS_UNDELIVERED(q->q_state)) ||
		     QS_IS_BADADDR(q->q_state) ||
		     IS_IMM_RET(msg_timeout)))
		{
			failure_return = true;
			if (!done && q->q_owner == NULL &&
			    !emptyaddr(&e->e_from))
			{
				(void) sendtolist(e->e_from.q_paddr, NULLADDR,
						  &e->e_errorqueue, 0, e);
				done = true;
			}
		}
		else if ((bitset(QPINGONSUCCESS, q->q_flags) &&
			  ((QS_IS_SENT(q->q_state) &&
			    bitnset(M_LOCALMAILER, q->q_mailer->m_flags)) ||
			   bitset(QRELAYED|QEXPANDED|QDELIVERED, q->q_flags))) ||
			  bitset(QBYTRACE, q->q_flags) ||
			  bitset(QBYNRELAY, q->q_flags))
		{
			success_return = true;
		}
	}

	if (e->e_class < 0)
		e->e_flags |= EF_NO_BODY_RETN;

	/*
	**  See if the message timed out.
	*/

	if (!queueit)
		/* EMPTY */
		/* nothing to do */ ;
	else if (IS_MSG_ERR(msg_timeout))
	{
		if (failure_return)
		{
			if (msg_timeout == MSG_NOT_BY)
			{
				(void) sm_snprintf(buf, sizeof(buf),
					"delivery time expired %lds",
					e->e_deliver_by);
			}
			else
			{
				(void) sm_snprintf(buf, sizeof(buf),
					"Cannot send message for %s",
					pintvl(TimeOuts.to_q_return[e->e_timeoutclass],
						false));
			}

			/* don't free, allocated from e_rpool */
			e->e_message = sm_rpool_strdup_x(e->e_rpool, buf);
			message(buf);
			e->e_flags |= EF_CLRQUEUE;
		}
		if (msg_timeout == MSG_NOT_BY)
		{
			(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
				"Delivery time (%lds) expired\n",
				e->e_deliver_by);
		}
		else
			(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
				"Message could not be delivered for %s\n",
				pintvl(TimeOuts.to_q_return[e->e_timeoutclass],
					false));
		(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
			"Message will be deleted from queue\n");
		for (q = e->e_sendqueue; q != NULL; q = q->q_next)
		{
			if (QS_IS_UNDELIVERED(q->q_state))
			{
				q->q_state = QS_BADADDR;
				if (msg_timeout == MSG_NOT_BY)
					q->q_status = "5.4.7";
				else
					q->q_status = "4.4.7";
			}
		}
	}
	else
	{
		if (TimeOuts.to_q_warning[e->e_timeoutclass] > 0 &&
		    now >= e->e_ctime +
				TimeOuts.to_q_warning[e->e_timeoutclass])
			msg_timeout = MSG_WARN;
		else if (IS_DLVR_NOTIFY(e) &&
			 e->e_deliver_by > 0 &&
			 now >= e->e_ctime + e->e_deliver_by)
			msg_timeout = MSG_WARN_BY;

		if (IS_MSG_WARN(msg_timeout))
		{
			if (!bitset(EF_WARNING|EF_RESPONSE, e->e_flags) &&
			    e->e_class >= 0 &&
			    e->e_from.q_paddr != NULL &&
			    strcmp(e->e_from.q_paddr, "<>") != 0 &&
			    sm_strncasecmp(e->e_from.q_paddr, "owner-", 6) != 0 &&
			    (strlen(e->e_from.q_paddr) <= 8 ||
			     sm_strcasecmp(&e->e_from.q_paddr[strlen(e->e_from.q_paddr) - 8],
					   "-request") != 0))
			{
				for (q = e->e_sendqueue; q != NULL;
				     q = q->q_next)
				{
					if (QS_IS_UNDELIVERED(q->q_state)
#if _FFR_NODELAYDSN_ON_HOLD
					    && !bitnset(M_HOLD,
							q->q_mailer->m_flags)
#endif /* _FFR_NODELAYDSN_ON_HOLD */
					   )
					{
						if (msg_timeout ==
						    MSG_WARN_BY &&
						    (bitset(QPINGONDELAY,
							    q->q_flags) ||
						    !bitset(QHASNOTIFY,
							    q->q_flags))
						   )
						{
							q->q_flags |= QBYNDELAY;
							delay_return = true;
						}
						if (bitset(QPINGONDELAY,
							   q->q_flags))
						{
							q->q_flags |= QDELAYED;
							delay_return = true;
						}
					}
				}
			}
			if (delay_return)
			{
				if (msg_timeout == MSG_WARN_BY)
				{
					(void) sm_snprintf(buf, sizeof(buf),
						"Warning: Delivery time (%lds) exceeded",
						e->e_deliver_by);
				}
				else
					(void) sm_snprintf(buf, sizeof(buf),
						"Warning: could not send message for past %s",
						pintvl(TimeOuts.to_q_warning[e->e_timeoutclass],
							false));

				/* don't free, allocated from e_rpool */
				e->e_message = sm_rpool_strdup_x(e->e_rpool,
								 buf);
				message(buf);
				e->e_flags |= EF_WARNING;
			}
			if (msg_timeout == MSG_WARN_BY)
			{
				(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
					"Warning: Delivery time (%lds) exceeded\n",
					e->e_deliver_by);
			}
			else
				(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
					"Warning: message still undelivered after %s\n",
					pintvl(TimeOuts.to_q_warning[e->e_timeoutclass],
					     false));
			(void) sm_io_fprintf(e->e_xfp, SM_TIME_DEFAULT,
				      "Will keep trying until message is %s old\n",
				      pintvl(TimeOuts.to_q_return[e->e_timeoutclass],
					     false));
		}
	}

	if (tTd(50, 2))
		sm_dprintf("failure_return=%d delay_return=%d success_return=%d queueit=%d\n",
			failure_return, delay_return, success_return, queueit);

	/*
	**  If we had some fatal error, but no addresses are marked as
	**  bad, mark them _all_ as bad.
	*/

	if (bitset(EF_FATALERRS, e->e_flags) && !failure_return)
	{
		for (q = e->e_sendqueue; q != NULL; q = q->q_next)
		{
			if ((QS_IS_OK(q->q_state) ||
			     QS_IS_VERIFIED(q->q_state)) &&
			    bitset(QPINGONFAILURE, q->q_flags))
			{
				failure_return = true;
				q->q_state = QS_BADADDR;
			}
		}
	}

	/*
	**  Send back return receipts as requested.
	*/

	if (success_return && !failure_return && !delay_return && fulldrop &&
	    !bitset(PRIV_NORECEIPTS, PrivacyFlags) &&
	    strcmp(e->e_from.q_paddr, "<>") != 0)
	{
		auto ADDRESS *rlist = NULL;

		if (tTd(50, 8))
			sm_dprintf("dropenvelope(%s): sending return receipt\n",
				id);
		e->e_flags |= EF_SENDRECEIPT;
		(void) sendtolist(e->e_from.q_paddr, NULLADDR, &rlist, 0, e);
		(void) returntosender("Return receipt", rlist, RTSF_NO_BODY, e);
	}
	e->e_flags &= ~EF_SENDRECEIPT;

	/*
	**  Arrange to send error messages if there are fatal errors.
	*/

	if ((failure_return || delay_return) && e->e_errormode != EM_QUIET)
	{
		if (tTd(50, 8))
			sm_dprintf("dropenvelope(%s): saving mail\n", id);
		panic = savemail(e, !bitset(EF_NO_BODY_RETN, e->e_flags));
	}

	/*
	**  Arrange to send warning messages to postmaster as requested.
	*/

	if ((failure_return || pmnotify) &&
	    PostMasterCopy != NULL &&
	    !bitset(EF_RESPONSE, e->e_flags) &&
	    e->e_class >= 0)
	{
		auto ADDRESS *rlist = NULL;
		char pcopy[MAXNAME];

		if (failure_return)
		{
			expand(PostMasterCopy, pcopy, sizeof(pcopy), e);

			if (tTd(50, 8))
				sm_dprintf("dropenvelope(%s): sending postmaster copy to %s\n",
					id, pcopy);
			(void) sendtolist(pcopy, NULLADDR, &rlist, 0, e);
		}
		if (pmnotify)
			(void) sendtolist("postmaster", NULLADDR,
					  &rlist, 0, e);
		(void) returntosender(e->e_message, rlist,
				      RTSF_PM_BOUNCE|RTSF_NO_BODY, e);
	}

	/*
	**  Instantiate or deinstantiate the queue.
	*/

simpledrop:
	if (tTd(50, 8))
		sm_dprintf("dropenvelope(%s): at simpledrop, queueit=%d\n",
			id, queueit);
	if (!queueit || bitset(EF_CLRQUEUE, e->e_flags))
	{
		if (tTd(50, 1))
		{
			sm_dprintf("\n===== Dropping queue files for %s... queueit=%d, e_flags=",
				e->e_id, queueit);
			printenvflags(e);
		}
		if (!panic)
		{
			if (e->e_dfp != NULL)
			{
				(void) sm_io_close(e->e_dfp, SM_TIME_DEFAULT);
				e->e_dfp = NULL;
			}
			(void) xunlink(queuename(e, DATAFL_LETTER));
		}
		if (panic && QueueMode == QM_LOST)
		{
			/*
			**  leave the Qf file behind as
			**  the delivery attempt failed.
			*/

			/* EMPTY */
		}
		else
		if (xunlink(queuename(e, ANYQFL_LETTER)) == 0)
		{
			/* add to available space in filesystem */
			updfs(e, -1, panic ? 0 : -1, "dropenvelope");
		}

		if (e->e_ntries > 0 && LogLevel > 9)
			sm_syslog(LOG_INFO, id, "done; delay=%s, ntries=%d",
				  pintvl(curtime() - e->e_ctime, true),
				  e->e_ntries);
	}
	else if (queueit || !bitset(EF_INQUEUE, e->e_flags))
	{
		if (!split)
			queueup(e, false, true);
		else
		{
			ENVELOPE *oldsib;
			ENVELOPE *ee;

			/*
			**  Save old sibling and set it to NULL to avoid
			**  queueing up the same envelopes again.
			**  This requires that envelopes in that list have
			**  been take care of before (or at some other place).
			*/

			oldsib = e->e_sibling;
			e->e_sibling = NULL;
			if (!split_by_recipient(e) &&
			    bitset(EF_FATALERRS, e->e_flags))
			{
				syserr("!dropenvelope(%s): cannot commit data file %s, uid=%d",
					e->e_id, queuename(e, DATAFL_LETTER),
					(int) geteuid());
			}
			for (ee = e->e_sibling; ee != NULL; ee = ee->e_sibling)
				queueup(ee, false, true);
			queueup(e, false, true);

			/* clean up */
			for (ee = e->e_sibling; ee != NULL; ee = ee->e_sibling)
			{
				/* now unlock the job */
				if (tTd(50, 8))
					sm_dprintf("dropenvelope(%s): unlocking job\n",
						   ee->e_id);
				closexscript(ee);
				unlockqueue(ee);

				/* this envelope is marked unused */
				if (ee->e_dfp != NULL)
				{
					(void) sm_io_close(ee->e_dfp,
							   SM_TIME_DEFAULT);
					ee->e_dfp = NULL;
				}
				ee->e_id = NULL;
				ee->e_flags &= ~EF_HAS_DF;
			}
			e->e_sibling = oldsib;
		}
	}

	/* now unlock the job */
	if (tTd(50, 8))
		sm_dprintf("dropenvelope(%s): unlocking job\n", id);
	closexscript(e);
	unlockqueue(e);

	/* make sure that this envelope is marked unused */
	if (e->e_dfp != NULL)
	{
		(void) sm_io_close(e->e_dfp, SM_TIME_DEFAULT);
		e->e_dfp = NULL;
	}
	e->e_id = NULL;
	e->e_flags &= ~EF_HAS_DF;
	if (panic)
		return EX_IOERR;
	return EX_OK;
}

/*
**  CLEARENVELOPE -- clear an envelope without unlocking
**
**	This is normally used by a child process to get a clean
**	envelope without disturbing the parent.
**
**	Parameters:
**		e -- the envelope to clear.
**		fullclear - if set, the current envelope is total
**			garbage and should be ignored; otherwise,
**			release any resources it may indicate.
**		rpool -- either NULL, or a pointer to a resource pool
**			from which envelope memory is allocated, and
**			to which envelope resources are attached.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Closes files associated with the envelope.
**		Marks the envelope as unallocated.
*/

void
clearenvelope(e, fullclear, rpool)
	register ENVELOPE *e;
	bool fullclear;
	SM_RPOOL_T *rpool;
{
	register HDR *bh;
	register HDR **nhp;
	extern ENVELOPE BlankEnvelope;
	char **p;

	if (!fullclear)
	{
		/* clear out any file information */
		if (e->e_xfp != NULL)
			(void) sm_io_close(e->e_xfp, SM_TIME_DEFAULT);
		if (e->e_dfp != NULL)
			(void) sm_io_close(e->e_dfp, SM_TIME_DEFAULT);
		e->e_xfp = e->e_dfp = NULL;
	}

	/*
	**  Copy BlankEnvelope into *e.
	**  It is not safe to simply copy pointers to strings;
	**  the strings themselves must be copied (or set to NULL).
	**  The problem is that when we assign a new string value to
	**  a member of BlankEnvelope, we free the old string.
	**  We did not need to do this copying in sendmail 8.11 :-(
	**  and it is a potential performance hit.  Reference counted
	**  strings are one way out.
	*/

	*e = BlankEnvelope;
	e->e_message = NULL;
	e->e_qfletter = '\0';
	e->e_quarmsg = NULL;
	macdefine(&e->e_macro, A_PERM, macid("{quarantine}"), "");

	/*
	**  Copy the macro table.
	**  We might be able to avoid this by zeroing the macro table
	**  and always searching BlankEnvelope.e_macro after e->e_macro
	**  in macvalue().
	*/

	for (p = &e->e_macro.mac_table[0];
	     p <= &e->e_macro.mac_table[MAXMACROID];
	     ++p)
	{
		if (*p != NULL)
			*p = sm_rpool_strdup_x(rpool, *p);
	}

	/*
	**  XXX There are many strings in the envelope structure
	**  XXX that we are not attempting to copy here.
	**  XXX Investigate this further.
	*/

	e->e_rpool = rpool;
	e->e_macro.mac_rpool = rpool;
	if (Verbose)
		set_delivery_mode(SM_DELIVER, e);
	bh = BlankEnvelope.e_header;
	nhp = &e->e_header;
	while (bh != NULL)
	{
		*nhp = (HDR *) sm_rpool_malloc_x(rpool, sizeof(*bh));
		memmove((char *) *nhp, (char *) bh, sizeof(*bh));
		bh = bh->h_link;
		nhp = &(*nhp)->h_link;
	}
#if _FFR_MILTER_ENHSC
	e->e_enhsc[0] = '\0';
#endif /* _FFR_MILTER_ENHSC */
}
/*
**  INITSYS -- initialize instantiation of system
**
**	In Daemon mode, this is done in the child.
**
**	Parameters:
**		e -- the envelope to use.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Initializes the system macros, some global variables,
**		etc.  In particular, the current time in various
**		forms is set.
*/

void
initsys(e)
	register ENVELOPE *e;
{
	char buf[10];
#ifdef TTYNAME
	static char ybuf[60];			/* holds tty id */
	register char *p;
	extern char *ttyname();
#endif /* TTYNAME */

	/*
	**  Give this envelope a reality.
	**	I.e., an id, a transcript, and a creation time.
	**  We don't select the queue until all of the recipients are known.
	*/

	openxscript(e);
	e->e_ctime = curtime();
	e->e_qfletter = '\0';

	/*
	**  Set OutChannel to something useful if stdout isn't it.
	**	This arranges that any extra stuff the mailer produces
	**	gets sent back to the user on error (because it is
	**	tucked away in the transcript).
	*/

	if (OpMode == MD_DAEMON && bitset(EF_QUEUERUN, e->e_flags) &&
	    e->e_xfp != NULL)
		OutChannel = e->e_xfp;

	/*
	**  Set up some basic system macros.
	*/

	/* process id */
	(void) sm_snprintf(buf, sizeof(buf), "%d", (int) CurrentPid);
	macdefine(&e->e_macro, A_TEMP, 'p', buf);

	/* hop count */
	(void) sm_snprintf(buf, sizeof(buf), "%d", e->e_hopcount);
	macdefine(&e->e_macro, A_TEMP, 'c', buf);

	/* time as integer, unix time, arpa time */
	settime(e);

	/* Load average */
	sm_getla();

#ifdef TTYNAME
	/* tty name */
	if (macvalue('y', e) == NULL)
	{
		p = ttyname(2);
		if (p != NULL)
		{
			if (strrchr(p, '/') != NULL)
				p = strrchr(p, '/') + 1;
			(void) sm_strlcpy(ybuf, sizeof(ybuf), p);
			macdefine(&e->e_macro, A_PERM, 'y', ybuf);
		}
	}
#endif /* TTYNAME */
}
/*
**  SETTIME -- set the current time.
**
**	Parameters:
**		e -- the envelope in which the macros should be set.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Sets the various time macros -- $a, $b, $d, $t.
*/

void
settime(e)
	register ENVELOPE *e;
{
	register char *p;
	auto time_t now;
	char buf[30];
	register struct tm *tm;

	now = curtime();
	(void) sm_snprintf(buf, sizeof(buf), "%ld", (long) now);
	macdefine(&e->e_macro, A_TEMP, macid("{time}"), buf);
	tm = gmtime(&now);
	(void) sm_snprintf(buf, sizeof(buf), "%04d%02d%02d%02d%02d",
			   (int)(tm->tm_year + 1900), tm->tm_mon + 1, tm->tm_mday,
			   tm->tm_hour, tm->tm_min);
	macdefine(&e->e_macro, A_TEMP, 't', buf);
	(void) sm_strlcpy(buf, ctime(&now), sizeof(buf));
	p = strchr(buf, '\n');
	if (p != NULL)
		*p = '\0';
	macdefine(&e->e_macro, A_TEMP, 'd', buf);
	macdefine(&e->e_macro, A_TEMP, 'b', arpadate(buf));
	if (macvalue('a', e) == NULL)
		macdefine(&e->e_macro, A_PERM, 'a', macvalue('b', e));
}
/*
**  OPENXSCRIPT -- Open transcript file
**
**	Creates a transcript file for possible eventual mailing or
**	sending back.
**
**	Parameters:
**		e -- the envelope to create the transcript in/for.
**
**	Returns:
**		none
**
**	Side Effects:
**		Creates the transcript file.
*/

#ifndef O_APPEND
# define O_APPEND	0
#endif /* ! O_APPEND */

void
openxscript(e)
	register ENVELOPE *e;
{
	register char *p;

	if (e->e_xfp != NULL)
		return;

#if 0
	if (e->e_lockfp == NULL && bitset(EF_INQUEUE, e->e_flags))
		syserr("openxscript: job not locked");
#endif /* 0 */

	p = queuename(e, XSCRPT_LETTER);
	e->e_xfp = bfopen(p, FileMode, XscriptFileBufferSize,
			  SFF_NOTEXCL|SFF_OPENASROOT);

	if (e->e_xfp == NULL)
	{
		syserr("Can't create transcript file %s", p);
		e->e_xfp = sm_io_open(SmFtStdio, SM_TIME_DEFAULT,
				      SM_PATH_DEVNULL, SM_IO_RDWR, NULL);
		if (e->e_xfp == NULL)
			syserr("!Can't open %s", SM_PATH_DEVNULL);
	}
	(void) sm_io_setvbuf(e->e_xfp, SM_TIME_DEFAULT, NULL, SM_IO_LBF, 0);
	if (tTd(46, 9))
	{
		sm_dprintf("openxscript(%s):\n  ", p);
		dumpfd(sm_io_getinfo(e->e_xfp, SM_IO_WHAT_FD, NULL), true,
		       false);
	}
}
/*
**  CLOSEXSCRIPT -- close the transcript file.
**
**	Parameters:
**		e -- the envelope containing the transcript to close.
**
**	Returns:
**		none.
**
**	Side Effects:
**		none.
*/

void
closexscript(e)
	register ENVELOPE *e;
{
	if (e->e_xfp == NULL)
		return;
#if 0
	if (e->e_lockfp == NULL)
		syserr("closexscript: job not locked");
#endif /* 0 */
	(void) sm_io_close(e->e_xfp, SM_TIME_DEFAULT);
	e->e_xfp = NULL;
}
/*
**  SETSENDER -- set the person who this message is from
**
**	Under certain circumstances allow the user to say who
**	s/he is (using -f or -r).  These are:
**	1.  The user's uid is zero (root).
**	2.  The user's login name is in an approved list (typically
**	    from a network server).
**	3.  The address the user is trying to claim has a
**	    "!" character in it (since #2 doesn't do it for
**	    us if we are dialing out for UUCP).
**	A better check to replace #3 would be if the
**	effective uid is "UUCP" -- this would require me
**	to rewrite getpwent to "grab" uucp as it went by,
**	make getname more nasty, do another passwd file
**	scan, or compile the UID of "UUCP" into the code,
**	all of which are reprehensible.
**
**	Assuming all of these fail, we figure out something
**	ourselves.
**
**	Parameters:
**		from -- the person we would like to believe this message
**			is from, as specified on the command line.
**		e -- the envelope in which we would like the sender set.
**		delimptr -- if non-NULL, set to the location of the
**			trailing delimiter.
**		delimchar -- the character that will delimit the sender
**			address.
**		internal -- set if this address is coming from an internal
**			source such as an owner alias.
**
**	Returns:
**		none.
**
**	Side Effects:
**		sets sendmail's notion of who the from person is.
*/

void
setsender(from, e, delimptr, delimchar, internal)
	char *from;
	register ENVELOPE *e;
	char **delimptr;
	int delimchar;
	bool internal;
{
	register char **pvp;
	char *realname = NULL;
	char *bp;
	char buf[MAXNAME + 2];
	char pvpbuf[PSBUFSIZE];
	extern char *FullName;

	if (tTd(45, 1))
		sm_dprintf("setsender(%s)\n", from == NULL ? "" : from);

	/* may be set from earlier calls */
	macdefine(&e->e_macro, A_PERM, 'x', "");

	/*
	**  Figure out the real user executing us.
	**	Username can return errno != 0 on non-errors.
	*/

	if (bitset(EF_QUEUERUN, e->e_flags) || OpMode == MD_SMTP ||
	    OpMode == MD_ARPAFTP || OpMode == MD_DAEMON)
		realname = from;
	if (realname == NULL || realname[0] == '\0')
		realname = username();

	if (ConfigLevel < 2)
		SuprErrs = true;

	macdefine(&e->e_macro, A_PERM, macid("{addr_type}"), "e s");

	/* preset state for then clause in case from == NULL */
	e->e_from.q_state = QS_BADADDR;
	e->e_from.q_flags = 0;
	if (from == NULL ||
	    parseaddr(from, &e->e_from, RF_COPYALL|RF_SENDERADDR,
		      delimchar, delimptr, e, false) == NULL ||
	    QS_IS_BADADDR(e->e_from.q_state) ||
	    e->e_from.q_mailer == ProgMailer ||
	    e->e_from.q_mailer == FileMailer ||
	    e->e_from.q_mailer == InclMailer)
	{
		/* log garbage addresses for traceback */
		if (from != NULL && LogLevel > 2)
		{
			char *p;
			char ebuf[MAXNAME * 2 + 2];

			p = macvalue('_', e);
			if (p == NULL)
			{
				char *host = RealHostName;

				if (host == NULL)
					host = MyHostName;
				(void) sm_snprintf(ebuf, sizeof(ebuf),
						   "%.*s@@%.*s", MAXNAME,
						   realname, MAXNAME, host);
				p = ebuf;
			}
			sm_syslog(LOG_NOTICE, e->e_id,
				  "setsender: %s: invalid or unparsable, received from %s",
				  shortenstring(from, 83), p);
		}
		if (from != NULL)
		{
			if (!QS_IS_BADADDR(e->e_from.q_state))
			{
				/* it was a bogus mailer in the from addr */
				e->e_status = "5.1.7";
				usrerrenh(e->e_status,
					  "553 Invalid sender address");
			}
			SuprErrs = true;
		}
		if (from == realname ||
		    parseaddr(from = realname,
			      &e->e_from, RF_COPYALL|RF_SENDERADDR, ' ',
			      NULL, e, false) == NULL)
		{
			char nbuf[100];

			SuprErrs = true;
			expand("\201n", nbuf, sizeof(nbuf), e);
			from = sm_rpool_strdup_x(e->e_rpool, nbuf);
			if (parseaddr(from, &e->e_from, RF_COPYALL, ' ',
				      NULL, e, false) == NULL &&
			    parseaddr(from = "postmaster", &e->e_from,
				      RF_COPYALL, ' ', NULL, e, false) == NULL)
				syserr("553 5.3.0 setsender: can't even parse postmaster!");
		}
	}
	else
		FromFlag = true;
	e->e_from.q_state = QS_SENDER;
	if (tTd(45, 5))
	{
		sm_dprintf("setsender: QS_SENDER ");
		printaddr(sm_debug_file(), &e->e_from, false);
	}
	SuprErrs = false;

#if USERDB
	if (bitnset(M_CHECKUDB, e->e_from.q_mailer->m_flags))
	{
		register char *p;

		p = udbsender(e->e_from.q_user, e->e_rpool);
		if (p != NULL)
			from = p;
	}
#endif /* USERDB */

	if (bitnset(M_HASPWENT, e->e_from.q_mailer->m_flags))
	{
		SM_MBDB_T user;

		if (!internal)
		{
			/* if the user already given fullname don't redefine */
			if (FullName == NULL)
				FullName = macvalue('x', e);
			if (FullName != NULL)
			{
				if (FullName[0] == '\0')
					FullName = NULL;
				else
					FullName = newstr(FullName);
			}
		}

		if (e->e_from.q_user[0] != '\0' &&
		    sm_mbdb_lookup(e->e_from.q_user, &user) == EX_OK)
		{
			/*
			**  Process passwd file entry.
			*/

			/* extract home directory */
			if (*user.mbdb_homedir == '\0')
				e->e_from.q_home = NULL;
			else if (strcmp(user.mbdb_homedir, "/") == 0)
				e->e_from.q_home = "";
			else
				e->e_from.q_home = sm_rpool_strdup_x(e->e_rpool,
							user.mbdb_homedir);
			macdefine(&e->e_macro, A_PERM, 'z', e->e_from.q_home);

			/* extract user and group id */
			if (user.mbdb_uid != SM_NO_UID)
			{
				e->e_from.q_uid = user.mbdb_uid;
				e->e_from.q_gid = user.mbdb_gid;
				e->e_from.q_flags |= QGOODUID;
			}

			/* extract full name from passwd file */
			if (FullName == NULL && !internal &&
			    user.mbdb_fullname[0] != '\0' &&
			    strcmp(user.mbdb_name, e->e_from.q_user) == 0)
			{
				FullName = newstr(user.mbdb_fullname);
			}
		}
		else
		{
			e->e_from.q_home = NULL;
		}
		if (FullName != NULL && !internal)
			macdefine(&e->e_macro, A_TEMP, 'x', FullName);
	}
	else if (!internal && OpMode != MD_DAEMON && OpMode != MD_SMTP)
	{
		if (e->e_from.q_home == NULL)
		{
			e->e_from.q_home = getenv("HOME");
			if (e->e_from.q_home != NULL)
			{
				if (*e->e_from.q_home == '\0')
					e->e_from.q_home = NULL;
				else if (strcmp(e->e_from.q_home, "/") == 0)
					e->e_from.q_home++;
			}
		}
		e->e_from.q_uid = RealUid;
		e->e_from.q_gid = RealGid;
		e->e_from.q_flags |= QGOODUID;
	}

	/*
	**  Rewrite the from person to dispose of possible implicit
	**	links in the net.
	*/

	pvp = prescan(from, delimchar, pvpbuf, sizeof(pvpbuf), NULL,
			IntTokenTab, false);
	if (pvp == NULL)
	{
		/* don't need to give error -- prescan did that already */
		if (LogLevel > 2)
			sm_syslog(LOG_NOTICE, e->e_id,
				  "cannot prescan from (%s)",
				  shortenstring(from, MAXSHORTSTR));
		finis(true, true, ExitStat);
	}
	(void) REWRITE(pvp, 3, e);
	(void) REWRITE(pvp, 1, e);
	(void) REWRITE(pvp, 4, e);
	macdefine(&e->e_macro, A_PERM, macid("{addr_type}"), NULL);
	bp = buf + 1;
	cataddr(pvp, NULL, bp, sizeof(buf) - 2, '\0', false);
	if (*bp == '@@' && !bitnset(M_NOBRACKET, e->e_from.q_mailer->m_flags))
	{
		/* heuristic: route-addr: add angle brackets */
		(void) sm_strlcat(bp, ">", sizeof(buf) - 1);
		*--bp = '<';
	}
	e->e_sender = sm_rpool_strdup_x(e->e_rpool, bp);
	macdefine(&e->e_macro, A_PERM, 'f', e->e_sender);

	/* save the domain spec if this mailer wants it */
	if (e->e_from.q_mailer != NULL &&
	    bitnset(M_CANONICAL, e->e_from.q_mailer->m_flags))
	{
		char **lastat;

		/* get rid of any pesky angle brackets */
		macdefine(&e->e_macro, A_PERM, macid("{addr_type}"), "e s");
		(void) REWRITE(pvp, 3, e);
		(void) REWRITE(pvp, 1, e);
		(void) REWRITE(pvp, 4, e);
		macdefine(&e->e_macro, A_PERM, macid("{addr_type}"), NULL);

		/* strip off to the last "@@" sign */
		for (lastat = NULL; *pvp != NULL; pvp++)
		{
			if (strcmp(*pvp, "@@") == 0)
				lastat = pvp;
		}
		if (lastat != NULL)
		{
			e->e_fromdomain = copyplist(lastat, true, e->e_rpool);
			if (tTd(45, 3))
			{
				sm_dprintf("Saving from domain: ");
				printav(sm_debug_file(), e->e_fromdomain);
			}
		}
	}
}
/*
**  PRINTENVFLAGS -- print envelope flags for debugging
**
**	Parameters:
**		e -- the envelope with the flags to be printed.
**
**	Returns:
**		none.
*/

struct eflags
{
	char		*ef_name;
	unsigned long	ef_bit;
};

static struct eflags	EnvelopeFlags[] =
{
	{ "OLDSTYLE",		EF_OLDSTYLE	},
	{ "INQUEUE",		EF_INQUEUE	},
	{ "NO_BODY_RETN",	EF_NO_BODY_RETN	},
	{ "CLRQUEUE",		EF_CLRQUEUE	},
	{ "SENDRECEIPT",	EF_SENDRECEIPT	},
	{ "FATALERRS",		EF_FATALERRS	},
	{ "DELETE_BCC",		EF_DELETE_BCC	},
	{ "RESPONSE",		EF_RESPONSE	},
	{ "RESENT",		EF_RESENT	},
	{ "VRFYONLY",		EF_VRFYONLY	},
	{ "WARNING",		EF_WARNING	},
	{ "QUEUERUN",		EF_QUEUERUN	},
	{ "GLOBALERRS",		EF_GLOBALERRS	},
	{ "PM_NOTIFY",		EF_PM_NOTIFY	},
	{ "METOO",		EF_METOO	},
	{ "LOGSENDER",		EF_LOGSENDER	},
	{ "NORECEIPT",		EF_NORECEIPT	},
	{ "HAS8BIT",		EF_HAS8BIT	},
	{ "NL_NOT_EOL",		EF_NL_NOT_EOL	},
	{ "CRLF_NOT_EOL",	EF_CRLF_NOT_EOL	},
	{ "RET_PARAM",		EF_RET_PARAM	},
	{ "HAS_DF",		EF_HAS_DF	},
	{ "IS_MIME",		EF_IS_MIME	},
	{ "DONT_MIME",		EF_DONT_MIME	},
	{ "DISCARD",		EF_DISCARD	},
	{ "TOOBIG",		EF_TOOBIG	},
	{ "SPLIT",		EF_SPLIT	},
	{ "UNSAFE",		EF_UNSAFE	},
	{ NULL,			0		}
};

void
printenvflags(e)
	register ENVELOPE *e;
{
	register struct eflags *ef;
	bool first = true;

	sm_dprintf("%lx", e->e_flags);
	for (ef = EnvelopeFlags; ef->ef_name != NULL; ef++)
	{
		if (!bitset(ef->ef_bit, e->e_flags))
			continue;
		if (first)
			sm_dprintf("<%s", ef->ef_name);
		else
			sm_dprintf(",%s", ef->ef_name);
		first = false;
	}
	if (!first)
		sm_dprintf(">\n");
}
@


1.6
log
@merge newer sendmail; fix and correct; reduce upstream diffs; prep for deb
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003, 2006 Sendmail, Inc. and its suppliers.
d16 2
a17 2
SM_RCSID("$MirOS: src/gnu/usr.sbin/sendmail/sendmail/envelope.c,v 1.5 2009/11/18 08:53:39 tg Exp $")
SM_RCSID("@@(#)$Id: envelope.c,v 8.312 2010/02/03 16:36:40 ca Exp $")
@


1.5
log
@fix format strings; discovered at work when finding bogus message IDs
@
text
@d16 2
a17 2
SM_RCSID("$MirOS$")
SM_RCSID("@@(#)$Sendmail: envelope.c,v 8.305 2008/03/31 16:32:13 ca Exp $")
d167 1
a167 1
**		none.
d174 1
a174 1
void
d213 1
a213 1
		return;
d219 3
d250 1
d257 1
d627 3
d631 1
d727 3
@


1.4
log
@update to sendmail 8.14.3 (which has been on my TODO for 4 days *shames*),
a hah-I-knew-it! update for a bug I reported in IRCâ€¦ (which seems lost, as
only DFBSD, OBSD etc. are credited for finding):

Sendmail, Inc., and the Sendmail Consortium announce the availability
of sendmail 8.14.3. This version fixes some bugs:

o the MTA accessed storage after it free()d it. This was a regression
  introduced in 8.14.2, but the bug only showed up on a few operating
  systems.
o ruleset processing: the function cataddr() could cause the
  addition of the BlankSub character between some tokens when it
  should not happen and thus failures in rule matching.  It seems
  that none of the default rules were affected by this bug and hence
  the problem did not show up for default configurations.
o the libmilter state engine did not deal correctly with milters
  that requested the omission of protocol steps during the negotiation
  callback.

A complete list of changes can be found in the release notes [â€¦]
@
text
@d16 1
d828 1
a828 1
			   tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,
@


1.3
log
@circumvent (not fix) a SIGSEGV occuring under some circumstances in
sendmail(8) â€“ for instance, when receiving mails via STARTTLS

this does not seem to be STARTTLS related, however:
the macvalue(macid("{deliveryMode}"), parent) call returns an out of range
string pointer, which is then dereferenced â€“ no idea why the rv is invalid
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: envelope.c,v 8.302 2006/11/10 23:12:52 ca Exp $")
d78 1
a78 1
	int sendmode, dm;
a88 2
	dm = DM_NOTSET;
#ifdef gimme_a_sigsegv_please
a89 3
	{
		char *str;

a90 4
		str = macvalue(macid("{deliveryMode}"), parent);
		if (str != NULL)
			dm = (int) str[0];
	}
a91 1
#endif
d139 1
a139 3
		e->e_sendmode = sendmode;
	if (dm != DM_NOTSET)
		set_delivery_mode(dm, e);
@


1.2
log
@upgrade from sendmail 8.14.1 to 8.14.2 ourselves:
> From donotreply@@lists.sendmail.org Fri Nov  2 02:46:04 2007
> From: Claus Assmann <donotreply@@lists.sendmail.org>
Message-ID: <200711020234.lA22YPul046763@@lists.sendmail.org>
To: sendmail-announce@@sendmail.org
Date: Thu, 1 Nov 2007 19:34:25 -0700 (PDT)
Subject: sendmail 8.14.2 available

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Sendmail, Inc., and the Sendmail Consortium announce the availability
of sendmail 8.14.2 which fixes some problems, e.g.,

- - an important bug in the milter function smfi_chgfrom() which could
  cause the loss of a message body.
- - the handling of queued messages with 8 bit characters in From:
  or To: header which could be "mistaken" for internal control
  characters during a queue run and trigger various consistency checks.
- - the handling of lines longer than MAXLINE-1 characters in certain
  cases.

A complete list of changes can be found in the release notes (see
below).

Please send bug reports and general feedback to one of the addresses
listed at: http://www.sendmail.org/email-addresses.html

The version can be found at

ftp://ftp.sendmail.org/pub/sendmail/sendmail.8.14.2.tar.gz
ftp://ftp.sendmail.org/pub/sendmail/sendmail.8.14.2.tar.gz.sig
ftp://ftp.sendmail.org/pub/sendmail/sendmail.8.14.2.tar.Z
ftp://ftp.sendmail.org/pub/sendmail/sendmail.8.14.2.tar.Z.sig

MD5 signatures:
cf784b9f20c32949ae1f38f3eae29875 sendmail.8.14.2.tar.Z
f788d6986f12a81ac958195b045a529d sendmail.8.14.2.tar.Z.sig
1c1472365344ca8061d6453c43c9a831 sendmail.8.14.2.tar.gz
2ae4b6175a08e8a6cda992db20141d81 sendmail.8.14.2.tar.gz.sig

You either need the first two files or the third and fourth, i.e.,
the gzip'ed version or the compressed version and the corresponding
sig file.  The PGP signature was created using the Sendmail Signing
Key/2007, available on the web site (http://www.sendmail.org/) or
on the public key servers.

Since sendmail 8.11 and later includes hooks to cryptography, the
following information from OpenSSL applies to sendmail as well.

   PLEASE REMEMBER THAT EXPORT/IMPORT AND/OR USE OF STRONG CRYPTOGRAPHY
   SOFTWARE, PROVIDING CRYPTOGRAPHY HOOKS OR EVEN JUST COMMUNICATING
   TECHNICAL DETAILS ABOUT CRYPTOGRAPHY SOFTWARE IS ILLEGAL IN SOME
   PARTS OF THE WORLD.  SO, WHEN YOU IMPORT THIS PACKAGE TO YOUR
   COUNTRY, RE-DISTRIBUTE IT FROM THERE OR EVEN JUST EMAIL TECHNICAL
   SUGGESTIONS OR EVEN SOURCE PATCHES TO THE AUTHOR OR OTHER PEOPLE
   YOU ARE STRONGLY ADVISED TO PAY CLOSE ATTENTION TO ANY EXPORT/IMPORT
   AND/OR USE LAWS WHICH APPLY TO YOU. THE AUTHORS ARE NOT LIABLE FOR
   ANY VIOLATIONS YOU MAKE HERE. SO BE CAREFUL, IT IS YOUR RESPONSIBILITY.


			SENDMAIL RELEASE NOTES
      $Id: RELEASE_NOTES,v 8.1909 2007/10/31 16:04:13 ca Exp $


This listing shows the version of the sendmail binary, the version
of the sendmail configuration files, the date of release, and a
summary of the changes in that release.

8.14.2/8.14.2	2007/11/01
	If a message was queued and it contained 8 bit characters in
		a From: or To: header, then those characters could be
		"mistaken" for internal control characters during a queue
		run and trigger various consistency checks.  Problem
		noted by Neil Rickert of Northern Illinois University.
	If MaxMimeHeaderLength is set to a value greater than 0 (which
		it is by default) then even if the Linelimit parameter
		is 0, sendmail corrupted in the non-transfer-encoding
		case every MAXLINE-1 characters.  Patch from John Gardiner
		Myers of Proofpoint.
	Setting the suboption DeliveryMode for DaemonPortOptions did not
		work in earlier 8.14 versions.
	Note: DeliveryMode=interactive is silently converted to
		background if a milter can reject or delete a recipient.
		Prior to 8.14 this happened only if milter could delete
		recipients.
	ClientRate should trigger when the limit was exceeded (as
		documented), not when it was reached.  Patch from
		John Beck of Sun Microsystems.
	Force a queue run for -qGqueuegroup even if no runners are
		specified (R=0) and forking (F=f) is requested.
	When multiple results are requested for a DNS map lookup
		(-z and -Z), return only those that are relevant for
		the query (not also those in the "additional section".)
	If the message transfer time to sendmail (when acting as server)
		exceeds Timeout.queuewarn or Timeout.queuereturn and
		the message is refused (by a milter), sendmail previously
		created a delivery status notification (DSN).  Patch
		from Doug Heath of The Hertz Corporation.
	A code change in Cyrus-SASL 2.1.22 for sasl_decode64() requires
		the MTA to deal with some input (i.e., "=") itself.
		Problem noted by Eliot Lear.
	sendmail counted a delivery as successful if PIPELINING is
		compiled in but not offered by the server and the
		delivery failed temporarily.  Patch from Werner Wiethege.
	If getting the result of an LDAP query times out then close the
		map so it will be reopened on the next lookup.  This
		should help "failover" configurations that specify more
		than one LDAP server.
	If check_compat returns $#discard then a "savemail panic" could
		be triggered under some circumstances (e.g., requiring
		a system which does not have the compile time flag
		HASFLOCK set). Based on patch by Motonori Nakamura
		of National Institute of Informatics, Japan.
	If a milter rejected a recipient, the count for nrcpts= in the
		logfile entry might have been wrong.  Problem found by
		Petra Humann of TU Dresden.
	If a milter invoked smfi_chgfrom() where ESMTP arguments are not
		NULL, the message body was lost.  Patch from Motonori
		Nakamura of National Institute of Informatics, Japan.
	sendmail(8) had a bogus space in -qGname.  Patch from Peng Haitao.
	CONTRIB: buildvirtuser: Preserve ownership and permissions when
		replacing files.
	CONTRIB: buildvirtuser: Skip dot-files (e.g., .cvsignore) when
		reading the /etc/mail/virtusers/ directory.
	CONTRIB: buildvirtuser: Emit warnings instead of exiting where
		appropriate.
	LIBMILTER: Fix ABI backwards compatibility so milters compiled
		against an older libmilter.so shared library can use an
		8.14 libmilter.so shared library.
	LIBMILTER: smfi_version() did not properly extract the patchlevel
		from the version number, however, the returned value was
		correct for the current libmilter version.

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.5 (OpenBSD)

iQCVAwUBRyqEOs8etQMiMnoBAQKNdQP/cQKfjVP7qTi0Ol/OgR7AnvCaerCxiQ5J
y1uxjwXs2s+RemX0u5a4c0agoLscTKU5Ot6uzOdvKvZd0/unr/IkzuXZBF9LsnlZ
X1wS4GXQDXKDfazvwdwOUgxkthMZU1TiVFj/GH5TOfHqVUO5Ho/yRfAQoAn3taFc
5jeg+A3+M9M=
=DJHS
-----END PGP SIGNATURE-----
@
text
@d90 1
d101 1
@


1.2.2.1
log
@circumvent (not fix) a SIGSEGV occuring under some circumstances in
sendmail(8) â€“ for instance, when receiving mails via STARTTLS

this does not seem to be STARTTLS related, however:
the macvalue(macid("{deliveryMode}"), parent) call returns an out of range
string pointer, which is then dereferenced â€“ no idea why the rv is invalid
@
text
@a89 1
#ifdef gimme_a_sigsegv_please
a99 1
#endif
@


1.2.2.2
log
@MFC sendmail update to 8.14.3

agreed bsiegert@@
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: envelope.c,v 8.305 2008/03/31 16:32:13 ca Exp $")
d78 1
a78 1
	int sendmode;
d89 2
d92 3
d96 4
d101 1
d149 3
a151 1
		set_delivery_mode(sendmode, e);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: envelope.c,v 8.293 2004/02/18 00:46:18 gshapiro Exp $")
d78 2
d89 13
d108 1
a108 1
			sizeof e->e_from);
d112 1
a112 1
			sizeof e->e_from);
d116 3
d122 6
d146 4
d305 1
a305 1
				(void) sm_snprintf(buf, sizeof buf,
d311 1
a311 1
				(void) sm_snprintf(buf, sizeof buf,
d403 1
a403 1
					(void) sm_snprintf(buf, sizeof buf,
d408 1
a408 1
					(void) sm_snprintf(buf, sizeof buf,
d504 1
a504 1
			expand(PostMasterCopy, pcopy, sizeof pcopy, e);
d535 6
d542 1
d556 1
a556 1
			updfs(e, true, !panic);
d722 2
a723 2
		*nhp = (HDR *) sm_rpool_malloc_x(rpool, sizeof *bh);
		memmove((char *) *nhp, (char *) bh, sizeof *bh);
d782 1
a782 1
	(void) sm_snprintf(buf, sizeof buf, "%d", (int) CurrentPid);
d786 1
a786 1
	(void) sm_snprintf(buf, sizeof buf, "%d", e->e_hopcount);
d804 1
a804 1
			(void) sm_strlcpy(ybuf, sizeof ybuf, p);
d833 1
a833 1
	(void) sm_snprintf(buf, sizeof buf, "%ld", (long) now);
d836 1
a836 1
	(void) sm_snprintf(buf, sizeof buf, "%04d%02d%02d%02d%02d",
d840 1
a840 1
	(void) sm_strlcpy(buf, ctime(&now), sizeof buf);
d1029 1
a1029 1
				(void) sm_snprintf(ebuf, sizeof ebuf,
d1057 1
a1057 1
			expand("\201n", nbuf, sizeof nbuf, e);
d1168 2
a1169 1
	pvp = prescan(from, delimchar, pvpbuf, sizeof pvpbuf, NULL, NULL, false);
d1184 1
a1184 1
	cataddr(pvp, NULL, bp, sizeof buf - 2, '\0');
d1188 1
a1188 1
		(void) sm_strlcat(bp, ">", sizeof buf - 1);
@


1.1.127.1
log
@Import Sendmail 8.14.3, suitably stripped down by the not yet committed
contrib/samples/import-3rdpty,v 1.35; we have some new and renamed files
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003, 2006 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Id: envelope.c,v 8.305 2008/03/31 16:32:13 ca Exp $")
a77 2
	int sendmode;

a86 5
	if (parent != NULL)
		sendmode = parent->e_sendmode;
	else
		sendmode = DM_NOTSET;

d93 1
a93 1
			sizeof(e->e_from));
d97 1
a97 1
			sizeof(e->e_from));
a100 3
#if _FFR_SESSID
	e->e_sessid = e->e_id;
#endif /* _FFR_SESSID */
a103 6
#if _FFR_SESSID
		if (parent->e_sessid != NULL)
			e->e_sessid = sm_rpool_strdup_x(rpool,
							parent->e_sessid);
#endif /* _FFR_SESSID */

a121 2
	if (sendmode != DM_NOTSET)
		set_delivery_mode(sendmode, e);
d277 1
a277 1
				(void) sm_snprintf(buf, sizeof(buf),
d283 1
a283 1
				(void) sm_snprintf(buf, sizeof(buf),
d375 1
a375 1
					(void) sm_snprintf(buf, sizeof(buf),
d380 1
a380 1
					(void) sm_snprintf(buf, sizeof(buf),
d476 1
a476 1
			expand(PostMasterCopy, pcopy, sizeof(pcopy), e);
a506 6
		{
			if (e->e_dfp != NULL)
			{
				(void) sm_io_close(e->e_dfp, SM_TIME_DEFAULT);
				e->e_dfp = NULL;
			}
a507 1
		}
d521 1
a521 1
			updfs(e, -1, panic ? 0 : -1, "dropenvelope");
d687 2
a688 2
		*nhp = (HDR *) sm_rpool_malloc_x(rpool, sizeof(*bh));
		memmove((char *) *nhp, (char *) bh, sizeof(*bh));
d747 1
a747 1
	(void) sm_snprintf(buf, sizeof(buf), "%d", (int) CurrentPid);
d751 1
a751 1
	(void) sm_snprintf(buf, sizeof(buf), "%d", e->e_hopcount);
d769 1
a769 1
			(void) sm_strlcpy(ybuf, sizeof(ybuf), p);
d798 1
a798 1
	(void) sm_snprintf(buf, sizeof(buf), "%ld", (long) now);
d801 1
a801 1
	(void) sm_snprintf(buf, sizeof(buf), "%04d%02d%02d%02d%02d",
d805 1
a805 1
	(void) sm_strlcpy(buf, ctime(&now), sizeof(buf));
d994 1
a994 1
				(void) sm_snprintf(ebuf, sizeof(ebuf),
d1022 1
a1022 1
			expand("\201n", nbuf, sizeof(nbuf), e);
d1133 1
a1133 2
	pvp = prescan(from, delimchar, pvpbuf, sizeof(pvpbuf), NULL,
			IntTokenTab, false);
d1148 1
a1148 1
	cataddr(pvp, NULL, bp, sizeof(buf) - 2, '\0', false);
d1152 1
a1152 1
		(void) sm_strlcat(bp, ">", sizeof(buf) - 1);
@


1.1.127.2
log
@Import sendmail.8.14.5.Beta0.tar.gz
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Id: envelope.c,v 8.312 2010/02/03 16:36:40 ca Exp $")
d166 1
a166 1
**		EX_* status (currently: 0: success, EX_IOERR on panic)
d173 1
a173 1
int
d212 1
a212 1
		return EX_OK;
a217 3
	if (tTd(92, 2))
		sm_dprintf("dropenvelope: e_id=%s, EF_LOGSENDER=%d, LogLevel=%d\n",
			e->e_id, bitset(EF_LOGSENDER, e->e_flags), LogLevel);
a245 1

a251 1

a620 3
	if (panic)
		return EX_IOERR;
	return EX_OK;
a621 1

a716 3
#if _FFR_MILTER_ENHSC
	e->e_enhsc[0] = '\0';
#endif /* _FFR_MILTER_ENHSC */
@


1.1.127.3
log
@Import sendmail 8.14.9
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003, 2006 Proofpoint, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Id: envelope.c,v 8.313 2013-11-22 20:51:55 ca Exp $")
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@I persuaded myself to import another fix... though sendmail needed
much less updates/fixes recently than any other MTA (except qmüll)
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: envelope.c,v 8.294 2005/02/16 23:38:51 ca Exp $")
d521 1
a521 1
			updfs(e, -1, panic ? 0 : -1, "dropenvelope");
@


1.1.1.2.2.1
log
@MFC most of the recent sendmail updates to MirOS #8-stable
agreed bsiegert@@

This also changes the LOCALBASE stuff, links libmilter not
against LDAP, etc. but doesn't install the FreeBSD 6 confs
nor a shared libmilter in order to pass a no-files-diff:

tg@@maou:/usr/src/gnu/usr.sbin/sendmail $ sudo find / -ls | sort -k11 >~/x1
tg@@maou:/usr/src/gnu/usr.sbin/sendmail $ sudo make install
tg@@maou:/usr/src/gnu/usr.sbin/sendmail/cf/cf $ sudo make distribution
tg@@maou:/usr/src/gnu/usr.sbin/sendmail/cf/cf $ sudo find / -ls | sort -k11 | diff -u ~/x1 - | less

Note: files in /etc/mail/ are also changed, this affects the etc8.ngz set
on fresh installs and cannot(!) be automatically upgraded!
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: envelope.c,v 8.295 2005/06/15 20:32:18 ca Exp $")
a77 4
#if _FFR_DM_PER_DAEMON
	int		sendmode;
#endif /* _FFR_DM_PER_DAEMON */

a86 7
#if _FFR_DM_PER_DAEMON
	if (parent != NULL)
		sendmode = parent->e_sendmode;
	else
		sendmode = DM_NOTSET;
#endif /* _FFR_DM_PER_DAEMON */

a121 4
#if _FFR_DM_PER_DAEMON
	if (sendmode != DM_NOTSET)
		e->e_sendmode = sendmode;
#endif /* _FFR_DM_PER_DAEMON */
@


1.1.1.3
log
@Update to Sendmail 8.13.6
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: envelope.c,v 8.295 2005/06/15 20:32:18 ca Exp $")
a77 4
#if _FFR_DM_PER_DAEMON
	int		sendmode;
#endif /* _FFR_DM_PER_DAEMON */

a86 7
#if _FFR_DM_PER_DAEMON
	if (parent != NULL)
		sendmode = parent->e_sendmode;
	else
		sendmode = DM_NOTSET;
#endif /* _FFR_DM_PER_DAEMON */

a121 4
#if _FFR_DM_PER_DAEMON
	if (sendmode != DM_NOTSET)
		e->e_sendmode = sendmode;
#endif /* _FFR_DM_PER_DAEMON */
@


1.1.1.4
log
@Import latest Sendmail
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: envelope.c,v 8.296 2006/03/31 18:53:50 ca Exp $")
a521 6
		{
			if (e->e_dfp != NULL)
			{
				(void) sm_io_close(e->e_dfp, SM_TIME_DEFAULT);
				e->e_dfp = NULL;
			}
a522 1
		}
@


1.1.1.5
log
@Import Sendmail 8.14.0 via OpenBSD
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003, 2006 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: envelope.c,v 8.302 2006/11/10 23:12:52 ca Exp $")
d78 3
a80 1
	int sendmode;
d91 1
d96 1
d104 1
a104 1
			sizeof(e->e_from));
d108 1
a108 1
			sizeof(e->e_from));
d133 1
d136 1
d292 1
a292 1
				(void) sm_snprintf(buf, sizeof(buf),
d298 1
a298 1
				(void) sm_snprintf(buf, sizeof(buf),
d390 1
a390 1
					(void) sm_snprintf(buf, sizeof(buf),
d395 1
a395 1
					(void) sm_snprintf(buf, sizeof(buf),
d491 1
a491 1
			expand(PostMasterCopy, pcopy, sizeof(pcopy), e);
d709 2
a710 2
		*nhp = (HDR *) sm_rpool_malloc_x(rpool, sizeof(*bh));
		memmove((char *) *nhp, (char *) bh, sizeof(*bh));
d769 1
a769 1
	(void) sm_snprintf(buf, sizeof(buf), "%d", (int) CurrentPid);
d773 1
a773 1
	(void) sm_snprintf(buf, sizeof(buf), "%d", e->e_hopcount);
d791 1
a791 1
			(void) sm_strlcpy(ybuf, sizeof(ybuf), p);
d820 1
a820 1
	(void) sm_snprintf(buf, sizeof(buf), "%ld", (long) now);
d823 1
a823 1
	(void) sm_snprintf(buf, sizeof(buf), "%04d%02d%02d%02d%02d",
d827 1
a827 1
	(void) sm_strlcpy(buf, ctime(&now), sizeof(buf));
d1016 1
a1016 1
				(void) sm_snprintf(ebuf, sizeof(ebuf),
d1044 1
a1044 1
			expand("\201n", nbuf, sizeof(nbuf), e);
d1155 1
a1155 2
	pvp = prescan(from, delimchar, pvpbuf, sizeof(pvpbuf), NULL,
			IntTokenTab, false);
d1170 1
a1170 1
	cataddr(pvp, NULL, bp, sizeof(buf) - 2, '\0', false);
d1174 1
a1174 1
		(void) sm_strlcat(bp, ">", sizeof(buf) - 1);
@


1.1.1.6
log
@OpenBSD finally has upgraded their sendmail, tooâ€¦
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: envelope.c,v 8.305 2008/03/31 16:32:13 ca Exp $")
a107 3
#if _FFR_SESSID
	e->e_sessid = e->e_id;
#endif /* _FFR_SESSID */
a110 6
#if _FFR_SESSID
		if (parent->e_sessid != NULL)
			e->e_sessid = sm_rpool_strdup_x(rpool,
							parent->e_sessid);
#endif /* _FFR_SESSID */

d130 1
a130 1
		set_delivery_mode(sendmode, e);
@


1.1.1.7
log
@Replace â€œ$Sendmail: â€ with â€œ$Id: â€ (the latter is used by upstream)
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Id: envelope.c,v 8.305 2008/03/31 16:32:13 ca Exp $")
@


1.1.1.8
log
@Import OpenBSDâ€™s sendmail 8.14.5, RCS IDs properly sedded back
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Id: envelope.c,v 8.312 2010/02/03 16:36:40 ca Exp $")
d166 1
a166 1
**		EX_* status (currently: 0: success, EX_IOERR on panic)
d173 1
a173 1
int
d212 1
a212 1
		return EX_OK;
a217 3
	if (tTd(92, 2))
		sm_dprintf("dropenvelope: e_id=%s, EF_LOGSENDER=%d, LogLevel=%d\n",
			e->e_id, bitset(EF_LOGSENDER, e->e_flags), LogLevel);
a245 1

a251 1

a620 3
	if (panic)
		return EX_IOERR;
	return EX_OK;
a621 1

a716 3
#if _FFR_MILTER_ENHSC
	e->e_enhsc[0] = '\0';
#endif /* _FFR_MILTER_ENHSC */
@


