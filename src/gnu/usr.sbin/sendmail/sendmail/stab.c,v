head	1.4;
access;
symbols
	sendmail-8_14_9:1.1.127.3
	sendmail-8_14_7:1.1.127.2
	sendmail-8_14_6:1.1.127.2
	sendmail-8_14_5-ERRATA-1:1.1.127.1
	mbsd-20101220_mergebase:1.1.1.2.4.1
	sendmail-8_14_5:1.1.127.1
	cvs-201107021500:1.1.1.3
	cvs-20101220:1.1.1.3
	mbsd-20101220:1.1.1.2.0.4
	cvs-201012191730:1.1.1.2
	sendmail-8_14_5_Beta0:1.1.127.1
	sendmail-8_14_3:1.1.127.1
	sendmail:1.1.127
	cvs-200812170000:1.1.1.2
	cvs-200805071200:1.1.1.2
	MIRBSD_10:1.1.1.2.0.2
	MIRBSD_10_BASE:1.1.1.2
	cvs-200803022030:1.1.1.2
	cvs-200707152000:1.1.1.2
	cvs-200704292000:1.1.1.2
	cvs-200702051700:1.1.1.2
	cvs-200609121900:1.1.1.1
	MIRBSD_9_BASE:1.1.1.1
	cvs-200606151800:1.1.1.1
	cvs-200603231300:1.1.1.1
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200507211800:1.1.1.1
	cvs-200504262050:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2014.06.09.15.17.59;	author tg;	state Exp;
branches;
next	1.3;
commitid	1005395CFC65E5646F1;

1.3
date	2012.12.31.21.02.55;	author tg;	state Exp;
branches;
next	1.2;
commitid	10050E1FD6765F66D0C;

1.2
date	2011.07.02.15.04.11;	author tg;	state Exp;
branches;
next	1.1;
commitid	1004E0F31C5496AB95F;

1.1
date	2005.02.05.17.24.29;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.127.1;
next	;

1.1.1.1
date	2005.02.05.17.24.29;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.02.05.17.06.48;	author tg;	state Exp;
branches
	1.1.1.2.4.1;
next	1.1.1.3;
commitid	10045C763C551AABAF7;

1.1.1.3
date	2011.07.02.15.01.08;	author tg;	state Exp;
branches;
next	;
commitid	1004E0F31C5496AB95F;

1.1.1.2.4.1
date	2011.07.02.15.02.59;	author tg;	state Exp;
branches;
next	;
commitid	1004E0F31C5496AB95F;

1.1.127.1
date	2010.12.19.14.45.47;	author tg;	state Exp;
branches;
next	1.1.127.2;
commitid	1004D0E1A94384778FD;

1.1.127.2
date	2012.12.31.20.38.37;	author tg;	state Exp;
branches;
next	1.1.127.3;
commitid	10050E1F79A4182E8EC;

1.1.127.3
date	2014.06.09.14.29.18;	author tg;	state Exp;
branches;
next	;
commitid	1005395C4CC1A6DB9EE;


desc
@@


1.4
log
@merge
@
text
@/*
 * Copyright (c) 1998-2001, 2003 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>

SM_RCSID("@@(#)$Id: stab.c,v 8.92 2013-11-22 20:51:56 ca Exp $")

/*
**  STAB -- manage the symbol table
**
**	Parameters:
**		name -- the name to be looked up or inserted.
**		type -- the type of symbol.
**		op -- what to do:
**			ST_ENTER -- enter the name if not already present.
**			ST_FIND -- find it only.
**
**	Returns:
**		pointer to a STAB entry for this name.
**		NULL if not found and not entered.
**
**	Side Effects:
**		can update the symbol table.
*/

#define STABSIZE	2003
#define SM_LOWER(c)	((isascii(c) && isupper(c)) ? tolower(c) : (c))

static STAB	*SymTab[STABSIZE];

STAB *
stab(name, type, op)
	char *name;
	int type;
	int op;
{
	register STAB *s;
	register STAB **ps;
	register int hfunc;
	register char *p;
	int len;

	if (tTd(36, 5))
		sm_dprintf("STAB: %s %d ", name, type);

	/*
	**  Compute the hashing function
	*/

	hfunc = type;
	for (p = name; *p != '\0'; p++)
		hfunc = ((hfunc << 1) ^ (SM_LOWER(*p) & 0377)) % STABSIZE;

	if (tTd(36, 9))
		sm_dprintf("(hfunc=%d) ", hfunc);

	ps = &SymTab[hfunc];
	if (type == ST_MACRO || type == ST_RULESET || type == ST_NAMECANON)
	{
		while ((s = *ps) != NULL &&
		       (s->s_symtype != type || strcmp(name, s->s_name)))
			ps = &s->s_next;
	}
	else
	{
		while ((s = *ps) != NULL &&
		       (s->s_symtype != type || sm_strcasecmp(name, s->s_name)))
			ps = &s->s_next;
	}

	/*
	**  Dispose of the entry.
	*/

	if (s != NULL || op == ST_FIND)
	{
		if (tTd(36, 5))
		{
			if (s == NULL)
				sm_dprintf("not found\n");
			else
			{
				long *lp = (long *) s->s_class;

				sm_dprintf("type %d val %lx %lx %lx %lx\n",
					s->s_symtype, lp[0], lp[1], lp[2], lp[3]);
			}
		}
		return s;
	}

	/*
	**  Make a new entry and link it in.
	*/

	if (tTd(36, 5))
		sm_dprintf("entered\n");

	/* determine size of new entry */
	switch (type)
	{
	  case ST_CLASS:
		len = sizeof(s->s_class);
		break;

	  case ST_MAILER:
		len = sizeof(s->s_mailer);
		break;

	  case ST_ALIAS:
		len = sizeof(s->s_alias);
		break;

	  case ST_MAPCLASS:
		len = sizeof(s->s_mapclass);
		break;

	  case ST_MAP:
		len = sizeof(s->s_map);
		break;

	  case ST_HOSTSIG:
		len = sizeof(s->s_hostsig);
		break;

	  case ST_NAMECANON:
		len = sizeof(s->s_namecanon);
		break;

	  case ST_MACRO:
		len = sizeof(s->s_macro);
		break;

	  case ST_RULESET:
		len = sizeof(s->s_ruleset);
		break;

	  case ST_HEADER:
		len = sizeof(s->s_header);
		break;

	  case ST_SERVICE:
		len = sizeof(s->s_service);
		break;

#if LDAPMAP
	  case ST_LMAP:
		len = sizeof(s->s_lmap);
		break;
#endif /* LDAPMAP */

#if MILTER
	  case ST_MILTER:
		len = sizeof(s->s_milter);
		break;
#endif /* MILTER */

	  case ST_QUEUE:
		len = sizeof(s->s_quegrp);
		break;

#if SOCKETMAP
	  case ST_SOCKETMAP:
		len = sizeof(s->s_socketmap);
		break;
#endif /* SOCKETMAP */

	  default:
		/*
		**  Each mailer has its own MCI stab entry:
		**
		**  s = stab(host, ST_MCI + m->m_mno, ST_ENTER);
		**
		**  Therefore, anything ST_MCI or larger is an s_mci.
		*/

		if (type >= ST_MCI)
			len = sizeof(s->s_mci);
		else
		{
			syserr("stab: unknown symbol type %d", type);
			len = sizeof(s->s_value);
		}
		break;
	}
	len += sizeof(*s) - sizeof(s->s_value);

	if (tTd(36, 15))
		sm_dprintf("size of stab entry: %d\n", len);

	/* make new entry */
	s = (STAB *) sm_pmalloc_x(len);
	memset((char *) s, '\0', len);
	s->s_name = sm_pstrdup_x(name);
	s->s_symtype = type;

	/* link it in */
	*ps = s;

	/* set a default value for rulesets */
	if (type == ST_RULESET)
		s->s_ruleset = -1;

	return s;
}
/*
**  STABAPPLY -- apply function to all stab entries
**
**	Parameters:
**		func -- the function to apply.  It will be given two
**			parameters (the stab entry and the arg).
**		arg -- an arbitrary argument, passed to func.
**
**	Returns:
**		none.
*/

void
stabapply(func, arg)
	void (*func)__P((STAB *, int));
	int arg;
{
	register STAB **shead;
	register STAB *s;

	for (shead = SymTab; shead < &SymTab[STABSIZE]; shead++)
	{
		for (s = *shead; s != NULL; s = s->s_next)
		{
			if (tTd(36, 90))
				sm_dprintf("stabapply: trying %d/%s\n",
					s->s_symtype, s->s_name);
			func(s, arg);
		}
	}
}
/*
**  QUEUEUP_MACROS -- queueup the macros in a class
**
**	Write the macros listed in the specified class into the
**	file referenced by qfp.
**
**	Parameters:
**		class -- class ID.
**		qfp -- file pointer to the queue file.
**		e -- the envelope.
**
**	Returns:
**		none.
*/

void
queueup_macros(class, qfp, e)
	int class;
	SM_FILE_T *qfp;
	ENVELOPE *e;
{
	register STAB **shead;
	register STAB *s;

	if (e == NULL)
		return;

	class = bitidx(class);
	for (shead = SymTab; shead < &SymTab[STABSIZE]; shead++)
	{
		for (s = *shead; s != NULL; s = s->s_next)
		{
			int m;
			char *p;

			if (s->s_symtype == ST_CLASS &&
			    bitnset(bitidx(class), s->s_class) &&
			    (m = macid(s->s_name)) != 0 &&
			    (p = macvalue(m, e)) != NULL)
			{
				(void) sm_io_fprintf(qfp, SM_TIME_DEFAULT,
						      "$%s%s\n",
						      s->s_name,
						      denlstring(p, true,
								 false));
			}
		}
	}
}
/*
**  COPY_CLASS -- copy class members from one class to another
**
**	Parameters:
**		src -- source class.
**		dst -- destination class.
**
**	Returns:
**		none.
*/

void
copy_class(src, dst)
	int src;
	int dst;
{
	register STAB **shead;
	register STAB *s;

	src = bitidx(src);
	dst = bitidx(dst);
	for (shead = SymTab; shead < &SymTab[STABSIZE]; shead++)
	{
		for (s = *shead; s != NULL; s = s->s_next)
		{
			if (s->s_symtype == ST_CLASS &&
			    bitnset(src, s->s_class))
				setbitn(dst, s->s_class);
		}
	}
}

/*
**  RMEXPSTAB -- remove expired entries from SymTab.
**
**	These entries need to be removed in long-running processes,
**	e.g., persistent queue runners, to avoid consuming memory.
**
**	XXX It might be useful to restrict the maximum TTL to avoid
**		caching data very long.
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		can remove entries from the symbol table.
*/

#define SM_STAB_FREE(x)	\
	do \
	{ \
		char *o = (x); \
		(x) = NULL; \
		if (o != NULL) \
			sm_free(o); \
	} while (0)

void
rmexpstab()
{
	int i;
	STAB *s, *p, *f;
	time_t now;

	now = curtime();
	for (i = 0; i < STABSIZE; i++)
	{
		p = NULL;
		s = SymTab[i];
		while (s != NULL)
		{
			switch (s->s_symtype)
			{
			  case ST_HOSTSIG:
				if (s->s_hostsig.hs_exp >= now)
					goto next;	/* not expired */
				SM_STAB_FREE(s->s_hostsig.hs_sig); /* XXX */
				break;

			  case ST_NAMECANON:
				if (s->s_namecanon.nc_exp >= now)
					goto next;	/* not expired */
				SM_STAB_FREE(s->s_namecanon.nc_cname); /* XXX */
				break;

			  default:
				if (s->s_symtype >= ST_MCI)
				{
					/* call mci_uncache? */
					SM_STAB_FREE(s->s_mci.mci_status);
					SM_STAB_FREE(s->s_mci.mci_rstatus);
					SM_STAB_FREE(s->s_mci.mci_heloname);
#if 0
					/* not dynamically allocated */
					SM_STAB_FREE(s->s_mci.mci_host);
					SM_STAB_FREE(s->s_mci.mci_tolist);
#endif /* 0 */
#if SASL
					/* should always by NULL */
					SM_STAB_FREE(s->s_mci.mci_sasl_string);
#endif /* SASL */
					if (s->s_mci.mci_rpool != NULL)
					{
						sm_rpool_free(s->s_mci.mci_rpool);
						s->s_mci.mci_macro.mac_rpool = NULL;
						s->s_mci.mci_rpool = NULL;
					}
					break;
				}
  next:
				p = s;
				s = s->s_next;
				continue;
			}

			/* remove entry */
			SM_STAB_FREE(s->s_name); /* XXX */
			f = s;
			s = s->s_next;
			sm_free(f);	/* XXX */
			if (p == NULL)
				SymTab[i] = s;
			else
				p->s_next = s;
		}
	}
}

#if SM_HEAP_CHECK
/*
**  DUMPSTAB -- dump symbol table.
**
**	For debugging.
*/

#define MAXSTTYPES	(ST_MCI + 1)

void
dumpstab()
{
	int i, t, total, types[MAXSTTYPES];
	STAB *s;
	static int prevt[MAXSTTYPES], prev = 0;

	total = 0;
	for (i = 0; i < MAXSTTYPES; i++)
		types[i] = 0;
	for (i = 0; i < STABSIZE; i++)
	{
		s = SymTab[i];
		while (s != NULL)
		{
			++total;
			t = s->s_symtype;
			if (t > MAXSTTYPES - 1)
				t = MAXSTTYPES - 1;
			types[t]++;
			s = s->s_next;
		}
	}
	sm_syslog(LOG_INFO, NOQID, "stab: total=%d (%d)", total, total - prev);
	prev = total;
	for (i = 0; i < MAXSTTYPES; i++)
	{
		if (types[i] != 0)
		{
			sm_syslog(LOG_INFO, NOQID, "stab: type[%2d]=%2d (%d)",
				i, types[i], types[i] - prevt[i]);
		}
		prevt[i] = types[i];
	}
}
#endif /* SM_HEAP_CHECK */
@


1.3
log
@merge sendmail 8.14.6
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001, 2003 Sendmail, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Id: stab.c,v 8.91 2011/08/08 17:33:34 ca Exp $")
@


1.2
log
@Replace “$Sendmail: ” with “$Id: ” (the latter is used by upstream)
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Id: stab.c,v 8.89 2006/08/15 23:24:58 ca Exp $")
d68 1
a68 1
	if (type == ST_MACRO || type == ST_RULESET)
a115 4
	  case ST_ADDRESS:
		len = sizeof(s->s_address);
		break;

@


1.1
log
@Initial revision
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: stab.c,v 8.88 2003/05/21 15:36:30 ca Exp $")
d113 1
a113 1
		len = sizeof s->s_class;
d117 1
a117 1
		len = sizeof s->s_address;
d121 1
a121 1
		len = sizeof s->s_mailer;
d125 1
a125 1
		len = sizeof s->s_alias;
d129 1
a129 1
		len = sizeof s->s_mapclass;
d133 1
a133 1
		len = sizeof s->s_map;
d137 1
a137 1
		len = sizeof s->s_hostsig;
d141 1
a141 1
		len = sizeof s->s_namecanon;
d145 1
a145 1
		len = sizeof s->s_macro;
d149 1
a149 1
		len = sizeof s->s_ruleset;
d153 1
a153 1
		len = sizeof s->s_header;
d157 1
a157 1
		len = sizeof s->s_service;
d162 1
a162 1
		len = sizeof s->s_lmap;
d168 1
a168 1
		len = sizeof s->s_milter;
d173 1
a173 1
		len = sizeof s->s_quegrp;
d178 1
a178 1
		len = sizeof s->s_socketmap;
d192 1
a192 1
			len = sizeof s->s_mci;
d196 1
a196 1
			len = sizeof s->s_value;
d200 1
a200 1
	len += sizeof *s - sizeof s->s_value;
@


1.1.127.1
log
@Import Sendmail 8.14.3, suitably stripped down by the not yet committed
contrib/samples/import-3rdpty,v 1.35; we have some new and renamed files
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Id: stab.c,v 8.89 2006/08/15 23:24:58 ca Exp $")
d113 1
a113 1
		len = sizeof(s->s_class);
d117 1
a117 1
		len = sizeof(s->s_address);
d121 1
a121 1
		len = sizeof(s->s_mailer);
d125 1
a125 1
		len = sizeof(s->s_alias);
d129 1
a129 1
		len = sizeof(s->s_mapclass);
d133 1
a133 1
		len = sizeof(s->s_map);
d137 1
a137 1
		len = sizeof(s->s_hostsig);
d141 1
a141 1
		len = sizeof(s->s_namecanon);
d145 1
a145 1
		len = sizeof(s->s_macro);
d149 1
a149 1
		len = sizeof(s->s_ruleset);
d153 1
a153 1
		len = sizeof(s->s_header);
d157 1
a157 1
		len = sizeof(s->s_service);
d162 1
a162 1
		len = sizeof(s->s_lmap);
d168 1
a168 1
		len = sizeof(s->s_milter);
d173 1
a173 1
		len = sizeof(s->s_quegrp);
d178 1
a178 1
		len = sizeof(s->s_socketmap);
d192 1
a192 1
			len = sizeof(s->s_mci);
d196 1
a196 1
			len = sizeof(s->s_value);
d200 1
a200 1
	len += sizeof(*s) - sizeof(s->s_value);
@


1.1.127.2
log
@Import sendmail 8.14.6 via mircvs://contrib/samples/import-3rdpty
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Id: stab.c,v 8.91 2011/08/08 17:33:34 ca Exp $")
d68 1
a68 1
	if (type == ST_MACRO || type == ST_RULESET || type == ST_NAMECANON)
d116 4
@


1.1.127.3
log
@Import sendmail 8.14.9
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2001, 2003 Proofpoint, Inc. and its suppliers.
d16 1
a16 1
SM_RCSID("@@(#)$Id: stab.c,v 8.92 2013-11-22 20:51:56 ca Exp $")
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import Sendmail 8.14.0 via OpenBSD
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Sendmail: stab.c,v 8.89 2006/08/15 23:24:58 ca Exp $")
d113 1
a113 1
		len = sizeof(s->s_class);
d117 1
a117 1
		len = sizeof(s->s_address);
d121 1
a121 1
		len = sizeof(s->s_mailer);
d125 1
a125 1
		len = sizeof(s->s_alias);
d129 1
a129 1
		len = sizeof(s->s_mapclass);
d133 1
a133 1
		len = sizeof(s->s_map);
d137 1
a137 1
		len = sizeof(s->s_hostsig);
d141 1
a141 1
		len = sizeof(s->s_namecanon);
d145 1
a145 1
		len = sizeof(s->s_macro);
d149 1
a149 1
		len = sizeof(s->s_ruleset);
d153 1
a153 1
		len = sizeof(s->s_header);
d157 1
a157 1
		len = sizeof(s->s_service);
d162 1
a162 1
		len = sizeof(s->s_lmap);
d168 1
a168 1
		len = sizeof(s->s_milter);
d173 1
a173 1
		len = sizeof(s->s_quegrp);
d178 1
a178 1
		len = sizeof(s->s_socketmap);
d192 1
a192 1
			len = sizeof(s->s_mci);
d196 1
a196 1
			len = sizeof(s->s_value);
d200 1
a200 1
	len += sizeof(*s) - sizeof(s->s_value);
@


1.1.1.2.4.1
log
@Replace “$Sendmail: ” with “$Id: ” (the latter is used by upstream)
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Id: stab.c,v 8.89 2006/08/15 23:24:58 ca Exp $")
@


1.1.1.3
log
@Replace “$Sendmail: ” with “$Id: ” (the latter is used by upstream)
@
text
@d16 1
a16 1
SM_RCSID("@@(#)$Id: stab.c,v 8.89 2006/08/15 23:24:58 ca Exp $")
@


