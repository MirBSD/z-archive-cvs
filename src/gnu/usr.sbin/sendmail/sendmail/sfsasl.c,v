head	1.6;
access;
symbols
	sendmail-8_14_9:1.1.127.4
	sendmail-8_14_7:1.1.127.3
	sendmail-8_14_6:1.1.127.2
	sendmail-8_14_5-ERRATA-1:1.1.127.2
	mbsd-20101220_mergebase:1.4
	sendmail-8_14_5:1.1.127.2
	cvs-201107021500:1.1.1.6
	cvs-20101220:1.1.1.5
	mbsd-20101220:1.4.0.2
	cvs-201012191730:1.1.1.4
	sendmail-8_14_5_Beta0:1.1.127.2
	sendmail-8_14_3:1.1.127.1
	sendmail:1.1.127
	cvs-200812170000:1.1.1.4
	cvs-200805071200:1.1.1.4
	MIRBSD_10:1.1.1.3.0.2
	MIRBSD_10_BASE:1.1.1.3
	cvs-200803022030:1.1.1.3
	cvs-200707152000:1.1.1.3
	cvs-200704292000:1.1.1.3
	cvs-200702051700:1.1.1.3
	cvs-200609121900:1.1.1.3
	MIRBSD_9_BASE:1.1.1.2
	cvs-200606151800:1.1.1.2
	cvs-200603231300:1.1.1.2
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200507211800:1.1.1.1
	cvs-200504262050:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2014.06.09.15.17.57;	author tg;	state Exp;
branches;
next	1.5;
commitid	1005395CFC65E5646F1;

1.5
date	2013.08.06.20.37.26;	author tg;	state Exp;
branches;
next	1.4;
commitid	10052015E562892E658;

1.4
date	2010.12.19.17.18.33;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004D0E3E2D1286B3DF;

1.3
date	2009.11.18.08.53.41;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004B03B61970AF200B;

1.2
date	2008.05.07.11.57.13;	author tg;	state Exp;
branches;
next	1.1;
commitid	100482198DE5A7916C7;

1.1
date	2005.02.05.17.24.29;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.127.1;
next	;

1.1.1.1
date	2005.02.05.17.24.29;	author tg;	state Exp;
branches
	1.1.1.1.2.1;
next	1.1.1.2;

1.1.1.2
date	2006.03.23.13.10.08;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	10044229DEA33D36552;

1.1.1.3
date	2006.09.12.19.22.39;	author tg;	state Exp;
branches
	1.1.1.3.2.1;
next	1.1.1.4;
commitid	100450708CE5C63A8F5;

1.1.1.4
date	2008.05.07.12.31.51;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	1004821A13C1FC036E1;

1.1.1.5
date	2011.07.02.15.01.05;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	1004E0F31C5496AB95F;

1.1.1.6
date	2011.07.02.15.17.44;	author tg;	state Exp;
branches;
next	;
commitid	1004E0F36A10B5CA95B;

1.1.1.1.2.1
date	2006.03.30.19.28.09;	author tg;	state Exp;
branches;
next	;
commitid	100442C309C7183FA09;

1.1.1.3.2.1
date	2008.05.17.19.12.23;	author tg;	state Exp;
branches;
next	;
commitid	100482F2DC168C89AEA;

1.1.127.1
date	2010.12.19.14.45.47;	author tg;	state Exp;
branches;
next	1.1.127.2;
commitid	1004D0E1A94384778FD;

1.1.127.2
date	2010.12.19.14.56.27;	author tg;	state Exp;
branches;
next	1.1.127.3;
commitid	1004D0E1D294DE25888;

1.1.127.3
date	2013.08.06.20.26.37;	author tg;	state Exp;
branches;
next	1.1.127.4;
commitid	10052015BDF0FDDCF84;

1.1.127.4
date	2014.06.09.14.29.18;	author tg;	state Exp;
branches;
next	;
commitid	1005395C4CC1A6DB9EE;


desc
@@


1.6
log
@merge
@
text
@/*
 * Copyright (c) 1999-2006, 2008 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sm/gen.h>
SM_RCSID("$MirOS: src/gnu/usr.sbin/sendmail/sendmail/sfsasl.c,v 1.5 2013/08/06 20:37:26 tg Exp $")
SM_RCSID("@@(#)$Id: sfsasl.c,v 8.121 2013-11-22 20:51:56 ca Exp $")
#include <stdlib.h>
#include <sendmail.h>
#include <sm/time.h>
#include <errno.h>

/* allow to disable error handling code just in case... */
#ifndef DEAL_WITH_ERROR_SSL
# define DEAL_WITH_ERROR_SSL	1
#endif /* ! DEAL_WITH_ERROR_SSL */

#if SASL
# include "sfsasl.h"

/* Structure used by the "sasl" file type */
struct sasl_obj
{
	SM_FILE_T *fp;
	sasl_conn_t *conn;
};

struct sasl_info
{
	SM_FILE_T *fp;
	sasl_conn_t *conn;
};

/*
**  SASL_GETINFO - returns requested information about a "sasl" file
**		  descriptor.
**
**	Parameters:
**		fp -- the file descriptor
**		what -- the type of information requested
**		valp -- the thang to return the information in
**
**	Returns:
**		-1 for unknown requests
**		>=0 on success with valp filled in (if possible).
*/

static int sasl_getinfo __P((SM_FILE_T *, int, void *));

static int
sasl_getinfo(fp, what, valp)
	SM_FILE_T *fp;
	int what;
	void *valp;
{
	struct sasl_obj *so = (struct sasl_obj *) fp->f_cookie;

	switch (what)
	{
	  case SM_IO_WHAT_FD:
		if (so->fp == NULL)
			return -1;
		return so->fp->f_file; /* for stdio fileno() compatability */

	  case SM_IO_IS_READABLE:
		if (so->fp == NULL)
			return 0;

		/* get info from underlying file */
		return sm_io_getinfo(so->fp, what, valp);

	  default:
		return -1;
	}
}

/*
**  SASL_OPEN -- creates the sasl specific information for opening a
**		file of the sasl type.
**
**	Parameters:
**		fp -- the file pointer associated with the new open
**		info -- contains the sasl connection information pointer and
**			the original SM_FILE_T that holds the open
**		flags -- ignored
**		rpool -- ignored
**
**	Returns:
**		0 on success
*/

static int sasl_open __P((SM_FILE_T *, const void *, int, const void *));

/* ARGSUSED2 */
static int
sasl_open(fp, info, flags, rpool)
	SM_FILE_T *fp;
	const void *info;
	int flags;
	const void *rpool;
{
	struct sasl_obj *so;
	struct sasl_info *si = (struct sasl_info *) info;

	so = (struct sasl_obj *) sm_malloc(sizeof(struct sasl_obj));
	if (so == NULL)
	{
		errno = ENOMEM;
		return -1;
	}
	so->fp = si->fp;
	so->conn = si->conn;

	/*
	**  The underlying 'fp' is set to SM_IO_NOW so that the entire
	**  encoded string is written in one chunk. Otherwise there is
	**  the possibility that it may appear illegal, bogus or
	**  mangled to the other side of the connection.
	**  We will read or write through 'fp' since it is the opaque
	**  connection for the communications. We need to treat it this
	**  way in case the encoded string is to be sent down a TLS
	**  connection rather than, say, sm_io's stdio.
	*/

	(void) sm_io_setvbuf(so->fp, SM_TIME_DEFAULT, NULL, SM_IO_NOW, 0);
	fp->f_cookie = so;
	return 0;
}

/*
**  SASL_CLOSE -- close the sasl specific parts of the sasl file pointer
**
**	Parameters:
**		fp -- the file pointer to close
**
**	Returns:
**		0 on success
*/

static int sasl_close __P((SM_FILE_T *));

static int
sasl_close(fp)
	SM_FILE_T *fp;
{
	struct sasl_obj *so;

	so = (struct sasl_obj *) fp->f_cookie;
	if (so == NULL)
		return 0;
	if (so->fp != NULL)
	{
		sm_io_close(so->fp, SM_TIME_DEFAULT);
		so->fp = NULL;
	}
	sm_free(so);
	so = NULL;
	return 0;
}

/* how to deallocate a buffer allocated by SASL */
extern void	sm_sasl_free __P((void *));
#  define SASL_DEALLOC(b)	sm_sasl_free(b)

/*
**  SASL_READ -- read encrypted information and decrypt it for the caller
**
**	Parameters:
**		fp -- the file pointer
**		buf -- the location to place the decrypted information
**		size -- the number of bytes to read after decryption
**
**	Results:
**		-1 on error
**		otherwise the number of bytes read
*/

static ssize_t sasl_read __P((SM_FILE_T *, char *, size_t));

static ssize_t
sasl_read(fp, buf, size)
	SM_FILE_T *fp;
	char *buf;
	size_t size;
{
	int result;
	ssize_t len;
# if SASL >= 20000
	static const char *outbuf = NULL;
# else /* SASL >= 20000 */
	static char *outbuf = NULL;
# endif /* SASL >= 20000 */
	static unsigned int outlen = 0;
	static unsigned int offset = 0;
	struct sasl_obj *so = (struct sasl_obj *) fp->f_cookie;

	/*
	**  sasl_decode() may require more data than a single read() returns.
	**  Hence we have to put a loop around the decoding.
	**  This also requires that we may have to split up the returned
	**  data since it might be larger than the allowed size.
	**  Therefore we use a static pointer and return portions of it
	**  if necessary.
	**  XXX Note: This function is not thread-safe nor can it be used
	**  on more than one file. A correct implementation would store
	**  this data in fp->f_cookie.
	*/

# if SASL >= 20000
	while (outlen == 0)
# else /* SASL >= 20000 */
	while (outbuf == NULL && outlen == 0)
# endif /* SASL >= 20000 */
	{
		len = sm_io_read(so->fp, SM_TIME_DEFAULT, buf, size);
		if (len <= 0)
			return len;
		result = sasl_decode(so->conn, buf,
				     (unsigned int) len, &outbuf, &outlen);
		if (result != SASL_OK)
		{
			if (LogLevel > 7)
				sm_syslog(LOG_WARNING, NOQID,
					"AUTH: sasl_decode error=%d", result);
			outbuf = NULL;
			offset = 0;
			outlen = 0;
			return -1;
		}
	}

	if (outbuf == NULL)
	{
		/* be paranoid: outbuf == NULL but outlen != 0 */
		syserr("@@sasl_read failure: outbuf == NULL but outlen != 0");
		/* NOTREACHED */
	}
	if (outlen - offset > size)
	{
		/* return another part of the buffer */
		(void) memcpy(buf, outbuf + offset, size);
		offset += size;
		len = size;
	}
	else
	{
		/* return the rest of the buffer */
		len = outlen - offset;
		(void) memcpy(buf, outbuf + offset, (size_t) len);
# if SASL < 20000
		SASL_DEALLOC(outbuf);
# endif /* SASL < 20000 */
		outbuf = NULL;
		offset = 0;
		outlen = 0;
	}
	return len;
}

/*
**  SASL_WRITE -- write information out after encrypting it
**
**	Parameters:
**		fp -- the file pointer
**		buf -- holds the data to be encrypted and written
**		size -- the number of bytes to have encrypted and written
**
**	Returns:
**		-1 on error
**		otherwise number of bytes written
*/

static ssize_t sasl_write __P((SM_FILE_T *, const char *, size_t));

static ssize_t
sasl_write(fp, buf, size)
	SM_FILE_T *fp;
	const char *buf;
	size_t size;
{
	int result;
# if SASL >= 20000
	const char *outbuf;
# else /* SASL >= 20000 */
	char *outbuf;
# endif /* SASL >= 20000 */
	unsigned int outlen, *maxencode;
	size_t ret = 0, total = 0;
	struct sasl_obj *so = (struct sasl_obj *) fp->f_cookie;

	/*
	**  Fetch the maximum input buffer size for sasl_encode().
	**  This can be less than the size set in attemptauth()
	**  due to a negotiation with the other side, e.g.,
	**  Cyrus IMAP lmtp program sets maxbuf=4096,
	**  digestmd5 substracts 25 and hence we'll get 4071
	**  instead of 8192 (MAXOUTLEN).
	**  Hack (for now): simply reduce the size, callers are (must be)
	**  able to deal with that and invoke sasl_write() again with
	**  the rest of the data.
	**  Note: it would be better to store this value in the context
	**  after the negotiation.
	*/

	result = sasl_getprop(so->conn, SASL_MAXOUTBUF,
				(const void **) &maxencode);
	if (result == SASL_OK && size > *maxencode && *maxencode > 0)
		size = *maxencode;

	result = sasl_encode(so->conn, buf,
			     (unsigned int) size, &outbuf, &outlen);

	if (result != SASL_OK)
	{
		if (LogLevel > 7)
			sm_syslog(LOG_WARNING, NOQID,
				"AUTH: sasl_encode error=%d", result);
		return -1;
	}

	if (outbuf != NULL)
	{
		while (outlen > 0)
		{
			errno = 0;
			/* XXX result == 0? */
			ret = sm_io_write(so->fp, SM_TIME_DEFAULT,
					  &outbuf[total], outlen);
			if (ret <= 0)
				return ret;
			outlen -= ret;
			total += ret;
		}
# if SASL < 20000
		SASL_DEALLOC(outbuf);
# endif /* SASL < 20000 */
	}
	return size;
}

/*
**  SFDCSASL -- create sasl file type and open in and out file pointers
**	       for sendmail to read from and write to.
**
**	Parameters:
**		fin -- the sm_io file encrypted data to be read from
**		fout -- the sm_io file encrypted data to be written to
**		conn -- the sasl connection pointer
**		tmo -- timeout
**
**	Returns:
**		-1 on error
**		0 on success
**
**	Side effects:
**		The arguments "fin" and "fout" are replaced with the new
**		SM_FILE_T pointers.
*/

int
sfdcsasl(fin, fout, conn, tmo)
	SM_FILE_T **fin;
	SM_FILE_T **fout;
	sasl_conn_t *conn;
	int tmo;
{
	SM_FILE_T *newin, *newout;
	SM_FILE_T  SM_IO_SET_TYPE(sasl_vector, "sasl", sasl_open, sasl_close,
		sasl_read, sasl_write, NULL, sasl_getinfo, NULL,
		SM_TIME_DEFAULT);
	struct sasl_info info;

	if (conn == NULL)
	{
		/* no need to do anything */
		return 0;
	}

	SM_IO_INIT_TYPE(sasl_vector, "sasl", sasl_open, sasl_close,
		sasl_read, sasl_write, NULL, sasl_getinfo, NULL,
		SM_TIME_DEFAULT);
	info.fp = *fin;
	info.conn = conn;
	newin = sm_io_open(&sasl_vector, SM_TIME_DEFAULT, &info,
			SM_IO_RDONLY_B, NULL);

	if (newin == NULL)
		return -1;

	info.fp = *fout;
	info.conn = conn;
	newout = sm_io_open(&sasl_vector, SM_TIME_DEFAULT, &info,
			SM_IO_WRONLY_B, NULL);

	if (newout == NULL)
	{
		(void) sm_io_close(newin, SM_TIME_DEFAULT);
		return -1;
	}
	sm_io_automode(newin, newout);

	sm_io_setinfo(*fin, SM_IO_WHAT_TIMEOUT, &tmo);
	sm_io_setinfo(*fout, SM_IO_WHAT_TIMEOUT, &tmo);

	*fin = newin;
	*fout = newout;
	return 0;
}
#endif /* SASL */

#if STARTTLS
# include "sfsasl.h"
#  include <openssl/err.h>

/* Structure used by the "tls" file type */
struct tls_obj
{
	SM_FILE_T *fp;
	SSL *con;
};

struct tls_info
{
	SM_FILE_T *fp;
	SSL *con;
};

/*
**  TLS_GETINFO - returns requested information about a "tls" file
**		 descriptor.
**
**	Parameters:
**		fp -- the file descriptor
**		what -- the type of information requested
**		valp -- the thang to return the information in (unused)
**
**	Returns:
**		-1 for unknown requests
**		>=0 on success with valp filled in (if possible).
*/

static int tls_getinfo __P((SM_FILE_T *, int, void *));

/* ARGSUSED2 */
static int
tls_getinfo(fp, what, valp)
	SM_FILE_T *fp;
	int what;
	void *valp;
{
	struct tls_obj *so = (struct tls_obj *) fp->f_cookie;

	switch (what)
	{
	  case SM_IO_WHAT_FD:
		if (so->fp == NULL)
			return -1;
		return so->fp->f_file; /* for stdio fileno() compatability */

	  case SM_IO_IS_READABLE:
		return SSL_pending(so->con) > 0;

	  default:
		return -1;
	}
}

/*
**  TLS_OPEN -- creates the tls specific information for opening a
**	       file of the tls type.
**
**	Parameters:
**		fp -- the file pointer associated with the new open
**		info -- the sm_io file pointer holding the open and the
**			TLS encryption connection to be read from or written to
**		flags -- ignored
**		rpool -- ignored
**
**	Returns:
**		0 on success
*/

static int tls_open __P((SM_FILE_T *, const void *, int, const void *));

/* ARGSUSED2 */
static int
tls_open(fp, info, flags, rpool)
	SM_FILE_T *fp;
	const void *info;
	int flags;
	const void *rpool;
{
	struct tls_obj *so;
	struct tls_info *ti = (struct tls_info *) info;

	so = (struct tls_obj *) sm_malloc(sizeof(struct tls_obj));
	if (so == NULL)
	{
		errno = ENOMEM;
		return -1;
	}
	so->fp = ti->fp;
	so->con = ti->con;

	/*
	**  We try to get the "raw" file descriptor that TLS uses to
	**  do the actual read/write with. This is to allow us control
	**  over the file descriptor being a blocking or non-blocking type.
	**  Under the covers TLS handles the change and this allows us
	**  to do timeouts with sm_io.
	*/

	fp->f_file = sm_io_getinfo(so->fp, SM_IO_WHAT_FD, NULL);
	(void) sm_io_setvbuf(so->fp, SM_TIME_DEFAULT, NULL, SM_IO_NOW, 0);
	fp->f_cookie = so;
	return 0;
}

/*
**  TLS_CLOSE -- close the tls specific parts of the tls file pointer
**
**	Parameters:
**		fp -- the file pointer to close
**
**	Returns:
**		0 on success
*/

static int tls_close __P((SM_FILE_T *));

static int
tls_close(fp)
	SM_FILE_T *fp;
{
	struct tls_obj *so;

	so = (struct tls_obj *) fp->f_cookie;
	if (so == NULL)
		return 0;
	if (so->fp != NULL)
	{
		sm_io_close(so->fp, SM_TIME_DEFAULT);
		so->fp = NULL;
	}
	sm_free(so);
	so = NULL;
	return 0;
}

/* maximum number of retries for TLS related I/O due to handshakes */
# define MAX_TLS_IOS	4

/*
**  TLS_RETRY -- check whether a failed SSL operation can be retried
**
**	Parameters:
**		ssl -- TLS structure
**		rfd -- read fd
**		wfd -- write fd
**		tlsstart -- start time of TLS operation
**		timeout -- timeout for TLS operation
**		err -- SSL error
**		where -- description of operation
**
**	Results:
**		>0 on success
**		0 on timeout
**		<0 on error
*/

int
tls_retry(ssl, rfd, wfd, tlsstart, timeout, err, where)
	SSL *ssl;
	int rfd;
	int wfd;
	time_t tlsstart;
	int timeout;
	int err;
	const char *where;
{
	int ret;
	time_t left;
	time_t now = curtime();
	struct timeval tv;

	ret = -1;

	/*
	**  For SSL_ERROR_WANT_{READ,WRITE}:
	**  There is not a complete SSL record available yet
	**  or there is only a partial SSL record removed from
	**  the network (socket) buffer into the SSL buffer.
	**  The SSL_connect will only succeed when a full
	**  SSL record is available (assuming a "real" error
	**  doesn't happen). To handle when a "real" error
	**  does happen the select is set for exceptions too.
	**  The connection may be re-negotiated during this time
	**  so both read and write "want errors" need to be handled.
	**  A select() exception loops back so that a proper SSL
	**  error message can be gotten.
	*/

	left = timeout - (now - tlsstart);
	if (left <= 0)
		return 0;	/* timeout */
	tv.tv_sec = left;
	tv.tv_usec = 0;

	if (LogLevel > 14)
	{
		sm_syslog(LOG_INFO, NOQID,
			  "STARTTLS=%s, info: fds=%d/%d, err=%d",
			  where, rfd, wfd, err);
	}

	if (FD_SETSIZE > 0 &&
	    ((err == SSL_ERROR_WANT_READ && rfd >= FD_SETSIZE) ||
	     (err == SSL_ERROR_WANT_WRITE && wfd >= FD_SETSIZE)))
	{
		if (LogLevel > 5)
		{
			sm_syslog(LOG_ERR, NOQID,
				  "STARTTLS=%s, error: fd %d/%d too large",
				  where, rfd, wfd);
		if (LogLevel > 8)
			tlslogerr(LOG_WARNING, where);
		}
		errno = EINVAL;
	}
	else if (err == SSL_ERROR_WANT_READ)
	{
		fd_set ssl_maskr, ssl_maskx;
		int save_errno = errno;

		FD_ZERO(&ssl_maskr);
		FD_SET(rfd, &ssl_maskr);
		FD_ZERO(&ssl_maskx);
		FD_SET(rfd, &ssl_maskx);
		do
		{
			ret = select(rfd + 1, &ssl_maskr, NULL, &ssl_maskx,
					&tv);
		} while (ret < 0 && errno == EINTR);
		if (ret < 0 && errno > 0)
			ret = -errno;
		errno = save_errno;
	}
	else if (err == SSL_ERROR_WANT_WRITE)
	{
		fd_set ssl_maskw, ssl_maskx;
		int save_errno = errno;

		FD_ZERO(&ssl_maskw);
		FD_SET(wfd, &ssl_maskw);
		FD_ZERO(&ssl_maskx);
		FD_SET(rfd, &ssl_maskx);
		do
		{
			ret = select(wfd + 1, NULL, &ssl_maskw, &ssl_maskx,
					&tv);
		} while (ret < 0 && errno == EINTR);
		if (ret < 0 && errno > 0)
			ret = -errno;
		errno = save_errno;
	}
	return ret;
}

/* errno to force refill() etc to stop (see IS_IO_ERROR()) */
#ifdef ETIMEDOUT
# define SM_ERR_TIMEOUT	ETIMEDOUT
#else /* ETIMEDOUT */
# define SM_ERR_TIMEOUT	EIO
#endif /* ETIMEDOUT */

/*
**  SET_TLS_RD_TMO -- read secured information for the caller
**
**	Parameters:
**		rd_tmo -- read timeout
**
**	Results:
**		none
**	This is a hack: there is no way to pass it in
*/

static int tls_rd_tmo = -1;

void
set_tls_rd_tmo(rd_tmo)
	int rd_tmo;
{
	tls_rd_tmo = rd_tmo;
}

/*
**  TLS_READ -- read secured information for the caller
**
**	Parameters:
**		fp -- the file pointer
**		buf -- the location to place the data
**		size -- the number of bytes to read from connection
**
**	Results:
**		-1 on error
**		otherwise the number of bytes read
*/

static ssize_t tls_read __P((SM_FILE_T *, char *, size_t));

static ssize_t
tls_read(fp, buf, size)
	SM_FILE_T *fp;
	char *buf;
	size_t size;
{
	int r, rfd, wfd, try, ssl_err;
	struct tls_obj *so = (struct tls_obj *) fp->f_cookie;
	time_t tlsstart;
	char *err;

	try = 99;
	err = NULL;
	tlsstart = curtime();

  retry:
	r = SSL_read(so->con, (char *) buf, size);

	if (r > 0)
		return r;

	err = NULL;
	switch (ssl_err = SSL_get_error(so->con, r))
	{
	  case SSL_ERROR_NONE:
	  case SSL_ERROR_ZERO_RETURN:
		break;
	  case SSL_ERROR_WANT_WRITE:
		err = "read W BLOCK";
		/* FALLTHROUGH */
	  case SSL_ERROR_WANT_READ:
		if (err == NULL)
			err = "read R BLOCK";
		rfd = SSL_get_rfd(so->con);
		wfd = SSL_get_wfd(so->con);
		try = tls_retry(so->con, rfd, wfd, tlsstart,
				(tls_rd_tmo < 0) ? TimeOuts.to_datablock
						 : tls_rd_tmo,
				ssl_err, "read");
		if (try > 0)
			goto retry;
		errno = SM_ERR_TIMEOUT;
		break;

	  case SSL_ERROR_WANT_X509_LOOKUP:
		err = "write X BLOCK";
		break;
	  case SSL_ERROR_SYSCALL:
		if (r == 0 && errno == 0) /* out of protocol EOF found */
			break;
		err = "syscall error";
/*
		get_last_socket_error());
*/
		break;
	  case SSL_ERROR_SSL:
#if DEAL_WITH_ERROR_SSL
		if (r == 0 && errno == 0) /* out of protocol EOF found */
			break;
#endif /* DEAL_WITH_ERROR_SSL */
		err = "generic SSL error";

		if (LogLevel > 9)
		{
			int pri;

			if (errno == EAGAIN && try > 0)
				pri = LOG_DEBUG;
			else
				pri = LOG_WARNING;
			tlslogerr(pri, "read");
		}

#if DEAL_WITH_ERROR_SSL
		/* avoid repeated calls? */
		if (r == 0)
			r = -1;
#endif /* DEAL_WITH_ERROR_SSL */
		break;
	}
	if (err != NULL)
	{
		int save_errno;

		save_errno = (errno == 0) ? EIO : errno;
		if (try == 0 && save_errno == SM_ERR_TIMEOUT)
		{
			if (LogLevel > 7)
				sm_syslog(LOG_WARNING, NOQID,
					  "STARTTLS: read error=timeout");
		}
		else if (LogLevel > 8)
		{
			int pri;

			if (save_errno == EAGAIN && try > 0)
				pri = LOG_DEBUG;
			else
				pri = LOG_WARNING;
			sm_syslog(pri, NOQID,
				  "STARTTLS: read error=%s (%d), errno=%d, get_error=%s, retry=%d, ssl_err=%d",
				  err, r, errno,
				  ERR_error_string(ERR_get_error(), NULL), try,
				  ssl_err);
		}
		else if (LogLevel > 7)
			sm_syslog(LOG_WARNING, NOQID,
				  "STARTTLS: read error=%s (%d), errno=%d, retry=%d, ssl_err=%d",
				  err, r, errno, try, ssl_err);
		errno = save_errno;
	}
	return r;
}

/*
**  TLS_WRITE -- write information out through secure connection
**
**	Parameters:
**		fp -- the file pointer
**		buf -- holds the data to be securely written
**		size -- the number of bytes to write
**
**	Returns:
**		-1 on error
**		otherwise number of bytes written
*/

static ssize_t tls_write __P((SM_FILE_T *, const char *, size_t));

static ssize_t
tls_write(fp, buf, size)
	SM_FILE_T *fp;
	const char *buf;
	size_t size;
{
	int r, rfd, wfd, try, ssl_err;
	struct tls_obj *so = (struct tls_obj *) fp->f_cookie;
	time_t tlsstart;
	char *err;

	try = 99;
	err = NULL;
	tlsstart = curtime();

  retry:
	r = SSL_write(so->con, (char *) buf, size);

	if (r > 0)
		return r;
	err = NULL;
	switch (ssl_err = SSL_get_error(so->con, r))
	{
	  case SSL_ERROR_NONE:
	  case SSL_ERROR_ZERO_RETURN:
		break;
	  case SSL_ERROR_WANT_WRITE:
		err = "read W BLOCK";
		/* FALLTHROUGH */
	  case SSL_ERROR_WANT_READ:
		if (err == NULL)
			err = "read R BLOCK";
		rfd = SSL_get_rfd(so->con);
		wfd = SSL_get_wfd(so->con);
		try = tls_retry(so->con, rfd, wfd, tlsstart,
				DATA_PROGRESS_TIMEOUT, ssl_err, "write");
		if (try > 0)
			goto retry;
		errno = SM_ERR_TIMEOUT;
		break;
	  case SSL_ERROR_WANT_X509_LOOKUP:
		err = "write X BLOCK";
		break;
	  case SSL_ERROR_SYSCALL:
		if (r == 0 && errno == 0) /* out of protocol EOF found */
			break;
		err = "syscall error";
/*
		get_last_socket_error());
*/
		break;
	  case SSL_ERROR_SSL:
		err = "generic SSL error";
/*
		ERR_GET_REASON(ERR_peek_error()));
*/
		if (LogLevel > 9)
			tlslogerr(LOG_WARNING, "write");

#if DEAL_WITH_ERROR_SSL
		/* avoid repeated calls? */
		if (r == 0)
			r = -1;
#endif /* DEAL_WITH_ERROR_SSL */
		break;
	}
	if (err != NULL)
	{
		int save_errno;

		save_errno = (errno == 0) ? EIO : errno;
		if (try == 0 && save_errno == SM_ERR_TIMEOUT)
		{
			if (LogLevel > 7)
				sm_syslog(LOG_WARNING, NOQID,
					  "STARTTLS: write error=timeout");
		}
		else if (LogLevel > 8)
			sm_syslog(LOG_WARNING, NOQID,
				  "STARTTLS: write error=%s (%d), errno=%d, get_error=%s, retry=%d, ssl_err=%d",
				  err, r, errno,
				  ERR_error_string(ERR_get_error(), NULL), try,
				  ssl_err);
		else if (LogLevel > 7)
			sm_syslog(LOG_WARNING, NOQID,
				  "STARTTLS: write error=%s (%d), errno=%d, retry=%d, ssl_err=%d",
				  err, r, errno, try, ssl_err);
		errno = save_errno;
	}
	return r;
}

/*
**  SFDCTLS -- create tls file type and open in and out file pointers
**	      for sendmail to read from and write to.
**
**	Parameters:
**		fin -- data input source being replaced
**		fout -- data output source being replaced
**		con -- the tls connection pointer
**
**	Returns:
**		-1 on error
**		0 on success
**
**	Side effects:
**		The arguments "fin" and "fout" are replaced with the new
**		SM_FILE_T pointers.
**		The original "fin" and "fout" are preserved in the tls file
**		type but are not actually used because of the design of TLS.
*/

int
sfdctls(fin, fout, con)
	SM_FILE_T **fin;
	SM_FILE_T **fout;
	SSL *con;
{
	SM_FILE_T *tlsin, *tlsout;
	SM_FILE_T SM_IO_SET_TYPE(tls_vector, "tls", tls_open, tls_close,
		tls_read, tls_write, NULL, tls_getinfo, NULL,
		SM_TIME_FOREVER);
	struct tls_info info;

	SM_ASSERT(con != NULL);

	SM_IO_INIT_TYPE(tls_vector, "tls", tls_open, tls_close,
		tls_read, tls_write, NULL, tls_getinfo, NULL,
		SM_TIME_FOREVER);
	info.fp = *fin;
	info.con = con;
	tlsin = sm_io_open(&tls_vector, SM_TIME_DEFAULT, &info, SM_IO_RDONLY_B,
			   NULL);
	if (tlsin == NULL)
		return -1;

	info.fp = *fout;
	tlsout = sm_io_open(&tls_vector, SM_TIME_DEFAULT, &info, SM_IO_WRONLY_B,
			    NULL);
	if (tlsout == NULL)
	{
		(void) sm_io_close(tlsin, SM_TIME_DEFAULT);
		return -1;
	}
	sm_io_automode(tlsin, tlsout);

	*fin = tlsin;
	*fout = tlsout;
	return 0;
}
#endif /* STARTTLS */
@


1.5
log
@merge
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2006, 2008 Sendmail, Inc. and its suppliers.
d12 2
a13 2
SM_RCSID("$MirOS: src/gnu/usr.sbin/sendmail/sendmail/sfsasl.c,v 1.4 2010/12/19 17:18:33 tg Exp $")
SM_RCSID("@@(#)$Id: sfsasl.c,v 8.120 2013/03/15 17:49:12 guenther Exp $")
@


1.4
log
@merge newer sendmail; fix and correct; reduce upstream diffs; prep for deb
@
text
@d12 2
a13 2
SM_RCSID("$MirOS: src/gnu/usr.sbin/sendmail/sendmail/sfsasl.c,v 1.3 2009/11/18 08:53:41 tg Exp $")
SM_RCSID("@@(#)$Id: sfsasl.c,v 8.118 2008/07/22 15:12:48 ca Exp $")
d632 1
a632 1
			tlslogerr(where);
d639 1
d652 1
d657 1
d670 1
d778 1
d780 9
a788 1
			tlslogerr("read");
d809 8
a816 1
			sm_syslog(LOG_WARNING, NOQID,
d821 1
d903 1
a903 1
			tlslogerr("write");
@


1.3
log
@fix format strings; discovered at work when finding bogus message IDs
@
text
@d12 2
a13 2
SM_RCSID("$MirOS$")
SM_RCSID("@@(#)$Sendmail: sfsasl.c,v 8.117 2008/01/31 18:48:29 ca Exp $")
d300 1
a300 1
	**  due to a negotation with the other side, e.g.,
@


1.2
log
@update to sendmail 8.14.3 (which has been on my TODO for 4 days *shames*),
a hah-I-knew-it! update for a bug I reported in IRC… (which seems lost, as
only DFBSD, OBSD etc. are credited for finding):

Sendmail, Inc., and the Sendmail Consortium announce the availability
of sendmail 8.14.3. This version fixes some bugs:

o the MTA accessed storage after it free()d it. This was a regression
  introduced in 8.14.2, but the bug only showed up on a few operating
  systems.
o ruleset processing: the function cataddr() could cause the
  addition of the BlankSub character between some tokens when it
  should not happen and thus failures in rule matching.  It seems
  that none of the default rules were affected by this bug and hence
  the problem did not show up for default configurations.
o the libmilter state engine did not deal correctly with milters
  that requested the omission of protocol steps during the negotiation
  callback.

A complete list of changes can be found in the release notes […]
@
text
@d12 1
d803 1
a803 1
				  "STARTTLS: read error=%s (%d), retry=%d, ssl_err=%d",
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2004 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: sfsasl.c,v 8.101 2004/12/15 22:45:55 ca Exp $")
d15 1
d227 3
d311 1
a311 1
                             (const void **) &maxencode);
d319 4
d324 1
d330 1
d352 1
a352 1
**		fout -- the sm_io file encrypted data to be writen to
d354 1
d366 1
a366 1
sfdcsasl(fin, fout, conn)
d370 1
d375 1
a375 1
		SM_TIME_FOREVER);
d386 1
a386 1
		SM_TIME_FOREVER);
d407 3
d559 139
d718 1
a718 2
	int r;
	static int again = MAX_TLS_IOS;
d720 1
d723 5
a730 2
	{
		again = MAX_TLS_IOS;
a731 1
	}
d734 1
a734 1
	switch (SSL_get_error(so->con, r))
a737 1
		again = MAX_TLS_IOS;
d740 2
a741 5
		if (--again <= 0)
			err = "read W BLOCK";
		else
			errno = EAGAIN;
		break;
d743 1
a743 1
		if (--again <= 0)
d745 9
a753 2
		else
			errno = EAGAIN;
d755 1
d788 7
a794 2
		again = MAX_TLS_IOS;
		if (LogLevel > 9)
d796 1
a796 1
				  "STARTTLS: read error=%s (%d), errno=%d, get_error=%s",
d798 2
a799 1
				  ERR_error_string(ERR_get_error(), NULL));
d802 2
a803 1
				  "STARTTLS: read error=%s (%d)", err, r);
d830 1
a830 2
	int r;
	static int again = MAX_TLS_IOS;
d832 1
d835 5
a842 2
	{
		again = MAX_TLS_IOS;
a843 1
	}
d845 1
a845 1
	switch (SSL_get_error(so->con, r))
a848 1
		again = MAX_TLS_IOS;
d851 2
a852 5
		if (--again <= 0)
			err = "write W BLOCK";
		else
			errno = EAGAIN;
		break;
d854 9
a862 4
		if (--again <= 0)
			err = "write R BLOCK";
		else
			errno = EAGAIN;
d895 7
a901 2
		again = MAX_TLS_IOS;
		if (LogLevel > 9)
d903 1
a903 1
				  "STARTTLS: write error=%s (%d), errno=%d, get_error=%s",
d905 2
a906 1
				  ERR_error_string(ERR_get_error(), NULL));
d909 2
a910 1
				  "STARTTLS: write error=%s (%d)", err, r);
@


1.1.127.1
log
@Import Sendmail 8.14.3, suitably stripped down by the not yet committed
contrib/samples/import-3rdpty,v 1.35; we have some new and renamed files
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2006, 2008 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Id: sfsasl.c,v 8.117 2008/01/31 18:48:29 ca Exp $")
a14 1
#include <sm/time.h>
a225 3
			if (LogLevel > 7)
				sm_syslog(LOG_WARNING, NOQID,
					"AUTH: sasl_decode error=%d", result);
d307 1
a307 1
				(const void **) &maxencode);
a314 4
	{
		if (LogLevel > 7)
			sm_syslog(LOG_WARNING, NOQID,
				"AUTH: sasl_encode error=%d", result);
a315 1
	}
a320 1
			errno = 0;
d342 1
a342 1
**		fout -- the sm_io file encrypted data to be written to
a343 1
**		tmo -- timeout
d355 1
a355 1
sfdcsasl(fin, fout, conn, tmo)
a358 1
	int tmo;
d363 1
a363 1
		SM_TIME_DEFAULT);
d374 1
a374 1
		SM_TIME_DEFAULT);
a394 3
	sm_io_setinfo(*fin, SM_IO_WHAT_TIMEOUT, &tmo);
	sm_io_setinfo(*fout, SM_IO_WHAT_TIMEOUT, &tmo);

a543 139
**  TLS_RETRY -- check whether a failed SSL operation can be retried
**
**	Parameters:
**		ssl -- TLS structure
**		rfd -- read fd
**		wfd -- write fd
**		tlsstart -- start time of TLS operation
**		timeout -- timeout for TLS operation
**		err -- SSL error
**		where -- description of operation
**
**	Results:
**		>0 on success
**		0 on timeout
**		<0 on error
*/

int
tls_retry(ssl, rfd, wfd, tlsstart, timeout, err, where)
	SSL *ssl;
	int rfd;
	int wfd;
	time_t tlsstart;
	int timeout;
	int err;
	const char *where;
{
	int ret;
	time_t left;
	time_t now = curtime();
	struct timeval tv;

	ret = -1;

	/*
	**  For SSL_ERROR_WANT_{READ,WRITE}:
	**  There is not a complete SSL record available yet
	**  or there is only a partial SSL record removed from
	**  the network (socket) buffer into the SSL buffer.
	**  The SSL_connect will only succeed when a full
	**  SSL record is available (assuming a "real" error
	**  doesn't happen). To handle when a "real" error
	**  does happen the select is set for exceptions too.
	**  The connection may be re-negotiated during this time
	**  so both read and write "want errors" need to be handled.
	**  A select() exception loops back so that a proper SSL
	**  error message can be gotten.
	*/

	left = timeout - (now - tlsstart);
	if (left <= 0)
		return 0;	/* timeout */
	tv.tv_sec = left;
	tv.tv_usec = 0;

	if (LogLevel > 14)
	{
		sm_syslog(LOG_INFO, NOQID,
			  "STARTTLS=%s, info: fds=%d/%d, err=%d",
			  where, rfd, wfd, err);
	}

	if (FD_SETSIZE > 0 &&
	    ((err == SSL_ERROR_WANT_READ && rfd >= FD_SETSIZE) ||
	     (err == SSL_ERROR_WANT_WRITE && wfd >= FD_SETSIZE)))
	{
		if (LogLevel > 5)
		{
			sm_syslog(LOG_ERR, NOQID,
				  "STARTTLS=%s, error: fd %d/%d too large",
				  where, rfd, wfd);
		if (LogLevel > 8)
			tlslogerr(where);
		}
		errno = EINVAL;
	}
	else if (err == SSL_ERROR_WANT_READ)
	{
		fd_set ssl_maskr, ssl_maskx;

		FD_ZERO(&ssl_maskr);
		FD_SET(rfd, &ssl_maskr);
		FD_ZERO(&ssl_maskx);
		FD_SET(rfd, &ssl_maskx);
		do
		{
			ret = select(rfd + 1, &ssl_maskr, NULL, &ssl_maskx,
					&tv);
		} while (ret < 0 && errno == EINTR);
		if (ret < 0 && errno > 0)
			ret = -errno;
	}
	else if (err == SSL_ERROR_WANT_WRITE)
	{
		fd_set ssl_maskw, ssl_maskx;

		FD_ZERO(&ssl_maskw);
		FD_SET(wfd, &ssl_maskw);
		FD_ZERO(&ssl_maskx);
		FD_SET(rfd, &ssl_maskx);
		do
		{
			ret = select(wfd + 1, NULL, &ssl_maskw, &ssl_maskx,
					&tv);
		} while (ret < 0 && errno == EINTR);
		if (ret < 0 && errno > 0)
			ret = -errno;
	}
	return ret;
}

/* errno to force refill() etc to stop (see IS_IO_ERROR()) */
#ifdef ETIMEDOUT
# define SM_ERR_TIMEOUT	ETIMEDOUT
#else /* ETIMEDOUT */
# define SM_ERR_TIMEOUT	EIO
#endif /* ETIMEDOUT */

/*
**  SET_TLS_RD_TMO -- read secured information for the caller
**
**	Parameters:
**		rd_tmo -- read timeout
**
**	Results:
**		none
**	This is a hack: there is no way to pass it in
*/

static int tls_rd_tmo = -1;

void
set_tls_rd_tmo(rd_tmo)
	int rd_tmo;
{
	tls_rd_tmo = rd_tmo;
}

/*
d564 2
a565 1
	int r, rfd, wfd, try, ssl_err;
a566 1
	time_t tlsstart;
a568 5
	try = 99;
	err = NULL;
	tlsstart = curtime();

  retry:
d572 2
d575 1
d578 1
a578 1
	switch (ssl_err = SSL_get_error(so->con, r))
d582 1
d585 5
a589 2
		err = "read W BLOCK";
		/* FALLTHROUGH */
d591 1
a591 1
		if (err == NULL)
d593 2
a594 9
		rfd = SSL_get_rfd(so->con);
		wfd = SSL_get_wfd(so->con);
		try = tls_retry(so->con, rfd, wfd, tlsstart,
				(tls_rd_tmo < 0) ? TimeOuts.to_datablock
						 : tls_rd_tmo,
				ssl_err, "read");
		if (try > 0)
			goto retry;
		errno = SM_ERR_TIMEOUT;
a595 1

d628 2
a629 7
		if (try == 0 && save_errno == SM_ERR_TIMEOUT)
		{
			if (LogLevel > 7)
				sm_syslog(LOG_WARNING, NOQID,
					  "STARTTLS: read error=timeout");
		}
		else if (LogLevel > 8)
d631 1
a631 1
				  "STARTTLS: read error=%s (%d), errno=%d, get_error=%s, retry=%d, ssl_err=%d",
d633 1
a633 2
				  ERR_error_string(ERR_get_error(), NULL), try,
				  ssl_err);
d636 1
a636 2
				  "STARTTLS: read error=%s (%d), retry=%d, ssl_err=%d",
				  err, r, errno, try, ssl_err);
d663 2
a664 1
	int r, rfd, wfd, try, ssl_err;
a665 1
	time_t tlsstart;
a667 5
	try = 99;
	err = NULL;
	tlsstart = curtime();

  retry:
d671 2
d674 1
d676 1
a676 1
	switch (ssl_err = SSL_get_error(so->con, r))
d680 1
d683 5
a687 2
		err = "read W BLOCK";
		/* FALLTHROUGH */
d689 4
a692 9
		if (err == NULL)
			err = "read R BLOCK";
		rfd = SSL_get_rfd(so->con);
		wfd = SSL_get_wfd(so->con);
		try = tls_retry(so->con, rfd, wfd, tlsstart,
				DATA_PROGRESS_TIMEOUT, ssl_err, "write");
		if (try > 0)
			goto retry;
		errno = SM_ERR_TIMEOUT;
d725 2
a726 7
		if (try == 0 && save_errno == SM_ERR_TIMEOUT)
		{
			if (LogLevel > 7)
				sm_syslog(LOG_WARNING, NOQID,
					  "STARTTLS: write error=timeout");
		}
		else if (LogLevel > 8)
d728 1
a728 1
				  "STARTTLS: write error=%s (%d), errno=%d, get_error=%s, retry=%d, ssl_err=%d",
d730 1
a730 2
				  ERR_error_string(ERR_get_error(), NULL), try,
				  ssl_err);
d733 1
a733 2
				  "STARTTLS: write error=%s (%d), errno=%d, retry=%d, ssl_err=%d",
				  err, r, errno, try, ssl_err);
@


1.1.127.2
log
@Import sendmail.8.14.5.Beta0.tar.gz
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Id: sfsasl.c,v 8.118 2008/07/22 15:12:48 ca Exp $")
d299 1
a299 1
	**  due to a negotiation with the other side, e.g.,
@


1.1.127.3
log
@Update
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Id: sfsasl.c,v 8.120 2013/03/15 17:49:12 guenther Exp $")
d631 1
a631 1
			tlslogerr(LOG_WARNING, where);
a637 1
		int save_errno = errno;
a649 1
		errno = save_errno;
a653 1
		int save_errno = errno;
a665 1
		errno = save_errno;
a772 1

d774 1
a774 9
		{
			int pri;

			if (errno == EAGAIN && try > 0)
				pri = LOG_DEBUG;
			else
				pri = LOG_WARNING;
			tlslogerr(pri, "read");
		}
d795 1
a795 8
		{
			int pri;

			if (save_errno == EAGAIN && try > 0)
				pri = LOG_DEBUG;
			else
				pri = LOG_WARNING;
			sm_syslog(pri, NOQID,
a799 1
		}
d881 1
a881 1
			tlslogerr(LOG_WARNING, "write");
@


1.1.127.4
log
@Import sendmail 8.14.9
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2006, 2008 Proofpoint, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Id: sfsasl.c,v 8.121 2013-11-22 20:51:56 ca Exp $")
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.1.2.1
log
@MFC most of the recent sendmail updates to MirOS #8-stable
agreed bsiegert@@

This also changes the LOCALBASE stuff, links libmilter not
against LDAP, etc. but doesn't install the FreeBSD 6 confs
nor a shared libmilter in order to pass a no-files-diff:

tg@@maou:/usr/src/gnu/usr.sbin/sendmail $ sudo find / -ls | sort -k11 >~/x1
tg@@maou:/usr/src/gnu/usr.sbin/sendmail $ sudo make install
tg@@maou:/usr/src/gnu/usr.sbin/sendmail/cf/cf $ sudo make distribution
tg@@maou:/usr/src/gnu/usr.sbin/sendmail/cf/cf $ sudo find / -ls | sort -k11 | diff -u ~/x1 - | less

Note: files in /etc/mail/ are also changed, this affects the etc8.ngz set
on fresh installs and cannot(!) be automatically upgraded!
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2006 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: sfsasl.c,v 8.113 2006/03/02 19:18:27 ca Exp $")
a225 3
			if (LogLevel > 7)
				sm_syslog(LOG_WARNING, NOQID,
					"AUTH: sasl_decode error=%d", result);
d307 1
a307 1
				(const void **) &maxencode);
a314 4
	{
		if (LogLevel > 7)
			sm_syslog(LOG_WARNING, NOQID,
				"AUTH: sasl_encode error=%d", result);
a315 1
	}
a543 119
**  TLS_RETRY -- check whether a failed SSL operation can be retried
**
**	Parameters:
**		ssl -- TLS structure
**		rfd -- read fd
**		wfd -- write fd
**		tlsstart -- start time of TLS operation
**		timeout -- timeout for TLS operation
**		err -- SSL error
**		where -- description of operation
**
**	Results:
**		>0 on success
**		0 on timeout
**		<0 on error
*/

int
tls_retry(ssl, rfd, wfd, tlsstart, timeout, err, where)
	SSL *ssl;
	int rfd;
	int wfd;
	time_t tlsstart;
	int timeout;
	int err;
	const char *where;
{
	int ret;
	time_t left;
	time_t now = curtime();
	struct timeval tv;

	ret = -1;

	/*
	**  For SSL_ERROR_WANT_{READ,WRITE}:
	**  There is not a complete SSL record available yet
	**  or there is only a partial SSL record removed from
	**  the network (socket) buffer into the SSL buffer.
	**  The SSL_connect will only succeed when a full
	**  SSL record is available (assuming a "real" error
	**  doesn't happen). To handle when a "real" error
	**  does happen the select is set for exceptions too.
	**  The connection may be re-negotiated during this time
	**  so both read and write "want errors" need to be handled.
	**  A select() exception loops back so that a proper SSL
	**  error message can be gotten.
	*/

	left = timeout - (now - tlsstart);
	if (left <= 0)
		return 0;	/* timeout */
	tv.tv_sec = left;
	tv.tv_usec = 0;

	if (LogLevel > 14)
	{
		sm_syslog(LOG_INFO, NOQID,
			  "STARTTLS=%s, info: fds=%d/%d, err=%d",
			  where, rfd, wfd, err);
	}

	if (FD_SETSIZE > 0 &&
	    ((err == SSL_ERROR_WANT_READ && rfd >= FD_SETSIZE) ||
	     (err == SSL_ERROR_WANT_WRITE && wfd >= FD_SETSIZE)))
	{
		if (LogLevel > 5)
		{
			sm_syslog(LOG_ERR, NOQID,
				  "STARTTLS=%s, error: fd %d/%d too large",
				  where, rfd, wfd);
		if (LogLevel > 8)
			tlslogerr(where);
		}
		errno = EINVAL;
	}
	else if (err == SSL_ERROR_WANT_READ)
	{
		fd_set ssl_maskr, ssl_maskx;

		FD_ZERO(&ssl_maskr);
		FD_SET(rfd, &ssl_maskr);
		FD_ZERO(&ssl_maskx);
		FD_SET(rfd, &ssl_maskx);
		do
		{
			ret = select(rfd + 1, &ssl_maskr, NULL, &ssl_maskx,
					&tv);
		} while (ret < 0 && errno == EINTR);
		if (ret < 0 && errno > 0)
			ret = -errno;
	}
	else if (err == SSL_ERROR_WANT_WRITE)
	{
		fd_set ssl_maskw, ssl_maskx;

		FD_ZERO(&ssl_maskw);
		FD_SET(wfd, &ssl_maskw);
		FD_ZERO(&ssl_maskx);
		FD_SET(rfd, &ssl_maskx);
		do
		{
			ret = select(wfd + 1, NULL, &ssl_maskw, &ssl_maskx,
					&tv);
		} while (ret < 0 && errno == EINTR);
		if (ret < 0 && errno > 0)
			ret = -errno;
	}
	return ret;
}

/* errno to force refill() etc to stop (see IS_IO_ERROR()) */
#ifdef ETIMEDOUT
# define SM_ERR_TIMEOUT	ETIMEDOUT
#else /* ETIMEDOUT */
# define SM_ERR_TIMEOUT	EIO
#endif /* ETIMEDOUT */

/*
d564 2
a565 1
	int r, rfd, wfd, try, ssl_err;
a566 1
	time_t tlsstart;
a568 5
	try = 99;
	err = NULL;
	tlsstart = curtime();

  retry:
d572 2
d575 1
d578 1
a578 1
	switch (ssl_err = SSL_get_error(so->con, r))
d582 1
d585 5
a589 2
		err = "read W BLOCK";
		/* FALLTHROUGH */
d591 1
a591 1
		if (err == NULL)
d593 2
a594 7
		rfd = SSL_get_rfd(so->con);
		wfd = SSL_get_wfd(so->con);
		try = tls_retry(so->con, rfd, wfd, tlsstart,
				TimeOuts.to_datablock, ssl_err, "read");
		if (try > 0)
			goto retry;
		errno = SM_ERR_TIMEOUT;
a595 1

d628 2
a629 7
		if (try == 0 && save_errno == SM_ERR_TIMEOUT)
		{
			if (LogLevel > 7)
				sm_syslog(LOG_WARNING, NOQID,
					  "STARTTLS: read error=timeout");
		}
		else if (LogLevel > 8)
d631 1
a631 1
				  "STARTTLS: read error=%s (%d), errno=%d, get_error=%s, retry=%d, ssl_err=%d",
d633 1
a633 2
				  ERR_error_string(ERR_get_error(), NULL), try,
				  ssl_err);
d636 1
a636 2
				  "STARTTLS: read error=%s (%d), retry=%d, ssl_err=%d",
				  err, r, errno, try, ssl_err);
d663 2
a664 1
	int r, rfd, wfd, try, ssl_err;
a665 1
	time_t tlsstart;
a667 5
	try = 99;
	err = NULL;
	tlsstart = curtime();

  retry:
d671 2
d674 1
d676 1
a676 1
	switch (ssl_err = SSL_get_error(so->con, r))
d680 1
d683 5
a687 2
		err = "read W BLOCK";
		/* FALLTHROUGH */
d689 4
a692 9
		if (err == NULL)
			err = "read R BLOCK";
		rfd = SSL_get_rfd(so->con);
		wfd = SSL_get_wfd(so->con);
		try = tls_retry(so->con, rfd, wfd, tlsstart,
				DATA_PROGRESS_TIMEOUT, ssl_err, "write");
		if (try > 0)
			goto retry;
		errno = SM_ERR_TIMEOUT;
d725 2
a726 7
		if (try == 0 && save_errno == SM_ERR_TIMEOUT)
		{
			if (LogLevel > 7)
				sm_syslog(LOG_WARNING, NOQID,
					  "STARTTLS: write error=timeout");
		}
		else if (LogLevel > 8)
d728 1
a728 1
				  "STARTTLS: write error=%s (%d), errno=%d, get_error=%s, retry=%d, ssl_err=%d",
d730 1
a730 2
				  ERR_error_string(ERR_get_error(), NULL), try,
				  ssl_err);
d733 1
a733 2
				  "STARTTLS: write error=%s (%d), errno=%d, retry=%d, ssl_err=%d",
				  err, r, errno, try, ssl_err);
@


1.1.1.2
log
@Update to Sendmail 8.13.6
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2006 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: sfsasl.c,v 8.113 2006/03/02 19:18:27 ca Exp $")
a225 3
			if (LogLevel > 7)
				sm_syslog(LOG_WARNING, NOQID,
					"AUTH: sasl_decode error=%d", result);
d307 1
a307 1
				(const void **) &maxencode);
a314 4
	{
		if (LogLevel > 7)
			sm_syslog(LOG_WARNING, NOQID,
				"AUTH: sasl_encode error=%d", result);
a315 1
	}
a543 119
**  TLS_RETRY -- check whether a failed SSL operation can be retried
**
**	Parameters:
**		ssl -- TLS structure
**		rfd -- read fd
**		wfd -- write fd
**		tlsstart -- start time of TLS operation
**		timeout -- timeout for TLS operation
**		err -- SSL error
**		where -- description of operation
**
**	Results:
**		>0 on success
**		0 on timeout
**		<0 on error
*/

int
tls_retry(ssl, rfd, wfd, tlsstart, timeout, err, where)
	SSL *ssl;
	int rfd;
	int wfd;
	time_t tlsstart;
	int timeout;
	int err;
	const char *where;
{
	int ret;
	time_t left;
	time_t now = curtime();
	struct timeval tv;

	ret = -1;

	/*
	**  For SSL_ERROR_WANT_{READ,WRITE}:
	**  There is not a complete SSL record available yet
	**  or there is only a partial SSL record removed from
	**  the network (socket) buffer into the SSL buffer.
	**  The SSL_connect will only succeed when a full
	**  SSL record is available (assuming a "real" error
	**  doesn't happen). To handle when a "real" error
	**  does happen the select is set for exceptions too.
	**  The connection may be re-negotiated during this time
	**  so both read and write "want errors" need to be handled.
	**  A select() exception loops back so that a proper SSL
	**  error message can be gotten.
	*/

	left = timeout - (now - tlsstart);
	if (left <= 0)
		return 0;	/* timeout */
	tv.tv_sec = left;
	tv.tv_usec = 0;

	if (LogLevel > 14)
	{
		sm_syslog(LOG_INFO, NOQID,
			  "STARTTLS=%s, info: fds=%d/%d, err=%d",
			  where, rfd, wfd, err);
	}

	if (FD_SETSIZE > 0 &&
	    ((err == SSL_ERROR_WANT_READ && rfd >= FD_SETSIZE) ||
	     (err == SSL_ERROR_WANT_WRITE && wfd >= FD_SETSIZE)))
	{
		if (LogLevel > 5)
		{
			sm_syslog(LOG_ERR, NOQID,
				  "STARTTLS=%s, error: fd %d/%d too large",
				  where, rfd, wfd);
		if (LogLevel > 8)
			tlslogerr(where);
		}
		errno = EINVAL;
	}
	else if (err == SSL_ERROR_WANT_READ)
	{
		fd_set ssl_maskr, ssl_maskx;

		FD_ZERO(&ssl_maskr);
		FD_SET(rfd, &ssl_maskr);
		FD_ZERO(&ssl_maskx);
		FD_SET(rfd, &ssl_maskx);
		do
		{
			ret = select(rfd + 1, &ssl_maskr, NULL, &ssl_maskx,
					&tv);
		} while (ret < 0 && errno == EINTR);
		if (ret < 0 && errno > 0)
			ret = -errno;
	}
	else if (err == SSL_ERROR_WANT_WRITE)
	{
		fd_set ssl_maskw, ssl_maskx;

		FD_ZERO(&ssl_maskw);
		FD_SET(wfd, &ssl_maskw);
		FD_ZERO(&ssl_maskx);
		FD_SET(rfd, &ssl_maskx);
		do
		{
			ret = select(wfd + 1, NULL, &ssl_maskw, &ssl_maskx,
					&tv);
		} while (ret < 0 && errno == EINTR);
		if (ret < 0 && errno > 0)
			ret = -errno;
	}
	return ret;
}

/* errno to force refill() etc to stop (see IS_IO_ERROR()) */
#ifdef ETIMEDOUT
# define SM_ERR_TIMEOUT	ETIMEDOUT
#else /* ETIMEDOUT */
# define SM_ERR_TIMEOUT	EIO
#endif /* ETIMEDOUT */

/*
d564 2
a565 1
	int r, rfd, wfd, try, ssl_err;
a566 1
	time_t tlsstart;
a568 5
	try = 99;
	err = NULL;
	tlsstart = curtime();

  retry:
d572 2
d575 1
d578 1
a578 1
	switch (ssl_err = SSL_get_error(so->con, r))
d582 1
d585 5
a589 2
		err = "read W BLOCK";
		/* FALLTHROUGH */
d591 1
a591 1
		if (err == NULL)
d593 2
a594 7
		rfd = SSL_get_rfd(so->con);
		wfd = SSL_get_wfd(so->con);
		try = tls_retry(so->con, rfd, wfd, tlsstart,
				TimeOuts.to_datablock, ssl_err, "read");
		if (try > 0)
			goto retry;
		errno = SM_ERR_TIMEOUT;
a595 1

d628 2
a629 7
		if (try == 0 && save_errno == SM_ERR_TIMEOUT)
		{
			if (LogLevel > 7)
				sm_syslog(LOG_WARNING, NOQID,
					  "STARTTLS: read error=timeout");
		}
		else if (LogLevel > 8)
d631 1
a631 1
				  "STARTTLS: read error=%s (%d), errno=%d, get_error=%s, retry=%d, ssl_err=%d",
d633 1
a633 2
				  ERR_error_string(ERR_get_error(), NULL), try,
				  ssl_err);
d636 1
a636 2
				  "STARTTLS: read error=%s (%d), retry=%d, ssl_err=%d",
				  err, r, errno, try, ssl_err);
d663 2
a664 1
	int r, rfd, wfd, try, ssl_err;
a665 1
	time_t tlsstart;
a667 5
	try = 99;
	err = NULL;
	tlsstart = curtime();

  retry:
d671 2
d674 1
d676 1
a676 1
	switch (ssl_err = SSL_get_error(so->con, r))
d680 1
d683 5
a687 2
		err = "read W BLOCK";
		/* FALLTHROUGH */
d689 4
a692 9
		if (err == NULL)
			err = "read R BLOCK";
		rfd = SSL_get_rfd(so->con);
		wfd = SSL_get_wfd(so->con);
		try = tls_retry(so->con, rfd, wfd, tlsstart,
				DATA_PROGRESS_TIMEOUT, ssl_err, "write");
		if (try > 0)
			goto retry;
		errno = SM_ERR_TIMEOUT;
d725 2
a726 7
		if (try == 0 && save_errno == SM_ERR_TIMEOUT)
		{
			if (LogLevel > 7)
				sm_syslog(LOG_WARNING, NOQID,
					  "STARTTLS: write error=timeout");
		}
		else if (LogLevel > 8)
d728 1
a728 1
				  "STARTTLS: write error=%s (%d), errno=%d, get_error=%s, retry=%d, ssl_err=%d",
d730 1
a730 2
				  ERR_error_string(ERR_get_error(), NULL), try,
				  ssl_err);
d733 1
a733 2
				  "STARTTLS: write error=%s (%d), errno=%d, retry=%d, ssl_err=%d",
				  err, r, errno, try, ssl_err);
@


1.1.1.3
log
@Import latest Sendmail
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: sfsasl.c,v 8.115 2006/04/18 21:34:07 ca Exp $")
a14 1
#include <sm/time.h>
a328 1
			errno = 0;
d350 1
a350 1
**		fout -- the sm_io file encrypted data to be written to
a351 1
**		tmo -- timeout
d363 1
a363 1
sfdcsasl(fin, fout, conn, tmo)
a366 1
	int tmo;
d371 1
a371 1
		SM_TIME_DEFAULT);
d382 1
a382 1
		SM_TIME_DEFAULT);
a402 3
	sm_io_setinfo(*fin, SM_IO_WHAT_TIMEOUT, &tmo);
	sm_io_setinfo(*fout, SM_IO_WHAT_TIMEOUT, &tmo);

@


1.1.1.3.2.1
log
@MFC sendmail update to 8.14.3

agreed bsiegert@@
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2006, 2008 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: sfsasl.c,v 8.117 2008/01/31 18:48:29 ca Exp $")
a677 20
**  SET_TLS_RD_TMO -- read secured information for the caller
**
**	Parameters:
**		rd_tmo -- read timeout
**
**	Results:
**		none
**	This is a hack: there is no way to pass it in
*/

static int tls_rd_tmo = -1;

void
set_tls_rd_tmo(rd_tmo)
	int rd_tmo;
{
	tls_rd_tmo = rd_tmo;
}

/*
d728 1
a728 3
				(tls_rd_tmo < 0) ? TimeOuts.to_datablock
						 : tls_rd_tmo,
				ssl_err, "read");
@


1.1.1.4
log
@OpenBSD finally has upgraded their sendmail, too…
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2006, 2008 Sendmail, Inc. and its suppliers.
d12 1
a12 1
SM_RCSID("@@(#)$Sendmail: sfsasl.c,v 8.117 2008/01/31 18:48:29 ca Exp $")
a677 20
**  SET_TLS_RD_TMO -- read secured information for the caller
**
**	Parameters:
**		rd_tmo -- read timeout
**
**	Results:
**		none
**	This is a hack: there is no way to pass it in
*/

static int tls_rd_tmo = -1;

void
set_tls_rd_tmo(rd_tmo)
	int rd_tmo;
{
	tls_rd_tmo = rd_tmo;
}

/*
d728 1
a728 3
				(tls_rd_tmo < 0) ? TimeOuts.to_datablock
						 : tls_rd_tmo,
				ssl_err, "read");
@


1.1.1.5
log
@Replace “$Sendmail: ” with “$Id: ” (the latter is used by upstream)
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Id: sfsasl.c,v 8.117 2008/01/31 18:48:29 ca Exp $")
@


1.1.1.6
log
@Import OpenBSD’s sendmail 8.14.5, RCS IDs properly sedded back
@
text
@d12 1
a12 1
SM_RCSID("@@(#)$Id: sfsasl.c,v 8.118 2008/07/22 15:12:48 ca Exp $")
d299 1
a299 1
	**  due to a negotiation with the other side, e.g.,
@


