head	1.6;
access;
symbols
	sendmail-8_14_9:1.1.127.3
	sendmail-8_14_7:1.1.127.2
	sendmail-8_14_6:1.1.127.1
	sendmail-8_14_5-ERRATA-1:1.1.127.1
	mbsd-20101220_mergebase:1.1.1.6.2.1
	sendmail-8_14_5:1.1.127.1
	cvs-201107021500:1.1.1.7
	cvs-20101220:1.1.1.7
	mbsd-20101220:1.1.1.6.0.2
	cvs-201012191730:1.1.1.6
	sendmail-8_14_5_Beta0:1.1.127.1
	sendmail-8_14_3:1.1.127.1
	sendmail:1.1.127
	cvs-200812170000:1.1.1.6
	cvs-200805071200:1.1.1.6
	MIRBSD_10:1.2.0.2
	MIRBSD_10_BASE:1.2
	cvs-200803022030:1.1.1.5
	cvs-200707152000:1.1.1.5
	cvs-200704292000:1.1.1.5
	cvs-200702051700:1.1.1.5
	cvs-200609121900:1.1.1.4
	MIRBSD_9_BASE:1.1.1.3
	cvs-200606151800:1.1.1.3
	cvs-200603231300:1.1.1.2
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200507211800:1.1.1.1
	cvs-200504262050:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2014.06.09.15.17.52;	author tg;	state Exp;
branches;
next	1.5;
commitid	1005395CFC65E5646F1;

1.5
date	2013.08.06.20.37.13;	author tg;	state Exp;
branches;
next	1.4;
commitid	10052015E562892E658;

1.4
date	2011.07.02.15.04.10;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004E0F31C5496AB95F;

1.3
date	2008.05.07.13.15.28;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004821AB7510EE48FB;

1.2
date	2008.03.02.21.41.16;	author tg;	state Exp;
branches
	1.2.2.1;
next	1.1;
commitid	10047CB1EE51190ECAF;

1.1
date	2005.02.05.17.24.29;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.127.1;
next	;

1.2.2.1
date	2008.05.17.19.12.16;	author tg;	state Exp;
branches;
next	;
commitid	100482F2DC168C89AEA;

1.1.1.1
date	2005.02.05.17.24.29;	author tg;	state Exp;
branches
	1.1.1.1.2.1;
next	1.1.1.2;

1.1.1.2
date	2006.03.23.13.10.01;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	10044229DEA33D36552;

1.1.1.3
date	2006.06.15.18.18.30;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	1004491A472259D8EA1;

1.1.1.4
date	2006.09.12.19.22.30;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	100450708CE5C63A8F5;

1.1.1.5
date	2007.02.05.17.06.36;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	10045C763C551AABAF7;

1.1.1.6
date	2008.05.07.12.31.51;	author tg;	state Exp;
branches
	1.1.1.6.2.1;
next	1.1.1.7;
commitid	1004821A13C1FC036E1;

1.1.1.7
date	2011.07.02.15.00.53;	author tg;	state Exp;
branches;
next	;
commitid	1004E0F31C5496AB95F;

1.1.1.1.2.1
date	2006.03.30.19.28.03;	author tg;	state Exp;
branches;
next	;
commitid	100442C309C7183FA09;

1.1.1.6.2.1
date	2011.07.02.15.02.57;	author tg;	state Exp;
branches;
next	;
commitid	1004E0F31C5496AB95F;

1.1.127.1
date	2010.12.19.14.45.45;	author tg;	state Exp;
branches;
next	1.1.127.2;
commitid	1004D0E1A94384778FD;

1.1.127.2
date	2013.08.06.20.26.22;	author tg;	state Exp;
branches;
next	1.1.127.3;
commitid	10052015BDF0FDDCF84;

1.1.127.3
date	2014.06.09.14.29.17;	author tg;	state Exp;
branches;
next	;
commitid	1005395C4CC1A6DB9EE;


desc
@@


1.6
log
@merge
@
text
@/*
 * Copyright (c) 1998-2003, 2006, 2013 Proofpoint, Inc. and its suppliers.
 *	All rights reserved.
 * Copyright (c) 1994, 1996-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <sendmail.h>
#include <string.h>

SM_RCSID("@@(#)$Id: mime.c,v 8.149 2013-11-22 20:51:56 ca Exp $")

/*
**  MIME support.
**
**	I am indebted to John Beck of Hewlett-Packard, who contributed
**	his code to me for inclusion.  As it turns out, I did not use
**	his code since he used a "minimum change" approach that used
**	several temp files, and I wanted a "minimum impact" approach
**	that would avoid copying.  However, looking over his code
**	helped me cement my understanding of the problem.
**
**	I also looked at, but did not directly use, Nathaniel
**	Borenstein's "code.c" module.  Again, it functioned as
**	a file-to-file translator, which did not fit within my
**	design bounds, but it was a useful base for understanding
**	the problem.
*/

/* use "old" mime 7 to 8 algorithm by default */
#ifndef MIME7TO8_OLD
# define MIME7TO8_OLD	1
#endif /* ! MIME7TO8_OLD */

#if MIME8TO7
static int	isboundary __P((char *, char **));
static int	mimeboundary __P((char *, char **));
static int	mime_getchar __P((SM_FILE_T *, char **, int *));
static int	mime_getchar_crlf __P((SM_FILE_T *, char **, int *));

/* character set for hex and base64 encoding */
static char	Base16Code[] =	"0123456789ABCDEF";
static char	Base64Code[] =	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

/* types of MIME boundaries */
# define MBT_SYNTAX	0	/* syntax error */
# define MBT_NOTSEP	1	/* not a boundary */
# define MBT_INTERMED	2	/* intermediate boundary (no trailing --) */
# define MBT_FINAL	3	/* final boundary (trailing -- included) */

static char	*MimeBoundaryNames[] =
{
	"SYNTAX",	"NOTSEP",	"INTERMED",	"FINAL"
};

static bool	MapNLtoCRLF;

/*
**  MIME8TO7 -- output 8 bit body in 7 bit format
**
**	The header has already been output -- this has to do the
**	8 to 7 bit conversion.  It would be easy if we didn't have
**	to deal with nested formats (multipart/xxx and message/rfc822).
**
**	We won't be called if we don't have to do a conversion, and
**	appropriate MIME-Version: and Content-Type: fields have been
**	output.  Any Content-Transfer-Encoding: field has not been
**	output, and we can add it here.
**
**	Parameters:
**		mci -- mailer connection information.
**		header -- the header for this body part.
**		e -- envelope.
**		boundaries -- the currently pending message boundaries.
**			NULL if we are processing the outer portion.
**		flags -- to tweak processing.
**		level -- recursion level.
**
**	Returns:
**		An indicator of what terminated the message part:
**		  MBT_FINAL -- the final boundary
**		  MBT_INTERMED -- an intermediate boundary
**		  MBT_NOTSEP -- an end of file
**		  SM_IO_EOF -- I/O error occurred
*/

struct args
{
	char	*a_field;	/* name of field */
	char	*a_value;	/* value of that field */
};

int
mime8to7(mci, header, e, boundaries, flags, level)
	register MCI *mci;
	HDR *header;
	register ENVELOPE *e;
	char **boundaries;
	int flags;
	int level;
{
	register char *p;
	int linelen;
	int blen;
	int bt;
	off_t offset;
	size_t sectionsize, sectionhighbits;
	int i;
	char *type;
	char *subtype;
	char *cte;
	char **pvp;
	int argc = 0;
	char *bp;
	bool use_qp = false;
	struct args argv[MAXMIMEARGS];
	char bbuf[128];
	char buf[MAXLINE];
	char pvpbuf[MAXLINE];
	extern unsigned char MimeTokenTab[256];

	if (level > MAXMIMENESTING)
	{
		if (!bitset(EF_TOODEEP, e->e_flags))
		{
			if (tTd(43, 4))
				sm_dprintf("mime8to7: too deep, level=%d\n",
					   level);
			usrerr("mime8to7: recursion level %d exceeded",
				level);
			e->e_flags |= EF_DONT_MIME|EF_TOODEEP;
		}
	}
	if (tTd(43, 1))
	{
		sm_dprintf("mime8to7: flags = %x, boundaries =", flags);
		if (boundaries[0] == NULL)
			sm_dprintf(" <none>");
		else
		{
			for (i = 0; boundaries[i] != NULL; i++)
				sm_dprintf(" %s", boundaries[i]);
		}
		sm_dprintf("\n");
	}
	MapNLtoCRLF = true;
	p = hvalue("Content-Transfer-Encoding", header);
	if (p == NULL ||
	    (pvp = prescan(p, '\0', pvpbuf, sizeof(pvpbuf), NULL,
			   MimeTokenTab, false)) == NULL ||
	    pvp[0] == NULL)
	{
		cte = NULL;
	}
	else
	{
		cataddr(pvp, NULL, buf, sizeof(buf), '\0', false);
		cte = sm_rpool_strdup_x(e->e_rpool, buf);
	}

	type = subtype = NULL;
	p = hvalue("Content-Type", header);
	if (p == NULL)
	{
		if (bitset(M87F_DIGEST, flags))
			p = "message/rfc822";
		else
			p = "text/plain";
	}
	if (p != NULL &&
	    (pvp = prescan(p, '\0', pvpbuf, sizeof(pvpbuf), NULL,
			   MimeTokenTab, false)) != NULL &&
	    pvp[0] != NULL)
	{
		if (tTd(43, 40))
		{
			for (i = 0; pvp[i] != NULL; i++)
				sm_dprintf("pvp[%d] = \"%s\"\n", i, pvp[i]);
		}
		type = *pvp++;
		if (*pvp != NULL && strcmp(*pvp, "/") == 0 &&
		    *++pvp != NULL)
		{
			subtype = *pvp++;
		}

		/* break out parameters */
		while (*pvp != NULL && argc < MAXMIMEARGS)
		{
			/* skip to semicolon separator */
			while (*pvp != NULL && strcmp(*pvp, ";") != 0)
				pvp++;
			if (*pvp++ == NULL || *pvp == NULL)
				break;

			/* complain about empty values */
			if (strcmp(*pvp, ";") == 0)
			{
				usrerr("mime8to7: Empty parameter in Content-Type header");

				/* avoid bounce loops */
				e->e_flags |= EF_DONT_MIME;
				continue;
			}

			/* extract field name */
			argv[argc].a_field = *pvp++;

			/* see if there is a value */
			if (*pvp != NULL && strcmp(*pvp, "=") == 0 &&
			    (*++pvp == NULL || strcmp(*pvp, ";") != 0))
			{
				argv[argc].a_value = *pvp;
				argc++;
			}
		}
	}

	/* check for disaster cases */
	if (type == NULL)
		type = "-none-";
	if (subtype == NULL)
		subtype = "-none-";

	/* don't propagate some flags more than one level into the message */
	flags &= ~M87F_DIGEST;

	/*
	**  Check for cases that can not be encoded.
	**
	**	For example, you can't encode certain kinds of types
	**	or already-encoded messages.  If we find this case,
	**	just copy it through.
	*/

	(void) sm_snprintf(buf, sizeof(buf), "%.100s/%.100s", type, subtype);
	if (wordinclass(buf, 'n') || (cte != NULL && !wordinclass(cte, 'e')))
		flags |= M87F_NO8BIT;

# ifdef USE_B_CLASS
	if (wordinclass(buf, 'b') || wordinclass(type, 'b'))
		MapNLtoCRLF = false;
# endif /* USE_B_CLASS */
	if (wordinclass(buf, 'q') || wordinclass(type, 'q'))
		use_qp = true;

	/*
	**  Multipart requires special processing.
	**
	**	Do a recursive descent into the message.
	*/

	if (sm_strcasecmp(type, "multipart") == 0 &&
	    (!bitset(M87F_NO8BIT, flags) || bitset(M87F_NO8TO7, flags)) &&
	    !bitset(EF_TOODEEP, e->e_flags)
	   )
	{

		if (sm_strcasecmp(subtype, "digest") == 0)
			flags |= M87F_DIGEST;

		for (i = 0; i < argc; i++)
		{
			if (sm_strcasecmp(argv[i].a_field, "boundary") == 0)
				break;
		}
		if (i >= argc || argv[i].a_value == NULL)
		{
			usrerr("mime8to7: Content-Type: \"%s\": %s boundary",
				i >= argc ? "missing" : "bogus", p);
			p = "---";

			/* avoid bounce loops */
			e->e_flags |= EF_DONT_MIME;
		}
		else
		{
			p = argv[i].a_value;
			stripquotes(p);
		}
		if (sm_strlcpy(bbuf, p, sizeof(bbuf)) >= sizeof(bbuf))
		{
			usrerr("mime8to7: multipart boundary \"%s\" too long",
				p);

			/* avoid bounce loops */
			e->e_flags |= EF_DONT_MIME;
		}

		if (tTd(43, 1))
			sm_dprintf("mime8to7: multipart boundary \"%s\"\n",
				bbuf);
		for (i = 0; i < MAXMIMENESTING; i++)
		{
			if (boundaries[i] == NULL)
				break;
		}
		if (i >= MAXMIMENESTING)
		{
			if (tTd(43, 4))
				sm_dprintf("mime8to7: too deep, i=%d\n", i);
			if (!bitset(EF_TOODEEP, e->e_flags))
				usrerr("mime8to7: multipart nesting boundary too deep");

			/* avoid bounce loops */
			e->e_flags |= EF_DONT_MIME|EF_TOODEEP;
		}
		else
		{
			boundaries[i] = bbuf;
			boundaries[i + 1] = NULL;
		}
		mci->mci_flags |= MCIF_INMIME;

		/* skip the early "comment" prologue */
		if (!putline("", mci))
			goto writeerr;
		mci->mci_flags &= ~MCIF_INHEADER;
		bt = MBT_FINAL;
		while ((blen = sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf,
					sizeof(buf))) >= 0)
		{
			bt = mimeboundary(buf, boundaries);
			if (bt != MBT_NOTSEP)
				break;
			if (!putxline(buf, blen, mci,
					PXLF_MAPFROM|PXLF_STRIP8BIT))
				goto writeerr;
			if (tTd(43, 99))
				sm_dprintf("  ...%s", buf);
		}
		if (sm_io_eof(e->e_dfp))
			bt = MBT_FINAL;
		while (bt != MBT_FINAL)
		{
			auto HDR *hdr = NULL;

			(void) sm_strlcpyn(buf, sizeof(buf), 2, "--", bbuf);
			if (!putline(buf, mci))
				goto writeerr;
			if (tTd(43, 35))
				sm_dprintf("  ...%s\n", buf);
			collect(e->e_dfp, false, &hdr, e, false);
			if (tTd(43, 101))
				putline("+++after collect", mci);
			if (!putheader(mci, hdr, e, flags))
				goto writeerr;
			if (tTd(43, 101))
				putline("+++after putheader", mci);
			bt = mime8to7(mci, hdr, e, boundaries, flags,
				      level + 1);
			if (bt == SM_IO_EOF)
				goto writeerr;
		}
		(void) sm_strlcpyn(buf, sizeof(buf), 3, "--", bbuf, "--");
		if (!putline(buf, mci))
			goto writeerr;
		if (tTd(43, 35))
			sm_dprintf("  ...%s\n", buf);
		boundaries[i] = NULL;
		mci->mci_flags &= ~MCIF_INMIME;

		/* skip the late "comment" epilogue */
		while ((blen = sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf,
					sizeof(buf))) >= 0)
		{
			bt = mimeboundary(buf, boundaries);
			if (bt != MBT_NOTSEP)
				break;
			if (!putxline(buf, blen, mci,
					PXLF_MAPFROM|PXLF_STRIP8BIT))
				goto writeerr;
			if (tTd(43, 99))
				sm_dprintf("  ...%s", buf);
		}
		if (sm_io_eof(e->e_dfp))
			bt = MBT_FINAL;
		if (tTd(43, 3))
			sm_dprintf("\t\t\tmime8to7=>%s (multipart)\n",
				MimeBoundaryNames[bt]);
		return bt;
	}

	/*
	**  Message/xxx types -- recurse exactly once.
	**
	**	Class 's' is predefined to have "rfc822" only.
	*/

	if (sm_strcasecmp(type, "message") == 0)
	{
		if (!wordinclass(subtype, 's') ||
		    bitset(EF_TOODEEP, e->e_flags))
		{
			flags |= M87F_NO8BIT;
		}
		else
		{
			auto HDR *hdr = NULL;

			if (!putline("", mci))
				goto writeerr;

			mci->mci_flags |= MCIF_INMIME;
			collect(e->e_dfp, false, &hdr, e, false);
			if (tTd(43, 101))
				putline("+++after collect", mci);
			if (!putheader(mci, hdr, e, flags))
				goto writeerr;
			if (tTd(43, 101))
				putline("+++after putheader", mci);
			if (hvalue("MIME-Version", hdr) == NULL &&
			    !bitset(M87F_NO8TO7, flags) &&
			    !putline("MIME-Version: 1.0", mci))
				goto writeerr;
			bt = mime8to7(mci, hdr, e, boundaries, flags,
				      level + 1);
			mci->mci_flags &= ~MCIF_INMIME;
			return bt;
		}
	}

	/*
	**  Non-compound body type
	**
	**	Compute the ratio of seven to eight bit characters;
	**	use that as a heuristic to decide how to do the
	**	encoding.
	*/

	sectionsize = sectionhighbits = 0;
	if (!bitset(M87F_NO8BIT|M87F_NO8TO7, flags))
	{
		/* remember where we were */
		offset = sm_io_tell(e->e_dfp, SM_TIME_DEFAULT);
		if (offset == -1)
			syserr("mime8to7: cannot sm_io_tell on %cf%s",
			       DATAFL_LETTER, e->e_id);

		/* do a scan of this body type to count character types */
		while ((blen = sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf,
					sizeof(buf))) >= 0)
		{
			if (mimeboundary(buf, boundaries) != MBT_NOTSEP)
				break;
			for (i = 0; i < blen; i++)
			{
				/* count bytes with the high bit set */
				sectionsize++;
				if (bitset(0200, buf[i]))
					sectionhighbits++;
			}

			/*
			**  Heuristic: if 1/4 of the first 4K bytes are 8-bit,
			**  assume base64.  This heuristic avoids double-reading
			**  large graphics or video files.
			*/

			if (sectionsize >= 4096 &&
			    sectionhighbits > sectionsize / 4)
				break;
		}

		/* return to the original offset for processing */
		/* XXX use relative seeks to handle >31 bit file sizes? */
		if (sm_io_seek(e->e_dfp, SM_TIME_DEFAULT, offset, SEEK_SET) < 0)
			syserr("mime8to7: cannot sm_io_fseek on %cf%s",
			       DATAFL_LETTER, e->e_id);
		else
			sm_io_clearerr(e->e_dfp);
	}

	/*
	**  Heuristically determine encoding method.
	**	If more than 1/8 of the total characters have the
	**	eighth bit set, use base64; else use quoted-printable.
	**	However, only encode binary encoded data as base64,
	**	since otherwise the NL=>CRLF mapping will be a problem.
	*/

	if (tTd(43, 8))
	{
		sm_dprintf("mime8to7: %ld high bit(s) in %ld byte(s), cte=%s, type=%s/%s\n",
			(long) sectionhighbits, (long) sectionsize,
			cte == NULL ? "[none]" : cte,
			type == NULL ? "[none]" : type,
			subtype == NULL ? "[none]" : subtype);
	}
	if (cte != NULL && sm_strcasecmp(cte, "binary") == 0)
		sectionsize = sectionhighbits;
	linelen = 0;
	bp = buf;
	if (sectionhighbits == 0)
	{
		/* no encoding necessary */
		if (cte != NULL &&
		    bitset(MCIF_CVT8TO7|MCIF_CVT7TO8|MCIF_INMIME,
			   mci->mci_flags) &&
		    !bitset(M87F_NO8TO7, flags))
		{
			/*
			**  Skip _unless_ in MIME mode and potentially
			**  converting from 8 bit to 7 bit MIME.  See
			**  putheader() for the counterpart where the
			**  CTE header is skipped in the opposite
			**  situation.
			*/

			(void) sm_snprintf(buf, sizeof(buf),
				"Content-Transfer-Encoding: %.200s", cte);
			if (!putline(buf, mci))
				goto writeerr;
			if (tTd(43, 36))
				sm_dprintf("  ...%s\n", buf);
		}
		if (!putline("", mci))
			goto writeerr;
		mci->mci_flags &= ~MCIF_INHEADER;
		while ((blen = sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf,
					sizeof(buf))) >= 0)
		{
			if (!bitset(MCIF_INLONGLINE, mci->mci_flags))
			{
				bt = mimeboundary(buf, boundaries);
				if (bt != MBT_NOTSEP)
					break;
			}
			if (!putxline(buf, blen, mci,
				      PXLF_MAPFROM|PXLF_NOADDEOL))
				goto writeerr;
		}
		if (sm_io_eof(e->e_dfp))
			bt = MBT_FINAL;
	}
	else if (!MapNLtoCRLF ||
		 (sectionsize / 8 < sectionhighbits && !use_qp))
	{
		/* use base64 encoding */
		int c1, c2;

		if (tTd(43, 36))
			sm_dprintf("  ...Content-Transfer-Encoding: base64\n");
		if (!putline("Content-Transfer-Encoding: base64", mci))
			goto writeerr;
		(void) sm_snprintf(buf, sizeof(buf),
			"X-MIME-Autoconverted: from 8bit to base64 by %s id %s",
			MyHostName, e->e_id);
		if (!putline(buf, mci) || !putline("", mci))
			goto writeerr;
		mci->mci_flags &= ~MCIF_INHEADER;
		while ((c1 = mime_getchar_crlf(e->e_dfp, boundaries, &bt)) !=
			SM_IO_EOF)
		{
			if (linelen > 71)
			{
				*bp = '\0';
				if (!putline(buf, mci))
					goto writeerr;
				linelen = 0;
				bp = buf;
			}
			linelen += 4;
			*bp++ = Base64Code[(c1 >> 2)];
			c1 = (c1 & 0x03) << 4;
			c2 = mime_getchar_crlf(e->e_dfp, boundaries, &bt);
			if (c2 == SM_IO_EOF)
			{
				*bp++ = Base64Code[c1];
				*bp++ = '=';
				*bp++ = '=';
				break;
			}
			c1 |= (c2 >> 4) & 0x0f;
			*bp++ = Base64Code[c1];
			c1 = (c2 & 0x0f) << 2;
			c2 = mime_getchar_crlf(e->e_dfp, boundaries, &bt);
			if (c2 == SM_IO_EOF)
			{
				*bp++ = Base64Code[c1];
				*bp++ = '=';
				break;
			}
			c1 |= (c2 >> 6) & 0x03;
			*bp++ = Base64Code[c1];
			*bp++ = Base64Code[c2 & 0x3f];
		}
		*bp = '\0';
		if (!putline(buf, mci))
			goto writeerr;
	}
	else
	{
		/* use quoted-printable encoding */
		int c1, c2;
		int fromstate;
		BITMAP256 badchars;

		/* set up map of characters that must be mapped */
		clrbitmap(badchars);
		for (c1 = 0x00; c1 < 0x20; c1++)
			setbitn(c1, badchars);
		clrbitn('\t', badchars);
		for (c1 = 0x7f; c1 < 0x100; c1++)
			setbitn(c1, badchars);
		setbitn('=', badchars);
		if (bitnset(M_EBCDIC, mci->mci_mailer->m_flags))
			for (p = "!\"#$@@[\\]^`{|}~"; *p != '\0'; p++)
				setbitn(*p, badchars);

		if (tTd(43, 36))
			sm_dprintf("  ...Content-Transfer-Encoding: quoted-printable\n");
		if (!putline("Content-Transfer-Encoding: quoted-printable",
				mci))
			goto writeerr;
		(void) sm_snprintf(buf, sizeof(buf),
			"X-MIME-Autoconverted: from 8bit to quoted-printable by %s id %s",
			MyHostName, e->e_id);
		if (!putline(buf, mci) || !putline("", mci))
			goto writeerr;
		mci->mci_flags &= ~MCIF_INHEADER;
		fromstate = 0;
		c2 = '\n';
		while ((c1 = mime_getchar(e->e_dfp, boundaries, &bt)) !=
			SM_IO_EOF)
		{
			if (c1 == '\n')
			{
				if (c2 == ' ' || c2 == '\t')
				{
					*bp++ = '=';
					*bp++ = Base16Code[(c2 >> 4) & 0x0f];
					*bp++ = Base16Code[c2 & 0x0f];
				}
				if (buf[0] == '.' && bp == &buf[1])
				{
					buf[0] = '=';
					*bp++ = Base16Code[('.' >> 4) & 0x0f];
					*bp++ = Base16Code['.' & 0x0f];
				}
				*bp = '\0';
				if (!putline(buf, mci))
					goto writeerr;
				linelen = fromstate = 0;
				bp = buf;
				c2 = c1;
				continue;
			}
			if (c2 == ' ' && linelen == 4 && fromstate == 4 &&
			    bitnset(M_ESCFROM, mci->mci_mailer->m_flags))
			{
				*bp++ = '=';
				*bp++ = '2';
				*bp++ = '0';
				linelen += 3;
			}
			else if (c2 == ' ' || c2 == '\t')
			{
				*bp++ = c2;
				linelen++;
			}
			if (linelen > 72 &&
			    (linelen > 75 || c1 != '.' ||
			     (linelen > 73 && c2 == '.')))
			{
				if (linelen > 73 && c2 == '.')
					bp--;
				else
					c2 = '\n';
				*bp++ = '=';
				*bp = '\0';
				if (!putline(buf, mci))
					goto writeerr;
				linelen = fromstate = 0;
				bp = buf;
				if (c2 == '.')
				{
					*bp++ = '.';
					linelen++;
				}
			}
			if (bitnset(bitidx(c1), badchars))
			{
				*bp++ = '=';
				*bp++ = Base16Code[(c1 >> 4) & 0x0f];
				*bp++ = Base16Code[c1 & 0x0f];
				linelen += 3;
			}
			else if (c1 != ' ' && c1 != '\t')
			{
				if (linelen < 4 && c1 == "From"[linelen])
					fromstate++;
				*bp++ = c1;
				linelen++;
			}
			c2 = c1;
		}

		/* output any saved character */
		if (c2 == ' ' || c2 == '\t')
		{
			*bp++ = '=';
			*bp++ = Base16Code[(c2 >> 4) & 0x0f];
			*bp++ = Base16Code[c2 & 0x0f];
			linelen += 3;
		}

		if (linelen > 0 || boundaries[0] != NULL)
		{
			*bp = '\0';
			if (!putline(buf, mci))
				goto writeerr;
		}

	}
	if (tTd(43, 3))
		sm_dprintf("\t\t\tmime8to7=>%s (basic)\n", MimeBoundaryNames[bt]);
	return bt;

  writeerr:
	return SM_IO_EOF;
}
/*
**  MIME_GETCHAR -- get a character for MIME processing
**
**	Treats boundaries as SM_IO_EOF.
**
**	Parameters:
**		fp -- the input file.
**		boundaries -- the current MIME boundaries.
**		btp -- if the return value is SM_IO_EOF, *btp is set to
**			the type of the boundary.
**
**	Returns:
**		The next character in the input stream.
*/

static int
mime_getchar(fp, boundaries, btp)
	register SM_FILE_T *fp;
	char **boundaries;
	int *btp;
{
	int c;
	static unsigned char *bp = NULL;
	static int buflen = 0;
	static bool atbol = true;	/* at beginning of line */
	static int bt = MBT_SYNTAX;	/* boundary type of next SM_IO_EOF */
	static unsigned char buf[128];	/* need not be a full line */
	int start = 0;			/* indicates position of - in buffer */

	if (buflen == 1 && *bp == '\n')
	{
		/* last \n in buffer may be part of next MIME boundary */
		c = *bp;
	}
	else if (buflen > 0)
	{
		buflen--;
		return *bp++;
	}
	else
		c = sm_io_getc(fp, SM_TIME_DEFAULT);
	bp = buf;
	buflen = 0;
	if (c == '\n')
	{
		/* might be part of a MIME boundary */
		*bp++ = c;
		atbol = true;
		c = sm_io_getc(fp, SM_TIME_DEFAULT);
		if (c == '\n')
		{
			(void) sm_io_ungetc(fp, SM_TIME_DEFAULT, c);
			return c;
		}
		start = 1;
	}
	if (c != SM_IO_EOF)
		*bp++ = c;
	else
		bt = MBT_FINAL;
	if (atbol && c == '-')
	{
		/* check for a message boundary */
		c = sm_io_getc(fp, SM_TIME_DEFAULT);
		if (c != '-')
		{
			if (c != SM_IO_EOF)
				*bp++ = c;
			else
				bt = MBT_FINAL;
			buflen = bp - buf - 1;
			bp = buf;
			return *bp++;
		}

		/* got "--", now check for rest of separator */
		*bp++ = '-';
		while (bp < &buf[sizeof(buf) - 2] &&
		       (c = sm_io_getc(fp, SM_TIME_DEFAULT)) != SM_IO_EOF &&
		       c != '\n')
		{
			*bp++ = c;
		}
		*bp = '\0';	/* XXX simply cut off? */
		bt = mimeboundary((char *) &buf[start], boundaries);
		switch (bt)
		{
		  case MBT_FINAL:
		  case MBT_INTERMED:
			/* we have a message boundary */
			buflen = 0;
			*btp = bt;
			return SM_IO_EOF;
		}

		if (bp < &buf[sizeof(buf) - 2] && c != SM_IO_EOF)
			*bp++ = c;
	}

	atbol = c == '\n';
	buflen = bp - buf - 1;
	if (buflen < 0)
	{
		*btp = bt;
		return SM_IO_EOF;
	}
	bp = buf;
	return *bp++;
}
/*
**  MIME_GETCHAR_CRLF -- do mime_getchar, but translate NL => CRLF
**
**	Parameters:
**		fp -- the input file.
**		boundaries -- the current MIME boundaries.
**		btp -- if the return value is SM_IO_EOF, *btp is set to
**			the type of the boundary.
**
**	Returns:
**		The next character in the input stream.
*/

static int
mime_getchar_crlf(fp, boundaries, btp)
	register SM_FILE_T *fp;
	char **boundaries;
	int *btp;
{
	static bool sendlf = false;
	int c;

	if (sendlf)
	{
		sendlf = false;
		return '\n';
	}
	c = mime_getchar(fp, boundaries, btp);
	if (c == '\n' && MapNLtoCRLF)
	{
		sendlf = true;
		return '\r';
	}
	return c;
}
/*
**  MIMEBOUNDARY -- determine if this line is a MIME boundary & its type
**
**	Parameters:
**		line -- the input line.
**		boundaries -- the set of currently pending boundaries.
**
**	Returns:
**		MBT_NOTSEP -- if this is not a separator line
**		MBT_INTERMED -- if this is an intermediate separator
**		MBT_FINAL -- if this is a final boundary
**		MBT_SYNTAX -- if this is a boundary for the wrong
**			enclosure -- i.e., a syntax error.
*/

static int
mimeboundary(line, boundaries)
	register char *line;
	char **boundaries;
{
	int type = MBT_NOTSEP;
	int i;
	int savec;

	if (line[0] != '-' || line[1] != '-' || boundaries == NULL)
		return MBT_NOTSEP;
	i = strlen(line);
	if (i > 0 && line[i - 1] == '\n')
		i--;

	/* strip off trailing whitespace */
	while (i > 0 && (line[i - 1] == ' ' || line[i - 1] == '\t'
#if _FFR_MIME_CR_OK
		|| line[i - 1] == '\r'
#endif /* _FFR_MIME_CR_OK */
	       ))
		i--;
	savec = line[i];
	line[i] = '\0';

	if (tTd(43, 5))
		sm_dprintf("mimeboundary: line=\"%s\"... ", line);

	/* check for this as an intermediate boundary */
	if (isboundary(&line[2], boundaries) >= 0)
		type = MBT_INTERMED;
	else if (i > 2 && strncmp(&line[i - 2], "--", 2) == 0)
	{
		/* check for a final boundary */
		line[i - 2] = '\0';
		if (isboundary(&line[2], boundaries) >= 0)
			type = MBT_FINAL;
		line[i - 2] = '-';
	}

	line[i] = savec;
	if (tTd(43, 5))
		sm_dprintf("%s\n", MimeBoundaryNames[type]);
	return type;
}
/*
**  DEFCHARSET -- return default character set for message
**
**	The first choice for character set is for the mailer
**	corresponding to the envelope sender.  If neither that
**	nor the global configuration file has a default character
**	set defined, return "unknown-8bit" as recommended by
**	RFC 1428 section 3.
**
**	Parameters:
**		e -- the envelope for this message.
**
**	Returns:
**		The default character set for that mailer.
*/

char *
defcharset(e)
	register ENVELOPE *e;
{
	if (e != NULL && e->e_from.q_mailer != NULL &&
	    e->e_from.q_mailer->m_defcharset != NULL)
		return e->e_from.q_mailer->m_defcharset;
	if (DefaultCharSet != NULL)
		return DefaultCharSet;
	return "unknown-8bit";
}
/*
**  ISBOUNDARY -- is a given string a currently valid boundary?
**
**	Parameters:
**		line -- the current input line.
**		boundaries -- the list of valid boundaries.
**
**	Returns:
**		The index number in boundaries if the line is found.
**		-1 -- otherwise.
**
*/

static int
isboundary(line, boundaries)
	char *line;
	char **boundaries;
{
	register int i;

	for (i = 0; i <= MAXMIMENESTING && boundaries[i] != NULL; i++)
	{
		if (strcmp(line, boundaries[i]) == 0)
			return i;
	}
	return -1;
}
#endif /* MIME8TO7 */

#if MIME7TO8
static int	mime_fromqp __P((unsigned char *, unsigned char **, int));

/*
**  MIME7TO8 -- output 7 bit encoded MIME body in 8 bit format
**
**  This is a hack. Supports translating the two 7-bit body-encodings
**  (quoted-printable and base64) to 8-bit coded bodies.
**
**  There is not much point in supporting multipart here, as the UA
**  will be able to deal with encoded MIME bodies if it can parse MIME
**  multipart messages.
**
**  Note also that we won't be called unless it is a text/plain MIME
**  message, encoded base64 or QP and mailer flag '9' has been defined
**  on mailer.
**
**  Contributed by Marius Olaffson <marius@@rhi.hi.is>.
**
**	Parameters:
**		mci -- mailer connection information.
**		header -- the header for this body part.
**		e -- envelope.
**
**	Returns:
**		true iff body was written successfully
*/

static char index_64[128] =
{
	-1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1,
	-1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1,
	-1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,62, -1,-1,-1,63,
	52,53,54,55, 56,57,58,59, 60,61,-1,-1, -1,-1,-1,-1,
	-1, 0, 1, 2,  3, 4, 5, 6,  7, 8, 9,10, 11,12,13,14,
	15,16,17,18, 19,20,21,22, 23,24,25,-1, -1,-1,-1,-1,
	-1,26,27,28, 29,30,31,32, 33,34,35,36, 37,38,39,40,
	41,42,43,44, 45,46,47,48, 49,50,51,-1, -1,-1,-1,-1
};

# define CHAR64(c)  (((c) < 0 || (c) > 127) ? -1 : index_64[(c)])

bool
mime7to8(mci, header, e)
	register MCI *mci;
	HDR *header;
	register ENVELOPE *e;
{
	int pxflags, blen;
	register char *p;
	char *cte;
	char **pvp;
	unsigned char *fbufp;
	char buf[MAXLINE];
	unsigned char fbuf[MAXLINE + 1];
	char pvpbuf[MAXLINE];
	extern unsigned char MimeTokenTab[256];

	p = hvalue("Content-Transfer-Encoding", header);
	if (p == NULL ||
	    (pvp = prescan(p, '\0', pvpbuf, sizeof(pvpbuf), NULL,
			   MimeTokenTab, false)) == NULL ||
	    pvp[0] == NULL)
	{
		/* "can't happen" -- upper level should have caught this */
		syserr("mime7to8: unparsable CTE %s", p == NULL ? "<NULL>" : p);

		/* avoid bounce loops */
		e->e_flags |= EF_DONT_MIME;

		/* cheap failsafe algorithm -- should work on text/plain */
		if (p != NULL)
		{
			(void) sm_snprintf(buf, sizeof(buf),
				"Content-Transfer-Encoding: %s", p);
			if (!putline(buf, mci))
				goto writeerr;
		}
		if (!putline("", mci))
			goto writeerr;
		mci->mci_flags &= ~MCIF_INHEADER;
		while ((blen = sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf,
					sizeof(buf))) >= 0)
		{
			if (!putxline(buf, blen, mci, PXLF_MAPFROM))
				goto writeerr;
		}
		return true;
	}
	cataddr(pvp, NULL, buf, sizeof(buf), '\0', false);
	cte = sm_rpool_strdup_x(e->e_rpool, buf);

	mci->mci_flags |= MCIF_INHEADER;
	if (!putline("Content-Transfer-Encoding: 8bit", mci))
		goto writeerr;
	(void) sm_snprintf(buf, sizeof(buf),
		"X-MIME-Autoconverted: from %.200s to 8bit by %s id %s",
		cte, MyHostName, e->e_id);
	if (!putline(buf, mci) || !putline("", mci))
		goto writeerr;
	mci->mci_flags &= ~MCIF_INHEADER;

	/*
	**  Translate body encoding to 8-bit.  Supports two types of
	**  encodings; "base64" and "quoted-printable". Assume qp if
	**  it is not base64.
	*/

	pxflags = PXLF_MAPFROM;
	if (sm_strcasecmp(cte, "base64") == 0)
	{
		int c1, c2, c3, c4;

		fbufp = fbuf;
		while ((c1 = sm_io_getc(e->e_dfp, SM_TIME_DEFAULT)) !=
			SM_IO_EOF)
		{
			if (isascii(c1) && isspace(c1))
				continue;

			do
			{
				c2 = sm_io_getc(e->e_dfp, SM_TIME_DEFAULT);
			} while (isascii(c2) && isspace(c2));
			if (c2 == SM_IO_EOF)
				break;

			do
			{
				c3 = sm_io_getc(e->e_dfp, SM_TIME_DEFAULT);
			} while (isascii(c3) && isspace(c3));
			if (c3 == SM_IO_EOF)
				break;

			do
			{
				c4 = sm_io_getc(e->e_dfp, SM_TIME_DEFAULT);
			} while (isascii(c4) && isspace(c4));
			if (c4 == SM_IO_EOF)
				break;

			if (c1 == '=' || c2 == '=')
				continue;
			c1 = CHAR64(c1);
			c2 = CHAR64(c2);

#if MIME7TO8_OLD
#define CHK_EOL if (*--fbufp != '\n' || (fbufp > fbuf && *--fbufp != '\r')) \
			++fbufp;
#else /* MIME7TO8_OLD */
#define CHK_EOL if (*--fbufp != '\n' || (fbufp > fbuf && *--fbufp != '\r')) \
		{					\
			++fbufp;			\
			pxflags |= PXLF_NOADDEOL;	\
		}
#endif /* MIME7TO8_OLD */

#define PUTLINE64	\
	do		\
	{		\
		if (*fbufp++ == '\n' || fbufp >= &fbuf[MAXLINE])	\
		{							\
			CHK_EOL;					\
			if (!putxline((char *) fbuf, fbufp - fbuf, mci, pxflags)) \
				goto writeerr;				\
			pxflags &= ~PXLF_NOADDEOL;			\
			fbufp = fbuf;					\
		}	\
	} while (0)

			*fbufp = (c1 << 2) | ((c2 & 0x30) >> 4);
			PUTLINE64;
			if (c3 == '=')
				continue;
			c3 = CHAR64(c3);
			*fbufp = ((c2 & 0x0f) << 4) | ((c3 & 0x3c) >> 2);
			PUTLINE64;
			if (c4 == '=')
				continue;
			c4 = CHAR64(c4);
			*fbufp = ((c3 & 0x03) << 6) | c4;
			PUTLINE64;
		}
	}
	else
	{
		int off;

		/* quoted-printable */
		pxflags |= PXLF_NOADDEOL;
		fbufp = fbuf;
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf,
				   sizeof(buf)) >= 0)
		{
			off = mime_fromqp((unsigned char *) buf, &fbufp,
					  &fbuf[MAXLINE] - fbufp);
again:
			if (off < -1)
				continue;

			if (fbufp - fbuf > 0)
			{
				if (!putxline((char *) fbuf, fbufp - fbuf - 1,
						mci, pxflags))
					goto writeerr;
			}
			fbufp = fbuf;
			if (off >= 0 && buf[off] != '\0')
			{
				off = mime_fromqp((unsigned char *) (buf + off),
						  &fbufp,
						  &fbuf[MAXLINE] - fbufp);
				goto again;
			}
		}
	}

	/* force out partial last line */
	if (fbufp > fbuf)
	{
		*fbufp = '\0';
		if (!putxline((char *) fbuf, fbufp - fbuf, mci, pxflags))
			goto writeerr;
	}

	/*
	**  The decoded text may end without an EOL.  Since this function
	**  is only called for text/plain MIME messages, it is safe to
	**  add an extra one at the end just in case.  This is a hack,
	**  but so is auto-converting MIME in the first place.
	*/

	if (!putline("", mci))
		goto writeerr;

	if (tTd(43, 3))
		sm_dprintf("\t\t\tmime7to8 => %s to 8bit done\n", cte);
	return true;

  writeerr:
	return false;
}
/*
**  The following is based on Borenstein's "codes.c" module, with simplifying
**  changes as we do not deal with multipart, and to do the translation in-core,
**  with an attempt to prevent overrun of output buffers.
**
**  What is needed here are changes to defend this code better against
**  bad encodings. Questionable to always return 0xFF for bad mappings.
*/

static char index_hex[128] =
{
	-1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1,
	-1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1,
	-1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1,
	0, 1, 2, 3,  4, 5, 6, 7,  8, 9,-1,-1, -1,-1,-1,-1,
	-1,10,11,12, 13,14,15,-1, -1,-1,-1,-1, -1,-1,-1,-1,
	-1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1,
	-1,10,11,12, 13,14,15,-1, -1,-1,-1,-1, -1,-1,-1,-1,
	-1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1
};

# define HEXCHAR(c)  (((c) < 0 || (c) > 127) ? -1 : index_hex[(c)])

/*
**  MIME_FROMQP -- decode quoted printable string
**
**	Parameters:
**		infile -- input (encoded) string
**		outfile -- output string
**		maxlen -- size of output buffer
**
**	Returns:
**		-2 if decoding failure
**		-1 if infile completely decoded into outfile
**		>= 0 is the position in infile decoding
**			reached before maxlen was reached
*/

static int
mime_fromqp(infile, outfile, maxlen)
	unsigned char *infile;
	unsigned char **outfile;
	int maxlen;		/* Max # of chars allowed in outfile */
{
	int c1, c2;
	int nchar = 0;
	unsigned char *b;

	/* decrement by one for trailing '\0', at least one other char */
	if (--maxlen < 1)
		return 0;

	b = infile;
	while ((c1 = *infile++) != '\0' && nchar < maxlen)
	{
		if (c1 == '=')
		{
			if ((c1 = *infile++) == '\0')
				break;

			if (c1 == '\n' || (c1 = HEXCHAR(c1)) == -1)
			{
				/* ignore it and the rest of the buffer */
				return -2;
			}
			else
			{
				do
				{
					if ((c2 = *infile++) == '\0')
					{
						c2 = -1;
						break;
					}
				} while ((c2 = HEXCHAR(c2)) == -1);

				if (c2 == -1)
					break;
				nchar++;
				*(*outfile)++ = c1 << 4 | c2;
			}
		}
		else
		{
			nchar++;
			*(*outfile)++ = c1;
			if (c1 == '\n')
				break;
		}
	}
	*(*outfile)++ = '\0';
	if (nchar >= maxlen)
		return (infile - b - 1);
	return -1;
}
#endif /* MIME7TO8 */
@


1.5
log
@merge
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003, 2006, 2013 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Id: mime.c,v 8.148 2013/03/12 15:24:53 ca Exp $")
@


1.4
log
@Replace “$Sendmail: ” with “$Id: ” (the latter is used by upstream)
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003, 2006 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Id: mime.c,v 8.147 2007/09/26 23:29:11 ca Exp $")
d110 1
d326 2
a327 2
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof(buf))
			!= NULL)
d332 1
a332 1
			if (!putxline(buf, strlen(buf), mci,
d370 2
a371 2
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof(buf))
			!= NULL)
d376 1
a376 1
			if (!putxline(buf, strlen(buf), mci,
d447 2
a448 2
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof(buf))
			!= NULL)
d452 1
a452 1
			for (p = buf; *p != '\0'; p++)
d456 1
a456 1
				if (bitset(0200, *p))
d526 2
a527 2
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof(buf))
			!= NULL)
d535 1
a535 1
			if (!putxline(buf, strlen(buf), mci,
d1037 1
a1037 1
	int pxflags;
d1070 2
a1071 2
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof(buf))
			!= NULL)
d1073 1
a1073 1
			if (!putline(buf, mci))
d1181 1
a1181 1
				   sizeof(buf)) != NULL)
@


1.3
log
@merge and reduce diffs against upstream
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: mime.c,v 8.147 2007/09/26 23:29:11 ca Exp $")
@


1.2
log
@upgrade from sendmail 8.14.1 to 8.14.2 ourselves:
> From donotreply@@lists.sendmail.org Fri Nov  2 02:46:04 2007
> From: Claus Assmann <donotreply@@lists.sendmail.org>
Message-ID: <200711020234.lA22YPul046763@@lists.sendmail.org>
To: sendmail-announce@@sendmail.org
Date: Thu, 1 Nov 2007 19:34:25 -0700 (PDT)
Subject: sendmail 8.14.2 available

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Sendmail, Inc., and the Sendmail Consortium announce the availability
of sendmail 8.14.2 which fixes some problems, e.g.,

- - an important bug in the milter function smfi_chgfrom() which could
  cause the loss of a message body.
- - the handling of queued messages with 8 bit characters in From:
  or To: header which could be "mistaken" for internal control
  characters during a queue run and trigger various consistency checks.
- - the handling of lines longer than MAXLINE-1 characters in certain
  cases.

A complete list of changes can be found in the release notes (see
below).

Please send bug reports and general feedback to one of the addresses
listed at: http://www.sendmail.org/email-addresses.html

The version can be found at

ftp://ftp.sendmail.org/pub/sendmail/sendmail.8.14.2.tar.gz
ftp://ftp.sendmail.org/pub/sendmail/sendmail.8.14.2.tar.gz.sig
ftp://ftp.sendmail.org/pub/sendmail/sendmail.8.14.2.tar.Z
ftp://ftp.sendmail.org/pub/sendmail/sendmail.8.14.2.tar.Z.sig

MD5 signatures:
cf784b9f20c32949ae1f38f3eae29875 sendmail.8.14.2.tar.Z
f788d6986f12a81ac958195b045a529d sendmail.8.14.2.tar.Z.sig
1c1472365344ca8061d6453c43c9a831 sendmail.8.14.2.tar.gz
2ae4b6175a08e8a6cda992db20141d81 sendmail.8.14.2.tar.gz.sig

You either need the first two files or the third and fourth, i.e.,
the gzip'ed version or the compressed version and the corresponding
sig file.  The PGP signature was created using the Sendmail Signing
Key/2007, available on the web site (http://www.sendmail.org/) or
on the public key servers.

Since sendmail 8.11 and later includes hooks to cryptography, the
following information from OpenSSL applies to sendmail as well.

   PLEASE REMEMBER THAT EXPORT/IMPORT AND/OR USE OF STRONG CRYPTOGRAPHY
   SOFTWARE, PROVIDING CRYPTOGRAPHY HOOKS OR EVEN JUST COMMUNICATING
   TECHNICAL DETAILS ABOUT CRYPTOGRAPHY SOFTWARE IS ILLEGAL IN SOME
   PARTS OF THE WORLD.  SO, WHEN YOU IMPORT THIS PACKAGE TO YOUR
   COUNTRY, RE-DISTRIBUTE IT FROM THERE OR EVEN JUST EMAIL TECHNICAL
   SUGGESTIONS OR EVEN SOURCE PATCHES TO THE AUTHOR OR OTHER PEOPLE
   YOU ARE STRONGLY ADVISED TO PAY CLOSE ATTENTION TO ANY EXPORT/IMPORT
   AND/OR USE LAWS WHICH APPLY TO YOU. THE AUTHORS ARE NOT LIABLE FOR
   ANY VIOLATIONS YOU MAKE HERE. SO BE CAREFUL, IT IS YOUR RESPONSIBILITY.


			SENDMAIL RELEASE NOTES
      $Id: RELEASE_NOTES,v 8.1909 2007/10/31 16:04:13 ca Exp $


This listing shows the version of the sendmail binary, the version
of the sendmail configuration files, the date of release, and a
summary of the changes in that release.

8.14.2/8.14.2	2007/11/01
	If a message was queued and it contained 8 bit characters in
		a From: or To: header, then those characters could be
		"mistaken" for internal control characters during a queue
		run and trigger various consistency checks.  Problem
		noted by Neil Rickert of Northern Illinois University.
	If MaxMimeHeaderLength is set to a value greater than 0 (which
		it is by default) then even if the Linelimit parameter
		is 0, sendmail corrupted in the non-transfer-encoding
		case every MAXLINE-1 characters.  Patch from John Gardiner
		Myers of Proofpoint.
	Setting the suboption DeliveryMode for DaemonPortOptions did not
		work in earlier 8.14 versions.
	Note: DeliveryMode=interactive is silently converted to
		background if a milter can reject or delete a recipient.
		Prior to 8.14 this happened only if milter could delete
		recipients.
	ClientRate should trigger when the limit was exceeded (as
		documented), not when it was reached.  Patch from
		John Beck of Sun Microsystems.
	Force a queue run for -qGqueuegroup even if no runners are
		specified (R=0) and forking (F=f) is requested.
	When multiple results are requested for a DNS map lookup
		(-z and -Z), return only those that are relevant for
		the query (not also those in the "additional section".)
	If the message transfer time to sendmail (when acting as server)
		exceeds Timeout.queuewarn or Timeout.queuereturn and
		the message is refused (by a milter), sendmail previously
		created a delivery status notification (DSN).  Patch
		from Doug Heath of The Hertz Corporation.
	A code change in Cyrus-SASL 2.1.22 for sasl_decode64() requires
		the MTA to deal with some input (i.e., "=") itself.
		Problem noted by Eliot Lear.
	sendmail counted a delivery as successful if PIPELINING is
		compiled in but not offered by the server and the
		delivery failed temporarily.  Patch from Werner Wiethege.
	If getting the result of an LDAP query times out then close the
		map so it will be reopened on the next lookup.  This
		should help "failover" configurations that specify more
		than one LDAP server.
	If check_compat returns $#discard then a "savemail panic" could
		be triggered under some circumstances (e.g., requiring
		a system which does not have the compile time flag
		HASFLOCK set). Based on patch by Motonori Nakamura
		of National Institute of Informatics, Japan.
	If a milter rejected a recipient, the count for nrcpts= in the
		logfile entry might have been wrong.  Problem found by
		Petra Humann of TU Dresden.
	If a milter invoked smfi_chgfrom() where ESMTP arguments are not
		NULL, the message body was lost.  Patch from Motonori
		Nakamura of National Institute of Informatics, Japan.
	sendmail(8) had a bogus space in -qGname.  Patch from Peng Haitao.
	CONTRIB: buildvirtuser: Preserve ownership and permissions when
		replacing files.
	CONTRIB: buildvirtuser: Skip dot-files (e.g., .cvsignore) when
		reading the /etc/mail/virtusers/ directory.
	CONTRIB: buildvirtuser: Emit warnings instead of exiting where
		appropriate.
	LIBMILTER: Fix ABI backwards compatibility so milters compiled
		against an older libmilter.so shared library can use an
		8.14 libmilter.so shared library.
	LIBMILTER: smfi_version() did not properly extract the patchlevel
		from the version number, however, the returned value was
		correct for the current libmilter version.

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.5 (OpenBSD)

iQCVAwUBRyqEOs8etQMiMnoBAQKNdQP/cQKfjVP7qTi0Ol/OgR7AnvCaerCxiQ5J
y1uxjwXs2s+RemX0u5a4c0agoLscTKU5Ot6uzOdvKvZd0/unr/IkzuXZBF9LsnlZ
X1wS4GXQDXKDfazvwdwOUgxkthMZU1TiVFj/GH5TOfHqVUO5Ho/yRfAQoAn3taFc
5jeg+A3+M9M=
=DJHS
-----END PGP SIGNATURE-----
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: mime.c,v 8.146 2006/08/16 16:52:11 ca Exp $")
@


1.2.2.1
log
@MFC sendmail update to 8.14.3

agreed bsiegert@@
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: mime.c,v 8.147 2007/09/26 23:29:11 ca Exp $")
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: mime.c,v 8.137 2004/09/02 21:37:26 ca Exp $")
d83 1
d90 1
d100 1
a100 1
mime8to7(mci, header, e, boundaries, flags)
d106 1
d127 12
d154 1
a154 1
	    (pvp = prescan(p, '\0', pvpbuf, sizeof pvpbuf, NULL,
d162 1
a162 1
		cataddr(pvp, NULL, buf, sizeof buf, '\0');
d176 1
a176 1
	    (pvp = prescan(p, '\0', pvpbuf, sizeof pvpbuf, NULL,
d230 1
a230 1
	/* don't propogate some flags more than one level into the message */
d241 1
a241 1
	(void) sm_snprintf(buf, sizeof buf, "%.100s/%.100s", type, subtype);
d259 3
a261 1
	    (!bitset(M87F_NO8BIT, flags) || bitset(M87F_NO8TO7, flags)))
d286 1
a286 1
		if (sm_strlcpy(bbuf, p, sizeof bbuf) >= sizeof bbuf)
d305 4
a308 1
			usrerr("mime8to7: multipart nesting boundary too deep");
d311 1
a311 1
			e->e_flags |= EF_DONT_MIME;
d321 2
a322 1
		putline("", mci);
d325 1
a325 1
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof buf)
d331 3
a333 2
			putxline(buf, strlen(buf), mci,
				 PXLF_MAPFROM|PXLF_STRIP8BIT);
d343 3
a345 2
			(void) sm_strlcpyn(buf, sizeof buf, 2, "--", bbuf);
			putline(buf, mci);
d351 2
a352 1
			putheader(mci, hdr, e, flags);
d355 8
a362 4
			bt = mime8to7(mci, hdr, e, boundaries, flags);
		}
		(void) sm_strlcpyn(buf, sizeof buf, 3, "--", bbuf, "--");
		putline(buf, mci);
d369 1
a369 1
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof buf)
d375 3
a377 2
			putxline(buf, strlen(buf), mci,
				 PXLF_MAPFROM|PXLF_STRIP8BIT);
d397 2
a398 1
		if (!wordinclass(subtype, 's'))
d406 2
a407 1
			putline("", mci);
d413 2
a414 1
			putheader(mci, hdr, e, flags);
d418 5
a422 3
			    !bitset(M87F_NO8TO7, flags))
				putline("MIME-Version: 1.0", mci);
			bt = mime8to7(mci, hdr, e, boundaries, flags);
d446 1
a446 1
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof buf)
d515 1
a515 1
			(void) sm_snprintf(buf, sizeof buf,
d517 2
a518 1
			putline(buf, mci);
d522 2
a523 1
		putline("", mci);
d525 1
a525 1
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof buf)
d528 9
a536 4
			bt = mimeboundary(buf, boundaries);
			if (bt != MBT_NOTSEP)
				break;
			putline(buf, mci);
d549 3
a551 2
		putline("Content-Transfer-Encoding: base64", mci);
		(void) sm_snprintf(buf, sizeof buf,
d554 2
a555 2
		putline(buf, mci);
		putline("", mci);
d563 2
a564 1
				putline(buf, mci);
d594 2
a595 1
		putline(buf, mci);
d618 4
a621 2
		putline("Content-Transfer-Encoding: quoted-printable", mci);
		(void) sm_snprintf(buf, sizeof buf,
d624 2
a625 2
		putline(buf, mci);
		putline("", mci);
d647 2
a648 1
				putline(buf, mci);
d677 2
a678 1
				putline(buf, mci);
d716 2
a717 1
			putline(buf, mci);
d724 3
d805 1
a805 1
		while (bp < &buf[sizeof buf - 2] &&
d823 1
a823 1
		if (bp < &buf[sizeof buf - 2] && c != SM_IO_EOF)
d1013 1
a1013 1
**		none.
d1030 1
a1030 1
void
d1048 1
a1048 1
	    (pvp = prescan(p, '\0', pvpbuf, sizeof pvpbuf, NULL,
d1061 1
a1061 1
			(void) sm_snprintf(buf, sizeof buf,
d1063 2
a1064 1
			putline(buf, mci);
d1066 2
a1067 1
		putline("", mci);
d1069 1
a1069 1
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof buf)
d1071 5
a1075 2
			putline(buf, mci);
		return;
d1077 1
a1077 1
	cataddr(pvp, NULL, buf, sizeof buf, '\0');
d1081 3
a1083 2
	putline("Content-Transfer-Encoding: 8bit", mci);
	(void) sm_snprintf(buf, sizeof buf,
d1086 2
a1087 2
	putline(buf, mci);
	putline("", mci);
d1151 2
a1152 1
			putxline((char *) fbuf, fbufp - fbuf, mci, pxflags); \
d1180 1
a1180 1
				   sizeof buf) != NULL)
d1189 5
a1193 2
				putxline((char *) fbuf, fbufp - fbuf - 1, mci,
					 pxflags);
d1209 2
a1210 1
		putxline((char *) fbuf, fbufp - fbuf, mci, pxflags);
d1220 2
a1221 1
	putline("", mci);
d1225 4
@


1.1.127.1
log
@Import Sendmail 8.14.3, suitably stripped down by the not yet committed
contrib/samples/import-3rdpty,v 1.35; we have some new and renamed files
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003, 2006 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Id: mime.c,v 8.147 2007/09/26 23:29:11 ca Exp $")
a82 1
**		level -- recursion level.
a88 1
**		  SM_IO_EOF -- I/O error occurred
d98 1
a98 1
mime8to7(mci, header, e, boundaries, flags, level)
a103 1
	int level;
a123 12
	if (level > MAXMIMENESTING)
	{
		if (!bitset(EF_TOODEEP, e->e_flags))
		{
			if (tTd(43, 4))
				sm_dprintf("mime8to7: too deep, level=%d\n",
					   level);
			usrerr("mime8to7: recursion level %d exceeded",
				level);
			e->e_flags |= EF_DONT_MIME|EF_TOODEEP;
		}
	}
d139 1
a139 1
	    (pvp = prescan(p, '\0', pvpbuf, sizeof(pvpbuf), NULL,
d147 1
a147 1
		cataddr(pvp, NULL, buf, sizeof(buf), '\0', false);
d161 1
a161 1
	    (pvp = prescan(p, '\0', pvpbuf, sizeof(pvpbuf), NULL,
d215 1
a215 1
	/* don't propagate some flags more than one level into the message */
d226 1
a226 1
	(void) sm_snprintf(buf, sizeof(buf), "%.100s/%.100s", type, subtype);
d244 1
a244 3
	    (!bitset(M87F_NO8BIT, flags) || bitset(M87F_NO8TO7, flags)) &&
	    !bitset(EF_TOODEEP, e->e_flags)
	   )
d269 1
a269 1
		if (sm_strlcpy(bbuf, p, sizeof(bbuf)) >= sizeof(bbuf))
d288 1
a288 4
			if (tTd(43, 4))
				sm_dprintf("mime8to7: too deep, i=%d\n", i);
			if (!bitset(EF_TOODEEP, e->e_flags))
				usrerr("mime8to7: multipart nesting boundary too deep");
d291 1
a291 1
			e->e_flags |= EF_DONT_MIME|EF_TOODEEP;
d301 1
a301 2
		if (!putline("", mci))
			goto writeerr;
d304 1
a304 1
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof(buf))
d310 2
a311 3
			if (!putxline(buf, strlen(buf), mci,
					PXLF_MAPFROM|PXLF_STRIP8BIT))
				goto writeerr;
d321 2
a322 3
			(void) sm_strlcpyn(buf, sizeof(buf), 2, "--", bbuf);
			if (!putline(buf, mci))
				goto writeerr;
d328 1
a328 2
			if (!putheader(mci, hdr, e, flags))
				goto writeerr;
d331 4
a334 8
			bt = mime8to7(mci, hdr, e, boundaries, flags,
				      level + 1);
			if (bt == SM_IO_EOF)
				goto writeerr;
		}
		(void) sm_strlcpyn(buf, sizeof(buf), 3, "--", bbuf, "--");
		if (!putline(buf, mci))
			goto writeerr;
d341 1
a341 1
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof(buf))
d347 2
a348 3
			if (!putxline(buf, strlen(buf), mci,
					PXLF_MAPFROM|PXLF_STRIP8BIT))
				goto writeerr;
d368 1
a368 2
		if (!wordinclass(subtype, 's') ||
		    bitset(EF_TOODEEP, e->e_flags))
d376 1
a376 2
			if (!putline("", mci))
				goto writeerr;
d382 1
a382 2
			if (!putheader(mci, hdr, e, flags))
				goto writeerr;
d386 3
a388 5
			    !bitset(M87F_NO8TO7, flags) &&
			    !putline("MIME-Version: 1.0", mci))
				goto writeerr;
			bt = mime8to7(mci, hdr, e, boundaries, flags,
				      level + 1);
d412 1
a412 1
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof(buf))
d481 1
a481 1
			(void) sm_snprintf(buf, sizeof(buf),
d483 1
a483 2
			if (!putline(buf, mci))
				goto writeerr;
d487 1
a487 2
		if (!putline("", mci))
			goto writeerr;
d489 1
a489 1
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof(buf))
d492 4
a495 9
			if (!bitset(MCIF_INLONGLINE, mci->mci_flags))
			{
				bt = mimeboundary(buf, boundaries);
				if (bt != MBT_NOTSEP)
					break;
			}
			if (!putxline(buf, strlen(buf), mci,
				      PXLF_MAPFROM|PXLF_NOADDEOL))
				goto writeerr;
d508 2
a509 3
		if (!putline("Content-Transfer-Encoding: base64", mci))
			goto writeerr;
		(void) sm_snprintf(buf, sizeof(buf),
d512 2
a513 2
		if (!putline(buf, mci) || !putline("", mci))
			goto writeerr;
d521 1
a521 2
				if (!putline(buf, mci))
					goto writeerr;
d551 1
a551 2
		if (!putline(buf, mci))
			goto writeerr;
d574 2
a575 4
		if (!putline("Content-Transfer-Encoding: quoted-printable",
				mci))
			goto writeerr;
		(void) sm_snprintf(buf, sizeof(buf),
d578 2
a579 2
		if (!putline(buf, mci) || !putline("", mci))
			goto writeerr;
d601 1
a601 2
				if (!putline(buf, mci))
					goto writeerr;
d630 1
a630 2
				if (!putline(buf, mci))
					goto writeerr;
d668 1
a668 2
			if (!putline(buf, mci))
				goto writeerr;
a674 3

  writeerr:
	return SM_IO_EOF;
d753 1
a753 1
		while (bp < &buf[sizeof(buf) - 2] &&
d771 1
a771 1
		if (bp < &buf[sizeof(buf) - 2] && c != SM_IO_EOF)
d961 1
a961 1
**		true iff body was written successfully
d978 1
a978 1
bool
d996 1
a996 1
	    (pvp = prescan(p, '\0', pvpbuf, sizeof(pvpbuf), NULL,
d1009 1
a1009 1
			(void) sm_snprintf(buf, sizeof(buf),
d1011 1
a1011 2
			if (!putline(buf, mci))
				goto writeerr;
d1013 1
a1013 2
		if (!putline("", mci))
			goto writeerr;
d1015 1
a1015 1
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof(buf))
d1017 2
a1018 5
		{
			if (!putline(buf, mci))
				goto writeerr;
		}
		return true;
d1020 1
a1020 1
	cataddr(pvp, NULL, buf, sizeof(buf), '\0', false);
d1024 2
a1025 3
	if (!putline("Content-Transfer-Encoding: 8bit", mci))
		goto writeerr;
	(void) sm_snprintf(buf, sizeof(buf),
d1028 2
a1029 2
	if (!putline(buf, mci) || !putline("", mci))
		goto writeerr;
d1093 1
a1093 2
			if (!putxline((char *) fbuf, fbufp - fbuf, mci, pxflags)) \
				goto writeerr;				\
d1121 1
a1121 1
				   sizeof(buf)) != NULL)
d1130 2
a1131 5
			{
				if (!putxline((char *) fbuf, fbufp - fbuf - 1,
						mci, pxflags))
					goto writeerr;
			}
d1147 1
a1147 2
		if (!putxline((char *) fbuf, fbufp - fbuf, mci, pxflags))
			goto writeerr;
d1157 1
a1157 2
	if (!putline("", mci))
		goto writeerr;
a1160 4
	return true;

  writeerr:
	return false;
@


1.1.127.2
log
@Update
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003, 2006, 2013 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Id: mime.c,v 8.148 2013/03/12 15:24:53 ca Exp $")
a109 1
	int blen;
d325 2
a326 2
		while ((blen = sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf,
					sizeof(buf))) >= 0)
d331 1
a331 1
			if (!putxline(buf, blen, mci,
d369 2
a370 2
		while ((blen = sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf,
					sizeof(buf))) >= 0)
d375 1
a375 1
			if (!putxline(buf, blen, mci,
d446 2
a447 2
		while ((blen = sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf,
					sizeof(buf))) >= 0)
d451 1
a451 1
			for (i = 0; i < blen; i++)
d455 1
a455 1
				if (bitset(0200, buf[i]))
d525 2
a526 2
		while ((blen = sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf,
					sizeof(buf))) >= 0)
d534 1
a534 1
			if (!putxline(buf, blen, mci,
d1036 1
a1036 1
	int pxflags, blen;
d1069 2
a1070 2
		while ((blen = sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf,
					sizeof(buf))) >= 0)
d1072 1
a1072 1
			if (!putxline(buf, blen, mci, PXLF_MAPFROM))
d1180 1
a1180 1
				   sizeof(buf)) >= 0)
@


1.1.127.3
log
@Import sendmail 8.14.9
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003, 2006, 2013 Proofpoint, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Id: mime.c,v 8.149 2013-11-22 20:51:56 ca Exp $")
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.1.2.1
log
@MFC most of the recent sendmail updates to MirOS #8-stable
agreed bsiegert@@

This also changes the LOCALBASE stuff, links libmilter not
against LDAP, etc. but doesn't install the FreeBSD 6 confs
nor a shared libmilter in order to pass a no-files-diff:

tg@@maou:/usr/src/gnu/usr.sbin/sendmail $ sudo find / -ls | sort -k11 >~/x1
tg@@maou:/usr/src/gnu/usr.sbin/sendmail $ sudo make install
tg@@maou:/usr/src/gnu/usr.sbin/sendmail/cf/cf $ sudo make distribution
tg@@maou:/usr/src/gnu/usr.sbin/sendmail/cf/cf $ sudo find / -ls | sort -k11 | diff -u ~/x1 - | less

Note: files in /etc/mail/ are also changed, this affects the etc8.ngz set
on fresh installs and cannot(!) be automatically upgraded!
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: mime.c,v 8.139 2006/03/01 18:07:45 ca Exp $")
a88 1
**		  SM_IO_EOF -- I/O error occurred
d301 1
a301 2
		if (!putline("", mci))
			goto writeerr;
d310 2
a311 3
			if (!putxline(buf, strlen(buf), mci,
					PXLF_MAPFROM|PXLF_STRIP8BIT))
				goto writeerr;
d322 1
a322 2
			if (!putline(buf, mci))
				goto writeerr;
d328 1
a328 2
			if (!putheader(mci, hdr, e, flags))
				goto writeerr;
a331 2
			if (bt == SM_IO_EOF)
				goto writeerr;
d334 1
a334 2
		if (!putline(buf, mci))
			goto writeerr;
d347 2
a348 3
			if (!putxline(buf, strlen(buf), mci,
					PXLF_MAPFROM|PXLF_STRIP8BIT))
				goto writeerr;
d376 1
a376 2
			if (!putline("", mci))
				goto writeerr;
d382 1
a382 2
			if (!putheader(mci, hdr, e, flags))
				goto writeerr;
d386 2
a387 3
			    !bitset(M87F_NO8TO7, flags) &&
			    !putline("MIME-Version: 1.0", mci))
				goto writeerr;
d483 1
a483 2
			if (!putline(buf, mci))
				goto writeerr;
d487 1
a487 2
		if (!putline("", mci))
			goto writeerr;
d495 1
a495 2
			if (!putline(buf, mci))
				goto writeerr;
d508 1
a508 2
		if (!putline("Content-Transfer-Encoding: base64", mci))
			goto writeerr;
d512 2
a513 2
		if (!putline(buf, mci) || !putline("", mci))
			goto writeerr;
d521 1
a521 2
				if (!putline(buf, mci))
					goto writeerr;
d551 1
a551 2
		if (!putline(buf, mci))
			goto writeerr;
d574 1
a574 3
		if (!putline("Content-Transfer-Encoding: quoted-printable",
				mci))
			goto writeerr;
d578 2
a579 2
		if (!putline(buf, mci) || !putline("", mci))
			goto writeerr;
d601 1
a601 2
				if (!putline(buf, mci))
					goto writeerr;
d630 1
a630 2
				if (!putline(buf, mci))
					goto writeerr;
d668 1
a668 2
			if (!putline(buf, mci))
				goto writeerr;
a674 3

  writeerr:
	return SM_IO_EOF;
d961 1
a961 1
**		true iff body was written successfully
d978 1
a978 1
bool
d1011 1
a1011 2
			if (!putline(buf, mci))
				goto writeerr;
d1013 1
a1013 2
		if (!putline("", mci))
			goto writeerr;
d1017 2
a1018 5
		{
			if (!putline(buf, mci))
				goto writeerr;
		}
		return true;
d1024 1
a1024 2
	if (!putline("Content-Transfer-Encoding: 8bit", mci))
		goto writeerr;
d1028 2
a1029 2
	if (!putline(buf, mci) || !putline("", mci))
		goto writeerr;
d1093 1
a1093 2
			if (!putxline((char *) fbuf, fbufp - fbuf, mci, pxflags)) \
				goto writeerr;				\
d1130 2
a1131 5
			{
				if (!putxline((char *) fbuf, fbufp - fbuf - 1,
						mci, pxflags))
					goto writeerr;
			}
d1147 1
a1147 2
		if (!putxline((char *) fbuf, fbufp - fbuf, mci, pxflags))
			goto writeerr;
d1157 1
a1157 2
	if (!putline("", mci))
		goto writeerr;
a1160 4
	return true;

  writeerr:
	return false;
@


1.1.1.2
log
@Update to Sendmail 8.13.6
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: mime.c,v 8.139 2006/03/01 18:07:45 ca Exp $")
a88 1
**		  SM_IO_EOF -- I/O error occurred
d301 1
a301 2
		if (!putline("", mci))
			goto writeerr;
d310 2
a311 3
			if (!putxline(buf, strlen(buf), mci,
					PXLF_MAPFROM|PXLF_STRIP8BIT))
				goto writeerr;
d322 1
a322 2
			if (!putline(buf, mci))
				goto writeerr;
d328 1
a328 2
			if (!putheader(mci, hdr, e, flags))
				goto writeerr;
a331 2
			if (bt == SM_IO_EOF)
				goto writeerr;
d334 1
a334 2
		if (!putline(buf, mci))
			goto writeerr;
d347 2
a348 3
			if (!putxline(buf, strlen(buf), mci,
					PXLF_MAPFROM|PXLF_STRIP8BIT))
				goto writeerr;
d376 1
a376 2
			if (!putline("", mci))
				goto writeerr;
d382 1
a382 2
			if (!putheader(mci, hdr, e, flags))
				goto writeerr;
d386 2
a387 3
			    !bitset(M87F_NO8TO7, flags) &&
			    !putline("MIME-Version: 1.0", mci))
				goto writeerr;
d483 1
a483 2
			if (!putline(buf, mci))
				goto writeerr;
d487 1
a487 2
		if (!putline("", mci))
			goto writeerr;
d495 1
a495 2
			if (!putline(buf, mci))
				goto writeerr;
d508 1
a508 2
		if (!putline("Content-Transfer-Encoding: base64", mci))
			goto writeerr;
d512 2
a513 2
		if (!putline(buf, mci) || !putline("", mci))
			goto writeerr;
d521 1
a521 2
				if (!putline(buf, mci))
					goto writeerr;
d551 1
a551 2
		if (!putline(buf, mci))
			goto writeerr;
d574 1
a574 3
		if (!putline("Content-Transfer-Encoding: quoted-printable",
				mci))
			goto writeerr;
d578 2
a579 2
		if (!putline(buf, mci) || !putline("", mci))
			goto writeerr;
d601 1
a601 2
				if (!putline(buf, mci))
					goto writeerr;
d630 1
a630 2
				if (!putline(buf, mci))
					goto writeerr;
d668 1
a668 2
			if (!putline(buf, mci))
				goto writeerr;
a674 3

  writeerr:
	return SM_IO_EOF;
d961 1
a961 1
**		true iff body was written successfully
d978 1
a978 1
bool
d1011 1
a1011 2
			if (!putline(buf, mci))
				goto writeerr;
d1013 1
a1013 2
		if (!putline("", mci))
			goto writeerr;
d1017 2
a1018 5
		{
			if (!putline(buf, mci))
				goto writeerr;
		}
		return true;
d1024 1
a1024 2
	if (!putline("Content-Transfer-Encoding: 8bit", mci))
		goto writeerr;
d1028 2
a1029 2
	if (!putline(buf, mci) || !putline("", mci))
		goto writeerr;
d1093 1
a1093 2
			if (!putxline((char *) fbuf, fbufp - fbuf, mci, pxflags)) \
				goto writeerr;				\
d1130 2
a1131 5
			{
				if (!putxline((char *) fbuf, fbufp - fbuf - 1,
						mci, pxflags))
					goto writeerr;
			}
d1147 1
a1147 2
		if (!putxline((char *) fbuf, fbufp - fbuf, mci, pxflags))
			goto writeerr;
d1157 1
a1157 2
	if (!putline("", mci))
		goto writeerr;
a1160 4
	return true;

  writeerr:
	return false;
@


1.1.1.3
log
@Yeah, another sendmail flaw *yawn*

And TNF knew it, a month ago!
@
text
@a82 1
**		level -- recursion level.
d99 1
a99 1
mime8to7(mci, header, e, boundaries, flags, level)
a104 1
	int level;
a124 12
	if (level > MAXMIMENESTING)
	{
		if (!bitset(EF_TOODEEP, e->e_flags))
		{
			if (tTd(43, 4))
				sm_dprintf("mime8to7: too deep, level=%d\n",
					   level);
			usrerr("mime8to7: recursion level %d exceeded",
				level);
			e->e_flags |= EF_DONT_MIME|EF_TOODEEP;
		}
	}
d245 1
a245 3
	    (!bitset(M87F_NO8BIT, flags) || bitset(M87F_NO8TO7, flags)) &&
	    !bitset(EF_TOODEEP, e->e_flags)
	   )
d289 1
a289 4
			if (tTd(43, 4))
				sm_dprintf("mime8to7: too deep, i=%d\n", i);
			if (!bitset(EF_TOODEEP, e->e_flags))
				usrerr("mime8to7: multipart nesting boundary too deep");
d292 1
a292 1
			e->e_flags |= EF_DONT_MIME|EF_TOODEEP;
d336 1
a336 2
			bt = mime8to7(mci, hdr, e, boundaries, flags,
				      level + 1);
d377 1
a377 2
		if (!wordinclass(subtype, 's') ||
		    bitset(EF_TOODEEP, e->e_flags))
d400 1
a400 2
			bt = mime8to7(mci, hdr, e, boundaries, flags,
				      level + 1);
@


1.1.1.4
log
@Import latest Sendmail
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2003, 2006 Sendmail, Inc. and its suppliers.
d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: mime.c,v 8.142.2.1 2006/05/23 01:32:08 ca Exp $")
d230 1
a230 1
	/* don't propagate some flags more than one level into the message */
@


1.1.1.5
log
@Import Sendmail 8.14.0 via OpenBSD
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: mime.c,v 8.146 2006/08/16 16:52:11 ca Exp $")
d154 1
a154 1
	    (pvp = prescan(p, '\0', pvpbuf, sizeof(pvpbuf), NULL,
d162 1
a162 1
		cataddr(pvp, NULL, buf, sizeof(buf), '\0', false);
d176 1
a176 1
	    (pvp = prescan(p, '\0', pvpbuf, sizeof(pvpbuf), NULL,
d241 1
a241 1
	(void) sm_snprintf(buf, sizeof(buf), "%.100s/%.100s", type, subtype);
d286 1
a286 1
		if (sm_strlcpy(bbuf, p, sizeof(bbuf)) >= sizeof(bbuf))
d325 1
a325 1
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof(buf))
d343 1
a343 1
			(void) sm_strlcpyn(buf, sizeof(buf), 2, "--", bbuf);
d360 1
a360 1
		(void) sm_strlcpyn(buf, sizeof(buf), 3, "--", bbuf, "--");
d369 1
a369 1
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof(buf))
d446 1
a446 1
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof(buf))
d515 1
a515 1
			(void) sm_snprintf(buf, sizeof(buf),
d525 1
a525 1
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof(buf))
d547 1
a547 1
		(void) sm_snprintf(buf, sizeof(buf),
d617 1
a617 1
		(void) sm_snprintf(buf, sizeof(buf),
d801 1
a801 1
		while (bp < &buf[sizeof(buf) - 2] &&
d819 1
a819 1
		if (bp < &buf[sizeof(buf) - 2] && c != SM_IO_EOF)
d1044 1
a1044 1
	    (pvp = prescan(p, '\0', pvpbuf, sizeof(pvpbuf), NULL,
d1057 1
a1057 1
			(void) sm_snprintf(buf, sizeof(buf),
d1065 1
a1065 1
		while (sm_io_fgets(e->e_dfp, SM_TIME_DEFAULT, buf, sizeof(buf))
d1073 1
a1073 1
	cataddr(pvp, NULL, buf, sizeof(buf), '\0', false);
d1079 1
a1079 1
	(void) sm_snprintf(buf, sizeof(buf),
d1176 1
a1176 1
				   sizeof(buf)) != NULL)
@


1.1.1.6
log
@OpenBSD finally has upgraded their sendmail, too…
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Sendmail: mime.c,v 8.147 2007/09/26 23:29:11 ca Exp $")
d528 4
a531 8
			if (!bitset(MCIF_INLONGLINE, mci->mci_flags))
			{
				bt = mimeboundary(buf, boundaries);
				if (bt != MBT_NOTSEP)
					break;
			}
			if (!putxline(buf, strlen(buf), mci,
				      PXLF_MAPFROM|PXLF_NOADDEOL))
@


1.1.1.6.2.1
log
@Replace “$Sendmail: ” with “$Id: ” (the latter is used by upstream)
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Id: mime.c,v 8.147 2007/09/26 23:29:11 ca Exp $")
@


1.1.1.7
log
@Replace “$Sendmail: ” with “$Id: ” (the latter is used by upstream)
@
text
@d17 1
a17 1
SM_RCSID("@@(#)$Id: mime.c,v 8.147 2007/09/26 23:29:11 ca Exp $")
@


