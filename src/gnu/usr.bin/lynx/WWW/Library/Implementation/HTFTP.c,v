head	1.9;
access;
symbols
	lynx-2_8_8dev_16:1.1.109.14
	lynx-2_8_8dev_15e:1.1.109.14
	lynx-2_8_8dev_15:1.1.109.13
	lynx-2_8_8dev_14:1.1.109.12
	lynx-2_8_8dev_12:1.1.109.11
	lynx-2_8_8dev_11:1.1.109.11
	lynx-2_8_8dev_10a:1.1.109.11
	lynx-2_8_8dev_7a:1.1.109.10
	lynx-2_8_8dev_7:1.1.109.10
	lynx-2_8_7rel_1:1.1.109.9
	lynx-2_8_7dev_12:1.1.109.8
	lynx-2_8_7dev_11a:1.1.109.7
	MIRBSD_10:1.1.109.6.0.2
	MIRBSD_10_BASE:1.1.109.6
	lynx-2_8_7dev_8:1.1.109.6
	lynx-2_8_7dev_7:1.1.109.6
	lynx-2_8_7dev_5:1.1.109.5
	lynx-2_8_7dev_2:1.1.109.4
	lynx-2_8_6pre_5:1.1.109.4
	lynx-2_8_6pre_4:1.1.109.3
	lynx-2_8_6pre_3:1.1.109.3
	MIRBSD_9_BASE:1.1.109.3
	lynx-2_8_6dev_18c:1.1.109.3
	lynx-2_8_6dev_18:1.1.109.3
	MIRBSD_8:1.1.109.2.0.2
	MIRBSD_8_BASE:1.1.109.2
	lynx-2_8_6dev_16:1.1.109.2
	lynx:1.1.109;
locks; strict;
comment	@ * @;


1.9
date	2013.05.18.14.59.33;	author tg;	state Exp;
branches;
next	1.8;
commitid	1005197975F6A2B23A5;

1.8
date	2012.12.31.21.19.43;	author tg;	state Exp;
branches;
next	1.7;
commitid	10050E2017B122CED3C;

1.7
date	2012.08.23.18.36.06;	author tg;	state Exp;
branches;
next	1.6;
commitid	1005036781D23C1E744;

1.6
date	2012.02.19.19.37.53;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004F414F917991F461;

1.5
date	2007.08.03.15.20.25;	author tg;	state Exp;
branches;
next	1.4;
commitid	10046B347BE53E79AC8;

1.4
date	2007.05.20.09.43.22;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004650182E2FFFB588;

1.3
date	2006.10.02.23.12.16;	author tg;	state Exp;
branches;
next	1.2;
commitid	10045219CDF7E09CCE1;

1.2
date	2006.09.21.21.48.37;	author tg;	state Exp;
branches;
next	1.1;
commitid	100451308B24B1C2E71;

1.1
date	2005.03.27.22.11.54;	author tg;	state Exp;
branches
	1.1.109.1;
next	;

1.1.109.1
date	2005.03.27.22.11.54;	author tg;	state Exp;
branches;
next	1.1.109.2;

1.1.109.2
date	2005.06.22.11.11.40;	author tg;	state Exp;
branches;
next	1.1.109.3;
commitid	408242b94777c7d4;

1.1.109.3
date	2006.06.02.19.16.53;	author tg;	state Exp;
branches;
next	1.1.109.4;
commitid	10044808E727319C3F7;

1.1.109.4
date	2006.10.02.22.55.59;	author tg;	state Exp;
branches;
next	1.1.109.5;
commitid	100452198D23E36C6DC;

1.1.109.5
date	2007.05.19.22.29.37;	author tg;	state Exp;
branches;
next	1.1.109.6;
commitid	100464F7A1519624932;

1.1.109.6
date	2007.08.03.15.10.31;	author tg;	state Exp;
branches;
next	1.1.109.7;
commitid	10046B3450C0C128495;

1.1.109.7
date	2008.12.16.23.13.05;	author tg;	state Exp;
branches;
next	1.1.109.8;
commitid	100494835F965A87026;

1.1.109.8
date	2009.01.18.19.31.25;	author tg;	state Exp;
branches;
next	1.1.109.9;
commitid	1004973839C3B701938;

1.1.109.9
date	2009.08.09.14.37.47;	author tg;	state Exp;
branches;
next	1.1.109.10;
commitid	1004A7EDF4952738297;

1.1.109.10
date	2010.12.19.18.12.40;	author tg;	state Exp;
branches;
next	1.1.109.11;
commitid	1004D0E4B24304015D1;

1.1.109.11
date	2012.02.19.18.28.21;	author tg;	state Exp;
branches;
next	1.1.109.12;
commitid	1004F413EF328BF0E26;

1.1.109.12
date	2012.08.23.17.47.49;	author tg;	state Exp;
branches;
next	1.1.109.13;
commitid	10050366CBF479FD80F;

1.1.109.13
date	2012.12.31.21.09.47;	author tg;	state Exp;
branches;
next	1.1.109.14;
commitid	10050E1FF02228195F0;

1.1.109.14
date	2013.05.18.14.43.56;	author tg;	state Exp;
branches;
next	;
commitid	100519793BB3FCC7E2F;


desc
@@


1.9
log
@fastmerge
@
text
@/*
 * $LynxId: HTFTP.c,v 1.121 2013/05/06 00:09:50 tom Exp $
 *
 *			File Transfer Protocol (FTP) Client
 *			for a WorldWideWeb browser
 *			===================================
 *
 *	A cache of control connections is kept.
 *
 * Note: Port allocation
 *
 *	It is essential that the port is allocated by the system, rather
 *	than chosen in rotation by us (POLL_PORTS), or the following
 *	problem occurs.
 *
 *	It seems that an attempt by the server to connect to a port which has
 *	been used recently by a listen on the same socket, or by another
 *	socket this or another process causes a hangup of (almost exactly)
 *	one minute.  Therefore, we have to use a rotating port number.
 *	The problem remains that if the application is run twice in quick
 *	succession, it will hang for what remains of a minute.
 *
 * Authors
 *	TBL	Tim Berners-lee <timbl@@info.cern.ch>
 *	DD	Denis DeLaRoca 310 825-4580 <CSP1DWD@@mvs.oac.ucla.edu>
 *	LM	Lou Montulli <montulli@@ukanaix.cc.ukans.edu>
 *	FM	Foteos Macrides <macrides@@sci.wfeb.edu>
 * History:
 *	 2 May 91	Written TBL, as a part of the WorldWideWeb project.
 *	15 Jan 92	Bug fix: close() was used for NETCLOSE for control soc
 *	10 Feb 92	Retry if cached connection times out or breaks
 *	 8 Dec 92	Bug fix 921208 TBL after DD
 *	17 Dec 92	Anon FTP password now just WWWuser@@ suggested by DD
 *			fails on princeton.edu!
 *	27 Dec 93 (FM)	Fixed up so FTP now works with VMS hosts.  Path
 *			must be Unix-style and cannot include the device
 *			or top directory.
 *	?? ??? ?? (LM)	Added code to prompt and send passwords for non
 *			anonymous FTP
 *	25 Mar 94 (LM)	Added code to recognize different ftp server types
 *			and code to parse dates and sizes on most hosts.
 *	27 Mar 93 (FM)	Added code for getting dates and sizes on VMS hosts.
 *
 * Notes:
 *			Portions Copyright 1994 Trustees of Dartmouth College
 *			Code for recognizing different FTP servers and
 *			parsing "ls -l" output taken from Macintosh Fetch
 *			program with permission from Jim Matthews,
 *			Dartmouth Software Development Team.
 */

/*
 * BUGS:	@@@@@@	Limit connection cache size!
 * 		Error reporting to user.
 * 		400 & 500 errors are ack'ed by user with windows.
 * 		Use configuration file for user names
 * 
 *		Note for portability this version does not use select() and
 *		so does not watch the control and data channels at the
 *		same time.
 */

#include <HTUtils.h>

#include <HTAlert.h>

#include <HTFTP.h>		/* Implemented here */
#include <HTTCP.h>
#include <HTTP.h>
#include <HTFont.h>

#define REPEAT_PORT		/* Give the port number for each file */
#define REPEAT_LISTEN		/* Close each listen socket and open a new one */

/* define POLL_PORTS		 If allocation does not work, poll ourselves.*/
#define LISTEN_BACKLOG 2	/* Number of pending connect requests (TCP) */

#define FIRST_TCP_PORT	1024	/* Region to try for a listening port */
#define LAST_TCP_PORT	5999

#define LINE_LENGTH 256

#include <HTParse.h>
#include <HTAnchor.h>
#include <HTFile.h>		/* For HTFileFormat() */
#include <HTBTree.h>
#include <HTChunk.h>
#ifndef IPPORT_FTP
#define IPPORT_FTP	21
#endif /* !IPORT_FTP */

#include <LYUtils.h>
#include <LYGlobalDefs.h>
#include <LYStrings.h>
#include <LYLeaks.h>

typedef struct _connection {
    struct _connection *next;	/* Link on list         */
    unsigned long addr;		/* IP address           */
    int socket;			/* Socket number for communication */
    BOOL binary;		/* Binary mode? */
} connection;

/*		Hypertext object building machinery
*/
#include <HTML.h>

/*
 * socklen_t is the standard, but there are many pre-standard variants.
 * This ifdef works around a few of those cases.
 *
 * Information was obtained from header files on these platforms:
 *	AIX 4.3.2, 5.1
 *	HPUX 10.20, 11.00, 11.11
 *	IRIX64 6.5
 *	Tru64 4.0G, 4.0D, 5.1
 */
#if defined(SYS_IRIX64)
	/* IRIX64 6.5 socket.h may use socklen_t if SGI_SOURCE is not defined */
#  if _NO_XOPEN4 && _NO_XOPEN5
#    define LY_SOCKLEN socklen_t
#  elif _ABIAPI
#    define LY_SOCKLEN int
#  elif _XOPEN5
#    if (_MIPS_SIM != _ABIO32)
#      define LY_SOCKLEN socklen_t
#    else
#      define LY_SOCKLEN int
#    endif
#  else
#    define LY_SOCKLEN size_t
#  endif
#elif defined(SYS_HPUX)
#  if defined(_XOPEN_SOURCE_EXTENDED) && defined(SO_PROTOTYPE)
#    define LY_SOCKLEN socklen_t
#  else	/* HPUX 10.20, etc. */
#    define LY_SOCKLEN int
#  endif
#elif defined(SYS_TRU64)
#  if defined(_POSIX_PII_SOCKET)
#    define LY_SOCKLEN socklen_t
#  elif defined(_XOPEN_SOURCE_EXTENDED)
#    define LY_SOCKLEN size_t
#  else
#    define LY_SOCKLEN int
#  endif
#else
#  define LY_SOCKLEN socklen_t
#endif

#define PUTC(c)      (*target->isa->put_character) (target, c)
#define PUTS(s)      (*target->isa->put_string)    (target, s)
#define START(e)     (*target->isa->start_element) (target, e, 0, 0, -1, 0)
#define END(e)       (*target->isa->end_element)   (target, e, 0)
#define FREE_TARGET  (*target->isa->_free)         (target)
#define ABORT_TARGET (*target->isa->_free)         (target)

#define TRACE_ENTRY(tag, entry_info) \
    CTRACE((tfp, "HTFTP: %s filename: %s  date: %s  size: %" PRI_off_t "\n", \
	    tag, \
	    entry_info->filename, \
	    NonNull(entry_info->date), \
	    entry_info->size))

struct _HTStructured {
    const HTStructuredClass *isa;
    /* ... */
};

/*	Global Variables
 *	---------------------
 */
int HTfileSortMethod = FILE_BY_NAME;

#ifndef DISABLE_FTP		/*This disables everything to end-of-file */
static char ThisYear[8];
static char LastYear[8];
static int TheDate;
static BOOLEAN HaveYears = FALSE;

/*	Module-Wide Variables
 *	---------------------
 */
static connection *connections = NULL;	/* Linked list of connections */
static char response_text[LINE_LENGTH + 1];	/* Last response from ftp host */
static connection *control = NULL;	/* Current connection */
static int data_soc = -1;	/* Socket for data transfer =invalid */
static char *user_entered_password = NULL;
static char *last_username_and_host = NULL;

/*
 * Some ftp servers are known to have a broken implementation of RETR.  If
 * asked to retrieve a directory, they get confused and fail subsequent
 * commands such as CWD and LIST.
 */
static int Broken_RETR = FALSE;

/*
 * Some ftp servers are known to have a broken implementation of EPSV.  The
 * server will hang for a long time when we attempt to connect after issuing
 * this command.
 */
#ifdef INET6
static int Broken_EPSV = FALSE;
#endif

typedef enum {
    GENERIC_SERVER
    ,MACHTEN_SERVER
    ,UNIX_SERVER
    ,VMS_SERVER
    ,CMS_SERVER
    ,DCTS_SERVER
    ,TCPC_SERVER
    ,PETER_LEWIS_SERVER
    ,NCSA_SERVER
    ,WINDOWS_NT_SERVER
    ,WINDOWS_2K_SERVER
    ,MS_WINDOWS_SERVER
    ,MSDOS_SERVER
    ,APPLESHARE_SERVER
    ,NETPRESENZ_SERVER
    ,DLS_SERVER
} eServerType;

static eServerType server_type = GENERIC_SERVER;	/* the type of ftp host */
static int unsure_type = FALSE;	/* sure about the type? */
static BOOLEAN use_list = FALSE;	/* use the LIST command? */

static int interrupted_in_next_data_char = FALSE;

#ifdef POLL_PORTS
static PortNumber port_number = FIRST_TCP_PORT;
#endif /* POLL_PORTS */

static BOOL have_socket = FALSE;	/* true if master_socket is valid */
static unsigned master_socket;	/* Listening socket = invalid */

static char port_command[255];	/* Command for setting the port */
static fd_set open_sockets;	/* Mask of active channels */
static unsigned num_sockets;	/* Number of sockets to scan */
static PortNumber passive_port;	/* Port server specified for data */

#define NEXT_CHAR HTGetCharacter()	/* Use function in HTFormat.c */

#define DATA_BUFFER_SIZE 2048
static char data_buffer[DATA_BUFFER_SIZE];	/* Input data buffer */
static char *data_read_pointer;
static char *data_write_pointer;

#define NEXT_DATA_CHAR next_data_char()
static int close_connection(connection * con);

#ifndef HAVE_ATOLL
off_t LYatoll(const char *value)
{
    off_t result = 0;

    while (*value != '\0') {
	result = (result * 10) + (off_t) (*value++ - '0');
    }
    return result;
}
#endif

#ifdef LY_FIND_LEAKS
/*
 *  This function frees module globals. - FM
 */
static void free_FTPGlobals(void)
{
    FREE(user_entered_password);
    FREE(last_username_and_host);
    if (control) {
	if (control->socket != -1)
	    close_connection(control);
	FREE(control);
    }
}
#endif /* LY_FIND_LEAKS */

/* PUBLIC						HTVMS_name()
 *		CONVERTS WWW name into a VMS name
 * ON ENTRY:
 *	nn		Node Name (optional)
 *	fn		WWW file name
 *
 * ON EXIT:
 *	returns		vms file specification
 *
 * Bug: Returns pointer to static -- non-reentrant
 */
char *HTVMS_name(const char *nn,
		 const char *fn)
{
    /* We try converting the filename into Files-11 syntax.  That is, we assume
     * first that the file is, like us, on a VMS node.  We try remote (or
     * local) DECnet access.  Files-11, VMS, VAX and DECnet are trademarks of
     * Digital Equipment Corporation.  The node is assumed to be local if the
     * hostname WITHOUT DOMAIN matches the local one.  @@@@@@
     */
    static char *vmsname;
    char *filename = (char *) malloc(strlen(fn) + 1);
    char *nodename = (char *) malloc(strlen(nn) + 2 + 1);	/* Copies to hack */
    char *second;		/* 2nd slash */
    char *last;			/* last slash */

    const char *hostname = HTHostName();

    if (!filename || !nodename)
	outofmem(__FILE__, "HTVMSname");

    assert(filename != NULL);
    assert(nodename != NULL);

    strcpy(filename, fn);
    strcpy(nodename, "");	/* On same node?  Yes if node names match */
    if (StrNCmp(nn, "localhost", 9)) {
	const char *p;
	const char *q;

	for (p = hostname, q = nn;
	     *p && *p != '.' && *q && *q != '.'; p++, q++) {
	    if (TOUPPER(*p) != TOUPPER(*q)) {
		char *r;

		strcpy(nodename, nn);
		r = strchr(nodename, '.');	/* Mismatch */
		if (r)
		    *r = '\0';	/* Chop domain */
		strcat(nodename, "::");		/* Try decnet anyway */
		break;
	    }
	}
    }

    second = strchr(filename + 1, '/');		/* 2nd slash */
    last = strrchr(filename, '/');	/* last slash */

    if (!second) {		/* Only one slash */
	HTSprintf0(&vmsname, "%s%s", nodename, filename + 1);
    } else if (second == last) {	/* Exactly two slashes */
	*second = '\0';		/* Split filename from disk */
	HTSprintf0(&vmsname, "%s%s:%s", nodename, filename + 1, second + 1);
	*second = '/';		/* restore */
    } else {			/* More than two slashes */
	char *p;

	*second = '\0';		/* Split disk from directories */
	*last = '\0';		/* Split dir from filename */
	HTSprintf0(&vmsname, "%s%s:[%s]%s",
		   nodename, filename + 1, second + 1, last + 1);
	*second = *last = '/';	/* restore filename */
	if ((p = strchr(vmsname, '[')) != 0) {
	    while (*p != '\0' && *p != ']') {
		if (*p == '/')
		    *p = '.';	/* Convert dir sep.  to dots */
		++p;
	    }
	}
    }
    FREE(nodename);
    FREE(filename);
    return vmsname;
}

/*	Procedure: Read a character from the data connection
 *	----------------------------------------------------
 */
static int next_data_char(void)
{
    int status;

    if (data_read_pointer >= data_write_pointer) {
	status = NETREAD(data_soc, data_buffer, DATA_BUFFER_SIZE);
	if (status == HT_INTERRUPTED)
	    interrupted_in_next_data_char = 1;
	if (status <= 0)
	    return EOF;
	data_write_pointer = data_buffer + status;
	data_read_pointer = data_buffer;
    }
#ifdef NOT_ASCII
    {
	char c = *data_read_pointer++;

	return FROMASCII(c);
    }
#else
    return UCH(*data_read_pointer++);
#endif /* NOT_ASCII */
}

/*	Close an individual connection
 *
 */
static int close_connection(connection * con)
{
    connection *scan;
    int status;

    CTRACE((tfp, "HTFTP: Closing control socket %d\n", con->socket));
    status = NETCLOSE(con->socket);
    if (TRACE && status != 0) {
#ifdef UNIX
	CTRACE((tfp, "HTFTP:close_connection: %s", LYStrerror(errno)));
#else
	if (con->socket != INVSOC)
	    HTInetStatus("HTFTP:close_connection");
#endif
    }
    con->socket = -1;
    if (connections == con) {
	connections = con->next;
	return status;
    }
    for (scan = connections; scan; scan = scan->next) {
	if (scan->next == con) {
	    scan->next = con->next;	/* Unlink */
	    if (control == con)
		control = (connection *) 0;
	    return status;
	}			/*if */
    }				/* for */
    return -1;			/* very strange -- was not on list. */
}

static char *help_message_buffer = NULL;	/* global :( */

static void init_help_message_cache(void)
{
    FREE(help_message_buffer);
}

static void help_message_cache_add(char *string)
{
    if (help_message_buffer)
	StrAllocCat(help_message_buffer, string);
    else
	StrAllocCopy(help_message_buffer, string);

    CTRACE((tfp, "Adding message to help cache: %s\n", string));
}

static char *help_message_cache_non_empty(void)
{
    return (help_message_buffer);
}

static char *help_message_cache_contents(void)
{
    return (help_message_buffer);
}

/*	Send One Command
 *	----------------
 *
 *	This function checks whether we have a control connection, and sends
 *	one command if given.
 *
 * On entry,
 *	control	points to the connection which is established.
 *	cmd	points to a command, or is zero to just get the response.
 *
 *	The command should already be terminated with the CRLF pair.
 *
 * On exit,
 *	returns:  1 for success,
 *		  or negative for communication failure (in which case
 *		  the control connection will be closed).
 */
static int write_cmd(const char *cmd)
{
    int status;

    if (!control) {
	CTRACE((tfp, "HTFTP: No control connection set up!!\n"));
	return HT_NO_CONNECTION;
    }

    if (cmd) {
	CTRACE((tfp, "  Tx: %s", cmd));
#ifdef NOT_ASCII
	{
	    char *p;

	    for (p = cmd; *p; p++) {
		*p = TOASCII(*p);
	    }
	}
#endif /* NOT_ASCII */
	status = (int) NETWRITE(control->socket, cmd, (unsigned) strlen(cmd));
	if (status < 0) {
	    CTRACE((tfp,
		    "HTFTP: Error %d sending command: closing socket %d\n",
		    status, control->socket));
	    close_connection(control);
	    return status;
	}
    }
    return 1;
}

/*
 * For each string in the list, check if it is found in the response text.
 * If so, return TRUE.
 */
static BOOL find_response(HTList *list)
{
    BOOL result = FALSE;
    HTList *p = list;
    char *value;

    while ((value = (char *) HTList_nextObject(p)) != NULL) {
	if (LYstrstr(response_text, value)) {
	    result = TRUE;
	    break;
	}
    }
    return result;
}

/*	Execute Command and get Response
 *	--------------------------------
 *
 *	See the state machine illustrated in RFC959, p57. This implements
 *	one command/reply sequence.  It also interprets lines which are to
 *	be continued, which are marked with a "-" immediately after the
 *	status code.
 *
 *	Continuation then goes on until a line with a matching reply code
 *	an a space after it.
 *
 * On entry,
 *	control	points to the connection which is established.
 *	cmd	points to a command, or is zero to just get the response.
 *
 *	The command must already be terminated with the CRLF pair.
 *
 * On exit,
 *	returns:  The first digit of the reply type,
 *		  or negative for communication failure.
 */
static int response(const char *cmd)
{
    int result;			/* Three-digit decimal code */
    int continuation_response = -1;
    int status;

    if ((status = write_cmd(cmd)) < 0)
	return status;

    do {
	char *p = response_text;

	for (;;) {
	    int ich = NEXT_CHAR;

	    if (((*p++ = (char) ich) == LF)
		|| (p == &response_text[LINE_LENGTH])) {

		char continuation;

		if (interrupted_in_htgetcharacter) {
		    CTRACE((tfp,
			    "HTFTP: Interrupted in HTGetCharacter, apparently.\n"));
		    NETCLOSE(control->socket);
		    control->socket = -1;
		    return HT_INTERRUPTED;
		}

		*p = '\0';	/* Terminate the string */
		CTRACE((tfp, "    Rx: %s", response_text));

		/* Check for login or help messages */
		if (!StrNCmp(response_text, "230-", 4) ||
		    !StrNCmp(response_text, "250-", 4) ||
		    !StrNCmp(response_text, "220-", 4))
		    help_message_cache_add(response_text + 4);

		sscanf(response_text, "%d%c", &result, &continuation);
		if (continuation_response == -1) {
		    if (continuation == '-')	/* start continuation */
			continuation_response = result;
		} else {	/* continuing */
		    if (continuation_response == result &&
			continuation == ' ')
			continuation_response = -1;	/* ended */
		}
		if (result == 220 && find_response(broken_ftp_retr)) {
		    Broken_RETR = TRUE;
		    CTRACE((tfp, "This server is broken (RETR)\n"));
		}
#ifdef INET6
		if (result == 220 && find_response(broken_ftp_epsv)) {
		    Broken_EPSV = TRUE;
		    CTRACE((tfp, "This server is broken (EPSV)\n"));
		}
#endif
		break;
	    }
	    /* if end of line */
	    if (interrupted_in_htgetcharacter) {
		CTRACE((tfp,
			"HTFTP: Interrupted in HTGetCharacter, apparently.\n"));
		NETCLOSE(control->socket);
		control->socket = -1;
		return HT_INTERRUPTED;
	    }

	    if (ich == EOF) {
		CTRACE((tfp, "Error on rx: closing socket %d\n",
			control->socket));
		strcpy(response_text, "000 *** TCP read error on response\n");
		close_connection(control);
		return -1;	/* End of file on response */
	    }
	}			/* Loop over characters */

    } while (continuation_response != -1);

    if (result == 421) {
	CTRACE((tfp, "HTFTP: They close so we close socket %d\n",
		control->socket));
	close_connection(control);
	return -1;
    }
    if ((result == 255 && server_type == CMS_SERVER) &&
	(0 == strncasecomp(cmd, "CWD", 3) ||
	 0 == strcasecomp(cmd, "CDUP"))) {
	/*
	 * Alas, CMS returns 255 on failure to CWD to parent of root.  - PG
	 */
	result = 555;
    }
    return result / 100;
}

static int send_cmd_1(const char *verb)
{
    char command[80];

    sprintf(command, "%.*s%c%c", (int) sizeof(command) - 4, verb, CR, LF);
    return response(command);
}

static int send_cmd_2(const char *verb, const char *param)
{
    char *command = 0;
    int status;

    HTSprintf0(&command, "%s %s%c%c", verb, param, CR, LF);
    status = response(command);
    FREE(command);

    return status;
}

#define send_cwd(path) send_cmd_2("CWD", path)

/*
 * This function should try to set the macintosh server into binary mode.  Some
 * servers need an additional letter after the MACB command.
 */
static int set_mac_binary(eServerType ServerType)
{
    /* try to set mac binary mode */
    if (ServerType == APPLESHARE_SERVER ||
	ServerType == NETPRESENZ_SERVER) {
	/*
	 * Presumably E means "Enable".  - KW
	 */
	return (2 == response("MACB E\r\n"));
    } else {
	return (2 == response("MACB\r\n"));
    }
}

/* This function gets the current working directory to help
 * determine what kind of host it is
 */

static void get_ftp_pwd(eServerType *ServerType, BOOLEAN *UseList)
{
    char *cp;

    /* get the working directory (to see what it looks like) */
    int status = response("PWD\r\n");

    if (status < 0) {
	return;
    } else {
	cp = strchr(response_text + 5, '"');
	if (cp)
	    *cp = '\0';
	if (*ServerType == TCPC_SERVER) {
	    *ServerType = ((response_text[5] == '/') ?
			   NCSA_SERVER : TCPC_SERVER);
	    CTRACE((tfp, "HTFTP: Treating as %s server.\n",
		    ((*ServerType == NCSA_SERVER) ?
		     "NCSA" : "TCPC")));
	} else if (response_text[5] == '/') {
	    /* path names beginning with / imply Unix,
	     * right?
	     */
	    if (set_mac_binary(*ServerType)) {
		*ServerType = NCSA_SERVER;
		CTRACE((tfp, "HTFTP: Treating as NCSA server.\n"));
	    } else {
		*ServerType = UNIX_SERVER;
		*UseList = TRUE;
		CTRACE((tfp, "HTFTP: Treating as Unix server.\n"));
	    }
	    return;
	} else if (response_text[strlen(response_text) - 1] == ']') {
	    /* path names ending with ] imply VMS, right? */
	    *ServerType = VMS_SERVER;
	    *UseList = TRUE;
	    CTRACE((tfp, "HTFTP: Treating as VMS server.\n"));
	} else {
	    *ServerType = GENERIC_SERVER;
	    CTRACE((tfp, "HTFTP: Treating as Generic server.\n"));
	}

	if ((*ServerType == NCSA_SERVER) ||
	    (*ServerType == TCPC_SERVER) ||
	    (*ServerType == PETER_LEWIS_SERVER) ||
	    (*ServerType == NETPRESENZ_SERVER))
	    set_mac_binary(*ServerType);
    }
}

/* This function turns MSDOS-like directory output off for
 * Windows NT servers.
 */

static void set_unix_dirstyle(eServerType *ServerType, BOOLEAN *UseList)
{
    char *cp;

    /* This is a toggle.  It seems we have to toggle in order to see
     * the current state (after toggling), so we may end up toggling
     * twice.  - kw
     */
    int status = response("SITE DIRSTYLE\r\n");

    if (status != 2) {
	*ServerType = GENERIC_SERVER;
	CTRACE((tfp, "HTFTP: DIRSTYLE failed, treating as Generic server.\n"));
	return;
    } else {
	*UseList = TRUE;
	/* Expecting one of:
	 * 200 MSDOS-like directory output is off
	 * 200 MSDOS-like directory output is on
	 * The following code doesn't look for the full exact string -
	 * who knows how the wording may change in some future version.
	 * If the first response isn't recognized, we toggle again
	 * anyway, under the assumption that it's more likely that
	 * the MSDOS setting was "off" originally. - kw
	 */
	cp = strstr(response_text + 4, "MSDOS");
	if (cp && strstr(cp, " off")) {
	    return;		/* already off now. */
	} else {
	    response("SITE DIRSTYLE\r\n");
	}
    }
}

#define CheckForInterrupt(msg) \
	if (status == HT_INTERRUPTED) { \
	    CTRACE((tfp, "HTFTP: Interrupted %s.\n", msg)); \
	    _HTProgress(CONNECTION_INTERRUPTED); \
	    NETCLOSE(control->socket); \
	    control->socket = -1; \
	    return HT_INTERRUPTED; \
	}

/*	Get a valid connection to the host
 *	----------------------------------
 *
 * On entry,
 *	arg	points to the name of the host in a hypertext address
 * On exit,
 *	returns <0 if error
 *		socket number if success
 *
 *	This routine takes care of managing timed-out connections, and
 *	limiting the number of connections in use at any one time.
 *
 *	It ensures that all connections are logged in if they exist.
 *	It ensures they have the port number transferred.
 */
static int get_connection(const char *arg,
			  HTParentAnchor *anchor)
{
    int status;
    char *command = 0;
    connection *con;
    char *username = NULL;
    char *password = NULL;
    static BOOLEAN firstuse = TRUE;

    if (firstuse) {
	/*
	 * Set up freeing at exit.  - FM
	 */
#ifdef LY_FIND_LEAKS
	atexit(free_FTPGlobals);
#endif
	firstuse = FALSE;
    }

    if (control) {
	/*
	 * Reuse this object - KW, DW & FM
	 */
	if (control->socket != -1) {
	    NETCLOSE(control->socket);
	}
	con = control;
	con->addr = 0;
	con->binary = FALSE;
    } else {
	/*
	 * Allocate and init control struct.
	 */
	con = typecalloc(connection);
	if (con == NULL)
	    outofmem(__FILE__, "get_connection");

	assert(con != NULL);
    }
    con->socket = -1;

    if (isEmpty(arg)) {
	free(con);
	return -1;		/* Bad if no name specified     */
    }

    /* Get node name:
     */
    CTRACE((tfp, "get_connection(%s)\n", arg));
    {
	char *p1 = HTParse(arg, "", PARSE_HOST);
	char *p2 = strrchr(p1, '@@');	/* user? */
	char *pw = NULL;

	if (p2 != NULL) {
	    username = p1;
	    *p2 = '\0';		/* terminate */
	    p1 = p2 + 1;	/* point to host */
	    pw = strchr(username, ':');
	    if (pw != NULL) {
		*pw++ = '\0';
		password = HTUnEscape(pw);
	    }
	    if (*username)
		HTUnEscape(username);

	    /*
	     * If the password doesn't exist then we are going to have to ask
	     * the user for it.  The only problem is that we don't want to ask
	     * for it every time, so we will store away in a primitive fashion.
	     */
	    if (!password) {
		char *tmp = NULL;

		HTSprintf0(&tmp, "%s@@%s", username, p1);
		/*
		 * If the user@@host is not equal to the last time through or
		 * user_entered_password has no data then we need to ask the
		 * user for the password.
		 */
		if (!last_username_and_host ||
		    strcmp(tmp, last_username_and_host) ||
		    !user_entered_password) {

		    StrAllocCopy(last_username_and_host, tmp);
		    HTSprintf0(&tmp, gettext("Enter password for user %s@@%s:"),
			       username, p1);
		    FREE(user_entered_password);
		    user_entered_password = HTPromptPassword(tmp);

		}		/* else we already know the password */
		password = user_entered_password;
		FREE(tmp);
	    }
	}

	if (!username)
	    FREE(p1);
    }				/* scope of p1 */

    status = HTDoConnect(arg, "FTP", IPPORT_FTP, (int *) &con->socket);

    if (status < 0) {
	if (status == HT_INTERRUPTED) {
	    CTRACE((tfp, "HTFTP: Interrupted on connect\n"));
	} else {
	    CTRACE((tfp, "HTFTP: Unable to connect to remote host for `%s'.\n",
		    arg));
	}
	if (status == HT_INTERRUPTED) {
	    _HTProgress(CONNECTION_INTERRUPTED);
	    status = HT_NOT_LOADED;
	} else {
	    HTAlert(gettext("Unable to connect to FTP host."));
	}
	if (con->socket != -1) {
	    NETCLOSE(con->socket);
	}

	FREE(username);
	if (control == con)
	    control = NULL;
	FREE(con);
	return status;		/* Bad return */
    }

    CTRACE((tfp, "FTP connected, socket %d  control %p\n",
	    con->socket, (void *) con));
    control = con;		/* Current control connection */

    /* Initialise buffering for control connection */
    HTInitInput(control->socket);
    init_help_message_cache();	/* Clear the login message buffer. */

    /*  Now we log in           Look up username, prompt for pw.
     */
    status = response((char *) 0);	/* Get greeting */
    CheckForInterrupt("at beginning of login");

    server_type = GENERIC_SERVER;	/* reset */
    if (status == 2) {		/* Send username */
	char *cp;		/* look at greeting text */

	/* don't gettext() this -- incoming text: */
	if (strlen(response_text) > 4) {
	    if ((cp = strstr(response_text, " awaits your command")) ||
		(cp = strstr(response_text, " ready."))) {
		*cp = '\0';
	    }
	    cp = response_text + 4;
	    if (!strncasecomp(cp, "NetPresenz", 10))
		server_type = NETPRESENZ_SERVER;
	} else {
	    cp = response_text;
	}
	StrAllocCopy(anchor->server, cp);

	status = send_cmd_2("USER", (username && *username)
			    ? username
			    : "anonymous");

	CheckForInterrupt("while sending username");
    }
    if (status == 3) {		/* Send password */
	if (password) {
	    /*
	     * We have non-zero length password, so send it. - FM
	     */
	    HTSprintf0(&command, "PASS %s%c%c", password, CR, LF);
	} else {
	    /*
	     * Create and send a mail address as the password. - FM
	     */
	    const char *the_address;
	    char *user = NULL;
	    const char *host = NULL;
	    char *cp;

	    the_address = anonftp_password;
	    if (isEmpty(the_address))
		the_address = personal_mail_address;
	    if (isEmpty(the_address))
		the_address = LYGetEnv("USER");
	    if (isEmpty(the_address))
		the_address = "WWWuser";

	    StrAllocCopy(user, the_address);
	    if ((cp = strchr(user, '@@')) != NULL) {
		*cp++ = '\0';
		if (*cp == '\0')
		    host = HTHostName();
		else
		    host = cp;
	    } else {
		host = HTHostName();
	    }

	    /*
	     * If host is not fully qualified, suppress it
	     * as ftp.uu.net prefers a blank to a bad name
	     */
	    if (!(host) || strchr(host, '.') == NULL)
		host = "";

	    HTSprintf0(&command, "PASS %s@@%s%c%c", user, host, CR, LF);
	    FREE(user);
	}
	status = response(command);
	FREE(command);
	CheckForInterrupt("while sending password");
    }
    FREE(username);

    if (status == 3) {
	status = send_cmd_1("ACCT noaccount");
	CheckForInterrupt("while sending password");
    }
    if (status != 2) {
	CTRACE((tfp, "HTFTP: Login fail: %s", response_text));
	/* if (control->socket > 0) close_connection(control->socket); */
	return -1;		/* Bad return */
    }
    CTRACE((tfp, "HTFTP: Logged in.\n"));

    /* Check for host type */
    if (server_type != NETPRESENZ_SERVER)
	server_type = GENERIC_SERVER;	/* reset */
    use_list = FALSE;		/* reset */
    if (response("SYST\r\n") == 2) {
	/* we got a line -- what kind of server are we talking to? */
	if (StrNCmp(response_text + 4,
		    "UNIX Type: L8 MAC-OS MachTen", 28) == 0) {
	    server_type = MACHTEN_SERVER;
	    use_list = TRUE;
	    CTRACE((tfp, "HTFTP: Treating as MachTen server.\n"));

	} else if (strstr(response_text + 4, "UNIX") != NULL ||
		   strstr(response_text + 4, "Unix") != NULL) {
	    server_type = UNIX_SERVER;
	    unsure_type = FALSE;	/* to the best of out knowledge... */
	    use_list = TRUE;
	    CTRACE((tfp, "HTFTP: Treating as Unix server.\n"));

	} else if (strstr(response_text + 4, "MSDOS") != NULL) {
	    server_type = MSDOS_SERVER;
	    use_list = TRUE;
	    CTRACE((tfp, "HTFTP: Treating as MSDOS (Unix emulation) server.\n"));

	} else if (StrNCmp(response_text + 4, "VMS", 3) == 0) {
	    char *tilde = strstr(arg, "/~");

	    use_list = TRUE;
	    if (tilde != 0
		&& tilde[2] != 0
		&& strstr(response_text + 4, "MadGoat") != 0) {
		server_type = UNIX_SERVER;
		CTRACE((tfp, "HTFTP: Treating VMS as UNIX server.\n"));
	    } else {
		server_type = VMS_SERVER;
		CTRACE((tfp, "HTFTP: Treating as VMS server.\n"));
	    }

	} else if ((StrNCmp(response_text + 4, "VM/CMS", 6) == 0) ||
		   (StrNCmp(response_text + 4, "VM ", 3) == 0)) {
	    server_type = CMS_SERVER;
	    use_list = TRUE;
	    CTRACE((tfp, "HTFTP: Treating as CMS server.\n"));

	} else if (StrNCmp(response_text + 4, "DCTS", 4) == 0) {
	    server_type = DCTS_SERVER;
	    CTRACE((tfp, "HTFTP: Treating as DCTS server.\n"));

	} else if (strstr(response_text + 4, "MAC-OS TCP/Connect II") != NULL) {
	    server_type = TCPC_SERVER;
	    CTRACE((tfp, "HTFTP: Looks like a TCPC server.\n"));
	    get_ftp_pwd(&server_type, &use_list);
	    unsure_type = TRUE;

	} else if (server_type == NETPRESENZ_SERVER) {	/* already set above */
	    use_list = TRUE;
	    set_mac_binary(server_type);
	    CTRACE((tfp, "HTFTP: Treating as NetPresenz (MACOS) server.\n"));

	} else if (StrNCmp(response_text + 4, "MACOS Peter's Server", 20) == 0) {
	    server_type = PETER_LEWIS_SERVER;
	    use_list = TRUE;
	    set_mac_binary(server_type);
	    CTRACE((tfp, "HTFTP: Treating as Peter Lewis (MACOS) server.\n"));

	} else if (StrNCmp(response_text + 4, "Windows_NT", 10) == 0) {
	    server_type = WINDOWS_NT_SERVER;
	    CTRACE((tfp, "HTFTP: Treating as Window_NT server.\n"));
	    set_unix_dirstyle(&server_type, &use_list);

	} else if (StrNCmp(response_text + 4, "Windows2000", 11) == 0) {
	    server_type = WINDOWS_2K_SERVER;
	    CTRACE((tfp, "HTFTP: Treating as Window_2K server.\n"));
	    set_unix_dirstyle(&server_type, &use_list);

	} else if (StrNCmp(response_text + 4, "MS Windows", 10) == 0) {
	    server_type = MS_WINDOWS_SERVER;
	    use_list = TRUE;
	    CTRACE((tfp, "HTFTP: Treating as MS Windows server.\n"));

	} else if (StrNCmp(response_text + 4,
			   "MACOS AppleShare IP FTP Server", 30) == 0) {
	    server_type = APPLESHARE_SERVER;
	    use_list = TRUE;
	    set_mac_binary(server_type);
	    CTRACE((tfp, "HTFTP: Treating as AppleShare server.\n"));

	} else {
	    server_type = GENERIC_SERVER;
	    CTRACE((tfp, "HTFTP: Ugh!  A Generic server.\n"));
	    get_ftp_pwd(&server_type, &use_list);
	    unsure_type = TRUE;
	}
    } else {
	/* SYST fails :(  try to get the type from the PWD command */
	get_ftp_pwd(&server_type, &use_list);
    }

    return con->socket;		/* Good return */
}

static void reset_master_socket(void)
{
    have_socket = FALSE;
}

static void set_master_socket(int value)
{
    have_socket = (BOOLEAN) (value >= 0);
    if (have_socket)
	master_socket = (unsigned) value;
}

/*	Close Master (listening) socket
 *	-------------------------------
 *
 *
 */
static int close_master_socket(void)
{
    int status;

    if (have_socket)
	FD_CLR(master_socket, &open_sockets);

    status = NETCLOSE((int) master_socket);
    CTRACE((tfp, "HTFTP: Closed master socket %u\n", master_socket));

    reset_master_socket();

    if (status < 0)
	return HTInetStatus(gettext("close master socket"));
    else
	return status;
}

/*	Open a master socket for listening on
 *	-------------------------------------
 *
 *	When data is transferred, we open a port, and wait for the server to
 *	connect with the data.
 *
 * On entry,
 *	have_socket	Must be false, if master_socket is not setup already
 *	master_socket	Must be negative if not set up already.
 * On exit,
 *	Returns		socket number if good
 *			less than zero if error.
 *	master_socket	is socket number if good, else negative.
 *	port_number	is valid if good.
 */
static int get_listen_socket(void)
{
#ifdef INET6
    struct sockaddr_storage soc_address;	/* Binary network address */
    struct sockaddr_in *soc_in = (struct sockaddr_in *) &soc_address;
    int af;
    LY_SOCKLEN slen;

#else
    struct sockaddr_in soc_address;	/* Binary network address */
    struct sockaddr_in *soc_in = &soc_address;
#endif /* INET6 */
    int new_socket;		/* Will be master_socket */

    FD_ZERO(&open_sockets);	/* Clear our record of open sockets */
    num_sockets = 0;

#ifndef REPEAT_LISTEN
    if (have_socket)
	return master_socket;	/* Done already */
#endif /* !REPEAT_LISTEN */

#ifdef INET6
    /* query address family of control connection */
    slen = (LY_SOCKLEN) sizeof(soc_address);
    if (getsockname(control->socket, (struct sockaddr *) &soc_address,
		    &slen) < 0) {
	return HTInetStatus("getsockname failed");
    }
    af = ((struct sockaddr *) &soc_address)->sa_family;
    memset(&soc_address, 0, sizeof(soc_address));
#endif /* INET6 */

/*  Create internet socket
*/
#ifdef INET6
    new_socket = socket(af, SOCK_STREAM, IPPROTO_TCP);
#else
    new_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
#endif /* INET6 */

    if (new_socket < 0)
	return HTInetStatus(gettext("socket for master socket"));

    CTRACE((tfp, "HTFTP: Opened master socket number %d\n", new_socket));

/*  Search for a free port.
*/
#ifdef INET6
    memset(&soc_address, 0, sizeof(soc_address));
    ((struct sockaddr *) &soc_address)->sa_family = af;
    switch (af) {
    case AF_INET:
#ifdef SIN6_LEN
	((struct sockaddr *) &soc_address)->sa_len = sizeof(struct sockaddr_in);
#endif /* SIN6_LEN */
	break;
    case AF_INET6:
#ifdef SIN6_LEN
	((struct sockaddr *) &soc_address)->sa_len = sizeof(struct sockaddr_in6);
#endif /* SIN6_LEN */
	break;
    default:
	HTInetStatus("AF");
    }
#else
    soc_in->sin_family = AF_INET;	/* Family = internet, host order  */
    soc_in->sin_addr.s_addr = INADDR_ANY;	/* Any peer address */
#endif /* INET6 */
#ifdef POLL_PORTS
    {
	PortNumber old_port_number = port_number;

	for (port_number = (old_port_number + 1);; port_number++) {
	    int status;

	    if (port_number > LAST_TCP_PORT)
		port_number = FIRST_TCP_PORT;
	    if (port_number == old_port_number) {
		return HTInetStatus("bind");
	    }
#ifdef INET6
	    soc_in->sin_port = htons(port_number);
#else
	    soc_address.sin_port = htons(port_number);
#endif /* INET6 */
#ifdef SOCKS
	    if (socks_flag)
		if ((status = Rbind(new_socket,
				    (struct sockaddr *) &soc_address,
		/* Cast to generic sockaddr */
				    SOCKADDR_LEN(soc_address)
#ifndef SHORTENED_RBIND
				    ,socks_bind_remoteAddr
#endif /* !SHORTENED_RBIND */
		     )) == 0) {
		    break;
		} else
#endif /* SOCKS */
		    if ((status = bind(new_socket,
				       (struct sockaddr *) &soc_address,
		    /* Cast to generic sockaddr */
				       SOCKADDR_LEN(soc_address)
			 )) == 0) {
		    break;
		}
	    CTRACE((tfp, "TCP bind attempt to port %d yields %d, errno=%d\n",
		    port_number, status, SOCKET_ERRNO));
	}			/* for */
    }
#else
    {
	int status;
	LY_SOCKLEN address_length = (LY_SOCKLEN) sizeof(soc_address);

#ifdef SOCKS
	if (socks_flag)
	    status = Rgetsockname(control->socket,
				  (struct sockaddr *) &soc_address,
				  &address_length);
	else
#endif /* SOCKS */
	    status = getsockname(control->socket,
				 (struct sockaddr *) &soc_address,
				 &address_length);
	if (status < 0) {
	    close(new_socket);
	    return HTInetStatus("getsockname");
	}
#ifdef INET6
	CTRACE((tfp, "HTFTP: This host is %s\n",
		HTInetString((void *) soc_in)));

	soc_in->sin_port = 0;	/* Unspecified: please allocate */
#else
	CTRACE((tfp, "HTFTP: This host is %s\n",
		HTInetString(soc_in)));

	soc_address.sin_port = 0;	/* Unspecified: please allocate */
#endif /* INET6 */
#ifdef SOCKS
	if (socks_flag)
	    status = Rbind(new_socket,
			   (struct sockaddr *) &soc_address,
	    /* Cast to generic sockaddr */
			   sizeof(soc_address)
#ifndef SHORTENED_RBIND
			   ,socks_bind_remoteAddr
#endif /* !SHORTENED_RBIND */
		);
	else
#endif /* SOCKS */
	    status = bind(new_socket,
			  (struct sockaddr *) &soc_address,
	    /* Cast to generic sockaddr */
			  SOCKADDR_LEN(soc_address)
		);
	if (status < 0) {
	    close(new_socket);
	    return HTInetStatus("bind");
	}

	address_length = sizeof(soc_address);
#ifdef SOCKS
	if (socks_flag)
	    status = Rgetsockname(new_socket,
				  (struct sockaddr *) &soc_address,
				  &address_length);
	else
#endif /* SOCKS */
	    status = getsockname(new_socket,
				 (struct sockaddr *) &soc_address,
				 &address_length);
	if (status < 0) {
	    close(new_socket);
	    return HTInetStatus("getsockname");
	}
    }
#endif /* POLL_PORTS */

#ifdef INET6
    CTRACE((tfp, "HTFTP: bound to port %d on %s\n",
	    (int) ntohs(soc_in->sin_port),
	    HTInetString((void *) soc_in)));
#else
    CTRACE((tfp, "HTFTP: bound to port %d on %s\n",
	    (int) ntohs(soc_in->sin_port),
	    HTInetString(soc_in)));
#endif /* INET6 */

#ifdef REPEAT_LISTEN
    if (have_socket)
	(void) close_master_socket();
#endif /* REPEAT_LISTEN */

    set_master_socket(new_socket);

/*	Now we must find out who we are to tell the other guy
*/
    (void) HTHostName();	/* Make address valid - doesn't work */
#ifdef INET6
    switch (((struct sockaddr *) &soc_address)->sa_family) {
    case AF_INET:
#endif /* INET6 */
	sprintf(port_command, "PORT %d,%d,%d,%d,%d,%d%c%c",
		(int) *((unsigned char *) (&soc_in->sin_addr) + 0),
		(int) *((unsigned char *) (&soc_in->sin_addr) + 1),
		(int) *((unsigned char *) (&soc_in->sin_addr) + 2),
		(int) *((unsigned char *) (&soc_in->sin_addr) + 3),
		(int) *((unsigned char *) (&soc_in->sin_port) + 0),
		(int) *((unsigned char *) (&soc_in->sin_port) + 1),
		CR, LF);

#ifdef INET6
	break;

    case AF_INET6:
	{
	    char hostbuf[MAXHOSTNAMELEN];
	    char portbuf[MAXHOSTNAMELEN];

	    getnameinfo((struct sockaddr *) &soc_address,
			SOCKADDR_LEN(soc_address),
			hostbuf,
			(socklen_t) sizeof(hostbuf),
			portbuf,
			(socklen_t) sizeof(portbuf),
			NI_NUMERICHOST | NI_NUMERICSERV);
	    sprintf(port_command, "EPRT |%d|%s|%s|%c%c", 2, hostbuf, portbuf,
		    CR, LF);
	    break;
	}
    default:
	sprintf(port_command, "JUNK%c%c", CR, LF);
	break;
    }
#endif /* INET6 */

    /*  Inform TCP that we will accept connections
     */
    {
	int status;

#ifdef SOCKS
	if (socks_flag)
	    status = Rlisten((int) master_socket, 1);
	else
#endif /* SOCKS */
	    status = listen((int) master_socket, 1);
	if (status < 0) {
	    reset_master_socket();
	    return HTInetStatus("listen");
	}
    }
    CTRACE((tfp, "TCP: Master socket(), bind() and listen() all OK\n"));
    FD_SET(master_socket, &open_sockets);
    if ((master_socket + 1) > num_sockets)
	num_sockets = master_socket + 1;

    return (int) master_socket;	/* Good */

}				/* get_listen_socket */

static const char *months[12] =
{
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};

/*	Procedure: Set the current and last year strings and date integer
 *	-----------------------------------------------------------------
 *
 *	Bug:
 *		This code is for sorting listings by date, if that option
 *		is selected in Lynx, and doesn't take into account time
 *		zones or ensure resetting at midnight, so the sort may not
 *		be perfect, but the actual date isn't changed in the display,
 *		i.e., the date is still correct. - FM
 */
static void set_years_and_date(void)
{
    char day[8], month[8], date[12];
    time_t NowTime;
    int i;
    char *printable;

    NowTime = time(NULL);
    printable = ctime(&NowTime);
    LYStrNCpy(day, printable + 8, 2);
    if (day[0] == ' ') {
	day[0] = '0';
    }
    LYStrNCpy(month, printable + 4, 3);
    for (i = 0; i < 12; i++) {
	if (!strcasecomp(month, months[i])) {
	    break;
	}
    }
    i++;
    sprintf(date, "9999%02d%.2s", i, day);
    TheDate = atoi(date);
    LYStrNCpy(ThisYear, printable + 20, 4);
    sprintf(LastYear, "%d", (atoi(ThisYear) - 1));
    HaveYears = TRUE;
}

typedef struct _EntryInfo {
    char *filename;
    char *linkname;		/* symbolic link, if any */
    char *type;
    char *date;
    off_t size;
    BOOLEAN display;		/* show this entry? */
#ifdef LONG_LIST
    unsigned long file_links;
    char *file_mode;
    char *file_user;
    char *file_group;
#endif
} EntryInfo;

static void free_entryinfo_struct_contents(EntryInfo *entry_info)
{
    if (entry_info) {
	FREE(entry_info->filename);
	FREE(entry_info->linkname);
	FREE(entry_info->type);
	FREE(entry_info->date);
    }
    /* dont free the struct */
}

/*
 * is_ls_date() --
 *	Return TRUE if s points to a string of the form:
 *		"Sep  1  1990 " or
 *		"Sep 11 11:59 " or
 *		"Dec 12 1989  " or
 *		"FCv 23 1990  " ...
 */
static BOOLEAN is_ls_date(char *s)
{
    /* must start with three alpha characters */
    if (!isalpha(UCH(*s++)) || !isalpha(UCH(*s++)) || !isalpha(UCH(*s++)))
	return FALSE;

    /* space or HT_NON_BREAK_SPACE */
    if (!(*s == ' ' || *s == HT_NON_BREAK_SPACE)) {
	return FALSE;
    }
    s++;

    /* space or digit */
    if (!(*s == ' ' || isdigit(UCH(*s)))) {
	return FALSE;
    }
    s++;

    /* digit */
    if (!isdigit(UCH(*s++)))
	return FALSE;

    /* space */
    if (*s++ != ' ')
	return FALSE;

    /* space or digit */
    if (!(*s == ' ' || isdigit(UCH(*s)))) {
	return FALSE;
    }
    s++;

    /* digit */
    if (!isdigit(UCH(*s++)))
	return FALSE;

    /* colon or digit */
    if (!(*s == ':' || isdigit(UCH(*s)))) {
	return FALSE;
    }
    s++;

    /* digit */
    if (!isdigit(UCH(*s++)))
	return FALSE;

    /* space or digit */
    if (!(*s == ' ' || isdigit(UCH(*s)))) {
	return FALSE;
    }
    s++;

    /* space */
    if (*s != ' ')
	return FALSE;

    return TRUE;
}				/* is_ls_date() */

/*
 * Extract the name, size, and date from an EPLF line.  - 08-06-96 DJB
 */
static void parse_eplf_line(char *line,
			    EntryInfo *info)
{
    char *cp = line;
    char ct[26];
    off_t size;
    time_t secs;
    static time_t base;		/* time() value on this OS in 1970 */
    static int flagbase = 0;

    if (!flagbase) {
	struct tm t;

	t.tm_year = 70;
	t.tm_mon = 0;
	t.tm_mday = 0;
	t.tm_hour = 0;
	t.tm_min = 0;
	t.tm_sec = 0;
	t.tm_isdst = -1;
	base = mktime(&t);	/* could return -1 */
	flagbase = 1;
    }

    while (*cp) {
	switch (*cp) {
	case '\t':
	    StrAllocCopy(info->filename, cp + 1);
	    return;
	case 's':
	    size = 0;
	    while (*(++cp) && (*cp != ','))
		size = (size * 10) + (off_t) (*cp - '0');
	    info->size = size;
	    break;
	case 'm':
	    secs = 0;
	    while (*(++cp) && (*cp != ','))
		secs = (secs * 10) + (*cp - '0');
	    secs += base;	/* assumes that time_t is #seconds */
	    LYStrNCpy(ct, ctime(&secs), 24);
	    StrAllocCopy(info->date, ct);
	    break;
	case '/':
	    StrAllocCopy(info->type, ENTRY_IS_DIRECTORY);
	    /* FALLTHRU */
	default:
	    while (*cp) {
		if (*cp++ == ',')
		    break;
	    }
	    break;
	}
    }
}				/* parse_eplf_line */

/*
 * Extract the name, size, and date from an ls -l line.
 */
static void parse_ls_line(char *line,
			  EntryInfo *entry)
{
#ifdef LONG_LIST
    char *next;
    char *cp;
#endif
    int i, j;
    off_t base = 1;
    off_t size_num = 0;

    for (i = (int) strlen(line) - 1;
	 (i > 13) && (!isspace(UCH(line[i])) || !is_ls_date(&line[i - 12]));
	 i--) {
	;			/* null body */
    }
    line[i] = '\0';
    if (i > 13) {
	StrAllocCopy(entry->date, &line[i - 12]);
	/* replace the 4th location with nbsp if it is a space or zero */
	if (entry->date[4] == ' ' || entry->date[4] == '0')
	    entry->date[4] = HT_NON_BREAK_SPACE;
	/* make sure year or time is flush right */
	if (entry->date[11] == ' ') {
	    for (j = 11; j > 6; j--) {
		entry->date[j] = entry->date[j - 1];
	    }
	}
    }
    j = i - 14;
    while (isdigit(UCH(line[j]))) {
	size_num += ((off_t) (line[j] - '0') * base);
	base *= 10;
	j--;
    }
    entry->size = size_num;
    StrAllocCopy(entry->filename, &line[i + 1]);

#ifdef LONG_LIST
    line[j] = '\0';

    /*
     * Extract the file-permissions, as a string.
     */
    if ((cp = strchr(line, ' ')) != 0) {
	if ((cp - line) == 10) {
	    *cp = '\0';
	    StrAllocCopy(entry->file_mode, line);
	    *cp = ' ';
	}

	/*
	 * Next is the link-count.
	 */
	next = 0;
	entry->file_links = (unsigned long) strtol(cp, &next, 10);
	if (next == 0 || *next != ' ') {
	    entry->file_links = 0;
	    next = cp;
	} else {
	    cp = next;
	}
	/*
	 * Next is the user-name.
	 */
	while (isspace(UCH(*cp)))
	    ++cp;
	if ((next = strchr(cp, ' ')) != 0)
	    *next = '\0';
	if (*cp != '\0')
	    StrAllocCopy(entry->file_user, cp);
	/*
	 * Next is the group-name (perhaps).
	 */
	if (next != NULL) {
	    cp = (next + 1);
	    while (isspace(UCH(*cp)))
		++cp;
	    if ((next = strchr(cp, ' ')) != 0)
		*next = '\0';
	    if (*cp != '\0')
		StrAllocCopy(entry->file_group, cp);
	}
    }
#endif
}

/*
 * Extract the name and size info and whether it refers to a directory from a
 * LIST line in "dls" format.
 */
static void parse_dls_line(char *line,
			   EntryInfo *entry_info,
			   char **pspilledname)
{
    short j;
    int base = 1;
    off_t size_num = 0;
    int len;
    char *cps = NULL;

    /* README              763  Information about this server\0
       bin/                  -  \0
       etc/                  =  \0
       ls-lR                 0  \0
       ls-lR.Z               3  \0
       pub/                  =  Public area\0
       usr/                  -  \0
       morgan               14  -> ../real/morgan\0
       TIMIT.mostlikely.Z\0
       79215    \0
     */

    len = (int) strlen(line);
    if (len == 0) {
	FREE(*pspilledname);
	entry_info->display = FALSE;
	return;
    }
    cps = LYSkipNonBlanks(line);
    if (*cps == '\0') {		/* only a filename, save it and return. */
	StrAllocCopy(*pspilledname, line);
	entry_info->display = FALSE;
	return;
    }
    if (len < 24 || line[23] != ' ' ||
	(isspace(UCH(line[0])) && !*pspilledname)) {
	/* this isn't the expected "dls" format! */
	if (!isspace(UCH(line[0])))
	    *cps = '\0';
	if (*pspilledname && !*line) {
	    entry_info->filename = *pspilledname;
	    *pspilledname = NULL;
	    if (entry_info->filename[strlen(entry_info->filename) - 1] == '/')
		StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	    else
		StrAllocCopy(entry_info->type, "");
	} else {
	    StrAllocCopy(entry_info->filename, line);
	    if (cps != line && *(cps - 1) == '/')
		StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	    else
		StrAllocCopy(entry_info->type, "");
	    FREE(*pspilledname);
	}
	return;
    }

    j = 22;
    if (line[j] == '=' || line[j] == '-') {
	StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
    } else {
	while (isdigit(UCH(line[j]))) {
	    size_num += (line[j] - '0') * base;
	    base *= 10;
	    j--;
	}
    }
    entry_info->size = size_num;

    cps = LYSkipBlanks(&line[23]);
    if (!StrNCmp(cps, "-> ", 3) && cps[3] != '\0' && cps[3] != ' ') {
	StrAllocCopy(entry_info->type, ENTRY_IS_SYMBOLIC_LINK);
	StrAllocCopy(entry_info->linkname, LYSkipBlanks(cps + 3));
	entry_info->size = 0;	/* don't display size */
    }

    if (j > 0)
	line[j] = '\0';

    LYTrimTrailing(line);

    len = (int) strlen(line);
    if (len == 0 && *pspilledname && **pspilledname) {
	line = *pspilledname;
	len = (int) strlen(*pspilledname);
    }
    if (len > 0 && line[len - 1] == '/') {
	/*
	 * It's a dir, remove / and mark it as such.
	 */
	if (len > 1)
	    line[len - 1] = '\0';
	if (!entry_info->type)
	    StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
    }

    StrAllocCopy(entry_info->filename, line);
    FREE(*pspilledname);
}				/* parse_dls_line() */

/*
 * parse_vms_dir_entry()
 *	Format the name, date, and size from a VMS LIST line
 *	into the EntryInfo structure - FM
 */
static void parse_vms_dir_entry(char *line,
				EntryInfo *entry_info)
{
    int i, j;
    off_t ialloc;
    char *cp, *cpd, *cps, date[16];
    const char *sp = " ";

    /* Get rid of blank lines, and information lines.  Valid lines have the ';'
     * version number token.
     */
    if (!strlen(line) || (cp = strchr(line, ';')) == NULL) {
	entry_info->display = FALSE;
	return;
    }

    /* Cut out file or directory name at VMS version number. */
    *cp++ = '\0';
    StrAllocCopy(entry_info->filename, line);

    /* Cast VMS non-README file and directory names to lowercase. */
    if (strstr(entry_info->filename, "READ") == NULL) {
	LYLowerCase(entry_info->filename);
	i = (int) strlen(entry_info->filename);
    } else {
	i = (int) ((strstr(entry_info->filename, "READ")
		    - entry_info->filename)
		   + 4);
	if (!StrNCmp(&entry_info->filename[i], "ME", 2)) {
	    i += 2;
	    while (entry_info->filename[i] && entry_info->filename[i] != '.') {
		i++;
	    }
	} else if (!StrNCmp(&entry_info->filename[i], ".ME", 3)) {
	    i = (int) strlen(entry_info->filename);
	} else {
	    i = 0;
	}
	LYLowerCase(entry_info->filename + i);
    }

    /* Uppercase terminal .zs or _zs. */
    if ((--i > 2) &&
	entry_info->filename[i] == 'z' &&
	(entry_info->filename[i - 1] == '.' ||
	 entry_info->filename[i - 1] == '_'))
	entry_info->filename[i] = 'Z';

    /* Convert any tabs in rest of line to spaces. */
    cps = cp - 1;
    while ((cps = strchr(cps + 1, '\t')) != NULL)
	*cps = ' ';

    /* Collapse serial spaces. */
    i = 0;
    j = 1;
    cps = cp;
    while (cps[j] != '\0') {
	if (cps[i] == ' ' && cps[j] == ' ')
	    j++;
	else
	    cps[++i] = cps[j++];
    }
    cps[++i] = '\0';

    /* Set the years and date, if we don't have them yet. * */
    if (!HaveYears) {
	set_years_and_date();
    }

    /* Track down the date. */
    if ((cpd = strchr(cp, '-')) != NULL &&
	strlen(cpd) > 9 && isdigit(UCH(*(cpd - 1))) &&
	isalpha(UCH(*(cpd + 1))) && *(cpd + 4) == '-') {

	/* Month */
	*(cpd + 2) = (char) TOLOWER(*(cpd + 2));
	*(cpd + 3) = (char) TOLOWER(*(cpd + 3));
	sprintf(date, "%.3s ", cpd + 1);

	/* Day */
	if (isdigit(UCH(*(cpd - 2))))
	    sprintf(date + 4, "%.2s ", cpd - 2);
	else
	    sprintf(date + 4, "%c%.1s ", HT_NON_BREAK_SPACE, cpd - 1);

	/* Time or Year */
	if (!StrNCmp(ThisYear, cpd + 5, 4) &&
	    strlen(cpd) > 15 && *(cpd + 12) == ':') {
	    sprintf(date + 7, "%.5s", cpd + 10);
	} else {
	    sprintf(date + 7, " %.4s", cpd + 5);
	}

	StrAllocCopy(entry_info->date, date);
    }

    /* Track down the size */
    if ((cpd = strchr(cp, '/')) != NULL) {
	/* Appears be in used/allocated format */
	cps = cpd;
	while (isdigit(UCH(*(cps - 1))))
	    cps--;
	if (cps < cpd)
	    *cpd = '\0';
	entry_info->size = LYatoll(cps);
	cps = cpd + 1;
	while (isdigit(UCH(*cps)))
	    cps++;
	*cps = '\0';
	ialloc = LYatoll(cpd + 1);
	/* Check if used is in blocks or bytes */
	if (entry_info->size <= ialloc)
	    entry_info->size *= 512;

    } else if (strtok(cp, sp) != NULL) {
	/* We just initialized on the version number */
	/* Now let's hunt for a lone, size number    */
	while ((cps = strtok(NULL, sp)) != NULL) {
	    cpd = cps;
	    while (isdigit(UCH(*cpd)))
		cpd++;
	    if (*cpd == '\0') {
		/* Assume it's blocks */
		entry_info->size = (LYatoll(cps) * 512);
		break;
	    }
	}
    }

    TRACE_ENTRY("VMS", entry_info);
    return;
}				/* parse_vms_dir_entry() */

/*
 * parse_ms_windows_dir_entry() --
 *	Format the name, date, and size from an MS_WINDOWS LIST line into
 *	the EntryInfo structure (assumes Chameleon NEWT format). - FM
 */
static void parse_ms_windows_dir_entry(char *line,
				       EntryInfo *entry_info)
{
    char *cp = line;
    char *cps, *cpd, date[16];
    char *end = line + strlen(line);

    /*  Get rid of blank or junk lines.  */
    cp = LYSkipBlanks(cp);
    if (!(*cp)) {
	entry_info->display = FALSE;
	return;
    }

    /* Cut out file or directory name. */
    cps = LYSkipNonBlanks(cp);
    *cps++ = '\0';
    cpd = cps;
    StrAllocCopy(entry_info->filename, cp);

    /* Track down the size */
    if (cps < end) {
	cps = LYSkipBlanks(cps);
	cpd = LYSkipNonBlanks(cps);
	*cpd++ = '\0';
	if (isdigit(UCH(*cps))) {
	    entry_info->size = LYatoll(cps);
	} else {
	    StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	}
    } else {
	StrAllocCopy(entry_info->type, "");
    }

    /* Set the years and date, if we don't have them yet. * */
    if (!HaveYears) {
	set_years_and_date();
    }

    /* Track down the date. */
    if (cpd < end) {
	cpd = LYSkipBlanks(cpd);
	if (strlen(cpd) > 17) {
	    *(cpd + 6) = '\0';	/* Month and Day */
	    *(cpd + 11) = '\0';	/* Year */
	    *(cpd + 17) = '\0';	/* Time */
	    if (strcmp(ThisYear, cpd + 7))
		/* Not this year, so show the year */
		sprintf(date, "%.6s  %.4s", cpd, (cpd + 7));
	    else
		/* Is this year, so show the time */
		sprintf(date, "%.6s %.5s", cpd, (cpd + 12));
	    StrAllocCopy(entry_info->date, date);
	    if (entry_info->date[4] == ' ' || entry_info->date[4] == '0') {
		entry_info->date[4] = HT_NON_BREAK_SPACE;
	    }
	}
    }

    TRACE_ENTRY("MS Windows", entry_info);
    return;
}				/* parse_ms_windows_dir_entry */

/*
 * parse_windows_nt_dir_entry() --
 *	Format the name, date, and size from a WINDOWS_NT LIST line into
 *	the EntryInfo structure (assumes Chameleon NEWT format). - FM
 */
#ifdef NOTDEFINED
static void parse_windows_nt_dir_entry(char *line,
				       EntryInfo *entry_info)
{
    char *cp = line;
    char *cps, *cpd, date[16];
    char *end = line + strlen(line);
    int i;

    /*  Get rid of blank or junk lines.  */
    cp = LYSkipBlanks(cp);
    if (!(*cp)) {
	entry_info->display = FALSE;
	return;
    }

    /* Cut out file or directory name. */
    cpd = cp;
    cps = LYSkipNonBlanks(end - 1);
    cp = (cps + 1);
    if (!strcmp(cp, ".") || !strcmp(cp, "..")) {
	entry_info->display = FALSE;
	return;
    }
    StrAllocCopy(entry_info->filename, cp);
    if (cps < cpd)
	return;
    *cp = '\0';
    end = cp;

    /* Set the years and date, if we don't have them yet. * */
    if (!HaveYears) {
	set_years_and_date();
    }

    /* Cut out the date. */
    cp = cps = cpd;
    cps = LYSkipNonBlanks(cps);
    *cps++ = '\0';
    if (cps > end) {
	entry_info->display = FALSE;
	return;
    }
    cps = LYSkipBlanks(cps);
    cpd = LYSkipNonBlanks(cps);
    *cps++ = '\0';
    if (cps > end || cpd == cps || strlen(cpd) < 7) {
	entry_info->display = FALSE;
	return;
    }
    if (strlen(cp) == 8 &&
	isdigit(*cp) && isdigit(*(cp + 1)) && *(cp + 2) == '-' &&
	isdigit(*(cp + 3)) && isdigit(*(cp + 4)) && *(cp + 5) == '-') {
	*(cp + 2) = '\0';	/* Month */
	i = atoi(cp) - 1;
	*(cp + 5) = '\0';	/* Day */
	sprintf(date, "%.3s %.2s", months[i], (cp + 3));
	if (date[4] == '0')
	    date[4] = ' ';
	cp += 6;		/* Year */
	if (strcmp((ThisYear + 2), cp)) {
	    /* Not this year, so show the year */
	    if (atoi(cp) < 70) {
		sprintf(&date[6], "  20%.2s", cp);
	    } else {
		sprintf(&date[6], "  19%.2s", cp);
	    }
	} else {
	    /* Is this year, so show the time */
	    *(cpd + 2) = '\0';	/* Hour */
	    i = atoi(cpd);
	    if (*(cpd + 5) == 'P' || *(cpd + 5) == 'p')
		i += 12;
	    sprintf(&date[6], " %02d:%.2s", i, (cpd + 3));
	}
	StrAllocCopy(entry_info->date, date);
	if (entry_info->date[4] == ' ' || entry_info->date[4] == '0') {
	    entry_info->date[4] = HT_NON_BREAK_SPACE;
	}
    }

    /* Track down the size */
    if (cps < end) {
	cps = LYSkipBlanks(cps);
	cpd = LYSkipNonBlanks(cps);
	*cpd = '\0';
	if (isdigit(*cps)) {
	    entry_info->size = LYatoll(cps);
	} else {
	    StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	}
    } else {
	StrAllocCopy(entry_info->type, "");
    }

    /* Wrap it up */
    CTRACE((tfp, "HTFTP: Windows NT filename: %s  date: %s  size: %d\n",
	    entry_info->filename,
	    NonNull(entry_info->date),
	    entry_info->size));
    return;
}				/* parse_windows_nt_dir_entry */
#endif /* NOTDEFINED */

/*
 * parse_cms_dir_entry() --
 *	Format the name, date, and size from a VM/CMS line into
 *	the EntryInfo structure. - FM
 */
static void parse_cms_dir_entry(char *line,
				EntryInfo *entry_info)
{
    char *cp = line;
    char *cps, *cpd, date[16];
    char *end = line + strlen(line);
    int RecordLength = 0;
    int Records = 0;
    int i;

    /*  Get rid of blank or junk lines.  */
    cp = LYSkipBlanks(cp);
    if (!(*cp)) {
	entry_info->display = FALSE;
	return;
    }

    /* Cut out file or directory name. */
    cps = LYSkipNonBlanks(cp);
    *cps++ = '\0';
    StrAllocCopy(entry_info->filename, cp);
    if (strchr(entry_info->filename, '.') != NULL)
	/* If we already have a dot, we did an NLST. */
	return;
    cp = LYSkipBlanks(cps);
    if (!(*cp)) {
	/* If we don't have more, we've misparsed. */
	FREE(entry_info->filename);
	FREE(entry_info->type);
	entry_info->display = FALSE;
	return;
    }
    cps = LYSkipNonBlanks(cp);
    *cps++ = '\0';
    if ((0 == strcasecomp(cp, "DIR")) && (cp - line) > 17) {
	/* It's an SFS directory. */
	StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	entry_info->size = 0;
    } else {
	/* It's a file. */
	cp--;
	*cp = '.';
	StrAllocCat(entry_info->filename, cp);

	/* Track down the VM/CMS RECFM or type. */
	cp = cps;
	if (cp < end) {
	    cp = LYSkipBlanks(cp);
	    cps = LYSkipNonBlanks(cp);
	    *cps++ = '\0';
	    /* Check cp here, if it's relevant someday. */
	}
    }

    /* Track down the record length or dash. */
    cp = cps;
    if (cp < end) {
	cp = LYSkipBlanks(cp);
	cps = LYSkipNonBlanks(cp);
	*cps++ = '\0';
	if (isdigit(UCH(*cp))) {
	    RecordLength = atoi(cp);
	}
    }

    /* Track down the number of records or the dash. */
    cp = cps;
    if (cps < end) {
	cp = LYSkipBlanks(cp);
	cps = LYSkipNonBlanks(cp);
	*cps++ = '\0';
	if (isdigit(UCH(*cp))) {
	    Records = atoi(cp);
	}
	if (Records > 0 && RecordLength > 0) {
	    /* Compute an approximate size. */
	    entry_info->size = ((off_t) Records * (off_t) RecordLength);
	}
    }

    /* Set the years and date, if we don't have them yet. */
    if (!HaveYears) {
	set_years_and_date();
    }

    /* Track down the date. */
    cpd = cps;
    if (((cps < end) &&
	 (cps = strchr(cpd, ':')) != NULL) &&
	(cps < (end - 3) &&
	 isdigit(UCH(*(cps + 1))) && isdigit(UCH(*(cps + 2))) && *(cps + 3) == ':')) {
	cps += 3;
	*cps = '\0';
	if ((cps - cpd) >= 14) {
	    cpd = (cps - 14);
	    *(cpd + 2) = '\0';	/* Month */
	    *(cpd + 5) = '\0';	/* Day */
	    *(cpd + 8) = '\0';	/* Year */
	    cps -= 5;		/* Time */
	    if (*cpd == ' ')
		*cpd = '0';
	    i = atoi(cpd) - 1;
	    sprintf(date, "%.3s %.2s", months[i], (cpd + 3));
	    if (date[4] == '0')
		date[4] = ' ';
	    cpd += 6;		/* Year */
	    if (strcmp((ThisYear + 2), cpd)) {
		/* Not this year, so show the year. */
		if (atoi(cpd) < 70) {
		    sprintf(&date[6], "  20%.2s", cpd);
		} else {
		    sprintf(&date[6], "  19%.2s", cpd);
		}
	    } else {
		/* Is this year, so show the time. */
		*(cps + 2) = '\0';	/* Hour */
		i = atoi(cps);
		sprintf(&date[6], " %02d:%.2s", i, (cps + 3));
	    }
	    StrAllocCopy(entry_info->date, date);
	    if (entry_info->date[4] == ' ' || entry_info->date[4] == '0') {
		entry_info->date[4] = HT_NON_BREAK_SPACE;
	    }
	}
    }

    TRACE_ENTRY("VM/CMS", entry_info);
    return;
}				/* parse_cms_dir_entry */

/*
 * Given a line of LIST/NLST output in entry, return results and a file/dir
 * name in entry_info struct
 *
 * If first is true, this is the first name in a directory.
 */
static EntryInfo *parse_dir_entry(char *entry,
				  BOOLEAN *first,
				  char **pspilledname)
{
    EntryInfo *entry_info;
    int i;
    int len;
    BOOLEAN remove_size = FALSE;
    char *cp;

    entry_info = typecalloc(EntryInfo);

    if (entry_info == NULL)
	outofmem(__FILE__, "parse_dir_entry");

    assert(entry_info != NULL);

    entry_info->display = TRUE;

    switch (server_type) {
    case DLS_SERVER:

	/*
	 * Interpret and edit LIST output from a Unix server in "dls" format. 
	 * This one must have claimed to be Unix in order to get here; if the
	 * first line looks fishy, we revert to Unix and hope that fits better
	 * (this recovery is untested).  - kw
	 */

	if (*first) {
	    len = (int) strlen(entry);
	    if (!len || entry[0] == ' ' ||
		(len >= 24 && entry[23] != ' ') ||
		(len < 24 && strchr(entry, ' '))) {
		server_type = UNIX_SERVER;
		CTRACE((tfp,
			"HTFTP: Falling back to treating as Unix server.\n"));
	    } else {
		*first = FALSE;
	    }
	}

	if (server_type == DLS_SERVER) {
	    /* if still unchanged... */
	    parse_dls_line(entry, entry_info, pspilledname);

	    if (isEmpty(entry_info->filename)) {
		entry_info->display = FALSE;
		return (entry_info);
	    }
	    if (!strcmp(entry_info->filename, "..") ||
		!strcmp(entry_info->filename, "."))
		entry_info->display = FALSE;
	    if (entry_info->type && *entry_info->type == '\0') {
		FREE(entry_info->type);
		return (entry_info);
	    }
	    /*
	     * Goto the bottom and get real type.
	     */
	    break;
	}
	/* fall through if server_type changed for *first == TRUE ! */
    case UNIX_SERVER:
    case PETER_LEWIS_SERVER:
    case MACHTEN_SERVER:
    case MSDOS_SERVER:
    case WINDOWS_NT_SERVER:
    case WINDOWS_2K_SERVER:
    case APPLESHARE_SERVER:
    case NETPRESENZ_SERVER:
	/*
	 * Check for EPLF output (local times).
	 */
	if (*entry == '+') {
	    parse_eplf_line(entry, entry_info);
	    break;
	}

	/*
	 * Interpret and edit LIST output from Unix server.
	 */
	len = (int) strlen(entry);
	if (*first) {
	    /* don't gettext() this -- incoming text: */
	    if (!strcmp(entry, "can not access directory .")) {
		/*
		 * Don't reset *first, nothing real will follow.  - KW
		 */
		entry_info->display = FALSE;
		return (entry_info);
	    }
	    *first = FALSE;
	    if (!StrNCmp(entry, "total ", 6) ||
		strstr(entry, "not available") != NULL) {
		entry_info->display = FALSE;
		return (entry_info);
	    } else if (unsure_type) {
		/* this isn't really a unix server! */
		server_type = GENERIC_SERVER;
		entry_info->display = FALSE;
		return (entry_info);
	    }
	}

	/*
	 * Check first character of ls -l output.
	 */
	if (TOUPPER(entry[0]) == 'D') {
	    /*
	     * It's a directory.
	     */
	    StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	    remove_size = TRUE;	/* size is not useful */
	} else if (entry[0] == 'l') {
	    /*
	     * It's a symbolic link, does the user care about knowing if it is
	     * symbolic?  I think so since it might be a directory.
	     */
	    StrAllocCopy(entry_info->type, ENTRY_IS_SYMBOLIC_LINK);
	    remove_size = TRUE;	/* size is not useful */

	    /*
	     * Strip off " -> pathname".
	     */
	    for (i = len - 1; (i > 3) &&
		 (!isspace(UCH(entry[i])) ||
		  (entry[i - 1] != '>') ||
		  (entry[i - 2] != '-') ||
		  (entry[i - 3] != ' ')); i--) ;	/* null body */
	    if (i > 3) {
		entry[i - 3] = '\0';
		StrAllocCopy(entry_info->linkname, LYSkipBlanks(entry + i));
	    }
	}
	/* link */
	parse_ls_line(entry, entry_info);

	if (!strcmp(entry_info->filename, "..") ||
	    !strcmp(entry_info->filename, "."))
	    entry_info->display = FALSE;
	/*
	 * Goto the bottom and get real type.
	 */
	break;

    case VMS_SERVER:
	/*
	 * Interpret and edit LIST output from VMS server and convert
	 * information lines to zero length.
	 */
	parse_vms_dir_entry(entry, entry_info);

	/*
	 * Get rid of any junk lines.
	 */
	if (!entry_info->display)
	    return (entry_info);

	/*
	 * Trim off VMS directory extensions.
	 */
	len = (int) strlen(entry_info->filename);
	if ((len > 4) && !strcmp(&entry_info->filename[len - 4], ".dir")) {
	    entry_info->filename[len - 4] = '\0';
	    StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	    remove_size = TRUE;	/* size is not useful */
	}
	/*
	 * Goto the bottom and get real type.
	 */
	break;

    case MS_WINDOWS_SERVER:
	/*
	 * Interpret and edit LIST output from MS_WINDOWS server and convert
	 * information lines to zero length.
	 */
	parse_ms_windows_dir_entry(entry, entry_info);

	/*
	 * Get rid of any junk lines.
	 */
	if (!entry_info->display)
	    return (entry_info);
	if (entry_info->type && *entry_info->type == '\0') {
	    FREE(entry_info->type);
	    return (entry_info);
	}
	/*
	 * Goto the bottom and get real type.
	 */
	break;

#ifdef NOTDEFINED
    case WINDOWS_NT_SERVER:
	/*
	 * Interpret and edit LIST output from MS_WINDOWS server and convert
	 * information lines to zero length.
	 */
	parse_windows_nt_dir_entry(entry, entry_info);

	/*
	 * Get rid of any junk lines.
	 */
	if (!entry_info->display)
	    return (entry_info);
	if (entry_info->type && *entry_info->type == '\0') {
	    FREE(entry_info->type);
	    return (entry_info);
	}
	/*
	 * Goto the bottom and get real type.
	 */
	break;
#endif /* NOTDEFINED */

    case CMS_SERVER:
	{
	    /*
	     * Interpret and edit LIST output from VM/CMS server and convert
	     * any information lines to zero length.
	     */
	    parse_cms_dir_entry(entry, entry_info);

	    /*
	     * Get rid of any junk lines.
	     */
	    if (!entry_info->display)
		return (entry_info);
	    if (entry_info->type && *entry_info->type == '\0') {
		FREE(entry_info->type);
		return (entry_info);
	    }
	    /*
	     * Goto the bottom and get real type.
	     */
	    break;
	}

    case NCSA_SERVER:
    case TCPC_SERVER:
	/*
	 * Directories identified by trailing "/" characters.
	 */
	StrAllocCopy(entry_info->filename, entry);
	len = (int) strlen(entry);
	if (entry[len - 1] == '/') {
	    /*
	     * It's a dir, remove / and mark it as such.
	     */
	    entry[len - 1] = '\0';
	    StrAllocCopy(entry_info->type, ENTRY_IS_DIRECTORY);
	    remove_size = TRUE;	/* size is not useful */
	}
	/*
	 * Goto the bottom and get real type.
	 */
	break;

    default:
	/*
	 * We can't tell if it is a directory since we only did an NLST :( List
	 * bad file types anyways?  NOT!
	 */
	StrAllocCopy(entry_info->filename, entry);
	return (entry_info);	/* mostly empty info */

    }				/* switch (server_type) */

#ifdef LONG_LIST
    (void) remove_size;
#else
    if (remove_size && entry_info->size) {
	entry_info->size = 0;
    }
#endif

    if (isEmpty(entry_info->filename)) {
	entry_info->display = FALSE;
	return (entry_info);
    }
    if (strlen(entry_info->filename) > 3) {
	if (((cp = strrchr(entry_info->filename, '.')) != NULL &&
	     0 == strncasecomp(cp, ".me", 3)) &&
	    (cp[3] == '\0' || cp[3] == ';')) {
	    /*
	     * Don't treat this as application/x-Troff-me if it's a Unix server
	     * but has the string "read.me", or if it's not a Unix server.  -
	     * FM
	     */
	    if ((server_type != UNIX_SERVER) ||
		(cp > (entry_info->filename + 3) &&
		 0 == strncasecomp((cp - 4), "read.me", 7))) {
		StrAllocCopy(entry_info->type, "text/plain");
	    }
	}
    }

    /*
     * Get real types eventually.
     */
    if (!entry_info->type) {
	const char *cp2;
	HTFormat format;
	HTAtom *encoding;	/* @@@@ not used at all */

	format = HTFileFormat(entry_info->filename, &encoding, &cp2);

	if (cp2 == NULL) {
	    if (!StrNCmp(HTAtom_name(format), "application", 11)) {
		cp2 = HTAtom_name(format) + 12;
		if (!StrNCmp(cp2, "x-", 2))
		    cp2 += 2;
	    } else {
		cp2 = HTAtom_name(format);
	    }
	}

	StrAllocCopy(entry_info->type, cp2);
    }

    return (entry_info);
}

static void formatDate(char target[16], EntryInfo *entry)
{
    char temp[8], month[4];
    int i;

    /*
     * Set up for sorting in reverse chronological order. - FM
     */
    if (entry->date[9] == ':') {
	strcpy(target, "9999");
	LYStrNCpy(temp, &entry->date[7], 5);
	if (temp[0] == ' ') {
	    temp[0] = '0';
	}
    } else {
	LYStrNCpy(target, &entry->date[8], 4);
	strcpy(temp, "00:00");
    }
    LYStrNCpy(month, entry->date, 3);
    for (i = 0; i < 12; i++) {
	if (!strcasecomp(month, months[i])) {
	    break;
	}
    }
    i++;
    sprintf(month, "%02d", i);
    strcat(target, month);
    StrNCat(target, &entry->date[4], 2);
    if (target[6] == ' ' || target[6] == HT_NON_BREAK_SPACE) {
	target[6] = '0';
    }

    /* If no year given, assume last year if it would otherwise be in the
     * future by more than one day.  The one day tolerance is to account for a
     * possible timezone difference. - kw
     */
    if (target[0] == '9' && atoi(target) > TheDate + 1) {
	for (i = 0; i < 4; i++) {
	    target[i] = LastYear[i];
	}
    }
    strcat(target, temp);
}

static int compare_EntryInfo_structs(EntryInfo *entry1, EntryInfo *entry2)
{
    int status;
    char date1[16], date2[16];
    int result = strcmp(entry1->filename, entry2->filename);

    switch (HTfileSortMethod) {
    case FILE_BY_SIZE:
	/* both equal or both 0 */
	if (entry1->size > entry2->size)
	    result = 1;
	else if (entry1->size < entry2->size)
	    result = -1;
	break;

    case FILE_BY_TYPE:
	if (entry1->type && entry2->type) {
	    status = strcasecomp(entry1->type, entry2->type);
	    if (status)
		result = status;
	}
	break;

    case FILE_BY_DATE:
	if (entry1->date && entry2->date &&
	    strlen(entry1->date) == 12 &&
	    strlen(entry2->date) == 12) {
	    /*
	     * Set the years and date, if we don't have them yet.
	     */
	    if (!HaveYears) {
		set_years_and_date();
	    }
	    formatDate(date1, entry1);
	    formatDate(date2, entry2);
	    /*
	     * Do the comparison. - FM
	     */
	    status = strcasecomp(date2, date1);
	    if (status)
		result = status;
	}
	break;

    case FILE_BY_NAME:
    default:
	break;
    }
    return result;
}

#ifdef LONG_LIST
static char *FormatStr(char **bufp,
		       char *start,
		       const char *value)
{
    char fmt[512];

    if (*start) {
	sprintf(fmt, "%%%.*ss", (int) sizeof(fmt) - 3, start);
	HTSprintf(bufp, fmt, value);
    } else if (*bufp && !(value && *value)) {
	;
    } else if (value) {
	StrAllocCat(*bufp, value);
    }
    return *bufp;
}

static char *FormatSize(char **bufp,
			char *start,
			off_t value)
{
    char fmt[512];

    if (*start) {
	sprintf(fmt, "%%%.*s" PRI_off_t, (int) sizeof(fmt) - 3, start);

	HTSprintf(bufp, fmt, value);
    } else {
	sprintf(fmt, "%" PRI_off_t, value);

	StrAllocCat(*bufp, fmt);
    }
    return *bufp;
}

static char *FormatNum(char **bufp,
		       char *start,
		       unsigned long value)
{
    char fmt[512];

    if (*start) {
	sprintf(fmt, "%%%.*sld", (int) sizeof(fmt) - 3, start);
	HTSprintf(bufp, fmt, value);
    } else {
	sprintf(fmt, "%lu", value);
	StrAllocCat(*bufp, fmt);
    }
    return *bufp;
}

static void FlushParse(HTStructured * target, char **buf)
{
    if (*buf && **buf) {
	PUTS(*buf);
	**buf = '\0';
    }
}

static void LYListFmtParse(const char *fmtstr,
			   EntryInfo *data,
			   HTStructured * target,
			   char *tail)
{
    char c;
    char *s;
    char *end;
    char *start;
    char *str = NULL;
    char *buf = NULL;
    BOOL is_directory = (BOOL) (data->file_mode != 0 &&
				(TOUPPER(data->file_mode[0]) == 'D'));
    BOOL is_symlinked = (BOOL) (data->file_mode != 0 &&
				(TOUPPER(data->file_mode[0]) == 'L'));
    BOOL remove_size = (BOOL) (is_directory || is_symlinked);

    StrAllocCopy(str, fmtstr);
    s = str;
    end = str + strlen(str);
    while (*s) {
	start = s;
	while (*s) {
	    if (*s == '%') {
		if (*(s + 1) == '%')	/* literal % */
		    s++;
		else
		    break;
	    }
	    s++;
	}
	/* s is positioned either at a % or at \0 */
	*s = '\0';
	if (s > start) {	/* some literal chars. */
	    StrAllocCat(buf, start);
	}
	if (s == end)
	    break;
	start = ++s;
	while (isdigit(UCH(*s)) || *s == '.' || *s == '-' || *s == ' ' ||
	       *s == '#' || *s == '+' || *s == '\'')
	    s++;
	c = *s;			/* the format char. or \0 */
	*s = '\0';

	switch (c) {
	case '\0':
	    StrAllocCat(buf, start);
	    continue;

	case 'A':
	case 'a':		/* anchor */
	    FlushParse(target, &buf);
	    HTDirEntry(target, tail, data->filename);
	    FormatStr(&buf, start, data->filename);
	    PUTS(buf);
	    END(HTML_A);
	    if (buf != 0)
		*buf = '\0';
	    if (c != 'A' && data->linkname != 0) {
		PUTS(" -> ");
		PUTS(data->linkname);
	    }
	    break;

	case 'T':		/* MIME type */
	case 't':		/* MIME type description */
	    if (is_directory) {
		if (c != 'T') {
		    FormatStr(&buf, start, ENTRY_IS_DIRECTORY);
		} else {
		    FormatStr(&buf, start, "");
		}
	    } else if (is_symlinked) {
		if (c != 'T') {
		    FormatStr(&buf, start, ENTRY_IS_SYMBOLIC_LINK);
		} else {
		    FormatStr(&buf, start, "");
		}
	    } else {
		const char *cp2;
		HTFormat format;

		format = HTFileFormat(data->filename, NULL, &cp2);

		if (c != 'T') {
		    if (cp2 == NULL) {
			if (!StrNCmp(HTAtom_name(format),
				     "application", 11)) {
			    cp2 = HTAtom_name(format) + 12;
			    if (!StrNCmp(cp2, "x-", 2))
				cp2 += 2;
			} else {
			    cp2 = HTAtom_name(format);
			}
		    }
		    FormatStr(&buf, start, cp2);
		} else {
		    FormatStr(&buf, start, HTAtom_name(format));
		}
	    }
	    break;

	case 'd':		/* date */
	    if (data->date) {
		FormatStr(&buf, start, data->date);
	    } else {
		FormatStr(&buf, start, " * ");
	    }
	    break;

	case 's':		/* size in bytes */
	    FormatSize(&buf, start, data->size);
	    break;

	case 'K':		/* size in Kilobytes but not for directories */
	    if (remove_size) {
		FormatStr(&buf, start, "");
		StrAllocCat(buf, " ");
		break;
	    }
	    /* FALL THROUGH */
	case 'k':		/* size in Kilobytes */
	    /* FIXME - this is inconsistent with HTFile.c, but historical */
	    if (data->size < 1024) {
		FormatSize(&buf, start, data->size);
		StrAllocCat(buf, " bytes");
	    } else {
		FormatSize(&buf, start, data->size / 1024);
		StrAllocCat(buf, "Kb");
	    }
	    break;

#ifdef LONG_LIST
	case 'p':		/* unix-style permission bits */
	    FormatStr(&buf, start, NonNull(data->file_mode));
	    break;

	case 'o':		/* owner */
	    FormatStr(&buf, start, NonNull(data->file_user));
	    break;

	case 'g':		/* group */
	    FormatStr(&buf, start, NonNull(data->file_group));
	    break;

	case 'l':		/* link count */
	    FormatNum(&buf, start, data->file_links);
	    break;
#endif

	case '%':		/* literal % with flags/width */
	    FormatStr(&buf, start, "%");
	    break;

	default:
	    fprintf(stderr,
		    "Unknown format character `%c' in list format\n", c);
	    break;
	}

	s++;
    }
    if (buf) {
	LYTrimTrailing(buf);
	FlushParse(target, &buf);
	FREE(buf);
    }
    PUTC('\n');
    FREE(str);
}
#endif /* LONG_LIST */

/*	Read a directory into an hypertext object from the data socket
 *	--------------------------------------------------------------
 *
 * On entry,
 *	anchor		Parent anchor to link the this node to
 *	address		Address of the directory
 * On exit,
 *	returns		HT_LOADED if OK
 *			<0 if error.
 */
static int read_directory(HTParentAnchor *parent,
			  const char *address,
			  HTFormat format_out,
			  HTStream *sink)
{
    int status;
    BOOLEAN WasInterrupted = FALSE;
    HTStructured *target = HTML_new(parent, format_out, sink);
    char *filename = HTParse(address, "", PARSE_PATH + PARSE_PUNCTUATION);
    EntryInfo *entry_info;
    BOOLEAN first = TRUE;
    char *lastpath = NULL;	/* prefix for link, either "" (for root) or xxx  */
    BOOL tildeIsTop = FALSE;

#ifndef LONG_LIST
    char string_buffer[64];
#endif

    _HTProgress(gettext("Receiving FTP directory."));

    /*
     * Force the current Date and Year (TheDate, ThisYear, and LastYear) to be
     * recalculated for each directory request.  Otherwise we have a problem
     * with long-running sessions assuming the wrong date for today.  - kw
     */
    HaveYears = FALSE;
    /*
     * Check whether we always want the home directory treated as Welcome.  -
     * FM
     */
    if (server_type == VMS_SERVER)
	tildeIsTop = TRUE;

    /*
     * This should always come back FALSE, since the flag is set only for local
     * directory listings if LONG_LIST was defined on compilation, but we could
     * someday set up an equivalent listing for Unix ftp servers.  - FM
     */
    (void) HTDirTitles(target, parent, format_out, tildeIsTop);

    data_read_pointer = data_write_pointer = data_buffer;

    if (*filename == '\0') {	/* Empty filename: use root. */
	StrAllocCopy(lastpath, "/");
    } else if (!strcmp(filename, "/")) {	/* Root path. */
	StrAllocCopy(lastpath, "/foo/..");
    } else {
	char *p = strrchr(filename, '/');	/* Find the lastslash. */
	char *cp;

	if (server_type == CMS_SERVER) {
	    StrAllocCopy(lastpath, filename);	/* Use absolute path for CMS. */
	} else {
	    StrAllocCopy(lastpath, p + 1);	/* Take slash off the beginning. */
	}
	if ((cp = strrchr(lastpath, ';')) != NULL) {	/* Trim type= param. */
	    if (!strncasecomp((cp + 1), "type=", 5)) {
		if (TOUPPER(*(cp + 6)) == 'D' ||
		    TOUPPER(*(cp + 6)) == 'A' ||
		    TOUPPER(*(cp + 6)) == 'I')
		    *cp = '\0';
	    }
	}
    }
    FREE(filename);

    {
	HTBTree *bt = HTBTree_new((HTComparer) compare_EntryInfo_structs);
	int ic;
	HTChunk *chunk = HTChunkCreate(128);
	int BytesReceived = 0;
	int BytesReported = 0;
	char NumBytes[64];
	char *spilledname = NULL;

	PUTC('\n');		/* prettier LJM */
	for (ic = 0; ic != EOF;) {	/* For each entry in the directory */
	    HTChunkClear(chunk);

	    if (HTCheckForInterrupt()) {
		CTRACE((tfp,
			"read_directory: interrupted after %d bytes\n",
			BytesReceived));
		WasInterrupted = TRUE;
		if (BytesReceived) {
		    goto unload_btree;	/* unload btree */
		} else {
		    ABORT_TARGET;
		    HTBTreeAndObject_free(bt);
		    FREE(spilledname);
		    HTChunkFree(chunk);
		    return HT_INTERRUPTED;
		}
	    }

	    /*   read directory entry
	     */
	    interrupted_in_next_data_char = FALSE;
	    for (;;) {		/* Read in one line as filename */
		ic = NEXT_DATA_CHAR;
	      AgainForMultiNet:
		if (interrupted_in_next_data_char) {
		    CTRACE((tfp,
			    "read_directory: interrupted_in_next_data_char after %d bytes\n",
			    BytesReceived));
		    WasInterrupted = TRUE;
		    if (BytesReceived) {
			goto unload_btree;	/* unload btree */
		    } else {
			ABORT_TARGET;
			HTBTreeAndObject_free(bt);
			FREE(spilledname);
			HTChunkFree(chunk);
			return HT_INTERRUPTED;
		    }
		} else if ((char) ic == CR || (char) ic == LF) {	/* Terminator? */
		    if (chunk->size != 0) {	/* got some text */
			/* Deal with MultiNet's wrapping of long lines */
			if (server_type == VMS_SERVER) {
			    /* Deal with MultiNet's wrapping of long lines - F.M. */
			    if (data_read_pointer < data_write_pointer &&
				*(data_read_pointer + 1) == ' ')
				data_read_pointer++;
			    else if (data_read_pointer >= data_write_pointer) {
				status = NETREAD(data_soc, data_buffer,
						 DATA_BUFFER_SIZE);
				if (status == HT_INTERRUPTED) {
				    interrupted_in_next_data_char = 1;
				    goto AgainForMultiNet;
				}
				if (status <= 0) {
				    ic = EOF;
				    break;
				}
				data_write_pointer = data_buffer + status;
				data_read_pointer = data_buffer;
				if (*data_read_pointer == ' ')
				    data_read_pointer++;
				else
				    break;
			    } else
				break;
			} else
			    break;	/* finish getting one entry */
		    }
		} else if (ic == EOF) {
		    break;	/* End of file */
		} else {
		    HTChunkPutc(chunk, UCH(ic));
		}
	    }
	    HTChunkTerminate(chunk);

	    BytesReceived += chunk->size;
	    if (BytesReceived > BytesReported + 1024) {
#ifdef _WINDOWS
		sprintf(NumBytes, gettext("Transferred %d bytes (%5d)"),
			BytesReceived, ws_read_per_sec);
#else
		sprintf(NumBytes, TRANSFERRED_X_BYTES, BytesReceived);
#endif
		HTProgress(NumBytes);
		BytesReported = BytesReceived;
	    }

	    if (ic == EOF && chunk->size == 1)
		/* 1 means empty: includes terminating 0 */
		break;
	    CTRACE((tfp, "HTFTP: Line in %s is %s\n",
		    lastpath, chunk->data));

	    entry_info = parse_dir_entry(chunk->data, &first, &spilledname);
	    if (entry_info->display) {
		FREE(spilledname);
		CTRACE((tfp, "Adding file to BTree: %s\n",
			entry_info->filename));
		HTBTree_add(bt, entry_info);
	    } else {
		free_entryinfo_struct_contents(entry_info);
		FREE(entry_info);
	    }

	}			/* next entry */

      unload_btree:

	HTChunkFree(chunk);
	FREE(spilledname);

	/* print out the handy help message if it exists :) */
	if (help_message_cache_non_empty()) {
	    START(HTML_PRE);
	    START(HTML_HR);
	    PUTC('\n');
	    PUTS(help_message_cache_contents());
	    init_help_message_cache();	/* to free memory */
	    START(HTML_HR);
	    PUTC('\n');
	} else {
	    START(HTML_PRE);
	    PUTC('\n');
	}

	/* Run through tree printing out in order
	 */
	{
#ifndef LONG_LIST
#ifdef SH_EX			/* 1997/10/18 (Sat) 14:14:28 */
	    char *p, name_buff[256];
	    int name_len, dot_len;

#define	FNAME_WIDTH	30
#define	FILE_GAP	1

#endif
	    int i;
#endif
	    HTBTElement *ele;

	    for (ele = HTBTree_next(bt, NULL);
		 ele != NULL;
		 ele = HTBTree_next(bt, ele)) {
		entry_info = (EntryInfo *) HTBTree_object(ele);

#ifdef LONG_LIST
		LYListFmtParse(ftp_format,
			       entry_info,
			       target,
			       lastpath);
#else
		if (entry_info->date) {
		    PUTS(entry_info->date);
		    PUTS("  ");
		} else {
		    PUTS("     * ");
		}

		if (entry_info->type) {
		    for (i = 0; entry_info->type[i] != '\0' && i < 16; i++)
			PUTC(entry_info->type[i]);
		    for (; i < 17; i++)
			PUTC(' ');
		}
		/* start the anchor */
		HTDirEntry(target, lastpath, entry_info->filename);
#ifdef SH_EX			/* 1997/10/18 (Sat) 16:00 */
		name_len = strlen(entry_info->filename);

		sprintf(name_buff, "%-*s", FNAME_WIDTH, entry_info->filename);

		if (name_len < FNAME_WIDTH) {
		    dot_len = FNAME_WIDTH - FILE_GAP - name_len;
		    if (dot_len > 0) {
			p = name_buff + name_len + 1;
			while (dot_len-- > 0)
			    *p++ = '.';
		    }
		} else {
		    name_buff[FNAME_WIDTH] = '\0';
		}

		PUTS(name_buff);
#else
		PUTS(entry_info->filename);
#endif
		END(HTML_A);

		if (entry_info->size) {
#ifdef SH_EX			/* 1998/02/02 (Mon) 16:34:52 */
		    if (entry_info->size < 1024)
			sprintf(string_buffer, "%6ld bytes",
				entry_info->size);
		    else
			sprintf(string_buffer, "%6ld Kb",
				entry_info->size / 1024);
#else
		    if (entry_info->size < 1024)
			sprintf(string_buffer, "  %lu bytes",
				entry_info->size);
		    else
			sprintf(string_buffer, "  %luKb",
				entry_info->size / 1024);
#endif
		    PUTS(string_buffer);
		} else if (entry_info->linkname != 0) {
		    PUTS(" -> ");
		    PUTS(entry_info->linkname);
		}

		PUTC('\n');	/* end of this entry */
#endif

		free_entryinfo_struct_contents(entry_info);
	    }
	}
	END(HTML_PRE);
	END(HTML_BODY);
	FREE_TARGET;
	HTBTreeAndObject_free(bt);
    }

    FREE(lastpath);

    if (WasInterrupted || data_soc != -1) {	/* should always be true */
	/*
	 * Without closing the data socket first, the response(0) later may
	 * hang.  Some servers expect the client to fin/ack the close of the
	 * data connection before proceeding with the conversation on the
	 * control connection.  - kw
	 */
	CTRACE((tfp, "HTFTP: Closing data socket %d\n", data_soc));
	status = NETCLOSE(data_soc);
	if (status == -1)
	    HTInetStatus("close");	/* Comment only */
	data_soc = -1;
    }

    if (WasInterrupted || HTCheckForInterrupt()) {
	_HTProgress(TRANSFER_INTERRUPTED);
    }
    return HT_LOADED;
}

/*
 * Setup an FTP connection.
 */
static int setup_connection(const char *name,
			    HTParentAnchor *anchor)
{
    int retry;			/* How many times tried? */
    int status = HT_NO_CONNECTION;

    CTRACE((tfp, "setup_connection(%s)\n", name));

    /* set use_list to NOT since we don't know what kind of server
     * this is yet.  And set the type to GENERIC
     */
    use_list = FALSE;
    server_type = GENERIC_SERVER;
    Broken_RETR = FALSE;

#ifdef INET6
    Broken_EPSV = FALSE;
#endif

    for (retry = 0; retry < 2; retry++) {	/* For timed out/broken connections */
	status = get_connection(name, anchor);
	if (status < 0) {
	    break;
	}

	if (!ftp_local_passive) {
	    status = get_listen_socket();
	    if (status < 0) {
		NETCLOSE(control->socket);
		control->socket = -1;
#ifdef INET6
		if (have_socket)
		    (void) close_master_socket();
#else
		close_master_socket();
#endif /* INET6 */
		/* HT_INTERRUPTED would fall through, if we could interrupt
		   somehow in the middle of it, which we currently can't. */
		break;
	    }
#ifdef REPEAT_PORT
	    /*  Inform the server of the port number we will listen on
	     */
	    status = response(port_command);
	    if (status == HT_INTERRUPTED) {
		CTRACE((tfp, "HTFTP: Interrupted in response (port_command)\n"));
		_HTProgress(CONNECTION_INTERRUPTED);
		NETCLOSE(control->socket);
		control->socket = -1;
		close_master_socket();
		status = HT_INTERRUPTED;
		break;
	    }
	    if (status != 2) {	/* Could have timed out */
		if (status < 0)
		    continue;	/* try again - net error */
		status = -status;	/* bad reply */
		break;
	    }
	    CTRACE((tfp, "HTFTP: Port defined.\n"));
#endif /* REPEAT_PORT */
	} else {		/* Tell the server to be passive */
	    char *command = NULL;
	    const char *p = "?";
	    int h0, h1, h2, h3, p0, p1;		/* Parts of reply */

#ifdef INET6
	    char dst[LINE_LENGTH + 1];
#endif

	    data_soc = status;

#ifdef INET6
	    /* see RFC 2428 */
	    if (Broken_EPSV)
		status = 1;
	    else
		status = send_cmd_1(p = "EPSV");
	    if (status < 0)	/* retry or Bad return */
		continue;
	    else if (status != 2) {
		status = send_cmd_1(p = "PASV");
		if (status < 0) {	/* retry or Bad return */
		    continue;
		} else if (status != 2) {
		    status = -status;	/* bad reply */
		    break;
		}
	    }

	    if (strcmp(p, "PASV") == 0) {
		for (p = response_text; *p && *p != ','; p++) {
		    ;		/* null body */
		}

		while (--p > response_text && '0' <= *p && *p <= '9') {
		    ;		/* null body */
		}
		status = sscanf(p + 1, "%d,%d,%d,%d,%d,%d",
				&h0, &h1, &h2, &h3, &p0, &p1);
		if (status < 4) {
		    fprintf(tfp, "HTFTP: PASV reply has no inet address!\n");
		    status = HT_NO_CONNECTION;
		    break;
		}
		passive_port = (PortNumber) ((p0 << 8) + p1);
		sprintf(dst, "%d.%d.%d.%d", h0, h1, h2, h3);
	    } else if (strcmp(p, "EPSV") == 0) {
		char c0, c1, c2, c3;
		struct sockaddr_storage ss;
		LY_SOCKLEN sslen;

		/*
		 * EPSV bla (|||port|)
		 */
		for (p = response_text; *p && !isspace(UCH(*p)); p++) {
		    ;		/* null body */
		}
		for ( /*nothing */ ;
		     *p && *p != '(';
		     p++) {	/*) */
		    ;		/* null body */
		}
		status = sscanf(p, "(%c%c%c%d%c)", &c0, &c1, &c2, &p0, &c3);
		if (status != 5) {
		    fprintf(tfp, "HTFTP: EPSV reply has invalid format!\n");
		    status = HT_NO_CONNECTION;
		    break;
		}
		passive_port = (PortNumber) p0;

		sslen = (LY_SOCKLEN) sizeof(ss);
		if (getpeername(control->socket, (struct sockaddr *) &ss,
				&sslen) < 0) {
		    fprintf(tfp, "HTFTP: getpeername(control) failed\n");
		    status = HT_NO_CONNECTION;
		    break;
		}
		if (getnameinfo((struct sockaddr *) &ss,
				sslen,
				dst,
				(socklen_t) sizeof(dst),
				NULL, 0, NI_NUMERICHOST)) {
		    fprintf(tfp, "HTFTP: getnameinfo failed\n");
		    status = HT_NO_CONNECTION;
		    break;
		}
	    }
#else
	    status = send_cmd_1("PASV");
	    if (status != 2) {
		if (status < 0)
		    continue;	/* retry or Bad return */
		status = -status;	/* bad reply */
		break;
	    }
	    for (p = response_text; *p && *p != ','; p++) {
		;		/* null body */
	    }

	    while (--p > response_text && '0' <= *p && *p <= '9') {
		;		/* null body */
	    }

	    status = sscanf(p + 1, "%d,%d,%d,%d,%d,%d",
			    &h0, &h1, &h2, &h3, &p0, &p1);
	    if (status < 4) {
		fprintf(tfp, "HTFTP: PASV reply has no inet address!\n");
		status = HT_NO_CONNECTION;
		break;
	    }
	    passive_port = (PortNumber) ((p0 << 8) + p1);
#endif /* INET6 */
	    CTRACE((tfp, "HTFTP: Server is listening on port %d\n",
		    passive_port));

	    /* Open connection for data:  */

#ifdef INET6
	    HTSprintf0(&command, "%s//%s:%d/", STR_FTP_URL, dst, passive_port);
#else
	    HTSprintf0(&command, "%s//%d.%d.%d.%d:%d/",
		       STR_FTP_URL, h0, h1, h2, h3, passive_port);
#endif
	    status = HTDoConnect(command, "FTP data", passive_port, &data_soc);
	    FREE(command);

	    if (status < 0) {
		(void) HTInetStatus(gettext("connect for data"));
		NETCLOSE(data_soc);
		break;
	    }

	    CTRACE((tfp, "FTP data connected, socket %d\n", data_soc));
	}
	status = 0;
	break;			/* No more retries */

    }				/* for retries */
    CTRACE((tfp, "setup_connection returns %d\n", status));
    return status;
}

/*	Retrieve File from Server
 *	-------------------------
 *
 * On entry,
 *	name		WWW address of a file: document, including hostname
 * On exit,
 *	returns		Socket number for file if good.
 *			<0 if bad.
 */
int HTFTPLoad(const char *name,
	      HTParentAnchor *anchor,
	      HTFormat format_out,
	      HTStream *sink)
{
    BOOL isDirectory = NO;
    HTAtom *encoding = NULL;
    int status, final_status;
    int outstanding = 1;	/* outstanding control connection responses

				   that we are willing to wait for, if we
				   get to the point of reading data - kw */
    HTFormat format;

    CTRACE((tfp, "HTFTPLoad(%s) %s connection\n",
	    name,
	    (ftp_local_passive
	     ? "passive"
	     : "normal")));

    HTReadProgress((off_t) 0, (off_t) 0);

    status = setup_connection(name, anchor);
    if (status < 0)
	return status;		/* Failed with this code */

    /*  Ask for the file:
     */
    {
	char *filename = HTParse(name, "", PARSE_PATH + PARSE_PUNCTUATION);
	char *fname = filename;	/* Save for subsequent free() */
	char *vmsname = NULL;
	BOOL binary;
	const char *type = NULL;
	char *types = NULL;
	char *cp;

	if (server_type == CMS_SERVER) {
	    /* If the unescaped path has a %2f, reject it as illegal. - FM */
	    if (((cp = strstr(filename, "%2")) != NULL) &&
		TOUPPER(cp[2]) == 'F') {
		FREE(fname);
		init_help_message_cache();	/* to free memory */
		NETCLOSE(control->socket);
		control->socket = -1;
		CTRACE((tfp,
			"HTFTP: Rejecting path due to illegal escaped slash.\n"));
		return -1;
	    }
	}

	if (!*filename) {
	    StrAllocCopy(filename, "/");
	    type = "D";
	} else if ((type = types = strrchr(filename, ';')) != NULL) {
	    /*
	     * Check and trim the type= parameter.  - FM
	     */
	    if (!strncasecomp((type + 1), "type=", 5)) {
		switch (TOUPPER(*(type + 6))) {
		case 'D':
		    *types = '\0';
		    type = "D";
		    break;
		case 'A':
		    *types = '\0';
		    type = "A";
		    break;
		case 'I':
		    *types = '\0';
		    type = "I";
		    break;
		default:
		    type = "";
		    break;
		}
		if (!*filename) {
		    *filename = '/';
		    *(filename + 1) = '\0';
		}
	    }
	    if (*type != '\0') {
		CTRACE((tfp, "HTFTP: type=%s\n", type));
	    }
	}
	HTUnEscape(filename);
	CTRACE((tfp, "HTFTP: UnEscaped %s\n", filename));
	if (filename[1] == '~') {
	    /*
	     * Check if translation of HOME as tilde is supported,
	     * and adjust filename if so. - FM
	     */
	    char *cp2 = NULL;
	    char *fn = NULL;

	    if ((cp2 = strchr((filename + 1), '/')) != NULL) {
		*cp2 = '\0';
	    }
	    status = send_cmd_1("PWD");
	    if (status == 2 && response_text[5] == '/') {
		status = send_cwd(filename + 1);
		if (status == 2) {
		    StrAllocCopy(fn, (filename + 1));
		    if (cp2) {
			*cp2 = '/';
			if (fn[strlen(fn) - 1] != '/') {
			    StrAllocCat(fn, cp2);
			} else {
			    StrAllocCat(fn, (cp2 + 1));
			}
			cp2 = NULL;
		    }
		    FREE(fname);
		    fname = filename = fn;
		}
	    }
	    if (cp2) {
		*cp2 = '/';
	    }
	}
	if (strlen(filename) > 3) {
	    char *cp2;

	    if (((cp2 = strrchr(filename, '.')) != NULL &&
		 0 == strncasecomp(cp2, ".me", 3)) &&
		(cp2[3] == '\0' || cp2[3] == ';')) {
		/*
		 * Don't treat this as application/x-Troff-me if it's a Unix
		 * server but has the string "read.me", or if it's not a Unix
		 * server.  - FM
		 */
		if ((server_type != UNIX_SERVER) ||
		    (cp2 > (filename + 3) &&
		     0 == strncasecomp((cp2 - 4), "read.me", 7))) {
		    *cp2 = '\0';
		    format = HTFileFormat(filename, &encoding, NULL);
		    *cp2 = '.';
		} else {
		    format = HTFileFormat(filename, &encoding, NULL);
		}
	    } else {
		format = HTFileFormat(filename, &encoding, NULL);
	    }
	} else {
	    format = HTFileFormat(filename, &encoding, NULL);
	}
	format = HTCharsetFormat(format, anchor, -1);
	binary = (BOOL) (encoding != HTAtom_for("8bit") &&
			 encoding != HTAtom_for("7bit"));
	if (!binary &&
	/*
	 * Force binary if we're in source, download or dump mode and this is
	 * not a VM/CMS server, so we don't get CRLF instead of LF (or CR) for
	 * newlines in text files.  Can't do this for VM/CMS or we'll get raw
	 * EBCDIC.  - FM
	 */
	    (format_out == WWW_SOURCE ||
	     format_out == HTAtom_for("www/download") ||
	     format_out == HTAtom_for("www/dump")) &&
	    (server_type != CMS_SERVER))
	    binary = TRUE;
	if (!binary && type && *type == 'I') {
	    /*
	     * Force binary if we had ;type=I - FM
	     */
	    binary = TRUE;
	} else if (binary && type && *type == 'A') {
	    /*
	     * Force ASCII if we had ;type=A - FM
	     */
	    binary = FALSE;
	}
	if (binary != control->binary) {
	    /*
	     * Act on our setting if not already set.  - FM
	     */
	    const char *mode = binary ? "I" : "A";

	    status = send_cmd_2("TYPE", mode);
	    if (status != 2) {
		init_help_message_cache();	/* to free memory */
		return ((status < 0) ? status : -status);
	    }
	    control->binary = binary;
	}
	switch (server_type) {
	    /*
	     * Handle what for Lynx are special case servers, e.g., for which
	     * we respect RFC 1738, or which have known conflicts in suffix
	     * mappings.  - FM
	     */
	case VMS_SERVER:
	    {
		char *cp1, *cp2;
		BOOL included_device = FALSE;
		BOOL found_tilde = FALSE;

		/* Accept only Unix-style filename */
		if (strchr(filename, ':') != NULL ||
		    strchr(filename, '[') != NULL) {
		    FREE(fname);
		    init_help_message_cache();	/* to free memory */
		    NETCLOSE(control->socket);
		    control->socket = -1;
		    CTRACE((tfp,
			    "HTFTP: Rejecting path due to non-Unix-style syntax.\n"));
		    return -1;
		}
		/* Handle any unescaped "/%2F" path */
		if (!StrNCmp(filename, "//", 2)) {
		    int i;

		    included_device = TRUE;
		    for (i = 0; filename[(i + 1)]; i++)
			filename[i] = filename[(i + 1)];
		    filename[i] = '\0';
		    CTRACE((tfp, "HTFTP: Trimmed '%s'\n", filename));
		    cp = HTVMS_name("", filename);
		    CTRACE((tfp, "HTFTP: VMSized '%s'\n", cp));
		    if ((cp1 = strrchr(cp, ']')) != NULL) {
			strcpy(filename, ++cp1);
			CTRACE((tfp, "HTFTP: Filename '%s'\n", filename));
			*cp1 = '\0';
			status = send_cwd(cp);
			if (status != 2) {
			    char *dotslash = 0;

			    if ((cp1 = strchr(cp, '[')) != NULL) {
				*cp1++ = '\0';
				status = send_cwd(cp);
				if (status != 2) {
				    FREE(fname);
				    init_help_message_cache();	/* to free memory */
				    NETCLOSE(control->socket);
				    control->socket = -1;
				    return ((status < 0) ? status : -status);
				}
				HTSprintf0(&dotslash, "[.%s", cp1);
				status = send_cwd(dotslash);
				FREE(dotslash);
				if (status != 2) {
				    FREE(fname);
				    init_help_message_cache();	/* to free memory */
				    NETCLOSE(control->socket);
				    control->socket = -1;
				    return ((status < 0) ? status : -status);
				}
			    } else {
				FREE(fname);
				init_help_message_cache();	/* to free memory */
				NETCLOSE(control->socket);
				control->socket = -1;
				return ((status < 0) ? status : -status);
			    }
			}
		    } else if ((cp1 = strchr(cp, ':')) != NULL &&
			       strchr(cp, '[') == NULL &&
			       strchr(cp, ']') == NULL) {
			cp1++;
			if (*cp1 != '\0') {
			    int cplen = (int) (cp1 - cp);

			    strcpy(filename, cp1);
			    CTRACE((tfp, "HTFTP: Filename '%s'\n", filename));
			    HTSprintf0(&vmsname, "%.*s[%s]", cplen, cp, filename);
			    status = send_cwd(vmsname);
			    if (status != 2) {
				HTSprintf(&vmsname, "%.*s[000000]", cplen, cp);
				status = send_cwd(vmsname);
				if (status != 2) {
				    HTSprintf(&vmsname, "%.*s", cplen, cp);
				    status = send_cwd(vmsname);
				    if (status != 2) {
					FREE(fname);
					init_help_message_cache();
					NETCLOSE(control->socket);
					control->socket = -1;
					return ((status < 0) ? status : -status);
				    }
				}
			    } else {
				HTSprintf0(&vmsname, "000000");
				filename = vmsname;
			    }
			}
		    } else if (0 == strcmp(cp, (filename + 1))) {
			status = send_cwd(cp);
			if (status != 2) {
			    HTSprintf0(&vmsname, "%s:", cp);
			    status = send_cwd(vmsname);
			    if (status != 2) {
				FREE(fname);
				init_help_message_cache();	/* to free memory */
				NETCLOSE(control->socket);
				control->socket = -1;
				return ((status < 0) ? status : -status);
			    }
			}
			HTSprintf0(&vmsname, "000000");
			filename = vmsname;
		    }
		}
		/* Trim trailing slash if filename is not the top directory */
		if (strlen(filename) > 1 && filename[strlen(filename) - 1] == '/')
		    filename[strlen(filename) - 1] = '\0';

#ifdef MAINTAIN_CONNECTION	/* Don't need this if always new connection - F.M. */
		if (!included_device) {
		    /* Get the current default VMS device:[directory] */
		    status = send_cmd_1("PWD");
		    if (status != 2) {
			FREE(fname);
			init_help_message_cache();	/* to free memory */
			NETCLOSE(control->socket);
			control->socket = -1;
			return ((status < 0) ? status : -status);
		    }
		    /* Go to the VMS account's top directory */
		    if ((cp = strchr(response_text, '[')) != NULL &&
			(cp1 = strrchr(response_text, ']')) != NULL) {
			char *tmp = 0;
			unsigned len = 4;

			StrAllocCopy(tmp, cp);
			if ((cp2 = strchr(cp, '.')) != NULL && cp2 < cp1) {
			    len += (cp2 - cp);
			} else {
			    len += (cp1 - cp);
			}
			tmp[len] = 0;
			StrAllocCat(tmp, "]");

			status = send_cwd(tmp);
			FREE(tmp);

			if (status != 2) {
			    FREE(fname);
			    init_help_message_cache();	/* to free memory */
			    NETCLOSE(control->socket);
			    control->socket = -1;
			    return ((status < 0) ? status : -status);
			}
		    }
		}
#endif /* MAINTAIN_CONNECTION */

		/* If we want the VMS account's top directory, list it now */
		if (!(strcmp(filename, "/~")) ||
		    (included_device && 0 == strcmp(filename, "000000")) ||
		    (strlen(filename) == 1 && *filename == '/')) {
		    isDirectory = YES;
		    status = send_cmd_1("LIST");
		    FREE(fname);
		    if (status != 1) {
			/* Action not started */
			init_help_message_cache();	/* to free memory */
			NETCLOSE(control->socket);
			control->socket = -1;
			return ((status < 0) ? status : -status);
		    }
		    /* Big goto! */
		    goto listen;
		}
		/* Otherwise, go to appropriate directory and doctor filename */
		if (!StrNCmp(filename, "/~", 2)) {
		    filename += 2;
		    found_tilde = TRUE;
		}
		CTRACE((tfp, "check '%s' to translate x/y/ to [.x.y]\n", filename));
		if (!included_device &&
		    (cp = strchr(filename, '/')) != NULL &&
		    (cp1 = strrchr(cp, '/')) != NULL &&
		    (cp1 - cp) > 1) {
		    char *tmp = 0;

		    HTSprintf0(&tmp, "[.%.*s]", (int) (cp1 - cp - 1), cp + 1);

		    CTRACE((tfp, "change path '%s'\n", tmp));
		    while ((cp2 = strrchr(tmp, '/')) != NULL)
			*cp2 = '.';
		    CTRACE((tfp, "...to  path '%s'\n", tmp));

		    status = send_cwd(tmp);
		    FREE(tmp);

		    if (status != 2) {
			FREE(fname);
			init_help_message_cache();	/* to free memory */
			NETCLOSE(control->socket);
			control->socket = -1;
			return ((status < 0) ? status : -status);
		    }
		    filename = cp1 + 1;
		} else {
		    if (!included_device && !found_tilde) {
			filename += 1;
		    }
		}
		break;
	    }
	case CMS_SERVER:
	    {
		/*
		 * If we want the CMS account's top directory, or a base SFS or
		 * anonymous directory path (i.e., without a slash), list it
		 * now.  FM
		 */
		if ((strlen(filename) == 1 && *filename == '/') ||
		    ((0 == strncasecomp((filename + 1), "vmsysu:", 7)) &&
		     (cp = strchr((filename + 1), '.')) != NULL &&
		     strchr(cp, '/') == NULL) ||
		    (0 == strncasecomp(filename + 1, "anonymou.", 9) &&
		     strchr(filename + 1, '/') == NULL)) {
		    if (filename[1] != '\0') {
			status = send_cwd(filename + 1);
			if (status != 2) {
			    /* Action not started */
			    init_help_message_cache();	/* to free memory */
			    NETCLOSE(control->socket);
			    control->socket = -1;
			    return ((status < 0) ? status : -status);
			}
		    }
		    isDirectory = YES;
		    if (use_list)
			status = send_cmd_1("LIST");
		    else
			status = send_cmd_1("NLST");
		    FREE(fname);
		    if (status != 1) {
			/* Action not started */
			init_help_message_cache();	/* to free memory */
			NETCLOSE(control->socket);
			control->socket = -1;
			return ((status < 0) ? status : -status);
		    }
		    /* Big goto! */
		    goto listen;
		}
		filename++;

		/* Otherwise, go to appropriate directory and adjust filename */
		while ((cp = strchr(filename, '/')) != NULL) {
		    *cp++ = '\0';
		    status = send_cwd(filename);
		    if (status == 2) {
			if (*cp == '\0') {
			    isDirectory = YES;
			    if (use_list)
				status = send_cmd_1("LIST");
			    else
				status = send_cmd_1("NLST");
			    FREE(fname);
			    if (status != 1) {
				/* Action not started */
				init_help_message_cache();	/* to free memory */
				NETCLOSE(control->socket);
				control->socket = -1;
				return ((status < 0) ? status : -status);
			    }
			    /* Clear any messages from the login directory */
			    init_help_message_cache();
			    /* Big goto! */
			    goto listen;
			}
			filename = cp;
		    }
		}
		break;
	    }
	default:
	    /* Shift for any unescaped "/%2F" path */
	    if (!StrNCmp(filename, "//", 2))
		filename++;
	    break;
	}
	/*
	 * Act on a file or listing request, or try to figure out which we're
	 * dealing with if we don't know yet.  - FM
	 */
	if (!(type) || (type && *type != 'D')) {
	    /*
	     * If we are retrieving a file we will (except for CMS) use
	     * binary mode, which lets us use the size command supported by
	     * ftp servers which implement RFC 3659.  Knowing the size lets
	     * us in turn display ETA in the progress message -TD
	     */
	    if (control->binary) {
		int code;
		off_t size;

		status = send_cmd_2("SIZE", filename);
		if (status == 2 &&
		    sscanf(response_text, "%d %" PRI_off_t, &code, &size) == 2) {
		    anchor->content_length = size;
		}
	    }
	    status = send_cmd_2("RETR", filename);
	    if (status >= 5) {
		int check;

		if (Broken_RETR) {
		    CTRACE((tfp, "{{reconnecting...\n"));
		    close_connection(control);
		    check = setup_connection(name, anchor);
		    CTRACE((tfp, "...done }}reconnecting\n"));
		    if (check < 0)
			return check;
		}
	    }
	} else {
	    status = 5;		/* Failed status set as flag. - FM */
	}
	if (status != 1) {	/* Failed : try to CWD to it */
	    /* Clear any login messages if this isn't the login directory */
	    if (strcmp(filename, "/"))
		init_help_message_cache();

	    status = send_cwd(filename);
	    if (status == 2) {	/* Succeeded : let's NAME LIST it */
		isDirectory = YES;
		if (use_list)
		    status = send_cmd_1("LIST");
		else
		    status = send_cmd_1("NLST");
	    }
	}
	FREE(fname);
	FREE(vmsname);
	if (status != 1) {
	    init_help_message_cache();	/* to free memory */
	    NETCLOSE(control->socket);
	    control->socket = -1;
	    if (status < 0)
		return status;
	    else
		return -status;
	}
    }

  listen:
    if (!ftp_local_passive) {
	/* Wait for the connection */
#ifdef INET6
	struct sockaddr_storage soc_address;

#else
	struct sockaddr_in soc_address;
#endif /* INET6 */
	LY_SOCKLEN soc_addrlen = (LY_SOCKLEN) sizeof(soc_address);

#ifdef SOCKS
	if (socks_flag)
	    status = Raccept((int) master_socket,
			     (struct sockaddr *) &soc_address,
			     &soc_addrlen);
	else
#endif /* SOCKS */
	    status = accept((int) master_socket,
			    (struct sockaddr *) &soc_address,
			    &soc_addrlen);
	if (status < 0) {
	    init_help_message_cache();	/* to free memory */
	    return HTInetStatus("accept");
	}
	CTRACE((tfp, "TCP: Accepted new socket %d\n", status));
	data_soc = status;
    }

    if (isDirectory) {
	if (server_type == UNIX_SERVER && !unsure_type &&
	    !strcmp(response_text,
		    "150 Opening ASCII mode data connection for /bin/dl.\n")) {
	    CTRACE((tfp, "HTFTP: Treating as \"dls\" server.\n"));
	    server_type = DLS_SERVER;
	}
	final_status = read_directory(anchor, name, format_out, sink);
	if (final_status > 0) {
	    if (server_type != CMS_SERVER)
		if (outstanding-- > 0) {
		    status = response(0);
		    if (status < 0 ||
			(status == 2 && !StrNCmp(response_text, "221", 3)))
			outstanding = 0;
		}
	} else {		/* HT_INTERRUPTED */
	    /* User may have pressed 'z' to give up because no
	       packets got through, so let's not make them wait
	       any longer - kw */
	    outstanding = 0;
	}

	if (data_soc != -1) {	/* normally done in read_directory */
	    CTRACE((tfp, "HTFTP: Closing data socket %d\n", data_soc));
	    status = NETCLOSE(data_soc);
	    if (status == -1)
		HTInetStatus("close");	/* Comment only */
	}
	status = final_status;
    } else {
	int rv;
	char *FileName = HTParse(name, "", PARSE_PATH + PARSE_PUNCTUATION);

	/* Clear any login messages */
	init_help_message_cache();

	/* Fake a Content-Encoding for compressed files. - FM */
	HTUnEscape(FileName);
	if (!IsUnityEnc(encoding)) {
	    /*
	     * We already know from the call to HTFileFormat above that this is
	     * a compressed file, no need to look at the filename again.  - kw
	     */
	    StrAllocCopy(anchor->content_type, format->name);
	    StrAllocCopy(anchor->content_encoding, HTAtom_name(encoding));
	    format = HTAtom_for("www/compressed");

	} else {
	    int rootlen;
	    CompressFileType cft = HTCompressFileType(FileName, "._-", &rootlen);

	    if (cft != cftNone) {
		FileName[rootlen] = '\0';
		format = HTFileFormat(FileName, &encoding, NULL);
		format = HTCharsetFormat(format, anchor, -1);
		StrAllocCopy(anchor->content_type, format->name);
		format = HTAtom_for("www/compressed");
	    }

	    switch (cft) {
	    case cftCompress:
		StrAllocCopy(anchor->content_encoding, "x-compress");
		break;
	    case cftGzip:
		StrAllocCopy(anchor->content_encoding, "x-gzip");
		break;
	    case cftDeflate:
		StrAllocCopy(anchor->content_encoding, "x-deflate");
		break;
	    case cftBzip2:
		StrAllocCopy(anchor->content_encoding, "x-bzip2");
		break;
	    case cftNone:
		break;
	    }
	}
	FREE(FileName);

	_HTProgress(gettext("Receiving FTP file."));
	rv = HTParseSocket(format, format_out, anchor, data_soc, sink);

	HTInitInput(control->socket);
	/* Reset buffering to control connection DD 921208 */

	if (rv < 0) {
	    if (rv == -2)	/* weird error, don't expect much response */
		outstanding--;
	    else if (rv == HT_INTERRUPTED || rv == -1)
		/* User may have pressed 'z' to give up because no
		   packets got through, so let's not make them wait
		   longer - kw */
		outstanding = 0;
	    CTRACE((tfp, "HTFTP: Closing data socket %d\n", data_soc));
	    status = NETCLOSE(data_soc);
	} else {
	    status = 2;		/* data_soc already closed in HTCopy - kw */
	}

	if (status < 0 && rv != HT_INTERRUPTED && rv != -1) {
	    (void) HTInetStatus("close");	/* Comment only */
	} else {
	    if (rv != HT_LOADED && outstanding--) {
		status = response(0);	/* Pick up final reply */
		if (status != 2 && rv != HT_INTERRUPTED && rv != -1) {
		    data_soc = -1;	/* invalidate it */
		    init_help_message_cache();	/* to free memory */
		    return HTLoadError(sink, 500, response_text);
		} else if (status == 2 && !StrNCmp(response_text, "221", 3)) {
		    outstanding = 0;
		}
	    }
	}
	final_status = HT_LOADED;
    }
    while (outstanding-- > 0 &&
	   (status > 0)) {
	status = response(0);
	if (status == 2 && !StrNCmp(response_text, "221", 3))
	    break;
    }
    data_soc = -1;		/* invalidate it */
    CTRACE((tfp, "HTFTPLoad: normal end; "));
    if (control->socket < 0) {
	CTRACE((tfp, "control socket is %d\n", control->socket));
    } else {
	CTRACE((tfp, "closing control socket %d\n", control->socket));
	status = NETCLOSE(control->socket);
	if (status == -1)
	    HTInetStatus("control connection close");	/* Comment only */
    }
    control->socket = -1;
    init_help_message_cache();	/* to free memory */
    /* returns HT_LOADED (always for file if we get here) or error */
    return final_status;
}				/* open_file_read */

/*
 *  This function frees any user entered password, so that
 *  it must be entered again for a future request. - FM
 */
void HTClearFTPPassword(void)
{
    /*
     * Need code to check cached documents from non-anonymous ftp accounts and
     * do something to ensure that they no longer can be accessed without a new
     * retrieval.  - FM
     */

    /*
     * Now free the current user entered password, if any.  - FM
     */
    FREE(user_entered_password);
}

#endif /* ifndef DISABLE_FTP */
@


1.8
log
@fastmerge
@
text
@d2 1
a2 1
 * $LynxId: HTFTP.c,v 1.106 2012/11/15 23:51:23 tom Exp $
d354 7
a360 3
	for (p = strchr(vmsname, '['); *p != ']'; p++)
	    if (*p == '/')
		*p = '.';	/* Convert dir sep.  to dots */
d771 9
d837 2
a838 1
    if (!arg)
d840 1
a840 2
    if (!*arg)
	return -1;		/* Bad if name had zero length  */
d842 2
a843 2
/* Get node name:
*/
d930 2
a931 2
/*	Now we log in		Look up username, prompt for pw.
*/
d933 1
a934 7
    if (status == HT_INTERRUPTED) {
	CTRACE((tfp, "HTFTP: Interrupted at beginning of login.\n"));
	_HTProgress(CONNECTION_INTERRUPTED);
	NETCLOSE(control->socket);
	control->socket = -1;
	return HT_INTERRUPTED;
    }
d957 1
a957 7
	if (status == HT_INTERRUPTED) {
	    CTRACE((tfp, "HTFTP: Interrupted while sending username.\n"));
	    _HTProgress(CONNECTION_INTERRUPTED);
	    NETCLOSE(control->socket);
	    control->socket = -1;
	    return HT_INTERRUPTED;
	}
d1005 1
a1005 7
	if (status == HT_INTERRUPTED) {
	    CTRACE((tfp, "HTFTP: Interrupted while sending password.\n"));
	    _HTProgress(CONNECTION_INTERRUPTED);
	    NETCLOSE(control->socket);
	    control->socket = -1;
	    return HT_INTERRUPTED;
	}
d1011 1
a1011 8
	if (status == HT_INTERRUPTED) {
	    CTRACE((tfp, "HTFTP: Interrupted while sending password.\n"));
	    _HTProgress(CONNECTION_INTERRUPTED);
	    NETCLOSE(control->socket);
	    control->socket = -1;
	    return HT_INTERRUPTED;
	}

a1117 14
/*  Now we inform the server of the port number we will listen on
*/
#ifdef NOTREPEAT_PORT
    {
	int status = response(port_command);

	if (status != 2) {
	    if (control->socket)
		close_connection(control->socket);
	    return -status;	/* Bad return */
	}
	CTRACE((tfp, "HTFTP: Port defined.\n"));
    }
#endif /* NOTREPEAT_PORT */
d1296 2
a1297 1
	if (status < 0)
d1299 1
d1328 2
a1329 1
	if (status < 0)
d1331 1
d1344 2
a1345 1
	if (status < 0)
d1347 1
d1455 1
d1458 2
a1459 2
    StrNCpy(day, (char *) ctime(&NowTime) + 8, 2);
    day[2] = '\0';
d1463 1
a1463 2
    StrNCpy(month, (char *) ctime(&NowTime) + 4, 3);
    month[3] = '\0';
d1472 1
a1472 2
    strcpy(ThisYear, (char *) ctime(&NowTime) + 20);
    ThisYear[4] = '\0';
d1613 1
a1613 2
	    strcpy(ct, ctime(&secs));
	    ct[24] = 0;
d1771 1
a1771 1
	    if (cps && cps != line && *(cps - 1) == '/')
d2326 1
a2326 1
	    if (!entry_info->filename || *entry_info->filename == '\0') {
d2558 5
a2562 1
    if (entry_info->filename && strlen(entry_info->filename) > 3) {
d2605 44
d2651 3
a2653 2
    int i, status;
    char date1[16], date2[16], time1[8], time2[8], month[4];
d2658 5
a2662 6
	if (entry1->size == entry2->size)
	    return (strcmp(entry1->filename, entry2->filename));
	else if (entry1->size > entry2->size)
	    return (1);
	else
	    return (-1);
d2668 1
a2668 2
		return (status);
	    /* else fall to filename comparison */
d2670 1
a2670 1
	return (strcmp(entry1->filename, entry2->filename));
d2673 3
a2675 1
	if (entry1->date && entry2->date) {
d2677 1
a2677 8
	     * Make sure we have the correct length. - FM
	     */
	    if (strlen(entry1->date) != 12 || strlen(entry2->date) != 12) {
		return (strcmp(entry1->filename, entry2->filename));
	    }
	    /*
	     * Set the years and date,
	     * if we don't have them yet.
d2682 2
a2683 74
	    /*
	     * Set up for sorting in reverse
	     * chronological order. - FM
	     */
	    if (entry1->date[9] == ':') {
		strcpy(date1, "9999");
		strcpy(time1, &entry1->date[7]);
		if (time1[0] == ' ') {
		    time1[0] = '0';
		}
	    } else {
		strcpy(date1, &entry1->date[8]);
		strcpy(time1, "00:00");
	    }
	    StrNCpy(month, entry1->date, 3);
	    month[3] = '\0';
	    for (i = 0; i < 12; i++) {
		if (!strcasecomp(month, months[i])) {
		    break;
		}
	    }
	    i++;
	    sprintf(month, "%02d", i);
	    strcat(date1, month);
	    StrNCat(date1, &entry1->date[4], 2);
	    date1[8] = '\0';
	    if (date1[6] == ' ' || date1[6] == HT_NON_BREAK_SPACE) {
		date1[6] = '0';
	    }
	    /* If no year given, assume last year if it would otherwise be in
	     * the future by more than one day.  The one day tolerance is to
	     * account for a possible timezone difference.  - kw
	     */
	    if (date1[0] == '9' && atoi(date1) > TheDate + 1) {
		for (i = 0; i < 4; i++) {
		    date1[i] = LastYear[i];
		}
	    }
	    strcat(date1, time1);
	    if (entry2->date[9] == ':') {
		strcpy(date2, "9999");
		strcpy(time2, &entry2->date[7]);
		if (time2[0] == ' ') {
		    time2[0] = '0';
		}
	    } else {
		strcpy(date2, &entry2->date[8]);
		strcpy(time2, "00:00");
	    }
	    StrNCpy(month, entry2->date, 3);
	    month[3] = '\0';
	    for (i = 0; i < 12; i++) {
		if (!strcasecomp(month, months[i])) {
		    break;
		}
	    }
	    i++;
	    sprintf(month, "%02d", i);
	    strcat(date2, month);
	    StrNCat(date2, &entry2->date[4], 2);
	    date2[8] = '\0';
	    if (date2[6] == ' ' || date2[6] == HT_NON_BREAK_SPACE) {
		date2[6] = '0';
	    }
	    /* If no year given, assume last year if it would otherwise be in
	     * the future by more than one day.  The one day tolerance is to
	     * account for a possible timezone difference.  - kw
	     */
	    if (date2[0] == '9' && atoi(date2) > TheDate + 1) {
		for (i = 0; i < 4; i++) {
		    date2[i] = LastYear[i];
		}
	    }
	    strcat(date2, time2);
d2689 1
a2689 2
		return (status);
	    /* else fall to filename comparison */
d2691 1
a2691 1
	return (strcmp(entry1->filename, entry2->filename));
d2695 1
a2695 1
	return (strcmp(entry1->filename, entry2->filename));
d2697 1
d2817 2
a2818 1
	    *buf = '\0';
d2932 1
d3033 1
d3055 1
d3388 1
a3388 1
		     *p && *p && *p != '(';
d4108 1
d4110 15
a4124 16
		switch (cft) {
		case cftCompress:
		    StrAllocCopy(anchor->content_encoding, "x-compress");
		    break;
		case cftGzip:
		    StrAllocCopy(anchor->content_encoding, "x-gzip");
		    break;
		case cftDeflate:
		    StrAllocCopy(anchor->content_encoding, "x-deflate");
		    break;
		case cftBzip2:
		    StrAllocCopy(anchor->content_encoding, "x-bzip2");
		    break;
		case cftNone:
		    break;
		}
d4145 1
a4145 1
	} else
d4147 1
d4158 1
a4158 3
		} else if (status <= 0) {
		    outstanding = 0;
		} else if (status == 2 && !StrNCmp(response_text, "221", 3))
d4160 1
@


1.7
log
@fastmerge
@
text
@d2 1
a2 1
 * $LynxId: HTFTP.c,v 1.104 2012/08/15 23:14:42 tom Exp $
d4010 16
a4096 5
    /* !ftp_local_passive */
#if 0				/* no - this makes the data connection go away too soon (2.8.3dev.22) */
    if ((status = send_cmd_nowait("QUIT")) == 1)
	outstanding++;
#endif
a4183 7
#if 0				/* any known servers where ABOR would work this way? */
	    if (rv == HT_INTERRUPTED || rv == -501)
		if (send_cmd_nowait("ABOR") == 1) {
		    outstanding++;
		    CTRACE((tfp, "HTFTP: outstanding responses: %d\n", outstanding));
		}
#endif
@


1.6
log
@merge lynx2.8.8dev.10a and fix some spelling
@
text
@d2 1
a2 1
 * $LynxId: HTFTP.c,v 1.101 2012/02/09 12:34:48 tom Exp $
d158 7
d254 12
d1503 1
a1503 1
    unsigned long size;
d1599 1
a1599 1
    unsigned long size;
d1626 1
a1626 1
		size = (size * 10) + (unsigned long) (*cp - '0');
d1662 2
a1663 2
    unsigned long base = 1;
    unsigned long size_num = 0;
d1685 1
a1685 1
	size_num += ((unsigned long) (line[j] - '0') * base);
d1751 1
a1751 1
    int size_num = 0;
d1812 1
a1812 1
    entry_info->size = (unsigned long) size_num;
d1854 1
a1854 1
    unsigned int ialloc;
d1955 1
a1955 1
	entry_info->size = (unsigned long) atol(cps);
d1960 1
a1960 1
	ialloc = (unsigned) atoi(cpd + 1);
d1974 1
a1974 1
		entry_info->size = ((unsigned long) atol(cps) * 512);
d1980 1
a1980 5
    /* Wrap it up */
    CTRACE((tfp, "HTFTP: VMS filename: %s  date: %s  size: %lu\n",
	    entry_info->filename,
	    NonNull(entry_info->date),
	    entry_info->size));
d2015 1
a2015 1
	    entry_info->size = (unsigned long) atol(cps);
d2048 1
a2048 5
    /* Wrap it up */
    CTRACE((tfp, "HTFTP: MS Windows filename: %s  date: %s  size: %lu\n",
	    entry_info->filename,
	    NonNull(entry_info->date),
	    entry_info->size));
d2144 1
a2144 1
	    entry_info->size = atol(cps);
d2242 1
a2242 1
	    entry_info->size = ((unsigned long) Records * (unsigned long) RecordLength);
d2292 1
a2292 5
    /* Wrap it up. */
    CTRACE((tfp, "HTFTP: VM/CMS filename: %s  date: %s  size: %lu\n",
	    entry_info->filename,
	    NonNull(entry_info->date),
	    entry_info->size));
d2770 18
d2923 1
a2923 1
	    FormatNum(&buf, start, data->size);
d2936 1
a2936 1
		FormatNum(&buf, start, data->size);
d2939 1
a2939 1
		FormatNum(&buf, start, data->size / 1024);
@


1.5
log
@fastmerge
@
text
@d2 1
a2 1
 * $LynxId: HTFTP.c,v 1.80 2007/08/02 19:55:46 tom Exp $
d136 1
a136 1
#  else				/* HPUX 10.20, etc. */
d151 6
a156 6
#define PUTC(c)      (*targetClass.put_character) (target, c)
#define PUTS(s)      (*targetClass.put_string)    (target, s)
#define START(e)     (*targetClass.start_element) (target, e, 0, 0, -1, 0)
#define END(e)       (*targetClass.end_element)   (target, e, 0)
#define FREE_TARGET  (*targetClass._free)         (target)
#define ABORT_TARGET (*targetClass._free)         (target)
d293 4
d299 1
a299 1
    if (strncmp(nn, "localhost", 9)) {
d469 1
a469 1
	status = NETWRITE(control->socket, cmd, (int) strlen(cmd));
d553 3
a555 3
		if (!strncmp(response_text, "230-", 4) ||
		    !strncmp(response_text, "250-", 4) ||
		    !strncmp(response_text, "220-", 4))
d800 2
d891 1
a891 1
	    con->socket, con));
d949 1
a949 1
	    char *the_address;
d1017 1
a1017 1
    if ((status = response("SYST\r\n")) == 2) {
d1019 1
a1019 1
	if (strncmp(response_text + 4,
d1037 1
a1037 1
	} else if (strncmp(response_text + 4, "VMS", 3) == 0) {
d1051 2
a1052 2
	} else if ((strncmp(response_text + 4, "VM/CMS", 6) == 0) ||
		   (strncmp(response_text + 4, "VM ", 3) == 0)) {
d1057 1
a1057 1
	} else if (strncmp(response_text + 4, "DCTS", 4) == 0) {
d1072 1
a1072 1
	} else if (strncmp(response_text + 4, "MACOS Peter's Server", 20) == 0) {
d1078 1
a1078 1
	} else if (strncmp(response_text + 4, "Windows_NT", 10) == 0) {
d1083 1
a1083 1
	} else if (strncmp(response_text + 4, "Windows2000", 11) == 0) {
d1088 1
a1088 1
	} else if (strncmp(response_text + 4, "MS Windows", 10) == 0) {
d1093 1
a1093 1
	} else if (strncmp(response_text + 4,
d1135 1
a1135 1
    have_socket = (value >= 0);
d1137 1
a1137 1
	master_socket = value;
d1152 1
a1152 1
    status = NETCLOSE(master_socket);
d1202 1
a1202 1
    slen = sizeof(soc_address);
d1291 1
a1291 1
	LY_SOCKLEN address_length = sizeof(soc_address);
d1307 1
a1307 1
		HTInetString((SockA *) soc_in)));
d1355 1
a1355 1
	    HTInetString((SockA *) soc_in)));
d1395 4
a1398 1
			hostbuf, sizeof(hostbuf), portbuf, sizeof(portbuf),
d1417 1
a1417 1
	    status = Rlisten(master_socket, 1);
d1420 1
a1420 1
	    status = listen(master_socket, 1);
d1431 1
a1431 1
    return master_socket;	/* Good */
d1458 1
a1458 1
    strncpy(day, (char *) ctime(&NowTime) + 8, 2);
d1463 1
a1463 1
    strncpy(month, (char *) ctime(&NowTime) + 4, 3);
d1481 1
a1481 1
    char *linkname;
d1484 1
a1484 1
    unsigned int size;
d1486 6
a1520 1
	s++;
a1526 1
	s++;
a1540 1
	s++;
a1550 1
	s++;
a1560 1
	s++;
d1566 1
a1566 1
    if (*s++ != ' ')
d1607 1
a1607 1
		size = (size * 10) + (*cp - '0');
d1636 1
a1636 1
			  EntryInfo *entry_info)
d1638 4
d1643 2
a1644 2
    int base = 1;
    int size_num = 0;
d1646 1
a1646 1
    for (i = strlen(line) - 1;
d1648 3
a1650 1
	 i--) ;			/* null body */
d1653 1
a1653 1
	StrAllocCopy(entry_info->date, &line[i - 12]);
d1655 2
a1656 2
	if (entry_info->date[4] == ' ' || entry_info->date[4] == '0')
	    entry_info->date[4] = HT_NON_BREAK_SPACE;
d1658 1
a1658 1
	if (entry_info->date[11] == ' ') {
d1660 1
a1660 1
		entry_info->date[j] = entry_info->date[j - 1];
d1666 1
a1666 1
	size_num += (line[j] - '0') * base;
d1670 51
a1720 3
    entry_info->size = size_num;
    StrAllocCopy(entry_info->filename, &line[i + 1]);
}				/* parse_ls_line() */
d1748 1
a1748 1
    len = strlen(line);
d1793 1
a1793 1
    entry_info->size = size_num;
d1796 2
a1797 2
    if (!strncmp(cps, "-> ", 3) && cps[3] != '\0' && cps[3] != ' ') {
	StrAllocCopy(entry_info->type, gettext("Symbolic Link"));
d1807 1
a1807 1
    len = strlen(line);
d1810 1
a1810 1
	len = strlen(*pspilledname);
d1854 1
a1854 1
	i = strlen(entry_info->filename);
d1856 4
a1859 2
	i = ((strstr(entry_info->filename, "READ") - entry_info->filename) + 4);
	if (!strncmp(&entry_info->filename[i], "ME", 2)) {
d1864 2
a1865 2
	} else if (!strncmp(&entry_info->filename[i], ".ME", 3)) {
	    i = strlen(entry_info->filename);
d1872 1
a1872 1
    /* Uppercase terminal .z's or _z's. */
d1918 1
a1918 1
	if (!strncmp(ThisYear, cpd + 5, 4) &&
d1936 1
a1936 1
	entry_info->size = atoi(cps);
d1941 1
a1941 1
	ialloc = atoi(cpd + 1);
d1946 1
a1946 1
    } else if ((cps = strtok(cp, sp)) != NULL) {
d1955 1
a1955 1
		entry_info->size = atoi(cps) * 512;
d1962 1
a1962 1
    CTRACE((tfp, "HTFTP: VMS filename: %s  date: %s  size: %u\n",
d2000 1
a2000 1
	    entry_info->size = atoi(cps);
d2034 1
a2034 1
    CTRACE((tfp, "HTFTP: MS Windows filename: %s  date: %s  size: %u\n",
d2133 1
a2133 1
	    entry_info->size = atoi(cps);
d2231 1
a2231 1
	    entry_info->size = (Records * RecordLength);
d2282 1
a2282 1
    CTRACE((tfp, "HTFTP: VM/CMS filename: %s  date: %s  size: %u\n",
d2305 1
a2305 1
    entry_info = (EntryInfo *) malloc(sizeof(EntryInfo));
d2309 3
a2311 5
    entry_info->filename = NULL;
    entry_info->linkname = NULL;
    entry_info->type = NULL;
    entry_info->date = NULL;
    entry_info->size = 0;
d2325 1
a2325 1
	    len = strlen(entry);
d2377 1
a2377 1
	len = strlen(entry);
d2388 1
a2388 1
	    if (!strncmp(entry, "total ", 6) ||
d2414 1
a2414 1
	    StrAllocCopy(entry_info->type, gettext("Symbolic Link"));
a2426 1
		len = i - 3;
d2457 1
a2457 1
	len = strlen(entry_info->filename);
d2541 1
a2541 1
	len = strlen(entry);
d2565 3
d2571 1
d2601 1
a2601 1
	    if (!strncmp(HTAtom_name(format), "application", 11)) {
d2603 1
a2603 1
		if (!strncmp(cp2, "x-", 2))
d2614 1
a2614 1
}				/* parse_dir_entry */
d2669 1
a2669 1
	    strncpy(month, entry1->date, 3);
d2679 1
a2679 1
	    strncat(date1, &entry1->date[4], 2);
d2704 1
a2704 1
	    strncpy(month, entry2->date, 3);
d2714 1
a2714 1
	    strncat(date2, &entry2->date[4], 2);
d2745 213
a2975 1
    HTStructuredClass targetClass;
a2978 1
    char string_buffer[64];
a2979 1
    BOOL need_parent_link = FALSE;
d2982 3
a2984 1
    targetClass = *(target->isa);
d3006 1
a3006 1
    need_parent_link = HTDirTitles(target, parent, format_out, tildeIsTop);
d3114 1
a3114 1
		    HTChunkPutc(chunk, (char) ic);
a3168 5
	/* Put up header
	 */
	/* PUTS("    Date        Type             Size     Filename\n");
	 */

d3172 1
d3181 2
a3183 1
	    int i;
d3190 6
a3208 1

d3236 1
a3236 1
			sprintf(string_buffer, "%6d bytes",
d3239 1
a3239 1
			sprintf(string_buffer, "%6d Kb",
d3243 1
a3243 1
			sprintf(string_buffer, "  %u bytes",
d3246 1
a3246 1
			sprintf(string_buffer, "  %uKb",
d3256 1
d3397 1
a3397 1
		passive_port = (p0 << 8) + p1;
d3407 1
a3407 1
		for (p = response_text; *p && !isspace(*p); p++) {
d3412 1
a3412 1
		     p++)	/*) */
d3414 1
d3421 1
a3421 1
		passive_port = p0;
d3423 1
a3423 1
		sslen = sizeof(ss);
d3430 5
a3434 2
		if (getnameinfo((struct sockaddr *) &ss, sslen, dst,
				sizeof(dst), NULL, 0, NI_NUMERICHOST)) {
d3524 1
a3524 1
    HTReadProgress(0, 0);
d3713 1
a3713 1
		if (!strncmp(filename, "//", 2)) {
d3868 1
a3868 1
		if (!strncmp(filename, "/~", 2)) {
d3976 1
a3976 1
	    if (!strncmp(filename, "//", 2))
d4037 1
a4037 1
	LY_SOCKLEN soc_addrlen = sizeof(soc_address);
d4041 1
a4041 1
	    status = Raccept(master_socket,
d4046 1
a4046 1
	    status = accept(master_socket,
d4075 1
a4075 1
			(status == 2 && !strncmp(response_text, "221", 3)))
d4178 1
a4178 1
		} else if (status == 2 && !strncmp(response_text, "221", 3))
d4187 1
a4187 1
	if (status == 2 && !strncmp(response_text, "221", 3))
@


1.4
log
@• merge (except configure)
• reduce diff against upstream

untested
@
text
@d1 4
a4 1
/*			File Transfer Protocol (FTP) Client
d229 3
a231 1
static int master_socket = -1;	/* Listening socket = invalid   */
d234 1
a234 1
static int num_sockets;		/* Number of sockets to scan */
d352 1
a352 1
	    return -1;
d1122 12
d1143 1
a1143 1
    if (master_socket != -1)
d1145 1
d1147 4
a1150 2
    CTRACE((tfp, "HTFTP: Closed master socket %d\n", master_socket));
    master_socket = -1;
d1164 1
d1190 1
a1190 1
    if (master_socket >= 0)
d1357 1
a1357 1
    if (master_socket >= 0)
d1361 1
a1361 1
    master_socket = new_socket;
d1413 1
a1413 1
	    master_socket = -1;
d3041 1
a3041 1
		if (master_socket >= 0)
@


1.3
log
@fastmerge
@
text
@d182 3
a184 4
 * ProFTPD 1.2.5rc1 is known to have a broken implementation of RETR.  If asked
 * to retrieve a directory, it gets confused and fails subsequent commands such
 * as CWD and LIST.  Since this is an unusual bug, we should remove this ifdef
 * at some point - TD 2004/1/1.
d186 1
a186 2
#define BROKEN_PROFTPD 1
static int ProFTPD_bugs = FALSE;
d189 1
a189 1
 * wu-ftpd 2.6.2(12) is known to have a broken implementation of EPSV.  The
d191 1
a191 1
 * this command - TD 2004/12/28
d193 3
a195 2
#define BROKEN_WUFTPD 1
static int WU_FTPD_bugs = FALSE;
d472 19
d558 2
a559 3
#ifdef BROKEN_PROFTPD
		if (result == 220 && LYstrstr(response_text, "ProFTPD 1.2.5")) {
		    ProFTPD_bugs = TRUE;
d562 3
a564 5
#endif
#ifdef BROKEN_WUFTPD
		if (result == 220 && LYstrstr(response_text,
					      "(Version wu-2.6.2-12)")) {
		    WU_FTPD_bugs = TRUE;
d3002 5
a3006 2
    ProFTPD_bugs = FALSE;
    WU_FTPD_bugs = FALSE;
d3063 1
a3063 1
	    if (WU_FTPD_bugs)
a3678 4
#ifdef BROKEN_PROFTPD
	    /*
	     * ProFTPD 1.2.5rc1 gets confused when asked to RETR a directory.
	     */
d3682 1
a3682 1
		if (ProFTPD_bugs) {
a3690 1
#endif
@


1.2
log
@more size_t and ptrdiff_t fallout
@
text
@d3439 2
d3443 1
a3443 1
			    HTSprintf0(&vmsname, "%.*s[%s]", (int)(cp1 - cp), cp, filename);
d3446 1
a3446 1
				HTSprintf(&vmsname, "%.*s[000000]", (int)(cp1 - cp), cp);
d3449 1
a3449 1
				    HTSprintf(&vmsname, "%.*s", (int)(cp1 - cp), cp);
d3554 1
a3554 1
		    HTSprintf0(&tmp, "[.%.*s]", (int)(cp1 - cp - 1), cp + 1);
@


1.1
log
@Initial revision
@
text
@d133 1
a133 1
#  else	/* HPUX 10.20, etc. */
a1280 3
#ifdef INET6
			   socks_bind_remoteAddr
#else
a1281 1
#endif /* INET6 */
d2691 1
a2691 1
    need_parent_link = HTDirTitles(target, parent, tildeIsTop);
d2944 1
d3441 1
a3441 1
			    HTSprintf0(&vmsname, "%.*s[%s]", cp1 - cp, cp, filename);
d3444 1
a3444 1
				HTSprintf(&vmsname, "%.*s[000000]", cp1 - cp, cp);
d3447 1
a3447 1
				    HTSprintf(&vmsname, "%.*s", cp1 - cp, cp);
d3552 1
a3552 1
		    HTSprintf0(&tmp, "[.%.*s]", cp1 - cp - 1, cp + 1);
@


1.1.109.1
log
@Lynx 2.8.6dev.11h (pre-patch) minus
* lib
* po
* scripts
@
text
@@


1.1.109.2
log
@update our Lynx
@
text
@d133 1
a133 1
#  else				/* HPUX 10.20, etc. */
d1281 3
d1285 1
@


1.1.109.3
log
@import Lynx/2.8.6dev.18 (hopefully with our SSL fixes)
@
text
@d2691 1
a2691 1
    need_parent_link = HTDirTitles(target, parent, format_out, tildeIsTop);
a2943 1
	END(HTML_BODY);
@


1.1.109.4
log
@Update to lynx 2.8.6pre.5
This is a required update, because earlier versions contain some
non-free, non-redistributable files!
@
text
@a3438 2
			    int cplen = (int) (cp1 - cp);

d3441 1
a3441 1
			    HTSprintf0(&vmsname, "%.*s[%s]", cplen, cp, filename);
d3444 1
a3444 1
				HTSprintf(&vmsname, "%.*s[000000]", cplen, cp);
d3447 1
a3447 1
				    HTSprintf(&vmsname, "%.*s", cplen, cp);
d3552 1
a3552 1
		    HTSprintf0(&tmp, "[.%.*s]", (int) (cp1 - cp - 1), cp + 1);
@


1.1.109.5
log
@Finally, a new Lynx snapshot!
@
text
@d182 4
a185 3
 * Some ftp servers are known to have a broken implementation of RETR.  If
 * asked to retrieve a directory, they get confused and fail subsequent
 * commands such as CWD and LIST.
d187 2
a188 1
static int Broken_RETR = FALSE;
d191 1
a191 1
 * Some ftp servers are known to have a broken implementation of EPSV.  The
d193 1
a193 1
 * this command.
d195 2
a196 3
#ifdef INET6
static int Broken_EPSV = FALSE;
#endif
a472 19
/*
 * For each string in the list, check if it is found in the response text.
 * If so, return TRUE.
 */
static BOOL find_response(HTList *list)
{
    BOOL result = FALSE;
    HTList *p = list;
    char *value;

    while ((value = (char *) HTList_nextObject(p)) != NULL) {
	if (LYstrstr(response_text, value)) {
	    result = TRUE;
	    break;
	}
    }
    return result;
}

d540 3
a542 2
		if (result == 220 && find_response(broken_ftp_retr)) {
		    Broken_RETR = TRUE;
d545 5
a549 3
#ifdef INET6
		if (result == 220 && find_response(broken_ftp_epsv)) {
		    Broken_EPSV = TRUE;
d2987 2
a2988 5
    Broken_RETR = FALSE;

#ifdef INET6
    Broken_EPSV = FALSE;
#endif
d3045 1
a3045 1
	    if (Broken_EPSV)
d3661 4
d3668 1
a3668 1
		if (Broken_RETR) {
d3677 1
@


1.1.109.6
log
@Import Lynx 2.8.7dev.7 into base as well
@
text
@d1 1
a1 4
/*
 * $LynxId: HTFTP.c,v 1.80 2007/08/02 19:55:46 tom Exp $
 *
 *			File Transfer Protocol (FTP) Client
d226 1
a226 3
static BOOL have_socket = FALSE;	/* true if master_socket is valid */
static unsigned master_socket;	/* Listening socket = invalid */

d229 1
a229 1
static unsigned num_sockets;	/* Number of sockets to scan */
d347 1
a347 1
	    return EOF;
a1116 12
static void reset_master_socket(void)
{
    have_socket = FALSE;
}

static void set_master_socket(int value)
{
    have_socket = (value >= 0);
    if (have_socket)
	master_socket = value;
}

d1126 1
a1126 1
    if (have_socket)
a1127 1

d1129 2
a1130 4
    CTRACE((tfp, "HTFTP: Closed master socket %u\n", master_socket));

    reset_master_socket();

a1143 1
 *	have_socket	Must be false, if master_socket is not setup already
d1169 1
a1169 1
    if (have_socket)
d1336 1
a1336 1
    if (have_socket)
d1340 1
a1340 1
    set_master_socket(new_socket);
d1392 1
a1392 1
	    reset_master_socket();
d3020 1
a3020 1
		if (have_socket)
@


1.1.109.7
log
@Import Lynx 2.8.7dev.11a via eMail from Tom Dickey:
Message-ID: <20081215010313.GA8373@@invisible-island.net>
Message-ID: <20081216012408.GA15364@@invisible-island.net>
@
text
@d2 1
a2 1
 * $LynxId: HTFTP.c,v 1.81 2008/09/18 21:34:25 tom Exp $
d885 1
a885 1
	    con->socket, (void *) con));
@


1.1.109.8
log
@Import Lynx 2.8.7dev.12
@
text
@d2 1
a2 1
 * $LynxId: HTFTP.c,v 1.86 2008/12/26 22:19:03 tom Exp $
d151 6
a156 6
#define PUTC(c)      (*target->isa->put_character) (target, c)
#define PUTS(s)      (*target->isa->put_string)    (target, s)
#define START(e)     (*target->isa->start_element) (target, e, 0, 0, -1, 0)
#define END(e)       (*target->isa->end_element)   (target, e, 0)
#define FREE_TARGET  (*target->isa->_free)         (target)
#define ABORT_TARGET (*target->isa->_free)         (target)
d1472 1
a1472 1
    char *linkname;		/* symbolic link, if any */
d1475 1
a1475 1
    unsigned long size;
a1476 6
#ifdef LONG_LIST
    unsigned long file_links;
    char *file_mode;
    char *file_user;
    char *file_group;
#endif
d1626 1
a1626 1
			  EntryInfo *entry)
a1627 2
    char *next;
    char *cp;
d1629 2
a1630 2
    unsigned long base = 1;
    unsigned long size_num = 0;
d1634 1
a1634 3
	 i--) {
	;			/* null body */
    }
d1637 1
a1637 1
	StrAllocCopy(entry->date, &line[i - 12]);
d1639 2
a1640 2
	if (entry->date[4] == ' ' || entry->date[4] == '0')
	    entry->date[4] = HT_NON_BREAK_SPACE;
d1642 1
a1642 1
	if (entry->date[11] == ' ') {
d1644 1
a1644 1
		entry->date[j] = entry->date[j - 1];
d1654 3
a1656 50
    entry->size = size_num;
    StrAllocCopy(entry->filename, &line[i + 1]);

#ifdef LONG_LIST
    line[j] = '\0';

    /*
     * Extract the file-permissions, as a string.
     */
    if ((cp = strchr(line, ' ')) != 0
	&& (cp - line) == 10) {
	*cp = '\0';
	StrAllocCopy(entry->file_mode, line);
	*cp = ' ';
    }

    /*
     * Next is the link-count.
     */
    next = 0;
    entry->file_links = strtol(cp, &next, 10);
    if (next == 0 || *next != ' ') {
	entry->file_links = 0;
	next = cp;
    } else {
	cp = next;
    }
    /*
     * Next is the user-name.
     */
    while (isspace(UCH(*cp)))
	++cp;
    if ((next = strchr(cp, ' ')) != 0)
	*next = '\0';
    if (*cp != '\0')
	StrAllocCopy(entry->file_user, cp);
    /*
     * Next is the group-name (perhaps).
     */
    if (next != NULL) {
	cp = (next + 1);
	while (isspace(UCH(*cp)))
	    ++cp;
	if ((next = strchr(cp, ' ')) != 0)
	    *next = '\0';
	if (*cp != '\0')
	    StrAllocCopy(entry->file_group, cp);
    }
#endif
}
d1733 1
a1733 1
	StrAllocCopy(entry_info->type, ENTRY_IS_SYMBOLIC_LINK);
d1896 1
a1896 1
    CTRACE((tfp, "HTFTP: VMS filename: %s  date: %s  size: %lu\n",
d1968 1
a1968 1
    CTRACE((tfp, "HTFTP: MS Windows filename: %s  date: %s  size: %lu\n",
d2216 1
a2216 1
    CTRACE((tfp, "HTFTP: VM/CMS filename: %s  date: %s  size: %lu\n",
d2239 1
a2239 1
    entry_info = typecalloc(EntryInfo);
d2243 5
d2350 1
a2350 1
	    StrAllocCopy(entry_info->type, ENTRY_IS_SYMBOLIC_LINK);
a2501 1
#ifndef LONG_LIST
a2504 1
#endif
d2547 1
a2547 1
}
a2677 213
#ifdef LONG_LIST
static char *FormatStr(char **bufp,
		       char *start,
		       const char *value)
{
    char fmt[512];

    if (*start) {
	sprintf(fmt, "%%%.*ss", (int) sizeof(fmt) - 3, start);
	HTSprintf(bufp, fmt, value);
    } else if (*bufp && !(value && *value)) {
	;
    } else if (value) {
	StrAllocCat(*bufp, value);
    }
    return *bufp;
}

static char *FormatNum(char **bufp,
		       char *start,
		       long value)
{
    char fmt[512];

    if (*start) {
	sprintf(fmt, "%%%.*sld", (int) sizeof(fmt) - 3, start);
	HTSprintf(bufp, fmt, value);
    } else {
	sprintf(fmt, "%ld", value);
	StrAllocCat(*bufp, fmt);
    }
    return *bufp;
}

static void FlushParse(HTStructured * target, char **buf)
{
    if (*buf && **buf) {
	PUTS(*buf);
	**buf = '\0';
    }
}

static void LYListFmtParse(const char *fmtstr,
			   EntryInfo *data,
			   HTStructured * target,
			   char *tail)
{
    char c;
    char *s;
    char *end;
    char *start;
    char *str = NULL;
    char *buf = NULL;
    BOOL is_directory = (data->file_mode != 0 &&
			 (TOUPPER(data->file_mode[0]) == 'D'));
    BOOL is_symlinked = (data->file_mode != 0 &&
			 (TOUPPER(data->file_mode[0]) == 'L'));
    BOOL remove_size = (is_directory || is_symlinked);

    StrAllocCopy(str, fmtstr);
    s = str;
    end = str + strlen(str);
    while (*s) {
	start = s;
	while (*s) {
	    if (*s == '%') {
		if (*(s + 1) == '%')	/* literal % */
		    s++;
		else
		    break;
	    }
	    s++;
	}
	/* s is positioned either at a % or at \0 */
	*s = '\0';
	if (s > start) {	/* some literal chars. */
	    StrAllocCat(buf, start);
	}
	if (s == end)
	    break;
	start = ++s;
	while (isdigit(UCH(*s)) || *s == '.' || *s == '-' || *s == ' ' ||
	       *s == '#' || *s == '+' || *s == '\'')
	    s++;
	c = *s;			/* the format char. or \0 */
	*s = '\0';

	switch (c) {
	case '\0':
	    StrAllocCat(buf, start);
	    continue;

	case 'A':
	case 'a':		/* anchor */
	    FlushParse(target, &buf);
	    HTDirEntry(target, tail, data->filename);
	    FormatStr(&buf, start, data->filename);
	    PUTS(buf);
	    END(HTML_A);
	    *buf = '\0';
	    if (c != 'A' && data->linkname != 0) {
		PUTS(" -> ");
		PUTS(data->linkname);
	    }
	    break;

	case 'T':		/* MIME type */
	case 't':		/* MIME type description */
	    if (is_directory) {
		if (c != 'T') {
		    FormatStr(&buf, start, ENTRY_IS_DIRECTORY);
		} else {
		    FormatStr(&buf, start, "");
		}
	    } else if (is_symlinked) {
		if (c != 'T') {
		    FormatStr(&buf, start, ENTRY_IS_SYMBOLIC_LINK);
		} else {
		    FormatStr(&buf, start, "");
		}
	    } else {
		const char *cp2;
		HTFormat format;

		format = HTFileFormat(data->filename, NULL, &cp2);

		if (c != 'T') {
		    if (cp2 == NULL) {
			if (!strncmp(HTAtom_name(format),
				     "application", 11)) {
			    cp2 = HTAtom_name(format) + 12;
			    if (!strncmp(cp2, "x-", 2))
				cp2 += 2;
			} else {
			    cp2 = HTAtom_name(format);
			}
		    }
		    FormatStr(&buf, start, cp2);
		} else {
		    FormatStr(&buf, start, HTAtom_name(format));
		}
	    }
	    break;

	case 'd':		/* date */
	    if (data->date) {
		FormatStr(&buf, start, data->date);
	    } else {
		FormatStr(&buf, start, " * ");
	    }
	    break;

	case 's':		/* size in bytes */
	    FormatNum(&buf, start, data->size);
	    break;

	case 'K':		/* size in Kilobytes but not for directories */
	    if (remove_size) {
		FormatStr(&buf, start, "");
		StrAllocCat(buf, " ");
		break;
	    }
	    /* FALL THROUGH */
	case 'k':		/* size in Kilobytes */
	    /* FIXME - this is inconsistent with HTFile.c, but historical */
	    if (data->size < 1024) {
		FormatNum(&buf, start, data->size);
		StrAllocCat(buf, " bytes");
	    } else {
		FormatNum(&buf, start, data->size / 1024);
		StrAllocCat(buf, "Kb");
	    }
	    break;

#ifdef LONG_LIST
	case 'p':		/* unix-style permission bits */
	    FormatStr(&buf, start, NonNull(data->file_mode));
	    break;

	case 'o':		/* owner */
	    FormatStr(&buf, start, NonNull(data->file_user));
	    break;

	case 'g':		/* group */
	    FormatStr(&buf, start, NonNull(data->file_group));
	    break;

	case 'l':		/* link count */
	    FormatNum(&buf, start, data->file_links);
	    break;
#endif

	case '%':		/* literal % with flags/width */
	    FormatStr(&buf, start, "%");
	    break;

	default:
	    fprintf(stderr,
		    "Unknown format character `%c' in list format\n", c);
	    break;
	}

	s++;
    }
    if (buf) {
	LYTrimTrailing(buf);
	FlushParse(target, &buf);
	FREE(buf);
    }
    PUTC('\n');
    FREE(str);
}
#endif /* LONG_LIST */
d2700 1
a2704 4
#ifndef LONG_LIST
    char string_buffer[64];
#endif

d2890 5
a2897 1
#ifndef LONG_LIST
d2906 1
a2907 2
#endif
	    HTBTElement *ele;
a2913 6
#ifdef LONG_LIST
		LYListFmtParse(ftp_format,
			       entry_info,
			       target,
			       lastpath);
#else
d2927 1
d2955 1
a2955 1
			sprintf(string_buffer, "%6ld bytes",
d2958 1
a2958 1
			sprintf(string_buffer, "%6ld Kb",
d2962 1
a2962 1
			sprintf(string_buffer, "  %lu bytes",
d2965 1
a2965 1
			sprintf(string_buffer, "  %luKb",
a2974 1
#endif
@


1.1.109.9
log
@Woohoo, there’s a new Lynx release!
@
text
@d2 1
a2 1
 * $LynxId: HTFTP.c,v 1.89 2009/02/01 12:49:00 tom Exp $
d465 1
a465 1
	status = NETWRITE(control->socket, cmd, (unsigned) strlen(cmd));
d1129 1
a1129 1
    have_socket = (BOOLEAN) (value >= 0);
d1131 1
a1131 1
	master_socket = (unsigned) value;
d1146 1
a1146 1
    status = NETCLOSE((int) master_socket);
d1408 1
a1408 1
	    status = Rlisten((int) master_socket, 1);
d1411 1
a1411 1
	    status = listen((int) master_socket, 1);
d1422 1
a1422 1
    return (int) master_socket;	/* Good */
d1603 1
a1603 1
		size = (size * 10) + (unsigned long) (*cp - '0');
d1640 1
a1640 1
    for (i = (int) strlen(line) - 1;
d1660 1
a1660 1
	size_num += ((unsigned long) (line[j] - '0') * base);
d1684 1
a1684 1
    entry->file_links = (unsigned long) strtol(cp, &next, 10);
d1741 1
a1741 1
    len = (int) strlen(line);
d1786 1
a1786 1
    entry_info->size = (unsigned long) size_num;
d1800 1
a1800 1
    len = (int) strlen(line);
d1803 1
a1803 1
	len = (int) strlen(*pspilledname);
d1847 1
a1847 1
	i = (int) strlen(entry_info->filename);
d1856 1
a1856 1
	    i = (int) strlen(entry_info->filename);
d1927 1
a1927 1
	entry_info->size = (unsigned long) atol(cps);
d1932 1
a1932 1
	ialloc = (unsigned) atoi(cpd + 1);
d1946 1
a1946 1
		entry_info->size = ((unsigned long) atol(cps) * 512);
d1991 1
a1991 1
	    entry_info->size = (unsigned long) atol(cps);
d2124 1
a2124 1
	    entry_info->size = atol(cps);
d2222 1
a2222 1
	    entry_info->size = ((unsigned long) Records * (unsigned long) RecordLength);
d2313 1
a2313 1
	    len = (int) strlen(entry);
d2365 1
a2365 1
	len = (int) strlen(entry);
d2446 1
a2446 1
	len = (int) strlen(entry_info->filename);
d2530 1
a2530 1
	len = (int) strlen(entry);
d2554 1
a2554 3
#ifdef LONG_LIST
    (void) remove_size;
#else
d2752 1
a2752 1
		       unsigned long value)
d2760 1
a2760 1
	sprintf(fmt, "%lu", value);
d2785 5
a2789 5
    BOOL is_directory = (BOOL) (data->file_mode != 0 &&
				(TOUPPER(data->file_mode[0]) == 'D'));
    BOOL is_symlinked = (BOOL) (data->file_mode != 0 &&
				(TOUPPER(data->file_mode[0]) == 'L'));
    BOOL remove_size = (BOOL) (is_directory || is_symlinked);
d2963 1
d2975 2
d3388 1
a3388 1
		passive_port = (PortNumber) ((p0 << 8) + p1);
d3403 1
a3403 1
		     p++) {	/*) */
a3404 1
		}
d3411 1
a3411 1
		passive_port = (PortNumber) p0;
d4028 1
a4028 1
	    status = Raccept((int) master_socket,
d4033 1
a4033 1
	    status = accept((int) master_socket,
@


1.1.109.10
log
@Import lynx-current
@
text
@d2 1
a2 1
 * $LynxId: HTFTP.c,v 1.99 2010/10/31 17:56:13 tom Exp $
d136 1
a136 1
#  else	/* HPUX 10.20, etc. */
a292 4

    assert(filename != NULL);
    assert(nodename != NULL);

d295 1
a295 1
    if (StrNCmp(nn, "localhost", 9)) {
d465 1
a465 1
	status = (int) NETWRITE(control->socket, cmd, (unsigned) strlen(cmd));
d549 3
a551 3
		if (!StrNCmp(response_text, "230-", 4) ||
		    !StrNCmp(response_text, "250-", 4) ||
		    !StrNCmp(response_text, "220-", 4))
a795 2

	assert(con != NULL);
d943 1
a943 1
	    const char *the_address;
d1011 1
a1011 1
    if (response("SYST\r\n") == 2) {
d1013 1
a1013 1
	if (StrNCmp(response_text + 4,
d1031 1
a1031 1
	} else if (StrNCmp(response_text + 4, "VMS", 3) == 0) {
d1045 2
a1046 2
	} else if ((StrNCmp(response_text + 4, "VM/CMS", 6) == 0) ||
		   (StrNCmp(response_text + 4, "VM ", 3) == 0)) {
d1051 1
a1051 1
	} else if (StrNCmp(response_text + 4, "DCTS", 4) == 0) {
d1066 1
a1066 1
	} else if (StrNCmp(response_text + 4, "MACOS Peter's Server", 20) == 0) {
d1072 1
a1072 1
	} else if (StrNCmp(response_text + 4, "Windows_NT", 10) == 0) {
d1077 1
a1077 1
	} else if (StrNCmp(response_text + 4, "Windows2000", 11) == 0) {
d1082 1
a1082 1
	} else if (StrNCmp(response_text + 4, "MS Windows", 10) == 0) {
d1087 1
a1087 1
	} else if (StrNCmp(response_text + 4,
d1389 1
a1389 4
			hostbuf,
			(socklen_t) sizeof(hostbuf),
			portbuf,
			(socklen_t) sizeof(portbuf),
d1449 1
a1449 1
    StrNCpy(day, (char *) ctime(&NowTime) + 8, 2);
d1454 1
a1454 1
    StrNCpy(month, (char *) ctime(&NowTime) + 4, 3);
d1512 1
d1519 1
d1534 1
d1545 1
d1556 1
d1562 1
a1562 1
    if (*s != ' ')
a1633 1
#ifdef LONG_LIST
a1635 1
#endif
d1673 6
a1678 6
    if ((cp = strchr(line, ' ')) != 0) {
	if ((cp - line) == 10) {
	    *cp = '\0';
	    StrAllocCopy(entry->file_mode, line);
	    *cp = ' ';
	}
d1680 25
a1704 14
	/*
	 * Next is the link-count.
	 */
	next = 0;
	entry->file_links = (unsigned long) strtol(cp, &next, 10);
	if (next == 0 || *next != ' ') {
	    entry->file_links = 0;
	    next = cp;
	} else {
	    cp = next;
	}
	/*
	 * Next is the user-name.
	 */
d1710 1
a1710 13
	    StrAllocCopy(entry->file_user, cp);
	/*
	 * Next is the group-name (perhaps).
	 */
	if (next != NULL) {
	    cp = (next + 1);
	    while (isspace(UCH(*cp)))
		++cp;
	    if ((next = strchr(cp, ' ')) != 0)
		*next = '\0';
	    if (*cp != '\0')
		StrAllocCopy(entry->file_group, cp);
	}
d1789 1
a1789 1
    if (!StrNCmp(cps, "-> ", 3) && cps[3] != '\0' && cps[3] != ' ') {
d1849 2
a1850 4
	i = (int) ((strstr(entry_info->filename, "READ")
		    - entry_info->filename)
		   + 4);
	if (!StrNCmp(&entry_info->filename[i], "ME", 2)) {
d1855 1
a1855 1
	} else if (!StrNCmp(&entry_info->filename[i], ".ME", 3)) {
d1909 1
a1909 1
	if (!StrNCmp(ThisYear, cpd + 5, 4) &&
d1937 1
a1937 1
    } else if (strtok(cp, sp) != NULL) {
a2299 3

    assert(entry_info != NULL);

d2376 1
a2376 1
	    if (!StrNCmp(entry, "total ", 6) ||
d2415 1
d2590 1
a2590 1
	    if (!StrNCmp(HTAtom_name(format), "application", 11)) {
d2592 1
a2592 1
		if (!StrNCmp(cp2, "x-", 2))
d2658 1
a2658 1
	    StrNCpy(month, entry1->date, 3);
d2668 1
a2668 1
	    StrNCat(date1, &entry1->date[4], 2);
d2693 1
a2693 1
	    StrNCpy(month, entry2->date, 3);
d2703 1
a2703 1
	    StrNCat(date2, &entry2->date[4], 2);
d2862 1
a2862 1
			if (!StrNCmp(HTAtom_name(format),
d2865 1
a2865 1
			    if (!StrNCmp(cp2, "x-", 2))
d2969 1
d2996 1
a2996 1
    (void) HTDirTitles(target, parent, format_out, tildeIsTop);
d3104 1
a3104 1
		    HTChunkPutc(chunk, UCH(ic));
d3397 1
a3397 1
		for (p = response_text; *p && !isspace(UCH(*p)); p++) {
d3420 2
a3421 5
		if (getnameinfo((struct sockaddr *) &ss,
				sslen,
				dst,
				(socklen_t) sizeof(dst),
				NULL, 0, NI_NUMERICHOST)) {
d3511 1
a3511 1
    HTReadProgress((off_t) 0, (off_t) 0);
d3700 1
a3700 1
		if (!StrNCmp(filename, "//", 2)) {
d3855 1
a3855 1
		if (!StrNCmp(filename, "/~", 2)) {
d3963 1
a3963 1
	    if (!StrNCmp(filename, "//", 2))
d4062 1
a4062 1
			(status == 2 && !StrNCmp(response_text, "221", 3)))
d4165 1
a4165 1
		} else if (status == 2 && !StrNCmp(response_text, "221", 3))
d4174 1
a4174 1
	if (status == 2 && !StrNCmp(response_text, "221", 3))
@


1.1.109.11
log
@Import Lynx 2.8.8dev.10 plus dev.10a patch from invisible-island plus
fix for “lynx -help” output by KIHARA Hideto, by import-3rdpty,v 1.43
@
text
@d2 1
a2 1
 * $LynxId: HTFTP.c,v 1.101 2012/02/09 12:34:48 tom Exp $
d1202 1
a1202 1
    slen = (LY_SOCKLEN) sizeof(soc_address);
d1291 1
a1291 1
	LY_SOCKLEN address_length = (LY_SOCKLEN) sizeof(soc_address);
d1307 1
a1307 1
		HTInetString((void *) soc_in)));
d1355 1
a1355 1
	    HTInetString((void *) soc_in)));
d3423 1
a3423 1
		sslen = (LY_SOCKLEN) sizeof(ss);
d4037 1
a4037 1
	LY_SOCKLEN soc_addrlen = (LY_SOCKLEN) sizeof(soc_address);
@


1.1.109.12
log
@lynx2.8.8dev.14
@
text
@d2 1
a2 1
 * $LynxId: HTFTP.c,v 1.104 2012/08/15 23:14:42 tom Exp $
a157 7
#define TRACE_ENTRY(tag, entry_info) \
    CTRACE((tfp, "HTFTP: %s filename: %s  date: %s  size: %" PRI_off_t "\n", \
	    tag, \
	    entry_info->filename, \
	    NonNull(entry_info->date), \
	    entry_info->size))

a246 12
#ifndef HAVE_ATOLL
off_t LYatoll(const char *value)
{
    off_t result = 0;

    while (*value != '\0') {
	result = (result * 10) + (off_t) (*value++ - '0');
    }
    return result;
}
#endif

d1484 1
a1484 1
    off_t size;
d1580 1
a1580 1
    off_t size;
d1607 1
a1607 1
		size = (size * 10) + (off_t) (*cp - '0');
d1643 2
a1644 2
    off_t base = 1;
    off_t size_num = 0;
d1666 1
a1666 1
	size_num += ((off_t) (line[j] - '0') * base);
d1732 1
a1732 1
    off_t size_num = 0;
d1793 1
a1793 1
    entry_info->size = size_num;
d1835 1
a1835 1
    off_t ialloc;
d1936 1
a1936 1
	entry_info->size = LYatoll(cps);
d1941 1
a1941 1
	ialloc = LYatoll(cpd + 1);
d1955 1
a1955 1
		entry_info->size = (LYatoll(cps) * 512);
d1961 5
a1965 1
    TRACE_ENTRY("VMS", entry_info);
d2000 1
a2000 1
	    entry_info->size = LYatoll(cps);
d2033 5
a2037 1
    TRACE_ENTRY("MS Windows", entry_info);
d2133 1
a2133 1
	    entry_info->size = LYatoll(cps);
d2231 1
a2231 1
	    entry_info->size = ((off_t) Records * (off_t) RecordLength);
d2281 5
a2285 1
    TRACE_ENTRY("VM/CMS", entry_info);
a2762 18
static char *FormatSize(char **bufp,
			char *start,
			off_t value)
{
    char fmt[512];

    if (*start) {
	sprintf(fmt, "%%%.*s" PRI_off_t, (int) sizeof(fmt) - 3, start);

	HTSprintf(bufp, fmt, value);
    } else {
	sprintf(fmt, "%" PRI_off_t, value);

	StrAllocCat(*bufp, fmt);
    }
    return *bufp;
}

d2898 1
a2898 1
	    FormatSize(&buf, start, data->size);
d2911 1
a2911 1
		FormatSize(&buf, start, data->size);
d2914 1
a2914 1
		FormatSize(&buf, start, data->size / 1024);
@


1.1.109.13
log
@Import Lynx 2.8.8dev.15 as suggested by lewellyn on IRC
@
text
@d2 1
a2 1
 * $LynxId: HTFTP.c,v 1.106 2012/11/15 23:51:23 tom Exp $
a4009 16
	    /*
	     * If we are retrieving a file we will (except for CMS) use
	     * binary mode, which lets us use the size command supported by
	     * ftp servers which implement RFC 3659.  Knowing the size lets
	     * us in turn display ETA in the progress message -TD
	     */
	    if (control->binary) {
		int code;
		off_t size;

		status = send_cmd_2("SIZE", filename);
		if (status == 2 &&
		    sscanf(response_text, "%d %" PRI_off_t, &code, &size) == 2) {
		    anchor->content_length = size;
		}
	    }
d4081 5
d4173 7
@


1.1.109.14
log
@Update to the latest Lynx patchkit
@
text
@d2 1
a2 1
 * $LynxId: HTFTP.c,v 1.121 2013/05/06 00:09:50 tom Exp $
d354 3
a356 7
	if ((p = strchr(vmsname, '[')) != 0) {
	    while (*p != '\0' && *p != ']') {
		if (*p == '/')
		    *p = '.';	/* Convert dir sep.  to dots */
		++p;
	    }
	}
a766 9
#define CheckForInterrupt(msg) \
	if (status == HT_INTERRUPTED) { \
	    CTRACE((tfp, "HTFTP: Interrupted %s.\n", msg)); \
	    _HTProgress(CONNECTION_INTERRUPTED); \
	    NETCLOSE(control->socket); \
	    control->socket = -1; \
	    return HT_INTERRUPTED; \
	}

d824 1
a824 2
    if (isEmpty(arg)) {
	free(con);
d826 2
a827 1
    }
d829 2
a830 2
    /* Get node name:
     */
d917 2
a918 2
    /*  Now we log in           Look up username, prompt for pw.
     */
a919 1
    CheckForInterrupt("at beginning of login");
d921 7
d950 7
a956 1
	CheckForInterrupt("while sending username");
d1004 7
a1010 1
	CheckForInterrupt("while sending password");
d1016 8
a1023 1
	CheckForInterrupt("while sending password");
d1130 14
d1322 1
a1322 2
	if (status < 0) {
	    close(new_socket);
a1323 1
	}
d1352 1
a1352 2
	if (status < 0) {
	    close(new_socket);
a1353 1
	}
d1366 1
a1366 2
	if (status < 0) {
	    close(new_socket);
a1367 1
	}
a1474 1
    char *printable;
d1477 2
a1478 2
    printable = ctime(&NowTime);
    LYStrNCpy(day, printable + 8, 2);
d1482 2
a1483 1
    LYStrNCpy(month, printable + 4, 3);
d1492 2
a1493 1
    LYStrNCpy(ThisYear, printable + 20, 4);
d1634 2
a1635 1
	    LYStrNCpy(ct, ctime(&secs), 24);
d1793 1
a1793 1
	    if (cps != line && *(cps - 1) == '/')
d2348 1
a2348 1
	    if (isEmpty(entry_info->filename)) {
d2580 1
a2580 5
    if (isEmpty(entry_info->filename)) {
	entry_info->display = FALSE;
	return (entry_info);
    }
    if (strlen(entry_info->filename) > 3) {
a2622 44
static void formatDate(char target[16], EntryInfo *entry)
{
    char temp[8], month[4];
    int i;

    /*
     * Set up for sorting in reverse chronological order. - FM
     */
    if (entry->date[9] == ':') {
	strcpy(target, "9999");
	LYStrNCpy(temp, &entry->date[7], 5);
	if (temp[0] == ' ') {
	    temp[0] = '0';
	}
    } else {
	LYStrNCpy(target, &entry->date[8], 4);
	strcpy(temp, "00:00");
    }
    LYStrNCpy(month, entry->date, 3);
    for (i = 0; i < 12; i++) {
	if (!strcasecomp(month, months[i])) {
	    break;
	}
    }
    i++;
    sprintf(month, "%02d", i);
    strcat(target, month);
    StrNCat(target, &entry->date[4], 2);
    if (target[6] == ' ' || target[6] == HT_NON_BREAK_SPACE) {
	target[6] = '0';
    }

    /* If no year given, assume last year if it would otherwise be in the
     * future by more than one day.  The one day tolerance is to account for a
     * possible timezone difference. - kw
     */
    if (target[0] == '9' && atoi(target) > TheDate + 1) {
	for (i = 0; i < 4; i++) {
	    target[i] = LastYear[i];
	}
    }
    strcat(target, temp);
}

d2625 2
a2626 3
    int status;
    char date1[16], date2[16];
    int result = strcmp(entry1->filename, entry2->filename);
d2631 6
a2636 5
	if (entry1->size > entry2->size)
	    result = 1;
	else if (entry1->size < entry2->size)
	    result = -1;
	break;
d2642 2
a2643 1
		result = status;
d2645 1
a2645 1
	break;
d2648 1
a2648 3
	if (entry1->date && entry2->date &&
	    strlen(entry1->date) == 12 &&
	    strlen(entry2->date) == 12) {
d2650 8
a2657 1
	     * Set the years and date, if we don't have them yet.
d2662 74
a2735 2
	    formatDate(date1, entry1);
	    formatDate(date2, entry2);
d2741 2
a2742 1
		result = status;
d2744 1
a2744 1
	break;
d2748 1
a2748 1
	break;
a2749 1
    return result;
d2869 1
a2869 2
	    if (buf != 0)
		*buf = '\0';
a2982 1

a3082 1
		    HTChunkFree(chunk);
a3103 1
			HTChunkFree(chunk);
d3436 1
a3436 1
		     *p && *p != '(';
a4155 1
	    }
d4157 16
a4172 15
	    switch (cft) {
	    case cftCompress:
		StrAllocCopy(anchor->content_encoding, "x-compress");
		break;
	    case cftGzip:
		StrAllocCopy(anchor->content_encoding, "x-gzip");
		break;
	    case cftDeflate:
		StrAllocCopy(anchor->content_encoding, "x-deflate");
		break;
	    case cftBzip2:
		StrAllocCopy(anchor->content_encoding, "x-bzip2");
		break;
	    case cftNone:
		break;
d4193 1
a4193 1
	} else {
a4194 1
	}
d4205 3
a4207 1
		} else if (status == 2 && !StrNCmp(response_text, "221", 3)) {
a4208 1
		}
@


