head	1.30;
access;
symbols
	lynx-2_8_8dev_16:1.1.109.15
	lynx-2_8_8dev_15e:1.1.109.15
	lynx-2_8_8dev_15:1.1.109.14
	lynx-2_8_8dev_14:1.1.109.13
	lynx-2_8_8dev_12:1.1.109.12
	lynx-2_8_8dev_11:1.1.109.12
	lynx-2_8_8dev_10a:1.1.109.12
	lynx-2_8_8dev_7a:1.1.109.11
	lynx-2_8_8dev_7:1.1.109.11
	lynx-2_8_7rel_1:1.1.109.10
	lynx-2_8_7dev_12:1.1.109.9
	lynx-2_8_7dev_11a:1.1.109.8
	MIRBSD_10:1.15.0.2
	MIRBSD_10_BASE:1.15
	lynx-2_8_7dev_8:1.1.109.7
	lynx-2_8_7dev_7:1.1.109.6
	lynx-2_8_7dev_5:1.1.109.5
	lynx-2_8_7dev_2:1.1.109.4
	lynx-2_8_6pre_5:1.1.109.4
	lynx-2_8_6pre_4:1.1.109.4
	lynx-2_8_6pre_3:1.1.109.4
	MIRBSD_9_BASE:1.6
	lynx-2_8_6dev_18c:1.1.109.3
	lynx-2_8_6dev_18:1.1.109.3
	MIRBSD_8:1.3.0.2
	MIRBSD_8_BASE:1.3
	lynx-2_8_6dev_16:1.1.109.2
	lynx:1.1.109;
locks; strict;
comment	@ * @;


1.30
date	2015.07.19.12.25.44;	author tg;	state Exp;
branches;
next	1.29;
commitid	10055AB97502B6E820F;

1.29
date	2015.07.18.23.16.43;	author tg;	state Exp;
branches;
next	1.28;
commitid	10055AADE591232B40E;

1.28
date	2015.05.25.14.36.55;	author tg;	state Exp;
branches;
next	1.27;
commitid	1005563335259250303;

1.27
date	2015.01.04.22.24.27;	author tg;	state Exp;
branches;
next	1.26;
commitid	10054A9BD974311EA62;

1.26
date	2014.03.13.04.46.43;	author tg;	state Exp;
branches;
next	1.25;
commitid	100532138484761BDE3;

1.25
date	2013.05.18.14.59.36;	author tg;	state Exp;
branches;
next	1.24;
commitid	1005197975F6A2B23A5;

1.24
date	2012.12.31.21.19.45;	author tg;	state Exp;
branches;
next	1.23;
commitid	10050E2017B122CED3C;

1.23
date	2012.08.23.18.36.08;	author tg;	state Exp;
branches;
next	1.22;
commitid	1005036781D23C1E744;

1.22
date	2012.02.19.19.37.56;	author tg;	state Exp;
branches;
next	1.21;
commitid	1004F414F917991F461;

1.21
date	2012.01.24.20.04.21;	author tg;	state Exp;
branches;
next	1.20;
commitid	1004F1F0E697384A106;

1.20
date	2010.12.19.19.22.24;	author tg;	state Exp;
branches;
next	1.19;
commitid	1004D0E5B7B7150A62A;

1.19
date	2009.08.09.15.09.57;	author tg;	state Exp;
branches;
next	1.18;
commitid	1004A7EE6D4601C9EC9;

1.18
date	2009.01.18.19.40.53;	author tg;	state Exp;
branches;
next	1.17;
commitid	100497385D57954483F;

1.17
date	2008.12.16.23.33.04;	author tg;	state Exp;
branches;
next	1.16;
commitid	10049483AAC038754C9;

1.16
date	2008.12.16.23.27.08;	author tg;	state Exp;
branches;
next	1.15;
commitid	1004948395D7D988D96;

1.15
date	2008.03.09.18.19.39;	author tg;	state Exp;
branches;
next	1.14;
commitid	10047D42A4E0C2308F6;

1.14
date	2007.08.13.14.35.39;	author tg;	state Exp;
branches;
next	1.13;
commitid	10046C06C496B574CE5;

1.13
date	2007.08.03.15.20.27;	author tg;	state Exp;
branches;
next	1.12;
commitid	10046B347BE53E79AC8;

1.12
date	2007.05.20.09.43.23;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004650182E2FFFB588;

1.11
date	2007.04.18.12.15.05;	author tg;	state Exp;
branches;
next	1.10;
commitid	10046260BC97EFF02EE;

1.10
date	2007.04.18.11.22.06;	author tg;	state Exp;
branches;
next	1.9;
commitid	1004625FDB820C94650;

1.9
date	2007.01.17.03.13.45;	author tg;	state Exp;
branches;
next	1.8;
commitid	10045AD943123D706BA;

1.8
date	2006.11.10.20.56.35;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004554E794448DC2AF;

1.7
date	2006.09.13.19.18.34;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004508599C49FD4FBA;

1.6
date	2006.06.02.19.32.53;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004480926F0D407628;

1.5
date	2006.03.29.20.11.11;	author tg;	state Exp;
branches;
next	1.4;
commitid	100442AE9E47B122802;

1.4
date	2006.02.21.03.00.19;	author tg;	state Exp;
branches;
next	1.3;
commitid	10043FA824908AC18AC;

1.3
date	2005.10.21.21.42.34;	author tg;	state Exp;
branches;
next	1.2;
commitid	7eea435960d851d7;

1.2
date	2005.03.27.22.42.33;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.27.22.11.57;	author tg;	state Exp;
branches
	1.1.109.1;
next	;

1.1.109.1
date	2005.03.27.22.11.57;	author tg;	state Exp;
branches;
next	1.1.109.2;

1.1.109.2
date	2005.10.21.21.33.52;	author tg;	state Exp;
branches;
next	1.1.109.3;
commitid	2f9543595ec47e83;

1.1.109.3
date	2006.06.02.19.17.04;	author tg;	state Exp;
branches;
next	1.1.109.4;
commitid	10044808E727319C3F7;

1.1.109.4
date	2006.09.13.19.11.36;	author tg;	state Exp;
branches;
next	1.1.109.5;
commitid	100450857B406EB1869;

1.1.109.5
date	2007.05.19.22.29.47;	author tg;	state Exp;
branches;
next	1.1.109.6;
commitid	100464F7A1519624932;

1.1.109.6
date	2007.08.03.15.10.45;	author tg;	state Exp;
branches;
next	1.1.109.7;
commitid	10046B3450C0C128495;

1.1.109.7
date	2008.03.09.17.32.14;	author tg;	state Exp;
branches;
next	1.1.109.8;
commitid	10047D41E626DF0F5D0;

1.1.109.8
date	2008.12.16.23.13.10;	author tg;	state Exp;
branches;
next	1.1.109.9;
commitid	100494835F965A87026;

1.1.109.9
date	2009.01.18.19.31.26;	author tg;	state Exp;
branches;
next	1.1.109.10;
commitid	1004973839C3B701938;

1.1.109.10
date	2009.08.09.14.37.48;	author tg;	state Exp;
branches;
next	1.1.109.11;
commitid	1004A7EDF4952738297;

1.1.109.11
date	2010.12.19.18.12.42;	author tg;	state Exp;
branches;
next	1.1.109.12;
commitid	1004D0E4B24304015D1;

1.1.109.12
date	2012.02.19.18.28.41;	author tg;	state Exp;
branches;
next	1.1.109.13;
commitid	1004F413EF328BF0E26;

1.1.109.13
date	2012.08.23.17.48.08;	author tg;	state Exp;
branches;
next	1.1.109.14;
commitid	10050366CBF479FD80F;

1.1.109.14
date	2012.12.31.21.10.04;	author tg;	state Exp;
branches;
next	1.1.109.15;
commitid	10050E1FF02228195F0;

1.1.109.15
date	2013.05.18.14.43.57;	author tg;	state Exp;
branches;
next	;
commitid	100519793BB3FCC7E2F;


desc
@@


1.30
log
@revert the now no longer needed patches from yesternight, MirSSL copes now
@
text
@/*
 * $LynxId: HTTP.c,v 1.128 2013/05/05 19:36:45 tom Exp $
 *
 * HyperText Tranfer Protocol	- Client implementation		HTTP.c
 * ==========================
 * Modified:
 * 27 Jan 1994	PDM  Added Ari Luotonen's Fix for Reload when using proxy
 *		     servers.
 * 28 Apr 1997	AJL,FM Do Proxy Authorisation.
 */

#include <HTUtils.h>
#include <HTTP.h>
#include <LYUtils.h>

#ifdef USE_SSL
#include <HTNews.h>
#endif

#define HTTP_VERSION	"HTTP/1.0"

#define HTTP_PORT   80
#define HTTPS_PORT  443
#define SNEWS_PORT  563

#define INIT_LINE_SIZE		1536	/* Start with line buffer this big */
#define LINE_EXTEND_THRESH	256	/* Minimum read size */
#define VERSION_LENGTH		20	/* for returned protocol version */

#include <HTParse.h>
#include <HTTCP.h>
#include <HTFormat.h>
#include <HTFile.h>
#include <HTAlert.h>
#include <HTMIME.h>
#include <HTML.h>
#include <HTInit.h>
#include <HTAABrow.h>
#include <HTAccess.h>		/* Are we using an HTTP gateway? */

#include <LYCookie.h>
#include <LYGlobalDefs.h>
#include <GridText.h>
#include <LYStrings.h>
#include <LYUtils.h>
#include <LYrcFile.h>
#include <LYLeaks.h>

#ifdef USE_SSL
#ifdef USE_OPENSSL_INCL
#include <openssl/x509v3.h>
#endif
#ifdef USE_GNUTLS_INCL
#include <gnutls/x509.h>
#endif
#endif

__RCSID("$MirOS: src/gnu/usr.bin/lynx/WWW/Library/Implementation/HTTP.c,v 1.29 2015/07/18 23:16:43 tg Exp $");

BOOLEAN reloading = FALSE;	/* Reloading => send no-cache pragma to proxy */
char *redirecting_url = NULL;	/* Location: value. */
BOOL permanent_redirection = FALSE;	/* Got 301 status? */
BOOL redirect_post_content = FALSE;	/* Don't convert to GET? */

#ifdef USE_SSL
SSL_CTX *ssl_ctx = NULL;	/* SSL ctx */
SSL *SSL_handle = NULL;
static int ssl_okay;

static void free_ssl_ctx(void)
{
    if (ssl_ctx != NULL)
	SSL_CTX_free(ssl_ctx);
}

static int HTSSLCallback(int preverify_ok, X509_STORE_CTX * x509_ctx GCC_UNUSED)
{
    char *msg = NULL;
    int result = 1;

#ifdef USE_X509_SUPPORT
    HTSprintf0(&msg,
	       gettext("SSL callback:%s, preverify_ok=%d, ssl_okay=%d"),
	       X509_verify_cert_error_string((long) X509_STORE_CTX_get_error(x509_ctx)),
	       preverify_ok, ssl_okay);
    _HTProgress(msg);
    FREE(msg);
#endif

#ifndef USE_NSS_COMPAT_INCL
    if (!(preverify_ok || ssl_okay || ssl_noprompt)) {
#ifdef USE_X509_SUPPORT
	HTSprintf0(&msg, SSL_FORCED_PROMPT,
		   X509_verify_cert_error_string((long)
						 X509_STORE_CTX_get_error(x509_ctx)));
	if (HTForcedPrompt(ssl_noprompt, msg, YES))
	    ssl_okay = 1;
	else
	    result = 0;
#endif

	FREE(msg);
    }
#endif
    return result;
}

SSL *HTGetSSLHandle(void)
{
#ifdef USE_GNUTLS_INCL
    static char *certfile = NULL;
#endif

    if (ssl_ctx == NULL) {
	/*
	 * First time only.
	 */
#if SSLEAY_VERSION_NUMBER < 0x0800
	ssl_ctx = SSL_CTX_new();
	X509_set_default_verify_paths(ssl_ctx->cert);
#else
	long ssl_opts;

	ssl_opts = SSL_OP_ALL;
#ifdef SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS
	ssl_opts &= ~SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS;
#endif
	SSLeay_add_ssl_algorithms();
	ssl_ctx = SSL_CTX_new(SSLv23_client_method());
	SSL_CTX_set_options(ssl_ctx, ssl_opts);
	SSL_CTX_set_default_verify_paths(ssl_ctx);
	SSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_PEER, HTSSLCallback);
#endif /* SSLEAY_VERSION_NUMBER < 0x0800 */
#if defined(USE_PROGRAM_DIR) & !defined(USE_GNUTLS_INCL)
	{
	    X509_LOOKUP *lookup;

	    lookup = X509_STORE_add_lookup(ssl_ctx->cert_store,
					   X509_LOOKUP_file());
	    if (lookup != NULL) {
		char *certfile = NULL;

		HTSprintf0(&certfile, "%s\\cert.pem", program_dir);
		X509_LOOKUP_load_file(lookup, certfile, X509_FILETYPE_PEM);
		FREE(certfile);
	    }
	}
#endif
#ifdef USE_GNUTLS_INCL
	if ((certfile = LYGetEnv("SSL_CERT_FILE")) != NULL) {
	    CTRACE((tfp,
		    "HTGetSSLHandle: certfile is set to %s by SSL_CERT_FILE\n",
		    certfile));
	} else {
	    if (non_empty(SSL_cert_file)) {
		certfile = SSL_cert_file;
		CTRACE((tfp,
			"HTGetSSLHandle: certfile is set to %s by config SSL_CERT_FILE\n",
			certfile));
	    }
#if defined(USE_PROGRAM_DIR)
	    else {
		HTSprintf0(&(certfile), "%s\\cert.pem", program_dir);
		CTRACE((tfp,
			"HTGetSSLHandle: certfile is set to %s by installed directory\n", certfile));
	    }
#endif
	}
#endif
	atexit(free_ssl_ctx);
    }
#ifdef USE_GNUTLS_INCL
    ssl_ctx->certfile = certfile;
    ssl_ctx->certfile_type = GNUTLS_X509_FMT_PEM;
#endif
    ssl_okay = 0;
    return (SSL_new(ssl_ctx));
}

void HTSSLInitPRNG(void)
{
#ifndef __MirBSD__
#if SSLEAY_VERSION_NUMBER >= 0x00905100
    if (RAND_status() == 0) {
	char rand_file[256];
	time_t t;
	long l, seed;

#ifndef _WINDOWS
	pid_t pid;

#else
	DWORD pid;
#endif

	t = time(NULL);

#ifndef _WINDOWS
	pid = getpid();
#else
	pid = GetCurrentThreadId();
#endif

	RAND_file_name(rand_file, 256L);
	CTRACE((tfp, "HTTP: Seeding PRNG\n"));
	/* Seed as much as 1024 bytes from RAND_file_name */
	RAND_load_file(rand_file, 1024L);
	/* Seed in time (mod_ssl does this) */
	RAND_seed((unsigned char *) &t, (int) sizeof(time_t));

	/* Seed in pid (mod_ssl does this) */
	RAND_seed((unsigned char *) &pid, (int) sizeof(pid));
	/* Initialize system's random number generator */
	RAND_bytes((unsigned char *) &seed, (int) sizeof(long));

	lynx_srand((unsigned) seed);
	while (RAND_status() == 0) {
	    /* Repeatedly seed the PRNG using the system's random number generator until it has been seeded with enough data */
	    l = lynx_rand();
	    RAND_seed((unsigned char *) &l, (int) sizeof(long));
	}
	/* Write a rand_file */
	RAND_write_file(rand_file);
    }
#endif /* SSLEAY_VERSION_NUMBER >= 0x00905100 */
#endif
    return;
}

#define HTTP_NETREAD(sock, buff, size, handle) \
	(handle \
	 ? SSL_read(handle, buff, size) \
	 : NETREAD(sock, buff, size))

#define HTTP_NETWRITE(sock, buff, size, handle) \
	(handle \
	 ? SSL_write(handle, buff, size) \
	 : NETWRITE(sock, buff, size))

#define HTTP_NETCLOSE(sock, handle)  \
	{ (void)NETCLOSE(sock); \
	  if (handle) \
	      SSL_free(handle); \
	  SSL_handle = handle = NULL; \
	}

#else
#define HTTP_NETREAD(a, b, c, d)   NETREAD(a, b, c)
#define HTTP_NETWRITE(a, b, c, d)  NETWRITE(a, b, c)
#define HTTP_NETCLOSE(a, b)  (void)NETCLOSE(a)
#endif /* USE_SSL */

#ifdef _WINDOWS			/* 1997/11/06 (Thu) 13:00:08 */

#define	BOX_TITLE	"Lynx " __FILE__
#define	BOX_FLAG	(MB_ICONINFORMATION | MB_SETFOREGROUND)

typedef struct {
    int fd;
    char *buf;
    int len;
} recv_data_t;

int ws_read_per_sec = 0;
static int ws_errno = 0;

static DWORD g_total_times = 0;
static DWORD g_total_bytes = 0;

/* The same like read, but takes care of EINTR and uses select to
   timeout the stale connections.  */

static int ws_read(int fd, char *buf, int len)
{
    int res;
    int retry = 3;

    do {
	res = recv(fd, buf, len, 0);
	if (WSAEWOULDBLOCK == WSAGetLastError()) {
	    Sleep(100);
	    if (retry-- > 0)
		continue;
	}
    } while (res == SOCKET_ERROR && SOCKET_ERRNO == EINTR);

    return res;
}

#define DWORD_ERR ((DWORD)-1)

static DWORD __stdcall _thread_func(void *p)
{
    DWORD result;
    int i, val;
    recv_data_t *q = (recv_data_t *) p;

    i = 0;
    i++;
    val = ws_read(q->fd, q->buf, q->len);

    if (val == SOCKET_ERROR) {
	ws_errno = WSAGetLastError();
#if 0
	char buff[256];

	sprintf(buff, "Thread read: %d, error (%ld), fd = %d, len = %d",
		i, ws_errno, q->fd, q->len);
	MessageBox(NULL, buff, BOX_TITLE, BOX_FLAG);
#endif
	result = DWORD_ERR;
    } else {
	result = val;
    }

    return result;
}

/* The same like read, but takes care of EINTR and uses select to
   timeout the stale connections.  */

int ws_netread(int fd, char *buf, int len)
{
    int i;
    char buff[256];

    /* 1998/03/30 (Mon) 09:01:21 */
    HANDLE hThread;
    DWORD dwThreadID;
    DWORD exitcode = 0;
    DWORD ret_val = DWORD_ERR;
    DWORD val, process_time, now_TickCount, save_TickCount;

    static recv_data_t para;

#define TICK	5
#define STACK_SIZE	0x2000uL

    InitializeCriticalSection(&critSec_READ);

    para.fd = fd;
    para.buf = buf;
    para.len = len;

    ws_read_per_sec = 0;
    save_TickCount = GetTickCount();

    hThread = CreateThread(NULL, STACK_SIZE,
			   _thread_func,
			   (void *) &para, 0UL, &dwThreadID);

    if (hThread == 0) {
	HTInfoMsg("CreateThread Failed (read)");
	goto read_exit;
    }

    i = 0;
    while (1) {
	val = WaitForSingleObject(hThread, 1000 / TICK);
	i++;
	if (val == WAIT_FAILED) {
	    HTInfoMsg("Wait Failed");
	    ret_val = DWORD_ERR;
	    break;
	} else if (val == WAIT_TIMEOUT) {
	    i++;
	    if (i / TICK > (AlertSecs + 2)) {
		sprintf(buff, "Read Waiting (%2d.%01d) for %d Bytes",
			i / TICK, (i % TICK) * 10 / TICK, len);
		SetConsoleTitle(buff);
	    }
	    if (win32_check_interrupt() || ((i / TICK) > lynx_timeout)) {
		if (CloseHandle(hThread) == FALSE) {
		    HTInfoMsg("Thread terminate Failed");
		}
		WSASetLastError(ETIMEDOUT);
		ret_val = HT_INTERRUPTED;
		break;
	    }
	} else if (val == WAIT_OBJECT_0) {
	    if (GetExitCodeThread(hThread, &exitcode) == FALSE) {
		exitcode = DWORD_ERR;
	    }
	    if (CloseHandle(hThread) == FALSE) {
		HTInfoMsg("Thread terminate Failed");
	    }
	    now_TickCount = GetTickCount();
	    if (now_TickCount >= save_TickCount)
		process_time = now_TickCount - save_TickCount;
	    else
		process_time = now_TickCount + (0xffffffff - save_TickCount);

	    if (process_time == 0)
		process_time = 1;
	    g_total_times += process_time;

	    /*
	     * DWORD is unsigned, and could be an error code which is signed.
	     */
	    if ((long) exitcode > 0)
		g_total_bytes += exitcode;

	    ws_read_per_sec = g_total_bytes;
	    if (ws_read_per_sec > 2000000) {
		if (g_total_times > 1000)
		    ws_read_per_sec /= (g_total_times / 1000);
	    } else {
		ws_read_per_sec *= 1000;
		ws_read_per_sec /= g_total_times;
	    }

	    ret_val = exitcode;
	    break;
	}
    }				/* end while(1) */

  read_exit:
    LeaveCriticalSection(&critSec_READ);
    return ret_val;
}
#endif /* _WINDOWS */

/*
 * Strip any username from the given string so we retain only the host.
 */
static void strip_userid(char *host)
{
    char *p1 = host;
    char *p2 = strchr(host, '@@');
    char *fake;

    if (p2 != 0) {
	*p2++ = '\0';
	if ((fake = HTParse(host, "", PARSE_HOST)) != NULL) {
	    char *msg = NULL;

	    CTRACE((tfp, "parsed:%s\n", fake));
	    HTSprintf0(&msg, gettext("Address contains a username: %s"), host);
	    HTAlert(msg);
	    FREE(msg);
	}
	while ((*p1++ = *p2++) != '\0') {
	    ;
	}
    }
}

/*
 * Check if the user's options specified to use the given encoding.  Normally
 * all encodings with compiled-in support are specified (encodingALL).
 */
static BOOL acceptEncoding(int code)
{
    BOOL result = FALSE;

    if ((code & LYAcceptEncoding) != 0) {
	const char *program = 0;

	switch (code) {
	case encodingGZIP:
	    program = HTGetProgramPath(ppGZIP);
	    break;
	case encodingDEFLATE:
	    program = HTGetProgramPath(ppINFLATE);
	    break;
	case encodingCOMPRESS:
	    program = HTGetProgramPath(ppCOMPRESS);
	    break;
	case encodingBZIP2:
	    program = HTGetProgramPath(ppBZIP2);
	    break;
	default:
	    break;
	}
	/*
	 * FIXME:  if lynx did not rely upon external programs to decompress
	 * files for external viewers, this check could be relaxed.
	 */
	result = (BOOL) (program != 0);
    }
    return result;
}

#ifdef USE_SSL
static void show_cert_issuer(X509 * peer_cert GCC_UNUSED)
{
#if defined(USE_OPENSSL_INCL) || defined(USE_GNUTLS_FUNCS)
    char ssl_dn[1024];
    char *msg = NULL;

    X509_NAME_oneline(X509_get_issuer_name(peer_cert), ssl_dn, (int) sizeof(ssl_dn));
    HTSprintf0(&msg, gettext("Certificate issued by: %s"), ssl_dn);
    _HTProgress(msg);
    FREE(msg);
#elif defined(USE_GNUTLS_INCL)
    /* the OpenSSL "compat" code compiles but dumps core with GNU TLS */
#endif
}
#endif

/*
 * Remove IPv6 brackets (and any port-number) from the given host-string.
 */
#ifdef USE_SSL
static char *StripIpv6Brackets(char *host)
{
    int port_number;
    char *p;

    if ((p = HTParsePort(host, &port_number)) != 0)
	*p = '\0';

    if (*host == '[') {
	p = host + strlen(host) - 1;
	if (*p == ']') {
	    *p = '\0';
	    ++host;
	}
    }
    return host;
}
#endif

/*		Load Document from HTTP Server			HTLoadHTTP()
 *		==============================
 *
 *	Given a hypertext address, this routine loads a document.
 *
 *
 *  On entry,
 *	arg	is the hypertext reference of the article to be loaded.
 *
 *  On exit,
 *	returns >=0	If no error, a good socket number
 *		<0	Error.
 *
 *	The socket must be closed by the caller after the document has been
 *	read.
 *
 */
static int HTLoadHTTP(const char *arg,
		      HTParentAnchor *anAnchor,
		      HTFormat format_out,
		      HTStream *sink)
{
    static char empty[1];
    int s;			/* Socket number for returned data */
    const char *url = arg;	/* The URL which get_physical() returned */
    bstring *command = NULL;	/* The whole command */
    char *eol;			/* End of line if found */
    char *start_of_data;	/* Start of body of reply */
    int status;			/* tcp return */
    off_t bytes_already_read;
    char crlf[3];		/* A CR LF equivalent string */
    HTStream *target;		/* Unconverted data */
    HTFormat format_in;		/* Format arriving in the message */
    BOOL do_head = FALSE;	/* Whether or not we should do a head */
    BOOL do_post = FALSE;	/* ARE WE posting ? */
    const char *METHOD;

    char *line_buffer = NULL;
    char *line_kept_clean = NULL;

#ifdef SH_EX			/* FIX BUG by kaz@@maczuka.hitachi.ibaraki.jp */
    int real_length_of_line = 0;
#endif
    BOOL extensions;		/* Assume good HTTP server */
    char *linebuf = NULL;
    char temp[80];
    BOOL first_Accept = TRUE;
    BOOL show_401 = FALSE;
    BOOL show_407 = FALSE;
    BOOL auth_proxy = NO;	/* Generate a proxy authorization. - AJL */

    int length, rawlength, rv;
    int server_status = 0;
    BOOL doing_redirect, already_retrying = FALSE;
    int len = 0;

#ifdef USE_SSL
    unsigned long SSLerror;
    BOOL do_connect = FALSE;	/* ARE WE going to use a proxy tunnel ? */
    BOOL did_connect = FALSE;	/* ARE WE actually using a proxy tunnel ? */
    const char *connect_url = NULL;	/* The URL being proxied */
    char *connect_host = NULL;	/* The host being proxied */
    SSL *handle = NULL;		/* The SSL handle */
    X509 *peer_cert;		/* The peer certificate */
    char ssl_dn[1024];
    char *cert_host;
    char *ssl_host;
    char *p;
    char *msg = NULL;
    int status_sslcertcheck;
    char *ssl_dn_start;
    char *ssl_all_cns = NULL;

#ifdef USE_GNUTLS_INCL
    int ret;
    unsigned tls_status;
#endif

#if SSLEAY_VERSION_NUMBER >= 0x0900
    BOOL try_tls = TRUE;
#endif /* SSLEAY_VERSION_NUMBER >= 0x0900 */
    SSL_handle = NULL;
#else
    void *handle = NULL;
#endif /* USE_SSL */

    if (anAnchor->isHEAD)
	do_head = TRUE;
    else if (anAnchor->post_data)
	do_post = TRUE;

    if (!url) {
	status = -3;
	_HTProgress(BAD_REQUEST);
	goto done;
    }
    if (!*url) {
	status = -2;
	_HTProgress(BAD_REQUEST);
	goto done;
    }
#ifdef USE_SSL
    if (using_proxy && !StrNCmp(url, "http://", 7)) {
	int portnumber;

	if ((connect_url = strstr((url + 7), "https://"))) {
	    do_connect = TRUE;
	    connect_host = HTParse(connect_url, "https", PARSE_HOST);
	    if (!HTParsePort(connect_host, &portnumber)) {
		sprintf(temp, ":%d", HTTPS_PORT);
		StrAllocCat(connect_host, temp);
	    }
	    CTRACE((tfp, "HTTP: connect_url = '%s'\n", connect_url));
	    CTRACE((tfp, "HTTP: connect_host = '%s'\n", connect_host));
	} else if ((connect_url = strstr((url + 7), "snews://"))) {
	    do_connect = TRUE;
	    connect_host = HTParse(connect_url, "snews", PARSE_HOST);
	    if (!HTParsePort(connect_host, &portnumber)) {
		sprintf(temp, ":%d", SNEWS_PORT);
		StrAllocCat(connect_host, temp);
	    }
	    CTRACE((tfp, "HTTP: connect_url = '%s'\n", connect_url));
	    CTRACE((tfp, "HTTP: connect_host = '%s'\n", connect_host));
	}
    }
#endif /* USE_SSL */

    sprintf(crlf, "%c%c", CR, LF);

    /*
     * At this point, we're talking HTTP/1.0.
     */
    extensions = YES;

  try_again:
    /*
     * All initializations are moved down here from up above, so we can start
     * over here...
     */
    eol = 0;
    length = 0;
    doing_redirect = FALSE;
    permanent_redirection = FALSE;
    redirect_post_content = FALSE;
    target = NULL;
    line_buffer = NULL;
    line_kept_clean = NULL;

#ifdef USE_SSL
    if (!StrNCmp(url, "https", 5))
	status = HTDoConnect(url, "HTTPS", HTTPS_PORT, &s);
    else
	status = HTDoConnect(url, "HTTP", HTTP_PORT, &s);
#else
    if (!StrNCmp(url, "https", 5)) {
	HTAlert(gettext("This client does not contain support for HTTPS URLs."));
	status = HT_NOT_LOADED;
	goto done;
    }
    status = HTDoConnect(arg, "HTTP", HTTP_PORT, &s);
#endif /* USE_SSL */
    if (status == HT_INTERRUPTED) {
	/*
	 * Interrupt cleanly.
	 */
	CTRACE((tfp, "HTTP: Interrupted on connect; recovering cleanly.\n"));
	_HTProgress(CONNECTION_INTERRUPTED);
	status = HT_NOT_LOADED;
	goto done;
    }
    if (status < 0) {
#ifdef _WINDOWS
	CTRACE((tfp, "HTTP: Unable to connect to remote host for `%s'\n"
		" (status = %d, sock_errno = %d).\n",
		url, status, SOCKET_ERRNO));
#else
	CTRACE((tfp,
		"HTTP: Unable to connect to remote host for `%s' (errno = %d).\n",
		url, SOCKET_ERRNO));
#endif
	HTAlert(gettext("Unable to connect to remote host."));
	status = HT_NOT_LOADED;
	goto done;
    }
#ifdef USE_SSL
  use_tunnel:
    /*
     * If this is an https document, then do the SSL stuff here.
     */
    if (did_connect || !StrNCmp(url, "https", 5)) {
	SSL_handle = handle = HTGetSSLHandle();
	SSL_set_fd(handle, s);
	/* get host we're connecting to */
	ssl_host = HTParse(url, "", PARSE_HOST);
	ssl_host = StripIpv6Brackets(ssl_host);
#if defined(USE_GNUTLS_FUNCS)
	ret = gnutls_server_name_set(handle->gnutls_state,
				     GNUTLS_NAME_DNS,
				     ssl_host, strlen(ssl_host));
	CTRACE((tfp, "...called gnutls_server_name_set(%s) ->%d\n", ssl_host, ret));
#elif SSLEAY_VERSION_NUMBER >= 0x0900
#ifndef USE_NSS_COMPAT_INCL
	if (!try_tls) {
	    handle->options |= SSL_OP_NO_TLSv1;
#if OPENSSL_VERSION_NUMBER >= 0x0090806fL && !defined(OPENSSL_NO_TLSEXT)
	} else {
	    SSL_set_tlsext_host_name(handle, ssl_host);
#endif
	}
#endif
#endif /* SSLEAY_VERSION_NUMBER >= 0x0900 */
	HTSSLInitPRNG();
	status = SSL_connect(handle);

	if (status <= 0) {
#if SSLEAY_VERSION_NUMBER >= 0x0900
	    if (try_tls) {
		_HTProgress(gettext("Retrying connection without TLS."));
		try_tls = FALSE;
		if (did_connect)
		    HTTP_NETCLOSE(s, handle);
		goto try_again;
	    } else {
		CTRACE((tfp,
			"HTTP: Unable to complete SSL handshake for '%s', SSL_connect=%d, SSL error stack dump follows\n",
			url, status));
		SSL_load_error_strings();
		while ((SSLerror = ERR_get_error()) != 0) {
		    CTRACE((tfp, "HTTP: SSL: %s\n", ERR_error_string(SSLerror, NULL)));
		}
		HTAlert("Unable to make secure connection to remote host.");
		if (did_connect)
		    HTTP_NETCLOSE(s, handle);
		status = HT_NOT_LOADED;
		goto done;
	    }
#else
	    unsigned long SSLerror;

	    CTRACE((tfp,
		    "HTTP: Unable to complete SSL handshake for '%s', SSL_connect=%d, SSL error stack dump follows\n",
		    url, status));
	    SSL_load_error_strings();
	    while ((SSLerror = ERR_get_error()) != 0) {
		CTRACE((tfp, "HTTP: SSL: %s\n", ERR_error_string(SSLerror, NULL)));
	    }
	    HTAlert("Unable to make secure connection to remote host.");
	    if (did_connect)
		HTTP_NETCLOSE(s, handle);
	    status = HT_NOT_LOADED;
	    goto done;
#endif /* SSLEAY_VERSION_NUMBER >= 0x0900 */
	}
#ifdef USE_GNUTLS_INCL
	gnutls_certificate_set_verify_flags(handle->gnutls_cred,
					    GNUTLS_VERIFY_DO_NOT_ALLOW_SAME |
					    GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT);
	ret = gnutls_certificate_verify_peers2(handle->gnutls_state, &tls_status);
	if (ret < 0 || (ret == 0 &&
			tls_status & GNUTLS_CERT_SIGNER_NOT_FOUND)) {
	    int flag_continue = 1;
	    char *msg2;

	    if (ret == 0 && tls_status & GNUTLS_CERT_SIGNER_NOT_FOUND) {
		msg2 = gettext("self signed certificate");
	    } else if (tls_status & GNUTLS_CERT_SIGNER_NOT_FOUND) {
		msg2 = gettext("no issuer was found");
	    } else if (tls_status & GNUTLS_CERT_SIGNER_NOT_CA) {
		msg2 = gettext("issuer is not a CA");
	    } else if (tls_status & GNUTLS_CERT_REVOKED) {
		msg2 = gettext("the certificate has been revoked");
	    } else {
		msg2 = gettext("the certificate is not trusted");
	    }
	    HTSprintf0(&msg, SSL_FORCED_PROMPT, msg2);
	    CTRACE((tfp, "HTLoadHTTP: %s\n", msg));
	    if (!ssl_noprompt) {
		if (!HTForcedPrompt(ssl_noprompt, msg, YES)) {
		    flag_continue = 0;
		}
	    } else if (ssl_noprompt == FORCE_PROMPT_NO) {
		flag_continue = 0;
	    }
	    FREE(msg);
	    if (flag_continue == 0) {
		status = HT_NOT_LOADED;
		FREE(msg);
		goto done;
	    }
	}
#endif

	peer_cert = SSL_get_peer_certificate(handle);
#if defined(USE_OPENSSL_INCL) || defined(USE_GNUTLS_FUNCS)
	X509_NAME_oneline(X509_get_subject_name(peer_cert),
			  ssl_dn, (int) sizeof(ssl_dn));
#elif defined(USE_GNUTLS_INCL)
	X509_NAME_oneline(X509_get_subject_name(peer_cert),
			  ssl_dn + 1, (int) sizeof(ssl_dn) - 1);

	/* Iterate over DN in incompatible GnuTLS format to bring it into OpenSSL format */
	ssl_dn[0] = '/';
	ssl_dn_start = ssl_dn;
	while (*ssl_dn_start) {
	    if ((*ssl_dn_start == ',') && (*(ssl_dn_start + 1) == ' ')) {
		*ssl_dn_start++ = '/';
		if (*(p = ssl_dn_start) != 0) {
		    while ((p[0] = p[1]) != 0)
			++p;
		}
	    } else {
		ssl_dn_start++;
	    }
	}
#endif

	/*
	 * X.509 DN validation taking ALL CN fields into account
	 * (c) 2006 Thorsten Glaser <tg@@mirbsd.de>
	 */

	/* initialise status information */
	status_sslcertcheck = 0;	/* 0 = no CN found in DN */
	ssl_dn_start = ssl_dn;

	/* validate all CNs found in DN */
	CTRACE((tfp, "Validating CNs in '%s'\n", ssl_dn_start));
	while ((cert_host = strstr(ssl_dn_start, "/CN=")) != NULL) {
	    status_sslcertcheck = 1;	/* 1 = could not verify CN */
	    /* start of CommonName */
	    cert_host += 4;
	    /* find next part of DistinguishedName */
	    if ((p = strchr(cert_host, '/')) != NULL) {
		*p = '\0';
		ssl_dn_start = p;	/* yes this points to the NUL byte */
	    } else
		ssl_dn_start = NULL;
	    cert_host = StripIpv6Brackets(cert_host);

	    /* verify this CN */
	    CTRACE((tfp, "Matching\n\tssl_host  '%s'\n\tcert_host '%s'\n",
		    ssl_host, cert_host));
	    if (!strcasecomp_asterisk(ssl_host, cert_host)) {
		status_sslcertcheck = 2;	/* 2 = verified peer */
		/* I think this is cool to have in the logs -TG */
		HTSprintf0(&msg,
			   gettext("Verified connection to %s (cert=%s)"),
			   ssl_host, cert_host);
		_HTProgress(msg);
		FREE(msg);
		/* no need to continue the verification loop */
		break;
	    }

	    /* add this CN to list of failed CNs */
	    if (ssl_all_cns == NULL)
		StrAllocCopy(ssl_all_cns, "CN<");
	    else
		StrAllocCat(ssl_all_cns, ":CN<");
	    StrAllocCat(ssl_all_cns, cert_host);
	    StrAllocCat(ssl_all_cns, ">");
	    /* if we cannot retry, don't try it */
	    if (ssl_dn_start == NULL)
		break;
	    /* now retry next CN found in DN */
	    *ssl_dn_start = '/';	/* formerly NUL byte */
	}

	/* check the X.509v3 Subject Alternative Name */
#ifdef USE_GNUTLS_INCL
	if (status_sslcertcheck < 2) {
	    int i;
	    size_t size;
	    gnutls_x509_crt cert;
	    static char buf[2048];

	    /* import the certificate to the x509_crt format */
	    if (gnutls_x509_crt_init(&cert) == 0) {

		if (gnutls_x509_crt_import(cert, peer_cert,
					   GNUTLS_X509_FMT_DER) < 0) {
		    gnutls_x509_crt_deinit(cert);
		    goto done;
		}

		ret = 0;
		for (i = 0; !(ret < 0); i++) {
		    size = sizeof(buf);
		    ret = gnutls_x509_crt_get_subject_alt_name(cert, i, buf,
							       &size, NULL);

		    if (strcasecomp_asterisk(ssl_host, buf) == 0) {
			status_sslcertcheck = 2;
			HTSprintf0(&msg,
				   gettext("Verified connection to %s (subj=%s)"),
				   ssl_host, buf);
			_HTProgress(msg);
			FREE(msg);
			break;
		    }

		}
	    }
	}
#endif
#ifdef USE_OPENSSL_INCL
	if (status_sslcertcheck < 2) {
	    STACK_OF(GENERAL_NAME) * gens;
	    int i, numalts;
	    const GENERAL_NAME *gn;

	    gens = (STACK_OF(GENERAL_NAME) *)
		X509_get_ext_d2i(peer_cert, NID_subject_alt_name, NULL, NULL);

	    if (gens != NULL) {
		numalts = sk_GENERAL_NAME_num(gens);
		for (i = 0; i < numalts; ++i) {
		    gn = sk_GENERAL_NAME_value(gens, i);
		    if (gn->type == GEN_DNS)
			cert_host = (char *) ASN1_STRING_data(gn->d.ia5);
		    else if (gn->type == GEN_IPADD) {
			/* XXX untested -TG */
			size_t j = (size_t) ASN1_STRING_length(gn->d.ia5);

			cert_host = (char *) malloc(j + 1);
			MemCpy(cert_host, ASN1_STRING_data(gn->d.ia5), j);
			cert_host[j] = '\0';
		    } else
			continue;
		    status_sslcertcheck = 1;	/* got at least one */
		    /* verify this SubjectAltName (see above) */
		    cert_host = StripIpv6Brackets(cert_host);
		    if (!(gn->type == GEN_IPADD ? strcasecomp :
			  strcasecomp_asterisk) (ssl_host, cert_host)) {
			status_sslcertcheck = 2;
			HTSprintf0(&msg,
				   gettext("Verified connection to %s (subj=%s)"),
				   ssl_host, cert_host);
			_HTProgress(msg);
			FREE(msg);
			if (gn->type == GEN_IPADD)
			    free(cert_host);
			break;
		    }
		    /* add to list of failed CNs */
		    if (ssl_all_cns == NULL)
			StrAllocCopy(ssl_all_cns, "SAN<");
		    else
			StrAllocCat(ssl_all_cns, ":SAN<");
		    if (gn->type == GEN_DNS)
			StrAllocCat(ssl_all_cns, "DNS=");
		    else if (gn->type == GEN_IPADD)
			StrAllocCat(ssl_all_cns, "IP=");
		    StrAllocCat(ssl_all_cns, cert_host);
		    StrAllocCat(ssl_all_cns, ">");
		    if (gn->type == GEN_IPADD)
			free(cert_host);
		}
		sk_GENERAL_NAME_free(gens);
	    }
	}
#endif /* USE_OPENSSL_INCL */

	/* if an error occurred, format the appropriate message */
	if (status_sslcertcheck == 0) {
	    HTSprintf0(&msg, SSL_FORCED_PROMPT,
		       gettext("Can't find common name in certificate"));
	} else if (status_sslcertcheck == 1) {
	    HTSprintf0(&msg,
		       gettext("SSL error:host(%s)!=cert(%s)-Continue?"),
		       ssl_host, ssl_all_cns);
	}

	/* if an error occurred, let the user decide how much he trusts */
	if (status_sslcertcheck < 2) {
	    if (!HTForcedPrompt(ssl_noprompt, msg, YES)) {
		status = HT_NOT_LOADED;
		FREE(msg);
		FREE(ssl_all_cns);
		goto done;
	    }
	    HTSprintf0(&msg,
		       gettext("UNVERIFIED connection to %s (cert=%s)"),
		       ssl_host, ssl_all_cns ? ssl_all_cns : "NONE");
	    _HTProgress(msg);
	    FREE(msg);
	}

	show_cert_issuer(peer_cert);

	HTSprintf0(&msg,
		   gettext("Secure %d-bit %s (%s) HTTP connection"),
		   SSL_get_cipher_bits(handle, NULL),
		   SSL_get_cipher_version(handle),
		   SSL_get_cipher(handle));
	_HTProgress(msg);
	FREE(msg);
    }
#endif /* USE_SSL */

    /* Ask that node for the document, omitting the host name & anchor
     */
    {
	char *p1 = (HTParse(url, "", PARSE_PATH | PARSE_PUNCTUATION));

#ifdef USE_SSL
	if (do_connect) {
	    METHOD = "CONNECT";
	    BStrCopy0(command, "CONNECT ");
	} else
#endif /* USE_SSL */
	if (do_post) {
	    METHOD = "POST";
	    BStrCopy0(command, "POST ");
	} else if (do_head) {
	    METHOD = "HEAD";
	    BStrCopy0(command, "HEAD ");
	} else {
	    METHOD = "GET";
	    BStrCopy0(command, "GET ");
	}

	/*
	 * If we are using a proxy gateway don't copy in the first slash of
	 * say:  /gopher://a;lkdjfl;ajdf;lkj/;aldk/adflj so that just
	 * gopher://....  is sent.
	 */
#ifdef USE_SSL
	if (using_proxy && !did_connect) {
	    if (do_connect)
		BStrCat0(command, connect_host);
	    else
		BStrCat0(command, p1 + 1);
	}
#else
	if (using_proxy)
	    BStrCat0(command, p1 + 1);
#endif /* USE_SSL */
	else
	    BStrCat0(command, p1);
	FREE(p1);
    }
    if (extensions) {
	BStrCat0(command, " ");
	BStrCat0(command, HTTP_VERSION);
    }

    BStrCat0(command, crlf);	/* CR LF, as in rfc 977 */

    if (extensions) {
	int n, i;
	char *host = NULL;

	if ((host = HTParse(anAnchor->address, "", PARSE_HOST)) != NULL) {
	    strip_userid(host);
	    HTBprintf(&command, "Host: %s%c%c", host, CR, LF);
	    FREE(host);
	}

	if (!HTPresentations)
	    HTFormatInit();
	n = HTList_count(HTPresentations);

	first_Accept = TRUE;
	len = 0;
	for (i = 0; i < n; i++) {
	    HTPresentation *pres =
	    (HTPresentation *) HTList_objectAt(HTPresentations, i);

	    if (pres->get_accept) {
		if (pres->quality < 1.0) {
		    if (pres->maxbytes > 0) {
			sprintf(temp, ";q=%4.3f;mxb=%" PRI_off_t "",
				pres->quality, CAST_off_t (pres->maxbytes));
		    } else {
			sprintf(temp, ";q=%4.3f", pres->quality);
		    }
		} else if (pres->maxbytes > 0) {
		    sprintf(temp, ";mxb=%" PRI_off_t "", CAST_off_t (pres->maxbytes));
		} else {
		    temp[0] = '\0';
		}
		HTSprintf0(&linebuf, "%s%s%s",
			   (first_Accept ?
			    "Accept: " : ", "),
			   HTAtom_name(pres->rep),
			   temp);
		len += (int) strlen(linebuf);
		if (len > 252 && !first_Accept) {
		    BStrCat0(command, crlf);
		    HTSprintf0(&linebuf, "Accept: %s%s",
			       HTAtom_name(pres->rep),
			       temp);
		    len = (int) strlen(linebuf);
		}
		BStrCat0(command, linebuf);
		first_Accept = FALSE;
	    }
	}
	HTBprintf(&command, "%s*/*;q=0.01%c%c",
		  (first_Accept ?
		   "Accept: " : ", "), CR, LF);

	/*
	 * FIXME:  suppressing the "Accept-Encoding" in this case is done to
	 * work around limitations of the presentation logic used for the
	 * command-line "-base" option.  The remote site may transmit the
	 * document gzip'd, but the ensuing logic in HTSaveToFile() would see
	 * the mime-type as gzip rather than text/html, and not prepend the
	 * base URL.  This is less efficient than accepting the compressed data
	 * and uncompressing it, adding the base URL but is simpler than
	 * augmenting the dump's presentation logic -TD
	 */
	if (LYPrependBaseToSource && dump_output_immediately) {
	    CTRACE((tfp,
		    "omit Accept-Encoding to work-around interaction with -source\n"));
	} else {
	    char *list = 0;
	    int j, k;

	    for (j = 1; j < encodingALL; j <<= 1) {
		if (acceptEncoding(j)) {
		    for (k = 0; tbl_preferred_encoding[k].name != 0; ++k) {
			if (tbl_preferred_encoding[k].value == j) {
			    if (list != 0)
				StrAllocCat(list, ", ");
			    StrAllocCat(list, tbl_preferred_encoding[k].name);
			    break;
			}
		    }
		}
	    }

	    if (list != 0) {
		HTBprintf(&command, "Accept-Encoding: %s%c%c", list, CR, LF);
		free(list);
	    }
	}

	if (language && *language) {
	    HTBprintf(&command, "Accept-Language: %s%c%c", language, CR, LF);
	}

	if (pref_charset && *pref_charset) {
	    BStrCat0(command, "Accept-Charset: ");
	    StrAllocCopy(linebuf, pref_charset);
	    if (linebuf[strlen(linebuf) - 1] == ',')
		linebuf[strlen(linebuf) - 1] = '\0';
	    LYLowerCase(linebuf);
	    if (strstr(linebuf, "iso-8859-1") == NULL)
		StrAllocCat(linebuf, ", iso-8859-1;q=0.01");
	    if (strstr(linebuf, "us-ascii") == NULL)
		StrAllocCat(linebuf, ", us-ascii;q=0.01");
	    BStrCat0(command, linebuf);
	    HTBprintf(&command, "%c%c", CR, LF);
	}
#if 0
	/*
	 * Promote 300 (Multiple Choices) replies, if supported, over 406 (Not
	 * Acceptable) replies.  - FM
	 *
	 * This used to be done in versions 2.7 and 2.8*, but violates the
	 * specs for transparent content negotiation and has the effect that
	 * servers supporting those specs will send 300 (Multiple Choices)
	 * instead of a normal response (e.g.  200 OK), since they will assume
	 * that the client wants to make the choice.  It is not clear whether
	 * there are any servers or sites for which sending this header really
	 * improves anything.
	 *
	 * If there ever is a need to send "Negotiate:  trans" and really mean
	 * it, we should send "Negotiate:  trans,trans" or similar, since that
	 * is semantically equivalent and some servers may ignore "Negotiate:
	 * trans" as a special case when it comes from Lynx (to work around the
	 * old faulty behavior).  - kw
	 *
	 * References:
	 * RFC 2295 (see also RFC 2296), and mail to lynx-dev and
	 * new-httpd@@apache.org from Koen Holtman, Jan 1999.
	 */
	if (!do_post) {
	    HTBprintf(&command, "Negotiate: trans%c%c", CR, LF);
	}
#endif /* 0 */

	/*
	 * When reloading give no-cache pragma to proxy server to make it
	 * refresh its cache.  -- Ari L.  <luotonen@@dxcern.cern.ch>
	 *
	 * Also send it as a Cache-Control header for HTTP/1.1.  - FM
	 */
	if (reloading) {
	    HTBprintf(&command, "Pragma: no-cache%c%c", CR, LF);
	    HTBprintf(&command, "Cache-Control: no-cache%c%c", CR, LF);
	}

	if (LYSendUserAgent || no_useragent) {
	    if (non_empty(LYUserAgent)) {
		char *cp = LYSkipBlanks(LYUserAgent);

		/* Won't send it at all if all blank - kw */
		if (*cp != '\0')
		    HTBprintf(&command, "User-Agent: %.*s%c%c",
			      INIT_LINE_SIZE - 15, LYUserAgent, CR, LF);
	    } else {
		HTBprintf(&command, "User-Agent: %s/%s  libwww-FM/%s%c%c",
			  HTAppName ? HTAppName : "unknown",
			  HTAppVersion ? HTAppVersion : "0.0",
			  HTLibraryVersion, CR, LF);
	    }
	}

	if (personal_mail_address && !LYNoFromHeader) {
	    HTBprintf(&command, "From: %s%c%c", personal_mail_address, CR, LF);
	}

	if (!(LYUserSpecifiedURL ||
	      LYNoRefererHeader || LYNoRefererForThis) &&
	    strcmp(HTLoadedDocumentURL(), "")) {
	    const char *cp = LYRequestReferer;

	    if (!cp)
		cp = HTLoadedDocumentURL();	/* @@@@@@ Try both? - kw */
	    BStrCat0(command, "Referer: ");
	    if (isLYNXIMGMAP(cp)) {
		char *pound = findPoundSelector(cp);
		int nn = (pound ? (int) (pound - cp) : (int) strlen(cp));

		HTSABCat(&command, cp + LEN_LYNXIMGMAP, nn);
	    } else {
		BStrCat0(command, cp);
	    }
	    HTBprintf(&command, "%c%c", CR, LF);
	} {
	    char *abspath;
	    char *docname;
	    char *hostname;
	    char *colon;
	    int portnumber;
	    char *auth, *cookie = NULL;
	    BOOL secure = (BOOL) (StrNCmp(anAnchor->address, "https", 5)
				  ? FALSE
				  : TRUE);

	    abspath = HTParse(arg, "", PARSE_PATH | PARSE_PUNCTUATION);
	    docname = HTParse(arg, "", PARSE_PATH);
	    hostname = HTParse(arg, "", PARSE_HOST);
	    if (hostname &&
		NULL != (colon = HTParsePort(hostname, &portnumber))) {
		*colon = '\0';	/* Chop off port number */
	    } else if (!StrNCmp(arg, "https", 5)) {
		portnumber = HTTPS_PORT;
	    } else {
		portnumber = HTTP_PORT;
	    }

	    /*
	     * Add Authorization, Proxy-Authorization, and/or Cookie headers,
	     * if applicable.
	     */
	    if (using_proxy) {
		/*
		 * If we are using a proxy, first determine if we should
		 * include an Authorization header and/or Cookie header for the
		 * ultimate target of this request.  - FM & AJL
		 */
		char *host2 = NULL, *path2 = NULL;
		int port2 = (StrNCmp(docname, "https", 5) ?
			     HTTP_PORT : HTTPS_PORT);

		host2 = HTParse(docname, "", PARSE_HOST);
		path2 = HTParse(docname, "", PARSE_PATH | PARSE_PUNCTUATION);
		if (host2) {
		    if ((colon = HTParsePort(host2, &port2)) != NULL) {
			/* Use non-default port number */
			*colon = '\0';
		    }
		}
		/*
		 * This composeAuth() does file access, i.e., for the ultimate
		 * target of the request.  - AJL
		 */
		auth_proxy = NO;
		if ((auth = HTAA_composeAuth(host2, port2, path2,
					     auth_proxy)) != NULL &&
		    *auth != '\0') {
		    /*
		     * If auth is not NULL nor zero-length, it's an
		     * Authorization header to be included.  - FM
		     */
		    HTBprintf(&command, "%s%c%c", auth, CR, LF);
		    CTRACE((tfp, "HTTP: Sending authorization: %s\n", auth));
		} else if (auth && *auth == '\0') {
		    /*
		     * If auth is a zero-length string, the user either
		     * cancelled or goofed at the username and password prompt.
		     * - FM
		     */
		    if (!(traversal || dump_output_immediately) &&
			HTConfirm(CONFIRM_WO_PASSWORD)) {
			show_401 = TRUE;
		    } else {
			if (traversal || dump_output_immediately)
			    HTAlert(FAILED_NEED_PASSWD);
#ifdef USE_SSL
			if (did_connect)
			    HTTP_NETCLOSE(s, handle);
#endif /* USE_SSL */
			BStrFree(command);
			FREE(hostname);
			FREE(docname);
			FREE(abspath);
			FREE(host2);
			FREE(path2);
			status = HT_NOT_LOADED;
			goto done;
		    }
		} else {
		    CTRACE((tfp, "HTTP: Not sending authorization (yet).\n"));
		}
		/*
		 * Add 'Cookie:' header, if it's HTTP or HTTPS document being
		 * proxied.
		 */
		if (!StrNCmp(docname, "http", 4)) {
		    cookie = LYAddCookieHeader(host2, path2, port2, secure);
		}
		FREE(host2);
		FREE(path2);
		/*
		 * The next composeAuth() will be for the proxy.  - AJL
		 */
		auth_proxy = YES;
	    } else {
		/*
		 * Add cookie for a non-proxied request.  - FM
		 */
		cookie = LYAddCookieHeader(hostname, abspath, portnumber, secure);
		auth_proxy = NO;
	    }
	    /*
	     * If we do have a cookie set, add it to the request buffer.  - FM
	     */
	    if (cookie != NULL) {
		if (*cookie != '$') {
		    /*
		     * It's a historical cookie, so signal to the server that
		     * we support modern cookies.  - FM
		     */
		    BStrCat0(command, "Cookie2: $Version=\"1\"");
		    BStrCat0(command, crlf);
		    CTRACE((tfp, "HTTP: Sending Cookie2: $Version =\"1\"\n"));
		}
		if (*cookie != '\0') {
		    /*
		     * It's not a zero-length string, so add the header.  Note
		     * that any folding of long strings has been done already
		     * in LYCookie.c.  - FM
		     */
		    BStrCat0(command, "Cookie: ");
		    BStrCat0(command, cookie);
		    BStrCat0(command, crlf);
		    CTRACE((tfp, "HTTP: Sending Cookie: %s\n", cookie));
		}
		FREE(cookie);
	    }
	    FREE(abspath);

	    /*
	     * If we are using a proxy, auth_proxy should be YES, and we check
	     * here whether we want a Proxy-Authorization header for it.  If we
	     * are not using a proxy, auth_proxy should still be NO, and we
	     * check here for whether we want an Authorization header.  - FM &
	     * AJL
	     */
	    if ((auth = HTAA_composeAuth(hostname,
					 portnumber,
					 docname,
					 auth_proxy)) != NULL &&
		*auth != '\0') {
		/*
		 * If auth is not NULL nor zero-length, it's an Authorization
		 * or Proxy-Authorization header to be included.  - FM
		 */
		HTBprintf(&command, "%s%c%c", auth, CR, LF);
		CTRACE((tfp, (auth_proxy ?
			      "HTTP: Sending proxy authorization: %s\n" :
			      "HTTP: Sending authorization: %s\n"),
			auth));
	    } else if (auth && *auth == '\0') {
		/*
		 * If auth is a zero-length string, the user either cancelled
		 * or goofed at the username and password prompt.  - FM
		 */
		if (!(traversal || dump_output_immediately) && HTConfirm(CONFIRM_WO_PASSWORD)) {
		    if (auth_proxy == TRUE) {
			show_407 = TRUE;
		    } else {
			show_401 = TRUE;
		    }
		} else {
		    if (traversal || dump_output_immediately)
			HTAlert(FAILED_NEED_PASSWD);
		    BStrFree(command);
		    FREE(hostname);
		    FREE(docname);
		    status = HT_NOT_LOADED;
		    goto done;
		}
	    } else {
		CTRACE((tfp, (auth_proxy ?
			      "HTTP: Not sending proxy authorization (yet).\n" :
			      "HTTP: Not sending authorization (yet).\n")));
	    }
	    FREE(hostname);
	    FREE(docname);
	}
    }

    if (
#ifdef USE_SSL
	   !do_connect &&
#endif /* USE_SSL */
	   do_post) {
	CTRACE((tfp, "HTTP: Doing post, content-type '%s'\n",
		anAnchor->post_content_type
		? anAnchor->post_content_type
		: "lose"));
	HTBprintf(&command, "Content-type: %s%c%c",
		  anAnchor->post_content_type
		  ? anAnchor->post_content_type
		  : "lose",
		  CR, LF);

	HTBprintf(&command, "Content-length: %d%c%c",
		  !isBEmpty(anAnchor->post_data)
		  ? BStrLen(anAnchor->post_data)
		  : 0,
		  CR, LF);

	BStrCat0(command, crlf);	/* Blank line means "end" of headers */

	BStrCat(command, anAnchor->post_data);
    } else
	BStrCat0(command, crlf);	/* Blank line means "end" of headers */

    if (TRACE) {
	CTRACE((tfp, "Writing:\n"));
	trace_bstring(command);
#ifdef USE_SSL
	CTRACE((tfp, "%s",
		(anAnchor->post_data && !do_connect ? crlf : "")));
#else
	CTRACE((tfp, "%s",
		(anAnchor->post_data ? crlf : "")));
#endif /* USE_SSL */
	CTRACE((tfp, "----------------------------------\n"));
    }

    _HTProgress(gettext("Sending HTTP request."));

#ifdef    NOT_ASCII		/* S/390 -- gil -- 0548 */
    {
	char *p2;

	for (p2 = BStrData(command);
	     p2 < BStrData(command) + BStrLen(command);
	     p2++)
	    *p2 = TOASCII(*p2);
    }
#endif /* NOT_ASCII */
    status = (int) HTTP_NETWRITE(s,
				 BStrData(command),
				 BStrLen(command),
				 handle);
    BStrFree(command);
    FREE(linebuf);
    if (status <= 0) {
	if (status == 0) {
	    CTRACE((tfp, "HTTP: Got status 0 in initial write\n"));
	    /* Do nothing. */
	} else if ((SOCKET_ERRNO == ENOTCONN ||
		    SOCKET_ERRNO == ECONNRESET ||
		    SOCKET_ERRNO == EPIPE) &&
		   !already_retrying &&
	    /* Don't retry if we're posting. */ !do_post) {
	    /*
	     * Arrrrgh, HTTP 0/1 compatibility problem, maybe.
	     */
	    CTRACE((tfp,
		    "HTTP: BONZO ON WRITE Trying again with HTTP0 request.\n"));
	    _HTProgress(RETRYING_AS_HTTP0);
	    HTTP_NETCLOSE(s, handle);
	    extensions = NO;
	    already_retrying = TRUE;
	    goto try_again;
	} else {
	    CTRACE((tfp,
		    "HTTP: Hit unexpected network WRITE error; aborting connection.\n"));
	    HTTP_NETCLOSE(s, handle);
	    status = -1;
	    HTAlert(gettext("Unexpected network write error; connection aborted."));
	    goto done;
	}
    }

    CTRACE((tfp, "HTTP: WRITE delivered OK\n"));
    _HTProgress(gettext("HTTP request sent; waiting for response."));

    /*    Read the first line of the response
     * -----------------------------------
     */
    {
	/* Get numeric status etc */
	BOOL end_of_file = NO;
	int buffer_length = INIT_LINE_SIZE;

	line_buffer = typecallocn(char, (size_t) buffer_length);

	if (line_buffer == NULL)
	    outofmem(__FILE__, "HTLoadHTTP");

	HTReadProgress(bytes_already_read = 0, (off_t) 0);
	do {			/* Loop to read in the first line */
	    /*
	     * Extend line buffer if necessary for those crazy WAIS URLs ;-)
	     */
	    if (buffer_length - length < LINE_EXTEND_THRESH) {
		buffer_length = buffer_length + buffer_length;
		line_buffer =
		    (char *) realloc(line_buffer, ((unsigned) buffer_length *
						   sizeof(char)));

		if (line_buffer == NULL)
		    outofmem(__FILE__, "HTLoadHTTP");
	    }
	    CTRACE((tfp, "HTTP: Trying to read %d\n", buffer_length - length - 1));
	    status = HTTP_NETREAD(s,
				  line_buffer + length,
				  (buffer_length - length - 1),
				  handle);
	    CTRACE((tfp, "HTTP: Read %d\n", status));
	    if (status <= 0) {
		/*
		 * Retry if we get nothing back too.
		 * Bomb out if we get nothing twice.
		 */
		if (status == HT_INTERRUPTED) {
		    CTRACE((tfp, "HTTP: Interrupted initial read.\n"));
		    _HTProgress(CONNECTION_INTERRUPTED);
		    HTTP_NETCLOSE(s, handle);
		    status = HT_NO_DATA;
		    goto clean_up;
		} else if (status < 0 &&
			   (SOCKET_ERRNO == ENOTCONN ||
#ifdef _WINDOWS			/* 1997/11/09 (Sun) 16:59:58 */
			    SOCKET_ERRNO == ETIMEDOUT ||
#endif
			    SOCKET_ERRNO == ECONNRESET ||
			    SOCKET_ERRNO == EPIPE) &&
			   !already_retrying && !do_post) {
		    /*
		     * Arrrrgh, HTTP 0/1 compability problem, maybe.
		     */
		    CTRACE((tfp,
			    "HTTP: BONZO Trying again with HTTP0 request.\n"));
		    HTTP_NETCLOSE(s, handle);
		    FREE(line_buffer);
		    FREE(line_kept_clean);

		    extensions = NO;
		    already_retrying = TRUE;
		    _HTProgress(RETRYING_AS_HTTP0);
		    goto try_again;
		}
#ifdef USE_SSL
		else if ((SSLerror = ERR_get_error()) != 0) {
		    CTRACE((tfp,
			    "HTTP: Hit unexpected network read error; aborting connection; status %d:%s.\n",
			    status, ERR_error_string(SSLerror, NULL)));
		    HTAlert(gettext("Unexpected network read error; connection aborted."));
		    HTTP_NETCLOSE(s, handle);
		    status = -1;
		    goto clean_up;
		}
#endif
		else {
		    CTRACE((tfp,
			    "HTTP: Hit unexpected network read error; aborting connection; status %d.\n",
			    status));
		    HTAlert(gettext("Unexpected network read error; connection aborted."));
		    HTTP_NETCLOSE(s, handle);
		    status = -1;
		    goto clean_up;
		}
	    }
#ifdef    NOT_ASCII		/* S/390 -- gil -- 0564 */
	    {
		char *p2;

		for (p2 = line_buffer + length;
		     p2 < line_buffer + length + status;
		     p2++)
		    *p2 = FROMASCII(*p2);
	    }
#endif /* NOT_ASCII */

	    bytes_already_read += status;
	    HTReadProgress(bytes_already_read, (off_t) 0);

#ifdef UCX			/* UCX returns -1 on EOF */
	    if (status == 0 || status == -1)
#else
	    if (status == 0)
#endif
	    {
		break;
	    }
	    line_buffer[length + status] = 0;

	    if (line_buffer) {
		FREE(line_kept_clean);
		line_kept_clean = (char *) malloc((unsigned) buffer_length *
						  sizeof(char));

		if (line_kept_clean == NULL)
		    outofmem(__FILE__, "HTLoadHTTP");
		MemCpy(line_kept_clean, line_buffer, buffer_length);
#ifdef SH_EX			/* FIX BUG by kaz@@maczuka.hitachi.ibaraki.jp */
		real_length_of_line = length + status;
#endif
	    }

	    eol = strchr(line_buffer + length, LF);
	    /* Do we *really* want to do this? */
	    if (eol && eol != line_buffer && *(eol - 1) == CR)
		*(eol - 1) = ' ';

	    length = length + status;

	    /* Do we really want to do *this*? */
	    if (eol)
		*eol = 0;	/* Terminate the line */
	}
	/* All we need is the first line of the response.  If it's a HTTP/1.0
	 * response, then the first line will be absurdly short and therefore
	 * we can safely gate the number of bytes read through this code (as
	 * opposed to below) to ~1000.
	 *
	 * Well, let's try 100.
	 */
	while (!eol && !end_of_file && bytes_already_read < 100);
    }				/* Scope of loop variables */

    /* save total length, in case we decide later to show it all - kw */
    rawlength = length;

    /*    We now have a terminated unfolded line.  Parse it.
     * --------------------------------------------------
     */
    CTRACE((tfp, "HTTP: Rx: %s\n", line_buffer));

    /*
     * Kludge to work with old buggy servers and the VMS Help gateway.  They
     * can't handle the third word, so we try again without it.
     */
    if (extensions &&		/* Old buggy server or Help gateway? */
	(0 == StrNCmp(line_buffer, "<TITLE>Bad File Request</TITLE>", 31) ||
	 0 == StrNCmp(line_buffer, "Address should begin with", 25) ||
	 0 == StrNCmp(line_buffer, "<TITLE>Help ", 12) ||
	 0 == strcmp(line_buffer,
		     "Document address invalid or access not authorised"))) {
	FREE(line_buffer);
	FREE(line_kept_clean);
	extensions = NO;
	already_retrying = TRUE;
	CTRACE((tfp, "HTTP: close socket %d to retry with HTTP0\n", s));
	HTTP_NETCLOSE(s, handle);
	/* print a progress message */
	_HTProgress(RETRYING_AS_HTTP0);
	goto try_again;
    } {
	int fields;
	char server_version[VERSION_LENGTH + 1];

	server_version[0] = 0;

	fields = sscanf(line_buffer, "%20s %d",
			server_version,
			&server_status);

	CTRACE((tfp, "HTTP: Scanned %d fields from line_buffer\n", fields));

	if (http_error_file) {	/* Make the status code externally available */
	    FILE *error_file;

#ifdef SERVER_STATUS_ONLY
	    error_file = fopen(http_error_file, TXT_W);
	    if (error_file) {	/* Managed to open the file */
		fprintf(error_file, "error=%d\n", server_status);
		fclose(error_file);
	    }
#else
	    error_file = fopen(http_error_file, TXT_A);
	    if (error_file) {	/* Managed to open the file */
		fprintf(error_file, "   URL=%s (%s)\n", url, METHOD);
		fprintf(error_file, "STATUS=%s\n", line_buffer);
		fclose(error_file);
	    }
#endif /* SERVER_STATUS_ONLY */
	}

	/*
	 * Rule out a non-HTTP/1.n reply as best we can.
	 */
	if (fields < 2 || !server_version[0] || server_version[0] != 'H' ||
	    server_version[1] != 'T' || server_version[2] != 'T' ||
	    server_version[3] != 'P' || server_version[4] != '/' ||
	    server_version[6] != '.') {
	    /*
	     * Ugh!  An HTTP0 reply,
	     */
	    HTAtom *encoding;

	    CTRACE((tfp, "--- Talking HTTP0.\n"));

	    format_in = HTFileFormat(url, &encoding, NULL);
	    /*
	     * Treat all plain text as HTML.  This sucks but its the only
	     * solution without without looking at content.
	     */
	    if (!StrNCmp(HTAtom_name(format_in), "text/plain", 10)) {
		CTRACE((tfp, "HTTP: format_in being changed to text/HTML\n"));
		format_in = WWW_HTML;
	    }
	    if (!IsUnityEnc(encoding)) {
		/*
		 * Change the format to that for "www/compressed".
		 */
		CTRACE((tfp, "HTTP: format_in is '%s',\n", HTAtom_name(format_in)));
		StrAllocCopy(anAnchor->content_type, HTAtom_name(format_in));
		StrAllocCopy(anAnchor->content_encoding, HTAtom_name(encoding));
		format_in = HTAtom_for("www/compressed");
		CTRACE((tfp, "        Treating as '%s' with encoding '%s'\n",
			"www/compressed", HTAtom_name(encoding)));
	    }

	    start_of_data = line_kept_clean;
	} else {
	    /*
	     * Set up to decode full HTTP/1.n response.  - FM
	     */
	    format_in = HTAtom_for("www/mime");
	    CTRACE((tfp, "--- Talking HTTP1.\n"));

	    /*
	     * We set start_of_data to "" when !eol here because there will be
	     * a put_block done below; we do *not* use the value of
	     * start_of_data (as a pointer) in the computation of length (or
	     * anything else) when !eol.  Otherwise, set the value of length to
	     * what we have beyond eol (i.e., beyond the status line).  - FM
	     */
	    if (eol != 0) {
		start_of_data = (eol + 1);
	    } else {
		start_of_data = empty;
	    }
	    length = (eol
		      ? length - (int) (start_of_data - line_buffer)
		      : 0);

	    /*
	     * Trim trailing spaces in line_buffer so that we can use it in
	     * messages which include the status line.  - FM
	     */
	    while (line_buffer[strlen(line_buffer) - 1] == ' ')
		line_buffer[strlen(line_buffer) - 1] = '\0';

	    /*
	     * Take appropriate actions based on the status.  - FM
	     */
	    switch (server_status / 100) {
	    case 1:
		/*
		 * HTTP/1.1 Informational statuses.
		 * 100 Continue.
		 * 101 Switching Protocols.
		 * > 101 is unknown.
		 * We should never get these, and they have only the status
		 * line and possibly other headers, so we'll deal with them by
		 * showing the full header to the user as text/plain.  - FM
		 */
		HTAlert(gettext("Got unexpected Informational Status."));
		do_head = TRUE;
		break;

	    case 2:
		/*
		 * Good:  Got MIME object!  (Successful) - FM
		 */
		if (do_head) {
		    /*
		     * If HEAD was requested, show headers (and possibly bogus
		     * body) for all 2xx status codes as text/plain - KW
		     */
		    HTProgress(line_buffer);
		    break;
		}
		switch (server_status) {
		case 204:
		    /*
		     * No Content.
		     */
		    HTAlert(line_buffer);
		    HTTP_NETCLOSE(s, handle);
		    HTNoDataOK = 1;
		    status = HT_NO_DATA;
		    goto clean_up;

		case 205:
		    /*
		     * Reset Content.  The server has fulfilled the request but
		     * nothing is returned and we should reset any form
		     * content.  We'll instruct the user to do that, and
		     * restore the current document.  - FM
		     */
		    HTAlert(gettext("Request fulfilled.  Reset Content."));
		    HTTP_NETCLOSE(s, handle);
		    status = HT_NO_DATA;
		    goto clean_up;

		case 206:
		    /*
		     * Partial Content.  We didn't send a Range so something
		     * went wrong somewhere.  Show the status message and
		     * restore the current document.  - FM
		     */
		    HTAlert(line_buffer);
		    HTTP_NETCLOSE(s, handle);
		    status = HT_NO_DATA;
		    goto clean_up;

		default:
		    /*
		     * 200 OK.
		     * 201 Created.
		     * 202 Accepted.
		     * 203 Non-Authoritative Information.
		     * > 206 is unknown.
		     * All should return something to display.
		     */
#if defined(USE_SSL) && !defined(DISABLE_NEWS)
		    if (do_connect) {
			CTRACE((tfp,
				"HTTP: Proxy tunnel to '%s' established.\n",
				connect_host));
			do_connect = FALSE;
			url = connect_url;
			FREE(line_buffer);
			FREE(line_kept_clean);
			if (!StrNCmp(connect_url, "snews", 5)) {
			    CTRACE((tfp,
				    "      Will attempt handshake and snews connection.\n"));
			    status = HTNewsProxyConnect(s, url, anAnchor,
							format_out, sink);
			    goto done;
			}
			did_connect = TRUE;
			already_retrying = TRUE;
			eol = 0;
			length = 0;
			doing_redirect = FALSE;
			permanent_redirection = FALSE;
			target = NULL;
			CTRACE((tfp,
				"      Will attempt handshake and resubmit headers.\n"));
			goto use_tunnel;
		    }
#endif /* USE_SSL */
		    HTProgress(line_buffer);
		}		/* case 2 switch */
		break;

	    case 3:
		/*
		 * Various forms of Redirection.  - FM
		 * 300 Multiple Choices.
		 * 301 Moved Permanently.
		 * 302 Found (temporary; we can, and do, use GET).
		 * 303 See Other (temporary; always use GET).
		 * 304 Not Modified.
		 * 305 Use Proxy.
		 * 306 Set Proxy.
		 * 307 Temporary Redirect with method retained.
		 * > 308 is unknown.
		 */
		if (no_url_redirection || do_head || keep_mime_headers) {
		    /*
		     * If any of these flags are set, we do not redirect, but
		     * instead show what was returned to the user as
		     * text/plain.  - FM
		     */
		    HTProgress(line_buffer);
		    break;
		}

		if (server_status == 300) {	/* Multiple Choices */
		    /*
		     * For client driven content negotiation.  The server
		     * should be sending some way for the user-agent to make a
		     * selection, so we'll show the user whatever the server
		     * returns.  There might be a Location:  header with the
		     * server's preference present, but the choice should be up
		     * to the user, someday based on an Alternates:  header,
		     * and a body always should be present with descriptions
		     * and links for the choices (i.e., we use the latter, for
		     * now).  - FM
		     */
		    HTAlert(line_buffer);
		    if (traversal) {
			HTTP_NETCLOSE(s, handle);
			status = -1;
			goto clean_up;
		    }
		    if (!dump_output_immediately &&
			format_out == HTAtom_for("www/download")) {
			/*
			 * Convert a download request to a presentation request
			 * for interactive users.  - FM
			 */
			format_out = WWW_PRESENT;
		    }
		    break;
		}

		if (server_status == 304) {	/* Not Modified */
		    /*
		     * We didn't send an "If-Modified-Since" header, so this
		     * status is inappropriate.  We'll deal with it by showing
		     * the full header to the user as text/plain.  - FM
		     */
		    HTAlert(gettext("Got unexpected 304 Not Modified status."));
		    do_head = TRUE;
		    break;
		}

		if (server_status == 305 ||
		    server_status == 306 ||
		    server_status > 307) {
		    /*
		     * Show user the content, if any, for 305, 306, or unknown
		     * status.  - FM
		     */
		    HTAlert(line_buffer);
		    if (traversal) {
			HTTP_NETCLOSE(s, handle);
			status = -1;
			goto clean_up;
		    }
		    if (!dump_output_immediately &&
			format_out == HTAtom_for("www/download")) {
			/*
			 * Convert a download request to a presentation request
			 * for interactive users.  - FM
			 */
			format_out = WWW_PRESENT;
		    }
		    break;
		}

		/*
		 * We do not load the file, but read the headers for the
		 * "Location:", check out that redirecting_url and if it's
		 * acceptible (e.g., not a telnet URL when we have that
		 * disabled), initiate a new fetch.  If that's another
		 * redirecting_url, we'll repeat the checks, and fetch
		 * initiations if acceptible, until we reach the actual URL, or
		 * the redirection limit set in HTAccess.c is exceeded.  If the
		 * status was 301 indicating that the relocation is permanent,
		 * we set the permanent_redirection flag to make it permanent
		 * for the current anchor tree (i.e., will persist until the
		 * tree is freed or the client exits).  If the redirection
		 * would include POST content, we seek confirmation from an
		 * interactive user, with option to use 303 for 301 (but not
		 * for 307), and otherwise refuse the redirection.  We also
		 * don't allow permanent redirection if we keep POST content.
		 * If we don't find the Location header or its value is
		 * zero-length, we display whatever the server returned, and
		 * the user should RELOAD that to try again, or make a
		 * selection from it if it contains links, or Left-Arrow to the
		 * previous document.  - FM
		 */
		{
		    if ((dump_output_immediately || traversal) &&
			do_post &&
			server_status != 303 &&
			server_status != 302 &&
			server_status != 301) {
			/*
			 * Don't redirect POST content without approval from an
			 * interactive user.  - FM
			 */
			HTTP_NETCLOSE(s, handle);
			status = -1;
			HTAlert(gettext("Redirection of POST content requires user approval."));
			if (traversal)
			    HTProgress(line_buffer);
			goto clean_up;
		    }

		    HTProgress(line_buffer);
		    if (server_status == 301) {		/* Moved Permanently */
			if (do_post) {
			    /*
			     * Don't make the redirection permanent if we have
			     * POST content.  - FM
			     */
			    CTRACE((tfp,
				    "HTTP: Have POST content.  Treating 301 (Permanent) as Temporary.\n"));
			    HTAlert(gettext("Have POST content.  Treating Permanent Redirection as Temporary.\n"));
			} else {
			    permanent_redirection = TRUE;
			}
		    }
		    doing_redirect = TRUE;

		    break;
		}

	    case 4:
		/*
		 * "I think I goofed!" (Client Error) - FM
		 */
		switch (server_status) {
		case 401:	/* Unauthorized */
		    /*
		     * Authorization for origin server required.  If show_401
		     * is set, proceed to showing the 401 body.  Otherwise, if
		     * we can set up authorization based on the
		     * WWW-Authenticate header, and the user provides a
		     * username and password, try again.  Otherwise, check
		     * whether to show the 401 body or restore the current
		     * document - FM
		     */
		    if (show_401)
			break;
		    if (HTAA_shouldRetryWithAuth(start_of_data, (size_t)
						 length, s, NO)) {

			HTTP_NETCLOSE(s, handle);
			if (dump_output_immediately && !authentication_info[0]) {
			    fprintf(stderr,
				    "HTTP: Access authorization required.\n");
			    fprintf(stderr,
				    "       Use the -auth=id:pw parameter.\n");
			    status = HT_NO_DATA;
			    goto clean_up;
			}

			CTRACE((tfp, "%s %d %s\n",
				"HTTP: close socket", s,
				"to retry with Access Authorization"));

			_HTProgress(gettext("Retrying with access authorization information."));
			FREE(line_buffer);
			FREE(line_kept_clean);
#ifdef USE_SSL
			if (using_proxy && !StrNCmp(url, "https://", 8)) {
			    url = arg;
			    do_connect = TRUE;
			    did_connect = FALSE;
			}
#endif /* USE_SSL */
			goto try_again;
		    } else if (!(traversal || dump_output_immediately) &&
			       HTConfirm(gettext("Show the 401 message body?"))) {
			break;
		    } else {
			if (traversal || dump_output_immediately)
			    HTAlert(FAILED_RETRY_WITH_AUTH);
			HTTP_NETCLOSE(s, handle);
			status = -1;
			goto clean_up;
		    }

		case 407:
		    /*
		     * Authorization for proxy server required.  If we are not
		     * in fact using a proxy, or show_407 is set, proceed to
		     * showing the 407 body.  Otherwise, if we can set up
		     * authorization based on the Proxy-Authenticate header,
		     * and the user provides a username and password, try
		     * again.  Otherwise, check whether to show the 401 body or
		     * restore the current document.  - FM & AJL
		     */
		    if (!using_proxy || show_407)
			break;
		    if (HTAA_shouldRetryWithAuth(start_of_data, (size_t)
						 length, s, YES)) {

			HTTP_NETCLOSE(s, handle);
			if (dump_output_immediately && !proxyauth_info[0]) {
			    fprintf(stderr,
				    "HTTP: Proxy authorization required.\n");
			    fprintf(stderr,
				    "       Use the -pauth=id:pw parameter.\n");
			    status = HT_NO_DATA;
			    goto clean_up;
			}

			CTRACE((tfp, "%s %d %s\n",
				"HTTP: close socket", s,
				"to retry with Proxy Authorization"));

			_HTProgress(HTTP_RETRY_WITH_PROXY);
			FREE(line_buffer);
			FREE(line_kept_clean);
			goto try_again;
		    } else if (!(traversal || dump_output_immediately) &&
			       HTConfirm(gettext("Show the 407 message body?"))) {
			if (!dump_output_immediately &&
			    format_out == HTAtom_for("www/download")) {
			    /*
			     * Convert a download request to a presentation
			     * request for interactive users.  - FM
			     */
			    format_out = WWW_PRESENT;
			}
			break;
		    } else {
			if (traversal || dump_output_immediately)
			    HTAlert(FAILED_RETRY_WITH_PROXY);
			HTTP_NETCLOSE(s, handle);
			status = -1;
			goto clean_up;
		    }

		case 408:
		    /*
		     * Request Timeout.  Show the status message and restore
		     * the current document.  - FM
		     */
		    HTAlert(line_buffer);
		    HTTP_NETCLOSE(s, handle);
		    status = HT_NO_DATA;
		    goto clean_up;

		default:
		    /*
		     * 400 Bad Request.
		     * 402 Payment Required.
		     * 403 Forbidden.
		     * 404 Not Found.
		     * 405 Method Not Allowed.
		     * 406 Not Acceptable.
		     * 409 Conflict.
		     * 410 Gone.
		     * 411 Length Required.
		     * 412 Precondition Failed.
		     * 413 Request Entity Too Large.
		     * 414 Request-URI Too Long.
		     * 415 Unsupported Media Type.
		     * 416 List Response (for content negotiation).
		     * > 416 is unknown.
		     * Show the status message, and display the returned text
		     * if we are not doing a traversal.  - FM
		     */
		    HTAlert(line_buffer);
		    if (traversal) {
			HTTP_NETCLOSE(s, handle);
			status = -1;
			goto clean_up;
		    }
		    if (!dump_output_immediately &&
			format_out == HTAtom_for("www/download")) {
			/*
			 * Convert a download request to a presentation request
			 * for interactive users.  - FM
			 */
			format_out = WWW_PRESENT;
		    }
		    break;
		}		/* case 4 switch */
		break;

	    case 5:
		/*
		 * "I think YOU goofed!" (server error)
		 * 500 Internal Server Error
		 * 501 Not Implemented
		 * 502 Bad Gateway
		 * 503 Service Unavailable
		 * 504 Gateway Timeout
		 * 505 HTTP Version Not Supported
		 * > 505 is unknown.
		 * Should always include a message, which we always should
		 * display.  - FM
		 */
		HTAlert(line_buffer);
		if (traversal) {
		    HTTP_NETCLOSE(s, handle);
		    status = -1;
		    goto clean_up;
		}
		if (!dump_output_immediately &&
		    format_out == HTAtom_for("www/download")) {
		    /*
		     * Convert a download request to a presentation request for
		     * interactive users.  - FM
		     */
		    format_out = WWW_PRESENT;
		}
		break;

	    default:
		/*
		 * Bad or unknown server_status number.  Take a chance and hope
		 * there is something to display.  - FM
		 */
		HTAlert(gettext("Unknown status reply from server!"));
		HTAlert(line_buffer);
		if (traversal) {
		    HTTP_NETCLOSE(s, handle);
		    status = -1;
		    goto clean_up;
		}
		if (!dump_output_immediately &&
		    format_out == HTAtom_for("www/download")) {
		    /*
		     * Convert a download request to a presentation request for
		     * interactive users.  - FM
		     */
		    format_out = WWW_PRESENT;
		}
		break;
	    }			/* Switch on server_status/100 */

	}			/* Full HTTP reply */
    }				/* scope of fields */

    /*
     * The user may have pressed the 'z'ap key during the pause caused by one
     * of the HTAlerts above if the server reported an error, to skip loading
     * of the error response page.  Checking here before setting up the stream
     * stack and feeding it data avoids doing unnecessary work, it also can
     * avoid unnecessarily pushing a loaded document out of the cache to make
     * room for the unwanted error page.  - kw
     */
    if (HTCheckForInterrupt()) {
	HTTP_NETCLOSE(s, handle);
	if (doing_redirect) {
	    /*
	     * Impatient user.  - FM
	     */
	    CTRACE((tfp, "HTTP: Interrupted followup read.\n"));
	    _HTProgress(CONNECTION_INTERRUPTED);
	}
	status = HT_INTERRUPTED;
	goto clean_up;
    }
    /*
     * Set up the stream stack to handle the body of the message.
     */
    if (do_head || keep_mime_headers) {
	/*
	 * It was a HEAD request, or we want the headers and source.
	 */
	start_of_data = line_kept_clean;
#ifdef SH_EX			/* FIX BUG by kaz@@maczuka.hitachi.ibaraki.jp */
/* GIF file contains \0, so strlen does not return the data length */
	length = real_length_of_line;
#else
	length = rawlength;
#endif
	format_in = HTAtom_for("text/plain");

    } else if (doing_redirect) {

	format_in = HTAtom_for("message/x-http-redirection");
	StrAllocCopy(anAnchor->content_type, HTAtom_name(format_in));
	if (traversal) {
	    format_out = WWW_DEBUG;
	    if (!sink)
		sink = HTErrorStream();
	} else if (!dump_output_immediately &&
		   format_out == HTAtom_for("www/download")) {
	    /*
	     * Convert a download request to a presentation request for
	     * interactive users.  - FM
	     */
	    format_out = WWW_PRESENT;
	}
    }

    target = HTStreamStack(format_in,
			   format_out,
			   sink, anAnchor);

    if (target == NULL) {
	char *buffer = NULL;

	HTTP_NETCLOSE(s, handle);
	HTSprintf0(&buffer, CANNOT_CONVERT_I_TO_O,
		   HTAtom_name(format_in), HTAtom_name(format_out));
	_HTProgress(buffer);
	FREE(buffer);
	status = -1;
	goto clean_up;
    }

    /*
     * Recycle the first chunk of data, in all cases.
     */
    (*target->isa->put_block) (target, start_of_data, length);

    /*
     * Go pull the bulk of the data down.
     */
    rv = HTCopy(anAnchor, s, (void *) handle, target);

    /*
     * If we get here with doing_redirect set, it means that we were looking
     * for a Location header.  We either have got it now in redirecting_url -
     * in that case the stream should not have loaded any data.  Or we didn't
     * get it, in that case the stream may have presented the message body
     * normally.  - kw
     */

    if (rv == -1) {
	/*
	 * Intentional interrupt before data were received, not an error
	 */
	if (doing_redirect && traversal)
	    status = -1;
	else
	    status = HT_INTERRUPTED;
	HTTP_NETCLOSE(s, handle);
	goto clean_up;
    }

    if (rv == -2) {
	/*
	 * Aw hell, a REAL error, maybe cuz it's a dumb HTTP0 server
	 */
	(*target->isa->_abort) (target, NULL);
	if (doing_redirect && redirecting_url) {
	    /*
	     * Got a location before the error occurred?  Then consider it an
	     * interrupt but proceed below as normal.  - kw
	     */
	    /* do nothing here */
	} else {
	    HTTP_NETCLOSE(s, handle);
	    if (!doing_redirect && !already_retrying && !do_post) {
		CTRACE((tfp, "HTTP: Trying again with HTTP0 request.\n"));
		/*
		 * May as well consider it an interrupt -- right?
		 */
		FREE(line_buffer);
		FREE(line_kept_clean);
		extensions = NO;
		already_retrying = TRUE;
		_HTProgress(RETRYING_AS_HTTP0);
		goto try_again;
	    } else {
		status = HT_NOT_LOADED;
		goto clean_up;
	    }
	}
    }

    /*
     * Free if complete transmission (socket was closed before return).  Close
     * socket if partial transmission (was freed on abort).
     */
    if (rv != HT_INTERRUPTED && rv != -2) {
	(*target->isa->_free) (target);
    } else {
	HTTP_NETCLOSE(s, handle);
    }

    if (doing_redirect) {
	if (redirecting_url) {
	    /*
	     * Set up for checking redirecting_url in LYGetFile.c for
	     * restrictions before we seek the document at that Location.  - FM
	     */
	    CTRACE((tfp, "HTTP: Picked up location '%s'\n",
		    redirecting_url));
	    if (rv == HT_INTERRUPTED) {
		/*
		 * Intentional interrupt after data were received, not an error
		 * (probably).  We take it as a user request to abandon the
		 * redirection chain.
		 *
		 * This could reasonably be changed (by just removing this
		 * block), it would make sense if there are redirecting
		 * resources that "hang" after sending the headers.  - kw
		 */
		FREE(redirecting_url);
		CTRACE((tfp, "HTTP: Interrupted followup read.\n"));
		status = HT_INTERRUPTED;
		goto clean_up;
	    }
	    HTProgress(line_buffer);
	    if (server_status == 305) {		/* Use Proxy */
		/*
		 * Make sure the proxy field ends with a slash.  - FM
		 */
		if (redirecting_url[strlen(redirecting_url) - 1]
		    != '/')
		    StrAllocCat(redirecting_url, "/");
		/*
		 * Append our URL.  - FM
		 */
		StrAllocCat(redirecting_url, anAnchor->address);
		CTRACE((tfp, "HTTP: Proxy URL is '%s'\n",
			redirecting_url));
	    }
	    if (!do_post ||
		server_status == 303 ||
		server_status == 302) {
		/*
		 * We don't have POST content (nor support PUT or DELETE), or
		 * the status is "See Other" or "General Redirection" and we
		 * can convert to GET, so go back and check out the new URL.  -
		 * FM
		 */
		status = HT_REDIRECTING;
		goto clean_up;
	    }
	    /*
	     * Make sure the user wants to redirect the POST content, or treat
	     * as GET - FM & DK
	     */
	    switch (HTConfirmPostRedirect(redirecting_url,
					  server_status)) {
		/*
		 * User failed to confirm.  Abort the fetch.
		 */
	    case 0:
		FREE(redirecting_url);
		status = HT_NO_DATA;
		goto clean_up;

		/*
		 * User wants to treat as GET with no content.  Go back to
		 * check out the URL.
		 */
	    case 303:
		break;

		/*
		 * Set the flag to retain the POST content and go back to check
		 * out the URL.  - FM
		 */
	    default:
		redirect_post_content = TRUE;
	    }

	    /* Lou's old comment:  - FM */
	    /* OK, now we've got the redirection URL temporarily stored
	       in external variable redirecting_url, exported from HTMIME.c,
	       since there's no straightforward way to do this in the library
	       currently.  Do the right thing. */

	    status = HT_REDIRECTING;

	} else {
	    status = traversal ? -1 : HT_LOADED;
	}

    } else {
	/*
	 * If any data were received, treat as a complete transmission
	 */
	status = HT_LOADED;
    }

    /*
     * Clean up
     */
  clean_up:
    FREE(line_buffer);
    FREE(line_kept_clean);

  done:
    /*
     * Clear out on exit, just in case.
     */
    reloading = FALSE;
#ifdef USE_SSL
    FREE(connect_host);
    if (handle) {
	SSL_free(handle);
	SSL_handle = handle = NULL;
    }
#endif /* USE_SSL */
    dump_server_status = server_status;
    return status;
}

/*	Protocol descriptor
*/
#ifdef GLOBALDEF_IS_MACRO
#define _HTTP_C_GLOBALDEF_1_INIT { "http", HTLoadHTTP, 0}
GLOBALDEF(HTProtocol, HTTP, _HTTP_C_GLOBALDEF_1_INIT);
#define _HTTP_C_GLOBALDEF_2_INIT { "https", HTLoadHTTP, 0}
GLOBALDEF(HTProtocol, HTTPS, _HTTP_C_GLOBALDEF_2_INIT);
#else
GLOBALDEF HTProtocol HTTP =
{"http", HTLoadHTTP, 0};
GLOBALDEF HTProtocol HTTPS =
{"https", HTLoadHTTP, 0};
#endif /* GLOBALDEF_IS_MACRO */
@


1.29
log
@merge bugfix from sendmail (and add warnings to documentation):
        Properly initialize all OpenSSL algorithms for versions before
                OpenSSL 0.9.8o. Without this SHA2 algorithms may not
                work properly, causing for example failures for certs
                that use sha256WithRSAEncryption as signature algorithm.
additionally, remove redundant call (its an alias) from ftp(1)
@
text
@d58 1
a58 1
__RCSID("$MirOS$");
a128 1
	OpenSSL_add_all_algorithms();
@


1.28
log
@revert commitid 10054A9BD974311EA62, as upstream correctly pointed out
SSLv32_{client,server}_method() are correct to use and I re-added them
in commitid 10054C52A9E42384AA8 anyway (the new names TLS_method() and
TLS_{client,server}_method() still to be done) so this was stupid
@
text
@d58 2
d129 1
@


1.27
log
@fix build against an OpenSSL built w/o SSLv2 and SSLv3 support
(with SSLv3 but without SSLv2 is still broken, but we dont use that)
@
text
@a126 3
#if defined(OPENSSL_NO_SSL2) && defined(OPENSSL_NO_SSL3)
	ssl_ctx = SSL_CTX_new(TLSv1_client_method());
#else
a127 1
#endif
@


1.26
log
@mop up after openssl rng changes
@
text
@d127 3
d131 1
@


1.25
log
@fastmerge
@
text
@d180 1
d224 1
@


1.24
log
@fastmerge
@
text
@d2 1
a2 1
 * $LynxId: HTTP.c,v 1.126 2012/11/13 22:49:46 tom Exp $
d203 2
a204 4
	if (rand_file != NULL) {
	    /* Seed as much as 1024 bytes from RAND_file_name */
	    RAND_load_file(rand_file, 1024L);
	}
d219 2
a220 4
	if (rand_file != NULL) {
	    /* Write a rand_file */
	    RAND_write_file(rand_file);
	}
d557 2
a558 2
    char *line_buffer;
    char *line_kept_clean;
d2164 1
a2164 1
		    goto done;
@


1.23
log
@fastmerge
@
text
@d2 1
a2 1
 * $LynxId: HTTP.c,v 1.124 2012/08/01 11:00:26 tom Exp $
d719 6
a724 1
#if SSLEAY_VERSION_NUMBER >= 0x0900
d782 2
a783 1
	if (ret < 0) {
d787 3
a789 1
	    if (tls_status & GNUTLS_CERT_SIGNER_NOT_FOUND) {
a792 2
	    } else if (tls_status & GNUTLS_CERT_SIGNER_NOT_FOUND) {
		msg2 = gettext("the certificate has no known issuer");
@


1.22
log
@merge lynx2.8.8dev.10a and fix some spelling
@
text
@d2 1
a2 1
 * $LynxId: HTTP.c,v 1.123 2011/06/11 12:09:21 tom Exp $
d773 3
@


1.21
log
@fix http://curl.haxx.se/docs/adv_20120124B.html for lynx and sendmail

(both server and client modes in sendmail; the only SSL implementation
noted to choke on this is MSIE, which doesnt do SMTP STARTTLS luckily
but if there are others, probably should disable this for mailservers)

in sendmail, _FFR_TLS_1 would be the more effective way to do this but
we dont import from __future__ here

CVE-2011-3389
@
text
@d2 1
a2 1
 * $LynxId: HTTP.c,v 1.121 2010/11/07 21:20:58 tom Exp $
a57 4
struct _HTStream {
    HTStreamClass *isa;
};

d132 15
d159 7
a183 1
	int pid;
d186 7
d194 2
d197 4
d2000 1
a2000 1
		 * If we don't find the Location header or it's value is
@


1.20
log
@fastmerge; break since I cant get autoconf-2.13 to work and its late
@
text
@d124 6
d132 1
a132 1
	SSL_CTX_set_options(ssl_ctx, SSL_OP_ALL);
@


1.19
log
@automerge
@
text
@d2 1
a2 1
 * $LynxId: HTTP.c,v 1.108 2009/05/22 00:47:41 tom Exp $
d86 1
a86 1
	       X509_verify_cert_error_string(X509_STORE_CTX_get_error(x509_ctx)),
d96 2
a97 1
		   X509_verify_cert_error_string(X509_STORE_CTX_get_error(x509_ctx)));
d165 1
a165 1
	RAND_file_name(rand_file, 256);
d169 1
a169 1
	    RAND_load_file(rand_file, 1024);
d172 2
a173 1
	RAND_seed((unsigned char *) &t, sizeof(time_t));
d175 1
a175 1
	RAND_seed((unsigned char *) &pid, sizeof(pid));
d177 1
a177 1
	RAND_bytes((unsigned char *) &seed, sizeof(long));
d183 1
a183 1
	    RAND_seed((unsigned char *) &l, sizeof(long));
d195 4
a198 1
	(handle ? SSL_read(handle, buff, size) : NETREAD(sock, buff, size))
d200 4
a203 1
	(handle ? SSL_write(handle, buff, size) : NETWRITE(sock, buff, size))
d205 5
a209 1
	{ (void)NETCLOSE(sock); if (handle) SSL_free(handle); SSL_handle = handle = NULL; }
d455 1
a455 1
    X509_NAME_oneline(X509_get_issuer_name(peer_cert), ssl_dn, sizeof(ssl_dn));
d510 1
a510 1
    static char *empty = "";
d517 1
a517 1
    int bytes_already_read;
d527 2
d530 1
d540 1
a540 1
    int server_status;
d545 1
d590 1
a590 1
    if (using_proxy && !strncmp(url, "http://", 7)) {
d637 1
a637 1
    if (!strncmp(url, "https", 5))
d642 1
a642 1
    if (!strncmp(url, "https", 5)) {
d677 1
a677 1
    if (did_connect || !strncmp(url, "https", 5)) {
a705 2
		unsigned long SSLerror;

d738 1
a738 1
	if ((ret < 0) || tls_status) {
d772 4
d777 1
a777 4
#ifndef USE_GNUTLS_INCL
			  ssl_dn, sizeof(ssl_dn));
#else
			  ssl_dn + 1, sizeof(ssl_dn) - 1);
d904 1
a904 1
			memcpy(cert_host, ASN1_STRING_data(gn->d.ia5), j);
d1052 1
a1052 1
				pres->quality, CAST_off_t(pres->maxbytes));
d1057 1
a1057 1
		    sprintf(temp, ";mxb=%" PRI_off_t "", CAST_off_t(pres->maxbytes));
a1080 2
	first_Accept = FALSE;
	len = 0;
d1175 1
a1175 1
	    if (!isEmpty(LYUserAgent)) {
d1218 3
a1220 2
	    BOOL secure = (BOOL) (strncmp(anAnchor->address, "https", 5) ?
				  FALSE : TRUE);
d1228 1
a1228 1
	    } else if (!strncmp(arg, "https", 5)) {
d1245 1
a1245 1
		int port2 = (strncmp(docname, "https", 5) ?
d1302 1
a1302 1
		if (!strncmp(docname, "http", 4)) {
a1394 1
	auth_proxy = NO;
d1449 4
a1452 1
    status = HTTP_NETWRITE(s, BStrData(command), BStrLen(command), handle);
d1495 1
a1495 1
	line_buffer = typecallocn(char, (unsigned) buffer_length);
d1500 1
a1500 1
	HTReadProgress(bytes_already_read = 0, 0);
d1552 13
a1564 1
		} else {
d1586 1
a1586 1
	    HTReadProgress(bytes_already_read, 0);
a1593 1
		end_of_file = YES;
d1605 2
a1606 1
		memcpy(line_kept_clean, line_buffer, (unsigned) buffer_length);
d1608 1
d1645 3
a1647 3
	(0 == strncmp(line_buffer, "<TITLE>Bad File Request</TITLE>", 31) ||
	 0 == strncmp(line_buffer, "Address should begin with", 25) ||
	 0 == strncmp(line_buffer, "<TITLE>Help ", 12) ||
d1709 1
a1709 1
	    if (!strncmp(HTAtom_name(format_in), "text/plain", 10)) {
d1740 8
a1747 2
	    start_of_data = eol ? eol + 1 : empty;
	    length = eol ? length - (start_of_data - line_buffer) : 0;
d1838 1
a1838 1
			if (!strncmp(connect_url, "snews", 5)) {
a1847 1
			bytes_already_read = 0;
d2014 7
a2020 6
		     * Authorization for orgin server required.  If show_401 is
		     * set, proceed to showing the 401 body.  Otherwise, if we
		     * can set up authorization based on the WWW-Authenticate
		     * header, and the user provides a username and password,
		     * try again.  Otherwise, check whether to show the 401
		     * body or restore the current document.  - FM
d2024 2
a2025 1
		    if (HTAA_shouldRetryWithAuth(start_of_data, length, s, NO)) {
d2045 1
a2045 1
			if (using_proxy && !strncmp(url, "https://", 8)) {
d2075 2
a2076 1
		    if (HTAA_shouldRetryWithAuth(start_of_data, length, s, YES)) {
a2418 1
		doing_redirect = FALSE;
a2467 2
    do_head = FALSE;
    do_post = FALSE;
a2469 2
    do_connect = FALSE;
    did_connect = FALSE;
@


1.18
log
@fastmerge
@
text
@d2 1
a2 1
 * $LynxId: HTTP.c,v 1.101 2008/12/31 02:03:20 tom Exp $
d45 1
d62 1
a62 1
BOOL reloading = FALSE;		/* Reloading => send no-cache pragma to proxy */
d177 1
a177 1
	lynx_srand(seed);
a221 13
char *str_speed(void)
{
    static char buff[32];

    if (ws_read_per_sec > 1000)
	sprintf(buff, "%d.%03dkB", ws_read_per_sec / 1000,
		(ws_read_per_sec % 1000));
    else
	sprintf(buff, "%3d", ws_read_per_sec);

    return buff;
}

a287 4
    extern int win32_check_interrupt(void);	/* LYUtil.c */
    extern int lynx_timeout;	/* LYMain.c */
    extern CRITICAL_SECTION critSec_READ;	/* LYMain.c */

d431 1
a431 1
	result = (program != 0);
d456 1
d474 1
a512 1
    BOOL had_header;		/* Have we had at least one header? */
a611 1
    had_header = NO;
d664 3
d669 1
a669 1
	if (!try_tls)
d671 5
a787 3
	/* get host we're connecting to */
	ssl_host = HTParse(url, "", PARSE_HOST);
	ssl_host = StripIpv6Brackets(ssl_host);
d886 1
a886 1
			size_t j = ASN1_STRING_length(gn->d.ia5);
d1037 1
a1037 1
				pres->quality, pres->maxbytes);
d1042 1
a1042 1
		    sprintf(temp, ";mxb=%" PRI_off_t "", pres->maxbytes);
d1051 1
a1051 1
		len += strlen(linebuf);
d1057 1
a1057 1
		    len = strlen(linebuf);
d1161 14
a1174 12
	if (LYUserAgent && *LYUserAgent) {
	    char *cp = LYSkipBlanks(LYUserAgent);

	    /* Won't send it at all if all blank - kw */
	    if (*cp != '\0')
		HTBprintf(&command, "User-Agent: %.*s%c%c",
			  INIT_LINE_SIZE - 15, LYUserAgent, CR, LF);
	} else {
	    HTBprintf(&command, "User-Agent: %s/%s  libwww-FM/%s%c%c",
		      HTAppName ? HTAppName : "unknown",
		      HTAppVersion ? HTAppVersion : "0.0",
		      HTLibraryVersion, CR, LF);
d1479 1
a1479 1
	line_buffer = typecallocn(char, buffer_length);
d1492 2
a1493 1
		    (char *) realloc(line_buffer, (buffer_length * sizeof(char)));
d1499 4
a1502 2
	    status = HTTP_NETREAD(s, line_buffer + length,
				  buffer_length - length - 1, handle);
d1573 2
a1574 1
		line_kept_clean = (char *) malloc(buffer_length * sizeof(char));
d1578 1
a1578 1
		memcpy(line_kept_clean, line_buffer, buffer_length);
a1813 1
			had_header = NO;
@


1.17
log
@re-apply original logic from myself stripping off the IPv6 brackets
from sslhost and certhost, which got lost in the HTParsePort transition
@
text
@d2 1
a2 1
 * $LynxId: HTTP.c,v 1.99 2008/12/14 18:05:36 tom Exp $
d469 21
a553 1
    int port_number;
d798 1
a798 10
	/* strip port number or extract hostname component */
	if ((p = HTParsePort(ssl_host, &port_number)) != 0)
	    *p = '\0';
	else
	    p = ssl_host + strlen(ssl_host);
	/* strip IPv6 brackets */
	if (*ssl_host == '[' && *--p == ']') {
		++ssl_host;
		*p = '\0';
	}
d812 1
a812 10
	    /* strip port number */
	    if ((p = HTParsePort(cert_host, &port_number)) != 0)
		*p = '\0';
	    else
		p = cert_host + strlen(cert_host);
	    /* strip IPv6 brackets */
	    if (*cert_host == '[' && *--p == ']') {
		++cert_host;
		*p = '\0';
	    }
d906 1
a906 8
		    if ((p = HTParsePort(cert_host, &port_number)) != 0)
			*p = '\0';
		    else
			p = cert_host + strlen(cert_host);
		    if (*cert_host == '[' && *--p == ']') {
			++cert_host;
			*p = '\0';
		    }
a2278 1
/* (*target->isa->_abort)(target, NULL); *//* already done in HTCopy */
@


1.16
log
@fastmerge
@
text
@d781 7
d801 1
a801 1
	    /* strip port number (XXX [ip]:port encap here too? -TG) */
d804 7
d906 6
@


1.15
log
@upgrade lynx to 2.8.7dev.8  much better multibyte editing support
@
text
@d2 1
a2 1
 * $LynxId: HTTP.c,v 1.91 2008/02/17 19:36:08 Zdenek.Prikryl Exp $
d455 1
a455 1
#if defined(USE_OPENSSL_INCL)
d464 1
a464 1
    /* the OpenSSL code compiles but dumps core with GNU TLS */
d533 1
d570 2
d575 1
a575 1
	    if (!strchr(connect_host, ':')) {
d584 1
a584 1
	    if (!strchr(connect_host, ':')) {
d779 1
a779 1
	if ((p = strchr(ssl_host, (ssl_host[0] == '[') ? ']' : ':')) != NULL)
a780 2
	if (ssl_host[0] == '[')
	    ssl_host++;
d795 1
a795 2
	    if ((p = strchr(cert_host,
			    (cert_host[0] == '[') ? ']' : ':')) != NULL)
a796 2
	    if (cert_host[0] == '[')
		cert_host++;
d890 1
a890 2
		    if ((p = strchr(cert_host,
				    (cert_host[0] == '[') ? ']' : ':')) != NULL)
a891 2
		    if (cert_host[0] == '[')
			cert_host++;
d1032 1
a1032 1
			sprintf(temp, ";q=%4.3f;mxb=%ld",
d1038 1
a1038 1
		    sprintf(temp, ";mxb=%ld", pres->maxbytes);
d1206 2
a1207 3
		NULL != (colon = strchr(hostname, ':'))) {
		*(colon++) = '\0';	/* Chop off port number */
		portnumber = atoi(colon);
d1231 1
a1231 1
		    if ((colon = strchr(host2, ':')) != NULL) {
a1233 2
			colon++;
			port2 = atoi(colon);
d2436 1
@


1.14
log
@log ssl callback messages too
@
text
@d2 1
a2 1
 * $LynxId: HTTP.c,v 1.87 2007/07/03 00:20:33 tom Exp $
d82 1
d89 1
d91 1
d104 1
d133 7
d453 1
a453 1
static void show_cert_issuer(X509 * peer_cert)
d658 1
d661 1
d830 36
@


1.13
log
@fastmerge
@
text
@d82 7
@


1.12
log
@ merge (except configure)
 reduce diff against upstream

untested
@
text
@d2 1
a2 1
 * $LynxId: HTTP.c,v 1.85 2007/05/13 21:08:19 tom Exp $
d816 4
a819 2
	    if ((gens = X509_get_ext_d2i(peer_cert, NID_subject_alt_name,
					 NULL, NULL)) != NULL) {
d829 1
a829 1
			cert_host = malloc(j + 1);
@


1.11
log
@fix a possible use of uninitialised
@
text
@d1 5
a5 2
/*	HyperText Tranfer Protocol	- Client implementation		HTTP.c
 *	==========================
d49 1
d52 4
d434 17
d722 2
a723 2
	X509_NAME_oneline(X509_get_subject_name(peer_cert =
						SSL_get_peer_certificate(handle)),
d760 1
d762 1
d779 1
d781 2
d794 1
d810 1
d812 23
a834 22
		STACK_OF(GENERAL_NAME) *gens;
		int i, numalts;
		const GENERAL_NAME *gn;

		if ((gens = X509_get_ext_d2i(peer_cert, NID_subject_alt_name,
		    NULL, NULL)) != NULL) {
			numalts = sk_GENERAL_NAME_num(gens);
			for (i = 0; i < numalts; ++i) {
				gn = sk_GENERAL_NAME_value(gens, i);
				if (gn->type == GEN_DNS)
					cert_host = ASN1_STRING_data(gn->d.ia5);
				else if (gn->type == GEN_IPADD) {
					/* XXX untested -TG */
					size_t j = ASN1_STRING_length(gn->d.ia5);
					cert_host = malloc(j + 1);
					memcpy(cert_host, ASN1_STRING_data(gn->d.ia5), j);
					cert_host[j] = '\0';
				} else
					continue;
				status_sslcertcheck = 1;	/* got at least one */
				/* verify this SubjectAltName (see above) */
				if ((p = strchr(cert_host,
d836 28
a863 30
					*p = '\0';
				if (cert_host[0] == '[')
					cert_host++;
				if (!(gn->type == GEN_IPADD ? strcasecomp :
				    strcasecomp_asterisk)(ssl_host, cert_host)) {
					status_sslcertcheck = 2;
					HTSprintf0(&msg,
						   gettext("Verified connection to %s (subj=%s)"),
						   ssl_host, cert_host);
					_HTProgress(msg);
					FREE(msg);
					if (gn->type == GEN_IPADD)
						free(cert_host);
					break;
				}
				/* add to list of failed CNs */
				if (ssl_all_cns == NULL)
					StrAllocCopy(ssl_all_cns, "SAN<");
				else
					StrAllocCat(ssl_all_cns, ":SAN<");
				if (gn->type == GEN_DNS)
					StrAllocCat(ssl_all_cns, "DNS=");
				else if (gn->type == GEN_IPADD)
					StrAllocCat(ssl_all_cns, "IP=");
				StrAllocCat(ssl_all_cns, cert_host);
				StrAllocCat(ssl_all_cns, ">");
				if (gn->type == GEN_IPADD)
					free(cert_host);
			}
			sk_GENERAL_NAME_free(gens);
d865 2
d868 1
d895 2
a896 4
	X509_NAME_oneline(X509_get_issuer_name(peer_cert), ssl_dn, sizeof (ssl_dn));
	HTSprintf0(&msg, gettext("Certificate issued by: %s"), ssl_dn);
	_HTProgress(msg);
	FREE(msg);
@


1.10
log
@scan X.509v3 SubjectAltName for DNS: and IP: values and verify them, quite
the same as with X.509 commonName attributes, but after them (despite being
recommended to check them first, because it's easier this way), except IPs
aren't asterisk-compared.

makes https://www.cacert.org/ work.

) untested
) I could, in theory, merge the check code or even make a common function,
   but I wanted this to work NOW.
) Subject: C=Au, ST=NSW, L=Sydney, O=CAcert Inc., CN=cacert.org/emailAddress=support@@cacert.org
   X509v3 Subject Alternative Name: DNS:cacert.org, DNS:*.cacert.org, DNS:cacert.net, DNS:*.cacert.net, DNS:cacert.com, DNS:*.cacert.com
) I don't understand why they, HTTP-redirecting to www.cacert.org, don't
   make that one the primary CN
@
text
@d494 1
a494 1
    char *ssl_all_cns;
a727 1
	ssl_all_cns = NULL;
d799 1
d856 1
a856 1
		       ssl_host, ssl_all_cns);
@


1.9
log
@* log whether the connection peer (server) was verified
  against its certificate CNs or not, and, always, what
  the issuer was
* implement correct verification for https://[ip]:port/

TODO: handle certificates with X.509 Subject Alternati-
      ve Names (CAcert switched *sigh*)
@
text
@d45 4
d486 1
d697 2
a698 1
	X509_NAME_oneline(X509_get_subject_name(SSL_get_peer_certificate(handle)),
d766 6
a771 6
	    if (ssl_all_cns == NULL) {
		StrAllocCopy(ssl_all_cns, cert_host);
	    } else {
		StrAllocCat(ssl_all_cns, ":");
		StrAllocCat(ssl_all_cns, cert_host);
	    }
d779 57
d861 1
a861 2
	X509_NAME_oneline(X509_get_issuer_name(SSL_get_peer_certificate(handle)),
			  ssl_dn, sizeof (ssl_dn));
@


1.8
log
@display X.509 cert issur
@
text
@d725 2
a726 2
	/* strip port number */
	if ((p = strchr(ssl_host, ':')) != NULL)
d728 2
d741 3
a743 2
	    /* strip port number */
	    if ((p = strchr(cert_host, ':')) != NULL)
d745 2
a755 5
		X509_NAME_oneline(X509_get_issuer_name(SSL_get_peer_certificate(handle)),
				  ssl_dn, sizeof (ssl_dn));
		HTSprintf0(&msg, gettext("Certificate issued by: %s"), ssl_dn);
		_HTProgress(msg);
		FREE(msg);
d791 5
d798 5
@


1.7
log
@fastmerge
@
text
@d745 1
a745 1
		/* I think this is cool to have in the logs --mirabilos */
d751 5
@


1.6
log
@merge (yay, exactly my SSL verification code is in)
@
text
@d65 1
a65 1
static int HTSSLCallback(int preverify_ok, X509_STORE_CTX * x509_ctx)
d72 1
a72 1
	HTSprintf0(&msg, "SSL error:%s-Continue?",
d87 4
d105 7
d114 4
d224 2
d228 2
a229 1
    int i, val, ret;
d245 1
a245 1
	ret = -1;
d247 1
a247 1
	ret = val;
d250 1
a250 1
    return ((DWORD) ret);
d265 2
a266 1
    DWORD ret_val = -1, val, process_time, now_TickCount, save_TickCount;
d301 1
a301 1
	    ret_val = -1;
d320 1
a320 1
		exitcode = -1;
a333 1
	    g_total_bytes += exitcode;
d335 10
a344 2
	    if (g_total_bytes > 2000000) {
		ws_read_per_sec = g_total_bytes / (g_total_times / 1000);
d346 2
a347 1
		ws_read_per_sec = g_total_bytes * 1000 / g_total_times;
d349 1
d491 5
d657 34
d693 1
d695 18
d770 2
a771 2
	    HTSprintf0(&msg,
		       gettext("SSL error:Can't find common name in certificate-Continue?"));
@


1.5
log
@implement correct and full DN validation
scanning for multiple CNs (as seen on https://www.cacert.org/)
@
text
@a0 2
/* $MirOS: src/gnu/usr.bin/lynx/WWW/Library/Implementation/HTTP.c,v 1.4 2006/02/21 03:00:19 tg Exp $ */

d627 1
a627 42
#if 0
/* XXX fix for multiple /CN= in this */
HTSprintf0(&msg, "SSL DN is '%s'", ssl_dn);
/* SSL DN is '/CN=cacert.org/CN=*.cacert.org' (y) */
HTForcedPrompt(ssl_noprompt, msg, YES);
FREE(msg);
#endif
#if 0
	if ((cert_host = strstr(ssl_dn, "/CN=")) == NULL) {
	    HTSprintf0(&msg,
		       gettext("SSL error:Can't find common name in certificate-Continue?"));
	    if (!HTForcedPrompt(ssl_noprompt, msg, YES)) {
		status = HT_NOT_LOADED;
		FREE(msg);
		goto done;
	    }
	} else {
	    cert_host += 4;
	    if ((p = strchr(cert_host, '/')) != NULL)
		*p = '\0';
	    if ((p = strchr(cert_host, ':')) != NULL)
		*p = '\0';
	    ssl_host = HTParse(url, "", PARSE_HOST);
	    if ((p = strchr(ssl_host, ':')) != NULL)
		*p = '\0';
	    p = NULL;
	    StrAllocCopy(p, "www.");
	    StrAllocCat(p, cert_host);
	    if (strcasecomp_asterisk(ssl_host, cert_host)
	     && strcasecomp_asterisk(ssl_host, p)) {
		HTSprintf0(&msg,
			   gettext("SSL error:host(%s)!=cert(%s)-Continue?"),
			   ssl_host,
			   cert_host);
		if (!HTForcedPrompt(ssl_noprompt, msg, YES)) {
		    status = HT_NOT_LOADED;
		    FREE(msg);
		    goto done;
		}
	    }
	}
#else
d634 1
a634 1
	status_sslcertcheck = 0;		/* 0 = no CN found in DN */
a641 4
#if 0 /* debug */
HTSprintf0(&msg, "SSL init host(%s) dn(%s)", ssl_host, ssl_dn_start);
HTForcedPrompt(ssl_noprompt, msg, YES);FREE(msg);
#endif
d644 1
a644 1
	    status_sslcertcheck = 1;		/* 1 = could not verify CN */
a655 8
#if 0 /* debug */
StrAllocCopy(p,cert_host);
if (ssl_dn_start) *ssl_dn_start = '/';
HTSprintf0(&msg, "SSL check host(%s) next(%s)", p/*cert_host*/, ssl_dn_start ? ssl_dn_start : "<NULL>");
FREE(p);
if (ssl_dn_start) *ssl_dn_start = '\0';
HTForcedPrompt(ssl_noprompt, msg, YES);FREE(msg);
#endif
a662 3
#if 0 /* debug */
		HTForcedPrompt(ssl_noprompt, msg, YES);
#else
a663 1
#endif
d681 3
a683 2
	/* if an error occured, format the appropriate message */
	if (status_sslcertcheck == 0)
d686 1
a686 1
	else if (status_sslcertcheck == 1)
d689 5
a693 3
			       ssl_host, ssl_all_cns);
	/* if an error occured, let the user decide how much he trusts */
	if (status_sslcertcheck < 2)
d700 1
a700 1
#endif
d885 1
a885 1
	 * is semantically equivalent and some servers may ignore "Negotiate: 
d1008 1
a1008 1
		     * cancelled or goofed at the username and password prompt. 
d1675 1
a1675 1
		 * don't allow permanent redirection if we keep POST content. 
@


1.4
log
@work around CAcert.org certificate DN problem
XXX fix really later (multiple CN in DN)
@
text
@d1 1
a1 1
/* $MirOS: src/gnu/usr.bin/lynx/WWW/Library/Implementation/HTTP.c,v 1.3 2005/10/21 21:42:34 tg Exp $ */
d456 1
a456 1
    char ssl_dn[256];
d461 3
d632 1
d634 1
d636 1
d670 87
@


1.3
log
@merge
@
text
@d1 1
a1 1
/* $MirOS: src/gnu/usr.bin/lynx/WWW/Library/Implementation/HTTP.c,v 1.2 2005/03/27 22:42:33 tg Exp $ */
d626 5
d648 5
a652 1
	    if (strcasecomp_asterisk(ssl_host, cert_host)) {
@


1.2
log
@initial port of MirBSD Lynx
@
text
@d1 1
a1 1
/* $MirOS$ */
d436 1
a436 1
    int real_length_of_line;
@


1.1
log
@Initial revision
@
text
@d1 2
d643 1
a643 1
	    if (strcasecomp(ssl_host, cert_host)) {
@


1.1.109.1
log
@Lynx 2.8.6dev.11h (pre-patch) minus
* lib
* po
* scripts
@
text
@@


1.1.109.2
log
@Import new Lynx snapshot
@
text
@d434 1
a434 1
    int real_length_of_line = 0;
@


1.1.109.3
log
@import Lynx/2.8.6dev.18 (hopefully with our SSL fixes)
@
text
@d454 1
a454 1
    char ssl_dn[1024];
a458 3
    int status_sslcertcheck;
    char *ssl_dn_start;
    char *ssl_all_cns;
d624 1
a624 57

	/*
	 * X.509 DN validation taking ALL CN fields into account
	 * (c) 2006 Thorsten Glaser <tg@@mirbsd.de>
	 */

	/* initialise status information */
	status_sslcertcheck = 0;	/* 0 = no CN found in DN */
	ssl_dn_start = ssl_dn;
	ssl_all_cns = NULL;
	/* get host we're connecting to */
	ssl_host = HTParse(url, "", PARSE_HOST);
	/* strip port number */
	if ((p = strchr(ssl_host, ':')) != NULL)
	    *p = '\0';
	/* validate all CNs found in DN */
	while ((cert_host = strstr(ssl_dn_start, "/CN=")) != NULL) {
	    status_sslcertcheck = 1;	/* 1 = could not verify CN */
	    /* start of CommonName */
	    cert_host += 4;
	    /* find next part of DistinguishedName */
	    if ((p = strchr(cert_host, '/')) != NULL) {
		*p = '\0';
		ssl_dn_start = p;	/* yes this points to the NUL byte */
	    } else
		ssl_dn_start = NULL;
	    /* strip port number */
	    if ((p = strchr(cert_host, ':')) != NULL)
		*p = '\0';
	    /* verify this CN */
	    if (!strcasecomp_asterisk(ssl_host, cert_host)) {
		status_sslcertcheck = 2;	/* 2 = verified peer */
		/* I think this is cool to have in the logs --mirabilos */
		HTSprintf0(&msg,
			   gettext("Verified connection to %s (cert=%s)"),
			   ssl_host, cert_host);
		_HTProgress(msg);
		FREE(msg);
		/* no need to continue the verification loop */
		break;
	    }
	    /* add this CN to list of failed CNs */
	    if (ssl_all_cns == NULL) {
		StrAllocCopy(ssl_all_cns, cert_host);
	    } else {
		StrAllocCat(ssl_all_cns, ":");
		StrAllocCat(ssl_all_cns, cert_host);
	    }
	    /* if we cannot retry, don't try it */
	    if (ssl_dn_start == NULL)
		break;
	    /* now retry next CN found in DN */
	    *ssl_dn_start = '/';	/* formerly NUL byte */
	}

	/* if an error occurred, format the appropriate message */
	if (status_sslcertcheck == 0) {
a626 8
	} else if (status_sslcertcheck == 1) {
	    HTSprintf0(&msg,
		       gettext("SSL error:host(%s)!=cert(%s)-Continue?"),
		       ssl_host, ssl_all_cns);
	}

	/* if an error occurred, let the user decide how much he trusts */
	if (status_sslcertcheck < 2) {
a629 1
		FREE(ssl_all_cns);
d632 20
d837 1
a837 1
	 * is semantically equivalent and some servers may ignore "Negotiate:
d960 1
a960 1
		     * cancelled or goofed at the username and password prompt.
d1627 1
a1627 1
		 * don't allow permanent redirection if we keep POST content.
@


1.1.109.4
log
@Import Lynx 2.8.6pre.3
@
text
@d65 1
a65 1
static int HTSSLCallback(int preverify_ok, X509_STORE_CTX * x509_ctx GCC_UNUSED)
d72 1
a72 1
	HTSprintf0(&msg, SSL_FORCED_PROMPT,
a86 4
#ifdef USE_GNUTLS_INCL
    static char *certfile = NULL;
#endif

a100 7
#ifdef USE_GNUTLS_INCL
	if ((certfile = LYGetEnv("SSL_CERT_FILE")) != NULL) {
	    CTRACE((tfp,
		    "HTGetSSLHandle: certfile is set to %s by SSL_CERT_FILE\n",
		    certfile));
	}
#endif
a102 4
#ifdef USE_GNUTLS_INCL
    ssl_ctx->certfile = certfile;
    ssl_ctx->certfile_type = GNUTLS_X509_FMT_PEM;
#endif
a208 2
#define DWORD_ERR ((DWORD)-1)

d211 1
a211 2
    DWORD result;
    int i, val;
d227 1
a227 1
	result = DWORD_ERR;
d229 1
a229 1
	result = val;
d232 1
a232 1
    return result;
d247 1
a247 2
    DWORD ret_val = DWORD_ERR;
    DWORD val, process_time, now_TickCount, save_TickCount;
d282 1
a282 1
	    ret_val = DWORD_ERR;
d301 1
a301 1
		exitcode = DWORD_ERR;
d315 1
d317 2
a318 10
	    /*
	     * DWORD is unsigned, and could be an error code which is signed.
	     */
	    if ((long) exitcode > 0)
		g_total_bytes += exitcode;

	    ws_read_per_sec = g_total_bytes;
	    if (ws_read_per_sec > 2000000) {
		if (g_total_times > 1000)
		    ws_read_per_sec /= (g_total_times / 1000);
d320 1
a320 2
		ws_read_per_sec *= 1000;
		ws_read_per_sec /= g_total_times;
a321 1

a462 5
#ifdef USE_GNUTLS_INCL
    int ret;
    unsigned tls_status;
#endif

a623 34
#ifdef USE_GNUTLS_INCL
	ret = gnutls_certificate_verify_peers2(handle->gnutls_state, &tls_status);
	if ((ret < 0) || tls_status) {
	    int flag_continue = 1;
	    char *msg2;

	    if (tls_status & GNUTLS_CERT_SIGNER_NOT_FOUND) {
		msg2 = gettext("no issuer was found");
	    } else if (tls_status & GNUTLS_CERT_SIGNER_NOT_CA) {
		msg2 = gettext("issuer is not a CA");
	    } else if (tls_status & GNUTLS_CERT_SIGNER_NOT_FOUND) {
		msg2 = gettext("the certificate has no known issuer");
	    } else if (tls_status & GNUTLS_CERT_REVOKED) {
		msg2 = gettext("the certificate has been revoked");
	    } else {
		msg2 = gettext("the certificate is not trusted");
	    }
	    HTSprintf0(&msg, SSL_FORCED_PROMPT, msg2);
	    CTRACE((tfp, "HTLoadHTTP: %s\n", msg));
	    if (!ssl_noprompt) {
		if (!HTForcedPrompt(ssl_noprompt, msg, YES)) {
		    flag_continue = 0;
		}
	    } else if (ssl_noprompt == FORCE_PROMPT_NO) {
		flag_continue = 0;
	    }
	    FREE(msg);
	    if (flag_continue == 0) {
		status = HT_NOT_LOADED;
		FREE(msg);
		goto done;
	    }
	}
#endif
a625 1
#ifndef USE_GNUTLS_INCL
a626 18
#else
			  ssl_dn + 1, sizeof(ssl_dn) - 1);

	/* Iterate over DN in incompatible GnuTLS format to bring it into OpenSSL format */
	ssl_dn[0] = '/';
	ssl_dn_start = ssl_dn;
	while (*ssl_dn_start) {
	    if ((*ssl_dn_start == ',') && (*(ssl_dn_start + 1) == ' ')) {
		*ssl_dn_start++ = '/';
		if (*(p = ssl_dn_start) != 0) {
		    while ((p[0] = p[1]) != 0)
			++p;
		}
	    } else {
		ssl_dn_start++;
	    }
	}
#endif
d684 2
a685 2
	    HTSprintf0(&msg, SSL_FORCED_PROMPT,
		       gettext("Can't find common name in certificate"));
@


1.1.109.5
log
@Finally, a new Lynx snapshot!
@
text
@d1 2
a2 5
/*
 * $LynxId: HTTP.c,v 1.85 2007/05/13 21:08:19 tom Exp $
 *
 * HyperText Tranfer Protocol	- Client implementation		HTTP.c
 * ==========================
a44 9
#ifdef USE_SSL
#ifdef USE_OPENSSL_INCL
#include <openssl/x509v3.h>
#endif
#ifdef USE_GNUTLS_INCL
#include <gnutls/x509.h>
#endif
#endif

a421 17
#ifdef USE_SSL
static void show_cert_issuer(X509 * peer_cert)
{
#if defined(USE_OPENSSL_INCL)
    char ssl_dn[1024];
    char *msg = NULL;

    X509_NAME_oneline(X509_get_issuer_name(peer_cert), ssl_dn, sizeof(ssl_dn));
    HTSprintf0(&msg, gettext("Certificate issued by: %s"), ssl_dn);
    _HTProgress(msg);
    FREE(msg);
#elif defined(USE_GNUTLS_INCL)
    /* the OpenSSL code compiles but dumps core with GNU TLS */
#endif
}
#endif

a481 1
    X509 *peer_cert;		/* The peer certificate */
d489 1
a489 1
    char *ssl_all_cns = NULL;
d692 1
a692 2
	peer_cert = SSL_get_peer_certificate(handle);
	X509_NAME_oneline(X509_get_subject_name(peer_cert),
d722 1
d725 2
a726 2
	/* strip port number or extract hostname component */
	if ((p = strchr(ssl_host, (ssl_host[0] == '[') ? ']' : ':')) != NULL)
a727 3
	if (ssl_host[0] == '[')
	    ssl_host++;

a728 1
	CTRACE((tfp, "Validating CNs in '%s'\n", ssl_dn_start));
d739 2
a740 3
	    /* strip port number (XXX [ip]:port encap here too? -TG) */
	    if ((p = strchr(cert_host,
			    (cert_host[0] == '[') ? ']' : ':')) != NULL)
a741 3
	    if (cert_host[0] == '[')
		cert_host++;

a742 2
	    CTRACE((tfp, "Matching\n\tssl_host  '%s'\n\tcert_host '%s'\n",
		    ssl_host, cert_host));
d745 1
a745 1
		/* I think this is cool to have in the logs -TG */
a750 1
		show_cert_issuer(SSL_get_peer_certificate(handle));
a753 1

d755 6
a760 6
	    if (ssl_all_cns == NULL)
		StrAllocCopy(ssl_all_cns, "CN<");
	    else
		StrAllocCat(ssl_all_cns, ":CN<");
	    StrAllocCat(ssl_all_cns, cert_host);
	    StrAllocCat(ssl_all_cns, ">");
a767 61
	/* check the X.509v3 Subject Alternative Name */
#ifdef USE_OPENSSL_INCL
	if (status_sslcertcheck < 2) {
	    STACK_OF(GENERAL_NAME) * gens;
	    int i, numalts;
	    const GENERAL_NAME *gn;

	    if ((gens = X509_get_ext_d2i(peer_cert, NID_subject_alt_name,
					 NULL, NULL)) != NULL) {
		numalts = sk_GENERAL_NAME_num(gens);
		for (i = 0; i < numalts; ++i) {
		    gn = sk_GENERAL_NAME_value(gens, i);
		    if (gn->type == GEN_DNS)
			cert_host = (char *) ASN1_STRING_data(gn->d.ia5);
		    else if (gn->type == GEN_IPADD) {
			/* XXX untested -TG */
			size_t j = ASN1_STRING_length(gn->d.ia5);

			cert_host = malloc(j + 1);
			memcpy(cert_host, ASN1_STRING_data(gn->d.ia5), j);
			cert_host[j] = '\0';
		    } else
			continue;
		    status_sslcertcheck = 1;	/* got at least one */
		    /* verify this SubjectAltName (see above) */
		    if ((p = strchr(cert_host,
				    (cert_host[0] == '[') ? ']' : ':')) != NULL)
			*p = '\0';
		    if (cert_host[0] == '[')
			cert_host++;
		    if (!(gn->type == GEN_IPADD ? strcasecomp :
			  strcasecomp_asterisk) (ssl_host, cert_host)) {
			status_sslcertcheck = 2;
			HTSprintf0(&msg,
				   gettext("Verified connection to %s (subj=%s)"),
				   ssl_host, cert_host);
			_HTProgress(msg);
			FREE(msg);
			if (gn->type == GEN_IPADD)
			    free(cert_host);
			break;
		    }
		    /* add to list of failed CNs */
		    if (ssl_all_cns == NULL)
			StrAllocCopy(ssl_all_cns, "SAN<");
		    else
			StrAllocCat(ssl_all_cns, ":SAN<");
		    if (gn->type == GEN_DNS)
			StrAllocCat(ssl_all_cns, "DNS=");
		    else if (gn->type == GEN_IPADD)
			StrAllocCat(ssl_all_cns, "IP=");
		    StrAllocCat(ssl_all_cns, cert_host);
		    StrAllocCat(ssl_all_cns, ">");
		    if (gn->type == GEN_IPADD)
			free(cert_host);
		}
		sk_GENERAL_NAME_free(gens);
	    }
	}
#endif /* USE_OPENSSL_INCL */

a785 5
	    HTSprintf0(&msg,
		       gettext("UNVERIFIED connection to %s (cert=%s)"),
		       ssl_host, ssl_all_cns ? ssl_all_cns : "NONE");
	    _HTProgress(msg);
	    FREE(msg);
a787 2
	show_cert_issuer(peer_cert);

@


1.1.109.6
log
@Import Lynx 2.8.7dev.7 into base as well
@
text
@d2 1
a2 1
 * $LynxId: HTTP.c,v 1.87 2007/07/03 00:20:33 tom Exp $
d791 1
d817 2
a818 4
	    gens = (STACK_OF(GENERAL_NAME) *)
		X509_get_ext_d2i(peer_cert, NID_subject_alt_name, NULL, NULL);

	    if (gens != NULL) {
d828 1
a828 1
			cert_host = (char *) malloc(j + 1);
@


1.1.109.7
log
@Import Lynx 2.8.7dev.8
@
text
@d2 1
a2 1
 * $LynxId: HTTP.c,v 1.91 2008/02/17 19:36:08 Zdenek.Prikryl Exp $
a81 10
#ifdef USE_X509_SUPPORT
    HTSprintf0(&msg,
	       gettext("SSL callback:%s, preverify_ok=%d, ssl_okay=%d"),
	       X509_verify_cert_error_string(X509_STORE_CTX_get_error(x509_ctx)),
	       preverify_ok, ssl_okay);
    _HTProgress(msg);
    FREE(msg);
#endif

#ifndef USE_NSS_COMPAT_INCL
a93 1
#endif
a121 7
	} else {
	    if (non_empty(SSL_cert_file)) {
		certfile = SSL_cert_file;
		CTRACE((tfp,
			"HTGetSSLHandle: certfile is set to %s by config SSL_CERT_FILE\n",
			certfile));
	    }
d435 1
a435 1
static void show_cert_issuer(X509 * peer_cert GCC_UNUSED)
a639 1
#ifndef USE_NSS_COMPAT_INCL
a641 1
#endif
a809 36
#ifdef USE_GNUTLS_INCL
	if (status_sslcertcheck < 2) {
	    int i;
	    size_t size;
	    gnutls_x509_crt cert;
	    static char buf[2048];

	    /* import the certificate to the x509_crt format */
	    if (gnutls_x509_crt_init(&cert) == 0) {

		if (gnutls_x509_crt_import(cert, peer_cert,
					   GNUTLS_X509_FMT_DER) < 0) {
		    gnutls_x509_crt_deinit(cert);
		    goto done;
		}

		ret = 0;
		for (i = 0; !(ret < 0); i++) {
		    size = sizeof(buf);
		    ret = gnutls_x509_crt_get_subject_alt_name(cert, i, buf,
							       &size, NULL);

		    if (strcasecomp_asterisk(ssl_host, buf) == 0) {
			status_sslcertcheck = 2;
			HTSprintf0(&msg,
				   gettext("Verified connection to %s (subj=%s)"),
				   ssl_host, buf);
			_HTProgress(msg);
			FREE(msg);
			break;
		    }

		}
	    }
	}
#endif
@


1.1.109.8
log
@Import Lynx 2.8.7dev.11a via eMail from Tom Dickey:
Message-ID: <20081215010313.GA8373@@invisible-island.net>
Message-ID: <20081216012408.GA15364@@invisible-island.net>
@
text
@d2 1
a2 1
 * $LynxId: HTTP.c,v 1.99 2008/12/14 18:05:36 tom Exp $
d455 1
a455 1
#if defined(USE_OPENSSL_INCL) || defined(USE_GNUTLS_FUNCS)
d464 1
a464 1
    /* the OpenSSL "compat" code compiles but dumps core with GNU TLS */
a532 1
    int port_number;
a568 2
	int portnumber;

d572 1
a572 1
	    if (!HTParsePort(connect_host, &portnumber)) {
d581 1
a581 1
	    if (!HTParsePort(connect_host, &portnumber)) {
d776 1
a776 1
	if ((p = HTParsePort(ssl_host, &port_number)) != 0)
d778 2
d794 2
a795 1
	    if ((p = HTParsePort(cert_host, &port_number)) != 0)
d797 2
d892 2
a893 1
		    if ((p = HTParsePort(cert_host, &port_number)) != 0)
d895 2
d1037 1
a1037 1
			sprintf(temp, ";q=%4.3f;mxb=%" PRI_off_t "",
d1043 1
a1043 1
		    sprintf(temp, ";mxb=%" PRI_off_t "", pres->maxbytes);
d1211 3
a1213 2
		NULL != (colon = HTParsePort(hostname, &portnumber))) {
		*colon = '\0';	/* Chop off port number */
d1237 1
a1237 1
		    if ((colon = HTParsePort(host2, &port2)) != NULL) {
d1240 2
a2443 1
    dump_server_status = server_status;
@


1.1.109.9
log
@Import Lynx 2.8.7dev.12
@
text
@d2 1
a2 1
 * $LynxId: HTTP.c,v 1.101 2008/12/31 02:03:20 tom Exp $
a468 21
/*
 * Remove IPv6 brackets (and any port-number) from the given host-string.
 */
static char *StripIpv6Brackets(char *host)
{
    int port_number;
    char *p;

    if ((p = HTParsePort(host, &port_number)) != 0)
	*p = '\0';

    if (*host == '[') {
	p = host + strlen(host) - 1;
	if (*p == ']') {
	    *p = '\0';
	    ++host;
	}
    }
    return host;
}

d533 1
d778 3
a780 1
	ssl_host = StripIpv6Brackets(ssl_host);
d794 3
a796 1
	    cert_host = StripIpv6Brackets(cert_host);
d890 2
a891 1
		    cert_host = StripIpv6Brackets(cert_host);
d2264 1
@


1.1.109.10
log
@Woohoo, theres a new Lynx release!
@
text
@d2 1
a2 1
 * $LynxId: HTTP.c,v 1.108 2009/05/22 00:47:41 tom Exp $
a44 1
#include <LYUtils.h>
d61 1
a61 1
BOOLEAN reloading = FALSE;	/* Reloading => send no-cache pragma to proxy */
d176 1
a176 1
	lynx_srand((unsigned) seed);
d221 13
d300 4
d447 1
a447 1
	result = (BOOL) (program != 0);
a471 1
#ifdef USE_SSL
a488 1
#endif
d527 1
d627 1
a679 3
	/* get host we're connecting to */
	ssl_host = HTParse(url, "", PARSE_HOST);
	ssl_host = StripIpv6Brackets(ssl_host);
d682 1
a682 1
	if (!try_tls) {
a683 5
#if OPENSSL_VERSION_NUMBER >= 0x0090806fL && !defined(OPENSSL_NO_TLSEXT)
	} else {
	    SSL_set_tlsext_host_name(handle, ssl_host);
#endif
	}
d796 3
d897 1
a897 1
			size_t j = (size_t) ASN1_STRING_length(gn->d.ia5);
d1048 1
a1048 1
				pres->quality, CAST_off_t(pres->maxbytes));
d1053 1
a1053 1
		    sprintf(temp, ";mxb=%" PRI_off_t "", CAST_off_t(pres->maxbytes));
d1062 1
a1062 1
		len += (int) strlen(linebuf);
d1068 1
a1068 1
		    len = (int) strlen(linebuf);
d1172 12
a1183 14
	if (LYSendUserAgent || no_useragent) {
	    if (!isEmpty(LYUserAgent)) {
		char *cp = LYSkipBlanks(LYUserAgent);

		/* Won't send it at all if all blank - kw */
		if (*cp != '\0')
		    HTBprintf(&command, "User-Agent: %.*s%c%c",
			      INIT_LINE_SIZE - 15, LYUserAgent, CR, LF);
	    } else {
		HTBprintf(&command, "User-Agent: %s/%s  libwww-FM/%s%c%c",
			  HTAppName ? HTAppName : "unknown",
			  HTAppVersion ? HTAppVersion : "0.0",
			  HTLibraryVersion, CR, LF);
	    }
d1488 1
a1488 1
	line_buffer = typecallocn(char, (unsigned) buffer_length);
d1501 1
a1501 2
		    (char *) realloc(line_buffer, ((unsigned) buffer_length *
						   sizeof(char)));
d1507 2
a1508 4
	    status = HTTP_NETREAD(s,
				  line_buffer + length,
				  (buffer_length - length - 1),
				  handle);
d1579 1
a1579 2
		line_kept_clean = (char *) malloc((unsigned) buffer_length *
						  sizeof(char));
d1583 1
a1583 1
		memcpy(line_kept_clean, line_buffer, (unsigned) buffer_length);
d1819 1
@


1.1.109.11
log
@Import lynx-current
@
text
@d2 1
a2 1
 * $LynxId: HTTP.c,v 1.121 2010/11/07 21:20:58 tom Exp $
d86 1
a86 1
	       X509_verify_cert_error_string((long) X509_STORE_CTX_get_error(x509_ctx)),
d96 1
a96 2
		   X509_verify_cert_error_string((long)
						 X509_STORE_CTX_get_error(x509_ctx)));
d164 1
a164 1
	RAND_file_name(rand_file, 256L);
d168 1
a168 1
	    RAND_load_file(rand_file, 1024L);
d171 1
a171 2
	RAND_seed((unsigned char *) &t, (int) sizeof(time_t));

d173 1
a173 1
	RAND_seed((unsigned char *) &pid, (int) sizeof(pid));
d175 1
a175 1
	RAND_bytes((unsigned char *) &seed, (int) sizeof(long));
d181 1
a181 1
	    RAND_seed((unsigned char *) &l, (int) sizeof(long));
d193 1
a193 4
	(handle \
	 ? SSL_read(handle, buff, size) \
	 : NETREAD(sock, buff, size))

d195 1
a195 4
	(handle \
	 ? SSL_write(handle, buff, size) \
	 : NETWRITE(sock, buff, size))

d197 1
a197 5
	{ (void)NETCLOSE(sock); \
	  if (handle) \
	      SSL_free(handle); \
	  SSL_handle = handle = NULL; \
	}
d443 1
a443 1
    X509_NAME_oneline(X509_get_issuer_name(peer_cert), ssl_dn, (int) sizeof(ssl_dn));
d498 1
a498 1
    static char empty[1];
d505 1
a505 1
    off_t bytes_already_read;
a514 2

#ifdef SH_EX			/* FIX BUG by kaz@@maczuka.hitachi.ibaraki.jp */
a515 1
#endif
d525 1
a525 1
    int server_status = 0;
a529 1
    unsigned long SSLerror;
d574 1
a574 1
    if (using_proxy && !StrNCmp(url, "http://", 7)) {
d621 1
a621 1
    if (!StrNCmp(url, "https", 5))
d626 1
a626 1
    if (!StrNCmp(url, "https", 5)) {
d661 1
a661 1
    if (did_connect || !StrNCmp(url, "https", 5)) {
d690 2
d724 1
a724 1
	if (ret < 0) {
a757 1
#if defined(USE_OPENSSL_INCL) || defined(USE_GNUTLS_FUNCS)
d759 4
a762 4
			  ssl_dn, (int) sizeof(ssl_dn));
#elif defined(USE_GNUTLS_INCL)
	X509_NAME_oneline(X509_get_subject_name(peer_cert),
			  ssl_dn + 1, (int) sizeof(ssl_dn) - 1);
d889 1
a889 1
			MemCpy(cert_host, ASN1_STRING_data(gn->d.ia5), j);
d1037 1
a1037 1
				pres->quality, CAST_off_t (pres->maxbytes));
d1042 1
a1042 1
		    sprintf(temp, ";mxb=%" PRI_off_t "", CAST_off_t (pres->maxbytes));
d1066 2
d1162 1
a1162 1
	    if (non_empty(LYUserAgent)) {
d1205 2
a1206 3
	    BOOL secure = (BOOL) (StrNCmp(anAnchor->address, "https", 5)
				  ? FALSE
				  : TRUE);
d1214 1
a1214 1
	    } else if (!StrNCmp(arg, "https", 5)) {
d1231 1
a1231 1
		int port2 = (StrNCmp(docname, "https", 5) ?
d1288 1
a1288 1
		if (!StrNCmp(docname, "http", 4)) {
d1381 1
d1436 1
a1436 4
    status = (int) HTTP_NETWRITE(s,
				 BStrData(command),
				 BStrLen(command),
				 handle);
d1479 1
a1479 1
	line_buffer = typecallocn(char, (size_t) buffer_length);
d1484 1
a1484 1
	HTReadProgress(bytes_already_read = 0, (off_t) 0);
d1536 1
a1536 13
		}
#ifdef USE_SSL
		else if ((SSLerror = ERR_get_error()) != 0) {
		    CTRACE((tfp,
			    "HTTP: Hit unexpected network read error; aborting connection; status %d:%s.\n",
			    status, ERR_error_string(SSLerror, NULL)));
		    HTAlert(gettext("Unexpected network read error; connection aborted."));
		    HTTP_NETCLOSE(s, handle);
		    status = -1;
		    goto clean_up;
		}
#endif
		else {
d1558 1
a1558 1
	    HTReadProgress(bytes_already_read, (off_t) 0);
d1566 1
d1578 1
a1578 2
		MemCpy(line_kept_clean, line_buffer, buffer_length);
#ifdef SH_EX			/* FIX BUG by kaz@@maczuka.hitachi.ibaraki.jp */
a1579 1
#endif
d1616 3
a1618 3
	(0 == StrNCmp(line_buffer, "<TITLE>Bad File Request</TITLE>", 31) ||
	 0 == StrNCmp(line_buffer, "Address should begin with", 25) ||
	 0 == StrNCmp(line_buffer, "<TITLE>Help ", 12) ||
d1680 1
a1680 1
	    if (!StrNCmp(HTAtom_name(format_in), "text/plain", 10)) {
d1711 2
a1712 8
	    if (eol != 0) {
		start_of_data = (eol + 1);
	    } else {
		start_of_data = empty;
	    }
	    length = (eol
		      ? length - (int) (start_of_data - line_buffer)
		      : 0);
d1803 1
a1803 1
			if (!StrNCmp(connect_url, "snews", 5)) {
d1813 1
d1980 6
a1985 7
		     * Authorization for origin server required.  If show_401
		     * is set, proceed to showing the 401 body.  Otherwise, if
		     * we can set up authorization based on the
		     * WWW-Authenticate header, and the user provides a
		     * username and password, try again.  Otherwise, check
		     * whether to show the 401 body or restore the current
		     * document - FM
d1989 1
a1989 2
		    if (HTAA_shouldRetryWithAuth(start_of_data, (size_t)
						 length, s, NO)) {
d2009 1
a2009 1
			if (using_proxy && !StrNCmp(url, "https://", 8)) {
d2039 1
a2039 2
		    if (HTAA_shouldRetryWithAuth(start_of_data, (size_t)
						 length, s, YES)) {
d2382 1
d2432 2
d2436 2
@


1.1.109.12
log
@Import Lynx 2.8.8dev.10 plus dev.10a patch from invisible-island plus
fix for lynx -help output by KIHARA Hideto, by import-3rdpty,v 1.43
@
text
@d2 1
a2 1
 * $LynxId: HTTP.c,v 1.123 2011/06/11 12:09:21 tom Exp $
d58 4
a129 15
#if defined(USE_PROGRAM_DIR) & !defined(USE_GNUTLS_INCL)
	{
	    X509_LOOKUP *lookup;

	    lookup = X509_STORE_add_lookup(ssl_ctx->cert_store,
					   X509_LOOKUP_file());
	    if (lookup != NULL) {
		char *certfile = NULL;

		HTSprintf0(&certfile, "%s\\cert.pem", program_dir);
		X509_LOOKUP_load_file(lookup, certfile, X509_FILETYPE_PEM);
		FREE(certfile);
	    }
	}
#endif
a141 7
#if defined(USE_PROGRAM_DIR)
	    else {
		HTSprintf0(&(certfile), "%s\\cert.pem", program_dir);
		CTRACE((tfp,
			"HTGetSSLHandle: certfile is set to %s by installed directory\n", certfile));
	    }
#endif
d160 1
a162 7
#ifndef _WINDOWS
	pid_t pid;

#else
	DWORD pid;
#endif

a163 2

#ifndef _WINDOWS
a164 4
#else
	pid = GetCurrentThreadId();
#endif

@


1.1.109.13
log
@lynx2.8.8dev.14
@
text
@d2 1
a2 1
 * $LynxId: HTTP.c,v 1.124 2012/08/01 11:00:26 tom Exp $
a766 3
	gnutls_certificate_set_verify_flags(handle->gnutls_cred,
					    GNUTLS_VERIFY_DO_NOT_ALLOW_SAME |
					    GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT);
@


1.1.109.14
log
@Import Lynx 2.8.8dev.15 as suggested by lewellyn on IRC
@
text
@d2 1
a2 1
 * $LynxId: HTTP.c,v 1.126 2012/11/13 22:49:46 tom Exp $
d713 1
a713 6
#if defined(USE_GNUTLS_FUNCS)
	ret = gnutls_server_name_set(handle->gnutls_state,
				     GNUTLS_NAME_DNS,
				     ssl_host, strlen(ssl_host));
	CTRACE((tfp, "...called gnutls_server_name_set(%s) ->%d\n", ssl_host, ret));
#elif SSLEAY_VERSION_NUMBER >= 0x0900
d771 1
a771 2
	if (ret < 0 || (ret == 0 &&
			tls_status & GNUTLS_CERT_SIGNER_NOT_FOUND)) {
d775 1
a775 3
	    if (ret == 0 && tls_status & GNUTLS_CERT_SIGNER_NOT_FOUND) {
		msg2 = gettext("self signed certificate");
	    } else if (tls_status & GNUTLS_CERT_SIGNER_NOT_FOUND) {
d779 2
@


1.1.109.15
log
@Update to the latest Lynx patchkit
@
text
@d2 1
a2 1
 * $LynxId: HTTP.c,v 1.128 2013/05/05 19:36:45 tom Exp $
d197 4
a200 2
	/* Seed as much as 1024 bytes from RAND_file_name */
	RAND_load_file(rand_file, 1024L);
d215 4
a218 2
	/* Write a rand_file */
	RAND_write_file(rand_file);
d555 2
a556 2
    char *line_buffer = NULL;
    char *line_kept_clean = NULL;
d2162 1
a2162 1
		    goto clean_up;
@


