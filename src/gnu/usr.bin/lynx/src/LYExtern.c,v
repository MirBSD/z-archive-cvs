head	1.4;
access;
symbols
	lynx-2_8_8dev_16:1.1.109.10
	lynx-2_8_8dev_15e:1.1.109.10
	lynx-2_8_8dev_15:1.1.109.9
	lynx-2_8_8dev_14:1.1.109.9
	lynx-2_8_8dev_12:1.1.109.8
	lynx-2_8_8dev_11:1.1.109.8
	lynx-2_8_8dev_10a:1.1.109.8
	lynx-2_8_8dev_7a:1.1.109.7
	lynx-2_8_8dev_7:1.1.109.7
	lynx-2_8_7rel_1:1.1.109.6
	lynx-2_8_7dev_12:1.1.109.5
	lynx-2_8_7dev_11a:1.1.109.4
	MIRBSD_10:1.1.109.3.0.2
	MIRBSD_10_BASE:1.1.109.3
	lynx-2_8_7dev_8:1.1.109.3
	lynx-2_8_7dev_7:1.1.109.3
	lynx-2_8_7dev_5:1.1.109.2
	lynx-2_8_7dev_2:1.1.109.2
	lynx-2_8_6pre_5:1.1.109.2
	lynx-2_8_6pre_4:1.1.109.2
	lynx-2_8_6pre_3:1.1.109.2
	MIRBSD_9_BASE:1.1.109.2
	lynx-2_8_6dev_18c:1.1.109.2
	lynx-2_8_6dev_18:1.1.109.2
	MIRBSD_8:1.1.109.2.0.2
	MIRBSD_8_BASE:1.1.109.2
	lynx-2_8_6dev_16:1.1.109.2
	lynx:1.1.109;
locks; strict;
comment	@ * @;


1.4
date	2013.05.18.14.59.44;	author tg;	state Exp;
branches;
next	1.3;
commitid	1005197975F6A2B23A5;

1.3
date	2012.08.23.18.36.11;	author tg;	state Exp;
branches;
next	1.2;
commitid	1005036781D23C1E744;

1.2
date	2012.02.19.19.38.10;	author tg;	state Exp;
branches;
next	1.1;
commitid	1004F414F917991F461;

1.1
date	2005.03.27.22.12.09;	author tg;	state Exp;
branches
	1.1.109.1;
next	;

1.1.109.1
date	2005.03.27.22.12.09;	author tg;	state Exp;
branches;
next	1.1.109.2;

1.1.109.2
date	2005.12.19.23.10.41;	author tg;	state Exp;
branches;
next	1.1.109.3;
commitid	10043A73DF946372F3D;

1.1.109.3
date	2007.08.03.15.11.21;	author tg;	state Exp;
branches;
next	1.1.109.4;
commitid	10046B3450C0C128495;

1.1.109.4
date	2008.12.16.23.13.11;	author tg;	state Exp;
branches;
next	1.1.109.5;
commitid	100494835F965A87026;

1.1.109.5
date	2009.01.18.19.31.28;	author tg;	state Exp;
branches;
next	1.1.109.6;
commitid	1004973839C3B701938;

1.1.109.6
date	2009.08.09.14.37.52;	author tg;	state Exp;
branches;
next	1.1.109.7;
commitid	1004A7EDF4952738297;

1.1.109.7
date	2010.12.19.18.12.46;	author tg;	state Exp;
branches;
next	1.1.109.8;
commitid	1004D0E4B24304015D1;

1.1.109.8
date	2012.02.19.18.29.41;	author tg;	state Exp;
branches;
next	1.1.109.9;
commitid	1004F413EF328BF0E26;

1.1.109.9
date	2012.08.23.17.48.54;	author tg;	state Exp;
branches;
next	1.1.109.10;
commitid	10050366CBF479FD80F;

1.1.109.10
date	2013.05.18.14.44.02;	author tg;	state Exp;
branches;
next	;
commitid	100519793BB3FCC7E2F;


desc
@@


1.4
log
@fastmerge
@
text
@/*
 * $LynxId: LYExtern.c,v 1.52 2013/05/04 13:01:06 tom Exp $
 *
 External application support.
 This feature allows lynx to pass a given URL to an external program.
 It was written for three reasons.
 1) To overcome the deficiency	of Lynx_386 not supporting ftp and news.
    External programs can be used instead by passing the URL.

 2) To allow for background transfers in multitasking systems.
    I use wget for http and ftp transfers via the external command.

 3) To allow for new URLs to be used through lynx.
    URLs can be made up such as mymail: to spawn desired applications
    via the external command.

 See lynx.cfg for other info.
*/

#include <LYUtils.h>

#ifdef USE_EXTERNALS

#include <HTAlert.h>
#include <LYGlobalDefs.h>
#include <LYExtern.h>
#include <LYLeaks.h>
#include <LYCurses.h>
#include <LYReadCFG.h>
#include <LYStrings.h>

#ifdef WIN_EX
/* ASCII char -> HEX digit */
#define ASC2HEXD(x) ((UCH(x) >= '0' && UCH(x) <= '9') ?               \
		     (UCH(x) - '0') : (toupper(UCH(x)) - 'A' + 10))

/* Decodes the forms %xy in a URL to the character the hexadecimal
   code of which is xy. xy are hexadecimal digits from
   [0123456789ABCDEF] (case-insensitive). If x or y are not hex-digits
   or '%' is near '\0', the whole sequence is inserted literally. */

static char *decode_string(char *s)
{
    char *save_s;
    char *p = s;

    save_s = s;
    for (; *s; s++, p++) {
	if (*s != '%')
	    *p = *s;
	else {
	    /* Do nothing if at the end of the string. Or if the chars
	       are not hex-digits. */
	    if (!*(s + 1) || !*(s + 2)
		|| !(isxdigit(UCH(*(s + 1))) && isxdigit(UCH(*(s + 2))))) {
		*p = *s;
		continue;
	    }
	    *p = (char) ((ASC2HEXD(*(s + 1)) << 4) + ASC2HEXD(*(s + 2)));
	    s += 2;
	}
    }
    *p = '\0';
    return save_s;
}
#endif /* WIN_EX */

#ifdef WIN_EX
/*
 *  Delete dangerous characters as local path.
 *  We delete '<>|' and also '%"'.
 *  '%' should be deleted because it's difficut to escape for all cases.
 *  So we can't treat paths which include '%'.
 *  '"' should be deleted because it's an obstacle to quote whole path.
 */
static void delete_danger_characters(char *src)
{
    char *dst;

    for (dst = src; *src != '\0'; src++) {
	if (strchr("<>|%\"", *src) == NULL) {
	    *dst = *src;
	    dst++;
	}
    }
    *dst = '\0';
}

static char *escapeParameter(CONST char *parameter)
{
    size_t i;
    size_t last = strlen(parameter);
    size_t n = 0;
    size_t encoded = 0;
    size_t escaped = 0;
    char *result;
    char *needs_encoded = "<>|";
    char *needs_escaped = "%";
    char *needs_escaped_NT = "%&^";

    for (i = 0; i < last; ++i) {
	if (strchr(needs_encoded, parameter[i]) != NULL) {
	    ++encoded;
	}
	if (system_is_NT) {
	    if (strchr(needs_escaped_NT, parameter[i]) != NULL) {
		++escaped;
	    }
	} else if (strchr(needs_escaped, parameter[i]) != NULL) {
	    ++escaped;
	}
    }

    result = (char *) malloc(last + encoded * 2 + escaped + 1);
    if (result == NULL)
	outofmem(__FILE__, "escapeParameter");

    n = 0;
    for (i = 0; i < last; i++) {
	if (strchr(needs_encoded, parameter[i]) != NULL) {
	    sprintf(result + n, "%%%02X", (unsigned char) parameter[i]);
	    n += 3;
	    continue;
	}
	if (system_is_NT) {
	    if (strchr(needs_escaped_NT, parameter[i]) != NULL) {
		result[n++] = '^';
		result[n++] = parameter[i];
		continue;
	    }
	} else if (strchr(needs_escaped, parameter[i]) != NULL) {
	    result[n++] = '%';	/* parameter[i] is '%' */
	    result[n++] = parameter[i];
	    continue;
	}
	result[n++] = parameter[i];
    }
    result[n] = '\0';

    return result;
}
#endif /* WIN_EX */

static void format(char **result,
		   char *fmt,
		   char *parm)
{
    *result = NULL;
    HTAddParam(result, fmt, 1, parm);
    HTEndParam(result, fmt, 1);
}

/*
 * Format the given command into a buffer, returning the resulting string.
 *
 * It is too dangerous to leave any URL that may come along unquoted.  They
 * often contain '&', ';', and '?' chars, and who knows what else may occur.
 * Prevent spoofing of the shell.  Dunno how this needs to be modified for VMS
 * or DOS.  - kw
 */
static char *format_command(char *command,
			    char *param)
{
    char *cmdbuf = NULL;

#if defined(WIN_EX)
    char pram_string[LY_MAXPATH];
    char *escaped = NULL;

    if (strnicmp("file://localhost/", param, 17) == 0) {
	/* decode local path parameter for programs to be
	   able to interpret - TH */
	LYStrNCpy(pram_string, param, sizeof(pram_string) - 1);
	decode_string(pram_string);
	param = pram_string;
    } else {
	/* encode or escape URL parameter - TH */
	escaped = escapeParameter(param);
	param = escaped;
    }

    if (isMAILTO_URL(param)) {
	format(&cmdbuf, command, param + 7);
    } else if (strnicmp("telnet://", param, 9) == 0) {
	char host[sizeof(pram_string)];
	int last_pos;

	LYStrNCpy(host, param + 9, sizeof(host));
	last_pos = strlen(host) - 1;
	if (last_pos > 1 && host[last_pos] == '/')
	    host[last_pos] = '\0';

	format(&cmdbuf, command, host);
    } else if (strnicmp("file://localhost/", param, 17) == 0) {
	char e_buff[LY_MAXPATH], *p;

	p = param + 17;
	delete_danger_characters(p);
	*e_buff = 0;
	if (strchr(p, ':') == NULL) {
	    sprintf(e_buff, "%.3s/", windows_drive);
	}
	strncat(e_buff, p, sizeof(e_buff) - strlen(e_buff) - 1);
	p = strrchr(e_buff, '.');
	if (p) {
	    trimPoundSelector(p);
	}

	/* Less ==> short filename with backslashes,
	 * less ==> long filename with forward slashes, may be quoted
	 */
	if (ISUPPER(command[0])) {
	    char *short_name = HTDOS_short_name(e_buff);

	    p = quote_pathname(short_name);
	    format(&cmdbuf, command, p);
	    FREE(p);
	} else {
	    p = quote_pathname(e_buff);
	    format(&cmdbuf, command, p);
	    FREE(p);
	}
    } else {
	format(&cmdbuf, command, param);
    }
    FREE(escaped);
#else
    format(&cmdbuf, command, param);
#endif
    return cmdbuf;
}

/*
 * Find the EXTERNAL command which matches the given name 'param'.  If there is
 * more than one possibility, make a popup menu of the matching commands and
 * allow the user to select one.  Return the selected command.
 */
static char *lookup_external(char *param,
			     int only_overriders)
{
    int pass, num_disabled, num_matched, num_choices, cur_choice;
    size_t length = 0;
    char *cmdbuf = NULL;
    char **actions = 0;
    char **choices = 0;
    lynx_list_item_type *ptr = 0;

    for (pass = 0; pass < 2; pass++) {
	num_disabled = 0;
	num_matched = 0;
	num_choices = 0;
	for (ptr = externals; ptr != 0; ptr = ptr->next) {

	    if (match_item_by_name(ptr, param, only_overriders)) {
		++num_matched;
		CTRACE((tfp, "EXTERNAL: '%s' <==> '%s'\n", ptr->name, param));
		if (no_externals && !ptr->always_enabled && !only_overriders) {
		    ++num_disabled;
		} else {
		    if (pass == 0) {
			length++;
		    } else if (pass != 0) {
			cmdbuf = format_command(ptr->command, param);
			if (length > 1) {
			    actions[num_choices] = cmdbuf;
			    choices[num_choices] =
				format_command(ptr->menu_name, param);
			}
		    }
		    num_choices++;
		}
	    }
	}
	if (length > 1) {
	    if (pass == 0) {
		actions = typecallocn(char *, length + 1);
		choices = typecallocn(char *, length + 1);

		if (actions == 0 || choices == 0)
		    outofmem(__FILE__, "lookup_external");
	    } else {
		actions[num_choices] = 0;
		choices[num_choices] = 0;
	    }
	}
    }

    if (num_disabled != 0
	&& num_disabled == num_matched) {
	HTUserMsg(EXTERNALS_DISABLED);
    } else if (num_choices > 1) {
	int old_y, old_x;

	LYGetYX(old_y, old_x);
	cur_choice = LYhandlePopupList(-1,
				       0,
				       old_x,
				       (STRING2PTR) choices,
				       -1,
				       -1,
				       FALSE,
				       TRUE);
	wmove(LYwin, old_y, old_x);
	CTRACE((tfp, "selected choice %d of %d\n", cur_choice, num_choices));
	if (cur_choice < 0) {
	    HTInfoMsg(CANCELLED);
	    cmdbuf = 0;
	}
	for (pass = 0; choices[pass] != 0; pass++) {
	    if (pass == cur_choice) {
		cmdbuf = actions[pass];
	    } else {
		FREE(actions[pass]);
	    }
	    FREE(choices[pass]);
	}
    }

    if (actions) {
	for (pass = 0; actions[pass] != 0; ++pass) {
	    if (actions[pass] != cmdbuf)
		FREE(actions[pass]);
	}
	FREE(actions);
    }

    if (choices) {
	for (pass = 0; choices[pass] != 0; ++pass) {
	    FREE(choices[pass]);
	}
	FREE(choices);
    }

    return cmdbuf;
}

BOOL run_external(char *param,
		  int only_overriders)
{
#ifdef WIN_EX
    int status;
#endif
    int redraw_flag = TRUE;
    char *cmdbuf = NULL;
    BOOL found = FALSE;
    int confirmed = TRUE;

    if (externals == NULL)
	return 0;

#ifdef WIN_EX			/* 1998/01/26 (Mon) 09:16:13 */
    if (param == NULL) {
	HTInfoMsg(gettext("External command is null"));
	return 0;
    }
#endif

    cmdbuf = lookup_external(param, only_overriders);
    if (non_empty(cmdbuf)) {
#ifdef WIN_EX			/* 1997/10/17 (Fri) 14:07:50 */
	int len;
	char buff[LY_MAXPATH];

	CTRACE((tfp, "Lynx EXTERNAL: '%s'\n", cmdbuf));
#ifdef WIN_GUI			/* 1997/11/06 (Thu) 14:17:15 */
	confirmed = MessageBox(GetForegroundWindow(), cmdbuf,
			       "Lynx (EXTERNAL COMMAND EXEC)",
			       MB_ICONQUESTION | MB_SETFOREGROUND | MB_OKCANCEL)
	    != IDCANCEL;
#else
	confirmed = HTConfirm(LYElideString(cmdbuf, 40)) != NO;
#endif
	if (confirmed) {
	    len = strlen(cmdbuf);
	    if (len > 255) {
		sprintf(buff, "Lynx: command line too long (%d > 255)", len);
#ifdef WIN_GUI			/* 1997/11/06 (Thu) 14:17:02 */
		MessageBox(GetForegroundWindow(), buff,
			   "Lynx (EXTERNAL COMMAND EXEC)",
			   MB_ICONEXCLAMATION | MB_SETFOREGROUND | MB_OK);
		SetConsoleTitle("Lynx for Win32");
#else
		HTConfirm(LYElideString(buff, 40));
#endif
		confirmed = FALSE;
	    } else {
		SetConsoleTitle(cmdbuf);
	    }
	}

	if (strnicmp(cmdbuf, "start ", 6) == 0)
	    redraw_flag = FALSE;
	else
	    redraw_flag = TRUE;
#else
	HTUserMsg(cmdbuf);
#endif
	found = TRUE;
	if (confirmed) {
	    if (redraw_flag) {
		stop_curses();
		fflush(stdout);
	    }

	    /* command running. */
#ifdef WIN_EX			/* 1997/10/17 (Fri) 14:07:50 */
#if defined(__CYGWIN__) || defined(__MINGW32__)
	    status = system(cmdbuf);
#else
	    status = xsystem(cmdbuf);
#endif
	    if (status != 0) {
		sprintf(buff,
			"EXEC code = %04x (%2d, %2d)\r\n"
			"'%s'",
			status, (status / 256), (status & 0xff),
			cmdbuf);
#ifdef SH_EX			/* WIN_GUI for ERROR only */
		MessageBox(GetForegroundWindow(), buff,
			   "Lynx (EXTERNAL COMMAND EXEC)",
			   MB_ICONSTOP | MB_SETFOREGROUND | MB_OK);
#else
		HTConfirm(LYElideString(buff, 40));
#endif /* 1 */
	    }
#else /* Not WIN_EX */
	    LYSystem(cmdbuf);
#endif /* WIN_EX */

#if defined(WIN_EX)
	    SetConsoleTitle("Lynx for Win32");
#endif
	    if (redraw_flag) {
		fflush(stdout);
		start_curses();
	    }
	}
    }

    FREE(cmdbuf);
    return found;
}
#endif /* USE_EXTERNALS */
@


1.3
log
@fastmerge
@
text
@d2 1
a2 1
 * $LynxId: LYExtern.c,v 1.50 2012/08/15 23:16:22 tom Exp $
d278 3
d317 7
d325 6
d333 1
@


1.2
log
@merge lynx2.8.8dev.10a and fix some spelling
@
text
@d2 1
a2 1
 * $LynxId: LYExtern.c,v 1.49 2012/02/10 18:36:39 tom Exp $
d34 2
a35 2
#define ASC2HEXD(x) (((x) >= '0' && (x) <= '9') ?               \
		     ((x) - '0') : (toupper(x) - 'A' + 10))
@


1.1
log
@Initial revision
@
text
@d2 2
d55 1
a55 1
		|| !(isxdigit(*(s + 1)) && isxdigit(*(s + 2)))) {
d70 5
a74 1
 * Quote the path to make it safe for shell command processing.
d76 1
a76 1
char *quote_pathname(char *pathname)
d78 10
a87 1
    char *result = NULL;
d89 48
a136 4
    if (strchr(pathname, ' ') != NULL) {
	HTSprintf0(&result, "\"%s\"", pathname);
    } else {
	StrAllocCopy(result, pathname);
d138 2
d167 2
a168 7
    if (*param != '"' && strchr(param, ' ') != NULL) {
	char *cp = quote_pathname(param);

	format(&cmdbuf, command, cp);
	FREE(cp);
    } else {
	char pram_string[LY_MAXPATH];
d170 4
a173 1
	LYstrncpy(pram_string, param, sizeof(pram_string) - 1);
d176 5
d182 26
a207 25
	if (isMAILTO_URL(param)) {
	    format(&cmdbuf, command, param + 7);
	} else if (strnicmp("telnet://", param, 9) == 0) {
	    char host[sizeof(pram_string)];
	    int last_pos;

	    strcpy(host, param + 9);
	    last_pos = strlen(host) - 1;
	    if (last_pos > 1 && host[last_pos] == '/')
		host[last_pos] = '\0';

	    format(&cmdbuf, command, host);
	} else if (strnicmp("file://localhost/", param, 17) == 0) {
	    char e_buff[LY_MAXPATH], *p;

	    p = param + 17;
	    *e_buff = 0;
	    if (strchr(p, ':') == NULL) {
		sprintf(e_buff, "%.3s/", windows_drive);
	    }
	    strncat(e_buff, p, sizeof(e_buff) - strlen(e_buff) - 1);
	    p = strrchr(e_buff, '.');
	    if (p) {
		trimPoundSelector(p);
	    }
d209 9
a217 14
	    /* Less ==> short filename with backslashes,
	     * less ==> long filename with forward slashes, may be quoted
	     */
	    if (ISUPPER(command[0])) {
		format(&cmdbuf,
		       command, HTDOS_short_name(e_buff));
	    } else {
		if (*e_buff != '"' && strchr(e_buff, ' ') != NULL) {
		    p = quote_pathname(e_buff);
		    LYstrncpy(e_buff, p, sizeof(e_buff) - 1);
		    FREE(p);
		}
		format(&cmdbuf, command, e_buff);
	    }
d219 3
a221 1
	    format(&cmdbuf, command, param);
d223 2
d226 1
d239 1
a239 1
			     BOOL only_overriders)
d242 1
a242 1
    int length = 0;
d244 1
d264 5
a268 2
			if (length > 1)
			    choices[num_choices] = cmdbuf;
d276 1
d279 1
d295 1
a295 1
				       (const char **) choices,
d299 1
a299 2
				       TRUE,
				       FALSE);
d308 1
a308 1
		cmdbuf = choices[pass];
d310 1
a310 1
		FREE(choices[pass]);
d312 1
d314 1
d321 1
a321 1
		  BOOL only_overriders)
@


1.1.109.1
log
@Lynx 2.8.6dev.11h (pre-patch) minus
* lib
* po
* scripts
@
text
@@


1.1.109.2
log
@Import new Standard Webbrowser
Sorry, but I've waited for it.
@
text
@a68 2
 *  We always quote it not only includes spaces in it.
 *  At least we should quote paths which include "&".
d74 4
a77 72
    HTSprintf0(&result, "\"%s\"", pathname);
    return result;
}

/*
 *  Delete dangerous characters as local path.
 *  We delete '<>|' and also '%"'.
 *  '%' should be deleted because it's difficut to escape for all cases.
 *  So we can't treat paths which include '%'.
 *  '"' should be deleted because it's a obstacle to quote whole path.
 */
static void delete_danger_characters(char *src)
{
    char *dst;

    for (dst = src; *src != '\0'; src++) {
	if (strchr("<>|%\"", *src) == NULL) {
	    *dst = *src;
	    dst++;
	}
    }
    *dst = '\0';
}

static char *escapeParameter(CONST char *parameter)
{
    size_t i;
    size_t last = strlen(parameter);
    size_t n = 0;
    size_t encoded = 0;
    size_t escaped = 0;
    char *result;
    char *needs_encoded = "<>|";
    char *needs_escaped = "%";
    char *needs_escaped_NT = "%&^";

    for (i = 0; i < last; ++i) {
	if (strchr(needs_encoded, parameter[i]) != NULL) {
	    ++encoded;
	}
	if (system_is_NT) {
	    if (strchr(needs_escaped_NT, parameter[i]) != NULL) {
		++escaped;
	    }
	} else if (strchr(needs_escaped, parameter[i]) != NULL) {
	    ++escaped;
	}
    }

    result = (char *) malloc(last + encoded * 2 + escaped + 1);
    if (result == NULL)
	outofmem(__FILE__, "escapeParameter");

    n = 0;
    for (i = 0; i < last; i++) {
	if (strchr(needs_encoded, parameter[i]) != NULL) {
	    sprintf(result + n, "%%%02X", (unsigned char) parameter[i]);
	    n += 3;
	    continue;
	}
	if (system_is_NT) {
	    if (strchr(needs_escaped_NT, parameter[i]) != NULL) {
		result[n++] = '^';
		result[n++] = parameter[i];
		continue;
	    }
	} else if (strchr(needs_escaped, parameter[i]) != NULL) {
	    result[n++] = '%';	/* parameter[i] is '%' */
	    result[n++] = parameter[i];
	    continue;
	}
	result[n++] = parameter[i];
a78 2
    result[n] = '\0';

d106 7
a112 2
    char pram_string[LY_MAXPATH];
    char *escaped = NULL;
a113 3
    if (strnicmp("file://localhost/", param, 17) == 0) {
	/* decode local path parameter for programs to be
	   able to interpret - TH */
a116 5
    } else {
	/* encode or escape URL parameter - TH */
	escaped = escapeParameter(param);
	param = escaped;
    }
d118 25
a142 26
    if (isMAILTO_URL(param)) {
	format(&cmdbuf, command, param + 7);
    } else if (strnicmp("telnet://", param, 9) == 0) {
	char host[sizeof(pram_string)];
	int last_pos;

	LYstrncpy(host, param + 9, sizeof(host));
	last_pos = strlen(host) - 1;
	if (last_pos > 1 && host[last_pos] == '/')
	    host[last_pos] = '\0';

	format(&cmdbuf, command, host);
    } else if (strnicmp("file://localhost/", param, 17) == 0) {
	char e_buff[LY_MAXPATH], *p;

	p = param + 17;
	delete_danger_characters(p);
	*e_buff = 0;
	if (strchr(p, ':') == NULL) {
	    sprintf(e_buff, "%.3s/", windows_drive);
	}
	strncat(e_buff, p, sizeof(e_buff) - strlen(e_buff) - 1);
	p = strrchr(e_buff, '.');
	if (p) {
	    trimPoundSelector(p);
	}
d144 14
a157 9
	/* Less ==> short filename with backslashes,
	 * less ==> long filename with forward slashes, may be quoted
	 */
	if (ISUPPER(command[0])) {
	    char *short_name = HTDOS_short_name(e_buff);

	    p = quote_pathname(short_name);
	    format(&cmdbuf, command, p);
	    FREE(p);
d159 1
a159 3
	    p = quote_pathname(e_buff);
	    format(&cmdbuf, command, p);
	    FREE(p);
a160 2
    } else {
	format(&cmdbuf, command, param);
a161 1
    FREE(escaped);
@


1.1.109.3
log
@Import Lynx 2.8.7dev.7 into base as well
@
text
@a1 2
 * $LynxId: LYExtern.c,v 1.39 2007/07/31 21:30:21 tom Exp $
 *
d305 1
a305 1
				       (BOOLEAN) (keypad_mode != NUMBERS_AS_ARROWS));
@


1.1.109.4
log
@Import Lynx 2.8.7dev.11a via eMail from Tom Dickey:
Message-ID: <20081215010313.GA8373@@invisible-island.net>
Message-ID: <20081216012408.GA15364@@invisible-island.net>
@
text
@d2 1
a2 1
 * $LynxId: LYExtern.c,v 1.40 2008/07/04 15:06:14 tom Exp $
d306 2
a307 1
				       TRUE);
@


1.1.109.5
log
@Import Lynx 2.8.7dev.12
@
text
@d2 1
a2 1
 * $LynxId: LYExtern.c,v 1.41 2008/12/29 01:34:31 tom Exp $
d70 13
@


1.1.109.6
log
@Woohoo, there’s a new Lynx release!
@
text
@d2 1
a2 1
 * $LynxId: LYExtern.c,v 1.42 2009/01/01 22:07:00 tom Exp $
d272 1
a272 1
		choices = typecallocn(char *, (unsigned) length + 1);
@


1.1.109.7
log
@Import lynx-current
@
text
@d2 1
a2 1
 * $LynxId: LYExtern.c,v 1.48 2010/12/11 13:08:13 tom Exp $
d55 1
a55 1
		|| !(isxdigit(UCH(*(s + 1))) && isxdigit(UCH(*(s + 2))))) {
d173 1
a173 1
	LYStrNCpy(pram_string, param, sizeof(pram_string) - 1);
d188 1
a188 1
	LYStrNCpy(host, param + 9, sizeof(host));
d239 1
a239 1
			     int only_overriders)
d242 1
a242 1
    size_t length = 0;
a243 1
    char **actions = 0;
d263 2
a264 5
			if (length > 1) {
			    actions[num_choices] = cmdbuf;
			    choices[num_choices] =
				format_command(ptr->menu_name, param);
			}
d272 1
a272 2
		actions = typecallocn(char *, length + 1);
		choices = typecallocn(char *, length + 1);
a273 1
		actions[num_choices] = 0;
d302 1
a302 1
		cmdbuf = actions[pass];
d304 1
a304 1
		FREE(actions[pass]);
a305 1
	    FREE(choices[pass]);
a306 1
	FREE(actions);
d313 1
a313 1
		  int only_overriders)
@


1.1.109.8
log
@Import Lynx 2.8.8dev.10 plus dev.10a patch from invisible-island plus
fix for “lynx -help” output by KIHARA Hideto, by import-3rdpty,v 1.43
@
text
@d2 1
a2 1
 * $LynxId: LYExtern.c,v 1.49 2012/02/10 18:36:39 tom Exp $
d295 1
a295 1
				       (STRING2PTR) choices,
@


1.1.109.9
log
@lynx2.8.8dev.14
@
text
@d2 1
a2 1
 * $LynxId: LYExtern.c,v 1.50 2012/08/15 23:16:22 tom Exp $
d34 2
a35 2
#define ASC2HEXD(x) ((UCH(x) >= '0' && UCH(x) <= '9') ?               \
		     (UCH(x) - '0') : (toupper(UCH(x)) - 'A' + 10))
@


1.1.109.10
log
@Update to the latest Lynx patchkit
@
text
@d2 1
a2 1
 * $LynxId: LYExtern.c,v 1.52 2013/05/04 13:01:06 tom Exp $
a277 3

		if (actions == 0 || choices == 0)
		    outofmem(__FILE__, "lookup_external");
a313 7
    }

    if (actions) {
	for (pass = 0; actions[pass] != 0; ++pass) {
	    if (actions[pass] != cmdbuf)
		FREE(actions[pass]);
	}
a314 6
    }

    if (choices) {
	for (pass = 0; choices[pass] != 0; ++pass) {
	    FREE(choices[pass]);
	}
a316 1

@


