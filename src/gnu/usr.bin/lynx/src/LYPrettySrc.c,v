head	1.3;
branch	1.1.109;
access;
symbols
	lynx-2_8_8dev_16:1.1.109.6
	lynx-2_8_8dev_15e:1.1.109.6
	lynx-2_8_8dev_15:1.1.109.5
	lynx-2_8_8dev_14:1.1.109.5
	lynx-2_8_8dev_12:1.1.109.5
	lynx-2_8_8dev_11:1.1.109.5
	lynx-2_8_8dev_10a:1.1.109.5
	lynx-2_8_8dev_7a:1.1.109.5
	lynx-2_8_8dev_7:1.1.109.5
	lynx-2_8_7rel_1:1.1.109.4
	lynx-2_8_7dev_12:1.1.109.3
	lynx-2_8_7dev_11a:1.1.109.3
	MIRBSD_10:1.1.109.3.0.2
	MIRBSD_10_BASE:1.1.109.3
	lynx-2_8_7dev_8:1.1.109.3
	lynx-2_8_7dev_7:1.1.109.3
	lynx-2_8_7dev_5:1.1.109.3
	lynx-2_8_7dev_2:1.1.109.3
	lynx-2_8_6pre_5:1.1.109.3
	lynx-2_8_6pre_4:1.1.109.2
	lynx-2_8_6pre_3:1.1.109.2
	MIRBSD_9_BASE:1.1.109.1
	lynx-2_8_6dev_18c:1.1.109.1
	lynx-2_8_6dev_18:1.1.109.1
	MIRBSD_8:1.1.109.1.0.2
	MIRBSD_8_BASE:1.1.109.1
	lynx-2_8_6dev_16:1.1.109.1
	lynx:1.1.109;
locks; strict;
comment	@ * @;


1.3
date	2006.10.02.23.12.21;	author tg;	state Exp;
branches;
next	1.2;
commitid	10045219CDF7E09CCE1;

1.2
date	2006.09.22.02.35.00;	author tg;	state Exp;
branches;
next	1.1;
commitid	10045134BD754BD37C6;

1.1
date	2005.03.27.22.12.13;	author tg;	state Exp;
branches
	1.1.109.1;
next	;

1.1.109.1
date	2005.03.27.22.12.13;	author tg;	state Exp;
branches;
next	1.1.109.2;

1.1.109.2
date	2006.09.13.19.12.11;	author tg;	state Exp;
branches;
next	1.1.109.3;
commitid	100450857B406EB1869;

1.1.109.3
date	2006.10.02.22.56.45;	author tg;	state Exp;
branches;
next	1.1.109.4;
commitid	100452198D23E36C6DC;

1.1.109.4
date	2009.08.09.14.37.53;	author tg;	state Exp;
branches;
next	1.1.109.5;
commitid	1004A7EDF4952738297;

1.1.109.5
date	2010.12.19.18.12.48;	author tg;	state Exp;
branches;
next	1.1.109.6;
commitid	1004D0E4B24304015D1;

1.1.109.6
date	2013.05.18.14.44.03;	author tg;	state Exp;
branches;
next	;
commitid	100519793BB3FCC7E2F;


desc
@@


1.3
log
@fastmerge
@
text
@/* HTML source syntax highlighting
   by Vlad Harchev <hvv@@hippo.ru>
   March 1999
*/
#include <HTUtils.h>
#include <LYHash.h>
#include <LYPrettySrc.h>
#include <LYStrings.h>
#include <LYLeaks.h>

 /* This file creates too many "leak detected" entries in Lynx.leaks. */
#define NO_MEMORY_TRACKING
#include <LYLeaks.h>

#ifdef USE_PRETTYSRC
BOOL psrc_convert_string = FALSE;
BOOL psrc_view = FALSE;		/* this is read by SGML_put_character - TRUE

				   when viewing pretty source */
BOOL LYpsrc = FALSE;		/* this tells what will be shown on '\':

				   if TRUE, then pretty source, normal source view otherwise. Toggled by
				   -prettysrc commandline option.  */
BOOL sgml_in_psrc_was_initialized;
BOOL psrc_nested_call;
BOOL psrc_first_tag;
BOOL mark_htext_as_source = FALSE;

  /* tagspecs from lynx.cfg are read here. After .lss file is read (is with lss
     support), the style cache and markup are created before entering the
     mainloop. */
BOOL psrcview_no_anchor_numbering = FALSE;
static const char *HTL_tagspecs_defaults[HTL_num_lexemes] =
{
 /* these values are defaults. They are also listed in comments of distibution's
    lynx.cfg. */
#ifdef USE_COLOR_STYLE
    "span.htmlsrc_comment:!span",
    "span.htmlsrc_tag:!span",
    "span.htmlsrc_attrib:!span",
    "span.htmlsrc_attrval:!span",
    "span.htmlsrc_abracket:!span",
    "span.htmlsrc_entity:!span",
    "span.htmlsrc_href:!span",
    "span.htmlsrc_entire:!span",
    "span.htmlsrc_badseq:!span",
    "span.htmlsrc_badtag:!span",
    "span.htmlsrc_badattr:!span",
    "span.htmlsrc_sgmlspecial:!span"
#else
    "b:!b",			/* comment */
    "b:!b",			/* tag     */
    "b:!b",			/* attrib  */
    ":",			/* attrval */
    "b:!b",			/* abracket */
    "b:!b",			/* entity  */
    ":",			/* href    */
    ":",			/* entire  */
    "b:!b",			/* badseq  */
    ":",			/* badtag  */
    ":",			/* badattr */
    "b:!b"			/* sgmlspec */
#endif
};

char *HTL_tagspecs[HTL_num_lexemes];

 /* these are pointers since tagspec can be empty (the pointer will be NULL
    in that case) */
HT_tagspec *lexeme_start[HTL_num_lexemes];
HT_tagspec *lexeme_end[HTL_num_lexemes];

int tagname_transform = 2;
int attrname_transform = 2;

static int html_src_tag_index(char *tagname)
{
    HTTag *tag = SGMLFindTag(&HTML_dtd, tagname);

    return (tag && tag != &HTTag_unrecognized) ? tag - HTML_dtd.tags : -1;
}

typedef enum {
    HTSRC_CK_normal,
    HTSRC_CK_seen_excl,
    HTSRC_CK_after_tagname,
    HTSRC_CK_seen_dot
} html_src_check_state;

static void append_close_tag(char *tagname,
			     HT_tagspec ** head,
			     HT_tagspec ** tail)
{
    int idx, nattr;
    HTTag *tag;
    HT_tagspec *subj;

    idx = html_src_tag_index(tagname);
    tag = HTML_dtd.tags + idx;
    nattr = tag->number_of_attributes;

    if (idx == -1) {
	fprintf(stderr,
		"internal error: previous check didn't find bad HTML tag %s", tagname);
	exit_immediately(EXIT_FAILURE);
    }

    subj = typecalloc(HT_tagspec);
    subj->element = (HTMLElement) idx;
    subj->present = typecallocn(BOOL, nattr);
    subj->value = typecallocn(char *, nattr);

    subj->start = FALSE;
#ifdef USE_COLOR_STYLE
    subj->class_name = NULL;
#endif

    if (!*head) {
	*head = subj;
	*tail = subj;
    } else {
	(*tail)->next = subj;
	*tail = subj;
    }
}

/* this will allocate node, initialize all members, and node
   append to the list, possibly modifying head and modifying tail */
static void append_open_tag(char *tagname,
			    char *classname GCC_UNUSED,
			    HT_tagspec ** head,
			    HT_tagspec ** tail)
{
    HT_tagspec *subj;
    HTTag *tag;

#ifdef USE_COLOR_STYLE
    int hcode;
#endif

    append_close_tag(tagname, head, tail);	/* initialize common members */
    subj = *tail;
    subj->start = TRUE;

    tag = HTML_dtd.tags + subj->element;

#ifdef USE_COLOR_STYLE
    hcode = hash_code_lowercase_on_fly(tagname);
    if (non_empty(classname)) {

#  if 0
	/*
	 * we don't provide a classname as attribute of that tag, since for
	 * plain formatting tags they are not used directly for anything except
	 * style - and we provide style value directly.
	 */
	int class_attr_idx = 0;
	int n = tag->number_of_attributes;
	attr *attrs = tag->attributes;

/*.... *//* this is not implemented though it's easy */
#  endif

	hcode = hash_code_aggregate_char('.', hcode);
	hcode = hash_code_aggregate_lower_str(classname, hcode);
	StrAllocCopy(subj->class_name, classname);
    } else {
	StrAllocCopy(subj->class_name, "");
    }
    subj->style = hcode;
#endif
}

#define isLeadP(p) ((isalpha(UCH(*p)) || *p == '_'))
#define isNextP(p) ((isalnum(UCH(*p)) || *p == '_'))

#define FMT_AT " at column %d:\n\t%s\n"
#define TXT_AT (int) (1 + p - ts), ts

/* returns FALSE if incorrect */
int html_src_parse_tagspec(char *ts,
			   HTlexeme lexeme,
			   BOOL checkonly,
			   BOOL isstart)
{
    BOOL stop = FALSE;
    BOOL code = FALSE;
    char *p = ts;
    char *tagstart = 0;
    char *tagend = 0;
    char *classstart;
    char *classend;
    char save, save1;
    char after_excl = FALSE;
    html_src_check_state state = HTSRC_CK_normal;
    HT_tagspec *head = NULL;
    HT_tagspec *tail = NULL;
    HT_tagspec **slot = (isstart ? lexeme_start : lexeme_end) + lexeme;

    while (!stop) {
	switch (state) {
	case HTSRC_CK_normal:
	case HTSRC_CK_seen_excl:
	    switch (*p) {
	    case '\0':
		stop = TRUE;
		code = TRUE;
		break;
	    case ' ':
	    case '\t':
		break;
	    case '!':
		if (state == HTSRC_CK_seen_excl) {
		    CTRACE2(TRACE_CFG,
			    (tfp, "second '!'" FMT_AT,
			     TXT_AT));
		    stop = TRUE;
		    break;
		}
		state = HTSRC_CK_seen_excl;
		after_excl = TRUE;
		break;
	    default:
		if (!isLeadP(p)) {
		    CTRACE2(TRACE_CFG,
			    (tfp, "no name starting" FMT_AT,
			     TXT_AT));
		    stop = TRUE;
		    break;
		}
		tagstart = p;
		while (*p && isNextP(p))
		    ++p;
		tagend = p--;
		state = HTSRC_CK_after_tagname;
	    }
	    break;
	case HTSRC_CK_after_tagname:
	    switch (*p) {
	    case '\0':
		stop = TRUE;
		code = TRUE;
		/* FALLTHRU */
	    case ' ':
		/* FALLTHRU */
	    case '\t':
		save = *tagend;

		*tagend = '\0';
		classstart = 0;
		if (checkonly) {
		    int idx = html_src_tag_index(tagstart);

		    CTRACE2(TRACE_CFG,
			    (tfp, "tag index(%s) = %d\n",
			     tagstart, idx));

		    *tagend = save;
		    if (idx == -1) {
			stop = TRUE;
			break;
		    }
		} else {
		    if (after_excl)
			append_close_tag(tagstart, &head, &tail);
		    else
			append_open_tag(tagstart, NULL, &head, &tail);
		}
		state = HTSRC_CK_normal;
		after_excl = FALSE;
		break;
	    case '.':
		if (after_excl) {
		    CTRACE2(TRACE_CFG,
			    (tfp, "dot after '!'" FMT_AT,
			     TXT_AT));
		    stop = TRUE;
		    break;
		}
		state = HTSRC_CK_seen_dot;
		break;
	    default:
		CTRACE2(TRACE_CFG,
			(tfp, "unexpected char '%c' after tagname" FMT_AT,
			 *p, TXT_AT));
		stop = TRUE;
		break;
	    }
	    break;
	case HTSRC_CK_seen_dot:
	    switch (*p) {
	    case ' ':
	    case '\t':
		break;
	    case '\0':
		CTRACE2(TRACE_CFG,
			(tfp, "expected text after dot" FMT_AT,
			 TXT_AT));
		stop = TRUE;
		break;
	    default:
		if (!isLeadP(p)) {
		    CTRACE2(TRACE_CFG,
			    (tfp, "no name starting" FMT_AT,
			     TXT_AT));
		    stop = TRUE;
		    break;
		}
		classstart = p;
		while (*p && isNextP(p))
		    ++p;
		classend = p--;
		save = *classend;
		*classend = '\0';
		save1 = *tagend;
		*tagend = '\0';
		if (checkonly) {
		    int idx = html_src_tag_index(tagstart);

		    *tagend = save1;
		    *classend = save;
		    if (idx == -1)
			return FALSE;
		} else {
		    append_open_tag(tagstart, classstart, &head, &tail);
		}
		state = HTSRC_CK_normal;
		after_excl = FALSE;
		break;
	    }			/* of switch(*p) */
	    break;
	}			/* of switch */
	++p;
    }

    if (code && !checkonly)
	*slot = head;

    return code;
}

/*this will clean the data associated with lexeme 'l' */
void html_src_clean_item(HTlexeme l)
{
    int i;

    if (HTL_tagspecs[l])
	FREE(HTL_tagspecs[l]);
    for (i = 0; i < 2; ++i) {
	HT_tagspec *cur;
	HT_tagspec **pts = (i ? lexeme_start : lexeme_end) + l;
	HT_tagspec *ts = *pts;

	*pts = NULL;
	while (ts) {
	    FREE(ts->present);
	    FREE(ts->value);
#ifdef USE_COLOR_STYLE
	    if (ts->start) {
		FREE(ts->class_name);
	    }
#endif
	    cur = ts;
	    ts = ts->next;
	    FREE(cur);
	}
    }
}

/*this will be registered with atexit*/
void html_src_clean_data(void)
{
    int i;

    for (i = 0; i < HTL_num_lexemes; ++i)
	html_src_clean_item((HTlexeme) i);
}

void html_src_on_lynxcfg_reload(void)
{
    html_src_clean_data();
    HTMLSRC_init_caches(TRUE);
}

static void failed_init(const char *tag, int lexeme)
{
    fprintf(stderr,
	    gettext("parse-error while caching %s tagspec of lexeme %d\n"),
	    tag, lexeme);
    fprintf(stderr,
	    gettext("Use -trace -trace-mask=8 to see details in log.\n"));
    exit_immediately(EXIT_FAILURE);
}

void HTMLSRC_init_caches(BOOL dont_exit)
{
    int i;
    char *p;
    char buf[1000];

    CTRACE2(TRACE_CFG, (tfp, "HTMLSRC_init_caches(%d tagspecs)\n", HTL_num_lexemes));
    for (i = 0; i < HTL_num_lexemes; ++i) {
	/*we assume that HT_tagspecs was NULLs at when program started */
	LYstrncpy(buf,
		  HTL_tagspecs[i]
		  ? HTL_tagspecs[i]
		  : HTL_tagspecs_defaults[i],
		  sizeof(buf) - 1);
	StrAllocCopy(HTL_tagspecs[i], buf);

	CTRACE2(TRACE_CFG, (tfp, "parsing lexeme %d: %s\n", i + 1, buf));

	if ((p = strchr(buf, ':')) != 0)
	    *p = '\0';
	if (!html_src_parse_tagspec(buf,
				    (HTlexeme) i,
				    FALSE,
				    TRUE) && !dont_exit) {
	    failed_init("1st", i);
	}
	if (!html_src_parse_tagspec(p ? p + 1 : NULL,
				    (HTlexeme) i,
				    FALSE,
				    FALSE) && !dont_exit) {
	    failed_init("2nd", i);
	}
    }
}

#endif /* ifdef USE_PRETTYSRC */
@


1.2
log
@really fix that ptrdiff_t fallout this time
(doesn't this stuff do depends, TD?)
@
text
@d177 2
a178 2
#define FMT_AT " at column %ld:\n\t%s\n"
#define TXT_AT (1 + p - ts), ts
@


1.1
log
@Initial revision
@
text
@d153 3
a155 3
	 * we don't provide a classname as attribute of that tag, since for plain
	 * formatting tags they are not used directly for anything except style -
	 * and we provide style value directly.
d174 7
a180 1
/* returns 1 if incorrect */
d186 2
d193 2
a194 1
    char stop = FALSE, after_excl = FALSE;
d196 2
a197 1
    HT_tagspec *head = NULL, *tail = NULL;
d207 1
d213 7
a219 2
		if (state == HTSRC_CK_seen_excl)
		    return 1;	/*second '!' */
d224 12
a235 9
		if (isalpha(UCH(*p)) || *p == '_') {
		    tagstart = p;
		    while (*p && (isalnum(UCH(*p)) || *p == '_'))
			++p;
		    tagend = p;
		    state = HTSRC_CK_after_tagname;
		} else
		    return 1;
		continue;
d242 1
d247 1
a247 2
		{
		    char save = *tagend;
d249 13
a261 13
		    *tagend = '\0';
		    classstart = 0;
		    if (checkonly) {
			int idx = html_src_tag_index(tagstart);

			*tagend = save;
			if (idx == -1)
			    return 1;
		    } else {
			if (after_excl)
			    append_close_tag(tagstart, &head, &tail);
			else
			    append_open_tag(tagstart, NULL, &head, &tail);
d263 5
a267 2
		    state = HTSRC_CK_normal;
		    after_excl = FALSE;
d269 2
d273 7
a279 2
		if (after_excl)
		    return 1;
d283 5
a287 1
		return 1;
d290 17
a306 4
	case HTSRC_CK_seen_dot:{
		switch (*p) {
		case ' ':
		case '\t':
d308 21
a328 31
		case '\0':
		    return 1;
		default:{
			char save, save1;

			if (isalpha(UCH(*p)) || *p == '_') {
			    classstart = p;
			    while (*p && (isalnum(UCH(*p)) || *p == '_'))
				++p;
			    classend = p;
			    save = *classend;
			    *classend = '\0';
			    save1 = *tagend;
			    *tagend = '\0';
			    if (checkonly) {
				int idx = html_src_tag_index(tagstart);

				*tagend = save1;
				*classend = save;
				if (idx == -1)
				    return 1;
			    } else {
				append_open_tag(tagstart, classstart, &head, &tail);
			    }
			    state = HTSRC_CK_normal;
			    after_excl = FALSE;
			    continue;
			} else
			    return 1;
		    }
		}		/*of switch(*p) */
d330 2
a331 1
	    }			/* of case HTSRC_CK_seen_dot: */
d336 1
a336 1
    if (!checkonly)
d338 2
a339 1
    return 0;
d385 10
d401 1
d411 2
d415 5
a419 4
	if (html_src_parse_tagspec(buf, (HTlexeme) i, FALSE, TRUE) && !dont_exit) {
	    fprintf(stderr,
		    "internal error while caching 1st tagspec of %d lexeme", i);
	    exit_immediately(EXIT_FAILURE);
d421 5
a425 5
	if (html_src_parse_tagspec(p ? p + 1 : NULL, (HTlexeme) i, FALSE,
				   FALSE) && !dont_exit) {
	    fprintf(stderr,
		    "internal error while caching 2nd tagspec of %d lexeme", i);
	    exit_immediately(EXIT_FAILURE);
@


1.1.109.1
log
@Lynx 2.8.6dev.11h (pre-patch) minus
* lib
* po
* scripts
@
text
@@


1.1.109.2
log
@Import Lynx 2.8.6pre.3
@
text
@d153 3
a155 3
	 * we don't provide a classname as attribute of that tag, since for
	 * plain formatting tags they are not used directly for anything except
	 * style - and we provide style value directly.
d174 1
a174 7
#define isLeadP(p) ((isalpha(UCH(*p)) || *p == '_'))
#define isNextP(p) ((isalnum(UCH(*p)) || *p == '_'))

#define FMT_AT " at column %d:\n\t%s\n"
#define TXT_AT (1 + p - ts), ts

/* returns FALSE if incorrect */
a179 2
    BOOL stop = FALSE;
    BOOL code = FALSE;
d185 1
a185 2
    char save, save1;
    char after_excl = FALSE;
d187 1
a187 2
    HT_tagspec *head = NULL;
    HT_tagspec *tail = NULL;
a196 1
		code = TRUE;
d202 2
a203 7
		if (state == HTSRC_CK_seen_excl) {
		    CTRACE2(TRACE_CFG,
			    (tfp, "second '!'" FMT_AT,
			     TXT_AT));
		    stop = TRUE;
		    break;
		}
d208 9
a216 12
		if (!isLeadP(p)) {
		    CTRACE2(TRACE_CFG,
			    (tfp, "no name starting" FMT_AT,
			     TXT_AT));
		    stop = TRUE;
		    break;
		}
		tagstart = p;
		while (*p && isNextP(p))
		    ++p;
		tagend = p--;
		state = HTSRC_CK_after_tagname;
a222 1
		code = TRUE;
d227 2
a228 1
		save = *tagend;
d230 13
a242 13
		*tagend = '\0';
		classstart = 0;
		if (checkonly) {
		    int idx = html_src_tag_index(tagstart);

		    CTRACE2(TRACE_CFG,
			    (tfp, "tag index(%s) = %d\n",
			     tagstart, idx));

		    *tagend = save;
		    if (idx == -1) {
			stop = TRUE;
			break;
d244 2
a245 5
		} else {
		    if (after_excl)
			append_close_tag(tagstart, &head, &tail);
		    else
			append_open_tag(tagstart, NULL, &head, &tail);
a246 2
		state = HTSRC_CK_normal;
		after_excl = FALSE;
d249 2
a250 7
		if (after_excl) {
		    CTRACE2(TRACE_CFG,
			    (tfp, "dot after '!'" FMT_AT,
			     TXT_AT));
		    stop = TRUE;
		    break;
		}
d254 1
a254 5
		CTRACE2(TRACE_CFG,
			(tfp, "unexpected char '%c' after tagname" FMT_AT,
			 *p, TXT_AT));
		stop = TRUE;
		break;
d257 4
a260 17
	case HTSRC_CK_seen_dot:
	    switch (*p) {
	    case ' ':
	    case '\t':
		break;
	    case '\0':
		CTRACE2(TRACE_CFG,
			(tfp, "expected text after dot" FMT_AT,
			 TXT_AT));
		stop = TRUE;
		break;
	    default:
		if (!isLeadP(p)) {
		    CTRACE2(TRACE_CFG,
			    (tfp, "no name starting" FMT_AT,
			     TXT_AT));
		    stop = TRUE;
d262 31
a292 21
		}
		classstart = p;
		while (*p && isNextP(p))
		    ++p;
		classend = p--;
		save = *classend;
		*classend = '\0';
		save1 = *tagend;
		*tagend = '\0';
		if (checkonly) {
		    int idx = html_src_tag_index(tagstart);

		    *tagend = save1;
		    *classend = save;
		    if (idx == -1)
			return FALSE;
		} else {
		    append_open_tag(tagstart, classstart, &head, &tail);
		}
		state = HTSRC_CK_normal;
		after_excl = FALSE;
d294 1
a294 2
	    }			/* of switch(*p) */
	    break;
d299 1
a299 1
    if (code && !checkonly)
d301 1
a301 2

    return code;
a346 10
static void failed_init(const char *tag, int lexeme)
{
    fprintf(stderr,
	    gettext("parse-error while caching %s tagspec of lexeme %d\n"),
	    tag, lexeme);
    fprintf(stderr,
	    gettext("Use -trace -trace-mask=8 to see details in log.\n"));
    exit_immediately(EXIT_FAILURE);
}

a352 1
    CTRACE2(TRACE_CFG, (tfp, "HTMLSRC_init_caches(%d tagspecs)\n", HTL_num_lexemes));
a361 2
	CTRACE2(TRACE_CFG, (tfp, "parsing lexeme %d: %s\n", i + 1, buf));

d364 4
a367 5
	if (!html_src_parse_tagspec(buf,
				    (HTlexeme) i,
				    FALSE,
				    TRUE) && !dont_exit) {
	    failed_init("1st", i);
d369 5
a373 5
	if (!html_src_parse_tagspec(p ? p + 1 : NULL,
				    (HTlexeme) i,
				    FALSE,
				    FALSE) && !dont_exit) {
	    failed_init("2nd", i);
@


1.1.109.3
log
@Update to lynx 2.8.6pre.5
This is a required update, because earlier versions contain some
non-free, non-redistributable files!
@
text
@d178 1
a178 1
#define TXT_AT (int) (1 + p - ts), ts
@


1.1.109.4
log
@Woohoo, there’s a new Lynx release!
@
text
@d1 4
a4 7
/*
 * $LynxId: LYPrettySrc.c,v 1.20 2009/03/11 00:30:39 tom Exp $
 *
 * HTML source syntax highlighting
 * by Vlad Harchev <hvv@@hippo.ru>
 * March 1999
 */
d20 1
a20 1
BOOLEAN LYpsrc = FALSE;		/* this tells what will be shown on '\':
d32 1
a32 1
BOOLEAN psrcview_no_anchor_numbering = FALSE;
d110 2
a111 2
    subj->present = typecallocn(BOOL, (unsigned) nattr);
    subj->value = typecallocn(char *, (unsigned) nattr);
@


1.1.109.5
log
@Import lynx-current
@
text
@d2 1
a2 1
 * $LynxId: LYPrettySrc.c,v 1.25 2010/10/27 00:15:12 tom Exp $
d83 1
a83 1
    return (tag && tag != &HTTag_unrecognized) ? (int) (tag - HTML_dtd.tags) : -1;
d138 1
d148 2
a159 1
	HTTag *tag = HTML_dtd.tags + subj->element;
d164 1
a164 2
/*.... */
/* this is not implemented though it's easy */
d186 2
a187 2
			   int checkonly,
			   int isstart)
d398 1
a398 1
void HTMLSRC_init_caches(int dont_exit)
d407 1
a407 1
	LYStrNCpy(buf,
@


1.1.109.6
log
@Update to the latest Lynx patchkit
@
text
@d2 1
a2 1
 * $LynxId: LYPrettySrc.c,v 1.28 2013/05/06 00:53:30 tom Exp $
a111 3
    if (subj == 0)
	outofmem(__FILE__, "append_close_tag");

a112 1

a113 4

    if (subj->present == 0)
	outofmem(__FILE__, "append_close_tag");

a115 3
    if (subj->value == 0)
	outofmem(__FILE__, "append_close_tag");

a401 1
    static char empty[] = "";
d423 1
a423 1
	if (!html_src_parse_tagspec(p ? p + 1 : empty,
@


