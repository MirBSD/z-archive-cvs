head	1.3;
access;
symbols
	lynx-2_8_8dev_16:1.1.109.13
	lynx-2_8_8dev_15e:1.1.109.12
	lynx-2_8_8dev_15:1.1.109.12
	lynx-2_8_8dev_14:1.1.109.12
	lynx-2_8_8dev_12:1.1.109.12
	lynx-2_8_8dev_11:1.1.109.12
	lynx-2_8_8dev_10a:1.1.109.12
	lynx-2_8_8dev_7a:1.1.109.11
	lynx-2_8_8dev_7:1.1.109.11
	lynx-2_8_7rel_1:1.1.109.10
	lynx-2_8_7dev_12:1.1.109.9
	lynx-2_8_7dev_11a:1.1.109.9
	MIRBSD_10:1.1.109.8.0.2
	MIRBSD_10_BASE:1.1.109.8
	lynx-2_8_7dev_8:1.1.109.8
	lynx-2_8_7dev_7:1.1.109.8
	lynx-2_8_7dev_5:1.1.109.7
	lynx-2_8_7dev_2:1.1.109.6
	lynx-2_8_6pre_5:1.1.109.6
	lynx-2_8_6pre_4:1.1.109.5
	lynx-2_8_6pre_3:1.1.109.4
	MIRBSD_9_BASE:1.1.109.3
	lynx-2_8_6dev_18c:1.1.109.3
	lynx-2_8_6dev_18:1.1.109.2
	MIRBSD_8:1.1.109.2.0.2
	MIRBSD_8_BASE:1.1.109.2
	lynx-2_8_6dev_16:1.1.109.2
	lynx:1.1.109;
locks; strict;
comment	@ * @;


1.3
date	2013.08.06.20.43.07;	author tg;	state Exp;
branches;
next	1.2;
commitid	10052015FDA30F39400;

1.2
date	2012.02.19.19.38.16;	author tg;	state Exp;
branches;
next	1.1;
commitid	1004F414F917991F461;

1.1
date	2005.03.27.22.12.13;	author tg;	state Exp;
branches
	1.1.109.1;
next	;

1.1.109.1
date	2005.03.27.22.12.13;	author tg;	state Exp;
branches;
next	1.1.109.2;

1.1.109.2
date	2005.06.22.11.11.49;	author tg;	state Exp;
branches;
next	1.1.109.3;
commitid	408242b94777c7d4;

1.1.109.3
date	2006.06.15.19.33.43;	author tg;	state Exp;
branches;
next	1.1.109.4;
commitid	1004491B61C19ABA389;

1.1.109.4
date	2006.09.13.19.12.15;	author tg;	state Exp;
branches;
next	1.1.109.5;
commitid	100450857B406EB1869;

1.1.109.5
date	2006.09.20.21.51.45;	author tg;	state Exp;
branches;
next	1.1.109.6;
commitid	1004511B7EF6E3BA055;

1.1.109.6
date	2006.10.02.22.56.50;	author tg;	state Exp;
branches;
next	1.1.109.7;
commitid	100452198D23E36C6DC;

1.1.109.7
date	2007.05.19.22.30.32;	author tg;	state Exp;
branches;
next	1.1.109.8;
commitid	100464F7A1519624932;

1.1.109.8
date	2007.08.03.15.11.39;	author tg;	state Exp;
branches;
next	1.1.109.9;
commitid	10046B3450C0C128495;

1.1.109.9
date	2008.12.16.23.13.12;	author tg;	state Exp;
branches;
next	1.1.109.10;
commitid	100494835F965A87026;

1.1.109.10
date	2009.08.09.14.37.53;	author tg;	state Exp;
branches;
next	1.1.109.11;
commitid	1004A7EDF4952738297;

1.1.109.11
date	2010.12.19.18.12.48;	author tg;	state Exp;
branches;
next	1.1.109.12;
commitid	1004D0E4B24304015D1;

1.1.109.12
date	2012.02.19.18.30.10;	author tg;	state Exp;
branches;
next	1.1.109.13;
commitid	1004F413EF328BF0E26;

1.1.109.13
date	2013.08.06.20.31.37;	author tg;	state Exp;
branches;
next	;
commitid	10052015D37118B3894;


desc
@@


1.3
log
@fastmerge
@
text
@/*
 * $LynxId: LYStyle.c,v 1.73 2013/06/02 19:17:06 tom Exp $
 *
 * character level styles for Lynx
 * (c) 1996 Rob Partington -- donated to the Lyncei (if they want it :-)
 */
#include <HTUtils.h>
#include <HTML.h>
#include <LYGlobalDefs.h>

#include <LYStructs.h>
#include <LYReadCFG.h>
#include <LYCurses.h>
#include <LYCharUtils.h>
#include <LYUtils.h>		/* defines TABLESIZE */
#include <AttrList.h>
#include <SGML.h>
#include <HTMLDTD.h>

/* Hash table definitions */
#include <LYHash.h>
#include <LYStyle.h>

#include <LYexit.h>
#include <LYLeaks.h>
#include <LYStrings.h>
#include <LYHash.h>

#define CTRACE1(p) CTRACE2(TRACE_CFG || TRACE_STYLE, p)

#ifdef USE_COLOR_STYLE

static void style_initialiseHashTable(void);

/* because curses isn't started when we parse the config file, we
 * need to remember the STYLE: lines we encounter and parse them
 * after curses has started
 */
static HTList *lss_styles = NULL;

#define CACHEW 128
#define CACHEH 64

static unsigned *cached_styles_ptr = NULL;
static int cached_styles_rows = 0;
static int cached_styles_cols = 0;

/* stack of attributes during page rendering */
int last_styles[MAX_LAST_STYLES + 1] =
{0};
int last_colorattr_ptr = 0;

bucket hashStyles[CSHASHSIZE];

int cached_tag_styles[HTML_ELEMENTS];
int current_tag_style;
BOOL force_current_tag_style = FALSE;
char *forced_classname;
BOOL force_classname;

/* Remember the hash codes for common elements */
int s_a = NOSTYLE;
int s_aedit = NOSTYLE;
int s_aedit_arr = NOSTYLE;
int s_aedit_pad = NOSTYLE;
int s_aedit_sel = NOSTYLE;
int s_alert = NOSTYLE;
int s_alink = NOSTYLE;
int s_curedit = NOSTYLE;
int s_forw_backw = NOSTYLE;
int s_hot_paste = NOSTYLE;
int s_menu_active = NOSTYLE;
int s_menu_bg = NOSTYLE;
int s_menu_entry = NOSTYLE;
int s_menu_frame = NOSTYLE;
int s_menu_number = NOSTYLE;
int s_menu_sb = NOSTYLE;
int s_normal = NOSTYLE;
int s_prompt_edit = NOSTYLE;
int s_prompt_edit_arr = NOSTYLE;
int s_prompt_edit_pad = NOSTYLE;
int s_prompt_sel = NOSTYLE;
int s_status = NOSTYLE;
int s_title = NOSTYLE;
int s_whereis = NOSTYLE;

#ifdef USE_SCROLLBAR
int s_sb_aa = NOSTYLE;
int s_sb_bar = NOSTYLE;
int s_sb_bg = NOSTYLE;
int s_sb_naa = NOSTYLE;
#endif

/* start somewhere safe */
#define MAX_COLOR 16
static int colorPairs = 0;

#ifdef USE_BLINK
#  define MAX_BLINK	2
#  define M_BLINK	A_BLINK
#else
#  define MAX_BLINK	1
#  define M_BLINK	0
#endif

#define MAX_PAIR 255		/* because our_pairs[] type is unsigned-char */
static unsigned char our_pairs[2]
[MAX_BLINK]
[MAX_COLOR + 1]
[MAX_COLOR + 1];

static bucket *new_bucket(const char *name)
{
    bucket *result = typecalloc(bucket);

    if (!result)
	outofmem(__FILE__, "new_bucket");
    StrAllocCopy(result->name, name);
    return result;
}

#if OMIT_SCN_KEEPING
bucket *special_bucket(void)
{
    return new_bucket("<special>");
}
#endif

bucket *nostyle_bucket(void)
{
    return new_bucket("<NOSTYLE>");
}

static char *TrimLowercase(char *buffer)
{
    LYRemoveBlanks(buffer);
    strtolower(buffer);
    return buffer;
}

/*
 * Parse a string containing a combination of video attributes and color.
 */
static void parse_either(const char *attrs,
			 int dft_color,
			 int *monop,
			 int *colorp)
{
    int value;
    char *temp_attrs = NULL;

    if (StrAllocCopy(temp_attrs, attrs) != NULL) {
	char *to_free = temp_attrs;

	while (*temp_attrs != '\0') {
	    char *next = strchr(temp_attrs, '+');
	    char save = (char) ((next != NULL) ? *next : '\0');

	    if (next == NULL)
		next = temp_attrs + strlen(temp_attrs);

	    if (save != 0)
		*next = '\0';
	    if ((value = string_to_attr(temp_attrs)) != 0)
		*monop |= value;
	    else if (colorp != 0
		     && (value = check_color(temp_attrs, dft_color)) != ERR_COLOR)
		*colorp = value;

	    temp_attrs = next;
	    if (save != '\0')
		*temp_attrs++ = save;
	}
	FREE(to_free);
    }
}

/* icky parsing of the style options */
static void parse_attributes(const char *mono,
			     const char *fg,
			     const char *bg,
			     int style,
			     const char *element)
{
    int mA = A_NORMAL;
    int fA = default_fg;
    int bA = default_bg;
    int cA = A_NORMAL;
    int newstyle = hash_code(element);

    CTRACE2(TRACE_STYLE, (tfp, "CSS(PA):style d=%d / h=%d, e=%s\n",
			  style, newstyle, element));

    parse_either(mono, ERR_COLOR, &mA, (int *) 0);
    parse_either(bg, default_bg, &cA, &bA);
    parse_either(fg, default_fg, &cA, &fA);

    if (style == -1) {		/* default */
	CTRACE2(TRACE_STYLE, (tfp, "CSS(DEF):default_fg=%d, default_bg=%d\n",
			      fA, bA));
	default_fg = fA;
	default_bg = bA;
	default_color_reset = TRUE;
	return;
    }
    if (fA == NO_COLOR) {
	bA = NO_COLOR;
    } else if (COLORS) {
#ifdef USE_BLINK
	if (term_blink_is_boldbg) {
	    if (fA >= COLORS)
		cA = A_BOLD;
	    if (bA >= COLORS)
		cA |= M_BLINK;
	} else
#endif
	if (fA >= COLORS || bA >= COLORS)
	    cA = A_BOLD;
	if (fA >= COLORS)
	    fA %= COLORS;
	if (bA >= COLORS)
	    bA %= COLORS;
    } else {
	cA = A_BOLD;
	fA = NO_COLOR;
	bA = NO_COLOR;
    }

    /*
     * If we have colour, and space to create a new colour attribute,
     * and we have a valid colour description, then add this style
     */
    if (lynx_has_color && colorPairs < COLOR_PAIRS - 1 && fA != NO_COLOR) {
	int curPair = 0;
	int iFg = (1 + (fA >= 0 ? fA : 0));
	int iBg = (1 + (bA >= 0 ? bA : 0));
	int iBold = !!((unsigned) cA & A_BOLD);
	int iBlink = !!((unsigned) cA & M_BLINK);

	CTRACE2(TRACE_STYLE, (tfp, "parse_attributes %d/%d %d/%d %#x\n",
			      fA, default_fg, bA, default_bg, cA));
	if (fA < MAX_COLOR
	    && bA < MAX_COLOR
#ifdef USE_CURSES_PAIR_0
	    && (cA != A_NORMAL || fA != default_fg || bA != default_bg)
#endif
	    && curPair < MAX_PAIR) {
	    if (our_pairs[iBold][iBlink][iFg][iBg] != 0) {
		curPair = our_pairs[iBold][iBlink][iFg][iBg];
	    } else {
		curPair = ++colorPairs;
		init_pair((short) curPair, (short) fA, (short) bA);
		our_pairs[iBold][iBlink][iFg][iBg] = UCH(curPair);
	    }
	}
	CTRACE2(TRACE_STYLE, (tfp, "CSS(CURPAIR):%d\n", curPair));
	if (style < DSTYLE_ELEMENTS)
	    setStyle(style, COLOR_PAIR(curPair) | cA, cA, mA);
	setHashStyle(newstyle, COLOR_PAIR(curPair) | cA, cA, mA, element);
    } else {
	if (lynx_has_color && fA != NO_COLOR) {
	    CTRACE2(TRACE_STYLE,
		    (tfp, "CSS(NC): maximum of %d colorpairs exhausted\n",
		     COLOR_PAIRS - 1));
	}
	/* only mono is set */
	if (style < DSTYLE_ELEMENTS)
	    setStyle(style, -1, -1, mA);
	setHashStyle(newstyle, -1, -1, mA, element);
    }
}

/* parse a style option of the format
 * STYLE:<OBJECT>:FG:BG
 */
static void parse_style(char *param)
{
    /* *INDENT-OFF* */
    static struct {
	const char *name;
	int style;
	int *set_hash;
    } table[] = {
	{ "default",		-1,			0 }, /* default fg/bg */
	{ "alink",		DSTYLE_ALINK,		0 }, /* active link */
	{ "a",			DSTYLE_LINK,		0 }, /* normal link */
	{ "a",			HTML_A,			0 }, /* normal link */
	{ "status",		DSTYLE_STATUS,		0 }, /* status bar */
	{ "label",		DSTYLE_OPTION,		0 }, /* [INLINE]s */
	{ "value",		DSTYLE_VALUE,		0 }, /* [INLINE]s */
	{ "normal",		DSTYLE_NORMAL,		0 },
	{ "candy",		DSTYLE_CANDY,		0 }, /* [INLINE]s */
	{ "whereis",		DSTYLE_WHEREIS,		&s_whereis },
	{ "edit.active.pad",	DSTYLE_ELEMENTS,	&s_aedit_pad },
	{ "edit.active.arrow",	DSTYLE_ELEMENTS,	&s_aedit_arr },
	{ "edit.active.marked",	DSTYLE_ELEMENTS,	&s_aedit_sel },
	{ "edit.active",	DSTYLE_ELEMENTS,	&s_aedit },
	{ "edit.current",	DSTYLE_ELEMENTS,	&s_curedit },
	{ "edit.prompt.pad",	DSTYLE_ELEMENTS,	&s_prompt_edit_pad },
	{ "edit.prompt.arrow",	DSTYLE_ELEMENTS,	&s_prompt_edit_arr },
	{ "edit.prompt.marked",	DSTYLE_ELEMENTS,	&s_prompt_sel },
	{ "edit.prompt",	DSTYLE_ELEMENTS,	&s_prompt_edit },
	{ "forwbackw.arrow",	DSTYLE_ELEMENTS,	&s_forw_backw },
	{ "hot.paste",		DSTYLE_ELEMENTS,	&s_hot_paste },
	{ "menu.frame",		DSTYLE_ELEMENTS,	&s_menu_frame },
	{ "menu.bg",		DSTYLE_ELEMENTS,	&s_menu_bg },
	{ "menu.n",		DSTYLE_ELEMENTS,	&s_menu_number },
	{ "menu.entry",		DSTYLE_ELEMENTS,	&s_menu_entry },
	{ "menu.active",	DSTYLE_ELEMENTS,	&s_menu_active },
	{ "menu.sb",		DSTYLE_ELEMENTS,	&s_menu_sb },
    };
    /* *INDENT-ON* */

    unsigned n;
    BOOL found = FALSE;

    char *buffer = 0;
    char *tmp = 0;
    char *element, *mono;
    const char *fg, *bg;

    if (param == 0)
	return;
    CTRACE2(TRACE_STYLE, (tfp, "parse_style(%s)\n", param));
    StrAllocCopy(buffer, param);
    if (buffer == 0)
	return;

    TrimLowercase(buffer);
    if ((tmp = strchr(buffer, ':')) == 0) {
	fprintf(stderr, gettext("\
Syntax Error parsing style in lss file:\n\
[%s]\n\
The line must be of the form:\n\
OBJECT:MONO:COLOR (ie em:bold:brightblue:white)\n\
where OBJECT is one of EM,STRONG,B,I,U,BLINK etc.\n\n"), buffer);
	exit_immediately(EXIT_FAILURE);
    }
    *tmp = '\0';
    element = buffer;

    mono = tmp + 1;
    tmp = strchr(mono, ':');

    if (!tmp) {
	fg = "nocolor";
	bg = "nocolor";
    } else {
	*tmp = '\0';
	fg = tmp + 1;
	tmp = strchr(fg, ':');
	if (!tmp)
	    bg = "default";
	else {
	    *tmp = '\0';
	    bg = tmp + 1;
	}
    }

    CTRACE2(TRACE_STYLE, (tfp, "CSSPARSE:%s => %d %s\n",
			  element, hash_code(element),
			  (hashStyles[hash_code(element)].name ? "used" : "")));

    /*
     * We use some pseudo-elements, so catch these first
     */
    for (n = 0; n < TABLESIZE(table); n++) {
	if (!strcasecomp(element, table[n].name)) {
	    parse_attributes(mono, fg, bg, table[n].style, table[n].name);
	    if (table[n].set_hash != 0)
		*(table[n].set_hash) = hash_code(table[n].name);
	    found = TRUE;
	    break;
	}
    }

    if (found) {
	if (!strcasecomp(element, "normal")) {
	    /* added - kw */
	    parse_attributes(mono, fg, bg, DSTYLE_NORMAL, "html");
	    s_normal = hash_code("html");	/* rather bizarre... - kw */

	    LYnormalColor();
	}
    } else {
	/* It must be a HTML element, so look through the list until we find it. */
	int element_number = -1;
	HTTag *t = SGMLFindTag(&HTML_dtd, element);

	if (t && t->name) {
	    element_number = (int) (t - HTML_dtd.tags);
	}
	if (element_number >= HTML_A &&
	    element_number < HTML_ELEMENTS) {
	    parse_attributes(mono, fg, bg, element_number + STARTAT, element);
	} else {
	    parse_attributes(mono, fg, bg, DSTYLE_ELEMENTS, element);
	}
    }
    FREE(buffer);
}

static void style_deleteStyleList(void)
{
    LYFreeStringList(lss_styles);
    lss_styles = NULL;
}

static void free_colorstylestuff(void)
{
    style_initialiseHashTable();
    style_deleteStyleList();
    memset(our_pairs, 0, sizeof(our_pairs));
    FreeCachedStyles();
}

/*
 * Initialise the default style sheet to match the vanilla-curses lynx.
 */
static void initialise_default_stylesheet(void)
{
    /* Use the data setup in USE_COLOR_TABLE */
    /* *INDENT-OFF* */
    static const struct {
	int		color;	/* index into lynx_color_pairs[] */
	const char	*type;
    } table2[] = {
	/*
	 * non-color-style colors encode bold/reverse/underline as a 0-7
	 * index like this:
	 *  b,r,u 0
	 *  b,r,U 1
	 *  b,R,u 2
	 *  b,R,U 3
	 *  B,r,u 4
	 *  B,r,U 5
	 *  B,R,u 6
	 *  B,R,U 7
	 */
	{ 0,	"normal" },
	{ 1,	"a" },
	{ 2,	"status" },
	{ 4,	"b" },
	{ 4,	"blink" },
	{ 4,	"cite" },
	{ 4,	"del" },
	{ 4,	"em" },
	{ 4,	"i" },
	{ 4,	"ins" },
	{ 4,	"strike" },
	{ 4,	"strong" },
	{ 4,	"u" },
#if 0
	{ 5,	"a.b" },
	{ 5,	"b.a" },
	{ 5,	"var.a" },
#endif
	{ 6,	"alink" },
	{ 7,	"whereis" },
#if 0
	{ 0,	"h2.link" },
	{ 0,	"link.h2" },
#endif
#ifdef USE_PRETTYSRC
	/* FIXME: HTL_tagspecs_defaults[] has similar info */
	{ 4,	"span.htmlsrc_comment" },
	{ 4,	"span.htmlsrc_tag" },
	{ 4,	"span.htmlsrc_attrib" },
	{ 4,	"span.htmlsrc_attrval" },
	{ 4,	"span.htmlsrc_abracket" },
	{ 4,	"span.htmlsrc_entity" },
	{ 4,	"span.htmlsrc_href" },
	{ 4,	"span.htmlsrc_entire" },
	{ 4,	"span.htmlsrc_badseq" },
	{ 4,	"span.htmlsrc_badtag" },
	{ 4,	"span.htmlsrc_badattr" },
	{ 4,	"span.htmlsrc_sgmlspecial" },
#endif
    };
    /* *INDENT-ON* */

    unsigned n;
    char *normal = LYgetTableString(0);
    char *strong = LYgetTableString(4);

    CTRACE1((tfp, "initialise_default_stylesheet\n"));

    /*
     * For debugging this function, create hash codes for all of the tags.
     * That makes it simpler to find the cases that are overlooked in the
     * table.
     */
    for (n = 0; n < (unsigned) HTML_dtd.number_of_tags; ++n) {
	char *name = 0;

	HTSprintf0(&name, "%s:%s", HTML_dtd.tags[n].name, normal);
	parse_style(name);
	FREE(name);
    }

    for (n = 0; n < TABLESIZE(table2); ++n) {
	int code = table2[n].color;
	char *name = 0;
	char *value = 0;

	switch (code) {
	case 0:
	    value = normal;
	    break;
	case 4:
	    value = strong;
	    break;
	default:
	    value = LYgetTableString(code);
	    break;
	}
	HTSprintf0(&name, "%s:%s", table2[n].type, value);
	parse_style(name);
	FREE(name);
	if (value != normal && value != strong && value != 0)
	    free(value);
    }
    FREE(normal);
    FREE(strong);
}

/* Set all the buckets in the hash table to be empty */
static void style_initialiseHashTable(void)
{
    int i;
    static int firsttime = 1;

    for (i = 0; i < CSHASHSIZE; i++) {
	if (firsttime)
	    hashStyles[i].name = NULL;
	else
	    FREE(hashStyles[i].name);
	hashStyles[i].color = 0;
	hashStyles[i].cattr = 0;
	hashStyles[i].mono = 0;
    }
    if (firsttime) {
	firsttime = 0;
#ifdef LY_FIND_LEAKS
	atexit(free_colorstylestuff);
#endif
    }
    s_alink = hash_code("alink");
    s_a = hash_code("a");
    s_status = hash_code("status");
    s_alert = hash_code("alert");
    s_title = hash_code("title");
#ifdef USE_SCROLLBAR
    s_sb_bar = hash_code("scroll.bar");
    s_sb_bg = hash_code("scroll.back");
    s_sb_aa = hash_code("scroll.arrow");
    s_sb_naa = hash_code("scroll.noarrow");
#endif
}

void parse_userstyles(void)
{
    char *name;
    HTList *cur = LYuse_color_style ? lss_styles : 0;

    colorPairs = 0;
    style_initialiseHashTable();

    if (HTList_isEmpty(cur)) {
	initialise_default_stylesheet();
    } else {
	while ((name = (char *) HTList_nextObject(cur)) != NULL) {
	    CTRACE2(TRACE_STYLE, (tfp, "LSS:%s\n",
				  (name
				   ? name
				   : "!?! empty !?!")));
	    if (name != NULL)
		parse_style(name);
	}
    }

#define dft_style(a,b) if (a == NOSTYLE) a = b
    /* *INDENT-OFF* */
    dft_style(s_prompt_edit,		s_normal);
    dft_style(s_prompt_edit_arr,	s_prompt_edit);
    dft_style(s_prompt_edit_pad,	s_prompt_edit);
    dft_style(s_prompt_sel,		s_prompt_edit);
    dft_style(s_aedit,			s_alink);
    dft_style(s_aedit_arr,		s_aedit);
    dft_style(s_aedit_pad,		s_aedit);
    dft_style(s_curedit,		s_aedit);
    dft_style(s_aedit_sel,		s_aedit);
    dft_style(s_menu_bg,		s_normal);
    dft_style(s_menu_entry,		s_menu_bg);
    dft_style(s_menu_frame,		s_menu_bg);
    dft_style(s_menu_number,		s_menu_bg);
    dft_style(s_menu_active,		s_alink);
    /* *INDENT-ON* */

}

/* Add a STYLE: option line to our list.  Process "default:" early
 * for it to have the same semantic as other lines: works at any place
 * of the style file, the first line overrides the later ones.
 */
static void HStyle_addStyle(char *buffer)
{
    char *name = NULL;

    CTRACE1((tfp, "HStyle_addStyle(%s)\n", buffer));

    StrAllocCopy(name, buffer);
    TrimLowercase(name);

    if (lss_styles == NULL)
	lss_styles = HTList_new();

    if (!strncasecomp(name, "default:", 8)) {
	/* default fg/bg */
	CTRACE2(TRACE_STYLE, (tfp, "READCSS.default%s:%s\n",
			      (default_color_reset ? ".ignore" : ""),
			      name ? name : "!?! empty !?!"));
	if (!default_color_reset)
	    parse_style(name);
	FREE(name);
	return;			/* do not need to process it again */
    }
    CTRACE2(TRACE_STYLE, (tfp, "READCSS:%s\n", name ? name : "!?! empty !?!"));
    HTList_addObject(lss_styles, name);
}

static int style_readFromFileREC(char *lss_filename,
				 char *parent_filename)
{
    FILE *fh;
    char *buffer = NULL;

    CTRACE2(TRACE_STYLE, (tfp, "CSS:Reading styles from file: %s\n",
			  lss_filename ? lss_filename : "?!? empty ?!?"));
    if (isEmpty(lss_filename))
	return -1;
    if ((fh = LYOpenCFG(lss_filename, parent_filename, LYNX_LSS_FILE)) == 0) {
	/* this should probably be an alert or something */
	CTRACE2(TRACE_STYLE, (tfp,
			      "CSS:Can't open style file '%s', using defaults\n", lss_filename));
	return -1;
    }

    if (parent_filename == 0) {
	free_colorstylestuff();
    }

    while (LYSafeGets(&buffer, fh) != NULL) {
	LYTrimTrailing(buffer);
	LYTrimTail(buffer);
	LYTrimHead(buffer);
	if (!strncasecomp(buffer, "include:", 8))
	    style_readFromFileREC(LYSkipBlanks(buffer + 8), lss_filename);
	else if (buffer[0] != '#' && strlen(buffer) != 0)
	    HStyle_addStyle(buffer);
    }

    LYCloseInput(fh);
    if ((parent_filename == 0) && LYCursesON)
	parse_userstyles();
    return 0;
}

int style_readFromFile(char *filename)
{
    return style_readFromFileREC(filename, (char *) 0);
}

/* Used in HTStructured methods: - kw */

void TrimColorClass(const char *tagname,
		    char *styleclassname,
		    int *phcode)
{
    char *end, *start = NULL, *lookfrom;
    char tmp[64];

    sprintf(tmp, ";%.*s", (int) sizeof(tmp) - 3, tagname);
    TrimLowercase(tmp);

    if ((lookfrom = styleclassname) != 0) {
	do {
	    end = start;
	    start = strstr(lookfrom, tmp);
	    if (start)
		lookfrom = start + 1;
	}
	while (start);
	/* trim the last matching element off the end
	 * - should match classes here as well (rp)
	 */
	if (end)
	    *end = '\0';
    }
    *phcode = hash_code(lookfrom && *lookfrom ? lookfrom : &tmp[1]);
}

/* This function is designed as faster analog to TrimColorClass.
 * It assumes that tag_name is present in stylename! -HV
 */
void FastTrimColorClass(const char *tag_name,
			unsigned name_len,
			char *stylename,
			char **pstylename_end,	/*will be modified */
			int *phcode)	/*will be modified */
{
    char *tag_start = *pstylename_end;
    BOOLEAN found = FALSE;

    CTRACE2(TRACE_STYLE,
	    (tfp, "STYLE.fast-trim: [%s] from [%s]: ",
	     tag_name, stylename));
    while (tag_start >= stylename) {
	for (; (tag_start >= stylename) && (*tag_start != ';'); --tag_start) ;
	if (!strncasecomp(tag_start + 1, tag_name, (int) name_len)) {
	    found = TRUE;
	    break;
	}
	--tag_start;
    }
    if (found) {
	*tag_start = '\0';
	*pstylename_end = tag_start;
    }
    CTRACE2(TRACE_STYLE, (tfp, found ? "success.\n" : "failed.\n"));
    *phcode = hash_code(tag_start + 1);
}

/* This is called each time lss styles are read. It will fill
 * each element of 'cached_tag_styles' -HV
 */
void cache_tag_styles(void)
{
    char buf[200];
    int i;

    for (i = 0; i < HTML_ELEMENTS; ++i) {
	LYStrNCpy(buf, HTML_dtd.tags[i].name, sizeof(buf) - 1);
	LYLowerCase(buf);
	cached_tag_styles[i] = hash_code(buf);
    }
}

#define SIZEOF_CACHED_STYLES (unsigned) (cached_styles_rows * cached_styles_cols)

static unsigned *RefCachedStyle(int y, int x)
{
    unsigned *result = 0;

    if (cached_styles_ptr == 0) {
	cached_styles_rows = display_lines;
	cached_styles_cols = LYcols;
	cached_styles_ptr = typecallocn(unsigned, SIZEOF_CACHED_STYLES);
    }
    if (y >= 0 &&
	x >= 0 &&
	y < cached_styles_rows &&
	x < cached_styles_cols) {
	result = cached_styles_ptr + (y * cached_styles_cols) + x;
    }
    return result;
}

BOOL ValidCachedStyle(int y, int x)
{
    return (BOOL) (RefCachedStyle(y, x) != 0);
}

unsigned GetCachedStyle(int y, int x)
{
    unsigned value = 0;
    unsigned *cache = RefCachedStyle(y, x);

    if (cache != 0) {
	value = *cache;
    }
    return value;
}

void SetCachedStyle(int y, int x, unsigned value)
{
    unsigned *cache = RefCachedStyle(y, x);

    if (cache != 0) {
	*cache = value;
    }
}

void ResetCachedStyles(void)
{
    if (cached_styles_ptr != NULL) {
	memset(cached_styles_ptr, 0, sizeof(unsigned) * SIZEOF_CACHED_STYLES);
    }
}

void FreeCachedStyles(void)
{
    if (cached_styles_ptr != NULL) {
	FREE(cached_styles_ptr);
	cached_styles_rows = 0;
	cached_styles_cols = 0;
    }
}

/*
 * Recompute the pairs associated with the color style.
 */
void update_color_style(void)
{
    CTRACE((tfp, "update_color_style %p\n", lss_styles));
    memset(our_pairs, 0, sizeof(our_pairs));
    parse_userstyles();
}

#endif /* USE_COLOR_STYLE */
@


1.2
log
@merge lynx2.8.8dev.10a and fix some spelling
@
text
@d2 1
a2 1
 * $LynxId: LYStyle.c,v 1.71 2012/02/10 01:24:18 tom Exp $
d564 1
a564 1
    HTList *cur = lss_styles;
d810 10
@


1.1
log
@Initial revision
@
text
@d1 4
a4 1
/* character level styles for Lynx
a5 1
 * $Id: LYStyle.c 1.59 Sun, 02 Jan 2005 15:35:21 -0800 dickey $
d27 3
d35 13
d49 1
a49 1
int last_styles[MAX_LAST_STYLES] =
a53 10
bucket special_bucket =
{
    "<special>",		/* in order something to be in trace. */
    0, 0, 0, 0, NULL
};
bucket nostyle_bucket =
{
    "<NOSTYLE>",		/* in order something to be in trace. */
    0, 0, 0, 0, NULL
};
d106 1
d112 29
d144 1
a144 1
static void parse_either(char *attrs,
d150 4
d155 20
a174 18
    while (*attrs != '\0') {
	char *next = strchr(attrs, '+');
	char save = (next != NULL) ? *next : '\0';

	if (next == NULL)
	    next = attrs + strlen(attrs);

	if (save != 0)		/* attrs might be a constant string */
	    *next = '\0';
	if ((value = string_to_attr(attrs)) != 0)
	    *monop |= value;
	else if (colorp != 0
		 && (value = check_color(attrs, dft_color)) != ERR_COLOR)
	    *colorp = value;

	attrs = next;
	if (save != '\0')
	    *attrs++ = save;
d179 3
a181 3
static void parse_attributes(char *mono,
			     char *fg,
			     char *bg,
d183 1
a183 1
			     char *element)
d237 2
a238 2
	int iBold = !!(cA & A_BOLD);
	int iBlink = !!(cA & M_BLINK);
d247 1
a247 1
	    && curPair < 255) {
d253 1
a253 1
		our_pairs[iBold][iBlink][iFg][iBg] = curPair;
d280 1
a280 1
	char *name;
d289 2
a290 3
	{ "label",		DSTYLE_OPTION,		0 }, /* [INLINE]'s */
	{ "value",		DSTYLE_VALUE,		0 }, /* [INLINE]'s */
	{ "high",		DSTYLE_HIGH,		0 }, /* [INLINE]'s */
d292 1
a292 1
	{ "candy",		DSTYLE_CANDY,		0 }, /* [INLINE]'s */
d319 2
a320 1
    char *element, *mono, *fg, *bg;
d329 1
a338 1
    strtolower(buffer);
a363 2
    strtolower(element);

d378 9
a386 8
	;
    } else if (!strcasecomp(element, "normal"))		/* added - kw */
    {
	parse_attributes(mono, fg, bg, DSTYLE_NORMAL, "html");
	s_normal = hash_code("html");	/* rather bizarre... - kw */
    }
    /* It must be a HTML element, so look through the list until we find it. */
    else {
d391 1
a391 1
	    element_number = t - HTML_dtd.tags;
d394 1
a394 1
	    element_number < HTML_ELEMENTS)
d396 1
a396 1
	else
d398 1
d403 6
a408 1
#ifdef LY_FIND_LEAKS
d413 2
a415 1
#endif
d418 1
a418 2
 * initialise the default style sheet
 * This should be able to be read from a file in CSS format :-)
d422 57
a478 9
    static const char *table[] =
    {
	"a:bold:green",
	"alert:bold:yellow:red",
	"alink:reverse:yellow:black",
	"label:normal:magenta",
	"status:reverse:yellow:blue",
	"title:normal:magenta",
	"whereis:reverse+underline:magenta:cyan"
d480 2
d483 4
a486 1
    char temp[80];
d488 34
a521 3
    CTRACE((tfp, "initialize_default_stylesheet\n"));
    for (n = 0; n < TABLESIZE(table); n++) {
	parse_style(strcpy(temp, table[n]));
d523 2
a560 6
/* because curses isn't started when we parse the config file, we
 * need to remember the STYLE: lines we encounter and parse them
 * after curses has started
 */
static HTList *lss_styles = NULL;

a568 1
    /* set our styles to be the same as vanilla-curses-lynx */
d610 2
a611 1
    CTRACE((tfp, "HStyle_addStyle(%s)\n", buffer));
d613 2
d617 3
a619 3
    strtolower(name);
    if (!strncasecomp(name, "default:", 8))	/* default fg/bg */
    {
d625 1
a631 6
void style_deleteStyleList(void)
{
    LYFreeStringList(lss_styles);
    lss_styles = NULL;
}

a636 1
    int len;
d650 1
a650 2
	style_initialiseHashTable();
	style_deleteStyleList();
d658 2
a659 2
	    style_readFromFileREC(buffer + 8, lss_filename);
	else if (buffer[0] != '#' && (len = strlen(buffer)) > 0)
d684 1
a684 1
    strtolower(tmp);
d707 1
a707 1
			int name_len,
d720 1
a720 1
	if (!strncasecomp(tag_start + 1, tag_name, name_len)) {
d734 3
a736 3
 /* This is called each time lss styles are read. It will fill
  * each elt of 'cached_tag_styles' -HV
  */
d743 1
a743 1
	LYstrncpy(buf, HTML_dtd.tags[i].name, sizeof(buf) - 1);
d749 61
@


1.1.109.1
log
@Lynx 2.8.6dev.11h (pre-patch) minus
* lib
* po
* scripts
@
text
@@


1.1.109.2
log
@update our Lynx
@
text
@d3 1
a3 1
 * $Id: LYStyle.c 1.60 Thu, 02 Jun 2005 15:36:59 -0700 dickey $
a102 7
static char *TrimLowercase(char *buffer)
{
    LYRemoveBlanks(buffer);
    strtolower(buffer);
    return buffer;
}

a284 1
    TrimLowercase(buffer);
d294 1
d320 2
d336 8
a343 9
	if (!strcasecomp(element, "normal")) {
	    /* added - kw */
	    parse_attributes(mono, fg, bg, DSTYLE_NORMAL, "html");
	    s_normal = hash_code("html");	/* rather bizarre... - kw */

	    LYnormalColor();
	}
    } else {
	/* It must be a HTML element, so look through the list until we find it. */
d351 1
a351 1
	    element_number < HTML_ELEMENTS) {
d353 1
a353 1
	} else {
a354 1
	}
a482 1

a483 2
    TrimLowercase(name);

d486 3
a488 3

    if (!strncasecomp(name, "default:", 8)) {
	/* default fg/bg */
d534 1
a534 1
	    style_readFromFileREC(LYSkipBlanks(buffer + 8), lss_filename);
d560 1
a560 1
    TrimLowercase(tmp);
@


1.1.109.3
log
@apply lynx 2.8.6dev.16c patch
@
text
@d375 2
a376 1
 * Initialise the default style sheet to match the vanilla-curses lynx.
d380 9
a388 57
    /* Use the data setup in USE_COLOR_TABLE */
    /* *INDENT-OFF* */
    static const struct {
	int		color;	/* index into lynx_color_pairs[] */
	const char	*type;
    } table2[] = {
	/*
	 * non-color-style colors encode bold/reverse/underline as a 0-7
	 * index like this:
	 *  b,r,u 0
	 *  b,r,U 1
	 *  b,R,u 2
	 *  b,R,U 3
	 *  B,r,u 4
	 *  B,r,U 5
	 *  B,R,u 6
	 *  B,R,U 7
	 */
	{ 0,	"normal" },
	{ 1,	"a" },
	{ 2,	"status" },
	{ 4,	"b" },
	{ 4,	"blink" },
	{ 4,	"cite" },
	{ 4,	"del" },
	{ 4,	"em" },
	{ 4,	"i" },
	{ 4,	"ins" },
	{ 4,	"strike" },
	{ 4,	"strong" },
	{ 4,	"u" },
#if 0
	{ 5,	"a.b" },
	{ 5,	"b.a" },
	{ 5,	"var.a" },
#endif
	{ 6,	"alink" },
	{ 7,	"whereis" },
#if 0
	{ 0,	"h2.link" },
	{ 0,	"link.h2" },
#endif
#ifdef USE_PRETTYSRC
	/* FIXME: HTL_tagspecs_defaults[] has similar info */
	{ 4,	"span.htmlsrc_comment" },
	{ 4,	"span.htmlsrc_tag" },
	{ 4,	"span.htmlsrc_attrib" },
	{ 4,	"span.htmlsrc_attrval" },
	{ 4,	"span.htmlsrc_abracket" },
	{ 4,	"span.htmlsrc_entity" },
	{ 4,	"span.htmlsrc_href" },
	{ 4,	"span.htmlsrc_entire" },
	{ 4,	"span.htmlsrc_badseq" },
	{ 4,	"span.htmlsrc_badtag" },
	{ 4,	"span.htmlsrc_badattr" },
	{ 4,	"span.htmlsrc_sgmlspecial" },
#endif
a389 2
    /* *INDENT-ON* */

d391 1
a391 4
    char *normal = LYgetTableString(0);
    char *strong = LYgetTableString(4);

    CTRACE((tfp, "initialise_default_stylesheet\n"));
d393 3
a395 34
    /*
     * For debugging this function, create hash codes for all of the tags.
     * That makes it simpler to find the cases that are overlooked in the
     * table.
     */
    for (n = 0; n < (unsigned) HTML_dtd.number_of_tags; ++n) {
	char *name = 0;

	HTSprintf0(&name, "%s:%s", HTML_dtd.tags[n].name, normal);
	parse_style(name);
	FREE(name);
    }

    for (n = 0; n < TABLESIZE(table2); ++n) {
	int code = table2[n].color;
	char *name = 0;
	char *value = 0;

	switch (code) {
	case 0:
	    value = normal;
	    break;
	case 4:
	    value = strong;
	    break;
	default:
	    value = LYgetTableString(code);
	    break;
	}
	HTSprintf0(&name, "%s:%s", table2[n].type, value);
	parse_style(name);
	FREE(name);
	if (value != normal && value != strong && value != 0)
	    free(value);
a396 2
    FREE(normal);
    FREE(strong);
d447 1
@


1.1.109.4
log
@Import Lynx 2.8.6pre.3
@
text
@d3 1
a3 1
 * $Id: LYStyle.c 1.61 Thu, 31 Aug 2006 16:37:53 -0700 dickey $
@


1.1.109.5
log
@Import Lynx 2.8.6pre.4
@
text
@d3 1
a3 1
 * $Id: LYStyle.c 1.62 Mon, 18 Sep 2006 17:28:28 -0700 dickey $
d254 1
@


1.1.109.6
log
@Update to lynx 2.8.6pre.5
This is a required update, because earlier versions contain some
non-free, non-redistributable files!
@
text
@d3 1
a3 1
 * $Id: LYStyle.c 1.63 Mon, 02 Oct 2006 12:56:53 -0700 dickey $
a29 6
/* because curses isn't started when we parse the config file, we
 * need to remember the STYLE: lines we encounter and parse them
 * after curses has started
 */
static HTList *lss_styles = NULL;

a97 1
#define MAX_PAIR 255		/* because our_pairs[] type is unsigned-char */
d210 1
a210 1
	    && curPair < MAX_PAIR) {
d365 1
a365 6
static void style_deleteStyleList(void)
{
    LYFreeStringList(lss_styles);
    lss_styles = NULL;
}

a369 1
    memset(our_pairs, 0, sizeof(our_pairs));
d371 1
d517 6
d593 6
d618 2
a619 1
	free_colorstylestuff();
@


1.1.109.7
log
@Finally, a new Lynx snapshot!
@
text
@d3 1
a3 1
 * $LynxId: LYStyle.c,v 1.57 2006/10/02 20:07:15 tom Exp $
@


1.1.109.8
log
@Import Lynx 2.8.7dev.7 into base as well
@
text
@d1 1
a1 4
/*
 * $LynxId: LYStyle.c,v 1.61 2007/07/23 19:57:17 tom Exp $
 *
 * character level styles for Lynx
d3 1
a24 3
#include <LYHash.h>

#define CTRACE1(p) CTRACE2(TRACE_CFG || TRACE_STYLE, p)
a35 7
#define CACHEW 128
#define CACHEH 64

static unsigned *cached_styles_ptr = NULL;
static int cached_styles_rows = 0;
static int cached_styles_cols = 0;

a382 1
    FreeCachedStyles();
d454 1
a454 1
    CTRACE1((tfp, "initialise_default_stylesheet\n"));
d578 1
a578 1
    CTRACE1((tfp, "HStyle_addStyle(%s)\n", buffer));
d702 3
a704 3
/* This is called each time lss styles are read. It will fill
 * each element of 'cached_tag_styles' -HV
 */
a716 61
#define SIZEOF_CACHED_STYLES (cached_styles_rows * cached_styles_cols)

static unsigned *RefCachedStyle(int y, int x)
{
    unsigned *result = 0;

    if (cached_styles_ptr == 0) {
	cached_styles_rows = display_lines;
	cached_styles_cols = LYcols;
	cached_styles_ptr = typecallocn(unsigned, SIZEOF_CACHED_STYLES);
    }
    if (y >= 0 &&
	x >= 0 &&
	y < cached_styles_rows &&
	x < cached_styles_cols) {
	result = cached_styles_ptr + (y * cached_styles_cols) + x;
    }
    return result;
}

BOOL ValidCachedStyle(int y, int x)
{
    return (RefCachedStyle(y, x) != 0);
}

unsigned GetCachedStyle(int y, int x)
{
    unsigned value = 0;
    unsigned *cache = RefCachedStyle(y, x);

    if (cache != 0) {
	value = *cache;
    }
    return value;
}

void SetCachedStyle(int y, int x, unsigned value)
{
    unsigned *cache = RefCachedStyle(y, x);

    if (cache != 0) {
	*cache = value;
    }
}

void ResetCachedStyles(void)
{
    if (cached_styles_ptr != NULL) {
	memset(cached_styles_ptr, 0, sizeof(unsigned) * SIZEOF_CACHED_STYLES);
    }
}

void FreeCachedStyles(void)
{
    if (cached_styles_ptr != NULL) {
	FREE(cached_styles_ptr);
	cached_styles_rows = 0;
	cached_styles_cols = 0;
    }
}

@


1.1.109.9
log
@Import Lynx 2.8.7dev.11a via eMail from Tom Dickey:
Message-ID: <20081215010313.GA8373@@invisible-island.net>
Message-ID: <20081216012408.GA15364@@invisible-island.net>
@
text
@d2 1
a2 1
 * $LynxId: LYStyle.c,v 1.62 2008/08/31 16:00:10 tom Exp $
d49 1
a49 1
int last_styles[MAX_LAST_STYLES + 1] =
@


1.1.109.10
log
@Woohoo, there’s a new Lynx release!
@
text
@d2 1
a2 1
 * $LynxId: LYStyle.c,v 1.64 2009/01/01 23:06:42 tom Exp $
d141 1
a141 1
	char save = (char) ((next != NULL) ? *next : '\0');
d235 1
a235 1
		our_pairs[iBold][iBlink][iFg][iBg] = UCH(curPair);
d640 1
a640 1
	else if (buffer[0] != '#' && (len = (int) strlen(buffer)) > 0)
d688 1
a688 1
			unsigned name_len,
d701 1
a701 1
	if (!strncasecomp(tag_start + 1, tag_name, (int) name_len)) {
d730 1
a730 1
#define SIZEOF_CACHED_STYLES (unsigned) (cached_styles_rows * cached_styles_cols)
d752 1
a752 1
    return (BOOL) (RefCachedStyle(y, x) != 0);
@


1.1.109.11
log
@Import lynx-current
@
text
@d2 1
a2 1
 * $LynxId: LYStyle.c,v 1.69 2010/09/24 22:07:20 tom Exp $
d132 1
a132 1
static void parse_either(const char *attrs,
a137 1
    char *temp_attrs = NULL;
d139 18
a156 23
    if (StrAllocCopy(temp_attrs, attrs) != NULL) {
	char *to_free = temp_attrs;

	while (*temp_attrs != '\0') {
	    char *next = strchr(temp_attrs, '+');
	    char save = (char) ((next != NULL) ? *next : '\0');

	    if (next == NULL)
		next = temp_attrs + strlen(temp_attrs);

	    if (save != 0)
		*next = '\0';
	    if ((value = string_to_attr(temp_attrs)) != 0)
		*monop |= value;
	    else if (colorp != 0
		     && (value = check_color(temp_attrs, dft_color)) != ERR_COLOR)
		*colorp = value;

	    temp_attrs = next;
	    if (save != '\0')
		*temp_attrs++ = save;
	}
	FREE(to_free);
d161 3
a163 3
static void parse_attributes(const char *mono,
			     const char *fg,
			     const char *bg,
d165 1
a165 1
			     const char *element)
d219 2
a220 2
	int iBold = !!((unsigned) cA & A_BOLD);
	int iBlink = !!((unsigned) cA & M_BLINK);
d262 1
a262 1
	const char *name;
d301 1
a301 2
    char *element, *mono;
    const char *fg, *bg;
d372 1
a372 1
	    element_number = (int) (t - HTML_dtd.tags);
d617 1
d640 1
a640 1
	else if (buffer[0] != '#' && strlen(buffer) != 0)
d724 1
a724 1
	LYStrNCpy(buf, HTML_dtd.tags[i].name, sizeof(buf) - 1);
@


1.1.109.12
log
@Import Lynx 2.8.8dev.10 plus dev.10a patch from invisible-island plus
fix for “lynx -help” output by KIHARA Hideto, by import-3rdpty,v 1.43
@
text
@d2 1
a2 1
 * $LynxId: LYStyle.c,v 1.71 2012/02/10 01:24:18 tom Exp $
d54 10
a121 22
static bucket *new_bucket(const char *name)
{
    bucket *result = typecalloc(bucket);

    if (!result)
	outofmem(__FILE__, "new_bucket");
    StrAllocCopy(result->name, name);
    return result;
}

#if OMIT_SCN_KEEPING
bucket *special_bucket(void)
{
    return new_bucket("<special>");
}
#endif

bucket *nostyle_bucket(void)
{
    return new_bucket("<NOSTYLE>");
}

a612 1
	FREE(name);
@


1.1.109.13
log
@Update
@
text
@d2 1
a2 1
 * $LynxId: LYStyle.c,v 1.73 2013/06/02 19:17:06 tom Exp $
d564 1
a564 1
    HTList *cur = LYuse_color_style ? lss_styles : 0;
a809 10
/*
 * Recompute the pairs associated with the color style.
 */
void update_color_style(void)
{
    CTRACE((tfp, "update_color_style %p\n", lss_styles));
    memset(our_pairs, 0, sizeof(our_pairs));
    parse_userstyles();
}

@


