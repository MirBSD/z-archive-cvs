head	1.1;
branch	1.1.109;
access;
symbols
	lynx-2_8_8dev_16:1.1.109.5
	lynx-2_8_8dev_15e:1.1.109.5
	lynx-2_8_8dev_15:1.1.109.4
	lynx-2_8_8dev_14:1.1.109.4
	lynx-2_8_8dev_12:1.1.109.4
	lynx-2_8_8dev_11:1.1.109.4
	lynx-2_8_8dev_10a:1.1.109.4
	lynx-2_8_8dev_7a:1.1.109.3
	lynx-2_8_8dev_7:1.1.109.3
	lynx-2_8_7rel_1:1.1.109.2
	lynx-2_8_7dev_12:1.1.109.2
	lynx-2_8_7dev_11a:1.1.109.1
	lynx:1.1.109;
locks; strict;
comment	@ * @;


1.1
date	2008.12.16.23.13.12;	author tg;	state Exp;
branches
	1.1.109.1;
next	;
commitid	100494835F965A87026;

1.1.109.1
date	2008.12.16.23.13.12;	author tg;	state Exp;
branches;
next	1.1.109.2;
commitid	100494835F965A87026;

1.1.109.2
date	2009.01.18.19.31.29;	author tg;	state Exp;
branches;
next	1.1.109.3;
commitid	1004973839C3B701938;

1.1.109.3
date	2010.12.19.18.12.49;	author tg;	state Exp;
branches;
next	1.1.109.4;
commitid	1004D0E4B24304015D1;

1.1.109.4
date	2012.02.19.18.30.16;	author tg;	state Exp;
branches;
next	1.1.109.5;
commitid	1004F413EF328BF0E26;

1.1.109.5
date	2013.05.18.14.44.04;	author tg;	state Exp;
branches;
next	;
commitid	100519793BB3FCC7E2F;


desc
@@


1.1
log
@Initial revision
@
text
@/* $LynxId: LYmktime.c,v 1.7 2008/07/06 12:55:40 tom Exp $ */

#include <LYStrings.h>
#include <LYUtils.h>

#include <parsdate.h>

#ifdef TEST_DRIVER
char *LYstrncpy(char *dst,
		const char *src,
		int n)
{
    char *val;
    int len;

    if (src == 0)
	src = "";
    len = strlen(src);

    if (n < 0)
	n = 0;

    val = strncpy(dst, src, n);
    if (len < n)
	*(dst + len) = '\0';
    else
	*(dst + n) = '\0';
    return val;
}
#define strcasecomp strcasecmp
BOOLEAN WWW_TraceFlag = FALSE;
FILE *TraceFP(void)
{
    return stderr;
}
#define USE_PARSDATE 0
#else
#define USE_PARSDATE 1
#endif

/*
 * This function takes a string in the format
 *	"Mon, 01-Jan-96 13:45:35 GMT" or
 *	"Mon,  1 Jan 1996 13:45:35 GMT" or
 *	"dd-mm-yyyy"
 * as an argument, and returns its conversion to clock format (seconds since
 * 00:00:00 Jan 1 1970), or 0 if the string doesn't match the expected pattern. 
 * It also returns 0 if the time is in the past and the "absolute" argument is
 * FALSE.  It is intended for handling 'expires' strings in Version 0 cookies
 * homologously to 'max-age' strings in Version 1 cookies, for which 0 is the
 * minimum, and greater values are handled as '[max-age seconds] + time(NULL)'. 
 * If "absolute" if TRUE, we return the clock format value itself, but if
 * anything goes wrong when parsing the expected patterns, we still return 0. 
 * - FM
 */
time_t LYmktime(char *string,
		BOOL absolute)
{
#if USE_PARSDATE
    time_t result;

    if (non_empty(string)) {
	CTRACE((tfp, "LYmktime: Parsing '%s'\n", string));
	result = parsedate(string, 0);

	if (!absolute) {
	    if ((time((time_t *) 0) - result) >= 0)
		result = 0;
	}
	if (result != 0) {
	    CTRACE((tfp, "LYmktime: clock=%" PRI_time_t ", ctime=%s",
		    CAST_time_t(result),
		    ctime(&result)));
	}
    }
    return result;
#else
    char *s;
    time_t now, clock2;
    int day, month, year, hour, minutes, seconds;
    char *start;
    char temp[8];

    /*
     * Make sure we have a string to parse.  - FM
     */
    if (!non_empty(string))
	return (0);
    s = string;
    CTRACE((tfp, "LYmktime: Parsing '%s'\n", s));

    /*
     * Skip any lead alphabetic "Day, " field and seek a numeric day field.  -
     * FM
     */
    while (*s != '\0' && !isdigit(UCH(*s)))
	s++;
    if (*s == '\0')
	return (0);

    /*
     * Get the numeric day and convert to an integer.  - FM
     */
    start = s;
    while (*s != '\0' && isdigit(UCH(*s)))
	s++;
    if (*s == '\0' || (s - start) > 2)
	return (0);
    LYstrncpy(temp, start, (int) (s - start));
    day = atoi(temp);
    if (day < 1 || day > 31)
	return (0);

    /*
     * Get the month string and convert to an integer.  - FM
     */
    while (*s != '\0' && !isalnum(UCH(*s)))
	s++;
    if (*s == '\0')
	return (0);
    start = s;
    while (*s != '\0' && isalnum(UCH(*s)))
	s++;
    if ((*s == '\0') ||
	(s - start) < (isdigit(UCH(*(s - 1))) ? 2 : 3) ||
	(s - start) > (isdigit(UCH(*(s - 1))) ? 2 : 9))
	return (0);
    LYstrncpy(temp, start, (isdigit(UCH(*(s - 1))) ? 2 : 3));
    switch (TOUPPER(temp[0])) {
    case '0':
    case '1':
	month = atoi(temp);
	if (month < 1 || month > 12) {
	    return (0);
	}
	break;
    case 'A':
	if (!strcasecomp(temp, "Apr")) {
	    month = 4;
	} else if (!strcasecomp(temp, "Aug")) {
	    month = 8;
	} else {
	    return (0);
	}
	break;
    case 'D':
	if (!strcasecomp(temp, "Dec")) {
	    month = 12;
	} else {
	    return (0);
	}
	break;
    case 'F':
	if (!strcasecomp(temp, "Feb")) {
	    month = 2;
	} else {
	    return (0);
	}
	break;
    case 'J':
	if (!strcasecomp(temp, "Jan")) {
	    month = 1;
	} else if (!strcasecomp(temp, "Jun")) {
	    month = 6;
	} else if (!strcasecomp(temp, "Jul")) {
	    month = 7;
	} else {
	    return (0);
	}
	break;
    case 'M':
	if (!strcasecomp(temp, "Mar")) {
	    month = 3;
	} else if (!strcasecomp(temp, "May")) {
	    month = 5;
	} else {
	    return (0);
	}
	break;
    case 'N':
	if (!strcasecomp(temp, "Nov")) {
	    month = 11;
	} else {
	    return (0);
	}
	break;
    case 'O':
	if (!strcasecomp(temp, "Oct")) {
	    month = 10;
	} else {
	    return (0);
	}
	break;
    case 'S':
	if (!strcasecomp(temp, "Sep")) {
	    month = 9;
	} else {
	    return (0);
	}
	break;
    default:
	return (0);
    }

    /*
     * Get the numeric year string and convert to an integer.  - FM
     */
    while (*s != '\0' && !isdigit(UCH(*s)))
	s++;
    if (*s == '\0')
	return (0);
    start = s;
    while (*s != '\0' && isdigit(UCH(*s)))
	s++;
    if ((s - start) == 4) {
	LYstrncpy(temp, start, 4);
    } else if ((s - start) == 2) {
	now = time(NULL);
	/*
	 * Assume that received 2-digit dates >= 70 are 19xx; others
	 * are 20xx.  Only matters when dealing with broken software
	 * (HTTP server or web page) which is not Y2K compliant.  The
	 * line is drawn on a best-guess basis; it is impossible for
	 * this to be completely accurate because it depends on what
	 * the broken sender software intends.  (This totally breaks
	 * in 2100 -- setting up the next crisis...) - BL
	 */
	if (atoi(start) >= 70)
	    LYstrncpy(temp, "19", 2);
	else
	    LYstrncpy(temp, "20", 2);
	strncat(temp, start, 2);
	temp[4] = '\0';
    } else {
	return (0);
    }
    year = atoi(temp);

    /*
     * Get the numeric hour string and convert to an integer.  - FM
     */
    while (*s != '\0' && !isdigit(UCH(*s)))
	s++;
    if (*s == '\0') {
	hour = 0;
	minutes = 0;
	seconds = 0;
    } else {
	start = s;
	while (*s != '\0' && isdigit(UCH(*s)))
	    s++;
	if (*s != ':' || (s - start) > 2)
	    return (0);
	LYstrncpy(temp, start, (int) (s - start));
	hour = atoi(temp);

	/*
	 * Get the numeric minutes string and convert to an integer.  - FM
	 */
	while (*s != '\0' && !isdigit(UCH(*s)))
	    s++;
	if (*s == '\0')
	    return (0);
	start = s;
	while (*s != '\0' && isdigit(UCH(*s)))
	    s++;
	if (*s != ':' || (s - start) > 2)
	    return (0);
	LYstrncpy(temp, start, (int) (s - start));
	minutes = atoi(temp);

	/*
	 * Get the numeric seconds string and convert to an integer.  - FM
	 */
	while (*s != '\0' && !isdigit(UCH(*s)))
	    s++;
	if (*s == '\0')
	    return (0);
	start = s;
	while (*s != '\0' && isdigit(UCH(*s)))
	    s++;
	if (*s == '\0' || (s - start) > 2)
	    return (0);
	LYstrncpy(temp, start, (int) (s - start));
	seconds = atoi(temp);
    }

    /*
     * Convert to clock format (seconds since 00:00:00 Jan 1 1970), but then
     * zero it if it's in the past and "absolute" is not TRUE.  - FM
     */
    month -= 3;
    if (month < 0) {
	month += 12;
	year--;
    }
    day += (year - 1968) * 1461 / 4;
    day += ((((month * 153) + 2) / 5) - 672);
    clock2 = (time_t) ((day * 60 * 60 * 24) +
		       (hour * 60 * 60) +
		       (minutes * 60) +
		       seconds);
    if (absolute == FALSE && (long) (time((time_t *) 0) - clock2) >= 0)
	clock2 = (time_t) 0;
    if (clock2 > 0)
	CTRACE((tfp, "LYmktime: clock=%" PRI_time_t ", ctime=%s",
		CAST_time_t(clock2),
		ctime(&clock2)));

    return (clock2);
#endif
}

#ifdef TEST_DRIVER
static void test_mktime(char *source)
{
    time_t before = LYmktime(source, TRUE);
    time_t after = parsedate(source, 0);

    printf("TEST %s\n", source);
    printf("\t%" PRI_time_t "  %s", CAST_time_t(before), ctime(&before));
    printf("\t%" PRI_time_t "  %s", CAST_time_t(after), ctime(&after));
    if (before != after)
	printf("\t****\n");
}

int main(void)
{
    test_mktime("Mon, 01-Jan-96 13:45:35 GMT");
    test_mktime("Mon,  1 Jan 1996 13:45:35 GMT");
    test_mktime("31-12-1999");
    test_mktime("Wed May 14 22:00:00 2008");
    test_mktime("Sun, 29-Jun-2008 23:19:30 GMT");
    test_mktime("Sun Jul 06 07:00:00 2008 GMT");
    return 0;
}
#endif
@


1.1.109.1
log
@Import Lynx 2.8.7dev.11a via eMail from Tom Dickey:
Message-ID: <20081215010313.GA8373@@invisible-island.net>
Message-ID: <20081216012408.GA15364@@invisible-island.net>
@
text
@@


1.1.109.2
log
@Import Lynx 2.8.7dev.12
@
text
@d1 1
a1 1
/* $LynxId: LYmktime.c,v 1.9 2008/12/27 00:46:30 tom Exp $ */
d60 1
a60 1
    time_t result = 0;
@


1.1.109.3
log
@Import lynx-current
@
text
@d1 1
a1 1
/* $LynxId: LYmktime.c,v 1.12 2010/11/07 21:21:08 tom Exp $ */
d23 1
a23 1
    val = StrNCpy(dst, src, n);
d57 1
a57 1
		int absolute)
d72 1
a72 1
		    CAST_time_t (result),
d307 1
a307 1
		CAST_time_t (clock2),
d321 2
a322 3
    printf("\t%" PRI_time_t "  %s", CAST_time_t (before), ctime(&before));
    printf("\t%" PRI_time_t "  %s", CAST_time_t (after), ctime(&after));

@


1.1.109.4
log
@Import Lynx 2.8.8dev.10 plus dev.10a patch from invisible-island plus
fix for “lynx -help” output by KIHARA Hideto, by import-3rdpty,v 1.43
@
text
@d1 1
a1 1
/* $LynxId: LYmktime.c,v 1.13 2011/05/24 09:51:41 tom Exp $ */
d67 1
a67 1
	    if ((long) (time((time_t *) 0) - result) >= 0)
@


1.1.109.5
log
@Update to the latest Lynx patchkit
@
text
@d1 1
a1 1
/* $LynxId: LYmktime.c,v 1.14 2013/05/03 20:14:06 tom Exp $ */
d109 1
a109 1
    LYStrNCpy(temp, start, (s - start));
d128 1
a128 1
    LYStrNCpy(temp, start, (isdigit(UCH(*(s - 1))) ? 2 : 3));
d216 1
a216 1
	LYStrNCpy(temp, start, 4);
d229 1
a229 1
	    LYStrNCpy(temp, "19", 2);
d231 1
a231 1
	    LYStrNCpy(temp, "20", 2);
d254 1
a254 1
	LYStrNCpy(temp, start, (s - start));
d269 1
a269 1
	LYStrNCpy(temp, start, (s - start));
d284 1
a284 1
	LYStrNCpy(temp, start, (s - start));
@


