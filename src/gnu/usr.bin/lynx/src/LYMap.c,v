head	1.5;
access;
symbols
	lynx-2_8_8dev_16:1.1.109.9
	lynx-2_8_8dev_15e:1.1.109.9
	lynx-2_8_8dev_15:1.1.109.8
	lynx-2_8_8dev_14:1.1.109.8
	lynx-2_8_8dev_12:1.1.109.8
	lynx-2_8_8dev_11:1.1.109.8
	lynx-2_8_8dev_10a:1.1.109.8
	lynx-2_8_8dev_7a:1.1.109.7
	lynx-2_8_8dev_7:1.1.109.7
	lynx-2_8_7rel_1:1.1.109.6
	lynx-2_8_7dev_12:1.1.109.5
	lynx-2_8_7dev_11a:1.1.109.4
	MIRBSD_10:1.1.109.4.0.2
	MIRBSD_10_BASE:1.1.109.4
	lynx-2_8_7dev_8:1.1.109.4
	lynx-2_8_7dev_7:1.1.109.4
	lynx-2_8_7dev_5:1.1.109.4
	lynx-2_8_7dev_2:1.1.109.4
	lynx-2_8_6pre_5:1.1.109.4
	lynx-2_8_6pre_4:1.1.109.4
	lynx-2_8_6pre_3:1.1.109.4
	MIRBSD_9_BASE:1.2
	lynx-2_8_6dev_18c:1.1.109.3
	lynx-2_8_6dev_18:1.1.109.3
	MIRBSD_8:1.2.0.2
	MIRBSD_8_BASE:1.2
	lynx-2_8_6dev_16:1.1.109.2
	lynx:1.1.109;
locks; strict;
comment	@ * @;


1.5
date	2013.05.18.14.59.48;	author tg;	state Exp;
branches;
next	1.4;
commitid	1005197975F6A2B23A5;

1.4
date	2012.02.19.19.38.14;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004F414F917991F461;

1.3
date	2006.09.13.19.18.37;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004508599C49FD4FBA;

1.2
date	2005.12.20.00.06.14;	author tg;	state Exp;
branches;
next	1.1;
commitid	10043A74B0B29538E8C;

1.1
date	2005.03.27.22.12.13;	author tg;	state Exp;
branches
	1.1.109.1;
next	;

1.1.109.1
date	2005.03.27.22.12.13;	author tg;	state Exp;
branches;
next	1.1.109.2;

1.1.109.2
date	2005.12.19.23.10.42;	author tg;	state Exp;
branches;
next	1.1.109.3;
commitid	10043A73DF946372F3D;

1.1.109.3
date	2006.06.02.19.17.46;	author tg;	state Exp;
branches;
next	1.1.109.4;
commitid	10044808E727319C3F7;

1.1.109.4
date	2006.09.13.19.12.04;	author tg;	state Exp;
branches;
next	1.1.109.5;
commitid	100450857B406EB1869;

1.1.109.5
date	2009.01.18.19.31.28;	author tg;	state Exp;
branches;
next	1.1.109.6;
commitid	1004973839C3B701938;

1.1.109.6
date	2009.08.09.14.37.53;	author tg;	state Exp;
branches;
next	1.1.109.7;
commitid	1004A7EDF4952738297;

1.1.109.7
date	2010.12.19.18.12.48;	author tg;	state Exp;
branches;
next	1.1.109.8;
commitid	1004D0E4B24304015D1;

1.1.109.8
date	2012.02.19.18.29.59;	author tg;	state Exp;
branches;
next	1.1.109.9;
commitid	1004F413EF328BF0E26;

1.1.109.9
date	2013.05.18.14.44.05;	author tg;	state Exp;
branches;
next	;
commitid	100519793BB3FCC7E2F;


desc
@@


1.5
log
@fastmerge
@
text
@/*
 * $LynxId: LYMap.c,v 1.47 2013/05/06 00:53:46 tom Exp $
 *			Lynx Client-side Image MAP Support	       LYMap.c
 *			==================================
 *
 *	Author: FM	Foteos Macrides (macrides@@sci.wfbr.edu)
 *
 */

#include <HTUtils.h>
#include <HTTP.h>
#include <HTAnchor.h>
#include <HTAccess.h>
#include <HTFormat.h>
#include <HTParse.h>
#include <HTAlert.h>
#include <LYUtils.h>
#include <LYMap.h>
#include <GridText.h>
#include <LYGlobalDefs.h>
#include <LYKeymap.h>
#include <LYCharUtils.h>
#include <LYCharSets.h>
#include <LYStrings.h>

#ifdef DIRED_SUPPORT
#include <LYUpload.h>
#include <LYLocal.h>
#endif

#include <LYexit.h>
#include <LYLeaks.h>

#define NO_MAP_TITLE "[USEMAP]"

typedef struct _LYMapElement {
    char *address;
    char *title;
    BOOLEAN intern_flag;
} LYMapElement;

typedef struct _LYImageMap {
    char *address;
    char *title;
    HTList *elements;
} LYImageMap;

static HTList *LynxMaps = NULL;

BOOL LYMapsOnly = FALSE;

/*
 * Utility for freeing a list of MAPs.
 */
void ImageMapList_free(HTList *theList)
{
    LYImageMap *map;
    LYMapElement *element;
    HTList *cur = theList;
    HTList *current;

    if (!cur)
	return;

    while (NULL != (map = (LYImageMap *) HTList_nextObject(cur))) {
	FREE(map->address);
	FREE(map->title);
	if (map->elements) {
	    current = map->elements;
	    while (NULL !=
		   (element = (LYMapElement *) HTList_nextObject(current))) {
		FREE(element->address);
		FREE(element->title);
		FREE(element);
	    }
	    HTList_delete(map->elements);
	    map->elements = NULL;
	}
	FREE(map);
    }
    HTList_delete(theList);
    return;
}

#ifdef LY_FIND_LEAKS
/*
 * Utility for freeing the global list of MAPs.  - kw
 */
static void LYLynxMaps_free(void)
{
    ImageMapList_free(LynxMaps);
    LynxMaps = NULL;
    return;
}
#endif /* LY_FIND_LEAKS */

/*
 * We keep two kinds of lists:
 * - A global list (LynxMaps) shared by MAPs from all documents that
 *   do not have POST data.
 * - For each response to a POST which contains MAPs, a list specific
 *   to this combination of URL and post_data.  It is kept in the
 *   HTParentAnchor structure and is freed when the document is removed
 *   from memory, in the course of normal removal of anchors.
 *   MAPs from POST responses can only be accessed via internal links,
 *   i.e., from within the same document (with the same post_data).
 *   The notion of "same document" is extended, so that LYNXIMGMAP:
 *   and List Page screens are logically part of the document on which
 *   they are based. - kw
 *
 * If track_internal_links is false, only the global list will be used
 * for all MAPs.
 *
 */

/*
 * Utility for creating an LYImageMap list, if it doesn't exist already, adding
 * LYImageMap entry structures if needed, and removing any LYMapElements in a
 * pre-existing LYImageMap entry so that it will have only those from AREA tags
 * for the current analysis of MAP element content.  - FM
 */
BOOL LYAddImageMap(char *address,
		   char *title,
		   HTParentAnchor *node_anchor)
{
    LYImageMap *tmp = NULL;
    LYImageMap *old = NULL;
    HTList *cur = NULL;
    HTList *theList = NULL;
    HTList *curele = NULL;
    LYMapElement *ele = NULL;

    if (isEmpty(address))
	return FALSE;
    if (!(node_anchor && node_anchor->address))
	return FALSE;

    /*
     * Set theList to either the global LynxMaps list or, if we are associated
     * with post data, the specific list.  The list is created if it doesn't
     * already exist.  - kw
     */
    if (track_internal_links && node_anchor->post_data) {
	/*
	 * We are handling a MAP element found while parsing node_anchor's
	 * stream of data, and node_anchor has post_data associated and should
	 * therefore represent a POST response, so use the specific list.  - kw
	 */
	theList = node_anchor->imaps;
	if (!theList) {
	    theList = node_anchor->imaps = HTList_new();
	}
    } else {
	if (!LynxMaps) {
	    LynxMaps = HTList_new();
#ifdef LY_FIND_LEAKS
	    atexit(LYLynxMaps_free);
#endif
	}
	theList = LynxMaps;
    }

    if (theList) {
	cur = theList;
	while (NULL != (old = (LYImageMap *) HTList_nextObject(cur))) {
	    if (old->address == 0)	/* shouldn't happen */
		continue;
	    if (!strcmp(old->address, address)) {
		FREE(old->address);
		FREE(old->title);
		if (old->elements) {
		    curele = old->elements;
		    while (NULL !=
			   (ele = (LYMapElement *) HTList_nextObject(curele))) {
			FREE(ele->address);
			FREE(ele->title);
			FREE(ele);
		    }
		    HTList_delete(old->elements);
		    old->elements = NULL;
		}
		break;
	    }
	}
    }

    tmp = (old != NULL) ?
	old : typecalloc(LYImageMap);
    if (tmp == NULL) {
	outofmem(__FILE__, "LYAddImageMap");
	return FALSE;
    }
    StrAllocCopy(tmp->address, address);
    if (non_empty(title))
	StrAllocCopy(tmp->title, title);
    if (tmp != old)
	HTList_addObject(theList, tmp);
    return TRUE;
}

/*
 * Utility for adding LYMapElements to LYImageMaps
 * in the appropriate list. - FM
 */
BOOL LYAddMapElement(char *map,
		     char *address,
		     char *title,
		     HTParentAnchor *node_anchor,
		     int intern_flag GCC_UNUSED)
{
    LYMapElement *tmp = NULL;
    LYImageMap *theMap = NULL;
    HTList *theList = NULL;
    HTList *cur = NULL;

    if (isEmpty(map) || isEmpty(address))
	return FALSE;
    if (!(node_anchor && node_anchor->address))
	return FALSE;

    /*
     * Set theList to either the global LynxMaps list or, if we are associated
     * with post data, the specific list.  The list should already exist, since
     * this function is only called if the AREA tag we are handling was within
     * a MAP element in node_anchor's stream of data, so that LYAddImageMap has
     * been called.  - kw
     */
    if (track_internal_links && node_anchor->post_data) {
	/*
	 * We are handling an AREA tag found while parsing node_anchor's stream
	 * of data, and node_anchor has post_data associated and should
	 * therefore represent a POST response, so use the specific list.  - kw
	 */
	theList = node_anchor->imaps;
	if (!theList) {
	    return FALSE;
	}
    } else {
	if (!LynxMaps)
	    LYAddImageMap(map, NULL, node_anchor);
	theList = LynxMaps;
    }

    cur = theList;
    while (NULL != (theMap = (LYImageMap *) HTList_nextObject(cur))) {
	if (!strcmp(theMap->address, map)) {
	    break;
	}
    }
    if (!theMap)
	return FALSE;
    if (!theMap->elements)
	theMap->elements = HTList_new();
    cur = theMap->elements;
    while (NULL != (tmp = (LYMapElement *) HTList_nextObject(cur))) {
	if (!strcmp(tmp->address, address)) {
	    FREE(tmp->address);
	    FREE(tmp->title);
	    HTList_removeObject(theMap->elements, tmp);
	    FREE(tmp);
	    break;
	}
    }

    tmp = typecalloc(LYMapElement);
    if (tmp == NULL) {
	perror("Out of memory in LYAddMapElement");
	return FALSE;
    }
    StrAllocCopy(tmp->address, address);
    if (non_empty(title))
	StrAllocCopy(tmp->title, title);
    else
	StrAllocCopy(tmp->title, address);
    if (track_internal_links)
	tmp->intern_flag = (BOOLEAN) intern_flag;
    HTList_appendObject(theMap->elements, tmp);

    CTRACE((tfp,
	    "LYAddMapElement\n\tmap     %s\n\taddress %s\n\ttitle   %s)\n",
	    NonNull(map), NonNull(address), NonNull(title)));

    return TRUE;
}

/*
 * Utility for checking whether an LYImageMap entry with a given address
 * already exists in the LynxMaps structure.  - FM
 */
BOOL LYHaveImageMap(char *address)
{
    LYImageMap *Map;
    HTList *cur = LynxMaps;

    if (!(cur && non_empty(address)))
	return FALSE;

    while (NULL != (Map = (LYImageMap *) HTList_nextObject(cur))) {
	if (!strcmp(Map->address, address)) {
	    return TRUE;
	}
    }

    return FALSE;
}

/*
 * Fills in a DocAddress structure for getting the HTParentAnchor of the
 * underlying resource.  ALso returns a pointer to that anchor in
 * *punderlying if we are dealing with POST data.  - kw
 *
 * address  is the address of the underlying resource, i.e., the one
 *	    containing the MAP element, the MAP's name appended as
 *	    fragment is ignored.
 * anAnchor is the LYNXIMGMAP: anchor; if it is associated with POST
 *	    data, we want the specific list, otherwise the global list.
 */
static void fill_DocAddress(DocAddress *wwwdoc,
			    const char *address,
			    HTParentAnchor *anAnchor,
			    HTParentAnchor **punderlying)
{
    char *doc_address = NULL;
    HTParentAnchor *underlying;

    StrAllocCopy(doc_address, address);
    if (anAnchor && anAnchor->post_data) {
	wwwdoc->address = doc_address;
	wwwdoc->post_data = anAnchor->post_data;
	wwwdoc->post_content_type = anAnchor->post_content_type;
	wwwdoc->bookmark = NULL;
	wwwdoc->isHEAD = FALSE;
	wwwdoc->safe = FALSE;
	underlying = HTAnchor_findAddress(wwwdoc);
	if (underlying->safe)
	    wwwdoc->safe = TRUE;
	if (punderlying)
	    *punderlying = underlying;
    } else {
	wwwdoc->address = doc_address;
	wwwdoc->post_data = NULL;
	wwwdoc->post_content_type = NULL;
	wwwdoc->bookmark = NULL;
	wwwdoc->isHEAD = FALSE;
	wwwdoc->safe = FALSE;
	if (punderlying)
	    *punderlying = NULL;
    }
}

/*
 * Get the appropriate list for creating a LYNXIMGMAP:  pseudo- document: 
 * either the global list (LynxMaps), or the specific list if a List Page for a
 * POST response is requested.  Also fill in the DocAddress structure etc.  by
 * calling fill_DocAddress().
 *
 * address is the address of the underlying resource, i.e., the one
 *	   containing the MAP element, the MAP's name appended as
 *	   fragment is ignored.
 * anchor  is the LYNXIMGMAP: anchor for which LYLoadIMGmap() is
 *	   requested; if it is associated with POST data, we want the
 *	   specific list for this combination of address+post_data.
 *
 * if track_internal_links is false, the Anchor passed to
 * LYLoadIMGmap() will never have post_data, so that the global list
 * will be used. - kw
 */
static HTList *get_the_list(DocAddress *wwwdoc,
			    const char *address,
			    HTParentAnchor *anchor,
			    HTParentAnchor **punderlying)
{
    HTList *result;

    if (anchor->post_data) {
	fill_DocAddress(wwwdoc, address, anchor, punderlying);
	if (non_empty(punderlying)) {
	    result = (*punderlying)->imaps;
	} else {
	    result = anchor->imaps;
	}
    } else {
	fill_DocAddress(wwwdoc, address, NULL, punderlying);
	result = LynxMaps;
    }
    return result;
}

/*	LYLoadIMGmap - F.Macrides (macrides@@sci.wfeb.edu)
 *	------------
 *	Create a text/html stream with a list of links
 *	for HyperText References in AREAs of a MAP.
 */

static int LYLoadIMGmap(const char *arg,
			HTParentAnchor *anAnchor,
			HTFormat format_out,
			HTStream *sink)
{
    HTFormat format_in = WWW_HTML;
    HTStream *target = NULL;
    char *buf = NULL;
    LYMapElement *tmp = NULL;
    LYImageMap *theMap = NULL;
    char *MapTitle = NULL;
    char *MapAddress = NULL;
    HTList *theList;
    HTList *cur = NULL;
    const char *address = NULL;
    char *cp = NULL;
    DocAddress WWWDoc;
    HTParentAnchor *underlying;
    BOOL old_cache_setting = LYforce_no_cache;
    BOOL old_reloading = reloading;
    HTFormat old_format_out = HTOutputFormat;

    if (isLYNXIMGMAP(arg)) {
	address = (arg + LEN_LYNXIMGMAP);
    }
    if (!(address && strchr(address, ':'))) {
	HTAlert(MISDIRECTED_MAP_REQUEST);
	return (HT_NOT_LOADED);
    }

    theList = get_the_list(&WWWDoc, address, anAnchor, &underlying);
    if (WWWDoc.safe)
	anAnchor->safe = TRUE;

    if (!theList) {
	if (anAnchor->post_data && !WWWDoc.safe &&
	    ((underlying && underlying->document && !LYforce_no_cache) ||
	     HTConfirm(CONFIRM_POST_RESUBMISSION) != TRUE)) {
	    HTAlert(FAILED_MAP_POST_REQUEST);
	    return (HT_NOT_LOADED);
	}
	LYforce_no_cache = TRUE;
	reloading = TRUE;
	HTOutputFormat = WWW_PRESENT;
	LYMapsOnly = TRUE;
	if (!HTLoadAbsolute(&WWWDoc)) {
	    LYforce_no_cache = old_cache_setting;
	    reloading = old_reloading;
	    HTOutputFormat = old_format_out;
	    LYMapsOnly = FALSE;
	    HTAlert(MAP_NOT_ACCESSIBLE);
	    return (HT_NOT_LOADED);
	}
	LYforce_no_cache = old_cache_setting;
	reloading = old_reloading;
	HTOutputFormat = old_format_out;
	LYMapsOnly = FALSE;
	theList = get_the_list(&WWWDoc, address, anAnchor, &underlying);
    }

    if (!theList) {
	HTAlert(MAPS_NOT_AVAILABLE);
	return (HT_NOT_LOADED);
    }

    cur = theList;
    while (NULL != (theMap = (LYImageMap *) HTList_nextObject(cur))) {
	if (!strcmp(theMap->address, address)) {
	    break;
	}
    }
    if (theMap && HTList_count(theMap->elements) == 0) {
	/*
	 * We found a MAP without any usable AREA.  Fake a redirection to the
	 * address with fragment.  We do this even for post data (internal link
	 * within a document with post data) if it will not result in an
	 * unwanted network request.  - kw
	 */
	if (!anAnchor->post_data) {
	    StrAllocCopy(redirecting_url, address);
	    return (HT_REDIRECTING);
	} else if (WWWDoc.safe ||
		   (underlying->document && !anAnchor->document &&
		    (LYinternal_flag || LYoverride_no_cache))) {
	    StrAllocCopy(redirecting_url, address);
	    redirect_post_content = TRUE;
	    return (HT_REDIRECTING);
	}
    }
    if (!(theMap && theMap->elements)) {
	if (anAnchor->post_data && !WWWDoc.safe &&
	    ((underlying && underlying->document && !LYforce_no_cache) ||
	     HTConfirm(CONFIRM_POST_RESUBMISSION) != TRUE)) {
	    HTAlert(FAILED_MAP_POST_REQUEST);
	    return (HT_NOT_LOADED);
	}
	LYforce_no_cache = TRUE;
	reloading = TRUE;
	HTOutputFormat = WWW_PRESENT;
	LYMapsOnly = TRUE;
	if (!HTLoadAbsolute(&WWWDoc)) {
	    LYforce_no_cache = old_cache_setting;
	    reloading = old_reloading;
	    HTOutputFormat = old_format_out;
	    LYMapsOnly = FALSE;
	    HTAlert(MAP_NOT_ACCESSIBLE);
	    return (HT_NOT_LOADED);
	}
	LYforce_no_cache = old_cache_setting;
	reloading = old_reloading;
	HTOutputFormat = old_format_out;
	LYMapsOnly = FALSE;
	cur = get_the_list(&WWWDoc, address, anAnchor, &underlying);
	while (NULL != (theMap = (LYImageMap *) HTList_nextObject(cur))) {
	    if (!strcmp(theMap->address, address)) {
		break;
	    }
	}
	if (!(theMap && theMap->elements)) {
	    HTAlert(MAP_NOT_AVAILABLE);
	    return (HT_NOT_LOADED);
	}
    }
    if (track_internal_links)
	anAnchor->no_cache = TRUE;

    target = HTStreamStack(format_in,
			   format_out,
			   sink, anAnchor);

    if (!target || target == NULL) {
	HTSprintf0(&buf, CANNOT_CONVERT_I_TO_O,
		   HTAtom_name(format_in), HTAtom_name(format_out));
	HTAlert(buf);
	FREE(buf);
	return (HT_NOT_LOADED);
    }

    if (non_empty(theMap->title)) {
	StrAllocCopy(MapTitle, theMap->title);
    } else if (non_empty(anAnchor->title)) {
	StrAllocCopy(MapTitle, anAnchor->title);
    } else if (non_empty(LYRequestTitle) &&
	       strcasecomp(LYRequestTitle, NO_MAP_TITLE)) {
	StrAllocCopy(MapTitle, LYRequestTitle);
    } else if ((cp = strchr(address, '#')) != NULL) {
	StrAllocCopy(MapTitle, (cp + 1));
    }
    if (isEmpty(MapTitle)) {
	StrAllocCopy(MapTitle, NO_MAP_TITLE);
    } else {
	LYEntify(&MapTitle, TRUE);
    }

#define PUTS(buf)    (*target->isa->put_block)(target, buf, (int) strlen(buf))

    HTSprintf0(&buf, "<html>\n<head>\n");
    PUTS(buf);
    HTSprintf0(&buf, "<META %s content=\"text/html;charset=%s\">\n",
	       "http-equiv=\"content-type\"",
	       LYCharSet_UC[current_char_set].MIMEname);
    PUTS(buf);
    /*
     * This page is a list of titles and anchors for them.  Since titles
     * already passed SGML/HTML stage they are converted to current_char_set. 
     * That is why we insist on META charset for this page.
     */
    HTSprintf0(&buf, "<title>%s</title>\n", MapTitle);
    PUTS(buf);
    HTSprintf0(&buf, "</head>\n<body>\n");
    PUTS(buf);

    HTSprintf0(&buf, "<h1><em>%s</em></h1>\n", MapTitle);
    PUTS(buf);

    StrAllocCopy(MapAddress, address);
    LYEntify(&MapAddress, FALSE);
    HTSprintf0(&buf, "<h2><em>MAP:</em>&nbsp;%s</h2>\n", MapAddress);
    PUTS(buf);

    HTSprintf0(&buf, "<%s compact>\n", ((keypad_mode == NUMBERS_AS_ARROWS) ?
					"ol" : "ul"));
    PUTS(buf);
    cur = theMap->elements;
    while (NULL != (tmp = (LYMapElement *) HTList_nextObject(cur))) {
	StrAllocCopy(MapAddress, tmp->address);
	LYEntify(&MapAddress, FALSE);
	PUTS("<li><a href=\"");
	PUTS(MapAddress);
	PUTS("\"");
	if (track_internal_links && tmp->intern_flag) {
	    PUTS(" TYPE=\"internal link\"");
	}
	PUTS("\n>");
	LYformTitle(&MapTitle, tmp->title);
	LYEntify(&MapTitle, TRUE);
	PUTS(MapTitle);
	PUTS("</a>\n");
    }
    HTSprintf0(&buf, "</%s>\n</body>\n</html>\n",
	       ((keypad_mode == NUMBERS_AS_ARROWS)
		? "ol"
		: "ul"));
    PUTS(buf);

    (*target->isa->_free) (target);
    FREE(MapAddress);
    FREE(MapTitle);
    FREE(buf);
    return (HT_LOADED);
}

void LYPrintImgMaps(FILE *fp)
{
    const char *only = HTLoadedDocumentURL();
    size_t only_len = strlen(only);
    HTList *outer = LynxMaps;
    HTList *inner;
    LYImageMap *map;
    LYMapElement *elt;
    int count;

    if (HTList_count(outer) > 0) {
	while (NULL != (map = (LYImageMap *) HTList_nextObject(outer))) {
	    if (only_len != 0) {
		if (StrNCmp(only, map->address, only_len)
		    || (map->address[only_len] != '\0'
			&& map->address[only_len] != '#')) {
		    continue;
		}
	    }
	    fprintf(fp, "\n%s\n", isEmpty(map->title) ? NO_MAP_TITLE : map->title);
	    fprintf(fp, "%s\n", map->address);
	    inner = map->elements;
	    count = 0;
	    while (NULL != (elt = (LYMapElement *) HTList_nextObject(inner))) {
		fprintf(fp, "%4d. %s", ++count, elt->address);
		if (track_internal_links && elt->intern_flag)
		    fprintf(fp, " TYPE=\"internal link\"");
		fprintf(fp, "\n");
	    }
	}
    }
}

#ifdef GLOBALDEF_IS_MACRO
#define _LYIMGMAP_C_GLOBALDEF_1_INIT { "LYNXIMGMAP", LYLoadIMGmap, 0}
GLOBALDEF(HTProtocol, LYLynxIMGmap, _LYIMGMAP_C_GLOBALDEF_1_INIT);
#else
GLOBALDEF HTProtocol LYLynxIMGmap =
{"LYNXIMGMAP", LYLoadIMGmap, 0};
#endif /* GLOBALDEF_IS_MACRO */
@


1.4
log
@merge lynx2.8.8dev.10a and fix some spelling
@
text
@d2 1
a2 1
 * $LynxId: LYMap.c,v 1.43 2011/06/11 12:36:41 tom Exp $
d39 1
a39 3
#ifndef DONT_TRACK_INTERNAL_LINKS
    BOOL intern_flag;
#endif
d111 1
a111 1
 * If DONT_TRACK_INTERNAL_LINKS is defined, only the global list will be used
d143 1
a143 2
#ifndef DONT_TRACK_INTERNAL_LINKS
    if (node_anchor->post_data) {
d153 1
a153 3
    } else
#endif
    {
d228 1
a228 2
#ifndef DONT_TRACK_INTERNAL_LINKS
    if (node_anchor->post_data) {
d238 1
a238 3
    } else
#endif
    {
d275 2
a276 3
#ifndef DONT_TRACK_INTERNAL_LINKS
    tmp->intern_flag = intern_flag;
#endif
d364 1
a364 1
 * if DONT_TRACK_INTERNAL_LINKS is defined, the Anchor passed to
d373 3
a375 1
    if (anchor && anchor->post_data) {
d377 5
a381 3
	if (non_empty(punderlying))
	    return (*punderlying)->imaps;
	return anchor->imaps;
d384 1
a384 1
	return LynxMaps;
d386 1
d518 2
a519 3
#ifdef DONT_TRACK_INTERNAL_LINKS
    anAnchor->no_cache = TRUE;
#endif
d585 1
a585 2
#ifndef DONT_TRACK_INTERNAL_LINKS
	if (tmp->intern_flag)
d587 1
a587 1
#endif
d632 1
a632 2
#ifndef DONT_TRACK_INTERNAL_LINKS
		if (elt->intern_flag)
a633 1
#endif
@


1.3
log
@fastmerge
@
text
@d1 3
a3 1
/*			Lynx Client-side Image MAP Support	       LYMap.c
a49 4
struct _HTStream {
    HTStreamClass *isa;
};

d207 1
a207 1
 * Utility for adding LYMapElement's to LYImageMap's
d214 1
a214 1
		     BOOL intern_flag GCC_UNUSED)
d327 2
a328 1
static void fill_DocAddress(DocAddress *wwwdoc, char *address,
d332 1
d335 1
d337 1
a337 1
	wwwdoc->address = address;
d349 1
a349 1
	wwwdoc->address = address;
d377 2
a378 1
static HTList *get_the_list(DocAddress *wwwdoc, char *address,
d413 1
a413 1
    char *address = NULL;
d422 1
a422 1
	address = (char *) (arg + LEN_LYNXIMGMAP);
d554 1
a554 1
#define PUTS(buf)    (*target->isa->put_block)(target, buf, strlen(buf))
d616 1
a616 1
    int only_len = strlen(only);
d626 1
a626 1
		if (strncmp(only, map->address, only_len)
@


1.2
log
@fix build
@
text
@d613 2
d623 7
@


1.1
log
@Initial revision
@
text
@d32 2
d209 1
a209 1
 * Utility for adding LYMapElements to LYImageMaps
d243 1
a243 1
	if (!theList)
d245 1
d289 5
d541 1
a541 1
	       strcasecomp(LYRequestTitle, "[USEMAP]")) {
d547 1
a547 1
	StrAllocCopy(MapTitle, "[USEMAP]");
d562 2
a563 2
     * already passed SGML/HTML stage they converted to current_char_set.  That
     * is why we insist on META charset for this page.
d611 26
@


1.1.109.1
log
@Lynx 2.8.6dev.11h (pre-patch) minus
* lib
* po
* scripts
@
text
@@


1.1.109.2
log
@Import new Standard Webbrowser
Sorry, but I've waited for it.
@
text
@a31 2
#define NO_MAP_TITLE "[USEMAP]"

d207 1
a207 1
 * Utility for adding LYMapElement's to LYImageMap's
d241 1
a241 1
	if (!theList) {
a242 1
	}
a285 5

    CTRACE((tfp,
	    "LYAddMapElement\n\tmap     %s\n\taddress %s\n\ttitle   %s)\n",
	    NonNull(map), NonNull(address), NonNull(title)));

d533 1
a533 1
	       strcasecomp(LYRequestTitle, NO_MAP_TITLE)) {
d539 1
a539 1
	StrAllocCopy(MapTitle, NO_MAP_TITLE);
d554 2
a555 2
     * already passed SGML/HTML stage they are converted to current_char_set. 
     * That is why we insist on META charset for this page.
a602 26
void LYPrintImgMaps(FILE *fp)
{
    HTList *outer = LynxMaps;
    HTList *inner;
    LYImageMap *map;
    LYMapElement *elt;
    int count;

    if (HTList_count(outer) > 0) {
	while (NULL != (map = (LYImageMap *) HTList_nextObject(outer))) {
	    fprintf(fp, "\n%s\n", isEmpty(map->title) ? NO_MAP_TITLE : map->title);
	    fprintf(fp, "%s\n", map->address);
	    inner = map->elements;
	    count = 0;
	    while (NULL != (elt = (LYMapElement *) HTList_nextObject(inner))) {
		fprintf(fp, "%4d. %s", ++count, elt->address);
#ifndef DONT_TRACK_INTERNAL_LINKS
		if (map->intern_flag)
		    fprintf(fp, " TYPE=\"internal link\"");
#endif
		fprintf(fp, "\n");
	    }
	}
    }
}

@


1.1.109.3
log
@import Lynx/2.8.6dev.18 (hopefully with our SSL fixes)
@
text
@d628 1
a628 1
		if (elt->intern_flag)
@


1.1.109.4
log
@Import Lynx 2.8.6pre.3
@
text
@a612 2
    const char *only = HTLoadedDocumentURL();
    int only_len = strlen(only);
a620 7
	    if (only_len != 0) {
		if (strncmp(only, map->address, only_len)
		    || (map->address[only_len] != '\0'
			&& map->address[only_len] != '#')) {
		    continue;
		}
	    }
@


1.1.109.5
log
@Import Lynx 2.8.7dev.12
@
text
@d1 1
a1 3
/*
 * $LynxId: LYMap.c,v 1.36 2008/12/27 15:15:28 tom Exp $
 *			Lynx Client-side Image MAP Support	       LYMap.c
d329 1
a329 2
static void fill_DocAddress(DocAddress *wwwdoc,
			    const char *address,
a332 1
    char *doc_address = NULL;
a334 1
    StrAllocCopy(doc_address, address);
d336 1
a336 1
	wwwdoc->address = doc_address;
d348 1
a348 1
	wwwdoc->address = doc_address;
d376 1
a376 2
static HTList *get_the_list(DocAddress *wwwdoc,
			    const char *address,
d411 1
a411 1
    const char *address = NULL;
d420 1
a420 1
	address = (arg + LEN_LYNXIMGMAP);
@


1.1.109.6
log
@Woohoo, there’s a new Lynx release!
@
text
@d2 1
a2 1
 * $LynxId: LYMap.c,v 1.37 2009/01/01 22:30:15 tom Exp $
d558 1
a558 1
#define PUTS(buf)    (*target->isa->put_block)(target, buf, (int) strlen(buf))
d620 1
a620 1
    unsigned only_len = strlen(only);
@


1.1.109.7
log
@Import lynx-current
@
text
@d2 1
a2 1
 * $LynxId: LYMap.c,v 1.40 2010/09/24 22:31:41 tom Exp $
d218 1
a218 1
		     int intern_flag GCC_UNUSED)
d620 1
a620 1
    size_t only_len = strlen(only);
d630 1
a630 1
		if (StrNCmp(only, map->address, only_len)
@


1.1.109.8
log
@Import Lynx 2.8.8dev.10 plus dev.10a patch from invisible-island plus
fix for “lynx -help” output by KIHARA Hideto, by import-3rdpty,v 1.43
@
text
@d2 1
a2 1
 * $LynxId: LYMap.c,v 1.43 2011/06/11 12:36:41 tom Exp $
d50 4
@


1.1.109.9
log
@Update to the latest Lynx patchkit
@
text
@d2 1
a2 1
 * $LynxId: LYMap.c,v 1.47 2013/05/06 00:53:46 tom Exp $
d39 3
a41 1
    BOOLEAN intern_flag;
d113 1
a113 1
 * If track_internal_links is false, only the global list will be used
d145 2
a146 1
    if (track_internal_links && node_anchor->post_data) {
d156 3
a158 1
    } else {
d233 2
a234 1
    if (track_internal_links && node_anchor->post_data) {
d244 3
a246 1
    } else {
d283 3
a285 2
    if (track_internal_links)
	tmp->intern_flag = (BOOLEAN) intern_flag;
d373 1
a373 1
 * if track_internal_links is false, the Anchor passed to
d382 1
a382 3
    HTList *result;

    if (anchor->post_data) {
d384 3
a386 5
	if (non_empty(punderlying)) {
	    result = (*punderlying)->imaps;
	} else {
	    result = anchor->imaps;
	}
d389 1
a389 1
	result = LynxMaps;
a390 1
    return result;
d522 3
a524 2
    if (track_internal_links)
	anAnchor->no_cache = TRUE;
d590 2
a591 1
	if (track_internal_links && tmp->intern_flag) {
d593 1
a593 1
	}
d638 2
a639 1
		if (track_internal_links && elt->intern_flag)
d641 1
@


