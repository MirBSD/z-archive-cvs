head	1.5;
access;
symbols
	MIRBSD_10:1.5.0.4
	MIRBSD_10_BASE:1.5
	MIRBSD_9_BASE:1.5
	MIRBSD_8:1.5.0.2
	MIRBSD_8_BASE:1.5
	binutils-20050707:1.1.101.4
	FSF:1.1.101;
locks; strict;
comment	@ * @;


1.5
date	2005.07.07.16.23.17;	author tg;	state Exp;
branches;
next	1.4;
commitid	689b42cd56cee80e;

1.4
date	2005.06.05.21.24.48;	author tg;	state Exp;
branches;
next	1.3;
commitid	3cf942a36d3e2dcb;

1.3
date	2005.03.28.21.57.00;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.13.16.07.12;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.00.19.15;	author tg;	state Exp;
branches
	1.1.101.1;
next	;

1.1.101.1
date	2005.02.05.00.19.15;	author tg;	state Exp;
branches;
next	1.1.101.2;

1.1.101.2
date	2005.03.28.15.41.15;	author tg;	state Exp;
branches;
next	1.1.101.3;

1.1.101.3
date	2005.05.14.16.50.52;	author tg;	state Exp;
branches;
next	1.1.101.4;
commitid	3a6242862a097542;

1.1.101.4
date	2005.07.07.15.31.45;	author tg;	state Exp;
branches;
next	;
commitid	598542cd4ac1fb58;


desc
@@


1.5
log
@fastmerge
@
text
@/* Instruction printing code for the ARC.
   Copyright 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2005
   Free Software Foundation, Inc.
   Contributed by Doug Evans (dje@@cygnus.com).

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "ansidecl.h"
#include "libiberty.h"
#include "dis-asm.h"
#include "opcode/arc.h"
#include "elf-bfd.h"
#include "elf/arc.h"
#include <string.h>
#include "opintl.h"

#include <stdarg.h>
#include "arc-dis.h"
#include "arc-ext.h"

#ifndef dbg
#define dbg (0)
#endif

/* Classification of the opcodes for the decoder to print 
   the instructions.  */

typedef enum
{
  CLASS_A4_ARITH,	     
  CLASS_A4_OP3_GENERAL,
  CLASS_A4_FLAG,
  /* All branches other than JC.  */
  CLASS_A4_BRANCH,
  CLASS_A4_JC ,
  /* All loads other than immediate 
     indexed loads.  */
  CLASS_A4_LD0,
  CLASS_A4_LD1,
  CLASS_A4_ST,
  CLASS_A4_SR,
  /* All single operand instructions.  */
  CLASS_A4_OP3_SUBOPC3F,
  CLASS_A4_LR
} a4_decoding_class;

#define BIT(word,n)	((word) & (1 << n))
#define BITS(word,s,e)  (((word) << (31 - e)) >> (s + (31 - e)))
#define OPCODE(word)	(BITS ((word), 27, 31))
#define FIELDA(word)	(BITS ((word), 21, 26))
#define FIELDB(word)	(BITS ((word), 15, 20))
#define FIELDC(word)	(BITS ((word),  9, 14))

/* FIELD D is signed in all of its uses, so we make sure argument is
   treated as signed for bit shifting purposes:  */
#define FIELDD(word)	(BITS (((signed int)word), 0, 8))

#define PUT_NEXT_WORD_IN(a)						\
  do									\
    {									\
      if (is_limm == 1 && !NEXT_WORD (1))				\
        mwerror (state, _("Illegal limm reference in last instruction!\n")); \
      a = state->words[1];						\
    }									\
  while (0)

#define CHECK_FLAG_COND_NULLIFY()				\
  do								\
    {								\
      if (is_shimm == 0)					\
        {							\
          flag = BIT (state->words[0], 8);			\
          state->nullifyMode = BITS (state->words[0], 5, 6);	\
          cond = BITS (state->words[0], 0, 4);			\
        }							\
    }								\
  while (0)

#define CHECK_COND()				\
  do						\
    {						\
      if (is_shimm == 0)			\
        cond = BITS (state->words[0], 0, 4);	\
    }						\
  while (0)

#define CHECK_FIELD(field)			\
  do						\
    {						\
      if (field == 62)				\
        {					\
          is_limm++;				\
	  field##isReg = 0;			\
	  PUT_NEXT_WORD_IN (field);		\
	  limm_value = field;			\
	}					\
      else if (field > 60)			\
        {					\
	  field##isReg = 0;			\
	  is_shimm++;				\
	  flag = (field == 61);			\
	  field = FIELDD (state->words[0]);	\
	}					\
    }						\
  while (0)

#define CHECK_FIELD_A()				\
  do						\
    {						\
      fieldA = FIELDA (state->words[0]);	\
      if (fieldA > 60)				\
        {					\
	  fieldAisReg = 0;			\
	  fieldA = 0;				\
	}					\
    }						\
  while (0)

#define CHECK_FIELD_B()				\
  do						\
    {						\
      fieldB = FIELDB (state->words[0]);	\
      CHECK_FIELD (fieldB);			\
    }						\
  while (0)

#define CHECK_FIELD_C()				\
  do						\
    {						\
      fieldC = FIELDC (state->words[0]);	\
      CHECK_FIELD (fieldC);			\
    }						\
  while (0)

#define IS_SMALL(x)                 (((field##x) < 256) && ((field##x) > -257))
#define IS_REG(x)                    (field##x##isReg)
#define WRITE_FORMAT_LB_Rx_RB(x)     WRITE_FORMAT (x, "[","]","","")
#define WRITE_FORMAT_x_COMMA_LB(x)   WRITE_FORMAT (x, "",",[","",",[")
#define WRITE_FORMAT_COMMA_x_RB(x)   WRITE_FORMAT (x, ",","]",",","]")
#define WRITE_FORMAT_x_RB(x)         WRITE_FORMAT (x, "","]","","]")
#define WRITE_FORMAT_COMMA_x(x)      WRITE_FORMAT (x, ",","",",","")
#define WRITE_FORMAT_x_COMMA(x)      WRITE_FORMAT (x, "",",","",",")
#define WRITE_FORMAT_x(x)            WRITE_FORMAT (x, "","","","")
#define WRITE_FORMAT(x,cb1,ca1,cb,ca) strcat (formatString,		\
				     (IS_REG (x) ? cb1"%r"ca1 :		\
				      usesAuxReg ? cb"%a"ca :		\
				      IS_SMALL (x) ? cb"%d"ca : cb"%h"ca))
#define WRITE_FORMAT_RB()	strcat (formatString, "]")
#define WRITE_COMMENT(str)	(state->comm[state->commNum++] = (str))
#define WRITE_NOP_COMMENT()	if (!fieldAisReg && !flag) WRITE_COMMENT ("nop");

#define NEXT_WORD(x)	(offset += 4, state->words[x])

#define add_target(x)	(state->targets[state->tcnt++] = (x))

static char comment_prefix[] = "\t; ";

static const char *
core_reg_name (struct arcDisState * state, int val)
{
  if (state->coreRegName)
    return (*state->coreRegName)(state->_this, val);
  return 0;
}

static const char *
aux_reg_name (struct arcDisState * state, int val)
{
  if (state->auxRegName)
    return (*state->auxRegName)(state->_this, val);
  return 0;
}

static const char *
cond_code_name (struct arcDisState * state, int val)
{
  if (state->condCodeName)
    return (*state->condCodeName)(state->_this, val);
  return 0;
}

static const char *
instruction_name (struct arcDisState * state,
		  int    op1,
		  int    op2,
		  int *  flags)
{
  if (state->instName)
    return (*state->instName)(state->_this, op1, op2, flags);
  return 0;
}

static void
mwerror (struct arcDisState * state, const char * msg)
{
  if (state->err != 0)
    (*state->err)(state->_this, (msg));
}

static const char *
post_address (struct arcDisState * state, int addr)
{
  static char id[3 * ARRAY_SIZE (state->addresses)];
  int j, i = state->acnt;

  if (i < ((int) ARRAY_SIZE (state->addresses)))
    {
      state->addresses[i] = addr;
      ++state->acnt;
      j = i*3;
      id[j+0] = '@@';
      id[j+1] = '0'+i;
      id[j+2] = 0;

      return id + j;
    }
  return "";
}

static void
arc_sprintf (struct arcDisState *state, char *buf, const char *format, ...)
{
  char *bp;
  const char *p;
  int size, leading_zero, regMap[2];
  long auxNum;
  va_list ap;

  va_start (ap, format);

  bp = buf;
  *bp = 0;
  p = format;
  auxNum = -1;
  regMap[0] = 0;
  regMap[1] = 0;

  while (1)
    switch (*p++)
      {
      case 0:
	goto DOCOMM; /* (return)  */
      default:
	*bp++ = p[-1];
	break;
      case '%':
	size = 0;
	leading_zero = 0;
      RETRY: ;
	switch (*p++)
	  {
	  case '0':
	  case '1':
	  case '2':
	  case '3':
	  case '4':
	  case '5':
	  case '6':
	  case '7':
	  case '8':
	  case '9':
	    {
	      /* size.  */
	      size = p[-1] - '0';
	      if (size == 0)
		leading_zero = 1; /* e.g. %08x  */
	      while (*p >= '0' && *p <= '9')
		{
		  size = size * 10 + *p - '0';
		  p++;
		}
	      goto RETRY;
	    }
#define inc_bp() bp = bp + strlen (bp)

	  case 'h':
	    {
	      unsigned u = va_arg (ap, int);

	      /* Hex.  We can change the format to 0x%08x in
		 one place, here, if we wish.
		 We add underscores for easy reading.  */
	      if (u > 65536)
		sprintf (bp, "0x%x_%04x", u >> 16, u & 0xffff);
	      else
		sprintf (bp, "0x%x", u);
	      inc_bp ();
	    }
	    break;
	  case 'X': case 'x':
	    {
	      int val = va_arg (ap, int);

	      if (size != 0)
		if (leading_zero)
		  sprintf (bp, "%0*x", size, val);
		else
		  sprintf (bp, "%*x", size, val);
	      else
		sprintf (bp, "%x", val);
	      inc_bp ();
	    }
	    break;
	  case 'd':
	    {
	      int val = va_arg (ap, int);

	      if (size != 0)
		sprintf (bp, "%*d", size, val);
	      else
		sprintf (bp, "%d", val);
	      inc_bp ();
	    }
	    break;
	  case 'r':
	    {
	      /* Register.  */
	      int val = va_arg (ap, int);

#define REG2NAME(num, name) case num: sprintf (bp, ""name); \
  regMap[(num < 32) ? 0 : 1] |= 1 << (num - ((num < 32) ? 0 : 32)); break;

	      switch (val)
		{
		  REG2NAME (26, "gp");
		  REG2NAME (27, "fp");
		  REG2NAME (28, "sp");
		  REG2NAME (29, "ilink1");
		  REG2NAME (30, "ilink2");
		  REG2NAME (31, "blink");
		  REG2NAME (60, "lp_count");
		default:
		  {
		    const char * ext;

		    ext = core_reg_name (state, val);
		    if (ext)
		      sprintf (bp, "%s", ext);
		    else
		      sprintf (bp,"r%d",val);
		  }
		  break;
		}
	      inc_bp ();
	    } break;

	  case 'a':
	    {
	      /* Aux Register.  */
	      int val = va_arg (ap, int);

#define AUXREG2NAME(num, name) case num: sprintf (bp,name); break;

	      switch (val)
		{
		  AUXREG2NAME (0x0, "status");
		  AUXREG2NAME (0x1, "semaphore");
		  AUXREG2NAME (0x2, "lp_start");
		  AUXREG2NAME (0x3, "lp_end");
		  AUXREG2NAME (0x4, "identity");
		  AUXREG2NAME (0x5, "debug");
		default:
		  {
		    const char *ext;

		    ext = aux_reg_name (state, val);
		    if (ext)
		      sprintf (bp, "%s", ext);
		    else
		      arc_sprintf (state, bp, "%h", val);
		  }
		  break;
		}
	      inc_bp ();
	    }
	    break;

	  case 's':
	    {
	      sprintf (bp, "%s", va_arg (ap, char *));
	      inc_bp ();
	    }
	    break;

	  default:
	    fprintf (stderr, "?? format %c\n", p[-1]);
	    break;
	  }
      }

 DOCOMM: *bp = 0;
  va_end (ap);
}

static void
write_comments_(struct arcDisState * state,
		int shimm,
		int is_limm,
		long limm_value)
{
  if (state->commentBuffer != 0)
    {
      int i;

      if (is_limm)
	{
	  const char *name = post_address (state, limm_value + shimm);

	  if (*name != 0)
	    WRITE_COMMENT (name);
	}
      for (i = 0; i < state->commNum; i++)
	{
	  if (i == 0)
	    strcpy (state->commentBuffer, comment_prefix);
	  else
	    strcat (state->commentBuffer, ", ");
	  strcat (state->commentBuffer, state->comm[i]);
	}
    }
}

#define write_comments2(x) write_comments_ (state, x, is_limm, limm_value)
#define write_comments()   write_comments2 (0)

static const char *condName[] =
{
  /* 0..15.  */
  ""   , "z"  , "nz" , "p"  , "n"  , "c"  , "nc" , "v"  ,
  "nv" , "gt" , "ge" , "lt" , "le" , "hi" , "ls" , "pnz"
};

static void
write_instr_name_(struct arcDisState * state,
		  const char * instrName,
		  int cond,
		  int condCodeIsPartOfName,
		  int flag,
		  int signExtend,
		  int addrWriteBack,
		  int directMem)
{
  strcpy (state->instrBuffer, instrName);

  if (cond > 0)
    {
      const char *cc = 0;

      if (!condCodeIsPartOfName)
	strcat (state->instrBuffer, ".");

      if (cond < 16)
	cc = condName[cond];
      else
	cc = cond_code_name (state, cond);

      if (!cc)
	cc = "???";

      strcat (state->instrBuffer, cc);
    }

  if (flag)
    strcat (state->instrBuffer, ".f");

  switch (state->nullifyMode)
    {
    case BR_exec_always:
      strcat (state->instrBuffer, ".d");
      break;
    case BR_exec_when_jump:
      strcat (state->instrBuffer, ".jd");
      break;
    }

  if (signExtend)
    strcat (state->instrBuffer, ".x");

  if (addrWriteBack)
    strcat (state->instrBuffer, ".a");

  if (directMem)
    strcat (state->instrBuffer, ".di");
}

#define write_instr_name()						\
  do									\
    {									\
      write_instr_name_(state, instrName,cond, condCodeIsPartOfName,	\
			flag, signExtend, addrWriteBack, directMem);	\
      formatString[0] = '\0';						\
    }									\
  while (0)

enum
{
  op_LD0 = 0, op_LD1 = 1, op_ST  = 2, op_3   = 3,
  op_BC  = 4, op_BLC = 5, op_LPC = 6, op_JC  = 7,
  op_ADD = 8, op_ADC = 9, op_SUB = 10, op_SBC = 11,
  op_AND = 12, op_OR  = 13, op_BIC = 14, op_XOR = 15
};

extern disassemble_info tm_print_insn_info;

static int
dsmOneArcInst (bfd_vma addr, struct arcDisState * state)
{
  int condCodeIsPartOfName = 0;
  a4_decoding_class decodingClass;
  const char * instrName;
  int repeatsOp = 0;
  int fieldAisReg = 1;
  int fieldBisReg = 1;
  int fieldCisReg = 1;
  int fieldA;
  int fieldB;
  int fieldC = 0;
  int flag = 0;
  int cond = 0;
  int is_shimm = 0;
  int is_limm = 0;
  long limm_value = 0;
  int signExtend = 0;
  int addrWriteBack = 0;
  int directMem = 0;
  int is_linked = 0;
  int offset = 0;
  int usesAuxReg = 0;
  int flags;
  int ignoreFirstOpd;
  char formatString[60];

  state->instructionLen = 4;
  state->nullifyMode = BR_exec_when_no_jump;
  state->opWidth = 12;
  state->isBranch = 0;

  state->_mem_load = 0;
  state->_ea_present = 0;
  state->_load_len = 0;
  state->ea_reg1 = no_reg;
  state->ea_reg2 = no_reg;
  state->_offset = 0;

  if (! NEXT_WORD (0))
    return 0;

  state->_opcode = OPCODE (state->words[0]);
  instrName = 0;
  decodingClass = CLASS_A4_ARITH; /* default!  */
  repeatsOp = 0;
  condCodeIsPartOfName=0;
  state->commNum = 0;
  state->tcnt = 0;
  state->acnt = 0;
  state->flow = noflow;
  ignoreFirstOpd = 0;

  if (state->commentBuffer)
    state->commentBuffer[0] = '\0';

  switch (state->_opcode)
    {
    case op_LD0:
      switch (BITS (state->words[0],1,2))
	{
	case 0:
	  instrName = "ld";
	  state->_load_len = 4;
	  break;
	case 1:
	  instrName = "ldb";
	  state->_load_len = 1;
	  break;
	case 2:
	  instrName = "ldw";
	  state->_load_len = 2;
	  break;
	default:
	  instrName = "??? (0[3])";
	  state->flow = invalid_instr;
	  break;
	}
      decodingClass = CLASS_A4_LD0;
      break;

    case op_LD1:
      if (BIT (state->words[0],13))
	{
	  instrName = "lr";
	  decodingClass = CLASS_A4_LR;
	}
      else
	{
	  switch (BITS (state->words[0], 10, 11))
	    {
	    case 0:
	      instrName = "ld";
	      state->_load_len = 4;
	      break;
	    case 1:
	      instrName = "ldb";
	      state->_load_len = 1;
	      break;
	    case 2:
	      instrName = "ldw";
	      state->_load_len = 2;
	      break;
	    default:
	      instrName = "??? (1[3])";
	      state->flow = invalid_instr;
	      break;
	    }
	  decodingClass = CLASS_A4_LD1;
	}
      break;

    case op_ST:
      if (BIT (state->words[0], 25))
	{
	  instrName = "sr";
	  decodingClass = CLASS_A4_SR;
	}
      else
	{
	  switch (BITS (state->words[0], 22, 23))
	    {
	    case 0:
	      instrName = "st";
	      break;
	    case 1:
	      instrName = "stb";
	      break;
	    case 2:
	      instrName = "stw";
	      break;
	    default:
	      instrName = "??? (2[3])";
	      state->flow = invalid_instr;
	      break;
	    }
	  decodingClass = CLASS_A4_ST;
	}
      break;

    case op_3:
      decodingClass = CLASS_A4_OP3_GENERAL;  /* default for opcode 3...  */
      switch (FIELDC (state->words[0]))
	{
	case  0:
	  instrName = "flag";
	  decodingClass = CLASS_A4_FLAG;
	  break;
	case  1:
	  instrName = "asr";
	  break;
	case  2:
	  instrName = "lsr";
	  break;
	case  3:
	  instrName = "ror";
	  break;
	case  4:
	  instrName = "rrc";
	  break;
	case  5:
	  instrName = "sexb";
	  break;
	case  6:
	  instrName = "sexw";
	  break;
	case  7:
	  instrName = "extb";
	  break;
	case  8:
	  instrName = "extw";
	  break;
	case  0x3f:
	  {
	    decodingClass = CLASS_A4_OP3_SUBOPC3F;
	    switch (FIELDD (state->words[0]))
	      {
	      case 0:
		instrName = "brk";
		break;
	      case 1:
		instrName = "sleep";
		break;
	      case 2:
		instrName = "swi";
		break;
	      default:
		instrName = "???";
		state->flow=invalid_instr;
		break;
	      }
	  }
	  break;

	  /* ARC Extension Library Instructions
	     NOTE: We assume that extension codes are these instrs.  */
	default:
	  instrName = instruction_name (state,
					state->_opcode,
					FIELDC (state->words[0]),
					&flags);
	  if (!instrName)
	    {
	      instrName = "???";
	      state->flow = invalid_instr;
	    }
	  if (flags & IGNORE_FIRST_OPD)
	    ignoreFirstOpd = 1;
	  break;
	}
      break;

    case op_BC:
      instrName = "b";
    case op_BLC:
      if (!instrName)
	instrName = "bl";
    case op_LPC:
      if (!instrName)
	instrName = "lp";
    case op_JC:
      if (!instrName)
	{
	  if (BITS (state->words[0],9,9))
	    {
	      instrName = "jl";
	      is_linked = 1;
	    }
	  else
	    {
	      instrName = "j";
	      is_linked = 0;
	    }
	}
      condCodeIsPartOfName = 1;
      decodingClass = ((state->_opcode == op_JC) ? CLASS_A4_JC : CLASS_A4_BRANCH );
      state->isBranch = 1;
      break;

    case op_ADD:
    case op_ADC:
    case op_AND:
      repeatsOp = (FIELDC (state->words[0]) == FIELDB (state->words[0]));

      switch (state->_opcode)
	{
	case op_ADD:
	  instrName = (repeatsOp ? "asl" : "add");
	  break;
	case op_ADC:
	  instrName = (repeatsOp ? "rlc" : "adc");
	  break;
	case op_AND:
	  instrName = (repeatsOp ? "mov" : "and");
	  break;
	}
      break;

    case op_SUB: instrName = "sub";
      break;
    case op_SBC: instrName = "sbc";
      break;
    case op_OR:  instrName = "or";
      break;
    case op_BIC: instrName = "bic";
      break;

    case op_XOR:
      if (state->words[0] == 0x7fffffff)
	{
	  /* NOP encoded as xor -1, -1, -1.   */
	  instrName = "nop";
	  decodingClass = CLASS_A4_OP3_SUBOPC3F;
	}
      else
	instrName = "xor";
      break;

    default:
      instrName = instruction_name (state,state->_opcode,0,&flags);
      /* if (instrName) printf("FLAGS=0x%x\n", flags);  */
      if (!instrName)
	{
	  instrName = "???";
	  state->flow=invalid_instr;
	}
      if (flags & IGNORE_FIRST_OPD)
	ignoreFirstOpd = 1;
      break;
    }

  fieldAisReg = fieldBisReg = fieldCisReg = 1; /* Assume regs for now.  */
  flag = cond = is_shimm = is_limm = 0;
  state->nullifyMode = BR_exec_when_no_jump;	/* 0  */
  signExtend = addrWriteBack = directMem = 0;
  usesAuxReg = 0;

  switch (decodingClass)
    {
    case CLASS_A4_ARITH:
      CHECK_FIELD_A ();
      CHECK_FIELD_B ();
      if (!repeatsOp)
	CHECK_FIELD_C ();
      CHECK_FLAG_COND_NULLIFY ();

      write_instr_name ();
      if (!ignoreFirstOpd)
	{
	  WRITE_FORMAT_x (A);
	  WRITE_FORMAT_COMMA_x (B);
	  if (!repeatsOp)
	    WRITE_FORMAT_COMMA_x (C);
	  WRITE_NOP_COMMENT ();
	  arc_sprintf (state, state->operandBuffer, formatString,
		      fieldA, fieldB, fieldC);
	}
      else
	{
	  WRITE_FORMAT_x (B);
	  if (!repeatsOp)
	    WRITE_FORMAT_COMMA_x (C);
	  arc_sprintf (state, state->operandBuffer, formatString,
		      fieldB, fieldC);
	}
      write_comments ();
      break;

    case CLASS_A4_OP3_GENERAL:
      CHECK_FIELD_A ();
      CHECK_FIELD_B ();
      CHECK_FLAG_COND_NULLIFY ();

      write_instr_name ();
      if (!ignoreFirstOpd)
	{
	  WRITE_FORMAT_x (A);
	  WRITE_FORMAT_COMMA_x (B);
	  WRITE_NOP_COMMENT ();
	  arc_sprintf (state, state->operandBuffer, formatString,
		      fieldA, fieldB);
	}
      else
	{
	  WRITE_FORMAT_x (B);
	  arc_sprintf (state, state->operandBuffer, formatString, fieldB);
	}
      write_comments ();
      break;

    case CLASS_A4_FLAG:
      CHECK_FIELD_B ();
      CHECK_FLAG_COND_NULLIFY ();
      flag = 0; /* This is the FLAG instruction -- it's redundant.  */

      write_instr_name ();
      WRITE_FORMAT_x (B);
      arc_sprintf (state, state->operandBuffer, formatString, fieldB);
      write_comments ();
      break;

    case CLASS_A4_BRANCH:
      fieldA = BITS (state->words[0],7,26) << 2;
      fieldA = (fieldA << 10) >> 10; /* Make it signed.  */
      fieldA += addr + 4;
      CHECK_FLAG_COND_NULLIFY ();
      flag = 0;

      write_instr_name ();
      /* This address could be a label we know. Convert it.  */
      if (state->_opcode != op_LPC /* LP  */)
	{
	  add_target (fieldA); /* For debugger.  */
	  state->flow = state->_opcode == op_BLC /* BL  */
	    ? direct_call
	    : direct_jump;
	  /* indirect calls are achieved by "lr blink,[status];
	     lr dest<- func addr; j [dest]"  */
	}

      strcat (formatString, "%s"); /* Address/label name.  */
      arc_sprintf (state, state->operandBuffer, formatString,
		  post_address (state, fieldA));
      write_comments ();
      break;

    case CLASS_A4_JC:
      /* For op_JC -- jump to address specified.
	 Also covers jump and link--bit 9 of the instr. word
	 selects whether linked, thus "is_linked" is set above.  */
      fieldA = 0;
      CHECK_FIELD_B ();
      CHECK_FLAG_COND_NULLIFY ();

      if (!fieldBisReg)
	{
	  fieldAisReg = 0;
	  fieldA = (fieldB >> 25) & 0x7F; /* Flags.  */
	  fieldB = (fieldB & 0xFFFFFF) << 2;
	  state->flow = is_linked ? direct_call : direct_jump;
	  add_target (fieldB);
	  /* Screwy JLcc requires .jd mode to execute correctly
	     but we pretend it is .nd (no delay slot).  */
	  if (is_linked && state->nullifyMode == BR_exec_when_jump)
	    state->nullifyMode = BR_exec_when_no_jump;
	}
      else
	{
	  state->flow = is_linked ? indirect_call : indirect_jump;
	  /* We should also treat this as indirect call if NOT linked
	     but the preceding instruction was a "lr blink,[status]"
	     and we have a delay slot with "add blink,blink,2".
	     For now we can't detect such.  */
	  state->register_for_indirect_jump = fieldB;
	}

      write_instr_name ();
      strcat (formatString,
	      IS_REG (B) ? "[%r]" : "%s"); /* Address/label name.  */
      if (fieldA != 0)
	{
	  fieldAisReg = 0;
	  WRITE_FORMAT_COMMA_x (A);
	}
      if (IS_REG (B))
	arc_sprintf (state, state->operandBuffer, formatString, fieldB, fieldA);
      else
	arc_sprintf (state, state->operandBuffer, formatString,
		    post_address (state, fieldB), fieldA);
      write_comments ();
      break;

    case CLASS_A4_LD0:
      /* LD instruction.
	 B and C can be regs, or one (both?) can be limm.  */
      CHECK_FIELD_A ();
      CHECK_FIELD_B ();
      CHECK_FIELD_C ();
      if (dbg)
	printf ("5:b reg %d %d c reg %d %d  \n",
		fieldBisReg,fieldB,fieldCisReg,fieldC);
      state->_offset = 0;
      state->_ea_present = 1;
      if (fieldBisReg)
	state->ea_reg1 = fieldB;
      else
	state->_offset += fieldB;
      if (fieldCisReg)
	state->ea_reg2 = fieldC;
      else
	state->_offset += fieldC;
      state->_mem_load = 1;

      directMem     = BIT (state->words[0], 5);
      addrWriteBack = BIT (state->words[0], 3);
      signExtend    = BIT (state->words[0], 0);

      write_instr_name ();
      WRITE_FORMAT_x_COMMA_LB(A);
      if (fieldBisReg || fieldB != 0)
	WRITE_FORMAT_x_COMMA (B);
      else
	fieldB = fieldC;

      WRITE_FORMAT_x_RB (C);
      arc_sprintf (state, state->operandBuffer, formatString,
		  fieldA, fieldB, fieldC);
      write_comments ();
      break;

    case CLASS_A4_LD1:
      /* LD instruction.  */
      CHECK_FIELD_B ();
      CHECK_FIELD_A ();
      fieldC = FIELDD (state->words[0]);

      if (dbg)
	printf ("6:b reg %d %d c 0x%x  \n",
		fieldBisReg, fieldB, fieldC);
      state->_ea_present = 1;
      state->_offset = fieldC;
      state->_mem_load = 1;
      if (fieldBisReg)
	state->ea_reg1 = fieldB;
      /* Field B is either a shimm (same as fieldC) or limm (different!)
	 Say ea is not present, so only one of us will do the name lookup.  */
      else
	state->_offset += fieldB, state->_ea_present = 0;

      directMem     = BIT (state->words[0],14);
      addrWriteBack = BIT (state->words[0],12);
      signExtend    = BIT (state->words[0],9);

      write_instr_name ();
      WRITE_FORMAT_x_COMMA_LB (A);
      if (!fieldBisReg)
	{
	  fieldB = state->_offset;
	  WRITE_FORMAT_x_RB (B);
	}
      else
	{
	  WRITE_FORMAT_x (B);
	  if (fieldC != 0 && !BIT (state->words[0],13))
	    {
	      fieldCisReg = 0;
	      WRITE_FORMAT_COMMA_x_RB (C);
	    }
	  else
	    WRITE_FORMAT_RB ();
	}
      arc_sprintf (state, state->operandBuffer, formatString,
		  fieldA, fieldB, fieldC);
      write_comments ();
      break;

    case CLASS_A4_ST:
      /* ST instruction.  */
      CHECK_FIELD_B();
      CHECK_FIELD_C();
      fieldA = FIELDD(state->words[0]); /* shimm  */

      /* [B,A offset]  */
      if (dbg) printf("7:b reg %d %x off %x\n",
		      fieldBisReg,fieldB,fieldA);
      state->_ea_present = 1;
      state->_offset = fieldA;
      if (fieldBisReg)
	state->ea_reg1 = fieldB;
      /* Field B is either a shimm (same as fieldA) or limm (different!)
	 Say ea is not present, so only one of us will do the name lookup.
	 (for is_limm we do the name translation here).  */
      else
	state->_offset += fieldB, state->_ea_present = 0;

      directMem     = BIT (state->words[0], 26);
      addrWriteBack = BIT (state->words[0], 24);

      write_instr_name ();
      WRITE_FORMAT_x_COMMA_LB(C);

      if (!fieldBisReg)
	{
	  fieldB = state->_offset;
	  WRITE_FORMAT_x_RB (B);
	}
      else
	{
	  WRITE_FORMAT_x (B);
	  if (fieldBisReg && fieldA != 0)
	    {
	      fieldAisReg = 0;
	      WRITE_FORMAT_COMMA_x_RB(A);
	    }
	  else
	    WRITE_FORMAT_RB();
	}
      arc_sprintf (state, state->operandBuffer, formatString,
		  fieldC, fieldB, fieldA);
      write_comments2 (fieldA);
      break;

    case CLASS_A4_SR:
      /* SR instruction  */
      CHECK_FIELD_B();
      CHECK_FIELD_C();

      write_instr_name ();
      WRITE_FORMAT_x_COMMA_LB(C);
      /* Try to print B as an aux reg if it is not a core reg.  */
      usesAuxReg = 1;
      WRITE_FORMAT_x (B);
      WRITE_FORMAT_RB ();
      arc_sprintf (state, state->operandBuffer, formatString, fieldC, fieldB);
      write_comments ();
      break;

    case CLASS_A4_OP3_SUBOPC3F:
      write_instr_name ();
      state->operandBuffer[0] = '\0';
      break;

    case CLASS_A4_LR:
      /* LR instruction */
      CHECK_FIELD_A ();
      CHECK_FIELD_B ();

      write_instr_name ();
      WRITE_FORMAT_x_COMMA_LB (A);
      /* Try to print B as an aux reg if it is not a core reg. */
      usesAuxReg = 1;
      WRITE_FORMAT_x (B);
      WRITE_FORMAT_RB ();
      arc_sprintf (state, state->operandBuffer, formatString, fieldA, fieldB);
      write_comments ();
      break;

    default:
      mwerror (state, "Bad decoding class in ARC disassembler");
      break;
    }

  state->_cond = cond;
  return state->instructionLen = offset;
}


/* Returns the name the user specified core extension register.  */

static const char *
_coreRegName(void * arg ATTRIBUTE_UNUSED, int regval)
{
  return arcExtMap_coreRegName (regval);
}

/* Returns the name the user specified AUX extension register.  */

static const char *
_auxRegName(void *_this ATTRIBUTE_UNUSED, int regval)
{
  return arcExtMap_auxRegName(regval);
}

/* Returns the name the user specified condition code name.  */

static const char *
_condCodeName(void *_this ATTRIBUTE_UNUSED, int regval)
{
  return arcExtMap_condCodeName(regval);
}

/* Returns the name the user specified extension instruction.  */

static const char *
_instName (void *_this ATTRIBUTE_UNUSED, int majop, int minop, int *flags)
{
  return arcExtMap_instName(majop, minop, flags);
}

/* Decode an instruction returning the size of the instruction
   in bytes or zero if unrecognized.  */

static int
decodeInstr (bfd_vma            address, /* Address of this instruction.  */
	     disassemble_info * info)
{
  int status;
  bfd_byte buffer[4];
  struct arcDisState s;		/* ARC Disassembler state.  */
  void *stream = info->stream; 	/* Output stream.  */
  fprintf_ftype func = info->fprintf_func;
  int bytes;

  memset (&s, 0, sizeof(struct arcDisState));

  /* read first instruction  */
  status = (*info->read_memory_func) (address, buffer, 4, info);
  if (status != 0)
    {
      (*info->memory_error_func) (status, address, info);
      return 0;
    }
  if (info->endian == BFD_ENDIAN_LITTLE)
    s.words[0] = bfd_getl32(buffer);
  else
    s.words[0] = bfd_getb32(buffer);
  /* Always read second word in case of limm.  */

  /* We ignore the result since last insn may not have a limm.  */
  status = (*info->read_memory_func) (address + 4, buffer, 4, info);
  if (info->endian == BFD_ENDIAN_LITTLE)
    s.words[1] = bfd_getl32(buffer);
  else
    s.words[1] = bfd_getb32(buffer);

  s._this = &s;
  s.coreRegName = _coreRegName;
  s.auxRegName = _auxRegName;
  s.condCodeName = _condCodeName;
  s.instName = _instName;

  /* Disassemble.  */
  bytes = dsmOneArcInst (address, (void *)& s);

  /* Display the disassembly instruction.  */
  (*func) (stream, "%08x ", s.words[0]);
  (*func) (stream, "    ");
  (*func) (stream, "%-10s ", s.instrBuffer);

  if (__TRANSLATION_REQUIRED (s))
    {
      bfd_vma addr = s.addresses[s.operandBuffer[1] - '0'];

      (*info->print_address_func) ((bfd_vma) addr, info);
      (*func) (stream, "\n");
    }
  else
    (*func) (stream, "%s",s.operandBuffer);

  return s.instructionLen;
}

/* Return the print_insn function to use.
   Side effect: load (possibly empty) extension section  */

disassembler_ftype
arc_get_disassembler (void *ptr)
{
  if (ptr)
    build_ARC_extmap (ptr);
  return decodeInstr;
}
@


1.4
log
@first attempt to merge binutils and gdb of today (minus generated files)
XXX elf.sc yields equivalent results for MirOS; double-check against
XXX other platforms. this merger took as much time as ALL the other files!
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1998, 2000, 2001, 2002
d18 2
a19 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
a37 1

d41 2
a42 1
typedef enum { 
a59 1

a66 1

d148 9
a156 9
#define IS_SMALL(x) (((field##x) < 256) && ((field##x) > -257))
#define IS_REG(x)   (field##x##isReg)
#define WRITE_FORMAT_LB_Rx_RB(x)     WRITE_FORMAT(x,"[","]","","")
#define WRITE_FORMAT_x_COMMA_LB(x)   WRITE_FORMAT(x,"",",[","",",[")
#define WRITE_FORMAT_COMMA_x_RB(x)   WRITE_FORMAT(x,",","]",",","]")
#define WRITE_FORMAT_x_RB(x)         WRITE_FORMAT(x,"","]","","]")
#define WRITE_FORMAT_COMMA_x(x)      WRITE_FORMAT(x,",","",",","")
#define WRITE_FORMAT_x_COMMA(x)      WRITE_FORMAT(x,"",",","",",")
#define WRITE_FORMAT_x(x)            WRITE_FORMAT(x,"","","","")
a170 15
static const char *core_reg_name PARAMS ((struct arcDisState *, int));
static const char *aux_reg_name PARAMS ((struct arcDisState *, int));
static const char *cond_code_name PARAMS ((struct arcDisState *, int));
static const char *instruction_name
  PARAMS ((struct arcDisState *, int, int, int *));
static void mwerror PARAMS ((struct arcDisState *, const char *));
static const char *post_address PARAMS ((struct arcDisState *, int));
static void write_comments_
  PARAMS ((struct arcDisState *, int, int, long int));
static void write_instr_name_
  PARAMS ((struct arcDisState *, const char *, int, int, int, int, int, int));
static int dsmOneArcInst PARAMS ((bfd_vma, struct arcDisState *));
static const char *_coreRegName PARAMS ((void *, int));
static int decodeInstr PARAMS ((bfd_vma, disassemble_info *));

d172 1
a172 3
core_reg_name (state, val)
     struct arcDisState * state;
     int                  val;
d180 1
a180 3
aux_reg_name (state, val)
     struct arcDisState * state;
     int                  val;
d188 1
a188 3
cond_code_name (state, val)
     struct arcDisState * state;
     int                  val;
d196 4
a199 5
instruction_name (state, op1, op2, flags)
     struct arcDisState * state;
     int    op1;
     int    op2;
     int *  flags;
d207 1
a207 3
mwerror (state, msg)
     struct arcDisState * state;
     const char * msg;
d214 1
a214 3
post_address (state, addr)
     struct arcDisState * state;
     int addr;
a232 3
static void my_sprintf PARAMS ((struct arcDisState *, char *, const char *,
				...));

d234 1
a234 2
my_sprintf VPARAMS ((struct arcDisState *state, char *buf, const char *format,
		     ...))
d240 1
d242 1
a242 4
  VA_OPEN (ap, format);
  VA_FIXEDARG (ap, struct arcDisState *, state);
  VA_FIXEDARG (ap, char *, buf);
  VA_FIXEDARG (ap, const char *, format);
d383 1
a383 1
		      my_sprintf (state, bp, "%h", val);
d405 1
a405 1
  VA_CLOSE (ap);
d409 4
a412 5
write_comments_(state, shimm, is_limm, limm_value)
     struct arcDisState * state;
     int shimm;
     int is_limm;
     long limm_value;
d436 2
a437 2
#define write_comments2(x) write_comments_(state, x, is_limm, limm_value)
#define write_comments() write_comments2(0)
d439 2
a440 1
static const char *condName[] = {
d447 8
a454 9
write_instr_name_(state, instrName, cond, condCodeIsPartOfName, flag, signExtend, addrWriteBack, directMem)
     struct arcDisState * state;
     const char * instrName;
     int cond;
     int condCodeIsPartOfName;
     int flag;
     int signExtend;
     int addrWriteBack;
     int directMem;
d508 2
a509 1
enum {
d519 1
a519 3
dsmOneArcInst (addr, state)
     bfd_vma              addr;
     struct arcDisState * state;
d608 1
a608 1
	  switch (BITS (state->words[0],10,11))
d632 1
a632 1
      if (BIT (state->words[0],25))
d639 1
a639 1
	  switch (BITS (state->words[0],22,23))
d694 1
a694 1
	    switch( FIELDD (state->words[0]) )
d789 1
a789 1
	  /* nop encoded as xor -1, -1, -1  */
d833 1
a833 1
	  my_sprintf (state, state->operandBuffer, formatString,
d841 1
a841 1
	  my_sprintf (state, state->operandBuffer, formatString,
d858 1
a858 1
	  my_sprintf (state, state->operandBuffer, formatString,
d864 1
a864 1
	  my_sprintf (state, state->operandBuffer, formatString, fieldB);
d872 1
a872 1
      flag = 0; /* this is the FLAG instruction -- it's redundant  */
d876 1
a876 1
      my_sprintf (state, state->operandBuffer, formatString, fieldB);
d882 1
a882 1
      fieldA = (fieldA << 10) >> 10; /* make it signed  */
d899 2
a900 2
      strcat (formatString, "%s"); /* address/label name */
      my_sprintf (state, state->operandBuffer, formatString,
d916 1
a916 1
	  fieldA = (fieldB >> 25) & 0x7F; /* flags */
d920 2
a921 2
	  /* screwy JLcc requires .jd mode to execute correctly
	   * but we pretend it is .nd (no delay slot).  */
d929 3
a931 3
	   * but the preceding instruction was a "lr blink,[status]"
	   * and we have a delay slot with "add blink,blink,2".
	   * For now we can't detect such.  */
d937 1
a937 1
	      IS_REG (B) ? "[%r]" : "%s"); /* address/label name  */
d944 1
a944 1
	my_sprintf (state, state->operandBuffer, formatString, fieldB, fieldA);
d946 1
a946 1
	my_sprintf (state, state->operandBuffer, formatString,
d972 3
a974 3
      directMem     = BIT (state->words[0],5);
      addrWriteBack = BIT (state->words[0],3);
      signExtend    = BIT (state->words[0],0);
d984 1
a984 1
      my_sprintf (state, state->operandBuffer, formatString,
d1003 1
a1003 1
      /* field B is either a shimm (same as fieldC) or limm (different!)
d1030 1
a1030 1
      my_sprintf (state, state->operandBuffer, formatString,
d1048 1
a1048 1
      /* field B is either a shimm (same as fieldA) or limm (different!)
d1054 2
a1055 2
      directMem     = BIT(state->words[0],26);
      addrWriteBack = BIT(state->words[0],24);
d1057 1
a1057 1
      write_instr_name();
d1063 1
a1063 1
	  WRITE_FORMAT_x_RB(B);
d1067 1
a1067 1
	  WRITE_FORMAT_x(B);
d1076 1
a1076 1
      my_sprintf (state, state->operandBuffer, formatString,
d1078 1
a1078 1
      write_comments2(fieldA);
d1086 1
a1086 1
      write_instr_name();
d1090 4
a1093 4
      WRITE_FORMAT_x(B);
      WRITE_FORMAT_RB();
      my_sprintf (state, state->operandBuffer, formatString, fieldC, fieldB);
      write_comments();
d1097 1
a1097 1
      write_instr_name();
d1103 2
a1104 2
      CHECK_FIELD_A();
      CHECK_FIELD_B();
d1106 2
a1107 2
      write_instr_name();
      WRITE_FORMAT_x_COMMA_LB(A);
d1110 4
a1113 4
      WRITE_FORMAT_x(B);
      WRITE_FORMAT_RB();
      my_sprintf (state, state->operandBuffer, formatString, fieldA, fieldB);
      write_comments();
a1115 1

d1127 1
d1129 1
a1129 3
_coreRegName(arg, regval)
     void * arg ATTRIBUTE_UNUSED;
     int regval;
d1135 1
d1142 1
a1143 1
/* Returns the name the user specified condition code name.  */
d1151 1
d1160 1
d1162 2
a1163 3
decodeInstr (address, info)
     bfd_vma            address; /* Address of this instruction.  */
     disassemble_info * info;
d1167 2
a1168 2
  struct arcDisState s;	/* ARC Disassembler state  */
  void *stream = info->stream; /* output stream  */
d1185 1
a1185 1
  /* always read second word in case of limm  */
d1187 1
a1187 1
  /* we ignore the result since last insn may not have a limm  */
d1200 2
a1201 2
  /* disassemble  */
  bytes = dsmOneArcInst(address, (void *)&s);
d1203 1
a1203 1
  /* display the disassembly instruction  */
a1205 1

d1208 1
a1208 1
  if (__TRANSLATION_REQUIRED(s))
d1211 1
d1217 1
@


1.3
log
@merge opcodes
@
text
@d18 1
a18 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.2
log
@merge binutils, minus generated files, plus generated+hacked files
@
text
@d37 23
d67 1
d557 1
a557 1
  int decodingClass;
d598 1
a598 1
  decodingClass = 0; /* default!  */
d632 1
a632 1
      decodingClass = 5;
d639 1
a639 1
	  decodingClass = 10;
d662 1
a662 1
	  decodingClass = 6;
d670 1
a670 1
	  decodingClass = 8;
d690 1
a690 1
	  decodingClass = 7;
d695 1
a695 1
      decodingClass = 1;  /* default for opcode 3...  */
d700 1
a700 1
	  decodingClass = 2;
d728 1
a728 1
	    decodingClass = 9;
d789 1
a789 1
      decodingClass = ((state->_opcode == op_JC) ? 4 : 3);
a796 1
      decodingClass = 0;
d826 1
a826 1
	  decodingClass = 9;
d853 1
a853 1
    case 0:
d882 1
a882 1
    case 1:
d904 1
a904 1
    case 2:
d915 1
a915 1
    case 3:
d940 1
a940 1
    case 4:
d986 1
a986 1
    case 5:
d1024 1
a1024 1
    case 6:
d1070 1
a1070 1
    case 7:
d1115 2
a1116 1
    case 8:
d1131 1
a1131 1
    case 9:
d1136 1
a1136 1
    case 10:
a1150 5
    case 11:
      CHECK_COND();
      write_instr_name();
      state->operandBuffer[0] = '\0';
      break;
@


1.1
log
@Initial revision
@
text
@d441 1
a441 2
	  strncat (state->commentBuffer, state->comm[i],
		   sizeof (state->commentBuffer));
@


1.1.101.1
log
@GNU binutils (CVS snapshot)
@
text
@@


1.1.101.2
log
@GNU binutils (CVS snapshot), without
* top-level files
* bfd/po
* binutils/po
* binutils/testsuite
* gas/po
* gas/testsuite
* gprof
* intl
* ld/po
* ld/testsuite
* libiberty/config
* opcodes/po
* texinfo
(same procedure as usual)
@
text
@a36 23

/* Classification of the opcodes for the decoder to print 
   the instructions.  */

typedef enum { 
  CLASS_A4_ARITH,	     
  CLASS_A4_OP3_GENERAL,
  CLASS_A4_FLAG,
  /* All branches other than JC.  */
  CLASS_A4_BRANCH,
  CLASS_A4_JC ,
  /* All loads other than immediate 
     indexed loads.  */
  CLASS_A4_LD0,
  CLASS_A4_LD1,
  CLASS_A4_ST,
  CLASS_A4_SR,
  /* All single operand instructions.  */
  CLASS_A4_OP3_SUBOPC3F,
  CLASS_A4_LR
} a4_decoding_class;


a43 1

d534 1
a534 1
  a4_decoding_class decodingClass;
d575 1
a575 1
  decodingClass = CLASS_A4_ARITH; /* default!  */
d609 1
a609 1
      decodingClass = CLASS_A4_LD0;
d616 1
a616 1
	  decodingClass = CLASS_A4_LR;
d639 1
a639 1
	  decodingClass = CLASS_A4_LD1;
d647 1
a647 1
	  decodingClass = CLASS_A4_SR;
d667 1
a667 1
	  decodingClass = CLASS_A4_ST;
d672 1
a672 1
      decodingClass = CLASS_A4_OP3_GENERAL;  /* default for opcode 3...  */
d677 1
a677 1
	  decodingClass = CLASS_A4_FLAG;
d705 1
a705 1
	    decodingClass = CLASS_A4_OP3_SUBOPC3F;
d766 1
a766 1
      decodingClass = ((state->_opcode == op_JC) ? CLASS_A4_JC : CLASS_A4_BRANCH );
d774 1
d804 1
a804 1
	  decodingClass = CLASS_A4_OP3_SUBOPC3F;
d831 1
a831 1
    case CLASS_A4_ARITH:
d860 1
a860 1
    case CLASS_A4_OP3_GENERAL:
d882 1
a882 1
    case CLASS_A4_FLAG:
d893 1
a893 1
    case CLASS_A4_BRANCH:
d918 1
a918 1
    case CLASS_A4_JC:
d964 1
a964 1
    case CLASS_A4_LD0:
d1002 1
a1002 1
    case CLASS_A4_LD1:
d1048 1
a1048 1
    case CLASS_A4_ST:
d1093 1
a1093 2

    case CLASS_A4_SR:
d1108 1
a1108 1
    case CLASS_A4_OP3_SUBOPC3F:
d1113 1
a1113 1
    case CLASS_A4_LR:
d1128 5
@


1.1.101.3
log
@GNU binutils, -current (mainline) snapshot as of today,
with the usual bunch of files removed
@
text
@d18 1
a18 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.1.101.4
log
@GNU binutils and debugger as of today
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2005
d18 1
a18 2
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */
d37 1
d41 1
a41 2
typedef enum
{
d59 1
d67 1
d149 9
a157 9
#define IS_SMALL(x)                 (((field##x) < 256) && ((field##x) > -257))
#define IS_REG(x)                    (field##x##isReg)
#define WRITE_FORMAT_LB_Rx_RB(x)     WRITE_FORMAT (x, "[","]","","")
#define WRITE_FORMAT_x_COMMA_LB(x)   WRITE_FORMAT (x, "",",[","",",[")
#define WRITE_FORMAT_COMMA_x_RB(x)   WRITE_FORMAT (x, ",","]",",","]")
#define WRITE_FORMAT_x_RB(x)         WRITE_FORMAT (x, "","]","","]")
#define WRITE_FORMAT_COMMA_x(x)      WRITE_FORMAT (x, ",","",",","")
#define WRITE_FORMAT_x_COMMA(x)      WRITE_FORMAT (x, "",",","",",")
#define WRITE_FORMAT_x(x)            WRITE_FORMAT (x, "","","","")
d172 15
d188 3
a190 1
core_reg_name (struct arcDisState * state, int val)
d198 3
a200 1
aux_reg_name (struct arcDisState * state, int val)
d208 3
a210 1
cond_code_name (struct arcDisState * state, int val)
d218 5
a222 4
instruction_name (struct arcDisState * state,
		  int    op1,
		  int    op2,
		  int *  flags)
d230 3
a232 1
mwerror (struct arcDisState * state, const char * msg)
d239 3
a241 1
post_address (struct arcDisState * state, int addr)
d260 3
d264 2
a265 1
arc_sprintf (struct arcDisState *state, char *buf, const char *format, ...)
a270 1
  va_list ap;
d272 4
a275 1
  va_start (ap, format);
d416 1
a416 1
		      arc_sprintf (state, bp, "%h", val);
d438 1
a438 1
  va_end (ap);
d442 5
a446 4
write_comments_(struct arcDisState * state,
		int shimm,
		int is_limm,
		long limm_value)
d471 2
a472 2
#define write_comments2(x) write_comments_ (state, x, is_limm, limm_value)
#define write_comments()   write_comments2 (0)
d474 1
a474 2
static const char *condName[] =
{
d481 9
a489 8
write_instr_name_(struct arcDisState * state,
		  const char * instrName,
		  int cond,
		  int condCodeIsPartOfName,
		  int flag,
		  int signExtend,
		  int addrWriteBack,
		  int directMem)
d543 1
a543 2
enum
{
d553 3
a555 1
dsmOneArcInst (bfd_vma addr, struct arcDisState * state)
d644 1
a644 1
	  switch (BITS (state->words[0], 10, 11))
d668 1
a668 1
      if (BIT (state->words[0], 25))
d675 1
a675 1
	  switch (BITS (state->words[0], 22, 23))
d730 1
a730 1
	    switch (FIELDD (state->words[0]))
d825 1
a825 1
	  /* NOP encoded as xor -1, -1, -1.   */
d869 1
a869 1
	  arc_sprintf (state, state->operandBuffer, formatString,
d877 1
a877 1
	  arc_sprintf (state, state->operandBuffer, formatString,
d894 1
a894 1
	  arc_sprintf (state, state->operandBuffer, formatString,
d900 1
a900 1
	  arc_sprintf (state, state->operandBuffer, formatString, fieldB);
d908 1
a908 1
      flag = 0; /* This is the FLAG instruction -- it's redundant.  */
d912 1
a912 1
      arc_sprintf (state, state->operandBuffer, formatString, fieldB);
d918 1
a918 1
      fieldA = (fieldA << 10) >> 10; /* Make it signed.  */
d935 2
a936 2
      strcat (formatString, "%s"); /* Address/label name.  */
      arc_sprintf (state, state->operandBuffer, formatString,
d952 1
a952 1
	  fieldA = (fieldB >> 25) & 0x7F; /* Flags.  */
d956 2
a957 2
	  /* Screwy JLcc requires .jd mode to execute correctly
	     but we pretend it is .nd (no delay slot).  */
d965 3
a967 3
	     but the preceding instruction was a "lr blink,[status]"
	     and we have a delay slot with "add blink,blink,2".
	     For now we can't detect such.  */
d973 1
a973 1
	      IS_REG (B) ? "[%r]" : "%s"); /* Address/label name.  */
d980 1
a980 1
	arc_sprintf (state, state->operandBuffer, formatString, fieldB, fieldA);
d982 1
a982 1
	arc_sprintf (state, state->operandBuffer, formatString,
d1008 3
a1010 3
      directMem     = BIT (state->words[0], 5);
      addrWriteBack = BIT (state->words[0], 3);
      signExtend    = BIT (state->words[0], 0);
d1020 1
a1020 1
      arc_sprintf (state, state->operandBuffer, formatString,
d1039 1
a1039 1
      /* Field B is either a shimm (same as fieldC) or limm (different!)
d1066 1
a1066 1
      arc_sprintf (state, state->operandBuffer, formatString,
d1084 1
a1084 1
      /* Field B is either a shimm (same as fieldA) or limm (different!)
d1090 2
a1091 2
      directMem     = BIT (state->words[0], 26);
      addrWriteBack = BIT (state->words[0], 24);
d1093 1
a1093 1
      write_instr_name ();
d1099 1
a1099 1
	  WRITE_FORMAT_x_RB (B);
d1103 1
a1103 1
	  WRITE_FORMAT_x (B);
d1112 1
a1112 1
      arc_sprintf (state, state->operandBuffer, formatString,
d1114 1
a1114 1
      write_comments2 (fieldA);
d1122 1
a1122 1
      write_instr_name ();
d1126 4
a1129 4
      WRITE_FORMAT_x (B);
      WRITE_FORMAT_RB ();
      arc_sprintf (state, state->operandBuffer, formatString, fieldC, fieldB);
      write_comments ();
d1133 1
a1133 1
      write_instr_name ();
d1139 2
a1140 2
      CHECK_FIELD_A ();
      CHECK_FIELD_B ();
d1142 2
a1143 2
      write_instr_name ();
      WRITE_FORMAT_x_COMMA_LB (A);
d1146 4
a1149 4
      WRITE_FORMAT_x (B);
      WRITE_FORMAT_RB ();
      arc_sprintf (state, state->operandBuffer, formatString, fieldA, fieldB);
      write_comments ();
d1152 1
a1163 1

d1165 3
a1167 1
_coreRegName(void * arg ATTRIBUTE_UNUSED, int regval)
a1172 1

d1179 1
a1180 1

a1187 1

a1195 1

d1197 3
a1199 2
decodeInstr (bfd_vma            address, /* Address of this instruction.  */
	     disassemble_info * info)
d1203 2
a1204 2
  struct arcDisState s;		/* ARC Disassembler state.  */
  void *stream = info->stream; 	/* Output stream.  */
d1221 1
a1221 1
  /* Always read second word in case of limm.  */
d1223 1
a1223 1
  /* We ignore the result since last insn may not have a limm.  */
d1236 2
a1237 2
  /* Disassemble.  */
  bytes = dsmOneArcInst (address, (void *)& s);
d1239 1
a1239 1
  /* Display the disassembly instruction.  */
d1242 1
d1245 1
a1245 1
  if (__TRANSLATION_REQUIRED (s))
a1247 1

a1252 1

@


