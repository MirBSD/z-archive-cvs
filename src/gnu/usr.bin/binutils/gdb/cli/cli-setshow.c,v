head	1.3;
access;
symbols
	MIRBSD_10:1.3.0.4
	MIRBSD_10_BASE:1.3
	MIRBSD_9_BASE:1.3
	MIRBSD_8:1.3.0.2
	MIRBSD_8_BASE:1.3
	binutils-20050707:1.1.101.3
	gdb-20050107:1.1.101.1
	FSF:1.1.101;
locks; strict;
comment	@ * @;


1.3
date	2005.06.05.21.24.29;	author tg;	state Exp;
branches;
next	1.2;
commitid	3cf942a36d3e2dcb;

1.2
date	2005.04.19.20.13.30;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.00.21.22;	author tg;	state Exp;
branches
	1.1.101.1;
next	;

1.1.101.1
date	2005.02.05.00.21.22;	author tg;	state Exp;
branches;
next	1.1.101.2;

1.1.101.2
date	2005.05.14.16.40.31;	author tg;	state Exp;
branches;
next	1.1.101.3;
commitid	2ced428628ec0160;

1.1.101.3
date	2005.06.05.17.46.16;	author tg;	state Exp;
branches;
next	;
commitid	7ce142a33a2d11fb;


desc
@@


1.3
log
@first attempt to merge binutils and gdb of today (minus generated files)
XXX elf.sc yields equivalent results for MirOS; double-check against
XXX other platforms. this merger took as much time as ALL the other files!
@
text
@/* Handle set and show GDB commands.

   Copyright 2000, 2001, 2002, 2003 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#ifdef __MirBSD__
#include "readline/readline.h"
#else
#include "readline/tilde.h"
#endif
#include "value.h"
#include <ctype.h>
#include "gdb_string.h"

#include "ui-out.h"

#include "cli/cli-decode.h"
#include "cli/cli-cmds.h"
#include "cli/cli-setshow.h"

/* Prototypes for local functions */

static int parse_binary_operation (char *);


static enum auto_boolean
parse_auto_binary_operation (const char *arg)
{
  if (arg != NULL && *arg != '\0')
    {
      int length = strlen (arg);
      while (isspace (arg[length - 1]) && length > 0)
	length--;
      if (strncmp (arg, "on", length) == 0
	  || strncmp (arg, "1", length) == 0
	  || strncmp (arg, "yes", length) == 0
	  || strncmp (arg, "enable", length) == 0)
	return AUTO_BOOLEAN_TRUE;
      else if (strncmp (arg, "off", length) == 0
	       || strncmp (arg, "0", length) == 0
	       || strncmp (arg, "no", length) == 0
	       || strncmp (arg, "disable", length) == 0)
	return AUTO_BOOLEAN_FALSE;
      else if (strncmp (arg, "auto", length) == 0
	       || (strncmp (arg, "-1", length) == 0 && length > 1))
	return AUTO_BOOLEAN_AUTO;
    }
  error (_("\"on\", \"off\" or \"auto\" expected."));
  return AUTO_BOOLEAN_AUTO; /* pacify GCC */
}

static int
parse_binary_operation (char *arg)
{
  int length;

  if (!arg || !*arg)
    return 1;

  length = strlen (arg);

  while (arg[length - 1] == ' ' || arg[length - 1] == '\t')
    length--;

  if (strncmp (arg, "on", length) == 0
      || strncmp (arg, "1", length) == 0
      || strncmp (arg, "yes", length) == 0
      || strncmp (arg, "enable", length) == 0)
    return 1;
  else if (strncmp (arg, "off", length) == 0
	   || strncmp (arg, "0", length) == 0
	   || strncmp (arg, "no", length) == 0
	   || strncmp (arg, "disable", length) == 0)
    return 0;
  else
    {
      error (_("\"on\" or \"off\" expected."));
      return 0;
    }
}

void
deprecated_show_value_hack (struct ui_file *ignore_file,
			    int ignore_from_tty,
			    struct cmd_list_element *c,
			    const char *value)
{
  /* If there's no command or value, don't try to print it out.  */
  if (c == NULL || value == NULL)
    return;
  /* Print doc minus "show" at start.  */
  print_doc_line (gdb_stdout, c->doc + 5);
  switch (c->var_type)
    {
    case var_string:
    case var_string_noescape:
    case var_optional_filename:
    case var_filename:
    case var_enum:
      printf_filtered ((" is \"%s\".\n"), value);
      break;
    default:
      printf_filtered ((" is %s.\n"), value);
      break;
    }
}

/* Do a "set" or "show" command.  ARG is NULL if no argument, or the text
   of the argument, and FROM_TTY is nonzero if this command is being entered
   directly by the user (i.e. these are just like any other
   command).  C is the command list element for the command.  */

void
do_setshow_command (char *arg, int from_tty, struct cmd_list_element *c)
{
  if (c->type == set_cmd)
    {
      switch (c->var_type)
	{
	case var_string:
	  {
	    char *new;
	    char *p;
	    char *q;
	    int ch;

	    if (arg == NULL)
	      arg = "";
	    new = (char *) xmalloc (strlen (arg) + 2);
	    p = arg;
	    q = new;
	    while ((ch = *p++) != '\000')
	      {
		if (ch == '\\')
		  {
		    /* \ at end of argument is used after spaces
		       so they won't be lost.  */
		    /* This is obsolete now that we no longer strip
		       trailing whitespace and actually, the backslash
		       didn't get here in my test, readline or
		       something did something funky with a backslash
		       right before a newline.  */
		    if (*p == 0)
		      break;
		    ch = parse_escape (&p);
		    if (ch == 0)
		      break;	/* C loses */
		    else if (ch > 0)
		      *q++ = ch;
		  }
		else
		  *q++ = ch;
	      }
#if 0
	    if (*(p - 1) != '\\')
	      *q++ = ' ';
#endif
	    *q++ = '\0';
	    new = (char *) xrealloc (new, q - new);
	    if (*(char **) c->var != NULL)
	      xfree (*(char **) c->var);
	    *(char **) c->var = new;
	  }
	  break;
	case var_string_noescape:
	  if (arg == NULL)
	    arg = "";
	  if (*(char **) c->var != NULL)
	    xfree (*(char **) c->var);
	  *(char **) c->var = savestring (arg, strlen (arg));
	  break;
	case var_optional_filename:
	  if (arg == NULL)
	    arg = "";
	  if (*(char **) c->var != NULL)
	    xfree (*(char **) c->var);
	  *(char **) c->var = savestring (arg, strlen (arg));
	  break;
	case var_filename:
	  if (arg == NULL)
	    error_no_arg (_("filename to set it to."));
	  if (*(char **) c->var != NULL)
	    xfree (*(char **) c->var);
	  *(char **) c->var = tilde_expand (arg);
	  break;
	case var_boolean:
	  *(int *) c->var = parse_binary_operation (arg);
	  break;
	case var_auto_boolean:
	  *(enum auto_boolean *) c->var = parse_auto_binary_operation (arg);
	  break;
	case var_uinteger:
	  if (arg == NULL)
	    error_no_arg (_("integer to set it to."));
	  *(unsigned int *) c->var = parse_and_eval_long (arg);
	  if (*(unsigned int *) c->var == 0)
	    *(unsigned int *) c->var = UINT_MAX;
	  break;
	case var_integer:
	  {
	    unsigned int val;
	    if (arg == NULL)
	      error_no_arg (_("integer to set it to."));
	    val = parse_and_eval_long (arg);
	    if (val == 0)
	      *(int *) c->var = INT_MAX;
	    else if (val >= INT_MAX)
	      error (_("integer %u out of range"), val);
	    else
	      *(int *) c->var = val;
	    break;
	  }
	case var_zinteger:
	  if (arg == NULL)
	    error_no_arg (_("integer to set it to."));
	  *(int *) c->var = parse_and_eval_long (arg);
	  break;
	case var_enum:
	  {
	    int i;
	    int len;
	    int nmatches;
	    const char *match = NULL;
	    char *p;

	    /* if no argument was supplied, print an informative error message */
	    if (arg == NULL)
	      {
		char msg[1024];
		strcpy (msg, "Requires an argument. Valid arguments are ");
		for (i = 0; c->enums[i]; i++)
		  {
		    if (i != 0)
		      strcat (msg, ", ");
		    strcat (msg, c->enums[i]);
		  }
		strcat (msg, ".");
		error (("%s"), msg);
	      }

	    p = strchr (arg, ' ');

	    if (p)
	      len = p - arg;
	    else
	      len = strlen (arg);

	    nmatches = 0;
	    for (i = 0; c->enums[i]; i++)
	      if (strncmp (arg, c->enums[i], len) == 0)
		{
		  if (c->enums[i][len] == '\0')
		    {
		      match = c->enums[i];
		      nmatches = 1;
		      break; /* exact match. */
		    }
		  else
		    {
		      match = c->enums[i];
		      nmatches++;
		    }
		}

	    if (nmatches <= 0)
	      error (_("Undefined item: \"%s\"."), arg);

	    if (nmatches > 1)
	      error (_("Ambiguous item \"%s\"."), arg);

	    *(const char **) c->var = match;
	  }
	  break;
	default:
	  error (_("gdb internal error: bad var_type in do_setshow_command"));
	}
    }
  else if (c->type == show_cmd)
    {
      struct cleanup *old_chain;
      struct ui_stream *stb;

      stb = ui_out_stream_new (uiout);
      old_chain = make_cleanup_ui_out_stream_delete (stb);

      /* Possibly call the pre hook.  */
      if (c->pre_show_hook)
	(c->pre_show_hook) (c);

      switch (c->var_type)
	{
	case var_string:
	  if (*(char **) c->var)
	    fputstr_filtered (*(char **) c->var, '"', stb->stream);
	  break;
	case var_string_noescape:
	case var_optional_filename:
	case var_filename:
	case var_enum:
	  if (*(char **) c->var)
	    fputs_filtered (*(char **) c->var, stb->stream);
	  break;
	case var_boolean:
	  fputs_filtered (*(int *) c->var ? "on" : "off", stb->stream);
	  break;
	case var_auto_boolean:
	  switch (*(enum auto_boolean*) c->var)
	    {
	    case AUTO_BOOLEAN_TRUE:
	      fputs_filtered ("on", stb->stream);
	      break;
	    case AUTO_BOOLEAN_FALSE:
	      fputs_filtered ("off", stb->stream);
	      break;
	    case AUTO_BOOLEAN_AUTO:
	      fputs_filtered ("auto", stb->stream);
	      break;
	    default:
	      internal_error (__FILE__, __LINE__,
			      _("do_setshow_command: invalid var_auto_boolean"));
	      break;
	    }
	  break;
	case var_uinteger:
	  if (*(unsigned int *) c->var == UINT_MAX)
	    {
	      fputs_filtered ("unlimited", stb->stream);
	      break;
	    }
	  /* else fall through */
	case var_zinteger:
	  fprintf_filtered (stb->stream, "%u", *(unsigned int *) c->var);
	  break;
	case var_integer:
	  if (*(int *) c->var == INT_MAX)
	    {
	      fputs_filtered ("unlimited", stb->stream);
	    }
	  else
	    fprintf_filtered (stb->stream, "%d", *(int *) c->var);
	  break;

	default:
	  error (_("gdb internal error: bad var_type in do_setshow_command"));
	}


      /* FIXME: cagney/2005-02-10: Need to split this in half: code to
	 convert the value into a string (esentially the above); and
	 code to print the value out.  For the latter there should be
	 MI and CLI specific versions.  */

      if (ui_out_is_mi_like_p (uiout))
	ui_out_field_stream (uiout, "value", stb);
      else
	{
	  long length;
	  char *value = ui_file_xstrdup (stb->stream, &length);
	  make_cleanup (xfree, value);
	  if (c->show_value_func != NULL)
	    c->show_value_func (gdb_stdout, from_tty, c, value);
	  else
	    deprecated_show_value_hack (gdb_stdout, from_tty, c, value);
	}
      do_cleanups (old_chain);
    }
  else
    error (_("gdb internal error: bad cmd_type in do_setshow_command"));
  c->func (c, NULL, from_tty);
  if (c->type == set_cmd && deprecated_set_hook)
    deprecated_set_hook (c);
}

/* Show all the settings in a list of show commands.  */

void
cmd_show_list (struct cmd_list_element *list, int from_tty, char *prefix)
{
  struct cleanup *showlist_chain;

  showlist_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "showlist");
  for (; list != NULL; list = list->next)
    {
      /* If we find a prefix, run its list, prefixing our output by its
         prefix (with "show " skipped).  */
      if (list->prefixlist && !list->abbrev_flag)
	{
	  struct cleanup *optionlist_chain
	    = make_cleanup_ui_out_tuple_begin_end (uiout, "optionlist");
	  char *new_prefix = strstr (list->prefixname, "show ") + 5;
	  if (ui_out_is_mi_like_p (uiout))
	    ui_out_field_string (uiout, "prefix", new_prefix);
	  cmd_show_list (*list->prefixlist, from_tty, new_prefix);
	  /* Close the tuple.  */
	  do_cleanups (optionlist_chain);
	}
      if (list->type == show_cmd)
	{
	  struct cleanup *option_chain
	    = make_cleanup_ui_out_tuple_begin_end (uiout, "option");
	  ui_out_text (uiout, prefix);
	  ui_out_field_string (uiout, "name", list->name);
	  ui_out_text (uiout, ":  ");
	  do_setshow_command ((char *) NULL, from_tty, list);
          /* Close the tuple.  */
	  do_cleanups (option_chain);
	}
    }
  /* Close the tuple.  */
  do_cleanups (showlist_chain);
}

@


1.2
log
@hack on gdb
make it somehow work (i386, sparc, powerpc)
add readline docs from rl 5.0
nuke generated files
make make build work again
bump OS version
@
text
@d63 1
a63 1
  error ("\"on\", \"off\" or \"auto\" expected.");
d92 1
a92 1
      error ("\"on\" or \"off\" expected.");
d97 26
d187 7
d196 1
a196 1
	    error_no_arg ("filename to set it to.");
d209 1
a209 1
	    error_no_arg ("integer to set it to.");
d218 1
a218 1
	      error_no_arg ("integer to set it to.");
d223 1
a223 1
	      error ("integer %u out of range", val);
d230 1
a230 1
	    error_no_arg ("integer to set it to.");
d253 1
a253 1
		error ("%s", msg);
d281 1
a281 1
	      error ("Undefined item: \"%s\".", arg);
d284 1
a284 1
	      error ("Ambiguous item \"%s\".", arg);
d290 1
a290 1
	  error ("gdb internal error: bad var_type in do_setshow_command");
a296 1
      int quote;
a304 6
      /* Print doc minus "show" at start.  */
      print_doc_line (gdb_stdout, c->doc + 5);

      ui_out_text (uiout, " is ");
      ui_out_wrap_hint (uiout, "    ");
      quote = 0;
d308 2
a309 7
	  {
	    unsigned char *p;

	    if (*(unsigned char **) c->var)
	      fputstr_filtered (*(unsigned char **) c->var, '"', stb->stream);
	    quote = 1;
	  }
d312 1
a316 1
	  quote = 1;
d335 1
a335 1
			      "do_setshow_command: invalid var_auto_boolean");
d359 20
a378 1
	  error ("gdb internal error: bad var_type in do_setshow_command");
a379 6
      if (quote)
	ui_out_text (uiout, "\"");
      ui_out_field_stream (uiout, "value", stb);
      if (quote)
	ui_out_text (uiout, "\"");
      ui_out_text (uiout, ".\n");
d383 1
a383 1
    error ("gdb internal error: bad cmd_type in do_setshow_command");
@


1.1
log
@Initial revision
@
text
@d21 3
d25 1
@


1.1.101.1
log
@The GNU Debugger, CVS version matching binutils
@
text
@@


1.1.101.2
log
@The GNU Debugger, today's -current (mainline) snapshot
Some directories removed as usual
@
text
@d59 1
a59 1
  error (_("\"on\", \"off\" or \"auto\" expected."));
d88 1
a88 1
      error (_("\"on\" or \"off\" expected."));
a92 26
void
deprecated_show_value_hack (struct ui_file *ignore_file,
			    int ignore_from_tty,
			    struct cmd_list_element *c,
			    const char *value)
{
  /* If there's no command or value, don't try to print it out.  */
  if (c == NULL || value == NULL)
    return;
  /* Print doc minus "show" at start.  */
  print_doc_line (gdb_stdout, c->doc + 5);
  switch (c->var_type)
    {
    case var_string:
    case var_string_noescape:
    case var_optional_filename:
    case var_filename:
    case var_enum:
      printf_filtered ((" is \"%s\".\n"), value);
      break;
    default:
      printf_filtered ((" is %s.\n"), value);
      break;
    }
}

a156 7
	case var_optional_filename:
	  if (arg == NULL)
	    arg = "";
	  if (*(char **) c->var != NULL)
	    xfree (*(char **) c->var);
	  *(char **) c->var = savestring (arg, strlen (arg));
	  break;
d159 1
a159 1
	    error_no_arg (_("filename to set it to."));
d172 1
a172 1
	    error_no_arg (_("integer to set it to."));
d181 1
a181 1
	      error_no_arg (_("integer to set it to."));
d186 1
a186 1
	      error (_("integer %u out of range"), val);
d193 1
a193 1
	    error_no_arg (_("integer to set it to."));
d216 1
a216 1
		error (("%s"), msg);
d244 1
a244 1
	      error (_("Undefined item: \"%s\"."), arg);
d247 1
a247 1
	      error (_("Ambiguous item \"%s\"."), arg);
d253 1
a253 1
	  error (_("gdb internal error: bad var_type in do_setshow_command"));
d260 1
d269 6
d283 1
a286 1
	case var_optional_filename:
d291 1
d310 1
a310 1
			      _("do_setshow_command: invalid var_auto_boolean"));
d334 1
a334 20
	  error (_("gdb internal error: bad var_type in do_setshow_command"));
	}


      /* FIXME: cagney/2005-02-10: Need to split this in half: code to
	 convert the value into a string (esentially the above); and
	 code to print the value out.  For the latter there should be
	 MI and CLI specific versions.  */

      if (ui_out_is_mi_like_p (uiout))
	ui_out_field_stream (uiout, "value", stb);
      else
	{
	  long length;
	  char *value = ui_file_xstrdup (stb->stream, &length);
	  make_cleanup (xfree, value);
	  if (c->show_value_func != NULL)
	    c->show_value_func (gdb_stdout, from_tty, c, value);
	  else
	    deprecated_show_value_hack (gdb_stdout, from_tty, c, value);
d336 6
d345 1
a345 1
    error (_("gdb internal error: bad cmd_type in do_setshow_command"));
@


1.1.101.3
log
@Import GNU binutils and gdb as of today (snapshot), appropriately shortened
using src/scripts/binutils-import,v 1.4
@
text
@d304 6
a309 2
	  if (*(char **) c->var)
	    fputstr_filtered (*(char **) c->var, '"', stb->stream);
@


