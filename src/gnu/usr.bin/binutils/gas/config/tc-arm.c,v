head	1.2;
access;
symbols
	MIRBSD_10:1.1.101.5.0.4
	MIRBSD_10_BASE:1.1.101.5
	MIRBSD_9_BASE:1.1.101.5
	MIRBSD_8:1.1.101.5.0.2
	MIRBSD_8_BASE:1.1.101.5
	binutils-20050707:1.1.101.5
	FSF:1.1.101;
locks; strict;
comment	@ * @;


1.2
date	2016.11.06.20.14.59;	author tg;	state Exp;
branches;
next	1.1;
commitid	100581F8F0A4217341C;

1.1
date	2005.02.05.00.18.42;	author tg;	state Exp;
branches
	1.1.101.1;
next	;

1.1.101.1
date	2005.02.05.00.18.42;	author tg;	state Exp;
branches;
next	1.1.101.2;

1.1.101.2
date	2005.03.28.15.39.28;	author tg;	state Exp;
branches;
next	1.1.101.3;

1.1.101.3
date	2005.05.14.16.47.47;	author tg;	state Exp;
branches;
next	1.1.101.4;
commitid	3a6242862a097542;

1.1.101.4
date	2005.06.05.17.45.33;	author tg;	state Exp;
branches;
next	1.1.101.5;
commitid	7ce142a33a2d11fb;

1.1.101.5
date	2005.07.07.15.31.31;	author tg;	state Exp;
branches;
next	;
commitid	598542cd4ac1fb58;


desc
@@


1.2
log
@spelling
@
text
@/* tc-arm.c -- Assemble for the ARM
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
   2004, 2005
   Free Software Foundation, Inc.
   Contributed by Richard Earnshaw (rwe@@pegasus.esprit.ec.org)
	Modified by David Taylor (dtaylor@@armltd.co.uk)
	Cirrus coprocessor mods by Aldy Hernandez (aldyh@@redhat.com)
	Cirrus coprocessor fixes by Petko Manolov (petkan@@nucleusys.com)
	Cirrus coprocessor fixes by Vladimir Ivanov (vladitx@@nucleusys.com)

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include <string.h>
#define	 NO_RELOC 0
#include "as.h"
#include "safe-ctype.h"

/* Need TARGET_CPU.  */
#include "config.h"
#include "subsegs.h"
#include "obstack.h"
#include "symbols.h"
#include "listing.h"

#include "opcode/arm.h"

#ifdef OBJ_ELF
#include "elf/arm.h"
#include "dwarf2dbg.h"
#include "dw2gencfi.h"
#endif

/* XXX Set this to 1 after the next binutils release.  */
#define WARN_DEPRECATED 0

#ifdef OBJ_ELF
/* Must be at least the size of the largest unwind opcode (currently two).  */
#define ARM_OPCODE_CHUNK_SIZE 8

/* This structure holds the unwinding state.  */

static struct
{
  symbolS *	  proc_start;
  symbolS *	  table_entry;
  symbolS *	  personality_routine;
  int		  personality_index;
  /* The segment containing the function.  */
  segT		  saved_seg;
  subsegT	  saved_subseg;
  /* Opcodes generated from this function.  */
  unsigned char * opcodes;
  int		  opcode_count;
  int		  opcode_alloc;
  /* The number of bytes pushed to the stack.  */
  offsetT	  frame_size;
  /* We don't add stack adjustment opcodes immediately so that we can merge
     multiple adjustments.  We can also omit the final adjustment
     when using a frame pointer.  */
  offsetT	  pending_offset;
  /* These two fields are set by both unwind_movsp and unwind_setfp.  They
     hold the reg+offset to use when restoring sp from a frame pointer.	 */
  offsetT	  fp_offset;
  int		  fp_reg;
  /* Nonzero if an unwind_setfp directive has been seen.  */
  unsigned	  fp_used:1;
  /* Nonzero if the last opcode restores sp from fp_reg.  */
  unsigned	  sp_restored:1;
} unwind;

/* Bit N indicates that an R_ARM_NONE relocation has been output for
   __aeabi_unwind_cpp_prN already if set. This enables dependencies to be
   emitted only once per section, to save unnecessary bloat.  */
static unsigned int marked_pr_dependency = 0;

#endif /* OBJ_ELF */

enum arm_float_abi
{
  ARM_FLOAT_ABI_HARD,
  ARM_FLOAT_ABI_SOFTFP,
  ARM_FLOAT_ABI_SOFT
};

/* Types of processor to assemble for.	*/
#define ARM_1		ARM_ARCH_V1
#define ARM_2		ARM_ARCH_V2
#define ARM_3		ARM_ARCH_V2S
#define ARM_250		ARM_ARCH_V2S
#define ARM_6		ARM_ARCH_V3
#define ARM_7		ARM_ARCH_V3
#define ARM_8		ARM_ARCH_V4
#define ARM_9		ARM_ARCH_V4T
#define ARM_STRONG	ARM_ARCH_V4
#define ARM_CPU_MASK	0x0000000f		/* XXX? */

#ifndef CPU_DEFAULT
#if defined __XSCALE__
#define CPU_DEFAULT	(ARM_ARCH_XSCALE)
#else
#if defined __thumb__
#define CPU_DEFAULT	(ARM_ARCH_V5T)
#else
#define CPU_DEFAULT	ARM_ANY
#endif
#endif
#endif

#ifndef FPU_DEFAULT
# ifdef TE_LINUX
#  define FPU_DEFAULT FPU_ARCH_FPA
# elif defined (TE_NetBSD)
#  ifdef OBJ_ELF
#   define FPU_DEFAULT FPU_ARCH_VFP	/* Soft-float, but VFP order.  */
#  else
    /* Legacy a.out format.  */
#   define FPU_DEFAULT FPU_ARCH_FPA	/* Soft-float, but FPA order.  */
#  endif
# elif defined (TE_VXWORKS)
#  define FPU_DEFAULT FPU_ARCH_VFP	/* Soft-float, VFP order.  */
# else
   /* For backwards compatibility, default to FPA.  */
#  define FPU_DEFAULT FPU_ARCH_FPA
# endif
#endif /* ifndef FPU_DEFAULT */

#define streq(a, b)	      (strcmp (a, b) == 0)

static unsigned long cpu_variant;

/* Flags stored in private area of BFD structure.  */
static int uses_apcs_26	     = FALSE;
static int atpcs	     = FALSE;
static int support_interwork = FALSE;
static int uses_apcs_float   = FALSE;
static int pic_code	     = FALSE;

/* Variables that we set while parsing command-line options.  Once all
   options have been read we re-process these values to set the real
   assembly flags.  */
static int legacy_cpu = -1;
static int legacy_fpu = -1;

static int mcpu_cpu_opt = -1;
static int mcpu_fpu_opt = -1;
static int march_cpu_opt = -1;
static int march_fpu_opt = -1;
static int mfpu_opt = -1;
static int mfloat_abi_opt = -1;
#ifdef OBJ_ELF
# ifdef EABI_DEFAULT
static int meabi_flags = EABI_DEFAULT;
# else
static int meabi_flags = EF_ARM_EABI_UNKNOWN;
# endif
#endif

#ifdef OBJ_ELF
/* Pre-defined "_GLOBAL_OFFSET_TABLE_"	*/
symbolS * GOT_symbol;
#endif

/* Size of relocation record.  */
const int md_reloc_size = 8;

/* 0: assemble for ARM,
   1: assemble for Thumb,
   2: assemble for Thumb even though target CPU does not support thumb
      instructions.  */
static int thumb_mode = 0;

/* If unified_syntax is true, we are processing the new unified
   ARM/Thumb syntax.  Important differences from the old ARM mode:

     - Immediate operands do not require a # prefix.
     - Conditional affixes always appear at the end of the
       instruction.  (For backward compatibility, those instructions
       that formerly had them in the middle, continue to accept them
       there.)
     - The IT instruction may appear, and if it does is validated
       against subsequent conditional affixes.  It does not generate
       machine code.

   Important differences from the old Thumb mode:

     - Immediate operands do not require a # prefix.
     - Most of the V6T2 instructions are only available in unified mode.
     - The .N and .W suffixes are recognized and honored (it is an error
       if they cannot be honored).
     - All instructions set the flags if and only if they have an 's' affix.
     - Conditional affixes may be used.  They are validated against
       preceding IT instructions.  Unlike ARM mode, you cannot use a
       conditional affix except in the scope of an IT instruction.  */

static bfd_boolean unified_syntax = FALSE;

struct arm_it
{
  const char *	error;
  unsigned long instruction;
  int		size;
  int		size_req;
  int		cond;
  struct
  {
    bfd_reloc_code_real_type type;
    expressionS		     exp;
    int			     pc_rel;
  } reloc;

  struct
  {
    unsigned reg;
    signed int imm;
    unsigned present	: 1;  /* Operand present.  */
    unsigned isreg	: 1;  /* Operand was a register.  */
    unsigned immisreg	: 1;  /* .imm field is a second register.  */
    unsigned hasreloc	: 1;  /* Operand has relocation suffix.  */
    unsigned writeback	: 1;  /* Operand has trailing !  */
    unsigned preind	: 1;  /* Preindexed address.  */
    unsigned postind	: 1;  /* Postindexed address.  */
    unsigned negative	: 1;  /* Index register was negated.  */
    unsigned shifted	: 1;  /* Shift applied to operation.  */
    unsigned shift_kind : 3;  /* Shift operation (enum shift_kind).  */
  } operands[6];
};

static struct arm_it inst;

#define NUM_FLOAT_VALS 8

const char * fp_const[] =
{
  "0.0", "1.0", "2.0", "3.0", "4.0", "5.0", "0.5", "10.0", 0
};

/* Number of littlenums required to hold an extended precision number.	*/
#define MAX_LITTLENUMS 6

LITTLENUM_TYPE fp_values[NUM_FLOAT_VALS][MAX_LITTLENUMS];

#define FAIL	(-1)
#define SUCCESS (0)

#define SUFF_S 1
#define SUFF_D 2
#define SUFF_E 3
#define SUFF_P 4

#define CP_T_X	 0x00008000
#define CP_T_Y	 0x00400000

#define CONDS_BIT	 0x00100000
#define LOAD_BIT	 0x00100000

#define DOUBLE_LOAD_FLAG 0x00000001

struct asm_cond
{
  const char *	template;
  unsigned long value;
};

#define COND_ALWAYS 0xE

struct asm_psr
{
  const char *template;
  unsigned long field;
};

/* The bit that distinguishes CPSR and SPSR.  */
#define SPSR_BIT   (1 << 22)

/* The individual PSR flag bits.  */
#define PSR_c	(1 << 16)
#define PSR_x	(1 << 17)
#define PSR_s	(1 << 18)
#define PSR_f	(1 << 19)

struct reloc_entry
{
  char *name;
  bfd_reloc_code_real_type reloc;
};

enum vfp_sp_reg_pos
{
  VFP_REG_Sd, VFP_REG_Sm, VFP_REG_Sn
};

enum vfp_ldstm_type
{
  VFP_LDSTMIA, VFP_LDSTMDB, VFP_LDSTMIAX, VFP_LDSTMDBX
};

/* ARM register categories.  This includes coprocessor numbers and various
   architecture extensions' registers.	*/
enum arm_reg_type
{
  REG_TYPE_RN,
  REG_TYPE_CP,
  REG_TYPE_CN,
  REG_TYPE_FN,
  REG_TYPE_VFS,
  REG_TYPE_VFD,
  REG_TYPE_VFC,
  REG_TYPE_MVF,
  REG_TYPE_MVD,
  REG_TYPE_MVFX,
  REG_TYPE_MVDX,
  REG_TYPE_MVAX,
  REG_TYPE_DSPSC,
  REG_TYPE_MMXWR,
  REG_TYPE_MMXWC,
  REG_TYPE_MMXWCG,
  REG_TYPE_XSCALE,
};

/* Structure for a hash table entry for a register.  */
struct reg_entry
{
  const char   *name;
  unsigned char number;
  unsigned char type;
  unsigned char builtin;
};

/* Diagnostics used when we don't get a register of the expected type.	*/
const char *const reg_expected_msgs[] =
{
  N_("ARM register expected"),
  N_("bad or missing co-processor number"),
  N_("co-processor register expected"),
  N_("FPA register expected"),
  N_("VFP single precision register expected"),
  N_("VFP double precision register expected"),
  N_("VFP system register expected"),
  N_("Maverick MVF register expected"),
  N_("Maverick MVD register expected"),
  N_("Maverick MVFX register expected"),
  N_("Maverick MVDX register expected"),
  N_("Maverick MVAX register expected"),
  N_("Maverick DSPSC register expected"),
  N_("iWMMXt data register expected"),
  N_("iWMMXt control register expected"),
  N_("iWMMXt scalar register expected"),
  N_("XScale accumulator register expected"),
};

/* Some well known registers that we refer to directly elsewhere.  */
#define REG_SP	13
#define REG_LR	14
#define REG_PC	15

/* ARM instructions take 4bytes in the object file, Thumb instructions
   take 2:  */
#define INSN_SIZE	4

struct asm_opcode
{
  /* Basic string to match.  */
  const char *template;

  /* Parameters to instruction.	 */
  unsigned char operands[8];

  /* Conditional tag - see opcode_lookup.  */
  unsigned int tag : 4;

  /* Basic instruction code.  */
  unsigned int avalue : 28;

  /* Thumb-format instruction code.  */
  unsigned int tvalue;

  /* Which architecture variant provides this instruction.  */
  unsigned long avariant;
  unsigned long tvariant;

  /* Function to call to encode instruction in ARM format.  */
  void (* aencode) (void);

  /* Function to call to encode instruction in Thumb format.  */
  void (* tencode) (void);
};

/* Defines for various bits that we will want to toggle.  */
#define INST_IMMEDIATE	0x02000000
#define OFFSET_REG	0x02000000
#define HWOFFSET_IMM	0x00400000
#define SHIFT_BY_REG	0x00000010
#define PRE_INDEX	0x01000000
#define INDEX_UP	0x00800000
#define WRITE_BACK	0x00200000
#define LDM_TYPE_2_OR_3	0x00400000

#define LITERAL_MASK	0xf000f000
#define OPCODE_MASK	0xfe1fffff
#define V4_STR_BIT	0x00000020

#define DATA_OP_SHIFT	21

/* Codes to distinguish the arithmetic instructions.  */
#define OPCODE_AND	0
#define OPCODE_EOR	1
#define OPCODE_SUB	2
#define OPCODE_RSB	3
#define OPCODE_ADD	4
#define OPCODE_ADC	5
#define OPCODE_SBC	6
#define OPCODE_RSC	7
#define OPCODE_TST	8
#define OPCODE_TEQ	9
#define OPCODE_CMP	10
#define OPCODE_CMN	11
#define OPCODE_ORR	12
#define OPCODE_MOV	13
#define OPCODE_BIC	14
#define OPCODE_MVN	15

#define T_OPCODE_MUL 0x4340
#define T_OPCODE_TST 0x4200
#define T_OPCODE_CMN 0x42c0
#define T_OPCODE_NEG 0x4240
#define T_OPCODE_MVN 0x43c0

#define T_OPCODE_ADD_R3	0x1800
#define T_OPCODE_SUB_R3 0x1a00
#define T_OPCODE_ADD_HI 0x4400
#define T_OPCODE_ADD_ST 0xb000
#define T_OPCODE_SUB_ST 0xb080
#define T_OPCODE_ADD_SP 0xa800
#define T_OPCODE_ADD_PC 0xa000
#define T_OPCODE_ADD_I8 0x3000
#define T_OPCODE_SUB_I8 0x3800
#define T_OPCODE_ADD_I3 0x1c00
#define T_OPCODE_SUB_I3 0x1e00

#define T_OPCODE_ASR_R	0x4100
#define T_OPCODE_LSL_R	0x4080
#define T_OPCODE_LSR_R	0x40c0
#define T_OPCODE_ROR_R	0x41c0
#define T_OPCODE_ASR_I	0x1000
#define T_OPCODE_LSL_I	0x0000
#define T_OPCODE_LSR_I	0x0800

#define T_OPCODE_MOV_I8	0x2000
#define T_OPCODE_CMP_I8 0x2800
#define T_OPCODE_CMP_LR 0x4280
#define T_OPCODE_MOV_HR 0x4600
#define T_OPCODE_CMP_HR 0x4500

#define T_OPCODE_LDR_PC 0x4800
#define T_OPCODE_LDR_SP 0x9800
#define T_OPCODE_STR_SP 0x9000
#define T_OPCODE_LDR_IW 0x6800
#define T_OPCODE_STR_IW 0x6000
#define T_OPCODE_LDR_IH 0x8800
#define T_OPCODE_STR_IH 0x8000
#define T_OPCODE_LDR_IB 0x7800
#define T_OPCODE_STR_IB 0x7000
#define T_OPCODE_LDR_RW 0x5800
#define T_OPCODE_STR_RW 0x5000
#define T_OPCODE_LDR_RH 0x5a00
#define T_OPCODE_STR_RH 0x5200
#define T_OPCODE_LDR_RB 0x5c00
#define T_OPCODE_STR_RB 0x5400

#define T_OPCODE_PUSH	0xb400
#define T_OPCODE_POP	0xbc00

#define T_OPCODE_BRANCH 0xe000

#define THUMB_SIZE	2	/* Size of thumb instruction.  */
#define THUMB_PP_PC_LR 0x0100
#define THUMB_LOAD_BIT 0x0800

#define BAD_ARGS	_("bad arguments to instruction")
#define BAD_PC		_("r15 not allowed here")
#define BAD_COND	_("instruction cannot be conditional")
#define BAD_OVERLAP	_("registers may not be the same")
#define BAD_HIREG	_("lo register required")
#define BAD_THUMB32	_("instruction not supported in Thumb16 mode")

static struct hash_control *arm_ops_hsh;
static struct hash_control *arm_cond_hsh;
static struct hash_control *arm_shift_hsh;
static struct hash_control *arm_psr_hsh;
static struct hash_control *arm_reg_hsh;
static struct hash_control *arm_reloc_hsh;

/* Stuff needed to resolve the label ambiguity
   As:
     ...
     label:   <insn>
   may differ from:
     ...
     label:
	      <insn>
*/

symbolS *  last_label_seen;
static int label_is_thumb_function_name = FALSE;

/* Literal pool structure.  Held on a per-section
   and per-sub-section basis.  */

#define MAX_LITERAL_POOL_SIZE 1024
typedef struct literal_pool
{
  expressionS	 literals [MAX_LITERAL_POOL_SIZE];
  unsigned int	 next_free_entry;
  unsigned int	 id;
  symbolS *	 symbol;
  segT		 section;
  subsegT	 sub_section;
  struct literal_pool * next;
} literal_pool;

/* Pointer to a linked list of literal pools.  */
literal_pool * list_of_pools = NULL;

/* Pure syntax.	 */

/* This array holds the chars that always start a comment.  If the
   pre-processor is disabled, these aren't very useful.	 */
const char comment_chars[] = "@@";

/* This array holds the chars that only start a comment at the beginning of
   a line.  If the line seems to have the form '# 123 filename'
   .line and .file directives will appear in the pre-processed output.	*/
/* Note that input_file.c hand checks for '#' at the beginning of the
   first line of the input file.  This is because the compiler outputs
   #NO_APP at the beginning of its output.  */
/* Also note that comments like this one will always work.  */
const char line_comment_chars[] = "#";

const char line_separator_chars[] = ";";

/* Chars that can be used to separate mant
   from exp in floating point numbers.	*/
const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant.  */
/* As in 0f12.456  */
/* or	 0d1.2345e12  */

const char FLT_CHARS[] = "rRsSfFdDxXeEpP";

/* Prefix characters that indicate the start of an immediate
   value.  */
#define is_immediate_prefix(C) ((C) == '#' || (C) == '$')

/* Separator character handling.  */

#define skip_whitespace(str)  do { if (*(str) == ' ') ++(str); } while (0)

static inline int
skip_past_char (char ** str, char c)
{
  if (**str == c)
    {
      (*str)++;
      return SUCCESS;
    }
  else
    return FAIL;
}
#define skip_past_comma(str) skip_past_char (str, ',')

/* Arithmetic expressions (possibly involving symbols).	 */

/* Return TRUE if anything in the expression is a bignum.  */

static int
walk_no_bignums (symbolS * sp)
{
  if (symbol_get_value_expression (sp)->X_op == O_big)
    return 1;

  if (symbol_get_value_expression (sp)->X_add_symbol)
    {
      return (walk_no_bignums (symbol_get_value_expression (sp)->X_add_symbol)
	      || (symbol_get_value_expression (sp)->X_op_symbol
		  && walk_no_bignums (symbol_get_value_expression (sp)->X_op_symbol)));
    }

  return 0;
}

static int in_my_get_expression = 0;

/* Third argument to my_get_expression.	 */
#define GE_NO_PREFIX 0
#define GE_IMM_PREFIX 1
#define GE_OPT_PREFIX 2

static int
my_get_expression (expressionS * ep, char ** str, int prefix_mode)
{
  char * save_in;
  segT	 seg;

  /* In unified syntax, all prefixes are optional.  */
  if (unified_syntax)
    prefix_mode = GE_OPT_PREFIX;

  switch (prefix_mode)
    {
    case GE_NO_PREFIX: break;
    case GE_IMM_PREFIX:
      if (!is_immediate_prefix (**str))
	{
	  inst.error = _("immediate expression requires a # prefix");
	  return FAIL;
	}
      (*str)++;
      break;
    case GE_OPT_PREFIX:
      if (is_immediate_prefix (**str))
	(*str)++;
      break;
    default: abort ();
    }

  memset (ep, 0, sizeof (expressionS));

  save_in = input_line_pointer;
  input_line_pointer = *str;
  in_my_get_expression = 1;
  seg = expression (ep);
  in_my_get_expression = 0;

  if (ep->X_op == O_illegal)
    {
      /* We found a bad expression in md_operand().  */
      *str = input_line_pointer;
      input_line_pointer = save_in;
      if (inst.error == NULL)
	inst.error = _("bad expression");
      return 1;
    }

#ifdef OBJ_AOUT
  if (seg != absolute_section
      && seg != text_section
      && seg != data_section
      && seg != bss_section
      && seg != undefined_section)
    {
      inst.error = _("bad segment");
      *str = input_line_pointer;
      input_line_pointer = save_in;
      return 1;
    }
#endif

  /* Get rid of any bignums now, so that we don't generate an error for which
     we can't establish a line number later on.	 Big numbers are never valid
     in instructions, which is where this routine is always called.  */
  if (ep->X_op == O_big
      || (ep->X_add_symbol
	  && (walk_no_bignums (ep->X_add_symbol)
	      || (ep->X_op_symbol
		  && walk_no_bignums (ep->X_op_symbol)))))
    {
      inst.error = _("invalid constant");
      *str = input_line_pointer;
      input_line_pointer = save_in;
      return 1;
    }

  *str = input_line_pointer;
  input_line_pointer = save_in;
  return 0;
}

/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.

   Note that fp constants aren't represent in the normal way on the ARM.
   In big endian mode, things are as expected.	However, in little endian
   mode fp constants are big-endian word-wise, and little-endian byte-wise
   within the words.  For example, (double) 1.1 in big endian mode is
   the byte sequence 3f f1 99 99 99 99 99 9a, and in little endian mode is
   the byte sequence 99 99 f1 3f 9a 99 99 99.

   ??? The format of 12 byte floats is uncertain according to gcc's arm.h.  */

char *
md_atof (int type, char * litP, int * sizeP)
{
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  char *t;
  int i;

  switch (type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

    case 'x':
    case 'X':
      prec = 6;
      break;

    case 'p':
    case 'P':
      prec = 6;
      break;

    default:
      *sizeP = 0;
      return _("bad call to MD_ATOF()");
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;
  *sizeP = prec * 2;

  if (target_big_endian)
    {
      for (i = 0; i < prec; i++)
	{
	  md_number_to_chars (litP, (valueT) words[i], 2);
	  litP += 2;
	}
    }
  else
    {
      if (cpu_variant & FPU_ARCH_VFP)
	for (i = prec - 1; i >= 0; i--)
	  {
	    md_number_to_chars (litP, (valueT) words[i], 2);
	    litP += 2;
	  }
      else
	/* For a 4 byte float the order of elements in `words' is 1 0.
	   For an 8 byte float the order is 1 0 3 2.  */
	for (i = 0; i < prec; i += 2)
	  {
	    md_number_to_chars (litP, (valueT) words[i + 1], 2);
	    md_number_to_chars (litP + 2, (valueT) words[i], 2);
	    litP += 4;
	  }
    }

  return 0;
}

/* We handle all bad expressions here, so that we can report the faulty
   instruction in the error message.  */
void
md_operand (expressionS * expr)
{
  if (in_my_get_expression)
    expr->X_op = O_illegal;
}

/* Immediate values.  */

/* Generic immediate-value read function for use in directives.
   Accepts anything that 'expression' can fold to a constant.
   *val receives the number.  */
#ifdef OBJ_ELF
static int
immediate_for_directive (int *val)
{
  expressionS exp;
  exp.X_op = O_illegal;

  if (is_immediate_prefix (*input_line_pointer))
    {
      input_line_pointer++;
      expression (&exp);
    }

  if (exp.X_op != O_constant)
    {
      as_bad (_("expected #constant"));
      ignore_rest_of_line ();
      return FAIL;
    }
  *val = exp.X_add_number;
  return SUCCESS;
}
#endif

/* Register parsing.  */

/* Generic register parser.  CCP points to what should be the
   beginning of a register name.  If it is indeed a valid register
   name, advance CCP over it and return the reg_entry structure;
   otherwise return NULL.  Does not issue diagnostics.	*/

static struct reg_entry *
arm_reg_parse_multi (char **ccp)
{
  char *start = *ccp;
  char *p;
  struct reg_entry *reg;

#ifdef REGISTER_PREFIX
  if (*start != REGISTER_PREFIX)
    return FAIL;
  start++;
#endif
#ifdef OPTIONAL_REGISTER_PREFIX
  if (*start == OPTIONAL_REGISTER_PREFIX)
    start++;
#endif

  p = start;
  if (!ISALPHA (*p) || !is_name_beginner (*p))
    return NULL;

  do
    p++;
  while (ISALPHA (*p) || ISDIGIT (*p) || *p == '_');

  reg = (struct reg_entry *) hash_find_n (arm_reg_hsh, start, p - start);

  if (!reg)
    return NULL;

  *ccp = p;
  return reg;
}

/* As above, but the register must be of type TYPE, and the return
   value is the register number or NULL.  */

static int
arm_reg_parse (char **ccp, enum arm_reg_type type)
{
  char *start = *ccp;
  struct reg_entry *reg = arm_reg_parse_multi (ccp);

  if (reg && reg->type == type)
    return reg->number;

  /* Alternative syntaxes are accepted for a few register classes.  */
  switch (type)
    {
    case REG_TYPE_MVF:
    case REG_TYPE_MVD:
    case REG_TYPE_MVFX:
    case REG_TYPE_MVDX:
      /* Generic coprocessor register names are allowed for these.  */
      if (reg->type == REG_TYPE_CN)
	return reg->number;
      break;

    case REG_TYPE_CP:
      /* For backward compatibility, a bare number is valid here.  */
      {
	unsigned long processor = strtoul (start, ccp, 10);
	if (*ccp != start && processor <= 15)
	  return processor;
      }

    case REG_TYPE_MMXWC:
      /* WC includes WCG.  ??? I'm not sure this is true for all
	 instructions that take WC registers.  */
      if (reg->type == REG_TYPE_MMXWCG)
	return reg->number;
      break;

    default:
      break;
    }

  *ccp = start;
  return FAIL;
}

/* Parse an ARM register list.  Returns the bitmask, or FAIL.  */
static long
parse_reg_list (char ** strp)
{
  char * str = * strp;
  long	 range = 0;
  int	 another_range;

  /* We come back here if we get ranges concatenated by '+' or '|'.  */
  do
    {
      another_range = 0;

      if (*str == '{')
	{
	  int in_range = 0;
	  int cur_reg = -1;

	  str++;
	  do
	    {
	      int reg;

	      if ((reg = arm_reg_parse (&str, REG_TYPE_RN)) == FAIL)
		{
		  inst.error = _(reg_expected_msgs[REG_TYPE_RN]);
		  return FAIL;
		}

	      if (in_range)
		{
		  int i;

		  if (reg <= cur_reg)
		    {
		      inst.error = _("bad range in register list");
		      return FAIL;
		    }

		  for (i = cur_reg + 1; i < reg; i++)
		    {
		      if (range & (1 << i))
			as_tsktsk
			  (_("Warning: duplicated register (r%d) in register list"),
			   i);
		      else
			range |= 1 << i;
		    }
		  in_range = 0;
		}

	      if (range & (1 << reg))
		as_tsktsk (_("Warning: duplicated register (r%d) in register list"),
			   reg);
	      else if (reg <= cur_reg)
		as_tsktsk (_("Warning: register range not in ascending order"));

	      range |= 1 << reg;
	      cur_reg = reg;
	    }
	  while (skip_past_comma (&str) != FAIL
		 || (in_range = 1, *str++ == '-'));
	  str--;

	  if (*str++ != '}')
	    {
	      inst.error = _("missing `}'");
	      return FAIL;
	    }
	}
      else
	{
	  expressionS expr;

	  if (my_get_expression (&expr, &str, GE_NO_PREFIX))
	    return FAIL;

	  if (expr.X_op == O_constant)
	    {
	      if (expr.X_add_number
		  != (expr.X_add_number & 0x0000ffff))
		{
		  inst.error = _("invalid register mask");
		  return FAIL;
		}

	      if ((range & expr.X_add_number) != 0)
		{
		  int regno = range & expr.X_add_number;

		  regno &= -regno;
		  regno = (1 << regno) - 1;
		  as_tsktsk
		    (_("Warning: duplicated register (r%d) in register list"),
		     regno);
		}

	      range |= expr.X_add_number;
	    }
	  else
	    {
	      if (inst.reloc.type != 0)
		{
		  inst.error = _("expression too complex");
		  return FAIL;
		}

	      memcpy (&inst.reloc.exp, &expr, sizeof (expressionS));
	      inst.reloc.type = BFD_RELOC_ARM_MULTI;
	      inst.reloc.pc_rel = 0;
	    }
	}

      if (*str == '|' || *str == '+')
	{
	  str++;
	  another_range = 1;
	}
    }
  while (another_range);

  *strp = str;
  return range;
}

/* Parse a VFP register list.  If the string is invalid return FAIL.
   Otherwise return the number of registers, and set PBASE to the first
   register.  Double precision registers are matched if DP is nonzero.	*/

static int
parse_vfp_reg_list (char **str, unsigned int *pbase, int dp)
{
  int base_reg;
  int new_base;
  int regtype;
  int max_regs;
  int count = 0;
  int warned = 0;
  unsigned long mask = 0;
  int i;

  if (**str != '{')
    return FAIL;

  (*str)++;

  if (dp)
    {
      regtype = REG_TYPE_VFD;
      max_regs = 16;
    }
  else
    {
      regtype = REG_TYPE_VFS;
      max_regs = 32;
    }

  base_reg = max_regs;

  do
    {
      new_base = arm_reg_parse (str, regtype);
      if (new_base == FAIL)
	{
	  inst.error = gettext (reg_expected_msgs[regtype]);
	  return FAIL;
	}

      if (new_base < base_reg)
	base_reg = new_base;

      if (mask & (1 << new_base))
	{
	  inst.error = _("invalid register list");
	  return FAIL;
	}

      if ((mask >> new_base) != 0 && ! warned)
	{
	  as_tsktsk (_("register list not in ascending order"));
	  warned = 1;
	}

      mask |= 1 << new_base;
      count++;

      if (**str == '-') /* We have the start of a range expression */
	{
	  int high_range;

	  (*str)++;

	  if ((high_range = arm_reg_parse (str, regtype)) == FAIL)
	    {
	      inst.error = gettext (reg_expected_msgs[regtype]);
	      return FAIL;
	    }

	  if (high_range <= new_base)
	    {
	      inst.error = _("register range not in ascending order");
	      return FAIL;
	    }

	  for (new_base++; new_base <= high_range; new_base++)
	    {
	      if (mask & (1 << new_base))
		{
		  inst.error = _("invalid register list");
		  return FAIL;
		}

	      mask |= 1 << new_base;
	      count++;
	    }
	}
    }
  while (skip_past_comma (str) != FAIL);

  (*str)++;

  /* Sanity check -- should have raised a parse error above.  */
  if (count == 0 || count > max_regs)
    abort ();

  *pbase = base_reg;

  /* Final test -- the registers must be consecutive.  */
  mask >>= base_reg;
  for (i = 0; i < count; i++)
    {
      if ((mask & (1u << i)) == 0)
	{
	  inst.error = _("non-contiguous register range");
	  return FAIL;
	}
    }

  return count;
}

/* Parse an explicit relocation suffix on an expression.  This is
   either nothing, or a word in parentheses.  Note that if !OBJ_ELF,
   arm_reloc_hsh contains no entries, so this function can only
   succeed if there is no () after the word.  Returns -1 on error,
   BFD_RELOC_UNUSED if there wasn't any suffix.	 */
static int
parse_reloc (char **str)
{
  struct reloc_entry *r;
  char *p, *q;

  if (**str != '(')
    return BFD_RELOC_UNUSED;

  p = *str + 1;
  q = p;

  while (*q && *q != ')' && *q != ',')
    q++;
  if (*q != ')')
    return -1;

  if ((r = hash_find_n (arm_reloc_hsh, p, q - p)) == NULL)
    return -1;

  *str = q + 1;
  return r->reloc;
}

/* Directives: register aliases.  */

static void
insert_reg_alias (char *str, int number, int type)
{
  struct reg_entry *new;
  const char *name;

  if ((new = hash_find (arm_reg_hsh, str)) != 0)
    {
      if (new->builtin)
	as_warn (_("ignoring attempt to redefine built-in register '%s'"), str);

      /* Only warn about a redefinition if it's not defined as the
	 same register.	 */
      else if (new->number != number || new->type != type)
	as_warn (_("ignoring redefinition of register alias '%s'"), str);

      return;
    }

  name = xstrdup (str);
  new = xmalloc (sizeof (struct reg_entry));

  new->name = name;
  new->number = number;
  new->type = type;
  new->builtin = FALSE;

  if (hash_insert (arm_reg_hsh, name, (PTR) new))
    abort ();
}

/* Look for the .req directive.	 This is of the form:

	new_register_name .req existing_register_name

   If we find one, or if it looks sufficiently like one that we want to
   handle any error here, return non-zero.  Otherwise return zero.  */

static int
create_register_alias (char * newname, char *p)
{
  struct reg_entry *old;
  char *oldname, *nbuf;
  size_t nlen;

  /* The input scrubber ensures that whitespace after the mnemonic is
     collapsed to single spaces.  */
  oldname = p;
  if (strncmp (oldname, " .req ", 6) != 0)
    return 0;

  oldname += 6;
  if (*oldname == '\0')
    return 0;

  old = hash_find (arm_reg_hsh, oldname);
  if (!old)
    {
      as_warn (_("unknown register '%s' -- .req ignored"), oldname);
      return 1;
    }

  /* If TC_CASE_SENSITIVE is defined, then newname already points to
     the desired alias name, and p points to its end.  If not, then
     the desired alias name is in the global original_case_string.  */
#ifdef TC_CASE_SENSITIVE
  nlen = p - newname;
#else
  newname = original_case_string;
  nlen = strlen (newname);
#endif

  nbuf = alloca (nlen + 1);
  memcpy (nbuf, newname, nlen);
  nbuf[nlen] = '\0';

  /* Create aliases under the new name as stated; an all-lowercase
     version of the new name; and an all-uppercase version of the new
     name.  */
  insert_reg_alias (nbuf, old->number, old->type);

  for (p = nbuf; *p; p++)
    *p = TOUPPER (*p);

  if (strncmp (nbuf, newname, nlen))
    insert_reg_alias (nbuf, old->number, old->type);

  for (p = nbuf; *p; p++)
    *p = TOLOWER (*p);

  if (strncmp (nbuf, newname, nlen))
    insert_reg_alias (nbuf, old->number, old->type);

  return 1;
}

/* Should never be called, as .req goes between the alias and the
   register name, not at the beginning of the line.  */
static void
s_req (int a ATTRIBUTE_UNUSED)
{
  as_bad (_("invalid syntax for .req directive"));
}

/* The .unreq directive deletes an alias which was previously defined
   by .req.  For example:

       my_alias .req r11
       .unreq my_alias	  */

static void
s_unreq (int a ATTRIBUTE_UNUSED)
{
  char * name;
  char saved_char;

  name = input_line_pointer;

  while (*input_line_pointer != 0
	 && *input_line_pointer != ' '
	 && *input_line_pointer != '\n')
    ++input_line_pointer;

  saved_char = *input_line_pointer;
  *input_line_pointer = 0;

  if (!*name)
    as_bad (_("invalid syntax for .unreq directive"));
  else
    {
      struct reg_entry *reg = hash_find (arm_reg_hsh, name);

      if (!reg)
	as_bad (_("unknown register alias '%s'"), name);
      else if (reg->builtin)
	as_warn (_("ignoring attempt to undefine built-in register '%s'"),
		 name);
      else
	{
	  hash_delete (arm_reg_hsh, name);
	  free ((char *) reg->name);
	  free (reg);
	}
    }

  *input_line_pointer = saved_char;
  demand_empty_rest_of_line ();
}

/* Directives: Instruction set selection.  */

#ifdef OBJ_ELF
/* This code is to handle mapping symbols as defined in the ARM ELF spec.
   (See "Mapping symbols", section 4.5.5, ARM AAELF version 1.0).
   Note that previously, $a and $t has type STT_FUNC (BSF_OBJECT flag),
   and $d has type STT_OBJECT (BSF_OBJECT flag). Now all three are untyped.  */

static enum mstate mapstate = MAP_UNDEFINED;

static void
mapping_state (enum mstate state)
{
  symbolS * symbolP;
  const char * symname;
  int type;

  if (mapstate == state)
    /* The mapping symbol has already been emitted.
       There is nothing else to do.  */
    return;

  mapstate = state;

  switch (state)
    {
    case MAP_DATA:
      symname = "$d";
      type = BSF_NO_FLAGS;
      break;
    case MAP_ARM:
      symname = "$a";
      type = BSF_NO_FLAGS;
      break;
    case MAP_THUMB:
      symname = "$t";
      type = BSF_NO_FLAGS;
      break;
    case MAP_UNDEFINED:
      return;
    default:
      abort ();
    }

  seg_info (now_seg)->tc_segment_info_data.mapstate = state;

  symbolP = symbol_new (symname, now_seg, (valueT) frag_now_fix (), frag_now);
  symbol_table_insert (symbolP);
  symbol_get_bfdsym (symbolP)->flags |= type | BSF_LOCAL;

  switch (state)
    {
    case MAP_ARM:
      THUMB_SET_FUNC (symbolP, 0);
      ARM_SET_THUMB (symbolP, 0);
      ARM_SET_INTERWORK (symbolP, support_interwork);
      break;

    case MAP_THUMB:
      THUMB_SET_FUNC (symbolP, 1);
      ARM_SET_THUMB (symbolP, 1);
      ARM_SET_INTERWORK (symbolP, support_interwork);
      break;

    case MAP_DATA:
    default:
      return;
    }
}
#else
#define mapping_state(x) /* nothing */
#endif

/* Find the real, Thumb encoded start of a Thumb function.  */

static symbolS *
find_real_start (symbolS * symbolP)
{
  char *       real_start;
  const char * name = S_GET_NAME (symbolP);
  symbolS *    new_target;

  /* This definition must agree with the one in gcc/config/arm/thumb.c.	 */
#define STUB_NAME ".real_start_of"

  if (name == NULL)
    abort ();

  /* The compiler may generate BL instructions to local labels because
     it needs to perform a branch to a far away location. These labels
     do not have a corresponding ".real_start_of" label.  We check
     both for S_IS_LOCAL and for a leading dot, to give a way to bypass
     the ".real_start_of" convention for nonlocal branches.  */
  if (S_IS_LOCAL (symbolP) || name[0] == '.')
    return symbolP;

  real_start = ACONCAT ((STUB_NAME, name, NULL));
  new_target = symbol_find (real_start);

  if (new_target == NULL)
    {
      as_warn ("Failed to find real start of function: %s\n", name);
      new_target = symbolP;
    }

  return new_target;
}

static void
opcode_select (int width)
{
  switch (width)
    {
    case 16:
      if (! thumb_mode)
	{
	  if (! (cpu_variant & ARM_EXT_V4T))
	    as_bad (_("selected processor does not support THUMB opcodes"));

	  thumb_mode = 1;
	  /* No need to force the alignment, since we will have been
	     coming from ARM mode, which is word-aligned.  */
	  record_alignment (now_seg, 1);
	}
      mapping_state (MAP_THUMB);
      break;

    case 32:
      if (thumb_mode)
	{
	  if ((cpu_variant & ARM_ALL) == ARM_EXT_V4T)
	    as_bad (_("selected processor does not support ARM opcodes"));

	  thumb_mode = 0;

	  if (!need_pass_2)
	    frag_align (2, 0, 0);

	  record_alignment (now_seg, 1);
	}
      mapping_state (MAP_ARM);
      break;

    default:
      as_bad (_("invalid instruction size selected (%d)"), width);
    }
}

static void
s_arm (int ignore ATTRIBUTE_UNUSED)
{
  opcode_select (32);
  demand_empty_rest_of_line ();
}

static void
s_thumb (int ignore ATTRIBUTE_UNUSED)
{
  opcode_select (16);
  demand_empty_rest_of_line ();
}

static void
s_code (int unused ATTRIBUTE_UNUSED)
{
  int temp;

  temp = get_absolute_expression ();
  switch (temp)
    {
    case 16:
    case 32:
      opcode_select (temp);
      break;

    default:
      as_bad (_("invalid operand to .code directive (%d) (expecting 16 or 32)"), temp);
    }
}

static void
s_force_thumb (int ignore ATTRIBUTE_UNUSED)
{
  /* If we are not already in thumb mode go into it, EVEN if
     the target processor does not support thumb instructions.
     This is used by gcc/config/arm/lib1funcs.asm for example
     to compile interworking support functions even if the
     target processor should not support interworking.	*/
  if (! thumb_mode)
    {
      thumb_mode = 2;
      record_alignment (now_seg, 1);
    }

  demand_empty_rest_of_line ();
}

static void
s_thumb_func (int ignore ATTRIBUTE_UNUSED)
{
  s_thumb (0);

  /* The following label is the name/address of the start of a Thumb function.
     We need to know this for the interworking support.	 */
  label_is_thumb_function_name = TRUE;
}

/* Perform a .set directive, but also mark the alias as
   being a thumb function.  */

static void
s_thumb_set (int equiv)
{
  /* XXX the following is a duplicate of the code for s_set() in read.c
     We cannot just call that code as we need to get at the symbol that
     is created.  */
  char *    name;
  char	    delim;
  char *    end_name;
  symbolS * symbolP;

  /* Especial apologies for the random logic:
     This just grew, and could be parsed much more simply!
     Dean - in haste.  */
  name	    = input_line_pointer;
  delim	    = get_symbol_end ();
  end_name  = input_line_pointer;
  *end_name = delim;

  if (*input_line_pointer != ',')
    {
      *end_name = 0;
      as_bad (_("expected comma after name \"%s\""), name);
      *end_name = delim;
      ignore_rest_of_line ();
      return;
    }

  input_line_pointer++;
  *end_name = 0;

  if (name[0] == '.' && name[1] == '\0')
    {
      /* XXX - this should not happen to .thumb_set.  */
      abort ();
    }

  if ((symbolP = symbol_find (name)) == NULL
      && (symbolP = md_undefined_symbol (name)) == NULL)
    {
#ifndef NO_LISTING
      /* When doing symbol listings, play games with dummy fragments living
	 outside the normal fragment chain to record the file and line info
	 for this symbol.  */
      if (listing & LISTING_SYMBOLS)
	{
	  extern struct list_info_struct * listing_tail;
	  fragS * dummy_frag = xmalloc (sizeof (fragS));

	  memset (dummy_frag, 0, sizeof (fragS));
	  dummy_frag->fr_type = rs_fill;
	  dummy_frag->line = listing_tail;
	  symbolP = symbol_new (name, undefined_section, 0, dummy_frag);
	  dummy_frag->fr_symbol = symbolP;
	}
      else
#endif
	symbolP = symbol_new (name, undefined_section, 0, &zero_address_frag);

#ifdef OBJ_COFF
      /* "set" symbols are local unless otherwise specified.  */
      SF_SET_LOCAL (symbolP);
#endif /* OBJ_COFF  */
    }				/* Make a new symbol.  */

  symbol_table_insert (symbolP);

  * end_name = delim;

  if (equiv
      && S_IS_DEFINED (symbolP)
      && S_GET_SEGMENT (symbolP) != reg_section)
    as_bad (_("symbol `%s' already defined"), S_GET_NAME (symbolP));

  pseudo_set (symbolP);

  demand_empty_rest_of_line ();

  /* XXX Now we come to the Thumb specific bit of code.	 */

  THUMB_SET_FUNC (symbolP, 1);
  ARM_SET_THUMB (symbolP, 1);
#if defined OBJ_ELF || defined OBJ_COFF
  ARM_SET_INTERWORK (symbolP, support_interwork);
#endif
}

/* Directives: Mode selection.  */

/* .syntax [unified|divided] - choose the new unified syntax
   (same for Arm and Thumb encoding, modulo slight differences in what
   can be represented) or the old divergent syntax for each mode.  */
static void
s_syntax (int unused ATTRIBUTE_UNUSED)
{
  char *name, delim;

  name = input_line_pointer;
  delim = get_symbol_end ();

  if (!strcasecmp (name, "unified"))
    unified_syntax = TRUE;
  else if (!strcasecmp (name, "divided"))
    unified_syntax = FALSE;
  else
    {
      as_bad (_("unrecognized syntax mode \"%s\""), name);
      return;
    }
  *input_line_pointer = delim;
  demand_empty_rest_of_line ();
}

/* Directives: sectioning and alignment.  */

/* Same as s_align_ptwo but align 0 => align 2.	 */

static void
s_align (int unused ATTRIBUTE_UNUSED)
{
  int temp;
  long temp_fill;
  long max_alignment = 15;

  temp = get_absolute_expression ();
  if (temp > max_alignment)
    as_bad (_("alignment too large: %d assumed"), temp = max_alignment);
  else if (temp < 0)
    {
      as_bad (_("alignment negative. 0 assumed."));
      temp = 0;
    }

  if (*input_line_pointer == ',')
    {
      input_line_pointer++;
      temp_fill = get_absolute_expression ();
    }
  else
    temp_fill = 0;

  if (!temp)
    temp = 2;

  /* Only make a frag if we HAVE to.  */
  if (temp && !need_pass_2)
    frag_align (temp, (int) temp_fill, 0);
  demand_empty_rest_of_line ();

  record_alignment (now_seg, temp);
}

static void
s_bss (int ignore ATTRIBUTE_UNUSED)
{
  /* We don't support putting frags in the BSS segment, we fake it by
     marking in_bss, then looking at s_skip for clues.	*/
  subseg_set (bss_section, 0);
  demand_empty_rest_of_line ();
  mapping_state (MAP_DATA);
}

static void
s_even (int ignore ATTRIBUTE_UNUSED)
{
  /* Never make frag if expect extra pass.  */
  if (!need_pass_2)
    frag_align (1, 0, 0);

  record_alignment (now_seg, 1);

  demand_empty_rest_of_line ();
}

/* Directives: Literal pools.  */

static literal_pool *
find_literal_pool (void)
{
  literal_pool * pool;

  for (pool = list_of_pools; pool != NULL; pool = pool->next)
    {
      if (pool->section == now_seg
	  && pool->sub_section == now_subseg)
	break;
    }

  return pool;
}

static literal_pool *
find_or_make_literal_pool (void)
{
  /* Next literal pool ID number.  */
  static unsigned int latest_pool_num = 1;
  literal_pool *      pool;

  pool = find_literal_pool ();

  if (pool == NULL)
    {
      /* Create a new pool.  */
      pool = xmalloc (sizeof (* pool));
      if (! pool)
	return NULL;

      pool->next_free_entry = 0;
      pool->section	    = now_seg;
      pool->sub_section	    = now_subseg;
      pool->next	    = list_of_pools;
      pool->symbol	    = NULL;

      /* Add it to the list.  */
      list_of_pools = pool;
    }

  /* New pools, and emptied pools, will have a NULL symbol.  */
  if (pool->symbol == NULL)
    {
      pool->symbol = symbol_create (FAKE_LABEL_NAME, undefined_section,
				    (valueT) 0, &zero_address_frag);
      pool->id = latest_pool_num ++;
    }

  /* Done.  */
  return pool;
}

/* Add the literal in the global 'inst'
   structure to the relevent literal pool.  */

static int
add_to_lit_pool (void)
{
  literal_pool * pool;
  unsigned int entry;

  pool = find_or_make_literal_pool ();

  /* Check if this literal value is already in the pool.  */
  for (entry = 0; entry < pool->next_free_entry; entry ++)
    {
      if ((pool->literals[entry].X_op == inst.reloc.exp.X_op)
	  && (inst.reloc.exp.X_op == O_constant)
	  && (pool->literals[entry].X_add_number
	      == inst.reloc.exp.X_add_number)
	  && (pool->literals[entry].X_unsigned
	      == inst.reloc.exp.X_unsigned))
	break;

      if ((pool->literals[entry].X_op == inst.reloc.exp.X_op)
	  && (inst.reloc.exp.X_op == O_symbol)
	  && (pool->literals[entry].X_add_number
	      == inst.reloc.exp.X_add_number)
	  && (pool->literals[entry].X_add_symbol
	      == inst.reloc.exp.X_add_symbol)
	  && (pool->literals[entry].X_op_symbol
	      == inst.reloc.exp.X_op_symbol))
	break;
    }

  /* Do we need to create a new entry?	*/
  if (entry == pool->next_free_entry)
    {
      if (entry >= MAX_LITERAL_POOL_SIZE)
	{
	  inst.error = _("literal pool overflow");
	  return FAIL;
	}

      pool->literals[entry] = inst.reloc.exp;
      pool->next_free_entry += 1;
    }

  inst.reloc.exp.X_op	      = O_symbol;
  inst.reloc.exp.X_add_number = ((int) entry) * 4;
  inst.reloc.exp.X_add_symbol = pool->symbol;

  return SUCCESS;
}

/* Can't use symbol_new here, so have to create a symbol and then at
   a later date assign it a value. Thats what these functions do.  */

static void
symbol_locate (symbolS *    symbolP,
	       const char * name,	/* It is copied, the caller can modify.	 */
	       segT	    segment,	/* Segment identifier (SEG_<something>).  */
	       valueT	    valu,	/* Symbol value.  */
	       fragS *	    frag)	/* Associated fragment.	 */
{
  unsigned int name_length;
  char * preserved_copy_of_name;

  name_length = strlen (name) + 1;   /* +1 for \0.  */
  obstack_grow (&notes, name, name_length);
  preserved_copy_of_name = obstack_finish (&notes);

#ifdef tc_canonicalize_symbol_name
  preserved_copy_of_name =
    tc_canonicalize_symbol_name (preserved_copy_of_name);
#endif

  S_SET_NAME (symbolP, preserved_copy_of_name);

  S_SET_SEGMENT (symbolP, segment);
  S_SET_VALUE (symbolP, valu);
  symbol_clear_list_pointers (symbolP);

  symbol_set_frag (symbolP, frag);

  /* Link to end of symbol chain.  */
  {
    extern int symbol_table_frozen;

    if (symbol_table_frozen)
      abort ();
  }

  symbol_append (symbolP, symbol_lastP, & symbol_rootP, & symbol_lastP);

  obj_symbol_new_hook (symbolP);

#ifdef tc_symbol_new_hook
  tc_symbol_new_hook (symbolP);
#endif

#ifdef DEBUG_SYMS
  verify_symbol_chain (symbol_rootP, symbol_lastP);
#endif /* DEBUG_SYMS  */
}


static void
s_ltorg (int ignored ATTRIBUTE_UNUSED)
{
  unsigned int entry;
  literal_pool * pool;
  char sym_name[20];

  pool = find_literal_pool ();
  if (pool == NULL
      || pool->symbol == NULL
      || pool->next_free_entry == 0)
    return;

  mapping_state (MAP_DATA);

  /* Align pool as you have word accesses.
     Only make a frag if we have to.  */
  if (!need_pass_2)
    frag_align (2, 0, 0);

  record_alignment (now_seg, 2);

  sprintf (sym_name, "$$lit_\002%x", pool->id);

  symbol_locate (pool->symbol, sym_name, now_seg,
		 (valueT) frag_now_fix (), frag_now);
  symbol_table_insert (pool->symbol);

  ARM_SET_THUMB (pool->symbol, thumb_mode);

#if defined OBJ_COFF || defined OBJ_ELF
  ARM_SET_INTERWORK (pool->symbol, support_interwork);
#endif

  for (entry = 0; entry < pool->next_free_entry; entry ++)
    /* First output the expression in the instruction to the pool.  */
    emit_expr (&(pool->literals[entry]), 4); /* .word  */

  /* Mark the pool as empty.  */
  pool->next_free_entry = 0;
  pool->symbol = NULL;
}

#ifdef OBJ_ELF
/* Forward declarations for functions below, in the MD interface
   section.  */
static void fix_new_arm (fragS *, int, short, expressionS *, int, int);
static valueT create_unwind_entry (int);
static void start_unwind_section (const segT, int);
static void add_unwind_opcode (valueT, int);
static void flush_pending_unwind (void);

/* Directives: Data.  */

static void
s_arm_elf_cons (int nbytes)
{
  expressionS exp;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  if (is_it_end_of_statement ())
    {
      demand_empty_rest_of_line ();
      return;
    }

#ifdef md_cons_align
  md_cons_align (nbytes);
#endif

  mapping_state (MAP_DATA);
  do
    {
      int reloc;
      char *base = input_line_pointer;

      expression (& exp);

      if (exp.X_op != O_symbol)
	emit_expr (&exp, (unsigned int) nbytes);
      else
	{
	  char *before_reloc = input_line_pointer;
	  reloc = parse_reloc (&input_line_pointer);
	  if (reloc == -1)
	    {
	      as_bad (_("unrecognized relocation suffix"));
	      ignore_rest_of_line ();
	      return;
	    }
	  else if (reloc == BFD_RELOC_UNUSED)
	    emit_expr (&exp, (unsigned int) nbytes);
	  else
	    {
	      reloc_howto_type *howto = bfd_reloc_type_lookup (stdoutput, reloc);
	      int size = bfd_get_reloc_size (howto);

	      if (reloc == BFD_RELOC_ARM_PLT32)
		{
		  as_bad (_("(plt) is only valid on branch targets"));
		  reloc = BFD_RELOC_UNUSED;
		  size = 0;
		}

	      if (size > nbytes)
		as_bad (_("%s relocations do not fit in %d bytes"),
			howto->name, nbytes);
	      else
		{
		  /* We've parsed an expression stopping at O_symbol.
		     But there may be more expression left now that we
		     have parsed the relocation marker.  Parse it again.
		     XXX Surely there is a cleaner way to do this.  */
		  char *p = input_line_pointer;
		  int offset;
		  char *save_buf = alloca (input_line_pointer - base);
		  memcpy (save_buf, base, input_line_pointer - base);
		  memmove (base + (input_line_pointer - before_reloc),
			   base, before_reloc - base);

		  input_line_pointer = base + (input_line_pointer-before_reloc);
		  expression (&exp);
		  memcpy (base, save_buf, p - base);

		  offset = nbytes - size;
		  p = frag_more ((int) nbytes);
		  fix_new_exp (frag_now, p - frag_now->fr_literal + offset,
			       size, &exp, 0, reloc);
		}
	    }
	}
    }
  while (*input_line_pointer++ == ',');

  /* Put terminator back into stream.  */
  input_line_pointer --;
  demand_empty_rest_of_line ();
}


/* Parse a .rel31 directive.  */

static void
s_arm_rel31 (int ignored ATTRIBUTE_UNUSED)
{
  expressionS exp;
  char *p;
  valueT highbit;

  highbit = 0;
  if (*input_line_pointer == '1')
    highbit = 0x80000000;
  else if (*input_line_pointer != '0')
    as_bad (_("expected 0 or 1"));

  input_line_pointer++;
  if (*input_line_pointer != ',')
    as_bad (_("missing comma"));
  input_line_pointer++;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

#ifdef md_cons_align
  md_cons_align (4);
#endif

  mapping_state (MAP_DATA);

  expression (&exp);

  p = frag_more (4);
  md_number_to_chars (p, highbit, 4);
  fix_new_arm (frag_now, p - frag_now->fr_literal, 4, &exp, 1,
	       BFD_RELOC_ARM_PREL31);

  demand_empty_rest_of_line ();
}

/* Directives: AEABI stack-unwind tables.  */

/* Parse an unwind_fnstart directive.  Simply records the current location.  */

static void
s_arm_unwind_fnstart (int ignored ATTRIBUTE_UNUSED)
{
  demand_empty_rest_of_line ();
  /* Mark the start of the function.  */
  unwind.proc_start = expr_build_dot ();

  /* Reset the rest of the unwind info.	 */
  unwind.opcode_count = 0;
  unwind.table_entry = NULL;
  unwind.personality_routine = NULL;
  unwind.personality_index = -1;
  unwind.frame_size = 0;
  unwind.fp_offset = 0;
  unwind.fp_reg = 13;
  unwind.fp_used = 0;
  unwind.sp_restored = 0;
}


/* Parse a handlerdata directive.  Creates the exception handling table entry
   for the function.  */

static void
s_arm_unwind_handlerdata (int ignored ATTRIBUTE_UNUSED)
{
  demand_empty_rest_of_line ();
  if (unwind.table_entry)
    as_bad (_("dupicate .handlerdata directive"));

  create_unwind_entry (1);
}

/* Parse an unwind_fnend directive.  Generates the index table entry.  */

static void
s_arm_unwind_fnend (int ignored ATTRIBUTE_UNUSED)
{
  long where;
  char *ptr;
  valueT val;

  demand_empty_rest_of_line ();

  /* Add eh table entry.  */
  if (unwind.table_entry == NULL)
    val = create_unwind_entry (0);
  else
    val = 0;

  /* Add index table entry.  This is two words.	 */
  start_unwind_section (unwind.saved_seg, 1);
  frag_align (2, 0, 0);
  record_alignment (now_seg, 2);

  ptr = frag_more (8);
  where = frag_now_fix () - 8;

  /* Self relative offset of the function start.  */
  fix_new (frag_now, where, 4, unwind.proc_start, 0, 1,
	   BFD_RELOC_ARM_PREL31);

  /* Indicate dependency on EHABI-defined personality routines to the
     linker, if it hasn't been done already.  */
  if (unwind.personality_index >= 0 && unwind.personality_index < 3
      && !(marked_pr_dependency & (1 << unwind.personality_index)))
    {
      static const char *const name[] = {
	"__aeabi_unwind_cpp_pr0",
	"__aeabi_unwind_cpp_pr1",
	"__aeabi_unwind_cpp_pr2"
      };
      symbolS *pr = symbol_find_or_make (name[unwind.personality_index]);
      fix_new (frag_now, where, 0, pr, 0, 1, BFD_RELOC_NONE);
      marked_pr_dependency |= 1 << unwind.personality_index;
      seg_info (now_seg)->tc_segment_info_data.marked_pr_dependency
	= marked_pr_dependency;
    }

  if (val)
    /* Inline exception table entry.  */
    md_number_to_chars (ptr + 4, val, 4);
  else
    /* Self relative offset of the table entry.	 */
    fix_new (frag_now, where + 4, 4, unwind.table_entry, 0, 1,
	     BFD_RELOC_ARM_PREL31);

  /* Restore the original section.  */
  subseg_set (unwind.saved_seg, unwind.saved_subseg);
}


/* Parse an unwind_cantunwind directive.  */

static void
s_arm_unwind_cantunwind (int ignored ATTRIBUTE_UNUSED)
{
  demand_empty_rest_of_line ();
  if (unwind.personality_routine || unwind.personality_index != -1)
    as_bad (_("personality routine specified for cantunwind frame"));

  unwind.personality_index = -2;
}


/* Parse a personalityindex directive.	*/

static void
s_arm_unwind_personalityindex (int ignored ATTRIBUTE_UNUSED)
{
  expressionS exp;

  if (unwind.personality_routine || unwind.personality_index != -1)
    as_bad (_("duplicate .personalityindex directive"));

  expression (&exp);

  if (exp.X_op != O_constant
      || exp.X_add_number < 0 || exp.X_add_number > 15)
    {
      as_bad (_("bad personality routine number"));
      ignore_rest_of_line ();
      return;
    }

  unwind.personality_index = exp.X_add_number;

  demand_empty_rest_of_line ();
}


/* Parse a personality directive.  */

static void
s_arm_unwind_personality (int ignored ATTRIBUTE_UNUSED)
{
  char *name, *p, c;

  if (unwind.personality_routine || unwind.personality_index != -1)
    as_bad (_("duplicate .personality directive"));

  name = input_line_pointer;
  c = get_symbol_end ();
  p = input_line_pointer;
  unwind.personality_routine = symbol_find_or_make (name);
  *p = c;
  demand_empty_rest_of_line ();
}


/* Parse a directive saving core registers.  */

static void
s_arm_unwind_save_core (void)
{
  valueT op;
  long range;
  int n;

  range = parse_reg_list (&input_line_pointer);
  if (range == FAIL)
    {
      as_bad (_("expected register list"));
      ignore_rest_of_line ();
      return;
    }

  demand_empty_rest_of_line ();

  /* Turn .unwind_movsp ip followed by .unwind_save {..., ip, ...}
     into .unwind_save {..., sp...}.  We aren't bothered about the value of
     ip because it is clobbered by calls.  */
  if (unwind.sp_restored && unwind.fp_reg == 12
      && (range & 0x3000) == 0x1000)
    {
      unwind.opcode_count--;
      unwind.sp_restored = 0;
      range = (range | 0x2000) & ~0x1000;
      unwind.pending_offset = 0;
    }

  /* See if we can use the short opcodes.  These pop a block of upto 8
     registers starting with r4, plus maybe r14.  */
  for (n = 0; n < 8; n++)
    {
      /* Break at the first non-saved register.	 */
      if ((range & (1 << (n + 4))) == 0)
	break;
    }
  /* See if there are any other bits set.  */
  if (n == 0 || (range & (0xfff0 << n) & 0xbff0) != 0)
    {
      /* Use the long form.  */
      op = 0x8000 | ((range >> 4) & 0xfff);
      add_unwind_opcode (op, 2);
    }
  else
    {
      /* Use the short form.  */
      if (range & 0x4000)
	op = 0xa8; /* Pop r14.	*/
      else
	op = 0xa0; /* Do not pop r14.  */
      op |= (n - 1);
      add_unwind_opcode (op, 1);
    }

  /* Pop r0-r3.	 */
  if (range & 0xf)
    {
      op = 0xb100 | (range & 0xf);
      add_unwind_opcode (op, 2);
    }

  /* Record the number of bytes pushed.	 */
  for (n = 0; n < 16; n++)
    {
      if (range & (1 << n))
	unwind.frame_size += 4;
    }
}


/* Parse a directive saving FPA registers.  */

static void
s_arm_unwind_save_fpa (int reg)
{
  expressionS exp;
  int num_regs;
  valueT op;

  /* Get Number of registers to transfer.  */
  if (skip_past_comma (&input_line_pointer) != FAIL)
    expression (&exp);
  else
    exp.X_op = O_illegal;

  if (exp.X_op != O_constant)
    {
      as_bad (_("expected , <constant>"));
      ignore_rest_of_line ();
      return;
    }

  num_regs = exp.X_add_number;

  if (num_regs < 1 || num_regs > 4)
    {
      as_bad (_("number of registers must be in the range [1:4]"));
      ignore_rest_of_line ();
      return;
    }

  demand_empty_rest_of_line ();

  if (reg == 4)
    {
      /* Short form.  */
      op = 0xb4 | (num_regs - 1);
      add_unwind_opcode (op, 1);
    }
  else
    {
      /* Long form.  */
      op = 0xc800 | (reg << 4) | (num_regs - 1);
      add_unwind_opcode (op, 2);
    }
  unwind.frame_size += num_regs * 12;
}


/* Parse a directive saving VFP registers.  */

static void
s_arm_unwind_save_vfp (void)
{
  int count;
  unsigned int reg;
  valueT op;

  count = parse_vfp_reg_list (&input_line_pointer, &reg, 1);
  if (count == FAIL)
    {
      as_bad (_("expected register list"));
      ignore_rest_of_line ();
      return;
    }

  demand_empty_rest_of_line ();

  if (reg == 8)
    {
      /* Short form.  */
      op = 0xb8 | (count - 1);
      add_unwind_opcode (op, 1);
    }
  else
    {
      /* Long form.  */
      op = 0xb300 | (reg << 4) | (count - 1);
      add_unwind_opcode (op, 2);
    }
  unwind.frame_size += count * 8 + 4;
}


/* Parse a directive saving iWMMXt data registers.  */

static void
s_arm_unwind_save_mmxwr (void)
{
  int reg;
  int hi_reg;
  int i;
  unsigned mask = 0;
  valueT op;

  if (*input_line_pointer == '{')
    input_line_pointer++;

  do
    {
      reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWR);

      if (reg == FAIL)
	{
	  as_bad (_(reg_expected_msgs[REG_TYPE_MMXWR]));
	  goto error;
	}

      if (mask >> reg)
	as_tsktsk (_("register list not in ascending order"));
      mask |= 1 << reg;

      if (*input_line_pointer == '-')
	{
	  input_line_pointer++;
	  hi_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWR);
	  if (hi_reg == FAIL)
	    {
	      as_bad (_(reg_expected_msgs[REG_TYPE_MMXWR]));
	      goto error;
	    }
	  else if (reg >= hi_reg)
	    {
	      as_bad (_("bad register range"));
	      goto error;
	    }
	  for (; reg < hi_reg; reg++)
	    mask |= 1 << reg;
	}
    }
  while (skip_past_comma (&input_line_pointer) != FAIL);

  if (*input_line_pointer == '}')
    input_line_pointer++;

  demand_empty_rest_of_line ();

  /* Generate any deferred opcodes becuuse we're going to be looking at
     the list.	*/
  flush_pending_unwind ();

  for (i = 0; i < 16; i++)
    {
      if (mask & (1 << i))
	unwind.frame_size += 8;
    }

  /* Attempt to combine with a previous opcode.	 We do this because gcc
     likes to output separate unwind directives for a single block of
     registers.	 */
  if (unwind.opcode_count > 0)
    {
      i = unwind.opcodes[unwind.opcode_count - 1];
      if ((i & 0xf8) == 0xc0)
	{
	  i &= 7;
	  /* Only merge if the blocks are contiguous.  */
	  if (i < 6)
	    {
	      if ((mask & 0xfe00) == (1 << 9))
		{
		  mask |= ((1 << (i + 11)) - 1) & 0xfc00;
		  unwind.opcode_count--;
		}
	    }
	  else if (i == 6 && unwind.opcode_count >= 2)
	    {
	      i = unwind.opcodes[unwind.opcode_count - 2];
	      reg = i >> 4;
	      i &= 0xf;

	      op = 0xffff << (reg - 1);
	      if (reg > 0
		  || ((mask & op) == (1u << (reg - 1))))
		{
		  op = (1 << (reg + i + 1)) - 1;
		  op &= ~((1 << reg) - 1);
		  mask |= op;
		  unwind.opcode_count -= 2;
		}
	    }
	}
    }

  hi_reg = 15;
  /* We want to generate opcodes in the order the registers have been
     saved, ie. descending order.  */
  for (reg = 15; reg >= -1; reg--)
    {
      /* Save registers in blocks.  */
      if (reg < 0
	  || !(mask & (1 << reg)))
	{
	  /* We found an unsaved reg.  Generate opcodes to save the
	     preceeding block.	*/
	  if (reg != hi_reg)
	    {
	      if (reg == 9)
		{
		  /* Short form.  */
		  op = 0xc0 | (hi_reg - 10);
		  add_unwind_opcode (op, 1);
		}
	      else
		{
		  /* Long form.	 */
		  op = 0xc600 | ((reg + 1) << 4) | ((hi_reg - reg) - 1);
		  add_unwind_opcode (op, 2);
		}
	    }
	  hi_reg = reg - 1;
	}
    }

  return;
error:
  ignore_rest_of_line ();
}

static void
s_arm_unwind_save_mmxwcg (void)
{
  int reg;
  int hi_reg;
  unsigned mask = 0;
  valueT op;

  if (*input_line_pointer == '{')
    input_line_pointer++;

  do
    {
      reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWCG);

      if (reg == FAIL)
	{
	  as_bad (_(reg_expected_msgs[REG_TYPE_MMXWCG]));
	  goto error;
	}

      reg -= 8;
      if (mask >> reg)
	as_tsktsk (_("register list not in ascending order"));
      mask |= 1 << reg;

      if (*input_line_pointer == '-')
	{
	  input_line_pointer++;
	  hi_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWCG);
	  if (hi_reg == FAIL)
	    {
	      as_bad (_(reg_expected_msgs[REG_TYPE_MMXWCG]));
	      goto error;
	    }
	  else if (reg >= hi_reg)
	    {
	      as_bad (_("bad register range"));
	      goto error;
	    }
	  for (; reg < hi_reg; reg++)
	    mask |= 1 << reg;
	}
    }
  while (skip_past_comma (&input_line_pointer) != FAIL);

  if (*input_line_pointer == '}')
    input_line_pointer++;

  demand_empty_rest_of_line ();

  /* Generate any deferred opcodes becuuse we're going to be looking at
     the list.	*/
  flush_pending_unwind ();

  for (reg = 0; reg < 16; reg++)
    {
      if (mask & (1 << reg))
	unwind.frame_size += 4;
    }
  op = 0xc700 | mask;
  add_unwind_opcode (op, 2);
  return;
error:
  ignore_rest_of_line ();
}


/* Parse an unwind_save directive.  */

static void
s_arm_unwind_save (int ignored ATTRIBUTE_UNUSED)
{
  char *peek;
  struct reg_entry *reg;
  bfd_boolean had_brace = FALSE;

  /* Figure out what sort of save we have.  */
  peek = input_line_pointer;

  if (*peek == '{')
    {
      had_brace = TRUE;
      peek++;
    }

  reg = arm_reg_parse_multi (&peek);

  if (!reg)
    {
      as_bad (_("register expected"));
      ignore_rest_of_line ();
      return;
    }

  switch (reg->type)
    {
    case REG_TYPE_FN:
      if (had_brace)
	{
	  as_bad (_("FPA .unwind_save does not take a register list"));
	  ignore_rest_of_line ();
	  return;
	}
      s_arm_unwind_save_fpa (reg->number);
      return;

    case REG_TYPE_RN:	  s_arm_unwind_save_core ();   return;
    case REG_TYPE_VFD:	   s_arm_unwind_save_vfp ();	return;
    case REG_TYPE_MMXWR:  s_arm_unwind_save_mmxwr ();  return;
    case REG_TYPE_MMXWCG: s_arm_unwind_save_mmxwcg (); return;

    default:
      as_bad (_(".unwind_save does not support this kind of register"));
      ignore_rest_of_line ();
    }
}


/* Parse an unwind_movsp directive.  */

static void
s_arm_unwind_movsp (int ignored ATTRIBUTE_UNUSED)
{
  int reg;
  valueT op;

  reg = arm_reg_parse (&input_line_pointer, REG_TYPE_RN);
  if (reg == FAIL)
    {
      as_bad (_(reg_expected_msgs[REG_TYPE_RN]));
      ignore_rest_of_line ();
      return;
    }
  demand_empty_rest_of_line ();

  if (reg == REG_SP || reg == REG_PC)
    {
      as_bad (_("SP and PC not permitted in .unwind_movsp directive"));
      return;
    }

  if (unwind.fp_reg != REG_SP)
    as_bad (_("unexpected .unwind_movsp directive"));

  /* Generate opcode to restore the value.  */
  op = 0x90 | reg;
  add_unwind_opcode (op, 1);

  /* Record the information for later.	*/
  unwind.fp_reg = reg;
  unwind.fp_offset = unwind.frame_size;
  unwind.sp_restored = 1;
}

/* Parse an unwind_pad directive.  */

static void
s_arm_unwind_pad (int ignored ATTRIBUTE_UNUSED)
{
  int offset;

  if (immediate_for_directive (&offset) == FAIL)
    return;

  if (offset & 3)
    {
      as_bad (_("stack increment must be multiple of 4"));
      ignore_rest_of_line ();
      return;
    }

  /* Don't generate any opcodes, just record the details for later.  */
  unwind.frame_size += offset;
  unwind.pending_offset += offset;

  demand_empty_rest_of_line ();
}

/* Parse an unwind_setfp directive.  */

static void
s_arm_unwind_setfp (int ignored ATTRIBUTE_UNUSED)
{
  int sp_reg;
  int fp_reg;
  int offset;

  fp_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_RN);
  if (skip_past_comma (&input_line_pointer) == FAIL)
    sp_reg = FAIL;
  else
    sp_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_RN);

  if (fp_reg == FAIL || sp_reg == FAIL)
    {
      as_bad (_("expected <reg>, <reg>"));
      ignore_rest_of_line ();
      return;
    }

  /* Optional constant.	 */
  if (skip_past_comma (&input_line_pointer) != FAIL)
    {
      if (immediate_for_directive (&offset) == FAIL)
	return;
    }
  else
    offset = 0;

  demand_empty_rest_of_line ();

  if (sp_reg != 13 && sp_reg != unwind.fp_reg)
    {
      as_bad (_("register must be either sp or set by a previous"
		"unwind_movsp directive"));
      return;
    }

  /* Don't generate any opcodes, just record the information for later.	 */
  unwind.fp_reg = fp_reg;
  unwind.fp_used = 1;
  if (sp_reg == 13)
    unwind.fp_offset = unwind.frame_size - offset;
  else
    unwind.fp_offset -= offset;
}

/* Parse an unwind_raw directive.  */

static void
s_arm_unwind_raw (int ignored ATTRIBUTE_UNUSED)
{
  expressionS exp;
  /* This is an arbitary limit.	 */
  unsigned char op[16];
  int count;

  expression (&exp);
  if (exp.X_op == O_constant
      && skip_past_comma (&input_line_pointer) != FAIL)
    {
      unwind.frame_size += exp.X_add_number;
      expression (&exp);
    }
  else
    exp.X_op = O_illegal;

  if (exp.X_op != O_constant)
    {
      as_bad (_("expected <offset>, <opcode>"));
      ignore_rest_of_line ();
      return;
    }

  count = 0;

  /* Parse the opcode.	*/
  for (;;)
    {
      if (count >= 16)
	{
	  as_bad (_("unwind opcode too long"));
	  ignore_rest_of_line ();
	}
      if (exp.X_op != O_constant || exp.X_add_number & ~0xff)
	{
	  as_bad (_("invalid unwind opcode"));
	  ignore_rest_of_line ();
	  return;
	}
      op[count++] = exp.X_add_number;

      /* Parse the next byte.  */
      if (skip_past_comma (&input_line_pointer) == FAIL)
	break;

      expression (&exp);
    }

  /* Add the opcode bytes in reverse order.  */
  while (count--)
    add_unwind_opcode (op[count], 1);

  demand_empty_rest_of_line ();
}
#endif /* OBJ_ELF */

/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
     pseudo-op name without dot
     function to call to execute this pseudo-op
     Integer arg to pass to the function.  */

const pseudo_typeS md_pseudo_table[] =
{
  /* Never called because '.req' does not start a line.	 */
  { "req",	   s_req,	  0 },
  { "unreq",	   s_unreq,	  0 },
  { "bss",	   s_bss,	  0 },
  { "align",	   s_align,	  0 },
  { "arm",	   s_arm,	  0 },
  { "thumb",	   s_thumb,	  0 },
  { "code",	   s_code,	  0 },
  { "force_thumb", s_force_thumb, 0 },
  { "thumb_func",  s_thumb_func,  0 },
  { "thumb_set",   s_thumb_set,	  0 },
  { "even",	   s_even,	  0 },
  { "ltorg",	   s_ltorg,	  0 },
  { "pool",	   s_ltorg,	  0 },
  { "syntax",	   s_syntax,	  0 },
#ifdef OBJ_ELF
  { "word",	   s_arm_elf_cons, 4 },
  { "long",	   s_arm_elf_cons, 4 },
  { "rel31",	   s_arm_rel31,	  0 },
  { "fnstart",		s_arm_unwind_fnstart,	0 },
  { "fnend",		s_arm_unwind_fnend,	0 },
  { "cantunwind",	s_arm_unwind_cantunwind, 0 },
  { "personality",	s_arm_unwind_personality, 0 },
  { "personalityindex",	s_arm_unwind_personalityindex, 0 },
  { "handlerdata",	s_arm_unwind_handlerdata, 0 },
  { "save",		s_arm_unwind_save,	0 },
  { "movsp",		s_arm_unwind_movsp,	0 },
  { "pad",		s_arm_unwind_pad,	0 },
  { "setfp",		s_arm_unwind_setfp,	0 },
  { "unwind_raw",	s_arm_unwind_raw,	0 },
#else
  { "word",	   cons, 4},
#endif
  { "extend",	   float_cons, 'x' },
  { "ldouble",	   float_cons, 'x' },
  { "packed",	   float_cons, 'p' },
  { 0, 0, 0 }
};

/* Parser functions used exclusively in instruction operands.  */

/* Generic immediate-value read function for use in insn parsing.
   STR points to the beginning of the immediate (the leading #);
   VAL receives the value; if the value is outside [MIN, MAX]
   issue an error.  PREFIX_OPT is true if the immediate prefix is
   optional.  */

static int
parse_immediate (char **str, int *val, int min, int max,
		 bfd_boolean prefix_opt)
{
  expressionS exp;
  my_get_expression (&exp, str, prefix_opt ? GE_OPT_PREFIX : GE_IMM_PREFIX);
  if (exp.X_op != O_constant)
    {
      inst.error = _("constant expression required");
      return FAIL;
    }

  if (exp.X_add_number < min || exp.X_add_number > max)
    {
      inst.error = _("immediate value out of range");
      return FAIL;
    }

  *val = exp.X_add_number;
  return SUCCESS;
}

/* Returns the pseudo-register number of an FPA immediate constant,
   or FAIL if there isn't a valid constant here.  */

static int
parse_fpa_immediate (char ** str)
{
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  char *	 save_in;
  expressionS	 exp;
  int		 i;
  int		 j;

  /* First try and match exact strings, this is to guarantee
     that some formats will work even for cross assembly.  */

  for (i = 0; fp_const[i]; i++)
    {
      if (strncmp (*str, fp_const[i], strlen (fp_const[i])) == 0)
	{
	  char *start = *str;

	  *str += strlen (fp_const[i]);
	  if (is_end_of_line[(unsigned char) **str])
	    return i + 8;
	  *str = start;
	}
    }

  /* Just because we didn't get a match doesn't mean that the constant
     isn't valid, just that it is in a format that we don't
     automatically recognize.  Try parsing it with the standard
     expression routines.  */

  memset (words, 0, MAX_LITTLENUMS * sizeof (LITTLENUM_TYPE));

  /* Look for a raw floating point number.  */
  if ((save_in = atof_ieee (*str, 'x', words)) != NULL
      && is_end_of_line[(unsigned char) *save_in])
    {
      for (i = 0; i < NUM_FLOAT_VALS; i++)
	{
	  for (j = 0; j < MAX_LITTLENUMS; j++)
	    {
	      if (words[j] != fp_values[i][j])
		break;
	    }

	  if (j == MAX_LITTLENUMS)
	    {
	      *str = save_in;
	      return i + 8;
	    }
	}
    }

  /* Try and parse a more complex expression, this will probably fail
     unless the code uses a floating point prefix (eg "0f").  */
  save_in = input_line_pointer;
  input_line_pointer = *str;
  if (expression (&exp) == absolute_section
      && exp.X_op == O_big
      && exp.X_add_number < 0)
    {
      /* FIXME: 5 = X_PRECISION, should be #define'd where we can use it.
	 Ditto for 15.	*/
      if (gen_to_words (words, 5, (long) 15) == 0)
	{
	  for (i = 0; i < NUM_FLOAT_VALS; i++)
	    {
	      for (j = 0; j < MAX_LITTLENUMS; j++)
		{
		  if (words[j] != fp_values[i][j])
		    break;
		}

	      if (j == MAX_LITTLENUMS)
		{
		  *str = input_line_pointer;
		  input_line_pointer = save_in;
		  return i + 8;
		}
	    }
	}
    }

  *str = input_line_pointer;
  input_line_pointer = save_in;
  inst.error = _("invalid FPA immediate expression");
  return FAIL;
}

/* Shift operands.  */
enum shift_kind
{
  SHIFT_LSL, SHIFT_LSR, SHIFT_ASR, SHIFT_ROR, SHIFT_RRX
};

struct asm_shift_name
{
  const char	  *name;
  enum shift_kind  kind;
};

/* Third argument to parse_shift.  */
enum parse_shift_mode
{
  NO_SHIFT_RESTRICT,		/* Any kind of shift is accepted.  */
  SHIFT_IMMEDIATE,		/* Shift operand must be an immediate.	*/
  SHIFT_LSL_OR_ASR_IMMEDIATE,	/* Shift must be LSL or ASR immediate.	*/
  SHIFT_ASR_IMMEDIATE,		/* Shift must be ASR immediate.	 */
  SHIFT_LSL_IMMEDIATE,		/* Shift must be LSL immediate.	 */
};

/* Parse a <shift> specifier on an ARM data processing instruction.
   This has three forms:

     (LSL|LSR|ASL|ASR|ROR) Rs
     (LSL|LSR|ASL|ASR|ROR) #imm
     RRX

   Note that ASL is assimilated to LSL in the instruction encoding, and
   RRX to ROR #0 (which cannot be written as such).  */

static int
parse_shift (char **str, int i, enum parse_shift_mode mode)
{
  const struct asm_shift_name *shift_name;
  enum shift_kind shift;
  char *s = *str;
  char *p = s;
  int reg;

  for (p = *str; ISALPHA (*p); p++)
    ;

  if (p == *str)
    {
      inst.error = _("shift expression expected");
      return FAIL;
    }

  shift_name = hash_find_n (arm_shift_hsh, *str, p - *str);

  if (shift_name == NULL)
    {
      inst.error = _("shift expression expected");
      return FAIL;
    }

  shift = shift_name->kind;

  switch (mode)
    {
    case NO_SHIFT_RESTRICT:
    case SHIFT_IMMEDIATE:   break;

    case SHIFT_LSL_OR_ASR_IMMEDIATE:
      if (shift != SHIFT_LSL && shift != SHIFT_ASR)
	{
	  inst.error = _("'LSL' or 'ASR' required");
	  return FAIL;
	}
      break;

    case SHIFT_LSL_IMMEDIATE:
      if (shift != SHIFT_LSL)
	{
	  inst.error = _("'LSL' required");
	  return FAIL;
	}
      break;

    case SHIFT_ASR_IMMEDIATE:
      if (shift != SHIFT_ASR)
	{
	  inst.error = _("'ASR' required");
	  return FAIL;
	}
      break;

    default: abort ();
    }

  if (shift != SHIFT_RRX)
    {
      /* Whitespace can appear here if the next thing is a bare digit.	*/
      skip_whitespace (p);

      if (mode == NO_SHIFT_RESTRICT
	  && (reg = arm_reg_parse (&p, REG_TYPE_RN)) != FAIL)
	{
	  inst.operands[i].imm = reg;
	  inst.operands[i].immisreg = 1;
	}
      else if (my_get_expression (&inst.reloc.exp, &p, GE_IMM_PREFIX))
	return FAIL;
    }
  inst.operands[i].shift_kind = shift;
  inst.operands[i].shifted = 1;
  *str = p;
  return SUCCESS;
}

/* Parse a <shifter_operand> for an ARM data processing instruction:

      #<immediate>
      #<immediate>, <rotate>
      <Rm>
      <Rm>, <shift>

   where <shift> is defined by parse_shift above, and <rotate> is a
   multiple of 2 between 0 and 30.  Validation of immediate operands
   is deferred to md_apply_fix.  */

static int
parse_shifter_operand (char **str, int i)
{
  int value;
  expressionS expr;

  if ((value = arm_reg_parse (str, REG_TYPE_RN)) != FAIL)
    {
      inst.operands[i].reg = value;
      inst.operands[i].isreg = 1;

      /* parse_shift will override this if appropriate */
      inst.reloc.exp.X_op = O_constant;
      inst.reloc.exp.X_add_number = 0;

      if (skip_past_comma (str) == FAIL)
	return SUCCESS;

      /* Shift operation on register.  */
      return parse_shift (str, i, NO_SHIFT_RESTRICT);
    }

  if (my_get_expression (&inst.reloc.exp, str, GE_IMM_PREFIX))
    return FAIL;

  if (skip_past_comma (str) == SUCCESS)
    {
      /* #x, y -- ie explicit rotation by Y.  */
      if (my_get_expression (&expr, str, GE_NO_PREFIX))
	return FAIL;

      if (expr.X_op != O_constant || inst.reloc.exp.X_op != O_constant)
	{
	  inst.error = _("constant expression expected");
	  return FAIL;
	}

      value = expr.X_add_number;
      if (value < 0 || value > 30 || value % 2 != 0)
	{
	  inst.error = _("invalid rotation");
	  return FAIL;
	}
      if (inst.reloc.exp.X_add_number < 0 || inst.reloc.exp.X_add_number > 255)
	{
	  inst.error = _("invalid constant");
	  return FAIL;
	}

      /* Convert to decoded value.  md_apply_fix will put it back.  */
      inst.reloc.exp.X_add_number
	= (((inst.reloc.exp.X_add_number << (32 - value))
	    | (inst.reloc.exp.X_add_number >> value)) & 0xffffffff);
    }

  inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;
  inst.reloc.pc_rel = 0;
  return SUCCESS;
}

/* Parse all forms of an ARM address expression.  Information is written
   to inst.operands[i] and/or inst.reloc.

   Preindexed addressing (.preind=1):

   [Rn, #offset]       .reg=Rn .reloc.exp=offset
   [Rn, +/-Rm]	       .reg=Rn .imm=Rm .immisreg=1 .negative=0/1
   [Rn, +/-Rm, shift]  .reg=Rn .imm=Rm .immisreg=1 .negative=0/1
		       .shift_kind=shift .reloc.exp=shift_imm

   These three may have a trailing ! which causes .writeback to be set also.

   Postindexed addressing (.postind=1, .writeback=1):

   [Rn], #offset       .reg=Rn .reloc.exp=offset
   [Rn], +/-Rm	       .reg=Rn .imm=Rm .immisreg=1 .negative=0/1
   [Rn], +/-Rm, shift  .reg=Rn .imm=Rm .immisreg=1 .negative=0/1
		       .shift_kind=shift .reloc.exp=shift_imm

   Unindexed addressing (.preind=0, .postind=0):

   [Rn], {option}      .reg=Rn .imm=option .immisreg=0

   Other:

   [Rn]{!}	       shorthand for [Rn,#0]{!}
   =immediate	       .isreg=0 .reloc.exp=immediate
   label	       .reg=PC .reloc.pc_rel=1 .reloc.exp=label

  It is the caller's responsibility to check for addressing modes not
  supported by the instruction, and to set inst.reloc.type.  */

static int
parse_address (char **str, int i)
{
  char *p = *str;
  int reg;

  if (skip_past_char (&p, '[') == FAIL)
    {
      if (skip_past_char (&p, '=') == FAIL)
	{
	  /* bare address - translate to PC-relative offset */
	  inst.reloc.pc_rel = 1;
	  inst.operands[i].reg = REG_PC;
	  inst.operands[i].isreg = 1;
	  inst.operands[i].preind = 1;
	}
      /* else a load-constant pseudo op, no special treatment needed here */

      if (my_get_expression (&inst.reloc.exp, &p, GE_NO_PREFIX))
	return FAIL;

      *str = p;
      return SUCCESS;
    }

  if ((reg = arm_reg_parse (&p, REG_TYPE_RN)) == FAIL)
    {
      inst.error = _(reg_expected_msgs[REG_TYPE_RN]);
      return FAIL;
    }
  inst.operands[i].reg = reg;
  inst.operands[i].isreg = 1;

  if (skip_past_comma (&p) == SUCCESS)
    {
      inst.operands[i].preind = 1;

      if (*p == '+') p++;
      else if (*p == '-') p++, inst.operands[i].negative = 1;

      if ((reg = arm_reg_parse (&p, REG_TYPE_RN)) != FAIL)
	{
	  inst.operands[i].imm = reg;
	  inst.operands[i].immisreg = 1;

	  if (skip_past_comma (&p) == SUCCESS)
	    if (parse_shift (&p, i, SHIFT_IMMEDIATE) == FAIL)
	      return FAIL;
	}
      else
	{
	  if (inst.operands[i].negative)
	    {
	      inst.operands[i].negative = 0;
	      p--;
	    }
	  if (my_get_expression (&inst.reloc.exp, &p, GE_IMM_PREFIX))
	    return FAIL;
	}
    }

  if (skip_past_char (&p, ']') == FAIL)
    {
      inst.error = _("']' expected");
      return FAIL;
    }

  if (skip_past_char (&p, '!') == SUCCESS)
    inst.operands[i].writeback = 1;

  else if (skip_past_comma (&p) == SUCCESS)
    {
      if (skip_past_char (&p, '{') == SUCCESS)
	{
	  /* [Rn], {expr} - unindexed, with option */
	  if (parse_immediate (&p, &inst.operands[i].imm,
			       0, 255, TRUE) == FAIL)
	    return FAIL;

	  if (skip_past_char (&p, '}') == FAIL)
	    {
	      inst.error = _("'}' expected at end of 'option' field");
	      return FAIL;
	    }
	  if (inst.operands[i].preind)
	    {
	      inst.error = _("cannot combine index with option");
	      return FAIL;
	    }
	  *str = p;
	  return SUCCESS;
	}
      else
	{
	  inst.operands[i].postind = 1;
	  inst.operands[i].writeback = 1;

	  if (inst.operands[i].preind)
	    {
	      inst.error = _("cannot combine pre- and post-indexing");
	      return FAIL;
	    }

	  if (*p == '+') p++;
	  else if (*p == '-') p++, inst.operands[i].negative = 1;

	  if ((reg = arm_reg_parse (&p, REG_TYPE_RN)) != FAIL)
	    {
	      inst.operands[i].imm = reg;
	      inst.operands[i].immisreg = 1;

	      if (skip_past_comma (&p) == SUCCESS)
		if (parse_shift (&p, i, SHIFT_IMMEDIATE) == FAIL)
		  return FAIL;
	    }
	  else
	    {
	      if (inst.operands[i].negative)
		{
		  inst.operands[i].negative = 0;
		  p--;
		}
	      if (my_get_expression (&inst.reloc.exp, &p, GE_IMM_PREFIX))
		return FAIL;
	    }
	}
    }

  /* If at this point neither .preind nor .postind is set, we have a
     bare [Rn]{!}, which is shorthand for [Rn,#0]{!}.  */
  if (inst.operands[i].preind == 0 && inst.operands[i].postind == 0)
    {
      inst.operands[i].preind = 1;
      inst.reloc.exp.X_op = O_constant;
      inst.reloc.exp.X_add_number = 0;
    }
  *str = p;
  return SUCCESS;
}

/* Miscellaneous. */

/* Parse a PSR flag operand.  The value returned is FAIL on syntax error,
   or a bitmask suitable to be or-ed into the ARM msr instruction.  */
static int
parse_psr (char **str)
{
  char *p;
  unsigned long psr_field;

  /* CPSR's and SPSR's can now be lowercase.  This is just a convenience
     feature for ease of use and backwards compatibility.  */
  p = *str;
  if (*p == 's' || *p == 'S')
    psr_field = SPSR_BIT;
  else if (*p == 'c' || *p == 'C')
    psr_field = 0;
  else
    goto error;

  p++;
  if (strncasecmp (p, "PSR", 3) != 0)
    goto error;
  p += 3;

  if (*p == '_')
    {
      /* A suffix follows.  */
      const struct asm_psr *psr;
      char *start;

      p++;
      start = p;

      do
	p++;
      while (ISALNUM (*p) || *p == '_');

      psr = hash_find_n (arm_psr_hsh, start, p - start);
      if (!psr)
	goto error;

      psr_field |= psr->field;
    }
  else
    {
      if (ISALNUM (*p))
	goto error;    /* Garbage after "[CS]PSR".  */

      psr_field |= (PSR_c | PSR_f);
    }
  *str = p;
  return psr_field;

 error:
  inst.error = _("flag for {c}psr instruction expected");
  return FAIL;
}

/* Parse the flags argument to CPSI[ED].  Returns FAIL on error, or a
   value suitable for splatting into the AIF field of the instruction.	*/

static int
parse_cps_flags (char **str)
{
  int val = 0;
  int saw_a_flag = 0;
  char *s = *str;

  for (;;)
    switch (*s++)
      {
      case '\0': case ',':
	goto done;

      case 'a': case 'A': saw_a_flag = 1; val |= 0x4; break;
      case 'i': case 'I': saw_a_flag = 1; val |= 0x2; break;
      case 'f': case 'F': saw_a_flag = 1; val |= 0x1; break;

      default:
	inst.error = _("unrecognized CPS flag");
	return FAIL;
      }

 done:
  if (saw_a_flag == 0)
    {
      inst.error = _("missing CPS flags");
      return FAIL;
    }

  *str = s - 1;
  return val;
}

/* Parse an endian specifier ("BE" or "LE", case insensitive);
   returns 0 for big-endian, 1 for little-endian, FAIL for an error.  */

static int
parse_endian_specifier (char **str)
{
  int little_endian;
  char *s = *str;

  if (strncasecmp (s, "BE", 2))
    little_endian = 0;
  else if (strncasecmp (s, "LE", 2))
    little_endian = 1;
  else
    {
      inst.error = _("valid endian specifiers are be or le");
      return FAIL;
    }

  if (ISALNUM (s[2]) || s[2] == '_')
    {
      inst.error = _("valid endian specifiers are be or le");
      return FAIL;
    }

  *str = s + 2;
  return little_endian;
}

/* Parse a rotation specifier: ROR #0, #8, #16, #24.  *val receives a
   value suitable for poking into the rotate field of an sxt or sxta
   instruction, or FAIL on error.  */

static int
parse_ror (char **str)
{
  int rot;
  char *s = *str;

  if (strncasecmp (s, "ROR", 3) == 0)
    s += 3;
  else
    {
      inst.error = _("missing rotation field after comma");
      return FAIL;
    }

  if (parse_immediate (&s, &rot, 0, 24, FALSE) == FAIL)
    return FAIL;

  switch (rot)
    {
    case  0: *str = s; return 0x0;
    case  8: *str = s; return 0x1;
    case 16: *str = s; return 0x2;
    case 24: *str = s; return 0x3;

    default:
      inst.error = _("rotation can only be 0, 8, 16, or 24");
      return FAIL;
    }
}

/* Parse a conditional code (from conds[] below).  The value returned is in the
   range 0 .. 14, or FAIL.  */
static int
parse_cond (char **str)
{
  char *p, *q;
  const struct asm_cond *c;

  p = q = *str;
  while (ISALPHA (*q))
    q++;

  c = hash_find_n (arm_cond_hsh, p, q - p);
  if (!c)
    {
      inst.error = _("condition required");
      return FAIL;
    }

  *str = q;
  return c->value;
}

/* Matcher codes for parse_operands.  */
enum operand_parse_code
{
  OP_stop,	/* end of line */

  OP_RR,	/* ARM register */
  OP_RRnpc,	/* ARM register, not r15 */
  OP_RRnpcb,	/* ARM register, not r15, in square brackets */
  OP_RRw,	/* ARM register, not r15, optional trailing ! */
  OP_RCP,	/* Coprocessor number */
  OP_RCN,	/* Coprocessor register */
  OP_RF,	/* FPA register */
  OP_RVS,	/* VFP single precision register */
  OP_RVD,	/* VFP double precision register */
  OP_RVC,	/* VFP control register */
  OP_RMF,	/* Maverick F register */
  OP_RMD,	/* Maverick D register */
  OP_RMFX,	/* Maverick FX register */
  OP_RMDX,	/* Maverick DX register */
  OP_RMAX,	/* Maverick AX register */
  OP_RMDS,	/* Maverick DSPSC register */
  OP_RIWR,	/* iWMMXt wR register */
  OP_RIWC,	/* iWMMXt wC register */
  OP_RIWG,	/* iWMMXt wCG register */
  OP_RXA,	/* XScale accumulator register */

  OP_REGLST,	/* ARM register list */
  OP_VRSLST,	/* VFP single-precision register list */
  OP_VRDLST,	/* VFP double-precision register list */

  OP_I7,	/* immediate value 0 .. 7 */
  OP_I15,	/*		   0 .. 15 */
  OP_I16,	/*		   1 .. 16 */
  OP_I31,	/*		   0 .. 31 */
  OP_I31w,	/*		   0 .. 31, optional trailing ! */
  OP_I32,	/*		   1 .. 32 */
  OP_I63s,	/*		 -64 .. 63 */
  OP_I255,	/*		   0 .. 255 */
  OP_Iffff,	/*		   0 .. 65535 */

  OP_I4b,	/* immediate, prefix optional, 1 .. 4 */
  OP_I7b,	/*			       0 .. 7 */
  OP_I15b,	/*			       0 .. 15 */
  OP_I31b,	/*			       0 .. 31 */

  OP_SH,	/* shifter operand */
  OP_ADDR,	/* Memory address expression (any mode) */
  OP_EXP,	/* arbitrary expression */
  OP_EXPi,	/* same, with optional immediate prefix */
  OP_EXPr,	/* same, with optional relocation suffix */

  OP_CPSF,	/* CPS flags */
  OP_ENDI,	/* Endianness specifier */
  OP_PSR,	/* CPSR/SPSR mask for msr */
  OP_COND,	/* conditional code */

  OP_RRnpc_I0,	/* ARM register or literal 0 */
  OP_RR_EXr,	/* ARM register or expression with opt. reloc suff. */
  OP_RR_EXi,	/* ARM register or expression with imm prefix */
  OP_RF_IF,	/* FPA register or immediate */
  OP_RIWR_RIWC, /* iWMMXt R or C reg */

  /* Optional operands.	 */
  OP_oI7b,	 /* immediate, prefix optional, 0 .. 7 */
  OP_oI31b,	 /*				0 .. 31 */
  OP_oIffffb,	 /*				0 .. 65535 */
  OP_oI255c,	 /*	  curly-brace enclosed, 0 .. 255 */

  OP_oRR,	 /* ARM register */
  OP_oRRnpc,	 /* ARM register, not the PC */
  OP_oSHll,	 /* LSL immediate */
  OP_oSHar,	 /* ASR immediate */
  OP_oSHllar,	 /* LSL or ASR immediate */
  OP_oROR,	 /* ROR 0/8/16/24 */

  OP_FIRST_OPTIONAL = OP_oI7b
};

/* Generic instruction operand parser.	This does no encoding and no
   semantic validation; it merely squirrels values away in the inst
   structure.  Returns SUCCESS or FAIL depending on whether the
   specified grammar matched.  */
static int
parse_operands (char *str, const unsigned char *pattern)
{
  unsigned const char *upat = pattern;
  char *backtrack_pos = 0;
  const char *backtrack_error = 0;
  int i, val, backtrack_index = 0;

#define po_char_or_fail(chr) do {		\
  if (skip_past_char (&str, chr) == FAIL)	\
    goto bad_args;				\
} while (0)

#define po_reg_or_fail(regtype) do {			\
  val = arm_reg_parse (&str, regtype);			\
  if (val == FAIL)					\
    {							\
      inst.error = _(reg_expected_msgs[regtype]);	\
      goto failure;					\
    }							\
  inst.operands[i].reg = val;				\
  inst.operands[i].isreg = 1;				\
} while (0)

#define po_reg_or_goto(regtype, label) do {	\
  val = arm_reg_parse (&str, regtype);		\
  if (val == FAIL)				\
    goto label;					\
						\
  inst.operands[i].reg = val;			\
  inst.operands[i].isreg = 1;			\
} while (0)

#define po_imm_or_fail(min, max, popt) do {			\
  if (parse_immediate (&str, &val, min, max, popt) == FAIL)	\
    goto failure;						\
  inst.operands[i].imm = val;					\
} while (0)

#define po_misc_or_fail(expr) do {		\
  if (expr)					\
    goto failure;				\
} while (0)

  skip_whitespace (str);

  for (i = 0; upat[i] != OP_stop; i++)
    {
      if (upat[i] >= OP_FIRST_OPTIONAL)
	{
	  /* Remember where we are in case we need to backtrack.  */
	  assert (!backtrack_pos);
	  backtrack_pos = str;
	  backtrack_error = inst.error;
	  backtrack_index = i;
	}

      if (i > 0)
	po_char_or_fail (',');

      switch (upat[i])
	{
	  /* Registers */
	case OP_oRRnpc:
	case OP_RRnpc:
	case OP_oRR:
	case OP_RR:    po_reg_or_fail (REG_TYPE_RN);	  break;
	case OP_RCP:   po_reg_or_fail (REG_TYPE_CP);	  break;
	case OP_RCN:   po_reg_or_fail (REG_TYPE_CN);	  break;
	case OP_RF:    po_reg_or_fail (REG_TYPE_FN);	  break;
	case OP_RVS:   po_reg_or_fail (REG_TYPE_VFS);	  break;
	case OP_RVD:   po_reg_or_fail (REG_TYPE_VFD);	  break;
	case OP_RVC:   po_reg_or_fail (REG_TYPE_VFC);	  break;
	case OP_RMF:   po_reg_or_fail (REG_TYPE_MVF);	  break;
	case OP_RMD:   po_reg_or_fail (REG_TYPE_MVD);	  break;
	case OP_RMFX:  po_reg_or_fail (REG_TYPE_MVFX);	  break;
	case OP_RMDX:  po_reg_or_fail (REG_TYPE_MVDX);	  break;
	case OP_RMAX:  po_reg_or_fail (REG_TYPE_MVAX);	  break;
	case OP_RMDS:  po_reg_or_fail (REG_TYPE_DSPSC);	  break;
	case OP_RIWR:  po_reg_or_fail (REG_TYPE_MMXWR);	  break;
	case OP_RIWC:  po_reg_or_fail (REG_TYPE_MMXWC);	  break;
	case OP_RIWG:  po_reg_or_fail (REG_TYPE_MMXWCG);  break;
	case OP_RXA:   po_reg_or_fail (REG_TYPE_XSCALE);  break;

	case OP_RRnpcb:
	  po_char_or_fail ('[');
	  po_reg_or_fail  (REG_TYPE_RN);
	  po_char_or_fail (']');
	  break;

	case OP_RRw:
	  po_reg_or_fail (REG_TYPE_RN);
	  if (skip_past_char (&str, '!') == SUCCESS)
	    inst.operands[i].writeback = 1;
	  break;

	  /* Immediates */
	case OP_I7:	 po_imm_or_fail (  0,	   7, FALSE);	break;
	case OP_I15:	 po_imm_or_fail (  0,	  15, FALSE);	break;
	case OP_I16:	 po_imm_or_fail (  1,	  16, FALSE);	break;
	case OP_I31:	 po_imm_or_fail (  0,	  31, FALSE);	break;
	case OP_I32:	 po_imm_or_fail (  1,	  32, FALSE);	break;
	case OP_I63s:	 po_imm_or_fail (-64,	  63, FALSE);	break;
	case OP_I255:	 po_imm_or_fail (  0,	 255, FALSE);	break;
	case OP_Iffff:	 po_imm_or_fail (  0, 0xffff, FALSE);	break;

	case OP_I4b:	 po_imm_or_fail (  1,	   4, TRUE);	break;
	case OP_oI7b:
	case OP_I7b:	 po_imm_or_fail (  0,	   7, TRUE);	break;
	case OP_I15b:	 po_imm_or_fail (  0,	  15, TRUE);	break;
	case OP_oI31b:
	case OP_I31b:	 po_imm_or_fail (  0,	  31, TRUE);	break;
	case OP_oIffffb: po_imm_or_fail (  0, 0xffff, TRUE);	break;

	  /* Immediate variants */
	case OP_oI255c:
	  po_char_or_fail ('{');
	  po_imm_or_fail (0, 255, TRUE);
	  po_char_or_fail ('}');
	  break;

	case OP_I31w:
	  /* The expression parser chokes on a trailing !, so we have
	     to find it first and zap it.  */
	  {
	    char *s = str;
	    while (*s && *s != ',')
	      s++;
	    if (s[-1] == '!')
	      {
		s[-1] = '\0';
		inst.operands[i].writeback = 1;
	      }
	    po_imm_or_fail (0, 31, TRUE);
	    if (str == s - 1)
	      str = s;
	  }
	  break;

	  /* Expressions */
	case OP_EXPi:	EXPi:
	  po_misc_or_fail (my_get_expression (&inst.reloc.exp, &str,
					      GE_OPT_PREFIX));
	  break;

	case OP_EXP:
	  po_misc_or_fail (my_get_expression (&inst.reloc.exp, &str,
					      GE_NO_PREFIX));
	  break;

	case OP_EXPr:	EXPr:
	  po_misc_or_fail (my_get_expression (&inst.reloc.exp, &str,
					      GE_NO_PREFIX));
	  if (inst.reloc.exp.X_op == O_symbol)
	    {
	      val = parse_reloc (&str);
	      if (val == -1)
		{
		  inst.error = _("unrecognized relocation suffix");
		  goto failure;
		}
	      else if (val != BFD_RELOC_UNUSED)
		{
		  inst.operands[i].imm = val;
		  inst.operands[i].hasreloc = 1;
		}
	    }
	  break;

	  /* Register or expression */
	case OP_RR_EXr:	  po_reg_or_goto (REG_TYPE_RN, EXPr); break;
	case OP_RR_EXi:	  po_reg_or_goto (REG_TYPE_RN, EXPi); break;

	  /* Register or immediate */
	case OP_RRnpc_I0: po_reg_or_goto (REG_TYPE_RN, I0);   break;
	I0:		  po_imm_or_fail (0, 0, FALSE);	      break;

	case OP_RF_IF:    po_reg_or_goto (REG_TYPE_FN, IF);   break;
	IF:
	  if (!is_immediate_prefix (*str))
	    goto bad_args;
	  str++;
	  val = parse_fpa_immediate (&str);
	  if (val == FAIL)
	    goto failure;
	  /* FPA immediates are encoded as registers 8-15.
	     parse_fpa_immediate has already applied the offset.  */
	  inst.operands[i].reg = val;
	  inst.operands[i].isreg = 1;
	  break;

	  /* Two kinds of register */
	case OP_RIWR_RIWC:
	  {
	    struct reg_entry *rege = arm_reg_parse_multi (&str);
	    if (rege->type != REG_TYPE_MMXWR
		&& rege->type != REG_TYPE_MMXWC
		&& rege->type != REG_TYPE_MMXWCG)
	      {
		inst.error = _("iWMMXt data or control register expected");
		goto failure;
	      }
	    inst.operands[i].reg = rege->number;
	    inst.operands[i].isreg = (rege->type == REG_TYPE_MMXWR);
	  }
	  break;

	  /* Misc */
	case OP_CPSF:	 val = parse_cps_flags (&str);		break;
	case OP_ENDI:	 val = parse_endian_specifier (&str);	break;
	case OP_oROR:	 val = parse_ror (&str);		break;
	case OP_PSR:	 val = parse_psr (&str);		break;
	case OP_COND:	 val = parse_cond (&str);		break;

	  /* Register lists */
	case OP_REGLST:
	  val = parse_reg_list (&str);
	  if (*str == '^')
	    {
	      inst.operands[1].writeback = 1;
	      str++;
	    }
	  break;

	case OP_VRSLST:
	  val = parse_vfp_reg_list (&str, &inst.operands[i].reg, 0);
	  break;

	case OP_VRDLST:
	  val = parse_vfp_reg_list (&str, &inst.operands[i].reg, 1);
	  break;

	  /* Addressing modes */
	case OP_ADDR:
	  po_misc_or_fail (parse_address (&str, i));
	  break;

	case OP_SH:
	  po_misc_or_fail (parse_shifter_operand (&str, i));
	  break;

	case OP_oSHll:
	  po_misc_or_fail (parse_shift (&str, i, SHIFT_LSL_IMMEDIATE));
	  break;

	case OP_oSHar:
	  po_misc_or_fail (parse_shift (&str, i, SHIFT_ASR_IMMEDIATE));
	  break;

	case OP_oSHllar:
	  po_misc_or_fail (parse_shift (&str, i, SHIFT_LSL_OR_ASR_IMMEDIATE));
	  break;

	default:
	  as_fatal ("unhandled operand code %d", upat[i]);
	}

      /* Various value-based sanity checks and shared operations.  We
	 do not signal immediate failures for the register constraints;
	 this allows a syntax error to take precedence.	 */
      switch (upat[i])
	{
	case OP_oRRnpc:
	case OP_RRnpc:
	case OP_RRnpcb:
	case OP_RRw:
	case OP_RRnpc_I0:
	  if (inst.operands[i].isreg && inst.operands[i].reg == REG_PC)
	    inst.error = BAD_PC;
	  break;

	case OP_CPSF:
	case OP_ENDI:
	case OP_oROR:
	case OP_PSR:
	case OP_COND:
	case OP_REGLST:
	case OP_VRSLST:
	case OP_VRDLST:
	  if (val == FAIL)
	    goto failure;
	  inst.operands[i].imm = val;
	  break;

	default:
	  break;
	}

      /* If we get here, this operand was successfully parsed.	*/
      inst.operands[i].present = 1;
      continue;

    bad_args:
      inst.error = BAD_ARGS;

    failure:
      if (!backtrack_pos)
	return FAIL;

      /* Do not backtrack over a trailing optional argument that
	 absorbed some text.  We will only fail again, with the
	 'garbage following instruction' error message, which is
	 probably less helpful than the current one.  */
      if (backtrack_index == i && backtrack_pos != str
	  && upat[i+1] == OP_stop)
	return FAIL;

      /* Try again, skipping the optional argument at backtrack_pos.  */
      str = backtrack_pos;
      inst.error = backtrack_error;
      inst.operands[backtrack_index].present = 0;
      i = backtrack_index;
      backtrack_pos = 0;
    }

  /* Check that we have parsed all the arguments.  */
  if (*str != '\0' && !inst.error)
    inst.error = _("garbage following instruction");

  return inst.error ? FAIL : SUCCESS;
}

#undef po_char_or_fail
#undef po_reg_or_fail
#undef po_reg_or_goto
#undef po_imm_or_fail

/* Shorthand macro for instruction encoding functions issuing errors.  */
#define constraint(expr, err) do {		\
  if (expr)					\
    {						\
      inst.error = err;				\
      return;					\
    }						\
} while (0)

/* Functions for operand encoding.  ARM, then Thumb.  */

#define rotate_left(v, n) (v << n | v >> (32 - n))

/* If VAL can be encoded in the immediate field of an ARM instruction,
   return the encoded form.  Otherwise, return FAIL.  */

static unsigned int
encode_arm_immediate (unsigned int val)
{
  unsigned int a, i;

  for (i = 0; i < 32; i += 2)
    if ((a = rotate_left (val, i)) <= 0xff)
      return a | (i << 7); /* 12-bit pack: [shift-cnt,const].  */

  return FAIL;
}

/* If VAL can be encoded in the immediate field of a Thumb32 instruction,
   return the encoded form.  Otherwise, return FAIL.  */
static unsigned int
encode_thumb32_immediate (unsigned int val)
{
  unsigned int a, i;

  if (val <= 255)
    return val;

  for (i = 0; i < 32; i++)
    {
      a = rotate_left (val, i);
      if (a >= 128 && a <= 255)
	return (a & 0x7f) | (i << 7);
    }

  a = val & 0xff;
  if (val == ((a << 16) | a))
    return 0x100 | a;
  if (val == ((a << 24) | (a << 16) | (a << 8) | a))
    return 0x300 | a;

  a = val & 0xff00;
  if (val == ((a << 16) | a))
    return 0x200 | (a >> 8);

  return FAIL;
}
/* Encode a VFP SP register number into inst.instruction.  */

static void
encode_arm_vfp_sp_reg (int reg, enum vfp_sp_reg_pos pos)
{
  switch (pos)
    {
    case VFP_REG_Sd:
      inst.instruction |= ((reg >> 1) << 12) | ((reg & 1) << 22);
      break;

    case VFP_REG_Sn:
      inst.instruction |= ((reg >> 1) << 16) | ((reg & 1) << 7);
      break;

    case VFP_REG_Sm:
      inst.instruction |= ((reg >> 1) << 0) | ((reg & 1) << 5);
      break;

    default:
      abort ();
    }
}

/* Encode a <shift> in an ARM-format instruction.  The immediate,
   if any, is handled by md_apply_fix.	 */
static void
encode_arm_shift (int i)
{
  if (inst.operands[i].shift_kind == SHIFT_RRX)
    inst.instruction |= SHIFT_ROR << 5;
  else
    {
      inst.instruction |= inst.operands[i].shift_kind << 5;
      if (inst.operands[i].immisreg)
	{
	  inst.instruction |= SHIFT_BY_REG;
	  inst.instruction |= inst.operands[i].imm << 8;
	}
      else
	inst.reloc.type = BFD_RELOC_ARM_SHIFT_IMM;
    }
}

static void
encode_arm_shifter_operand (int i)
{
  if (inst.operands[i].isreg)
    {
      inst.instruction |= inst.operands[i].reg;
      encode_arm_shift (i);
    }
  else
    inst.instruction |= INST_IMMEDIATE;
}

/* Subroutine of encode_arm_addr_mode_2 and encode_arm_addr_mode_3.  */
static void
encode_arm_addr_mode_common (int i, bfd_boolean is_t)
{
  assert (inst.operands[i].isreg);
  inst.instruction |= inst.operands[i].reg << 16;

  if (inst.operands[i].preind)
    {
      if (is_t)
	{
	  inst.error = _("instruction does not accept preindexed addressing");
	  return;
	}
      inst.instruction |= PRE_INDEX;
      if (inst.operands[i].writeback)
	inst.instruction |= WRITE_BACK;

    }
  else if (inst.operands[i].postind)
    {
      assert (inst.operands[i].writeback);
      if (is_t)
	inst.instruction |= WRITE_BACK;
    }
  else /* unindexed - only for coprocessor */
    {
      inst.error = _("instruction does not accept unindexed addressing");
      return;
    }

  if (((inst.instruction & WRITE_BACK) || !(inst.instruction & PRE_INDEX))
      && (((inst.instruction & 0x000f0000) >> 16)
	  == ((inst.instruction & 0x0000f000) >> 12)))
    as_warn ((inst.instruction & LOAD_BIT)
	     ? _("destination register same as write-back base")
	     : _("source register same as write-back base"));
}

/* inst.operands[i] was set up by parse_address.  Encode it into an
   ARM-format mode 2 load or store instruction.	 If is_t is true,
   reject forms that cannot be used with a T instruction (i.e. not
   post-indexed).  */
static void
encode_arm_addr_mode_2 (int i, bfd_boolean is_t)
{
  encode_arm_addr_mode_common (i, is_t);

  if (inst.operands[i].immisreg)
    {
      inst.instruction |= INST_IMMEDIATE;  /* yes, this is backwards */
      inst.instruction |= inst.operands[i].imm;
      if (!inst.operands[i].negative)
	inst.instruction |= INDEX_UP;
      if (inst.operands[i].shifted)
	{
	  if (inst.operands[i].shift_kind == SHIFT_RRX)
	    inst.instruction |= SHIFT_ROR << 5;
	  else
	    {
	      inst.instruction |= inst.operands[i].shift_kind << 5;
	      inst.reloc.type = BFD_RELOC_ARM_SHIFT_IMM;
	    }
	}
    }
  else /* immediate offset in inst.reloc */
    {
      if (inst.reloc.type == BFD_RELOC_UNUSED)
	inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM;
    }
}

/* inst.operands[i] was set up by parse_address.  Encode it into an
   ARM-format mode 3 load or store instruction.	 Reject forms that
   cannot be used with such instructions.  If is_t is true, reject
   forms that cannot be used with a T instruction (i.e. not
   post-indexed).  */
static void
encode_arm_addr_mode_3 (int i, bfd_boolean is_t)
{
  if (inst.operands[i].immisreg && inst.operands[i].shifted)
    {
      inst.error = _("instruction does not accept scaled register index");
      return;
    }

  encode_arm_addr_mode_common (i, is_t);

  if (inst.operands[i].immisreg)
    {
      inst.instruction |= inst.operands[i].imm;
      if (!inst.operands[i].negative)
	inst.instruction |= INDEX_UP;
    }
  else /* immediate offset in inst.reloc */
    {
      inst.instruction |= HWOFFSET_IMM;
      if (inst.reloc.type == BFD_RELOC_UNUSED)
	inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM8;
    }
}

/* inst.operands[i] was set up by parse_address.  Encode it into an
   ARM-format instruction.  Reject all forms which cannot be encoded
   into a coprocessor load/store instruction.  If wb_ok is false,
   reject use of writeback; if unind_ok is false, reject use of
   unindexed addressing.  If reloc_override is not 0, use it instead
   of BFD_ARM_CP_OFF_IMM.  */

static int
encode_arm_cp_address (int i, int wb_ok, int unind_ok, int reloc_override)
{
  inst.instruction |= inst.operands[i].reg << 16;

  assert (!(inst.operands[i].preind && inst.operands[i].postind));

  if (!inst.operands[i].preind && !inst.operands[i].postind) /* unindexed */
    {
      assert (!inst.operands[i].writeback);
      if (!unind_ok)
	{
	  inst.error = _("instruction does not support unindexed addressing");
	  return FAIL;
	}
      inst.instruction |= inst.operands[i].imm;
      inst.instruction |= INDEX_UP;
      return SUCCESS;
    }

  if (inst.operands[i].preind)
    inst.instruction |= PRE_INDEX;

  if (inst.operands[i].writeback)
    {
      if (inst.operands[i].reg == REG_PC)
	{
	  inst.error = _("pc may not be used with write-back");
	  return FAIL;
	}
      if (!wb_ok)
	{
	  inst.error = _("instruction does not support writeback");
	  return FAIL;
	}
      inst.instruction |= WRITE_BACK;
    }

  if (reloc_override)
    inst.reloc.type = reloc_override;
  else
    inst.reloc.type = BFD_RELOC_ARM_CP_OFF_IMM;
  return SUCCESS;
}

/* inst.reloc.exp describes an "=expr" load pseudo-operation.
   Determine whether it can be performed with a move instruction; if
   it can, convert inst.instruction to that move instruction and
   return 1; if it can't, convert inst.instruction to a literal-pool
   load and return 0.  If this is not a valid thing to do in the
   current context, set inst.error and return 1.

   inst.operands[i] describes the destination register.	 */

static int
move_or_literal_pool (int i, bfd_boolean thumb_p, bfd_boolean mode_3)
{
  if ((inst.instruction & (thumb_p ? THUMB_LOAD_BIT : LOAD_BIT)) == 0)
    {
      inst.error = _("invalid pseudo operation");
      return 1;
    }
  if (inst.reloc.exp.X_op != O_constant && inst.reloc.exp.X_op != O_symbol)
    {
      inst.error = _("constant expression expected");
      return 1;
    }
  if (inst.reloc.exp.X_op == O_constant)
    {
      if (thumb_p)
	{
	  if ((inst.reloc.exp.X_add_number & ~0xFF) == 0)
	    {
	      /* This can be done with a mov(1) instruction.  */
	      inst.instruction	= T_OPCODE_MOV_I8 | (inst.operands[i].reg << 8);
	      inst.instruction |= inst.reloc.exp.X_add_number;
	      return 1;
	    }
	}
      else
	{
	  int value = encode_arm_immediate (inst.reloc.exp.X_add_number);
	  if (value != FAIL)
	    {
	      /* This can be done with a mov instruction.  */
	      inst.instruction &= LITERAL_MASK;
	      inst.instruction |= INST_IMMEDIATE | (OPCODE_MOV << DATA_OP_SHIFT);
	      inst.instruction |= value & 0xfff;
	      return 1;
	    }

	  value = encode_arm_immediate (~inst.reloc.exp.X_add_number);
	  if (value != FAIL)
	    {
	      /* This can be done with a mvn instruction.  */
	      inst.instruction &= LITERAL_MASK;
	      inst.instruction |= INST_IMMEDIATE | (OPCODE_MVN << DATA_OP_SHIFT);
	      inst.instruction |= value & 0xfff;
	      return 1;
	    }
	}
    }

  if (add_to_lit_pool () == FAIL)
    {
      inst.error = _("literal pool insertion failed");
      return 1;
    }
  inst.operands[1].reg = REG_PC;
  inst.operands[1].isreg = 1;
  inst.operands[1].preind = 1;
  inst.reloc.pc_rel = 1;
  inst.reloc.type = (thumb_p
		     ? BFD_RELOC_ARM_THUMB_OFFSET
		     : (mode_3
			? BFD_RELOC_ARM_HWLITERAL
			: BFD_RELOC_ARM_LITERAL));
  return 0;
}

/* Functions for instruction encoding, sorted by subarchitecture.
   First some generics; their names are taken from the conventional
   bit positions for register arguments in ARM format instructions.  */

static void
do_noargs (void)
{
}

static void
do_rd (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
}

static void
do_rd_rm (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg;
}

static void
do_rd_rn (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
}

static void
do_rn_rd (void)
{
  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg << 12;
}

static void
do_rd_rm_rn (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 16;
}

static void
do_rd_rn_rm (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
}

static void
do_rm_rd_rn (void)
{
  inst.instruction |= inst.operands[0].reg;
  inst.instruction |= inst.operands[1].reg << 12;
  inst.instruction |= inst.operands[2].reg << 16;
}

static void
do_imm0 (void)
{
  inst.instruction |= inst.operands[0].imm;
}

static void
do_rd_cpaddr (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_cp_address (1, TRUE, TRUE, 0);
}

/* ARM instructions, in alphabetical order by function name (except
   that wrapper functions appear immediately after the function they
   wrap).  */

/* This is a pseudo-op of the form "adr rd, label" to be converted
   into a relative address of the form "add rd, pc, #label-.-8".  */

static void
do_adr (void)
{
  inst.instruction |= (inst.operands[0].reg << 12);  /* Rd */

  /* Frag hacking will turn this into a sub instruction if the offset turns
     out to be negative.  */
  inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;
  inst.reloc.pc_rel = 1;
  inst.reloc.exp.X_add_number -= 8;
}

/* This is a pseudo-op of the form "adrl rd, label" to be converted
   into a relative address of the form:
   add rd, pc, #low(label-.-8)"
   add rd, rd, #high(label-.-8)"  */

static void
do_adrl (void)
{
  inst.instruction |= (inst.operands[0].reg << 12);  /* Rd */

  /* Frag hacking will turn this into a sub instruction if the offset turns
     out to be negative.  */
  inst.reloc.type	       = BFD_RELOC_ARM_ADRL_IMMEDIATE;
  inst.reloc.pc_rel	       = 1;
  inst.size		       = INSN_SIZE * 2;
  inst.reloc.exp.X_add_number -= 8;
}

static void
do_arit (void)
{
  if (!inst.operands[1].present)
    inst.operands[1].reg = inst.operands[0].reg;
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  encode_arm_shifter_operand (2);
}

static void
do_bfc (void)
{
  unsigned int msb = inst.operands[1].imm + inst.operands[2].imm;
  constraint (msb > 32, _("bit-field extends past end of register"));
  /* The instruction encoding stores the LSB and MSB,
     not the LSB and width.  */
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].imm << 7;
  inst.instruction |= (msb - 1) << 16;
}

static void
do_bfi (void)
{
  unsigned int msb;

  /* #0 in second position is alternative syntax for bfc, which is
     the same instruction but with REG_PC in the Rm field.  */
  if (!inst.operands[1].isreg)
    inst.operands[1].reg = REG_PC;

  msb = inst.operands[2].imm + inst.operands[3].imm;
  constraint (msb > 32, _("bit-field extends past end of register"));
  /* The instruction encoding stores the LSB and MSB,
     not the LSB and width.  */
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].imm << 7;
  inst.instruction |= (msb - 1) << 16;
}

static void
do_bfx (void)
{
  constraint (inst.operands[2].imm + inst.operands[3].imm > 32,
	      _("bit-field extends past end of register"));
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].imm << 7;
  inst.instruction |= (inst.operands[3].imm - 1) << 16;
}

/* ARM V5 breakpoint instruction (argument parse)
     BKPT <16 bit unsigned immediate>
     Instruction is not conditional.
	The bit pattern given in insns[] has the COND_ALWAYS condition,
	and it is an error if the caller tried to override that.  */

static void
do_bkpt (void)
{
  /* Top 12 of 16 bits to bits 19:8.  */
  inst.instruction |= (inst.operands[0].imm & 0xfff0) << 4;

  /* Bottom 4 of 16 bits to bits 3:0.  */
  inst.instruction |= inst.operands[0].imm & 0xf;
}

static void
encode_branch (int default_reloc)
{
  if (inst.operands[0].hasreloc)
    {
      constraint (inst.operands[0].imm != BFD_RELOC_ARM_PLT32,
		  _("the only suffix valid here is '(plt)'"));
      inst.reloc.type	= BFD_RELOC_ARM_PLT32;
    }
  else
    {
      inst.reloc.type = default_reloc;
    }
  inst.reloc.pc_rel = 1;
}

static void
do_branch (void)
{
  encode_branch (BFD_RELOC_ARM_PCREL_BRANCH);
}

/* ARM V5 branch-link-exchange instruction (argument parse)
     BLX <target_addr>		ie BLX(1)
     BLX{<condition>} <Rm>	ie BLX(2)
   Unfortunately, there are two different opcodes for this mnemonic.
   So, the insns[].value is not used, and the code here zaps values
	into inst.instruction.
   Also, the <target_addr> can be 25 bits, hence has its own reloc.  */

static void
do_blx (void)
{
  if (inst.operands[0].isreg)
    {
      /* Arg is a register; the opcode provided by insns[] is correct.
	 It is not illegal to do "blx pc", just useless.  */
      if (inst.operands[0].reg == REG_PC)
	as_tsktsk (_("use of r15 in blx in ARM mode is not really useful"));

      inst.instruction |= inst.operands[0].reg;
    }
  else
    {
      /* Arg is an address; this instruction cannot be executed
	 conditionally, and the opcode must be adjusted.  */
      constraint (inst.cond != COND_ALWAYS, BAD_COND);
      inst.instruction = 0xfa000000;
      encode_branch (BFD_RELOC_ARM_PCREL_BLX);
    }
}

static void
do_bx (void)
{
  if (inst.operands[0].reg == REG_PC)
    as_tsktsk (_("use of r15 in bx in ARM mode is not really useful"));

  inst.instruction |= inst.operands[0].reg;
}


/* ARM v5TEJ.  Jump to Jazelle code.  */

static void
do_bxj (void)
{
  if (inst.operands[0].reg == REG_PC)
    as_tsktsk (_("use of r15 in bxj is not really useful"));

  inst.instruction |= inst.operands[0].reg;
}

/* Co-processor data operation:
      CDP{cond} <coproc>, <opcode_1>, <CRd>, <CRn>, <CRm>{, <opcode_2>}
      CDP2	<coproc>, <opcode_1>, <CRd>, <CRn>, <CRm>{, <opcode_2>}	 */
static void
do_cdp (void)
{
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].imm << 20;
  inst.instruction |= inst.operands[2].reg << 12;
  inst.instruction |= inst.operands[3].reg << 16;
  inst.instruction |= inst.operands[4].reg;
  inst.instruction |= inst.operands[5].imm << 5;
}

static void
do_cmp (void)
{
  inst.instruction |= inst.operands[0].reg << 16;
  encode_arm_shifter_operand (1);
}

/* Transfer between coprocessor and ARM registers.
   MRC{cond} <coproc>, <opcode_1>, <Rd>, <CRn>, <CRm>{, <opcode_2>}
   MRC2
   MCR{cond}
   MCR2

   No special properties.  */

static void
do_co_reg (void)
{
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].imm << 21;
  inst.instruction |= inst.operands[2].reg << 12;
  inst.instruction |= inst.operands[3].reg << 16;
  inst.instruction |= inst.operands[4].reg;
  inst.instruction |= inst.operands[5].imm << 5;
}

/* Transfer between coprocessor register and pair of ARM registers.
   MCRR{cond} <coproc>, <opcode>, <Rd>, <Rn>, <CRm>.
   MCRR2
   MRRC{cond}
   MRRC2

   Two XScale instructions are special cases of these:

     MAR{cond} acc0, <RdLo>, <RdHi> == MCRR{cond} p0, #0, <RdLo>, <RdHi>, c0
     MRA{cond} acc0, <RdLo>, <RdHi> == MRRC{cond} p0, #0, <RdLo>, <RdHi>, c0

   Result unpredicatable if Rd or Rn is R15.  */

static void
do_co_reg2c (void)
{
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].imm << 4;
  inst.instruction |= inst.operands[2].reg << 12;
  inst.instruction |= inst.operands[3].reg << 16;
  inst.instruction |= inst.operands[4].reg;
}

static void
do_cpsi (void)
{
  inst.instruction |= inst.operands[0].imm << 6;
  inst.instruction |= inst.operands[1].imm;
}

static void
do_it (void)
{
  /* There is no IT instruction in ARM mode.  We
     process it but do not generate code for it.  */
  inst.size = 0;
}

static void
do_ldmstm (void)
{
  int base_reg = inst.operands[0].reg;
  int range = inst.operands[1].imm;

  inst.instruction |= base_reg << 16;
  inst.instruction |= range;

  if (inst.operands[1].writeback)
    inst.instruction |= LDM_TYPE_2_OR_3;

  if (inst.operands[0].writeback)
    {
      inst.instruction |= WRITE_BACK;
      /* Check for unpredictable uses of writeback.  */
      if (inst.instruction & LOAD_BIT)
	{
	  /* Not allowed in LDM type 2.	 */
	  if ((inst.instruction & LDM_TYPE_2_OR_3)
	      && ((range & (1 << REG_PC)) == 0))
	    as_warn (_("writeback of base register is UNPREDICTABLE"));
	  /* Only allowed if base reg not in list for other types.  */
	  else if (range & (1 << base_reg))
	    as_warn (_("writeback of base register when in register list is UNPREDICTABLE"));
	}
      else /* STM.  */
	{
	  /* Not allowed for type 2.  */
	  if (inst.instruction & LDM_TYPE_2_OR_3)
	    as_warn (_("writeback of base register is UNPREDICTABLE"));
	  /* Only allowed if base reg not in list, or first in list.  */
	  else if ((range & (1 << base_reg))
		   && (range & ((1 << base_reg) - 1)))
	    as_warn (_("if writeback register is in list, it must be the lowest reg in the list"));
	}
    }
}

/* ARMv5TE load-consecutive (argument parse)
   Mode is like LDRH.

     LDRccD R, mode
     STRccD R, mode.  */

static void
do_ldrd (void)
{
  constraint (inst.operands[0].reg % 2 != 0,
	      _("first destination register must be even"));
  constraint (inst.operands[1].present
	      && inst.operands[1].reg != inst.operands[0].reg + 1,
	      _("can only load two consecutive registers"));
  constraint (inst.operands[0].reg == REG_LR, _("r14 not allowed here"));
  constraint (!inst.operands[2].isreg, _("'[' expected"));

  if (!inst.operands[1].present)
    inst.operands[1].reg = inst.operands[0].reg + 1;
  
  if (inst.instruction & LOAD_BIT)
    {
      /* encode_arm_addr_mode_3 will diagnose overlap between the base
	 register and the first register written; we have to diagnose
	 overlap between the base and the second register written here.	 */

      if (inst.operands[2].reg == inst.operands[1].reg
	  && (inst.operands[2].writeback || inst.operands[2].postind))
	as_warn (_("base register written back, and overlaps "
		   "second destination register"));

      /* For an index-register load, the index register must not overlap the
	 destination (even if not write-back).	*/
      else if (inst.operands[2].immisreg
	       && ((unsigned) inst.operands[2].imm == inst.operands[0].reg
		   || (unsigned) inst.operands[2].imm == inst.operands[1].reg))
	as_warn (_("index register overlaps destination register"));
    }

  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_addr_mode_3 (2, /*is_t=*/FALSE);
}

static void
do_ldrex (void)
{
  constraint (!inst.operands[1].isreg || !inst.operands[1].preind
	      || inst.operands[1].postind || inst.operands[1].writeback
	      || inst.operands[1].immisreg || inst.operands[1].shifted
	      || inst.operands[1].negative,
	      _("instruction does not accept this addressing mode"));

  constraint (inst.operands[1].reg == REG_PC, BAD_PC);

  constraint (inst.reloc.exp.X_op != O_constant
	      || inst.reloc.exp.X_add_number != 0,
	      _("offset must be zero in ARM encoding"));

  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.reloc.type = BFD_RELOC_UNUSED;
}

static void
do_ldrexd (void)
{
  constraint (inst.operands[0].reg % 2 != 0,
	      _("even register required"));
  constraint (inst.operands[1].present
	      && inst.operands[1].reg != inst.operands[0].reg + 1,
	      _("can only load two consecutive registers"));
  /* If op 1 were present and equal to PC, this function wouldn't
     have been called in the first place.  */
  constraint (inst.operands[0].reg == REG_LR, _("r14 not allowed here"));

  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[2].reg << 16;
}

static void
do_ldst (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  if (!inst.operands[1].isreg)
    if (move_or_literal_pool (0, /*thumb_p=*/FALSE, /*mode_3=*/FALSE))
      return;
  encode_arm_addr_mode_2 (1, /*is_t=*/FALSE);
}

static void
do_ldstt (void)
{
  /* ldrt/strt always use post-indexed addressing.  Turn [Rn] into [Rn]! and
     reject [Rn,...].  */
  if (inst.operands[1].preind)
    {
      constraint (inst.reloc.exp.X_op != O_constant ||
		  inst.reloc.exp.X_add_number != 0,
		  _("this instruction requires a post-indexed address"));

      inst.operands[1].preind = 0;
      inst.operands[1].postind = 1;
      inst.operands[1].writeback = 1;
    }
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_addr_mode_2 (1, /*is_t=*/TRUE);
}

/* Halfword and signed-byte load/store operations.  */

static void
do_ldstv4 (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  if (!inst.operands[1].isreg)
    if (move_or_literal_pool (0, /*thumb_p=*/FALSE, /*mode_3=*/TRUE))
      return;
  encode_arm_addr_mode_3 (1, /*is_t=*/FALSE);
}

static void
do_ldsttv4 (void)
{
  /* ldrt/strt always use post-indexed addressing.  Turn [Rn] into [Rn]! and
     reject [Rn,...].  */
  if (inst.operands[1].preind)
    {
      constraint (inst.reloc.exp.X_op != O_constant ||
		  inst.reloc.exp.X_add_number != 0,
		  _("this instruction requires a post-indexed address"));

      inst.operands[1].preind = 0;
      inst.operands[1].postind = 1;
      inst.operands[1].writeback = 1;
    }
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_addr_mode_3 (1, /*is_t=*/TRUE);
}

/* Co-processor register load/store.
   Format: <LDC|STC>{cond}[L] CP#,CRd,<address>	 */
static void
do_lstc (void)
{
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 12;
  encode_arm_cp_address (2, TRUE, TRUE, 0);
}

static void
do_mlas (void)
{
  /* This restriction does not apply to mls (nor to mla in v6, but
     that's hard to detect at present).	 */
  if (inst.operands[0].reg == inst.operands[1].reg
      && !(inst.instruction & 0x00400000))
    as_tsktsk (_("rd and rm should be different in mla"));

  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 8;
  inst.instruction |= inst.operands[3].reg << 12;

}

static void
do_mov (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_shifter_operand (1);
}

/* ARM V6T2 16-bit immediate register load: MOV[WT]{cond} Rd, #<imm16>.	 */
static void
do_mov16 (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  /* The value is in two pieces: 0:11, 16:19.  */
  inst.instruction |= (inst.operands[1].imm & 0x00000fff);
  inst.instruction |= (inst.operands[1].imm & 0x0000f000) << 4;
}

static void
do_mrs (void)
{
  /* mrs only accepts CPSR/SPSR/CPSR_all/SPSR_all.  */
  constraint ((inst.operands[1].imm & (PSR_c|PSR_x|PSR_s|PSR_f))
	      != (PSR_c|PSR_f),
	      _("'CPSR' or 'SPSR' expected"));
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= (inst.operands[1].imm & SPSR_BIT);
}

/* Two possible forms:
      "{C|S}PSR_<field>, Rm",
      "{C|S}PSR_f, #expression".  */

static void
do_msr (void)
{
  inst.instruction |= inst.operands[0].imm;
  if (inst.operands[1].isreg)
    inst.instruction |= inst.operands[1].reg;
  else
    {
      inst.instruction |= INST_IMMEDIATE;
      inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;
      inst.reloc.pc_rel = 0;
    }
}

static void
do_mul (void)
{
  if (!inst.operands[2].present)
    inst.operands[2].reg = inst.operands[0].reg;
  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 8;

  if (inst.operands[0].reg == inst.operands[1].reg)
    as_tsktsk (_("rd and rm should be different in mul"));
}

/* Long Multiply Parser
   UMULL RdLo, RdHi, Rm, Rs
   SMULL RdLo, RdHi, Rm, Rs
   UMLAL RdLo, RdHi, Rm, Rs
   SMLAL RdLo, RdHi, Rm, Rs.  */

static void
do_mull (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
  inst.instruction |= inst.operands[3].reg << 8;

  /* rdhi, rdlo and rm must all be different.  */
  if (inst.operands[0].reg == inst.operands[1].reg
      || inst.operands[0].reg == inst.operands[2].reg
      || inst.operands[1].reg == inst.operands[2].reg)
    as_tsktsk (_("rdhi, rdlo and rm must all be different"));
}

static void
do_nop (void)
{
  if (inst.operands[0].present)
    {
      /* Architectural NOP hints are CPSR sets with no bits selected.  */
      inst.instruction &= 0xf0000000;
      inst.instruction |= 0x0320f000 + inst.operands[0].imm;
    }
}

/* ARM V6 Pack Halfword Bottom Top instruction (argument parse).
   PKHBT {<cond>} <Rd>, <Rn>, <Rm> {, LSL #<shift_imm>}
   Condition defaults to COND_ALWAYS.
   Error if Rd, Rn or Rm are R15.  */

static void
do_pkhbt (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
  if (inst.operands[3].present)
    encode_arm_shift (3);
}

/* ARM V6 PKHTB (Argument Parse).  */

static void
do_pkhtb (void)
{
  if (!inst.operands[3].present)
    {
      /* If the shift specifier is omitted, turn the instruction
	 into pkhbt rd, rm, rn. */
      inst.instruction &= 0xfff00010;
      inst.instruction |= inst.operands[0].reg << 12;
      inst.instruction |= inst.operands[1].reg;
      inst.instruction |= inst.operands[2].reg << 16;
    }
  else
    {
      inst.instruction |= inst.operands[0].reg << 12;
      inst.instruction |= inst.operands[1].reg << 16;
      inst.instruction |= inst.operands[2].reg;
      encode_arm_shift (3);
    }
}

/* ARMv5TE: Preload-Cache

    PLD <addr_mode>

  Syntactically, like LDR with B=1, W=0, L=1.  */

static void
do_pld (void)
{
  constraint (!inst.operands[0].isreg,
	      _("'[' expected after PLD mnemonic"));
  constraint (inst.operands[0].postind,
	      _("post-indexed expression used in preload instruction"));
  constraint (inst.operands[0].writeback,
	      _("writeback used in preload instruction"));
  constraint (!inst.operands[0].preind,
	      _("unindexed addressing used in preload instruction"));
  inst.instruction |= inst.operands[0].reg;
  encode_arm_addr_mode_2 (0, /*is_t=*/FALSE);
}

static void
do_push_pop (void)
{
  inst.operands[1] = inst.operands[0];
  memset (&inst.operands[0], 0, sizeof inst.operands[0]);
  inst.operands[0].isreg = 1;
  inst.operands[0].writeback = 1;
  inst.operands[0].reg = REG_SP;
  do_ldmstm ();
}

/* ARM V6 RFE (Return from Exception) loads the PC and CPSR from the
   word at the specified address and the following word
   respectively.
   Unconditionally executed.
   Error if Rn is R15.	*/

static void
do_rfe (void)
{
  inst.instruction |= inst.operands[0].reg << 16;
  if (inst.operands[0].writeback)
    inst.instruction |= WRITE_BACK;
}

/* ARM V6 ssat (argument parse).  */

static void
do_ssat (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= (inst.operands[1].imm - 1) << 16;
  inst.instruction |= inst.operands[2].reg;

  if (inst.operands[3].present)
    encode_arm_shift (3);
}

/* ARM V6 usat (argument parse).  */

static void
do_usat (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].imm << 16;
  inst.instruction |= inst.operands[2].reg;

  if (inst.operands[3].present)
    encode_arm_shift (3);
}

/* ARM V6 ssat16 (argument parse).  */

static void
do_ssat16 (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= ((inst.operands[1].imm - 1) << 16);
  inst.instruction |= inst.operands[2].reg;
}

static void
do_usat16 (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].imm << 16;
  inst.instruction |= inst.operands[2].reg;
}

/* ARM V6 SETEND (argument parse).  Sets the E bit in the CPSR while
   preserving the other bits.

   setend <endian_specifier>, where <endian_specifier> is either
   BE or LE.  */

static void
do_setend (void)
{
  if (inst.operands[0].imm)
    inst.instruction |= 0x200;
}

static void
do_shift (void)
{
  unsigned int Rm = (inst.operands[1].present
		     ? inst.operands[1].reg
		     : inst.operands[0].reg);

  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= Rm;
  if (inst.operands[2].isreg)  /* Rd, {Rm,} Rs */
    {
      constraint (inst.operands[0].reg != Rm,
		  _("source1 and dest must be same register"));
      inst.instruction |= inst.operands[2].reg << 8;
      inst.instruction |= SHIFT_BY_REG;
    }
  else
    inst.reloc.type = BFD_RELOC_ARM_SHIFT_IMM;
}

static void
do_smi (void)
{
  inst.reloc.type = BFD_RELOC_ARM_SMI;
  inst.reloc.pc_rel = 0;
}

static void
do_swi (void)
{
  inst.reloc.type = BFD_RELOC_ARM_SWI;
  inst.reloc.pc_rel = 0;
}

/* ARM V5E (El Segundo) signed-multiply-accumulate (argument parse)
   SMLAxy{cond} Rd,Rm,Rs,Rn
   SMLAWy{cond} Rd,Rm,Rs,Rn
   Error if any register is R15.  */

static void
do_smla (void)
{
  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 8;
  inst.instruction |= inst.operands[3].reg << 12;
}

/* ARM V5E (El Segundo) signed-multiply-accumulate-long (argument parse)
   SMLALxy{cond} Rdlo,Rdhi,Rm,Rs
   Error if any register is R15.
   Warning if Rdlo == Rdhi.  */

static void
do_smlal (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
  inst.instruction |= inst.operands[3].reg << 8;

  if (inst.operands[0].reg == inst.operands[1].reg)
    as_tsktsk (_("rdhi and rdlo must be different"));
}

/* ARM V5E (El Segundo) signed-multiply (argument parse)
   SMULxy{cond} Rd,Rm,Rs
   Error if any register is R15.  */

static void
do_smul (void)
{
  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 8;
}

/* ARM V6 srs (argument parse).	 */

static void
do_srs (void)
{
  inst.instruction |= inst.operands[0].imm;
  if (inst.operands[0].writeback)
    inst.instruction |= WRITE_BACK;
}

/* ARM V6 strex (argument parse).  */

static void
do_strex (void)
{
  constraint (!inst.operands[2].isreg || !inst.operands[2].preind
	      || inst.operands[2].postind || inst.operands[2].writeback
	      || inst.operands[2].immisreg || inst.operands[2].shifted
	      || inst.operands[2].negative,
	      _("instruction does not accept this addressing mode"));

  constraint (inst.operands[2].reg == REG_PC, BAD_PC);

  constraint (inst.operands[0].reg == inst.operands[1].reg
	      || inst.operands[0].reg == inst.operands[2].reg, BAD_OVERLAP);

  constraint (inst.reloc.exp.X_op != O_constant
	      || inst.reloc.exp.X_add_number != 0,
	      _("offset must be zero in ARM encoding"));

  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 16;
  inst.reloc.type = BFD_RELOC_UNUSED;
}

static void
do_strexd (void)
{
  constraint (inst.operands[1].reg % 2 != 0,
	      _("even register required"));
  constraint (inst.operands[2].present
	      && inst.operands[2].reg != inst.operands[1].reg + 1,
	      _("can only store two consecutive registers"));
  /* If op 2 were present and equal to PC, this function wouldn't
     have been called in the first place.  */
  constraint (inst.operands[1].reg == REG_LR, _("r14 not allowed here"));

  constraint (inst.operands[0].reg == inst.operands[1].reg
	      || inst.operands[0].reg == inst.operands[1].reg + 1
	      || inst.operands[0].reg == inst.operands[3].reg,
	      BAD_OVERLAP);

  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[3].reg << 16;
}

/* ARM V6 SXTAH extracts a 16-bit value from a register, sign
   extends it to 32-bits, and adds the result to a value in another
   register.  You can specify a rotation by 0, 8, 16, or 24 bits
   before extracting the 16-bit value.
   SXTAH{<cond>} <Rd>, <Rn>, <Rm>{, <rotation>}
   Condition defaults to COND_ALWAYS.
   Error if any register uses R15.  */

static void
do_sxtah (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
  inst.instruction |= inst.operands[3].imm << 10;
}

/* ARM V6 SXTH.

   SXTH {<cond>} <Rd>, <Rm>{, <rotation>}
   Condition defaults to COND_ALWAYS.
   Error if any register uses R15.  */

static void
do_sxth (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].imm << 10;
}

/* VFP instructions.  In a logical order: SP variant first, monad
   before dyad, arithmetic then move then load/store.  */

static void
do_vfp_sp_monadic (void)
{
  encode_arm_vfp_sp_reg (inst.operands[0].reg, VFP_REG_Sd);
  encode_arm_vfp_sp_reg (inst.operands[1].reg, VFP_REG_Sm);
}

static void
do_vfp_sp_dyadic (void)
{
  encode_arm_vfp_sp_reg (inst.operands[0].reg, VFP_REG_Sd);
  encode_arm_vfp_sp_reg (inst.operands[1].reg, VFP_REG_Sn);
  encode_arm_vfp_sp_reg (inst.operands[2].reg, VFP_REG_Sm);
}

static void
do_vfp_sp_compare_z (void)
{
  encode_arm_vfp_sp_reg (inst.operands[0].reg, VFP_REG_Sd);
}

static void
do_vfp_dp_sp_cvt (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_vfp_sp_reg (inst.operands[1].reg, VFP_REG_Sm);
}

static void
do_vfp_sp_dp_cvt (void)
{
  encode_arm_vfp_sp_reg (inst.operands[0].reg, VFP_REG_Sd);
  inst.instruction |= inst.operands[1].reg;
}

static void
do_vfp_reg_from_sp (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_vfp_sp_reg (inst.operands[1].reg, VFP_REG_Sn);
}

static void
do_vfp_reg2_from_sp2 (void)
{
  constraint (inst.operands[2].imm != 2,
	      _("only two consecutive VFP SP registers allowed here"));
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  encode_arm_vfp_sp_reg (inst.operands[2].reg, VFP_REG_Sm);
}

static void
do_vfp_sp_from_reg (void)
{
  encode_arm_vfp_sp_reg (inst.operands[0].reg, VFP_REG_Sn);
  inst.instruction |= inst.operands[1].reg << 12;
}

static void
do_vfp_sp2_from_reg2 (void)
{
  constraint (inst.operands[0].imm != 2,
	      _("only two consecutive VFP SP registers allowed here"));
  encode_arm_vfp_sp_reg (inst.operands[0].reg, VFP_REG_Sm);
  inst.instruction |= inst.operands[1].reg << 12;
  inst.instruction |= inst.operands[2].reg << 16;
}

static void
do_vfp_sp_ldst (void)
{
  encode_arm_vfp_sp_reg (inst.operands[0].reg, VFP_REG_Sd);
  encode_arm_cp_address (1, FALSE, TRUE, 0);
}

static void
do_vfp_dp_ldst (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_cp_address (1, FALSE, TRUE, 0);
}


static void
vfp_sp_ldstm (enum vfp_ldstm_type ldstm_type)
{
  if (inst.operands[0].writeback)
    inst.instruction |= WRITE_BACK;
  else
    constraint (ldstm_type != VFP_LDSTMIA,
		_("this addressing mode requires base-register writeback"));
  inst.instruction |= inst.operands[0].reg << 16;
  encode_arm_vfp_sp_reg (inst.operands[1].reg, VFP_REG_Sd);
  inst.instruction |= inst.operands[1].imm;
}

static void
vfp_dp_ldstm (enum vfp_ldstm_type ldstm_type)
{
  int count;

  if (inst.operands[0].writeback)
    inst.instruction |= WRITE_BACK;
  else
    constraint (ldstm_type != VFP_LDSTMIA && ldstm_type != VFP_LDSTMIAX,
		_("this addressing mode requires base-register writeback"));

  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg << 12;

  count = inst.operands[1].imm << 1;
  if (ldstm_type == VFP_LDSTMIAX || ldstm_type == VFP_LDSTMDBX)
    count += 1;

  inst.instruction |= count;
}

static void
do_vfp_sp_ldstmia (void)
{
  vfp_sp_ldstm (VFP_LDSTMIA);
}

static void
do_vfp_sp_ldstmdb (void)
{
  vfp_sp_ldstm (VFP_LDSTMDB);
}

static void
do_vfp_dp_ldstmia (void)
{
  vfp_dp_ldstm (VFP_LDSTMIA);
}

static void
do_vfp_dp_ldstmdb (void)
{
  vfp_dp_ldstm (VFP_LDSTMDB);
}

static void
do_vfp_xp_ldstmia (void)
{
  vfp_dp_ldstm (VFP_LDSTMIAX);
}

static void
do_vfp_xp_ldstmdb (void)
{
  vfp_dp_ldstm (VFP_LDSTMDBX);
}

/* FPA instructions.  Also in a logical order.	*/

static void
do_fpa_cmp (void)
{
  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg;
}

static void
do_fpa_ldmstm (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  switch (inst.operands[1].imm)
    {
    case 1: inst.instruction |= CP_T_X;		 break;
    case 2: inst.instruction |= CP_T_Y;		 break;
    case 3: inst.instruction |= CP_T_Y | CP_T_X; break;
    case 4:					 break;
    default: abort ();
    }

  if (inst.instruction & (PRE_INDEX | INDEX_UP))
    {
      /* The instruction specified "ea" or "fd", so we can only accept
	 [Rn]{!}.  The instruction does not really support stacking or
	 unstacking, so we have to emulate these by setting appropriate
	 bits and offsets.  */
      constraint (inst.reloc.exp.X_op != O_constant
		  || inst.reloc.exp.X_add_number != 0,
		  _("this instruction does not support indexing"));

      if ((inst.instruction & PRE_INDEX) || inst.operands[2].writeback)
	inst.reloc.exp.X_add_number = 12 * inst.operands[1].imm;

      if (!(inst.instruction & INDEX_UP))
	inst.reloc.exp.X_add_number = -inst.reloc.exp.X_add_number;

      if (!(inst.instruction & PRE_INDEX) && inst.operands[2].writeback)
	{
	  inst.operands[2].preind = 0;
	  inst.operands[2].postind = 1;
	}
    }

  encode_arm_cp_address (2, TRUE, TRUE, 0);
}

/* iWMMXt instructions: strictly in alphabetical order.	 */

static void
do_iwmmxt_tandorc (void)
{
  constraint (inst.operands[0].reg != REG_PC, _("only r15 allowed here"));
}

static void
do_iwmmxt_textrc (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].imm;
}

static void
do_iwmmxt_textrm (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].imm;
}

static void
do_iwmmxt_tinsr (void)
{
  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg << 12;
  inst.instruction |= inst.operands[2].imm;
}

static void
do_iwmmxt_tmia (void)
{
  inst.instruction |= inst.operands[0].reg << 5;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 12;
}

static void
do_iwmmxt_waligni (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
  inst.instruction |= inst.operands[3].imm << 20;
}

static void
do_iwmmxt_wmov (void)
{
  /* WMOV rD, rN is an alias for WOR rD, rN, rN.  */
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[1].reg;
}

static void
do_iwmmxt_wldstbh (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.reloc.exp.X_add_number *= 4;
  encode_arm_cp_address (1, TRUE, FALSE, BFD_RELOC_ARM_CP_OFF_IMM_S2);
}

static void
do_iwmmxt_wldstw (void)
{
  /* RIWR_RIWC clears .isreg for a control register.  */
  if (!inst.operands[0].isreg)
    {
      constraint (inst.cond != COND_ALWAYS, BAD_COND);
      inst.instruction |= 0xf0000000;
    }

  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_cp_address (1, TRUE, TRUE, 0);
}

static void
do_iwmmxt_wldstd (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_cp_address (1, TRUE, FALSE, BFD_RELOC_ARM_CP_OFF_IMM_S2);
}

static void
do_iwmmxt_wshufh (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= ((inst.operands[2].imm & 0xf0) << 16);
  inst.instruction |= (inst.operands[2].imm & 0x0f);
}

static void
do_iwmmxt_wzero (void)
{
  /* WZERO reg is an alias for WANDN reg, reg, reg.  */
  inst.instruction |= inst.operands[0].reg;
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[0].reg << 16;
}

/* Cirrus Maverick instructions.  Simple 2-, 3-, and 4-register
   operations first, then control, shift, and load/store.  */

/* Insns like "foo X,Y,Z".  */

static void
do_mav_triple (void)
{
  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 12;
}

/* Insns like "foo W,X,Y,Z".
    where W=MVAX[0:3] and X,Y,Z=MVFX[0:15].  */

static void
do_mav_quad (void)
{
  inst.instruction |= inst.operands[0].reg << 5;
  inst.instruction |= inst.operands[1].reg << 12;
  inst.instruction |= inst.operands[2].reg << 16;
  inst.instruction |= inst.operands[3].reg;
}

/* cfmvsc32<cond> DSPSC,MVDX[15:0].  */
static void
do_mav_dspsc (void)
{
  inst.instruction |= inst.operands[1].reg << 12;
}

/* Maverick shift immediate instructions.
   cfsh32<cond> MVFX[15:0],MVFX[15:0],Shift[6:0].
   cfsh64<cond> MVDX[15:0],MVDX[15:0],Shift[6:0].  */

static void
do_mav_shift (void)
{
  int imm = inst.operands[2].imm;

  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;

  /* Bits 0-3 of the insn should have bits 0-3 of the immediate.
     Bits 5-7 of the insn should have bits 4-6 of the immediate.
     Bit 4 should be 0.	 */
  imm = (imm & 0xf) | ((imm & 0x70) << 1);

  inst.instruction |= imm;
}

/* XScale instructions.	 Also sorted arithmetic before move.  */

/* Xscale multiply-accumulate (argument parse)
     MIAcc   acc0,Rm,Rs
     MIAPHcc acc0,Rm,Rs
     MIAxycc acc0,Rm,Rs.  */

static void
do_xsc_mia (void)
{
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 12;
}

/* Xscale move-accumulator-register (argument parse)

     MARcc   acc0,RdLo,RdHi.  */

static void
do_xsc_mar (void)
{
  inst.instruction |= inst.operands[1].reg << 12;
  inst.instruction |= inst.operands[2].reg << 16;
}

/* Xscale move-register-accumulator (argument parse)

     MRAcc   RdLo,RdHi,acc0.  */

static void
do_xsc_mra (void)
{
  constraint (inst.operands[0].reg == inst.operands[1].reg, BAD_OVERLAP);
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
}

/* Encoding functions relevant only to Thumb.  */

/* inst.operands[i] is a shifted-register operand; encode
   it into inst.instruction in the format used by Thumb32.  */

static void
encode_thumb32_shifted_operand (int i)
{
  unsigned int value = inst.reloc.exp.X_add_number;
  unsigned int shift = inst.operands[i].shift_kind;

  inst.instruction |= inst.operands[i].reg;
  if (shift == SHIFT_RRX)
    inst.instruction |= SHIFT_ROR << 4;
  else
    {
      constraint (inst.reloc.exp.X_op != O_constant,
		  _("expression too complex"));

      constraint (value > 32
		  || (value == 32 && (shift == SHIFT_LSL
				      || shift == SHIFT_ROR)),
		  _("shift expression is too large"));

      if (value == 0)
	shift = SHIFT_LSL;
      else if (value == 32)
	value = 0;

      inst.instruction |= shift << 4;
      inst.instruction |= (value & 0x1c) << 10;
      inst.instruction |= (value & 0x03) << 6;
    }
}


/* inst.operands[i] was set up by parse_address.  Encode it into a
   Thumb32 format load or store instruction.  Reject forms that cannot
   be used with such instructions.  If is_t is true, reject forms that
   cannot be used with a T instruction; if is_d is true, reject forms
   that cannot be used with a D instruction.  */

static void
encode_thumb32_addr_mode (int i, bfd_boolean is_t, bfd_boolean is_d)
{
  bfd_boolean is_pc = (inst.operands[i].reg == REG_PC);

  constraint (!inst.operands[i].isreg,
	      _("Thumb does not support the ldr =N pseudo-operation"));

  inst.instruction |= inst.operands[i].reg << 16;
  if (inst.operands[i].immisreg)
    {
      constraint (is_pc, _("cannot use register index with PC-relative addressing"));
      constraint (is_t || is_d, _("cannot use register index with this instruction"));
      constraint (inst.operands[i].negative,
		  _("Thumb does not support negative register indexing"));
      constraint (inst.operands[i].postind,
		  _("Thumb does not support register post-indexing"));
      constraint (inst.operands[i].writeback,
		  _("Thumb does not support register indexing with writeback"));
      constraint (inst.operands[i].shifted && inst.operands[i].shift_kind != SHIFT_LSL,
		  _("Thumb supports only LSL in shifted register indexing"));

      inst.instruction |= inst.operands[1].imm;
      if (inst.operands[i].shifted)
	{
	  constraint (inst.reloc.exp.X_op != O_constant,
		      _("expression too complex"));
	  constraint (inst.reloc.exp.X_add_number < 0 || inst.reloc.exp.X_add_number > 3,
		      _("shift out of range"));
	  inst.instruction |= inst.reloc.exp.X_op << 4;
	}
      inst.reloc.type = BFD_RELOC_UNUSED;
    }
  else if (inst.operands[i].preind)
    {
      constraint (is_pc && inst.operands[i].writeback,
		  _("cannot use writeback with PC-relative addressing"));
      constraint (is_t && inst.operands[1].writeback,
		  _("cannot use writeback with this instruction"));

      if (is_d)
	{
	  inst.instruction |= 0x01000000;
	  if (inst.operands[i].writeback)
	    inst.instruction |= 0x00200000;
	}
      else
	{
	  inst.instruction |= 0x00000c00;
	  if (inst.operands[i].writeback)
	    inst.instruction |= 0x00000100;
	}
      inst.reloc.type = BFD_RELOC_ARM_T32_OFFSET_IMM;
      inst.reloc.pc_rel = is_pc;
    }
  else if (inst.operands[i].postind)
    {
      assert (inst.operands[i].writeback);
      constraint (is_pc, _("cannot use post-indexing with PC-relative addressing"));
      constraint (is_t, _("cannot use post-indexing with this instruction"));

      if (is_d)
	inst.instruction |= 0x00200000;
      else
	inst.instruction |= 0x00000900;
      inst.reloc.type = BFD_RELOC_ARM_T32_OFFSET_IMM;
    }
  else /* unindexed - only for coprocessor */
    inst.error = _("instruction does not accept unindexed addressing");
}

/* Table of Thumb instructions which exist in both 16- and 32-bit
   encodings (the latter only in post-V6T2 cores).  The index is the
   value used in the insns table below.  When there is more than one
   possible 16-bit encoding for the instruction, this table always
   holds variant (1).  */
#define T16_32_TAB				\
  X(adc,   4140, eb400000),			\
  X(adcs,  4140, eb500000),			\
  X(add,   1c00, eb000000),			\
  X(adds,  1c00, eb100000),			\
  X(and,   4000, ea000000),			\
  X(ands,  4000, ea100000),			\
  X(asr,   1000, fa40f000),			\
  X(asrs,  1000, fa50f000),			\
  X(bic,   4380, ea200000),			\
  X(bics,  4380, ea300000),			\
  X(cmn,   42c0, eb100f00),			\
  X(cmp,   2800, ebb00f00),			\
  X(cpsie, b660, f3af8400),			\
  X(cpsid, b670, f3af8600),			\
  X(cpy,   4600, ea4f0000),			\
  X(eor,   4040, ea800000),			\
  X(eors,  4040, ea900000),			\
  X(ldmia, c800, e8900000),			\
  X(ldr,   6800, f8500000),			\
  X(ldrb,  7800, f8100000),			\
  X(ldrh,  8800, f8300000),			\
  X(ldrsb, 5600, f9100000),			\
  X(ldrsh, 5e00, f9300000),			\
  X(lsl,   0000, fa00f000),			\
  X(lsls,  0000, fa10f000),			\
  X(lsr,   0800, fa20f000),			\
  X(lsrs,  0800, fa30f000),			\
  X(mov,   2000, ea4f0000),			\
  X(movs,  2000, ea5f0000),			\
  X(mul,   4340, fb00f000),                     \
  X(muls,  4340, ffffffff), /* no 32b muls */	\
  X(mvn,   43c0, ea6f0000),			\
  X(mvns,  43c0, ea7f0000),			\
  X(neg,   4240, f1c00000), /* rsb #0 */	\
  X(negs,  4240, f1d00000), /* rsbs #0 */	\
  X(orr,   4300, ea400000),			\
  X(orrs,  4300, ea500000),			\
  X(pop,   bc00, e8ad0000), /* ldmia sp!,... */	\
  X(push,  b400, e8bd0000), /* stmia sp!,... */	\
  X(rev,   ba00, fa90f080),			\
  X(rev16, ba40, fa90f090),			\
  X(revsh, bac0, fa90f0b0),			\
  X(ror,   41c0, fa60f000),			\
  X(rors,  41c0, fa70f000),			\
  X(sbc,   4180, eb600000),			\
  X(sbcs,  4180, eb700000),			\
  X(stmia, c000, e8800000),			\
  X(str,   6000, f8400000),			\
  X(strb,  7000, f8000000),			\
  X(strh,  8000, f8200000),			\
  X(sub,   1e00, eba00000),			\
  X(subs,  1e00, ebb00000),			\
  X(sxtb,  b240, fa4ff080),			\
  X(sxth,  b200, fa0ff080),			\
  X(tst,   4200, ea100f00),			\
  X(uxtb,  b2c0, fa5ff080),			\
  X(uxth,  b280, fa1ff080),			\
  X(nop,   bf00, f3af8000),			\
  X(yield, bf10, f3af8001),			\
  X(wfe,   bf20, f3af8002),			\
  X(wfi,   bf30, f3af8003),			\
  X(sev,   bf40, f3af9004), /* typo, 8004? */

/* To catch errors in encoding functions, the codes are all offset by
   0xF800, putting them in one of the 32-bit prefix ranges, ergo undefined
   as 16-bit instructions.  */
#define X(a,b,c) T_MNEM_##a
enum t16_32_codes { T16_32_OFFSET = 0xF7FF, T16_32_TAB };
#undef X

#define X(a,b,c) 0x##b
static const unsigned short thumb_op16[] = { T16_32_TAB };
#define THUMB_OP16(n) (thumb_op16[(n) - (T16_32_OFFSET + 1)])
#undef X

#define X(a,b,c) 0x##c
static const unsigned int thumb_op32[] = { T16_32_TAB };
#define THUMB_OP32(n) (thumb_op32[(n) - (T16_32_OFFSET + 1)])
#define THUMB_SETS_FLAGS(n) (THUMB_OP32 (n) & 0x00100000)
#undef X
#undef T16_32_TAB

/* Thumb instruction encoders, in alphabetical order.  */

/* Parse an add or subtract instruction.  We get here with inst.instruction
   equalling any of THUMB_OPCODE_add, adds, sub, or subs.  */

static void
do_t_add_sub (void)
{
  int Rd, Rs, Rn;

  Rd = inst.operands[0].reg;
  Rs = (inst.operands[1].present
	? inst.operands[1].reg    /* Rd, Rs, foo */
	: inst.operands[0].reg);  /* Rd, foo -> Rd, Rd, foo */

  if (unified_syntax)
    {
      if (!inst.operands[2].isreg)
	{
	  /* For an immediate, we always generate a 32-bit opcode;
	     section relaxation will shrink it later if possible.  */
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
	  inst.instruction |= inst.operands[0].reg << 8;
	  inst.instruction |= inst.operands[1].reg << 16;
	  inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
	}
      else
	{
	  Rn = inst.operands[2].reg;
	  /* See if we can do this with a 16-bit instruction.  */
	  if (!inst.operands[2].shifted && inst.size_req != 4)
	    {
	      if (Rd <= 7 && Rn <= 7 && Rn <= 7
		  && (inst.instruction == T_MNEM_adds
		      || inst.instruction == T_MNEM_subs))
		{
		  inst.instruction = (inst.instruction == T_MNEM_adds
				      ? T_OPCODE_ADD_R3
				      : T_OPCODE_SUB_R3);
		  inst.instruction |= Rd | (Rs << 3) | (Rn << 6);
		  return;
		}

	      if (inst.instruction == T_MNEM_add)
		{
		  if (Rd == Rs)
		    {
		      inst.instruction = T_OPCODE_ADD_HI;
		      inst.instruction |= (Rd & 8) << 4;
		      inst.instruction |= (Rd & 7);
		      inst.instruction |= Rn << 3;
		      return;
		    }
		  /* ... because addition is commutative! */
		  else if (Rd == Rn)
		    {
		      inst.instruction = T_OPCODE_ADD_HI;
		      inst.instruction |= (Rd & 8) << 4;
		      inst.instruction |= (Rd & 7);
		      inst.instruction |= Rs << 3;
		      return;
		    }
		}
	    }
	  /* If we get here, it can't be done in 16 bits.  */
	  constraint (inst.operands[2].shifted && inst.operands[2].immisreg,
		      _("shift must be constant"));
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction |= Rd << 8;
	  inst.instruction |= Rs << 16;
	  encode_thumb32_shifted_operand (2);
	}
    }
  else
    {
      constraint (inst.instruction == T_MNEM_adds
		  || inst.instruction == T_MNEM_subs,
		  BAD_THUMB32);

      if (!inst.operands[2].isreg) /* Rd, Rs, #imm */
	{
	  constraint ((Rd > 7 && (Rd != REG_SP || Rs != REG_SP))
		      || (Rs > 7 && Rs != REG_SP && Rs != REG_PC),
		      BAD_HIREG);

	  inst.instruction = (inst.instruction == T_MNEM_add
			      ? 0x0000 : 0x8000);
	  inst.instruction |= (Rd << 4) | Rs;
	  inst.reloc.type = BFD_RELOC_ARM_THUMB_ADD;
	  return;
	}

      Rn = inst.operands[2].reg;
      constraint (inst.operands[2].shifted, _("unshifted register required"));

      /* We now have Rd, Rs, and Rn set to registers.  */
      if (Rd > 7 || Rs > 7 || Rn > 7)
	{
	  /* Can't do this for SUB.	 */
	  constraint (inst.instruction == T_MNEM_sub, BAD_HIREG);
	  inst.instruction = T_OPCODE_ADD_HI;
	  inst.instruction |= (Rd & 8) << 4;
	  inst.instruction |= (Rd & 7);
	  if (Rs == Rd)
	    inst.instruction |= Rn << 3;
	  else if (Rn == Rd)
	    inst.instruction |= Rs << 3;
	  else
	    constraint (1, _("dest must overlap one source register"));
	}
      else
	{
	  inst.instruction = (inst.instruction == T_MNEM_add
			      ? T_OPCODE_ADD_R3 : T_OPCODE_SUB_R3);
	  inst.instruction |= Rd | (Rs << 3) | (Rn << 6);
	}
    }
}

static void
do_t_adr (void)
{
  inst.reloc.type = BFD_RELOC_ARM_THUMB_ADD;
  inst.reloc.exp.X_add_number -= 4; /* PC relative adjust.  */
  inst.reloc.pc_rel = 1;

  inst.instruction |= inst.operands[0].reg << 4;
}

/* Arithmetic instructions for which there is just one 16-bit
   instruction encoding, and it allows only two low registers.
   For maximal compatibility with ARM syntax, we allow three register
   operands even when Thumb-32 instructions are not available, as long
   as the first two are identical.  For instance, both "sbc r0,r1" and
   "sbc r0,r0,r1" are allowed.  */
static void
do_t_arit3 (void)
{
  int Rd, Rs, Rn;

  Rd = inst.operands[0].reg;
  Rs = (inst.operands[1].present
	? inst.operands[1].reg    /* Rd, Rs, foo */
	: inst.operands[0].reg);  /* Rd, foo -> Rd, Rd, foo */
  Rn = inst.operands[2].reg;

  if (unified_syntax)
    {
      if (!inst.operands[2].isreg)
	{
	  /* For an immediate, we always generate a 32-bit opcode;
	     section relaxation will shrink it later if possible.  */
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
	  inst.instruction |= Rd << 8;
	  inst.instruction |= Rs << 16;
	  inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
	}
      else
	{
	  /* See if we can do this with a 16-bit instruction.  */
	  if (THUMB_SETS_FLAGS (inst.instruction)
	      && !inst.operands[2].shifted
	      && inst.size_req != 4
	      && Rd == Rs)
	    {
	      inst.instruction = THUMB_OP16 (inst.instruction);
	      inst.instruction |= Rd;
	      inst.instruction |= Rn << 3;
	      return;
	    }

	  /* If we get here, it can't be done in 16 bits.  */
	  constraint (inst.operands[2].shifted
		      && inst.operands[2].immisreg,
		      _("shift must be constant"));
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction |= Rd << 8;
	  inst.instruction |= Rs << 16;
	  encode_thumb32_shifted_operand (2);
	}
    }
  else
    {
      /* On its face this is a lie - the instruction does set the
	 flags.  However, the only supported mnemonic in this mode
	 says it doesn't.  */
      constraint (THUMB_SETS_FLAGS (inst.instruction), BAD_THUMB32);

      constraint (!inst.operands[2].isreg || inst.operands[2].shifted,
		  _("unshifted register required"));
      constraint (Rd > 7 || Rs > 7 || Rn > 7, BAD_HIREG);
      constraint (Rd != Rs,
		  _("dest and source1 must be the same register"));

      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= Rd;
      inst.instruction |= Rn << 3;
    }
}

/* Similarly, but for instructions where the arithmetic operation is
   commutative, so we can allow either of them to be different from
   the destination operand in a 16-bit instruction.  For instance, all
   three of "adc r0,r1", "adc r0,r0,r1", and "adc r0,r1,r0" are
   accepted.  */
static void
do_t_arit3c (void)
{
  int Rd, Rs, Rn;

  Rd = inst.operands[0].reg;
  Rs = (inst.operands[1].present
	? inst.operands[1].reg    /* Rd, Rs, foo */
	: inst.operands[0].reg);  /* Rd, foo -> Rd, Rd, foo */
  Rn = inst.operands[2].reg;

  if (unified_syntax)
    {
      if (!inst.operands[2].isreg)
	{
	  /* For an immediate, we always generate a 32-bit opcode;
	     section relaxation will shrink it later if possible.  */
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
	  inst.instruction |= Rd << 8;
	  inst.instruction |= Rs << 16;
	  inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
	}
      else
	{
	  /* See if we can do this with a 16-bit instruction.  */
	  if (THUMB_SETS_FLAGS (inst.instruction)
	      && !inst.operands[2].shifted
	      && inst.size_req != 4)
	    {
	      if (Rd == Rs)
		{
		  inst.instruction = THUMB_OP16 (inst.instruction);
		  inst.instruction |= Rd;
		  inst.instruction |= Rn << 3;
		  return;
		}
	      if (Rd == Rn)
		{
		  inst.instruction = THUMB_OP16 (inst.instruction);
		  inst.instruction |= Rd;
		  inst.instruction |= Rs << 3;
		  return;
		}
	    }

	  /* If we get here, it can't be done in 16 bits.  */
	  constraint (inst.operands[2].shifted
		      && inst.operands[2].immisreg,
		      _("shift must be constant"));
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction |= Rd << 8;
	  inst.instruction |= Rs << 16;
	  encode_thumb32_shifted_operand (2);
	}
    }
  else
    {
      /* On its face this is a lie - the instruction does set the
	 flags.  However, the only supported mnemonic in this mode
	 says it doesn't.  */
      constraint (THUMB_SETS_FLAGS (inst.instruction), BAD_THUMB32);

      constraint (!inst.operands[2].isreg || inst.operands[2].shifted,
		  _("unshifted register required"));
      constraint (Rd > 7 || Rs > 7 || Rn > 7, BAD_HIREG);

      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= Rd;

      if (Rd == Rs)
	inst.instruction |= Rn << 3;
      else if (Rd == Rn)
	inst.instruction |= Rs << 3;
      else
	constraint (1, _("dest must overlap one source register"));
    }
}

static void
do_t_bfc (void)
{
  unsigned int msb = inst.operands[1].imm + inst.operands[2].imm;
  constraint (msb > 32, _("bit-field extends past end of register"));
  /* The instruction encoding stores the LSB and MSB,
     not the LSB and width.  */
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= (inst.operands[1].imm & 0x1c) << 10;
  inst.instruction |= (inst.operands[1].imm & 0x03) << 6;
  inst.instruction |= msb - 1;
}

static void
do_t_bfi (void)
{
  unsigned int msb;

  /* #0 in second position is alternative syntax for bfc, which is
     the same instruction but with REG_PC in the Rm field.  */
  if (!inst.operands[1].isreg)
    inst.operands[1].reg = REG_PC;

  msb = inst.operands[2].imm + inst.operands[3].imm;
  constraint (msb > 32, _("bit-field extends past end of register"));
  /* The instruction encoding stores the LSB and MSB,
     not the LSB and width.  */
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= (inst.operands[2].imm & 0x1c) << 10;
  inst.instruction |= (inst.operands[2].imm & 0x03) << 6;
  inst.instruction |= msb - 1;
}

static void
do_t_bfx (void)
{
  constraint (inst.operands[2].imm + inst.operands[3].imm > 32,
	      _("bit-field extends past end of register"));
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= (inst.operands[2].imm & 0x1c) << 10;
  inst.instruction |= (inst.operands[2].imm & 0x03) << 6;
  inst.instruction |= inst.operands[3].imm - 1;
}

/* ARM V5 Thumb BLX (argument parse)
	BLX <target_addr>	which is BLX(1)
	BLX <Rm>		which is BLX(2)
   Unfortunately, there are two different opcodes for this mnemonic.
   So, the insns[].value is not used, and the code here zaps values
	into inst.instruction.

   ??? How to take advantage of the additional two bits of displacement
   available in Thumb32 mode?  Need new relocation?  */

static void
do_t_blx (void)
{
  if (inst.operands[0].isreg)
    /* We have a register, so this is BLX(2).  */
    inst.instruction |= inst.operands[0].reg << 3;
  else
    {
      /* No register.  This must be BLX(1).  */
      inst.instruction = 0xf000e800;
      inst.reloc.type	= BFD_RELOC_THUMB_PCREL_BLX;
      inst.reloc.pc_rel = 1;
    }
}

static void
do_t_branch (void)
{
  if (unified_syntax && inst.size_req != 2)
    {
      if (inst.cond == COND_ALWAYS)
	{
	  inst.instruction = 0xf000b000;
	  inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH25;
	}
      else
	{
	  assert (inst.cond != 0xF);
	  inst.instruction = (inst.cond << 22) | 0xf0008000;
	  inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH20;
	}
    }
  else
    {
      if (inst.cond == COND_ALWAYS)
	inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH12;
      else
	{
	  inst.instruction = 0xd000 | (inst.cond << 8);
	  inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH9;
	}
    }

  inst.reloc.pc_rel = 1;
}

static void
do_t_bkpt (void)
{
  if (inst.operands[0].present)
    {
      constraint (inst.operands[0].imm > 255,
		  _("immediate value out of range"));
      inst.instruction |= inst.operands[0].imm;
    }
}

static void
do_t_branch23 (void)
{
  inst.reloc.type   = BFD_RELOC_THUMB_PCREL_BRANCH23;
  inst.reloc.pc_rel = 1;

  /* If the destination of the branch is a defined symbol which does not have
     the THUMB_FUNC attribute, then we must be calling a function which has
     the (interfacearm) attribute.  We look for the Thumb entry point to that
     function and change the branch to refer to that function instead.	*/
  if (	 inst.reloc.exp.X_op == O_symbol
      && inst.reloc.exp.X_add_symbol != NULL
      && S_IS_DEFINED (inst.reloc.exp.X_add_symbol)
      && ! THUMB_IS_FUNC (inst.reloc.exp.X_add_symbol))
    inst.reloc.exp.X_add_symbol =
      find_real_start (inst.reloc.exp.X_add_symbol);
}

static void
do_t_bx (void)
{
  inst.instruction |= inst.operands[0].reg << 3;
  /* ??? FIXME: Should add a hacky reloc here if reg is REG_PC.	 The reloc
     should cause the alignment to be checked once it is known.	 This is
     because BX PC only works if the instruction is word aligned.  */
}

static void
do_t_bxj (void)
{
  if (inst.operands[0].reg == REG_PC)
    as_tsktsk (_("use of r15 in bxj is not really useful"));

  inst.instruction |= inst.operands[0].reg << 16;
}

static void
do_t_clz (void)
{
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[1].reg;
}

static void
do_t_cpsi (void)
{
  if (unified_syntax
      && (inst.operands[1].present || inst.size_req == 4))
    {
      unsigned int imod = (inst.instruction & 0x0030) >> 4;
      inst.instruction = 0xf3af8000;
      inst.instruction |= imod << 9;
      inst.instruction |= inst.operands[0].imm << 5;
      if (inst.operands[1].present)
	inst.instruction |= 0x100 | inst.operands[1].imm;
    }
  else
    {
      constraint (inst.operands[1].present,
		  _("Thumb does not support the 2-argument "
		    "form of this instruction"));
      inst.instruction |= inst.operands[0].imm;
    }
}

/* THUMB CPY instruction (argument parse).  */

static void
do_t_cpy (void)
{
  if (inst.size_req == 4)
    {
      inst.instruction = THUMB_OP32 (T_MNEM_mov);
      inst.instruction |= inst.operands[0].reg << 8;
      inst.instruction |= inst.operands[1].reg;
    }
  else
    {
      inst.instruction |= (inst.operands[0].reg & 0x8) << 4;
      inst.instruction |= (inst.operands[0].reg & 0x7);
      inst.instruction |= inst.operands[1].reg << 3;
    }
}

static void
do_t_czb (void)
{
  constraint (inst.operands[0].reg > 7, BAD_HIREG);
  inst.instruction |= inst.operands[0].reg;
  inst.reloc.pc_rel = 1;
  inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH7;
}

static void
do_t_hint (void)
{
  if (unified_syntax && inst.size_req == 4)
    inst.instruction = THUMB_OP32 (inst.instruction);
  else
    inst.instruction = THUMB_OP16 (inst.instruction);
}

static void
do_t_it (void)
{
  unsigned int cond = inst.operands[0].imm;
  if ((cond & 0x1) == 0x0)
    {
      unsigned int mask = inst.instruction & 0x000f;
      inst.instruction &= 0xfff0;

      if ((mask & 0x7) == 0)
	/* no conversion needed */;
      else if ((mask & 0x3) == 0)
	mask = (~(mask & 0x8) & 0x8) | 0x4;
      else if ((mask & 1) == 0)
	mask = (~(mask & 0xC) & 0xC) | 0x2;
      else
	mask = (~(mask & 0xE) & 0xE) | 0x1;

      inst.instruction |= (mask & 0xF);
    }

  inst.instruction |= cond << 4;
}

static void
do_t_ldmstm (void)
{
  /* This really doesn't seem worth it.  */
  constraint (inst.reloc.type != BFD_RELOC_UNUSED,
	      _("expression too complex"));
  constraint (inst.operands[1].writeback,
	      _("Thumb load/store multiple does not support {reglist}^"));

  if (unified_syntax)
    {
      /* See if we can use a 16-bit instruction.  */
      if (inst.instruction < 0xffff /* not ldmdb/stmdb */
	  && inst.size_req != 4
	  && inst.operands[0].reg <= 7
	  && !(inst.operands[1].imm & ~0xff)
	  && (inst.instruction == T_MNEM_stmia
	      ? inst.operands[0].writeback
	      : (inst.operands[0].writeback
		 == !(inst.operands[1].imm & (1 << inst.operands[0].reg)))))
	{
	  if (inst.instruction == T_MNEM_stmia
	      && (inst.operands[1].imm & (1 << inst.operands[0].reg))
	      && (inst.operands[1].imm & ((1 << inst.operands[0].reg) - 1)))
	    as_warn (_("value stored for r%d is UNPREDICTABLE"),
		     inst.operands[0].reg);

	  inst.instruction = THUMB_OP16 (inst.instruction);
	  inst.instruction |= inst.operands[0].reg << 8;
	  inst.instruction |= inst.operands[1].imm;
	}
      else
	{
	  if (inst.operands[1].imm & (1 << 13))
	    as_warn (_("SP should not be in register list"));
	  if (inst.instruction == T_MNEM_stmia)
	    {
	      if (inst.operands[1].imm & (1 << 15))
		as_warn (_("PC should not be in register list"));
	      if (inst.operands[1].imm & (1 << inst.operands[0].reg))
		as_warn (_("value stored for r%d is UNPREDICTABLE"),
			 inst.operands[0].reg);
	    }
	  else
	    {
	      if (inst.operands[1].imm & (1 << 14)
		  && inst.operands[1].imm & (1 << 15))
		as_warn (_("LR and PC should not both be in register list"));
	      if ((inst.operands[1].imm & (1 << inst.operands[0].reg))
		  && inst.operands[0].writeback)
		as_warn (_("base register should not be in register list "
			   "when written back"));
	    }
	  if (inst.instruction < 0xffff)
	    inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction |= inst.operands[0].reg << 16;
	  inst.instruction |= inst.operands[1].imm;
	  if (inst.operands[0].writeback)
	    inst.instruction |= WRITE_BACK;
	}
    }
  else
    {
      constraint (inst.operands[0].reg > 7
		  || (inst.operands[1].imm & ~0xff), BAD_HIREG);
      if (inst.instruction == T_MNEM_stmia)
	{
	  if (!inst.operands[0].writeback)
	    as_warn (_("this instruction will write back the base register"));
	  if ((inst.operands[1].imm & (1 << inst.operands[0].reg))
	      && (inst.operands[1].imm & ((1 << inst.operands[0].reg) - 1)))
	    as_warn (_("value stored for r%d is UNPREDICTABLE"),
		     inst.operands[0].reg);
	}
      else
	{
	  if (!inst.operands[0].writeback
	      && !(inst.operands[1].imm & (1 << inst.operands[0].reg)))
	    as_warn (_("this instruction will write back the base register"));
	  else if (inst.operands[0].writeback
		   && (inst.operands[1].imm & (1 << inst.operands[0].reg)))
	    as_warn (_("this instruction will not write back the base register"));
	}

      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= inst.operands[0].reg << 8;
      inst.instruction |= inst.operands[1].imm;
    }
}

static void
do_t_ldrex (void)
{
  constraint (!inst.operands[1].isreg || !inst.operands[1].preind
	      || inst.operands[1].postind || inst.operands[1].writeback
	      || inst.operands[1].immisreg || inst.operands[1].shifted
	      || inst.operands[1].negative,
	      _("instruction does not accept this addressing mode"));

  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.reloc.type = BFD_RELOC_ARM_T32_OFFSET_U8;
}

static void
do_t_ldrexd (void)
{
  if (!inst.operands[1].present)
    {
      constraint (inst.operands[0].reg == REG_LR,
		  _("r14 not allowed as first register "
		    "when second register is omitted"));
      inst.operands[1].reg = inst.operands[0].reg + 1;
    }
  constraint (inst.operands[0].reg == inst.operands[1].reg,
	      BAD_OVERLAP);

  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 8;
  inst.instruction |= inst.operands[2].reg << 16;
}

static void
do_t_ldst (void)
{
  if (unified_syntax)
    {
      /* Generation of 16-bit instructions for anything other than
	 Rd, [Rn, Ri] is deferred to section relaxation time.  */
      if (inst.operands[1].isreg && inst.operands[1].immisreg
	  && !inst.operands[1].shifted && !inst.operands[1].postind
	  && !inst.operands[1].negative && inst.operands[0].reg <= 7
	  && inst.operands[1].reg <= 7 && inst.operands[1].imm <= 7
	  && inst.instruction <= 0xffff)
	{
	  inst.instruction = THUMB_OP16 (inst.instruction);
	  goto op16;
	}

      inst.instruction = THUMB_OP32 (inst.instruction);
      inst.instruction |= inst.operands[0].reg << 12;
      encode_thumb32_addr_mode (1, /*is_t=*/FALSE, /*is_d=*/FALSE);
      return;
    }

  constraint (inst.operands[0].reg > 7, BAD_HIREG);

  if (inst.instruction == T_MNEM_ldrsh || inst.instruction == T_MNEM_ldrsb)
    {
      /* Only [Rn,Rm] is acceptable.  */
      constraint (inst.operands[1].reg > 7 || inst.operands[1].imm > 7, BAD_HIREG);
      constraint (!inst.operands[1].isreg || !inst.operands[1].immisreg
		  || inst.operands[1].postind || inst.operands[1].shifted
		  || inst.operands[1].negative,
		  _("Thumb does not support this addressing mode"));
      inst.instruction = THUMB_OP16 (inst.instruction);
      goto op16;
    }
     
  inst.instruction = THUMB_OP16 (inst.instruction);
  if (!inst.operands[1].isreg)
    if (move_or_literal_pool (0, /*thumb_p=*/TRUE, /*mode_3=*/FALSE))
      return;

  constraint (!inst.operands[1].preind
	      || inst.operands[1].shifted
	      || inst.operands[1].writeback,
	      _("Thumb does not support this addressing mode"));
  if (inst.operands[1].reg == REG_PC || inst.operands[1].reg == REG_SP)
    {
      constraint (inst.instruction & 0x0600,
		  _("byte or halfword not valid for base register"));
      constraint (inst.operands[1].reg == REG_PC
		  && !(inst.instruction & THUMB_LOAD_BIT),
		  _("r15 based store not allowed"));
      constraint (inst.operands[1].immisreg,
		  _("invalid base register for register offset"));

      if (inst.operands[1].reg == REG_PC)
	inst.instruction = T_OPCODE_LDR_PC;
      else if (inst.instruction & THUMB_LOAD_BIT)
	inst.instruction = T_OPCODE_LDR_SP;
      else
	inst.instruction = T_OPCODE_STR_SP;

      inst.instruction |= inst.operands[0].reg << 8;
      inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;
      return;
    }

  constraint (inst.operands[1].reg > 7, BAD_HIREG);
  if (!inst.operands[1].immisreg)
    {
      /* Immediate offset.  */
      inst.instruction |= inst.operands[0].reg;
      inst.instruction |= inst.operands[1].reg << 3;
      inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;
      return;
    }

  /* Register offset.  */
  constraint (inst.operands[1].imm > 7, BAD_HIREG);
  constraint (inst.operands[1].negative,
	      _("Thumb does not support this addressing mode"));

 op16:
  switch (inst.instruction)
    {
    case T_OPCODE_STR_IW: inst.instruction = T_OPCODE_STR_RW; break;
    case T_OPCODE_STR_IH: inst.instruction = T_OPCODE_STR_RH; break;
    case T_OPCODE_STR_IB: inst.instruction = T_OPCODE_STR_RB; break;
    case T_OPCODE_LDR_IW: inst.instruction = T_OPCODE_LDR_RW; break;
    case T_OPCODE_LDR_IH: inst.instruction = T_OPCODE_LDR_RH; break;
    case T_OPCODE_LDR_IB: inst.instruction = T_OPCODE_LDR_RB; break;
    case 0x5600 /* ldrsb */:
    case 0x5e00 /* ldrsh */: break;
    default: abort ();
    }

  inst.instruction |= inst.operands[0].reg;
  inst.instruction |= inst.operands[1].reg << 3;
  inst.instruction |= inst.operands[1].imm << 6;
}

static void
do_t_ldstd (void)
{
  if (!inst.operands[1].present)
    {
      inst.operands[1].reg = inst.operands[0].reg + 1;
      constraint (inst.operands[0].reg == REG_LR,
		  _("r14 not allowed here"));
    }
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 8;
  encode_thumb32_addr_mode (2, /*is_t=*/FALSE, /*is_d=*/TRUE);
			    
}

static void
do_t_ldstt (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  encode_thumb32_addr_mode (1, /*is_t=*/TRUE, /*is_d=*/FALSE);
}

static void
do_t_mla (void)
{
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
  inst.instruction |= inst.operands[3].reg << 12;
}

static void
do_t_mlal (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 8;
  inst.instruction |= inst.operands[2].reg << 16;
  inst.instruction |= inst.operands[3].reg;
}

static void
do_t_mov_cmp (void)
{
  if (unified_syntax)
    {
      int r0off = (inst.instruction == T_MNEM_mov
		   || inst.instruction == T_MNEM_movs) ? 8 : 16;
      if (!inst.operands[1].isreg)
	{
	  /* For an immediate, we always generate a 32-bit opcode;
	     section relaxation will shrink it later if possible.  */
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
	  inst.instruction |= inst.operands[0].reg << r0off;
	  inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
	}
      else if (inst.size_req == 4
	       || inst.operands[1].shifted
	       || (inst.instruction == T_MNEM_movs
		   && (inst.operands[0].reg > 7 || inst.operands[1].reg > 7)))
	{
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction |= inst.operands[0].reg << r0off;
	  encode_thumb32_shifted_operand (1);
	}
      else
	switch (inst.instruction)
	  {
	  case T_MNEM_mov:
	    inst.instruction = T_OPCODE_MOV_HR;
	    inst.instruction |= (inst.operands[0].reg & 0x8) << 4;
	    inst.instruction |= (inst.operands[0].reg & 0x7);
	    inst.instruction |= inst.operands[1].reg << 3;
	    break;

	  case T_MNEM_movs:
	    /* We know we have low registers at this point.
	       Generate ADD Rd, Rs, #0.  */
	    inst.instruction = T_OPCODE_ADD_I3;
	    inst.instruction |= inst.operands[0].reg;
	    inst.instruction |= inst.operands[1].reg << 3;
	    break;

	  case T_MNEM_cmp:
	    if (inst.operands[0].reg <= 7 && inst.operands[1].reg <= 7)
	      {
		inst.instruction = T_OPCODE_CMP_LR;
		inst.instruction |= inst.operands[0].reg;
		inst.instruction |= inst.operands[1].reg << 3;
	      }
	    else
	      {
		inst.instruction = T_OPCODE_CMP_HR;
		inst.instruction |= (inst.operands[0].reg & 0x8) << 4;
		inst.instruction |= (inst.operands[0].reg & 0x7);
		inst.instruction |= inst.operands[1].reg << 3;
	      }
	    break;
	  }
      return;
    }

  inst.instruction = THUMB_OP16 (inst.instruction);
  if (inst.operands[1].isreg)
    {
      if (inst.operands[0].reg < 8 && inst.operands[1].reg < 8)
	{
	  /* A move of two lowregs is encoded as ADD Rd, Rs, #0
	     since a MOV instruction produces unpredictable results.  */
	  if (inst.instruction == T_OPCODE_MOV_I8)
	    inst.instruction = T_OPCODE_ADD_I3;
	  else
	    inst.instruction = T_OPCODE_CMP_LR;

	  inst.instruction |= inst.operands[0].reg;
	  inst.instruction |= inst.operands[1].reg << 3;
	}
      else
	{
	  if (inst.instruction == T_OPCODE_MOV_I8)
	    inst.instruction = T_OPCODE_MOV_HR;
	  else
	    inst.instruction = T_OPCODE_CMP_HR;
	  do_t_cpy ();
	}
    }
  else
    {
      constraint (inst.operands[0].reg > 7,
		  _("only lo regs allowed with immediate"));
      inst.instruction |= inst.operands[0].reg << 8;
      inst.reloc.type = BFD_RELOC_ARM_THUMB_IMM;
    }
}

static void
do_t_mov16 (void)
{
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= (inst.operands[1].imm & 0xf000) << 4;
  inst.instruction |= (inst.operands[1].imm & 0x0800) << 15;
  inst.instruction |= (inst.operands[1].imm & 0x0700) << 4;
  inst.instruction |= (inst.operands[1].imm & 0x00ff);
}

static void
do_t_mvn_tst (void)
{
  if (unified_syntax)
    {
      int r0off = (inst.instruction == T_MNEM_mvn
		   || inst.instruction == T_MNEM_mvns) ? 8 : 16;
      if (!inst.operands[1].isreg)
	{
	  /* For an immediate, we always generate a 32-bit opcode;
	     section relaxation will shrink it later if possible.  */
	  if (inst.instruction < 0xffff)
	    inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
	  inst.instruction |= inst.operands[0].reg << r0off;
	  inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
	}
      else
	{
	  /* See if we can do this with a 16-bit instruction.  */
	  if (inst.instruction < 0xffff
	      && THUMB_SETS_FLAGS (inst.instruction)
	      && !inst.operands[1].shifted
	      && inst.operands[0].reg <= 7
	      && inst.operands[1].reg <= 7
	      && inst.size_req != 4)
	    {
	      inst.instruction = THUMB_OP16 (inst.instruction);
	      inst.instruction |= inst.operands[0].reg;
	      inst.instruction |= inst.operands[1].reg << 3;
	    }
	  else
	    {
	      constraint (inst.operands[1].shifted
			  && inst.operands[1].immisreg,
			  _("shift must be constant"));
	      if (inst.instruction < 0xffff)
		inst.instruction = THUMB_OP32 (inst.instruction);
	      inst.instruction |= inst.operands[0].reg << r0off;
	      encode_thumb32_shifted_operand (1);
	    }
	}
    }
  else
    {
      constraint (inst.instruction > 0xffff
		  || inst.instruction == T_MNEM_mvns, BAD_THUMB32);
      constraint (!inst.operands[1].isreg || inst.operands[1].shifted,
		  _("unshifted register required"));
      constraint (inst.operands[0].reg > 7 || inst.operands[1].reg > 7,
		  BAD_HIREG);

      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= inst.operands[0].reg;
      inst.instruction |= inst.operands[1].reg << 3;
    }
}

static void
do_t_mrs (void)
{
  /* mrs only accepts CPSR/SPSR/CPSR_all/SPSR_all.  */
  constraint ((inst.operands[1].imm & (PSR_c|PSR_x|PSR_s|PSR_f))
	      != (PSR_c|PSR_f),
	      _("'CPSR' or 'SPSR' expected"));
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= (inst.operands[1].imm & SPSR_BIT) >> 2;
}

static void
do_t_msr (void)
{
  constraint (!inst.operands[1].isreg,
	      _("Thumb encoding does not support an immediate here"));
  inst.instruction |= (inst.operands[0].imm & SPSR_BIT) >> 2;
  inst.instruction |= (inst.operands[0].imm & ~SPSR_BIT) >> 8;
  inst.instruction |= inst.operands[1].reg << 16;
}

static void
do_t_mul (void)
{
  if (!inst.operands[2].present)
    inst.operands[2].reg = inst.operands[0].reg;

  /* There is no 32-bit MULS and no 16-bit MUL. */
  if (unified_syntax && inst.instruction == T_MNEM_mul)
    {
      inst.instruction = THUMB_OP32 (inst.instruction);
      inst.instruction |= inst.operands[0].reg << 8;
      inst.instruction |= inst.operands[1].reg << 16;
      inst.instruction |= inst.operands[2].reg << 0;
    }
  else
    {
      constraint (!unified_syntax
		  && inst.instruction == T_MNEM_muls, BAD_THUMB32);
      constraint (inst.operands[0].reg > 7 || inst.operands[1].reg > 7,
		  BAD_HIREG);

      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= inst.operands[0].reg;

      if (inst.operands[0].reg == inst.operands[1].reg)
	inst.instruction |= inst.operands[2].reg << 3;
      else if (inst.operands[0].reg == inst.operands[2].reg)
	inst.instruction |= inst.operands[1].reg << 3;
      else
	constraint (1, _("dest must overlap one source register"));
    }
}

static void
do_t_mull (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 8;
  inst.instruction |= inst.operands[2].reg << 16;
  inst.instruction |= inst.operands[3].reg;

  if (inst.operands[0].reg == inst.operands[1].reg)
    as_tsktsk (_("rdhi and rdlo must be different"));
}

static void
do_t_nop (void)
{
  if (unified_syntax)
    {
      if (inst.size_req == 4 || inst.operands[0].imm > 15)
	{
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction |= inst.operands[0].imm;
	}
      else
	{
	  inst.instruction = THUMB_OP16 (inst.instruction);
	  inst.instruction |= inst.operands[0].imm << 4;
	}
    }
  else
    {
      constraint (inst.operands[0].present,
		  _("Thumb does not support NOP with hints"));
      inst.instruction = 0x46c0;
    }
}

static void
do_t_neg (void)
{
  if (unified_syntax)
    {
      if (inst.operands[0].reg > 7 || inst.operands[1].reg > 7
	  || !THUMB_SETS_FLAGS (inst.instruction)
	  || inst.size_req == 4)
	{
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction |= inst.operands[0].reg << 8;
	  inst.instruction |= inst.operands[1].reg << 16;
	}
      else
	{
	  inst.instruction = THUMB_OP16 (inst.instruction);
	  inst.instruction |= inst.operands[0].reg;
	  inst.instruction |= inst.operands[1].reg << 3;
	}
    }
  else
    {
      constraint (inst.operands[0].reg > 7 || inst.operands[1].reg > 7,
		  BAD_HIREG);
      constraint (THUMB_SETS_FLAGS (inst.instruction), BAD_THUMB32);

      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= inst.operands[0].reg;
      inst.instruction |= inst.operands[1].reg << 3;
    }
}

static void
do_t_pkhbt (void)
{
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
  if (inst.operands[3].present)
    {
      unsigned int val = inst.reloc.exp.X_add_number;
      constraint (inst.reloc.exp.X_op != O_constant,
		  _("expression too complex"));
      inst.instruction |= (val & 0x1c) << 10;
      inst.instruction |= (val & 0x03) << 6;
    }
}

static void
do_t_pkhtb (void)
{
  if (!inst.operands[3].present)
    inst.instruction &= ~0x00000020;
  do_t_pkhbt ();
}

static void
do_t_pld (void)
{
  encode_thumb32_addr_mode (0, /*is_t=*/FALSE, /*is_d=*/FALSE);
}

static void
do_t_push_pop (void)
{
  constraint (inst.operands[0].writeback,
	      _("push/pop do not support {reglist}^"));
  constraint (inst.reloc.type != BFD_RELOC_UNUSED,
	      _("expression too complex"));

  if ((inst.operands[0].imm & ~0xff) == 0)
    inst.instruction = THUMB_OP16 (inst.instruction);
  else if ((inst.instruction == T_MNEM_push
	    && (inst.operands[0].imm & ~0xff) == 1 << REG_LR)
	   || (inst.instruction == T_MNEM_pop
	       && (inst.operands[0].imm & ~0xff) == 1 << REG_PC))
    {
      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= THUMB_PP_PC_LR;
      inst.operands[0].imm &= 0xff;
    }
  else if (unified_syntax)
    {
      if (inst.operands[1].imm & (1 << 13))
	as_warn (_("SP should not be in register list"));
      if (inst.instruction == T_MNEM_push)
	{
	  if (inst.operands[1].imm & (1 << 15))
	    as_warn (_("PC should not be in register list"));
	}
      else
	{
	  if (inst.operands[1].imm & (1 << 14)
	      && inst.operands[1].imm & (1 << 15))
	    as_warn (_("LR and PC should not both be in register list"));
	}

      inst.instruction = THUMB_OP32 (inst.instruction);
    }
  else
    {
      inst.error = _("invalid register list to push/pop instruction");
      return;
    }

  inst.instruction |= inst.operands[0].imm;
}

static void
do_t_rbit (void)
{
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 16;
}

static void
do_t_rev (void)
{
  if (inst.operands[0].reg <= 7 && inst.operands[1].reg <= 7
      && inst.size_req != 4)
    {
      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= inst.operands[0].reg;
      inst.instruction |= inst.operands[1].reg << 3;
    }
  else if (unified_syntax)
    {
      inst.instruction = THUMB_OP32 (inst.instruction);
      inst.instruction |= inst.operands[0].reg << 8;
      inst.instruction |= inst.operands[1].reg << 16;
      inst.instruction |= inst.operands[1].reg;
    }
  else
    inst.error = BAD_HIREG;
}

static void
do_t_rsb (void)
{
  int Rd, Rs;

  Rd = inst.operands[0].reg;
  Rs = (inst.operands[1].present
	? inst.operands[1].reg    /* Rd, Rs, foo */
	: inst.operands[0].reg);  /* Rd, foo -> Rd, Rd, foo */

  inst.instruction |= Rd << 8;
  inst.instruction |= Rs << 16;
  if (!inst.operands[2].isreg)
    {
      inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
      inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
    }
  else
    encode_thumb32_shifted_operand (2);
}

static void
do_t_setend (void)
{
  if (inst.operands[0].imm)
    inst.instruction |= 0x8;
}

static void
do_t_shift (void)
{
  if (!inst.operands[1].present)
    inst.operands[1].reg = inst.operands[0].reg;

  if (unified_syntax)
    {
      if (inst.operands[0].reg > 7
	  || inst.operands[1].reg > 7
	  || !THUMB_SETS_FLAGS (inst.instruction)
	  || (!inst.operands[2].isreg && inst.instruction == T_MNEM_rors)
	  || (inst.operands[2].isreg && inst.operands[1].reg != inst.operands[0].reg)
	  || inst.size_req == 4)
	{
	  if (inst.operands[2].isreg)
	    {
	      inst.instruction = THUMB_OP32 (inst.instruction);
	      inst.instruction |= inst.operands[0].reg << 8;
	      inst.instruction |= inst.operands[1].reg << 16;
	      inst.instruction |= inst.operands[2].reg;
	    }
	  else
	    {
	      inst.operands[1].shifted = 1;
	      switch (inst.instruction)
		{
		case T_MNEM_asr:
		case T_MNEM_asrs: inst.operands[1].shift_kind = SHIFT_ASR; break;
		case T_MNEM_lsl:
		case T_MNEM_lsls: inst.operands[1].shift_kind = SHIFT_LSL; break;
		case T_MNEM_lsr:
		case T_MNEM_lsrs: inst.operands[1].shift_kind = SHIFT_LSR; break;
		case T_MNEM_ror:
		case T_MNEM_rors: inst.operands[1].shift_kind = SHIFT_ROR; break;
		default: abort ();
		}
	      
	      inst.instruction = THUMB_OP32 (THUMB_SETS_FLAGS (inst.instruction)
					     ? T_MNEM_movs : T_MNEM_mov);
	      inst.instruction |= inst.operands[0].reg << 8;
	      encode_thumb32_shifted_operand (1);
	      /* Prevent the incorrect generation of an ARM_IMMEDIATE fixup.  */
	      inst.reloc.type = BFD_RELOC_UNUSED;
	    }
	}
      else
	{
	  if (inst.operands[2].isreg)
	    {
	      switch (inst.instruction)
		{
		case T_MNEM_asrs: inst.instruction = T_OPCODE_ASR_R; break;
		case T_MNEM_lsls: inst.instruction = T_OPCODE_LSL_R; break;
		case T_MNEM_lsrs: inst.instruction = T_OPCODE_LSR_R; break;
		case T_MNEM_rors: inst.instruction = T_OPCODE_ROR_R; break;
		default: abort ();
		}
	  
	      inst.instruction |= inst.operands[0].reg;
	      inst.instruction |= inst.operands[2].reg << 3;
	    }
	  else
	    {
	      switch (inst.instruction)
		{
		case T_MNEM_asrs: inst.instruction = T_OPCODE_ASR_I; break;
		case T_MNEM_lsls: inst.instruction = T_OPCODE_LSL_I; break;
		case T_MNEM_lsrs: inst.instruction = T_OPCODE_LSR_I; break;
		default: abort ();
		}
	      inst.reloc.type = BFD_RELOC_ARM_THUMB_SHIFT;
	      inst.instruction |= inst.operands[0].reg;
	      inst.instruction |= inst.operands[1].reg << 3;
	    }
	}
    }
  else
    {
      constraint (inst.operands[0].reg > 7
		  || inst.operands[1].reg > 7, BAD_HIREG);
      constraint (THUMB_SETS_FLAGS (inst.instruction), BAD_THUMB32);

      if (inst.operands[2].isreg)  /* Rd, {Rs,} Rn */
	{
	  constraint (inst.operands[2].reg > 7, BAD_HIREG);
	  constraint (inst.operands[0].reg != inst.operands[1].reg,
		      _("source1 and dest must be same register"));

	  switch (inst.instruction)
	    {
	    case T_MNEM_asr: inst.instruction = T_OPCODE_ASR_R; break;
	    case T_MNEM_lsl: inst.instruction = T_OPCODE_LSL_R; break;
	    case T_MNEM_lsr: inst.instruction = T_OPCODE_LSR_R; break;
	    case T_MNEM_ror: inst.instruction = T_OPCODE_ROR_R; break;
	    default: abort ();
	    }
	  
	  inst.instruction |= inst.operands[0].reg;
	  inst.instruction |= inst.operands[2].reg << 3;
	}
      else
	{
	  switch (inst.instruction)
	    {
	    case T_MNEM_asr: inst.instruction = T_OPCODE_ASR_I; break;
	    case T_MNEM_lsl: inst.instruction = T_OPCODE_LSL_I; break;
	    case T_MNEM_lsr: inst.instruction = T_OPCODE_LSR_I; break;
	    case T_MNEM_ror: inst.error = _("ror #imm not supported"); return;
	    default: abort ();
	    }
	  inst.reloc.type = BFD_RELOC_ARM_THUMB_SHIFT;
	  inst.instruction |= inst.operands[0].reg;
	  inst.instruction |= inst.operands[1].reg << 3;
	}
    }
}

static void
do_t_simd (void)
{
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
}

static void
do_t_smi (void)
{
  unsigned int value = inst.reloc.exp.X_add_number;
  constraint (inst.reloc.exp.X_op != O_constant,
	      _("expression too complex"));
  inst.reloc.type = BFD_RELOC_UNUSED;
  inst.instruction |= (value & 0xf000) >> 12;
  inst.instruction |= (value & 0x0ff0);
  inst.instruction |= (value & 0x000f) << 16;
}

static void
do_t_ssat (void)
{
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].imm - 1;
  inst.instruction |= inst.operands[2].reg << 16;

  if (inst.operands[3].present)
    {
      constraint (inst.reloc.exp.X_op != O_constant,
		  _("expression too complex"));

      if (inst.reloc.exp.X_add_number != 0)
	{
	  if (inst.operands[3].shift_kind == SHIFT_ASR)
	    inst.instruction |= 0x00200000;  /* sh bit */
	  inst.instruction |= (inst.reloc.exp.X_add_number & 0x1c) << 10;
	  inst.instruction |= (inst.reloc.exp.X_add_number & 0x03) << 6;
	}
      inst.reloc.type = BFD_RELOC_UNUSED;
    }
}

static void
do_t_ssat16 (void)
{
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].imm - 1;
  inst.instruction |= inst.operands[2].reg << 16;
}

static void
do_t_strex (void)
{
  constraint (!inst.operands[2].isreg || !inst.operands[2].preind
	      || inst.operands[2].postind || inst.operands[2].writeback
	      || inst.operands[2].immisreg || inst.operands[2].shifted
	      || inst.operands[2].negative,
	      _("instruction does not accept this addressing mode"));

  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 12;
  inst.instruction |= inst.operands[2].reg << 16;
  inst.reloc.type = BFD_RELOC_ARM_T32_OFFSET_U8;
}

static void
do_t_strexd (void)
{
  if (!inst.operands[2].present)
    inst.operands[2].reg = inst.operands[1].reg + 1;

  constraint (inst.operands[0].reg == inst.operands[1].reg
	      || inst.operands[0].reg == inst.operands[2].reg
	      || inst.operands[0].reg == inst.operands[3].reg
	      || inst.operands[1].reg == inst.operands[2].reg,
	      BAD_OVERLAP);

  inst.instruction |= inst.operands[0].reg;
  inst.instruction |= inst.operands[1].reg << 12;
  inst.instruction |= inst.operands[2].reg << 8;
  inst.instruction |= inst.operands[3].reg << 16;
}

static void
do_t_sxtah (void)
{
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
  inst.instruction |= inst.operands[3].imm << 4;
}

static void
do_t_sxth (void)
{
  if (inst.instruction <= 0xffff && inst.size_req != 4
      && inst.operands[0].reg <= 7 && inst.operands[1].reg <= 7
      && (!inst.operands[2].present || inst.operands[2].imm == 0))
    {
      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= inst.operands[0].reg;
      inst.instruction |= inst.operands[1].reg << 3;
    }
  else if (unified_syntax)
    {
      if (inst.instruction <= 0xffff)
	inst.instruction = THUMB_OP32 (inst.instruction);
      inst.instruction |= inst.operands[0].reg << 8;
      inst.instruction |= inst.operands[1].reg;
      inst.instruction |= inst.operands[2].imm << 4;
    }
  else
    {
      constraint (inst.operands[2].present && inst.operands[2].imm != 0,
		  _("Thumb encoding does not support rotation"));
      constraint (1, BAD_HIREG);
    }
}

static void
do_t_swi (void)
{
  inst.reloc.type = BFD_RELOC_ARM_SWI;
}

static void
do_t_usat (void)
{
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].imm;
  inst.instruction |= inst.operands[2].reg << 16;

  if (inst.operands[3].present)
    {
      constraint (inst.reloc.exp.X_op != O_constant,
		  _("expression too complex"));
      if (inst.reloc.exp.X_add_number != 0)
	{
	  if (inst.operands[3].shift_kind == SHIFT_ASR)
	    inst.instruction |= 0x00200000;  /* sh bit */

	  inst.instruction |= (inst.reloc.exp.X_add_number & 0x1c) << 10;
	  inst.instruction |= (inst.reloc.exp.X_add_number & 0x03) << 6;
	}
      inst.reloc.type = BFD_RELOC_UNUSED;
    }
}

static void
do_t_usat16 (void)
{
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].imm;
  inst.instruction |= inst.operands[2].reg << 16;
}

/* Overall per-instruction processing.	*/

/* We need to be able to fix up arbitrary expressions in some statements.
   This is so that we can handle symbols that are an arbitrary distance from
   the pc.  The most common cases are of the form ((+/-sym -/+ . - 8) & mask),
   which returns part of an address in a form which will be valid for
   a data instruction.	We do this by pushing the expression into a symbol
   in the expr_section, and creating a fix for that.  */

static void
fix_new_arm (fragS *	   frag,
	     int	   where,
	     short int	   size,
	     expressionS * exp,
	     int	   pc_rel,
	     int	   reloc)
{
  fixS *	   new_fix;

  switch (exp->X_op)
    {
    case O_constant:
    case O_symbol:
    case O_add:
    case O_subtract:
      new_fix = fix_new_exp (frag, where, size, exp, pc_rel, reloc);
      break;

    default:
      new_fix = fix_new (frag, where, size, make_expr_symbol (exp), 0,
			 pc_rel, reloc);
      break;
    }

  /* Mark whether the fix is to a THUMB instruction, or an ARM
     instruction.  */
  new_fix->tc_fix_data = thumb_mode;
}

static void
output_inst (const char * str)
{
  char * to = NULL;

  if (inst.error)
    {
      as_bad ("%s -- `%s'", inst.error, str);
      return;
    }
  if (inst.size == 0)
    return;

  to = frag_more (inst.size);

  if (thumb_mode && (inst.size > THUMB_SIZE))
    {
      assert (inst.size == (2 * THUMB_SIZE));
      md_number_to_chars (to, inst.instruction >> 16, THUMB_SIZE);
      md_number_to_chars (to + THUMB_SIZE, inst.instruction, THUMB_SIZE);
    }
  else if (inst.size > INSN_SIZE)
    {
      assert (inst.size == (2 * INSN_SIZE));
      md_number_to_chars (to, inst.instruction, INSN_SIZE);
      md_number_to_chars (to + INSN_SIZE, inst.instruction, INSN_SIZE);
    }
  else
    md_number_to_chars (to, inst.instruction, inst.size);

  if (inst.reloc.type != BFD_RELOC_UNUSED)
    fix_new_arm (frag_now, to - frag_now->fr_literal,
		 inst.size, & inst.reloc.exp, inst.reloc.pc_rel,
		 inst.reloc.type);

#ifdef OBJ_ELF
  dwarf2_emit_insn (inst.size);
#endif
}

/* Tag values used in struct asm_opcode's tag field.  */
enum opcode_tag
{
  OT_unconditional,	/* Instruction cannot be conditionalized.
			   The ARM condition field is still 0xE.  */
  OT_unconditionalF,	/* Instruction cannot be conditionalized
			   and carries 0xF in its ARM condition field.  */
  OT_csuffix,		/* Instruction takes a conditional suffix.  */
  OT_cinfix3,		/* Instruction takes a conditional infix,
			   beginning at character index 3.  (In
			   unified mode, it becomes a suffix.)  */
  OT_csuf_or_in3,	/* Instruction takes either a conditional
			   suffix or an infix at character index 3.
			   (In unified mode, a suffix only.  */
  OT_odd_infix_unc,	/* This is the unconditional variant of an
			   instruction that takes a conditional infix
			   at an unusual position.  In unified mode,
			   this variant will accept a suffix.  */
  OT_odd_infix_0	/* Values greater than or equal to OT_odd_infix_0
			   are the conditional variants of instructions that
			   take conditional infixes in unusual positions.
			   The infix appears at character index
			   (tag - OT_odd_infix_0).  These are not accepted
			   in unified mode.  */
};

/* Subroutine of md_assemble, responsible for looking up the primary
   opcode from the mnemonic the user wrote.  STR points to the
   beginning of the mnemonic.

   This is not simply a hash table lookup, because of conditional
   variants.  Most instructions have conditional variants, which are
   expressed with a _conditional affix_ to the mnemonic.  If we were
   to encode each conditional variant as a literal string in the opcode
   table, it would have approximately 20,000 entries.

   Most mnemonics take this affix as a suffix, and in unified syntax,
   'most' is upgraded to 'all'.  However, in the divided syntax, some
   instructions take the affix as an infix, notably the s-variants of
   the arithmetic instructions.  Of those instructions, all but six
   have the infix appear after the third character of the mnemonic.

   Accordingly, the algorithm for looking up primary opcodes given
   an identifier is:

   1. Look up the identifier in the opcode table.
      If we find a match, go to step U.

   2. Look up the last two characters of the identifier in the
      conditions table.  If we find a match, look up the first N-2
      characters of the identifier in the opcode table.  If we
      find a match, go to step CE.

   3. Look up the fourth and fifth characters of the identifier in
      the conditions table.  If we find a match, extract those
      characters from the identifier, and look up the remaining
      characters in the opcode table.  If we find a match, go
      to step CM.

   4. Fail.

   U. Examine the tag field of the opcode structure, in case this is
      one of the six instructions with its conditional infix in an
      unusual place.  If it is, the tag tells us where to find the
      infix; look it up in the conditions table and set inst.cond
      accordingly.  Otherwise, this is an unconditional instruction.
      Again set inst.cond accordingly.  Return the opcode structure.

  CE. Examine the tag field to make sure this is an instruction that
      should receive a conditional suffix.  If it is not, fail.
      Otherwise, set inst.cond from the suffix we already looked up,
      and return the opcode structure.

  CM. Examine the tag field to make sure this is an instruction that
      should receive a conditional infix after the third character.
      If it is not, fail.  Otherwise, undo the edits to the current
      line of input and proceed as for case CE.  */

static const struct asm_opcode *
opcode_lookup (char **str)
{
  char *end, *base;
  char *affix;
  const struct asm_opcode *opcode;
  const struct asm_cond *cond;

  /* Scan up to the end of the mnemonic, which must end in white space,
     '.' (in unified mode only), or end of string.  */
  for (base = end = *str; *end != '\0'; end++)
    if (*end == ' ' || (unified_syntax && *end == '.'))
      break;

  if (end == base)
    return 0;

  /* Handle a possible width suffix.  */
  if (end[0] == '.')
    {
      if (end[1] == 'w' && (end[2] == ' ' || end[2] == '\0'))
	inst.size_req = 4;
      else if (end[1] == 'n' && (end[2] == ' ' || end[2] == '\0'))
	inst.size_req = 2;
      else
	return 0;

      *str = end + 2;
    }
  else
    *str = end;

  /* Look for unaffixed or special-case affixed mnemonic.  */
  opcode = hash_find_n (arm_ops_hsh, base, end - base);
  if (opcode)
    {
      /* step U */
      if (opcode->tag < OT_odd_infix_0)
	{
	  inst.cond = COND_ALWAYS;
	  return opcode;
	}

      if (unified_syntax)
	as_warn (_("conditional infixes are deprecated in unified syntax"));
      affix = base + (opcode->tag - OT_odd_infix_0);
      cond = hash_find_n (arm_cond_hsh, affix, 2);
      assert (cond);

      inst.cond = cond->value;
      return opcode;
    }

  /* Cannot have a conditional suffix on a mnemonic of less than two
     characters.  */
  if (end - base < 3)
    return 0;

  /* Look for suffixed mnemonic.  */
  affix = end - 2;
  cond = hash_find_n (arm_cond_hsh, affix, 2);
  opcode = hash_find_n (arm_ops_hsh, base, affix - base);
  if (opcode && cond)
    {
      /* step CE */
      switch (opcode->tag)
	{
	case OT_cinfix3:
	case OT_odd_infix_unc:
	  if (!unified_syntax)
	    return 0;
	  /* else fall through */

	case OT_csuffix:
	case OT_csuf_or_in3:
	  inst.cond = cond->value;
	  return opcode;

	case OT_unconditional:
	case OT_unconditionalF:
	  /* delayed diagnostic */
	  inst.error = BAD_COND;
	  inst.cond = COND_ALWAYS;
	  return opcode;

	default:
	  return 0;
	}
    }

  /* Cannot have a usual-position infix on a mnemonic of less than
     six characters (five would be a suffix).  */
  if (end - base < 6)
    return 0;

  /* Look for infixed mnemonic in the usual position.  */
  affix = base + 3;
  cond = hash_find_n (arm_cond_hsh, affix, 2);
  if (cond)
    {
      char save[2];
      memcpy (save, affix, 2);
      memmove (affix, affix + 2, (end - affix) - 2);
      opcode = hash_find_n (arm_ops_hsh, base, (end - base) - 2);
      memmove (affix + 2, affix, (end - affix) - 2);
      memcpy (affix, save, 2);
    }
  if (opcode && (opcode->tag == OT_cinfix3 || opcode->tag == OT_csuf_or_in3))
    {
      /* step CM */
      if (unified_syntax)
	as_warn (_("conditional infixes are deprecated in unified syntax"));

      inst.cond = cond->value;
      return opcode;
    }

  return 0;
}

void
md_assemble (char *str)
{
  char *p = str;
  const struct asm_opcode * opcode;

  /* Align the previous label if needed.  */
  if (last_label_seen != NULL)
    {
      symbol_set_frag (last_label_seen, frag_now);
      S_SET_VALUE (last_label_seen, (valueT) frag_now_fix ());
      S_SET_SEGMENT (last_label_seen, now_seg);
    }

  memset (&inst, '\0', sizeof (inst));
  inst.reloc.type = BFD_RELOC_UNUSED;

  opcode = opcode_lookup (&p);
  if (!opcode)
    {
      /* It wasn't an instruction, but it might be a register alias of
	 the form alias .req reg.  */
      if (!create_register_alias (str, p))
	as_bad (_("bad instruction `%s'"), str);

      return;
    }

  if (thumb_mode)
    {
      /* Check that this instruction is supported for this CPU.  */
      if (thumb_mode == 1 && (opcode->tvariant & cpu_variant) == 0)
	{
	  as_bad (_("selected processor does not support `%s'"), str);
	  return;
	}
      if (inst.cond != COND_ALWAYS && !unified_syntax
	  && opcode->tencode != do_t_branch)
	{
	  as_bad (_("Thumb does not support conditional execution"));
	  return;
	}

      mapping_state (MAP_THUMB);
      inst.instruction = opcode->tvalue;

      if (!parse_operands (p, opcode->operands))
	opcode->tencode ();

      if (!inst.error)
	{
	  assert (inst.instruction < 0xe800 || inst.instruction > 0xffff);
	  inst.size = (inst.instruction > 0xffff ? 4 : 2);
	  if (inst.size_req && inst.size_req != inst.size)
	    {
	      as_bad (_("cannot honor width suffix -- `%s'"), str);
	      return;
	    }
	}
    }
  else
    {
      /* Check that this instruction is supported for this CPU.  */
      if ((opcode->avariant & cpu_variant) == 0)
	{
	  as_bad (_("selected processor does not support `%s'"), str);
	  return;
	}
      if (inst.size_req)
	{
	  as_bad (_("width suffixes are invalid in ARM mode -- `%s'"), str);
	  return;
	}

      mapping_state (MAP_ARM);
      inst.instruction = opcode->avalue;
      if (opcode->tag == OT_unconditionalF)
	inst.instruction |= 0xF << 28;
      else
	inst.instruction |= inst.cond << 28;
      inst.size = INSN_SIZE;
      if (!parse_operands (p, opcode->operands))
	opcode->aencode ();
    }
  output_inst (str);
}

/* Various frobbings of labels and their addresses.  */

void
arm_start_line_hook (void)
{
  last_label_seen = NULL;
}

void
arm_frob_label (symbolS * sym)
{
  last_label_seen = sym;

  ARM_SET_THUMB (sym, thumb_mode);

#if defined OBJ_COFF || defined OBJ_ELF
  ARM_SET_INTERWORK (sym, support_interwork);
#endif

  /* Note - do not allow local symbols (.Lxxx) to be labeled
     as Thumb functions.  This is because these labels, whilst
     they exist inside Thumb code, are not the entry points for
     possible ARM->Thumb calls.	 Also, these labels can be used
     as part of a computed goto or switch statement.  eg gcc
     can generate code that looks like this:

		ldr  r2, [pc, .Laaa]
		lsl  r3, r3, #2
		ldr  r2, [r3, r2]
		mov  pc, r2

       .Lbbb:  .word .Lxxx
       .Lccc:  .word .Lyyy
       ..etc...
       .Laaa:	.word Lbbb

     The first instruction loads the address of the jump table.
     The second instruction converts a table index into a byte offset.
     The third instruction gets the jump address out of the table.
     The fourth instruction performs the jump.

     If the address stored at .Laaa is that of a symbol which has the
     Thumb_Func bit set, then the linker will arrange for this address
     to have the bottom bit set, which in turn would mean that the
     address computation performed by the third instruction would end
     up with the bottom bit set.  Since the ARM is capable of unaligned
     word loads, the instruction would then load the incorrect address
     out of the jump table, and chaos would ensue.  */
  if (label_is_thumb_function_name
      && (S_GET_NAME (sym)[0] != '.' || S_GET_NAME (sym)[1] != 'L')
      && (bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)
    {
      /* When the address of a Thumb function is taken the bottom
	 bit of that address should be set.  This will allow
	 interworking between Arm and Thumb functions to work
	 correctly.  */

      THUMB_SET_FUNC (sym, 1);

      label_is_thumb_function_name = FALSE;
    }
}

int
arm_data_in_code (void)
{
  if (thumb_mode && ! strncmp (input_line_pointer + 1, "data:", 5))
    {
      *input_line_pointer = '/';
      input_line_pointer += 5;
      *input_line_pointer = 0;
      return 1;
    }

  return 0;
}

char *
arm_canonicalize_symbol_name (char * name)
{
  int len;

  if (thumb_mode && (len = strlen (name)) > 5
      && streq (name + len - 5, "/data"))
    *(name + len - 5) = 0;

  return name;
}

/* Table of all register names defined by default.  The user can
   define additional names with .req.  Note that all register names
   should appear in both upper and lowercase variants.	Some registers
   also have mixed-case names.	*/

#define REGDEF(s,n,t) { #s, n, REG_TYPE_##t, TRUE }
#define REGNUM(p,n,t) REGDEF(p##n, n, t)
#define REGSET(p,t) \
  REGNUM(p, 0,t), REGNUM(p, 1,t), REGNUM(p, 2,t), REGNUM(p, 3,t), \
  REGNUM(p, 4,t), REGNUM(p, 5,t), REGNUM(p, 6,t), REGNUM(p, 7,t), \
  REGNUM(p, 8,t), REGNUM(p, 9,t), REGNUM(p,10,t), REGNUM(p,11,t), \
  REGNUM(p,12,t), REGNUM(p,13,t), REGNUM(p,14,t), REGNUM(p,15,t)

static const struct reg_entry reg_names[] =
{
  /* ARM integer registers.  */
  REGSET(r, RN), REGSET(R, RN),

  /* ATPCS synonyms.  */
  REGDEF(a1,0,RN), REGDEF(a2,1,RN), REGDEF(a3, 2,RN), REGDEF(a4, 3,RN),
  REGDEF(v1,4,RN), REGDEF(v2,5,RN), REGDEF(v3, 6,RN), REGDEF(v4, 7,RN),
  REGDEF(v5,8,RN), REGDEF(v6,9,RN), REGDEF(v7,10,RN), REGDEF(v8,11,RN),

  REGDEF(A1,0,RN), REGDEF(A2,1,RN), REGDEF(A3, 2,RN), REGDEF(A4, 3,RN),
  REGDEF(V1,4,RN), REGDEF(V2,5,RN), REGDEF(V3, 6,RN), REGDEF(V4, 7,RN),
  REGDEF(V5,8,RN), REGDEF(V6,9,RN), REGDEF(V7,10,RN), REGDEF(V8,11,RN),

  /* Well-known aliases.  */
  REGDEF(wr, 7,RN), REGDEF(sb, 9,RN), REGDEF(sl,10,RN), REGDEF(fp,11,RN),
  REGDEF(ip,12,RN), REGDEF(sp,13,RN), REGDEF(lr,14,RN), REGDEF(pc,15,RN),

  REGDEF(WR, 7,RN), REGDEF(SB, 9,RN), REGDEF(SL,10,RN), REGDEF(FP,11,RN),
  REGDEF(IP,12,RN), REGDEF(SP,13,RN), REGDEF(LR,14,RN), REGDEF(PC,15,RN),

  /* Coprocessor numbers.  */
  REGSET(p, CP), REGSET(P, CP),

  /* Coprocessor register numbers.  The "cr" variants are for backward
     compatibility.  */
  REGSET(c,  CN), REGSET(C, CN),
  REGSET(cr, CN), REGSET(CR, CN),

  /* FPA registers.  */
  REGNUM(f,0,FN), REGNUM(f,1,FN), REGNUM(f,2,FN), REGNUM(f,3,FN),
  REGNUM(f,4,FN), REGNUM(f,5,FN), REGNUM(f,6,FN), REGNUM(f,7, FN),

  REGNUM(F,0,FN), REGNUM(F,1,FN), REGNUM(F,2,FN), REGNUM(F,3,FN),
  REGNUM(F,4,FN), REGNUM(F,5,FN), REGNUM(F,6,FN), REGNUM(F,7, FN),

  /* VFP SP registers.	*/
  REGSET(s,VFS),
  REGNUM(s,16,VFS), REGNUM(s,17,VFS), REGNUM(s,18,VFS), REGNUM(s,19,VFS),
  REGNUM(s,20,VFS), REGNUM(s,21,VFS), REGNUM(s,22,VFS), REGNUM(s,23,VFS),
  REGNUM(s,24,VFS), REGNUM(s,25,VFS), REGNUM(s,26,VFS), REGNUM(s,27,VFS),
  REGNUM(s,28,VFS), REGNUM(s,29,VFS), REGNUM(s,30,VFS), REGNUM(s,31,VFS),

  REGSET(S,VFS),
  REGNUM(S,16,VFS), REGNUM(S,17,VFS), REGNUM(S,18,VFS), REGNUM(S,19,VFS),
  REGNUM(S,20,VFS), REGNUM(S,21,VFS), REGNUM(S,22,VFS), REGNUM(S,23,VFS),
  REGNUM(S,24,VFS), REGNUM(S,25,VFS), REGNUM(S,26,VFS), REGNUM(S,27,VFS),
  REGNUM(S,28,VFS), REGNUM(S,29,VFS), REGNUM(S,30,VFS), REGNUM(S,31,VFS),

  /* VFP DP Registers.	*/
  REGSET(d,VFD), REGSET(D,VFS),

  /* VFP control registers.  */
  REGDEF(fpsid,0,VFC), REGDEF(fpscr,1,VFC), REGDEF(fpexc,8,VFC),
  REGDEF(FPSID,0,VFC), REGDEF(FPSCR,1,VFC), REGDEF(FPEXC,8,VFC),

  /* Maverick DSP coprocessor registers.  */
  REGSET(mvf,MVF),  REGSET(mvd,MVD),  REGSET(mvfx,MVFX),  REGSET(mvdx,MVDX),
  REGSET(MVF,MVF),  REGSET(MVD,MVD),  REGSET(MVFX,MVFX),  REGSET(MVDX,MVDX),

  REGNUM(mvax,0,MVAX), REGNUM(mvax,1,MVAX),
  REGNUM(mvax,2,MVAX), REGNUM(mvax,3,MVAX),
  REGDEF(dspsc,0,DSPSC),

  REGNUM(MVAX,0,MVAX), REGNUM(MVAX,1,MVAX),
  REGNUM(MVAX,2,MVAX), REGNUM(MVAX,3,MVAX),
  REGDEF(DSPSC,0,DSPSC),

  /* iWMMXt data registers - p0, c0-15.	 */
  REGSET(wr,MMXWR), REGSET(wR,MMXWR), REGSET(WR, MMXWR),

  /* iWMMXt control registers - p1, c0-3.  */
  REGDEF(wcid,	0,MMXWC),  REGDEF(wCID,	 0,MMXWC),  REGDEF(WCID,  0,MMXWC),
  REGDEF(wcon,	1,MMXWC),  REGDEF(wCon,	 1,MMXWC),  REGDEF(WCON,  1,MMXWC),
  REGDEF(wcssf, 2,MMXWC),  REGDEF(wCSSF, 2,MMXWC),  REGDEF(WCSSF, 2,MMXWC),
  REGDEF(wcasf, 3,MMXWC),  REGDEF(wCASF, 3,MMXWC),  REGDEF(WCASF, 3,MMXWC),

  /* iWMMXt scalar (constant/offset) registers - p1, c8-11.  */
  REGDEF(wcgr0, 8,MMXWCG),  REGDEF(wCGR0, 8,MMXWCG),  REGDEF(WCGR0, 8,MMXWCG),
  REGDEF(wcgr1, 9,MMXWCG),  REGDEF(wCGR1, 9,MMXWCG),  REGDEF(WCGR1, 9,MMXWCG),
  REGDEF(wcgr2,10,MMXWCG),  REGDEF(wCGR2,10,MMXWCG),  REGDEF(WCGR2,10,MMXWCG),
  REGDEF(wcgr3,11,MMXWCG),  REGDEF(wCGR3,11,MMXWCG),  REGDEF(WCGR3,11,MMXWCG),

  /* XScale accumulator registers.  */
  REGNUM(acc,0,XSCALE), REGNUM(ACC,0,XSCALE),
};
#undef REGDEF
#undef REGNUM
#undef REGSET

/* Table of all PSR suffixes.  Bare "CPSR" and "SPSR" are handled
   within psr_required_here.  */
static const struct asm_psr psrs[] =
{
  /* Backward compatibility notation.  Note that "all" is no longer
     truly all possible PSR bits.  */
  {"all",  PSR_c | PSR_f},
  {"flg",  PSR_f},
  {"ctl",  PSR_c},

  /* Individual flags.	*/
  {"f",	   PSR_f},
  {"c",	   PSR_c},
  {"x",	   PSR_x},
  {"s",	   PSR_s},
  /* Combinations of flags.  */
  {"fs",   PSR_f | PSR_s},
  {"fx",   PSR_f | PSR_x},
  {"fc",   PSR_f | PSR_c},
  {"sf",   PSR_s | PSR_f},
  {"sx",   PSR_s | PSR_x},
  {"sc",   PSR_s | PSR_c},
  {"xf",   PSR_x | PSR_f},
  {"xs",   PSR_x | PSR_s},
  {"xc",   PSR_x | PSR_c},
  {"cf",   PSR_c | PSR_f},
  {"cs",   PSR_c | PSR_s},
  {"cx",   PSR_c | PSR_x},
  {"fsx",  PSR_f | PSR_s | PSR_x},
  {"fsc",  PSR_f | PSR_s | PSR_c},
  {"fxs",  PSR_f | PSR_x | PSR_s},
  {"fxc",  PSR_f | PSR_x | PSR_c},
  {"fcs",  PSR_f | PSR_c | PSR_s},
  {"fcx",  PSR_f | PSR_c | PSR_x},
  {"sfx",  PSR_s | PSR_f | PSR_x},
  {"sfc",  PSR_s | PSR_f | PSR_c},
  {"sxf",  PSR_s | PSR_x | PSR_f},
  {"sxc",  PSR_s | PSR_x | PSR_c},
  {"scf",  PSR_s | PSR_c | PSR_f},
  {"scx",  PSR_s | PSR_c | PSR_x},
  {"xfs",  PSR_x | PSR_f | PSR_s},
  {"xfc",  PSR_x | PSR_f | PSR_c},
  {"xsf",  PSR_x | PSR_s | PSR_f},
  {"xsc",  PSR_x | PSR_s | PSR_c},
  {"xcf",  PSR_x | PSR_c | PSR_f},
  {"xcs",  PSR_x | PSR_c | PSR_s},
  {"cfs",  PSR_c | PSR_f | PSR_s},
  {"cfx",  PSR_c | PSR_f | PSR_x},
  {"csf",  PSR_c | PSR_s | PSR_f},
  {"csx",  PSR_c | PSR_s | PSR_x},
  {"cxf",  PSR_c | PSR_x | PSR_f},
  {"cxs",  PSR_c | PSR_x | PSR_s},
  {"fsxc", PSR_f | PSR_s | PSR_x | PSR_c},
  {"fscx", PSR_f | PSR_s | PSR_c | PSR_x},
  {"fxsc", PSR_f | PSR_x | PSR_s | PSR_c},
  {"fxcs", PSR_f | PSR_x | PSR_c | PSR_s},
  {"fcsx", PSR_f | PSR_c | PSR_s | PSR_x},
  {"fcxs", PSR_f | PSR_c | PSR_x | PSR_s},
  {"sfxc", PSR_s | PSR_f | PSR_x | PSR_c},
  {"sfcx", PSR_s | PSR_f | PSR_c | PSR_x},
  {"sxfc", PSR_s | PSR_x | PSR_f | PSR_c},
  {"sxcf", PSR_s | PSR_x | PSR_c | PSR_f},
  {"scfx", PSR_s | PSR_c | PSR_f | PSR_x},
  {"scxf", PSR_s | PSR_c | PSR_x | PSR_f},
  {"xfsc", PSR_x | PSR_f | PSR_s | PSR_c},
  {"xfcs", PSR_x | PSR_f | PSR_c | PSR_s},
  {"xsfc", PSR_x | PSR_s | PSR_f | PSR_c},
  {"xscf", PSR_x | PSR_s | PSR_c | PSR_f},
  {"xcfs", PSR_x | PSR_c | PSR_f | PSR_s},
  {"xcsf", PSR_x | PSR_c | PSR_s | PSR_f},
  {"cfsx", PSR_c | PSR_f | PSR_s | PSR_x},
  {"cfxs", PSR_c | PSR_f | PSR_x | PSR_s},
  {"csfx", PSR_c | PSR_s | PSR_f | PSR_x},
  {"csxf", PSR_c | PSR_s | PSR_x | PSR_f},
  {"cxfs", PSR_c | PSR_x | PSR_f | PSR_s},
  {"cxsf", PSR_c | PSR_x | PSR_s | PSR_f},
};

/* Table of all shift-in-operand names.	 */
static const struct asm_shift_name shift_names [] =
{
  { "asl", SHIFT_LSL },	 { "ASL", SHIFT_LSL },
  { "lsl", SHIFT_LSL },	 { "LSL", SHIFT_LSL },
  { "lsr", SHIFT_LSR },	 { "LSR", SHIFT_LSR },
  { "asr", SHIFT_ASR },	 { "ASR", SHIFT_ASR },
  { "ror", SHIFT_ROR },	 { "ROR", SHIFT_ROR },
  { "rrx", SHIFT_RRX },	 { "RRX", SHIFT_RRX }
};

/* Table of all explicit relocation names.  */
#ifdef OBJ_ELF
static struct reloc_entry reloc_names[] =
{
  { "got",     BFD_RELOC_ARM_GOT32   },	 { "GOT",     BFD_RELOC_ARM_GOT32   },
  { "gotoff",  BFD_RELOC_ARM_GOTOFF  },	 { "GOTOFF",  BFD_RELOC_ARM_GOTOFF  },
  { "plt",     BFD_RELOC_ARM_PLT32   },	 { "PLT",     BFD_RELOC_ARM_PLT32   },
  { "target1", BFD_RELOC_ARM_TARGET1 },	 { "TARGET1", BFD_RELOC_ARM_TARGET1 },
  { "target2", BFD_RELOC_ARM_TARGET2 },	 { "TARGET2", BFD_RELOC_ARM_TARGET2 },
  { "sbrel",   BFD_RELOC_ARM_SBREL32 },	 { "SBREL",   BFD_RELOC_ARM_SBREL32 },
  { "tlsgd",   BFD_RELOC_ARM_TLS_GD32},  { "TLSGD",   BFD_RELOC_ARM_TLS_GD32},
  { "tlsldm",  BFD_RELOC_ARM_TLS_LDM32}, { "TLSLDM",  BFD_RELOC_ARM_TLS_LDM32},
  { "tlsldo",  BFD_RELOC_ARM_TLS_LDO32}, { "TLSLDO",  BFD_RELOC_ARM_TLS_LDO32},
  { "gottpoff",BFD_RELOC_ARM_TLS_IE32},  { "GOTTPOFF",BFD_RELOC_ARM_TLS_IE32},
  { "tpoff",   BFD_RELOC_ARM_TLS_LE32},  { "TPOFF",   BFD_RELOC_ARM_TLS_LE32}
};
#endif

/* Table of all conditional affixes.  0xF is not defined as a condition code.  */
static const struct asm_cond conds[] =
{
  {"eq", 0x0},
  {"ne", 0x1},
  {"cs", 0x2}, {"hs", 0x2},
  {"cc", 0x3}, {"ul", 0x3}, {"lo", 0x3},
  {"mi", 0x4},
  {"pl", 0x5},
  {"vs", 0x6},
  {"vc", 0x7},
  {"hi", 0x8},
  {"ls", 0x9},
  {"ge", 0xa},
  {"lt", 0xb},
  {"gt", 0xc},
  {"le", 0xd},
  {"al", 0xe}
};

/* Table of ARM-format instructions.	*/

/* Macros for gluing together operand strings.  N.B. In all cases
   other than OPS0, the trailing OP_stop comes from default
   zero-initialization of the unspecified elements of the array.  */
#define OPS0()		  { OP_stop, }
#define OPS1(a)		  { OP_##a, }
#define OPS2(a,b)	  { OP_##a,OP_##b, }
#define OPS3(a,b,c)	  { OP_##a,OP_##b,OP_##c, }
#define OPS4(a,b,c,d)	  { OP_##a,OP_##b,OP_##c,OP_##d, }
#define OPS5(a,b,c,d,e)	  { OP_##a,OP_##b,OP_##c,OP_##d,OP_##e, }
#define OPS6(a,b,c,d,e,f) { OP_##a,OP_##b,OP_##c,OP_##d,OP_##e,OP_##f, }

/* These macros abstract out the exact format of the mnemonic table and
   save some repeated characters.  */

/* The normal sort of mnemonic; has a Thumb variant; takes a conditional suffix.  */
#define TxCE(mnem, op, top, nops, ops, ae, te) \
  { #mnem, OPS##nops ops, OT_csuffix, 0x##op, top, ARM_VARIANT, \
    THUMB_VARIANT, do_##ae, do_##te }

/* Two variants of the above - TCE for a numeric Thumb opcode, tCE for
   a T_MNEM_xyz enumerator.  */
#define TCE(mnem, aop, top, nops, ops, ae, te) \
       TxCE(mnem, aop, 0x##top, nops, ops, ae, te)
#define tCE(mnem, aop, top, nops, ops, ae, te) \
       TxCE(mnem, aop, T_MNEM_##top, nops, ops, ae, te)

/* Second most common sort of mnemonic: has a Thumb variant, takes a conditional
   infix after the third character.  */
#define TxC3(mnem, op, top, nops, ops, ae, te) \
  { #mnem, OPS##nops ops, OT_cinfix3, 0x##op, top, ARM_VARIANT, \
    THUMB_VARIANT, do_##ae, do_##te }
#define TC3(mnem, aop, top, nops, ops, ae, te) \
       TxC3(mnem, aop, 0x##top, nops, ops, ae, te)
#define tC3(mnem, aop, top, nops, ops, ae, te) \
       TxC3(mnem, aop, T_MNEM_##top, nops, ops, ae, te)

/* Mnemonic with a conditional infix in an unusual place.  Each and every variant has to
   appear in the condition table.  */
#define TxCM_(m1, m2, m3, op, top, nops, ops, ae, te)	\
  { #m1 #m2 #m3, OPS##nops ops, sizeof(#m2) == 1 ? OT_odd_infix_unc : OT_odd_infix_0 + sizeof(#m1) - 1, \
    0x##op, top, ARM_VARIANT, THUMB_VARIANT, do_##ae, do_##te }

#define TxCM(m1, m2, op, top, nops, ops, ae, te)	\
  TxCM_(m1,   , m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, eq, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, ne, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, cs, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, hs, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, cc, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, ul, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, lo, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, mi, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, pl, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, vs, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, vc, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, hi, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, ls, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, ge, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, lt, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, gt, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, le, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, al, m2, op, top, nops, ops, ae, te)

#define TCM(m1,m2, aop, top, nops, ops, ae, te)		\
       TxCM(m1,m2, aop, 0x##top, nops, ops, ae, te)
#define tCM(m1,m2, aop, top, nops, ops, ae, te)			\
       TxCM(m1,m2, aop, T_MNEM_##top, nops, ops, ae, te)

/* Mnemonic that cannot be conditionalized.  The ARM condition-code
   field is still 0xE.  */
#define TUE(mnem, op, top, nops, ops, ae, te)				\
  { #mnem, OPS##nops ops, OT_unconditional, 0x##op, 0x##top, ARM_VARIANT, \
    THUMB_VARIANT, do_##ae, do_##te }

/* Mnemonic that cannot be conditionalized, and bears 0xF in its ARM
   condition code field.  */
#define TUF(mnem, op, top, nops, ops, ae, te)				\
  { #mnem, OPS##nops ops, OT_unconditionalF, 0x##op, 0x##top, ARM_VARIANT, \
    THUMB_VARIANT, do_##ae, do_##te }

/* ARM-only variants of all the above.  */
#define CE(mnem,  op, nops, ops, ae)	\
  { #mnem, OPS##nops ops, OT_csuffix, 0x##op, 0x0, ARM_VARIANT, 0, do_##ae, NULL }

#define C3(mnem, op, nops, ops, ae)	\
  { #mnem, OPS##nops ops, OT_cinfix3, 0x##op, 0x0, ARM_VARIANT, 0, do_##ae, NULL }

#define xCM_(m1, m2, m3, op, nops, ops, ae)	\
  { #m1 #m2 #m3, OPS##nops ops, \
    sizeof(#m2) == 1 ? OT_odd_infix_unc : OT_odd_infix_0 + sizeof(#m1) - 1, \
    0x##op, 0x0, ARM_VARIANT, 0, do_##ae, NULL }

#define CM(m1, m2, op, nops, ops, ae)	\
  xCM_(m1,   , m2, op, nops, ops, ae),	\
  xCM_(m1, eq, m2, op, nops, ops, ae),	\
  xCM_(m1, ne, m2, op, nops, ops, ae),	\
  xCM_(m1, cs, m2, op, nops, ops, ae),	\
  xCM_(m1, hs, m2, op, nops, ops, ae),	\
  xCM_(m1, cc, m2, op, nops, ops, ae),	\
  xCM_(m1, ul, m2, op, nops, ops, ae),	\
  xCM_(m1, lo, m2, op, nops, ops, ae),	\
  xCM_(m1, mi, m2, op, nops, ops, ae),	\
  xCM_(m1, pl, m2, op, nops, ops, ae),	\
  xCM_(m1, vs, m2, op, nops, ops, ae),	\
  xCM_(m1, vc, m2, op, nops, ops, ae),	\
  xCM_(m1, hi, m2, op, nops, ops, ae),	\
  xCM_(m1, ls, m2, op, nops, ops, ae),	\
  xCM_(m1, ge, m2, op, nops, ops, ae),	\
  xCM_(m1, lt, m2, op, nops, ops, ae),	\
  xCM_(m1, gt, m2, op, nops, ops, ae),	\
  xCM_(m1, le, m2, op, nops, ops, ae),	\
  xCM_(m1, al, m2, op, nops, ops, ae)

#define UE(mnem, op, nops, ops, ae)	\
  { #mnem, OPS##nops ops, OT_unconditional, 0x##op, 0, ARM_VARIANT, 0, do_##ae, NULL }

#define UF(mnem, op, nops, ops, ae)	\
  { #mnem, OPS##nops ops, OT_unconditionalF, 0x##op, 0, ARM_VARIANT, 0, do_##ae, NULL }

#define do_0 0

/* Thumb-only, unconditional.  */
#define UT(mnem,  op, nops, ops, te) TUE(mnem,  0, op, nops, ops, 0, te)

/* ARM-only, takes either a suffix or a position-3 infix
   (for an FPA corner case). */
#define C3E(mnem, op, nops, ops, ae) \
  { #mnem, OPS##nops ops, OT_csuf_or_in3, 0x##op, 0, ARM_VARIANT, 0, do_##ae, 0 }

static const struct asm_opcode insns[] =
{
#define ARM_VARIANT ARM_EXT_V1 /* Core ARM Instructions.  */
#define THUMB_VARIANT ARM_EXT_V4T
 tCE(and,	0000000, and,      3, (RR, oRR, SH), arit, t_arit3c),
 tC3(ands,	0100000, ands,	   3, (RR, oRR, SH), arit, t_arit3c),
 tCE(eor,	0200000, eor,	   3, (RR, oRR, SH), arit, t_arit3c),
 tC3(eors,	0300000, eors,	   3, (RR, oRR, SH), arit, t_arit3c),
 tCE(sub,	0400000, sub,	   3, (RR, oRR, SH), arit, t_add_sub),
 tC3(subs,	0500000, subs,	   3, (RR, oRR, SH), arit, t_add_sub),
 tCE(add,	0800000, add,	   3, (RR, oRR, SH), arit, t_add_sub),
 tC3(adds,	0900000, adds,	   3, (RR, oRR, SH), arit, t_add_sub),
 tCE(adc,	0a00000, adc,	   3, (RR, oRR, SH), arit, t_arit3c),
 tC3(adcs,	0b00000, adcs,	   3, (RR, oRR, SH), arit, t_arit3c),
 tCE(sbc,	0c00000, sbc,	   3, (RR, oRR, SH), arit, t_arit3),
 tC3(sbcs,	0d00000, sbcs,	   3, (RR, oRR, SH), arit, t_arit3),
 tCE(orr,	1800000, orr,	   3, (RR, oRR, SH), arit, t_arit3c),
 tC3(orrs,	1900000, orrs,	   3, (RR, oRR, SH), arit, t_arit3c),
 tCE(bic,	1c00000, bic,	   3, (RR, oRR, SH), arit, t_arit3),
 tC3(bics,	1d00000, bics,	   3, (RR, oRR, SH), arit, t_arit3),

 /* The p-variants of tst/cmp/cmn/teq (below) are the pre-V6 mechanism
    for setting PSR flag bits.  They are obsolete in V6 and do not
    have Thumb equivalents. */
 tCE(tst,	1100000, tst,	   2, (RR, SH),      cmp,  t_mvn_tst),
 tC3(tsts,	1100000, tst,	   2, (RR, SH),      cmp,  t_mvn_tst),
  C3(tstp,	110f000,     	   2, (RR, SH),      cmp),
 tCE(cmp,	1500000, cmp,	   2, (RR, SH),      cmp,  t_mov_cmp),
 tC3(cmps,	1500000, cmp,	   2, (RR, SH),      cmp,  t_mov_cmp),
  C3(cmpp,	150f000,     	   2, (RR, SH),      cmp),
 tCE(cmn,	1700000, cmn,	   2, (RR, SH),      cmp,  t_mvn_tst),
 tC3(cmns,	1700000, cmn,	   2, (RR, SH),      cmp,  t_mvn_tst),
  C3(cmnp,	170f000,     	   2, (RR, SH),      cmp),

 tCE(mov,	1a00000, mov,	   2, (RR, SH),      mov,  t_mov_cmp),
 tC3(movs,	1b00000, movs,	   2, (RR, SH),      mov,  t_mov_cmp),
 tCE(mvn,	1e00000, mvn,	   2, (RR, SH),      mov,  t_mvn_tst),
 tC3(mvns,	1f00000, mvns,	   2, (RR, SH),      mov,  t_mvn_tst),

 tCE(ldr,	4100000, ldr,	   2, (RR, ADDR),    ldst, t_ldst),
 tC3(ldrb,	4500000, ldrb,	   2, (RR, ADDR),    ldst, t_ldst),
 tCE(str,	4000000, str,	   2, (RR, ADDR),    ldst, t_ldst),
 tC3(strb,	4400000, strb,	   2, (RR, ADDR),    ldst, t_ldst),

 tC3(stmia,	8800000, stmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),
 tC3(stmea,	8800000, stmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),
 tC3(ldmia,	8900000, ldmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),
 tC3(ldmfd,	8900000, ldmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),

 TCE(swi,	f000000, df00,     1, (EXPi),        swi, t_swi),
 TCE(b,		a000000, e000,	   1, (EXPr),	     branch, t_branch),
 TCE(bl,	b000000, f000f800, 1, (EXPr),	     branch, t_branch23),

  /* Pseudo ops.  */
 TCE(adr,	28f0000, 000f,	   2, (RR, EXP),     adr,  t_adr),
  C3(adrl,	28f0000,           2, (RR, EXP),     adrl),
 tCE(nop,	1a00000, nop,	   1, (oI255c),	     nop,  t_nop),

  /* Thumb-compatibility pseudo ops.  */
 tCE(lsl,	1a00000, lsl,	   3, (RR, oRR, SH), shift, t_shift),
 tC3(lsls,	1b00000, lsls,	   3, (RR, oRR, SH), shift, t_shift),
 tCE(lsr,	1a00020, lsr,	   3, (RR, oRR, SH), shift, t_shift),
 tC3(lsrs,	1b00020, lsrs,	   3, (RR, oRR, SH), shift, t_shift),
 tCE(asr,	1a00040, asr,	   3, (RR, oRR, SH), shift, t_shift),
 tC3(asrs,      1b00040, asrs,     3, (RR, oRR, SH), shift, t_shift),
 tCE(ror,	1a00060, ror,	   3, (RR, oRR, SH), shift, t_shift),
 tC3(rors,	1b00060, rors,	   3, (RR, oRR, SH), shift, t_shift),
 tCE(neg,	2600000, neg,	   2, (RR, RR),      rd_rn, t_neg),
 tC3(negs,	2700000, negs,	   2, (RR, RR),      rd_rn, t_neg),
 tCE(push,	92d0000, push,     1, (REGLST),	     push_pop, t_push_pop),
 tCE(pop,	8bd0000, pop,	   1, (REGLST),	     push_pop, t_push_pop),

#undef THUMB_VARIANT
#define THUMB_VARIANT ARM_EXT_V6
 TCE(cpy,       1a00000, 4600,     2, (RR, RR),      rd_rm, t_cpy),

 /* V1 instructions with no Thumb analogue prior to V6T2.  */
#undef THUMB_VARIANT
#define THUMB_VARIANT ARM_EXT_V6T2
 TCE(rsb,	0600000, ebc00000, 3, (RR, oRR, SH), arit, t_rsb),
 TC3(rsbs,	0700000, ebd00000, 3, (RR, oRR, SH), arit, t_rsb),
 TCE(teq,	1300000, ea900f00, 2, (RR, SH),      cmp,  t_mvn_tst),
 TC3(teqs,	1300000, ea900f00, 2, (RR, SH),      cmp,  t_mvn_tst),
  C3(teqp,	130f000,           2, (RR, SH),      cmp),

 TC3(ldrt,	4300000, f8500e00, 2, (RR, ADDR),    ldstt, t_ldstt),
 TC3(ldrbt,	4700000, f8300e00, 2, (RR, ADDR),    ldstt, t_ldstt),
 TC3(strt,	4200000, f8400e00, 2, (RR, ADDR),    ldstt, t_ldstt),
 TC3(strbt,	4600000, f8200e00, 2, (RR, ADDR),    ldstt, t_ldstt),

 TC3(stmdb,	9000000, e9100000, 2, (RRw, REGLST), ldmstm, t_ldmstm),
 TC3(stmfd,     9000000, e9100000, 2, (RRw, REGLST), ldmstm, t_ldmstm),

 TC3(ldmdb,	9100000, e9000000, 2, (RRw, REGLST), ldmstm, t_ldmstm),
 TC3(ldmea,	9100000, e9000000, 2, (RRw, REGLST), ldmstm, t_ldmstm),

 /* V1 instructions with no Thumb analogue at all.  */
  CE(rsc,	0e00000,	   3, (RR, oRR, SH), arit),
  C3(rscs,	0f00000,	   3, (RR, oRR, SH), arit),

  C3(stmib,	9800000,	   2, (RRw, REGLST), ldmstm),
  C3(stmfa,	9800000,	   2, (RRw, REGLST), ldmstm),
  C3(stmda,	8000000,	   2, (RRw, REGLST), ldmstm),
  C3(stmed,	8000000,	   2, (RRw, REGLST), ldmstm),
  C3(ldmib,	9900000,	   2, (RRw, REGLST), ldmstm),
  C3(ldmed,	9900000,	   2, (RRw, REGLST), ldmstm),
  C3(ldmda,	8100000,	   2, (RRw, REGLST), ldmstm),
  C3(ldmfa,	8100000,	   2, (RRw, REGLST), ldmstm),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V2	/* ARM 2 - multiplies.	*/
#undef THUMB_VARIANT
#define THUMB_VARIANT ARM_EXT_V4T
 tCE(mul,	0000090, mul,	   3, (RRnpc, RRnpc, oRR), mul, t_mul),
 tC3(muls,	0100090, muls,	   3, (RRnpc, RRnpc, oRR), mul, t_mul),

#undef THUMB_VARIANT
#define THUMB_VARIANT ARM_EXT_V6T2
 TCE(mla,	0200090, fb000000, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mlas, t_mla),
  C3(mlas,	0300090,           4, (RRnpc, RRnpc, RRnpc, RRnpc), mlas),

  /* Generic coprocessor instructions.	*/
 TCE(cdp,	e000000, ee000000, 6, (RCP, I15b, RCN, RCN, RCN, oI7b), cdp,    cdp),
 TCE(ldc,	c100000, ec100000, 3, (RCP, RCN, ADDR),		        lstc,   lstc),
 TC3(ldcl,	c500000, ec500000, 3, (RCP, RCN, ADDR),		        lstc,   lstc),
 TCE(stc,	c000000, ec000000, 3, (RCP, RCN, ADDR),		        lstc,   lstc),
 TC3(stcl,	c400000, ec400000, 3, (RCP, RCN, ADDR),		        lstc,   lstc),
 TCE(mcr,	e000010, ee000010, 6, (RCP, I7b, RR, RCN, RCN, oI7b),   co_reg, co_reg),
 TCE(mrc,	e100010, ee100010, 6, (RCP, I7b, RR, RCN, RCN, oI7b),   co_reg, co_reg),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V2S /* ARM 3 - swp instructions.  */
  CE(swp,	1000090,           3, (RRnpc, RRnpc, RRnpcb), rd_rm_rn),
  C3(swpb,	1400090,           3, (RRnpc, RRnpc, RRnpcb), rd_rm_rn),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V3	/* ARM 6 Status register instructions.	*/
 TCE(mrs,	10f0000, f3ef8000, 2, (RR, PSR),     mrs, t_mrs),
 TCE(msr,	120f000, f3808000, 2, (PSR, RR_EXi), msr, t_msr),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V3M	 /* ARM 7M long multiplies.  */
 TCE(smull,	0c00090, fb800000, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mull, t_mull),
  CM(smull,s,	0d00090,           4, (RRnpc, RRnpc, RRnpc, RRnpc), mull),
 TCE(umull,	0800090, fba00000, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mull, t_mull),
  CM(umull,s,	0900090,           4, (RRnpc, RRnpc, RRnpc, RRnpc), mull),
 TCE(smlal,	0e00090, fbc00000, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mull, t_mull),
  CM(smlal,s,	0f00090,           4, (RRnpc, RRnpc, RRnpc, RRnpc), mull),
 TCE(umlal,	0a00090, fbe00000, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mull, t_mull),
  CM(umlal,s,	0b00090,           4, (RRnpc, RRnpc, RRnpc, RRnpc), mull),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V4	/* ARM Architecture 4.	*/
#undef THUMB_VARIANT
#define THUMB_VARIANT ARM_EXT_V4T
 tC3(ldrh,	01000b0, ldrh,     2, (RR, ADDR), ldstv4, t_ldst),
 tC3(strh,	00000b0, strh,     2, (RR, ADDR), ldstv4, t_ldst),
 tC3(ldrsh,	01000f0, ldrsh,    2, (RR, ADDR), ldstv4, t_ldst),
 tC3(ldrsb,	01000d0, ldrsb,    2, (RR, ADDR), ldstv4, t_ldst),
 tCM(ld,sh,	01000f0, ldrsh,    2, (RR, ADDR), ldstv4, t_ldst),
 tCM(ld,sb,	01000d0, ldrsb,    2, (RR, ADDR), ldstv4, t_ldst),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V4T|ARM_EXT_V5
  /* ARM Architecture 4T.  */
  /* Note: bx (and blx) are required on V5, even if the processor does
     not support Thumb.	 */
 TCE(bx,	12fff10, 4700, 1, (RR),	bx, t_bx),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V5 /*  ARM Architecture 5T.	 */
#undef THUMB_VARIANT
#define THUMB_VARIANT ARM_EXT_V5T
  /* Note: blx has 2 variants; the .value coded here is for
     BLX(2).  Only this variant has conditional execution.  */
 TCE(blx,	12fff30, 4780, 1, (RR_EXr),			    blx,  t_blx),
 TUE(bkpt,	1200070, be00, 1, (oIffffb),			    bkpt, t_bkpt),

#undef THUMB_VARIANT
#define THUMB_VARIANT ARM_EXT_V6T2
 TCE(clz,	16f0f10, fab0f080, 2, (RRnpc, RRnpc),		        rd_rm,  t_clz),
 TUF(ldc2,	c100000, fc100000, 3, (RCP, RCN, ADDR),		        lstc,	lstc),
 TUF(ldc2l,	c500000, fc500000, 3, (RCP, RCN, ADDR),		        lstc,	lstc),
 TUF(stc2,	c000000, fc000000, 3, (RCP, RCN, ADDR),		        lstc,	lstc),
 TUF(stc2l,	c400000, fc400000, 3, (RCP, RCN, ADDR),		        lstc,	lstc),
 TUF(cdp2,	e000000, fe000000, 6, (RCP, I15b, RCN, RCN, RCN, oI7b), cdp,    cdp),
 TUF(mcr2,	e000010, fe000010, 6, (RCP, I7b, RR, RCN, RCN, oI7b),   co_reg, co_reg),
 TUF(mrc2,	e100010, fe100010, 6, (RCP, I7b, RR, RCN, RCN, oI7b),   co_reg, co_reg),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V5ExP /*  ARM Architecture 5TExP.  */
 TCE(smlabb,	1000080, fb100000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),
 TCE(smlatb,	10000a0, fb100020, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),
 TCE(smlabt,	10000c0, fb100010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),
 TCE(smlatt,	10000e0, fb100030, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),

 TCE(smlawb,	1200080, fb300000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),
 TCE(smlawt,	12000c0, fb300010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),

 TCE(smlalbb,	1400080, fbc00080, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smlal, t_mlal),
 TCE(smlaltb,	14000a0, fbc000a0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smlal, t_mlal),
 TCE(smlalbt,	14000c0, fbc00090, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smlal, t_mlal),
 TCE(smlaltt,	14000e0, fbc000b0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smlal, t_mlal),

 TCE(smulbb,	1600080, fb10f000, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),
 TCE(smultb,	16000a0, fb10f020, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),
 TCE(smulbt,	16000c0, fb10f010, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),
 TCE(smultt,	16000e0, fb10f030, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),

 TCE(smulwb,	12000a0, fb30f000, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),
 TCE(smulwt,	12000e0, fb30f010, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),

 TCE(qadd,	1000050, fa80f080, 3, (RRnpc, RRnpc, RRnpc),	    rd_rm_rn, rd_rm_rn),
 TCE(qdadd,	1400050, fa80f090, 3, (RRnpc, RRnpc, RRnpc),	    rd_rm_rn, rd_rm_rn),
 TCE(qsub,	1200050, fa80f0a0, 3, (RRnpc, RRnpc, RRnpc),	    rd_rm_rn, rd_rm_rn),
 TCE(qdsub,	1600050, fa80f0b0, 3, (RRnpc, RRnpc, RRnpc),	    rd_rm_rn, rd_rm_rn),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V5E /*  ARM Architecture 5TE.  */
 TUF(pld,	450f000, f810f000, 1, (ADDR),		     pld,  t_pld),
 TC3(ldrd,	00000d0, e9500000, 3, (RRnpc, oRRnpc, ADDR), ldrd, t_ldstd),
 TC3(strd,	00000f0, e9400000, 3, (RRnpc, oRRnpc, ADDR), ldrd, t_ldstd),

 TCE(mcrr,	c400000, ec400000, 5, (RCP, I15b, RRnpc, RRnpc, RCN), co_reg2c, co_reg2c),
 TCE(mrrc,	c500000, ec500000, 5, (RCP, I15b, RRnpc, RRnpc, RCN), co_reg2c, co_reg2c),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V5J /*  ARM Architecture 5TEJ.  */
 TCE(bxj,	12fff20, f3c08f00, 1, (RR),			  bxj, t_bxj),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V6 /*  ARM V6.  */
#undef THUMB_VARIANT
#define THUMB_VARIANT ARM_EXT_V6
 TUF(cpsie,     1080000, b660,     2, (CPSF, oI31b),              cpsi,   t_cpsi),
 TUF(cpsid,     10c0000, b670,     2, (CPSF, oI31b),              cpsi,   t_cpsi),
 tCE(rev,       6bf0f30, rev,      2, (RRnpc, RRnpc),             rd_rm,  t_rev),
 tCE(rev16,     6bf0fb0, rev16,    2, (RRnpc, RRnpc),             rd_rm,  t_rev),
 tCE(revsh,     6ff0fb0, revsh,    2, (RRnpc, RRnpc),             rd_rm,  t_rev),
 tCE(sxth,      6bf0070, sxth,     3, (RRnpc, RRnpc, oROR),       sxth,   t_sxth),
 tCE(uxth,      6ff0070, uxth,     3, (RRnpc, RRnpc, oROR),       sxth,   t_sxth),
 tCE(sxtb,      6af0070, sxtb,     3, (RRnpc, RRnpc, oROR),       sxth,   t_sxth),
 tCE(uxtb,      6ef0070, uxtb,     3, (RRnpc, RRnpc, oROR),       sxth,   t_sxth),
 TUF(setend,    1010000, b650,     1, (ENDI),                     setend, t_setend),

#undef THUMB_VARIANT
#define THUMB_VARIANT ARM_EXT_V6T2
 TUF(cps,	1020000, f3af8100, 1, (I31b),			  imm0, imm0),
 TCE(ldrex,	1900f9f, e8500f00, 2, (RRnpc, ADDR),		  ldrex, t_ldrex),
 TUF(mcrr2,	c400000, fc400000, 5, (RCP, I15b, RRnpc, RRnpc, RCN), co_reg2c, co_reg2c),
 TUF(mrrc2,	c500000, fc500000, 5, (RCP, I15b, RRnpc, RRnpc, RCN), co_reg2c, co_reg2c),
 TCE(pkhbt,	6800010, eac00000, 4, (RRnpc, RRnpc, RRnpc, oSHll),   pkhbt, t_pkhbt),
 TCE(pkhtb,	6800050, eac00020, 4, (RRnpc, RRnpc, RRnpc, oSHar),   pkhtb, t_pkhtb),
 TCE(qadd16,	6200f10, fa90f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(qadd8,	6200f90, fa80f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(qaddsubx,	6200f30, faa0f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(qsub16,	6200f70, fad0f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(qsub8,	6200ff0, fac0f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(qsubaddx,	6200f50, fae0f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(sadd16,	6100f10, fa90f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(sadd8,	6100f90, fa80f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(saddsubx,	6100f30, faa0f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(shadd16,	6300f10, fa90f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(shadd8,	6300f90, fa80f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(shaddsubx, 6300f30, faa0f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(shsub16,	6300f70, fad0f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(shsub8,	6300ff0, fac0f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(shsubaddx, 6300f50, fae0f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(ssub16,	6100f70, fad0f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(ssub8,	6100ff0, fac0f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(ssubaddx,	6100f50, fae0f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uadd16,	6500f10, fa90f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uadd8,	6500f90, fa80f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uaddsubx,	6500f30, faa0f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uhadd16,	6700f10, fa90f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uhadd8,	6700f90, fa80f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uhaddsubx, 6700f30, faa0f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uhsub16,	6700f70, fad0f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uhsub8,	6700ff0, fac0f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uhsubaddx, 6700f50, fae0f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uqadd16,	6600f10, fa90f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uqadd8,	6600f90, fa80f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uqaddsubx, 6600f30, faa0f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uqsub16,	6600f70, fad0f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uqsub8,	6600ff0, fac0f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uqsubaddx, 6600f50, fae0f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(usub16,	6500f70, fad0f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(usub8,	6500ff0, fac0f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(usubaddx,	6500f50, fae0f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TUF(rfeia,	8900a00, e990c000, 1, (RRw),			   rfe, rfe),
  UF(rfeib,	9900a00,           1, (RRw),			   rfe),
  UF(rfeda,	8100a00,           1, (RRw),			   rfe),
 TUF(rfedb,	9100a00, e810c000, 1, (RRw),			   rfe, rfe),
 TUF(rfefd,	8900a00, e990c000, 1, (RRw),			   rfe, rfe),
  UF(rfefa,	9900a00,           1, (RRw),			   rfe),
  UF(rfeea,	8100a00,           1, (RRw),			   rfe),
 TUF(rfeed,	9100a00, e810c000, 1, (RRw),			   rfe, rfe),
 TCE(sxtah,	6b00070, fa00f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
 TCE(sxtab16,	6800070, fa20f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
 TCE(sxtab,	6a00070, fa40f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
 TCE(sxtb16,	68f0070, fa2ff080, 3, (RRnpc, RRnpc, oROR),	   sxth,  t_sxth),
 TCE(uxtah,	6f00070, fa10f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
 TCE(uxtab16,	6c00070, fa30f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
 TCE(uxtab,	6e00070, fa50f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
 TCE(uxtb16,	6cf0070, fa3ff080, 3, (RRnpc, RRnpc, oROR),	   sxth,  t_sxth),
 TCE(sel,	68000b0, faa0f080, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(smlad,	7000010, fb200000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE(smladx,	7000030, fb200010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE(smlald,	7400010, fbc000c0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smlal,t_mlal),
 TCE(smlaldx,	7400030, fbc000d0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smlal,t_mlal),
 TCE(smlsd,	7000050, fb400000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE(smlsdx,	7000070, fb400010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE(smlsld,	7400050, fbd000c0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smlal,t_mlal),
 TCE(smlsldx,	7400070, fbd000d0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smlal,t_mlal),
 TCE(smmla,	7500010, fb500000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE(smmlar,	7500030, fb500010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE(smmls,	75000d0, fb600000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE(smmlsr,	75000f0, fb600010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE(smmul,	750f010, fb50f000, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
 TCE(smmulr,	750f030, fb50f010, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
 TCE(smuad,	700f010, fb20f000, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
 TCE(smuadx,	700f030, fb20f010, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
 TCE(smusd,	700f050, fb40f000, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
 TCE(smusdx,	700f070, fb40f010, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
 TUF(srsia,	8cd0500, e980c000, 1, (I31w),			   srs,  srs),
  UF(srsib,	9cd0500,           1, (I31w),			   srs),
  UF(srsda,	84d0500,	   1, (I31w),			   srs),
 TUF(srsdb,	94d0500, e800c000, 1, (I31w),			   srs,  srs),
 TCE(ssat,	6a00010, f3000000, 4, (RRnpc, I32, RRnpc, oSHllar),ssat,   t_ssat),
 TCE(ssat16,	6a00f30, f3200000, 3, (RRnpc, I16, RRnpc),	   ssat16, t_ssat16),
 TCE(strex,	1800f90, e8400000, 3, (RRnpc, RRnpc, ADDR),	   strex,  t_strex),
 TCE(umaal,	0400090, fbe00060, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smlal,  t_mlal),
 TCE(usad8,	780f010, fb70f000, 3, (RRnpc, RRnpc, RRnpc),	   smul,   t_simd),
 TCE(usada8,	7800010, fb700000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla,   t_mla),
 TCE(usat,	6e00010, f3800000, 4, (RRnpc, I31, RRnpc, oSHllar),usat,   t_usat),
 TCE(usat16,	6e00f30, f3a00000, 3, (RRnpc, I15, RRnpc),	   usat16, t_usat16),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V6K
#undef THUMB_VARIANT
#define THUMB_VARIANT ARM_EXT_V6K
 tCE(yield,	320f001, yield,    0, (), noargs, t_hint),
 tCE(wfe,	320f002, wfe,      0, (), noargs, t_hint),
 tCE(wfi,	320f003, wfi,      0, (), noargs, t_hint),
 tCE(sev,	320f004, sev,      0, (), noargs, t_hint),

#undef THUMB_VARIANT
#define THUMB_VARIANT ARM_EXT_V6T2
 TCE(ldrexb,	1d00f9f, e8d00f4f, 2, (RRnpc, RRnpcb),	              rd_rn,  rd_rn),
 TCE(ldrexh,	1f00f9f, e8d00f5f, 2, (RRnpc, RRnpcb),	              rd_rn,  rd_rn),
 TCE(ldrexd,	1b00f9f, e8d0007f, 3, (RRnpc, oRRnpc, RRnpcb),        ldrexd, t_ldrexd),
 TCE(strexb,	1c00f90, e8c00f40, 3, (RRnpc, RRnpc, ADDR),           strex,  rm_rd_rn),
 TCE(strexh,	1e00f90, e8c00f50, 3, (RRnpc, RRnpc, ADDR),           strex,  rm_rd_rn),
 TCE(strexd,	1a00f90, e8c00070, 4, (RRnpc, RRnpc, oRRnpc, RRnpcb), strexd, t_strexd),
 TUF(clrex,	57ff01f, f3bf8f2f, 0, (),			      noargs, noargs),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V6Z
 TCE(smi,	1600070, f7f08000, 1, (EXPi), smi, t_smi),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V6T2
 TCE(bfc,	7c0001f, f36f0000, 3, (RRnpc, I31, I32),	   bfc, t_bfc),
 TCE(bfi,	7c00010, f3600000, 4, (RRnpc, RRnpc_I0, I31, I32), bfi, t_bfi),
 TCE(sbfx,	7a00050, f3400000, 4, (RR, RR, I31, I32),	   bfx, t_bfx),
 TCE(ubfx,	7e00050, f3c00000, 4, (RR, RR, I31, I32),	   bfx, t_bfx),

 TCE(mls,	0600090, fb000010, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mlas, t_mla),
 TCE(movw,	3000000, f2400000, 2, (RRnpc, Iffff),		    mov16, t_mov16),
 TCE(movt,	3400000, f2c00000, 2, (RRnpc, Iffff),		    mov16, t_mov16),
 TCE(rbit,	3ff0f30, fa90f0a0, 2, (RR, RR),			    rd_rm, t_rbit),

 TC3(ldrht,	03000b0, f8300e00, 2, (RR, ADDR), ldsttv4, t_ldstt),
 TC3(ldrsht,	03000f0, f9300e00, 2, (RR, ADDR), ldsttv4, t_ldstt),
 TC3(ldrsbt,	03000d0, f9100e00, 2, (RR, ADDR), ldsttv4, t_ldstt),
 TC3(strht,	02000b0, f8200e00, 2, (RR, ADDR), ldsttv4, t_ldstt),

  UT(cbnz,      b900,    2, (RR, EXP), t_czb),
  UT(cbz,       b100,    2, (RR, EXP), t_czb),
 /* ARM does not really have an IT instruction.  */
 TUE(it,        0, bf08, 1, (COND),    it, t_it),
 TUE(itt,       0, bf0c, 1, (COND),    it, t_it),
 TUE(ite,       0, bf04, 1, (COND),    it, t_it),
 TUE(ittt,      0, bf0e, 1, (COND),    it, t_it),
 TUE(itet,      0, bf06, 1, (COND),    it, t_it),
 TUE(itte,      0, bf0a, 1, (COND),    it, t_it),
 TUE(itee,      0, bf02, 1, (COND),    it, t_it),
 TUE(itttt,     0, bf0f, 1, (COND),    it, t_it),
 TUE(itett,     0, bf07, 1, (COND),    it, t_it),
 TUE(ittet,     0, bf0b, 1, (COND),    it, t_it),
 TUE(iteet,     0, bf03, 1, (COND),    it, t_it),
 TUE(ittte,     0, bf0d, 1, (COND),    it, t_it),
 TUE(itete,     0, bf05, 1, (COND),    it, t_it),
 TUE(ittee,     0, bf09, 1, (COND),    it, t_it),
 TUE(iteee,     0, bf01, 1, (COND),    it, t_it),

#undef ARM_VARIANT
#define ARM_VARIANT FPU_FPA_EXT_V1  /* Core FPA instruction set (V1).  */
  CE(wfs,	e200110, 1, (RR),	     rd),
  CE(rfs,	e300110, 1, (RR),	     rd),
  CE(wfc,	e400110, 1, (RR),	     rd),
  CE(rfc,	e500110, 1, (RR),	     rd),

  C3(ldfs,	c100100, 2, (RF, ADDR),	     rd_cpaddr),
  C3(ldfd,	c108100, 2, (RF, ADDR),	     rd_cpaddr),
  C3(ldfe,	c500100, 2, (RF, ADDR),	     rd_cpaddr),
  C3(ldfp,	c508100, 2, (RF, ADDR),	     rd_cpaddr),

  C3(stfs,	c000100, 2, (RF, ADDR),	     rd_cpaddr),
  C3(stfd,	c008100, 2, (RF, ADDR),	     rd_cpaddr),
  C3(stfe,	c400100, 2, (RF, ADDR),	     rd_cpaddr),
  C3(stfp,	c408100, 2, (RF, ADDR),	     rd_cpaddr),

  C3(mvfs,	e008100, 2, (RF, RF_IF),     rd_rm),
  C3(mvfsp,	e008120, 2, (RF, RF_IF),     rd_rm),
  C3(mvfsm,	e008140, 2, (RF, RF_IF),     rd_rm),
  C3(mvfsz,	e008160, 2, (RF, RF_IF),     rd_rm),
  C3(mvfd,	e008180, 2, (RF, RF_IF),     rd_rm),
  C3(mvfdp,	e0081a0, 2, (RF, RF_IF),     rd_rm),
  C3(mvfdm,	e0081c0, 2, (RF, RF_IF),     rd_rm),
  C3(mvfdz,	e0081e0, 2, (RF, RF_IF),     rd_rm),
  C3(mvfe,	e088100, 2, (RF, RF_IF),     rd_rm),
  C3(mvfep,	e088120, 2, (RF, RF_IF),     rd_rm),
  C3(mvfem,	e088140, 2, (RF, RF_IF),     rd_rm),
  C3(mvfez,	e088160, 2, (RF, RF_IF),     rd_rm),

  C3(mnfs,	e108100, 2, (RF, RF_IF),     rd_rm),
  C3(mnfsp,	e108120, 2, (RF, RF_IF),     rd_rm),
  C3(mnfsm,	e108140, 2, (RF, RF_IF),     rd_rm),
  C3(mnfsz,	e108160, 2, (RF, RF_IF),     rd_rm),
  C3(mnfd,	e108180, 2, (RF, RF_IF),     rd_rm),
  C3(mnfdp,	e1081a0, 2, (RF, RF_IF),     rd_rm),
  C3(mnfdm,	e1081c0, 2, (RF, RF_IF),     rd_rm),
  C3(mnfdz,	e1081e0, 2, (RF, RF_IF),     rd_rm),
  C3(mnfe,	e188100, 2, (RF, RF_IF),     rd_rm),
  C3(mnfep,	e188120, 2, (RF, RF_IF),     rd_rm),
  C3(mnfem,	e188140, 2, (RF, RF_IF),     rd_rm),
  C3(mnfez,	e188160, 2, (RF, RF_IF),     rd_rm),

  C3(abss,	e208100, 2, (RF, RF_IF),     rd_rm),
  C3(abssp,	e208120, 2, (RF, RF_IF),     rd_rm),
  C3(abssm,	e208140, 2, (RF, RF_IF),     rd_rm),
  C3(abssz,	e208160, 2, (RF, RF_IF),     rd_rm),
  C3(absd,	e208180, 2, (RF, RF_IF),     rd_rm),
  C3(absdp,	e2081a0, 2, (RF, RF_IF),     rd_rm),
  C3(absdm,	e2081c0, 2, (RF, RF_IF),     rd_rm),
  C3(absdz,	e2081e0, 2, (RF, RF_IF),     rd_rm),
  C3(abse,	e288100, 2, (RF, RF_IF),     rd_rm),
  C3(absep,	e288120, 2, (RF, RF_IF),     rd_rm),
  C3(absem,	e288140, 2, (RF, RF_IF),     rd_rm),
  C3(absez,	e288160, 2, (RF, RF_IF),     rd_rm),

  C3(rnds,	e308100, 2, (RF, RF_IF),     rd_rm),
  C3(rndsp,	e308120, 2, (RF, RF_IF),     rd_rm),
  C3(rndsm,	e308140, 2, (RF, RF_IF),     rd_rm),
  C3(rndsz,	e308160, 2, (RF, RF_IF),     rd_rm),
  C3(rndd,	e308180, 2, (RF, RF_IF),     rd_rm),
  C3(rnddp,	e3081a0, 2, (RF, RF_IF),     rd_rm),
  C3(rnddm,	e3081c0, 2, (RF, RF_IF),     rd_rm),
  C3(rnddz,	e3081e0, 2, (RF, RF_IF),     rd_rm),
  C3(rnde,	e388100, 2, (RF, RF_IF),     rd_rm),
  C3(rndep,	e388120, 2, (RF, RF_IF),     rd_rm),
  C3(rndem,	e388140, 2, (RF, RF_IF),     rd_rm),
  C3(rndez,	e388160, 2, (RF, RF_IF),     rd_rm),

  C3(sqts,	e408100, 2, (RF, RF_IF),     rd_rm),
  C3(sqtsp,	e408120, 2, (RF, RF_IF),     rd_rm),
  C3(sqtsm,	e408140, 2, (RF, RF_IF),     rd_rm),
  C3(sqtsz,	e408160, 2, (RF, RF_IF),     rd_rm),
  C3(sqtd,	e408180, 2, (RF, RF_IF),     rd_rm),
  C3(sqtdp,	e4081a0, 2, (RF, RF_IF),     rd_rm),
  C3(sqtdm,	e4081c0, 2, (RF, RF_IF),     rd_rm),
  C3(sqtdz,	e4081e0, 2, (RF, RF_IF),     rd_rm),
  C3(sqte,	e488100, 2, (RF, RF_IF),     rd_rm),
  C3(sqtep,	e488120, 2, (RF, RF_IF),     rd_rm),
  C3(sqtem,	e488140, 2, (RF, RF_IF),     rd_rm),
  C3(sqtez,	e488160, 2, (RF, RF_IF),     rd_rm),

  C3(logs,	e508100, 2, (RF, RF_IF),     rd_rm),
  C3(logsp,	e508120, 2, (RF, RF_IF),     rd_rm),
  C3(logsm,	e508140, 2, (RF, RF_IF),     rd_rm),
  C3(logsz,	e508160, 2, (RF, RF_IF),     rd_rm),
  C3(logd,	e508180, 2, (RF, RF_IF),     rd_rm),
  C3(logdp,	e5081a0, 2, (RF, RF_IF),     rd_rm),
  C3(logdm,	e5081c0, 2, (RF, RF_IF),     rd_rm),
  C3(logdz,	e5081e0, 2, (RF, RF_IF),     rd_rm),
  C3(loge,	e588100, 2, (RF, RF_IF),     rd_rm),
  C3(logep,	e588120, 2, (RF, RF_IF),     rd_rm),
  C3(logem,	e588140, 2, (RF, RF_IF),     rd_rm),
  C3(logez,	e588160, 2, (RF, RF_IF),     rd_rm),

  C3(lgns,	e608100, 2, (RF, RF_IF),     rd_rm),
  C3(lgnsp,	e608120, 2, (RF, RF_IF),     rd_rm),
  C3(lgnsm,	e608140, 2, (RF, RF_IF),     rd_rm),
  C3(lgnsz,	e608160, 2, (RF, RF_IF),     rd_rm),
  C3(lgnd,	e608180, 2, (RF, RF_IF),     rd_rm),
  C3(lgndp,	e6081a0, 2, (RF, RF_IF),     rd_rm),
  C3(lgndm,	e6081c0, 2, (RF, RF_IF),     rd_rm),
  C3(lgndz,	e6081e0, 2, (RF, RF_IF),     rd_rm),
  C3(lgne,	e688100, 2, (RF, RF_IF),     rd_rm),
  C3(lgnep,	e688120, 2, (RF, RF_IF),     rd_rm),
  C3(lgnem,	e688140, 2, (RF, RF_IF),     rd_rm),
  C3(lgnez,	e688160, 2, (RF, RF_IF),     rd_rm),

  C3(exps,	e708100, 2, (RF, RF_IF),     rd_rm),
  C3(expsp,	e708120, 2, (RF, RF_IF),     rd_rm),
  C3(expsm,	e708140, 2, (RF, RF_IF),     rd_rm),
  C3(expsz,	e708160, 2, (RF, RF_IF),     rd_rm),
  C3(expd,	e708180, 2, (RF, RF_IF),     rd_rm),
  C3(expdp,	e7081a0, 2, (RF, RF_IF),     rd_rm),
  C3(expdm,	e7081c0, 2, (RF, RF_IF),     rd_rm),
  C3(expdz,	e7081e0, 2, (RF, RF_IF),     rd_rm),
  C3(expe,	e788100, 2, (RF, RF_IF),     rd_rm),
  C3(expep,	e788120, 2, (RF, RF_IF),     rd_rm),
  C3(expem,	e788140, 2, (RF, RF_IF),     rd_rm),
  C3(expdz,	e788160, 2, (RF, RF_IF),     rd_rm),

  C3(sins,	e808100, 2, (RF, RF_IF),     rd_rm),
  C3(sinsp,	e808120, 2, (RF, RF_IF),     rd_rm),
  C3(sinsm,	e808140, 2, (RF, RF_IF),     rd_rm),
  C3(sinsz,	e808160, 2, (RF, RF_IF),     rd_rm),
  C3(sind,	e808180, 2, (RF, RF_IF),     rd_rm),
  C3(sindp,	e8081a0, 2, (RF, RF_IF),     rd_rm),
  C3(sindm,	e8081c0, 2, (RF, RF_IF),     rd_rm),
  C3(sindz,	e8081e0, 2, (RF, RF_IF),     rd_rm),
  C3(sine,	e888100, 2, (RF, RF_IF),     rd_rm),
  C3(sinep,	e888120, 2, (RF, RF_IF),     rd_rm),
  C3(sinem,	e888140, 2, (RF, RF_IF),     rd_rm),
  C3(sinez,	e888160, 2, (RF, RF_IF),     rd_rm),

  C3(coss,	e908100, 2, (RF, RF_IF),     rd_rm),
  C3(cossp,	e908120, 2, (RF, RF_IF),     rd_rm),
  C3(cossm,	e908140, 2, (RF, RF_IF),     rd_rm),
  C3(cossz,	e908160, 2, (RF, RF_IF),     rd_rm),
  C3(cosd,	e908180, 2, (RF, RF_IF),     rd_rm),
  C3(cosdp,	e9081a0, 2, (RF, RF_IF),     rd_rm),
  C3(cosdm,	e9081c0, 2, (RF, RF_IF),     rd_rm),
  C3(cosdz,	e9081e0, 2, (RF, RF_IF),     rd_rm),
  C3(cose,	e988100, 2, (RF, RF_IF),     rd_rm),
  C3(cosep,	e988120, 2, (RF, RF_IF),     rd_rm),
  C3(cosem,	e988140, 2, (RF, RF_IF),     rd_rm),
  C3(cosez,	e988160, 2, (RF, RF_IF),     rd_rm),

  C3(tans,	ea08100, 2, (RF, RF_IF),     rd_rm),
  C3(tansp,	ea08120, 2, (RF, RF_IF),     rd_rm),
  C3(tansm,	ea08140, 2, (RF, RF_IF),     rd_rm),
  C3(tansz,	ea08160, 2, (RF, RF_IF),     rd_rm),
  C3(tand,	ea08180, 2, (RF, RF_IF),     rd_rm),
  C3(tandp,	ea081a0, 2, (RF, RF_IF),     rd_rm),
  C3(tandm,	ea081c0, 2, (RF, RF_IF),     rd_rm),
  C3(tandz,	ea081e0, 2, (RF, RF_IF),     rd_rm),
  C3(tane,	ea88100, 2, (RF, RF_IF),     rd_rm),
  C3(tanep,	ea88120, 2, (RF, RF_IF),     rd_rm),
  C3(tanem,	ea88140, 2, (RF, RF_IF),     rd_rm),
  C3(tanez,	ea88160, 2, (RF, RF_IF),     rd_rm),

  C3(asns,	eb08100, 2, (RF, RF_IF),     rd_rm),
  C3(asnsp,	eb08120, 2, (RF, RF_IF),     rd_rm),
  C3(asnsm,	eb08140, 2, (RF, RF_IF),     rd_rm),
  C3(asnsz,	eb08160, 2, (RF, RF_IF),     rd_rm),
  C3(asnd,	eb08180, 2, (RF, RF_IF),     rd_rm),
  C3(asndp,	eb081a0, 2, (RF, RF_IF),     rd_rm),
  C3(asndm,	eb081c0, 2, (RF, RF_IF),     rd_rm),
  C3(asndz,	eb081e0, 2, (RF, RF_IF),     rd_rm),
  C3(asne,	eb88100, 2, (RF, RF_IF),     rd_rm),
  C3(asnep,	eb88120, 2, (RF, RF_IF),     rd_rm),
  C3(asnem,	eb88140, 2, (RF, RF_IF),     rd_rm),
  C3(asnez,	eb88160, 2, (RF, RF_IF),     rd_rm),

  C3(acss,	ec08100, 2, (RF, RF_IF),     rd_rm),
  C3(acssp,	ec08120, 2, (RF, RF_IF),     rd_rm),
  C3(acssm,	ec08140, 2, (RF, RF_IF),     rd_rm),
  C3(acssz,	ec08160, 2, (RF, RF_IF),     rd_rm),
  C3(acsd,	ec08180, 2, (RF, RF_IF),     rd_rm),
  C3(acsdp,	ec081a0, 2, (RF, RF_IF),     rd_rm),
  C3(acsdm,	ec081c0, 2, (RF, RF_IF),     rd_rm),
  C3(acsdz,	ec081e0, 2, (RF, RF_IF),     rd_rm),
  C3(acse,	ec88100, 2, (RF, RF_IF),     rd_rm),
  C3(acsep,	ec88120, 2, (RF, RF_IF),     rd_rm),
  C3(acsem,	ec88140, 2, (RF, RF_IF),     rd_rm),
  C3(acsez,	ec88160, 2, (RF, RF_IF),     rd_rm),

  C3(atns,	ed08100, 2, (RF, RF_IF),     rd_rm),
  C3(atnsp,	ed08120, 2, (RF, RF_IF),     rd_rm),
  C3(atnsm,	ed08140, 2, (RF, RF_IF),     rd_rm),
  C3(atnsz,	ed08160, 2, (RF, RF_IF),     rd_rm),
  C3(atnd,	ed08180, 2, (RF, RF_IF),     rd_rm),
  C3(atndp,	ed081a0, 2, (RF, RF_IF),     rd_rm),
  C3(atndm,	ed081c0, 2, (RF, RF_IF),     rd_rm),
  C3(atndz,	ed081e0, 2, (RF, RF_IF),     rd_rm),
  C3(atne,	ed88100, 2, (RF, RF_IF),     rd_rm),
  C3(atnep,	ed88120, 2, (RF, RF_IF),     rd_rm),
  C3(atnem,	ed88140, 2, (RF, RF_IF),     rd_rm),
  C3(atnez,	ed88160, 2, (RF, RF_IF),     rd_rm),

  C3(urds,	ee08100, 2, (RF, RF_IF),     rd_rm),
  C3(urdsp,	ee08120, 2, (RF, RF_IF),     rd_rm),
  C3(urdsm,	ee08140, 2, (RF, RF_IF),     rd_rm),
  C3(urdsz,	ee08160, 2, (RF, RF_IF),     rd_rm),
  C3(urdd,	ee08180, 2, (RF, RF_IF),     rd_rm),
  C3(urddp,	ee081a0, 2, (RF, RF_IF),     rd_rm),
  C3(urddm,	ee081c0, 2, (RF, RF_IF),     rd_rm),
  C3(urddz,	ee081e0, 2, (RF, RF_IF),     rd_rm),
  C3(urde,	ee88100, 2, (RF, RF_IF),     rd_rm),
  C3(urdep,	ee88120, 2, (RF, RF_IF),     rd_rm),
  C3(urdem,	ee88140, 2, (RF, RF_IF),     rd_rm),
  C3(urdez,	ee88160, 2, (RF, RF_IF),     rd_rm),

  C3(nrms,	ef08100, 2, (RF, RF_IF),     rd_rm),
  C3(nrmsp,	ef08120, 2, (RF, RF_IF),     rd_rm),
  C3(nrmsm,	ef08140, 2, (RF, RF_IF),     rd_rm),
  C3(nrmsz,	ef08160, 2, (RF, RF_IF),     rd_rm),
  C3(nrmd,	ef08180, 2, (RF, RF_IF),     rd_rm),
  C3(nrmdp,	ef081a0, 2, (RF, RF_IF),     rd_rm),
  C3(nrmdm,	ef081c0, 2, (RF, RF_IF),     rd_rm),
  C3(nrmdz,	ef081e0, 2, (RF, RF_IF),     rd_rm),
  C3(nrme,	ef88100, 2, (RF, RF_IF),     rd_rm),
  C3(nrmep,	ef88120, 2, (RF, RF_IF),     rd_rm),
  C3(nrmem,	ef88140, 2, (RF, RF_IF),     rd_rm),
  C3(nrmez,	ef88160, 2, (RF, RF_IF),     rd_rm),

  C3(adfs,	e000100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfsp,	e000120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfsm,	e000140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfsz,	e000160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfd,	e000180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfdp,	e0001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfdm,	e0001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfdz,	e0001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfe,	e080100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfep,	e080120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfem,	e080140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfez,	e080160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(sufs,	e200100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufsp,	e200120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufsm,	e200140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufsz,	e200160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufd,	e200180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufdp,	e2001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufdm,	e2001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufdz,	e2001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufe,	e280100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufep,	e280120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufem,	e280140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufez,	e280160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(rsfs,	e300100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfsp,	e300120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfsm,	e300140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfsz,	e300160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfd,	e300180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfdp,	e3001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfdm,	e3001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfdz,	e3001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfe,	e380100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfep,	e380120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfem,	e380140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfez,	e380160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(mufs,	e100100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufsp,	e100120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufsm,	e100140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufsz,	e100160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufd,	e100180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufdp,	e1001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufdm,	e1001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufdz,	e1001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufe,	e180100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufep,	e180120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufem,	e180140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufez,	e180160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(dvfs,	e400100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfsp,	e400120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfsm,	e400140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfsz,	e400160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfd,	e400180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfdp,	e4001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfdm,	e4001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfdz,	e4001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfe,	e480100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfep,	e480120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfem,	e480140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfez,	e480160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(rdfs,	e500100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfsp,	e500120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfsm,	e500140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfsz,	e500160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfd,	e500180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfdp,	e5001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfdm,	e5001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfdz,	e5001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfe,	e580100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfep,	e580120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfem,	e580140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfez,	e580160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(pows,	e600100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powsp,	e600120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powsm,	e600140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powsz,	e600160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powd,	e600180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powdp,	e6001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powdm,	e6001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powdz,	e6001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powe,	e680100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powep,	e680120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powem,	e680140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powez,	e680160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(rpws,	e700100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwsp,	e700120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwsm,	e700140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwsz,	e700160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwd,	e700180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwdp,	e7001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwdm,	e7001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwdz,	e7001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwe,	e780100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwep,	e780120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwem,	e780140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwez,	e780160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(rmfs,	e800100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfsp,	e800120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfsm,	e800140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfsz,	e800160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfd,	e800180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfdp,	e8001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfdm,	e8001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfdz,	e8001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfe,	e880100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfep,	e880120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfem,	e880140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfez,	e880160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(fmls,	e900100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmlsp,	e900120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmlsm,	e900140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmlsz,	e900160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmld,	e900180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmldp,	e9001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmldm,	e9001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmldz,	e9001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmle,	e980100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmlep,	e980120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmlem,	e980140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmlez,	e980160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(fdvs,	ea00100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvsp,	ea00120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvsm,	ea00140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvsz,	ea00160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvd,	ea00180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvdp,	ea001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvdm,	ea001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvdz,	ea001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdve,	ea80100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvep,	ea80120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvem,	ea80140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvez,	ea80160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(frds,	eb00100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frdsp,	eb00120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frdsm,	eb00140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frdsz,	eb00160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frdd,	eb00180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frddp,	eb001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frddm,	eb001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frddz,	eb001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frde,	eb80100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frdep,	eb80120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frdem,	eb80140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frdez,	eb80160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(pols,	ec00100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(polsp,	ec00120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(polsm,	ec00140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(polsz,	ec00160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(pold,	ec00180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(poldp,	ec001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(poldm,	ec001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(poldz,	ec001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(pole,	ec80100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(polep,	ec80120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(polem,	ec80140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(polez,	ec80160, 3, (RF, RF, RF_IF), rd_rn_rm),

  CE(cmf,	e90f110, 2, (RF, RF_IF),     fpa_cmp),
 C3E(cmfe,	ed0f110, 2, (RF, RF_IF),     fpa_cmp),
  CE(cnf,	eb0f110, 2, (RF, RF_IF),     fpa_cmp),
 C3E(cnfe,	ef0f110, 2, (RF, RF_IF),     fpa_cmp),

  C3(flts,	e000110, 2, (RF, RR),	     rn_rd),
  C3(fltsp,	e000130, 2, (RF, RR),	     rn_rd),
  C3(fltsm,	e000150, 2, (RF, RR),	     rn_rd),
  C3(fltsz,	e000170, 2, (RF, RR),	     rn_rd),
  C3(fltd,	e000190, 2, (RF, RR),	     rn_rd),
  C3(fltdp,	e0001b0, 2, (RF, RR),	     rn_rd),
  C3(fltdm,	e0001d0, 2, (RF, RR),	     rn_rd),
  C3(fltdz,	e0001f0, 2, (RF, RR),	     rn_rd),
  C3(flte,	e080110, 2, (RF, RR),	     rn_rd),
  C3(fltep,	e080130, 2, (RF, RR),	     rn_rd),
  C3(fltem,	e080150, 2, (RF, RR),	     rn_rd),
  C3(fltez,	e080170, 2, (RF, RR),	     rn_rd),

  /* The implementation of the FIX instruction is broken on some
     assemblers, in that it accepts a precision specifier as well as a
     rounding specifier, despite the fact that this is meaningless.
     To be more compatible, we accept it as well, though of course it
     does not set any bits.  */
  CE(fix,	e100110, 2, (RR, RF),	     rd_rm),
  C3(fixp,	e100130, 2, (RR, RF),	     rd_rm),
  C3(fixm,	e100150, 2, (RR, RF),	     rd_rm),
  C3(fixz,	e100170, 2, (RR, RF),	     rd_rm),
  C3(fixsp,	e100130, 2, (RR, RF),	     rd_rm),
  C3(fixsm,	e100150, 2, (RR, RF),	     rd_rm),
  C3(fixsz,	e100170, 2, (RR, RF),	     rd_rm),
  C3(fixdp,	e100130, 2, (RR, RF),	     rd_rm),
  C3(fixdm,	e100150, 2, (RR, RF),	     rd_rm),
  C3(fixdz,	e100170, 2, (RR, RF),	     rd_rm),
  C3(fixep,	e100130, 2, (RR, RF),	     rd_rm),
  C3(fixem,	e100150, 2, (RR, RF),	     rd_rm),
  C3(fixez,	e100170, 2, (RR, RF),	     rd_rm),

  /* Instructions that were new with the real FPA, call them V2.  */
#undef ARM_VARIANT
#define ARM_VARIANT FPU_FPA_EXT_V2
  CE(lfm,	c100200, 3, (RF, I4b, ADDR), fpa_ldmstm),
  C3(lfmfd,	c900200, 3, (RF, I4b, ADDR), fpa_ldmstm),
  C3(lfmea,	d100200, 3, (RF, I4b, ADDR), fpa_ldmstm),
  CE(sfm,	c000200, 3, (RF, I4b, ADDR), fpa_ldmstm),
  C3(sfmfd,	d000200, 3, (RF, I4b, ADDR), fpa_ldmstm),
  C3(sfmea,	c800200, 3, (RF, I4b, ADDR), fpa_ldmstm),

#undef ARM_VARIANT
#define ARM_VARIANT FPU_VFP_EXT_V1xD  /* VFP V1xD (single precision).  */
  /* Moves and type conversions.  */
  CE(fcpys,	eb00a40, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(fmrs,	e100a10, 2, (RR, RVS),	      vfp_reg_from_sp),
  CE(fmsr,	e000a10, 2, (RVS, RR),	      vfp_sp_from_reg),
  CE(fmstat,	ef1fa10, 0, (),		      noargs),
  CE(fsitos,	eb80ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(fuitos,	eb80a40, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(ftosis,	ebd0a40, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(ftosizs,	ebd0ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(ftouis,	ebc0a40, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(ftouizs,	ebc0ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(fmrx,	ef00a10, 2, (RR, RVC),	      rd_rn),
  CE(fmxr,	ee00a10, 2, (RVC, RR),	      rn_rd),

  /* Memory operations.	 */
  CE(flds,	d100a00, 2, (RVS, ADDR),      vfp_sp_ldst),
  CE(fsts,	d000a00, 2, (RVS, ADDR),      vfp_sp_ldst),
  CE(fldmias,	c900a00, 2, (RRw, VRSLST),    vfp_sp_ldstmia),
  CE(fldmfds,	c900a00, 2, (RRw, VRSLST),    vfp_sp_ldstmia),
  CE(fldmdbs,	d300a00, 2, (RRw, VRSLST),    vfp_sp_ldstmdb),
  CE(fldmeas,	d300a00, 2, (RRw, VRSLST),    vfp_sp_ldstmdb),
  CE(fldmiax,	c900b00, 2, (RRw, VRDLST),    vfp_xp_ldstmia),
  CE(fldmfdx,	c900b00, 2, (RRw, VRDLST),    vfp_xp_ldstmia),
  CE(fldmdbx,	d300b00, 2, (RRw, VRDLST),    vfp_xp_ldstmdb),
  CE(fldmeax,	d300b00, 2, (RRw, VRDLST),    vfp_xp_ldstmdb),
  CE(fstmias,	c800a00, 2, (RRw, VRSLST),    vfp_sp_ldstmia),
  CE(fstmeas,	c800a00, 2, (RRw, VRSLST),    vfp_sp_ldstmia),
  CE(fstmdbs,	d200a00, 2, (RRw, VRSLST),    vfp_sp_ldstmdb),
  CE(fstmfds,	d200a00, 2, (RRw, VRSLST),    vfp_sp_ldstmdb),
  CE(fstmiax,	c800b00, 2, (RRw, VRDLST),    vfp_xp_ldstmia),
  CE(fstmeax,	c800b00, 2, (RRw, VRDLST),    vfp_xp_ldstmia),
  CE(fstmdbx,	d200b00, 2, (RRw, VRDLST),    vfp_xp_ldstmdb),
  CE(fstmfdx,	d200b00, 2, (RRw, VRDLST),    vfp_xp_ldstmdb),

  /* Monadic operations.  */
  CE(fabss,	eb00ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(fnegs,	eb10a40, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(fsqrts,	eb10ac0, 2, (RVS, RVS),	      vfp_sp_monadic),

  /* Dyadic operations.	 */
  CE(fadds,	e300a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
  CE(fsubs,	e300a40, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
  CE(fmuls,	e200a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
  CE(fdivs,	e800a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
  CE(fmacs,	e000a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
  CE(fmscs,	e100a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
  CE(fnmuls,	e200a40, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
  CE(fnmacs,	e000a40, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
  CE(fnmscs,	e100a40, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),

  /* Comparisons.  */
  CE(fcmps,	eb40a40, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(fcmpzs,	eb50a40, 1, (RVS),	      vfp_sp_compare_z),
  CE(fcmpes,	eb40ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(fcmpezs,	eb50ac0, 1, (RVS),	      vfp_sp_compare_z),

#undef ARM_VARIANT
#define ARM_VARIANT FPU_VFP_EXT_V1 /* VFP V1 (Double precision).  */
  /* Moves and type conversions.  */
  CE(fcpyd,	eb00b40, 2, (RVD, RVD),	      rd_rm),
  CE(fcvtds,	eb70ac0, 2, (RVD, RVS),	      vfp_dp_sp_cvt),
  CE(fcvtsd,	eb70bc0, 2, (RVS, RVD),	      vfp_sp_dp_cvt),
  CE(fmdhr,	e200b10, 2, (RVD, RR),	      rn_rd),
  CE(fmdlr,	e000b10, 2, (RVD, RR),	      rn_rd),
  CE(fmrdh,	e300b10, 2, (RR, RVD),	      rd_rn),
  CE(fmrdl,	e100b10, 2, (RR, RVD),	      rd_rn),
  CE(fsitod,	eb80bc0, 2, (RVD, RVS),	      vfp_dp_sp_cvt),
  CE(fuitod,	eb80b40, 2, (RVD, RVS),	      vfp_dp_sp_cvt),
  CE(ftosid,	ebd0b40, 2, (RVS, RVD),	      vfp_sp_dp_cvt),
  CE(ftosizd,	ebd0bc0, 2, (RVS, RVD),	      vfp_sp_dp_cvt),
  CE(ftouid,	ebc0b40, 2, (RVS, RVD),	      vfp_sp_dp_cvt),
  CE(ftouizd,	ebc0bc0, 2, (RVS, RVD),	      vfp_sp_dp_cvt),

  /* Memory operations.	 */
  CE(fldd,	d100b00, 2, (RVD, ADDR),      vfp_dp_ldst),
  CE(fstd,	d000b00, 2, (RVD, ADDR),      vfp_dp_ldst),
  CE(fldmiad,	c900b00, 2, (RRw, VRDLST),    vfp_dp_ldstmia),
  CE(fldmfdd,	c900b00, 2, (RRw, VRDLST),    vfp_dp_ldstmia),
  CE(fldmdbd,	d300b00, 2, (RRw, VRDLST),    vfp_dp_ldstmdb),
  CE(fldmead,	d300b00, 2, (RRw, VRDLST),    vfp_dp_ldstmdb),
  CE(fstmiad,	c800b00, 2, (RRw, VRDLST),    vfp_dp_ldstmia),
  CE(fstmead,	c800b00, 2, (RRw, VRDLST),    vfp_dp_ldstmia),
  CE(fstmdbd,	d200b00, 2, (RRw, VRDLST),    vfp_dp_ldstmdb),
  CE(fstmfdd,	d200b00, 2, (RRw, VRDLST),    vfp_dp_ldstmdb),

  /* Monadic operations.  */
  CE(fabsd,	eb00bc0, 2, (RVD, RVD),	      rd_rm),
  CE(fnegd,	eb10b40, 2, (RVD, RVD),	      rd_rm),
  CE(fsqrtd,	eb10bc0, 2, (RVD, RVD),	      rd_rm),

  /* Dyadic operations.	 */
  CE(faddd,	e300b00, 3, (RVD, RVD, RVD),  rd_rn_rm),
  CE(fsubd,	e300b40, 3, (RVD, RVD, RVD),  rd_rn_rm),
  CE(fmuld,	e200b00, 3, (RVD, RVD, RVD),  rd_rn_rm),
  CE(fdivd,	e800b00, 3, (RVD, RVD, RVD),  rd_rn_rm),
  CE(fmacd,	e000b00, 3, (RVD, RVD, RVD),  rd_rn_rm),
  CE(fmscd,	e100b00, 3, (RVD, RVD, RVD),  rd_rn_rm),
  CE(fnmuld,	e200b40, 3, (RVD, RVD, RVD),  rd_rn_rm),
  CE(fnmacd,	e000b40, 3, (RVD, RVD, RVD),  rd_rn_rm),
  CE(fnmscd,	e100b40, 3, (RVD, RVD, RVD),  rd_rn_rm),

  /* Comparisons.  */
  CE(fcmpd,	eb40b40, 2, (RVD, RVD),	      rd_rm),
  CE(fcmpzd,	eb50b40, 1, (RVD),	      rd),
  CE(fcmped,	eb40bc0, 2, (RVD, RVD),	      rd_rm),
  CE(fcmpezd,	eb50bc0, 1, (RVD),	      rd),

#undef ARM_VARIANT
#define ARM_VARIANT FPU_VFP_EXT_V2
  CE(fmsrr,	c400a10, 3, (VRSLST, RR, RR), vfp_sp2_from_reg2),
  CE(fmrrs,	c500a10, 3, (RR, RR, VRSLST), vfp_reg2_from_sp2),
  CE(fmdrr,	c400b10, 3, (RVD, RR, RR),    rm_rd_rn),
  CE(fmrrd,	c500b10, 3, (RR, RR, RVD),    rd_rn_rm),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_CEXT_XSCALE /* Intel XScale extensions.	 */
  CE(mia,	e200010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
  CE(miaph,	e280010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
  CE(miabb,	e2c0010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
  CE(miabt,	e2d0010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
  CE(miatb,	e2e0010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
  CE(miatt,	e2f0010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
  CE(mar,	c400000, 3, (RXA, RRnpc, RRnpc), xsc_mar),
  CE(mra,	c500000, 3, (RRnpc, RRnpc, RXA), xsc_mra),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_CEXT_IWMMXT /* Intel Wireless MMX technology.  */
  CE(tandcb,	e13f130, 1, (RR),		    iwmmxt_tandorc),
  CE(tandch,	e53f130, 1, (RR),		    iwmmxt_tandorc),
  CE(tandcw,	e93f130, 1, (RR),		    iwmmxt_tandorc),
  CE(tbcstb,	e400010, 2, (RIWR, RR),		    rn_rd),
  CE(tbcsth,	e400050, 2, (RIWR, RR),		    rn_rd),
  CE(tbcstw,	e400090, 2, (RIWR, RR),		    rn_rd),
  CE(textrcb,	e130170, 2, (RR, I7),		    iwmmxt_textrc),
  CE(textrch,	e530170, 2, (RR, I7),		    iwmmxt_textrc),
  CE(textrcw,	e930170, 2, (RR, I7),		    iwmmxt_textrc),
  CE(textrmub,	e100070, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
  CE(textrmuh,	e500070, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
  CE(textrmuw,	e900070, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
  CE(textrmsb,	e100078, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
  CE(textrmsh,	e500078, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
  CE(textrmsw,	e900078, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
  CE(tinsrb,	e600010, 3, (RIWR, RR, I7),	    iwmmxt_tinsr),
  CE(tinsrh,	e600050, 3, (RIWR, RR, I7),	    iwmmxt_tinsr),
  CE(tinsrw,	e600090, 3, (RIWR, RR, I7),	    iwmmxt_tinsr),
  CE(tmcr,	e000110, 2, (RIWC, RR),		    rn_rd),
  CE(tmcrr,	c400000, 3, (RIWR, RR, RR),	    rm_rd_rn),
  CE(tmia,	e200010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
  CE(tmiaph,	e280010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
  CE(tmiabb,	e2c0010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
  CE(tmiabt,	e2d0010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
  CE(tmiatb,	e2e0010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
  CE(tmiatt,	e2f0010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
  CE(tmovmskb,	e100030, 2, (RR, RIWR),		    rd_rn),
  CE(tmovmskh,	e500030, 2, (RR, RIWR),		    rd_rn),
  CE(tmovmskw,	e900030, 2, (RR, RIWR),		    rd_rn),
  CE(tmrc,	e100110, 2, (RR, RIWC),		    rd_rn),
  CE(tmrrc,	c500000, 3, (RR, RR, RIWR),	    rd_rn_rm),
  CE(torcb,	e13f150, 1, (RR),		    iwmmxt_tandorc),
  CE(torch,	e53f150, 1, (RR),		    iwmmxt_tandorc),
  CE(torcw,	e93f150, 1, (RR),		    iwmmxt_tandorc),
  CE(waccb,	e0001c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wacch,	e4001c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(waccw,	e8001c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(waddbss,	e300180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waddb,	e000180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waddbus,	e100180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waddhss,	e700180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waddh,	e400180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waddhus,	e500180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waddwss,	eb00180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waddw,	e800180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waddwus,	e900180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waligni,	e000020, 4, (RIWR, RIWR, RIWR, I7), iwmmxt_waligni),
  CE(walignr0,	e800020, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(walignr1,	e900020, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(walignr2,	ea00020, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(walignr3,	eb00020, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wand,	e200000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wandn,	e300000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wavg2b,	e800000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wavg2br,	e900000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wavg2h,	ec00000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wavg2hr,	ed00000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpeqb,	e000060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpeqh,	e400060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpeqw,	e800060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpgtub,	e100060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpgtuh,	e500060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpgtuw,	e900060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpgtsb,	e300060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpgtsh,	e700060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpgtsw,	eb00060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wldrb,	c100000, 2, (RIWR, ADDR),	    iwmmxt_wldstbh),
  CE(wldrh,	c500000, 2, (RIWR, ADDR),	    iwmmxt_wldstbh),
  CE(wldrw,	c100100, 2, (RIWR_RIWC, ADDR),	    iwmmxt_wldstw),
  CE(wldrd,	c500100, 2, (RIWR, ADDR),	    iwmmxt_wldstd),
  CE(wmacs,	e600100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmacsz,	e700100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmacu,	e400100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmacuz,	e500100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmadds,	ea00100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmaddu,	e800100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmaxsb,	e200160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmaxsh,	e600160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmaxsw,	ea00160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmaxub,	e000160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmaxuh,	e400160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmaxuw,	e800160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wminsb,	e300160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wminsh,	e700160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wminsw,	eb00160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wminub,	e100160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wminuh,	e500160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wminuw,	e900160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmov,	e000000, 2, (RIWR, RIWR),	    iwmmxt_wmov),
  CE(wmulsm,	e300100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmulsl,	e200100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmulum,	e100100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmulul,	e000100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wor,	e000000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wpackhss,	e700080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wpackhus,	e500080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wpackwss,	eb00080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wpackwus,	e900080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wpackdss,	ef00080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wpackdus,	ed00080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wrorh,	e700040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wrorhg,	e700148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wrorw,	eb00040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wrorwg,	eb00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wrord,	ef00040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wrordg,	ef00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wsadb,	e000120, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsadbz,	e100120, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsadh,	e400120, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsadhz,	e500120, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wshufh,	e0001e0, 3, (RIWR, RIWR, I255),	    iwmmxt_wshufh),
  CE(wsllh,	e500040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsllhg,	e500148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wsllw,	e900040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsllwg,	e900148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wslld,	ed00040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wslldg,	ed00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wsrah,	e400040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsrahg,	e400148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wsraw,	e800040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsrawg,	e800148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wsrad,	ec00040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsradg,	ec00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wsrlh,	e600040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsrlhg,	e600148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wsrlw,	ea00040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsrlwg,	ea00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wsrld,	ee00040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsrldg,	ee00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wstrb,	c000000, 2, (RIWR, ADDR),	    iwmmxt_wldstbh),
  CE(wstrh,	c400000, 2, (RIWR, ADDR),	    iwmmxt_wldstbh),
  CE(wstrw,	c000100, 2, (RIWR_RIWC, ADDR),	    iwmmxt_wldstw),
  CE(wstrd,	c400100, 2, (RIWR, ADDR),	    iwmmxt_wldstd),
  CE(wsubbss,	e3001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsubb,	e0001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsubbus,	e1001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsubhss,	e7001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsubh,	e4001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsubhus,	e5001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsubwss,	eb001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsubw,	e8001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsubwus,	e9001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wunpckehub,e0000c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckehuh,e4000c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckehuw,e8000c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckehsb,e2000c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckehsh,e6000c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckehsw,ea000c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckihb, e1000c0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wunpckihh, e5000c0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wunpckihw, e9000c0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wunpckelub,e0000e0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckeluh,e4000e0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckeluw,e8000e0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckelsb,e2000e0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckelsh,e6000e0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckelsw,ea000e0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckilb, e1000e0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wunpckilh, e5000e0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wunpckilw, e9000e0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wxor,	e100000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wzero,	e300000, 1, (RIWR),		    iwmmxt_wzero),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_CEXT_MAVERICK /* Cirrus Maverick instructions.	*/
  CE(cfldrs,	c100400, 2, (RMF, ADDR),	      rd_cpaddr),
  CE(cfldrd,	c500400, 2, (RMD, ADDR),	      rd_cpaddr),
  CE(cfldr32,	c100500, 2, (RMFX, ADDR),	      rd_cpaddr),
  CE(cfldr64,	c500500, 2, (RMDX, ADDR),	      rd_cpaddr),
  CE(cfstrs,	c000400, 2, (RMF, ADDR),	      rd_cpaddr),
  CE(cfstrd,	c400400, 2, (RMD, ADDR),	      rd_cpaddr),
  CE(cfstr32,	c000500, 2, (RMFX, ADDR),	      rd_cpaddr),
  CE(cfstr64,	c400500, 2, (RMDX, ADDR),	      rd_cpaddr),
  CE(cfmvsr,	e000450, 2, (RMF, RR),		      rn_rd),
  CE(cfmvrs,	e100450, 2, (RR, RMF),		      rd_rn),
  CE(cfmvdlr,	e000410, 2, (RMD, RR),		      rn_rd),
  CE(cfmvrdl,	e100410, 2, (RR, RMD),		      rd_rn),
  CE(cfmvdhr,	e000430, 2, (RMD, RR),		      rn_rd),
  CE(cfmvrdh,	e100430, 2, (RR, RMD),		      rd_rn),
  CE(cfmv64lr,	e000510, 2, (RMDX, RR),		      rn_rd),
  CE(cfmvr64l,	e100510, 2, (RR, RMDX),		      rd_rn),
  CE(cfmv64hr,	e000530, 2, (RMDX, RR),		      rn_rd),
  CE(cfmvr64h,	e100530, 2, (RR, RMDX),		      rd_rn),
  CE(cfmval32,	e200440, 2, (RMAX, RMFX),	      rd_rn),
  CE(cfmv32al,	e100440, 2, (RMFX, RMAX),	      rd_rn),
  CE(cfmvam32,	e200460, 2, (RMAX, RMFX),	      rd_rn),
  CE(cfmv32am,	e100460, 2, (RMFX, RMAX),	      rd_rn),
  CE(cfmvah32,	e200480, 2, (RMAX, RMFX),	      rd_rn),
  CE(cfmv32ah,	e100480, 2, (RMFX, RMAX),	      rd_rn),
  CE(cfmva32,	e2004a0, 2, (RMAX, RMFX),	      rd_rn),
  CE(cfmv32a,	e1004a0, 2, (RMFX, RMAX),	      rd_rn),
  CE(cfmva64,	e2004c0, 2, (RMAX, RMDX),	      rd_rn),
  CE(cfmv64a,	e1004c0, 2, (RMDX, RMAX),	      rd_rn),
  CE(cfmvsc32,	e2004e0, 2, (RMDS, RMDX),	      mav_dspsc),
  CE(cfmv32sc,	e1004e0, 2, (RMDX, RMDS),	      rd),
  CE(cfcpys,	e000400, 2, (RMF, RMF),		      rd_rn),
  CE(cfcpyd,	e000420, 2, (RMD, RMD),		      rd_rn),
  CE(cfcvtsd,	e000460, 2, (RMD, RMF),		      rd_rn),
  CE(cfcvtds,	e000440, 2, (RMF, RMD),		      rd_rn),
  CE(cfcvt32s,	e000480, 2, (RMF, RMFX),	      rd_rn),
  CE(cfcvt32d,	e0004a0, 2, (RMD, RMFX),	      rd_rn),
  CE(cfcvt64s,	e0004c0, 2, (RMF, RMDX),	      rd_rn),
  CE(cfcvt64d,	e0004e0, 2, (RMD, RMDX),	      rd_rn),
  CE(cfcvts32,	e100580, 2, (RMFX, RMF),	      rd_rn),
  CE(cfcvtd32,	e1005a0, 2, (RMFX, RMD),	      rd_rn),
  CE(cftruncs32,e1005c0, 2, (RMFX, RMF),	      rd_rn),
  CE(cftruncd32,e1005e0, 2, (RMFX, RMD),	      rd_rn),
  CE(cfrshl32,	e000550, 3, (RMFX, RMFX, RR),	      mav_triple),
  CE(cfrshl64,	e000570, 3, (RMDX, RMDX, RR),	      mav_triple),
  CE(cfsh32,	e000500, 3, (RMFX, RMFX, I63s),	      mav_shift),
  CE(cfsh64,	e200500, 3, (RMDX, RMDX, I63s),	      mav_shift),
  CE(cfcmps,	e100490, 3, (RR, RMF, RMF),	      rd_rn_rm),
  CE(cfcmpd,	e1004b0, 3, (RR, RMD, RMD),	      rd_rn_rm),
  CE(cfcmp32,	e100590, 3, (RR, RMFX, RMFX),	      rd_rn_rm),
  CE(cfcmp64,	e1005b0, 3, (RR, RMDX, RMDX),	      rd_rn_rm),
  CE(cfabss,	e300400, 2, (RMF, RMF),		      rd_rn),
  CE(cfabsd,	e300420, 2, (RMD, RMD),		      rd_rn),
  CE(cfnegs,	e300440, 2, (RMF, RMF),		      rd_rn),
  CE(cfnegd,	e300460, 2, (RMD, RMD),		      rd_rn),
  CE(cfadds,	e300480, 3, (RMF, RMF, RMF),	      rd_rn_rm),
  CE(cfaddd,	e3004a0, 3, (RMD, RMD, RMD),	      rd_rn_rm),
  CE(cfsubs,	e3004c0, 3, (RMF, RMF, RMF),	      rd_rn_rm),
  CE(cfsubd,	e3004e0, 3, (RMD, RMD, RMD),	      rd_rn_rm),
  CE(cfmuls,	e100400, 3, (RMF, RMF, RMF),	      rd_rn_rm),
  CE(cfmuld,	e100420, 3, (RMD, RMD, RMD),	      rd_rn_rm),
  CE(cfabs32,	e300500, 2, (RMFX, RMFX),	      rd_rn),
  CE(cfabs64,	e300520, 2, (RMDX, RMDX),	      rd_rn),
  CE(cfneg32,	e300540, 2, (RMFX, RMFX),	      rd_rn),
  CE(cfneg64,	e300560, 2, (RMDX, RMDX),	      rd_rn),
  CE(cfadd32,	e300580, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
  CE(cfadd64,	e3005a0, 3, (RMDX, RMDX, RMDX),	      rd_rn_rm),
  CE(cfsub32,	e3005c0, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
  CE(cfsub64,	e3005e0, 3, (RMDX, RMDX, RMDX),	      rd_rn_rm),
  CE(cfmul32,	e100500, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
  CE(cfmul64,	e100520, 3, (RMDX, RMDX, RMDX),	      rd_rn_rm),
  CE(cfmac32,	e100540, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
  CE(cfmsc32,	e100560, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
  CE(cfmadd32,	e000600, 4, (RMAX, RMFX, RMFX, RMFX), mav_quad),
  CE(cfmsub32,	e100600, 4, (RMAX, RMFX, RMFX, RMFX), mav_quad),
  CE(cfmadda32, e200600, 4, (RMAX, RMAX, RMFX, RMFX), mav_quad),
  CE(cfmsuba32, e300600, 4, (RMAX, RMAX, RMFX, RMFX), mav_quad),
};
#undef ARM_VARIANT
#undef THUMB_VARIANT
#undef TCE
#undef TCM
#undef TUE
#undef TUF
#undef TCC
#undef CE
#undef CM
#undef UE
#undef UF
#undef UT
#undef OPS0
#undef OPS1
#undef OPS2
#undef OPS3
#undef OPS4
#undef OPS5
#undef OPS6
#undef do_0

/* MD interface: bits in the object file.  */

/* Turn an integer of n bytes (in val) into a stream of bytes appropriate
   for use in the a.out file, and stores them in the array pointed to by buf.
   This knows about the endian-ness of the target machine and does
   THE RIGHT THING, whatever it is.  Possible values for n are 1 (byte)
   2 (short) and 4 (long)  Floating numbers are put out as a series of
   LITTLENUMS (shorts, here at least).	*/

void
md_number_to_chars (char * buf, valueT val, int n)
{
  if (target_big_endian)
    number_to_chars_bigendian (buf, val, n);
  else
    number_to_chars_littleendian (buf, val, n);
}

static valueT
md_chars_to_number (char * buf, int n)
{
  valueT result = 0;
  unsigned char * where = (unsigned char *) buf;

  if (target_big_endian)
    {
      while (n--)
	{
	  result <<= 8;
	  result |= (*where++ & 255);
	}
    }
  else
    {
      while (n--)
	{
	  result <<= 8;
	  result |= (where[n] & 255);
	}
    }

  return result;
}

/* MD interface: Sections.  */

int
md_estimate_size_before_relax (fragS * fragP ATTRIBUTE_UNUSED,
			       segT    segtype ATTRIBUTE_UNUSED)
{
  as_fatal (_("md_estimate_size_before_relax\n"));
  return 1;
}

/* Round up a section size to the appropriate boundary.	 */

valueT
md_section_align (segT	 segment ATTRIBUTE_UNUSED,
		  valueT size)
{
#ifdef OBJ_ELF
  return size;
#else
  /* Round all sects to multiple of 4.	*/
  return (size + 3) & ~3;
#endif
}

/* This is called from HANDLE_ALIGN in write.c.	 Fill in the contents
   of an rs_align_code fragment.  */

void
arm_handle_align (fragS * fragP)
{
  static char const arm_noop[4] = { 0x00, 0x00, 0xa0, 0xe1 };
  static char const thumb_noop[2] = { 0xc0, 0x46 };
  static char const arm_bigend_noop[4] = { 0xe1, 0xa0, 0x00, 0x00 };
  static char const thumb_bigend_noop[2] = { 0x46, 0xc0 };

  int bytes, fix, noop_size;
  char * p;
  const char * noop;

  if (fragP->fr_type != rs_align_code)
    return;

  bytes = fragP->fr_next->fr_address - fragP->fr_address - fragP->fr_fix;
  p = fragP->fr_literal + fragP->fr_fix;
  fix = 0;

  if (bytes > MAX_MEM_FOR_RS_ALIGN_CODE)
    bytes &= MAX_MEM_FOR_RS_ALIGN_CODE;

  if (fragP->tc_frag_data)
    {
      if (target_big_endian)
	noop = thumb_bigend_noop;
      else
	noop = thumb_noop;
      noop_size = sizeof (thumb_noop);
    }
  else
    {
      if (target_big_endian)
	noop = arm_bigend_noop;
      else
	noop = arm_noop;
      noop_size = sizeof (arm_noop);
    }

  if (bytes & (noop_size - 1))
    {
      fix = bytes & (noop_size - 1);
      memset (p, 0, fix);
      p += fix;
      bytes -= fix;
    }

  while (bytes >= noop_size)
    {
      memcpy (p, noop, noop_size);
      p += noop_size;
      bytes -= noop_size;
      fix += noop_size;
    }

  fragP->fr_fix += fix;
  fragP->fr_var = noop_size;
}

/* Called from md_do_align.  Used to create an alignment
   frag in a code section.  */

void
arm_frag_align_code (int n, int max)
{
  char * p;

  /* We assume that there will never be a requirement
     to support alignments greater than 32 bytes.  */
  if (max > MAX_MEM_FOR_RS_ALIGN_CODE)
    as_fatal (_("alignments greater than 32 bytes not supported in .text sections."));

  p = frag_var (rs_align_code,
		MAX_MEM_FOR_RS_ALIGN_CODE,
		1,
		(relax_substateT) max,
		(symbolS *) NULL,
		(offsetT) n,
		(char *) NULL);
  *p = 0;
}

/* Perform target specific initialisation of a frag.  */

void
arm_init_frag (fragS * fragP)
{
  /* Record whether this frag is in an ARM or a THUMB area.  */
  fragP->tc_frag_data = thumb_mode;
}

#ifdef OBJ_ELF
/* When we change sections we need to issue a new mapping symbol.  */

void
arm_elf_change_section (void)
{
  flagword flags;
  segment_info_type *seginfo;

  /* Link an unlinked unwind index table section to the .text section.	*/
  if (elf_section_type (now_seg) == SHT_ARM_EXIDX
      && elf_linked_to_section (now_seg) == NULL)
    elf_linked_to_section (now_seg) = text_section;

  if (!SEG_NORMAL (now_seg))
    return;

  flags = bfd_get_section_flags (stdoutput, now_seg);

  /* We can ignore sections that only contain debug info.  */
  if ((flags & SEC_ALLOC) == 0)
    return;

  seginfo = seg_info (now_seg);
  mapstate = seginfo->tc_segment_info_data.mapstate;
  marked_pr_dependency = seginfo->tc_segment_info_data.marked_pr_dependency;
}

int
arm_elf_section_type (const char * str, size_t len)
{
  if (len == 5 && strncmp (str, "exidx", 5) == 0)
    return SHT_ARM_EXIDX;

  return -1;
}

/* Code to deal with unwinding tables.	*/

static void add_unwind_adjustsp (offsetT);

/* Cenerate and deferred unwind frame offset.  */

static void
flush_pending_unwind (void)
{
  offsetT offset;

  offset = unwind.pending_offset;
  unwind.pending_offset = 0;
  if (offset != 0)
    add_unwind_adjustsp (offset);
}

/* Add an opcode to this list for this function.  Two-byte opcodes should
   be passed as op[0] << 8 | op[1].  The list of opcodes is built in reverse
   order.  */

static void
add_unwind_opcode (valueT op, int length)
{
  /* Add any deferred stack adjustment.	 */
  if (unwind.pending_offset)
    flush_pending_unwind ();

  unwind.sp_restored = 0;

  if (unwind.opcode_count + length > unwind.opcode_alloc)
    {
      unwind.opcode_alloc += ARM_OPCODE_CHUNK_SIZE;
      if (unwind.opcodes)
	unwind.opcodes = xrealloc (unwind.opcodes,
				   unwind.opcode_alloc);
      else
	unwind.opcodes = xmalloc (unwind.opcode_alloc);
    }
  while (length > 0)
    {
      length--;
      unwind.opcodes[unwind.opcode_count] = op & 0xff;
      op >>= 8;
      unwind.opcode_count++;
    }
}

/* Add unwind opcodes to adjust the stack pointer.  */

static void
add_unwind_adjustsp (offsetT offset)
{
  valueT op;

  if (offset > 0x200)
    {
      /* We need at most 5 bytes to hold a 32-bit value in a uleb128.  */
      char bytes[5];
      int n;
      valueT o;

      /* Long form: 0xb2, uleb128.  */
      /* This might not fit in a word so add the individual bytes,
	 remembering the list is built in reverse order.  */
      o = (valueT) ((offset - 0x204) >> 2);
      if (o == 0)
	add_unwind_opcode (0, 1);

      /* Calculate the uleb128 encoding of the offset.	*/
      n = 0;
      while (o)
	{
	  bytes[n] = o & 0x7f;
	  o >>= 7;
	  if (o)
	    bytes[n] |= 0x80;
	  n++;
	}
      /* Add the insn.	*/
      for (; n; n--)
	add_unwind_opcode (bytes[n - 1], 1);
      add_unwind_opcode (0xb2, 1);
    }
  else if (offset > 0x100)
    {
      /* Two short opcodes.  */
      add_unwind_opcode (0x3f, 1);
      op = (offset - 0x104) >> 2;
      add_unwind_opcode (op, 1);
    }
  else if (offset > 0)
    {
      /* Short opcode.	*/
      op = (offset - 4) >> 2;
      add_unwind_opcode (op, 1);
    }
  else if (offset < 0)
    {
      offset = -offset;
      while (offset > 0x100)
	{
	  add_unwind_opcode (0x7f, 1);
	  offset -= 0x100;
	}
      op = ((offset - 4) >> 2) | 0x40;
      add_unwind_opcode (op, 1);
    }
}

/* Finish the list of unwind opcodes for this function.	 */
static void
finish_unwind_opcodes (void)
{
  valueT op;

  if (unwind.fp_used)
    {
      /* Adjust sp as necessary.  */
      unwind.pending_offset += unwind.fp_offset - unwind.frame_size;
      flush_pending_unwind ();

      /* After restoring sp from the frame pointer.  */
      op = 0x90 | unwind.fp_reg;
      add_unwind_opcode (op, 1);
    }
  else
    flush_pending_unwind ();
}


/* Start an exception table entry.  If idx is nonzero this is an index table
   entry.  */

static void
start_unwind_section (const segT text_seg, int idx)
{
  const char * text_name;
  const char * prefix;
  const char * prefix_once;
  const char * group_name;
  size_t prefix_len;
  size_t text_len;
  char * sec_name;
  size_t sec_name_len;
  int type;
  int flags;
  int linkonce;

  if (idx)
    {
      prefix = ELF_STRING_ARM_unwind;
      prefix_once = ELF_STRING_ARM_unwind_once;
      type = SHT_ARM_EXIDX;
    }
  else
    {
      prefix = ELF_STRING_ARM_unwind_info;
      prefix_once = ELF_STRING_ARM_unwind_info_once;
      type = SHT_PROGBITS;
    }

  text_name = segment_name (text_seg);
  if (streq (text_name, ".text"))
    text_name = "";

  if (strncmp (text_name, ".gnu.linkonce.t.",
	       strlen (".gnu.linkonce.t.")) == 0)
    {
      prefix = prefix_once;
      text_name += strlen (".gnu.linkonce.t.");
    }

  prefix_len = strlen (prefix);
  text_len = strlen (text_name);
  sec_name_len = prefix_len + text_len;
  sec_name = xmalloc (sec_name_len + 1);
  memcpy (sec_name, prefix, prefix_len);
  memcpy (sec_name + prefix_len, text_name, text_len);
  sec_name[prefix_len + text_len] = '\0';

  flags = SHF_ALLOC;
  linkonce = 0;
  group_name = 0;

  /* Handle COMDAT group.  */
  if (prefix != prefix_once && (text_seg->flags & SEC_LINK_ONCE) != 0)
    {
      group_name = elf_group_name (text_seg);
      if (group_name == NULL)
	{
	  as_bad ("Group section `%s' has no group signature",
		  segment_name (text_seg));
	  ignore_rest_of_line ();
	  return;
	}
      flags |= SHF_GROUP;
      linkonce = 1;
    }

  obj_elf_change_section (sec_name, type, flags, 0, group_name, linkonce, 0);

  /* Set the setion link for index tables.  */
  if (idx)
    elf_linked_to_section (now_seg) = text_seg;
}


/* Start an unwind table entry.	 HAVE_DATA is nonzero if we have additional
   personality routine data.  Returns zero, or the index table value for
   and inline entry.  */

static valueT
create_unwind_entry (int have_data)
{
  int size;
  addressT where;
  char *ptr;
  /* The current word of data.	*/
  valueT data;
  /* The number of bytes left in this word.  */
  int n;

  finish_unwind_opcodes ();

  /* Remember the current text section.	 */
  unwind.saved_seg = now_seg;
  unwind.saved_subseg = now_subseg;

  start_unwind_section (now_seg, 0);

  if (unwind.personality_routine == NULL)
    {
      if (unwind.personality_index == -2)
	{
	  if (have_data)
	    as_bad (_("handerdata in cantunwind frame"));
	  return 1; /* EXIDX_CANTUNWIND.  */
	}

      /* Use a default personality routine if none is specified.  */
      if (unwind.personality_index == -1)
	{
	  if (unwind.opcode_count > 3)
	    unwind.personality_index = 1;
	  else
	    unwind.personality_index = 0;
	}

      /* Space for the personality routine entry.  */
      if (unwind.personality_index == 0)
	{
	  if (unwind.opcode_count > 3)
	    as_bad (_("too many unwind opcodes for personality routine 0"));

	  if (!have_data)
	    {
	      /* All the data is inline in the index table.  */
	      data = 0x80;
	      n = 3;
	      while (unwind.opcode_count > 0)
		{
		  unwind.opcode_count--;
		  data = (data << 8) | unwind.opcodes[unwind.opcode_count];
		  n--;
		}

	      /* Pad with "finish" opcodes.  */
	      while (n--)
		data = (data << 8) | 0xb0;

	      return data;
	    }
	  size = 0;
	}
      else
	/* We get two opcodes "free" in the first word.	 */
	size = unwind.opcode_count - 2;
    }
  else
    /* An extra byte is required for the opcode count.	*/
    size = unwind.opcode_count + 1;

  size = (size + 3) >> 2;
  if (size > 0xff)
    as_bad (_("too many unwind opcodes"));

  frag_align (2, 0, 0);
  record_alignment (now_seg, 2);
  unwind.table_entry = expr_build_dot ();

  /* Allocate the table entry.	*/
  ptr = frag_more ((size << 2) + 4);
  where = frag_now_fix () - ((size << 2) + 4);

  switch (unwind.personality_index)
    {
    case -1:
      /* ??? Should this be a PLT generating relocation?  */
      /* Custom personality routine.  */
      fix_new (frag_now, where, 4, unwind.personality_routine, 0, 1,
	       BFD_RELOC_ARM_PREL31);

      where += 4;
      ptr += 4;

      /* Set the first byte to the number of additional words.	*/
      data = size - 1;
      n = 3;
      break;

    /* ABI defined personality routines.  */
    case 0:
      /* Three opcodes bytes are packed into the first word.  */
      data = 0x80;
      n = 3;
      break;

    case 1:
    case 2:
      /* The size and first two opcode bytes go in the first word.  */
      data = ((0x80 + unwind.personality_index) << 8) | size;
      n = 2;
      break;

    default:
      /* Should never happen.  */
      abort ();
    }

  /* Pack the opcodes into words (MSB first), reversing the list at the same
     time.  */
  while (unwind.opcode_count > 0)
    {
      if (n == 0)
	{
	  md_number_to_chars (ptr, data, 4);
	  ptr += 4;
	  n = 4;
	  data = 0;
	}
      unwind.opcode_count--;
      n--;
      data = (data << 8) | unwind.opcodes[unwind.opcode_count];
    }

  /* Finish off the last word.	*/
  if (n < 4)
    {
      /* Pad with "finish" opcodes.  */
      while (n--)
	data = (data << 8) | 0xb0;

      md_number_to_chars (ptr, data, 4);
    }

  if (!have_data)
    {
      /* Add an empty descriptor if there is no user-specified data.   */
      ptr = frag_more (4);
      md_number_to_chars (ptr, 0, 4);
    }

  return 0;
}

/* Convert REGNAME to a DWARF-2 register number.  */

int
tc_arm_regname_to_dw2regnum (const char *regname)
{
  int reg = arm_reg_parse ((char **) &regname, REG_TYPE_RN);

  if (reg == FAIL)
    return -1;

  return reg;
}

/* Initialize the DWARF-2 unwind information for this procedure.  */

void
tc_arm_frame_initial_instructions (void)
{
  cfi_add_CFA_def_cfa (REG_SP, 0);
}
#endif /* OBJ_ELF */


/* MD interface: Symbol and relocation handling.  */

/* Return the address within the segment that a PC-relative fixup is
   relative to.  For ARM, PC-relative fixups applied to instructions
   are generally relative to the location of the fixup plus 8 bytes.
   Thumb branches are offset by 4, and Thumb loads relative to PC
   require special handling.  */

long
md_pcrel_from_section (fixS * fixP, segT seg)
{
  offsetT base = fixP->fx_where + fixP->fx_frag->fr_address;

  /* If this is pc-relative and we are going to emit a relocation
     then we just want to put out any pipeline compensation that the linker
     will need.  Otherwise we want to use the calculated base.  */
  if (fixP->fx_pcrel 
      && ((fixP->fx_addsy && S_GET_SEGMENT (fixP->fx_addsy) != seg)
	  || arm_force_relocation (fixP)))
    base = 0;

  switch (fixP->fx_r_type)
    {
      /* PC relative addressing on the Thumb is slightly odd as the
	 bottom two bits of the PC are forced to zero for the
	 calculation.  This happens *after* application of the
	 pipeline offset.  However, Thumb adrl already adjusts for
	 this, so we need not do it again.  */
    case BFD_RELOC_ARM_THUMB_ADD:
      return base & ~3;

    case BFD_RELOC_ARM_THUMB_OFFSET:
    case BFD_RELOC_ARM_T32_OFFSET_IMM:
      return (base + 4) & ~3;

      /* Thumb branches are simply offset by +4.  */
    case BFD_RELOC_THUMB_PCREL_BRANCH7:
    case BFD_RELOC_THUMB_PCREL_BRANCH9:
    case BFD_RELOC_THUMB_PCREL_BRANCH12:
    case BFD_RELOC_THUMB_PCREL_BRANCH20:
    case BFD_RELOC_THUMB_PCREL_BRANCH23:
    case BFD_RELOC_THUMB_PCREL_BRANCH25:
    case BFD_RELOC_THUMB_PCREL_BLX:
      return base + 4;

      /* ARM mode branches are offset by +8.  However, the Windows CE
	 loader expects the relocation not to take this into account.  */
    case BFD_RELOC_ARM_PCREL_BRANCH:
    case BFD_RELOC_ARM_PCREL_BLX:
    case BFD_RELOC_ARM_PLT32:
#ifdef TE_WINCE
      return base;
#else
      return base + 8;
#endif

      /* ARM mode loads relative to PC are also offset by +8.  Unlike
	 branches, the Windows CE loader *does* expect the relocation
	 to take this into account.  */
    case BFD_RELOC_ARM_OFFSET_IMM:
    case BFD_RELOC_ARM_OFFSET_IMM8:
    case BFD_RELOC_ARM_HWLITERAL:
    case BFD_RELOC_ARM_LITERAL:
    case BFD_RELOC_ARM_CP_OFF_IMM:
      return base + 8;


      /* Other PC-relative relocations are un-offset.  */
    default:
      return base;
    }
}

/* Under ELF we need to default _GLOBAL_OFFSET_TABLE.
   Otherwise we have no need to default values of symbols.  */

symbolS *
md_undefined_symbol (char * name ATTRIBUTE_UNUSED)
{
#ifdef OBJ_ELF
  if (name[0] == '_' && name[1] == 'G'
      && streq (name, GLOBAL_OFFSET_TABLE_NAME))
    {
      if (!GOT_symbol)
	{
	  if (symbol_find (name))
	    as_bad ("GOT already in the symbol table");

	  GOT_symbol = symbol_new (name, undefined_section,
				   (valueT) 0, & zero_address_frag);
	}

      return GOT_symbol;
    }
#endif

  return 0;
}

/* Subroutine of md_apply_fix.	 Check to see if an immediate can be
   computed as two separate immediate values, added together.  We
   already know that this value cannot be computed by just one ARM
   instruction.	 */

static unsigned int
validate_immediate_twopart (unsigned int   val,
			    unsigned int * highpart)
{
  unsigned int a;
  unsigned int i;

  for (i = 0; i < 32; i += 2)
    if (((a = rotate_left (val, i)) & 0xff) != 0)
      {
	if (a & 0xff00)
	  {
	    if (a & ~ 0xffff)
	      continue;
	    * highpart = (a  >> 8) | ((i + 24) << 7);
	  }
	else if (a & 0xff0000)
	  {
	    if (a & 0xff000000)
	      continue;
	    * highpart = (a >> 16) | ((i + 16) << 7);
	  }
	else
	  {
	    assert (a & 0xff000000);
	    * highpart = (a >> 24) | ((i + 8) << 7);
	  }

	return (a & 0xff) | (i << 7);
      }

  return FAIL;
}

static int
validate_offset_imm (unsigned int val, int hwse)
{
  if ((hwse && val > 255) || val > 4095)
    return FAIL;
  return val;
}

/* Subroutine of md_apply_fix.	 Do those data_ops which can take a
   negative immediate constant by altering the instruction.  A bit of
   a hack really.
	MOV <-> MVN
	AND <-> BIC
	ADC <-> SBC
	by inverting the second operand, and
	ADD <-> SUB
	CMP <-> CMN
	by negating the second operand.	 */

static int
negate_data_op (unsigned long * instruction,
		unsigned long	value)
{
  int op, new_inst;
  unsigned long negated, inverted;

  negated = encode_arm_immediate (-value);
  inverted = encode_arm_immediate (~value);

  op = (*instruction >> DATA_OP_SHIFT) & 0xf;
  switch (op)
    {
      /* First negates.	 */
    case OPCODE_SUB:		 /* ADD <-> SUB	 */
      new_inst = OPCODE_ADD;
      value = negated;
      break;

    case OPCODE_ADD:
      new_inst = OPCODE_SUB;
      value = negated;
      break;

    case OPCODE_CMP:		 /* CMP <-> CMN	 */
      new_inst = OPCODE_CMN;
      value = negated;
      break;

    case OPCODE_CMN:
      new_inst = OPCODE_CMP;
      value = negated;
      break;

      /* Now Inverted ops.  */
    case OPCODE_MOV:		 /* MOV <-> MVN	 */
      new_inst = OPCODE_MVN;
      value = inverted;
      break;

    case OPCODE_MVN:
      new_inst = OPCODE_MOV;
      value = inverted;
      break;

    case OPCODE_AND:		 /* AND <-> BIC	 */
      new_inst = OPCODE_BIC;
      value = inverted;
      break;

    case OPCODE_BIC:
      new_inst = OPCODE_AND;
      value = inverted;
      break;

    case OPCODE_ADC:		  /* ADC <-> SBC  */
      new_inst = OPCODE_SBC;
      value = inverted;
      break;

    case OPCODE_SBC:
      new_inst = OPCODE_ADC;
      value = inverted;
      break;

      /* We cannot do anything.	 */
    default:
      return FAIL;
    }

  if (value == (unsigned) FAIL)
    return FAIL;

  *instruction &= OPCODE_MASK;
  *instruction |= new_inst << DATA_OP_SHIFT;
  return value;
}

void
md_apply_fix (fixS *	fixP,
	       valueT * valP,
	       segT	seg)
{
  offsetT	 value = * valP;
  offsetT	 newval;
  unsigned int	 newimm;
  unsigned long	 temp;
  int		 sign;
  char *	 buf = fixP->fx_where + fixP->fx_frag->fr_literal;

  assert (fixP->fx_r_type <= BFD_RELOC_UNUSED);

  /* Note whether this will delete the relocation.  */
  if (fixP->fx_addsy == 0 && !fixP->fx_pcrel)
    fixP->fx_done = 1;

  /* On a 64-bit host, silently truncate 'value' to 32 bits for
     consistency with the behavior on 32-bit hosts.  Remember value
     for emit_reloc.  */
  value &= 0xffffffff;
  value ^= 0x80000000;
  value -= 0x80000000; 

  *valP = value;
  fixP->fx_addnumber = value;

  /* Same treatment for fixP->fx_offset.  */
  fixP->fx_offset &= 0xffffffff;
  fixP->fx_offset ^= 0x80000000;
  fixP->fx_offset -= 0x80000000;

  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_NONE:
      /* This will need to go in the object file.  */
      fixP->fx_done = 0;
      break;

    case BFD_RELOC_ARM_IMMEDIATE:
      /* We claim that this fixup has been processed here,
	 even if in fact we generate an error because we do
	 not have a reloc for it, so tc_gen_reloc will reject it.  */
      fixP->fx_done = 1;

      if (fixP->fx_addsy
	  && ! S_IS_DEFINED (fixP->fx_addsy))
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("undefined symbol %s used as an immediate value"),
			S_GET_NAME (fixP->fx_addsy));
	  break;
	}

      newimm = encode_arm_immediate (value);
      temp = md_chars_to_number (buf, INSN_SIZE);

      /* If the instruction will fail, see if we can fix things up by
	 changing the opcode.  */
      if (newimm == (unsigned int) FAIL
	  && (newimm = negate_data_op (&temp, value)) == (unsigned int) FAIL)
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("invalid constant (%lx) after fixup"),
			(unsigned long) value);
	  break;
	}

      newimm |= (temp & 0xfffff000);
      md_number_to_chars (buf, (valueT) newimm, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_ADRL_IMMEDIATE:
      {
	unsigned int highpart = 0;
	unsigned int newinsn  = 0xe1a00000; /* nop.  */

	newimm = encode_arm_immediate (value);
	temp = md_chars_to_number (buf, INSN_SIZE);

	/* If the instruction will fail, see if we can fix things up by
	   changing the opcode.	 */
	if (newimm == (unsigned int) FAIL
	    && (newimm = negate_data_op (& temp, value)) == (unsigned int) FAIL)
	  {
	    /* No ?  OK - try using two ADD instructions to generate
	       the value.  */
	    newimm = validate_immediate_twopart (value, & highpart);

	    /* Yes - then make sure that the second instruction is
	       also an add.  */
	    if (newimm != (unsigned int) FAIL)
	      newinsn = temp;
	    /* Still No ?  Try using a negated value.  */
	    else if ((newimm = validate_immediate_twopart (- value, & highpart)) != (unsigned int) FAIL)
	      temp = newinsn = (temp & OPCODE_MASK) | OPCODE_SUB << DATA_OP_SHIFT;
	    /* Otherwise - give up.  */
	    else
	      {
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("unable to compute ADRL instructions for PC offset of 0x%lx"),
			      (long) value);
		break;
	      }

	    /* Replace the first operand in the 2nd instruction (which
	       is the PC) with the destination register.  We have
	       already added in the PC in the first instruction and we
	       do not want to do it again.  */
	    newinsn &= ~ 0xf0000;
	    newinsn |= ((newinsn & 0x0f000) << 4);
	  }

	newimm |= (temp & 0xfffff000);
	md_number_to_chars (buf, (valueT) newimm, INSN_SIZE);

	highpart |= (newinsn & 0xfffff000);
	md_number_to_chars (buf + INSN_SIZE, (valueT) highpart, INSN_SIZE);
      }
      break;

    case BFD_RELOC_ARM_OFFSET_IMM:
    case BFD_RELOC_ARM_LITERAL:
      sign = value >= 0;

      if (value < 0)
	value = - value;

      if (validate_offset_imm (value, 0) == FAIL)
	{
	  if (fixP->fx_r_type == BFD_RELOC_ARM_LITERAL)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid literal constant: pool needs to be closer"));
	  else
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("bad immediate value for offset (%ld)"),
			  (long) value);
	  break;
	}

      newval = md_chars_to_number (buf, INSN_SIZE);
      newval &= 0xff7ff000;
      newval |= value | (sign ? INDEX_UP : 0);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_OFFSET_IMM8:
    case BFD_RELOC_ARM_HWLITERAL:
      sign = value >= 0;

      if (value < 0)
	value = - value;

      if (validate_offset_imm (value, 1) == FAIL)
	{
	  if (fixP->fx_r_type == BFD_RELOC_ARM_HWLITERAL)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid literal constant: pool needs to be closer"));
	  else
	    as_bad (_("bad immediate value for half-word offset (%ld)"),
		    (long) value);
	  break;
	}

      newval = md_chars_to_number (buf, INSN_SIZE);
      newval &= 0xff7ff0f0;
      newval |= ((value >> 4) << 8) | (value & 0xf) | (sign ? INDEX_UP : 0);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_T32_OFFSET_U8:
      if (value < 0 || value > 1020 || value % 4 != 0)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("bad immediate value for offset (%ld)"), (long) value);
      value /= 4;

      newval = md_chars_to_number (buf+2, THUMB_SIZE);
      newval |= value;
      md_number_to_chars (buf+2, newval, THUMB_SIZE);
      break;

    case BFD_RELOC_ARM_T32_OFFSET_IMM:
      /* This is a complicated relocation used for all varieties of Thumb32
	 load/store instruction with immediate offset:

	 1110 100P u1WL NNNN XXXX YYYY iiii iiii - +/-(U) pre/post(P) 8-bit,
	                                           *4, optional writeback(W)
						   (doubleword load/store)

	 1111 100S uTTL 1111 XXXX iiii iiii iiii - +/-(U) 12-bit PC-rel
	 1111 100S 0TTL NNNN XXXX 1Pu1 iiii iiii - +/-(U) pre/post(P) 8-bit
	 1111 100S 0TTL NNNN XXXX 1110 iiii iiii - positive 8-bit (T instruction)
	 1111 100S 1TTL NNNN XXXX iiii iiii iiii - positive 12-bit
	 1111 100S 0TTL NNNN XXXX 1100 iiii iiii - negative 8-bit

	 Uppercase letters indicate bits that are already encoded at
	 this point.  Lowercase letters are our problem.  For the
	 second block of instructions, the secondary opcode nybble
	 (bits 8..11) is present, and bit 23 is zero, even if this is
	 a PC-relative operation.  */
      newval = md_chars_to_number (buf, THUMB_SIZE);
      newval <<= 16;
      newval |= md_chars_to_number (buf+THUMB_SIZE, THUMB_SIZE);

      if ((newval & 0xf0000000) == 0xe0000000)
	{
	  /* Doubleword load/store: 8-bit offset, scaled by 4.  */
	  if (value >= 0)
	    newval |= (1 << 23);
	  else
	    value = -value;
	  if (value % 4 != 0)
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("offset not a multiple of 4"));
	      break;
	    }
	  value /= 4;
	  if (value >= 0xff)
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("offset out of range"));
	      break;
	    }
	  newval &= ~0xff;
	}
      else if ((newval & 0x000f0000) == 0x000f0000)
	{
	  /* PC-relative, 12-bit offset.  */
	  if (value >= 0)
	    newval |= (1 << 23);
	  else
	    value = -value;
	  if (value >= 0xfff)
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("offset out of range"));
	      break;
	    }
	  newval &= ~0xfff;
	}
      else if ((newval & 0x00000100) == 0x00000100)
	{
	  /* Writeback: 8-bit, +/- offset.  */
	  if (value >= 0)
	    newval |= (1 << 9);
	  else
	    value = -value;
	  if (value >= 0xff)
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("offset out of range"));
	      break;
	    }
	  newval &= ~0xff;
	}
      else if ((newval & 0x00000f00) == 0x00000e00)
	{
	  /* T-instruction: positive 8-bit offset.  */
	  if (value < 0 || value >= 0xff)
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("offset out of range"));
	      break;
	    }
	  newval &= ~0xff;
	  newval |= value;
	}
      else
	{
	  /* Positive 12-bit or negative 8-bit offset.  */
	  int limit;
	  if (value >= 0)
	    {
	      newval |= (1 << 23);
	      limit = 0xfff;
	    }
	  else
	    {
	      value = -value;
	      limit = 0xff;
	    }
	  if (value > limit)
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("offset out of range"));
	      break;
	    }
	  newval &= ~limit;
	}

      newval |= value;
      md_number_to_chars (buf, (newval >> 16) & 0xffff, THUMB_SIZE);
      md_number_to_chars (buf + THUMB_SIZE, newval & 0xffff, THUMB_SIZE);
      break;

    case BFD_RELOC_ARM_SHIFT_IMM:
      newval = md_chars_to_number (buf, INSN_SIZE);
      if (((unsigned long) value) > 32
	  || (value == 32
	      && (((newval & 0x60) == 0) || (newval & 0x60) == 0x60)))
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("shift expression is too large"));
	  break;
	}

      if (value == 0)
	/* Shifts of zero must be done as lsl.	*/
	newval &= ~0x60;
      else if (value == 32)
	value = 0;
      newval &= 0xfffff07f;
      newval |= (value & 0x1f) << 7;
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_T32_IMMEDIATE:
      /* We claim that this fixup has been processed here,
	 even if in fact we generate an error because we do
	 not have a reloc for it, so tc_gen_reloc will reject it.  */
      fixP->fx_done = 1;

      if (fixP->fx_addsy
	  && ! S_IS_DEFINED (fixP->fx_addsy))
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("undefined symbol %s used as an immediate value"),
			S_GET_NAME (fixP->fx_addsy));
	  break;
	}

      newval = md_chars_to_number (buf, THUMB_SIZE);
      newval <<= 16;
      newval |= md_chars_to_number (buf+2, THUMB_SIZE);

      newimm = encode_thumb32_immediate (value);

      /* FUTURE: Implement analogue of negate_data_op for T32.  */
      if (newimm == (unsigned int)FAIL)
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("invalid constant (%lx) after fixup"),
			(unsigned long) value);
	  break;
	}

      newval |= (newimm & 0x800) << 15;
      newval |= (newimm & 0x700) << 4;
      newval |= (newimm & 0x0ff);

      md_number_to_chars (buf,   (valueT) ((newval >> 16) & 0xffff), THUMB_SIZE);
      md_number_to_chars (buf+2, (valueT) (newval & 0xffff), THUMB_SIZE);
      break;

    case BFD_RELOC_ARM_SMI:
      if (((unsigned long) value) > 0xffff)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("invalid smi expression"));
      newval = md_chars_to_number (buf, INSN_SIZE);
      newval |= (value & 0xf) | ((value & 0xfff0) << 4);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_SWI:
      if (fixP->tc_fix_data != 0)
	{
	  if (((unsigned long) value) > 0xff)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid swi expression"));
	  newval = md_chars_to_number (buf, THUMB_SIZE);
	  newval |= value;
	  md_number_to_chars (buf, newval, THUMB_SIZE);
	}
      else
	{
	  if (((unsigned long) value) > 0x00ffffff)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid swi expression"));
	  newval = md_chars_to_number (buf, INSN_SIZE);
	  newval |= value;
	  md_number_to_chars (buf, newval, INSN_SIZE);
	}
      break;

    case BFD_RELOC_ARM_MULTI:
      if (((unsigned long) value) > 0xffff)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("invalid expression in load/store multiple"));
      newval = value | md_chars_to_number (buf, INSN_SIZE);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_PCREL_BRANCH:
#ifdef OBJ_ELF
    case BFD_RELOC_ARM_PLT32:
#endif

      /* We are going to store value (shifted right by two) in the
	 instruction, in a 24 bit, signed field.  Bits 0 and 1 must be
	 clear, and bits 26 through 32 either all clear or all set. */
      if (value & 0x00000003)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("misaligned branch destination"));
      if ((value & (offsetT)0xfe000000) != (offsetT)0
	  && (value & (offsetT)0xfe000000) != (offsetT)0xfe000000)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("branch out of range"));

      if (fixP->fx_done || !seg->use_rela_p)
	{
	  newval = md_chars_to_number (buf, INSN_SIZE);
	  newval |= (value >> 2) & 0x00ffffff;
	  md_number_to_chars (buf, newval, INSN_SIZE);
	}
      break;

    case BFD_RELOC_ARM_PCREL_BLX:
      /* BLX allows bit 1 to be set in the branch destination, since
	 it targets a Thumb instruction which is only required to be
	 aligned modulo 2.  Other constraints are as for B/BL.  */
      if (value & 0x00000001)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("misaligned BLX destination"));
      if ((value & (offsetT)0xfe000000) != (offsetT)0
	  && (value & (offsetT)0xfe000000) != (offsetT)0xfe000000)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("branch out of range"));

      if (fixP->fx_done || !seg->use_rela_p)
	{
	  offsetT hbit;
	  hbit   = (value >> 1) & 1;
	  value  = (value >> 2) & 0x00ffffff;

	  newval = md_chars_to_number (buf, INSN_SIZE);
	  newval |= value | hbit << 24;
	  md_number_to_chars (buf, newval, INSN_SIZE);
	}
      break;

    case BFD_RELOC_THUMB_PCREL_BRANCH7: /* CZB */
      /* CZB can only branch forward.  */
      if (value & ~0x7e)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("branch out of range"));

      if (fixP->fx_done || !seg->use_rela_p)
	{
	  newval = md_chars_to_number (buf, THUMB_SIZE);
	  newval |= ((value & 0x2e) << 2) | ((value & 0x40) << 3);
	  md_number_to_chars (buf, newval, THUMB_SIZE);
	}
      break;

    case BFD_RELOC_THUMB_PCREL_BRANCH9: /* Conditional branch.	*/
      if ((value & ~0xff) && ((value & ~0xff) != ~0xff))
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("branch out of range"));

      if (fixP->fx_done || !seg->use_rela_p)
	{
	  newval = md_chars_to_number (buf, THUMB_SIZE);
	  newval |= (value & 0x1ff) >> 1;
	  md_number_to_chars (buf, newval, THUMB_SIZE);
	}
      break;

    case BFD_RELOC_THUMB_PCREL_BRANCH12: /* Unconditional branch.  */
      if ((value & ~0x7ff) && ((value & ~0x7ff) != ~0x7ff))
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("branch out of range"));

      if (fixP->fx_done || !seg->use_rela_p)
	{
	  newval = md_chars_to_number (buf, THUMB_SIZE);
	  newval |= (value & 0xfff) >> 1;
	  md_number_to_chars (buf, newval, THUMB_SIZE);
	}
      break;

    case BFD_RELOC_THUMB_PCREL_BRANCH20:
      if ((value & ~0x1fffff) && ((value & ~0x1fffff) != ~0x1fffff))
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("conditional branch out of range"));

      if (fixP->fx_done || !seg->use_rela_p)
	{
	  offsetT newval2;
	  addressT S, J1, J2, lo, hi;

	  S  = (value & 0x00100000) >> 20;
	  J2 = (value & 0x00080000) >> 19;
	  J1 = (value & 0x00040000) >> 18;
	  hi = (value & 0x0003f000) >> 12;
	  lo = (value & 0x00000ffe) >> 1;

	  newval   = md_chars_to_number (buf, THUMB_SIZE);
	  newval2  = md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);
	  newval  |= (S << 10) | hi;
	  newval2 |= (J1 << 13) | (J2 << 11) | lo;
	  md_number_to_chars (buf, newval, THUMB_SIZE);
	  md_number_to_chars (buf + THUMB_SIZE, newval2, THUMB_SIZE);
	}
      break;

    case BFD_RELOC_THUMB_PCREL_BLX:
    case BFD_RELOC_THUMB_PCREL_BRANCH23:
      if ((value & ~0x3fffff) && ((value & ~0x3fffff) != ~0x3fffff))
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("branch out of range"));

      if (fixP->fx_r_type == BFD_RELOC_THUMB_PCREL_BLX)
	/* For a BLX instruction, make sure that the relocation is rounded up
	   to a word boundary.  This follows the semantics of the instruction
	   which specifies that bit 1 of the target address will come from bit
	   1 of the base address.  */
	value = (value + 1) & ~ 1;

      if (fixP->fx_done || !seg->use_rela_p)
	{
	  offsetT newval2;

	  newval   = md_chars_to_number (buf, THUMB_SIZE);
	  newval2  = md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);
	  newval  |= (value & 0x7fffff) >> 12;
	  newval2 |= (value & 0xfff) >> 1;
	  md_number_to_chars (buf, newval, THUMB_SIZE);
	  md_number_to_chars (buf + THUMB_SIZE, newval2, THUMB_SIZE);
	}
      break;

    case BFD_RELOC_THUMB_PCREL_BRANCH25:
      if ((value & ~0x1ffffff) && ((value & ~0x1ffffff) != ~0x1ffffff))
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("branch out of range"));

      if (fixP->fx_done || !seg->use_rela_p)
	{
	  offsetT newval2;
	  addressT S, I1, I2, lo, hi;

	  S  = (value & 0x01000000) >> 24;
	  I1 = (value & 0x00800000) >> 23;
	  I2 = (value & 0x00400000) >> 22;
	  hi = (value & 0x003ff000) >> 12;
	  lo = (value & 0x00000ffe) >> 1;

	  I1 = !(I1 ^ S);
	  I2 = !(I2 ^ S);

	  newval   = md_chars_to_number (buf, THUMB_SIZE);
	  newval2  = md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);
	  newval  |= (S << 10) | hi;
	  newval2 |= (I1 << 13) | (I2 << 11) | lo;
	  md_number_to_chars (buf, newval, THUMB_SIZE);
	  md_number_to_chars (buf + THUMB_SIZE, newval2, THUMB_SIZE);
	}
      break;

    case BFD_RELOC_8:
      if (fixP->fx_done || !seg->use_rela_p)
	md_number_to_chars (buf, value, 1);
      break;

    case BFD_RELOC_16:
      if (fixP->fx_done || !seg->use_rela_p)
	md_number_to_chars (buf, value, 2);
      break;

#ifdef OBJ_ELF
    case BFD_RELOC_ARM_TLS_GD32:
    case BFD_RELOC_ARM_TLS_LE32:
    case BFD_RELOC_ARM_TLS_IE32:
    case BFD_RELOC_ARM_TLS_LDM32:
    case BFD_RELOC_ARM_TLS_LDO32:
      S_SET_THREAD_LOCAL (fixP->fx_addsy);
      /* fall through */

    case BFD_RELOC_ARM_GOT32:
    case BFD_RELOC_ARM_GOTOFF:
    case BFD_RELOC_ARM_TARGET2:
      if (fixP->fx_done || !seg->use_rela_p)
	md_number_to_chars (buf, 0, 4);
      break;
#endif

    case BFD_RELOC_RVA:
    case BFD_RELOC_32:
    case BFD_RELOC_ARM_TARGET1:
    case BFD_RELOC_ARM_ROSEGREL32:
    case BFD_RELOC_ARM_SBREL32:
    case BFD_RELOC_32_PCREL:
      if (fixP->fx_done || !seg->use_rela_p)
	md_number_to_chars (buf, value, 4);
      break;

#ifdef OBJ_ELF
    case BFD_RELOC_ARM_PREL31:
      if (fixP->fx_done || !seg->use_rela_p)
	{
	  newval = md_chars_to_number (buf, 4) & 0x80000000;
	  if ((value ^ (value >> 1)) & 0x40000000)
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("rel31 relocation overflow"));
	    }
	  newval |= value & 0x7fffffff;
	  md_number_to_chars (buf, newval, 4);
	}
      break;
#endif

    case BFD_RELOC_ARM_CP_OFF_IMM:
      if (value < -1023 || value > 1023 || (value & 3))
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("co-processor offset out of range"));
    cp_off_common:
      sign = value >= 0;
      if (value < 0)
	value = -value;
      newval = md_chars_to_number (buf, INSN_SIZE) & 0xff7fff00;
      newval |= (value >> 2) | (sign ? INDEX_UP : 0);
      if (value == 0)
	newval &= ~WRITE_BACK;
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_CP_OFF_IMM_S2:
      if (value < -255 || value > 255)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("co-processor offset out of range"));
      goto cp_off_common;

    case BFD_RELOC_ARM_THUMB_OFFSET:
      newval = md_chars_to_number (buf, THUMB_SIZE);
      /* Exactly what ranges, and where the offset is inserted depends
	 on the type of instruction, we can establish this from the
	 top 4 bits.  */
      switch (newval >> 12)
	{
	case 4: /* PC load.  */
	  /* Thumb PC loads are somewhat odd, bit 1 of the PC is
	     forced to zero for these loads; md_pcrel_from has already
	     compensated for this.  */
	  if (value & 3)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, target not word aligned (0x%08lX)"),
			  (((unsigned int) fixP->fx_frag->fr_address
			    + (unsigned int) fixP->fx_where) & ~3) + value);

	  if (value & ~0x3fc)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);

	  newval |= value >> 2;
	  break;

	case 9: /* SP load/store.  */
	  if (value & ~0x3fc)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
	  newval |= value >> 2;
	  break;

	case 6: /* Word load/store.  */
	  if (value & ~0x7c)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
	  newval |= value << 4; /* 6 - 2.  */
	  break;

	case 7: /* Byte load/store.  */
	  if (value & ~0x1f)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
	  newval |= value << 6;
	  break;

	case 8: /* Halfword load/store.	 */
	  if (value & ~0x3e)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
	  newval |= value << 5; /* 6 - 1.  */
	  break;

	default:
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			"Unable to process relocation for thumb opcode: %lx",
			(unsigned long) newval);
	  break;
	}
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;

    case BFD_RELOC_ARM_THUMB_ADD:
      /* This is a complicated relocation, since we use it for all of
	 the following immediate relocations:

	    3bit ADD/SUB
	    8bit ADD/SUB
	    9bit ADD/SUB SP word-aligned
	   10bit ADD PC/SP word-aligned

	 The type of instruction being processed is encoded in the
	 instruction field:

	   0x8000  SUB
	   0x00F0  Rd
	   0x000F  Rs
      */
      newval = md_chars_to_number (buf, THUMB_SIZE);
      {
	int rd = (newval >> 4) & 0xf;
	int rs = newval & 0xf;
	int subtract = !!(newval & 0x8000);

	/* Check for HI regs, only very restricted cases allowed:
	   Adjusting SP, and using PC or SP to get an address.	*/
	if ((rd > 7 && (rd != REG_SP || rs != REG_SP))
	    || (rs > 7 && rs != REG_SP && rs != REG_PC))
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("invalid Hi register with immediate"));

	/* If value is negative, choose the opposite instruction.  */
	if (value < 0)
	  {
	    value = -value;
	    subtract = !subtract;
	    if (value < 0)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("immediate value out of range"));
	  }

	if (rd == REG_SP)
	  {
	    if (value & ~0x1fc)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("invalid immediate for stack address calculation"));
	    newval = subtract ? T_OPCODE_SUB_ST : T_OPCODE_ADD_ST;
	    newval |= value >> 2;
	  }
	else if (rs == REG_PC || rs == REG_SP)
	  {
	    if (subtract || value & ~0x3fc)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("invalid immediate for address calculation (value = 0x%08lX)"),
			    (unsigned long) value);
	    newval = (rs == REG_PC ? T_OPCODE_ADD_PC : T_OPCODE_ADD_SP);
	    newval |= rd << 8;
	    newval |= value >> 2;
	  }
	else if (rs == rd)
	  {
	    if (value & ~0xff)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("immediate value out of range"));
	    newval = subtract ? T_OPCODE_SUB_I8 : T_OPCODE_ADD_I8;
	    newval |= (rd << 8) | value;
	  }
	else
	  {
	    if (value & ~0x7)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("immediate value out of range"));
	    newval = subtract ? T_OPCODE_SUB_I3 : T_OPCODE_ADD_I3;
	    newval |= rd | (rs << 3) | (value << 6);
	  }
      }
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;

    case BFD_RELOC_ARM_THUMB_IMM:
      newval = md_chars_to_number (buf, THUMB_SIZE);
      if (value < 0 || value > 255)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("invalid immediate: %ld is too large"),
		      (long) value);
      newval |= value;
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;

    case BFD_RELOC_ARM_THUMB_SHIFT:
      /* 5bit shift value (0..32).  LSL cannot take 32.	 */
      newval = md_chars_to_number (buf, THUMB_SIZE) & 0xf83f;
      temp = newval & 0xf800;
      if (value < 0 || value > 32 || (value == 32 && temp == T_OPCODE_LSL_I))
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("invalid shift value: %ld"), (long) value);
      /* Shifts of zero must be encoded as LSL.	 */
      if (value == 0)
	newval = (newval & 0x003f) | T_OPCODE_LSL_I;
      /* Shifts of 32 are encoded as zero.  */
      else if (value == 32)
	value = 0;
      newval |= value << 6;
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;

    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      fixP->fx_done = 0;
      return;

    case BFD_RELOC_UNUSED:
    default:
      as_bad_where (fixP->fx_file, fixP->fx_line,
		    _("bad relocation fixup type (%d)"), fixP->fx_r_type);
    }
}

/* Translate internal representation of relocation info to BFD target
   format.  */

arelent *
tc_gen_reloc (asection * section ATTRIBUTE_UNUSED,
	      fixS *	 fixp)
{
  arelent * reloc;
  bfd_reloc_code_real_type code;

  reloc = xmalloc (sizeof (arelent));

  reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;

  if (fixp->fx_pcrel)
    fixp->fx_offset = reloc->address;
  reloc->addend = fixp->fx_offset;

  switch (fixp->fx_r_type)
    {
    case BFD_RELOC_8:
      if (fixp->fx_pcrel)
	{
	  code = BFD_RELOC_8_PCREL;
	  break;
	}

    case BFD_RELOC_16:
      if (fixp->fx_pcrel)
	{
	  code = BFD_RELOC_16_PCREL;
	  break;
	}

    case BFD_RELOC_32:
      if (fixp->fx_pcrel)
	{
	  code = BFD_RELOC_32_PCREL;
	  break;
	}

    case BFD_RELOC_NONE:
    case BFD_RELOC_ARM_PCREL_BRANCH:
    case BFD_RELOC_ARM_PCREL_BLX:
    case BFD_RELOC_RVA:
    case BFD_RELOC_THUMB_PCREL_BRANCH7:
    case BFD_RELOC_THUMB_PCREL_BRANCH9:
    case BFD_RELOC_THUMB_PCREL_BRANCH12:
    case BFD_RELOC_THUMB_PCREL_BRANCH20:
    case BFD_RELOC_THUMB_PCREL_BRANCH23:
    case BFD_RELOC_THUMB_PCREL_BRANCH25:
    case BFD_RELOC_THUMB_PCREL_BLX:
    case BFD_RELOC_VTABLE_ENTRY:
    case BFD_RELOC_VTABLE_INHERIT:
      code = fixp->fx_r_type;
      break;

    case BFD_RELOC_ARM_LITERAL:
    case BFD_RELOC_ARM_HWLITERAL:
      /* If this is called then the a literal has
	 been referenced across a section boundary.  */
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("literal referenced across section boundary"));
      return NULL;

#ifdef OBJ_ELF
    case BFD_RELOC_ARM_GOT32:
    case BFD_RELOC_ARM_GOTOFF:
    case BFD_RELOC_ARM_PLT32:
    case BFD_RELOC_ARM_TARGET1:
    case BFD_RELOC_ARM_ROSEGREL32:
    case BFD_RELOC_ARM_SBREL32:
    case BFD_RELOC_ARM_PREL31:
    case BFD_RELOC_ARM_TARGET2:
    case BFD_RELOC_ARM_TLS_LE32:
    case BFD_RELOC_ARM_TLS_LDO32:
      code = fixp->fx_r_type;
      break;

    case BFD_RELOC_ARM_TLS_GD32:
    case BFD_RELOC_ARM_TLS_IE32:
    case BFD_RELOC_ARM_TLS_LDM32:
      /* BFD will include the symbol's address in the addend.
	 But we don't want that, so subtract it out again here.  */
      if (!S_IS_COMMON (fixp->fx_addsy))
	reloc->addend -= (*reloc->sym_ptr_ptr)->value;
      code = fixp->fx_r_type;
      break;
#endif

    case BFD_RELOC_ARM_IMMEDIATE:
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("internal relocation (type: IMMEDIATE) not fixed up"));
      return NULL;

    case BFD_RELOC_ARM_ADRL_IMMEDIATE:
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("ADRL used for a symbol not defined in the same file"));
      return NULL;

    case BFD_RELOC_ARM_OFFSET_IMM:
      if (fixp->fx_addsy != NULL
	  && !S_IS_DEFINED (fixp->fx_addsy)
	  && S_IS_LOCAL (fixp->fx_addsy))
	{
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			_("undefined local label `%s'"),
			S_GET_NAME (fixp->fx_addsy));
	  return NULL;
	}

      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("internal_relocation (type: OFFSET_IMM) not fixed up"));
      return NULL;

    default:
      {
	char * type;

	switch (fixp->fx_r_type)
	  {
	  case BFD_RELOC_NONE:		   type = "NONE";	  break;
	  case BFD_RELOC_ARM_OFFSET_IMM8:  type = "OFFSET_IMM8";  break;
	  case BFD_RELOC_ARM_SHIFT_IMM:	   type = "SHIFT_IMM";	  break;
	  case BFD_RELOC_ARM_SMI:	   type = "SMI";	  break;
	  case BFD_RELOC_ARM_SWI:	   type = "SWI";	  break;
	  case BFD_RELOC_ARM_MULTI:	   type = "MULTI";	  break;
	  case BFD_RELOC_ARM_CP_OFF_IMM:   type = "CP_OFF_IMM";	  break;
	  case BFD_RELOC_ARM_THUMB_ADD:	   type = "THUMB_ADD";	  break;
	  case BFD_RELOC_ARM_THUMB_SHIFT:  type = "THUMB_SHIFT";  break;
	  case BFD_RELOC_ARM_THUMB_IMM:	   type = "THUMB_IMM";	  break;
	  case BFD_RELOC_ARM_THUMB_OFFSET: type = "THUMB_OFFSET"; break;
	  default:			   type = _("<unknown>"); break;
	  }
	as_bad_where (fixp->fx_file, fixp->fx_line,
		      _("cannot represent %s relocation in this object file format"),
		      type);
	return NULL;
      }
    }

#ifdef OBJ_ELF
  if ((code == BFD_RELOC_32_PCREL || code == BFD_RELOC_32)
      && GOT_symbol
      && fixp->fx_addsy == GOT_symbol)
    {
      code = BFD_RELOC_ARM_GOTPC;
      reloc->addend = fixp->fx_offset = reloc->address;
    }
#endif

  reloc->howto = bfd_reloc_type_lookup (stdoutput, code);

  if (reloc->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("cannot represent %s relocation in this object file format"),
		    bfd_get_reloc_code_name (code));
      return NULL;
    }

  /* HACK: Since arm ELF uses Rel instead of Rela, encode the
     vtable entry to be used in the relocation's section offset.  */
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    reloc->address = fixp->fx_offset;

  return reloc;
}

/* This fix_new is called by cons via TC_CONS_FIX_NEW.	*/

void
cons_fix_new_arm (fragS *	frag,
		  int		where,
		  int		size,
		  expressionS * exp)
{
  bfd_reloc_code_real_type type;
  int pcrel = 0;

  /* Pick a reloc.
     FIXME: @@@@ Should look at CPU word size.  */
  switch (size)
    {
    case 1:
      type = BFD_RELOC_8;
      break;
    case 2:
      type = BFD_RELOC_16;
      break;
    case 4:
    default:
      type = BFD_RELOC_32;
      break;
    case 8:
      type = BFD_RELOC_64;
      break;
    }

  fix_new_exp (frag, where, (int) size, exp, pcrel, type);
}

#if defined OBJ_COFF || defined OBJ_ELF
void
arm_validate_fix (fixS * fixP)
{
  /* If the destination of the branch is a defined symbol which does not have
     the THUMB_FUNC attribute, then we must be calling a function which has
     the (interfacearm) attribute.  We look for the Thumb entry point to that
     function and change the branch to refer to that function instead.	*/
  if (fixP->fx_r_type == BFD_RELOC_THUMB_PCREL_BRANCH23
      && fixP->fx_addsy != NULL
      && S_IS_DEFINED (fixP->fx_addsy)
      && ! THUMB_IS_FUNC (fixP->fx_addsy))
    {
      fixP->fx_addsy = find_real_start (fixP->fx_addsy);
    }
}
#endif

int
arm_force_relocation (struct fix * fixp)
{
#if defined (OBJ_COFF) && defined (TE_PE)
  if (fixp->fx_r_type == BFD_RELOC_RVA)
    return 1;
#endif

  /* Resolve these relocations even if the symbol is extern or weak.  */
  if (fixp->fx_r_type == BFD_RELOC_ARM_IMMEDIATE
      || fixp->fx_r_type == BFD_RELOC_ARM_OFFSET_IMM
      || fixp->fx_r_type == BFD_RELOC_ARM_ADRL_IMMEDIATE)
    return 0;

  return generic_force_reloc (fixp);
}

#ifdef OBJ_COFF
/* This is a little hack to help the gas/arm/adrl.s test.  It prevents
   local labels from being added to the output symbol table when they
   are used with the ADRL pseudo op.  The ADRL relocation should always
   be resolved before the binbary is emitted, so it is safe to say that
   it is adjustable.  */

bfd_boolean
arm_fix_adjustable (fixS * fixP)
{
  if (fixP->fx_r_type == BFD_RELOC_ARM_ADRL_IMMEDIATE)
    return 1;
  return 0;
}
#endif

#ifdef OBJ_ELF
/* Relocations against Thumb function names must be left unadjusted,
   so that the linker can use this information to correctly set the
   bottom bit of their addresses.  The MIPS version of this function
   also prevents relocations that are mips-16 specific, but I do not
   know why it does this.

   FIXME:
   There is one other problem that ought to be addressed here, but
   which currently is not:  Taking the address of a label (rather
   than a function) and then later jumping to that address.  Such
   addresses also ought to have their bottom bit set (assuming that
   they reside in Thumb code), but at the moment they will not.	 */

bfd_boolean
arm_fix_adjustable (fixS * fixP)
{
  if (fixP->fx_addsy == NULL)
    return 1;

  if (THUMB_IS_FUNC (fixP->fx_addsy)
      && fixP->fx_subsy == NULL)
    return 0;

  /* We need the symbol name for the VTABLE entries.  */
  if (	 fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 0;

  /* Don't allow symbols to be discarded on GOT related relocs.	 */
  if (fixP->fx_r_type == BFD_RELOC_ARM_PLT32
      || fixP->fx_r_type == BFD_RELOC_ARM_GOT32
      || fixP->fx_r_type == BFD_RELOC_ARM_GOTOFF
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_GD32
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_LE32
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_IE32
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_LDM32
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_LDO32
      || fixP->fx_r_type == BFD_RELOC_ARM_TARGET2)
    return 0;

  return 1;
}

const char *
elf32_arm_target_format (void)
{
#ifdef TE_SYMBIAN
  return (target_big_endian
	  ? "elf32-bigarm-symbian"
	  : "elf32-littlearm-symbian");
#elif defined (TE_VXWORKS)
  return (target_big_endian
	  ? "elf32-bigarm-vxworks"
	  : "elf32-littlearm-vxworks");
#else
  if (target_big_endian)
    return "elf32-bigarm";
  else
    return "elf32-littlearm";
#endif
}

void
armelf_frob_symbol (symbolS * symp,
		    int *     puntp)
{
  elf_frob_symbol (symp, puntp);
}
#endif

/* MD interface: Finalization.	*/

/* A good place to do this, although this was probably not intended
   for this kind of use.  We need to dump the literal pool before
   references are made to a null symbol pointer.  */

void
arm_cleanup (void)
{
  literal_pool * pool;

  for (pool = list_of_pools; pool; pool = pool->next)
    {
      /* Put it at the end of the relevent section.  */
      subseg_set (pool->section, pool->sub_section);
#ifdef OBJ_ELF
      arm_elf_change_section ();
#endif
      s_ltorg (0);
    }
}

/* Adjust the symbol table.  This marks Thumb symbols as distinct from
   ARM ones.  */

void
arm_adjust_symtab (void)
{
#ifdef OBJ_COFF
  symbolS * sym;

  for (sym = symbol_rootP; sym != NULL; sym = symbol_next (sym))
    {
      if (ARM_IS_THUMB (sym))
	{
	  if (THUMB_IS_FUNC (sym))
	    {
	      /* Mark the symbol as a Thumb function.  */
	      if (   S_GET_STORAGE_CLASS (sym) == C_STAT
		  || S_GET_STORAGE_CLASS (sym) == C_LABEL)  /* This can happen!	 */
		S_SET_STORAGE_CLASS (sym, C_THUMBSTATFUNC);

	      else if (S_GET_STORAGE_CLASS (sym) == C_EXT)
		S_SET_STORAGE_CLASS (sym, C_THUMBEXTFUNC);
	      else
		as_bad (_("%s: unexpected function type: %d"),
			S_GET_NAME (sym), S_GET_STORAGE_CLASS (sym));
	    }
	  else switch (S_GET_STORAGE_CLASS (sym))
	    {
	    case C_EXT:
	      S_SET_STORAGE_CLASS (sym, C_THUMBEXT);
	      break;
	    case C_STAT:
	      S_SET_STORAGE_CLASS (sym, C_THUMBSTAT);
	      break;
	    case C_LABEL:
	      S_SET_STORAGE_CLASS (sym, C_THUMBLABEL);
	      break;
	    default:
	      /* Do nothing.  */
	      break;
	    }
	}

      if (ARM_IS_INTERWORK (sym))
	coffsymbol (symbol_get_bfdsym (sym))->native->u.syment.n_flags = 0xFF;
    }
#endif
#ifdef OBJ_ELF
  symbolS * sym;
  char	    bind;

  for (sym = symbol_rootP; sym != NULL; sym = symbol_next (sym))
    {
      if (ARM_IS_THUMB (sym))
	{
	  elf_symbol_type * elf_sym;

	  elf_sym = elf_symbol (symbol_get_bfdsym (sym));
	  bind = ELF_ST_BIND (elf_sym->internal_elf_sym.st_info);

	  if (! bfd_is_arm_mapping_symbol_name (elf_sym->symbol.name))
	    {
	      /* If it's a .thumb_func, declare it as so,
		 otherwise tag label as .code 16.  */
	      if (THUMB_IS_FUNC (sym))
		elf_sym->internal_elf_sym.st_info =
		  ELF_ST_INFO (bind, STT_ARM_TFUNC);
	      else
		elf_sym->internal_elf_sym.st_info =
		  ELF_ST_INFO (bind, STT_ARM_16BIT);
	    }
	}
    }
#endif
}

/* MD interface: Initialization.  */

static void
set_constant_flonums (void)
{
  int i;

  for (i = 0; i < NUM_FLOAT_VALS; i++)
    if (atof_ieee ((char *) fp_const[i], 'x', fp_values[i]) == NULL)
      abort ();
}

void
md_begin (void)
{
  unsigned mach;
  unsigned int i;

  if (	 (arm_ops_hsh = hash_new ()) == NULL
      || (arm_cond_hsh = hash_new ()) == NULL
      || (arm_shift_hsh = hash_new ()) == NULL
      || (arm_psr_hsh = hash_new ()) == NULL
      || (arm_reg_hsh = hash_new ()) == NULL
      || (arm_reloc_hsh = hash_new ()) == NULL)
    as_fatal (_("virtual memory exhausted"));

  for (i = 0; i < sizeof (insns) / sizeof (struct asm_opcode); i++)
    hash_insert (arm_ops_hsh, insns[i].template, (PTR) (insns + i));
  for (i = 0; i < sizeof (conds) / sizeof (struct asm_cond); i++)
    hash_insert (arm_cond_hsh, conds[i].template, (PTR) (conds + i));
  for (i = 0; i < sizeof (shift_names) / sizeof (struct asm_shift_name); i++)
    hash_insert (arm_shift_hsh, shift_names[i].name, (PTR) (shift_names + i));
  for (i = 0; i < sizeof (psrs) / sizeof (struct asm_psr); i++)
    hash_insert (arm_psr_hsh, psrs[i].template, (PTR) (psrs + i));
  for (i = 0; i < sizeof (reg_names) / sizeof (struct reg_entry); i++)
    hash_insert (arm_reg_hsh, reg_names[i].name, (PTR) (reg_names + i));
#ifdef OBJ_ELF
  for (i = 0; i < sizeof (reloc_names) / sizeof (struct reloc_entry); i++)
    hash_insert (arm_reloc_hsh, reloc_names[i].name, (PTR) (reloc_names + i));
#endif

  set_constant_flonums ();

  /* Set the cpu variant based on the command-line options.  We prefer
     -mcpu= over -march= if both are set (as for GCC); and we prefer
     -mfpu= over any other way of setting the floating point unit.
     Use of legacy options with new options are faulted.  */
  if (legacy_cpu != -1)
    {
      if (mcpu_cpu_opt != -1 || march_cpu_opt != -1)
	as_bad (_("use of old and new-style options to set CPU type"));

      mcpu_cpu_opt = legacy_cpu;
    }
  else if (mcpu_cpu_opt == -1)
    mcpu_cpu_opt = march_cpu_opt;

  if (legacy_fpu != -1)
    {
      if (mfpu_opt != -1)
	as_bad (_("use of old and new-style options to set FPU type"));

      mfpu_opt = legacy_fpu;
    }
  else if (mfpu_opt == -1)
    {
#if !(defined (TE_LINUX) || defined (TE_NetBSD) || defined (TE_VXWORKS))
      /* Some environments specify a default FPU.  If they don't, infer it
	 from the processor.  */
      if (mcpu_fpu_opt != -1)
	mfpu_opt = mcpu_fpu_opt;
      else
	mfpu_opt = march_fpu_opt;
#else
      mfpu_opt = FPU_DEFAULT;
#endif
    }

  if (mfpu_opt == -1)
    {
      if (mcpu_cpu_opt == -1)
	mfpu_opt = FPU_DEFAULT;
      else if (mcpu_cpu_opt & ARM_EXT_V5)
	mfpu_opt = FPU_ARCH_VFP_V2;
      else
	mfpu_opt = FPU_ARCH_FPA;
    }

  if (mcpu_cpu_opt == -1)
    mcpu_cpu_opt = CPU_DEFAULT;

  cpu_variant = mcpu_cpu_opt | mfpu_opt;

#if defined OBJ_COFF || defined OBJ_ELF
  {
    unsigned int flags = 0;

#if defined OBJ_ELF
    flags = meabi_flags;

    switch (meabi_flags)
      {
      case EF_ARM_EABI_UNKNOWN:
#endif
	/* Set the flags in the private structure.  */
	if (uses_apcs_26)      flags |= F_APCS26;
	if (support_interwork) flags |= F_INTERWORK;
	if (uses_apcs_float)   flags |= F_APCS_FLOAT;
	if (pic_code)	       flags |= F_PIC;
	if ((cpu_variant & FPU_ANY) == FPU_NONE
	     || (cpu_variant & FPU_ANY) == FPU_ARCH_VFP) /* VFP layout only.  */
	  flags |= F_SOFT_FLOAT;

	switch (mfloat_abi_opt)
	  {
	  case ARM_FLOAT_ABI_SOFT:
	  case ARM_FLOAT_ABI_SOFTFP:
	    flags |= F_SOFT_FLOAT;
	    break;

	  case ARM_FLOAT_ABI_HARD:
	    if (flags & F_SOFT_FLOAT)
	      as_bad (_("hard-float conflicts with specified fpu"));
	    break;
	  }

	/* Using VFP conventions (even if soft-float).	*/
	if (cpu_variant & FPU_VFP_EXT_NONE)
	  flags |= F_VFP_FLOAT;

#if defined OBJ_ELF
	if (cpu_variant & FPU_ARCH_MAVERICK)
	    flags |= EF_ARM_MAVERICK_FLOAT;
	break;

      case EF_ARM_EABI_VER4:
	/* No additional flags to set.	*/
	break;

      default:
	abort ();
      }
#endif
    bfd_set_private_flags (stdoutput, flags);

    /* We have run out flags in the COFF header to encode the
       status of ATPCS support, so instead we create a dummy,
       empty, debug section called .arm.atpcs.	*/
    if (atpcs)
      {
	asection * sec;

	sec = bfd_make_section (stdoutput, ".arm.atpcs");

	if (sec != NULL)
	  {
	    bfd_set_section_flags
	      (stdoutput, sec, SEC_READONLY | SEC_DEBUGGING /* | SEC_HAS_CONTENTS */);
	    bfd_set_section_size (stdoutput, sec, 0);
	    bfd_set_section_contents (stdoutput, sec, NULL, 0, 0);
	  }
      }
  }
#endif

  /* Record the CPU type as well.  */
  switch (cpu_variant & ARM_CPU_MASK)
    {
    case ARM_2:
      mach = bfd_mach_arm_2;
      break;

    case ARM_3:			/* Also ARM_250.  */
      mach = bfd_mach_arm_2a;
      break;

    case ARM_6:			/* Also ARM_7.	*/
      mach = bfd_mach_arm_3;
      break;

    default:
      mach = bfd_mach_arm_unknown;
      break;
    }

  /* Catch special cases.  */
  if (cpu_variant & ARM_CEXT_IWMMXT)
    mach = bfd_mach_arm_iWMMXt;
  else if (cpu_variant & ARM_CEXT_XSCALE)
    mach = bfd_mach_arm_XScale;
  else if (cpu_variant & ARM_CEXT_MAVERICK)
    mach = bfd_mach_arm_ep9312;
  else if (cpu_variant & ARM_EXT_V5E)
    mach = bfd_mach_arm_5TE;
  else if (cpu_variant & ARM_EXT_V5)
    {
      if (cpu_variant & ARM_EXT_V4T)
	mach = bfd_mach_arm_5T;
      else
	mach = bfd_mach_arm_5;
    }
  else if (cpu_variant & ARM_EXT_V4)
    {
      if (cpu_variant & ARM_EXT_V4T)
	mach = bfd_mach_arm_4T;
      else
	mach = bfd_mach_arm_4;
    }
  else if (cpu_variant & ARM_EXT_V3M)
    mach = bfd_mach_arm_3M;

  bfd_set_arch_mach (stdoutput, TARGET_ARCH, mach);
}

/* Command line processing.  */

/* md_parse_option
      Invocation line includes a switch not recognized by the base assembler.
      See if it's a processor-specific option.

      This routine is somewhat complicated by the need for backwards
      compatibility (since older releases of gcc can't be changed).
      The new options try to make the interface as compatible as
      possible with GCC.

      New options (supported) are:

	      -mcpu=<cpu name>		 Assemble for selected processor
	      -march=<architecture name> Assemble for selected architecture
	      -mfpu=<fpu architecture>	 Assemble for selected FPU.
	      -EB/-mbig-endian		 Big-endian
	      -EL/-mlittle-endian	 Little-endian
	      -k			 Generate PIC code
	      -mthumb			 Start in Thumb mode
	      -mthumb-interwork		 Code supports ARM/Thumb interworking

      For now we will also provide support for:

	      -mapcs-32			 32-bit Program counter
	      -mapcs-26			 26-bit Program counter
	      -macps-float		 Floats passed in FP registers
	      -mapcs-reentrant		 Reentrant code
	      -matpcs
      (sometime these will probably be replaced with -mapcs=<list of options>
      and -matpcs=<list of options>)

      The remaining options are only supported for back-wards compatibility.
      Cpu variants, the arm part is optional:
	      -m[arm]1		      Currently not supported.
	      -m[arm]2, -m[arm]250    Arm 2 and Arm 250 processor
	      -m[arm]3		      Arm 3 processor
	      -m[arm]6[xx],	      Arm 6 processors
	      -m[arm]7[xx][t][[d]m]   Arm 7 processors
	      -m[arm]8[10]	      Arm 8 processors
	      -m[arm]9[20][tdmi]      Arm 9 processors
	      -mstrongarm[110[0]]     StrongARM processors
	      -mxscale		      XScale processors
	      -m[arm]v[2345[t[e]]]    Arm architectures
	      -mall		      All (except the ARM1)
      FP variants:
	      -mfpa10, -mfpa11	      FPA10 and 11 co-processor instructions
	      -mfpe-old		      (No float load/store multiples)
	      -mvfpxd		      VFP Single precision
	      -mvfp		      All VFP
	      -mno-fpu		      Disable all floating point instructions

      The following CPU names are recognized:
	      arm1, arm2, arm250, arm3, arm6, arm600, arm610, arm620,
	      arm7, arm7m, arm7d, arm7dm, arm7di, arm7dmi, arm70, arm700,
	      arm700i, arm710 arm710t, arm720, arm720t, arm740t, arm710c,
	      arm7100, arm7500, arm7500fe, arm7tdmi, arm8, arm810, arm9,
	      arm920, arm920t, arm940t, arm946, arm966, arm9tdmi, arm9e,
	      arm10t arm10e, arm1020t, arm1020e, arm10200e,
	      strongarm, strongarm110, strongarm1100, strongarm1110, xscale.

      */

const char * md_shortopts = "m:k";

#ifdef ARM_BI_ENDIAN
#define OPTION_EB (OPTION_MD_BASE + 0)
#define OPTION_EL (OPTION_MD_BASE + 1)
#else
#if TARGET_BYTES_BIG_ENDIAN
#define OPTION_EB (OPTION_MD_BASE + 0)
#else
#define OPTION_EL (OPTION_MD_BASE + 1)
#endif
#endif

struct option md_longopts[] =
{
#ifdef OPTION_EB
  {"EB", no_argument, NULL, OPTION_EB},
#endif
#ifdef OPTION_EL
  {"EL", no_argument, NULL, OPTION_EL},
#endif
  {NULL, no_argument, NULL, 0}
};

size_t md_longopts_size = sizeof (md_longopts);

struct arm_option_table
{
  char *option;		/* Option name to match.  */
  char *help;		/* Help information.  */
  int  *var;		/* Variable to change.	*/
  int	value;		/* What to change it to.  */
  char *deprecated;	/* If non-null, print this message.  */
};

struct arm_option_table arm_opts[] =
{
  {"k",	     N_("generate PIC code"),	   &pic_code,	 1, NULL},
  {"mthumb", N_("assemble Thumb code"),	   &thumb_mode,	 1, NULL},
  {"mthumb-interwork", N_("support ARM/Thumb interworking"),
   &support_interwork, 1, NULL},
  {"mapcs-32", N_("code uses 32-bit program counter"), &uses_apcs_26, 0, NULL},
  {"mapcs-26", N_("code uses 26-bit program counter"), &uses_apcs_26, 1, NULL},
  {"mapcs-float", N_("floating point args are in fp regs"), &uses_apcs_float,
   1, NULL},
  {"mapcs-reentrant", N_("re-entrant code"), &pic_code, 1, NULL},
  {"matpcs", N_("code is ATPCS conformant"), &atpcs, 1, NULL},
  {"mbig-endian", N_("assemble for big-endian"), &target_big_endian, 1, NULL},
  {"mlittle-endian", N_("assemble for little-endian"), &target_big_endian, 0,
   NULL},

  /* These are recognized by the assembler, but have no affect on code.	 */
  {"mapcs-frame", N_("use frame pointer"), NULL, 0, NULL},
  {"mapcs-stack-check", N_("use stack size checking"), NULL, 0, NULL},

  /* DON'T add any new processors to this list -- we want the whole list
     to go away...  Add them to the processors table instead.  */
  {"marm1",	 NULL, &legacy_cpu, ARM_ARCH_V1,  N_("use -mcpu=arm1")},
  {"m1",	 NULL, &legacy_cpu, ARM_ARCH_V1,  N_("use -mcpu=arm1")},
  {"marm2",	 NULL, &legacy_cpu, ARM_ARCH_V2,  N_("use -mcpu=arm2")},
  {"m2",	 NULL, &legacy_cpu, ARM_ARCH_V2,  N_("use -mcpu=arm2")},
  {"marm250",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm250")},
  {"m250",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm250")},
  {"marm3",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm3")},
  {"m3",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm3")},
  {"marm6",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm6")},
  {"m6",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm6")},
  {"marm600",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm600")},
  {"m600",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm600")},
  {"marm610",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm610")},
  {"m610",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm610")},
  {"marm620",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm620")},
  {"m620",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm620")},
  {"marm7",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7")},
  {"m7",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7")},
  {"marm70",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm70")},
  {"m70",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm70")},
  {"marm700",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700")},
  {"m700",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700")},
  {"marm700i",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700i")},
  {"m700i",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700i")},
  {"marm710",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710")},
  {"m710",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710")},
  {"marm710c",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710c")},
  {"m710c",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710c")},
  {"marm720",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm720")},
  {"m720",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm720")},
  {"marm7d",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7d")},
  {"m7d",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7d")},
  {"marm7di",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7di")},
  {"m7di",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7di")},
  {"marm7m",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7m")},
  {"m7m",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7m")},
  {"marm7dm",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dm")},
  {"m7dm",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dm")},
  {"marm7dmi",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dmi")},
  {"m7dmi",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dmi")},
  {"marm7100",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7100")},
  {"m7100",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7100")},
  {"marm7500",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500")},
  {"m7500",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500")},
  {"marm7500fe", NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500fe")},
  {"m7500fe",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500fe")},
  {"marm7t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"m7t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"marm7tdmi",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"m7tdmi",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"marm710t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm710t")},
  {"m710t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm710t")},
  {"marm720t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm720t")},
  {"m720t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm720t")},
  {"marm740t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm740t")},
  {"m740t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm740t")},
  {"marm8",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm8")},
  {"m8",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm8")},
  {"marm810",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm810")},
  {"m810",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm810")},
  {"marm9",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9")},
  {"m9",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9")},
  {"marm9tdmi",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9tdmi")},
  {"m9tdmi",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9tdmi")},
  {"marm920",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm920")},
  {"m920",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm920")},
  {"marm940",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm940")},
  {"m940",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm940")},
  {"mstrongarm", NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=strongarm")},
  {"mstrongarm110", NULL, &legacy_cpu, ARM_ARCH_V4,
   N_("use -mcpu=strongarm110")},
  {"mstrongarm1100", NULL, &legacy_cpu, ARM_ARCH_V4,
   N_("use -mcpu=strongarm1100")},
  {"mstrongarm1110", NULL, &legacy_cpu, ARM_ARCH_V4,
   N_("use -mcpu=strongarm1110")},
  {"mxscale",	 NULL, &legacy_cpu, ARM_ARCH_XSCALE, N_("use -mcpu=xscale")},
  {"miwmmxt",	 NULL, &legacy_cpu, ARM_ARCH_IWMMXT, N_("use -mcpu=iwmmxt")},
  {"mall",	 NULL, &legacy_cpu, ARM_ANY,	  N_("use -mcpu=all")},

  /* Architecture variants -- don't add any more to this list either.  */
  {"mv2",	 NULL, &legacy_cpu, ARM_ARCH_V2,  N_("use -march=armv2")},
  {"marmv2",	 NULL, &legacy_cpu, ARM_ARCH_V2,  N_("use -march=armv2")},
  {"mv2a",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -march=armv2a")},
  {"marmv2a",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -march=armv2a")},
  {"mv3",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -march=armv3")},
  {"marmv3",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -march=armv3")},
  {"mv3m",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -march=armv3m")},
  {"marmv3m",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -march=armv3m")},
  {"mv4",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -march=armv4")},
  {"marmv4",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -march=armv4")},
  {"mv4t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -march=armv4t")},
  {"marmv4t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -march=armv4t")},
  {"mv5",	 NULL, &legacy_cpu, ARM_ARCH_V5,  N_("use -march=armv5")},
  {"marmv5",	 NULL, &legacy_cpu, ARM_ARCH_V5,  N_("use -march=armv5")},
  {"mv5t",	 NULL, &legacy_cpu, ARM_ARCH_V5T, N_("use -march=armv5t")},
  {"marmv5t",	 NULL, &legacy_cpu, ARM_ARCH_V5T, N_("use -march=armv5t")},
  {"mv5e",	 NULL, &legacy_cpu, ARM_ARCH_V5TE, N_("use -march=armv5te")},
  {"marmv5e",	 NULL, &legacy_cpu, ARM_ARCH_V5TE, N_("use -march=armv5te")},

  /* Floating point variants -- don't add any more to this list either.	 */
  {"mfpe-old", NULL, &legacy_fpu, FPU_ARCH_FPE, N_("use -mfpu=fpe")},
  {"mfpa10",   NULL, &legacy_fpu, FPU_ARCH_FPA, N_("use -mfpu=fpa10")},
  {"mfpa11",   NULL, &legacy_fpu, FPU_ARCH_FPA, N_("use -mfpu=fpa11")},
  {"mno-fpu",  NULL, &legacy_fpu, 0,
   N_("use either -mfpu=softfpa or -mfpu=softvfp")},

  {NULL, NULL, NULL, 0, NULL}
};

struct arm_cpu_option_table
{
  char *name;
  int	value;
  /* For some CPUs we assume an FPU unless the user explicitly sets
     -mfpu=...	*/
  int	default_fpu;
};

/* This list should, at a minimum, contain all the cpu names
   recognized by GCC.  */
static struct arm_cpu_option_table arm_cpus[] =
{
  {"all",		ARM_ANY,	 FPU_ARCH_FPA},
  {"arm1",		ARM_ARCH_V1,	 FPU_ARCH_FPA},
  {"arm2",		ARM_ARCH_V2,	 FPU_ARCH_FPA},
  {"arm250",		ARM_ARCH_V2S,	 FPU_ARCH_FPA},
  {"arm3",		ARM_ARCH_V2S,	 FPU_ARCH_FPA},
  {"arm6",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm60",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm600",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm610",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm620",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7m",		ARM_ARCH_V3M,	 FPU_ARCH_FPA},
  {"arm7d",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7dm",		ARM_ARCH_V3M,	 FPU_ARCH_FPA},
  {"arm7di",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7dmi",		ARM_ARCH_V3M,	 FPU_ARCH_FPA},
  {"arm70",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm700",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm700i",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm710",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm710t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm720",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm720t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm740t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm710c",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7100",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7500",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7500fe",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm7tdmi",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm7tdmi-s",	ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm8",		ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"arm810",		ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm",		ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm1",	ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm110",	ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm1100",	ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm1110",	ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"arm9",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm920",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm920t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm922t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm940t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm9tdmi",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  /* For V5 or later processors we default to using VFP; but the user
     should really set the FPU type explicitly.	 */
  {"arm9e-r0",		ARM_ARCH_V5TExP, FPU_ARCH_VFP_V2},
  {"arm9e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm926ej",		ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2},
  {"arm926ejs",		ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2},
  {"arm926ej-s",	ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2},
  {"arm946e-r0",	ARM_ARCH_V5TExP, FPU_ARCH_VFP_V2},
  {"arm946e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm966e-r0",	ARM_ARCH_V5TExP, FPU_ARCH_VFP_V2},
  {"arm966e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm10t",		ARM_ARCH_V5T,	 FPU_ARCH_VFP_V1},
  {"arm10e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm1020",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm1020t",		ARM_ARCH_V5T,	 FPU_ARCH_VFP_V1},
  {"arm1020e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm1026ejs",	ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2},
  {"arm1026ej-s",	ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2},
  {"arm1136js",		ARM_ARCH_V6,	 FPU_NONE},
  {"arm1136j-s",	ARM_ARCH_V6,	 FPU_NONE},
  {"arm1136jfs",	ARM_ARCH_V6,	 FPU_ARCH_VFP_V2},
  {"arm1136jf-s",	ARM_ARCH_V6,	 FPU_ARCH_VFP_V2},
  {"mpcore",		ARM_ARCH_V6K,	 FPU_ARCH_VFP_V2},
  {"mpcorenovfp",	ARM_ARCH_V6K,	 FPU_NONE},
  {"arm1176jz-s",	ARM_ARCH_V6ZK,	 FPU_NONE},
  {"arm1176jzf-s",	ARM_ARCH_V6ZK,	 FPU_ARCH_VFP_V2},
  /* ??? XSCALE is really an architecture.  */
  {"xscale",		ARM_ARCH_XSCALE, FPU_ARCH_VFP_V2},
  /* ??? iwmmxt is not a processor.  */
  {"iwmmxt",		ARM_ARCH_IWMMXT, FPU_ARCH_VFP_V2},
  {"i80200",		ARM_ARCH_XSCALE, FPU_ARCH_VFP_V2},
  /* Maverick */
  {"ep9312",		ARM_ARCH_V4T | ARM_CEXT_MAVERICK, FPU_ARCH_MAVERICK},
  {NULL, 0, 0}
};

struct arm_arch_option_table
{
  char *name;
  int	value;
  int	default_fpu;
};

/* This list should, at a minimum, contain all the architecture names
   recognized by GCC.  */
static struct arm_arch_option_table arm_archs[] =
{
  {"all",		ARM_ANY,	 FPU_ARCH_FPA},
  {"armv1",		ARM_ARCH_V1,	 FPU_ARCH_FPA},
  {"armv2",		ARM_ARCH_V2,	 FPU_ARCH_FPA},
  {"armv2a",		ARM_ARCH_V2S,	 FPU_ARCH_FPA},
  {"armv2s",		ARM_ARCH_V2S,	 FPU_ARCH_FPA},
  {"armv3",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"armv3m",		ARM_ARCH_V3M,	 FPU_ARCH_FPA},
  {"armv4",		ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"armv4xm",		ARM_ARCH_V4xM,	 FPU_ARCH_FPA},
  {"armv4t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"armv4txm",		ARM_ARCH_V4TxM,	 FPU_ARCH_FPA},
  {"armv5",		ARM_ARCH_V5,	 FPU_ARCH_VFP},
  {"armv5t",		ARM_ARCH_V5T,	 FPU_ARCH_VFP},
  {"armv5txm",		ARM_ARCH_V5TxM,	 FPU_ARCH_VFP},
  {"armv5te",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP},
  {"armv5texp",		ARM_ARCH_V5TExP, FPU_ARCH_VFP},
  {"armv5tej",		ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP},
  {"armv6",		ARM_ARCH_V6,	 FPU_ARCH_VFP},
  {"armv6j",		ARM_ARCH_V6,	 FPU_ARCH_VFP},
  {"armv6k",		ARM_ARCH_V6K,	 FPU_ARCH_VFP},
  {"armv6z",		ARM_ARCH_V6Z,	 FPU_ARCH_VFP},
  {"armv6zk",		ARM_ARCH_V6ZK,	 FPU_ARCH_VFP},
  {"armv6t2",		ARM_ARCH_V6T2,	 FPU_ARCH_VFP},
  {"armv6kt2",		ARM_ARCH_V6KT2,	 FPU_ARCH_VFP},
  {"armv6zt2",		ARM_ARCH_V6ZT2,	 FPU_ARCH_VFP},
  {"armv6zkt2",		ARM_ARCH_V6ZKT2, FPU_ARCH_VFP},
  {"xscale",		ARM_ARCH_XSCALE, FPU_ARCH_VFP},
  {"iwmmxt",		ARM_ARCH_IWMMXT, FPU_ARCH_VFP},
  {NULL, 0, 0}
};

/* ISA extensions in the co-processor space.  */
struct arm_option_value_table
{
  char *name;
  int value;
};

static struct arm_option_value_table arm_extensions[] =
{
  {"maverick",		ARM_CEXT_MAVERICK},
  {"xscale",		ARM_CEXT_XSCALE},
  {"iwmmxt",		ARM_CEXT_IWMMXT},
  {NULL,		0}
};

/* This list should, at a minimum, contain all the fpu names
   recognized by GCC.  */
static struct arm_option_value_table arm_fpus[] =
{
  {"softfpa",		FPU_NONE},
  {"fpe",		FPU_ARCH_FPE},
  {"fpe2",		FPU_ARCH_FPE},
  {"fpe3",		FPU_ARCH_FPA},	/* Third release supports LFM/SFM.  */
  {"fpa",		FPU_ARCH_FPA},
  {"fpa10",		FPU_ARCH_FPA},
  {"fpa11",		FPU_ARCH_FPA},
  {"arm7500fe",		FPU_ARCH_FPA},
  {"softvfp",		FPU_ARCH_VFP},
  {"softvfp+vfp",	FPU_ARCH_VFP_V2},
  {"vfp",		FPU_ARCH_VFP_V2},
  {"vfp9",		FPU_ARCH_VFP_V2},
  {"vfp10",		FPU_ARCH_VFP_V2},
  {"vfp10-r0",		FPU_ARCH_VFP_V1},
  {"vfpxd",		FPU_ARCH_VFP_V1xD},
  {"arm1020t",		FPU_ARCH_VFP_V1},
  {"arm1020e",		FPU_ARCH_VFP_V2},
  {"arm1136jfs",	FPU_ARCH_VFP_V2},
  {"arm1136jf-s",	FPU_ARCH_VFP_V2},
  {"maverick",		FPU_ARCH_MAVERICK},
  {NULL, 0}
};

static struct arm_option_value_table arm_float_abis[] =
{
  {"hard",	ARM_FLOAT_ABI_HARD},
  {"softfp",	ARM_FLOAT_ABI_SOFTFP},
  {"soft",	ARM_FLOAT_ABI_SOFT},
  {NULL, 0}
};

#ifdef OBJ_ELF
/* We only know how to output GNU and ver 4 (AAELF) formats.  */
static struct arm_option_value_table arm_eabis[] =
{
  {"gnu",	EF_ARM_EABI_UNKNOWN},
  {"4",		EF_ARM_EABI_VER4},
  {NULL, 0}
};
#endif

struct arm_long_option_table
{
  char * option;		/* Substring to match.	*/
  char * help;			/* Help information.  */
  int (* func) (char * subopt);	/* Function to decode sub-option.  */
  char * deprecated;		/* If non-null, print this message.  */
};

static int
arm_parse_extension (char * str, int * opt_p)
{
  while (str != NULL && *str != 0)
    {
      struct arm_option_value_table * opt;
      char * ext;
      int optlen;

      if (*str != '+')
	{
	  as_bad (_("invalid architectural extension"));
	  return 0;
	}

      str++;
      ext = strchr (str, '+');

      if (ext != NULL)
	optlen = ext - str;
      else
	optlen = strlen (str);

      if (optlen == 0)
	{
	  as_bad (_("missing architectural extension"));
	  return 0;
	}

      for (opt = arm_extensions; opt->name != NULL; opt++)
	if (strncmp (opt->name, str, optlen) == 0)
	  {
	    *opt_p |= opt->value;
	    break;
	  }

      if (opt->name == NULL)
	{
	  as_bad (_("unknown architectural extnsion `%s'"), str);
	  return 0;
	}

      str = ext;
    };

  return 1;
}

static int
arm_parse_cpu (char * str)
{
  struct arm_cpu_option_table * opt;
  char * ext = strchr (str, '+');
  int optlen;

  if (ext != NULL)
    optlen = ext - str;
  else
    optlen = strlen (str);

  if (optlen == 0)
    {
      as_bad (_("missing cpu name `%s'"), str);
      return 0;
    }

  for (opt = arm_cpus; opt->name != NULL; opt++)
    if (strncmp (opt->name, str, optlen) == 0)
      {
	mcpu_cpu_opt = opt->value;
	mcpu_fpu_opt = opt->default_fpu;

	if (ext != NULL)
	  return arm_parse_extension (ext, &mcpu_cpu_opt);

	return 1;
      }

  as_bad (_("unknown cpu `%s'"), str);
  return 0;
}

static int
arm_parse_arch (char * str)
{
  struct arm_arch_option_table *opt;
  char *ext = strchr (str, '+');
  int optlen;

  if (ext != NULL)
    optlen = ext - str;
  else
    optlen = strlen (str);

  if (optlen == 0)
    {
      as_bad (_("missing architecture name `%s'"), str);
      return 0;
    }


  for (opt = arm_archs; opt->name != NULL; opt++)
    if (streq (opt->name, str))
      {
	march_cpu_opt = opt->value;
	march_fpu_opt = opt->default_fpu;

	if (ext != NULL)
	  return arm_parse_extension (ext, &march_cpu_opt);

	return 1;
      }

  as_bad (_("unknown architecture `%s'\n"), str);
  return 0;
}

static int
arm_parse_fpu (char * str)
{
  struct arm_option_value_table * opt;

  for (opt = arm_fpus; opt->name != NULL; opt++)
    if (streq (opt->name, str))
      {
	mfpu_opt = opt->value;
	return 1;
      }

  as_bad (_("unknown floating point format `%s'\n"), str);
  return 0;
}

static int
arm_parse_float_abi (char * str)
{
  struct arm_option_value_table * opt;

  for (opt = arm_float_abis; opt->name != NULL; opt++)
    if (streq (opt->name, str))
      {
	mfloat_abi_opt = opt->value;
	return 1;
      }

  as_bad (_("unknown floating point abi `%s'\n"), str);
  return 0;
}

#ifdef OBJ_ELF
static int
arm_parse_eabi (char * str)
{
  struct arm_option_value_table *opt;

  for (opt = arm_eabis; opt->name != NULL; opt++)
    if (streq (opt->name, str))
      {
	meabi_flags = opt->value;
	return 1;
      }
  as_bad (_("unknown EABI `%s'\n"), str);
  return 0;
}
#endif

struct arm_long_option_table arm_long_opts[] =
{
  {"mcpu=", N_("<cpu name>\t  assemble for CPU <cpu name>"),
   arm_parse_cpu, NULL},
  {"march=", N_("<arch name>\t  assemble for architecture <arch name>"),
   arm_parse_arch, NULL},
  {"mfpu=", N_("<fpu name>\t  assemble for FPU architecture <fpu name>"),
   arm_parse_fpu, NULL},
  {"mfloat-abi=", N_("<abi>\t  assemble for floating point ABI <abi>"),
   arm_parse_float_abi, NULL},
#ifdef OBJ_ELF
  {"meabi=", N_("<ver>\t  assemble for eabi version <ver>"),
   arm_parse_eabi, NULL},
#endif
  {NULL, NULL, 0, NULL}
};

int
md_parse_option (int c, char * arg)
{
  struct arm_option_table *opt;
  struct arm_long_option_table *lopt;

  switch (c)
    {
#ifdef OPTION_EB
    case OPTION_EB:
      target_big_endian = 1;
      break;
#endif

#ifdef OPTION_EL
    case OPTION_EL:
      target_big_endian = 0;
      break;
#endif

    case 'a':
      /* Listing option.  Just ignore these, we don't support additional
	 ones.	*/
      return 0;

    default:
      for (opt = arm_opts; opt->option != NULL; opt++)
	{
	  if (c == opt->option[0]
	      && ((arg == NULL && opt->option[1] == 0)
		  || streq (arg, opt->option + 1)))
	    {
#if WARN_DEPRECATED
	      /* If the option is deprecated, tell the user.  */
	      if (opt->deprecated != NULL)
		as_tsktsk (_("option `-%c%s' is deprecated: %s"), c,
			   arg ? arg : "", _(opt->deprecated));
#endif

	      if (opt->var != NULL)
		*opt->var = opt->value;

	      return 1;
	    }
	}

      for (lopt = arm_long_opts; lopt->option != NULL; lopt++)
	{
	  /* These options are expected to have an argument.  */
	  if (c == lopt->option[0]
	      && arg != NULL
	      && strncmp (arg, lopt->option + 1,
			  strlen (lopt->option + 1)) == 0)
	    {
#if WARN_DEPRECATED
	      /* If the option is deprecated, tell the user.  */
	      if (lopt->deprecated != NULL)
		as_tsktsk (_("option `-%c%s' is deprecated: %s"), c, arg,
			   _(lopt->deprecated));
#endif

	      /* Call the sup-option parser.  */
	      return lopt->func (arg + strlen (lopt->option) - 1);
	    }
	}

      return 0;
    }

  return 1;
}

void
md_show_usage (FILE * fp)
{
  struct arm_option_table *opt;
  struct arm_long_option_table *lopt;

  fprintf (fp, _(" ARM-specific assembler options:\n"));

  for (opt = arm_opts; opt->option != NULL; opt++)
    if (opt->help != NULL)
      fprintf (fp, "  -%-23s%s\n", opt->option, _(opt->help));

  for (lopt = arm_long_opts; lopt->option != NULL; lopt++)
    if (lopt->help != NULL)
      fprintf (fp, "  -%s%s\n", lopt->option, _(lopt->help));

#ifdef OPTION_EB
  fprintf (fp, _("\
  -EB                     assemble code for a big-endian cpu\n"));
#endif

#ifdef OPTION_EL
  fprintf (fp, _("\
  -EL                     assemble code for a little-endian cpu\n"));
#endif
}
@


1.1
log
@Initial revision
@
text
@d2 2
a3 2
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
   2005
d20 1
a20 1
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
d25 2
a26 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
d29 1
a29 1
#define  NO_RELOC 0
d59 4
a62 4
  symbolS *       proc_start;
  symbolS *       table_entry;
  symbolS *       personality_routine;
  int             personality_index;
d64 2
a65 2
  segT            saved_seg;
  subsegT         saved_subseg;
d68 2
a69 2
  int             opcode_count;
  int             opcode_alloc;
d71 1
a71 1
  offsetT         frame_size;
d75 1
a75 1
  offsetT         pending_offset;
d77 3
a79 3
     hold the reg+offset to use when restoring sp from a frame pointer.  */
  offsetT         fp_offset;
  int             fp_reg;
d81 1
a81 1
  unsigned        fp_used:1;
d83 1
a83 1
  unsigned        sp_restored:1;
d86 5
d100 1
a100 1
/* Types of processor to assemble for.  */
d110 1
a110 1
#define ARM_CPU_MASK	0x0000000f              /* XXX? */
d117 1
a117 1
#define CPU_DEFAULT 	(ARM_ARCH_V5T)
d119 1
a119 1
#define CPU_DEFAULT 	ARM_ANY
d142 1
a142 2
#define streq(a, b)           (strcmp (a, b) == 0)
#define skip_whitespace(str)  while (*(str) == ' ') ++(str)
d147 2
a148 2
static int uses_apcs_26      = FALSE;
static int atpcs             = FALSE;
d151 1
a151 1
static int pic_code          = FALSE;
d166 3
d170 1
a172 29
/* This array holds the chars that always start a comment.  If the
   pre-processor is disabled, these aren't very useful.  */
const char comment_chars[] = "@@";

/* This array holds the chars that only start a comment at the beginning of
   a line.  If the line seems to have the form '# 123 filename'
   .line and .file directives will appear in the pre-processed output.  */
/* Note that input_file.c hand checks for '#' at the beginning of the
   first line of the input file.  This is because the compiler outputs
   #NO_APP at the beginning of its output.  */
/* Also note that comments like this one will always work.  */
const char line_comment_chars[] = "#";

const char line_separator_chars[] = ";";

/* Chars that can be used to separate mant
   from exp in floating point numbers.  */
const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant.  */
/* As in 0f12.456  */
/* or    0d1.2345e12  */

const char FLT_CHARS[] = "rRsSfFdDxXeEpP";

/* Prefix characters that indicate the start of an immediate
   value.  */
#define is_immediate_prefix(C) ((C) == '#' || (C) == '$')

d174 1
a174 1
/* Pre-defined "_GLOBAL_OFFSET_TABLE_"  */
d187 24
a210 4
typedef struct arm_fix
{
  int thumb_mode;
} arm_fix_data;
d214 1
a214 1
  const char *  error;
d216 3
a218 1
  int           size;
d222 2
a223 2
    expressionS              exp;
    int                      pc_rel;
a224 1
};
d226 15
a240 48
struct arm_it inst;

enum asm_shift_index
{
  SHIFT_LSL = 0,
  SHIFT_LSR,
  SHIFT_ASR,
  SHIFT_ROR,
  SHIFT_RRX
};

struct asm_shift_properties
{
  enum asm_shift_index index;
  unsigned long        bit_field;
  unsigned int         allows_0  : 1;
  unsigned int         allows_32 : 1;
};

static const struct asm_shift_properties shift_properties [] =
{
  { SHIFT_LSL, 0,    1, 0},
  { SHIFT_LSR, 0x20, 0, 1},
  { SHIFT_ASR, 0x40, 0, 1},
  { SHIFT_ROR, 0x60, 0, 0},
  { SHIFT_RRX, 0x60, 0, 0}
};

struct asm_shift_name
{
  const char *                        name;
  const struct asm_shift_properties * properties;
};

static const struct asm_shift_name shift_names [] =
{
  { "asl", shift_properties + SHIFT_LSL },
  { "lsl", shift_properties + SHIFT_LSL },
  { "lsr", shift_properties + SHIFT_LSR },
  { "asr", shift_properties + SHIFT_ASR },
  { "ror", shift_properties + SHIFT_ROR },
  { "rrx", shift_properties + SHIFT_RRX },
  { "ASL", shift_properties + SHIFT_LSL },
  { "LSL", shift_properties + SHIFT_LSL },
  { "LSR", shift_properties + SHIFT_LSR },
  { "ASR", shift_properties + SHIFT_ASR },
  { "ROR", shift_properties + SHIFT_ROR },
  { "RRX", shift_properties + SHIFT_RRX }
d243 1
a243 10
/* Any kind of shift is accepted.  */
#define NO_SHIFT_RESTRICT 1
/* The shift operand must be an immediate value, not a register.  */
#define SHIFT_IMMEDIATE	  0
/* The shift must be LSL or ASR and the operand must be an immediate.  */
#define SHIFT_LSL_OR_ASR_IMMEDIATE 2
/* The shift must be ASR and the operand must be an immediate.  */
#define SHIFT_ASR_IMMEDIATE 3
/* The shift must be LSL and the operand must be an immediate.  */
#define SHIFT_LSL_IMMEDIATE 4
d252 1
a252 1
/* Number of littlenums required to hold an extended precision number.  */
a259 4
/* Whether a Co-processor load/store operation accepts write-back forms.  */
#define CP_WB_OK 1
#define CP_NO_WB 0

d265 2
a266 5
#define CP_T_X   0x00008000
#define CP_T_Y   0x00400000
#define CP_T_Pre 0x01000000
#define CP_T_UD  0x00800000
#define CP_T_WB  0x00200000
d268 2
a269 2
#define CONDS_BIT        0x00100000
#define LOAD_BIT         0x00100000
d275 1
a275 1
  const char *  template;
d279 1
a279 22
#define COND_ALWAYS 0xe0000000
#define COND_MASK   0xf0000000

static const struct asm_cond conds[] =
{
  {"eq", 0x00000000},
  {"ne", 0x10000000},
  {"cs", 0x20000000}, {"hs", 0x20000000},
  {"cc", 0x30000000}, {"ul", 0x30000000}, {"lo", 0x30000000},
  {"mi", 0x40000000},
  {"pl", 0x50000000},
  {"vs", 0x60000000},
  {"vc", 0x70000000},
  {"hi", 0x80000000},
  {"ls", 0x90000000},
  {"ge", 0xa0000000},
  {"lt", 0xb0000000},
  {"gt", 0xc0000000},
  {"le", 0xd0000000},
  {"al", 0xe0000000},
  {"nv", 0xf0000000}
};
a283 1
  bfd_boolean cpsr;
d290 5
a294 7
/* How many bits to shift the PSR_xxx bits up by.  */
#define PSR_SHIFT  16

#define PSR_c   (1 << 0)
#define PSR_x   (1 << 1)
#define PSR_s   (1 << 2)
#define PSR_f   (1 << 3)
d296 1
a296 1
static const struct asm_psr psrs[] =
d298 2
a299 171
  {"CPSR",	TRUE,  PSR_c | PSR_f},
  {"CPSR_all",	TRUE,  PSR_c | PSR_f},
  {"SPSR",	FALSE, PSR_c | PSR_f},
  {"SPSR_all",	FALSE, PSR_c | PSR_f},
  {"CPSR_flg",	TRUE,  PSR_f},
  {"CPSR_f",    TRUE,  PSR_f},
  {"SPSR_flg",	FALSE, PSR_f},
  {"SPSR_f",    FALSE, PSR_f},
  {"CPSR_c",	TRUE,  PSR_c},
  {"CPSR_ctl",	TRUE,  PSR_c},
  {"SPSR_c",	FALSE, PSR_c},
  {"SPSR_ctl",	FALSE, PSR_c},
  {"CPSR_x",    TRUE,  PSR_x},
  {"CPSR_s",    TRUE,  PSR_s},
  {"SPSR_x",    FALSE, PSR_x},
  {"SPSR_s",    FALSE, PSR_s},
  /* Combinations of flags.  */
  {"CPSR_fs",	TRUE, PSR_f | PSR_s},
  {"CPSR_fx",	TRUE, PSR_f | PSR_x},
  {"CPSR_fc",	TRUE, PSR_f | PSR_c},
  {"CPSR_sf",	TRUE, PSR_s | PSR_f},
  {"CPSR_sx",	TRUE, PSR_s | PSR_x},
  {"CPSR_sc",	TRUE, PSR_s | PSR_c},
  {"CPSR_xf",	TRUE, PSR_x | PSR_f},
  {"CPSR_xs",	TRUE, PSR_x | PSR_s},
  {"CPSR_xc",	TRUE, PSR_x | PSR_c},
  {"CPSR_cf",	TRUE, PSR_c | PSR_f},
  {"CPSR_cs",	TRUE, PSR_c | PSR_s},
  {"CPSR_cx",	TRUE, PSR_c | PSR_x},
  {"CPSR_fsx",	TRUE, PSR_f | PSR_s | PSR_x},
  {"CPSR_fsc",	TRUE, PSR_f | PSR_s | PSR_c},
  {"CPSR_fxs",	TRUE, PSR_f | PSR_x | PSR_s},
  {"CPSR_fxc",	TRUE, PSR_f | PSR_x | PSR_c},
  {"CPSR_fcs",	TRUE, PSR_f | PSR_c | PSR_s},
  {"CPSR_fcx",	TRUE, PSR_f | PSR_c | PSR_x},
  {"CPSR_sfx",	TRUE, PSR_s | PSR_f | PSR_x},
  {"CPSR_sfc",	TRUE, PSR_s | PSR_f | PSR_c},
  {"CPSR_sxf",	TRUE, PSR_s | PSR_x | PSR_f},
  {"CPSR_sxc",	TRUE, PSR_s | PSR_x | PSR_c},
  {"CPSR_scf",	TRUE, PSR_s | PSR_c | PSR_f},
  {"CPSR_scx",	TRUE, PSR_s | PSR_c | PSR_x},
  {"CPSR_xfs",	TRUE, PSR_x | PSR_f | PSR_s},
  {"CPSR_xfc",	TRUE, PSR_x | PSR_f | PSR_c},
  {"CPSR_xsf",	TRUE, PSR_x | PSR_s | PSR_f},
  {"CPSR_xsc",	TRUE, PSR_x | PSR_s | PSR_c},
  {"CPSR_xcf",	TRUE, PSR_x | PSR_c | PSR_f},
  {"CPSR_xcs",	TRUE, PSR_x | PSR_c | PSR_s},
  {"CPSR_cfs",	TRUE, PSR_c | PSR_f | PSR_s},
  {"CPSR_cfx",	TRUE, PSR_c | PSR_f | PSR_x},
  {"CPSR_csf",	TRUE, PSR_c | PSR_s | PSR_f},
  {"CPSR_csx",	TRUE, PSR_c | PSR_s | PSR_x},
  {"CPSR_cxf",	TRUE, PSR_c | PSR_x | PSR_f},
  {"CPSR_cxs",	TRUE, PSR_c | PSR_x | PSR_s},
  {"CPSR_fsxc",	TRUE, PSR_f | PSR_s | PSR_x | PSR_c},
  {"CPSR_fscx",	TRUE, PSR_f | PSR_s | PSR_c | PSR_x},
  {"CPSR_fxsc",	TRUE, PSR_f | PSR_x | PSR_s | PSR_c},
  {"CPSR_fxcs",	TRUE, PSR_f | PSR_x | PSR_c | PSR_s},
  {"CPSR_fcsx",	TRUE, PSR_f | PSR_c | PSR_s | PSR_x},
  {"CPSR_fcxs",	TRUE, PSR_f | PSR_c | PSR_x | PSR_s},
  {"CPSR_sfxc",	TRUE, PSR_s | PSR_f | PSR_x | PSR_c},
  {"CPSR_sfcx",	TRUE, PSR_s | PSR_f | PSR_c | PSR_x},
  {"CPSR_sxfc",	TRUE, PSR_s | PSR_x | PSR_f | PSR_c},
  {"CPSR_sxcf",	TRUE, PSR_s | PSR_x | PSR_c | PSR_f},
  {"CPSR_scfx",	TRUE, PSR_s | PSR_c | PSR_f | PSR_x},
  {"CPSR_scxf",	TRUE, PSR_s | PSR_c | PSR_x | PSR_f},
  {"CPSR_xfsc",	TRUE, PSR_x | PSR_f | PSR_s | PSR_c},
  {"CPSR_xfcs",	TRUE, PSR_x | PSR_f | PSR_c | PSR_s},
  {"CPSR_xsfc",	TRUE, PSR_x | PSR_s | PSR_f | PSR_c},
  {"CPSR_xscf",	TRUE, PSR_x | PSR_s | PSR_c | PSR_f},
  {"CPSR_xcfs",	TRUE, PSR_x | PSR_c | PSR_f | PSR_s},
  {"CPSR_xcsf",	TRUE, PSR_x | PSR_c | PSR_s | PSR_f},
  {"CPSR_cfsx",	TRUE, PSR_c | PSR_f | PSR_s | PSR_x},
  {"CPSR_cfxs",	TRUE, PSR_c | PSR_f | PSR_x | PSR_s},
  {"CPSR_csfx",	TRUE, PSR_c | PSR_s | PSR_f | PSR_x},
  {"CPSR_csxf",	TRUE, PSR_c | PSR_s | PSR_x | PSR_f},
  {"CPSR_cxfs",	TRUE, PSR_c | PSR_x | PSR_f | PSR_s},
  {"CPSR_cxsf",	TRUE, PSR_c | PSR_x | PSR_s | PSR_f},
  {"SPSR_fs",	FALSE, PSR_f | PSR_s},
  {"SPSR_fx",	FALSE, PSR_f | PSR_x},
  {"SPSR_fc",	FALSE, PSR_f | PSR_c},
  {"SPSR_sf",	FALSE, PSR_s | PSR_f},
  {"SPSR_sx",	FALSE, PSR_s | PSR_x},
  {"SPSR_sc",	FALSE, PSR_s | PSR_c},
  {"SPSR_xf",	FALSE, PSR_x | PSR_f},
  {"SPSR_xs",	FALSE, PSR_x | PSR_s},
  {"SPSR_xc",	FALSE, PSR_x | PSR_c},
  {"SPSR_cf",	FALSE, PSR_c | PSR_f},
  {"SPSR_cs",	FALSE, PSR_c | PSR_s},
  {"SPSR_cx",	FALSE, PSR_c | PSR_x},
  {"SPSR_fsx",	FALSE, PSR_f | PSR_s | PSR_x},
  {"SPSR_fsc",	FALSE, PSR_f | PSR_s | PSR_c},
  {"SPSR_fxs",	FALSE, PSR_f | PSR_x | PSR_s},
  {"SPSR_fxc",	FALSE, PSR_f | PSR_x | PSR_c},
  {"SPSR_fcs",	FALSE, PSR_f | PSR_c | PSR_s},
  {"SPSR_fcx",	FALSE, PSR_f | PSR_c | PSR_x},
  {"SPSR_sfx",	FALSE, PSR_s | PSR_f | PSR_x},
  {"SPSR_sfc",	FALSE, PSR_s | PSR_f | PSR_c},
  {"SPSR_sxf",	FALSE, PSR_s | PSR_x | PSR_f},
  {"SPSR_sxc",	FALSE, PSR_s | PSR_x | PSR_c},
  {"SPSR_scf",	FALSE, PSR_s | PSR_c | PSR_f},
  {"SPSR_scx",	FALSE, PSR_s | PSR_c | PSR_x},
  {"SPSR_xfs",	FALSE, PSR_x | PSR_f | PSR_s},
  {"SPSR_xfc",	FALSE, PSR_x | PSR_f | PSR_c},
  {"SPSR_xsf",	FALSE, PSR_x | PSR_s | PSR_f},
  {"SPSR_xsc",	FALSE, PSR_x | PSR_s | PSR_c},
  {"SPSR_xcf",	FALSE, PSR_x | PSR_c | PSR_f},
  {"SPSR_xcs",	FALSE, PSR_x | PSR_c | PSR_s},
  {"SPSR_cfs",	FALSE, PSR_c | PSR_f | PSR_s},
  {"SPSR_cfx",	FALSE, PSR_c | PSR_f | PSR_x},
  {"SPSR_csf",	FALSE, PSR_c | PSR_s | PSR_f},
  {"SPSR_csx",	FALSE, PSR_c | PSR_s | PSR_x},
  {"SPSR_cxf",	FALSE, PSR_c | PSR_x | PSR_f},
  {"SPSR_cxs",	FALSE, PSR_c | PSR_x | PSR_s},
  {"SPSR_fsxc",	FALSE, PSR_f | PSR_s | PSR_x | PSR_c},
  {"SPSR_fscx",	FALSE, PSR_f | PSR_s | PSR_c | PSR_x},
  {"SPSR_fxsc",	FALSE, PSR_f | PSR_x | PSR_s | PSR_c},
  {"SPSR_fxcs",	FALSE, PSR_f | PSR_x | PSR_c | PSR_s},
  {"SPSR_fcsx",	FALSE, PSR_f | PSR_c | PSR_s | PSR_x},
  {"SPSR_fcxs",	FALSE, PSR_f | PSR_c | PSR_x | PSR_s},
  {"SPSR_sfxc",	FALSE, PSR_s | PSR_f | PSR_x | PSR_c},
  {"SPSR_sfcx",	FALSE, PSR_s | PSR_f | PSR_c | PSR_x},
  {"SPSR_sxfc",	FALSE, PSR_s | PSR_x | PSR_f | PSR_c},
  {"SPSR_sxcf",	FALSE, PSR_s | PSR_x | PSR_c | PSR_f},
  {"SPSR_scfx",	FALSE, PSR_s | PSR_c | PSR_f | PSR_x},
  {"SPSR_scxf",	FALSE, PSR_s | PSR_c | PSR_x | PSR_f},
  {"SPSR_xfsc",	FALSE, PSR_x | PSR_f | PSR_s | PSR_c},
  {"SPSR_xfcs",	FALSE, PSR_x | PSR_f | PSR_c | PSR_s},
  {"SPSR_xsfc",	FALSE, PSR_x | PSR_s | PSR_f | PSR_c},
  {"SPSR_xscf",	FALSE, PSR_x | PSR_s | PSR_c | PSR_f},
  {"SPSR_xcfs",	FALSE, PSR_x | PSR_c | PSR_f | PSR_s},
  {"SPSR_xcsf",	FALSE, PSR_x | PSR_c | PSR_s | PSR_f},
  {"SPSR_cfsx",	FALSE, PSR_c | PSR_f | PSR_s | PSR_x},
  {"SPSR_cfxs",	FALSE, PSR_c | PSR_f | PSR_x | PSR_s},
  {"SPSR_csfx",	FALSE, PSR_c | PSR_s | PSR_f | PSR_x},
  {"SPSR_csxf",	FALSE, PSR_c | PSR_s | PSR_x | PSR_f},
  {"SPSR_cxfs",	FALSE, PSR_c | PSR_x | PSR_f | PSR_s},
  {"SPSR_cxsf",	FALSE, PSR_c | PSR_x | PSR_s | PSR_f},
};

enum wreg_type
  {
    IWMMXT_REG_WR = 0,
    IWMMXT_REG_WC = 1,
    IWMMXT_REG_WR_OR_WC = 2,
    IWMMXT_REG_WCG
  };

enum iwmmxt_insn_type
{
  check_rd,
  check_wr,
  check_wrwr,
  check_wrwrwr,
  check_wrwrwcg,
  check_tbcst,
  check_tmovmsk,
  check_tmia,
  check_tmcrr,
  check_tmrrc,
  check_tmcr,
  check_tmrc,
  check_tinsr,
  check_textrc,
  check_waligni,
  check_textrm,
  check_wshufh
};

enum vfp_dp_reg_pos
{
  VFP_REG_Dd, VFP_REG_Dm, VFP_REG_Dn
d312 3
a314 8
/* VFP system registers.  */
struct vfp_reg
{
  const char *name;
  unsigned long regno;
};

static const struct vfp_reg vfp_regs[] =
d316 17
a332 6
  {"fpsid", 0x00000000},
  {"FPSID", 0x00000000},
  {"fpscr", 0x00010000},
  {"FPSCR", 0x00010000},
  {"fpexc", 0x00080000},
  {"FPEXC", 0x00080000}
d338 26
a363 3
  const char * name;
  int          number;
  bfd_boolean  builtin;
d367 2
a368 2
#define REG_SP  13
#define REG_LR  14
a370 210
#define wr_register(reg)  ((reg ^ WR_PREFIX) >= 0 && (reg ^ WR_PREFIX) <= 15)
#define wc_register(reg)  ((reg ^ WC_PREFIX) >= 0 && (reg ^ WC_PREFIX) <= 15)
#define wcg_register(reg) ((reg ^ WC_PREFIX) >= 8 && (reg ^ WC_PREFIX) <= 11)

/* These are the standard names.  Users can add aliases with .req.
   and delete them with .unreq.  */

/* Integer Register Numbers.  */
static const struct reg_entry rn_table[] =
{
  {"r0",  0, TRUE},  {"r1",  1, TRUE},      {"r2",  2, TRUE},      {"r3",  3, TRUE},
  {"r4",  4, TRUE},  {"r5",  5, TRUE},      {"r6",  6, TRUE},      {"r7",  7, TRUE},
  {"r8",  8, TRUE},  {"r9",  9, TRUE},      {"r10", 10, TRUE},     {"r11", 11, TRUE},
  {"r12", 12, TRUE}, {"r13", REG_SP, TRUE}, {"r14", REG_LR, TRUE}, {"r15", REG_PC, TRUE},
  /* ATPCS Synonyms.  */
  {"a1",  0, TRUE},  {"a2",  1, TRUE},      {"a3",  2, TRUE},      {"a4",  3, TRUE},
  {"v1",  4, TRUE},  {"v2",  5, TRUE},      {"v3",  6, TRUE},      {"v4",  7, TRUE},
  {"v5",  8, TRUE},  {"v6",  9, TRUE},      {"v7",  10, TRUE},     {"v8",  11, TRUE},
  /* Well-known aliases.  */
  {"wr",  7, TRUE},  {"sb",  9, TRUE},      {"sl",  10, TRUE},     {"fp",  11, TRUE},
  {"ip",  12, TRUE}, {"sp",  REG_SP, TRUE}, {"lr",  REG_LR, TRUE}, {"pc",  REG_PC, TRUE},
  {NULL, 0, TRUE}
};

#define WR_PREFIX 0x200
#define WC_PREFIX 0x400

static const struct reg_entry iwmmxt_table[] =
{
  /* Intel Wireless MMX technology register names.  */
  {  "wr0", 0x0 | WR_PREFIX, TRUE},   {"wr1", 0x1 | WR_PREFIX, TRUE},
  {  "wr2", 0x2 | WR_PREFIX, TRUE},   {"wr3", 0x3 | WR_PREFIX, TRUE},
  {  "wr4", 0x4 | WR_PREFIX, TRUE},   {"wr5", 0x5 | WR_PREFIX, TRUE},
  {  "wr6", 0x6 | WR_PREFIX, TRUE},   {"wr7", 0x7 | WR_PREFIX, TRUE},
  {  "wr8", 0x8 | WR_PREFIX, TRUE},   {"wr9", 0x9 | WR_PREFIX, TRUE},
  { "wr10", 0xa | WR_PREFIX, TRUE},  {"wr11", 0xb | WR_PREFIX, TRUE},
  { "wr12", 0xc | WR_PREFIX, TRUE},  {"wr13", 0xd | WR_PREFIX, TRUE},
  { "wr14", 0xe | WR_PREFIX, TRUE},  {"wr15", 0xf | WR_PREFIX, TRUE},
  { "wcid", 0x0 | WC_PREFIX, TRUE},  {"wcon", 0x1 | WC_PREFIX, TRUE},
  {"wcssf", 0x2 | WC_PREFIX, TRUE}, {"wcasf", 0x3 | WC_PREFIX, TRUE},
  {"wcgr0", 0x8 | WC_PREFIX, TRUE}, {"wcgr1", 0x9 | WC_PREFIX, TRUE},
  {"wcgr2", 0xa | WC_PREFIX, TRUE}, {"wcgr3", 0xb | WC_PREFIX, TRUE},

  {  "wR0", 0x0 | WR_PREFIX, TRUE},   {"wR1", 0x1 | WR_PREFIX, TRUE},
  {  "wR2", 0x2 | WR_PREFIX, TRUE},   {"wR3", 0x3 | WR_PREFIX, TRUE},
  {  "wR4", 0x4 | WR_PREFIX, TRUE},   {"wR5", 0x5 | WR_PREFIX, TRUE},
  {  "wR6", 0x6 | WR_PREFIX, TRUE},   {"wR7", 0x7 | WR_PREFIX, TRUE},
  {  "wR8", 0x8 | WR_PREFIX, TRUE},   {"wR9", 0x9 | WR_PREFIX, TRUE},
  { "wR10", 0xa | WR_PREFIX, TRUE},  {"wR11", 0xb | WR_PREFIX, TRUE},
  { "wR12", 0xc | WR_PREFIX, TRUE},  {"wR13", 0xd | WR_PREFIX, TRUE},
  { "wR14", 0xe | WR_PREFIX, TRUE},  {"wR15", 0xf | WR_PREFIX, TRUE},
  { "wCID", 0x0 | WC_PREFIX, TRUE},  {"wCon", 0x1 | WC_PREFIX, TRUE},
  {"wCSSF", 0x2 | WC_PREFIX, TRUE}, {"wCASF", 0x3 | WC_PREFIX, TRUE},
  {"wCGR0", 0x8 | WC_PREFIX, TRUE}, {"wCGR1", 0x9 | WC_PREFIX, TRUE},
  {"wCGR2", 0xa | WC_PREFIX, TRUE}, {"wCGR3", 0xb | WC_PREFIX, TRUE},
  {NULL, 0, TRUE}
};

/* Co-processor Numbers.  */
static const struct reg_entry cp_table[] =
{
  {"p0",  0, TRUE},  {"p1",  1, TRUE},  {"p2",  2, TRUE},  {"p3", 3, TRUE},
  {"p4",  4, TRUE},  {"p5",  5, TRUE},  {"p6",  6, TRUE},  {"p7", 7, TRUE},
  {"p8",  8, TRUE},  {"p9",  9, TRUE},  {"p10", 10, TRUE}, {"p11", 11, TRUE},
  {"p12", 12, TRUE}, {"p13", 13, TRUE}, {"p14", 14, TRUE}, {"p15", 15, TRUE},
  {NULL, 0, TRUE}
};

/* Co-processor Register Numbers.  */
static const struct reg_entry cn_table[] =
{
  {"c0",   0, TRUE},  {"c1",   1, TRUE},  {"c2",   2, TRUE},  {"c3",   3, TRUE},
  {"c4",   4, TRUE},  {"c5",   5, TRUE},  {"c6",   6, TRUE},  {"c7",   7, TRUE},
  {"c8",   8, TRUE},  {"c9",   9, TRUE},  {"c10",  10, TRUE}, {"c11",  11, TRUE},
  {"c12",  12, TRUE}, {"c13",  13, TRUE}, {"c14",  14, TRUE}, {"c15",  15, TRUE},
  /* Not really valid, but kept for back-wards compatibility.  */
  {"cr0",  0, TRUE},  {"cr1",  1, TRUE},  {"cr2",  2, TRUE},  {"cr3",  3, TRUE},
  {"cr4",  4, TRUE},  {"cr5",  5, TRUE},  {"cr6",  6, TRUE},  {"cr7",  7, TRUE},
  {"cr8",  8, TRUE},  {"cr9",  9, TRUE},  {"cr10", 10, TRUE}, {"cr11", 11, TRUE},
  {"cr12", 12, TRUE}, {"cr13", 13, TRUE}, {"cr14", 14, TRUE}, {"cr15", 15, TRUE},
  {NULL, 0, TRUE}
};

/* FPA Registers.  */
static const struct reg_entry fn_table[] =
{
  {"f0", 0, TRUE},   {"f1", 1, TRUE},   {"f2", 2, TRUE},   {"f3", 3, TRUE},
  {"f4", 4, TRUE},   {"f5", 5, TRUE},   {"f6", 6, TRUE},   {"f7", 7, TRUE},
  {NULL, 0, TRUE}
};

/* VFP SP Registers.  */
static const struct reg_entry sn_table[] =
{
  {"s0",  0, TRUE},  {"s1",  1, TRUE},  {"s2",  2, TRUE},  {"s3", 3, TRUE},
  {"s4",  4, TRUE},  {"s5",  5, TRUE},  {"s6",  6, TRUE},  {"s7", 7, TRUE},
  {"s8",  8, TRUE},  {"s9",  9, TRUE},  {"s10", 10, TRUE}, {"s11", 11, TRUE},
  {"s12", 12, TRUE}, {"s13", 13, TRUE}, {"s14", 14, TRUE}, {"s15", 15, TRUE},
  {"s16", 16, TRUE}, {"s17", 17, TRUE}, {"s18", 18, TRUE}, {"s19", 19, TRUE},
  {"s20", 20, TRUE}, {"s21", 21, TRUE}, {"s22", 22, TRUE}, {"s23", 23, TRUE},
  {"s24", 24, TRUE}, {"s25", 25, TRUE}, {"s26", 26, TRUE}, {"s27", 27, TRUE},
  {"s28", 28, TRUE}, {"s29", 29, TRUE}, {"s30", 30, TRUE}, {"s31", 31, TRUE},
  {NULL, 0, TRUE}
};

/* VFP DP Registers.  */
static const struct reg_entry dn_table[] =
{
  {"d0",  0, TRUE},  {"d1",  1, TRUE},  {"d2",  2, TRUE},  {"d3", 3, TRUE},
  {"d4",  4, TRUE},  {"d5",  5, TRUE},  {"d6",  6, TRUE},  {"d7", 7, TRUE},
  {"d8",  8, TRUE},  {"d9",  9, TRUE},  {"d10", 10, TRUE}, {"d11", 11, TRUE},
  {"d12", 12, TRUE}, {"d13", 13, TRUE}, {"d14", 14, TRUE}, {"d15", 15, TRUE},
  {NULL, 0, TRUE}
};

/* Maverick DSP coprocessor registers.  */
static const struct reg_entry mav_mvf_table[] =
{
  {"mvf0",  0, TRUE},  {"mvf1",  1, TRUE},  {"mvf2",  2, TRUE},  {"mvf3",  3, TRUE},
  {"mvf4",  4, TRUE},  {"mvf5",  5, TRUE},  {"mvf6",  6, TRUE},  {"mvf7",  7, TRUE},
  {"mvf8",  8, TRUE},  {"mvf9",  9, TRUE},  {"mvf10", 10, TRUE}, {"mvf11", 11, TRUE},
  {"mvf12", 12, TRUE}, {"mvf13", 13, TRUE}, {"mvf14", 14, TRUE}, {"mvf15", 15, TRUE},
  {NULL, 0, TRUE}
};

static const struct reg_entry mav_mvd_table[] =
{
  {"mvd0",  0, TRUE},  {"mvd1",  1, TRUE},  {"mvd2",  2, TRUE},  {"mvd3",  3, TRUE},
  {"mvd4",  4, TRUE},  {"mvd5",  5, TRUE},  {"mvd6",  6, TRUE},  {"mvd7",  7, TRUE},
  {"mvd8",  8, TRUE},  {"mvd9",  9, TRUE},  {"mvd10", 10, TRUE}, {"mvd11", 11, TRUE},
  {"mvd12", 12, TRUE}, {"mvd13", 13, TRUE}, {"mvd14", 14, TRUE}, {"mvd15", 15, TRUE},
  {NULL, 0, TRUE}
};

static const struct reg_entry mav_mvfx_table[] =
{
  {"mvfx0",  0, TRUE},  {"mvfx1",  1, TRUE},  {"mvfx2",  2, TRUE},  {"mvfx3",  3, TRUE},
  {"mvfx4",  4, TRUE},  {"mvfx5",  5, TRUE},  {"mvfx6",  6, TRUE},  {"mvfx7",  7, TRUE},
  {"mvfx8",  8, TRUE},  {"mvfx9",  9, TRUE},  {"mvfx10", 10, TRUE}, {"mvfx11", 11, TRUE},
  {"mvfx12", 12, TRUE}, {"mvfx13", 13, TRUE}, {"mvfx14", 14, TRUE}, {"mvfx15", 15, TRUE},
  {NULL, 0, TRUE}
};

static const struct reg_entry mav_mvdx_table[] =
{
  {"mvdx0",  0, TRUE},  {"mvdx1",  1, TRUE},  {"mvdx2",  2, TRUE},  {"mvdx3",  3, TRUE},
  {"mvdx4",  4, TRUE},  {"mvdx5",  5, TRUE},  {"mvdx6",  6, TRUE},  {"mvdx7",  7, TRUE},
  {"mvdx8",  8, TRUE},  {"mvdx9",  9, TRUE},  {"mvdx10", 10, TRUE}, {"mvdx11", 11, TRUE},
  {"mvdx12", 12, TRUE}, {"mvdx13", 13, TRUE}, {"mvdx14", 14, TRUE}, {"mvdx15", 15, TRUE},
  {NULL, 0, TRUE}
};

static const struct reg_entry mav_mvax_table[] =
{
  {"mvax0", 0, TRUE}, {"mvax1", 1, TRUE}, {"mvax2", 2, TRUE}, {"mvax3", 3, TRUE},
  {NULL, 0, TRUE}
};

static const struct reg_entry mav_dspsc_table[] =
{
  {"dspsc", 0, TRUE},
  {NULL, 0, TRUE}
};

struct reg_map
{
  const struct reg_entry * names;
  int                      max_regno;
  struct hash_control *    htab;
  const char *             expected;
};

struct reg_map all_reg_maps[] =
{
  {rn_table,        15, NULL, N_("ARM register expected")},
  {cp_table,        15, NULL, N_("bad or missing co-processor number")},
  {cn_table,        15, NULL, N_("co-processor register expected")},
  {fn_table,         7, NULL, N_("FPA register expected")},
  {sn_table,	    31, NULL, N_("VFP single precision register expected")},
  {dn_table,	    15, NULL, N_("VFP double precision register expected")},
  {mav_mvf_table,   15, NULL, N_("Maverick MVF register expected")},
  {mav_mvd_table,   15, NULL, N_("Maverick MVD register expected")},
  {mav_mvfx_table,  15, NULL, N_("Maverick MVFX register expected")},
  {mav_mvdx_table,  15, NULL, N_("Maverick MVDX register expected")},
  {mav_mvax_table,   3, NULL, N_("Maverick MVAX register expected")},
  {mav_dspsc_table,  0, NULL, N_("Maverick DSPSC register expected")},
  {iwmmxt_table,    23, NULL, N_("Intel Wireless MMX technology register expected")},
};

/* Enumeration matching entries in table above.  */
enum arm_reg_type
{
  REG_TYPE_RN = 0,
#define REG_TYPE_FIRST REG_TYPE_RN
  REG_TYPE_CP = 1,
  REG_TYPE_CN = 2,
  REG_TYPE_FN = 3,
  REG_TYPE_SN = 4,
  REG_TYPE_DN = 5,
  REG_TYPE_MVF = 6,
  REG_TYPE_MVD = 7,
  REG_TYPE_MVFX = 8,
  REG_TYPE_MVDX = 9,
  REG_TYPE_MVAX = 10,
  REG_TYPE_DSPSC = 11,
  REG_TYPE_IWMMXT = 12,

  REG_TYPE_MAX = 13
};

d373 1
a373 19
#define INSN_SIZE       4

/* "INSN<cond> X,Y" where X:bit12, Y:bit16.  */
#define MAV_MODE1	0x100c

/* "INSN<cond> X,Y" where X:bit16, Y:bit12.  */
#define MAV_MODE2	0x0c10

/* "INSN<cond> X,Y" where X:bit12, Y:bit16.  */
#define MAV_MODE3	0x100c

/* "INSN<cond> X,Y,Z" where X:16, Y:0, Z:12.  */
#define MAV_MODE4	0x0c0010

/* "INSN<cond> X,Y,Z" where X:12, Y:16, Z:0.  */
#define MAV_MODE5	0x00100c

/* "INSN<cond> W,X,Y,Z" where W:5, X:12, Y:16, Z:0.  */
#define MAV_MODE6	0x00100c05
d378 7
a384 1
  const char * template;
d387 1
a387 1
  unsigned long value;
d389 2
a390 3
  /* Offset into the template where the condition code (if any) will be.
     If zero, then the instruction is never conditional.  */
  unsigned cond_offset;
d393 5
a397 1
  unsigned long variant;
d399 2
a400 2
  /* Function to call to parse args.  */
  void (* parms) (char *);
d406 1
a406 1
#define HWOFFSET_IMM    0x00400000
d457 2
a458 1
#define T_OPCODE_LSR_R  0x40c0
d488 1
a488 1
#define T_OPCODE_BRANCH 0xe7fe
a490 18
#define THUMB_REG_LO	0x1
#define THUMB_REG_HI	0x2
#define THUMB_REG_ANY	0x3

#define THUMB_H1	0x0080
#define THUMB_H2	0x0040

#define THUMB_ASR 0
#define THUMB_LSL 1
#define THUMB_LSR 2

#define THUMB_MOVE 0
#define THUMB_COMPARE 1
#define THUMB_CPY 2

#define THUMB_LOAD 0
#define THUMB_STORE 1

d492 1
d494 13
a506 32
/* These three are used for immediate shifts, do not alter.  */
#define THUMB_WORD 2
#define THUMB_HALFWORD 1
#define THUMB_BYTE 0

struct thumb_opcode
{
  /* Basic string to match.  */
  const char * template;

  /* Basic instruction code.  */
  unsigned long value;

  int size;

  /* Which CPU variants this exists for.  */
  unsigned long variant;

  /* Function to call to parse args.  */
  void (* parms) (char *);
};

#define BAD_ARGS 	_("bad arguments to instruction")
#define BAD_PC 		_("r15 not allowed here")
#define BAD_COND 	_("instruction is not conditional")
#define ERR_NO_ACCUM	_("acc0 expected")

static struct hash_control * arm_ops_hsh   = NULL;
static struct hash_control * arm_tops_hsh  = NULL;
static struct hash_control * arm_cond_hsh  = NULL;
static struct hash_control * arm_shift_hsh = NULL;
static struct hash_control * arm_psr_hsh   = NULL;
d515 1
a515 1
              <insn>
a520 4
/* Literal Pool stuff.  */

#define MAX_LITERAL_POOL_SIZE 1024

d524 1
d527 6
a532 6
  expressionS    literals [MAX_LITERAL_POOL_SIZE];
  unsigned int   next_free_entry;
  unsigned int   id;
  symbolS *      symbol;
  segT           section;
  subsegT        sub_section;
d538 17
d556 7
a562 4
static literal_pool *
find_literal_pool (void)
{
  literal_pool * pool;
d564 1
a564 6
  for (pool = list_of_pools; pool != NULL; pool = pool->next)
    {
      if (pool->section == now_seg
	  && pool->sub_section == now_subseg)
	break;
    }
d566 3
a568 2
  return pool;
}
d570 1
a570 6
static literal_pool *
find_or_make_literal_pool (void)
{
  /* Next literal pool ID number.  */
  static unsigned int latest_pool_num = 1;
  literal_pool *      pool;
d572 1
a572 1
  pool = find_literal_pool ();
d574 4
a577 1
  if (pool == NULL)
d579 9
a587 4
      /* Create a new pool.  */
      pool = xmalloc (sizeof (* pool));
      if (! pool)
	return NULL;
d589 1
a589 5
      pool->next_free_entry = 0;
      pool->section         = now_seg;
      pool->sub_section     = now_subseg;
      pool->next            = list_of_pools;
      pool->symbol          = NULL;
d591 5
a595 3
      /* Add it to the list.  */
      list_of_pools = pool;
    }
d597 1
a597 2
  /* New pools, and emptied pools, will have a NULL symbol.  */
  if (pool->symbol == NULL)
d599 3
a601 3
      pool->symbol = symbol_create (FAKE_LABEL_NAME, undefined_section,
				    (valueT) 0, &zero_address_frag);
      pool->id = latest_pool_num ++;
d604 1
a604 2
  /* Done.  */
  return pool;
d607 6
a612 2
/* Add the literal in the global 'inst'
   structure to the relevent literal pool.  */
d615 1
a615 1
add_to_lit_pool (void)
d617 2
a618 15
  literal_pool * pool;
  unsigned int entry;

  pool = find_or_make_literal_pool ();

  /* Check if this literal value is already in the pool.  */
  for (entry = 0; entry < pool->next_free_entry; entry ++)
    {
      if ((pool->literals[entry].X_op == inst.reloc.exp.X_op)
	  && (inst.reloc.exp.X_op == O_constant)
	  && (pool->literals[entry].X_add_number
	      == inst.reloc.exp.X_add_number)
	  && (pool->literals[entry].X_unsigned
	      == inst.reloc.exp.X_unsigned))
	break;
d620 3
a622 10
      if ((pool->literals[entry].X_op == inst.reloc.exp.X_op)
          && (inst.reloc.exp.X_op == O_symbol)
          && (pool->literals[entry].X_add_number
	      == inst.reloc.exp.X_add_number)
          && (pool->literals[entry].X_add_symbol
	      == inst.reloc.exp.X_add_symbol)
          && (pool->literals[entry].X_op_symbol
	      == inst.reloc.exp.X_op_symbol))
        break;
    }
d624 1
a624 2
  /* Do we need to create a new entry?  */
  if (entry == pool->next_free_entry)
d626 3
a628 1
      if (entry >= MAX_LITERAL_POOL_SIZE)
d630 1
a630 1
	  inst.error = _("literal pool overflow");
d633 26
d660 11
a670 2
      pool->literals[entry] = inst.reloc.exp;
      pool->next_free_entry += 1;
d672 1
d674 14
a687 3
  inst.reloc.exp.X_op         = O_symbol;
  inst.reloc.exp.X_add_number = ((int) entry) * 4 - 8;
  inst.reloc.exp.X_add_symbol = pool->symbol;
d689 3
a691 1
  return SUCCESS;
d694 4
a697 2
/* Can't use symbol_new here, so have to create a symbol and then at
   a later date assign it a value. Thats what these functions do.  */
d699 6
a704 9
static void
symbol_locate (symbolS *    symbolP,
	       const char * name,	/* It is copied, the caller can modify.  */
	       segT         segment,	/* Segment identifier (SEG_<something>).  */
	       valueT       valu,	/* Symbol value.  */
	       fragS *      frag)	/* Associated fragment.  */
{
  unsigned int name_length;
  char * preserved_copy_of_name;
d706 1
a706 7
  name_length = strlen (name) + 1;   /* +1 for \0.  */
  obstack_grow (&notes, name, name_length);
  preserved_copy_of_name = obstack_finish (&notes);
#ifdef STRIP_UNDERSCORE
  if (preserved_copy_of_name[0] == '_')
    preserved_copy_of_name++;
#endif
d708 7
a714 4
#ifdef tc_canonicalize_symbol_name
  preserved_copy_of_name =
    tc_canonicalize_symbol_name (preserved_copy_of_name);
#endif
d716 8
a723 1
  S_SET_NAME (symbolP, preserved_copy_of_name);
d725 6
a730 3
  S_SET_SEGMENT (symbolP, segment);
  S_SET_VALUE (symbolP, valu);
  symbol_clear_list_pointers (symbolP);
d732 4
a735 1
  symbol_set_frag (symbolP, frag);
d737 4
a740 3
  /* Link to end of symbol chain.  */
  {
    extern int symbol_table_frozen;
d742 4
a745 3
    if (symbol_table_frozen)
      abort ();
  }
d747 4
a750 1
  symbol_append (symbolP, symbol_lastP, & symbol_rootP, & symbol_lastP);
d752 26
a777 1
  obj_symbol_new_hook (symbolP);
d779 2
a780 3
#ifdef tc_symbol_new_hook
  tc_symbol_new_hook (symbolP);
#endif
d782 7
a788 3
#ifdef DEBUG_SYMS
  verify_symbol_chain (symbol_rootP, symbol_lastP);
#endif /* DEBUG_SYMS  */
d791 1
a791 2
/* Check that an immediate is valid.
   If so, convert it to the right format.  */
d793 6
a798 2
static unsigned int
validate_immediate (unsigned int val)
d800 2
a801 2
  unsigned int a;
  unsigned int i;
d803 5
a807 1
#define rotate_left(v, n) (v << n | v >> (32 - n))
d809 10
a818 3
  for (i = 0; i < 32; i += 2)
    if ((a = rotate_left (val, i)) <= 0xff)
      return a | (i << 7); /* 12-bit pack: [shift-cnt,const].  */
d820 1
a820 2
  return FAIL;
}
d822 4
a825 3
/* Check to see if an immediate can be computed as two separate immediate
   values, added together.  We already know that this value cannot be
   computed by just one ARM instruction.  */
d827 2
a828 3
static unsigned int
validate_immediate_twopart (unsigned int   val,
			    unsigned int * highpart)
d830 21
a850 2
  unsigned int a;
  unsigned int i;
d852 1
a852 20
  for (i = 0; i < 32; i += 2)
    if (((a = rotate_left (val, i)) & 0xff) != 0)
      {
	if (a & 0xff00)
	  {
	    if (a & ~ 0xffff)
	      continue;
	    * highpart = (a  >> 8) | ((i + 24) << 7);
	  }
	else if (a & 0xff0000)
	  {
	    if (a & 0xff000000)
	      continue;
	    * highpart = (a >> 16) | ((i + 16) << 7);
	  }
	else
	  {
	    assert (a & 0xff000000);
	    * highpart = (a >> 24) | ((i + 8) << 7);
	  }
d854 2
a855 2
	return (a & 0xff) | (i << 7);
      }
d857 2
a858 1
  return FAIL;
d861 3
d865 1
a865 1
validate_offset_imm (unsigned int val, int hwse)
d867 2
a868 4
  if ((hwse && val > 255) || val > 4095)
    return FAIL;
  return val;
}
d870 2
a871 4

#ifdef OBJ_ELF
/* This code is to handle mapping symbols as defined in the ARM ELF spec.
   (This text is taken from version B-02 of the spec):
d873 11
a883 1
      4.4.7 Mapping and tagging symbols
d885 7
a891 68
      A section of an ARM ELF file can contain a mixture of ARM code,
      Thumb code, and data.  There are inline transitions between code
      and data at literal pool boundaries. There can also be inline
      transitions between ARM code and Thumb code, for example in
      ARM-Thumb inter-working veneers.  Linkers, machine-level
      debuggers, profiling tools, and disassembly tools need to map
      images accurately. For example, setting an ARM breakpoint on a
      Thumb location, or in a literal pool, can crash the program
      being debugged, ruining the debugging session.

      ARM ELF entities are mapped (see section 4.4.7.1 below) and
      tagged (see section 4.4.7.2 below) using local symbols (with
      binding STB_LOCAL).  To assist consumers, mapping and tagging
      symbols should be collated first in the symbol table, before
      other symbols with binding STB_LOCAL.

      To allow properly collated mapping and tagging symbols to be
      skipped by consumers that have no interest in them, the first
      such symbol should have the name $m and its st_value field equal
      to the total number of mapping and tagging symbols (including
      the $m) in the symbol table.

      4.4.7.1 Mapping symbols

      $a    Labels the first byte of a sequence of ARM instructions.
            Its type is STT_FUNC.

      $d    Labels the first byte of a sequence of data items.
            Its type is STT_OBJECT.

      $t    Labels the first byte of a sequence of Thumb instructions.
            Its type is STT_FUNC.

      This list of mapping symbols may be extended in the future.

      Section-relative mapping symbols

      Mapping symbols defined in a section define a sequence of
      half-open address intervals that cover the address range of the
      section. Each interval starts at the address defined by a
      mapping symbol, and continues up to, but not including, the
      address defined by the next (in address order) mapping symbol or
      the end of the section. A corollary is that there must be a
      mapping symbol defined at the beginning of each section.
      Consumers can ignore the size of a section-relative mapping
      symbol. Producers can set it to 0.

      Absolute mapping symbols

      Because of the need to crystallize a Thumb address with the
      Thumb-bit set, absolute symbol of type STT_FUNC (symbols of type
      STT_FUNC defined in section SHN_ABS) need to be mapped with $a
      or $t.

      The extent of a mapping symbol defined in SHN_ABS is [st_value,
      st_value + st_size), or [st_value, st_value + 1) if st_size = 0,
      where [x, y) denotes the half-open address range from x,
      inclusive, to y, exclusive.

      In the absence of a mapping symbol, a consumer can interpret a
      function symbol with an odd value as the Thumb code address
      obtained by clearing the least significant bit of the
      value. This interpretation is deprecated, and it may not work in
      the future.

   Note - the Tagging symbols ($b, $f, $p $m) have been dropped from
   the EABI (which is still under development), so they are not
   implemented here.  */
d893 6
a898 1
static enum mstate mapstate = MAP_UNDEFINED;
d900 11
a910 2
static void
mapping_state (enum mstate state)
d912 8
a919 3
  symbolS * symbolP;
  const char * symname;
  int type;
d921 4
a924 4
  if (mapstate == state)
    /* The mapping symbol has already been emitted.
       There is nothing else to do.  */
    return;
d926 4
a929 1
  mapstate = state;
d931 5
a935 19
  switch (state)
    {
    case MAP_DATA:
      symname = "$d";
      type = BSF_OBJECT;
      break;
    case MAP_ARM:
      symname = "$a";
      type = BSF_FUNCTION;
      break;
    case MAP_THUMB:
      symname = "$t";
      type = BSF_FUNCTION;
      break;
    case MAP_UNDEFINED:
      return;
    default:
      abort ();
    }
d937 3
a939 1
  seg_info (now_seg)->tc_segment_info_data = state;
d941 5
a945 3
  symbolP = symbol_new (symname, now_seg, (valueT) frag_now_fix (), frag_now);
  symbol_table_insert (symbolP);
  symbol_get_bfdsym (symbolP)->flags |= type | BSF_LOCAL;
d947 11
a957 7
  switch (state)
    {
    case MAP_ARM:
      THUMB_SET_FUNC (symbolP, 0);
      ARM_SET_THUMB (symbolP, 0);
      ARM_SET_INTERWORK (symbolP, support_interwork);
      break;
d959 5
a963 5
    case MAP_THUMB:
      THUMB_SET_FUNC (symbolP, 1);
      ARM_SET_THUMB (symbolP, 1);
      ARM_SET_INTERWORK (symbolP, support_interwork);
      break;
d965 6
a970 5
    case MAP_DATA:
    default:
      return;
    }
}
d972 9
a980 1
/* When we change sections we need to issue a new mapping symbol.  */
d982 2
a983 4
void
arm_elf_change_section (void)
{
  flagword flags;
d985 8
a992 4
  /* Link an unlinked unwind index table section to the .text section.  */
  if (elf_section_type (now_seg) == SHT_ARM_EXIDX
      && elf_linked_to_section (now_seg) == NULL)
    elf_linked_to_section (now_seg) = text_section;
d994 3
a996 2
  if (!SEG_NORMAL (now_seg))
    return;
d998 6
a1003 1
  flags = bfd_get_section_flags (stdoutput, now_seg);
d1005 9
a1013 3
  /* We can ignore sections that only contain debug info.  */
  if ((flags & SEC_ALLOC) == 0)
    return;
d1015 5
a1019 2
  mapstate = seg_info (now_seg)->tc_segment_info_data;
}
d1021 7
a1027 5
int
arm_elf_section_type (const char * str, size_t len)
{
  if (len == 5 && strncmp (str, "exidx", 5) == 0)
    return SHT_ARM_EXIDX;
d1029 2
a1030 1
  return -1;
d1032 4
a1035 6
#else
#define mapping_state(a)
#endif /* OBJ_ELF */

/* arm_reg_parse () := if it looks like a register, return its token and
   advance the pointer.  */
d1038 1
a1038 1
arm_reg_parse (char ** ccp, struct hash_control * htab)
d1040 8
a1047 4
  char * start = * ccp;
  char   c;
  char * p;
  struct reg_entry * reg;
d1049 1
a1049 12
#ifdef REGISTER_PREFIX
  if (*start != REGISTER_PREFIX)
    return FAIL;
  p = start + 1;
#else
  p = start;
#ifdef OPTIONAL_REGISTER_PREFIX
  if (*p == OPTIONAL_REGISTER_PREFIX)
    p++, start++;
#endif
#endif
  if (!ISALPHA (*p) || !is_name_beginner (*p))
d1052 1
a1052 3
  c = *p++;
  while (ISALPHA (c) || ISDIGIT (c) || c == '_')
    c = *p++;
d1054 6
a1059 5
  *--p = 0;
  reg = (struct reg_entry *) hash_find (htab, start);
  *p = c;

  if (reg)
d1061 2
a1062 2
      *ccp = p;
      return reg->number;
d1065 1
a1065 2
  return FAIL;
}
d1067 8
a1074 3
/* Search for the following register name in each of the possible reg name
   tables.  Return the classification if found, or REG_TYPE_MAX if not
   present.  */
d1076 2
a1077 4
static enum arm_reg_type
arm_reg_parse_any (char *cp)
{
  int i;
d1079 5
a1083 3
  for (i = (int) REG_TYPE_FIRST; i < (int) REG_TYPE_MAX; i++)
    if (arm_reg_parse (&cp, all_reg_maps[i].htab) != FAIL)
      return (enum arm_reg_type) i;
d1085 1
a1085 10
  return REG_TYPE_MAX;
}

static void
opcode_select (int width)
{
  switch (width)
    {
    case 16:
      if (! thumb_mode)
d1087 3
a1089 2
	  if (! (cpu_variant & ARM_EXT_V4T))
	    as_bad (_("selected processor does not support THUMB opcodes"));
d1091 2
a1092 7
	  thumb_mode = 1;
	  /* No need to force the alignment, since we will have been
             coming from ARM mode, which is word-aligned.  */
	  record_alignment (now_seg, 1);
	}
      mapping_state (MAP_THUMB);
      break;
d1094 1
a1094 2
    case 32:
      if (thumb_mode)
d1096 3
a1098 2
	  if ((cpu_variant & ARM_ALL) == ARM_EXT_V4T)
	    as_bad (_("selected processor does not support ARM opcodes"));
d1100 5
a1104 1
	  thumb_mode = 0;
d1106 28
a1133 2
	  if (!need_pass_2)
	    frag_align (2, 0, 0);
d1135 8
a1142 1
	  record_alignment (now_seg, 1);
d1144 90
a1233 2
      mapping_state (MAP_ARM);
      break;
d1235 5
a1239 2
    default:
      as_bad (_("invalid instruction size selected (%d)"), width);
d1241 33
d1276 2
d1288 1
a1288 1
       .unreq my_alias    */
a1295 1
  skip_whitespace (input_line_pointer);
d1306 3
a1308 1
  if (*name)
d1310 1
a1310 1
      enum arm_reg_type req_type = arm_reg_parse_any (name);
d1312 6
a1317 1
      if (req_type != REG_TYPE_MAX)
d1319 3
a1321 31
	  char *temp_name = name;
	  int req_no = arm_reg_parse (&temp_name, all_reg_maps[req_type].htab);

	  if (req_no != FAIL)
	    {
	      struct reg_entry *req_entry;

	      /* Check to see if this alias is a builtin one.  */
	      req_entry = hash_delete (all_reg_maps[req_type].htab, name);

	      if (!req_entry)
		as_bad (_("unreq: missing hash entry for \"%s\""), name);
	      else if (req_entry->builtin)
		/* FIXME: We are deleting a built in register alias which
		   points to a const data structure, so we only need to
		   free up the memory used by the key in the hash table.
		   Unfortunately we have not recorded this value, so this
		   is a memory leak.  */
		  /* FIXME: Should we issue a warning message ?  */
		;
	      else
		{
		  /* Deleting a user defined alias.  We need to free the
		     key and the value, but fortunately the key is the same
		     as the value->name field.  */
		  free ((char *) req_entry->name);
		  free (req_entry);
		}
	    }
          else
            as_bad (_(".unreq: unrecognized symbol \"%s\""), name);
a1322 2
      else
        as_bad (_(".unreq: unrecognized symbol \"%s\""), name);
a1323 2
  else
    as_bad (_("invalid syntax for .unreq directive"));
d1329 1
a1329 9
static void
s_bss (int ignore ATTRIBUTE_UNUSED)
{
  /* We don't support putting frags in the BSS segment, we fake it by
     marking in_bss, then looking at s_skip for clues.  */
  subseg_set (bss_section, 0);
  demand_empty_rest_of_line ();
  mapping_state (MAP_DATA);
}
d1331 5
a1335 6
static void
s_even (int ignore ATTRIBUTE_UNUSED)
{
  /* Never make frag if expect extra pass.  */
  if (!need_pass_2)
    frag_align (1, 0, 0);
d1337 1
a1337 4
  record_alignment (now_seg, 1);

  demand_empty_rest_of_line ();
}
d1340 1
a1340 1
s_ltorg (int ignored ATTRIBUTE_UNUSED)
d1342 3
a1344 3
  unsigned int entry;
  literal_pool * pool;
  char sym_name[20];
d1346 3
a1348 4
  pool = find_literal_pool ();
  if (pool == NULL
      || pool->symbol == NULL
      || pool->next_free_entry == 0)
d1351 1
a1351 1
  mapping_state (MAP_DATA);
d1353 19
a1371 4
  /* Align pool as you have word accesses.
     Only make a frag if we have to.  */
  if (!need_pass_2)
    frag_align (2, 0, 0);
d1373 1
a1373 1
  record_alignment (now_seg, 2);
d1375 3
a1377 1
  sprintf (sym_name, "$$lit_\002%x", pool->id);
d1379 7
a1385 3
  symbol_locate (pool->symbol, sym_name, now_seg,
		 (valueT) frag_now_fix (), frag_now);
  symbol_table_insert (pool->symbol);
d1387 5
a1391 1
  ARM_SET_THUMB (pool->symbol, thumb_mode);
d1393 7
a1399 2
#if defined OBJ_COFF || defined OBJ_ELF
  ARM_SET_INTERWORK (pool->symbol, support_interwork);
d1402 8
a1409 3
  for (entry = 0; entry < pool->next_free_entry; entry ++)
    /* First output the expression in the instruction to the pool.  */
    emit_expr (&(pool->literals[entry]), 4); /* .word  */
d1411 2
a1412 4
  /* Mark the pool as empty.  */
  pool->next_free_entry = 0;
  pool->symbol = NULL;
}
d1414 2
a1415 1
/* Same as s_align_ptwo but align 0 => align 2.  */
d1417 7
a1423 6
static void
s_align (int unused ATTRIBUTE_UNUSED)
{
  int temp;
  long temp_fill;
  long max_alignment = 15;
d1425 2
a1426 8
  temp = get_absolute_expression ();
  if (temp > max_alignment)
    as_bad (_("alignment too large: %d assumed"), temp = max_alignment);
  else if (temp < 0)
    {
      as_bad (_("alignment negative. 0 assumed."));
      temp = 0;
    }
d1428 1
a1428 1
  if (*input_line_pointer == ',')
d1430 2
a1431 2
      input_line_pointer++;
      temp_fill = get_absolute_expression ();
a1432 2
  else
    temp_fill = 0;
d1434 1
a1434 9
  if (!temp)
    temp = 2;

  /* Only make a frag if we HAVE to.  */
  if (temp && !need_pass_2)
    frag_align (temp, (int) temp_fill, 0);
  demand_empty_rest_of_line ();

  record_alignment (now_seg, temp);
d1438 73
a1510 1
s_force_thumb (int ignore ATTRIBUTE_UNUSED)
d1516 1
a1516 1
     target processor should not support interworking.  */
a1519 1

d1529 1
a1529 2
  if (! thumb_mode)
    opcode_select (16);
d1532 1
a1532 1
     We need to know this for the interworking support.  */
a1533 2

  demand_empty_rest_of_line ();
d1546 1
a1546 1
  char      delim;
d1553 2
a1554 2
  name      = input_line_pointer;
  delim     = get_symbol_end ();
a1557 2
  SKIP_WHITESPACE ();

d1582 1
a1582 1
         for this symbol.  */
d1617 1
a1617 1
  /* XXX Now we come to the Thumb specific bit of code.  */
d1626 5
d1632 1
a1632 1
s_arm (int ignore ATTRIBUTE_UNUSED)
d1634 15
a1648 1
  opcode_select (32);
d1652 3
a1654 6
static void
s_thumb (int ignore ATTRIBUTE_UNUSED)
{
  opcode_select (16);
  demand_empty_rest_of_line ();
}
d1657 1
a1657 1
s_code (int unused ATTRIBUTE_UNUSED)
d1660 2
d1664 3
a1666 1
  switch (temp)
d1668 3
a1670 4
    case 16:
    case 32:
      opcode_select (temp);
      break;
d1672 4
a1675 2
    default:
      as_bad (_("invalid operand to .code directive (%d) (expecting 16 or 32)"), temp);
d1677 12
d1692 1
a1692 1
end_of_line (char * str)
d1694 5
a1698 4
  skip_whitespace (str);

  if (*str != '\0' && !inst.error)
    inst.error = _("garbage following instruction");
d1701 2
a1702 2
static int
skip_past_comma (char ** str)
d1704 3
a1706 2
  char * p = * str, c;
  int comma = 0;
d1708 1
a1708 6
  while ((c = *p) == ' ' || c == ',')
    {
      p++;
      if (c == ',' && comma++)
	return FAIL;
    }
d1710 1
a1710 5
  if (c == '\0')
    return FAIL;

  *str = p;
  return comma ? SUCCESS : FAIL;
d1713 1
a1713 1
/* Return TRUE if anything in the expression is a bignum.  */
d1715 2
a1716 2
static int
walk_no_bignums (symbolS * sp)
d1718 1
a1718 2
  if (symbol_get_value_expression (sp)->X_op == O_big)
    return 1;
d1720 1
a1720 1
  if (symbol_get_value_expression (sp)->X_add_symbol)
d1722 3
a1724 3
      return (walk_no_bignums (symbol_get_value_expression (sp)->X_add_symbol)
	      || (symbol_get_value_expression (sp)->X_op_symbol
		  && walk_no_bignums (symbol_get_value_expression (sp)->X_op_symbol)));
d1727 1
a1727 1
  return 0;
d1730 2
a1731 4
static int in_my_get_expression = 0;

static int
my_get_expression (expressionS * ep, char ** str)
d1733 3
a1735 2
  char * save_in;
  segT   seg;
d1737 1
a1737 5
  save_in = input_line_pointer;
  input_line_pointer = *str;
  in_my_get_expression = 1;
  seg = expression (ep);
  in_my_get_expression = 0;
d1739 1
a1739 1
  if (ep->X_op == O_illegal)
d1741 10
a1750 5
      /* We found a bad expression in md_operand().  */
      *str = input_line_pointer;
      input_line_pointer = save_in;
      return 1;
    }
d1752 2
a1753 11
#ifdef OBJ_AOUT
  if (seg != absolute_section
      && seg != text_section
      && seg != data_section
      && seg != bss_section
      && seg != undefined_section)
    {
      inst.error = _("bad_segment");
      *str = input_line_pointer;
      input_line_pointer = save_in;
      return 1;
a1754 1
#endif
d1756 2
a1757 8
  /* Get rid of any bignums now, so that we don't generate an error for which
     we can't establish a line number later on.  Big numbers are never valid
     in instructions, which is where this routine is always called.  */
  if (ep->X_op == O_big
      || (ep->X_add_symbol
	  && (walk_no_bignums (ep->X_add_symbol)
	      || (ep->X_op_symbol
		  && walk_no_bignums (ep->X_op_symbol)))))
d1759 3
a1761 4
      inst.error = _("invalid constant");
      *str = input_line_pointer;
      input_line_pointer = save_in;
      return 1;
d1764 2
a1765 3
  *str = input_line_pointer;
  input_line_pointer = save_in;
  return 0;
d1768 2
a1769 4
/* A standard register must be given at this point.
   SHIFT is the place to put it in inst.instruction.
   Restores input start point on error.
   Returns the reg#, or FAIL.  */
d1772 1
a1772 1
reg_required_here (char ** str, int shift)
d1774 4
a1777 3
  static char buff [128]; /* XXX  */
  int         reg;
  char *      start = * str;
d1779 2
a1780 1
  if ((reg = arm_reg_parse (str, all_reg_maps[REG_TYPE_RN].htab)) != FAIL)
d1782 17
a1798 3
      if (shift >= 0)
	inst.instruction |= reg << shift;
      return reg;
d1801 12
a1812 2
  /* Restore the start point, we may have got a reg of the wrong class.  */
  *str = start;
d1814 3
a1816 4
  /* In the few cases where we might be able to accept something else
     this error can be overridden.  */
  sprintf (buff, _("register expected, not '%.100s'"), start);
  inst.error = buff;
d1818 1
a1818 1
  return FAIL;
d1821 12
a1832 5
/* A Intel Wireless MMX technology register
   must be given at this point.
   Shift is the place to put it in inst.instruction.
   Restores input start point on err.
   Returns the reg#, or FAIL.  */
d1834 3
a1836 40
static int
wreg_required_here (char ** str,
		    int shift,
		    enum wreg_type reg_type)
{
  static char buff [128];
  int    reg;
  char * start = *str;

  if ((reg = arm_reg_parse (str, all_reg_maps[REG_TYPE_IWMMXT].htab)) != FAIL)
    {
      if (wr_register (reg)
	  && (reg_type == IWMMXT_REG_WR || reg_type == IWMMXT_REG_WR_OR_WC))
        {
          if (shift >= 0)
            inst.instruction |= (reg ^ WR_PREFIX) << shift;
          return reg;
        }
      else if (wc_register (reg)
	       && (reg_type == IWMMXT_REG_WC || reg_type == IWMMXT_REG_WR_OR_WC))
        {
          if (shift >= 0)
            inst.instruction |= (reg ^ WC_PREFIX) << shift;
          return reg;
        }
      else if ((wcg_register (reg) && reg_type == IWMMXT_REG_WCG))
        {
          if (shift >= 0)
            inst.instruction |= ((reg ^ WC_PREFIX) - 8) << shift;
          return reg;
        }
    }

  /* Restore the start point, we may have got a reg of the wrong class.  */
  *str = start;

  /* In the few cases where we might be able to accept
     something else this error can be overridden.  */
  sprintf (buff, _("Intel Wireless MMX technology register expected, not '%.100s'"), start);
  inst.error = buff;
d1838 4
a1841 2
  return FAIL;
}
d1843 1
a1843 7
static const struct asm_psr *
arm_psr_parse (char ** ccp)
{
  char * start = * ccp;
  char   c;
  char * p;
  const struct asm_psr * psr;
d1845 3
a1847 1
  p = start;
d1849 1
a1849 6
  /* Skip to the end of the next word in the input stream.  */
  do
    {
      c = *p++;
    }
  while (ISALPHA (c) || c == '_');
d1851 3
a1853 2
  /* Terminate the word.  */
  *--p = 0;
d1855 3
a1857 6
  /* CPSR's and SPSR's can now be lowercase.  This is just a convenience
     feature for ease of use and backwards compatibility.  */
  if (!strncmp (start, "cpsr", 4))
    strncpy (start, "CPSR", 4);
  else if (!strncmp (start, "spsr", 4))
    strncpy (start, "SPSR", 4);
d1859 1
a1859 2
  /* Now locate the word in the psr hash table.  */
  psr = (const struct asm_psr *) hash_find (arm_psr_hsh, start);
d1861 1
a1861 2
  /* Restore the input stream.  */
  *p = c;
d1863 3
a1865 3
  /* If we found a valid match, advance the
     stream pointer past the end of the word.  */
  *ccp = p;
d1867 3
a1869 1
  return psr;
a1871 1
/* Parse the input looking for a PSR flag.  */
d1873 2
a1874 2
static int
psr_required_here (char ** str)
d1876 18
a1893 2
  char * start = * str;
  const struct asm_psr * psr;
d1895 1
a1895 1
  psr = arm_psr_parse (str);
d1897 3
a1899 5
  if (psr)
    {
      /* If this is the SPSR that is being modified, set the R bit.  */
      if (! psr->cpsr)
	inst.instruction |= SPSR_BIT;
d1901 1
a1901 2
      /* Set the psr flags in the MSR instruction.  */
      inst.instruction |= psr->field << PSR_SHIFT;
d1903 3
a1905 2
      return SUCCESS;
    }
d1907 3
a1909 3
  /* In the few cases where we might be able to accept
     something else this error can be overridden.  */
  inst.error = _("flag for {c}psr instruction expected");
d1911 3
a1913 3
  /* Restore the start point.  */
  *str = start;
  return FAIL;
d1916 13
a1928 2
static int
co_proc_number (char ** str)
d1930 11
a1940 2
  int processor, pchar;
  char *start;
d1942 3
a1944 2
  skip_whitespace (*str);
  start = *str;
d1946 2
a1947 5
  /* The data sheet seems to imply that just a number on its own is valid
     here, but the RISC iX assembler seems to accept a prefix 'p'.  We will
     accept either.  */
  if ((processor = arm_reg_parse (str, all_reg_maps[REG_TYPE_CP].htab))
      == FAIL)
d1949 4
a1952 1
      *str = start;
d1954 3
a1956 2
      pchar = *(*str)++;
      if (pchar >= '0' && pchar <= '9')
d1958 11
a1968 2
	  processor = pchar - '0';
	  if (**str >= '0' && **str <= '9')
d1970 14
a1983 2
	      processor = processor * 10 + *(*str)++ - '0';
	      if (processor > 15)
d1985 19
a2003 2
		  inst.error = _("illegal co-processor number");
		  return FAIL;
a2006 5
      else
	{
	  inst.error = all_reg_maps[REG_TYPE_CP].expected;
	  return FAIL;
	}
d2008 1
d2010 3
a2012 2
  inst.instruction |= processor << 8;
  return SUCCESS;
d2015 5
a2019 2
static int
cp_opc_expr (char ** str, int where, int length)
d2021 18
a2038 1
  expressionS expr;
d2040 3
a2042 1
  skip_whitespace (* str);
d2044 1
a2044 1
  memset (&expr, '\0', sizeof (expr));
d2046 1
a2046 7
  if (my_get_expression (&expr, str))
    return FAIL;
  if (expr.X_op != O_constant)
    {
      inst.error = _("bad or missing expression");
      return FAIL;
    }
d2048 4
a2051 5
  if ((expr.X_add_number & ((1 << length) - 1)) != expr.X_add_number)
    {
      inst.error = _("immediate co-processor expression too large");
      return FAIL;
    }
d2053 1
a2053 2
  inst.instruction |= expr.X_add_number << where;
  return SUCCESS;
d2056 1
a2056 5
static int
cp_reg_required_here (char ** str, int where)
{
  int    reg;
  char * start = *str;
d2058 1
a2058 5
  if ((reg = arm_reg_parse (str, all_reg_maps[REG_TYPE_CN].htab)) != FAIL)
    {
      inst.instruction |= reg << where;
      return reg;
    }
d2060 6
a2065 3
  /* In the few cases where we might be able to accept something else
     this error can be overridden.  */
  inst.error = all_reg_maps[REG_TYPE_CN].expected;
d2067 10
a2076 3
  /* Restore the start point.  */
  *str = start;
  return FAIL;
a2078 5
static int
fp_reg_required_here (char ** str, int where)
{
  int    reg;
  char * start = * str;
d2080 2
a2081 5
  if ((reg = arm_reg_parse (str, all_reg_maps[REG_TYPE_FN].htab)) != FAIL)
    {
      inst.instruction |= reg << where;
      return reg;
    }
d2083 6
a2088 3
  /* In the few cases where we might be able to accept something else
     this error can be overridden.  */
  inst.error = all_reg_maps[REG_TYPE_FN].expected;
d2090 1
a2090 3
  /* Restore the start point.  */
  *str = start;
  return FAIL;
d2093 4
a2096 2
static int
cp_address_offset (char ** str)
d2098 3
a2100 1
  int offset;
d2102 1
a2102 1
  skip_whitespace (* str);
d2104 5
a2108 5
  if (! is_immediate_prefix (**str))
    {
      inst.error = _("immediate expression expected");
      return FAIL;
    }
d2110 4
a2113 1
  (*str)++;
d2115 2
a2116 2
  if (my_get_expression (& inst.reloc.exp, str))
    return FAIL;
d2118 3
a2120 3
  if (inst.reloc.exp.X_op == O_constant)
    {
      offset = inst.reloc.exp.X_add_number;
d2122 16
a2137 5
      if (offset & 3)
	{
	  inst.error = _("co-processor address must be word aligned");
	  return FAIL;
	}
d2139 7
a2145 5
      if (offset > 1023 || offset < -1023)
	{
	  inst.error = _("offset too large");
	  return FAIL;
	}
d2147 3
a2149 4
      if (offset >= 0)
	inst.instruction |= INDEX_UP;
      else
	offset = -offset;
a2150 4
      inst.instruction |= offset >> 2;
    }
  else
    inst.reloc.type = BFD_RELOC_ARM_CP_OFF_IMM;
d2152 1
a2152 2
  return SUCCESS;
}
d2154 2
a2155 2
static int
cp_address_required_here (char ** str, int wb_ok)
d2157 3
a2159 3
  char * p = * str;
  int    pre_inc = 0;
  int    write_back = 0;
d2161 2
a2162 3
  if (*p == '[')
    {
      int reg;
a2163 2
      p++;
      skip_whitespace (p);
d2165 1
a2165 2
      if ((reg = reg_required_here (& p, 16)) == FAIL)
	return FAIL;
d2167 4
a2170 1
      skip_whitespace (p);
d2172 2
a2173 3
      if (*p == ']')
	{
	  p++;
d2175 1
a2175 1
	  skip_whitespace (p);
d2177 7
a2183 10
	  if (*p == '\0')
	    {
	      /* As an extension to the official ARM syntax we allow:
		   [Rn]
	         as a short hand for:
		   [Rn,#0]  */
	      inst.instruction |= PRE_INDEX | INDEX_UP;
	      *str = p;
	      return SUCCESS;
	    }
d2185 1
a2185 5
	  if (skip_past_comma (& p) == FAIL)
	    {
	      inst.error = _("comma expected after closing square bracket");
	      return FAIL;
	    }
d2187 2
a2188 1
	  skip_whitespace (p);
a2189 6
	  if (*p == '#')
	    {
	      if (wb_ok)
		{
		  /* [Rn], #expr  */
		  write_back = WRITE_BACK;
d2191 1
a2191 5
		  if (reg == REG_PC)
		    {
		      inst.error = _("pc may not be used in post-increment");
		      return FAIL;
		    }
d2193 4
a2196 9
		  if (cp_address_offset (& p) == FAIL)
		    return FAIL;
		}
	      else
		pre_inc = PRE_INDEX | INDEX_UP;
	    }
	  else if (*p == '{')
	    {
	      int option;
d2198 2
a2199 2
	      /* [Rn], {<expr>}  */
	      p++;
d2201 7
a2207 1
	      skip_whitespace (p);
a2208 2
	      if (my_get_expression (& inst.reloc.exp, & p))
		return FAIL;
d2210 1
a2210 3
	      if (inst.reloc.exp.X_op == O_constant)
		{
		  option = inst.reloc.exp.X_add_number;
d2212 6
a2217 5
		  if (option > 255 || option < 0)
		    {
		      inst.error = _("'option' field too large");
		      return FAIL;
		    }
d2219 7
a2225 1
		  skip_whitespace (p);
d2227 1
a2227 27
		  if (*p != '}')
		    {
		      inst.error = _("'}' expected at end of 'option' field");
		      return FAIL;
		    }
		  else
		    {
		      p++;
		      inst.instruction |= option;
		      inst.instruction |= INDEX_UP;
		    }
		}
	      else
		{
		  inst.error = _("non-constant expressions for 'option' field not supported");
		  return FAIL;
		}
	    }
	  else
	    {
	      inst.error = _("# or { expected after comma");
	      return FAIL;
	    }
	}
      else
	{
	  /* '['Rn, #expr']'[!]  */
d2229 11
a2239 5
	  if (skip_past_comma (& p) == FAIL)
	    {
	      inst.error = _("pre-indexed expression expected");
	      return FAIL;
	    }
d2241 14
a2254 27
	  pre_inc = PRE_INDEX;

	  if (cp_address_offset (& p) == FAIL)
	    return FAIL;

	  skip_whitespace (p);

	  if (*p++ != ']')
	    {
	      inst.error = _("missing ]");
	      return FAIL;
	    }

	  skip_whitespace (p);

	  if (wb_ok && *p == '!')
	    {
	      if (reg == REG_PC)
		{
		  inst.error = _("pc may not be used with write-back");
		  return FAIL;
		}

	      p++;
	      write_back = WRITE_BACK;
	    }
	}
d2258 8
a2265 2
      if (my_get_expression (&inst.reloc.exp, &p))
	return FAIL;
d2267 5
a2271 5
      inst.reloc.type = BFD_RELOC_ARM_CP_OFF_IMM;
      inst.reloc.exp.X_add_number -= 8;  /* PC rel adjust.  */
      inst.reloc.pc_rel = 1;
      inst.instruction |= (REG_PC << 16);
      pre_inc = PRE_INDEX;
d2274 6
a2279 3
  inst.instruction |= write_back | pre_inc;
  *str = p;
  return SUCCESS;
d2282 5
a2286 2
static int
cp_byte_address_offset (char ** str)
d2288 3
a2290 1
  int offset;
d2292 5
a2296 1
  skip_whitespace (* str);
d2298 1
a2298 1
  if (! is_immediate_prefix (**str))
d2300 3
a2302 2
      inst.error = _("immediate expression expected");
      return FAIL;
d2305 1
a2305 1
  (*str)++;
d2307 1
a2307 4
  if (my_get_expression (& inst.reloc.exp, str))
    return FAIL;

  if (inst.reloc.exp.X_op == O_constant)
d2309 4
a2312 1
      offset = inst.reloc.exp.X_add_number;
d2314 1
a2314 5
      if (offset > 255 || offset < -255)
        {
          inst.error = _("offset too large");
          return FAIL;
        }
d2316 5
a2320 6
      if (offset >= 0)
        inst.instruction |= INDEX_UP;
      else
        offset = -offset;

      inst.instruction |= offset;
d2323 7
a2329 1
    inst.reloc.type = BFD_RELOC_ARM_CP_OFF_IMM_S2;
a2330 2
  return SUCCESS;
}
d2332 4
a2335 2
static int
cp_byte_address_required_here (char ** str)
d2337 3
a2339 3
  char * p = * str;
  int    pre_inc = 0;
  int    write_back = 0;
d2341 2
a2342 1
  if (*p == '[')
d2344 4
a2347 1
      int reg;
d2349 1
a2349 2
      p++;
      skip_whitespace (p);
d2351 5
a2355 63
      if ((reg = reg_required_here (& p, 16)) == FAIL)
        return FAIL;

      skip_whitespace (p);

      if (*p == ']')
        {
          p++;

          if (skip_past_comma (& p) == SUCCESS)
            {
              /* [Rn], #expr */
              write_back = WRITE_BACK;

              if (reg == REG_PC)
                {
                  inst.error = _("pc may not be used in post-increment");
                  return FAIL;
                }

              if (cp_byte_address_offset (& p) == FAIL)
                return FAIL;
            }
          else
            pre_inc = PRE_INDEX | INDEX_UP;
        }
      else
        {
          /* '['Rn, #expr']'[!] */

          if (skip_past_comma (& p) == FAIL)
            {
              inst.error = _("pre-indexed expression expected");
              return FAIL;
            }

          pre_inc = PRE_INDEX;

          if (cp_byte_address_offset (& p) == FAIL)
            return FAIL;

          skip_whitespace (p);

          if (*p++ != ']')
            {
              inst.error = _("missing ]");
              return FAIL;
            }

          skip_whitespace (p);

          if (*p == '!')
            {
              if (reg == REG_PC)
                {
                  inst.error = _("pc may not be used with write-back");
                  return FAIL;
                }

              p++;
              write_back = WRITE_BACK;
            }
        }
d2359 6
a2364 2
      if (my_get_expression (&inst.reloc.exp, &p))
        return FAIL;
a2365 6
      inst.reloc.type = BFD_RELOC_ARM_CP_OFF_IMM_S2;
      inst.reloc.exp.X_add_number -= 8;  /* PC rel adjust.  */
      inst.reloc.pc_rel = 1;
      inst.instruction |= (REG_PC << 16);
      pre_inc = PRE_INDEX;
    }
d2367 1
a2367 4
  inst.instruction |= write_back | pre_inc;
  *str = p;
  return SUCCESS;
}
d2370 1
a2370 1
do_nop (char * str)
d2372 10
a2381 2
  skip_whitespace (str);
  if (*str == '{')
d2383 1
a2383 1
      str++;
d2385 1
a2385 3
      if (my_get_expression (&inst.reloc.exp, &str))
	inst.reloc.exp.X_op = O_illegal;
      else
d2387 2
a2388 5
	  skip_whitespace (str);
	  if (*str == '}')
	    str++;
	  else
	    inst.reloc.exp.X_op = O_illegal;
d2391 5
a2395 3
      if (inst.reloc.exp.X_op != O_constant
	  || inst.reloc.exp.X_add_number > 255
	  || inst.reloc.exp.X_add_number < 0)
d2397 14
a2410 2
	  inst.error = _("Invalid NOP hint");
	  return;
a2411 4

      /* Arcitectural NOP hints are CPSR sets with no bits selected.  */
      inst.instruction &= 0xf0000000;
      inst.instruction |= 0x0320f000 + inst.reloc.exp.X_add_number;
d2413 1
d2415 2
a2416 2
  end_of_line (str);
}
d2418 1
a2418 6
static void
do_empty (char * str)
{
  /* Do nothing really.  */
  end_of_line (str);
}
d2420 3
a2422 7
static void
do_mrs (char * str)
{
  int skip = 0;

  /* Only one syntax.  */
  skip_whitespace (str);
d2424 1
a2424 1
  if (reg_required_here (&str, 12) == FAIL)
d2426 2
a2427 2
      inst.error = BAD_ARGS;
      return;
d2430 4
a2433 1
  if (skip_past_comma (&str) == FAIL)
d2435 30
a2464 2
      inst.error = _("comma expected after register name");
      return;
d2467 28
a2494 17
  skip_whitespace (str);

  if (   streq (str, "CPSR")
      || streq (str, "SPSR")
	 /* Lower case versions for backwards compatibility.  */
      || streq (str, "cpsr")
      || streq (str, "spsr"))
    skip = 4;

  /* This is for backwards compatibility with older toolchains.  */
  else if (   streq (str, "cpsr_all")
	   || streq (str, "spsr_all"))
    skip = 8;
  else
    {
      inst.error = _("CPSR or SPSR expected");
      return;
d2497 3
a2499 5
  if (* str == 's' || * str == 'S')
    inst.instruction |= SPSR_BIT;
  str += skip;

  end_of_line (str);
a2501 4
/* Two possible forms:
      "{C|S}PSR_<field>, Rm",
      "{C|S}PSR_f, #expression".  */

d2503 1
a2503 1
do_msr (char * str)
d2505 4
a2508 1
  skip_whitespace (str);
d2510 2
a2511 2
  if (psr_required_here (& str) == FAIL)
    return;
d2513 1
a2513 1
  if (skip_past_comma (& str) == FAIL)
d2515 1
a2515 3
      inst.error = _("comma missing after psr flags");
      return;
    }
d2517 5
a2521 1
  skip_whitespace (str);
d2523 4
a2526 6
  if (reg_required_here (& str, 0) != FAIL)
    {
      inst.error = NULL;
      end_of_line (str);
      return;
    }
d2528 17
a2544 5
  if (! is_immediate_prefix (* str))
    {
      inst.error =
	_("only a register or immediate value can follow a psr flag");
      return;
d2546 1
d2548 2
a2549 2
  str ++;
  inst.error = NULL;
d2551 1
a2551 6
  if (my_get_expression (& inst.reloc.exp, & str))
    {
      inst.error =
	_("only a register or immediate value can follow a psr flag");
      return;
    }
d2553 3
a2555 13
#if 0  /* The first edition of the ARM architecture manual stated that
	  writing anything other than the flags with an immediate operation
	  had UNPREDICTABLE effects.  This constraint was removed in the
	  second edition of the specification.  */
  if ((cpu_variant & ARM_EXT_V5) != ARM_EXT_V5
      && inst.instruction & ((PSR_c | PSR_x | PSR_s) << PSR_SHIFT))
    {
      inst.error = _("immediate value cannot be used to set this field");
      return;
    }
#endif

  inst.instruction |= INST_IMMEDIATE;
d2557 1
a2557 1
  if (inst.reloc.exp.X_add_symbol)
d2559 2
a2560 2
      inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;
      inst.reloc.pc_rel = 0;
d2562 6
a2567 9
  else
    {
      unsigned value = validate_immediate (inst.reloc.exp.X_add_number);

      if (value == (unsigned) FAIL)
	{
	  inst.error = _("invalid constant");
	  return;
	}
a2568 2
      inst.instruction |= value;
    }
d2570 1
a2570 9
  inst.error = NULL;
  end_of_line (str);
}

/* Long Multiply Parser
   UMULL RdLo, RdHi, Rm, Rs
   SMULL RdLo, RdHi, Rm, Rs
   UMLAL RdLo, RdHi, Rm, Rs
   SMLAL RdLo, RdHi, Rm, Rs.  */
d2573 1
a2573 1
do_mull (char * str)
d2575 3
a2577 1
  int rdlo, rdhi, rm, rs;
d2579 2
a2580 2
  /* Only one format "rdlo, rdhi, rm, rs".  */
  skip_whitespace (str);
d2582 1
a2582 1
  if ((rdlo = reg_required_here (&str, 12)) == FAIL)
d2584 2
a2585 2
      inst.error = BAD_ARGS;
      return;
d2588 3
a2590 2
  if (skip_past_comma (&str) == FAIL
      || (rdhi = reg_required_here (&str, 16)) == FAIL)
d2592 2
a2593 1
      inst.error = BAD_ARGS;
d2597 1
a2597 2
  if (skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL)
d2599 8
a2606 1
      inst.error = BAD_ARGS;
a2607 1
    }
d2609 4
a2612 3
  /* rdhi, rdlo and rm must all be different.  */
  if (rdlo == rdhi || rdlo == rm || rdhi == rm)
    as_tsktsk (_("rdhi, rdlo and rm must all be different"));
d2614 3
a2616 5
  if (skip_past_comma (&str) == FAIL
      || (rs = reg_required_here (&str, 8)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
d2618 1
a2619 5
  if (rdhi == REG_PC || rdhi == REG_PC || rdhi == REG_PC || rdhi == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
d2621 1
a2621 2
  end_of_line (str);
}
d2624 1
a2624 1
do_mul (char * str)
d2626 2
a2627 1
  int rd, rm;
d2629 2
a2630 4
  /* Only one format "rd, rm, rs".  */
  skip_whitespace (str);

  if ((rd = reg_required_here (&str, 16)) == FAIL)
d2632 2
a2633 1
      inst.error = BAD_ARGS;
d2636 1
d2638 1
a2638 1
  if (rd == REG_PC)
d2640 1
a2640 1
      inst.error = BAD_PC;
d2644 14
a2657 6
  if (skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
d2659 4
a2662 5
  if (rm == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
d2664 2
a2665 2
  if (rm == rd)
    as_tsktsk (_("rd and rm should be different in mul"));
d2667 1
a2667 2
  if (skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 8)) == FAIL)
d2669 2
a2670 1
      inst.error = BAD_ARGS;
d2674 3
a2676 5
  if (rm == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
d2678 1
a2678 1
  end_of_line (str);
d2681 2
d2684 1
a2684 1
do_mla (char * str)
d2686 3
a2688 1
  int rd, rm;
d2690 5
a2694 2
  /* Only one format "rd, rm, rs, rn".  */
  skip_whitespace (str);
d2696 1
a2696 1
  if ((rd = reg_required_here (&str, 16)) == FAIL)
d2698 2
a2699 1
      inst.error = BAD_ARGS;
d2703 2
a2704 1
  if (rd == REG_PC)
d2706 2
a2707 2
      inst.error = BAD_PC;
      return;
d2709 2
d2712 1
a2712 6
  if (skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
d2714 1
a2714 1
  if (rm == REG_PC)
d2716 2
a2717 1
      inst.error = BAD_PC;
d2721 8
a2728 2
  if (rm == rd)
    as_tsktsk (_("rd and rm should be different in mla"));
d2730 1
a2730 8
  if (skip_past_comma (&str) == FAIL
      || (rd = reg_required_here (&str, 8)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 12)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
d2732 11
a2742 1
  if (rd == REG_PC || rm == REG_PC)
d2744 2
a2745 2
      inst.error = BAD_PC;
      return;
d2747 2
d2750 1
a2750 28
  end_of_line (str);
}

/* Expects *str -> the characters "acc0", possibly with leading blanks.
   Advances *str to the next non-alphanumeric.
   Returns 0, or else FAIL (in which case sets inst.error).

  (In a future XScale, there may be accumulators other than zero.
  At that time this routine and its callers can be upgraded to suit.)  */

static int
accum0_required_here (char ** str)
{
  static char buff [128];	/* Note the address is taken.  Hence, static.  */
  char * p = * str;
  char   c;
  int result = 0;		/* The accum number.  */

  skip_whitespace (p);

  *str = p;			/* Advance caller's string pointer too.  */
  c = *p++;
  while (ISALNUM (c))
    c = *p++;

  *--p = 0;			/* Aap nul into input buffer at non-alnum.  */

  if (! ( streq (*str, "acc0") || streq (*str, "ACC0")))
d2752 3
a2754 3
      sprintf (buff, _("acc0 expected, not '%.100s'"), *str);
      inst.error = buff;
      result = FAIL;
d2757 1
a2757 4
  *p = c;			/* Unzap.  */
  *str = p;			/* Caller's string pointer to after match.  */
  return result;
}
d2759 2
a2760 6
static int
ldst_extend_v4 (char ** str)
{
  int add = INDEX_UP;

  switch (**str)
d2762 1
a2762 7
    case '#':
    case '$':
      (*str)++;
      if (my_get_expression (& inst.reloc.exp, str))
	return FAIL;

      if (inst.reloc.exp.X_op == O_constant)
d2764 2
a2765 18
	  int value = inst.reloc.exp.X_add_number;

	  if (value < -255 || value > 255)
	    {
	      inst.error = _("address offset too large");
	      return FAIL;
	    }

	  if (value < 0)
	    {
	      value = -value;
	      add = 0;
	    }

	  /* Halfword and signextension instructions have the
             immediate value split across bits 11..8 and bits 3..0.  */
	  inst.instruction |= (add | HWOFFSET_IMM
			       | ((value >> 4) << 8) | (value & 0xF));
d2767 1
a2767 1
      else
d2769 3
a2771 3
	  inst.instruction |= HWOFFSET_IMM;
	  inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM8;
	  inst.reloc.pc_rel = 0;
d2773 1
a2773 1
      return SUCCESS;
d2775 3
a2777 3
    case '-':
      add = 0;
      /* Fall through.  */
d2779 2
a2780 3
    case '+':
      (*str)++;
      /* Fall through.  */
d2782 3
a2784 3
    default:
      if (reg_required_here (str, 0) == FAIL)
	return FAIL;
d2786 1
a2786 3
      inst.instruction |= add;
      return SUCCESS;
    }
d2788 7
d2796 42
a2837 4
/* Expects **str -> after a comma. May be leading blanks.
   Advances *str, recognizing a load  mode, and setting inst.instruction.
   Returns rn, or else FAIL (in which case may set inst.error
   and not advance str)
d2839 5
a2843 1
   Note: doesn't know Rd, so no err checks that require such knowledge.  */
d2846 2
a2847 1
ld_mode_required_here (char ** string)
d2849 7
a2855 3
  char * str = * string;
  int    rn;
  int    pre_inc = 0;
d2857 5
a2861 1
  skip_whitespace (str);
d2863 3
a2865 3
  if (* str == '[')
    {
      str++;
d2867 2
a2868 1
      skip_whitespace (str);
d2870 8
a2877 2
      if ((rn = reg_required_here (& str, 16)) == FAIL)
	return FAIL;
d2879 2
a2880 1
      skip_whitespace (str);
d2882 3
a2884 1
      if (* str == ']')
d2886 1
a2886 17
	  str ++;

	  if (skip_past_comma (& str) == SUCCESS)
	    {
	      /* [Rn],... (post inc) */
	      if (ldst_extend_v4 (&str) == FAIL)
		return FAIL;
	    }
	  else 	      /* [Rn] */
	    {
	      skip_whitespace (str);

	      if (* str == '!')
		{
		  str ++;
		  inst.instruction |= WRITE_BACK;
		}
d2888 4
a2891 3
	      inst.instruction |= INDEX_UP | HWOFFSET_IMM;
	      pre_inc = 1;
	    }
d2893 1
a2893 7
      else	  /* [Rn,...] */
	{
	  if (skip_past_comma (& str) == FAIL)
	    {
	      inst.error = _("pre-indexed expression expected");
	      return FAIL;
	    }
d2895 4
a2898 1
	  pre_inc = 1;
d2900 1
a2900 2
	  if (ldst_extend_v4 (&str) == FAIL)
	    return FAIL;
d2902 7
a2908 3
	  skip_whitespace (str);

	  if (* str ++ != ']')
d2910 2
a2911 2
	      inst.error = _("missing ]");
	      return FAIL;
d2914 1
a2914 3
	  skip_whitespace (str);

	  if (* str == '!')
d2916 2
a2917 2
	      str ++;
	      inst.instruction |= WRITE_BACK;
d2921 8
a2928 5
  else if (* str == '=')	/* ldr's "r,=label" syntax */
    /* We should never reach here, because <text> = <expression> is
       caught gas/read.c read_a_source_file() as a .set operation.  */
    return FAIL;
  else				/* PC +- 8 bit immediate offset.  */
d2930 11
a2940 2
      if (my_get_expression (& inst.reloc.exp, & str))
	return FAIL;
d2942 8
a2949 8
      inst.instruction            |= HWOFFSET_IMM;	/* The I bit.  */
      inst.reloc.type              = BFD_RELOC_ARM_OFFSET_IMM8;
      inst.reloc.exp.X_add_number -= 8;  		/* PC rel adjust.  */
      inst.reloc.pc_rel            = 1;
      inst.instruction            |= (REG_PC << 16);

      rn = REG_PC;
      pre_inc = 1;
d2952 4
a2955 4
  inst.instruction |= (pre_inc ? PRE_INDEX : 0);
  * string = str;

  return rn;
d2958 5
a2962 4
/* ARM V5E (El Segundo) signed-multiply-accumulate (argument parse)
   SMLAxy{cond} Rd,Rm,Rs,Rn
   SMLAWy{cond} Rd,Rm,Rs,Rn
   Error if any register is R15.  */
d2964 1
a2964 2
static void
do_smla (char * str)
d2966 3
a2968 1
  int rd, rm, rs, rn;
d2970 9
a2978 10
  skip_whitespace (str);

  if ((rd = reg_required_here (& str, 16)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rm = reg_required_here (& str, 0)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rs = reg_required_here (& str, 8)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rn = reg_required_here (& str, 12)) == FAIL)
    inst.error = BAD_ARGS;
d2980 2
a2981 2
  else if (rd == REG_PC || rm == REG_PC || rs == REG_PC || rn == REG_PC)
    inst.error = BAD_PC;
d2983 3
a2985 3
  else
    end_of_line (str);
}
d2987 2
a2988 4
/* ARM V5E (El Segundo) signed-multiply-accumulate-long (argument parse)
   SMLALxy{cond} Rdlo,Rdhi,Rm,Rs
   Error if any register is R15.
   Warning if Rdlo == Rdhi.  */
d2990 2
a2991 2
static void
do_smlal (char * str)
d2993 5
a2997 1
  int rdlo, rdhi, rm, rs;
d2999 2
a3000 1
  skip_whitespace (str);
d3002 1
a3002 7
  if ((rdlo = reg_required_here (& str, 12)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rdhi = reg_required_here (& str, 16)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rm = reg_required_here (& str, 0)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rs = reg_required_here (& str, 8)) == FAIL)
d3004 2
a3005 2
      inst.error = BAD_ARGS;
      return;
d3008 3
a3010 1
  if (rdlo == REG_PC || rdhi == REG_PC || rm == REG_PC || rs == REG_PC)
d3012 2
a3013 2
      inst.error = BAD_PC;
      return;
d3016 1
a3016 2
  if (rdlo == rdhi)
    as_tsktsk (_("rdhi and rdlo must be different"));
d3018 4
a3021 2
  end_of_line (str);
}
d3023 7
a3029 3
/* ARM V5E (El Segundo) signed-multiply (argument parse)
   SMULxy{cond} Rd,Rm,Rs
   Error if any register is R15.  */
d3031 7
a3037 4
static void
do_smul (char * str)
{
  int rd, rm, rs;
d3039 7
a3045 1
  skip_whitespace (str);
d3047 2
a3048 6
  if ((rd = reg_required_here (& str, 16)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rm = reg_required_here (& str, 0)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rs = reg_required_here (& str, 8)) == FAIL)
    inst.error = BAD_ARGS;
d3050 4
a3053 2
  else if (rd == REG_PC || rm == REG_PC || rs == REG_PC)
    inst.error = BAD_PC;
d3055 13
a3067 2
  else
    end_of_line (str);
d3070 1
a3070 3
/* ARM V5E (El Segundo) saturating-add/subtract (argument parse)
   Q[D]{ADD,SUB}{cond} Rd,Rm,Rn
   Error if any register is R15.  */
d3072 4
a3075 4
static void
do_qadd (char * str)
{
  int rd, rm, rn;
d3077 3
a3079 1
  skip_whitespace (str);
d3081 5
a3085 6
  if ((rd = reg_required_here (& str, 12)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rm = reg_required_here (& str, 0)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rn = reg_required_here (& str, 16)) == FAIL)
    inst.error = BAD_ARGS;
d3087 4
a3090 2
  else if (rd == REG_PC || rm == REG_PC || rn == REG_PC)
    inst.error = BAD_PC;
d3092 3
a3094 3
  else
    end_of_line (str);
}
d3096 2
a3097 3
/* ARM V5E (el Segundo)
   MCRRcc <coproc>, <opcode>, <Rd>, <Rn>, <CRm>.
   MRRCcc <coproc>, <opcode>, <Rd>, <Rn>, <CRm>.
d3099 3
a3101 2
   These are equivalent to the XScale instructions MAR and MRA,
   respectively, when coproc == 0, opcode == 0, and CRm == 0.
d3103 2
a3104 1
   Result unpredicatable if Rd or Rn is R15.  */
d3106 5
a3110 4
static void
do_co_reg2c (char * str)
{
  int rd, rn;
d3112 5
a3116 1
  skip_whitespace (str);
d3118 11
a3128 6
  if (co_proc_number (& str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d3130 4
a3133 6
  if (skip_past_comma (& str) == FAIL
      || cp_opc_expr (& str, 4, 4) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d3136 4
a3139 7
  if (skip_past_comma (& str) == FAIL
      || (rd = reg_required_here (& str, 12)) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d3141 2
a3142 7
  if (skip_past_comma (& str) == FAIL
      || (rn = reg_required_here (& str, 16)) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d3144 1
a3144 4
  /* Unpredictable result if rd or rn is R15.  */
  if (rd == REG_PC || rn == REG_PC)
    as_tsktsk
      (_("Warning: instruction unpredictable when using r15"));
d3146 4
a3149 7
  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 0) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d3151 1
a3151 2
  end_of_line (str);
}
d3153 1
a3153 4
/* ARM V5 count-leading-zeroes instruction (argument parse)
     CLZ{<cond>} <Rd>, <Rm>
     Condition defaults to COND_ALWAYS.
     Error if Rd or Rm are R15.  */
d3155 4
a3158 4
static void
do_clz (char * str)
{
  int rd, rm;
d3160 1
a3160 1
  skip_whitespace (str);
d3162 1
a3162 4
  if (((rd = reg_required_here (& str, 12)) == FAIL)
      || (skip_past_comma (& str) == FAIL)
      || ((rm = reg_required_here (& str, 0)) == FAIL))
    inst.error = BAD_ARGS;
d3164 1
a3164 2
  else if (rd == REG_PC || rm == REG_PC )
    inst.error = BAD_PC;
d3166 3
a3168 3
  else
    end_of_line (str);
}
d3170 2
a3171 5
/* ARM V5 (argument parse)
     LDC2{L} <coproc>, <CRd>, <addressing mode>
     STC2{L} <coproc>, <CRd>, <addressing mode>
     Instruction is not conditional, and has 0xf in the condition field.
     Otherwise, it's the same as LDC/STC.  */
d3173 2
a3174 2
static void
do_lstc2 (char * str)
d3176 2
a3177 1
  skip_whitespace (str);
d3179 1
a3179 1
  if (co_proc_number (& str) == FAIL)
d3181 9
a3189 18
      if (!inst.error)
	inst.error = BAD_ARGS;
    }
  else if (skip_past_comma (& str) == FAIL
	   || cp_reg_required_here (& str, 12) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
    }
  else if (skip_past_comma (& str) == FAIL
	   || cp_address_required_here (&str, CP_WB_OK) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
    }
  else
    end_of_line (str);
}
d3191 2
a3192 4
/* ARM V5 (argument parse)
     CDP2 <coproc>, <opcode_1>, <CRd>, <CRn>, <CRm>, <opcode_2>
     Instruction is not conditional, and has 0xf in the condition field.
     Otherwise, it's the same as CDP.  */
d3194 3
a3196 4
static void
do_cdp2 (char * str)
{
  skip_whitespace (str);
d3198 1
a3198 1
  if (co_proc_number (& str) == FAIL)
d3200 2
a3201 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d3203 2
d3206 1
a3206 2
  if (skip_past_comma (& str) == FAIL
      || cp_opc_expr (& str, 20,4) == FAIL)
d3208 9
a3216 4
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d3218 14
a3231 6
  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 12) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d3234 1
a3234 2
  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 16) == FAIL)
d3236 2
a3237 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d3240 2
a3241 7
  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 0) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d3243 1
a3243 1
  if (skip_past_comma (& str) == SUCCESS)
d3245 1
a3245 1
      if (cp_opc_expr (& str, 5, 3) == FAIL)
d3247 17
a3263 3
	  if (!inst.error)
	    inst.error = BAD_ARGS;
	  return;
d3265 4
a3268 1
    }
d3270 5
a3274 2
  end_of_line (str);
}
d3276 2
a3277 5
/* ARM V5 (argument parse)
     MCR2 <coproc>, <opcode_1>, <Rd>, <CRn>, <CRm>, <opcode_2>
     MRC2 <coproc>, <opcode_1>, <Rd>, <CRn>, <CRm>, <opcode_2>
     Instruction is not conditional, and has 0xf in the condition field.
     Otherwise, it's the same as MCR/MRC.  */
d3279 4
a3282 4
static void
do_co_reg2 (char * str)
{
  skip_whitespace (str);
d3284 15
a3298 5
  if (co_proc_number (& str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d3301 7
a3307 6
  if (skip_past_comma (& str) == FAIL
      || cp_opc_expr (& str, 21, 3) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d3309 3
d3313 1
a3313 7
  if (skip_past_comma (& str) == FAIL
      || reg_required_here (& str, 12) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d3315 7
a3321 7
  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 16) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d3323 20
a3342 7
  if (skip_past_comma (& str) == FAIL
      || cp_reg_required_here (& str, 0) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d3344 2
a3345 12
  if (skip_past_comma (& str) == SUCCESS)
    {
      if (cp_opc_expr (& str, 5, 3) == FAIL)
	{
	  if (!inst.error)
	    inst.error = BAD_ARGS;
	  return;
	}
    }

  end_of_line (str);
}
d3347 3
a3349 4
static void
do_bx (char * str)
{
  int reg;
d3351 3
a3353 1
  skip_whitespace (str);
d3355 3
a3357 1
  if ((reg = reg_required_here (&str, 0)) == FAIL)
d3359 4
a3362 2
      inst.error = BAD_ARGS;
      return;
d3364 2
d3367 3
a3369 5
  /* Note - it is not illegal to do a "bx pc".  Useless, but not illegal.  */
  if (reg == REG_PC)
    as_tsktsk (_("use of r15 in bx in ARM mode is not really useful"));

  end_of_line (str);
d3372 2
a3373 1
/* ARM v5TEJ.  Jump to Jazelle code.  */
d3375 2
a3376 2
static void
do_bxj (char * str)
d3378 13
a3390 1
  int reg;
d3392 4
a3395 1
  skip_whitespace (str);
d3397 2
a3398 1
  if ((reg = reg_required_here (&str, 0)) == FAIL)
d3400 2
a3401 2
      inst.error = BAD_ARGS;
      return;
d3404 2
a3405 5
  /* Note - it is not illegal to do a "bxj pc".  Useless, but not illegal.  */
  if (reg == REG_PC)
    as_tsktsk (_("use of r15 in bxj is not really useful"));

  end_of_line (str);
d3408 2
a3409 1
/* ARM V6 umaal (argument parse).  */
d3411 2
a3412 2
static void
do_umaal (char * str)
d3414 2
a3415 1
  int rdlo, rdhi, rm, rs;
d3417 5
a3421 8
  skip_whitespace (str);
  if ((rdlo = reg_required_here (& str, 12)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rdhi = reg_required_here (& str, 16)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rm = reg_required_here (& str, 0)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rs = reg_required_here (& str, 8)) == FAIL)
d3423 2
a3424 2
      inst.error = BAD_ARGS;
      return;
d3427 1
a3427 1
  if (rdlo == REG_PC || rdhi == REG_PC || rm == REG_PC || rs == REG_PC)
d3429 2
a3430 2
      inst.error = BAD_PC;
      return;
d3433 2
a3434 1
  end_of_line (str);
d3437 3
a3439 1
/* ARM V6 strex (argument parse).  */
d3441 2
a3442 2
static void
do_strex (char * str)
d3444 2
a3445 1
  int rd, rm, rn;
d3447 3
a3449 6
  /* Parse Rd, Rm,.  */
  skip_whitespace (str);
  if ((rd = reg_required_here (& str, 12)) == FAIL
      || skip_past_comma (& str) == FAIL
      || (rm = reg_required_here (& str, 0)) == FAIL
      || skip_past_comma (& str) == FAIL)
d3451 2
a3452 12
      inst.error = BAD_ARGS;
      return;
    }
  if (rd == REG_PC || rm == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
  if (rd == rm)
    {
      inst.error = _("Rd equal to Rm or Rn yields unpredictable results");
      return;
d3455 2
a3456 4
  /* Skip past '['.  */
  if ((strlen (str) >= 1)
      && strncmp (str, "[", 1) == 0)
    str += 1;
d3458 6
a3463 1
  skip_whitespace (str);
d3465 3
a3467 5
  /* Parse Rn.  */
  if ((rn = reg_required_here (& str, 16)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
a3468 18
  else if (rn == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
  if (rd == rn)
    {
      inst.error = _("Rd equal to Rm or Rn yields unpredictable results");
      return;
    }
  skip_whitespace (str);

  /* Skip past ']'.  */
  if ((strlen (str) >= 1)
      && strncmp (str, "]", 1) == 0)
    str += 1;

  end_of_line (str);
d3471 2
a3472 2
/* KIND indicates what kind of shifts are accepted.  */

d3474 1
a3474 1
decode_shift (char ** str, int kind)
d3476 2
a3477 5
  const struct asm_shift_name * shift;
  char * p;
  char   c;

  skip_whitespace (* str);
d3479 3
a3481 2
  for (p = * str; ISALPHA (* p); p ++)
    ;
d3483 2
a3484 1
  if (p == * str)
d3486 1
a3486 1
      inst.error = _("shift expression expected");
d3490 3
a3492 4
  c = * p;
  * p = '\0';
  shift = (const struct asm_shift_name *) hash_find (arm_shift_hsh, * str);
  * p = c;
d3494 4
a3497 5
  if (shift == NULL)
    {
      inst.error = _("shift expression expected");
      return FAIL;
    }
d3499 166
a3664 1
  assert (shift->properties->index == shift_properties[shift->properties->index].index);
d3666 5
a3670 19
  if (kind == SHIFT_LSL_OR_ASR_IMMEDIATE
      && shift->properties->index != SHIFT_LSL
      && shift->properties->index != SHIFT_ASR)
    {
      inst.error = _("'LSL' or 'ASR' required");
      return FAIL;
    }
  else if (kind == SHIFT_LSL_IMMEDIATE
	   && shift->properties->index != SHIFT_LSL)
    {
      inst.error = _("'LSL' required");
      return FAIL;
    }
  else if (kind == SHIFT_ASR_IMMEDIATE
	   && shift->properties->index != SHIFT_ASR)
    {
      inst.error = _("'ASR' required");
      return FAIL;
    }
d3672 42
a3713 6
  if (shift->properties->index == SHIFT_RRX)
    {
      * str = p;
      inst.instruction |= shift->properties->bit_field;
      return SUCCESS;
    }
d3715 5
a3719 1
  skip_whitespace (p);
d3721 4
a3724 14
  if (kind == NO_SHIFT_RESTRICT && reg_required_here (& p, 8) != FAIL)
    {
      inst.instruction |= shift->properties->bit_field | SHIFT_BY_REG;
      * str = p;
      return SUCCESS;
    }
  else if (! is_immediate_prefix (* p))
    {
      inst.error = (NO_SHIFT_RESTRICT
		    ? _("shift requires register or #expression")
		    : _("shift requires #expression"));
      * str = p;
      return FAIL;
    }
d3726 18
a3743 2
  inst.error = NULL;
  p ++;
d3745 21
a3765 2
  if (my_get_expression (& inst.reloc.exp, & p))
    return FAIL;
d3767 15
a3781 4
  /* Validate some simple #expressions.  */
  if (inst.reloc.exp.X_op == O_constant)
    {
      unsigned num = inst.reloc.exp.X_add_number;
d3783 11
a3793 19
      /* Reject operations greater than 32.  */
      if (num > 32
	  /* Reject a shift of 0 unless the mode allows it.  */
	  || (num == 0 && shift->properties->allows_0 == 0)
	  /* Reject a shift of 32 unless the mode allows it.  */
	  || (num == 32 && shift->properties->allows_32 == 0)
	  )
	{
	  /* As a special case we allow a shift of zero for
	     modes that do not support it to be recoded as an
	     logical shift left of zero (ie nothing).  We warn
	     about this though.  */
	  if (num == 0)
	    {
	      as_warn (_("shift of 0 ignored."));
	      shift = & shift_names[0];
	      assert (shift->properties->index == SHIFT_LSL);
	    }
	  else
d3795 2
a3796 2
	      inst.error = _("invalid immediate shift");
	      return FAIL;
d3798 33
d3833 26
a3858 4
      /* Shifts of 32 are encoded as 0, for those shifts that
	 support it.  */
      if (num == 32)
	num = 0;
d3860 3
a3862 8
      inst.instruction |= (num << 7) | shift->properties->bit_field;
    }
  else
    {
      inst.reloc.type   = BFD_RELOC_ARM_SHIFT_IMM;
      inst.reloc.pc_rel = 0;
      inst.instruction |= shift->properties->bit_field;
    }
d3864 3
a3866 3
  * str = p;
  return SUCCESS;
}
d3868 2
a3869 5
static void
do_sat (char ** str, int bias)
{
  int rd, rm;
  expressionS expr;
d3871 3
a3873 1
  skip_whitespace (*str);
d3875 7
a3881 12
  /* Parse <Rd>, field.  */
  if ((rd = reg_required_here (str, 12)) == FAIL
      || skip_past_comma (str) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
  if (rd == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
d3883 6
a3888 29
  /* Parse #<immed>,  field.  */
  if (is_immediate_prefix (**str))
    (*str)++;
  else
    {
      inst.error = _("immediate expression expected");
      return;
    }
  if (my_get_expression (&expr, str))
    {
      inst.error = _("bad expression");
      return;
    }
  if (expr.X_op != O_constant)
    {
      inst.error = _("constant expression expected");
      return;
    }
  if (expr.X_add_number + bias < 0
      || expr.X_add_number + bias > 31)
    {
      inst.error = _("immediate value out of range");
      return;
    }
  inst.instruction |= (expr.X_add_number + bias) << 16;
  if (skip_past_comma (str) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
d3891 3
a3893 11
  /* Parse <Rm> field.  */
  if ((rm = reg_required_here (str, 0)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
  if (rm == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
d3895 1
a3895 2
  if (skip_past_comma (str) == SUCCESS)
    decode_shift (str, SHIFT_LSL_OR_ASR_IMMEDIATE);
d3898 20
a3917 1
/* ARM V6 ssat (argument parse).  */
d3919 2
a3920 2
static void
do_ssat (char * str)
d3922 1
a3922 3
  do_sat (&str, /*bias=*/-1);
  end_of_line (str);
}
d3924 3
a3926 1
/* ARM V6 usat (argument parse).  */
d3928 1
a3928 5
static void
do_usat (char * str)
{
  do_sat (&str, /*bias=*/0);
  end_of_line (str);
d3931 4
a3934 2
static void
do_sat16 (char ** str, int bias)
d3936 1
a3936 2
  int rd, rm;
  expressionS expr;
d3938 2
a3939 1
  skip_whitespace (*str);
d3941 1
a3941 3
  /* Parse the <Rd> field.  */
  if ((rd = reg_required_here (str, 12)) == FAIL
      || skip_past_comma (str) == FAIL)
d3943 3
a3945 38
      inst.error = BAD_ARGS;
      return;
    }
  if (rd == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  /* Parse #<immed>, field.  */
  if (is_immediate_prefix (**str))
    (*str)++;
  else
    {
      inst.error = _("immediate expression expected");
      return;
    }
  if (my_get_expression (&expr, str))
    {
      inst.error = _("bad expression");
      return;
    }
  if (expr.X_op != O_constant)
    {
      inst.error = _("constant expression expected");
      return;
    }
  if (expr.X_add_number + bias < 0
      || expr.X_add_number + bias > 15)
    {
      inst.error = _("immediate value out of range");
      return;
    }
  inst.instruction |= (expr.X_add_number + bias) << 16;
  if (skip_past_comma (str) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
d3948 5
a3952 12
  /* Parse <Rm> field.  */
  if ((rm = reg_required_here (str, 0)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
  if (rm == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
}
d3954 3
a3956 1
/* ARM V6 ssat16 (argument parse).  */
d3958 1
a3958 5
static void
do_ssat16 (char * str)
{
  do_sat16 (&str, /*bias=*/-1);
  end_of_line (str);
d3960 1
d3963 1
a3963 1
do_usat16 (char * str)
d3965 5
a3969 3
  do_sat16 (&str, /*bias=*/0);
  end_of_line (str);
}
d3971 3
a3973 4
static void
do_cps_mode (char ** str)
{
  expressionS expr;
d3975 3
a3977 1
  skip_whitespace (*str);
d3979 2
a3980 4
  if (! is_immediate_prefix (**str))
    {
      inst.error = _("immediate expression expected");
      return;
d3982 1
d3984 8
a3991 2
  (*str)++; /* Strip off the immediate signifier.  */
  if (my_get_expression (&expr, str))
d3993 8
a4000 2
      inst.error = _("bad expression");
      return;
a4001 16

  if (expr.X_op != O_constant)
    {
      inst.error = _("constant expression expected");
      return;
    }

  /* The mode is a 5 bit field.  Valid values are 0-31.  */
  if (((unsigned) expr.X_add_number) > 31
      || (inst.reloc.exp.X_add_number) < 0)
    {
      inst.error = _("invalid constant");
      return;
    }

  inst.instruction |= expr.X_add_number;
a4003 2
/* ARM V6 srs (argument parse).  */

d4005 1
a4005 1
do_srs (char * str)
d4007 1
a4007 9
  char *exclam;
  skip_whitespace (str);
  exclam = strchr (str, '!');
  if (exclam)
    *exclam = '\0';
  do_cps_mode (&str);
  if (exclam)
    *exclam = '!';
  if (*str == '!')
d4009 2
a4010 2
      inst.instruction |= WRITE_BACK;
      str++;
d4012 2
a4013 1
  end_of_line (str);
d4016 1
a4016 2
/* ARM V6 SMMUL (argument parse).  */

d4018 1
a4018 1
do_smmul (char * str)
d4020 13
a4032 1
  int rd, rm, rs;
d4034 2
a4035 6
  skip_whitespace (str);
  if ((rd = reg_required_here (&str, 16)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rs = reg_required_here (&str, 8)) == FAIL)
d4037 3
a4039 2
      inst.error = BAD_ARGS;
      return;
d4041 1
a4041 4

  if (   rd == REG_PC
      || rm == REG_PC
      || rs == REG_PC)
d4043 1
a4043 1
      inst.error = BAD_PC;
d4047 6
a4052 1
  end_of_line (str);
d4055 4
a4058 2
/* ARM V6 SMLALD (argument parse).  */

d4060 1
a4060 1
do_smlald (char * str)
d4062 1
a4062 1
  int rdlo, rdhi, rm, rs;
d4064 1
a4064 8
  skip_whitespace (str);
  if ((rdlo = reg_required_here (&str, 12)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rdhi = reg_required_here (&str, 16)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rs = reg_required_here (&str, 8)) == FAIL)
d4066 14
a4079 2
      inst.error = BAD_ARGS;
      return;
d4081 1
a4081 5

  if (   rdlo == REG_PC
      || rdhi == REG_PC
      || rm == REG_PC
      || rs == REG_PC)
d4083 2
a4084 2
      inst.error = BAD_PC;
      return;
a4085 2

  end_of_line (str);
d4088 5
a4092 3
/* ARM V6 SMLAD (argument parse).  Signed multiply accumulate dual.
   smlad{x}{<cond>} Rd, Rm, Rs, Rn */

d4094 1
a4094 1
do_smlad (char * str)
d4096 1
a4096 10
  int rd, rm, rs, rn;

  skip_whitespace (str);
  if ((rd = reg_required_here (&str, 16)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rs = reg_required_here (&str, 8)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rn = reg_required_here (&str, 12)) == FAIL)
d4098 1
a4098 1
      inst.error = BAD_ARGS;
d4102 9
a4110 4
  if (   rd == REG_PC
      || rn == REG_PC
      || rs == REG_PC
      || rm == REG_PC)
d4112 3
a4114 2
      inst.error = BAD_PC;
      return;
a4115 2

  end_of_line (str);
d4118 6
a4123 1
/* Returns true if the endian-specifier indicates big-endianness.  */
d4126 1
a4126 1
do_endian_specifier (char * str)
d4128 1
a4128 1
  int big_endian = 0;
d4130 3
a4132 4
  skip_whitespace (str);
  if (strlen (str) < 2)
    inst.error = _("missing endian specifier");
  else if (strncasecmp (str, "BE", 2) == 0)
d4134 9
a4142 2
      str += 2;
      big_endian = 1;
a4143 4
  else if (strncasecmp (str, "LE", 2) == 0)
    str += 2;
  else
    inst.error = _("valid endian specifiers are be or le");
d4145 2
a4146 1
  end_of_line (str);
d4148 14
a4161 2
  return big_endian;
}
d4163 5
a4167 11
/* ARM V6 SETEND (argument parse).  Sets the E bit in the CPSR while
   preserving the other bits.

   setend <endian_specifier>, where <endian_specifier> is either
   BE or LE.  */

static void
do_setend (char * str)
{
  if (do_endian_specifier (str))
    inst.instruction |= 0x200;
d4170 6
a4175 1
/* ARM V6 SXTH.
d4177 1
a4177 3
   SXTH {<cond>} <Rd>, <Rm>{, <rotation>}
   Condition defaults to COND_ALWAYS.
   Error if any register uses R15.  */
d4179 2
a4180 2
static void
do_sxth (char * str)
d4182 1
a4182 11
  int rd, rm;
  expressionS expr;
  int rotation_clear_mask = 0xfffff3ff;
  int rotation_eight_mask = 0x00000400;
  int rotation_sixteen_mask = 0x00000800;
  int rotation_twenty_four_mask = 0x00000c00;

  skip_whitespace (str);
  if ((rd = reg_required_here (&str, 12)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL)
d4184 2
a4185 2
      inst.error = BAD_ARGS;
      return;
d4187 1
a4187 2

  else if (rd == REG_PC || rm == REG_PC)
d4189 2
a4190 2
      inst.error = BAD_PC;
      return;
d4192 1
a4192 6

  /* Zero out the rotation field.  */
  inst.instruction &= rotation_clear_mask;

  /* Check for lack of optional rotation field.  */
  if (skip_past_comma (&str) == FAIL)
d4194 21
a4214 3
      end_of_line (str);
      return;
    }
d4216 10
a4225 8
  /* Move past 'ROR'.  */
  skip_whitespace (str);
  if (strncasecmp (str, "ROR", 3) == 0)
    str += 3;
  else
    {
      inst.error = _("missing rotation field after comma");
      return;
d4228 1
a4228 5
  /* Get the immediate constant.  */
  skip_whitespace (str);
  if (is_immediate_prefix (* str))
    str++;
  else
d4230 2
a4231 2
      inst.error = _("immediate expression expected");
      return;
d4233 11
d4245 3
a4247 5
  if (my_get_expression (&expr, &str))
    {
      inst.error = _("bad expression");
      return;
    }
d4249 4
a4252 5
  if (expr.X_op != O_constant)
    {
      inst.error = _("constant expression expected");
      return;
    }
d4254 5
a4258 8
  switch (expr.X_add_number)
    {
    case 0:
      /* Rotation field has already been zeroed.  */
      break;
    case 8:
      inst.instruction |= rotation_eight_mask;
      break;
d4260 6
a4265 3
    case 16:
      inst.instruction |= rotation_sixteen_mask;
      break;
d4267 6
a4272 3
    case 24:
      inst.instruction |= rotation_twenty_four_mask;
      break;
d4274 6
a4279 4
    default:
      inst.error = _("rotation can be 8, 16, 24 or 0 when field is ommited");
      break;
    }
d4281 6
a4286 1
  end_of_line (str);
d4289 7
a4295 7
/* ARM V6 SXTAH extracts a 16-bit value from a register, sign
   extends it to 32-bits, and adds the result to a value in another
   register.  You can specify a rotation by 0, 8, 16, or 24 bits
   before extracting the 16-bit value.
   SXTAH{<cond>} <Rd>, <Rn>, <Rm>{, <rotation>}
   Condition defaults to COND_ALWAYS.
   Error if any register uses R15.  */
d4298 1
a4298 1
do_sxtah (char * str)
d4300 4
a4303 6
  int rd, rn, rm;
  expressionS expr;
  int rotation_clear_mask = 0xfffff3ff;
  int rotation_eight_mask = 0x00000400;
  int rotation_sixteen_mask = 0x00000800;
  int rotation_twenty_four_mask = 0x00000c00;
d4305 5
a4309 10
  skip_whitespace (str);
  if ((rd = reg_required_here (&str, 12)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rn = reg_required_here (&str, 16)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
d4311 6
a4316 5
  else if (rd == REG_PC || rn == REG_PC || rm == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
d4318 3
a4320 2
  /* Zero out the rotation field.  */
  inst.instruction &= rotation_clear_mask;
d4322 2
a4323 6
  /* Check for lack of optional rotation field.  */
  if (skip_past_comma (&str) == FAIL)
    {
      end_of_line (str);
      return;
    }
d4325 4
a4328 9
  /* Move past 'ROR'.  */
  skip_whitespace (str);
  if (strncasecmp (str, "ROR", 3) == 0)
    str += 3;
  else
    {
      inst.error = _("missing rotation field after comma");
      return;
    }
d4330 6
a4335 9
  /* Get the immediate constant.  */
  skip_whitespace (str);
  if (is_immediate_prefix (* str))
    str++;
  else
    {
      inst.error = _("immediate expression expected");
      return;
    }
d4337 4
a4340 5
  if (my_get_expression (&expr, &str))
    {
      inst.error = _("bad expression");
      return;
    }
d4342 4
a4345 5
  if (expr.X_op != O_constant)
    {
      inst.error = _("constant expression expected");
      return;
    }
d4347 7
a4353 5
  switch (expr.X_add_number)
    {
    case 0:
      /* Rotation field has already been zeroed.  */
      break;
d4355 9
a4363 3
    case 8:
      inst.instruction |= rotation_eight_mask;
      break;
d4365 11
a4375 3
    case 16:
      inst.instruction |= rotation_sixteen_mask;
      break;
d4377 4
a4380 3
    case 24:
      inst.instruction |= rotation_twenty_four_mask;
      break;
d4382 4
a4385 4
    default:
      inst.error = _("rotation can be 8, 16, 24 or 0 when field is ommited");
      break;
    }
d4387 8
a4394 1
  end_of_line (str);
d4397 10
d4408 5
a4412 5
/* ARM V6 RFE (Return from Exception) loads the PC and CPSR from the
   word at the specified address and the following word
   respectively.
   Unconditionally executed.
   Error if Rn is R15.  */
d4415 1
a4415 1
do_rfe (char * str)
d4417 2
a4418 1
  int rn;
d4420 3
a4422 1
  skip_whitespace (str);
d4424 4
a4427 4
  if ((rn = reg_required_here (&str, 16)) == FAIL)
    return;

  if (rn == REG_PC)
d4429 3
a4431 2
      inst.error = BAD_PC;
      return;
d4433 1
a4433 4

  skip_whitespace (str);

  if (*str == '!')
d4435 1
a4435 2
      inst.instruction |= WRITE_BACK;
      str++;
d4437 1
a4437 1
  end_of_line (str);
a4439 6
/* ARM V6 REV (Byte Reverse Word) reverses the byte order in a 32-bit
   register (argument parse).
   REV{<cond>} Rd, Rm.
   Condition defaults to COND_ALWAYS.
   Error if Rd or Rm are R15.  */

d4441 1
a4441 1
do_rev (char * str)
d4443 2
a4444 1
  int rd, rm;
d4446 7
a4452 1
  skip_whitespace (str);
d4454 9
a4462 7
  if ((rd = reg_required_here (&str, 12)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL)
    inst.error = BAD_ARGS;

  else if (rd == REG_PC || rm == REG_PC)
    inst.error = BAD_PC;
d4464 2
d4467 7
a4473 1
    end_of_line (str);
a4475 5
/* ARM V6 Perform Two Sixteen Bit Integer Additions. (argument parse).
   QADD16{<cond>} <Rd>, <Rn>, <Rm>
   Condition defaults to COND_ALWAYS.
   Error if Rd, Rn or Rm are R15.  */

d4477 1
a4477 1
do_qadd16 (char * str)
d4479 6
a4484 1
  int rd, rm, rn;
d4486 1
a4486 1
  skip_whitespace (str);
d4488 5
a4492 6
  if ((rd = reg_required_here (&str, 12)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rn = reg_required_here (&str, 16)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (rm = reg_required_here (&str, 0)) == FAIL)
    inst.error = BAD_ARGS;
d4494 2
a4495 2
  else if (rd == REG_PC || rm == REG_PC || rn == REG_PC)
    inst.error = BAD_PC;
d4497 12
a4508 2
  else
    end_of_line (str);
d4512 1
a4512 1
do_pkh_core (char * str, int shift)
d4514 3
a4516 1
  int rd, rn, rm;
d4518 7
a4524 10
  skip_whitespace (str);
  if (((rd = reg_required_here (&str, 12)) == FAIL)
      || (skip_past_comma (&str) == FAIL)
      || ((rn = reg_required_here (&str, 16)) == FAIL)
      || (skip_past_comma (&str) == FAIL)
      || ((rm = reg_required_here (&str, 0)) == FAIL))
    {
      inst.error = BAD_ARGS;
      return;
    }
d4526 16
a4541 5
  else if (rd == REG_PC || rn == REG_PC || rm == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
d4543 1
a4543 14
  /* Check for optional shift immediate constant.  */
  if (skip_past_comma (&str) == FAIL)
    {
      if (shift == SHIFT_ASR_IMMEDIATE)
	{
	  /* If the shift specifier is ommited, turn the instruction
	     into pkhbt rd, rm, rn.  First, switch the instruction
	     code, and clear the rn and rm fields.  */
	  inst.instruction &= 0xfff0f010;
	  /* Now, re-encode the registers.  */
	  inst.instruction |= (rm << 16) | rn;
	}
      return;
    }
d4545 2
a4546 2
  decode_shift (&str, shift);
}
d4548 1
a4548 4
/* ARM V6 Pack Halfword Bottom Top instruction (argument parse).
   PKHBT {<cond>} <Rd>, <Rn>, <Rm> {, LSL #<shift_imm>}
   Condition defaults to COND_ALWAYS.
   Error if Rd, Rn or Rm are R15.  */
d4551 1
a4551 1
do_pkhbt (char * str)
d4553 5
a4557 1
  do_pkh_core (str, SHIFT_LSL_IMMEDIATE);
d4560 6
a4565 1
/* ARM V6 PKHTB (Argument Parse).  */
d4568 1
a4568 1
do_pkhtb (char * str)
d4570 3
a4572 1
  do_pkh_core (str, SHIFT_ASR_IMMEDIATE);
a4574 6
/* ARM V6 Load Register Exclusive instruction (argument parse).
   LDREX{,B,D,H}{<cond>} <Rd, [<Rn>]
   Condition defaults to COND_ALWAYS.
   Error if Rd or Rn are R15.
   See ARMARMv6 A4.1.27: LDREX.  */

d4576 1
a4576 1
do_ldrex (char * str)
d4578 2
a4579 1
  int rd, rn;
d4581 5
a4585 1
  skip_whitespace (str);
d4587 1
a4587 3
  /* Parse Rd.  */
  if (((rd = reg_required_here (&str, 12)) == FAIL)
      || (skip_past_comma (&str) == FAIL))
d4589 22
a4610 2
      inst.error = BAD_ARGS;
      return;
d4612 7
a4618 6
  else if (rd == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
  skip_whitespace (str);
d4620 10
a4629 5
  /* Skip past '['.  */
  if ((strlen (str) >= 1)
      &&strncmp (str, "[", 1) == 0)
    str += 1;
  skip_whitespace (str);
d4631 4
a4634 2
  /* Parse Rn.  */
  if ((rn = reg_required_here (&str, 16)) == FAIL)
d4636 3
a4638 9
      inst.error = BAD_ARGS;
      return;
    }
  else if (rn == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
  skip_whitespace (str);
d4640 4
a4643 4
  /* Skip past ']'.  */
  if ((strlen (str) >= 1)
      && strncmp (str, "]", 1) == 0)
    str += 1;
d4645 7
a4651 5
  end_of_line (str);
}

/* ARM V6 change processor state instruction (argument parse)
      CPS, CPSIE, CSPID .  */
d4653 2
a4654 5
static void
do_cps (char * str)
{
  do_cps_mode (&str);
  end_of_line (str);
d4658 1
a4658 1
do_cps_flags (char ** str, int thumb_p)
d4660 5
a4664 12
  struct cps_flag
  {
    char character;
    unsigned long arm_value;
    unsigned long thumb_value;
  };
  static struct cps_flag flag_table[] =
  {
    {'a', 0x100, 0x4 },
    {'i', 0x080, 0x2 },
    {'f', 0x040, 0x1 }
  };
d4666 1
a4666 1
  int saw_a_flag = 0;
d4668 3
a4670 1
  skip_whitespace (*str);
d4672 4
a4675 5
  /* Get the a, f and i flags.  */
  while (**str && **str != ',')
    {
      struct cps_flag *p;
      struct cps_flag *q = flag_table + sizeof (flag_table)/sizeof (*p);
d4677 11
a4687 14
      for (p = flag_table; p < q; ++p)
	if (strncasecmp (*str, &p->character, 1) == 0)
	  {
	    inst.instruction |= (thumb_p ? p->thumb_value : p->arm_value);
	    saw_a_flag = 1;
	    break;
	  }
      if (p == q)
	{
	  inst.error = _("unrecognized flag");
	  return;
	}
      (*str)++;
    }
d4689 2
a4690 2
  if (!saw_a_flag)
    inst.error = _("no 'a', 'i', or 'f' flags for 'cps'");
d4694 1
a4694 1
do_cpsi (char * str)
d4696 6
a4701 1
  do_cps_flags (&str, /*thumb_p=*/0);
d4703 6
a4708 1
  if (skip_past_comma (&str) == SUCCESS)
d4710 7
a4716 2
      skip_whitespace (str);
      do_cps_mode (&str);
d4718 2
a4719 1
  end_of_line (str);
d4722 1
a4722 2
/* THUMB V5 breakpoint instruction (argument parse)
	BKPT <immed_8>.  */
d4725 1
a4725 1
do_t_bkpt (char * str)
d4727 6
a4732 2
  expressionS expr;
  unsigned long number;
d4734 6
a4739 11
  skip_whitespace (str);

  /* Allow optional leading '#'.  */
  if (is_immediate_prefix (*str))
    str ++;

  memset (& expr, '\0', sizeof (expr));
  if (my_get_expression (& expr, & str)
      || (expr.X_op != O_constant
	  /* As a convenience we allow 'bkpt' without an operand.  */
	  && expr.X_op != O_absent))
d4741 3
a4743 3
      inst.error = _("bad expression");
      return;
    }
d4745 3
a4747 7
  number = expr.X_add_number;

  /* Check it fits an 8 bit unsigned.  */
  if (number != (number & 0xff))
    {
      inst.error = _("immediate value out of range");
      return;
d4749 3
d4753 8
a4760 3
  inst.instruction |= number;

  end_of_line (str);
d4763 2
a4764 2
static bfd_reloc_code_real_type
arm_parse_reloc (void)
d4766 5
a4770 23
  char         id [16];
  char *       ip;
  unsigned int i;
  static struct
  {
    char * str;
    int    len;
    bfd_reloc_code_real_type reloc;
  }
  reloc_map[] =
  {
#define MAP(str,reloc) { str, sizeof (str) - 1, reloc }
    MAP ("(got)",    BFD_RELOC_ARM_GOT32),
    MAP ("(gotoff)", BFD_RELOC_ARM_GOTOFF),
    /* ScottB: Jan 30, 1998 - Added support for parsing "var(PLT)"
       branch instructions generated by GCC for PLT relocs.  */
    MAP ("(plt)",    BFD_RELOC_ARM_PLT32),
    MAP ("(target1)", BFD_RELOC_ARM_TARGET1),
    MAP ("(sbrel)", BFD_RELOC_ARM_SBREL32),
    MAP ("(target2)", BFD_RELOC_ARM_TARGET2),
    { NULL, 0,         BFD_RELOC_UNUSED }
#undef MAP
  };
d4772 4
a4775 4
  for (i = 0, ip = input_line_pointer;
       i < sizeof (id) && (ISALNUM (*ip) || ISPUNCT (*ip));
       i++, ip++)
    id[i] = TOLOWER (*ip);
d4777 1
a4777 3
  for (i = 0; reloc_map[i].str; i++)
    if (strncmp (id, reloc_map[i].str, reloc_map[i].len) == 0)
      break;
d4779 6
a4784 1
  input_line_pointer += reloc_map[i].len;
d4786 8
a4793 1
  return reloc_map[i].reloc;
a4795 5
/* ARM V5 branch-link-exchange (argument parse) for BLX(1) only.
   Expects inst.instruction is set for BLX(1).
   Note: this is cloned from do_branch, and the reloc changed to be a
	new one that can cope with setting one extra bit (the H bit).  */

d4797 1
a4797 1
do_branch25 (char * str)
d4799 7
a4805 2
  if (my_get_expression (& inst.reloc.exp, & str))
    return;
d4807 3
a4809 3
#ifdef OBJ_ELF
  {
    char * save_in;
d4811 13
a4823 2
    /* ScottB: February 5, 1998 */
    /* Check to see of PLT32 reloc required for the instruction.  */
d4825 8
a4832 21
    /* arm_parse_reloc() works on input_line_pointer.
       We actually want to parse the operands to the branch instruction
       passed in 'str'.  Save the input pointer and restore it later.  */
    save_in = input_line_pointer;
    input_line_pointer = str;

    if (inst.reloc.exp.X_op == O_symbol
	&& *str == '('
	&& arm_parse_reloc () == BFD_RELOC_ARM_PLT32)
      {
	inst.reloc.type   = BFD_RELOC_ARM_PLT32;
	inst.reloc.pc_rel = 0;
	/* Modify str to point to after parsed operands, otherwise
	   end_of_line() will complain about the (PLT) left in str.  */
	str = input_line_pointer;
      }
    else
      {
	inst.reloc.type   = BFD_RELOC_ARM_PCREL_BLX;
	inst.reloc.pc_rel = 1;
      }
d4834 2
a4835 8
    input_line_pointer = save_in;
  }
#else
  inst.reloc.type   = BFD_RELOC_ARM_PCREL_BLX;
  inst.reloc.pc_rel = 1;
#endif /* OBJ_ELF */

  end_of_line (str);
d4838 5
a4842 7
/* ARM V5 branch-link-exchange instruction (argument parse)
     BLX <target_addr>		ie BLX(1)
     BLX{<condition>} <Rm>	ie BLX(2)
   Unfortunately, there are two different opcodes for this mnemonic.
   So, the insns[].value is not used, and the code here zaps values
	into inst.instruction.
   Also, the <target_addr> can be 25 bits, hence has its own reloc.  */
d4845 1
a4845 1
do_blx (char * str)
d4847 4
a4850 2
  char * mystr = str;
  int rm;
d4852 6
a4857 2
  skip_whitespace (mystr);
  rm = reg_required_here (& mystr, 0);
d4859 4
a4862 4
  /* The above may set inst.error.  Ignore his opinion.  */
  inst.error = 0;

  if (rm != FAIL)
d4864 3
a4866 5
      /* Arg is a register.
	 Use the condition code our caller put in inst.instruction.
	 Pass ourselves off as a BX with a funny opcode.  */
      inst.instruction |= 0x012fff30;
      do_bx (str);
d4868 1
a4868 8
  else
    {
      /* This must be is BLX <target address>, no condition allowed.  */
      if (inst.instruction != COND_ALWAYS)
	{
	  inst.error = BAD_COND;
	  return;
	}
d4870 4
a4873 1
      inst.instruction = 0xfafffffe;
d4875 8
a4882 4
      /* Process like a B/BL, but with a different reloc.
	 Note that B/BL expecte fffffe, not 0, offset in the opcode table.  */
      do_branch25 (str);
    }
d4885 1
a4885 6
/* ARM V5 Thumb BLX (argument parse)
	BLX <target_addr>	which is BLX(1)
	BLX <Rm>		which is BLX(2)
   Unfortunately, there are two different opcodes for this mnemonic.
   So, the tinsns[].value is not used, and the code here zaps values
	into inst.instruction.	*/
d4888 1
a4888 1
do_t_blx (char * str)
d4890 1
a4890 13
  char * mystr = str;
  int rm;

  skip_whitespace (mystr);
  inst.instruction = 0x4780;

  /* Note that this call is to the ARM register recognizer.  BLX(2)
     uses the ARM register space, not the Thumb one, so a call to
     thumb_reg() would be wrong.  */
  rm = reg_required_here (& mystr, 3);
  inst.error = 0;

  if (rm != FAIL)
d4892 6
a4897 2
      /* It's BLX(2).  The .instruction was zapped with rm & is final.  */
      inst.size = 2;
d4901 8
a4908 3
      /* No ARM register.  This must be BLX(1).  Change the .instruction.  */
      inst.instruction = 0xf7ffeffe;
      inst.size = 4;
d4910 3
a4912 2
      if (my_get_expression (& inst.reloc.exp, & mystr))
	return;
d4914 14
a4927 3
      inst.reloc.type   = BFD_RELOC_THUMB_PCREL_BLX;
      inst.reloc.pc_rel = 1;
    }
d4929 9
a4937 1
  end_of_line (mystr);
d4940 5
a4944 5
/* ARM V5 breakpoint instruction (argument parse)
     BKPT <16 bit unsigned immediate>
     Instruction is not conditional.
	The bit pattern given in insns[] has the COND_ALWAYS condition,
	and it is an error if the caller tried to override that.  */
d4947 1
a4947 1
do_bkpt (char * str)
d4949 4
a4952 2
  expressionS expr;
  unsigned long number;
d4954 1
a4954 1
  skip_whitespace (str);
d4956 6
a4961 14
  /* Allow optional leading '#'.  */
  if (is_immediate_prefix (* str))
    str++;

  memset (& expr, '\0', sizeof (expr));

  if (my_get_expression (& expr, & str)
      || (expr.X_op != O_constant
	  /* As a convenience we allow 'bkpt' without an operand.  */
	  && expr.X_op != O_absent))
    {
      inst.error = _("bad expression");
      return;
    }
d4963 3
a4965 1
  number = expr.X_add_number;
d4967 1
a4967 6
  /* Check it fits a 16 bit unsigned.  */
  if (number != (number & 0xffff))
    {
      inst.error = _("immediate value out of range");
      return;
    }
d4969 6
a4974 5
  /* Top 12 of 16 bits to bits 19:8.  */
  inst.instruction |= (number & 0xfff0) << 4;

  /* Bottom 4 of 16 bits to bits 3:0.  */
  inst.instruction |= number & 0xf;
d4976 2
a4977 1
  end_of_line (str);
d4980 1
a4980 1
/* THUMB CPS instruction (argument parse).  */
d4983 1
a4983 1
do_t_cps (char * str)
d4985 3
a4987 2
  do_cps_flags (&str, /*thumb_p=*/1);
  end_of_line (str);
d4990 2
a4991 8
/* Parse and validate that a register is of the right form, this saves
   repeated checking of this information in many similar cases.
   Unlike the 32-bit case we do not insert the register into the opcode
   here, since the position is often unknown until the full instruction
   has been parsed.  */

static int
thumb_reg (char ** strp, int hi_lo)
d4993 4
a4996 1
  int reg;
d4998 2
a4999 2
  if ((reg = reg_required_here (strp, -1)) == FAIL)
    return FAIL;
d5001 2
a5002 9
  switch (hi_lo)
    {
    case THUMB_REG_LO:
      if (reg > 7)
	{
	  inst.error = _("lo register required");
	  return FAIL;
	}
      break;
d5004 5
a5008 13
    case THUMB_REG_HI:
      if (reg < 8)
	{
	  inst.error = _("hi register required");
	  return FAIL;
	}
      break;

    default:
      break;
    }

  return reg;
d5012 1
a5012 1
thumb_mov_compare (char * str, int move)
d5014 3
a5016 1
  int Rd, Rs = FAIL;
d5018 3
a5020 4
  skip_whitespace (str);

  if ((Rd = thumb_reg (&str, THUMB_REG_ANY)) == FAIL
      || skip_past_comma (&str) == FAIL)
d5022 4
a5025 3
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
d5027 3
d5031 6
a5036 8
  if (move != THUMB_CPY && is_immediate_prefix (*str))
    {
      str++;
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
    }
  else if ((Rs = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
    return;
d5038 6
a5043 18
  if (Rs != FAIL)
    {
      if (move != THUMB_CPY && Rs < 8 && Rd < 8)
	{
	  if (move == THUMB_MOVE)
	    /* A move of two lowregs is encoded as ADD Rd, Rs, #0
	       since a MOV instruction produces unpredictable results.  */
	    inst.instruction = T_OPCODE_ADD_I3;
	  else
	    inst.instruction = T_OPCODE_CMP_LR;
	  inst.instruction |= Rd | (Rs << 3);
	}
      else
	{
	  if (move == THUMB_MOVE)
	    inst.instruction = T_OPCODE_MOV_HR;
	  else if (move != THUMB_CPY)
	    inst.instruction = T_OPCODE_CMP_HR;
d5045 4
a5048 2
	  if (Rd > 7)
	    inst.instruction |= THUMB_H1;
d5050 8
a5057 2
	  if (Rs > 7)
	    inst.instruction |= THUMB_H2;
d5059 4
a5062 10
	  inst.instruction |= (Rd & 7) | ((Rs & 7) << 3);
	}
    }
  else
    {
      if (Rd > 7)
	{
	  inst.error = _("only lo regs allowed with immediate");
	  return;
	}
d5064 7
a5070 4
      if (move == THUMB_MOVE)
	inst.instruction = T_OPCODE_MOV_I8;
      else
	inst.instruction = T_OPCODE_CMP_I8;
d5072 2
a5073 19
      inst.instruction |= Rd << 8;

      if (inst.reloc.exp.X_op != O_constant)
	inst.reloc.type = BFD_RELOC_ARM_THUMB_IMM;
      else
	{
	  unsigned value = inst.reloc.exp.X_add_number;

	  if (value > 255)
	    {
	      inst.error = _("invalid immediate");
	      return;
	    }

	  inst.instruction |= value;
	}
    }

  end_of_line (str);
d5076 3
a5078 1
/* THUMB CPY instruction (argument parse).  */
d5081 1
a5081 1
do_t_cpy (char * str)
d5083 3
a5085 1
  thumb_mov_compare (str, THUMB_CPY);
d5088 1
a5088 1
/* THUMB SETEND instruction (argument parse).  */
d5091 1
a5091 1
do_t_setend (char * str)
d5093 3
a5095 2
  if (do_endian_specifier (str))
    inst.instruction |= 0x8;
d5098 1
a5098 1
/* Parse INSN_TYPE insn STR having a possible IMMEDIATE_SIZE immediate.  */
d5100 2
a5101 4
static unsigned long
check_iwmmxt_insn (char * str,
		   enum iwmmxt_insn_type insn_type,
		   int immediate_size)
d5103 5
a5107 4
  int reg = 0;
  const char *  inst_error;
  expressionS expr;
  unsigned long number;
d5109 1
a5109 4
  inst_error = inst.error;
  if (!inst.error)
    inst.error = BAD_ARGS;
  skip_whitespace (str);
d5111 2
a5112 6
  switch (insn_type)
    {
    case check_rd:
      if ((reg = reg_required_here (&str, 12)) == FAIL)
	return FAIL;
      break;
d5114 3
a5116 11
    case check_wr:
       if ((wreg_required_here (&str, 0, IWMMXT_REG_WR)) == FAIL)
	 return FAIL;
       break;

    case check_wrwr:
      if ((wreg_required_here (&str, 12, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL))
	return FAIL;
      break;
d5118 5
a5122 8
    case check_wrwrwr:
      if ((wreg_required_here (&str, 12, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 0, IWMMXT_REG_WR) == FAIL))
	return FAIL;
      break;
d5124 11
a5134 8
    case check_wrwrwcg:
      if ((wreg_required_here (&str, 12, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 0, IWMMXT_REG_WCG) == FAIL))
	return FAIL;
      break;
d5136 4
a5139 6
    case check_tbcst:
      if ((wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || reg_required_here (&str, 12) == FAIL))
	return FAIL;
      break;
d5141 4
a5144 6
    case check_tmovmsk:
      if ((reg_required_here (&str, 12) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL))
	return FAIL;
      break;
d5146 7
a5152 8
    case check_tmia:
      if ((wreg_required_here (&str, 5, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || reg_required_here (&str, 0) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || reg_required_here (&str, 12) == FAIL))
	return FAIL;
      break;
d5154 8
a5161 8
    case check_tmcrr:
      if ((wreg_required_here (&str, 0, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || reg_required_here (&str, 12) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || reg_required_here (&str, 16) == FAIL))
	return FAIL;
      break;
d5163 1
a5163 8
    case check_tmrrc:
      if ((reg_required_here (&str, 12) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || reg_required_here (&str, 16) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 0, IWMMXT_REG_WR) == FAIL))
	return FAIL;
      break;
d5165 3
a5167 6
    case check_tmcr:
      if ((wreg_required_here (&str, 16, IWMMXT_REG_WC) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || reg_required_here (&str, 12) == FAIL))
	return FAIL;
      break;
d5169 10
a5178 6
    case check_tmrc:
      if ((reg_required_here (&str, 12) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 16, IWMMXT_REG_WC) == FAIL))
	return FAIL;
      break;
d5180 6
a5185 7
    case check_tinsr:
      if ((wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || reg_required_here (&str, 12) == FAIL
	   || skip_past_comma (&str) == FAIL))
	return FAIL;
      break;
d5187 7
a5193 5
    case check_textrc:
      if ((reg_required_here (&str, 12) == FAIL
	   || skip_past_comma (&str) == FAIL))
	return FAIL;
      break;
d5195 5
a5199 9
    case check_waligni:
      if ((wreg_required_here (&str, 12, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 0, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL))
	return FAIL;
      break;
d5201 6
a5206 7
    case check_textrm:
      if ((reg_required_here (&str, 12) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL))
	return FAIL;
      break;
d5208 6
a5213 8
    case check_wshufh:
      if ((wreg_required_here (&str, 12, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL
	   || wreg_required_here (&str, 16, IWMMXT_REG_WR) == FAIL
	   || skip_past_comma (&str) == FAIL))
	return FAIL;
      break;
    }
d5215 6
a5220 9
  if (immediate_size == 0)
    {
      end_of_line (str);
      inst.error = inst_error;
      return reg;
    }
  else
    {
      skip_whitespace (str);
d5222 9
a5230 3
      /* Allow optional leading '#'.  */
      if (is_immediate_prefix (* str))
        str++;
d5232 6
a5237 1
      memset (& expr, '\0', sizeof (expr));
d5239 9
a5247 5
      if (my_get_expression (& expr, & str) || (expr.X_op != O_constant))
        {
          inst.error = _("bad or missing expression");
          return FAIL;
        }
d5249 5
a5253 11
      number = expr.X_add_number;

      if (number != (number & immediate_size))
        {
          inst.error = _("immediate value out of range");
          return FAIL;
        }
      end_of_line (str);
      inst.error = inst_error;
      return number;
    }
d5257 1
a5257 1
do_iwmmxt_byte_addr (char * str)
d5259 3
a5261 2
  int op = (inst.instruction & 0x300) >> 8;
  int reg;
a5262 2
  inst.instruction &= ~0x300;
  inst.instruction |= (op & 1) << 22 | (op & 2) << 7;
d5264 5
a5268 9
  skip_whitespace (str);

  if ((reg = wreg_required_here (&str, 12, IWMMXT_REG_WR_OR_WC)) == FAIL
      || skip_past_comma (& str) == FAIL
      || cp_byte_address_required_here (&str) == FAIL)
    {
      if (! inst.error)
        inst.error = BAD_ARGS;
    }
d5270 5
a5274 8
    end_of_line (str);

  if (wc_register (reg))
    {
      as_bad (_("non-word size not supported with control register"));
      inst.instruction |=  0xf0000100;
      inst.instruction &= ~0x00400000;
    }
d5278 1
a5278 1
do_iwmmxt_tandc (char * str)
d5280 10
a5289 1
  int reg;
d5291 3
a5293 1
  reg = check_iwmmxt_insn (str, check_rd, 0);
d5295 1
a5295 2
  if (reg != REG_PC && !inst.error)
    inst.error = _("only r15 allowed here");
d5299 1
a5299 1
do_iwmmxt_tbcst (char * str)
d5301 1
a5301 1
  check_iwmmxt_insn (str, check_tbcst, 0);
d5305 1
a5305 1
do_iwmmxt_textrc (char * str)
d5307 2
a5308 1
  unsigned long number;
d5310 5
a5314 2
  if ((number = check_iwmmxt_insn (str, check_textrc, 7)) == (unsigned long) FAIL)
    return;
d5316 4
a5319 1
  inst.instruction |= number & 0x7;
d5323 1
a5323 1
do_iwmmxt_textrm (char * str)
d5325 2
a5326 1
  unsigned long number;
d5328 7
a5334 2
  if ((number = check_iwmmxt_insn (str, check_textrm, 7)) == (unsigned long) FAIL)
    return;
d5336 5
a5340 1
  inst.instruction |= number & 0x7;
d5344 1
a5344 1
do_iwmmxt_tinsr (char * str)
d5346 22
a5367 1
  unsigned long number;
d5369 2
a5370 2
  if ((number = check_iwmmxt_insn (str, check_tinsr, 7)) == (unsigned long) FAIL)
    return;
d5372 6
a5377 2
  inst.instruction |= number & 0x7;
}
d5379 1
a5379 4
static void
do_iwmmxt_tmcr (char * str)
{
  check_iwmmxt_insn (str, check_tmcr, 0);
d5381 2
d5385 1
a5385 1
do_iwmmxt_tmcrr (char * str)
d5387 1
a5387 1
  check_iwmmxt_insn (str, check_tmcrr, 0);
d5391 1
a5391 1
do_iwmmxt_tmia (char * str)
d5393 2
a5394 1
  check_iwmmxt_insn (str, check_tmia, 0);
d5398 1
a5398 1
do_iwmmxt_tmovmsk (char * str)
d5400 3
a5402 1
  check_iwmmxt_insn (str, check_tmovmsk, 0);
d5406 1
a5406 1
do_iwmmxt_tmrc (char * str)
d5408 3
a5410 1
  check_iwmmxt_insn (str, check_tmrc, 0);
d5414 1
a5414 1
do_iwmmxt_tmrrc (char * str)
d5416 3
a5418 1
  check_iwmmxt_insn (str, check_tmrrc, 0);
d5422 1
a5422 1
do_iwmmxt_torc (char * str)
d5424 4
a5427 1
  check_iwmmxt_insn (str, check_rd, 0);
d5431 1
a5431 1
do_iwmmxt_waligni (char * str)
d5433 4
a5436 6
  unsigned long number;

  if ((number = check_iwmmxt_insn (str, check_waligni, 7)) == (unsigned long) FAIL)
    return;

  inst.instruction |= ((number & 0x7) << 20);
d5440 1
a5440 1
do_iwmmxt_wmov (char * str)
d5442 3
a5444 4
  if (check_iwmmxt_insn (str, check_wrwr, 0) == (unsigned long) FAIL)
    return;

  inst.instruction |= ((inst.instruction >> 16) & 0xf);
d5448 1
a5448 1
do_iwmmxt_word_addr (char * str)
d5450 2
a5451 11
  int op = (inst.instruction & 0x300) >> 8;
  int reg;

  inst.instruction &= ~0x300;
  inst.instruction |= (op & 1) << 22 | (op & 2) << 7;

  skip_whitespace (str);

  if ((reg = wreg_required_here (&str, 12, IWMMXT_REG_WR_OR_WC)) == FAIL
      || skip_past_comma (& str) == FAIL
      || cp_address_required_here (& str, CP_WB_OK) == FAIL)
d5453 2
a5454 2
      if (! inst.error)
        inst.error = BAD_ARGS;
a5455 2
  else
    end_of_line (str);
d5457 2
a5458 9
  if (wc_register (reg))
    {
      if ((inst.instruction & COND_MASK) != COND_ALWAYS)
	as_bad (_("conditional execution not supported with control register"));
      if (op != 2)
	as_bad (_("non-word size not supported with control register"));
      inst.instruction |=  0xf0000100;
      inst.instruction &= ~0x00400000;
    }
d5462 1
a5462 1
do_iwmmxt_wrwr (char * str)
d5464 2
a5465 1
  check_iwmmxt_insn (str, check_wrwr, 0);
d5469 1
a5469 1
do_iwmmxt_wrwrwcg (char * str)
d5471 4
a5474 1
  check_iwmmxt_insn (str, check_wrwrwcg, 0);
d5478 1
a5478 1
do_iwmmxt_wrwrwr (char * str)
d5480 4
a5483 1
  check_iwmmxt_insn (str, check_wrwrwr, 0);
d5485 5
d5492 1
a5492 1
do_iwmmxt_wshufh (char * str)
d5494 4
a5497 1
  unsigned long number;
d5499 2
a5500 2
  if ((number = check_iwmmxt_insn (str, check_wshufh, 0xff)) == (unsigned long) FAIL)
    return;
d5502 7
a5508 1
  inst.instruction |= ((number & 0xf0) << 16) | (number & 0xf);
d5511 1
d5513 1
a5513 1
do_iwmmxt_wzero (char * str)
d5515 1
a5515 4
  if (check_iwmmxt_insn (str, check_wr, 0) == (unsigned long) FAIL)
    return;

  inst.instruction |= ((inst.instruction & 0xf) << 12) | ((inst.instruction & 0xf) << 16);
d5518 3
a5520 4
/* Xscale multiply-accumulate (argument parse)
     MIAcc   acc0,Rm,Rs
     MIAPHcc acc0,Rm,Rs
     MIAxycc acc0,Rm,Rs.  */
d5523 1
a5523 1
do_xsc_mia (char * str)
d5525 1
a5525 2
  int rs;
  int rm;
d5527 2
a5528 2
  if (accum0_required_here (& str) == FAIL)
    inst.error = ERR_NO_ACCUM;
d5530 4
a5533 3
  else if (skip_past_comma (& str) == FAIL
	   || (rm = reg_required_here (& str, 0)) == FAIL)
    inst.error = BAD_ARGS;
d5535 4
a5538 3
  else if (skip_past_comma (& str) == FAIL
	   || (rs = reg_required_here (& str, 12)) == FAIL)
    inst.error = BAD_ARGS;
d5540 4
a5543 3
  /* inst.instruction has now been zapped with both rm and rs.  */
  else if (rm == REG_PC || rs == REG_PC)
    inst.error = BAD_PC;	/* Undefined result if rm or rs is R15.  */
d5545 5
a5549 2
  else
    end_of_line (str);
d5557 1
a5557 1
do_xsc_mar (char * str)
d5559 3
a5561 1
  int rdlo, rdhi;
d5563 1
a5563 2
  if (accum0_required_here (& str) == FAIL)
    inst.error = ERR_NO_ACCUM;
d5565 1
a5565 3
  else if (skip_past_comma (& str) == FAIL
	   || (rdlo = reg_required_here (& str, 12)) == FAIL)
    inst.error = BAD_ARGS;
d5567 6
a5572 10
  else if (skip_past_comma (& str) == FAIL
	   || (rdhi = reg_required_here (& str, 16)) == FAIL)
    inst.error = BAD_ARGS;

  /* inst.instruction has now been zapped with both rdlo and rdhi.  */
  else if (rdlo == REG_PC || rdhi == REG_PC)
    inst.error = BAD_PC;	/* Undefined result if rdlo or rdhi is R15.  */

  else
    end_of_line (str);
d5574 2
d5577 2
a5578 3
/* Xscale move-register-accumulator (argument parse)

     MRAcc   RdLo,RdHi,acc0.  */
d5581 1
a5581 1
do_xsc_mra (char * str)
d5583 2
a5584 2
  int rdlo;
  int rdhi;
d5586 7
a5592 1
  skip_whitespace (str);
d5594 4
a5597 2
  if ((rdlo = reg_required_here (& str, 12)) == FAIL)
    inst.error = BAD_ARGS;
d5599 4
a5602 3
  else if (skip_past_comma (& str) == FAIL
	   || (rdhi = reg_required_here (& str, 16)) == FAIL)
    inst.error = BAD_ARGS;
d5604 171
a5774 3
  else if  (skip_past_comma (& str) == FAIL
	    || accum0_required_here (& str) == FAIL)
    inst.error = ERR_NO_ACCUM;
d5776 1
a5776 3
  /* inst.instruction has now been zapped with both rdlo and rdhi.  */
  else if (rdlo == rdhi)
    inst.error = BAD_ARGS;	/* Undefined result if 2 writes to same reg.  */
d5778 2
a5779 5
  else if (rdlo == REG_PC || rdhi == REG_PC)
    inst.error = BAD_PC;	/* Undefined result if rdlo or rdhi is R15.  */
  else
    end_of_line (str);
}
d5781 2
a5782 2
static int
ldst_extend (char ** str)
d5784 35
a5818 1
  int add = INDEX_UP;
d5820 31
a5850 1
  switch (**str)
d5852 3
a5854 5
    case '#':
    case '$':
      (*str)++;
      if (my_get_expression (& inst.reloc.exp, str))
	return FAIL;
d5856 1
a5856 1
      if (inst.reloc.exp.X_op == O_constant)
d5858 3
a5860 1
	  int value = inst.reloc.exp.X_add_number;
d5862 6
a5867 5
	  if (value < -4095 || value > 4095)
	    {
	      inst.error = _("address offset too large");
	      return FAIL;
	    }
d5869 2
a5870 5
	  if (value < 0)
	    {
	      value = -value;
	      add = 0;
	    }
d5872 14
a5885 1
	  inst.instruction |= add | value;
d5889 3
a5891 2
	  inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM;
	  inst.reloc.pc_rel = 0;
d5893 12
a5904 1
      return SUCCESS;
d5906 10
a5915 3
    case '-':
      add = 0;
      /* Fall through.  */
d5917 31
a5947 3
    case '+':
      (*str)++;
      /* Fall through.  */
d5949 16
a5964 3
    default:
      if (reg_required_here (str, 0) == FAIL)
	return FAIL;
d5966 5
a5970 3
      inst.instruction |= add | OFFSET_REG;
      if (skip_past_comma (str) == SUCCESS)
	return decode_shift (str, SHIFT_IMMEDIATE);
d5972 3
a5974 1
      return SUCCESS;
d5978 74
a6051 1
/* ARMv5TE: Preload-Cache
d6053 8
a6060 1
    PLD <addr_mode>
d6062 12
a6073 1
  Syntactically, like LDR with B=1, W=0, L=1.  */
d6076 1
a6076 1
do_pld (char * str)
d6078 1
a6078 1
  int rd;
d6080 4
a6083 1
  skip_whitespace (str);
d6085 10
a6094 5
  if (* str != '[')
    {
      inst.error = _("'[' expected after PLD mnemonic");
      return;
    }
d6096 11
a6106 2
  ++str;
  skip_whitespace (str);
d6108 6
a6113 2
  if ((rd = reg_required_here (& str, 16)) == FAIL)
    return;
d6115 2
a6116 1
  skip_whitespace (str);
d6118 7
a6124 1
  if (*str == ']')
d6126 6
a6131 3
      /* [Rn], ... ?  */
      ++str;
      skip_whitespace (str);
d6133 6
a6138 2
      /* Post-indexed addressing is not allowed with PLD.  */
      if (skip_past_comma (&str) == SUCCESS)
d6140 2
a6141 3
	  inst.error
	    = _("post-indexed expression used in preload instruction");
	  return;
d6143 1
a6143 1
      else if (*str == '!') /* [Rn]! */
d6145 3
a6147 2
	  inst.error = _("writeback used in preload instruction");
	  ++str;
a6148 2
      else /* [Rn] */
	inst.instruction |= INDEX_UP | PRE_INDEX;
d6150 1
a6150 1
  else /* [Rn, ...] */
d6152 3
a6154 1
      if (skip_past_comma (& str) == FAIL)
d6156 2
a6157 2
	  inst.error = _("pre-indexed expression expected");
	  return;
d6159 1
d6161 2
a6162 2
      if (ldst_extend (&str) == FAIL)
	return;
d6164 10
a6173 1
      skip_whitespace (str);
d6175 5
a6179 5
      if (* str != ']')
	{
	  inst.error = _("missing ]");
	  return;
	}
d6181 11
a6191 2
      ++ str;
      skip_whitespace (str);
d6193 8
a6200 5
      if (* str == '!') /* [Rn]! */
	{
	  inst.error = _("writeback used in preload instruction");
	  ++ str;
	}
d6202 5
a6206 2
      inst.instruction |= PRE_INDEX;
    }
d6208 1
a6208 1
  end_of_line (str);
d6211 7
a6217 5
/* ARMv5TE load-consecutive (argument parse)
   Mode is like LDRH.

     LDRccD R, mode
     STRccD R, mode.  */
d6220 1
a6220 1
do_ldrd (char * str)
d6222 2
a6223 6
  int rd;
  int rn;

  skip_whitespace (str);

  if ((rd = reg_required_here (& str, 12)) == FAIL)
d6225 6
a6230 2
      inst.error = BAD_ARGS;
      return;
d6232 1
a6232 3

  if (skip_past_comma (& str) == FAIL
      || (rn = ld_mode_required_here (& str)) == FAIL)
d6234 4
a6237 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d6239 3
d6243 4
a6246 2
  /* inst.instruction has now been zapped with Rd and the addressing mode.  */
  if (rd & 1)		/* Unpredictable result if Rd is odd.  */
d6248 3
a6250 2
      inst.error = _("destination register must be even");
      return;
d6252 1
a6252 2

  if (rd == REG_LR)
d6254 3
a6256 2
      inst.error = _("r14 not allowed here");
      return;
d6258 10
d6269 8
a6276 4
  if (((rd == rn) || (rd + 1 == rn))
      && ((inst.instruction & WRITE_BACK)
	  || (!(inst.instruction & PRE_INDEX))))
    as_warn (_("pre/post-indexing used when modified address register is destination"));
d6278 5
a6282 4
  /* For an index-register load, the index register must not overlap the
     destination (even if not write-back).  */
  if ((inst.instruction & V4_STR_BIT) == 0
      && (inst.instruction & HWOFFSET_IMM) == 0)
d6284 11
a6294 1
      int rm = inst.instruction & 0x0000000f;
d6296 1
a6296 2
      if (rm == rd || (rm == rd + 1))
	as_warn (_("ldrd destination registers must not overlap index register"));
d6299 1
a6299 1
  end_of_line (str);
d6302 2
a6303 5
/* Returns the index into fp_values of a floating point number,
   or -1 if not in the table.  */

static int
my_get_float_expression (char ** str)
d6305 5
a6309 5
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  char *         save_in;
  expressionS    exp;
  int            i;
  int            j;
d6311 17
a6327 1
  memset (words, 0, MAX_LITTLENUMS * sizeof (LITTLENUM_TYPE));
d6329 5
a6333 5
  /* Look for a raw floating point number.  */
  if ((save_in = atof_ieee (*str, 'x', words)) != NULL
      && is_end_of_line[(unsigned char) *save_in])
    {
      for (i = 0; i < NUM_FLOAT_VALS; i++)
d6335 3
a6337 1
	  for (j = 0; j < MAX_LITTLENUMS; j++)
d6339 7
a6345 5
	      if (words[j] != fp_values[i][j])
		break;
	    }

	  if (j == MAX_LITTLENUMS)
d6347 7
a6353 2
	      *str = save_in;
	      return i;
d6355 6
d6363 1
a6363 8

  /* Try and parse a more complex expression, this will probably fail
     unless the code uses a floating point prefix (eg "0f").  */
  save_in = input_line_pointer;
  input_line_pointer = *str;
  if (expression (&exp) == absolute_section
      && exp.X_op == O_big
      && exp.X_add_number < 0)
d6365 12
a6376 3
      /* FIXME: 5 = X_PRECISION, should be #define'd where we can use it.
	 Ditto for 15.  */
      if (gen_to_words (words, 5, (long) 15) == 0)
d6378 7
a6384 7
	  for (i = 0; i < NUM_FLOAT_VALS; i++)
	    {
	      for (j = 0; j < MAX_LITTLENUMS; j++)
		{
		  if (words[j] != fp_values[i][j])
		    break;
		}
d6386 3
a6388 8
	      if (j == MAX_LITTLENUMS)
		{
		  *str = input_line_pointer;
		  input_line_pointer = save_in;
		  return i;
		}
	    }
	}
d6390 10
d6401 3
a6403 3
  *str = input_line_pointer;
  input_line_pointer = save_in;
  return -1;
d6406 2
a6407 4
/* We handle all bad expressions here, so that we can report the faulty
   instruction in the error message.  */
void
md_operand (expressionS * expr)
d6409 1
a6409 1
  if (in_my_get_expression)
d6411 4
a6414 3
      expr->X_op = O_illegal;
      if (inst.error == NULL)
	inst.error = _("bad expression");
d6416 6
d6424 16
a6439 9
/* Do those data_ops which can take a negative immediate constant
   by altering the instruction.  A bit of a hack really.
        MOV <-> MVN
        AND <-> BIC
        ADC <-> SBC
        by inverting the second operand, and
        ADD <-> SUB
        CMP <-> CMN
        by negating the second operand.  */
d6441 5
a6445 6
static int
negate_data_op (unsigned long * instruction,
		unsigned long   value)
{
  int op, new_inst;
  unsigned long negated, inverted;
d6447 1
a6447 2
  negated = validate_immediate (-value);
  inverted = validate_immediate (~value);
d6449 1
a6449 2
  op = (*instruction >> DATA_OP_SHIFT) & 0xf;
  switch (op)
d6451 14
a6464 5
      /* First negates.  */
    case OPCODE_SUB:             /* ADD <-> SUB  */
      new_inst = OPCODE_ADD;
      value = negated;
      break;
d6466 13
a6478 4
    case OPCODE_ADD:
      new_inst = OPCODE_SUB;
      value = negated;
      break;
d6480 6
a6485 4
    case OPCODE_CMP:             /* CMP <-> CMN  */
      new_inst = OPCODE_CMN;
      value = negated;
      break;
d6487 4
a6490 4
    case OPCODE_CMN:
      new_inst = OPCODE_CMP;
      value = negated;
      break;
d6492 9
a6500 5
      /* Now Inverted ops.  */
    case OPCODE_MOV:             /* MOV <-> MVN  */
      new_inst = OPCODE_MVN;
      value = inverted;
      break;
d6502 4
a6505 4
    case OPCODE_MVN:
      new_inst = OPCODE_MOV;
      value = inverted;
      break;
d6507 13
a6519 4
    case OPCODE_AND:             /* AND <-> BIC  */
      new_inst = OPCODE_BIC;
      value = inverted;
      break;
d6521 4
a6524 4
    case OPCODE_BIC:
      new_inst = OPCODE_AND;
      value = inverted;
      break;
d6526 8
a6533 13
    case OPCODE_ADC:              /* ADC <-> SBC  */
      new_inst = OPCODE_SBC;
      value = inverted;
      break;

    case OPCODE_SBC:
      new_inst = OPCODE_ADC;
      value = inverted;
      break;

      /* We cannot do anything.  */
    default:
      return FAIL;
d6535 5
d6541 6
a6546 2
  if (value == (unsigned) FAIL)
    return FAIL;
d6548 7
a6554 3
  *instruction &= OPCODE_MASK;
  *instruction |= new_inst << DATA_OP_SHIFT;
  return value;
d6557 2
a6558 2
static int
data_op2 (char ** str)
d6560 5
a6564 2
  int value;
  expressionS expr;
d6566 34
a6599 1
  skip_whitespace (* str);
d6601 7
a6607 5
  if (reg_required_here (str, 0) != FAIL)
    {
      if (skip_past_comma (str) == SUCCESS)
	/* Shift operation on register.  */
	return decode_shift (str, NO_SHIFT_RESTRICT);
d6609 17
a6625 1
      return SUCCESS;
d6627 3
a6629 1
  else
d6631 1
a6631 2
      /* Immediate expression.  */
      if (is_immediate_prefix (**str))
d6633 6
a6638 2
	  (*str)++;
	  inst.error = NULL;
d6640 7
a6646 8
	  if (my_get_expression (&inst.reloc.exp, str))
	    return FAIL;

	  if (inst.reloc.exp.X_add_symbol)
	    {
	      inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;
	      inst.reloc.pc_rel = 0;
	    }
d6648 2
a6649 48
	    {
	      if (skip_past_comma (str) == SUCCESS)
		{
		  /* #x, y -- ie explicit rotation by Y.  */
		  if (my_get_expression (&expr, str))
		    return FAIL;

		  if (expr.X_op != O_constant)
		    {
		      inst.error = _("constant expression expected");
		      return FAIL;
		    }

		  /* Rotate must be a multiple of 2.  */
		  if (((unsigned) expr.X_add_number) > 30
		      || (expr.X_add_number & 1) != 0
		      || ((unsigned) inst.reloc.exp.X_add_number) > 255)
		    {
		      inst.error = _("invalid constant");
		      return FAIL;
		    }
		  inst.instruction |= INST_IMMEDIATE;
		  inst.instruction |= inst.reloc.exp.X_add_number;
		  inst.instruction |= expr.X_add_number << 7;
		  return SUCCESS;
		}

	      /* Implicit rotation, select a suitable one.  */
	      value = validate_immediate (inst.reloc.exp.X_add_number);

	      if (value == FAIL)
		{
		  /* Can't be done.  Perhaps the code reads something like
		     "add Rd, Rn, #-n", where "sub Rd, Rn, #n" would be OK.  */
		  if ((value = negate_data_op (&inst.instruction,
					       inst.reloc.exp.X_add_number))
		      == FAIL)
		    {
		      inst.error = _("invalid constant");
		      return FAIL;
		    }
		}

	      inst.instruction |= value;
	    }

	  inst.instruction |= INST_IMMEDIATE;
	  return SUCCESS;
d6651 7
a6657 4

      (*str)++;
      inst.error = _("register or shift expression expected");
      return FAIL;
d6661 2
a6662 2
static int
fp_op2 (char ** str)
d6664 6
a6669 1
  skip_whitespace (* str);
d6671 4
a6674 3
  if (fp_reg_required_here (str, 0) != FAIL)
    return SUCCESS;
  else
d6676 13
a6688 2
      /* Immediate expression.  */
      if (*((*str)++) == '#')
d6690 7
a6696 10
	  int i;

	  inst.error = NULL;

	  skip_whitespace (* str);

	  /* First try and match exact strings, this is to guarantee
	     that some formats will work even for cross assembly.  */

	  for (i = 0; fp_const[i]; i++)
d6698 3
a6700 12
	      if (strncmp (*str, fp_const[i], strlen (fp_const[i])) == 0)
		{
		  char *start = *str;

		  *str += strlen (fp_const[i]);
		  if (is_end_of_line[(unsigned char) **str])
		    {
		      inst.instruction |= i + 8;
		      return SUCCESS;
		    }
		  *str = start;
		}
d6702 1
a6702 6

	  /* Just because we didn't get a match doesn't mean that the
	     constant isn't valid, just that it is in a format that we
	     don't automatically recognize.  Try parsing it with
	     the standard expression routines.  */
	  if ((i = my_get_float_expression (str)) >= 0)
d6704 7
a6710 2
	      inst.instruction |= i + 8;
	      return SUCCESS;
d6712 10
d6723 3
a6725 6
	  inst.error = _("invalid floating point immediate expression");
	  return FAIL;
	}
      inst.error =
	_("floating point register or immediate expression expected");
      return FAIL;
d6730 22
a6751 1
do_arit (char * str)
d6753 2
a6754 1
  skip_whitespace (str);
d6756 2
a6757 5
  if (reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 16) == FAIL
      || skip_past_comma (&str) == FAIL
      || data_op2 (&str) == FAIL)
d6759 4
a6762 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d6764 9
d6774 7
a6780 1
  end_of_line (str);
d6784 1
a6784 1
do_adr (char * str)
d6786 4
a6789 3
  /* This is a pseudo-op of the form "adr rd, label" to be converted
     into a relative address of the form "add rd, pc, #label-.-8".  */
  skip_whitespace (str);
d6791 21
a6811 3
  if (reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL
      || my_get_expression (&inst.reloc.exp, &str))
d6813 3
a6815 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
a6816 10

  /* Frag hacking will turn this into a sub instruction if the offset turns
     out to be negative.  */
  inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;
#ifndef TE_WINCE
  inst.reloc.exp.X_add_number -= 8; /* PC relative adjust.  */
#endif
  inst.reloc.pc_rel = 1;

  end_of_line (str);
d6820 1
a6820 1
do_adrl (char * str)
d6822 18
a6839 10
  /* This is a pseudo-op of the form "adrl rd, label" to be converted
     into a relative address of the form:
     add rd, pc, #low(label-.-8)"
     add rd, rd, #high(label-.-8)"  */

  skip_whitespace (str);

  if (reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL
      || my_get_expression (&inst.reloc.exp, &str))
d6841 3
a6843 2
      if (!inst.error)
	inst.error = BAD_ARGS;
d6845 3
a6847 1
      return;
a6848 10

  end_of_line (str);
  /* Frag hacking will turn this into a sub instruction if the offset turns
     out to be negative.  */
  inst.reloc.type              = BFD_RELOC_ARM_ADRL_IMMEDIATE;
#ifndef TE_WINCE
  inst.reloc.exp.X_add_number -= 8; /* PC relative adjust  */
#endif
  inst.reloc.pc_rel            = 1;
  inst.size                    = INSN_SIZE * 2;
d6852 1
a6852 1
do_cmp (char * str)
d6854 4
a6857 3
  skip_whitespace (str);

  if (reg_required_here (&str, 16) == FAIL)
d6859 5
a6863 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d6865 1
d6867 7
a6873 7
  if (skip_past_comma (&str) == FAIL
      || data_op2 (&str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d6875 4
a6878 1
  end_of_line (str);
d6882 1
a6882 1
do_mov (char * str)
d6884 4
a6887 1
  skip_whitespace (str);
d6889 6
a6894 1
  if (reg_required_here (&str, 12) == FAIL)
d6896 3
a6898 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d6900 15
d6916 3
a6918 2
  if (skip_past_comma (&str) == FAIL
      || data_op2 (&str) == FAIL)
d6920 1
a6920 2
      if (!inst.error)
	inst.error = BAD_ARGS;
d6924 1
a6924 1
  end_of_line (str);
d6928 1
a6928 1
do_ldst (char * str)
d6930 3
a6932 3
  int pre_inc = 0;
  int conflict_reg;
  int value;
d6934 5
a6938 3
  skip_whitespace (str);

  if ((conflict_reg = reg_required_here (&str, 12)) == FAIL)
d6940 3
a6942 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d6944 1
a6944 2

  if (skip_past_comma (&str) == FAIL)
d6946 4
a6949 2
      inst.error = _("address expected");
      return;
d6951 3
d6955 4
a6958 5
  if (*str == '[')
    {
      int reg;

      str++;
d6960 4
a6963 1
      skip_whitespace (str);
d6965 10
a6974 2
      if ((reg = reg_required_here (&str, 16)) == FAIL)
	return;
d6976 6
a6981 2
      /* Conflicts can occur on stores as well as loads.  */
      conflict_reg = (conflict_reg == reg);
d6983 5
a6987 1
      skip_whitespace (str);
d6989 15
a7003 13
      if (*str == ']')
	{
	  str ++;

	  if (skip_past_comma (&str) == SUCCESS)
	    {
	      /* [Rn],... (post inc)  */
	      if (ldst_extend (&str) == FAIL)
		return;
	      if (conflict_reg)
		as_warn (_("%s register same as write-back base"),
			 ((inst.instruction & LOAD_BIT)
			  ? _("destination") : _("source")));
d7007 2
a7008 4
	      /* [Rn]  */
	      skip_whitespace (str);

	      if (*str == '!')
d7010 9
a7018 6
		  if (conflict_reg)
		    as_warn (_("%s register same as write-back base"),
			     ((inst.instruction & LOAD_BIT)
			      ? _("destination") : _("source")));
		  str++;
		  inst.instruction |= WRITE_BACK;
d7020 7
a7026 3

	      inst.instruction |= INDEX_UP;
	      pre_inc = 1;
d7031 1
a7031 2
	  /* [Rn,...]  */
	  if (skip_past_comma (&str) == FAIL)
d7033 11
a7043 2
	      inst.error = _("pre-indexed expression expected");
	      return;
d7045 1
a7045 8

	  pre_inc = 1;
	  if (ldst_extend (&str) == FAIL)
	    return;

	  skip_whitespace (str);

	  if (*str++ != ']')
d7047 10
a7056 2
	      inst.error = _("missing ]");
	      return;
d7058 7
d7066 5
a7070 1
	  skip_whitespace (str);
d7072 1
a7072 1
	  if (*str == '!')
d7074 5
a7078 6
	      if (conflict_reg)
		as_warn (_("%s register same as write-back base"),
			 ((inst.instruction & LOAD_BIT)
			  ? _("destination") : _("source")));
	      str++;
	      inst.instruction |= WRITE_BACK;
d7080 3
d7084 1
a7084 4
    }
  else if (*str == '=')
    {
      if ((inst.instruction & LOAD_BIT) == 0)
d7086 11
a7096 2
	  inst.error = _("invalid pseudo operation");
	  return;
d7098 10
d7109 11
a7119 2
      /* Parse an "ldr Rd, =expr" instruction; this is another pseudo op.  */
      str++;
d7121 6
a7126 1
      skip_whitespace (str);
d7128 4
a7131 2
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
d7133 1
a7133 2
      if (inst.reloc.exp.X_op != O_constant
	  && inst.reloc.exp.X_op != O_symbol)
d7135 4
a7138 2
	  inst.error = _("constant expression expected");
	  return;
d7140 3
d7144 7
a7150 3
      if (inst.reloc.exp.X_op == O_constant)
	{
	  value = validate_immediate (inst.reloc.exp.X_add_number);
d7152 8
a7159 10
	  if (value != FAIL)
	    {
	      /* This can be done with a mov instruction.  */
	      inst.instruction &= LITERAL_MASK;
	      inst.instruction |= (INST_IMMEDIATE
				   | (OPCODE_MOV << DATA_OP_SHIFT));
	      inst.instruction |= value & 0xfff;
	      end_of_line (str);
	      return;
	    }
d7161 5
a7165 1
	  value = validate_immediate (~inst.reloc.exp.X_add_number);
d7167 5
a7171 11
	  if (value != FAIL)
	    {
	      /* This can be done with a mvn instruction.  */
	      inst.instruction &= LITERAL_MASK;
	      inst.instruction |= (INST_IMMEDIATE
				   | (OPCODE_MVN << DATA_OP_SHIFT));
	      inst.instruction |= value & 0xfff;
	      end_of_line (str);
	      return;
	    }
	}
d7173 5
a7177 7
      /* Insert into literal pool.  */
      if (add_to_lit_pool () == FAIL)
	{
	  if (!inst.error)
	    inst.error = _("literal pool insertion failed");
	  return;
	}
d7179 5
a7183 10
      /* Change the instruction exp to point to the pool.  */
      inst.reloc.type = BFD_RELOC_ARM_LITERAL;
      inst.reloc.pc_rel = 1;
      inst.instruction |= (REG_PC << 16);
      pre_inc = 1;
    }
  else
    {
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
d7185 7
a7191 12
      inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM;
#ifndef TE_WINCE
      /* PC rel adjust.  */
      inst.reloc.exp.X_add_number -= 8;
#endif
      inst.reloc.pc_rel = 1;
      inst.instruction |= (REG_PC << 16);
      pre_inc = 1;
    }

  inst.instruction |= (pre_inc ? PRE_INDEX : 0);
  end_of_line (str);
d7195 1
a7195 1
do_ldstt (char * str)
d7197 3
a7199 5
  int conflict_reg;

  skip_whitespace (str);

  if ((conflict_reg = reg_required_here (& str, 12)) == FAIL)
d7201 3
a7203 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d7205 1
a7205 2

  if (skip_past_comma (& str) == FAIL)
d7207 5
a7211 2
      inst.error = _("address expected");
      return;
d7213 1
a7213 2

  if (*str == '[')
d7215 5
a7219 1
      int reg;
d7221 5
a7225 1
      str++;
d7227 6
a7232 1
      skip_whitespace (str);
d7234 5
a7238 13
      if ((reg = reg_required_here (&str, 16)) == FAIL)
	return;

      /* ldrt/strt always use post-indexed addressing, so if the base is
	 the same as Rd, we warn.  */
      if (conflict_reg == reg)
	as_warn (_("%s register same as write-back base"),
		 ((inst.instruction & LOAD_BIT)
		  ? _("destination") : _("source")));

      skip_whitespace (str);

      if (*str == ']')
d7240 2
a7241 12
	  str ++;

	  if (skip_past_comma (&str) == SUCCESS)
	    {
	      /* [Rn],... (post inc)  */
	      if (ldst_extend (&str) == FAIL)
		return;
	    }
	  else
	    {
	      /* [Rn]  */
	      skip_whitespace (str);
d7243 2
a7244 11
	      /* Skip a write-back '!'.  */
	      if (*str == '!')
		str++;

	      inst.instruction |= INDEX_UP;
	    }
	}
      else
	{
	  inst.error = _("post-indexed expression expected");
	  return;
d7246 1
d7248 1
a7248 5
  else
    {
      inst.error = _("post-indexed expression expected");
      return;
    }
d7250 6
a7255 1
  end_of_line (str);
d7257 2
d7260 6
a7265 1
/* Halfword and signed-byte load/store operations.  */
d7268 6
a7273 1
do_ldstv4 (char * str)
d7275 1
a7275 3
  int pre_inc = 0;
  int conflict_reg;
  int value;
d7277 8
a7284 1
  skip_whitespace (str);
d7286 4
a7289 5
  if ((conflict_reg = reg_required_here (& str, 12)) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d7292 11
a7302 1
  if (skip_past_comma (& str) == FAIL)
d7304 1
a7304 1
      inst.error = _("address expected");
d7307 2
d7310 9
a7318 1
  if (*str == '[')
d7320 11
a7330 1
      int reg;
d7332 4
a7335 1
      str++;
d7337 91
a7427 1
      skip_whitespace (str);
d7429 2
a7430 2
      if ((reg = reg_required_here (&str, 16)) == FAIL)
	return;
d7432 9
a7440 2
      /* Conflicts can occur on stores as well as loads.  */
      conflict_reg = (conflict_reg == reg);
d7442 4
a7445 1
      skip_whitespace (str);
d7447 6
a7452 1
      if (*str == ']')
d7454 3
a7456 1
	  str ++;
d7458 9
a7466 14
	  if (skip_past_comma (&str) == SUCCESS)
	    {
	      /* [Rn],... (post inc)  */
	      if (ldst_extend_v4 (&str) == FAIL)
		return;
	      if (conflict_reg)
		as_warn (_("%s register same as write-back base"),
			 ((inst.instruction & LOAD_BIT)
			  ? _("destination") : _("source")));
	    }
	  else
	    {
	      /* [Rn]  */
	      inst.instruction |= HWOFFSET_IMM;
d7468 4
a7471 1
	      skip_whitespace (str);
d7473 26
a7498 9
	      if (*str == '!')
		{
		  if (conflict_reg)
		    as_warn (_("%s register same as write-back base"),
			     ((inst.instruction & LOAD_BIT)
			      ? _("destination") : _("source")));
		  str++;
		  inst.instruction |= WRITE_BACK;
		}
d7500 2
a7501 3
	      inst.instruction |= INDEX_UP;
	      pre_inc = 1;
	    }
d7503 6
a7508 8
      else
	{
	  /* [Rn,...]  */
	  if (skip_past_comma (&str) == FAIL)
	    {
	      inst.error = _("pre-indexed expression expected");
	      return;
	    }
d7510 17
a7526 3
	  pre_inc = 1;
	  if (ldst_extend_v4 (&str) == FAIL)
	    return;
d7528 3
a7530 1
	  skip_whitespace (str);
d7532 2
a7533 5
	  if (*str++ != ']')
	    {
	      inst.error = _("missing ]");
	      return;
	    }
d7535 5
a7539 1
	  skip_whitespace (str);
d7541 6
a7546 10
	  if (*str == '!')
	    {
	      if (conflict_reg)
		as_warn (_("%s register same as write-back base"),
			 ((inst.instruction & LOAD_BIT)
			  ? _("destination") : _("source")));
	      str++;
	      inst.instruction |= WRITE_BACK;
	    }
	}
a7547 7
  else if (*str == '=')
    {
      if ((inst.instruction & LOAD_BIT) == 0)
	{
	  inst.error = _("invalid pseudo operation");
	  return;
	}
d7549 2
a7550 3
      /* XXX Does this work correctly for half-word/byte ops?  */
      /* Parse an "ldr Rd, =expr" instruction; this is another pseudo op.  */
      str++;
d7552 7
a7558 1
      skip_whitespace (str);
d7560 2
a7561 2
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
d7563 4
a7566 2
      if (inst.reloc.exp.X_op != O_constant
	  && inst.reloc.exp.X_op != O_symbol)
d7568 1
a7568 1
	  inst.error = _("constant expression expected");
d7571 2
a7572 2

      if (inst.reloc.exp.X_op == O_constant)
d7574 3
a7576 1
	  value = validate_immediate (inst.reloc.exp.X_add_number);
d7578 2
a7579 9
	  if (value != FAIL)
	    {
	      /* This can be done with a mov instruction.  */
	      inst.instruction &= LITERAL_MASK;
	      inst.instruction |= INST_IMMEDIATE | (OPCODE_MOV << DATA_OP_SHIFT);
	      inst.instruction |= value & 0xfff;
	      end_of_line (str);
	      return;
	    }
d7581 2
a7582 1
	  value = validate_immediate (~ inst.reloc.exp.X_add_number);
d7584 5
a7588 1
	  if (value != FAIL)
d7590 1
a7590 5
	      /* This can be done with a mvn instruction.  */
	      inst.instruction &= LITERAL_MASK;
	      inst.instruction |= INST_IMMEDIATE | (OPCODE_MVN << DATA_OP_SHIFT);
	      inst.instruction |= value & 0xfff;
	      end_of_line (str);
d7594 10
a7603 3

      /* Insert into literal pool.  */
      if (add_to_lit_pool () == FAIL)
d7605 1
a7605 2
	  if (!inst.error)
	    inst.error = _("literal pool insertion failed");
d7609 9
a7617 6
      /* Change the instruction exp to point to the pool.  */
      inst.instruction |= HWOFFSET_IMM;
      inst.reloc.type = BFD_RELOC_ARM_HWLITERAL;
      inst.reloc.pc_rel = 1;
      inst.instruction |= (REG_PC << 16);
      pre_inc = 1;
d7619 2
a7620 4
  else
    {
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
d7622 1
a7622 10
      inst.instruction |= HWOFFSET_IMM;
      inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM8;
#ifndef TE_WINCE
      /* PC rel adjust.  */
      inst.reloc.exp.X_add_number -= 8;
#endif
      inst.reloc.pc_rel = 1;
      inst.instruction |= (REG_PC << 16);
      pre_inc = 1;
    }
d7624 4
a7627 2
  inst.instruction |= (pre_inc ? PRE_INDEX : 0);
  end_of_line (str);
d7630 2
a7631 2
static long
reg_list (char ** strp)
d7633 3
a7635 3
  char * str = * strp;
  long   range = 0;
  int    another_range;
d7637 3
a7639 4
  /* We come back here if we get ranges concatenated by '+' or '|'.  */
  do
    {
      another_range = 0;
d7641 6
a7646 4
      if (*str == '{')
	{
	  int in_range = 0;
	  int cur_reg = -1;
d7648 4
a7651 4
	  str++;
	  do
	    {
	      int reg;
d7653 4
a7656 1
	      skip_whitespace (str);
d7658 4
a7661 2
	      if ((reg = reg_required_here (& str, -1)) == FAIL)
		return FAIL;
d7663 15
a7677 3
	      if (in_range)
		{
		  int i;
d7679 1
a7679 5
		  if (reg <= cur_reg)
		    {
		      inst.error = _("bad range in register list");
		      return FAIL;
		    }
d7681 3
a7683 11
		  for (i = cur_reg + 1; i < reg; i++)
		    {
		      if (range & (1 << i))
			as_tsktsk
			  (_("Warning: duplicated register (r%d) in register list"),
			   i);
		      else
			range |= 1 << i;
		    }
		  in_range = 0;
		}
d7685 10
a7694 5
	      if (range & (1 << reg))
		as_tsktsk (_("Warning: duplicated register (r%d) in register list"),
			   reg);
	      else if (reg <= cur_reg)
		as_tsktsk (_("Warning: register range not in ascending order"));
d7696 2
a7697 7
	      range |= 1 << reg;
	      cur_reg = reg;
	    }
	  while (skip_past_comma (&str) != FAIL
		 || (in_range = 1, *str++ == '-'));
	  str--;
	  skip_whitespace (str);
d7699 4
a7702 9
	  if (*str++ != '}')
	    {
	      inst.error = _("missing `}'");
	      return FAIL;
	    }
	}
      else
	{
	  expressionS expr;
d7704 3
a7706 2
	  if (my_get_expression (&expr, &str))
	    return FAIL;
d7708 29
a7736 8
	  if (expr.X_op == O_constant)
	    {
	      if (expr.X_add_number
		  != (expr.X_add_number & 0x0000ffff))
		{
		  inst.error = _("invalid register mask");
		  return FAIL;
		}
d7738 3
a7740 3
	      if ((range & expr.X_add_number) != 0)
		{
		  int regno = range & expr.X_add_number;
d7742 5
a7746 6
		  regno &= -regno;
		  regno = (1 << regno) - 1;
		  as_tsktsk
		    (_("Warning: duplicated register (r%d) in register list"),
		     regno);
		}
d7748 65
a7812 9
	      range |= expr.X_add_number;
	    }
	  else
	    {
	      if (inst.reloc.type != 0)
		{
		  inst.error = _("expression too complex");
		  return FAIL;
		}
d7814 77
a7890 5
	      memcpy (&inst.reloc.exp, &expr, sizeof (expressionS));
	      inst.reloc.type = BFD_RELOC_ARM_MULTI;
	      inst.reloc.pc_rel = 0;
	    }
	}
d7892 10
a7901 1
      skip_whitespace (str);
d7903 17
a7919 7
      if (*str == '|' || *str == '+')
	{
	  str++;
	  another_range = 1;
	}
    }
  while (another_range);
d7921 150
a8070 3
  *strp = str;
  return range;
}
d8072 1
a8072 2
static void
do_ldmstm (char * str)
d8074 886
a8959 2
  int base_reg;
  long range;
d8961 5
a8965 1
  skip_whitespace (str);
d8967 28
a8994 2
  if ((base_reg = reg_required_here (&str, 16)) == FAIL)
    return;
d8996 15
a9010 5
  if (base_reg == REG_PC)
    {
      inst.error = _("r15 not allowed as base register");
      return;
    }
d9012 290
a9301 1
  skip_whitespace (str);
d9303 6
a9308 5
  if (*str == '!')
    {
      inst.instruction |= WRITE_BACK;
      str++;
    }
d9310 8
a9317 7
  if (skip_past_comma (&str) == FAIL
      || (range = reg_list (&str)) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d9319 5
a9323 5
  if (*str == '^')
    {
      str++;
      inst.instruction |= LDM_TYPE_2_OR_3;
    }
d9325 1
a9325 1
  if (inst.instruction & WRITE_BACK)
d9327 1
a9327 2
      /* Check for unpredictable uses of writeback.  */
      if (inst.instruction & LOAD_BIT)
d9329 2
a9330 7
	  /* Not allowed in LDM type 2.  */
	  if ((inst.instruction & LDM_TYPE_2_OR_3)
	      && ((range & (1 << REG_PC)) == 0))
	    as_warn (_("writeback of base register is UNPREDICTABLE"));
	  /* Only allowed if base reg not in list for other types.  */
	  else if (range & (1 << base_reg))
	    as_warn (_("writeback of base register when in register list is UNPREDICTABLE"));
d9332 4
a9335 1
      else /* STM.  */
d9337 2
a9338 7
	  /* Not allowed for type 2.  */
	  if (inst.instruction & LDM_TYPE_2_OR_3)
	    as_warn (_("writeback of base register is UNPREDICTABLE"));
	  /* Only allowed if base reg not in list, or first in list.  */
	  else if ((range & (1 << base_reg))
		   && (range & ((1 << base_reg) - 1)))
	    as_warn (_("if writeback register is in list, it must be the lowest reg in the list"));
d9342 1
a9342 2
  inst.instruction |= range;
  end_of_line (str);
d9345 5
a9349 2
static void
do_smi (char * str)
d9351 3
a9353 1
  skip_whitespace (str);
d9355 1
a9355 3
  /* Allow optional leading '#'.  */
  if (is_immediate_prefix (*str))
    str++;
d9357 11
a9367 2
  if (my_get_expression (& inst.reloc.exp, & str))
    return;
d9369 2
a9370 4
  inst.reloc.type = BFD_RELOC_ARM_SMI;
  inst.reloc.pc_rel = 0;
  end_of_line (str);
}
d9372 2
a9373 2
static void
do_swi (char * str)
d9375 4
a9378 1
  skip_whitespace (str);
d9380 3
a9382 3
  /* Allow optional leading '#'.  */
  if (is_immediate_prefix (*str))
    str++;
d9384 1
a9384 1
  if (my_get_expression (& inst.reloc.exp, & str))
d9387 3
a9389 4
  inst.reloc.type = BFD_RELOC_ARM_SWI;
  inst.reloc.pc_rel = 0;
  end_of_line (str);
}
d9391 2
a9392 4
static void
do_swap (char * str)
{
  int reg;
d9394 1
a9394 6
  skip_whitespace (str);

  if ((reg = reg_required_here (&str, 12)) == FAIL)
    return;

  if (reg == REG_PC)
d9396 5
a9400 2
      inst.error = _("r15 not allowed in swap");
      return;
d9402 1
a9402 3

  if (skip_past_comma (&str) == FAIL
      || (reg = reg_required_here (&str, 0)) == FAIL)
d9404 5
a9408 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d9411 1
a9411 1
  if (reg == REG_PC)
d9413 4
a9416 2
      inst.error = _("r15 not allowed in swap");
      return;
d9419 1
a9419 2
  if (skip_past_comma (&str) == FAIL
      || *str++ != '[')
d9421 4
a9424 2
      inst.error = BAD_ARGS;
      return;
d9427 3
a9429 1
  skip_whitespace (str);
d9431 2
a9432 2
  if ((reg = reg_required_here (&str, 16)) == FAIL)
    return;
d9434 4
a9437 5
  if (reg == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }
d9439 4
a9442 1
  skip_whitespace (str);
d9444 9
a9452 5
  if (*str++ != ']')
    {
      inst.error = _("missing ]");
      return;
    }
d9454 1
a9454 2
  end_of_line (str);
}
d9456 2
a9457 2
static void
do_branch (char * str)
d9459 3
a9461 2
  if (my_get_expression (&inst.reloc.exp, &str))
    return;
d9464 1
a9464 2
  {
    char * save_in;
d9466 15
a9480 2
    /* ScottB: February 5, 1998 - Check to see of PLT32 reloc
       required for the instruction.  */
d9482 3
a9484 26
    /* arm_parse_reloc () works on input_line_pointer.
       We actually want to parse the operands to the branch instruction
       passed in 'str'.  Save the input pointer and restore it later.  */
    save_in = input_line_pointer;
    input_line_pointer = str;
    if (inst.reloc.exp.X_op == O_symbol
	&& *str == '('
	&& arm_parse_reloc () == BFD_RELOC_ARM_PLT32)
      {
	inst.reloc.type   = BFD_RELOC_ARM_PLT32;
	inst.reloc.pc_rel = 0;
	/* Modify str to point to after parsed operands, otherwise
	   end_of_line() will complain about the (PLT) left in str.  */
	str = input_line_pointer;
      }
    else
      {
	inst.reloc.type   = BFD_RELOC_ARM_PCREL_BRANCH;
	inst.reloc.pc_rel = 1;
      }
    input_line_pointer = save_in;
  }
#else
  inst.reloc.type   = BFD_RELOC_ARM_PCREL_BRANCH;
  inst.reloc.pc_rel = 1;
#endif /* OBJ_ELF  */
d9486 3
a9488 1
  end_of_line (str);
d9491 2
a9492 2
static void
do_cdp (char * str)
d9494 2
a9495 3
  /* Co-processor data operation.
     Format: CDP{cond} CP#,<expr>,CRd,CRn,CRm{,<expr>}  */
  skip_whitespace (str);
d9497 4
a9500 6
  if (co_proc_number (&str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d9502 1
a9502 7
  if (skip_past_comma (&str) == FAIL
      || cp_opc_expr (&str, 20,4) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d9504 1
a9504 7
  if (skip_past_comma (&str) == FAIL
      || cp_reg_required_here (&str, 12) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d9506 4
a9509 7
  if (skip_past_comma (&str) == FAIL
      || cp_reg_required_here (&str, 16) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d9511 5
a9515 7
  if (skip_past_comma (&str) == FAIL
      || cp_reg_required_here (&str, 0) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d9517 3
a9519 12
  if (skip_past_comma (&str) == SUCCESS)
    {
      if (cp_opc_expr (&str, 5, 3) == FAIL)
	{
	  if (!inst.error)
	    inst.error = BAD_ARGS;
	  return;
	}
    }

  end_of_line (str);
}
d9522 1
a9522 1
do_lstc (char * str)
d9524 3
a9526 2
  /* Co-processor register load/store.
     Format: <LDC|STC{cond}[L] CP#,CRd,<address>  */
d9528 1
a9528 1
  skip_whitespace (str);
d9530 1
a9530 1
  if (co_proc_number (&str) == FAIL)
d9532 6
a9537 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d9539 1
a9539 3

  if (skip_past_comma (&str) == FAIL
      || cp_reg_required_here (&str, 12) == FAIL)
d9541 4
a9544 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d9546 1
d9548 1
a9548 10
  if (skip_past_comma (&str) == FAIL
      || cp_address_required_here (&str, CP_WB_OK) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}
d9551 1
a9551 1
do_co_reg (char * str)
d9553 1
a9553 2
  /* Co-processor register transfer.
     Format: <MCR|MRC>{cond} CP#,<expr1>,Rd,CRn,CRm{,<expr2>}  */
d9555 1
a9555 3
  skip_whitespace (str);

  if (co_proc_number (&str) == FAIL)
d9557 4
a9560 4
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d9562 6
a9567 7
  if (skip_past_comma (&str) == FAIL
      || cp_opc_expr (&str, 21, 3) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d9569 14
a9582 6
  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 12) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d9584 1
a9584 3

  if (skip_past_comma (&str) == FAIL
      || cp_reg_required_here (&str, 16) == FAIL)
d9586 4
a9589 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d9591 1
a9591 3

  if (skip_past_comma (&str) == FAIL
      || cp_reg_required_here (&str, 0) == FAIL)
d9593 3
a9595 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d9597 1
a9597 2

  if (skip_past_comma (&str) == SUCCESS)
d9599 2
a9600 1
      if (cp_opc_expr (&str, 5, 3) == FAIL)
d9602 2
a9603 3
	  if (!inst.error)
	    inst.error = BAD_ARGS;
	  return;
d9605 2
a9607 2

  end_of_line (str);
d9610 1
d9612 1
a9612 1
do_fpa_ctrl (char * str)
d9614 1
a9614 2
  /* FP control registers.
     Format: <WFS|RFS|WFC|RFC>{cond} Rn  */
d9616 5
a9620 1
  skip_whitespace (str);
d9622 3
a9624 5
  if (reg_required_here (&str, 12) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d9626 2
a9627 2

  end_of_line (str);
a9629 4
static void
do_fpa_ldst (char * str)
{
  skip_whitespace (str);
d9631 2
a9632 17
  if (fp_reg_required_here (&str, 12) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) == FAIL
      || cp_address_required_here (&str, CP_WB_OK) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}
d9635 1
a9635 1
do_fpa_ldmstm (char * str)
d9637 11
a9647 1
  int num_regs;
d9649 1
a9649 3
  skip_whitespace (str);

  if (fp_reg_required_here (&str, 12) == FAIL)
d9651 3
a9653 3
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
d9655 1
a9655 4

  /* Get Number of registers to transfer.  */
  if (skip_past_comma (&str) == FAIL
      || my_get_expression (&inst.reloc.exp, &str))
d9657 3
a9659 3
      if (! inst.error)
	inst.error = _("constant expression expected");
      return;
d9662 6
a9667 1
  if (inst.reloc.exp.X_op != O_constant)
d9669 2
a9670 2
      inst.error = _("constant value required for number of registers");
      return;
d9673 7
a9679 1
  num_regs = inst.reloc.exp.X_add_number;
d9681 3
a9683 5
  if (num_regs < 1 || num_regs > 4)
    {
      inst.error = _("number of registers must be in the range [1:4]");
      return;
    }
d9685 2
a9686 1
  switch (num_regs)
d9688 2
a9689 27
    case 1:
      inst.instruction |= CP_T_X;
      break;
    case 2:
      inst.instruction |= CP_T_Y;
      break;
    case 3:
      inst.instruction |= CP_T_Y | CP_T_X;
      break;
    case 4:
      break;
    default:
      abort ();
    }

  if (inst.instruction & (CP_T_Pre | CP_T_UD)) /* ea/fd format.  */
    {
      int reg;
      int write_back;
      int offset;

      /* The instruction specified "ea" or "fd", so we can only accept
	 [Rn]{!}.  The instruction does not really support stacking or
	 unstacking, so we have to emulate these by setting appropriate
	 bits and offsets.  */
      if (skip_past_comma (&str) == FAIL
	  || *str != '[')
d9691 3
a9693 2
	  if (! inst.error)
	    inst.error = BAD_ARGS;
d9696 3
d9700 24
a9723 2
      str++;
      skip_whitespace (str);
d9725 3
a9727 2
      if ((reg = reg_required_here (&str, 16)) == FAIL)
	return;
d9729 1
a9729 1
      skip_whitespace (str);
d9731 3
a9733 1
      if (*str != ']')
d9735 3
a9737 2
	  inst.error = BAD_ARGS;
	  return;
d9740 2
a9741 2
      str++;
      if (*str == '!')
d9743 4
a9746 8
	  write_back = 1;
	  str++;
	  if (reg == REG_PC)
	    {
	      inst.error =
		_("r15 not allowed as base register with write-back");
	      return;
	    }
a9747 2
      else
	write_back = 0;
d9749 2
a9750 1
      if (inst.instruction & CP_T_Pre)
d9752 4
a9755 9
	  /* Pre-decrement.  */
	  offset = 3 * num_regs;
	  if (write_back)
	    inst.instruction |= CP_T_WB;
	}
      else
	{
	  /* Post-increment.  */
	  if (write_back)
d9757 15
a9771 9
	      inst.instruction |= CP_T_WB;
	      offset = 3 * num_regs;
	    }
	  else
	    {
	      /* No write-back, so convert this into a standard pre-increment
		 instruction -- aesthetically more pleasing.  */
	      inst.instruction |= CP_T_Pre | CP_T_UD;
	      offset = 0;
d9773 1
d9775 19
d9795 1
a9795 4
      inst.instruction |= offset;
    }
  else if (skip_past_comma (&str) == FAIL
	   || cp_address_required_here (&str, CP_WB_OK) == FAIL)
d9797 13
a9809 4
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d9811 6
a9816 2
  end_of_line (str);
}
d9818 6
a9823 4
static void
do_fpa_dyadic (char * str)
{
  skip_whitespace (str);
d9825 3
a9827 5
  if (fp_reg_required_here (&str, 12) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
d9830 3
a9832 2
  if (skip_past_comma (&str) == FAIL
      || fp_reg_required_here (&str, 16) == FAIL)
d9834 10
a9843 3
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
d9846 2
a9847 2
  if (skip_past_comma (&str) == FAIL
      || fp_op2 (&str) == FAIL)
d9849 3
a9851 4
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d9853 1
a9853 13
  end_of_line (str);
}

static void
do_fpa_monadic (char * str)
{
  skip_whitespace (str);

  if (fp_reg_required_here (&str, 12) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
d9856 1
a9856 2
  if (skip_past_comma (&str) == FAIL
      || fp_op2 (&str) == FAIL)
d9858 3
a9860 3
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
d9863 1
a9863 1
  end_of_line (str);
d9866 4
a9869 2
static void
do_fpa_cmp (char * str)
d9871 1
a9871 1
  skip_whitespace (str);
d9873 2
a9874 6
  if (fp_reg_required_here (&str, 16) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d9876 2
a9877 7
  if (skip_past_comma (&str) == FAIL
      || fp_op2 (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d9879 1
a9879 2
  end_of_line (str);
}
d9881 2
a9882 2
static void
do_fpa_from_reg (char * str)
d9884 3
a9886 1
  skip_whitespace (str);
a9887 6
  if (fp_reg_required_here (&str, 16) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d9889 1
a9889 7
  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 12) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d9891 5
a9895 2
  end_of_line (str);
}
d9897 2
a9898 2
static void
do_fpa_to_reg (char * str)
d9900 1
a9900 1
  skip_whitespace (str);
d9902 7
a9908 2
  if (reg_required_here (&str, 12) == FAIL)
    return;
d9910 1
a9910 2
  if (skip_past_comma (&str) == FAIL
      || fp_reg_required_here (&str, 0) == FAIL)
d9912 7
a9918 4
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d9920 3
a9922 2
  end_of_line (str);
}
d9924 9
a9932 1
/* Encode a VFP SP register number.  */
d9934 10
a9943 8
static void
vfp_sp_encode_reg (int reg, enum vfp_sp_reg_pos pos)
{
  switch (pos)
    {
    case VFP_REG_Sd:
      inst.instruction |= ((reg >> 1) << 12) | ((reg & 1) << 22);
      break;
d9945 9
a9953 3
    case VFP_REG_Sn:
      inst.instruction |= ((reg >> 1) << 16) | ((reg & 1) << 7);
      break;
a9954 3
    case VFP_REG_Sm:
      inst.instruction |= ((reg >> 1) << 0) | ((reg & 1) << 5);
      break;
d9956 1
d9958 1
a9958 1
      abort ();
d9962 5
a9966 3
static int
vfp_sp_reg_required_here (char ** str,
			  enum vfp_sp_reg_pos pos)
d9968 12
a9979 2
  int    reg;
  char * start = *str;
d9981 1
a9981 4
  if ((reg = arm_reg_parse (str, all_reg_maps[REG_TYPE_SN].htab)) != FAIL)
    {
      vfp_sp_encode_reg (reg, pos);
      return reg;
d9983 1
d9985 1
a9985 7
  /* In the few cases where we might be able to accept something else
     this error can be overridden.  */
  inst.error = _(all_reg_maps[REG_TYPE_SN].expected);

  /* Restore the start point.  */
  *str = start;
  return FAIL;
d9988 4
a9991 6
static int
vfp_dp_reg_required_here (char ** str,
			  enum vfp_dp_reg_pos pos)
{
  int    reg;
  char * start = *str;
d9993 6
a9998 7
  if ((reg = arm_reg_parse (str, all_reg_maps[REG_TYPE_DN].htab)) != FAIL)
    {
      switch (pos)
	{
	case VFP_REG_Dd:
	  inst.instruction |= reg << 12;
	  break;
d10000 20
a10019 3
	case VFP_REG_Dn:
	  inst.instruction |= reg << 16;
	  break;
d10021 2
a10022 13
	case VFP_REG_Dm:
	  inst.instruction |= reg << 0;
	  break;

	default:
	  abort ();
	}
      return reg;
    }

  /* In the few cases where we might be able to accept something else
     this error can be overridden.  */
  inst.error = _(all_reg_maps[REG_TYPE_DN].expected);
a10023 2
  /* Restore the start point.  */
  *str = start;
d10027 2
a10028 2
static void
do_vfp_sp_monadic (char * str)
d10030 4
a10033 1
  skip_whitespace (str);
d10035 10
a10044 2
  if (vfp_sp_reg_required_here (&str, VFP_REG_Sd) == FAIL)
    return;
d10046 6
a10051 7
  if (skip_past_comma (&str) == FAIL
      || vfp_sp_reg_required_here (&str, VFP_REG_Sm) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10053 2
a10054 2
  end_of_line (str);
}
d10056 8
a10063 4
static void
do_vfp_dp_monadic (char * str)
{
  skip_whitespace (str);
d10065 4
a10068 2
  if (vfp_dp_reg_required_here (&str, VFP_REG_Dd) == FAIL)
    return;
d10070 4
a10073 7
  if (skip_past_comma (&str) == FAIL
      || vfp_dp_reg_required_here (&str, VFP_REG_Dm) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10075 4
a10078 2
  end_of_line (str);
}
d10080 5
a10084 4
static void
do_vfp_sp_dyadic (char * str)
{
  skip_whitespace (str);
d10086 4
a10089 2
  if (vfp_sp_reg_required_here (&str, VFP_REG_Sd) == FAIL)
    return;
d10091 4
a10094 9
  if (skip_past_comma (&str) == FAIL
      || vfp_sp_reg_required_here (&str, VFP_REG_Sn) == FAIL
      || skip_past_comma (&str) == FAIL
      || vfp_sp_reg_required_here (&str, VFP_REG_Sm) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10096 4
a10099 2
  end_of_line (str);
}
d10101 4
a10104 4
static void
do_vfp_dp_dyadic (char * str)
{
  skip_whitespace (str);
d10106 4
a10109 2
  if (vfp_dp_reg_required_here (&str, VFP_REG_Dd) == FAIL)
    return;
d10111 3
a10113 8
  if (skip_past_comma (&str) == FAIL
      || vfp_dp_reg_required_here (&str, VFP_REG_Dn) == FAIL
      || skip_past_comma (&str) == FAIL
      || vfp_dp_reg_required_here (&str, VFP_REG_Dm) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
d10116 6
a10121 1
  end_of_line (str);
d10124 4
a10127 2
static void
do_vfp_reg_from_sp (char * str)
d10129 6
a10134 1
  skip_whitespace (str);
d10136 1
a10136 2
  if (reg_required_here (&str, 12) == FAIL)
    return;
d10138 3
a10140 7
  if (skip_past_comma (&str) == FAIL
      || vfp_sp_reg_required_here (&str, VFP_REG_Sn) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10142 6
a10147 2
  end_of_line (str);
}
d10149 2
a10150 18
/* Parse a VFP register list.  If the string is invalid return FAIL.
   Otherwise return the number of registers, and set PBASE to the first
   register.  Double precision registers are matched if DP is nonzero.  */

static int
vfp_parse_reg_list (char **str, int *pbase, int dp)
{
  int base_reg;
  int new_base;
  int regtype;
  int max_regs;
  int count = 0;
  int warned = 0;
  unsigned long mask = 0;
  int i;

  if (**str != '{')
    return FAIL;
d10152 4
a10155 2
  (*str)++;
  skip_whitespace (*str);
d10157 1
a10157 1
  if (dp)
d10159 4
a10162 8
      regtype = REG_TYPE_DN;
      max_regs = 16;
    }
  else
    {
      regtype = REG_TYPE_SN;
      max_regs = 32;
    }
d10164 5
a10168 1
  base_reg = max_regs;
d10170 2
a10171 4
  do
    {
      new_base = arm_reg_parse (str, all_reg_maps[regtype].htab);
      if (new_base == FAIL)
d10173 4
a10176 2
	  inst.error = _(all_reg_maps[regtype].expected);
	  return FAIL;
d10179 2
a10180 2
      if (new_base < base_reg)
	base_reg = new_base;
d10182 4
a10185 1
      if (mask & (1 << new_base))
d10187 4
a10190 2
	  inst.error = _("invalid register list");
	  return FAIL;
d10193 3
a10195 5
      if ((mask >> new_base) != 0 && ! warned)
	{
	  as_tsktsk (_("register list not in ascending order"));
	  warned = 1;
	}
d10197 4
a10200 2
      mask |= 1 << new_base;
      count++;
d10202 2
a10203 1
      skip_whitespace (*str);
d10205 8
a10212 3
      if (**str == '-') /* We have the start of a range expression */
	{
	  int high_range;
d10214 15
a10228 1
	  (*str)++;
d10230 7
a10236 7
	  if ((high_range
	       = arm_reg_parse (str, all_reg_maps[regtype].htab))
	      == FAIL)
	    {
	      inst.error = _(all_reg_maps[regtype].expected);
	      return FAIL;
	    }
d10238 2
a10239 5
	  if (high_range <= new_base)
	    {
	      inst.error = _("register range not in ascending order");
	      return FAIL;
	    }
d10241 11
a10251 7
	  for (new_base++; new_base <= high_range; new_base++)
	    {
	      if (mask & (1 << new_base))
		{
		  inst.error = _("invalid register list");
		  return FAIL;
		}
d10253 10
a10262 3
	      mask |= 1 << new_base;
	      count++;
	    }
a10263 2
    }
  while (skip_past_comma (str) != FAIL);
d10265 5
a10269 1
  (*str)++;
d10271 3
a10273 3
  /* Sanity check -- should have raised a parse error above.  */
  if (count == 0 || count > max_regs)
    abort ();
d10275 2
a10276 1
  *pbase = base_reg;
d10278 1
a10278 5
  /* Final test -- the registers must be consecutive.  */
  mask >>= base_reg;
  for (i = 0; i < count; i++)
    {
      if ((mask & (1u << i)) == 0)
d10280 7
a10286 2
	  inst.error = _("non-contiguous register range");
	  return FAIL;
a10287 1
    }
d10289 11
a10299 2
  return count;
}
d10301 27
a10327 4
static void
do_vfp_reg2_from_sp2 (char * str)
{
  int reg;
d10329 86
a10414 1
  skip_whitespace (str);
d10416 4
a10419 9
  if (reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 16) == FAIL
      || skip_past_comma (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10421 10
a10430 7
  /* We require exactly two consecutive SP registers.  */
  if (vfp_parse_reg_list (&str, &reg, 0) != 2)
    {
      if (! inst.error)
	inst.error = _("only two consecutive VFP SP registers allowed here");
    }
  vfp_sp_encode_reg (reg, VFP_REG_Sm);
d10432 9
a10440 2
  end_of_line (str);
}
d10442 5
a10446 4
static void
do_vfp_sp_from_reg (char * str)
{
  skip_whitespace (str);
d10448 8
a10455 2
  if (vfp_sp_reg_required_here (&str, VFP_REG_Sn) == FAIL)
    return;
d10457 3
a10459 7
  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 12) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10461 1
a10461 2
  end_of_line (str);
}
d10463 8
a10470 4
static void
do_vfp_sp2_from_reg2 (char * str)
{
  int reg;
d10472 3
a10474 1
  skip_whitespace (str);
d10476 3
a10478 7
  /* We require exactly two consecutive SP registers.  */
  if (vfp_parse_reg_list (&str, &reg, 0) != 2)
    {
      if (! inst.error)
	inst.error = _("only two consecutive VFP SP registers allowed here");
    }
  vfp_sp_encode_reg (reg, VFP_REG_Sm);
d10480 8
a10487 9
  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 16) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10489 20
a10508 2
  end_of_line (str);
}
d10510 7
a10516 4
static void
do_vfp_reg_from_dp (char * str)
{
  skip_whitespace (str);
d10518 4
a10521 2
  if (reg_required_here (&str, 12) == FAIL)
    return;
d10523 10
a10532 7
  if (skip_past_comma (&str) == FAIL
      || vfp_dp_reg_required_here (&str, VFP_REG_Dn) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10534 7
a10540 2
  end_of_line (str);
}
d10542 11
a10552 4
static void
do_vfp_reg2_from_dp (char * str)
{
  skip_whitespace (str);
d10554 5
a10558 2
  if (reg_required_here (&str, 12) == FAIL)
    return;
d10560 5
a10564 9
  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 16) == FAIL
      || skip_past_comma (&str) == FAIL
      || vfp_dp_reg_required_here (&str, VFP_REG_Dm) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10566 5
a10570 2
  end_of_line (str);
}
d10572 7
a10578 4
static void
do_vfp_dp_from_reg (char * str)
{
  skip_whitespace (str);
d10580 4
a10583 2
  if (vfp_dp_reg_required_here (&str, VFP_REG_Dn) == FAIL)
    return;
d10585 7
a10591 7
  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 12) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10593 4
a10596 2
  end_of_line (str);
}
d10598 7
a10604 4
static void
do_vfp_dp_from_reg2 (char * str)
{
  skip_whitespace (str);
d10606 4
a10609 2
  if (vfp_dp_reg_required_here (&str, VFP_REG_Dm) == FAIL)
    return;
d10611 4
a10614 9
  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 16) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10616 14
a10629 2
  end_of_line (str);
}
d10631 5
a10635 7
static const struct vfp_reg *
vfp_psr_parse (char ** str)
{
  char *start = *str;
  char  c;
  char *p;
  const struct vfp_reg *vreg;
d10637 19
a10655 1
  p = start;
d10657 4
a10660 6
  /* Find the end of the current token.  */
  do
    {
      c = *p++;
    }
  while (ISALPHA (c));
d10662 4
a10665 2
  /* Mark it.  */
  *--p = 0;
d10667 15
a10681 9
  for (vreg = vfp_regs + 0;
       vreg < vfp_regs + sizeof (vfp_regs) / sizeof (struct vfp_reg);
       vreg++)
    {
      if (streq (start, vreg->name))
	{
	  *p = c;
	  *str = p;
	  return vreg;
d10683 1
a10683 1
    }
d10685 4
a10688 3
  *p = c;
  return NULL;
}
d10690 4
a10693 5
static int
vfp_psr_required_here (char ** str)
{
  char *start = *str;
  const struct vfp_reg *vreg;
d10695 8
a10702 1
  vreg = vfp_psr_parse (str);
d10704 7
a10710 5
  if (vreg)
    {
      inst.instruction |= vreg->regno;
      return SUCCESS;
    }
d10712 9
a10720 1
  inst.error = _("VFP system register expected");
d10722 15
a10736 3
  *str = start;
  return FAIL;
}
d10738 14
a10751 4
static void
do_vfp_reg_from_ctrl (char * str)
{
  skip_whitespace (str);
d10753 5
a10757 2
  if (reg_required_here (&str, 12) == FAIL)
    return;
d10759 16
a10774 7
  if (skip_past_comma (&str) == FAIL
      || vfp_psr_required_here (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10776 4
a10779 2
  end_of_line (str);
}
d10781 2
a10782 4
static void
do_vfp_ctrl_from_reg (char * str)
{
  skip_whitespace (str);
d10784 7
a10790 2
  if (vfp_psr_required_here (&str) == FAIL)
    return;
d10792 7
a10798 7
  if (skip_past_comma (&str) == FAIL
      || reg_required_here (&str, 12) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10800 7
a10806 2
  end_of_line (str);
}
d10808 7
a10814 4
static void
do_vfp_sp_ldst (char * str)
{
  skip_whitespace (str);
d10816 8
a10823 6
  if (vfp_sp_reg_required_here (&str, VFP_REG_Sd) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10825 3
a10827 7
  if (skip_past_comma (&str) == FAIL
      || cp_address_required_here (&str, CP_NO_WB) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10829 4
a10832 2
  end_of_line (str);
}
d10834 2
a10835 4
static void
do_vfp_dp_ldst (char * str)
{
  skip_whitespace (str);
d10837 9
a10845 6
  if (vfp_dp_reg_required_here (&str, VFP_REG_Dd) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10847 6
a10852 7
  if (skip_past_comma (&str) == FAIL
      || cp_address_required_here (&str, CP_NO_WB) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d10854 9
a10862 2
  end_of_line (str);
}
d10864 37
d10902 9
a10910 5
static void
vfp_sp_ldstm (char * str, enum vfp_ldstm_type ldstm_type)
{
  int count;
  int reg;
d10912 16
a10927 1
  skip_whitespace (str);
d10929 3
a10931 13
  if (reg_required_here (&str, 16) == FAIL)
    return;

  skip_whitespace (str);

  if (*str == '!')
    {
      inst.instruction |= WRITE_BACK;
      str++;
    }
  else if (ldstm_type != VFP_LDSTMIA)
    {
      inst.error = _("this addressing mode requires base-register writeback");
a10932 1
    }
d10934 4
a10937 6
  if (skip_past_comma (&str) == FAIL
      || (count = vfp_parse_reg_list (&str, &reg, 0)) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d10939 1
a10939 1
  vfp_sp_encode_reg (reg, VFP_REG_Sd);
d10941 2
a10942 3
  inst.instruction |= count;
  end_of_line (str);
}
d10944 3
a10946 2
static void
vfp_dp_ldstm (char * str, enum vfp_ldstm_type ldstm_type)
d10948 2
a10949 2
  int count;
  int reg;
d10951 1
a10951 1
  skip_whitespace (str);
d10953 3
a10955 2
  if (reg_required_here (&str, 16) == FAIL)
    return;
d10957 3
a10959 1
  skip_whitespace (str);
d10961 1
a10961 1
  if (*str == '!')
d10963 20
a10982 8
      inst.instruction |= WRITE_BACK;
      str++;
    }
  else if (ldstm_type != VFP_LDSTMIA && ldstm_type != VFP_LDSTMIAX)
    {
      inst.error = _("this addressing mode requires base-register writeback");
      return;
    }
d10984 15
a10998 7
  if (skip_past_comma (&str) == FAIL
      || (count = vfp_parse_reg_list (&str, &reg, 1)) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d11000 7
a11006 3
  count <<= 1;
  if (ldstm_type == VFP_LDSTMIAX || ldstm_type == VFP_LDSTMDBX)
    count += 1;
d11008 13
a11020 3
  inst.instruction |= (reg << 12) | count;
  end_of_line (str);
}
d11022 10
a11031 5
static void
do_vfp_sp_ldstmia (char * str)
{
  vfp_sp_ldstm (str, VFP_LDSTMIA);
}
d11033 4
a11036 5
static void
do_vfp_sp_ldstmdb (char * str)
{
  vfp_sp_ldstm (str, VFP_LDSTMDB);
}
d11038 4
a11041 5
static void
do_vfp_dp_ldstmia (char * str)
{
  vfp_dp_ldstm (str, VFP_LDSTMIA);
}
d11043 10
a11052 5
static void
do_vfp_dp_ldstmdb (char * str)
{
  vfp_dp_ldstm (str, VFP_LDSTMDB);
}
d11054 3
a11056 5
static void
do_vfp_xp_ldstmia (char *str)
{
  vfp_dp_ldstm (str, VFP_LDSTMIAX);
}
d11058 3
a11060 5
static void
do_vfp_xp_ldstmdb (char * str)
{
  vfp_dp_ldstm (str, VFP_LDSTMDBX);
}
d11062 21
a11082 4
static void
do_vfp_sp_compare_z (char * str)
{
  skip_whitespace (str);
d11084 4
a11087 1
  if (vfp_sp_reg_required_here (&str, VFP_REG_Sd) == FAIL)
d11089 2
a11090 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d11092 1
d11094 1
a11094 2
  end_of_line (str);
}
d11096 1
a11096 6
static void
do_vfp_dp_compare_z (char * str)
{
  skip_whitespace (str);

  if (vfp_dp_reg_required_here (&str, VFP_REG_Dd) == FAIL)
d11098 4
a11101 3
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
d11104 6
a11109 1
  end_of_line (str);
d11112 7
a11118 2
static void
do_vfp_dp_sp_cvt (char * str)
d11120 2
a11121 1
  skip_whitespace (str);
d11123 3
a11125 5
  if (vfp_dp_reg_required_here (&str, VFP_REG_Dd) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || vfp_sp_reg_required_here (&str, VFP_REG_Sm) == FAIL)
d11127 13
a11139 3
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
d11142 1
a11142 1
  end_of_line (str);
d11145 3
a11147 2
static void
do_vfp_sp_dp_cvt (char * str)
d11149 8
a11156 7
  skip_whitespace (str);

  if (vfp_sp_reg_required_here (&str, VFP_REG_Sd) == FAIL)
    return;

  if (skip_past_comma (&str) == FAIL
      || vfp_dp_reg_required_here (&str, VFP_REG_Dm) == FAIL)
d11158 1
a11158 3
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
a11159 2

  end_of_line (str);
d11161 1
d11163 2
a11164 7
/* Thumb specific routines.  */

/* Parse an add or subtract instruction, SUBTRACT is non-zero if the opcode
   was SUB.  */

static void
thumb_add_sub (char * str, int subtract)
d11166 4
a11169 1
  int Rd, Rs, Rn = FAIL;
d11171 5
a11175 1
  skip_whitespace (str);
d11177 2
a11178 7
  if ((Rd = thumb_reg (&str, THUMB_REG_ANY)) == FAIL
      || skip_past_comma (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d11180 6
a11185 11
  if (is_immediate_prefix (*str))
    {
      Rs = Rd;
      str++;
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
    }
  else
    {
      if ((Rs = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
	return;
d11187 8
a11194 16
      if (skip_past_comma (&str) == FAIL)
	{
	  /* Two operand format, shuffle the registers
	     and pretend there are 3.  */
	  Rn = Rs;
	  Rs = Rd;
	}
      else if (is_immediate_prefix (*str))
	{
	  str++;
	  if (my_get_expression (&inst.reloc.exp, &str))
	    return;
	}
      else if ((Rn = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
	return;
    }
d11196 6
a11201 12
  /* We now have Rd and Rs set to registers, and Rn set to a register or FAIL;
     for the latter case, EXPR contains the immediate that was found.  */
  if (Rn != FAIL)
    {
      /* All register format.  */
      if (Rd > 7 || Rs > 7 || Rn > 7)
	{
	  if (Rs != Rd)
	    {
	      inst.error = _("dest and source1 must be the same register");
	      return;
	    }
d11203 6
a11208 6
	  /* Can't do this for SUB.  */
	  if (subtract)
	    {
	      inst.error = _("subtract valid only on lo regs");
	      return;
	    }
d11210 5
a11214 14
	  inst.instruction = (T_OPCODE_ADD_HI
			      | (Rd > 7 ? THUMB_H1 : 0)
			      | (Rn > 7 ? THUMB_H2 : 0));
	  inst.instruction |= (Rd & 7) | ((Rn & 7) << 3);
	}
      else
	{
	  inst.instruction = subtract ? T_OPCODE_SUB_R3 : T_OPCODE_ADD_R3;
	  inst.instruction |= Rd | (Rs << 3) | (Rn << 6);
	}
    }
  else
    {
      /* Immediate expression, now things start to get nasty.  */
d11216 3
a11218 8
      /* First deal with HI regs, only very restricted cases allowed:
	 Adjusting SP, and using PC or SP to get an address.  */
      if ((Rd > 7 && (Rd != REG_SP || Rs != REG_SP))
	  || (Rs > 7 && Rs != REG_SP && Rs != REG_PC))
	{
	  inst.error = _("invalid Hi register with immediate");
	  return;
	}
d11220 4
a11223 11
      if (inst.reloc.exp.X_op != O_constant)
	{
	  /* Value isn't known yet, all we can do is store all the fragments
	     we know about in the instruction and let the reloc hacking
	     work it all out.  */
	  inst.instruction = (subtract ? 0x8000 : 0) | (Rd << 4) | Rs;
	  inst.reloc.type = BFD_RELOC_ARM_THUMB_ADD;
	}
      else
	{
	  int offset = inst.reloc.exp.X_add_number;
d11225 11
a11235 2
	  if (subtract)
	    offset = - offset;
d11237 2
a11238 4
	  if (offset < 0)
	    {
	      offset = - offset;
	      subtract = 1;
d11240 18
a11257 11
	      /* Quick check, in case offset is MIN_INT.  */
	      if (offset < 0)
		{
		  inst.error = _("immediate value out of range");
		  return;
		}
	    }
	  /* Note - you cannot convert a subtract of 0 into an
	     add of 0 because the carry flag is set differently.  */
	  else if (offset > 0)
	    subtract = 0;
d11259 5
a11263 46
	  if (Rd == REG_SP)
	    {
	      if (offset & ~0x1fc)
		{
		  inst.error = _("invalid immediate value for stack adjust");
		  return;
		}
	      inst.instruction = subtract ? T_OPCODE_SUB_ST : T_OPCODE_ADD_ST;
	      inst.instruction |= offset >> 2;
	    }
	  else if (Rs == REG_PC || Rs == REG_SP)
	    {
	      if (subtract
		  || (offset & ~0x3fc))
		{
		  inst.error = _("invalid immediate for address calculation");
		  return;
		}
	      inst.instruction = (Rs == REG_PC ? T_OPCODE_ADD_PC
				  : T_OPCODE_ADD_SP);
	      inst.instruction |= (Rd << 8) | (offset >> 2);
	    }
	  else if (Rs == Rd)
	    {
	      if (offset & ~0xff)
		{
		  inst.error = _("immediate value out of range");
		  return;
		}
	      inst.instruction = subtract ? T_OPCODE_SUB_I8 : T_OPCODE_ADD_I8;
	      inst.instruction |= (Rd << 8) | offset;
	    }
	  else
	    {
	      if (offset & ~0x7)
		{
		  inst.error = _("immediate value out of range");
		  return;
		}
	      inst.instruction = subtract ? T_OPCODE_SUB_I3 : T_OPCODE_ADD_I3;
	      inst.instruction |= Rd | (Rs << 3) | (offset << 6);
	    }
	}
    }

  end_of_line (str);
d11265 1
d11267 1
a11267 4
static void
thumb_shift (char * str, int shift)
{
  int Rd, Rs, Rn = FAIL;
d11269 3
a11271 1
  skip_whitespace (str);
d11273 4
a11276 7
  if ((Rd = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || skip_past_comma (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d11278 1
a11278 1
  if (is_immediate_prefix (*str))
d11280 6
a11285 5
      /* Two operand immediate format, set Rs to Rd.  */
      Rs = Rd;
      str ++;
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
d11287 1
a11287 4
  else
    {
      if ((Rs = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
	return;
d11289 2
a11290 16
      if (skip_past_comma (&str) == FAIL)
	{
	  /* Two operand format, shuffle the registers
	     and pretend there are 3.  */
	  Rn = Rs;
	  Rs = Rd;
	}
      else if (is_immediate_prefix (*str))
	{
	  str++;
	  if (my_get_expression (&inst.reloc.exp, &str))
	    return;
	}
      else if ((Rn = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
	return;
    }
d11292 5
a11296 2
  /* We now have Rd and Rs set to registers, and Rn set to a register or FAIL;
     for the latter case, EXPR contains the immediate that was found.  */
d11298 1
a11298 1
  if (Rn != FAIL)
d11300 1
a11300 1
      if (Rs != Rd)
d11302 6
a11307 3
	  inst.error = _("source1 and dest must be same register");
	  return;
	}
d11309 21
a11329 5
      switch (shift)
	{
	case THUMB_ASR: inst.instruction = T_OPCODE_ASR_R; break;
	case THUMB_LSL: inst.instruction = T_OPCODE_LSL_R; break;
	case THUMB_LSR: inst.instruction = T_OPCODE_LSR_R; break;
d11332 2
a11333 1
      inst.instruction |= Rd | (Rn << 3);
d11335 6
a11340 1
  else
d11342 1
a11342 1
      switch (shift)
d11344 1
a11344 4
	case THUMB_ASR: inst.instruction = T_OPCODE_ASR_I; break;
	case THUMB_LSL: inst.instruction = T_OPCODE_LSL_I; break;
	case THUMB_LSR: inst.instruction = T_OPCODE_LSR_I; break;
	}
d11346 2
a11347 9
      if (inst.reloc.exp.X_op != O_constant)
	{
	  /* Value isn't known yet, create a dummy reloc and let reloc
	     hacking fix it up.  */
	  inst.reloc.type = BFD_RELOC_ARM_THUMB_SHIFT;
	}
      else
	{
	  unsigned shift_value = inst.reloc.exp.X_add_number;
d11349 1
a11349 1
	  if (shift_value > 32 || (shift_value == 32 && shift == THUMB_LSL))
d11351 8
a11358 2
	      inst.error = _("invalid immediate for shift");
	      return;
a11359 10

	  /* Shifts of zero are handled by converting to LSL.  */
	  if (shift_value == 0)
	    inst.instruction = T_OPCODE_LSL_I;

	  /* Shifts of 32 are encoded as a shift of zero.  */
	  if (shift_value == 32)
	    shift_value = 0;

	  inst.instruction |= shift_value << 6;
a11360 2

      inst.instruction |= Rd | (Rs << 3);
d11362 2
d11365 1
a11365 2
  end_of_line (str);
}
d11368 1
a11368 1
thumb_load_store (char * str, int load_store, int size)
d11370 1
a11370 1
  int Rd, Rb, Ro = FAIL;
d11372 4
a11375 1
  skip_whitespace (str);
d11377 5
a11381 7
  if ((Rd = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || skip_past_comma (&str) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }
d11383 7
a11389 5
  if (*str == '[')
    {
      str++;
      if ((Rb = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
	return;
d11391 14
a11404 16
      if (skip_past_comma (&str) != FAIL)
	{
	  if (is_immediate_prefix (*str))
	    {
	      str++;
	      if (my_get_expression (&inst.reloc.exp, &str))
		return;
	    }
	  else if ((Ro = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
	    return;
	}
      else
	{
	  inst.reloc.exp.X_op = O_constant;
	  inst.reloc.exp.X_add_number = 0;
	}
d11406 1
a11406 14
      if (*str != ']')
	{
	  inst.error = _("expected ']'");
	  return;
	}
      str++;
    }
  else if (*str == '=')
    {
      if (load_store != THUMB_LOAD)
	{
	  inst.error = _("invalid pseudo operation");
	  return;
	}
d11408 5
a11412 44
      /* Parse an "ldr Rd, =expr" instruction; this is another pseudo op.  */
      str++;

      skip_whitespace (str);

      if (my_get_expression (& inst.reloc.exp, & str))
	return;

      end_of_line (str);

      if (   inst.reloc.exp.X_op != O_constant
	  && inst.reloc.exp.X_op != O_symbol)
	{
	  inst.error = "Constant expression expected";
	  return;
	}

      if (inst.reloc.exp.X_op == O_constant
	  && ((inst.reloc.exp.X_add_number & ~0xFF) == 0))
	{
	  /* This can be done with a mov instruction.  */

	  inst.instruction  = T_OPCODE_MOV_I8 | (Rd << 8);
	  inst.instruction |= inst.reloc.exp.X_add_number;
	  return;
	}

      /* Insert into literal pool.  */
      if (add_to_lit_pool () == FAIL)
	{
	  if (!inst.error)
	    inst.error = "literal pool insertion failed";
	  return;
	}

      inst.reloc.type   = BFD_RELOC_ARM_THUMB_OFFSET;
      inst.reloc.pc_rel = 1;
      inst.instruction  = T_OPCODE_LDR_PC | (Rd << 8);
      /* Adjust ARM pipeline offset to Thumb.  */
      inst.reloc.exp.X_add_number += 4;

      return;
    }
  else
d11414 2
a11415 2
      if (my_get_expression (&inst.reloc.exp, &str))
	return;
d11417 1
a11417 6
      inst.instruction = T_OPCODE_LDR_PC | (Rd << 8);
      inst.reloc.pc_rel = 1;
      inst.reloc.exp.X_add_number -= 4; /* Pipeline offset.  */
      inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;
      end_of_line (str);
      return;
d11419 2
d11422 1
a11422 1
  if (Rb == REG_PC || Rb == REG_SP)
d11424 2
a11425 15
      if (size != THUMB_WORD)
	{
	  inst.error = _("byte or halfword not valid for base register");
	  return;
	}
      else if (Rb == REG_PC && load_store != THUMB_LOAD)
	{
	  inst.error = _("r15 based store not allowed");
	  return;
	}
      else if (Ro != FAIL)
	{
	  inst.error = _("invalid base register for register offset");
	  return;
	}
d11427 1
a11427 22
      if (Rb == REG_PC)
	inst.instruction = T_OPCODE_LDR_PC;
      else if (load_store == THUMB_LOAD)
	inst.instruction = T_OPCODE_LDR_SP;
      else
	inst.instruction = T_OPCODE_STR_SP;

      inst.instruction |= Rd << 8;
      if (inst.reloc.exp.X_op == O_constant)
	{
	  unsigned offset = inst.reloc.exp.X_add_number;

	  if (offset & ~0x3fc)
	    {
	      inst.error = _("invalid offset");
	      return;
	    }

	  inst.instruction |= offset >> 2;
	}
      else
	inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;
d11429 1
a11429 1
  else if (Rb > 7)
d11431 10
a11440 2
      inst.error = _("invalid base register in load/store");
      return;
a11441 12
  else if (Ro == FAIL)
    {
      /* Immediate offset.  */
      if (size == THUMB_WORD)
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_IW : T_OPCODE_STR_IW);
      else if (size == THUMB_HALFWORD)
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_IH : T_OPCODE_STR_IH);
      else
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_IB : T_OPCODE_STR_IB);
d11443 1
a11443 17
      inst.instruction |= Rd | (Rb << 3);

      if (inst.reloc.exp.X_op == O_constant)
	{
	  unsigned offset = inst.reloc.exp.X_add_number;

	  if (offset & ~(0x1f << size))
	    {
	      inst.error = _("invalid offset");
	      return;
	    }
	  inst.instruction |= (offset >> size) << 6;
	}
      else
	inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;
    }
  else
d11445 4
a11448 7
      /* Register offset.  */
      if (size == THUMB_WORD)
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_RW : T_OPCODE_STR_RW);
      else if (size == THUMB_HALFWORD)
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_RH : T_OPCODE_STR_RH);
d11450 1
a11450 4
	inst.instruction = (load_store == THUMB_LOAD
			    ? T_OPCODE_LDR_RB : T_OPCODE_STR_RB);

      inst.instruction |= Rd | (Rb << 3) | (Ro << 6);
d11453 2
a11454 2
  end_of_line (str);
}
d11456 1
a11456 1
/* A register must be given at this point.
d11458 3
a11460 1
   Shift is the place to put it in inst.instruction.
d11462 2
a11463 2
   Restores input start point on err.
   Returns the reg#, or FAIL.  */
d11465 12
a11476 5
static int
mav_reg_required_here (char ** str, int shift, enum arm_reg_type regtype)
{
  int   reg;
  char *start = *str;
d11478 6
a11483 4
  if ((reg = arm_reg_parse (str, all_reg_maps[regtype].htab)) != FAIL)
    {
      if (shift >= 0)
	inst.instruction |= reg << shift;
d11485 5
a11489 2
      return reg;
    }
d11491 3
a11493 2
  /* Restore the start point.  */
  *str = start;
d11495 4
a11498 10
  /* Try generic coprocessor name if applicable.  */
  if (regtype == REG_TYPE_MVF ||
      regtype == REG_TYPE_MVD ||
      regtype == REG_TYPE_MVFX ||
      regtype == REG_TYPE_MVDX)
    {
      if ((reg = arm_reg_parse (str, all_reg_maps[REG_TYPE_CN].htab)) != FAIL)
	{
	  if (shift >= 0)
	    inst.instruction |= reg << shift;
d11500 3
a11502 2
	  return reg;
	}
d11504 5
a11508 3
      /* Restore the start point.  */
      *str = start;
    }
d11510 6
a11515 3
  /* In the few cases where we might be able to accept something else
     this error can be overridden.  */
  inst.error = _(all_reg_maps[regtype].expected);
d11517 1
a11517 2
  return FAIL;
}
d11519 10
a11528 1
/* Cirrus Maverick Instructions.  */
d11530 6
a11535 1
/* Isnsn like "foo X,Y".  */
d11537 3
a11539 7
static void
do_mav_binops (char * str,
	       int mode,
	       enum arm_reg_type reg0,
	       enum arm_reg_type reg1)
{
  int shift0, shift1;
d11541 3
a11543 2
  shift0 = mode & 0xff;
  shift1 = (mode >> 8) & 0xff;
d11545 4
a11548 1
  skip_whitespace (str);
d11550 17
a11566 3
  if (mav_reg_required_here (&str, shift0, reg0) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, shift1, reg1) == FAIL)
d11568 4
a11571 2
      if (!inst.error)
	inst.error = BAD_ARGS;
d11573 4
a11576 2
  else
    end_of_line (str);
d11579 1
a11579 1
/* Isnsn like "foo X,Y,Z".  */
d11581 3
a11583 8
static void
do_mav_triple (char * str,
	       int mode,
	       enum arm_reg_type reg0,
	       enum arm_reg_type reg1,
	       enum arm_reg_type reg2)
{
  int shift0, shift1, shift2;
d11585 4
a11588 3
  shift0 = mode & 0xff;
  shift1 = (mode >> 8) & 0xff;
  shift2 = (mode >> 16) & 0xff;
d11590 1
a11590 1
  skip_whitespace (str);
d11592 8
a11599 12
  if (mav_reg_required_here (&str, shift0, reg0) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, shift1, reg1) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, shift2, reg2) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
    }
  else
    end_of_line (str);
}
d11601 1
a11601 1
/* Wrapper functions.  */
d11603 7
a11609 5
static void
do_mav_binops_1a (char * str)
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_RN, REG_TYPE_MVF);
}
d11611 19
a11629 5
static void
do_mav_binops_1b (char * str)
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_RN, REG_TYPE_MVD);
}
d11631 8
a11638 5
static void
do_mav_binops_1c (char * str)
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_RN, REG_TYPE_MVDX);
}
d11640 1
a11640 5
static void
do_mav_binops_1d (char * str)
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVF, REG_TYPE_MVF);
}
d11642 1
a11642 5
static void
do_mav_binops_1e (char * str)
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVD, REG_TYPE_MVD);
}
d11644 10
a11653 5
static void
do_mav_binops_1f (char * str)
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVD, REG_TYPE_MVF);
}
d11655 1
a11655 2
static void
do_mav_binops_1g (char * str)
d11657 8
a11664 2
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVF, REG_TYPE_MVD);
}
d11666 1
a11666 5
static void
do_mav_binops_1h (char * str)
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVF, REG_TYPE_MVFX);
}
d11668 1
a11668 2
static void
do_mav_binops_1i (char * str)
d11670 6
a11675 2
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVD, REG_TYPE_MVFX);
}
d11677 1
a11677 2
static void
do_mav_binops_1j (char * str)
d11679 13
a11691 2
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVF, REG_TYPE_MVDX);
}
d11693 3
a11695 5
static void
do_mav_binops_1k (char * str)
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVD, REG_TYPE_MVDX);
}
d11697 80
a11776 5
static void
do_mav_binops_1l (char * str)
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVFX, REG_TYPE_MVF);
}
d11778 19
a11796 5
static void
do_mav_binops_1m (char * str)
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVFX, REG_TYPE_MVD);
}
d11798 6
a11803 5
static void
do_mav_binops_1n (char * str)
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVFX, REG_TYPE_MVFX);
}
d11805 2
a11806 5
static void
do_mav_binops_1o (char * str)
{
  do_mav_binops (str, MAV_MODE1, REG_TYPE_MVDX, REG_TYPE_MVDX);
}
d11808 1
a11808 2
static void
do_mav_binops_2a (char * str)
d11810 6
a11815 2
  do_mav_binops (str, MAV_MODE2, REG_TYPE_MVF, REG_TYPE_RN);
}
d11817 3
a11819 2
static void
do_mav_binops_2b (char * str)
d11821 28
a11848 4014
  do_mav_binops (str, MAV_MODE2, REG_TYPE_MVD, REG_TYPE_RN);
}

static void
do_mav_binops_2c (char * str)
{
  do_mav_binops (str, MAV_MODE2, REG_TYPE_MVDX, REG_TYPE_RN);
}

static void
do_mav_binops_3a (char * str)
{
  do_mav_binops (str, MAV_MODE3, REG_TYPE_MVAX, REG_TYPE_MVFX);
}

static void
do_mav_binops_3b (char * str)
{
  do_mav_binops (str, MAV_MODE3, REG_TYPE_MVFX, REG_TYPE_MVAX);
}

static void
do_mav_binops_3c (char * str)
{
  do_mav_binops (str, MAV_MODE3, REG_TYPE_MVAX, REG_TYPE_MVDX);
}

static void
do_mav_binops_3d (char * str)
{
  do_mav_binops (str, MAV_MODE3, REG_TYPE_MVDX, REG_TYPE_MVAX);
}

static void
do_mav_triple_4a (char * str)
{
  do_mav_triple (str, MAV_MODE4, REG_TYPE_MVFX, REG_TYPE_MVFX, REG_TYPE_RN);
}

static void
do_mav_triple_4b (char * str)
{
  do_mav_triple (str, MAV_MODE4, REG_TYPE_MVDX, REG_TYPE_MVDX, REG_TYPE_RN);
}

static void
do_mav_triple_5a (char * str)
{
  do_mav_triple (str, MAV_MODE5, REG_TYPE_RN, REG_TYPE_MVF, REG_TYPE_MVF);
}

static void
do_mav_triple_5b (char * str)
{
  do_mav_triple (str, MAV_MODE5, REG_TYPE_RN, REG_TYPE_MVD, REG_TYPE_MVD);
}

static void
do_mav_triple_5c (char * str)
{
  do_mav_triple (str, MAV_MODE5, REG_TYPE_RN, REG_TYPE_MVFX, REG_TYPE_MVFX);
}

static void
do_mav_triple_5d (char * str)
{
  do_mav_triple (str, MAV_MODE5, REG_TYPE_RN, REG_TYPE_MVDX, REG_TYPE_MVDX);
}

static void
do_mav_triple_5e (char * str)
{
  do_mav_triple (str, MAV_MODE5, REG_TYPE_MVF, REG_TYPE_MVF, REG_TYPE_MVF);
}

static void
do_mav_triple_5f (char * str)
{
  do_mav_triple (str, MAV_MODE5, REG_TYPE_MVD, REG_TYPE_MVD, REG_TYPE_MVD);
}

static void
do_mav_triple_5g (char * str)
{
  do_mav_triple (str, MAV_MODE5, REG_TYPE_MVFX, REG_TYPE_MVFX, REG_TYPE_MVFX);
}

static void
do_mav_triple_5h (char * str)
{
  do_mav_triple (str, MAV_MODE5, REG_TYPE_MVDX, REG_TYPE_MVDX, REG_TYPE_MVDX);
}

/* Isnsn like "foo W,X,Y,Z".
    where W=MVAX[0:3] and X,Y,Z=MVFX[0:15].  */

static void
do_mav_quad (char * str,
	     int mode,
	     enum arm_reg_type reg0,
	     enum arm_reg_type reg1,
	     enum arm_reg_type reg2,
	     enum arm_reg_type reg3)
{
  int shift0, shift1, shift2, shift3;

  shift0= mode & 0xff;
  shift1 = (mode >> 8) & 0xff;
  shift2 = (mode >> 16) & 0xff;
  shift3 = (mode >> 24) & 0xff;

  skip_whitespace (str);

  if (mav_reg_required_here (&str, shift0, reg0) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, shift1, reg1) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, shift2, reg2) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, shift3, reg3) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
    }
  else
    end_of_line (str);
}

static void
do_mav_quad_6a (char * str)
{
  do_mav_quad (str, MAV_MODE6, REG_TYPE_MVAX, REG_TYPE_MVFX, REG_TYPE_MVFX,
	       REG_TYPE_MVFX);
}

static void
do_mav_quad_6b (char * str)
{
  do_mav_quad (str, MAV_MODE6, REG_TYPE_MVAX, REG_TYPE_MVAX, REG_TYPE_MVFX,
	       REG_TYPE_MVFX);
}

/* cfmvsc32<cond> DSPSC,MVDX[15:0].  */
static void
do_mav_dspsc_1 (char * str)
{
  skip_whitespace (str);

  /* cfmvsc32.  */
  if (mav_reg_required_here (&str, -1, REG_TYPE_DSPSC) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, 12, REG_TYPE_MVDX) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;

      return;
    }

  end_of_line (str);
}

/* cfmv32sc<cond> MVDX[15:0],DSPSC.  */
static void
do_mav_dspsc_2 (char * str)
{
  skip_whitespace (str);

  /* cfmv32sc.  */
  if (mav_reg_required_here (&str, 12, REG_TYPE_MVDX) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, -1, REG_TYPE_DSPSC) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;

      return;
    }

  end_of_line (str);
}

/* Maverick shift immediate instructions.
   cfsh32<cond> MVFX[15:0],MVFX[15:0],Shift[6:0].
   cfsh64<cond> MVDX[15:0],MVDX[15:0],Shift[6:0].  */

static void
do_mav_shift (char * str,
	      enum arm_reg_type reg0,
	      enum arm_reg_type reg1)
{
  int error;
  int imm, neg = 0;

  skip_whitespace (str);

  error = 0;

  if (mav_reg_required_here (&str, 12, reg0) == FAIL
      || skip_past_comma (&str) == FAIL
      || mav_reg_required_here (&str, 16, reg1) == FAIL
      || skip_past_comma  (&str) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  /* Calculate the immediate operand.
     The operand is a 7bit signed number.  */
  skip_whitespace (str);

  if (*str == '#')
    ++str;

  if (!ISDIGIT (*str) && *str != '-')
    {
      inst.error = _("expecting immediate, 7bit operand");
      return;
    }

  if (*str == '-')
    {
      neg = 1;
      ++str;
    }

  for (imm = 0; *str && ISDIGIT (*str); ++str)
    imm = imm * 10 + *str - '0';

  if (imm > 64)
    {
      inst.error = _("immediate out of range");
      return;
    }

  /* Make negative imm's into 7bit signed numbers.  */
  if (neg)
    {
      imm = -imm;
      imm &= 0x0000007f;
    }

  /* Bits 0-3 of the insn should have bits 0-3 of the immediate.
     Bits 5-7 of the insn should have bits 4-6 of the immediate.
     Bit 4 should be 0.  */
  imm = (imm & 0xf) | ((imm & 0x70) << 1);

  inst.instruction |= imm;
  end_of_line (str);
}

static void
do_mav_shift_1 (char * str)
{
  do_mav_shift (str, REG_TYPE_MVFX, REG_TYPE_MVFX);
}

static void
do_mav_shift_2 (char * str)
{
  do_mav_shift (str, REG_TYPE_MVDX, REG_TYPE_MVDX);
}

static int
mav_parse_offset (char ** str, int * negative)
{
  char * p = *str;
  int offset;

  *negative = 0;

  skip_whitespace (p);

  if (*p == '#')
    ++p;

  if (*p == '-')
    {
      *negative = 1;
      ++p;
    }

  if (!ISDIGIT (*p))
    {
      inst.error = _("offset expected");
      return 0;
    }

  for (offset = 0; *p && ISDIGIT (*p); ++p)
    offset = offset * 10 + *p - '0';

  if (offset > 0x3fc)
    {
      inst.error = _("offset out of range");
      return 0;
    }
  if (offset & 0x3)
    {
      inst.error = _("offset not a multiple of 4");
      return 0;
    }

  *str = p;

  return *negative ? -offset : offset;
}

/* Maverick load/store instructions.
  <insn><cond> CRd,[Rn,<offset>]{!}.
  <insn><cond> CRd,[Rn],<offset>.  */

static void
do_mav_ldst (char * str, enum arm_reg_type reg0)
{
  int offset, negative;

  skip_whitespace (str);

  if (mav_reg_required_here (&str, 12, reg0) == FAIL
      || skip_past_comma (&str) == FAIL
      || *str++ != '['
      || reg_required_here (&str, 16) == FAIL)
    goto fail_ldst;

  if (skip_past_comma (&str) == SUCCESS)
    {
      /* You are here: "<offset>]{!}".  */
      inst.instruction |= PRE_INDEX;

      offset = mav_parse_offset (&str, &negative);

      if (inst.error)
	return;

      if (*str++ != ']')
	{
	  inst.error = _("missing ]");
	  return;
	}

      if (*str == '!')
	{
	  inst.instruction |= WRITE_BACK;
	  ++str;
	}
    }
  else
    {
      /* You are here: "], <offset>".  */
      if (*str++ != ']')
	{
	  inst.error = _("missing ]");
	  return;
	}

      if (skip_past_comma (&str) == FAIL
	  || (offset = mav_parse_offset (&str, &negative), inst.error))
	goto fail_ldst;

      inst.instruction |= CP_T_WB; /* Post indexed, set bit W.  */
    }

  if (negative)
    offset = -offset;
  else
    inst.instruction |= CP_T_UD; /* Positive, so set bit U.  */

  inst.instruction |= offset >> 2;
  end_of_line (str);
  return;

fail_ldst:
  if (!inst.error)
     inst.error = BAD_ARGS;
}

static void
do_mav_ldst_1 (char * str)
{
  do_mav_ldst (str, REG_TYPE_MVF);
}

static void
do_mav_ldst_2 (char * str)
{
  do_mav_ldst (str, REG_TYPE_MVD);
}

static void
do_mav_ldst_3 (char * str)
{
  do_mav_ldst (str, REG_TYPE_MVFX);
}

static void
do_mav_ldst_4 (char * str)
{
  do_mav_ldst (str, REG_TYPE_MVDX);
}

static void
do_t_nop (char * str)
{
  /* Do nothing.  */
  end_of_line (str);
}

/* Handle the Format 4 instructions that do not have equivalents in other
   formats.  That is, ADC, AND, EOR, SBC, ROR, TST, NEG, CMN, ORR, MUL,
   BIC and MVN.  */

static void
do_t_arit (char * str)
{
  int Rd, Rs, Rn;

  skip_whitespace (str);

  if ((Rd = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (Rs = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (&str) != FAIL)
    {
      /* Three operand format not allowed for TST, CMN, NEG and MVN.
	 (It isn't allowed for CMP either, but that isn't handled by this
	 function.)  */
      if (inst.instruction == T_OPCODE_TST
	  || inst.instruction == T_OPCODE_CMN
	  || inst.instruction == T_OPCODE_NEG
	  || inst.instruction == T_OPCODE_MVN)
	{
	  inst.error = BAD_ARGS;
	  return;
	}

      if ((Rn = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
	return;

      if (Rs != Rd)
	{
	  inst.error = _("dest and source1 must be the same register");
	  return;
	}
      Rs = Rn;
    }

  if (inst.instruction == T_OPCODE_MUL
      && Rs == Rd)
    as_tsktsk (_("Rs and Rd must be different in MUL"));

  inst.instruction |= Rd | (Rs << 3);
  end_of_line (str);
}

static void
do_t_add (char * str)
{
  thumb_add_sub (str, 0);
}

static void
do_t_asr (char * str)
{
  thumb_shift (str, THUMB_ASR);
}

static void
do_t_branch9 (char * str)
{
  if (my_get_expression (&inst.reloc.exp, &str))
    return;
  inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH9;
  inst.reloc.pc_rel = 1;
  end_of_line (str);
}

static void
do_t_branch12 (char * str)
{
  if (my_get_expression (&inst.reloc.exp, &str))
    return;
  inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH12;
  inst.reloc.pc_rel = 1;
  end_of_line (str);
}

/* Find the real, Thumb encoded start of a Thumb function.  */

static symbolS *
find_real_start (symbolS * symbolP)
{
  char *       real_start;
  const char * name = S_GET_NAME (symbolP);
  symbolS *    new_target;

  /* This definition must agree with the one in gcc/config/arm/thumb.c.  */
#define STUB_NAME ".real_start_of"

  if (name == NULL)
    abort ();

  /* Names that start with '.' are local labels, not function entry points.
     The compiler may generate BL instructions to these labels because it
     needs to perform a branch to a far away location.  */
  if (name[0] == '.')
    return symbolP;

  real_start = malloc (strlen (name) + strlen (STUB_NAME) + 1);
  sprintf (real_start, "%s%s", STUB_NAME, name);

  new_target = symbol_find (real_start);

  if (new_target == NULL)
    {
      as_warn ("Failed to find real start of function: %s\n", name);
      new_target = symbolP;
    }

  free (real_start);

  return new_target;
}

static void
do_t_branch23 (char * str)
{
  if (my_get_expression (& inst.reloc.exp, & str))
    return;

  inst.reloc.type   = BFD_RELOC_THUMB_PCREL_BRANCH23;
  inst.reloc.pc_rel = 1;
  end_of_line (str);

  /* If the destination of the branch is a defined symbol which does not have
     the THUMB_FUNC attribute, then we must be calling a function which has
     the (interfacearm) attribute.  We look for the Thumb entry point to that
     function and change the branch to refer to that function instead.  */
  if (   inst.reloc.exp.X_op == O_symbol
      && inst.reloc.exp.X_add_symbol != NULL
      && S_IS_DEFINED (inst.reloc.exp.X_add_symbol)
      && ! THUMB_IS_FUNC (inst.reloc.exp.X_add_symbol))
    inst.reloc.exp.X_add_symbol =
      find_real_start (inst.reloc.exp.X_add_symbol);
}

static void
do_t_bx (char * str)
{
  int reg;

  skip_whitespace (str);

  if ((reg = thumb_reg (&str, THUMB_REG_ANY)) == FAIL)
    return;

  /* This sets THUMB_H2 from the top bit of reg.  */
  inst.instruction |= reg << 3;

  /* ??? FIXME: Should add a hacky reloc here if reg is REG_PC.  The reloc
     should cause the alignment to be checked once it is known.  This is
     because BX PC only works if the instruction is word aligned.  */

  end_of_line (str);
}

static void
do_t_compare (char * str)
{
  thumb_mov_compare (str, THUMB_COMPARE);
}

static void
do_t_ldmstm (char * str)
{
  int Rb;
  long range;

  skip_whitespace (str);

  if ((Rb = thumb_reg (&str, THUMB_REG_LO)) == FAIL)
    return;

  if (*str != '!')
    as_warn (_("inserted missing '!': load/store multiple always writes back base register"));
  else
    str++;

  if (skip_past_comma (&str) == FAIL
      || (range = reg_list (&str)) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (inst.reloc.type != BFD_RELOC_NONE)
    {
      /* This really doesn't seem worth it.  */
      inst.reloc.type = BFD_RELOC_NONE;
      inst.error = _("expression too complex");
      return;
    }

  if (range & ~0xff)
    {
      inst.error = _("only lo-regs valid in load/store multiple");
      return;
    }

  inst.instruction |= (Rb << 8) | range;
  end_of_line (str);
}

static void
do_t_ldr (char * str)
{
  thumb_load_store (str, THUMB_LOAD, THUMB_WORD);
}

static void
do_t_ldrb (char * str)
{
  thumb_load_store (str, THUMB_LOAD, THUMB_BYTE);
}

static void
do_t_ldrh (char * str)
{
  thumb_load_store (str, THUMB_LOAD, THUMB_HALFWORD);
}

static void
do_t_lds (char * str)
{
  int Rd, Rb, Ro;

  skip_whitespace (str);

  if ((Rd = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || skip_past_comma (&str) == FAIL
      || *str++ != '['
      || (Rb = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || skip_past_comma (&str) == FAIL
      || (Ro = thumb_reg (&str, THUMB_REG_LO)) == FAIL
      || *str++ != ']')
    {
      if (! inst.error)
	inst.error = _("syntax: ldrs[b] Rd, [Rb, Ro]");
      return;
    }

  inst.instruction |= Rd | (Rb << 3) | (Ro << 6);
  end_of_line (str);
}

static void
do_t_lsl (char * str)
{
  thumb_shift (str, THUMB_LSL);
}

static void
do_t_lsr (char * str)
{
  thumb_shift (str, THUMB_LSR);
}

static void
do_t_mov (char * str)
{
  thumb_mov_compare (str, THUMB_MOVE);
}

static void
do_t_push_pop (char * str)
{
  long range;

  skip_whitespace (str);

  if ((range = reg_list (&str)) == FAIL)
    {
      if (! inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (inst.reloc.type != BFD_RELOC_NONE)
    {
      /* This really doesn't seem worth it.  */
      inst.reloc.type = BFD_RELOC_NONE;
      inst.error = _("expression too complex");
      return;
    }

  if (range & ~0xff)
    {
      if ((inst.instruction == T_OPCODE_PUSH
	   && (range & ~0xff) == 1 << REG_LR)
	  || (inst.instruction == T_OPCODE_POP
	      && (range & ~0xff) == 1 << REG_PC))
	{
	  inst.instruction |= THUMB_PP_PC_LR;
	  range &= 0xff;
	}
      else
	{
	  inst.error = _("invalid register list to push/pop instruction");
	  return;
	}
    }

  inst.instruction |= range;
  end_of_line (str);
}

static void
do_t_str (char * str)
{
  thumb_load_store (str, THUMB_STORE, THUMB_WORD);
}

static void
do_t_strb (char * str)
{
  thumb_load_store (str, THUMB_STORE, THUMB_BYTE);
}

static void
do_t_strh (char * str)
{
  thumb_load_store (str, THUMB_STORE, THUMB_HALFWORD);
}

static void
do_t_sub (char * str)
{
  thumb_add_sub (str, 1);
}

static void
do_t_swi (char * str)
{
  skip_whitespace (str);

  if (my_get_expression (&inst.reloc.exp, &str))
    return;

  inst.reloc.type = BFD_RELOC_ARM_SWI;
  end_of_line (str);
}

static void
do_t_adr (char * str)
{
  int reg;

  /* This is a pseudo-op of the form "adr rd, label" to be converted
     into a relative address of the form "add rd, pc, #label-.-4".  */
  skip_whitespace (str);

  /* Store Rd in temporary location inside instruction.  */
  if ((reg = reg_required_here (&str, 4)) == FAIL
      || (reg > 7)  /* For Thumb reg must be r0..r7.  */
      || skip_past_comma (&str) == FAIL
      || my_get_expression (&inst.reloc.exp, &str))
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  inst.reloc.type = BFD_RELOC_ARM_THUMB_ADD;
  inst.reloc.exp.X_add_number -= 4; /* PC relative adjust.  */
  inst.reloc.pc_rel = 1;
  inst.instruction |= REG_PC; /* Rd is already placed into the instruction.  */

  end_of_line (str);
}

static void
insert_reg (const struct reg_entry * r,
	    struct hash_control * htab)
{
  int    len  = strlen (r->name) + 2;
  char * buf  = xmalloc (len);
  char * buf2 = xmalloc (len);
  int    i    = 0;

#ifdef REGISTER_PREFIX
  buf[i++] = REGISTER_PREFIX;
#endif

  strcpy (buf + i, r->name);

  for (i = 0; buf[i]; i++)
    buf2[i] = TOUPPER (buf[i]);

  buf2[i] = '\0';

  hash_insert (htab, buf,  (PTR) r);
  hash_insert (htab, buf2, (PTR) r);
}

static void
build_reg_hsh (struct reg_map * map)
{
  const struct reg_entry *r;

  if ((map->htab = hash_new ()) == NULL)
    as_fatal (_("virtual memory exhausted"));

  for (r = map->names; r->name != NULL; r++)
    insert_reg (r, map->htab);
}

static void
insert_reg_alias (char * str,
		  int regnum,
		  struct hash_control *htab)
{
  const char * error;
  struct reg_entry * new = xmalloc (sizeof (struct reg_entry));
  const char * name = xmalloc (strlen (str) + 1);

  strcpy ((char *) name, str);

  new->name = name;
  new->number = regnum;
  new->builtin = FALSE;

  error = hash_insert (htab, name, (PTR) new);
  if (error)
    {
      as_bad (_("failed to create an alias for %s, reason: %s"),
	    str, error);
      free ((char *) name);
      free (new);
    }
}

/* Look for the .req directive.  This is of the form:

   	new_register_name .req existing_register_name

   If we find one, or if it looks sufficiently like one that we want to
   handle any error here, return non-zero.  Otherwise return zero.  */

static int
create_register_alias (char * newname, char * p)
{
  char * q;
  char c;

  q = p;
  skip_whitespace (q);

  c = *p;
  *p = '\0';

  if (*q && !strncmp (q, ".req ", 5))
    {
      char *copy_of_str;
      char *r;

#ifndef IGNORE_OPCODE_CASE
      newname = original_case_string;
#endif
      copy_of_str = newname;

      q += 4;
      skip_whitespace (q);

      for (r = q; *r != '\0'; r++)
	if (*r == ' ')
	  break;

      if (r != q)
	{
	  enum arm_reg_type new_type, old_type;
	  int old_regno;
	  char d = *r;

	  *r = '\0';
	  old_type = arm_reg_parse_any (q);
	  *r = d;

	  new_type = arm_reg_parse_any (newname);

	  if (new_type == REG_TYPE_MAX)
	    {
	      if (old_type != REG_TYPE_MAX)
		{
		  old_regno = arm_reg_parse (&q, all_reg_maps[old_type].htab);
		  insert_reg_alias (newname, old_regno,
				    all_reg_maps[old_type].htab);
		}
	      else
		as_warn (_("register '%s' does not exist\n"), q);
	    }
	  else if (old_type == REG_TYPE_MAX)
	    {
	      as_warn (_("ignoring redefinition of register alias '%s' to non-existant register '%s'"),
		       copy_of_str, q);
	    }
	  else
	    {
	      /* Do not warn about redefinitions to the same alias.  */
	      if (new_type != old_type
		  || (arm_reg_parse (&q, all_reg_maps[old_type].htab)
		      != arm_reg_parse (&q, all_reg_maps[new_type].htab)))
		as_warn (_("ignoring redefinition of register alias '%s'"),
			 copy_of_str);

	    }
	}
      else
	as_warn (_("ignoring incomplete .req pseuso op"));

      *p = c;
      return 1;
    }

  *p = c;
  return 0;
}

static void
set_constant_flonums (void)
{
  int i;

  for (i = 0; i < NUM_FLOAT_VALS; i++)
    if (atof_ieee ((char *) fp_const[i], 'x', fp_values[i]) == NULL)
      abort ();
}


static const struct asm_opcode insns[] =
{
  /* Core ARM Instructions.  */
  {"and",        0xe0000000, 3,  ARM_EXT_V1,       do_arit},
  {"ands",       0xe0100000, 3,  ARM_EXT_V1,       do_arit},
  {"eor",        0xe0200000, 3,  ARM_EXT_V1,       do_arit},
  {"eors",       0xe0300000, 3,  ARM_EXT_V1,       do_arit},
  {"sub",        0xe0400000, 3,  ARM_EXT_V1,       do_arit},
  {"subs",       0xe0500000, 3,  ARM_EXT_V1,       do_arit},
  {"rsb",        0xe0600000, 3,  ARM_EXT_V1,       do_arit},
  {"rsbs",       0xe0700000, 3,  ARM_EXT_V1,       do_arit},
  {"add",        0xe0800000, 3,  ARM_EXT_V1,       do_arit},
  {"adds",       0xe0900000, 3,  ARM_EXT_V1,       do_arit},
  {"adc",        0xe0a00000, 3,  ARM_EXT_V1,       do_arit},
  {"adcs",       0xe0b00000, 3,  ARM_EXT_V1,       do_arit},
  {"sbc",        0xe0c00000, 3,  ARM_EXT_V1,       do_arit},
  {"sbcs",       0xe0d00000, 3,  ARM_EXT_V1,       do_arit},
  {"rsc",        0xe0e00000, 3,  ARM_EXT_V1,       do_arit},
  {"rscs",       0xe0f00000, 3,  ARM_EXT_V1,       do_arit},
  {"orr",        0xe1800000, 3,  ARM_EXT_V1,       do_arit},
  {"orrs",       0xe1900000, 3,  ARM_EXT_V1,       do_arit},
  {"bic",        0xe1c00000, 3,  ARM_EXT_V1,       do_arit},
  {"bics",       0xe1d00000, 3,  ARM_EXT_V1,       do_arit},

  {"tst",        0xe1100000, 3,  ARM_EXT_V1,       do_cmp},
  {"tsts",       0xe1100000, 3,  ARM_EXT_V1,       do_cmp},
  {"tstp",       0xe110f000, 3,  ARM_EXT_V1,       do_cmp},
  {"teq",        0xe1300000, 3,  ARM_EXT_V1,       do_cmp},
  {"teqs",       0xe1300000, 3,  ARM_EXT_V1,       do_cmp},
  {"teqp",       0xe130f000, 3,  ARM_EXT_V1,       do_cmp},
  {"cmp",        0xe1500000, 3,  ARM_EXT_V1,       do_cmp},
  {"cmps",       0xe1500000, 3,  ARM_EXT_V1,       do_cmp},
  {"cmpp",       0xe150f000, 3,  ARM_EXT_V1,       do_cmp},
  {"cmn",        0xe1700000, 3,  ARM_EXT_V1,       do_cmp},
  {"cmns",       0xe1700000, 3,  ARM_EXT_V1,       do_cmp},
  {"cmnp",       0xe170f000, 3,  ARM_EXT_V1,       do_cmp},

  {"mov",        0xe1a00000, 3,  ARM_EXT_V1,       do_mov},
  {"movs",       0xe1b00000, 3,  ARM_EXT_V1,       do_mov},
  {"mvn",        0xe1e00000, 3,  ARM_EXT_V1,       do_mov},
  {"mvns",       0xe1f00000, 3,  ARM_EXT_V1,       do_mov},

  {"ldr",        0xe4100000, 3,  ARM_EXT_V1,       do_ldst},
  {"ldrb",       0xe4500000, 3,  ARM_EXT_V1,       do_ldst},
  {"ldrt",       0xe4300000, 3,  ARM_EXT_V1,       do_ldstt},
  {"ldrbt",      0xe4700000, 3,  ARM_EXT_V1,       do_ldstt},
  {"str",        0xe4000000, 3,  ARM_EXT_V1,       do_ldst},
  {"strb",       0xe4400000, 3,  ARM_EXT_V1,       do_ldst},
  {"strt",       0xe4200000, 3,  ARM_EXT_V1,       do_ldstt},
  {"strbt",      0xe4600000, 3,  ARM_EXT_V1,       do_ldstt},

  {"stmia",      0xe8800000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmib",      0xe9800000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmda",      0xe8000000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmdb",      0xe9000000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmfd",      0xe9000000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmfa",      0xe9800000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmea",      0xe8800000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"stmed",      0xe8000000, 3,  ARM_EXT_V1,       do_ldmstm},

  {"ldmia",      0xe8900000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmib",      0xe9900000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmda",      0xe8100000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmdb",      0xe9100000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmfd",      0xe8900000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmfa",      0xe8100000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmea",      0xe9100000, 3,  ARM_EXT_V1,       do_ldmstm},
  {"ldmed",      0xe9900000, 3,  ARM_EXT_V1,       do_ldmstm},

  {"swi",        0xef000000, 3,  ARM_EXT_V1,       do_swi},
#ifdef TE_WINCE
  /* XXX This is the wrong place to do this.  Think multi-arch.  */
  {"bl",         0xeb000000, 2,  ARM_EXT_V1,       do_branch},
  {"b",          0xea000000, 1,  ARM_EXT_V1,       do_branch},
#else
  {"bl",         0xebfffffe, 2,  ARM_EXT_V1,       do_branch},
  {"b",          0xeafffffe, 1,  ARM_EXT_V1,       do_branch},
#endif

  /* Pseudo ops.  */
  {"adr",        0xe28f0000, 3,  ARM_EXT_V1,       do_adr},
  {"adrl",       0xe28f0000, 3,  ARM_EXT_V1,       do_adrl},
  {"nop",        0xe1a00000, 3,  ARM_EXT_V1,       do_nop},

  /* ARM 2 multiplies.  */
  {"mul",        0xe0000090, 3,  ARM_EXT_V2,       do_mul},
  {"muls",       0xe0100090, 3,  ARM_EXT_V2,       do_mul},
  {"mla",        0xe0200090, 3,  ARM_EXT_V2,       do_mla},
  {"mlas",       0xe0300090, 3,  ARM_EXT_V2,       do_mla},

  /* Generic coprocessor instructions.  */
  {"cdp",        0xee000000, 3,  ARM_EXT_V2,       do_cdp},
  {"ldc",        0xec100000, 3,  ARM_EXT_V2,       do_lstc},
  {"ldcl",       0xec500000, 3,  ARM_EXT_V2,       do_lstc},
  {"stc",        0xec000000, 3,  ARM_EXT_V2,       do_lstc},
  {"stcl",       0xec400000, 3,  ARM_EXT_V2,       do_lstc},
  {"mcr",        0xee000010, 3,  ARM_EXT_V2,       do_co_reg},
  {"mrc",        0xee100010, 3,  ARM_EXT_V2,       do_co_reg},

  /* ARM 3 - swp instructions.  */
  {"swp",        0xe1000090, 3,  ARM_EXT_V2S,      do_swap},
  {"swpb",       0xe1400090, 3,  ARM_EXT_V2S,      do_swap},

  /* ARM 6 Status register instructions.  */
  {"mrs",        0xe10f0000, 3,  ARM_EXT_V3,       do_mrs},
  {"msr",        0xe120f000, 3,  ARM_EXT_V3,       do_msr},
  /* ScottB: our code uses     0xe128f000 for msr.
     NickC:  but this is wrong because the bits 16 through 19 are
             handled by the PSR_xxx defines above.  */

  /* ARM 7M long multiplies.  */
  {"smull",      0xe0c00090, 5,  ARM_EXT_V3M,      do_mull},
  {"smulls",     0xe0d00090, 5,  ARM_EXT_V3M,      do_mull},
  {"umull",      0xe0800090, 5,  ARM_EXT_V3M,      do_mull},
  {"umulls",     0xe0900090, 5,  ARM_EXT_V3M,      do_mull},
  {"smlal",      0xe0e00090, 5,  ARM_EXT_V3M,      do_mull},
  {"smlals",     0xe0f00090, 5,  ARM_EXT_V3M,      do_mull},
  {"umlal",      0xe0a00090, 5,  ARM_EXT_V3M,      do_mull},
  {"umlals",     0xe0b00090, 5,  ARM_EXT_V3M,      do_mull},

  /* ARM Architecture 4.  */
  {"ldrh",       0xe01000b0, 3,  ARM_EXT_V4,       do_ldstv4},
  {"ldrsh",      0xe01000f0, 3,  ARM_EXT_V4,       do_ldstv4},
  {"ldrsb",      0xe01000d0, 3,  ARM_EXT_V4,       do_ldstv4},
  {"strh",       0xe00000b0, 3,  ARM_EXT_V4,       do_ldstv4},

  /* ARM Architecture 4T.  */
  /* Note: bx (and blx) are required on V5, even if the processor does
     not support Thumb.  */
  {"bx",         0xe12fff10, 2,  ARM_EXT_V4T | ARM_EXT_V5, do_bx},

  /*  ARM Architecture 5T.  */
  /* Note: blx has 2 variants, so the .value is set dynamically.
     Only one of the variants has conditional execution.  */
  {"blx",        0xe0000000, 3,  ARM_EXT_V5,       do_blx},
  {"clz",        0xe16f0f10, 3,  ARM_EXT_V5,       do_clz},
  {"bkpt",       0xe1200070, 0,  ARM_EXT_V5,       do_bkpt},
  {"ldc2",       0xfc100000, 0,  ARM_EXT_V5,       do_lstc2},
  {"ldc2l",      0xfc500000, 0,  ARM_EXT_V5,       do_lstc2},
  {"stc2",       0xfc000000, 0,  ARM_EXT_V5,       do_lstc2},
  {"stc2l",      0xfc400000, 0,  ARM_EXT_V5,       do_lstc2},
  {"cdp2",       0xfe000000, 0,  ARM_EXT_V5,       do_cdp2},
  {"mcr2",       0xfe000010, 0,  ARM_EXT_V5,       do_co_reg2},
  {"mrc2",       0xfe100010, 0,  ARM_EXT_V5,       do_co_reg2},

  /*  ARM Architecture 5TExP.  */
  {"smlabb",     0xe1000080, 6,  ARM_EXT_V5ExP,    do_smla},
  {"smlatb",     0xe10000a0, 6,  ARM_EXT_V5ExP,    do_smla},
  {"smlabt",     0xe10000c0, 6,  ARM_EXT_V5ExP,    do_smla},
  {"smlatt",     0xe10000e0, 6,  ARM_EXT_V5ExP,    do_smla},

  {"smlawb",     0xe1200080, 6,  ARM_EXT_V5ExP,    do_smla},
  {"smlawt",     0xe12000c0, 6,  ARM_EXT_V5ExP,    do_smla},

  {"smlalbb",    0xe1400080, 7,  ARM_EXT_V5ExP,    do_smlal},
  {"smlaltb",    0xe14000a0, 7,  ARM_EXT_V5ExP,    do_smlal},
  {"smlalbt",    0xe14000c0, 7,  ARM_EXT_V5ExP,    do_smlal},
  {"smlaltt",    0xe14000e0, 7,  ARM_EXT_V5ExP,    do_smlal},

  {"smulbb",     0xe1600080, 6,  ARM_EXT_V5ExP,    do_smul},
  {"smultb",     0xe16000a0, 6,  ARM_EXT_V5ExP,    do_smul},
  {"smulbt",     0xe16000c0, 6,  ARM_EXT_V5ExP,    do_smul},
  {"smultt",     0xe16000e0, 6,  ARM_EXT_V5ExP,    do_smul},

  {"smulwb",     0xe12000a0, 6,  ARM_EXT_V5ExP,    do_smul},
  {"smulwt",     0xe12000e0, 6,  ARM_EXT_V5ExP,    do_smul},

  {"qadd",       0xe1000050, 4,  ARM_EXT_V5ExP,    do_qadd},
  {"qdadd",      0xe1400050, 5,  ARM_EXT_V5ExP,    do_qadd},
  {"qsub",       0xe1200050, 4,  ARM_EXT_V5ExP,    do_qadd},
  {"qdsub",      0xe1600050, 5,  ARM_EXT_V5ExP,    do_qadd},

  /*  ARM Architecture 5TE.  */
  {"pld",        0xf450f000, 0,  ARM_EXT_V5E,      do_pld},
  {"ldrd",       0xe00000d0, 3,  ARM_EXT_V5E,      do_ldrd},
  {"strd",       0xe00000f0, 3,  ARM_EXT_V5E,      do_ldrd},

  {"mcrr",       0xec400000, 4,  ARM_EXT_V5E,      do_co_reg2c},
  {"mrrc",       0xec500000, 4,  ARM_EXT_V5E,      do_co_reg2c},

  /*  ARM Architecture 5TEJ.  */
  {"bxj",	 0xe12fff20, 3,  ARM_EXT_V5J,	   do_bxj},

  /*  ARM V6.  */
  { "cps",       0xf1020000, 0,  ARM_EXT_V6,       do_cps},
  { "cpsie",     0xf1080000, 0,  ARM_EXT_V6,       do_cpsi},
  { "cpsid",     0xf10C0000, 0,  ARM_EXT_V6,       do_cpsi},
  { "ldrex",     0xe1900f9f, 5,  ARM_EXT_V6,       do_ldrex},
  { "mcrr2",     0xfc400000, 0,  ARM_EXT_V6,       do_co_reg2c},
  { "mrrc2",     0xfc500000, 0,  ARM_EXT_V6,       do_co_reg2c},
  { "pkhbt",     0xe6800010, 5,  ARM_EXT_V6,       do_pkhbt},
  { "pkhtb",     0xe6800050, 5,  ARM_EXT_V6,       do_pkhtb},
  { "qadd16",    0xe6200f10, 6,  ARM_EXT_V6,       do_qadd16},
  { "qadd8",     0xe6200f90, 5,  ARM_EXT_V6,       do_qadd16},
  { "qaddsubx",  0xe6200f30, 8,  ARM_EXT_V6,       do_qadd16},
  { "qsub16",    0xe6200f70, 6,  ARM_EXT_V6,       do_qadd16},
  { "qsub8",     0xe6200ff0, 5,  ARM_EXT_V6,       do_qadd16},
  { "qsubaddx",  0xe6200f50, 8,  ARM_EXT_V6,       do_qadd16},
  { "sadd16",    0xe6100f10, 6,  ARM_EXT_V6,       do_qadd16},
  { "sadd8",     0xe6100f90, 5,  ARM_EXT_V6,       do_qadd16},
  { "saddsubx",  0xe6100f30, 8,  ARM_EXT_V6,       do_qadd16},
  { "shadd16",   0xe6300f10, 7,  ARM_EXT_V6,       do_qadd16},
  { "shadd8",    0xe6300f90, 6,  ARM_EXT_V6,       do_qadd16},
  { "shaddsubx", 0xe6300f30, 9,  ARM_EXT_V6,       do_qadd16},
  { "shsub16",   0xe6300f70, 7,  ARM_EXT_V6,       do_qadd16},
  { "shsub8",    0xe6300ff0, 6,  ARM_EXT_V6,       do_qadd16},
  { "shsubaddx", 0xe6300f50, 9,  ARM_EXT_V6,       do_qadd16},
  { "ssub16",    0xe6100f70, 6,  ARM_EXT_V6,       do_qadd16},
  { "ssub8",     0xe6100ff0, 5,  ARM_EXT_V6,       do_qadd16},
  { "ssubaddx",  0xe6100f50, 8,  ARM_EXT_V6,       do_qadd16},
  { "uadd16",    0xe6500f10, 6,  ARM_EXT_V6,       do_qadd16},
  { "uadd8",     0xe6500f90, 5,  ARM_EXT_V6,       do_qadd16},
  { "uaddsubx",  0xe6500f30, 8,  ARM_EXT_V6,       do_qadd16},
  { "uhadd16",   0xe6700f10, 7,  ARM_EXT_V6,       do_qadd16},
  { "uhadd8",    0xe6700f90, 6,  ARM_EXT_V6,       do_qadd16},
  { "uhaddsubx", 0xe6700f30, 9,  ARM_EXT_V6,       do_qadd16},
  { "uhsub16",   0xe6700f70, 7,  ARM_EXT_V6,       do_qadd16},
  { "uhsub8",    0xe6700ff0, 6,  ARM_EXT_V6,       do_qadd16},
  { "uhsubaddx", 0xe6700f50, 9,  ARM_EXT_V6,       do_qadd16},
  { "uqadd16",   0xe6600f10, 7,  ARM_EXT_V6,       do_qadd16},
  { "uqadd8",    0xe6600f90, 6,  ARM_EXT_V6,       do_qadd16},
  { "uqaddsubx", 0xe6600f30, 9,  ARM_EXT_V6,       do_qadd16},
  { "uqsub16",   0xe6600f70, 7,  ARM_EXT_V6,       do_qadd16},
  { "uqsub8",    0xe6600ff0, 6,  ARM_EXT_V6,       do_qadd16},
  { "uqsubaddx", 0xe6600f50, 9,  ARM_EXT_V6,       do_qadd16},
  { "usub16",    0xe6500f70, 6,  ARM_EXT_V6,       do_qadd16},
  { "usub8",     0xe6500ff0, 5,  ARM_EXT_V6,       do_qadd16},
  { "usubaddx",  0xe6500f50, 8,  ARM_EXT_V6,       do_qadd16},
  { "rev",       0xe6bf0f30, 3,  ARM_EXT_V6,       do_rev},
  { "rev16",     0xe6bf0fb0, 5,  ARM_EXT_V6,       do_rev},
  { "revsh",     0xe6ff0fb0, 5,  ARM_EXT_V6,       do_rev},
  { "rfeia",     0xf8900a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfeib",     0xf9900a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfeda",     0xf8100a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfedb",     0xf9100a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfefd",     0xf8900a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfefa",     0xf9900a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfeea",     0xf8100a00, 0,  ARM_EXT_V6,       do_rfe},
  { "rfeed",     0xf9100a00, 0,  ARM_EXT_V6,       do_rfe},
  { "sxtah",     0xe6b00070, 5,  ARM_EXT_V6,       do_sxtah},
  { "sxtab16",   0xe6800070, 7,  ARM_EXT_V6,       do_sxtah},
  { "sxtab",     0xe6a00070, 5,  ARM_EXT_V6,       do_sxtah},
  { "sxth",      0xe6bf0070, 4,  ARM_EXT_V6,       do_sxth},
  { "sxtb16",    0xe68f0070, 6,  ARM_EXT_V6,       do_sxth},
  { "sxtb",      0xe6af0070, 4,  ARM_EXT_V6,       do_sxth},
  { "uxtah",     0xe6f00070, 5,  ARM_EXT_V6,       do_sxtah},
  { "uxtab16",   0xe6c00070, 7,  ARM_EXT_V6,       do_sxtah},
  { "uxtab",     0xe6e00070, 5,  ARM_EXT_V6,       do_sxtah},
  { "uxth",      0xe6ff0070, 4,  ARM_EXT_V6,       do_sxth},
  { "uxtb16",    0xe6cf0070, 6,  ARM_EXT_V6,       do_sxth},
  { "uxtb",      0xe6ef0070, 4,  ARM_EXT_V6,       do_sxth},
  { "sel",       0xe68000b0, 3,  ARM_EXT_V6,       do_qadd16},
  { "setend",    0xf1010000, 0,  ARM_EXT_V6,       do_setend},
  { "smlad",     0xe7000010, 5,  ARM_EXT_V6,       do_smlad},
  { "smladx",    0xe7000030, 6,  ARM_EXT_V6,       do_smlad},
  { "smlald",    0xe7400010, 6,  ARM_EXT_V6,       do_smlald},
  { "smlaldx",   0xe7400030, 7,  ARM_EXT_V6,       do_smlald},
  { "smlsd",     0xe7000050, 5,  ARM_EXT_V6,       do_smlad},
  { "smlsdx",    0xe7000070, 6,  ARM_EXT_V6,       do_smlad},
  { "smlsld",    0xe7400050, 6,  ARM_EXT_V6,       do_smlald},
  { "smlsldx",   0xe7400070, 7,  ARM_EXT_V6,       do_smlald},
  { "smmla",     0xe7500010, 5,  ARM_EXT_V6,       do_smlad},
  { "smmlar",    0xe7500030, 6,  ARM_EXT_V6,       do_smlad},
  { "smmls",     0xe75000d0, 5,  ARM_EXT_V6,       do_smlad},
  { "smmlsr",    0xe75000f0, 6,  ARM_EXT_V6,       do_smlad},
  { "smmul",     0xe750f010, 5,  ARM_EXT_V6,       do_smmul},
  { "smmulr",    0xe750f030, 6,  ARM_EXT_V6,       do_smmul},
  { "smuad",     0xe700f010, 5,  ARM_EXT_V6,       do_smmul},
  { "smuadx",    0xe700f030, 6,  ARM_EXT_V6,       do_smmul},
  { "smusd",     0xe700f050, 5,  ARM_EXT_V6,       do_smmul},
  { "smusdx",    0xe700f070, 6,  ARM_EXT_V6,       do_smmul},
  { "srsia",     0xf8cd0500, 0,  ARM_EXT_V6,       do_srs},
  { "srsib",     0xf9cd0500, 0,  ARM_EXT_V6,       do_srs},
  { "srsda",     0xf84d0500, 0,  ARM_EXT_V6,       do_srs},
  { "srsdb",     0xf94d0500, 0,  ARM_EXT_V6,       do_srs},
  { "ssat",      0xe6a00010, 4,  ARM_EXT_V6,       do_ssat},
  { "ssat16",    0xe6a00f30, 6,  ARM_EXT_V6,       do_ssat16},
  { "strex",     0xe1800f90, 5,  ARM_EXT_V6,       do_strex},
  { "umaal",     0xe0400090, 5,  ARM_EXT_V6,       do_umaal},
  { "usad8",     0xe780f010, 5,  ARM_EXT_V6,       do_smmul},
  { "usada8",    0xe7800010, 6,  ARM_EXT_V6,       do_smlad},
  { "usat",      0xe6e00010, 4,  ARM_EXT_V6,       do_usat},
  { "usat16",    0xe6e00f30, 6,  ARM_EXT_V6,       do_usat16},

  /*  ARM V6K.  */
  { "clrex",     0xf57ff01f, 0,  ARM_EXT_V6K,      do_empty},
  { "ldrexb",    0xe1d00f9f, 6,  ARM_EXT_V6K,      do_ldrex},
  { "ldrexd",    0xe1b00f9f, 6,  ARM_EXT_V6K,      do_ldrex},
  { "ldrexh",    0xe1f00f9f, 6,  ARM_EXT_V6K,      do_ldrex},
  { "sev",       0xe320f004, 3,  ARM_EXT_V6K,      do_empty},
  { "strexb",    0xe1c00f90, 6,  ARM_EXT_V6K,      do_strex},
  { "strexd",    0xe1a00f90, 6,  ARM_EXT_V6K,      do_strex},
  { "strexh",    0xe1e00f90, 6,  ARM_EXT_V6K,      do_strex},
  { "wfe",       0xe320f002, 3,  ARM_EXT_V6K,      do_empty},
  { "wfi",       0xe320f003, 3,  ARM_EXT_V6K,      do_empty},
  { "yield",     0xe320f001, 5,  ARM_EXT_V6K,      do_empty},

  /*  ARM V6Z.  */
  { "smi",       0xe1600070, 3,  ARM_EXT_V6Z,      do_smi},

  /* Core FPA instruction set (V1).  */
  {"wfs",        0xee200110, 3,  FPU_FPA_EXT_V1,   do_fpa_ctrl},
  {"rfs",        0xee300110, 3,  FPU_FPA_EXT_V1,   do_fpa_ctrl},
  {"wfc",        0xee400110, 3,  FPU_FPA_EXT_V1,   do_fpa_ctrl},
  {"rfc",        0xee500110, 3,  FPU_FPA_EXT_V1,   do_fpa_ctrl},

  {"ldfs",       0xec100100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},
  {"ldfd",       0xec108100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},
  {"ldfe",       0xec500100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},
  {"ldfp",       0xec508100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},

  {"stfs",       0xec000100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},
  {"stfd",       0xec008100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},
  {"stfe",       0xec400100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},
  {"stfp",       0xec408100, 3,  FPU_FPA_EXT_V1,   do_fpa_ldst},

  {"mvfs",       0xee008100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfsp",      0xee008120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfsm",      0xee008140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfsz",      0xee008160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfd",       0xee008180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfdp",      0xee0081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfdm",      0xee0081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfdz",      0xee0081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfe",       0xee088100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfep",      0xee088120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfem",      0xee088140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mvfez",      0xee088160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"mnfs",       0xee108100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfsp",      0xee108120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfsm",      0xee108140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfsz",      0xee108160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfd",       0xee108180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfdp",      0xee1081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfdm",      0xee1081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfdz",      0xee1081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfe",       0xee188100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfep",      0xee188120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfem",      0xee188140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"mnfez",      0xee188160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"abss",       0xee208100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"abssp",      0xee208120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"abssm",      0xee208140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"abssz",      0xee208160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absd",       0xee208180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absdp",      0xee2081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absdm",      0xee2081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absdz",      0xee2081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"abse",       0xee288100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absep",      0xee288120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absem",      0xee288140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"absez",      0xee288160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"rnds",       0xee308100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndsp",      0xee308120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndsm",      0xee308140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndsz",      0xee308160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndd",       0xee308180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rnddp",      0xee3081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rnddm",      0xee3081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rnddz",      0xee3081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rnde",       0xee388100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndep",      0xee388120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndem",      0xee388140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"rndez",      0xee388160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"sqts",       0xee408100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtsp",      0xee408120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtsm",      0xee408140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtsz",      0xee408160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtd",       0xee408180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtdp",      0xee4081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtdm",      0xee4081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtdz",      0xee4081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqte",       0xee488100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtep",      0xee488120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtem",      0xee488140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sqtez",      0xee488160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"logs",       0xee508100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logsp",      0xee508120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logsm",      0xee508140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logsz",      0xee508160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logd",       0xee508180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logdp",      0xee5081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logdm",      0xee5081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logdz",      0xee5081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"loge",       0xee588100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logep",      0xee588120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logem",      0xee588140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"logez",      0xee588160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"lgns",       0xee608100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnsp",      0xee608120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnsm",      0xee608140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnsz",      0xee608160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnd",       0xee608180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgndp",      0xee6081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgndm",      0xee6081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgndz",      0xee6081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgne",       0xee688100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnep",      0xee688120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnem",      0xee688140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"lgnez",      0xee688160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"exps",       0xee708100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expsp",      0xee708120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expsm",      0xee708140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expsz",      0xee708160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expd",       0xee708180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expdp",      0xee7081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expdm",      0xee7081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expdz",      0xee7081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expe",       0xee788100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expep",      0xee788120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expem",      0xee788140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"expdz",      0xee788160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"sins",       0xee808100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sinsp",      0xee808120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sinsm",      0xee808140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sinsz",      0xee808160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sind",       0xee808180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sindp",      0xee8081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sindm",      0xee8081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sindz",      0xee8081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sine",       0xee888100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sinep",      0xee888120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sinem",      0xee888140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"sinez",      0xee888160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"coss",       0xee908100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cossp",      0xee908120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cossm",      0xee908140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cossz",      0xee908160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosd",       0xee908180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosdp",      0xee9081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosdm",      0xee9081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosdz",      0xee9081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cose",       0xee988100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosep",      0xee988120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosem",      0xee988140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"cosez",      0xee988160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"tans",       0xeea08100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tansp",      0xeea08120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tansm",      0xeea08140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tansz",      0xeea08160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tand",       0xeea08180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tandp",      0xeea081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tandm",      0xeea081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tandz",      0xeea081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tane",       0xeea88100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tanep",      0xeea88120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tanem",      0xeea88140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"tanez",      0xeea88160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"asns",       0xeeb08100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnsp",      0xeeb08120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnsm",      0xeeb08140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnsz",      0xeeb08160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnd",       0xeeb08180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asndp",      0xeeb081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asndm",      0xeeb081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asndz",      0xeeb081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asne",       0xeeb88100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnep",      0xeeb88120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnem",      0xeeb88140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"asnez",      0xeeb88160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"acss",       0xeec08100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acssp",      0xeec08120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acssm",      0xeec08140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acssz",      0xeec08160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsd",       0xeec08180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsdp",      0xeec081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsdm",      0xeec081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsdz",      0xeec081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acse",       0xeec88100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsep",      0xeec88120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsem",      0xeec88140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"acsez",      0xeec88160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"atns",       0xeed08100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnsp",      0xeed08120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnsm",      0xeed08140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnsz",      0xeed08160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnd",       0xeed08180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atndp",      0xeed081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atndm",      0xeed081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atndz",      0xeed081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atne",       0xeed88100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnep",      0xeed88120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnem",      0xeed88140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"atnez",      0xeed88160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"urds",       0xeee08100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdsp",      0xeee08120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdsm",      0xeee08140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdsz",      0xeee08160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdd",       0xeee08180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urddp",      0xeee081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urddm",      0xeee081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urddz",      0xeee081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urde",       0xeee88100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdep",      0xeee88120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdem",      0xeee88140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"urdez",      0xeee88160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"nrms",       0xeef08100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmsp",      0xeef08120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmsm",      0xeef08140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmsz",      0xeef08160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmd",       0xeef08180, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmdp",      0xeef081a0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmdm",      0xeef081c0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmdz",      0xeef081e0, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrme",       0xeef88100, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmep",      0xeef88120, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmem",      0xeef88140, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},
  {"nrmez",      0xeef88160, 3,  FPU_FPA_EXT_V1,   do_fpa_monadic},

  {"adfs",       0xee000100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfsp",      0xee000120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfsm",      0xee000140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfsz",      0xee000160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfd",       0xee000180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfdp",      0xee0001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfdm",      0xee0001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfdz",      0xee0001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfe",       0xee080100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfep",      0xee080120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfem",      0xee080140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"adfez",      0xee080160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"sufs",       0xee200100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufsp",      0xee200120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufsm",      0xee200140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufsz",      0xee200160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufd",       0xee200180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufdp",      0xee2001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufdm",      0xee2001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufdz",      0xee2001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufe",       0xee280100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufep",      0xee280120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufem",      0xee280140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"sufez",      0xee280160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"rsfs",       0xee300100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfsp",      0xee300120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfsm",      0xee300140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfsz",      0xee300160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfd",       0xee300180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfdp",      0xee3001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfdm",      0xee3001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfdz",      0xee3001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfe",       0xee380100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfep",      0xee380120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfem",      0xee380140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rsfez",      0xee380160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"mufs",       0xee100100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufsp",      0xee100120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufsm",      0xee100140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufsz",      0xee100160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufd",       0xee100180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufdp",      0xee1001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufdm",      0xee1001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufdz",      0xee1001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufe",       0xee180100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufep",      0xee180120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufem",      0xee180140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"mufez",      0xee180160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"dvfs",       0xee400100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfsp",      0xee400120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfsm",      0xee400140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfsz",      0xee400160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfd",       0xee400180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfdp",      0xee4001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfdm",      0xee4001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfdz",      0xee4001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfe",       0xee480100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfep",      0xee480120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfem",      0xee480140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"dvfez",      0xee480160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"rdfs",       0xee500100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfsp",      0xee500120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfsm",      0xee500140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfsz",      0xee500160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfd",       0xee500180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfdp",      0xee5001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfdm",      0xee5001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfdz",      0xee5001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfe",       0xee580100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfep",      0xee580120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfem",      0xee580140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rdfez",      0xee580160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"pows",       0xee600100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powsp",      0xee600120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powsm",      0xee600140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powsz",      0xee600160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powd",       0xee600180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powdp",      0xee6001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powdm",      0xee6001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powdz",      0xee6001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powe",       0xee680100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powep",      0xee680120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powem",      0xee680140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"powez",      0xee680160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"rpws",       0xee700100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwsp",      0xee700120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwsm",      0xee700140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwsz",      0xee700160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwd",       0xee700180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwdp",      0xee7001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwdm",      0xee7001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwdz",      0xee7001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwe",       0xee780100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwep",      0xee780120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwem",      0xee780140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rpwez",      0xee780160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"rmfs",       0xee800100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfsp",      0xee800120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfsm",      0xee800140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfsz",      0xee800160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfd",       0xee800180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfdp",      0xee8001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfdm",      0xee8001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfdz",      0xee8001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfe",       0xee880100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfep",      0xee880120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfem",      0xee880140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"rmfez",      0xee880160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"fmls",       0xee900100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmlsp",      0xee900120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmlsm",      0xee900140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmlsz",      0xee900160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmld",       0xee900180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmldp",      0xee9001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmldm",      0xee9001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmldz",      0xee9001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmle",       0xee980100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmlep",      0xee980120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmlem",      0xee980140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fmlez",      0xee980160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"fdvs",       0xeea00100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvsp",      0xeea00120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvsm",      0xeea00140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvsz",      0xeea00160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvd",       0xeea00180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvdp",      0xeea001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvdm",      0xeea001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvdz",      0xeea001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdve",       0xeea80100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvep",      0xeea80120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvem",      0xeea80140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"fdvez",      0xeea80160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"frds",       0xeeb00100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdsp",      0xeeb00120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdsm",      0xeeb00140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdsz",      0xeeb00160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdd",       0xeeb00180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frddp",      0xeeb001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frddm",      0xeeb001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frddz",      0xeeb001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frde",       0xeeb80100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdep",      0xeeb80120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdem",      0xeeb80140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"frdez",      0xeeb80160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"pols",       0xeec00100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"polsp",      0xeec00120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"polsm",      0xeec00140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"polsz",      0xeec00160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"pold",       0xeec00180, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"poldp",      0xeec001a0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"poldm",      0xeec001c0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"poldz",      0xeec001e0, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"pole",       0xeec80100, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"polep",      0xeec80120, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"polem",      0xeec80140, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},
  {"polez",      0xeec80160, 3,  FPU_FPA_EXT_V1,   do_fpa_dyadic},

  {"cmf",        0xee90f110, 3,  FPU_FPA_EXT_V1,   do_fpa_cmp},
  {"cmfe",       0xeed0f110, 3,  FPU_FPA_EXT_V1,   do_fpa_cmp},
  {"cnf",        0xeeb0f110, 3,  FPU_FPA_EXT_V1,   do_fpa_cmp},
  {"cnfe",       0xeef0f110, 3,  FPU_FPA_EXT_V1,   do_fpa_cmp},
  /* The FPA10 data sheet suggests that the 'E' of cmfe/cnfe should
     not be an optional suffix, but part of the instruction.  To be
     compatible, we accept either.  */
  {"cmfe",       0xeed0f110, 4,  FPU_FPA_EXT_V1,   do_fpa_cmp},
  {"cnfe",       0xeef0f110, 4,  FPU_FPA_EXT_V1,   do_fpa_cmp},

  {"flts",       0xee000110, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltsp",      0xee000130, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltsm",      0xee000150, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltsz",      0xee000170, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltd",       0xee000190, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltdp",      0xee0001b0, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltdm",      0xee0001d0, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltdz",      0xee0001f0, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"flte",       0xee080110, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltep",      0xee080130, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltem",      0xee080150, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},
  {"fltez",      0xee080170, 3,  FPU_FPA_EXT_V1,   do_fpa_from_reg},

  /* The implementation of the FIX instruction is broken on some
     assemblers, in that it accepts a precision specifier as well as a
     rounding specifier, despite the fact that this is meaningless.
     To be more compatible, we accept it as well, though of course it
     does not set any bits.  */
  {"fix",        0xee100110, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixp",       0xee100130, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixm",       0xee100150, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixz",       0xee100170, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixsp",      0xee100130, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixsm",      0xee100150, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixsz",      0xee100170, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixdp",      0xee100130, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixdm",      0xee100150, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixdz",      0xee100170, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixep",      0xee100130, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixem",      0xee100150, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},
  {"fixez",      0xee100170, 3,  FPU_FPA_EXT_V1,   do_fpa_to_reg},

  /* Instructions that were new with the real FPA, call them V2.  */
  {"lfm",        0xec100200, 3,  FPU_FPA_EXT_V2,   do_fpa_ldmstm},
  {"lfmfd",      0xec900200, 3,  FPU_FPA_EXT_V2,   do_fpa_ldmstm},
  {"lfmea",      0xed100200, 3,  FPU_FPA_EXT_V2,   do_fpa_ldmstm},
  {"sfm",        0xec000200, 3,  FPU_FPA_EXT_V2,   do_fpa_ldmstm},
  {"sfmfd",      0xed000200, 3,  FPU_FPA_EXT_V2,   do_fpa_ldmstm},
  {"sfmea",      0xec800200, 3,  FPU_FPA_EXT_V2,   do_fpa_ldmstm},

  /* VFP V1xD (single precision).  */
  /* Moves and type conversions.  */
  {"fcpys",   0xeeb00a40, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fmrs",    0xee100a10, 4, FPU_VFP_EXT_V1xD, do_vfp_reg_from_sp},
  {"fmsr",    0xee000a10, 4, FPU_VFP_EXT_V1xD, do_vfp_sp_from_reg},
  {"fmstat",  0xeef1fa10, 6, FPU_VFP_EXT_V1xD, do_empty},
  {"fsitos",  0xeeb80ac0, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fuitos",  0xeeb80a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"ftosis",  0xeebd0a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"ftosizs", 0xeebd0ac0, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"ftouis",  0xeebc0a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"ftouizs", 0xeebc0ac0, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fmrx",    0xeef00a10, 4, FPU_VFP_EXT_V1xD, do_vfp_reg_from_ctrl},
  {"fmxr",    0xeee00a10, 4, FPU_VFP_EXT_V1xD, do_vfp_ctrl_from_reg},

  /* Memory operations.  */
  {"flds",    0xed100a00, 4, FPU_VFP_EXT_V1xD, do_vfp_sp_ldst},
  {"fsts",    0xed000a00, 4, FPU_VFP_EXT_V1xD, do_vfp_sp_ldst},
  {"fldmias", 0xec900a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmia},
  {"fldmfds", 0xec900a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmia},
  {"fldmdbs", 0xed300a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmdb},
  {"fldmeas", 0xed300a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmdb},
  {"fldmiax", 0xec900b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmia},
  {"fldmfdx", 0xec900b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmia},
  {"fldmdbx", 0xed300b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmdb},
  {"fldmeax", 0xed300b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmdb},
  {"fstmias", 0xec800a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmia},
  {"fstmeas", 0xec800a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmia},
  {"fstmdbs", 0xed200a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmdb},
  {"fstmfds", 0xed200a00, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_ldstmdb},
  {"fstmiax", 0xec800b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmia},
  {"fstmeax", 0xec800b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmia},
  {"fstmdbx", 0xed200b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmdb},
  {"fstmfdx", 0xed200b00, 7, FPU_VFP_EXT_V1xD, do_vfp_xp_ldstmdb},

  /* Monadic operations.  */
  {"fabss",   0xeeb00ac0, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fnegs",   0xeeb10a40, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fsqrts",  0xeeb10ac0, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},

  /* Dyadic operations.  */
  {"fadds",   0xee300a00, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fsubs",   0xee300a40, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fmuls",   0xee200a00, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fdivs",   0xee800a00, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fmacs",   0xee000a00, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fmscs",   0xee100a00, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fnmuls",  0xee200a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fnmacs",  0xee000a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},
  {"fnmscs",  0xee100a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_dyadic},

  /* Comparisons.  */
  {"fcmps",   0xeeb40a40, 5, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fcmpzs",  0xeeb50a40, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_compare_z},
  {"fcmpes",  0xeeb40ac0, 6, FPU_VFP_EXT_V1xD, do_vfp_sp_monadic},
  {"fcmpezs", 0xeeb50ac0, 7, FPU_VFP_EXT_V1xD, do_vfp_sp_compare_z},

  /* VFP V1 (Double precision).  */
  /* Moves and type conversions.  */
  {"fcpyd",   0xeeb00b40, 5, FPU_VFP_EXT_V1,   do_vfp_dp_monadic},
  {"fcvtds",  0xeeb70ac0, 6, FPU_VFP_EXT_V1,   do_vfp_dp_sp_cvt},
  {"fcvtsd",  0xeeb70bc0, 6, FPU_VFP_EXT_V1,   do_vfp_sp_dp_cvt},
  {"fmdhr",   0xee200b10, 5, FPU_VFP_EXT_V1,   do_vfp_dp_from_reg},
  {"fmdlr",   0xee000b10, 5, FPU_VFP_EXT_V1,   do_vfp_dp_from_reg},
  {"fmrdh",   0xee300b10, 5, FPU_VFP_EXT_V1,   do_vfp_reg_from_dp},
  {"fmrdl",   0xee100b10, 5, FPU_VFP_EXT_V1,   do_vfp_reg_from_dp},
  {"fsitod",  0xeeb80bc0, 6, FPU_VFP_EXT_V1,   do_vfp_dp_sp_cvt},
  {"fuitod",  0xeeb80b40, 6, FPU_VFP_EXT_V1,   do_vfp_dp_sp_cvt},
  {"ftosid",  0xeebd0b40, 6, FPU_VFP_EXT_V1,   do_vfp_sp_dp_cvt},
  {"ftosizd", 0xeebd0bc0, 7, FPU_VFP_EXT_V1,   do_vfp_sp_dp_cvt},
  {"ftouid",  0xeebc0b40, 6, FPU_VFP_EXT_V1,   do_vfp_sp_dp_cvt},
  {"ftouizd", 0xeebc0bc0, 7, FPU_VFP_EXT_V1,   do_vfp_sp_dp_cvt},

  /* Memory operations.  */
  {"fldd",    0xed100b00, 4, FPU_VFP_EXT_V1,   do_vfp_dp_ldst},
  {"fstd",    0xed000b00, 4, FPU_VFP_EXT_V1,   do_vfp_dp_ldst},
  {"fldmiad", 0xec900b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmia},
  {"fldmfdd", 0xec900b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmia},
  {"fldmdbd", 0xed300b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmdb},
  {"fldmead", 0xed300b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmdb},
  {"fstmiad", 0xec800b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmia},
  {"fstmead", 0xec800b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmia},
  {"fstmdbd", 0xed200b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmdb},
  {"fstmfdd", 0xed200b00, 7, FPU_VFP_EXT_V1,   do_vfp_dp_ldstmdb},

  /* Monadic operations.  */
  {"fabsd",   0xeeb00bc0, 5, FPU_VFP_EXT_V1,   do_vfp_dp_monadic},
  {"fnegd",   0xeeb10b40, 5, FPU_VFP_EXT_V1,   do_vfp_dp_monadic},
  {"fsqrtd",  0xeeb10bc0, 6, FPU_VFP_EXT_V1,   do_vfp_dp_monadic},

  /* Dyadic operations.  */
  {"faddd",   0xee300b00, 5, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fsubd",   0xee300b40, 5, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fmuld",   0xee200b00, 5, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fdivd",   0xee800b00, 5, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fmacd",   0xee000b00, 5, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fmscd",   0xee100b00, 5, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fnmuld",  0xee200b40, 6, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fnmacd",  0xee000b40, 6, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},
  {"fnmscd",  0xee100b40, 6, FPU_VFP_EXT_V1,   do_vfp_dp_dyadic},

  /* Comparisons.  */
  {"fcmpd",   0xeeb40b40, 5, FPU_VFP_EXT_V1,   do_vfp_dp_monadic},
  {"fcmpzd",  0xeeb50b40, 6, FPU_VFP_EXT_V1,   do_vfp_dp_compare_z},
  {"fcmped",  0xeeb40bc0, 6, FPU_VFP_EXT_V1,   do_vfp_dp_monadic},
  {"fcmpezd", 0xeeb50bc0, 7, FPU_VFP_EXT_V1,   do_vfp_dp_compare_z},

  /* VFP V2.  */
  {"fmsrr",   0xec400a10, 5, FPU_VFP_EXT_V2,   do_vfp_sp2_from_reg2},
  {"fmrrs",   0xec500a10, 5, FPU_VFP_EXT_V2,   do_vfp_reg2_from_sp2},
  {"fmdrr",   0xec400b10, 5, FPU_VFP_EXT_V2,   do_vfp_dp_from_reg2},
  {"fmrrd",   0xec500b10, 5, FPU_VFP_EXT_V2,   do_vfp_reg2_from_dp},

  /* Intel XScale extensions to ARM V5 ISA.  (All use CP0).  */
  {"mia",        0xee200010, 3,  ARM_CEXT_XSCALE,   do_xsc_mia},
  {"miaph",      0xee280010, 5,  ARM_CEXT_XSCALE,   do_xsc_mia},
  {"miabb",      0xee2c0010, 5,  ARM_CEXT_XSCALE,   do_xsc_mia},
  {"miabt",      0xee2d0010, 5,  ARM_CEXT_XSCALE,   do_xsc_mia},
  {"miatb",      0xee2e0010, 5,  ARM_CEXT_XSCALE,   do_xsc_mia},
  {"miatt",      0xee2f0010, 5,  ARM_CEXT_XSCALE,   do_xsc_mia},
  {"mar",        0xec400000, 3,  ARM_CEXT_XSCALE,   do_xsc_mar},
  {"mra",        0xec500000, 3,  ARM_CEXT_XSCALE,   do_xsc_mra},

  /* Intel Wireless MMX technology instructions.  */
  {"tandcb",     0xee130130, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tandc},
  {"tandch",     0xee530130, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tandc},
  {"tandcw",     0xee930130, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tandc},
  {"tbcstb",     0xee400010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tbcst},
  {"tbcsth",     0xee400050, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tbcst},
  {"tbcstw",     0xee400090, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tbcst},
  {"textrcb",    0xee130170, 7, ARM_CEXT_IWMMXT, do_iwmmxt_textrc},
  {"textrch",    0xee530170, 7, ARM_CEXT_IWMMXT, do_iwmmxt_textrc},
  {"textrcw",    0xee930170, 7, ARM_CEXT_IWMMXT, do_iwmmxt_textrc},
  {"textrmub",   0xee100070, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"textrmuh",   0xee500070, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"textrmuw",   0xee900070, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"textrmsb",   0xee100078, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"textrmsh",   0xee500078, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"textrmsw",   0xee900078, 8, ARM_CEXT_IWMMXT, do_iwmmxt_textrm},
  {"tinsrb",     0xee600010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tinsr},
  {"tinsrh",     0xee600050, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tinsr},
  {"tinsrw",     0xee600090, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tinsr},
  {"tmcr",       0xee000110, 4, ARM_CEXT_IWMMXT, do_iwmmxt_tmcr},
  {"tmcrr",      0xec400000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_tmcrr},
  {"tmia",       0xee200010, 4, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmiaph",     0xee280010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmiabb",     0xee2c0010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmiabt",     0xee2d0010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmiatb",     0xee2e0010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmiatt",     0xee2f0010, 6, ARM_CEXT_IWMMXT, do_iwmmxt_tmia},
  {"tmovmskb",   0xee100030, 8, ARM_CEXT_IWMMXT, do_iwmmxt_tmovmsk},
  {"tmovmskh",   0xee500030, 8, ARM_CEXT_IWMMXT, do_iwmmxt_tmovmsk},
  {"tmovmskw",   0xee900030, 8, ARM_CEXT_IWMMXT, do_iwmmxt_tmovmsk},
  {"tmrc",       0xee100110, 4, ARM_CEXT_IWMMXT, do_iwmmxt_tmrc},
  {"tmrrc",      0xec500000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_tmrrc},
  {"torcb",      0xee130150, 5, ARM_CEXT_IWMMXT, do_iwmmxt_torc},
  {"torch",      0xee530150, 5, ARM_CEXT_IWMMXT, do_iwmmxt_torc},
  {"torcw",      0xee930150, 5, ARM_CEXT_IWMMXT, do_iwmmxt_torc},
  {"waccb",      0xee0001c0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wacch",      0xee4001c0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"waccw",      0xee8001c0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"waddbss",    0xee300180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddb",      0xee000180, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddbus",    0xee100180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddhss",    0xee700180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddh",      0xee400180, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddhus",    0xee500180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddwss",    0xeeb00180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddw",      0xee800180, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waddwus",    0xee900180, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"waligni",    0xee000020, 7, ARM_CEXT_IWMMXT, do_iwmmxt_waligni},
  {"walignr0",   0xee800020, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"walignr1",   0xee900020, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"walignr2",   0xeea00020, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"walignr3",   0xeeb00020, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wand",       0xee200000, 4, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wandn",      0xee300000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wavg2b",     0xee800000, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wavg2br",    0xee900000, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wavg2h",     0xeec00000, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wavg2hr",    0xeed00000, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpeqb",    0xee000060, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpeqh",    0xee400060, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpeqw",    0xee800060, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtub",   0xee100060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtuh",   0xee500060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtuw",   0xee900060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtsb",   0xee300060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtsh",   0xee700060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wcmpgtsw",   0xeeb00060, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wldrb",      0xec100000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_byte_addr},
  {"wldrh",      0xec100100, 5, ARM_CEXT_IWMMXT, do_iwmmxt_byte_addr},
  {"wldrw",      0xec100200, 5, ARM_CEXT_IWMMXT, do_iwmmxt_word_addr},
  {"wldrd",      0xec100300, 5, ARM_CEXT_IWMMXT, do_iwmmxt_word_addr},
  {"wmacs",      0xee600100, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmacsz",     0xee700100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmacu",      0xee400100, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmacuz",     0xee500100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmadds",     0xeea00100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaddu",     0xee800100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxsb",     0xee200160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxsh",     0xee600160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxsw",     0xeea00160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxub",     0xee000160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxuh",     0xee400160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmaxuw",     0xee800160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminsb",     0xee300160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminsh",     0xee700160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminsw",     0xeeb00160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminub",     0xee100160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminuh",     0xee500160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wminuw",     0xee900160, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmov",       0xee000000, 4, ARM_CEXT_IWMMXT, do_iwmmxt_wmov},
  {"wmulsm",     0xee300100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmulsl",     0xee200100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmulum",     0xee100100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wmulul",     0xee000100, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wor",        0xee000000, 3, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackhss",   0xee700080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackhus",   0xee500080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackwss",   0xeeb00080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackwus",   0xee900080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackdss",   0xeef00080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wpackdus",   0xeed00080, 8, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wrorh",      0xee700040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wrorhg",     0xee700148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wrorw",      0xeeb00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wrorwg",     0xeeb00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wrord",      0xeef00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wrordg",     0xeef00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsadb",      0xee000120, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsadbz",     0xee100120, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsadh",      0xee400120, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsadhz",     0xee500120, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wshufh",     0xee0001e0, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wshufh},
  {"wsllh",      0xee500040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsllhg",     0xee500148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsllw",      0xee900040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsllwg",     0xee900148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wslld",      0xeed00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wslldg",     0xeed00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsrah",      0xee400040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsrahg",     0xee400148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsraw",      0xee800040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsrawg",     0xee800148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsrad",      0xeec00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsradg",     0xeec00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsrlh",      0xee600040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsrlhg",     0xee600148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsrlw",      0xeea00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsrlwg",     0xeea00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wsrld",      0xeee00040, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsrldg",     0xeee00148, 6, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwcg},
  {"wstrb",      0xec000000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_byte_addr},
  {"wstrh",      0xec000100, 5, ARM_CEXT_IWMMXT, do_iwmmxt_byte_addr},
  {"wstrw",      0xec000200, 5, ARM_CEXT_IWMMXT, do_iwmmxt_word_addr},
  {"wstrd",      0xec000300, 5, ARM_CEXT_IWMMXT, do_iwmmxt_word_addr},
  {"wsubbss",    0xee3001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubb",      0xee0001a0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubbus",    0xee1001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubhss",    0xee7001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubh",      0xee4001a0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubhus",    0xee5001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubwss",    0xeeb001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubw",      0xee8001a0, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wsubwus",    0xee9001a0, 7, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckehub", 0xee0000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckehuh", 0xee4000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckehuw", 0xee8000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckehsb", 0xee2000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckehsh", 0xee6000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckehsw", 0xeea000c0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckihb",  0xee1000c0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckihh",  0xee5000c0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckihw",  0xee9000c0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckelub", 0xee0000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckeluh", 0xee4000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckeluw", 0xee8000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckelsb", 0xee2000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckelsh", 0xee6000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckelsw", 0xeea000e0, 10, ARM_CEXT_IWMMXT, do_iwmmxt_wrwr},
  {"wunpckilb",  0xee1000e0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckilh",  0xee5000e0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wunpckilw",  0xee9000e0, 9, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wxor",       0xee100000, 4, ARM_CEXT_IWMMXT, do_iwmmxt_wrwrwr},
  {"wzero",      0xee300000, 5, ARM_CEXT_IWMMXT, do_iwmmxt_wzero},

  /* Cirrus Maverick instructions.  */
  {"cfldrs",     0xec100400, 6,  ARM_CEXT_MAVERICK, do_mav_ldst_1},
  {"cfldrd",     0xec500400, 6,  ARM_CEXT_MAVERICK, do_mav_ldst_2},
  {"cfldr32",    0xec100500, 7,  ARM_CEXT_MAVERICK, do_mav_ldst_3},
  {"cfldr64",    0xec500500, 7,  ARM_CEXT_MAVERICK, do_mav_ldst_4},
  {"cfstrs",     0xec000400, 6,  ARM_CEXT_MAVERICK, do_mav_ldst_1},
  {"cfstrd",     0xec400400, 6,  ARM_CEXT_MAVERICK, do_mav_ldst_2},
  {"cfstr32",    0xec000500, 7,  ARM_CEXT_MAVERICK, do_mav_ldst_3},
  {"cfstr64",    0xec400500, 7,  ARM_CEXT_MAVERICK, do_mav_ldst_4},
  {"cfmvsr",     0xee000450, 6,  ARM_CEXT_MAVERICK, do_mav_binops_2a},
  {"cfmvrs",     0xee100450, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1a},
  {"cfmvdlr",    0xee000410, 7,  ARM_CEXT_MAVERICK, do_mav_binops_2b},
  {"cfmvrdl",    0xee100410, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1b},
  {"cfmvdhr",    0xee000430, 7,  ARM_CEXT_MAVERICK, do_mav_binops_2b},
  {"cfmvrdh",    0xee100430, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1b},
  {"cfmv64lr",   0xee000510, 8,  ARM_CEXT_MAVERICK, do_mav_binops_2c},
  {"cfmvr64l",   0xee100510, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1c},
  {"cfmv64hr",   0xee000530, 8,  ARM_CEXT_MAVERICK, do_mav_binops_2c},
  {"cfmvr64h",   0xee100530, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1c},
  {"cfmval32",   0xee200440, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3a},
  {"cfmv32al",   0xee100440, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3b},
  {"cfmvam32",   0xee200460, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3a},
  {"cfmv32am",   0xee100460, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3b},
  {"cfmvah32",   0xee200480, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3a},
  {"cfmv32ah",   0xee100480, 8,  ARM_CEXT_MAVERICK, do_mav_binops_3b},
  {"cfmva32",    0xee2004a0, 7,  ARM_CEXT_MAVERICK, do_mav_binops_3a},
  {"cfmv32a",    0xee1004a0, 7,  ARM_CEXT_MAVERICK, do_mav_binops_3b},
  {"cfmva64",    0xee2004c0, 7,  ARM_CEXT_MAVERICK, do_mav_binops_3c},
  {"cfmv64a",    0xee1004c0, 7,  ARM_CEXT_MAVERICK, do_mav_binops_3d},
  {"cfmvsc32",   0xee2004e0, 8,  ARM_CEXT_MAVERICK, do_mav_dspsc_1},
  {"cfmv32sc",   0xee1004e0, 8,  ARM_CEXT_MAVERICK, do_mav_dspsc_2},
  {"cfcpys",     0xee000400, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1d},
  {"cfcpyd",     0xee000420, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1e},
  {"cfcvtsd",    0xee000460, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1f},
  {"cfcvtds",    0xee000440, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1g},
  {"cfcvt32s",   0xee000480, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1h},
  {"cfcvt32d",   0xee0004a0, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1i},
  {"cfcvt64s",   0xee0004c0, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1j},
  {"cfcvt64d",   0xee0004e0, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1k},
  {"cfcvts32",   0xee100580, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1l},
  {"cfcvtd32",   0xee1005a0, 8,  ARM_CEXT_MAVERICK, do_mav_binops_1m},
  {"cftruncs32", 0xee1005c0, 10, ARM_CEXT_MAVERICK, do_mav_binops_1l},
  {"cftruncd32", 0xee1005e0, 10, ARM_CEXT_MAVERICK, do_mav_binops_1m},
  {"cfrshl32",   0xee000550, 8,  ARM_CEXT_MAVERICK, do_mav_triple_4a},
  {"cfrshl64",   0xee000570, 8,  ARM_CEXT_MAVERICK, do_mav_triple_4b},
  {"cfsh32",     0xee000500, 6,  ARM_CEXT_MAVERICK, do_mav_shift_1},
  {"cfsh64",     0xee200500, 6,  ARM_CEXT_MAVERICK, do_mav_shift_2},
  {"cfcmps",     0xee100490, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5a},
  {"cfcmpd",     0xee1004b0, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5b},
  {"cfcmp32",    0xee100590, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5c},
  {"cfcmp64",    0xee1005b0, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5d},
  {"cfabss",     0xee300400, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1d},
  {"cfabsd",     0xee300420, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1e},
  {"cfnegs",     0xee300440, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1d},
  {"cfnegd",     0xee300460, 6,  ARM_CEXT_MAVERICK, do_mav_binops_1e},
  {"cfadds",     0xee300480, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5e},
  {"cfaddd",     0xee3004a0, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5f},
  {"cfsubs",     0xee3004c0, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5e},
  {"cfsubd",     0xee3004e0, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5f},
  {"cfmuls",     0xee100400, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5e},
  {"cfmuld",     0xee100420, 6,  ARM_CEXT_MAVERICK, do_mav_triple_5f},
  {"cfabs32",    0xee300500, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1n},
  {"cfabs64",    0xee300520, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1o},
  {"cfneg32",    0xee300540, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1n},
  {"cfneg64",    0xee300560, 7,  ARM_CEXT_MAVERICK, do_mav_binops_1o},
  {"cfadd32",    0xee300580, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5g},
  {"cfadd64",    0xee3005a0, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5h},
  {"cfsub32",    0xee3005c0, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5g},
  {"cfsub64",    0xee3005e0, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5h},
  {"cfmul32",    0xee100500, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5g},
  {"cfmul64",    0xee100520, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5h},
  {"cfmac32",    0xee100540, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5g},
  {"cfmsc32",    0xee100560, 7,  ARM_CEXT_MAVERICK, do_mav_triple_5g},
  {"cfmadd32",   0xee000600, 8,  ARM_CEXT_MAVERICK, do_mav_quad_6a},
  {"cfmsub32",   0xee100600, 8,  ARM_CEXT_MAVERICK, do_mav_quad_6a},
  {"cfmadda32",  0xee200600, 9,  ARM_CEXT_MAVERICK, do_mav_quad_6b},
  {"cfmsuba32",  0xee300600, 9,  ARM_CEXT_MAVERICK, do_mav_quad_6b},
};

/* Iterate over the base tables to create the instruction patterns.  */

static void
build_arm_ops_hsh (void)
{
  unsigned int i;
  unsigned int j;
  static struct obstack insn_obstack;

  obstack_begin (&insn_obstack, 4000);

  for (i = 0; i < sizeof (insns) / sizeof (struct asm_opcode); i++)
    {
      const struct asm_opcode *insn = insns + i;

      if (insn->cond_offset != 0)
	{
	  /* Insn supports conditional execution.  Build the varaints
	     and insert them in the hash table.  */
	  for (j = 0; j < sizeof (conds) / sizeof (struct asm_cond); j++)
	    {
	      unsigned len = strlen (insn->template);
	      struct asm_opcode *new;
	      char *template;

	      new = obstack_alloc (&insn_obstack, sizeof (struct asm_opcode));
	      /* All condition codes are two characters.  */
	      template = obstack_alloc (&insn_obstack, len + 3);

	      strncpy (template, insn->template, insn->cond_offset);
	      strcpy (template + insn->cond_offset, conds[j].template);
	      if (len > insn->cond_offset)
		strcpy (template + insn->cond_offset + 2,
			insn->template + insn->cond_offset);
	      new->template = template;
	      new->cond_offset = 0;
	      new->variant = insn->variant;
	      new->parms = insn->parms;
	      new->value = (insn->value & ~COND_MASK) | conds[j].value;

	      hash_insert (arm_ops_hsh, new->template, (PTR) new);
	    }
	}
      /* Finally, insert the unconditional insn in the table directly;
	 no need to build a copy.  */
      hash_insert (arm_ops_hsh, insn->template, (PTR) insn);
    }
}

#if 0 /* Suppressed - for now.  */
#if defined OBJ_ELF || defined OBJ_COFF

#ifdef OBJ_ELF
#define arm_Note Elf_External_Note
#else
typedef struct
{
  unsigned char	namesz[4];	/* Size of entry's owner string.  */
  unsigned char	descsz[4];	/* Size of the note descriptor.  */
  unsigned char	type[4];	/* Interpretation of the descriptor.  */
  char		name[1];	/* Start of the name+desc data.  */
} arm_Note;
#endif

/* The description is kept to a fix sized in order to make updating
   it and merging it easier.  */
#define ARM_NOTE_DESCRIPTION_LENGTH	8

static void
arm_add_note (const char * name,
	      const char * description,
	      unsigned int type)
{
  arm_Note     note ATTRIBUTE_UNUSED;
  char *       p;
  unsigned int name_len;

  name_len = (strlen (name) + 1 + 3) & ~3;

  p = frag_more (sizeof (note.namesz));
  md_number_to_chars (p, (valueT) name_len, sizeof (note.namesz));

  p = frag_more (sizeof (note.descsz));
  md_number_to_chars (p, (valueT) ARM_NOTE_DESCRIPTION_LENGTH, sizeof (note.descsz));

  p = frag_more (sizeof (note.type));
  md_number_to_chars (p, (valueT) type, sizeof (note.type));

  p = frag_more (name_len);
  strcpy (p, name);

  p = frag_more (ARM_NOTE_DESCRIPTION_LENGTH);
  strncpy (p, description, ARM_NOTE_DESCRIPTION_LENGTH);
  frag_align (2, 0, 0);
}
#endif
#endif


static const struct thumb_opcode tinsns[] =
{
  /* Thumb v1 (ARMv4T).  */
  {"adc",	0x4140,		2,	ARM_EXT_V4T, do_t_arit},
  {"add",	0x0000,		2,	ARM_EXT_V4T, do_t_add},
  {"and",	0x4000,		2,	ARM_EXT_V4T, do_t_arit},
  {"asr",	0x0000,		2,	ARM_EXT_V4T, do_t_asr},
  {"b",		T_OPCODE_BRANCH, 2,	ARM_EXT_V4T, do_t_branch12},
  {"beq",	0xd0fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bne",	0xd1fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bcs",	0xd2fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bhs",	0xd2fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bcc",	0xd3fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bul",	0xd3fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"blo",	0xd3fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bmi",	0xd4fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bpl",	0xd5fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bvs",	0xd6fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bvc",	0xd7fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bhi",	0xd8fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bls",	0xd9fe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bge",	0xdafe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"blt",	0xdbfe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bgt",	0xdcfe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"ble",	0xddfe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bal",	0xdefe,		2,	ARM_EXT_V4T, do_t_branch9},
  {"bic",	0x4380,		2,	ARM_EXT_V4T, do_t_arit},
  {"bl",	0xf7fffffe,	4,	ARM_EXT_V4T, do_t_branch23},
  {"bx",	0x4700,		2,	ARM_EXT_V4T, do_t_bx},
  {"cmn",	T_OPCODE_CMN,	2,	ARM_EXT_V4T, do_t_arit},
  {"cmp",	0x0000,		2,	ARM_EXT_V4T, do_t_compare},
  {"eor",	0x4040,		2,	ARM_EXT_V4T, do_t_arit},
  {"ldmia",	0xc800,		2,	ARM_EXT_V4T, do_t_ldmstm},
  {"ldr",	0x0000,		2,	ARM_EXT_V4T, do_t_ldr},
  {"ldrb",	0x0000,		2,	ARM_EXT_V4T, do_t_ldrb},
  {"ldrh",	0x0000,		2,	ARM_EXT_V4T, do_t_ldrh},
  {"ldrsb",	0x5600,		2,	ARM_EXT_V4T, do_t_lds},
  {"ldrsh",	0x5e00,		2,	ARM_EXT_V4T, do_t_lds},
  {"ldsb",	0x5600,		2,	ARM_EXT_V4T, do_t_lds},
  {"ldsh",	0x5e00,		2,	ARM_EXT_V4T, do_t_lds},
  {"lsl",	0x0000,		2,	ARM_EXT_V4T, do_t_lsl},
  {"lsr",	0x0000,		2,	ARM_EXT_V4T, do_t_lsr},
  {"mov",	0x0000,		2,	ARM_EXT_V4T, do_t_mov},
  {"mul",	T_OPCODE_MUL,	2,	ARM_EXT_V4T, do_t_arit},
  {"mvn",	T_OPCODE_MVN,	2,	ARM_EXT_V4T, do_t_arit},
  {"neg",	T_OPCODE_NEG,	2,	ARM_EXT_V4T, do_t_arit},
  {"orr",	0x4300,		2,	ARM_EXT_V4T, do_t_arit},
  {"pop",	0xbc00,		2,	ARM_EXT_V4T, do_t_push_pop},
  {"push",	0xb400,		2,	ARM_EXT_V4T, do_t_push_pop},
  {"ror",	0x41c0,		2,	ARM_EXT_V4T, do_t_arit},
  {"sbc",	0x4180,		2,	ARM_EXT_V4T, do_t_arit},
  {"stmia",	0xc000,		2,	ARM_EXT_V4T, do_t_ldmstm},
  {"str",	0x0000,		2,	ARM_EXT_V4T, do_t_str},
  {"strb",	0x0000,		2,	ARM_EXT_V4T, do_t_strb},
  {"strh",	0x0000,		2,	ARM_EXT_V4T, do_t_strh},
  {"swi",	0xdf00,		2,	ARM_EXT_V4T, do_t_swi},
  {"sub",	0x0000,		2,	ARM_EXT_V4T, do_t_sub},
  {"tst",	T_OPCODE_TST,	2,	ARM_EXT_V4T, do_t_arit},
  /* Pseudo ops:  */
  {"adr",       0x0000,         2,      ARM_EXT_V4T, do_t_adr},
  {"nop",       0x46C0,         2,      ARM_EXT_V4T, do_t_nop},      /* mov r8,r8  */
  /* Thumb v2 (ARMv5T).  */
  {"blx",	0,		0,	ARM_EXT_V5T, do_t_blx},
  {"bkpt",	0xbe00,		2,	ARM_EXT_V5T, do_t_bkpt},

  /* ARM V6.  */
  {"cpsie",	0xb660,		2,	ARM_EXT_V6,  do_t_cps},
  {"cpsid",     0xb670,		2,	ARM_EXT_V6,  do_t_cps},
  {"cpy",	0x4600,		2,	ARM_EXT_V6,  do_t_cpy},
  {"rev",	0xba00,		2,	ARM_EXT_V6,  do_t_arit},
  {"rev16",	0xba40,		2,	ARM_EXT_V6,  do_t_arit},
  {"revsh",	0xbac0,		2,	ARM_EXT_V6,  do_t_arit},
  {"setend",	0xb650,		2,	ARM_EXT_V6,  do_t_setend},
  {"sxth",	0xb200,		2,	ARM_EXT_V6,  do_t_arit},
  {"sxtb",	0xb240,		2,	ARM_EXT_V6,  do_t_arit},
  {"uxth",	0xb280,		2,	ARM_EXT_V6,  do_t_arit},
  {"uxtb",	0xb2c0,		2,	ARM_EXT_V6,  do_t_arit},
};

void
md_begin (void)
{
  unsigned mach;
  unsigned int i;

  if (   (arm_ops_hsh = hash_new ()) == NULL
      || (arm_tops_hsh = hash_new ()) == NULL
      || (arm_cond_hsh = hash_new ()) == NULL
      || (arm_shift_hsh = hash_new ()) == NULL
      || (arm_psr_hsh = hash_new ()) == NULL)
    as_fatal (_("virtual memory exhausted"));

  build_arm_ops_hsh ();
  for (i = 0; i < sizeof (tinsns) / sizeof (struct thumb_opcode); i++)
    hash_insert (arm_tops_hsh, tinsns[i].template, (PTR) (tinsns + i));
  for (i = 0; i < sizeof (conds) / sizeof (struct asm_cond); i++)
    hash_insert (arm_cond_hsh, conds[i].template, (PTR) (conds + i));
  for (i = 0; i < sizeof (shift_names) / sizeof (struct asm_shift_name); i++)
    hash_insert (arm_shift_hsh, shift_names[i].name, (PTR) (shift_names + i));
  for (i = 0; i < sizeof (psrs) / sizeof (struct asm_psr); i++)
    hash_insert (arm_psr_hsh, psrs[i].template, (PTR) (psrs + i));

  for (i = (int) REG_TYPE_FIRST; i < (int) REG_TYPE_MAX; i++)
    build_reg_hsh (all_reg_maps + i);

  set_constant_flonums ();

  /* Set the cpu variant based on the command-line options.  We prefer
     -mcpu= over -march= if both are set (as for GCC); and we prefer
     -mfpu= over any other way of setting the floating point unit.
     Use of legacy options with new options are faulted.  */
  if (legacy_cpu != -1)
    {
      if (mcpu_cpu_opt != -1 || march_cpu_opt != -1)
	as_bad (_("use of old and new-style options to set CPU type"));

      mcpu_cpu_opt = legacy_cpu;
    }
  else if (mcpu_cpu_opt == -1)
    mcpu_cpu_opt = march_cpu_opt;

  if (legacy_fpu != -1)
    {
      if (mfpu_opt != -1)
	as_bad (_("use of old and new-style options to set FPU type"));

      mfpu_opt = legacy_fpu;
    }
  else if (mfpu_opt == -1)
    {
#if !(defined (TE_LINUX) || defined (TE_NetBSD) || defined (TE_VXWORKS)) 
      /* Some environments specify a default FPU.  If they don't, infer it
	 from the processor.  */
      if (mcpu_fpu_opt != -1)
	mfpu_opt = mcpu_fpu_opt;
      else
	mfpu_opt = march_fpu_opt;
#else
      mfpu_opt = FPU_DEFAULT;
#endif
    }

  if (mfpu_opt == -1)
    {
      if (mcpu_cpu_opt == -1)
	mfpu_opt = FPU_DEFAULT;
      else if (mcpu_cpu_opt & ARM_EXT_V5)
	mfpu_opt = FPU_ARCH_VFP_V2;
      else
	mfpu_opt = FPU_ARCH_FPA;
    }

  if (mcpu_cpu_opt == -1)
    mcpu_cpu_opt = CPU_DEFAULT;

  cpu_variant = mcpu_cpu_opt | mfpu_opt;

  {
    unsigned int flags = 0;

#if defined OBJ_ELF
    flags = meabi_flags;

    switch (meabi_flags)
      {
      case EF_ARM_EABI_UNKNOWN:
#endif
#if defined OBJ_COFF || defined OBJ_ELF
	/* Set the flags in the private structure.  */
	if (uses_apcs_26)      flags |= F_APCS26;
	if (support_interwork) flags |= F_INTERWORK;
	if (uses_apcs_float)   flags |= F_APCS_FLOAT;
	if (pic_code)          flags |= F_PIC;
	if ((cpu_variant & FPU_ANY) == FPU_NONE
	     || (cpu_variant & FPU_ANY) == FPU_ARCH_VFP) /* VFP layout only.  */
	  flags |= F_SOFT_FLOAT;

	switch (mfloat_abi_opt)
	  {
	  case ARM_FLOAT_ABI_SOFT:
	  case ARM_FLOAT_ABI_SOFTFP:
	    flags |= F_SOFT_FLOAT;
	    break;

	  case ARM_FLOAT_ABI_HARD:
	    if (flags & F_SOFT_FLOAT)
	      as_bad (_("hard-float conflicts with specified fpu"));
	    break;
	  }

	/* Using VFP conventions (even if soft-float).  */
	if (cpu_variant & FPU_VFP_EXT_NONE)
	  flags |= F_VFP_FLOAT;
#endif
#if defined OBJ_ELF
	if (cpu_variant & FPU_ARCH_MAVERICK)
	    flags |= EF_ARM_MAVERICK_FLOAT;
	break;

      case EF_ARM_EABI_VER4:
	/* No additional flags to set.  */
	break;

      default:
	abort ();
      }
#endif
#if defined OBJ_COFF || defined OBJ_ELF
    bfd_set_private_flags (stdoutput, flags);

    /* We have run out flags in the COFF header to encode the
       status of ATPCS support, so instead we create a dummy,
       empty, debug section called .arm.atpcs.  */
    if (atpcs)
      {
	asection * sec;

	sec = bfd_make_section (stdoutput, ".arm.atpcs");

	if (sec != NULL)
	  {
	    bfd_set_section_flags
	      (stdoutput, sec, SEC_READONLY | SEC_DEBUGGING /* | SEC_HAS_CONTENTS */);
	    bfd_set_section_size (stdoutput, sec, 0);
	    bfd_set_section_contents (stdoutput, sec, NULL, 0, 0);
	  }
      }
#endif
  }

  /* Record the CPU type as well.  */
  switch (cpu_variant & ARM_CPU_MASK)
    {
    case ARM_2:
      mach = bfd_mach_arm_2;
      break;

    case ARM_3: 		/* Also ARM_250.  */
      mach = bfd_mach_arm_2a;
      break;

    case ARM_6:			/* Also ARM_7.  */
      mach = bfd_mach_arm_3;
      break;

    default:
      mach = bfd_mach_arm_unknown;
      break;
    }

  /* Catch special cases.  */
  if (cpu_variant & ARM_CEXT_IWMMXT)
    mach = bfd_mach_arm_iWMMXt;
  else if (cpu_variant & ARM_CEXT_XSCALE)
    mach = bfd_mach_arm_XScale;
  else if (cpu_variant & ARM_CEXT_MAVERICK)
    mach = bfd_mach_arm_ep9312;
  else if (cpu_variant & ARM_EXT_V5E)
    mach = bfd_mach_arm_5TE;
  else if (cpu_variant & ARM_EXT_V5)
    {
      if (cpu_variant & ARM_EXT_V4T)
	mach = bfd_mach_arm_5T;
      else
	mach = bfd_mach_arm_5;
    }
  else if (cpu_variant & ARM_EXT_V4)
    {
      if (cpu_variant & ARM_EXT_V4T)
	mach = bfd_mach_arm_4T;
      else
	mach = bfd_mach_arm_4;
    }
  else if (cpu_variant & ARM_EXT_V3M)
    mach = bfd_mach_arm_3M;

#if 0 /* Suppressed - for now.  */
#if defined (OBJ_ELF) || defined (OBJ_COFF)

  /* Create a .note section to fully identify this arm binary.  */

#define NOTE_ARCH_STRING 	"arch: "

#if defined OBJ_COFF && ! defined NT_VERSION
#define NT_VERSION  1
#define NT_ARCH     2
#endif

  {
    segT current_seg = now_seg;
    subsegT current_subseg = now_subseg;
    asection * arm_arch;
    const char * arch_string;

    arm_arch = bfd_make_section_old_way (stdoutput, ARM_NOTE_SECTION);

#ifdef OBJ_COFF
    bfd_set_section_flags (stdoutput, arm_arch,
			   SEC_DATA | SEC_ALLOC | SEC_LOAD | SEC_LINK_ONCE \
			   | SEC_HAS_CONTENTS);
#else
    bfd_set_section_flags (stdoutput, arm_arch,
			   SEC_READONLY | SEC_HAS_CONTENTS);
#endif
    arm_arch->output_section = arm_arch;
    subseg_set (arm_arch, 0);

    switch (mach)
      {
      default:
      case bfd_mach_arm_unknown: arch_string = "unknown"; break;
      case bfd_mach_arm_2:       arch_string = "armv2"; break;
      case bfd_mach_arm_2a:      arch_string = "armv2a"; break;
      case bfd_mach_arm_3:       arch_string = "armv3"; break;
      case bfd_mach_arm_3M:      arch_string = "armv3M"; break;
      case bfd_mach_arm_4:       arch_string = "armv4"; break;
      case bfd_mach_arm_4T:      arch_string = "armv4t"; break;
      case bfd_mach_arm_5:       arch_string = "armv5"; break;
      case bfd_mach_arm_5T:      arch_string = "armv5t"; break;
      case bfd_mach_arm_5TE:     arch_string = "armv5te"; break;
      case bfd_mach_arm_XScale:  arch_string = "XScale"; break;
      case bfd_mach_arm_ep9312:  arch_string = "ep9312"; break;
      case bfd_mach_arm_iWMMXt:  arch_string = "iWMMXt"; break;
      }

    arm_add_note (NOTE_ARCH_STRING, arch_string, NT_ARCH);

    subseg_set (current_seg, current_subseg);
  }
#endif
#endif /* Suppressed code.  */

  bfd_set_arch_mach (stdoutput, TARGET_ARCH, mach);
}

/* Turn an integer of n bytes (in val) into a stream of bytes appropriate
   for use in the a.out file, and stores them in the array pointed to by buf.
   This knows about the endian-ness of the target machine and does
   THE RIGHT THING, whatever it is.  Possible values for n are 1 (byte)
   2 (short) and 4 (long)  Floating numbers are put out as a series of
   LITTLENUMS (shorts, here at least).  */

void
md_number_to_chars (char * buf, valueT val, int n)
{
  if (target_big_endian)
    number_to_chars_bigendian (buf, val, n);
  else
    number_to_chars_littleendian (buf, val, n);
}

static valueT
md_chars_to_number (char * buf, int n)
{
  valueT result = 0;
  unsigned char * where = (unsigned char *) buf;

  if (target_big_endian)
    {
      while (n--)
	{
	  result <<= 8;
	  result |= (*where++ & 255);
	}
    }
  else
    {
      while (n--)
	{
	  result <<= 8;
	  result |= (where[n] & 255);
	}
    }

  return result;
}

/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.

   Note that fp constants aren't represent in the normal way on the ARM.
   In big endian mode, things are as expected.  However, in little endian
   mode fp constants are big-endian word-wise, and little-endian byte-wise
   within the words.  For example, (double) 1.1 in big endian mode is
   the byte sequence 3f f1 99 99 99 99 99 9a, and in little endian mode is
   the byte sequence 99 99 f1 3f 9a 99 99 99.

   ??? The format of 12 byte floats is uncertain according to gcc's arm.h.  */

char *
md_atof (int type, char * litP, int * sizeP)
{
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  char *t;
  int i;

  switch (type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

    case 'x':
    case 'X':
      prec = 6;
      break;

    case 'p':
    case 'P':
      prec = 6;
      break;

    default:
      *sizeP = 0;
      return _("bad call to MD_ATOF()");
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;
  *sizeP = prec * 2;

  if (target_big_endian)
    {
      for (i = 0; i < prec; i++)
	{
	  md_number_to_chars (litP, (valueT) words[i], 2);
	  litP += 2;
	}
    }
  else
    {
      if (cpu_variant & FPU_ARCH_VFP)
	for (i = prec - 1; i >= 0; i--)
	  {
	    md_number_to_chars (litP, (valueT) words[i], 2);
	    litP += 2;
	  }
      else
	/* For a 4 byte float the order of elements in `words' is 1 0.
	   For an 8 byte float the order is 1 0 3 2.  */
	for (i = 0; i < prec; i += 2)
	  {
	    md_number_to_chars (litP, (valueT) words[i + 1], 2);
	    md_number_to_chars (litP + 2, (valueT) words[i], 2);
	    litP += 4;
	  }
    }

  return 0;
}

/* The knowledge of the PC's pipeline offset is built into the insns
   themselves.  */

long
md_pcrel_from (fixS * fixP)
{
  if (fixP->fx_addsy
      && S_GET_SEGMENT (fixP->fx_addsy) == undefined_section
      && fixP->fx_subsy == NULL)
    return 0;

  if (fixP->fx_pcrel && (fixP->fx_r_type == BFD_RELOC_ARM_THUMB_ADD))
    {
      /* PC relative addressing on the Thumb is slightly odd
	 as the bottom two bits of the PC are forced to zero
	 for the calculation.  */
      return (fixP->fx_where + fixP->fx_frag->fr_address) & ~3;
    }

#ifdef TE_WINCE
  /* The pattern was adjusted to accommodate CE's off-by-one fixups,
     so we un-adjust here to compensate for the accommodation.  */
  return fixP->fx_where + fixP->fx_frag->fr_address + 8;
#else
  return fixP->fx_where + fixP->fx_frag->fr_address;
#endif
}

/* Round up a section size to the appropriate boundary.  */

valueT
md_section_align (segT   segment ATTRIBUTE_UNUSED,
		  valueT size)
{
#ifdef OBJ_ELF
  return size;
#else
  /* Round all sects to multiple of 4.  */
  return (size + 3) & ~3;
#endif
}

/* Under ELF we need to default _GLOBAL_OFFSET_TABLE.
   Otherwise we have no need to default values of symbols.  */

symbolS *
md_undefined_symbol (char * name ATTRIBUTE_UNUSED)
{
#ifdef OBJ_ELF
  if (name[0] == '_' && name[1] == 'G'
      && streq (name, GLOBAL_OFFSET_TABLE_NAME))
    {
      if (!GOT_symbol)
	{
	  if (symbol_find (name))
	    as_bad ("GOT already in the symbol table");

	  GOT_symbol = symbol_new (name, undefined_section,
				   (valueT) 0, & zero_address_frag);
	}

      return GOT_symbol;
    }
#endif

  return 0;
}

void
md_apply_fix3 (fixS *   fixP,
	       valueT * valP,
	       segT     seg)
{
  offsetT        value = * valP;
  offsetT        newval;
  unsigned int   newimm;
  unsigned long  temp;
  int            sign;
  char *         buf = fixP->fx_where + fixP->fx_frag->fr_literal;
  arm_fix_data * arm_data = (arm_fix_data *) fixP->tc_fix_data;

  assert (fixP->fx_r_type < BFD_RELOC_UNUSED);

  /* Note whether this will delete the relocation.  */
#if 0
  /* Patch from REarnshaw to JDavis (disabled for the moment, since it
     doesn't work fully.)  */
  if ((fixP->fx_addsy == 0 || symbol_constant_p (fixP->fx_addsy))
      && !fixP->fx_pcrel)
#else
  if (fixP->fx_addsy == 0 && !fixP->fx_pcrel)
#endif
    fixP->fx_done = 1;

  /* If this symbol is in a different section then we need to leave it for
     the linker to deal with.  Unfortunately, md_pcrel_from can't tell,
     so we have to undo it's effects here.  */
  if (fixP->fx_pcrel)
    {
      if (fixP->fx_addsy != NULL
	  && S_IS_DEFINED (fixP->fx_addsy)
	  && S_GET_SEGMENT (fixP->fx_addsy) != seg)
	value += md_pcrel_from (fixP);
    }

  /* Remember value for emit_reloc.  */
  fixP->fx_addnumber = value;

  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_ARM_IMMEDIATE:
      /* We claim that this fixup has been processed here,
	 even if in fact we generate an error because we do
	 not have a reloc for it, so tc_gen_reloc will reject it.  */
      fixP->fx_done = 1;

      if (fixP->fx_addsy
	  && ! S_IS_DEFINED (fixP->fx_addsy))
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("undefined symbol %s used as an immediate value"),
			S_GET_NAME (fixP->fx_addsy));
	  break;
	}

      newimm = validate_immediate (value);
      temp = md_chars_to_number (buf, INSN_SIZE);

      /* If the instruction will fail, see if we can fix things up by
	 changing the opcode.  */
      if (newimm == (unsigned int) FAIL
	  && (newimm = negate_data_op (&temp, value)) == (unsigned int) FAIL)
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("invalid constant (%lx) after fixup"),
			(unsigned long) value);
	  break;
	}

      newimm |= (temp & 0xfffff000);
      md_number_to_chars (buf, (valueT) newimm, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_ADRL_IMMEDIATE:
      {
	unsigned int highpart = 0;
	unsigned int newinsn  = 0xe1a00000; /* nop.  */

	newimm = validate_immediate (value);
	temp = md_chars_to_number (buf, INSN_SIZE);

	/* If the instruction will fail, see if we can fix things up by
	   changing the opcode.  */
	if (newimm == (unsigned int) FAIL
	    && (newimm = negate_data_op (& temp, value)) == (unsigned int) FAIL)
	  {
	    /* No ?  OK - try using two ADD instructions to generate
               the value.  */
	    newimm = validate_immediate_twopart (value, & highpart);

	    /* Yes - then make sure that the second instruction is
               also an add.  */
	    if (newimm != (unsigned int) FAIL)
	      newinsn = temp;
	    /* Still No ?  Try using a negated value.  */
	    else if ((newimm = validate_immediate_twopart (- value, & highpart)) != (unsigned int) FAIL)
	      temp = newinsn = (temp & OPCODE_MASK) | OPCODE_SUB << DATA_OP_SHIFT;
	    /* Otherwise - give up.  */
	    else
	      {
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("unable to compute ADRL instructions for PC offset of 0x%lx"),
			      (long) value);
		break;
	      }

	    /* Replace the first operand in the 2nd instruction (which
	       is the PC) with the destination register.  We have
	       already added in the PC in the first instruction and we
	       do not want to do it again.  */
	    newinsn &= ~ 0xf0000;
	    newinsn |= ((newinsn & 0x0f000) << 4);
	  }

	newimm |= (temp & 0xfffff000);
	md_number_to_chars (buf, (valueT) newimm, INSN_SIZE);

	highpart |= (newinsn & 0xfffff000);
	md_number_to_chars (buf + INSN_SIZE, (valueT) highpart, INSN_SIZE);
      }
      break;

    case BFD_RELOC_ARM_OFFSET_IMM:
      sign = value >= 0;

      if (value < 0)
	value = - value;

      if (validate_offset_imm (value, 0) == FAIL)
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("bad immediate value for offset (%ld)"),
			(long) value);
	  break;
	}

      newval = md_chars_to_number (buf, INSN_SIZE);
      newval &= 0xff7ff000;
      newval |= value | (sign ? INDEX_UP : 0);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_OFFSET_IMM8:
    case BFD_RELOC_ARM_HWLITERAL:
      sign = value >= 0;

      if (value < 0)
	value = - value;

      if (validate_offset_imm (value, 1) == FAIL)
	{
	  if (fixP->fx_r_type == BFD_RELOC_ARM_HWLITERAL)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid literal constant: pool needs to be closer"));
	  else
	    as_bad (_("bad immediate value for half-word offset (%ld)"),
		    (long) value);
	  break;
	}

      newval = md_chars_to_number (buf, INSN_SIZE);
      newval &= 0xff7ff0f0;
      newval |= ((value >> 4) << 8) | (value & 0xf) | (sign ? INDEX_UP : 0);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_LITERAL:
      sign = value >= 0;

      if (value < 0)
	value = - value;

      if (validate_offset_imm (value, 0) == FAIL)
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("invalid literal constant: pool needs to be closer"));
	  break;
	}

      newval = md_chars_to_number (buf, INSN_SIZE);
      newval &= 0xff7ff000;
      newval |= value | (sign ? INDEX_UP : 0);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_SHIFT_IMM:
      newval = md_chars_to_number (buf, INSN_SIZE);
      if (((unsigned long) value) > 32
	  || (value == 32
	      && (((newval & 0x60) == 0) || (newval & 0x60) == 0x60)))
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("shift expression is too large"));
	  break;
	}

      if (value == 0)
	/* Shifts of zero must be done as lsl.  */
	newval &= ~0x60;
      else if (value == 32)
	value = 0;
      newval &= 0xfffff07f;
      newval |= (value & 0x1f) << 7;
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_SMI:
      if (((unsigned long) value) > 0xffff)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("invalid smi expression"));
      newval = md_chars_to_number (buf, INSN_SIZE) & 0xfff000f0;
      newval |= (value & 0xf) | ((value & 0xfff0) << 4);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_SWI:
      if (arm_data->thumb_mode)
	{
	  if (((unsigned long) value) > 0xff)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid swi expression"));
	  newval = md_chars_to_number (buf, THUMB_SIZE) & 0xff00;
	  newval |= value;
	  md_number_to_chars (buf, newval, THUMB_SIZE);
	}
      else
	{
	  if (((unsigned long) value) > 0x00ffffff)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid swi expression"));
	  newval = md_chars_to_number (buf, INSN_SIZE) & 0xff000000;
	  newval |= value;
	  md_number_to_chars (buf, newval, INSN_SIZE);
	}
      break;

    case BFD_RELOC_ARM_MULTI:
      if (((unsigned long) value) > 0xffff)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("invalid expression in load/store multiple"));
      newval = value | md_chars_to_number (buf, INSN_SIZE);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_PCREL_BRANCH:
      newval = md_chars_to_number (buf, INSN_SIZE);

      /* Sign-extend a 24-bit number.  */
#define SEXT24(x)	((((x) & 0xffffff) ^ (~ 0x7fffff)) + 0x800000)

#ifdef OBJ_ELF
      value = fixP->fx_offset;
#endif

      /* We are going to store value (shifted right by two) in the
	 instruction, in a 24 bit, signed field.  Thus we need to check
	 that none of the top 8 bits of the shifted value (top 7 bits of
         the unshifted, unsigned value) are set, or that they are all set.  */
      if ((value & ~ ((offsetT) 0x1ffffff)) != 0
	  && ((value & ~ ((offsetT) 0x1ffffff)) != ~ ((offsetT) 0x1ffffff)))
	{
#ifdef OBJ_ELF
	  /* Normally we would be stuck at this point, since we cannot store
	     the absolute address that is the destination of the branch in the
	     24 bits of the branch instruction.  If however, we happen to know
	     that the destination of the branch is in the same section as the
	     branch instruction itself, then we can compute the relocation for
	     ourselves and not have to bother the linker with it.

	     FIXME: The test for OBJ_ELF is only here because I have not
	     worked out how to do this for OBJ_COFF.  */
	  if (fixP->fx_addsy != NULL
	      && S_IS_DEFINED (fixP->fx_addsy)
	      && S_GET_SEGMENT (fixP->fx_addsy) == seg)
	    {
	      /* Get pc relative value to go into the branch.  */
	      value = * valP;

	      /* Permit a backward branch provided that enough bits
		 are set.  Allow a forwards branch, provided that
		 enough bits are clear.  */
	      if (   (value & ~ ((offsetT) 0x1ffffff)) == ~ ((offsetT) 0x1ffffff)
		  || (value & ~ ((offsetT) 0x1ffffff)) == 0)
		fixP->fx_done = 1;
	    }

	  if (! fixP->fx_done)
#endif
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("GAS can't handle same-section branch dest >= 0x04000000"));
	}

      value >>= 2;
      value += SEXT24 (newval);

      if (    (value & ~ ((offsetT) 0xffffff)) != 0
	  && ((value & ~ ((offsetT) 0xffffff)) != ~ ((offsetT) 0xffffff)))
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("out of range branch"));

      if (seg->use_rela_p && !fixP->fx_done)
	{
	  /* Must unshift the value before storing it in the addend.  */
	  value <<= 2;
#ifdef OBJ_ELF
	  fixP->fx_offset = value;
#endif
	  fixP->fx_addnumber = value;
	  newval = newval & 0xff000000;
	}
      else
	  newval = (value & 0x00ffffff) | (newval & 0xff000000);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_PCREL_BLX:
      {
	offsetT hbit;
	newval = md_chars_to_number (buf, INSN_SIZE);

#ifdef OBJ_ELF
	value = fixP->fx_offset;
#endif
	hbit   = (value >> 1) & 1;
	value  = (value >> 2) & 0x00ffffff;
	value  = (value + (newval & 0x00ffffff)) & 0x00ffffff;

	if (seg->use_rela_p && !fixP->fx_done)
	  {
	    /* Must sign-extend and unshift the value before storing
	       it in the addend.  */
	    value = SEXT24 (value);
	    value = (value << 2) | hbit;
#ifdef OBJ_ELF
	    fixP->fx_offset = value;
#endif
	    fixP->fx_addnumber = value;
	    newval = newval & 0xfe000000;
	  }
	else
	  newval = value | (newval & 0xfe000000) | (hbit << 24);
	md_number_to_chars (buf, newval, INSN_SIZE);
      }
      break;

    case BFD_RELOC_THUMB_PCREL_BRANCH9: /* Conditional branch.  */
      newval = md_chars_to_number (buf, THUMB_SIZE);
      {
	addressT diff = (newval & 0xff) << 1;
	if (diff & 0x100)
	  diff |= ~0xff;

	value += diff;
	if ((value & ~0xff) && ((value & ~0xff) != ~0xff))
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("branch out of range"));
	if (seg->use_rela_p && !fixP->fx_done)
	  {
#ifdef OBJ_ELF
	    fixP->fx_offset = value;
#endif
	    fixP->fx_addnumber = value;
	    newval = newval & 0xff00;
	  }
	else
	  newval = (newval & 0xff00) | ((value & 0x1ff) >> 1);
      }
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;

    case BFD_RELOC_THUMB_PCREL_BRANCH12: /* Unconditional branch.  */
      newval = md_chars_to_number (buf, THUMB_SIZE);
      {
	addressT diff = (newval & 0x7ff) << 1;
	if (diff & 0x800)
	  diff |= ~0x7ff;

	value += diff;
	if ((value & ~0x7ff) && ((value & ~0x7ff) != ~0x7ff))
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("branch out of range"));
	if (seg->use_rela_p && !fixP->fx_done)
	  {
#ifdef OBJ_ELF
	    fixP->fx_offset = value;
#endif
	    fixP->fx_addnumber = value;
	    newval = newval & 0xf800;
	  }
	else
	  newval = (newval & 0xf800) | ((value & 0xfff) >> 1);
      }
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;

    case BFD_RELOC_THUMB_PCREL_BLX:
    case BFD_RELOC_THUMB_PCREL_BRANCH23:
      {
	offsetT newval2;
	addressT diff;

	newval  = md_chars_to_number (buf, THUMB_SIZE);
	newval2 = md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);
	diff = ((newval & 0x7ff) << 12) | ((newval2 & 0x7ff) << 1);
	if (diff & 0x400000)
	  diff |= ~0x3fffff;
#ifdef OBJ_ELF
	value = fixP->fx_offset;
#endif
	value += diff;

	if ((value & ~0x3fffff) && ((value & ~0x3fffff) != ~0x3fffff))
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("branch with link out of range"));

	if (fixP->fx_r_type == BFD_RELOC_THUMB_PCREL_BLX)
	  /* For a BLX instruction, make sure that the relocation is rounded up
	     to a word boundary.  This follows the semantics of the instruction
	     which specifies that bit 1 of the target address will come from bit
	     1 of the base address.  */
	  value = (value + 1) & ~ 1;

	if (seg->use_rela_p && !fixP->fx_done)
	  {
#ifdef OBJ_ELF
	    fixP->fx_offset = value;
#endif
	    fixP->fx_addnumber = value;
	    newval = newval & 0xf800;
	    newval2 = newval2 & 0xf800;
	  }
	else
	  {
	    newval  = (newval  & 0xf800) | ((value & 0x7fffff) >> 12);
	    newval2 = (newval2 & 0xf800) | ((value & 0xfff) >> 1);
	  }
	md_number_to_chars (buf, newval, THUMB_SIZE);
	md_number_to_chars (buf + THUMB_SIZE, newval2, THUMB_SIZE);
      }
      break;

    case BFD_RELOC_8:
      if (seg->use_rela_p && !fixP->fx_done)
	break;
      if (fixP->fx_done || fixP->fx_pcrel)
	md_number_to_chars (buf, value, 1);
#ifdef OBJ_ELF
      else
	{
	  value = fixP->fx_offset;
	  md_number_to_chars (buf, value, 1);
	}
#endif
      break;

    case BFD_RELOC_16:
      if (seg->use_rela_p && !fixP->fx_done)
	break;
      if (fixP->fx_done || fixP->fx_pcrel)
	md_number_to_chars (buf, value, 2);
#ifdef OBJ_ELF
      else
	{
	  value = fixP->fx_offset;
	  md_number_to_chars (buf, value, 2);
	}
#endif
      break;

#ifdef OBJ_ELF
    case BFD_RELOC_ARM_GOT32:
    case BFD_RELOC_ARM_GOTOFF:
    case BFD_RELOC_ARM_TARGET2:
      if (seg->use_rela_p && !fixP->fx_done)
	break;
      md_number_to_chars (buf, 0, 4);
      break;
#endif

    case BFD_RELOC_RVA:
    case BFD_RELOC_32:
    case BFD_RELOC_ARM_TARGET1:
    case BFD_RELOC_ARM_ROSEGREL32:
    case BFD_RELOC_ARM_SBREL32:
    case BFD_RELOC_32_PCREL:
      if (seg->use_rela_p && !fixP->fx_done)
	break;
      if (fixP->fx_done || fixP->fx_pcrel)
	md_number_to_chars (buf, value, 4);
#ifdef OBJ_ELF
      else
	{
	  value = fixP->fx_offset;
	  md_number_to_chars (buf, value, 4);
	}
#endif
      break;

#ifdef OBJ_ELF
    case BFD_RELOC_ARM_PREL31:
      if (fixP->fx_done || fixP->fx_pcrel)
	{
	  newval = md_chars_to_number (buf, 4) & 0x80000000;
	  if ((value ^ (value >> 1)) & 0x40000000)
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("rel31 relocation overflow"));
	    }
	  newval |= value & 0x7fffffff;
	  md_number_to_chars (buf, newval, 4);
	}
      break;

    case BFD_RELOC_ARM_PLT32:
      /* It appears the instruction is fully prepared at this point.  */
      break;
#endif

    case BFD_RELOC_ARM_CP_OFF_IMM:
      sign = value >= 0;
      if (value < -1023 || value > 1023 || (value & 3))
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("illegal value for co-processor offset"));
      if (value < 0)
	value = -value;
      newval = md_chars_to_number (buf, INSN_SIZE) & 0xff7fff00;
      newval |= (value >> 2) | (sign ? INDEX_UP : 0);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_CP_OFF_IMM_S2:
      sign = value >= 0;
      if (value < -255 || value > 255)
        as_bad_where (fixP->fx_file, fixP->fx_line,
                      _("Illegal value for co-processor offset"));
      if (value < 0)
        value = -value;
      newval = md_chars_to_number (buf, INSN_SIZE) & 0xff7fff00;
      newval |= value | (sign ?  INDEX_UP : 0);
      md_number_to_chars (buf, newval , INSN_SIZE);
      break;

    case BFD_RELOC_ARM_THUMB_OFFSET:
      newval = md_chars_to_number (buf, THUMB_SIZE);
      /* Exactly what ranges, and where the offset is inserted depends
	 on the type of instruction, we can establish this from the
	 top 4 bits.  */
      switch (newval >> 12)
	{
	case 4: /* PC load.  */
	  /* Thumb PC loads are somewhat odd, bit 1 of the PC is
	     forced to zero for these loads, so we will need to round
	     up the offset if the instruction address is not word
	     aligned (since the final address produced must be, and
	     we can only describe word-aligned immediate offsets).  */

	  if ((fixP->fx_frag->fr_address + fixP->fx_where + value) & 3)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, target not word aligned (0x%08X)"),
			  (unsigned int) (fixP->fx_frag->fr_address
					  + fixP->fx_where + value));

	  if ((value + 2) & ~0x3fe)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);

	  /* Round up, since pc will be rounded down.  */
	  newval |= (value + 2) >> 2;
	  break;

	case 9: /* SP load/store.  */
	  if (value & ~0x3fc)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
	  newval |= value >> 2;
	  break;

	case 6: /* Word load/store.  */
	  if (value & ~0x7c)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
	  newval |= value << 4; /* 6 - 2.  */
	  break;

	case 7: /* Byte load/store.  */
	  if (value & ~0x1f)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
	  newval |= value << 6;
	  break;

	case 8: /* Halfword load/store.  */
	  if (value & ~0x3e)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
	  newval |= value << 5; /* 6 - 1.  */
	  break;

	default:
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			"Unable to process relocation for thumb opcode: %lx",
			(unsigned long) newval);
	  break;
	}
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;

    case BFD_RELOC_ARM_THUMB_ADD:
      /* This is a complicated relocation, since we use it for all of
         the following immediate relocations:

	    3bit ADD/SUB
	    8bit ADD/SUB
	    9bit ADD/SUB SP word-aligned
	   10bit ADD PC/SP word-aligned

         The type of instruction being processed is encoded in the
         instruction field:

	   0x8000  SUB
	   0x00F0  Rd
	   0x000F  Rs
      */
      newval = md_chars_to_number (buf, THUMB_SIZE);
      {
	int rd = (newval >> 4) & 0xf;
	int rs = newval & 0xf;
	int subtract = newval & 0x8000;

	if (rd == REG_SP)
	  {
	    if (value & ~0x1fc)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("invalid immediate for stack address calculation"));
	    newval = subtract ? T_OPCODE_SUB_ST : T_OPCODE_ADD_ST;
	    newval |= value >> 2;
	  }
	else if (rs == REG_PC || rs == REG_SP)
	  {
	    if (subtract ||
		value & ~0x3fc)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("invalid immediate for address calculation (value = 0x%08lX)"),
			    (unsigned long) value);
	    newval = (rs == REG_PC ? T_OPCODE_ADD_PC : T_OPCODE_ADD_SP);
	    newval |= rd << 8;
	    newval |= value >> 2;
	  }
	else if (rs == rd)
	  {
	    if (value & ~0xff)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("invalid 8bit immediate"));
	    newval = subtract ? T_OPCODE_SUB_I8 : T_OPCODE_ADD_I8;
	    newval |= (rd << 8) | value;
	  }
	else
	  {
	    if (value & ~0x7)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("invalid 3bit immediate"));
	    newval = subtract ? T_OPCODE_SUB_I3 : T_OPCODE_ADD_I3;
	    newval |= rd | (rs << 3) | (value << 6);
	  }
      }
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;

    case BFD_RELOC_ARM_THUMB_IMM:
      newval = md_chars_to_number (buf, THUMB_SIZE);
      switch (newval >> 11)
	{
	case 0x04: /* 8bit immediate MOV.  */
	case 0x05: /* 8bit immediate CMP.  */
	  if (value < 0 || value > 255)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid immediate: %ld is too large"),
			  (long) value);
	  newval |= value;
	  break;

	default:
	  abort ();
	}
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;

    case BFD_RELOC_ARM_THUMB_SHIFT:
      /* 5bit shift value (0..31).  */
      if (value < 0 || value > 31)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("illegal Thumb shift value: %ld"), (long) value);
      newval = md_chars_to_number (buf, THUMB_SIZE) & 0xf03f;
      newval |= value << 6;
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;

    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      fixP->fx_done = 0;
      return;

    case BFD_RELOC_NONE:
    default:
      as_bad_where (fixP->fx_file, fixP->fx_line,
		    _("bad relocation fixup type (%d)"), fixP->fx_r_type);
    }
}

/* Translate internal representation of relocation info to BFD target
   format.  */

arelent *
tc_gen_reloc (asection * section ATTRIBUTE_UNUSED,
	      fixS *     fixp)
{
  arelent * reloc;
  bfd_reloc_code_real_type code;

  reloc = xmalloc (sizeof (arelent));

  reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;

  /* @@@@ Why fx_addnumber sometimes and fx_offset other times?  */
#ifndef OBJ_ELF
  if (fixp->fx_pcrel == 0)
    reloc->addend = fixp->fx_offset;
  else
    reloc->addend = fixp->fx_offset = reloc->address;
#else  /* OBJ_ELF */
  reloc->addend = fixp->fx_offset;
#endif

  switch (fixp->fx_r_type)
    {
    case BFD_RELOC_8:
      if (fixp->fx_pcrel)
	{
	  code = BFD_RELOC_8_PCREL;
	  break;
	}

    case BFD_RELOC_16:
      if (fixp->fx_pcrel)
	{
	  code = BFD_RELOC_16_PCREL;
	  break;
	}

    case BFD_RELOC_32:
      if (fixp->fx_pcrel)
	{
	  code = BFD_RELOC_32_PCREL;
	  break;
	}

    case BFD_RELOC_ARM_PCREL_BRANCH:
    case BFD_RELOC_ARM_PCREL_BLX:
    case BFD_RELOC_RVA:
    case BFD_RELOC_THUMB_PCREL_BRANCH9:
    case BFD_RELOC_THUMB_PCREL_BRANCH12:
    case BFD_RELOC_THUMB_PCREL_BRANCH23:
    case BFD_RELOC_THUMB_PCREL_BLX:
    case BFD_RELOC_VTABLE_ENTRY:
    case BFD_RELOC_VTABLE_INHERIT:
      code = fixp->fx_r_type;
      break;

    case BFD_RELOC_ARM_LITERAL:
    case BFD_RELOC_ARM_HWLITERAL:
      /* If this is called then the a literal has
	 been referenced across a section boundary.  */
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("literal referenced across section boundary"));
      return NULL;

#ifdef OBJ_ELF
    case BFD_RELOC_ARM_GOT32:
    case BFD_RELOC_ARM_GOTOFF:
    case BFD_RELOC_ARM_PLT32:
    case BFD_RELOC_ARM_TARGET1:
    case BFD_RELOC_ARM_ROSEGREL32:
    case BFD_RELOC_ARM_SBREL32:
    case BFD_RELOC_ARM_PREL31:
    case BFD_RELOC_ARM_TARGET2:
      code = fixp->fx_r_type;
      break;
#endif

    case BFD_RELOC_ARM_IMMEDIATE:
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("internal relocation (type: IMMEDIATE) not fixed up"));
      return NULL;

    case BFD_RELOC_ARM_ADRL_IMMEDIATE:
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("ADRL used for a symbol not defined in the same file"));
      return NULL;

    case BFD_RELOC_ARM_OFFSET_IMM:
      if (fixp->fx_addsy != NULL
	  && !S_IS_DEFINED (fixp->fx_addsy)
	  && S_IS_LOCAL (fixp->fx_addsy))
	{
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			_("undefined local label `%s'"),
			S_GET_NAME (fixp->fx_addsy));
	  return NULL;
	}

      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("internal_relocation (type: OFFSET_IMM) not fixed up"));
      return NULL;

    default:
      {
	char * type;

	switch (fixp->fx_r_type)
	  {
	  case BFD_RELOC_ARM_OFFSET_IMM8:  type = "OFFSET_IMM8";  break;
	  case BFD_RELOC_ARM_SHIFT_IMM:    type = "SHIFT_IMM";    break;
	  case BFD_RELOC_ARM_SMI:          type = "SMI";          break;
	  case BFD_RELOC_ARM_SWI:          type = "SWI";          break;
	  case BFD_RELOC_ARM_MULTI:        type = "MULTI";        break;
	  case BFD_RELOC_ARM_CP_OFF_IMM:   type = "CP_OFF_IMM";   break;
	  case BFD_RELOC_ARM_THUMB_ADD:    type = "THUMB_ADD";    break;
	  case BFD_RELOC_ARM_THUMB_SHIFT:  type = "THUMB_SHIFT";  break;
	  case BFD_RELOC_ARM_THUMB_IMM:    type = "THUMB_IMM";    break;
	  case BFD_RELOC_ARM_THUMB_OFFSET: type = "THUMB_OFFSET"; break;
	  default:                         type = _("<unknown>"); break;
	  }
	as_bad_where (fixp->fx_file, fixp->fx_line,
		      _("cannot represent %s relocation in this object file format"),
		      type);
	return NULL;
      }
    }

#ifdef OBJ_ELF
  if ((code == BFD_RELOC_32_PCREL || code == BFD_RELOC_32)
      && GOT_symbol
      && fixp->fx_addsy == GOT_symbol)
    {
      code = BFD_RELOC_ARM_GOTPC;
      reloc->addend = fixp->fx_offset = reloc->address;
    }
#endif

  reloc->howto = bfd_reloc_type_lookup (stdoutput, code);

  if (reloc->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("cannot represent %s relocation in this object file format"),
		    bfd_get_reloc_code_name (code));
      return NULL;
    }

  /* HACK: Since arm ELF uses Rel instead of Rela, encode the
     vtable entry to be used in the relocation's section offset.  */
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    reloc->address = fixp->fx_offset;

  return reloc;
}

int
md_estimate_size_before_relax (fragS * fragP ATTRIBUTE_UNUSED,
			       segT    segtype ATTRIBUTE_UNUSED)
{
  as_fatal (_("md_estimate_size_before_relax\n"));
  return 1;
}

/* We need to be able to fix up arbitrary expressions in some statements.
   This is so that we can handle symbols that are an arbitrary distance from
   the pc.  The most common cases are of the form ((+/-sym -/+ . - 8) & mask),
   which returns part of an address in a form which will be valid for
   a data instruction.  We do this by pushing the expression into a symbol
   in the expr_section, and creating a fix for that.  */

static void
fix_new_arm (fragS *       frag,
	     int           where,
	     short int     size,
	     expressionS * exp,
	     int           pc_rel,
	     int           reloc)
{
  fixS *           new_fix;
  arm_fix_data *   arm_data;

  switch (exp->X_op)
    {
    case O_constant:
    case O_symbol:
    case O_add:
    case O_subtract:
      new_fix = fix_new_exp (frag, where, size, exp, pc_rel, reloc);
      break;

    default:
      new_fix = fix_new (frag, where, size, make_expr_symbol (exp), 0,
			 pc_rel, reloc);
      break;
    }

  /* Mark whether the fix is to a THUMB instruction, or an ARM
     instruction.  */
  arm_data = obstack_alloc (& notes, sizeof (arm_fix_data));
  new_fix->tc_fix_data = (PTR) arm_data;
  arm_data->thumb_mode = thumb_mode;
}

static void
output_inst (const char * str)
{
  char * to = NULL;

  if (inst.error)
    {
      as_bad ("%s -- `%s'", inst.error, str);
      return;
    }

  to = frag_more (inst.size);

  if (thumb_mode && (inst.size > THUMB_SIZE))
    {
      assert (inst.size == (2 * THUMB_SIZE));
      md_number_to_chars (to, inst.instruction >> 16, THUMB_SIZE);
      md_number_to_chars (to + THUMB_SIZE, inst.instruction, THUMB_SIZE);
    }
  else if (inst.size > INSN_SIZE)
    {
      assert (inst.size == (2 * INSN_SIZE));
      md_number_to_chars (to, inst.instruction, INSN_SIZE);
      md_number_to_chars (to + INSN_SIZE, inst.instruction, INSN_SIZE);
    }
  else
    md_number_to_chars (to, inst.instruction, inst.size);

  if (inst.reloc.type != BFD_RELOC_NONE)
    fix_new_arm (frag_now, to - frag_now->fr_literal,
		 inst.size, & inst.reloc.exp, inst.reloc.pc_rel,
		 inst.reloc.type);

#ifdef OBJ_ELF
  dwarf2_emit_insn (inst.size);
#endif
}

void
md_assemble (char * str)
{
  char  c;
  char *p;
  char *start;

  /* Align the instruction.
     This may not be the right thing to do but ...  */
#if 0
  arm_align (2, 0);
#endif

  /* Align the previous label if needed.  */
  if (last_label_seen != NULL)
    {
      symbol_set_frag (last_label_seen, frag_now);
      S_SET_VALUE (last_label_seen, (valueT) frag_now_fix ());
      S_SET_SEGMENT (last_label_seen, now_seg);
    }

  memset (&inst, '\0', sizeof (inst));
  inst.reloc.type = BFD_RELOC_NONE;

  skip_whitespace (str);

  /* Scan up to the end of the op-code, which must end in white space or
     end of string.  */
  for (start = p = str; *p != '\0'; p++)
    if (*p == ' ')
      break;

  if (p == str)
    {
      as_bad (_("no operator -- statement `%s'\n"), str);
      return;
    }

  if (thumb_mode)
    {
      const struct thumb_opcode * opcode;

      c = *p;
      *p = '\0';
      opcode = (const struct thumb_opcode *) hash_find (arm_tops_hsh, str);
      *p = c;

      if (opcode)
	{
	  /* Check that this instruction is supported for this CPU.  */
	  if (thumb_mode == 1 && (opcode->variant & cpu_variant) == 0)
	    {
	      as_bad (_("selected processor does not support `%s'"), str);
	      return;
	    }

	  mapping_state (MAP_THUMB);
	  inst.instruction = opcode->value;
	  inst.size = opcode->size;
	  opcode->parms (p);
	  output_inst (str);
	  return;
	}
    }
  else
    {
      const struct asm_opcode * opcode;

      c = *p;
      *p = '\0';
      opcode = (const struct asm_opcode *) hash_find (arm_ops_hsh, str);
      *p = c;

      if (opcode)
	{
	  /* Check that this instruction is supported for this CPU.  */
	  if ((opcode->variant & cpu_variant) == 0)
	    {
	      as_bad (_("selected processor does not support `%s'"), str);
	      return;
	    }

          mapping_state (MAP_ARM);
	  inst.instruction = opcode->value;
	  inst.size = INSN_SIZE;
	  opcode->parms (p);
	  output_inst (str);
	  return;
	}
    }

  /* It wasn't an instruction, but it might be a register alias of the form
     alias .req reg.  */
  if (create_register_alias (str, p))
    return;

  as_bad (_("bad instruction `%s'"), start);
}

/* md_parse_option
      Invocation line includes a switch not recognized by the base assembler.
      See if it's a processor-specific option.

      This routine is somewhat complicated by the need for backwards
      compatibility (since older releases of gcc can't be changed).
      The new options try to make the interface as compatible as
      possible with GCC.

      New options (supported) are:

	      -mcpu=<cpu name>		 Assemble for selected processor
	      -march=<architecture name> Assemble for selected architecture
	      -mfpu=<fpu architecture>	 Assemble for selected FPU.
	      -EB/-mbig-endian		 Big-endian
	      -EL/-mlittle-endian	 Little-endian
	      -k			 Generate PIC code
	      -mthumb			 Start in Thumb mode
	      -mthumb-interwork		 Code supports ARM/Thumb interworking

      For now we will also provide support for:

	      -mapcs-32			 32-bit Program counter
	      -mapcs-26			 26-bit Program counter
	      -macps-float		 Floats passed in FP registers
	      -mapcs-reentrant		 Reentrant code
	      -matpcs
      (sometime these will probably be replaced with -mapcs=<list of options>
      and -matpcs=<list of options>)

      The remaining options are only supported for back-wards compatibility.
      Cpu variants, the arm part is optional:
              -m[arm]1                Currently not supported.
              -m[arm]2, -m[arm]250    Arm 2 and Arm 250 processor
              -m[arm]3                Arm 3 processor
              -m[arm]6[xx],           Arm 6 processors
              -m[arm]7[xx][t][[d]m]   Arm 7 processors
              -m[arm]8[10]            Arm 8 processors
              -m[arm]9[20][tdmi]      Arm 9 processors
              -mstrongarm[110[0]]     StrongARM processors
              -mxscale                XScale processors
              -m[arm]v[2345[t[e]]]    Arm architectures
              -mall                   All (except the ARM1)
      FP variants:
              -mfpa10, -mfpa11        FPA10 and 11 co-processor instructions
              -mfpe-old               (No float load/store multiples)
	      -mvfpxd		      VFP Single precision
	      -mvfp		      All VFP
              -mno-fpu                Disable all floating point instructions

      The following CPU names are recognized:
	      arm1, arm2, arm250, arm3, arm6, arm600, arm610, arm620,
	      arm7, arm7m, arm7d, arm7dm, arm7di, arm7dmi, arm70, arm700,
	      arm700i, arm710 arm710t, arm720, arm720t, arm740t, arm710c,
	      arm7100, arm7500, arm7500fe, arm7tdmi, arm8, arm810, arm9,
	      arm920, arm920t, arm940t, arm946, arm966, arm9tdmi, arm9e,
	      arm10t arm10e, arm1020t, arm1020e, arm10200e,
	      strongarm, strongarm110, strongarm1100, strongarm1110, xscale.

      */

const char * md_shortopts = "m:k";

#ifdef ARM_BI_ENDIAN
#define OPTION_EB (OPTION_MD_BASE + 0)
#define OPTION_EL (OPTION_MD_BASE + 1)
#else
#if TARGET_BYTES_BIG_ENDIAN
#define OPTION_EB (OPTION_MD_BASE + 0)
#else
#define OPTION_EL (OPTION_MD_BASE + 1)
#endif
#endif

struct option md_longopts[] =
{
#ifdef OPTION_EB
  {"EB", no_argument, NULL, OPTION_EB},
#endif
#ifdef OPTION_EL
  {"EL", no_argument, NULL, OPTION_EL},
#endif
  {NULL, no_argument, NULL, 0}
};

size_t md_longopts_size = sizeof (md_longopts);

struct arm_option_table
{
  char *option;		/* Option name to match.  */
  char *help;		/* Help information.  */
  int  *var;		/* Variable to change.  */
  int   value;		/* What to change it to.  */
  char *deprecated;	/* If non-null, print this message.  */
};

struct arm_option_table arm_opts[] =
{
  {"k",      N_("generate PIC code"),      &pic_code,    1, NULL},
  {"mthumb", N_("assemble Thumb code"),    &thumb_mode,  1, NULL},
  {"mthumb-interwork", N_("support ARM/Thumb interworking"),
   &support_interwork, 1, NULL},
  {"mapcs-32", N_("code uses 32-bit program counter"), &uses_apcs_26, 0, NULL},
  {"mapcs-26", N_("code uses 26-bit program counter"), &uses_apcs_26, 1, NULL},
  {"mapcs-float", N_("floating point args are in fp regs"), &uses_apcs_float,
   1, NULL},
  {"mapcs-reentrant", N_("re-entrant code"), &pic_code, 1, NULL},
  {"matpcs", N_("code is ATPCS conformant"), &atpcs, 1, NULL},
  {"mbig-endian", N_("assemble for big-endian"), &target_big_endian, 1, NULL},
  {"mlittle-endian", N_("assemble for little-endian"), &target_big_endian, 1,
   NULL},

  /* These are recognized by the assembler, but have no affect on code.  */
  {"mapcs-frame", N_("use frame pointer"), NULL, 0, NULL},
  {"mapcs-stack-check", N_("use stack size checking"), NULL, 0, NULL},

  /* DON'T add any new processors to this list -- we want the whole list
     to go away...  Add them to the processors table instead.  */
  {"marm1",	 NULL, &legacy_cpu, ARM_ARCH_V1,  N_("use -mcpu=arm1")},
  {"m1",	 NULL, &legacy_cpu, ARM_ARCH_V1,  N_("use -mcpu=arm1")},
  {"marm2",	 NULL, &legacy_cpu, ARM_ARCH_V2,  N_("use -mcpu=arm2")},
  {"m2",	 NULL, &legacy_cpu, ARM_ARCH_V2,  N_("use -mcpu=arm2")},
  {"marm250",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm250")},
  {"m250",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm250")},
  {"marm3",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm3")},
  {"m3",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm3")},
  {"marm6",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm6")},
  {"m6",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm6")},
  {"marm600",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm600")},
  {"m600",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm600")},
  {"marm610",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm610")},
  {"m610",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm610")},
  {"marm620",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm620")},
  {"m620",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm620")},
  {"marm7",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7")},
  {"m7",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7")},
  {"marm70",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm70")},
  {"m70",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm70")},
  {"marm700",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700")},
  {"m700",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700")},
  {"marm700i",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700i")},
  {"m700i",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700i")},
  {"marm710",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710")},
  {"m710",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710")},
  {"marm710c",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710c")},
  {"m710c",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710c")},
  {"marm720",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm720")},
  {"m720",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm720")},
  {"marm7d",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7d")},
  {"m7d",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7d")},
  {"marm7di",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7di")},
  {"m7di",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7di")},
  {"marm7m",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7m")},
  {"m7m",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7m")},
  {"marm7dm",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dm")},
  {"m7dm",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dm")},
  {"marm7dmi",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dmi")},
  {"m7dmi",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dmi")},
  {"marm7100",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7100")},
  {"m7100",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7100")},
  {"marm7500",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500")},
  {"m7500",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500")},
  {"marm7500fe", NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500fe")},
  {"m7500fe",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500fe")},
  {"marm7t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"m7t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"marm7tdmi",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"m7tdmi",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"marm710t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm710t")},
  {"m710t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm710t")},
  {"marm720t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm720t")},
  {"m720t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm720t")},
  {"marm740t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm740t")},
  {"m740t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm740t")},
  {"marm8",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm8")},
  {"m8",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm8")},
  {"marm810",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm810")},
  {"m810",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm810")},
  {"marm9",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9")},
  {"m9",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9")},
  {"marm9tdmi",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9tdmi")},
  {"m9tdmi",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9tdmi")},
  {"marm920",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm920")},
  {"m920",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm920")},
  {"marm940",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm940")},
  {"m940",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm940")},
  {"mstrongarm", NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=strongarm")},
  {"mstrongarm110", NULL, &legacy_cpu, ARM_ARCH_V4,
   N_("use -mcpu=strongarm110")},
  {"mstrongarm1100", NULL, &legacy_cpu, ARM_ARCH_V4,
   N_("use -mcpu=strongarm1100")},
  {"mstrongarm1110", NULL, &legacy_cpu, ARM_ARCH_V4,
   N_("use -mcpu=strongarm1110")},
  {"mxscale",	 NULL, &legacy_cpu, ARM_ARCH_XSCALE, N_("use -mcpu=xscale")},
  {"miwmmxt",	 NULL, &legacy_cpu, ARM_ARCH_IWMMXT, N_("use -mcpu=iwmmxt")},
  {"mall",	 NULL, &legacy_cpu, ARM_ANY,      N_("use -mcpu=all")},

  /* Architecture variants -- don't add any more to this list either.  */
  {"mv2",	 NULL, &legacy_cpu, ARM_ARCH_V2,  N_("use -march=armv2")},
  {"marmv2",	 NULL, &legacy_cpu, ARM_ARCH_V2,  N_("use -march=armv2")},
  {"mv2a",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -march=armv2a")},
  {"marmv2a",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -march=armv2a")},
  {"mv3",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -march=armv3")},
  {"marmv3",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -march=armv3")},
  {"mv3m",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -march=armv3m")},
  {"marmv3m",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -march=armv3m")},
  {"mv4",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -march=armv4")},
  {"marmv4",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -march=armv4")},
  {"mv4t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -march=armv4t")},
  {"marmv4t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -march=armv4t")},
  {"mv5",	 NULL, &legacy_cpu, ARM_ARCH_V5,  N_("use -march=armv5")},
  {"marmv5",	 NULL, &legacy_cpu, ARM_ARCH_V5,  N_("use -march=armv5")},
  {"mv5t",	 NULL, &legacy_cpu, ARM_ARCH_V5T, N_("use -march=armv5t")},
  {"marmv5t",	 NULL, &legacy_cpu, ARM_ARCH_V5T, N_("use -march=armv5t")},
  {"mv5e",	 NULL, &legacy_cpu, ARM_ARCH_V5TE, N_("use -march=armv5te")},
  {"marmv5e",	 NULL, &legacy_cpu, ARM_ARCH_V5TE, N_("use -march=armv5te")},

  /* Floating point variants -- don't add any more to this list either.  */
  {"mfpe-old", NULL, &legacy_fpu, FPU_ARCH_FPE, N_("use -mfpu=fpe")},
  {"mfpa10",   NULL, &legacy_fpu, FPU_ARCH_FPA, N_("use -mfpu=fpa10")},
  {"mfpa11",   NULL, &legacy_fpu, FPU_ARCH_FPA, N_("use -mfpu=fpa11")},
  {"mno-fpu",  NULL, &legacy_fpu, 0,
   N_("use either -mfpu=softfpa or -mfpu=softvfp")},

  {NULL, NULL, NULL, 0, NULL}
};

struct arm_cpu_option_table
{
  char *name;
  int   value;
  /* For some CPUs we assume an FPU unless the user explicitly sets
     -mfpu=...  */
  int   default_fpu;
};

/* This list should, at a minimum, contain all the cpu names
   recognized by GCC.  */
static struct arm_cpu_option_table arm_cpus[] =
{
  {"all",		ARM_ANY,	 FPU_ARCH_FPA},
  {"arm1",		ARM_ARCH_V1,	 FPU_ARCH_FPA},
  {"arm2",		ARM_ARCH_V2,	 FPU_ARCH_FPA},
  {"arm250",		ARM_ARCH_V2S,	 FPU_ARCH_FPA},
  {"arm3",		ARM_ARCH_V2S,	 FPU_ARCH_FPA},
  {"arm6",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm60",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm600",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm610",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm620",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7m",		ARM_ARCH_V3M,	 FPU_ARCH_FPA},
  {"arm7d",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7dm",		ARM_ARCH_V3M,	 FPU_ARCH_FPA},
  {"arm7di",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7dmi",		ARM_ARCH_V3M,	 FPU_ARCH_FPA},
  {"arm70",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm700",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm700i",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm710",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm710t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm720",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm720t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm740t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm710c",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7100",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7500",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7500fe",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
d11866 1
a11866 1
     should really set the FPU type explicitly.  */
d11868 1
a11868 1
  {"arm9e",		ARM_ARCH_V5TE,   FPU_ARCH_VFP_V2},
d11873 1
a11873 1
  {"arm946e",		ARM_ARCH_V5TE,   FPU_ARCH_VFP_V2},
d11883 8
a11890 8
  {"arm1136js",		ARM_ARCH_V6,     FPU_NONE},
  {"arm1136j-s",	ARM_ARCH_V6,     FPU_NONE},
  {"arm1136jfs",	ARM_ARCH_V6,     FPU_ARCH_VFP_V2},
  {"arm1136jf-s",	ARM_ARCH_V6,     FPU_ARCH_VFP_V2},
  {"mpcore",		ARM_ARCH_V6K,    FPU_ARCH_VFP_V2},
  {"mpcorenovfp",	ARM_ARCH_V6K,    FPU_NONE},
  {"arm1176jz-s",	ARM_ARCH_V6ZK,   FPU_NONE},
  {"arm1176jzf-s",	ARM_ARCH_V6ZK,   FPU_ARCH_VFP_V2},
d11901 1
a11901 1459
struct arm_arch_option_table
{
  char *name;
  int   value;
  int   default_fpu;
};

/* This list should, at a minimum, contain all the architecture names
   recognized by GCC.  */
static struct arm_arch_option_table arm_archs[] =
{
  {"all",		ARM_ANY,	 FPU_ARCH_FPA},
  {"armv1",		ARM_ARCH_V1,	 FPU_ARCH_FPA},
  {"armv2",		ARM_ARCH_V2,	 FPU_ARCH_FPA},
  {"armv2a",		ARM_ARCH_V2S,	 FPU_ARCH_FPA},
  {"armv2s",		ARM_ARCH_V2S,	 FPU_ARCH_FPA},
  {"armv3",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"armv3m",		ARM_ARCH_V3M,	 FPU_ARCH_FPA},
  {"armv4",		ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"armv4xm",		ARM_ARCH_V4xM,	 FPU_ARCH_FPA},
  {"armv4t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"armv4txm",		ARM_ARCH_V4TxM,	 FPU_ARCH_FPA},
  {"armv5",		ARM_ARCH_V5,	 FPU_ARCH_VFP},
  {"armv5t",		ARM_ARCH_V5T,	 FPU_ARCH_VFP},
  {"armv5txm",		ARM_ARCH_V5TxM,	 FPU_ARCH_VFP},
  {"armv5te",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP},
  {"armv5texp",		ARM_ARCH_V5TExP, FPU_ARCH_VFP},
  {"armv5tej",		ARM_ARCH_V5TEJ,  FPU_ARCH_VFP},
  {"armv6",             ARM_ARCH_V6,     FPU_ARCH_VFP},
  {"armv6j",            ARM_ARCH_V6,     FPU_ARCH_VFP},
  {"armv6k",            ARM_ARCH_V6K,    FPU_ARCH_VFP},
  {"armv6z",            ARM_ARCH_V6Z,    FPU_ARCH_VFP},
  {"armv6zk",           ARM_ARCH_V6ZK,   FPU_ARCH_VFP},
  {"xscale",		ARM_ARCH_XSCALE, FPU_ARCH_VFP},
  {"iwmmxt",		ARM_ARCH_IWMMXT, FPU_ARCH_VFP},
  {NULL, 0, 0}
};

/* ISA extensions in the co-processor space.  */
struct arm_arch_extension_table
{
  char *name;
  int value;
};

static struct arm_arch_extension_table arm_extensions[] =
{
  {"maverick",		ARM_CEXT_MAVERICK},
  {"xscale",		ARM_CEXT_XSCALE},
  {"iwmmxt",		ARM_CEXT_IWMMXT},
  {NULL,		0}
};

struct arm_fpu_option_table
{
  char *name;
  int   value;
};

/* This list should, at a minimum, contain all the fpu names
   recognized by GCC.  */
static struct arm_fpu_option_table arm_fpus[] =
{
  {"softfpa",		FPU_NONE},
  {"fpe",		FPU_ARCH_FPE},
  {"fpe2",		FPU_ARCH_FPE},
  {"fpe3",		FPU_ARCH_FPA},	/* Third release supports LFM/SFM.  */
  {"fpa",		FPU_ARCH_FPA},
  {"fpa10",		FPU_ARCH_FPA},
  {"fpa11",		FPU_ARCH_FPA},
  {"arm7500fe",		FPU_ARCH_FPA},
  {"softvfp",		FPU_ARCH_VFP},
  {"softvfp+vfp",	FPU_ARCH_VFP_V2},
  {"vfp",		FPU_ARCH_VFP_V2},
  {"vfp9",		FPU_ARCH_VFP_V2},
  {"vfp10",		FPU_ARCH_VFP_V2},
  {"vfp10-r0",		FPU_ARCH_VFP_V1},
  {"vfpxd",		FPU_ARCH_VFP_V1xD},
  {"arm1020t",		FPU_ARCH_VFP_V1},
  {"arm1020e",		FPU_ARCH_VFP_V2},
  {"arm1136jfs",	FPU_ARCH_VFP_V2},
  {"arm1136jf-s",	FPU_ARCH_VFP_V2},
  {"maverick",		FPU_ARCH_MAVERICK},
  {NULL, 0}
};

struct arm_float_abi_option_table
{
  char *name;
  int value;
};

static struct arm_float_abi_option_table arm_float_abis[] =
{
  {"hard",	ARM_FLOAT_ABI_HARD},
  {"softfp",	ARM_FLOAT_ABI_SOFTFP},
  {"soft",	ARM_FLOAT_ABI_SOFT},
  {NULL, 0}
};

struct arm_eabi_option_table
{
  char *name;
  unsigned int value;
};

#ifdef OBJ_ELF
/* We only know how to output GNU and ver 4 (AAELF) formats.  */
static struct arm_eabi_option_table arm_eabis[] =
{
  {"gnu",	EF_ARM_EABI_UNKNOWN},
  {"4",		EF_ARM_EABI_VER4},
  {NULL, 0}
};
#endif

struct arm_long_option_table
{
  char * option;		/* Substring to match.  */
  char * help;			/* Help information.  */
  int (* func) (char * subopt);	/* Function to decode sub-option.  */
  char * deprecated;		/* If non-null, print this message.  */
};

static int
arm_parse_extension (char * str, int * opt_p)
{
  while (str != NULL && *str != 0)
    {
      struct arm_arch_extension_table * opt;
      char * ext;
      int optlen;

      if (*str != '+')
	{
	  as_bad (_("invalid architectural extension"));
	  return 0;
	}

      str++;
      ext = strchr (str, '+');

      if (ext != NULL)
	optlen = ext - str;
      else
	optlen = strlen (str);

      if (optlen == 0)
	{
	  as_bad (_("missing architectural extension"));
	  return 0;
	}

      for (opt = arm_extensions; opt->name != NULL; opt++)
	if (strncmp (opt->name, str, optlen) == 0)
	  {
	    *opt_p |= opt->value;
	    break;
	  }

      if (opt->name == NULL)
	{
	  as_bad (_("unknown architectural extnsion `%s'"), str);
	  return 0;
	}

      str = ext;
    };

  return 1;
}

static int
arm_parse_cpu (char * str)
{
  struct arm_cpu_option_table * opt;
  char * ext = strchr (str, '+');
  int optlen;

  if (ext != NULL)
    optlen = ext - str;
  else
    optlen = strlen (str);

  if (optlen == 0)
    {
      as_bad (_("missing cpu name `%s'"), str);
      return 0;
    }

  for (opt = arm_cpus; opt->name != NULL; opt++)
    if (strncmp (opt->name, str, optlen) == 0)
      {
	mcpu_cpu_opt = opt->value;
	mcpu_fpu_opt = opt->default_fpu;

	if (ext != NULL)
	  return arm_parse_extension (ext, &mcpu_cpu_opt);

	return 1;
      }

  as_bad (_("unknown cpu `%s'"), str);
  return 0;
}

static int
arm_parse_arch (char * str)
{
  struct arm_arch_option_table *opt;
  char *ext = strchr (str, '+');
  int optlen;

  if (ext != NULL)
    optlen = ext - str;
  else
    optlen = strlen (str);

  if (optlen == 0)
    {
      as_bad (_("missing architecture name `%s'"), str);
      return 0;
    }


  for (opt = arm_archs; opt->name != NULL; opt++)
    if (streq (opt->name, str))
      {
	march_cpu_opt = opt->value;
	march_fpu_opt = opt->default_fpu;

	if (ext != NULL)
	  return arm_parse_extension (ext, &march_cpu_opt);

	return 1;
      }

  as_bad (_("unknown architecture `%s'\n"), str);
  return 0;
}

static int
arm_parse_fpu (char * str)
{
  struct arm_fpu_option_table * opt;

  for (opt = arm_fpus; opt->name != NULL; opt++)
    if (streq (opt->name, str))
      {
	mfpu_opt = opt->value;
	return 1;
      }

  as_bad (_("unknown floating point format `%s'\n"), str);
  return 0;
}

static int
arm_parse_float_abi (char * str)
{
  struct arm_float_abi_option_table * opt;

  for (opt = arm_float_abis; opt->name != NULL; opt++)
    if (streq (opt->name, str))
      {
	mfloat_abi_opt = opt->value;
	return 1;
      }

  as_bad (_("unknown floating point abi `%s'\n"), str);
  return 0;
}

#ifdef OBJ_ELF
static int
arm_parse_eabi (char * str)
{
  struct arm_eabi_option_table *opt;

  for (opt = arm_eabis; opt->name != NULL; opt++)
    if (streq (opt->name, str))
      {
	meabi_flags = opt->value;
	return 1;
      }
  as_bad (_("unknown EABI `%s'\n"), str);
  return 0;
}
#endif

struct arm_long_option_table arm_long_opts[] =
{
  {"mcpu=", N_("<cpu name>\t  assemble for CPU <cpu name>"),
   arm_parse_cpu, NULL},
  {"march=", N_("<arch name>\t  assemble for architecture <arch name>"),
   arm_parse_arch, NULL},
  {"mfpu=", N_("<fpu name>\t  assemble for FPU architecture <fpu name>"),
   arm_parse_fpu, NULL},
  {"mfloat-abi=", N_("<abi>\t  assemble for floating point ABI <abi>"),
   arm_parse_float_abi, NULL},
#ifdef OBJ_ELF
  {"meabi=", N_("<ver>\t  assemble for eabi version <ver>"),
   arm_parse_eabi, NULL},
#endif
  {NULL, NULL, 0, NULL}
};

int
md_parse_option (int c, char * arg)
{
  struct arm_option_table *opt;
  struct arm_long_option_table *lopt;

  switch (c)
    {
#ifdef OPTION_EB
    case OPTION_EB:
      target_big_endian = 1;
      break;
#endif

#ifdef OPTION_EL
    case OPTION_EL:
      target_big_endian = 0;
      break;
#endif

    case 'a':
      /* Listing option.  Just ignore these, we don't support additional
	 ones.  */
      return 0;

    default:
      for (opt = arm_opts; opt->option != NULL; opt++)
	{
	  if (c == opt->option[0]
	      && ((arg == NULL && opt->option[1] == 0)
		  || streq (arg, opt->option + 1)))
	    {
#if WARN_DEPRECATED
	      /* If the option is deprecated, tell the user.  */
	      if (opt->deprecated != NULL)
		as_tsktsk (_("option `-%c%s' is deprecated: %s"), c,
			   arg ? arg : "", _(opt->deprecated));
#endif

	      if (opt->var != NULL)
		*opt->var = opt->value;

	      return 1;
	    }
	}

      for (lopt = arm_long_opts; lopt->option != NULL; lopt++)
	{
	  /* These options are expected to have an argument.  */
	  if (c == lopt->option[0]
	      && arg != NULL
	      && strncmp (arg, lopt->option + 1,
			  strlen (lopt->option + 1)) == 0)
	    {
#if WARN_DEPRECATED
	      /* If the option is deprecated, tell the user.  */
	      if (lopt->deprecated != NULL)
		as_tsktsk (_("option `-%c%s' is deprecated: %s"), c, arg,
			   _(lopt->deprecated));
#endif

	      /* Call the sup-option parser.  */
	      return lopt->func (arg + strlen (lopt->option) - 1);
	    }
	}

      return 0;
    }

  return 1;
}

void
md_show_usage (FILE * fp)
{
  struct arm_option_table *opt;
  struct arm_long_option_table *lopt;

  fprintf (fp, _(" ARM-specific assembler options:\n"));

  for (opt = arm_opts; opt->option != NULL; opt++)
    if (opt->help != NULL)
      fprintf (fp, "  -%-23s%s\n", opt->option, _(opt->help));

  for (lopt = arm_long_opts; lopt->option != NULL; lopt++)
    if (lopt->help != NULL)
      fprintf (fp, "  -%s%s\n", lopt->option, _(lopt->help));

#ifdef OPTION_EB
  fprintf (fp, _("\
  -EB                     assemble code for a big-endian cpu\n"));
#endif

#ifdef OPTION_EL
  fprintf (fp, _("\
  -EL                     assemble code for a little-endian cpu\n"));
#endif
}

/* This fix_new is called by cons via TC_CONS_FIX_NEW.  */

void
cons_fix_new_arm (fragS *       frag,
		  int           where,
		  int           size,
		  expressionS * exp)
{
  bfd_reloc_code_real_type type;
  int pcrel = 0;

  /* Pick a reloc.
     FIXME: @@@@ Should look at CPU word size.  */
  switch (size)
    {
    case 1:
      type = BFD_RELOC_8;
      break;
    case 2:
      type = BFD_RELOC_16;
      break;
    case 4:
    default:
      type = BFD_RELOC_32;
      break;
    case 8:
      type = BFD_RELOC_64;
      break;
    }

  fix_new_exp (frag, where, (int) size, exp, pcrel, type);
}

/* A good place to do this, although this was probably not intended
   for this kind of use.  We need to dump the literal pool before
   references are made to a null symbol pointer.  */

void
arm_cleanup (void)
{
  literal_pool * pool;

  for (pool = list_of_pools; pool; pool = pool->next)
    {
      /* Put it at the end of the relevent section.  */
      subseg_set (pool->section, pool->sub_section);
#ifdef OBJ_ELF
      arm_elf_change_section ();
#endif
      s_ltorg (0);
    }
}

void
arm_start_line_hook (void)
{
  last_label_seen = NULL;
}

void
arm_frob_label (symbolS * sym)
{
  last_label_seen = sym;

  ARM_SET_THUMB (sym, thumb_mode);

#if defined OBJ_COFF || defined OBJ_ELF
  ARM_SET_INTERWORK (sym, support_interwork);
#endif

  /* Note - do not allow local symbols (.Lxxx) to be labeled
     as Thumb functions.  This is because these labels, whilst
     they exist inside Thumb code, are not the entry points for
     possible ARM->Thumb calls.  Also, these labels can be used
     as part of a computed goto or switch statement.  eg gcc
     can generate code that looks like this:

                ldr  r2, [pc, .Laaa]
                lsl  r3, r3, #2
                ldr  r2, [r3, r2]
                mov  pc, r2

       .Lbbb:  .word .Lxxx
       .Lccc:  .word .Lyyy
       ..etc...
       .Laaa:   .word Lbbb

     The first instruction loads the address of the jump table.
     The second instruction converts a table index into a byte offset.
     The third instruction gets the jump address out of the table.
     The fourth instruction performs the jump.

     If the address stored at .Laaa is that of a symbol which has the
     Thumb_Func bit set, then the linker will arrange for this address
     to have the bottom bit set, which in turn would mean that the
     address computation performed by the third instruction would end
     up with the bottom bit set.  Since the ARM is capable of unaligned
     word loads, the instruction would then load the incorrect address
     out of the jump table, and chaos would ensue.  */
  if (label_is_thumb_function_name
      && (S_GET_NAME (sym)[0] != '.' || S_GET_NAME (sym)[1] != 'L')
      && (bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)
    {
      /* When the address of a Thumb function is taken the bottom
	 bit of that address should be set.  This will allow
	 interworking between Arm and Thumb functions to work
	 correctly.  */

      THUMB_SET_FUNC (sym, 1);

      label_is_thumb_function_name = FALSE;
    }
}

/* Adjust the symbol table.  This marks Thumb symbols as distinct from
   ARM ones.  */

void
arm_adjust_symtab (void)
{
#ifdef OBJ_COFF
  symbolS * sym;

  for (sym = symbol_rootP; sym != NULL; sym = symbol_next (sym))
    {
      if (ARM_IS_THUMB (sym))
	{
	  if (THUMB_IS_FUNC (sym))
	    {
	      /* Mark the symbol as a Thumb function.  */
	      if (   S_GET_STORAGE_CLASS (sym) == C_STAT
		  || S_GET_STORAGE_CLASS (sym) == C_LABEL)  /* This can happen!  */
		S_SET_STORAGE_CLASS (sym, C_THUMBSTATFUNC);

	      else if (S_GET_STORAGE_CLASS (sym) == C_EXT)
		S_SET_STORAGE_CLASS (sym, C_THUMBEXTFUNC);
	      else
		as_bad (_("%s: unexpected function type: %d"),
			S_GET_NAME (sym), S_GET_STORAGE_CLASS (sym));
	    }
	  else switch (S_GET_STORAGE_CLASS (sym))
	    {
	    case C_EXT:
	      S_SET_STORAGE_CLASS (sym, C_THUMBEXT);
	      break;
	    case C_STAT:
	      S_SET_STORAGE_CLASS (sym, C_THUMBSTAT);
	      break;
	    case C_LABEL:
	      S_SET_STORAGE_CLASS (sym, C_THUMBLABEL);
	      break;
	    default:
	      /* Do nothing.  */
	      break;
	    }
	}

      if (ARM_IS_INTERWORK (sym))
	coffsymbol (symbol_get_bfdsym (sym))->native->u.syment.n_flags = 0xFF;
    }
#endif
#ifdef OBJ_ELF
  symbolS * sym;
  char      bind;

  for (sym = symbol_rootP; sym != NULL; sym = symbol_next (sym))
    {
      if (ARM_IS_THUMB (sym))
	{
	  elf_symbol_type * elf_sym;

	  elf_sym = elf_symbol (symbol_get_bfdsym (sym));
	  bind = ELF_ST_BIND (elf_sym);

	  /* If it's a .thumb_func, declare it as so,
	     otherwise tag label as .code 16.  */
	  if (THUMB_IS_FUNC (sym))
	    elf_sym->internal_elf_sym.st_info =
	      ELF_ST_INFO (bind, STT_ARM_TFUNC);
	  else
	    elf_sym->internal_elf_sym.st_info =
	      ELF_ST_INFO (bind, STT_ARM_16BIT);
	}
    }
#endif
}

int
arm_data_in_code (void)
{
  if (thumb_mode && ! strncmp (input_line_pointer + 1, "data:", 5))
    {
      *input_line_pointer = '/';
      input_line_pointer += 5;
      *input_line_pointer = 0;
      return 1;
    }

  return 0;
}

char *
arm_canonicalize_symbol_name (char * name)
{
  int len;

  if (thumb_mode && (len = strlen (name)) > 5
      && streq (name + len - 5, "/data"))
    *(name + len - 5) = 0;

  return name;
}

#if defined OBJ_COFF || defined OBJ_ELF
void
arm_validate_fix (fixS * fixP)
{
  /* If the destination of the branch is a defined symbol which does not have
     the THUMB_FUNC attribute, then we must be calling a function which has
     the (interfacearm) attribute.  We look for the Thumb entry point to that
     function and change the branch to refer to that function instead.  */
  if (fixP->fx_r_type == BFD_RELOC_THUMB_PCREL_BRANCH23
      && fixP->fx_addsy != NULL
      && S_IS_DEFINED (fixP->fx_addsy)
      && ! THUMB_IS_FUNC (fixP->fx_addsy))
    {
      fixP->fx_addsy = find_real_start (fixP->fx_addsy);
    }
}
#endif

int
arm_force_relocation (struct fix * fixp)
{
#if defined (OBJ_COFF) && defined (TE_PE)
  if (fixp->fx_r_type == BFD_RELOC_RVA)
    return 1;
#endif
#ifdef OBJ_ELF
  if (fixp->fx_r_type == BFD_RELOC_ARM_PCREL_BRANCH
      || fixp->fx_r_type == BFD_RELOC_ARM_PCREL_BLX
      || fixp->fx_r_type == BFD_RELOC_THUMB_PCREL_BLX
      || fixp->fx_r_type == BFD_RELOC_THUMB_PCREL_BRANCH23)
    return 1;
#endif

  /* Resolve these relocations even if the symbol is extern or weak.  */
  if (fixp->fx_r_type == BFD_RELOC_ARM_IMMEDIATE
      || fixp->fx_r_type == BFD_RELOC_ARM_OFFSET_IMM
      || fixp->fx_r_type == BFD_RELOC_ARM_ADRL_IMMEDIATE)
    return 0;

  return generic_force_reloc (fixp);
}

#ifdef OBJ_COFF
/* This is a little hack to help the gas/arm/adrl.s test.  It prevents
   local labels from being added to the output symbol table when they
   are used with the ADRL pseudo op.  The ADRL relocation should always
   be resolved before the binbary is emitted, so it is safe to say that
   it is adjustable.  */

bfd_boolean
arm_fix_adjustable (fixS * fixP)
{
  if (fixP->fx_r_type == BFD_RELOC_ARM_ADRL_IMMEDIATE)
    return 1;
  return 0;
}
#endif

#ifdef OBJ_ELF
/* Relocations against Thumb function names must be left unadjusted,
   so that the linker can use this information to correctly set the
   bottom bit of their addresses.  The MIPS version of this function
   also prevents relocations that are mips-16 specific, but I do not
   know why it does this.

   FIXME:
   There is one other problem that ought to be addressed here, but
   which currently is not:  Taking the address of a label (rather
   than a function) and then later jumping to that address.  Such
   addresses also ought to have their bottom bit set (assuming that
   they reside in Thumb code), but at the moment they will not.  */

bfd_boolean
arm_fix_adjustable (fixS * fixP)
{
  if (fixP->fx_addsy == NULL)
    return 1;

  if (THUMB_IS_FUNC (fixP->fx_addsy)
      && fixP->fx_subsy == NULL)
    return 0;

  /* We need the symbol name for the VTABLE entries.  */
  if (   fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 0;

  /* Don't allow symbols to be discarded on GOT related relocs.  */
  if (fixP->fx_r_type == BFD_RELOC_ARM_PLT32
      || fixP->fx_r_type == BFD_RELOC_ARM_GOT32
      || fixP->fx_r_type == BFD_RELOC_ARM_GOTOFF
      || fixP->fx_r_type == BFD_RELOC_ARM_TARGET2)
    return 0;

  return 1;
}

const char *
elf32_arm_target_format (void)
{
#ifdef TE_SYMBIAN
  return (target_big_endian
	  ? "elf32-bigarm-symbian"
	  : "elf32-littlearm-symbian");
#elif defined (TE_VXWORKS)
  return (target_big_endian
	  ? "elf32-bigarm-vxworks"
	  : "elf32-littlearm-vxworks");
#else
  if (target_big_endian)
    return "elf32-bigarm";
  else
    return "elf32-littlearm";
#endif
}

void
armelf_frob_symbol (symbolS * symp,
		    int *     puntp)
{
  elf_frob_symbol (symp, puntp);
}

static void
s_arm_elf_cons (int nbytes)
{
  expressionS exp;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  if (is_it_end_of_statement ())
    {
      demand_empty_rest_of_line ();
      return;
    }

#ifdef md_cons_align
  md_cons_align (nbytes);
#endif

  mapping_state (MAP_DATA);
  do
    {
      bfd_reloc_code_real_type reloc;

      expression (& exp);

      if (exp.X_op == O_symbol
	  && * input_line_pointer == '('
	  && (reloc = arm_parse_reloc ()) != BFD_RELOC_UNUSED)
	{
	  reloc_howto_type *howto = bfd_reloc_type_lookup (stdoutput, reloc);
	  int size = bfd_get_reloc_size (howto);

	  if (size > nbytes)
	    as_bad ("%s relocations do not fit in %d bytes",
		    howto->name, nbytes);
	  else
	    {
	      char *p = frag_more ((int) nbytes);
	      int offset = nbytes - size;

	      fix_new_exp (frag_now, p - frag_now->fr_literal + offset, size,
			   &exp, 0, reloc);
	    }
	}
      else
	emit_expr (&exp, (unsigned int) nbytes);
    }
  while (*input_line_pointer++ == ',');

  /* Put terminator back into stream.  */
  input_line_pointer --;
  demand_empty_rest_of_line ();
}


/* Parse a .rel31 directive.  */

static void
s_arm_rel31 (int ignored ATTRIBUTE_UNUSED)
{
  expressionS exp;
  char *p;
  valueT highbit;

  SKIP_WHITESPACE ();

  highbit = 0;
  if (*input_line_pointer == '1')
    highbit = 0x80000000;
  else if (*input_line_pointer != '0')
    as_bad (_("expected 0 or 1"));

  input_line_pointer++;
  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    as_bad (_("missing comma"));
  input_line_pointer++;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

#ifdef md_cons_align
  md_cons_align (4);
#endif

  mapping_state (MAP_DATA);

  expression (&exp);

  p = frag_more (4);
  md_number_to_chars (p, highbit, 4);
  fix_new_arm (frag_now, p - frag_now->fr_literal, 4, &exp, 1,
	       BFD_RELOC_ARM_PREL31);

  demand_empty_rest_of_line ();
}

/* Code to deal with unwinding tables.  */

static void add_unwind_adjustsp (offsetT);

/* Switch to section NAME and create section if necessary.  It's
   rather ugly that we have to manipulate input_line_pointer but I
   don't see any other way to accomplish the same thing without
   changing obj-elf.c (which may be the Right Thing, in the end).
   Copied from tc-ia64.c.  */

static void
set_section (char *name)
{
  char *saved_input_line_pointer;

  saved_input_line_pointer = input_line_pointer;
  input_line_pointer = name;
  obj_elf_section (0);
  input_line_pointer = saved_input_line_pointer;
}

/* Cenerate and deferred unwind frame offset.  */

static void
flush_pending_unwind (void)
{
  offsetT offset;

  offset = unwind.pending_offset;
  unwind.pending_offset = 0;
  if (offset != 0)
    add_unwind_adjustsp (offset);
}

/* Add an opcode to this list for this function.  Two-byte opcodes should
   be passed as op[0] << 8 | op[1].  The list of opcodes is built in reverse
   order.  */

static void
add_unwind_opcode (valueT op, int length)
{
  /* Add any deferred stack adjustment.  */
  if (unwind.pending_offset)
    flush_pending_unwind ();

  unwind.sp_restored = 0;

  if (unwind.opcode_count + length > unwind.opcode_alloc)
    {
      unwind.opcode_alloc += ARM_OPCODE_CHUNK_SIZE;
      if (unwind.opcodes)
	unwind.opcodes = xrealloc (unwind.opcodes,
				   unwind.opcode_alloc);
      else
	unwind.opcodes = xmalloc (unwind.opcode_alloc);
    }
  while (length > 0)
    {
      length--;
      unwind.opcodes[unwind.opcode_count] = op & 0xff;
      op >>= 8;
      unwind.opcode_count++;
    }
}

/* Add unwind opcodes to adjust the stack pointer.  */

static void
add_unwind_adjustsp (offsetT offset)
{
  valueT op;

  if (offset > 0x200)
    {
      /* We need at most 5 bytes to hold a 32-bit value in a uleb128.  */
      char bytes[5];
      int n;
      valueT o;

      /* Long form: 0xb2, uleb128.  */
      /* This might not fit in a word so add the individual bytes,
	 remembering the list is built in reverse order.  */
      o = (valueT) ((offset - 0x204) >> 2);
      if (o == 0)
	add_unwind_opcode (0, 1);

      /* Calculate the uleb128 encoding of the offset.  */
      n = 0;
      while (o)
	{
	  bytes[n] = o & 0x7f;
	  o >>= 7;
	  if (o)
	    bytes[n] |= 0x80;
	  n++;
	}
      /* Add the insn.  */
      for (; n; n--)
	add_unwind_opcode (bytes[n - 1], 1);
      add_unwind_opcode (0xb2, 1);
    }
  else if (offset > 0x100)
    {
      /* Two short opcodes.  */
      add_unwind_opcode (0x3f, 1);
      op = (offset - 0x104) >> 2;
      add_unwind_opcode (op, 1);
    }
  else if (offset > 0)
    {
      /* Short opcode.  */
      op = (offset - 4) >> 2;
      add_unwind_opcode (op, 1);
    }
  else if (offset < 0)
    {
      offset = -offset;
      while (offset > 0x100)
	{
	  add_unwind_opcode (0x7f, 1);
	  offset -= 0x100;
	}
      op = ((offset - 4) >> 2) | 0x40;
      add_unwind_opcode (op, 1);
    }
}

/* Finish the list of unwind opcodes for this function.  */
static void
finish_unwind_opcodes (void)
{
  valueT op;

  if (unwind.fp_used)
    {
      /* Adjust sp as neccessary.  */
      unwind.pending_offset += unwind.fp_offset - unwind.frame_size;
      flush_pending_unwind ();

      /* After restoring sp from the frame pointer.  */
      op = 0x90 | unwind.fp_reg;
      add_unwind_opcode (op, 1);
    }
  else
    flush_pending_unwind ();
}


/* Start an exception table entry.  If idx is nonzero this is an index table
   entry.  */

static void
start_unwind_section (const segT text_seg, int idx)
{
  const char * text_name;
  const char * prefix;
  const char * prefix_once;
  size_t prefix_len;
  size_t text_len;
  char * sec_name;
  size_t sec_name_len;

  if (idx)
    {
      prefix = ELF_STRING_ARM_unwind;
      prefix_once = ELF_STRING_ARM_unwind_once;
    }
  else
    {
      prefix = ELF_STRING_ARM_unwind_info;
      prefix_once = ELF_STRING_ARM_unwind_info_once;
    }

  text_name = segment_name (text_seg);
  if (streq (text_name, ".text"))
    text_name = "";

  if (strncmp (text_name, ".gnu.linkonce.t.",
	       strlen (".gnu.linkonce.t.")) == 0)
    {
      prefix = prefix_once;
      text_name += strlen (".gnu.linkonce.t.");
    }

  prefix_len = strlen (prefix);
  text_len = strlen (text_name);
  sec_name_len = prefix_len + text_len;
  sec_name = alloca (sec_name_len + 1);
  memcpy (sec_name, prefix, prefix_len);
  memcpy (sec_name + prefix_len, text_name, text_len);
  sec_name[prefix_len + text_len] = '\0';

  /* Handle COMDAT group.  */
  if (prefix != prefix_once && (text_seg->flags & SEC_LINK_ONCE) != 0)
    {
      char *section;
      size_t len, group_name_len;
      const char *group_name = elf_group_name (text_seg);

      if (group_name == NULL)
        {
          as_bad ("Group section `%s' has no group signature",
                  segment_name (text_seg));
          ignore_rest_of_line ();
          return;
        }
      /* We have to construct a fake section directive.  */
      group_name_len = strlen (group_name);
      if (idx)
	prefix_len = 13;
      else
	prefix_len = 16;

      len = (sec_name_len
             + prefix_len             /* ,"aG",%sectiontype,  */
             + group_name_len         /* ,group_name  */
             + 7);                    /* ,comdat  */

      section = alloca (len + 1);
      memcpy (section, sec_name, sec_name_len);
      if (idx)
	  memcpy (section + sec_name_len, ",\"aG\",%exidx,", 13);
      else
	  memcpy (section + sec_name_len, ",\"aG\",%progbits,", 16);
      memcpy (section + sec_name_len + prefix_len, group_name, group_name_len);
      memcpy (section + len - 7, ",comdat", 7);
      section [len] = '\0';
      set_section (section);
    }
  else
    {
      set_section (sec_name);
      bfd_set_section_flags (stdoutput, now_seg,
			     SEC_LOAD | SEC_ALLOC | SEC_READONLY);
    }

  /* Set the setion link for index tables.  */
  if (idx)
    elf_linked_to_section (now_seg) = text_seg;
}


/* Start an unwind table entry.  HAVE_DATA is nonzero if we have additional
   personality routine data.  Returns zero, or the index table value for
   and inline entry.  */

static valueT
create_unwind_entry (int have_data)
{
  int size;
  addressT where;
  unsigned char *ptr;
  /* The current word of data.  */
  valueT data;
  /* The number of bytes left in this word.  */
  int n;

  finish_unwind_opcodes ();

  /* Remember the current text section.  */
  unwind.saved_seg = now_seg;
  unwind.saved_subseg = now_subseg;

  start_unwind_section (now_seg, 0);

  if (unwind.personality_routine == NULL)
    {
      if (unwind.personality_index == -2)
	{
	  if (have_data)
	    as_bad (_("handerdata in cantunwind frame"));
	  return 1; /* EXIDX_CANTUNWIND.  */
	}

      /* Use a default personality routine if none is specified.  */
      if (unwind.personality_index == -1)
	{
	  if (unwind.opcode_count > 3)
	    unwind.personality_index = 1;
	  else
	    unwind.personality_index = 0;
	}

      /* Space for the personality routine entry.  */
      if (unwind.personality_index == 0)
	{
	  if (unwind.opcode_count > 3)
	    as_bad (_("too many unwind opcodes for personality routine 0"));

	  if (!have_data)
	    {
	      /* All the data is inline in the index table.  */
	      data = 0x80;
	      n = 3;
	      while (unwind.opcode_count > 0)
		{
		  unwind.opcode_count--;
		  data = (data << 8) | unwind.opcodes[unwind.opcode_count];
		  n--;
		}

	      /* Pad with "finish" opcodes.  */
	      while (n--)
		data = (data << 8) | 0xb0;

	      return data;
	    }
	  size = 0;
	}
      else
	/* We get two opcodes "free" in the first word.  */
	size = unwind.opcode_count - 2;
    }
  else
    /* An extra byte is required for the opcode count.  */
    size = unwind.opcode_count + 1;

  size = (size + 3) >> 2;
  if (size > 0xff)
    as_bad (_("too many unwind opcodes"));

  frag_align (2, 0, 0);
  record_alignment (now_seg, 2);
  unwind.table_entry = expr_build_dot ();

  /* Allocate the table entry.  */
  ptr = frag_more ((size << 2) + 4);
  where = frag_now_fix () - ((size << 2) + 4);

  switch (unwind.personality_index)
    {
    case -1:
      /* ??? Should this be a PLT generating relocation?  */
      /* Custom personality routine.  */
      fix_new (frag_now, where, 4, unwind.personality_routine, 0, 1,
	       BFD_RELOC_ARM_PREL31);
      where += 4;
      ptr += 4;

      /* Set the first byte to the number of additional words.  */
      data = size - 1;
      n = 3;
      break;

    /* ABI defined personality routines.  */
    /* TODO: Emit R_ARM_NONE to the personality routine.  */
    case 0:
      /* Three opcodes bytes are packed into the first word.  */
      data = 0x80;
      n = 3;
      break;

    case 1:
    case 2:
      /* The size and first two opcode bytes go in the first word.  */
      data = ((0x80 + unwind.personality_index) << 8) | size;
      n = 2;
      break;

    default:
      /* Should never happen.  */
      abort ();
    }

  /* Pack the opcodes into words (MSB first), reversing the list at the same
     time.  */
  while (unwind.opcode_count > 0)
    {
      if (n == 0)
	{
	  md_number_to_chars (ptr, data, 4);
	  ptr += 4;
	  n = 4;
	  data = 0;
	}
      unwind.opcode_count--;
      n--;
      data = (data << 8) | unwind.opcodes[unwind.opcode_count];
    }

  /* Finish off the last word.  */
  if (n < 4)
    {
      /* Pad with "finish" opcodes.  */
      while (n--)
	data = (data << 8) | 0xb0;

      md_number_to_chars (ptr, data, 4);
    }

  if (!have_data)
    {
      /* Add an empty descriptor if there is no user-specified data.   */
      ptr = frag_more (4);
      md_number_to_chars (ptr, 0, 4);
    }

  return 0;
}


/* Parse an unwind_fnstart directive.  Simply records the current location.  */

static void
s_arm_unwind_fnstart (int ignored ATTRIBUTE_UNUSED)
{
  demand_empty_rest_of_line ();
  /* Mark the start of the function.  */
  unwind.proc_start = expr_build_dot ();

  /* Reset the rest of the unwind info.  */
  unwind.opcode_count = 0;
  unwind.table_entry = NULL;
  unwind.personality_routine = NULL;
  unwind.personality_index = -1;
  unwind.frame_size = 0;
  unwind.fp_offset = 0;
  unwind.fp_reg = 13;
  unwind.fp_used = 0;
  unwind.sp_restored = 0;
}


/* Parse a handlerdata directive.  Creates the exception handling table entry
   for the function.  */

static void
s_arm_unwind_handlerdata (int ignored ATTRIBUTE_UNUSED)
{
  demand_empty_rest_of_line ();
  if (unwind.table_entry)
    as_bad (_("dupicate .handlerdata directive"));

  create_unwind_entry (1);
}

/* Parse an unwind_fnend directive.  Generates the index table entry.  */

static void
s_arm_unwind_fnend (int ignored ATTRIBUTE_UNUSED)
{
  long where;
  unsigned char *ptr;
  valueT val;

  demand_empty_rest_of_line ();

  /* Add eh table entry.  */
  if (unwind.table_entry == NULL)
    val = create_unwind_entry (0);
  else
    val = 0;

  /* Add index table entry.  This is two words.  */
  start_unwind_section (unwind.saved_seg, 1);
  frag_align (2, 0, 0);
  record_alignment (now_seg, 2);

  ptr = frag_more (8);
  where = frag_now_fix () - 8;

  /* Self relative offset of the function start.  */
  fix_new (frag_now, where, 4, unwind.proc_start, 0, 1,
	   BFD_RELOC_ARM_PREL31);

  if (val)
    /* Inline exception table entry.  */
    md_number_to_chars (ptr + 4, val, 4);
  else
    /* Self relative offset of the table entry.  */
    fix_new (frag_now, where + 4, 4, unwind.table_entry, 0, 1,
	     BFD_RELOC_ARM_PREL31);

  /* Restore the original section.  */
  subseg_set (unwind.saved_seg, unwind.saved_subseg);
}


/* Parse an unwind_cantunwind directive.  */

static void
s_arm_unwind_cantunwind (int ignored ATTRIBUTE_UNUSED)
{
  demand_empty_rest_of_line ();
  if (unwind.personality_routine || unwind.personality_index != -1)
    as_bad (_("personality routine specified for cantunwind frame"));

  unwind.personality_index = -2;
}


/* Parse a personalityindex directive.  */

static void
s_arm_unwind_personalityindex (int ignored ATTRIBUTE_UNUSED)
{
  expressionS exp;

  if (unwind.personality_routine || unwind.personality_index != -1)
    as_bad (_("duplicate .personalityindex directive"));

  SKIP_WHITESPACE ();

  expression (&exp);

  if (exp.X_op != O_constant
      || exp.X_add_number < 0 || exp.X_add_number > 15)
    {
      as_bad (_("bad personality routine number"));
      ignore_rest_of_line ();
      return;
    }

  unwind.personality_index = exp.X_add_number;

  demand_empty_rest_of_line ();
}


/* Parse a personality directive.  */

static void
s_arm_unwind_personality (int ignored ATTRIBUTE_UNUSED)
{
  char *name, *p, c;

  if (unwind.personality_routine || unwind.personality_index != -1)
    as_bad (_("duplicate .personality directive"));

  SKIP_WHITESPACE ();
  name = input_line_pointer;
  c = get_symbol_end ();
  p = input_line_pointer;
  unwind.personality_routine = symbol_find_or_make (name);
  *p = c;
  SKIP_WHITESPACE ();
  demand_empty_rest_of_line ();
}


/* Parse a directive saving core registers.  */

static void
s_arm_unwind_save_core (void)
{
  valueT op;
  long range;
  int n;

  SKIP_WHITESPACE ();
  range = reg_list (&input_line_pointer);
  if (range == FAIL)
    {
      as_bad (_("expected register list"));
      ignore_rest_of_line ();
      return;
    }

  demand_empty_rest_of_line ();

  /* Turn .unwind_movsp ip followed by .unwind_save {..., ip, ...}
     into .unwind_save {..., sp...}.  We aren't bothered about the value of
     ip because it is clobbered by calls.  */
  if (unwind.sp_restored && unwind.fp_reg == 12
      && (range & 0x3000) == 0x1000)
    {
      unwind.opcode_count--;
      unwind.sp_restored = 0;
      range = (range | 0x2000) & ~0x1000;
      unwind.pending_offset = 0;
    }

  /* See if we can use the short opcodes.  These pop a block of upto 8
     registers starting with r4, plus maybe r14.  */
  for (n = 0; n < 8; n++)
    {
      /* Break at the first non-saved register.  */
      if ((range & (1 << (n + 4))) == 0)
	break;
    }
  /* See if there are any other bits set.  */
  if (n == 0 || (range & (0xfff0 << n) & 0xbff0) != 0)
    {
      /* Use the long form.  */
      op = 0x8000 | ((range >> 4) & 0xfff);
      add_unwind_opcode (op, 2);
    }
  else
    {
      /* Use the short form.  */
      if (range & 0x4000)
	op = 0xa8; /* Pop r14.  */
      else
	op = 0xa0; /* Do not pop r14.  */
      op |= (n - 1);
      add_unwind_opcode (op, 1);
    }

  /* Pop r0-r3.  */
  if (range & 0xf)
    {
      op = 0xb100 | (range & 0xf);
      add_unwind_opcode (op, 2);
    }

  /* Record the number of bytes pushed.  */
  for (n = 0; n < 16; n++)
    {
      if (range & (1 << n))
	unwind.frame_size += 4;
    }
}


/* Parse a directive saving FPA registers.  */

static void
s_arm_unwind_save_fpa (int reg)
d11903 4
a11906 3
  expressionS exp;
  int num_regs;
  valueT op;
d11908 3
a11910 44
  /* Get Number of registers to transfer.  */
  if (skip_past_comma (&input_line_pointer) != FAIL)
    expression (&exp);
  else
    exp.X_op = O_illegal;

  if (exp.X_op != O_constant)
    {
      as_bad (_("expected , <constant>"));
      ignore_rest_of_line ();
      return;
    }

  num_regs = exp.X_add_number;

  if (num_regs < 1 || num_regs > 4)
    {
      as_bad (_("number of registers must be in the range [1:4]"));
      ignore_rest_of_line ();
      return;
    }

  demand_empty_rest_of_line ();

  if (reg == 4)
    {
      /* Short form.  */
      op = 0xb4 | (num_regs - 1);
      add_unwind_opcode (op, 1);
    }
  else
    {
      /* Long form.  */
      op = 0xc800 | (reg << 4) | (num_regs - 1);
      add_unwind_opcode (op, 2);
    }
  unwind.frame_size += num_regs * 12;
}


/* Parse a directive saving VFP registers.  */

static void
s_arm_unwind_save_vfp (void)
d11912 30
a11941 257
  int count;
  int reg;
  valueT op;

  count = vfp_parse_reg_list (&input_line_pointer, &reg, 1);
  if (count == FAIL)
    {
      as_bad (_("expected register list"));
      ignore_rest_of_line ();
      return;
    }

  demand_empty_rest_of_line ();

  if (reg == 8)
    {
      /* Short form.  */
      op = 0xb8 | (count - 1);
      add_unwind_opcode (op, 1);
    }
  else
    {
      /* Long form.  */
      op = 0xb300 | (reg << 4) | (count - 1);
      add_unwind_opcode (op, 2);
    }
  unwind.frame_size += count * 8 + 4;
}


/* Parse a directive saving iWMMXt registers.  */

static void
s_arm_unwind_save_wmmx (void)
{
  int reg;
  int hi_reg;
  int i;
  unsigned wcg_mask;
  unsigned wr_mask;
  valueT op;

  if (*input_line_pointer == '{')
    input_line_pointer++;

  wcg_mask = 0;
  wr_mask = 0;
  do
    {
      reg = arm_reg_parse (&input_line_pointer,
			   all_reg_maps[REG_TYPE_IWMMXT].htab);

      if (wr_register (reg))
	{
	  i = reg & ~WR_PREFIX;
	  if (wr_mask >> i)
	    as_tsktsk (_("register list not in ascending order"));
	  wr_mask |= 1 << i;
	}
      else if (wcg_register (reg))
	{
	  i = (reg & ~WC_PREFIX) - 8;
	  if (wcg_mask >> i)
	    as_tsktsk (_("register list not in ascending order"));
	  wcg_mask |= 1 << i;
	}
      else
	{
	  as_bad (_("expected wr or wcgr"));
	  goto error;
	}

      SKIP_WHITESPACE ();
      if (*input_line_pointer == '-')
	{
	  hi_reg = arm_reg_parse (&input_line_pointer,
				  all_reg_maps[REG_TYPE_IWMMXT].htab);
	  if (wr_register (reg) && wr_register (hi_reg))
	    {
	      for (; reg < hi_reg; reg++)
		wr_mask |= 1 << (reg & ~WR_PREFIX);
	    }
	  else if (wcg_register (reg) && wcg_register (hi_reg))
	    {
	      for (; reg < hi_reg; reg++)
		wcg_mask |= 1 << ((reg & ~WC_PREFIX) - 8);
	    }
	  else
	    {
	      as_bad (_("bad register range"));
	      goto error;
	    }
	}
    }
  while (skip_past_comma (&input_line_pointer) != FAIL);

  SKIP_WHITESPACE ();
  if (*input_line_pointer == '}')
    input_line_pointer++;

  demand_empty_rest_of_line ();

  if (wr_mask && wcg_mask)
    {
      as_bad (_("inconsistent register types"));
      goto error;
    }

  /* Generate any deferred opcodes becuuse we're going to be looking at
     the list.  */
  flush_pending_unwind ();

  if (wcg_mask)
    {
      for (i = 0; i < 16; i++)
	{
	  if (wcg_mask & (1 << i))
	    unwind.frame_size += 4;
	}
      op = 0xc700 | wcg_mask;
      add_unwind_opcode (op, 2);
    }
  else
    {
      for (i = 0; i < 16; i++)
	{
	  if (wr_mask & (1 << i))
	    unwind.frame_size += 8;
	}
      /* Attempt to combine with a previous opcode.  We do this because gcc
	 likes to output separate unwind directives for a single block of
	 registers.  */
      if (unwind.opcode_count > 0)
	{
	  i = unwind.opcodes[unwind.opcode_count - 1];
	  if ((i & 0xf8) == 0xc0)
	    {
	      i &= 7;
	      /* Only merge if the blocks are contiguous.  */
	      if (i < 6)
		{
		  if ((wr_mask & 0xfe00) == (1 << 9))
		    {
		      wr_mask |= ((1 << (i + 11)) - 1) & 0xfc00;
		      unwind.opcode_count--;
		    }
		}
	      else if (i == 6 && unwind.opcode_count >= 2)
		{
		  i = unwind.opcodes[unwind.opcode_count - 2];
		  reg = i >> 4;
		  i &= 0xf;

		  op = 0xffff << (reg - 1);
		  if (reg > 0
		      || ((wr_mask & op) == (1u << (reg - 1))))
		    {
		      op = (1 << (reg + i + 1)) - 1;
		      op &= ~((1 << reg) - 1);
		      wr_mask |= op;
		      unwind.opcode_count -= 2;
		    }
		}
	    }
	}

      hi_reg = 15;
      /* We want to generate opcodes in the order the registers have been
	 saved, ie. descending order.  */
      for (reg = 15; reg >= -1; reg--)
	{
	  /* Save registers in blocks.  */
	  if (reg < 0
	      || !(wr_mask & (1 << reg)))
	    {
	      /* We found an unsaved reg.  Generate opcodes to save the
		 preceeding block.  */
	      if (reg != hi_reg)
		{
		  if (reg == 9)
		    {
		      /* Short form.  */
		      op = 0xc0 | (hi_reg - 10);
		      add_unwind_opcode (op, 1);
		    }
		  else
		    {
		      /* Long form.  */
		      op = 0xc600 | ((reg + 1) << 4) | ((hi_reg - reg) - 1);
		      add_unwind_opcode (op, 2);
		    }
		}
	      hi_reg = reg - 1;
	    }
	}
    }
  return;
error:
  ignore_rest_of_line ();
}


/* Parse an unwind_save directive.  */

static void
s_arm_unwind_save (int ignored ATTRIBUTE_UNUSED)
{
  char *saved_ptr;
  int reg;

  /* Figure out what sort of save we have.  */
  SKIP_WHITESPACE ();
  saved_ptr = input_line_pointer;

  reg = arm_reg_parse (&input_line_pointer, all_reg_maps[REG_TYPE_FN].htab);
  if (reg != FAIL)
    {
      s_arm_unwind_save_fpa (reg);
      return;
    }

  if (*input_line_pointer == '{')
    input_line_pointer++;

  SKIP_WHITESPACE ();

  reg = arm_reg_parse (&input_line_pointer, all_reg_maps[REG_TYPE_RN].htab);
  if (reg != FAIL)
    {
      input_line_pointer = saved_ptr;
      s_arm_unwind_save_core ();
      return;
    }

  reg = arm_reg_parse (&input_line_pointer, all_reg_maps[REG_TYPE_DN].htab);
  if (reg != FAIL)
    {
      input_line_pointer = saved_ptr;
      s_arm_unwind_save_vfp ();
      return;
    }

  reg = arm_reg_parse (&input_line_pointer,
		       all_reg_maps[REG_TYPE_IWMMXT].htab);
  if (reg != FAIL)
    {
      input_line_pointer = saved_ptr;
      s_arm_unwind_save_wmmx ();
      return;
    }

  /* TODO: Maverick registers.  */
  as_bad (_("unrecognised register"));
}


/* Parse an unwind_movsp directive.  */
d11943 2
a11944 2
static void
s_arm_unwind_movsp (int ignored ATTRIBUTE_UNUSED)
d11946 3
a11948 2
  int reg;
  valueT op;
d11950 7
a11956 8
  SKIP_WHITESPACE ();
  reg = reg_required_here (&input_line_pointer, -1);
  if (reg == FAIL)
    {
      as_bad (_("ARM register expected"));
      ignore_rest_of_line ();
      return;
    }
d11958 26
a11983 6
  if (reg == 13 || reg == 15)
    {
      as_bad (_("r%d not permitted in .unwind_movsp directive"), reg);
      ignore_rest_of_line ();
      return;
    }
d11985 7
a11991 2
  if (unwind.fp_reg != 13)
    as_bad (_("unexpected .unwind_movsp directive"));
d11993 9
a12001 3
  /* Generate opcode to restore the value.  */
  op = 0x90 | reg;
  add_unwind_opcode (op, 1);
d12003 7
a12009 9
  /* Record the information for later.  */
  unwind.fp_reg = reg;
  unwind.fp_offset = unwind.frame_size;
  unwind.sp_restored = 1;
  demand_empty_rest_of_line ();
}


/* Parse #<number>.  */
d12012 1
a12012 1
require_hashconst (int * val)
d12014 5
a12018 1
  expressionS exp;
d12020 5
a12024 8
  SKIP_WHITESPACE ();
  if (*input_line_pointer == '#')
    {
      input_line_pointer++;
      expression (&exp);
    }
  else
    exp.X_op = O_illegal;
d12026 2
a12027 9
  if (exp.X_op != O_constant)
    {
      as_bad (_("expected #constant"));
      ignore_rest_of_line ();
      return FAIL;
    }
  *val = exp.X_add_number;
  return SUCCESS;
}
d12029 4
a12032 1
/* Parse an unwind_pad directive.  */
d12034 5
a12038 4
static void
s_arm_unwind_pad (int ignored ATTRIBUTE_UNUSED)
{
  int offset;
d12040 6
a12045 2
  if (require_hashconst (&offset) == FAIL)
    return;
d12047 5
a12051 6
  if (offset & 3)
    {
      as_bad (_("stack increment must be multiple of 4"));
      ignore_rest_of_line ();
      return;
    }
d12053 2
a12054 3
  /* Don't generate any opcodes, just record the details for later.  */
  unwind.frame_size += offset;
  unwind.pending_offset += offset;
d12056 1
a12056 1
  demand_empty_rest_of_line ();
d12059 2
a12060 4
/* Parse an unwind_setfp directive.  */

static void
s_arm_unwind_setfp (int ignored ATTRIBUTE_UNUSED)
d12062 3
a12064 3
  int sp_reg;
  int fp_reg;
  int offset;
d12066 2
a12067 3
  fp_reg = reg_required_here (&input_line_pointer, -1);
  if (skip_past_comma (&input_line_pointer) == FAIL)
    sp_reg = FAIL;
d12069 1
a12069 1
    sp_reg = reg_required_here (&input_line_pointer, -1);
d12071 1
a12071 1
  if (fp_reg == FAIL || sp_reg == FAIL)
d12073 2
a12074 3
      as_bad (_("expected <reg>, <reg>"));
      ignore_rest_of_line ();
      return;
d12077 5
a12081 8
  /* Optonal constant.  */
  if (skip_past_comma (&input_line_pointer) != FAIL)
    {
      if (require_hashconst (&offset) == FAIL)
	return;
    }
  else
    offset = 0;
d12083 2
a12084 1
  demand_empty_rest_of_line ();
d12086 2
a12087 6
  if (sp_reg != 13 && sp_reg != unwind.fp_reg)
    {
      as_bad (_("register must be either sp or set by a previous"
		"unwind_movsp directive"));
      return;
    }
d12089 2
a12090 7
  /* Don't generate any opcodes, just record the information for later.  */
  unwind.fp_reg = fp_reg;
  unwind.fp_used = 1;
  if (sp_reg == 13)
    unwind.fp_offset = unwind.frame_size - offset;
  else
    unwind.fp_offset -= offset;
d12093 2
a12094 4
/* Parse an unwind_raw directive.  */

static void
s_arm_unwind_raw (int ignored ATTRIBUTE_UNUSED)
d12096 3
a12098 4
  expressionS exp;
  /* This is an arbitary limit.  */
  unsigned char op[16];
  int count;
d12100 2
a12101 8
  SKIP_WHITESPACE ();
  expression (&exp);
  if (exp.X_op == O_constant
      && skip_past_comma (&input_line_pointer) != FAIL)
    {
      unwind.frame_size += exp.X_add_number;
      expression (&exp);
    }
d12103 1
a12103 1
    exp.X_op = O_illegal;
d12105 1
a12105 1
  if (exp.X_op != O_constant)
d12107 2
a12108 3
      as_bad (_("expected <offset>, <opcode>"));
      ignore_rest_of_line ();
      return;
a12110 1
  count = 0;
d12112 5
a12116 15
  /* Parse the opcode.  */
  for (;;)
    {
      if (count >= 16)
	{
	  as_bad (_("unwind opcode too long"));
	  ignore_rest_of_line ();
	}
      if (exp.X_op != O_constant || exp.X_add_number & ~0xff)
	{
	  as_bad (_("invalid unwind opcode"));
	  ignore_rest_of_line ();
	  return;
	}
      op[count++] = exp.X_add_number;
d12118 2
a12119 3
      /* Parse the next byte.  */
      if (skip_past_comma (&input_line_pointer) == FAIL)
	break;
d12121 2
a12122 2
      expression (&exp);
    }
d12124 3
a12126 3
  /* Add the opcode bytes in reverse order.  */
  while (count--)
    add_unwind_opcode (op[count], 1);
d12128 4
a12131 2
  demand_empty_rest_of_line ();
}
d12133 6
a12138 1
#endif /* OBJ_ELF */
d12140 3
a12142 2
/* This is called from HANDLE_ALIGN in write.c.  Fill in the contents
   of an rs_align_code fragment.  */
d12144 2
a12145 2
void
arm_handle_align (fragS * fragP)
d12147 1
a12147 4
  static char const arm_noop[4] = { 0x00, 0x00, 0xa0, 0xe1 };
  static char const thumb_noop[2] = { 0xc0, 0x46 };
  static char const arm_bigend_noop[4] = { 0xe1, 0xa0, 0x00, 0x00 };
  static char const thumb_bigend_noop[2] = { 0x46, 0xc0 };
d12149 6
a12154 3
  int bytes, fix, noop_size;
  char * p;
  const char * noop;
d12156 3
a12158 2
  if (fragP->fr_type != rs_align_code)
    return;
d12160 5
a12164 3
  bytes = fragP->fr_next->fr_address - fragP->fr_address - fragP->fr_fix;
  p = fragP->fr_literal + fragP->fr_fix;
  fix = 0;
d12166 10
a12175 2
  if (bytes > MAX_MEM_FOR_RS_ALIGN_CODE)
    bytes &= MAX_MEM_FOR_RS_ALIGN_CODE;
d12177 16
a12192 16
  if (fragP->tc_frag_data)
    {
      if (target_big_endian)
	noop = thumb_bigend_noop;
      else
	noop = thumb_noop;
      noop_size = sizeof (thumb_noop);
    }
  else
    {
      if (target_big_endian)
	noop = arm_bigend_noop;
      else
	noop = arm_noop;
      noop_size = sizeof (arm_noop);
    }
d12194 5
a12198 7
  if (bytes & (noop_size - 1))
    {
      fix = bytes & (noop_size - 1);
      memset (p, 0, fix);
      p += fix;
      bytes -= fix;
    }
d12200 1
a12200 1
  while (bytes >= noop_size)
d12202 5
a12206 5
      memcpy (p, noop, noop_size);
      p += noop_size;
      bytes -= noop_size;
      fix += noop_size;
    }
d12208 5
a12212 3
  fragP->fr_fix += fix;
  fragP->fr_var = noop_size;
}
d12214 4
a12217 2
/* Called from md_do_align.  Used to create an alignment
   frag in a code section.  */
d12219 13
a12231 4
void
arm_frag_align_code (int n, int max)
{
  char * p;
d12233 2
a12234 4
  /* We assume that there will never be a requirement
     to support alignments greater than 32 bytes.  */
  if (max > MAX_MEM_FOR_RS_ALIGN_CODE)
    as_fatal (_("alignments greater than 32 bytes not supported in .text sections."));
d12236 3
a12238 9
  p = frag_var (rs_align_code,
		MAX_MEM_FOR_RS_ALIGN_CODE,
		1,
		(relax_substateT) max,
		(symbolS *) NULL,
		(offsetT) n,
		(char *) NULL);
  *p = 0;
}
d12240 14
a12253 1
/* Perform target specific initialisation of a frag.  */
d12255 4
a12258 6
void
arm_init_frag (fragS * fragP)
{
  /* Record whether this frag is in an ARM or a THUMB area.  */
  fragP->tc_frag_data = thumb_mode;
}
d12260 2
a12261 1
#ifdef OBJ_ELF
d12263 2
a12264 1
/* Convert REGNAME to a DWARF-2 register number.  */
d12266 2
a12267 2
int
tc_arm_regname_to_dw2regnum (const char *regname)
d12269 2
a12270 1
  unsigned int i;
d12272 1
a12272 3
  for (i = 0; rn_table[i].name; i++)
    if (streq (regname, rn_table[i].name))
      return rn_table[i].number;
d12274 3
a12276 2
  return -1;
}
d12278 3
a12280 1
/* Initialize the DWARF-2 unwind information for this procedure.  */
d12282 3
a12284 5
void
tc_arm_frame_initial_instructions (void)
{
  cfi_add_CFA_def_cfa (REG_SP, 0);
}
d12287 3
a12289 39
/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
     pseudo-op name without dot
     function to call to execute this pseudo-op
     Integer arg to pass to the function.  */

const pseudo_typeS md_pseudo_table[] =
{
  /* Never called because '.req' does not start a line.  */
  { "req",         s_req,         0 },
  { "unreq",       s_unreq,       0 },
  { "bss",         s_bss,         0 },
  { "align",       s_align,       0 },
  { "arm",         s_arm,         0 },
  { "thumb",       s_thumb,       0 },
  { "code",        s_code,        0 },
  { "force_thumb", s_force_thumb, 0 },
  { "thumb_func",  s_thumb_func,  0 },
  { "thumb_set",   s_thumb_set,   0 },
  { "even",        s_even,        0 },
  { "ltorg",       s_ltorg,       0 },
  { "pool",        s_ltorg,       0 },
#ifdef OBJ_ELF
  { "word",        s_arm_elf_cons, 4 },
  { "long",        s_arm_elf_cons, 4 },
  { "rel31",       s_arm_rel31,   0 },
  { "fnstart",		s_arm_unwind_fnstart,	0 },
  { "fnend",		s_arm_unwind_fnend,	0 },
  { "cantunwind",	s_arm_unwind_cantunwind, 0 },
  { "personality",	s_arm_unwind_personality, 0 },
  { "personalityindex",	s_arm_unwind_personalityindex, 0 },
  { "handlerdata",	s_arm_unwind_handlerdata, 0 },
  { "save",		s_arm_unwind_save,	0 },
  { "movsp",		s_arm_unwind_movsp,	0 },
  { "pad",		s_arm_unwind_pad,	0 },
  { "setfp",		s_arm_unwind_setfp,	0 },
  { "unwind_raw",	s_arm_unwind_raw,	0 },
#else
  { "word",        cons, 4},
d12291 1
a12291 5
  { "extend",      float_cons, 'x' },
  { "ldouble",     float_cons, 'x' },
  { "packed",      float_cons, 'p' },
  { 0, 0, 0 }
};
@


1.1.101.1
log
@GNU binutils (CVS snapshot)
@
text
@@


1.1.101.2
log
@GNU binutils (CVS snapshot), without
* top-level files
* bfd/po
* binutils/po
* binutils/testsuite
* gas/po
* gas/testsuite
* gprof
* intl
* ld/po
* ld/testsuite
* libiberty/config
* opcodes/po
* texinfo
(same procedure as usual)
@
text
@d2 2
a3 2
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
   2004, 2005
a161 3
# ifdef EABI_DEFAULT
static int meabi_flags = EABI_DEFAULT;
# else
a162 1
# endif
d2686 12
d2829 1
a2829 1
do_mlas (char * str, bfd_boolean is_mls)
d2861 1
a2861 3
  /* This restriction does not apply to mls (nor to mla in v6, but
     that's hard to detect at present).  */
  if (rm == rd && !is_mls)
a2881 12
static void
do_mla (char *str)
{
  do_mlas (str, FALSE);
}

static void
do_mls (char *str)
{
  do_mlas (str, TRUE);
}

a4526 280
/* ARM V6T2 bitfield manipulation instructions.  */

static int
five_bit_unsigned_immediate (char **str)
{
  expressionS expr;

  skip_whitespace (*str);
  if (!is_immediate_prefix (**str))
    {
      inst.error = _("immediate expression expected");
      return -1;
    }
  (*str)++;
  if (my_get_expression (&expr, str))
    {
      inst.error = _("bad expression");
      return -1;
    }
  if (expr.X_op != O_constant)
    {
      inst.error = _("constant expression expected");
      return -1;
    }
  if (expr.X_add_number < 0 || expr.X_add_number > 32)
    {
      inst.error = _("immediate value out of range");
      return -1;
    }
  
  return expr.X_add_number;
}

static void
bfci_lsb_and_width (char *str)
{
  int lsb, width;

  if ((lsb = five_bit_unsigned_immediate (&str)) == -1)
    return;

  if (skip_past_comma (&str) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
  if ((width = five_bit_unsigned_immediate (&str)) == -1)
    return;

  end_of_line (str);

  if (width == 0 || lsb == 32)
    {
      inst.error = _("immediate value out of range");
      return;
    }
  else if (width + lsb > 32)
    {
      inst.error = _("bit-field extends past end of register");
      return;
    }

  /* Convert to LSB/MSB and write to register.  */
  inst.instruction |= lsb << 7;
  inst.instruction |= (width + lsb - 1) << 16;
}

static void
do_bfc (char *str)
{
  int rd;

  /* Rd.  */
  skip_whitespace (str);
  if (((rd = reg_required_here (&str, 12)) == FAIL)
      || (skip_past_comma (&str) == FAIL))
    {
      inst.error = BAD_ARGS;
      return;
    }
  else if (rd == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  bfci_lsb_and_width (str);
}

static void
do_bfi (char *str)
{
  int rd, rm;

  /* Rd.  */
  skip_whitespace (str);
  if (((rd = reg_required_here (&str, 12)) == FAIL)
      || (skip_past_comma (&str) == FAIL))
    {
      inst.error = BAD_ARGS;
      return;
    }
  else if (rd == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  /* Rm.  Accept #0 in this position as an alternative syntax for bfc.  */
  skip_whitespace (str);
  if (is_immediate_prefix (*str))
    {
      expressionS expr;
      str++;
      if (my_get_expression (&expr, &str))
	{
	  inst.error = _("bad expression");
	  return;
	}
      if (expr.X_op != O_constant)
	{
	  inst.error = _("constant expression expected");
	  return;
	}
      if (expr.X_add_number != 0)
	{
	  inst.error = _("immediate value out of range");
	  return;
	}
      inst.instruction |= 0x0000000f;  /* Rm = PC -> bfc, not bfi.  */
    }
  else
    {
      if ((rm = reg_required_here (&str, 0)) == FAIL)
	{
	  inst.error = BAD_ARGS;
	  return;
	}
      else if (rm == REG_PC)
	{
	  inst.error = BAD_PC;
	  return;
	}
    }
  if (skip_past_comma (&str) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  bfci_lsb_and_width (str);
}

static void
do_bfx (char *str)
{
  int lsb, width;

  /* Rd.  */
  skip_whitespace (str);
  if (reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  /* Rm.  */
  skip_whitespace (str);
  if (reg_required_here (&str, 0) == FAIL
      || skip_past_comma (&str) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  if ((lsb = five_bit_unsigned_immediate (&str)) == -1)
    return;

  if (skip_past_comma (&str) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }
  if ((width = five_bit_unsigned_immediate (&str)) == -1)
    return;

  end_of_line (str);

  if (width == 0 || lsb == 32)
    {
      inst.error = _("immediate value out of range");
      return;
    }
  else if (width + lsb > 32)
    {
      inst.error = _("bit-field extends past end of register");
      return;
    }

  inst.instruction |= lsb << 7;
  inst.instruction |= (width - 1) << 16;
}

static void
do_rbit (char *str)
{
  /* Rd.  */
  skip_whitespace (str);
  if (reg_required_here (&str, 12) == FAIL
      || skip_past_comma (&str) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  /* Rm.  */
  skip_whitespace (str);
  if (reg_required_here (&str, 0) == FAIL)
    {
      inst.error = BAD_ARGS;
      return;
    }

  end_of_line (str);
}

/* ARM V6T2 16-bit immediate register load: MOV[WT]{cond} Rd, #<imm16>.  */
static void
do_mov16 (char *str)
{
  int rd;
  expressionS expr;

  /* Rd.  */
  skip_whitespace (str);
  if (((rd = reg_required_here (&str, 12)) == FAIL)
      || (skip_past_comma (&str) == FAIL))
    {
      inst.error = BAD_ARGS;
      return;
    }
  else if (rd == REG_PC)
    {
      inst.error = BAD_PC;
      return;
    }

  /* Imm16.  */
  skip_whitespace (str);
  if (!is_immediate_prefix (*str))
    {
      inst.error = _("immediate expression expected");
      return;
    }
  str++;
  if (my_get_expression (&expr, &str))
    {
      inst.error = _("bad expression");
      return;
    }
  if (expr.X_op != O_constant)
    {
      inst.error = _("constant expression expected");
      return;
    }
  if (expr.X_add_number < 0 || expr.X_add_number > 65535)
    {
      inst.error = _("immediate value out of range");
      return;
    }

  end_of_line (str);

  /* The value is in two pieces: 0:11, 16:19.  */
  inst.instruction |= (expr.X_add_number & 0x00000fff);
  inst.instruction |= (expr.X_add_number & 0x0000f000) << 4;
}
  

a4565 1
#ifdef OBJ_ELF
a4605 1
#endif
a6529 78
static void
do_ldsttv4 (char * str)
{
  int conflict_reg;

  skip_whitespace (str);

  if ((conflict_reg = reg_required_here (& str, 12)) == FAIL)
    {
      if (!inst.error)
	inst.error = BAD_ARGS;
      return;
    }

  if (skip_past_comma (& str) == FAIL)
    {
      inst.error = _("address expected");
      return;
    }

  if (*str == '[')
    {
      int reg;

      str++;

      skip_whitespace (str);

      if ((reg = reg_required_here (&str, 16)) == FAIL)
	return;

      /* ldrt/strt always use post-indexed addressing, so if the base is
	 the same as Rd, we warn.  */
      if (conflict_reg == reg)
	as_warn (_("%s register same as write-back base"),
		 ((inst.instruction & LOAD_BIT)
		  ? _("destination") : _("source")));

      skip_whitespace (str);

      if (*str == ']')
	{
	  str ++;

	  if (skip_past_comma (&str) == SUCCESS)
	    {
	      /* [Rn],... (post inc)  */
	      if (ldst_extend_v4 (&str) == FAIL)
		return;
	    }
	  else
	    {
	      /* [Rn]  */
	      skip_whitespace (str);

	      /* Skip a write-back '!'.  */
	      if (*str == '!')
		str++;

	      inst.instruction |= (INDEX_UP|HWOFFSET_IMM);
	    }
	}
      else
	{
	  inst.error = _("post-indexed expression expected");
	  return;
	}
    }
  else
    {
      inst.error = _("post-indexed expression expected");
      return;
    }

  end_of_line (str);
}


d9384 1
a9384 1
  if (inst.reloc.type != BFD_RELOC_UNUSED)
d9387 1
a9387 1
      inst.reloc.type = BFD_RELOC_UNUSED;
d9476 1
a9476 1
  if (inst.reloc.type != BFD_RELOC_UNUSED)
d9479 1
a9479 1
      inst.reloc.type = BFD_RELOC_UNUSED;
a10026 15
  /*  ARM V6T2.  */
  { "bfc",       0xe7c0001f, 3,  ARM_EXT_V6T2,     do_bfc},
  { "bfi",       0xe7c00010, 3,  ARM_EXT_V6T2,     do_bfi},
  { "mls",       0xe0600090, 3,  ARM_EXT_V6T2,     do_mls},
  { "movw",      0xe3000000, 4,  ARM_EXT_V6T2,     do_mov16},
  { "movt",      0xe3400000, 4,  ARM_EXT_V6T2,     do_mov16},
  { "rbit",      0xe3ff0f30, 4,  ARM_EXT_V6T2,     do_rbit},
  { "sbfx",      0xe7a00050, 4,  ARM_EXT_V6T2,     do_bfx},
  { "ubfx",      0xe7e00050, 4,  ARM_EXT_V6T2,     do_bfx},

  { "ldrht",     0xe03000b0, 3,  ARM_EXT_V6T2,     do_ldsttv4},
  { "ldrsht",    0xe03000f0, 3,  ARM_EXT_V6T2,     do_ldsttv4},
  { "ldrsbt",    0xe03000d0, 3,  ARM_EXT_V6T2,     do_ldsttv4},
  { "strht",     0xe02000b0, 3,  ARM_EXT_V6T2,     do_ldsttv4},

d10885 49
a11011 6

  /* ARM V6K.  */
  {"sev",	0xbf40,		2,	ARM_EXT_V6K, do_empty},
  {"wfe",	0xbf20,		2,	ARM_EXT_V6K, do_empty},
  {"wfi",	0xbf30,		2,	ARM_EXT_V6K, do_empty},
  {"yield",	0xbf10,		2,	ARM_EXT_V6K, do_empty},
a11091 1
#if defined OBJ_COFF || defined OBJ_ELF
d11102 1
d11128 1
a11128 1

d11142 1
d11162 1
a11163 1
#endif
d11211 56
d11481 1
a11481 1
  assert (fixP->fx_r_type <= BFD_RELOC_UNUSED);
d11484 6
d11491 1
a11509 5
    case BFD_RELOC_NONE:
      /* This will need to go in the object file.  */
      fixP->fx_done = 0;
      break;
  
d12177 1
a12177 1
    case BFD_RELOC_UNUSED:
a12232 1
    case BFD_RELOC_NONE:
a12296 1
	  case BFD_RELOC_NONE:		   type = "NONE";         break;
d12420 1
a12420 1
  if (inst.reloc.type != BFD_RELOC_UNUSED)
d12437 6
d12452 1
a12452 1
  inst.reloc.type = BFD_RELOC_UNUSED;
a12881 4
  {"armv6t2",		ARM_ARCH_V6T2,   FPU_ARCH_VFP},
  {"armv6kt2",		ARM_ARCH_V6KT2,  FPU_ARCH_VFP},
  {"armv6zt2",		ARM_ARCH_V6ZT2,  FPU_ARCH_VFP},
  {"armv6zkt2",		ARM_ARCH_V6ZKT2, FPU_ARCH_VFP},
d13427 1
a13427 1
	  bind = ELF_ST_BIND (elf_sym->internal_elf_sym.st_info);
d13941 1
a13941 1
  char *ptr;
a14025 8

      /* Indicate dependency to linker.  */
        {
          char *name = "__aeabi_unwind_cpp_pr0";
	  symbolS *pr = symbol_find_or_make (name);
	  fix_new (frag_now, where, 4, pr, 0, 1, BFD_RELOC_NONE);
	}

d14035 1
d14040 1
a14040 1
      goto emit_reloc;
a14046 11
      goto emit_reloc;

    emit_reloc:
      {
	/* Indicate dependency to linker.  */
	char *name[] = { "__aeabi_unwind_cpp_pr0",
	                 "__aeabi_unwind_cpp_pr1",
			 "__aeabi_unwind_cpp_pr2" };
	symbolS *pr = symbol_find_or_make (name[unwind.personality_index]);
	fix_new (frag_now, where, 4, pr, 0, 1, BFD_RELOC_NONE);
      }
d14132 1
a14132 1
  char *ptr;
@


1.1.101.3
log
@GNU binutils, -current (mainline) snapshot as of today,
with the usual bunch of files removed
@
text
@d25 2
a26 2
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */
a85 5
/* Bit N indicates that an R_ARM_NONE relocation has been output for
   __aeabi_unwind_cpp_prN already if set. This enables dependencies to be
   emitted only once per section, to save unnecessary bloat.  */
static unsigned int marked_pr_dependency = 0;

d1135 4
d1241 72
a1312 3
   (See "Mapping symbols", section 4.5.5, ARM AAELF version 1.0).
   Note that previously, $a and $t has type STT_FUNC (BSF_OBJECT flag),
   and $d has type STT_OBJECT (BSF_OBJECT flag). Now all three are untyped.  */
d1334 1
a1334 1
      type = BSF_NO_FLAGS;
d1338 1
a1338 1
      type = BSF_NO_FLAGS;
d1342 1
a1342 1
      type = BSF_NO_FLAGS;
d1350 1
a1350 1
  seg_info (now_seg)->tc_segment_info_data.mapstate = state;
a1381 1
  segment_info_type *seginfo;
d1397 1
a1397 3
  seginfo = seg_info (now_seg);
  mapstate = seginfo->tc_segment_info_data.mapstate;
  marked_pr_dependency = seginfo->tc_segment_info_data.marked_pr_dependency;
a4875 5
    MAP ("(tlsgd)", BFD_RELOC_ARM_TLS_GD32),
    MAP ("(tlsldm)", BFD_RELOC_ARM_TLS_LDM32),
    MAP ("(tlsldo)", BFD_RELOC_ARM_TLS_LDO32),
    MAP ("(gottpoff)", BFD_RELOC_ARM_TLS_IE32),
    MAP ("(tpoff)", BFD_RELOC_ARM_TLS_LE32),
a12218 8
     case BFD_RELOC_ARM_TLS_GD32:
     case BFD_RELOC_ARM_TLS_LE32:
     case BFD_RELOC_ARM_TLS_IE32:
     case BFD_RELOC_ARM_TLS_LDM32:
     case BFD_RELOC_ARM_TLS_LDO32:
	S_SET_THREAD_LOCAL (fixP->fx_addsy);
	/* fall through */

a12541 12
    case BFD_RELOC_ARM_TLS_LE32:
    case BFD_RELOC_ARM_TLS_LDO32:
      code = fixp->fx_r_type;
      break;

    case BFD_RELOC_ARM_TLS_GD32:
    case BFD_RELOC_ARM_TLS_IE32:
    case BFD_RELOC_ARM_TLS_LDM32:
      /* BFD will include the symbol's address in the addend.  
	 But we don't want that, so subtract it out again here.  */
      if (!S_IS_COMMON (fixp->fx_addsy))
	reloc->addend -= (*reloc->sym_ptr_ptr)->value;
d12913 1
a12913 1
  {"mlittle-endian", N_("assemble for little-endian"), &target_big_endian, 0,
d13708 8
a13715 11
	  if (! bfd_is_arm_mapping_symbol_name (elf_sym->symbol.name))
	    { 
	      /* If it's a .thumb_func, declare it as so,
		 otherwise tag label as .code 16.  */
	      if (THUMB_IS_FUNC (sym))
		elf_sym->internal_elf_sym.st_info =
		  ELF_ST_INFO (bind, STT_ARM_TFUNC);
	      else
		elf_sym->internal_elf_sym.st_info =
		  ELF_ST_INFO (bind, STT_ARM_16BIT);
	    }
a13837 5
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_GD32
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_LE32
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_IE32
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_LDM32
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_LDO32
a13892 2
      char *sym_start;
      int sym_len;
a13893 1
      sym_start = input_line_pointer;
a13894 1
      sym_len = input_line_pointer - sym_start;
d13908 1
a13908 1
	      char *p;
a13909 1
	      char *saved_buf = alloca (sym_len), *saved_input;
a13910 12
	      /* We've parsed an expression stopping at O_symbol.  But there
		 may be more expression left now that we have parsed the
		 relocation marker.  Parse it again.  */
	      saved_input = input_line_pointer - sym_len;
	      memcpy (saved_buf, saved_input, sym_len);
	      memmove (saved_input, sym_start, sym_len);
	      input_line_pointer = saved_input;
	      expression (& exp);
	      memcpy (saved_input, saved_buf, sym_len);
	      assert (input_line_pointer >= saved_input + sym_len);

	      p = frag_more ((int) nbytes);
d14306 7
d14326 1
a14326 1
      break;
d14333 11
a14451 17
  /* Indicate dependency on EHABI-defined personality routines to the
     linker, if it hasn't been done already.  */
  if (unwind.personality_index >= 0 && unwind.personality_index < 3)
    {
      char *name[] = { "__aeabi_unwind_cpp_pr0",
		       "__aeabi_unwind_cpp_pr1",
		       "__aeabi_unwind_cpp_pr2" };
      if (!(marked_pr_dependency & (1 << unwind.personality_index)))
	{
	  symbolS *pr = symbol_find_or_make (name[unwind.personality_index]);
	  fix_new (frag_now, where, 0, pr, 0, 1, BFD_RELOC_NONE);
	  marked_pr_dependency |= 1 << unwind.personality_index;
	  seg_info (now_seg)->tc_segment_info_data.marked_pr_dependency
	    = marked_pr_dependency;
        }
    }

@


1.1.101.4
log
@Import GNU binutils and gdb as of today (snapshot), appropriately shortened
using src/scripts/binutils-import,v 1.4
@
text
@d20 1
a20 1
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
d29 1
a29 1
#define	 NO_RELOC 0
d59 4
a62 4
  symbolS *	  proc_start;
  symbolS *	  table_entry;
  symbolS *	  personality_routine;
  int		  personality_index;
d64 2
a65 2
  segT		  saved_seg;
  subsegT	  saved_subseg;
d68 2
a69 2
  int		  opcode_count;
  int		  opcode_alloc;
d71 1
a71 1
  offsetT	  frame_size;
d75 1
a75 1
  offsetT	  pending_offset;
d77 3
a79 3
     hold the reg+offset to use when restoring sp from a frame pointer.	 */
  offsetT	  fp_offset;
  int		  fp_reg;
d81 1
a81 1
  unsigned	  fp_used:1;
d83 1
a83 1
  unsigned	  sp_restored:1;
d100 1
a100 1
/* Types of processor to assemble for.	*/
d110 1
a110 1
#define ARM_CPU_MASK	0x0000000f		/* XXX? */
d117 1
a117 1
#define CPU_DEFAULT	(ARM_ARCH_V5T)
d119 1
a119 1
#define CPU_DEFAULT	ARM_ANY
d142 2
a143 1
#define streq(a, b)	      (strcmp (a, b) == 0)
d148 2
a149 2
static int uses_apcs_26	     = FALSE;
static int atpcs	     = FALSE;
d152 1
a152 1
static int pic_code	     = FALSE;
d174 29
d204 1
a204 1
/* Pre-defined "_GLOBAL_OFFSET_TABLE_"	*/
d217 4
a220 24
/* If unified_syntax is true, we are processing the new unified
   ARM/Thumb syntax.  Important differences from the old ARM mode:

     - Immediate operands do not require a # prefix.
     - Conditional affixes always appear at the end of the
       instruction.  (For backward compatibility, those instructions
       that formerly had them in the middle, continue to accept them
       there.)
     - The IT instruction may appear, and if it does is validated
       against subsequent conditional affixes.  It does not generate
       machine code.

   Important differences from the old Thumb mode:

     - Immediate operands do not require a # prefix.
     - Most of the V6T2 instructions are only available in unified mode.
     - The .N and .W suffixes are recognized and honored (it is an error
       if they cannot be honored).
     - All instructions set the flags if and only if they have an 's' affix.
     - Conditional affixes may be used.  They are validated against
       preceding IT instructions.  Unlike ARM mode, you cannot use a
       conditional affix except in the scope of an IT instruction.  */

static bfd_boolean unified_syntax = FALSE;
d224 1
a224 1
  const char *	error;
d226 1
a226 3
  int		size;
  int		size_req;
  int		cond;
d230 2
a231 2
    expressionS		     exp;
    int			     pc_rel;
d233 35
d269 14
a282 15
  struct
  {
    unsigned reg;
    unsigned imm;
    unsigned present	: 1;  /* operand present */
    unsigned isreg	: 1;  /* operand was a register */
    unsigned immisreg	: 1;  /* .imm field is a second register */
    unsigned hasreloc	: 1;  /* operand has relocation suffix */
    unsigned writeback	: 1;  /* operand has trailing ! */
    unsigned preind	: 1;  /* preindexed address */
    unsigned postind	: 1;  /* postindexed address */
    unsigned negative	: 1;  /* index register was negated */
    unsigned shifted	: 1;  /* shift applied to operation */
    unsigned shift_kind : 3;  /* shift operation (enum shift_kind) */
  } operands[6];
d285 10
a294 1
static struct arm_it inst;
d303 1
a303 1
/* Number of littlenums required to hold an extended precision number.	*/
d311 4
d320 5
a324 2
#define CP_T_X	 0x00008000
#define CP_T_Y	 0x00400000
d326 2
a327 2
#define CONDS_BIT	 0x00100000
#define LOAD_BIT	 0x00100000
d333 1
a333 1
  const char *	template;
d337 22
a358 1
#define COND_ALWAYS 0xE
d363 1
d370 177
a546 5
/* The individual PSR flag bits.  */
#define PSR_c	(1 << 16)
#define PSR_x	(1 << 17)
#define PSR_s	(1 << 18)
#define PSR_f	(1 << 19)
d548 1
a548 1
struct reloc_entry
d550 1
a550 2
  char *name;
  bfd_reloc_code_real_type reloc;
d563 8
a570 3
/* ARM register categories.  This includes coprocessor numbers and various
   architecture extensions' registers.	*/
enum arm_reg_type
d572 6
a577 17
  REG_TYPE_RN,
  REG_TYPE_CP,
  REG_TYPE_CN,
  REG_TYPE_FN,
  REG_TYPE_VFS,
  REG_TYPE_VFD,
  REG_TYPE_VFC,
  REG_TYPE_MVF,
  REG_TYPE_MVD,
  REG_TYPE_MVFX,
  REG_TYPE_MVDX,
  REG_TYPE_MVAX,
  REG_TYPE_DSPSC,
  REG_TYPE_MMXWR,
  REG_TYPE_MMXWC,
  REG_TYPE_MMXWCG,
  REG_TYPE_XSCALE,
d583 3
a585 26
  const char   *name;
  unsigned char number;
  unsigned char type;
  unsigned char builtin;
};

/* Diagnostics used when we don't get a register of the expected type.	*/
const char *const reg_expected_msgs[] =
{
  N_("ARM register expected"),
  N_("bad or missing co-processor number"),
  N_("co-processor register expected"),
  N_("FPA register expected"),
  N_("VFP single precision register expected"),
  N_("VFP double precision register expected"),
  N_("VFP system register expected"),
  N_("Maverick MVF register expected"),
  N_("Maverick MVD register expected"),
  N_("Maverick MVFX register expected"),
  N_("Maverick MVDX register expected"),
  N_("Maverick MVAX register expected"),
  N_("Maverick DSPSC register expected"),
  N_("iWMMXt data register expected"),
  N_("iWMMXt control register expected"),
  N_("iWMMXt scalar register expected"),
  N_("XScale accumulator register expected"),
d589 2
a590 2
#define REG_SP	13
#define REG_LR	14
d593 210
d805 19
a823 1
#define INSN_SIZE	4
d828 1
a828 7
  const char *template;

  /* Parameters to instruction.	 */
  unsigned char operands[8];

  /* Conditional tag - see opcode_lookup.  */
  unsigned int tag : 4;
d831 1
a831 1
  unsigned int avalue : 28;
d833 3
a835 2
  /* Thumb-format instruction code.  */
  unsigned int tvalue;
d838 1
a838 2
  unsigned long avariant;
  unsigned long tvariant;
d840 2
a841 5
  /* Function to call to encode instruction in ARM format.  */
  void (* aencode) (void);

  /* Function to call to encode instruction in Thumb format.  */
  void (* tencode) (void);
d847 1
a847 1
#define HWOFFSET_IMM	0x00400000
d898 1
a898 2
#define T_OPCODE_LSR_R	0x40c0
#define T_OPCODE_ROR_R	0x41c0
d931 18
a949 1
#define THUMB_LOAD_BIT 0x0800
d951 32
a982 13
#define BAD_ARGS	_("bad arguments to instruction")
#define BAD_PC		_("r15 not allowed here")
#define BAD_COND	_("instruction cannot be conditional")
#define BAD_OVERLAP	_("registers may not be the same")
#define BAD_HIREG	_("lo register required")
#define BAD_THUMB32	_("instruction not supported in Thumb16 mode")

static struct hash_control *arm_ops_hsh;
static struct hash_control *arm_cond_hsh;
static struct hash_control *arm_shift_hsh;
static struct hash_control *arm_psr_hsh;
static struct hash_control *arm_reg_hsh;
static struct hash_control *arm_reloc_hsh;
d991 1
a991 1
	      <insn>
d997 4
a1003 1
#define MAX_LITERAL_POOL_SIZE 1024
d1006 6
a1011 6
  expressionS	 literals [MAX_LITERAL_POOL_SIZE];
  unsigned int	 next_free_entry;
  unsigned int	 id;
  symbolS *	 symbol;
  segT		 section;
  subsegT	 sub_section;
a1016 2

/* Pure syntax.	 */
d1018 4
a1021 3
/* This array holds the chars that always start a comment.  If the
   pre-processor is disabled, these aren't very useful.	 */
const char comment_chars[] = "@@";
d1023 6
a1028 8
/* This array holds the chars that only start a comment at the beginning of
   a line.  If the line seems to have the form '# 123 filename'
   .line and .file directives will appear in the pre-processed output.	*/
/* Note that input_file.c hand checks for '#' at the beginning of the
   first line of the input file.  This is because the compiler outputs
   #NO_APP at the beginning of its output.  */
/* Also note that comments like this one will always work.  */
const char line_comment_chars[] = "#";
d1030 2
a1031 1
const char line_separator_chars[] = ";";
d1033 6
a1038 3
/* Chars that can be used to separate mant
   from exp in floating point numbers.	*/
const char EXP_CHARS[] = "eE";
d1040 1
a1040 3
/* Chars that mean this number is a floating point constant.  */
/* As in 0f12.456  */
/* or	 0d1.2345e12  */
d1042 6
a1047 1
const char FLT_CHARS[] = "rRsSfFdDxXeEpP";
d1049 5
a1053 3
/* Prefix characters that indicate the start of an immediate
   value.  */
#define is_immediate_prefix(C) ((C) == '#' || (C) == '$')
d1055 3
a1057 1
/* Separator character handling.  */
d1059 2
a1060 6
#define skip_whitespace(str)  do { if (*(str) == ' ') ++(str); } while (0)

static inline int
skip_past_char (char ** str, char c)
{
  if (**str == c)
d1062 3
a1064 2
      (*str)++;
      return SUCCESS;
d1066 3
a1068 2
  else
    return FAIL;
a1069 1
#define skip_past_comma(str) skip_past_char (str, ',')
d1071 2
a1072 3
/* Arithmetic expressions (possibly involving symbols).	 */

/* Return TRUE if anything in the expression is a bignum.  */
d1075 1
a1075 1
walk_no_bignums (symbolS * sp)
d1077 4
a1080 2
  if (symbol_get_value_expression (sp)->X_op == O_big)
    return 1;
d1082 2
a1083 1
  if (symbol_get_value_expression (sp)->X_add_symbol)
d1085 17
a1101 3
      return (walk_no_bignums (symbol_get_value_expression (sp)->X_add_symbol)
	      || (symbol_get_value_expression (sp)->X_op_symbol
		  && walk_no_bignums (symbol_get_value_expression (sp)->X_op_symbol)));
d1104 2
a1105 21
  return 0;
}

static int in_my_get_expression = 0;

/* Third argument to my_get_expression.	 */
#define GE_NO_PREFIX 0
#define GE_IMM_PREFIX 1
#define GE_OPT_PREFIX 2

static int
my_get_expression (expressionS * ep, char ** str, int prefix_mode)
{
  char * save_in;
  segT	 seg;

  /* In unified syntax, all prefixes are optional.  */
  if (unified_syntax)
    prefix_mode = GE_OPT_PREFIX;

  switch (prefix_mode)
d1107 1
a1107 3
    case GE_NO_PREFIX: break;
    case GE_IMM_PREFIX:
      if (!is_immediate_prefix (**str))
d1109 1
a1109 1
	  inst.error = _("immediate expression requires a # prefix");
d1112 3
a1114 7
      (*str)++;
      break;
    case GE_OPT_PREFIX:
      if (is_immediate_prefix (**str))
	(*str)++;
      break;
    default: abort ();
d1117 3
a1119 1
  memset (ep, 0, sizeof (expressionS));
d1121 1
a1121 48
  save_in = input_line_pointer;
  input_line_pointer = *str;
  in_my_get_expression = 1;
  seg = expression (ep);
  in_my_get_expression = 0;

  if (ep->X_op == O_illegal)
    {
      /* We found a bad expression in md_operand().  */
      *str = input_line_pointer;
      input_line_pointer = save_in;
      if (inst.error == NULL)
	inst.error = _("bad expression");
      return 1;
    }

#ifdef OBJ_AOUT
  if (seg != absolute_section
      && seg != text_section
      && seg != data_section
      && seg != bss_section
      && seg != undefined_section)
    {
      inst.error = _("bad segment");
      *str = input_line_pointer;
      input_line_pointer = save_in;
      return 1;
    }
#endif

  /* Get rid of any bignums now, so that we don't generate an error for which
     we can't establish a line number later on.	 Big numbers are never valid
     in instructions, which is where this routine is always called.  */
  if (ep->X_op == O_big
      || (ep->X_add_symbol
	  && (walk_no_bignums (ep->X_add_symbol)
	      || (ep->X_op_symbol
		  && walk_no_bignums (ep->X_op_symbol)))))
    {
      inst.error = _("invalid constant");
      *str = input_line_pointer;
      input_line_pointer = save_in;
      return 1;
    }

  *str = input_line_pointer;
  input_line_pointer = save_in;
  return 0;
d1124 2
a1125 4
/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.
d1127 6
a1132 11
   Note that fp constants aren't represent in the normal way on the ARM.
   In big endian mode, things are as expected.	However, in little endian
   mode fp constants are big-endian word-wise, and little-endian byte-wise
   within the words.  For example, (double) 1.1 in big endian mode is
   the byte sequence 3f f1 99 99 99 99 99 9a, and in little endian mode is
   the byte sequence 99 99 f1 3f 9a 99 99 99.

   ??? The format of 12 byte floats is uncertain according to gcc's arm.h.  */

char *
md_atof (int type, char * litP, int * sizeP)
d1134 2
a1135 4
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  char *t;
  int i;
d1137 3
a1139 8
  switch (type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;
d1141 4
a1144 6
    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;
d1146 1
a1146 4
    case 'x':
    case 'X':
      prec = 6;
      break;
d1148 3
a1150 4
    case 'p':
    case 'P':
      prec = 6;
      break;
d1152 1
a1152 4
    default:
      *sizeP = 0;
      return _("bad call to MD_ATOF()");
    }
d1154 3
a1156 4
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;
  *sizeP = prec * 2;
d1158 3
a1160 26
  if (target_big_endian)
    {
      for (i = 0; i < prec; i++)
	{
	  md_number_to_chars (litP, (valueT) words[i], 2);
	  litP += 2;
	}
    }
  else
    {
      if (cpu_variant & FPU_ARCH_VFP)
	for (i = prec - 1; i >= 0; i--)
	  {
	    md_number_to_chars (litP, (valueT) words[i], 2);
	    litP += 2;
	  }
      else
	/* For a 4 byte float the order of elements in `words' is 1 0.
	   For an 8 byte float the order is 1 0 3 2.  */
	for (i = 0; i < prec; i += 2)
	  {
	    md_number_to_chars (litP, (valueT) words[i + 1], 2);
	    md_number_to_chars (litP + 2, (valueT) words[i], 2);
	    litP += 4;
	  }
    }
d1162 1
a1162 2
  return 0;
}
d1164 1
a1164 8
/* We handle all bad expressions here, so that we can report the faulty
   instruction in the error message.  */
void
md_operand (expressionS * expr)
{
  if (in_my_get_expression)
    expr->X_op = O_illegal;
}
d1166 3
a1168 1
/* Immediate values.  */
d1170 3
a1172 24
/* Generic immediate-value read function for use in directives.
   Accepts anything that 'expression' can fold to a constant.
   *val receives the number.  */
#ifdef OBJ_ELF
static int
immediate_for_directive (int *val)
{
  expressionS exp;
  exp.X_op = O_illegal;

  if (is_immediate_prefix (*input_line_pointer))
    {
      input_line_pointer++;
      expression (&exp);
    }

  if (exp.X_op != O_constant)
    {
      as_bad (_("expected #constant"));
      ignore_rest_of_line ();
      return FAIL;
    }
  *val = exp.X_add_number;
  return SUCCESS;
a1173 1
#endif
d1175 2
a1176 1
/* Register parsing.  */
d1178 2
a1179 7
/* Generic register parser.  CCP points to what should be the
   beginning of a register name.  If it is indeed a valid register
   name, advance CCP over it and return the reg_entry structure;
   otherwise return NULL.  Does not issue diagnostics.	*/

static struct reg_entry *
arm_reg_parse_multi (char **ccp)
d1181 2
a1182 3
  char *start = *ccp;
  char *p;
  struct reg_entry *reg;
d1184 1
a1184 9
#ifdef REGISTER_PREFIX
  if (*start != REGISTER_PREFIX)
    return FAIL;
  start++;
#endif
#ifdef OPTIONAL_REGISTER_PREFIX
  if (*start == OPTIONAL_REGISTER_PREFIX)
    start++;
#endif
d1186 3
a1188 3
  p = start;
  if (!ISALPHA (*p) || !is_name_beginner (*p))
    return NULL;
d1190 1
a1190 11
  do
    p++;
  while (ISALPHA (*p) || ISDIGIT (*p) || *p == '_');

  reg = (struct reg_entry *) hash_find_n (arm_reg_hsh, start, p - start);

  if (!reg)
    return NULL;

  *ccp = p;
  return reg;
d1193 3
a1195 2
/* As above, but the register must be of type TYPE, and the return
   value is the register number or NULL.  */
d1197 3
a1199 2
static int
arm_reg_parse (char **ccp, enum arm_reg_type type)
d1201 2
a1202 2
  char *start = *ccp;
  struct reg_entry *reg = arm_reg_parse_multi (ccp);
d1204 20
a1223 2
  if (reg && reg->type == type)
    return reg->number;
d1225 1
a1225 18
  /* Alternative syntaxes are accepted for a few register classes.  */
  switch (type)
    {
    case REG_TYPE_MVF:
    case REG_TYPE_MVD:
    case REG_TYPE_MVFX:
    case REG_TYPE_MVDX:
      /* Generic coprocessor register names are allowed for these.  */
      if (reg->type == REG_TYPE_CN)
	return reg->number;
      break;

    case REG_TYPE_CP:
      /* For backward compatibility, a bare number is valid here.  */
      {
	unsigned long processor = strtoul (start, ccp, 10);
	if (*ccp != start && processor <= 15)
	  return processor;
a1227 12
    case REG_TYPE_MMXWC:
      /* WC includes WCG.  ??? I'm not sure this is true for all
	 instructions that take WC registers.  */
      if (reg->type == REG_TYPE_MMXWCG)
	return reg->number;
      break;

    default:
      break;
    }

  *ccp = start;
d1231 2
a1232 3
/* Parse an ARM register list.  Returns the bitmask, or FAIL.  */
static long
parse_reg_list (char ** strp)
d1234 4
a1237 3
  char * str = * strp;
  long	 range = 0;
  int	 another_range;
d1239 6
a1244 4
  /* We come back here if we get ranges concatenated by '+' or '|'.  */
  do
    {
      another_range = 0;
d1246 1
a1246 4
      if (*str == '{')
	{
	  int in_range = 0;
	  int cur_reg = -1;
d1248 6
a1253 4
	  str++;
	  do
	    {
	      int reg;
d1255 4
a1258 5
	      if ((reg = arm_reg_parse (&str, REG_TYPE_RN)) == FAIL)
		{
		  inst.error = _(reg_expected_msgs[REG_TYPE_RN]);
		  return FAIL;
		}
d1260 1
a1260 3
	      if (in_range)
		{
		  int i;
d1262 19
a1280 5
		  if (reg <= cur_reg)
		    {
		      inst.error = _("bad range in register list");
		      return FAIL;
		    }
d1282 1
a1282 11
		  for (i = cur_reg + 1; i < reg; i++)
		    {
		      if (range & (1 << i))
			as_tsktsk
			  (_("Warning: duplicated register (r%d) in register list"),
			   i);
		      else
			range |= 1 << i;
		    }
		  in_range = 0;
		}
d1284 3
a1286 5
	      if (range & (1 << reg))
		as_tsktsk (_("Warning: duplicated register (r%d) in register list"),
			   reg);
	      else if (reg <= cur_reg)
		as_tsktsk (_("Warning: register range not in ascending order"));
d1288 7
a1294 6
	      range |= 1 << reg;
	      cur_reg = reg;
	    }
	  while (skip_past_comma (&str) != FAIL
		 || (in_range = 1, *str++ == '-'));
	  str--;
d1296 5
a1300 9
	  if (*str++ != '}')
	    {
	      inst.error = _("missing `}'");
	      return FAIL;
	    }
	}
      else
	{
	  expressionS expr;
d1302 5
a1306 2
	  if (my_get_expression (&expr, &str, GE_NO_PREFIX))
	    return FAIL;
d1308 1
a1308 8
	  if (expr.X_op == O_constant)
	    {
	      if (expr.X_add_number
		  != (expr.X_add_number & 0x0000ffff))
		{
		  inst.error = _("invalid register mask");
		  return FAIL;
		}
d1310 5
a1314 3
	      if ((range & expr.X_add_number) != 0)
		{
		  int regno = range & expr.X_add_number;
d1316 4
a1319 6
		  regno &= -regno;
		  regno = (1 << regno) - 1;
		  as_tsktsk
		    (_("Warning: duplicated register (r%d) in register list"),
		     regno);
		}
d1321 2
a1322 9
	      range |= expr.X_add_number;
	    }
	  else
	    {
	      if (inst.reloc.type != 0)
		{
		  inst.error = _("expression too complex");
		  return FAIL;
		}
d1324 1
a1324 5
	      memcpy (&inst.reloc.exp, &expr, sizeof (expressionS));
	      inst.reloc.type = BFD_RELOC_ARM_MULTI;
	      inst.reloc.pc_rel = 0;
	    }
	}
d1326 3
a1328 7
      if (*str == '|' || *str == '+')
	{
	  str++;
	  another_range = 1;
	}
    }
  while (another_range);
d1330 3
a1332 2
  *strp = str;
  return range;
d1335 14
a1348 3
/* Parse a VFP register list.  If the string is invalid return FAIL.
   Otherwise return the number of registers, and set PBASE to the first
   register.  Double precision registers are matched if DP is nonzero.	*/
d1351 1
a1351 1
parse_vfp_reg_list (char **str, int *pbase, int dp)
d1353 4
a1356 8
  int base_reg;
  int new_base;
  int regtype;
  int max_regs;
  int count = 0;
  int warned = 0;
  unsigned long mask = 0;
  int i;
d1358 12
a1369 1
  if (**str != '{')
d1372 7
a1378 1
  (*str)++;
d1380 1
a1380 6
  if (dp)
    {
      regtype = REG_TYPE_VFD;
      max_regs = 16;
    }
  else
d1382 2
a1383 2
      regtype = REG_TYPE_VFS;
      max_regs = 32;
d1386 18
a1403 1
  base_reg = max_regs;
d1405 4
a1408 1
  do
d1410 2
a1411 2
      new_base = arm_reg_parse (str, regtype);
      if (new_base == FAIL)
d1413 7
a1419 2
	  inst.error = gettext (reg_expected_msgs[regtype]);
	  return FAIL;
d1421 2
d1424 2
a1425 4
      if (new_base < base_reg)
	base_reg = new_base;

      if (mask & (1 << new_base))
d1427 2
a1428 3
	  inst.error = _("invalid register list");
	  return FAIL;
	}
d1430 1
a1430 5
      if ((mask >> new_base) != 0 && ! warned)
	{
	  as_tsktsk (_("register list not in ascending order"));
	  warned = 1;
	}
d1432 2
a1433 2
      mask |= 1 << new_base;
      count++;
d1435 4
a1438 3
      if (**str == '-') /* We have the start of a range expression */
	{
	  int high_range;
d1440 4
a1443 1
	  (*str)++;
d1445 5
a1449 5
	  if ((high_range = arm_reg_parse (str, regtype)) == FAIL)
	    {
	      inst.error = gettext (reg_expected_msgs[regtype]);
	      return FAIL;
	    }
d1451 2
a1452 5
	  if (high_range <= new_base)
	    {
	      inst.error = _("register range not in ascending order");
	      return FAIL;
	    }
d1454 2
a1455 7
	  for (new_base++; new_base <= high_range; new_base++)
	    {
	      if (mask & (1 << new_base))
		{
		  inst.error = _("invalid register list");
		  return FAIL;
		}
d1457 5
a1461 6
	      mask |= 1 << new_base;
	      count++;
	    }
	}
    }
  while (skip_past_comma (str) != FAIL);
d1463 2
a1464 1
  (*str)++;
d1466 4
a1469 3
  /* Sanity check -- should have raised a parse error above.  */
  if (count == 0 || count > max_regs)
    abort ();
d1471 2
a1472 1
  *pbase = base_reg;
d1474 1
a1474 3
  /* Final test -- the registers must be consecutive.  */
  mask >>= base_reg;
  for (i = 0; i < count; i++)
d1476 3
a1478 1
      if ((mask & (1u << i)) == 0)
d1480 31
a1510 2
	  inst.error = _("non-contiguous register range");
	  return FAIL;
d1512 2
d1515 2
d1518 2
a1519 1
  return count;
d1522 2
a1523 7
/* Parse an explicit relocation suffix on an expression.  This is
   either nothing, or a word in parentheses.  Note that if !OBJ_ELF,
   arm_reloc_hsh contains no entries, so this function can only
   succeed if there is no () after the word.  Returns -1 on error,
   BFD_RELOC_UNUSED if there wasn't any suffix.	 */
static int
parse_reloc (char **str)
d1525 6
a1530 2
  struct reloc_entry *r;
  char *p, *q;
d1532 6
a1537 2
  if (**str != '(')
    return BFD_RELOC_UNUSED;
d1539 1
a1539 2
  p = *str + 1;
  q = p;
d1541 1
a1541 10
  while (*q && *q != ')' && *q != ',')
    q++;
  if (*q != ')')
    return -1;

  if ((r = hash_find_n (arm_reloc_hsh, p, q - p)) == NULL)
    return -1;

  *str = q + 1;
  return r->reloc;
a1543 2
/* Directives: register aliases.  */

d1545 1
a1545 1
insert_reg_alias (char *str, int number, int type)
d1547 11
a1557 2
  struct reg_entry *new;
  const char *name;
d1559 4
a1562 4
  if ((new = hash_find (arm_reg_hsh, str)) != 0)
    {
      if (new->builtin)
	as_warn (_("ignoring attempt to redefine built-in register '%s'"), str);
d1564 1
a1564 4
      /* Only warn about a redefinition if it's not defined as the
	 same register.	 */
      else if (new->number != number || new->type != type)
	as_warn (_("ignoring redefinition of register alias '%s'"), str);
d1566 1
a1566 2
      return;
    }
d1568 3
a1570 2
  name = xstrdup (str);
  new = xmalloc (sizeof (struct reg_entry));
d1572 1
a1572 4
  new->name = name;
  new->number = number;
  new->type = type;
  new->builtin = FALSE;
d1574 3
a1576 3
  if (hash_insert (arm_reg_hsh, name, (PTR) new))
    abort ();
}
d1578 3
a1580 1
/* Look for the .req directive.	 This is of the form:
d1582 4
a1585 1
	new_register_name .req existing_register_name
d1587 1
a1587 2
   If we find one, or if it looks sufficiently like one that we want to
   handle any error here, return non-zero.  Otherwise return zero.  */
d1589 2
a1590 2
static int
create_register_alias (char * newname, char *p)
d1592 3
a1594 9
  struct reg_entry *old;
  char *oldname, *nbuf;
  size_t nlen;

  /* The input scrubber ensures that whitespace after the mnemonic is
     collapsed to single spaces.  */
  oldname = p;
  if (strncmp (oldname, " .req ", 6) != 0)
    return 0;
d1596 8
a1603 3
  oldname += 6;
  if (*oldname == '\0')
    return 0;
d1605 1
a1605 2
  old = hash_find (arm_reg_hsh, oldname);
  if (!old)
d1607 2
a1608 2
      as_warn (_("unknown register '%s' -- .req ignored"), oldname);
      return 1;
d1610 2
d1613 2
a1614 9
  /* If TC_CASE_SENSITIVE is defined, then newname already points to
     the desired alias name, and p points to its end.  If not, then
     the desired alias name is in the global original_case_string.  */
#ifdef TC_CASE_SENSITIVE
  nlen = p - newname;
#else
  newname = original_case_string;
  nlen = strlen (newname);
#endif
d1616 4
a1619 3
  nbuf = alloca (nlen + 1);
  memcpy (nbuf, newname, nlen);
  nbuf[nlen] = '\0';
d1621 1
a1621 18
  /* Create aliases under the new name as stated; an all-lowercase
     version of the new name; and an all-uppercase version of the new
     name.  */
  insert_reg_alias (nbuf, old->number, old->type);

  for (p = nbuf; *p; p++)
    *p = TOUPPER (*p);

  if (strncmp (nbuf, newname, nlen))
    insert_reg_alias (nbuf, old->number, old->type);

  for (p = nbuf; *p; p++)
    *p = TOLOWER (*p);

  if (strncmp (nbuf, newname, nlen))
    insert_reg_alias (nbuf, old->number, old->type);

  return 1;
a1623 2
/* Should never be called, as .req goes between the alias and the
   register name, not at the beginning of the line.  */
d1625 1
a1625 1
s_req (int a ATTRIBUTE_UNUSED)
d1627 8
a1634 2
  as_bad (_("invalid syntax for .req directive"));
}
d1636 2
a1637 2
/* The .unreq directive deletes an alias which was previously defined
   by .req.  For example:
d1639 2
a1640 2
       my_alias .req r11
       .unreq my_alias	  */
d1643 1
a1643 1
s_unreq (int a ATTRIBUTE_UNUSED)
d1645 2
a1646 2
  char * name;
  char saved_char;
d1648 3
a1650 28
  name = input_line_pointer;

  while (*input_line_pointer != 0
	 && *input_line_pointer != ' '
	 && *input_line_pointer != '\n')
    ++input_line_pointer;

  saved_char = *input_line_pointer;
  *input_line_pointer = 0;

  if (!*name)
    as_bad (_("invalid syntax for .unreq directive"));
  else
    {
      struct reg_entry *reg = hash_find (arm_reg_hsh, name);

      if (!reg)
	as_bad (_("unknown register alias '%s'"), name);
      else if (reg->builtin)
	as_warn (_("ignoring attempt to undefine built-in register '%s'"),
		 name);
      else
	{
	  hash_delete (arm_reg_hsh, name);
	  free ((char *) reg->name);
	  free (reg);
	}
    }
a1651 1
  *input_line_pointer = saved_char;
d1655 2
a1656 9
/* Directives: Instruction set selection.  */

#ifdef OBJ_ELF
/* This code is to handle mapping symbols as defined in the ARM ELF spec.
   (See "Mapping symbols", section 4.5.5, ARM AAELF version 1.0).
   Note that previously, $a and $t has type STT_FUNC (BSF_OBJECT flag),
   and $d has type STT_OBJECT (BSF_OBJECT flag). Now all three are untyped.  */

static enum mstate mapstate = MAP_UNDEFINED;
d1659 1
a1659 1
mapping_state (enum mstate state)
d1661 6
a1667 2
  const char * symname;
  int type;
d1669 7
a1675 4
  if (mapstate == state)
    /* The mapping symbol has already been emitted.
       There is nothing else to do.  */
    return;
d1677 1
a1677 1
  mapstate = state;
d1679 1
a1679 208
  switch (state)
    {
    case MAP_DATA:
      symname = "$d";
      type = BSF_NO_FLAGS;
      break;
    case MAP_ARM:
      symname = "$a";
      type = BSF_NO_FLAGS;
      break;
    case MAP_THUMB:
      symname = "$t";
      type = BSF_NO_FLAGS;
      break;
    case MAP_UNDEFINED:
      return;
    default:
      abort ();
    }

  seg_info (now_seg)->tc_segment_info_data.mapstate = state;

  symbolP = symbol_new (symname, now_seg, (valueT) frag_now_fix (), frag_now);
  symbol_table_insert (symbolP);
  symbol_get_bfdsym (symbolP)->flags |= type | BSF_LOCAL;

  switch (state)
    {
    case MAP_ARM:
      THUMB_SET_FUNC (symbolP, 0);
      ARM_SET_THUMB (symbolP, 0);
      ARM_SET_INTERWORK (symbolP, support_interwork);
      break;

    case MAP_THUMB:
      THUMB_SET_FUNC (symbolP, 1);
      ARM_SET_THUMB (symbolP, 1);
      ARM_SET_INTERWORK (symbolP, support_interwork);
      break;

    case MAP_DATA:
    default:
      return;
    }
}
#else
#define mapping_state(x) /* nothing */
#endif

/* Find the real, Thumb encoded start of a Thumb function.  */

static symbolS *
find_real_start (symbolS * symbolP)
{
  char *       real_start;
  const char * name = S_GET_NAME (symbolP);
  symbolS *    new_target;

  /* This definition must agree with the one in gcc/config/arm/thumb.c.	 */
#define STUB_NAME ".real_start_of"

  if (name == NULL)
    abort ();

  /* Names that start with '.' are local labels, not function entry points.
     The compiler may generate BL instructions to these labels because it
     needs to perform a branch to a far away location.	*/
  if (name[0] == '.')
    return symbolP;

  real_start = malloc (strlen (name) + strlen (STUB_NAME) + 1);
  sprintf (real_start, "%s%s", STUB_NAME, name);

  new_target = symbol_find (real_start);

  if (new_target == NULL)
    {
      as_warn ("Failed to find real start of function: %s\n", name);
      new_target = symbolP;
    }

  free (real_start);

  return new_target;
}

static void
opcode_select (int width)
{
  switch (width)
    {
    case 16:
      if (! thumb_mode)
	{
	  if (! (cpu_variant & ARM_EXT_V4T))
	    as_bad (_("selected processor does not support THUMB opcodes"));

	  thumb_mode = 1;
	  /* No need to force the alignment, since we will have been
	     coming from ARM mode, which is word-aligned.  */
	  record_alignment (now_seg, 1);
	}
      mapping_state (MAP_THUMB);
      break;

    case 32:
      if (thumb_mode)
	{
	  if ((cpu_variant & ARM_ALL) == ARM_EXT_V4T)
	    as_bad (_("selected processor does not support ARM opcodes"));

	  thumb_mode = 0;

	  if (!need_pass_2)
	    frag_align (2, 0, 0);

	  record_alignment (now_seg, 1);
	}
      mapping_state (MAP_ARM);
      break;

    default:
      as_bad (_("invalid instruction size selected (%d)"), width);
    }
}

static void
s_arm (int ignore ATTRIBUTE_UNUSED)
{
  opcode_select (32);
  demand_empty_rest_of_line ();
}

static void
s_thumb (int ignore ATTRIBUTE_UNUSED)
{
  opcode_select (16);
  demand_empty_rest_of_line ();
}

static void
s_code (int unused ATTRIBUTE_UNUSED)
{
  int temp;

  temp = get_absolute_expression ();
  switch (temp)
    {
    case 16:
    case 32:
      opcode_select (temp);
      break;

    default:
      as_bad (_("invalid operand to .code directive (%d) (expecting 16 or 32)"), temp);
    }
}

static void
s_force_thumb (int ignore ATTRIBUTE_UNUSED)
{
  /* If we are not already in thumb mode go into it, EVEN if
     the target processor does not support thumb instructions.
     This is used by gcc/config/arm/lib1funcs.asm for example
     to compile interworking support functions even if the
     target processor should not support interworking.	*/
  if (! thumb_mode)
    {
      thumb_mode = 2;
      record_alignment (now_seg, 1);
    }

  demand_empty_rest_of_line ();
}

static void
s_thumb_func (int ignore ATTRIBUTE_UNUSED)
{
  s_thumb (0);

  /* The following label is the name/address of the start of a Thumb function.
     We need to know this for the interworking support.	 */
  label_is_thumb_function_name = TRUE;
}

/* Perform a .set directive, but also mark the alias as
   being a thumb function.  */

static void
s_thumb_set (int equiv)
{
  /* XXX the following is a duplicate of the code for s_set() in read.c
     We cannot just call that code as we need to get at the symbol that
     is created.  */
  char *    name;
  char	    delim;
  char *    end_name;
  symbolS * symbolP;

  /* Especial apologies for the random logic:
     This just grew, and could be parsed much more simply!
     Dean - in haste.  */
  name	    = input_line_pointer;
  delim	    = get_symbol_end ();
  end_name  = input_line_pointer;
  *end_name = delim;

  if (*input_line_pointer != ',')
d1703 1
a1703 1
	 for this symbol.  */
d1738 1
a1738 1
  /* XXX Now we come to the Thumb specific bit of code.	 */
d1747 6
a1752 1
/* Directives: Mode selection.  */
a1753 3
/* .syntax [unified|divided] - choose the new unified syntax
   (same for Arm and Thumb encoding, modulo slight differences in what
   can be represented) or the old divergent syntax for each mode.  */
d1755 1
a1755 1
s_syntax (int unused ATTRIBUTE_UNUSED)
d1757 1
a1757 15
  char *name, delim;

  name = input_line_pointer;
  delim = get_symbol_end ();

  if (!strcasecmp (name, "unified"))
    unified_syntax = TRUE;
  else if (!strcasecmp (name, "divided"))
    unified_syntax = FALSE;
  else
    {
      as_bad (_("unrecognized syntax mode \"%s\""), name);
      return;
    }
  *input_line_pointer = delim;
a1760 4
/* Directives: sectioning and alignment.  */

/* Same as s_align_ptwo but align 0 => align 2.	 */

d1762 1
a1762 1
s_align (int unused ATTRIBUTE_UNUSED)
a1764 2
  long temp_fill;
  long max_alignment = 15;
d1767 1
a1767 3
  if (temp > max_alignment)
    as_bad (_("alignment too large: %d assumed"), temp = max_alignment);
  else if (temp < 0)
d1769 4
a1772 3
      as_bad (_("alignment negative. 0 assumed."));
      temp = 0;
    }
d1774 2
a1775 4
  if (*input_line_pointer == ',')
    {
      input_line_pointer++;
      temp_fill = get_absolute_expression ();
d1777 1
a1777 2
  else
    temp_fill = 0;
d1779 4
a1782 2
  if (!temp)
    temp = 2;
d1784 2
a1785 6
  /* Only make a frag if we HAVE to.  */
  if (temp && !need_pass_2)
    frag_align (temp, (int) temp_fill, 0);
  demand_empty_rest_of_line ();

  record_alignment (now_seg, temp);
d1788 2
a1789 2
static void
s_bss (int ignore ATTRIBUTE_UNUSED)
d1791 9
a1799 6
  /* We don't support putting frags in the BSS segment, we fake it by
     marking in_bss, then looking at s_skip for clues.	*/
  subseg_set (bss_section, 0);
  demand_empty_rest_of_line ();
  mapping_state (MAP_DATA);
}
d1801 2
a1802 6
static void
s_even (int ignore ATTRIBUTE_UNUSED)
{
  /* Never make frag if expect extra pass.  */
  if (!need_pass_2)
    frag_align (1, 0, 0);
d1804 2
a1805 3
  record_alignment (now_seg, 1);

  demand_empty_rest_of_line ();
d1808 1
a1808 1
/* Directives: Literal pools.  */
d1810 2
a1811 2
static literal_pool *
find_literal_pool (void)
d1813 2
a1814 1
  literal_pool * pool;
d1816 1
a1816 1
  for (pool = list_of_pools; pool != NULL; pool = pool->next)
d1818 3
a1820 3
      if (pool->section == now_seg
	  && pool->sub_section == now_subseg)
	break;
d1823 1
a1823 1
  return pool;
d1826 4
a1829 2
static literal_pool *
find_or_make_literal_pool (void)
d1831 2
a1832 3
  /* Next literal pool ID number.  */
  static unsigned int latest_pool_num = 1;
  literal_pool *      pool;
d1834 5
a1838 1
  pool = find_literal_pool ();
d1840 1
a1840 1
  if (pool == NULL)
d1842 5
a1846 4
      /* Create a new pool.  */
      pool = xmalloc (sizeof (* pool));
      if (! pool)
	return NULL;
d1848 11
a1858 8
      pool->next_free_entry = 0;
      pool->section	    = now_seg;
      pool->sub_section	    = now_subseg;
      pool->next	    = list_of_pools;
      pool->symbol	    = NULL;

      /* Add it to the list.  */
      list_of_pools = pool;
d1860 1
d1862 8
a1869 2
  /* New pools, and emptied pools, will have a NULL symbol.  */
  if (pool->symbol == NULL)
d1871 4
a1874 3
      pool->symbol = symbol_create (FAKE_LABEL_NAME, undefined_section,
				    (valueT) 0, &zero_address_frag);
      pool->id = latest_pool_num ++;
d1877 3
a1879 2
  /* Done.  */
  return pool;
d1882 4
a1885 2
/* Add the literal in the global 'inst'
   structure to the relevent literal pool.  */
d1888 1
a1888 1
add_to_lit_pool (void)
d1890 3
a1892 4
  literal_pool * pool;
  unsigned int entry;

  pool = find_or_make_literal_pool ();
d1894 1
a1894 2
  /* Check if this literal value is already in the pool.  */
  for (entry = 0; entry < pool->next_free_entry; entry ++)
d1896 3
a1898 17
      if ((pool->literals[entry].X_op == inst.reloc.exp.X_op)
	  && (inst.reloc.exp.X_op == O_constant)
	  && (pool->literals[entry].X_add_number
	      == inst.reloc.exp.X_add_number)
	  && (pool->literals[entry].X_unsigned
	      == inst.reloc.exp.X_unsigned))
	break;

      if ((pool->literals[entry].X_op == inst.reloc.exp.X_op)
	  && (inst.reloc.exp.X_op == O_symbol)
	  && (pool->literals[entry].X_add_number
	      == inst.reloc.exp.X_add_number)
	  && (pool->literals[entry].X_add_symbol
	      == inst.reloc.exp.X_add_symbol)
	  && (pool->literals[entry].X_op_symbol
	      == inst.reloc.exp.X_op_symbol))
	break;
d1901 2
a1902 12
  /* Do we need to create a new entry?	*/
  if (entry == pool->next_free_entry)
    {
      if (entry >= MAX_LITERAL_POOL_SIZE)
	{
	  inst.error = _("literal pool overflow");
	  return FAIL;
	}

      pool->literals[entry] = inst.reloc.exp;
      pool->next_free_entry += 1;
    }
d1904 4
a1907 3
  inst.reloc.exp.X_op	      = O_symbol;
  inst.reloc.exp.X_add_number = ((int) entry) * 4;
  inst.reloc.exp.X_add_symbol = pool->symbol;
d1909 1
a1909 1
  return SUCCESS;
d1912 5
a1916 2
/* Can't use symbol_new here, so have to create a symbol and then at
   a later date assign it a value. Thats what these functions do.  */
d1918 40
a1957 9
static void
symbol_locate (symbolS *    symbolP,
	       const char * name,	/* It is copied, the caller can modify.	 */
	       segT	    segment,	/* Segment identifier (SEG_<something>).  */
	       valueT	    valu,	/* Symbol value.  */
	       fragS *	    frag)	/* Associated fragment.	 */
{
  unsigned int name_length;
  char * preserved_copy_of_name;
d1959 2
a1960 3
  name_length = strlen (name) + 1;   /* +1 for \0.  */
  obstack_grow (&notes, name, name_length);
  preserved_copy_of_name = obstack_finish (&notes);
d1962 7
a1968 4
#ifdef tc_canonicalize_symbol_name
  preserved_copy_of_name =
    tc_canonicalize_symbol_name (preserved_copy_of_name);
#endif
d1970 1
a1970 1
  S_SET_NAME (symbolP, preserved_copy_of_name);
d1972 6
a1977 3
  S_SET_SEGMENT (symbolP, segment);
  S_SET_VALUE (symbolP, valu);
  symbol_clear_list_pointers (symbolP);
d1979 2
a1980 1
  symbol_set_frag (symbolP, frag);
d1982 6
a1987 3
  /* Link to end of symbol chain.  */
  {
    extern int symbol_table_frozen;
d1989 2
a1990 3
    if (symbol_table_frozen)
      abort ();
  }
d1992 2
a1993 1
  symbol_append (symbolP, symbol_lastP, & symbol_rootP, & symbol_lastP);
d1995 3
a1997 5
  obj_symbol_new_hook (symbolP);

#ifdef tc_symbol_new_hook
  tc_symbol_new_hook (symbolP);
#endif
d1999 1
a1999 3
#ifdef DEBUG_SYMS
  verify_symbol_chain (symbol_rootP, symbol_lastP);
#endif /* DEBUG_SYMS  */
d2002 1
d2004 2
a2005 2
static void
s_ltorg (int ignored ATTRIBUTE_UNUSED)
d2007 4
a2010 3
  unsigned int entry;
  literal_pool * pool;
  char sym_name[20];
d2012 5
a2016 5
  pool = find_literal_pool ();
  if (pool == NULL
      || pool->symbol == NULL
      || pool->next_free_entry == 0)
    return;
d2018 2
a2019 1
  mapping_state (MAP_DATA);
d2021 2
a2022 4
  /* Align pool as you have word accesses.
     Only make a frag if we have to.  */
  if (!need_pass_2)
    frag_align (2, 0, 0);
d2024 3
a2026 1
  record_alignment (now_seg, 2);
d2028 4
a2031 1
  sprintf (sym_name, "$$lit_\002%x", pool->id);
d2033 5
a2037 3
  symbol_locate (pool->symbol, sym_name, now_seg,
		 (valueT) frag_now_fix (), frag_now);
  symbol_table_insert (pool->symbol);
d2039 2
a2040 1
  ARM_SET_THUMB (pool->symbol, thumb_mode);
d2042 7
a2048 3
#if defined OBJ_COFF || defined OBJ_ELF
  ARM_SET_INTERWORK (pool->symbol, support_interwork);
#endif
d2050 20
a2069 3
  for (entry = 0; entry < pool->next_free_entry; entry ++)
    /* First output the expression in the instruction to the pool.  */
    emit_expr (&(pool->literals[entry]), 4); /* .word  */
d2071 2
a2072 3
  /* Mark the pool as empty.  */
  pool->next_free_entry = 0;
  pool->symbol = NULL;
d2075 4
a2078 8
#ifdef OBJ_ELF
/* Forward declarations for functions below, in the MD interface
   section.  */
static void fix_new_arm (fragS *, int, short, expressionS *, int, int);
static valueT create_unwind_entry (int);
static void start_unwind_section (const segT, int);
static void add_unwind_opcode (valueT, int);
static void flush_pending_unwind (void);
d2080 1
a2080 1
/* Directives: Data.  */
d2082 1
a2082 4
static void
s_arm_elf_cons (int nbytes)
{
  expressionS exp;
d2084 3
a2086 5
#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  if (is_it_end_of_statement ())
d2088 2
a2089 2
      demand_empty_rest_of_line ();
      return;
d2092 15
a2106 3
#ifdef md_cons_align
  md_cons_align (nbytes);
#endif
d2108 1
a2108 2
  mapping_state (MAP_DATA);
  do
d2110 3
a2112 2
      int reloc;
      char *base = input_line_pointer;
d2114 8
a2121 1
      expression (& exp);
d2123 5
a2127 18
      if (exp.X_op != O_symbol)
	emit_expr (&exp, (unsigned int) nbytes);
      else
	{
	  char *before_reloc = input_line_pointer;
	  reloc = parse_reloc (&input_line_pointer);
	  if (reloc == -1)
	    {
	      as_bad (_("unrecognized relocation suffix"));
	      ignore_rest_of_line ();
	      return;
	    }
	  else if (reloc == BFD_RELOC_UNUSED)
	    emit_expr (&exp, (unsigned int) nbytes);
	  else
	    {
	      reloc_howto_type *howto = bfd_reloc_type_lookup (stdoutput, reloc);
	      int size = bfd_get_reloc_size (howto);
d2129 4
a2132 27
	      if (size > nbytes)
		as_bad ("%s relocations do not fit in %d bytes",
			howto->name, nbytes);
	      else
		{
		  /* We've parsed an expression stopping at O_symbol.
		     But there may be more expression left now that we
		     have parsed the relocation marker.  Parse it again.
		     XXX Surely there is a cleaner way to do this.  */
		  char *p = input_line_pointer;
		  int offset;
		  char *save_buf = alloca (input_line_pointer - base);
		  memcpy (save_buf, base, input_line_pointer - base);
		  memmove (base + (input_line_pointer - before_reloc),
			   base, before_reloc - base);

		  input_line_pointer = base + (input_line_pointer-before_reloc);
		  expression (&exp);
		  memcpy (base, save_buf, p - base);

		  offset = nbytes - size;
		  p = frag_more ((int) nbytes);
		  fix_new_exp (frag_now, p - frag_now->fr_literal + offset,
			       size, &exp, 0, reloc);
		}
	    }
	}
a2133 1
  while (*input_line_pointer++ == ',');
d2135 7
a2141 3
  /* Put terminator back into stream.  */
  input_line_pointer --;
  demand_empty_rest_of_line ();
d2144 4
d2149 1
a2149 1
/* Parse a .rel31 directive.  */
d2151 5
a2155 6
static void
s_arm_rel31 (int ignored ATTRIBUTE_UNUSED)
{
  expressionS exp;
  char *p;
  valueT highbit;
d2157 1
a2157 5
  highbit = 0;
  if (*input_line_pointer == '1')
    highbit = 0x80000000;
  else if (*input_line_pointer != '0')
    as_bad (_("expected 0 or 1"));
d2159 2
a2160 4
  input_line_pointer++;
  if (*input_line_pointer != ',')
    as_bad (_("missing comma"));
  input_line_pointer++;
d2162 3
a2164 3
#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif
d2166 5
a2170 3
#ifdef md_cons_align
  md_cons_align (4);
#endif
d2172 5
a2176 1
  mapping_state (MAP_DATA);
d2178 4
a2181 1
  expression (&exp);
d2183 4
a2186 4
  p = frag_more (4);
  md_number_to_chars (p, highbit, 4);
  fix_new_arm (frag_now, p - frag_now->fr_literal, 4, &exp, 1,
	       BFD_RELOC_ARM_PREL31);
d2188 1
a2188 1
  demand_empty_rest_of_line ();
d2191 6
a2196 1
/* Directives: AEABI stack-unwind tables.  */
d2198 3
a2200 1
/* Parse an unwind_fnstart directive.  Simply records the current location.  */
d2202 2
a2203 6
static void
s_arm_unwind_fnstart (int ignored ATTRIBUTE_UNUSED)
{
  demand_empty_rest_of_line ();
  /* Mark the start of the function.  */
  unwind.proc_start = expr_build_dot ();
d2205 2
a2206 11
  /* Reset the rest of the unwind info.	 */
  unwind.opcode_count = 0;
  unwind.table_entry = NULL;
  unwind.personality_routine = NULL;
  unwind.personality_index = -1;
  unwind.frame_size = 0;
  unwind.fp_offset = 0;
  unwind.fp_reg = 13;
  unwind.fp_used = 0;
  unwind.sp_restored = 0;
}
d2208 1
d2210 3
a2212 2
/* Parse a handlerdata directive.  Creates the exception handling table entry
   for the function.  */
d2214 1
a2214 6
static void
s_arm_unwind_handlerdata (int ignored ATTRIBUTE_UNUSED)
{
  demand_empty_rest_of_line ();
  if (unwind.table_entry)
    as_bad (_("dupicate .handlerdata directive"));
d2216 10
a2225 2
  create_unwind_entry (1);
}
d2227 5
a2231 1
/* Parse an unwind_fnend directive.  Generates the index table entry.  */
d2233 1
a2233 6
static void
s_arm_unwind_fnend (int ignored ATTRIBUTE_UNUSED)
{
  long where;
  char *ptr;
  valueT val;
d2235 6
a2240 1
  demand_empty_rest_of_line ();
d2242 5
a2246 5
  /* Add eh table entry.  */
  if (unwind.table_entry == NULL)
    val = create_unwind_entry (0);
  else
    val = 0;
d2248 9
a2256 4
  /* Add index table entry.  This is two words.	 */
  start_unwind_section (unwind.saved_seg, 1);
  frag_align (2, 0, 0);
  record_alignment (now_seg, 2);
d2258 2
a2259 2
  ptr = frag_more (8);
  where = frag_now_fix () - 8;
d2261 1
a2261 3
  /* Self relative offset of the function start.  */
  fix_new (frag_now, where, 4, unwind.proc_start, 0, 1,
	   BFD_RELOC_ARM_PREL31);
d2263 2
a2264 16
  /* Indicate dependency on EHABI-defined personality routines to the
     linker, if it hasn't been done already.  */
  if (unwind.personality_index >= 0 && unwind.personality_index < 3
      && !(marked_pr_dependency & (1 << unwind.personality_index)))
    {
      static const char *const name[] = {
	"__aeabi_unwind_cpp_pr0",
	"__aeabi_unwind_cpp_pr1",
	"__aeabi_unwind_cpp_pr2"
      };
      symbolS *pr = symbol_find_or_make (name[unwind.personality_index]);
      fix_new (frag_now, where, 0, pr, 0, 1, BFD_RELOC_NONE);
      marked_pr_dependency |= 1 << unwind.personality_index;
      seg_info (now_seg)->tc_segment_info_data.marked_pr_dependency
	= marked_pr_dependency;
    }
d2266 3
a2268 7
  if (val)
    /* Inline exception table entry.  */
    md_number_to_chars (ptr + 4, val, 4);
  else
    /* Self relative offset of the table entry.	 */
    fix_new (frag_now, where + 4, 4, unwind.table_entry, 0, 1,
	     BFD_RELOC_ARM_PREL31);
d2270 5
a2274 3
  /* Restore the original section.  */
  subseg_set (unwind.saved_seg, unwind.saved_subseg);
}
d2276 1
d2278 27
a2304 1
/* Parse an unwind_cantunwind directive.  */
d2306 5
a2310 6
static void
s_arm_unwind_cantunwind (int ignored ATTRIBUTE_UNUSED)
{
  demand_empty_rest_of_line ();
  if (unwind.personality_routine || unwind.personality_index != -1)
    as_bad (_("personality routine specified for cantunwind frame"));
d2312 1
a2312 2
  unwind.personality_index = -2;
}
d2314 2
d2317 1
a2317 1
/* Parse a personalityindex directive.	*/
d2319 5
a2323 4
static void
s_arm_unwind_personalityindex (int ignored ATTRIBUTE_UNUSED)
{
  expressionS exp;
d2325 1
a2325 2
  if (unwind.personality_routine || unwind.personality_index != -1)
    as_bad (_("duplicate .personalityindex directive"));
d2327 7
a2333 1
  expression (&exp);
d2335 6
a2340 2
  if (exp.X_op != O_constant
      || exp.X_add_number < 0 || exp.X_add_number > 15)
d2342 8
a2349 3
      as_bad (_("bad personality routine number"));
      ignore_rest_of_line ();
      return;
d2352 3
a2354 3
  unwind.personality_index = exp.X_add_number;

  demand_empty_rest_of_line ();
d2357 4
d2362 1
a2362 1
/* Parse a personality directive.  */
d2364 5
a2368 4
static void
s_arm_unwind_personality (int ignored ATTRIBUTE_UNUSED)
{
  char *name, *p, c;
d2370 1
a2370 2
  if (unwind.personality_routine || unwind.personality_index != -1)
    as_bad (_("duplicate .personality directive"));
d2372 17
a2388 7
  name = input_line_pointer;
  c = get_symbol_end ();
  p = input_line_pointer;
  unwind.personality_routine = symbol_find_or_make (name);
  *p = c;
  demand_empty_rest_of_line ();
}
d2390 4
d2395 2
a2396 1
/* Parse a directive saving core registers.  */
d2398 2
a2399 2
static void
s_arm_unwind_save_core (void)
d2401 3
a2403 3
  valueT op;
  long range;
  int n;
d2405 1
a2405 2
  range = parse_reg_list (&input_line_pointer);
  if (range == FAIL)
d2407 4
a2410 4
      as_bad (_("expected register list"));
      ignore_rest_of_line ();
      return;
    }
d2412 2
a2413 1
  demand_empty_rest_of_line ();
d2415 1
a2415 11
  /* Turn .unwind_movsp ip followed by .unwind_save {..., ip, ...}
     into .unwind_save {..., sp...}.  We aren't bothered about the value of
     ip because it is clobbered by calls.  */
  if (unwind.sp_restored && unwind.fp_reg == 12
      && (range & 0x3000) == 0x1000)
    {
      unwind.opcode_count--;
      unwind.sp_restored = 0;
      range = (range | 0x2000) & ~0x1000;
      unwind.pending_offset = 0;
    }
d2417 58
a2474 7
  /* See if we can use the short opcodes.  These pop a block of upto 8
     registers starting with r4, plus maybe r14.  */
  for (n = 0; n < 8; n++)
    {
      /* Break at the first non-saved register.	 */
      if ((range & (1 << (n + 4))) == 0)
	break;
d2476 1
a2476 2
  /* See if there are any other bits set.  */
  if (n == 0 || (range & (0xfff0 << n) & 0xbff0) != 0)
d2478 8
a2485 3
      /* Use the long form.  */
      op = 0x8000 | ((range >> 4) & 0xfff);
      add_unwind_opcode (op, 2);
d2487 11
a2497 1
  else
d2499 4
a2502 3
      /* Use the short form.  */
      if (range & 0x4000)
	op = 0xa8; /* Pop r14.	*/
d2504 15
a2518 4
	op = 0xa0; /* Do not pop r14.  */
      op |= (n - 1);
      add_unwind_opcode (op, 1);
    }
d2520 3
a2522 5
  /* Pop r0-r3.	 */
  if (range & 0xf)
    {
      op = 0xb100 | (range & 0xf);
      add_unwind_opcode (op, 2);
d2525 1
a2525 6
  /* Record the number of bytes pushed.	 */
  for (n = 0; n < 16; n++)
    {
      if (range & (1 << n))
	unwind.frame_size += 4;
    }
d2528 6
a2533 2

/* Parse a directive saving FPA registers.  */
d2536 1
a2536 1
s_arm_unwind_save_fpa (int reg)
d2538 1
a2538 3
  expressionS exp;
  int num_regs;
  valueT op;
d2540 2
a2541 5
  /* Get Number of registers to transfer.  */
  if (skip_past_comma (&input_line_pointer) != FAIL)
    expression (&exp);
  else
    exp.X_op = O_illegal;
d2543 1
a2543 1
  if (exp.X_op != O_constant)
d2545 1
a2545 2
      as_bad (_("expected , <constant>"));
      ignore_rest_of_line ();
d2549 1
a2549 3
  num_regs = exp.X_add_number;

  if (num_regs < 1 || num_regs > 4)
d2551 1
a2551 2
      as_bad (_("number of registers must be in the range [1:4]"));
      ignore_rest_of_line ();
d2555 1
a2555 1
  demand_empty_rest_of_line ();
d2557 11
a2567 6
  if (reg == 4)
    {
      /* Short form.  */
      op = 0xb4 | (num_regs - 1);
      add_unwind_opcode (op, 1);
    }
d2570 2
a2571 3
      /* Long form.  */
      op = 0xc800 | (reg << 4) | (num_regs - 1);
      add_unwind_opcode (op, 2);
d2573 6
a2578 1
  unwind.frame_size += num_regs * 12;
d2581 3
a2583 2

/* Parse a directive saving VFP registers.  */
d2586 1
a2586 1
s_arm_unwind_save_vfp (void)
d2588 4
a2591 3
  int count;
  int reg;
  valueT op;
d2593 1
a2593 2
  count = parse_vfp_reg_list (&input_line_pointer, &reg, 1);
  if (count == FAIL)
d2595 1
a2595 2
      as_bad (_("expected register list"));
      ignore_rest_of_line ();
d2599 1
a2599 1
  demand_empty_rest_of_line ();
d2601 1
a2601 1
  if (reg == 8)
d2603 3
a2605 3
      /* Short form.  */
      op = 0xb8 | (count - 1);
      add_unwind_opcode (op, 1);
d2607 2
a2608 1
  else
d2610 3
a2612 3
      /* Long form.  */
      op = 0xb300 | (reg << 4) | (count - 1);
      add_unwind_opcode (op, 2);
a2613 2
  unwind.frame_size += count * 8 + 4;
}
d2615 2
d2618 6
a2623 1
/* Parse a directive saving iWMMXt data registers.  */
d2625 1
a2625 8
static void
s_arm_unwind_save_mmxwr (void)
{
  int reg;
  int hi_reg;
  int i;
  unsigned mask = 0;
  valueT op;
d2627 6
a2632 4
  if (*input_line_pointer == '{')
    input_line_pointer++;

  do
d2634 1
a2634 1
      reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWR);
d2636 1
a2636 1
      if (reg == FAIL)
d2638 2
a2639 2
	  as_bad (_(reg_expected_msgs[REG_TYPE_MMXWR]));
	  goto error;
d2642 12
a2653 3
      if (mask >> reg)
	as_tsktsk (_("register list not in ascending order"));
      mask |= 1 << reg;
d2655 4
a2658 19
      if (*input_line_pointer == '-')
	{
	  input_line_pointer++;
	  hi_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWR);
	  if (hi_reg == FAIL)
	    {
	      as_bad (_(reg_expected_msgs[REG_TYPE_MMXWR]));
	      goto error;
	    }
	  else if (reg >= hi_reg)
	    {
	      as_bad (_("bad register range"));
	      goto error;
	    }
	  for (; reg < hi_reg; reg++)
	    mask |= 1 << reg;
	}
    }
  while (skip_past_comma (&input_line_pointer) != FAIL);
d2660 2
a2661 2
  if (*input_line_pointer == '}')
    input_line_pointer++;
d2663 5
a2667 1
  demand_empty_rest_of_line ();
d2669 6
a2674 3
  /* Generate any deferred opcodes becuuse we're going to be looking at
     the list.	*/
  flush_pending_unwind ();
d2676 2
a2677 1
  for (i = 0; i < 16; i++)
d2679 2
a2680 2
      if (mask & (1 << i))
	unwind.frame_size += 8;
d2683 6
a2688 4
  /* Attempt to combine with a previous opcode.	 We do this because gcc
     likes to output separate unwind directives for a single block of
     registers.	 */
  if (unwind.opcode_count > 0)
d2690 2
a2691 30
      i = unwind.opcodes[unwind.opcode_count - 1];
      if ((i & 0xf8) == 0xc0)
	{
	  i &= 7;
	  /* Only merge if the blocks are contiguous.  */
	  if (i < 6)
	    {
	      if ((mask & 0xfe00) == (1 << 9))
		{
		  mask |= ((1 << (i + 11)) - 1) & 0xfc00;
		  unwind.opcode_count--;
		}
	    }
	  else if (i == 6 && unwind.opcode_count >= 2)
	    {
	      i = unwind.opcodes[unwind.opcode_count - 2];
	      reg = i >> 4;
	      i &= 0xf;

	      op = 0xffff << (reg - 1);
	      if (reg > 0
		  || ((mask & op) == (1u << (reg - 1))))
		{
		  op = (1 << (reg + i + 1)) - 1;
		  op &= ~((1 << reg) - 1);
		  mask |= op;
		  unwind.opcode_count -= 2;
		}
	    }
	}
d2694 4
a2697 28
  hi_reg = 15;
  /* We want to generate opcodes in the order the registers have been
     saved, ie. descending order.  */
  for (reg = 15; reg >= -1; reg--)
    {
      /* Save registers in blocks.  */
      if (reg < 0
	  || !(mask & (1 << reg)))
	{
	  /* We found an unsaved reg.  Generate opcodes to save the
	     preceeding block.	*/
	  if (reg != hi_reg)
	    {
	      if (reg == 9)
		{
		  /* Short form.  */
		  op = 0xc0 | (hi_reg - 10);
		  add_unwind_opcode (op, 1);
		}
	      else
		{
		  /* Long form.	 */
		  op = 0xc600 | ((reg + 1) << 4) | ((hi_reg - reg) - 1);
		  add_unwind_opcode (op, 2);
		}
	    }
	  hi_reg = reg - 1;
	}
d2700 1
a2700 3
  return;
error:
  ignore_rest_of_line ();
d2704 1
a2704 1
s_arm_unwind_save_mmxwcg (void)
d2706 4
a2709 4
  int reg;
  int hi_reg;
  unsigned mask = 0;
  valueT op;
d2711 5
a2715 2
  if (*input_line_pointer == '{')
    input_line_pointer++;
d2717 1
a2717 1
  do
d2719 3
a2721 1
      reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWCG);
d2723 6
a2728 5
      if (reg == FAIL)
	{
	  as_bad (_(reg_expected_msgs[REG_TYPE_MMXWCG]));
	  goto error;
	}
d2730 4
a2733 22
      reg -= 8;
      if (mask >> reg)
	as_tsktsk (_("register list not in ascending order"));
      mask |= 1 << reg;

      if (*input_line_pointer == '-')
	{
	  input_line_pointer++;
	  hi_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWCG);
	  if (hi_reg == FAIL)
	    {
	      as_bad (_(reg_expected_msgs[REG_TYPE_MMXWCG]));
	      goto error;
	    }
	  else if (reg >= hi_reg)
	    {
	      as_bad (_("bad register range"));
	      goto error;
	    }
	  for (; reg < hi_reg; reg++)
	    mask |= 1 << reg;
	}
a2734 1
  while (skip_past_comma (&input_line_pointer) != FAIL);
d2736 2
a2737 2
  if (*input_line_pointer == '}')
    input_line_pointer++;
d2739 6
a2744 5
  demand_empty_rest_of_line ();

  /* Generate any deferred opcodes becuuse we're going to be looking at
     the list.	*/
  flush_pending_unwind ();
d2746 1
a2746 1
  for (reg = 0; reg < 16; reg++)
d2748 2
a2749 2
      if (mask & (1 << reg))
	unwind.frame_size += 4;
d2751 2
a2752 5
  op = 0xc700 | mask;
  add_unwind_opcode (op, 2);
  return;
error:
  ignore_rest_of_line ();
a2754 3

/* Parse an unwind_save directive.  */

d2756 1
a2756 1
s_arm_unwind_save (int ignored ATTRIBUTE_UNUSED)
d2758 1
a2758 3
  char *peek;
  struct reg_entry *reg;
  bfd_boolean had_brace = FALSE;
d2760 2
a2761 2
  /* Figure out what sort of save we have.  */
  peek = input_line_pointer;
d2763 1
a2763 1
  if (*peek == '{')
d2765 2
a2766 2
      had_brace = TRUE;
      peek++;
d2769 5
a2773 1
  reg = arm_reg_parse_multi (&peek);
d2775 2
a2776 1
  if (!reg)
d2778 1
a2778 2
      as_bad (_("register expected"));
      ignore_rest_of_line ();
d2782 1
a2782 1
  switch (reg->type)
d2784 1
a2784 8
    case REG_TYPE_FN:
      if (had_brace)
	{
	  as_bad (_("FPA .unwind_save does not take a register list"));
	  ignore_rest_of_line ();
	  return;
	}
      s_arm_unwind_save_fpa (reg->number);
a2785 9

    case REG_TYPE_RN:	  s_arm_unwind_save_core ();   return;
    case REG_TYPE_VFD:	   s_arm_unwind_save_vfp ();	return;
    case REG_TYPE_MMXWR:  s_arm_unwind_save_mmxwr ();  return;
    case REG_TYPE_MMXWCG: s_arm_unwind_save_mmxwcg (); return;

    default:
      as_bad (_(".unwind_save does not support this kind of register"));
      ignore_rest_of_line ();
a2786 1
}
d2788 4
d2793 4
a2796 10
/* Parse an unwind_movsp directive.  */

static void
s_arm_unwind_movsp (int ignored ATTRIBUTE_UNUSED)
{
  int reg;
  valueT op;

  reg = arm_reg_parse (&input_line_pointer, REG_TYPE_RN);
  if (reg == FAIL)
d2798 1
a2798 2
      as_bad (_(reg_expected_msgs[REG_TYPE_RN]));
      ignore_rest_of_line ();
a2800 1
  demand_empty_rest_of_line ();
d2802 1
a2802 1
  if (reg == REG_SP || reg == REG_PC)
d2804 1
a2804 1
      as_bad (_("SP and PC not permitted in .unwind_movsp directive"));
d2808 2
a2809 2
  if (unwind.fp_reg != REG_SP)
    as_bad (_("unexpected .unwind_movsp directive"));
d2811 4
a2814 8
  /* Generate opcode to restore the value.  */
  op = 0x90 | reg;
  add_unwind_opcode (op, 1);

  /* Record the information for later.	*/
  unwind.fp_reg = reg;
  unwind.fp_offset = unwind.frame_size;
  unwind.sp_restored = 1;
a2816 2
/* Parse an unwind_pad directive.  */

d2818 1
a2818 1
s_arm_unwind_pad (int ignored ATTRIBUTE_UNUSED)
d2820 2
a2821 4
  int offset;

  if (immediate_for_directive (&offset) == FAIL)
    return;
d2823 3
a2825 6
  if (offset & 3)
    {
      as_bad (_("stack increment must be multiple of 4"));
      ignore_rest_of_line ();
      return;
    }
d2827 2
a2828 3
  /* Don't generate any opcodes, just record the details for later.  */
  unwind.frame_size += offset;
  unwind.pending_offset += offset;
d2830 2
a2831 7
  demand_empty_rest_of_line ();
}

/* Parse an unwind_setfp directive.  */

static void
s_arm_unwind_setfp (int ignored ATTRIBUTE_UNUSED)
d2833 4
a2836 9
  int sp_reg;
  int fp_reg;
  int offset;

  fp_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_RN);
  if (skip_past_comma (&input_line_pointer) == FAIL)
    sp_reg = FAIL;
  else
    sp_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_RN);
d2838 1
a2838 6
  if (fp_reg == FAIL || sp_reg == FAIL)
    {
      as_bad (_("expected <reg>, <reg>"));
      ignore_rest_of_line ();
      return;
    }
d2840 4
a2843 8
  /* Optional constant.	 */
  if (skip_past_comma (&input_line_pointer) != FAIL)
    {
      if (immediate_for_directive (&offset) == FAIL)
	return;
    }
  else
    offset = 0;
d2845 1
a2845 1
  demand_empty_rest_of_line ();
d2847 1
a2847 1
  if (sp_reg != 13 && sp_reg != unwind.fp_reg)
d2849 3
a2851 3
      as_bad (_("register must be either sp or set by a previous"
		"unwind_movsp directive"));
      return;
d2854 3
a2856 7
  /* Don't generate any opcodes, just record the information for later.	 */
  unwind.fp_reg = fp_reg;
  unwind.fp_used = 1;
  if (sp_reg == 13)
    unwind.fp_offset = unwind.frame_size - offset;
  else
    unwind.fp_offset -= offset;
d2859 2
a2860 4
/* Parse an unwind_raw directive.  */

static void
s_arm_unwind_raw (int ignored ATTRIBUTE_UNUSED)
d2862 1
a2862 4
  expressionS exp;
  /* This is an arbitary limit.	 */
  unsigned char op[16];
  int count;
d2864 1
a2864 3
  expression (&exp);
  if (exp.X_op == O_constant
      && skip_past_comma (&input_line_pointer) != FAIL)
d2866 9
a2874 5
      unwind.frame_size += exp.X_add_number;
      expression (&exp);
    }
  else
    exp.X_op = O_illegal;
d2876 5
a2880 6
  if (exp.X_op != O_constant)
    {
      as_bad (_("expected <offset>, <opcode>"));
      ignore_rest_of_line ();
      return;
    }
d2882 5
a2886 1
  count = 0;
d2888 4
a2891 7
  /* Parse the opcode.	*/
  for (;;)
    {
      if (count >= 16)
	{
	  as_bad (_("unwind opcode too long"));
	  ignore_rest_of_line ();
d2893 1
a2893 1
      if (exp.X_op != O_constant || exp.X_add_number & ~0xff)
d2895 3
a2897 3
	  as_bad (_("invalid unwind opcode"));
	  ignore_rest_of_line ();
	  return;
d2899 1
a2899 1
      op[count++] = exp.X_add_number;
d2901 3
a2903 3
      /* Parse the next byte.  */
      if (skip_past_comma (&input_line_pointer) == FAIL)
	break;
d2905 3
a2907 2
      expression (&exp);
    }
d2909 3
a2911 3
  /* Add the opcode bytes in reverse order.  */
  while (count--)
    add_unwind_opcode (op[count], 1);
d2913 3
a2915 1
  demand_empty_rest_of_line ();
a2916 7
#endif /* OBJ_ELF */

/* This table describes all the machine specific pseudo-ops the assembler
   has to support.  The fields are:
     pseudo-op name without dot
     function to call to execute this pseudo-op
     Integer arg to pass to the function.  */
d2918 4
a2921 42
const pseudo_typeS md_pseudo_table[] =
{
  /* Never called because '.req' does not start a line.	 */
  { "req",	   s_req,	  0 },
  { "unreq",	   s_unreq,	  0 },
  { "bss",	   s_bss,	  0 },
  { "align",	   s_align,	  0 },
  { "arm",	   s_arm,	  0 },
  { "thumb",	   s_thumb,	  0 },
  { "code",	   s_code,	  0 },
  { "force_thumb", s_force_thumb, 0 },
  { "thumb_func",  s_thumb_func,  0 },
  { "thumb_set",   s_thumb_set,	  0 },
  { "even",	   s_even,	  0 },
  { "ltorg",	   s_ltorg,	  0 },
  { "pool",	   s_ltorg,	  0 },
  { "syntax",	   s_syntax,	  0 },
#ifdef OBJ_ELF
  { "word",	   s_arm_elf_cons, 4 },
  { "long",	   s_arm_elf_cons, 4 },
  { "rel31",	   s_arm_rel31,	  0 },
  { "fnstart",		s_arm_unwind_fnstart,	0 },
  { "fnend",		s_arm_unwind_fnend,	0 },
  { "cantunwind",	s_arm_unwind_cantunwind, 0 },
  { "personality",	s_arm_unwind_personality, 0 },
  { "personalityindex",	s_arm_unwind_personalityindex, 0 },
  { "handlerdata",	s_arm_unwind_handlerdata, 0 },
  { "save",		s_arm_unwind_save,	0 },
  { "movsp",		s_arm_unwind_movsp,	0 },
  { "pad",		s_arm_unwind_pad,	0 },
  { "setfp",		s_arm_unwind_setfp,	0 },
  { "unwind_raw",	s_arm_unwind_raw,	0 },
#else
  { "word",	   cons, 4},
#endif
  { "extend",	   float_cons, 'x' },
  { "ldouble",	   float_cons, 'x' },
  { "packed",	   float_cons, 'p' },
  { 0, 0, 0 }
};

/* Parser functions used exclusively in instruction operands.  */
d2923 1
a2923 5
/* Generic immediate-value read function for use in insn parsing.
   STR points to the beginning of the immediate (the leading #);
   VAL receives the value; if the value is outside [MIN, MAX]
   issue an error.  PREFIX_OPT is true if the immediate prefix is
   optional.  */
d2926 1
a2926 2
parse_immediate (char **str, int *val, int min, int max,
		 bfd_boolean prefix_opt)
d2928 5
a2932 7
  expressionS exp;
  my_get_expression (&exp, str, prefix_opt ? GE_OPT_PREFIX : GE_IMM_PREFIX);
  if (exp.X_op != O_constant)
    {
      inst.error = _("constant expression required");
      return FAIL;
    }
d2934 1
a2934 1
  if (exp.X_add_number < min || exp.X_add_number > max)
d2936 1
a2936 3
      inst.error = _("immediate value out of range");
      return FAIL;
    }
d2938 1
a2938 3
  *val = exp.X_add_number;
  return SUCCESS;
}
d2940 2
a2941 2
/* Returns the pseudo-register number of an FPA immediate constant,
   or FAIL if there isn't a valid constant here.  */
d2943 1
a2943 8
static int
parse_fpa_immediate (char ** str)
{
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  char *	 save_in;
  expressionS	 exp;
  int		 i;
  int		 j;
d2945 3
a2947 2
  /* First try and match exact strings, this is to guarantee
     that some formats will work even for cross assembly.  */
d2949 21
a2969 3
  for (i = 0; fp_const[i]; i++)
    {
      if (strncmp (*str, fp_const[i], strlen (fp_const[i])) == 0)
d2971 5
a2975 1
	  char *start = *str;
d2977 1
a2977 6
	  *str += strlen (fp_const[i]);
	  if (is_end_of_line[(unsigned char) **str])
	    return i + 8;
	  *str = start;
	}
    }
d2979 2
a2980 4
  /* Just because we didn't get a match doesn't mean that the constant
     isn't valid, just that it is in a format that we don't
     automatically recognize.  Try parsing it with the standard
     expression routines.  */
d2982 1
a2982 1
  memset (words, 0, MAX_LITTLENUMS * sizeof (LITTLENUM_TYPE));
d2984 1
a2984 7
  /* Look for a raw floating point number.  */
  if ((save_in = atof_ieee (*str, 'x', words)) != NULL
      && is_end_of_line[(unsigned char) *save_in])
    {
      for (i = 0; i < NUM_FLOAT_VALS; i++)
	{
	  for (j = 0; j < MAX_LITTLENUMS; j++)
d2986 2
a2987 2
	      if (words[j] != fp_values[i][j])
		break;
d2990 3
a2992 1
	  if (j == MAX_LITTLENUMS)
d2994 2
a2995 2
	      *str = save_in;
	      return i + 8;
d2999 8
d3008 5
a3012 19
  /* Try and parse a more complex expression, this will probably fail
     unless the code uses a floating point prefix (eg "0f").  */
  save_in = input_line_pointer;
  input_line_pointer = *str;
  if (expression (&exp) == absolute_section
      && exp.X_op == O_big
      && exp.X_add_number < 0)
    {
      /* FIXME: 5 = X_PRECISION, should be #define'd where we can use it.
	 Ditto for 15.	*/
      if (gen_to_words (words, 5, (long) 15) == 0)
	{
	  for (i = 0; i < NUM_FLOAT_VALS; i++)
	    {
	      for (j = 0; j < MAX_LITTLENUMS; j++)
		{
		  if (words[j] != fp_values[i][j])
		    break;
		}
d3014 2
a3015 8
	      if (j == MAX_LITTLENUMS)
		{
		  *str = input_line_pointer;
		  input_line_pointer = save_in;
		  return i + 8;
		}
	    }
	}
d3018 4
a3021 4
  *str = input_line_pointer;
  input_line_pointer = save_in;
  inst.error = _("invalid FPA immediate expression");
  return FAIL;
d3024 7
a3030 2
/* Shift operands.  */
enum shift_kind
d3032 1
a3032 2
  SHIFT_LSL, SHIFT_LSR, SHIFT_ASR, SHIFT_ROR, SHIFT_RRX
};
d3034 1
a3034 5
struct asm_shift_name
{
  const char	  *name;
  enum shift_kind  kind;
};
d3036 8
a3043 9
/* Third argument to parse_shift.  */
enum parse_shift_mode
{
  NO_SHIFT_RESTRICT,		/* Any kind of shift is accepted.  */
  SHIFT_IMMEDIATE,		/* Shift operand must be an immediate.	*/
  SHIFT_LSL_OR_ASR_IMMEDIATE,	/* Shift must be LSL or ASR immediate.	*/
  SHIFT_ASR_IMMEDIATE,		/* Shift must be ASR immediate.	 */
  SHIFT_LSL_IMMEDIATE,		/* Shift must be LSL immediate.	 */
};
d3045 2
a3046 2
/* Parse a <shift> specifier on an ARM data processing instruction.
   This has three forms:
d3048 3
a3050 3
     (LSL|LSR|ASL|ASR|ROR) Rs
     (LSL|LSR|ASL|ASR|ROR) #imm
     RRX
d3052 4
a3055 2
   Note that ASL is assimilated to LSL in the instruction encoding, and
   RRX to ROR #0 (which cannot be written as such).  */
d3057 2
a3058 2
static int
parse_shift (char **str, int i, enum parse_shift_mode mode)
d3060 1
a3060 5
  const struct asm_shift_name *shift_name;
  enum shift_kind shift;
  char *s = *str;
  char *p = s;
  int reg;
d3062 1
a3062 2
  for (p = *str; ISALPHA (*p); p++)
    ;
d3064 7
a3070 1
  if (p == *str)
d3072 2
a3073 2
      inst.error = _("shift expression expected");
      return FAIL;
d3076 1
a3076 3
  shift_name = hash_find_n (arm_shift_hsh, *str, p - *str);

  if (shift_name == NULL)
d3078 2
a3079 2
      inst.error = _("shift expression expected");
      return FAIL;
d3082 2
a3083 1
  shift = shift_name->kind;
d3085 2
a3086 4
  switch (mode)
    {
    case NO_SHIFT_RESTRICT:
    case SHIFT_IMMEDIATE:   break;
d3088 3
a3090 7
    case SHIFT_LSL_OR_ASR_IMMEDIATE:
      if (shift != SHIFT_LSL && shift != SHIFT_ASR)
	{
	  inst.error = _("'LSL' or 'ASR' required");
	  return FAIL;
	}
      break;
d3092 4
a3095 7
    case SHIFT_LSL_IMMEDIATE:
      if (shift != SHIFT_LSL)
	{
	  inst.error = _("'LSL' required");
	  return FAIL;
	}
      break;
d3097 1
a3097 7
    case SHIFT_ASR_IMMEDIATE:
      if (shift != SHIFT_ASR)
	{
	  inst.error = _("'ASR' required");
	  return FAIL;
	}
      break;
d3099 6
a3104 2
    default: abort ();
    }
d3106 2
a3107 4
  if (shift != SHIFT_RRX)
    {
      /* Whitespace can appear here if the next thing is a bare digit.	*/
      skip_whitespace (p);
d3109 2
a3110 13
      if (mode == NO_SHIFT_RESTRICT
	  && (reg = arm_reg_parse (&p, REG_TYPE_RN)) != FAIL)
	{
	  inst.operands[i].imm = reg;
	  inst.operands[i].immisreg = 1;
	}
      else if (my_get_expression (&inst.reloc.exp, &p, GE_IMM_PREFIX))
	return FAIL;
    }
  inst.operands[i].shift_kind = shift;
  inst.operands[i].shifted = 1;
  *str = p;
  return SUCCESS;
d3113 10
a3122 1
/* Parse a <shifter_operand> for an ARM data processing instruction:
d3124 13
a3136 4
      #<immediate>
      #<immediate>, <rotate>
      <Rm>
      <Rm>, <shift>
d3138 3
a3140 3
   where <shift> is defined by parse_shift above, and <rotate> is a
   multiple of 2 between 0 and 30.  Validation of immediate operands
   is deferred to md_apply_fix3.  */
d3142 2
a3143 5
static int
parse_shifter_operand (char **str, int i)
{
  int value;
  expressionS expr;
d3145 1
a3145 4
  if ((value = arm_reg_parse (str, REG_TYPE_RN)) != FAIL)
    {
      inst.operands[i].reg = value;
      inst.operands[i].isreg = 1;
d3147 4
a3150 3
      /* parse_shift will override this if appropriate */
      inst.reloc.exp.X_op = O_constant;
      inst.reloc.exp.X_add_number = 0;
d3152 1
a3152 2
      if (skip_past_comma (str) == FAIL)
	return SUCCESS;
d3154 5
a3158 2
      /* Shift operation on register.  */
      return parse_shift (str, i, NO_SHIFT_RESTRICT);
d3161 7
a3167 2
  if (my_get_expression (&inst.reloc.exp, str, GE_IMM_PREFIX))
    return FAIL;
d3169 2
a3170 1
  if (skip_past_comma (str) == SUCCESS)
d3172 4
a3175 3
      /* #x, y -- ie explicit rotation by Y.  */
      if (my_get_expression (&expr, str, GE_NO_PREFIX))
	return FAIL;
d3177 7
a3183 5
      if (expr.X_op != O_constant || inst.reloc.exp.X_op != O_constant)
	{
	  inst.error = _("constant expression expected");
	  return FAIL;
	}
d3185 4
a3188 11
      value = expr.X_add_number;
      if (value < 0 || value > 30 || value % 2 != 0)
	{
	  inst.error = _("invalid rotation");
	  return FAIL;
	}
      if (inst.reloc.exp.X_add_number < 0 || inst.reloc.exp.X_add_number > 255)
	{
	  inst.error = _("invalid constant");
	  return FAIL;
	}
d3190 6
a3195 4
      /* Convert to decoded value.  md_apply_fix3 will put it back.  */
      inst.reloc.exp.X_add_number
	= (((inst.reloc.exp.X_add_number << (32 - value))
	    | (inst.reloc.exp.X_add_number >> value)) & 0xffffffff);
d3198 1
a3198 3
  inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;
  inst.reloc.pc_rel = 0;
  return SUCCESS;
d3201 4
a3204 2
/* Parse all forms of an ARM address expression.  Information is written
   to inst.operands[i] and/or inst.reloc.
d3206 4
a3209 1
   Preindexed addressing (.preind=1):
d3211 1
a3211 4
   [Rn, #offset]       .reg=Rn .reloc.exp=offset
   [Rn, +/-Rm]	       .reg=Rn .imm=Rm .immisreg=1 .negative=0/1
   [Rn, +/-Rm, shift]  .reg=Rn .imm=Rm .immisreg=1 .negative=0/1
		       .shift_kind=shift .reloc.exp=shift_imm
d3213 4
a3216 1
   These three may have a trailing ! which causes .writeback to be set also.
d3218 2
a3219 1
   Postindexed addressing (.postind=1, .writeback=1):
d3221 3
a3223 4
   [Rn], #offset       .reg=Rn .reloc.exp=offset
   [Rn], +/-Rm	       .reg=Rn .imm=Rm .immisreg=1 .negative=0/1
   [Rn], +/-Rm, shift  .reg=Rn .imm=Rm .immisreg=1 .negative=0/1
		       .shift_kind=shift .reloc.exp=shift_imm
d3225 5
a3229 1
   Unindexed addressing (.preind=0, .postind=0):
d3231 4
a3234 1
   [Rn], {option}      .reg=Rn .imm=option .immisreg=0
d3236 20
a3255 1
   Other:
d3257 4
a3260 3
   [Rn]{!}	       shorthand for [Rn,#0]{!}
   =immediate	       .isreg=0 .reloc.exp=immediate
   label	       .reg=PC .reloc.pc_rel=1 .reloc.exp=label
d3262 2
a3263 5
  It is the caller's responsibility to check for addressing modes not
  supported by the instruction, and to set inst.reloc.type.  */

static int
parse_address (char **str, int i)
d3265 1
a3265 2
  char *p = *str;
  int reg;
d3267 1
a3267 1
  if (skip_past_char (&p, '[') == FAIL)
d3269 4
a3272 9
      if (skip_past_char (&p, '=') == FAIL)
	{
	  /* bare address - translate to PC-relative offset */
	  inst.reloc.pc_rel = 1;
	  inst.operands[i].reg = REG_PC;
	  inst.operands[i].isreg = 1;
	  inst.operands[i].preind = 1;
	}
      /* else a load-constant pseudo op, no special treatment needed here */
d3274 7
a3280 2
      if (my_get_expression (&inst.reloc.exp, &p, GE_NO_PREFIX))
	return FAIL;
d3282 6
a3287 2
      *str = p;
      return SUCCESS;
d3290 2
a3291 1
  if ((reg = arm_reg_parse (&p, REG_TYPE_RN)) == FAIL)
d3293 3
a3295 2
      inst.error = _(reg_expected_msgs[REG_TYPE_RN]);
      return FAIL;
a3296 2
  inst.operands[i].reg = reg;
  inst.operands[i].isreg = 1;
d3298 2
a3299 1
  if (skip_past_comma (&p) == SUCCESS)
d3301 4
a3304 1
      inst.operands[i].preind = 1;
d3306 3
a3308 4
      if (*p == '+') p++;
      else if (*p == '-') p++, inst.operands[i].negative = 1;

      if ((reg = arm_reg_parse (&p, REG_TYPE_RN)) != FAIL)
d3310 3
a3312 16
	  inst.operands[i].imm = reg;
	  inst.operands[i].immisreg = 1;

	  if (skip_past_comma (&p) == SUCCESS)
	    if (parse_shift (&p, i, SHIFT_IMMEDIATE) == FAIL)
	      return FAIL;
	}
      else
	{
	  if (inst.operands[i].negative)
	    {
	      inst.operands[i].negative = 0;
	      p--;
	    }
	  if (my_get_expression (&inst.reloc.exp, &p, GE_IMM_PREFIX))
	    return FAIL;
d3316 15
a3330 1
  if (skip_past_char (&p, ']') == FAIL)
d3332 3
a3334 2
      inst.error = _("']' expected");
      return FAIL;
d3337 7
a3343 2
  if (skip_past_char (&p, '!') == SUCCESS)
    inst.operands[i].writeback = 1;
d3345 2
a3346 1
  else if (skip_past_comma (&p) == SUCCESS)
d3348 4
a3351 6
      if (skip_past_char (&p, '{') == SUCCESS)
	{
	  /* [Rn], {expr} - unindexed, with option */
	  if (parse_immediate (&p, &inst.operands[i].imm,
				       0, 255, TRUE) == FAIL)
	    return FAIL;
d3353 7
a3359 17
	  if (skip_past_char (&p, '}') == FAIL)
	    {
	      inst.error = _("'}' expected at end of 'option' field");
	      return FAIL;
	    }
	  if (inst.operands[i].preind)
	    {
	      inst.error = _("cannot combine index with option");
	      return FAIL;
	    }
	  *str = p;
	  return SUCCESS;
	}
      else
	{
	  inst.operands[i].postind = 1;
	  inst.operands[i].writeback = 1;
d3361 7
a3367 5
	  if (inst.operands[i].preind)
	    {
	      inst.error = _("cannot combine pre- and post-indexing");
	      return FAIL;
	    }
d3369 7
a3375 22
	  if (*p == '+') p++;
	  else if (*p == '-') p++, inst.operands[i].negative = 1;

	  if ((reg = arm_reg_parse (&p, REG_TYPE_RN)) != FAIL)
	    {
	      inst.operands[i].imm = reg;
	      inst.operands[i].immisreg = 1;

	      if (skip_past_comma (&p) == SUCCESS)
		if (parse_shift (&p, i, SHIFT_IMMEDIATE) == FAIL)
		  return FAIL;
	    }
	  else
	    {
	      if (inst.operands[i].negative)
		{
		  inst.operands[i].negative = 0;
		  p--;
		}
	      if (my_get_expression (&inst.reloc.exp, &p, GE_IMM_PREFIX))
		return FAIL;
	    }
d3379 1
a3379 10
  /* If at this point neither .preind nor .postind is set, we have a
     bare [Rn]{!}, which is shorthand for [Rn,#0]{!}.  */
  if (inst.operands[i].preind == 0 && inst.operands[i].postind == 0)
    {
      inst.operands[i].preind = 1;
      inst.reloc.exp.X_op = O_constant;
      inst.reloc.exp.X_add_number = 0;
    }
  *str = p;
  return SUCCESS;
d3382 2
a3383 6
/* Miscellaneous. */

/* Parse a PSR flag operand.  The value returned is FAIL on syntax error,
   or a bitmask suitable to be or-ed into the ARM msr instruction.  */
static int
parse_psr (char **str)
d3385 1
a3385 2
  char *p;
  unsigned long psr_field;
d3387 1
a3387 20
  /* CPSR's and SPSR's can now be lowercase.  This is just a convenience
     feature for ease of use and backwards compatibility.  */
  p = *str;
  if (*p == 's' || *p == 'S')
    psr_field = SPSR_BIT;
  else if (*p == 'c' || *p == 'C')
    psr_field = 0;
  else
    goto error;

  p++;
  if (strncasecmp (p, "PSR", 3) != 0)
    goto error;
  p += 3;

  if (*p == '_')
    {
      /* A suffix follows.  */
      const struct asm_psr *psr;
      char *start;
d3389 4
a3392 12
      p++;
      start = p;

      do
	p++;
      while (ISALNUM (*p) || *p == '_');

      psr = hash_find_n (arm_psr_hsh, start, p - start);
      if (!psr)
	goto error;

      psr_field |= psr->field;
a3393 4
  else
    {
      if (ISALNUM (*p))
	goto error;    /* Garbage after "[CS]PSR".  */
d3395 3
a3397 4
      psr_field |= (PSR_c | PSR_f);
    }
  *str = p;
  return psr_field;
d3399 1
a3399 3
 error:
  inst.error = _("flag for {c}psr instruction expected");
  return FAIL;
d3402 1
a3402 2
/* Parse the flags argument to CPSI[ED].  Returns FAIL on error, or a
   value suitable for splatting into the AIF field of the instruction.	*/
d3404 2
a3405 2
static int
parse_cps_flags (char **str)
d3407 1
a3407 3
  int val = 0;
  int saw_a_flag = 0;
  char *s = *str;
d3409 1
a3409 14
  for (;;)
    switch (*s++)
      {
      case '\0': case ',':
	goto done;

      case 'a': case 'A': saw_a_flag = 1; val |= 0x4; break;
      case 'i': case 'I': saw_a_flag = 1; val |= 0x2; break;
      case 'f': case 'F': saw_a_flag = 1; val |= 0x1; break;

      default:
	inst.error = _("unrecognized CPS flag");
	return FAIL;
      }
d3411 1
a3411 2
 done:
  if (saw_a_flag == 0)
d3413 2
a3414 2
      inst.error = _("missing CPS flags");
      return FAIL;
d3417 5
a3421 2
  *str = s - 1;
  return val;
d3424 1
a3424 2
/* Parse an endian specifier ("BE" or "LE", case insensitive);
   returns 0 for big-endian, 1 for little-endian, FAIL for an error.  */
d3426 2
a3427 2
static int
parse_endian_specifier (char **str)
d3429 1
a3429 2
  int little_endian;
  char *s = *str;
d3431 8
a3438 5
  if (strncasecmp (s, "BE", 2))
    little_endian = 0;
  else if (strncasecmp (s, "LE", 2))
    little_endian = 1;
  else
d3440 2
a3441 2
      inst.error = _("valid endian specifiers are be or le");
      return FAIL;
d3444 1
a3444 1
  if (ISALNUM (s[2]) || s[2] == '_')
d3446 2
a3447 2
      inst.error = _("valid endian specifiers are be or le");
      return FAIL;
d3450 1
a3450 2
  *str = s + 2;
  return little_endian;
d3453 1
a3453 3
/* Parse a rotation specifier: ROR #0, #8, #16, #24.  *val receives a
   value suitable for poking into the rotate field of an sxt or sxta
   instruction, or FAIL on error.  */
d3455 2
a3456 2
static int
parse_ror (char **str)
d3458 1
a3458 2
  int rot;
  char *s = *str;
d3460 16
a3475 3
  if (strncasecmp (s, "ROR", 3) == 0)
    s += 3;
  else
d3477 2
a3478 2
      inst.error = _("missing rotation field after comma");
      return FAIL;
d3481 6
a3486 2
  if (parse_immediate (&s, &rot, 0, 24, FALSE) == FAIL)
    return FAIL;
d3488 12
a3499 1
  switch (rot)
d3501 9
a3509 4
    case  0: *str = s; return 0x0;
    case  8: *str = s; return 0x1;
    case 16: *str = s; return 0x2;
    case 24: *str = s; return 0x3;
d3511 1
a3511 4
    default:
      inst.error = _("rotation can only be 0, 8, 16, or 24");
      return FAIL;
    }
d3514 2
a3515 2
/* Parse a conditional code (from conds[] below).  The value returned is in the
   range 0 .. 14, or FAIL.  */
d3517 1
a3517 1
parse_cond (char **str)
d3519 5
a3523 2
  char *p, *q;
  const struct asm_cond *c;
d3525 2
a3526 3
  p = q = *str;
  while (ISALPHA (*q))
    q++;
d3528 1
a3528 2
  c = hash_find_n (arm_cond_hsh, p, q - p);
  if (!c)
d3530 1
a3530 1
      inst.error = _("condition required");
d3534 4
a3537 3
  *str = q;
  return c->value;
}
d3539 5
a3543 4
/* Matcher codes for parse_operands.  */
enum operand_parse_code
{
  OP_stop,	/* end of line */
d3545 1
a3545 166
  OP_RR,	/* ARM register */
  OP_RRnpc,	/* ARM register, not r15 */
  OP_RRnpcb,	/* ARM register, not r15, in square brackets */
  OP_RRw,	/* ARM register, not r15, optional trailing ! */
  OP_RCP,	/* Coprocessor number */
  OP_RCN,	/* Coprocessor register */
  OP_RF,	/* FPA register */
  OP_RVS,	/* VFP single precision register */
  OP_RVD,	/* VFP double precision register */
  OP_RVC,	/* VFP control register */
  OP_RMF,	/* Maverick F register */
  OP_RMD,	/* Maverick D register */
  OP_RMFX,	/* Maverick FX register */
  OP_RMDX,	/* Maverick DX register */
  OP_RMAX,	/* Maverick AX register */
  OP_RMDS,	/* Maverick DSPSC register */
  OP_RIWR,	/* iWMMXt wR register */
  OP_RIWC,	/* iWMMXt wC register */
  OP_RIWG,	/* iWMMXt wCG register */
  OP_RXA,	/* XScale accumulator register */

  OP_REGLST,	/* ARM register list */
  OP_VRSLST,	/* VFP single-precision register list */
  OP_VRDLST,	/* VFP double-precision register list */

  OP_I7,	/* immediate value 0 .. 7 */
  OP_I15,	/*		   0 .. 15 */
  OP_I16,	/*		   1 .. 16 */
  OP_I31,	/*		   0 .. 31 */
  OP_I31w,	/*		   0 .. 31, optional trailing ! */
  OP_I32,	/*		   1 .. 32 */
  OP_I63s,	/*		 -64 .. 63 */
  OP_I255,	/*		   0 .. 255 */
  OP_Iffff,	/*		   0 .. 65535 */

  OP_I4b,	/* immediate, prefix optional, 1 .. 4 */
  OP_I7b,	/*			       0 .. 7 */
  OP_I15b,	/*			       0 .. 15 */
  OP_I31b,	/*			       0 .. 31 */

  OP_SH,	/* shifter operand */
  OP_ADDR,	/* Memory address expression (any mode) */
  OP_EXP,	/* arbitrary expression */
  OP_EXPi,	/* same, with optional immediate prefix */
  OP_EXPr,	/* same, with optional relocation suffix */

  OP_CPSF,	/* CPS flags */
  OP_ENDI,	/* Endianness specifier */
  OP_PSR,	/* CPSR/SPSR mask for msr */
  OP_COND,	/* conditional code */

  OP_RRnpc_I0,	/* ARM register or literal 0 */
  OP_RR_EXr,	/* ARM register or expression with opt. reloc suff. */
  OP_RR_EXi,	/* ARM register or expression with imm prefix */
  OP_RF_IF,	/* FPA register or immediate */
  OP_RIWR_RIWC, /* iWMMXt R or C reg */

  /* Optional operands.	 */
  OP_oI7b,	 /* immediate, prefix optional, 0 .. 7 */
  OP_oI31b,	 /*				0 .. 31 */
  OP_oIffffb,	 /*				0 .. 65535 */
  OP_oI255c,	 /*	  curly-brace enclosed, 0 .. 255 */

  OP_oRR,	 /* ARM register */
  OP_oRRnpc,	 /* ARM register, not the PC */
  OP_oSHll,	 /* LSL immediate */
  OP_oSHar,	 /* ASR immediate */
  OP_oSHllar,	 /* LSL or ASR immediate */
  OP_oROR,	 /* ROR 0/8/16/24 */

  OP_FIRST_OPTIONAL = OP_oI7b
};

/* Generic instruction operand parser.	This does no encoding and no
   semantic validation; it merely squirrels values away in the inst
   structure.  Returns SUCCESS or FAIL depending on whether the
   specified grammar matched.  */
static int
parse_operands (char *str, const char *pattern)
{
  unsigned const char *upat = pattern;
  char *backtrack_pos = 0;
  const char *backtrack_error = 0;
  int i, val, backtrack_index = 0;

#define po_char_or_fail(chr) do {		\
  if (skip_past_char (&str, chr) == FAIL)	\
    goto bad_args;				\
} while (0)

#define po_reg_or_fail(regtype) do {			\
  val = arm_reg_parse (&str, regtype);			\
  if (val == FAIL)					\
    {							\
      inst.error = _(reg_expected_msgs[regtype]);	\
      goto failure;					\
    }							\
  inst.operands[i].reg = val;				\
  inst.operands[i].isreg = 1;				\
} while (0)

#define po_reg_or_goto(regtype, label) do {	\
  val = arm_reg_parse (&str, regtype);		\
  if (val == FAIL)				\
    goto label;					\
						\
  inst.operands[i].reg = val;			\
  inst.operands[i].isreg = 1;			\
} while (0)

#define po_imm_or_fail(min, max, popt) do {			\
  if (parse_immediate (&str, &val, min, max, popt) == FAIL)	\
    goto failure;						\
  inst.operands[i].imm = val;					\
} while (0)

#define po_misc_or_fail(expr) do {		\
  if (expr)					\
    goto failure;				\
} while (0)

  skip_whitespace (str);

  for (i = 0; upat[i] != OP_stop; i++)
    {
      if (upat[i] >= OP_FIRST_OPTIONAL)
	{
	  /* Remember where we are in case we need to backtrack.  */
	  assert (!backtrack_pos);
	  backtrack_pos = str;
	  backtrack_error = inst.error;
	  backtrack_index = i;
	}

      if (i > 0)
	po_char_or_fail (',');

      switch (upat[i])
	{
	  /* Registers */
	case OP_oRRnpc:
	case OP_RRnpc:
	case OP_oRR:
	case OP_RR:    po_reg_or_fail (REG_TYPE_RN);	  break;
	case OP_RCP:   po_reg_or_fail (REG_TYPE_CP);	  break;
	case OP_RCN:   po_reg_or_fail (REG_TYPE_CN);	  break;
	case OP_RF:    po_reg_or_fail (REG_TYPE_FN);	  break;
	case OP_RVS:   po_reg_or_fail (REG_TYPE_VFS);	  break;
	case OP_RVD:   po_reg_or_fail (REG_TYPE_VFD);	  break;
	case OP_RVC:   po_reg_or_fail (REG_TYPE_VFC);	  break;
	case OP_RMF:   po_reg_or_fail (REG_TYPE_MVF);	  break;
	case OP_RMD:   po_reg_or_fail (REG_TYPE_MVD);	  break;
	case OP_RMFX:  po_reg_or_fail (REG_TYPE_MVFX);	  break;
	case OP_RMDX:  po_reg_or_fail (REG_TYPE_MVDX);	  break;
	case OP_RMAX:  po_reg_or_fail (REG_TYPE_MVAX);	  break;
	case OP_RMDS:  po_reg_or_fail (REG_TYPE_DSPSC);	  break;
	case OP_RIWR:  po_reg_or_fail (REG_TYPE_MMXWR);	  break;
	case OP_RIWC:  po_reg_or_fail (REG_TYPE_MMXWC);	  break;
	case OP_RIWG:  po_reg_or_fail (REG_TYPE_MMXWCG);  break;
	case OP_RXA:   po_reg_or_fail (REG_TYPE_XSCALE);  break;

	case OP_RRnpcb:
	  po_char_or_fail ('[');
	  po_reg_or_fail  (REG_TYPE_RN);
	  po_char_or_fail (']');
	  break;
d3547 19
a3565 5
	case OP_RRw:
	  po_reg_or_fail (REG_TYPE_RN);
	  if (skip_past_char (&str, '!') == SUCCESS)
	    inst.operands[i].writeback = 1;
	  break;
d3567 6
a3572 24
	  /* Immediates */
	case OP_I7:	 po_imm_or_fail (  0,	   7, FALSE);	break;
	case OP_I15:	 po_imm_or_fail (  0,	  15, FALSE);	break;
	case OP_I16:	 po_imm_or_fail (  1,	  16, FALSE);	break;
	case OP_I31:	 po_imm_or_fail (  0,	  31, FALSE);	break;
	case OP_I32:	 po_imm_or_fail (  1,	  32, FALSE);	break;
	case OP_I63s:	 po_imm_or_fail (-64,	  63, FALSE);	break;
	case OP_I255:	 po_imm_or_fail (  0,	 255, FALSE);	break;
	case OP_Iffff:	 po_imm_or_fail (  0, 0xffff, FALSE);	break;

	case OP_I4b:	 po_imm_or_fail (  1,	   4, TRUE);	break;
	case OP_oI7b:
	case OP_I7b:	 po_imm_or_fail (  0,	   7, TRUE);	break;
	case OP_I15b:	 po_imm_or_fail (  0,	  15, TRUE);	break;
	case OP_oI31b:
	case OP_I31b:	 po_imm_or_fail (  0,	  31, TRUE);	break;
	case OP_oIffffb: po_imm_or_fail (  0, 0xffff, TRUE);	break;

	  /* Immediate variants */
	case OP_oI255c:
	  po_char_or_fail ('{');
	  po_imm_or_fail (0, 255, TRUE);
	  po_char_or_fail ('}');
	  break;
d3574 1
a3574 17
	case OP_I31w:
	  /* The expression parser chokes on a trailing !, so we have
	     to find it first and zap it.  */
	  {
	    char *s = str;
	    while (*s && *s != ',')
	      s++;
	    if (s[-1] == '!')
	      {
		s[-1] = '\0';
		inst.operands[i].writeback = 1;
	      }
	    po_imm_or_fail (0, 31, TRUE);
	    if (str == s - 1)
	      str = s;
	  }
	  break;
d3576 14
a3589 5
	  /* Expressions */
	case OP_EXPi:	EXPi:
	  po_misc_or_fail (my_get_expression (&inst.reloc.exp, &str,
					      GE_OPT_PREFIX));
	  break;
d3591 2
a3592 4
	case OP_EXP:
	  po_misc_or_fail (my_get_expression (&inst.reloc.exp, &str,
					      GE_NO_PREFIX));
	  break;
d3594 2
a3595 18
	case OP_EXPr:	EXPr:
	  po_misc_or_fail (my_get_expression (&inst.reloc.exp, &str,
					      GE_NO_PREFIX));
	  if (inst.reloc.exp.X_op == O_symbol)
	    {
	      val = parse_reloc (&str);
	      if (val == -1)
		{
		  inst.error = _("unrecognized relocation suffix");
		  goto failure;
		}
	      else if (val != BFD_RELOC_UNUSED)
		{
		  inst.operands[i].imm = val;
		  inst.operands[i].hasreloc = 1;
		}
	    }
	  break;
d3597 4
a3600 21
	  /* Register or expression */
	case OP_RR_EXr:	  po_reg_or_goto (REG_TYPE_RN, EXPr); break;
	case OP_RR_EXi:	  po_reg_or_goto (REG_TYPE_RN, EXPi); break;

	  /* Register or immediate */
	case OP_RRnpc_I0: po_reg_or_goto (REG_TYPE_RN, I0);   break;
	I0:		  po_imm_or_fail (0, 0, FALSE);	      break;

	case OP_RF_IF:    po_reg_or_goto (REG_TYPE_FN, IF);   break;
	IF:
	  if (!is_immediate_prefix (*str))
	    goto bad_args;
	  str++;
	  val = parse_fpa_immediate (&str);
	  if (val == FAIL)
	    goto failure;
	  /* FPA immediates are encoded as registers 8-15.
	     parse_fpa_immediate has already applied the offset.  */
	  inst.operands[i].reg = val;
	  inst.operands[i].isreg = 1;
	  break;
d3602 19
a3620 27
	  /* Two kinds of register */
	case OP_RIWR_RIWC:
	  {
	    struct reg_entry *rege = arm_reg_parse_multi (&str);
	    if (rege->type != REG_TYPE_MMXWR
		&& rege->type != REG_TYPE_MMXWC
		&& rege->type != REG_TYPE_MMXWCG)
	      {
		inst.error = _("iWMMXt data or control register expected");
		goto failure;
	      }
	    inst.operands[i].reg = rege->number;
	    inst.operands[i].isreg = (rege->type == REG_TYPE_MMXWR);
	  }
	  break;

	  /* Misc */
	case OP_CPSF:	 val = parse_cps_flags (&str);		break;
	case OP_ENDI:	 val = parse_endian_specifier (&str);	break;
	case OP_oROR:	 val = parse_ror (&str);		break;
	case OP_PSR:	 val = parse_psr (&str);		break;
	case OP_COND:	 val = parse_cond (&str);		break;

	  /* Register lists */
	case OP_REGLST:
	  val = parse_reg_list (&str);
	  if (*str == '^')
d3622 2
a3623 2
	      inst.operands[1].writeback = 1;
	      str++;
d3625 1
a3625 1
	  break;
d3627 4
a3630 3
	case OP_VRSLST:
	  val = parse_vfp_reg_list (&str, &inst.operands[i].reg, 0);
	  break;
d3632 8
a3639 3
	case OP_VRDLST:
	  val = parse_vfp_reg_list (&str, &inst.operands[i].reg, 1);
	  break;
d3641 3
a3643 4
	  /* Addressing modes */
	case OP_ADDR:
	  po_misc_or_fail (parse_address (&str, i));
	  break;
d3645 5
a3649 3
	case OP_SH:
	  po_misc_or_fail (parse_shifter_operand (&str, i));
	  break;
d3651 1
a3651 3
	case OP_oSHll:
	  po_misc_or_fail (parse_shift (&str, i, SHIFT_LSL_IMMEDIATE));
	  break;
d3653 12
a3664 3
	case OP_oSHar:
	  po_misc_or_fail (parse_shift (&str, i, SHIFT_ASR_IMMEDIATE));
	  break;
d3666 30
a3695 3
	case OP_oSHllar:
	  po_misc_or_fail (parse_shift (&str, i, SHIFT_LSL_OR_ASR_IMMEDIATE));
	  break;
d3697 11
a3707 3
	default:
	  as_fatal ("unhandled operand code %d", upat[i]);
	}
d3709 3
a3711 13
      /* Various value-based sanity checks and shared operations.  We
	 do not signal immediate failures for the register constraints;
	 this allows a syntax error to take precedence.	 */
      switch (upat[i])
	{
	case OP_oRRnpc:
	case OP_RRnpc:
	case OP_RRnpcb:
	case OP_RRw:
	case OP_RRnpc_I0:
	  if (inst.operands[i].isreg && inst.operands[i].reg == REG_PC)
	    inst.error = BAD_PC;
	  break;
d3713 1
a3713 12
	case OP_CPSF:
	case OP_ENDI:
	case OP_oROR:
	case OP_PSR:
	case OP_COND:
	case OP_REGLST:
	case OP_VRSLST:
	case OP_VRDLST:
	  if (val == FAIL)
	    goto failure;
	  inst.operands[i].imm = val;
	  break;
d3715 6
a3720 3
	default:
	  break;
	}
d3722 1
a3722 3
      /* If we get here, this operand was successfully parsed.	*/
      inst.operands[i].present = 1;
      continue;
d3724 6
a3729 2
    bad_args:
      inst.error = BAD_ARGS;
d3731 5
a3735 3
    failure:
      if (!backtrack_pos)
	return FAIL;
d3737 1
a3737 7
      /* Do not backtrack over a trailing optional argument that
	 absorbed some text.  We will only fail again, with the
	 'garbage following instruction' error message, which is
	 probably less helpful than the current one.  */
      if (backtrack_index == i && backtrack_pos != str
	  && upat[i+1] == OP_stop)
	return FAIL;
d3739 11
a3749 6
      /* Try again, skipping the optional argument at backtrack_pos.  */
      str = backtrack_pos;
      inst.error = backtrack_error;
      inst.operands[backtrack_index].present = 0;
      i = backtrack_index;
      backtrack_pos = 0;
d3752 30
a3781 3
  /* Check that we have parsed all the arguments.  */
  if (*str != '\0' && !inst.error)
    inst.error = _("garbage following instruction");
d3783 11
a3793 1
  return inst.error ? FAIL : SUCCESS;
d3796 1
a3796 13
#undef po_char_or_fail
#undef po_reg_or_fail
#undef po_reg_or_goto
#undef po_imm_or_fail

/* Shorthand macro for instruction encoding functions issuing errors.  */
#define constraint(expr, err) do {		\
  if (expr)					\
    {						\
      inst.error = err;				\
      return;					\
    }						\
} while (0)
d3798 6
a3803 1
/* Functions for operand encoding.  ARM, then Thumb.  */
d3805 2
a3806 7
#define rotate_left(v, n) (v << n | v >> (32 - n))

/* If VAL can be encoded in the immediate field of an ARM instruction,
   return the encoded form.  Otherwise, return FAIL.  */

static unsigned int
encode_arm_immediate (unsigned int val)
d3808 2
a3809 7
  unsigned int a, i;

  for (i = 0; i < 32; i += 2)
    if ((a = rotate_left (val, i)) <= 0xff)
      return a | (i << 7); /* 12-bit pack: [shift-cnt,const].  */

  return FAIL;
d3812 2
a3813 4
/* If VAL can be encoded in the immediate field of a Thumb32 instruction,
   return the encoded form.  Otherwise, return FAIL.  */
static unsigned int
encode_thumb32_immediate (unsigned int val)
d3815 1
a3815 1
  unsigned int a, i;
d3817 1
a3817 2
  if (val <= 255)
    return val;
d3819 1
a3819 1
  for (i = 0; i < 32; i++)
d3821 2
a3822 3
      a = rotate_left (val, i);
      if (a >= 128 && a <= 255)
	return (a & 0x7f) | (i << 7);
d3825 6
a3830 13
  a = val & 0xff;
  if (val == ((a << 16) | a))
    return 0x100 | a;
  if (val == ((a << 24) | (a << 16) | (a << 8) | a))
    return 0x300 | a;

  a = val & 0xff00;
  if (val == ((a << 16) | a))
    return 0x200 | (a >> 8);

  return FAIL;
}
/* Encode a VFP SP register number into inst.instruction.  */
d3832 1
a3832 4
static void
encode_arm_vfp_sp_reg (int reg, enum vfp_sp_reg_pos pos)
{
  switch (pos)
d3834 2
a3835 14
    case VFP_REG_Sd:
      inst.instruction |= ((reg >> 1) << 12) | ((reg & 1) << 22);
      break;

    case VFP_REG_Sn:
      inst.instruction |= ((reg >> 1) << 16) | ((reg & 1) << 7);
      break;

    case VFP_REG_Sm:
      inst.instruction |= ((reg >> 1) << 0) | ((reg & 1) << 5);
      break;

    default:
      abort ();
a3836 1
}
d3838 3
a3840 8
/* Encode a <shift> in an ARM-format instruction.  The immediate,
   if any, is handled by md_apply_fix3.	 */
static void
encode_arm_shift (int i)
{
  if (inst.operands[i].shift_kind == SHIFT_RRX)
    inst.instruction |= SHIFT_ROR << 5;
  else
d3842 2
a3843 8
      inst.instruction |= inst.operands[i].shift_kind << 5;
      if (inst.operands[i].immisreg)
	{
	  inst.instruction |= SHIFT_BY_REG;
	  inst.instruction |= inst.operands[i].imm << 8;
	}
      else
	inst.reloc.type = BFD_RELOC_ARM_SHIFT_IMM;
d3845 2
d3849 2
d3852 1
a3852 1
encode_arm_shifter_operand (int i)
d3854 9
a3862 1
  if (inst.operands[i].isreg)
d3864 2
a3865 2
      inst.instruction |= inst.operands[i].reg;
      encode_arm_shift (i);
d3867 1
a3867 2
  else
    inst.instruction |= INST_IMMEDIATE;
d3870 2
a3871 1
/* Subroutine of encode_arm_addr_mode_2 and encode_arm_addr_mode_3.  */
d3873 1
a3873 1
encode_arm_addr_mode_common (int i, bfd_boolean is_t)
d3875 1
a3875 2
  assert (inst.operands[i].isreg);
  inst.instruction |= inst.operands[i].reg << 16;
d3877 6
a3882 1
  if (inst.operands[i].preind)
d3884 3
a3886 8
      if (is_t)
	{
	  inst.error = _("instruction does not accept preindexed addressing");
	  return;
	}
      inst.instruction |= PRE_INDEX;
      if (inst.operands[i].writeback)
	inst.instruction |= WRITE_BACK;
d3888 3
a3890 8
    }
  else if (inst.operands[i].postind)
    {
      assert (inst.operands[i].writeback);
      if (is_t)
	inst.instruction |= WRITE_BACK;
    }
  else /* unindexed - only for coprocessor */
d3892 1
a3892 1
      inst.error = _("instruction does not accept unindexed addressing");
d3896 1
a3896 6
  if (((inst.instruction & WRITE_BACK) || !(inst.instruction & PRE_INDEX))
      && (((inst.instruction & 0x000f0000) >> 16)
	  == ((inst.instruction & 0x0000f000) >> 12)))
    as_warn ((inst.instruction & LOAD_BIT)
	     ? _("destination register same as write-back base")
	     : _("source register same as write-back base"));
d3899 2
a3900 4
/* inst.operands[i] was set up by parse_address.  Encode it into an
   ARM-format mode 2 load or store instruction.	 If is_t is true,
   reject forms that cannot be used with a T instruction (i.e. not
   post-indexed).  */
d3902 1
a3902 1
encode_arm_addr_mode_2 (int i, bfd_boolean is_t)
d3904 1
a3904 1
  encode_arm_addr_mode_common (i, is_t);
d3906 8
a3913 1
  if (inst.operands[i].immisreg)
d3915 2
a3916 14
      inst.instruction |= INST_IMMEDIATE;  /* yes, this is backwards */
      inst.instruction |= inst.operands[i].imm;
      if (!inst.operands[i].negative)
	inst.instruction |= INDEX_UP;
      if (inst.operands[i].shifted)
	{
	  if (inst.operands[i].shift_kind == SHIFT_RRX)
	    inst.instruction |= SHIFT_ROR << 5;
	  else
	    {
	      inst.instruction |= inst.operands[i].shift_kind << 5;
	      inst.reloc.type = BFD_RELOC_ARM_SHIFT_IMM;
	    }
	}
d3918 5
a3922 1
  else /* immediate offset in inst.reloc */
d3924 2
a3925 4
      if (inst.reloc.type == BFD_RELOC_UNUSED)
	inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM;
      if (inst.reloc.pc_rel)
	inst.reloc.exp.X_add_number -= 8;  /* pipeline offset */
d3927 2
d3931 3
a3933 5
/* inst.operands[i] was set up by parse_address.  Encode it into an
   ARM-format mode 3 load or store instruction.	 Reject forms that
   cannot be used with such instructions.  If is_t is true, reject
   forms that cannot be used with a T instruction (i.e. not
   post-indexed).  */
d3935 1
a3935 1
encode_arm_addr_mode_3 (int i, bfd_boolean is_t)
d3937 10
a3946 1
  if (inst.operands[i].immisreg && inst.operands[i].shifted)
d3948 1
a3948 1
      inst.error = _("instruction does not accept scaled register index");
d3952 4
a3955 3
  encode_arm_addr_mode_common (i, is_t);

  if (inst.operands[i].immisreg)
d3957 2
a3958 11
      inst.instruction |= inst.operands[i].imm;
      if (!inst.operands[i].negative)
	inst.instruction |= INDEX_UP;
    }
  else /* immediate offset in inst.reloc */
    {
      inst.instruction |= HWOFFSET_IMM;
      if (inst.reloc.type == BFD_RELOC_UNUSED)
	inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM8;
      if (inst.reloc.pc_rel)
	inst.reloc.exp.X_add_number -= 8;  /* pipeline offset */
d3960 2
d3964 1
a3964 6
/* inst.operands[i] was set up by parse_address.  Encode it into an
   ARM-format instruction.  Reject all forms which cannot be encoded
   into a coprocessor load/store instruction.  If wb_ok is false,
   reject use of writeback; if unind_ok is false, reject use of
   unindexed addressing.  If reloc_override is not 0, use it instead
   of BFD_ARM_CP_OFF_IMM.  */
d3967 1
a3967 1
encode_arm_cp_address (int i, int wb_ok, int unind_ok, int reloc_override)
d3969 1
a3969 1
  inst.instruction |= inst.operands[i].reg << 16;
d3971 4
a3974 3
  assert (!(inst.operands[i].preind && inst.operands[i].postind));

  if (!inst.operands[i].preind && !inst.operands[i].postind) /* unindexed */
d3976 2
a3977 9
      assert (!inst.operands[i].writeback);
      if (!unind_ok)
	{
	  inst.error = _("instruction does not support unindexed addressing");
	  return FAIL;
	}
      inst.instruction |= inst.operands[i].imm;
      inst.instruction |= INDEX_UP;
      return SUCCESS;
d3979 6
d3986 5
a3990 2
  if (inst.operands[i].preind)
    inst.instruction |= PRE_INDEX;
d3992 2
a3993 14
  if (inst.operands[i].writeback)
    {
      if (inst.operands[i].reg == REG_PC)
	{
	  inst.error = _("pc may not be used with write-back");
	  return FAIL;
	}
      if (!wb_ok)
	{
	  inst.error = _("instruction does not support writeback");
	  return FAIL;
	}
      inst.instruction |= WRITE_BACK;
    }
d3995 5
a3999 7
  if (reloc_override)
    inst.reloc.type = reloc_override;
  else
    inst.reloc.type = BFD_RELOC_ARM_CP_OFF_IMM;
  if (inst.reloc.pc_rel)
    inst.reloc.exp.X_add_number -= 8;
  return SUCCESS;
d4002 1
a4002 6
/* inst.reloc.exp describes an "=expr" load pseudo-operation.
   Determine whether it can be performed with a move instruction; if
   it can, convert inst.instruction to that move instruction and
   return 1; if it can't, convert inst.instruction to a literal-pool
   load and return 0.  If this is not a valid thing to do in the
   current context, set inst.error and return 1.
d4004 3
a4006 1
   inst.operands[i] describes the destination register.	 */
d4008 2
a4009 2
static int
move_or_literal_pool (int i, bfd_boolean thumb_p, bfd_boolean mode_3)
d4011 27
a4037 1
  if ((inst.instruction & (thumb_p ? THUMB_LOAD_BIT : LOAD_BIT)) == 0)
d4039 2
a4040 2
      inst.error = _("invalid pseudo operation");
      return 1;
d4042 6
a4047 1
  if (inst.reloc.exp.X_op != O_constant && inst.reloc.exp.X_op != O_symbol)
d4049 2
a4050 2
      inst.error = _("constant expression expected");
      return 1;
d4052 6
a4057 1
  if (inst.reloc.exp.X_op == O_constant)
d4059 3
a4061 21
      if (thumb_p)
	{
	  if ((inst.reloc.exp.X_add_number & ~0xFF) == 0)
	    {
	      /* This can be done with a mov(1) instruction.  */
	      inst.instruction	= T_OPCODE_MOV_I8 | (inst.operands[i].reg << 8);
	      inst.instruction |= inst.reloc.exp.X_add_number;
	      return 1;
	    }
	}
      else
	{
	  int value = encode_arm_immediate (inst.reloc.exp.X_add_number);
	  if (value != FAIL)
	    {
	      /* This can be done with a mov instruction.  */
	      inst.instruction &= LITERAL_MASK;
	      inst.instruction |= INST_IMMEDIATE | (OPCODE_MOV << DATA_OP_SHIFT);
	      inst.instruction |= value & 0xfff;
	      return 1;
	    }
d4063 4
a4066 10
	  value = encode_arm_immediate (~inst.reloc.exp.X_add_number);
	  if (value != FAIL)
	    {
	      /* This can be done with a mvn instruction.  */
	      inst.instruction &= LITERAL_MASK;
	      inst.instruction |= INST_IMMEDIATE | (OPCODE_MVN << DATA_OP_SHIFT);
	      inst.instruction |= value & 0xfff;
	      return 1;
	    }
	}
d4069 1
a4069 1
  if (add_to_lit_pool () == FAIL)
d4071 2
a4072 2
      inst.error = _("literal pool insertion failed");
      return 1;
a4073 11
  inst.operands[1].reg = REG_PC;
  inst.operands[1].isreg = 1;
  inst.operands[1].preind = 1;
  inst.reloc.pc_rel = 1;
  inst.reloc.type = (thumb_p
		     ? BFD_RELOC_ARM_THUMB_OFFSET
		     : (mode_3
			? BFD_RELOC_ARM_HWLITERAL
			: BFD_RELOC_ARM_LITERAL));
  return 0;
}
d4075 12
a4086 3
/* Functions for instruction encoding, sorted by subarchitecture.
   First some generics; their names are taken from the conventional
   bit positions for register arguments in ARM format instructions.  */
d4088 3
a4090 4
static void
do_noargs (void)
{
}
d4092 4
a4095 5
static void
do_rd (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
}
d4097 1
a4097 5
static void
do_rd_rm (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg;
d4100 7
a4106 6
static void
do_rd_rn (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
}
d4109 1
a4109 1
do_rn_rd (void)
d4111 6
a4116 3
  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg << 12;
}
d4118 10
a4127 7
static void
do_rd_rm_rn (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 16;
}
d4129 5
a4133 7
static void
do_rd_rn_rm (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
}
d4135 2
a4136 7
static void
do_rm_rd_rn (void)
{
  inst.instruction |= inst.operands[0].reg;
  inst.instruction |= inst.operands[1].reg << 12;
  inst.instruction |= inst.operands[2].reg << 16;
}
d4138 6
a4143 5
static void
do_imm0 (void)
{
  inst.instruction |= inst.operands[0].imm;
}
d4145 9
a4153 6
static void
do_rd_cpaddr (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_cp_address (1, TRUE, TRUE, 0);
}
d4155 9
a4163 3
/* ARM instructions, in alphabetical order by function name (except
   that wrapper functions appear immediately after the function they
   wrap).  */
d4165 5
a4169 2
/* This is a pseudo-op of the form "adr rd, label" to be converted
   into a relative address of the form "add rd, pc, #label-.-8".  */
d4171 5
a4175 4
static void
do_adr (void)
{
  inst.instruction |= (inst.operands[0].reg << 12);  /* Rd */
d4177 5
a4181 8
  /* Frag hacking will turn this into a sub instruction if the offset turns
     out to be negative.  */
  inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;
#ifndef TE_WINCE
  inst.reloc.exp.X_add_number -= 8; /* PC relative adjust.  */
#endif
  inst.reloc.pc_rel = 1;
}
d4183 3
a4185 4
/* This is a pseudo-op of the form "adrl rd, label" to be converted
   into a relative address of the form:
   add rd, pc, #low(label-.-8)"
   add rd, rd, #high(label-.-8)"  */
d4187 3
a4189 4
static void
do_adrl (void)
{
  inst.instruction |= (inst.operands[0].reg << 12);  /* Rd */
d4191 3
a4193 9
  /* Frag hacking will turn this into a sub instruction if the offset turns
     out to be negative.  */
  inst.reloc.type	       = BFD_RELOC_ARM_ADRL_IMMEDIATE;
#ifndef TE_WINCE
  inst.reloc.exp.X_add_number -= 8; /* PC relative adjust  */
#endif
  inst.reloc.pc_rel	       = 1;
  inst.size		       = INSN_SIZE * 2;
}
d4195 4
a4198 9
static void
do_arit (void)
{
  if (!inst.operands[1].present)
    inst.operands[1].reg = inst.operands[0].reg;
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  encode_arm_shifter_operand (2);
}
d4200 1
a4200 10
static void
do_bfc (void)
{
  unsigned int msb = inst.operands[1].imm + inst.operands[2].imm;
  constraint (msb > 32, _("bit-field extends past end of register"));
  /* The instruction encoding stores the LSB and MSB,
     not the LSB and width.  */
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].imm << 7;
  inst.instruction |= (msb - 1) << 16;
a4202 4
static void
do_bfi (void)
{
  unsigned int msb;
d4204 5
a4208 14
  /* #0 in second position is alternative syntax for bfc, which is
     the same instruction but with REG_PC in the Rm field.  */
  if (!inst.operands[1].isreg)
    inst.operands[1].reg = REG_PC;

  msb = inst.operands[2].imm + inst.operands[3].imm;
  constraint (msb > 32, _("bit-field extends past end of register"));
  /* The instruction encoding stores the LSB and MSB,
     not the LSB and width.  */
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].imm << 7;
  inst.instruction |= (msb - 1) << 16;
}
d4211 1
a4211 1
do_bfx (void)
d4213 1
a4213 7
  constraint (inst.operands[2].imm + inst.operands[3].imm > 32,
	      _("bit-field extends past end of register"));
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].imm << 7;
  inst.instruction |= (inst.operands[3].imm - 1) << 16;
}
d4215 1
a4215 5
/* ARM V5 breakpoint instruction (argument parse)
     BKPT <16 bit unsigned immediate>
     Instruction is not conditional.
	The bit pattern given in insns[] has the COND_ALWAYS condition,
	and it is an error if the caller tried to override that.  */
d4217 2
a4218 5
static void
do_bkpt (void)
{
  /* Top 12 of 16 bits to bits 19:8.  */
  inst.instruction |= (inst.operands[0].imm & 0xfff0) << 4;
d4220 1
a4220 8
  /* Bottom 4 of 16 bits to bits 3:0.  */
  inst.instruction |= inst.operands[0].imm & 0xf;
}

static void
encode_branch (int default_reloc)
{
  if (inst.operands[0].hasreloc)
d4222 2
a4223 4
      constraint (inst.operands[0].imm != BFD_RELOC_ARM_PLT32,
		  _("the only suffix valid here is '(plt)'"));
      inst.reloc.type	= BFD_RELOC_ARM_PLT32;
      inst.reloc.pc_rel = 0;
d4225 4
a4228 1
  else
d4230 2
a4231 2
      inst.reloc.type = default_reloc;
      inst.reloc.pc_rel = 1;
d4233 1
d4236 6
d4243 1
a4243 1
do_branch (void)
d4245 14
a4258 1
  encode_branch (BFD_RELOC_ARM_PCREL_BRANCH);
d4261 4
a4264 7
/* ARM V5 branch-link-exchange instruction (argument parse)
     BLX <target_addr>		ie BLX(1)
     BLX{<condition>} <Rm>	ie BLX(2)
   Unfortunately, there are two different opcodes for this mnemonic.
   So, the insns[].value is not used, and the code here zaps values
	into inst.instruction.
   Also, the <target_addr> can be 25 bits, hence has its own reloc.  */
d4267 1
a4267 1
do_blx (void)
d4269 13
a4281 6
  if (inst.operands[0].isreg)
    {
      /* Arg is a register; the opcode provided by insns[] is correct.
	 It is not illegal to do "blx pc", just useless.  */
      if (inst.operands[0].reg == REG_PC)
	as_tsktsk (_("use of r15 in blx in ARM mode is not really useful"));
a4282 2
      inst.instruction |= inst.operands[0].reg;
    }
d4284 1
a4284 7
    {
      /* Arg is an address; this instruction cannot be executed
	 conditionally, and the opcode must be adjusted.  */
      constraint (inst.cond != COND_ALWAYS, BAD_COND);
      inst.instruction = 0xfafffffe;
      encode_branch (BFD_RELOC_ARM_PCREL_BLX);
    }
d4288 1
a4288 1
do_bx (void)
d4290 1
a4290 2
  if (inst.operands[0].reg == REG_PC)
    as_tsktsk (_("use of r15 in bx in ARM mode is not really useful"));
d4292 10
a4301 2
  inst.instruction |= inst.operands[0].reg;
}
d4303 5
d4309 14
a4322 1
/* ARM v5TEJ.  Jump to Jazelle code.  */
d4324 2
a4325 5
static void
do_bxj (void)
{
  if (inst.operands[0].reg == REG_PC)
    as_tsktsk (_("use of r15 in bxj is not really useful"));
d4327 4
a4330 2
  inst.instruction |= inst.operands[0].reg;
}
a4331 3
/* Co-processor data operation:
      CDP{cond} <coproc>, <opcode_1>, <CRd>, <CRn>, <CRm>{, <opcode_2>}
      CDP2	<coproc>, <opcode_1>, <CRd>, <CRn>, <CRm>{, <opcode_2>}	 */
d4333 1
a4333 1
do_cdp (void)
d4335 1
a4335 6
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].imm << 20;
  inst.instruction |= inst.operands[2].reg << 12;
  inst.instruction |= inst.operands[3].reg << 16;
  inst.instruction |= inst.operands[4].reg;
  inst.instruction |= inst.operands[5].imm << 5;
d4338 2
d4341 1
a4341 1
do_cmp (void)
d4343 1
a4343 2
  inst.instruction |= inst.operands[0].reg << 16;
  encode_arm_shifter_operand (1);
d4346 5
a4350 7
/* Transfer between coprocessor and ARM registers.
   MRC{cond} <coproc>, <opcode_1>, <Rd>, <CRn>, <CRm>{, <opcode_2>}
   MRC2
   MCR{cond}
   MCR2

   No special properties.  */
d4353 1
a4353 1
do_co_reg (void)
d4355 3
a4357 7
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].imm << 21;
  inst.instruction |= inst.operands[2].reg << 12;
  inst.instruction |= inst.operands[3].reg << 16;
  inst.instruction |= inst.operands[4].reg;
  inst.instruction |= inst.operands[5].imm << 5;
}
d4359 13
a4371 5
/* Transfer between coprocessor register and pair of ARM registers.
   MCRR{cond} <coproc>, <opcode>, <Rd>, <Rn>, <CRm>.
   MCRR2
   MRRC{cond}
   MRRC2
d4373 5
a4377 1
   Two XScale instructions are special cases of these:
d4379 12
a4390 2
     MAR{cond} acc0, <RdLo>, <RdHi> == MCRR{cond} p0, #0, <RdLo>, <RdHi>, c0
     MRA{cond} acc0, <RdLo>, <RdHi> == MRRC{cond} p0, #0, <RdLo>, <RdHi>, c0
d4392 4
a4395 1
   Result unpredicatable if Rd or Rn is R15.  */
d4397 1
a4397 8
static void
do_co_reg2c (void)
{
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].imm << 4;
  inst.instruction |= inst.operands[2].reg << 12;
  inst.instruction |= inst.operands[3].reg << 16;
  inst.instruction |= inst.operands[4].reg;
d4400 2
a4401 6
static void
do_cpsi (void)
{
  inst.instruction |= inst.operands[0].imm << 6;
  inst.instruction |= inst.operands[1].imm;
}
d4404 1
a4404 1
do_it (void)
d4406 2
a4407 3
  /* There is no IT instruction in ARM mode.  We
     process it but do not generate code for it.  */
  inst.size = 0;
d4411 1
a4411 1
do_ldmstm (void)
d4413 12
a4424 2
  int base_reg = inst.operands[0].reg;
  int range = inst.operands[1].imm;
d4426 1
a4426 2
  inst.instruction |= base_reg << 16;
  inst.instruction |= range;
d4428 1
a4428 2
  if (inst.operands[1].writeback)
    inst.instruction |= LDM_TYPE_2_OR_3;
d4430 2
a4431 1
  if (inst.operands[0].writeback)
d4433 11
a4443 3
      inst.instruction |= WRITE_BACK;
      /* Check for unpredictable uses of writeback.  */
      if (inst.instruction & LOAD_BIT)
d4445 2
a4446 17
	  /* Not allowed in LDM type 2.	 */
	  if ((inst.instruction & LDM_TYPE_2_OR_3)
	      && ((range & (1 << REG_PC)) == 0))
	    as_warn (_("writeback of base register is UNPREDICTABLE"));
	  /* Only allowed if base reg not in list for other types.  */
	  else if (range & (1 << base_reg))
	    as_warn (_("writeback of base register when in register list is UNPREDICTABLE"));
	}
      else /* STM.  */
	{
	  /* Not allowed for type 2.  */
	  if (inst.instruction & LDM_TYPE_2_OR_3)
	    as_warn (_("writeback of base register is UNPREDICTABLE"));
	  /* Only allowed if base reg not in list, or first in list.  */
	  else if ((range & (1 << base_reg))
		   && (range & ((1 << base_reg) - 1)))
	    as_warn (_("if writeback register is in list, it must be the lowest reg in the list"));
d4448 1
d4450 3
a4454 6
/* ARMv5TE load-consecutive (argument parse)
   Mode is like LDRH.

     LDRccD R, mode
     STRccD R, mode.  */

d4456 1
a4456 1
do_ldrd (void)
d4458 1
a4458 7
  constraint (inst.operands[0].reg % 2 != 0,
	      _("first destination register must be even"));
  constraint (inst.operands[1].present
	      && inst.operands[1].reg != inst.operands[0].reg + 1,
	      _("can only load two consecutive registers"));
  constraint (inst.operands[0].reg == REG_LR, _("r14 not allowed here"));
  constraint (!inst.operands[2].isreg, _("'[' expected"));
d4460 1
a4460 4
  if (!inst.operands[1].present)
    inst.operands[1].reg = inst.operands[0].reg + 1;
  
  if (inst.instruction & LOAD_BIT)
d4462 2
a4463 15
      /* encode_arm_addr_mode_3 will diagnose overlap between the base
	 register and the first register written; we have to diagnose
	 overlap between the base and the second register written here.	 */

      if (inst.operands[2].reg == inst.operands[1].reg
	  && (inst.operands[2].writeback || inst.operands[2].postind))
	as_warn (_("base register written back, and overlaps "
		   "second destination register"));

      /* For an index-register load, the index register must not overlap the
	 destination (even if not write-back).	*/
      else if (inst.operands[2].immisreg
	       && (inst.operands[2].imm == inst.operands[0].reg
		   || inst.operands[2].imm == inst.operands[1].reg))
	as_warn (_("index register overlaps destination register"));
d4465 2
d4468 1
a4468 3
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_addr_mode_3 (2, /*is_t=*/FALSE);
}
d4470 2
a4471 2
static void
do_ldrex (void)
d4473 1
a4473 5
  constraint (!inst.operands[1].isreg || !inst.operands[1].preind
	      || inst.operands[1].postind || inst.operands[1].writeback
	      || inst.operands[1].immisreg || inst.operands[1].shifted
	      || inst.operands[1].negative,
	      _("instruction does not accept this addressing mode"));
d4475 24
a4498 9
  constraint (inst.operands[1].reg == REG_PC, BAD_PC);

  constraint (inst.reloc.exp.X_op != O_constant
	      || inst.reloc.exp.X_add_number != 0,
	      _("offset must be zero in ARM encoding"));

  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.reloc.type = BFD_RELOC_UNUSED;
d4502 1
a4502 1
do_ldrexd (void)
d4504 1
a4504 8
  constraint (inst.operands[0].reg % 2 != 0,
	      _("even register required"));
  constraint (inst.operands[1].present
	      && inst.operands[1].reg != inst.operands[0].reg + 1,
	      _("can only load two consecutive registers"));
  /* If op 1 were present and equal to PC, this function wouldn't
     have been called in the first place.  */
  constraint (inst.operands[0].reg == REG_LR, _("r14 not allowed here"));
d4506 2
a4507 3
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[2].reg << 16;
}
d4509 3
a4511 6
static void
do_ldst (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  if (!inst.operands[1].isreg)
    if (move_or_literal_pool (0, /*thumb_p=*/FALSE, /*mode_3=*/FALSE))
d4513 5
a4517 2
  encode_arm_addr_mode_2 (1, /*is_t=*/FALSE);
}
d4519 6
a4524 6
static void
do_ldstt (void)
{
  /* ldrt/strt always use post-indexed addressing.  Turn [Rn] into [Rn]! and
     reject [Rn,...].  */
  if (inst.operands[1].preind)
d4526 3
a4528 3
      constraint (inst.reloc.exp.X_op != O_constant ||
		  inst.reloc.exp.X_add_number != 0,
		  _("this instruction requires a post-indexed address"));
d4530 3
a4532 6
      inst.operands[1].preind = 0;
      inst.operands[1].postind = 1;
      inst.operands[1].writeback = 1;
    }
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_addr_mode_2 (1, /*is_t=*/TRUE);
a4534 2
/* Halfword and signed-byte load/store operations.  */

d4536 1
a4536 1
do_ldstv4 (void)
d4538 13
a4550 3
  inst.instruction |= inst.operands[0].reg << 12;
  if (!inst.operands[1].isreg)
    if (move_or_literal_pool (0, /*thumb_p=*/FALSE, /*mode_3=*/TRUE))
d4552 3
a4554 1
  encode_arm_addr_mode_3 (1, /*is_t=*/FALSE);
d4558 1
a4558 1
do_ldsttv4 (void)
d4560 11
a4570 3
  /* ldrt/strt always use post-indexed addressing.  Turn [Rn] into [Rn]! and
     reject [Rn,...].  */
  if (inst.operands[1].preind)
d4572 3
a4574 3
      constraint (inst.reloc.exp.X_op != O_constant ||
		  inst.reloc.exp.X_add_number != 0,
		  _("this instruction requires a post-indexed address"));
d4576 40
a4615 3
      inst.operands[1].preind = 0;
      inst.operands[1].postind = 1;
      inst.operands[1].writeback = 1;
d4617 2
a4618 2
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_addr_mode_3 (1, /*is_t=*/TRUE);
a4620 2
/* Co-processor register load/store.
   Format: <LDC|STC>{cond}[L] CP#,CRd,<address>	 */
d4622 1
a4622 1
do_lstc (void)
d4624 10
a4633 4
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 12;
  encode_arm_cp_address (2, TRUE, TRUE, 0);
}
d4635 8
a4642 8
static void
do_mlas (void)
{
  /* This restriction does not apply to mls (nor to mla in v6, but
     that's hard to detect at present).	 */
  if (inst.operands[0].reg == inst.operands[1].reg
      && !(inst.instruction & 0x00400000))
    as_tsktsk (_("rd and rm should be different in mla"));
d4644 2
a4645 4
  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 8;
  inst.instruction |= inst.operands[3].reg << 12;
d4647 7
a4653 1
}
d4655 1
a4655 6
static void
do_mov (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_shifter_operand (1);
}
d4657 10
a4666 9
/* ARM V6T2 16-bit immediate register load: MOV[WT]{cond} Rd, #<imm16>.	 */
static void
do_mov16 (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  /* The value is in two pieces: 0:11, 16:19.  */
  inst.instruction |= (inst.operands[1].imm & 0x00000fff);
  inst.instruction |= (inst.operands[1].imm & 0x0000f000) << 4;
}
d4668 2
a4669 9
static void
do_mrs (void)
{
  /* mrs only accepts CPSR/SPSR/CPSR_all/SPSR_all.  */
  constraint ((inst.operands[1].imm & (PSR_c|PSR_x|PSR_s|PSR_f))
	      != (PSR_c|PSR_f),
	      _("'CPSR' or 'SPSR' expected"));
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= (inst.operands[1].imm & SPSR_BIT);
a4671 4
/* Two possible forms:
      "{C|S}PSR_<field>, Rm",
      "{C|S}PSR_f, #expression".  */

d4673 1
a4673 1
do_msr (void)
d4675 4
a4678 4
  inst.instruction |= inst.operands[0].imm;
  if (inst.operands[1].isreg)
    inst.instruction |= inst.operands[1].reg;
  else
d4680 2
a4681 3
      inst.instruction |= INST_IMMEDIATE;
      inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;
      inst.reloc.pc_rel = 0;
a4682 1
}
d4684 7
a4690 8
static void
do_mul (void)
{
  if (!inst.operands[2].present)
    inst.operands[2].reg = inst.operands[0].reg;
  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 8;
d4692 1
a4692 2
  if (inst.operands[0].reg == inst.operands[1].reg)
    as_tsktsk (_("rd and rm should be different in mul"));
d4695 1
a4695 6
/* Long Multiply Parser
   UMULL RdLo, RdHi, Rm, Rs
   SMULL RdLo, RdHi, Rm, Rs
   UMLAL RdLo, RdHi, Rm, Rs
   SMLAL RdLo, RdHi, Rm, Rs.  */

d4697 1
a4697 1
do_mull (void)
d4699 2
a4700 4
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
  inst.instruction |= inst.operands[3].reg << 8;
d4702 13
a4714 6
  /* rdhi, rdlo and rm must all be different.  */
  if (inst.operands[0].reg == inst.operands[1].reg
      || inst.operands[0].reg == inst.operands[2].reg
      || inst.operands[1].reg == inst.operands[2].reg)
    as_tsktsk (_("rdhi, rdlo and rm must all be different"));
}
d4716 19
a4734 4
static void
do_nop (void)
{
  if (inst.operands[0].present)
d4736 2
a4737 3
      /* Architectural NOP hints are CPSR sets with no bits selected.  */
      inst.instruction &= 0xf0000000;
      inst.instruction |= 0x0320f000 + inst.operands[0].imm;
d4739 6
d4746 1
d4748 2
a4749 4
/* ARM V6 Pack Halfword Bottom Top instruction (argument parse).
   PKHBT {<cond>} <Rd>, <Rn>, <Rm> {, LSL #<shift_imm>}
   Condition defaults to COND_ALWAYS.
   Error if Rd, Rn or Rm are R15.  */
d4752 1
a4752 1
do_pkhbt (void)
d4754 2
a4755 6
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
  if (inst.operands[3].present)
    encode_arm_shift (3);
}
d4757 1
a4757 1
/* ARM V6 PKHTB (Argument Parse).  */
d4759 9
a4767 4
static void
do_pkhtb (void)
{
  if (!inst.operands[3].present)
d4769 2
a4770 6
      /* If the shift specifier is omitted, turn the instruction
	 into pkhbt rd, rm, rn. */
      inst.instruction &= 0xfff00010;
      inst.instruction |= inst.operands[0].reg << 12;
      inst.instruction |= inst.operands[1].reg;
      inst.instruction |= inst.operands[2].reg << 16;
d4772 5
a4776 1
  else
d4778 2
a4779 4
      inst.instruction |= inst.operands[0].reg << 12;
      inst.instruction |= inst.operands[1].reg << 16;
      inst.instruction |= inst.operands[2].reg;
      encode_arm_shift (3);
d4781 4
d4787 32
a4818 1
/* ARMv5TE: Preload-Cache
d4820 4
a4823 1
    PLD <addr_mode>
d4825 3
a4827 1
  Syntactically, like LDR with B=1, W=0, L=1.  */
d4829 1
a4829 14
static void
do_pld (void)
{
  constraint (!inst.operands[0].isreg,
	      _("'[' expected after PLD mnemonic"));
  constraint (inst.operands[0].postind,
	      _("post-indexed expression used in preload instruction"));
  constraint (inst.operands[0].writeback,
	      _("writeback used in preload instruction"));
  constraint (!inst.operands[0].preind,
	      _("unindexed addressing used in preload instruction"));
  inst.instruction |= inst.operands[0].reg;
  encode_arm_addr_mode_2 (0, /*is_t=*/FALSE);
}
d4831 1
a4831 9
static void
do_push_pop (void)
{
  inst.operands[1] = inst.operands[0];
  memset (&inst.operands[0], 0, sizeof inst.operands[0]);
  inst.operands[0].isreg = 1;
  inst.operands[0].writeback = 1;
  inst.operands[0].reg = REG_SP;
  do_ldmstm ();
d4833 1
d4835 4
a4838 5
/* ARM V6 RFE (Return from Exception) loads the PC and CPSR from the
   word at the specified address and the following word
   respectively.
   Unconditionally executed.
   Error if Rn is R15.	*/
d4841 1
a4841 1
do_rfe (void)
d4843 9
a4851 4
  inst.instruction |= inst.operands[0].reg << 16;
  if (inst.operands[0].writeback)
    inst.instruction |= WRITE_BACK;
}
d4853 21
a4873 1
/* ARM V6 ssat (argument parse).  */
d4875 6
a4880 6
static void
do_ssat (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= (inst.operands[1].imm - 1) << 16;
  inst.instruction |= inst.operands[2].reg;
d4882 1
a4882 2
  if (inst.operands[3].present)
    encode_arm_shift (3);
d4885 7
a4891 1
/* ARM V6 usat (argument parse).  */
d4894 1
a4894 1
do_usat (void)
d4896 5
a4900 3
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].imm << 16;
  inst.instruction |= inst.operands[2].reg;
d4902 2
a4903 3
  if (inst.operands[3].present)
    encode_arm_shift (3);
}
d4905 16
a4920 1
/* ARM V6 ssat16 (argument parse).  */
d4922 1
a4922 7
static void
do_ssat16 (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= ((inst.operands[1].imm - 1) << 16);
  inst.instruction |= inst.operands[2].reg;
}
d4924 4
a4927 6
static void
do_usat16 (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].imm << 16;
  inst.instruction |= inst.operands[2].reg;
d4930 6
a4935 5
/* ARM V6 SETEND (argument parse).  Sets the E bit in the CPSR while
   preserving the other bits.

   setend <endian_specifier>, where <endian_specifier> is either
   BE or LE.  */
d4938 1
a4938 1
do_setend (void)
d4940 5
a4944 3
  if (inst.operands[0].imm)
    inst.instruction |= 0x200;
}
d4946 5
a4950 6
static void
do_shift (void)
{
  unsigned int Rm = (inst.operands[1].present
		     ? inst.operands[1].reg
		     : inst.operands[0].reg);
d4952 1
a4952 3
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= Rm;
  if (inst.operands[2].isreg)  /* Rd, {Rm,} Rs */
d4954 2
a4955 4
      constraint (inst.operands[0].reg != Rm,
		  _("source1 and dest must be same register"));
      inst.instruction |= inst.operands[2].reg << 8;
      inst.instruction |= SHIFT_BY_REG;
d4958 20
a4977 2
    inst.reloc.type = BFD_RELOC_ARM_SHIFT_IMM;
}
d4980 1
a4980 1
do_smi (void)
d4982 36
a5017 2
  inst.reloc.type = BFD_RELOC_ARM_SMI;
  inst.reloc.pc_rel = 0;
d5020 2
d5023 1
a5023 1
do_swi (void)
d5025 2
a5026 2
  inst.reloc.type = BFD_RELOC_ARM_SWI;
  inst.reloc.pc_rel = 0;
d5029 5
a5033 4
/* ARM V5E (El Segundo) signed-multiply-accumulate (argument parse)
   SMLAxy{cond} Rd,Rm,Rs,Rn
   SMLAWy{cond} Rd,Rm,Rs,Rn
   Error if any register is R15.  */
d5035 2
a5036 2
static void
do_smla (void)
d5038 28
a5065 4
  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 8;
  inst.instruction |= inst.operands[3].reg << 12;
a5067 5
/* ARM V5E (El Segundo) signed-multiply-accumulate-long (argument parse)
   SMLALxy{cond} Rdlo,Rdhi,Rm,Rs
   Error if any register is R15.
   Warning if Rdlo == Rdhi.  */

d5069 1
a5069 1
do_smlal (void)
d5071 56
a5126 4
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
  inst.instruction |= inst.operands[3].reg << 8;
d5128 24
a5151 2
  if (inst.operands[0].reg == inst.operands[1].reg)
    as_tsktsk (_("rdhi and rdlo must be different"));
d5154 1
a5154 3
/* ARM V5E (El Segundo) signed-multiply (argument parse)
   SMULxy{cond} Rd,Rm,Rs
   Error if any register is R15.  */
d5157 1
a5157 1
do_smul (void)
d5159 1
a5159 3
  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 8;
d5162 1
a5162 1
/* ARM V6 srs (argument parse).	 */
d5165 1
a5165 1
do_srs (void)
d5167 2
a5168 3
  inst.instruction |= inst.operands[0].imm;
  if (inst.operands[0].writeback)
    inst.instruction |= WRITE_BACK;
d5171 1
a5171 1
/* ARM V6 strex (argument parse).  */
d5173 4
a5176 2
static void
do_strex (void)
d5178 176
a5353 19
  constraint (!inst.operands[2].isreg || !inst.operands[2].preind
	      || inst.operands[2].postind || inst.operands[2].writeback
	      || inst.operands[2].immisreg || inst.operands[2].shifted
	      || inst.operands[2].negative,
	      _("instruction does not accept this addressing mode"));

  constraint (inst.operands[2].reg == REG_PC, BAD_PC);

  constraint (inst.operands[0].reg == inst.operands[1].reg
	      || inst.operands[0].reg == inst.operands[2].reg, BAD_OVERLAP);

  constraint (inst.reloc.exp.X_op != O_constant
	      || inst.reloc.exp.X_add_number != 0,
	      _("offset must be zero in ARM encoding"));

  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 16;
  inst.reloc.type = BFD_RELOC_UNUSED;
d5357 1
a5357 1
do_strexd (void)
d5359 24
a5382 17
  constraint (inst.operands[1].reg % 2 != 0,
	      _("even register required"));
  constraint (inst.operands[2].present
	      && inst.operands[2].reg != inst.operands[1].reg + 1,
	      _("can only store two consecutive registers"));
  /* If op 2 were present and equal to PC, this function wouldn't
     have been called in the first place.  */
  constraint (inst.operands[1].reg == REG_LR, _("r14 not allowed here"));

  constraint (inst.operands[0].reg == inst.operands[1].reg
	      || inst.operands[0].reg == inst.operands[1].reg + 1
	      || inst.operands[0].reg == inst.operands[3].reg,
	      BAD_OVERLAP);

  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[3].reg << 16;
a5384 8
/* ARM V6 SXTAH extracts a 16-bit value from a register, sign
   extends it to 32-bits, and adds the result to a value in another
   register.  You can specify a rotation by 0, 8, 16, or 24 bits
   before extracting the 16-bit value.
   SXTAH{<cond>} <Rd>, <Rn>, <Rm>{, <rotation>}
   Condition defaults to COND_ALWAYS.
   Error if any register uses R15.  */

d5386 1
a5386 1
do_sxtah (void)
d5388 1
a5388 5
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
  inst.instruction |= inst.operands[3].imm << 10;
}
d5390 1
a5390 1
/* ARM V6 SXTH.
d5392 3
a5394 3
   SXTH {<cond>} <Rd>, <Rm>{, <rotation>}
   Condition defaults to COND_ALWAYS.
   Error if any register uses R15.  */
d5397 1
a5397 1
do_sxth (void)
d5399 1
a5399 3
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].imm << 10;
a5400 3

/* VFP instructions.  In a logical order: SP variant first, monad
   before dyad, arithmetic then move then load/store.  */
d5403 1
a5403 1
do_vfp_sp_monadic (void)
d5405 6
a5410 2
  encode_arm_vfp_sp_reg (inst.operands[0].reg, VFP_REG_Sd);
  encode_arm_vfp_sp_reg (inst.operands[1].reg, VFP_REG_Sm);
d5414 1
a5414 1
do_vfp_sp_dyadic (void)
d5416 6
a5421 3
  encode_arm_vfp_sp_reg (inst.operands[0].reg, VFP_REG_Sd);
  encode_arm_vfp_sp_reg (inst.operands[1].reg, VFP_REG_Sn);
  encode_arm_vfp_sp_reg (inst.operands[2].reg, VFP_REG_Sm);
d5425 1
a5425 1
do_vfp_sp_compare_z (void)
d5427 6
a5432 1
  encode_arm_vfp_sp_reg (inst.operands[0].reg, VFP_REG_Sd);
d5436 1
a5436 1
do_vfp_dp_sp_cvt (void)
d5438 1
a5438 2
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_vfp_sp_reg (inst.operands[1].reg, VFP_REG_Sm);
d5442 1
a5442 1
do_vfp_sp_dp_cvt (void)
d5444 1
a5444 2
  encode_arm_vfp_sp_reg (inst.operands[0].reg, VFP_REG_Sd);
  inst.instruction |= inst.operands[1].reg;
d5448 1
a5448 1
do_vfp_reg_from_sp (void)
d5450 1
a5450 2
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_vfp_sp_reg (inst.operands[1].reg, VFP_REG_Sn);
d5454 1
a5454 1
do_vfp_reg2_from_sp2 (void)
d5456 1
a5456 5
  constraint (inst.operands[2].imm != 2,
	      _("only two consecutive VFP SP registers allowed here"));
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  encode_arm_vfp_sp_reg (inst.operands[2].reg, VFP_REG_Sm);
d5460 1
a5460 1
do_vfp_sp_from_reg (void)
d5462 1
a5462 2
  encode_arm_vfp_sp_reg (inst.operands[0].reg, VFP_REG_Sn);
  inst.instruction |= inst.operands[1].reg << 12;
d5466 1
a5466 1
do_vfp_sp2_from_reg2 (void)
d5468 1
a5468 5
  constraint (inst.operands[0].imm != 2,
	      _("only two consecutive VFP SP registers allowed here"));
  encode_arm_vfp_sp_reg (inst.operands[0].reg, VFP_REG_Sm);
  inst.instruction |= inst.operands[1].reg << 12;
  inst.instruction |= inst.operands[2].reg << 16;
d5472 1
a5472 1
do_vfp_sp_ldst (void)
d5474 1
a5474 2
  encode_arm_vfp_sp_reg (inst.operands[0].reg, VFP_REG_Sd);
  encode_arm_cp_address (1, FALSE, TRUE, 0);
d5478 1
a5478 1
do_vfp_dp_ldst (void)
d5480 6
a5485 2
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_cp_address (1, FALSE, TRUE, 0);
a5487 1

d5489 1
a5489 1
vfp_sp_ldstm (enum vfp_ldstm_type ldstm_type)
d5491 4
a5494 8
  if (inst.operands[0].writeback)
    inst.instruction |= WRITE_BACK;
  else
    constraint (ldstm_type != VFP_LDSTMIA,
		_("this addressing mode requires base-register writeback"));
  inst.instruction |= inst.operands[0].reg << 16;
  encode_arm_vfp_sp_reg (inst.operands[1].reg, VFP_REG_Sd);
  inst.instruction |= inst.operands[1].imm;
d5498 1
a5498 1
vfp_dp_ldstm (enum vfp_ldstm_type ldstm_type)
d5500 2
a5501 1
  int count;
d5503 2
a5504 5
  if (inst.operands[0].writeback)
    inst.instruction |= WRITE_BACK;
  else
    constraint (ldstm_type != VFP_LDSTMIA && ldstm_type != VFP_LDSTMIAX,
		_("this addressing mode requires base-register writeback"));
d5506 1
a5506 2
  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg << 12;
d5508 9
a5516 3
  count = inst.operands[1].imm << 1;
  if (ldstm_type == VFP_LDSTMIAX || ldstm_type == VFP_LDSTMDBX)
    count += 1;
d5518 9
a5526 1
  inst.instruction |= count;
d5530 1
a5530 1
do_vfp_sp_ldstmia (void)
d5532 1
a5532 1
  vfp_sp_ldstm (VFP_LDSTMIA);
d5536 1
a5536 1
do_vfp_sp_ldstmdb (void)
d5538 1
a5538 1
  vfp_sp_ldstm (VFP_LDSTMDB);
d5542 1
a5542 1
do_vfp_dp_ldstmia (void)
d5544 1
a5544 1
  vfp_dp_ldstm (VFP_LDSTMIA);
d5548 1
a5548 1
do_vfp_dp_ldstmdb (void)
d5550 6
a5555 1
  vfp_dp_ldstm (VFP_LDSTMDB);
d5559 1
a5559 1
do_vfp_xp_ldstmia (void)
d5561 4
a5564 1
  vfp_dp_ldstm (VFP_LDSTMIAX);
d5567 5
d5573 1
a5573 1
do_vfp_xp_ldstmdb (void)
d5575 17
a5591 4
  vfp_dp_ldstm (VFP_LDSTMDBX);
}

/* FPA instructions.  Also in a logical order.	*/
d5593 2
a5594 5
static void
do_fpa_cmp (void)
{
  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg;
d5597 1
a5597 12
static void
do_fpa_ldmstm (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  switch (inst.operands[1].imm)
    {
    case 1: inst.instruction |= CP_T_X;		 break;
    case 2: inst.instruction |= CP_T_Y;		 break;
    case 3: inst.instruction |= CP_T_Y | CP_T_X; break;
    case 4:					 break;
    default: abort ();
    }
d5599 1
a5599 27
  if (inst.instruction & (PRE_INDEX | INDEX_UP))
    {
      /* The instruction specified "ea" or "fd", so we can only accept
	 [Rn]{!}.  The instruction does not really support stacking or
	 unstacking, so we have to emulate these by setting appropriate
	 bits and offsets.  */
      constraint (inst.reloc.exp.X_op != O_constant
		  || inst.reloc.exp.X_add_number != 0,
		  _("this instruction does not support indexing"));

      if ((inst.instruction & PRE_INDEX) || inst.operands[2].writeback)
	inst.reloc.exp.X_add_number = 12 * inst.operands[1].imm;

      if (!(inst.instruction & INDEX_UP))
	inst.reloc.exp.X_add_number = -inst.reloc.exp.X_add_number;

      if (!(inst.instruction & PRE_INDEX) && inst.operands[2].writeback)
	{
	  inst.operands[2].preind = 0;
	  inst.operands[2].postind = 1;
	}
    }

  encode_arm_cp_address (2, TRUE, TRUE, 0);
}

/* iWMMXt instructions: strictly in alphabetical order.	 */
d5602 1
a5602 1
do_iwmmxt_tandorc (void)
d5604 1
a5604 2
  constraint (inst.operands[0].reg != REG_PC, _("only r15 allowed here"));
}
d5606 2
a5607 6
static void
do_iwmmxt_textrc (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].imm;
}
d5609 3
a5611 7
static void
do_iwmmxt_textrm (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].imm;
}
d5613 3
a5615 7
static void
do_iwmmxt_tinsr (void)
{
  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg << 12;
  inst.instruction |= inst.operands[2].imm;
}
d5617 3
a5619 7
static void
do_iwmmxt_tmia (void)
{
  inst.instruction |= inst.operands[0].reg << 5;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 12;
}
d5621 2
a5622 7
static void
do_iwmmxt_waligni (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
  inst.instruction |= inst.operands[3].imm << 20;
d5625 1
a5625 8
static void
do_iwmmxt_wmov (void)
{
  /* WMOV rD, rN is an alias for WOR rD, rN, rN.  */
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[1].reg;
}
d5627 1
a5627 7
static void
do_iwmmxt_wldstbh (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.reloc.exp.X_add_number *= 4;
  encode_arm_cp_address (1, TRUE, FALSE, BFD_RELOC_ARM_CP_OFF_IMM_S2);
}
d5630 1
a5630 1
do_iwmmxt_wldstw (void)
d5632 2
a5633 6
  /* RIWR_RIWC clears .isreg for a control register.  */
  if (!inst.operands[0].isreg)
    {
      constraint (inst.cond != COND_ALWAYS, BAD_COND);
      inst.instruction |= 0xf0000000;
    }
d5635 1
a5635 3
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_cp_address (1, TRUE, TRUE, 0);
}
d5637 2
a5638 6
static void
do_iwmmxt_wldstd (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  encode_arm_cp_address (1, TRUE, FALSE, BFD_RELOC_ARM_CP_OFF_IMM_S2);
}
d5640 3
a5642 8
static void
do_iwmmxt_wshufh (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= ((inst.operands[2].imm & 0xf0) << 16);
  inst.instruction |= (inst.operands[2].imm & 0x0f);
}
d5644 3
a5646 11
static void
do_iwmmxt_wzero (void)
{
  /* WZERO reg is an alias for WANDN reg, reg, reg.  */
  inst.instruction |= inst.operands[0].reg;
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[0].reg << 16;
}

/* Cirrus Maverick instructions.  Simple 2-, 3-, and 4-register
   operations first, then control, shift, and load/store.  */
d5648 3
a5650 1
/* Insns like "foo X,Y,Z".  */
d5652 4
a5655 6
static void
do_mav_triple (void)
{
  inst.instruction |= inst.operands[0].reg << 16;
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 12;
d5658 2
a5659 5
/* Insns like "foo W,X,Y,Z".
    where W=MVAX[0:3] and X,Y,Z=MVFX[0:15].  */

static void
do_mav_quad (void)
d5661 1
a5661 5
  inst.instruction |= inst.operands[0].reg << 5;
  inst.instruction |= inst.operands[1].reg << 12;
  inst.instruction |= inst.operands[2].reg << 16;
  inst.instruction |= inst.operands[3].reg;
}
d5663 7
a5669 6
/* cfmvsc32<cond> DSPSC,MVDX[15:0].  */
static void
do_mav_dspsc (void)
{
  inst.instruction |= inst.operands[1].reg << 12;
}
d5671 3
a5673 3
/* Maverick shift immediate instructions.
   cfsh32<cond> MVFX[15:0],MVFX[15:0],Shift[6:0].
   cfsh64<cond> MVDX[15:0],MVDX[15:0],Shift[6:0].  */
d5675 5
a5679 4
static void
do_mav_shift (void)
{
  int imm = inst.operands[2].imm;
d5681 5
a5685 2
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
d5687 8
a5694 9
  /* Bits 0-3 of the insn should have bits 0-3 of the immediate.
     Bits 5-7 of the insn should have bits 4-6 of the immediate.
     Bit 4 should be 0.	 */
  imm = (imm & 0xf) | ((imm & 0x70) << 1);

  inst.instruction |= imm;
}

/* XScale instructions.	 Also sorted arithmetic before move.  */
d5696 3
a5698 4
/* Xscale multiply-accumulate (argument parse)
     MIAcc   acc0,Rm,Rs
     MIAPHcc acc0,Rm,Rs
     MIAxycc acc0,Rm,Rs.  */
d5700 3
a5702 6
static void
do_xsc_mia (void)
{
  inst.instruction |= inst.operands[1].reg;
  inst.instruction |= inst.operands[2].reg << 12;
}
d5704 3
a5706 1
/* Xscale move-accumulator-register (argument parse)
d5708 3
a5710 1
     MARcc   acc0,RdLo,RdHi.  */
d5712 2
a5713 5
static void
do_xsc_mar (void)
{
  inst.instruction |= inst.operands[1].reg << 12;
  inst.instruction |= inst.operands[2].reg << 16;
d5716 3
a5718 1
/* Xscale move-register-accumulator (argument parse)
d5720 1
a5720 1
     MRAcc   RdLo,RdHi,acc0.  */
d5723 1
a5723 1
do_xsc_mra (void)
d5725 1
a5725 6
  constraint (inst.operands[0].reg == inst.operands[1].reg, BAD_OVERLAP);
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
}

/* Encoding functions relevant only to Thumb.  */
d5727 1
a5727 8
/* inst.operands[i] is a shifted-register operand; encode
   it into inst.instruction in the format used by Thumb32.  */

static void
encode_thumb32_shifted_operand (int i)
{
  unsigned int value = inst.reloc.exp.X_add_number;
  unsigned int shift = inst.operands[i].shift_kind;
d5729 1
a5729 4
  inst.instruction |= inst.operands[i].reg;
  if (shift == SHIFT_RRX)
    inst.instruction |= SHIFT_ROR << 4;
  else
d5731 2
a5732 16
      constraint (inst.reloc.exp.X_op != O_constant,
		  _("expression too complex"));

      constraint (value > 32
		  || (value == 32 && (shift == SHIFT_LSL
				      || shift == SHIFT_ROR)),
		  _("shift expression is too large"));

      if (value == 0)
	shift = SHIFT_LSL;
      else if (value == 32)
	value = 0;

      inst.instruction |= shift << 4;
      inst.instruction |= (value & 0x1c) << 10;
      inst.instruction |= (value & 0x03) << 6;
a5733 1
}
d5735 2
d5738 2
a5739 5
/* inst.operands[i] was set up by parse_address.  Encode it into a
   Thumb32 format load or store instruction.  Reject forms that cannot
   be used with such instructions.  If is_t is true, reject forms that
   cannot be used with a T instruction; if is_d is true, reject forms
   that cannot be used with a D instruction.  */
d5741 1
a5741 7
static void
encode_thumb32_addr_mode (int i, bfd_boolean is_t, bfd_boolean is_d)
{
  bfd_boolean is_pc = (inst.operands[i].reg == REG_PC);

  constraint (!inst.operands[i].isreg,
	      _("Thumb does not support the ldr =N pseudo-operation"));
d5743 1
a5743 2
  inst.instruction |= inst.operands[i].reg << 16;
  if (inst.operands[i].immisreg)
d5745 3
a5747 10
      constraint (is_pc, _("cannot use register index with PC-relative addressing"));
      constraint (is_t || is_d, _("cannot use register index with this instruction"));
      constraint (inst.operands[i].negative,
		  _("Thumb does not support negative register indexing"));
      constraint (inst.operands[i].postind,
		  _("Thumb does not support register post-indexing"));
      constraint (inst.operands[i].writeback,
		  _("Thumb does not support register indexing with writeback"));
      constraint (inst.operands[i].shifted && inst.operands[i].shift_kind != SHIFT_LSL,
		  _("Thumb supports only LSL in shifted register indexing"));
d5749 2
a5750 2
      inst.instruction |= inst.operands[1].imm;
      if (inst.operands[i].shifted)
d5752 8
a5759 5
	  constraint (inst.reloc.exp.X_op != O_constant,
		      _("expression too complex"));
	  constraint (inst.reloc.exp.X_add_number < 0 || inst.reloc.exp.X_add_number > 3,
		      _("shift out of range"));
	  inst.instruction |= inst.reloc.exp.X_op << 4;
d5761 2
a5762 1
      inst.reloc.type = BFD_RELOC_UNUSED;
d5764 1
a5764 1
  else if (inst.operands[i].preind)
d5766 1
a5766 142
      constraint (is_pc && inst.operands[i].writeback,
		  _("cannot use writeback with PC-relative addressing"));
      constraint (is_t && inst.operands[1].writeback,
		  _("cannot use writeback with this instruction"));

      if (is_d)
	{
	  inst.instruction |= 0x01000000;
	  if (inst.operands[i].writeback)
	    inst.instruction |= 0x00200000;
	}
      else
	{
	  inst.instruction |= 0x00000c00;
	  if (inst.operands[i].writeback)
	    inst.instruction |= 0x00000100;
	}
      inst.reloc.type = BFD_RELOC_ARM_T32_OFFSET_IMM;
      inst.reloc.pc_rel = is_pc;
    }
  else if (inst.operands[i].postind)
    {
      assert (inst.operands[i].writeback);
      constraint (is_pc, _("cannot use post-indexing with PC-relative addressing"));
      constraint (is_t, _("cannot use post-indexing with this instruction"));

      if (is_d)
	inst.instruction |= 0x00200000;
      else
	inst.instruction |= 0x00000900;
      inst.reloc.type = BFD_RELOC_ARM_T32_OFFSET_IMM;
    }
  else /* unindexed - only for coprocessor */
    inst.error = _("instruction does not accept unindexed addressing");
}

/* Table of Thumb instructions which exist in both 16- and 32-bit
   encodings (the latter only in post-V6T2 cores).  The index is the
   value used in the insns table below.  When there is more than one
   possible 16-bit encoding for the instruction, this table always
   holds variant (1).  */
#define T16_32_TAB				\
  X(adc,   4140, eb400000),			\
  X(adcs,  4140, eb500000),			\
  X(add,   1c00, eb000000),			\
  X(adds,  1c00, eb100000),			\
  X(and,   4000, ea000000),			\
  X(ands,  4000, ea100000),			\
  X(asr,   1000, fa40f000),			\
  X(asrs,  1000, fa50f000),			\
  X(bic,   4380, ea200000),			\
  X(bics,  4380, ea300000),			\
  X(cmn,   42c0, eb100f00),			\
  X(cmp,   2800, ebb00f00),			\
  X(cpsie, b660, f3af8400),			\
  X(cpsid, b670, f3af8600),			\
  X(cpy,   4600, ea4f0000),			\
  X(eor,   4040, ea800000),			\
  X(eors,  4040, ea900000),			\
  X(ldmia, c800, e8900000),			\
  X(ldr,   6800, f8500000),			\
  X(ldrb,  7800, f8100000),			\
  X(ldrh,  8800, f8300000),			\
  X(ldrsb, 5600, f9100000),			\
  X(ldrsh, 5e00, f9300000),			\
  X(lsl,   0000, fa00f000),			\
  X(lsls,  0000, fa10f000),			\
  X(lsr,   0800, fa20f000),			\
  X(lsrs,  0800, fa30f000),			\
  X(mov,   2000, ea4f0000),			\
  X(movs,  2000, ea5f0000),			\
  X(mul,   4340, fb00f000),                     \
  X(muls,  4340, ffffffff), /* no 32b muls */	\
  X(mvn,   43c0, ea6f0000),			\
  X(mvns,  43c0, ea7f0000),			\
  X(neg,   4240, f1c00000), /* rsb #0 */	\
  X(negs,  4240, f1d00000), /* rsbs #0 */	\
  X(orr,   4300, ea400000),			\
  X(orrs,  4300, ea500000),			\
  X(pop,   bc00, e8ad0000), /* ldmia sp!,... */	\
  X(push,  b400, e8bd0000), /* stmia sp!,... */	\
  X(rev,   ba00, fa90f080),			\
  X(rev16, ba40, fa90f090),			\
  X(revsh, bac0, fa90f0b0),			\
  X(ror,   41c0, fa60f000),			\
  X(rors,  41c0, fa70f000),			\
  X(sbc,   4180, eb600000),			\
  X(sbcs,  4180, eb700000),			\
  X(stmia, c000, e8800000),			\
  X(str,   6000, f8400000),			\
  X(strb,  7000, f8000000),			\
  X(strh,  8000, f8200000),			\
  X(sub,   1e00, eba00000),			\
  X(subs,  1e00, ebb00000),			\
  X(sxtb,  b240, fa4ff080),			\
  X(sxth,  b200, fa0ff080),			\
  X(tst,   4200, ea100f00),			\
  X(uxtb,  b2c0, fa5ff080),			\
  X(uxth,  b280, fa1ff080),			\
  X(nop,   bf00, f3af8000),			\
  X(yield, bf10, f3af8001),			\
  X(wfe,   bf20, f3af8002),			\
  X(wfi,   bf30, f3af8003),			\
  X(sev,   bf40, f3af9004), /* typo, 8004? */

/* To catch errors in encoding functions, the codes are all offset by
   0xF800, putting them in one of the 32-bit prefix ranges, ergo undefined
   as 16-bit instructions.  */
#define X(a,b,c) T_MNEM_##a
enum t16_32_codes { T16_32_OFFSET = 0xF7FF, T16_32_TAB };
#undef X

#define X(a,b,c) 0x##b
static const unsigned short thumb_op16[] = { T16_32_TAB };
#define THUMB_OP16(n) (thumb_op16[(n) - (T16_32_OFFSET + 1)])
#undef X

#define X(a,b,c) 0x##c
static const unsigned int thumb_op32[] = { T16_32_TAB };
#define THUMB_OP32(n) (thumb_op32[(n) - (T16_32_OFFSET + 1)])
#define THUMB_SETS_FLAGS(n) (THUMB_OP32 (n) & 0x00100000)
#undef X
#undef T16_32_TAB

/* Thumb instruction encoders, in alphabetical order.  */

/* Parse an add or subtract instruction.  We get here with inst.instruction
   equalling any of THUMB_OPCODE_add, adds, sub, or subs.  */

static void
do_t_add_sub (void)
{
  int Rd, Rs, Rn;

  Rd = inst.operands[0].reg;
  Rs = (inst.operands[1].present
	? inst.operands[1].reg    /* Rd, Rs, foo */
	: inst.operands[0].reg);  /* Rd, foo -> Rd, Rd, foo */

  if (unified_syntax)
    {
      if (!inst.operands[2].isreg)
d5768 2
a5769 7
	  /* For an immediate, we always generate a 32-bit opcode;
	     section relaxation will shrink it later if possible.  */
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
	  inst.instruction |= inst.operands[0].reg << 8;
	  inst.instruction |= inst.operands[1].reg << 16;
	  inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
a5770 16
      else
	{
	  Rn = inst.operands[2].reg;
	  /* See if we can do this with a 16-bit instruction.  */
	  if (!inst.operands[2].shifted && inst.size_req != 4)
	    {
	      if (Rd <= 7 && Rn <= 7 && Rn <= 7
		  && (inst.instruction == T_MNEM_adds
		      || inst.instruction == T_MNEM_subs))
		{
		  inst.instruction = (inst.instruction == T_MNEM_adds
				      ? T_OPCODE_ADD_R3
				      : T_OPCODE_SUB_R3);
		  inst.instruction |= Rd | (Rs << 3) | (Rn << 6);
		  return;
		}
d5772 4
a5775 35
	      if (inst.instruction == T_MNEM_add)
		{
		  if (Rd == Rs)
		    {
		      inst.instruction = T_OPCODE_ADD_HI;
		      inst.instruction |= (Rd & 8) << 4;
		      inst.instruction |= (Rd & 7);
		      inst.instruction |= Rn << 3;
		      return;
		    }
		  /* ... because addition is commutative! */
		  else if (Rd == Rn)
		    {
		      inst.instruction = T_OPCODE_ADD_HI;
		      inst.instruction |= (Rd & 8) << 4;
		      inst.instruction |= (Rd & 7);
		      inst.instruction |= Rs << 3;
		      return;
		    }
		}
	    }
	  /* If we get here, it can't be done in 16 bits.  */
	  constraint (inst.operands[2].shifted && inst.operands[2].immisreg,
		      _("shift must be constant"));
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction |= Rd << 8;
	  inst.instruction |= Rs << 16;
	  encode_thumb32_shifted_operand (2);
	}
    }
  else
    {
      constraint (inst.instruction == T_MNEM_adds
		  || inst.instruction == T_MNEM_subs,
		  BAD_THUMB32);
d5777 1
a5777 1
      if (!inst.operands[2].isreg) /* Rd, Rs, #imm */
d5779 1
a5779 8
	  constraint ((Rd > 7 && (Rd != REG_SP || Rs != REG_SP))
		      || (Rs > 7 && Rs != REG_SP && Rs != REG_PC),
		      BAD_HIREG);

	  inst.instruction = (inst.instruction == T_MNEM_add
			      ? 0x0000 : 0x8000);
	  inst.instruction |= (Rd << 4) | Rs;
	  inst.reloc.type = BFD_RELOC_ARM_THUMB_ADD;
d5783 2
a5784 2
      Rn = inst.operands[2].reg;
      constraint (inst.operands[2].shifted, _("unshifted register required"));
d5786 1
a5786 2
      /* We now have Rd, Rs, and Rn set to registers.  */
      if (Rd > 7 || Rs > 7 || Rn > 7)
d5788 2
a5789 17
	  /* Can't do this for SUB.	 */
	  constraint (inst.instruction == T_MNEM_sub, BAD_HIREG);
	  inst.instruction = T_OPCODE_ADD_HI;
	  inst.instruction |= (Rd & 8) << 4;
	  inst.instruction |= (Rd & 7);
	  if (Rs == Rd)
	    inst.instruction |= Rn << 3;
	  else if (Rn == Rd)
	    inst.instruction |= Rs << 3;
	  else
	    constraint (1, _("dest must overlap one source register"));
	}
      else
	{
	  inst.instruction = (inst.instruction == T_MNEM_add
			      ? T_OPCODE_ADD_R3 : T_OPCODE_SUB_R3);
	  inst.instruction |= Rd | (Rs << 3) | (Rn << 6);
d5791 2
d5794 2
d5798 6
d5805 1
a5805 1
do_t_adr (void)
d5807 2
a5808 3
  inst.reloc.type = BFD_RELOC_ARM_THUMB_ADD;
  inst.reloc.exp.X_add_number -= 4; /* PC relative adjust.  */
  inst.reloc.pc_rel = 1;
d5810 1
a5810 2
  inst.instruction |= inst.operands[0].reg << 4;
}
d5812 5
a5816 10
/* Arithmetic instructions for which there is just one 16-bit
   instruction encoding, and it allows only two low registers.
   For maximal compatibility with ARM syntax, we allow three register
   operands even when Thumb-32 instructions are not available, as long
   as the first two are identical.  For instance, both "sbc r0,r1" and
   "sbc r0,r0,r1" are allowed.  */
static void
do_t_arit3 (void)
{
  int Rd, Rs, Rn;
d5818 7
a5824 31
  Rd = inst.operands[0].reg;
  Rs = (inst.operands[1].present
	? inst.operands[1].reg    /* Rd, Rs, foo */
	: inst.operands[0].reg);  /* Rd, foo -> Rd, Rd, foo */
  Rn = inst.operands[2].reg;

  if (unified_syntax)
    {
      if (!inst.operands[2].isreg)
	{
	  /* For an immediate, we always generate a 32-bit opcode;
	     section relaxation will shrink it later if possible.  */
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
	  inst.instruction |= Rd << 8;
	  inst.instruction |= Rs << 16;
	  inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
	}
      else
	{
	  /* See if we can do this with a 16-bit instruction.  */
	  if (THUMB_SETS_FLAGS (inst.instruction)
	      && !inst.operands[2].shifted
	      && inst.size_req != 4
	      && Rd == Rs)
	    {
	      inst.instruction = THUMB_OP16 (inst.instruction);
	      inst.instruction |= Rd;
	      inst.instruction |= Rn << 3;
	      return;
	    }
d5826 5
a5830 9
	  /* If we get here, it can't be done in 16 bits.  */
	  constraint (inst.operands[2].shifted
		      && inst.operands[2].immisreg,
		      _("shift must be constant"));
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction |= Rd << 8;
	  inst.instruction |= Rs << 16;
	  encode_thumb32_shifted_operand (2);
	}
d5832 2
a5833 1
  else
d5835 3
a5837 4
      /* On its face this is a lie - the instruction does set the
	 flags.  However, the only supported mnemonic in this mode
	 says it doesn't.  */
      constraint (THUMB_SETS_FLAGS (inst.instruction), BAD_THUMB32);
d5839 11
a5849 5
      constraint (!inst.operands[2].isreg || inst.operands[2].shifted,
		  _("unshifted register required"));
      constraint (Rd > 7 || Rs > 7 || Rn > 7, BAD_HIREG);
      constraint (Rd != Rs,
		  _("dest and source1 must be the same register"));
d5851 2
a5852 3
      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= Rd;
      inst.instruction |= Rn << 3;
d5854 2
d5858 5
a5862 7
/* Similarly, but for instructions where the arithmetic operation is
   commutative, so we can allow either of them to be different from
   the destination operand in a 16-bit instruction.  For instance, all
   three of "adc r0,r1", "adc r0,r0,r1", and "adc r0,r1,r0" are
   accepted.  */
static void
do_t_arit3c (void)
d5864 5
a5868 1
  int Rd, Rs, Rn;
d5870 1
a5870 5
  Rd = inst.operands[0].reg;
  Rs = (inst.operands[1].present
	? inst.operands[1].reg    /* Rd, Rs, foo */
	: inst.operands[0].reg);  /* Rd, foo -> Rd, Rd, foo */
  Rn = inst.operands[2].reg;
d5872 3
a5874 1
  if (unified_syntax)
d5876 1
a5876 1
      if (!inst.operands[2].isreg)
d5878 1
a5878 14
	  /* For an immediate, we always generate a 32-bit opcode;
	     section relaxation will shrink it later if possible.  */
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
	  inst.instruction |= Rd << 8;
	  inst.instruction |= Rs << 16;
	  inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
	}
      else
	{
	  /* See if we can do this with a 16-bit instruction.  */
	  if (THUMB_SETS_FLAGS (inst.instruction)
	      && !inst.operands[2].shifted
	      && inst.size_req != 4)
d5880 2
a5881 14
	      if (Rd == Rs)
		{
		  inst.instruction = THUMB_OP16 (inst.instruction);
		  inst.instruction |= Rd;
		  inst.instruction |= Rn << 3;
		  return;
		}
	      if (Rd == Rn)
		{
		  inst.instruction = THUMB_OP16 (inst.instruction);
		  inst.instruction |= Rd;
		  inst.instruction |= Rs << 3;
		  return;
		}
d5884 5
a5888 8
	  /* If we get here, it can't be done in 16 bits.  */
	  constraint (inst.operands[2].shifted
		      && inst.operands[2].immisreg,
		      _("shift must be constant"));
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction |= Rd << 8;
	  inst.instruction |= Rs << 16;
	  encode_thumb32_shifted_operand (2);
d5891 8
a5898 1
  else
d5900 11
a5910 4
      /* On its face this is a lie - the instruction does set the
	 flags.  However, the only supported mnemonic in this mode
	 says it doesn't.  */
      constraint (THUMB_SETS_FLAGS (inst.instruction), BAD_THUMB32);
d5912 9
a5920 3
      constraint (!inst.operands[2].isreg || inst.operands[2].shifted,
		  _("unshifted register required"));
      constraint (Rd > 7 || Rs > 7 || Rn > 7, BAD_HIREG);
d5922 4
a5925 2
      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= Rd;
d5927 10
a5936 6
      if (Rd == Rs)
	inst.instruction |= Rn << 3;
      else if (Rd == Rn)
	inst.instruction |= Rs << 3;
      else
	constraint (1, _("dest must overlap one source register"));
d5940 13
a5952 2
static void
do_t_bfc (void)
d5954 60
a6013 9
  unsigned int msb = inst.operands[1].imm + inst.operands[2].imm;
  constraint (msb > 32, _("bit-field extends past end of register"));
  /* The instruction encoding stores the LSB and MSB,
     not the LSB and width.  */
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= (inst.operands[1].imm & 0x1c) << 10;
  inst.instruction |= (inst.operands[1].imm & 0x03) << 6;
  inst.instruction |= msb - 1;
}
d6015 4
a6018 4
static void
do_t_bfi (void)
{
  unsigned int msb;
d6020 2
a6021 4
  /* #0 in second position is alternative syntax for bfc, which is
     the same instruction but with REG_PC in the Rm field.  */
  if (!inst.operands[1].isreg)
    inst.operands[1].reg = REG_PC;
d6023 3
a6025 9
  msb = inst.operands[2].imm + inst.operands[3].imm;
  constraint (msb > 32, _("bit-field extends past end of register"));
  /* The instruction encoding stores the LSB and MSB,
     not the LSB and width.  */
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= (inst.operands[2].imm & 0x1c) << 10;
  inst.instruction |= (inst.operands[2].imm & 0x03) << 6;
  inst.instruction |= msb - 1;
d6028 2
a6029 2
static void
do_t_bfx (void)
d6031 2
a6032 8
  constraint (inst.operands[2].imm + inst.operands[3].imm > 32,
	      _("bit-field extends past end of register"));
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= (inst.operands[2].imm & 0x1c) << 10;
  inst.instruction |= (inst.operands[2].imm & 0x03) << 6;
  inst.instruction |= inst.operands[3].imm - 1;
}
d6034 1
a6034 6
/* ARM V5 Thumb BLX (argument parse)
	BLX <target_addr>	which is BLX(1)
	BLX <Rm>		which is BLX(2)
   Unfortunately, there are two different opcodes for this mnemonic.
   So, the insns[].value is not used, and the code here zaps values
	into inst.instruction.
d6036 5
a6040 2
   ??? How to take advantage of the additional two bits of displacement
   available in Thumb32 mode?  Need new relocation?  */
d6042 2
a6043 6
static void
do_t_blx (void)
{
  if (inst.operands[0].isreg)
    /* We have a register, so this is BLX(2).  */
    inst.instruction |= inst.operands[0].reg << 3;
d6046 68
a6113 4
      /* No register.  This must be BLX(1).  */
      inst.instruction = 0xf7ffeffe;
      inst.reloc.type	= BFD_RELOC_THUMB_PCREL_BLX;
      inst.reloc.pc_rel = 1;
d6117 2
a6118 2
static void
do_t_branch (void)
d6120 4
a6123 14
  if (unified_syntax && inst.size_req != 2)
    {
      if (inst.cond == COND_ALWAYS)
	{
	  inst.instruction = 0xf7ffbffe;
	  inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH25;
	}
      else
	{
	  assert (inst.cond != 0xF);
	  inst.instruction = (inst.cond << 22) | 0xf43faffe;
	  inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH20;
	}
    }
d6126 2
a6127 3
      if (inst.cond == COND_ALWAYS)
	inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH12;
      else
d6129 37
a6165 2
	  inst.instruction = 0xd0fe | (inst.cond << 8);
	  inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH9;
d6167 3
a6170 2

  inst.reloc.pc_rel = 1;
d6174 1
a6174 1
do_t_bkpt (void)
d6176 7
a6182 1
  if (inst.operands[0].present)
d6184 3
a6186 3
      constraint (inst.operands[0].imm > 255,
		  _("immediate value out of range"));
      inst.instruction |= inst.operands[0].imm;
d6188 2
d6193 1
a6193 1
do_t_branch23 (void)
d6195 19
a6213 1
  inst.reloc.type   = BFD_RELOC_THUMB_PCREL_BRANCH23;
d6216 1
a6216 10
  /* If the destination of the branch is a defined symbol which does not have
     the THUMB_FUNC attribute, then we must be calling a function which has
     the (interfacearm) attribute.  We look for the Thumb entry point to that
     function and change the branch to refer to that function instead.	*/
  if (	 inst.reloc.exp.X_op == O_symbol
      && inst.reloc.exp.X_add_symbol != NULL
      && S_IS_DEFINED (inst.reloc.exp.X_add_symbol)
      && ! THUMB_IS_FUNC (inst.reloc.exp.X_add_symbol))
    inst.reloc.exp.X_add_symbol =
      find_real_start (inst.reloc.exp.X_add_symbol);
d6220 1
a6220 1
do_t_bx (void)
d6222 13
a6234 5
  inst.instruction |= inst.operands[0].reg << 3;
  /* ??? FIXME: Should add a hacky reloc here if reg is REG_PC.	 The reloc
     should cause the alignment to be checked once it is known.	 This is
     because BX PC only works if the instruction is word aligned.  */
}
d6236 2
a6237 5
static void
do_t_bxj (void)
{
  if (inst.operands[0].reg == REG_PC)
    as_tsktsk (_("use of r15 in bxj is not really useful"));
d6239 9
a6247 1
  inst.instruction |= inst.operands[0].reg << 16;
d6251 1
a6251 1
do_t_clz (void)
d6253 1
a6253 4
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[1].reg;
}
d6255 1
a6255 5
static void
do_t_cpsi (void)
{
  if (unified_syntax
      && (inst.operands[1].present || inst.size_req == 4))
d6257 3
a6259 6
      unsigned int imod = (inst.instruction & 0x0030) >> 4;
      inst.instruction = 0xf3af8000;
      inst.instruction |= imod << 9;
      inst.instruction |= inst.operands[0].imm << 5;
      if (inst.operands[1].present)
	inst.instruction |= 0x100 | inst.operands[1].imm;
d6261 3
a6263 1
  else
d6265 3
a6267 4
      constraint (inst.operands[1].present,
		  _("Thumb does not support the 2-argument "
		    "form of this instruction"));
      inst.instruction |= inst.operands[0].imm;
d6269 2
a6272 2
/* THUMB CPY instruction (argument parse).  */

d6274 1
a6274 1
do_t_cpy (void)
d6276 3
a6278 1
  if (inst.size_req == 4)
d6280 3
a6282 3
      inst.instruction = THUMB_OP32 (T_MNEM_mov);
      inst.instruction |= inst.operands[0].reg << 8;
      inst.instruction |= inst.operands[1].reg;
d6284 3
a6286 1
  else
d6288 3
a6290 3
      inst.instruction |= (inst.operands[0].reg & 0x8) << 4;
      inst.instruction |= (inst.operands[0].reg & 0x7);
      inst.instruction |= inst.operands[1].reg << 3;
a6291 1
}
d6293 1
a6293 7
static void
do_t_czb (void)
{
  constraint (inst.operands[0].reg > 7, BAD_HIREG);
  inst.instruction |= inst.operands[0].reg;
  inst.reloc.pc_rel = 1;
  inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH7;
d6297 1
a6297 1
do_t_hint (void)
d6299 3
a6301 5
  if (unified_syntax && inst.size_req == 4)
    inst.instruction = THUMB_OP32 (inst.instruction);
  else
    inst.instruction = THUMB_OP16 (inst.instruction);
}
d6303 16
a6318 5
static void
do_t_it (void)
{
  unsigned int cond = inst.operands[0].imm;
  if ((cond & 0x1) == 0x0)
d6320 1
a6320 2
      unsigned int mask = inst.instruction & 0x000f;
      inst.instruction &= 0xfff0;
d6322 3
a6324 8
      if ((mask & 0x7) == 0)
	/* no conversion needed */;
      else if ((mask & 0x3) == 0)
	mask = (~(mask & 0x8) & 0x8) | 0x4;
      else if ((mask & 1) == 0)
	mask = (~(mask & 0xC) & 0xC) | 0x2;
      else
	mask = (~(mask & 0xE) & 0xE) | 0x1;
d6326 2
a6327 2
      inst.instruction |= (mask & 0xF);
    }
d6329 2
a6330 2
  inst.instruction |= cond << 4;
}
d6332 1
a6332 8
static void
do_t_ldmstm (void)
{
  /* This really doesn't seem worth it.  */
  constraint (inst.reloc.type != BFD_RELOC_UNUSED,
	      _("expression too complex"));
  constraint (inst.operands[1].writeback,
	      _("Thumb load/store multiple does not support {reglist}^"));
d6334 1
a6334 11
  if (unified_syntax)
    {
      /* See if we can use a 16-bit instruction.  */
      if (inst.instruction < 0xffff /* not ldmdb/stmdb */
	  && inst.size_req != 4
	  && inst.operands[0].reg <= 7
	  && !(inst.operands[1].imm & ~0xff)
	  && (inst.instruction == T_MNEM_stmia
	      ? inst.operands[0].writeback
	      : (inst.operands[0].writeback
		 == !(inst.operands[1].imm & (1 << inst.operands[0].reg)))))
d6336 26
a6361 5
	  if (inst.instruction == T_MNEM_stmia
	      && (inst.operands[1].imm & (1 << inst.operands[0].reg))
	      && (inst.operands[1].imm & ((1 << inst.operands[0].reg) - 1)))
	    as_warn (_("value stored for r%d is UNPREDICTABLE"),
		     inst.operands[0].reg);
d6363 3
a6365 3
	  inst.instruction = THUMB_OP16 (inst.instruction);
	  inst.instruction |= inst.operands[0].reg << 8;
	  inst.instruction |= inst.operands[1].imm;
d6369 14
a6382 3
	  if (inst.operands[1].imm & (1 << 13))
	    as_warn (_("SP should not be in register list"));
	  if (inst.instruction == T_MNEM_stmia)
d6384 2
a6385 5
	      if (inst.operands[1].imm & (1 << 15))
		as_warn (_("PC should not be in register list"));
	      if (inst.operands[1].imm & (1 << inst.operands[0].reg))
		as_warn (_("value stored for r%d is UNPREDICTABLE"),
			 inst.operands[0].reg);
d6387 4
a6390 1
	  else
d6392 6
a6397 7
	      if (inst.operands[1].imm & (1 << 14)
		  && inst.operands[1].imm & (1 << 15))
		as_warn (_("LR and PC should not both be in register list"));
	      if ((inst.operands[1].imm & (1 << inst.operands[0].reg))
		  && inst.operands[0].writeback)
		as_warn (_("base register should not be in register list "
			   "when written back"));
a6398 6
	  if (inst.instruction < 0xffff)
	    inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction |= inst.operands[0].reg << 16;
	  inst.instruction |= inst.operands[1].imm;
	  if (inst.operands[0].writeback)
	    inst.instruction |= WRITE_BACK;
d6401 1
a6401 1
  else
d6403 1
a6403 3
      constraint (inst.operands[0].reg > 7
		  || (inst.operands[1].imm & ~0xff), BAD_HIREG);
      if (inst.instruction == T_MNEM_stmia)
d6405 2
a6406 6
	  if (!inst.operands[0].writeback)
	    as_warn (_("this instruction will write back the base register"));
	  if ((inst.operands[1].imm & (1 << inst.operands[0].reg))
	      && (inst.operands[1].imm & ((1 << inst.operands[0].reg) - 1)))
	    as_warn (_("value stored for r%d is UNPREDICTABLE"),
		     inst.operands[0].reg);
d6408 11
a6418 1
      else
d6420 2
a6421 6
	  if (!inst.operands[0].writeback
	      && !(inst.operands[1].imm & (1 << inst.operands[0].reg)))
	    as_warn (_("this instruction will write back the base register"));
	  else if (inst.operands[0].writeback
		   && (inst.operands[1].imm & (1 << inst.operands[0].reg)))
	    as_warn (_("this instruction will not write back the base register"));
d6424 16
a6439 5
      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= inst.operands[0].reg << 8;
      inst.instruction |= inst.operands[1].imm;
    }
}
d6441 11
a6451 8
static void
do_t_ldrex (void)
{
  constraint (!inst.operands[1].isreg || !inst.operands[1].preind
	      || inst.operands[1].postind || inst.operands[1].writeback
	      || inst.operands[1].immisreg || inst.operands[1].shifted
	      || inst.operands[1].negative,
	      _("instruction does not accept this addressing mode"));
d6453 7
a6459 4
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.reloc.type = BFD_RELOC_ARM_T32_OFFSET_U8;
}
d6461 7
a6467 4
static void
do_t_ldrexd (void)
{
  if (!inst.operands[1].present)
d6469 11
a6479 4
      constraint (inst.operands[0].reg == REG_LR,
		  _("r14 not allowed as first register "
		    "when second register is omitted"));
      inst.operands[1].reg = inst.operands[0].reg + 1;
a6480 2
  constraint (inst.operands[0].reg == inst.operands[1].reg,
	      BAD_OVERLAP);
d6482 2
a6483 3
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 8;
  inst.instruction |= inst.operands[2].reg << 16;
d6487 1
a6487 1
do_t_ldst (void)
d6489 5
a6493 1
  if (unified_syntax)
d6495 2
a6496 15
      /* Generation of 16-bit instructions for anything other than
	 Rd, [Rn, Ri] is deferred to section relaxation time.  */
      if (inst.operands[1].isreg && inst.operands[1].immisreg
	  && !inst.operands[1].shifted && !inst.operands[1].postind
	  && !inst.operands[1].negative && inst.operands[0].reg <= 7
	  && inst.operands[1].reg <= 7 && inst.operands[1].imm <= 7
	  && inst.instruction <= 0xffff)
	{
	  inst.instruction = THUMB_OP16 (inst.instruction);
	  goto op16;
	}

      inst.instruction = THUMB_OP32 (inst.instruction);
      inst.instruction |= inst.operands[0].reg << 12;
      encode_thumb32_addr_mode (1, /*is_t=*/FALSE, /*is_d=*/FALSE);
d6500 1
a6500 3
  constraint (inst.operands[0].reg > 7, BAD_HIREG);

  if (inst.instruction == T_MNEM_ldrsh || inst.instruction == T_MNEM_ldrsb)
d6502 2
a6503 8
      /* Only [Rn,Rm] is acceptable.  */
      constraint (inst.operands[1].reg > 7 || inst.operands[1].imm > 7, BAD_HIREG);
      constraint (!inst.operands[1].isreg || !inst.operands[1].immisreg
		  || inst.operands[1].postind || inst.operands[1].shifted
		  || inst.operands[1].negative,
		  _("Thumb does not support this addressing mode"));
      inst.instruction = THUMB_OP16 (inst.instruction);
      goto op16;
a6504 5
     
  inst.instruction = THUMB_OP16 (inst.instruction);
  if (!inst.operands[1].isreg)
    if (move_or_literal_pool (0, /*thumb_p=*/TRUE, /*mode_3=*/FALSE))
      return;
d6506 1
a6506 5
  constraint (!inst.operands[1].preind
	      || inst.operands[1].shifted
	      || inst.operands[1].writeback,
	      _("Thumb does not support this addressing mode"));
  if (inst.operands[1].reg == REG_PC || inst.operands[1].reg == REG_SP)
d6508 3
a6510 7
      constraint (inst.instruction & 0x0600,
		  _("byte or halfword not valid for base register"));
      constraint (inst.operands[1].reg == REG_PC
		  && !(inst.instruction & THUMB_LOAD_BIT),
		  _("r15 based store not allowed"));
      constraint (inst.operands[1].immisreg,
		  _("invalid base register for register offset"));
d6512 4
a6515 6
      if (inst.operands[1].reg == REG_PC)
	inst.instruction = T_OPCODE_LDR_PC;
      else if (inst.instruction & THUMB_LOAD_BIT)
	inst.instruction = T_OPCODE_LDR_SP;
      else
	inst.instruction = T_OPCODE_STR_SP;
d6517 6
a6522 4
      inst.instruction |= inst.operands[0].reg << 8;
      inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;
      return;
    }
d6524 1
a6524 9
  constraint (inst.operands[1].reg > 7, BAD_HIREG);
  if (!inst.operands[1].immisreg)
    {
      /* Immediate offset.  */
      inst.instruction |= inst.operands[0].reg;
      inst.instruction |= inst.operands[1].reg << 3;
      inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;
      return;
    }
d6526 3
a6528 4
  /* Register offset.  */
  constraint (inst.operands[1].imm > 7, BAD_HIREG);
  constraint (inst.operands[1].negative,
	      _("Thumb does not support this addressing mode"));
d6530 10
a6539 13
 op16:
  switch (inst.instruction)
    {
    case T_OPCODE_STR_IW: inst.instruction = T_OPCODE_STR_RW; break;
    case T_OPCODE_STR_IH: inst.instruction = T_OPCODE_STR_RH; break;
    case T_OPCODE_STR_IB: inst.instruction = T_OPCODE_STR_RB; break;
    case T_OPCODE_LDR_IW: inst.instruction = T_OPCODE_LDR_RW; break;
    case T_OPCODE_LDR_IH: inst.instruction = T_OPCODE_LDR_RH; break;
    case T_OPCODE_LDR_IB: inst.instruction = T_OPCODE_LDR_RB; break;
    case 0x5600 /* ldrsb */:
    case 0x5e00 /* ldrsh */: break;
    default: abort ();
    }
d6541 3
a6543 4
  inst.instruction |= inst.operands[0].reg;
  inst.instruction |= inst.operands[1].reg << 3;
  inst.instruction |= inst.operands[1].imm << 6;
}
d6545 10
a6554 4
static void
do_t_ldstd (void)
{
  if (!inst.operands[1].present)
d6556 2
a6557 3
      inst.operands[1].reg = inst.operands[0].reg + 1;
      constraint (inst.operands[0].reg == REG_LR,
		  _("r14 not allowed here"));
d6559 2
a6560 4
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 8;
  encode_thumb32_addr_mode (2, /*is_t=*/FALSE, /*is_d=*/TRUE);
			    
d6563 1
a6563 6
static void
do_t_ldstt (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  encode_thumb32_addr_mode (1, /*is_t=*/TRUE, /*is_d=*/FALSE);
}
d6566 1
a6566 1
do_t_mla (void)
d6568 3
a6570 5
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
  inst.instruction |= inst.operands[3].reg << 12;
}
d6572 1
a6572 8
static void
do_t_mlal (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 8;
  inst.instruction |= inst.operands[2].reg << 16;
  inst.instruction |= inst.operands[3].reg;
}
d6574 1
a6574 4
static void
do_t_mov_cmp (void)
{
  if (unified_syntax)
d6576 4
a6579 29
      int r0off = (inst.instruction == T_MNEM_mov
		   || inst.instruction == T_MNEM_movs) ? 8 : 16;
      if (!inst.operands[1].isreg)
	{
	  /* For an immediate, we always generate a 32-bit opcode;
	     section relaxation will shrink it later if possible.  */
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
	  inst.instruction |= inst.operands[0].reg << r0off;
	  inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
	}
      else if (inst.size_req == 4
	       || inst.operands[1].shifted
	       || (inst.instruction == T_MNEM_movs
		   && (inst.operands[0].reg > 7 || inst.operands[1].reg > 7)))
	{
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction |= inst.operands[0].reg << r0off;
	  encode_thumb32_shifted_operand (1);
	}
      else
	switch (inst.instruction)
	  {
	  case T_MNEM_mov:
	    inst.instruction = T_OPCODE_MOV_HR;
	    inst.instruction |= (inst.operands[0].reg & 0x8) << 4;
	    inst.instruction |= (inst.operands[0].reg & 0x7);
	    inst.instruction |= inst.operands[1].reg << 3;
	    break;
d6581 3
a6583 24
	  case T_MNEM_movs:
	    /* We know we have low registers at this point.
	       Generate ADD Rd, Rs, #0.  */
	    inst.instruction = T_OPCODE_ADD_I3;
	    inst.instruction |= inst.operands[0].reg;
	    inst.instruction |= inst.operands[1].reg << 3;
	    break;

	  case T_MNEM_cmp:
	    if (inst.operands[0].reg <= 7 && inst.operands[1].reg <= 7)
	      {
		inst.instruction = T_OPCODE_CMP_LR;
		inst.instruction |= inst.operands[0].reg;
		inst.instruction |= inst.operands[1].reg << 3;
	      }
	    else
	      {
		inst.instruction = T_OPCODE_CMP_HR;
		inst.instruction |= (inst.operands[0].reg & 0x8) << 4;
		inst.instruction |= (inst.operands[0].reg & 0x7);
		inst.instruction |= inst.operands[1].reg << 3;
	      }
	    break;
	  }
d6587 1
a6587 2
  inst.instruction = THUMB_OP16 (inst.instruction);
  if (inst.operands[1].isreg)
d6589 15
a6603 1
      if (inst.operands[0].reg < 8 && inst.operands[1].reg < 8)
d6605 12
a6616 4
	  /* A move of two lowregs is encoded as ADD Rd, Rs, #0
	     since a MOV instruction produces unpredictable results.  */
	  if (inst.instruction == T_OPCODE_MOV_I8)
	    inst.instruction = T_OPCODE_ADD_I3;
d6618 15
a6632 1
	    inst.instruction = T_OPCODE_CMP_LR;
d6634 3
a6636 2
	  inst.instruction |= inst.operands[0].reg;
	  inst.instruction |= inst.operands[1].reg << 3;
d6640 30
a6669 5
	  if (inst.instruction == T_OPCODE_MOV_I8)
	    inst.instruction = T_OPCODE_MOV_HR;
	  else
	    inst.instruction = T_OPCODE_CMP_HR;
	  do_t_cpy ();
d6672 1
a6672 1
  else
d6674 11
a6684 6
      constraint (inst.operands[0].reg > 7,
		  _("only lo regs allowed with immediate"));
      inst.instruction |= inst.operands[0].reg << 8;
      inst.reloc.type = BFD_RELOC_ARM_THUMB_IMM;
    }
}
d6686 2
a6687 9
static void
do_t_mov16 (void)
{
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= (inst.operands[1].imm & 0xf000) << 4;
  inst.instruction |= (inst.operands[1].imm & 0x0800) << 15;
  inst.instruction |= (inst.operands[1].imm & 0x0700) << 4;
  inst.instruction |= (inst.operands[1].imm & 0x00ff);
}
d6689 2
a6690 8
static void
do_t_mvn_tst (void)
{
  if (unified_syntax)
    {
      int r0off = (inst.instruction == T_MNEM_mvn
		   || inst.instruction == T_MNEM_mvns) ? 8 : 16;
      if (!inst.operands[1].isreg)
d6692 2
a6693 7
	  /* For an immediate, we always generate a 32-bit opcode;
	     section relaxation will shrink it later if possible.  */
	  if (inst.instruction < 0xffff)
	    inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
	  inst.instruction |= inst.operands[0].reg << r0off;
	  inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
d6695 2
a6696 1
      else
d6698 3
a6700 7
	  /* See if we can do this with a 16-bit instruction.  */
	  if (inst.instruction < 0xffff
	      && THUMB_SETS_FLAGS (inst.instruction)
	      && !inst.operands[1].shifted
	      && inst.operands[0].reg <= 7
	      && inst.operands[1].reg <= 7
	      && inst.size_req != 4)
d6702 6
a6707 3
	      inst.instruction = THUMB_OP16 (inst.instruction);
	      inst.instruction |= inst.operands[0].reg;
	      inst.instruction |= inst.operands[1].reg << 3;
d6709 4
a6712 1
	  else
d6714 6
a6719 7
	      constraint (inst.operands[1].shifted
			  && inst.operands[1].immisreg,
			  _("shift must be constant"));
	      if (inst.instruction < 0xffff)
		inst.instruction = THUMB_OP32 (inst.instruction);
	      inst.instruction |= inst.operands[0].reg << r0off;
	      encode_thumb32_shifted_operand (1);
d6722 15
d6740 2
a6741 6
      constraint (inst.instruction > 0xffff
		  || inst.instruction == T_MNEM_mvns, BAD_THUMB32);
      constraint (!inst.operands[1].isreg || inst.operands[1].shifted,
		  _("unshifted register required"));
      constraint (inst.operands[0].reg > 7 || inst.operands[1].reg > 7,
		  BAD_HIREG);
d6743 9
a6751 3
      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= inst.operands[0].reg;
      inst.instruction |= inst.operands[1].reg << 3;
a6752 1
}
d6754 2
a6755 9
static void
do_t_mrs (void)
{
  /* mrs only accepts CPSR/SPSR/CPSR_all/SPSR_all.  */
  constraint ((inst.operands[1].imm & (PSR_c|PSR_x|PSR_s|PSR_f))
	      != (PSR_c|PSR_f),
	      _("'CPSR' or 'SPSR' expected"));
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= (inst.operands[1].imm & SPSR_BIT) >> 2;
d6759 1
a6759 1
do_t_msr (void)
d6761 1
a6761 6
  constraint (!inst.operands[1].isreg,
	      _("Thumb encoding does not support an immediate here"));
  inst.instruction |= (inst.operands[0].imm & SPSR_BIT) >> 2;
  inst.instruction |= (inst.operands[0].imm & ~SPSR_BIT) >> 8;
  inst.instruction |= inst.operands[1].reg << 16;
}
d6763 1
a6763 5
static void
do_t_mul (void)
{
  if (!inst.operands[2].present)
    inst.operands[2].reg = inst.operands[0].reg;
d6765 1
a6765 2
  /* There is no 32-bit MULS and no 16-bit MUL. */
  if (unified_syntax && inst.instruction == T_MNEM_mul)
d6767 3
a6769 4
      inst.instruction = THUMB_OP32 (inst.instruction);
      inst.instruction |= inst.operands[0].reg << 8;
      inst.instruction |= inst.operands[1].reg << 16;
      inst.instruction |= inst.operands[2].reg << 0;
d6771 2
a6772 1
  else
d6774 2
a6775 14
      constraint (!unified_syntax
		  && inst.instruction == T_MNEM_muls, BAD_THUMB32);
      constraint (inst.operands[0].reg > 7 || inst.operands[1].reg > 7,
		  BAD_HIREG);

      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= inst.operands[0].reg;

      if (inst.operands[0].reg == inst.operands[1].reg)
	inst.instruction |= inst.operands[2].reg << 3;
      else if (inst.operands[0].reg == inst.operands[2].reg)
	inst.instruction |= inst.operands[1].reg << 3;
      else
	constraint (1, _("dest must overlap one source register"));
a6776 1
}
d6778 3
a6780 7
static void
do_t_mull (void)
{
  inst.instruction |= inst.operands[0].reg << 12;
  inst.instruction |= inst.operands[1].reg << 8;
  inst.instruction |= inst.operands[2].reg << 16;
  inst.instruction |= inst.operands[3].reg;
d6782 1
a6782 3
  if (inst.operands[0].reg == inst.operands[1].reg)
    as_tsktsk (_("rdhi and rdlo must be different"));
}
d6784 1
a6784 23
static void
do_t_nop (void)
{
  if (unified_syntax)
    {
      if (inst.size_req == 4 || inst.operands[0].imm > 15)
	{
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction |= inst.operands[0].imm;
	}
      else
	{
	  inst.instruction = THUMB_OP16 (inst.instruction);
	  inst.instruction |= inst.operands[0].imm << 4;
	}
    }
  else
    {
      constraint (inst.operands[0].present,
		  _("Thumb does not support NOP with hints"));
      inst.instruction = 0x46c0;
    }
}
d6786 2
a6787 25
static void
do_t_neg (void)
{
  if (unified_syntax)
    {
      if (inst.operands[0].reg > 7 || inst.operands[1].reg > 7
	  || !THUMB_SETS_FLAGS (inst.instruction)
	  || inst.size_req == 4)
	{
	  inst.instruction = THUMB_OP32 (inst.instruction);
	  inst.instruction |= inst.operands[0].reg << 8;
	  inst.instruction |= inst.operands[1].reg << 16;
	}
      else
	{
	  inst.instruction = THUMB_OP16 (inst.instruction);
	  inst.instruction |= inst.operands[0].reg;
	  inst.instruction |= inst.operands[1].reg << 3;
	}
    }
  else
    {
      constraint (inst.operands[0].reg > 7 || inst.operands[1].reg > 7,
		  BAD_HIREG);
      constraint (THUMB_SETS_FLAGS (inst.instruction), BAD_THUMB32);
d6789 6
a6794 5
      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= inst.operands[0].reg;
      inst.instruction |= inst.operands[1].reg << 3;
    }
}
d6796 1
a6796 15
static void
do_t_pkhbt (void)
{
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
  if (inst.operands[3].present)
    {
      unsigned int val = inst.reloc.exp.X_add_number;
      constraint (inst.reloc.exp.X_op != O_constant,
		  _("expression too complex"));
      inst.instruction |= (val & 0x1c) << 10;
      inst.instruction |= (val & 0x03) << 6;
    }
}
d6798 3
a6800 7
static void
do_t_pkhtb (void)
{
  if (!inst.operands[3].present)
    inst.instruction &= ~0x00000020;
  do_t_pkhbt ();
}
d6802 10
a6811 5
static void
do_t_pld (void)
{
  encode_thumb32_addr_mode (0, /*is_t=*/FALSE, /*is_d=*/FALSE);
}
d6813 3
a6815 7
static void
do_t_push_pop (void)
{
  constraint (inst.operands[0].writeback,
	      _("push/pop do not support {reglist}^"));
  constraint (inst.reloc.type != BFD_RELOC_UNUSED,
	      _("expression too complex"));
d6817 2
a6818 19
  if ((inst.operands[0].imm & ~0xff) == 0)
    inst.instruction = THUMB_OP16 (inst.instruction);
  else if ((inst.instruction == T_MNEM_push
	    && (inst.operands[0].imm & ~0xff) == 1 << REG_LR)
	   || (inst.instruction == T_MNEM_pop
	       && (inst.operands[0].imm & ~0xff) == 1 << REG_PC))
    {
      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= THUMB_PP_PC_LR;
      inst.operands[0].imm &= 0xff;
    }
  else if (unified_syntax)
    {
      if (inst.operands[1].imm & (1 << 13))
	as_warn (_("SP should not be in register list"));
      if (inst.instruction == T_MNEM_push)
	{
	  if (inst.operands[1].imm & (1 << 15))
	    as_warn (_("PC should not be in register list"));
d6822 2
a6823 3
	  if (inst.operands[1].imm & (1 << 14)
	      && inst.operands[1].imm & (1 << 15))
	    as_warn (_("LR and PC should not both be in register list"));
a6824 2

      inst.instruction = THUMB_OP32 (inst.instruction);
d6828 1
a6828 1
      inst.error = _("invalid register list to push/pop instruction");
d6832 1
a6832 1
  inst.instruction |= inst.operands[0].imm;
d6835 3
a6837 2
static void
do_t_rbit (void)
d6839 3
a6841 3
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 16;
}
d6843 2
a6844 5
static void
do_t_rev (void)
{
  if (inst.operands[0].reg <= 7 && inst.operands[1].reg <= 7
      && inst.size_req != 4)
d6846 13
a6858 14
      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= inst.operands[0].reg;
      inst.instruction |= inst.operands[1].reg << 3;
    }
  else if (unified_syntax)
    {
      inst.instruction = THUMB_OP32 (inst.instruction);
      inst.instruction |= inst.operands[0].reg << 8;
      inst.instruction |= inst.operands[1].reg << 16;
      inst.instruction |= inst.operands[1].reg;
    }
  else
    inst.error = BAD_HIREG;
}
d6860 2
a6861 4
static void
do_t_rsb (void)
{
  int Rd, Rs;
d6863 3
a6865 4
  Rd = inst.operands[0].reg;
  Rs = (inst.operands[1].present
	? inst.operands[1].reg    /* Rd, Rs, foo */
	: inst.operands[0].reg);  /* Rd, foo -> Rd, Rd, foo */
d6867 5
a6871 10
  inst.instruction |= Rd << 8;
  inst.instruction |= Rs << 16;
  if (!inst.operands[2].isreg)
    {
      inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
      inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
    }
  else
    encode_thumb32_shifted_operand (2);
}
d6873 11
a6883 6
static void
do_t_setend (void)
{
  if (inst.operands[0].imm)
    inst.instruction |= 0x8;
}
d6885 5
a6889 5
static void
do_t_shift (void)
{
  if (!inst.operands[1].present)
    inst.operands[1].reg = inst.operands[0].reg;
d6891 2
a6892 15
  if (unified_syntax)
    {
      if (inst.operands[0].reg > 7
	  || inst.operands[1].reg > 7
	  || !THUMB_SETS_FLAGS (inst.instruction)
	  || (!inst.operands[2].isreg && inst.instruction == T_MNEM_rors)
	  || (inst.operands[2].isreg && inst.operands[1].reg != inst.operands[0].reg)
	  || inst.size_req == 4)
	{
	  if (inst.operands[2].isreg)
	    {
	      inst.instruction = THUMB_OP32 (inst.instruction);
	      inst.instruction |= inst.operands[0].reg << 8;
	      inst.instruction |= inst.operands[1].reg << 16;
	      inst.instruction |= inst.operands[2].reg;
d6894 6
a6899 1
	  else
d6901 2
a6902 20
	      inst.operands[1].shifted = 1;
	      switch (inst.instruction)
		{
		case T_MNEM_asr:
		case T_MNEM_asrs: inst.operands[1].shift_kind = SHIFT_ASR; break;
		case T_MNEM_lsl:
		case T_MNEM_lsls: inst.operands[1].shift_kind = SHIFT_LSL; break;
		case T_MNEM_lsr:
		case T_MNEM_lsrs: inst.operands[1].shift_kind = SHIFT_LSR; break;
		case T_MNEM_ror:
		case T_MNEM_rors: inst.operands[1].shift_kind = SHIFT_ROR; break;
		default: abort ();
		}
	      
	      inst.instruction = THUMB_OP32 (THUMB_SETS_FLAGS (inst.instruction)
					     ? T_MNEM_movs : T_MNEM_mov);
	      inst.instruction |= inst.operands[0].reg << 8;
	      encode_thumb32_shifted_operand (1);
	      /* Prevent the incorrect generation of an ARM_IMMEDIATE fixup.  */
	      inst.reloc.type = BFD_RELOC_UNUSED;
d6907 6
a6912 1
	  if (inst.operands[2].isreg)
d6914 8
a6921 1
	      switch (inst.instruction)
d6923 7
a6929 5
		case T_MNEM_asrs: inst.instruction = T_OPCODE_ASR_R; break;
		case T_MNEM_lsls: inst.instruction = T_OPCODE_LSL_R; break;
		case T_MNEM_lsrs: inst.instruction = T_OPCODE_LSR_R; break;
		case T_MNEM_rors: inst.instruction = T_OPCODE_ROR_R; break;
		default: abort ();
d6931 2
a6932 3
	  
	      inst.instruction |= inst.operands[0].reg;
	      inst.instruction |= inst.operands[2].reg << 3;
d6936 1
a6936 1
	      switch (inst.instruction)
d6938 2
a6939 4
		case T_MNEM_asrs: inst.instruction = T_OPCODE_ASR_I; break;
		case T_MNEM_lsls: inst.instruction = T_OPCODE_LSL_I; break;
		case T_MNEM_lsrs: inst.instruction = T_OPCODE_LSR_I; break;
		default: abort ();
d6941 4
a6944 3
	      inst.reloc.type = BFD_RELOC_ARM_THUMB_SHIFT;
	      inst.instruction |= inst.operands[0].reg;
	      inst.instruction |= inst.operands[1].reg << 3;
a6946 6
    }
  else
    {
      constraint (inst.operands[0].reg > 7
		  || inst.operands[1].reg > 7, BAD_HIREG);
      constraint (THUMB_SETS_FLAGS (inst.instruction), BAD_THUMB32);
d6948 1
a6948 5
      if (inst.operands[2].isreg)  /* Rd, {Rs,} Rn */
	{
	  constraint (inst.operands[2].reg > 7, BAD_HIREG);
	  constraint (inst.operands[0].reg != inst.operands[1].reg,
		      _("source1 and dest must be same register"));
d6950 1
a6950 13
	  switch (inst.instruction)
	    {
	    case T_MNEM_asr: inst.instruction = T_OPCODE_ASR_R; break;
	    case T_MNEM_lsl: inst.instruction = T_OPCODE_LSL_R; break;
	    case T_MNEM_lsr: inst.instruction = T_OPCODE_LSR_R; break;
	    case T_MNEM_ror: inst.instruction = T_OPCODE_ROR_R; break;
	    default: abort ();
	    }
	  
	  inst.instruction |= inst.operands[0].reg;
	  inst.instruction |= inst.operands[2].reg << 3;
	}
      else
d6952 2
a6953 11
	  switch (inst.instruction)
	    {
	    case T_MNEM_asr: inst.instruction = T_OPCODE_ASR_I; break;
	    case T_MNEM_lsl: inst.instruction = T_OPCODE_LSL_I; break;
	    case T_MNEM_lsr: inst.instruction = T_OPCODE_LSR_I; break;
	    case T_MNEM_ror: inst.error = _("ror #imm not supported"); return;
	    default: abort ();
	    }
	  inst.reloc.type = BFD_RELOC_ARM_THUMB_SHIFT;
	  inst.instruction |= inst.operands[0].reg;
	  inst.instruction |= inst.operands[1].reg << 3;
d6956 4
d6963 1
a6963 1
do_t_simd (void)
d6965 15
a6979 4
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
}
d6981 5
a6985 11
static void
do_t_smi (void)
{
  unsigned int value = inst.reloc.exp.X_add_number;
  constraint (inst.reloc.exp.X_op != O_constant,
	      _("expression too complex"));
  inst.reloc.type = BFD_RELOC_UNUSED;
  inst.instruction |= (value & 0xf000) >> 12;
  inst.instruction |= (value & 0x0ff0);
  inst.instruction |= (value & 0x000f) << 16;
}
d6987 7
a6993 6
static void
do_t_ssat (void)
{
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].imm - 1;
  inst.instruction |= inst.operands[2].reg << 16;
d6995 1
a6995 1
  if (inst.operands[3].present)
d6997 3
a6999 2
      constraint (inst.reloc.exp.X_op != O_constant,
		  _("expression too complex"));
d7001 4
a7004 1
      if (inst.reloc.exp.X_add_number != 0)
d7006 17
a7022 4
	  if (inst.operands[3].shift_kind == SHIFT_ASR)
	    inst.instruction |= 0x00200000;  /* sh bit */
	  inst.instruction |= (inst.reloc.exp.X_add_number & 0x1c) << 10;
	  inst.instruction |= (inst.reloc.exp.X_add_number & 0x03) << 6;
a7023 1
      inst.reloc.type = BFD_RELOC_UNUSED;
d7025 3
d7031 1
a7031 1
do_t_ssat16 (void)
d7033 5
a7037 4
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].imm - 1;
  inst.instruction |= inst.operands[2].reg << 16;
}
d7039 2
a7040 8
static void
do_t_strex (void)
{
  constraint (!inst.operands[2].isreg || !inst.operands[2].preind
	      || inst.operands[2].postind || inst.operands[2].writeback
	      || inst.operands[2].immisreg || inst.operands[2].shifted
	      || inst.operands[2].negative,
	      _("instruction does not accept this addressing mode"));
d7042 3
a7044 4
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 12;
  inst.instruction |= inst.operands[2].reg << 16;
  inst.reloc.type = BFD_RELOC_ARM_T32_OFFSET_U8;
d7048 1
a7048 1
do_t_strexd (void)
d7050 1
a7050 2
  if (!inst.operands[2].present)
    inst.operands[2].reg = inst.operands[1].reg + 1;
d7052 3
a7054 5
  constraint (inst.operands[0].reg == inst.operands[1].reg
	      || inst.operands[0].reg == inst.operands[2].reg
	      || inst.operands[0].reg == inst.operands[3].reg
	      || inst.operands[1].reg == inst.operands[2].reg,
	      BAD_OVERLAP);
d7056 6
a7061 4
  inst.instruction |= inst.operands[0].reg;
  inst.instruction |= inst.operands[1].reg << 12;
  inst.instruction |= inst.operands[2].reg << 8;
  inst.instruction |= inst.operands[3].reg << 16;
d7065 1
a7065 1
do_t_sxtah (void)
d7067 26
a7092 5
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].reg << 16;
  inst.instruction |= inst.operands[2].reg;
  inst.instruction |= inst.operands[3].imm << 4;
}
d7094 2
a7095 6
static void
do_t_sxth (void)
{
  if (inst.instruction <= 0xffff && inst.size_req != 4
      && inst.operands[0].reg <= 7 && inst.operands[1].reg <= 7
      && (!inst.operands[2].present || inst.operands[2].imm == 0))
d7097 2
a7098 3
      inst.instruction = THUMB_OP16 (inst.instruction);
      inst.instruction |= inst.operands[0].reg;
      inst.instruction |= inst.operands[1].reg << 3;
d7100 7
a7106 1
  else if (unified_syntax)
d7108 2
a7109 5
      if (inst.instruction <= 0xffff)
	inst.instruction = THUMB_OP32 (inst.instruction);
      inst.instruction |= inst.operands[0].reg << 8;
      inst.instruction |= inst.operands[1].reg;
      inst.instruction |= inst.operands[2].imm << 4;
d7111 4
a7114 1
  else
d7116 2
a7117 3
      constraint (inst.operands[2].present && inst.operands[2].imm != 0,
		  _("Thumb encoding does not support rotation"));
      constraint (1, BAD_HIREG);
d7119 2
d7124 1
a7124 1
do_t_swi (void)
d7126 38
a7163 1
  inst.reloc.type = BFD_RELOC_ARM_SWI;
d7167 1
a7167 1
do_t_usat (void)
d7169 42
a7210 3
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].imm;
  inst.instruction |= inst.operands[2].reg << 16;
d7212 1
a7212 1
  if (inst.operands[3].present)
d7214 1
a7214 3
      constraint (inst.reloc.exp.X_op != O_constant,
		  _("expression too complex"));
      if (inst.reloc.exp.X_add_number != 0)
d7216 3
a7218 5
	  if (inst.operands[3].shift_kind == SHIFT_ASR)
	    inst.instruction |= 0x00200000;  /* sh bit */

	  inst.instruction |= (inst.reloc.exp.X_add_number & 0x1c) << 10;
	  inst.instruction |= (inst.reloc.exp.X_add_number & 0x03) << 6;
a7219 1
      inst.reloc.type = BFD_RELOC_UNUSED;
d7221 2
d7226 1
a7226 1
do_t_usat16 (void)
d7228 2
a7229 6
  inst.instruction |= inst.operands[0].reg << 8;
  inst.instruction |= inst.operands[1].imm;
  inst.instruction |= inst.operands[2].reg << 16;
}

/* Overall per-instruction processing.	*/
d7231 1
a7231 6
/* We need to be able to fix up arbitrary expressions in some statements.
   This is so that we can handle symbols that are an arbitrary distance from
   the pc.  The most common cases are of the form ((+/-sym -/+ . - 8) & mask),
   which returns part of an address in a form which will be valid for
   a data instruction.	We do this by pushing the expression into a symbol
   in the expr_section, and creating a fix for that.  */
d7233 6
a7238 9
static void
fix_new_arm (fragS *	   frag,
	     int	   where,
	     short int	   size,
	     expressionS * exp,
	     int	   pc_rel,
	     int	   reloc)
{
  fixS *	   new_fix;
d7240 2
a7241 1
  switch (exp->X_op)
d7243 4
a7246 6
    case O_constant:
    case O_symbol:
    case O_add:
    case O_subtract:
      new_fix = fix_new_exp (frag, where, size, exp, pc_rel, reloc);
      break;
d7248 6
a7253 4
    default:
      new_fix = fix_new (frag, where, size, make_expr_symbol (exp), 0,
			 pc_rel, reloc);
      break;
d7256 1
a7256 3
  /* Mark whether the fix is to a THUMB instruction, or an ARM
     instruction.  */
  new_fix->tc_fix_data = thumb_mode;
d7260 1
a7260 1
output_inst (const char * str)
d7262 4
a7265 1
  char * to = NULL;
d7267 1
a7267 1
  if (inst.error)
d7269 2
a7270 1
      as_bad ("%s -- `%s'", inst.error, str);
a7272 2
  if (inst.size == 0)
    return;
d7274 7
a7280 1
  to = frag_more (inst.size);
d7282 2
a7283 1
  if (thumb_mode && (inst.size > THUMB_SIZE))
d7285 3
a7287 3
      assert (inst.size == (2 * THUMB_SIZE));
      md_number_to_chars (to, inst.instruction >> 16, THUMB_SIZE);
      md_number_to_chars (to + THUMB_SIZE, inst.instruction, THUMB_SIZE);
d7289 3
a7291 1
  else if (inst.size > INSN_SIZE)
d7293 3
a7295 3
      assert (inst.size == (2 * INSN_SIZE));
      md_number_to_chars (to, inst.instruction, INSN_SIZE);
      md_number_to_chars (to + INSN_SIZE, inst.instruction, INSN_SIZE);
a7296 107
  else
    md_number_to_chars (to, inst.instruction, inst.size);

  if (inst.reloc.type != BFD_RELOC_UNUSED)
    fix_new_arm (frag_now, to - frag_now->fr_literal,
		 inst.size, & inst.reloc.exp, inst.reloc.pc_rel,
		 inst.reloc.type);

#ifdef OBJ_ELF
  dwarf2_emit_insn (inst.size);
#endif
}

/* Tag values used in struct asm_opcode's tag field.  */
enum opcode_tag
{
  OT_unconditional,	/* Instruction cannot be conditionalized.
			   The ARM condition field is still 0xE.  */
  OT_unconditionalF,	/* Instruction cannot be conditionalized
			   and carries 0xF in its ARM condition field.  */
  OT_csuffix,		/* Instruction takes a conditional suffix.  */
  OT_cinfix3,		/* Instruction takes a conditional infix,
			   beginning at character index 3.  (In
			   unified mode, it becomes a suffix.)  */
  OT_csuf_or_in3,	/* Instruction takes either a conditional
			   suffix or an infix at character index 3.
			   (In unified mode, a suffix only.  */
  OT_odd_infix_unc,	/* This is the unconditional variant of an
			   instruction that takes a conditional infix
			   at an unusual position.  In unified mode,
			   this variant will accept a suffix.  */
  OT_odd_infix_0	/* Values greater than or equal to OT_odd_infix_0
			   are the conditional variants of instructions that
			   take conditional infixes in unusual positions.
			   The infix appears at character index
			   (tag - OT_odd_infix_0).  These are not accepted
			   in unified mode.  */
};

/* Subroutine of md_assemble, responsible for looking up the primary
   opcode from the mnemonic the user wrote.  STR points to the
   beginning of the mnemonic.

   This is not simply a hash table lookup, because of conditional
   variants.  Most instructions have conditional variants, which are
   expressed with a _conditional affix_ to the mnemonic.  If we were
   to encode each conditional variant as a literal string in the opcode
   table, it would have approximately 20,000 entries.

   Most mnemonics take this affix as a suffix, and in unified syntax,
   'most' is upgraded to 'all'.  However, in the divided syntax, some
   instructions take the affix as an infix, notably the s-variants of
   the arithmetic instructions.  Of those instructions, all but six
   have the infix appear after the third character of the mnemonic.

   Accordingly, the algorithm for looking up primary opcodes given
   an identifier is:

   1. Look up the identifier in the opcode table.
      If we find a match, go to step U.

   2. Look up the last two characters of the identifier in the
      conditions table.  If we find a match, look up the first N-2
      characters of the identifier in the opcode table.  If we
      find a match, go to step CE.

   3. Look up the fourth and fifth characters of the identifier in
      the conditions table.  If we find a match, extract those
      characters from the identifier, and look up the remaining
      characters in the opcode table.  If we find a match, go
      to step CM.

   4. Fail.

   U. Examine the tag field of the opcode structure, in case this is
      one of the six instructions with its conditional infix in an
      unusual place.  If it is, the tag tells us where to find the
      infix; look it up in the conditions table and set inst.cond
      accordingly.  Otherwise, this is an unconditional instruction.
      Again set inst.cond accordingly.  Return the opcode structure.

  CE. Examine the tag field to make sure this is an instruction that
      should receive a conditional suffix.  If it is not, fail.
      Otherwise, set inst.cond from the suffix we already looked up,
      and return the opcode structure.

  CM. Examine the tag field to make sure this is an instruction that
      should receive a conditional infix after the third character.
      If it is not, fail.  Otherwise, undo the edits to the current
      line of input and proceed as for case CE.  */

static const struct asm_opcode *
opcode_lookup (char **str)
{
  char *end, *base;
  char *affix;
  const struct asm_opcode *opcode;
  const struct asm_cond *cond;

  /* Scan up to the end of the mnemonic, which must end in white space,
     '.' (in unified mode only), or end of string.  */
  for (base = end = *str; *end != '\0'; end++)
    if (*end == ' ' || (unified_syntax && *end == '.'))
      break;

  if (end == base)
    return 0;
d7298 2
a7299 2
  /* Handle a possible width suffix.  */
  if (end[0] == '.')
d7301 3
a7303 8
      if (end[1] == 'w' && (end[2] == ' ' || end[2] == '\0'))
	inst.size_req = 4;
      else if (end[1] == 'n' && (end[2] == ' ' || end[2] == '\0'))
	inst.size_req = 2;
      else
	return 0;

      *str = end + 2;
a7304 2
  else
    *str = end;
d7306 1
a7306 3
  /* Look for unaffixed or special-case affixed mnemonic.  */
  opcode = hash_find_n (arm_ops_hsh, base, end - base);
  if (opcode)
d7308 1
a7308 2
      /* step U */
      if (opcode->tag < OT_odd_infix_0)
d7310 3
a7312 2
	  inst.cond = COND_ALWAYS;
	  return opcode;
d7314 10
d7325 1
a7325 5
      if (unified_syntax)
	as_warn (_("conditional infixes are deprecated in unified syntax"));
      affix = base + (opcode->tag - OT_odd_infix_0);
      cond = hash_find_n (arm_cond_hsh, affix, 2);
      assert (cond);
d7327 5
a7331 2
      inst.cond = cond->value;
      return opcode;
d7334 2
a7335 4
  /* Cannot have a conditional suffix on a mnemonic of less than two
     characters.  */
  if (end - base < 3)
    return 0;
d7337 4
a7340 26
  /* Look for suffixed mnemonic.  */
  affix = end - 2;
  cond = hash_find_n (arm_cond_hsh, affix, 2);
  opcode = hash_find_n (arm_ops_hsh, base, affix - base);
  if (opcode && cond)
    {
      /* step CE */
      switch (opcode->tag)
	{
	case OT_cinfix3:
	case OT_odd_infix_unc:
	  if (!unified_syntax)
	    return 0;
	  /* else fall through */

	case OT_csuffix:
	case OT_csuf_or_in3:
	  inst.cond = cond->value;
	  return opcode;

	case OT_unconditional:
	case OT_unconditionalF:
	  /* delayed diagnostic */
	  inst.error = BAD_COND;
	  inst.cond = COND_ALWAYS;
	  return opcode;
d7342 5
a7346 3
	default:
	  return 0;
	}
d7349 6
a7354 25
  /* Cannot have a usual-position infix on a mnemonic of less than
     six characters (five would be a suffix).  */
  if (end - base < 6)
    return 0;

  /* Look for infixed mnemonic in the usual position.  */
  affix = base + 3;
  cond = hash_find_n (arm_cond_hsh, affix, 2);
  if (cond)
    {
      char save[2];
      memcpy (save, affix, 2);
      memmove (affix, affix + 2, (end - affix) - 2);
      opcode = hash_find_n (arm_ops_hsh, base, (end - base) - 2);
      memmove (affix + 2, affix, (end - affix) - 2);
      memcpy (affix, save, 2);
    }
  if (opcode && (opcode->tag == OT_cinfix3 || opcode->tag == OT_csuf_or_in3))
    {
      /* step CM */
      if (unified_syntax)
	as_warn (_("conditional infixes are deprecated in unified syntax"));

      inst.cond = cond->value;
      return opcode;
d7357 1
a7357 1
  return 0;
d7360 2
a7361 2
void
md_assemble (char *str)
d7363 3
a7365 2
  char *p = str;
  const struct asm_opcode * opcode;
d7367 1
a7367 2
  /* Align the previous label if needed.  */
  if (last_label_seen != NULL)
d7369 3
a7371 3
      symbol_set_frag (last_label_seen, frag_now);
      S_SET_VALUE (last_label_seen, (valueT) frag_now_fix ());
      S_SET_SEGMENT (last_label_seen, now_seg);
d7374 8
a7381 2
  memset (&inst, '\0', sizeof (inst));
  inst.reloc.type = BFD_RELOC_UNUSED;
d7383 1
a7383 2
  opcode = opcode_lookup (&p);
  if (!opcode)
d7385 3
a7387 4
      /* It wasn't an instruction, but it might be a register alias of
	 the form alias .req reg.  */
      if (!create_register_alias (str, p))
	as_bad (_("bad instruction `%s'"), str);
d7389 5
d7397 18
a7414 1
  if (thumb_mode)
d7416 10
a7425 2
      /* Check that this instruction is supported for this CPU.  */
      if (thumb_mode == 1 && (opcode->tvariant & cpu_variant) == 0)
d7427 2
a7428 1
	  as_bad (_("selected processor does not support `%s'"), str);
d7431 10
a7440 2
      if (inst.cond != COND_ALWAYS && !unified_syntax
	  && opcode->tencode != do_t_branch)
d7442 1
a7442 1
	  as_bad (_("Thumb does not support conditional execution"));
d7446 2
a7447 7
      mapping_state (MAP_THUMB);
      inst.instruction = opcode->tvalue;

      if (!parse_operands (p, opcode->operands))
	opcode->tencode ();

      if (!inst.error)
d7449 3
a7451 3
	  assert (inst.instruction < 0xe800 || inst.instruction > 0xffff);
	  inst.size = (inst.instruction > 0xffff ? 4 : 2);
	  if (inst.size_req && inst.size_req != inst.size)
d7453 2
a7454 1
	      as_bad (_("cannot honor width suffix -- `%s'"), str);
d7458 4
a7461 5
    }
  else
    {
      /* Check that this instruction is supported for this CPU.  */
      if ((opcode->avariant & cpu_variant) == 0)
d7463 4
a7466 2
	  as_bad (_("selected processor does not support `%s'"), str);
	  return;
d7468 1
a7468 1
      if (inst.size_req)
d7470 13
a7482 2
	  as_bad (_("width suffixes are invalid in ARM mode -- `%s'"), str);
	  return;
d7485 8
a7492 9
      mapping_state (MAP_ARM);
      inst.instruction = opcode->avalue;
      if (opcode->tag == OT_unconditionalF)
	inst.instruction |= 0xF << 28;
      else
	inst.instruction |= inst.cond << 28;
      inst.size = INSN_SIZE;
      if (!parse_operands (p, opcode->operands))
	opcode->aencode ();
a7493 2
  output_inst (str);
}
d7495 1
a7495 6
/* Various frobbings of labels and their addresses.  */

void
arm_start_line_hook (void)
{
  last_label_seen = NULL;
d7498 2
a7499 2
void
arm_frob_label (symbolS * sym)
d7501 1
a7501 1
  last_label_seen = sym;
d7503 6
a7508 1
  ARM_SET_THUMB (sym, thumb_mode);
d7510 7
a7516 3
#if defined OBJ_COFF || defined OBJ_ELF
  ARM_SET_INTERWORK (sym, support_interwork);
#endif
d7518 7
a7524 6
  /* Note - do not allow local symbols (.Lxxx) to be labeled
     as Thumb functions.  This is because these labels, whilst
     they exist inside Thumb code, are not the entry points for
     possible ARM->Thumb calls.	 Also, these labels can be used
     as part of a computed goto or switch statement.  eg gcc
     can generate code that looks like this:
d7526 2
a7527 4
		ldr  r2, [pc, .Laaa]
		lsl  r3, r3, #2
		ldr  r2, [r3, r2]
		mov  pc, r2
d7529 4
a7532 4
       .Lbbb:  .word .Lxxx
       .Lccc:  .word .Lyyy
       ..etc...
       .Laaa:	.word Lbbb
d7534 6
a7539 4
     The first instruction loads the address of the jump table.
     The second instruction converts a table index into a byte offset.
     The third instruction gets the jump address out of the table.
     The fourth instruction performs the jump.
d7541 2
a7542 10
     If the address stored at .Laaa is that of a symbol which has the
     Thumb_Func bit set, then the linker will arrange for this address
     to have the bottom bit set, which in turn would mean that the
     address computation performed by the third instruction would end
     up with the bottom bit set.  Since the ARM is capable of unaligned
     word loads, the instruction would then load the incorrect address
     out of the jump table, and chaos would ensue.  */
  if (label_is_thumb_function_name
      && (S_GET_NAME (sym)[0] != '.' || S_GET_NAME (sym)[1] != 'L')
      && (bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)
d7544 12
a7555 4
      /* When the address of a Thumb function is taken the bottom
	 bit of that address should be set.  This will allow
	 interworking between Arm and Thumb functions to work
	 correctly.  */
d7557 6
a7562 1
      THUMB_SET_FUNC (sym, 1);
d7564 6
a7569 1
      label_is_thumb_function_name = FALSE;
d7571 2
d7575 2
a7576 2
int
arm_data_in_code (void)
d7578 11
a7588 1
  if (thumb_mode && ! strncmp (input_line_pointer + 1, "data:", 5))
d7590 3
a7592 4
      *input_line_pointer = '/';
      input_line_pointer += 5;
      *input_line_pointer = 0;
      return 1;
d7595 1
a7595 1
  return 0;
d7598 2
a7599 2
char *
arm_canonicalize_symbol_name (char * name)
d7601 4
a7604 1
  int len;
d7606 7
a7612 3
  if (thumb_mode && (len = strlen (name)) > 5
      && streq (name + len - 5, "/data"))
    *(name + len - 5) = 0;
d7614 1
a7614 1
  return name;
a7615 27

/* Table of all register names defined by default.  The user can
   define additional names with .req.  Note that all register names
   should appear in both upper and lowercase variants.	Some registers
   also have mixed-case names.	*/

#define REGDEF(s,n,t) { #s, n, REG_TYPE_##t, TRUE }
#define REGNUM(p,n,t) REGDEF(p##n, n, t)
#define REGSET(p,t) \
  REGNUM(p, 0,t), REGNUM(p, 1,t), REGNUM(p, 2,t), REGNUM(p, 3,t), \
  REGNUM(p, 4,t), REGNUM(p, 5,t), REGNUM(p, 6,t), REGNUM(p, 7,t), \
  REGNUM(p, 8,t), REGNUM(p, 9,t), REGNUM(p,10,t), REGNUM(p,11,t), \
  REGNUM(p,12,t), REGNUM(p,13,t), REGNUM(p,14,t), REGNUM(p,15,t)

static const struct reg_entry reg_names[] =
{
  /* ARM integer registers.  */
  REGSET(r, RN), REGSET(R, RN),

  /* ATPCS synonyms.  */
  REGDEF(a1,0,RN), REGDEF(a2,1,RN), REGDEF(a3, 2,RN), REGDEF(a4, 3,RN),
  REGDEF(v1,4,RN), REGDEF(v2,5,RN), REGDEF(v3, 6,RN), REGDEF(v4, 7,RN),
  REGDEF(v5,8,RN), REGDEF(v6,9,RN), REGDEF(v7,10,RN), REGDEF(v8,11,RN),

  REGDEF(A1,0,RN), REGDEF(A2,1,RN), REGDEF(A3, 2,RN), REGDEF(A4, 3,RN),
  REGDEF(V1,4,RN), REGDEF(V2,5,RN), REGDEF(V3, 6,RN), REGDEF(V4, 7,RN),
  REGDEF(V5,8,RN), REGDEF(V6,9,RN), REGDEF(V7,10,RN), REGDEF(V8,11,RN),
d7617 10
a7626 3
  /* Well-known aliases.  */
  REGDEF(wr, 7,RN), REGDEF(sb, 9,RN), REGDEF(sl,10,RN), REGDEF(fp,11,RN),
  REGDEF(ip,12,RN), REGDEF(sp,13,RN), REGDEF(lr,14,RN), REGDEF(pc,15,RN),
d7628 3
a7630 2
  REGDEF(WR, 7,RN), REGDEF(SB, 9,RN), REGDEF(SL,10,RN), REGDEF(FP,11,RN),
  REGDEF(IP,12,RN), REGDEF(SP,13,RN), REGDEF(LR,14,RN), REGDEF(PC,15,RN),
d7632 3
a7634 2
  /* Coprocessor numbers.  */
  REGSET(p, CP), REGSET(P, CP),
d7636 4
a7639 65
  /* Coprocessor register numbers.  The "cr" variants are for backward
     compatibility.  */
  REGSET(c,  CN), REGSET(C, CN),
  REGSET(cr, CN), REGSET(CR, CN),

  /* FPA registers.  */
  REGNUM(f,0,FN), REGNUM(f,1,FN), REGNUM(f,2,FN), REGNUM(f,3,FN),
  REGNUM(f,4,FN), REGNUM(f,5,FN), REGNUM(f,6,FN), REGNUM(f,7, FN),

  REGNUM(F,0,FN), REGNUM(F,1,FN), REGNUM(F,2,FN), REGNUM(F,3,FN),
  REGNUM(F,4,FN), REGNUM(F,5,FN), REGNUM(F,6,FN), REGNUM(F,7, FN),

  /* VFP SP registers.	*/
  REGSET(s,VFS),
  REGNUM(s,16,VFS), REGNUM(s,17,VFS), REGNUM(s,18,VFS), REGNUM(s,19,VFS),
  REGNUM(s,20,VFS), REGNUM(s,21,VFS), REGNUM(s,22,VFS), REGNUM(s,23,VFS),
  REGNUM(s,24,VFS), REGNUM(s,25,VFS), REGNUM(s,26,VFS), REGNUM(s,27,VFS),
  REGNUM(s,28,VFS), REGNUM(s,29,VFS), REGNUM(s,30,VFS), REGNUM(s,31,VFS),

  REGSET(S,VFS),
  REGNUM(S,16,VFS), REGNUM(S,17,VFS), REGNUM(S,18,VFS), REGNUM(S,19,VFS),
  REGNUM(S,20,VFS), REGNUM(S,21,VFS), REGNUM(S,22,VFS), REGNUM(S,23,VFS),
  REGNUM(S,24,VFS), REGNUM(S,25,VFS), REGNUM(S,26,VFS), REGNUM(S,27,VFS),
  REGNUM(S,28,VFS), REGNUM(S,29,VFS), REGNUM(S,30,VFS), REGNUM(S,31,VFS),

  /* VFP DP Registers.	*/
  REGSET(d,VFD), REGSET(D,VFS),

  /* VFP control registers.  */
  REGDEF(fpsid,0,VFC), REGDEF(fpscr,1,VFC), REGDEF(fpexc,8,VFC),
  REGDEF(FPSID,0,VFC), REGDEF(FPSCR,1,VFC), REGDEF(FPEXC,8,VFC),

  /* Maverick DSP coprocessor registers.  */
  REGSET(mvf,MVF),  REGSET(mvd,MVD),  REGSET(mvfx,MVFX),  REGSET(mvdx,MVDX),
  REGSET(MVF,MVF),  REGSET(MVD,MVD),  REGSET(MVFX,MVFX),  REGSET(MVDX,MVDX),

  REGNUM(mvax,0,MVAX), REGNUM(mvax,1,MVAX),
  REGNUM(mvax,2,MVAX), REGNUM(mvax,3,MVAX),
  REGDEF(dspsc,0,DSPSC),

  REGNUM(MVAX,0,MVAX), REGNUM(MVAX,1,MVAX),
  REGNUM(MVAX,2,MVAX), REGNUM(MVAX,3,MVAX),
  REGDEF(DSPSC,0,DSPSC),

  /* iWMMXt data registers - p0, c0-15.	 */
  REGSET(wr,MMXWR), REGSET(wR,MMXWR), REGSET(WR, MMXWR),

  /* iWMMXt control registers - p1, c0-3.  */
  REGDEF(wcid,	0,MMXWC),  REGDEF(wCID,	 0,MMXWC),  REGDEF(WCID,  0,MMXWC),
  REGDEF(wcon,	1,MMXWC),  REGDEF(wCon,	 1,MMXWC),  REGDEF(WCON,  1,MMXWC),
  REGDEF(wcssf, 2,MMXWC),  REGDEF(wCSSF, 2,MMXWC),  REGDEF(WCSSF, 2,MMXWC),
  REGDEF(wcasf, 3,MMXWC),  REGDEF(wCASF, 3,MMXWC),  REGDEF(WCASF, 3,MMXWC),

  /* iWMMXt scalar (constant/offset) registers - p1, c8-11.  */
  REGDEF(wcgr0, 8,MMXWCG),  REGDEF(wCGR0, 8,MMXWCG),  REGDEF(WCGR0, 8,MMXWCG),
  REGDEF(wcgr1, 9,MMXWCG),  REGDEF(wCGR1, 9,MMXWCG),  REGDEF(WCGR1, 9,MMXWCG),
  REGDEF(wcgr2,10,MMXWCG),  REGDEF(wCGR2,10,MMXWCG),  REGDEF(WCGR2,10,MMXWCG),
  REGDEF(wcgr3,11,MMXWCG),  REGDEF(wCGR3,11,MMXWCG),  REGDEF(WCGR3,11,MMXWCG),

  /* XScale accumulator registers.  */
  REGNUM(acc,0,XSCALE), REGNUM(ACC,0,XSCALE),
};
#undef REGDEF
#undef REGNUM
#undef REGSET
d7641 3
a7643 3
/* Table of all PSR suffixes.  Bare "CPSR" and "SPSR" are handled
   within psr_required_here.  */
static const struct asm_psr psrs[] =
d7645 2
a7646 73
  /* Backward compatibility notation.  Note that "all" is no longer
     truly all possible PSR bits.  */
  {"all",  PSR_c | PSR_f},
  {"flg",  PSR_f},
  {"ctl",  PSR_c},

  /* Individual flags.	*/
  {"f",	   PSR_f},
  {"c",	   PSR_c},
  {"x",	   PSR_x},
  {"s",	   PSR_s},
  /* Combinations of flags.  */
  {"fs",   PSR_f | PSR_s},
  {"fx",   PSR_f | PSR_x},
  {"fc",   PSR_f | PSR_c},
  {"sf",   PSR_s | PSR_f},
  {"sx",   PSR_s | PSR_x},
  {"sc",   PSR_s | PSR_c},
  {"xf",   PSR_x | PSR_f},
  {"xs",   PSR_x | PSR_s},
  {"xc",   PSR_x | PSR_c},
  {"cf",   PSR_c | PSR_f},
  {"cs",   PSR_c | PSR_s},
  {"cx",   PSR_c | PSR_x},
  {"fsx",  PSR_f | PSR_s | PSR_x},
  {"fsc",  PSR_f | PSR_s | PSR_c},
  {"fxs",  PSR_f | PSR_x | PSR_s},
  {"fxc",  PSR_f | PSR_x | PSR_c},
  {"fcs",  PSR_f | PSR_c | PSR_s},
  {"fcx",  PSR_f | PSR_c | PSR_x},
  {"sfx",  PSR_s | PSR_f | PSR_x},
  {"sfc",  PSR_s | PSR_f | PSR_c},
  {"sxf",  PSR_s | PSR_x | PSR_f},
  {"sxc",  PSR_s | PSR_x | PSR_c},
  {"scf",  PSR_s | PSR_c | PSR_f},
  {"scx",  PSR_s | PSR_c | PSR_x},
  {"xfs",  PSR_x | PSR_f | PSR_s},
  {"xfc",  PSR_x | PSR_f | PSR_c},
  {"xsf",  PSR_x | PSR_s | PSR_f},
  {"xsc",  PSR_x | PSR_s | PSR_c},
  {"xcf",  PSR_x | PSR_c | PSR_f},
  {"xcs",  PSR_x | PSR_c | PSR_s},
  {"cfs",  PSR_c | PSR_f | PSR_s},
  {"cfx",  PSR_c | PSR_f | PSR_x},
  {"csf",  PSR_c | PSR_s | PSR_f},
  {"csx",  PSR_c | PSR_s | PSR_x},
  {"cxf",  PSR_c | PSR_x | PSR_f},
  {"cxs",  PSR_c | PSR_x | PSR_s},
  {"fsxc", PSR_f | PSR_s | PSR_x | PSR_c},
  {"fscx", PSR_f | PSR_s | PSR_c | PSR_x},
  {"fxsc", PSR_f | PSR_x | PSR_s | PSR_c},
  {"fxcs", PSR_f | PSR_x | PSR_c | PSR_s},
  {"fcsx", PSR_f | PSR_c | PSR_s | PSR_x},
  {"fcxs", PSR_f | PSR_c | PSR_x | PSR_s},
  {"sfxc", PSR_s | PSR_f | PSR_x | PSR_c},
  {"sfcx", PSR_s | PSR_f | PSR_c | PSR_x},
  {"sxfc", PSR_s | PSR_x | PSR_f | PSR_c},
  {"sxcf", PSR_s | PSR_x | PSR_c | PSR_f},
  {"scfx", PSR_s | PSR_c | PSR_f | PSR_x},
  {"scxf", PSR_s | PSR_c | PSR_x | PSR_f},
  {"xfsc", PSR_x | PSR_f | PSR_s | PSR_c},
  {"xfcs", PSR_x | PSR_f | PSR_c | PSR_s},
  {"xsfc", PSR_x | PSR_s | PSR_f | PSR_c},
  {"xscf", PSR_x | PSR_s | PSR_c | PSR_f},
  {"xcfs", PSR_x | PSR_c | PSR_f | PSR_s},
  {"xcsf", PSR_x | PSR_c | PSR_s | PSR_f},
  {"cfsx", PSR_c | PSR_f | PSR_s | PSR_x},
  {"cfxs", PSR_c | PSR_f | PSR_x | PSR_s},
  {"csfx", PSR_c | PSR_s | PSR_f | PSR_x},
  {"csxf", PSR_c | PSR_s | PSR_x | PSR_f},
  {"cxfs", PSR_c | PSR_x | PSR_f | PSR_s},
  {"cxsf", PSR_c | PSR_x | PSR_s | PSR_f},
};
d7648 5
a7652 10
/* Table of all shift-in-operand names.	 */
static const struct asm_shift_name shift_names [] =
{
  { "asl", SHIFT_LSL },	 { "ASL", SHIFT_LSL },
  { "lsl", SHIFT_LSL },	 { "LSL", SHIFT_LSL },
  { "lsr", SHIFT_LSR },	 { "LSR", SHIFT_LSR },
  { "asr", SHIFT_ASR },	 { "ASR", SHIFT_ASR },
  { "ror", SHIFT_ROR },	 { "ROR", SHIFT_ROR },
  { "rrx", SHIFT_RRX },	 { "RRX", SHIFT_RRX }
};
d7654 3
a7656 17
/* Table of all explicit relocation names.  */
#ifdef OBJ_ELF
static struct reloc_entry reloc_names[] =
{
  { "got",     BFD_RELOC_ARM_GOT32   },	 { "GOT",     BFD_RELOC_ARM_GOT32   },
  { "gotoff",  BFD_RELOC_ARM_GOTOFF  },	 { "GOTOFF",  BFD_RELOC_ARM_GOTOFF  },
  { "plt",     BFD_RELOC_ARM_PLT32   },	 { "PLT",     BFD_RELOC_ARM_PLT32   },
  { "target1", BFD_RELOC_ARM_TARGET1 },	 { "TARGET1", BFD_RELOC_ARM_TARGET1 },
  { "target2", BFD_RELOC_ARM_TARGET2 },	 { "TARGET2", BFD_RELOC_ARM_TARGET2 },
  { "sbrel",   BFD_RELOC_ARM_SBREL32 },	 { "SBREL",   BFD_RELOC_ARM_SBREL32 },
  { "tlsgd",   BFD_RELOC_ARM_TLS_GD32},  { "TLSGD",   BFD_RELOC_ARM_TLS_GD32},
  { "tlsldm",  BFD_RELOC_ARM_TLS_LDM32}, { "TLSLDM",  BFD_RELOC_ARM_TLS_LDM32},
  { "tlsldo",  BFD_RELOC_ARM_TLS_LDO32}, { "TLSLDO",  BFD_RELOC_ARM_TLS_LDO32},
  { "gottpoff",BFD_RELOC_ARM_TLS_IE32},  { "GOTTPOFF",BFD_RELOC_ARM_TLS_IE32},
  { "tpoff",   BFD_RELOC_ARM_TLS_LE32},  { "TPOFF",   BFD_RELOC_ARM_TLS_LE32}
};
#endif
d7658 4
a7661 150
/* Table of all conditional affixes.  0xF is not defined as a condition code.  */
static const struct asm_cond conds[] =
{
  {"eq", 0x0},
  {"ne", 0x1},
  {"cs", 0x2}, {"hs", 0x2},
  {"cc", 0x3}, {"ul", 0x3}, {"lo", 0x3},
  {"mi", 0x4},
  {"pl", 0x5},
  {"vs", 0x6},
  {"vc", 0x7},
  {"hi", 0x8},
  {"ls", 0x9},
  {"ge", 0xa},
  {"lt", 0xb},
  {"gt", 0xc},
  {"le", 0xd},
  {"al", 0xe}
};

/* Table of ARM-format instructions.	*/

/* Macros for gluing together operand strings.  N.B. In all cases
   other than OPS0, the trailing OP_stop comes from default
   zero-initialization of the unspecified elements of the array.  */
#define OPS0()		  { OP_stop, }
#define OPS1(a)		  { OP_##a, }
#define OPS2(a,b)	  { OP_##a,OP_##b, }
#define OPS3(a,b,c)	  { OP_##a,OP_##b,OP_##c, }
#define OPS4(a,b,c,d)	  { OP_##a,OP_##b,OP_##c,OP_##d, }
#define OPS5(a,b,c,d,e)	  { OP_##a,OP_##b,OP_##c,OP_##d,OP_##e, }
#define OPS6(a,b,c,d,e,f) { OP_##a,OP_##b,OP_##c,OP_##d,OP_##e,OP_##f, }

/* These macros abstract out the exact format of the mnemonic table and
   save some repeated characters.  */

/* The normal sort of mnemonic; has a Thumb variant; takes a conditional suffix.  */
#define TxCE(mnem, op, top, nops, ops, ae, te) \
  { #mnem, OPS##nops ops, OT_csuffix, 0x##op, top, ARM_VARIANT, \
    THUMB_VARIANT, do_##ae, do_##te }

/* Two variants of the above - TCE for a numeric Thumb opcode, tCE for
   a T_MNEM_xyz enumerator.  */
#define TCE(mnem, aop, top, nops, ops, ae, te) \
       TxCE(mnem, aop, 0x##top, nops, ops, ae, te)
#define tCE(mnem, aop, top, nops, ops, ae, te) \
       TxCE(mnem, aop, T_MNEM_##top, nops, ops, ae, te)

/* Second most common sort of mnemonic: has a Thumb variant, takes a conditional
   infix after the third character.  */
#define TxC3(mnem, op, top, nops, ops, ae, te) \
  { #mnem, OPS##nops ops, OT_cinfix3, 0x##op, top, ARM_VARIANT, \
    THUMB_VARIANT, do_##ae, do_##te }
#define TC3(mnem, aop, top, nops, ops, ae, te) \
       TxC3(mnem, aop, 0x##top, nops, ops, ae, te)
#define tC3(mnem, aop, top, nops, ops, ae, te) \
       TxC3(mnem, aop, T_MNEM_##top, nops, ops, ae, te)

/* Mnemonic with a conditional infix in an unusual place.  Each and every variant has to
   appear in the condition table.  */
#define TxCM_(m1, m2, m3, op, top, nops, ops, ae, te)	\
  { #m1 #m2 #m3, OPS##nops ops, sizeof(#m2) == 1 ? OT_odd_infix_unc : OT_odd_infix_0 + sizeof(#m1) - 1, \
    0x##op, top, ARM_VARIANT, THUMB_VARIANT, do_##ae, do_##te }

#define TxCM(m1, m2, op, top, nops, ops, ae, te)	\
  TxCM_(m1,   , m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, eq, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, ne, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, cs, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, hs, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, cc, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, ul, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, lo, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, mi, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, pl, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, vs, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, vc, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, hi, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, ls, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, ge, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, lt, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, gt, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, le, m2, op, top, nops, ops, ae, te),	\
  TxCM_(m1, al, m2, op, top, nops, ops, ae, te)

#define TCM(m1,m2, aop, top, nops, ops, ae, te)		\
       TxCM(m1,m2, aop, 0x##top, nops, ops, ae, te)
#define tCM(m1,m2, aop, top, nops, ops, ae, te)			\
       TxCM(m1,m2, aop, T_MNEM_##top, nops, ops, ae, te)

/* Mnemonic that cannot be conditionalized.  The ARM condition-code
   field is still 0xE.  */
#define TUE(mnem, op, top, nops, ops, ae, te)				\
  { #mnem, OPS##nops ops, OT_unconditional, 0x##op, 0x##top, ARM_VARIANT, \
    THUMB_VARIANT, do_##ae, do_##te }

/* Mnemonic that cannot be conditionalized, and bears 0xF in its ARM
   condition code field.  */
#define TUF(mnem, op, top, nops, ops, ae, te)				\
  { #mnem, OPS##nops ops, OT_unconditionalF, 0x##op, 0x##top, ARM_VARIANT, \
    THUMB_VARIANT, do_##ae, do_##te }

/* ARM-only variants of all the above.  */
#define CE(mnem,  op, nops, ops, ae)	\
  { #mnem, OPS##nops ops, OT_csuffix, 0x##op, 0x0, ARM_VARIANT, 0, do_##ae, NULL }

#define C3(mnem, op, nops, ops, ae)	\
  { #mnem, OPS##nops ops, OT_cinfix3, 0x##op, 0x0, ARM_VARIANT, 0, do_##ae, NULL }

#define xCM_(m1, m2, m3, op, nops, ops, ae)	\
  { #m1 #m2 #m3, OPS##nops ops, \
    sizeof(#m2) == 1 ? OT_odd_infix_unc : OT_odd_infix_0 + sizeof(#m1) - 1, \
    0x##op, 0x0, ARM_VARIANT, 0, do_##ae, NULL }

#define CM(m1, m2, op, nops, ops, ae)	\
  xCM_(m1,   , m2, op, nops, ops, ae),	\
  xCM_(m1, eq, m2, op, nops, ops, ae),	\
  xCM_(m1, ne, m2, op, nops, ops, ae),	\
  xCM_(m1, cs, m2, op, nops, ops, ae),	\
  xCM_(m1, hs, m2, op, nops, ops, ae),	\
  xCM_(m1, cc, m2, op, nops, ops, ae),	\
  xCM_(m1, ul, m2, op, nops, ops, ae),	\
  xCM_(m1, lo, m2, op, nops, ops, ae),	\
  xCM_(m1, mi, m2, op, nops, ops, ae),	\
  xCM_(m1, pl, m2, op, nops, ops, ae),	\
  xCM_(m1, vs, m2, op, nops, ops, ae),	\
  xCM_(m1, vc, m2, op, nops, ops, ae),	\
  xCM_(m1, hi, m2, op, nops, ops, ae),	\
  xCM_(m1, ls, m2, op, nops, ops, ae),	\
  xCM_(m1, ge, m2, op, nops, ops, ae),	\
  xCM_(m1, lt, m2, op, nops, ops, ae),	\
  xCM_(m1, gt, m2, op, nops, ops, ae),	\
  xCM_(m1, le, m2, op, nops, ops, ae),	\
  xCM_(m1, al, m2, op, nops, ops, ae)

#define UE(mnem, op, nops, ops, ae)	\
  { #mnem, OPS##nops ops, OT_unconditional, 0x##op, 0, ARM_VARIANT, 0, do_##ae, NULL }

#define UF(mnem, op, nops, ops, ae)	\
  { #mnem, OPS##nops ops, OT_unconditionalF, 0x##op, 0, ARM_VARIANT, 0, do_##ae, NULL }

#define do_0 0

/* Thumb-only, unconditional.  */
#define UT(mnem,  op, nops, ops, te) TUE(mnem,  0, op, nops, ops, 0, te)

/* ARM-only, takes either a suffix or a position-3 infix
   (for an FPA corner case). */
#define C3E(mnem, op, nops, ops, ae) \
  { #mnem, OPS##nops ops, OT_csuf_or_in3, 0x##op, 0, ARM_VARIANT, 0, do_##ae, 0 }
d7663 3
a7665 1
static const struct asm_opcode insns[] =
d7667 2
a7668 46
#define ARM_VARIANT ARM_EXT_V1 /* Core ARM Instructions.  */
#define THUMB_VARIANT ARM_EXT_V4T
 tCE(and,	0000000, and,      3, (RR, oRR, SH), arit, t_arit3c),
 tC3(ands,	0100000, ands,	   3, (RR, oRR, SH), arit, t_arit3c),
 tCE(eor,	0200000, eor,	   3, (RR, oRR, SH), arit, t_arit3c),
 tC3(eors,	0300000, eors,	   3, (RR, oRR, SH), arit, t_arit3c),
 tCE(sub,	0400000, sub,	   3, (RR, oRR, SH), arit, t_add_sub),
 tC3(subs,	0500000, subs,	   3, (RR, oRR, SH), arit, t_add_sub),
 tCE(add,	0800000, add,	   3, (RR, oRR, SH), arit, t_add_sub),
 tC3(adds,	0900000, adds,	   3, (RR, oRR, SH), arit, t_add_sub),
 tCE(adc,	0a00000, adc,	   3, (RR, oRR, SH), arit, t_arit3c),
 tC3(adcs,	0b00000, adcs,	   3, (RR, oRR, SH), arit, t_arit3c),
 tCE(sbc,	0c00000, sbc,	   3, (RR, oRR, SH), arit, t_arit3),
 tC3(sbcs,	0d00000, sbcs,	   3, (RR, oRR, SH), arit, t_arit3),
 tCE(orr,	1800000, orr,	   3, (RR, oRR, SH), arit, t_arit3c),
 tC3(orrs,	1900000, orrs,	   3, (RR, oRR, SH), arit, t_arit3c),
 tCE(bic,	1c00000, bic,	   3, (RR, oRR, SH), arit, t_arit3),
 tC3(bics,	1d00000, bics,	   3, (RR, oRR, SH), arit, t_arit3),

 /* The p-variants of tst/cmp/cmn/teq (below) are the pre-V6 mechanism
    for setting PSR flag bits.  They are obsolete in V6 and do not
    have Thumb equivalents. */
 tCE(tst,	1100000, tst,	   2, (RR, SH),      cmp,  t_mvn_tst),
 tC3(tsts,	1100000, tst,	   2, (RR, SH),      cmp,  t_mvn_tst),
  C3(tstp,	110f000,     	   2, (RR, SH),      cmp),
 tCE(cmp,	1500000, cmp,	   2, (RR, SH),      cmp,  t_mov_cmp),
 tC3(cmps,	1500000, cmp,	   2, (RR, SH),      cmp,  t_mov_cmp),
  C3(cmpp,	150f000,     	   2, (RR, SH),      cmp),
 tCE(cmn,	1700000, cmn,	   2, (RR, SH),      cmp,  t_mvn_tst),
 tC3(cmns,	1700000, cmn,	   2, (RR, SH),      cmp,  t_mvn_tst),
  C3(cmnp,	170f000,     	   2, (RR, SH),      cmp),

 tCE(mov,	1a00000, mov,	   2, (RR, SH),      mov,  t_mov_cmp),
 tC3(movs,	1b00000, movs,	   2, (RR, SH),      mov,  t_mov_cmp),
 tCE(mvn,	1e00000, mvn,	   2, (RR, SH),      mov,  t_mvn_tst),
 tC3(mvns,	1f00000, mvns,	   2, (RR, SH),      mov,  t_mvn_tst),

 tCE(ldr,	4100000, ldr,	   2, (RR, ADDR),    ldst, t_ldst),
 tC3(ldrb,	4500000, ldrb,	   2, (RR, ADDR),    ldst, t_ldst),
 tCE(str,	4000000, str,	   2, (RR, ADDR),    ldst, t_ldst),
 tC3(strb,	4400000, strb,	   2, (RR, ADDR),    ldst, t_ldst),

 tC3(stmia,	8800000, stmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),
 tC3(stmea,	8800000, stmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),
 tC3(ldmia,	8900000, ldmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),
 tC3(ldmfd,	8900000, ldmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),
d7670 7
a7676 9
 TCE(swi,	f000000, df00,     1, (EXPi),        swi, t_swi),
#ifdef TE_WINCE
  /* XXX This is the wrong place to do this.  Think multi-arch.	 */
 TCE(b,		a000000, e7fe,	     1, (EXPr),	    branch, t_branch),
 TCE(bl,	b000000, f7fffffe,   1, (EXPr),	    branch, t_branch23),
#else
 TCE(b,		afffffe, e7fe,	     1, (EXPr),	    branch, t_branch),
 TCE(bl,	bfffffe, f7fffffe,   1, (EXPr),	    branch, t_branch23),
#endif
d7678 3
a7680 108
  /* Pseudo ops.  */
 TCE(adr,	28f0000, 000f,	   2, (RR, EXP),    adr,  t_adr),
  C3(adrl,	28f0000,           2, (RR, EXP),    adrl),
 tCE(nop,	1a00000, nop,	   1, (oI255c),	    nop,  t_nop),

  /* Thumb-compatibility pseudo ops.  */
 tCE(lsl,	1a00000, lsl,	   3, (RR, oRR, SH), shift, t_shift),
 tC3(lsls,	1b00000, lsls,	   3, (RR, oRR, SH), shift, t_shift),
 tCE(lsr,	1a00020, lsr,	   3, (RR, oRR, SH), shift, t_shift),
 tC3(lsrs,	1b00020, lsrs,	   3, (RR, oRR, SH), shift, t_shift),
 tCE(asr,	1a00040, asr,	   3, (RR, oRR, SH), shift, t_shift),
 tC3(asrs,     1b00040, asrs,     3, (RR, oRR, SH), shift, t_shift),
 tCE(ror,	1a00060, ror,	   3, (RR, oRR, SH), shift, t_shift),
 tC3(rors,	1b00060, rors,	   3, (RR, oRR, SH), shift, t_shift),
 tCE(neg,	2600000, neg,	   2, (RR, RR),      rd_rn, t_neg),
 tC3(negs,	2700000, negs,	   2, (RR, RR),      rd_rn, t_neg),
 tCE(push,	92d0000, push,     1, (REGLST),	     push_pop, t_push_pop),
 tCE(pop,	8bd0000, pop,	   1, (REGLST),	     push_pop, t_push_pop),

#undef THUMB_VARIANT
#define THUMB_VARIANT ARM_EXT_V6
 TCE(cpy,       1a00000, 4600,     2, (RR, RR),          rd_rm, t_cpy),

 /* V1 instructions with no Thumb analogue prior to V6T2.  */
#undef THUMB_VARIANT
#define THUMB_VARIANT ARM_EXT_V6T2
 TCE(rsb,	0600000, ebc00000, 3, (RR, oRR, SH), arit, t_rsb),
 TC3(rsbs,	0700000, ebd00000, 3, (RR, oRR, SH), arit, t_rsb),
 TCE(teq,	1300000, ea900f00, 2, (RR, SH),      cmp,  t_mvn_tst),
 TC3(teqs,	1300000, ea900f00, 2, (RR, SH),      cmp,  t_mvn_tst),
  C3(teqp,	130f000,           2, (RR, SH),      cmp),

 TC3(ldrt,	4300000, f8500e00, 2, (RR, ADDR),    ldstt, t_ldstt),
 TC3(ldrbt,	4700000, f8300e00, 2, (RR, ADDR),    ldstt, t_ldstt),
 TC3(strt,	4200000, f8400e00, 2, (RR, ADDR),    ldstt, t_ldstt),
 TC3(strbt,	4600000, f8200e00, 2, (RR, ADDR),    ldstt, t_ldstt),

 TC3(stmdb,	9000000, e9100000, 2, (RRw, REGLST), ldmstm, t_ldmstm),
 TC3(stmfd,    9000000, e9100000, 2, (RRw, REGLST), ldmstm, t_ldmstm),

 TC3(ldmdb,	9100000, e9000000, 2, (RRw, REGLST), ldmstm, t_ldmstm),
 TC3(ldmea,	9100000, e9000000, 2, (RRw, REGLST), ldmstm, t_ldmstm),

 /* V1 instructions with no Thumb analogue at all.  */
  CE(rsc,	0e00000,	   3, (RR, oRR, SH), arit),
  C3(rscs,	0f00000,	   3, (RR, oRR, SH), arit),

  C3(stmib,	9800000,	   2, (RRw, REGLST), ldmstm),
  C3(stmfa,	9800000,	   2, (RRw, REGLST), ldmstm),
  C3(stmda,	8000000,	   2, (RRw, REGLST), ldmstm),
  C3(stmed,	8000000,	   2, (RRw, REGLST), ldmstm),
  C3(ldmib,	9900000,	   2, (RRw, REGLST), ldmstm),
  C3(ldmed,	9900000,	   2, (RRw, REGLST), ldmstm),
  C3(ldmda,	8100000,	   2, (RRw, REGLST), ldmstm),
  C3(ldmfa,	8100000,	   2, (RRw, REGLST), ldmstm),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V2	/* ARM 2 - multiplies.	*/
#undef THUMB_VARIANT
#define THUMB_VARIANT ARM_EXT_V4T
 tCE(mul,	0000090, mul,	   3, (RRnpc, RRnpc, oRR), mul, t_mul),
 tC3(muls,	0100090, muls,	   3, (RRnpc, RRnpc, oRR), mul, t_mul),

#undef THUMB_VARIANT
#define THUMB_VARIANT ARM_EXT_V6T2
 TCE(mla,	0200090, fb000000, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mlas, t_mla),
  C3(mlas,	0300090,           4, (RRnpc, RRnpc, RRnpc, RRnpc), mlas),

  /* Generic coprocessor instructions.	*/
 TCE(cdp,	e000000, ee000000, 6, (RCP, I15b, RCN, RCN, RCN, oI7b), cdp,    cdp),
 TCE(ldc,	c100000, ec100000, 3, (RCP, RCN, ADDR),		        lstc,   lstc),
 TC3(ldcl,	c500000, ec500000, 3, (RCP, RCN, ADDR),		        lstc,   lstc),
 TCE(stc,	c000000, ec000000, 3, (RCP, RCN, ADDR),		        lstc,   lstc),
 TC3(stcl,	c400000, ec400000, 3, (RCP, RCN, ADDR),		        lstc,   lstc),
 TCE(mcr,	e000010, ee000010, 6, (RCP, I7b, RR, RCN, RCN, oI7b),   co_reg, co_reg),
 TCE(mrc,	e100010, ee100010, 6, (RCP, I7b, RR, RCN, RCN, oI7b),   co_reg, co_reg),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V2S /* ARM 3 - swp instructions.  */
  CE(swp,	1000090,           3, (RRnpc, RRnpc, RRnpcb), rd_rm_rn),
  C3(swpb,	1400090,           3, (RRnpc, RRnpc, RRnpcb), rd_rm_rn),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V3	/* ARM 6 Status register instructions.	*/
 TCE(mrs,	10f0000, f3ef8000, 2, (RR, PSR),     mrs, t_mrs),
 TCE(msr,	120f000, f3808000, 2, (PSR, RR_EXi), msr, t_msr),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V3M	 /* ARM 7M long multiplies.  */
 TCE(smull,	0c00090, fb800000, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mull, t_mull),
  CM(smull,s,	0d00090,           4, (RRnpc, RRnpc, RRnpc, RRnpc), mull),
 TCE(umull,	0800090, fba00000, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mull, t_mull),
  CM(umull,s,	0900090,           4, (RRnpc, RRnpc, RRnpc, RRnpc), mull),
 TCE(smlal,	0e00090, fbc00000, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mull, t_mull),
  CM(smlal,s,	0f00090,           4, (RRnpc, RRnpc, RRnpc, RRnpc), mull),
 TCE(umlal,	0a00090, fbe00000, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mull, t_mull),
  CM(umlal,s,	0b00090,           4, (RRnpc, RRnpc, RRnpc, RRnpc), mull),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V4	/* ARM Architecture 4.	*/
#undef THUMB_VARIANT
#define THUMB_VARIANT ARM_EXT_V4T
 tC3(ldrh,	01000b0, ldrh,     2, (RR, ADDR), ldstv4, t_ldst),
 tC3(strh,	00000b0, strh,     2, (RR, ADDR), ldstv4, t_ldst),
 tC3(ldrsh,	01000f0, ldrsh,    2, (RR, ADDR), ldstv4, t_ldst),
 tC3(ldrsb,	01000d0, ldrsb,    2, (RR, ADDR), ldstv4, t_ldst),
 tCM(ld,sh,	01000f0, ldrsh,    2, (RR, ADDR), ldstv4, t_ldst),
 tCM(ld,sb,	01000d0, ldrsb,    2, (RR, ADDR), ldstv4, t_ldst),
d7682 3
a7684 6
#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V4T|ARM_EXT_V5
  /* ARM Architecture 4T.  */
  /* Note: bx (and blx) are required on V5, even if the processor does
     not support Thumb.	 */
 TCE(bx,	12fff10, 4700, 1, (RR),	bx, t_bx),
d7686 5
a7690 638
#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V5 /*  ARM Architecture 5T.	 */
#undef THUMB_VARIANT
#define THUMB_VARIANT ARM_EXT_V5T
  /* Note: blx has 2 variants; the .value coded here is for
     BLX(2).  Only this variant has conditional execution.  */
 TCE(blx,	12fff30, 4780, 1, (RR_EXr),			    blx,  t_blx),
 TUE(bkpt,	1200070, be00, 1, (oIffffb),			    bkpt, t_bkpt),

#undef THUMB_VARIANT
#define THUMB_VARIANT ARM_EXT_V6T2
 TCE(clz,	16f0f10, fab0f080, 2, (RRnpc, RRnpc),		        rd_rm,  t_clz),
 TUF(ldc2,	c100000, fc100000, 3, (RCP, RCN, ADDR),		        lstc,	lstc),
 TUF(ldc2l,	c500000, fc500000, 3, (RCP, RCN, ADDR),		        lstc,	lstc),
 TUF(stc2,	c000000, fc000000, 3, (RCP, RCN, ADDR),		        lstc,	lstc),
 TUF(stc2l,	c400000, fc400000, 3, (RCP, RCN, ADDR),		        lstc,	lstc),
 TUF(cdp2,	e000000, fe000000, 6, (RCP, I15b, RCN, RCN, RCN, oI7b), cdp,    cdp),
 TUF(mcr2,	e000010, fe000010, 6, (RCP, I7b, RR, RCN, RCN, oI7b),   co_reg, co_reg),
 TUF(mrc2,	e100010, fe100010, 6, (RCP, I7b, RR, RCN, RCN, oI7b),   co_reg, co_reg),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V5ExP /*  ARM Architecture 5TExP.  */
 TCE(smlabb,	1000080, fb100000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),
 TCE(smlatb,	10000a0, fb100020, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),
 TCE(smlabt,	10000c0, fb100010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),
 TCE(smlatt,	10000e0, fb100030, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),

 TCE(smlawb,	1200080, fb300000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),
 TCE(smlawt,	12000c0, fb300010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),

 TCE(smlalbb,	1400080, fbc00080, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smlal, t_mlal),
 TCE(smlaltb,	14000a0, fbc000a0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smlal, t_mlal),
 TCE(smlalbt,	14000c0, fbc00090, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smlal, t_mlal),
 TCE(smlaltt,	14000e0, fbc000b0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smlal, t_mlal),

 TCE(smulbb,	1600080, fb10f000, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),
 TCE(smultb,	16000a0, fb10f020, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),
 TCE(smulbt,	16000c0, fb10f010, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),
 TCE(smultt,	16000e0, fb10f030, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),

 TCE(smulwb,	12000a0, fb30f000, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),
 TCE(smulwt,	12000e0, fb30f010, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),

 TCE(qadd,	1000050, fa80f080, 3, (RRnpc, RRnpc, RRnpc),	    rd_rm_rn, rd_rm_rn),
 TCE(qdadd,	1400050, fa80f090, 3, (RRnpc, RRnpc, RRnpc),	    rd_rm_rn, rd_rm_rn),
 TCE(qsub,	1200050, fa80f0a0, 3, (RRnpc, RRnpc, RRnpc),	    rd_rm_rn, rd_rm_rn),
 TCE(qdsub,	1600050, fa80f0b0, 3, (RRnpc, RRnpc, RRnpc),	    rd_rm_rn, rd_rm_rn),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V5E /*  ARM Architecture 5TE.  */
 TUF(pld,	450f000, f810f000, 1, (ADDR),		     pld,  t_pld),
 TC3(ldrd,	00000d0, e9500000, 3, (RRnpc, oRRnpc, ADDR), ldrd, t_ldstd),
 TC3(strd,	00000f0, e9400000, 3, (RRnpc, oRRnpc, ADDR), ldrd, t_ldstd),

 TCE(mcrr,	c400000, ec400000, 5, (RCP, I15b, RRnpc, RRnpc, RCN), co_reg2c, co_reg2c),
 TCE(mrrc,	c500000, ec500000, 5, (RCP, I15b, RRnpc, RRnpc, RCN), co_reg2c, co_reg2c),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V5J /*  ARM Architecture 5TEJ.  */
 TCE(bxj,	12fff20, f3c08f00, 1, (RR),			  bxj, t_bxj),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V6 /*  ARM V6.  */
#undef THUMB_VARIANT
#define THUMB_VARIANT ARM_EXT_V6
 TUF(cpsie,     1080000, b660,     2, (CPSF, oI31b),              cpsi,   t_cpsi),
 TUF(cpsid,     10c0000, b670,     2, (CPSF, oI31b),              cpsi,   t_cpsi),
 tCE(rev,       6bf0f30, rev,      2, (RRnpc, RRnpc),             rd_rm,  t_rev),
 tCE(rev16,     6bf0fb0, rev16,    2, (RRnpc, RRnpc),             rd_rm,  t_rev),
 tCE(revsh,     6ff0fb0, revsh,    2, (RRnpc, RRnpc),             rd_rm,  t_rev),
 tCE(sxth,      6bf0070, sxth,     3, (RRnpc, RRnpc, oROR),       sxth,   t_sxth),
 tCE(uxth,      6ff0070, uxth,     3, (RRnpc, RRnpc, oROR),       sxth,   t_sxth),
 tCE(sxtb,      6af0070, sxtb,     3, (RRnpc, RRnpc, oROR),       sxth,   t_sxth),
 tCE(uxtb,      6ef0070, uxtb,     3, (RRnpc, RRnpc, oROR),       sxth,   t_sxth),
 TUF(setend,    1010000, b650,     1, (ENDI),                     setend, t_setend),

#undef THUMB_VARIANT
#define THUMB_VARIANT ARM_EXT_V6T2
 TUF(cps,	1020000, f3af8100, 1, (I31b),			  imm0, imm0),
 TCE(ldrex,	1900f9f, e8500f00, 2, (RRnpc, ADDR),		  ldrex, t_ldrex),
 TUF(mcrr2,	c400000, fc400000, 5, (RCP, I15b, RRnpc, RRnpc, RCN), co_reg2c, co_reg2c),
 TUF(mrrc2,	c500000, fc500000, 5, (RCP, I15b, RRnpc, RRnpc, RCN), co_reg2c, co_reg2c),
 TCE(pkhbt,	6800010, eac00000, 4, (RRnpc, RRnpc, RRnpc, oSHll),   pkhbt, t_pkhbt),
 TCE(pkhtb,	6800050, eac00020, 4, (RRnpc, RRnpc, RRnpc, oSHar),   pkhtb, t_pkhtb),
 TCE(qadd16,	6200f10, fa90f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(qadd8,	6200f90, fa80f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(qaddsubx,	6200f30, faa0f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(qsub16,	6200f70, fad0f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(qsub8,	6200ff0, fac0f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(qsubaddx,	6200f50, fae0f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(sadd16,	6100f10, fa90f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(sadd8,	6100f90, fa80f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(saddsubx,	6100f30, faa0f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(shadd16,	6300f10, fa90f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(shadd8,	6300f90, fa80f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(shaddsubx, 6300f30, faa0f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(shsub16,	6300f70, fad0f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(shsub8,	6300ff0, fac0f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(shsubaddx, 6300f50, fae0f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(ssub16,	6100f70, fad0f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(ssub8,	6100ff0, fac0f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(ssubaddx,	6100f50, fae0f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uadd16,	6500f10, fa90f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uadd8,	6500f90, fa80f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uaddsubx,	6500f30, faa0f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uhadd16,	6700f10, fa90f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uhadd8,	6700f90, fa80f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uhaddsubx, 6700f30, faa0f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uhsub16,	6700f70, fad0f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uhsub8,	6700ff0, fac0f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uhsubaddx, 6700f50, fae0f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uqadd16,	6600f10, fa90f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uqadd8,	6600f90, fa80f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uqaddsubx, 6600f30, faa0f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uqsub16,	6600f70, fad0f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uqsub8,	6600ff0, fac0f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(uqsubaddx, 6600f50, fae0f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(usub16,	6500f70, fad0f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(usub8,	6500ff0, fac0f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(usubaddx,	6500f50, fae0f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TUF(rfeia,	8900a00, e990c000, 1, (RRw),			   rfe, rfe),
  UF(rfeib,	9900a00,           1, (RRw),			   rfe),
  UF(rfeda,	8100a00,           1, (RRw),			   rfe),
 TUF(rfedb,	9100a00, e810c000, 1, (RRw),			   rfe, rfe),
 TUF(rfefd,	8900a00, e990c000, 1, (RRw),			   rfe, rfe),
  UF(rfefa,	9900a00,           1, (RRw),			   rfe),
  UF(rfeea,	8100a00,           1, (RRw),			   rfe),
 TUF(rfeed,	9100a00, e810c000, 1, (RRw),			   rfe, rfe),
 TCE(sxtah,	6b00070, fa00f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
 TCE(sxtab16,	6800070, fa20f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
 TCE(sxtab,	6a00070, fa40f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
 TCE(sxtb16,	68f0070, fa2ff080, 3, (RRnpc, RRnpc, oROR),	   sxth,  t_sxth),
 TCE(uxtah,	6f00070, fa10f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
 TCE(uxtab16,	6c00070, fa30f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
 TCE(uxtab,	6e00070, fa50f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
 TCE(uxtb16,	6cf0070, fa3ff080, 3, (RRnpc, RRnpc, oROR),	   sxth,  t_sxth),
 TCE(sel,	68000b0, faa0f080, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
 TCE(smlad,	7000010, fb200000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE(smladx,	7000030, fb200010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE(smlald,	7400010, fbc000c0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smlal,t_mlal),
 TCE(smlaldx,	7400030, fbc000d0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smlal,t_mlal),
 TCE(smlsd,	7000050, fb400000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE(smlsdx,	7000070, fb400010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE(smlsld,	7400050, fbd000c0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smlal,t_mlal),
 TCE(smlsldx,	7400070, fbd000d0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smlal,t_mlal),
 TCE(smmla,	7500010, fb500000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE(smmlar,	7500030, fb500010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE(smmls,	75000d0, fb600000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE(smmlsr,	75000f0, fb600010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
 TCE(smmul,	750f010, fb50f000, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
 TCE(smmulr,	750f030, fb50f010, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
 TCE(smuad,	700f010, fb20f000, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
 TCE(smuadx,	700f030, fb20f010, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
 TCE(smusd,	700f050, fb40f000, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
 TCE(smusdx,	700f070, fb40f010, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
 TUF(srsia,	8cd0500, e980c000, 1, (I31w),			   srs,  srs),
  UF(srsib,	9cd0500,           1, (I31w),			   srs),
  UF(srsda,	84d0500,	   1, (I31w),			   srs),
 TUF(srsdb,	94d0500, e800c000, 1, (I31w),			   srs,  srs),
 TCE(ssat,	6a00010, f3000000, 4, (RRnpc, I32, RRnpc, oSHllar),ssat,   t_ssat),
 TCE(ssat16,	6a00f30, f3200000, 3, (RRnpc, I16, RRnpc),	   ssat16, t_ssat16),
 TCE(strex,	1800f90, e8400000, 3, (RRnpc, RRnpc, ADDR),	   strex,  t_strex),
 TCE(umaal,	0400090, fbe00060, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smlal,  t_mlal),
 TCE(usad8,	780f010, fb70f000, 3, (RRnpc, RRnpc, RRnpc),	   smul,   t_simd),
 TCE(usada8,	7800010, fb700000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla,   t_mla),
 TCE(usat,	6e00010, f3800000, 4, (RRnpc, I31, RRnpc, oSHllar),usat,   t_usat),
 TCE(usat16,	6e00f30, f3a00000, 3, (RRnpc, I15, RRnpc),	   usat16, t_usat16),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V6K
#undef THUMB_VARIANT
#define THUMB_VARIANT ARM_EXT_V6K
 tCE(yield,	320f001, yield,    0, (), noargs, t_hint),
 tCE(wfe,	320f002, wfe,      0, (), noargs, t_hint),
 tCE(wfi,	320f003, wfi,      0, (), noargs, t_hint),
 tCE(sev,	320f004, sev,      0, (), noargs, t_hint),

#undef THUMB_VARIANT
#define THUMB_VARIANT ARM_EXT_V6T2
 TCE(ldrexb,	1d00f9f, e8d00f4f, 2, (RRnpc, RRnpcb),	              rd_rn,  rd_rn),
 TCE(ldrexh,	1f00f9f, e8d00f5f, 2, (RRnpc, RRnpcb),	              rd_rn,  rd_rn),
 TCE(ldrexd,	1b00f9f, e8d0007f, 3, (RRnpc, oRRnpc, RRnpcb),        ldrexd, t_ldrexd),
 TCE(strexb,	1c00f90, e8c00f40, 3, (RRnpc, RRnpc, ADDR),           strex,  rm_rd_rn),
 TCE(strexh,	1e00f90, e8c00f50, 3, (RRnpc, RRnpc, ADDR),           strex,  rm_rd_rn),
 TCE(strexd,	1a00f90, e8c00070, 4, (RRnpc, RRnpc, oRRnpc, RRnpcb), strexd, t_strexd),
 TUF(clrex,	57ff01f, f3bf8f2f, 0, (),			      noargs, noargs),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V6Z
 TCE(smi,	1600070, f7f08000, 1, (EXPi), smi, t_smi),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_EXT_V6T2
 TCE(bfc,	7c0001f, f36f0000, 3, (RRnpc, I31, I32),	   bfc, t_bfc),
 TCE(bfi,	7c00010, f3600000, 4, (RRnpc, RRnpc_I0, I31, I32), bfi, t_bfi),
 TCE(sbfx,	7a00050, f3400000, 4, (RR, RR, I31, I32),	   bfx, t_bfx),
 TCE(ubfx,	7e00050, f3c00000, 4, (RR, RR, I31, I32),	   bfx, t_bfx),

 TCE(mls,	0600090, fb000010, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mlas, t_mla),
 TCE(movw,	3000000, f2400000, 2, (RRnpc, Iffff),		    mov16, t_mov16),
 TCE(movt,	3400000, f2c00000, 2, (RRnpc, Iffff),		    mov16, t_mov16),
 TCE(rbit,	3ff0f30, fa90f0a0, 2, (RR, RR),			    rd_rm, t_rbit),

 TC3(ldrht,	03000b0, f8300e00, 2, (RR, ADDR), ldsttv4, t_ldstt),
 TC3(ldrsht,	03000f0, f9300e00, 2, (RR, ADDR), ldsttv4, t_ldstt),
 TC3(ldrsbt,	03000d0, f9100e00, 2, (RR, ADDR), ldsttv4, t_ldstt),
 TC3(strht,	02000b0, f8200e00, 2, (RR, ADDR), ldsttv4, t_ldstt),

  UT(cbnz,      b900,    2, (RR, EXP), t_czb),
  UT(cbz,       b100,    2, (RR, EXP), t_czb),
 /* ARM does not really have an IT instruction.  */
 TUE(it,        0, bf08, 1, (COND),    it, t_it),
 TUE(itt,       0, bf0c, 1, (COND),    it, t_it),
 TUE(ite,       0, bf04, 1, (COND),    it, t_it),
 TUE(ittt,      0, bf0e, 1, (COND),    it, t_it),
 TUE(itet,      0, bf06, 1, (COND),    it, t_it),
 TUE(itte,      0, bf0a, 1, (COND),    it, t_it),
 TUE(itee,      0, bf02, 1, (COND),    it, t_it),
 TUE(itttt,     0, bf0f, 1, (COND),    it, t_it),
 TUE(itett,     0, bf07, 1, (COND),    it, t_it),
 TUE(ittet,     0, bf0b, 1, (COND),    it, t_it),
 TUE(iteet,     0, bf03, 1, (COND),    it, t_it),
 TUE(ittte,     0, bf0d, 1, (COND),    it, t_it),
 TUE(itete,     0, bf05, 1, (COND),    it, t_it),
 TUE(ittee,     0, bf09, 1, (COND),    it, t_it),
 TUE(iteee,     0, bf01, 1, (COND),    it, t_it),

#undef ARM_VARIANT
#define ARM_VARIANT FPU_FPA_EXT_V1  /* Core FPA instruction set (V1).  */
  CE(wfs,	e200110, 1, (RR),	     rd),
  CE(rfs,	e300110, 1, (RR),	     rd),
  CE(wfc,	e400110, 1, (RR),	     rd),
  CE(rfc,	e500110, 1, (RR),	     rd),

  C3(ldfs,	c100100, 2, (RF, ADDR),	     rd_cpaddr),
  C3(ldfd,	c108100, 2, (RF, ADDR),	     rd_cpaddr),
  C3(ldfe,	c500100, 2, (RF, ADDR),	     rd_cpaddr),
  C3(ldfp,	c508100, 2, (RF, ADDR),	     rd_cpaddr),

  C3(stfs,	c000100, 2, (RF, ADDR),	     rd_cpaddr),
  C3(stfd,	c008100, 2, (RF, ADDR),	     rd_cpaddr),
  C3(stfe,	c400100, 2, (RF, ADDR),	     rd_cpaddr),
  C3(stfp,	c408100, 2, (RF, ADDR),	     rd_cpaddr),

  C3(mvfs,	e008100, 2, (RF, RF_IF),     rd_rm),
  C3(mvfsp,	e008120, 2, (RF, RF_IF),     rd_rm),
  C3(mvfsm,	e008140, 2, (RF, RF_IF),     rd_rm),
  C3(mvfsz,	e008160, 2, (RF, RF_IF),     rd_rm),
  C3(mvfd,	e008180, 2, (RF, RF_IF),     rd_rm),
  C3(mvfdp,	e0081a0, 2, (RF, RF_IF),     rd_rm),
  C3(mvfdm,	e0081c0, 2, (RF, RF_IF),     rd_rm),
  C3(mvfdz,	e0081e0, 2, (RF, RF_IF),     rd_rm),
  C3(mvfe,	e088100, 2, (RF, RF_IF),     rd_rm),
  C3(mvfep,	e088120, 2, (RF, RF_IF),     rd_rm),
  C3(mvfem,	e088140, 2, (RF, RF_IF),     rd_rm),
  C3(mvfez,	e088160, 2, (RF, RF_IF),     rd_rm),

  C3(mnfs,	e108100, 2, (RF, RF_IF),     rd_rm),
  C3(mnfsp,	e108120, 2, (RF, RF_IF),     rd_rm),
  C3(mnfsm,	e108140, 2, (RF, RF_IF),     rd_rm),
  C3(mnfsz,	e108160, 2, (RF, RF_IF),     rd_rm),
  C3(mnfd,	e108180, 2, (RF, RF_IF),     rd_rm),
  C3(mnfdp,	e1081a0, 2, (RF, RF_IF),     rd_rm),
  C3(mnfdm,	e1081c0, 2, (RF, RF_IF),     rd_rm),
  C3(mnfdz,	e1081e0, 2, (RF, RF_IF),     rd_rm),
  C3(mnfe,	e188100, 2, (RF, RF_IF),     rd_rm),
  C3(mnfep,	e188120, 2, (RF, RF_IF),     rd_rm),
  C3(mnfem,	e188140, 2, (RF, RF_IF),     rd_rm),
  C3(mnfez,	e188160, 2, (RF, RF_IF),     rd_rm),

  C3(abss,	e208100, 2, (RF, RF_IF),     rd_rm),
  C3(abssp,	e208120, 2, (RF, RF_IF),     rd_rm),
  C3(abssm,	e208140, 2, (RF, RF_IF),     rd_rm),
  C3(abssz,	e208160, 2, (RF, RF_IF),     rd_rm),
  C3(absd,	e208180, 2, (RF, RF_IF),     rd_rm),
  C3(absdp,	e2081a0, 2, (RF, RF_IF),     rd_rm),
  C3(absdm,	e2081c0, 2, (RF, RF_IF),     rd_rm),
  C3(absdz,	e2081e0, 2, (RF, RF_IF),     rd_rm),
  C3(abse,	e288100, 2, (RF, RF_IF),     rd_rm),
  C3(absep,	e288120, 2, (RF, RF_IF),     rd_rm),
  C3(absem,	e288140, 2, (RF, RF_IF),     rd_rm),
  C3(absez,	e288160, 2, (RF, RF_IF),     rd_rm),

  C3(rnds,	e308100, 2, (RF, RF_IF),     rd_rm),
  C3(rndsp,	e308120, 2, (RF, RF_IF),     rd_rm),
  C3(rndsm,	e308140, 2, (RF, RF_IF),     rd_rm),
  C3(rndsz,	e308160, 2, (RF, RF_IF),     rd_rm),
  C3(rndd,	e308180, 2, (RF, RF_IF),     rd_rm),
  C3(rnddp,	e3081a0, 2, (RF, RF_IF),     rd_rm),
  C3(rnddm,	e3081c0, 2, (RF, RF_IF),     rd_rm),
  C3(rnddz,	e3081e0, 2, (RF, RF_IF),     rd_rm),
  C3(rnde,	e388100, 2, (RF, RF_IF),     rd_rm),
  C3(rndep,	e388120, 2, (RF, RF_IF),     rd_rm),
  C3(rndem,	e388140, 2, (RF, RF_IF),     rd_rm),
  C3(rndez,	e388160, 2, (RF, RF_IF),     rd_rm),

  C3(sqts,	e408100, 2, (RF, RF_IF),     rd_rm),
  C3(sqtsp,	e408120, 2, (RF, RF_IF),     rd_rm),
  C3(sqtsm,	e408140, 2, (RF, RF_IF),     rd_rm),
  C3(sqtsz,	e408160, 2, (RF, RF_IF),     rd_rm),
  C3(sqtd,	e408180, 2, (RF, RF_IF),     rd_rm),
  C3(sqtdp,	e4081a0, 2, (RF, RF_IF),     rd_rm),
  C3(sqtdm,	e4081c0, 2, (RF, RF_IF),     rd_rm),
  C3(sqtdz,	e4081e0, 2, (RF, RF_IF),     rd_rm),
  C3(sqte,	e488100, 2, (RF, RF_IF),     rd_rm),
  C3(sqtep,	e488120, 2, (RF, RF_IF),     rd_rm),
  C3(sqtem,	e488140, 2, (RF, RF_IF),     rd_rm),
  C3(sqtez,	e488160, 2, (RF, RF_IF),     rd_rm),

  C3(logs,	e508100, 2, (RF, RF_IF),     rd_rm),
  C3(logsp,	e508120, 2, (RF, RF_IF),     rd_rm),
  C3(logsm,	e508140, 2, (RF, RF_IF),     rd_rm),
  C3(logsz,	e508160, 2, (RF, RF_IF),     rd_rm),
  C3(logd,	e508180, 2, (RF, RF_IF),     rd_rm),
  C3(logdp,	e5081a0, 2, (RF, RF_IF),     rd_rm),
  C3(logdm,	e5081c0, 2, (RF, RF_IF),     rd_rm),
  C3(logdz,	e5081e0, 2, (RF, RF_IF),     rd_rm),
  C3(loge,	e588100, 2, (RF, RF_IF),     rd_rm),
  C3(logep,	e588120, 2, (RF, RF_IF),     rd_rm),
  C3(logem,	e588140, 2, (RF, RF_IF),     rd_rm),
  C3(logez,	e588160, 2, (RF, RF_IF),     rd_rm),

  C3(lgns,	e608100, 2, (RF, RF_IF),     rd_rm),
  C3(lgnsp,	e608120, 2, (RF, RF_IF),     rd_rm),
  C3(lgnsm,	e608140, 2, (RF, RF_IF),     rd_rm),
  C3(lgnsz,	e608160, 2, (RF, RF_IF),     rd_rm),
  C3(lgnd,	e608180, 2, (RF, RF_IF),     rd_rm),
  C3(lgndp,	e6081a0, 2, (RF, RF_IF),     rd_rm),
  C3(lgndm,	e6081c0, 2, (RF, RF_IF),     rd_rm),
  C3(lgndz,	e6081e0, 2, (RF, RF_IF),     rd_rm),
  C3(lgne,	e688100, 2, (RF, RF_IF),     rd_rm),
  C3(lgnep,	e688120, 2, (RF, RF_IF),     rd_rm),
  C3(lgnem,	e688140, 2, (RF, RF_IF),     rd_rm),
  C3(lgnez,	e688160, 2, (RF, RF_IF),     rd_rm),

  C3(exps,	e708100, 2, (RF, RF_IF),     rd_rm),
  C3(expsp,	e708120, 2, (RF, RF_IF),     rd_rm),
  C3(expsm,	e708140, 2, (RF, RF_IF),     rd_rm),
  C3(expsz,	e708160, 2, (RF, RF_IF),     rd_rm),
  C3(expd,	e708180, 2, (RF, RF_IF),     rd_rm),
  C3(expdp,	e7081a0, 2, (RF, RF_IF),     rd_rm),
  C3(expdm,	e7081c0, 2, (RF, RF_IF),     rd_rm),
  C3(expdz,	e7081e0, 2, (RF, RF_IF),     rd_rm),
  C3(expe,	e788100, 2, (RF, RF_IF),     rd_rm),
  C3(expep,	e788120, 2, (RF, RF_IF),     rd_rm),
  C3(expem,	e788140, 2, (RF, RF_IF),     rd_rm),
  C3(expdz,	e788160, 2, (RF, RF_IF),     rd_rm),

  C3(sins,	e808100, 2, (RF, RF_IF),     rd_rm),
  C3(sinsp,	e808120, 2, (RF, RF_IF),     rd_rm),
  C3(sinsm,	e808140, 2, (RF, RF_IF),     rd_rm),
  C3(sinsz,	e808160, 2, (RF, RF_IF),     rd_rm),
  C3(sind,	e808180, 2, (RF, RF_IF),     rd_rm),
  C3(sindp,	e8081a0, 2, (RF, RF_IF),     rd_rm),
  C3(sindm,	e8081c0, 2, (RF, RF_IF),     rd_rm),
  C3(sindz,	e8081e0, 2, (RF, RF_IF),     rd_rm),
  C3(sine,	e888100, 2, (RF, RF_IF),     rd_rm),
  C3(sinep,	e888120, 2, (RF, RF_IF),     rd_rm),
  C3(sinem,	e888140, 2, (RF, RF_IF),     rd_rm),
  C3(sinez,	e888160, 2, (RF, RF_IF),     rd_rm),

  C3(coss,	e908100, 2, (RF, RF_IF),     rd_rm),
  C3(cossp,	e908120, 2, (RF, RF_IF),     rd_rm),
  C3(cossm,	e908140, 2, (RF, RF_IF),     rd_rm),
  C3(cossz,	e908160, 2, (RF, RF_IF),     rd_rm),
  C3(cosd,	e908180, 2, (RF, RF_IF),     rd_rm),
  C3(cosdp,	e9081a0, 2, (RF, RF_IF),     rd_rm),
  C3(cosdm,	e9081c0, 2, (RF, RF_IF),     rd_rm),
  C3(cosdz,	e9081e0, 2, (RF, RF_IF),     rd_rm),
  C3(cose,	e988100, 2, (RF, RF_IF),     rd_rm),
  C3(cosep,	e988120, 2, (RF, RF_IF),     rd_rm),
  C3(cosem,	e988140, 2, (RF, RF_IF),     rd_rm),
  C3(cosez,	e988160, 2, (RF, RF_IF),     rd_rm),

  C3(tans,	ea08100, 2, (RF, RF_IF),     rd_rm),
  C3(tansp,	ea08120, 2, (RF, RF_IF),     rd_rm),
  C3(tansm,	ea08140, 2, (RF, RF_IF),     rd_rm),
  C3(tansz,	ea08160, 2, (RF, RF_IF),     rd_rm),
  C3(tand,	ea08180, 2, (RF, RF_IF),     rd_rm),
  C3(tandp,	ea081a0, 2, (RF, RF_IF),     rd_rm),
  C3(tandm,	ea081c0, 2, (RF, RF_IF),     rd_rm),
  C3(tandz,	ea081e0, 2, (RF, RF_IF),     rd_rm),
  C3(tane,	ea88100, 2, (RF, RF_IF),     rd_rm),
  C3(tanep,	ea88120, 2, (RF, RF_IF),     rd_rm),
  C3(tanem,	ea88140, 2, (RF, RF_IF),     rd_rm),
  C3(tanez,	ea88160, 2, (RF, RF_IF),     rd_rm),

  C3(asns,	eb08100, 2, (RF, RF_IF),     rd_rm),
  C3(asnsp,	eb08120, 2, (RF, RF_IF),     rd_rm),
  C3(asnsm,	eb08140, 2, (RF, RF_IF),     rd_rm),
  C3(asnsz,	eb08160, 2, (RF, RF_IF),     rd_rm),
  C3(asnd,	eb08180, 2, (RF, RF_IF),     rd_rm),
  C3(asndp,	eb081a0, 2, (RF, RF_IF),     rd_rm),
  C3(asndm,	eb081c0, 2, (RF, RF_IF),     rd_rm),
  C3(asndz,	eb081e0, 2, (RF, RF_IF),     rd_rm),
  C3(asne,	eb88100, 2, (RF, RF_IF),     rd_rm),
  C3(asnep,	eb88120, 2, (RF, RF_IF),     rd_rm),
  C3(asnem,	eb88140, 2, (RF, RF_IF),     rd_rm),
  C3(asnez,	eb88160, 2, (RF, RF_IF),     rd_rm),

  C3(acss,	ec08100, 2, (RF, RF_IF),     rd_rm),
  C3(acssp,	ec08120, 2, (RF, RF_IF),     rd_rm),
  C3(acssm,	ec08140, 2, (RF, RF_IF),     rd_rm),
  C3(acssz,	ec08160, 2, (RF, RF_IF),     rd_rm),
  C3(acsd,	ec08180, 2, (RF, RF_IF),     rd_rm),
  C3(acsdp,	ec081a0, 2, (RF, RF_IF),     rd_rm),
  C3(acsdm,	ec081c0, 2, (RF, RF_IF),     rd_rm),
  C3(acsdz,	ec081e0, 2, (RF, RF_IF),     rd_rm),
  C3(acse,	ec88100, 2, (RF, RF_IF),     rd_rm),
  C3(acsep,	ec88120, 2, (RF, RF_IF),     rd_rm),
  C3(acsem,	ec88140, 2, (RF, RF_IF),     rd_rm),
  C3(acsez,	ec88160, 2, (RF, RF_IF),     rd_rm),

  C3(atns,	ed08100, 2, (RF, RF_IF),     rd_rm),
  C3(atnsp,	ed08120, 2, (RF, RF_IF),     rd_rm),
  C3(atnsm,	ed08140, 2, (RF, RF_IF),     rd_rm),
  C3(atnsz,	ed08160, 2, (RF, RF_IF),     rd_rm),
  C3(atnd,	ed08180, 2, (RF, RF_IF),     rd_rm),
  C3(atndp,	ed081a0, 2, (RF, RF_IF),     rd_rm),
  C3(atndm,	ed081c0, 2, (RF, RF_IF),     rd_rm),
  C3(atndz,	ed081e0, 2, (RF, RF_IF),     rd_rm),
  C3(atne,	ed88100, 2, (RF, RF_IF),     rd_rm),
  C3(atnep,	ed88120, 2, (RF, RF_IF),     rd_rm),
  C3(atnem,	ed88140, 2, (RF, RF_IF),     rd_rm),
  C3(atnez,	ed88160, 2, (RF, RF_IF),     rd_rm),

  C3(urds,	ee08100, 2, (RF, RF_IF),     rd_rm),
  C3(urdsp,	ee08120, 2, (RF, RF_IF),     rd_rm),
  C3(urdsm,	ee08140, 2, (RF, RF_IF),     rd_rm),
  C3(urdsz,	ee08160, 2, (RF, RF_IF),     rd_rm),
  C3(urdd,	ee08180, 2, (RF, RF_IF),     rd_rm),
  C3(urddp,	ee081a0, 2, (RF, RF_IF),     rd_rm),
  C3(urddm,	ee081c0, 2, (RF, RF_IF),     rd_rm),
  C3(urddz,	ee081e0, 2, (RF, RF_IF),     rd_rm),
  C3(urde,	ee88100, 2, (RF, RF_IF),     rd_rm),
  C3(urdep,	ee88120, 2, (RF, RF_IF),     rd_rm),
  C3(urdem,	ee88140, 2, (RF, RF_IF),     rd_rm),
  C3(urdez,	ee88160, 2, (RF, RF_IF),     rd_rm),

  C3(nrms,	ef08100, 2, (RF, RF_IF),     rd_rm),
  C3(nrmsp,	ef08120, 2, (RF, RF_IF),     rd_rm),
  C3(nrmsm,	ef08140, 2, (RF, RF_IF),     rd_rm),
  C3(nrmsz,	ef08160, 2, (RF, RF_IF),     rd_rm),
  C3(nrmd,	ef08180, 2, (RF, RF_IF),     rd_rm),
  C3(nrmdp,	ef081a0, 2, (RF, RF_IF),     rd_rm),
  C3(nrmdm,	ef081c0, 2, (RF, RF_IF),     rd_rm),
  C3(nrmdz,	ef081e0, 2, (RF, RF_IF),     rd_rm),
  C3(nrme,	ef88100, 2, (RF, RF_IF),     rd_rm),
  C3(nrmep,	ef88120, 2, (RF, RF_IF),     rd_rm),
  C3(nrmem,	ef88140, 2, (RF, RF_IF),     rd_rm),
  C3(nrmez,	ef88160, 2, (RF, RF_IF),     rd_rm),

  C3(adfs,	e000100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfsp,	e000120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfsm,	e000140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfsz,	e000160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfd,	e000180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfdp,	e0001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfdm,	e0001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfdz,	e0001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfe,	e080100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfep,	e080120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfem,	e080140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(adfez,	e080160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(sufs,	e200100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufsp,	e200120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufsm,	e200140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufsz,	e200160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufd,	e200180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufdp,	e2001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufdm,	e2001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufdz,	e2001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufe,	e280100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufep,	e280120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufem,	e280140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(sufez,	e280160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(rsfs,	e300100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfsp,	e300120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfsm,	e300140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfsz,	e300160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfd,	e300180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfdp,	e3001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfdm,	e3001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfdz,	e3001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfe,	e380100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfep,	e380120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfem,	e380140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rsfez,	e380160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(mufs,	e100100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufsp,	e100120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufsm,	e100140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufsz,	e100160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufd,	e100180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufdp,	e1001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufdm,	e1001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufdz,	e1001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufe,	e180100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufep,	e180120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufem,	e180140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(mufez,	e180160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(dvfs,	e400100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfsp,	e400120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfsm,	e400140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfsz,	e400160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfd,	e400180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfdp,	e4001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfdm,	e4001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfdz,	e4001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfe,	e480100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfep,	e480120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfem,	e480140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(dvfez,	e480160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(rdfs,	e500100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfsp,	e500120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfsm,	e500140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfsz,	e500160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfd,	e500180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfdp,	e5001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfdm,	e5001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfdz,	e5001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfe,	e580100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfep,	e580120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfem,	e580140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rdfez,	e580160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(pows,	e600100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powsp,	e600120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powsm,	e600140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powsz,	e600160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powd,	e600180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powdp,	e6001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powdm,	e6001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powdz,	e6001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powe,	e680100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powep,	e680120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powem,	e680140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(powez,	e680160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(rpws,	e700100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwsp,	e700120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwsm,	e700140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwsz,	e700160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwd,	e700180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwdp,	e7001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwdm,	e7001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwdz,	e7001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwe,	e780100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwep,	e780120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwem,	e780140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rpwez,	e780160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(rmfs,	e800100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfsp,	e800120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfsm,	e800140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfsz,	e800160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfd,	e800180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfdp,	e8001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfdm,	e8001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfdz,	e8001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfe,	e880100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfep,	e880120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfem,	e880140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(rmfez,	e880160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(fmls,	e900100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmlsp,	e900120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmlsm,	e900140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmlsz,	e900160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmld,	e900180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmldp,	e9001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmldm,	e9001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmldz,	e9001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmle,	e980100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmlep,	e980120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmlem,	e980140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fmlez,	e980160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(fdvs,	ea00100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvsp,	ea00120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvsm,	ea00140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvsz,	ea00160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvd,	ea00180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvdp,	ea001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvdm,	ea001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvdz,	ea001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdve,	ea80100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvep,	ea80120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvem,	ea80140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(fdvez,	ea80160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(frds,	eb00100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frdsp,	eb00120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frdsm,	eb00140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frdsz,	eb00160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frdd,	eb00180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frddp,	eb001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frddm,	eb001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frddz,	eb001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frde,	eb80100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frdep,	eb80120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frdem,	eb80140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(frdez,	eb80160, 3, (RF, RF, RF_IF), rd_rn_rm),

  C3(pols,	ec00100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(polsp,	ec00120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(polsm,	ec00140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(polsz,	ec00160, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(pold,	ec00180, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(poldp,	ec001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(poldm,	ec001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(poldz,	ec001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(pole,	ec80100, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(polep,	ec80120, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(polem,	ec80140, 3, (RF, RF, RF_IF), rd_rn_rm),
  C3(polez,	ec80160, 3, (RF, RF, RF_IF), rd_rn_rm),

  CE(cmf,	e90f110, 2, (RF, RF_IF),     fpa_cmp),
 C3E(cmfe,	ed0f110, 2, (RF, RF_IF),     fpa_cmp),
  CE(cnf,	eb0f110, 2, (RF, RF_IF),     fpa_cmp),
 C3E(cnfe,	ef0f110, 2, (RF, RF_IF),     fpa_cmp),

  C3(flts,	e000110, 2, (RF, RR),	     rn_rd),
  C3(fltsp,	e000130, 2, (RF, RR),	     rn_rd),
  C3(fltsm,	e000150, 2, (RF, RR),	     rn_rd),
  C3(fltsz,	e000170, 2, (RF, RR),	     rn_rd),
  C3(fltd,	e000190, 2, (RF, RR),	     rn_rd),
  C3(fltdp,	e0001b0, 2, (RF, RR),	     rn_rd),
  C3(fltdm,	e0001d0, 2, (RF, RR),	     rn_rd),
  C3(fltdz,	e0001f0, 2, (RF, RR),	     rn_rd),
  C3(flte,	e080110, 2, (RF, RR),	     rn_rd),
  C3(fltep,	e080130, 2, (RF, RR),	     rn_rd),
  C3(fltem,	e080150, 2, (RF, RR),	     rn_rd),
  C3(fltez,	e080170, 2, (RF, RR),	     rn_rd),
d7692 3
a7694 18
  /* The implementation of the FIX instruction is broken on some
     assemblers, in that it accepts a precision specifier as well as a
     rounding specifier, despite the fact that this is meaningless.
     To be more compatible, we accept it as well, though of course it
     does not set any bits.  */
  CE(fix,	e100110, 2, (RR, RF),	     rd_rm),
  C3(fixp,	e100130, 2, (RR, RF),	     rd_rm),
  C3(fixm,	e100150, 2, (RR, RF),	     rd_rm),
  C3(fixz,	e100170, 2, (RR, RF),	     rd_rm),
  C3(fixsp,	e100130, 2, (RR, RF),	     rd_rm),
  C3(fixsm,	e100150, 2, (RR, RF),	     rd_rm),
  C3(fixsz,	e100170, 2, (RR, RF),	     rd_rm),
  C3(fixdp,	e100130, 2, (RR, RF),	     rd_rm),
  C3(fixdm,	e100150, 2, (RR, RF),	     rd_rm),
  C3(fixdz,	e100170, 2, (RR, RF),	     rd_rm),
  C3(fixep,	e100130, 2, (RR, RF),	     rd_rm),
  C3(fixem,	e100150, 2, (RR, RF),	     rd_rm),
  C3(fixez,	e100170, 2, (RR, RF),	     rd_rm),
d7696 4
a7699 9
  /* Instructions that were new with the real FPA, call them V2.  */
#undef ARM_VARIANT
#define ARM_VARIANT FPU_FPA_EXT_V2
  CE(lfm,	c100200, 3, (RF, I4b, ADDR), fpa_ldmstm),
  C3(lfmfd,	c900200, 3, (RF, I4b, ADDR), fpa_ldmstm),
  C3(lfmea,	d100200, 3, (RF, I4b, ADDR), fpa_ldmstm),
  CE(sfm,	c000200, 3, (RF, I4b, ADDR), fpa_ldmstm),
  C3(sfmfd,	d000200, 3, (RF, I4b, ADDR), fpa_ldmstm),
  C3(sfmea,	c800200, 3, (RF, I4b, ADDR), fpa_ldmstm),
d7701 4
a7704 35
#undef ARM_VARIANT
#define ARM_VARIANT FPU_VFP_EXT_V1xD  /* VFP V1xD (single precision).  */
  /* Moves and type conversions.  */
  CE(fcpys,	eb00a40, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(fmrs,	e100a10, 2, (RR, RVS),	      vfp_reg_from_sp),
  CE(fmsr,	e000a10, 2, (RVS, RR),	      vfp_sp_from_reg),
  CE(fmstat,	ef1fa10, 0, (),		      noargs),
  CE(fsitos,	eb80ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(fuitos,	eb80a40, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(ftosis,	ebd0a40, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(ftosizs,	ebd0ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(ftouis,	ebc0a40, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(ftouizs,	ebc0ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(fmrx,	ef00a10, 2, (RR, RVC),	      rd_rn),
  CE(fmxr,	ee00a10, 2, (RVC, RR),	      rn_rd),

  /* Memory operations.	 */
  CE(flds,	d100a00, 2, (RVS, ADDR),      vfp_sp_ldst),
  CE(fsts,	d000a00, 2, (RVS, ADDR),      vfp_sp_ldst),
  CE(fldmias,	c900a00, 2, (RRw, VRSLST),    vfp_sp_ldstmia),
  CE(fldmfds,	c900a00, 2, (RRw, VRSLST),    vfp_sp_ldstmia),
  CE(fldmdbs,	d300a00, 2, (RRw, VRSLST),    vfp_sp_ldstmdb),
  CE(fldmeas,	d300a00, 2, (RRw, VRSLST),    vfp_sp_ldstmdb),
  CE(fldmiax,	c900b00, 2, (RRw, VRDLST),    vfp_xp_ldstmia),
  CE(fldmfdx,	c900b00, 2, (RRw, VRDLST),    vfp_xp_ldstmia),
  CE(fldmdbx,	d300b00, 2, (RRw, VRDLST),    vfp_xp_ldstmdb),
  CE(fldmeax,	d300b00, 2, (RRw, VRDLST),    vfp_xp_ldstmdb),
  CE(fstmias,	c800a00, 2, (RRw, VRSLST),    vfp_sp_ldstmia),
  CE(fstmeas,	c800a00, 2, (RRw, VRSLST),    vfp_sp_ldstmia),
  CE(fstmdbs,	d200a00, 2, (RRw, VRSLST),    vfp_sp_ldstmdb),
  CE(fstmfds,	d200a00, 2, (RRw, VRSLST),    vfp_sp_ldstmdb),
  CE(fstmiax,	c800b00, 2, (RRw, VRDLST),    vfp_xp_ldstmia),
  CE(fstmeax,	c800b00, 2, (RRw, VRDLST),    vfp_xp_ldstmia),
  CE(fstmdbx,	d200b00, 2, (RRw, VRDLST),    vfp_xp_ldstmdb),
  CE(fstmfdx,	d200b00, 2, (RRw, VRDLST),    vfp_xp_ldstmdb),
d7706 2
a7707 15
  /* Monadic operations.  */
  CE(fabss,	eb00ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(fnegs,	eb10a40, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(fsqrts,	eb10ac0, 2, (RVS, RVS),	      vfp_sp_monadic),

  /* Dyadic operations.	 */
  CE(fadds,	e300a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
  CE(fsubs,	e300a40, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
  CE(fmuls,	e200a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
  CE(fdivs,	e800a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
  CE(fmacs,	e000a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
  CE(fmscs,	e100a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
  CE(fnmuls,	e200a40, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
  CE(fnmacs,	e000a40, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
  CE(fnmscs,	e100a40, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
d7709 7
a7715 5
  /* Comparisons.  */
  CE(fcmps,	eb40a40, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(fcmpzs,	eb50a40, 1, (RVS),	      vfp_sp_compare_z),
  CE(fcmpes,	eb40ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
  CE(fcmpezs,	eb50ac0, 1, (RVS),	      vfp_sp_compare_z),
d7717 2
a7718 28
#undef ARM_VARIANT
#define ARM_VARIANT FPU_VFP_EXT_V1 /* VFP V1 (Double precision).  */
  /* Moves and type conversions.  */
  CE(fcpyd,	eb00b40, 2, (RVD, RVD),	      rd_rm),
  CE(fcvtds,	eb70ac0, 2, (RVD, RVS),	      vfp_dp_sp_cvt),
  CE(fcvtsd,	eb70bc0, 2, (RVS, RVD),	      vfp_sp_dp_cvt),
  CE(fmdhr,	e200b10, 2, (RVD, RR),	      rn_rd),
  CE(fmdlr,	e000b10, 2, (RVD, RR),	      rn_rd),
  CE(fmrdh,	e300b10, 2, (RR, RVD),	      rd_rn),
  CE(fmrdl,	e100b10, 2, (RR, RVD),	      rd_rn),
  CE(fsitod,	eb80bc0, 2, (RVD, RVS),	      vfp_dp_sp_cvt),
  CE(fuitod,	eb80b40, 2, (RVD, RVS),	      vfp_dp_sp_cvt),
  CE(ftosid,	ebd0b40, 2, (RVS, RVD),	      vfp_sp_dp_cvt),
  CE(ftosizd,	ebd0bc0, 2, (RVS, RVD),	      vfp_sp_dp_cvt),
  CE(ftouid,	ebc0b40, 2, (RVS, RVD),	      vfp_sp_dp_cvt),
  CE(ftouizd,	ebc0bc0, 2, (RVS, RVD),	      vfp_sp_dp_cvt),

  /* Memory operations.	 */
  CE(fldd,	d100b00, 2, (RVD, ADDR),      vfp_dp_ldst),
  CE(fstd,	d000b00, 2, (RVD, ADDR),      vfp_dp_ldst),
  CE(fldmiad,	c900b00, 2, (RRw, VRDLST),    vfp_dp_ldstmia),
  CE(fldmfdd,	c900b00, 2, (RRw, VRDLST),    vfp_dp_ldstmia),
  CE(fldmdbd,	d300b00, 2, (RRw, VRDLST),    vfp_dp_ldstmdb),
  CE(fldmead,	d300b00, 2, (RRw, VRDLST),    vfp_dp_ldstmdb),
  CE(fstmiad,	c800b00, 2, (RRw, VRDLST),    vfp_dp_ldstmia),
  CE(fstmead,	c800b00, 2, (RRw, VRDLST),    vfp_dp_ldstmia),
  CE(fstmdbd,	d200b00, 2, (RRw, VRDLST),    vfp_dp_ldstmdb),
  CE(fstmfdd,	d200b00, 2, (RRw, VRDLST),    vfp_dp_ldstmdb),
d7720 4
a7723 15
  /* Monadic operations.  */
  CE(fabsd,	eb00bc0, 2, (RVD, RVD),	      rd_rm),
  CE(fnegd,	eb10b40, 2, (RVD, RVD),	      rd_rm),
  CE(fsqrtd,	eb10bc0, 2, (RVD, RVD),	      rd_rm),

  /* Dyadic operations.	 */
  CE(faddd,	e300b00, 3, (RVD, RVD, RVD),  rd_rn_rm),
  CE(fsubd,	e300b40, 3, (RVD, RVD, RVD),  rd_rn_rm),
  CE(fmuld,	e200b00, 3, (RVD, RVD, RVD),  rd_rn_rm),
  CE(fdivd,	e800b00, 3, (RVD, RVD, RVD),  rd_rn_rm),
  CE(fmacd,	e000b00, 3, (RVD, RVD, RVD),  rd_rn_rm),
  CE(fmscd,	e100b00, 3, (RVD, RVD, RVD),  rd_rn_rm),
  CE(fnmuld,	e200b40, 3, (RVD, RVD, RVD),  rd_rn_rm),
  CE(fnmacd,	e000b40, 3, (RVD, RVD, RVD),  rd_rn_rm),
  CE(fnmscd,	e100b40, 3, (RVD, RVD, RVD),  rd_rn_rm),
d7725 2
a7726 290
  /* Comparisons.  */
  CE(fcmpd,	eb40b40, 2, (RVD, RVD),	      rd_rm),
  CE(fcmpzd,	eb50b40, 1, (RVD),	      rd),
  CE(fcmped,	eb40bc0, 2, (RVD, RVD),	      rd_rm),
  CE(fcmpezd,	eb50bc0, 1, (RVD),	      rd),

#undef ARM_VARIANT
#define ARM_VARIANT FPU_VFP_EXT_V2
  CE(fmsrr,	c400a10, 3, (VRSLST, RR, RR), vfp_sp2_from_reg2),
  CE(fmrrs,	c500a10, 3, (RR, RR, VRSLST), vfp_reg2_from_sp2),
  CE(fmdrr,	c400b10, 3, (RVD, RR, RR),    rm_rd_rn),
  CE(fmrrd,	c500b10, 3, (RR, RR, RVD),    rd_rn_rm),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_CEXT_XSCALE /* Intel XScale extensions.	 */
  CE(mia,	e200010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
  CE(miaph,	e280010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
  CE(miabb,	e2c0010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
  CE(miabt,	e2d0010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
  CE(miatb,	e2e0010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
  CE(miatt,	e2f0010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
  CE(mar,	c400000, 3, (RXA, RRnpc, RRnpc), xsc_mar),
  CE(mra,	c500000, 3, (RRnpc, RRnpc, RXA), xsc_mra),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_CEXT_IWMMXT /* Intel Wireless MMX technology.  */
  CE(tandcb,	e13f130, 1, (RR),		    iwmmxt_tandorc),
  CE(tandch,	e53f130, 1, (RR),		    iwmmxt_tandorc),
  CE(tandcw,	e93f130, 1, (RR),		    iwmmxt_tandorc),
  CE(tbcstb,	e400010, 2, (RIWR, RR),		    rn_rd),
  CE(tbcsth,	e400050, 2, (RIWR, RR),		    rn_rd),
  CE(tbcstw,	e400090, 2, (RIWR, RR),		    rn_rd),
  CE(textrcb,	e130170, 2, (RR, I7),		    iwmmxt_textrc),
  CE(textrch,	e530170, 2, (RR, I7),		    iwmmxt_textrc),
  CE(textrcw,	e930170, 2, (RR, I7),		    iwmmxt_textrc),
  CE(textrmub,	e100070, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
  CE(textrmuh,	e500070, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
  CE(textrmuw,	e900070, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
  CE(textrmsb,	e100078, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
  CE(textrmsh,	e500078, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
  CE(textrmsw,	e900078, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
  CE(tinsrb,	e600010, 3, (RIWR, RR, I7),	    iwmmxt_tinsr),
  CE(tinsrh,	e600050, 3, (RIWR, RR, I7),	    iwmmxt_tinsr),
  CE(tinsrw,	e600090, 3, (RIWR, RR, I7),	    iwmmxt_tinsr),
  CE(tmcr,	e000110, 2, (RIWC, RR),		    rn_rd),
  CE(tmcrr,	c400000, 3, (RIWR, RR, RR),	    rm_rd_rn),
  CE(tmia,	e200010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
  CE(tmiaph,	e280010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
  CE(tmiabb,	e2c0010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
  CE(tmiabt,	e2d0010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
  CE(tmiatb,	e2e0010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
  CE(tmiatt,	e2f0010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
  CE(tmovmskb,	e100030, 2, (RR, RIWR),		    rd_rn),
  CE(tmovmskh,	e500030, 2, (RR, RIWR),		    rd_rn),
  CE(tmovmskw,	e900030, 2, (RR, RIWR),		    rd_rn),
  CE(tmrc,	e100110, 2, (RR, RIWC),		    rd_rn),
  CE(tmrrc,	c500000, 3, (RR, RR, RIWR),	    rd_rn_rm),
  CE(torcb,	e13f150, 1, (RR),		    iwmmxt_tandorc),
  CE(torch,	e53f150, 1, (RR),		    iwmmxt_tandorc),
  CE(torcw,	e93f150, 1, (RR),		    iwmmxt_tandorc),
  CE(waccb,	e0001c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wacch,	e4001c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(waccw,	e8001c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(waddbss,	e300180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waddb,	e000180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waddbus,	e100180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waddhss,	e700180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waddh,	e400180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waddhus,	e500180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waddwss,	eb00180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waddw,	e800180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waddwus,	e900180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(waligni,	e000020, 4, (RIWR, RIWR, RIWR, I7), iwmmxt_waligni),
  CE(walignr0,	e800020, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(walignr1,	e900020, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(walignr2,	ea00020, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(walignr3,	eb00020, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wand,	e200000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wandn,	e300000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wavg2b,	e800000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wavg2br,	e900000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wavg2h,	ec00000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wavg2hr,	ed00000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpeqb,	e000060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpeqh,	e400060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpeqw,	e800060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpgtub,	e100060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpgtuh,	e500060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpgtuw,	e900060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpgtsb,	e300060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpgtsh,	e700060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wcmpgtsw,	eb00060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wldrb,	c100000, 2, (RIWR, ADDR),	    iwmmxt_wldstbh),
  CE(wldrh,	c500000, 2, (RIWR, ADDR),	    iwmmxt_wldstbh),
  CE(wldrw,	c100100, 2, (RIWR_RIWC, ADDR),	    iwmmxt_wldstw),
  CE(wldrd,	c500100, 2, (RIWR, ADDR),	    iwmmxt_wldstd),
  CE(wmacs,	e600100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmacsz,	e700100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmacu,	e400100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmacuz,	e500100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmadds,	ea00100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmaddu,	e800100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmaxsb,	e200160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmaxsh,	e600160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmaxsw,	ea00160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmaxub,	e000160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmaxuh,	e400160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmaxuw,	e800160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wminsb,	e300160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wminsh,	e700160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wminsw,	eb00160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wminub,	e100160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wminuh,	e500160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wminuw,	e900160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmov,	e000000, 2, (RIWR, RIWR),	    iwmmxt_wmov),
  CE(wmulsm,	e300100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmulsl,	e200100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmulum,	e100100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wmulul,	e000100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wor,	e000000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wpackhss,	e700080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wpackhus,	e500080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wpackwss,	eb00080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wpackwus,	e900080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wpackdss,	ef00080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wpackdus,	ed00080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wrorh,	e700040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wrorhg,	e700148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wrorw,	eb00040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wrorwg,	eb00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wrord,	ef00040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wrordg,	ef00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wsadb,	e000120, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsadbz,	e100120, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsadh,	e400120, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsadhz,	e500120, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wshufh,	e0001e0, 3, (RIWR, RIWR, I255),	    iwmmxt_wshufh),
  CE(wsllh,	e500040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsllhg,	e500148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wsllw,	e900040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsllwg,	e900148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wslld,	ed00040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wslldg,	ed00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wsrah,	e400040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsrahg,	e400148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wsraw,	e800040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsrawg,	e800148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wsrad,	ec00040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsradg,	ec00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wsrlh,	e600040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsrlhg,	e600148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wsrlw,	ea00040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsrlwg,	ea00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wsrld,	ee00040, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsrldg,	ee00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
  CE(wstrb,	c000000, 2, (RIWR, ADDR),	    iwmmxt_wldstbh),
  CE(wstrh,	c400000, 2, (RIWR, ADDR),	    iwmmxt_wldstbh),
  CE(wstrw,	c000100, 2, (RIWR_RIWC, ADDR),	    iwmmxt_wldstw),
  CE(wstrd,	c400100, 2, (RIWR, ADDR),	    iwmmxt_wldstd),
  CE(wsubbss,	e3001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsubb,	e0001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsubbus,	e1001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsubhss,	e7001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsubh,	e4001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsubhus,	e5001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsubwss,	eb001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsubw,	e8001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wsubwus,	e9001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wunpckehub,e0000c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckehuh,e4000c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckehuw,e8000c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckehsb,e2000c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckehsh,e6000c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckehsw,ea000c0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckihb, e1000c0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wunpckihh, e5000c0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wunpckihw, e9000c0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wunpckelub,e0000e0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckeluh,e4000e0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckeluw,e8000e0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckelsb,e2000e0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckelsh,e6000e0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckelsw,ea000e0, 2, (RIWR, RIWR),	    rd_rn),
  CE(wunpckilb, e1000e0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wunpckilh, e5000e0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wunpckilw, e9000e0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wxor,	e100000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
  CE(wzero,	e300000, 1, (RIWR),		    iwmmxt_wzero),

#undef ARM_VARIANT
#define ARM_VARIANT ARM_CEXT_MAVERICK /* Cirrus Maverick instructions.	*/
  CE(cfldrs,	c100400, 2, (RMF, ADDR),	      rd_cpaddr),
  CE(cfldrd,	c500400, 2, (RMD, ADDR),	      rd_cpaddr),
  CE(cfldr32,	c100500, 2, (RMFX, ADDR),	      rd_cpaddr),
  CE(cfldr64,	c500500, 2, (RMDX, ADDR),	      rd_cpaddr),
  CE(cfstrs,	c000400, 2, (RMF, ADDR),	      rd_cpaddr),
  CE(cfstrd,	c400400, 2, (RMD, ADDR),	      rd_cpaddr),
  CE(cfstr32,	c000500, 2, (RMFX, ADDR),	      rd_cpaddr),
  CE(cfstr64,	c400500, 2, (RMDX, ADDR),	      rd_cpaddr),
  CE(cfmvsr,	e000450, 2, (RMF, RR),		      rn_rd),
  CE(cfmvrs,	e100450, 2, (RR, RMF),		      rd_rn),
  CE(cfmvdlr,	e000410, 2, (RMD, RR),		      rn_rd),
  CE(cfmvrdl,	e100410, 2, (RR, RMD),		      rd_rn),
  CE(cfmvdhr,	e000430, 2, (RMD, RR),		      rn_rd),
  CE(cfmvrdh,	e100430, 2, (RR, RMD),		      rd_rn),
  CE(cfmv64lr,	e000510, 2, (RMDX, RR),		      rn_rd),
  CE(cfmvr64l,	e100510, 2, (RR, RMDX),		      rd_rn),
  CE(cfmv64hr,	e000530, 2, (RMDX, RR),		      rn_rd),
  CE(cfmvr64h,	e100530, 2, (RR, RMDX),		      rd_rn),
  CE(cfmval32,	e200440, 2, (RMAX, RMFX),	      rd_rn),
  CE(cfmv32al,	e100440, 2, (RMFX, RMAX),	      rd_rn),
  CE(cfmvam32,	e200460, 2, (RMAX, RMFX),	      rd_rn),
  CE(cfmv32am,	e100460, 2, (RMFX, RMAX),	      rd_rn),
  CE(cfmvah32,	e200480, 2, (RMAX, RMFX),	      rd_rn),
  CE(cfmv32ah,	e100480, 2, (RMFX, RMAX),	      rd_rn),
  CE(cfmva32,	e2004a0, 2, (RMAX, RMFX),	      rd_rn),
  CE(cfmv32a,	e1004a0, 2, (RMFX, RMAX),	      rd_rn),
  CE(cfmva64,	e2004c0, 2, (RMAX, RMDX),	      rd_rn),
  CE(cfmv64a,	e1004c0, 2, (RMDX, RMAX),	      rd_rn),
  CE(cfmvsc32,	e2004e0, 2, (RMDS, RMDX),	      mav_dspsc),
  CE(cfmv32sc,	e1004e0, 2, (RMDX, RMDS),	      rd),
  CE(cfcpys,	e000400, 2, (RMF, RMF),		      rd_rn),
  CE(cfcpyd,	e000420, 2, (RMD, RMD),		      rd_rn),
  CE(cfcvtsd,	e000460, 2, (RMD, RMF),		      rd_rn),
  CE(cfcvtds,	e000440, 2, (RMF, RMD),		      rd_rn),
  CE(cfcvt32s,	e000480, 2, (RMF, RMFX),	      rd_rn),
  CE(cfcvt32d,	e0004a0, 2, (RMD, RMFX),	      rd_rn),
  CE(cfcvt64s,	e0004c0, 2, (RMF, RMDX),	      rd_rn),
  CE(cfcvt64d,	e0004e0, 2, (RMD, RMDX),	      rd_rn),
  CE(cfcvts32,	e100580, 2, (RMFX, RMF),	      rd_rn),
  CE(cfcvtd32,	e1005a0, 2, (RMFX, RMD),	      rd_rn),
  CE(cftruncs32,e1005c0, 2, (RMFX, RMF),	      rd_rn),
  CE(cftruncd32,e1005e0, 2, (RMFX, RMD),	      rd_rn),
  CE(cfrshl32,	e000550, 3, (RMFX, RMFX, RR),	      mav_triple),
  CE(cfrshl64,	e000570, 3, (RMDX, RMDX, RR),	      mav_triple),
  CE(cfsh32,	e000500, 3, (RMFX, RMFX, I63s),	      mav_shift),
  CE(cfsh64,	e200500, 3, (RMDX, RMDX, I63s),	      mav_shift),
  CE(cfcmps,	e100490, 3, (RR, RMF, RMF),	      rd_rn_rm),
  CE(cfcmpd,	e1004b0, 3, (RR, RMD, RMD),	      rd_rn_rm),
  CE(cfcmp32,	e100590, 3, (RR, RMFX, RMFX),	      rd_rn_rm),
  CE(cfcmp64,	e1005b0, 3, (RR, RMDX, RMDX),	      rd_rn_rm),
  CE(cfabss,	e300400, 2, (RMF, RMF),		      rd_rn),
  CE(cfabsd,	e300420, 2, (RMD, RMD),		      rd_rn),
  CE(cfnegs,	e300440, 2, (RMF, RMF),		      rd_rn),
  CE(cfnegd,	e300460, 2, (RMD, RMD),		      rd_rn),
  CE(cfadds,	e300480, 3, (RMF, RMF, RMF),	      rd_rn_rm),
  CE(cfaddd,	e3004a0, 3, (RMD, RMD, RMD),	      rd_rn_rm),
  CE(cfsubs,	e3004c0, 3, (RMF, RMF, RMF),	      rd_rn_rm),
  CE(cfsubd,	e3004e0, 3, (RMD, RMD, RMD),	      rd_rn_rm),
  CE(cfmuls,	e100400, 3, (RMF, RMF, RMF),	      rd_rn_rm),
  CE(cfmuld,	e100420, 3, (RMD, RMD, RMD),	      rd_rn_rm),
  CE(cfabs32,	e300500, 2, (RMFX, RMFX),	      rd_rn),
  CE(cfabs64,	e300520, 2, (RMDX, RMDX),	      rd_rn),
  CE(cfneg32,	e300540, 2, (RMFX, RMFX),	      rd_rn),
  CE(cfneg64,	e300560, 2, (RMDX, RMDX),	      rd_rn),
  CE(cfadd32,	e300580, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
  CE(cfadd64,	e3005a0, 3, (RMDX, RMDX, RMDX),	      rd_rn_rm),
  CE(cfsub32,	e3005c0, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
  CE(cfsub64,	e3005e0, 3, (RMDX, RMDX, RMDX),	      rd_rn_rm),
  CE(cfmul32,	e100500, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
  CE(cfmul64,	e100520, 3, (RMDX, RMDX, RMDX),	      rd_rn_rm),
  CE(cfmac32,	e100540, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
  CE(cfmsc32,	e100560, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
  CE(cfmadd32,	e000600, 4, (RMAX, RMFX, RMFX, RMFX), mav_quad),
  CE(cfmsub32,	e100600, 4, (RMAX, RMFX, RMFX, RMFX), mav_quad),
  CE(cfmadda32, e200600, 4, (RMAX, RMAX, RMFX, RMFX), mav_quad),
  CE(cfmsuba32, e300600, 4, (RMAX, RMAX, RMFX, RMFX), mav_quad),
};
#undef ARM_VARIANT
#undef THUMB_VARIANT
#undef TCE
#undef TCM
#undef TUE
#undef TUF
#undef TCC
#undef CE
#undef CM
#undef UE
#undef UF
#undef UT
#undef OPS0
#undef OPS1
#undef OPS2
#undef OPS3
#undef OPS4
#undef OPS5
#undef OPS6
#undef do_0

/* MD interface: bits in the object file.  */
d7728 7
a7734 6
/* Turn an integer of n bytes (in val) into a stream of bytes appropriate
   for use in the a.out file, and stores them in the array pointed to by buf.
   This knows about the endian-ness of the target machine and does
   THE RIGHT THING, whatever it is.  Possible values for n are 1 (byte)
   2 (short) and 4 (long)  Floating numbers are put out as a series of
   LITTLENUMS (shorts, here at least).	*/
d7736 1
a7736 7
void
md_number_to_chars (char * buf, valueT val, int n)
{
  if (target_big_endian)
    number_to_chars_bigendian (buf, val, n);
  else
    number_to_chars_littleendian (buf, val, n);
d7739 2
a7740 2
static valueT
md_chars_to_number (char * buf, int n)
d7742 4
a7745 2
  valueT result = 0;
  unsigned char * where = (unsigned char *) buf;
d7747 4
a7750 1
  if (target_big_endian)
d7752 3
a7754 5
      while (n--)
	{
	  result <<= 8;
	  result |= (*where++ & 255);
	}
d7756 16
a7771 1
  else
d7773 3
a7775 5
      while (n--)
	{
	  result <<= 8;
	  result |= (where[n] & 255);
	}
d7778 1
a7778 1
  return result;
d7781 15
a7795 1
/* MD interface: Sections.  */
d7797 1
a7797 6
int
md_estimate_size_before_relax (fragS * fragP ATTRIBUTE_UNUSED,
			       segT    segtype ATTRIBUTE_UNUSED)
{
  as_fatal (_("md_estimate_size_before_relax\n"));
  return 1;
d7800 3
a7802 1
/* Round up a section size to the appropriate boundary.	 */
d7804 2
a7805 3
valueT
md_section_align (segT	 segment ATTRIBUTE_UNUSED,
		  valueT size)
d7807 8
a7814 7
#ifdef OBJ_ELF
  return size;
#else
  /* Round all sects to multiple of 4.	*/
  return (size + 3) & ~3;
#endif
}
d7816 2
a7817 2
/* This is called from HANDLE_ALIGN in write.c.	 Fill in the contents
   of an rs_align_code fragment.  */
d7819 2
a7820 7
void
arm_handle_align (fragS * fragP)
{
  static char const arm_noop[4] = { 0x00, 0x00, 0xa0, 0xe1 };
  static char const thumb_noop[2] = { 0xc0, 0x46 };
  static char const arm_bigend_noop[4] = { 0xe1, 0xa0, 0x00, 0x00 };
  static char const thumb_bigend_noop[2] = { 0x46, 0xc0 };
d7822 1
a7822 15
  int bytes, fix, noop_size;
  char * p;
  const char * noop;

  if (fragP->fr_type != rs_align_code)
    return;

  bytes = fragP->fr_next->fr_address - fragP->fr_address - fragP->fr_fix;
  p = fragP->fr_literal + fragP->fr_fix;
  fix = 0;

  if (bytes > MAX_MEM_FOR_RS_ALIGN_CODE)
    bytes &= MAX_MEM_FOR_RS_ALIGN_CODE;

  if (fragP->tc_frag_data)
d7824 2
a7825 5
      if (target_big_endian)
	noop = thumb_bigend_noop;
      else
	noop = thumb_noop;
      noop_size = sizeof (thumb_noop);
d7829 2
a7830 5
      if (target_big_endian)
	noop = arm_bigend_noop;
      else
	noop = arm_noop;
      noop_size = sizeof (arm_noop);
d7833 3
a7835 1
  if (bytes & (noop_size - 1))
d7837 9
a7845 5
      fix = bytes & (noop_size - 1);
      memset (p, 0, fix);
      p += fix;
      bytes -= fix;
    }
d7847 5
a7851 7
  while (bytes >= noop_size)
    {
      memcpy (p, noop, noop_size);
      p += noop_size;
      bytes -= noop_size;
      fix += noop_size;
    }
d7853 5
a7857 3
  fragP->fr_fix += fix;
  fragP->fr_var = noop_size;
}
d7859 2
a7860 2
/* Called from md_do_align.  Used to create an alignment
   frag in a code section.  */
d7862 1
a7862 4
void
arm_frag_align_code (int n, int max)
{
  char * p;
d7864 3
a7866 4
  /* We assume that there will never be a requirement
     to support alignments greater than 32 bytes.  */
  if (max > MAX_MEM_FOR_RS_ALIGN_CODE)
    as_fatal (_("alignments greater than 32 bytes not supported in .text sections."));
d7868 1
a7868 9
  p = frag_var (rs_align_code,
		MAX_MEM_FOR_RS_ALIGN_CODE,
		1,
		(relax_substateT) max,
		(symbolS *) NULL,
		(offsetT) n,
		(char *) NULL);
  *p = 0;
}
d7870 7
a7876 1
/* Perform target specific initialisation of a frag.  */
d7878 5
a7882 6
void
arm_init_frag (fragS * fragP)
{
  /* Record whether this frag is in an ARM or a THUMB area.  */
  fragP->tc_frag_data = thumb_mode;
}
d7884 7
a7890 2
#ifdef OBJ_ELF
/* When we change sections we need to issue a new mapping symbol.  */
d7892 6
a7897 5
void
arm_elf_change_section (void)
{
  flagword flags;
  segment_info_type *seginfo;
d7899 1
a7899 4
  /* Link an unlinked unwind index table section to the .text section.	*/
  if (elf_section_type (now_seg) == SHT_ARM_EXIDX
      && elf_linked_to_section (now_seg) == NULL)
    elf_linked_to_section (now_seg) = text_section;
d7901 3
a7903 2
  if (!SEG_NORMAL (now_seg))
    return;
d7905 1
a7905 1
  flags = bfd_get_section_flags (stdoutput, now_seg);
d7907 10
a7916 3
  /* We can ignore sections that only contain debug info.  */
  if ((flags & SEC_ALLOC) == 0)
    return;
d7918 1
a7918 3
  seginfo = seg_info (now_seg);
  mapstate = seginfo->tc_segment_info_data.mapstate;
  marked_pr_dependency = seginfo->tc_segment_info_data.marked_pr_dependency;
d7921 2
a7922 2
int
arm_elf_section_type (const char * str, size_t len)
d7924 3
a7926 2
  if (len == 5 && strncmp (str, "exidx", 5) == 0)
    return SHT_ARM_EXIDX;
d7928 9
a7936 4
  return -1;
}

/* Code to deal with unwinding tables.	*/
d7938 7
a7944 1
static void add_unwind_adjustsp (offsetT);
d7946 2
a7947 1
/* Cenerate and deferred unwind frame offset.  */
d7950 1
a7950 1
flush_pending_unwind (void)
d7952 12
a7963 1
  offsetT offset;
d7965 1
a7965 4
  offset = unwind.pending_offset;
  unwind.pending_offset = 0;
  if (offset != 0)
    add_unwind_adjustsp (offset);
a7967 4
/* Add an opcode to this list for this function.  Two-byte opcodes should
   be passed as op[0] << 8 | op[1].  The list of opcodes is built in reverse
   order.  */

d7969 1
a7969 1
add_unwind_opcode (valueT op, int length)
d7971 1
a7971 3
  /* Add any deferred stack adjustment.	 */
  if (unwind.pending_offset)
    flush_pending_unwind ();
d7973 1
a7973 1
  unwind.sp_restored = 0;
d7975 2
a7976 1
  if (unwind.opcode_count + length > unwind.opcode_alloc)
d7978 2
a7979 6
      unwind.opcode_alloc += ARM_OPCODE_CHUNK_SIZE;
      if (unwind.opcodes)
	unwind.opcodes = xrealloc (unwind.opcodes,
				   unwind.opcode_alloc);
      else
	unwind.opcodes = xmalloc (unwind.opcode_alloc);
d7981 6
a7986 1
  while (length > 0)
d7988 3
a7990 4
      length--;
      unwind.opcodes[unwind.opcode_count] = op & 0xff;
      op >>= 8;
      unwind.opcode_count++;
d7992 2
a7995 2
/* Add unwind opcodes to adjust the stack pointer.  */

d7997 1
a7997 1
add_unwind_adjustsp (offsetT offset)
d7999 4
a8002 1
  valueT op;
d8004 2
a8005 1
  if (offset > 0x200)
d8007 4
a8010 4
      /* We need at most 5 bytes to hold a 32-bit value in a uleb128.  */
      char bytes[5];
      int n;
      valueT o;
d8012 2
a8013 6
      /* Long form: 0xb2, uleb128.  */
      /* This might not fit in a word so add the individual bytes,
	 remembering the list is built in reverse order.  */
      o = (valueT) ((offset - 0x204) >> 2);
      if (o == 0)
	add_unwind_opcode (0, 1);
d8015 12
a8026 16
      /* Calculate the uleb128 encoding of the offset.	*/
      n = 0;
      while (o)
	{
	  bytes[n] = o & 0x7f;
	  o >>= 7;
	  if (o)
	    bytes[n] |= 0x80;
	  n++;
	}
      /* Add the insn.	*/
      for (; n; n--)
	add_unwind_opcode (bytes[n - 1], 1);
      add_unwind_opcode (0xb2, 1);
    }
  else if (offset > 0x100)
d8028 3
a8030 21
      /* Two short opcodes.  */
      add_unwind_opcode (0x3f, 1);
      op = (offset - 0x104) >> 2;
      add_unwind_opcode (op, 1);
    }
  else if (offset > 0)
    {
      /* Short opcode.	*/
      op = (offset - 4) >> 2;
      add_unwind_opcode (op, 1);
    }
  else if (offset < 0)
    {
      offset = -offset;
      while (offset > 0x100)
	{
	  add_unwind_opcode (0x7f, 1);
	  offset -= 0x100;
	}
      op = ((offset - 4) >> 2) | 0x40;
      add_unwind_opcode (op, 1);
d8032 2
a8035 1
/* Finish the list of unwind opcodes for this function.	 */
d8037 1
a8037 1
finish_unwind_opcodes (void)
d8039 4
a8042 1
  valueT op;
d8044 2
a8045 1
  if (unwind.fp_used)
d8047 4
a8050 3
      /* Adjust sp as neccessary.  */
      unwind.pending_offset += unwind.fp_offset - unwind.frame_size;
      flush_pending_unwind ();
d8052 1
a8052 6
      /* After restoring sp from the frame pointer.  */
      op = 0x90 | unwind.fp_reg;
      add_unwind_opcode (op, 1);
    }
  else
    flush_pending_unwind ();
a8054 4

/* Start an exception table entry.  If idx is nonzero this is an index table
   entry.  */

d8056 1
a8056 1
start_unwind_section (const segT text_seg, int idx)
d8058 4
a8061 11
  const char * text_name;
  const char * prefix;
  const char * prefix_once;
  const char * group_name;
  size_t prefix_len;
  size_t text_len;
  char * sec_name;
  size_t sec_name_len;
  int type;
  int flags;
  int linkonce;
d8063 4
a8066 1
  if (idx)
d8068 3
a8070 3
      prefix = ELF_STRING_ARM_unwind;
      prefix_once = ELF_STRING_ARM_unwind_once;
      type = SHT_ARM_EXIDX;
d8072 16
a8087 1
  else
d8089 1
a8089 3
      prefix = ELF_STRING_ARM_unwind_info;
      prefix_once = ELF_STRING_ARM_unwind_info_once;
      type = SHT_PROGBITS;
d8091 1
d8093 2
a8094 3
  text_name = segment_name (text_seg);
  if (streq (text_name, ".text"))
    text_name = "";
d8096 3
a8098 2
  if (strncmp (text_name, ".gnu.linkonce.t.",
	       strlen (".gnu.linkonce.t.")) == 0)
d8100 6
a8105 2
      prefix = prefix_once;
      text_name += strlen (".gnu.linkonce.t.");
d8108 9
a8116 7
  prefix_len = strlen (prefix);
  text_len = strlen (text_name);
  sec_name_len = prefix_len + text_len;
  sec_name = xmalloc (sec_name_len + 1);
  memcpy (sec_name, prefix, prefix_len);
  memcpy (sec_name + prefix_len, text_name, text_len);
  sec_name[prefix_len + text_len] = '\0';
d8118 1
a8118 3
  flags = SHF_ALLOC;
  linkonce = 0;
  group_name = 0;
d8120 1
a8120 2
  /* Handle COMDAT group.  */
  if (prefix != prefix_once && (text_seg->flags & SEC_LINK_ONCE) != 0)
d8122 2
a8123 10
      group_name = elf_group_name (text_seg);
      if (group_name == NULL)
	{
	  as_bad ("Group section `%s' has no group signature",
		  segment_name (text_seg));
	  ignore_rest_of_line ();
	  return;
	}
      flags |= SHF_GROUP;
      linkonce = 1;
d8126 1
a8126 1
  obj_elf_change_section (sec_name, type, flags, 0, group_name, linkonce, 0);
d8128 2
a8129 3
  /* Set the setion link for index tables.  */
  if (idx)
    elf_linked_to_section (now_seg) = text_seg;
d8132 4
d8137 2
a8138 3
/* Start an unwind table entry.	 HAVE_DATA is nonzero if we have additional
   personality routine data.  Returns zero, or the index table value for
   and inline entry.  */
d8140 7
a8146 10
static valueT
create_unwind_entry (int have_data)
{
  int size;
  addressT where;
  char *ptr;
  /* The current word of data.	*/
  valueT data;
  /* The number of bytes left in this word.  */
  int n;
d8148 2
a8149 1
  finish_unwind_opcodes ();
d8151 4
a8154 3
  /* Remember the current text section.	 */
  unwind.saved_seg = now_seg;
  unwind.saved_subseg = now_subseg;
d8156 2
a8157 1
  start_unwind_section (now_seg, 0);
d8159 2
a8160 1
  if (unwind.personality_routine == NULL)
d8162 4
a8165 6
      if (unwind.personality_index == -2)
	{
	  if (have_data)
	    as_bad (_("handerdata in cantunwind frame"));
	  return 1; /* EXIDX_CANTUNWIND.  */
	}
d8167 2
a8168 8
      /* Use a default personality routine if none is specified.  */
      if (unwind.personality_index == -1)
	{
	  if (unwind.opcode_count > 3)
	    unwind.personality_index = 1;
	  else
	    unwind.personality_index = 0;
	}
d8170 4
a8173 5
      /* Space for the personality routine entry.  */
      if (unwind.personality_index == 0)
	{
	  if (unwind.opcode_count > 3)
	    as_bad (_("too many unwind opcodes for personality routine 0"));
d8175 6
a8180 11
	  if (!have_data)
	    {
	      /* All the data is inline in the index table.  */
	      data = 0x80;
	      n = 3;
	      while (unwind.opcode_count > 0)
		{
		  unwind.opcode_count--;
		  data = (data << 8) | unwind.opcodes[unwind.opcode_count];
		  n--;
		}
d8182 6
a8187 11
	      /* Pad with "finish" opcodes.  */
	      while (n--)
		data = (data << 8) | 0xb0;

	      return data;
	    }
	  size = 0;
	}
      else
	/* We get two opcodes "free" in the first word.	 */
	size = unwind.opcode_count - 2;
a8188 3
  else
    /* An extra byte is required for the opcode count.	*/
    size = unwind.opcode_count + 1;
d8190 2
a8191 3
  size = (size + 3) >> 2;
  if (size > 0xff)
    as_bad (_("too many unwind opcodes"));
d8193 4
a8196 3
  frag_align (2, 0, 0);
  record_alignment (now_seg, 2);
  unwind.table_entry = expr_build_dot ();
d8198 6
a8203 3
  /* Allocate the table entry.	*/
  ptr = frag_more ((size << 2) + 4);
  where = frag_now_fix () - ((size << 2) + 4);
d8205 2
a8206 1
  switch (unwind.personality_index)
d8208 7
a8214 5
    case -1:
      /* ??? Should this be a PLT generating relocation?  */
      /* Custom personality routine.  */
      fix_new (frag_now, where, 4, unwind.personality_routine, 0, 1,
	       BFD_RELOC_ARM_PREL31);
a8215 2
      where += 4;
      ptr += 4;
d8217 5
a8221 4
      /* Set the first byte to the number of additional words.	*/
      data = size - 1;
      n = 3;
      break;
d8223 1
a8223 6
    /* ABI defined personality routines.  */
    case 0:
      /* Three opcodes bytes are packed into the first word.  */
      data = 0x80;
      n = 3;
      break;
d8225 2
a8226 6
    case 1:
    case 2:
      /* The size and first two opcode bytes go in the first word.  */
      data = ((0x80 + unwind.personality_index) << 8) | size;
      n = 2;
      break;
d8228 11
a8238 3
    default:
      /* Should never happen.  */
      abort ();
d8241 2
a8242 3
  /* Pack the opcodes into words (MSB first), reversing the list at the same
     time.  */
  while (unwind.opcode_count > 0)
d8244 3
a8246 10
      if (n == 0)
	{
	  md_number_to_chars (ptr, data, 4);
	  ptr += 4;
	  n = 4;
	  data = 0;
	}
      unwind.opcode_count--;
      n--;
      data = (data << 8) | unwind.opcodes[unwind.opcode_count];
d8248 18
d8267 6
a8272 2
  /* Finish off the last word.	*/
  if (n < 4)
d8274 2
a8275 5
      /* Pad with "finish" opcodes.  */
      while (n--)
	data = (data << 8) | 0xb0;

      md_number_to_chars (ptr, data, 4);
d8278 2
a8279 1
  if (!have_data)
d8281 3
a8283 3
      /* Add an empty descriptor if there is no user-specified data.   */
      ptr = frag_more (4);
      md_number_to_chars (ptr, 0, 4);
d8286 6
a8291 1
  return 0;
d8294 5
a8298 1
/* Convert REGNAME to a DWARF-2 register number.  */
d8300 2
a8301 2
int
tc_arm_regname_to_dw2regnum (const char *regname)
d8303 2
a8304 1
  int reg = arm_reg_parse ((char **) &regname, REG_TYPE_RN);
d8306 5
a8310 2
  if (reg == FAIL)
    return -1;
d8312 4
a8315 1
  return reg;
d8318 5
a8322 1
/* Initialize the DWARF-2 unwind information for this procedure.  */
d8324 2
a8325 2
void
tc_arm_frame_initial_instructions (void)
d8327 1
a8327 1
  cfi_add_CFA_def_cfa (REG_SP, 0);
a8328 1
#endif /* OBJ_ELF */
d8330 4
d8335 6
a8340 1
/* MD interface: Symbol and relocation handling.  */
d8342 2
a8343 2
/* The knowledge of the PC's pipeline offset is built into the insns
   themselves.	*/
d8345 2
a8346 2
long
md_pcrel_from (fixS * fixP)
d8348 1
a8348 4
  if (fixP->fx_addsy
      && S_GET_SEGMENT (fixP->fx_addsy) == undefined_section
      && fixP->fx_subsy == NULL)
    return 0;
d8350 1
a8350 5
  /* PC relative addressing on the Thumb is slightly odd as the bottom
     two bits of the PC are forced to zero for the calculation.  This
     happens *after* application of the pipeline offset.  However,
     Thumb adrl already adjusts for this, so we need not do it again.  */
  switch (fixP->fx_r_type)
d8352 3
a8354 9
    case BFD_RELOC_ARM_THUMB_ADD:
      return (fixP->fx_where + fixP->fx_frag->fr_address) & ~3;

    case BFD_RELOC_ARM_THUMB_OFFSET:
    case BFD_RELOC_ARM_T32_OFFSET_IMM:
      return (fixP->fx_where + fixP->fx_frag->fr_address + 4) & ~3;

    default:
      break;
d8357 1
a8357 7
#ifdef TE_WINCE
  /* The pattern was adjusted to accommodate CE's off-by-one fixups,
     so we un-adjust here to compensate for the accommodation.	*/
  return fixP->fx_where + fixP->fx_frag->fr_address + 8;
#else
  return fixP->fx_where + fixP->fx_frag->fr_address;
#endif
d8360 2
a8361 5
/* Under ELF we need to default _GLOBAL_OFFSET_TABLE.
   Otherwise we have no need to default values of symbols.  */

symbolS *
md_undefined_symbol (char * name ATTRIBUTE_UNUSED)
d8363 1
a8363 8
#ifdef OBJ_ELF
  if (name[0] == '_' && name[1] == 'G'
      && streq (name, GLOBAL_OFFSET_TABLE_NAME))
    {
      if (!GOT_symbol)
	{
	  if (symbol_find (name))
	    as_bad ("GOT already in the symbol table");
d8365 2
a8366 3
	  GOT_symbol = symbol_new (name, undefined_section,
				   (valueT) 0, & zero_address_frag);
	}
d8368 6
a8373 1
      return GOT_symbol;
a8374 1
#endif
d8376 1
a8376 1
  return 0;
d8379 2
a8380 8
/* Subroutine of md_apply_fix3.	 Check to see if an immediate can be
   computed as two separate immediate values, added together.  We
   already know that this value cannot be computed by just one ARM
   instruction.	 */

static unsigned int
validate_immediate_twopart (unsigned int   val,
			    unsigned int * highpart)
d8382 1
a8382 2
  unsigned int a;
  unsigned int i;
d8384 2
a8385 20
  for (i = 0; i < 32; i += 2)
    if (((a = rotate_left (val, i)) & 0xff) != 0)
      {
	if (a & 0xff00)
	  {
	    if (a & ~ 0xffff)
	      continue;
	    * highpart = (a  >> 8) | ((i + 24) << 7);
	  }
	else if (a & 0xff0000)
	  {
	    if (a & 0xff000000)
	      continue;
	    * highpart = (a >> 16) | ((i + 16) << 7);
	  }
	else
	  {
	    assert (a & 0xff000000);
	    * highpart = (a >> 24) | ((i + 8) << 7);
	  }
d8387 7
a8393 2
	return (a & 0xff) | (i << 7);
      }
d8395 1
a8395 1
  return FAIL;
d8398 1
a8398 7
static int
validate_offset_imm (unsigned int val, int hwse)
{
  if ((hwse && val > 255) || val > 4095)
    return FAIL;
  return val;
}
d8400 2
a8401 10
/* Subroutine of md_apply_fix3.	 Do those data_ops which can take a
   negative immediate constant by altering the instruction.  A bit of
   a hack really.
	MOV <-> MVN
	AND <-> BIC
	ADC <-> SBC
	by inverting the second operand, and
	ADD <-> SUB
	CMP <-> CMN
	by negating the second operand.	 */
d8403 2
a8404 3
static int
negate_data_op (unsigned long * instruction,
		unsigned long	value)
d8406 1
a8406 2
  int op, new_inst;
  unsigned long negated, inverted;
d8408 1
a8408 2
  negated = encode_arm_immediate (-value);
  inverted = encode_arm_immediate (~value);
d8410 2
a8411 2
  op = (*instruction >> DATA_OP_SHIFT) & 0xf;
  switch (op)
d8413 4
a8416 5
      /* First negates.	 */
    case OPCODE_SUB:		 /* ADD <-> SUB	 */
      new_inst = OPCODE_ADD;
      value = negated;
      break;
d8418 11
a8428 4
    case OPCODE_ADD:
      new_inst = OPCODE_SUB;
      value = negated;
      break;
d8430 16
a8445 4
    case OPCODE_CMP:		 /* CMP <-> CMN	 */
      new_inst = OPCODE_CMN;
      value = negated;
      break;
d8447 12
a8458 4
    case OPCODE_CMN:
      new_inst = OPCODE_CMP;
      value = negated;
      break;
d8460 6
a8465 5
      /* Now Inverted ops.  */
    case OPCODE_MOV:		 /* MOV <-> MVN	 */
      new_inst = OPCODE_MVN;
      value = inverted;
      break;
d8467 14
a8480 4
    case OPCODE_MVN:
      new_inst = OPCODE_MOV;
      value = inverted;
      break;
d8482 8
a8489 4
    case OPCODE_AND:		 /* AND <-> BIC	 */
      new_inst = OPCODE_BIC;
      value = inverted;
      break;
d8491 14
a8504 4
    case OPCODE_BIC:
      new_inst = OPCODE_AND;
      value = inverted;
      break;
d8506 4
a8509 4
    case OPCODE_ADC:		  /* ADC <-> SBC  */
      new_inst = OPCODE_SBC;
      value = inverted;
      break;
d8511 11
a8521 4
    case OPCODE_SBC:
      new_inst = OPCODE_ADC;
      value = inverted;
      break;
d8523 43
a8565 3
      /* We cannot do anything.	 */
    default:
      return FAIL;
d8568 1
a8568 6
  if (value == (unsigned) FAIL)
    return FAIL;

  *instruction &= OPCODE_MASK;
  *instruction |= new_inst << DATA_OP_SHIFT;
  return value;
d8571 2
a8572 4
void
md_apply_fix3 (fixS *	fixP,
	       valueT * valP,
	       segT	seg)
d8574 1
a8574 6
  offsetT	 value = * valP;
  offsetT	 newval;
  unsigned int	 newimm;
  unsigned long	 temp;
  int		 sign;
  char *	 buf = fixP->fx_where + fixP->fx_frag->fr_literal;
d8576 1
a8576 1
  assert (fixP->fx_r_type <= BFD_RELOC_UNUSED);
d8578 7
a8584 3
  /* Note whether this will delete the relocation.  */
  if (fixP->fx_addsy == 0 && !fixP->fx_pcrel)
    fixP->fx_done = 1;
d8586 1
a8586 4
  /* If this symbol is in a different section then we need to leave it for
     the linker to deal with.  Unfortunately, md_pcrel_from can't tell,
     so we have to undo its effects here.  */
  if (fixP->fx_pcrel)
d8588 5
a8592 4
      if (fixP->fx_addsy != NULL
	  && S_IS_DEFINED (fixP->fx_addsy)
	  && S_GET_SEGMENT (fixP->fx_addsy) != seg)
	value += md_pcrel_from (fixP);
d8594 4
d8599 16
a8614 9
  /* On a 64-bit host, silently truncate 'value' to 32 bits for
     consistency with the behavior on 32-bit hosts.  Remember value
     for emit_reloc.  */
  value &= 0xffffffff;
  value ^= 0x80000000;
  value -= 0x80000000; 

  *valP = value;
  fixP->fx_addnumber = value;
d8616 2
a8617 4
  /* Same treatment for fixP->fx_offset.  */
  fixP->fx_offset &= 0xffffffff;
  fixP->fx_offset ^= 0x80000000;
  fixP->fx_offset -= 0x80000000;
d8619 1
a8619 1
  switch (fixP->fx_r_type)
d8621 5
a8625 4
    case BFD_RELOC_NONE:
      /* This will need to go in the object file.  */
      fixP->fx_done = 0;
      break;
d8627 6
a8632 5
    case BFD_RELOC_ARM_IMMEDIATE:
      /* We claim that this fixup has been processed here,
	 even if in fact we generate an error because we do
	 not have a reloc for it, so tc_gen_reloc will reject it.  */
      fixP->fx_done = 1;
d8634 5
a8638 2
      if (fixP->fx_addsy
	  && ! S_IS_DEFINED (fixP->fx_addsy))
d8640 3
a8642 4
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("undefined symbol %s used as an immediate value"),
			S_GET_NAME (fixP->fx_addsy));
	  break;
d8645 1
a8645 7
      newimm = encode_arm_immediate (value);
      temp = md_chars_to_number (buf, INSN_SIZE);

      /* If the instruction will fail, see if we can fix things up by
	 changing the opcode.  */
      if (newimm == (unsigned int) FAIL
	  && (newimm = negate_data_op (&temp, value)) == (unsigned int) FAIL)
d8647 3
a8649 4
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("invalid constant (%lx) after fixup"),
			(unsigned long) value);
	  break;
d8651 3
d8655 5
a8659 3
      newimm |= (temp & 0xfffff000);
      md_number_to_chars (buf, (valueT) newimm, INSN_SIZE);
      break;
d8661 3
a8663 4
    case BFD_RELOC_ARM_ADRL_IMMEDIATE:
      {
	unsigned int highpart = 0;
	unsigned int newinsn  = 0xe1a00000; /* nop.  */
d8665 3
a8667 2
	newimm = encode_arm_immediate (value);
	temp = md_chars_to_number (buf, INSN_SIZE);
d8669 2
a8670 8
	/* If the instruction will fail, see if we can fix things up by
	   changing the opcode.	 */
	if (newimm == (unsigned int) FAIL
	    && (newimm = negate_data_op (& temp, value)) == (unsigned int) FAIL)
	  {
	    /* No ?  OK - try using two ADD instructions to generate
	       the value.  */
	    newimm = validate_immediate_twopart (value, & highpart);
d8672 2
a8673 15
	    /* Yes - then make sure that the second instruction is
	       also an add.  */
	    if (newimm != (unsigned int) FAIL)
	      newinsn = temp;
	    /* Still No ?  Try using a negated value.  */
	    else if ((newimm = validate_immediate_twopart (- value, & highpart)) != (unsigned int) FAIL)
	      temp = newinsn = (temp & OPCODE_MASK) | OPCODE_SUB << DATA_OP_SHIFT;
	    /* Otherwise - give up.  */
	    else
	      {
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("unable to compute ADRL instructions for PC offset of 0x%lx"),
			      (long) value);
		break;
	      }
d8675 2
a8676 7
	    /* Replace the first operand in the 2nd instruction (which
	       is the PC) with the destination register.  We have
	       already added in the PC in the first instruction and we
	       do not want to do it again.  */
	    newinsn &= ~ 0xf0000;
	    newinsn |= ((newinsn & 0x0f000) << 4);
	  }
d8678 4
a8681 2
	newimm |= (temp & 0xfffff000);
	md_number_to_chars (buf, (valueT) newimm, INSN_SIZE);
d8683 1
a8683 4
	highpart |= (newinsn & 0xfffff000);
	md_number_to_chars (buf + INSN_SIZE, (valueT) highpart, INSN_SIZE);
      }
      break;
d8685 7
a8691 3
    case BFD_RELOC_ARM_OFFSET_IMM:
    case BFD_RELOC_ARM_LITERAL:
      sign = value >= 0;
d8693 5
a8697 2
      if (value < 0)
	value = - value;
d8699 12
a8710 1
      if (validate_offset_imm (value, 0) == FAIL)
d8712 2
a8713 8
	  if (fixP->fx_r_type == BFD_RELOC_ARM_LITERAL)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid literal constant: pool needs to be closer"));
	  else
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("bad immediate value for offset (%ld)"),
			  (long) value);
	  break;
d8716 10
a8725 14
      newval = md_chars_to_number (buf, INSN_SIZE);
      newval &= 0xff7ff000;
      newval |= value | (sign ? INDEX_UP : 0);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;

    case BFD_RELOC_ARM_OFFSET_IMM8:
    case BFD_RELOC_ARM_HWLITERAL:
      sign = value >= 0;

      if (value < 0)
	value = - value;

      if (validate_offset_imm (value, 1) == FAIL)
d8727 2
a8728 7
	  if (fixP->fx_r_type == BFD_RELOC_ARM_HWLITERAL)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid literal constant: pool needs to be closer"));
	  else
	    as_bad (_("bad immediate value for half-word offset (%ld)"),
		    (long) value);
	  break;
d8731 4
a8734 5
      newval = md_chars_to_number (buf, INSN_SIZE);
      newval &= 0xff7ff0f0;
      newval |= ((value >> 4) << 8) | (value & 0xf) | (sign ? INDEX_UP : 0);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;
d8736 2
a8737 5
    case BFD_RELOC_ARM_T32_OFFSET_U8:
      if (value < 0 || value > 1020 || value % 4 != 0)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("bad immediate value for offset (%ld)"), (long) value);
      value /= 4;
d8739 1
a8739 28
      newval = md_chars_to_number (buf+2, THUMB_SIZE);
      newval &= 0xff00;
      newval |= value;
      md_number_to_chars (buf+2, newval, THUMB_SIZE);
      break;

    case BFD_RELOC_ARM_T32_OFFSET_IMM:
      /* This is a complicated relocation used for all varieties of Thumb32
	 load/store instruction with immediate offset:

	 1110 100P u1WL NNNN XXXX YYYY iiii iiii - +/-(U) pre/post(P) 8-bit,
	                                           *4, optional writeback(W)
						   (doubleword load/store)

	 1111 100S uTTL 1111 XXXX iiii iiii iiii - +/-(U) 12-bit PC-rel
	 1111 100S 0TTL NNNN XXXX 1Pu1 iiii iiii - +/-(U) pre/post(P) 8-bit
	 1111 100S 0TTL NNNN XXXX 1110 iiii iiii - positive 8-bit (T instruction)
	 1111 100S 1TTL NNNN XXXX iiii iiii iiii - positive 12-bit
	 1111 100S 0TTL NNNN XXXX 1100 iiii iiii - negative 8-bit

	 Uppercase letters indicate bits that are already encoded at
	 this point.  Lowercase letters are our problem.  For the
	 second block of instructions, the secondary opcode nybble
	 (bits 8..11) is present, and bit 23 is zero, even if this is
	 a PC-relative operation.  */
      newval = md_chars_to_number (buf, THUMB_SIZE);
      newval <<= 16;
      newval |= md_chars_to_number (buf+THUMB_SIZE, THUMB_SIZE);
d8741 2
a8742 1
      if ((newval & 0xf0000000) == 0xe0000000)
d8744 2
a8745 19
	  /* Doubleword load/store: 8-bit offset, scaled by 4.  */
	  if (value >= 0)
	    newval |= (1 << 23);
	  else
	    value = -value;
	  if (value % 4 != 0)
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("offset not a multiple of 4"));
	      break;
	    }
	  value /= 4;
	  if (value >= 0xff)
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("offset out of range"));
	      break;
	    }
	  newval &= ~0xff;
d8747 3
a8749 1
      else if ((newval & 0x000f0000) == 0x000f0000)
d8751 5
a8755 12
	  /* PC-relative, 12-bit offset.  */
	  if (value >= 0)
	    newval |= (1 << 23);
	  else
	    value = -value;
	  if (value >= 0xfff)
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("offset out of range"));
	      break;
	    }
	  newval &= ~0xfff;
d8757 3
a8759 1
      else if ((newval & 0x00000100) == 0x00000100)
d8761 3
a8763 12
	  /* Writeback: 8-bit, +/- offset.  */
	  if (value >= 0)
	    newval |= (1 << 9);
	  else
	    value = -value;
	  if (value >= 0xff)
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("offset out of range"));
	      break;
	    }
	  newval &= ~0xff;
d8765 35
a8799 1
      else if ((newval & 0x00000f00) == 0x00000e00)
d8801 2
a8802 9
	  /* T-instruction: positive 8-bit offset.  */
	  if (value < 0 || value >= 0xff)
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("offset out of range"));
	      break;
	    }
	  newval &= ~0xff;
	  newval |= value;
d8804 5
d8810 4
d8815 3
a8817 3
	  /* Positive 12-bit or negative 8-bit offset.  */
	  int limit;
	  if (value >= 0)
d8819 2
a8820 2
	      newval |= (1 << 23);
	      limit = 0xfff;
d8822 2
a8823 12
	  else
	    {
	      value = -value;
	      limit = 0xff;
	    }
	  if (value > limit)
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("offset out of range"));
	      break;
	    }
	  newval &= ~limit;
d8825 20
d8846 1
a8846 4
      newval |= value;
      md_number_to_chars (buf, (newval >> 16) & 0xffff, THUMB_SIZE);
      md_number_to_chars (buf + THUMB_SIZE, newval & 0xffff, THUMB_SIZE);
      break;
d8848 1
a8848 5
    case BFD_RELOC_ARM_SHIFT_IMM:
      newval = md_chars_to_number (buf, INSN_SIZE);
      if (((unsigned long) value) > 32
	  || (value == 32
	      && (((newval & 0x60) == 0) || (newval & 0x60) == 0x60)))
d8850 8
a8857 3
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("shift expression is too large"));
	  break;
d8859 15
d8875 2
a8876 9
      if (value == 0)
	/* Shifts of zero must be done as lsl.	*/
	newval &= ~0x60;
      else if (value == 32)
	value = 0;
      newval &= 0xfffff07f;
      newval |= (value & 0x1f) << 7;
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;
d8878 2
a8879 5
    case BFD_RELOC_ARM_T32_IMMEDIATE:
      /* We claim that this fixup has been processed here,
	 even if in fact we generate an error because we do
	 not have a reloc for it, so tc_gen_reloc will reject it.  */
      fixP->fx_done = 1;
d8881 1
a8881 8
      if (fixP->fx_addsy
	  && ! S_IS_DEFINED (fixP->fx_addsy))
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("undefined symbol %s used as an immediate value"),
			S_GET_NAME (fixP->fx_addsy));
	  break;
	}
d8883 1
a8883 3
      newval = md_chars_to_number (buf, THUMB_SIZE);
      newval <<= 16;
      newval |= md_chars_to_number (buf+2, THUMB_SIZE);
d8885 2
a8886 1
      newimm = encode_thumb32_immediate (value);
d8888 5
a8892 8
      /* FUTURE: Implement analogue of negate_data_op for T32.  */
      if (newimm == (unsigned int)FAIL)
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("invalid constant (%lx) after fixup"),
			(unsigned long) value);
	  break;
	}
d8894 4
a8897 4
      newval &= 0xfbff8f00;
      newval |= (newimm & 0x800) << 15;
      newval |= (newimm & 0x700) << 4;
      newval |= (newimm & 0x0ff);
d8899 2
a8900 3
      md_number_to_chars (buf,   (valueT) ((newval >> 16) & 0xffff), THUMB_SIZE);
      md_number_to_chars (buf+2, (valueT) (newval & 0xffff), THUMB_SIZE);
      break;
d8902 2
a8903 8
    case BFD_RELOC_ARM_SMI:
      if (((unsigned long) value) > 0xffff)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("invalid smi expression"));
      newval = md_chars_to_number (buf, INSN_SIZE) & 0xfff000f0;
      newval |= (value & 0xf) | ((value & 0xfff0) << 4);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;
d8905 7
a8911 2
    case BFD_RELOC_ARM_SWI:
      if (fixP->tc_fix_data != 0)
d8913 4
a8916 15
	  if (((unsigned long) value) > 0xff)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid swi expression"));
	  newval = md_chars_to_number (buf, THUMB_SIZE) & 0xff00;
	  newval |= value;
	  md_number_to_chars (buf, newval, THUMB_SIZE);
	}
      else
	{
	  if (((unsigned long) value) > 0x00ffffff)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid swi expression"));
	  newval = md_chars_to_number (buf, INSN_SIZE) & 0xff000000;
	  newval |= value;
	  md_number_to_chars (buf, newval, INSN_SIZE);
a8917 1
      break;
d8919 3
a8921 7
    case BFD_RELOC_ARM_MULTI:
      if (((unsigned long) value) > 0xffff)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("invalid expression in load/store multiple"));
      newval = value | md_chars_to_number (buf, INSN_SIZE);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;
d8923 3
a8925 2
    case BFD_RELOC_ARM_PCREL_BRANCH:
      newval = md_chars_to_number (buf, INSN_SIZE);
d8927 2
a8928 2
      /* Sign-extend a 24-bit number.  */
#define SEXT24(x)	((((x) & 0xffffff) ^ (~ 0x7fffff)) + 0x800000)
d8930 1
a8930 3
#ifdef OBJ_ELF
      value = fixP->fx_offset;
#endif
d8932 1
a8932 14
      /* We are going to store value (shifted right by two) in the
	 instruction, in a 24 bit, signed field  Thus we need to check
	 that none of the top 8 bits of the shifted value (top 7 bits of
	 the unshifted, unsigned value) are set, or that they are all set.  */
      if ((value & ~ ((offsetT) 0x1ffffff)) != 0
	  && ((value & ~ ((offsetT) 0x1ffffff)) != ~ ((offsetT) 0x1ffffff)))
	{
#ifdef OBJ_ELF
	  /* Normally we would be stuck at this point, since we cannot store
	     the absolute address that is the destination of the branch in the
	     24 bits of the branch instruction.	 If however, we happen to know
	     that the destination of the branch is in the same section as the
	     branch instruction itself, then we can compute the relocation for
	     ourselves and not have to bother the linker with it.
d8934 7
a8940 8
	     FIXME: The test for OBJ_ELF is only here because I have not
	     worked out how to do this for OBJ_COFF.  */
	  if (fixP->fx_addsy != NULL
	      && S_IS_DEFINED (fixP->fx_addsy)
	      && S_GET_SEGMENT (fixP->fx_addsy) == seg)
	    {
	      /* Get pc relative value to go into the branch.  */
	      value = * valP;
d8942 2
a8943 7
	      /* Permit a backward branch provided that enough bits
		 are set.  Allow a forwards branch, provided that
		 enough bits are clear.	 */
	      if (   (value & ~ ((offsetT) 0x1ffffff)) == ~ ((offsetT) 0x1ffffff)
		  || (value & ~ ((offsetT) 0x1ffffff)) == 0)
		fixP->fx_done = 1;
	    }
d8945 1
a8945 5
	  if (! fixP->fx_done)
#endif
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("GAS can't handle same-section branch dest >= 0x04000000"));
	}
d8947 10
a8956 2
      value >>= 2;
      value += SEXT24 (newval);
d8958 1
a8958 4
      if (    (value & ~ ((offsetT) 0xffffff)) != 0
	  && ((value & ~ ((offsetT) 0xffffff)) != ~ ((offsetT) 0xffffff)))
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("out of range branch"));
d8960 8
a8967 14
      if (seg->use_rela_p && !fixP->fx_done)
	{
	  /* Must unshift the value before storing it in the addend.  */
	  value <<= 2;
#ifdef OBJ_ELF
	  fixP->fx_offset = value;
#endif
	  fixP->fx_addnumber = value;
	  newval = newval & 0xff000000;
	}
      else
	  newval = (value & 0x00ffffff) | (newval & 0xff000000);
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;
d8969 3
a8971 4
    case BFD_RELOC_ARM_PCREL_BLX:
      {
	offsetT hbit;
	newval = md_chars_to_number (buf, INSN_SIZE);
d8973 1
a8973 6
#ifdef OBJ_ELF
	value = fixP->fx_offset;
#endif
	hbit   = (value >> 1) & 1;
	value  = (value >> 2) & 0x00ffffff;
	value  = (value + (newval & 0x00ffffff)) & 0x00ffffff;
d8975 12
a8986 17
	if (seg->use_rela_p && !fixP->fx_done)
	  {
	    /* Must sign-extend and unshift the value before storing
	       it in the addend.  */
	    value = SEXT24 (value);
	    value = (value << 2) | hbit;
#ifdef OBJ_ELF
	    fixP->fx_offset = value;
#endif
	    fixP->fx_addnumber = value;
	    newval = newval & 0xfe000000;
	  }
	else
	  newval = value | (newval & 0xfe000000) | (hbit << 24);
	md_number_to_chars (buf, newval, INSN_SIZE);
      }
      break;
d8988 1
a8988 10
    case BFD_RELOC_THUMB_PCREL_BRANCH7: /* CZB */
      newval = md_chars_to_number (buf, THUMB_SIZE);
      {
	addressT diff = ((newval & 0x00f8) >> 2) | (newval & 0x0200) >> 3;
	/* This one does not have the offset encoded in the pattern.  */
	value = value + diff - 4;
	/* CZB can only branch forward.  */
	if (value & ~0x7e)
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("branch out of range"));
d8990 5
a8994 13
	newval &= 0xfd07;
	if (seg->use_rela_p && !fixP->fx_done)
	  {
#ifdef OBJ_ELF
	    fixP->fx_offset = value;
#endif
	    fixP->fx_addnumber = value;
	  }
	else
	  newval |= ((value & 0x2e) << 2) | ((value & 0x40) << 3);
      }
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;
d8996 11
a9006 6
    case BFD_RELOC_THUMB_PCREL_BRANCH9: /* Conditional branch.	*/
      newval = md_chars_to_number (buf, THUMB_SIZE);
      {
	addressT diff = (newval & 0xff) << 1;
	if (diff & 0x100)
	  diff |= ~0xff;
d9008 5
a9012 17
	value += diff;
	if ((value & ~0xff) && ((value & ~0xff) != ~0xff))
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("branch out of range"));
	if (seg->use_rela_p && !fixP->fx_done)
	  {
#ifdef OBJ_ELF
	    fixP->fx_offset = value;
#endif
	    fixP->fx_addnumber = value;
	    newval = newval & 0xff00;
	  }
	else
	  newval = (newval & 0xff00) | ((value & 0x1ff) >> 1);
      }
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;
d9014 5
a9018 6
    case BFD_RELOC_THUMB_PCREL_BRANCH12: /* Unconditional branch.  */
      newval = md_chars_to_number (buf, THUMB_SIZE);
      {
	addressT diff = (newval & 0x7ff) << 1;
	if (diff & 0x800)
	  diff |= ~0x7ff;
d9020 5
a9024 17
	value += diff;
	if ((value & ~0x7ff) && ((value & ~0x7ff) != ~0x7ff))
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("branch out of range"));
	if (seg->use_rela_p && !fixP->fx_done)
	  {
#ifdef OBJ_ELF
	    fixP->fx_offset = value;
#endif
	    fixP->fx_addnumber = value;
	    newval = newval & 0xf800;
	  }
	else
	  newval = (newval & 0xf800) | ((value & 0xfff) >> 1);
      }
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;
d9026 5
a9030 4
    case BFD_RELOC_THUMB_PCREL_BRANCH20:
      {
	offsetT newval2;
	addressT diff, S, J1, J2, lo, hi;
d9032 5
a9036 2
	newval	= md_chars_to_number (buf, THUMB_SIZE);
	newval2 = md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);
d9038 5
a9042 5
	S  = !(newval & 0x0400);  /* flipped - 0=negative */
	hi = (newval  & 0x003f);
	J1 = (newval2 & 0x2000) >> 13;
	J2 = (newval2 & 0x0800) >> 11;
	lo = (newval2 & 0x07ff);
d9044 5
a9048 3
	diff = ((S << 20) | (J2 << 19) | (J1 << 18) | (hi << 12) | (lo << 1));
	diff -= (1 << 20);  /* sign extend */
	value += diff;
d9050 5
a9054 3
	if ((value & ~0x1fffff) && ((value & ~0x1fffff) != ~0x1fffff))
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("conditional branch out of range"));
d9056 5
a9060 16
	newval  = newval  & 0xfbc0;
	newval2 = newval2 & 0xd000;
	if (seg->use_rela_p && !fixP->fx_done)
	  {
#ifdef OBJ_ELF
	    fixP->fx_offset = value;
#endif
	    fixP->fx_addnumber = value;
	  }
	else
	  {
	    S  = (value & 0x00100000) >> 20;
	    J2 = (value & 0x00080000) >> 19;
	    J1 = (value & 0x00040000) >> 18;
	    hi = (value & 0x0003f000) >> 12;
	    lo = (value & 0x00000ffe) >> 1;
d9062 5
a9066 3
	    newval  = newval  | (S << 10) | hi;
	    newval2 = newval2 | (J1 << 13) | (J2 << 11) | lo;
	  }
d9068 5
a9072 4
	md_number_to_chars (buf, newval, THUMB_SIZE);
	md_number_to_chars (buf + THUMB_SIZE, newval2, THUMB_SIZE);
      }
      break;
d9074 5
a9078 5
    case BFD_RELOC_THUMB_PCREL_BLX:
    case BFD_RELOC_THUMB_PCREL_BRANCH23:
      {
	offsetT newval2;
	addressT diff;
d9080 5
a9084 9
	newval	= md_chars_to_number (buf, THUMB_SIZE);
	newval2 = md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);
	diff = ((newval & 0x7ff) << 12) | ((newval2 & 0x7ff) << 1);
	if (diff & 0x400000)
	  diff |= ~0x3fffff;
#ifdef OBJ_ELF
	value = fixP->fx_offset;
#endif
	value += diff;
d9086 5
a9090 3
	if ((value & ~0x3fffff) && ((value & ~0x3fffff) != ~0x3fffff))
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("branch with link out of range"));
d9092 5
a9096 6
	if (fixP->fx_r_type == BFD_RELOC_THUMB_PCREL_BLX)
	  /* For a BLX instruction, make sure that the relocation is rounded up
	     to a word boundary.  This follows the semantics of the instruction
	     which specifies that bit 1 of the target address will come from bit
	     1 of the base address.  */
	  value = (value + 1) & ~ 1;
d9098 5
a9102 18
	if (seg->use_rela_p && !fixP->fx_done)
	  {
#ifdef OBJ_ELF
	    fixP->fx_offset = value;
#endif
	    fixP->fx_addnumber = value;
	    newval = newval & 0xf800;
	    newval2 = newval2 & 0xf800;
	  }
	else
	  {
	    newval  = (newval  & 0xf800) | ((value & 0x7fffff) >> 12);
	    newval2 = (newval2 & 0xf800) | ((value & 0xfff) >> 1);
	  }
	md_number_to_chars (buf, newval, THUMB_SIZE);
	md_number_to_chars (buf + THUMB_SIZE, newval2, THUMB_SIZE);
      }
      break;
d9104 5
a9108 13
    case BFD_RELOC_8:
      if (seg->use_rela_p && !fixP->fx_done)
	break;
      if (fixP->fx_done || fixP->fx_pcrel)
	md_number_to_chars (buf, value, 1);
#ifdef OBJ_ELF
      else
	{
	  value = fixP->fx_offset;
	  md_number_to_chars (buf, value, 1);
	}
#endif
      break;
d9110 5
a9114 4
    case BFD_RELOC_THUMB_PCREL_BRANCH25:
      {
	offsetT newval2;
	addressT diff, S, I1, I2, lo, hi;
d9116 5
a9120 2
	newval	= md_chars_to_number (buf, THUMB_SIZE);
	newval2 = md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);
d9122 5
a9126 9
	S  = (newval  & 0x0400) >> 10;
	hi = (newval  & 0x03ff);
	I1 = (newval2 & 0x2000) >> 13;
	I2 = (newval2 & 0x0800) >> 11;
	lo = (newval2 & 0x07ff);

	I1 = !(I1 ^ S);
	I2 = !(I2 ^ S);
	S  = !S;
d9128 5
a9132 3
	diff = ((S << 24) | (I1 << 23) | (I2 << 22) | (hi << 12) | (lo << 1));
	diff -= (1 << 24);  /* sign extend */
	value += diff;
d9134 5
a9138 3
	if ((value & ~0x1ffffff) && ((value & ~0x1ffffff) != ~0x1ffffff))
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("branch out of range"));
d9140 5
a9144 16
	newval  = newval  & 0xf800;
	newval2 = newval2 & 0xd000;
	if (seg->use_rela_p && !fixP->fx_done)
	  {
#ifdef OBJ_ELF
	    fixP->fx_offset = value;
#endif
	    fixP->fx_addnumber = value;
	  }
	else
	  {
	    S  = (value & 0x01000000) >> 24;
	    I1 = (value & 0x00800000) >> 23;
	    I2 = (value & 0x00400000) >> 22;
	    hi = (value & 0x003ff000) >> 12;
	    lo = (value & 0x00000ffe) >> 1;
d9146 5
a9150 2
	    I1 = !(I1 ^ S);
	    I2 = !(I2 ^ S);
d9152 5
a9156 7
	    newval  = newval  | (S << 10) | hi;
	    newval2 = newval2 | (I1 << 13) | (I2 << 11) | lo;
	  }
	md_number_to_chars (buf, newval, THUMB_SIZE);
	md_number_to_chars (buf + THUMB_SIZE, newval2, THUMB_SIZE);
      }
      break;
d9158 5
a9162 13
    case BFD_RELOC_16:
      if (seg->use_rela_p && !fixP->fx_done)
	break;
      if (fixP->fx_done || fixP->fx_pcrel)
	md_number_to_chars (buf, value, 2);
#ifdef OBJ_ELF
      else
	{
	  value = fixP->fx_offset;
	  md_number_to_chars (buf, value, 2);
	}
#endif
      break;
d9164 5
a9168 8
#ifdef OBJ_ELF
    case BFD_RELOC_ARM_TLS_GD32:
    case BFD_RELOC_ARM_TLS_LE32:
    case BFD_RELOC_ARM_TLS_IE32:
    case BFD_RELOC_ARM_TLS_LDM32:
    case BFD_RELOC_ARM_TLS_LDO32:
      S_SET_THREAD_LOCAL (fixP->fx_addsy);
      /* fall through */
d9170 5
a9174 8
    case BFD_RELOC_ARM_GOT32:
    case BFD_RELOC_ARM_GOTOFF:
    case BFD_RELOC_ARM_TARGET2:
      if (seg->use_rela_p && !fixP->fx_done)
	break;
      md_number_to_chars (buf, 0, 4);
      break;
#endif
d9176 25
a9200 18
    case BFD_RELOC_RVA:
    case BFD_RELOC_32:
    case BFD_RELOC_ARM_TARGET1:
    case BFD_RELOC_ARM_ROSEGREL32:
    case BFD_RELOC_ARM_SBREL32:
    case BFD_RELOC_32_PCREL:
      if (seg->use_rela_p && !fixP->fx_done)
	break;
      if (fixP->fx_done || fixP->fx_pcrel)
	md_number_to_chars (buf, value, 4);
#ifdef OBJ_ELF
      else
	{
	  value = fixP->fx_offset;
	  md_number_to_chars (buf, value, 4);
	}
#endif
      break;
d9202 14
a9215 14
#ifdef OBJ_ELF
    case BFD_RELOC_ARM_PREL31:
      if (fixP->fx_done || fixP->fx_pcrel)
	{
	  newval = md_chars_to_number (buf, 4) & 0x80000000;
	  if ((value ^ (value >> 1)) & 0x40000000)
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("rel31 relocation overflow"));
	    }
	  newval |= value & 0x7fffffff;
	  md_number_to_chars (buf, newval, 4);
	}
      break;
d9217 6
a9222 4
    case BFD_RELOC_ARM_PLT32:
      /* It appears the instruction is fully prepared at this point.  */
      break;
#endif
d9224 6
a9229 14
    case BFD_RELOC_ARM_CP_OFF_IMM:
      if (value < -1023 || value > 1023 || (value & 3))
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("co-processor offset out of range"));
    cp_off_common:
      sign = value >= 0;
      if (value < 0)
	value = -value;
      newval = md_chars_to_number (buf, INSN_SIZE) & 0xff7fff00;
      newval |= (value >> 2) | (sign ? INDEX_UP : 0);
      if (value == 0)
	newval &= ~WRITE_BACK;
      md_number_to_chars (buf, newval, INSN_SIZE);
      break;
d9231 5
a9235 5
    case BFD_RELOC_ARM_CP_OFF_IMM_S2:
      if (value < -255 || value > 255)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("co-processor offset out of range"));
      goto cp_off_common;
d9237 7
a9243 16
    case BFD_RELOC_ARM_THUMB_OFFSET:
      newval = md_chars_to_number (buf, THUMB_SIZE);
      /* Exactly what ranges, and where the offset is inserted depends
	 on the type of instruction, we can establish this from the
	 top 4 bits.  */
      switch (newval >> 12)
	{
	case 4: /* PC load.  */
	  /* Thumb PC loads are somewhat odd, bit 1 of the PC is
	     forced to zero for these loads; md_pcrel_from has already
	     compensated for this.  */
	  if (value & 3)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, target not word aligned (0x%08lX)"),
			  (((unsigned int) fixP->fx_frag->fr_address
			    + (unsigned int) fixP->fx_where) & ~3) + value);
d9245 2
a9246 4
	  if (value & ~0x3fc)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
d9248 2
a9249 2
	  newval |= value >> 2;
	  break;
d9251 5
a9255 7
	case 9: /* SP load/store.  */
	  if (value & ~0x3fc)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
	  newval |= value >> 2;
	  break;
d9257 7
a9263 7
	case 6: /* Word load/store.  */
	  if (value & ~0x7c)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
	  newval |= value << 4; /* 6 - 2.  */
	  break;
d9265 2
a9266 7
	case 7: /* Byte load/store.  */
	  if (value & ~0x1f)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
	  newval |= value << 6;
	  break;
d9268 2
a9269 7
	case 8: /* Halfword load/store.	 */
	  if (value & ~0x3e)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("invalid offset, value too big (0x%08lX)"),
			  (long) value);
	  newval |= value << 5; /* 6 - 1.  */
	  break;
d9271 3
a9273 8
	default:
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			"Unable to process relocation for thumb opcode: %lx",
			(unsigned long) newval);
	  break;
	}
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;
d9275 7
a9281 3
    case BFD_RELOC_ARM_THUMB_ADD:
      /* This is a complicated relocation, since we use it for all of
	 the following immediate relocations:
d9283 1
a9283 4
	    3bit ADD/SUB
	    8bit ADD/SUB
	    9bit ADD/SUB SP word-aligned
	   10bit ADD PC/SP word-aligned
d9285 1
a9285 2
	 The type of instruction being processed is encoded in the
	 instruction field:
d9287 9
a9295 9
	   0x8000  SUB
	   0x00F0  Rd
	   0x000F  Rs
      */
      newval = md_chars_to_number (buf, THUMB_SIZE);
      {
	int rd = (newval >> 4) & 0xf;
	int rs = newval & 0xf;
	int subtract = !!(newval & 0x8000);
d9297 3
a9299 6
	/* Check for HI regs, only very restricted cases allowed:
	   Adjusting SP, and using PC or SP to get an address.	*/
	if ((rd > 7 && (rd != REG_SP || rs != REG_SP))
	    || (rs > 7 && rs != REG_SP && rs != REG_PC))
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("invalid Hi register with immediate"));
d9301 2
a9302 9
	/* If value is negative, choose the opposite instruction.  */
	if (value < 0)
	  {
	    value = -value;
	    subtract = !subtract;
	    if (value < 0)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("immediate value out of range"));
	  }
d9304 5
a9308 37
	if (rd == REG_SP)
	  {
	    if (value & ~0x1fc)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("invalid immediate for stack address calculation"));
	    newval = subtract ? T_OPCODE_SUB_ST : T_OPCODE_ADD_ST;
	    newval |= value >> 2;
	  }
	else if (rs == REG_PC || rs == REG_SP)
	  {
	    if (subtract || value & ~0x3fc)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("invalid immediate for address calculation (value = 0x%08lX)"),
			    (unsigned long) value);
	    newval = (rs == REG_PC ? T_OPCODE_ADD_PC : T_OPCODE_ADD_SP);
	    newval |= rd << 8;
	    newval |= value >> 2;
	  }
	else if (rs == rd)
	  {
	    if (value & ~0xff)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("immediate value out of range"));
	    newval = subtract ? T_OPCODE_SUB_I8 : T_OPCODE_ADD_I8;
	    newval |= (rd << 8) | value;
	  }
	else
	  {
	    if (value & ~0x7)
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("immediate value out of range"));
	    newval = subtract ? T_OPCODE_SUB_I3 : T_OPCODE_ADD_I3;
	    newval |= rd | (rs << 3) | (value << 6);
	  }
      }
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;
d9310 5
a9314 9
    case BFD_RELOC_ARM_THUMB_IMM:
      newval = md_chars_to_number (buf, THUMB_SIZE);
      if (value < 0 || value > 255)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("invalid immediate: %ld is too large"),
		      (long) value);
      newval |= value;
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;
d9316 2
a9317 16
    case BFD_RELOC_ARM_THUMB_SHIFT:
      /* 5bit shift value (0..32).  LSL cannot take 32.	 */
      newval = md_chars_to_number (buf, THUMB_SIZE) & 0xf83f;
      temp = newval & 0xf800;
      if (value < 0 || value > 32 || (value == 32 && temp == T_OPCODE_LSL_I))
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("invalid shift value: %ld"), (long) value);
      /* Shifts of zero must be encoded as LSL.	 */
      if (value == 0)
	newval = (newval & 0x003f) | T_OPCODE_LSL_I;
      /* Shifts of 32 are encoded as zero.  */
      else if (value == 32)
	value = 0;
      newval |= value << 6;
      md_number_to_chars (buf, newval, THUMB_SIZE);
      break;
d9319 3
a9321 3
    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      fixP->fx_done = 0;
d9323 1
d9325 5
a9329 4
    case BFD_RELOC_UNUSED:
    default:
      as_bad_where (fixP->fx_file, fixP->fx_line,
		    _("bad relocation fixup type (%d)"), fixP->fx_r_type);
d9331 14
d9347 5
a9351 2
/* Translate internal representation of relocation info to BFD target
   format.  */
d9353 2
a9354 3
arelent *
tc_gen_reloc (asection * section ATTRIBUTE_UNUSED,
	      fixS *	 fixp)
d9356 6
a9361 2
  arelent * reloc;
  bfd_reloc_code_real_type code;
d9363 2
a9364 1
  reloc = xmalloc (sizeof (arelent));
d9366 5
a9370 3
  reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
d9372 8
a9379 9
  /* @@@@ Why fx_addnumber sometimes and fx_offset other times?  */
#ifndef OBJ_ELF
  if (fixp->fx_pcrel == 0)
    reloc->addend = fixp->fx_offset;
  else
    reloc->addend = fixp->fx_offset = reloc->address;
#else  /* OBJ_ELF */
  reloc->addend = fixp->fx_offset;
#endif
d9381 6
a9386 1
  switch (fixp->fx_r_type)
d9388 5
a9392 6
    case BFD_RELOC_8:
      if (fixp->fx_pcrel)
	{
	  code = BFD_RELOC_8_PCREL;
	  break;
	}
d9394 2
a9395 6
    case BFD_RELOC_16:
      if (fixp->fx_pcrel)
	{
	  code = BFD_RELOC_16_PCREL;
	  break;
	}
d9397 3
a9399 6
    case BFD_RELOC_32:
      if (fixp->fx_pcrel)
	{
	  code = BFD_RELOC_32_PCREL;
	  break;
	}
d9401 4
a9404 15
    case BFD_RELOC_NONE:
    case BFD_RELOC_ARM_PCREL_BRANCH:
    case BFD_RELOC_ARM_PCREL_BLX:
    case BFD_RELOC_RVA:
    case BFD_RELOC_THUMB_PCREL_BRANCH7:
    case BFD_RELOC_THUMB_PCREL_BRANCH9:
    case BFD_RELOC_THUMB_PCREL_BRANCH12:
    case BFD_RELOC_THUMB_PCREL_BRANCH20:
    case BFD_RELOC_THUMB_PCREL_BRANCH23:
    case BFD_RELOC_THUMB_PCREL_BRANCH25:
    case BFD_RELOC_THUMB_PCREL_BLX:
    case BFD_RELOC_VTABLE_ENTRY:
    case BFD_RELOC_VTABLE_INHERIT:
      code = fixp->fx_r_type;
      break;
d9406 1
a9406 7
    case BFD_RELOC_ARM_LITERAL:
    case BFD_RELOC_ARM_HWLITERAL:
      /* If this is called then the a literal has
	 been referenced across a section boundary.  */
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("literal referenced across section boundary"));
      return NULL;
d9408 5
a9412 13
#ifdef OBJ_ELF
    case BFD_RELOC_ARM_GOT32:
    case BFD_RELOC_ARM_GOTOFF:
    case BFD_RELOC_ARM_PLT32:
    case BFD_RELOC_ARM_TARGET1:
    case BFD_RELOC_ARM_ROSEGREL32:
    case BFD_RELOC_ARM_SBREL32:
    case BFD_RELOC_ARM_PREL31:
    case BFD_RELOC_ARM_TARGET2:
    case BFD_RELOC_ARM_TLS_LE32:
    case BFD_RELOC_ARM_TLS_LDO32:
      code = fixp->fx_r_type;
      break;
d9414 4
a9417 10
    case BFD_RELOC_ARM_TLS_GD32:
    case BFD_RELOC_ARM_TLS_IE32:
    case BFD_RELOC_ARM_TLS_LDM32:
      /* BFD will include the symbol's address in the addend.
	 But we don't want that, so subtract it out again here.  */
      if (!S_IS_COMMON (fixp->fx_addsy))
	reloc->addend -= (*reloc->sym_ptr_ptr)->value;
      code = fixp->fx_r_type;
      break;
#endif
d9419 1
a9419 4
    case BFD_RELOC_ARM_IMMEDIATE:
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("internal relocation (type: IMMEDIATE) not fixed up"));
      return NULL;
d9421 2
a9422 4
    case BFD_RELOC_ARM_ADRL_IMMEDIATE:
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("ADRL used for a symbol not defined in the same file"));
      return NULL;
d9424 1
a9424 4
    case BFD_RELOC_ARM_OFFSET_IMM:
      if (fixp->fx_addsy != NULL
	  && !S_IS_DEFINED (fixp->fx_addsy)
	  && S_IS_LOCAL (fixp->fx_addsy))
d9426 2
a9427 4
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			_("undefined local label `%s'"),
			S_GET_NAME (fixp->fx_addsy));
	  return NULL;
d9430 14
a9443 3
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("internal_relocation (type: OFFSET_IMM) not fixed up"));
      return NULL;
d9445 3
a9447 3
    default:
      {
	char * type;
d9449 1
a9449 20
	switch (fixp->fx_r_type)
	  {
	  case BFD_RELOC_NONE:		   type = "NONE";	  break;
	  case BFD_RELOC_ARM_OFFSET_IMM8:  type = "OFFSET_IMM8";  break;
	  case BFD_RELOC_ARM_SHIFT_IMM:	   type = "SHIFT_IMM";	  break;
	  case BFD_RELOC_ARM_SMI:	   type = "SMI";	  break;
	  case BFD_RELOC_ARM_SWI:	   type = "SWI";	  break;
	  case BFD_RELOC_ARM_MULTI:	   type = "MULTI";	  break;
	  case BFD_RELOC_ARM_CP_OFF_IMM:   type = "CP_OFF_IMM";	  break;
	  case BFD_RELOC_ARM_THUMB_ADD:	   type = "THUMB_ADD";	  break;
	  case BFD_RELOC_ARM_THUMB_SHIFT:  type = "THUMB_SHIFT";  break;
	  case BFD_RELOC_ARM_THUMB_IMM:	   type = "THUMB_IMM";	  break;
	  case BFD_RELOC_ARM_THUMB_OFFSET: type = "THUMB_OFFSET"; break;
	  default:			   type = _("<unknown>"); break;
	  }
	as_bad_where (fixp->fx_file, fixp->fx_line,
		      _("cannot represent %s relocation in this object file format"),
		      type);
	return NULL;
      }
d9452 19
a9470 9
#ifdef OBJ_ELF
  if ((code == BFD_RELOC_32_PCREL || code == BFD_RELOC_32)
      && GOT_symbol
      && fixp->fx_addsy == GOT_symbol)
    {
      code = BFD_RELOC_ARM_GOTPC;
      reloc->addend = fixp->fx_offset = reloc->address;
    }
#endif
d9472 5
a9476 1
  reloc->howto = bfd_reloc_type_lookup (stdoutput, code);
d9478 5
a9482 7
  if (reloc->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("cannot represent %s relocation in this object file format"),
		    bfd_get_reloc_code_name (code));
      return NULL;
    }
d9484 5
a9488 4
  /* HACK: Since arm ELF uses Rel instead of Rela, encode the
     vtable entry to be used in the relocation's section offset.  */
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    reloc->address = fixp->fx_offset;
d9490 5
a9494 1
  return reloc;
d9497 3
a9499 1
/* This fix_new is called by cons via TC_CONS_FIX_NEW.	*/
d9501 2
a9502 5
void
cons_fix_new_arm (fragS *	frag,
		  int		where,
		  int		size,
		  expressionS * exp)
d9504 11
a9514 2
  bfd_reloc_code_real_type type;
  int pcrel = 0;
d9516 1
a9516 3
  /* Pick a reloc.
     FIXME: @@@@ Should look at CPU word size.  */
  switch (size)
d9518 21
a9538 13
    case 1:
      type = BFD_RELOC_8;
      break;
    case 2:
      type = BFD_RELOC_16;
      break;
    case 4:
    default:
      type = BFD_RELOC_32;
      break;
    case 8:
      type = BFD_RELOC_64;
      break;
d9541 6
a9546 1
  fix_new_exp (frag, where, (int) size, exp, pcrel, type);
d9549 2
a9550 3
#if defined OBJ_COFF || defined OBJ_ELF
void
arm_validate_fix (fixS * fixP)
d9552 1
a9552 11
  /* If the destination of the branch is a defined symbol which does not have
     the THUMB_FUNC attribute, then we must be calling a function which has
     the (interfacearm) attribute.  We look for the Thumb entry point to that
     function and change the branch to refer to that function instead.	*/
  if (fixP->fx_r_type == BFD_RELOC_THUMB_PCREL_BRANCH23
      && fixP->fx_addsy != NULL
      && S_IS_DEFINED (fixP->fx_addsy)
      && ! THUMB_IS_FUNC (fixP->fx_addsy))
    {
      fixP->fx_addsy = find_real_start (fixP->fx_addsy);
    }
a9553 1
#endif
d9555 2
a9556 2
int
arm_force_relocation (struct fix * fixp)
d9558 2
a9559 11
#if defined (OBJ_COFF) && defined (TE_PE)
  if (fixp->fx_r_type == BFD_RELOC_RVA)
    return 1;
#endif
#ifdef OBJ_ELF
  if (fixp->fx_r_type == BFD_RELOC_ARM_PCREL_BRANCH
      || fixp->fx_r_type == BFD_RELOC_ARM_PCREL_BLX
      || fixp->fx_r_type == BFD_RELOC_THUMB_PCREL_BLX
      || fixp->fx_r_type == BFD_RELOC_THUMB_PCREL_BRANCH23)
    return 1;
#endif
d9561 9
a9569 5
  /* Resolve these relocations even if the symbol is extern or weak.  */
  if (fixp->fx_r_type == BFD_RELOC_ARM_IMMEDIATE
      || fixp->fx_r_type == BFD_RELOC_ARM_OFFSET_IMM
      || fixp->fx_r_type == BFD_RELOC_ARM_ADRL_IMMEDIATE)
    return 0;
d9571 8
a9578 1
  return generic_force_reloc (fixp);
d9581 1
a9581 6
#ifdef OBJ_COFF
/* This is a little hack to help the gas/arm/adrl.s test.  It prevents
   local labels from being added to the output symbol table when they
   are used with the ADRL pseudo op.  The ADRL relocation should always
   be resolved before the binbary is emitted, so it is safe to say that
   it is adjustable.  */
d9583 2
a9584 2
bfd_boolean
arm_fix_adjustable (fixS * fixP)
d9586 6
a9591 5
  if (fixP->fx_r_type == BFD_RELOC_ARM_ADRL_IMMEDIATE)
    return 1;
  return 0;
}
#endif
d9593 2
a9594 6
#ifdef OBJ_ELF
/* Relocations against Thumb function names must be left unadjusted,
   so that the linker can use this information to correctly set the
   bottom bit of their addresses.  The MIPS version of this function
   also prevents relocations that are mips-16 specific, but I do not
   know why it does this.
d9596 5
a9600 6
   FIXME:
   There is one other problem that ought to be addressed here, but
   which currently is not:  Taking the address of a label (rather
   than a function) and then later jumping to that address.  Such
   addresses also ought to have their bottom bit set (assuming that
   they reside in Thumb code), but at the moment they will not.	 */
d9602 2
a9603 5
bfd_boolean
arm_fix_adjustable (fixS * fixP)
{
  if (fixP->fx_addsy == NULL)
    return 1;
d9605 1
a9605 3
  if (THUMB_IS_FUNC (fixP->fx_addsy)
      && fixP->fx_subsy == NULL)
    return 0;
d9607 5
a9611 4
  /* We need the symbol name for the VTABLE entries.  */
  if (	 fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 0;
d9613 1
a9613 11
  /* Don't allow symbols to be discarded on GOT related relocs.	 */
  if (fixP->fx_r_type == BFD_RELOC_ARM_PLT32
      || fixP->fx_r_type == BFD_RELOC_ARM_GOT32
      || fixP->fx_r_type == BFD_RELOC_ARM_GOTOFF
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_GD32
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_LE32
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_IE32
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_LDM32
      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_LDO32
      || fixP->fx_r_type == BFD_RELOC_ARM_TARGET2)
    return 0;
d9615 1
a9615 1
  return 1;
d9618 2
a9619 2
const char *
elf32_arm_target_format (void)
d9621 17
a9637 14
#ifdef TE_SYMBIAN
  return (target_big_endian
	  ? "elf32-bigarm-symbian"
	  : "elf32-littlearm-symbian");
#elif defined (TE_VXWORKS)
  return (target_big_endian
	  ? "elf32-bigarm-vxworks"
	  : "elf32-littlearm-vxworks");
#else
  if (target_big_endian)
    return "elf32-bigarm";
  else
    return "elf32-littlearm";
#endif
d9640 2
a9641 3
void
armelf_frob_symbol (symbolS * symp,
		    int *     puntp)
d9643 3
a9645 3
  elf_frob_symbol (symp, puntp);
}
#endif
d9647 2
a9648 1
/* MD interface: Finalization.	*/
d9650 2
a9651 3
/* A good place to do this, although this was probably not intended
   for this kind of use.  We need to dump the literal pool before
   references are made to a null symbol pointer.  */
d9653 3
a9655 4
void
arm_cleanup (void)
{
  literal_pool * pool;
d9657 1
a9657 9
  for (pool = list_of_pools; pool; pool = pool->next)
    {
      /* Put it at the end of the relevent section.  */
      subseg_set (pool->section, pool->sub_section);
#ifdef OBJ_ELF
      arm_elf_change_section ();
#endif
      s_ltorg (0);
    }
d9660 5
a9664 2
/* Adjust the symbol table.  This marks Thumb symbols as distinct from
   ARM ones.  */
d9666 2
a9667 2
void
arm_adjust_symtab (void)
d9669 4
a9672 2
#ifdef OBJ_COFF
  symbolS * sym;
d9674 2
a9675 10
  for (sym = symbol_rootP; sym != NULL; sym = symbol_next (sym))
    {
      if (ARM_IS_THUMB (sym))
	{
	  if (THUMB_IS_FUNC (sym))
	    {
	      /* Mark the symbol as a Thumb function.  */
	      if (   S_GET_STORAGE_CLASS (sym) == C_STAT
		  || S_GET_STORAGE_CLASS (sym) == C_LABEL)  /* This can happen!	 */
		S_SET_STORAGE_CLASS (sym, C_THUMBSTATFUNC);
d9677 4
a9680 22
	      else if (S_GET_STORAGE_CLASS (sym) == C_EXT)
		S_SET_STORAGE_CLASS (sym, C_THUMBEXTFUNC);
	      else
		as_bad (_("%s: unexpected function type: %d"),
			S_GET_NAME (sym), S_GET_STORAGE_CLASS (sym));
	    }
	  else switch (S_GET_STORAGE_CLASS (sym))
	    {
	    case C_EXT:
	      S_SET_STORAGE_CLASS (sym, C_THUMBEXT);
	      break;
	    case C_STAT:
	      S_SET_STORAGE_CLASS (sym, C_THUMBSTAT);
	      break;
	    case C_LABEL:
	      S_SET_STORAGE_CLASS (sym, C_THUMBLABEL);
	      break;
	    default:
	      /* Do nothing.  */
	      break;
	    }
	}
d9682 6
a9687 2
      if (ARM_IS_INTERWORK (sym))
	coffsymbol (symbol_get_bfdsym (sym))->native->u.syment.n_flags = 0xFF;
a9688 4
#endif
#ifdef OBJ_ELF
  symbolS * sym;
  char	    bind;
d9690 1
a9690 1
  for (sym = symbol_rootP; sym != NULL; sym = symbol_next (sym))
d9692 5
a9696 3
      if (ARM_IS_THUMB (sym))
	{
	  elf_symbol_type * elf_sym;
d9698 5
a9702 2
	  elf_sym = elf_symbol (symbol_get_bfdsym (sym));
	  bind = ELF_ST_BIND (elf_sym->internal_elf_sym.st_info);
d9704 2
a9705 14
	  if (! bfd_is_arm_mapping_symbol_name (elf_sym->symbol.name))
	    {
	      /* If it's a .thumb_func, declare it as so,
		 otherwise tag label as .code 16.  */
	      if (THUMB_IS_FUNC (sym))
		elf_sym->internal_elf_sym.st_info =
		  ELF_ST_INFO (bind, STT_ARM_TFUNC);
	      else
		elf_sym->internal_elf_sym.st_info =
		  ELF_ST_INFO (bind, STT_ARM_16BIT);
	    }
	}
    }
#endif
d9708 5
a9712 1
/* MD interface: Initialization.  */
d9715 1
a9715 1
set_constant_flonums (void)
d9717 2
a9718 1
  int i;
d9720 4
a9723 3
  for (i = 0; i < NUM_FLOAT_VALS; i++)
    if (atof_ieee ((char *) fp_const[i], 'x', fp_values[i]) == NULL)
      abort ();
d9726 2
a9727 2
void
md_begin (void)
d9729 1
a9729 2
  unsigned mach;
  unsigned int i;
d9731 1
a9731 7
  if (	 (arm_ops_hsh = hash_new ()) == NULL
      || (arm_cond_hsh = hash_new ()) == NULL
      || (arm_shift_hsh = hash_new ()) == NULL
      || (arm_psr_hsh = hash_new ()) == NULL
      || (arm_reg_hsh = hash_new ()) == NULL
      || (arm_reloc_hsh = hash_new ()) == NULL)
    as_fatal (_("virtual memory exhausted"));
d9733 12
a9744 14
  for (i = 0; i < sizeof (insns) / sizeof (struct asm_opcode); i++)
    hash_insert (arm_ops_hsh, insns[i].template, (PTR) (insns + i));
  for (i = 0; i < sizeof (conds) / sizeof (struct asm_cond); i++)
    hash_insert (arm_cond_hsh, conds[i].template, (PTR) (conds + i));
  for (i = 0; i < sizeof (shift_names) / sizeof (struct asm_shift_name); i++)
    hash_insert (arm_shift_hsh, shift_names[i].name, (PTR) (shift_names + i));
  for (i = 0; i < sizeof (psrs) / sizeof (struct asm_psr); i++)
    hash_insert (arm_psr_hsh, psrs[i].template, (PTR) (psrs + i));
  for (i = 0; i < sizeof (reg_names) / sizeof (struct reg_entry); i++)
    hash_insert (arm_reg_hsh, reg_names[i].name, (PTR) (reg_names + i));
#ifdef OBJ_ELF
  for (i = 0; i < sizeof (reloc_names) / sizeof (struct reloc_entry); i++)
    hash_insert (arm_reloc_hsh, reloc_names[i].name, (PTR) (reloc_names + i));
#endif
d9746 3
a9748 1
  set_constant_flonums ();
d9750 1578
a11327 8
  /* Set the cpu variant based on the command-line options.  We prefer
     -mcpu= over -march= if both are set (as for GCC); and we prefer
     -mfpu= over any other way of setting the floating point unit.
     Use of legacy options with new options are faulted.  */
  if (legacy_cpu != -1)
    {
      if (mcpu_cpu_opt != -1 || march_cpu_opt != -1)
	as_bad (_("use of old and new-style options to set CPU type"));
d11343 1
a11343 1
#if !(defined (TE_LINUX) || defined (TE_NetBSD) || defined (TE_VXWORKS))
d11385 1
a11385 1
	if (pic_code)	       flags |= F_PIC;
d11403 1
a11403 1
	/* Using VFP conventions (even if soft-float).	*/
d11413 1
a11413 1
	/* No additional flags to set.	*/
d11424 1
a11424 1
       empty, debug section called .arm.atpcs.	*/
d11449 1
a11449 1
    case ARM_3:			/* Also ARM_250.  */
d11453 1
a11453 1
    case ARM_6:			/* Also ARM_7.	*/
d11491 6
a11496 1
/* Command line processing.  */
d11498 8
a11505 3
/* md_parse_option
      Invocation line includes a switch not recognized by the base assembler.
      See if it's a processor-specific option.
d11507 68
a11574 4
      This routine is somewhat complicated by the need for backwards
      compatibility (since older releases of gcc can't be changed).
      The new options try to make the interface as compatible as
      possible with GCC.
d11576 4
a11579 1
      New options (supported) are:
d11581 4
a11584 8
	      -mcpu=<cpu name>		 Assemble for selected processor
	      -march=<architecture name> Assemble for selected architecture
	      -mfpu=<fpu architecture>	 Assemble for selected FPU.
	      -EB/-mbig-endian		 Big-endian
	      -EL/-mlittle-endian	 Little-endian
	      -k			 Generate PIC code
	      -mthumb			 Start in Thumb mode
	      -mthumb-interwork		 Code supports ARM/Thumb interworking
d11586 4
a11589 1
      For now we will also provide support for:
d11591 26
a11616 7
	      -mapcs-32			 32-bit Program counter
	      -mapcs-26			 26-bit Program counter
	      -macps-float		 Floats passed in FP registers
	      -mapcs-reentrant		 Reentrant code
	      -matpcs
      (sometime these will probably be replaced with -mapcs=<list of options>
      and -matpcs=<list of options>)
d11618 2
a11619 19
      The remaining options are only supported for back-wards compatibility.
      Cpu variants, the arm part is optional:
	      -m[arm]1		      Currently not supported.
	      -m[arm]2, -m[arm]250    Arm 2 and Arm 250 processor
	      -m[arm]3		      Arm 3 processor
	      -m[arm]6[xx],	      Arm 6 processors
	      -m[arm]7[xx][t][[d]m]   Arm 7 processors
	      -m[arm]8[10]	      Arm 8 processors
	      -m[arm]9[20][tdmi]      Arm 9 processors
	      -mstrongarm[110[0]]     StrongARM processors
	      -mxscale		      XScale processors
	      -m[arm]v[2345[t[e]]]    Arm architectures
	      -mall		      All (except the ARM1)
      FP variants:
	      -mfpa10, -mfpa11	      FPA10 and 11 co-processor instructions
	      -mfpe-old		      (No float load/store multiples)
	      -mvfpxd		      VFP Single precision
	      -mvfp		      All VFP
	      -mno-fpu		      Disable all floating point instructions
d11621 2
a11622 8
      The following CPU names are recognized:
	      arm1, arm2, arm250, arm3, arm6, arm600, arm610, arm620,
	      arm7, arm7m, arm7d, arm7dm, arm7di, arm7dmi, arm70, arm700,
	      arm700i, arm710 arm710t, arm720, arm720t, arm740t, arm710c,
	      arm7100, arm7500, arm7500fe, arm7tdmi, arm8, arm810, arm9,
	      arm920, arm920t, arm940t, arm946, arm966, arm9tdmi, arm9e,
	      arm10t arm10e, arm1020t, arm1020e, arm10200e,
	      strongarm, strongarm110, strongarm1100, strongarm1110, xscale.
d11624 7
a11630 1
      */
d11632 7
a11638 1
const char * md_shortopts = "m:k";
d11640 4
a11643 3
#ifdef ARM_BI_ENDIAN
#define OPTION_EB (OPTION_MD_BASE + 0)
#define OPTION_EL (OPTION_MD_BASE + 1)
d11645 12
a11656 2
#if TARGET_BYTES_BIG_ENDIAN
#define OPTION_EB (OPTION_MD_BASE + 0)
d11658 2
a11659 2
#define OPTION_EL (OPTION_MD_BASE + 1)
#endif
d11661 4
d11666 2
a11667 1
struct option md_longopts[] =
d11669 15
a11683 5
#ifdef OPTION_EB
  {"EB", no_argument, NULL, OPTION_EB},
#endif
#ifdef OPTION_EL
  {"EL", no_argument, NULL, OPTION_EL},
a11684 2
  {NULL, no_argument, NULL, 0}
};
d11686 2
a11687 1
size_t md_longopts_size = sizeof (md_longopts);
d11689 4
a11692 1
struct arm_option_table
d11694 24
a11717 6
  char *option;		/* Option name to match.  */
  char *help;		/* Help information.  */
  int  *var;		/* Variable to change.	*/
  int	value;		/* What to change it to.  */
  char *deprecated;	/* If non-null, print this message.  */
};
d11719 2
a11720 15
struct arm_option_table arm_opts[] =
{
  {"k",	     N_("generate PIC code"),	   &pic_code,	 1, NULL},
  {"mthumb", N_("assemble Thumb code"),	   &thumb_mode,	 1, NULL},
  {"mthumb-interwork", N_("support ARM/Thumb interworking"),
   &support_interwork, 1, NULL},
  {"mapcs-32", N_("code uses 32-bit program counter"), &uses_apcs_26, 0, NULL},
  {"mapcs-26", N_("code uses 26-bit program counter"), &uses_apcs_26, 1, NULL},
  {"mapcs-float", N_("floating point args are in fp regs"), &uses_apcs_float,
   1, NULL},
  {"mapcs-reentrant", N_("re-entrant code"), &pic_code, 1, NULL},
  {"matpcs", N_("code is ATPCS conformant"), &atpcs, 1, NULL},
  {"mbig-endian", N_("assemble for big-endian"), &target_big_endian, 1, NULL},
  {"mlittle-endian", N_("assemble for little-endian"), &target_big_endian, 0,
   NULL},
d11722 12
a11733 3
  /* These are recognized by the assembler, but have no affect on code.	 */
  {"mapcs-frame", N_("use frame pointer"), NULL, 0, NULL},
  {"mapcs-stack-check", N_("use stack size checking"), NULL, 0, NULL},
d11735 2917
a14651 80
  /* DON'T add any new processors to this list -- we want the whole list
     to go away...  Add them to the processors table instead.  */
  {"marm1",	 NULL, &legacy_cpu, ARM_ARCH_V1,  N_("use -mcpu=arm1")},
  {"m1",	 NULL, &legacy_cpu, ARM_ARCH_V1,  N_("use -mcpu=arm1")},
  {"marm2",	 NULL, &legacy_cpu, ARM_ARCH_V2,  N_("use -mcpu=arm2")},
  {"m2",	 NULL, &legacy_cpu, ARM_ARCH_V2,  N_("use -mcpu=arm2")},
  {"marm250",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm250")},
  {"m250",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm250")},
  {"marm3",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm3")},
  {"m3",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm3")},
  {"marm6",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm6")},
  {"m6",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm6")},
  {"marm600",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm600")},
  {"m600",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm600")},
  {"marm610",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm610")},
  {"m610",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm610")},
  {"marm620",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm620")},
  {"m620",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm620")},
  {"marm7",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7")},
  {"m7",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7")},
  {"marm70",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm70")},
  {"m70",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm70")},
  {"marm700",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700")},
  {"m700",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700")},
  {"marm700i",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700i")},
  {"m700i",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700i")},
  {"marm710",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710")},
  {"m710",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710")},
  {"marm710c",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710c")},
  {"m710c",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710c")},
  {"marm720",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm720")},
  {"m720",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm720")},
  {"marm7d",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7d")},
  {"m7d",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7d")},
  {"marm7di",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7di")},
  {"m7di",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7di")},
  {"marm7m",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7m")},
  {"m7m",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7m")},
  {"marm7dm",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dm")},
  {"m7dm",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dm")},
  {"marm7dmi",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dmi")},
  {"m7dmi",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dmi")},
  {"marm7100",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7100")},
  {"m7100",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7100")},
  {"marm7500",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500")},
  {"m7500",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500")},
  {"marm7500fe", NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500fe")},
  {"m7500fe",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500fe")},
  {"marm7t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"m7t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"marm7tdmi",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"m7tdmi",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
  {"marm710t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm710t")},
  {"m710t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm710t")},
  {"marm720t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm720t")},
  {"m720t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm720t")},
  {"marm740t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm740t")},
  {"m740t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm740t")},
  {"marm8",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm8")},
  {"m8",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm8")},
  {"marm810",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm810")},
  {"m810",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm810")},
  {"marm9",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9")},
  {"m9",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9")},
  {"marm9tdmi",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9tdmi")},
  {"m9tdmi",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9tdmi")},
  {"marm920",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm920")},
  {"m920",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm920")},
  {"marm940",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm940")},
  {"m940",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm940")},
  {"mstrongarm", NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=strongarm")},
  {"mstrongarm110", NULL, &legacy_cpu, ARM_ARCH_V4,
   N_("use -mcpu=strongarm110")},
  {"mstrongarm1100", NULL, &legacy_cpu, ARM_ARCH_V4,
   N_("use -mcpu=strongarm1100")},
  {"mstrongarm1110", NULL, &legacy_cpu, ARM_ARCH_V4,
   N_("use -mcpu=strongarm1110")},
  {"mxscale",	 NULL, &legacy_cpu, ARM_ARCH_XSCALE, N_("use -mcpu=xscale")},
  {"miwmmxt",	 NULL, &legacy_cpu, ARM_ARCH_IWMMXT, N_("use -mcpu=iwmmxt")},
  {"mall",	 NULL, &legacy_cpu, ARM_ANY,	  N_("use -mcpu=all")},
d14653 14
a14666 19
  /* Architecture variants -- don't add any more to this list either.  */
  {"mv2",	 NULL, &legacy_cpu, ARM_ARCH_V2,  N_("use -march=armv2")},
  {"marmv2",	 NULL, &legacy_cpu, ARM_ARCH_V2,  N_("use -march=armv2")},
  {"mv2a",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -march=armv2a")},
  {"marmv2a",	 NULL, &legacy_cpu, ARM_ARCH_V2S, N_("use -march=armv2a")},
  {"mv3",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -march=armv3")},
  {"marmv3",	 NULL, &legacy_cpu, ARM_ARCH_V3,  N_("use -march=armv3")},
  {"mv3m",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -march=armv3m")},
  {"marmv3m",	 NULL, &legacy_cpu, ARM_ARCH_V3M, N_("use -march=armv3m")},
  {"mv4",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -march=armv4")},
  {"marmv4",	 NULL, &legacy_cpu, ARM_ARCH_V4,  N_("use -march=armv4")},
  {"mv4t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -march=armv4t")},
  {"marmv4t",	 NULL, &legacy_cpu, ARM_ARCH_V4T, N_("use -march=armv4t")},
  {"mv5",	 NULL, &legacy_cpu, ARM_ARCH_V5,  N_("use -march=armv5")},
  {"marmv5",	 NULL, &legacy_cpu, ARM_ARCH_V5,  N_("use -march=armv5")},
  {"mv5t",	 NULL, &legacy_cpu, ARM_ARCH_V5T, N_("use -march=armv5t")},
  {"marmv5t",	 NULL, &legacy_cpu, ARM_ARCH_V5T, N_("use -march=armv5t")},
  {"mv5e",	 NULL, &legacy_cpu, ARM_ARCH_V5TE, N_("use -march=armv5te")},
  {"marmv5e",	 NULL, &legacy_cpu, ARM_ARCH_V5TE, N_("use -march=armv5te")},
a14667 6
  /* Floating point variants -- don't add any more to this list either.	 */
  {"mfpe-old", NULL, &legacy_fpu, FPU_ARCH_FPE, N_("use -mfpu=fpe")},
  {"mfpa10",   NULL, &legacy_fpu, FPU_ARCH_FPA, N_("use -mfpu=fpa10")},
  {"mfpa11",   NULL, &legacy_fpu, FPU_ARCH_FPA, N_("use -mfpu=fpa11")},
  {"mno-fpu",  NULL, &legacy_fpu, 0,
   N_("use either -mfpu=softfpa or -mfpu=softvfp")},
d14669 1
a14669 2
  {NULL, NULL, NULL, 0, NULL}
};
d14671 2
a14672 1
struct arm_cpu_option_table
d14674 168
a14841 6
  char *name;
  int	value;
  /* For some CPUs we assume an FPU unless the user explicitly sets
     -mfpu=...	*/
  int	default_fpu;
};
d14843 2
a14844 3
/* This list should, at a minimum, contain all the cpu names
   recognized by GCC.  */
static struct arm_cpu_option_table arm_cpus[] =
d14846 50
a14895 79
  {"all",		ARM_ANY,	 FPU_ARCH_FPA},
  {"arm1",		ARM_ARCH_V1,	 FPU_ARCH_FPA},
  {"arm2",		ARM_ARCH_V2,	 FPU_ARCH_FPA},
  {"arm250",		ARM_ARCH_V2S,	 FPU_ARCH_FPA},
  {"arm3",		ARM_ARCH_V2S,	 FPU_ARCH_FPA},
  {"arm6",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm60",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm600",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm610",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm620",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7m",		ARM_ARCH_V3M,	 FPU_ARCH_FPA},
  {"arm7d",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7dm",		ARM_ARCH_V3M,	 FPU_ARCH_FPA},
  {"arm7di",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7dmi",		ARM_ARCH_V3M,	 FPU_ARCH_FPA},
  {"arm70",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm700",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm700i",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm710",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm710t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm720",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm720t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm740t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm710c",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7100",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7500",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7500fe",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"arm7t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm7tdmi",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm7tdmi-s",	ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm8",		ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"arm810",		ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm",		ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm1",	ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm110",	ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm1100",	ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"strongarm1110",	ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"arm9",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm920",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm920t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm922t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm940t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"arm9tdmi",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  /* For V5 or later processors we default to using VFP; but the user
     should really set the FPU type explicitly.	 */
  {"arm9e-r0",		ARM_ARCH_V5TExP, FPU_ARCH_VFP_V2},
  {"arm9e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm926ej",		ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2},
  {"arm926ejs",		ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2},
  {"arm926ej-s",	ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2},
  {"arm946e-r0",	ARM_ARCH_V5TExP, FPU_ARCH_VFP_V2},
  {"arm946e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm966e-r0",	ARM_ARCH_V5TExP, FPU_ARCH_VFP_V2},
  {"arm966e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm10t",		ARM_ARCH_V5T,	 FPU_ARCH_VFP_V1},
  {"arm10e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm1020",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm1020t",		ARM_ARCH_V5T,	 FPU_ARCH_VFP_V1},
  {"arm1020e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2},
  {"arm1026ejs",	ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2},
  {"arm1026ej-s",	ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2},
  {"arm1136js",		ARM_ARCH_V6,	 FPU_NONE},
  {"arm1136j-s",	ARM_ARCH_V6,	 FPU_NONE},
  {"arm1136jfs",	ARM_ARCH_V6,	 FPU_ARCH_VFP_V2},
  {"arm1136jf-s",	ARM_ARCH_V6,	 FPU_ARCH_VFP_V2},
  {"mpcore",		ARM_ARCH_V6K,	 FPU_ARCH_VFP_V2},
  {"mpcorenovfp",	ARM_ARCH_V6K,	 FPU_NONE},
  {"arm1176jz-s",	ARM_ARCH_V6ZK,	 FPU_NONE},
  {"arm1176jzf-s",	ARM_ARCH_V6ZK,	 FPU_ARCH_VFP_V2},
  /* ??? XSCALE is really an architecture.  */
  {"xscale",		ARM_ARCH_XSCALE, FPU_ARCH_VFP_V2},
  /* ??? iwmmxt is not a processor.  */
  {"iwmmxt",		ARM_ARCH_IWMMXT, FPU_ARCH_VFP_V2},
  {"i80200",		ARM_ARCH_XSCALE, FPU_ARCH_VFP_V2},
  /* Maverick */
  {"ep9312",		ARM_ARCH_V4T | ARM_CEXT_MAVERICK, FPU_ARCH_MAVERICK},
  {NULL, 0, 0}
};
d14897 2
a14898 1
struct arm_arch_option_table
d14900 2
a14901 4
  char *name;
  int	value;
  int	default_fpu;
};
d14903 8
a14910 34
/* This list should, at a minimum, contain all the architecture names
   recognized by GCC.  */
static struct arm_arch_option_table arm_archs[] =
{
  {"all",		ARM_ANY,	 FPU_ARCH_FPA},
  {"armv1",		ARM_ARCH_V1,	 FPU_ARCH_FPA},
  {"armv2",		ARM_ARCH_V2,	 FPU_ARCH_FPA},
  {"armv2a",		ARM_ARCH_V2S,	 FPU_ARCH_FPA},
  {"armv2s",		ARM_ARCH_V2S,	 FPU_ARCH_FPA},
  {"armv3",		ARM_ARCH_V3,	 FPU_ARCH_FPA},
  {"armv3m",		ARM_ARCH_V3M,	 FPU_ARCH_FPA},
  {"armv4",		ARM_ARCH_V4,	 FPU_ARCH_FPA},
  {"armv4xm",		ARM_ARCH_V4xM,	 FPU_ARCH_FPA},
  {"armv4t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA},
  {"armv4txm",		ARM_ARCH_V4TxM,	 FPU_ARCH_FPA},
  {"armv5",		ARM_ARCH_V5,	 FPU_ARCH_VFP},
  {"armv5t",		ARM_ARCH_V5T,	 FPU_ARCH_VFP},
  {"armv5txm",		ARM_ARCH_V5TxM,	 FPU_ARCH_VFP},
  {"armv5te",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP},
  {"armv5texp",		ARM_ARCH_V5TExP, FPU_ARCH_VFP},
  {"armv5tej",		ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP},
  {"armv6",		ARM_ARCH_V6,	 FPU_ARCH_VFP},
  {"armv6j",		ARM_ARCH_V6,	 FPU_ARCH_VFP},
  {"armv6k",		ARM_ARCH_V6K,	 FPU_ARCH_VFP},
  {"armv6z",		ARM_ARCH_V6Z,	 FPU_ARCH_VFP},
  {"armv6zk",		ARM_ARCH_V6ZK,	 FPU_ARCH_VFP},
  {"armv6t2",		ARM_ARCH_V6T2,	 FPU_ARCH_VFP},
  {"armv6kt2",		ARM_ARCH_V6KT2,	 FPU_ARCH_VFP},
  {"armv6zt2",		ARM_ARCH_V6ZT2,	 FPU_ARCH_VFP},
  {"armv6zkt2",		ARM_ARCH_V6ZKT2, FPU_ARCH_VFP},
  {"xscale",		ARM_ARCH_XSCALE, FPU_ARCH_VFP},
  {"iwmmxt",		ARM_ARCH_IWMMXT, FPU_ARCH_VFP},
  {NULL, 0, 0}
};
d14912 6
a14917 6
/* ISA extensions in the co-processor space.  */
struct arm_option_value_table
{
  char *name;
  int value;
};
d14919 2
a14920 7
static struct arm_option_value_table arm_extensions[] =
{
  {"maverick",		ARM_CEXT_MAVERICK},
  {"xscale",		ARM_CEXT_XSCALE},
  {"iwmmxt",		ARM_CEXT_IWMMXT},
  {NULL,		0}
};
d14922 3
a14924 26
/* This list should, at a minimum, contain all the fpu names
   recognized by GCC.  */
static struct arm_option_value_table arm_fpus[] =
{
  {"softfpa",		FPU_NONE},
  {"fpe",		FPU_ARCH_FPE},
  {"fpe2",		FPU_ARCH_FPE},
  {"fpe3",		FPU_ARCH_FPA},	/* Third release supports LFM/SFM.  */
  {"fpa",		FPU_ARCH_FPA},
  {"fpa10",		FPU_ARCH_FPA},
  {"fpa11",		FPU_ARCH_FPA},
  {"arm7500fe",		FPU_ARCH_FPA},
  {"softvfp",		FPU_ARCH_VFP},
  {"softvfp+vfp",	FPU_ARCH_VFP_V2},
  {"vfp",		FPU_ARCH_VFP_V2},
  {"vfp9",		FPU_ARCH_VFP_V2},
  {"vfp10",		FPU_ARCH_VFP_V2},
  {"vfp10-r0",		FPU_ARCH_VFP_V1},
  {"vfpxd",		FPU_ARCH_VFP_V1xD},
  {"arm1020t",		FPU_ARCH_VFP_V1},
  {"arm1020e",		FPU_ARCH_VFP_V2},
  {"arm1136jfs",	FPU_ARCH_VFP_V2},
  {"arm1136jf-s",	FPU_ARCH_VFP_V2},
  {"maverick",		FPU_ARCH_MAVERICK},
  {NULL, 0}
};
d14926 6
a14931 7
static struct arm_option_value_table arm_float_abis[] =
{
  {"hard",	ARM_FLOAT_ABI_HARD},
  {"softfp",	ARM_FLOAT_ABI_SOFTFP},
  {"soft",	ARM_FLOAT_ABI_SOFT},
  {NULL, 0}
};
a14932 9
#ifdef OBJ_ELF
/* We only know how to output GNU and ver 4 (AAELF) formats.  */
static struct arm_option_value_table arm_eabis[] =
{
  {"gnu",	EF_ARM_EABI_UNKNOWN},
  {"4",		EF_ARM_EABI_VER4},
  {NULL, 0}
};
#endif
d14934 1
a14934 7
struct arm_long_option_table
{
  char * option;		/* Substring to match.	*/
  char * help;			/* Help information.  */
  int (* func) (char * subopt);	/* Function to decode sub-option.  */
  char * deprecated;		/* If non-null, print this message.  */
};
d14937 1
a14937 1
arm_parse_extension (char * str, int * opt_p)
d14939 4
a14942 1
  while (str != NULL && *str != 0)
d14944 5
a14948 3
      struct arm_option_value_table * opt;
      char * ext;
      int optlen;
d14950 9
a14958 5
      if (*str != '+')
	{
	  as_bad (_("invalid architectural extension"));
	  return 0;
	}
d14960 1
a14960 2
      str++;
      ext = strchr (str, '+');
d14962 4
a14965 4
      if (ext != NULL)
	optlen = ext - str;
      else
	optlen = strlen (str);
d14967 2
a14968 5
      if (optlen == 0)
	{
	  as_bad (_("missing architectural extension"));
	  return 0;
	}
d14970 6
a14975 6
      for (opt = arm_extensions; opt->name != NULL; opt++)
	if (strncmp (opt->name, str, optlen) == 0)
	  {
	    *opt_p |= opt->value;
	    break;
	  }
d14977 3
a14979 5
      if (opt->name == NULL)
	{
	  as_bad (_("unknown architectural extnsion `%s'"), str);
	  return 0;
	}
d14981 2
a14982 2
      str = ext;
    };
d14984 1
a14984 2
  return 1;
}
d14986 2
a14987 2
static int
arm_parse_cpu (char * str)
d14989 3
a14991 3
  struct arm_cpu_option_table * opt;
  char * ext = strchr (str, '+');
  int optlen;
d14993 3
a14995 2
  if (ext != NULL)
    optlen = ext - str;
d14997 1
a14997 1
    optlen = strlen (str);
d14999 1
a14999 1
  if (optlen == 0)
d15001 3
a15003 2
      as_bad (_("missing cpu name `%s'"), str);
      return 0;
d15006 8
a15013 5
  for (opt = arm_cpus; opt->name != NULL; opt++)
    if (strncmp (opt->name, str, optlen) == 0)
      {
	mcpu_cpu_opt = opt->value;
	mcpu_fpu_opt = opt->default_fpu;
d15015 1
a15015 2
	if (ext != NULL)
	  return arm_parse_extension (ext, &mcpu_cpu_opt);
d15017 6
a15022 2
	return 1;
      }
d15024 7
a15030 2
  as_bad (_("unknown cpu `%s'"), str);
  return 0;
d15033 4
a15036 2
static int
arm_parse_arch (char * str)
d15038 4
a15041 3
  struct arm_arch_option_table *opt;
  char *ext = strchr (str, '+');
  int optlen;
d15043 8
a15050 2
  if (ext != NULL)
    optlen = ext - str;
d15052 1
a15052 1
    optlen = strlen (str);
d15054 1
a15054 1
  if (optlen == 0)
d15056 3
a15058 2
      as_bad (_("missing architecture name `%s'"), str);
      return 0;
d15061 21
d15083 2
a15084 5
  for (opt = arm_archs; opt->name != NULL; opt++)
    if (streq (opt->name, str))
      {
	march_cpu_opt = opt->value;
	march_fpu_opt = opt->default_fpu;
d15086 3
a15088 2
	if (ext != NULL)
	  return arm_parse_extension (ext, &march_cpu_opt);
d15090 1
a15090 5
	return 1;
      }

  as_bad (_("unknown architecture `%s'\n"), str);
  return 0;
d15093 1
a15093 4
static int
arm_parse_fpu (char * str)
{
  struct arm_option_value_table * opt;
d15095 2
a15096 6
  for (opt = arm_fpus; opt->name != NULL; opt++)
    if (streq (opt->name, str))
      {
	mfpu_opt = opt->value;
	return 1;
      }
d15098 2
a15099 6
  as_bad (_("unknown floating point format `%s'\n"), str);
  return 0;
}

static int
arm_parse_float_abi (char * str)
d15101 4
a15104 1
  struct arm_option_value_table * opt;
d15106 3
a15108 6
  for (opt = arm_float_abis; opt->name != NULL; opt++)
    if (streq (opt->name, str))
      {
	mfloat_abi_opt = opt->value;
	return 1;
      }
d15110 2
a15111 3
  as_bad (_("unknown floating point abi `%s'\n"), str);
  return 0;
}
d15113 3
a15115 5
#ifdef OBJ_ELF
static int
arm_parse_eabi (char * str)
{
  struct arm_option_value_table *opt;
d15117 2
a15118 10
  for (opt = arm_eabis; opt->name != NULL; opt++)
    if (streq (opt->name, str))
      {
	meabi_flags = opt->value;
	return 1;
      }
  as_bad (_("unknown EABI `%s'\n"), str);
  return 0;
}
#endif
d15120 16
a15135 16
struct arm_long_option_table arm_long_opts[] =
{
  {"mcpu=", N_("<cpu name>\t  assemble for CPU <cpu name>"),
   arm_parse_cpu, NULL},
  {"march=", N_("<arch name>\t  assemble for architecture <arch name>"),
   arm_parse_arch, NULL},
  {"mfpu=", N_("<fpu name>\t  assemble for FPU architecture <fpu name>"),
   arm_parse_fpu, NULL},
  {"mfloat-abi=", N_("<abi>\t  assemble for floating point ABI <abi>"),
   arm_parse_float_abi, NULL},
#ifdef OBJ_ELF
  {"meabi=", N_("<ver>\t  assemble for eabi version <ver>"),
   arm_parse_eabi, NULL},
#endif
  {NULL, NULL, 0, NULL}
};
d15137 7
a15143 5
int
md_parse_option (int c, char * arg)
{
  struct arm_option_table *opt;
  struct arm_long_option_table *lopt;
d15145 1
a15145 1
  switch (c)
d15147 5
a15151 5
#ifdef OPTION_EB
    case OPTION_EB:
      target_big_endian = 1;
      break;
#endif
d15153 3
a15155 5
#ifdef OPTION_EL
    case OPTION_EL:
      target_big_endian = 0;
      break;
#endif
d15157 2
a15158 4
    case 'a':
      /* Listing option.  Just ignore these, we don't support additional
	 ones.	*/
      return 0;
d15160 4
a15163 13
    default:
      for (opt = arm_opts; opt->option != NULL; opt++)
	{
	  if (c == opt->option[0]
	      && ((arg == NULL && opt->option[1] == 0)
		  || streq (arg, opt->option + 1)))
	    {
#if WARN_DEPRECATED
	      /* If the option is deprecated, tell the user.  */
	      if (opt->deprecated != NULL)
		as_tsktsk (_("option `-%c%s' is deprecated: %s"), c,
			   arg ? arg : "", _(opt->deprecated));
#endif
d15165 4
a15168 2
	      if (opt->var != NULL)
		*opt->var = opt->value;
d15170 9
a15178 3
	      return 1;
	    }
	}
d15180 1
a15180 14
      for (lopt = arm_long_opts; lopt->option != NULL; lopt++)
	{
	  /* These options are expected to have an argument.  */
	  if (c == lopt->option[0]
	      && arg != NULL
	      && strncmp (arg, lopt->option + 1,
			  strlen (lopt->option + 1)) == 0)
	    {
#if WARN_DEPRECATED
	      /* If the option is deprecated, tell the user.  */
	      if (lopt->deprecated != NULL)
		as_tsktsk (_("option `-%c%s' is deprecated: %s"), c, arg,
			   _(lopt->deprecated));
#endif
d15182 6
a15187 4
	      /* Call the sup-option parser.  */
	      return lopt->func (arg + strlen (lopt->option) - 1);
	    }
	}
d15189 1
a15189 2
      return 0;
    }
d15191 1
a15191 2
  return 1;
}
d15193 2
a15194 2
void
md_show_usage (FILE * fp)
d15196 1
a15196 2
  struct arm_option_table *opt;
  struct arm_long_option_table *lopt;
d15198 3
a15200 1
  fprintf (fp, _(" ARM-specific assembler options:\n"));
d15202 2
a15203 3
  for (opt = arm_opts; opt->option != NULL; opt++)
    if (opt->help != NULL)
      fprintf (fp, "  -%-23s%s\n", opt->option, _(opt->help));
d15205 1
a15205 3
  for (lopt = arm_long_opts; lopt->option != NULL; lopt++)
    if (lopt->help != NULL)
      fprintf (fp, "  -%s%s\n", lopt->option, _(lopt->help));
d15207 5
a15211 3
#ifdef OPTION_EB
  fprintf (fp, _("\
  -EB                     assemble code for a big-endian cpu\n"));
d15214 39
a15252 3
#ifdef OPTION_EL
  fprintf (fp, _("\
  -EL                     assemble code for a little-endian cpu\n"));
d15254 5
a15258 1
}
@


1.1.101.5
log
@GNU binutils and debugger as of today
@
text
@d229 11
a239 11
    signed int imm;
    unsigned present	: 1;  /* Operand present.  */
    unsigned isreg	: 1;  /* Operand was a register.  */
    unsigned immisreg	: 1;  /* .imm field is a second register.  */
    unsigned hasreloc	: 1;  /* Operand has relocation suffix.  */
    unsigned writeback	: 1;  /* Operand has trailing !  */
    unsigned preind	: 1;  /* Preindexed address.  */
    unsigned postind	: 1;  /* Postindexed address.  */
    unsigned negative	: 1;  /* Index register was negated.  */
    unsigned shifted	: 1;  /* Shift applied to operation.  */
    unsigned shift_kind : 3;  /* Shift operation (enum shift_kind).  */
d488 1
a488 1
#define T_OPCODE_BRANCH 0xe000
d1038 1
a1038 1
parse_vfp_reg_list (char **str, unsigned int *pbase, int dp)
d1417 4
a1420 6
  /* The compiler may generate BL instructions to local labels because
     it needs to perform a branch to a far away location. These labels
     do not have a corresponding ".real_start_of" label.  We check
     both for S_IS_LOCAL and for a leading dot, to give a way to bypass
     the ".real_start_of" convention for nonlocal branches.  */
  if (S_IS_LOCAL (symbolP) || name[0] == '.')
d1423 3
a1425 1
  real_start = ACONCAT ((STUB_NAME, name, NULL));
d1434 2
a1974 7
	      if (reloc == BFD_RELOC_ARM_PLT32)
		{
		  as_bad (_("(plt) is only valid on branch targets"));
		  reloc = BFD_RELOC_UNUSED;
		  size = 0;
		}

d1976 1
a1976 1
		as_bad (_("%s relocations do not fit in %d bytes"),
d2333 1
a2333 1
  unsigned int reg;
d3074 1
a3074 1
   is deferred to md_apply_fix.  */
d3125 1
a3125 1
      /* Convert to decoded value.  md_apply_fix will put it back.  */
d3244 1
a3244 1
			       0, 255, TRUE) == FAIL)
d3572 1
a3572 1
parse_operands (char *str, const unsigned char *pattern)
d3980 1
a3980 1
   if any, is handled by md_apply_fix.	 */
d4080 2
d4112 2
d4166 2
d4334 3
a4337 1
  inst.reloc.exp.X_add_number -= 8;
d4353 3
a4357 1
  inst.reloc.exp.X_add_number -= 8;
d4437 1
d4442 1
a4443 1
  inst.reloc.pc_rel = 1;
d4477 1
a4477 1
      inst.instruction = 0xfa000000;
d4654 2
a4655 2
	       && ((unsigned) inst.operands[2].imm == inst.operands[0].reg
		   || (unsigned) inst.operands[2].imm == inst.operands[1].reg))
d6133 1
a6133 1
      inst.instruction = 0xf000e800;
d6146 1
a6146 1
	  inst.instruction = 0xf000b000;
d6152 1
a6152 1
	  inst.instruction = (inst.cond << 22) | 0xf0008000;
d6162 1
a6162 1
	  inst.instruction = 0xd000 | (inst.cond << 8);
d8128 8
a8135 2
 TCE(b,		a000000, e000,	   1, (EXPr),	     branch, t_branch),
 TCE(bl,	b000000, f000f800, 1, (EXPr),	     branch, t_branch23),
d8138 3
a8140 3
 TCE(adr,	28f0000, 000f,	   2, (RR, EXP),     adr,  t_adr),
  C3(adrl,	28f0000,           2, (RR, EXP),     adrl),
 tCE(nop,	1a00000, nop,	   1, (oI255c),	     nop,  t_nop),
d8148 1
a8148 1
 tC3(asrs,      1b00040, asrs,     3, (RR, oRR, SH), shift, t_shift),
d8158 1
a8158 1
 TCE(cpy,       1a00000, 4600,     2, (RR, RR),      rd_rm, t_cpy),
d8175 1
a8175 1
 TC3(stmfd,     9000000, e9100000, 2, (RRw, REGLST), ldmstm, t_ldmstm),
d9903 2
a9904 5
/* Return the address within the segment that a PC-relative fixup is
   relative to.  For ARM, PC-relative fixups applied to instructions
   are generally relative to the location of the fixup plus 8 bytes.
   Thumb branches are offset by 4, and Thumb loads relative to PC
   require special handling.  */
d9907 1
a9907 1
md_pcrel_from_section (fixS * fixP, segT seg)
d9909 4
a9912 9
  offsetT base = fixP->fx_where + fixP->fx_frag->fr_address;

  /* If this is pc-relative and we are going to emit a relocation
     then we just want to put out any pipeline compensation that the linker
     will need.  Otherwise we want to use the calculated base.  */
  if (fixP->fx_pcrel 
      && ((fixP->fx_addsy && S_GET_SEGMENT (fixP->fx_addsy) != seg)
	  || arm_force_relocation (fixP)))
    base = 0;
d9914 4
a9919 5
      /* PC relative addressing on the Thumb is slightly odd as the
	 bottom two bits of the PC are forced to zero for the
	 calculation.  This happens *after* application of the
	 pipeline offset.  However, Thumb adrl already adjusts for
	 this, so we need not do it again.  */
d9921 1
a9921 1
      return base & ~3;
d9925 1
a9925 1
      return (base + 4) & ~3;
d9927 3
a9929 9
      /* Thumb branches are simply offset by +4.  */
    case BFD_RELOC_THUMB_PCREL_BRANCH7:
    case BFD_RELOC_THUMB_PCREL_BRANCH9:
    case BFD_RELOC_THUMB_PCREL_BRANCH12:
    case BFD_RELOC_THUMB_PCREL_BRANCH20:
    case BFD_RELOC_THUMB_PCREL_BRANCH23:
    case BFD_RELOC_THUMB_PCREL_BRANCH25:
    case BFD_RELOC_THUMB_PCREL_BLX:
      return base + 4;
a9930 5
      /* ARM mode branches are offset by +8.  However, the Windows CE
	 loader expects the relocation not to take this into account.  */
    case BFD_RELOC_ARM_PCREL_BRANCH:
    case BFD_RELOC_ARM_PCREL_BLX:
    case BFD_RELOC_ARM_PLT32:
d9932 3
a9934 1
      return base;
d9936 1
a9936 1
      return base + 8;
a9937 16

      /* ARM mode loads relative to PC are also offset by +8.  Unlike
	 branches, the Windows CE loader *does* expect the relocation
	 to take this into account.  */
    case BFD_RELOC_ARM_OFFSET_IMM:
    case BFD_RELOC_ARM_OFFSET_IMM8:
    case BFD_RELOC_ARM_HWLITERAL:
    case BFD_RELOC_ARM_LITERAL:
    case BFD_RELOC_ARM_CP_OFF_IMM:
      return base + 8;


      /* Other PC-relative relocations are un-offset.  */
    default:
      return base;
    }
d9966 1
a9966 1
/* Subroutine of md_apply_fix.	 Check to see if an immediate can be
d10013 1
a10013 1
/* Subroutine of md_apply_fix.	 Do those data_ops which can take a
d10103 1
a10103 1
md_apply_fix (fixS *	fixP,
d10120 11
d10291 1
d10462 1
d10475 1
a10475 1
      newval = md_chars_to_number (buf, INSN_SIZE);
d10486 1
a10486 1
	  newval = md_chars_to_number (buf, THUMB_SIZE);
d10495 1
a10495 1
	  newval = md_chars_to_number (buf, INSN_SIZE);
d10510 5
d10516 1
a10516 1
    case BFD_RELOC_ARM_PLT32:
d10520 42
a10561 7
	 instruction, in a 24 bit, signed field.  Bits 0 and 1 must be
	 clear, and bits 26 through 32 either all clear or all set. */
      if (value & 0x00000003)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("misaligned branch destination"));
      if ((value & (offsetT)0xfe000000) != (offsetT)0
	  && (value & (offsetT)0xfe000000) != (offsetT)0xfe000000)
d10563 1
a10563 1
		      _("branch out of range"));
d10565 1
a10565 1
      if (fixP->fx_done || !seg->use_rela_p)
d10567 7
a10573 3
	  newval = md_chars_to_number (buf, INSN_SIZE);
	  newval |= (value >> 2) & 0x00ffffff;
	  md_number_to_chars (buf, newval, INSN_SIZE);
d10575 3
d10581 3
a10583 10
      /* BLX allows bit 1 to be set in the branch destination, since
	 it targets a Thumb instruction which is only required to be
	 aligned modulo 2.  Other constraints are as for B/BL.  */
      if (value & 0x00000001)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("misaligned BLX destination"));
      if ((value & (offsetT)0xfe000000) != (offsetT)0
	  && (value & (offsetT)0xfe000000) != (offsetT)0xfe000000)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("branch out of range"));
d10585 6
a10590 5
      if (fixP->fx_done || !seg->use_rela_p)
	{
	  offsetT hbit;
	  hbit   = (value >> 1) & 1;
	  value  = (value >> 2) & 0x00ffffff;
d10592 16
a10607 4
	  newval = md_chars_to_number (buf, INSN_SIZE);
	  newval |= value | hbit << 24;
	  md_number_to_chars (buf, newval, INSN_SIZE);
	}
d10611 9
a10619 4
      /* CZB can only branch forward.  */
      if (value & ~0x7e)
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("branch out of range"));
d10621 9
a10629 3
      if (fixP->fx_done || !seg->use_rela_p)
	{
	  newval = md_chars_to_number (buf, THUMB_SIZE);
d10631 2
a10632 2
	  md_number_to_chars (buf, newval, THUMB_SIZE);
	}
d10636 5
a10640 3
      if ((value & ~0xff) && ((value & ~0xff) != ~0xff))
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("branch out of range"));
d10642 16
a10657 6
      if (fixP->fx_done || !seg->use_rela_p)
	{
	  newval = md_chars_to_number (buf, THUMB_SIZE);
	  newval |= (value & 0x1ff) >> 1;
	  md_number_to_chars (buf, newval, THUMB_SIZE);
	}
d10661 5
a10665 3
      if ((value & ~0x7ff) && ((value & ~0x7ff) != ~0x7ff))
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("branch out of range"));
d10667 16
a10682 6
      if (fixP->fx_done || !seg->use_rela_p)
	{
	  newval = md_chars_to_number (buf, THUMB_SIZE);
	  newval |= (value & 0xfff) >> 1;
	  md_number_to_chars (buf, newval, THUMB_SIZE);
	}
d10686 37
a10722 3
      if ((value & ~0x1fffff) && ((value & ~0x1fffff) != ~0x1fffff))
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("conditional branch out of range"));
d10724 3
a10726 4
      if (fixP->fx_done || !seg->use_rela_p)
	{
	  offsetT newval2;
	  addressT S, J1, J2, lo, hi;
d10728 3
a10730 13
	  S  = (value & 0x00100000) >> 20;
	  J2 = (value & 0x00080000) >> 19;
	  J1 = (value & 0x00040000) >> 18;
	  hi = (value & 0x0003f000) >> 12;
	  lo = (value & 0x00000ffe) >> 1;

	  newval   = md_chars_to_number (buf, THUMB_SIZE);
	  newval2  = md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);
	  newval  |= (S << 10) | hi;
	  newval2 |= (J1 << 13) | (J2 << 11) | lo;
	  md_number_to_chars (buf, newval, THUMB_SIZE);
	  md_number_to_chars (buf + THUMB_SIZE, newval2, THUMB_SIZE);
	}
d10735 43
a10777 3
      if ((value & ~0x3fffff) && ((value & ~0x3fffff) != ~0x3fffff))
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("branch out of range"));
d10779 10
a10788 17
      if (fixP->fx_r_type == BFD_RELOC_THUMB_PCREL_BLX)
	/* For a BLX instruction, make sure that the relocation is rounded up
	   to a word boundary.  This follows the semantics of the instruction
	   which specifies that bit 1 of the target address will come from bit
	   1 of the base address.  */
	value = (value + 1) & ~ 1;

      if (fixP->fx_done || !seg->use_rela_p)
	{
	  offsetT newval2;

	  newval   = md_chars_to_number (buf, THUMB_SIZE);
	  newval2  = md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);
	  newval  |= (value & 0x7fffff) >> 12;
	  newval2 |= (value & 0xfff) >> 1;
	  md_number_to_chars (buf, newval, THUMB_SIZE);
	  md_number_to_chars (buf + THUMB_SIZE, newval2, THUMB_SIZE);
d10790 1
d10794 24
a10817 3
      if ((value & ~0x1ffffff) && ((value & ~0x1ffffff) != ~0x1ffffff))
	as_bad_where (fixP->fx_file, fixP->fx_line,
		      _("branch out of range"));
d10819 16
a10834 4
      if (fixP->fx_done || !seg->use_rela_p)
	{
	  offsetT newval2;
	  addressT S, I1, I2, lo, hi;
d10836 2
a10837 17
	  S  = (value & 0x01000000) >> 24;
	  I1 = (value & 0x00800000) >> 23;
	  I2 = (value & 0x00400000) >> 22;
	  hi = (value & 0x003ff000) >> 12;
	  lo = (value & 0x00000ffe) >> 1;

	  I1 = !(I1 ^ S);
	  I2 = !(I2 ^ S);

	  newval   = md_chars_to_number (buf, THUMB_SIZE);
	  newval2  = md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);
	  newval  |= (S << 10) | hi;
	  newval2 |= (I1 << 13) | (I2 << 11) | lo;
	  md_number_to_chars (buf, newval, THUMB_SIZE);
	  md_number_to_chars (buf + THUMB_SIZE, newval2, THUMB_SIZE);
	}
      break;
d10839 6
a10844 3
    case BFD_RELOC_8:
      if (fixP->fx_done || !seg->use_rela_p)
	md_number_to_chars (buf, value, 1);
d10848 3
a10850 1
      if (fixP->fx_done || !seg->use_rela_p)
d10852 7
d10873 3
a10875 2
      if (fixP->fx_done || !seg->use_rela_p)
	md_number_to_chars (buf, 0, 4);
d10885 3
a10887 1
      if (fixP->fx_done || !seg->use_rela_p)
d10889 7
d10900 1
a10900 1
      if (fixP->fx_done || !seg->use_rela_p)
d10912 4
d11137 7
a11143 2
  if (fixp->fx_pcrel)
    fixp->fx_offset = reloc->address;
d11145 1
d11356 7
@


