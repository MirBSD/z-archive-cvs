head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_4_4:1.1.1.2
	MIRBSD_10:1.1.1.2.0.2
	MIRBSD_10_BASE:1.1.1.2
	cvs-200704292000:1.1.1.2
	cvs-200606302200:1.1.1.2
	MIRBSD_9_BASE:1.1.1.1
	cvs-200601311430:1.1.1.1
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200507211800:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2005.02.05.17.23.37;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.23.37;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.06.30.22.43.20;	author tg;	state Exp;
branches;
next	;
commitid	10044A5A6F7276AA324;


desc
@@


1.1
log
@Initial revision
@
text
@
package Text::Tabs;

require Exporter;

@@ISA = (Exporter);
@@EXPORT = qw(expand unexpand $tabstop);

use vars qw($VERSION $tabstop $debug);
$VERSION = 98.112801;

use strict;

BEGIN	{
	$tabstop = 8;
	$debug = 0;
}

sub expand
{
	my (@@l) = @@_;
	for $_ (@@l) {
		1 while s/(^|\n)([^\t\n]*)(\t+)/
			$1. $2 . (" " x 
				($tabstop * length($3)
				- (length($2) % $tabstop)))
			/sex;
	}
	return @@l if wantarray;
	return $l[0];
}

sub unexpand
{
	my (@@l) = @@_;
	my @@e;
	my $x;
	my $line;
	my @@lines;
	my $lastbit;
	for $x (@@l) {
		@@lines = split("\n", $x, -1);
		for $line (@@lines) {
			$line = expand($line);
			@@e = split(/(.{$tabstop})/,$line,-1);
			$lastbit = pop(@@e);
			$lastbit = '' unless defined $lastbit;
			$lastbit = "\t"
				if $lastbit eq " "x$tabstop;
			for $_ (@@e) {
				if ($debug) {
					my $x = $_;
					$x =~ s/\t/^I\t/gs;
					print "sub on '$x'\n";
				}
				s/  +$/\t/;
			}
			$line = join('',@@e, $lastbit);
		}
		$x = join("\n", @@lines);
	}
	return @@l if wantarray;
	return $l[0];
}

1;
__END__


=head1 NAME

Text::Tabs -- expand and unexpand tabs per the unix expand(1) and unexpand(1)

=head1 SYNOPSIS

  use Text::Tabs;

  $tabstop = 4;
  @@lines_without_tabs = expand(@@lines_with_tabs);
  @@lines_with_tabs = unexpand(@@lines_without_tabs);

=head1 DESCRIPTION

Text::Tabs does about what the unix utilities expand(1) and unexpand(1)
do.  Given a line with tabs in it, expand will replace the tabs with
the appropriate number of spaces.  Given a line with or without tabs in
it, unexpand will add tabs when it can save bytes by doing so.  Invisible
compression with plain ascii!

=head1 BUGS

expand doesn't handle newlines very quickly -- do not feed it an
entire document in one string.  Instead feed it an array of lines.

=head1 AUTHOR

David Muir Sharnoff <muir@@idiom.com>
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import Perl 5.8.8 from OpenLSD
@
text
@d10 1
a10 1
$VERSION = 2005.0824;
d19 9
a27 15
sub expand {
	my @@l;
	my $pad;
	for ( @@_ ) {
		my $s = '';
		for (split(/^/m, $_, -1)) {
			my $offs = 0;
			s{\t}{
				$pad = $tabstop - (pos() + $offs) % $tabstop;
				$offs += $pad - 1;
				" " x $pad;
			}eg;
			$s .= $_;
		}
		push(@@l, $s);
a68 14
sub expand
{
	my (@@l) = @@_;
	for $_ (@@l) {
		1 while s/(^|\n)([^\t\n]*)(\t+)/
			$1. $2 . (" " x 
				($tabstop * length($3)
				- (length($2) % $tabstop)))
			/sex;
	}
	return @@l if wantarray;
	return $l[0];
}

d95 1
a95 6
=head1 LICENSE

Copyright (C) 1996-2002,2005 David Muir Sharnoff.  
Copyright (C) 2005 Aristotle Pagaltzis 
This module may be modified, used, copied, and redistributed at your own risk.
Publicly redistributed modified versions must use a different name.
d97 1
@

