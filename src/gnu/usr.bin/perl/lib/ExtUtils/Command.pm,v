head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_4_4:1.1.1.2
	MIRBSD_10:1.1.1.2.0.2
	MIRBSD_10_BASE:1.1.1.2
	cvs-200704292000:1.1.1.2
	cvs-200606302200:1.1.1.2
	MIRBSD_9_BASE:1.1.1.1
	cvs-200601311430:1.1.1.1
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200507211800:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2005.02.05.17.23.22;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.23.22;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.06.30.22.41.36;	author tg;	state Exp;
branches;
next	;
commitid	10044A5A6F7276AA324;


desc
@@


1.1
log
@Initial revision
@
text
@package ExtUtils::Command;

use 5.00503;
use strict;
use Carp;
use File::Copy;
use File::Compare;
use File::Basename;
use File::Path qw(rmtree);
require Exporter;
use vars qw(@@ISA @@EXPORT $VERSION);
@@ISA     = qw(Exporter);
@@EXPORT  = qw(cp rm_f rm_rf mv cat eqtime mkpath touch test_f);
$VERSION = '1.05';

my $Is_VMS = $^O eq 'VMS';

=head1 NAME

ExtUtils::Command - utilities to replace common UNIX commands in Makefiles etc.

=head1 SYNOPSIS

  perl -MExtUtils::Command       -e cat files... > destination
  perl -MExtUtils::Command       -e mv source... destination
  perl -MExtUtils::Command       -e cp source... destination
  perl -MExtUtils::Command       -e touch files...
  perl -MExtUtils::Command       -e rm_f files...
  perl -MExtUtils::Command       -e rm_rf directories...
  perl -MExtUtils::Command       -e mkpath directories...
  perl -MExtUtils::Command       -e eqtime source destination
  perl -MExtUtils::Command       -e test_f file
  perl -MExtUtils::Command=chmod -e chmod mode files...

=head1 DESCRIPTION

The module is used to replace common UNIX commands.  In all cases the
functions work from @@ARGV rather than taking arguments.  This makes
them easier to deal with in Makefiles.

  perl -MExtUtils::Command -e some_command some files to work on

I<NOT>

  perl -MExtUtils::Command -e 'some_command qw(some files to work on)'

Filenames with * and ? will be glob expanded.

=over 4

=cut

# VMS uses % instead of ? to mean "one character"
my $wild_regex = $Is_VMS ? '*%' : '*?';
sub expand_wildcards
{
 @@ARGV = map(/[$wild_regex]/o ? glob($_) : $_,@@ARGV);
}


=item cat 

Concatenates all files mentioned on command line to STDOUT.

=cut 

sub cat ()
{
 expand_wildcards();
 print while (<>);
}

=item eqtime src dst

Sets modified time of dst to that of src

=cut 

sub eqtime
{
 my ($src,$dst) = @@ARGV;
 local @@ARGV = ($dst);  touch();  # in case $dst doesn't exist
 utime((stat($src))[8,9],$dst);
}

=item rm_rf files....

Removes directories - recursively (even if readonly)

=cut 

sub rm_rf
{
 expand_wildcards();
 rmtree([grep -e $_,@@ARGV],0,0);
}

=item rm_f files....

Removes files (even if readonly)

=cut 

sub rm_f
{
 expand_wildcards();
 foreach (@@ARGV)
  {
   next unless -f $_;
   next if unlink($_);
   chmod(0777,$_);
   next if unlink($_);
   carp "Cannot delete $_:$!";
  }
}

=item touch files ...

Makes files exist, with current timestamp 

=cut 

sub touch {
    my $t    = time;
    expand_wildcards();
    foreach my $file (@@ARGV) {
        open(FILE,">>$file") || die "Cannot write $file:$!";
        close(FILE);
        utime($t,$t,$file);
    }
}

=item mv source... destination

Moves source to destination.
Multiple sources are allowed if destination is an existing directory.

=cut 

sub mv {
    my $dst = pop(@@ARGV);
    expand_wildcards();
    croak("Too many arguments") if (@@ARGV > 1 && ! -d $dst);
    foreach my $src (@@ARGV) {
        move($src,$dst);
    }
}

=item cp source... destination

Copies source to destination.
Multiple sources are allowed if destination is an existing directory.

=cut

sub cp {
    my $dst = pop(@@ARGV);
    expand_wildcards();
    croak("Too many arguments") if (@@ARGV > 1 && ! -d $dst);
    foreach my $src (@@ARGV) {
        copy($src,$dst);
    }
}

=item chmod mode files...

Sets UNIX like permissions 'mode' on all the files.  e.g. 0666

=cut 

sub chmod {
    my $mode = shift(@@ARGV);
    expand_wildcards();
    chmod(oct $mode,@@ARGV) || die "Cannot chmod ".join(' ',$mode,@@ARGV).":$!";
}

=item mkpath directory...

Creates directory, including any parent directories.

=cut 

sub mkpath
{
 expand_wildcards();
 File::Path::mkpath([@@ARGV],0,0777);
}

=item test_f file

Tests if a file exists

=cut 

sub test_f
{
 exit !-f shift(@@ARGV);
}


1;
__END__ 

=back

=head1 BUGS

Should probably be Auto/Self loaded.

=head1 SEE ALSO 

ExtUtils::MakeMaker, ExtUtils::MM_Unix, ExtUtils::MM_Win32

=head1 AUTHOR

Nick Ing-Simmons <F<nick@@ni-s.u-net.com>>.

=cut

@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import Perl 5.8.8 from OpenLSD
@
text
@d11 4
a14 5
use vars qw(@@ISA @@EXPORT @@EXPORT_OK $VERSION);
@@ISA       = qw(Exporter);
@@EXPORT    = qw(cp rm_f rm_rf mv cat eqtime mkpath touch test_f chmod 
                dos2unix);
$VERSION = '1.09';
d24 10
a33 11
  perl -MExtUtils::Command  -e cat files... > destination
  perl -MExtUtils::Command  -e mv source... destination
  perl -MExtUtils::Command  -e cp source... destination
  perl -MExtUtils::Command  -e touch files...
  perl -MExtUtils::Command  -e rm_f files...
  perl -MExtUtils::Command  -e rm_rf directories...
  perl -MExtUtils::Command  -e mkpath directories...
  perl -MExtUtils::Command  -e eqtime source destination
  perl -MExtUtils::Command  -e test_f file
  perl -MExtUtils::Command  -e chmod mode files...
  ...
a46 2
For that use L<Shell::Command>.

d61 1
a61 3
=item cat

    cat file ...
d73 1
a73 3
=item eqtime

    eqtime source destination
d75 1
a75 1
Sets modified time of destination to that of source.
d86 1
a86 1
=item rm_rf
d88 1
a88 3
    rm_rf files or directories ...

Removes files and directories - recursively (even if readonly)
d98 1
a98 3
=item rm_f

    rm_f file ...
d104 11
a114 14
sub rm_f {
    expand_wildcards();

    foreach my $file (@@ARGV) {
        next unless -f $file;

        next if _unlink($file);

        chmod(0777, $file);

        next if _unlink($file);

        carp "Cannot delete $file: $!";
    }
d117 1
a117 14
sub _unlink {
    my $files_unlinked = 0;
    foreach my $file (@@_) {
        my $delete_count = 0;
        $delete_count++ while unlink $file;
        $files_unlinked++ if $delete_count;
    }
    return $files_unlinked;
}


=item touch

    touch file ...
d133 1
a133 7
=item mv

    mv source_file destination_file
    mv source_file source_file destination_dir

Moves source to destination.  Multiple sources are allowed if
destination is an existing directory.
d135 2
a136 1
Returns true if all moves succeeded, false otherwise.
d141 1
d143 3
a145 8
    my @@src = @@ARGV;
    my $dst = pop @@src;

    croak("Too many arguments") if (@@src > 1 && ! -d $dst);

    my $nok = 0;
    foreach my $src (@@src) {
        $nok ||= !move($src,$dst);
a146 1
    return !$nok;
d149 1
a149 4
=item cp

    cp source_file destination_file
    cp source_file source_file destination_dir
d151 2
a152 4
Copies sources to the destination.  Multiple sources are allowed if
destination is an existing directory.

Returns true if all copies succeeded, false otherwise.
d157 1
d159 3
a161 8
    my @@src = @@ARGV;
    my $dst = pop @@src;

    croak("Too many arguments") if (@@src > 1 && ! -d $dst);

    my $nok = 0;
    foreach my $src (@@src) {
        $nok ||= !copy($src,$dst);
a162 1
    return $nok;
d165 1
a165 3
=item chmod

    chmod mode files ...
a171 1
    local @@ARGV = @@ARGV;
a173 16

    if( $Is_VMS ) {
        foreach my $idx (0..$#ARGV) {
            my $path = $ARGV[$idx];
            next unless -d $path;

            # chmod 0777, [.foo.bar] doesn't work on VMS, you have to do
            # chmod 0777, [.foo]bar.dir
            my @@dirs = File::Spec->splitdir( $path );
            $dirs[-1] .= '.dir';
            $path = File::Spec->catfile(@@dirs);

            $ARGV[$idx] = $path;
        }
    }

d177 1
a177 1
=item mkpath
d179 1
a179 3
    mkpath directory ...

Creates directories, including any parent directories.
d189 1
a189 3
=item test_f

    test_f file
d197 1
a197 1
 exit !-f $ARGV[0];
a199 1
=item dos2unix
d201 2
a202 1
    dos2unix files or dirs ...
d204 1
a204 3
Converts DOS and OS/2 linefeeds to Unix style recursively.

=cut
d206 1
a206 22
sub dos2unix {
    require File::Find;
    File::Find::find(sub {
        return if -d;
        return unless -w _;
        return unless -r _;
        return if -B _;

        local $\;

	my $orig = $_;
	my $temp = '.dos2unix_tmp';
	open ORIG, $_ or do { warn "dos2unix can't open $_: $!"; return };
	open TEMP, ">$temp" or 
	    do { warn "dos2unix can't create .dos2unix_tmp: $!"; return };
        while (my $line = <ORIG>) { 
            $line =~ s/\015\012/\012/g;
            print TEMP $line;
        }
	close ORIG;
	close TEMP;
	rename $temp, $orig;
d208 1
a208 4
    }, @@ARGV);
}

=back
d212 1
a212 2
Shell::Command which is these same functions but take arguments normally.

d216 1
a216 3
Nick Ing-Simmons C<ni-s@@cpan.org>

Currently maintained by Michael G Schwern C<schwern@@pobox.com>.
@

