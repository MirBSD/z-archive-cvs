head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_4_4:1.1.1.2
	MIRBSD_10:1.1.1.2.0.2
	MIRBSD_10_BASE:1.1.1.2
	cvs-200704292000:1.1.1.2
	cvs-200606302200:1.1.1.2
	MIRBSD_9_BASE:1.1.1.1
	cvs-200601311430:1.1.1.1
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200507211800:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2005.02.05.17.22.37;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.22.37;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.06.30.22.37.01;	author tg;	state Exp;
branches;
next	;
commitid	10044A5A6F7276AA324;


desc
@@


1.1
log
@Initial revision
@
text
@#!perl

BEGIN {
    chdir 't';
    @@INC = ('../lib', '../ext/B/t');
    require Config;
    if (($Config::Config{'extensions'} !~ /\bB\b/) ){
        print "1..0 # Skip -- Perl configured without B module\n";
        exit 0;
    }
    require './test.pl';
}
use OptreeCheck;
use Config;
plan tests => 11;

SKIP: {
skip "no perlio in this build", 11 unless $Config::Config{useperlio};

pass("SORT OPTIMIZATION");

checkOptree ( name	=> 'sub {sort @@a}',
	      code	=> sub {sort @@a},
	      bcopts	=> '-exec',
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# 1  <;> nextstate(main 424 optree_sort.t:14) v
# 2  <0> pushmark s
# 3  <#> gv[*a] s
# 4  <1> rv2av[t2] lK/1
# 5  <@@> sort K
# 6  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 424 optree_sort.t:14) v
# 2  <0> pushmark s
# 3  <$> gv(*a) s
# 4  <1> rv2av[t1] lK/1
# 5  <@@> sort K
# 6  <1> leavesub[1 ref] K/REFC,1
EONT_EONT

checkOptree ( name	=> 'sort @@a',
	      prog	=> 'sort @@a',
	      bcopts	=> '-exec',
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
1  <0> enter 
2  <;> nextstate(main 1 -e:1) v
3  <0> pushmark s
4  <#> gv[*a] s
5  <1> rv2av[t2] lK/1
6  <@@> sort vK
7  <@@> leave[1 ref] vKP/REFC
EOT_EOT
# 1  <0> enter 
# 2  <;> nextstate(main 1 -e:1) v
# 3  <0> pushmark s
# 4  <$> gv(*a) s
# 5  <1> rv2av[t1] lK/1
# 6  <@@> sort vK
# 7  <@@> leave[1 ref] vKP/REFC
EONT_EONT

checkOptree ( name	=> 'sub {@@a = sort @@a}',
	      code	=> sub {@@a = sort @@a},
	      bcopts	=> '-exec',
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
1  <;> nextstate(main -438 optree.t:244) v
2  <0> pushmark s
3  <0> pushmark s
4  <#> gv[*a] s
5  <1> rv2av[t4] lK/1
6  <@@> sort lK
7  <0> pushmark s
8  <#> gv[*a] s
9  <1> rv2av[t2] lKRM*/1
a  <2> aassign[t\d+] KS/COMMON
b  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 65 optree.t:311) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <$> gv(*a) s
# 5  <1> rv2av[t2] lK/1
# 6  <@@> sort lK
# 7  <0> pushmark s
# 8  <$> gv(*a) s
# 9  <1> rv2av[t1] lKRM*/1
# a  <2> aassign[t3] KS/COMMON
# b  <1> leavesub[1 ref] K/REFC,1
EONT_EONT

checkOptree ( name	=> '@@a = sort @@a',
	      prog	=> '@@a = sort @@a',
	      bcopts	=> '-exec',
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
1  <0> enter 
2  <;> nextstate(main 1 -e:1) v
3  <0> pushmark s
4  <0> pushmark s
5  <#> gv[*a] s
6  <1> rv2av[t4] lKRM*/1
7  <@@> sort lK/INPLACE
8  <@@> leave[1 ref] vKP/REFC
EOT_EOT
# 1  <0> enter 
# 2  <;> nextstate(main 1 -e:1) v
# 3  <0> pushmark s
# 4  <0> pushmark s
# 5  <$> gv(*a) s
# 6  <1> rv2av[t2] lKRM*/1
# 7  <@@> sort lK/INPLACE
# 8  <@@> leave[1 ref] vKP/REFC
EONT_EONT

checkOptree ( name	=> 'sub {@@a = sort @@a; reverse @@a}',
	      code	=> sub {@@a = sort @@a; reverse @@a},
	      bcopts	=> '-exec',
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
1  <;> nextstate(main -438 optree.t:286) v
2  <0> pushmark s
3  <0> pushmark s
4  <#> gv[*a] s
5  <1> rv2av[t4] lKRM*/1
6  <@@> sort lK/INPLACE
7  <;> nextstate(main -438 optree.t:288) v
8  <0> pushmark s
9  <#> gv[*a] s
a  <1> rv2av[t7] lK/1
b  <@@> reverse[t8] K/1
c  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 66 optree.t:345) v
# 2  <0> pushmark s
# 3  <0> pushmark s
# 4  <$> gv(*a) s
# 5  <1> rv2av[t2] lKRM*/1
# 6  <@@> sort lK/INPLACE
# 7  <;> nextstate(main 66 optree.t:346) v
# 8  <0> pushmark s
# 9  <$> gv(*a) s
# a  <1> rv2av[t4] lK/1
# b  <@@> reverse[t5] K/1
# c  <1> leavesub[1 ref] K/REFC,1
EONT_EONT

checkOptree ( name	=> '@@a = sort @@a; reverse @@a',
	      prog	=> '@@a = sort @@a; reverse @@a',
	      bcopts	=> '-exec',
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
1  <0> enter 
2  <;> nextstate(main 1 -e:1) v
3  <0> pushmark s
4  <0> pushmark s
5  <#> gv[*a] s
6  <1> rv2av[t4] lKRM*/1
7  <@@> sort lK/INPLACE
8  <;> nextstate(main 1 -e:1) v
9  <0> pushmark s
a  <#> gv[*a] s
b  <1> rv2av[t7] lK/1
c  <@@> reverse[t8] vK/1
d  <@@> leave[1 ref] vKP/REFC
EOT_EOT
# 1  <0> enter 
# 2  <;> nextstate(main 1 -e:1) v
# 3  <0> pushmark s
# 4  <0> pushmark s
# 5  <$> gv(*a) s
# 6  <1> rv2av[t2] lKRM*/1
# 7  <@@> sort lK/INPLACE
# 8  <;> nextstate(main 1 -e:1) v
# 9  <0> pushmark s
# a  <$> gv(*a) s
# b  <1> rv2av[t4] lK/1
# c  <@@> reverse[t5] vK/1
# d  <@@> leave[1 ref] vKP/REFC
EONT_EONT

checkOptree ( name	=> 'sub {my @@a; @@a = sort @@a}',
	      code	=> sub {my @@a; @@a = sort @@a},
	      bcopts	=> '-exec',
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
1  <;> nextstate(main -437 optree.t:254) v
2  <0> padav[@@a:-437,-436] vM/LVINTRO
3  <;> nextstate(main -436 optree.t:256) v
4  <0> pushmark s
5  <0> pushmark s
6  <0> padav[@@a:-437,-436] l
7  <@@> sort lK
8  <0> pushmark s
9  <0> padav[@@a:-437,-436] lRM*
a  <2> aassign[t\d+] KS/COMMON
b  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 427 optree_sort.t:172) v
# 2  <0> padav[@@a:427,428] vM/LVINTRO
# 3  <;> nextstate(main 428 optree_sort.t:173) v
# 4  <0> pushmark s
# 5  <0> pushmark s
# 6  <0> padav[@@a:427,428] l
# 7  <@@> sort lK
# 8  <0> pushmark s
# 9  <0> padav[@@a:427,428] lRM*
# a  <2> aassign[t2] KS/COMMON
# b  <1> leavesub[1 ref] K/REFC,1
EONT_EONT

checkOptree ( name	=> 'my @@a; @@a = sort @@a',
	      prog	=> 'my @@a; @@a = sort @@a',
	      bcopts	=> '-exec',
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
1  <0> enter 
2  <;> nextstate(main 1 -e:1) v
3  <0> padav[@@a:1,2] vM/LVINTRO
4  <;> nextstate(main 2 -e:1) v
5  <0> pushmark s
6  <0> pushmark s
7  <0> padav[@@a:1,2] lRM*
8  <@@> sort lK/INPLACE
9  <@@> leave[1 ref] vKP/REFC
EOT_EOT
# 1  <0> enter 
# 2  <;> nextstate(main 1 -e:1) v
# 3  <0> padav[@@a:1,2] vM/LVINTRO
# 4  <;> nextstate(main 2 -e:1) v
# 5  <0> pushmark s
# 6  <0> pushmark s
# 7  <0> padav[@@a:1,2] lRM*
# 8  <@@> sort lK/INPLACE
# 9  <@@> leave[1 ref] vKP/REFC
EONT_EONT

checkOptree ( name	=> 'sub {my @@a; @@a = sort @@a; push @@a, 1}',
	      code	=> sub {my @@a; @@a = sort @@a; push @@a, 1},
	      bcopts	=> '-exec',
	      debug	=> 0,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
1  <;> nextstate(main -437 optree.t:325) v
2  <0> padav[@@a:-437,-436] vM/LVINTRO
3  <;> nextstate(main -436 optree.t:325) v
4  <0> pushmark s
5  <0> pushmark s
6  <0> padav[@@a:-437,-436] lRM*
7  <@@> sort lK/INPLACE
8  <;> nextstate(main -436 optree.t:325) v
9  <0> pushmark s
a  <0> padav[@@a:-437,-436] lRM
b  <$> const[IV 1] s
c  <@@> push[t3] sK/2
d  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 429 optree_sort.t:219) v
# 2  <0> padav[@@a:429,430] vM/LVINTRO
# 3  <;> nextstate(main 430 optree_sort.t:220) v
# 4  <0> pushmark s
# 5  <0> pushmark s
# 6  <0> padav[@@a:429,430] lRM*
# 7  <@@> sort lK/INPLACE
# 8  <;> nextstate(main 430 optree_sort.t:220) v
# 9  <0> pushmark s
# a  <0> padav[@@a:429,430] lRM
# b  <$> const(IV 1) s
# c  <@@> push[t3] sK/2
# d  <1> leavesub[1 ref] K/REFC,1
EONT_EONT

checkOptree ( name	=> 'sub {my @@a; @@a = sort @@a; 1}',
	      code	=> sub {my @@a; @@a = sort @@a; 1},
	      bcopts	=> '-exec',
	      debug	=> 0,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
1  <;> nextstate(main -437 optree.t:325) v
2  <0> padav[@@a:-437,-436] vM/LVINTRO
3  <;> nextstate(main -436 optree.t:325) v
4  <0> pushmark s
5  <0> pushmark s
6  <0> padav[@@a:-437,-436] lRM*
7  <@@> sort lK/INPLACE
8  <;> nextstate(main -436 optree.t:346) v
9  <$> const[IV 1] s
a  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# 1  <;> nextstate(main 431 optree_sort.t:250) v
# 2  <0> padav[@@a:431,432] vM/LVINTRO
# 3  <;> nextstate(main 432 optree_sort.t:251) v
# 4  <0> pushmark s
# 5  <0> pushmark s
# 6  <0> padav[@@a:431,432] lRM*
# 7  <@@> sort lK/INPLACE
# 8  <;> nextstate(main 432 optree_sort.t:251) v
# 9  <$> const(IV 1) s
# a  <1> leavesub[1 ref] K/REFC,1
EONT_EONT

} #skip

__END__

@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import Perl 5.8.8 from OpenLSD
@
text
@d4 2
a5 7
    if ($ENV{PERL_CORE}){
	chdir('t') if -d 't';
	@@INC = ('.', '../lib', '../ext/B/t');
    } else {
	unshift @@INC, 't';
	push @@INC, "../../t";
    }
d11 1
a11 1
    # require 'test.pl'; # now done by OptreeCheck
d41 4
a44 7
checkOptree ( name => 'sort @@a',
	      prog => 'sort @@a',
	      errs => [ 'Useless use of sort in void context at -e line 1.',
			'Name "main::a" used only once: possible typo at -e line 1.',
			],
	      bcopts => '-exec',
	      expect => <<'EOT_EOT', expect_nt => <<'EONT_EONT');
d75 1
a75 1
a  <2> aassign[t5] KS/COMMON
a146 1
	      errs      => ['Useless use of reverse in void context at -e line 1.'],
d191 1
a191 1
a  <2> aassign[t2] KS/COMMON
@

