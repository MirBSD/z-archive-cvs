head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_4_4:1.1.1.2
	MIRBSD_10:1.1.1.2.0.2
	MIRBSD_10_BASE:1.1.1.2
	cvs-200704292000:1.1.1.2
	cvs-200606302200:1.1.1.2
	MIRBSD_9_BASE:1.1.1.1
	cvs-200601311430:1.1.1.1
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200507211800:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2005.02.05.17.22.37;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.22.37;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.06.30.22.37.01;	author tg;	state Exp;
branches;
next	;
commitid	10044A5A6F7276AA324;


desc
@@


1.1
log
@Initial revision
@
text
@#!./perl

BEGIN {
    chdir 't';
    @@INC = ('../lib', '../ext/B/t');
    require Config;
    if (($Config::Config{'extensions'} !~ /\bB\b/) ){
        print "1..0 # Skip -- Perl configured without B module\n";
        exit 0;
    }
    require './test.pl';
}

# import checkOptree(), and %gOpts (containing test state)
use OptreeCheck;	# ALSO DOES @@ARGV HANDLING !!!!!!
use Config;

plan tests => 6;

require_ok("B::Concise");

my $out = runperl(
    switches => ["-MO=Concise,BEGIN,CHECK,INIT,END,-exec"],
    prog => q{$a=$b && print q/foo/},
    stderr => 1 );

#print "out:$out\n";

my $src = q[our ($beg, $chk, $init, $end) = qq{'foo'}; BEGIN { $beg++ } CHECK { $chk++ } INIT { $init++ } END { $end++ }];



checkOptree ( name	=> 'BEGIN',
	      bcopts	=> 'BEGIN',
	      prog	=> $src,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# BEGIN 1:
# b  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->b
# 1        <;> nextstate(B::Concise -242 Concise.pm:304) v/2 ->2
# 3        <1> require sK/1 ->4
# 2           <$> const[PV "strict.pm"] s/BARE ->3
# 4        <;> nextstate(B::Concise -242 Concise.pm:304) v/2 ->5
# -        <@@> lineseq K ->-
# 5           <;> nextstate(B::Concise -242 Concise.pm:304) /2 ->6
# a           <1> entersub[t1] KS*/TARG,2 ->b
# 6              <0> pushmark s ->7
# 7              <$> const[PV "strict"] sM ->8
# 8              <$> const[PV "refs"] sM ->9
# 9              <$> method_named[PVIV 1520340202] ->a
# BEGIN 2:
# m  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->m
# c        <;> nextstate(B::Concise -227 Concise.pm:327) v/2 ->d
# e        <1> require sK/1 ->f
# d           <$> const[PV "warnings.pm"] s/BARE ->e
# f        <;> nextstate(B::Concise -227 Concise.pm:327) v/2 ->g
# -        <@@> lineseq K ->-
# g           <;> nextstate(B::Concise -227 Concise.pm:327) /2 ->h
# l           <1> entersub[t1] KS*/TARG,2 ->m
# h              <0> pushmark s ->i
# i              <$> const[PV "warnings"] sM ->j
# j              <$> const[PV "qw"] sM ->k
# k              <$> method_named[PVIV 1520340202] ->l
# BEGIN 3:
# q  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->q
# n        <;> nextstate(main 2 -e:3) v ->o
# p        <1> postinc[t3] sK/1 ->q
# -           <1> ex-rv2sv sKRM/1 ->p
# o              <#> gvsv[*beg] s ->p
EOT_EOT
# BEGIN 1:
# b  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->b
# 1        <;> nextstate(B::Concise -242 Concise.pm:304) v/2 ->2
# 3        <1> require sK/1 ->4
# 2           <$> const(PV "strict.pm") s/BARE ->3
# 4        <;> nextstate(B::Concise -242 Concise.pm:304) v/2 ->5
# -        <@@> lineseq K ->-
# 5           <;> nextstate(B::Concise -242 Concise.pm:304) /2 ->6
# a           <1> entersub[t1] KS*/TARG,2 ->b
# 6              <0> pushmark s ->7
# 7              <$> const(PV "strict") sM ->8
# 8              <$> const(PV "refs") sM ->9
# 9              <$> method_named(PVIV 1520340202) ->a
# BEGIN 2:
# m  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->m
# c        <;> nextstate(B::Concise -227 Concise.pm:327) v/2 ->d
# e        <1> require sK/1 ->f
# d           <$> const(PV "warnings.pm") s/BARE ->e
# f        <;> nextstate(B::Concise -227 Concise.pm:327) v/2 ->g
# -        <@@> lineseq K ->-
# g           <;> nextstate(B::Concise -227 Concise.pm:327) /2 ->h
# l           <1> entersub[t1] KS*/TARG,2 ->m
# h              <0> pushmark s ->i
# i              <$> const(PV "warnings") sM ->j
# j              <$> const(PV "qw") sM ->k
# k              <$> method_named(PVIV 1520340202) ->l
# BEGIN 3:
# q  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->q
# n        <;> nextstate(main 2 -e:3) v ->o
# p        <1> postinc[t2] sK/1 ->q
# -           <1> ex-rv2sv sKRM/1 ->p
# o              <$> gvsv(*beg) s ->p
EONT_EONT


checkOptree ( name	=> 'END',
	      bcopts	=> 'END',
	      prog	=> $src,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# END 1:
# 4  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->4
# 1        <;> nextstate(main 5 -e:6) v ->2
# 3        <1> postinc[t3] sK/1 ->4
# -           <1> ex-rv2sv sKRM/1 ->3
# 2              <#> gvsv[*end] s ->3
EOT_EOT
# END 1:
# 4  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->4
# 1        <;> nextstate(main 5 -e:6) v ->2
# 3        <1> postinc[t2] sK/1 ->4
# -           <1> ex-rv2sv sKRM/1 ->3
# 2              <$> gvsv(*end) s ->3
EONT_EONT


checkOptree ( name	=> 'CHECK',
	      bcopts	=> 'CHECK',
	      prog	=> $src,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# CHECK 1:
# 4  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->4
# 1        <;> nextstate(main 3 -e:4) v ->2
# 3        <1> postinc[t3] sK/1 ->4
# -           <1> ex-rv2sv sKRM/1 ->3
# 2              <#> gvsv[*chk] s ->3
EOT_EOT
# CHECK 1:
# 4  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->4
# 1        <;> nextstate(main 3 -e:4) v ->2
# 3        <1> postinc[t2] sK/1 ->4
# -           <1> ex-rv2sv sKRM/1 ->3
# 2              <$> gvsv(*chk) s ->3
EONT_EONT


checkOptree ( name	=> 'INIT',
	      bcopts	=> 'INIT',
	      #todo	=> 'get working',
	      prog	=> $src,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# INIT 1:
# 4  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->4
# 1        <;> nextstate(main 4 -e:5) v ->2
# 3        <1> postinc[t3] sK/1 ->4
# -           <1> ex-rv2sv sKRM/1 ->3
# 2              <#> gvsv[*init] s ->3
EOT_EOT
# INIT 1:
# 4  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->4
# 1        <;> nextstate(main 4 -e:5) v ->2
# 3        <1> postinc[t2] sK/1 ->4
# -           <1> ex-rv2sv sKRM/1 ->3
# 2              <$> gvsv(*init) s ->3
EONT_EONT


checkOptree ( name	=> 'all of BEGIN END INIT CHECK -exec',
	      bcopts	=> [qw/ BEGIN END INIT CHECK -exec /],
	      #todo	=> 'get working',
	      prog	=> $src,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# BEGIN 1:
# 1  <;> nextstate(B::Concise -242 Concise.pm:304) v/2
# 2  <$> const[PV "strict.pm"] s/BARE
# 3  <1> require sK/1
# 4  <;> nextstate(B::Concise -242 Concise.pm:304) v/2
# 5  <;> nextstate(B::Concise -242 Concise.pm:304) /2
# 6  <0> pushmark s
# 7  <$> const[PV "strict"] sM
# 8  <$> const[PV "refs"] sM
# 9  <$> method_named[PVIV 1520340202] 
# a  <1> entersub[t1] KS*/TARG,2
# b  <1> leavesub[1 ref] K/REFC,1
# BEGIN 2:
# c  <;> nextstate(B::Concise -227 Concise.pm:327) v/2
# d  <$> const[PV "warnings.pm"] s/BARE
# e  <1> require sK/1
# f  <;> nextstate(B::Concise -227 Concise.pm:327) v/2
# g  <;> nextstate(B::Concise -227 Concise.pm:327) /2
# h  <0> pushmark s
# i  <$> const[PV "warnings"] sM
# j  <$> const[PV "qw"] sM
# k  <$> method_named[PVIV 1520340202] 
# l  <1> entersub[t1] KS*/TARG,2
# m  <1> leavesub[1 ref] K/REFC,1
# BEGIN 3:
# n  <;> nextstate(main 2 -e:3) v
# o  <#> gvsv[*beg] s
# p  <1> postinc[t3] sK/1
# q  <1> leavesub[1 ref] K/REFC,1
# END 1:
# r  <;> nextstate(main 5 -e:6) v
# s  <#> gvsv[*end] s
# t  <1> postinc[t3] sK/1
# u  <1> leavesub[1 ref] K/REFC,1
# INIT 1:
# v  <;> nextstate(main 4 -e:5) v
# w  <#> gvsv[*init] s
# x  <1> postinc[t3] sK/1
# y  <1> leavesub[1 ref] K/REFC,1
# CHECK 1:
# z  <;> nextstate(main 3 -e:4) v
# 10 <#> gvsv[*chk] s
# 11 <1> postinc[t3] sK/1
# 12 <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# BEGIN 1:
# 1  <;> nextstate(B::Concise -242 Concise.pm:304) v/2
# 2  <$> const(PV "strict.pm") s/BARE
# 3  <1> require sK/1
# 4  <;> nextstate(B::Concise -242 Concise.pm:304) v/2
# 5  <;> nextstate(B::Concise -242 Concise.pm:304) /2
# 6  <0> pushmark s
# 7  <$> const(PV "strict") sM
# 8  <$> const(PV "refs") sM
# 9  <$> method_named(PVIV 1520340202) 
# a  <1> entersub[t1] KS*/TARG,2
# b  <1> leavesub[1 ref] K/REFC,1
# BEGIN 2:
# c  <;> nextstate(B::Concise -227 Concise.pm:327) v/2
# d  <$> const(PV "warnings.pm") s/BARE
# e  <1> require sK/1
# f  <;> nextstate(B::Concise -227 Concise.pm:327) v/2
# g  <;> nextstate(B::Concise -227 Concise.pm:327) /2
# h  <0> pushmark s
# i  <$> const(PV "warnings") sM
# j  <$> const(PV "qw") sM
# k  <$> method_named(PVIV 1520340202) 
# l  <1> entersub[t1] KS*/TARG,2
# m  <1> leavesub[1 ref] K/REFC,1
# BEGIN 3:
# n  <;> nextstate(main 2 -e:3) v
# o  <$> gvsv(*beg) s
# p  <1> postinc[t2] sK/1
# q  <1> leavesub[1 ref] K/REFC,1
# END 1:
# r  <;> nextstate(main 5 -e:6) v
# s  <$> gvsv(*end) s
# t  <1> postinc[t2] sK/1
# u  <1> leavesub[1 ref] K/REFC,1
# INIT 1:
# v  <;> nextstate(main 4 -e:5) v
# w  <$> gvsv(*init) s
# x  <1> postinc[t2] sK/1
# y  <1> leavesub[1 ref] K/REFC,1
# CHECK 1:
# z  <;> nextstate(main 3 -e:4) v
# 10 <$> gvsv(*chk) s
# 11 <1> postinc[t2] sK/1
# 12 <1> leavesub[1 ref] K/REFC,1
EONT_EONT
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import Perl 5.8.8 from OpenLSD
@
text
@a2 7
# This tests the B:: module(s) with CHECK, BEGIN, END and INIT blocks. The
# text excerpts below marked with "# " in front are the expected output. They
# are there twice, EOT for threading, and EONT for a non-threading Perl. The
# output is matched losely. If the match fails even though the "got" and
# "expected" output look exactly the same, then watch for trailing, invisible
# spaces.

d4 2
a5 7
    if ($ENV{PERL_CORE}){
	chdir('t') if -d 't';
	@@INC = ('.', '../lib', '../ext/B/t');
    } else {
	unshift @@INC, 't';
	push @@INC, "../../t";
    }
d11 1
a11 1
    # require 'test.pl'; # now done by OptreeCheck
d18 1
a18 1
plan tests => 7;
a31 6
my @@warnings_todo;
@@warnings_todo = (todo =>
   "Change 23768 (Remove Carp from warnings.pm) alters expected output, not"
   . "propagated to 5.8.x")
    if $] < 5.009;

a35 1
	      @@warnings_todo,
d40 1
a40 1
# 1        <;> nextstate(B::Concise -234 Concise.pm:328) v/2 ->2
d42 2
a43 2
# 2           <$> const[PV "warnings.pm"] s/BARE ->3
# 4        <;> nextstate(B::Concise -234 Concise.pm:328) v/2 ->5
d45 1
a45 1
# 5           <;> nextstate(B::Concise -234 Concise.pm:328) /2 ->6
d48 2
a49 2
# 7              <$> const[PV "warnings"] sM ->8
# 8              <$> const[PV "qw"] sM ->9
d52 20
a71 6
# f  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->f
# c        <;> nextstate(main 2 -e:1) v ->d
# e        <1> postinc[t3] sK/1 ->f
# -           <1> ex-rv2sv sKRM/1 ->e
# d              <#> gvsv[*beg] s ->e
d76 1
a76 1
# 1        <;> nextstate(B::Concise -234 Concise.pm:328) v/2 ->2
d78 2
a79 2
# 2           <$> const(PV "warnings.pm") s/BARE ->3
# 4        <;> nextstate(B::Concise -234 Concise.pm:328) v/2 ->5
d81 1
a81 1
# 5           <;> nextstate(B::Concise -234 Concise.pm:328) /2 ->6
d84 2
a85 2
# 7              <$> const(PV "warnings") sM ->8
# 8              <$> const(PV "qw") sM ->9
d88 20
a107 6
# f  <1> leavesub[1 ref] K/REFC,1 ->(end)
# -     <@@> lineseq KP ->f
# c        <;> nextstate(main 2 -e:1) v ->d
# e        <1> postinc[t2] sK/1 ->f
# -           <1> ex-rv2sv sKRM/1 ->e
# d              <$> gvsv(*beg) s ->e
d180 1
a181 1
	      @@warnings_todo,
d184 2
a185 2
# 1  <;> nextstate(B::Concise -234 Concise.pm:328) v/2
# 2  <$> const[PV "warnings.pm"] s/BARE
d187 2
a188 2
# 4  <;> nextstate(B::Concise -234 Concise.pm:328) v/2
# 5  <;> nextstate(B::Concise -234 Concise.pm:328) /2
d190 2
a191 2
# 7  <$> const[PV "warnings"] sM
# 8  <$> const[PV "qw"] sM
d196 16
a211 4
# c  <;> nextstate(main 2 -e:1) v
# d  <#> gvsv[*beg] s
# e  <1> postinc[t3] sK/1
# f  <1> leavesub[1 ref] K/REFC,1
d213 4
a216 4
# g  <;> nextstate(main 5 -e:1) v
# h  <#> gvsv[*end] s
# i  <1> postinc[t3] sK/1
# j  <1> leavesub[1 ref] K/REFC,1
d218 4
a221 4
# k  <;> nextstate(main 4 -e:1) v
# l  <#> gvsv[*init] s
# m  <1> postinc[t3] sK/1
# n  <1> leavesub[1 ref] K/REFC,1
d223 4
a226 4
# o  <;> nextstate(main 3 -e:1) v
# p  <#> gvsv[*chk] s
# q  <1> postinc[t3] sK/1
# r  <1> leavesub[1 ref] K/REFC,1
d229 2
a230 2
# 1  <;> nextstate(B::Concise -234 Concise.pm:328) v/2
# 2  <$> const(PV "warnings.pm") s/BARE
d232 2
a233 2
# 4  <;> nextstate(B::Concise -234 Concise.pm:328) v/2
# 5  <;> nextstate(B::Concise -234 Concise.pm:328) /2
d235 2
a236 2
# 7  <$> const(PV "warnings") sM
# 8  <$> const(PV "qw") sM
d241 16
a256 4
# c  <;> nextstate(main 2 -e:1) v
# d  <$> gvsv(*beg) s
# e  <1> postinc[t2] sK/1
# f  <1> leavesub[1 ref] K/REFC,1
d258 4
a261 4
# g  <;> nextstate(main 5 -e:1) v
# h  <$> gvsv(*end) s
# i  <1> postinc[t2] sK/1
# j  <1> leavesub[1 ref] K/REFC,1
d263 4
a266 4
# k  <;> nextstate(main 4 -e:1) v
# l  <$> gvsv(*init) s
# m  <1> postinc[t2] sK/1
# n  <1> leavesub[1 ref] K/REFC,1
d268 4
a271 41
# o  <;> nextstate(main 3 -e:1) v
# p  <$> gvsv(*chk) s
# q  <1> postinc[t2] sK/1
# r  <1> leavesub[1 ref] K/REFC,1
EONT_EONT


# perl "-I../lib" -MO=Concise,BEGIN,CHECK,INIT,END,-exec -e '$a=$b && print q/foo/'



checkOptree ( name	=> 'regression test for patch 25352',
	      bcopts	=> [qw/ BEGIN END INIT CHECK -exec /],
	      prog	=> 'print q/foo/',
	      @@warnings_todo,
	      expect	=> <<'EOT_EOT', expect_nt => <<'EONT_EONT');
# BEGIN 1:
# 1  <;> nextstate(B::Concise -234 Concise.pm:359) v/2
# 2  <$> const[PV "warnings.pm"] s/BARE
# 3  <1> require sK/1
# 4  <;> nextstate(B::Concise -234 Concise.pm:359) v/2
# 5  <;> nextstate(B::Concise -234 Concise.pm:359) /2
# 6  <0> pushmark s
# 7  <$> const[PV "warnings"] sM
# 8  <$> const[PV "qw"] sM
# 9  <$> method_named[PV "unimport"] 
# a  <1> entersub[t1] KS*/TARG,2
# b  <1> leavesub[1 ref] K/REFC,1
EOT_EOT
# BEGIN 1:
# 1  <;> nextstate(B::Concise -234 Concise.pm:359) v/2
# 2  <$> const(PV "warnings.pm") s/BARE
# 3  <1> require sK/1
# 4  <;> nextstate(B::Concise -234 Concise.pm:359) v/2
# 5  <;> nextstate(B::Concise -234 Concise.pm:359) /2
# 6  <0> pushmark s
# 7  <$> const(PV "warnings") sM
# 8  <$> const(PV "qw") sM
# 9  <$> method_named(PV "unimport") 
# a  <1> entersub[t1] KS*/TARG,2
# b  <1> leavesub[1 ref] K/REFC,1
@

