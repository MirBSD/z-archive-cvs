head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_4_4:1.1.1.2
	MIRBSD_10:1.1.1.2.0.2
	MIRBSD_10_BASE:1.1.1.2
	cvs-200704292000:1.1.1.2
	cvs-200606302200:1.1.1.2
	MIRBSD_9_BASE:1.1.1.1
	cvs-200601311430:1.1.1.1
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200507211800:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2005.02.05.17.22.35;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.22.35;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.06.30.22.40.22;	author tg;	state Exp;
branches;
next	;
commitid	10044A5A6F7276AA324;


desc
@@


1.1
log
@Initial revision
@
text
@#!/usr/bin/perl

# Check whether there are naming conflicts when names are truncated to
# the DOSish case-ignoring 8.3 format, plus other portability no-nos.

# The "8.3 rule" is loose: "if reducing the directory entry names
# within one directory to lowercase and 8.3-truncated causes
# conflicts, that's a bad thing".  So the rule is NOT the strict
# "no filename shall be longer than eight and a suffix if present
# not longer than three".

# TODO: this doesn't actually check for *directory entries*, what this
# does is to check for *MANIFEST entries*, which are only files, not
# directories.  In other words, a 8.3 conflict between a directory
# "abcdefghx" and a file "abcdefghy" wouldn't be noticed-- or even for
# a directory "abcdefgh" and a file "abcdefghy".

sub eight_dot_three {
    my ($dir, $base, $ext) = ($_[0] =~ m!^(?:(.+)/)?([^/.]+)(?:\.([^/.]+))?$!);
    my $file = $base . defined $ext ? ".$ext" : "";
    $base = substr($base, 0, 8);
    $ext  = substr($ext,  0, 3) if defined $ext;
    if ($dir =~ /\./)  {
	warn "$dir: directory name contains '.'\n";
    }
    if ($file =~ /[^A-Za-z0-9\._-]/) {
	warn "$file: filename contains non-portable characters\n";
    }
    if (length $file > 30) {
	warn "$file: filename longer than 30 characters\n"; # make up a limit
    }
    if (defined $dir) {
	return ($dir, defined $ext ? "$dir/$base.$ext" : "$dir/$base");
    } else {
	return ('.', defined $ext ? "$base.$ext" : $base);
    }
}

my %dir;

if (open(MANIFEST, "MANIFEST")) {
    while (<MANIFEST>) {
	chomp;
	s/\s.+//;
	unless (-f) {
	    warn "$_: missing\n";
	    next;
	}
	if (tr/././ > 1) {
	    print "$_: more than one dot\n";
	    next;
	}
	my ($dir, $edt) = eight_dot_three($_);
	($dir, $edt) = map { lc } ($dir, $edt);
	push @@{$dir{$dir}->{$edt}}, $_;
    }
} else {
    die "$0: MANIFEST: $!\n";
}

for my $dir (sort keys %dir) {
    for my $edt (keys %{$dir{$dir}}) {
	my @@files = @@{$dir{$dir}->{$edt}};
	if (@@files > 1) {
	    print "@@files: directory $dir conflict $edt\n";
	}
    }
}
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import Perl 5.8.8 from OpenLSD
@
text
@d1 1
a1 3
#!/usr/bin/perl -w

use strict;
d12 5
a16 2
my %seen;
my $maxl = 30; # make up a limit for a maximum filename length
d19 2
a20 3
    return () if $seen{$_[0]}++;
    my ($dir, $base, $ext) = ($_[0] =~ m{^(?:(.+)/)?([^/.]+)(?:\.([^/.]+))?$});
    my $file = $base . ( defined $ext ? ".$ext" : "" );
d23 2
a24 2
    if (defined $dir && $dir =~ /\./)  {
	print "directory name contains '.': $dir\n";
d27 1
a27 1
	print "filename contains non-portable characters: $_[0]\n";
d29 2
a30 2
    if (length $file > $maxl) {
	print "filename longer than $maxl characters: $file\n";
d46 1
a46 1
	    print "missing: $_\n";
d50 1
a50 1
	    print "more than one dot: $_\n";
d53 3
a55 6
	while (m!/|\z!g) {
	    my ($dir, $edt) = eight_dot_three($`);
	    next unless defined $dir;
	    ($dir, $edt) = map { lc } ($dir, $edt);
	    push @@{$dir{$dir}->{$edt}}, $_;
	}
d65 1
a65 1
	    print "directory $dir conflict $edt: @@files\n";
@

