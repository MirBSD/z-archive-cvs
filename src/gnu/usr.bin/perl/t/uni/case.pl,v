head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_4_4:1.1.1.2
	MIRBSD_10:1.1.1.2.0.2
	MIRBSD_10_BASE:1.1.1.2
	cvs-200704292000:1.1.1.2
	cvs-200606302200:1.1.1.2
	MIRBSD_9_BASE:1.1.1.1
	cvs-200601311430:1.1.1.1
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200507211800:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2005.02.05.17.24.06;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.24.06;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.06.30.22.47.09;	author tg;	state Exp;
branches;
next	;
commitid	10044A5A6F7276AA324;


desc
@@


1.1
log
@Initial revision
@
text
@use File::Spec;

require "test.pl";

sub unidump {
    join " ", map { sprintf "%04X", $_ } unpack "U*", $_[0];
}

sub casetest {
    my ($base, $spec, $func) = @@_;
    my $file = File::Spec->catfile(File::Spec->catdir(File::Spec->updir,
						      "lib", "unicore", "To"),
				   "$base.pl");
    my $simple = do $file;
    my %simple;
    for my $i (split(/\n/, $simple)) {
	my ($k, $v) = split(' ', $i);
	$simple{$k} = $v;
    }
    my %seen;

    for my $i (sort keys %simple) {
	$seen{$i}++;
    }
    print "# ", scalar keys %simple, " simple mappings\n";

    my $both;

    for my $i (sort keys %$spec) {
	if (++$seen{$i} == 2) {
	    warn sprintf "$base: $i seen twice\n";
	    $both++;
	}
    }
    print "# ", scalar keys %$spec, " special mappings\n";

    exit(1) if $both;

    my %none;
    for my $i (map { ord } split //,
	       "\e !\"#\$%&'()+,-./0123456789:;<=>?\@@[\\]^_{|}~\b") {
	next if pack("U0U", $i) =~ /\w/;
	$none{$i}++ unless $seen{$i};
    }
    print "# ", scalar keys %none, " noncase mappings\n";

    my $tests = 
	(scalar keys %simple) +
	(scalar keys %$spec) +
	(scalar keys %none);
    print "1..$tests\n";

    my $test = 1;

    for my $i (sort keys %simple) {
	my $w = $simple{$i};
	my $c = pack "U0U", hex $i;
	my $d = $func->($c);
	my $e = unidump($d);
	print $d eq pack("U0U", hex $simple{$i}) ?
	    "ok $test # $i -> $w\n" : "not ok $test # $i -> $e ($w)\n";
	$test++;
    }

    for my $i (sort keys %$spec) {
	my $w = unidump($spec->{$i});
	my $u = unpack "U0U", $i;
	my $h = sprintf "%04X", $u;
	my $c = chr($u); $c .= chr(0x100); chop $c;
	my $d = $func->($c);
	my $e = unidump($d);
	if (ord "A" == 193) { # EBCDIC
	    # We need to a little bit of remapping.
	    #
	    # For example, in titlecase (ucfirst) mapping
	    # of U+0149 the Unicode mapping is U+02BC U+004E.
	    # The 4E is N, which in EBCDIC is 2B--
	    # and the ucfirst() does that right.
	    # The problem is that our reference
	    # data is in Unicode code points.
	    #
	    # The Right Way here would be to use, say,
	    # Encode, to remap the less-than 0x100 code points,
	    # but let's try to be Encode-independent here. 
	    #
	    # These are the titlecase exceptions:
	    #
	    #         Unicode   Unicode+EBCDIC  
	    #
	    # 0149 -> 02BC 004E (02BC 002B)
	    # 01F0 -> 004A 030C (00A2 030C)
	    # 1E96 -> 0048 0331 (00E7 0331)
	    # 1E97 -> 0054 0308 (00E8 0308)
	    # 1E98 -> 0057 030A (00EF 030A)
	    # 1E99 -> 0059 030A (00DF 030A)
	    # 1E9A -> 0041 02BE (00A0 02BE)
	    #
	    # The uppercase exceptions are identical.
	    #
	    # The lowercase has one more:
	    #
	    #         Unicode   Unicode+EBCDIC  
	    #
	    # 0130 -> 0069 0307 (00D1 0307)
	    #
	    if ($i =~ /^(0130|0149|01F0|1E96|1E97|1E98|1E99|1E9A)$/) {
		$e =~ s/004E/002B/; # N
		$e =~ s/004A/00A2/; # J
		$e =~ s/0048/00E7/; # H
		$e =~ s/0054/00E8/; # T
		$e =~ s/0057/00EF/; # W
		$e =~ s/0059/00DF/; # Y
		$e =~ s/0041/00A0/; # A
		$e =~ s/0069/00D1/; # i
	    }
	    # We have to map the output, not the input, because
	    # pack/unpack U has been EBCDICified, too, it would
	    # just undo our remapping.
	}
	print $w eq $e ?
	    "ok $test # $i -> $w\n" : "not ok $test # $h -> $e ($w)\n";
	$test++;
    }

    for my $i (sort { $a <=> $b } keys %none) {
	my $w = $i = sprintf "%04X", $i;
	my $c = pack "U0U", hex $i;
	my $d = $func->($c);
	my $e = unidump($d);
	print $d eq $c ?
	    "ok $test # $i -> $w\n" : "not ok $test # $i -> $e ($w)\n";
	$test++;
    }
}

1;
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import Perl 5.8.8 from OpenLSD
@
text
@d10 1
a10 13
    my ($base, $spec, @@funcs) = @@_;
    # For each provided function run it, and run a version with some extra
    # characters afterwards. Use a recylcing symbol, as it doesn't change case.
    my $ballast = chr (0x2672) x 3;
    @@funcs = map {my $f = $_;
		  ($f,
		   sub {my $r = $f->($_[0] . $ballast); # Add it before
			$r =~ s/$ballast\z//so # Remove it afterwards
			    or die "'$_[0]' to '$r' mangled";
			$r; # Result with $ballast removed.
		    },
		   )} @@funcs;

d48 3
a50 3
	((scalar keys %simple) +
	 (scalar keys %$spec) +
	 (scalar keys %none)) * @@funcs;
d58 5
a62 7
	foreach my $func (@@funcs) {
	    my $d = $func->($c);
	    my $e = unidump($d);
	    print $d eq pack("U0U", hex $simple{$i}) ?
		"ok $test # $i -> $w\n" : "not ok $test # $i -> $e ($w)\n";
		$test++;
	}
d70 45
a114 50
	foreach my $func (@@funcs) {
	    my $d = $func->($c);
	    my $e = unidump($d);
	    if (ord "A" == 193) { # EBCDIC
		# We need to a little bit of remapping.
		#
		# For example, in titlecase (ucfirst) mapping
		# of U+0149 the Unicode mapping is U+02BC U+004E.
		# The 4E is N, which in EBCDIC is 2B--
		# and the ucfirst() does that right.
		# The problem is that our reference
		# data is in Unicode code points.
		#
		# The Right Way here would be to use, say,
		# Encode, to remap the less-than 0x100 code points,
		# but let's try to be Encode-independent here. 
		#
		# These are the titlecase exceptions:
		#
		#         Unicode   Unicode+EBCDIC  
		#
		# 0149 -> 02BC 004E (02BC 002B)
		# 01F0 -> 004A 030C (00A2 030C)
		# 1E96 -> 0048 0331 (00E7 0331)
		# 1E97 -> 0054 0308 (00E8 0308)
		# 1E98 -> 0057 030A (00EF 030A)
		# 1E99 -> 0059 030A (00DF 030A)
		# 1E9A -> 0041 02BE (00A0 02BE)
		#
		# The uppercase exceptions are identical.
		#
		# The lowercase has one more:
		#
		#         Unicode   Unicode+EBCDIC  
		#
		# 0130 -> 0069 0307 (00D1 0307)
		#
		if ($i =~ /^(0130|0149|01F0|1E96|1E97|1E98|1E99|1E9A)$/) {
		    $e =~ s/004E/002B/; # N
		    $e =~ s/004A/00A2/; # J
		    $e =~ s/0048/00E7/; # H
		    $e =~ s/0054/00E8/; # T
		    $e =~ s/0057/00EF/; # W
		    $e =~ s/0059/00DF/; # Y
		    $e =~ s/0041/00A0/; # A
		    $e =~ s/0069/00D1/; # i
		}
		# We have to map the output, not the input, because
		# pack/unpack U has been EBCDICified, too, it would
		# just undo our remapping.
d116 3
a118 3
	    print $w eq $e ?
		"ok $test # $i -> $w\n" : "not ok $test # $h -> $e ($w)\n";
		$test++;
d120 3
d128 5
a132 7
	foreach my $func (@@funcs) {
	    my $d = $func->($c);
	    my $e = unidump($d);
	    print $d eq $c ?
		"ok $test # $i -> $w\n" : "not ok $test # $i -> $e ($w)\n";
		$test++;
	}
@

