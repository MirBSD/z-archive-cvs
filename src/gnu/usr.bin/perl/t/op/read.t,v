head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_4_4:1.1.1.2
	MIRBSD_10:1.1.1.2.0.2
	MIRBSD_10_BASE:1.1.1.2
	cvs-200704292000:1.1.1.2
	cvs-200606302200:1.1.1.2
	MIRBSD_9_BASE:1.1.1.1
	cvs-200601311430:1.1.1.1
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200507211800:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2005.02.05.17.24.01;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.24.01;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.06.30.22.46.54;	author tg;	state Exp;
branches;
next	;
commitid	10044A5A6F7276AA324;


desc
@@


1.1
log
@Initial revision
@
text
@#!./perl

# $RCSfile: read.t,v $$Revision: 1.7 $$Date: 2003/12/03 03:02:49 $

print "1..4\n";


open(FOO,'op/read.t') || open(FOO,'t/op/read.t') || open(FOO,':op:read.t') || die "Can't open op.read";
seek(FOO,4,0);
$got = read(FOO,$buf,4);

print ($got == 4 ? "ok 1\n" : "not ok 1\n");
print ($buf eq "perl" ? "ok 2\n" : "not ok 2 :$buf:\n");

seek (FOO,0,2) || seek(FOO,20000,0);
$got = read(FOO,$buf,4);

print ($got == 0 ? "ok 3\n" : "not ok 3\n");
print ($buf eq "" ? "ok 4\n" : "not ok 4\n");
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import Perl 5.8.8 from OpenLSD
@
text
@d3 1
a3 1
# $RCSfile: read.t,v $$Revision: 1.8 $$Date: 2006/03/28 19:23:13 $
d5 1
a5 6
BEGIN {
    chdir 't';
    @@INC = '../lib';
    require './test.pl';
}
use strict;
a6 1
plan tests => 2564;
d9 2
a10 3
seek(FOO,4,0) or die "Seek failed: $!";
my $buf;
my $got = read(FOO,$buf,4);
d12 2
a13 2
is ($got, 4);
is ($buf, "perl");
d18 2
a19 77
is ($got, 0);
is ($buf, "");

# This is true if Config is not built, or if PerlIO is enabled
# ie assume that PerlIO is present, unless we know for sure otherwise.
my $has_perlio = !eval {
    no warnings;
    require Config;
    !$Config::Config{useperlio}
};

my $tmpfile = 'Op_read.tmp';

END { 1 while unlink $tmpfile }

my (@@values, @@buffers) = ('', '');

foreach (65, 161, 253, 9786) {
    push @@values, join "", map {chr $_} $_ .. $_ + 4;
    push @@buffers, join "", map {chr $_} $_ + 5 .. $_ + 20;
}
my @@offsets = (0, 3, 7, 22, -1, -3, -5, -7);
my @@lengths = (0, 2, 5, 10);

foreach my $value (@@values) {
    foreach my $initial_buffer (@@buffers) {
	my @@utf8 = 1;
	if ($value !~ tr/\0-\377//c) {
	    # It's all 8 bit
	    unshift @@utf8, 0;
	}
      SKIP:
	foreach my $utf8 (@@utf8) {
	    skip "Needs :utf8 layer but no perlio", 2 * @@offsets * @@lengths
	      if $utf8 and !$has_perlio;

	    1 while unlink $tmpfile;
	    open FH, ">$tmpfile" or die "Can't open $tmpfile: $!";
	    binmode FH, "utf8" if $utf8;
	    print FH $value;
	    close FH;
	    foreach my $offset (@@offsets) {
		foreach my $length (@@lengths) {
		    # Will read the lesser of the length of the file and the
		    # read length
		    my $will_read = $value;
		    if ($length < length $will_read) {
			substr ($will_read, $length) = '';
		    }
		    # Going to trash this so need a copy
		    my $buffer = $initial_buffer;

		    my $expect = $buffer;
		    if ($offset > 0) {
			# Right pad with NUL bytes
			$expect .= "\0" x $offset;
			substr ($expect, $offset) = '';
		    }
		    substr ($expect, $offset) = $will_read;

		    open FH, $tmpfile or die "Can't open $tmpfile: $!";
		    binmode FH, "utf8" if $utf8;
		    my $what = sprintf "%d into %d l $length o $offset",
			ord $value, ord $buffer;
		    $what .= ' u' if $utf8;
		    $got = read (FH, $buffer, $length, $offset);
		    is ($got, length $will_read, "got $what");
		    is ($buffer, $expect, "buffer $what");
		    close FH;
		}
	    }
	}
    }
}



@

