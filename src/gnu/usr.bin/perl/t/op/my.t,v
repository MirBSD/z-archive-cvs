head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_4_4:1.1.1.2
	MIRBSD_10:1.1.1.2.0.2
	MIRBSD_10_BASE:1.1.1.2
	cvs-200704292000:1.1.1.2
	cvs-200606302200:1.1.1.2
	MIRBSD_9_BASE:1.1.1.1
	cvs-200601311430:1.1.1.1
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200507211800:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2005.02.05.17.24.01;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.24.01;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.06.30.22.46.51;	author tg;	state Exp;
branches;
next	;
commitid	10044A5A6F7276AA324;


desc
@@


1.1
log
@Initial revision
@
text
@#!./perl

# $RCSfile: my.t,v $

print "1..33\n";

sub foo {
    my($a, $b) = @@_;
    my $c;
    my $d;
    $c = "ok 3\n";
    $d = "ok 4\n";
    { my($a, undef, $c) = ("ok 9\n", "not ok 10\n", "ok 10\n");
      ($x, $y) = ($a, $c); }
    print $a, $b;
    $c . $d;
}

$a = "ok 5\n";
$b = "ok 6\n";
$c = "ok 7\n";
$d = "ok 8\n";

print &foo("ok 1\n","ok 2\n");

print $a,$b,$c,$d,$x,$y;

# same thing, only with arrays and associative arrays

sub foo2 {
    my($a, @@b) = @@_;
    my(@@c, %d);
    @@c = "ok 13\n";
    $d{''} = "ok 14\n";
    { my($a,@@c) = ("ok 19\n", "ok 20\n"); ($x, $y) = ($a, @@c); }
    print $a, @@b;
    $c[0] . $d{''};
}

$a = "ok 15\n";
@@b = "ok 16\n";
@@c = "ok 17\n";
$d{''} = "ok 18\n";

print &foo2("ok 11\n","ok 12\n");

print $a,@@b,@@c,%d,$x,$y;

my $i = "outer";

if (my $i = "inner") {
    print "not " if $i ne "inner";
}
print "ok 21\n";

if ((my $i = 1) == 0) {
    print "not ";
}
else {
    print "not" if $i != 1;
}
print "ok 22\n";

my $j = 5;
while (my $i = --$j) {
    print("not "), last unless $i > 0;
}
continue {
    print("not "), last unless $i > 0;
}
print "ok 23\n";

$j = 5;
for (my $i = 0; (my $k = $i) < $j; ++$i) {
    print("not "), last unless $i >= 0 && $i < $j && $i == $k;
}
print "ok 24\n";
print "not " if defined $k;
print "ok 25\n";

foreach my $i (26, 27) {
    print "ok $i\n";
}

print "not " if $i ne "outer";
print "ok 28\n";

# Ensure that C<my @@y> (without parens) doesn't force scalar context.
my @@x;
{ @@x = my @@y }
print +(@@x ? "not " : ""), "ok 29\n";
{ @@x = my %y }
print +(@@x ? "not " : ""), "ok 30\n";

# Found in HTML::FormatPS
my %fonts = qw(nok 31);
for my $full (keys %fonts) {
    $full =~ s/^n//;
    # Supposed to be copy-on-write via force_normal after a THINKFIRST check.
    print "$full $fonts{nok}\n";
}

#  [perl #29340] optimising away the = () left the padav returning the
# array rather than the contents, leading to 'Bizarre copy of array' error

sub opta { my @@a=() }
sub opth { my %h=() }
eval { my $x = opta };
print "not " if $@@;
print "ok 32\n";
eval { my $x = opth };
print "not " if $@@;
print "ok 33\n";
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import Perl 5.8.8 from OpenLSD
@
text
@d5 1
a5 1
print "1..36\n";
a113 10
# my $foo = undef should always assign [perl #37776]
{
    my $count = 34;
    loop:
    my $test = undef;
    print "not " if defined $test;
    print "ok $count\n";
    $test = 42;
    goto loop if ++$count < 37;
}
@

