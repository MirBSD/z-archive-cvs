head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_4_4:1.1.1.2
	MIRBSD_10:1.1.1.2.0.2
	MIRBSD_10_BASE:1.1.1.2
	cvs-200704292000:1.1.1.2
	cvs-200606302200:1.1.1.2
	MIRBSD_9_BASE:1.1.1.1
	cvs-200601311430:1.1.1.1
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200507211800:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2005.02.05.17.24.00;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.24.00;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.06.30.22.46.39;	author tg;	state Exp;
branches;
next	;
commitid	10044A5A6F7276AA324;


desc
@@


1.1
log
@Initial revision
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
}

print "1..82\n";

#
# @@foo, @@bar, and @@ary are also used from tie-stdarray after tie-ing them
#

@@ary = (1,2,3,4,5);
if (join('',@@ary) eq '12345') {print "ok 1\n";} else {print "not ok 1\n";}

$tmp = $ary[$#ary]; --$#ary;
if ($tmp == 5) {print "ok 2\n";} else {print "not ok 2\n";}
if ($#ary == 3) {print "ok 3\n";} else {print "not ok 3\n";}
if (join('',@@ary) eq '1234') {print "ok 4\n";} else {print "not ok 4\n";}

$[ = 1;
@@ary = (1,2,3,4,5);
if (join('',@@ary) eq '12345') {print "ok 5\n";} else {print "not ok 5\n";}

$tmp = $ary[$#ary]; --$#ary;
if ($tmp == 5) {print "ok 6\n";} else {print "not ok 6\n";}
if ($#ary == 4) {print "ok 7\n";} else {print "not ok 7\n";}
if (join('',@@ary) eq '1234') {print "ok 8\n";} else {print "not ok 8\n";}

if ($ary[5] eq '') {print "ok 9\n";} else {print "not ok 9\n";}

$#ary += 1;	# see if element 5 gone for good
if ($#ary == 5) {print "ok 10\n";} else {print "not ok 10\n";}
if (defined $ary[5]) {print "not ok 11\n";} else {print "ok 11\n";}

$[ = 0;
@@foo = ();
$r = join(',', $#foo, @@foo);
if ($r eq "-1") {print "ok 12\n";} else {print "not ok 12 $r\n";}
$foo[0] = '0';
$r = join(',', $#foo, @@foo);
if ($r eq "0,0") {print "ok 13\n";} else {print "not ok 13 $r\n";}
$foo[2] = '2';
$r = join(',', $#foo, @@foo);
if ($r eq "2,0,,2") {print "ok 14\n";} else {print "not ok 14 $r\n";}
@@bar = ();
$bar[0] = '0';
$bar[1] = '1';
$r = join(',', $#bar, @@bar);
if ($r eq "1,0,1") {print "ok 15\n";} else {print "not ok 15 $r\n";}
@@bar = ();
$r = join(',', $#bar, @@bar);
if ($r eq "-1") {print "ok 16\n";} else {print "not ok 16 $r\n";}
$bar[0] = '0';
$r = join(',', $#bar, @@bar);
if ($r eq "0,0") {print "ok 17\n";} else {print "not ok 17 $r\n";}
$bar[2] = '2';
$r = join(',', $#bar, @@bar);
if ($r eq "2,0,,2") {print "ok 18\n";} else {print "not ok 18 $r\n";}
reset 'b';
@@bar = ();
$bar[0] = '0';
$r = join(',', $#bar, @@bar);
if ($r eq "0,0") {print "ok 19\n";} else {print "not ok 19 $r\n";}
$bar[2] = '2';
$r = join(',', $#bar, @@bar);
if ($r eq "2,0,,2") {print "ok 20\n";} else {print "not ok 20 $r\n";}

$foo = 'now is the time';
if (($F1,$F2,$Etc) = ($foo =~ /^(\S+)\s+(\S+)\s*(.*)/)) {
    if ($F1 eq 'now' && $F2 eq 'is' && $Etc eq 'the time') {
	print "ok 21\n";
    }
    else {
	print "not ok 21\n";
    }
}
else {
    print "not ok 21\n";
}

$foo = 'lskjdf';
if ($cnt = (($F1,$F2,$Etc) = ($foo =~ /^(\S+)\s+(\S+)\s*(.*)/))) {
    print "not ok 22 $cnt $F1:$F2:$Etc\n";
}
else {
    print "ok 22\n";
}

%foo = ('blurfl','dyick','foo','bar','etc.','etc.');
%bar = %foo;
print $bar{'foo'} eq 'bar' ? "ok 23\n" : "not ok 23\n";
%bar = ();
print $bar{'foo'} eq '' ? "ok 24\n" : "not ok 24\n";
(%bar,$a,$b) = (%foo,'how','now');
print $bar{'foo'} eq 'bar' ? "ok 25\n" : "not ok 25\n";
print $bar{'how'} eq 'now' ? "ok 26\n" : "not ok 26\n";
@@bar{keys %foo} = values %foo;
print $bar{'foo'} eq 'bar' ? "ok 27\n" : "not ok 27\n";
print $bar{'how'} eq 'now' ? "ok 28\n" : "not ok 28\n";

@@foo = grep(/e/,split(' ','now is the time for all good men to come to'));
print join(' ',@@foo) eq 'the time men come' ? "ok 29\n" : "not ok 29\n";

@@foo = grep(!/e/,split(' ','now is the time for all good men to come to'));
print join(' ',@@foo) eq 'now is for all good to to' ? "ok 30\n" : "not ok 30\n";

$foo = join('',('a','b','c','d','e','f')[0..5]);
print $foo eq 'abcdef' ? "ok 31\n" : "not ok 31\n";

$foo = join('',('a','b','c','d','e','f')[0..1]);
print $foo eq 'ab' ? "ok 32\n" : "not ok 32\n";

$foo = join('',('a','b','c','d','e','f')[6]);
print $foo eq '' ? "ok 33\n" : "not ok 33\n";

@@foo = ('a','b','c','d','e','f')[0,2,4];
@@bar = ('a','b','c','d','e','f')[1,3,5];
$foo = join('',(@@foo,@@bar)[0..5]);
print $foo eq 'acebdf' ? "ok 34\n" : "not ok 34\n";

$foo = ('a','b','c','d','e','f')[0,2,4];
print $foo eq 'e' ? "ok 35\n" : "not ok 35\n";

$foo = ('a','b','c','d','e','f')[1];
print $foo eq 'b' ? "ok 36\n" : "not ok 36\n";

@@foo = ( 'foo', 'bar', 'burbl');
push(foo, 'blah');
print $#foo == 3 ? "ok 37\n" : "not ok 37\n";

# various AASSIGN_COMMON checks (see newASSIGNOP() in op.c)

$test = 37;
sub t { ++$test; print "not " unless $_[0]; print "ok $test\n"; }

@@foo = @@foo;
t("@@foo" eq "foo bar burbl blah");				# 38

(undef,@@foo) = @@foo;
t("@@foo" eq "bar burbl blah");					# 39

@@foo = ('XXX',@@foo, 'YYY');
t("@@foo" eq "XXX bar burbl blah YYY");				# 40

@@foo = @@foo = qw(foo b\a\r bu\\rbl blah);
t("@@foo" eq 'foo b\a\r bu\\rbl blah');				# 41

@@bar = @@foo = qw(foo bar);					# 42
t("@@foo" eq "foo bar");
t("@@bar" eq "foo bar");						# 43

# try the same with local
# XXX tie-stdarray fails the tests involving local, so we use
# different variable names to escape the 'tie'

@@bee = ( 'foo', 'bar', 'burbl', 'blah');
{

    local @@bee = @@bee;
    t("@@bee" eq "foo bar burbl blah");				# 44
    {
	local (undef,@@bee) = @@bee;
	t("@@bee" eq "bar burbl blah");				# 45
	{
	    local @@bee = ('XXX',@@bee,'YYY');
	    t("@@bee" eq "XXX bar burbl blah YYY");		# 46
	    {
		local @@bee = local(@@bee) = qw(foo bar burbl blah);
		t("@@bee" eq "foo bar burbl blah");		# 47
		{
		    local (@@bim) = local(@@bee) = qw(foo bar);
		    t("@@bee" eq "foo bar");			# 48
		    t("@@bim" eq "foo bar");			# 49
		}
		t("@@bee" eq "foo bar burbl blah");		# 50
	    }
	    t("@@bee" eq "XXX bar burbl blah YYY");		# 51
	}
	t("@@bee" eq "bar burbl blah");				# 52
    }
    t("@@bee" eq "foo bar burbl blah");				# 53
}

# try the same with my
{

    my @@bee = @@bee;
    t("@@bee" eq "foo bar burbl blah");				# 54
    {
	my (undef,@@bee) = @@bee;
	t("@@bee" eq "bar burbl blah");				# 55
	{
	    my @@bee = ('XXX',@@bee,'YYY');
	    t("@@bee" eq "XXX bar burbl blah YYY");		# 56
	    {
		my @@bee = my @@bee = qw(foo bar burbl blah);
		t("@@bee" eq "foo bar burbl blah");		# 57
		{
		    my (@@bim) = my(@@bee) = qw(foo bar);
		    t("@@bee" eq "foo bar");			# 58
		    t("@@bim" eq "foo bar");			# 59
		}
		t("@@bee" eq "foo bar burbl blah");		# 60
	    }
	    t("@@bee" eq "XXX bar burbl blah YYY");		# 61
	}
	t("@@bee" eq "bar burbl blah");				# 62
    }
    t("@@bee" eq "foo bar burbl blah");				# 63
}

# make sure reification behaves
my $t = 63;
sub reify { $_[1] = ++$t; print "@@_\n"; }
reify('ok');
reify('ok');

# qw() is no more a runtime split, it's compiletime.
print "not " unless qw(foo bar snorfle)[2] eq 'snorfle';
print "ok 66\n";

@@ary = (12,23,34,45,56);

print "not " unless shift(@@ary) == 12;
print "ok 67\n";

print "not " unless pop(@@ary) == 56;
print "ok 68\n";

print "not " unless push(@@ary,56) == 4;
print "ok 69\n";

print "not " unless unshift(@@ary,12) == 5;
print "ok 70\n";

sub foo { "a" }
@@foo=(foo())[0,0];
$foo[1] eq "a" or print "not ";
print "ok 71\n";

# $[ should have the same effect regardless of whether the aelem
#    op is optimized to aelemfast.

sub tary {
  local $[ = 10;
  my $five = 5;
  print "not " unless $tary[5] == $tary[$five];
  print "ok 72\n";
}

@@tary = (0..50);
tary();


require './test.pl';

# bugid #15439 - clearing an array calls destructors which may try
# to modify the array - caused 'Attempt to free unreferenced scalar'

my $got = runperl (
	prog => q{
		    sub X::DESTROY { @@a = () }
		    @@a = (bless {}, 'X');
		    @@a = ();
		},
	stderr => 1
    );

$got =~ s/\n/ /g;
print "# $got\nnot " unless $got eq '';
print "ok 73\n";

# Test negative and funky indices.

{
    my @@a = 0..4;
    print $a[-1] == 4 ? "ok 74\n" : "not ok 74\n";
    print $a[-2] == 3 ? "ok 75\n" : "not ok 75\n";
    print $a[-5] == 0 ? "ok 76\n" : "not ok 76\n";
    print defined $a[-6] ? "not ok 77\n" : "ok 77\n";

    print $a[2.1]   == 2 ? "ok 78\n" : "not ok 78\n";
    print $a[2.9]   == 2 ? "ok 79\n" : "not ok 79\n";
    print $a[undef] == 0 ? "ok 80\n" : "not ok 80\n";
    print $a["3rd"] == 3 ? "ok 81\n" : "not ok 81\n";
}

sub kindalike { # TODO: test.pl-ize the array.t.
    my ($s, $r, $m, $n) = @@_;
    print $s =~ /$r/ ? "ok $n - $m\n" : "not ok $n - $m ($s)\n";
}

{
    my @@a;
    eval '$a[-1] = 0';
    kindalike($@@, qr/Modification of non-creatable array value attempted, subscript -1/, "\$a[-1] = 0", 82);
}
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import Perl 5.8.8 from OpenLSD
@
text
@d5 1
a5 1
    @@INC = '.', '../lib';
d8 1
a8 3
require 'test.pl';

plan (91);
d15 1
a15 1
is(join('',@@ary), '12345');
d18 3
a20 3
is($tmp, 5);
is($#ary, 3);
is(join('',@@ary), '1234');
d24 1
a24 1
is(join('',@@ary), '12345');
d27 3
a29 4
is($tmp, 5);
# Must do == here beacuse $[ isn't 0
ok($#ary == 4);
is(join('',@@ary), '1234');
d31 1
a31 1
is($ary[5], undef);
d34 2
a35 2
ok($#ary == 5);
ok(!defined $ary[5]);
d40 1
a40 1
is($r, "-1");
d43 1
a43 1
is($r, "0,0");
d46 1
a46 1
is($r, "2,0,,2");
d51 1
a51 1
is($r, "1,0,1");
d54 1
a54 1
is($r, "-1");
d57 1
a57 1
is($r, "0,0");
d60 2
a61 2
is($r, "2,0,,2");
reset 'b' if $^O ne 'VMS';
d65 1
a65 1
is($r, "0,0");
d68 1
a68 1
is($r, "2,0,,2");
d71 11
a81 4
ok(scalar (($F1,$F2,$Etc) = ($foo =~ /^(\S+)\s+(\S+)\s*(.*)/)));
is($F1, 'now');
is($F2, 'is');
is($Etc, 'the time');
d84 6
a89 2
ok(!($cnt = (($F1,$F2,$Etc) = ($foo =~ /^(\S+)\s+(\S+)\s*(.*)/))))
   or diag("$cnt $F1:$F2:$Etc");
d93 1
a93 1
is($bar{'foo'}, 'bar');
d95 1
a95 1
is($bar{'foo'}, undef);
d97 2
a98 2
is($bar{'foo'}, 'bar');
is($bar{'how'}, 'now');
d100 2
a101 2
is($bar{'foo'}, 'bar');
is($bar{'how'}, 'now');
d104 1
a104 1
is(join(' ',@@foo), 'the time men come');
d107 1
a107 1
is(join(' ',@@foo), 'now is for all good to to');
d110 1
a110 1
is($foo, 'abcdef');
d113 1
a113 1
is($foo, 'ab');
d116 1
a116 1
is($foo, '');
d121 1
a121 1
is($foo, 'acebdf');
d124 1
a124 1
is($foo, 'e');
d127 1
a127 1
is($foo, 'b');
d131 1
a131 1
is($#foo, 3);
d135 2
a136 1
#curr_test(38);
d139 1
a139 1
is("@@foo", "foo bar burbl blah");				# 38
d142 1
a142 1
is("@@foo", "bar burbl blah");					# 39
d145 1
a145 1
is("@@foo", "XXX bar burbl blah YYY");				# 40
d148 1
a148 1
is("@@foo", 'foo b\a\r bu\\rbl blah');				# 41
d151 2
a152 2
is("@@foo", "foo bar");
is("@@bar", "foo bar");						# 43
d162 1
a162 1
    is("@@bee", "foo bar burbl blah");				# 44
d165 1
a165 1
	is("@@bee", "bar burbl blah");				# 45
d168 1
a168 1
	    is("@@bee", "XXX bar burbl blah YYY");		# 46
d171 1
a171 1
		is("@@bee", "foo bar burbl blah");		# 47
d174 2
a175 2
		    is("@@bee", "foo bar");			# 48
		    is("@@bim", "foo bar");			# 49
d177 1
a177 1
		is("@@bee", "foo bar burbl blah");		# 50
d179 1
a179 1
	    is("@@bee", "XXX bar burbl blah YYY");		# 51
d181 1
a181 1
	is("@@bee", "bar burbl blah");				# 52
d183 1
a183 1
    is("@@bee", "foo bar burbl blah");				# 53
d190 1
a190 1
    is("@@bee", "foo bar burbl blah");				# 54
d193 1
a193 1
	is("@@bee", "bar burbl blah");				# 55
d196 1
a196 1
	    is("@@bee", "XXX bar burbl blah YYY");		# 56
d199 1
a199 1
		is("@@bee", "foo bar burbl blah");		# 57
d202 2
a203 2
		    is("@@bee", "foo bar");			# 58
		    is("@@bim", "foo bar");			# 59
d205 1
a205 1
		is("@@bee", "foo bar burbl blah");		# 60
d207 1
a207 1
	    is("@@bee", "XXX bar burbl blah YYY");		# 61
d209 1
a209 1
	is("@@bee", "bar burbl blah");				# 62
d211 1
a211 1
    is("@@bee", "foo bar burbl blah");				# 63
d215 2
a216 2
my $t = curr_test();
sub reify { $_[1] = $t++; print "@@_\n"; }
d220 5
a224 1
curr_test($t);
d226 2
a227 2
# qw() is no longer a runtime split, it's compiletime.
is (qw(foo bar snorfle)[2], 'snorfle');
d229 5
a233 1
@@ary = (12,23,34,45,56);
d235 2
a236 4
is(shift(@@ary), 12);
is(pop(@@ary), 56);
is(push(@@ary,56), 4);
is(unshift(@@ary,12), 5);
d240 2
a241 1
is ($foo[1], "a");
a245 2


d249 2
a250 1
  is ($tary[5], $tary[$five]);
d257 2
d272 2
a273 1
is ($got, '');
a276 1

d279 9
a287 9
    is($a[-1], 4);
    is($a[-2], 3);
    is($a[-5], 0);
    ok(!defined $a[-6]);

    is($a[2.1]  , 2);
    is($a[2.9]  , 2);
    is($a[undef], 0);
    is($a["3rd"], 3);
d290 4
d298 1
a298 19
    like($@@, qr/Modification of non-creatable array value attempted, subscript -1/, "\$a[-1] = 0");
}

sub test_arylen {
    my $ref = shift;
    local $^W = 1;
    is ($$ref, undef, "\$# on freed array is undef");
    my @@warn;
    local $SIG{__WARN__} = sub {push @@warn, "@@_"};
    $$ref = 1000;
    is (scalar @@warn, 1);
    like ($warn[0], qr/^Attempt to set length of freed array/);
}

{
    my $a = \$#{[]};
    # Need a new statement to make it go out of scope
    test_arylen ($a);
    test_arylen (do {my @@a; \$#a});
@

