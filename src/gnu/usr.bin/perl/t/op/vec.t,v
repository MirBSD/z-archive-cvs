head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_4_4:1.1.1.2
	MIRBSD_10:1.1.1.2.0.2
	MIRBSD_10_BASE:1.1.1.2
	cvs-200704292000:1.1.1.2
	cvs-200606302200:1.1.1.2
	MIRBSD_9_BASE:1.1.1.1
	cvs-200601311430:1.1.1.1
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200507211800:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2005.02.05.17.24.02;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.24.02;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.06.30.22.47.01;	author tg;	state Exp;
branches;
next	;
commitid	10044A5A6F7276AA324;


desc
@@


1.1
log
@Initial revision
@
text
@#!./perl

print "1..31\n";

my $Is_EBCDIC = (ord('A') == 193) ? 1 : 0;

print vec($foo,0,1) == 0 ? "ok 1\n" : "not ok 1\n";
print length($foo) == 0 ? "ok 2\n" : "not ok 2\n";
vec($foo,0,1) = 1;
print length($foo) == 1 ? "ok 3\n" : "not ok 3\n";
print unpack('C',$foo) == 1 ? "ok 4\n" : "not ok 4\n";
print vec($foo,0,1) == 1 ? "ok 5\n" : "not ok 5\n";

print vec($foo,20,1) == 0 ? "ok 6\n" : "not ok 6\n";
vec($foo,20,1) = 1;
print vec($foo,20,1) == 1 ? "ok 7\n" : "not ok 7\n";
print length($foo) == 3 ? "ok 8\n" : "not ok 8\n";
print vec($foo,1,8) == 0 ? "ok 9\n" : "not ok 9\n";
vec($foo,1,8) = 0xf1;
print vec($foo,1,8) == 0xf1 ? "ok 10\n" : "not ok 10\n";
print ((unpack('C',substr($foo,1,1)) & 255) == 0xf1 ? "ok 11\n" : "not ok 11\n");
print vec($foo,2,4) == 1 ? "ok 12\n" : "not ok 12\n";
print vec($foo,3,4) == 15 ? "ok 13\n" : "not ok 13\n";
vec($Vec, 0, 32) = 0xbaddacab;
print $Vec eq "\xba\xdd\xac\xab" ? "ok 14\n" : "not ok 14\n";
print vec($Vec, 0, 32) == 3135089835 ? "ok 15\n" : "not ok 15\n";

# ensure vec() handles numericalness correctly
$foo = $bar = $baz = 0;
vec($foo = 0,0,1) = 1;
vec($bar = 0,1,1) = 1;
$baz = $foo | $bar;
print $foo eq "1" && $foo == 1 ? "ok 16\n" : "not ok 16\n";
print $bar eq "2" && $bar == 2 ? "ok 17\n" : "not ok 17\n";
print "$foo $bar $baz" eq "1 2 3" ? "ok 18\n" : "not ok 18\n";

# error cases

$x = eval { vec $foo, 0, 3 };
print "not " if defined $x or $@@ !~ /^Illegal number of bits in vec/;
print "ok 19\n";
$x = eval { vec $foo, 0, 0 };
print "not " if defined $x or $@@ !~ /^Illegal number of bits in vec/;
print "ok 20\n";
$x = eval { vec $foo, 0, -13 };
print "not " if defined $x or $@@ !~ /^Illegal number of bits in vec/;
print "ok 21\n";
$x = eval { vec($foo, -1, 4) = 2 };
print "not " if defined $x or $@@ !~ /^Negative offset to vec in lvalue context/;
print "ok 22\n";
print "not " if vec('abcd', 7, 8);
print "ok 23\n";

# UTF8
# N.B. currently curiously coded to circumvent bugs elswhere in UTF8 handling

$foo = "\x{100}" . "\xff\xfe";
$x = substr $foo, 1;
print "not " if vec($x, 0, 8) != 255;
print "ok 24\n";
eval { vec($foo, 1, 8) };
print "not " if $@@;
print "ok 25\n";
eval { vec($foo, 1, 8) = 13 };
print "not " if $@@;
print "ok 26\n";
if ($Is_EBCDIC) {
    print "not " if $foo ne "\x8c\x0d\xff\x8a\x69";
    print "ok 27\n";
}
else {
    print "not " if $foo ne "\xc4\x0d\xc3\xbf\xc3\xbe";
    print "ok 27\n";
}
$foo = "\x{100}" . "\xff\xfe";
$x = substr $foo, 1;
vec($x, 2, 4) = 7;
print "not " if $x ne "\xff\xf7";
print "ok 28\n";

# mixed magic

$foo = "\x61\x62\x63\x64\x65\x66";
print "not " if vec(substr($foo, 2, 2), 0, 16) != 25444;
print "ok 29\n";
vec(substr($foo, 1,3), 5, 4) = 3;
print "not " if $foo ne "\x61\x62\x63\x34\x65\x66";
print "ok 30\n";

# A variation of [perl #20933]
{
    my $s = "";
    vec($s, 0, 1) = 0;
    vec($s, 1, 1) = 1;
    my @@r;
    $r[$_] = \ vec $s, $_, 1 for (0, 1);
    print "not " if (${ $r[0] } != 0 || ${ $r[1] } != 1);
    print "ok 31\n";
}
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import Perl 5.8.8 from OpenLSD
@
text
@d3 1
a3 7
BEGIN {
    chdir 't' if -d 't';
    @@INC = qw(. ../lib);
}

require "test.pl";
plan( tests => 31 );
d7 2
a8 2
is(vec($foo,0,1), 0);
is(length($foo), 0);
d10 3
a12 3
is(length($foo), 1);
is(unpack('C',$foo), 1);
is(vec($foo,0,1), 1);
d14 1
a14 1
is(vec($foo,20,1), 0);
d16 3
a18 3
is(vec($foo,20,1), 1);
is(length($foo), 3);
is(vec($foo,1,8), 0);
d20 4
a23 4
is(vec($foo,1,8), 0xf1);
is((unpack('C',substr($foo,1,1)) & 255), 0xf1);
is(vec($foo,2,4), 1);;
is(vec($foo,3,4), 15);
d25 2
a26 2
is($Vec, "\xba\xdd\xac\xab");
is(vec($Vec, 0, 32), 3135089835);
d33 3
a35 3
ok($foo eq "1" && $foo == 1);
ok($bar eq "2" && $bar == 2);
ok("$foo $bar $baz" eq "1 2 3");
d40 2
a41 2
like($@@, /^Illegal number of bits in vec/);
$@@ = undef;
d43 2
a44 2
like($@@, /^Illegal number of bits in vec/);
$@@ = undef;
d46 2
a47 2
like($@@, /^Illegal number of bits in vec/);
$@@ = undef;
d49 4
a52 3
like($@@, /^Illegal number of bits in vec/);
$@@ = undef;
ok(! vec('abcd', 7, 8));
d59 2
a60 2
is(vec($x, 0, 8), 255);
$@@ = undef;
d62 2
a63 2
ok(! $@@);
$@@ = undef;
d65 2
a66 1
ok(! $@@);
d68 2
a69 1
    is($foo, "\x8c\x0d\xff\x8a\x69"); 
d72 2
a73 1
    is($foo, "\xc4\x0d\xc3\xbf\xc3\xbe");
d78 2
a79 1
is($x, "\xff\xf7");
d84 2
a85 1
is(vec(substr($foo, 2, 2), 0, 16), 25444);
d87 2
a88 1
is($foo, "\x61\x62\x63\x34\x65\x66");
d97 2
a98 1
    ok(!(${ $r[0] } != 0 || ${ $r[1] } != 1)); 
@

