head	1.20;
access;
symbols
	MIRBSD_10:1.6.0.2
	MIRBSD_10_BASE:1.6
	MIRBSD_9_BASE:1.5
	MIRBSD_8:1.5.0.2
	MIRBSD_8_BASE:1.5
	cvs-1_12_13:1.1.101.3
	cvs-1_12_12:1.1.101.2
	FSF:1.1.101;
locks; strict;
comment	@ * @;


1.20
date	2017.11.18.22.15.53;	author tg;	state Exp;
branches;
next	1.19;
commitid	1005A10B12D3E83E46B;

1.19
date	2017.08.11.23.49.29;	author tg;	state Exp;
branches;
next	1.18;
commitid	100598E42983648CD3E;

1.18
date	2017.08.11.23.14.37;	author tg;	state Exp;
branches;
next	1.17;
commitid	100598E3A50558A800E;

1.17
date	2017.08.11.22.48.30;	author tg;	state Exp;
branches;
next	1.16;
commitid	100598E34506B7923D1;

1.16
date	2017.08.11.22.45.28;	author tg;	state Exp;
branches;
next	1.15;
commitid	100598E339526A1CA02;

1.15
date	2017.08.11.22.20.33;	author tg;	state Exp;
branches;
next	1.14;
commitid	100598E2DC30D72D553;

1.14
date	2017.08.11.22.10.36;	author tg;	state Exp;
branches;
next	1.13;
commitid	100598E2B6813013053;

1.13
date	2017.08.11.21.24.28;	author tg;	state Exp;
branches;
next	1.12;
commitid	100598E209F00E2A351;

1.12
date	2017.08.11.21.19.07;	author tg;	state Exp;
branches;
next	1.11;
commitid	100598E1F4737C8AB74;

1.11
date	2017.01.08.19.13.05;	author tg;	state Exp;
branches;
next	1.10;
commitid	10058728F2D5F1A39E6;

1.10
date	2011.06.11.00.39.38;	author tg;	state Exp;
branches;
next	1.9;
commitid	1004DF2B94660192B86;

1.9
date	2011.06.11.00.24.05;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004DF2B5B25E899A1F;

1.8
date	2010.09.19.19.43.10;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004C9667C83946BB2E;

1.7
date	2010.09.16.20.56.10;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004C928463526833A8;

1.6
date	2007.03.10.23.53.44;	author tg;	state Exp;
branches;
next	1.5;
commitid	10045F344D65465EF23;

1.5
date	2005.12.16.16.09.46;	author tg;	state Exp;
branches;
next	1.4;
commitid	10043A2E6BF072740FB;

1.4
date	2005.12.05.22.12.50;	author tg;	state Exp;
branches;
next	1.3;
commitid	78e44394bb6132ce;

1.3
date	2005.04.19.20.58.22;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.13.15.50.39;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.06.15.17.56;	author tg;	state Exp;
branches
	1.1.101.1;
next	;

1.1.101.1
date	2005.03.06.15.17.56;	author tg;	state Exp;
branches;
next	1.1.101.2;

1.1.101.2
date	2005.04.19.20.33.19;	author tg;	state Exp;
branches;
next	1.1.101.3;

1.1.101.3
date	2005.12.05.21.43.45;	author tg;	state Exp;
branches;
next	;
commitid	2cec4394b499b817;


desc
@@


1.20
log
@allow cvs -R with :fork:
@
text
@/*
 * Copyright © 2017
 *	mirabilos <m@@mirbsd.org>
 *
 * Copyright (C) 1986-2005 The Free Software Foundation, Inc.
 *
 * Portions Copyright (C) 1998-2005 Derek Price, Ximbiot <http://ximbiot.com>,
 *                                  and others.
 *
 * Poritons Copyright (c) 1992, Mark D. Baushke
 *
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS source distribution.
 * 
 * Name of Root
 * 
 * Determine the path to the CVSROOT and set "Root" accordingly.
 */

#include "cvs.h"
#include <assert.h>
#include "getline.h"

__RCSID("$MirOS: src/gnu/usr.bin/cvs/src/root.c,v 1.19 2017/08/11 23:49:29 tg Exp $");

/* Printable names for things in the current_parsed_root->method enum variable.
   Watch out if the enum is changed in cvs.h! */

const char method_names[][16] = {
    "undefined", "local", "server (rsh)", "pserver",
    "kserver", "gserver", "ext", "fork"
};

#ifndef DEBUG

cvsroot_t *
Name_Root (const char *dir, const char *update_dir)
{
    FILE *fpin;
    cvsroot_t *ret;
    const char *xupdate_dir;
    char *root = NULL;
    size_t root_allocated = 0;
    char *tmp;
    char *cvsadm;
    char *cp;
    int len;

    TRACE (TRACE_FLOW, "Name_Root (%s, %s)",
	   dir ? dir : "(null)",
	   update_dir ? update_dir : "(null)");

    if (update_dir && *update_dir)
	xupdate_dir = update_dir;
    else
	xupdate_dir = ".";

    if (dir != NULL)
    {
	cvsadm = Xasprintf ("%s/%s", dir, CVSADM);
	tmp = Xasprintf ("%s/%s", dir, CVSADM_ROOT);
    }
    else
    {
	cvsadm = xstrdup (CVSADM);
	tmp = xstrdup (CVSADM_ROOT);
    }

    /*
     * Do not bother looking for a readable file if there is no cvsadm
     * directory present.
     *
     * It is possible that not all repositories will have a CVS/Root
     * file. This is ok, but the user will need to specify -d
     * /path/name or have the environment variable CVSROOT set in
     * order to continue.  */
    if ((!isdir (cvsadm)) || (!isreadable (tmp)))
    {
	ret = NULL;
	goto out;
    }

    /*
     * The assumption here is that the CVS Root is always contained in the
     * first line of the "Root" file.
     */
    fpin = xfopen (tmp, "r");

    if ((len = getline (&root, &root_allocated, fpin)) < 0)
    {
	int saved_errno = errno;
	/* FIXME: should be checking for end of file separately; errno
	   is not set in that case.  */
	error (0, 0, "in directory %s:", xupdate_dir);
	error (0, saved_errno, "cannot read %s", CVSADM_ROOT);
	error (0, 0, "please correct this problem");
	ret = NULL;
	goto out;
    }
    fclose (fpin);
    cp = root + len - 1;
    if (*cp == '\n')
	*cp = '\0';			/* strip the newline */

    /*
     * root now contains a candidate for CVSroot. It must be an
     * absolute pathname or specify a remote server.
     */

    ret = parse_cvsroot (root);
    if (ret == NULL)
    {
	error (0, 0, "in directory %s:", xupdate_dir);
	error (0, 0,
	       "ignoring %s because it does not contain a valid root.",
	       CVSADM_ROOT);
	goto out;
    }

    if (!ret->isremote && !isdir (ret->directory))
    {
	error (0, 0, "in directory %s:", xupdate_dir);
	error (0, 0,
	       "ignoring %s because it specifies a non-existent repository %s",
	       CVSADM_ROOT, root);
	ret = NULL;
	goto out;
    }


 out:
    free (cvsadm);
    free (tmp);
    if (root != NULL)
	free (root);
    return ret;
}



/*
 * Write the CVS/Root file so that the environment variable CVSROOT
 * and/or the -d option to cvs will be validated or not necessary for
 * future work.
 */
void
Create_Root (const char *dir, const char *rootdir)
{
    FILE *fout;
    char *tmp;

    if (noexec)
	return;

    /* record the current cvs root */

    if (rootdir != NULL)
    {
        if (dir != NULL)
	    tmp = Xasprintf ("%s/%s", dir, CVSADM_ROOT);
        else
	    tmp = xstrdup (CVSADM_ROOT);

        fout = xfopen (tmp, "w+");
        if (fprintf (fout, "%s\n", rootdir) < 0)
	    error (1, errno, "write to %s failed", tmp);
        if (fclose (fout) == EOF)
	    error (1, errno, "cannot close %s", tmp);
	free (tmp);
    }
}

#endif /* ! DEBUG */



/* Translate an absolute repository string for a primary server and return it.
 *
 * INPUTS
 *   root_in	The root to be translated.
 *
 * RETURNS
 *   A translated string this function owns, or a pointer to the original
 *   string passed in if no translation was necessary.
 *
 *   If the returned string is the translated one, it may be overwritten
 *   by the next call to this function.
 */
const char *
primary_root_translate (const char *root_in)
{
#ifdef PROXY_SUPPORT
    char *translated;
    static char *previous = NULL;
    static size_t len;

    /* This can happen, for instance, during `cvs init'.  */
    if (!config) return root_in;

    if (config->PrimaryServer
        && !strncmp (root_in, config->PrimaryServer->directory,
		     strlen (config->PrimaryServer->directory))
        && (ISSLASH (root_in[strlen (config->PrimaryServer->directory)])
            || root_in[strlen (config->PrimaryServer->directory)] == '\0')
       )
    {
	translated =
	    Xasnprintf (previous, &len,
		        "%s%s", current_parsed_root->directory,
	                root_in + strlen (config->PrimaryServer->directory));
	if (previous && previous != translated)
	    free (previous);
	return previous = translated;
    }
#endif

    /* There is no primary root configured or it didn't match.  */
    return root_in;
}



/* Translate a primary root in reverse for PATHNAMEs in responses.
 *
 * INPUTS
 *   root_in	The root to be translated.
 *
 * RETURNS
 *   A translated string this function owns, or a pointer to the original
 *   string passed in if no translation was necessary.
 *
 *   If the returned string is the translated one, it may be overwritten
 *   by the next call to this function.
 */
const char *
primary_root_inverse_translate (const char *root_in)
{
#ifdef PROXY_SUPPORT
    char *translated;
    static char *previous = NULL;
    static size_t len;

    /* This can happen, for instance, during `cvs init'.  */
    if (!config) return root_in;

    if (config->PrimaryServer
        && !strncmp (root_in, current_parsed_root->directory,
		     strlen (current_parsed_root->directory))
        && (ISSLASH (root_in[strlen (current_parsed_root->directory)])
            || root_in[strlen (current_parsed_root->directory)] == '\0')
       )
    {
	translated =
	    Xasnprintf (previous, &len,
		        "%s%s", config->PrimaryServer->directory,
	                root_in + strlen (current_parsed_root->directory));
	if (previous && previous != translated)
	    free (previous);
	return previous = translated;
    }
#endif

    /* There is no primary root configured or it didn't match.  */
    return root_in;
}



/* The root_allow_* stuff maintains a list of valid CVSROOT
   directories.  Then we can check against them when a remote user
   hands us a CVSROOT directory.  */
static List *root_allow;
static List *root_allow_regexp;

static void
delconfig (Node *n)
{
    if (n->data) free_config (n->data);
}



void
root_allow_add (const char *arg, const char *configPath)
{
    Node *n;

    if (!root_allow) root_allow = getlist();
    n = getnode();
    n->key = xstrdup (arg);
    n->data = parse_config (arg, configPath);
    n->delproc = delconfig;
    addnode (root_allow, n);
}

void
root_allow_regexp_add (const char *arg, const char *configPath)
{
    Node *n;

    if (!root_allow_regexp) root_allow_regexp = getlist();
    n = getnode();
    n->key = xstrdup (arg);

    /* This is a regexp, not the final cvsroot path - we cannot attach
       it a config. So we attach configPath and we'll root_allow_add()
       the actual, matching root in root_allow_compare_regexp() */
    n->data = (void*)configPath;

    addnode (root_allow_regexp, n);
}

void
root_allow_free (void)
{
    dellist (&root_allow);
    dellist (&root_allow_regexp);
}

int
root_allow_used (void)
{
    return root_allow || root_allow_regexp;
}

/* walklist() callback for determining if 'root_to_check' matches
   n->key (a regexp). If yes, 'root_to_check' will be added as if
   directly specified through --allow-root.
 */
static int
root_allow_compare_regexp (Node *n, void *root_to_check)
{
  int status;
  regex_t re;

  if (regcomp(&re, n->key,
	      REG_EXTENDED|REG_NOSUB) != 0)
  {
      return 0;      /* report error? */
  }
  status = regexec(&re, root_to_check, (size_t) 0, NULL, 0);
  regfree(&re);
  if (status == 0)
  {
      /* n->data contains gConfigPath */
      root_allow_add (root_to_check, n->data);
      return 1;
  }
  return 0;
}

bool
root_allow_ok (const char *arg)
{
    if (!root_allow_used())
    {
	/* Probably someone upgraded from CVS before 1.9.10 to 1.9.10
	   or later without reading the documentation about
	   --allow-root.  Printing an error here doesn't disclose any
	   particularly useful information to an attacker because a
	   CVS server configured in this way won't let *anyone* in.  */

	/* Note that we are called from a context where we can spit
	   back "error" rather than waiting for the next request which
	   expects responses.  */
	printf ("\
error 0 Server configuration missing --allow-root or --allow-root-regexp in inetd.conf\n");
	exit (EXIT_FAILURE);
    }

    /* Look for 'arg' in the list of full-path allowed roots */
    if (findnode (root_allow, arg))
	return true;

    /* Match 'arg' against the list of allowed roots regexps */
    if (walklist (root_allow_regexp, root_allow_compare_regexp, (void*)arg))
      return true;

    return false;
}



/* Get a config we stored in response to root_allow.
 *
 * RETURNS
 *   The config associated with ARG.
 */
struct config *
get_root_allow_config (const char *arg, const char *configPath)
{
    Node *n;

    TRACE (TRACE_FUNCTION, "get_root_allow_config (%s)", arg);

    if (root_allow)
	n = findnode (root_allow, arg);
    else
	n = NULL;

    if (n) return n->data;
    return parse_config (arg, configPath);
}



/* This global variable holds the global -d option.  It is NULL if -d
   was not used, which means that we must get the CVSroot information
   from the CVSROOT environment variable or from a CVS/Root file.  */
char *CVSroot_cmdline;



/* FIXME - Deglobalize this. */
cvsroot_t *current_parsed_root = NULL;
/* Used to save the original root being processed so that we can still find it
 * in lists and the like after a `Redirect' response.  Also set to mirror
 * current_parsed_root in server mode so that code which runs on both the
 * client and server but which wants to use original data on the client can
 * just always reference the original_parsed_root.
 */
const cvsroot_t *original_parsed_root;


/* allocate and initialize a cvsroot_t
 *
 * We must initialize the strings to NULL so we know later what we should
 * free
 *
 * Some of the other zeroes remain meaningful as, "never set, use default",
 * or the like
 */
/* Functions which allocate memory are not pure.  */
static cvsroot_t *new_cvsroot_t(void)
    __attribute__( (__malloc__) );
static cvsroot_t *
new_cvsroot_t (void)
{
    cvsroot_t *newroot;

    /* gotta store it somewhere */
    newroot = xmalloc(sizeof(cvsroot_t));

    newroot->original = NULL;
    newroot->directory = NULL;
    newroot->method = null_method;
    newroot->isremote = false;
#ifdef CLIENT_SUPPORT
    newroot->username = NULL;
    newroot->password = NULL;
    newroot->hostname = NULL;
    newroot->cvs_rsh = NULL;
    newroot->cvs_server = NULL;
    newroot->port = 0;
    newroot->proxy_hostname = NULL;
    newroot->proxy_port = 0;
    newroot->redirect = true;	/* Advertise Redirect support */
#endif /* CLIENT_SUPPORT */

    return newroot;
}



/* Dispose of a cvsroot_t and its component parts.
 *
 * NOTE
 *  It is dangerous for most code to call this function since parse_cvsroot
 *  maintains a cache of parsed roots.
 */
static void
free_cvsroot_t (cvsroot_t *root)
{
    assert (root);
    if (root->original != NULL)
	free (root->original);
    if (root->directory != NULL)
	free (root->directory);
#ifdef CLIENT_SUPPORT
    if (root->username != NULL)
	free (root->username);
    if (root->password != NULL)
    {
	/* I like to be paranoid */
	memset (root->password, 0, strlen (root->password));
	free (root->password);
    }
    if (root->hostname != NULL)
	free (root->hostname);
    if (root->cvs_rsh != NULL)
	free (root->cvs_rsh);
    if (root->cvs_server != NULL)
	free (root->cvs_server);
    if (root->proxy_hostname != NULL)
	free (root->proxy_hostname);
#endif /* CLIENT_SUPPORT */
    free (root);
}


#if defined(CLIENT_SUPPORT) || defined (SERVER_SUPPORT)
static char *validate_hostname(const char *) __attribute__((__malloc__));
#endif /* defined(CLIENT_SUPPORT) || defined (SERVER_SUPPORT) */

/*
 * Parse a CVSROOT string to allocate and return a new cvsroot_t structure.
 * Valid specifications are:
 *
 *	:(gserver|kserver|pserver):[[user][:password]@@]host[:[port]]/path
 *	[:(ext|server):][[user]@@]host[:]/path
 *	[:local:[e:]]/path
 *	:fork:/path
 *
 * INPUTS
 *	root_in		C String containing the CVSROOT to be parsed.
 *
 * RETURNS
 *	A pointer to a newly allocated cvsroot_t structure upon success and
 *	NULL upon failure.  The caller should never dispose of this structure,
 *	as it is stored in a cache, but the caller may rely on it not to
 *	change.
 *
 * NOTES
 * 	This would have been a lot easier to write in Perl.
 *
 *	Would it make sense to reimplement the root and config file parsing
 *	gunk in Lex/Yacc?
 *
 * SEE ALSO
 * 	free_cvsroot_t()
 */
cvsroot_t *
parse_cvsroot (const char *root_in)
{
    cvsroot_t *newroot;			/* the new root to be returned */
    char *cvsroot_save;			/* what we allocated so we can dispose
					 * it when finished */
    char *cvsroot_copy, *p;		/* temporary pointers for parsing */
#if defined(CLIENT_SUPPORT) || defined (SERVER_SUPPORT)
    char *q;				/* temporary pointer for parsing */
    char *firstslash;			/* save where the path spec starts
					 * while we parse
					 * [[user][:password]@@]host[:[port]]
					 */
    int check_hostname, no_port, no_password, no_proxy;
#endif /* defined(CLIENT_SUPPORT) || defined (SERVER_SUPPORT) */
    static List *cache = NULL;
    Node *node;

    assert (root_in != NULL);

    /* This message is TRACE_FLOW since this function is called repeatedly by
     * the recursion routines.
     */
    TRACE (TRACE_FLOW, "parse_cvsroot (%s)", root_in);

    if ((node = findnode (cache, root_in)))
	return node->data;

    assert (root_in);

    /* allocate some space */
    newroot = new_cvsroot_t();

    /* save the original string */
    newroot->original = xstrdup (root_in);

    /* and another copy we can munge while parsing */
    cvsroot_save = cvsroot_copy = xstrdup (root_in);

    if (*cvsroot_copy == ':')
    {
	char *method = ++cvsroot_copy;

	/* Access method specified, as in
	 * "cvs -d :(gserver|kserver|pserver):[[user][:password]@@]host[:[port]]/path",
	 * "cvs -d [:(ext|server):][[user]@@]host[:]/path",
	 * "cvs -d :local:e:\path",
	 * "cvs -d :fork:/path".
	 * We need to get past that part of CVSroot before parsing the
	 * rest of it.
	 */

	if (! (p = strchr (method, ':')))
	{
	    error (0, 0, "No closing `:' on method in CVSROOT.");
	    goto error_exit;
	}
	*p = '\0';
	cvsroot_copy = ++p;

#if defined (CLIENT_SUPPORT) || defined (SERVER_SUPPORT)
	/* Look for method options, for instance, proxy, proxyport.
	 * Calling strtok again is saved until after parsing the method.
	 */
	method = strtok (method, ";");
	if (!method)
	    /* Could just exit now, but this keeps the error message in sync.
	     */
	    method = "";
#endif /* defined (CLIENT_SUPPORT) || defined (SERVER_SUPPORT) */

    if (NULL == method)
	{
	    error (0, 0, "Missing method in CVSROOT.");
	    goto error_exit;
	}

	/* Now we have an access method -- see if it's valid. */

	if (!strcasecmp (method, "local"))
	    newroot->method = local_method;
	else if (!strcasecmp (method, "pserver"))
	    newroot->method = pserver_method;
	else if (!strcasecmp (method, "kserver"))
	    newroot->method = kserver_method;
	else if (!strcasecmp (method, "gserver"))
	    newroot->method = gserver_method;
	else if (!strcasecmp (method, "server"))
	    newroot->method = server_method;
	else if (strncmp (method, "ext=", 4) == 0)
	{
	    newroot->cvs_rsh = xstrdup(method + 4);
	    newroot->method = ext_method;
	}
	else if (!strcasecmp (method, "extssh"))
	{
	    newroot->cvs_rsh = xstrdup("ssh");
	    newroot->method = extssh_method;
	}
	else if (!strcasecmp (method, "ext"))
	    newroot->method = ext_method;
	else if (!strcasecmp (method, "fork"))
	    newroot->method = fork_method;
	else
	{
	    error (0, 0, "Unknown method (`%s') in CVSROOT.", method);
	    goto error_exit;
	}

#if defined (CLIENT_SUPPORT) || defined (SERVER_SUPPORT)
	/* Parse the method options, for instance, proxy, proxyport */
	while ((p = strtok (NULL, ";")))
	{
	    char *q = strchr (p, '=');
	    if (q == NULL)
	    {
	        error (0, 0, "Option (`%s') has no argument in CVSROOT.",
                       p);
	        goto error_exit;
	    }

	    *q++ = '\0';
	    TRACE (TRACE_DATA, "CVSROOT option=`%s' value=`%s'", p, q);
	    if (!strcasecmp (p, "proxy"))
	    {
		if (!(newroot->proxy_hostname = validate_hostname(q))) {
			error(0, 0, "Invalid proxy hostname: %s", q);
			goto error_exit;
		}
	    }
	    else if (!strcasecmp (p, "proxyport"))
	    {
		char *r = q;

		do {
		    if (!isdigit(*r)) {
 proxy_port_error:
			error (0, 0,
"CVSROOT may only specify a positive, non-zero, integer proxy port (not `%s').",
			       q);
			goto error_exit;
		    }
		} while (*++r);
		if ((newroot->proxy_port = atoi(q)) <= 0 ||
		    newroot->proxy_port > 65535)
			goto proxy_port_error;
	    }
	    else if (!strcasecmp (p, "CVS_RSH"))
	    {
		/* override CVS_RSH environment variable */
		if (newroot->method == ext_method
		    || newroot->method == extssh_method)
		newroot->cvs_rsh = xstrdup (q);
	    }
	    else if (!strcasecmp (p, "CVS_SERVER"))
	    {
		/* override CVS_SERVER environment variable */
		if (newroot->method == ext_method
		    || newroot->method == extssh_method
		    || newroot->method == fork_method)
		    newroot->cvs_server = xstrdup (q);
	    }
	    else if (!strcasecmp (p, "Redirect"))
		readBool ("CVSROOT", "Redirect", q, &newroot->redirect);
	    else
	    {
	        error (0, 0, "Unknown option (`%s') in CVSROOT.", p);
	        goto error_exit;
	    }
	}
#endif /* defined (CLIENT_SUPPORT) || defined (SERVER_SUPPORT) */
    }
    else
    {
	/* If the method isn't specified, assume EXT_METHOD if the string looks
	   like a relative path and LOCAL_METHOD otherwise.  */

	newroot->method = ((*cvsroot_copy != '/' && strchr (cvsroot_copy, '/'))
			  ? ext_method
			  : local_method);
    }

    /*
     * There are a few sanity checks we can do now, only knowing the
     * method of this root.
     */

    newroot->isremote = (newroot->method != local_method);

#if defined (CLIENT_SUPPORT) || defined (SERVER_SUPPORT)
    if (readonlyfs && newroot->isremote && (newroot->method != ext_method)
      && (newroot->method != extssh_method) && (newroot->method != fork_method))
	error (1, 0,
"Read-only repository feature unavailable with remote roots (cvsroot = %s)",
	       cvsroot_copy);

    if ((newroot->method != local_method)
	&& (newroot->method != fork_method)
       )
    {
	/* split the string into [[user][:password]@@]host[:[port]] & /path
	 *
	 * this will allow some characters such as '@@' & ':' to remain unquoted
	 * in the path portion of the spec
	 */
	if ((p = strchr (cvsroot_copy, '/')) == NULL)
	{
	    error (0, 0, "CVSROOT requires a path spec:");
	    error (0, 0,
":(gserver|kserver|pserver):[[user][:password]@@]host[:[port]]/path");
	    error (0, 0, "[:(ext|server):][[user]@@]host[:]/path");
	    goto error_exit;
	}
	firstslash = p;		/* == NULL if '/' not in string */
	*p = '\0';

	/* Check to see if there is a username[:password] in the string. */
	if ((p = strchr (cvsroot_copy, '@@')) != NULL)
	{
	    *p = '\0';
	    /* check for a password */
	    if ((q = strchr (cvsroot_copy, ':')) != NULL)
	    {
		*q = '\0';
		newroot->password = xstrdup (++q);
		/* Don't check for *newroot->password == '\0' since
		 * a user could conceivably wish to specify a blank password
		 *
		 * (newroot->password == NULL means to use the
		 * password from .cvspass)
		 */
	    }

	    /* copy the username */
	    if (*cvsroot_copy != '\0')
		/* a blank username is impossible, so leave it NULL in that
		 * case so we know to use the default username
		 */
	    {
		/* for want of strcspn */
		if (/* no at, obviously */ strchr(cvsroot_copy, '@@') ||
		    /* no colon, interference with CVSROOT/passwd file */
		    strchr(cvsroot_copy, ':') ||
		    /* no linefeeds, interference with pserver protocol */
		    strchr(cvsroot_copy, '\012')) {
			error(0, 0, "Bad username \"%s\"", cvsroot_copy);
			goto error_exit;
		}
		/* other limitations include not beginning with a
		 * hyphen-minus but that’s not even a requirement
		 * in POSIX, let alone other operating environments…
		 */
		newroot->username = xstrdup (cvsroot_copy);
	    }

	    cvsroot_copy = ++p;
	}

	/* now deal with host[:[port]] */

	/* the port */
	if ((p = strchr (cvsroot_copy, ':')) != NULL)
	{
	    *p++ = '\0';
	    if (*p)
	    {
		char qch;

		q = p;
		while ((qch = *q++))
		{
		    if (!isdigit(qch))
			goto parse_port_error;
		}
		if ((newroot->port = atoi(p)) <= 0 || newroot->port > 65535) {
 parse_port_error:
		    error (0, 0,
"CVSROOT may only specify a positive, non-zero, integer port (not `%s').",
			    p);
		    error (0, 0, "Perhaps you entered a relative pathname?");
		    goto error_exit;
		}
	    }
	}

	/* check and copy host */
	newroot->hostname = validate_hostname(cvsroot_copy);

	/* restore the '/' */
	cvsroot_copy = firstslash;
	*cvsroot_copy = '/';
    }
#endif /* defined(CLIENT_SUPPORT) || defined (SERVER_SUPPORT) */

    /*
     * Parse the path for all methods.
     */
    /* Here & local_cvsroot() should be the only places this needs to be
     * called on a CVSROOT now.  cvsroot->original is saved for error messages
     * and, otherwise, we want no trailing slashes.
     */
    Sanitize_Repository_Name (cvsroot_copy);
    newroot->directory = xstrdup (cvsroot_copy);

    /*
     * Do various sanity checks.
     */

#if defined(CLIENT_SUPPORT) || defined (SERVER_SUPPORT)
    if (newroot->username && ! newroot->hostname)
    {
	/* this defangs sanity.sh tests for remote reject, though */
 bad_hostname:
	error (0, 0, "Missing or bad hostname in CVSROOT.");
	goto error_exit;
    }

    /* We won't have attempted to parse these without CLIENT_SUPPORT or
     * SERVER_SUPPORT.
     */
    check_hostname = 0;
    no_password = 1;
    no_proxy = 1;
    no_port = 0;
#endif /* defined (CLIENT_SUPPORT) || defined (SERVER_SUPPORT) */
    switch (newroot->method)
    {
    case local_method:
#if defined(CLIENT_SUPPORT) || defined (SERVER_SUPPORT)
	if (newroot->username || newroot->hostname)
	{
	    error (0, 0, "Can't specify hostname and username in CVSROOT");
	    error (0, 0, "when using local access method.");
	    goto error_exit;
	}
#endif /* defined(CLIENT_SUPPORT) || defined (SERVER_SUPPORT) */
	/* cvs.texinfo has always told people that CVSROOT must be an
	   absolute pathname.  Furthermore, attempts to use a relative
	   pathname produced various errors (I couldn't get it to work),
	   so there would seem to be little risk in making this a fatal
	   error.  */
	if (!ISABSOLUTE (newroot->directory))
	{
	    error (0, 0, "CVSROOT must be an absolute pathname (not `%s')",
		   newroot->directory);
	    error (0, 0, "when using local access method.");
	    goto error_exit;
	}
#if defined(CLIENT_SUPPORT) || defined (SERVER_SUPPORT)
	/* We don't need to check for these in :local: mode, really, since
	 * we shouldn't be able to hit the code above which parses them, but
	 * I'm leaving them here in lieu of assertions.
	 */
	no_port = 1;
	/* no_password already set */
#endif /* defined(CLIENT_SUPPORT) || defined (SERVER_SUPPORT) */
	break;
#if defined(CLIENT_SUPPORT) || defined (SERVER_SUPPORT)
    case fork_method:
	/* We want :fork: to behave the same as other remote access
           methods.  Therefore, don't check to see that the repository
           name is absolute -- let the server do it.  */
	if (newroot->username || newroot->hostname)
	{
	    error (0, 0, "Can't specify hostname and username in CVSROOT");
	    error (0, 0, "when using fork access method.");
	    goto error_exit;
	}
	newroot->hostname = xstrdup("server");  /* for error messages */
	if (!ISABSOLUTE (newroot->directory))
	{
	    error (0, 0, "CVSROOT must be an absolute pathname (not `%s')",
		   newroot->directory);
	    error (0, 0, "when using fork access method.");
	    goto error_exit;
	}
	no_port = 1;
	/* no_password already set */
	break;
    case kserver_method:
	check_hostname = 1;
	/* no_password already set */
	break;
    case gserver_method:
	check_hostname = 1;
	no_proxy = 0;
	/* no_password already set */
	break;
    case server_method:
    case ext_method:
	no_port = 1;
    case extssh_method:
	/* no_password already set */
	check_hostname = 1;
	break;
    case pserver_method:
	no_password = 0;
	no_proxy = 0;
	check_hostname = 1;
	break;
#endif /* defined(CLIENT_SUPPORT) || defined (SERVER_SUPPORT) */
    default:
	error (1, 0, "Invalid method found in parse_cvsroot");
    }

#if defined(CLIENT_SUPPORT) || defined (SERVER_SUPPORT)
    if (no_password && newroot->password)
    {
	error (0, 0, "CVSROOT password specification is only valid for");
	error (0, 0, "pserver connection method.");
	goto error_exit;
    }
    if (no_proxy && (newroot->proxy_hostname || newroot->proxy_port))
    {
	error (0, 0,
"CVSROOT proxy specification is only valid for gserver and");
	error (0, 0, "pserver connection methods.");
	goto error_exit;
    }

    if (!newroot->proxy_hostname && newroot->proxy_port)
    {
	error (0, 0, "Proxy port specified in CVSROOT without proxy host.");
	goto error_exit;
    }

    if (check_hostname && !newroot->hostname)
	goto bad_hostname;

    if (no_port && newroot->port)
    {
        error (0, 0,
"CVSROOT port specification is only valid for extssh,");
        error (0, 0, "gserver, kserver and pserver connection methods.");
        goto error_exit;
    }
#endif /* defined(CLIENT_SUPPORT) || defined (SERVER_SUPPORT) */

    if (*newroot->directory == '\0')
    {
	error (0, 0, "Missing directory in CVSROOT.");
	goto error_exit;
    }
    
    /* Hooray!  We finally parsed it! */
    free (cvsroot_save);

    if (!cache) cache = getlist();
    node = getnode();
    node->key = xstrdup (newroot->original);
    node->data = newroot;
    addnode (cache, node);
    return newroot;

error_exit:
    free (cvsroot_save);
    free_cvsroot_t (newroot);
    return NULL;
}



#ifdef AUTH_CLIENT_SUPPORT
/* Use root->username, root->hostname, root->port, and root->directory
 * to create a normalized CVSROOT fit for the .cvspass file
 *
 * username defaults to the result of getcaller()
 * port defaults to the result of get_cvs_port_number()
 *
 * FIXME - we could cache the canonicalized version of a root inside the
 * cvsroot_t, but we'd have to un'const the input here and stop expecting the
 * caller to be responsible for our return value
 *
 * ASSUMPTIONS
 *   ROOT->method == pserver_method
 */
char *
normalize_cvsroot (const cvsroot_t *root)
{
    char *cvsroot_canonical;
    char *p, *hostname;

    assert (root && root->hostname && root->directory);

    /* use a lower case hostname since we know hostnames are case insensitive */
    /* Some logic says we should be tacking our domain name on too if it isn't
     * there already, but for now this works.  Reverse->Forward lookups are
     * almost certainly too much since that would make CVS immune to some of
     * the DNS trickery that makes life easier for sysadmins when they want to
     * move a repository or the like
     */
    p = hostname = xstrdup (root->hostname);
    while (*p)
    {
	*p = tolower (*p);
	p++;
    }

    cvsroot_canonical = Xasprintf (":pserver:%s@@%s:%d%s",
                                   root->username ? root->username
                                                  : getcaller(),
                                   hostname, get_cvs_port_number (root),
                                   root->directory);

    free (hostname);
    return cvsroot_canonical;
}
#endif /* AUTH_CLIENT_SUPPORT */



#ifdef PROXY_SUPPORT
/* A walklist() function to walk the root_allow list looking for a PrimaryServer
 * configuration with a directory matching the requested directory.
 *
 * If found, replace it.
 */
static bool get_local_root_dir_done;
static int
get_local_root_dir (Node *p, void *root_in)
{
    struct config *c = p->data;
    char **r = root_in;

    if (get_local_root_dir_done)
	return 0;

    if (c->PrimaryServer && !strcmp (*r, c->PrimaryServer->directory))
    {
	free (*r);
	*r = xstrdup (p->key);
	get_local_root_dir_done = true;
    }
    return 0;
}
#endif /* PROXY_SUPPORT */



/* allocate and return a cvsroot_t structure set up as if we're using the local
 * repository DIR.  */
cvsroot_t *
local_cvsroot (const char *dir)
{
    cvsroot_t *newroot = new_cvsroot_t();

    newroot->original = xstrdup(dir);
    newroot->method = local_method;
    newroot->directory = xstrdup(dir);
    /* Here and parse_cvsroot() should be the only places this needs to be
     * called on a CVSROOT now.  cvsroot->original is saved for error messages
     * and, otherwise, we want no trailing slashes.
     */
    Sanitize_Repository_Name (newroot->directory);

#ifdef PROXY_SUPPORT
    /* Translate the directory to a local one in the case that we are
     * configured as a secondary.  If root_allow has not been initialized,
     * nothing happens.
     */
    get_local_root_dir_done = false;
    walklist (root_allow, get_local_root_dir, &newroot->directory);
#endif /* PROXY_SUPPORT */

    return newroot;
}



#ifdef DEBUG
/* This is for testing the parsing function.  Use

     gcc -I. -I.. -I../lib -DDEBUG root.c -o root

   to compile.  */

#include <stdio.h>

char *program_name = "testing";
char *cvs_cmd_name = "parse_cvsroot";		/* XXX is this used??? */

void
main (int argc, char *argv[])
{
    program_name = argv[0];

    if (argc != 2)
    {
	fprintf (stderr, "Usage: %s <CVSROOT>\n", program_name);
	exit (2);
    }
  
    if ((current_parsed_root = parse_cvsroot (argv[1])) == NULL)
    {
	fprintf (stderr, "%s: Parsing failed.\n", program_name);
	exit (1);
    }
    printf ("CVSroot: %s\n", argv[1]);
    printf ("current_parsed_root->method: %s\n",
	    method_names[current_parsed_root->method]);
    printf ("current_parsed_root->username: %s\n",
	    current_parsed_root->username
	      ? current_parsed_root->username : "NULL");
    printf ("current_parsed_root->hostname: %s\n",
	    current_parsed_root->hostname
	      ? current_parsed_root->hostname : "NULL");
    printf ("current_parsed_root->directory: %s\n",
	    current_parsed_root->directory);

   exit (0);
   /* NOTREACHED */
}
#endif

#if defined(CLIENT_SUPPORT) || defined (SERVER_SUPPORT)
#define CLS_INVALID	0
#define CLS_INSIDE	1
#define CLS_OUTSIDE	2
#define CLS_SEPARATOR	4
/* EBCDIC safe */
#define CLASSIFY(x)	classify[(unsigned char)(x)]
static char *
validate_hostname(const char *s)
{
	char *buf, *cp;
	size_t sz;
	static char classify_initialised = 0, *classify;

	/* initialise classification table */
	if (!classify_initialised) {
		const char *ccp;

		classify = xmalloc(256);
		for (sz = 0; sz < 256; ++sz)
			CLASSIFY(sz) = CLS_INVALID;
		for (ccp = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
		    *ccp; ++ccp)
			CLASSIFY(*ccp) = CLS_INSIDE | CLS_OUTSIDE;
		CLASSIFY('-') = CLS_INSIDE;
		CLASSIFY('.') = CLS_SEPARATOR;
		classify_initialised = 1;
	}

	/* total size limit tolerating a trailing dot */
	if ((sz = strlen(s)) > 256)
		return (NULL);
	buf = xstrdup(s);

	/* drop trailing dot */
	if ((unsigned char)buf[sz - 1] == (unsigned char)'.')
		buf[--sz] = '\0';
	/* recheck */
	if (sz > 255) {
 err:
		free(buf);
		return (NULL);
	}

	/* check each label */
	cp = buf;
 loop:
	/* must begin with [0-9A-Za-z] */
	if (!(CLASSIFY(*cp++) & CLS_OUTSIDE))
		goto err;
	sz = 1;
	/* arbitrary many [0-9A-Za-z-] */
	while (CLASSIFY(*cp) & CLS_INSIDE) {
		++cp;
		++sz;
	}
	/* except the last must have been [0-9A-Za-z] again */
	if (!(CLASSIFY(cp[-1]) & CLS_OUTSIDE))
		goto err;
	/* maximum label size */
	if (sz > 63)
		goto err;
	/* next label? */
	if (CLASSIFY(*cp) & CLS_SEPARATOR) {
		++cp;
		goto loop;
	}
	/* must be end of string now */
	if (*cp)
		goto err;
	/* it is, everything okay */
	return (buf);
}
#endif /* defined(CLIENT_SUPPORT) || defined (SERVER_SUPPORT) */
@


1.19
log
@adjust the testsuite accordingly
@
text
@d24 1
a24 1
__RCSID("$MirOS: src/gnu/usr.bin/cvs/src/root.c,v 1.10 2011/06/11 00:39:38 tg Exp $");
d723 1
a723 1
	&& (newroot->method != extssh_method))
@


1.18
log
@r1.17 also caught local access where CVSROOT=..

since it’s already checked at all the right places, just harmonise
the error message (what’s one more goto in the error path after all)
@
text
@d2 3
d500 1
d843 1
@


1.17
log
@reject invalid hostnames earlier: Der Versuch ist strafbar.
@
text
@d814 1
a814 5
	if (!(newroot->hostname = validate_hostname(cvsroot_copy)) &&
	    *cvsroot_copy != '\0') {
		error(0, 0, "Invalid server hostname: %s", cvsroot_copy);
		goto error_exit;
	}
d839 1
d954 1
a954 4
    {
	error (0, 0, "Didn't specify hostname in CVSROOT.");
	goto error_exit;
    }
@


1.16
log
@usernames are the trickiest component; ensure internal consistency at least
@
text
@d814 5
a818 1
	newroot->hostname = validate_hostname(cvsroot_copy);
@


1.15
log
@offer the same protections to proxy host and port; bounds-check the port
@
text
@d766 14
d781 1
@


1.14
log
@the other VCSes are cautious, so implement hostname validation, too
@
text
@d653 4
a656 1
		newroot->proxy_hostname = xstrdup (q);
d661 4
a664 5
		if (*r == '-') r++;
		while (*r)
		{
		    if (!isdigit(*r++))
		    {
d670 4
a673 5
		}
		if ((newroot->proxy_port = atoi (q)) <= 0)
		    error (0, 0,
"CVSROOT may only specify a positive, non-zero, integer proxy port (not `%s').",
			   q);
d787 1
a787 2
		if ((newroot->port = atoi (p)) <= 0)
		{
@


1.13
log
@simplify and streamline port parsing
@
text
@d497 3
a499 1

d798 2
a799 7
	/* copy host */
	if (*cvsroot_copy != '\0') {
	    /* blank hostnames are invalid, but for now leave the field NULL
	     * and catch the error during the sanity checks later
	     */
	    newroot->hostname = xstrdup (cvsroot_copy);
	}
d824 1
a824 1
	error (0, 0, "Missing hostname in CVSROOT.");
d1127 75
@


1.12
log
@reject negative port numbers earlier; introduced by
2000-10-17  Derek Price  <derek.price@@openavenue.com>
@
text
@d774 1
a774 1
	    if (strlen(p))
d776 2
d779 1
a779 1
		while (*q)
d781 2
a782 9
		    if (!isdigit(*q++))
		    {
			error (0, 0,
"CVSROOT may only specify a positive, non-zero, integer port (not `%s').",
				p);
			error (0, 0,
                               "Perhaps you entered a relative pathname?");
			goto error_exit;
		    }
d786 1
d797 1
a797 1
	if (*cvsroot_copy != '\0')
d802 1
@


1.11
log
@Apply --allow-root-regexp patch, for the Savannah admins, slightly edited:
2007-05-09  Derek Price  <derek@@ximbiot.com> and/for Sylvain Beucler  <beuc@@beuc.net>
@
text
@a776 1
		if (*q == '-') q++;
@


1.10
log
@accept port when using extssh connection method (Closes: #151882)
@
text
@d21 1
a21 1
__RCSID("$MirOS: src/gnu/usr.bin/cvs/src/root.c,v 1.9 2011/06/11 00:24:05 tg Exp $");
d270 1
d294 17
d314 1
d320 27
a346 1
    return (root_allow != NULL);
d352 1
a352 1
    if (!root_allow)
d364 1
a364 1
error 0 Server configuration missing --allow-root in inetd.conf\n");
d368 1
d371 5
@


1.9
log
@make extssh a more separarte connection method and clean up old sins
@
text
@d21 1
a21 1
__RCSID("$MirOS: src/gnu/usr.bin/cvs/src/root.c,v 1.8 2010/09/19 19:43:10 tg Exp $");
d857 1
a858 1
	no_port = 1;
d902 2
a903 2
"CVSROOT port specification is only valid for gserver, kserver,");
        error (0, 0, "and pserver connection methods.");
@


1.8
log
@merge from ports/devel/cvs
@
text
@d21 1
a21 1
__RCSID("$MirOS: ports/devel/cvs/patches/patch-src_root_c,v 1.3 2010/09/15 20:57:02 tg Exp $");
d566 1
a566 2
	    const char *rsh = method + 4;
	    setenv ("CVS_RSH", rsh, 1); /* This is a hack, but simplifies */
d569 1
a569 1
	else if (strncmp (method, "extssh", 6) == 0)
d571 2
a572 3
	    const char *rsh = method + 3;
	    setenv ("CVS_RSH", rsh, 1); /* This is a hack, but simplifies */
	    newroot->method = ext_method;
d624 3
a626 2
		if (newroot->method == ext_method)
		    newroot->cvs_rsh = xstrdup (q);
d632 1
d664 2
a665 1
    if (readonlyfs && newroot->isremote && (newroot->method != ext_method))
d857 1
@


1.7
log
@begin attempting to synchronise with the port
@
text
@@


1.6
log
@sync the cvs port and the cvs in the base system;
RCSID stuff like in commitid 10045F33CB2157CFEAE
@
text
@d21 1
a21 1
__RCSID("$MirOS: src/gnu/usr.bin/cvs/src/root.c,v 1.5 2005/12/16 16:09:46 tg Exp $");
d298 6
d546 6
d564 12
@


1.5
log
@Implement forwarding of "readonlyfs" (acquired by either cvs -R or
export CVSREADONLYFS=1) to an :ext: server, after YEARS of cursing.
@
text
@a0 2
/* $MirOS: src/gnu/usr.bin/cvs/src/root.c,v 1.4 2005/12/05 22:12:50 tg Exp $ */

d21 1
a21 1
__RCSID("$MirOS: src/gnu/usr.bin/cvs/src/root.c,v 1.4 2005/12/05 22:12:50 tg Exp $");
@


1.4
log
@merge (sans generated files)
re-do the commitid generator
@
text
@d1 1
a1 1
/* $MirOS: src/gnu/usr.bin/cvs/src/root.c,v 1.3 2005/04/19 20:58:22 tg Exp $ */
d23 1
a23 1
__RCSID("$MirOS: src/gnu/usr.bin/cvs/src/root.c,v 1.3 2005/04/19 20:58:22 tg Exp $");
d642 1
a642 1
    if (readonlyfs && newroot->isremote && !quiet)
@


1.3
log
@initial fubar'ing of the CVS port
this won't even build right now...
@
text
@d1 1
a1 1
/* $MirOS: src/gnu/usr.bin/cvs/src/root.c,v 1.2 2005/03/13 15:50:39 tg Exp $ */
d23 1
a23 1
__RCSID("$MirOS: src/gnu/usr.bin/cvs/src/root.c,v 1.2 2005/03/13 15:50:39 tg Exp $");
d119 1
a119 5
    if (
#ifdef CLIENT_SUPPORT
        !ret->isremote &&
#endif
        !isdir (ret->directory))
d282 1
a282 1
root_allow_add (const char *arg)
d289 1
a289 1
    n->data = parse_config (arg);
d332 1
a332 1
get_root_allow_config (const char *arg)
d344 1
a344 1
    return parse_config (arg);
d387 1
d389 1
a396 1
    newroot->directory = NULL;
a398 1
    newroot->isremote = 0;
d407 7
a413 2
/* Dispose of a cvsroot_t and its component parts */
void
d416 1
a638 1
#if defined(CLIENT_SUPPORT) || defined (SERVER_SUPPORT)
d641 1
d785 1
a785 1
	if (!isabsolute (newroot->directory))
d813 1
a813 1
	if (!isabsolute (newroot->directory))
a1026 10
/* Toy versions of various functions when debugging under unix.  Yes,
   these make various bad assumptions, but they're pretty easy to
   debug when something goes wrong.  */

int
isabsolute( const char *dir )
{
    return (dir && (*dir == '/'));
}

d1028 1
a1028 1
main( int argc, char *argv[] )
d1044 2
a1045 1
    printf ("current_parsed_root->method: %s\n", method_names[current_parsed_root->method]);
d1047 2
a1048 1
	    current_parsed_root->username ? current_parsed_root->username : "NULL");
d1050 4
a1053 2
	    current_parsed_root->hostname ? current_parsed_root->hostname : "NULL");
    printf ("current_parsed_root->directory: %s\n", current_parsed_root->directory);
@


1.2
log
@merge src/gnu except binutils, lynx and generated files
@
text
@d1 1
a1 1
/* $MirOS$ */
d4 6
a9 2
 * Copyright (c) 1992, Mark D. Baushke
 * Copyright (c) 2002, Derek R. Price
d20 1
d23 1
a23 1
__RCSID("$MirOS$");
d59 2
a60 4
	cvsadm = xmalloc (strlen (dir) + sizeof (CVSADM) + 10);
	(void) sprintf (cvsadm, "%s/%s", dir, CVSADM);
	tmp = xmalloc (strlen (dir) + sizeof (CVSADM_ROOT) + 10);
	(void) sprintf (tmp, "%s/%s", dir, CVSADM_ROOT);
d86 1
a86 1
    fpin = open_file (tmp, "r");
d163 1
a163 4
	{
	    tmp = xmalloc (strlen (dir) + sizeof (CVSADM_ROOT) + 10);
	    (void) sprintf (tmp, "%s/%s", dir, CVSADM_ROOT);
	}
d167 1
a167 1
        fout = open_file (tmp, "w+");
d195 1
a199 1
#ifdef PROXY_SUPPORT
d241 1
a245 1
#ifdef PROXY_SUPPORT
d475 3
a481 2
    char *cvsroot_copy, *p, *q;		/* temporary pointers for parsing */
#ifdef CLIENT_SUPPORT
d483 1
a483 1
#endif /* CLIENT_SUPPORT */
d497 2
d529 1
a529 1
#ifdef CLIENT_SUPPORT
d534 5
a538 1
#endif /* CLIENT_SUPPORT */
d562 1
a562 1
#ifdef CLIENT_SUPPORT
d620 1
a620 1
#endif /* CLIENT_SUPPORT */
a635 11
#ifndef DEBUG
    /* Why do we avoid these checks when DEBUG is set?  How is this used?  */
# ifndef CLIENT_SUPPORT
    if (newroot->method != local_method)
    {
	error (0, 0, "CVSROOT is set for a remote access method but your");
	error (0, 0, "CVS executable doesn't support it.");
	goto error_exit;
    }
# endif
#endif /* ! DEBUG */
d637 1
a637 1
#ifdef CLIENT_SUPPORT
a645 1
#ifdef CLIENT_SUPPORT
a646 1
#endif /* SERVER_SUPPORT */
d736 1
a736 1
#endif /* CLIENT_SUPPORT */
d752 1
a752 1
#ifdef CLIENT_SUPPORT
d759 3
a761 1
    /* We won't have attempted to parse these without CLIENT_SUPPORT */
d766 1
a766 1
#endif /* CLIENT_SUPPORT */
d770 1
a770 1
#ifdef CLIENT_SUPPORT
d777 1
a777 1
#endif /* CLIENT_SUPPORT */
d790 1
a790 1
#ifdef CLIENT_SUPPORT
d797 1
a797 1
#endif /* CLIENT_SUPPORT */
d799 1
a799 1
#ifdef CLIENT_SUPPORT
a821 5
# ifndef HAVE_KERBEROS
       	error (0, 0, "CVSROOT is set for a kerberos access method but your");
	error (0, 0, "CVS executable doesn't support it.");
	goto error_exit;
# else
a824 1
# endif
a825 5
# ifndef HAVE_GSSAPI
	error (0, 0, "CVSROOT is set for a GSSAPI access method but your");
	error (0, 0, "CVS executable doesn't support it.");
	goto error_exit;
# else
a829 1
# endif
d841 1
a841 1
#endif /* CLIENT_SUPPORT */
d846 1
a846 1
#ifdef CLIENT_SUPPORT
d880 1
a880 1
#endif /*CLIENT_SUPPORT */
d926 2
@


1.1
log
@Initial revision
@
text
@d1 2
d18 2
d644 1
a644 1
    if (readonlyfs && newroot->isremote)
@


1.1.101.1
log
@GNU CVS 1.12.11 with the following directories removed:
- contrib/pam
- emx
- os2
- tools
- vms
- windows-NT
- zlib
@
text
@@


1.1.101.2
log
@GNU CVS 1.12.12 "should" fix security issues
@
text
@d2 2
a3 6
 * Copyright (C) 1986-2005 The Free Software Foundation, Inc.
 *
 * Portions Copyright (C) 1998-2005 Derek Price, Ximbiot <http://ximbiot.com>,
 *                                  and others.
 *
 * Poritons Copyright (c) 1992, Mark D. Baushke
a13 1
#include <assert.h>
d50 4
a53 2
	cvsadm = Xasprintf ("%s/%s", dir, CVSADM);
	tmp = Xasprintf ("%s/%s", dir, CVSADM_ROOT);
d79 1
a79 1
    fpin = xfopen (tmp, "r");
d156 4
a159 1
	    tmp = Xasprintf ("%s/%s", dir, CVSADM_ROOT);
d163 1
a163 1
        fout = xfopen (tmp, "w+");
a190 1
#ifdef PROXY_SUPPORT
d195 1
a236 1
#ifdef PROXY_SUPPORT
d241 1
a470 3
    char *cvsroot_copy, *p;		/* temporary pointers for parsing */
#if defined(CLIENT_SUPPORT) || defined (SERVER_SUPPORT)
    char *q;				/* temporary pointer for parsing */
d475 2
d478 1
a478 1
#endif /* defined(CLIENT_SUPPORT) || defined (SERVER_SUPPORT) */
a491 2
    assert (root_in);

d522 1
a522 1
#if defined (CLIENT_SUPPORT) || defined (SERVER_SUPPORT)
d527 1
a527 5
	if (!method)
	    /* Could just exit now, but this keeps the error message in sync.
	     */
	    method = "";
#endif /* defined (CLIENT_SUPPORT) || defined (SERVER_SUPPORT) */
d551 1
a551 1
#if defined (CLIENT_SUPPORT) || defined (SERVER_SUPPORT)
d609 1
a609 1
#endif /* defined (CLIENT_SUPPORT) || defined (SERVER_SUPPORT) */
d625 11
d637 1
a637 1
#if defined(CLIENT_SUPPORT) || defined (SERVER_SUPPORT)
d646 1
d648 1
d738 1
a738 1
#endif /* defined(CLIENT_SUPPORT) || defined (SERVER_SUPPORT) */
d754 1
a754 1
#if defined(CLIENT_SUPPORT) || defined (SERVER_SUPPORT)
d761 1
a761 3
    /* We won't have attempted to parse these without CLIENT_SUPPORT or
     * SERVER_SUPPORT.
     */
d766 1
a766 1
#endif /* defined (CLIENT_SUPPORT) || defined (SERVER_SUPPORT) */
d770 1
a770 1
#if defined(CLIENT_SUPPORT) || defined (SERVER_SUPPORT)
d777 1
a777 1
#endif /* defined(CLIENT_SUPPORT) || defined (SERVER_SUPPORT) */
d790 1
a790 1
#if defined(CLIENT_SUPPORT) || defined (SERVER_SUPPORT)
d797 1
a797 1
#endif /* defined(CLIENT_SUPPORT) || defined (SERVER_SUPPORT) */
d799 1
a799 1
#if defined(CLIENT_SUPPORT) || defined (SERVER_SUPPORT)
d822 5
d830 1
d832 5
d841 1
d853 1
a853 1
#endif /* defined(CLIENT_SUPPORT) || defined (SERVER_SUPPORT) */
d858 1
a858 1
#if defined(CLIENT_SUPPORT) || defined (SERVER_SUPPORT)
d892 1
a892 1
#endif /* defined(CLIENT_SUPPORT) || defined (SERVER_SUPPORT) */
a937 2
    assert (root && root->hostname && root->directory);

@


1.1.101.3
log
@Import current version of GNU CVS, in the hope to actually fix bugs...
@
text
@d115 5
a119 1
    if (!ret->isremote && !isdir (ret->directory))
d282 1
a282 1
root_allow_add (const char *arg, const char *configPath)
d289 1
a289 1
    n->data = parse_config (arg, configPath);
d332 1
a332 1
get_root_allow_config (const char *arg, const char *configPath)
d344 1
a344 1
    return parse_config (arg, configPath);
a386 1
    newroot->directory = NULL;
a387 1
    newroot->isremote = false;
d395 1
d398 1
d407 2
a408 7
/* Dispose of a cvsroot_t and its component parts.
 *
 * NOTE
 *  It is dangerous for most code to call this function since parse_cvsroot
 *  maintains a cache of parsed roots.
 */
static void
a410 1
    assert (root);
d633 1
a635 1
#if defined (CLIENT_SUPPORT) || defined (SERVER_SUPPORT)
d779 1
a779 1
	if (!ISABSOLUTE (newroot->directory))
d807 1
a807 1
	if (!ISABSOLUTE (newroot->directory))
d1021 10
d1032 1
a1032 1
main (int argc, char *argv[])
d1048 1
a1048 2
    printf ("current_parsed_root->method: %s\n",
	    method_names[current_parsed_root->method]);
d1050 1
a1050 2
	    current_parsed_root->username
	      ? current_parsed_root->username : "NULL");
d1052 2
a1053 4
	    current_parsed_root->hostname
	      ? current_parsed_root->hostname : "NULL");
    printf ("current_parsed_root->directory: %s\n",
	    current_parsed_root->directory);
@


