head	1.1;
branch	1.1.101;
access;
symbols
	MIRBSD_10:1.1.101.2.0.4
	MIRBSD_10_BASE:1.1.101.2
	MIRBSD_9_BASE:1.1.101.2
	MIRBSD_8:1.1.101.2.0.2
	MIRBSD_8_BASE:1.1.101.2
	cvs-1_12_13:1.1.101.2
	cvs-1_12_12:1.1.101.1
	FSF:1.1.101;
locks; strict;
comment	@ * @;


1.1
date	2005.03.06.15.17.50;	author tg;	state Exp;
branches
	1.1.101.1;
next	;

1.1.101.1
date	2005.03.06.15.17.50;	author tg;	state Exp;
branches;
next	1.1.101.2;

1.1.101.2
date	2005.12.05.21.43.46;	author tg;	state Exp;
branches;
next	;
commitid	2cec4394b499b817;


desc
@@


1.1
log
@Initial revision
@
text
@/* dirname.c -- return all but the last element in a path

   Copyright (C) 1990, 1998, 2000, 2001, 2003, 2004 Free Software
   Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software Foundation,
   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#if HAVE_CONFIG_H
# include <config.h>
#endif

#include "dirname.h"

#include <string.h>
#include "xalloc.h"

/* Return the length of `dirname (PATH)', or zero if PATH is
   in the working directory.  Works properly even if
   there are trailing slashes (by effectively ignoring them).  */
size_t
dir_len (char const *path)
{
  size_t prefix_length = FILE_SYSTEM_PREFIX_LEN (path);
  size_t length;

  /* Strip the basename and any redundant slashes before it.  */
  for (length = base_name (path) - path;  prefix_length < length;  length--)
    if (! ISSLASH (path[length - 1]))
      return length;

  /* But don't strip the only slash from "/".  */
  return prefix_length + ISSLASH (path[prefix_length]);
}

/* Return the leading directories part of PATH,
   allocated with xmalloc.
   Works properly even if there are trailing slashes
   (by effectively ignoring them).  */

char *
dir_name (char const *path)
{
  size_t length = dir_len (path);
  bool append_dot = (length == FILE_SYSTEM_PREFIX_LEN (path));
  char *newpath = xmalloc (length + append_dot + 1);
  memcpy (newpath, path, length);
  if (append_dot)
    newpath[length++] = '.';
  newpath[length] = 0;
  return newpath;
}

#ifdef TEST_DIRNAME
/*

Run the test like this (expect no output):
  gcc -DHAVE_CONFIG_H -DTEST_DIRNAME -I.. -O -Wall \
     basename.c dirname.c xmalloc.c error.c
  sed -n '/^BEGIN-DATA$/,/^END-DATA$/p' dirname.c|grep -v DATA|./a.out

If it's been built on a DOS or Windows platforms, run another test like
this (again, expect no output):
  sed -n '/^BEGIN-DOS-DATA$/,/^END-DOS-DATA$/p' dirname.c|grep -v DATA|./a.out

BEGIN-DATA
foo//// .
bar/foo//// bar
foo/ .
/ /
. .
a .
END-DATA

BEGIN-DOS-DATA
c:///// c:/
c:/ c:/
c:/. c:/
c:foo c:.
c:foo/bar c:foo
END-DOS-DATA

*/

# define MAX_BUFF_LEN 1024
# include <stdio.h>

char *program_name;

int
main (int argc, char *argv[])
{
  char buff[MAX_BUFF_LEN + 1];

  program_name = argv[0];

  buff[MAX_BUFF_LEN] = 0;
  while (fgets (buff, MAX_BUFF_LEN, stdin) && buff[0])
    {
      char path[MAX_BUFF_LEN];
      char expected_result[MAX_BUFF_LEN];
      char const *result;
      sscanf (buff, "%s %s", path, expected_result);
      result = dir_name (path);
      if (strcmp (result, expected_result))
	printf ("%s: got %s, expected %s\n", path, result, expected_result);
    }
  return 0;
}
#endif
@


1.1.101.1
log
@GNU CVS 1.12.11 with the following directories removed:
- contrib/pam
- emx
- os2
- tools
- vms
- windows-NT
- zlib
@
text
@@


1.1.101.2
log
@Import current version of GNU CVS, in the hope to actually fix bugs...
@
text
@d1 1
a1 1
/* dirname.c -- return all but the last element in a file name
d3 1
a3 1
   Copyright (C) 1990, 1998, 2000, 2001, 2003, 2004, 2005 Free Software
d18 1
a18 1
   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
d20 1
a20 1
#ifdef HAVE_CONFIG_H
d29 1
a29 1
/* Return the length of `dirname (FILE)', or zero if FILE is
d33 1
a33 1
dir_len (char const *file)
d35 1
a35 1
  size_t prefix_length = FILE_SYSTEM_PREFIX_LEN (file);
d39 2
a40 2
  for (length = base_name (file) - file;  prefix_length < length;  length--)
    if (! ISSLASH (file[length - 1]))
d44 1
a44 1
  return prefix_length + ISSLASH (file[prefix_length]);
d47 1
a47 1
/* Return the leading directories part of FILE,
d53 1
a53 1
dir_name (char const *file)
d55 4
a58 4
  size_t length = dir_len (file);
  bool append_dot = (length == FILE_SYSTEM_PREFIX_LEN (file));
  char *dir = xmalloc (length + append_dot + 1);
  memcpy (dir, file, length);
d60 3
a62 3
    dir[length++] = '.';
  dir[length] = 0;
  return dir;
d111 1
a111 1
      char file[MAX_BUFF_LEN];
d114 2
a115 2
      sscanf (buff, "%s %s", file, expected_result);
      result = dir_name (file);
d117 1
a117 1
	printf ("%s: got %s, expected %s\n", file, result, expected_result);
@

