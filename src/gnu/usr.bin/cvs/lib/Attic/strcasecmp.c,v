head	1.2;
access;
symbols
	cvs-1_12_13:1.1.101.2
	cvs-1_12_12:1.1.101.1
	FSF:1.1.101;
locks; strict;
comment	@ * @;


1.2
date	2005.12.05.23.01.42;	author tg;	state dead;
branches;
next	1.1;
commitid	3ddc4394c6df587b;

1.1
date	2005.03.06.15.17.51;	author tg;	state Exp;
branches
	1.1.101.1;
next	;

1.1.101.1
date	2005.03.06.15.17.51;	author tg;	state Exp;
branches;
next	1.1.101.2;

1.1.101.2
date	2005.12.05.21.43.47;	author tg;	state Exp;
branches;
next	;
commitid	2cec4394b499b817;


desc
@@


1.2
log
@these won't work here... but we don't have multibyte locales, anyway
@
text
@/* strcasecmp.c -- case insensitive string comparator
   Copyright (C) 1998, 1999 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software Foundation,
   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#if HAVE_CONFIG_H
# include <config.h>
#endif

#ifdef LENGTH_LIMIT
# define STRXCASECMP_FUNCTION strncasecmp
# define STRXCASECMP_DECLARE_N , size_t n
# define LENGTH_LIMIT_EXPR(Expr) Expr
#else
# define STRXCASECMP_FUNCTION strcasecmp
# define STRXCASECMP_DECLARE_N /* empty */
# define LENGTH_LIMIT_EXPR(Expr) 0
#endif

#include <stddef.h>
#include <ctype.h>

#define TOLOWER(Ch) (isupper (Ch) ? tolower (Ch) : (Ch))

/* Compare {{no more than N characters of }}strings S1 and S2,
   ignoring case, returning less than, equal to or
   greater than zero if S1 is lexicographically less
   than, equal to or greater than S2.  */

int
STRXCASECMP_FUNCTION (const char *s1, const char *s2 STRXCASECMP_DECLARE_N)
{
  register const unsigned char *p1 = (const unsigned char *) s1;
  register const unsigned char *p2 = (const unsigned char *) s2;
  unsigned char c1, c2;

  if (p1 == p2 || LENGTH_LIMIT_EXPR (n == 0))
    return 0;

  do
    {
      c1 = TOLOWER (*p1);
      c2 = TOLOWER (*p2);

      if (LENGTH_LIMIT_EXPR (--n == 0) || c1 == '\0')
	break;

      ++p1;
      ++p2;
    }
  while (c1 == c2);

  return c1 - c2;
}
@


1.1
log
@Initial revision
@
text
@@


1.1.101.1
log
@GNU CVS 1.12.11 with the following directories removed:
- contrib/pam
- emx
- os2
- tools
- vms
- windows-NT
- zlib
@
text
@@


1.1.101.2
log
@Import current version of GNU CVS, in the hope to actually fix bugs...
@
text
@d1 2
a2 4
/* Case-insensitive string comparison function.
   Copyright (C) 1998, 1999, 2005 Free Software Foundation, Inc.
   Written by Bruno Haible <bruno@@clisp.org>, 2005,
   based on earlier glibc code.
d16 1
a16 1
   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
d18 1
a18 1
#ifdef HAVE_CONFIG_H
d22 9
a30 2
/* Specification.  */
#include "strcase.h"
d32 1
d35 1
a35 3
#if HAVE_MBRTOWC
# include "mbuiter.h"
#endif
d37 4
a40 1
#define TOLOWER(Ch) (isupper (Ch) ? tolower (Ch) : (Ch))
a41 5
/* Compare strings S1 and S2, ignoring case, returning less than, equal to or
   greater than zero if S1 is lexicographically less than, equal to or greater
   than S2.
   Note: This function may, in multibyte locales, return 0 for strings of
   different lengths!  */
d43 1
a43 1
strcasecmp (const char *s1, const char *s2)
d45 5
a49 1
  if (s1 == s2)
d52 1
a52 5
  /* Be careful not to look at the entire extent of s1 or s2 until needed.
     This is useful because when two strings differ, the difference is
     most often already in the very few first characters.  */
#if HAVE_MBRTOWC
  if (MB_CUR_MAX > 1)
d54 2
a55 2
      mbui_iterator_t iter1;
      mbui_iterator_t iter2;
d57 2
a58 2
      mbui_init (iter1, s1);
      mbui_init (iter2, s2);
d60 2
a61 17
      while (mbui_avail (iter1) && mbui_avail (iter2))
	{
	  int cmp = mb_casecmp (mbui_cur (iter1), mbui_cur (iter2));

	  if (cmp != 0)
	    return cmp;

	  mbui_advance (iter1);
	  mbui_advance (iter2);
	}
      if (mbui_avail (iter1))
	/* s2 terminated before s1.  */
	return 1;
      if (mbui_avail (iter2))
	/* s1 terminated before s2.  */
	return -1;
      return 0;
d63 1
a63 19
  else
#endif
    {
      const unsigned char *p1 = (const unsigned char *) s1;
      const unsigned char *p2 = (const unsigned char *) s2;
      unsigned char c1, c2;

      do
	{
	  c1 = TOLOWER (*p1);
	  c2 = TOLOWER (*p2);

	  if (c1 == '\0')
	    break;

	  ++p1;
	  ++p2;
	}
      while (c1 == c2);
d65 1
a65 2
      return c1 - c2;
    }
@

