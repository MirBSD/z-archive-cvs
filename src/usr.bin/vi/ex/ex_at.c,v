head	1.1;
branch	1.1.1;
access;
symbols
	cvs-201012271745:1.1.1.2
	MIRBSD_10:1.1.1.1.0.4
	MIRBSD_10_BASE:1.1.1.1
	MIRBSD_9_BASE:1.1.1.1
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200507211800:1.1.1.1
	cvs-200504291700:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2005.02.05.17.30.13;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.30.13;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2010.12.27.17.52.27;	author tg;	state Exp;
branches;
next	;
commitid	1004D18D2680A7ACEE9;


desc
@@


1.1
log
@Initial revision
@
text
@/*	$OpenBSD: ex_at.c,v 1.6 2002/02/16 21:27:57 millert Exp $	*/

/*-
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
 *	Keith Bostic.  All rights reserved.
 *
 * See the LICENSE file for redistribution information.
 */

#include "config.h"

#ifndef lint
static const char sccsid[] = "@@(#)ex_at.c	10.12 (Berkeley) 9/15/96";
#endif /* not lint */

#include <sys/types.h>
#include <sys/queue.h>

#include <bitstring.h>
#include <ctype.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "../common/common.h"

/*
 * ex_at -- :@@[@@ | buffer]
 *	    :*[* | buffer]
 *
 *	Execute the contents of the buffer.
 *
 * PUBLIC: int ex_at(SCR *, EXCMD *);
 */
int
ex_at(sp, cmdp)
	SCR *sp;
	EXCMD *cmdp;
{
	CB *cbp;
	CHAR_T name;
	EXCMD *ecp;
	RANGE *rp;
	TEXT *tp;
	size_t len;
	char *p;

	/*
	 * !!!
	 * Historically, [@@*]<carriage-return> and [@@*][@@*] executed the most
	 * recently executed buffer in ex mode.
	 */
	name = FL_ISSET(cmdp->iflags, E_C_BUFFER) ? cmdp->buffer : '@@';
	if (name == '@@' || name == '*') {
		if (!F_ISSET(sp, SC_AT_SET)) {
			ex_emsg(sp, NULL, EXM_NOPREVBUF);
			return (1);
		}
		name = sp->at_lbuf;
	}
	sp->at_lbuf = name;
	F_SET(sp, SC_AT_SET);

	CBNAME(sp, cbp, name);
	if (cbp == NULL) {
		ex_emsg(sp, KEY_NAME(sp, name), EXM_EMPTYBUF);
		return (1);
	}

	/*
	 * !!!
	 * Historically the @@ command took a range of lines, and the @@ buffer
	 * was executed once per line.  The historic vi could be trashed by
	 * this because it didn't notice if the underlying file changed, or,
	 * for that matter, if there were no more lines on which to operate.
	 * For example, take a 10 line file, load "%delete" into a buffer,
	 * and enter :8,10@@<buffer>.
	 *
	 * The solution is a bit tricky.  If the user specifies a range, take
	 * the same approach as for global commands, and discard the command
	 * if exit or switch to a new file/screen.  If the user doesn't specify
	 * the  range, continue to execute after a file/screen switch, which
	 * means @@ buffers are still useful in a multi-screen environment.
	 */
	CALLOC_RET(sp, ecp, EXCMD *, 1, sizeof(EXCMD));
	CIRCLEQ_INIT(&ecp->rq);
	CALLOC_RET(sp, rp, RANGE *, 1, sizeof(RANGE));
	rp->start = cmdp->addr1.lno;
	if (F_ISSET(cmdp, E_ADDR_DEF)) {
		rp->stop = rp->start;
		FL_SET(ecp->agv_flags, AGV_AT_NORANGE);
	} else {
		rp->stop = cmdp->addr2.lno;
		FL_SET(ecp->agv_flags, AGV_AT);
	}
	CIRCLEQ_INSERT_HEAD(&ecp->rq, rp, q);

	/*
	 * Buffers executed in ex mode or from the colon command line in vi
	 * were ex commands.  We can't push it on the terminal queue, since
	 * it has to be executed immediately, and we may be in the middle of
	 * an ex command already.  Push the command on the ex command stack.
	 * Build two copies of the command.  We need two copies because the
	 * ex parser may step on the command string when it's parsing it.
	 */
	for (len = 0, tp = cbp->textq.cqh_last;
	    tp != (void *)&cbp->textq; tp = tp->q.cqe_prev)
		len += tp->len + 1;

	MALLOC_RET(sp, ecp->cp, char *, len * 2);
	ecp->o_cp = ecp->cp;
	ecp->o_clen = len;
	ecp->cp[len] = '\0';

	/* Copy the buffer into the command space. */
	for (p = ecp->cp + len, tp = cbp->textq.cqh_last;
	    tp != (void *)&cbp->textq; tp = tp->q.cqe_prev) {
		memcpy(p, tp->lb, tp->len);
		p += tp->len;
		*p++ = '\n';
	}

	LIST_INSERT_HEAD(&sp->gp->ecq, ecp, q);
	return (0);
}
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@newer nvi from Ogre, to fix benzâ€™ segfaults
@
text
@d1 1
a1 1
/*	$OpenBSD: ex_at.c,v 1.8 2009/10/27 23:59:47 deraadt Exp $	*/
d14 4
d109 2
a110 2
	for (len = 0, tp = CIRCLEQ_LAST(&cbp->textq);
	    tp != CIRCLEQ_END(&cbp->textq); tp = CIRCLEQ_PREV(tp, q))
d119 2
a120 2
	for (p = ecp->cp + len, tp = CIRCLEQ_LAST(&cbp->textq);
	    tp != CIRCLEQ_END(&cbp->textq); tp = CIRCLEQ_PREV(tp, q)) {
@

