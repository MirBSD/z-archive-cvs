head	1.9;
access;
symbols
	MIRBSD_10:1.8.0.2
	MIRBSD_10_BASE:1.8
	MIRBSD_9_BASE:1.6
	MIRBSD_8:1.6.0.2
	MIRBSD_8_BASE:1.6
	cvs-200507211800:1.1.1.3
	cvs-200504291700:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2013.10.31.20.07.08;	author tg;	state Exp;
branches;
next	1.8;
commitid	1005272B7081B0E5655;

1.8
date	2007.08.08.19.09.48;	author tg;	state Exp;
branches;
next	1.7;
commitid	10046BA150E4442DCEC;

1.7
date	2006.09.21.03.46.54;	author tg;	state Exp;
branches;
next	1.6;
commitid	10045120B4140888F28;

1.6
date	2005.11.23.20.38.23;	author tg;	state Exp;
branches;
next	1.5;
commitid	501c4384d345a96c;

1.5
date	2005.11.23.18.04.11;	author tg;	state Exp;
branches;
next	1.4;
commitid	af74384af2ab463;

1.4
date	2005.05.19.22.57.39;	author tg;	state Exp;
branches;
next	1.3;
commitid	3271428d19eadbe8;

1.3
date	2005.04.29.18.35.10;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.13.18.33.18;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.29.45;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.29.45;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.29.17.06.06;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.07.21.21.00.01;	author tg;	state Exp;
branches;
next	;
commitid	560042e0092f571e;


desc
@@


1.9
log
@adapt most __attribute__((…)) occurrences to new KNF style(9)
@
text
@/*	$OpenBSD: socks.c,v 1.15 2005/05/24 20:13:28 avsm Exp $	*/

/*
 * Copyright (c) 1999 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 2004, 2005 Damien Miller.  All rights reserved.
 * Copyright © 2013
 *	Thorsten “mirabilos” Glaser <tg@@mirbsd.org>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <err.h>
#include <errno.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "atomicio.h"

__RCSID("$MirOS: src/usr.bin/nc/socks.c,v 1.8 2007/08/08 19:09:48 tg Exp $");

#define SOCKS_PORT	"1080"
#define HTTP_PROXY_PORT	"3128"
#define HTTP_MAXHDRS	64
#define SOCKS_V5	5
#define SOCKS_V4	4
#define SOCKS_NOAUTH	0
#define SOCKS_NOMETHOD	0xff
#define SOCKS_CONNECT	1
#define SOCKS_IPV4	1
#define SOCKS_DOMAIN	3
#define SOCKS_IPV6	4

int	remote_connect(const char *, const char *, struct addrinfo);
int	socks_connect(const char *host, const char *port, struct addrinfo hints,
	    const char *proxyhost, const char *proxyport, struct addrinfo proxyhints,
	    int socksv);

static int
decode_addrport(const char *h, const char *p, struct sockaddr *addr,
    socklen_t addrlen, int v4only, int numeric)
{
	int r;
	struct addrinfo hints, *res;

	bzero(&hints, sizeof(hints));
	hints.ai_family = v4only ? PF_INET : PF_UNSPEC;
	hints.ai_flags = numeric ? AI_NUMERICHOST : 0;
	hints.ai_socktype = SOCK_STREAM;
	r = getaddrinfo(h, p, &hints, &res);
	/* Don't fatal when attempting to convert a numeric address */
	if (r != 0) {
		if (!numeric) {
			errx(1, "getaddrinfo(\"%.64s\", \"%.64s\"): %s", h, p,
			    gai_strerror(r));
		}
		return (-1);
	}
	if (addrlen < res->ai_addrlen) {
		freeaddrinfo(res);
		errx(1, "internal error: addrlen < res->ai_addrlen");
	}
	memcpy(addr, res->ai_addr, res->ai_addrlen);
	freeaddrinfo(res);
	return (0);
}

static int
proxy_read_line(int fd, char *buf, size_t bufsz)
{
	size_t off;

	for(off = 0;;) {
		if (off >= bufsz)
			errx(1, "proxy read too long");
		if (atomicio(read, fd, buf + off, 1) != 1)
			err(1, "proxy read");
		/* Skip CR */
		if (buf[off] == '\r')
			continue;
		if (buf[off] == '\n') {
			buf[off] = '\0';
			break;
		}
		off++;
	}
	return (off);
}

int
socks_connect(const char *host, const char *port,
    struct addrinfo hints __attribute__((__unused__)),
    const char *proxyhost, const char *proxyport, struct addrinfo proxyhints,
    int socksv)
{
	int proxyfd, r;
	size_t hlen, wlen;
	unsigned char buf[1024];
	size_t cnt;
	struct sockaddr_storage addr;
	struct sockaddr_in *in4 = (struct sockaddr_in *)&addr;
	struct sockaddr_in6 *in6 = (struct sockaddr_in6 *)&addr;
	in_port_t serverport;

	if (proxyport == NULL)
		proxyport = (socksv == -1) ? HTTP_PROXY_PORT : SOCKS_PORT;

	proxyfd = remote_connect(proxyhost, proxyport, proxyhints);

	if (proxyfd < 0)
		return (-1);

	/* Abuse API to lookup port */
	if (decode_addrport("0.0.0.0", port, (struct sockaddr *)&addr,
	    sizeof(addr), 1, 1) == -1)
		errx(1, "unknown port \"%.64s\"", port);
	serverport = in4->sin_port;

	if (socksv == 5) {
		if (decode_addrport(host, port, (struct sockaddr *)&addr,
		    sizeof(addr), 0, 1) == -1)
			addr.ss_family = 0; /* used in switch below */

		/* Version 5, one method: no authentication */
		buf[0] = SOCKS_V5;
		buf[1] = 1;
		buf[2] = SOCKS_NOAUTH;
		cnt = atomicio(vwrite, proxyfd, buf, 3);
		if (cnt != 3)
			err(1, "write failed (%zu/3)", cnt);

		cnt = atomicio(read, proxyfd, buf, 2);
		if (cnt != 2)
			err(1, "read failed (%zu/3)", cnt);

		if (buf[1] == SOCKS_NOMETHOD)
			errx(1, "authentication method negotiation failed");

		switch (addr.ss_family) {
		case 0:
			/* Version 5, connect: domain name */

			/* Max domain name length is 255 bytes */
			hlen = strlen(host);
			if (hlen > 255)
				errx(1, "host name too long for SOCKS5");
			buf[0] = SOCKS_V5;
			buf[1] = SOCKS_CONNECT;
			buf[2] = 0;
			buf[3] = SOCKS_DOMAIN;
			buf[4] = hlen;
			memcpy(buf + 5, host, hlen);			
			memcpy(buf + 5 + hlen, &serverport, sizeof serverport);
			wlen = 7 + hlen;
			break;
		case AF_INET:
			/* Version 5, connect: IPv4 address */
			buf[0] = SOCKS_V5;
			buf[1] = SOCKS_CONNECT;
			buf[2] = 0;
			buf[3] = SOCKS_IPV4;
			memcpy(buf + 4, &in4->sin_addr, sizeof in4->sin_addr);
			memcpy(buf + 8, &in4->sin_port, sizeof in4->sin_port);
			wlen = 10;
			break;
		case AF_INET6:
			/* Version 5, connect: IPv6 address */
			buf[0] = SOCKS_V5;
			buf[1] = SOCKS_CONNECT;
			buf[2] = 0;
			buf[3] = SOCKS_IPV6;
			memcpy(buf + 4, &in6->sin6_addr, sizeof in6->sin6_addr);
			memcpy(buf + 20, &in6->sin6_port,
			    sizeof in6->sin6_port);
			wlen = 22;
			break;
		default:
			errx(1, "internal error: silly AF");
		}

		cnt = atomicio(vwrite, proxyfd, buf, wlen);
		if (cnt != wlen)
			err(1, "write failed (%zu/%zu)", cnt, wlen);

		cnt = atomicio(read, proxyfd, buf, 10);
		if (cnt != 10)
			err(1, "read failed (%zu/10)", cnt);
		if (buf[1] != 0)
			errx(1, "connection failed, SOCKS error %u", buf[1]);
	} else if (socksv == 4) {
		/* This will exit on lookup failure */
		decode_addrport(host, port, (struct sockaddr *)&addr,
		    sizeof(addr), 1, 0);

		/* Version 4 */
		buf[0] = SOCKS_V4;
		buf[1] = SOCKS_CONNECT;	/* connect */
		memcpy(buf + 2, &in4->sin_port, sizeof in4->sin_port);
		memcpy(buf + 4, &in4->sin_addr, sizeof in4->sin_addr);
		buf[8] = 0;	/* empty username */
		wlen = 9;

		cnt = atomicio(vwrite, proxyfd, buf, wlen);
		if (cnt != wlen)
			err(1, "write failed (%zu/%zu)", cnt, wlen);

		cnt = atomicio(read, proxyfd, buf, 8);
		if (cnt != 8)
			err(1, "read failed (%zu/8)", cnt);
		if (buf[1] != 90)
			errx(1, "connection failed, SOCKS error %u", buf[1]);
	} else if (socksv == -1) {
		/* HTTP proxy CONNECT */

		/* Disallow bad chars in hostname */
		if (strcspn(host, "\r\n\t []:") != strlen(host))
			errx(1, "Invalid hostname");

		/* Try to be sane about numeric IPv6 addresses */
		if (strchr(host, ':') != NULL) {
			r = snprintf((char *)buf, sizeof(buf),
			    "CONNECT [%s]:%u HTTP/1.0\r\n\r\n",
			    host, ntohs(serverport));
		} else {
			r = snprintf((char *)buf, sizeof(buf),
			    "CONNECT %s:%u HTTP/1.0\r\n\r\n",
			    host, ntohs(serverport));
		}
		if (r == -1 || (size_t)r >= sizeof(buf))
			errx(1, "hostname too long");
		r = strlen((char *)buf);

		cnt = atomicio(vwrite, proxyfd, buf, r);
		if ((int)cnt != r)
			err(1, "write failed (%zu/%d)", cnt, r);

		/* Read reply */
		for (r = 0; r < HTTP_MAXHDRS; r++) {
			proxy_read_line(proxyfd, (char *)buf, sizeof(buf));
			if (r == 0 && strncmp((char *)buf,
			    "HTTP/1.0 200 ", 12) != 0)
				errx(1, "Proxy error: \"%s\"", buf);
			/* Discard headers until we hit an empty line */
			if (*buf == '\0')
				break;
		}
	} else
		errx(1, "Unknown proxy protocol %d", socksv);

	return (proxyfd);
}
@


1.8
log
@more format strings: usr.bin and usr.sbin/[a..timed]
@
text
@a0 1
/**	$MirOS: src/usr.bin/nc/socks.c,v 1.7 2006/09/21 03:46:54 tg Exp $ */
d6 2
d44 1
a44 1
__RCSID("$MirOS: src/usr.bin/nc/socks.c,v 1.7 2006/09/21 03:46:54 tg Exp $");
d116 1
a116 1
    struct addrinfo hints __attribute__ ((__unused__)),
@


1.7
log
@another more... ugly style, make(1) especially
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.bin/nc/socks.c,v 1.6 2005/11/23 20:38:23 tg Exp $ */
d43 1
a43 1
__RCSID("$MirOS: src/usr.bin/nc/socks.c,v 1.6 2005/11/23 20:38:23 tg Exp $");
d153 1
a153 1
			err(1, "write failed (%ld/3)", cnt);
d157 1
a157 1
			err(1, "read failed (%ld/3)", cnt);
d206 1
a206 1
			err(1, "write failed (%ld/%ld)", cnt, wlen);
d210 1
a210 1
			err(1, "read failed (%ld/10)", cnt);
d212 1
a212 1
			errx(1, "connection failed, SOCKS error %d", buf[1]);
d228 1
a228 1
			err(1, "write failed (%ld/%ld)", cnt, wlen);
d232 1
a232 1
			err(1, "read failed (%ld/8)", cnt);
d234 1
a234 1
			errx(1, "connection failed, SOCKS error %d", buf[1]);
d245 1
a245 1
			    "CONNECT [%s]:%d HTTP/1.0\r\n\r\n",
d249 1
a249 1
			    "CONNECT %s:%d HTTP/1.0\r\n\r\n",
d258 1
a258 1
			err(1, "write failed (%ld/%d)", cnt, r);
@


1.6
log
@make this stuff build again (watch for the many XXXes),
sync CLEANFILES, etc.
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.bin/nc/socks.c,v 1.5 2005/11/23 18:04:11 tg Exp $ */
d43 1
a43 1
__RCSID("$MirOS: src/usr.bin/nc/socks.c,v 1.5 2005/11/23 18:04:11 tg Exp $");
d153 1
a153 1
			err(1, "write failed (%d/3)", cnt);
d157 1
a157 1
			err(1, "read failed (%d/3)", cnt);
d206 1
a206 1
			err(1, "write failed (%d/%d)", cnt, wlen);
d210 1
a210 1
			err(1, "read failed (%d/10)", cnt);
d228 1
a228 1
			err(1, "write failed (%d/%d)", cnt, wlen);
d232 1
a232 1
			err(1, "read failed (%d/8)", cnt);
d258 1
a258 1
			err(1, "write failed (%d/%d)", cnt, r);
@


1.5
log
@fastmerge remainder of src/usr.bin
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.bin/nc/socks.c,v 1.4 2005/05/19 22:57:39 tg Exp $ */
d43 1
a43 1
__RCSID("$MirOS: src/usr.bin/nc/socks.c,v 1.4 2005/05/19 22:57:39 tg Exp $");
d254 1
a254 1
		r = strlen(buf);
d257 1
a257 1
		if (cnt != r)
d262 3
a264 2
			proxy_read_line(proxyfd, buf, sizeof(buf));
			if (r == 0 && strncmp(buf, "HTTP/1.0 200 ", 12) != 0)
@


1.4
log
@fix DNS while proxying over http
From: Ray <ray@@cyth.net>
@
text
@d1 2
a2 2
/**	$MirOS: src/usr.bin/nc/socks.c,v 1.3 2005/04/29 18:35:10 tg Exp $ */
/*	$OpenBSD: socks.c,v 1.10 2005/02/08 15:26:23 otto Exp $	*/
d6 1
d41 1
d43 1
a43 1
__RCSID("$MirOS: src/usr.bin/nc/socks.c,v 1.3 2005/04/29 18:35:10 tg Exp $");
d54 2
a55 1

d62 3
a64 2
static in_addr_t
decode_addr(const char *s)
d66 2
a67 2
	struct hostent *hp = gethostbyname (s);
	struct in_addr retval;
d69 16
a84 19
	if (hp)
		return *(in_addr_t *)hp->h_addr_list[0];
	if (inet_aton (s, &retval))
		return retval.s_addr;
	errx (1, "cannot decode address \"%s\"", s);
}

static in_port_t
decode_port(const char *s)
{
	struct servent *sp;
	in_port_t port;
	char *p;

	port = strtol (s, &p, 10);
	if (s == p) {
		sp = getservbyname (s, "tcp");
		if (sp)
			return sp->s_port;
d86 3
a88 3
	if (*s != '\0' && *p == '\0')
		return htons (port);
	errx (1, "cannot decode port \"%s\"", s);
d92 1
a92 1
proxy_read_line(int fd, char *buf, int bufsz)
d94 1
a94 1
	int r, off;
d99 1
a99 3
		if ((r = read(fd, buf + off, 1)) <= 0) {
			if (r == -1 && errno == EINTR)
				continue;
a100 1
		}
d120 1
d122 4
a125 2
	ssize_t cnt;
	in_addr_t serveraddr;
d134 1
a134 1
		return -1;
d136 5
a140 4
	/* HTTP proxies can use hostnames */
	if (socksv != -1)
		serveraddr = decode_addr(host);
	serverport = decode_port (port);
d143 4
d151 1
a151 3
		cnt = write (proxyfd, buf, 3);
		if (cnt == -1)
			err (1, "write failed");
d153 5
a157 1
			errx (1, "short write, %d (expected 3)", cnt);
a158 1
		read (proxyfd, buf, 2);
d160 1
a160 1
			errx (1, "authentication method negotiation failed");
d162 45
a206 14
		/* Version 5, connect: IPv4 address */
		buf[0] = SOCKS_V5;
		buf[1] = SOCKS_CONNECT;
		buf[2] = 0;
		buf[3] = SOCKS_IPV4;
		memcpy (buf + 4, &serveraddr, sizeof serveraddr);
		memcpy (buf + 8, &serverport, sizeof serverport);

		/* XXX Handle short writes better */
		cnt = write (proxyfd, buf, 10);
		if (cnt == -1)
			err (1, "write failed");
		if (cnt != 10)
			errx (1, "short write, %d (expected 10)", cnt);
d208 1
a208 4
		/* XXX Handle short reads better */
		cnt = read (proxyfd, buf, sizeof buf);
		if (cnt == -1)
			err (1, "read failed");
d210 1
a210 1
			errx (1, "unexpected reply size %d (expected 10)", cnt);
d212 1
a212 1
			errx (1, "connection failed, SOCKS error %d", buf[1]);
d214 4
d221 2
a222 2
		memcpy (buf + 2, &serverport, sizeof serverport);
		memcpy (buf + 4, &serveraddr, sizeof serveraddr);
d224 5
d230 1
a230 10
		cnt = write (proxyfd, buf, 9);
		if (cnt == -1)
			err (1, "write failed");
		if (cnt != 9)
			errx (1, "short write, %d (expected 9)", cnt);

		/* XXX Handle short reads better */
		cnt = read (proxyfd, buf, 8);
		if (cnt == -1)
			err (1, "read failed");
d232 1
a232 1
			errx (1, "unexpected reply size %d (expected 8)", cnt);
d234 1
a234 1
			errx (1, "connection failed, SOCKS error %d", buf[1]);
d240 1
a240 1
			errx (1, "Invalid hostname");
d253 2
a254 2
			errx (1, "hostname too long");
		r = strlen((char *)buf);
d256 1
a256 4
		/* XXX atomicio */
		cnt = write (proxyfd, buf, r);
		if (cnt == -1)
			err (1, "write failed");
d258 1
a258 1
			errx (1, "short write, %d (expected %d)", cnt, r);
d262 3
a264 4
			proxy_read_line(proxyfd, (char *)buf, sizeof(buf));
			if (r == 0 &&
			    strncmp((char *)buf, "HTTP/1.0 200 ", 12) != 0)
				errx (1, "Proxy error: \"%s\"", buf);
d270 1
a270 1
		errx (1, "Unknown proxy protocol %d", socksv);
d272 1
a272 1
	return proxyfd;
@


1.3
log
@(tentative) merge, more to come
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.bin/nc/socks.c,v 1.2 2005/03/13 18:33:18 tg Exp $ */
d41 1
a41 1
__RCSID("$MirOS: src/usr.bin/nc/socks.c,v 1.2 2005/03/13 18:33:18 tg Exp $");
d135 3
a137 1
	serveraddr = decode_addr (host);
@


1.2
log
@merge src/usr.bin
@
text
@d1 2
a2 2
/**	$MirOS$ */
/*	$OpenBSD: socks.c,v 1.9 2004/10/17 03:13:55 djm Exp $	*/
d41 1
a41 1
__RCSID("$MirOS$");
d54 3
a56 3
int	remote_connect(char *, char *, struct addrinfo);
int	socks_connect(char *host, char *port, struct addrinfo hints,
	    char *proxyhost, char *proxyport, struct addrinfo proxyhints,
d116 3
a118 3
socks_connect(char *host, char *port,
    struct addrinfo hints __attribute__((unused)),
    char *proxyhost, char *proxyport, struct addrinfo proxyhints,
d215 1
a215 1
		if (r == -1 || r >= (ssize_t)sizeof(buf))
@


1.1
log
@Initial revision
@
text
@d1 1
d41 2
d116 2
a117 1
socks_connect(char *host, char *port, struct addrinfo hints,
d207 1
a207 1
			r = snprintf(buf, sizeof(buf),
d211 1
a211 1
			r = snprintf(buf, sizeof(buf),
d215 1
a215 1
		if (r == -1 || r >= sizeof(buf))
d217 1
a217 1
		r = strlen(buf);
d228 3
a230 2
			proxy_read_line(proxyfd, buf, sizeof(buf));
			if (r == 0 && strncmp(buf, "HTTP/1.0 200 ", 12) != 0)
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@improve my Frankenstein OS (*wink* you know who you are) further
sans wchar_t of course

this is the essence of reading >1200 commit messages which suck
due to not having the new format of ours...
@
text
@d1 1
a1 1
/*	$OpenBSD: socks.c,v 1.10 2005/02/08 15:26:23 otto Exp $	*/
d51 3
a53 3
int	remote_connect(const char *, const char *, struct addrinfo);
int	socks_connect(const char *host, const char *port, struct addrinfo hints,
	    const char *proxyhost, const char *proxyport, struct addrinfo proxyhints,
d113 2
a114 3
socks_connect(const char *host, const char *port,
    struct addrinfo hints __attribute__ ((__unused__)),
    const char *proxyhost, const char *proxyport, struct addrinfo proxyhints,
d211 1
a211 1
		if (r == -1 || (size_t)r >= sizeof(buf))
@


1.1.1.3
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d1 1
a1 1
/*	$OpenBSD: socks.c,v 1.15 2005/05/24 20:13:28 avsm Exp $	*/
a4 1
 * Copyright (c) 2004, 2005 Damien Miller.  All rights reserved.
a38 1
#include "atomicio.h"
d49 1
a49 2
#define SOCKS_DOMAIN	3
#define SOCKS_IPV6	4
d56 2
a57 3
static int
decode_addrport(const char *h, const char *p, struct sockaddr *addr,
    socklen_t addrlen, int v4only, int numeric)
d59 2
a60 2
	int r;
	struct addrinfo hints, *res;
d62 19
a80 16
	bzero(&hints, sizeof(hints));
	hints.ai_family = v4only ? PF_INET : PF_UNSPEC;
	hints.ai_flags = numeric ? AI_NUMERICHOST : 0;
	hints.ai_socktype = SOCK_STREAM;
	r = getaddrinfo(h, p, &hints, &res);
	/* Don't fatal when attempting to convert a numeric address */
	if (r != 0) {
		if (!numeric) {
			errx(1, "getaddrinfo(\"%.64s\", \"%.64s\"): %s", h, p,
			    gai_strerror(r));
		}
		return (-1);
	}
	if (addrlen < res->ai_addrlen) {
		freeaddrinfo(res);
		errx(1, "internal error: addrlen < res->ai_addrlen");
d82 3
a84 3
	memcpy(addr, res->ai_addr, res->ai_addrlen);
	freeaddrinfo(res);
	return (0);
d88 1
a88 1
proxy_read_line(int fd, char *buf, size_t bufsz)
d90 1
a90 1
	size_t off;
d95 3
a97 1
		if (atomicio(read, fd, buf + off, 1) != 1)
d99 1
a118 1
	size_t hlen, wlen;
d120 2
a121 4
	size_t cnt;
	struct sockaddr_storage addr;
	struct sockaddr_in *in4 = (struct sockaddr_in *)&addr;
	struct sockaddr_in6 *in6 = (struct sockaddr_in6 *)&addr;
d130 1
a130 1
		return (-1);
d132 2
a133 5
	/* Abuse API to lookup port */
	if (decode_addrport("0.0.0.0", port, (struct sockaddr *)&addr,
	    sizeof(addr), 1, 1) == -1)
		errx(1, "unknown port \"%.64s\"", port);
	serverport = in4->sin_port;
a135 4
		if (decode_addrport(host, port, (struct sockaddr *)&addr,
		    sizeof(addr), 0, 1) == -1)
			addr.ss_family = 0; /* used in switch below */

d140 3
a142 1
		cnt = atomicio(vwrite, proxyfd, buf, 3);
d144 1
a144 5
			err(1, "write failed (%d/3)", cnt);

		cnt = atomicio(read, proxyfd, buf, 2);
		if (cnt != 2)
			err(1, "read failed (%d/3)", cnt);
d146 1
d148 1
a148 1
			errx(1, "authentication method negotiation failed");
d150 14
a163 45
		switch (addr.ss_family) {
		case 0:
			/* Version 5, connect: domain name */

			/* Max domain name length is 255 bytes */
			hlen = strlen(host);
			if (hlen > 255)
				errx(1, "host name too long for SOCKS5");
			buf[0] = SOCKS_V5;
			buf[1] = SOCKS_CONNECT;
			buf[2] = 0;
			buf[3] = SOCKS_DOMAIN;
			buf[4] = hlen;
			memcpy(buf + 5, host, hlen);			
			memcpy(buf + 5 + hlen, &serverport, sizeof serverport);
			wlen = 7 + hlen;
			break;
		case AF_INET:
			/* Version 5, connect: IPv4 address */
			buf[0] = SOCKS_V5;
			buf[1] = SOCKS_CONNECT;
			buf[2] = 0;
			buf[3] = SOCKS_IPV4;
			memcpy(buf + 4, &in4->sin_addr, sizeof in4->sin_addr);
			memcpy(buf + 8, &in4->sin_port, sizeof in4->sin_port);
			wlen = 10;
			break;
		case AF_INET6:
			/* Version 5, connect: IPv6 address */
			buf[0] = SOCKS_V5;
			buf[1] = SOCKS_CONNECT;
			buf[2] = 0;
			buf[3] = SOCKS_IPV6;
			memcpy(buf + 4, &in6->sin6_addr, sizeof in6->sin6_addr);
			memcpy(buf + 20, &in6->sin6_port,
			    sizeof in6->sin6_port);
			wlen = 22;
			break;
		default:
			errx(1, "internal error: silly AF");
		}

		cnt = atomicio(vwrite, proxyfd, buf, wlen);
		if (cnt != wlen)
			err(1, "write failed (%d/%d)", cnt, wlen);
d165 4
a168 1
		cnt = atomicio(read, proxyfd, buf, 10);
d170 1
a170 1
			err(1, "read failed (%d/10)", cnt);
d172 1
a172 1
			errx(1, "connection failed, SOCKS error %d", buf[1]);
a173 4
		/* This will exit on lookup failure */
		decode_addrport(host, port, (struct sockaddr *)&addr,
		    sizeof(addr), 1, 0);

d177 2
a178 2
		memcpy(buf + 2, &in4->sin_port, sizeof in4->sin_port);
		memcpy(buf + 4, &in4->sin_addr, sizeof in4->sin_addr);
a179 5
		wlen = 9;

		cnt = atomicio(vwrite, proxyfd, buf, wlen);
		if (cnt != wlen)
			err(1, "write failed (%d/%d)", cnt, wlen);
d181 10
a190 1
		cnt = atomicio(read, proxyfd, buf, 8);
d192 1
a192 1
			err(1, "read failed (%d/8)", cnt);
d194 1
a194 1
			errx(1, "connection failed, SOCKS error %d", buf[1]);
d200 1
a200 1
			errx(1, "Invalid hostname");
d213 1
a213 1
			errx(1, "hostname too long");
d216 4
a219 1
		cnt = atomicio(vwrite, proxyfd, buf, r);
d221 1
a221 1
			err(1, "write failed (%d/%d)", cnt, r);
d227 1
a227 1
				errx(1, "Proxy error: \"%s\"", buf);
d233 1
a233 1
		errx(1, "Unknown proxy protocol %d", socksv);
d235 1
a235 1
	return (proxyfd);
@


