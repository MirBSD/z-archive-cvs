head	1.18;
access;
symbols
	MIRBSD_10:1.7.0.2
	MIRBSD_10_BASE:1.7
	cvs-200707151930:1.1.1.5
	OPENBSD_4_0:1.1.1.4
	MIRBSD_9_BASE:1.5
	MIRBSD_8:1.4.0.2
	MIRBSD_8_BASE:1.4
	cvs-200507211800:1.1.1.3
	cvs-200504291700:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2018.12.22.20.11.32;	author tg;	state Exp;
branches;
next	1.17;
commitid	1005C1E9A713489246A;

1.17
date	2015.07.19.12.25.48;	author tg;	state Exp;
branches;
next	1.16;
commitid	10055AB97502B6E820F;

1.16
date	2015.07.18.23.16.47;	author tg;	state Exp;
branches;
next	1.15;
commitid	10055AADE591232B40E;

1.15
date	2014.11.13.22.58.28;	author tg;	state Exp;
branches;
next	1.14;
commitid	1005465371B0D84FA4E;

1.14
date	2014.11.13.21.26.03;	author tg;	state Exp;
branches;
next	1.12;
commitid	100546521FD6FBA6945;

1.12
date	2014.11.13.21.23.58;	author tg;	state Exp;
branches;
next	1.11;
commitid	1005465217F6E3D2B68;

1.11
date	2014.11.13.21.03.46;	author tg;	state Exp;
branches;
next	1.10;
commitid	10054651CC6734CA3BE;

1.10
date	2014.11.13.20.50.02;	author tg;	state Exp;
branches;
next	1.9;
commitid	1005465199216ECC21D;

1.9
date	2013.10.31.20.07.03;	author tg;	state Exp;
branches;
next	1.8;
commitid	1005272B7081B0E5655;

1.8
date	2010.08.12.11.30.46;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004C63DB632DB66F25;

1.7
date	2007.07.15.20.01.07;	author tg;	state Exp;
branches;
next	1.6;
commitid	100469A7CFC300FC2D9;

1.6
date	2006.10.03.19.22.17;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004522B87E42B315D1;

1.5
date	2006.06.14.21.48.35;	author tg;	state Exp;
branches;
next	1.4;
commitid	100449084353DFE7216;

1.4
date	2005.11.23.17.36.14;	author tg;	state Exp;
branches;
next	1.3;
commitid	453a4384a89dc800;

1.3
date	2005.04.29.18.35.08;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.15.18.44.52;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.29.34;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.29.34;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.29.17.06.04;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.07.21.20.59.22;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	560042e0092f571e;

1.1.1.4
date	2006.10.03.19.10.03;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	1004522B592570E1901;

1.1.1.5
date	2007.07.15.19.51.36;	author tg;	state Exp;
branches;
next	;
commitid	100469A7AC943312E80;


desc
@@


1.18
log
@display when we’re in the SSL part of the negotiation

(might wish to implement SIGHUP or even ^T to jump to the next host)
@
text
@/*	$OpenBSD: fetch.c,v 1.74 2007/06/13 13:52:26 pyr Exp $	*/
/*	$NetBSD: fetch.c,v 1.14 1997/08/18 10:20:20 lukem Exp $	*/

/*-
 * Copyright © 2013, 2014, 2015, 2018
 *	mirabilos <m@@mirbsd.org>
 * Copyright (c) 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason Thorpe and Luke Mewburn.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * FTP User Program -- Command line file retrieval
 */

#include <sys/param.h>
#include <sys/socket.h>
#include <sys/stat.h>

#include <netinet/in.h>

#include <arpa/ftp.h>
#include <arpa/inet.h>

#include <ctype.h>
#include <err.h>
#include <libgen.h>
#include <limits.h>
#include <netdb.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <stdarg.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <util.h>
#include <resolv.h>

#ifndef SMALL
#include <openssl/ssl.h>
#include <openssl/err.h>
#else
#define SSL void
#endif

#include "ftp_var.h"

__RCSID("$MirOS: src/usr.bin/ftp/fetch.c,v 1.16 2015/07/18 23:16:47 tg Exp $");

static int	url_get(const char *, const char *, const char *);
static void	aborthttp(int) __dead;
static void	abortfile(int) __dead;
char		hextochar(const char *);
char		*urldecode(const char *);
int		ftp_printf(FILE *, SSL *, const char *, ...)
    __attribute__((__format__(__printf__, 3, 4)));
char		*ftp_readline(FILE *, SSL *, size_t *);
size_t		ftp_read(FILE *, SSL *, char *, size_t);
#ifndef SMALL
int		proxy_connect(int, char *);
int		SSL_vprintf(SSL *, const char *, va_list)
    __attribute__((__format__(__printf__, 2, 0)));
char		*SSL_readline(SSL *, size_t *);
#endif

#define	FTP_URL		"ftp://"	/* ftp URL prefix */
#define	HTTP_URL	"http://"	/* http URL prefix */
#define	HTTPS_URL	"https://"	/* https URL prefix */
#define	FILE_URL	"file:"		/* file URL prefix */
#define FTP_PROXY	"ftp_proxy"	/* env var with ftp proxy location */
#define HTTP_PROXY	"http_proxy"	/* env var with http proxy location */

#define COOKIE_MAX_LEN	42

#define EMPTYSTRING(x)	((x) == NULL || (*(x) == '\0'))

static const char at_encoding_warning[] =
    "Extra `@@' characters in usernames and passwords should be encoded as %%40";
static char L_slash[] = "/";
static char L_cd[] = "cd";
static char L_mget[] = "mget";

jmp_buf	httpabort;

static int	redirect_loop;

/*
 * Retrieve URL, via the proxy in $proxyvar if necessary.
 * Modifies the string argument given.
 * Returns -1 on failure, 0 on success
 */
static int
url_get(const char *origline, const char *proxyenv, const char *outfile)
{
	char pbuf[NI_MAXSERV], hbuf[NI_MAXHOST], *cp, *portnum, *path, ststr[4];
	char *hosttail, *host, *port, *buf = NULL;
	char * volatile newline;
	const char *cause = "unknown";
	int error, i, isftpurl = 0, isfileurl = 0, isredirect = 0;
	volatile int rval = -1;
	struct addrinfo hints, *res0, *res;
	const char * volatile savefile;
	char * volatile proxyurl = NULL;
	char *credentials = NULL;
	volatile int s = -1, out;
	volatile sig_t oldintr;
	FILE * volatile fin = NULL;
	off_t hashbytes;
	const char *errstr;
	size_t len, wlen;
#ifndef SMALL
	char *sslpath = NULL, *sslhost = NULL;
	int ishttpsurl = 0;
	SSL_CTX *ssl_ctx = NULL;
#endif
	SSL * volatile ssl = NULL;
	int statusx;

	newline = strdup(origline);
	if (newline == NULL)
		errx(1, "Can't allocate memory to parse URL");
	if (strncasecmp(newline, HTTP_URL, sizeof(HTTP_URL) - 1) == 0)
		host = newline + sizeof(HTTP_URL) - 1;
	else if (strncasecmp(newline, FTP_URL, sizeof(FTP_URL) - 1) == 0) {
		host = newline + sizeof(FTP_URL) - 1;
		isftpurl = 1;
	} else if (strncasecmp(newline, FILE_URL, sizeof(FILE_URL) - 1) == 0) {
		host = newline + sizeof(FILE_URL) - 1;
		isfileurl = 1;
#ifndef SMALL
	} else if (strncasecmp(newline, HTTPS_URL, sizeof(HTTPS_URL) - 1) == 0) {
		host = newline + sizeof(HTTPS_URL) - 1;
		ishttpsurl = 1;
#endif
	} else
		errx(1, "url_get: Invalid URL '%s'", newline);

	if (isfileurl) {
		path = host;
	} else {
		path = strchr(host, '/');		/* find path */
		if (EMPTYSTRING(path)) {
			if (isftpurl)
				goto noftpautologin;
			warnx("Invalid URL (no `/' after host): %s", origline);
			goto accept_it_nevertheless;
			goto cleanup_url_get;
		}
		*path++ = '\0';
		if (EMPTYSTRING(path)) {
			if (isftpurl)
				goto noftpautologin;
 accept_it_nevertheless:
			path = L_slash;
		}
	}

	if (outfile)
		savefile = outfile;
	else
		savefile = basename(path);

	if (EMPTYSTRING(savefile)) {
		if (isftpurl)
			goto noftpautologin;
		warnx("Invalid URL (no file after directory): %s", origline);
		goto cleanup_url_get;
	}

	if (!strcmp(savefile, "/"))
		savefile = strdup(host);

	if (!isfileurl && proxyenv != NULL) {
		/* use proxy */
		statusx = path == L_slash;
#ifndef SMALL
		if (ishttpsurl) {
			sslpath = strdup(path);
			sslhost = strdup(host);
			if (! sslpath || ! sslhost)
				errx(1, "Can't allocate memory for https path/host.");
		}
		if (*host == '[' && (hosttail = strrchr(host, ']')) != NULL &&
		    (hosttail[1] == '\0' || hosttail[1] == ':')) {
			host++;
			*hosttail++ = '\0';
		}
		if (!(http_user_headers_seen & HTTP_USER_HEADER_SEEN_COOKIE))
			cookie_get(host, path, ishttpsurl, &buf);
#endif
		proxyurl = strdup(proxyenv);
		if (proxyurl == NULL)
			errx(1, "Can't allocate memory for proxy URL.");
		if (strncasecmp(proxyurl, HTTP_URL, sizeof(HTTP_URL) - 1) == 0)
			host = proxyurl + sizeof(HTTP_URL) - 1;
		else if (strncasecmp(proxyurl, FTP_URL, sizeof(FTP_URL) - 1) == 0)
			host = proxyurl + sizeof(FTP_URL) - 1;
		else {
			warnx("Malformed proxy URL: %s", proxyenv);
			goto cleanup_url_get;
		}
		if (EMPTYSTRING(host)) {
			warnx("Malformed proxy URL: %s", proxyenv);
			goto cleanup_url_get;
		}
		*--path = '/';			/* add / back to real path */
		path = strchr(host, '/');	/* remove trailing / on host */
		if (!EMPTYSTRING(path))
			*path++ = '\0';		/* i guess this ++ is useless */

		path = strchr(host, '@@');	/* look for credentials in proxy */
		if (!EMPTYSTRING(path)) {
			*path++ = '\0';
			credentials = strchr(host, ':');
			if (EMPTYSTRING(credentials)) {
				warnx("Malformed proxy URL: %s", proxyenv);
				goto cleanup_url_get;
			}
			credentials = malloc(COOKIE_MAX_LEN);
			b64_ntop(host, strlen(host), credentials, COOKIE_MAX_LEN);
			/*
			 * This removes the password from proxyenv,
			 * filling with stars
			 */
			host = strchr(proxyenv + 5, ':');
			while (*++host != '@@')
				*host = '*';

			host = path;
		}
		if (statusx) {
			if (asprintf(&path, "%s/", newline) == -1)
				errx(1, "Can't allocate memory to parse URL");
			free(newline);
			newline = path;
		} else
			path = newline;
	}

	if (isfileurl) {
		struct stat st;

		s = open(path, O_RDONLY);
		if (s == -1) {
			warn("Can't open file %s", path);
			goto cleanup_url_get;
		}

		if (fstat(s, &st) == -1)
			filesize = -1;
		else
			filesize = st.st_size;

		/* Open the output file.  */
		if (strcmp(savefile, "-") != 0) {
			out = open(savefile, O_CREAT | O_WRONLY | O_TRUNC,
			    0666);
			if (out < 0) {
				warn("Can't open %s", savefile);
				goto cleanup_url_get;
			}
		} else
			out = fileno(stdout);

		/* Trap signals */
		oldintr = NULL;
		if (setjmp(httpabort)) {
			if (oldintr)
				(void)signal(SIGINT, oldintr);
			goto cleanup_url_get;
		}
		oldintr = signal(SIGINT, abortfile);

		bytes = 0;
		hashbytes = mark;
		progressmeter(-1);

		if ((buf = malloc(4096)) == NULL)
			errx(1, "Can't allocate memory for transfer buffer");

		/* Finally, suck down the file. */
		i = 0;
		while ((len = read(s, buf, 4096)) > 0) {
			bytes += len;
			for (cp = buf; len > 0; len -= i, cp += i) {
				if ((i = write(out, cp, len)) == -1) {
					warn("Writing %s", savefile);
					goto cleanup_url_get;
				}
				else if (i == 0)
					break;
			}
			if (hash && !progress) {
				while (bytes >= hashbytes) {
					(void)putc('#', ttyout);
					hashbytes += mark;
				}
				(void)fflush(ttyout);
			}
		}
		if (hash && !progress && bytes > 0) {
			if (bytes < mark)
				(void)putc('#', ttyout);
			(void)putc('\n', ttyout);
			(void)fflush(ttyout);
		}
		if (len != 0) {
			warn("Reading from file");
			goto cleanup_url_get;
		}
		progressmeter(1);
		if (verbose)
			fputs("Successfully retrieved file.\n", ttyout);
		(void)signal(SIGINT, oldintr);

		rval = 0;
		goto cleanup_url_get;
	}

	if (*host == '[' && (hosttail = strrchr(host, ']')) != NULL &&
	    (hosttail[1] == '\0' || hosttail[1] == ':')) {
		host++;
		*hosttail++ = '\0';
	} else
		hosttail = host;

	portnum = strrchr(hosttail, ':');		/* find portnum */
	if (portnum != NULL)
		*portnum++ = '\0';

	if (debug)
		fprintf(ttyout, "host %s, port %s, path %s, save as %s.\n",
		    host, portnum, path, savefile);

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = family;
	hints.ai_socktype = SOCK_STREAM;
#ifndef SMALL
	port = portnum ? portnum : (ishttpsurl ? httpsport : httpport);
#else
	port = portnum ? portnum : httpport;
#endif
	error = getaddrinfo(host, port, &hints, &res0);
	/*
	 * If the services file is corrupt/missing, fall back
	 * on our hard-coded defines.
	 */
	if (error == EAI_SERVICE && port == httpport) {
		snprintf(pbuf, sizeof(pbuf), "%d", HTTP_PORT);
		error = getaddrinfo(host, pbuf, &hints, &res0);
#ifndef SMALL
	} else if (error == EAI_SERVICE && port == httpsport) {
		snprintf(pbuf, sizeof(pbuf), "%d", HTTPS_PORT);
		error = getaddrinfo(host, pbuf, &hints, &res0);
#endif
	}
	if (error) {
		warnx("%s: %s", gai_strerror(error), host);
		goto cleanup_url_get;
	}

	s = -1;
	for (res = res0; res; res = res->ai_next) {
		if (getnameinfo(res->ai_addr, res->ai_addrlen, hbuf,
		    sizeof(hbuf), NULL, 0, NI_NUMERICHOST) != 0)
			strlcpy(hbuf, "(unknown)", sizeof(hbuf));
		if (verbose)
			fprintf(ttyout, "Trying %s...", hbuf);

		s = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
		if (s == -1) {
			cause = "socket";
			if (verbose)
				(void)putc('\n', ttyout);
			continue;
		}

 again:
		if (connect(s, res->ai_addr, res->ai_addrlen) < 0) {
			int save_errno;

			if (errno == EINTR)
				goto again;
			save_errno = errno;
			close(s);
			errno = save_errno;
			s = -1;
			cause = "connect";
			if (verbose)
				(void)putc('\n', ttyout);
			continue;
		}

		/* get port in numeric */
		if (getnameinfo(res->ai_addr, res->ai_addrlen, NULL, 0,
		    pbuf, sizeof(pbuf), NI_NUMERICSERV) == 0)
			port = pbuf;
		else
			port = NULL;

#ifndef SMALL
		if (proxyenv && sslhost)
			proxy_connect(s, sslhost);
#endif
		break;
	}
	freeaddrinfo(res0);
	if (s < 0) {
		if (verbose)
			(void)putc('\n', ttyout);
		warn("%s (%s)", cause, hbuf);
		goto cleanup_url_get;
	}

#ifndef SMALL
	if (ishttpsurl) {
		if (verbose)
			fprintf(ttyout, " SSL...\n");
		if (proxyenv && sslpath) {
			ishttpsurl = 0;
			proxyurl = NULL;
			path = sslpath;
		}
		SSL_library_init();
		SSL_load_error_strings();
		ssl_ctx = SSL_CTX_new(SSLv23_client_method());
		ssl = SSL_new(ssl_ctx);
		if (ssl == NULL || ssl_ctx == NULL) {
			ERR_print_errors_fp(ttyout);
			goto cleanup_url_get;
		}
		if (SSL_set_fd(ssl, s) == 0) {
			ERR_print_errors_fp(ttyout);
			goto cleanup_url_get;
		}
		if (SSL_connect(ssl) <= 0) {
			ERR_print_errors_fp(ttyout);
			goto cleanup_url_get;
		}
	} else
#endif
	    {
		if (verbose)
			(void)putc('\n', ttyout);
		fin = fdopen(s, "r+");
	}

	if (verbose)
		fprintf(ttyout, "Requesting %s", origline);
	/*
	 * Construct and send the request.
	 */
#ifndef SMALL
	if (!proxyurl && !(http_user_headers_seen & HTTP_USER_HEADER_SEEN_COOKIE))
		cookie_get(host, path, ishttpsurl, &buf);
#endif
	if (!(http_user_headers_seen & HTTP_USER_HEADER_SEEN_USER_AGENT))
		addheader(&buf, HTTP_USER_AGENT);
	if (proxyurl) {
		if (verbose)
			fprintf(ttyout, " (via %s)\n", proxyenv);
		/*
		 * Host: directive must use the destination host address for
		 * the original URI (path).  We do not attach it at this moment.
		 */
		if (credentials && !(http_user_headers_seen &
		    HTTP_USER_HEADER_SEEN_PROXY_AUTH)) {
			if (asprintf(&cp, "Proxy-Authorization: Basic %s",
			    credentials) == -1)
				errx(1, "not enough memory for HTTP headers");
			addheader(&buf, cp);
			free(cp);
		}
		statusx = 0;
	} else {
		char *h, *p;

		if (verbose)
			fprintf(ttyout, "\n");
		if (strchr(host, ':')) {
			/*
			 * strip off scoped address portion, since it's
			 * local to node
			 */
			h = strdup(host);
			if (h == NULL)
				errx(1, "Can't allocate memory.");
			if ((p = strchr(h, '%')) != NULL)
				*p = '\0';
		} else
			h = host;

		/*
		 * Send port number only if it's specified and does not equal
		 * 80. Some broken HTTP servers get confused if you explicitly
		 * send them the port number.
		 */
#ifndef SMALL
		statusx = (port && strcmp(port, (ishttpsurl ? "443" : "80")) != 0);
#else
		statusx = (port && strcmp(port, "80") != 0);
#endif

		if (asprintf(&cp, "Host: %s%s%s%s%s",
		    (h == host) ? "" : "[", h,
		    (h == host) ? "" : "]",
		    statusx ? ":" : "", statusx ? port : "") == -1)
			errx(1, "not enough memory for HTTP headers");
		if (h != host)
			free(h);
		if (!(http_user_headers_seen & HTTP_USER_HEADER_SEEN_HOST))
			addheader(&buf, cp);
		free(cp);
		statusx = path[0] != '/';
	}
	ftp_printf(fin, ssl, "GET %s%s HTTP/1.0\r\n%s%s\r\n",
	    statusx ? "/" : "", path,
	    buf ? buf : "", http_user_headers ? http_user_headers : "");

#ifndef SMALL
	free(buf);
#endif
	buf = NULL;

	if (fin != NULL && fflush(fin) == EOF) {
		warn("Writing HTTP request");
		goto cleanup_url_get;
	}
	if ((buf = ftp_readline(fin, ssl, &len)) == NULL) {
		warn("Receiving HTTP reply");
		goto cleanup_url_get;
	}

	while (len > 0 && (buf[len-1] == '\r' || buf[len-1] == '\n'))
		buf[--len] = '\0';
	if (debug)
		fprintf(ttyout, "received '%s'\n", buf);

	cp = strchr(buf, ' ');
	if (cp == NULL)
		goto improper;
	else
		cp++;

	strlcpy(ststr, cp, sizeof(ststr));
	statusx = strtonum(ststr, 200, 307, &errstr);
	if (errstr) {
		warnx("Error retrieving file: %s", cp);
		goto cleanup_url_get;
	}

	switch (statusx) {
	case 200:	/* OK */
		break;
	case 301:	/* Moved Permanently */
	case 302:	/* Found */
	case 303:	/* See Other */
	case 307:	/* Temporary Redirect */
		isredirect++;
		if (redirect_loop++ > 10) {
			warnx("Too many redirections requested");
			goto cleanup_url_get;
		}
		break;
	default:
		warnx("Error retrieving file: %s", cp);
		goto cleanup_url_get;
	}

	/*
	 * Read the rest of the header.
	 */
	free(buf);
	filesize = -1;

	for (;;) {
		if ((buf = ftp_readline(fin, ssl, &len)) == NULL) {
			warn("Receiving HTTP reply");
			goto cleanup_url_get;
		}

		while (len > 0 && (buf[len-1] == '\r' || buf[len-1] == '\n'))
			buf[--len] = '\0';
		if (len == 0)
			break;
		if (debug)
			fprintf(ttyout, "received '%s'\n", buf);

		/* Look for some headers */
		cp = buf;
#define CONTENTLEN "Content-Length: "
		if (strncasecmp(cp, CONTENTLEN, sizeof(CONTENTLEN) - 1) == 0) {
			cp += sizeof(CONTENTLEN) - 1;
			filesize = strtonum(cp, 0, LLONG_MAX, &errstr);
			if (errstr != NULL)
				goto improper;
#define LOCATION "Location: "
		} else if (isredirect &&
		    strncasecmp(cp, LOCATION, sizeof(LOCATION) - 1) == 0) {
			cp += sizeof(LOCATION) - 1;
			if (verbose)
				fprintf(ttyout, "Redirected to %s\n", cp);
			if (fin != NULL)
				fclose(fin);
			else if (s != -1)
				close(s);
			free(proxyurl);
			free(newline);
			rval = url_get(cp, proxyenv, outfile);
			free(buf);
			return (rval);
		}
	}

	/* Open the output file.  */
	if (strcmp(savefile, "-") != 0) {
		out = open(savefile, O_CREAT | O_WRONLY | O_TRUNC, 0666);
		if (out < 0) {
			warn("Can't open %s", savefile);
			goto cleanup_url_get;
		}
	} else
		out = fileno(stdout);

	/* Trap signals */
	oldintr = NULL;
	if (setjmp(httpabort)) {
		if (oldintr)
			(void)signal(SIGINT, oldintr);
		goto cleanup_url_get;
	}
	oldintr = signal(SIGINT, aborthttp);

	bytes = 0;
	hashbytes = mark;
	progressmeter(-1);

	free(buf);

	/* Finally, suck down the file. */
	if ((buf = malloc(4096)) == NULL)
		errx(1, "Can't allocate memory for transfer buffer");
	i = 0;
	len = 1;
	while (len > 0) {
		len = ftp_read(fin, ssl, buf, 4096);
		bytes += len;
		for (cp = buf, wlen = len; wlen > 0; wlen -= i, cp += i) {
			if ((i = write(out, cp, wlen)) == -1) {
				warn("Writing %s", savefile);
				goto cleanup_url_get;
			}
			else if (i == 0)
				break;
		}
		if (hash && !progress) {
			while (bytes >= hashbytes) {
				(void)putc('#', ttyout);
				hashbytes += mark;
			}
			(void)fflush(ttyout);
		}
	}
	if (hash && !progress && bytes > 0) {
		if (bytes < mark)
			(void)putc('#', ttyout);
		(void)putc('\n', ttyout);
		(void)fflush(ttyout);
	}
	if (len != 0) {
		warn("Reading from socket");
		goto cleanup_url_get;
	}
	progressmeter(1);
	if (filesize != -1 && len == 0 && bytes != filesize) {
		if (verbose)
			fputs("Read short file.\n", ttyout);
		goto cleanup_url_get;
	}

	if (verbose)
		fputs("Successfully retrieved file.\n", ttyout);
	(void)signal(SIGINT, oldintr);

	rval = 0;
	goto cleanup_url_get;

 noftpautologin:
	warnx(
	    "Auto-login using ftp URLs isn't supported when using $ftp_proxy");
	goto cleanup_url_get;

 improper:
	warnx("Improper response from %s", host);

 cleanup_url_get:
#ifndef SMALL
	if (ssl) {
		SSL_shutdown(ssl);
		SSL_free(ssl);
	}
#endif
	if (fin != NULL)
		fclose(fin);
	else if (s != -1)
		close(s);
	free(buf);
	free(proxyurl);
	free(newline);
	return (rval);
}

/*
 * Abort a http retrieval
 */
/* ARGSUSED */
static void
aborthttp(int signo __unused)
{

	alarmtimer(0);
	fputs("\nhttp fetch aborted.\n", ttyout);
	(void)fflush(ttyout);
	longjmp(httpabort, 1);
}

/*
 * Abort a http retrieval
 */
/* ARGSUSED */
static void
abortfile(int signo __unused)
{

	alarmtimer(0);
	fputs("\nfile fetch aborted.\n", ttyout);
	(void)fflush(ttyout);
	longjmp(httpabort, 1);
}

/*
 * Retrieve multiple files from the command line, transferring
 * files of the form "host:path", "ftp://host/path" using the
 * ftp protocol, and files of the form "http://host/path" using
 * the http protocol.
 * If path has a trailing "/", then return (-1);
 * the path will be cd-ed into and the connection remains open,
 * and the function will return -1 (to indicate the connection
 * is alive).
 * If an error occurs the return value will be the offset+1 in
 * argv[] of the file that caused a problem (i.e, argv[x]
 * returns x+1)
 * Otherwise, 0 is returned if all files retrieved successfully.
 */
int
auto_fetch(int argc, char *argv[], char *outfile)
{
	char *xargv[5];
	char *cp, *url, *host, *dir, *file, *portnum;
	char *username, *pass, *pathstart;
	char *ftpproxy, *httpproxy;
	int rval, xargc;
	volatile int argpos;
	int dirhasglob, filehasglob, oautologin;
	char rempath[MAXPATHLEN];

	argpos = 0;

	if (setjmp(toplevel)) {
		if (connected)
			disconnect(0, NULL);
		return (argpos + 1);
	}
	(void)signal(SIGINT, (sig_t)intr);
	(void)signal(SIGPIPE, (sig_t)lostpeer);

	if ((ftpproxy = getenv(FTP_PROXY)) != NULL && *ftpproxy == '\0')
		ftpproxy = NULL;
	if ((httpproxy = getenv(HTTP_PROXY)) != NULL && *httpproxy == '\0')
		httpproxy = NULL;

	/*
	 * Loop through as long as there's files to fetch.
	 */
	for (rval = 0; (rval == 0) && (argpos < argc); free(url), argpos++) {
		if (strchr(argv[argpos], ':') == NULL)
			break;
		host = dir = file = portnum = username = pass = NULL;

		/*
		 * We muck with the string, so we make a copy.
		 */
		url = strdup(argv[argpos]);
		if (url == NULL)
			errx(1, "Can't allocate memory for auto-fetch.");

		/*
		 * Try HTTP URL-style arguments first.
		 */
		if (strncasecmp(url, HTTP_URL, sizeof(HTTP_URL) - 1) == 0 ||
#ifndef SMALL
		    /* even if we compiled without SSL, url_get will check */
		    strncasecmp(url, HTTPS_URL, sizeof(HTTPS_URL) -1) == 0 ||
#endif
		    strncasecmp(url, FILE_URL, sizeof(FILE_URL) - 1) == 0) {
			redirect_loop = 0;
			if (url_get(url, httpproxy, outfile) == -1)
				rval = argpos + 1;
			continue;
		}

		/*
		 * Try FTP URL-style arguments next. If ftpproxy is
		 * set, use url_get() instead of standard ftp.
		 * Finally, try host:file.
		 */
		host = url;
		if (strncasecmp(url, FTP_URL, sizeof(FTP_URL) - 1) == 0) {
			char *passend, *passagain, *userend;

			if (ftpproxy) {
				if (url_get(url, ftpproxy, outfile) == -1)
					rval = argpos + 1;
				continue;
			}
			host += sizeof(FTP_URL) - 1;
			dir = strchr(host, '/');

			/* Look for [user:pass@@]host[:port] */

			/* check if we have "user:pass@@" */
			userend = strchr(host, ':');
			passend = strchr(host, '@@');
			if (passend && userend && userend < passend &&
			    (!dir || passend < dir)) {
				username = host;
				pass = userend + 1;
				host = passend + 1;
				*userend = *passend = '\0';
				passagain = strchr(host, '@@');
				if (strchr(pass, '@@') != NULL ||
				    (passagain != NULL && passagain < dir)) {
					warnx(at_encoding_warning);
					goto bad_ftp_url;
				}

				if (EMPTYSTRING(username) || EMPTYSTRING(pass)) {
 bad_ftp_url:
					warnx("Invalid URL: %s", argv[argpos]);
					rval = argpos + 1;
					continue;
				}
				username = urldecode(username);
				pass = urldecode(pass);
			}

#ifdef INET6
			/* check [host]:port, or [host] */
			if (host[0] == '[') {
				cp = strchr(host, ']');
				if (cp && (!dir || cp < dir)) {
					if (cp + 1 == dir || cp[1] == ':') {
						host++;
						*cp++ = '\0';
					} else
						cp = NULL;
				} else
					cp = host;
			} else
				cp = host;
#else
			cp = host;
#endif

			/* split off host[:port] if there is */
			if (cp) {
				portnum = strchr(cp, ':');
				pathstart = strchr(cp, '/');
				/* : in path is not a port # indicator */
				if (portnum && pathstart &&
				    pathstart < portnum)
					portnum = NULL;

				if (!portnum)
					;
				else {
					if (!dir)
						;
					else if (portnum + 1 < dir) {
						*portnum++ = '\0';
						/*
						 * XXX should check if portnum
						 * is decimal number
						 */
					} else {
						/* empty portnum */
						goto bad_ftp_url;
					}
				}
			} else
				portnum = NULL;
		} else {			/* classic style `host:file' */
			dir = strchr(host, ':');
		}
		if (EMPTYSTRING(host)) {
			rval = argpos + 1;
			continue;
		}

		/*
		 * If dir is NULL, the file wasn't specified
		 * (URL looked something like ftp://host)
		 */
		if (dir != NULL)
			*dir++ = '\0';

		/*
		 * Extract the file and (if present) directory name.
		 */
		if (!EMPTYSTRING(dir)) {
			cp = strrchr(dir, '/');
			if (cp != NULL) {
				*cp++ = '\0';
				file = cp;
			} else {
				file = dir;
				dir = NULL;
			}
		}
		if (debug)
			fprintf(ttyout,
			    "user %s:%s host %s port %s dir %s file %s\n",
			    username, pass, host, portnum, dir, file);

		/*
		 * Set up the connection.
		 */
		if (connected)
			disconnect(0, NULL);
		xargv[0] = __progname;
		xargv[1] = host;
		xargv[2] = NULL;
		xargc = 2;
		if (!EMPTYSTRING(portnum)) {
			xargv[2] = portnum;
			xargv[3] = NULL;
			xargc = 3;
		}
		oautologin = autologin;
		if (username != NULL)
			autologin = 0;
		setpeer(xargc, xargv);
		autologin = oautologin;
		if ((connected == 0) ||
		    ((connected == 1) && !ftp_login(host, username, pass))) {
			warnx("Can't connect or login to host `%s'", host);
			rval = argpos + 1;
			continue;
		}

		/* Always use binary transfers. */
		setbinary(0, NULL);

		dirhasglob = filehasglob = 0;
		if (doglob) {
			if (!EMPTYSTRING(dir) &&
			    strpbrk(dir, "*?[]{}") != NULL)
				dirhasglob = 1;
			if (!EMPTYSTRING(file) &&
			    strpbrk(file, "*?[]{}") != NULL)
				filehasglob = 1;
		}

		/* Change directories, if necessary. */
		if (!EMPTYSTRING(dir) && !dirhasglob) {
			xargv[0] = L_cd;
			xargv[1] = dir;
			xargv[2] = NULL;
			cd(2, xargv);
			if (!dirchange) {
				rval = argpos + 1;
				continue;
			}
		}

		if (EMPTYSTRING(file)) {
			rval = -1;
			continue;
		}

		if (verbose)
			fprintf(ttyout, "Retrieving %s/%s\n", dir ? dir : "", file);

		if (dirhasglob) {
			snprintf(rempath, sizeof(rempath), "%s/%s", dir, file);
			file = rempath;
		}

		/* Fetch the file(s). */
		xargc = 2;
		xargv[0] = L_mget + 1;
		xargv[1] = file;
		xargv[2] = NULL;
		if (dirhasglob || filehasglob) {
			int ointeractive;

			ointeractive = interactive;
			interactive = 0;
			xargv[0] = L_mget;
			mget(xargc, xargv);
			interactive = ointeractive;
		} else {
			if (outfile != NULL) {
				xargv[2] = outfile;
				xargv[3] = NULL;
				xargc++;
			}
			get(xargc, xargv);
		}

		if ((code / 100) != COMPLETE)
			rval = argpos + 1;
	}
	if (connected && rval != -1)
		disconnect(0, NULL);
	return (rval);
}

char *
urldecode(const char *str)
{
	char *ret, c;
	int i, reallen;

	if (str == NULL)
		return NULL;
	if ((ret = malloc(strlen(str)+1)) == NULL)
		err(1, "Can't allocate memory for URL decoding");
	for (i = 0, reallen = 0; str[i] != '\0'; i++, reallen++, ret++) {
		c = str[i];
		if (c == '+') {
			*ret = ' ';
			continue;
		}

		/* Cannot use strtol here because next char
		 * after %xx may be a digit.
		 */
		if (c == '%' && isxdigit(str[i+1]) && isxdigit(str[i+2])) {
			*ret = hextochar(&str[i+1]);
			i+=2;
			continue;
		}
		*ret = c;
	}
	*ret = '\0';

	return ret-reallen;
}

char
hextochar(const char *str)
{
	char c, ret;

	c = str[0];
	ret = c;
	if (isalpha(c))
		ret -= isupper(c) ? 'A' - 10 : 'a' - 10;
	else
		ret -= '0';
	ret *= 16;

	c = str[1];
	ret += c;
	if (isalpha(c))
		ret -= isupper(c) ? 'A' - 10 : 'a' - 10;
	else
		ret -= '0';
	return ret;
}

int
isurl(const char *p)
{

	if (strncasecmp(p, FTP_URL, sizeof(FTP_URL) - 1) == 0 ||
	    strncasecmp(p, HTTP_URL, sizeof(HTTP_URL) - 1) == 0 ||
#ifndef SMALL
	    strncasecmp(p, HTTPS_URL, sizeof(HTTPS_URL) - 1) == 0 ||
#endif
	    strncasecmp(p, FILE_URL, sizeof(FILE_URL) - 1) == 0 ||
	    strstr(p, ":/"))
		return (1);
	return (0);
}

char *
ftp_readline(FILE *fp, SSL *ssl, size_t *lenp)
{
	if (fp != NULL)
		return fparseln(fp, lenp, NULL, "\0\0\0", 0);
#ifndef SMALL
	else if (ssl != NULL)
		return SSL_readline(ssl, lenp);
#endif
	else
		return NULL;
}

size_t
ftp_read(FILE *fp, SSL *ssl, char *buf, size_t len)
{
	size_t ret;
	if (fp != NULL)
		ret = fread(buf, sizeof(char), len, fp);
#ifndef SMALL
	else if (ssl != NULL) {
		int nr;

		if (len > INT_MAX)
			len = INT_MAX;
		if ((nr = SSL_read(ssl, buf, (int)len)) <= 0)
			ret = 0;
		else
			ret = nr;
	}
#endif
	else
		ret = 0;
	return (ret);
}

int
ftp_printf(FILE *fp, SSL *ssl, const char *fmt, ...)
{
	int ret;
	va_list ap;

	va_start(ap, fmt);

	if (fp != NULL)
		ret = vfprintf(fp, fmt, ap);
#ifndef SMALL
	else if (ssl != NULL)
		ret = SSL_vprintf((SSL*)ssl, fmt, ap);
#endif
	else
		ret = 0;

	va_end(ap);
	return (ret);
}

#ifndef SMALL
int
SSL_vprintf(SSL *ssl, const char *fmt, va_list ap)
{
	int ret;
	char *string;

	if ((ret = vasprintf(&string, fmt, ap)) == -1)
		return ret;
	ret = SSL_write(ssl, string, ret);
	free(string);
	return ret;
}

char *
SSL_readline(SSL *ssl, size_t *lenp)
{
	size_t i, len;
	char *buf, *q, c;

	len = 128;
	if ((buf = malloc(len)) == NULL)
		errx(1, "Can't allocate memory for transfer buffer");
	for (i = 0; ; i++) {
		if (i >= len - 1) {
			if ((q = realloc(buf, 2 * len)) == NULL)
				errx(1, "Can't expand transfer buffer");
			buf = q;
			len *= 2;
		}
		if (SSL_read(ssl, &c, 1) <= 0)
			break;
		buf[i] = c;
		if (c == '\n')
			break;
	}
	*lenp = i;
	return (buf);
}

int
proxy_connect(int socketfd, char *host)
{
	int l;
	char buf[1024];
	char *connstr, *hosttail;
	const char *port;

	if (*host == '[' && (hosttail = strrchr(host, ']')) != NULL &&
		(hosttail[1] == '\0' || hosttail[1] == ':')) {
		host++;
		*hosttail++ = '\0';
	} else
		hosttail = host;

	/* find portnum */
	if ((connstr = strrchr(hosttail, ':'))) {
		*connstr++ = '\0';
		port = connstr;
	} else
		port = "443";

	l = asprintf(&connstr, "CONNECT %s:%s HTTP/1.1\r\n\r\n", host, port);
	if (l == -1)
		errx(1, "Could not allocate memory to assemble connect string!");
	if (debug) {
		if (verbose)
			(void)putc('\n', ttyout);
		printf("%s", connstr);
	}
	if (write(socketfd, connstr, l) != l)
		err(1, "Could not send connect string");
	read(socketfd, &buf, sizeof(buf)); /* only proxy header XXX: error handling? */
	free(connstr);
	return(200);
}
#endif

void
addheader(char **bufp, const char *newheader)
{
	char *cp;

	/* set a new header entry */
	if (asprintf(&cp, "%s%s\r\n", *bufp ? *bufp : "", newheader) == -1)
		errx(1, "not enough memory for HTTP headers");
	free(*bufp);
	*bufp = cp;
}
@


1.17
log
@revert the now no longer needed patches from yesternight, MirSSL copes now
@
text
@d5 2
a6 2
 * Copyright © 2013, 2014, 2015
 *	mirabilos <tg@@mirbsd.org>
d400 1
a400 1
			fprintf(ttyout, "Trying %s...\n", hbuf);
d405 2
d410 1
a410 1
again:
d421 2
d441 2
d449 2
d472 5
a476 1
	} else {
a478 3
#else
	fin = fdopen(s, "r+");
#endif
d720 1
a720 1
noftpautologin:
d725 1
a725 1
improper:
d728 1
a728 1
cleanup_url_get:
d880 1
a880 1
bad_ftp_url:
d1252 3
a1254 1
	if (debug)
d1256 1
@


1.16
log
@merge bugfix from sendmail (and add warnings to documentation):
        Properly initialize all OpenSSL algorithms for versions before
                OpenSSL 0.9.8o. Without this SHA2 algorithms may not
                work properly, causing for example failures for certs
                that use sha256WithRSAEncryption as signature algorithm.
additionally, remove redundant call (it’s an alias) from ftp(1)
@
text
@d80 1
a80 1
__RCSID("$MirOS: src/usr.bin/ftp/fetch.c,v 1.15 2014/11/13 22:58:28 tg Exp $");
a449 1
		OpenSSL_add_all_algorithms();
@


1.15
log
@Add -H (like wget --header) support. Yak shaving time.
• more __CRAZY=Yes
• accept http://foo (w/o trailing /) but keep complaining
• unbreak http://foo/ (with exactly one trailing slash)
  ‣ was broken in separate variants for with/without proxy
• do not replace the : in user:pass with an asterisk
• streamline HTTP header/request generation
• unbreak cookies for proxy-using requests
@
text
@d5 2
a6 2
 * Copyright © 2013, 2014
 *	Thorsten “mirabilos” Glaser <tg@@mirbsd.org>
d80 1
a80 1
__RCSID("$MirOS: src/usr.bin/ftp/fetch.c,v 1.9 2013/10/31 20:07:03 tg Exp $");
d450 1
a450 1
		SSLeay_add_ssl_algorithms();
@


1.14
log
@get at least the headers right, c’mon obsd…
@
text
@d128 2
a129 1
	char *hosttail, *newline, *host, *port, *buf = NULL;
d139 1
a139 1
	FILE *fin = NULL;
d178 1
d185 1
d205 3
a207 1
	if (!isfileurl && proxyenv != NULL) {		/* use proxy */
d215 7
d257 2
a258 2
			for (host = strchr(proxyenv + 5, ':');  *host != '@@';
			     host++)
d263 7
a269 1
		path = newline;
d475 1
a475 1
	 * Construct and send the request. Proxy requests don't want leading /.
d478 2
a479 1
	cookie_get(host, path, ishttpsurl, &buf);
d481 2
d490 11
a500 7
		if (credentials)
			ftp_printf(fin, ssl, "GET %s HTTP/1.0\r\n"
			    "Proxy-Authorization: Basic %s\r\n%s%s\r\n\r\n",
			    path, credentials, buf ? buf : "", HTTP_USER_AGENT);
		else
			ftp_printf(fin, ssl, "GET %s HTTP/1.0\r\n%s%s\r\n\r\n",
			    path, buf ? buf : "", HTTP_USER_AGENT);
d502 2
a503 2
	} else {
		ftp_printf(fin, ssl, "GET /%s HTTP/1.0\r\nHost: ", path);
a504 2
			char *h, *p;

a513 2
			ftp_printf(fin, ssl, "[%s]", h);
			free(h);
d515 1
a515 1
			ftp_printf(fin, ssl, "%s", host);
d523 1
a523 2
		if (port && strcmp(port, (ishttpsurl ? "443" : "80")) != 0)
			ftp_printf(fin, ssl, ":%s", port);
d525 1
a525 2
		if (port && strcmp(port, "80") != 0)
			ftp_printf(fin, ssl, ":%s", port);
a526 5
		ftp_printf(fin, ssl, "\r\n%s%s\r\n\r\n",
		    buf ? buf : "", HTTP_USER_AGENT);
		if (verbose)
			fprintf(ttyout, "\n");
	}
d528 15
d1253 12
@


1.12
log
@get at least this one file __CRAZY=Yes safe
@
text
@d471 1
a471 1
			    "Proxy-Authorization: Basic %s%s\r\n%s\r\n\r\n",
@


1.11
log
@improvements from obsd
@
text
@d83 2
a84 2
void		aborthttp(int);
void		abortfile(int);
d93 2
a94 1
int		SSL_vprintf(SSL *, const char *, va_list);
d111 3
d128 4
a131 2
	char *hosttail, *cause = "unknown", *newline, *host, *port, *buf = NULL;
	int error, i, isftpurl = 0, isfileurl = 0, isredirect = 0, rval = -1;
d147 2
a148 2
	SSL *ssl = NULL;
	int status;
d183 1
a183 1
			path = "/";
d541 1
a541 1
	status = strtonum(ststr, 200, 307, &errstr);
d547 1
a547 1
	switch (status) {
d712 2
a713 2
void
aborthttp(int signo)
d726 2
a727 2
void
abortfile(int signo)
d971 1
a971 1
			xargv[0] = "cd";
d996 1
a996 1
		xargv[0] = "get";
d1004 1
a1004 1
			xargv[0] = "mget";
d1191 1
a1191 1
proxy_connect(int socket, char *host)
d1195 2
a1196 1
	char *connstr, *hosttail, *port;
d1205 5
a1209 4
	port = strrchr(hosttail, ':');               /* find portnum */
	if (port != NULL)
		*port++ = '\0';
	if (!port)
d1217 1
a1217 1
	if (write(socket, connstr, l) != l)
d1219 1
a1219 1
	read(socket, &buf, sizeof(buf)); /* only proxy header XXX: error handling? */
@


1.10
log
@erm… CRLF on the wire!
@
text
@d108 1
a108 1
static const char *at_encoding_warning =
d129 1
a129 1
	char *cookie = NULL;
d228 2
a229 2
			cookie = strchr(host, ':');
			if (EMPTYSTRING(cookie)) {
d233 2
a234 2
			cookie  = malloc(COOKIE_MAX_LEN);
			b64_ntop(host, strlen(host), cookie, COOKIE_MAX_LEN);
d463 1
a463 1
		if (cookie)
d466 1
a466 1
			    path, cookie, buf ? buf : "", HTTP_USER_AGENT);
@


1.9
log
@adapt most __attribute__((…)) occurrences to new KNF style(9)
@
text
@d5 1
a5 1
 * Copyright © 2013
d80 1
a80 1
__RCSID("$MirOS: src/usr.bin/ftp/fetch.c,v 1.8 2010/08/12 11:30:46 tg Exp $");
d1204 1
a1204 1
	l = asprintf(&connstr, "CONNECT %s:%s HTTP/1.1\n\n", host, port);
@


1.8
log
@display host that connecting to failed, by request of cow-orker agocke
@
text
@d5 2
d80 1
a80 1
__RCSID("$MirOS: src/usr.bin/ftp/fetch.c,v 1.7 2007/07/15 20:01:07 tg Exp $");
d87 2
a88 1
int		ftp_printf(FILE *, SSL *, const char *, ...) __attribute__((format(printf, 3, 4)));
@


1.7
log
@fastmerge and fix their bugs (tree breaker, but they don't seem to care,
it's been broken for 25 days…)
@
text
@a0 1
/**	$MirOS: src/usr.bin/ftp/fetch.c,v 1.6 2006/10/03 19:22:17 tg Exp $ */
d78 1
a78 1
__RCSID("$MirOS: src/usr.bin/ftp/fetch.c,v 1.6 2006/10/03 19:22:17 tg Exp $");
d410 1
a410 1
		warn("%s", cause);
@


1.6
log
@merge
@
text
@d1 2
a2 2
/**	$MirOS: src/usr.bin/ftp/fetch.c,v 1.5 2006/06/14 21:48:35 tg Exp $ */
/*	$OpenBSD: fetch.c,v 1.68 2006/07/07 12:00:25 ray Exp $	*/
d68 1
d79 1
a79 1
__RCSID("$MirOS: src/usr.bin/ftp/fetch.c,v 1.5 2006/06/14 21:48:35 tg Exp $");
d102 1
d121 1
a121 1
	char pbuf[NI_MAXSERV], hbuf[NI_MAXHOST], *cp, *portnum, *path;
d127 1
d140 1
d221 4
d226 17
d437 1
a437 1
			goto cleanup_url_get;;
d451 3
d461 8
a468 2
		ftp_printf(fin, ssl, "GET %s HTTP/1.0\r\n%s\r\n\r\n", path,
		    HTTP_USER_AGENT);
d500 2
a501 1
		ftp_printf(fin, ssl, "\r\n%s\r\n\r\n", HTTP_USER_AGENT);
d505 7
d531 15
a545 1
	if (strncmp(cp, "301", 3) == 0 || strncmp(cp, "302", 3) == 0) {
d551 2
a552 1
	} else if (strncmp(cp, "200", 3)) {
d1210 1
@


1.5
log
@I get TIRED of that FRICKING message
if I $ ftp http://server.dom/ I want it to do that!
@
text
@d1 2
a2 2
/**	$MirOS$ */
/*	$OpenBSD: fetch.c,v 1.55 2005/07/18 02:55:59 fgsch Exp $	*/
d57 1
d62 1
d69 7
d78 1
a78 1
__RCSID("$MirOS: src/usr.bin/ftp/fetch.c,v 1.4 2005/11/23 17:36:14 tg Exp $");
d85 8
d96 1
d119 2
a120 2
	char pbuf[NI_MAXSERV], hbuf[NI_MAXHOST], *cp, *ep, *portnum, *path;
	char *hosttail, *cause = "unknown", *line, *host, *port, *buf = NULL;
d124 1
a124 1
	char * volatile proxy = NULL;
d129 8
a136 1
	size_t len;
d138 2
a139 2
	line = strdup(origline);
	if (line == NULL)
d141 4
a144 4
	if (strncasecmp(line, HTTP_URL, sizeof(HTTP_URL) - 1) == 0)
		host = line + sizeof(HTTP_URL) - 1;
	else if (strncasecmp(line, FTP_URL, sizeof(FTP_URL) - 1) == 0) {
		host = line + sizeof(FTP_URL) - 1;
d146 2
a147 2
	} else if (strncasecmp(line, FILE_URL, sizeof(FILE_URL) - 1) == 0) {
		host = line + sizeof(FILE_URL) - 1;
d149 5
d155 1
a155 1
		errx(1, "url_get: Invalid URL '%s'", line);
d190 11
a200 3
	if (proxyenv != NULL) {				/* use proxy */
		proxy = strdup(proxyenv);
		if (proxy == NULL)
d202 4
a205 4
		if (strncasecmp(proxy, HTTP_URL, sizeof(HTTP_URL) - 1) == 0)
			host = proxy + sizeof(HTTP_URL) - 1;
		else if (strncasecmp(proxy, FTP_URL, sizeof(FTP_URL) - 1) == 0)
			host = proxy + sizeof(FTP_URL) - 1;
d218 1
a218 1
		path = line;
d319 3
d323 1
d325 4
a329 4
		/*
		 * If the services file is corrupt/missing, fall back
		 * on our hard-coded defines.
		 */
d332 5
d359 2
d363 1
d365 1
d378 4
d390 28
d419 1
d426 1
a426 1
	if (proxy) {
d433 1
a433 1
		fprintf(fin, "GET %s HTTP/1.0\r\n%s\r\n\r\n", path,
d436 1
a436 1
		fprintf(fin, "GET /%s HTTP/1.1\r\nHost: ", path);
d449 1
a449 1
			fprintf(fin, "[%s]", h);
d452 1
a452 1
			fprintf(fin, "%s", host);
d459 4
d464 3
a466 3
			fprintf(fin, ":%s", port);
		fprintf(fin, "\r\nConnection: close\r\n%s\r\n\r\n",
		    HTTP_USER_AGENT);
d470 1
a470 1
	if (fflush(fin) == EOF) {
d474 1
a474 2

	if ((buf = fparseln(fin, &len, NULL, "\0\0\0", 0)) == NULL) {
d506 2
a507 2
	while (1) {
		if ((buf = fparseln(fin, &len, NULL, "\0\0\0", 0)) == NULL) {
d511 1
d524 2
a525 2
			filesize = strtol(cp, &ep, 10);
			if (filesize < 1 || *ep != '\0')
d537 2
a538 3
			if (proxy)
				free(proxy);
			free(line);
d540 1
a540 2
			if (buf)
				free(buf);
d574 3
a576 1
	while ((len = fread(buf, sizeof(char), 4096, fin)) > 0) {
d578 2
a579 2
		for (cp = buf; len > 0; len -= i, cp += i) {
			if ((i = write(out, cp, len)) == -1) {
d627 6
d637 3
a639 5
	if (buf)
		free(buf);
	if (proxy)
		free(proxy);
	free(line);
d689 2
a690 2
	char *cp, *line, *host, *dir, *file, *portnum;
	char *user, *pass, *pathstart;
d715 1
a715 1
	for (rval = 0; (rval == 0) && (argpos < argc); free(line), argpos++) {
d718 1
a718 1
		host = dir = file = portnum = user = pass = NULL;
d723 2
a724 2
		line = strdup(argv[argpos]);
		if (line == NULL)
d730 6
a735 2
		if (strncasecmp(line, HTTP_URL, sizeof(HTTP_URL) - 1) == 0 ||
		    strncasecmp(line, FILE_URL, sizeof(FILE_URL) - 1) == 0) {
d737 1
a737 1
			if (url_get(line, httpproxy, outfile) == -1)
d747 2
a748 2
		host = line;
		if (strncasecmp(line, FTP_URL, sizeof(FTP_URL) - 1) == 0) {
d752 1
a752 1
				if (url_get(line, ftpproxy, outfile) == -1)
d766 1
a766 1
				user = host;
d777 1
a777 1
				if (EMPTYSTRING(user) || EMPTYSTRING(pass)) {
d783 1
a783 1
				user = urldecode(user);
d863 1
a863 1
			    user, pass, host, portnum, dir, file);
d880 1
a880 1
		if (user != NULL)
d885 1
a885 1
		    ((connected == 1) && !ftp_login(host, user, pass))) {
d975 4
a978 2
		/* Can't use strtol here because next char after %xx may be
		 * a digit. */
d1019 3
d1027 129
@


1.4
log
@fastmerge usr.bin part 1 (a-m)
@
text
@d1 1
d69 1
a69 1
__RCSID("$MirOS: src/usr.bin/ftp/fetch.c,v 1.3 2005/04/29 18:35:08 tg Exp $");
d141 1
a141 2
			warnx("Invalid URL (no file after host): %s", origline);
			goto cleanup_url_get;
d157 3
@


1.3
log
@(tentative) merge, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.54 2005/04/21 05:17:21 fgsch Exp $	*/
d68 1
a68 1
__RCSID("$MirOS: src/usr.bin/ftp/fetch.c,v 1.2 2005/03/15 18:44:52 tg Exp $");
d196 2
a197 1
			out = open(savefile, O_CREAT | O_WRONLY | O_TRUNC, 0666);
d334 2
d340 2
d346 2
a347 4
		if (verbose)
			fprintf(ttyout, "Requesting %s (via %s)\n",
			    origline, proxyenv);
		fprintf(fin, "GET %s HTTP/1.0\r\n%s\r\n\r\n", path, HTTP_USER_AGENT);
d349 1
a349 2
		if (verbose)
			fprintf(ttyout, "Requesting %s\n", origline);
d353 4
a356 1
			/* strip off scoped address portion, since it's local to node */
d362 1
a362 13
			/*
			 * Send port number only if it's specified and does not equal
			 * 80. Some broken HTTP servers get confused if you explicitly
			 * send them the port number.
			 */
			if (port && strcmp(port, "80") != 0)
				fprintf(fin,
				    "GET /%s HTTP/1.0\r\nHost: [%s]:%s\r\n%s\r\n\r\n",
				    path, h, port, HTTP_USER_AGENT);
			else
				fprintf(fin,
				    "GET /%s HTTP/1.0\r\nHost: [%s]\r\n%s\r\n\r\n",
				    path, h, HTTP_USER_AGENT);
d364 14
a377 10
		} else {
			if (port && strcmp(port, "80") != 0)
				fprintf(fin,
				    "GET /%s HTTP/1.0\r\nHost: %s:%s\r\n%s\r\n\r\n",
				    path, host, port, HTTP_USER_AGENT);
			else
				fprintf(fin,
				    "GET /%s HTTP/1.0\r\nHost: %s\r\n%s\r\n\r\n",
				    path, host, HTTP_USER_AGENT);
		}
@


1.2
log
@rather than fixing
/usr/src/usr.bin/ftp/cmds.c:63: warning: 'rcsid' defined but not used
just convert to __RCSID() macro
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.49 2004/02/28 20:08:38 krw Exp $	*/
d68 1
a68 1
__RCSID("$MirOS$");
d86 1
a86 1
   "Extra `@@' characters in usernames and passwords should be encoded as %%40";
d90 2
d98 1
a98 4
url_get(origline, proxyenv, outfile)
	const char *origline;
	const char *proxyenv;
	const char *outfile;
d100 3
a103 6
	int error;
	int i, isftpurl, isfileurl, isredirect;
	volatile int s, out;
	size_t len;
	char *cp, *ep, *portnum, *path;
	char pbuf[NI_MAXSERV], hbuf[NI_MAXHOST];
d105 2
a106 3
	char *line, *host, *port, *buf;
	char * volatile proxy;
	char *hosttail;
d108 1
d110 1
a110 12
	char *cause = "unknown";
	FILE *fin;
	int rval;

	s = -1;
	proxy = NULL;
	fin = NULL;
	buf = NULL;
	isftpurl = 0;
	isfileurl = 0;
	isredirect = 0;
	rval = -1;
d404 4
d554 1
d556 1
a556 2
aborthttp(notused)
	int notused;
d568 1
d570 1
a570 2
abortfile(notused)
	int notused;
d594 1
a594 4
auto_fetch(argc, argv, outfile)
	int argc;
	char *argv[];
	char *outfile;
d598 1
a598 1
	char *user, *pass;
d640 1
d712 6
d864 1
a864 2
urldecode(str)
        const char *str;
d866 2
a867 24
        char *ret;
        char c;
        int i, reallen;

        if (str == NULL)
                return NULL;
        if ((ret = malloc(strlen(str)+1)) == NULL)
                err(1, "Can't allocate memory for URL decoding");
        for (i = 0, reallen = 0; str[i] != '\0'; i++, reallen++, ret++) {
                c = str[i];
                if (c == '+') {
                        *ret = ' ';
                        continue;
                }
                /* Can't use strtol here because next char after %xx may be
                 * a digit. */
                if (c == '%' && isxdigit(str[i+1]) && isxdigit(str[i+2])) {
                        *ret = hextochar(&str[i+1]);
                        i+=2;
                        continue;
                }
                *ret = c;
        }
        *ret = '\0';
d869 22
a890 1
        return ret-reallen;
d894 1
a894 2
hextochar(str)
        const char *str;
d896 9
a904 1
        char c, ret;
d906 7
a912 15
        c = str[0];
        ret = c;
        if (isalpha(c))
                ret -= isupper(c) ? 'A' - 10 : 'a' - 10;
        else
                ret -= '0';
        ret *= 16;

        c = str[1];
        ret += c;
        if (isalpha(c))
                ret -= isupper(c) ? 'A' - 10 : 'a' - 10;
        else
                ret -= '0';
        return ret;
d916 1
a916 2
isurl(p)
	const char *p;
@


1.1
log
@Initial revision
@
text
@a39 4
#if !defined(lint) && !defined(SMALL)
static char rcsid[] = "$OpenBSD: fetch.c,v 1.49 2004/02/28 20:08:38 krw Exp $";
#endif /* not lint and not SMALL */

a43 1
#include <sys/types.h>
d68 2
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@improve my Frankenstein OS (*wink* you know who you are) further
sans wchar_t of course

this is the essence of reading >1200 commit messages which suck
due to not having the new format of ours...
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.54 2005/04/21 05:17:21 fgsch Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.54 2005/04/21 05:17:21 fgsch Exp $";
d89 1
a89 1
    "Extra `@@' characters in usernames and passwords should be encoded as %%40";
a92 2
static int	redirect_loop;

d99 4
a102 1
url_get(const char *origline, const char *proxyenv, const char *outfile)
a103 3
	char pbuf[NI_MAXSERV], hbuf[NI_MAXHOST], *cp, *ep, *portnum, *path;
	char *hosttail, *cause = "unknown", *line, *host, *port, *buf = NULL;
	int error, i, isftpurl = 0, isfileurl = 0, isredirect = 0, rval = -1;
d105 6
d112 3
a114 2
	char * volatile proxy = NULL;
	volatile int s = -1, out;
a115 1
	FILE *fin = NULL;
d117 12
a128 1
	size_t len;
a421 4
		if (redirect_loop++ > 10) {
			warnx("Too many redirections requested");
			goto cleanup_url_get;
		}
a567 1
/* ARGSUSED */
d569 2
a570 1
aborthttp(int signo)
a581 1
/* ARGSUSED */
d583 2
a584 1
abortfile(int signo)
d608 4
a611 1
auto_fetch(int argc, char *argv[], char *outfile)
d615 1
a615 1
	char *user, *pass, *pathstart;
a656 1
			redirect_loop = 0;
a727 6
				pathstart = strchr(cp, '/');
				/* : in path is not a port # indicator */
				if (portnum && pathstart &&
				    pathstart < portnum)
					portnum = NULL;

d874 2
a875 1
urldecode(const char *str)
d877 24
a900 2
	char *ret, c;
	int i, reallen;
d902 1
a902 22
	if (str == NULL)
		return NULL;
	if ((ret = malloc(strlen(str)+1)) == NULL)
		err(1, "Can't allocate memory for URL decoding");
	for (i = 0, reallen = 0; str[i] != '\0'; i++, reallen++, ret++) {
		c = str[i];
		if (c == '+') {
			*ret = ' ';
			continue;
		}
		/* Can't use strtol here because next char after %xx may be
		 * a digit. */
		if (c == '%' && isxdigit(str[i+1]) && isxdigit(str[i+2])) {
			*ret = hextochar(&str[i+1]);
			i+=2;
			continue;
		}
		*ret = c;
	}
	*ret = '\0';

	return ret-reallen;
d906 2
a907 1
hextochar(const char *str)
d909 1
a909 9
	char c, ret;

	c = str[0];
	ret = c;
	if (isalpha(c))
		ret -= isupper(c) ? 'A' - 10 : 'a' - 10;
	else
		ret -= '0';
	ret *= 16;
d911 15
a925 7
	c = str[1];
	ret += c;
	if (isalpha(c))
		ret -= isupper(c) ? 'A' - 10 : 'a' - 10;
	else
		ret -= '0';
	return ret;
d929 2
a930 1
isurl(const char *p)
@


1.1.1.3
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.55 2005/07/18 02:55:59 fgsch Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.55 2005/07/18 02:55:59 fgsch Exp $";
d199 1
a199 2
			out = open(savefile, O_CREAT | O_WRONLY | O_TRUNC,
			    0666);
a335 2
	if (verbose)
		fprintf(ttyout, "Requesting %s", origline);
a339 2
		if (verbose)
			fprintf(ttyout, " (via %s)\n", proxyenv);
d344 4
a347 2
		fprintf(fin, "GET %s HTTP/1.0\r\n%s\r\n\r\n", path,
		    HTTP_USER_AGENT);
d349 2
a350 1
		fprintf(fin, "GET /%s HTTP/1.1\r\nHost: ", path);
d354 1
a354 4
			/*
			 * strip off scoped address portion, since it's
			 * local to node
			 */
d360 13
a372 1
			fprintf(fin, "[%s]", h);
d374 10
a383 14
		} else
			fprintf(fin, "%s", host);

		/*
		 * Send port number only if it's specified and does not equal
		 * 80. Some broken HTTP servers get confused if you explicitly
		 * send them the port number.
		 */
		if (port && strcmp(port, "80") != 0)
			fprintf(fin, ":%s", port);
		fprintf(fin, "\r\nConnection: close\r\n%s\r\n\r\n",
		    HTTP_USER_AGENT);
		if (verbose)
			fprintf(ttyout, "\n");
@


1.1.1.4
log
@Import OpenBSD 4.0's ftp(1) which downgraded to HTTP/1.0
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.68 2006/07/07 12:00:25 ray Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: fetch.c,v 1.68 2006/07/07 12:00:25 ray Exp $";
a60 1
#include <limits.h>
a64 1
#include <stdarg.h>
a70 7
#ifndef SMALL
#include <openssl/ssl.h>
#include <openssl/err.h>
#else
#define SSL void
#endif

a77 8
int		ftp_printf(FILE *, SSL *, const char *, ...) __attribute__((format(printf, 3, 4)));
char		*ftp_readline(FILE *, SSL *, size_t *);
size_t		ftp_read(FILE *, SSL *, char *, size_t);
#ifndef SMALL
int		proxy_connect(int, char *);
int		SSL_vprintf(SSL *, const char *, va_list);
char		*SSL_readline(SSL *, size_t *);
#endif
a80 1
#define	HTTPS_URL	"https://"	/* https URL prefix */
d103 2
a104 2
	char pbuf[NI_MAXSERV], hbuf[NI_MAXHOST], *cp, *portnum, *path;
	char *hosttail, *cause = "unknown", *newline, *host, *port, *buf = NULL;
d108 1
a108 1
	char * volatile proxyurl = NULL;
d113 1
a113 8
	const char *errstr;
	size_t len, wlen;
#ifndef SMALL
	char *sslpath = NULL, *sslhost = NULL;
	int ishttpsurl = 0;
	SSL_CTX *ssl_ctx = NULL;
#endif
	SSL *ssl = NULL;
d115 2
a116 2
	newline = strdup(origline);
	if (newline == NULL)
d118 4
a121 4
	if (strncasecmp(newline, HTTP_URL, sizeof(HTTP_URL) - 1) == 0)
		host = newline + sizeof(HTTP_URL) - 1;
	else if (strncasecmp(newline, FTP_URL, sizeof(FTP_URL) - 1) == 0) {
		host = newline + sizeof(FTP_URL) - 1;
d123 2
a124 2
	} else if (strncasecmp(newline, FILE_URL, sizeof(FILE_URL) - 1) == 0) {
		host = newline + sizeof(FILE_URL) - 1;
a125 5
#ifndef SMALL
	} else if (strncasecmp(newline, HTTPS_URL, sizeof(HTTPS_URL) - 1) == 0) {
		host = newline + sizeof(HTTPS_URL) - 1;
		ishttpsurl = 1;
#endif
d127 1
a127 1
		errx(1, "url_get: Invalid URL '%s'", newline);
d160 3
a162 11
	if (!isfileurl && proxyenv != NULL) {		/* use proxy */
#ifndef SMALL
		if (ishttpsurl) {
			sslpath = strdup(path);
			sslhost = strdup(host);
			if (! sslpath || ! sslhost)
				errx(1, "Can't allocate memory for https path/host.");
		}
#endif
		proxyurl = strdup(proxyenv);
		if (proxyurl == NULL)
d164 4
a167 4
		if (strncasecmp(proxyurl, HTTP_URL, sizeof(HTTP_URL) - 1) == 0)
			host = proxyurl + sizeof(HTTP_URL) - 1;
		else if (strncasecmp(proxyurl, FTP_URL, sizeof(FTP_URL) - 1) == 0)
			host = proxyurl + sizeof(FTP_URL) - 1;
d180 1
a180 1
		path = newline;
a280 3
#ifndef SMALL
	port = portnum ? portnum : (ishttpsurl ? httpsport : httpport);
#else
a281 1
#endif
a282 4
	/*
	 * If the services file is corrupt/missing, fall back
	 * on our hard-coded defines.
	 */
d284 4
a289 5
#ifndef SMALL
	} else if (error == EAI_SERVICE && port == httpsport) {
		snprintf(pbuf, sizeof(pbuf), "%d", HTTPS_PORT);
		error = getaddrinfo(host, pbuf, &hints, &res0);
#endif
a311 2
			int save_errno;

a313 1
			save_errno = errno;
a314 1
			errno = save_errno;
a326 4
#ifndef SMALL
		if (proxyenv && sslhost)
			proxy_connect(s, sslhost);
#endif
a334 28
#ifndef SMALL
	if (ishttpsurl) {
		if (proxyenv && sslpath) {
			ishttpsurl = 0;
			proxyurl = NULL;
			path = sslpath;
		}
		SSL_library_init();
		SSL_load_error_strings();
		SSLeay_add_ssl_algorithms();
		ssl_ctx = SSL_CTX_new(SSLv23_client_method());
		ssl = SSL_new(ssl_ctx);
		if (ssl == NULL || ssl_ctx == NULL) {
			ERR_print_errors_fp(ttyout);
			goto cleanup_url_get;
		}
		if (SSL_set_fd(ssl, s) == 0) {
			ERR_print_errors_fp(ttyout);
			goto cleanup_url_get;
		}
		if (SSL_connect(ssl) <= 0) {
			ERR_print_errors_fp(ttyout);
			goto cleanup_url_get;;
		}
	} else {
		fin = fdopen(s, "r+");
	}
#else
a335 1
#endif
d342 1
a342 1
	if (proxyurl) {
d349 1
a349 1
		ftp_printf(fin, ssl, "GET %s HTTP/1.0\r\n%s\r\n\r\n", path,
d352 1
a352 1
		ftp_printf(fin, ssl, "GET /%s HTTP/1.0\r\nHost: ", path);
d365 1
a365 1
			ftp_printf(fin, ssl, "[%s]", h);
d368 1
a368 1
			ftp_printf(fin, ssl, "%s", host);
a374 4
#ifndef SMALL
		if (port && strcmp(port, (ishttpsurl ? "443" : "80")) != 0)
			ftp_printf(fin, ssl, ":%s", port);
#else
d376 3
a378 3
			ftp_printf(fin, ssl, ":%s", port);
#endif
		ftp_printf(fin, ssl, "\r\n%s\r\n\r\n", HTTP_USER_AGENT);
d382 1
a382 1
	if (fin != NULL && fflush(fin) == EOF) {
d386 2
a387 1
	if ((buf = ftp_readline(fin, ssl, &len)) == NULL) {
d419 2
a420 2
	for (;;) {
		if ((buf = ftp_readline(fin, ssl, &len)) == NULL) {
a423 1

d436 2
a437 2
			filesize = strtonum(cp, 0, LLONG_MAX, &errstr);
			if (errstr != NULL)
d449 3
a451 2
			free(proxyurl);
			free(newline);
d453 2
a454 1
			free(buf);
d488 1
a488 3
	len = 1;
	while (len > 0) {
		len = ftp_read(fin, ssl, buf, 4096);
d490 2
a491 2
		for (cp = buf, wlen = len; wlen > 0; wlen -= i, cp += i) {
			if ((i = write(out, cp, wlen)) == -1) {
a538 6
#ifndef SMALL
	if (ssl) {
		SSL_shutdown(ssl);
		SSL_free(ssl);
	}
#endif
d543 5
a547 3
	free(buf);
	free(proxyurl);
	free(newline);
d597 2
a598 2
	char *cp, *url, *host, *dir, *file, *portnum;
	char *username, *pass, *pathstart;
d623 1
a623 1
	for (rval = 0; (rval == 0) && (argpos < argc); free(url), argpos++) {
d626 1
a626 1
		host = dir = file = portnum = username = pass = NULL;
d631 2
a632 2
		url = strdup(argv[argpos]);
		if (url == NULL)
d638 2
a639 6
		if (strncasecmp(url, HTTP_URL, sizeof(HTTP_URL) - 1) == 0 ||
#ifndef SMALL
		    /* even if we compiled without SSL, url_get will check */
		    strncasecmp(url, HTTPS_URL, sizeof(HTTPS_URL) -1) == 0 ||
#endif
		    strncasecmp(url, FILE_URL, sizeof(FILE_URL) - 1) == 0) {
d641 1
a641 1
			if (url_get(url, httpproxy, outfile) == -1)
d651 2
a652 2
		host = url;
		if (strncasecmp(url, FTP_URL, sizeof(FTP_URL) - 1) == 0) {
d656 1
a656 1
				if (url_get(url, ftpproxy, outfile) == -1)
d670 1
a670 1
				username = host;
d681 1
a681 1
				if (EMPTYSTRING(username) || EMPTYSTRING(pass)) {
d687 1
a687 1
				username = urldecode(username);
d767 1
a767 1
			    username, pass, host, portnum, dir, file);
d784 1
a784 1
		if (username != NULL)
d789 1
a789 1
		    ((connected == 1) && !ftp_login(host, username, pass))) {
d879 2
a880 4

		/* Cannot use strtol here because next char
		 * after %xx may be a digit.
		 */
a920 3
#ifndef SMALL
	    strncasecmp(p, HTTPS_URL, sizeof(HTTPS_URL) - 1) == 0 ||
#endif
a925 129

char *
ftp_readline(FILE *fp, SSL *ssl, size_t *lenp)
{
	if (fp != NULL)
		return fparseln(fp, lenp, NULL, "\0\0\0", 0);
#ifndef SMALL
	else if (ssl != NULL)
		return SSL_readline(ssl, lenp);
#endif
	else
		return NULL;
}

size_t
ftp_read(FILE *fp, SSL *ssl, char *buf, size_t len)
{
	size_t ret;
	if (fp != NULL)
		ret = fread(buf, sizeof(char), len, fp);
#ifndef SMALL
	else if (ssl != NULL) {
		int nr;

		if (len > INT_MAX)
			len = INT_MAX;
		if ((nr = SSL_read(ssl, buf, (int)len)) <= 0)
			ret = 0;
		else
			ret = nr;
	}
#endif
	else
		ret = 0;
	return (ret);
}

int
ftp_printf(FILE *fp, SSL *ssl, const char *fmt, ...)
{
	int ret;
	va_list ap;

	va_start(ap, fmt);

	if (fp != NULL)
		ret = vfprintf(fp, fmt, ap);
#ifndef SMALL
	else if (ssl != NULL)
		ret = SSL_vprintf((SSL*)ssl, fmt, ap);
#endif
	else
		ret = NULL;

	va_end(ap);
	return (ret);
}

#ifndef SMALL
int
SSL_vprintf(SSL *ssl, const char *fmt, va_list ap)
{
	int ret;
	char *string;

	if ((ret = vasprintf(&string, fmt, ap)) == -1)
		return ret;
	ret = SSL_write(ssl, string, ret);
	free(string);
	return ret;
}

char *
SSL_readline(SSL *ssl, size_t *lenp)
{
	size_t i, len;
	char *buf, *q, c;

	len = 128;
	if ((buf = malloc(len)) == NULL)
		errx(1, "Can't allocate memory for transfer buffer");
	for (i = 0; ; i++) {
		if (i >= len - 1) {
			if ((q = realloc(buf, 2 * len)) == NULL)
				errx(1, "Can't expand transfer buffer");
			buf = q;
			len *= 2;
		}
		if (SSL_read(ssl, &c, 1) <= 0)
			break;
		buf[i] = c;
		if (c == '\n')
			break;
	}
	*lenp = i;
	return (buf);
}

int
proxy_connect(int socket, char *host)
{
	int l;
	char buf[1024];
	char *connstr, *hosttail, *port;

	if (*host == '[' && (hosttail = strrchr(host, ']')) != NULL &&
		(hosttail[1] == '\0' || hosttail[1] == ':')) {
		host++;
		*hosttail++ = '\0';
	} else
		hosttail = host;

	port = strrchr(hosttail, ':');               /* find portnum */
	if (port != NULL)
		*port++ = '\0';
	if (!port)
		port = "443";

	l = asprintf(&connstr, "CONNECT %s:%s HTTP/1.1\n\n", host, port);
	if (l == -1)
		errx(1, "Could not allocate memory to assemble connect string!");
	if (debug)
		printf("%s", connstr);
	if (write(socket, connstr, l) != l)
		err(1, "Could not send connect string");
	read(socket, &buf, sizeof(buf)); /* only proxy header XXX: error handling? */
	return(200);
}
#endif
@


1.1.1.5
log
@the FTP on-the wire protocol must die, but we nevertheless could use -k
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.74 2007/06/13 13:52:26 pyr Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: fetch.c,v 1.74 2007/06/13 13:52:26 pyr Exp $";
a71 1
#include <resolv.h>
a102 1
#define COOKIE_MAX_LEN	42
d121 1
a121 1
	char pbuf[NI_MAXSERV], hbuf[NI_MAXHOST], *cp, *portnum, *path, ststr[4];
a126 1
	char *cookie = NULL;
a138 1
	int status;
a216 4
			*path++ = '\0';		/* i guess this ++ is useless */

		path = strchr(host, '@@');	/* look for credentials in proxy */
		if (!EMPTYSTRING(path)) {
a217 17
			cookie = strchr(host, ':');
			if (EMPTYSTRING(cookie)) {
				warnx("Malformed proxy URL: %s", proxyenv);
				goto cleanup_url_get;
			}
			cookie  = malloc(COOKIE_MAX_LEN);
			b64_ntop(host, strlen(host), cookie, COOKIE_MAX_LEN);
			/*
			 * This removes the password from proxyenv,
			 * filling with stars
			 */
			for (host = strchr(proxyenv + 5, ':');  *host != '@@';
			     host++)
				*host = '*';

			host = path;
		}
d412 1
a412 1
			goto cleanup_url_get;
a425 3
#ifndef SMALL
	cookie_get(host, path, ishttpsurl, &buf);
#endif
d433 2
a434 8
		if (cookie)
			ftp_printf(fin, ssl, "GET %s HTTP/1.0\r\n"
			    "Proxy-Authorization: Basic %s%s\r\n%s\r\n\r\n",
			    path, cookie, buf ? buf : "", HTTP_USER_AGENT);
		else
			ftp_printf(fin, ssl, "GET %s HTTP/1.0\r\n%s%s\r\n\r\n",
			    path, buf ? buf : "", HTTP_USER_AGENT);

d466 1
a466 2
		ftp_printf(fin, ssl, "\r\n%s%s\r\n\r\n",
		    buf ? buf : "", HTTP_USER_AGENT);
a469 7


#ifndef SMALL
	free(buf);
#endif
	buf = NULL;

d489 1
a489 15

	strlcpy(ststr, cp, sizeof(ststr));
	status = strtonum(ststr, 200, 307, &errstr);
	if (errstr) {
		warnx("Error retrieving file: %s", cp);
		goto cleanup_url_get;
	}

	switch (status) {
	case 200:	/* OK */
		break;
	case 301:	/* Moved Permanently */
	case 302:	/* Found */
	case 303:	/* See Other */
	case 307:	/* Temporary Redirect */
d495 1
a495 2
		break;
	default:
a1152 1
	free(connstr);
@


