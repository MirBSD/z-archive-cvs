head	1.6;
access;
symbols
	MIRBSD_10:1.5.0.2
	MIRBSD_10_BASE:1.5
	cvs-200707151930:1.1.1.4
	OPENBSD_4_0:1.1.1.3
	MIRBSD_9_BASE:1.3
	MIRBSD_8:1.3.0.2
	MIRBSD_8_BASE:1.3
	cvs-200507211800:1.1.1.2
	cvs-200504291700:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2013.09.15.11.01.29;	author tg;	state Exp;
branches;
next	1.5;
commitid	1005235938A2629E92C;

1.5
date	2007.07.15.20.01.09;	author tg;	state Exp;
branches;
next	1.4;
commitid	100469A7CFC300FC2D9;

1.4
date	2006.10.03.19.22.18;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004522B87E42B315D1;

1.3
date	2005.04.29.18.35.09;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.15.18.44.52;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.29.34;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.29.34;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.29.17.06.05;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.10.03.19.10.03;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	1004522B592570E1901;

1.1.1.4
date	2007.07.15.19.51.38;	author tg;	state Exp;
branches;
next	;
commitid	100469A7AC943312E80;


desc
@@


1.6
log
@we can build SPARC again, but only with a tad more floppy squeezing
@
text
@/*	$OpenBSD: util.c,v 1.46 2007/06/06 19:15:33 pyr Exp $	*/
/*	$NetBSD: util.c,v 1.12 1997/08/18 10:20:27 lukem Exp $	*/

/*-
 * Copyright (c) 1997-1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Luke Mewburn.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1985, 1989, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * FTP User Program -- Misc support routines
 */
#include <sys/ioctl.h>
#include <sys/time.h>
#include <arpa/ftp.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <libgen.h>
#include <limits.h>
#include <glob.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <tzfile.h>
#include <unistd.h>

#include "ftp_var.h"
#include "pathnames.h"

__RCSID("$MirOS: src/usr.bin/ftp/util.c,v 1.5 2007/07/15 20:01:09 tg Exp $");

static void updateprogressmeter(int);

/*
 * Connect to peer server and
 * auto-login, if possible.
 */
void
setpeer(int argc, char *argv[])
{
	char *host, *port;

	if (connected) {
		fprintf(ttyout, "Already connected to %s, use close first.\n",
		    hostname);
		code = -1;
		return;
	}
	if (argc < 2)
		(void)another(&argc, &argv, "to");
	if (argc < 2 || argc > 3) {
		fprintf(ttyout, "usage: %s host-name [port]\n", argv[0]);
		code = -1;
		return;
	}
	if (gatemode)
		port = gateport;
	else
		port = ftpport;
#if 0
	if (argc > 2) {
		char *ep;
		long nport;

		nport = strtol(argv[2], &ep, 10);
		if (nport < 1 || nport > USHRT_MAX || *ep != '\0') {
			fprintf(ttyout, "%s: bad port number '%s'.\n",
			    argv[1], argv[2]);
			fprintf(ttyout, "usage: %s host-name [port]\n",
			    argv[0]);
			code = -1;
			return;
		}
		port = htons((in_port_t)nport);
	}
#else
	if (argc > 2)
		port = argv[2];
#endif

	if (gatemode) {
		if (gateserver == NULL || *gateserver == '\0')
			errx(1, "gateserver not defined (shouldn't happen)");
		host = hookup(gateserver, port);
	} else
		host = hookup(argv[1], port);

	if (host) {
		int overbose;

		if (gatemode) {
			if (command("PASSERVE %s", argv[1]) != COMPLETE)
				return;
			if (verbose)
				fprintf(ttyout,
				    "Connected via pass-through server %s\n",
				    gateserver);
		}

		connected = 1;
		/*
		 * Set up defaults for FTP.
		 */
		(void)strlcpy(formname, "non-print", sizeof formname);
		form = FORM_N;
		(void)strlcpy(modename, "stream", sizeof modename);
		mode = MODE_S;
		(void)strlcpy(structname, "file", sizeof structname);
		stru = STRU_F;
		(void)strlcpy(bytename, "8", sizeof bytename);
		bytesize = 8;

		/*
		 * Set type to 0 (not specified by user),
		 * meaning binary by default, but don't bother
		 * telling server.  We can use binary
		 * for text files unless changed by the user.
		 */
		(void)strlcpy(typename, "binary", sizeof typename);
		curtype = TYPE_A;
		type = 0;
		if (autologin)
			(void)ftp_login(argv[1], NULL, NULL);

#if (defined(unix) || defined(BSD)) && NBBY == 8
/*
 * this ifdef is to keep someone form "porting" this to an incompatible
 * system and not checking this out. This way they have to think about it.
 */
		overbose = verbose;
		if (debug == 0)
			verbose = -1;
		if (command("SYST") == COMPLETE && overbose) {
			char *cp, c;
			c = 0;
			cp = strchr(reply_string + 4, ' ');
			if (cp == NULL)
				cp = strchr(reply_string + 4, '\r');
			if (cp) {
				if (cp[-1] == '.')
					cp--;
				c = *cp;
				*cp = '\0';
			}

			fprintf(ttyout, "Remote system type is %s.\n", reply_string + 4);
			if (cp)
				*cp = c;
		}
		if (!strncmp(reply_string, "215 UNIX Type: L8", 17)) {
			if (proxy)
				unix_proxy = 1;
			else
				unix_server = 1;
			if (overbose)
				fprintf(ttyout, "Using %s mode to transfer files.\n",
				    typename);
		} else {
			if (proxy)
				unix_proxy = 0;
			else
				unix_server = 0;
#ifndef SMALL
			if (overbose &&
			    !strncmp(reply_string, "215 TOPS20", 10))
				fputs(
"Remember to set tenex mode when transferring binary files from this machine.\n",
				    ttyout);
#endif /* !SMALL */
		}
		verbose = overbose;
#endif /* unix || BSD */
	}
}

/*
 * login to remote host, using given username & password if supplied
 */
int
ftp_login(const char *host, char *user, char *pass)
{
	char tmp[80], *acctname = NULL, host_name[MAXHOSTNAMELEN];
	char anonpass[MAXLOGNAME + 1 + MAXHOSTNAMELEN];	/* "user@@hostname" */
	int n, aflag = 0, retry = 0;
	struct passwd *pw;

#ifndef SMALL
	if (user == NULL) {
		if (ruserpass(host, &user, &pass, &acctname) < 0) {
			code = -1;
			return (0);
		}
	}
#endif

	/*
	 * Set up arguments for an anonymous FTP session, if necessary.
	 */
	if ((user == NULL || pass == NULL) && anonftp) {
		memset(anonpass, 0, sizeof(anonpass));
		memset(host_name, 0, sizeof(host_name));

		/*
		 * Set up anonymous login password.
		 */
		if ((user = getlogin()) == NULL) {
			if ((pw = getpwuid(getuid())) == NULL)
				user = "anonymous";
			else
				user = pw->pw_name;
		}
		gethostname(host_name, sizeof(host_name));
#ifndef DONT_CHEAT_ANONPASS
		/*
		 * Every anonymous FTP server I've encountered
		 * will accept the string "username@@", and will
		 * append the hostname itself.  We do this by default
		 * since many servers are picky about not having
		 * a FQDN in the anonymous password. - thorpej@@netbsd.org
		 */
		snprintf(anonpass, sizeof(anonpass) - 1, "%s@@",
		    user);
#else
		snprintf(anonpass, sizeof(anonpass) - 1, "%s@@%s",
		    user, hp->h_name);
#endif
		pass = anonpass;
		user = "anonymous";	/* as per RFC 1635 */
	}

tryagain:
	if (retry)
		user = "ftp";		/* some servers only allow "ftp" */

	while (user == NULL) {
		char *myname = getlogin();

		if (myname == NULL && (pw = getpwuid(getuid())) != NULL)
			myname = pw->pw_name;
		if (myname)
			fprintf(ttyout, "Name (%s:%s): ", host, myname);
		else
			fprintf(ttyout, "Name (%s): ", host);
		user = myname;
		if (fgets(tmp, sizeof(tmp), stdin) != NULL) {
			char *p;

			if ((p = strchr(tmp, '\n')) != NULL)
				*p = '\0';
			if (tmp[0] != '\0')
				user = tmp;
		}
	}
	n = command("USER %s", user);
	if (n == CONTINUE) {
		if (pass == NULL)
			pass = getpass("Password:");
		n = command("PASS %s", pass);
	}
	if (n == CONTINUE) {
		aflag++;
		if (acctname == NULL)
			acctname = getpass("Account:");
		n = command("ACCT %s", acctname);
	}
	if ((n != COMPLETE) ||
	    (!aflag && acctname != NULL && command("ACCT %s", acctname) != COMPLETE)) {
		warnx("Login failed.");
		if (retry || !anonftp)
			return (0);
		else
			retry = 1;
		goto tryagain;
	}
	if (proxy)
		return (1);
	connected = -1;
	for (n = 0; n < macnum; ++n) {
		if (!strcmp("init", macros[n].mac_name)) {
			(void)strlcpy(line, "$init", sizeof line);
			makeargv();
			domacro(margc, margv);
			break;
		}
	}
	return (1);
}

/*
 * `another' gets another argument, and stores the new argc and argv.
 * It reverts to the top level (via main.c's intr()) on EOF/error.
 *
 * Returns false if no new arguments have been added.
 */
int
another(int *pargc, char ***pargv, const char *prompt)
{
	int len = strlen(line), ret;

	if (len >= sizeof(line) - 3) {
		fputs("sorry, arguments too long.\n", ttyout);
		intr();
	}
	fprintf(ttyout, "(%s) ", prompt);
	line[len++] = ' ';
	if (fgets(&line[len], (int)(sizeof(line) - len), stdin) == NULL)
		intr();
	len += strlen(&line[len]);
	if (len > 0 && line[len - 1] == '\n')
		line[len - 1] = '\0';
	makeargv();
	ret = margc > *pargc;
	*pargc = margc;
	*pargv = margv;
	return (ret);
}

/*
 * glob files given in argv[] from the remote server.
 * if errbuf isn't NULL, store error messages there instead
 * of writing to the screen.
 */
char *
remglob(char *argv[], int doswitch, char **errbuf)
{
	char temp[MAXPATHLEN], *cp, *lmode;
	static char buf[MAXPATHLEN], **args;
	static FILE *ftemp = NULL;
	int oldverbose, oldhash, fd;

	if (!mflag) {
		if (!doglob)
			args = NULL;
		else {
			if (ftemp) {
				(void)fclose(ftemp);
				ftemp = NULL;
			}
		}
		return (NULL);
	}
	if (!doglob) {
		if (args == NULL)
			args = argv;
		if ((cp = *++args) == NULL)
			args = NULL;
		return (cp);
	}
	if (ftemp == NULL) {
		int len;

		if ((cp = getenv("TMPDIR")) == NULL || *cp == '\0')
		    cp = _PATH_TMP;
		len = strlen(cp);
		if (len + sizeof(TMPFILE) + (cp[len-1] != '/') > sizeof(temp)) {
			warnx("unable to create temporary file: %s",
			    strerror(ENAMETOOLONG));
			return (NULL);
		}

		(void)strlcpy(temp, cp, sizeof temp);
		if (temp[len-1] != '/')
			temp[len++] = '/';
		(void)strlcpy(&temp[len], TMPFILE, sizeof temp - len);
		if ((fd = mkstemp(temp)) < 0) {
			warn("unable to create temporary file %s", temp);
			return (NULL);
		}
		close(fd);
		oldverbose = verbose;
		verbose = (errbuf != NULL) ? -1 : 0;
		oldhash = hash;
		hash = 0;
		if (doswitch)
			pswitch(!proxy);
		for (lmode = "w"; *++argv != NULL; lmode = "a")
			recvrequest("NLST", temp, *argv, lmode, 0, 0);
		if ((code / 100) != COMPLETE) {
			if (errbuf != NULL)
				*errbuf = reply_string;
		}
		if (doswitch)
			pswitch(!proxy);
		verbose = oldverbose;
		hash = oldhash;
		ftemp = fopen(temp, "r");
		(void)unlink(temp);
		if (ftemp == NULL) {
			if (errbuf == NULL)
				fputs("can't find list of remote files, oops.\n",
				    ttyout);
			else
				*errbuf =
				    "can't find list of remote files, oops.";
			return (NULL);
		}
	}
	if (fgets(buf, sizeof(buf), ftemp) == NULL) {
		(void)fclose(ftemp);
		ftemp = NULL;
		return (NULL);
	}
	if ((cp = strchr(buf, '\n')) != NULL)
		*cp = '\0';
	return (buf);
}

int
confirm(const char *cmd, const char *file)
{
	char str[BUFSIZ];

	if (!interactive || confirmrest)
		return (1);
top:
	fprintf(ttyout, "%s %s? ", cmd, file);
	(void)fflush(ttyout);
	if (fgets(str, sizeof(str), stdin) == NULL)
		return (0);
	switch (tolower(*str)) {
		case 'n':
			return (0);
		case 'p':
			interactive = 0;
			fputs("Interactive mode: off.\n", ttyout);
			break;
		case 'a':
			confirmrest = 1;
			fprintf(ttyout, "Prompting off for duration of %s.\n", cmd);
			break;
		case 'y':
			return(1);
			break;
		default:
			fprintf(ttyout, "n, y, p, a, are the only acceptable commands!\n");
			goto top;
			break;
	}
	return (1);
}

/*
 * Glob a local file name specification with
 * the expectation of a single return value.
 * Can't control multiple values being expanded
 * from the expression, we return only the first.
 */
int
globulize(char **cpp)
{
	glob_t gl;
	int flags;

	if (!doglob)
		return (1);

	flags = GLOB_BRACE|GLOB_NOCHECK|GLOB_QUOTE|GLOB_TILDE;
	memset(&gl, 0, sizeof(gl));
	if (glob(*cpp, flags, NULL, &gl) ||
	    gl.gl_pathc == 0) {
		warnx("%s: not found", *cpp);
		globfree(&gl);
		return (0);
	}
		/* XXX: caller should check if *cpp changed, and
		 *	free(*cpp) if that is the case
		 */
	*cpp = strdup(gl.gl_pathv[0]);
	if (*cpp == NULL)
		err(1, NULL);
	globfree(&gl);
	return (1);
}

/*
 * determine size of remote file
 */
off_t
remotesize(const char *file, int noisy)
{
	int overbose;
	off_t size;

	overbose = verbose;
	size = -1;
	if (debug == 0)
		verbose = -1;
	if (command("SIZE %s", file) == COMPLETE) {
		char *cp, *ep;

		cp = strchr(reply_string, ' ');
		if (cp != NULL) {
			cp++;
			size = strtoq(cp, &ep, 10);
			if (*ep != '\0' && !isspace(*ep))
				size = -1;
		}
	} else if (noisy && debug == 0) {
		fputs(reply_string, ttyout);
		fputc('\n', ttyout);
	}
	verbose = overbose;
	return (size);
}

/*
 * determine last modification time (in GMT) of remote file
 */
time_t
remotemodtime(const char *file, int noisy)
{
	int overbose;
	time_t rtime;
	int ocode;

	overbose = verbose;
	ocode = code;
	rtime = -1;
	if (debug == 0)
		verbose = -1;
	if (command("MDTM %s", file) == COMPLETE) {
		struct tm timebuf;
		int yy, mo, day, hour, min, sec;
 		/*
 		 * time-val = 14DIGIT [ "." 1*DIGIT ]
 		 *		YYYYMMDDHHMMSS[.sss]
 		 * mdtm-response = "213" SP time-val CRLF / error-response
 		 */
		/* TODO: parse .sss as well, use timespecs. */
		char *timestr = reply_string;

		/* Repair `19%02d' bug on server side */
		while (!isspace(*timestr))
			timestr++;
		while (isspace(*timestr))
			timestr++;
		if (strncmp(timestr, "191", 3) == 0) {
 			fprintf(ttyout,
 	    "Y2K warning! Fixed incorrect time-val received from server.\n");
	    		timestr[0] = ' ';
			timestr[1] = '2';
			timestr[2] = '0';
		}
		sscanf(reply_string, "%*s %04d%02d%02d%02d%02d%02d", &yy, &mo,
			&day, &hour, &min, &sec);
		memset(&timebuf, 0, sizeof(timebuf));
		timebuf.tm_sec = sec;
		timebuf.tm_min = min;
		timebuf.tm_hour = hour;
		timebuf.tm_mday = day;
		timebuf.tm_mon = mo - 1;
		timebuf.tm_year = yy - TM_YEAR_BASE;
		timebuf.tm_isdst = -1;
		rtime = mktime(&timebuf);
		if (rtime == -1 && (noisy || debug != 0))
			fprintf(ttyout, "Can't convert %s to a time.\n", reply_string);
		else
			rtime += timebuf.tm_gmtoff;	/* conv. local -> GMT */
	} else if (noisy && debug == 0) {
		fputs(reply_string, ttyout);
		fputc('\n', ttyout);
	}
	verbose = overbose;
	if (rtime == -1)
		code = ocode;
	return (rtime);
}

/*
 * Ensure file is in or under dir.
 * Returns 1 if so, 0 if not (or an error occurred).
 */
int
fileindir(const char *file, const char *dir)
{
	char	parentdirbuf[MAXPATHLEN], *parentdir;
	char	realdir[MAXPATHLEN];
	size_t	dirlen;

		 			/* determine parent directory of file */
	(void)strlcpy(parentdirbuf, file, sizeof(parentdirbuf));
	parentdir = dirname(parentdirbuf);
	if (strcmp(parentdir, ".") == 0)
		return 1;		/* current directory is ok */

					/* find the directory */
	if (realpath(parentdir, realdir) == NULL) {
		warn("Unable to determine real path of `%s'", parentdir);
		return 0;
	}
	if (realdir[0] != '/')		/* relative result is ok */
		return 1;

	dirlen = strlen(dir);
	if (strncmp(realdir, dir, dirlen) == 0 &&
	    (realdir[dirlen] == '/' || realdir[dirlen] == '\0'))
		return 1;
	return 0;
}


/*
 * Returns true if this is the controlling/foreground process, else false.
 */
int
foregroundproc(void)
{
	static pid_t pgrp = -1;
	int ctty_pgrp;

	if (pgrp == -1)
		pgrp = getpgrp();

	return((ioctl(STDOUT_FILENO, TIOCGPGRP, &ctty_pgrp) != -1 &&
	    ctty_pgrp == pgrp));
}

/* ARGSUSED */
static void
updateprogressmeter(int signo)
{
	int save_errno = errno;

	/* update progressmeter if foreground process or in -m mode */
	if (foregroundproc() || progress == -1)
		progressmeter(0);
	errno = save_errno;
}

/*
 * Display a transfer progress bar if progress is non-zero.
 * SIGALRM is hijacked for use by this function.
 * - Before the transfer, set filesize to size of file (or -1 if unknown),
 *   and call with flag = -1. This starts the once per second timer,
 *   and a call to updateprogressmeter() upon SIGALRM.
 * - During the transfer, updateprogressmeter will call progressmeter
 *   with flag = 0
 * - After the transfer, call with flag = 1
 */
static struct timeval start;

void
progressmeter(int flag)
{
	/*
	 * List of order of magnitude prefixes.
	 * The last is `P', as 2^64 = 16384 Petabytes
	 */
	static const char prefixes[] = " KMGTP";

	static struct timeval lastupdate;
	static off_t lastsize;
	struct timeval now, td, wait;
	off_t cursize, abbrevsize;
	double elapsed;
	int ratio, barlength, i, remaining;
	char buf[512];

	if (flag == -1) {
		(void)gettimeofday(&start, (struct timezone *)0);
		lastupdate = start;
		lastsize = restart_point;
	}
	(void)gettimeofday(&now, (struct timezone *)0);
	if (!progress || filesize < 0)
		return;
	cursize = bytes + restart_point;

	if (filesize)
		ratio = cursize * 100 / filesize;
	else
		ratio = 100;
	ratio = MAX(ratio, 0);
	ratio = MIN(ratio, 100);
	snprintf(buf, sizeof(buf), "\r%3d%% ", ratio);

	barlength = ttywidth - 30;
	if (barlength > 0) {
		i = barlength * ratio / 100;
		snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
		    "|%.*s%*s|", i, 
		    "*******************************************************"
		    "*******************************************************"
		    "*******************************************************"
		    "*******************************************************"
		    "*******************************************************"
		    "*******************************************************"
		    "*******************************************************",
		    barlength - i, "");
	}

	i = 0;
	abbrevsize = cursize;
	while (abbrevsize >= 100000 && i < sizeof(prefixes)) {
		i++;
		abbrevsize >>= 10;
	}
	snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
	    " %5lld %c%c ", (long long)abbrevsize, prefixes[i],
	    prefixes[i] == ' ' ? ' ' : 'B');

	timersub(&now, &lastupdate, &wait);
	if (cursize > lastsize) {
		lastupdate = now;
		lastsize = cursize;
		if (wait.tv_sec >= STALLTIME) {	/* fudge out stalled time */
			start.tv_sec += wait.tv_sec;
			start.tv_usec += wait.tv_usec;
		}
		wait.tv_sec = 0;
	}

	timersub(&now, &start, &td);
	elapsed = td.tv_sec + (td.tv_usec / 1000000.0);

	if (flag == 1) {
		i = (int)elapsed / 3600;
		if (i)
			snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
			    "%2d:", i);
		else
			snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
			    "   ");
		i = (int)elapsed % 3600;
		snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
		    "%02d:%02d    ", i / 60, i % 60);
	} else if (bytes <= 0 || elapsed <= 0.0 || cursize > filesize) {
		snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
		    "   --:-- ETA");
	} else if (wait.tv_sec >= STALLTIME) {
		snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
		    " - stalled -");
	} else {
		remaining = (int)((filesize - restart_point) /
				  (bytes / elapsed) - elapsed);
		i = remaining / 3600;
		if (i)
			snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
			    "%2d:", i);
		else
			snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
			    "   ");
		i = remaining % 3600;
		snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
		    "%02d:%02d ETA", i / 60, i % 60);
	}
	(void)write(fileno(ttyout), buf, strlen(buf));

	if (flag == -1) {
		(void)signal(SIGALRM, updateprogressmeter);
		alarmtimer(1);		/* set alarm timer for 1 Hz */
	} else if (flag == 1) {
		alarmtimer(0);
		(void)putc('\n', ttyout);
	}
	fflush(ttyout);
}

/*
 * Display transfer statistics.
 * Requires start to be initialised by progressmeter(-1),
 * direction to be defined by xfer routines, and filesize and bytes
 * to be updated by xfer routines
 * If siginfo is nonzero, an ETA is displayed, and the output goes to STDERR
 * instead of TTYOUT.
 */
void
ptransfer(int siginfo)
{
	struct timeval now, td;
	double elapsed;
	off_t bs;
	int meg, remaining, hh;
	char buf[100];

	if (!verbose && !siginfo)
		return;

	(void)gettimeofday(&now, (struct timezone *)0);
	timersub(&now, &start, &td);
	elapsed = td.tv_sec + (td.tv_usec / 1000000.0);
	bs = bytes / (elapsed == 0.0 ? 1 : elapsed);
	meg = 0;
	if (bs > (1024 * 1024))
		meg = 1;
	(void)snprintf(buf, sizeof(buf),
	    "%lld byte%s %s in %.2f seconds (%.2f %sB/s)\n",
	    (long long)bytes, bytes == 1 ? "" : "s", direction, elapsed,
	    bs / (1024.0 * (meg ? 1024.0 : 1.0)), meg ? "M" : "K");
	if (siginfo && bytes > 0 && elapsed > 0.0 && filesize >= 0
	    && bytes + restart_point <= filesize) {
		remaining = (int)((filesize - restart_point) /
				  (bytes / elapsed) - elapsed);
		hh = remaining / 3600;
		remaining %= 3600;
			/* "buf+len(buf) -1" to overwrite \n */
		snprintf(buf + strlen(buf) - 1, sizeof(buf) - strlen(buf),
		    "  ETA: %02d:%02d:%02d\n", hh, remaining / 60,
		    remaining % 60);
	}
	(void)write(siginfo ? STDERR_FILENO : fileno(ttyout), buf, strlen(buf));
}

/*
 * List words in stringlist, vertically arranged
 */
void
list_vertical(StringList *sl)
{
	int i, j, w;
	int columns, width, lines;
	char *p;

	width = 0;

	for (i = 0 ; i < sl->sl_cur ; i++) {
		w = strlen(sl->sl_str[i]);
		if (w > width)
			width = w;
	}
	width = (width + 8) &~ 7;

	columns = ttywidth / width;
	if (columns == 0)
		columns = 1;
	lines = (sl->sl_cur + columns - 1) / columns;
	for (i = 0; i < lines; i++) {
		for (j = 0; j < columns; j++) {
			p = sl->sl_str[j * lines + i];
			if (p)
				fputs(p, ttyout);
			if (j * lines + i + lines >= sl->sl_cur) {
				putc('\n', ttyout);
				break;
			}
			w = strlen(p);
			while (w < width) {
				w = (w + 8) &~ 7;
				(void)putc('\t', ttyout);
			}
		}
	}
}

/*
 * Update the global ttywidth value, using TIOCGWINSZ.
 */
/* ARGSUSED */
void
setttywidth(int signo)
{
	int save_errno = errno;
	struct winsize winsize;

	if (ioctl(fileno(ttyout), TIOCGWINSZ, &winsize) != -1)
		ttywidth = winsize.ws_col ? winsize.ws_col : 80;
	else
		ttywidth = 80;
	errno = save_errno;
}

/*
 * Set the SIGALRM interval timer for wait seconds, 0 to disable.
 */
void
alarmtimer(int wait)
{
	struct itimerval itv;

	itv.it_value.tv_sec = wait;
	itv.it_value.tv_usec = 0;
	itv.it_interval = itv.it_value;
	setitimer(ITIMER_REAL, &itv, NULL);
}

/*
 * Setup or cleanup EditLine structures
 */
#ifndef SMALL
void
controlediting(void)
{
	HistEvent hev;

	if (editing && el == NULL && hist == NULL) {
		el = el_init(__progname, stdin, ttyout, stderr); /* init editline */
		hist = history_init();		/* init the builtin history */
		history(hist, &hev, H_SETSIZE, 100);	/* remember 100 events */
		el_set(el, EL_HIST, history, hist);	/* use history */

		el_set(el, EL_EDITOR, "emacs");	/* default editor is emacs */
		el_set(el, EL_PROMPT, prompt);	/* set the prompt function */

		/* add local file completion, bind to TAB */
		el_set(el, EL_ADDFN, "ftp-complete",
		    "Context sensitive argument completion",
		    complete);
		el_set(el, EL_BIND, "^I", "ftp-complete", NULL);

		el_source(el, NULL);	/* read ~/.editrc */
		el_set(el, EL_SIGNAL, 1);
	} else if (!editing) {
		if (hist) {
			history_end(hist);
			hist = NULL;
		}
		if (el) {
			el_end(el);
			el = NULL;
		}
	}
}
#endif /* !SMALL */
@


1.5
log
@fastmerge and fix their bugs (tree breaker, but they don't seem to care,
it's been broken for 25 daysâ€¦)
@
text
@d99 1
a99 1
__RCSID("$MirOS: src/usr.bin/ftp/util.c,v 1.4 2006/10/03 19:22:18 tg Exp $");
d232 1
d238 1
@


1.4
log
@merge
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.43 2006/05/16 23:43:16 ray Exp $	*/
d99 1
a99 1
__RCSID("$MirOS: src/usr.bin/ftp/util.c,v 1.3 2005/04/29 18:35:09 tg Exp $");
d254 1
d261 1
d311 9
a319 7
		*tmp = '\0';
		(void)fgets(tmp, sizeof(tmp) - 1, stdin);
		tmp[strlen(tmp) - 1] = '\0';
		if (*tmp == '\0')
			user = myname;
		else
			user = tmp;
@


1.3
log
@(tentative) merge, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.40 2005/04/11 15:16:50 deraadt Exp $	*/
d84 1
d99 1
a99 1
__RCSID("$MirOS: src/usr.bin/ftp/util.c,v 1.2 2005/03/15 18:44:52 tg Exp $");
d249 1
a249 1
	char tmp[80], *acct = NULL, hostname[MAXHOSTNAMELEN];
d255 1
a255 1
		if (ruserpass(host, &user, &pass, &acct) < 0) {
d266 1
a266 1
		memset(hostname, 0, sizeof(hostname));
d277 1
a277 1
		gethostname(hostname, sizeof(hostname));
d325 3
a327 3
		if (acct == NULL)
			acct = getpass("Account:");
		n = command("ACCT %s", acct);
d330 1
a330 1
	    (!aflag && acct != NULL && command("ACCT %s", acct) != COMPLETE)) {
d389 1
a389 1
	char temp[MAXPATHLEN], *cp, *mode;
d439 2
a440 2
		for (mode = "w"; *++argv != NULL; mode = "a")
			recvrequest("NLST", temp, *argv, mode, 0, 0);
d474 1
a474 1
	char line[BUFSIZ];
d481 1
a481 1
	if (fgets(line, sizeof(line), stdin) == NULL)
d483 1
a483 1
	switch (tolower(*line)) {
d633 33
@


1.2
log
@rather than fixing
/usr/src/usr.bin/ftp/cmds.c:63: warning: 'rcsid' defined but not used
just convert to __RCSID() macro
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.37 2003/12/16 21:46:22 deraadt Exp $	*/
d98 1
a98 1
__RCSID("$MirOS$");
d107 1
a107 3
setpeer(argc, argv)
	int argc;
	char *argv[];
d109 1
a109 2
	char *host;
	char *port;
d246 1
a246 3
ftp_login(host, user, pass)
	const char *host;
	char *user, *pass;
d248 1
a248 2
	char tmp[80];
	char *acct;
d250 1
a250 1
	char hostname[MAXHOSTNAMELEN];
a251 1
	int n, aflag = 0, retry = 0;
a252 1
	acct = NULL;
d358 1
a358 4
another(pargc, pargv, prompt)
	int *pargc;
	char ***pargv;
	const char *prompt;
d386 26
a411 31
remglob(argv, doswitch, errbuf)
        char *argv[];
        int doswitch;
	char **errbuf;
{
        char temp[MAXPATHLEN];
        static char buf[MAXPATHLEN];
        static FILE *ftemp = NULL;
        static char **args;
        int oldverbose, oldhash, fd;
        char *cp, *mode;

        if (!mflag) {
                if (!doglob)
                        args = NULL;
                else {
                        if (ftemp) {
                                (void)fclose(ftemp);
                                ftemp = NULL;
                        }
                }
                return (NULL);
        }
        if (!doglob) {
                if (args == NULL)
                        args = argv;
                if ((cp = *++args) == NULL)
                        args = NULL;
                return (cp);
        }
        if (ftemp == NULL) {
d427 5
a431 5
                if ((fd = mkstemp(temp)) < 0) {
                        warn("unable to create temporary file %s", temp);
                        return (NULL);
                }
                close(fd);
d436 4
a439 4
                if (doswitch)
                        pswitch(!proxy);
                for (mode = "w"; *++argv != NULL; mode = "a")
                        recvrequest("NLST", temp, *argv, mode, 0, 0);
d446 1
a446 1
                verbose = oldverbose;
d448 3
a450 3
                ftemp = fopen(temp, "r");
                (void)unlink(temp);
                if (ftemp == NULL) {
d457 5
a461 5
                        return (NULL);
                }
        }
        if (fgets(buf, sizeof(buf), ftemp) == NULL) {
                (void)fclose(ftemp);
d463 5
a467 5
                return (NULL);
        }
        if ((cp = strchr(buf, '\n')) != NULL)
                *cp = '\0';
        return (buf);
d471 1
a471 2
confirm(cmd, file)
	const char *cmd, *file;
d511 1
a511 2
globulize(cpp)
	char **cpp;
d541 1
a541 3
remotesize(file, noisy)
	const char *file;
	int noisy;
d572 1
a572 3
remotemodtime(file, noisy)
	const char *file;
	int noisy;
d635 1
a635 1
foregroundproc()
d647 1
d649 1
a649 2
updateprogressmeter(dummy)
	int dummy;
d672 1
a672 2
progressmeter(flag)
	int flag;
d797 1
a797 2
ptransfer(siginfo)
	int siginfo;
d837 1
a837 2
list_vertical(sl)
	StringList *sl;
d840 1
a840 1
	int columns, width, lines, items;
d843 1
a843 1
	width = items = 0;
d877 1
d879 1
a879 2
setttywidth(a)
	int a;
d895 1
a895 2
alarmtimer(wait)
	int wait;
d910 1
a910 1
controlediting()
@


1.1
log
@Initial revision
@
text
@a72 4
#if !defined(lint) && !defined(SMALL)
static char rcsid[] = "$OpenBSD: util.c,v 1.37 2003/12/16 21:46:22 deraadt Exp $";
#endif /* not lint and not SMALL */

d98 2
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@improve my Frankenstein OS (*wink* you know who you are) further
sans wchar_t of course

this is the essence of reading >1200 commit messages which suck
due to not having the new format of ours...
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.40 2005/04/11 15:16:50 deraadt Exp $	*/
d74 1
a74 1
static char rcsid[] = "$OpenBSD: util.c,v 1.40 2005/04/11 15:16:50 deraadt Exp $";
d109 3
a111 1
setpeer(int argc, char *argv[])
d113 2
a114 1
	char *host, *port;
d251 3
a253 1
ftp_login(const char *host, char *user, char *pass)
d255 2
a256 1
	char tmp[80], *acct = NULL, hostname[MAXHOSTNAMELEN];
d258 2
a260 1
	struct passwd *pw;
d262 1
d368 4
a371 1
another(int *pargc, char ***pargv, const char *prompt)
d399 31
a429 26
remglob(char *argv[], int doswitch, char **errbuf)
{
	char temp[MAXPATHLEN], *cp, *mode;
	static char buf[MAXPATHLEN], **args;
	static FILE *ftemp = NULL;
	int oldverbose, oldhash, fd;

	if (!mflag) {
		if (!doglob)
			args = NULL;
		else {
			if (ftemp) {
				(void)fclose(ftemp);
				ftemp = NULL;
			}
		}
		return (NULL);
	}
	if (!doglob) {
		if (args == NULL)
			args = argv;
		if ((cp = *++args) == NULL)
			args = NULL;
		return (cp);
	}
	if (ftemp == NULL) {
d445 5
a449 5
		if ((fd = mkstemp(temp)) < 0) {
			warn("unable to create temporary file %s", temp);
			return (NULL);
		}
		close(fd);
d454 4
a457 4
		if (doswitch)
			pswitch(!proxy);
		for (mode = "w"; *++argv != NULL; mode = "a")
			recvrequest("NLST", temp, *argv, mode, 0, 0);
d464 1
a464 1
		verbose = oldverbose;
d466 3
a468 3
		ftemp = fopen(temp, "r");
		(void)unlink(temp);
		if (ftemp == NULL) {
d475 5
a479 5
			return (NULL);
		}
	}
	if (fgets(buf, sizeof(buf), ftemp) == NULL) {
		(void)fclose(ftemp);
d481 5
a485 5
		return (NULL);
	}
	if ((cp = strchr(buf, '\n')) != NULL)
		*cp = '\0';
	return (buf);
d489 2
a490 1
confirm(const char *cmd, const char *file)
d530 2
a531 1
globulize(char **cpp)
d561 3
a563 1
remotesize(const char *file, int noisy)
d594 3
a596 1
remotemodtime(const char *file, int noisy)
d659 1
a659 1
foregroundproc(void)
a670 1
/* ARGSUSED */
d672 2
a673 1
updateprogressmeter(int signo)
d696 2
a697 1
progressmeter(int flag)
d822 2
a823 1
ptransfer(int siginfo)
d863 2
a864 1
list_vertical(StringList *sl)
d867 1
a867 1
	int columns, width, lines;
d870 1
a870 1
	width = 0;
a903 1
/* ARGSUSED */
d905 2
a906 1
setttywidth(int signo)
d922 2
a923 1
alarmtimer(int wait)
d938 1
a938 1
controlediting(void)
@


1.1.1.3
log
@Import OpenBSD 4.0's ftp(1) which downgraded to HTTP/1.0
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.43 2006/05/16 23:43:16 ray Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: util.c,v 1.43 2006/05/16 23:43:16 ray Exp $";
a87 1
#include <libgen.h>
d250 1
a250 1
	char tmp[80], *acctname = NULL, host_name[MAXHOSTNAMELEN];
d256 1
a256 1
		if (ruserpass(host, &user, &pass, &acctname) < 0) {
d267 1
a267 1
		memset(host_name, 0, sizeof(host_name));
d278 1
a278 1
		gethostname(host_name, sizeof(host_name));
d326 3
a328 3
		if (acctname == NULL)
			acctname = getpass("Account:");
		n = command("ACCT %s", acctname);
d331 1
a331 1
	    (!aflag && acctname != NULL && command("ACCT %s", acctname) != COMPLETE)) {
d390 1
a390 1
	char temp[MAXPATHLEN], *cp, *lmode;
d440 2
a441 2
		for (lmode = "w"; *++argv != NULL; lmode = "a")
			recvrequest("NLST", temp, *argv, lmode, 0, 0);
d475 1
a475 1
	char str[BUFSIZ];
d482 1
a482 1
	if (fgets(str, sizeof(str), stdin) == NULL)
d484 1
a484 1
	switch (tolower(*str)) {
a633 33
 * Ensure file is in or under dir.
 * Returns 1 if so, 0 if not (or an error occurred).
 */
int
fileindir(const char *file, const char *dir)
{
	char	parentdirbuf[MAXPATHLEN], *parentdir;
	char	realdir[MAXPATHLEN];
	size_t	dirlen;

		 			/* determine parent directory of file */
	(void)strlcpy(parentdirbuf, file, sizeof(parentdirbuf));
	parentdir = dirname(parentdirbuf);
	if (strcmp(parentdir, ".") == 0)
		return 1;		/* current directory is ok */

					/* find the directory */
	if (realpath(parentdir, realdir) == NULL) {
		warn("Unable to determine real path of `%s'", parentdir);
		return 0;
	}
	if (realdir[0] != '/')		/* relative result is ok */
		return 1;

	dirlen = strlen(dir);
	if (strncmp(realdir, dir, dirlen) == 0 &&
	    (realdir[dirlen] == '/' || realdir[dirlen] == '\0'))
		return 1;
	return 0;
}


/*
@


1.1.1.4
log
@the FTP on-the wire protocol must die, but we nevertheless could use -k
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.46 2007/06/06 19:15:33 pyr Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: util.c,v 1.46 2007/06/06 19:15:33 pyr Exp $";
a255 1
#ifndef SMALL
a261 1
#endif
d311 7
a317 9
		user = myname;
		if (fgets(tmp, sizeof(tmp), stdin) != NULL) {
			char *p;

			if ((p = strchr(tmp, '\n')) != NULL)
				*p = '\0';
			if (tmp[0] != '\0')
				user = tmp;
		}
@


