head	1.4;
access;
symbols
	MIRBSD_10:1.4.0.2
	MIRBSD_10_BASE:1.4
	cvs-200707151930:1.1.1.3
	OPENBSD_4_0:1.1.1.3
	MIRBSD_9_BASE:1.3
	MIRBSD_8:1.3.0.2
	MIRBSD_8_BASE:1.3
	cvs-200507211800:1.1.1.2
	cvs-200504291700:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2006.10.03.19.22.16;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004522B87E42B315D1;

1.3
date	2005.04.29.18.35.08;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.15.18.44.52;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.29.34;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.29.34;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.29.17.06.04;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.10.03.19.10.03;	author tg;	state Exp;
branches;
next	;
commitid	1004522B592570E1901;


desc
@@


1.4
log
@merge
@
text
@/*	$OpenBSD: complete.c,v 1.19 2006/06/23 20:35:25 steven Exp $	*/
/*	$NetBSD: complete.c,v 1.10 1997/08/18 10:20:18 lukem Exp $	*/

/*-
 * Copyright (c) 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Luke Mewburn.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef SMALL
/*
 * FTP user program - command and file completion routines
 */

#include <ctype.h>
#include <err.h>
#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "ftp_var.h"

__RCSID("$MirOS: src/usr.bin/ftp/complete.c,v 1.3 2005/04/29 18:35:08 tg Exp $");

static int	     comparstr(const void *, const void *);
static unsigned char complete_ambiguous(char *, int, StringList *);
static unsigned char complete_command(char *, int);
static unsigned char complete_local(char *, int);
static unsigned char complete_remote(char *, int);

static int
comparstr(const void *a, const void *b)
{
	return (strcmp(*(char **)a, *(char **)b));
}

/*
 * Determine if complete is ambiguous. If unique, insert.
 * If no choices, error. If unambiguous prefix, insert that.
 * Otherwise, list choices. words is assumed to be filtered
 * to only contain possible choices.
 * Args:
 *	word	word which started the match
 *	list	list by default
 *	words	stringlist containing possible matches
 */
static unsigned char
complete_ambiguous(char *word, int list, StringList *words)
{
	char insertstr[MAXPATHLEN];
	char *lastmatch;
	int i, j;
	size_t matchlen, wordlen;

	wordlen = strlen(word);
	if (words->sl_cur == 0)
		return (CC_ERROR);	/* no choices available */

	if (words->sl_cur == 1) {	/* only once choice available */
		(void)strlcpy(insertstr, words->sl_str[0], sizeof insertstr);
		if (el_insertstr(el, insertstr + wordlen) == -1)
			return (CC_ERROR);
		else
			return (CC_REFRESH);
	}

	if (!list) {
		matchlen = 0;
		lastmatch = words->sl_str[0];
		matchlen = strlen(lastmatch);
		for (i = 1 ; i < words->sl_cur ; i++) {
			for (j = wordlen ; j < strlen(words->sl_str[i]); j++)
				if (lastmatch[j] != words->sl_str[i][j])
					break;
			if (j < matchlen)
				matchlen = j;
		}
		if (matchlen > wordlen) {
			(void)strlcpy(insertstr, lastmatch, matchlen+1);
			if (el_insertstr(el, insertstr + wordlen) == -1)
				return (CC_ERROR);
			else	
					/*
					 * XXX: really want CC_REFRESH_BEEP
					 */
				return (CC_REFRESH);
		}
	}

	putc('\n', ttyout);
	qsort(words->sl_str, words->sl_cur, sizeof(char *), comparstr);
	list_vertical(words);
	return (CC_REDISPLAY);
}

/*
 * Complete a command
 */
static unsigned char
complete_command(char *word, int list)
{
	struct cmd *c;
	StringList *words;
	size_t wordlen;
	unsigned char rv;

	words = sl_init();
	wordlen = strlen(word);

	for (c = cmdtab; c->c_name != NULL; c++) {
		if (wordlen > strlen(c->c_name))
			continue;
		if (strncmp(word, c->c_name, wordlen) == 0)
			sl_add(words, c->c_name);
	}

	rv = complete_ambiguous(word, list, words);
	sl_free(words, 0);
	return (rv);
}

/*
 * Complete a local file
 */
static unsigned char
complete_local(char *word, int list)
{
	StringList *words;
	char dir[MAXPATHLEN];
	char *file;
	DIR *dd;
	struct dirent *dp;
	unsigned char rv;

	if ((file = strrchr(word, '/')) == NULL) {
		dir[0] = '.';
		dir[1] = '\0';
		file = word;
	} else {
		if (file == word) {
			dir[0] = '/';
			dir[1] = '\0';
		} else {
			(void)strlcpy(dir, word, (size_t)(file - word) + 1);
		}
		file++;
	}

	if ((dd = opendir(dir)) == NULL)
		return (CC_ERROR);

	words = sl_init();

	for (dp = readdir(dd); dp != NULL; dp = readdir(dd)) {
		if (!strcmp(dp->d_name, ".") || !strcmp(dp->d_name, ".."))
			continue;
		if (strlen(file) > dp->d_namlen)
			continue;
		if (strncmp(file, dp->d_name, strlen(file)) == 0) {
			char *tcp;

			tcp = strdup(dp->d_name);
			if (tcp == NULL)
				errx(1, "Can't allocate memory for local dir");
			sl_add(words, tcp);
		}
	}
	closedir(dd);

	rv = complete_ambiguous(file, list, words);
	sl_free(words, 1);
	return (rv);
}

/*
 * Complete a remote file
 */
static unsigned char
complete_remote(char *word, int list)
{
	static StringList *dirlist;
	static char	 lastdir[MAXPATHLEN];
	StringList	*words;
	char		 dir[MAXPATHLEN];
	char		*file, *cp;
	int		 i;
	unsigned char	 rv;

	char *dummyargv[] = { "complete", dir, NULL };

	if ((file = strrchr(word, '/')) == NULL) {
		dir[0] = '.';
		dir[1] = '\0';
		file = word;
	} else {
		cp = file;
		while (*cp == '/' && cp > word)
			cp--;
		(void)strlcpy(dir, word, (size_t)(cp - word + 2));
		file++;
	}

	if (dirchange || strcmp(dir, lastdir) != 0) {	/* dir not cached */
		char *emesg;

		sl_free(dirlist, 1);
		dirlist = sl_init();

		mflag = 1;
		emesg = NULL;
		if (debug)
			(void)putc('\n', ttyout);
		while ((cp = remglob(dummyargv, 0, &emesg)) != NULL) {
			char *tcp;

			if (!mflag)
				continue;
			if (*cp == '\0') {
				mflag = 0;
				continue;
			}
			tcp = strrchr(cp, '/');
			if (tcp)
				tcp++;
			else
				tcp = cp;
			tcp = strdup(tcp);
			if (tcp == NULL)
				errx(1, "Can't allocate memory for remote dir");
			sl_add(dirlist, tcp);
		}
		if (emesg != NULL) {
			fprintf(ttyout, "\n%s\n", emesg);
			return (CC_REDISPLAY);
		}
		(void)strlcpy(lastdir, dir, sizeof lastdir);
		dirchange = 0;
	}

	words = sl_init();
	for (i = 0; i < dirlist->sl_cur; i++) {
		cp = dirlist->sl_str[i];
		if (strlen(file) > strlen(cp))
			continue;
		if (strncmp(file, cp, strlen(file)) == 0)
			sl_add(words, cp);
	}
	rv = complete_ambiguous(file, list, words);
	sl_free(words, 0);
	return (rv);
}

/*
 * Generic complete routine
 */
unsigned char
complete(EditLine *el, int ch)
{
	static char word[FTPBUFLEN];
	static int lastc_argc, lastc_argo;
	struct cmd *c;
	const LineInfo *lf;
	int celems, dolist;
	size_t len;

	ch = ch;		/* not used */
	lf = el_line(el);
	len = lf->lastchar - lf->buffer;
	if (len >= sizeof(line))
		return (CC_ERROR);
	(void)memcpy(line, lf->buffer, len);
	line[len] = '\0';
	cursor_pos = line + (lf->cursor - lf->buffer);
	lastc_argc = cursor_argc;	/* remember last cursor pos */
	lastc_argo = cursor_argo;
	makeargv();			/* build argc/argv of current line */

	if (cursor_argo >= sizeof(word))
		return (CC_ERROR);

	dolist = 0;
			/* if cursor and word is same, list alternatives */
	if (lastc_argc == cursor_argc && lastc_argo == cursor_argo
	    && strncmp(word, margv[cursor_argc], cursor_argo) == 0)
		dolist = 1;
	else if (cursor_argo)
		memcpy(word, margv[cursor_argc], cursor_argo);
	word[cursor_argo] = '\0';

	if (cursor_argc == 0)
		return (complete_command(word, dolist));

	c = getcmd(margv[0]);
	if (c == (struct cmd *)-1 || c == 0)
		return (CC_ERROR);
	celems = strlen(c->c_complete);

		/* check for 'continuation' completes (which are uppercase) */
	if ((cursor_argc > celems) && (celems > 0)
	    && isupper(c->c_complete[celems-1]))
		cursor_argc = celems;

	if (cursor_argc > celems)
		return (CC_ERROR);

	switch (c->c_complete[cursor_argc - 1]) {
	case 'l':			/* local complete */
	case 'L':
		return (complete_local(word, dolist));
	case 'r':			/* remote complete */
	case 'R':
		if (connected != -1) {
			fputs("\nMust be logged in to complete.\n", ttyout);
			return (CC_REDISPLAY);
		}
		return (complete_remote(word, dolist));
	case 'c':			/* command complete */
	case 'C':
		return (complete_command(word, dolist));
	case 'n':			/* no complete */
		return (CC_ERROR);
	}

	return (CC_ERROR);
}

#endif /* !SMALL */
@


1.3
log
@(tentative) merge, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: complete.c,v 1.17 2004/09/16 04:39:16 deraadt Exp $	*/
a40 1

d54 1
a54 1
__RCSID("$MirOS: src/usr.bin/ftp/complete.c,v 1.2 2005/03/15 18:44:52 tg Exp $");
d237 1
a237 2
		if (dirlist != NULL)
			sl_free(dirlist, 1);
@


1.2
log
@rather than fixing
/usr/src/usr.bin/ftp/cmds.c:63: warning: 'rcsid' defined but not used
just convert to __RCSID() macro
@
text
@d1 1
a1 1
/*	$OpenBSD: complete.c,v 1.14 2003/04/05 17:19:47 deraadt Exp $	*/
d55 1
a55 1
__RCSID("$MirOS$");
d64 1
a64 2
comparstr(a, b)
	const void *a, *b;
d80 1
a80 4
complete_ambiguous(word, list, words)
	char *word;
	int list;
	StringList *words;
d132 1
a132 3
complete_command(word, list)
	char *word;
	int list;
d158 1
a158 3
complete_local(word, list)
	char *word;
	int list;
d211 1
a211 3
complete_remote(word, list)
	char *word;
	int list;
d290 1
a290 3
complete(el, ch)
	EditLine *el;
	int ch;
a293 1

d299 1
d304 2
a305 1
	(void)strlcpy(line, lf->buffer, len+1);
d340 15
a354 16
		case 'l':			/* local complete */
		case 'L':
			return (complete_local(word, dolist));
		case 'r':			/* remote complete */
		case 'R':
			if (connected != -1) {
				fputs("\nMust be logged in to complete.\n", ttyout);
				return (CC_REDISPLAY);
			}
			return (complete_remote(word, dolist));
		case 'c':			/* command complete */
		case 'C':
			return (complete_command(word, dolist));
		case 'n':			/* no complete */
		default:
			return (CC_ERROR);
@


1.1
log
@Initial revision
@
text
@a40 3
#ifndef lint
static char rcsid[] = "$OpenBSD: complete.c,v 1.14 2003/04/05 17:19:47 deraadt Exp $";
#endif /* not lint */
d55 2
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@improve my Frankenstein OS (*wink* you know who you are) further
sans wchar_t of course

this is the essence of reading >1200 commit messages which suck
due to not having the new format of ours...
@
text
@d1 1
a1 1
/*	$OpenBSD: complete.c,v 1.17 2004/09/16 04:39:16 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: complete.c,v 1.17 2004/09/16 04:39:16 deraadt Exp $";
d65 2
a66 1
comparstr(const void *a, const void *b)
d82 4
a85 1
complete_ambiguous(char *word, int list, StringList *words)
d137 3
a139 1
complete_command(char *word, int list)
d165 3
a167 1
complete_local(char *word, int list)
d220 3
a222 1
complete_remote(char *word, int list)
d301 3
a303 1
complete(EditLine *el, int ch)
d307 1
a312 1
	ch = ch;		/* not used */
d317 1
a317 2
	(void)memcpy(line, lf->buffer, len);
	line[len] = '\0';
d352 16
a367 15
	case 'l':			/* local complete */
	case 'L':
		return (complete_local(word, dolist));
	case 'r':			/* remote complete */
	case 'R':
		if (connected != -1) {
			fputs("\nMust be logged in to complete.\n", ttyout);
			return (CC_REDISPLAY);
		}
		return (complete_remote(word, dolist));
	case 'c':			/* command complete */
	case 'C':
		return (complete_command(word, dolist));
	case 'n':			/* no complete */
		return (CC_ERROR);
@


1.1.1.3
log
@Import OpenBSD 4.0's ftp(1) which downgraded to HTTP/1.0
@
text
@d1 1
a1 1
/*	$OpenBSD: complete.c,v 1.19 2006/06/23 20:35:25 steven Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: complete.c,v 1.19 2006/06/23 20:35:25 steven Exp $";
d239 2
a240 1
		sl_free(dirlist, 1);
@


