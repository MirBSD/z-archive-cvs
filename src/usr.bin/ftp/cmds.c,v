head	1.7;
access;
symbols
	MIRBSD_10:1.5.0.2
	MIRBSD_10_BASE:1.5
	cvs-200707151930:1.1.1.4
	OPENBSD_4_0:1.1.1.3
	MIRBSD_9_BASE:1.3
	MIRBSD_8:1.3.0.2
	MIRBSD_8_BASE:1.3
	cvs-200507211800:1.1.1.2
	cvs-200504291700:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.03.01.16.02.54;	author tg;	state Exp;
branches;
next	1.6;
commitid	10054F3383E4E01EF7A;

1.6
date	2013.09.15.11.01.28;	author tg;	state Exp;
branches;
next	1.5;
commitid	1005235938A2629E92C;

1.5
date	2007.07.15.20.01.07;	author tg;	state Exp;
branches;
next	1.4;
commitid	100469A7CFC300FC2D9;

1.4
date	2006.10.03.19.22.16;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004522B87E42B315D1;

1.3
date	2005.04.29.18.35.08;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.15.18.44.51;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.29.34;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.29.34;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.29.17.06.03;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.10.03.19.10.03;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	1004522B592570E1901;

1.1.1.4
date	2007.07.15.19.51.36;	author tg;	state Exp;
branches;
next	;
commitid	100469A7AC943312E80;


desc
@@


1.7
log
@KNF
@
text
@/*	$OpenBSD: cmds.c,v 1.55 2006/11/22 04:08:35 ray Exp $	*/
/*	$NetBSD: cmds.c,v 1.27 1997/08/18 10:20:15 lukem Exp $	*/

/*
 * Copyright (C) 1997 and 1998 WIDE Project.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1985, 1989, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * FTP User Program -- Command Routines.
 */
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <arpa/ftp.h>

#include <ctype.h>
#include <err.h>
#include <glob.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "ftp_var.h"
#include "pathnames.h"

__RCSID("$MirOS: src/usr.bin/ftp/cmds.c,v 1.6 2013/09/15 11:01:28 tg Exp $");

jmp_buf	jabort;
char   *mname;
char   *home = "/";

struct	types {
	char	*t_name;
	char	*t_mode;
	int	t_type;
	char	*t_arg;
} types[] = {
	{ "ascii",	"A",	TYPE_A,	0 },
	{ "binary",	"I",	TYPE_I,	0 },
	{ "image",	"I",	TYPE_I,	0 },
#ifndef SMALL
	{ "ebcdic",	"E",	TYPE_E,	0 },
	{ "tenex",	"L",	TYPE_L,	bytename },
#endif /* !SMALL */
	{ NULL }
};

/*
 * Set transfer type.
 */
void
settype(int argc, char *argv[])
{
	struct types *p;
	int comret;

	if (argc > 2) {
		char *sep;

		fprintf(ttyout, "usage: %s [", argv[0]);
		sep = " ";
		for (p = types; p->t_name; p++) {
			fprintf(ttyout, "%s%s", sep, p->t_name);
			sep = " | ";
		}
		fputs(" ]\n", ttyout);
		code = -1;
		return;
	}
	if (argc < 2) {
		fprintf(ttyout, "Using %s mode to transfer files.\n", typename);
		code = 0;
		return;
	}
	for (p = types; p->t_name; p++)
		if (strcmp(argv[1], p->t_name) == 0)
			break;
	if (p->t_name == 0) {
		fprintf(ttyout, "%s: unknown mode.\n", argv[1]);
		code = -1;
		return;
	}
	if ((p->t_arg != NULL) && (*(p->t_arg) != '\0'))
		comret = command("TYPE %s %s", p->t_mode, p->t_arg);
	else
		comret = command("TYPE %s", p->t_mode);
	if (comret == COMPLETE) {
		(void)strlcpy(typename, p->t_name, sizeof typename);
		curtype = type = p->t_type;
	}
}

/*
 * Internal form of settype; changes current type in use with server
 * without changing our notion of the type for data transfers.
 * Used to change to and from ascii for listings.
 */
void
changetype(int newtype, int show)
{
	struct types *p;
	int comret, oldverbose = verbose;

	if (newtype == 0)
		newtype = TYPE_I;
	if (newtype == curtype)
		return;
	if (debug == 0 && show == 0)
		verbose = 0;
	for (p = types; p->t_name; p++)
		if (newtype == p->t_type)
			break;
	if (p->t_name == 0) {
		warnx("internal error: unknown type %d.", newtype);
		return;
	}
#ifndef SMALL
	if (newtype == TYPE_L && bytename[0] != '\0')
		comret = command("TYPE %s %s", p->t_mode, bytename);
	else
#endif /* !SMALL */
		comret = command("TYPE %s", p->t_mode);
	if (comret == COMPLETE)
		curtype = newtype;
	verbose = oldverbose;
}

char *stype[] = {
	"type",
	"",
	0
};

/*
 * Set binary transfer type.
 */
/*ARGSUSED*/
void
setbinary(int argc, char *argv[])
{

	stype[1] = "binary";
	settype(2, stype);
}

/*
 * Set ascii transfer type.
 */
/*ARGSUSED*/
void
setascii(int argc, char *argv[])
{

	stype[1] = "ascii";
	settype(2, stype);
}

#ifndef SMALL
/*
 * Set tenex transfer type.
 */
/*ARGSUSED*/
void
settenex(int argc, char *argv[])
{

	stype[1] = "tenex";
	settype(2, stype);
}
#endif /* !SMALL */

/*
 * Set file transfer mode.
 */
/*ARGSUSED*/
void
setftmode(int argc, char *argv[])
{

	fprintf(ttyout, "We only support %s mode, sorry.\n", modename);
	code = -1;
}

/*
 * Set file transfer format.
 */
/*ARGSUSED*/
void
setform(int argc, char *argv[])
{

	fprintf(ttyout, "We only support %s format, sorry.\n", formname);
	code = -1;
}

/*
 * Set file transfer structure.
 */
/*ARGSUSED*/
void
setstruct(int argc, char *argv[])
{

	fprintf(ttyout, "We only support %s structure, sorry.\n", structname);
	code = -1;
}

/*
 * Send a single file.
 */
void
put(int argc, char *argv[])
{
	char *cmd;
	int loc = 0;
	char *oldargv1, *oldargv2;

	if (argc == 2) {
		argc++;
		argv[2] = argv[1];
		loc++;
	}
	if (argc < 2 && !another(&argc, &argv, "local-file"))
		goto usage;
	if ((argc < 3 && !another(&argc, &argv, "remote-file")) || argc > 3) {
usage:
		fprintf(ttyout, "usage: %s local-file [ remote-file ]\n", argv[0]);
		code = -1;
		return;
	}
	oldargv1 = argv[1];
	oldargv2 = argv[2];
	if (!globulize(&argv[1])) {
		code = -1;
		return;
	}
	/*
	 * If "globulize" modifies argv[1], and argv[2] is a copy of
	 * the old argv[1], make it a copy of the new argv[1].
	 */
	if (argv[1] != oldargv1 && argv[2] == oldargv1) {
		argv[2] = argv[1];
	}
	cmd = (argv[0][0] == 'a') ? "APPE" : ((sunique) ? "STOU" : "STOR");
	if (loc && ntflag) {
		argv[2] = dotrans(argv[2]);
	}
	if (loc && mapflag) {
		argv[2] = domap(argv[2]);
	}
	sendrequest(cmd, argv[1], argv[2],
	    argv[1] != oldargv1 || argv[2] != oldargv2);
	if (oldargv1 != argv[1])	/* free up after globulize() */
		free(argv[1]);
}

/*
 * Send multiple files.
 */
void
mput(int argc, char *argv[])
{
	int i;
	sig_t oldintr;
	int ointer;
	char *tp;

	if (argc < 2 && !another(&argc, &argv, "local-files")) {
		fprintf(ttyout, "usage: %s local-files\n", argv[0]);
		code = -1;
		return;
	}
	mname = argv[0];
	mflag = 1;
	oldintr = signal(SIGINT, mabort);
	(void)setjmp(jabort);
	if (proxy) {
		char *cp, *tp2, tmpbuf[MAXPATHLEN];

		while ((cp = remglob(argv, 0, NULL)) != NULL) {
			if (*cp == '\0') {
				mflag = 0;
				continue;
			}
			if (mflag && confirm(argv[0], cp)) {
				tp = cp;
				if (mcase) {
					while (*tp && !islower(*tp)) {
						tp++;
					}
					if (!*tp) {
						tp = cp;
						tp2 = tmpbuf;
						while ((*tp2 = *tp) != '\0') {
						     if (isupper(*tp2)) {
							    *tp2 =
								tolower(*tp2);
						     }
						     tp++;
						     tp2++;
						}
					}
					tp = tmpbuf;
				}
				if (ntflag) {
					tp = dotrans(tp);
				}
				if (mapflag) {
					tp = domap(tp);
				}
				sendrequest((sunique) ? "STOU" : "STOR",
				    cp, tp, cp != tp || !interactive);
				if (!mflag && fromatty) {
					ointer = interactive;
					interactive = 1;
					if (confirm("Continue with", "mput")) {
						mflag++;
					}
					interactive = ointer;
				}
			}
		}
		(void)signal(SIGINT, oldintr);
		mflag = 0;
		return;
	}
	for (i = 1; i < argc; i++) {
		char **cpp;
		glob_t gl;
		int flags;

		if (!doglob) {
			if (mflag && confirm(argv[0], argv[i])) {
				tp = (ntflag) ? dotrans(argv[i]) : argv[i];
				tp = (mapflag) ? domap(tp) : tp;
				sendrequest((sunique) ? "STOU" : "STOR",
				    argv[i], tp, tp != argv[i] || !interactive);
				if (!mflag && fromatty) {
					ointer = interactive;
					interactive = 1;
					if (confirm("Continue with", "mput")) {
						mflag++;
					}
					interactive = ointer;
				}
			}
			continue;
		}

		memset(&gl, 0, sizeof(gl));
		flags = GLOB_BRACE|GLOB_NOCHECK|GLOB_QUOTE|GLOB_TILDE;
		if (glob(argv[i], flags, NULL, &gl) || gl.gl_pathc == 0) {
			warnx("%s: not found", argv[i]);
			globfree(&gl);
			continue;
		}
		for (cpp = gl.gl_pathv; cpp && *cpp != NULL; cpp++) {
			if (mflag && confirm(argv[0], *cpp)) {
				tp = (ntflag) ? dotrans(*cpp) : *cpp;
				tp = (mapflag) ? domap(tp) : tp;
				sendrequest((sunique) ? "STOU" : "STOR",
				    *cpp, tp, *cpp != tp || !interactive);
				if (!mflag && fromatty) {
					ointer = interactive;
					interactive = 1;
					if (confirm("Continue with", "mput")) {
						mflag++;
					}
					interactive = ointer;
				}
			}
		}
		globfree(&gl);
	}
	(void)signal(SIGINT, oldintr);
	mflag = 0;
}

void
reget(int argc, char *argv[])
{

	(void)getit(argc, argv, 1, "r+w");
}

void
get(int argc, char *argv[])
{

	(void)getit(argc, argv, 0, restart_point ? "r+w" : "w" );
}

/*
 * Receive one file.
 */
int
getit(int argc, char *argv[], int restartit, const char *mode)
{
	int loc = 0;
	int rval = 0;
	char *oldargv1, *oldargv2, *globargv2;

	if (argc == 2) {
		argc++;
		argv[2] = argv[1];
		loc++;
	}
	if (argc < 2 && !another(&argc, &argv, "remote-file"))
		goto usage;
	if ((argc < 3 && !another(&argc, &argv, "local-file")) || argc > 3) {
usage:
		fprintf(ttyout, "usage: %s remote-file [ local-file ]\n", argv[0]);
		code = -1;
		return (0);
	}
	oldargv1 = argv[1];
	oldargv2 = argv[2];
	if (!globulize(&argv[2])) {
		code = -1;
		return (0);
	}
	globargv2 = argv[2];
	if (loc && mcase) {
		char *tp = argv[1], *tp2, tmpbuf[MAXPATHLEN];

		while (*tp && !islower(*tp)) {
			tp++;
		}
		if (!*tp) {
			tp = argv[2];
			tp2 = tmpbuf;
			while ((*tp2 = *tp) != '\0') {
				if (isupper(*tp2)) {
					*tp2 = tolower(*tp2);
				}
				tp++;
				tp2++;
			}
			argv[2] = tmpbuf;
		}
	}
	if (loc && ntflag)
		argv[2] = dotrans(argv[2]);
	if (loc && mapflag)
		argv[2] = domap(argv[2]);
	if (restartit) {
		struct stat stbuf;
		int ret;

		ret = stat(argv[2], &stbuf);
		if (restartit == 1) {
			if (ret < 0) {
				warn("local: %s", argv[2]);
				goto freegetit;
			}
			restart_point = stbuf.st_size;
		} else {
			if (ret == 0) {
				time_t mtime;

				mtime = remotemodtime(argv[1], 0);
				if (mtime == -1)
					goto freegetit;
				if (stbuf.st_mtime >= mtime) {
					rval = 1;
					goto freegetit;
				}
			}
		}
	}

	recvrequest("RETR", argv[2], argv[1], mode,
	    argv[1] != oldargv1 || argv[2] != oldargv2, loc);
	restart_point = 0;
freegetit:
	if (oldargv2 != globargv2)	/* free up after globulize() */
		free(globargv2);
	return (rval);
}

/* XXX - Signal race. */
/* ARGSUSED */
void
mabort(int signo)
{
	int ointer, oconf;

	alarmtimer(0);
	putc('\n', ttyout);
	(void)fflush(ttyout);
	if (mflag && fromatty) {
		ointer = interactive;
		oconf = confirmrest;
		interactive = 1;
		confirmrest = 0;
		if (confirm("Continue with", mname)) {
			interactive = ointer;
			confirmrest = oconf;
			longjmp(jabort, 1);
		}
		interactive = ointer;
		confirmrest = oconf;
	}
	mflag = 0;
	longjmp(jabort, 1);
}

/*
 * Get multiple files.
 */
void
mget(int argc, char *argv[])
{
	sig_t oldintr;
	int ch, ointer;
	char *cp, *tp, *tp2, tmpbuf[MAXPATHLEN], localcwd[MAXPATHLEN];

	if (argc < 2 && !another(&argc, &argv, "remote-files")) {
		fprintf(ttyout, "usage: %s remote-files\n", argv[0]);
		code = -1;
		return;
	}
	mname = argv[0];
	mflag = 1;
	if (getcwd(localcwd, sizeof(localcwd)) == NULL)
		err(1, "can't get cwd");

	oldintr = signal(SIGINT, mabort);
	(void)setjmp(jabort);
	while ((cp = remglob(argv, proxy, NULL)) != NULL) {
		if (*cp == '\0') {
			mflag = 0;
			continue;
		}
		if (!mflag)
			continue;
		if (!fileindir(cp, localcwd)) {
			fprintf(ttyout, "Skipping non-relative filename `%s'\n",
			    cp);
			continue;
		}
		if (confirm(argv[0], cp)) {
			tp = cp;
			if (mcase) {
				for (tp2 = tmpbuf; (ch = *tp++) != 0; )
					*tp2++ = isupper(ch) ? tolower(ch) : ch;
				*tp2 = '\0';
				tp = tmpbuf;
			}
			if (ntflag)
				tp = dotrans(tp);
			if (mapflag)
				tp = domap(tp);
			recvrequest("RETR", tp, cp, "w",
			    tp != cp || !interactive, 1);
			if (!mflag && fromatty) {
				ointer = interactive;
				interactive = 1;
				if (confirm("Continue with", "mget")) {
					mflag++;
				}
				interactive = ointer;
			}
		}
	}
	(void)signal(SIGINT, oldintr);
	mflag = 0;
}

char *
onoff(int bool)
{

	return (bool ? "on" : "off");
}

#ifndef SMALL
/*
 * Show status.
 */
/*ARGSUSED*/
void
status(int argc, char *argv[])
{
	int i;

	if (connected)
		fprintf(ttyout, "Connected %sto %s.\n",
		    connected == -1 ? "and logged in" : "", hostname);
	else
		fputs("Not connected.\n", ttyout);
	if (!proxy) {
		pswitch(1);
		if (connected) {
			fprintf(ttyout, "Connected for proxy commands to %s.\n",
			    hostname);
		}
		else {
			fputs("No proxy connection.\n", ttyout);
		}
		pswitch(0);
	}
	fprintf(ttyout, "Gate ftp: %s, server %s, port %s.\n", onoff(gatemode),
	    *gateserver ? gateserver : "(none)", gateport);
	fprintf(ttyout, "Passive mode: %s.\n", onoff(passivemode));
	fprintf(ttyout, "Mode: %s; Type: %s; Form: %s; Structure: %s.\n",
		modename, typename, formname, structname);
	fprintf(ttyout, "Verbose: %s; Bell: %s; Prompting: %s; Globbing: %s.\n",
		onoff(verbose), onoff(bell), onoff(interactive),
		onoff(doglob));
	fprintf(ttyout, "Store unique: %s; Receive unique: %s.\n", onoff(sunique),
		onoff(runique));
	fprintf(ttyout, "Preserve modification times: %s.\n", onoff(preserve));
	fprintf(ttyout, "Case: %s; CR stripping: %s.\n", onoff(mcase), onoff(crflag));
	if (ntflag) {
		fprintf(ttyout, "Ntrans: (in) %s (out) %s\n", ntin, ntout);
	}
	else {
		fputs("Ntrans: off.\n", ttyout);
	}
	if (mapflag) {
		fprintf(ttyout, "Nmap: (in) %s (out) %s\n", mapin, mapout);
	}
	else {
		fputs("Nmap: off.\n", ttyout);
	}
	fprintf(ttyout, "Hash mark printing: %s; Mark count: %d; Progress bar: %s.\n",
	    onoff(hash), mark, onoff(progress));
	fprintf(ttyout, "Use of PORT/LPRT cmds: %s.\n", onoff(sendport));
	fprintf(ttyout, "Use of EPSV/EPRT cmds for IPv4: %s%s.\n", onoff(epsv4),
	    epsv4bad ? " (disabled for this connection)" : "");
#ifndef SMALL
	fprintf(ttyout, "Command line editing: %s.\n", onoff(editing));
#endif /* !SMALL */
	if (macnum > 0) {
		fputs("Macros:\n", ttyout);
		for (i=0; i<macnum; i++) {
			fprintf(ttyout, "\t%s\n", macros[i].mac_name);
		}
	}
	code = 0;
}
#endif /* !SMALL */

/*
 * Toggle a variable
 */
int
togglevar(int argc, char *argv[], int *var, const char *mesg)
{
	if (argc < 2) {
		*var = !*var;
	} else if (argc == 2 && strcasecmp(argv[1], "on") == 0) {
		*var = 1;
	} else if (argc == 2 && strcasecmp(argv[1], "off") == 0) {
		*var = 0;
	} else {
		fprintf(ttyout, "usage: %s [ on | off ]\n", argv[0]);
		return (-1);
	}
	if (mesg)
		fprintf(ttyout, "%s %s.\n", mesg, onoff(*var));
	return (*var);
}

/*
 * Set beep on cmd completed mode.
 */
/*ARGSUSED*/
void
setbell(int argc, char *argv[])
{

	code = togglevar(argc, argv, &bell, "Bell mode");
}

#ifndef SMALL
/*
 * Set command line editing
 */
/*ARGSUSED*/
void
setedit(int argc, char *argv[])
{

	code = togglevar(argc, argv, &editing, "Editing mode");
	controlediting();
}
#endif /* !SMALL */

/*
 * Toggle use of IPv4 EPSV/EPRT
 */
/*ARGSUSED*/
void
setepsv4(int argc, char *argv[])
{

	code = togglevar(argc, argv, &epsv4, "EPSV/EPRT on IPv4");
	epsv4bad = 0;
}

/*
 * Turn on packet tracing.
 */
/*ARGSUSED*/
void
settrace(int argc, char *argv[])
{

	code = togglevar(argc, argv, &trace, "Packet tracing");
}

/*
 * Toggle hash mark printing during transfers, or set hash mark bytecount.
 */
/*ARGSUSED*/
void
sethash(int argc, char *argv[])
{
	if (argc == 1)
		hash = !hash;
	else if (argc != 2) {
		fprintf(ttyout, "usage: %s [ on | off | bytecount ]\n", argv[0]);
		code = -1;
		return;
	} else if (strcasecmp(argv[1], "on") == 0)
		hash = 1;
	else if (strcasecmp(argv[1], "off") == 0)
		hash = 0;
	else {
		int nmark;
		const char *errstr;

		nmark = strtonum(argv[1], 1, INT_MAX, &errstr);
		if (errstr) {
			fprintf(ttyout, "bytecount value is %s: %s\n",
			    errstr, argv[1]);
			code = -1;
			return;
		}
		mark = nmark;
		hash = 1;
	}
	fprintf(ttyout, "Hash mark printing %s", onoff(hash));
	if (hash)
		fprintf(ttyout, " (%d bytes/hash mark)", mark);
	fputs(".\n", ttyout);
	code = hash;
}

/*
 * Turn on printing of server echo's.
 */
/*ARGSUSED*/
void
setverbose(int argc, char *argv[])
{

	code = togglevar(argc, argv, &verbose, "Verbose mode");
}

/*
 * Toggle PORT/LPRT cmd use before each data connection.
 */
/*ARGSUSED*/
void
setport(int argc, char *argv[])
{

	code = togglevar(argc, argv, &sendport, "Use of PORT/LPRT cmds");
}

/*
 * Toggle transfer progress bar.
 */
/*ARGSUSED*/
void
setprogress(int argc, char *argv[])
{

	code = togglevar(argc, argv, &progress, "Progress bar");
}

/*
 * Turn on interactive prompting during mget, mput, and mdelete.
 */
/*ARGSUSED*/
void
setprompt(int argc, char *argv[])
{

	code = togglevar(argc, argv, &interactive, "Interactive mode");
}

/*
 * Toggle gate-ftp mode, or set gate-ftp server
 */
/*ARGSUSED*/
void
setgate(int argc, char *argv[])
{
	static char gsbuf[MAXHOSTNAMELEN];

	if (argc > 3) {
		fprintf(ttyout, "usage: %s [ on | off | gateserver [ port ] ]\n",
		    argv[0]);
		code = -1;
		return;
	} else if (argc < 2) {
		gatemode = !gatemode;
	} else {
		if (argc == 2 && strcasecmp(argv[1], "on") == 0)
			gatemode = 1;
		else if (argc == 2 && strcasecmp(argv[1], "off") == 0)
			gatemode = 0;
		else {
			if (argc == 3) {
#if 0
				char *ep;
				long port;

				port = strtol(argv[2], &ep, 10);
				if (port < 0 || port > USHRT_MAX || *ep != '\0') {
					fprintf(ttyout,
					    "%s: bad gateport value.\n",
					    argv[2]);
					code = -1;
					return;
				}
				gateport = htons(port);
#else
				gateport = strdup(argv[2]);
				if (gateport == NULL)
					err(1, NULL);
#endif
			}
			strlcpy(gsbuf, argv[1], sizeof(gsbuf));
			gateserver = gsbuf;
			gatemode = 1;
		}
	}
	if (gatemode && (gateserver == NULL || *gateserver == '\0')) {
		fprintf(ttyout,
		    "Disabling gate-ftp mode - no gate-ftp server defined.\n");
		gatemode = 0;
	} else {
		fprintf(ttyout, "Gate ftp: %s, server %s, port %s.\n",
		    onoff(gatemode),
		    *gateserver ? gateserver : "(none)", gateport);
	}
	code = gatemode;
}

/*
 * Toggle metacharacter interpretation on local file names.
 */
/*ARGSUSED*/
void
setglob(int argc, char *argv[])
{

	code = togglevar(argc, argv, &doglob, "Globbing");
}

/*
 * Toggle preserving modification times on retrieved files.
 */
/*ARGSUSED*/
void
setpreserve(int argc, char *argv[])
{

	code = togglevar(argc, argv, &preserve, "Preserve modification times");
}

/*
 * Set debugging mode on/off and/or set level of debugging.
 */
/*ARGSUSED*/
void
setdebug(int argc, char *argv[])
{
	if (argc > 2) {
		fprintf(ttyout, "usage: %s [ on | off | debuglevel ]\n", argv[0]);
		code = -1;
		return;
	} else if (argc == 2) {
		if (strcasecmp(argv[1], "on") == 0)
			debug = 1;
		else if (strcasecmp(argv[1], "off") == 0)
			debug = 0;
		else {
			const char *errstr;
			int val;

			val = strtonum(argv[1], 0, INT_MAX, &errstr);
			if (errstr) {
				fprintf(ttyout, "debugging value is %s: %s\n",
				    errstr, argv[1]);
				code = -1;
				return;
			}
			debug = val;
		}
	} else
		debug = !debug;
	if (debug)
		options |= SO_DEBUG;
	else
		options &= ~SO_DEBUG;
	fprintf(ttyout, "Debugging %s (debug=%d).\n", onoff(debug), debug);
	code = debug > 0;
}

/*
 * Set current working directory on remote machine.
 */
void
cd(int argc, char *argv[])
{
	int r;

	if ((argc < 2 && !another(&argc, &argv, "remote-directory")) ||
	    argc > 2) {
		fprintf(ttyout, "usage: %s remote-directory\n", argv[0]);
		code = -1;
		return;
	}
	r = command("CWD %s", argv[1]);
	if (r == ERROR && code == 500) {
		if (verbose)
			fputs("CWD command not recognized, trying XCWD.\n", ttyout);
		r = command("XCWD %s", argv[1]);
	}
	if (r == ERROR && code == 550) {
		dirchange = 0;
		return;
	}
	if (r == COMPLETE)
		dirchange = 1;
}

/*
 * Set current working directory on local machine.
 */
void
lcd(int argc, char *argv[])
{
	char buf[MAXPATHLEN];
	char *oldargv1;

	if (argc < 2)
		argc++, argv[1] = home;
	if (argc != 2) {
		fprintf(ttyout, "usage: %s local-directory\n", argv[0]);
		code = -1;
		return;
	}
	oldargv1 = argv[1];
	if (!globulize(&argv[1])) {
		code = -1;
		return;
	}
	if (chdir(argv[1]) < 0) {
		warn("local: %s", argv[1]);
		code = -1;
	} else {
		if (getcwd(buf, sizeof(buf)) != NULL)
			fprintf(ttyout, "Local directory now %s\n", buf);
		else
			warn("getcwd: %s", argv[1]);
		code = 0;
	}
	if (oldargv1 != argv[1])	/* free up after globulize() */
		free(argv[1]);
}

/*
 * Delete a single file.
 */
void
deletecmd(int argc, char *argv[])
{

	if ((argc < 2 && !another(&argc, &argv, "remote-file")) || argc > 2) {
		fprintf(ttyout, "usage: %s remote-file\n", argv[0]);
		code = -1;
		return;
	}
	(void)command("DELE %s", argv[1]);
}

/*
 * Delete multiple files.
 */
void
mdelete(int argc, char *argv[])
{
	sig_t oldintr;
	int ointer;
	char *cp;

	if (argc < 2 && !another(&argc, &argv, "remote-files")) {
		fprintf(ttyout, "usage: %s remote-files\n", argv[0]);
		code = -1;
		return;
	}
	mname = argv[0];
	mflag = 1;
	oldintr = signal(SIGINT, mabort);
	(void)setjmp(jabort);
	while ((cp = remglob(argv, 0, NULL)) != NULL) {
		if (*cp == '\0') {
			mflag = 0;
			continue;
		}
		if (mflag && confirm(argv[0], cp)) {
			(void)command("DELE %s", cp);
			if (!mflag && fromatty) {
				ointer = interactive;
				interactive = 1;
				if (confirm("Continue with", "mdelete")) {
					mflag++;
				}
				interactive = ointer;
			}
		}
	}
	(void)signal(SIGINT, oldintr);
	mflag = 0;
}

/*
 * Rename a remote file.
 */
void
renamefile(int argc, char *argv[])
{

	if (argc < 2 && !another(&argc, &argv, "from-name"))
		goto usage;
	if ((argc < 3 && !another(&argc, &argv, "to-name")) || argc > 3) {
usage:
		fprintf(ttyout, "usage: %s from-name to-name\n", argv[0]);
		code = -1;
		return;
	}
	if (command("RNFR %s", argv[1]) == CONTINUE)
		(void)command("RNTO %s", argv[2]);
}

/*
 * Get a directory listing of remote files.
 */
void
ls(int argc, char *argv[])
{
	const char *cmd;
	char *oldargv2, *globargv2;

	if (argc < 2)
		argc++, argv[1] = NULL;
	if (argc < 3)
		argc++, argv[2] = "-";
	if (argc > 3) {
		fprintf(ttyout, "usage: %s remote-directory local-file\n", argv[0]);
		code = -1;
		return;
	}
	cmd = strcmp(argv[0], "nlist") == 0 ? "NLST" : "LIST";
	oldargv2 = argv[2];
	if (strcmp(argv[2], "-") && !globulize(&argv[2])) {
		code = -1;
		return;
	}
	globargv2 = argv[2];
	if (strcmp(argv[2], "-") && *argv[2] != '|' && (!globulize(&argv[2]) ||
	    !confirm("output to local-file:", argv[2]))) {
		code = -1;
		goto freels;
	}
	recvrequest(cmd, argv[2], argv[1], "w", 0, 0);

	/* flush results in case commands are coming from a pipe */
	fflush(ttyout);
freels:
	if (argv[2] != globargv2)		/* free up after globulize() */
		free(argv[2]);
	if (globargv2 != oldargv2)
		free(globargv2);
}

/*
 * Get a directory listing of multiple remote files.
 */
void
mls(int argc, char *argv[])
{
	sig_t oldintr;
	int ointer, i;
	char lmode[1], *dest, *odest;

	if (argc < 2 && !another(&argc, &argv, "remote-files"))
		goto usage;
	if (argc < 3 && !another(&argc, &argv, "local-file")) {
usage:
		fprintf(ttyout, "usage: %s remote-files local-file\n", argv[0]);
		code = -1;
		return;
	}
	odest = dest = argv[argc - 1];
	argv[argc - 1] = NULL;
	if (strcmp(dest, "-") && *dest != '|')
		if (!globulize(&dest) ||
		    !confirm("output to local-file:", dest)) {
			code = -1;
			return;
	}
	mname = argv[0];
	mflag = 1;
	oldintr = signal(SIGINT, mabort);
	(void)setjmp(jabort);
	for (i = 1; mflag && i < argc-1; ++i) {
		*lmode = (i == 1) ? 'w' : 'a';
		recvrequest("LIST", dest, argv[i], lmode, 0, 0);
		if (!mflag && fromatty) {
			ointer = interactive;
			interactive = 1;
			if (confirm("Continue with", argv[0])) {
				mflag ++;
			}
			interactive = ointer;
		}
	}
	(void)signal(SIGINT, oldintr);
	mflag = 0;
	if (dest != odest)			/* free up after globulize() */
		free(dest);
}

/*
 * Do a shell escape
 */
/*ARGSUSED*/
void
shell(int argc, char *argv[])
{
	pid_t pid;
	sig_t old1, old2;
	char shellnam[MAXPATHLEN], *shellp, *namep;
	int wait_status;

	old1 = signal (SIGINT, SIG_IGN);
	old2 = signal (SIGQUIT, SIG_IGN);
	if ((pid = fork()) == 0) {
		for (pid = 3; pid < 20; pid++)
			(void)close(pid);
		(void)signal(SIGINT, SIG_DFL);
		(void)signal(SIGQUIT, SIG_DFL);
		shellp = getenv("SHELL");
		if (shellp == NULL || *shellp == '\0')
			shellp = _PATH_BSHELL;
		namep = strrchr(shellp, '/');
		if (namep == NULL)
			namep = shellp;
		shellnam[0] = '-';
		(void)strlcpy(shellnam + 1, ++namep, sizeof(shellnam) - 1);
		if (strcmp(namep, "sh") != 0)
			shellnam[0] = '+';
		if (debug) {
			fputs(shellp, ttyout);
			fputc('\n', ttyout);
			(void)fflush(ttyout);
		}
		if (argc > 1) {
			execl(shellp, shellnam, "-c", altarg, (char *)0);
		}
		else {
			execl(shellp, shellnam, (char *)0);
		}
		warn("%s", shellp);
		code = -1;
		exit(1);
	}
	if (pid > 0)
		while (wait(&wait_status) != pid)
			;
	(void)signal(SIGINT, old1);
	(void)signal(SIGQUIT, old2);
	if (pid == -1) {
		warn("Try again later");
		code = -1;
	}
	else {
		code = 0;
	}
}

/*
 * Send new user information (re-login)
 */
void
user(int argc, char *argv[])
{
	char acctname[80];
	int n, aflag = 0;

	if (argc < 2)
		(void)another(&argc, &argv, "username");
	if (argc < 2 || argc > 4) {
		fprintf(ttyout, "usage: %s username [password] [account]\n", argv[0]);
		code = -1;
		return;
	}
	n = command("USER %s", argv[1]);
	if (n == CONTINUE) {
		if (argc < 3 )
			argv[2] = getpass("Password: "), argc++;
		n = command("PASS %s", argv[2]);
	}
	if (n == CONTINUE) {
		if (argc < 4) {
			char *p;

			(void)fputs("Account: ", ttyout);
			(void)fflush(ttyout);
			if (fgets(acctname, sizeof(acctname), stdin) == NULL)
				goto fail;
			if ((p = strchr(acctname, '\n')) != NULL)
				*p = '\0';
			argv[3] = acctname;
			argc++;
		}
		n = command("ACCT %s", argv[3]);
		aflag++;
	}
	if (n != COMPLETE) {
 fail:
		fputs("Login failed.\n", ttyout);
		return;
	}
	if (!aflag && argc == 4) {
		(void)command("ACCT %s", argv[3]);
	}
	connected = -1;
}

/*
 * Print working directory on remote machine.
 */
/*ARGSUSED*/
void
pwd(int argc, char *argv[])
{
	int oldverbose = verbose;

	/*
	 * If we aren't verbose, this doesn't do anything!
	 */
	verbose = 1;
	if (command("PWD") == ERROR && code == 500) {
		fputs("PWD command not recognized, trying XPWD.\n", ttyout);
		(void)command("XPWD");
	}
	verbose = oldverbose;
}

/*
 * Print working directory on local machine.
 */
/* ARGSUSED */
void
lpwd(int argc, char *argv[])
{
	char buf[MAXPATHLEN];

	if (getcwd(buf, sizeof(buf)) != NULL)
		fprintf(ttyout, "Local directory %s\n", buf);
	else
		warn("getcwd");
	code = 0;
}

/*
 * Make a directory.
 */
void
makedir(int argc, char *argv[])
{

	if ((argc < 2 && !another(&argc, &argv, "directory-name")) ||
	    argc > 2) {
		fprintf(ttyout, "usage: %s directory-name\n", argv[0]);
		code = -1;
		return;
	}
	if (command("MKD %s", argv[1]) == ERROR && code == 500) {
		if (verbose)
			fputs("MKD command not recognized, trying XMKD.\n", ttyout);
		(void)command("XMKD %s", argv[1]);
	}
}

/*
 * Remove a directory.
 */
void
removedir(int argc, char *argv[])
{

	if ((argc < 2 && !another(&argc, &argv, "directory-name")) ||
	    argc > 2) {
		fprintf(ttyout, "usage: %s directory-name\n", argv[0]);
		code = -1;
		return;
	}
	if (command("RMD %s", argv[1]) == ERROR && code == 500) {
		if (verbose)
			fputs("RMD command not recognized, trying XRMD.\n", ttyout);
		(void)command("XRMD %s", argv[1]);
	}
}

/*
 * Send a line, verbatim, to the remote machine.
 */
void
quote(int argc, char *argv[])
{

	if (argc < 2 && !another(&argc, &argv, "command line to send")) {
		fprintf(ttyout, "usage: %s line-to-send\n", argv[0]);
		code = -1;
		return;
	}
	quote1("", argc, argv);
}

/*
 * Send a SITE command to the remote machine.  The line
 * is sent verbatim to the remote machine, except that the
 * word "SITE" is added at the front.
 */
void
site(int argc, char *argv[])
{

	if (argc < 2 && !another(&argc, &argv, "arguments to SITE command")) {
		fprintf(ttyout, "usage: %s line-to-send\n", argv[0]);
		code = -1;
		return;
	}
	quote1("SITE", argc, argv);
}

/*
 * Turn argv[1..argc) into a space-separated string, then prepend initial text.
 * Send the result as a one-line command and get response.
 */
void
quote1(const char *initial, int argc, char *argv[])
{
	int i, len;
	char buf[BUFSIZ];		/* must be >= sizeof(line) */

	(void)strlcpy(buf, initial, sizeof(buf));
	if (argc > 1) {
		for (i = 1, len = strlen(buf); i < argc && len < sizeof(buf)-1; i++) {
			/* Space for next arg */
			if (len > 1)
				buf[len++] = ' ';

			/* Sanity check */
			if (len >= sizeof(buf) - 1)
				break;

			/* Copy next argument, NUL terminate always */
			strlcpy(&buf[len], argv[i], sizeof(buf) - len);

			/* Update string length */
			len = strlen(buf);
		}
	}

	/* Make double (triple?) sure the sucker is NUL terminated */
	buf[sizeof(buf) - 1] = '\0';

	if (command("%s", buf) == PRELIM) {
		while (getreply(0) == PRELIM)
			continue;
	}
}

void
do_chmod(int argc, char *argv[])
{

	if (argc < 2 && !another(&argc, &argv, "mode"))
		goto usage;
	if ((argc < 3 && !another(&argc, &argv, "file-name")) || argc > 3) {
usage:
		fprintf(ttyout, "usage: %s mode file-name\n", argv[0]);
		code = -1;
		return;
	}
	(void)command("SITE CHMOD %s %s", argv[1], argv[2]);
}

void
do_umask(int argc, char *argv[])
{
	int oldverbose = verbose;

	verbose = 1;
	(void)command(argc == 1 ? "SITE UMASK" : "SITE UMASK %s", argv[1]);
	verbose = oldverbose;
}

void
idle(int argc, char *argv[])
{
	int oldverbose = verbose;

	verbose = 1;
	(void)command(argc == 1 ? "SITE IDLE" : "SITE IDLE %s", argv[1]);
	verbose = oldverbose;
}

/*
 * Ask the other side for help.
 */
void
rmthelp(int argc, char *argv[])
{
	int oldverbose = verbose;

	verbose = 1;
	(void)command(argc == 1 ? "HELP" : "HELP %s", argv[1]);
	verbose = oldverbose;
}

/*
 * Terminate session and exit.
 */
/*ARGSUSED*/
void
quit(int argc, char *argv[])
{

	if (connected)
		disconnect(0, 0);
	pswitch(1);
	if (connected) {
		disconnect(0, 0);
	}
	exit(0);
}

/*
 * Terminate session, but don't exit.
 */
/* ARGSUSED */
void
disconnect(int argc, char *argv[])
{

	if (!connected)
		return;
	(void)command("QUIT");
	if (cout) {
		(void)fclose(cout);
	}
	cout = NULL;
	connected = 0;
	data = -1;
	if (!proxy) {
		macnum = 0;
	}
}

void
account(int argc, char *argv[])
{
	char *ap;

	if (argc > 2) {
		fprintf(ttyout, "usage: %s [password]\n", argv[0]);
		code = -1;
		return;
	}
	else if (argc == 2)
		ap = argv[1];
	else
		ap = getpass("Account:");
	(void)command("ACCT %s", ap);
}

jmp_buf abortprox;

/* ARGSUSED */
void
proxabort(int signo)
{

	alarmtimer(0);
	if (!proxy) {
		pswitch(1);
	}
	if (connected) {
		proxflag = 1;
	}
	else {
		proxflag = 0;
	}
	pswitch(0);
	longjmp(abortprox, 1);
}

void
doproxy(int argc, char *argv[])
{
	struct cmd *c;
	int cmdpos;
	sig_t oldintr;

	if (argc < 2 && !another(&argc, &argv, "command")) {
		fprintf(ttyout, "usage: %s command\n", argv[0]);
		code = -1;
		return;
	}
	c = getcmd(argv[1]);
	if (c == (struct cmd *) -1) {
		fputs("?Ambiguous command.\n", ttyout);
		(void)fflush(ttyout);
		code = -1;
		return;
	}
	if (c == 0) {
		fputs("?Invalid command.\n", ttyout);
		(void)fflush(ttyout);
		code = -1;
		return;
	}
	if (!c->c_proxy) {
		fputs("?Invalid proxy command.\n", ttyout);
		(void)fflush(ttyout);
		code = -1;
		return;
	}
	if (setjmp(abortprox)) {
		code = -1;
		return;
	}
	oldintr = signal(SIGINT, proxabort);
	pswitch(1);
	if (c->c_conn && !connected) {
		fputs("Not connected.\n", ttyout);
		(void)fflush(ttyout);
		pswitch(0);
		(void)signal(SIGINT, oldintr);
		code = -1;
		return;
	}
	cmdpos = strcspn(line, " \t");
	if (cmdpos > 0)		/* remove leading "proxy " from input buffer */
		memmove(line, line + cmdpos + 1, strlen(line) - cmdpos + 1);
	(*c->c_handler)(argc-1, argv+1);
	if (connected) {
		proxflag = 1;
	}
	else {
		proxflag = 0;
	}
	pswitch(0);
	(void)signal(SIGINT, oldintr);
}

void
setcase(int argc, char *argv[])
{

	code = togglevar(argc, argv, &mcase, "Case mapping");
}

void
setcr(int argc, char *argv[])
{

	code = togglevar(argc, argv, &crflag, "Carriage Return stripping");
}

void
setntrans(int argc, char *argv[])
{
	if (argc == 1) {
		ntflag = 0;
		fputs("Ntrans off.\n", ttyout);
		code = ntflag;
		return;
	}
	ntflag++;
	code = ntflag;
	(void)strlcpy(ntin, argv[1], sizeof(ntin));
	if (argc == 2) {
		ntout[0] = '\0';
		return;
	}
	(void)strlcpy(ntout, argv[2], sizeof(ntout));
}

char *
dotrans(char *name)
{
	static char new[MAXPATHLEN];
	char *cp1, *cp2 = new;
	int i, ostop, found;

	for (ostop = 0; *(ntout + ostop) && ostop < 16; ostop++)
		continue;
	for (cp1 = name; *cp1; cp1++) {
		found = 0;
		for (i = 0; *(ntin + i) && i < 16; i++) {
			if (*cp1 == *(ntin + i)) {
				found++;
				if (i < ostop) {
					*cp2++ = *(ntout + i);
				}
				break;
			}
		}
		if (!found) {
			*cp2++ = *cp1;
		}
	}
	*cp2 = '\0';
	return (new);
}

void
setnmap(int argc, char *argv[])
{
	char *cp;

	if (argc == 1) {
		mapflag = 0;
		fputs("Nmap off.\n", ttyout);
		code = mapflag;
		return;
	}
	if ((argc < 3 && !another(&argc, &argv, "mapout")) || argc > 3) {
		fprintf(ttyout, "usage: %s [mapin mapout]\n", argv[0]);
		code = -1;
		return;
	}
	mapflag = 1;
	code = 1;
	cp = strchr(altarg, ' ');
	if (proxy) {
		while(*++cp == ' ')
			continue;
		altarg = cp;
		cp = strchr(altarg, ' ');
	}
	*cp = '\0';
	(void)strncpy(mapin, altarg, MAXPATHLEN - 1);
	while (*++cp == ' ')
		continue;
	(void)strncpy(mapout, cp, MAXPATHLEN - 1);
}

char *
domap(char *name)
{
	static char new[MAXPATHLEN];
	char *cp1 = name, *cp2 = mapin;
	char *tp[9], *te[9];
	int i, toks[9], toknum = 0, match = 1;

	for (i=0; i < 9; ++i) {
		toks[i] = 0;
	}
	while (match && *cp1 && *cp2) {
		switch (*cp2) {
			case '\\':
				if (*++cp2 != *cp1) {
					match = 0;
				}
				break;
			case '$':
				if (*(cp2+1) >= '1' && (*cp2+1) <= '9') {
					if (*cp1 != *(++cp2+1)) {
						toks[toknum = *cp2 - '1']++;
						tp[toknum] = cp1;
						while (*++cp1 && *(cp2+1)
							!= *cp1);
						te[toknum] = cp1;
					}
					cp2++;
					break;
				}
				/* FALLTHROUGH */
			default:
				if (*cp2 != *cp1) {
					match = 0;
				}
				break;
		}
		if (match && *cp1) {
			cp1++;
		}
		if (match && *cp2) {
			cp2++;
		}
	}
	if (!match && *cp1) /* last token mismatch */
	{
		toks[toknum] = 0;
	}
	cp1 = new;
	*cp1 = '\0';
	cp2 = mapout;
	while (*cp2) {
		match = 0;
		switch (*cp2) {
			case '\\':
				if (*(cp2 + 1)) {
					*cp1++ = *++cp2;
				}
				break;
			case '[':
LOOP:
				if (*++cp2 == '$' && isdigit(*(cp2+1))) {
					if (*++cp2 == '0') {
						char *cp3 = name;

						while (*cp3) {
							*cp1++ = *cp3++;
						}
						match = 1;
					}
					else if (toks[toknum = *cp2 - '1']) {
						char *cp3 = tp[toknum];

						while (cp3 != te[toknum]) {
							*cp1++ = *cp3++;
						}
						match = 1;
					}
				}
				else {
					while (*cp2 && *cp2 != ',' &&
					    *cp2 != ']') {
						if (*cp2 == '\\') {
							cp2++;
						}
						else if (*cp2 == '$' &&
   						        isdigit(*(cp2+1))) {
							if (*++cp2 == '0') {
							   char *cp3 = name;

							   while (*cp3) {
								*cp1++ = *cp3++;
							   }
							}
							else if (toks[toknum =
							    *cp2 - '1']) {
							   char *cp3=tp[toknum];

							   while (cp3 !=
								  te[toknum]) {
								*cp1++ = *cp3++;
							   }
							}
						}
						else if (*cp2) {
							*cp1++ = *cp2++;
						}
					}
					if (!*cp2) {
						fputs(
"nmap: unbalanced brackets.\n", ttyout);
						return (name);
					}
					match = 1;
					cp2--;
				}
				if (match) {
					while (*++cp2 && *cp2 != ']') {
					      if (*cp2 == '\\' && *(cp2 + 1)) {
							cp2++;
					      }
					}
					if (!*cp2) {
						fputs(
"nmap: unbalanced brackets.\n", ttyout);
						return (name);
					}
					break;
				}
				switch (*++cp2) {
					case ',':
						goto LOOP;
					case ']':
						break;
					default:
						cp2--;
						goto LOOP;
				}
				break;
			case '$':
				if (isdigit(*(cp2 + 1))) {
					if (*++cp2 == '0') {
						char *cp3 = name;

						while (*cp3) {
							*cp1++ = *cp3++;
						}
					}
					else if (toks[toknum = *cp2 - '1']) {
						char *cp3 = tp[toknum];

						while (cp3 != te[toknum]) {
							*cp1++ = *cp3++;
						}
					}
					break;
				}
				/* FALLTHROUGH */
			default:
				*cp1++ = *cp2;
				break;
		}
		cp2++;
	}
	*cp1 = '\0';
	if (!*new) {
		return (name);
	}
	return (new);
}

void
setpassive(int argc, char *argv[])
{

	code = togglevar(argc, argv, &passivemode,
	    verbose ? "Passive mode" : NULL);
}

void
setsunique(int argc, char *argv[])
{

	code = togglevar(argc, argv, &sunique, "Store unique");
}

void
setrunique(int argc, char *argv[])
{

	code = togglevar(argc, argv, &runique, "Receive unique");
}

/* change directory to parent directory */
/* ARGSUSED */
void
cdup(int argc, char *argv[])
{
	int r;

	r = command("CDUP");
	if (r == ERROR && code == 500) {
		if (verbose)
			fputs("CDUP command not recognized, trying XCUP.\n", ttyout);
		r = command("XCUP");
	}
	if (r == COMPLETE)
		dirchange = 1;
}

/*
 * Restart transfer at specific point
 */
void
restart(int argc, char *argv[])
{
	quad_t nrestart_point;
	char *ep;

	if (argc != 2)
		fputs("restart: offset not specified.\n", ttyout);
	else {
		nrestart_point = strtoq(argv[1], &ep, 10);
		if (nrestart_point == QUAD_MAX || *ep != '\0')
			fputs("restart: invalid offset.\n", ttyout);
		else {
			fprintf(ttyout, "Restarting at %lld. Execute get, put "
				"or append to initiate transfer\n",
				(long long)nrestart_point);
			restart_point = nrestart_point;
		}
	}
}

/* 
 * Show remote system type
 */
/* ARGSUSED */
void
syst(int argc, char *argv[])
{

	(void)command("SYST");
}

void
macdef(int argc, char *argv[])
{
	char *tmp;
	int c;

	if (macnum == 16) {
		fputs("Limit of 16 macros have already been defined.\n", ttyout);
		code = -1;
		return;
	}
	if ((argc < 2 && !another(&argc, &argv, "macro name")) || argc > 2) {
		fprintf(ttyout, "usage: %s macro_name\n", argv[0]);
		code = -1;
		return;
	}
	if (interactive)
		fputs(
"Enter macro line by line, terminating it with a null line.\n", ttyout);
	(void)strlcpy(macros[macnum].mac_name, argv[1],
	    sizeof(macros[macnum].mac_name));
	if (macnum == 0)
		macros[macnum].mac_start = macbuf;
	else
		macros[macnum].mac_start = macros[macnum - 1].mac_end + 1;
	tmp = macros[macnum].mac_start;
	while (tmp != macbuf+4096) {
		if ((c = getchar()) == EOF) {
			fputs("macdef: end of file encountered.\n", ttyout);
			code = -1;
			return;
		}
		if ((*tmp = c) == '\n') {
			if (tmp == macros[macnum].mac_start) {
				macros[macnum++].mac_end = tmp;
				code = 0;
				return;
			}
			if (*(tmp-1) == '\0') {
				macros[macnum++].mac_end = tmp - 1;
				code = 0;
				return;
			}
			*tmp = '\0';
		}
		tmp++;
	}
	while (1) {
		while ((c = getchar()) != '\n' && c != EOF)
			;	/* nothing */
		if (c == EOF || getchar() == '\n') {
			fputs("Macro not defined - 4K buffer exceeded.\n", ttyout);
			code = -1;
			return;
		}
	}
}

/*
 * Get size of file on remote machine
 */
void
sizecmd(int argc, char *argv[])
{
	off_t size;

	if ((argc < 2 && !another(&argc, &argv, "filename")) || argc > 2) {
		fprintf(ttyout, "usage: %s filename\n", argv[0]);
		code = -1;
		return;
	}
	size = remotesize(argv[1], 1);
	if (size != -1)
		fprintf(ttyout, "%s\t%lld\n", argv[1], (long long)size);
	code = size;
}

/*
 * Get last modification time of file on remote machine
 */
void
modtime(int argc, char *argv[])
{
	time_t mtime;

	if ((argc < 2 && !another(&argc, &argv, "filename")) || argc > 2) {
		fprintf(ttyout, "usage: %s filename\n", argv[0]);
		code = -1;
		return;
	}
	mtime = remotemodtime(argv[1], 1);
	if (mtime != -1)
		fprintf(ttyout, "%s\t%s", argv[1], asctime(localtime(&mtime)));
	code = mtime;
}

/*
 * Show status on remote machine
 */
void
rmtstatus(int argc, char *argv[])
{

	(void)command(argc > 1 ? "STAT %s" : "STAT" , argv[1]);
}

/*
 * Get file if modtime is more recent than current file
 */
void
newer(int argc, char *argv[])
{

	if (getit(argc, argv, -1, "w"))
		fprintf(ttyout, "Local file \"%s\" is newer than remote file \"%s\".\n",
			argv[2], argv[1]);
}

/*
 * Display one file through $PAGER (defaults to "more").
 */
void
page(int argc, char *argv[])
{
	int orestart_point, ohash, overbose;
	char *p, *pager, *oldargv1;

	if ((argc < 2 && !another(&argc, &argv, "filename")) || argc > 2) {
		fprintf(ttyout, "usage: %s filename\n", argv[0]);
		code = -1;
		return;
	}
	oldargv1 = argv[1];
	if (!globulize(&argv[1])) {
		code = -1;
		return;
	}
	p = getenv("PAGER");
	if (p == NULL || (*p == '\0'))
		p = PAGER;
	if (asprintf(&pager, "|%s", p) == -1)
		errx(1, "Can't allocate memory for $PAGER");

	orestart_point = restart_point;
	ohash = hash;
	overbose = verbose;
	restart_point = hash = verbose = 0;
	recvrequest("RETR", pager, argv[1], "r+w", 1, 0);
	(void)free(pager);
	restart_point = orestart_point;
	hash = ohash;
	verbose = overbose;
	if (oldargv1 != argv[1])	/* free up after globulize() */
		free(argv[1]);
}
@


1.6
log
@we can build SPARC again, but only with a tad more floppy squeezing
@
text
@d83 1
a83 1
__RCSID("$MirOS: src/usr.bin/ftp/cmds.c,v 1.5 2007/07/15 20:01:07 tg Exp $");
d2023 1
a2023 1
			/* LOOP */;
@


1.5
log
@fastmerge and fix their bugs (tree breaker, but they don't seem to care,
it's been broken for 25 days…)
@
text
@d83 1
a83 1
__RCSID("$MirOS: src/usr.bin/ftp/cmds.c,v 1.4 2006/10/03 19:22:16 tg Exp $");
d98 1
d101 1
d174 1
d178 1
d215 1
d227 1
d634 1
d700 1
@


1.4
log
@merge
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.52 2006/05/19 04:05:35 ray Exp $	*/
d83 1
a83 1
__RCSID("$MirOS: src/usr.bin/ftp/cmds.c,v 1.3 2005/04/29 18:35:08 tg Exp $");
d532 1
d1273 2
d1277 4
a1280 2
			(void)fgets(acctname, sizeof(acctname) - 1, stdin);
			acctname[strlen(acctname) - 1] = '\0';
d1288 1
@


1.3
log
@(tentative) merge, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.48 2004/09/16 04:39:16 deraadt Exp $	*/
d83 1
a83 1
__RCSID("$MirOS: src/usr.bin/ftp/cmds.c,v 1.2 2005/03/15 18:44:51 tg Exp $");
d566 1
a566 1
	char *cp, *tp, *tp2, tmpbuf[MAXPATHLEN];
d575 3
d585 8
a592 1
		if (mflag && confirm(argv[0], cp)) {
d780 2
a781 2
		long nmark;
		char *ep;
d783 4
a786 3
		nmark = strtol(argv[1], &ep, 10);
		if (nmark < 1 || nmark > INT_MAX || *ep != '\0') {
			fprintf(ttyout, "%s: bad bytecount value.\n", argv[1]);
d942 2
a943 2
			char *ep;
			long val;
d945 4
a948 4
			val = strtol(argv[1], &ep, 10);
			if (val < 0 || val > INT_MAX || *ep != '\0') {
				fprintf(ttyout, "%s: bad debugging value.\n",
				    argv[1]);
d952 1
a952 1
			debug = (int)val;
d1150 1
a1150 1
	char mode[1], *dest, *odest;
d1173 2
a1174 2
		*mode = (i == 1) ? 'w' : 'a';
		recvrequest("LIST", dest, argv[i], mode, 0, 0);
d1199 1
a1199 1
	char shellnam[MAXPATHLEN], *shell, *namep;
d1209 4
a1212 4
		shell = getenv("SHELL");
		if (shell == NULL || *shell == '\0')
			shell = _PATH_BSHELL;
		namep = strrchr(shell, '/');
d1214 1
a1214 1
			namep = shell;
d1220 1
a1220 1
			fputs(shell, ttyout);
d1225 1
a1225 1
			execl(shell, shellnam, "-c", altarg, (char *)0);
d1228 1
a1228 1
			execl(shell, shellnam, (char *)0);
d1230 1
a1230 1
		warn("%s", shell);
d1254 1
a1254 1
	char acct[80];
d1274 4
a1277 3
			(void)fgets(acct, sizeof(acct) - 1, stdin);
			acct[strlen(acct) - 1] = '\0';
			argv[3] = acct; argc++;
a1412 5

			/* Sanity check */
			if (len >= sizeof(buf) - 1)
				break;

d1872 1
a1872 1
				/* intentional drop through */
@


1.2
log
@rather than fixing
/usr/src/usr.bin/ftp/cmds.c:63: warning: 'rcsid' defined but not used
just convert to __RCSID() macro
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.46 2003/12/16 21:46:22 deraadt Exp $	*/
d83 1
a83 1
__RCSID("$MirOS$");
d107 1
a107 3
settype(argc, argv)
	int argc;
	char *argv[];
d154 1
a154 2
changetype(newtype, show)
	int newtype, show;
d190 1
a190 1
/*VARARGS*/
d192 1
a192 3
setbinary(argc, argv)
	int argc;
	char *argv[];
d202 1
a202 1
/*VARARGS*/
d204 1
a204 3
setascii(argc, argv)
	int argc;
	char *argv[];
d214 1
a214 1
/*VARARGS*/
d216 1
a216 3
settenex(argc, argv)
	int argc;
	char *argv[];
d228 1
a228 3
setftmode(argc, argv)
	int argc;
	char *argv[];
d240 1
a240 3
setform(argc, argv)
	int argc;
	char *argv[];
d252 1
a252 3
setstruct(argc, argv)
	int argc;
	char *argv[];
d263 1
a263 3
put(argc, argv)
	int argc;
	char *argv[];
d312 1
a312 3
mput(argc, argv)
	int argc;
	char *argv[];
d431 1
a431 3
reget(argc, argv)
	int argc;
	char *argv[];
d438 1
a438 3
get(argc, argv)
	int argc;
	char *argv[];
d448 1
a448 5
getit(argc, argv, restartit, mode)
	int argc;
	char *argv[];
	int restartit;
	const char *mode;
d534 1
a534 2
mabort(signo)
	int signo;
d562 1
a562 3
mget(argc, argv)
	int argc;
	char *argv[];
d611 1
a611 2
onoff(bool)
	int bool;
d622 1
a622 3
status(argc, argv)
	int argc;
	char *argv[];
d687 1
a687 5
togglevar(argc, argv, var, mesg)
	int   argc;
	char *argv[];
	int  *var;
	const char *mesg;
d707 1
a707 1
/*VARARGS*/
d709 1
a709 3
setbell(argc, argv)
	int argc;
	char *argv[];
d719 1
a719 1
/*VARARGS*/
d721 1
a721 3
setedit(argc, argv)
	int argc;
	char *argv[];
d732 1
a732 1
/*VARARGS*/
d734 1
a734 3
setepsv4(argc, argv)
	int argc;
	char *argv[];
d744 1
a744 1
/*VARARGS*/
d746 1
a746 3
settrace(argc, argv)
	int argc;
	char *argv[];
d755 1
a755 1
/*VARARGS*/
d757 1
a757 3
sethash(argc, argv)
	int argc;
	char *argv[];
d792 1
a792 1
/*VARARGS*/
d794 1
a794 3
setverbose(argc, argv)
	int argc;
	char *argv[];
d803 1
a803 1
/*VARARGS*/
d805 1
a805 3
setport(argc, argv)
	int argc;
	char *argv[];
d814 1
a814 1
/*VARARGS*/
d816 1
a816 3
setprogress(argc, argv)
	int argc;
	char *argv[];
d825 1
a825 1
/*VARARGS*/
d827 1
a827 3
setprompt(argc, argv)
	int argc;
	char *argv[];
d836 1
a836 1
/*VARARGS*/
d838 1
a838 3
setgate(argc, argv)
	int argc;
	char *argv[];
d895 1
a895 1
/*VARARGS*/
d897 1
a897 3
setglob(argc, argv)
	int argc;
	char *argv[];
d906 1
a906 1
/*VARARGS*/
d908 1
a908 3
setpreserve(argc, argv)
	int argc;
	char *argv[];
d917 1
a917 1
/*VARARGS*/
d919 1
a919 3
setdebug(argc, argv)
	int argc;
	char *argv[];
d957 1
a957 3
cd(argc, argv)
	int argc;
	char *argv[];
d985 1
a985 3
lcd(argc, argv)
	int argc;
	char *argv[];
d1020 1
a1020 3
delete(argc, argv)
	int argc;
	char *argv[];
d1035 1
a1035 3
mdelete(argc, argv)
	int argc;
	char *argv[];
d1075 1
a1075 3
renamefile(argc, argv)
	int argc;
	char *argv[];
d1094 1
a1094 3
ls(argc, argv)
	int argc;
	char *argv[];
d1135 1
a1135 3
mls(argc, argv)
	int argc;
	char *argv[];
d1184 1
a1184 3
shell(argc, argv)
	int argc;
	char *argv[];
d1241 1
a1241 3
user(argc, argv)
	int argc;
	char *argv[];
d1283 1
a1283 1
/*VARARGS*/
d1285 1
a1285 3
pwd(argc, argv)
	int argc;
	char *argv[];
d1303 1
d1305 1
a1305 3
lpwd(argc, argv)
	int argc;
	char *argv[];
d1320 1
a1320 3
makedir(argc, argv)
	int argc;
	char *argv[];
d1340 1
a1340 3
removedir(argc, argv)
	int argc;
	char *argv[];
d1360 1
a1360 3
quote(argc, argv)
	int argc;
	char *argv[];
d1377 1
a1377 3
site(argc, argv)
	int argc;
	char *argv[];
d1393 1
a1393 4
quote1(initial, argc, argv)
	const char *initial;
	int argc;
	char *argv[];
d1432 1
a1432 3
do_chmod(argc, argv)
	int argc;
	char *argv[];
d1447 1
a1447 3
do_umask(argc, argv)
	int argc;
	char *argv[];
d1457 1
a1457 3
idle(argc, argv)
	int argc;
	char *argv[];
d1470 1
a1470 3
rmthelp(argc, argv)
	int argc;
	char *argv[];
d1482 1
a1482 1
/*VARARGS*/
d1484 1
a1484 3
quit(argc, argv)
	int argc;
	char *argv[];
d1499 1
d1501 1
a1501 3
disconnect(argc, argv)
	int argc;
	char *argv[];
d1519 1
a1519 3
account(argc, argv)
	int argc;
	char *argv[];
d1537 1
d1539 1
a1539 2
proxabort(notused)
	int notused;
d1557 1
a1557 3
doproxy(argc, argv)
	int argc;
	char *argv[];
d1616 1
a1616 3
setcase(argc, argv)
	int argc;
	char *argv[];
d1623 1
a1623 3
setcr(argc, argv)
	int argc;
	char *argv[];
d1630 1
a1630 3
setntrans(argc, argv)
	int argc;
	char *argv[];
d1649 1
a1649 2
dotrans(name)
	char *name;
d1677 1
a1677 3
setnmap(argc, argv)
	int argc;
	char *argv[];
d1709 1
a1709 2
domap(name)
	char *name;
d1880 1
a1880 3
setpassive(argc, argv)
	int argc;
	char *argv[];
d1888 1
a1888 3
setsunique(argc, argv)
	int argc;
	char *argv[];
d1895 1
a1895 3
setrunique(argc, argv)
	int argc;
	char *argv[];
d1902 1
d1904 1
a1904 3
cdup(argc, argv)
	int argc;
	char *argv[];
d1922 1
a1922 3
restart(argc, argv)
	int argc;
	char *argv[];
d1945 1
d1947 1
a1947 3
syst(argc, argv)
	int argc;
	char *argv[];
d1954 1
a1954 3
macdef(argc, argv)
	int argc;
	char *argv[];
d2015 1
a2015 3
sizecmd(argc, argv)
	int argc;
	char *argv[];
d2034 1
a2034 3
modtime(argc, argv)
	int argc;
	char *argv[];
d2053 1
a2053 3
rmtstatus(argc, argv)
	int argc;
	char *argv[];
d2063 1
a2063 3
newer(argc, argv)
	int argc;
	char *argv[];
d2075 1
a2075 3
page(argc, argv)
	int argc;
	char *argv[];
@


1.1
log
@Initial revision
@
text
@a61 4
#if !defined(lint) && !defined(SMALL)
static char rcsid[] = "$OpenBSD: cmds.c,v 1.46 2003/12/16 21:46:22 deraadt Exp $";
#endif /* not lint and not SMALL */

d83 2
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@improve my Frankenstein OS (*wink* you know who you are) further
sans wchar_t of course

this is the essence of reading >1200 commit messages which suck
due to not having the new format of ours...
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.48 2004/09/16 04:39:16 deraadt Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.48 2004/09/16 04:39:16 deraadt Exp $";
d109 3
a111 1
settype(int argc, char *argv[])
d158 2
a159 1
changetype(int newtype, int show)
d195 1
a195 1
/*ARGSUSED*/
d197 3
a199 1
setbinary(int argc, char *argv[])
d209 1
a209 1
/*ARGSUSED*/
d211 3
a213 1
setascii(int argc, char *argv[])
d223 1
a223 1
/*ARGSUSED*/
d225 3
a227 1
settenex(int argc, char *argv[])
d239 3
a241 1
setftmode(int argc, char *argv[])
d253 3
a255 1
setform(int argc, char *argv[])
d267 3
a269 1
setstruct(int argc, char *argv[])
d280 3
a282 1
put(int argc, char *argv[])
d331 3
a333 1
mput(int argc, char *argv[])
d452 3
a454 1
reget(int argc, char *argv[])
d461 3
a463 1
get(int argc, char *argv[])
d473 5
a477 1
getit(int argc, char *argv[], int restartit, const char *mode)
d563 2
a564 1
mabort(int signo)
d592 3
a594 1
mget(int argc, char *argv[])
d643 2
a644 1
onoff(int bool)
d655 3
a657 1
status(int argc, char *argv[])
d722 5
a726 1
togglevar(int argc, char *argv[], int *var, const char *mesg)
d746 1
a746 1
/*ARGSUSED*/
d748 3
a750 1
setbell(int argc, char *argv[])
d760 1
a760 1
/*ARGSUSED*/
d762 3
a764 1
setedit(int argc, char *argv[])
d775 1
a775 1
/*ARGSUSED*/
d777 3
a779 1
setepsv4(int argc, char *argv[])
d789 1
a789 1
/*ARGSUSED*/
d791 3
a793 1
settrace(int argc, char *argv[])
d802 1
a802 1
/*ARGSUSED*/
d804 3
a806 1
sethash(int argc, char *argv[])
d841 1
a841 1
/*ARGSUSED*/
d843 3
a845 1
setverbose(int argc, char *argv[])
d854 1
a854 1
/*ARGSUSED*/
d856 3
a858 1
setport(int argc, char *argv[])
d867 1
a867 1
/*ARGSUSED*/
d869 3
a871 1
setprogress(int argc, char *argv[])
d880 1
a880 1
/*ARGSUSED*/
d882 3
a884 1
setprompt(int argc, char *argv[])
d893 1
a893 1
/*ARGSUSED*/
d895 3
a897 1
setgate(int argc, char *argv[])
d954 1
a954 1
/*ARGSUSED*/
d956 3
a958 1
setglob(int argc, char *argv[])
d967 1
a967 1
/*ARGSUSED*/
d969 3
a971 1
setpreserve(int argc, char *argv[])
d980 1
a980 1
/*ARGSUSED*/
d982 3
a984 1
setdebug(int argc, char *argv[])
d1022 3
a1024 1
cd(int argc, char *argv[])
d1052 3
a1054 1
lcd(int argc, char *argv[])
d1089 3
a1091 1
deletecmd(int argc, char *argv[])
d1106 3
a1108 1
mdelete(int argc, char *argv[])
d1148 3
a1150 1
renamefile(int argc, char *argv[])
d1169 3
a1171 1
ls(int argc, char *argv[])
d1212 3
a1214 1
mls(int argc, char *argv[])
d1263 3
a1265 1
shell(int argc, char *argv[])
d1322 3
a1324 1
user(int argc, char *argv[])
d1366 1
a1366 1
/*ARGSUSED*/
d1368 3
a1370 1
pwd(int argc, char *argv[])
a1387 1
/* ARGSUSED */
d1389 3
a1391 1
lpwd(int argc, char *argv[])
d1406 3
a1408 1
makedir(int argc, char *argv[])
d1428 3
a1430 1
removedir(int argc, char *argv[])
d1450 3
a1452 1
quote(int argc, char *argv[])
d1469 3
a1471 1
site(int argc, char *argv[])
d1487 4
a1490 1
quote1(const char *initial, int argc, char *argv[])
d1529 3
a1531 1
do_chmod(int argc, char *argv[])
d1546 3
a1548 1
do_umask(int argc, char *argv[])
d1558 3
a1560 1
idle(int argc, char *argv[])
d1573 3
a1575 1
rmthelp(int argc, char *argv[])
d1587 1
a1587 1
/*ARGSUSED*/
d1589 3
a1591 1
quit(int argc, char *argv[])
a1605 1
/* ARGSUSED */
d1607 3
a1609 1
disconnect(int argc, char *argv[])
d1627 3
a1629 1
account(int argc, char *argv[])
a1646 1
/* ARGSUSED */
d1648 2
a1649 1
proxabort(int signo)
d1667 3
a1669 1
doproxy(int argc, char *argv[])
d1728 3
a1730 1
setcase(int argc, char *argv[])
d1737 3
a1739 1
setcr(int argc, char *argv[])
d1746 3
a1748 1
setntrans(int argc, char *argv[])
d1767 2
a1768 1
dotrans(char *name)
d1796 3
a1798 1
setnmap(int argc, char *argv[])
d1830 2
a1831 1
domap(char *name)
d2002 3
a2004 1
setpassive(int argc, char *argv[])
d2012 3
a2014 1
setsunique(int argc, char *argv[])
d2021 3
a2023 1
setrunique(int argc, char *argv[])
a2029 1
/* ARGSUSED */
d2031 3
a2033 1
cdup(int argc, char *argv[])
d2051 3
a2053 1
restart(int argc, char *argv[])
a2075 1
/* ARGSUSED */
d2077 3
a2079 1
syst(int argc, char *argv[])
d2086 3
a2088 1
macdef(int argc, char *argv[])
d2149 3
a2151 1
sizecmd(int argc, char *argv[])
d2170 3
a2172 1
modtime(int argc, char *argv[])
d2191 3
a2193 1
rmtstatus(int argc, char *argv[])
d2203 3
a2205 1
newer(int argc, char *argv[])
d2217 3
a2219 1
page(int argc, char *argv[])
@


1.1.1.3
log
@Import OpenBSD 4.0's ftp(1) which downgraded to HTTP/1.0
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.52 2006/05/19 04:05:35 ray Exp $	*/
d63 1
a63 1
static const char rcsid[] = "$OpenBSD: cmds.c,v 1.52 2006/05/19 04:05:35 ray Exp $";
d568 1
a568 1
	char *cp, *tp, *tp2, tmpbuf[MAXPATHLEN], localcwd[MAXPATHLEN];
a576 3
	if (getcwd(localcwd, sizeof(localcwd)) == NULL)
		err(1, "can't get cwd");

d584 1
a584 8
		if (!mflag)
			continue;
		if (!fileindir(cp, localcwd)) {
			fprintf(ttyout, "Skipping non-relative filename `%s'\n",
			    cp);
			continue;
		}
		if (confirm(argv[0], cp)) {
d772 2
a773 2
		int nmark;
		const char *errstr;
d775 3
a777 4
		nmark = strtonum(argv[1], 1, INT_MAX, &errstr);
		if (errstr) {
			fprintf(ttyout, "bytecount value is %s: %s\n",
			    errstr, argv[1]);
d933 2
a934 2
			const char *errstr;
			int val;
d936 4
a939 4
			val = strtonum(argv[1], 0, INT_MAX, &errstr);
			if (errstr) {
				fprintf(ttyout, "debugging value is %s: %s\n",
				    errstr, argv[1]);
d943 1
a943 1
			debug = val;
d1141 1
a1141 1
	char lmode[1], *dest, *odest;
d1164 2
a1165 2
		*lmode = (i == 1) ? 'w' : 'a';
		recvrequest("LIST", dest, argv[i], lmode, 0, 0);
d1190 1
a1190 1
	char shellnam[MAXPATHLEN], *shellp, *namep;
d1200 4
a1203 4
		shellp = getenv("SHELL");
		if (shellp == NULL || *shellp == '\0')
			shellp = _PATH_BSHELL;
		namep = strrchr(shellp, '/');
d1205 1
a1205 1
			namep = shellp;
d1211 1
a1211 1
			fputs(shellp, ttyout);
d1216 1
a1216 1
			execl(shellp, shellnam, "-c", altarg, (char *)0);
d1219 1
a1219 1
			execl(shellp, shellnam, (char *)0);
d1221 1
a1221 1
		warn("%s", shellp);
d1245 1
a1245 1
	char acctname[80];
d1265 3
a1267 4
			(void)fgets(acctname, sizeof(acctname) - 1, stdin);
			acctname[strlen(acctname) - 1] = '\0';
			argv[3] = acctname;
			argc++;
d1403 5
d1867 1
a1867 1
				/* FALLTHROUGH */
@


1.1.1.4
log
@the FTP on-the wire protocol must die, but we nevertheless could use -k
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.55 2006/11/22 04:08:35 ray Exp $	*/
d63 1
a63 1
static const char rcsid[] = "$OpenBSD: cmds.c,v 1.55 2006/11/22 04:08:35 ray Exp $";
a533 1
/* XXX - Signal race. */
a1273 2
			char *p;

d1276 2
a1277 4
			if (fgets(acctname, sizeof(acctname), stdin) == NULL)
				goto fail;
			if ((p = strchr(acctname, '\n')) != NULL)
				*p = '\0';
a1284 1
 fail:
@


