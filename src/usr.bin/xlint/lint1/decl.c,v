head	1.3;
access;
symbols
	cvs-201204081600:1.1.1.2
	MIRBSD_10:1.2.0.4
	MIRBSD_10_BASE:1.2
	MIRBSD_9_BASE:1.2
	MIRBSD_8:1.2.0.2
	MIRBSD_8_BASE:1.2
	cvs-200507211800:1.1.1.1
	cvs-200504261445:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2014.03.23.20.57.12;	author tg;	state Exp;
branches;
next	1.2;
commitid	100532F4ABF526283C8;

1.2
date	2005.04.17.01.16.30;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.30.18;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.30.18;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.03.23.20.40.26;	author tg;	state Exp;
branches;
next	;
commitid	100532F46D2072D4091;


desc
@@


1.3
log
@merge
@
text
@/*	$OpenBSD: decl.c,v 1.30 2011/09/21 18:08:07 jsg Exp $	*/
/*	$NetBSD: decl.c,v 1.11 1995/10/02 17:34:16 jpo Exp $	*/

/*
 * Copyright (c) 1994, 1995 Jochen Pohl
 * All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Jochen Pohl for
 *	The NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#include "lint1.h"

__RCSID("$MirOS: src/usr.bin/xlint/lint1/decl.c,v 1.2 2005/04/17 01:16:30 tg Exp $");

const	char *unnamed = "<unnamed>";

/* contains various information and classification on types */
ttab_t	ttab[NTSPEC];

/* shared type structures for arithmetic types and void */
static	type_t	*typetab;

/* value of next enumerator during declaration of enum types */
int	enumval;

/*
 * pointer to top element of a stack which contains informations local
 * to nested declarations
 */
dinfo_t	*dcs;

static	type_t	*tdeferr(type_t *, tspec_t);
static	void	settdsym(type_t *, sym_t *);
static	tspec_t	mrgtspec(tspec_t, tspec_t);
static	void	align(int, int);
static	sym_t	*newtag(sym_t *, scl_t, int, int);
static	int	eqargs(type_t *, type_t *, int *);
static	int	mnoarg(type_t *, int *);
static	int	chkosdef(sym_t *, sym_t *);
static	int	chkptdecl(sym_t *, sym_t *);
static	sym_t	*nsfunc(sym_t *, sym_t *);
static	void	osfunc(sym_t *, sym_t *);
static	void	ledecl(sym_t *);
static	int	chkinit(sym_t *);
static	void	chkausg(int, sym_t *);
static	void	chkvusg(int, sym_t *);
static	void	chklusg(sym_t *);
static	void	chktusg(sym_t *);
static	void	chkglvar(sym_t *);
static	void	glchksz(sym_t *);

/*
 * initializes all global vars used in declarations
 */
void
initdecl(void)
{
	int	i;
	static	struct {
		tspec_t	it_tspec;
		ttab_t	it_ttab;
	} ittab[] = {
		{ SIGNED,   { 0, 0, 0,
			      SIGNED, UNSIGN,
			      0, 0, 0, 0, 0, "signed" } },
		{ UNSIGN,   { 0, 0, 0,
			      SIGNED, UNSIGN,
			      0, 0, 0, 0, 0, "unsigned" } },
		{ BOOL,	    { sizeof (_Bool) * CHAR_BIT, CHAR_BIT, 1,
			      BOOL, BOOL,
			      1, 1, 0, 1, 1, "_Bool" } },
		{ CHAR,	    { CHAR_BIT, CHAR_BIT, 20,
			      SCHAR, UCHAR,
			      1, 0, 0, 1, 1, "char" } },
		{ SCHAR,    { CHAR_BIT, CHAR_BIT, 20,
			      SCHAR, UCHAR,
			      1, 0, 0, 1, 1, "signed char" } },
		{ UCHAR,    { CHAR_BIT, CHAR_BIT, 20,
			      SCHAR, UCHAR,
			      1, 1, 0, 1, 1, "unsigned char" } },
		{ SHORT,    { sizeof (short) * CHAR_BIT, 2 * CHAR_BIT, 30,
			      SHORT, USHORT,
			      1, 0, 0, 1, 1, "short" } },
		{ USHORT,   { sizeof (u_short) * CHAR_BIT, 2 * CHAR_BIT, 30,
			      SHORT, USHORT,
			      1, 1, 0, 1, 1, "unsigned short" } },
		{ INT,      { sizeof (int) * CHAR_BIT, 3 * CHAR_BIT, 40,
			      INT, UINT,
			      1, 0, 0, 1, 1, "int" } },
		{ UINT,     { sizeof (u_int) * CHAR_BIT, 3 * CHAR_BIT, 40,
			      INT, UINT,
			      1, 1, 0, 1, 1, "unsigned int" } },
		{ LONG,     { sizeof (long) * CHAR_BIT, 4 * CHAR_BIT, 50,
			      LONG, ULONG,
			      1, 0, 0, 1, 1, "long" } },
		{ ULONG,    { sizeof (u_long) * CHAR_BIT, 4 * CHAR_BIT, 50,
			      LONG, ULONG,
			      1, 1, 0, 1, 1, "unsigned long" } },
		{ QUAD,     { sizeof (quad_t) * CHAR_BIT, 8 * CHAR_BIT, 60,
			      QUAD, UQUAD,
			      1, 0, 0, 1, 1, "long long" } },
		{ UQUAD,    { sizeof (u_quad_t) * CHAR_BIT, 8 * CHAR_BIT, 60,
			      QUAD, UQUAD,
			      1, 1, 0, 1, 1, "unsigned long long" } },
		{ FLOAT,    { sizeof (float) * CHAR_BIT, 4 * CHAR_BIT, -1,
			      FLOAT, FLOAT,
			      0, 0, 1, 1, 1, "float" } },
		{ DOUBLE,   { sizeof (double) * CHAR_BIT, 8 * CHAR_BIT, -1,
			      DOUBLE, DOUBLE,
			      0, 0, 1, 1, 1, "double" } },
		{ LDOUBLE,  { sizeof (ldbl_t) * CHAR_BIT, 16 * CHAR_BIT, -1,
			      LDOUBLE, LDOUBLE,
			      0, 0, 1, 1, 1, "long double" } },
		{ COMPLEX,  { sizeof (float _Complex) * CHAR_BIT,
			      8 * CHAR_BIT, -1,
			      COMPLEX, COMPLEX,
			      0, 0, 1, 1, 3, "float _Complex" } },
		{ DCOMPLEX, { sizeof (double _Complex) * CHAR_BIT,
			      16 * CHAR_BIT, -1,
			      DCOMPLEX, DCOMPLEX,
			      0, 0, 1, 1, 3, "double _Complex" } },
		{ LDCOMPLEX,{ sizeof (long double _Complex) * CHAR_BIT,
			      32 * CHAR_BIT, -1,
			      LDCOMPLEX, LDCOMPLEX,
			      0, 0, 1, 1, 3, "long double _Complex" } },
#if 0
		{ IMAGINARY,{ sizeof (float _Imaginary) * CHAR_BIT,
			      4 * CHAR_BIT, -1,
			      IMAGINARY, IMAGINARY,
			      0, 0, 1, 1, 2, "float _Imaginary" } },
		{ DIMAGINARY,{ sizeof (double _Imaginary) * CHAR_BIT,
			      8 * CHAR_BIT, -1,
			      DIMAGINARY, DIMAGINARY,
			      0, 0, 1, 1, 2, "double _Imaginary" } },
		{ LDIMAGINARY,{ sizeof (long double _Imaginary) * CHAR_BIT,
			      16 * CHAR_BIT, -1,
			      LDIMAGINARY, LDIMAGINARY,
			      0, 0, 1, 1, 2, "long double _Imaginary" } },
#endif
		{ VOID,     { -1, -1, -1,
			      VOID, VOID,
			      0, 0, 0, 0, 0, "void" } },
		{ STRUCT,   { -1, -1, -1,
			      STRUCT, STRUCT,
			      0, 0, 0, 0, 0, "struct" } },
		{ UNION,    { -1, -1, -1,
			      UNION, UNION,
			      0, 0, 0, 0, 0, "union" } },
		{ ENUM,     { sizeof (int) * CHAR_BIT, 3 * CHAR_BIT, 40,
			      ENUM, ENUM,
			      1, 0, 0, 1, 1, "enum" } },
		{ PTR,      { sizeof (void *) * CHAR_BIT, 4 * CHAR_BIT, -1,
			      PTR, PTR,
			      0, 1, 0, 0, 1, "pointer" } },
		{ ARRAY,    { -1, -1, -1,
			      ARRAY, ARRAY,
			      0, 0, 0, 0, 0, "array" } },
		{ FUNC,     { -1, -1, -1,
			      FUNC, FUNC,
			      0, 0, 0, 0, 0, "function" } },
	};

	/* declaration stack */
	dcs = xcalloc(1, sizeof (dinfo_t));
	dcs->d_ctx = EXTERN;
	dcs->d_ldlsym = &dcs->d_dlsyms;

	/* type information and classification */
	for (i = 0; i < sizeof (ittab) / sizeof (ittab[0]); i++)
		STRUCT_ASSIGN(ttab[ittab[i].it_tspec], ittab[i].it_ttab);
	if (!pflag) {
		for (i = 0; i < NTSPEC; i++)
			ttab[i].tt_psz = ttab[i].tt_sz;
	}

	/* shared type structures */
	typetab = xcalloc(NTSPEC, sizeof (type_t));
	for (i = 0; i < NTSPEC; i++)
		typetab[i].t_tspec = NOTSPEC;
	typetab[BOOL].t_tspec = BOOL;
	typetab[CHAR].t_tspec = CHAR;
	typetab[SCHAR].t_tspec = SCHAR;
	typetab[UCHAR].t_tspec = UCHAR;
	typetab[SHORT].t_tspec = SHORT;
	typetab[USHORT].t_tspec = USHORT;
	typetab[INT].t_tspec = INT;
	typetab[UINT].t_tspec = UINT;
	typetab[LONG].t_tspec = LONG;
	typetab[ULONG].t_tspec = ULONG;
	typetab[QUAD].t_tspec = QUAD;
	typetab[UQUAD].t_tspec = UQUAD;
	typetab[FLOAT].t_tspec = FLOAT;
	typetab[DOUBLE].t_tspec = DOUBLE;
	typetab[LDOUBLE].t_tspec = LDOUBLE;
	typetab[COMPLEX].t_tspec = COMPLEX;
	typetab[DCOMPLEX].t_tspec = DCOMPLEX;
	typetab[LDCOMPLEX].t_tspec = LDCOMPLEX;
	typetab[IMAGINARY].t_tspec = IMAGINARY;
	typetab[DIMAGINARY].t_tspec = DIMAGINARY;
	typetab[LDIMAGINARY].t_tspec = LDIMAGINARY;
	typetab[VOID].t_tspec = VOID;
	/*
	 * Next two are not real types. They are only used by the parser
	 * to return keywords "signed" and "unsigned"
	 */
	typetab[SIGNED].t_tspec = SIGNED;
	typetab[UNSIGN].t_tspec = UNSIGN;
}

/*
 * Returns a shared type structure for arithmetic types and void.
 *
 * It's important to duplicate this structure (using duptyp() or tduptyp())
 * if it is to be modified (adding qualifiers or anything else).
 */
type_t *
gettyp(tspec_t t)
{
	return (&typetab[t]);
}

type_t *
duptyp(const type_t *tp)
{
	type_t	*ntp;

	ntp = getblk(sizeof (type_t));
	STRUCT_ASSIGN(*ntp, *tp);
	return (ntp);
}

/*
 * Use tduptyp() instead of duptyp() inside expressions (if the
 * allocated memory should be freed after the expr).
 */
type_t *
tduptyp(const type_t *tp)
{
	type_t	*ntp;

	ntp = tgetblk(sizeof (type_t));
	STRUCT_ASSIGN(*ntp, *tp);
	return (ntp);
}

/*
 * Returns 1 if the argument is void or an incomplete array,
 * struct, union or enum type.
 */
int
incompl(type_t *tp)
{
	tspec_t	t;

	if ((t = tp->t_tspec) == VOID) {
		return (1);
	} else if (t == ARRAY) {
		return (tp->t_aincompl);
	} else if (t == STRUCT || t == UNION) {
		return (tp->t_str->sincompl);
	} else if (t == ENUM) {
		return (tp->t_enum->eincompl);
	}
	return (0);
}

/*
 * Set the flag for (in)complete array, struct, union or enum
 * types.
 */
void
setcompl(type_t *tp, int ic)
{
	tspec_t	t;

	if ((t = tp->t_tspec) == ARRAY) {
		tp->t_aincompl = ic;
	} else if (t == STRUCT || t == UNION) {
		tp->t_str->sincompl = ic;
	} else {
		if (t != ENUM)
			lerror("setcompl() 1");
		tp->t_enum->eincompl = ic;
	}
}

/*
 * Remember the storage class of the current declaration in dcs->d_scl
 * (the top element of the declaration stack) and detect multiple
 * storage classes.
 */
void
addscl(scl_t sc)
{
	if (sc == INLINE) {
		if (dcs->d_inline)
			/* duplicate '%s' */
			warning(10, "inline");
		dcs->d_inline = 1;
		return;
	}
	if (dcs->d_type != NULL || dcs->d_atyp != NOTSPEC ||
	    dcs->d_smod != NOTSPEC || dcs->d_lmod != NOTSPEC) {
		/* storage class after type is obsolescent */
		warning(83);
	}
	if (dcs->d_scl == NOSCL) {
		dcs->d_scl = sc;
	} else {
		/*
		 * multiple storage classes. An error will be reported in
		 * deftyp().
		 */
		dcs->d_mscl = 1;
	}
}

/*
 * Remember the type, modifier or typedef name returned by the parser
 * in *dcs (top element of decl stack). This information is used in
 * deftyp() to build the type used for all declarators in this
 * declaration.
 *
 * Is tp->t_typedef 1, the type comes from a previously defined typename.
 * Otherwise it comes from a type specifier (int, long, ...) or a
 * struct/union/enum tag.
 */
void
addtype(type_t *tp)
{
	tspec_t	t;

	if (tp->t_typedef) {
		if (dcs->d_type != NULL || dcs->d_atyp != NOTSPEC ||
		    dcs->d_lmod != NOTSPEC || dcs->d_smod != NOTSPEC ||
		    dcs->d_dmod != NOTSPEC) {
			/*
			 * something like "typedef int a; int a b;"
			 * This should not happen with current grammar.
			 */
			lerror("addtype()");
		}
		dcs->d_type = tp;
		return;
	}

	t = tp->t_tspec;

	if (t == STRUCT || t == UNION || t == ENUM) {
		/*
		 * something like "int struct a ..."
		 * struct/union/enum with anything else is not allowed
		 */
		if (dcs->d_type != NULL || dcs->d_atyp != NOTSPEC ||
		    dcs->d_lmod != NOTSPEC || dcs->d_smod != NOTSPEC ||
		    dcs->d_dmod != NOTSPEC) {
			/*
			 * remember that an error must be reported in
			 * deftyp().
			 */
			dcs->d_terr = 1;
			dcs->d_atyp = dcs->d_smod = dcs->d_lmod =
			    dcs->d_dmod = NOTSPEC;
		}
		dcs->d_type = tp;
		return;
	}

	if (dcs->d_type != NULL && !dcs->d_type->t_typedef) {
		/*
		 * something like "struct a int"
		 * struct/union/enum with anything else is not allowed
		 */
		dcs->d_terr = 1;
		return;
	}

	if (t == LONG && dcs->d_lmod == LONG) {
		/* "long long" or "long ... long" */
		t = QUAD;
		dcs->d_lmod = NOTSPEC;
		if (!quadflg)
			/* %s C does not support 'long long' */
			(void)gnuism(265, "ANSI");
	}

	if (dcs->d_type != NULL && dcs->d_type->t_typedef) {
		/* something like "typedef int a; a long ..." */
		dcs->d_type = tdeferr(dcs->d_type, t);
		return;
	}

	/* now it can be only a combination of arithmetic types and void */
	if (t == SIGNED || t == UNSIGN) {
		/* remeber specifiers "signed" and "unsigned" in dcs->d_smod */
		if (dcs->d_smod != NOTSPEC)
			/*
			 * more than one "signed" and/or "unsigned"; print
			 * an error in deftyp()
			 */
			dcs->d_terr = 1;
		dcs->d_smod = t;
	} else if (t == SHORT || t == LONG || t == QUAD) {
		/*
		 * remember specifiers "short", "long" and "long long" in
		 * dcs->d_lmod
		 */
		if (dcs->d_lmod != NOTSPEC)
			/* more than one, print error in deftyp() */
			dcs->d_terr = 1;
		dcs->d_lmod = t;
	} else if (t == COMPLEX || t == IMAGINARY) {
		/*
		 * remember specifiers "_Complex" and "_Imaginary" in
		 * dcs->d_dmod
		 */
		if (dcs->d_dmod != NOTSPEC)
			/* more than one, print error in deftyp() */
			dcs->d_terr = 1;
		dcs->d_dmod = t;
	} else {
		/*
		 * remember specifiers "void", "char", "int", "float" or
		 * "double" int dcs->d_atyp
		 */
		if (dcs->d_atyp != NOTSPEC)
			/* more than one, print error in deftyp() */
			dcs->d_terr = 1;
		dcs->d_atyp = t;
	}
}

/*
 * called if a list of declaration specifiers contains a typedef name
 * and other specifiers (except struct, union, enum, typedef name)
 */
static type_t *
tdeferr(type_t *td, tspec_t t)
{
	tspec_t	t2;

	t2 = td->t_tspec;

	switch (t) {
	case SIGNED:
	case UNSIGN:
		if (t2 == CHAR || t2 == SHORT || t2 == INT || t2 == LONG ||
		    t2 == QUAD) {
			/* modifying typedef with ... */
			warning(5, ttab[t].tt_name);
			td = duptyp(gettyp(mrgtspec(t2, t)));
			td->t_typedef = 1;
			return (td);
		}
		break;
	case SHORT:
		if (t2 == INT || t2 == UINT) {
			/* modifying typedef with ... */
			warning(5, "short");
			td = duptyp(gettyp(t2 == INT ? SHORT : USHORT));
			td->t_typedef = 1;
			return (td);
		}
		break;
	case LONG:
		if (t2 == INT || t2 == UINT || t2 == LONG || t2 == ULONG ||
		    t2 == FLOAT || t2 == DOUBLE || t2 == COMPLEX ||
		    t2 == IMAGINARY) {
			/* modifying typedef with ... */
			warning(5, "long");
			if (t2 == INT) {
				td = gettyp(LONG);
			} else if (t2 == UINT) {
				td = gettyp(ULONG);
			} else if (t2 == LONG) {
				td = gettyp(QUAD);
			} else if (t2 == ULONG) {
				td = gettyp(UQUAD);
			} else if (t2 == FLOAT) {
				td = gettyp(DOUBLE);
			} else if (t2 == DOUBLE) {
				td = gettyp(LDOUBLE);
			} else if (t2 == COMPLEX) {
				td = gettyp(DCOMPLEX);
			} else if (t2 == DCOMPLEX) {
				td = gettyp(LDCOMPLEX);
			} else if (t2 == IMAGINARY) {
				td = gettyp(DIMAGINARY);
			} else if (t2 == DIMAGINARY) {
				td = gettyp(LDIMAGINARY);
			}
			td = duptyp(td);
			td->t_typedef = 1;
			return (td);
		}
		break;
		/* LINTED (enumeration values not handled in switch) */
	}

	/* Anything other is not accepted. */

	dcs->d_terr = 1;
	return (td);
}

/*
 * Remember the symbol of a typedef name (2nd arg) in a struct, union
 * or enum tag if the typedef name is the first defined for this tag.
 *
 * If the tag is unnamed, the typdef name is used for identification
 * of this tag in lint2. Although its possible that more than one typedef
 * name is defined for one tag, the first name defined should be unique
 * if the tag is unnamed.
 */
static void
settdsym(type_t *tp, sym_t *sym)
{
	tspec_t	t;

	if ((t = tp->t_tspec) == STRUCT || t == UNION) {
		if (tp->t_str->stdef == NULL)
			tp->t_str->stdef = sym;
	} else if (t == ENUM) {
		if (tp->t_enum->etdef == NULL)
			tp->t_enum->etdef = sym;
	}
}

/*
 * Remember a qualifier which is part of the declaration specifiers
 * (and not the declarator) in the top element of the declaration stack.
 * Also detect multiple qualifiers of the same kind.

 * The remembered qualifier is used by deftyp() to construct the type
 * for all declarators.
 */
void
addqual(tqual_t q)
{
	if (q == CONST) {
		if (dcs->d_const) {
			/* duplicate "%s" */
			warning(10, "const");
		}
		dcs->d_const = 1;
	} else if (q == VOLATILE) {
		if (dcs->d_volatile) {
			/* duplicate "%s" */
			warning(10, "volatile");
		}
		dcs->d_volatile = 1;
	} else if (q == RESTRICT) {
		if (dcs->d_restrict) {
			/* duplicate "%s" */
			warning(10, "restrict");
		}
		dcs->d_restrict = 1;
	} else
		lerror("addqual() 1");
}

/*
 * Go to the next declaration level (structs, nested structs, blocks,
 * argument declaration lists ...)
 */
void
pushdecl(scl_t sc)
{
	dinfo_t	*di;

	if (dflag)
		(void)printf("pushdecl(%d)\n", (int)sc);

	/* put a new element on the declaration stack */
	di = xcalloc(1, sizeof (dinfo_t));
	di->d_nxt = dcs;
	dcs = di;
	di->d_ctx = sc;
	di->d_ldlsym = &di->d_dlsyms;
}

/*
 * Go back to previous declaration level
 */
void
popdecl(void)
{
	dinfo_t	*di;

	if (dflag)
		(void)printf("popdecl(%d)\n", (int)dcs->d_ctx);

	if (dcs->d_nxt == NULL)
		lerror("popdecl() 1");
	di = dcs;
	dcs = di->d_nxt;
	switch (di->d_ctx) {
	case EXTERN:
		/* there is nothing after external declarations */
		lerror("popdecl() 2");
		/* NOTREACHED */
	case MOS:
	case MOU:
	case ENUMCON:
		/*
		 * Symbols declared in (nested) structs or enums are
		 * part of the next level (they are removed from the
		 * symbol table if the symbols of the outher level are
		 * removed)
		 */
		if ((*dcs->d_ldlsym = di->d_dlsyms) != NULL)
			dcs->d_ldlsym = di->d_ldlsym;
		break;
	case ARG:
		/*
		 * All symbols in dcs->d_dlsyms are introduced in old style
		 * argument declarations (it's not clean, but possible).
		 * They are appended to the list of symbols declared in
		 * an old style argument identifier list or a new style
		 * parameter type list.
		 */
		if (di->d_dlsyms != NULL) {
			*di->d_ldlsym = dcs->d_fpsyms;
			dcs->d_fpsyms = di->d_dlsyms;
		}
		break;
	case ABSTRACT:
		/*
		 * casts and sizeof
		 * Append all symbols declared in the abstract declaration
		 * to the list of symbols declared in the surounding decl.
		 * or block.
		 * XXX I'm not sure whether they should be removed from the
		 * symbol table now or later.
		 */
		if ((*dcs->d_ldlsym = di->d_dlsyms) != NULL)
			dcs->d_ldlsym = di->d_ldlsym;
		break;
	case AUTO:
		/* check usage of local vars */
		chkusage(di);
		/* FALLTHROUGH */
	case PARG:
		/* usage of arguments will be checked by funcend() */
		rmsyms(di->d_dlsyms);
		break;
	default:
		lerror("popdecl() 3");
	}
	free(di);
}

/*
 * Set flag d_asm in all declaration stack elements up to the
 * outermost one.
 *
 * This is used to mark compound statements which have, possibly in
 * nested compound statements, asm statements. For these compound
 * statements no warnings about unused or unitialized variables are
 * printed.
 *
 * There is no need to clear d_asm in dinfo structs with context AUTO,
 * because these structs are freed at the end of the compound statement.
 * But it must be cleard in the outermost dinfo struct, which has
 * context EXTERN. This could be done in clrtyp() and would work for
 * C, but not for C++ (due to mixed statements and declarations). Thus
 * we clear it in glclup(), which is used to do some cleanup after
 * global declarations/definitions.
 */
void
setasm(void)
{
	dinfo_t	*di;

	for (di = dcs; di != NULL; di = di->d_nxt)
		di->d_asm = 1;
}

/*
 * Clean all elements of the top element of declaration stack which
 * will be used by the next declaration
 */
void
clrtyp(void)
{
	dcs->d_atyp = dcs->d_smod = dcs->d_lmod = dcs->d_dmod = NOTSPEC;
	dcs->d_scl = NOSCL;
	dcs->d_type = NULL;
	dcs->d_const = dcs->d_volatile = 0;
	dcs->d_inline = 0;
	dcs->d_mscl = dcs->d_terr = 0;
	dcs->d_nedecl = 0;
	dcs->d_notyp = 0;
}

/*
 * Merge the domain (_Complex or _Imaginary) into a type.  Returns non-zero
 * if the merge doesn't make sense.  e.g., no "int _Complex".
 */
int
mergedomain(tspec_t *tp, tspec_t domain)
{
	if (domain == NOTSPEC)
		return (0);
	if (domain != COMPLEX && domain != IMAGINARY)
		lerror("mergedomain()");
	switch (*tp) {
	case FLOAT:
		*tp = domain;
		break;
	case DOUBLE:
		*tp = domain == COMPLEX ? DCOMPLEX : DIMAGINARY;
		break;
	case LDOUBLE:
		*tp = domain == COMPLEX ? LDCOMPLEX : LDIMAGINARY;
		break;
	default:
		return (1);
	}
	return (0);
}

/*
 * Create a type structure from the informations gathered in
 * the declaration stack.
 * Complain about storage classes which are not possible in current
 * context.
 */
void
deftyp(void)
{
	tspec_t	t, s, l, d;
	type_t	*tp;
	scl_t	scl;

	t = dcs->d_atyp;		/* BOOL, CHAR, INT, FLOAT,
					   DOUBLE, VOID */
	s = dcs->d_smod;		/* SIGNED, UNSIGNED */
	l = dcs->d_lmod;		/* SHORT, LONG, QUAD */
	d = dcs->d_dmod;		/* COMPLEX, IMAGINARY */
	tp = dcs->d_type;
	scl = dcs->d_scl;

	if (t == NOTSPEC && s == NOTSPEC && l == NOTSPEC && tp == NULL)
		dcs->d_notyp = 1;

	if (tp != NULL && (t != NOTSPEC || s != NOTSPEC || l != NOTSPEC)) {
		/* should never happen */
		lerror("deftyp() 1");
	}

	if (tp == NULL) {
		switch (t) {
		case NOTSPEC:
			t = INT;
			/* FALLTHROUGH */
		case BOOL:
			break;
		case INT:
			if (s == NOTSPEC)
				s = SIGNED;
			break;
		case CHAR:
			if (l != NOTSPEC) {
				dcs->d_terr = 1;
				l = NOTSPEC;
			}
			break;
		case FLOAT:
			if (l == LONG) {
				l = NOTSPEC;
				t = DOUBLE;
				/* use 'double' instead of ...  */
				warning(6);
			}
			break;
		case DOUBLE:
			if (l == LONG) {
				l = NOTSPEC;
				t = LDOUBLE;
			}
			break;
		case VOID:
			break;
		default:
			lerror("deftyp() 2");
		}
		if (mergedomain(&t, d))
			dcs->d_terr = 1;
		if (t != INT && t != CHAR && (s != NOTSPEC || l != NOTSPEC)) {
			dcs->d_terr = 1;
			l = s = NOTSPEC;
		}
		if (l != NOTSPEC)
			t = l;
		dcs->d_type = gettyp(mrgtspec(t, s));
	}

	if (dcs->d_mscl) {
		/* only one storage class allowed */
		error(7);
	}
	if (dcs->d_terr) {
		/* illegal type combination */
		error(4);
	}

	if (dcs->d_ctx == EXTERN) {
		if (scl == REG || scl == AUTO) {
			/* illegal storage class */
			error(8);
			scl = NOSCL;
		}
	} else if (dcs->d_ctx == ARG || dcs->d_ctx == PARG) {
		if (scl != NOSCL && scl != REG) {
			/* only "register" valid ... */
			error(9);
			scl = NOSCL;
		}
	}

	dcs->d_scl = scl;

	if (dcs->d_const && dcs->d_type->t_const) {
		if (!dcs->d_type->t_typedef)
			lerror("deftyp() 3");
		/* typedef already qualified with "%s" */
		warning(68, "const");
	}
	if (dcs->d_volatile && dcs->d_type->t_volatile) {
		if (!dcs->d_type->t_typedef)
			lerror("deftyp() 4");
		/* typedef already qualified with "%s" */
		warning(68, "volatile");
	}

	if (dcs->d_const || dcs->d_volatile) {
		dcs->d_type = duptyp(dcs->d_type);
		dcs->d_type->t_const |= dcs->d_const;
		dcs->d_type->t_volatile |= dcs->d_volatile;
	}
}

/*
 * Merge type specifiers (char, ..., long long, signed, unsigned).
 */
static tspec_t
mrgtspec(tspec_t t, tspec_t s)
{
	if (s == SIGNED || s == UNSIGN) {
		if (t == CHAR) {
			t = s == SIGNED ? SCHAR : UCHAR;
		} else if (t == SHORT) {
			t = s == SIGNED ? SHORT : USHORT;
		} else if (t == INT) {
			t = s == SIGNED ? INT : UINT;
		} else if (t == LONG) {
			t = s == SIGNED ? LONG : ULONG;
		} else if (t == QUAD) {
			t = s == SIGNED ? QUAD : UQUAD;
		}
	}

	return (t);
}

/*
 * Return the length of a type in bit.
 *
 * Printing a message if the outhermost dimension of an array is 0 must
 * be done by the caller. All other problems are reported by length()
 * if name is not NULL.
 */
int
length(type_t *tp, const char *name)
{
	int	elem, elsz;

	elem = 1;
	while (tp && tp->t_tspec == ARRAY) {
		elem *= tp->t_dim;
		tp = tp->t_subt;
	}
	if (tp == NULL)
		return (-1);

	switch (tp->t_tspec) {
	case FUNC:
		/* compiler takes size of function */
		lerror(msgs[12]);
		/* NOTREACHED */
	case STRUCT:
	case UNION:
		if (incompl(tp) && name != NULL) {
			/* incomplete structure or union %s: %s */
			error(31, tp->t_str->stag->s_name, name);
		}
		elsz = tp->t_str->size;
		break;
	case ENUM:
		if (incompl(tp) && name != NULL) {
			/* incomplete enum type: %s */
			warning(13, name);
		}
		/* FALLTHROUGH */
	default:
		elsz = size(tp->t_tspec);
		if (elsz <= 0)
			lerror("length()");
		break;
	}
	return (elem * elsz);
}

/*
 * Get the alignment of the given type in bits.
 */
int
getbound(type_t *tp)
{
	int	a;
	tspec_t	t;

	while (tp && tp->t_tspec == ARRAY)
		tp = tp->t_subt;

	if (tp == NULL)
		return (-1);

	if ((t = tp->t_tspec) == STRUCT || t == UNION) {
		a = tp->t_str->align;
	} else if (t == FUNC) {
		/* compiler takes alignment of function */
		error(14);
		a = ALIGN(1) * CHAR_BIT;
	} else {
		if ((a = size(t)) == 0) {
			a = CHAR_BIT;
		} else if (a > ALIGN(1) * CHAR_BIT) {
			a = ALIGN(1) * CHAR_BIT;
		}
	}
	if (a < CHAR_BIT || a > ALIGN(1) * CHAR_BIT)
		lerror("getbound() 1");
	return (a);
}

/*
 * Concatenate two lists of symbols by s_nxt. Used by declarations of
 * struct/union/enum elements and parameters.
 */
sym_t *
lnklst(sym_t *l1, sym_t *l2)
{
	sym_t	*l;

	if ((l = l1) == NULL)
		return (l2);
	while (l1->s_nxt != NULL)
		l1 = l1->s_nxt;
	l1->s_nxt = l2;
	return (l);
}

/*
 * Check if the type of the given symbol is valid and print an error
 * message if it is not.
 *
 * Invalid types are:
 * - arrays of incomlete types or functions
 * - functions returning arrays or functions
 * - void types other than type of function or pointer
 */
void
chktyp(sym_t *sym)
{
	tspec_t	to, t;
	type_t	**tpp, *tp;

	tpp = &sym->s_type;
	to = NOTSPEC;
	while ((tp = *tpp) != NULL) {
		t = tp->t_tspec;
		/*
		 * If this is the type of an old style function definition,
		 * a better warning is printed in funcdef().
		 */
		if (t == FUNC && !tp->t_proto &&
		    !(to == NOTSPEC && sym->s_osdef)) {
			if (sflag && hflag)
				/* function declaration is not a prototype */
				warning(287);
		}
		if (to == FUNC) {
			if (t == FUNC || t == ARRAY) {
				/* function returns illegal type */
				error(15);
				if (t == FUNC) {
					*tpp = incref(*tpp, PTR);
				} else {
					*tpp = incref((*tpp)->t_subt, PTR);
				}
				return;
			} else if (tp->t_const || tp->t_volatile) {
				if (sflag) {
					/* function cannot return const... */
					warning(228);
				}
			}
		} if (to == ARRAY) {
			if (t == FUNC) {
				/* array of function is illegal */
				error(16);
				*tpp = gettyp(INT);
				return;
			} else if (t == ARRAY && tp->t_dim == 0) {
				/* null dimension */
				error(17);
				return;
			} else if (t == VOID) {
				/* illegal use of void */
				error(18);
				*tpp = gettyp(INT);
#if 0	/* errors are produced by length() */
			} else if (incompl(tp)) {
				/* array of incomplete type */
				if (sflag) {
					error(301);
				} else {
					warning(301);
				}
#endif
			}
		} else if (to == NOTSPEC && t == VOID) {
			if (dcs->d_ctx == PARG) {
				if (sym->s_scl != ABSTRACT) {
					if (sym->s_name == unnamed)
						lerror("chktyp()");
					/* void param cannot have name: %s */
					error(61, sym->s_name);
					*tpp = gettyp(INT);
				}
			} else if (dcs->d_ctx == ABSTRACT) {
				/* ok */
			} else if (sym->s_scl != TYPEDEF) {
				/* void type for %s */
				error(19, sym->s_name);
				*tpp = gettyp(INT);
			}
		}
		if (t == VOID && to != PTR) {
			if (tp->t_const || tp->t_volatile || tp->t_restrict) {
				/* inappropriate qualifiers with "void" */
				warning(69);
				tp->t_const = tp->t_volatile = 0;
				tp->t_restrict = 0;
			}
		}
		tpp = &tp->t_subt;
		to = t;
	}
}

/*
 * Process the declarator of a struct/union element.
 */
sym_t *
decl1str(sym_t *dsym)
{
	type_t	*tp;
	tspec_t	t;
	int	sz, o, len;
	scl_t	sc;

	if ((sc = dsym->s_scl) != MOS && sc != MOU)
		lerror("decl1str() 1");

	if (dcs->d_rdcsym != NULL) {
		if ((sc = dcs->d_rdcsym->s_scl) != MOS && sc != MOU)
			/* should be ensured by storesym() */
			lerror("decl1str() 2");
		if (dsym->s_styp == dcs->d_rdcsym->s_styp) {
			/* duplicate member name: %s */
			error(33, dsym->s_name);
			rmsym(dcs->d_rdcsym);
		}
	}

	chktyp(dsym);

	t = (tp = dsym->s_type)->t_tspec;

	if (dsym->s_field) {
		/*
		 * bit field
		 *
		 * only unsigned and signed int are portable bit-field types
		 * (at least in ANSI C, in traditional C only unsigned int)
		 */
		if (t == CHAR || t == UCHAR || t == SCHAR ||
		    t == SHORT || t == USHORT || t == ENUM) {
			if (sflag) {
				/* bit-field type '%s' invalid in ANSI C */
				warning(273, tyname(tp));
			} else if (pflag) {
				/* nonportable bit-field type */
				warning(34);
			}
			if (isutyp(t))
				tp->t_tspec = UINT;
			else
				tp->t_tspec = INT;

			tp->t_isenum = 0;
		} else if (t == INT && dcs->d_smod == NOTSPEC) {
			if (pflag) {
				/* nonportable bit-field type */
				warning(34);
			}
		} else if (t != INT && t != UINT && t != LONG &&
		    t != ULONG && t != QUAD && t != UQUAD && t != BOOL) {
			/* illegal bit-field type */
			error(35);
			sz = tp->t_flen;
			dsym->s_type = tp = duptyp(gettyp(t = INT));
			if ((tp->t_flen = sz) > size(t))
				tp->t_flen = size(t);
		}
		if ((len = tp->t_flen) < 0 || len > size(t)) {
			/* illegal bit-field size */
			error(36);
			tp->t_flen = size(t);
		} else if (len == 0 && dsym->s_name != unnamed) {
			/* zero size bit-field */
			error(37);
			tp->t_flen = size(t);
		}
		if (dsym->s_scl == MOU) {
			/* illegal use of bit-field */
			error(41);
			dsym->s_type->t_isfield = 0;
			dsym->s_field = 0;
		}
	} else if (t == FUNC) {
		/* function illegal in structure or union */
		error(38);
		dsym->s_type = tp = incref(tp, t = PTR);
	}

	/*
	 * bit-fields of length 0 are not warned about because length()
	 * does not return the length of the bit-field but the length
	 * of the type the bit-field is packed in (its ok)
	 */
	if ((sz = length(dsym->s_type, dsym->s_name)) == 0) {
		if (t == ARRAY && dsym->s_type->t_dim == 0) {
			/* illegal zero sized structure member: %s */
			warning(39, dsym->s_name);
		}
	}

	if (dcs->d_ctx == MOU) {
		o = dcs->d_offset;
		dcs->d_offset = 0;
	}
	if (dsym->s_field) {
		align(getbound(tp), tp->t_flen);
		dsym->s_value.v_quad = (dcs->d_offset / size(t)) * size(t);
		tp->t_foffs = dcs->d_offset - (int)dsym->s_value.v_quad;
		dcs->d_offset += tp->t_flen;
	} else {
		align(getbound(tp), 0);
		dsym->s_value.v_quad = dcs->d_offset;
		dcs->d_offset += sz;
	}
	if (dcs->d_ctx == MOU) {
		if (o > dcs->d_offset)
			dcs->d_offset = o;
	}

	chkfdef(dsym, 0);

	return (dsym);
}

/*
 * Aligns next structure element as required.
 *
 * al contains the required alignment, len the length of a bit-field.
 */
static void
align(int al, int len)
{
	int	no;

	/*
	 * The alignment of the current element becomes the alignment of
	 * the struct/union if it is larger than the current alignment
	 * of the struct/union.
	 */
	if (al > dcs->d_stralign)
		dcs->d_stralign = al;

	no = (dcs->d_offset + (al - 1)) & ~(al - 1);
	if (len == 0 || dcs->d_offset + len > no)
		dcs->d_offset = no;
}

/*
 * Remember the width of the field in its type structure.
 */
sym_t *
bitfield(sym_t *dsym, int len)
{
	if (dsym == NULL) {
		dsym = getblk(sizeof (sym_t));
		dsym->s_name = unnamed;
		dsym->s_kind = FMOS;
		dsym->s_scl = MOS;
		dsym->s_type = gettyp(INT);
		dsym->s_blklev = -1;
	}
	dsym->s_type = duptyp(dsym->s_type);
	dsym->s_type->t_isfield = 1;
	dsym->s_type->t_proto = 0;
	dsym->s_type->t_isenum = 0;
	dsym->s_type->t_flen = len;
	dsym->s_field = 1;
	return (dsym);
}

/*
 * Collect informations about a sequence of asterisks and qualifiers
 * in a list of type pqinf_t.
 * Qualifiers refer always to the left asterisk. The rightmost asterisk
 * will be at the top of the list.
 */
pqinf_t *
mergepq(pqinf_t *p1, pqinf_t *p2)
{
	pqinf_t	*p;

	if (p2->p_pcnt != 0) {
		/* left '*' at the end of the list */
		for (p = p2; p->p_nxt != NULL; p = p->p_nxt) ;
		p->p_nxt = p1;
		return (p2);
	} else {
		if (p2->p_const) {
			if (p1->p_const) {
				/* duplicate %s */
				warning(10, "const");
			}
			p1->p_const = 1;
		}
		if (p2->p_volatile) {
			if (p1->p_volatile) {
				/* duplicate %s */
				warning(10, "volatile");
			}
			p1->p_volatile = 1;
		}
		free(p2);
		return (p1);
	}
}

/*
 * Followint 3 functions extend the type of a declarator with
 * pointer, function and array types.
 *
 * The current type is the type built by deftyp() (dcs->d_type) and
 * pointer, function and array types already added for this
 * declarator. The new type extension is inserted between both.
 */
sym_t *
addptr(sym_t *decl, pqinf_t *pi)
{
	type_t	**tpp, *tp;
	pqinf_t	*npi;

	tpp = &decl->s_type;
	while (*tpp && *tpp != dcs->d_type)
		tpp = &(*tpp)->t_subt;
	if (*tpp == NULL)
		return (decl);

	while (pi != NULL) {
		*tpp = tp = getblk(sizeof (type_t));
		tp->t_tspec = PTR;
		tp->t_const = pi->p_const;
		tp->t_volatile = pi->p_volatile;
		*(tpp = &tp->t_subt) = dcs->d_type;
		npi = pi->p_nxt;
		free(pi);
		pi = npi;
	}
	return (decl);
}

/*
 * If a dimension was specified, dim is 1, otherwise 0
 * n is the specified dimension
 */
sym_t *
addarray(sym_t *decl, int dim, int n)
{
	type_t	**tpp, *tp;

	tpp = &decl->s_type;
	while (*tpp && *tpp != dcs->d_type)
		tpp = &(*tpp)->t_subt;
	if (*tpp == NULL)
	    return (decl);

	*tpp = tp = getblk(sizeof (type_t));
	tp->t_tspec = ARRAY;
	tp->t_subt = dcs->d_type;
	tp->t_dim = n;

	if (n < 0) {
		/* zero or negative array dimension */
		error(20);
		n = 0;
	} else if (n == 0 && dim) {
		/* zero or negative array dimension */
		warning(20);
	} else if (n == 0 && !dim) {
		/* is incomplete type */
		setcompl(tp, 1);
	}

	return (decl);
}

sym_t *
addfunc(sym_t *decl, sym_t *args)
{
	type_t	**tpp, *tp;

	if (dcs->d_proto) {
		args = nsfunc(decl, args);
	} else {
		osfunc(decl, args);
	}

	/*
	 * The symbols are removed from the symbol table by popdecl() after
	 * addfunc(). To be able to restore them if this is a function
	 * definition, a pointer to the list of all symbols is stored in
	 * dcs->d_nxt->d_fpsyms. Also a list of the arguments (concatenated
	 * by s_nxt) is stored in dcs->d_nxt->d_fargs.
	 * (dcs->d_nxt must be used because *dcs is the declaration stack
	 * element created for the list of params and is removed after
	 * addfunc())
	 */
	if (dcs->d_nxt->d_ctx == EXTERN &&
	    decl->s_type == dcs->d_nxt->d_type) {
		dcs->d_nxt->d_fpsyms = dcs->d_dlsyms;
		dcs->d_nxt->d_fargs = args;
	}

	tpp = &decl->s_type;
	while (*tpp && *tpp != dcs->d_nxt->d_type)
		tpp = &(*tpp)->t_subt;
	if (*tpp == NULL)
	    return (decl);

	*tpp = tp = getblk(sizeof (type_t));
	tp->t_tspec = FUNC;
	tp->t_subt = dcs->d_nxt->d_type;
	if ((tp->t_proto = dcs->d_proto) != 0)
		tp->t_args = args;
	tp->t_vararg = dcs->d_vararg;

	return (decl);
}

/*
 * Called for new style function declarations.
 */
/* ARGSUSED */
static sym_t *
nsfunc(sym_t *decl, sym_t *args)
{
	sym_t	*arg, *sym;
	scl_t	sc;
	int	n;

	/*
	 * Declarations of structs/unions/enums in param lists are legal,
	 * but senseless.
	 */
	for (sym = dcs->d_dlsyms; sym != NULL; sym = sym->s_dlnxt) {
		sc = sym->s_scl;
		if (sc == STRTAG || sc == UNIONTAG || sc == ENUMTAG) {
			/* dubious tag declaration: %s %s */
			warning(85, scltoa(sc), sym->s_name);
		}
	}

	n = 1;
	for (arg = args; arg != NULL; arg = arg->s_nxt) {
		if (arg->s_type->t_tspec == VOID) {
			if (n > 1 || arg->s_nxt != NULL) {
				/* "void" must be sole parameter */
				error(60);
				arg->s_type = gettyp(INT);
			}
		}
		n++;
	}

	/* return NULL if first param is VOID */
	return (args != NULL && args->s_type->t_tspec != VOID ? args : NULL);
}

/*
 * Called for old style function declarations.
 */
static void
osfunc(sym_t *decl, sym_t *args)
{
	/*
	 * Remember list of params only if this is really seams to be
	 * a function definition.
	 */
	if (dcs->d_nxt->d_ctx == EXTERN &&
	    decl->s_type == dcs->d_nxt->d_type) {
		/*
		 * We assume that this becomes a function definition. If
		 * we are wrong, its corrected in chkfdef().
		 */
		if (args != NULL) {
			decl->s_osdef = 1;
			decl->s_args = args;
		}
	} else {
		if (args != NULL)
			/* function prototype parameters must have types */
			warning(62);
	}
}

/*
 * Lists of Identifiers in functions declarations are allowed only if
 * its also a function definition. If this is not the case, print a
 * error message.
 */
void
chkfdef(sym_t *sym, int msg)
{
	if (sym->s_osdef) {
		if (msg) {
			/* incomplete or misplaced function definition */
			error(22);
		}
		sym->s_osdef = 0;
		sym->s_args = NULL;
	}
}

/*
 * Process the name in a declarator.
 * If the symbol does already exists, a new one is created.
 * The symbol becomes one of the storage classes EXTERN, STATIC, AUTO or
 * TYPEDEF.
 * s_def and s_reg are valid after dname().
 */
sym_t *
dname(sym_t *sym)
{
	scl_t	sc = NOSCL;

	if (sym->s_scl == NOSCL) {
		dcs->d_rdcsym = NULL;
	} else if (sym->s_defarg) {
		sym->s_defarg = 0;
		dcs->d_rdcsym = NULL;
	} else {
		dcs->d_rdcsym = sym;
		sym = pushdown(sym);
	}

	switch (dcs->d_ctx) {
	case MOS:
	case MOU:
		/* Parent setzen */
		sym->s_styp = dcs->d_tagtyp->t_str;
		sym->s_def = DEF;
		sym->s_value.v_tspec = INT;
		sc = dcs->d_ctx;
		break;
	case EXTERN:
		/*
		 * static and external symbols without "extern" are
		 * considered to be tentative defined, external
		 * symbols with "extern" are declared, and typedef names
		 * are defined. Tentative defined and declared symbols
		 * may become defined if an initializer is present or
		 * this is a function definition.
		 */
		if ((sc = dcs->d_scl) == NOSCL) {
			sc = EXTERN;
			sym->s_def = TDEF;
		} else if (sc == STATIC) {
			sym->s_def = TDEF;
		} else if (sc == TYPEDEF) {
			sym->s_def = DEF;
		} else if (sc == EXTERN) {
			sym->s_def = DECL;
		} else {
			lerror("dname() 1");
		}
		break;
	case PARG:
		sym->s_arg = 1;
		/* FALLTHROUGH */
	case ARG:
		if ((sc = dcs->d_scl) == NOSCL) {
			sc = AUTO;
		} else if (sc == REG) {
			sym->s_reg = 1;
			sc = AUTO;
		} else {
			lerror("dname() 2");
		}
		sym->s_def = DEF;
		break;
	case AUTO:
		if ((sc = dcs->d_scl) == NOSCL) {
			/*
			 * XXX somewhat ugly because we dont know whether
			 * this is AUTO or EXTERN (functions). If we are
			 * wrong it must be corrected in decl1loc(), where
			 * we have the necessary type information.
			 */
			sc = AUTO;
			sym->s_def = DEF;
		} else if (sc == AUTO || sc == STATIC || sc == TYPEDEF) {
			sym->s_def = DEF;
		} else if (sc == REG) {
			sym->s_reg = 1;
			sc = AUTO;
			sym->s_def = DEF;
		} else if (sc == EXTERN) {
			sym->s_def = DECL;
		} else {
			lerror("dname() 3");
		}
		break;
	default:
		lerror("dname() 4");
	}
	sym->s_scl = sc;

	sym->s_type = dcs->d_type;

	dcs->d_fpsyms = NULL;

	return (sym);
}

/*
 * Process a name in the list of formal params in an old style function
 * definition.
 */
sym_t *
iname(sym_t *sym)
{
	if (sym->s_scl != NOSCL) {
		if (blklev == sym->s_blklev) {
			/* redeclaration of formal parameter %s */
			error(21, sym->s_name);
			if (!sym->s_defarg)
				lerror("iname()");
		}
		sym = pushdown(sym);
	}
	sym->s_type = gettyp(INT);
	sym->s_scl = AUTO;
	sym->s_def = DEF;
	sym->s_defarg = sym->s_arg = 1;
	return (sym);
}

/*
 * Create the type of a tag.
 *
 * tag points to the symbol table entry of the tag
 * kind is the kind of the tag (STRUCT/UNION/ENUM)
 * decl is 1 if the type of the tag will be completed in this declaration
 * (the following token is T_LBRACE)
 * semi is 1 if the following token is T_SEMI
 */
type_t *
mktag(sym_t *tag, tspec_t kind, int decl, int semi)
{
	scl_t	scl = NOSCL;
	type_t	*tp;

	if (kind == STRUCT) {
		scl = STRTAG;
	} else if (kind == UNION) {
		scl = UNIONTAG;
	} else if (kind == ENUM) {
		scl = ENUMTAG;
	} else {
		lerror("mktag()");
	}

	if (tag != NULL) {
		if (tag->s_scl != NOSCL) {
			tag = newtag(tag, scl, decl, semi);
		} else {
			/* a new tag, no empty declaration */
			dcs->d_nxt->d_nedecl = 1;
			if (scl == ENUMTAG && !decl) {
				if (sflag || pflag)
					/* forward reference to enum type */
					warning(42);
			}
		}
		if (tag->s_scl == NOSCL) {
			tag->s_scl = scl;
			tag->s_type = tp = getblk(sizeof (type_t));
		} else {
			tp = tag->s_type;
		}
	} else {
		tag = getblk(sizeof (sym_t));
		tag->s_name = unnamed;
		STRUCT_ASSIGN(tag->s_dpos, curr_pos);
		tag->s_kind = FTAG;
		tag->s_scl = scl;
		tag->s_blklev = -1;
		tag->s_type = tp = getblk(sizeof (type_t));
		dcs->d_nxt->d_nedecl = 1;
	}

	if (tp->t_tspec == NOTSPEC) {
		tp->t_tspec = kind;
		if (kind != ENUM) {
			tp->t_str = getblk(sizeof (str_t));
			tp->t_str->align = CHAR_BIT;
			tp->t_str->stag = tag;
		} else {
			tp->t_isenum = 1;
			tp->t_enum = getblk(sizeof (enum_t));
			tp->t_enum->etag = tag;
		}
		/* is incomplete type */
		setcompl(tp, 1);
	}

	return (tp);
}

/*
 * Checks all possible cases of tag redeclarations.
 * decl is 1 if T_LBRACE follows
 * semi is 1 if T_SEMI follows
 */
static sym_t *
newtag(sym_t *tag, scl_t scl, int decl, int semi)
{
	if (tag->s_blklev < blklev) {
		if (semi) {
			/* "struct a;" */
			if (!sflag)
				/* decl. introduces new type ... */
				warning(44, scltoa(scl), tag->s_name);
			tag = pushdown(tag);
			dcs->d_nxt->d_nedecl = 1;
		} else if (decl) {
			/* "struct a { ..." */
			if (hflag)
				/* redefinition hides earlier one: %s */
				warning(43, tag->s_name);
			tag = pushdown(tag);
			dcs->d_nxt->d_nedecl = 1;
		} else if (tag->s_scl != scl) {
			/* base type is really "%s %s" */
			warning(45, scltoa(tag->s_scl), tag->s_name);
			/* declaration introduces new type in ANSI C: %s %s */
			if (!sflag)
				warning(44, scltoa(scl), tag->s_name);
			tag = pushdown(tag);
			dcs->d_nxt->d_nedecl = 1;
		}
	} else {
		if (tag->s_scl != scl) {
			/* (%s) tag redeclared */
			error(46, scltoa(tag->s_scl));
			prevdecl(-1, tag);
			tag = pushdown(tag);
			dcs->d_nxt->d_nedecl = 1;
		} else if (decl && !incompl(tag->s_type)) {
			/* (%s) tag redeclared */
			error(46, scltoa(tag->s_scl));
			prevdecl(-1, tag);
			tag = pushdown(tag);
			dcs->d_nxt->d_nedecl = 1;
		} else if (semi || decl) {
			dcs->d_nxt->d_nedecl = 1;
		}
	}
	return (tag);
}

const char *
scltoa(scl_t sc)
{
	const	char *s;

	switch (sc) {
	case EXTERN:	s = "extern";	break;
	case STATIC:	s = "static";	break;
	case AUTO:	s = "auto";	break;
	case REG:	s = "register";	break;
	case TYPEDEF:	s = "typedef";	break;
	case STRTAG:	s = "struct";	break;
	case UNIONTAG:	s = "union";	break;
	case ENUMTAG:	s = "enum";	break;
	default:	lerror("tagttoa()");
	}
	return (s);
}

/*
 * Completes the type of a tag in a struct/union/enum declaration.
 * tp points to the type of the, tag, fmem to the list of members/enums.
 */
type_t *
compltag(type_t *tp, sym_t *fmem)
{
	tspec_t	t;
	str_t	*sp;
	int	n;
	sym_t	*mem;

	/* from now a complete type */
	setcompl(tp, 0);

	if ((t = tp->t_tspec) != ENUM) {
		align(dcs->d_stralign, 0);
		sp = tp->t_str;
		sp->align = dcs->d_stralign;
		sp->size = dcs->d_offset;
		sp->memb = fmem;
		if (sp->size == 0) {
			if (sflag) {
				/* zero sized %s */
				warning(47, ttab[t].tt_name);
			}
		} else {
			n = 0;
			for (mem = fmem; mem != NULL; mem = mem->s_nxt) {
				if (mem->s_name != unnamed)
					n++;
			}
			if (n == 0) {
				/* %s has no named members */
				warning(65,
					t == STRUCT ? "structure" : "union");
			}
		}
	} else {
		tp->t_enum->elem = fmem;
	}
	return (tp);
}

/*
 * Processes the name of an enumerator in en enum declaration.
 *
 * sym points to the enumerator
 * val is the value of the enumerator
 * impl is 1 if the value of the enumerator was not explicitly specified.
 */
sym_t *
ename(sym_t *sym, int val, int impl)
{
	if (sym->s_scl) {
		if (sym->s_blklev == blklev) {
			/* no hflag, because this is illegal!!! */
			if (sym->s_arg) {
				/* enumeration constant hides parameter: %s */
				warning(57, sym->s_name);
			} else {
				/* redeclaration of %s */
				error(27, sym->s_name);
				/*
				 * inside blocks it should not too complicated
				 * to find the position of the previous
				 * declaration
				 */
				if (blklev == 0)
					prevdecl(-1, sym);
			}
		} else {
			if (hflag)
				/* redefinition hides earlier one: %s */
				warning(43, sym->s_name);
		}
		sym = pushdown(sym);
	}
	sym->s_scl = ENUMCON;
	sym->s_type = dcs->d_tagtyp;
	sym->s_value.v_tspec = INT;
	sym->s_value.v_quad = val;
	if (impl && val - 1 == INT_MAX) {
		/* overflow in enumeration values: %s */
		warning(48, sym->s_name);
	}
	enumval = val + 1;
	return (sym);
}

/*
 * Process a single external declarator.
 */
void
decl1ext(sym_t *dsym, int initflg)
{
	int	warn, rval, redec;
	sym_t	*rdsym;

	chkfdef(dsym, 1);

	chktyp(dsym);

	if (initflg && !(initerr = chkinit(dsym)))
		dsym->s_def = DEF;

	/*
	 * Declarations of functions are marked as "tentative" in dname().
	 * This is wrong because there are no tentative function
	 * definitions.
	 */
	if (dsym->s_type->t_tspec == FUNC && dsym->s_def == TDEF)
		dsym->s_def = DECL;

	if (dcs->d_inline) {
		if (dsym->s_type->t_tspec == FUNC) {
			dsym->s_inline = 1;
		} else {
			/* variable declared inline: %s */
			warning(268, dsym->s_name);
		}
	}

	if (dsym->s_type->t_tspec == FUNC) {
		if (noretflg)
			dsym->s_noreturn = 1;
	}
	noretflg = 0;

	/* Write the declaration into the output file */
	if (plibflg && llibflg &&
	    dsym->s_type->t_tspec == FUNC && dsym->s_type->t_proto) {
		/*
		 * With both LINTLIBRARY and PROTOLIB the prototype is
		 * written as a function definition to the output file.
		 */
		rval = dsym->s_type->t_subt->t_tspec != VOID;
		outfdef(dsym, &dsym->s_dpos, rval, 0, NULL);
	} else {
		outsym(dsym, dsym->s_scl, dsym->s_def);
	}

	if ((rdsym = dcs->d_rdcsym) != NULL) {
		/*
		 * If the old symbol stems from a old style function definition
		 * we have remembered the params in rdsmy->s_args and compare
		 * them with the params of the prototype.
		 */
		if (rdsym->s_osdef && dsym->s_type->t_proto) {
			redec = chkosdef(rdsym, dsym);
		} else {
			redec = 0;
		}

		if (!redec && !isredec(dsym, (warn = 0, &warn))) {
			if (warn) {
				/* redeclaration of %s */
				(*(sflag ? error : warning))(27, dsym->s_name);
				prevdecl(-1, rdsym);
			}

			/*
			 * Overtake the rememberd params if the new symbol
			 * is not a prototype.
			 */
			if (rdsym->s_osdef && !dsym->s_type->t_proto) {
				dsym->s_osdef = rdsym->s_osdef;
				dsym->s_args = rdsym->s_args;
				STRUCT_ASSIGN(dsym->s_dpos, rdsym->s_dpos);
			}

			/*
			 * Remember the position of the declaration if the
			 * old symbol was a prototype and the new is not.
			 * Also remember the position if the old symbol
			 * was defined and the new is not.
			 */
			if (rdsym->s_type->t_proto && !dsym->s_type->t_proto) {
				STRUCT_ASSIGN(dsym->s_dpos, rdsym->s_dpos);
			} else if (rdsym->s_def == DEF && dsym->s_def != DEF) {
				STRUCT_ASSIGN(dsym->s_dpos, rdsym->s_dpos);
			}

			/*
			 * Copy informations about usage of the name into
			 * the new symbol.
			 */
			cpuinfo(dsym, rdsym);

			/* Once a name is defined, it remains defined. */
			if (rdsym->s_def == DEF)
				dsym->s_def = DEF;

			/* once a function is inline, it remains inline */
			if (rdsym->s_inline)
				dsym->s_inline = 1;

			compltyp(dsym, rdsym);

		}

		rmsym(rdsym);
	}

	if (dsym->s_scl == TYPEDEF) {
		dsym->s_type = duptyp(dsym->s_type);
		dsym->s_type->t_typedef = 1;
		settdsym(dsym->s_type, dsym);
	}

}

/*
 * Copies informations about usage into a new symbol table entry of
 * the same symbol.
 */
void
cpuinfo(sym_t *sym, sym_t *rdsym)
{
	sym->s_spos = rdsym->s_spos;
	sym->s_upos = rdsym->s_upos;
	sym->s_set = rdsym->s_set;
	sym->s_used = rdsym->s_used;
}

/*
 * Prints an error and returns 1 if a symbol is redeclared/redefined.
 * Otherwise returns 0 and, in some cases of minor problems, prints
 * a warning.
 */
int
isredec(sym_t *dsym, int *warn)
{
	sym_t	*rsym;

	if ((rsym = dcs->d_rdcsym)->s_scl == ENUMCON) {
		/* redeclaration of %s */
		error(27, dsym->s_name);
		prevdecl(-1, rsym);
		return (1);
	}
	if (rsym->s_scl == TYPEDEF) {
		/* typedef redeclared: %s */
		error(89, dsym->s_name);
		prevdecl(-1, rsym);
		return (1);
	}
	if (dsym->s_scl == TYPEDEF) {
		/* redeclaration of %s */
		error(27, dsym->s_name);
		prevdecl(-1, rsym);
		return (1);
	}
	if (rsym->s_def == DEF && dsym->s_def == DEF) {
		/* redefinition of %s */
		error(28, dsym->s_name);
		prevdecl(-1, rsym);
		return(1);
	}
	if (!eqtype(rsym->s_type, dsym->s_type, 0, 0, warn)) {
		/* redeclaration of %s */
		error(27, dsym->s_name);
		prevdecl(-1, rsym);
		return(1);
	}
	if (rsym->s_scl == EXTERN && dsym->s_scl == EXTERN)
		return(0);
	if (rsym->s_scl == STATIC && dsym->s_scl == STATIC)
		return(0);
	if (rsym->s_scl == STATIC && dsym->s_def == DECL)
		return(0);
	if (rsym->s_scl == EXTERN && rsym->s_def == DEF) {
		/*
		 * All cases except "int a = 1; static int a;" are caught
		 * above with or without a warning
		 */
		/* redeclaration of %s */
		error(27, dsym->s_name);
		prevdecl(-1, rsym);
		return(1);
	}
	if (rsym->s_scl == EXTERN) {
		/* previously declared extern, becomes static: %s */
		warning(29, dsym->s_name);
		prevdecl(-1, rsym);
		return(0);
	}
	/*
	 * Now its on of:
	 * "static a; int a;", "static a; int a = 1;", "static a = 1; int a;"
	 */
	/* redeclaration of %s; ANSI C requires "static" */
	if (sflag) {
		warning(30, dsym->s_name);
		prevdecl(-1, rsym);
	}
	dsym->s_scl = STATIC;
	return (0);
}

/*
 * Checks if two types are compatible. Returns 0 if not, otherwise 1.
 *
 * ignqual	ignore qualifiers of type; used for function params
 * promot	promote left type; used for comparison of params of
 *		old style function definitions with params of prototypes.
 * *warn	set to 1 if an old style function declaration is not
 *		compatible with a prototype
 */
int
eqtype(type_t *tp1, type_t *tp2, int ignqual, int promot, int *warn)
{
	tspec_t	t;

	while (tp1 != NULL && tp2 != NULL) {
		t = tp1->t_tspec;
		if (promot) {
			if (t == FLOAT) {
				t = DOUBLE;
			} else if (t == BOOL) {
				t = INT;
			} else if (t == CHAR || t == SCHAR) {
				t = INT;
			} else if (t == UCHAR) {
				t = INT;
			} else if (t == SHORT) {
				t = INT;
			} else if (t == USHORT) {
				/* CONSTCOND */
				t = INT_MAX < USHRT_MAX ? UINT : INT;
			} else if (t == COMPLEX) {
				t = DCOMPLEX;
			} else if (t == IMAGINARY) {
				t = DIMAGINARY;
			}
		}

		if (t != tp2->t_tspec)
			return (0);

		if (tp1->t_const != tp2->t_const && !ignqual)
			return (0);

		if (tp1->t_volatile != tp2->t_volatile && !ignqual)
			return (0);

		if (tp1->t_restrict != tp2->t_restrict && !ignqual)
			return (0);

		if (t == STRUCT || t == UNION)
			return (tp1->t_str == tp2->t_str);

		if (t == ARRAY && tp1->t_dim != tp2->t_dim) {
			if (tp1->t_dim != 0 && tp2->t_dim != 0)
				return (0);
		}

		/* dont check prototypes for traditional */
		if (t == FUNC) {
			if (tp1->t_proto && tp2->t_proto) {
				if (!eqargs(tp1, tp2, warn))
					return (0);
			} else if (tp1->t_proto) {
				if (!mnoarg(tp1, warn))
					return (0);
			} else if (tp2->t_proto) {
				if (!mnoarg(tp2, warn))
					return (0);
			}
		}

		tp1 = tp1->t_subt;
		tp2 = tp2->t_subt;
		ignqual = promot = 0;

	}

	return (tp1 == tp2);
}

/*
 * Compares the parameter types of two prototypes.
 */
static int
eqargs(type_t *tp1, type_t *tp2, int *warn)
{
	sym_t	*a1, *a2;

	if (tp1->t_vararg != tp2->t_vararg)
		return (0);

	a1 = tp1->t_args;
	a2 = tp2->t_args;

	while (a1 != NULL && a2 != NULL) {
		if (eqtype(a1->s_type, a2->s_type, 1, 0, warn) == 0)
			return (0);

		a1 = a1->s_nxt;
		a2 = a2->s_nxt;

	}

	return (a1 == a2);
}

/*
 * mnoarg() (matches functions with no argument type information)
 * returns 1 if all parameters of a prototype are compatible with
 * and old style function declaration.
 * This is the case if following conditions are met:
 *	1. the prototype must have a fixed number of parameters
 *	2. no parameter is of type float
 *	3. no parameter is converted to another type if integer promotion
 *	   is applied on it
 */
static int
mnoarg(type_t *tp, int *warn)
{
	sym_t	*arg;
	tspec_t	t;

	if (tp->t_vararg) {
		if (warn != NULL)
			*warn = 1;
	}
	for (arg = tp->t_args; arg != NULL; arg = arg->s_nxt) {
		if ((t = arg->s_type->t_tspec) == FLOAT || t == BOOL ||
		    t == CHAR || t == SCHAR || t == UCHAR ||
		    t == SHORT || t == USHORT || t == COMPLEX ||
		    t == DCOMPLEX || t == LDCOMPLEX || t == IMAGINARY ||
		    t == DIMAGINARY || t == LDIMAGINARY) {
			if (warn != NULL)
				*warn = 1;
		}
	}
	return (1);
}

/*
 * Compares a prototype declaration with the remembered arguments of
 * a previous old style function definition.
 */
static int
chkosdef(sym_t *rdsym, sym_t *dsym)
{
	sym_t	*args, *pargs, *arg, *parg;
	int	narg, nparg, n;
	int	warn, msg;

	args = rdsym->s_args;
	pargs = dsym->s_type->t_args;

	msg = 0;

	narg = nparg = 0;
	for (arg = args; arg != NULL; arg = arg->s_nxt)
		narg++;
	for (parg = pargs; parg != NULL; parg = parg->s_nxt)
		nparg++;
	if (narg != nparg) {
		/* prototype does not match old-style definition */
		error(63);
		msg = 1;
		goto end;
	}

	arg = args;
	parg = pargs;
	n = 1;
	while (narg--) {
		warn = 0;
		/*
		 * If it does not match due to promotion and sflag is
		 * not set we print only a warning.
		 */
		if (!eqtype(arg->s_type, parg->s_type, 1, 1, &warn) || warn) {
			/* prototype does not match old-style def., arg #%d */
			error(299, n);
			msg = 1;
		}
		arg = arg->s_nxt;
		parg = parg->s_nxt;
		n++;
	}

 end:
	if (msg)
		/* old style definition */
		prevdecl(300, rdsym);

	return (msg);
}

/*
 * Completes a type by copying the dimension and prototype information
 * from a second compatible type.
 *
 * Following lines are legal:
 *  "typedef a[]; a b; a b[10]; a c; a c[20];"
 *  "typedef ft(); ft f; f(int); ft g; g(long);"
 * This means that, if a type is completed, the type structure must
 * be duplicated.
 */
void
compltyp(sym_t *dsym, sym_t *ssym)
{
	type_t	**dstp, *src;
	type_t	*dst;

	dstp = &dsym->s_type;
	src = ssym->s_type;

	while ((dst = *dstp) != NULL) {
		if (src == NULL || dst->t_tspec != src->t_tspec)
			lerror("compltyp() 1");
		if (dst->t_tspec == ARRAY) {
			if (dst->t_dim == 0 && src->t_dim != 0) {
				*dstp = dst = duptyp(dst);
				dst->t_dim = src->t_dim;
				/* now a complete type */
				setcompl(dst, 0);
			}
		} else if (dst->t_tspec == FUNC) {
			if (!dst->t_proto && src->t_proto) {
				*dstp = dst = duptyp(dst);
				dst->t_proto = 1;
				dst->t_args = src->t_args;
			}
		}
		dstp = &dst->t_subt;
		src = src->t_subt;
	}
}

/*
 * Completes the declaration of a single argument.
 */
sym_t *
decl1arg(sym_t *sym, int initflg)
{
	tspec_t	t;

	chkfdef(sym, 1);

	chktyp(sym);

	if (dcs->d_rdcsym != NULL && dcs->d_rdcsym->s_blklev == blklev) {
		/* redeclaration of formal parameter %s */
		error(237, sym->s_name);
		rmsym(dcs->d_rdcsym);
		sym->s_arg = 1;
	}

	if (!sym->s_arg) {
		/* declared argument %s is missing */
		error(53, sym->s_name);
		sym->s_arg = 1;
	}

	if (initflg) {
		/* cannot initialize parameter: %s */
		error(52, sym->s_name);
		initerr = 1;
	}

	if ((t = sym->s_type->t_tspec) == ARRAY) {
		sym->s_type = incref(sym->s_type->t_subt, PTR);
	} else if (t == FUNC) {
		sym->s_type = incref(sym->s_type, PTR);
	}

	if (dcs->d_inline)
		/* argument declared inline: %s */
		warning(269, sym->s_name);

	/*
	 * Arguments must have complete types. lengths() prints the needed
	 * error messages (null dimension is impossible because arrays are
	 * converted to pointers).
	 */
	if (sym->s_type->t_tspec != VOID)
		(void)length(sym->s_type, sym->s_name);

	setsflg(sym);

	return (sym);
}

/*
 * Does some checks for lint directives which apply to functions.
 * Processes arguments in old style function definitions which default
 * to int.
 * Checks compatibility of old style function definition with previous
 * prototype.
 */
void
cluparg(void)
{
	sym_t	*args, *arg, *pargs, *parg;
	int	narg, nparg, n, msg;
	tspec_t	t;

	args = funcsym->s_args;
	pargs = funcsym->s_type->t_args;

	/* check for illegal combinations of lint directives */
	if (prflstrg != -1 && scflstrg != -1) {
		/* can't be used together: ** PRINTFLIKE ** ** SCANFLIKE ** */
		warning(289);
		prflstrg = scflstrg = -1;
	}
	if (nvararg != -1 && (prflstrg != -1 || scflstrg != -1)) {
		/* dubious use of ** VARARGS ** with ** %s ** */
		warning(288, prflstrg != -1 ? "PRINTFLIKE" : "SCANFLIKE");
		nvararg = -1;
	}

	/*
	 * check if the argument of a lint directive is compatible with the
	 * number of arguments.
	 */
	narg = 0;
	for (arg = dcs->d_fargs; arg != NULL; arg = arg->s_nxt)
		narg++;
	if (nargusg > narg) {
		/* argument number mismatch with directive: ** %s ** */
		warning(283, "ARGSUSED");
		nargusg = 0;
	}
	if (nvararg > narg) {
		/* argument number mismatch with directive: ** %s ** */
		warning(283, "VARARGS");
		nvararg = 0;
	}
	if (prflstrg > narg) {
		/* argument number mismatch with directive: ** %s ** */
		warning(283, "PRINTFLIKE");
		prflstrg = -1;
	} else if (prflstrg == 0) {
		prflstrg = -1;
	}
	if (scflstrg > narg) {
		/* argument number mismatch with directive: ** %s ** */
		warning(283, "SCANFLIKE");
		scflstrg = -1;
	} else if (scflstrg == 0) {
		scflstrg = -1;
	}
	if (prflstrg != -1 || scflstrg != -1) {
		narg = prflstrg != -1 ? prflstrg : scflstrg;
		arg = dcs->d_fargs;
		for (n = 1; n < narg; n++)
			arg = arg->s_nxt;
		if (arg->s_type->t_tspec != PTR ||
		    ((t = arg->s_type->t_subt->t_tspec) != CHAR &&
		     t != UCHAR && t != SCHAR)) {
			/* arg. %d must be 'char *' for PRINTFLIKE/SCANFLIKE */
			warning(293, narg);
			prflstrg = scflstrg = -1;
		}
	}

	/*
	 * print a warning for each argument of an old style function
	 * definition which defaults to int
	 */
	for (arg = args; arg != NULL; arg = arg->s_nxt) {
		if (arg->s_defarg) {
			/* argument type defaults to int: %s */
			warning(32, arg->s_name);
			arg->s_defarg = 0;
			setsflg(arg);
		}
	}

	/*
	 * If this is an old style function definition and a prototype
	 * exists, compare the types of arguments.
	 */
	if (funcsym->s_osdef && funcsym->s_type->t_proto) {
		/*
		 * If the number of arguments does not macht, we need not
		 * continue.
		 */
		narg = nparg = 0;
		msg = 0;
		for (parg = pargs; parg != NULL; parg = parg->s_nxt)
			nparg++;
		for (arg = args; arg != NULL; arg = arg->s_nxt)
			narg++;
		if (narg != nparg) {
			/* parameter mismatch: %d declared, %d defined */
			error(51, nparg, narg);
			msg = 1;
		} else {
			parg = pargs;
			arg = args;
			while (narg--) {
				msg |= chkptdecl(arg, parg);
				parg = parg->s_nxt;
				arg = arg->s_nxt;
			}
		}
		if (msg)
			/* prototype declaration */
			prevdecl(285, dcs->d_rdcsym);

		/* from now the prototype is valid */
		funcsym->s_osdef = 0;
		funcsym->s_args = NULL;

	}

}

/*
 * Checks compatibility of an old style function definition with a previous
 * prototype declaration.
 * Returns 1 if the position of the previous declaration should be reported.
 */
static int
chkptdecl(sym_t *arg, sym_t *parg)
{
	type_t	*tp, *ptp;
	int	warn, msg;

	tp = arg->s_type;
	ptp = parg->s_type;

	msg = 0;
	warn = 0;

	if (!eqtype(tp, ptp, 1, 1, &warn)) {
		if (eqtype(tp, ptp, 1, 0, &warn)) {
			/* type does not match prototype: %s */
			msg = gnuism(58, arg->s_name);
		} else {
			/* type does not match prototype: %s */
			error(58, arg->s_name);
			msg = 1;
		}
	} else if (warn) {
		/* type does not match prototype: %s */
		(*(sflag ? error : warning))(58, arg->s_name);
		msg = 1;
	}

	return (msg);
}

/*
 * Completes a single local declaration/definition.
 */
void
decl1loc(sym_t *dsym, int initflg)
{
	/* Correct a mistake done in dname(). */
	if (dsym->s_type->t_tspec == FUNC) {
		dsym->s_def = DECL;
		if (dcs->d_scl == NOSCL)
			dsym->s_scl = EXTERN;
	}

	if (dsym->s_type->t_tspec == FUNC) {
		if (dsym->s_scl == STATIC) {
			/* dubious static function at block level: %s */
			warning(93, dsym->s_name);
			dsym->s_scl = EXTERN;
		} else if (dsym->s_scl != EXTERN && dsym->s_scl != TYPEDEF) {
			/* function has illegal storage class: %s */
			error(94, dsym->s_name);
			dsym->s_scl = EXTERN;
		}
	}

	/*
	 * functions may be declared inline at local scope, although
	 * this has no effect for a later definition of the same
	 * function.
	 */
	if (dcs->d_inline) {
		if (dsym->s_type->t_tspec == FUNC) {
			dsym->s_inline = 1;
		} else {
			/* variable declared inline: %s */
			warning(268, dsym->s_name);
		}
	}

	chkfdef(dsym, 1);

	chktyp(dsym);

	if (dcs->d_rdcsym != NULL && dsym->s_scl == EXTERN)
		ledecl(dsym);

	if (dsym->s_scl == EXTERN) {
		/*
		 * XXX wenn die statische Variable auf Ebene 0 erst
		 * spaeter definiert wird, haben wir die Brille auf.
		 */
		if (dsym->s_xsym == NULL) {
			outsym(dsym, EXTERN, dsym->s_def);
		} else {
			outsym(dsym, dsym->s_xsym->s_scl, dsym->s_def);
		}
	}

	if (dcs->d_rdcsym != NULL) {
		if (dcs->d_rdcsym->s_blklev == 0) {
			switch (dsym->s_scl) {
			case AUTO:
				/* automatic hides external declaration: %s */
				if (hflag)
					warning(86, dsym->s_name);
				break;
			case STATIC:
				/* static hides external declaration: %s */
				if (hflag)
					warning(87, dsym->s_name);
				break;
			case TYPEDEF:
				/* typedef hides  external declaration: %s */
				if (hflag)
					warning(88, dsym->s_name);
				break;
			case EXTERN:
				/*
				 * Warnings and errors are printed in ledecl()
				 */
				break;
			default:
				lerror("decl1loc() 1");
			}
		} else if (dcs->d_rdcsym->s_blklev == blklev) {
			/* no hflag, because its illegal! */
			if (dcs->d_rdcsym->s_arg) {
				/*
				 * a "redeclaration of %s" error
				 * is produced below
				 */
			}

		} else if (dcs->d_rdcsym->s_blklev < blklev) {
			if (hflag)
				/* declaration hides earlier one: %s */
				warning(95, dsym->s_name);
		}

		if (dcs->d_rdcsym->s_blklev == blklev) {
			/* redeclaration of %s */
			error(27, dsym->s_name);
			rmsym(dcs->d_rdcsym);
		}
	}

	if (initflg && !(initerr = chkinit(dsym))) {
		dsym->s_def = DEF;
		setsflg(dsym);
	}

	if (dsym->s_scl == TYPEDEF) {
		dsym->s_type = duptyp(dsym->s_type);
		dsym->s_type->t_typedef = 1;
		settdsym(dsym->s_type, dsym);
	}

	/*
	 * Before we can check the size we must wait for a initialisation
	 * which may follow.
	 */
}

/*
 * Processes (re)declarations of external Symbols inside blocks.
 */
static void
ledecl(sym_t *dsym)
{
	int	eqt, warn;
	sym_t	*esym;

	/* look for a symbol with the same name */
	esym = dcs->d_rdcsym;
	while (esym != NULL && esym->s_blklev != 0) {
		while ((esym = esym->s_link) != NULL) {
			if (esym->s_kind != FVFT)
				continue;
			if (strcmp(dsym->s_name, esym->s_name) == 0)
				break;
		}
	}
	if (esym == NULL)
		return;
	if (esym->s_scl != EXTERN && esym->s_scl != STATIC) {
		/* gcc accepts this without a warning, pcc prints an error. */
		/* redeclaration of %s */
		warning(27, dsym->s_name);
		prevdecl(-1, esym);
		return;
	}

	warn = 0;
	eqt = eqtype(esym->s_type, dsym->s_type, 0, 0, &warn);

	if (!eqt || warn) {
		if (esym->s_scl == EXTERN) {
			/* inconsistent redeclaration of extern: %s */
			warning(90, dsym->s_name);
			prevdecl(-1, esym);
		} else {
			/* inconsistent redeclaration of static: %s */
			warning(92, dsym->s_name);
			prevdecl(-1, esym);
		}
	}

	if (eqt) {
		/*
		 * Remember the external symbol so we can update usage
		 * information at the end of the block.
		 */
		dsym->s_xsym = esym;
	}
}

/*
 * Print an error or a warning if the symbol can't be initialized due
 * to type/storage class. Return value is 1 if an error has been
 * detected.
 */
static int
chkinit(sym_t *sym)
{
	int	err;

	err = 0;

	if (sym->s_type->t_tspec == FUNC) {
		/* cannot initialize function: %s */
		error(24, sym->s_name);
		err = 1;
	} else if (sym->s_scl == TYPEDEF) {
		/* cannot initialize typedef: %s */
		error(25, sym->s_name);
		err = 1;
	} else if (sym->s_scl == EXTERN && sym->s_def == DECL) {
		/* cannot initialize "extern" declaration: %s */
		if (dcs->d_ctx == EXTERN) {
			warning(26, sym->s_name);
		} else {
			error(26, sym->s_name);
			err = 1;
		}
	}

	return (err);
}

/*
 * Create a symbole for an abstract declaration.
 */
sym_t *
aname(void)
{
	sym_t	*sym;

	if (dcs->d_ctx != ABSTRACT && dcs->d_ctx != PARG)
		lerror("aname()");

	sym = getblk(sizeof (sym_t));

	sym->s_name = unnamed;
	sym->s_def = DEF;
	sym->s_scl = ABSTRACT;
	sym->s_blklev = -1;

	if (dcs->d_ctx == PARG)
		sym->s_arg = 1;

	sym->s_type = dcs->d_type;
	dcs->d_rdcsym = NULL;
	dcs->d_vararg = 0;

	return (sym);
}

/*
 * Removes anything which has nothing to do on global level.
 */
void
globclup(void)
{
	while (dcs->d_nxt != NULL)
		popdecl();

	cleanup();
	blklev = 0;
	mblklev = 0;

	/*
	 * remove all information about pending lint directives without
	 * warnings.
	 */
	glclup(1);
}

/*
 * Process an abstract type declaration
 */
sym_t *
decl1abs(sym_t *sym)
{
	chkfdef(sym, 1);
	chktyp(sym);
	return (sym);
}

/*
 * Checks size after declarations of variables and their initialisation.
 */
void
chksz(sym_t *dsym)
{
	/*
	 * check size only for symbols which are defined and no function and
	 * not typedef name
	 */
	if (dsym->s_def != DEF)
		return;
	if (dsym->s_scl == TYPEDEF)
		return;
	if (dsym->s_type->t_tspec == FUNC)
		return;

	if (length(dsym->s_type, dsym->s_name) == 0 &&
	    dsym->s_type->t_tspec == ARRAY && dsym->s_type->t_dim == 0) {
		/* empty array declaration: %s */
		error(190, dsym->s_name);
	}
}

/*
 * Mark an object as set if it is not already
 */
void
setsflg(sym_t *sym)
{
	if (!sym->s_set) {
		sym->s_set = 1;
		STRUCT_ASSIGN(sym->s_spos, curr_pos);
	}
}

/*
 * Mark an object as used if it is not already
 */
void
setuflg(sym_t *sym, int fcall, int szof)
{
	if (!sym->s_used) {
		sym->s_used = 1;
		STRUCT_ASSIGN(sym->s_upos, curr_pos);
	}
	/*
	 * for function calls another record is written
	 *
	 * XXX Should symbols used in sizeof() treated as used or not?
	 * Probably not, because there is no sense to declare an
	 * external variable only to get their size.
	 */
	if (!fcall && !szof && sym->s_kind == FVFT && sym->s_scl == EXTERN)
		outusg(sym);
}

/*
 * Prints warnings for a list of variables and labels (concatenated
 * with s_dlnxt) if these are not used or only set.
 */
void
chkusage(dinfo_t *di)
{
	sym_t	*sym;
	int	mknowarn;

	/* for this warnings LINTED has no effect */
	mknowarn = nowarn;
	nowarn = 0;

	for (sym = di->d_dlsyms; sym != NULL; sym = sym->s_dlnxt)
		chkusg1(di->d_asm, sym);

	nowarn = mknowarn;
}

/*
 * Prints a warning for a single variable or label if it is not used or
 * only set.
 */
void
chkusg1(int novar, sym_t *sym)
{
	pos_t	cpos;

	if (sym->s_blklev == -1)
		return;

	STRUCT_ASSIGN(cpos, curr_pos);

	if (sym->s_kind == FVFT) {
		if (sym->s_arg) {
			chkausg(novar, sym);
		} else {
			chkvusg(novar, sym);
		}
	} else if (sym->s_kind == FLAB) {
		chklusg(sym);
	} else if (sym->s_kind == FTAG) {
		chktusg(sym);
	}

	STRUCT_ASSIGN(curr_pos, cpos);
}

static void
chkausg(int novar, sym_t *arg)
{
	if (!arg->s_set)
		lerror("chkausg() 1");

	if (novar)
		return;

	if (!arg->s_used && vflag) {
		STRUCT_ASSIGN(curr_pos, arg->s_dpos);
		/* argument %s unused in function %s */
		warning(231, arg->s_name, funcsym->s_name);
	}
}

static void
chkvusg(int novar, sym_t *sym)
{
	scl_t	sc;
	sym_t	*xsym;

	if (blklev == 0 || sym->s_blklev == 0)
		lerror("chkvusg() 1");

	/* errors in expressions easily cause lots of these warnings */
	if (nerr != 0)
		return;

	/*
	 * XXX Only variables are checkd, although types should
	 * probably also be checked
	 */
	if ((sc = sym->s_scl) != EXTERN && sc != STATIC &&
	    sc != AUTO && sc != REG) {
		return;
	}

	if (novar)
		return;

	if (sc == EXTERN) {
		if (!sym->s_used && !sym->s_set) {
			STRUCT_ASSIGN(curr_pos, sym->s_dpos);
			/* %s unused in function %s */
			warning(192, sym->s_name, funcsym->s_name);
		}
	} else {
		if (sym->s_set && !sym->s_used) {
			STRUCT_ASSIGN(curr_pos, sym->s_spos);
			/* %s set but not used in function %s */
			warning(191, sym->s_name, funcsym->s_name);
		} else if (!sym->s_used) {
			STRUCT_ASSIGN(curr_pos, sym->s_dpos);
			/* %s unused in function %s */
			warning(192, sym->s_name, funcsym->s_name);
		}
	}

	if (sc == EXTERN) {
		/*
		 * information about usage is taken over into the symbol
		 * tabel entry at level 0 if the symbol was locally declared
		 * as an external symbol.
		 *
		 * XXX This is wrong for symbols declared static at level 0
		 * if the usage information stems from sizeof(). This is
		 * because symbols at level 0 only used in sizeof() are
		 * considered to not be used.
		 */
		if ((xsym = sym->s_xsym) != NULL) {
			if (sym->s_used && !xsym->s_used) {
				xsym->s_used = 1;
				STRUCT_ASSIGN(xsym->s_upos, sym->s_upos);
			}
			if (sym->s_set && !xsym->s_set) {
				xsym->s_set = 1;
				STRUCT_ASSIGN(xsym->s_spos, sym->s_spos);
			}
		}
	}
}

static void
chklusg(sym_t *lab)
{
	if (blklev != 1 || lab->s_blklev != 1)
		lerror("chklusg() 1");

	if (lab->s_set && !lab->s_used) {
		STRUCT_ASSIGN(curr_pos, lab->s_spos);
		/* label %s unused in function %s */
		warning(192, lab->s_name, funcsym->s_name);
	} else if (!lab->s_set) {
		STRUCT_ASSIGN(curr_pos, lab->s_upos);
		/* undefined label %s */
		warning(23, lab->s_name);
	}
}

static void
chktusg(sym_t *sym)
{
	if (!incompl(sym->s_type))
		return;

	/* complain always about incomplete tags declared inside blocks */
	if (!zflag || dcs->d_ctx != EXTERN)
		return;

	STRUCT_ASSIGN(curr_pos, sym->s_dpos);
	switch (sym->s_type->t_tspec) {
	case STRUCT:
		/* struct %s never defined */
		warning(233, sym->s_name);
		break;
	case UNION:
		/* union %s never defined */
		warning(234, sym->s_name);
		break;
	case ENUM:
		/* enum %s never defined */
		warning(235, sym->s_name);
		break;
	default:
		lerror("chktusg() 1");
	}
}

/*
 * Called after the entire translation unit has been parsed.
 * Changes tentative definitions in definitions.
 * Performs some tests on global Symbols. Detected Problems are:
 * - defined variables of incomplete type
 * - constant variables which are not initialized
 * - static symbols which are never used
 */
void
chkglsyms(void)
{
	sym_t	*sym;
	pos_t	cpos;

	if (blklev != 0 || dcs->d_nxt != NULL)
		norecover();

	STRUCT_ASSIGN(cpos, curr_pos);

	for (sym = dcs->d_dlsyms; sym != NULL; sym = sym->s_dlnxt) {
		if (sym->s_blklev == -1)
			continue;
		if (sym->s_kind == FVFT) {
			chkglvar(sym);
		} else if (sym->s_kind == FTAG) {
			chktusg(sym);
		} else {
			if (sym->s_kind != FMOS)
				lerror("chkglsyms() 1");
		}
	}

	STRUCT_ASSIGN(curr_pos, cpos);
}

static void
chkglvar(sym_t *sym)
{
	if (sym->s_scl == TYPEDEF || sym->s_scl == ENUMCON)
		return;

	if (sym->s_scl != EXTERN && sym->s_scl != STATIC)
		lerror("chkglvar() 1");

	glchksz(sym);

	if (sym->s_scl == STATIC) {
		if (sym->s_type->t_tspec == FUNC) {
			if (sym->s_used && sym->s_def != DEF) {
				STRUCT_ASSIGN(curr_pos, sym->s_upos);
				/* static func. called but not def.. */
				error(225, sym->s_name);
			}
		}
		if (!sym->s_used) {
			STRUCT_ASSIGN(curr_pos, sym->s_dpos);
			if (sym->s_type->t_tspec == FUNC) {
				if (sym->s_def == DEF) {
					if (!sym->s_inline)
						/* static function %s unused */
						warning(236, sym->s_name);
				} else {
					/* static function %s decl. but ... */
					warning(290, sym->s_name);
				}
			} else if (!sym->s_set) {
				if (strncmp(sym->s_name, "__LINTED__", 10))
					/* static variable %s unused */
					warning(226, sym->s_name);
			} else {
				/* static variable %s set but not used */
				warning(307, sym->s_name);
			}
		}
		if (sym->s_def == TDEF && sym->s_type->t_const) {
			STRUCT_ASSIGN(curr_pos, sym->s_dpos);
			/* const object %s should have initializer */
			warning(227, sym->s_name);
		}
	}
}

static void
glchksz(sym_t *sym)
{
	if (sym->s_def == TDEF) {
		if (sym->s_type->t_tspec == FUNC)
			/*
			 * this can happen if a syntax error occurred
			 * after a function declaration
			 */
			return;
		STRUCT_ASSIGN(curr_pos, sym->s_dpos);
		if (length(sym->s_type, sym->s_name) == 0 &&
		    sym->s_type->t_tspec == ARRAY && sym->s_type->t_dim == 0) {
			/* empty array declaration: %s */
			if (sym->s_scl == EXTERN && !sflag) {
				warning(190, sym->s_name);
			} else {
				error(190, sym->s_name);
			}
		}
	}
}

/*
 * Prints information about location of previous definition/declaration.
 */
void
prevdecl(int msg, sym_t *psym)
{
	pos_t	cpos;

	if (!rflag)
		return;

	STRUCT_ASSIGN(cpos, curr_pos);
	STRUCT_ASSIGN(curr_pos, psym->s_dpos);
	if (msg != -1) {
		message(msg, psym->s_name);
	} else if (psym->s_def == DEF || psym->s_def == TDEF) {
		/* previous definition of %s */
		message(261, psym->s_name);
	} else {
		/* previous declaration of %s */
		message(260, psym->s_name);
	}
	STRUCT_ASSIGN(curr_pos, cpos);
}
@


1.2
log
@our lint(1) now can handle RCS IDs (by prefixing the variable, d'oh)
@
text
@d1 1
a1 2
/**	$MirOS$ */
/*	$OpenBSD: decl.c,v 1.10 2004/08/03 00:09:54 deraadt Exp $	*/
a34 4
#if 0
static char rcsid[] = "$OpenBSD: decl.c,v 1.10 2004/08/03 00:09:54 deraadt Exp $";
#endif

d39 1
d43 1
a43 1
__RCSID("$MirOS$");
d50 1
a50 1
/* shared type structures for arithmtic types and void */
d86 1
a86 1
initdecl()
d93 1
a93 1
		{ SIGNED,   { 0, 0,
d96 1
a96 1
		{ UNSIGN,   { 0, 0,
d99 4
a102 1
		{ CHAR,	    { CHAR_BIT, CHAR_BIT,
d105 1
a105 1
		{ SCHAR,    { CHAR_BIT, CHAR_BIT,
d108 1
a108 1
		{ UCHAR,    { CHAR_BIT, CHAR_BIT,
d111 1
a111 1
		{ SHORT,    { sizeof (short) * CHAR_BIT, 2 * CHAR_BIT,
d114 1
a114 1
		{ USHORT,   { sizeof (u_short) * CHAR_BIT, 2 * CHAR_BIT,
d117 1
a117 1
		{ INT,      { sizeof (int) * CHAR_BIT, 3 * CHAR_BIT,
d120 1
a120 1
		{ UINT,     { sizeof (u_int) * CHAR_BIT, 3 * CHAR_BIT,
d123 1
a123 1
		{ LONG,     { sizeof (long) * CHAR_BIT, 4 * CHAR_BIT,
d126 1
a126 1
		{ ULONG,    { sizeof (u_long) * CHAR_BIT, 4 * CHAR_BIT,
d129 1
a129 1
		{ QUAD,     { sizeof (quad_t) * CHAR_BIT, 8 * CHAR_BIT,
d132 1
a132 1
		{ UQUAD,    { sizeof (u_quad_t) * CHAR_BIT, 8 * CHAR_BIT,
d135 1
a135 1
		{ FLOAT,    { sizeof (float) * CHAR_BIT, 4 * CHAR_BIT,
d138 1
a138 1
		{ DOUBLE,   { sizeof (double) * CHAR_BIT, 8 * CHAR_BIT,
d141 1
a141 1
		{ LDOUBLE,  { sizeof (ldbl_t) * CHAR_BIT, 10 * CHAR_BIT,
d144 27
a170 1
		{ VOID,     { -1, -1,
d173 1
a173 1
		{ STRUCT,   { -1, -1,
d176 1
a176 1
		{ UNION,    { -1, -1,
d179 1
a179 1
		{ ENUM,     { sizeof (int) * CHAR_BIT, 3 * CHAR_BIT,
d182 1
a182 1
		{ PTR,      { sizeof (void *) * CHAR_BIT, 4 * CHAR_BIT,
d185 1
a185 1
		{ ARRAY,    { -1, -1,
d188 1
a188 1
		{ FUNC,     { -1, -1,
d210 1
d225 6
d241 1
a241 1
 * Returns a shared type structure vor arithmetic types and void.
d247 1
a247 2
gettyp(t)
	tspec_t	t;
d253 1
a253 2
duptyp(tp)
	const	type_t *tp;
d267 1
a267 2
tduptyp(tp)
	const	type_t *tp;
d281 1
a281 2
incompl(tp)
	type_t	*tp;
d302 1
a302 3
setcompl(tp, ic)
	type_t	*tp;
	int	ic;
d323 1
a323 2
addscl(sc)
	scl_t	sc;
d359 1
a359 2
addtype(tp)
	type_t	*tp;
d365 2
a366 1
		    dcs->d_lmod != NOTSPEC || dcs->d_smod != NOTSPEC) {
d385 2
a386 1
		    dcs->d_lmod != NOTSPEC || dcs->d_smod != NOTSPEC) {
d392 2
a393 1
			dcs->d_atyp = dcs->d_lmod = dcs->d_smod = NOTSPEC;
d414 1
a414 1
			(void)gnuism(265, tflag ? "traditional" : "ANSI");
d442 9
d468 1
a468 3
tdeferr(td, t)
	type_t	*td;
	tspec_t	t;
d479 2
a480 3
			if (!tflag)
				/* modifying typedef with ... */
				warning(5, ttab[t].tt_name);
d497 2
a498 1
		    t2 == FLOAT || t2 == DOUBLE) {
d513 8
d546 1
a546 3
settdsym(tp, sym)
	type_t	*tp;
	sym_t	*sym;
d564 1
a564 1
 * The rememberd qualifier is used by deftyp() to construct the type
d568 1
a568 2
addqual(q)
	tqual_t	q;
d576 1
a576 3
	} else {
		if (q != VOLATILE)
			lerror("addqual() 1");
d582 8
a589 1
	}
d597 1
a597 2
pushdecl(sc)
	scl_t	sc;
d616 1
a616 1
popdecl()
d701 1
a701 1
setasm()
d714 1
a714 1
clrtyp()
d716 1
a716 1
	dcs->d_atyp = dcs->d_smod = dcs->d_lmod = NOTSPEC;
d727 27
d760 1
a760 1
deftyp()
d762 1
a762 1
	tspec_t	t, s, l;
d766 2
a767 1
	t = dcs->d_atyp;		/* CHAR, INT, FLOAT, DOUBLE, VOID */
d770 1
d787 2
d803 2
a804 3
				if (!tflag)
					/* use 'double' instead of ...  */
					warning(6);
a810 3
				if (tflag)
					/* 'long double' is illegal in ... */
					warning(266);
d818 2
d878 1
a878 2
mrgtspec(t, s)
	tspec_t	t, s;
d905 1
a905 3
length(tp, name)
	type_t	*tp;
	const	char *name;
d910 1
a910 1
	while (tp->t_tspec == ARRAY) {
d914 3
d946 1
a946 1
 * Get the alignment of the given Type in bits.
d949 1
a949 2
getbound(tp)
	type_t	*tp;
d954 1
a954 1
	while (tp->t_tspec == ARRAY)
d957 3
d983 1
a983 2
lnklst(l1, l2)
	sym_t	*l1, *l2;
d1005 1
a1005 2
chktyp(sym)
	sym_t	*sym;
d1035 1
a1035 1
				if (sflag) {	/* XXX oder better !tflag ? */
d1082 1
a1082 1
			if (tp->t_const || tp->t_volatile) {
d1086 1
d1098 1
a1098 2
decl1str(dsym)
	sym_t	*dsym;
d1127 2
a1128 2
		 * only unsigned und signed int are protable bit-field types
		 *(at least in ANSI C, in traditional C only unsigned int)
d1139 6
d1151 1
a1151 1
		    t != ULONG && t != QUAD && t != UQUAD) {
d1222 1
a1222 2
align(al, len)
	int	al, len;
d1243 1
a1243 3
bitfield(dsym, len)
	sym_t	*dsym;
	int	len;
d1255 2
d1269 1
a1269 2
mergepq(p1, p2)
	pqinf_t	*p1, *p2;
d1302 1
a1302 1
 * The current type is the Type built by deftyp() (dcs->d_type) and
d1307 1
a1307 3
addptr(decl, pi)
	sym_t	*decl;
	pqinf_t	*pi;
d1313 1
a1313 1
	while (*tpp != dcs->d_type)
d1315 2
d1336 1
a1336 3
addarray(decl, dim, n)
	sym_t	*decl;
	int	dim, n;
d1341 1
a1341 1
	while (*tpp != dcs->d_type)
d1343 2
d1367 1
a1367 2
addfunc(decl, args)
	sym_t	*decl, *args;
a1371 3
		if (tflag)
			/* function prototypes are illegal in traditional C */
			warning(270);
d1394 1
a1394 1
	while (*tpp != dcs->d_nxt->d_type)
d1396 2
d1414 1
a1414 2
nsfunc(decl, args)
	sym_t	*decl, *args;
d1452 1
a1452 2
osfunc(decl, args)
	sym_t	*decl, *args;
d1481 1
a1481 3
chkfdef(sym, msg)
	sym_t	*sym;
	int	msg;
d1501 1
a1501 2
dname(sym)
	sym_t	*sym;
d1599 1
a1599 2
iname(sym)
	sym_t	*sym;
d1627 1
a1627 4
mktag(tag, kind, decl, semi)
	sym_t	*tag;
	tspec_t	kind;
	int	decl, semi;
d1649 1
a1649 1
				if (!tflag && (sflag || pflag))
d1682 1
a1682 1
		/* ist unvollstaendiger Typ */
d1695 1
a1695 4
newtag(tag, scl, decl, semi)
	sym_t	*tag;
	scl_t	scl;
	int	decl, semi;
d1700 4
a1703 9
			if (!tflag) {
				if (!sflag)
					/* decl. introduces new type ... */
					warning(44, scltoa(scl), tag->s_name);
				tag = pushdown(tag);
			} else if (tag->s_scl != scl) {
				/* base type is really "%s %s" */
				warning(45, scltoa(tag->s_scl), tag->s_name);
			}
d1742 1
a1742 2
scltoa(sc)
	scl_t	sc;
d1765 1
a1765 3
compltag(tp, fmem)
	type_t	*tp;
	sym_t	*fmem;
d1782 4
a1785 2
			/* zero sized %s */
			(void)gnuism(47, ttab[t].tt_name);
d1809 1
a1809 1
 * impl is 1 if the the value of the enumerator was not explicit specified.
d1812 1
a1812 3
ename(sym, val, impl)
	sym_t	*sym;
	int	val, impl;
d1854 1
a1854 3
decl1ext(dsym, initflg)
	sym_t	*dsym;
	int	initflg;
d1883 6
d1893 1
a1893 1
		 * With both LINTLIBRARY and PROTOLIB the prototyp is
a1902 1

a1914 1

d1977 1
a1977 2
cpuinfo(sym, rdsym)
	sym_t	*sym, *rdsym;
d1991 1
a1991 3
isredec(dsym, warn)
	sym_t	*dsym;
	int	*warn;
d2033 1
a2033 1
		 * All cases except "int a = 1; static int a;" are catched
d2070 1
a2070 3
eqtype(tp1, tp2, ignqual, promot, warn)
	type_t	*tp1, *tp2;
	int	ignqual, promot, *warn;
a2074 1

d2079 2
d2084 1
a2084 1
				t = tflag ? UINT : INT;
d2089 5
a2093 1
				t = INT_MAX < USHRT_MAX || tflag ? UINT : INT;
d2100 4
a2103 1
		if (tp1->t_const != tp2->t_const && !ignqual && !tflag)
d2106 1
a2106 1
		if (tp1->t_volatile != tp2->t_volatile && !ignqual && !tflag)
d2118 1
a2118 1
		if (t == FUNC && !tflag) {
d2144 1
a2144 3
eqargs(tp1, tp2, warn)
	type_t	*tp1, *tp2;
	int	*warn;
a2154 1

d2177 1
a2177 3
mnoarg(tp, warn)
	type_t	*tp;
	int	*warn;
d2187 1
a2187 1
		if ((t = arg->s_type->t_tspec) == FLOAT ||
d2189 3
a2191 1
		    t == SHORT || t == USHORT) {
d2204 1
a2204 2
chkosdef(rdsym, dsym)
	sym_t	*rdsym, *dsym;
d2255 1
a2255 1
 * Complets a type by copying the dimension and prototype information
d2265 1
a2265 2
compltyp(dsym, ssym)
	sym_t	*dsym, *ssym;
d2280 1
a2280 1
				/* now a complete Typ */
d2299 1
a2299 3
decl1arg(sym, initflg)
	sym_t	*sym;
	int	initflg;
a2328 3
		if (tflag)
			/* a function is declared as an argument: %s */
			warning(50, sym->s_name);
a2329 3
	} else if (t == FLOAT) {
		if (tflag)
			sym->s_type = gettyp(DOUBLE);
d2353 1
a2353 1
 * Checks compatiblility of old style function definition with previous
d2357 1
a2357 1
cluparg()
d2424 1
a2424 1
	 * print a warning for each argument off an old style function
d2437 1
a2437 1
	 * If this is an old style function definition and a prototyp
d2482 1
a2482 2
chkptdecl(arg, parg)
	sym_t	*arg, *parg;
d2515 1
a2515 3
decl1loc(dsym, initflg)
	sym_t	*dsym;
	int	initflg;
a2539 2
	 * XXX it should have an effect if tflag is set. this would
	 * also be the way gcc behaves.
a2569 1

a2570 1

a2594 1

a2595 1

d2599 1
a2599 1
				 * if !tflag, a "redeclaration of %s" error
a2601 6
				if (tflag) {
					if (hflag)
						/* decl. hides parameter: %s */
						warning(91, dsym->s_name);
					rmsym(dcs->d_rdcsym);
				}
a2604 1

a2607 1

a2610 1

a2613 1

a2614 1

d2638 1
a2638 2
ledecl(dsym)
	sym_t	*dsym;
d2688 2
a2689 2
 * Print an error or a warning if the symbol cant be initialized due
 * to type/storage class. Returnvalue is 1 if an error has been
d2693 1
a2693 2
chkinit(sym)
	sym_t	*sym;
d2724 1
a2724 1
aname()
d2752 1
a2752 1
globclup()
d2762 1
a2762 1
	 * remove all informations about pending lint directives without
d2772 1
a2772 2
decl1abs(sym)
	sym_t	*sym;
d2783 1
a2783 2
chksz(dsym)
	sym_t	*dsym;
d2799 1
a2799 5
		if (tflag) {
			warning(190, dsym->s_name);
		} else {
			error(190, dsym->s_name);
		}
d2807 1
a2807 2
setsflg(sym)
	sym_t	*sym;
d2819 1
a2819 3
setuflg(sym, fcall, szof)
	sym_t	*sym;
	int	fcall, szof;
d2841 1
a2841 2
chkusage(di)
	dinfo_t	*di;
d2861 1
a2861 3
chkusg1(novar, sym)
	int	novar;
	sym_t	*sym;
d2886 1
a2886 3
chkausg(novar, arg)
	int	novar;
	sym_t	*arg;
d2902 1
a2902 3
chkvusg(novar, sym)
	int	novar;
	sym_t	*sym;
d2969 1
a2969 2
chklusg(lab)
	sym_t	*lab;
d2986 1
a2986 2
chktusg(sym)
	sym_t	*sym;
d2991 1
a2991 1
	/* complain alwasy about incomplet tags declared inside blocks */
d3023 1
a3023 1
chkglsyms()
d3050 1
a3050 2
chkglvar(sym)
	sym_t	*sym;
d3088 1
a3088 1
		if (!tflag && sym->s_def == TDEF && sym->s_type->t_const) {
d3097 1
a3097 2
glchksz(sym)
	sym_t	*sym;
d3102 1
a3102 1
			 * this can happen if an syntax error occurred
d3110 1
a3110 1
			if (tflag || (sym->s_scl == EXTERN && !sflag)) {
d3123 1
a3123 3
prevdecl(msg, psym)
	int	msg;
	sym_t	*psym;
@


1.1
log
@Initial revision
@
text
@d1 1
d36 1
a36 1
#ifndef lint
d47 2
d180 1
a180 1
	
d418 1
a418 1
		 * "double" int dcs->d_atyp 
d1156 1
a1156 1
	
d1390 1
a1390 1
		 * we are wrong, its corrected in chkfdef(). 
d1858 1
a1858 1
		
d1904 1
a1904 1
		
d2425 1
a2425 1
		
d2578 1
a2578 1
			
d3049 1
a3049 1
	
d3075 3
a3077 2
				/* static variable %s unused */
				warning(226, sym->s_name);
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@import lint(1) from OBSD before they killed it
@
text
@d1 1
a1 1
/*	$OpenBSD: decl.c,v 1.30 2011/09/21 18:08:07 jsg Exp $	*/
d35 4
a42 2
#include <stdbool.h>
#include <complex.h>
d51 1
a51 1
/* shared type structures for arithmetic types and void */
d87 1
a87 1
initdecl(void)
d94 1
a94 1
		{ SIGNED,   { 0, 0, 0,
d97 1
a97 1
		{ UNSIGN,   { 0, 0, 0,
d100 1
a100 4
		{ BOOL,	    { sizeof (_Bool) * CHAR_BIT, CHAR_BIT, 1,
			      BOOL, BOOL,
			      1, 1, 0, 1, 1, "_Bool" } },
		{ CHAR,	    { CHAR_BIT, CHAR_BIT, 20,
d103 1
a103 1
		{ SCHAR,    { CHAR_BIT, CHAR_BIT, 20,
d106 1
a106 1
		{ UCHAR,    { CHAR_BIT, CHAR_BIT, 20,
d109 1
a109 1
		{ SHORT,    { sizeof (short) * CHAR_BIT, 2 * CHAR_BIT, 30,
d112 1
a112 1
		{ USHORT,   { sizeof (u_short) * CHAR_BIT, 2 * CHAR_BIT, 30,
d115 1
a115 1
		{ INT,      { sizeof (int) * CHAR_BIT, 3 * CHAR_BIT, 40,
d118 1
a118 1
		{ UINT,     { sizeof (u_int) * CHAR_BIT, 3 * CHAR_BIT, 40,
d121 1
a121 1
		{ LONG,     { sizeof (long) * CHAR_BIT, 4 * CHAR_BIT, 50,
d124 1
a124 1
		{ ULONG,    { sizeof (u_long) * CHAR_BIT, 4 * CHAR_BIT, 50,
d127 1
a127 1
		{ QUAD,     { sizeof (quad_t) * CHAR_BIT, 8 * CHAR_BIT, 60,
d130 1
a130 1
		{ UQUAD,    { sizeof (u_quad_t) * CHAR_BIT, 8 * CHAR_BIT, 60,
d133 1
a133 1
		{ FLOAT,    { sizeof (float) * CHAR_BIT, 4 * CHAR_BIT, -1,
d136 1
a136 1
		{ DOUBLE,   { sizeof (double) * CHAR_BIT, 8 * CHAR_BIT, -1,
d139 1
a139 1
		{ LDOUBLE,  { sizeof (ldbl_t) * CHAR_BIT, 16 * CHAR_BIT, -1,
d142 1
a142 27
		{ COMPLEX,  { sizeof (float _Complex) * CHAR_BIT,
			      8 * CHAR_BIT, -1,
			      COMPLEX, COMPLEX,
			      0, 0, 1, 1, 3, "float _Complex" } },
		{ DCOMPLEX, { sizeof (double _Complex) * CHAR_BIT,
			      16 * CHAR_BIT, -1,
			      DCOMPLEX, DCOMPLEX,
			      0, 0, 1, 1, 3, "double _Complex" } },
		{ LDCOMPLEX,{ sizeof (long double _Complex) * CHAR_BIT,
			      32 * CHAR_BIT, -1,
			      LDCOMPLEX, LDCOMPLEX,
			      0, 0, 1, 1, 3, "long double _Complex" } },
#if 0
		{ IMAGINARY,{ sizeof (float _Imaginary) * CHAR_BIT,
			      4 * CHAR_BIT, -1,
			      IMAGINARY, IMAGINARY,
			      0, 0, 1, 1, 2, "float _Imaginary" } },
		{ DIMAGINARY,{ sizeof (double _Imaginary) * CHAR_BIT,
			      8 * CHAR_BIT, -1,
			      DIMAGINARY, DIMAGINARY,
			      0, 0, 1, 1, 2, "double _Imaginary" } },
		{ LDIMAGINARY,{ sizeof (long double _Imaginary) * CHAR_BIT,
			      16 * CHAR_BIT, -1,
			      LDIMAGINARY, LDIMAGINARY,
			      0, 0, 1, 1, 2, "long double _Imaginary" } },
#endif
		{ VOID,     { -1, -1, -1,
d145 1
a145 1
		{ STRUCT,   { -1, -1, -1,
d148 1
a148 1
		{ UNION,    { -1, -1, -1,
d151 1
a151 1
		{ ENUM,     { sizeof (int) * CHAR_BIT, 3 * CHAR_BIT, 40,
d154 1
a154 1
		{ PTR,      { sizeof (void *) * CHAR_BIT, 4 * CHAR_BIT, -1,
d157 1
a157 1
		{ ARRAY,    { -1, -1, -1,
d160 1
a160 1
		{ FUNC,     { -1, -1, -1,
d177 1
a177 1

a181 1
	typetab[BOOL].t_tspec = BOOL;
a195 6
	typetab[COMPLEX].t_tspec = COMPLEX;
	typetab[DCOMPLEX].t_tspec = DCOMPLEX;
	typetab[LDCOMPLEX].t_tspec = LDCOMPLEX;
	typetab[IMAGINARY].t_tspec = IMAGINARY;
	typetab[DIMAGINARY].t_tspec = DIMAGINARY;
	typetab[LDIMAGINARY].t_tspec = LDIMAGINARY;
d206 1
a206 1
 * Returns a shared type structure for arithmetic types and void.
d212 2
a213 1
gettyp(tspec_t t)
d219 2
a220 1
duptyp(const type_t *tp)
d234 2
a235 1
tduptyp(const type_t *tp)
d249 2
a250 1
incompl(type_t *tp)
d271 3
a273 1
setcompl(type_t *tp, int ic)
d294 2
a295 1
addscl(scl_t sc)
d331 2
a332 1
addtype(type_t *tp)
d338 1
a338 2
		    dcs->d_lmod != NOTSPEC || dcs->d_smod != NOTSPEC ||
		    dcs->d_dmod != NOTSPEC) {
d357 1
a357 2
		    dcs->d_lmod != NOTSPEC || dcs->d_smod != NOTSPEC ||
		    dcs->d_dmod != NOTSPEC) {
d363 1
a363 2
			dcs->d_atyp = dcs->d_smod = dcs->d_lmod =
			    dcs->d_dmod = NOTSPEC;
d384 1
a384 1
			(void)gnuism(265, "ANSI");
a411 9
	} else if (t == COMPLEX || t == IMAGINARY) {
		/*
		 * remember specifiers "_Complex" and "_Imaginary" in
		 * dcs->d_dmod
		 */
		if (dcs->d_dmod != NOTSPEC)
			/* more than one, print error in deftyp() */
			dcs->d_terr = 1;
		dcs->d_dmod = t;
d415 1
a415 1
		 * "double" int dcs->d_atyp
d429 3
a431 1
tdeferr(type_t *td, tspec_t t)
d442 3
a444 2
			/* modifying typedef with ... */
			warning(5, ttab[t].tt_name);
d461 1
a461 2
		    t2 == FLOAT || t2 == DOUBLE || t2 == COMPLEX ||
		    t2 == IMAGINARY) {
a475 8
			} else if (t2 == COMPLEX) {
				td = gettyp(DCOMPLEX);
			} else if (t2 == DCOMPLEX) {
				td = gettyp(LDCOMPLEX);
			} else if (t2 == IMAGINARY) {
				td = gettyp(DIMAGINARY);
			} else if (t2 == DIMAGINARY) {
				td = gettyp(LDIMAGINARY);
d501 3
a503 1
settdsym(type_t *tp, sym_t *sym)
d521 1
a521 1
 * The remembered qualifier is used by deftyp() to construct the type
d525 2
a526 1
addqual(tqual_t q)
d534 3
a536 1
	} else if (q == VOLATILE) {
d542 1
a542 8
	} else if (q == RESTRICT) {
		if (dcs->d_restrict) {
			/* duplicate "%s" */
			warning(10, "restrict");
		}
		dcs->d_restrict = 1;
	} else
		lerror("addqual() 1");
d550 2
a551 1
pushdecl(scl_t sc)
d570 1
a570 1
popdecl(void)
d655 1
a655 1
setasm(void)
d668 1
a668 1
clrtyp(void)
d670 1
a670 1
	dcs->d_atyp = dcs->d_smod = dcs->d_lmod = dcs->d_dmod = NOTSPEC;
a680 27
 * Merge the domain (_Complex or _Imaginary) into a type.  Returns non-zero
 * if the merge doesn't make sense.  e.g., no "int _Complex".
 */
int
mergedomain(tspec_t *tp, tspec_t domain)
{
	if (domain == NOTSPEC)
		return (0);
	if (domain != COMPLEX && domain != IMAGINARY)
		lerror("mergedomain()");
	switch (*tp) {
	case FLOAT:
		*tp = domain;
		break;
	case DOUBLE:
		*tp = domain == COMPLEX ? DCOMPLEX : DIMAGINARY;
		break;
	case LDOUBLE:
		*tp = domain == COMPLEX ? LDCOMPLEX : LDIMAGINARY;
		break;
	default:
		return (1);
	}
	return (0);
}

/*
d687 1
a687 1
deftyp(void)
d689 1
a689 1
	tspec_t	t, s, l, d;
d693 1
a693 2
	t = dcs->d_atyp;		/* BOOL, CHAR, INT, FLOAT,
					   DOUBLE, VOID */
a695 1
	d = dcs->d_dmod;		/* COMPLEX, IMAGINARY */
a711 2
		case BOOL:
			break;
d726 3
a728 2
				/* use 'double' instead of ...  */
				warning(6);
d735 3
a744 2
		if (mergedomain(&t, d))
			dcs->d_terr = 1;
d803 2
a804 1
mrgtspec(tspec_t t, tspec_t s)
d831 3
a833 1
length(type_t *tp, const char *name)
d838 1
a838 1
	while (tp && tp->t_tspec == ARRAY) {
a841 3
	if (tp == NULL)
		return (-1);

d871 1
a871 1
 * Get the alignment of the given type in bits.
d874 2
a875 1
getbound(type_t *tp)
d880 1
a880 1
	while (tp && tp->t_tspec == ARRAY)
a882 3
	if (tp == NULL)
		return (-1);

d906 2
a907 1
lnklst(sym_t *l1, sym_t *l2)
d929 2
a930 1
chktyp(sym_t *sym)
d960 1
a960 1
				if (sflag) {
d1007 1
a1007 1
			if (tp->t_const || tp->t_volatile || tp->t_restrict) {
a1010 1
				tp->t_restrict = 0;
d1022 2
a1023 1
decl1str(sym_t *dsym)
d1052 2
a1053 2
		 * only unsigned and signed int are portable bit-field types
		 * (at least in ANSI C, in traditional C only unsigned int)
a1063 6
			if (isutyp(t))
				tp->t_tspec = UINT;
			else
				tp->t_tspec = INT;

			tp->t_isenum = 0;
d1070 1
a1070 1
		    t != ULONG && t != QUAD && t != UQUAD && t != BOOL) {
d1141 2
a1142 1
align(int al, int len)
d1153 1
a1153 1

d1163 3
a1165 1
bitfield(sym_t *dsym, int len)
a1176 2
	dsym->s_type->t_proto = 0;
	dsym->s_type->t_isenum = 0;
d1189 2
a1190 1
mergepq(pqinf_t *p1, pqinf_t *p2)
d1223 1
a1223 1
 * The current type is the type built by deftyp() (dcs->d_type) and
d1228 3
a1230 1
addptr(sym_t *decl, pqinf_t *pi)
d1236 1
a1236 1
	while (*tpp && *tpp != dcs->d_type)
a1237 2
	if (*tpp == NULL)
		return (decl);
d1257 3
a1259 1
addarray(sym_t *decl, int dim, int n)
d1264 1
a1264 1
	while (*tpp && *tpp != dcs->d_type)
a1265 2
	if (*tpp == NULL)
	    return (decl);
d1288 2
a1289 1
addfunc(sym_t *decl, sym_t *args)
d1294 3
d1319 1
a1319 1
	while (*tpp && *tpp != dcs->d_nxt->d_type)
a1320 2
	if (*tpp == NULL)
	    return (decl);
d1337 2
a1338 1
nsfunc(sym_t *decl, sym_t *args)
d1376 2
a1377 1
osfunc(sym_t *decl, sym_t *args)
d1387 1
a1387 1
		 * we are wrong, its corrected in chkfdef().
d1406 3
a1408 1
chkfdef(sym_t *sym, int msg)
d1428 2
a1429 1
dname(sym_t *sym)
d1527 2
a1528 1
iname(sym_t *sym)
d1556 4
a1559 1
mktag(sym_t *tag, tspec_t kind, int decl, int semi)
d1581 1
a1581 1
				if (sflag || pflag)
d1614 1
a1614 1
		/* is incomplete type */
d1627 4
a1630 1
newtag(sym_t *tag, scl_t scl, int decl, int semi)
d1635 9
a1643 4
			if (!sflag)
				/* decl. introduces new type ... */
				warning(44, scltoa(scl), tag->s_name);
			tag = pushdown(tag);
d1682 2
a1683 1
scltoa(scl_t sc)
d1706 3
a1708 1
compltag(type_t *tp, sym_t *fmem)
d1725 2
a1726 4
			if (sflag) {
				/* zero sized %s */
				warning(47, ttab[t].tt_name);
			}
d1750 1
a1750 1
 * impl is 1 if the value of the enumerator was not explicitly specified.
d1753 3
a1755 1
ename(sym_t *sym, int val, int impl)
d1797 3
a1799 1
decl1ext(sym_t *dsym, int initflg)
a1827 6
	if (dsym->s_type->t_tspec == FUNC) {
		if (noretflg)
			dsym->s_noreturn = 1;
	}
	noretflg = 0;

d1832 1
a1832 1
		 * With both LINTLIBRARY and PROTOLIB the prototype is
d1842 1
d1855 1
d1901 1
a1901 1

d1918 2
a1919 1
cpuinfo(sym_t *sym, sym_t *rdsym)
d1933 3
a1935 1
isredec(sym_t *dsym, int *warn)
d1977 1
a1977 1
		 * All cases except "int a = 1; static int a;" are caught
d2014 3
a2016 1
eqtype(type_t *tp1, type_t *tp2, int ignqual, int promot, int *warn)
d2021 1
a2025 2
			} else if (t == BOOL) {
				t = INT;
d2029 1
a2029 1
				t = INT;
d2034 1
a2034 5
				t = INT_MAX < USHRT_MAX ? UINT : INT;
			} else if (t == COMPLEX) {
				t = DCOMPLEX;
			} else if (t == IMAGINARY) {
				t = DIMAGINARY;
d2041 1
a2041 4
		if (tp1->t_const != tp2->t_const && !ignqual)
			return (0);

		if (tp1->t_volatile != tp2->t_volatile && !ignqual)
d2044 1
a2044 1
		if (tp1->t_restrict != tp2->t_restrict && !ignqual)
d2056 1
a2056 1
		if (t == FUNC) {
d2082 3
a2084 1
eqargs(type_t *tp1, type_t *tp2, int *warn)
d2095 1
d2118 3
a2120 1
mnoarg(type_t *tp, int *warn)
d2130 1
a2130 1
		if ((t = arg->s_type->t_tspec) == FLOAT || t == BOOL ||
d2132 1
a2132 3
		    t == SHORT || t == USHORT || t == COMPLEX ||
		    t == DCOMPLEX || t == LDCOMPLEX || t == IMAGINARY ||
		    t == DIMAGINARY || t == LDIMAGINARY) {
d2145 2
a2146 1
chkosdef(sym_t *rdsym, sym_t *dsym)
d2197 1
a2197 1
 * Completes a type by copying the dimension and prototype information
d2207 2
a2208 1
compltyp(sym_t *dsym, sym_t *ssym)
d2223 1
a2223 1
				/* now a complete type */
d2242 3
a2244 1
decl1arg(sym_t *sym, int initflg)
d2274 3
d2278 3
d2304 1
a2304 1
 * Checks compatibility of old style function definition with previous
d2308 1
a2308 1
cluparg(void)
d2375 1
a2375 1
	 * print a warning for each argument of an old style function
d2388 1
a2388 1
	 * If this is an old style function definition and a prototype
d2422 1
a2422 1

d2433 2
a2434 1
chkptdecl(sym_t *arg, sym_t *parg)
d2467 3
a2469 1
decl1loc(sym_t *dsym, int initflg)
d2494 2
d2526 1
d2528 1
d2553 1
d2555 1
d2559 1
a2559 1
				 * a "redeclaration of %s" error
d2562 6
d2571 1
d2575 1
d2579 1
d2583 1
d2585 1
d2609 2
a2610 1
ledecl(sym_t *dsym)
d2660 2
a2661 2
 * Print an error or a warning if the symbol can't be initialized due
 * to type/storage class. Return value is 1 if an error has been
d2665 2
a2666 1
chkinit(sym_t *sym)
d2697 1
a2697 1
aname(void)
d2725 1
a2725 1
globclup(void)
d2735 1
a2735 1
	 * remove all information about pending lint directives without
d2745 2
a2746 1
decl1abs(sym_t *sym)
d2757 2
a2758 1
chksz(sym_t *dsym)
d2774 5
a2778 1
		error(190, dsym->s_name);
d2786 2
a2787 1
setsflg(sym_t *sym)
d2799 3
a2801 1
setuflg(sym_t *sym, int fcall, int szof)
d2823 2
a2824 1
chkusage(dinfo_t *di)
d2844 3
a2846 1
chkusg1(int novar, sym_t *sym)
d2871 3
a2873 1
chkausg(int novar, sym_t *arg)
d2889 3
a2891 1
chkvusg(int novar, sym_t *sym)
d2958 2
a2959 1
chklusg(sym_t *lab)
d2976 2
a2977 1
chktusg(sym_t *sym)
d2982 1
a2982 1
	/* complain always about incomplete tags declared inside blocks */
d3014 1
a3014 1
chkglsyms(void)
d3041 2
a3042 1
chkglvar(sym_t *sym)
d3046 1
a3046 1

d3079 1
a3079 1
		if (sym->s_def == TDEF && sym->s_type->t_const) {
d3088 2
a3089 1
glchksz(sym_t *sym)
d3094 1
a3094 1
			 * this can happen if a syntax error occurred
d3102 1
a3102 1
			if (sym->s_scl == EXTERN && !sflag) {
d3115 3
a3117 1
prevdecl(int msg, sym_t *psym)
@

