head	1.2;
access;
symbols
	MIRBSD_10:1.2.0.2
	MIRBSD_10_BASE:1.2
	cvs-200707101400:1.1.1.3
	MIRBSD_9_BASE:1.1.1.2
	MIRBSD_8:1.1.1.2.0.2
	MIRBSD_8_BASE:1.1.1.2
	cvs-200507211800:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2007.07.10.14.22.36;	author tg;	state Exp;
branches;
next	1.1;
commitid	100469396332E98CC03;

1.1
date	2005.02.05.17.29.29;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.29.29;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.07.21.20.59.10;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	560042e0092f571e;

1.1.1.3
date	2007.07.10.14.08.18;	author tg;	state Exp;
branches;
next	;
commitid	100469392DB1BA5159C;


desc
@@


1.2
log
@make __CRAZY clean – fixes a format string error, even…
eat this, OgreBSD ☻☺
@
text
@/* $OpenBSD: funcs.c,v 1.4 2007/07/09 16:39:48 dim Exp $ */
/*
 * Copyright (c) Christos Zoulas 2003.
 * All Rights Reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice immediately at the beginning of the file, without modification,
 *    this list of conditions, and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *  
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#include "file.h"
#include "magic.h"
#include <limits.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

__RCSID("$MirOS$");

/*
 * Like printf, only we print to a buffer and advance it.
 */
protected int
file_printf(struct magic_set *ms, const char *fmt, ...)
{
	va_list ap;
	int len;
	size_t size;
	char *buf;
	ptrdiff_t diff;

	va_start(ap, fmt);

	len = vsnprintf(ms->o.ptr, ms->o.left, fmt, ap);
	if (len == -1) {
		file_error(ms, errno, "vsnprintf failed");
		return -1;
	} else if ((size_t)len >= ms->o.left) {
		va_end(ap);
		size = (ms->o.size - ms->o.left) + len + 1024;
		if ((buf = realloc(ms->o.buf, size)) == NULL) {
			file_oomem(ms);
			return -1;
		}
		diff = ms->o.ptr - ms->o.buf;
		ms->o.ptr = buf + diff;
		ms->o.buf = buf;
		ms->o.left = size - diff;
		ms->o.size = size;

		va_start(ap, fmt);
		len = vsnprintf(ms->o.ptr, ms->o.left, fmt, ap);
		if (len == -1) {
			file_error(ms, errno, "vsnprintf failed");
			return -1;
		}
	}
	ms->o.ptr += len;
	ms->o.left -= len;
	va_end(ap);
	return 0;
}

/*
 * error - print best error message possible
 */
/*VARARGS*/
protected void
file_error(struct magic_set *ms, int error, const char *f, ...)
{
	va_list va;
	/* Only the first error is ok */
	if (ms->haderr)
		return;
	va_start(va, f);
	(void)vsnprintf(ms->o.buf, ms->o.size, f, va);
	va_end(va);
	if (error > 0) {
		size_t len = strlen(ms->o.buf);
		(void)snprintf(ms->o.buf + len, ms->o.size - len, " (%s)",
		    strerror(error));
	}
	ms->haderr++;
	ms->error = error;
}


protected void
file_oomem(struct magic_set *ms)
{
	file_error(ms, errno, "cannot allocate memory");
}

protected void
file_badseek(struct magic_set *ms)
{
	file_error(ms, errno, "error seeking");
}

protected void
file_badread(struct magic_set *ms)
{
	file_error(ms, errno, "error reading");
}

protected int
file_buffer(struct magic_set *ms, const void *buf, size_t nb)
{
    int m;
    /* try compression stuff */
    if ((m = file_zmagic(ms, buf, nb)) == 0) {
	/* Check if we have a tar file */
	if ((m = file_is_tar(ms, buf, nb)) == 0) {
	    /* try tests in /etc/magic (or surrogate magic file) */
	    if ((m = file_softmagic(ms, buf, nb)) == 0) {
		/* try known keywords, check whether it is ASCII */
		if ((m = file_ascmagic(ms, buf, nb)) == 0) {
		    /* abandon hope, all ye who remain here */
		    if (file_printf(ms, ms->flags & MAGIC_MIME ?
			"application/octet-stream" : "data") == -1)
			    return -1;
		    m = 1;
		}
	    }
	}
    }
    return m;
}

protected int
file_reset(struct magic_set *ms)
{
	if (ms->mlist == NULL) {
		file_error(ms, 0, "no magic files loaded");
		return -1;
	}
	ms->o.ptr = ms->o.buf;
	ms->haderr = 0;
	ms->error = -1;
	return 0;
}

protected const char *
file_getbuffer(struct magic_set *ms)
{
	char *pbuf, *op, *np;
	size_t psize, len;

	if (ms->haderr)
		return NULL;

	if (ms->flags & MAGIC_RAW)
		return ms->o.buf;

	len = ms->o.size - ms->o.left;
	if (len > (SIZE_T_MAX - 1) / 4) {
		file_oomem(ms);
		return NULL;
	}
	/* * 4 is for octal representation, + 1 is for NUL */
	psize = len * 4 + 1;
	if (ms->o.psize < psize) {
		if ((pbuf = realloc(ms->o.pbuf, psize)) == NULL) {
			file_oomem(ms);
			return NULL;
		}
		ms->o.psize = psize;
		ms->o.pbuf = pbuf;
	}

	for (np = ms->o.pbuf, op = ms->o.buf; *op; op++) {
		if (isprint((unsigned char)*op)) {
			*np++ = *op;	
		} else {
			*np++ = '\\';
			*np++ = ((*op >> 6) & 3) + '0';
			*np++ = ((*op >> 3) & 7) + '0';
			*np++ = ((*op >> 0) & 7) + '0';
		}
	}
	*np = '\0';
	return ms->o.pbuf;
}
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $OpenBSD: funcs.c,v 1.2 2004/05/19 02:36:26 tedu Exp $ */
d32 1
d34 1
d39 2
a40 3
#ifndef	lint
FILE_RCSID("@@(#)$Id: funcs.c,v 1.2 2004/05/19 02:36:26 tedu Exp $")
#endif	/* lint */
d48 2
a49 1
	size_t len;
d51 1
d55 5
a59 1
	if ((len = vsnprintf(ms->o.ptr, ms->o.len, fmt, ap)) >= ms->o.len) {
d61 2
a62 1
		if ((buf = realloc(ms->o.buf, len + 1024)) == NULL) {
d66 2
a67 1
		ms->o.ptr = buf + (ms->o.ptr - ms->o.buf);
d69 2
a70 2
		ms->o.len = ms->o.size - (ms->o.ptr - ms->o.buf);
		ms->o.size = len + 1024;
d73 5
a77 1
		len = vsnprintf(ms->o.ptr, ms->o.len, fmt, ap);
d80 1
a80 1
	ms->o.len -= len;
d167 2
a168 2
	char *nbuf, *op, *np;
	size_t nsize;
d176 9
a184 3
	nsize = ms->o.len * 4 + 1;
	if (ms->o.psize < nsize) {
		if ((nbuf = realloc(ms->o.pbuf, nsize)) == NULL) {
d188 2
a189 2
		ms->o.psize = nsize;
		ms->o.pbuf = nbuf;
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d1 1
a1 1
/* $OpenBSD: funcs.c,v 1.3 2005/04/11 16:31:35 deraadt Exp $ */
d38 1
a38 1
FILE_RCSID("@@(#)$Id: funcs.c,v 1.3 2005/04/11 16:31:35 deraadt Exp $")
d52 1
a52 2
	len = vsnprintf(ms->o.ptr, ms->o.len, fmt, ap);
	if (len == -1 || len >= ms->o.len) {
@


1.1.1.3
log
@I've been waiting for them to fix the security issues in file(1) for MONTHS
@
text
@d1 1
a1 1
/* $OpenBSD: funcs.c,v 1.4 2007/07/09 16:39:48 dim Exp $ */
a31 1
#include <limits.h>
a32 1
#include <stddef.h>
d38 1
a38 1
FILE_RCSID("@@(#)$Id: funcs.c,v 1.4 2007/07/09 16:39:48 dim Exp $")
d47 1
a47 2
	int len;
	size_t size;
a48 1
	ptrdiff_t diff;
d52 2
a53 5
	len = vsnprintf(ms->o.ptr, ms->o.left, fmt, ap);
	if (len == -1) {
		file_error(ms, errno, "vsnprintf failed");
		return -1;
	} else if (len >= ms->o.left) {
d55 1
a55 2
		size = (ms->o.size - ms->o.left) + len + 1024;
		if ((buf = realloc(ms->o.buf, size)) == NULL) {
d59 1
a59 2
		diff = ms->o.ptr - ms->o.buf;
		ms->o.ptr = buf + diff;
d61 2
a62 2
		ms->o.left = size - diff;
		ms->o.size = size;
d65 1
a65 5
		len = vsnprintf(ms->o.ptr, ms->o.left, fmt, ap);
		if (len == -1) {
			file_error(ms, errno, "vsnprintf failed");
			return -1;
		}
d68 1
a68 1
	ms->o.left -= len;
d155 2
a156 2
	char *pbuf, *op, *np;
	size_t psize, len;
d164 3
a166 9
	len = ms->o.size - ms->o.left;
	if (len > (SIZE_T_MAX - 1) / 4) {
		file_oomem(ms);
		return NULL;
	}
	/* * 4 is for octal representation, + 1 is for NUL */
	psize = len * 4 + 1;
	if (ms->o.psize < psize) {
		if ((pbuf = realloc(ms->o.pbuf, psize)) == NULL) {
d170 2
a171 2
		ms->o.psize = psize;
		ms->o.pbuf = pbuf;
@


