head	1.9;
access;
symbols
	MIRBSD_10:1.9.0.2
	MIRBSD_10_BASE:1.9
	cvs-200702180200:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2007.07.07.22.02.41;	author tg;	state Exp;
branches;
next	1.8;
commitid	10046900D300D91247A;

1.8
date	2007.05.24.09.56.49;	author tg;	state Exp;
branches;
next	1.7;
commitid	100465561735F871594;

1.7
date	2007.02.18.12.54.04;	author tg;	state Exp;
branches;
next	1.6;
commitid	10045D84C731E54DB11;

1.6
date	2007.02.18.03.43.07;	author tg;	state Exp;
branches;
next	1.5;
commitid	10045D7CB465B5183BD;

1.5
date	2007.02.18.02.45.47;	author tg;	state Exp;
branches;
next	1.4;
commitid	10045D7BDE62E30F906;

1.4
date	2007.02.18.02.44.29;	author tg;	state Exp;
branches;
next	1.3;
commitid	10045D7BD9811B00138;

1.3
date	2007.02.18.02.41.16;	author tg;	state Exp;
branches;
next	1.2;
commitid	10045D7BCD54C97B5BC;

1.2
date	2007.02.18.02.39.14;	author tg;	state Exp;
branches;
next	1.1;
commitid	10045D7BC5F75BCEEA1;

1.1
date	2007.02.18.02.08.18;	author tg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	10045D7B51C40EF1094;

1.1.1.1
date	2007.02.18.02.08.18;	author tg;	state Exp;
branches;
next	;
commitid	10045D7B51C40EF1094;


desc
@@


1.9
log
@crunchgen:
• make stubbed object files obsolete, use GNU objcopy(1)’s symbol renaming
  feature instead
• rewrite to use BSD make and <bsd.prog.mk>, finally
• shrink the size of the generated makefile by a lot
• document that ‘-E’ flag has been obsolete since version 1.x
• bump to version 2.0

users of crunchgen:
• change clean removal of *.lo to *.lo* to account for more temp files
@
text
@/* $OpenBSD: crunchgen.c,v 1.28 2006/12/26 10:20:11 deraadt Exp $	 */

/*-
 * Copyright (c) 2007
 *	Thorsten Glaser <tg@@mirbsd.de>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 */

/*-
 * Copyright (c) 1994 University of Maryland
 * All Rights Reserved.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of U.M. not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  U.M. makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * U.M. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL U.M.
 * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Author: James da Silva, Systems Design and Analysis Group
 *			   Computer Science Department
 *			   University of Maryland at College Park
 */

/*-
 * Generates a Makefile and main C file for a crunched executable,
 * from specs given in a .conf file.
 */

#include <sys/param.h>
#include <sys/stat.h>

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

__RCSID("$MirOS: src/usr.bin/crunchgen/crunchgen.c,v 1.8 2007/05/24 09:56:49 tg Exp $");

#define CRUNCH_VERSION	"2.0-MirOS"

#define MAXLINELEN	16384
#define MAXFIELDS 	 2048

/* XXX - This should be runtime configurable */
/*
 * We might have more than one makefile
 * name on any given platform. Make sure
 * default name is last though.
 */
const char *mf_name[] = {
#if defined(MF_NAMES)
	MF_NAMES,
#else
	"Makefile",
#endif
	NULL
};

/* internal representation of conf file: */

/* simple lists of strings suffice for most parms */

typedef struct strlst {
	struct strlst *next;
	char *str;
} strlst_t;

/* progs have structure, each field can be set with "special" or calculated */

typedef struct prog {
	struct prog *next;
	char *name;
	char *ident;
	const char *mf_name;
	char *srcdir;
	char *objdir;
	strlst_t *objs;
	strlst_t *objpaths;
	strlst_t *links;
	int goterror;
} prog_t;

strlst_t *srcdirs = NULL;
strlst_t *libs = NULL;
strlst_t *libdirs = NULL;
char objdir[MAXPATHLEN] = "obj";
prog_t *progs = NULL;

char line[MAXLINELEN];

char confname[MAXPATHLEN], infilename[MAXPATHLEN];
char outmkname[MAXPATHLEN], outcfname[MAXPATHLEN];
char cachename[MAXPATHLEN], curfilename[MAXPATHLEN];
char topdir[MAXPATHLEN], execfname[MAXPATHLEN];
int linenum = -1;
int goterror = 0;

const char *progname = "crunchgen";

int verbose, readcache;
int reading_cache;

static void status(const char *);
static void out_of_memory(void) __dead;
static void add_string(strlst_t **, const char *);
static int is_dir(const char *);
static int is_nonempty_file(const char *);
static void usage(void) __dead;
static void parse_conf_file(void);
static void gen_outputs(void);

static void parse_one_file(char *);
static void parse_line(char *, int *, char **, int);
static void add_srcdirs(int argc, char **argv);
static void add_progs(int argc, char **argv);
static void add_link(int argc, char **argv);
static void add_libs(int argc, char **argv);
static void add_libdirs(int argc, char **argv);
static void add_special(int argc, char **argv);

static prog_t *find_prog(char *);
static void add_prog(char *);

static void remove_error_progs(void);
static void fillin_program(prog_t * p);
static void gen_specials_cache(void);
static void gen_output_makefile(void);
static void gen_output_cfile(void);

static void fillin_program_objs(prog_t * p, char *path);
static void top_makefile_rules(FILE * outmk);
static void prog_makefile_rules(FILE * outmk, prog_t * p);
static void output_strlst(FILE * outf, strlst_t * lst);
static char *genident(char *str);
static char *dir_search(char *name);

int
main(int argc, char *argv[])
{
	char *p;
	int optc;

	verbose = 1;
	readcache = 1;
	*outmkname = *outcfname = *execfname = '\0';

	if (argc > 0)
		progname = argv[0];

	while ((optc = getopt(argc, argv, "m:c:e:fqD:EL:O:")) != -1) {
		switch (optc) {
		case 'f':
			readcache = 0;
			break;
		case 'q':
			verbose = 0;
			break;

		case 'm':
			if (strlcpy(outmkname, optarg, sizeof(outmkname)) >=
			    sizeof(outmkname))
				usage();
			break;
		case 'c':
			if (strlcpy(outcfname, optarg, sizeof(outcfname)) >=
			    sizeof(outcfname))
				usage();
			break;
		case 'e':
			if (strlcpy(execfname, optarg, sizeof(execfname)) >=
			    sizeof(execfname))
				usage();
			break;

		case 'D':
			if (strlcpy(topdir, optarg, sizeof(topdir)) >= sizeof(topdir))
				usage();
			break;
		case 'E':
			break;
		case 'L':
			if (strlen(optarg) >= MAXPATHLEN)
				usage();
			add_string(&libdirs, optarg);
			break;
		case 'O':
			if (strlcpy(objdir, optarg, sizeof(objdir)) >=
			    sizeof(objdir))
				usage();
			break;
		default:
			usage();
		}
	}

	argc -= optind;
	argv += optind;

	if (argc != 1)
		usage();

	if (libdirs == NULL)
		add_string(&libdirs, "/usr/lib");
	/*
	 * generate filenames
	 */

	if (strlcpy(infilename, argv[0], sizeof(infilename)) >=
	    sizeof(infilename))
		usage();

	/* confname = $(basename infilename .conf) */

	if ((p = strrchr(infilename, '/')) != NULL)
		strlcpy(confname, p + 1, sizeof confname);
	else
		strlcpy(confname, infilename, sizeof confname);
	if ((p = strrchr(confname, '.')) != NULL && !strcmp(p, ".conf"))
		*p = '\0';

	if (!*outmkname)
		snprintf(outmkname, sizeof(outmkname), "%s.mk", confname);
	if (!*outcfname)
		snprintf(outcfname, sizeof(outcfname), "%s.c", confname);
	if (!*execfname)
		snprintf(execfname, sizeof(execfname), "%s", confname);
	snprintf(cachename, sizeof(cachename), "%s.cache", confname);

	parse_conf_file();
	gen_outputs();

	exit(goterror);
}

static void
usage(void)
{
	fprintf(stderr,
	    "usage: %s [-Efq] [-c c-file-name] [-D src-root] [-e exec-file-name]\n"
	    "\t[-L lib-dir] [-m makefile-name] [-O objdir-name] conf-file\n",
	    progname);
	exit(1);
}

void
parse_conf_file(void)
{
	if (!is_nonempty_file(infilename)) {
		fprintf(stderr, "%s: fatal: input file \"%s\" not found.\n",
		    progname, infilename);
		exit(1);
	}
	parse_one_file(infilename);
	if (readcache && is_nonempty_file(cachename)) {
		reading_cache = 1;
		parse_one_file(cachename);
	}
}

void
parse_one_file(char *filename)
{
	char *fieldv[MAXFIELDS];
	int fieldc;
	void (*f) (int c, char **v);
	FILE *cf;

	snprintf(line, sizeof(line), "reading %s", filename);
	status(line);
	strlcpy(curfilename, filename, sizeof curfilename);

	if ((cf = fopen(curfilename, "r")) == NULL) {
		perror(curfilename);
		goterror = 1;
		return;
	}
	linenum = 0;
	while (fgets(line, MAXLINELEN, cf) != NULL) {
		linenum++;
		parse_line(line, &fieldc, fieldv, MAXFIELDS);
		if (fieldc < 1)
			continue;
		if (!strcmp(fieldv[0], "srcdirs"))
			f = add_srcdirs;
		else if (!strcmp(fieldv[0], "progs"))
			f = add_progs;
		else if (!strcmp(fieldv[0], "ln"))
			f = add_link;
		else if (!strcmp(fieldv[0], "libs"))
			f = add_libs;
		else if (!strcmp(fieldv[0], "special"))
			f = add_special;
		else if (!strcmp(fieldv[0], "libdirs"))
			f = add_libdirs;
		else {
			fprintf(stderr, "%s:%d: skipping unknown command '%s'.\n",
			    curfilename, linenum, fieldv[0]);
			goterror = 1;
			continue;
		}
		if (fieldc < 2) {
			fprintf(stderr,
			    "%s:%d: %s command needs at least 1 "
			    "argument, skipping.\n",
			    curfilename, linenum, fieldv[0]);
			goterror = 1;
			continue;
		}
		f(fieldc, fieldv);
	}

	if (ferror(cf)) {
		perror(curfilename);
		goterror = 1;
	}
	fclose(cf);
}

void
parse_line(char *p, int *fc, char **fv, int nf)
{
	*fc = 0;
	while (1) {
		while (isspace(*p))
			p++;
		if (*p == '\0' || *p == '#')
			break;

		if (*fc < nf)
			fv[(*fc)++] = p;
		while (*p && !isspace(*p) && *p != '#')
			p++;
		if (*p == '\0' || *p == '#')
			break;
		*p++ = '\0';
	}
	if (*p)
		*p = '\0';	/* needed for '#' case */
}

void
add_srcdirs(int argc, char **argv)
{
	int i;
	char tmppath[MAXPATHLEN];
	int overflow;

	for (i = 1; i < argc; i++) {
		overflow = 0;
		if (argv[i][0] == '/' || topdir[0] == '\0') {
			if (strlcpy(tmppath, argv[i], sizeof(tmppath)) >=
			    sizeof(tmppath))
				overflow = 1;
		} else {
			if (strlcpy(tmppath, topdir, sizeof(tmppath)) >=
			    sizeof(tmppath) ||
			    strlcat(tmppath, "/", sizeof(tmppath)) >=
			    sizeof(tmppath) ||
			    strlcat(tmppath, argv[i], sizeof(tmppath)) >=
			    sizeof(tmppath))
				overflow = 1;
		}
		if (overflow) {
			goterror = 1;
			fprintf(stderr, "%s:%d: '%.40s...' is too long, skipping it.\n",
			    curfilename, linenum, argv[i]);
			continue;
		}
		if (is_dir(tmppath))
			add_string(&srcdirs, tmppath);
		else {
			fprintf(stderr, "%s:%d: '%s' is not a directory, skipping it.\n",
			    curfilename, linenum, tmppath);
			goterror = 1;
		}
	}
}

void
add_libdirs(int argc, char **argv)
{
	int i;
	char tmppath[MAXPATHLEN];
	char tmppath2[MAXPATHLEN];
	int overflow;

	for (i = 1; i < argc; i++) {
		overflow = 0;
		if (argv[i][0] == '/' || topdir[0] == '\0') {
			if (strlcpy(tmppath, argv[i], sizeof(tmppath)) >=
			    sizeof(tmppath))
				overflow = 1;
		} else {
			if (strlcpy(tmppath, topdir, sizeof(tmppath)) >=
			    sizeof(tmppath) ||
			    strlcat(tmppath, "/", sizeof(tmppath)) >=
			    sizeof(tmppath) ||
			    strlcat(tmppath, argv[i], sizeof(tmppath)) >=
			    sizeof(tmppath))
				overflow = 1;
		}
		if (overflow) {
			goterror = 1;
			fprintf(stderr, "%s:%d: '%.40s...' is too long, skipping it.\n",
			    curfilename, linenum, argv[i]);
			continue;
		}
		if (is_dir(tmppath)) {
			snprintf(tmppath2, sizeof(tmppath2), "%s/%s", tmppath,
			    objdir);
			if (is_dir(tmppath2))
				add_string(&libdirs, tmppath2);
			else {
				snprintf(tmppath2, sizeof(tmppath2),
				    "%s/obj.%s", tmppath, MACHINE);
				if (is_dir(tmppath2))
					add_string(&libdirs, tmppath2);
				else
					add_string(&libdirs, tmppath);
			}
		}
		else {
			fprintf(stderr, "%s:%d: '%s' is not a directory, skipping it.\n",
			    curfilename, linenum, tmppath);
			goterror = 1;
		}
	}
}


void
add_progs(int argc, char **argv)
{
	int i;

	for (i = 1; i < argc; i++)
		add_prog(argv[i]);
}

void
add_prog(char *name)
{
	prog_t *p1, *p2;

	/* add to end, but be smart about dups */

	for (p1 = NULL, p2 = progs; p2 != NULL; p1 = p2, p2 = p2->next)
		if (!strcmp(p2->name, name))
			return;

	p2 = calloc(1, sizeof(prog_t));
	if (p2)
		p2->name = strdup(name);
	if (!p2 || !p2->name)
		out_of_memory();

	p2->next = NULL;
	if (p1 == NULL)
		progs = p2;
	else
		p1->next = p2;

	p2->ident = p2->srcdir = p2->objdir = NULL;
	p2->links = p2->objs = NULL;
	p2->goterror = 0;
}

void
add_link(int argc, char **argv)
{
	int i;
	prog_t *p = find_prog(argv[1]);

	if (p == NULL) {
		fprintf(stderr,
		    "%s:%d: no prog %s previously declared, skipping link.\n",
		    curfilename, linenum, argv[1]);
		goterror = 1;
		return;
	}
	for (i = 2; i < argc; i++)
		add_string(&p->links, argv[i]);
}

void
add_libs(int argc, char **argv)
{
	int i;

	for (i = 1; i < argc; i++)
		add_string(&libs, argv[i]);
}

void
add_special(int argc, char **argv)
{
	int i;
	prog_t *p = find_prog(argv[1]);

	if (p == NULL) {
		if (reading_cache)
			return;
		fprintf(stderr,
		    "%s:%d: no prog %s previously declared, skipping special.\n",
		    curfilename, linenum, argv[1]);
		goterror = 1;
		return;
	}
	if (!strcmp(argv[2], "ident")) {
		if (argc != 4)
			goto argcount;
		if ((p->ident = strdup(argv[3])) == NULL)
			out_of_memory();
	} else if (!strcmp(argv[2], "srcdir")) {
		if (argc != 4)
			goto argcount;
		p->srcdir = NULL;
		if (argv[3][0] != '/' && topdir[0] != '\0') {
			if (asprintf(&(p->srcdir), "%s/%s",
			    topdir, argv[3]) == -1)
				p->srcdir = NULL;
			else if (!is_dir(p->srcdir))
				p->srcdir = NULL;
		}
		if ((p->srcdir == NULL) &&
		    ((p->srcdir = strdup(argv[3])) == NULL))
			out_of_memory();
	} else if (!strcmp(argv[2], "mf_name")) {
		if (argc != 4)
			goto argcount;
		if ((p->mf_name = strdup(argv[3])) == NULL)
			out_of_memory();
	} else if (!strcmp(argv[2], "objdir")) {
		if (argc != 4)
			goto argcount;
		if ((p->objdir = strdup(argv[3])) == NULL)
			out_of_memory();
	} else if (!strcmp(argv[2], "objs")) {
		p->objs = NULL;
		for (i = 3; i < argc; i++)
			add_string(&p->objs, argv[i]);
	} else if (!strcmp(argv[2], "objpaths")) {
		p->objpaths = NULL;
		for (i = 3; i < argc; i++)
			add_string(&p->objpaths, argv[i]);
	} else {
		fprintf(stderr, "%s:%d: bad parameter name '%s', skipping line.\n",
		    curfilename, linenum, argv[2]);
		goterror = 1;
	}
	return;

 argcount:
	fprintf(stderr,
	    "%s:%d: too %s arguments, expected \"special %s %s <string>\".\n",
	    curfilename, linenum, argc < 4 ? "few" : "many", argv[1], argv[2]);
	goterror = 1;
}

prog_t *
find_prog(char *str)
{
	prog_t *p;

	for (p = progs; p != NULL; p = p->next)
		if (!strcmp(p->name, str))
			return p;
	return NULL;
}

void
gen_outputs(void)
{
	prog_t *p;

	for (p = progs; p != NULL; p = p->next)
		fillin_program(p);

	remove_error_progs();
	gen_specials_cache();
	gen_output_cfile();
	gen_output_makefile();
	status("");
	fprintf(stderr,
	    "Run \"make -f %s objs exe\" to build crunched binary.\n",
	    outmkname);
}

void
fillin_program(prog_t * p)
{
	char path[MAXPATHLEN];
	char *srcparent;
	strlst_t *s;
	int i;

	snprintf(line, sizeof(line), "filling in parms for %s", p->name);
	status(line);

	if (!p->ident)
		p->ident = genident(p->name);
	if (!p->srcdir) {
		srcparent = dir_search(p->name);
		if (srcparent)
			snprintf(path, sizeof(path), "%s/%s", srcparent, p->name);
		if (is_dir(path))
			p->srcdir = strdup(path);
	}
	if (!p->objdir && p->srcdir) {
		snprintf(path, sizeof(path), "%s/%s", p->srcdir, objdir);
		if (is_dir(path))
			p->objdir = strdup(path);
		else {
			snprintf(path, sizeof(path), "%s/obj.%s", p->srcdir, MACHINE);
			if (is_dir(path))
				p->objdir = strdup(path);
			else
				p->objdir = p->srcdir;
		}
	}
	/* We have a sourcedir and no explicit objs, try */
	/* to find makefile and get objs from it. */
	if (p->srcdir && !p->objs) {
		for (i = 0; mf_name[i] != NULL; i++) {
			snprintf(path, sizeof(path), "%s/%s", p->srcdir, mf_name[i]);
			if (is_nonempty_file(path)) {
				p->mf_name = mf_name[i];
				fillin_program_objs(p, path);
				break;
			}
		}
	}
	if (!p->objpaths && p->objdir && p->objs)
		for (s = p->objs; s != NULL; s = s->next) {
			snprintf(line, sizeof(line), "%s/%s", p->objdir, s->str);
			add_string(&p->objpaths, line);
		}

	if (!p->srcdir && verbose)
		fprintf(stderr, "%s: %s: warning: could not find source directory.\n",
		    infilename, p->name);
	if (!p->objs && verbose)
		fprintf(stderr, "%s: %s: warning: could not find any .o files.\n",
		    infilename, p->name);

	if (!p->objpaths) {
		fprintf(stderr,
		    "%s: %s: error: no objpaths specified or calculated.\n",
		    infilename, p->name);
		p->goterror = goterror = 1;
	}
}

void
fillin_program_objs(prog_t * p, char *path)
{
	char *cp, *obj, tempfname[MAXPATHLEN];
	int fd, rc;
	FILE *f;

	/* discover the objs from the srcdir Makefile */

	snprintf(tempfname, sizeof(tempfname), ".tmp_%sXXXXXXXXXX", confname);
	if ((fd = mkstemp(tempfname)) == -1 || (f = fdopen(fd, "w")) == NULL) {
		if (fd != -1)
			close(fd);
		perror(tempfname);
		goterror = 1;
		return;
	}
	fprintf(f, ".include \"%s\"\n", path);
	fprintf(f, ".if defined(PROG) && !defined(OBJS)\n");
	fprintf(f, "OBJS=${PROG}.o\n");
	fprintf(f, ".endif\n");
	fprintf(f, "crunchgen_objs:\n\t@@echo 'OBJS= '${OBJS}\n");
	fclose(f);

	snprintf(line, sizeof(line), "make -f %s crunchgen_objs 2>&1", tempfname);
	if ((f = popen(line, "r")) == NULL) {
		perror("submake pipe");
		goterror = 1;
		return;
	}
	while (fgets(line, MAXLINELEN, f)) {
		if (strncmp(line, "OBJS= ", 6)) {
			if (strcmp(line,
			    "sh: warning: running as root with dot in PATH\n") == 0)
				continue;
			fprintf(stderr, "make error: %s", line);
			goterror = 1;
			continue;
		}
		cp = line + 6;
		while (isspace(*cp))
			cp++;
		while (*cp) {
			obj = cp;
			while (*cp && !isspace(*cp))
				cp++;
			if (*cp)
				*cp++ = '\0';
			add_string(&p->objs, obj);
			while (isspace(*cp))
				cp++;
		}
	}
	if ((rc = pclose(f)) != 0) {
		fprintf(stderr, "make error: make returned %d\n", rc);
		goterror = 1;
	}
	unlink(tempfname);
}

void
remove_error_progs(void)
{
	prog_t *p1, *p2;

	p1 = NULL;
	p2 = progs;
	while (p2 != NULL) {
		if (!p2->goterror)
			p1 = p2, p2 = p2->next;
		else {
			/* delete it from linked list */
			fprintf(stderr, "%s: %s: ignoring program because of errors.\n",
			    infilename, p2->name);
			if (p1)
				p1->next = p2->next;
			else
				progs = p2->next;
			p2 = p2->next;
		}
	}
}

void
gen_specials_cache(void)
{
	FILE *cachef;
	prog_t *p;

	snprintf(line, sizeof(line), "generating %s", cachename);
	status(line);

	if ((cachef = fopen(cachename, "w")) == NULL) {
		perror(cachename);
		goterror = 1;
		return;
	}
	fprintf(cachef, "# %s - parm cache generated from %s by crunchgen %s\n\n",
	    cachename, infilename, CRUNCH_VERSION);

	for (p = progs; p != NULL; p = p->next) {
		fprintf(cachef, "\n");
		if (p->srcdir)
			fprintf(cachef, "special %s srcdir %s\n", p->name, p->srcdir);
		if (p->mf_name)
			fprintf(cachef, "special %s mf_name %s\n", p->name, p->mf_name);
		if (p->objdir)
			fprintf(cachef, "special %s objdir %s\n", p->name, p->objdir);
		if (p->objs) {
			fprintf(cachef, "special %s objs", p->name);
			output_strlst(cachef, p->objs);
		}
		fprintf(cachef, "special %s objpaths", p->name);
		output_strlst(cachef, p->objpaths);
	}
	fclose(cachef);
}

void
gen_output_makefile(void)
{
	prog_t *p;
	FILE *outmk;

	snprintf(line, sizeof(line), "generating %s", outmkname);
	status(line);

	if ((outmk = fopen(outmkname, "w")) == NULL) {
		perror(outmkname);
		goterror = 1;
		return;
	}
	fprintf(outmk, "# %s - generated from %s by crunchgen %s\n\n",
	    outmkname, infilename, CRUNCH_VERSION);

	top_makefile_rules(outmk);

	for (p = progs; p != NULL; p = p->next)
		prog_makefile_rules(outmk, p);

	fprintf(outmk, "\n# ========\n\n.include <bsd.prog.mk>\n");
	fclose(outmk);
}

void
gen_output_cfile(void)
{
	extern const char crunched_skel[];
	FILE *outcf;
	prog_t *p;
	strlst_t *s;
	size_t nums = 2;

	snprintf(line, sizeof(line), "generating %s", outcfname);
	status(line);

	if ((outcf = fopen(outcfname, "w")) == NULL) {
		perror(outcfname);
		goterror = 1;
		return;
	}
	fprintf(outcf, "/* %s - generated from %s by crunchgen %s */\n",
	    outcfname, infilename, CRUNCH_VERSION);

	for (p = progs; p != NULL; p = p->next) {
		++nums;
		for (s = p->links; s != NULL; s = s->next)
			++nums;
	}
	fprintf(outcf, "#define EXECNAME \"%s\"\n", execfname);
	fprintf(outcf, "#define NUMS %zu\n", nums);
	fputs(crunched_skel, outcf);

	for (p = progs; p != NULL; p = p->next)
		fprintf(outcf, "extern int _crunched_%s_main(int, char **,"
		    " char **);\n", p->ident);

	fprintf(outcf, "\nstatic const struct stub entry_points[NUMS] = {\n");
	for (p = progs; p != NULL; p = p->next) {
		fprintf(outcf, "\t{ \"%s\", _crunched_%s_main },\n",
			p->name, p->ident);
		for (s = p->links; s != NULL; s = s->next)
			fprintf(outcf, "\t{ \"%s\", _crunched_%s_main },\n",
				s->str, p->ident);
	}

	fprintf(outcf, "\t{ EXECNAME, crunched_main },\n");
	fprintf(outcf, "\t{ NULL, NULL }\n};\n");
	fclose(outcf);
}

char *
genident(char *str)
{
	char *n, *s, *d;

	/*
	 * generates a Makefile/C identifier from a program name, mapping '-' to
	 * '_' and ignoring all other non-identifier characters.  This leads to
	 * programs named "foo.bar" and "foobar" to map to the same identifier.
	 */

	if ((n = strdup(str)) == NULL)
		return NULL;
	for (d = s = n; *s != '\0'; s++) {
		if (*s == '-')
			*d++ = '_';
		else if (*s == '_' || isalnum(*s))
			*d++ = *s;
	}
	*d = '\0';
	return n;
}

char *
dir_search(char *name)
{
	char path[MAXPATHLEN];
	strlst_t *dir;

	for (dir = srcdirs; dir != NULL; dir = dir->next) {
		snprintf(path, sizeof(path), "%s/%s", dir->str, name);
		if (is_dir(path))
			return dir->str;
	}
	return NULL;
}

void
top_makefile_rules(FILE *outmk)
{
	prog_t *p;
	strlst_t *l;

	fprintf(outmk,
	    ".include <bsd.own.mk>\n\n"
	    "LINK.rlo=	${LD} -dc -r\n"
	    "PROG=		%s\n"
	    "NOMAN=		Yes\n"
	    "SUBTARGETS=	",
	    execfname);
	for (p = progs; p != NULL; p = p->next)
		fprintf(outmk, "%s%s", p == progs ? "" : " ", p->ident);
	fprintf(outmk, "\nLDSTATIC?=\t-static\nLDADD+=\t\t");
	for (l = libdirs; l != NULL; l = l->next)
		fprintf(outmk, "%s-L%s", l == libdirs ? "" : " ", l->str);
	output_strlst(outmk, libs);

	fprintf(outmk, "\n"
	    ".for _i in ${SUBTARGETS}\n"
	    "OBJS+=		${_i}.lo\n"
	    "CLEANFILES+=	${_i}.lo*\n\n"
	    "objs: ${_i}_make\n\n"
	    "${_i}.lo: ${_i}_make\n"
	    "	rm -f $@@*\n"
	    "	${LINK.rlo} -o $@@~ ${${_i}_OBJPATHS}\n"
	    "	objcopy --redefine-sym main=_crunched_${_i}_main \\\n"
	    "	    --keep-global-symbol=_crunched_${_i}_main $@@~ $@@\n"
	    ".endfor\n");
}

void
prog_makefile_rules(FILE * outmk, prog_t * p)
{
	fprintf(outmk, "\n# -------- %s\n\n", p->name);

	if (p->srcdir && p->objs) {
		fprintf(outmk, "%s_SRCDIR=\t %s\n", p->ident, p->srcdir);
		fprintf(outmk, "%s_OBJS=\t", p->ident);
		output_strlst(outmk, p->objs);
		fprintf(outmk, "\n%s_make:\n", p->ident);
		fprintf(outmk, "\tcd ${%s_SRCDIR} && exec ${MAKE} -f %s ${%s_OBJS}\n\n",
		    p->ident, p->mf_name, p->ident);
	} else
		fprintf(outmk, "%s_make:\n\t@@echo \"*** cannot make objs for %s\"\n\n",
		    p->ident, p->name);

	fprintf(outmk, "%s_OBJPATHS=\t", p->ident);
	output_strlst(outmk, p->objpaths);
}

void
output_strlst(FILE * outf, strlst_t * lst)
{
	for (; lst != NULL; lst = lst->next)
		fprintf(outf, " %s", lst->str);
	fprintf(outf, "\n");
}

void
status(const char *str)
{
	static int lastlen = 0;
	int len, spaces;

	if (!verbose)
		return;

	len = strlen(str);
	spaces = lastlen - len;
	if (spaces < 1)
		spaces = 1;

	fprintf(stderr, " [%s]%*.*s\r", str, spaces, spaces, " ");
	fflush(stderr);
	lastlen = len;
}

void
out_of_memory(void)
{
	fprintf(stderr, "%s: %d: out of memory, stopping.\n", infilename,
	    linenum);
	exit(1);
}

void
add_string(strlst_t **listp, const char *str)
{
	strlst_t *p1, *p2;

	/* add to end, but be smart about dups */

	for (p1 = NULL, p2 = *listp; p2 != NULL; p1 = p2, p2 = p2->next)
		if (!strcmp(p2->str, str))
			return;

	p2 = calloc(1, sizeof(strlst_t));
	if (p2)
		p2->str = strdup(str);
	if (!p2 || !p2->str)
		out_of_memory();

	p2->next = NULL;
	if (p1 == NULL)
		*listp = p2;
	else
		p1->next = p2;
}

int
is_dir(const char *pathname)
{
	struct stat buf;

	if (stat(pathname, &buf) == -1)
		return 0;
	return S_ISDIR(buf.st_mode);
}

int
is_nonempty_file(const char *pathname)
{
	struct stat buf;

	if (stat(pathname, &buf) == -1)
		return 0;

	return S_ISREG(buf.st_mode) && buf.st_size > 0;
}
@


1.8
log
@do LDFLAGS
@
text
@d3 21
a23 2
/*
 * Copyright (c) 2007 Thorsten Glaser <tg@@mirbsd.de>
d49 1
a49 4
/*
 * ========================================================================
 * crunchgen.c
 *
d63 1
a63 1
__RCSID("$MirOS: src/usr.bin/crunchgen/crunchgen.c,v 1.7 2007/02/18 12:54:04 tg Exp $");
d65 1
a65 1
#define CRUNCH_VERSION	"1.3-MirOS"
d126 1
a126 1
int verbose, readcache, elf_names;	/* options */
a205 1
			elf_names = 1;
d820 1
a820 2
	fprintf(outmk, "\n# ========\n");
	fprintf(outmk, ".include <bsd.prog.mk>\n");
d854 1
a854 1
		fprintf(outcf, "extern int _crunched_%s_stub(int, char **,"
d859 1
a859 1
		fprintf(outcf, "\t{ \"%s\", _crunched_%s_stub },\n",
d862 1
a862 1
			fprintf(outcf, "\t{ \"%s\", _crunched_%s_stub },\n",
d909 1
a909 1
top_makefile_rules(FILE * outmk)
d914 10
a923 3
	fprintf(outmk, "\n.include <bsd.own.mk>\n");
	fprintf(outmk, "LINK.rlo=\t$(LD) -dc -r\n");
	fprintf(outmk, "LIBS=");
d925 1
a925 1
		fprintf(outmk, " -L%s", l->str);
d928 11
a938 19
	fprintf(outmk, "CRUNCHED_OBJS=");
	for (p = progs; p != NULL; p = p->next)
		fprintf(outmk, " %s.lo", p->name);
	fprintf(outmk, "\n");

	fprintf(outmk, "SUBMAKE_TARGETS=");
	for (p = progs; p != NULL; p = p->next)
		fprintf(outmk, " %s_make", p->ident);
	fprintf(outmk, "\n\n");

	fprintf(outmk, "%s: %s.o $(CRUNCHED_OBJS)\n",
	    execfname, execfname);
	fprintf(outmk, "\t$(CC) -static $(LDFLAGS) -o $@@ %s.o $(CRUNCHED_OBJS)"
	    " -Wl,--start-group $(LIBS) -Wl,--end-group\n", execfname);
	fprintf(outmk, "all: objs exe\nobjs: $(SUBMAKE_TARGETS)\n");
	fprintf(outmk, "exe: %s\n", execfname);
	fprintf(outmk, "clean:\n\trm -f %s *.lo *.o *_stub.c\n",
	    execfname);
	fprintf(outmk, ".PHONY: all objs exe clean $(SUBMAKE_TARGETS)\n\n");
d947 2
a948 2
		fprintf(outmk, "%s_SRCDIR=%s\n", p->ident, p->srcdir);
		fprintf(outmk, "%s_OBJS=", p->ident);
d950 2
a951 2
		fprintf(outmk, "%s_make:\n", p->ident);
		fprintf(outmk, "\tcd $(%s_SRCDIR) && exec $(MAKE) -f %s $(%s_OBJS)\n\n",
d954 1
a954 1
		fprintf(outmk, "%s_make:\n\t@@echo \"** cannot make objs for %s\"\n\n",
d957 1
a957 1
	fprintf(outmk, "%s_OBJPATHS=", p->ident);
a958 12

	fprintf(outmk, "%s_stub.c:\n", p->name);
	fprintf(outmk, "\tprint 'int _crunched_%s_stub(int, char **, char **);"
	    "\\nint' \\\n\t    'main(int, char **, char **);\\nint' \\\n\t    "
	    "'\\n_crunched_%s_stub(int ac, char **av, char' \\\n\t    '**e)\\n"
	    "{\\n\\treturn (main(ac, av, e));\\n}' >$@@\n", p->ident, p->ident);
	fprintf(outmk, "%s.lo: %s_stub.o $(%s_OBJPATHS)\n",
	    p->name, p->name, p->ident);
	fprintf(outmk, "\t$(LINK.rlo) -o $@@ %s_stub.o $(%s_OBJPATHS)\n",
	    p->name, p->ident);
	fprintf(outmk, "\tobjcopy -G %s_crunched_%s_stub $@@\n",
	    elf_names ? "" : "_", p->ident);
@


1.7
log
@why try hard to coerce source with sed into a line array
when we can just .incbin it?
@
text
@d47 1
a47 1
__RCSID("$MirOS: src/usr.bin/crunchgen/crunchgen.c,v 1.6 2007/02/18 03:43:07 tg Exp $");
d919 1
a919 1
	fprintf(outmk, "\t$(CC) -static -o $@@ %s.o $(CRUNCHED_OBJS)"
@


1.6
log
@* convert from crunchide(1) to GNU objcopy
* more __CRAZY-correctness

now all that's missing is a total conversation to <bsd.prog.mk>
@
text
@d47 1
a47 1
__RCSID("$MirOS: src/usr.bin/crunchgen/crunchgen.c,v 1.5 2007/02/18 02:45:47 tg Exp $");
d813 1
a813 2
	extern const char *crunched_skel[];
	const char **cp;
d837 1
a837 2
	for (cp = crunched_skel; *cp != NULL; cp++)
		fprintf(outcf, "%s\n", *cp);
@


1.5
log
@use -Wl,--start-group before $(LIBS) and -Wl,--end-group afterwards

from old crunch/crunchgen
@
text
@d47 1
a47 1
__RCSID("$MirOS: src/usr.bin/crunchgen/crunchgen.c,v 1.4 2007/02/18 02:44:29 tg Exp $");
d818 1
d831 5
d837 1
d842 2
a843 1
		fprintf(outcf, "extern int _crunched_%s_stub();\n", p->ident);
d845 1
a845 1
	fprintf(outcf, "\nstruct stub entry_points[] = {\n");
d950 4
a953 4
	fprintf(outmk, "\techo \""
	    "int _crunched_%s_stub(int argc, char **argv, char **envp)"
	    "{return main(argc,argv,envp);}\" >$@@\n",
	    p->ident);
d958 1
a958 1
	fprintf(outmk, "\tcrunchide -k %s_crunched_%s_stub $@@\n",
@


1.4
log
@use <bsd.own.mk>, <bsd.prog.mk>
don't strip

from old src/usr.bin/crunch/
@
text
@d47 1
a47 1
__RCSID("$MirOS: src/usr.bin/crunchgen/crunchgen.c,v 1.3 2007/02/18 02:41:16 tg Exp $");
d913 2
a914 2
	fprintf(outmk, "\t$(CC) -static -o $@@ %s.o $(CRUNCHED_OBJS) $(LIBS)\n",
	    execfname);
@


1.3
log
@make 'special prog srcdir dir' relative to topdir (-D) too
(old commitid 10044E724AB08B6CA0B)
@
text
@d47 1
a47 1
__RCSID("$MirOS: src/usr.bin/crunchgen/crunchgen.c,v 1.2 2007/02/18 02:39:14 tg Exp $");
d806 1
d894 2
a895 2
	fprintf(outmk, "STRIP?=strip\n");
	fprintf(outmk, "LINK=$(LD) -dc -r\n");
a914 1
	fprintf(outmk, "\t$(STRIP) %s\n", execfname);
d948 1
a948 1
	fprintf(outmk, "\t$(LINK) -o $@@ %s_stub.o $(%s_OBJPATHS)\n",
@


1.2
log
@MirOSification, __CRAZY cleanliness; some KNF
@
text
@d47 1
a47 1
__RCSID("$MirOS$");
d528 10
a537 1
		if ((p->srcdir = strdup(argv[3])) == NULL)
@


1.1
log
@Initial revision
@
text
@d4 1
d29 1
d37 5
d44 1
a45 2
#include <ctype.h>
#include <string.h>
d47 1
a47 3
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/param.h>
d49 1
a49 1
#define CRUNCH_VERSION	"0.3"
d60 1
a60 1
char           *mf_name[] = {
d74 2
a75 2
	struct strlst  *next;
	char           *str;
d81 10
a90 6
	struct prog    *next;
	char           *name, *ident, *mf_name;
	char           *srcdir, *objdir;
	strlst_t       *objs, *objpaths;
	strlst_t       *links;
	int             goterror;
d93 53
a145 28
strlst_t       *srcdirs = NULL;
strlst_t       *libs = NULL;
strlst_t       *libdirs = NULL;
char		objdir[MAXPATHLEN] = "obj";
prog_t         *progs = NULL;

char            line[MAXLINELEN];

char            confname[MAXPATHLEN], infilename[MAXPATHLEN];
char            outmkname[MAXPATHLEN], outcfname[MAXPATHLEN];
char            cachename[MAXPATHLEN], curfilename[MAXPATHLEN];
char            topdir[MAXPATHLEN], execfname[MAXPATHLEN];
int             linenum = -1;
int             goterror = 0;

char           *progname = "crunchgen";

int             verbose, readcache, elf_names;	/* options */
int             reading_cache;

void            status(char *str);
void            out_of_memory(void);
void            add_string(strlst_t ** listp, char *str);
int             is_dir(char *pathname);
int             is_nonempty_file(char *pathname);
void            usage(void);
void            parse_conf_file(void);
void            gen_outputs(void);
d147 1
a147 1
int 
d150 2
a151 4
	char           *p;
	int             optc;
	extern int      optind;
	extern char    *optarg;
d216 2
a217 2
         * generate filenames
         */
d223 1
a223 1
	/* confname = `basename infilename .conf` */
d246 1
a246 1
void 
d256 1
a256 13
void            parse_one_file(char *filename);
void            parse_line(char *line, int *fc, char **fv, int nf);
void            add_srcdirs(int argc, char **argv);
void            add_progs(int argc, char **argv);
void            add_link(int argc, char **argv);
void            add_libs(int argc, char **argv);
void            add_libdirs(int argc, char **argv);
void            add_special(int argc, char **argv);

prog_t         *find_prog(char *str);
void            add_prog(char *progname);

void 
d271 1
a271 1
void 
d274 4
a277 4
	char           *fieldv[MAXFIELDS];
	int             fieldc;
	void            (*f) (int c, char **v);
	FILE           *cf;
d307 1
a307 1
			fprintf(stderr, "%s:%d: skipping unknown command `%s'.\n",
d315 1
a315 1
		  	    "argument, skipping.\n",
d330 2
a331 2
void 
parse_line(char *line, int *fc, char **fv, int nf)
a332 3
	char           *p;

	p = line;
d352 1
a352 1
void 
d355 3
a357 3
	int             i;
	char            tmppath[MAXPATHLEN];
	int             overflow;
d376 1
a376 1
			fprintf(stderr, "%s:%d: `%.40s...' is too long, skipping it.\n",
d383 1
a383 1
			fprintf(stderr, "%s:%d: `%s' is not a directory, skipping it.\n",
d390 1
a390 1
void 
d393 4
a396 4
	int             i;
	char            tmppath[MAXPATHLEN];
	char            tmppath2[MAXPATHLEN];
	int             overflow;
d415 1
a415 1
			fprintf(stderr, "%s:%d: `%.40s...' is too long, skipping it.\n",
d425 1
a425 1
				snprintf(tmppath2, sizeof(tmppath2), 
d434 1
a434 1
			fprintf(stderr, "%s:%d: `%s' is not a directory, skipping it.\n",
d442 1
a442 1
void 
d445 1
a445 1
	int             i;
d451 2
a452 2
void 
add_prog(char *progname)
d454 1
a454 1
	prog_t         *p1, *p2;
d459 1
a459 1
		if (!strcmp(p2->name, progname))
d464 1
a464 1
		p2->name = strdup(progname);
d479 1
a479 1
void 
d482 2
a483 2
	int             i;
	prog_t         *p = find_prog(argv[1]);
d496 1
a496 1
void 
d499 1
a499 1
	int             i;
d505 1
a505 1
void 
d508 2
a509 2
	int             i;
	prog_t         *p = find_prog(argv[1]);
d549 1
a549 1
		fprintf(stderr, "%s:%d: bad parameter name `%s', skipping line.\n",
d555 1
a555 1
argcount:
d562 1
a562 1
prog_t  *
d565 1
a565 1
	prog_t         *p;
d573 1
a573 14
void            remove_error_progs(void);
void            fillin_program(prog_t * p);
void            gen_specials_cache(void);
void            gen_output_makefile(void);
void            gen_output_cfile(void);

void            fillin_program_objs(prog_t * p, char *path);
void            top_makefile_rules(FILE * outmk);
void            prog_makefile_rules(FILE * outmk, prog_t * p);
void            output_strlst(FILE * outf, strlst_t * lst);
char           *genident(char *str);
char           *dir_search(char *progname);

void 
d576 1
a576 1
	prog_t         *p;
d591 1
a591 1
void 
d594 4
a597 4
	char            path[MAXPATHLEN];
	char           *srcparent;
	strlst_t       *s;
	int             i;
d656 1
a656 1
void 
d659 3
a661 3
	char           *cp, *obj, tempfname[MAXPATHLEN];
	int             fd, rc;
	FILE           *f;
d716 1
a716 1
void 
d719 1
a719 1
	prog_t         *p1, *p2;
d739 1
a739 1
void 
d742 2
a743 2
	FILE           *cachef;
	prog_t         *p;
d774 1
a774 1
void 
d777 2
a778 2
	prog_t         *p;
	FILE           *outmk;
d800 1
a800 1
void 
d803 5
a807 5
	extern char    *crunched_skel[];
	char          **cp;
	FILE           *outcf;
	prog_t         *p;
	strlst_t       *s;
d841 1
a841 1
char           *
d844 1
a844 1
	char           *n, *s, *d;
d847 4
a850 4
         * generates a Makefile/C identifier from a program name, mapping '-' to
         * '_' and ignoring all other non-identifier characters.  This leads to
         * programs named "foo.bar" and "foobar" to map to the same identifier.
         */
d864 2
a865 2
char           *
dir_search(char *progname)
d867 2
a868 2
	char            path[MAXPATHLEN];
	strlst_t       *dir;
d871 1
a871 1
		snprintf(path, sizeof(path), "%s/%s", dir->str, progname);
d878 1
a878 1
void 
d881 2
a882 3
	prog_t         *p;
	strlst_t       *l;

d913 1
a913 1
void 
d945 1
a945 1
void 
d953 2
a954 2
void 
status(char *str)
d956 2
a957 2
	static int      lastlen = 0;
	int             len, spaces;
d972 1
a972 1
void 
d975 2
a976 1
	fprintf(stderr, "%s: %d: out of memory, stopping.\n", infilename, linenum);
d980 2
a981 2
void 
add_string(strlst_t ** listp, char *str)
d983 1
a983 1
	strlst_t       *p1, *p2;
d1004 2
a1005 2
int 
is_dir(char *pathname)
d1007 1
a1007 1
	struct stat     buf;
d1014 2
a1015 2
int 
is_nonempty_file(char *pathname)
d1017 1
a1017 1
	struct stat     buf;
@


1.1.1.1
log
@Import OpenBSD-current's crunchgen tool minus mkshel.sh
@
text
@@
