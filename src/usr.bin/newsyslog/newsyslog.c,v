head	1.6;
access;
symbols
	cvs-201805022245:1.1.1.3
	MIRBSD_10:1.1.1.2.0.4
	MIRBSD_10_BASE:1.1.1.2
	MIRBSD_9_BASE:1.1.1.2
	MIRBSD_8:1.1.1.2.0.2
	MIRBSD_8_BASE:1.1.1.2
	cvs-200507211800:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2018.05.02.23.54.35;	author tg;	state Exp;
branches;
next	1.5;
commitid	1005AEA4FCD7E9489F5;

1.5
date	2018.05.02.23.52.40;	author tg;	state Exp;
branches;
next	1.4;
commitid	1005AEA4F55389831C3;

1.4
date	2018.05.02.23.44.36;	author tg;	state Exp;
branches;
next	1.3;
commitid	1005AEA4D455CCAF9E7;

1.3
date	2018.05.02.23.22.06;	author tg;	state Exp;
branches;
next	1.2;
commitid	1005AEA483674F5E8CF;

1.2
date	2018.05.02.23.17.59;	author tg;	state Exp;
branches;
next	1.1;
commitid	1005AEA47401E6D6792;

1.1
date	2005.02.05.17.29.45;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.29.45;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.07.21.21.00.04;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	560042e0092f571e;

1.1.1.3
date	2018.05.02.22.50.02;	author tg;	state Exp;
branches;
next	;
commitid	1005AEA40AD6F70B3D3;


desc
@@


1.6
log
@implement new A flag to always rotate time-based files
@
text
@/*	$OpenBSD: newsyslog.c,v 1.108 2017/07/24 12:57:01 jca Exp $	*/

/*
 * Copyright (c) 1999, 2002, 2003 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
 */

/*
 * Copyright (c) 1997, Jason Downs.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * This file contains changes from the Open Software Foundation.
 */

/*
 * Copyright 1988, 1989 by the Massachusetts Institute of Technology
 *
 * Permission to use, copy, modify, and distribute this software
 * and its documentation for any purpose and without fee is
 * hereby granted, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation,
 * and that the names of M.I.T. and the M.I.T. S.I.P.B. not be
 * used in advertising or publicity pertaining to distribution
 * of the software without specific, written prior permission.
 * M.I.T. and the M.I.T. S.I.P.B. make no representations about
 * the suitability of this software for any purpose.  It is
 * provided "as is" without express or implied warranty.
 */

/*
 *      newsyslog - roll over selected logs at the appropriate time,
 *              keeping the specified number of backup files around.
 *
 */

#define CONF "/etc/newsyslog.conf"
#define PIDFILE "/var/run/syslog.pid"
#define COMPRESS "/usr/bin/gzip"
#define COMPRESS_POSTFIX ".gz"
#define STATS_DIR "/var/run"
#define SENDMAIL "/usr/sbin/sendmail"

#include <sys/param.h>	/* DEV_BSIZE */
#include <sys/queue.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/wait.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <grp.h>
#include <limits.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

__RCSID("$MirOS: src/usr.bin/newsyslog/newsyslog.c,v 1.5 2018/05/02 23:52:40 tg Exp $");

#define CE_ROTATED	0x01		/* Log file has been rotated */
#define CE_COMPACT	0x02		/* Compact the archived log files */
#define CE_BINARY	0x04		/* Logfile is in binary, don't add */
					/* status messages */
#define CE_MONITOR	0x08		/* Monitor for changes */
#define CE_FOLLOW	0x10		/* Follow symbolic links */
#define CE_TRIMAT	0x20		/* Trim at a specific time */
#define CE_ALWAYSROTATE	0x40		/* Always rotate the file */

#define	MIN_PID		2		/* Don't touch pids lower than this */
#define	MIN_SIZE	256		/* Don't rotate if smaller (in bytes) */

#define	DPRINTF(x)	do { if (verbose) printf x ; } while (0)

struct conf_entry {
	char    *log;		/* Name of the log */
	char    *logbase;	/* Basename of the log */
	char    *backdir;	/* Directory in which to store backups */
	uid_t   uid;		/* Owner of log */
	gid_t   gid;		/* Group of log */
	int     numlogs;	/* Number of logs to keep */
	off_t   size;		/* Size cutoff to trigger trimming the log */
	int     hours;		/* Hours between log trimming */
	time_t  trim_at;	/* Specific time at which to do trimming */
	mode_t  permissions;	/* File permissions on the log */
	int	signal;		/* Signal to send (defaults to SIGHUP) */
	int     flags;		/* Flags (CE_COMPACT & CE_BINARY)  */
	char	*whom;		/* Whom to notify if logfile changes */
	const char *pidfile;	/* Path to file containing pid to signal */
	char	*runcmd;	/* Command to run instead of sending a signal */
	TAILQ_ENTRY(conf_entry) next;
};
TAILQ_HEAD(entrylist, conf_entry);

struct pidinfo {
	const char *file;
	int	signal;
};

int	verbose = 0;		/* Print out what's going on */
int	needroot = 1;		/* Root privs are necessary */
int	noaction = 0;		/* Don't do anything, just show it */
int	monitormode = 0;	/* Don't do monitoring by default */
int	force = 0;		/* Force the logs to be rotated */
const char *conf = CONF;	/* Configuration file to use */
time_t	timenow;
char	hostname[MAXHOSTNAMELEN]; /* Hostname */
char	daytime[33];		/* timenow in human readable form */
char	*arcdir;		/* Dir to put archives in (if it exists) */

const char *lstat_log(char *, size_t, int);
char   *missing_field(char *, char *, int);
char   *sob(char *);
char   *son(char *);
int	age_old_log(struct conf_entry *);
int	domonitor(struct conf_entry *);
int	isnumberstr(char *);
int	log_trim(char *);
int	movefile(char *, char *, uid_t, gid_t, mode_t);
int	stat_suffix(char *, size_t, const char *, struct stat *,
	    int (*)(const char *, struct stat *));
off_t	sizefile(struct stat *);
int	parse_file(struct entrylist *, int *);
time_t	parse8601(char *);
time_t	parseDWM(char *);
void	child_killer(int);
void	compress_log(struct conf_entry *);
void	do_entry(struct conf_entry *);
void	dotrim(struct conf_entry *);
void	rotate(struct conf_entry *, const char *);
void	parse_args(int, char **);
void	run_command(const char *);
void	send_signal(const char *, int);
void	usage(void) __dead;

int
main(int argc, char **argv)
{
	struct entrylist config, runlist;
	struct conf_entry *p, *q, *tmp;
	struct pidinfo *pidlist, *pl;
	int status, listlen, ret;
	char **av;

	parse_args(argc, argv);
	argc -= optind;
	argv += optind;

	if (needroot && getuid() && geteuid())
		errx(1, "You must be root.");

	TAILQ_INIT(&config);
	TAILQ_INIT(&runlist);

	ret = parse_file(&config, &listlen);
	if (argc == 0)
		TAILQ_CONCAT(&runlist, &config, next);
	else {
		/* Only rotate specified files. */
		listlen = 0;
		for (av = argv; *av; av++) {
			TAILQ_FOREACH_SAFE(q, &config, next, tmp)
				if (strcmp(*av, q->log) == 0) {
					TAILQ_REMOVE(&config, q, next);
					TAILQ_INSERT_TAIL(&runlist, q, next);
					listlen++;
					break;
				}
			if (q == NULL)
				warnx("%s: %s not found", conf, *av);
		}
		if (TAILQ_EMPTY(&runlist))
			errx(1, "%s: no specified log files", conf);
	}

	pidlist = calloc(listlen + 1, sizeof(struct pidinfo));
	if (pidlist == NULL)
		err(1, NULL);

	signal(SIGCHLD, child_killer);

	/* Step 1, rotate all log files */
	TAILQ_FOREACH(q, &runlist, next)
		do_entry(q);

	/* Step 2, make a list of unique pid files */
	pl = pidlist;
	TAILQ_FOREACH(q, &runlist, next) {
		if (q->flags & CE_ROTATED) {
			struct pidinfo *pltmp;

			for (pltmp = pidlist; pltmp < pl; pltmp++) {
				if ((q->pidfile && pltmp->file &&
				    strcmp(pltmp->file, q->pidfile) == 0 &&
				    pltmp->signal == q->signal) ||
				    (q->runcmd && pltmp->file &&
				    strcmp(q->runcmd, pltmp->file) == 0))
					break;
			}
			if (pltmp == pl) {	/* unique entry */
				if (q->runcmd) {
					pl->file = q->runcmd;
					pl->signal = -1;
				} else {
					pl->file = q->pidfile;
					pl->signal = q->signal;
				}
				pl++;
			}
		}
	}

	/* Step 3, send a signal or run a command */
	for (pl--; pl >= pidlist; pl--) {
		if (pl->file != NULL) {
			if (pl->signal == -1)
				run_command(pl->file);
			else
				send_signal(pl->file, pl->signal);
		}
	}
	if (!noaction)
		sleep(5);

	/* Step 4, compress the log.0 file if configured to do so and free */
	TAILQ_FOREACH(p, &runlist, next) {
		if ((p->flags & CE_COMPACT) && (p->flags & CE_ROTATED) &&
		    p->numlogs > 0)
			compress_log(p);
	}

	/* Wait for children to finish, then exit */
	while (waitpid(-1, &status, 0) != -1)
		;
	return (ret);
}

void
do_entry(struct conf_entry *ent)
{
	struct stat sb;
	int modhours;
	off_t size;

	if (lstat(ent->log, &sb) != 0)
		return;
	if (!S_ISREG(sb.st_mode) &&
	    (!S_ISLNK(sb.st_mode) || !(ent->flags & CE_FOLLOW))) {
		DPRINTF(("--> not a regular file, skipping\n"));
		return;
	}
	if (S_ISLNK(sb.st_mode) && stat(ent->log, &sb) != 0) {
		DPRINTF(("--> link target does not exist, skipping\n"));
		return;
	}
	if (ent->uid == (uid_t)-1)
		ent->uid = sb.st_uid;
	if (ent->gid == (gid_t)-1)
		ent->gid = sb.st_gid;

	DPRINTF(("%s <%d%s%s%s%s%s>: ", ent->log, ent->numlogs,
	    (ent->flags & CE_ALWAYSROTATE) ? "A" : "",
	    (ent->flags & CE_COMPACT) ? "Z" : "",
	    (ent->flags & CE_BINARY) ? "B" : "",
	    (ent->flags & CE_FOLLOW) ? "F" : "",
	    (ent->flags & CE_MONITOR) && monitormode ? "M" : ""));
	size = sizefile(&sb);
	modhours = age_old_log(ent);
	if (ent->flags & CE_TRIMAT && !force) {
		if (timenow < ent->trim_at ||
		    difftime(timenow, ent->trim_at) >= 60 * 60) {
			DPRINTF(("--> will trim at %s",
			    ctime(&ent->trim_at)));
			return;
		} else if (ent->hours <= 0) {
			DPRINTF(("--> time is up\n"));
		}
	}
	if (ent->size > 0)
		DPRINTF(("size (KB): %.2f [%d] ", size / 1024.0,
		    (int)(ent->size / 1024)));
	if (ent->hours > 0)
		DPRINTF(("age (hr): %d [%d] ", modhours, ent->hours));
	if (monitormode && (ent->flags & CE_MONITOR) && domonitor(ent))
		DPRINTF(("--> monitored\n"));
	else if (!monitormode &&
	    (force || (ent->size > 0 && size >= ent->size) ||
	    (ent->hours <= 0 && (ent->flags & CE_TRIMAT)) ||
	    (ent->hours > 0 && (modhours >= ent->hours || modhours < 0)
	    && ((ent->flags & (CE_ALWAYSROTATE | CE_BINARY)) || size >= MIN_SIZE)))) {
		DPRINTF(("--> trimming log....\n"));
		if (noaction && !verbose)
			printf("%s <%d%s%s%s%s%s>: ", ent->log, ent->numlogs,
			    (ent->flags & CE_ALWAYSROTATE) ? "A" : "",
			    (ent->flags & CE_COMPACT) ? "Z" : "",
			    (ent->flags & CE_BINARY) ? "B" : "",
			    (ent->flags & CE_FOLLOW) ? "F" : "",
			    /* !monitormode */ "");
		dotrim(ent);
		ent->flags |= CE_ROTATED;
	} else
		DPRINTF(("--> skipping\n"));
}

/* Run the specified command */
void
run_command(const char *cmd)
{
	if (noaction)
		(void)printf("run %s\n", cmd);
	else
		system(cmd);
}

/* Send a signal to the pid specified by pidfile */
void
send_signal(const char *pidfile, int thesignal)
{
	char line[BUFSIZ], *ep;
	const char *errstr;
	pid_t pid;
	long lval;
	FILE *f;

	if ((f = fopen(pidfile, "r")) == NULL) {
		warn("can't open %s", pidfile);
		return;
	}

	pid = 0;
	errno = 0;
	errstr = NULL;
	if (fgets(line, sizeof(line), f)) {
		lval = strtol(line, &ep, 10);
		if (line[0] == '\0' || (*ep != '\0' && *ep != '\n'))
			errstr = "invalid number in";
		else if (lval < 0 || (errno == ERANGE && lval == LONG_MAX))
			errstr = "out of range number in";
		else if (lval == 0)
			errstr = "no number in";
		else if (lval < MIN_PID)
			errstr = "preposterous process number in";
		else
			pid = (pid_t)lval;
	} else {
		if (errno == 0)
			errstr = "empty";
		else
			errstr = "error reading";
	}
	(void)fclose(f);

	if (errstr)
		warnx("%s pid file: %s", errstr, pidfile);
	else if (noaction)
		(void)printf("kill -%s %ld\n", sys_signame[thesignal], (long)pid);
	else if (kill(pid, thesignal))
		warnx("warning - could not send SIG%s to PID from pid file %s",
		    sys_signame[thesignal], pidfile);
}

void
parse_args(int argc, char **argv)
{
	struct timeval now;
	struct tm *tm;
	size_t l;
	char *p;
	int ch;

	gettimeofday(&now, NULL);
	timenow = now.tv_sec;
	tm = gmtime(&now.tv_sec);
	l = strftime(daytime, sizeof(daytime), "%FT%T", tm);
	snprintf(daytime + l, sizeof(daytime) - l, ".%03ldZ",
	    now.tv_usec / 1000);

	/* Let's get our hostname */
	(void)gethostname(hostname, sizeof(hostname));

	/* Truncate domain */
	if ((p = strchr(hostname, '.')) != NULL)
		*p = '\0';

	while ((ch = getopt(argc, argv, "Fmnrva:f:")) != -1) {
		switch (ch) {
		case 'a':
			arcdir = optarg;
			break;
		case 'n':
			noaction = 1;	/* This implies needroot as off */
			/* fall through */
		case 'r':
			needroot = 0;
			break;
		case 'v':
			verbose = 1;
			break;
		case 'f':
			conf = optarg;
			break;
		case 'm':
			monitormode = 1;
			break;
		case 'F':
			force = 1;
			break;
		default:
			usage();
		}
	}
	if (monitormode && force)
		errx(1, "cannot specify both -m and -F flags");
}

void
usage(void)
{
	extern const char *__progname;

	(void)fprintf(stderr, "usage: %s [-Fmnrv] [-a directory] "
	    "[-f config_file] [log ...]\n", __progname);
	exit(1);
}

/*
 * Parse a configuration file and build a linked list of all the logs
 * to process
 */
int
parse_file(struct entrylist *list, int *nentries)
{
	char line[BUFSIZ], *parse, *q, *errline, *group, *tmp, *ep;
	struct conf_entry *working;
	struct passwd *pwd;
	struct group *grp;
	struct stat sb;
	int lineno = 0;
	int ret = 0;
	FILE *f;
	long l;

	if (strcmp(conf, "-") == 0)
		f = stdin;
	else if ((f = fopen(conf, "r")) == NULL)
		err(1, "can't open %s", conf);

	*nentries = 0;

nextline:
	while (fgets(line, sizeof(line), f) != NULL) {
		lineno++;
		tmp = sob(line);
		if (*tmp == '\0' || *tmp == '#')
			continue;
		errline = strdup(tmp);
		if (errline == NULL)
			err(1, NULL);
		working = calloc(1, sizeof(*working));
		if (working == NULL)
			err(1, NULL);

		q = parse = missing_field(sob(line), errline, lineno);
		*(parse = son(line)) = '\0';
		working->log = strdup(q);
		if (working->log == NULL)
			err(1, NULL);

		if ((working->logbase = strrchr(working->log, '/')) != NULL)
			working->logbase++;

		q = parse = missing_field(sob(++parse), errline, lineno);
		*(parse = son(parse)) = '\0';
		if ((group = strchr(q, ':')) != NULL ||
		    (group = strrchr(q, '.')) != NULL)  {
			*group++ = '\0';
			if (*q) {
				if (!(isnumberstr(q))) {
					if ((pwd = getpwnam(q)) == NULL) {
						warnx("%s:%d: unknown user"
						    " %s --> skipping",
						    conf, lineno, q);
						ret = 1;
						goto nextline;
					}
					working->uid = pwd->pw_uid;
				} else
					working->uid = atoi(q);
			} else
				working->uid = (uid_t)-1;

			q = group;
			if (*q) {
				if (!(isnumberstr(q))) {
					if ((grp = getgrnam(q)) == NULL) {
						warnx("%s:%d: unknown group"
						    " %s --> skipping",
						    conf, lineno, q);
						ret = 1;
						goto nextline;
					}
					working->gid = grp->gr_gid;
				} else
					working->gid = atoi(q);
			} else
				working->gid = (gid_t)-1;

			q = parse = missing_field(sob(++parse), errline, lineno);
			*(parse = son(parse)) = '\0';
		} else {
			working->uid = (uid_t)-1;
			working->gid = (gid_t)-1;
		}

		l = strtol(q, &ep, 8);
		if (*ep != '\0' || l < 0 || l > ALLPERMS) {
			warnx("%s:%d: bad permissions: %s --> skipping", conf,
			    lineno, q);
			ret = 1;
			goto nextline;
		}
		working->permissions = (mode_t)l;

		q = parse = missing_field(sob(++parse), errline, lineno);
		*(parse = son(parse)) = '\0';
		l = strtol(q, &ep, 10);
		if (*ep != '\0' || l < 0 || l >= INT_MAX) {
			warnx("%s:%d: bad number: %s --> skipping", conf,
			    lineno, q);
			ret = 1;
			goto nextline;
		}
		working->numlogs = (int)l;

		q = parse = missing_field(sob(++parse), errline, lineno);
		*(parse = son(parse)) = '\0';
		if (isdigit((unsigned char)*q))
			working->size = atoi(q) * 1024;
		else
			working->size = -1;

		working->flags = 0;
		q = parse = missing_field(sob(++parse), errline, lineno);
		*(parse = son(parse)) = '\0';
		l = strtol(q, &ep, 10);
		if (l < 0 || l >= INT_MAX) {
			warnx("%s:%d: interval out of range: %s --> skipping",
			    conf, lineno, q);
			ret = 1;
			goto nextline;
		}
		working->hours = (int)l;
		switch (*ep) {
		case '\0':
			break;
		case '@@':
			working->trim_at = parse8601(ep + 1);
			if (working->trim_at == (time_t) - 1) {
				warnx("%s:%d: bad time: %s --> skipping", conf,
				    lineno, q);
				ret = 1;
				goto nextline;
			}
			working->flags |= CE_TRIMAT;
			break;
		case '$':
			working->trim_at = parseDWM(ep + 1);
			if (working->trim_at == (time_t) - 1) {
				warnx("%s:%d: bad time: %s --> skipping", conf,
				    lineno, q);
				ret = 1;
				goto nextline;
			}
			working->flags |= CE_TRIMAT;
			break;
		case '*':
			if (q == ep)
				break;
			/* FALLTHROUGH */
		default:
			warnx("%s:%d: bad interval/at: %s --> skipping", conf,
			    lineno, q);
			ret = 1;
			goto nextline;
		}

		q = sob(++parse);	/* Optional field */
		if (*q == 'Z' || *q == 'z' || *q == 'B' || *q == 'b' ||
		    *q == 'A' || *q == 'a' ||
		    *q == 'M' || *q == 'm' || *q == 'F' || *q == 'f') {
			*(parse = son(q)) = '\0';
			while (*q) {
				switch (*q) {
				case 'Z':
				case 'z':
					working->flags |= CE_COMPACT;
					break;
				case 'B':
				case 'b':
					working->flags |= CE_BINARY;
					break;
				case 'A':
				case 'a':
					working->flags |= CE_ALWAYSROTATE;
					break;
				case 'M':
				case 'm':
					working->flags |= CE_MONITOR;
					break;
				case 'F':
				case 'f':
					working->flags |= CE_FOLLOW;
					break;
				default:
					warnx("%s:%d: illegal flag: `%c'"
					    " --> skipping",
					    conf, lineno, *q);
					ret = 1;
					goto nextline;
				}
				q++;
			}
		} else
			parse--;	/* no flags so undo */

		working->pidfile = PIDFILE;
		working->signal = SIGHUP;
		working->runcmd = NULL;
		working->whom = NULL;
		for (;;) {
			q = parse = sob(++parse);	/* Optional field */
			if (q == NULL || *q == '\0')
				break;
			if (*q == '/') {
				*(parse = son(parse)) = '\0';
				if (strlen(q) >= PATH_MAX) {
					warnx("%s:%d: pathname too long: %s"
					    " --> skipping",
					    conf, lineno, q);
					ret = 1;
					goto nextline;
				}
				working->pidfile = strdup(q);
				if (working->pidfile == NULL)
					err(1, NULL);
			} else if (*q == '"' && (tmp = strchr(q + 1, '"'))) {
				*(parse = tmp) = '\0';
				if (*++q != '\0') {
					working->runcmd = strdup(q);
					if (working->runcmd == NULL)
						err(1, NULL);
				}
				working->pidfile = NULL;
				working->signal = -1;
			} else if (strncmp(q, "SIG", 3) == 0) {
				int i;

				*(parse = son(parse)) = '\0';
				for (i = 1; i < NSIG; i++) {
					if (!strcmp(sys_signame[i], q + 3)) {
						working->signal = i;
						break;
					}
				}
				if (i == NSIG) {
					warnx("%s:%d: unknown signal: %s"
					    " --> skipping",
					    conf, lineno, q);
					ret = 1;
					goto nextline;
				}
			} else if (working->flags & CE_MONITOR) {
				*(parse = son(parse)) = '\0';
				working->whom = strdup(q);
				if (working->whom == NULL)
					err(1, NULL);
			} else {
				warnx("%s:%d: unrecognized field: %s"
				    " --> skipping",
				    conf, lineno, q);
				ret = 1;
				goto nextline;
			}
		}
		free(errline);

		if ((working->flags & CE_MONITOR) && working->whom == NULL) {
			warnx("%s:%d: missing monitor notification field"
			    " --> skipping",
			    conf, lineno);
			ret = 1;
			goto nextline;
		}

		/* If there is an arcdir, set working->backdir. */
		if (arcdir != NULL && working->logbase != NULL) {
			if (*arcdir == '/') {
				/* Fully qualified arcdir */
				working->backdir = arcdir;
			} else {
				/* arcdir is relative to log's parent dir */
				*(working->logbase - 1) = '\0';
				if ((asprintf(&working->backdir, "%s/%s",
				    working->log, arcdir)) == -1)
					err(1, NULL);
				*(working->logbase - 1) = '/';
			}
			/* Ignore arcdir if it doesn't exist. */
			if (stat(working->backdir, &sb) != 0 ||
			    !S_ISDIR(sb.st_mode)) {
				if (working->backdir != arcdir)
					free(working->backdir);
				working->backdir = NULL;
			}
		} else
			working->backdir = NULL;

		/* Make sure we can't oflow PATH_MAX */
		if (working->backdir != NULL) {
			if (snprintf(line, sizeof(line), "%s/%s.%d%s",
			    working->backdir, working->logbase,
			    working->numlogs, COMPRESS_POSTFIX) >= PATH_MAX) {
				warnx("%s:%d: pathname too long: %s"
				    " --> skipping", conf, lineno, q);
				ret = 1;
				goto nextline;
			}
		} else {
			if (snprintf(line, sizeof(line), "%s.%d%s",
			    working->log, working->numlogs, COMPRESS_POSTFIX)
			    >= PATH_MAX) {
				warnx("%s:%d: pathname too long: %s"
				    " --> skipping", conf, lineno,
				    working->log);
				ret = 1;
				goto nextline;
			}
		}
		TAILQ_INSERT_TAIL(list, working, next);
		(*nentries)++;
	}
	(void)fclose(f);
	return (ret);
}

char *
missing_field(char *p, char *errline, int lineno)
{
	if (p == NULL || *p == '\0') {
		warnx("%s:%d: missing field", conf, lineno);
		fputs(errline, stderr);
		exit(1);
	}
	return (p);
}

void
rotate(struct conf_entry *ent, const char *oldlog)
{
	char file1[PATH_MAX], file2[PATH_MAX];
	const char *suffix;
	int numdays = ent->numlogs - 1;
	int done = 0;

	/* Remove old logs */
	do {
		(void)snprintf(file1, sizeof(file1), "%s.%d", oldlog, numdays);
		(void)snprintf(file2, sizeof(file2), "%s.%d%s", oldlog,
		    numdays, COMPRESS_POSTFIX);
		if (noaction) {
			printf("\trm -f %s %s\n", file1, file2);
			done = access(file1, 0) && access(file2, 0);
		} else {
			done = unlink(file1) && unlink(file2);
		}
		numdays++;
	} while (done == 0);

	/* Move down log files */
	for (numdays = ent->numlogs - 2; numdays >= 0; numdays--) {
		/*
		 * If both the compressed archive and the non-compressed archive
		 * exist, we decide which to rotate based on the CE_COMPACT flag
		 */
		(void)snprintf(file1, sizeof(file1), "%s.%d", oldlog, numdays);
		suffix = lstat_log(file1, sizeof(file1), ent->flags);
		if (suffix == NULL)
			continue;
		(void)snprintf(file2, sizeof(file2), "%s.%d%s", oldlog,
		    numdays + 1, suffix);

		if (noaction) {
			printf("\tmv %s %s\n", file1, file2);
			printf("\tchmod %o %s\n", ent->permissions, file2);
			printf("\tchown %u:%u %s\n", ent->uid, ent->gid, file2);
		} else {
			if (rename(file1, file2))
				warn("can't mv %s to %s", file1, file2);
			if (chmod(file2, ent->permissions))
				warn("can't chmod %s", file2);
			if (chown(file2, ent->uid, ent->gid))
				warn("can't chown %s", file2);
		}
	}
}

void
dotrim(struct conf_entry *ent)
{
	char file1[PATH_MAX], file2[PATH_MAX], oldlog[PATH_MAX];
	int fd;

	/* Is there a separate backup dir? */
	if (ent->backdir != NULL)
		snprintf(oldlog, sizeof(oldlog), "%s/%s", ent->backdir,
		    ent->logbase);
	else
		strlcpy(oldlog, ent->log, sizeof(oldlog));

	if (ent->numlogs > 0)
		rotate(ent, oldlog);
	if (!noaction && !(ent->flags & CE_BINARY))
		(void)log_trim(ent->log);

	(void)snprintf(file2, sizeof(file2), "%s.XXXXXXXXXX", ent->log);
	if (noaction)  {
		printf("\tmktemp %s\n", file2);
	} else {
		if ((fd = mkstemp(file2)) < 0)
			err(1, "can't start '%s' log", file2);
		if (fchmod(fd, ent->permissions))
			err(1, "can't chmod '%s' log file", file2);
		if (fchown(fd, ent->uid, ent->gid))
			err(1, "can't chown '%s' log file", file2);
		(void)close(fd);
		/* Add status message */
		if (!(ent->flags & CE_BINARY) && log_trim(file2))
			err(1, "can't add status message to log '%s'", file2);
	}

	if (ent->numlogs == 0) {
		if (noaction)
			printf("\trm %s\n", ent->log);
		else if (unlink(ent->log))
			warn("can't rm %s", ent->log);
	} else {
		(void)snprintf(file1, sizeof(file1), "%s.0", oldlog);
		if (noaction) {
			printf("\tmv %s to %s\n", ent->log, file1);
			printf("\tchmod %o %s\n", ent->permissions, file1);
			printf("\tchown %u:%u %s\n", ent->uid, ent->gid, file1);
		} else if (movefile(ent->log, file1, ent->uid, ent->gid,
		    ent->permissions))
			warn("can't mv %s to %s", ent->log, file1);
	}

	/* Now move the new log file into place */
	if (noaction)
		printf("\tmv %s to %s\n", file2, ent->log);
	else if (rename(file2, ent->log))
		warn("can't mv %s to %s", file2, ent->log);
}

/* Log the fact that the logs were turned over */
int
log_trim(char *log)
{
	FILE    *f;

	if ((f = fopen(log, "a")) == NULL)
		return (-1);
	(void)fprintf(f, "%s %s newsyslog[%ld]: logfile turned over\n",
	    daytime, hostname, (long)getpid());
	if (fclose(f) == EOF)
		err(1, "log_trim: fclose");
	return (0);
}

/* Fork off compress or gzip to compress the old log file */
void
compress_log(struct conf_entry *ent)
{
	const char *base;
	char tmp[PATH_MAX];
	pid_t pid;

	if (ent->backdir != NULL)
		snprintf(tmp, sizeof(tmp), "%s/%s.0", ent->backdir,
		    ent->logbase);
	else
		snprintf(tmp, sizeof(tmp), "%s.0", ent->log);

	if ((base = strrchr(COMPRESS, '/')) == NULL)
		base = COMPRESS;
	else
		base++;
	if (noaction) {
		printf("%s %s\n", base, tmp);
		return;
	}
	pid = fork();
	if (pid < 0) {
		err(1, "fork");
	} else if (pid == 0) {
		(void)execl(COMPRESS, base, "-f", tmp, (char *)NULL);
		warn(COMPRESS);
		_exit(1);
	}
}

/* Return size in bytes of a file */
off_t
sizefile(struct stat *sb)
{
	/* For sparse files, return the size based on number of blocks used. */
	if (sb->st_size / DEV_BSIZE > sb->st_blocks)
		return (sb->st_blocks * DEV_BSIZE);
	else
		return (sb->st_size);
}

/* Return the age (in hours) of old log file (file.0), or -1 if none */
int
age_old_log(struct conf_entry *ent)
{
	char file[PATH_MAX];
	struct stat sb;

	if (ent->backdir != NULL)
		(void)snprintf(file, sizeof(file), "%s/%s.0", ent->backdir,
		    ent->logbase);
	else
		(void)snprintf(file, sizeof(file), "%s.0", ent->log);
	if (ent->flags & CE_COMPACT) {
		if (stat_suffix(file, sizeof(file), COMPRESS_POSTFIX, &sb,
		    stat) < 0 && stat(file, &sb) < 0)
			return (-1);
	} else {
		if (stat(file, &sb) < 0 && stat_suffix(file, sizeof(file),
		    COMPRESS_POSTFIX, &sb, stat) < 0)
			return (-1);
	}
	return ((int)(timenow - sb.st_mtime + 1800) / 3600);
}

/* Skip Over Blanks */
char *
sob(char *p)
{
	if (p == NULL)
		return(p);
	while (isspace((unsigned char)*p))
		p++;
	return (p);
}

/* Skip Over Non-Blanks */
char *
son(char *p)
{
	while (p && *p && !isspace((unsigned char)*p))
		p++;
	return (p);
}

/* Check if string is actually a number */
int
isnumberstr(char *string)
{
	while (*string) {
		if (!isdigit((unsigned char)*string++))
			return (0);
	}
	return (1);
}

int
domonitor(struct conf_entry *ent)
{
	char fname[PATH_MAX], *flog, *p, *rb = NULL;
	struct stat sb, tsb;
	off_t osize;
	FILE *fp;
	int rd;

	if (stat(ent->log, &sb) < 0)
		return (0);

	if (noaction) {
		if (!verbose)
			printf("%s: monitored\n", ent->log);
		return (1);
	}

	flog = strdup(ent->log);
	if (flog == NULL)
		err(1, NULL);

	for (p = flog; *p != '\0'; p++) {
		if (*p == '/')
			*p = '_';
	}
	snprintf(fname, sizeof(fname), "%s/newsyslog.%s.size",
	    STATS_DIR, flog);

	/* ..if it doesn't exist, simply record the current size. */
	if ((sb.st_size == 0) || stat(fname, &tsb) < 0)
		goto update;

	fp = fopen(fname, "r");
	if (fp == NULL) {
		warn("%s", fname);
		goto cleanup;
	}
	if (fscanf(fp, "%lld\n", &osize) != 1) {
		fclose(fp);
		goto update;
	}

	fclose(fp);

	/* If the file is smaller, mark the entire thing as changed. */
	if (sb.st_size < osize)
		osize = 0;

	/* Now see if current size is larger. */
	if (sb.st_size > osize) {
		rb = malloc(sb.st_size - osize);
		if (rb == NULL)
			err(1, NULL);

		/* Open logfile, seek. */
		fp = fopen(ent->log, "r");
		if (fp == NULL) {
			warn("%s", ent->log);
			goto cleanup;
		}
		fseek(fp, osize, SEEK_SET);
		rd = fread(rb, 1, sb.st_size - osize, fp);
		if (rd < 1) {
			warn("fread");
			fclose(fp);
			goto cleanup;
		}
		fclose(fp);

		/* Send message. */
		fp = popen(SENDMAIL " -t", "w");
		if (fp == NULL) {
			warn("popen");
			goto cleanup;
		}
		fprintf(fp, "Auto-Submitted: auto-generated\n");
		fprintf(fp, "To: %s\nSubject: LOGFILE NOTIFICATION: %s\n\n\n",
		    ent->whom, ent->log);
		fwrite(rb, 1, rd, fp);
		fputs("\n\n", fp);

		pclose(fp);
	}
update:
	/* Reopen for writing and update file. */
	fp = fopen(fname, "w");
	if (fp == NULL) {
		warn("%s", fname);
		goto cleanup;
	}
	fprintf(fp, "%lld\n", (long long)sb.st_size);
	fclose(fp);

cleanup:
	free(flog);
	free(rb);
	return (1);
}

/* ARGSUSED */
void
child_killer(int signo __unused)
{
	int save_errno = errno;
	int status;

	while (waitpid(-1, &status, WNOHANG) > 0)
		;
	errno = save_errno;
}

int
stat_suffix(char *file, size_t size, const char *suffix, struct stat *sp,
    int (*func)(const char *, struct stat *))
{
	size_t n;

	n = strlcat(file, suffix, size);
	if (n < size && func(file, sp) == 0)
		return (0);
	file[n - strlen(suffix)] = '\0';
	return (-1);
}

/*
 * lstat() a log, possibly appending a suffix; order is based on flags.
 * Returns the suffix appended (may be empty string) or NULL if no file.
 */
const char *
lstat_log(char *file, size_t size, int flags)
{
	struct stat sb;

	if (flags & CE_COMPACT) {
		if (stat_suffix(file, size, COMPRESS_POSTFIX, &sb, lstat) == 0)
			return (COMPRESS_POSTFIX);
		if (lstat(file, &sb) == 0)
			return ("");
	} else {
		if (lstat(file, &sb) == 0)
			return ("");
		if (stat_suffix(file, size, COMPRESS_POSTFIX, &sb, lstat) == 0)
			return (COMPRESS_POSTFIX);

	}
	return (NULL);
}

/*
 * Parse a limited subset of ISO 8601. The specific format is as follows:
 *
 * [CC[YY[MM[DD]]]][THH[MM[SS]]]	(where `T' is the literal letter)
 *
 * We don't accept a timezone specification; missing fields (including timezone)
 * are defaulted to the current date but time zero.
 */
time_t
parse8601(char *s)
{
	struct tm tm, *tmp;
	char *t;
	long l;

	tmp = localtime(&timenow);
	tm = *tmp;

	tm.tm_hour = tm.tm_min = tm.tm_sec = 0;

	l = strtol(s, &t, 10);
	if (l < 0 || l >= INT_MAX || (*t != '\0' && *t != 'T'))
		return (-1);

	/*
	 * Now t points either to the end of the string (if no time was
	 * provided) or to the letter `T' which separates date and time in
	 * ISO 8601.  The pointer arithmetic is the same for either case.
	 */
	switch (t - s) {
	case 8:
		tm.tm_year = ((l / 1000000) - 19) * 100;
		l = l % 1000000;
	case 6:
		tm.tm_year -= tm.tm_year % 100;
		tm.tm_year += l / 10000;
		l = l % 10000;
	case 4:
		tm.tm_mon = (l / 100) - 1;
		l = l % 100;
	case 2:
		tm.tm_mday = l;
	case 0:
		break;
	default:
		return (-1);
	}

	/* sanity check */
	if (tm.tm_year < 70 || tm.tm_mon < 0 || tm.tm_mon > 12 ||
	    tm.tm_mday < 1 || tm.tm_mday > 31)
		return (-1);

	if (*t != '\0') {
		s = ++t;
		l = strtol(s, &t, 10);
		if (l < 0 || l >= INT_MAX ||
		    (*t != '\0' && !isspace((unsigned char)*t)))
			return (-1);

		switch (t - s) {
		case 6:
			tm.tm_sec = l % 100;
			l /= 100;
		case 4:
			tm.tm_min = l % 100;
			l /= 100;
		case 2:
			tm.tm_hour = l;
		case 0:
			break;
		default:
			return (-1);
		}

		/* sanity check */
		if (tm.tm_sec < 0 || tm.tm_sec > 60 || tm.tm_min < 0 ||
		    tm.tm_min > 59 || tm.tm_hour < 0 || tm.tm_hour > 23)
			return (-1);
	}
	return (mktime(&tm));
}

/*-
 * Parse a cyclic time specification, the format is as follows:
 *
 *	[Dhh] or [Wd[Dhh]] or [Mdd[Dhh]]
 *
 * to rotate a logfile cyclic at
 *
 *	- every day (D) within a specific hour (hh)	(hh = 0...23)
 *	- once a week (W) at a specific day (d)     OR	(d = 0..6, 0 = Sunday)
 *	- once a month (M) at a specific day (d)	(d = 1..31,l|L)
 *
 * We don't accept a timezone specification; missing fields
 * are defaulted to the current date but time zero.
 */
time_t
parseDWM(char *s)
{
	static int mtab[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
	int WMseen = 0, Dseen = 0, nd;
	struct tm tm, *tmp;
	char *t;
	long l;

	tmp = localtime(&timenow);
	tm = *tmp;

	/* set no. of days per month */

	nd = mtab[tm.tm_mon];

	if (tm.tm_mon == 1) {
		if (((tm.tm_year + 1900) % 4 == 0) &&
		    ((tm.tm_year + 1900) % 100 != 0) &&
		    ((tm.tm_year + 1900) % 400 == 0)) {
			nd++;	/* leap year, 29 days in february */
		}
	}
	tm.tm_hour = tm.tm_min = tm.tm_sec = 0;

	for (;;) {
		switch (*s) {
		case 'D':
			if (Dseen)
				return (-1);
			Dseen++;
			s++;
			l = strtol(s, &t, 10);
			if (l < 0 || l > 23)
				return (-1);
			tm.tm_hour = l;
			break;

		case 'W':
			if (WMseen)
				return (-1);
			WMseen++;
			s++;
			l = strtol(s, &t, 10);
			if (l < 0 || l > 6)
				return (-1);
			if (l != tm.tm_wday) {
				int save;

				if (l < tm.tm_wday) {
					save = 6 - tm.tm_wday;
					save += (l + 1);
				} else {
					save = l - tm.tm_wday;
				}

				tm.tm_mday += save;

				if (tm.tm_mday > nd) {
					tm.tm_mon++;
					tm.tm_mday = tm.tm_mday - nd;
				}
			}
			break;

		case 'M':
			if (WMseen)
				return (-1);
			WMseen++;
			s++;
			if (tolower((unsigned char)*s) == 'l') {
				tm.tm_mday = nd;
				s++;
				t = s;
			} else {
				l = strtol(s, &t, 10);
				if (l < 1 || l > 31)
					return (-1);

				if (l > nd)
					return (-1);
				if (l < tm.tm_mday)
					tm.tm_mon++;
				tm.tm_mday = l;
			}
			break;

		default:
			return (-1);
			break;
		}

		if (*t == '\0' || isspace((unsigned char)*t))
			break;
		else
			s = t;
	}
	return (mktime(&tm));
}

/*
 * Move a file using rename(2) if possible and copying if not.
 */
int
movefile(char *from, char *to, uid_t owner_uid, gid_t group_gid, mode_t perm)
{
	FILE *src, *dst;
	int i;

	/* try rename(2) first */
	if (rename(from, to) == 0) {
		if (chmod(to, perm))
			warn("can't chmod %s", to);
		if (chown(to, owner_uid, group_gid))
			warn("can't chown %s", to);
		return (0);
	} else if (errno != EXDEV)
		return (-1);

	/* different filesystem, have to copy the file */
	if ((src = fopen(from, "r")) == NULL)
		err(1, "can't fopen %s for reading", from);
	if ((dst = fopen(to, "w")) == NULL)
		err(1, "can't fopen %s for writing", to);
	if (fchmod(fileno(dst), perm))
		err(1, "can't fchmod %s", to);
	if (fchown(fileno(dst), owner_uid, group_gid))
		err(1, "can't fchown %s", to);

	while ((i = getc(src)) != EOF) {
		if ((putc(i, dst)) == EOF)
			err(1, "error writing to %s", to);
	}

	if (ferror(src))
		err(1, "error reading from %s", from);
	if ((fclose(src)) != 0)
		err(1, "can't fclose %s", from);
	if ((fclose(dst)) != 0)
		err(1, "can't fclose %s", to);
	if ((unlink(from)) != 0)
		err(1, "can't unlink %s", from);

	return (0);
}
@


1.5
log
@install a new 'A' flag, currently a nop, and clean up inconsistencies
@
text
@d101 1
a101 1
__RCSID("$MirOS: src/usr.bin/newsyslog/newsyslog.c,v 1.2 2018/05/02 23:17:59 tg Exp $");
d332 1
a332 1
	    && ((ent->flags & CE_BINARY) || size >= MIN_SIZE)))) {
@


1.4
log
@improve display of the manpage and document better how the fields are
distinguished in the face of multiple optional ones (also fix .c for
the 'F' flag); render flags as a list instead of overlong prose
@
text
@d110 1
d303 2
a304 1
	DPRINTF(("%s <%d%s%s%s%s>: ", ent->log, ent->numlogs,
d335 2
a336 2
			printf("%s <%d%s%s%s>\n", ent->log,
			    ent->numlogs,
d339 2
a340 1
			    (ent->flags & CE_FOLLOW) ? "F" : "");
d631 1
d644 4
@


1.3
log
@make __CRAZY clean
@
text
@d628 1
a628 1
		    *q == 'M' || *q == 'm') {
@


1.2
log
@make it compile
@
text
@d101 1
a101 1
__RCSID("$MirOS$");
d130 1
a130 1
	char	*pidfile;	/* Path to file containing pid to signal */
d137 1
a137 1
	char	*file;
d146 1
a146 1
char	*conf = CONF;		/* Configuration file to use */
d152 1
a152 1
char   *lstat_log(char *, size_t, int);
d161 1
a161 1
int	stat_suffix(char *, size_t, char *, struct stat *,
d173 3
a175 3
void	run_command(char *);
void	send_signal(char *, int);
void	usage(void);
d346 1
a346 1
run_command(char *cmd)
d356 1
a356 1
send_signal(char *pidfile, int signal)
d358 2
a359 1
	char line[BUFSIZ], *ep, *err;
d371 1
a371 1
	err = NULL;
d375 1
a375 1
			err = "invalid number in";
d377 1
a377 1
			err = "out of range number in";
d379 1
a379 1
			err = "no number in";
d381 1
a381 1
			err = "preposterous process number in";
d386 1
a386 1
			err = "empty";
d388 1
a388 1
			err = "error reading";
d392 2
a393 2
	if (err)
		warnx("%s pid file: %s", err, pidfile);
d395 2
a396 2
		(void)printf("kill -%s %ld\n", sys_signame[signal], (long)pid);
	else if (kill(pid, signal))
d398 1
a398 1
		    sys_signame[signal], pidfile);
d794 2
a795 1
	char file1[PATH_MAX], file2[PATH_MAX], *suffix;
d917 2
a918 1
	char *base, tmp[PATH_MAX];
d1113 1
a1113 1
child_killer(int signo)
d1124 1
a1124 1
stat_suffix(char *file, size_t size, char *suffix, struct stat *sp,
d1140 1
a1140 1
char *
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.80 2004/05/10 05:32:16 deraadt Exp $	*/
d74 6
a79 22
#ifndef lint
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.80 2004/05/10 05:32:16 deraadt Exp $";
#endif /* not lint */

#ifndef CONF
#define CONF "/etc/newsyslog.conf" /* Configuration file */
#endif
#ifndef PIDFILE
#define PIDFILE "/etc/syslog.pid"
#endif
#ifndef COMPRESS
#define COMPRESS "/usr/bin/compress" /* File compression program */
#endif
#ifndef COMPRESS_POSTFIX
#define COMPRESS_POSTFIX ".Z"
#endif
#ifndef STATS_DIR
#define STATS_DIR "/etc"
#endif
#ifndef SENDMAIL
#define SENDMAIL "/usr/lib/sendmail"
#endif
d81 2
a82 1
#include <sys/param.h>
d101 2
d111 1
a111 1
#define	MIN_PID		4		/* Don't touch pids lower than this */
d132 1
a132 1
	struct conf_entry *next; /* Linked list pointer */
d134 1
d149 1
a149 1
char	*daytime;		/* timenow in human readable form */
a151 1
FILE   *openmail(void);
d164 1
a164 2
struct conf_entry *
	parse_file(int *);
d171 1
d180 2
a181 1
	struct conf_entry *p, *q, *x, *y;
d183 1
a183 1
	int status, listlen;
d185 1
a185 1
	
d193 7
a199 2
	p = parse_file(&listlen);
	if (argc > 0) {
a200 1
		x = y = NULL;
d203 1
a203 1
			for (q = p; q; q = q->next)
d205 2
a206 6
					if (x == NULL)
						x = y = q;
					else {
						y->next = q;
						y = q;
					}
d213 1
a213 1
		if (x == NULL)
a214 2
		y->next = NULL;
		p = x;
d217 1
a217 1
	pidlist = (struct pidinfo *)calloc(listlen + 1, sizeof(struct pidinfo));
d219 1
a219 1
		err(1, "calloc");
d224 1
a224 1
	for (q = p; q; q = q->next)
d228 2
a229 1
	for (q = p, pl = pidlist; q; ) {
a251 1
		q = q->next;
d267 3
a269 2
	while (p) {
		if ((p->flags & CE_COMPACT) && (p->flags & CE_ROTATED))
a270 3
		q = p;
		p = p->next;
		free(q);
d276 1
a276 1
	exit(0);
d283 1
a283 1
	int modtime;
d308 1
a308 1
	modtime = age_old_log(ent);
d323 1
a323 1
		DPRINTF(("age (hr): %d [%d] ", modtime, ent->hours));
d329 1
a329 1
	    (ent->hours > 0 && (modtime >= ent->hours || modtime < 0)
d396 2
a397 2
		warnx("warning - could not send SIG%s to daemon",
		    sys_signame[signal]);
d403 3
d409 6
a414 3
	timenow = time(NULL);
	daytime = ctime(&timenow) + 4;
	daytime[15] = '\0';
d429 1
a429 1
			noaction++; /* This implies needroot as off */
d435 1
a435 1
			verbose++;
d441 1
a441 1
			monitormode++;
d444 1
a444 1
			force++;
d465 1
a465 1
 * Parse a configuration file and return a linked list of all the logs
d468 2
a469 2
struct conf_entry *
parse_file(int *nentries)
d472 1
a472 1
	struct conf_entry *working = NULL, *first = NULL;
d476 2
a477 1
	int lineno;
d487 4
a490 1
	for (lineno = 1; fgets(line, sizeof(line), f); lineno++) {
d496 4
a499 13
			err(1, "strdup");
		(*nentries)++;
		if (!first) {
			working = malloc(sizeof(struct conf_entry));
			if (working == NULL)
				err(1, "malloc");
			first = working;
		} else {
			working->next = malloc(sizeof(struct conf_entry));
			if (working->next == NULL)
				err(1, "malloc");
			working = working->next;
		}
d505 1
a505 1
			err(1, "strdup");
d517 3
a519 2
					if ((pwd = getpwnam(q)) == NULL)
						errx(1, "%s:%d: unknown user: %s",
d521 3
d529 1
a529 1
			
d533 3
a535 2
					if ((grp = getgrnam(q)) == NULL)
						errx(1, "%s:%d: unknown group: %s",
d537 3
d545 1
a545 1
			
d554 6
a559 2
		if (*ep != '\0' || l < 0 || l > ALLPERMS)
			errx(1, "%s:%d: bad permissions: %s", conf, lineno, q);
d565 6
a570 2
		if (*ep != '\0' || l < 0 || l >= INT_MAX)
			errx(1, "%s:%d: bad number: %s", conf, lineno, q);
d575 1
a575 1
		if (isdigit(*q))
d579 1
a579 1
		
d584 6
a589 3
		if (l < 0 || l >= INT_MAX)
			errx(1, "%s:%d: interval out of range: %s", conf,
			    lineno, q);
d596 6
a601 2
			if (working->trim_at == (time_t) - 1)
				errx(1, "%s:%d: bad time: %s", conf, lineno, q);
d606 6
a611 2
			if (working->trim_at == (time_t) - 1)
				errx(1, "%s:%d: bad time: %s", conf, lineno, q);
d619 4
a622 2
			errx(1, "%s:%d: bad interval/at: %s", conf, lineno, q);
			break;
d648 2
a649 1
					errx(1, "%s:%d: illegal flag: `%c'",
d651 2
a652 1
					break;
d669 3
a671 2
				if (strlen(q) >= MAXPATHLEN)
					errx(1, "%s:%d: pathname too long: %s",
d673 3
d678 1
a678 1
					err(1, "strdup");
d684 1
a684 1
						err(1, "strdup");
d698 3
a700 2
				if (i == NSIG)
					errx(1, "%s:%d: unknown signal: %s",
d702 3
d709 4
a712 3
					err(1, "strdup");
			} else
				errx(1, "%s:%d: unrecognized field: %s",
d714 3
d720 3
a722 2
		if ((working->flags & CE_MONITOR) && working->whom == NULL)
			errx(1, "%s:%d: missing monitor notification field",
d724 3
d738 1
a738 1
					err(1, "malloc");
d751 1
a751 1
		/* Make sure we can't oflow MAXPATHLEN */
d755 6
a760 3
			    working->numlogs, COMPRESS_POSTFIX) >= MAXPATHLEN)
				errx(1, "%s:%d: pathname too long: %s",
				    conf, lineno, q);
d764 7
a770 3
			    >= MAXPATHLEN)
				errx(1, "%s:%d: pathname too long: %s",
				    conf, lineno, working->log);
d772 2
a774 2
	if (working)
		working->next = NULL;
d776 1
a776 1
	return (first);
d791 1
a791 1
dotrim(struct conf_entry *ent)
d793 3
a795 3
	char    file1[MAXPATHLEN], file2[MAXPATHLEN];
	char    oldlog[MAXPATHLEN], *suffix;
	int	numdays = ent->numlogs, fd;
d797 13
a809 18
	/* Is there a separate backup dir? */
	if (ent->backdir != NULL)
		snprintf(oldlog, sizeof(oldlog), "%s/%s", ent->backdir,
		    ent->logbase);
	else
		strlcpy(oldlog, ent->log, sizeof(oldlog));

	/* Remove oldest log (may not exist) */
	(void)snprintf(file1, sizeof(file1), "%s.%d", oldlog, numdays);
	(void)snprintf(file2, sizeof(file2), "%s.%d%s", oldlog, numdays,
	    COMPRESS_POSTFIX);

	if (noaction) {
		printf("\trm -f %s %s\n", file1, file2);
	} else {
		(void)unlink(file1);
		(void)unlink(file2);
	}
d812 1
a812 1
	while (numdays--) {
d837 17
d855 1
a855 1
		(void)log_trim(ent->log);  /* Report the trimming to the old log */
d915 1
a915 1
	char *base, tmp[MAXPATHLEN];
d942 1
a942 1
/* Return size in kilobytes of a file */
d957 1
a957 1
	char file[MAXPATHLEN];
d981 3
a983 1
	while (p && *p && isspace(*p))
d992 1
a992 1
	while (p && *p && !isspace(*p))
d1002 1
a1002 1
		if (!isdigit(*string++))
d1011 1
a1011 1
	char fname[MAXPATHLEN], *flog, *p, *rb = NULL;
d1028 1
a1028 1
		err(1, "strdup");
a1045 1
#ifdef QUAD_OFF_T
a1046 3
#else
	if (fscanf(fp, "%ld\n", &osize) != 1) {
#endif	/* QUAD_OFF_T */
d1059 1
a1059 1
		rb = (char *) malloc(sb.st_size - osize);
d1061 1
a1061 1
			err(1, "malloc");
a1075 2
		
		/* Send message. */
d1078 2
a1079 1
		fp = openmail();
d1081 1
a1081 1
			warn("openmail");
d1084 1
a1098 1
#ifdef QUAD_OFF_T
a1099 3
#else
	fprintf(fp, "%ld\n", (long)sb.st_size);
#endif	/* QUAD_OFF_T */
d1104 1
a1104 2
	if (rb != NULL)
		free(rb);
d1108 1
a1108 14
FILE *
openmail(void)
{
	char *cmdbuf = NULL;
	FILE *ret;

	if (asprintf(&cmdbuf, "%s -t", SENDMAIL) != -1) {
		ret = popen(cmdbuf, "w");
		free(cmdbuf);
		return (ret);
	}
	return (NULL);
}

d1213 2
a1214 1
		if (l < 0 || l >= INT_MAX || (*t != '\0' && !isspace(*t)))
d1324 1
a1324 1
			if (tolower(*s) == 'l') {
d1335 2
d1346 1
a1346 1
		if (*t == '\0' || isspace(*t))
d1355 1
a1355 1
 * Move a file using rename(2) is possible and copying if not.
d1391 2
a1393 2
	if ((fclose(dst)) != 0)
		err(1, "can't fclose %s", from);
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.82 2004/09/14 22:25:33 deraadt Exp $	*/
d75 1
a75 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.82 2004/09/14 22:25:33 deraadt Exp $";
a184 1
void	rotate(struct conf_entry *, const char *);
d282 1
a282 2
		if ((p->flags & CE_COMPACT) && (p->flags & CE_ROTATED) &&
		    p->numlogs > 0)
d752 1
a752 1
rotate(struct conf_entry *ent, const char *oldlog)
d754 10
a763 2
	char file1[MAXPATHLEN], file2[MAXPATHLEN], *suffix;
	int numdays = ent->numlogs;
a802 17
}

void
dotrim(struct conf_entry *ent)
{
	char file1[MAXPATHLEN], file2[MAXPATHLEN], oldlog[MAXPATHLEN];
	int fd;

	/* Is there a separate backup dir? */
	if (ent->backdir != NULL)
		snprintf(oldlog, sizeof(oldlog), "%s/%s", ent->backdir,
		    ent->logbase);
	else
		strlcpy(oldlog, ent->log, sizeof(oldlog));

	if (ent->numlogs > 0)
		rotate(ent, oldlog);
d804 1
a804 1
		(void)log_trim(ent->log);
a1077 1
/* ARGSUSED */
@


1.1.1.3
log
@time to update the logrotating utility
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.108 2017/07/24 12:57:01 jca Exp $	*/
d74 22
a95 6
#define CONF "/etc/newsyslog.conf"
#define PIDFILE "/var/run/syslog.pid"
#define COMPRESS "/usr/bin/gzip"
#define COMPRESS_POSTFIX ".gz"
#define STATS_DIR "/var/run"
#define SENDMAIL "/usr/sbin/sendmail"
d97 1
a97 2
#include <sys/param.h>	/* DEV_BSIZE */
#include <sys/queue.h>
d124 1
a124 1
#define	MIN_PID		2		/* Don't touch pids lower than this */
d145 1
a145 1
	TAILQ_ENTRY(conf_entry) next;
a146 1
TAILQ_HEAD(entrylist, conf_entry);
d160 2
a161 2
char	hostname[HOST_NAME_MAX+1]; /* Hostname */
char	daytime[33];		/* timenow in human readable form */
d164 1
d177 2
a178 1
int	parse_file(struct entrylist *, int *);
d194 1
a194 2
	struct entrylist config, runlist;
	struct conf_entry *p, *q, *tmp;
d196 1
a196 1
	int status, listlen, ret;
d198 1
a198 1

d206 2
a207 7
	TAILQ_INIT(&config);
	TAILQ_INIT(&runlist);

	ret = parse_file(&config, &listlen);
	if (argc == 0)
		TAILQ_CONCAT(&runlist, &config, next);
	else {
d209 1
d212 1
a212 1
			TAILQ_FOREACH_SAFE(q, &config, next, tmp)
d214 6
a219 2
					TAILQ_REMOVE(&config, q, next);
					TAILQ_INSERT_TAIL(&runlist, q, next);
d226 1
a226 1
		if (TAILQ_EMPTY(&runlist))
d228 2
d232 1
a232 1
	pidlist = calloc(listlen + 1, sizeof(struct pidinfo));
d234 1
a234 1
		err(1, NULL);
d239 1
a239 1
	TAILQ_FOREACH(q, &runlist, next)
d243 1
a243 2
	pl = pidlist;
	TAILQ_FOREACH(q, &runlist, next) {
d266 1
d282 1
a282 1
	TAILQ_FOREACH(p, &runlist, next) {
d286 3
d294 1
a294 1
	return (ret);
d301 1
a301 1
	int modhours;
d326 1
a326 1
	modhours = age_old_log(ent);
d341 1
a341 1
		DPRINTF(("age (hr): %d [%d] ", modhours, ent->hours));
d347 1
a347 1
	    (ent->hours > 0 && (modhours >= ent->hours || modhours < 0)
d414 2
a415 2
		warnx("warning - could not send SIG%s to PID from pid file %s",
		    sys_signame[signal], pidfile);
a420 3
	struct timeval now;
	struct tm *tm;
	size_t l;
d424 3
a426 6
	gettimeofday(&now, NULL);
	timenow = now.tv_sec;
	tm = gmtime(&now.tv_sec);
	l = strftime(daytime, sizeof(daytime), "%FT%T", tm);
	snprintf(daytime + l, sizeof(daytime) - l, ".%03ldZ",
	    now.tv_usec / 1000);
d441 1
a441 1
			noaction = 1;	/* This implies needroot as off */
d447 1
a447 1
			verbose = 1;
d453 1
a453 1
			monitormode = 1;
d456 1
a456 1
			force = 1;
d477 1
a477 1
 * Parse a configuration file and build a linked list of all the logs
d480 2
a481 2
int
parse_file(struct entrylist *list, int *nentries)
d484 1
a484 1
	struct conf_entry *working;
d488 1
a488 2
	int lineno = 0;
	int ret = 0;
d498 1
a498 4

nextline:
	while (fgets(line, sizeof(line), f) != NULL) {
		lineno++;
d504 13
a516 4
			err(1, NULL);
		working = calloc(1, sizeof(*working));
		if (working == NULL)
			err(1, NULL);
d522 1
a522 1
			err(1, NULL);
d534 2
a535 3
					if ((pwd = getpwnam(q)) == NULL) {
						warnx("%s:%d: unknown user"
						    " %s --> skipping",
a536 3
						ret = 1;
						goto nextline;
					}
d542 1
a542 1

d546 2
a547 3
					if ((grp = getgrnam(q)) == NULL) {
						warnx("%s:%d: unknown group"
						    " %s --> skipping",
a548 3
						ret = 1;
						goto nextline;
					}
d554 1
a554 1

d563 2
a564 6
		if (*ep != '\0' || l < 0 || l > ALLPERMS) {
			warnx("%s:%d: bad permissions: %s --> skipping", conf,
			    lineno, q);
			ret = 1;
			goto nextline;
		}
d570 2
a571 6
		if (*ep != '\0' || l < 0 || l >= INT_MAX) {
			warnx("%s:%d: bad number: %s --> skipping", conf,
			    lineno, q);
			ret = 1;
			goto nextline;
		}
d576 1
a576 1
		if (isdigit((unsigned char)*q))
d580 1
a580 1

d585 3
a587 6
		if (l < 0 || l >= INT_MAX) {
			warnx("%s:%d: interval out of range: %s --> skipping",
			    conf, lineno, q);
			ret = 1;
			goto nextline;
		}
d594 2
a595 6
			if (working->trim_at == (time_t) - 1) {
				warnx("%s:%d: bad time: %s --> skipping", conf,
				    lineno, q);
				ret = 1;
				goto nextline;
			}
d600 2
a601 6
			if (working->trim_at == (time_t) - 1) {
				warnx("%s:%d: bad time: %s --> skipping", conf,
				    lineno, q);
				ret = 1;
				goto nextline;
			}
d609 2
a610 4
			warnx("%s:%d: bad interval/at: %s --> skipping", conf,
			    lineno, q);
			ret = 1;
			goto nextline;
d636 1
a636 2
					warnx("%s:%d: illegal flag: `%c'"
					    " --> skipping",
d638 1
a638 2
					ret = 1;
					goto nextline;
d655 2
a656 3
				if (strlen(q) >= PATH_MAX) {
					warnx("%s:%d: pathname too long: %s"
					    " --> skipping",
a657 3
					ret = 1;
					goto nextline;
				}
d660 1
a660 1
					err(1, NULL);
d666 1
a666 1
						err(1, NULL);
d680 2
a681 3
				if (i == NSIG) {
					warnx("%s:%d: unknown signal: %s"
					    " --> skipping",
a682 3
					ret = 1;
					goto nextline;
				}
d687 3
a689 4
					err(1, NULL);
			} else {
				warnx("%s:%d: unrecognized field: %s"
				    " --> skipping",
a690 3
				ret = 1;
				goto nextline;
			}
d694 2
a695 3
		if ((working->flags & CE_MONITOR) && working->whom == NULL) {
			warnx("%s:%d: missing monitor notification field"
			    " --> skipping",
a696 3
			ret = 1;
			goto nextline;
		}
d708 1
a708 1
					err(1, NULL);
d721 1
a721 1
		/* Make sure we can't oflow PATH_MAX */
d725 3
a727 6
			    working->numlogs, COMPRESS_POSTFIX) >= PATH_MAX) {
				warnx("%s:%d: pathname too long: %s"
				    " --> skipping", conf, lineno, q);
				ret = 1;
				goto nextline;
			}
d731 3
a733 7
			    >= PATH_MAX) {
				warnx("%s:%d: pathname too long: %s"
				    " --> skipping", conf, lineno,
				    working->log);
				ret = 1;
				goto nextline;
			}
a734 2
		TAILQ_INSERT_TAIL(list, working, next);
		(*nentries)++;
d736 2
d739 1
a739 1
	return (ret);
d756 7
a762 3
	char file1[PATH_MAX], file2[PATH_MAX], *suffix;
	int numdays = ent->numlogs - 1;
	int done = 0;
d764 6
a769 13
	/* Remove old logs */
	do {
		(void)snprintf(file1, sizeof(file1), "%s.%d", oldlog, numdays);
		(void)snprintf(file2, sizeof(file2), "%s.%d%s", oldlog,
		    numdays, COMPRESS_POSTFIX);
		if (noaction) {
			printf("\trm -f %s %s\n", file1, file2);
			done = access(file1, 0) && access(file2, 0);
		} else {
			done = unlink(file1) && unlink(file2);
		}
		numdays++;
	} while (done == 0);
d772 1
a772 1
	for (numdays = ent->numlogs - 2; numdays >= 0; numdays--) {
d802 1
a802 1
	char file1[PATH_MAX], file2[PATH_MAX], oldlog[PATH_MAX];
d875 1
a875 1
	char *base, tmp[PATH_MAX];
d902 1
a902 1
/* Return size in bytes of a file */
d917 1
a917 1
	char file[PATH_MAX];
d941 1
a941 3
	if (p == NULL)
		return(p);
	while (isspace((unsigned char)*p))
d950 1
a950 1
	while (p && *p && !isspace((unsigned char)*p))
d960 1
a960 1
		if (!isdigit((unsigned char)*string++))
d969 1
a969 1
	char fname[PATH_MAX], *flog, *p, *rb = NULL;
d986 1
a986 1
		err(1, NULL);
d1004 1
d1006 3
d1021 1
a1021 1
		rb = malloc(sb.st_size - osize);
d1023 1
a1023 1
			err(1, NULL);
d1038 2
d1042 1
a1042 2
		/* Send message. */
		fp = popen(SENDMAIL " -t", "w");
d1044 1
a1044 1
			warn("popen");
a1046 1
		fprintf(fp, "Auto-Submitted: auto-generated\n");
d1061 1
d1063 3
d1070 2
a1071 1
	free(rb);
d1075 14
d1194 1
a1194 2
		if (l < 0 || l >= INT_MAX ||
		    (*t != '\0' && !isspace((unsigned char)*t)))
d1304 1
a1304 1
			if (tolower((unsigned char)*s) == 'l') {
a1314 2
				if (l < tm.tm_mday)
					tm.tm_mon++;
d1324 1
a1324 1
		if (*t == '\0' || isspace((unsigned char)*t))
d1333 1
a1333 1
 * Move a file using rename(2) if possible and copying if not.
d1369 2
a1371 2
	if ((fclose(dst)) != 0)
		err(1, "can't fclose %s", to);
@


