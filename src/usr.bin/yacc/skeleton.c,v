head	1.7;
access;
symbols
	MIRBSD_10:1.4.0.2
	MIRBSD_10_BASE:1.4
	OPENBSD_4_0:1.1.1.3
	MIRBSD_9_BASE:1.3
	MIRBSD_8:1.3.0.2
	MIRBSD_8_BASE:1.3
	cvs-200507211800:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2010.09.02.17.33.12;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004C7FDFE52874A8B9;

1.6
date	2008.07.08.19.24.30;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004873BF016F5F0E4D;

1.5
date	2008.07.08.19.22.00;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004873BE6F1C0004A0;

1.4
date	2006.09.20.21.41.09;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004511B578580E7F04;

1.3
date	2005.11.23.18.04.33;	author tg;	state Exp;
branches;
next	1.2;
commitid	af74384af2ab463;

1.2
date	2005.03.13.18.34.13;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.30.22;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.30.22;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.07.21.21.01.36;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	560042e0092f571e;

1.1.1.3
date	2006.09.20.19.06.51;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	10045119150397FC669;

1.1.1.4
date	2008.07.08.19.18.48;	author tg;	state Exp;
branches;
next	;
commitid	1004873BD926D656BF3;


desc
@@


1.7
log
@• fix pcc warnings
• make __CRAZY=Yes clean
@
text
@/**	$MirOS: src/usr.bin/yacc/skeleton.c,v 1.6 2008/07/08 19:24:30 tg Exp $ */
/*	$OpenBSD: skeleton.c,v 1.29 2008/07/08 15:06:50 otto Exp $	*/
/*	$NetBSD: skeleton.c,v 1.10 1996/03/25 00:36:18 mrg Exp $	*/

/*
 * Copyright (c) 1989 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Robert Paul Corbett.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/cdefs.h>
__SCCSID("@@(#)skeleton.c	5.8 (Berkeley) 4/29/95");
__RCSID("$MirOS: src/usr.bin/yacc/skeleton.c,v 1.6 2008/07/08 19:24:30 tg Exp $");

#include "defs.h"

/*  If the skeleton is changed, the banner should be changed so that	*/
/*  the altered version can be easily distinguished from the original.	*/
/*									*/
/*  The #defines included with the banner are there because they are	*/
/*  useful in subsequent code.  The macros #defined in the header or	*/
/*  the body either are not useful outside of semantic actions or	*/
/*  are conditional.							*/

const char *banner[] =
{
    "#include <stdlib.h>",
    "#include <string.h>",
    "__SCCSID(\"@@(#)yaccpar	1.9 (Berkeley) 02/21/93\");",
    "__RCSID(\"$MirOS: src/usr.bin/yacc/skeleton.c,v 1.6 2008/07/08 19:24:30 tg Exp $\");",
    "__RCSID(\"$miros: src/usr.bin/yacc/skeleton.c,v 1.6 2008/07/08 19:24:30 tg Exp $\");",
    "#define YYBYACC 1",
    "#define YYMAJOR 1",
    "#define YYMINOR 9",
    "#define YYLEX yylex()",
    "#define YYEMPTY -1",
    "#define yyclearin (yychar=(YYEMPTY))",
    "#define yyerrok (yyerrflag=0)",
    "#define YYRECOVERING() (yyerrflag!=0)",
    "int",
    "#if defined(__cplusplus) || defined(__STDC__)",
    "yyparse(void);",
    "#else",
    "yyparse();",
    "#endif",
    0
};


const char *tables[] =
{
    "#if defined(__cplusplus) || defined(__STDC__)",
    "extern const short yylhs[];",
    "extern const short yylen[];",
    "extern const short yydefred[];",
    "extern const short yydgoto[];",
    "extern const short yysindex[];",
    "extern const short yyrindex[];",
    "extern const short yygindex[];",
    "extern const short yytable[];",
    "extern const short yycheck[];",
    "#if YYDEBUG",
    "extern const char *const yyname[];",
    "extern const char *const yyrule[];",
    "#endif",
    "#else /* !(defined(__cplusplus) || defined(__STDC__)) */",
    "extern short yylhs[];",
    "extern short yylen[];",
    "extern short yydefred[];",
    "extern short yydgoto[];",
    "extern short yysindex[];",
    "extern short yyrindex[];",
    "extern short yygindex[];",
    "extern short yytable[];",
    "extern short yycheck[];",
    "#if YYDEBUG",
    "extern char *yyname[];",
    "extern char *yyrule[];",
    "#endif /* YYDEBUG */",
    "#endif /* !(defined(__cplusplus) || defined(__STDC__)) */",
    0
};


const char *header[] =
{
    "#ifdef YYSTACKSIZE",
    "#undef YYMAXDEPTH",
    "#define YYMAXDEPTH YYSTACKSIZE",
    "#else",
    "#ifdef YYMAXDEPTH",
    "#define YYSTACKSIZE YYMAXDEPTH",
    "#else",
    "#define YYSTACKSIZE 10000",
    "#define YYMAXDEPTH 10000",
    "#endif",
    "#endif",
    "#define YYINITSTACKSIZE 200",
    "/* LINTUSED */",
    "int yydebug;",
    "int yynerrs;",
    "int yyerrflag;",
    "int yychar;",
    "short *yyssp;",
    "YYSTYPE *yyvsp;",
    "YYSTYPE yyval;",
    "YYSTYPE yylval;",
    "short *yyss;",
    "short *yysslim;",
    "YYSTYPE *yyvs;",
    "int yystacksize;",
    0
};


const char *body[] =
{
    "/* allocate initial stack or double stack size, up to YYMAXDEPTH */",
    "#if defined(__cplusplus) || defined(__STDC__)",
    "static int yygrowstack(void)",
    "#else",
    "static int yygrowstack()",
    "#endif",
    "{",
    "    int newsize, i;",
    "    short *newss;",
    "    YYSTYPE *newvs;",
    "",
    "    if ((newsize = yystacksize) == 0)",
    "        newsize = YYINITSTACKSIZE;",
    "    else if (newsize >= YYMAXDEPTH)",
    "        return -1;",
    "    else if ((newsize *= 2) > YYMAXDEPTH)",
    "        newsize = YYMAXDEPTH;",
    "    i = yyssp - yyss;",
    "#ifdef SIZE_MAX",
    "#define YY_SIZE_MAX SIZE_MAX",
    "#else",
    "#define YY_SIZE_MAX 0xffffffffU",
    "#endif",
    "    if (newsize && YY_SIZE_MAX / newsize < sizeof *newss)",
    "        goto bail;",
    "    newss = yyss ? (short *)realloc(yyss, newsize * sizeof *newss) :",
    "      (short *)malloc(newsize * sizeof *newss); /* overflow check above */",
    "    if (newss == NULL)",
    "        goto bail;",
    "    yyss = newss;",
    "    yyssp = newss + i;",
    "    if (newsize && YY_SIZE_MAX / newsize < sizeof *newvs)",
    "        goto bail;",
    "    newvs = yyvs ? (YYSTYPE *)realloc(yyvs, newsize * sizeof *newvs) :",
    "      (YYSTYPE *)malloc(newsize * sizeof *newvs); /* overflow check above */",
    "    if (newvs == NULL)",
    "        goto bail;",
    "    yyvs = newvs;",
    "    yyvsp = newvs + i;",
    "    yystacksize = newsize;",
    "    yysslim = yyss + newsize - 1;",
    "    return 0;",
    "bail:",
    "    if (yyss)",
    "            free(yyss);",
    "    if (yyvs)",
    "            free(yyvs);",
    "    yyss = yyssp = NULL;",
    "    yyvs = yyvsp = NULL;",
    "    yystacksize = 0;",
    "    return -1;",
    "}",
    "",
    "#define YYABORT goto yyabort",
    "#define YYREJECT goto yyabort",
    "#define YYACCEPT goto yyaccept",
    "#define YYERROR goto yyerrlab",
    "int",
    "#if defined(__cplusplus) || defined(__STDC__)",
    "yyparse(void)",
    "#else",
    "yyparse()",
    "#endif",
    "{",
    "    int yym, yyn, yystate;",
    "#if YYDEBUG",
    "#if defined(__cplusplus) || defined(__STDC__)",
    "    const char *yys;",
    "#else /* !(defined(__cplusplus) || defined(__STDC__)) */",
    "    char *yys;",
    "#endif /* !(defined(__cplusplus) || defined(__STDC__)) */",
    "",
    "    if ((yys = getenv(\"YYDEBUG\")))",
    "    {",
    "        yyn = *yys;",
    "        if (yyn >= '0' && yyn <= '9')",
    "            yydebug = yyn - '0';",
    "    }",
    "#endif /* YYDEBUG */",
    "",
    "    yynerrs = 0;",
    "    yyerrflag = 0;",
    "    yychar = (-1);",
    "",
    "    if (yyss == NULL && yygrowstack()) goto yyoverflow;",
    "    yyssp = yyss;",
    "    yyvsp = yyvs;",
    "    *yyssp = 0;",
    "    yystate = 0;",
    "",
    "yyloop:",
    "    if ((yyn = yydefred[yystate]) != 0) goto yyreduce;",
    "    if (yychar < 0)",
    "    {",
    "        if ((yychar = yylex()) < 0) yychar = 0;",
    "#if YYDEBUG",
    "        if (yydebug)",
    "        {",
    "            yys = 0;",
    "            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",
    "            if (!yys) yys = \"illegal-symbol\";",
    "            printf(\"%sdebug: state %d, reading %d (%s)\\n\",",
    "                    YYPREFIX, yystate, yychar, yys);",
    "        }",
    "#endif",
    "    }",
    "    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&",
    "            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)",
    "    {",
    "#if YYDEBUG",
    "        if (yydebug)",
    "            printf(\"%sdebug: state %d, shifting to state %d\\n\",",
    "                    YYPREFIX, yystate, yytable[yyn]);",
    "#endif",
    "        if (yyssp >= yysslim && yygrowstack())",
    "        {",
    "            goto yyoverflow;",
    "        }",
    "        yystate = *++yyssp = yytable[yyn];",
    "        *++yyvsp = yylval;",
    "        yychar = (-1);",
    "        if (yyerrflag > 0)  --yyerrflag;",
    "        goto yyloop;",
    "    }",
    "    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&",
    "            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)",
    "    {",
    "        yyn = yytable[yyn];",
    "        goto yyreduce;",
    "    }",
    "    if (yyerrflag) goto yyinrecovery;",
    "#if defined(lint) || defined(__GNUC__)",
    "    goto yynewerror;",
    "#endif",
    "yynewerror:",
    "    yyerror(\"syntax error\");",
    "#if defined(lint) || defined(__GNUC__)",
    "    goto yyerrlab;",
    "#endif",
    "yyerrlab:",
    "    ++yynerrs;",
    "yyinrecovery:",
    "    if (yyerrflag < 3)",
    "    {",
    "        yyerrflag = 3;",
    "        for (;;)",
    "        {",
    "            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&",
    "                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)",
    "            {",
    "#if YYDEBUG",
    "                if (yydebug)",
    "                    printf(\"%sdebug: state %d, error recovery shifting\\",
    " to state %d\\n\", YYPREFIX, *yyssp, yytable[yyn]);",
    "#endif",
    "                if (yyssp >= yysslim && yygrowstack())",
    "                {",
    "                    goto yyoverflow;",
    "                }",
    "                yystate = *++yyssp = yytable[yyn];",
    "                *++yyvsp = yylval;",
    "                goto yyloop;",
    "            }",
    "            else",
    "            {",
    "#if YYDEBUG",
    "                if (yydebug)",
    "                    printf(\"%sdebug: error recovery discarding state %d\
\\n\",",
    "                            YYPREFIX, *yyssp);",
    "#endif",
    "                if (yyssp <= yyss) goto yyabort;",
    "                --yyssp;",
    "                --yyvsp;",
    "            }",
    "        }",
    "    }",
    "    else",
    "    {",
    "        if (yychar == 0) goto yyabort;",
    "#if YYDEBUG",
    "        if (yydebug)",
    "        {",
    "            yys = 0;",
    "            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",
    "            if (!yys) yys = \"illegal-symbol\";",
    "            printf(\"%sdebug: state %d, error recovery discards token %d\
 (%s)\\n\",",
    "                    YYPREFIX, yystate, yychar, yys);",
    "        }",
    "#endif",
    "        yychar = (-1);",
    "        goto yyloop;",
    "    }",
    "yyreduce:",
    "#if YYDEBUG",
    "    if (yydebug)",
    "        printf(\"%sdebug: state %d, reducing by rule %d (%s)\\n\",",
    "                YYPREFIX, yystate, yyn, yyrule[yyn]);",
    "#endif",
    "    yym = yylen[yyn];",
    "    if (yym)",
    "        yyval = yyvsp[1-yym];",
    "    else",
    "        memset(&yyval, 0, sizeof yyval);",
    "    switch (yyn)",
    "    {",
    0
};


const char *trailer[] =
{
    "    }",
    "    yyssp -= yym;",
    "    yystate = *yyssp;",
    "    yyvsp -= yym;",
    "    yym = yylhs[yyn];",
    "    if (yystate == 0 && yym == 0)",
    "    {",
    "#if YYDEBUG",
    "        if (yydebug)",
    "            printf(\"%sdebug: after reduction, shifting from state 0 to\\",
    " state %d\\n\", YYPREFIX, YYFINAL);",
    "#endif",
    "        yystate = YYFINAL;",
    "        *++yyssp = YYFINAL;",
    "        *++yyvsp = yyval;",
    "        if (yychar < 0)",
    "        {",
    "            if ((yychar = yylex()) < 0) yychar = 0;",
    "#if YYDEBUG",
    "            if (yydebug)",
    "            {",
    "                yys = 0;",
    "                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",
    "                if (!yys) yys = \"illegal-symbol\";",
    "                printf(\"%sdebug: state %d, reading %d (%s)\\n\",",
    "                        YYPREFIX, YYFINAL, yychar, yys);",
    "            }",
    "#endif",
    "        }",
    "        if (yychar == 0) goto yyaccept;",
    "        goto yyloop;",
    "    }",
    "    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&",
    "            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)",
    "        yystate = yytable[yyn];",
    "    else",
    "        yystate = yydgoto[yym];",
/* assert: int yystate is now in the range of short */
    "#if YYDEBUG",
    "    if (yydebug)",
    "        printf(\"%sdebug: after reduction, shifting from state %d \\",
    "to state %d\\n\", YYPREFIX, *yyssp, yystate);",
    "#endif",
    "    if (yyssp >= yysslim && yygrowstack())",
    "    {",
    "        goto yyoverflow;",
    "    }",
    "    *++yyssp = (short)yystate;",	/* cast to make pcc happy */
    "    *++yyvsp = yyval;",
    "    goto yyloop;",
    "yyoverflow:",
    "    yyerror(\"yacc stack overflow\");",
    "yyabort:",
    "    if (yyss)",
    "            free(yyss);",
    "    if (yyvs)",
    "            free(yyvs);",
    "    yyss = yyssp = NULL;",
    "    yyvs = yyvsp = NULL;",
    "    yystacksize = 0;",
    "    return (1);",
    "yyaccept:",
    "    if (yyss)",
    "            free(yyss);",
    "    if (yyvs)",
    "            free(yyvs);",
    "    yyss = yyssp = NULL;",
    "    yyvs = yyvsp = NULL;",
    "    yystacksize = 0;",
    "    return (0);",
    "}",
    0
};


void
write_section(const char *section[])
{
    int c;
    int i;
    const char *s;
    FILE *f;

    f = code_file;
    for (i = 0; (s = section[i]); ++i)
    {
	++outline;
	while ((c = *s))
	{
	    putc(c, f);
	    ++s;
	}
	putc('\n', f);
    }
}
@


1.6
log
@improve rcsid stuff
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.bin/yacc/skeleton.c,v 1.5 2008/07/08 19:22:00 tg Exp $ */
d39 1
a39 1
__RCSID("$MirOS: src/usr.bin/yacc/skeleton.c,v 1.5 2008/07/08 19:22:00 tg Exp $");
d51 1
a51 1
char *banner[] =
d76 1
a76 1
char *tables[] =
d111 1
a111 1
char *header[] =
d142 1
a142 1
char *body[] =
d231 2
a232 1
    "    *yyssp = yystate = 0;",
d262 1
a262 1
    "        *++yyssp = yystate = yytable[yyn];",
d303 1
a303 1
    "                *++yyssp = yystate = yytable[yyn];",
d355 1
a355 1
char *trailer[] =
d394 1
d404 1
a404 1
    "    *++yyssp = yystate;",
d433 1
a433 1
write_section(char *section[])
d437 1
a437 1
    char *s;
@


1.5
log
@merge
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.bin/yacc/skeleton.c,v 1.4 2006/09/20 21:41:09 tg Exp $ */
d39 1
a39 1
__RCSID("$MirOS: src/usr.bin/yacc/skeleton.c,v 1.4 2006/09/20 21:41:09 tg Exp $");
a52 1
    "/* From $MirOS: src/usr.bin/yacc/skeleton.c,v 1.4 2006/09/20 21:41:09 tg Exp $ */",
d56 2
a57 1
    "__RCSID(\"$miros: src/usr.bin/yacc/skeleton.c,v 1.5 2008/07/08 19:22:00 tg Exp $\");",
@


1.4
log
@finish merging
@
text
@d1 2
a2 2
/**	$MirOS: src/usr.bin/yacc/skeleton.c,v 1.3 2005/11/23 18:04:33 tg Exp $ */
/*	$OpenBSD: skeleton.c,v 1.26 2006/04/20 16:51:32 deraadt Exp $	*/
d39 1
a39 1
__RCSID("$MirOS: src/usr.bin/yacc/skeleton.c,v 1.3 2005/11/23 18:04:33 tg Exp $");
d53 1
a53 1
    "/* From $MirOS$ */",
d55 1
d57 1
a57 1
    "__RCSID(\"$MirOS: src/usr.bin/yacc/skeleton.c,v 1.3 2005/11/23 18:04:33 tg Exp $\");",
d162 7
d170 1
a170 1
    "      (short *)malloc(newsize * sizeof *newss);",
d175 2
d178 1
a178 1
    "      (YYSTYPE *)malloc(newsize * sizeof *newvs);",
d344 4
a347 1
    "    yyval = yyvsp[1-yym];",
@


1.3
log
@fastmerge remainder of src/usr.bin
@
text
@d1 2
a2 2
/**	$MirOS: src/usr.bin/yacc/skeleton.c,v 1.2 2005/03/13 18:34:13 tg Exp $ */
/*	$OpenBSD: skeleton.c,v 1.24 2005/06/10 16:40:45 pvalchev Exp $	*/
d39 1
a39 1
__RCSID("$MirOS: src/usr.bin/yacc/skeleton.c,v 1.2 2005/03/13 18:34:13 tg Exp $");
a42 4
/*  The definition of yysccsid in the banner should be replaced with	*/
/*  a #pragma ident directive if the target C compiler supports		*/
/*  #pragma ident directives.						*/
/*									*/
d53 1
d56 1
a56 1
    "__RCSID(\"$MirOS: src/usr.bin/yacc/skeleton.c,v 1.2 2005/03/13 18:34:13 tg Exp $\");",
d124 1
@


1.2
log
@merge src/usr.bin
@
text
@d1 2
a2 2
/**	$MirOS$ */
/*	$OpenBSD: skeleton.c,v 1.23 2004/03/12 13:39:50 henning Exp $	*/
d39 1
a39 1
__RCSID("$MirOS$");
d57 1
a57 1
    "#include <sys/cdefs.h>",
d59 1
a59 2
    "__RCSID(\"$MirOS$\");",
    "#include <stdlib.h>",
d431 1
a431 1
	while (c = *s)
@


1.1
log
@Initial revision
@
text
@d1 1
d37 3
a39 7
#ifndef lint
#if 0
static char sccsid[] = "@@(#)skeleton.c	5.8 (Berkeley) 4/29/95";
#else
static char rcsid[] = "$NetBSD: skeleton.c,v 1.10 1996/03/25 00:36:18 mrg Exp $";
#endif
#endif /* not lint */
d57 3
a59 8
    "#ifndef lint",
    "/*static char yysccsid[] = \"from: @@(#)yaccpar	1.9 (Berkeley) 02/21/93\";*/",
    "static char yyrcsid[]",
    "#if __GNUC__ >= 2",
    "  __attribute__ ((unused))",
    "#endif /* __GNUC__ >= 2 */",
    "  = \"$OpenBSD: skeleton.c,v 1.23 2004/03/12 13:39:50 henning Exp $\";",
    "#endif",
d69 6
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.24 2005/06/10 16:40:45 pvalchev Exp $	*/
d66 1
a66 1
    "  = \"$OpenBSD: skeleton.c,v 1.24 2005/06/10 16:40:45 pvalchev Exp $\";",
d434 1
a434 1
	while ((c = *s))
@


1.1.1.3
log
@import a few security-wise relevant changes right now
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.26 2006/04/20 16:51:32 deraadt Exp $	*/
d66 1
a66 1
    "  = \"$OpenBSD: skeleton.c,v 1.26 2006/04/20 16:51:32 deraadt Exp $\";",
a129 1
    "/* LINTUSED */",
@


1.1.1.4
log
@sync with obsd; this is really funny… might improve stability of some apps:
http://undeadly.org/cgi?action=article&sid=20080708155228&mode=expanded
@
text
@d1 1
a1 1
/*	$OpenBSD: skeleton.c,v 1.29 2008/07/08 15:06:50 otto Exp $	*/
d66 1
a66 1
    "  = \"$OpenBSD: skeleton.c,v 1.29 2008/07/08 15:06:50 otto Exp $\";",
a68 1
    "#include <string.h>",
a166 7
    "#ifdef SIZE_MAX",
    "#define YY_SIZE_MAX SIZE_MAX",
    "#else",
    "#define YY_SIZE_MAX 0xffffffffU",
    "#endif",
    "    if (newsize && YY_SIZE_MAX / newsize < sizeof *newss)",
    "        goto bail;",
d168 1
a168 1
    "      (short *)malloc(newsize * sizeof *newss); /* overflow check above */",
a172 2
    "    if (newsize && YY_SIZE_MAX / newsize < sizeof *newvs)",
    "        goto bail;",
d174 1
a174 1
    "      (YYSTYPE *)malloc(newsize * sizeof *newvs); /* overflow check above */",
d340 1
a340 4
    "    if (yym)",
    "        yyval = yyvsp[1-yym];",
    "    else",
    "        memset(&yyval, 0, sizeof yyval);",
@


