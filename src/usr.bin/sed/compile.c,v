head	1.3;
access;
symbols
	cvs-201711200100:1.1.1.4
	cvs-201603041800:1.1.1.3
	MIRBSD_10:1.1.1.2.0.4
	MIRBSD_10_BASE:1.1.1.2
	MIRBSD_9_BASE:1.1.1.2
	MIRBSD_8:1.1.1.2.0.2
	MIRBSD_8_BASE:1.1.1.2
	cvs-200507211800:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2017.11.20.01.23.56;	author tg;	state Exp;
branches;
next	1.2;
commitid	1005A122EB84015709A;

1.2
date	2016.03.04.19.42.26;	author tg;	state Exp;
branches;
next	1.1;
commitid	10056D9E53B4077740C;

1.1
date	2005.02.05.17.29.49;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.29.49;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.07.21.21.00.15;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	560042e0092f571e;

1.1.1.3
date	2016.03.04.18.49.12;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	10056D9D8B662032B91;

1.1.1.4
date	2017.11.20.01.07.48;	author tg;	state Exp;
branches;
next	;
commitid	1005A122AFA44AA870F;


desc
@@


1.3
log
@merge; appears to be okay-ish in the testsuite with termwidth = 60;
@
text
@/*	$OpenBSD: compile.c,v 1.42 2017/08/01 18:05:53 martijn Exp $	*/

/*-
 * Copyright (c) 2016
 *	mirabilos <m@@mirbsd.org>
 * Copyright (c) 1992 Diomidis Spinellis.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Diomidis Spinellis of Imperial College, University of London.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <regex.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "defs.h"
#include "extern.h"

__RCSID("$MirOS: src/usr.bin/sed/compile.c,v 1.2 2016/03/04 19:42:26 tg Exp $");

#define LHSZ	128
#define	LHMASK	(LHSZ - 1)
static struct labhash {
	struct	labhash *lh_next;
	u_int	lh_hash;
	struct	s_command *lh_cmd;
	int	lh_ref;
} *labels[LHSZ];

static char	 *compile_addr(char *, struct s_addr *);
static char	 *compile_ccl(char **, char *);
static char	 *compile_delimited(char *, char *, int);
static char	 *compile_flags(char *, struct s_subst *);
static char	 *compile_re(char *, regex_t **);
static char	 *compile_subst(char *, struct s_subst *);
static char	 *compile_text(void);
static char	 *compile_tr(char *, char **);
static struct s_command
		**compile_stream(struct s_command **);
static char	 *duptoeol(char *, const char *, char **);
static void	  enterlabel(struct s_command *);
static struct s_command
		 *findlabel(char *);
static void	  fixuplabel(struct s_command *, struct s_command *);
static void	  uselabel(void);

/*
 * Command specification.  This is used to drive the command parser.
 */
struct s_format {
	char code;				/* Command code */
	int naddr;				/* Number of address args */
	enum e_args args;			/* Argument type */
};

static struct s_format cmd_fmts[] = {
	{'{', 2, GROUP},
	{'}', 0, ENDGROUP},
	{'a', 1, TEXT},
	{'b', 2, BRANCH},
	{'c', 2, TEXT},
	{'d', 2, EMPTY},
	{'D', 2, EMPTY},
	{'g', 2, EMPTY},
	{'G', 2, EMPTY},
	{'h', 2, EMPTY},
	{'H', 2, EMPTY},
	{'i', 1, TEXT},
	{'l', 2, EMPTY},
	{'n', 2, EMPTY},
	{'N', 2, EMPTY},
	{'p', 2, EMPTY},
	{'P', 2, EMPTY},
	{'q', 1, EMPTY},
	{'r', 1, RFILE},
	{'s', 2, SUBST},
	{'t', 2, BRANCH},
	{'w', 2, WFILE},
	{'x', 2, EMPTY},
	{'y', 2, TR},
	{'!', 2, NONSEL},
	{':', 0, LABEL},
	{'#', 0, COMMENT},
	{'=', 1, EMPTY},
	{'\0', 0, COMMENT},
};

/* The compiled program. */
struct s_command *prog;

/*
 * Compile the program into prog.
 * Initialise appends.
 */
void
compile(void)
{
	*compile_stream(&prog) = NULL;
	fixuplabel(prog, NULL);
	uselabel();
	appends = xreallocarray(NULL, appendnum, sizeof(struct s_appends));
	match = xreallocarray(NULL, maxnsub + 1, sizeof(regmatch_t));
}

#define EATSPACE() do {							\
	if (p)								\
		while (isascii((unsigned char)*p) &&			\
		    isspace((unsigned char)*p))				\
			p++;						\
	} while (0)

static struct s_command **
compile_stream(struct s_command **link)
{
	char *p;
	static char *lbuf;	/* To avoid excessive malloc calls */
	static size_t bufsize;
	struct s_command *cmd, *cmd2, *stack;
	struct s_format *fp;
	int naddr;				/* Number of addresses */

	stack = 0;
	for (;;) {
		if ((p = cu_fgets(&lbuf, &bufsize)) == NULL) {
			if (stack != 0)
				error(COMPILE, "unexpected EOF (pending }'s)");
			return (link);
		}

semicolon:	EATSPACE();
		if (*p == '#' || *p == '\0')
			continue;
		if (*p == ';') {
			p++;
			goto semicolon;
		}
		*link = cmd = xmalloc(sizeof(struct s_command));
		link = &cmd->next;
		cmd->nonsel = cmd->inrange = 0;
		/* First parse the addresses */
		naddr = 0;

/* Valid characters to start an address */
#define	addrchar(c)	(strchr("0123456789/\\$", (c)))
		if (addrchar(*p)) {
			naddr++;
			cmd->a1 = xmalloc(sizeof(struct s_addr));
			p = compile_addr(p, cmd->a1);
			EATSPACE();				/* EXTENSION */
			if (*p == ',') {
				p++;
				EATSPACE();			/* EXTENSION */
				naddr++;
				cmd->a2 = xmalloc(sizeof(struct s_addr));
				p = compile_addr(p, cmd->a2);
				EATSPACE();
			} else {
				cmd->a2 = 0;
			}
		} else {
			cmd->a1 = cmd->a2 = 0;
		}

nonsel:		/* Now parse the command */
		if (!*p)
			error(COMPILE, "command expected");
		cmd->code = *p;
		for (fp = cmd_fmts; fp->code; fp++)
			if (fp->code == *p)
				break;
		if (!fp->code)
			error(COMPILE, "invalid command code %c", *p);
		if (naddr > fp->naddr)
			error(COMPILE,
			    "command %c expects up to %d address(es), found %d",
			    *p, fp->naddr, naddr);
		switch (fp->args) {
		case NONSEL:			/* ! */
			p++;
			EATSPACE();
			cmd->nonsel = 1;
			goto nonsel;
		case GROUP:			/* { */
			p++;
			EATSPACE();
			cmd->next = stack;
			stack = cmd;
			link = &cmd->u.c;
			if (*p)
				goto semicolon;
			break;
		case ENDGROUP:
			/*
			 * Short-circuit command processing, since end of
			 * group is really just a noop.
			 */
			cmd->nonsel = 1;
			if (stack == 0)
				error(COMPILE, "unexpected }");
			cmd2 = stack;
			stack = cmd2->next;
			cmd2->next = cmd;
			/*FALLTHROUGH*/
		case EMPTY:		/* d D g G h H l n N p P q x = \0 */
			p++;
			EATSPACE();
			if (*p == ';') {
				p++;
				link = &cmd->next;
				goto semicolon;
			}
			if (*p)
				error(COMPILE,
"extra characters at the end of %c command", cmd->code);
			break;
		case TEXT:			/* a c i */
			p++;
			EATSPACE();
			if (*p != '\\')
				error(COMPILE, "command %c expects \\ followed by"
				    " text", cmd->code);
			p++;
			EATSPACE();
			if (*p)
				error(COMPILE, "extra characters after \\ at the"
				    " end of %c command", cmd->code);
			cmd->t = compile_text();
			break;
		case COMMENT:			/* \0 # */
			break;
		case WFILE:			/* w */
			p++;
			EATSPACE();
			if (*p == '\0')
				error(COMPILE, "filename expected");
			cmd->t = duptoeol(p, "w command", NULL);
			if (aflag) {
				cmd->u.fd = -1;
				pledge_wpath = 1;
			}
			else if ((cmd->u.fd = open(p,
			    O_WRONLY|O_APPEND|O_CREAT|O_TRUNC,
			    DEFFILEMODE)) == -1)
				error(FATAL, "%s: %s", p, strerror(errno));
			break;
		case RFILE:			/* r */
			pledge_rpath = 1;
			p++;
			EATSPACE();
			cmd->t = duptoeol(p, "read command", NULL);
			break;
		case BRANCH:			/* b t */
			p++;
			EATSPACE();
			if (*p == '\0')
				cmd->t = NULL;
			else
				cmd->t = duptoeol(p, "branch", &p);
			if (*p == ';') {
				p++;
				goto semicolon;
			}
			break;
		case LABEL:			/* : */
			p++;
			EATSPACE();
			cmd->t = duptoeol(p, "label", &p);
			if (strlen(cmd->t) == 0)
				error(COMPILE, "empty label");
			enterlabel(cmd);
			if (*p == ';') {
				p++;
				goto semicolon;
			}
			break;
		case SUBST:			/* s */
			p++;
			if (*p == '\0' || *p == '\\')
				error(COMPILE, "substitute pattern can not be"
				    " delimited by newline or backslash");
			cmd->u.s = xmalloc(sizeof(struct s_subst));
			p = compile_re(p, &cmd->u.s->re);
			if (p == NULL)
				error(COMPILE, "unterminated substitute pattern");
			--p;
			p = compile_subst(p, cmd->u.s);
			p = compile_flags(p, cmd->u.s);
			EATSPACE();
			if (*p == ';') {
				p++;
				link = &cmd->next;
				goto semicolon;
			}
			break;
		case TR:			/* y */
			p++;
			p = compile_tr(p, (char **)&cmd->u.y);
			EATSPACE();
			if (*p == ';') {
				p++;
				link = &cmd->next;
				goto semicolon;
			}
			if (*p)
				error(COMPILE, "extra text at the end of a"
				    " transform command");
			break;
		}
	}
}

/*
 * Get a delimited string.  P points to the delimeter of the string; d points
 * to a buffer area.  Newline and delimiter escapes are processed; other
 * escapes are ignored.
 *
 * Returns a pointer to the first character after the final delimiter or NULL
 * in the case of a non-terminated string.  The character array d is filled
 * with the processed string.
 */
static char *
compile_delimited(char *p, char *d, int is_tr)
{
	char c;

	c = *p++;
	if (c == '\0')
		return (NULL);
	else if (c == '\\')
		error(COMPILE, "\\ can not be used as a string delimiter");
	else if (c == '\n')
		error(COMPILE, "newline can not be used as a string delimiter");
	while (*p) {
		if (*p == '[' && *p != c) {
			if ((d = compile_ccl(&p, d)) == NULL)
				error(COMPILE, "unbalanced brackets ([])");
			continue;
		} else if (*p == '\\' && p[1] == '[') {
			*d++ = *p++;
		} else if (*p == '\\' && p[1] == c) {
			p++;
		} else if (*p == '\\' && p[1] == 'n') {
			*d++ = '\n';
			p += 2;
			continue;
		} else if (*p == '\\' && p[1] == '\\') {
			if (is_tr)
				p++;
			else
				*d++ = *p++;
		} else if (*p == c) {
			*d = '\0';
			return (p + 1);
		}
		*d++ = *p++;
	}
	return (NULL);
}


/* compile_ccl: expand a POSIX character class */
static char *
compile_ccl(char **sp, char *t)
{
	int c, d;
	char *s = *sp;

	*t++ = *s++;
	if (*s == '^')
		*t++ = *s++;
	if (*s == ']')
		*t++ = *s++;
	for (; *s && (*t = *s) != ']'; s++, t++)
		if (*s == '[' && ((d = *(s+1)) == '.' || d == ':' || d == '=')) {
			*++t = *++s, t++, s++;
			for (c = *s; (*t = *s) != ']' || c != d; s++, t++)
				if ((c = *s) == '\0')
					return NULL;
		} else if (*s == '\\' && s[1] == 'n') {
			*t = '\n';
			s++;
		}
	if (*s == ']') {
		*sp = ++s;
		return (++t);
	} else {
		return (NULL);
	}
}

/*
 * Get a regular expression.  P points to the delimiter of the regular
 * expression; repp points to the address of a regexp pointer.  Newline
 * and delimiter escapes are processed; other escapes are ignored.
 * Returns a pointer to the first character after the final delimiter
 * or NULL in the case of a non terminated regular expression.  The regexp
 * pointer is set to the compiled regular expression.
 * Cflags are passed to regcomp.
 */
static char *
compile_re(char *p, regex_t **repp)
{
	int eval;
	char *re;

	re = xmalloc(strlen(p) + 1); /* strlen(re) <= strlen(p) */
	p = compile_delimited(p, re, 0);
	if (p && strlen(re) == 0) {
		*repp = NULL;
		free(re);
		return (p);
	}
	*repp = xmalloc(sizeof(regex_t));
	if (p && (eval = regcomp(*repp, re, Eflag ? REG_EXTENDED : 0)) != 0)
		error(COMPILE, "RE error: %s", strregerror(eval, *repp));
	if (maxnsub < (*repp)->re_nsub)
		maxnsub = (*repp)->re_nsub;
	free(re);
	return (p);
}

/*
 * Compile the substitution string of a regular expression and set res to
 * point to a saved copy of it.  Nsub is the number of parenthesized regular
 * expressions.
 */
static char *
compile_subst(char *p, struct s_subst *s)
{
	static char *lbuf;
	static size_t bufsize;
	size_t asize, ref, size;
	char c, *text, *op, *sp;
	int sawesc = 0;

	c = *p++;			/* Terminator character */
	if (c == '\0')
		return (NULL);

	s->maxbref = 0;
	s->linenum = linenum;
	text = NULL;
	asize = size = 0;
	do {
		size_t len = ROUNDLEN(strlen(p) + 1);
		if (asize - size < len) {
			do {
				asize += len;
			} while (asize - size < len);
			text = xrealloc(text, asize);
		}
		op = sp = text + size;
		for (; *p; p++) {
			if (*p == '\\' || sawesc) {
				/*
				 * If this is a continuation from the last
				 * buffer, we won't have a character to
				 * skip over.
				 */
				if (sawesc)
					sawesc = 0;
				else
					p++;

				if (*p == '\0') {
					/*
					 * This escaped character is continued
					 * in the next part of the line.  Note
					 * this fact, then cause the loop to
					 * exit w/ normal EOL case and reenter
					 * above with the new buffer.
					 */
					sawesc = 1;
					p--;
					continue;
				} else if (strchr("123456789", *p) != NULL) {
					*sp++ = '\\';
					ref = *p - '0';
					if (s->re != NULL &&
					    ref > s->re->re_nsub)
						error(COMPILE,
"\\%c not defined in the RE", *p);
					if (s->maxbref < ref)
						s->maxbref = ref;
				} else if (*p == '&' || *p == '\\')
					*sp++ = '\\';
			} else if (*p == c) {
				p++;
				*sp++ = '\0';
				size += sp - op;
				s->new = xrealloc(text, size);
				return (p);
			} else if (*p == '\n') {
				error(COMPILE,
"unescaped newline inside substitute pattern");
			}
			*sp++ = *p;
		}
		size += sp - op;
	} while ((p = cu_fgets(&lbuf, &bufsize)));
	error(COMPILE, "unterminated substitute in regular expression");
}

/*
 * Compile the flags of the s command
 */
static char *
compile_flags(char *p, struct s_subst *s)
{
	int gn;			/* True if we have seen g or n */
	long l;
	char wfile[PATH_MAX], *q, *eq;

	s->n = 1;				/* Default */
	s->p = 0;
	s->wfile = NULL;
	s->wfd = -1;
	for (gn = 0;;) {
		EATSPACE();			/* EXTENSION */
		switch (*p) {
		case 'g':
			if (gn)
				error(COMPILE, "more than one number or 'g' in"
				    " substitute flags");
			gn = 1;
			s->n = 0;
			break;
		case '\0':
		case '\n':
		case ';':
			return (p);
		case 'p':
			s->p = 1;
			break;
		case '1': case '2': case '3':
		case '4': case '5': case '6':
		case '7': case '8': case '9':
			if (gn)
				error(COMPILE, "more than one number or 'g' in"
				    " substitute flags");
			gn = 1;
			l = strtol(p, &p, 10);
			if (l <= 0 || l >= INT_MAX)
				error(COMPILE,
				    "number in substitute flags out of range");
			s->n = (int)l;
			continue;
		case 'w':
			p++;
#ifdef HISTORIC_PRACTICE
			if (*p != ' ') {
				warning("space missing before w wfile");
				return (p);
			}
#endif
			EATSPACE();
			q = wfile;
			eq = wfile + sizeof(wfile) - 1;
			while (*p) {
				if (*p == '\n')
					break;
				if (q >= eq)
					error(COMPILE, "wfile too long");
				*q++ = *p++;
			}
			*q = '\0';
			if (q == wfile)
				error(COMPILE, "no wfile specified");
			s->wfile = strdup(wfile);
			if (aflag)
				pledge_wpath = 1;
			else if ((s->wfd = open(wfile,
			    O_WRONLY|O_APPEND|O_CREAT|O_TRUNC,
			    DEFFILEMODE)) == -1)
				error(FATAL, "%s: %s", wfile, strerror(errno));
			return (p);
		default:
			error(COMPILE,
			    "bad flag in substitute command: '%c'", *p);
			break;
		}
		p++;
	}
}

/*
 * Compile a translation set of strings into a lookup table.
 */
static char *
compile_tr(char *p, char **transtab)
{
	int i;
	char *lt, *op, *np;
	char *old = NULL, *new = NULL;

	if (*p == '\0' || *p == '\\')
		error(COMPILE,
"transform pattern can not be delimited by newline or backslash");
	old = xmalloc(strlen(p) + 1);
	p = compile_delimited(p, old, 1);
	if (p == NULL) {
		error(COMPILE, "unterminated transform source string");
		goto bad;
	}
	new = xmalloc(strlen(p) + 1);
	p = compile_delimited(--p, new, 1);
	if (p == NULL) {
		error(COMPILE, "unterminated transform target string");
		goto bad;
	}
	EATSPACE();
	if (strlen(new) != strlen(old)) {
		error(COMPILE, "transform strings are not the same length");
		goto bad;
	}
	/* We assume characters are 8 bits */
	lt = xmalloc(UCHAR_MAX + 1);
	for (i = 0; i <= UCHAR_MAX; i++)
		lt[i] = (char)i;
	for (op = old, np = new; *op; op++, np++)
		lt[(u_char)*op] = *np;
	*transtab = lt;
	free(old);
	free(new);
	return (p);
bad:
	free(old);
	free(new);
	return (NULL);
}

/*
 * Compile the text following an a, c, or i command.
 */
static char *
compile_text(void)
{
	size_t asize, size;
	int esc_nl;
	char *lbuf, *text, *p, *op, *s;
	size_t bufsize;

	lbuf = text = NULL;
	asize = size = 0;
	while ((p = cu_fgets(&lbuf, &bufsize))) {
		size_t len = ROUNDLEN(strlen(p) + 1);
		if (asize - size < len) {
			do {
				asize += len;
			} while (asize - size < len);
			text = xrealloc(text, asize);
		}
		op = s = text + size;
		for (esc_nl = 0; *p != '\0'; p++) {
			if (*p == '\\' && p[1] != '\0' && *++p == '\n')
				esc_nl = 1;
			*s++ = *p;
		}
		size += s - op;
		if (!esc_nl) {
			*s = '\0';
			break;
		}
	}
	free(lbuf);
	text = xrealloc(text, size + 1);
	text[size] = '\0';
	return (text);
}

/*
 * Get an address and return a pointer to the first character after
 * it.  Fill the structure pointed to according to the address.
 */
static char *
compile_addr(char *p, struct s_addr *a)
{
	char *end;

	switch (*p) {
	case '\\':				/* Context address */
		++p;
		/* FALLTHROUGH */
	case '/':				/* Context address */
		p = compile_re(p, &a->u.r);
		if (p == NULL)
			error(COMPILE, "unterminated regular expression");
		a->type = AT_RE;
		return (p);

	case '$':				/* Last line */
		a->type = AT_LAST;
		return (p + 1);
						/* Line number */
	case '0': case '1': case '2': case '3': case '4':
	case '5': case '6': case '7': case '8': case '9':
		a->type = AT_LINE;
		a->u.l = strtoul(p, &end, 10);
		return (end);
	default:
		error(COMPILE, "expected context address");
		return (NULL);
	}
}

/*
 * duptoeol --
 *	Return a copy of all the characters up to \n or \0.
 */
static char *
duptoeol(char *s, const char *ctype, char **semi)
{
	size_t len;
	int ws;
	char *start;

	ws = 0;
	if (semi) {
		for (start = s; *s != '\0' && *s != '\n' && *s != ';'; ++s)
			ws = isspace((unsigned char)*s);
	} else {
		for (start = s; *s != '\0' && *s != '\n'; ++s)
			ws = isspace((unsigned char)*s);
		*s = '\0';
	}
	if (ws)
		warning("whitespace after %s", ctype);
	len = s - start + 1;
	if (semi)
		*semi = s;
	s = xmalloc(len);
	strlcpy(s, start, len);
	return (s);
}

/*
 * Convert goto label names to addresses, and count a and r commands, in
 * the given subset of the script.  Free the memory used by labels in b
 * and t commands (but not by :).
 *
 * TODO: Remove } nodes
 */
static void
fixuplabel(struct s_command *cp, struct s_command *end)
{

	for (; cp != end; cp = cp->next)
		switch (cp->code) {
		case 'a':
		case 'r':
			appendnum++;
			break;
		case 'b':
		case 't':
			/* Resolve branch target. */
			if (cp->t == NULL) {
				cp->u.c = NULL;
				break;
			}
			if ((cp->u.c = findlabel(cp->t)) == NULL)
				error(COMPILE, "undefined label '%s'", cp->t);
			free(cp->t);
			break;
		case '{':
			/* Do interior commands. */
			fixuplabel(cp->u.c, cp->next);
			break;
		}
}

/*
 * Associate the given command label for later lookup.
 */
static void
enterlabel(struct s_command *cp)
{
	struct labhash **lhp, *lh;
	u_char *p;
	u_int h, c;

	for (h = 0, p = (u_char *)cp->t; (c = *p) != 0; p++)
		h = (h << 5) + h + c;
	lhp = &labels[h & LHMASK];
	for (lh = *lhp; lh != NULL; lh = lh->lh_next)
		if (lh->lh_hash == h && strcmp(cp->t, lh->lh_cmd->t) == 0)
			error(COMPILE, "duplicate label '%s'", cp->t);
	lh = xmalloc(sizeof *lh);
	lh->lh_next = *lhp;
	lh->lh_hash = h;
	lh->lh_cmd = cp;
	lh->lh_ref = 0;
	*lhp = lh;
}

/*
 * Find the label contained in the command l in the command linked
 * list cp.  L is excluded from the search.  Return NULL if not found.
 */
static struct s_command *
findlabel(char *name)
{
	struct labhash *lh;
	u_char *p;
	u_int h, c;

	for (h = 0, p = (u_char *)name; (c = *p) != 0; p++)
		h = (h << 5) + h + c;
	for (lh = labels[h & LHMASK]; lh != NULL; lh = lh->lh_next) {
		if (lh->lh_hash == h && strcmp(name, lh->lh_cmd->t) == 0) {
			lh->lh_ref = 1;
			return (lh->lh_cmd);
		}
	}
	return (NULL);
}

/*
 * Warn about any unused labels.  As a side effect, release the label hash
 * table space.
 */
static void
uselabel(void)
{
	struct labhash *lh, *next;
	int i;

	for (i = 0; i < LHSZ; i++) {
		for (lh = labels[i]; lh != NULL; lh = next) {
			next = lh->lh_next;
			if (!lh->lh_ref)
				warning("unused label '%s'",
				    lh->lh_cmd->t);
			free(lh);
		}
	}
}
@


1.2
log
@fullmerge
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.40 2015/10/26 22:24:44 jca Exp $	*/
d53 1
a53 1
__RCSID("$MirOS$");
d271 1
a271 1
			if (aflag)
d273 2
d281 1
a529 1
				/* NOTREACHED */
a535 1
	/* NOTREACHED */
d586 1
a586 1
				error(WARNING, "space missing before w wfile");
d604 3
a606 1
			if (!aflag && (s->wfd = open(wfile,
d761 1
a761 1
		error(WARNING, "whitespace after %s", ctype);
d865 1
a865 1
				error(WARNING, "unused label '%s'",
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.17 2004/02/17 16:13:33 otto Exp $	*/
d4 2
a37 5
#ifndef lint
/* from: static char sccsid[] = "@@(#)compile.c	8.2 (Berkeley) 4/28/95"; */
static char *rcsid = "$OpenBSD: compile.c,v 1.17 2004/02/17 16:13:33 otto Exp $";
#endif /* not lint */

d53 2
d66 1
a66 1
static char	 *compile_delimited(char *, char *);
d74 1
a74 1
static char	 *duptoeol(char *, char *, char **);
d135 2
a136 2
	appends = xmalloc(sizeof(struct s_appends) * appendnum);
	match = xmalloc((maxnsub + 1) * sizeof(regmatch_t));
d141 2
a142 1
		while (*p && isascii(*p) && isspace(*p))		\
d150 2
a151 1
	static char lbuf[_POSIX2_LINE_MAX + 1];	/* To save stack */
d158 1
a158 1
		if ((p = cu_fgets(lbuf, sizeof(lbuf))) == NULL) {
d160 1
a160 1
				err(COMPILE, "unexpected EOF (pending }'s)");
d165 1
a165 1
		if (p && (*p == '#' || *p == '\0'))
d167 4
d191 1
a191 1
			} else
d193 2
a194 1
		} else
d196 1
d200 1
a200 1
			err(COMPILE, "command expected");
d206 1
a206 1
			err(COMPILE, "invalid command code %c", *p);
d208 3
a210 2
			err(COMPILE,
"command %c expects up to %d address(es), found %d", *p, fp->naddr, naddr);
d215 1
a215 1
			cmd->nonsel = ! cmd->nonsel;
d233 1
a233 1
				err(COMPILE, "unexpected }");
d247 1
a247 1
				err(COMPILE,
d254 2
a255 2
				err(COMPILE,
"command %c expects \\ followed by text", cmd->code);
d259 2
a260 2
				err(COMPILE,
"extra characters after \\ at the end of %c command", cmd->code);
d269 1
a269 1
				err(COMPILE, "filename expected");
d273 1
a273 1
			else if ((cmd->u.fd = open(p, 
d276 1
a276 1
				err(FATAL, "%s: %s", p, strerror(errno));
d300 1
a300 1
				err(COMPILE, "empty label");
d310 2
a311 2
				err(COMPILE,
"substitute pattern can not be delimited by newline or backslash");
d315 1
a315 1
				err(COMPILE, "unterminated substitute pattern");
d336 2
a337 2
				err(COMPILE,
"extra text at the end of a transform command");
d353 1
a353 1
compile_delimited(char *p, char *d)
d361 1
a361 1
		err(COMPILE, "\\ can not be used as a string delimiter");
d363 1
a363 1
		err(COMPILE, "newline can not be used as a string delimiter");
d365 1
a365 1
		if (*p == '[') {
d367 1
a367 1
				err(COMPILE, "unbalanced brackets ([])");
d371 1
a371 1
		} else if (*p == '\\' && p[1] == c)
d373 1
a373 1
		else if (*p == '\\' && p[1] == 'n') {
d377 6
a382 3
		} else if (*p == '\\' && p[1] == '\\')
			*d++ = *p++;
		else if (*p == c) {
d410 10
a419 3
		} else if (*s == '\\' && s[1] == 'n')
			    *t = '\n', s++;
	return (*s == ']') ? *sp = ++s, ++t : NULL;
d435 1
a435 1
	char re[_POSIX2_LINE_MAX + 1];
d437 2
a438 1
	p = compile_delimited(p, re);
d441 1
d445 2
a446 2
	if (p && (eval = regcomp(*repp, re, 0)) != 0)
		err(COMPILE, "RE error: %s", strregerror(eval, *repp));
d449 1
d461 3
a463 2
	static char lbuf[_POSIX2_LINE_MAX + 1];
	int asize, ref, size;
d465 1
d473 2
a474 3
	asize = 2 * _POSIX2_LINE_MAX + 1;
	text = xmalloc(asize);
	size = 0;
d476 7
d485 23
a507 3
			if (*p == '\\') {
				p++;
				if (strchr("123456789", *p) != NULL) {
d512 1
a512 1
						err(COMPILE,
d525 1
a525 1
				err(COMPILE,
d532 2
a533 6
		if (asize - size < _POSIX2_LINE_MAX + 1) {
			asize *= 2;
			text = xmalloc(asize);
		}
	} while (cu_fgets(p = lbuf, sizeof(lbuf)));
	err(COMPILE, "unterminated substitute in regular expression");
d545 1
a545 1
	char wfile[_POSIX2_LINE_MAX + 1], *q;
d556 2
a557 2
				err(COMPILE,
"more than one number or 'g' in substitute flags");
d572 2
a573 2
				err(COMPILE,
"more than one number or 'g' in substitute flags");
d577 1
a577 1
				err(COMPILE,
d585 1
a585 1
				err(WARNING, "space missing before w wfile");
d591 1
d595 2
d601 1
a601 1
				err(COMPILE, "no wfile specified");
d606 1
a606 1
				err(FATAL, "%s: %s", wfile, strerror(errno));
d609 1
a609 1
			err(COMPILE,
d625 1
a625 2
	char old[_POSIX2_LINE_MAX + 1];
	char new[_POSIX2_LINE_MAX + 1];
d628 1
a628 1
		err(COMPILE,
d630 2
a631 1
	p = compile_delimited(p, old);
d633 2
a634 2
		err(COMPILE, "unterminated transform source string");
		return (NULL);
d636 2
a637 1
	p = compile_delimited(--p, new);
d639 2
a640 2
		err(COMPILE, "unterminated transform target string");
		return (NULL);
d644 2
a645 2
		err(COMPILE, "transform strings are not the same length");
		return (NULL);
d648 1
a648 1
	lt = xmalloc(UCHAR_MAX);
d654 2
d657 4
d669 15
a683 8
	int asize, esc_nl, size;
	char *text, *p, *op, *s;
	char lbuf[_POSIX2_LINE_MAX + 1];

	asize = 2 * _POSIX2_LINE_MAX + 1;
	text = xmalloc(asize);
	size = 0;
	while (cu_fgets(lbuf, sizeof(lbuf))) {
a684 2
		p = lbuf;
		EATSPACE();
a694 4
		if (asize - size < _POSIX2_LINE_MAX + 1) {
			asize *= 2;
			text = xmalloc(asize);
		}
d696 2
d699 1
a699 1
	return (xrealloc(text, size + 1));
d718 1
a718 1
			err(COMPILE, "unterminated regular expression");
d726 1
a726 1
	case '0': case '1': case '2': case '3': case '4': 
d732 1
a732 1
		err(COMPILE, "expected context address");
d742 1
a742 1
duptoeol(char *s, char *ctype, char **semi)
d751 1
a751 1
			ws = isspace(*s);
d754 1
a754 1
			ws = isspace(*s);
d758 1
a758 1
		err(WARNING, "whitespace after %s", ctype);
d792 1
a792 1
				err(COMPILE2, "undefined label '%s'", cp->t);
d817 1
a817 1
			err(COMPILE2, "duplicate label '%s'", cp->t);
d848 1
a848 1
/* 
d862 1
a862 1
				err(WARNING, "unused label '%s'",
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.21 2005/04/11 07:11:44 deraadt Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: compile.c,v 1.21 2005/04/11 07:11:44 deraadt Exp $";
d265 1
a265 1
			else if ((cmd->u.fd = open(p,
a442 1
	int sawesc = 0;
d456 3
a458 23
			if (*p == '\\' || sawesc) {
				/*
				 * If this is a continuation from the last
				 * buffer, we won't have a character to
				 * skip over.
				 */
				if (sawesc)
					sawesc = 0;
				else
					p++;

				if (*p == '\0') {
					/*
					 * This escaped character is continued
					 * in the next part of the line.  Note
					 * this fact, then cause the loop to
					 * exit w/ normal EOL case and reenter
					 * above with the new buffer.
					 */
					sawesc = 1;
					p--;
					continue;
				} else if (strchr("123456789", *p) != NULL) {
d485 1
a485 1
			text = xrealloc(text, asize);
d599 1
a599 1
	lt = xmalloc(UCHAR_MAX + 1);
d668 1
a668 1
	case '0': case '1': case '2': case '3': case '4':
d790 1
a790 1
/*
@


1.1.1.3
log
@Import newer sed(1) from OpenBSD, hoping for bugfixes
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.40 2015/10/26 22:24:44 jca Exp $	*/
d36 5
d67 1
a67 1
static char	 *compile_delimited(char *, char *, int);
d136 2
a137 2
	appends = xreallocarray(NULL, appendnum, sizeof(struct s_appends));
	match = xreallocarray(NULL, maxnsub + 1, sizeof(regmatch_t));
d142 1
a142 2
		while (isascii((unsigned char)*p) &&			\
		    isspace((unsigned char)*p))				\
d150 1
a150 2
	static char *lbuf;	/* To avoid excessive malloc calls */
	static size_t bufsize;
d157 1
a157 1
		if ((p = cu_fgets(&lbuf, &bufsize)) == NULL) {
d159 1
a159 1
				error(COMPILE, "unexpected EOF (pending }'s)");
d164 1
a164 1
		if (*p == '#' || *p == '\0')
a165 4
		if (*p == ';') {
			p++;
			goto semicolon;
		}
d186 1
a186 1
			} else {
d188 1
a188 2
			}
		} else {
a189 1
		}
d193 1
a193 1
			error(COMPILE, "command expected");
d199 1
a199 1
			error(COMPILE, "invalid command code %c", *p);
d201 2
a202 3
			error(COMPILE,
			    "command %c expects up to %d address(es), found %d",
			    *p, fp->naddr, naddr);
d207 1
a207 1
			cmd->nonsel = 1;
d225 1
a225 1
				error(COMPILE, "unexpected }");
d239 1
a239 1
				error(COMPILE,
d246 2
a247 2
				error(COMPILE, "command %c expects \\ followed by"
				    " text", cmd->code);
d251 2
a252 2
				error(COMPILE, "extra characters after \\ at the"
				    " end of %c command", cmd->code);
d261 1
a261 1
				error(COMPILE, "filename expected");
d268 1
a268 1
				error(FATAL, "%s: %s", p, strerror(errno));
d292 1
a292 1
				error(COMPILE, "empty label");
d302 2
a303 2
				error(COMPILE, "substitute pattern can not be"
				    " delimited by newline or backslash");
d307 1
a307 1
				error(COMPILE, "unterminated substitute pattern");
d328 2
a329 2
				error(COMPILE, "extra text at the end of a"
				    " transform command");
d345 1
a345 1
compile_delimited(char *p, char *d, int is_tr)
d353 1
a353 1
		error(COMPILE, "\\ can not be used as a string delimiter");
d355 1
a355 1
		error(COMPILE, "newline can not be used as a string delimiter");
d357 1
a357 1
		if (*p == '[' && *p != c) {
d359 1
a359 1
				error(COMPILE, "unbalanced brackets ([])");
d363 1
a363 1
		} else if (*p == '\\' && p[1] == c) {
d365 1
a365 1
		} else if (*p == '\\' && p[1] == 'n') {
d369 3
a371 6
		} else if (*p == '\\' && p[1] == '\\') {
			if (is_tr)
				p++;
			else
				*d++ = *p++;
		} else if (*p == c) {
d399 3
a401 10
		} else if (*s == '\\' && s[1] == 'n') {
			*t = '\n';
			s++;
		}
	if (*s == ']') {
		*sp = ++s;
		return (++t);
	} else {
		return (NULL);
	}
d417 1
a417 1
	char *re;
d419 1
a419 2
	re = xmalloc(strlen(p) + 1); /* strlen(re) <= strlen(p) */
	p = compile_delimited(p, re, 0);
a421 1
		free(re);
d425 2
a426 2
	if (p && (eval = regcomp(*repp, re, Eflag ? REG_EXTENDED : 0)) != 0)
		error(COMPILE, "RE error: %s", strregerror(eval, *repp));
a428 1
	free(re);
d440 1
a440 2
	static char *lbuf;
	static size_t bufsize;
d451 3
a453 2
	text = NULL;
	asize = size = 0;
a454 7
		size_t len = ROUNDLEN(strlen(p) + 1);
		if (asize - size < len) {
			do {
				asize += len;
			} while (asize - size < len);
			text = xrealloc(text, asize);
		}
d484 1
a484 1
						error(COMPILE,
d497 1
a497 1
				error(COMPILE,
d504 6
a509 2
	} while ((p = cu_fgets(&lbuf, &bufsize)));
	error(COMPILE, "unterminated substitute in regular expression");
d521 1
a521 1
	char wfile[PATH_MAX], *q, *eq;
d532 2
a533 2
				error(COMPILE, "more than one number or 'g' in"
				    " substitute flags");
d548 2
a549 2
				error(COMPILE, "more than one number or 'g' in"
				    " substitute flags");
d553 1
a553 1
				error(COMPILE,
d561 1
a561 1
				error(WARNING, "space missing before w wfile");
a566 1
			eq = wfile + sizeof(wfile) - 1;
a569 2
				if (q >= eq)
					error(COMPILE, "wfile too long");
d574 1
a574 1
				error(COMPILE, "no wfile specified");
d579 1
a579 1
				error(FATAL, "%s: %s", wfile, strerror(errno));
d582 1
a582 1
			error(COMPILE,
d598 2
a599 1
	char *old = NULL, *new = NULL;
d602 1
a602 1
		error(COMPILE,
d604 1
a604 2
	old = xmalloc(strlen(p) + 1);
	p = compile_delimited(p, old, 1);
d606 2
a607 2
		error(COMPILE, "unterminated transform source string");
		goto bad;
d609 1
a609 2
	new = xmalloc(strlen(p) + 1);
	p = compile_delimited(--p, new, 1);
d611 2
a612 2
		error(COMPILE, "unterminated transform target string");
		goto bad;
d616 2
a617 2
		error(COMPILE, "transform strings are not the same length");
		goto bad;
a625 2
	free(old);
	free(new);
a626 4
bad:
	free(old);
	free(new);
	return (NULL);
d636 2
a637 2
	char *lbuf, *text, *p, *op, *s;
	size_t bufsize;
d639 4
a642 10
	lbuf = text = NULL;
	asize = size = 0;
	while ((p = cu_fgets(&lbuf, &bufsize))) {
		size_t len = ROUNDLEN(strlen(p) + 1);
		if (asize - size < len) {
			do {
				asize += len;
			} while (asize - size < len);
			text = xrealloc(text, asize);
		}
d644 2
d656 4
a660 2
	free(lbuf);
	text = xrealloc(text, size + 1);
d662 1
a662 1
	return (text);
d681 1
a681 1
			error(COMPILE, "unterminated regular expression");
d695 1
a695 1
		error(COMPILE, "expected context address");
d714 1
a714 1
			ws = isspace((unsigned char)*s);
d717 1
a717 1
			ws = isspace((unsigned char)*s);
d721 1
a721 1
		error(WARNING, "whitespace after %s", ctype);
d755 1
a755 1
				error(COMPILE, "undefined label '%s'", cp->t);
d780 1
a780 1
			error(COMPILE, "duplicate label '%s'", cp->t);
d825 1
a825 1
				error(WARNING, "unused label '%s'",
@


1.1.1.4
log
@update sed(1) from OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: compile.c,v 1.42 2017/08/01 18:05:53 martijn Exp $	*/
d267 1
a267 1
			if (aflag) {
a268 2
				pledge_wpath = 1;
			}
a274 1
			pledge_rpath = 1;
d523 1
d530 1
d581 1
a581 1
				warning("space missing before w wfile");
d599 1
a599 3
			if (aflag)
				pledge_wpath = 1;
			else if ((s->wfd = open(wfile,
d753 1
a753 1
		warning("whitespace after %s", ctype);
d857 1
a857 1
				warning("unused label '%s'",
@


