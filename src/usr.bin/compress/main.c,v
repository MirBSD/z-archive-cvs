head	1.14;
access;
symbols
	MIRBSD_10:1.11.0.2
	MIRBSD_10_BASE:1.11
	cvs-200704292000:1.1.1.5
	MIRBSD_9_BASE:1.9
	MIRBSD_8:1.7.0.2
	MIRBSD_8_BASE:1.7
	cvs-200507211800:1.1.1.4
	cvs-200504291700:1.1.1.3
	cvs-200504141130:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2012.08.25.08.12.26;	author tg;	state Exp;
branches;
next	1.13;
commitid	1005038890214015551;

1.13
date	2012.08.25.08.11.11;	author tg;	state Exp;
branches;
next	1.12;
commitid	100503888B748A08C18;

1.12
date	2009.10.27.19.27.15;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004AE749AA68A87F69;

1.11
date	2007.04.29.21.24.44;	author tg;	state Exp;
branches;
next	1.10;
commitid	10046350D16540EBAE7;

1.10
date	2006.07.05.21.35.14;	author tg;	state Exp;
branches;
next	1.9;
commitid	10044AC30A322041A5A;

1.9
date	2006.06.23.16.35.22;	author tg;	state Exp;
branches;
next	1.8;
commitid	100449C175633C23084;

1.8
date	2006.05.29.18.28.03;	author tg;	state Exp;
branches;
next	1.7;
commitid	100447B3D26129375B0;

1.7
date	2005.11.24.11.53.21;	author tg;	state Exp;
branches;
next	1.6;
commitid	2c004385a9a8211d;

1.6
date	2005.11.23.17.08.49;	author tg;	state Exp;
branches;
next	1.5;
commitid	7d454384a217581b;

1.5
date	2005.11.16.22.10.56;	author tg;	state Exp;
branches;
next	1.4;
commitid	50fc437bae818bf3;

1.4
date	2005.04.29.18.35.07;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2005.04.14.11.46.45;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.13.18.32.49;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.29.26;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.29.26;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.14.11.35.39;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.04.29.17.06.00;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2005.07.21.20.59.04;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	560042e0092f571e;

1.1.1.5
date	2007.04.29.20.07.00;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	1004634FAED5BC54DF0;

1.1.1.6
date	2009.10.27.19.19.38;	author tg;	state Exp;
branches;
next	;
commitid	1004AE747D77105067E;


desc
@@


1.14
log
@kill redundant newline
@
text
@/*	$OpenBSD: main.c,v 1.75 2009/04/18 18:21:54 naddy Exp $	*/

#include <sys/cdefs.h>

__RCSID("$MirOS: src/usr.bin/compress/main.c,v 1.12 2009/10/27 19:27:15 tg Exp $");

#ifndef SMALL
__COPYRIGHT("@@(#) Copyright (c) 1992, 1993\n\
	The Regents of the University of California.  All rights reserved.\n"
"Copyright (c) 1997-2002 Michael Shalayeff\n");

__IDSTRING(licence,
" Redistribution and use in source and binary forms, with or without\n"
" modification, are permitted provided that the following conditions\n"
" are met:\n"
" 1. Redistributions of source code must retain the above copyright\n"
"    notice, this list of conditions and the following disclaimer.\n"
" 2. Redistributions in binary form must reproduce the above copyright\n"
"    notice, this list of conditions and the following disclaimer in the\n"
"    documentation and/or other materials provided with the distribution.\n"
" 3. Neither the name of the University nor the names of its contributors\n"
"    may be used to endorse or promote products derived from this software\n"
"    without specific prior written permission.\n"
"\n"
" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n"
" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n"
" OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n"
" IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,\n"
" INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n"
" (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n"
" SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n"
" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n"
" STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n"
" IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n"
" THE POSSIBILITY OF SUCH DAMAGE.\n");
#endif /* SMALL */

#include <sys/param.h>
#include <sys/time.h>
#include <sys/stat.h>

#include <getopt.h>
#include <err.h>
#include <errno.h>
#include <fts.h>
#include <libgen.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <paths.h>
#include "compress.h"

#define min(a,b) ((a) < (b)? (a) : (b))

int cat, decomp, pipin, force, verbose, testmode, list, recurse, storename;
extern char *__progname;

const struct compressor {
	const char *name;
	const char *suffix;
	const u_char *magic;
	void *(*open)(int, const char *, char *, int, u_int32_t, int);
	int (*read)(void *, char *, int);
	int (*write)(void *, const char *, int);
	int (*close)(void *, struct z_info *, const char *, struct stat *);
} c_table[] = {
#define M_DEFLATE (&c_table[0])
  { "deflate", ".gz", (const u_char *)"\037\213",
    gz_open, gz_read, gz_write, gz_close },
#define M_COMPRESS (&c_table[1])
#ifndef SMALL
  { "compress", ".Z", (const u_char *)"\037\235",
    z_open,  zread,   zwrite,   z_close },
#endif /* SMALL */
#if 0
#define M_LZH (&c_table[2])
  { "lzh", ".lzh", (const u_char *)"\037\240",
    lzh_open, lzh_read, lzh_write, lzh_close },
#define M_ZIP (&c_table[3])
  { "zip", ".zip", (const u_char *)"PK",
    zip_open, zip_read, zip_write, zip_close },
#define M_PACK (&c_table[4])
  { "pack", ".pak", (const u_char *)"\037\036",
    pak_open, pak_read, pak_write, pak_close },
#endif
  { NULL, NULL, NULL, NULL, NULL, NULL, NULL }
};

#ifndef SMALL
const struct compressor null_method =
{ "null", ".nul", (const u_char *)"XX",
  null_open, null_read, null_write, null_close };
#endif /* SMALL */

int permission(const char *);
__dead void usage(int);
int docompress(const char *, char *, const struct compressor *,
    int, struct stat *);
int dodecompress(const char *, char *, const struct compressor *,
    int, struct stat *);
const struct compressor *check_method(int);
const char *check_suffix(const char *);
char *set_outfile(const char *, char *, size_t);
void list_stats(const char *, const struct compressor *, struct z_info *);
void verbose_info(const char *, off_t, off_t, u_int32_t);

#define	OPTSTRING	"123456789ab:cdfghlLnNOo:qrS:tvV"
const struct option longopts[] = {
#ifndef SMALL
	{ "ascii",	no_argument,		0, 'a' },
	{ "stdout",	no_argument,		0, 'c' },
	{ "to-stdout",	no_argument,		0, 'c' },
	{ "decompress",	no_argument,		0, 'd' },
	{ "uncompress",	no_argument,		0, 'd' },
	{ "force",	no_argument,		0, 'f' },
	{ "help",	no_argument,		0, 'h' },
	{ "list",	no_argument,		0, 'l' },
	{ "license",	no_argument,		0, 'L' },
	{ "no-name",	no_argument,		0, 'n' },
	{ "name",	no_argument,		0, 'N' },
	{ "quiet",	no_argument,		0, 'q' },
	{ "recursive",	no_argument,		0, 'r' },
	{ "suffix",	required_argument,	0, 'S' },
	{ "test",	no_argument,		0, 't' },
	{ "verbose",	no_argument,		0, 'v' },
	{ "version",	no_argument,		0, 'V' },
	{ "fast",	no_argument,		0, '1' },
	{ "best",	no_argument,		0, '9' },
#endif /* SMALL */
	{ NULL,		0,			0, 0 }
};

int
main(int argc, char *argv[])
{
	FTS *ftsp;
	FTSENT *entry;
	const struct compressor *method;
	const char *s, *infile;
	char *p;
	char outfile[MAXPATHLEN], _infile[MAXPATHLEN], suffix[16];
	char *nargv[512];	/* some estimate based on ARG_MAX */
	int bits, ch, error, i, rc, cflag, oflag;

	bits = cflag = oflag = 0;
	storename = -1;
	p = __progname;
	if (p[0] == 'g') {
		method = M_DEFLATE;
		bits = 6;
		p++;
	} else
#ifdef SMALL
		method = M_DEFLATE;
#else
		method = M_COMPRESS;
#endif /* SMALL */

	decomp = 0;
	if (!strcmp(p, "zcat")) {
		decomp++;
		cflag = 1;
	} else {
		if (p[0] == 'u' && p[1] == 'n') {
			p += 2;
			decomp++;
		}

		if (strcmp(p, "zip") &&
		    strcmp(p, "compress"))
			errx(1, "unknown program name");
	}

	strlcpy(suffix, method->suffix, sizeof(suffix));

	nargv[0] = NULL;
	if (method == M_DEFLATE && (p = getenv("GZIP")) != NULL) {
		char *last;

		nargv[0] = *argv++;
		for (i = 1, (p = strtok_r(p, " ", &last)); p != NULL;
		    (p = strtok_r(NULL, " ", &last)), i++)
			if (i < (int)(sizeof(nargv)/sizeof(nargv[1]) - argc - 1))
				nargv[i] = p;
			else
				errx(1, "GZIP is too long");
		argc += i - 1;
		while ((nargv[i++] = *argv++))
			;
		argv = nargv;
	}

	while ((ch = getopt_long(argc, argv, OPTSTRING, longopts, NULL)) != -1)
		switch(ch) {
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			method = M_DEFLATE;
			strlcpy(suffix, method->suffix, sizeof(suffix));
			bits = ch - '0';
			break;
		case 'a':
			warnx("option -a is ignored on this system");
			break;
		case 'b':
			bits = strtol(optarg, &p, 10);
			/*
			 * POSIX 1002.3 says 9 <= bits <= 14 for portable
			 * apps, but says the implementation may allow
			 * greater.
			 */
			if (*p)
				errx(1, "illegal bit count -- %s", optarg);
			break;
		case 'c':
			cflag = 1;
			break;
		case 'd':		/* Backward compatible. */
			decomp++;
			break;
		case 'f':
			force++;
			break;
		case 'g':
			method = M_DEFLATE;
			strlcpy(suffix, method->suffix, sizeof(suffix));
			bits = 6;
			break;
		case 'l':
			list++;
			testmode = 1;
			decomp++;
			break;
		case 'n':
			storename = 0;
			break;
		case 'N':
			storename = 1;
			break;
#ifndef SMALL
		case 'O':
			method = M_COMPRESS;
			strlcpy(suffix, method->suffix, sizeof(suffix));
			break;
#endif /* SMALL */
		case 'o':
			if (strlcpy(outfile, optarg,
			    sizeof(outfile)) >= sizeof(outfile))
				errx(1, "-o argument is too long");
			oflag = 1;
			break;
		case 'q':
			verbose = -1;
			break;
		case 'S':
			p = suffix;
			if (optarg[0] != '.')
				*p++ = '.';
			strlcpy(p, optarg, sizeof(suffix) - (p - suffix));
			p = optarg;
			break;
		case 't':
			testmode = 1;
			decomp++;
			break;
		case 'V':
			printf("MirOS compress\n");
			exit (0);
		case 'v':
			verbose++;
			break;
#ifndef SMALL
		case 'L':
			printf("BSD licence\n");
			exit (0);
#endif
		case 'r':
			recurse++;
			break;

		case 'h':
			usage(0);
			break;
		default:
			usage(1);
		}
	argc -= optind;
	argv += optind;

	if (argc == 0) {
		if (nargv[0] == NULL)
			argv = nargv;
		/* XXX - make sure we don't oflow nargv in $GZIP case (millert) */
		argv[0] = strdup("-");
		argv[1] = NULL;
	}
	if (oflag && (recurse || argc > 1))
		errx(1, "-o option may only be used with a single input file");

	if ((cat && argc) + testmode + oflag > 1)
		errx(1, "may not mix -o, -c, or -t options");
	/*
	 * By default, when compressing store the original name and timestamp
	 * in the header.  Do not restore these when decompressing unless
	 * the -N option is given.
	 */
	if (storename == -1)
		storename = !decomp;

	if ((ftsp = fts_open(argv, FTS_PHYSICAL|FTS_NOCHDIR, 0)) == NULL)
		err(1, NULL);
	for (rc = SUCCESS; (entry = fts_read(ftsp)) != NULL;) {
		cat = cflag;
		pipin = 0;
		infile = entry->fts_path;
		if (infile[0] == '-' && infile[1] == '\0') {
			infile = "stdin";
			pipin++;
			if (!oflag)
				cat = 1;
		}
		else
			switch (entry->fts_info) {
			case FTS_D:
				if (!recurse) {
					warnx("%s is a directory: ignored",
					    infile);
					fts_set(ftsp, entry, FTS_SKIP);
				}
				continue;
			case FTS_DP:
				continue;
			case FTS_NS:
				/*
				 * If file does not exist and has no suffix,
				 * tack on the default suffix and try that.
				 */
				if (entry->fts_errno == ENOENT) {
					p = strrchr(entry->fts_accpath, '.');
					if ((p == NULL ||
					    strcmp(p, suffix) != 0) &&
					    snprintf(_infile, sizeof(_infile),
					    "%s%s", infile, suffix) <
					    (ssize_t)sizeof(_infile) &&
					    stat(_infile, entry->fts_statp) ==
					    0 &&
					    S_ISREG(entry->fts_statp->st_mode)) {
						infile = _infile;
						break;
					}
				}
			case FTS_ERR:
			case FTS_DNR:
				warnx("%s: %s", infile,
				    strerror(entry->fts_errno));
				rc = rc ? rc : WARNING;
				continue;
			default:
				if (!S_ISREG(entry->fts_statp->st_mode) &&
				    !(S_ISLNK(entry->fts_statp->st_mode) &&
				    cat)) {
					warnx("%s not a regular file%s",
					    infile, cat ? "" : ": unchanged");
					rc = rc ? rc : WARNING;
					continue;
				}
				break;
			}

		if (!decomp && !pipin && (s = check_suffix(infile)) != NULL) {
			warnx("%s already has %s suffix -- unchanged",
			    infile, s);
			rc = rc ? rc : WARNING;
			continue;
		}

		if (!oflag) {
			if (cat)
				strlcpy(outfile, "stdout", sizeof(outfile));
			else if (decomp) {
				if (set_outfile(infile, outfile,
				    sizeof outfile) == NULL) {
					if (!force && !recurse) {
						warnx("%s: unknown suffix: "
						    "ignored", infile);
						rc = rc ? rc : WARNING;
					}
					if (!force)
						continue;
					strlcpy(outfile, infile,
					    sizeof (outfile));
				}
			} else {
				if ((size_t)snprintf(outfile, sizeof(outfile),
				    "%s%s", infile, suffix) >= sizeof(outfile)) {
					warnx("%s%s: name too long",
					    infile, suffix);
					rc = rc ? rc : WARNING;
					continue;
				}
			}
		}

		if (verbose > 0 && !pipin && !list)
			fprintf(stderr, "%s:\t", infile);

		if (!testmode && !strcmp(infile, outfile))
			errx(1, "Would overwrite infile '%s' with outfile, aborting.",
			    infile);

		error = (decomp ? dodecompress : docompress)
		    (infile, outfile, method, bits, entry->fts_statp);

		switch (error) {
		case SUCCESS:
			if (!cat && !testmode) {
				if (!pipin && unlink(infile) && verbose >= 0)
					warn("input: %s", infile);
			}
			break;
		case WARNING:
			rc = rc ? rc : WARNING;
			break;
		default:
			rc = FAILURE;
			break;
		}
	}
	if (list)
		list_stats(NULL, NULL, NULL);

	exit(rc);
}

int
docompress(const char *in, char *out, const struct compressor *method,
    int bits, struct stat *sb)
{
#ifndef SMALL
	u_char buf[Z_BUFSIZE];
	char *name;
	int error, ifd, ofd, flags, oreg;
	void *cookie;
	ssize_t nr;
	u_int32_t mtime;
	struct z_info info;
	struct stat osb;

	mtime = 0;
	flags = oreg = 0;
	error = SUCCESS;
	name = NULL;
	cookie  = NULL;

	if (pipin)
		ifd = dup(STDIN_FILENO);
	else
		ifd = open(in, O_RDONLY);
	if (ifd < 0) {
		if (verbose >= 0)
			warn("%s", in);
		return (FAILURE);
	}

	if (cat)
		ofd = dup(STDOUT_FILENO);
	else {
		if (stat(out, &osb) == 0) {
			oreg = S_ISREG(osb.st_mode);
			if (!force && oreg && !permission(out)) {
				(void) close(ifd);
				return (WARNING);
			}
		}
		ofd = open(out, O_WRONLY|O_CREAT, S_IWUSR);
	}
	if (ofd < 0) {
		if (verbose >= 0)
			warn("%s", out);
		(void) close(ifd);
		return (FAILURE);
	}

	if (method != M_COMPRESS && !force && isatty(ofd)) {
		if (verbose >= 0)
			warnx("%s: won't write compressed data to terminal",
			    out);
		(void) close(ofd);
		(void) close(ifd);
		return (FAILURE);
	}

	if (!pipin && storename) {
		name = basename(in);
		mtime = (u_int32_t)sb->st_mtime;
	}
	if ((cookie = (*method->open)(ofd, "w", name, bits, mtime, flags)) == NULL) {
		if (verbose >= 0)
			warn("%s", out);
		if (oreg)
			(void) unlink(out);
		(void) close(ofd);
		(void) close(ifd);
		return (FAILURE);
	}

	while ((nr = read(ifd, buf, sizeof(buf))) > 0)
		if ((method->write)(cookie, (const char *)buf, nr) != nr) {
			if (verbose >= 0)
				warn("%s", out);
			error = FAILURE;
			break;
		}

	if (!error && nr < 0) {
		if (verbose >= 0)
			warn("%s", in);
		error = FAILURE;
	}

	if ((method->close)(cookie, &info, out, sb)) {
		if (!error && verbose >= 0)
			warn("%s", out);
		error = FAILURE;
	}

	if (close(ifd)) {
		if (!error && verbose >= 0)
			warn("%s", in);
		error = FAILURE;
	}

	if (!force && info.total_out >= info.total_in) {
		if (verbose > 0)
			fprintf(stderr, "file would grow; left unmodified\n");
		(void) unlink(out);
		error = WARNING;
	}

	if (error) {
		if (oreg)
			(void) unlink(out);
	} else if (verbose > 0)
		verbose_info(out, info.total_out, info.total_in, info.hlen);

	return (error);
#else
	warnx("compression not supported");
	return (FAILURE);
#endif
}

const struct compressor *
check_method(int fd)
{
	const struct compressor *method;
	u_char magic[2];

	if (read(fd, magic, sizeof(magic)) != 2)
		return (NULL);
	for (method = &c_table[0]; method->name != NULL; method++) {
		if (magic[0] == method->magic[0] &&
		    magic[1] == method->magic[1])
			return (method);
	}
#ifndef SMALL
	if (force && cat) {
		null_magic[0] = magic[0];
		null_magic[1] = magic[1];
		return (&null_method);
	}
#endif /* SMALL */
	return (NULL);
}

int
dodecompress(const char *in, char *out, const struct compressor *method,
    int bits, struct stat *sb)
{
	u_char buf[Z_BUFSIZE];
	char oldname[MAXPATHLEN];
	int error, oreg, ifd, ofd;
	void *cookie;
	ssize_t nr;
	struct z_info info;
	struct stat osb;

	oreg = 0;
	error = SUCCESS;
	cookie = NULL;

	if (pipin)
		ifd = dup(STDIN_FILENO);
	else
		ifd = open(in, O_RDONLY);
	if (ifd < 0) {
		if (verbose >= 0)
			warn("%s", in);
		return -1;
	}

	if (!force && isatty(ifd)) {
		if (verbose >= 0)
			warnx("%s: won't read compressed data from terminal",
			    in);
		close (ifd);
		return -1;
	}

	if ((method = check_method(ifd)) == NULL) {
		if (verbose >= 0)
			warnx("%s: unrecognized file format", in);
		close (ifd);
		return -1;
	}

	/* XXX - open constrains outfile to MAXPATHLEN so this is safe */
	oldname[0] = '\0';
	if ((cookie = (*method->open)(ifd, "r", oldname, bits, 0, 1)) == NULL) {
		if (verbose >= 0)
			warn("%s", in);
		close (ifd);
		return (FAILURE);
	}
	if (storename && oldname[0] != '\0') {
		char *cp = strrchr(out, '/');
		if (cp != NULL) {
			*(cp + 1) = '\0';
			strlcat(out, oldname, MAXPATHLEN);
		} else
		strlcpy(out, oldname, MAXPATHLEN);
		cat = 0;			/* XXX should -c override? */
	}

	if (testmode)
		ofd = -1;
	else {
		if (cat)
			ofd = dup(STDOUT_FILENO);
		else {
			if (stat(out, &osb) == 0) {
				oreg = S_ISREG(osb.st_mode);
				if (!force && oreg && !permission(out)) {
					(void) close(ifd);
					return (WARNING);
				}
			}
			ofd = open(out, O_WRONLY|O_CREAT|O_TRUNC, S_IWUSR);
		}
		if (ofd < 0) {
			if (verbose >= 0)
				warn("%s", in);
			(method->close)(cookie, NULL, NULL, NULL);
			return (FAILURE);
		}
	}

	while ((nr = (method->read)(cookie, (char *)buf, sizeof(buf))) > 0) {
		if (ofd != -1 && write(ofd, buf, nr) != nr) {
			if (verbose >= 0)
				warn("%s", out);
			error = FAILURE;
			break;
		}
	}

	if (!error && nr < 0) {
		if (verbose >= 0)
			warnx("%s: %s", in,
			    errno == EINVAL ? "crc error" : strerror(errno));
		error = errno == EINVAL ? WARNING : FAILURE;
	}

	if ((method->close)(cookie, &info, NULL, NULL)) {
		if (!error && verbose >= 0)
			warnx("%s", in);
		error = FAILURE;
	}
	if (storename && !cat) {
		if (info.mtime != 0) {
			sb->st_mtimespec.tv_sec =
			    sb->st_atimespec.tv_sec = info.mtime;
			sb->st_mtimespec.tv_nsec =
			    sb->st_atimespec.tv_nsec = 0;
		} else
			storename = 0;		/* no timestamp to restore */
	}
	if (error == SUCCESS)
		setfile(out, ofd, sb);

	if (ofd != -1 && close(ofd)) {
		if (!error && verbose >= 0)
			warn("%s", out);
		error = FAILURE;
	}

	if (!error) {
		if (list) {
			if (info.mtime == 0)
				info.mtime = (u_int32_t)sb->st_mtime;
			list_stats(out, method, &info);
		} else if (verbose > 0) {
			verbose_info(out, info.total_in, info.total_out,
			    info.hlen);
		}
	}

	/* On error, clean up the file we created but preserve errno. */
	if (error && oreg)
		unlink(out);

	return (error);
}

void
setfile(const char *name, int fd, struct stat *fs)
{
	struct timeval tv[2];

	if (name == NULL || cat || testmode)
		return;

	/*
	 * If input was a pipe we don't have any info to restore but we
	 * must set the mode since the current mode on the file is 0200.
	 */
	if (pipin) {
		mode_t mask = umask(022);
		fchmod(fd, DEFFILEMODE & ~mask);
		umask(mask);
		return;
	}

	/*
	 * Changing the ownership probably won't succeed, unless we're root
	 * or POSIX_CHOWN_RESTRICTED is not set.  Set uid/gid before setting
	 * the mode; current BSD behavior is to remove all setuid bits on
	 * chown.  If chown fails, lose setuid/setgid bits.
	 */
	fs->st_mode &= S_ISUID|S_ISGID|S_IRWXU|S_IRWXG|S_IRWXO;
	if (fchown(fd, fs->st_uid, fs->st_gid)) {
		if (errno != EPERM)
			warn("fchown: %s", name);
		fs->st_mode &= ~(S_ISUID|S_ISGID);
	}
	if (fchmod(fd, fs->st_mode))
		warn("fchmod: %s", name);

	if (fs->st_flags && fchflags(fd, fs->st_flags))
		warn("fchflags: %s", name);

	TIMESPEC_TO_TIMEVAL(&tv[0], &fs->st_atimespec);
	TIMESPEC_TO_TIMEVAL(&tv[1], &fs->st_mtimespec);
	if (futimes(fd, tv))
		warn("futimes: %s", name);
}

int
permission(const char *fname)
{
	int ch, first;

	if (!isatty(fileno(stderr)))
		return (0);
	(void)fprintf(stderr, "overwrite %s? ", fname);
	first = ch = getchar();
	while (ch != '\n' && ch != EOF)
		ch = getchar();
	return (first == 'y');
}

/*
 * Check infile for a known suffix and return the suffix portion or NULL.
 */
const char *
check_suffix(const char *infile)
{
	int i;
	const char *suf, *sep, *separators = ".-_";
	static const char *suffixes[] =
	    { "Z", "gz", "z", "tgz", "taz", "cgz", "ngz", NULL };

	for (sep = separators; *sep != '\0'; sep++) {
		if ((suf = strrchr(infile, *sep)) == NULL)
			continue;
		suf++;

		for (i = 0; suffixes[i] != NULL; i++) {
			if (strcmp(suf, suffixes[i]) == 0)
				return (suf - 1);
		}
	}
	return (NULL);
}

/*
 * Set outfile based on the suffix.  In most cases we just strip
 * off the suffix but things like .tgz and .taz are special.
 */
char *
set_outfile(const char *infile, char *outfile, size_t osize)
{
	const char *s;
	char *cp;

	if ((s = check_suffix(infile)) == NULL)
		return (NULL);

	(void)strlcpy(outfile, infile, osize);
	cp = outfile + (s - infile) + 1;
	/*
	 * Convert tgz and taz -> tar, else drop the suffix.
	 */
	if (strcmp(cp, "tgz") == 0) {
		cp[1] = 'a';
		cp[2] = 'r';
	} else if (!strcmp(cp, "cgz") || !strcmp(cp, "ngz")) {
		*--cp = 0;
		strlcat(outfile, ".cpio", osize);
	} else if (strcmp(cp, "taz") == 0)
		cp[2] = 'r';
	else
		cp[-1] = '\0';
	return (outfile);
}

/*
 * Print output for the -l option.
 */
void
list_stats(const char *name, const struct compressor *method,
    struct z_info *info)
{
	static off_t compressed_total, uncompressed_total, header_total;
	static u_int nruns;
	char *timestr;

	if (nruns == 0) {
		if (verbose >= 0) {
			if (verbose > 0)
				fputs("method  crc      date   time  ", stdout);
			puts("compressed  uncompressed  ratio  uncompressed_name");
		}
	}
	nruns++;

	if (name != NULL) {
		if (verbose > 0) {
			timestr = ctime(&info->mtime) + 4;
			timestr[12] = '\0';
			if (timestr[4] == ' ')
				timestr[4] = '0';
			printf("%-7.7s %08x %s ", method->name, info->crc,
			    timestr);
		}
		printf("%10lld    %10lld  %4.1f%%  %s\n",
		    (long long)(info->total_in + info->hlen),
		    (long long)info->total_out,
		    ((long long)info->total_out - (long long)info->total_in) *
		    100.0 / info->total_out, name);
		compressed_total += info->total_in;
		uncompressed_total += info->total_out;
		header_total += info->hlen;
	} else if (verbose >= 0) {
		if (nruns < 3)		/* only do totals for > 1 files */
			return;
		if (verbose > 0)
			fputs("                              ", stdout);
		printf("%10lld    %10lld  %4.1f%%  (totals)\n",
		    (long long)(compressed_total + header_total),
		    (long long)uncompressed_total,
		    (uncompressed_total - compressed_total) *
		    100.0 / uncompressed_total);
	}
}

void
verbose_info(const char *file, off_t compressed, off_t uncompressed,
    u_int32_t hlen)
{
	if (testmode) {
		fputs("OK\n", stderr);
		return;
	}
	if (!pipin) {
		fprintf(stderr, "\t%4.1f%% -- replaced with %s\n",
		    (uncompressed - compressed) * 100.0 / uncompressed, file);
	}
	compressed += hlen;
	fprintf(stderr, "%lld bytes in, %lld bytes out\n",
	    (long long)(decomp ? compressed : uncompressed),
	    (long long)(decomp ? uncompressed : compressed));
}

__dead void
usage(int status)
{
	fprintf(stderr,
	    "usage: %s [-123456789cdfghLlNnOqrtVv] [-b bits] [-o filename]\n"
	    "\t[-S suffix] [file ...]\n",
	    __progname);
	exit(status);
}
@


1.13
log
@kill RCS ID in binary .text, for size
@
text
@d5 2
d12 1
a12 1
__IDSTRING(licence, "\n"
a54 2
__RCSID("$MirOS: src/usr.bin/compress/main.c,v 1.12 2009/10/27 19:27:15 tg Exp $");

@


1.12
log
@merge
@
text
@d3 2
d6 1
a6 2
static const char copyright[] =
"@@(#) Copyright (c) 1992, 1993\n\
d8 1
a8 2
"Copyright (c) 1997-2002 Michael Shalayeff\n";
#endif
d10 1
a10 3
#ifndef SMALL
static const char license[] =
"\n"
d33 1
a33 1
" THE POSSIBILITY OF SUCH DAMAGE.\n";
d53 1
a53 1
__RCSID("$MirOS: src/usr.bin/compress/main.c,v 1.11 2007/04/29 21:24:44 tg Exp $");
d282 2
a283 2
			fputs(copyright, stderr);
			fputs(license, stderr);
a284 1
			exit (0);
@


1.11
log
@merge openbsd changes; fix manpages; etc.
@
text
@d1 1
a1 2
/**	$MirOS: src/usr.bin/compress/main.c,v 1.10 2006/07/05 21:35:14 tg Exp $ */
/*	$OpenBSD: main.c,v 1.70 2007/04/04 13:29:45 millert Exp $	*/
d55 1
a55 1
__RCSID("$MirOS: src/usr.bin/compress/main.c,v 1.10 2006/07/05 21:35:14 tg Exp $");
d241 1
a241 1
			testmode++;
d637 5
@


1.10
log
@*sigh* fix -f
@
text
@d1 2
a2 2
/**	$MirOS: src/usr.bin/compress/main.c,v 1.9 2006/06/23 16:35:22 tg Exp $ */
/*	$OpenBSD: main.c,v 1.64 2005/07/11 14:16:47 millert Exp $	*/
d56 1
a56 1
__RCSID("$MirOS: src/usr.bin/compress/main.c,v 1.9 2006/06/23 16:35:22 tg Exp $");
d60 1
a60 3
int pipin, force, verbose, testmode, list, nosave;
int savename, recurse;
int cat, decomp;
d73 2
a74 1
  { "deflate", ".gz", "\037\213", gz_open, gz_read, gz_write, gz_close },
d77 2
a78 1
  { "compress", ".Z", "\037\235", z_open,  zread,   zwrite,   z_close },
d82 2
a83 1
  { "lzh", ".lzh", "\037\240", lzh_open, lzh_read, lzh_write, lzh_close },
d85 2
a86 1
  { "zip", ".zip", "PK", zip_open, zip_read, zip_write, zip_close },
d88 2
a89 1
  { "pack", ".pak", "\037\036", pak_open, pak_read, pak_write, pak_close },
d96 2
a97 1
{ "null", ".nul", "XX", null_open, null_read, null_write, null_close };
a142 1
	struct stat osb;
d144 2
a145 2
	const char *s;
	char *p, *infile;
d148 1
a148 1
	int bits, exists, oreg, ch, error, i, rc, oflag;
d150 2
a151 2
	oreg = exists = bits = oflag = 0;
	nosave = -1;
d167 1
a167 1
		cat = 1;
d182 1
a182 1
	if ((p = getenv("GZIP")) != NULL) {
d227 1
a227 1
			cat = 1;
d246 1
a246 1
			nosave = 1;
d249 1
a249 1
			nosave = 0;
d306 1
a306 1
		argv[0] = strdup("/dev/stdin");
a307 11
		pipin++;
		if (!oflag)
			cat = 1;
	} else {
		for (i = 0; i < argc; i++) {
			if (argv[i][0] == '-' && argv[i][1] == '\0') {
				argv[i] = strdup("/dev/stdin");
				pipin++;
				cat = 1;
			}
		}
d314 7
a320 2
	if (nosave == -1)
		nosave = decomp;
d325 2
d328 40
a367 36
		switch (entry->fts_info) {
		case FTS_D:
			if (!recurse) {
				warnx("%s is a directory: ignored",
				    infile);
				fts_set(ftsp, entry, FTS_SKIP);
			}
			continue;
		case FTS_DP:
			continue;
		case FTS_NS:
			/*
			 * If file does not exist and has no suffix,
			 * tack on the default suffix and try that.
			 */
			/* XXX - is overwriting fts_statp legal? (millert) */
			if (entry->fts_errno == ENOENT &&
			    ((p = strrchr(entry->fts_accpath, '.')) == NULL ||
			    strcmp(p, suffix) != 0) &&
			    snprintf(_infile, sizeof(_infile), "%s%s", infile,
			    suffix) < (ssize_t)sizeof(_infile) &&
			    stat(_infile, entry->fts_statp) == 0 &&
			    S_ISREG(entry->fts_statp->st_mode)) {
				infile = _infile;
				break;
			}
		case FTS_ERR:
		case FTS_DNR:
			warnx("%s: %s", infile, strerror(entry->fts_errno));
			rc = rc ? rc : WARNING;
			continue;
		default:
			if (!S_ISREG(entry->fts_statp->st_mode) && !pipin &&
			    !(S_ISLNK(entry->fts_statp->st_mode) && cat)) {
				warnx("%s not a regular file%s",
				    infile, cat ? "" : ": unchanged");
d370 10
a380 2
			break;
		}
d389 4
a392 4
		if (cat)
			strlcpy(outfile, "/dev/stdout", sizeof outfile);
		else if (!oflag) {
			if (decomp) {
a415 10
		if (!testmode) {
			exists = !stat(outfile, &osb);
			if (!force && exists && S_ISREG(osb.st_mode) &&
			    !permission(outfile)) {
				rc = rc ? rc : WARNING;
				continue;
			}
			oreg = !exists || S_ISREG(osb.st_mode);
		}

a437 7
			if (oreg && unlink(outfile) && errno != ENOENT &&
			    verbose >= 0) {
				if (force)
					warn("output: %s", outfile);
				else
					err(1, "output: %s", outfile);
			}
d454 1
a454 1
	int error, ifd, ofd, flags;
d459 1
d462 1
a462 1
	flags = 0;
d467 5
a471 1
	if ((ifd = open(in, O_RDONLY)) < 0) {
d477 13
a489 1
	if ((ofd = open(out, O_WRONLY|O_CREAT, S_IWUSR)) < 0) {
d505 1
a505 1
	if (!pipin && !nosave) {
d511 3
a513 1
			warn("%s", in);
d548 2
a549 1
		error = FAILURE;
d552 4
a555 1
	if (!error && verbose > 0)
d593 2
a594 1
	int error, ifd, ofd;
d598 1
d600 1
d604 5
a608 1
	if ((ifd = open(in, O_RDONLY)) < 0) {
d630 2
a631 2
	if ((cookie = (*method->open)(ifd, "r", nosave ? NULL : out,
	    bits, 0, 1)) == NULL) {
d637 4
d644 19
a662 5
	else if ((ofd = open(out, O_WRONLY|O_CREAT|O_TRUNC, S_IWUSR)) < 0) {
		if (verbose >= 0)
			warn("%s", in);
		(method->close)(cookie, NULL, NULL, NULL);
		return (FAILURE);
d686 1
a686 1
	if (!nosave) {
d693 1
a693 4
			nosave = 1;		/* no timestamp to restore */

		if (cat && strcmp(out, "/dev/stdout") != 0)
			cat = 0;		/* have a real output name */
d715 4
d759 4
a762 6
	if (!nosave) {
		TIMESPEC_TO_TIMEVAL(&tv[0], &fs->st_atimespec);
		TIMESPEC_TO_TIMEVAL(&tv[1], &fs->st_mtimespec);
		if (futimes(fd, tv))
			warn("futimes: %s", name);
	}
a854 2
		if (strcmp(name, "/dev/stdout") == 0)
			name += 5;
d906 2
a907 1
	    "usage: %s [-cdfghOqrtvV] [-b bits] [-S suffix] [-[1-9]] [file ...]\n",
@


1.9
log
@prevent removing of the input file before output is written, by accident
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.bin/compress/main.c,v 1.8 2006/05/29 18:28:03 tg Exp $ */
d56 1
a56 1
__RCSID("$MirOS: src/usr.bin/compress/main.c,v 1.8 2006/05/29 18:28:03 tg Exp $");
d418 1
a418 1
		if (!strcmp(infile, outfile))
@


1.8
log
@Option -f for "fuckoff, I know /bsd doesn't have a .gz suffix
but I still want to 'gzip -fvl' or 'gzip -fvt' it!"
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.bin/compress/main.c,v 1.7 2005/11/24 11:53:21 tg Exp $ */
d56 1
a56 1
__RCSID("$MirOS: src/usr.bin/compress/main.c,v 1.7 2005/11/24 11:53:21 tg Exp $");
d418 4
@


1.7
log
@I broke gzip compression:
|   Revision 1.5: [17]download - view: [18]text, [19]markup, [20]annotated - [21]select for diffs
|   Wed Nov 16 22:10:34 2005 UTC (7 days, 13 hours ago) by tg
|   Branches: [22]MAIN
|   Diff to previous 1.4: [23]preferred, [24]coloured
|   Changes since revision 1.4: +17 -16 lines
|make __CRAZY clean

char -> u_char fixes it
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.bin/compress/main.c,v 1.6 2005/11/23 17:08:49 tg Exp $ */
d56 1
a56 1
__RCSID("$MirOS: src/usr.bin/compress/main.c,v 1.6 2005/11/23 17:08:49 tg Exp $");
d384 1
a384 1
					if (!recurse) {
d389 4
a392 1
					continue;
@


1.6
log
@* merge
* while here, implement zdopen() from mpczar/minizip
* make __CRAZY=Yes clean
* if Z_STANDALONE is defined, zopen.c can be used in other projects
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.bin/compress/main.c,v 1.5 2005/11/16 22:10:56 tg Exp $ */
d56 1
a56 1
__RCSID("$MirOS: src/usr.bin/compress/main.c,v 1.5 2005/11/16 22:10:56 tg Exp $");
d68 1
a68 1
	const char *magic;
@


1.5
log
@make __CRAZY clean
@
text
@d1 2
a2 2
/**	$MirOS: src/usr.bin/compress/main.c,v 1.4 2005/04/29 18:35:07 tg Exp $ */
/*	$OpenBSD: main.c,v 1.62 2005/04/17 16:17:39 deraadt Exp $	*/
d56 1
a56 1
__RCSID("$MirOS: src/usr.bin/compress/main.c,v 1.4 2005/04/29 18:35:07 tg Exp $");
d72 1
a72 1
	int (*close)(void *, struct z_info *);
a96 1
void setfile(const char *, int, struct stat *);
d467 1
a467 1
			warn("%s", out);
d513 1
a513 4
	if (error == SUCCESS)
		setfile(out, ofd, sb);

	if ((method->close)(cookie, &info)) {
d612 1
a612 1
		(method->close)(cookie, NULL);
d632 1
a632 4
	if (error == SUCCESS)
		setfile(out, ofd, sb);

	if ((method->close)(cookie, &info)) {
a636 1

d649 2
d677 1
a677 1
	if (cat || testmode)
a679 7
	if (!pipin || !nosave) {
		TIMESPEC_TO_TIMEVAL(&tv[0], &fs->st_atimespec);
		TIMESPEC_TO_TIMEVAL(&tv[1], &fs->st_mtimespec);
		if (futimes(fd, tv))
			warn("futimes: %s", name);
	}

d708 7
@


1.4
log
@(tentative) merge, more to come
@
text
@d1 1
a1 1
/**	$MirOS: src/usr.bin/compress/main.c,v 1.3 2005/04/14 11:46:45 tg Exp $ */
d56 1
a56 1
__RCSID("$MirOS: src/usr.bin/compress/main.c,v 1.3 2005/04/14 11:46:45 tg Exp $");
d66 3
a68 3
	char *name;
	char *suffix;
	u_char *magic;
d88 1
a88 1
  { NULL }
d132 1
a132 1
	{ NULL }
d186 1
a186 1
			if (i < sizeof(nargv)/sizeof(nargv[1]) - argc - 1)
d304 1
a304 1
		argv[0] = "/dev/stdin";
d312 1
a312 1
				argv[i] = "/dev/stdin";
d350 1
a350 1
			    suffix) < sizeof(_infile) &&
d393 1
a393 1
				if (snprintf(outfile, sizeof(outfile),
d501 1
a501 1
		if ((method->write)(cookie, buf, nr) != nr) {
d620 1
a620 1
	while ((nr = (method->read)(cookie, buf, sizeof(buf))) > 0) {
d744 3
a746 2
	char *suf, *sep, *separators = ".-_";
	static char *suffixes[] = { "Z", "gz", "z", "tgz", "taz", "cgz", "ngz", NULL };
@


1.3
log
@merge, clean up
@
text
@d1 2
a2 2
/**	$MirOS: src/usr.bin/compress/main.c,v 1.2 2005/03/13 18:32:49 tg Exp $ */
/*	$OpenBSD: main.c,v 1.59 2005/02/24 09:44:36 moritz Exp $	*/
d56 1
a56 1
__RCSID("$MirOS: src/usr.bin/compress/main.c,v 1.2 2005/03/13 18:32:49 tg Exp $");
d97 1
a97 1
void setfile(const char *, struct stat *);
d188 1
a188 1
			else {
a189 1
			}
d417 1
a417 1
			(infile, outfile, method, bits, entry->fts_statp);
a421 1
				setfile(outfile, entry->fts_statp);
d514 3
d636 3
d679 1
a679 1
setfile(const char *name, struct stat *fs)
d683 3
d689 2
a690 2
		if (utimes(name, tv))
			warn("utimes: %s", name);
d699 1
a699 1
		chmod(name, DEFFILEMODE & ~mask);
d711 1
a711 1
	if (chown(name, fs->st_uid, fs->st_gid)) {
d713 1
a713 1
			warn("chown: %s", name);
d716 2
a717 2
	if (chmod(name, fs->st_mode))
		warn("chown: %s", name);
d719 2
a720 2
	if (fs->st_flags && chflags(name, fs->st_flags))
		warn("chflags: %s", name);
d820 1
a820 1
				timestr);
@


1.2
log
@merge src/usr.bin
@
text
@d1 2
a2 2
/**	$MirOS$ */
/*	$OpenBSD: main.c,v 1.54 2004/02/29 13:59:15 markus Exp $	*/
d56 1
a56 1
__RCSID("$MirOS$");
d148 1
a148 2
	exists = 0;
	bits = oflag = 0;
d348 2
a349 1
			    strchr(entry->fts_accpath, '.') == NULL &&
d404 1
a404 1
		if (!testmode)
d406 6
a411 4
		if (!force && exists && S_ISREG(osb.st_mode) &&
		    !permission(outfile)) {
			rc = rc ? rc : WARNING;
			continue;
a413 2
		oreg = !exists || S_ISREG(osb.st_mode);

d453 1
d538 4
d818 1
a818 1
		    (info->total_out - info->total_in) *
@


1.1
log
@Initial revision
@
text
@d1 1
a38 4
#ifndef SMALL
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.54 2004/02/29 13:59:15 markus Exp $";
#endif

d56 2
a276 1
#ifndef SMALL
d278 1
a278 3
			printf("%s\n%s\n", main_rcsid, gz_rcsid);
			printf("%s\n%s\n", z_rcsid, null_rcsid);
#endif
d733 1
a733 1
	static char *suffixes[] = { "Z", "gz", "z", "tgz", "taz", NULL };
d769 3
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@import OpenBSD's latest compress(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.59 2005/02/24 09:44:36 moritz Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.59 2005/02/24 09:44:36 moritz Exp $";
d149 2
a150 1
	oreg = exists = bits = oflag = 0;
d353 1
a353 2
			    ((p = strrchr(entry->fts_accpath, '.')) == NULL ||
			    strcmp(p, suffix) != 0) &&
d408 1
a408 1
		if (!testmode) {
d410 4
a413 6
			if (!force && exists && S_ISREG(osb.st_mode) &&
			    !permission(outfile)) {
				rc = rc ? rc : WARNING;
				continue;
			}
			oreg = !exists || S_ISREG(osb.st_mode);
d416 2
a456 1
#ifndef SMALL
a540 4
#else
	warnx("compression not supported");
	return (FAILURE);
#endif
d814 1
a814 1
		    ((long long)info->total_out - (long long)info->total_in) *
@


1.1.1.3
log
@improve my Frankenstein OS (*wink* you know who you are) further
sans wchar_t of course

this is the essence of reading >1200 commit messages which suck
due to not having the new format of ours...
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.62 2005/04/17 16:17:39 deraadt Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.62 2005/04/17 16:17:39 deraadt Exp $";
d98 1
a98 1
void setfile(const char *, int, struct stat *);
d189 1
a189 1
			else
d191 1
d422 1
a422 1
		    (infile, outfile, method, bits, entry->fts_statp);
d427 1
a519 3
	if (error == SUCCESS)
		setfile(out, ofd, sb);

a638 3
	if (error == SUCCESS)
		setfile(out, ofd, sb);

d679 1
a679 1
setfile(const char *name, int fd, struct stat *fs)
a682 3
	if (cat || testmode)
		return;

d686 2
a687 2
		if (futimes(fd, tv))
			warn("futimes: %s", name);
d696 1
a696 1
		fchmod(fd, DEFFILEMODE & ~mask);
d708 1
a708 1
	if (fchown(fd, fs->st_uid, fs->st_gid)) {
d710 1
a710 1
			warn("fchown: %s", name);
d713 2
a714 2
	if (fchmod(fd, fs->st_mode))
		warn("fchmod: %s", name);
d716 2
a717 2
	if (fs->st_flags && fchflags(fd, fs->st_flags))
		warn("fchflags: %s", name);
d814 1
a814 1
			    timestr);
@


1.1.1.4
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.64 2005/07/11 14:16:47 millert Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.64 2005/07/11 14:16:47 millert Exp $";
d73 1
a73 1
	int (*close)(void *, struct z_info *, const char *, struct stat *);
d98 1
d472 1
a472 1
			warn("%s", in);
d518 4
a521 1
	if ((method->close)(cookie, &info, out, sb)) {
d620 1
a620 1
		(method->close)(cookie, NULL, NULL, NULL);
d640 4
a643 1
	if ((method->close)(cookie, &info, NULL, NULL)) {
d648 1
a660 2
	if (error == SUCCESS)
		setfile(out, ofd, sb);
d687 1
a687 1
	if (name == NULL || cat || testmode)
d690 7
a724 7

	if (!nosave) {
		TIMESPEC_TO_TIMEVAL(&tv[0], &fs->st_atimespec);
		TIMESPEC_TO_TIMEVAL(&tv[1], &fs->st_mtimespec);
		if (futimes(fd, tv))
			warn("futimes: %s", name);
	}
@


1.1.1.5
log
@import openbsd compress, ssh, perl, sendmail for minor bugfixes
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.70 2007/04/04 13:29:45 millert Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.70 2007/04/04 13:29:45 millert Exp $";
d61 3
a63 1
int cat, decomp, pipin, force, verbose, testmode, list, recurse, storename;
d140 1
d146 1
a146 1
	int bits, ch, error, i, rc, cflag, oflag;
d148 2
a149 2
	bits = cflag = oflag = 0;
	storename = -1;
d165 1
a165 1
		cflag = 1;
d180 1
a180 1
	if (method == M_DEFLATE && (p = getenv("GZIP")) != NULL) {
d225 1
a225 1
			cflag = 1;
d244 1
a244 1
			storename = 0;
d247 1
a247 1
			storename = 1;
d307 1
a307 1
		argv[0] = "-";
d309 11
d326 2
a327 7
	/*
	 * By default, when compressing store the original name and timestamp
	 * in the header.  Do not restore these when decompressing unless
	 * the -N option is given.
	 */
	if (storename == -1)
		storename = !decomp;
a331 2
		cat = cflag;
		pipin = 0;
d333 36
a368 40
		if (infile[0] == '-' && infile[1] == '\0') {
			infile = "stdin";
			pipin++;
			if (!oflag)
				cat = 1;
		}
		else
			switch (entry->fts_info) {
			case FTS_D:
				if (!recurse) {
					warnx("%s is a directory: ignored",
					    infile);
					fts_set(ftsp, entry, FTS_SKIP);
				}
				continue;
			case FTS_DP:
				continue;
			case FTS_NS:
				/*
				 * If file does not exist and has no suffix,
				 * tack on the default suffix and try that.
				 */
				if (entry->fts_errno == ENOENT) {
					p = strrchr(entry->fts_accpath, '.');
					if ((p == NULL ||
					    strcmp(p, suffix) != 0) &&
					    snprintf(_infile, sizeof(_infile),
					    "%s%s", infile, suffix) <
					    sizeof(_infile) &&
					    stat(_infile, entry->fts_statp) ==
					    0 &&
					    S_ISREG(entry->fts_statp->st_mode)) {
						infile = _infile;
						break;
					}
				}
			case FTS_ERR:
			case FTS_DNR:
				warnx("%s: %s", infile,
				    strerror(entry->fts_errno));
a370 10
			default:
				if (!S_ISREG(entry->fts_statp->st_mode) &&
				    !(S_ISLNK(entry->fts_statp->st_mode) &&
				    cat)) {
					warnx("%s not a regular file%s",
					    infile, cat ? "" : ": unchanged");
					rc = rc ? rc : WARNING;
					continue;
				}
				break;
d372 2
d382 4
a385 4
		if (!oflag) {
			if (cat)
				strlcpy(outfile, "stdout", sizeof(outfile));
			else if (decomp) {
d406 10
d434 7
d457 1
a457 1
	int error, ifd, ofd, flags, oreg;
a461 1
	struct stat osb;
d464 1
a464 1
	flags = oreg = 0;
d469 1
a469 5
	if (pipin)
		ifd = dup(STDIN_FILENO);
	else
		ifd = open(in, O_RDONLY);
	if (ifd < 0) {
d475 1
a475 13
	if (cat)
		ofd = dup(STDOUT_FILENO);
	else {
		if (stat(out, &osb) == 0) {
			oreg = S_ISREG(osb.st_mode);
			if (!force && oreg && !permission(out)) {
				(void) close(ifd);
				return (WARNING);
			}
		}
		ofd = open(out, O_WRONLY|O_CREAT, S_IWUSR);
	}
	if (ofd < 0) {
d491 1
a491 1
	if (!pipin && storename) {
d497 1
a497 3
			warn("%s", out);
		if (oreg)
			(void) unlink(out);
d532 1
a532 2
		(void) unlink(out);
		error = WARNING;
d535 1
a535 4
	if (error) {
		if (oreg)
			(void) unlink(out);
	} else if (verbose > 0)
d573 1
a573 2
	char oldname[MAXPATHLEN];
	int error, oreg, ifd, ofd;
a576 1
	struct stat osb;
a577 1
	oreg = 0;
d581 1
a581 5
	if (pipin)
		ifd = dup(STDIN_FILENO);
	else
		ifd = open(in, O_RDONLY);
	if (ifd < 0) {
d603 2
a604 2
	oldname[0] = '\0';
	if ((cookie = (*method->open)(ifd, "r", oldname, bits, 0, 1)) == NULL) {
a609 4
	if (storename && oldname[0] != '\0') {
		strlcpy(out, oldname, MAXPATHLEN);
		cat = 0;			/* XXX should -c override? */
	}
d613 5
a617 19
	else {
		if (cat)
			ofd = dup(STDOUT_FILENO);
		else {
			if (stat(out, &osb) == 0) {
				oreg = S_ISREG(osb.st_mode);
				if (!force && oreg && !permission(out)) {
					(void) close(ifd);
					return (WARNING);
				}
			}
			ofd = open(out, O_WRONLY|O_CREAT|O_TRUNC, S_IWUSR);
		}
		if (ofd < 0) {
			if (verbose >= 0)
				warn("%s", in);
			(method->close)(cookie, NULL, NULL, NULL);
			return (FAILURE);
		}
d641 1
a641 1
	if (storename && !cat) {
d648 4
a651 1
			storename = 0;		/* no timestamp to restore */
a672 4
	/* On error, clean up the file we created but preserve errno. */
	if (error && oreg)
		unlink(out);

d713 6
a718 4
	TIMESPEC_TO_TIMEVAL(&tv[0], &fs->st_atimespec);
	TIMESPEC_TO_TIMEVAL(&tv[1], &fs->st_mtimespec);
	if (futimes(fd, tv))
		warn("futimes: %s", name);
d807 2
d860 1
a860 2
	    "usage: %s [-123456789cdfghLlNnOqrtVv] [-b bits] [-o filename]\n"
	    "\t[-S suffix] [file ...]\n",
@


1.1.1.6
log
@backport some of obsd fixes but not changes
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.75 2009/04/18 18:21:54 naddy Exp $	*/
d39 1
a39 1
static const char main_rcsid[] = "$OpenBSD: main.c,v 1.75 2009/04/18 18:21:54 naddy Exp $";
d237 1
a237 1
			testmode = 1;
a628 5
		char *cp = strrchr(out, '/');
		if (cp != NULL) {
			*(cp + 1) = '\0';
			strlcat(out, oldname, MAXPATHLEN);
		} else
@


