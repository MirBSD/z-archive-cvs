head	1.4;
access;
symbols
	cvs-20160325:1.1.1.2
	MIRBSD_10:1.2.0.4
	MIRBSD_10_BASE:1.2
	MIRBSD_9_BASE:1.2
	MIRBSD_8:1.2.0.2
	MIRBSD_8_BASE:1.2
	cvs-200507211800:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2016.03.25.19.17.10;	author tg;	state Exp;
branches;
next	1.3;
commitid	10056F58ECC633EC9F6;

1.3
date	2016.03.25.18.55.36;	author tg;	state Exp;
branches;
next	1.2;
commitid	10056F589BF44FCD098;

1.2
date	2005.06.08.10.37.53;	author tg;	state Exp;
branches;
next	1.1;
commitid	431f42a6ca471afe;

1.1
date	2005.02.05.17.29.48;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.29.48;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2016.03.25.18.29.32;	author tg;	state Exp;
branches;
next	;
commitid	10056F5839F0299669A;


desc
@@


1.4
log
@__CRAZY clean
@
text
@/*	$OpenBSD: inp.c,v 1.45 2015/11/11 01:12:10 deraadt Exp $	*/

/*
 * patch - a program to apply diffs to original files
 * 
 * Copyright 1986, Larry Wall
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following condition is met:
 * 1. Redistributions of source code must retain the above copyright notice,
 * this condition and the following disclaimer.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * -C option added in 1998, original code by Marc Espie, based on FreeBSD
 * behaviour
 */

#include <sys/types.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/mman.h>

#include <ctype.h>
#include <libgen.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "common.h"
#include "util.h"
#include "pch.h"
#include "inp.h"

__RCSID("$MirOS: src/usr.bin/patch/inp.c,v 1.3 2016/03/25 18:55:36 tg Exp $");

/* Input-file-with-indexable-lines abstract type */

static off_t	i_size;		/* size of the input file */
static char	*i_womp;	/* plan a buffer for entire file */
static char	**i_ptr;	/* pointers to lines in i_womp */
static char	null[] = "";	/* some valid memory */

static int	tifd = -1;	/* plan b virtual string array */
static char	*tibuf[2];	/* plan b buffers */
static LINENUM	tiline[2] = {-1, -1};	/* 1st line in each buffer */
static size_t	lines_per_buf;	/* how many lines per buffer */
static size_t	tibuflen;	/* plan b buffer length */
static size_t	tireclen;	/* length of records in tmp file */

static bool	rev_in_string(const char *);
static bool	reallocate_lines(size_t *);

/* returns false if insufficient memory */
static bool	plan_a(const char *);

static void	plan_b(const char *);

/* New patch--prepare to edit another file. */

void
re_input(void)
{
	if (using_plan_a) {
		free(i_ptr);
		i_ptr = NULL;
		if (i_womp != NULL) {
			munmap(i_womp, i_size);
			i_womp = NULL;
		}
		i_size = 0;
	} else {
		using_plan_a = true;	/* maybe the next one is smaller */
		close(tifd);
		tifd = -1;
		free(tibuf[0]);
		free(tibuf[1]);
		tibuf[0] = tibuf[1] = NULL;
		tiline[0] = tiline[1] = -1;
		tireclen = 0;
	}
}

/* Construct the line index, somehow or other. */

void
scan_input(const char *filename)
{
	if (!plan_a(filename))
		plan_b(filename);
	if (verbose) {
		say("Patching file %s using Plan %s...\n", filename,
		    (using_plan_a ? "A" : "B"));
	}
}

static bool
reallocate_lines(size_t *lines_allocated)
{
	char	**p;
	size_t	new_size;

	new_size = *lines_allocated * 3 / 2;
	p = reallocarray(i_ptr, new_size + 2, sizeof(char *));
	if (p == NULL) {	/* shucks, it was a near thing */
		munmap(i_womp, i_size);
		i_womp = NULL;
		free(i_ptr);
		i_ptr = NULL;
		*lines_allocated = 0;
		return false;
	}
	*lines_allocated = new_size;
	i_ptr = p;
	return true;
}

/* Try keeping everything in memory. */

static bool
plan_a(const char *filename)
{
	int		ifd, statfailed;
	char		*p, *s;
	struct stat	filestat;
	off_t		i;
	ptrdiff_t	sz;
	size_t		iline, lines_allocated;

#ifdef DEBUGGING
	if (debug & 8)
		return false;
#endif

	if (filename == NULL || *filename == '\0')
		return false;

	statfailed = stat(filename, &filestat);
	if (statfailed && ok_to_create_file) {
		if (verbose)
			say("(Creating file %s...)\n", filename);

		/*
		 * in check_patch case, we still display `Creating file' even
		 * though we're not. The rule is that -C should be as similar
		 * to normal patch behavior as possible
		 */
		if (check_only)
			return true;
		makedirs(filename, true);
		close(open(filename, O_CREAT | O_TRUNC | O_WRONLY, 0666));
		statfailed = stat(filename, &filestat);
	}
	if (statfailed)
		fatal("can't find %s\n", filename);
	filemode = filestat.st_mode;
	if (!S_ISREG(filemode))
		fatal("%s is not a normal file--can't patch\n", filename);
	i_size = filestat.st_size;
	if (out_of_mem) {
		set_hunkmax();	/* make sure dynamic arrays are allocated */
		out_of_mem = false;
		return false;	/* force plan b because plan a bombed */
	}
	if (i_size > SIZE_MAX) {
		say("block too large to mmap\n");
		return false;
	}
	if ((ifd = open(filename, O_RDONLY)) < 0)
		pfatal("can't open file %s", filename);

	if (i_size) {
		i_womp = mmap(NULL, i_size, PROT_READ, MAP_PRIVATE, ifd, 0);
		if (i_womp == MAP_FAILED) {
#ifndef __INTERIX
			perror("mmap failed");
#endif
			i_womp = NULL;
			close(ifd);
			return false;
		}
	} else {
		i_womp = NULL;
	}

	close(ifd);
	if (i_size)
		madvise(i_womp, i_size, MADV_SEQUENTIAL);

	/* estimate the number of lines */
	lines_allocated = i_size / 25;
	if (lines_allocated < 100)
		lines_allocated = 100;

	if (!reallocate_lines(&lines_allocated))
		return false;

	/* now scan the buffer and build pointer array */
	iline = 1;
	i_ptr[iline] = i_womp;
	/* test for NUL too, to maintain the behavior of the original code */
	for (s = i_womp, i = 0; i < i_size && *s != '\0'; s++, i++) {
		if (*s == '\n') {
			if (iline == lines_allocated) {
				if (!reallocate_lines(&lines_allocated))
					return false;
			}
			/* these are NOT NUL terminated */
			i_ptr[++iline] = s + 1;
		}
	}
	/* if the last line contains no EOL, append one */
	if (i_size > 0 && i_womp[i_size - 1] != '\n') {
		last_line_missing_eol = true;
		/* fix last line */
		sz = s - i_ptr[iline];
		p = malloc(sz + 1);
		if (p == NULL) {
			free(i_ptr);
			i_ptr = NULL;
			munmap(i_womp, i_size);
			i_womp = NULL;
			return false;
		}

		memcpy(p, i_ptr[iline], sz);
		p[sz] = '\n';
		i_ptr[iline] = p;
		/* count the extra line and make it point to some valid mem */
		i_ptr[++iline] = null;
	} else
		last_line_missing_eol = false;

	input_lines = iline - 1;

	/* now check for revision, if any */

	if (revision != NULL) {
		if (i_womp == NULL || !rev_in_string(i_womp)) {
			if (force) {
				if (verbose)
					say("Warning: this file doesn't appear "
					    "to be the %s version--patching anyway.\n",
					    revision);
			} else if (batch) {
				fatal("this file doesn't appear to be the "
				    "%s version--aborting.\n",
				    revision);
			} else {
				ask("This file doesn't appear to be the "
				    "%s version--patch anyway? [n] ",
				    revision);
				if (*buf != 'y')
					fatal("aborted\n");
			}
		} else if (verbose)
			say("Good.  This file appears to be the %s version.\n",
			    revision);
	}
	return true;		/* plan a will work */
}

/* Keep (virtually) nothing in memory. */

static void
plan_b(const char *filename)
{
	FILE	*ifp;
	size_t	i = 0, j, len, maxlen = 1;
	char	*lbuf = NULL, *p;
	bool	found_revision = (revision == NULL);

	using_plan_a = false;
	if ((ifp = fopen(filename, "r")) == NULL)
		pfatal("can't open file %s", filename);
	(void) unlink(TMPINNAME);
	if ((tifd = open(TMPINNAME, O_EXCL | O_CREAT | O_WRONLY, 0666)) < 0)
		pfatal("can't open file %s", TMPINNAME);
	while ((p = fgetln(ifp, &len)) != NULL) {
		if (p[len - 1] == '\n')
			p[len - 1] = '\0';
		else {
			/* EOF without EOL, copy and add the NUL */
			if ((lbuf = malloc(len + 1)) == NULL)
				fatal("out of memory\n");
			memcpy(lbuf, p, len);
			lbuf[len] = '\0';
			p = lbuf;

			last_line_missing_eol = true;
			len++;
		}
		if (revision != NULL && !found_revision && rev_in_string(p))
			found_revision = true;
		if (len > maxlen)
			maxlen = len;	/* find longest line */
	}
	free(lbuf);
	if (ferror(ifp))
		pfatal("can't read file %s", filename);

	if (revision != NULL) {
		if (!found_revision) {
			if (force) {
				if (verbose)
					say("Warning: this file doesn't appear "
					    "to be the %s version--patching anyway.\n",
					    revision);
			} else if (batch) {
				fatal("this file doesn't appear to be the "
				    "%s version--aborting.\n",
				    revision);
			} else {
				ask("This file doesn't appear to be the %s "
				    "version--patch anyway? [n] ",
				    revision);
				if (*buf != 'y')
					fatal("aborted\n");
			}
		} else if (verbose)
			say("Good.  This file appears to be the %s version.\n",
			    revision);
	}
	fseek(ifp, 0L, SEEK_SET);	/* rewind file */
	tireclen = maxlen;
	tibuflen = maxlen > BUFFERSIZE ? maxlen : BUFFERSIZE;
	lines_per_buf = tibuflen / maxlen;
	tibuf[0] = malloc(tibuflen + 1);
	if (tibuf[0] == NULL)
		fatal("out of memory\n");
	tibuf[1] = malloc(tibuflen + 1);
	if (tibuf[1] == NULL)
		fatal("out of memory\n");
	for (i = 1;; i++) {
		p = tibuf[0] + maxlen * (i % lines_per_buf);
		if (i % lines_per_buf == 0)	/* new block */
			if (write(tifd, tibuf[0], tibuflen) !=
			    (ssize_t) tibuflen)
				pfatal("can't write temp file");
		if (fgets(p, maxlen + 1, ifp) == NULL) {
			input_lines = i - 1;
			if (i % lines_per_buf != 0)
				if (write(tifd, tibuf[0], tibuflen) !=
				    (ssize_t) tibuflen)
					pfatal("can't write temp file");
			break;
		}
		j = strlen(p);
		/* These are '\n' terminated strings, so no need to add a NUL */
		if (j == 0 || p[j - 1] != '\n')
			p[j] = '\n';
	}
	fclose(ifp);
	close(tifd);
	if ((tifd = open(TMPINNAME, O_RDONLY)) < 0)
		pfatal("can't reopen file %s", TMPINNAME);
}

/*
 * Fetch a line from the input file, \n terminated, not necessarily \0.
 */
char *
ifetch(LINENUM line, int whichbuf)
{
	if (line < 1 || line > input_lines) {
		if (warn_on_invalid_line) {
			say("No such line %ld in input file, ignoring\n", line);
			warn_on_invalid_line = false;
		}
		return NULL;
	}
	if (using_plan_a)
		return i_ptr[line];
	else {
		LINENUM	offline = line % lines_per_buf;
		LINENUM	baseline = line - offline;

		if (tiline[0] == baseline)
			whichbuf = 0;
		else if (tiline[1] == baseline)
			whichbuf = 1;
		else {
			tiline[whichbuf] = baseline;

			if (lseek(tifd, (off_t) (baseline / lines_per_buf *
			    tibuflen), SEEK_SET) < 0)
				pfatal("cannot seek in the temporary input file");

			if (read(tifd, tibuf[whichbuf], tibuflen)
			    != (ssize_t) tibuflen)
				pfatal("error reading tmp file %s", TMPINNAME);
		}
		return tibuf[whichbuf] + (tireclen * offline);
	}
}

/*
 * True if the string argument contains the revision number we want.
 */
static bool
rev_in_string(const char *string)
{
	const char	*s;
	size_t		patlen;

	if (revision == NULL)
		return true;
	patlen = strlen(revision);
	if (strnEQ(string, revision, patlen) &&
	    isspace((unsigned char)string[patlen]))
		return true;
	for (s = string; *s; s++) {
		if (isspace((unsigned char)*s) && strnEQ(s + 1, revision, patlen) &&
		    isspace((unsigned char)s[patlen + 1])) {
			return true;
		}
	}
	return false;
}
@


1.3
log
@fastmerge
@
text
@d48 1
a48 1
__RCSID("$MirOS: src/usr.bin/patch/inp.c,v 1.2 2005/06/08 10:37:53 tg Exp $");
d55 1
d243 1
a243 1
		i_ptr[++iline] = "";
@


1.2
log
@work on Interix:
* missing <signal.h>
* no SIZE_MAX but SIZE_T_MAX (we also have SIZE_T_MAX on MirOS,
  but SIZE_MAX is the BSD idiom thus stays, and requires less changes)
* don't perror() on mmap failure, it's normal, and there is
  always Plan B (how nice...)

Openmotif still doesn't build, but that's probably because
I don't have XFree86 4.5 installed on Interix (yet!!!)
@
text
@d1 1
a1 2
/**	$MirOS$ */
/*	$OpenBSD: inp.c,v 1.32 2004/08/05 21:47:24 deraadt Exp $	*/
d5 1
a5 1
 *
d7 1
a7 1
 *
d12 1
a12 1
 *
d24 1
a24 1
 *
a35 1
#include <limits.h>
d37 1
d48 1
a48 1
__RCSID("$MirOS$");
d59 3
a61 2
static LINENUM	lines_per_buf;	/* how many lines per buffer */
static int	tireclen;	/* length of records in tmp file */
a76 1
		i_size = 0;
d83 1
d96 1
a96 1
/* Constuct the line index, somehow or other. */
d116 1
a116 1
	p = realloc(i_ptr, (new_size + 2) * sizeof(char *));
d136 1
a136 2
	char		*p, *s, lbuf[MAXLINELEN];
	LINENUM		iline;
d140 1
a140 1
	size_t		lines_allocated;
d163 1
a163 1
		close(creat(filename, 0666));
d166 2
a167 66
	if (statfailed && check_only)
		fatal("%s not found, -C mode, can't probe further\n", filename);
	/* For nonexistent or read-only files, look for RCS or SCCS versions.  */
	if (statfailed ||
	    /* No one can write to it.  */
	    (filestat.st_mode & 0222) == 0 ||
	    /* I can't write to it.  */
	    ((filestat.st_mode & 0022) == 0 && filestat.st_uid != getuid())) {
		char	*cs = NULL, *filebase, *filedir;
		struct stat	cstat;

		filebase = basename(filename);
		filedir = dirname(filename);

		/* Leave room in lbuf for the diff command.  */
		s = lbuf + 20;

#define try(f, a1, a2, a3) \
	(snprintf(s, sizeof lbuf - 20, f, a1, a2, a3), stat(s, &cstat) == 0)

		if (try("%s/RCS/%s%s", filedir, filebase, RCSSUFFIX) ||
		    try("%s/RCS/%s%s", filedir, filebase, "") ||
		    try("%s/%s%s", filedir, filebase, RCSSUFFIX)) {
			snprintf(buf, sizeof buf, CHECKOUT, filename);
			snprintf(lbuf, sizeof lbuf, RCSDIFF, filename);
			cs = "RCS";
		} else if (try("%s/SCCS/%s%s", filedir, SCCSPREFIX, filebase) ||
		    try("%s/%s%s", filedir, SCCSPREFIX, filebase)) {
			snprintf(buf, sizeof buf, GET, s);
			snprintf(lbuf, sizeof lbuf, SCCSDIFF, s, filename);
			cs = "SCCS";
		} else if (statfailed)
			fatal("can't find %s\n", filename);
		/*
		 * else we can't write to it but it's not under a version
		 * control system, so just proceed.
		 */
		if (cs) {
			if (!statfailed) {
				if ((filestat.st_mode & 0222) != 0)
					/* The owner can write to it.  */
					fatal("file %s seems to be locked "
					    "by somebody else under %s\n",
					    filename, cs);
				/*
				 * It might be checked out unlocked.  See if
				 * it's safe to check out the default version
				 * locked.
				 */
				if (verbose)
					say("Comparing file %s to default "
					    "%s version...\n",
					    filename, cs);
				if (system(lbuf))
					fatal("can't check out file %s: "
					    "differs from default %s version\n",
					    filename, cs);
			}
			if (verbose)
				say("Checking out file %s from %s...\n",
				    filename, cs);
			if (system(buf) || stat(filename, &filestat))
				fatal("can't check out file %s from %s\n",
				    filename, cs);
		}
	}
d184 3
a186 2
	i_womp = mmap(NULL, i_size, PROT_READ, MAP_PRIVATE, ifd, 0);
	if (i_womp == MAP_FAILED) {
d188 1
a188 1
		perror("mmap failed");
d190 5
a195 2
		close(ifd);
		return false;
d251 1
a251 1
		if (!rev_in_string(i_womp)) {
d281 2
a282 2
	int	i = 0, j, maxlen = 1;
	char	*p;
d291 15
a305 2
	while (fgets(buf, sizeof buf, ifp) != NULL) {
		if (revision != NULL && !found_revision && rev_in_string(buf))
d307 2
a308 2
		if ((i = strlen(buf)) > maxlen)
			maxlen = i;	/* find longest line */
d310 3
a312 3
	last_line_missing_eol = i > 0 && buf[i - 1] != '\n';
	if (last_line_missing_eol && maxlen == i)
		maxlen++;
a336 1
	lines_per_buf = BUFFERSIZE / maxlen;
d338 3
a340 1
	tibuf[0] = malloc(BUFFERSIZE + 1);
d343 1
a343 1
	tibuf[1] = malloc(BUFFERSIZE + 1);
d349 2
a350 1
			if (write(tifd, tibuf[0], BUFFERSIZE) < BUFFERSIZE)
d355 2
a356 1
				if (write(tifd, tibuf[0], BUFFERSIZE) < BUFFERSIZE)
d397 3
a399 2
			lseek(tifd, (off_t) (baseline / lines_per_buf *
			    BUFFERSIZE), SEEK_SET);
d401 2
a402 1
			if (read(tifd, tibuf[whichbuf], BUFFERSIZE) < 0)
d416 1
a416 1
	int		patlen;
d421 2
a422 1
	if (strnEQ(string, revision, patlen) && isspace(string[patlen]))
d425 2
a426 2
		if (isspace(*s) && strnEQ(s + 1, revision, patlen) &&
		    isspace(s[patlen + 1])) {
@


1.1
log
@Initial revision
@
text
@d1 1
d6 1
a6 1
 * 
d8 1
a8 1
 * 
d13 1
a13 1
 * 
d25 1
a25 1
 * 
a29 4
#ifndef lint
static const char rcsid[] = "$OpenBSD: inp.c,v 1.32 2004/08/05 21:47:24 deraadt Exp $";
#endif /* not lint */

d49 1
d251 1
d253 1
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import latest patch(1) from OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: inp.c,v 1.45 2015/11/11 01:12:10 deraadt Exp $	*/
d29 4
d40 1
a41 1
#include <stdint.h>
d62 2
a63 3
static size_t	lines_per_buf;	/* how many lines per buffer */
static size_t	tibuflen;	/* plan b buffer length */
static size_t	tireclen;	/* length of records in tmp file */
d79 1
a85 1
		i_size = 0;
d98 1
a98 1
/* Construct the line index, somehow or other. */
d118 1
a118 1
	p = reallocarray(i_ptr, new_size + 2, sizeof(char *));
d138 2
a139 1
	char		*p, *s;
d143 1
a143 1
	size_t		iline, lines_allocated;
d166 1
a166 1
		close(open(filename, O_CREAT | O_TRUNC | O_WRONLY, 0666));
d169 66
a234 2
	if (statfailed)
		fatal("can't find %s\n", filename);
d251 3
a253 9
	if (i_size) {
		i_womp = mmap(NULL, i_size, PROT_READ, MAP_PRIVATE, ifd, 0);
		if (i_womp == MAP_FAILED) {
			perror("mmap failed");
			i_womp = NULL;
			close(ifd);
			return false;
		}
	} else {
d255 2
d312 1
a312 1
		if (i_womp == NULL || !rev_in_string(i_womp)) {
d342 2
a343 2
	size_t	i = 0, j, len, maxlen = 1;
	char	*lbuf = NULL, *p;
d352 2
a353 15
	while ((p = fgetln(ifp, &len)) != NULL) {
		if (p[len - 1] == '\n')
			p[len - 1] = '\0';
		else {
			/* EOF without EOL, copy and add the NUL */
			if ((lbuf = malloc(len + 1)) == NULL)
				fatal("out of memory\n");
			memcpy(lbuf, p, len);
			lbuf[len] = '\0';
			p = lbuf;

			last_line_missing_eol = true;
			len++;
		}
		if (revision != NULL && !found_revision && rev_in_string(p))
d355 2
a356 2
		if (len > maxlen)
			maxlen = len;	/* find longest line */
d358 3
a360 3
	free(lbuf);
	if (ferror(ifp))
		pfatal("can't read file %s", filename);
d385 1
d387 1
a387 3
	tibuflen = maxlen > BUFFERSIZE ? maxlen : BUFFERSIZE;
	lines_per_buf = tibuflen / maxlen;
	tibuf[0] = malloc(tibuflen + 1);
d390 1
a390 1
	tibuf[1] = malloc(tibuflen + 1);
d396 1
a396 2
			if (write(tifd, tibuf[0], tibuflen) !=
			    (ssize_t) tibuflen)
d401 1
a401 2
				if (write(tifd, tibuf[0], tibuflen) !=
				    (ssize_t) tibuflen)
d442 2
a443 3
			if (lseek(tifd, (off_t) (baseline / lines_per_buf *
			    tibuflen), SEEK_SET) < 0)
				pfatal("cannot seek in the temporary input file");
d445 1
a445 2
			if (read(tifd, tibuf[whichbuf], tibuflen)
			    != (ssize_t) tibuflen)
d459 1
a459 1
	size_t		patlen;
d464 1
a464 2
	if (strnEQ(string, revision, patlen) &&
	    isspace((unsigned char)string[patlen]))
d467 2
a468 2
		if (isspace((unsigned char)*s) && strnEQ(s + 1, revision, patlen) &&
		    isspace((unsigned char)s[patlen + 1])) {
@

