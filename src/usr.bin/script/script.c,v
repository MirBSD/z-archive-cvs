head	1.15;
access;
symbols
	MIRBSD_10:1.14.0.2
	MIRBSD_10_BASE:1.14
	cvs-200702131500:1.1.1.3
	MIRBSD_9_BASE:1.1.1.2
	MIRBSD_8:1.1.1.2.0.2
	MIRBSD_8_BASE:1.1.1.2
	cvs-200507211800:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2013.10.31.20.07.09;	author tg;	state Exp;
branches;
next	1.14;
commitid	1005272B7081B0E5655;

1.14
date	2008.02.24.15.16.10;	author tg;	state Exp;
branches;
next	1.13;
commitid	10047C18A203B13B9CC;

1.13
date	2007.03.09.11.56.27;	author tg;	state Exp;
branches;
next	1.12;
commitid	10045F14B7F7F0C6C04;

1.12
date	2007.03.06.03.15.11;	author tg;	state Exp;
branches;
next	1.11;
commitid	10045ECDCC6462235F3;

1.11
date	2007.03.06.01.29.36;	author tg;	state Exp;
branches;
next	1.10;
commitid	10045ECC41742DC7DBB;

1.10
date	2007.03.06.01.23.20;	author tg;	state Exp;
branches;
next	1.9;
commitid	10045ECC29F7B37B49D;

1.9
date	2007.03.06.01.14.32;	author tg;	state Exp;
branches;
next	1.8;
commitid	10045ECC06805A12788;

1.8
date	2007.02.18.01.52.51;	author tg;	state Exp;
branches;
next	1.7;
commitid	10045D7B17F3B345C71;

1.7
date	2007.02.18.01.28.42;	author tg;	state Exp;
branches;
next	1.6;
commitid	10045D7ABC9614FC4E9;

1.6
date	2007.02.13.17.30.46;	author tg;	state Exp;
branches;
next	1.5;
commitid	10045D1F5C265A941D8;

1.5
date	2007.02.13.17.10.04;	author tg;	state Exp;
branches;
next	1.4;
commitid	10045D1F0F0741E96DF;

1.4
date	2007.02.13.17.06.00;	author tg;	state Exp;
branches;
next	1.3;
commitid	10045D1F00366859D64;

1.3
date	2007.02.13.16.48.20;	author tg;	state Exp;
branches;
next	1.2;
commitid	10045D1EB8D18E8A339;

1.2
date	2007.02.13.15.32.03;	author tg;	state Exp;
branches;
next	1.1;
commitid	10045D1DA04032C7D05;

1.1
date	2005.02.05.17.29.49;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.29.49;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.07.21.21.00.14;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	560042e0092f571e;

1.1.1.3
date	2007.02.13.15.12.40;	author tg;	state Exp;
branches;
next	;
commitid	10045D1D57970BA443E;


desc
@@


1.15
log
@adapt most __attribute__((…)) occurrences to new KNF style(9)
@
text
@/*	$OpenBSD: script.c,v 1.24 2005/12/12 20:10:53 deraadt Exp $	*/
/*	$NetBSD: script.c,v 1.3 1994/12/21 08:55:43 jtc Exp $	*/

/*-
 * Copyright © 2007, 2008, 2013
 *	Thorsten “mirabilos” Glaser <tg@@mirbsd.org>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 */

/*
 * Copyright (c) 2001 Theo de Raadt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1980, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
__COPYRIGHT("@@(#) Copyright (c) 1980, 1992, 1993\n\
	The Regents of the University of California.  All rights reserved.\n");
__SCCSID("@@(#)script.c	8.1 (Berkeley) 6/6/93");
__RCSID("$MirOS: src/usr.bin/script/script.c,v 1.14 2008/02/24 15:16:10 tg Exp $");

#include <sys/time.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/wait.h>

#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <signal.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <time.h>
#include <unistd.h>
#ifndef NO_CONV
#include <wchar.h>
#endif

#include <util.h>
#include <err.h>

FILE *fscript;
int master, slave;
volatile sig_atomic_t child;
pid_t subchild;
const char *fname;
bool do_loginshell = false;
const char *shcmd = NULL;

#ifndef NO_CONV
bool l1mode = false;
bool lumode = false;
const char *l1rep = "?";
size_t l1rlen = 1;
#else
#define l1mode	0
#define lumode	0
#endif

volatile sig_atomic_t dead;
volatile sig_atomic_t sigdeadstatus;
volatile sig_atomic_t flush;

struct termios tt;

void done(int) __attribute__((__noreturn__));
void dooutput(void) __attribute__((__noreturn__));
void doinput(void) __attribute__((__noreturn__));
void doshell(void) __attribute__((__noreturn__));
void fail(void) __attribute__((__noreturn__));
void finish(int);
void scriptflush(int);
void handlesigwinch(int);
void usage(void) __attribute__((__noreturn__));

#ifdef SMALL
#undef DEBUG
#else
bool qflg = false;
#endif

#ifdef DEBUG
#define dump(buf, len)	__dump(#buf, __func__, buf, len)
static void __dump(const char *, const char *, const uint8_t *, size_t);
#else
#define dump(buf, len)	/* nothing */
#endif

int
main(int argc, char *argv[])
{
	struct sigaction sa;
	struct termios rtt;
	struct winsize win;
	int aflg, nflg, ch;

#ifndef NO_CONV
#if !defined(MirBSD) || (MirBSD < 0x09AB)
#if 0
	extern bool __locale_is_utf8;
	__locale_is_utf8 = true;
#else
#error Need at least MirOS #9uAB locale support!
#endif
#endif
#endif

	aflg = nflg = 0;
	while ((ch = getopt(argc, argv, "ac:L:lnqsU:u")) != -1)
		switch(ch) {
		case 'a':
			aflg = 1;
			break;
		case 'c':
			shcmd = optarg;
			break;
#ifndef NO_CONV
		case 'L':
			l1rep = optarg;
			l1rlen = strlen(l1rep);
			/* FALLTHRU */
		case 'l':
			l1mode = true;
			lumode = false;
			break;
#endif
		case 'n':
			nflg = 1;
			break;
		case 'q':
#ifndef SMALL
			qflg = true;
#endif
			break;
		case 's':
			do_loginshell = true;
			break;
#ifndef NO_CONV
		case 'U':
			l1rep = optarg;
			l1rlen = strlen(l1rep);
			/* FALLTHRU */
		case 'u':
			lumode = true;
			l1mode = false;
			break;
#endif
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	if (nflg) {
		if (argc > 0)
			usage();
		fscript = NULL;
		fname = "";
	} else {
		if (argc > 0)
			fname = argv[0];
		else
			fname = "typescript";

		if ((fscript = fopen(fname, aflg ? "a" : "w")) == NULL)
			err(1, "%s", fname);
	}

	tcgetattr(STDIN_FILENO, &tt);
	ioctl(STDIN_FILENO, TIOCGWINSZ, &win);
	if (openpty(&master, &slave, NULL, &tt, &win) == -1)
		err(1, "openpty");

#ifndef SMALL
	if (!qflg)
		printf("Script started, %s%s%s\n",
#ifndef NO_CONV
		    l1mode ? "latin1 mode, " : lumode ? "luit mode, " :
#endif
		    "", fscript ? "output file is " : "no output file", fname);
#endif
	rtt = tt;
	cfmakeraw(&rtt);
	rtt.c_lflag &= ~ECHO;
	tcsetattr(STDIN_FILENO, TCSAFLUSH, &rtt);

	bzero(&sa, sizeof sa);
	sigemptyset(&sa.sa_mask);
	sa.sa_handler = finish;
	sigaction(SIGCHLD, &sa, NULL);

	sa.sa_handler = handlesigwinch;
	sa.sa_flags = SA_RESTART;
	sigaction(SIGWINCH, &sa, NULL);

	child = fork();
	if (child < 0) {
		warn("fork");
		fail();
	}
	if (child == 0) {
		subchild = child = fork();
		if (child < 0) {
			warn("fork");
			fail();
		}
		if (child)
			dooutput();
		else
			doshell();
		/* NOTREACHED */
	}
	doinput();
	/* NOTREACHED */
}

void
doinput(void)
{
	ssize_t cc, off;
	unsigned char ibuf[BUFSIZ];
	unsigned char *ubuf = NULL;
#ifndef NO_CONV
	unsigned char cbuf[BUFSIZ * 2];
	mbstate_t state = { 0, 0 };
#else
	unsigned char *cbuf = NULL;	/* to quieten gcc */
#endif

#ifndef NO_CONV
	if (lumode) {
		/* this formula works because wcwidth(U+0000..U+00FF)<2 */
		cc = l1rlen < 1 ? 1 : l1rlen;
		if ((ubuf = calloc(BUFSIZ, cc)) == NULL)
			err(1, "cannot allocate %zd*%zd bytes for"
			    " conversion buffer", cc, (ssize_t)BUFSIZ);
	}
#endif
	if (fscript)
		fclose(fscript);
	for (;;) {
		if (dead)
			break;
		cc = read(STDIN_FILENO, ibuf, BUFSIZ);
		if (cc == -1 && errno == EINTR)
			continue;
		if (cc <= 0)
			break;
#ifndef NO_CONV
		if (l1mode) {
			unsigned char *cp = cbuf;

			for (off = 0; off < cc; ++off)
				cp += wcrtomb((char *)cp, ibuf[off], &state);
			dump(ibuf, cc);
			cc = cp - cbuf;
			dump(cbuf, cc);
		} else if (lumode) {
			unsigned char *cp = ibuf;
			unsigned char *lp = ubuf;
			size_t n;
			wchar_t wc;

			off = cc;
			dump(ibuf, cc);
			while (off) {
				n = mbrtowc(&wc, (char *)cp, off, &state);

				if (n == 0) {
					n = 1;
					wc = 0;
				} else if (n == (size_t)-1) {
					n = 1;
					wc = 0xFFFD;
					state.count = 0;
				} else if (n == (size_t)-2)
					break;
				off -= n;
				cp += n;
				if (wc < 0x0100)
					*lp++ = wc;
				else for (cc = 0; cc < wcwidth(wc); ++cc) {
					/* what about wcwidth==(-1) C0/C1? */
					memcpy(lp, l1rep, l1rlen);
					lp += l1rlen;
				}
			}
			cc = lp - ubuf;
			dump(ubuf, cc);
		}
#endif
		for (off = 0; off < cc; ) {
			ssize_t n = write(master,
			    (l1mode ? cbuf : lumode ? ubuf : ibuf) + off,
			    cc - off);
			if (n == -1 && errno != EAGAIN)
				break;
			if (n == 0)
				break;	/* skip writing */
			if (n > 0)
				off += n;
		}
	}
#ifndef NO_CONV
	if (lumode && state.count)
		/* incomplete multibyte char on exit */
		write(master, l1rep, l1rlen);
#endif
	done(sigdeadstatus);
}

/* ARGSUSED */
void
finish(int signo __attribute__((__unused__)))
{
	int save_errno = errno;
	int status, e = 1;
	pid_t pid;

	while ((pid = wait3(&status, WNOHANG, 0)) > 0) {
		if (pid == (pid_t)child) {
			if (WIFEXITED(status))
				e = WEXITSTATUS(status);
		}
	}
	dead = 1;
	sigdeadstatus = e;
	errno = save_errno;
}

/* ARGSUSED */
void
handlesigwinch(int signo __attribute__((__unused__)))
{
	int save_errno = errno;
	struct winsize win;
	pid_t pgrp;

	if (ioctl(STDIN_FILENO, TIOCGWINSZ, &win) != -1) {
		ioctl(slave, TIOCSWINSZ, &win);
		if (ioctl(slave, TIOCGPGRP, &pgrp) != -1)
			killpg(pgrp, SIGWINCH);
	}
	errno = save_errno;
}

void
dooutput(void)
{
	struct sigaction sa;
	struct itimerval value;
	sigset_t blkalrm;
	unsigned char obuf[BUFSIZ];
	unsigned char *cbuf = NULL;
#ifndef SMALL
	time_t tvec;
#endif
#ifndef NO_CONV
	unsigned char ubuf[BUFSIZ * 2];
	mbstate_t state = { 0, 0 };
#else
	unsigned char *ubuf = NULL;	/* to quieten gcc */
#endif
	ssize_t outcc = 0, cc, fcc, off;

#ifndef NO_CONV
	if (l1mode) {
		/* this formula works because wcwidth(U+0000..U+00FF)<2 */
		cc = l1rlen < 1 ? 1 : l1rlen;
		if ((cbuf = calloc(BUFSIZ, cc)) == NULL)
			err(1, "cannot allocate %zd*%zd bytes for"
			    " conversion buffer", cc, (ssize_t)BUFSIZ);
	}
#endif
	close(STDIN_FILENO);
	close(slave);
	if (fscript) {
#ifndef SMALL
		tvec = time(NULL);
		if (!qflg)
			fprintf(fscript, "Script started on %s", ctime(&tvec));
#endif

		sigemptyset(&blkalrm);
		sigaddset(&blkalrm, SIGALRM);
		bzero(&sa, sizeof sa);
		sigemptyset(&sa.sa_mask);
		sa.sa_handler = scriptflush;
		sigaction(SIGALRM, &sa, NULL);

		value.it_interval.tv_sec = 30;
		value.it_interval.tv_usec = 0;
		value.it_value = value.it_interval;
		setitimer(ITIMER_REAL, &value, NULL);
	}
	for (;;) {
		if (fscript && flush) {
			if (outcc) {
				fflush(fscript);
				outcc = 0;
			}
			flush = 0;
		}
		fcc = cc = read(master, obuf, sizeof (obuf));
		if (cc == -1 && errno == EINTR)
			continue;
		if (cc <= 0)
			break;
		if (fscript)
			sigprocmask(SIG_BLOCK, &blkalrm, NULL);
#ifndef NO_CONV
		if (l1mode) {
			unsigned char *cp = obuf;
			unsigned char *lp = cbuf;
			size_t n;
			wchar_t wc;

			off = cc;
			dump(obuf, cc);
			while (off) {
				n = mbrtowc(&wc, (char *)cp, off, &state);

				if (n == 0) {
					n = 1;
					wc = 0;
				} else if (n == (size_t)-1) {
					n = 1;
					wc = 0xFFFD;
					state.count = 0;
				} else if (n == (size_t)-2)
					break;
				off -= n;
				cp += n;
				if (wc < 0x0100)
					*lp++ = wc;
				else for (cc = 0; cc < wcwidth(wc); ++cc) {
					/* what about wcwidth==(-1) C0/C1? */
					memcpy(lp, l1rep, l1rlen);
					lp += l1rlen;
				}
			}
			cc = lp - cbuf;
			dump(cbuf, cc);
		} else if (lumode) {
			unsigned char *cp = ubuf;

			for (off = 0; off < cc; ++off)
				cp += wcrtomb((char *)cp, obuf[off], &state);
			dump(obuf, cc);
			cc = cp - ubuf;
			dump(ubuf, cc);
		}
#endif
		for (off = 0; off < cc; ) {
			ssize_t n = write(STDOUT_FILENO,
			    (l1mode ? cbuf : lumode ? ubuf : obuf) + off,
			    cc - off);
			if (n == -1 && errno != EAGAIN)
				break;
			if (n == 0)
				break;	/* skip writing */
			if (n > 0)
				off += n;
		}
		if (fscript) {
			fwrite(obuf, 1, fcc, fscript);
			outcc += cc;
			sigprocmask(SIG_UNBLOCK, &blkalrm, NULL);
		}
	}
#ifndef NO_CONV
	if (l1mode && state.count)
		/* incomplete multibyte char on exit */
		write(STDOUT_FILENO, l1rep, l1rlen);
#endif
	done(0);
}

/* ARGSUSED */
void
scriptflush(int signo __attribute__((__unused__)))
{
	flush = 1;
}

void
doshell(void)
{
	const char *shell, *shargv0;
	char *cp;

	shell = getenv("SHELL");
	if (shell == NULL)
		shell = _PATH_BSHELL;

	close(master);
	if (fscript)
		fclose(fscript);
	login_tty(slave);

	if (!do_loginshell)
		shargv0 = shell;
	else if ((shargv0 = cp = calloc(1, 1 + strlen(shell) + 1)) == NULL) {
		warn("out of memory");
		fail();
	} else {
		*cp++ = '-';
		memcpy(cp, shell, strlen(shell) + 1);
	}

	if (shcmd)
		execl(shell, shargv0, "-c", shcmd, NULL);
	else
		execl(shell, shargv0, "-i", NULL);
	warn("%s%s%s", shargv0, shcmd ? " -c " : " -i", shcmd ? shcmd : "");
	fail();
}

void
fail(void)
{
	kill(0, SIGTERM);
	done(1);
}

void
done(int eval)
{
	if (subchild) {
		if (fscript) {
#ifndef SMALL
			time_t tvec;

			tvec = time(NULL);
			if (!qflg)
				fprintf(fscript,"\nScript done on %s",
				    ctime(&tvec));
#endif
			fclose(fscript);
		}
		close(master);
	} else {
		tcsetattr(STDIN_FILENO, TCSAFLUSH, &tt);
#ifndef SMALL
		if (!qflg)
			printf("Script done, %s%s\n",
			    fscript ? "output file is " : "no output file",
			    fname);
#endif
	}
	exit(eval);
}

void
usage(void)
{
#ifdef SMALL
	const char usage_str[] = "usage: script"
#else
	extern const char *__progname;
	fprintf(stderr, "usage: %s"
#endif
#ifdef NO_CONV
	    " [-as] [-c cmd] [-n | file]\n"
#else
	    " [-als] [-c cmd] [-L replstr] [-n | file]\n"
#endif
#ifdef SMALL
	    ;
	fwrite(usage_str, 1, sizeof (usage_str) - 1, stderr);
#else
	    , __progname);
#endif
	exit(1);
}

#ifdef DEBUG
static void
__dump(const char *name, const char *func, const uint8_t *buf, size_t len)
{
	size_t n = 0;

	fflush(NULL);
#if 0
	fprintf(stderr, "  dumping buffer <%s> in %s()", name, func);
	while (n < len)
		fprintf(stderr, "%s%02X",
		    n++ & 15 ? " " : "\r\n  ",
		    *buf++);
	fprintf(stderr, "\r\n");
#else
	fprintf(stderr, "{%s():%s[] =", func, name);
	while (n++ < len)
		fprintf(stderr, " %02X", *buf++);
	fprintf(stderr, "}");
#endif
	fflush(NULL);
}
#endif
@


1.14
log
@support -[Uu] which do the same as -[Ll] for the other direction instead.
XXX use one buffer instead of cbuf+ubuf
@
text
@d5 2
a6 2
 * Copyright (c) 2007, 2008
 *	Thorsten Glaser <tg@@mirbsd.de>
d82 1
a82 1
__RCSID("$MirOS: src/usr.bin/script/script.c,v 1.13 2007/03/09 11:56:27 tg Exp $");
d131 5
a135 5
void done(int) __attribute__((noreturn));
void dooutput(void) __attribute__((noreturn));
void doinput(void) __attribute__((noreturn));
void doshell(void) __attribute__((noreturn));
void fail(void) __attribute__((noreturn));
d139 1
a139 1
void usage(void) __attribute__((noreturn));
d379 1
a379 1
finish(int signo __attribute__((unused)))
d398 1
a398 1
handlesigwinch(int signo __attribute__((unused)))
d546 1
a546 1
scriptflush(int signo __attribute__((unused)))
@


1.13
log
@partial sync
@
text
@d5 1
a5 1
 * Copyright (c) 2007
d82 1
a82 1
__RCSID("$MirOS: src/usr.bin/script/script.c,v 1.12 2007/03/06 03:15:11 tg Exp $");
d117 1
d122 1
d168 1
a168 1
#error Need at least MirOS #9uAB locale support!*/
d174 1
a174 1
	while ((ch = getopt(argc, argv, "ac:L:lnqs")) != -1)
d189 1
d203 10
d243 1
a243 1
		    l1mode ? "latin1 mode, " :
d287 1
d295 9
d323 32
d359 2
a360 1
			    (l1mode ? cbuf : ibuf) + off, cc - off);
d369 5
d424 1
d426 2
d509 8
d521 2
a522 1
			     (l1mode ? cbuf : obuf) + off, cc - off);
@


1.12
log
@• add a close(slave); where it's not needed
• implement -q (quiet)
@
text
@d82 1
a82 1
__RCSID("$MirOS: src/usr.bin/script/script.c,v 1.11 2007/03/06 01:29:36 tg Exp $");
d361 1
a364 1
#endif
@


1.11
log
@improve portability
@
text
@d82 1
a82 1
__RCSID("$MirOS: src/usr.bin/script/script.c,v 1.10 2007/03/06 01:23:20 tg Exp $");
d141 2
d172 1
a172 1
	while ((ch = getopt(argc, argv, "ac:L:lns")) != -1)
d192 5
d227 2
a228 1
	printf("Script started, %s%s%s\n",
d230 1
a230 1
	    l1mode ? "latin1 mode, " :
d232 1
a232 3
	    "",
	    fscript ? "output file is " : "no output file",
	    fname);
d377 1
d381 2
a382 1
		fprintf(fscript, "Script started on %s", ctime(&tvec));
d527 3
a529 1
			fprintf(fscript,"\nScript done on %s", ctime(&tvec));
d537 4
a540 2
		printf("Script done, %s%s\n",
		    fscript ? "output file is " : "no output file", fname);
@


1.10
log
@uh, SECSPERMIN should be constant
@
text
@d82 1
a82 1
__RCSID("$MirOS: src/usr.bin/script/script.c,v 1.9 2007/03/06 01:14:32 tg Exp $");
d98 1
d129 5
a133 5
__dead void done(int);
__dead void dooutput(void);
__dead void doinput(void);
__dead void doshell(void);
__dead void fail(void);
d137 1
a137 1
__dead void usage(void);
@


1.9
log
@new #ifdef NO_CONV to use this on other OSes without our kewl I18N stuff,
because of e.g. the -c option (yes I do have something in mind for this…)
@
text
@d82 1
a82 1
__RCSID("$MirOS: src/usr.bin/script/script.c,v 1.8 2007/02/18 01:52:51 tg Exp $");
a97 1
#include <tzfile.h>
d383 1
a383 1
		value.it_interval.tv_sec = SECSPERMIN / 2;
@


1.8
log
@new option -s: do a login shell (- before shell argv[0])
@
text
@d82 1
a82 1
__RCSID("$MirOS: src/usr.bin/script/script.c,v 1.7 2007/02/18 01:28:42 tg Exp $");
d84 3
a87 3
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/time.h>
d100 1
d102 1
d107 2
a108 2
FILE	*fscript;
int	master, slave;
d110 1
a110 1
pid_t	subchild;
d115 1
d119 3
d127 1
a127 1
struct	termios tt;
d158 1
d167 1
d178 1
d186 1
d221 4
a224 1
	    l1mode ? "latin1 mode, " : "",
d268 1
d271 3
d285 1
d295 1
d355 3
a359 1
	mbstate_t state = { 0, 0 };
d361 1
d369 1
d404 1
d438 1
d455 1
d459 1
d543 3
d547 1
@


1.7
log
@#ifdef SMALL save all printf(3) and fprintf(3) calls
(script started/stopped on <time>, etc.) and shrink usage
@
text
@d82 1
a82 1
__RCSID("$MirOS: src/usr.bin/script/script.c,v 1.6 2007/02/13 17:30:46 tg Exp $");
d110 1
d162 1
a162 1
	while ((ch = getopt(argc, argv, "ac:L:ln")) != -1)
d180 3
d446 2
a447 1
	const char *shell;
d457 11
d469 1
a469 1
		execl(shell, shell, "-c", shcmd, NULL);
d471 2
a472 2
		execl(shell, shell, "-i", NULL);
	warn("%s%s%s", shell, shcmd ? " -c " : " -i", shcmd ? shcmd : "");
d516 1
a516 1
	    " [-al] [-c cmd] [-L replstr] [-n | file]\n"
@


1.6
log
@add option -c (like sh -c)
now the mksh regression test hack I've done with GNU screen for Debian
could be done with script as well
@
text
@d82 1
a82 1
__RCSID("$MirOS: src/usr.bin/script/script.c,v 1.5 2007/02/13 17:10:04 tg Exp $");
d132 4
d205 1
d210 1
d330 1
d332 1
d345 1
d348 1
a469 2
	time_t tvec;

d472 3
d477 1
d483 1
d486 1
d494 3
d498 9
a506 2
	fprintf(stderr, "usage: %s [-al] [-c cmd] [-L replstr] [-n | file]\n",
	    __progname);
@


1.5
log
@#if out debugging code, add comments
@
text
@d82 1
a82 1
__RCSID("$MirOS: src/usr.bin/script/script.c,v 1.4 2007/02/13 17:06:00 tg Exp $");
d110 1
d157 1
a157 1
	while ((ch = getopt(argc, argv, "aL:ln")) != -1)
d162 3
d442 5
a446 2
	execl(shell, shell, "-i", NULL);
	warn("%s", shell);
d481 1
a481 1
	fprintf(stderr, "usage: %s [-al] [-L replstr] [-n | file]\n",
@


1.4
log
@handle and document handling of non-1-column-wide chars
@
text
@d82 1
a82 1
__RCSID("$MirOS: src/usr.bin/script/script.c,v 1.3 2007/02/13 16:48:20 tg Exp $");
d147 1
a147 1
#if 1
d325 1
d388 1
@


1.3
log
@Implement
* -n: do not log typescript output
* -l / -L <replstr>: enable latin1 tty<->pty utf-8 conversion;
  invalid chars are replaced with <replstr> (default '?', but
  e.g. '<ESC>[7m?<ESC>[0m' works as well)
* mention luit(1) and GNU screen in TFM
@
text
@d82 1
a82 1
__RCSID("$MirOS: src/usr.bin/script/script.c,v 1.2 2007/02/13 15:32:03 tg Exp $");
d147 1
a147 1
#if 0
d386 1
a386 1
				else {
@


1.2
log
@MirOSify, make __CRAZY clean
@
text
@d4 20
d78 1
a78 1
#include <sys/cdefs.h>
d82 1
a82 1
__RCSID("$MirOS$");
a83 1
#include <sys/types.h>
d93 1
d100 1
d111 4
d123 1
d129 8
a140 1
	extern char *__progname;
d144 10
a153 3
	char ibuf[BUFSIZ];
	ssize_t cc, off;
	int aflg, ch;
d155 2
a156 2
	aflg = 0;
	while ((ch = getopt(argc, argv, "a")) != -1)
d161 10
d172 1
a172 2
			fprintf(stderr, "usage: %s [-a] [file]\n", __progname);
			exit(1);
d177 10
a186 4
	if (argc > 0)
		fname = argv[0];
	else
		fname = "typescript";
d188 3
a190 2
	if ((fscript = fopen(fname, aflg ? "a" : "w")) == NULL)
		err(1, "%s", fname);
d197 4
a200 1
	printf("Script started, output file is %s\n", fname);
d230 1
d232 3
d236 11
a246 2
	fclose(fscript);
	while (1) {
d254 9
d264 2
a265 1
			ssize_t n = write(master, ibuf + off, cc - off);
d318 2
a319 1
	char obuf[BUFSIZ];
d321 2
a322 1
	ssize_t outcc = 0, cc, off;
d324 6
d331 3
a333 2
	tvec = time(NULL);
	fprintf(fscript, "Script started on %s", ctime(&tvec));
d335 12
a346 11
	sigemptyset(&blkalrm);
	sigaddset(&blkalrm, SIGALRM);
	bzero(&sa, sizeof sa);
	sigemptyset(&sa.sa_mask);
	sa.sa_handler = scriptflush;
	sigaction(SIGALRM, &sa, NULL);

	value.it_interval.tv_sec = SECSPERMIN / 2;
	value.it_interval.tv_usec = 0;
	value.it_value = value.it_interval;
	setitimer(ITIMER_REAL, &value, NULL);
d348 1
a348 1
		if (flush) {
d355 1
a355 1
		cc = read(master, obuf, sizeof (obuf));
d360 34
a393 1
		sigprocmask(SIG_BLOCK, &blkalrm, NULL);
d395 2
a396 1
			ssize_t n = write(STDOUT_FILENO, obuf + off, cc - off);
d404 5
a408 3
		fwrite(obuf, 1, cc, fscript);
		outcc += cc;
		sigprocmask(SIG_UNBLOCK, &blkalrm, NULL);
d410 3
d433 2
a434 1
	fclose(fscript);
d436 1
a436 1
	execl(shell, shell, "-i", (char *)NULL);
d454 5
a458 3
		tvec = time(NULL);
		fprintf(fscript,"\nScript done on %s", ctime(&tvec));
		fclose(fscript);
d462 2
a463 1
		printf("Script done, output file is %s\n", fname);
d467 33
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.19 2003/06/10 22:20:50 deraadt Exp $	*/
d58 5
a62 12
#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1980, 1992, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)script.c	8.1 (Berkeley) 6/6/93";
#endif
static char rcsid[] = "$OpenBSD: script.c,v 1.19 2003/06/10 22:20:50 deraadt Exp $";
#endif /* not lint */
d86 3
a88 2
pid_t	child, subchild;
char	*fname;
d97 3
a99 3
void dooutput(void);
void doshell(void);
void fail(void);
d107 1
d122 1
a122 1
			(void)fprintf(stderr, "usage: script [-a] [file]\n");
d136 2
a137 2
	(void)tcgetattr(STDIN_FILENO, &tt);
	(void)ioctl(STDIN_FILENO, TIOCGWINSZ, &win);
d141 1
a141 1
	(void)printf("Script started, output file is %s\n", fname);
d145 1
a145 1
	(void)tcsetattr(STDIN_FILENO, TCSAFLUSH, &rtt);
d150 1
a150 1
	(void)sigaction(SIGCHLD, &sa, NULL);
d154 1
a154 1
	(void)sigaction(SIGWINCH, &sa, NULL);
d158 1
a158 1
		perror("fork");
d164 1
a164 1
			perror("fork");
d173 1
a173 1
	(void)fclose(fscript);
d184 2
d195 1
d197 1
a197 1
finish(int signo)
d204 1
a204 1
		if (pid == child) {
d214 1
d216 1
a216 1
handlesigwinch(int signo)
d235 1
d240 1
a240 1
	(void)close(STDIN_FILENO);
d242 1
a242 1
	(void)fprintf(fscript, "Script started on %s", ctime(&tvec));
d244 2
d249 1
a249 1
	(void)sigaction(SIGALRM, &sa, NULL);
d254 1
a254 1
	(void)setitimer(ITIMER_REAL, &value, NULL);
d258 1
a258 1
				(void)fflush(fscript);
d268 1
d270 3
a272 1
			ssize_t n = write(1, obuf + off, cc - off);
d278 1
a278 1
		(void)fwrite(obuf, 1, cc, fscript);
d280 1
d285 1
d287 1
a287 1
scriptflush(int signo)
d295 1
a295 1
	char *shell;
d301 2
a302 2
	(void)close(master);
	(void)fclose(fscript);
d305 1
a305 1
	perror(shell);
d312 1
a312 2

	(void)kill(0, SIGTERM);
d323 3
a325 3
		(void)fprintf(fscript,"\nScript done on %s", ctime(&tvec));
		(void)fclose(fscript);
		(void)close(master);
d327 2
a328 2
		(void)tcsetattr(STDIN_FILENO, TCSAFLUSH, &tt);
		(void)printf("Script done, output file is %s\n", fname);
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.23 2005/04/11 19:59:07 deraadt Exp $	*/
d59 1
a59 1
static const char copyright[] =
d66 1
a66 1
static const char sccsid[] = "@@(#)script.c	8.1 (Berkeley) 6/6/93";
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: script.c,v 1.23 2005/04/11 19:59:07 deraadt Exp $";
d93 1
a93 2
volatile sig_atomic_t child;
pid_t	subchild;
a112 1
	extern char *__progname;
d127 1
a127 1
			fprintf(stderr, "usage: %s [-a] [file]\n", __progname);
d163 1
a163 1
		warn("fork");
d169 1
a169 1
			warn("fork");
a197 1
/* ARGSUSED */
d206 1
a206 1
		if (pid == (pid_t)child) {
a215 1
/* ARGSUSED */
a235 1
	sigset_t blkalrm;
a243 2
	sigemptyset(&blkalrm);
	sigaddset(&blkalrm, SIGALRM);
a265 1
		sigprocmask(SIG_BLOCK, &blkalrm, NULL);
d267 1
a267 1
			ssize_t n = write(STDOUT_FILENO, obuf + off, cc - off);
a274 1
		sigprocmask(SIG_UNBLOCK, &blkalrm, NULL);
a278 1
/* ARGSUSED */
d298 1
a298 1
	warn("%s", shell);
@


1.1.1.3
log
@sync script(1) with openbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: script.c,v 1.24 2005/12/12 20:10:53 deraadt Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: script.c,v 1.24 2005/12/12 20:10:53 deraadt Exp $";
a190 2
			if (n == -1 && errno != EAGAIN)
				break;
a275 2
			if (n == -1 && errno != EAGAIN)
				break;
@
