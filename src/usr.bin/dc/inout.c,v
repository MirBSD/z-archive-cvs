head	1.3;
access;
symbols
	cvs-20140819:1.1.1.3
	MIRBSD_10:1.1.1.2.0.4
	MIRBSD_10_BASE:1.1.1.2
	MIRBSD_9_BASE:1.1.1.2
	MIRBSD_8:1.1.1.2.0.2
	MIRBSD_8_BASE:1.1.1.2
	cvs-200507211800:1.1.1.2
	cvs-200504291700:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2014.08.19.21.16.49;	author tg;	state Exp;
branches;
next	1.2;
commitid	10053F3BEC10EA5E918;

1.2
date	2014.08.19.20.44.55;	author tg;	state Exp;
branches;
next	1.1;
commitid	10053F3B75E4ADD80F6;

1.1
date	2005.02.05.17.29.28;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.29.28;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.29.17.06.01;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.08.19.20.22.48;	author tg;	state Exp;
branches;
next	;
commitid	10053F3B22340A28086;


desc
@@


1.3
log
@further improve handling of fractional non-decimal input
(still truncates, and with scale/k set, output is too large)
@
text
@/*	$OpenBSD: inout.c,v 1.17 2012/11/07 11:06:14 otto Exp $	*/

/*
 * Copyright (c) 2003, Otto Moerbeek <otto@@drijf.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <ssl/ssl.h>
#include <ctype.h>
#include <err.h>
#include <string.h>

#include "extern.h"

__RCSID("$MirOS: src/usr.bin/dc/inout.c,v 1.2 2014/08/19 20:44:55 tg Exp $");

#define MAX_CHARS_PER_LINE 68

static int	lastchar;
static int	charcount;

static int	src_getcharstream(struct source *);
static void	src_ungetcharstream(struct source *);
static char	*src_getlinestream(struct source *);
static void	src_freestream(struct source *);
static int	src_getcharstring(struct source *);
static void	src_ungetcharstring(struct source *);
static char	*src_getlinestring(struct source *);
static void	src_freestring(struct source *);
static void	flushwrap(FILE *);
static void	putcharwrap(FILE *, int);
static void	printwrap(FILE *, const char *);
static char	*get_digit(u_long, int, u_int);

static struct vtable stream_vtable = {
	src_getcharstream,
	src_ungetcharstream,
	src_getlinestream,
	src_freestream
};

static struct vtable string_vtable = {
	src_getcharstring,
	src_ungetcharstring,
	src_getlinestring,
	src_freestring
};

void
src_setstream(struct source *src, FILE *stream)
{
	src->u.stream = stream;
	src->vtable = &stream_vtable;
}

void
src_setstring(struct source *src, char *p)
{
	src->u.string.buf = (u_char *)p;
	src->u.string.pos = 0;
	src->vtable = &string_vtable;
}

static int
src_getcharstream(struct source *src)
{
	return src->lastchar = getc(src->u.stream);
}

static void
src_ungetcharstream(struct source *src)
{
	(void)ungetc(src->lastchar, src->u.stream);
}

/* ARGSUSED */
static void
src_freestream(struct source *src __unused)
{
}

static char *
src_getlinestream(struct source *src)
{
	char buf[BUFSIZ];

	if (fgets(buf, BUFSIZ, src->u.stream) == NULL)
		return bstrdup("");
	return bstrdup(buf);
}

static int
src_getcharstring(struct source *src)
{
	src->lastchar = src->u.string.buf[src->u.string.pos];
	if (src->lastchar == '\0')
		return EOF;
	else {
		src->u.string.pos++;
		return src->lastchar;
	}
}

static void
src_ungetcharstring(struct source *src)
{
	if (src->u.string.pos > 0) {
		if (src->lastchar != '\0')
			--src->u.string.pos;
	}
}

static char *
src_getlinestring(struct source *src)
{
	char buf[BUFSIZ];
	int ch, i;

	i = 0;
	while (i < BUFSIZ-1) {
		ch = src_getcharstring(src);
		if (ch == EOF)
			break;
		buf[i++] = ch;
		if (ch == '\n')
			break;
	}
	buf[i] = '\0';
	return bstrdup(buf);
}

static void
src_freestring(struct source *src)
{
	free(src->u.string.buf);
}

static void
flushwrap(FILE *f)
{
	if (lastchar != -1)
		(void)putc(lastchar, f);
}

static void
putcharwrap(FILE *f, int ch)
{
	if (charcount >= MAX_CHARS_PER_LINE) {
		charcount = 0;
		(void)fputs("\\\n", f);
	}
	if (lastchar != -1) {
		charcount++;
		(void)putc(lastchar, f);
	}
	lastchar = ch;
}

static void
printwrap(FILE *f, const char *p)
{
	char	buf[12];
	char	*q = buf;

	(void)strlcpy(buf, p, sizeof(buf));
	while (*q)
		putcharwrap(f, *q++);
}

struct number *
readnumber(struct source *src, u_int base)
{
	struct number	*n;
	int		ch;
	bool		sign = false;
	bool		dot = false;
	BN_ULONG	v;
	u_int		i;

	n = new_number();
	bn_check(BN_zero(n->number));

	while ((ch = (*src->vtable->readchar)(src)) != EOF) {

		if ('0' <= ch && ch <= '9')
			v = ch - '0';
		else if ('A' <= ch && ch <= 'F')
			v = ch - 'A' + 10;
		else if (ch == '_') {
			sign = true;
			continue;
		} else if (ch == '.') {
			if (dot)
				break;
			dot = true;
			continue;
		} else {
			(*src->vtable->unreadchar)(src);
			break;
		}
		if (dot)
			n->scale++;

		bn_check(BN_mul_word(n->number, base));

#if 0
		/* work around a bug in BN_add_word: 0 += 0 is buggy.... */
		if (v > 0)
#endif
			bn_check(BN_add_word(n->number, v));
	}
	if (base != 10) {
		u_int iscale, dscale;

		if ((dscale = bmachine_scale()) > n->scale) {
			iscale = dscale;
			dscale -= n->scale;
		} else {
			iscale = n->scale;
			dscale = 0;
		}
		scale_number(n->number, iscale);
		for (i = 0; i < n->scale; i++)
			(void)BN_div_word(n->number, base);
		n->scale += dscale;
		/*
		 * This makes the number have the k (scale) value
		 * if set. What we really want is to use a sane
		 * value in the default case, i.e. 0.1 -> one digit
		 * -> 0xF -> 15 -> scale=2; two digits 256 ergo 3.
		 */
	}
	if (sign)
		negate(n);
	return n;
}

char *
read_string(struct source *src)
{
	int count, i, sz, new_sz, ch;
	char *p;
	bool escape;

	escape = false;
	count = 1;
	i = 0;
	sz = 15;
	p = bmalloc(sz + 1);

	while ((ch = (*src->vtable->readchar)(src)) != EOF) {
		if (!escape) {
			if (ch == '[')
				count++;
			else if (ch == ']')
				count--;
			if (count == 0)
				break;
		}
		if (ch == '\\' && !escape)
			escape = true;
		else {
			escape = false;
			if (i == sz) {
				new_sz = sz * 2;
				p = brealloc(p, new_sz + 1);
				sz = new_sz;
			}
			p[i++] = ch;
		}
	}
	p[i] = '\0';
	return p;
}

static char *
get_digit(u_long num, int digits, u_int base)
{
	char *p;

	if (base <= 16) {
		p = bmalloc(2);
		p[0] = num >= 10 ? num + 'A' - 10 : num + '0';
		p[1] = '\0';
	} else {
		if (asprintf(&p, "%0*lu", digits, num) == -1)
			err(1, NULL);
	}
	return p;
}

void
printnumber(FILE *f, const struct number *b, u_int base)
{
	struct number	*int_part, *fract_part;
	int		digits;
	char		buf[11];
	size_t		sz;
	size_t		i;
	struct stack	stack;
	char		*p;

	charcount = 0;
	lastchar = -1;
	if (BN_is_zero(b->number))
		putcharwrap(f, '0');

	int_part = new_number();
	fract_part = new_number();
	fract_part->scale = b->scale;

	if (base <= 16)
		digits = 1;
	else {
		digits = snprintf(buf, sizeof(buf), "%u", base-1);
	}
	split_number(b, int_part->number, fract_part->number);

	i = 0;
	stack_init(&stack);
	while (!BN_is_zero(int_part->number)) {
		BN_ULONG rem = BN_div_word(int_part->number, base);
		stack_pushstring(&stack, get_digit(rem, digits, base));
		i++;
	}
	sz = i;
	if (BN_is_negative(b->number))
		putcharwrap(f, '-');
	for (i = 0; i < sz; i++) {
		p = stack_popstring(&stack);
		if (base > 16)
			putcharwrap(f, ' ');
		printwrap(f, p);
		free(p);
	}
	stack_clear(&stack);
	if (b->scale > 0) {
		struct number	*num_base;
		BIGNUM		mult, stop;

		putcharwrap(f, '.');
		num_base = new_number();
		bn_check(BN_set_word(num_base->number, base));
		BN_init(&mult);
		bn_check(BN_one(&mult));
		BN_init(&stop);
		bn_check(BN_one(&stop));
		scale_number(&stop, b->scale);

		i = 0;
		while (BN_cmp(&mult, &stop) < 0) {
			u_long	rem;

			if (i && base > 16)
				putcharwrap(f, ' ');
			i = 1;

			bmul_number(fract_part, fract_part, num_base,
			    bmachine_scale());
			split_number(fract_part, int_part->number, NULL);
			rem = BN_get_word(int_part->number);
			p = get_digit(rem, digits, base);
			int_part->scale = 0;
			normalize(int_part, fract_part->scale);
			bn_check(BN_sub(fract_part->number, fract_part->number,
			    int_part->number));
			printwrap(f, p);
			free(p);
			bn_check(BN_mul_word(&mult, base));
		}
		free_number(num_base);
		BN_free(&mult);
		BN_free(&stop);
	}
	flushwrap(f);
	free_number(int_part);
	free_number(fract_part);
}

void
print_value(FILE *f, const struct value *value, const char *prefix, u_int base)
{
	(void)fputs(prefix, f);
	switch (value->type) {
	case BCODE_NONE:
		if (value->array != NULL)
			(void)fputs("<array>", f);
		break;
	case BCODE_NUMBER:
		printnumber(f, value->u.num, base);
		break;
	case BCODE_STRING:
		(void)fputs(value->u.string, f);
		break;
	}
}

void
print_ascii(FILE *f, const struct number *n)
{
	BIGNUM *v;
	int numbits, i, ch;

	v = BN_dup(n->number);
	bn_checkp(v);

	if (BN_is_negative(v))
		BN_set_negative(v, 0);

	numbits = BN_num_bytes(v) * 8;
	while (numbits > 0) {
		ch = 0;
		for (i = 0; i < 8; i++)
			ch |= BN_is_bit_set(v, numbits-i-1) << (7 - i);
		(void)putc(ch, f);
		numbits -= 8;
	}
	BN_free(v);
}
@


1.2
log
@merge and make __CRAZY clean
@
text
@d19 1
d27 1
a27 1
__RCSID("$MirOS$");
d225 10
a234 1
		scale_number(n->number, n->scale);
d237 7
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: inout.c,v 1.8 2003/11/14 20:18:47 otto Exp $	*/
a18 4
#ifndef lint
static const char rcsid[] = "$OpenBSD: inout.c,v 1.8 2003/11/14 20:18:47 otto Exp $";
#endif /* not lint */

d26 2
d30 2
a31 2
static int	charCount;

d34 1
a34 1
static int	src_ungetcharstream(struct source *);
d38 1
a38 1
static int	src_ungetcharstring(struct source *);
d41 1
d81 1
a81 1
static int
d84 1
a84 1
	return ungetc(src->lastchar, src->u.stream);
d87 1
d89 1
a89 1
src_freestream(struct source *src)
d115 1
a115 1
static int
a117 2
	int ch;

d121 1
a121 4
		ch = src->u.string.buf[src->u.string.pos];
		return ch == '\0' ? EOF : ch;
	} else
		return EOF;
d150 7
d159 7
a165 4
	putc(ch, f);
	if (++charCount > MAX_CHARS_PER_LINE) {
		charCount = 0;
		fputs("\\\n", f);
d167 1
d176 1
a176 1
	snprintf(buf, sizeof(buf), "%s", p);
d189 1
d223 5
d294 1
a294 1
	int		i;
d298 2
d322 1
a322 2
	charCount = 0;
	if (BN_cmp(b->number, &zero) < 0)
d338 1
a338 1
		BN_set_word(num_base->number, base);
d340 1
a340 1
		BN_one(&mult);
d342 1
a342 1
		BN_one(&stop);
d353 2
a354 1
			bmul_number(fract_part, fract_part, num_base);
d360 2
a361 2
			BN_sub(fract_part->number, fract_part->number,
			    int_part->number);
d364 1
a364 1
			BN_mul_word(&mult, base);
d370 1
d378 1
a378 1
	fputs(prefix, f);
d382 1
a382 1
			fputs("<array>", f);
d388 1
a388 1
		fputs(value->u.string, f);
d402 2
a403 2
	if (BN_cmp(v, &zero) < 0)
		bn_check(BN_sub(v, &zero, v));
d410 1
a410 1
		putc(ch, f);
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@improve my Frankenstein OS (*wink* you know who you are) further
sans wchar_t of course

this is the essence of reading >1200 commit messages which suck
due to not having the new format of ours...
@
text
@d1 1
a1 1
/*	$OpenBSD: inout.c,v 1.12 2005/03/29 10:53:54 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: inout.c,v 1.12 2005/03/29 10:53:54 otto Exp $";
d32 2
a33 2
static int	lastchar;
static int	charcount;
a42 1
static void	flushwrap(FILE *);
a154 7
flushwrap(FILE *f)
{
	if (lastchar != -1)
		putc(lastchar, f);
}

static void
d157 3
a159 2
	if (charcount >= MAX_CHARS_PER_LINE) {
		charcount = 0;
a161 5
	if (lastchar != -1) {
		charcount++;
		putc(lastchar, f);
	}
	lastchar = ch;
d170 1
a170 1
	strlcpy(buf, p, sizeof(buf));
a285 2
	charcount = 0;
	lastchar = -1;
d308 1
a355 1
	flushwrap(f);
@


1.1.1.3
log
@get a dc that does
	dc -e 16i -e 0.FFFF -e f
right…
@
text
@d1 1
a1 1
/*	$OpenBSD: inout.c,v 1.17 2012/11/07 11:06:14 otto Exp $	*/
d19 4
d36 1
a36 1
static void	src_ungetcharstream(struct source *);
d40 1
a40 1
static void	src_ungetcharstring(struct source *);
d83 1
a83 1
static void
d86 1
a86 1
	(void)ungetc(src->lastchar, src->u.stream);
a88 1
/* ARGSUSED */
d116 1
a116 1
static void
d119 2
d124 4
a127 1
	}
d159 1
a159 1
		(void)putc(lastchar, f);
d167 1
a167 1
		(void)fputs("\\\n", f);
d171 1
a171 1
		(void)putc(lastchar, f);
d182 1
a182 1
	(void)strlcpy(buf, p, sizeof(buf));
a194 1
	u_int		i;
a227 5
	if (base != 10) {
		scale_number(n->number, n->scale);
		for (i = 0; i < n->scale; i++)
			(void)BN_div_word(n->number, base);
	}
d322 1
a322 1
	if (BN_is_negative(b->number))
d338 1
a338 1
		bn_check(BN_set_word(num_base->number, base));
d340 1
a340 1
		bn_check(BN_one(&mult));
d342 1
a342 1
		bn_check(BN_one(&stop));
d353 1
a353 2
			bmul_number(fract_part, fract_part, num_base,
			    bmachine_scale());
d359 2
a360 2
			bn_check(BN_sub(fract_part->number, fract_part->number,
			    int_part->number));
d363 1
a363 1
			bn_check(BN_mul_word(&mult, base));
d377 1
a377 1
	(void)fputs(prefix, f);
d381 1
a381 1
			(void)fputs("<array>", f);
d387 1
a387 1
		(void)fputs(value->u.string, f);
d401 2
a402 2
	if (BN_is_negative(v))
		BN_set_negative(v, 0);
d409 1
a409 1
		(void)putc(ch, f);
@


