head	1.2;
access;
symbols
	ncurses-5_2-devel:1.1.1.1.0.4
	MIRBSD_9_BASE:1.1.1.1
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200507211800:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2006.10.28.19.08.05;	author tg;	state dead;
branches;
next	1.1;
commitid	1004543AA865C08B5DD;

1.1
date	2005.02.05.17.30.01;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.30.01;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@switch to libncurses (for now)
agreed bsiegert@@

ncurses/Makefile: also install HTML docs

switched: libform libmenu libpanel and a few progs, lynx
not switched: tset/clear (but modernised), we use obsd code here
fixed: window
@
text
@#!/bin/sh
# $OpenBSD: MKtermsort.sh,v 1.4 2000/03/10 01:35:06 millert Exp $
# $From: MKtermsort.sh,v 1.6 2000/01/25 11:35:36 tom Exp $
#
# MKtermsort.sh -- generate indirection vectors for the various sort methods
#
# The output of this script is C source for nine arrays that list three sort
# orders for each of the three different classes of terminfo capabilities.
#
# keep the order independent of locale:
LANGUAGE=C
LC_ALL=C
export LANGUAGE
export LC_ALL
#
AWK=${1-awk}
DATA=${2-../include/Caps}

echo "/*";
echo " * termsort.c --- sort order arrays for use by infocmp.";
echo " *";
echo " * Note: this file is generated using MKtermsort.sh, do not edit by hand.";
echo " */";

echo "static const int bool_terminfo_sort[] = {";
$AWK <$DATA '
BEGIN           {i = 0;}
/^#/            {next;}
$3 == "bool"    {printf("%s\t%d\n", $2, i++);}
' | sort | $AWK '{print "\t", $2, ",\t/* ", $1, " */";}';
echo "};";
echo "";

echo "static const int num_terminfo_sort[] = {";
$AWK <$DATA '
BEGIN           {i = 0;}
/^#/            {next;}
$3 == "num"     {printf("%s\t%d\n", $2, i++);}
' | sort | $AWK '{print "\t", $2, ",\t/* ", $1, " */";}';
echo "};";
echo "";

echo "static const int str_terminfo_sort[] = {";
$AWK <$DATA '
BEGIN           {i = 0;}
/^#/            {next;}
$3 == "str"     {printf("%s\t%d\n", $2, i++);}
' | sort | $AWK '{print "\t", $2, ",\t/* ", $1, " */";}';
echo "};";
echo "";

echo "static const int bool_variable_sort[] = {";
$AWK <$DATA '
BEGIN           {i = 0;}
/^#/            {next;}
$3 == "bool"    {printf("%s\t%d\n", $1, i++);}
' | sort | $AWK '{print "\t", $2, ",\t/* ", $1, " */";}';
echo "};";
echo "";

echo "static const int num_variable_sort[] = {";
$AWK <$DATA '
BEGIN           {i = 0;}
/^#/            {next;}
$3 == "num"     {printf("%s\t%d\n", $1, i++);}
' | sort | $AWK '{print "\t", $2, ",\t/* ", $1, " */";}';
echo "};";
echo "";

echo "static const int str_variable_sort[] = {";
$AWK <$DATA '
BEGIN           {i = 0;}
/^#/            {next;}
$3 == "str"     {printf("%s\t%d\n", $1, i++);}
' | sort | $AWK '{print "\t", $2, ",\t/* ", $1, " */";}';
echo "};";
echo "";

echo "static const int bool_termcap_sort[] = {";
$AWK <$DATA '
BEGIN           {i = 0;}
/^#/            {next;}
$3 == "bool"    {printf("%s\t%d\n", $4, i++);}
' | sort | $AWK '{print "\t", $2, ",\t/* ", $1, " */";}';
echo "};";
echo "";

echo "static const int num_termcap_sort[] = {";
$AWK <$DATA '
BEGIN           {i = 0;}
/^#/            {next;}
$3 == "num"     {printf("%s\t%d\n", $4, i++);}
' | sort | $AWK '{print "\t", $2, ",\t/* ", $1, " */";}';
echo "};";
echo "";

echo "static const int str_termcap_sort[] = {";
$AWK <$DATA '
BEGIN           {i = 0;}
/^#/            {next;}
$3 == "str"     {printf("%s\t%d\n", $4, i++);}
' | sort | $AWK '{print "\t", $2, ",\t/* ", $1, " */";}';
echo "};";
echo "";

echo "static const bool bool_from_termcap[] = {";
$AWK <$DATA '
$3 == "bool" && substr($5, 1, 1) == "-"       {print "\tFALSE,\t/* ", $2, " */";}
$3 == "bool" && substr($5, 1, 1) == "Y"       {print "\tTRUE,\t/* ", $2, " */";}
'
echo "};";
echo "";

echo "static const bool num_from_termcap[] = {";
$AWK <$DATA '
$3 == "num" && substr($5, 1, 1) == "-"        {print "\tFALSE,\t/* ", $2, " */";}
$3 == "num" && substr($5, 1, 1) == "Y"        {print "\tTRUE,\t/* ", $2, " */";}
'
echo "};";
echo "";

echo "static const bool str_from_termcap[] = {";
$AWK <$DATA '
$3 == "str" && substr($5, 1, 1) == "-"        {print "\tFALSE,\t/* ", $2, " */";}
$3 == "str" && substr($5, 1, 1) == "Y"        {print "\tTRUE,\t/* ", $2, " */";}
'
echo "};";
echo "";
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@
