head	1.22;
access;
symbols
	cvs-200910041320:1.1.1.15
	cvs-200903221200:1.1.1.14
	cvs-200812162015:1.1.1.13
	cvs-200804031830:1.1.1.12
	MIRBSD_10:1.15.0.2
	MIRBSD_10_BASE:1.15
	cvs-200803022030:1.1.1.12
	cvs-200709131337:1.1.1.11
	cvs-200709021830:1.1.1.11
	cvs-200708201200:1.1.1.11
	cvs-200706161500:1.1.1.11
	cvs-200705192215:1.1.1.11
	cvs-200704292000:1.1.1.11
	cvs-200703080900:1.1.1.10
	cvs-200701251600:1.1.1.10
	cvs-200612111600:1.1.1.9
	cvs-200611090230:1.1.1.9
	OPENBSD_4_0:1.1.1.9
	MIRBSD_9_BASE:1.11
	cvs-200606162342:1.1.1.8
	cvs-200606022000:1.1.1.8
	cvs-200604191000:1.1.1.8
	cvs-200602220045:1.1.1.7
	MIRBSD_8:1.7.0.2
	MIRBSD_8_BASE:1.7
	cvs-200512201942:1.1.1.6
	cvs-200511231930:1.1.1.5
	cvs-200507211800:1.1.1.4
	cvs-200506221550:1.1.1.3
	cvs-200505050030:1.1.1.2
	cvs-200504291700:1.1.1.2
	cvs-200504261445:1.1.1.2
	cvs-200504141900:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2016.01.14.19.23.02;	author tg;	state Exp;
branches;
next	1.21;
commitid	1005697F5AA3EA7E36D;

1.21
date	2014.03.28.22.31.56;	author tg;	state Exp;
branches;
next	1.20;
commitid	1005335F87233372394;

1.20
date	2011.01.15.21.52.40;	author tg;	state Exp;
branches;
next	1.19;
commitid	1004D32173B08BB4E36;

1.19
date	2009.10.04.14.29.06;	author tg;	state Exp;
branches;
next	1.18;
commitid	1004AC8B1276FC00211;

1.18
date	2009.10.02.16.58.48;	author tg;	state Exp;
branches;
next	1.17;
commitid	1004AC6315648072669;

1.17
date	2009.03.22.15.01.18;	author tg;	state Exp;
branches;
next	1.16;
commitid	10049C652CD5CCC321F;

1.16
date	2008.12.16.20.55.25;	author tg;	state Exp;
branches;
next	1.15;
commitid	100494815C97ECEEDBF;

1.15
date	2008.03.02.21.14.20;	author tg;	state Exp;
branches;
next	1.14;
commitid	10047CB18BB506A8527;

1.14
date	2007.04.29.20.23.13;	author tg;	state Exp;
branches;
next	1.13;
commitid	1004634FEC2113C55F5;

1.13
date	2007.01.25.16.18.36;	author tg;	state Exp;
branches;
next	1.12;
commitid	10045B8D86E5B698AD6;

1.12
date	2006.09.20.21.41.00;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004511B578580E7F04;

1.11
date	2006.06.02.20.50.48;	author tg;	state Exp;
branches;
next	1.10;
commitid	1004480A4952B0D84EA;

1.10
date	2006.04.19.10.40.50;	author tg;	state Exp;
branches;
next	1.9;
commitid	100444613BD3A91C28B;

1.9
date	2006.02.22.02.16.47;	author tg;	state Exp;
branches;
next	1.8;
commitid	10043FBC991512A442B;

1.8
date	2006.02.22.01.23.49;	author tg;	state Exp;
branches;
next	1.7;
commitid	10043FBBD2C2C5E7D81;

1.7
date	2005.12.20.19.57.33;	author tg;	state Exp;
branches;
next	1.6;
commitid	10043A8623F4C1F637E;

1.6
date	2005.11.23.19.45.14;	author tg;	state Exp;
branches;
next	1.5;
commitid	29f4384c6def7d1;

1.5
date	2005.11.23.18.04.20;	author tg;	state Exp;
branches;
next	1.4;
commitid	af74384af2ab463;

1.4
date	2005.06.22.16.11.39;	author tg;	state Exp;
branches;
next	1.3;
commitid	598b42b98dcf335f;

1.3
date	2005.04.14.19.49.34;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.13.18.33.30;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.29.52;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.29.52;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.14.19.33.27;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.06.22.15.56.27;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	181342b98a38fe99;

1.1.1.4
date	2005.07.21.21.00.30;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	560042e0092f571e;

1.1.1.5
date	2005.11.23.19.34.15;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	116a4384c4467ffc;

1.1.1.6
date	2005.12.20.19.43.44;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	10043A85EF81EF097CF;

1.1.1.7
date	2006.02.22.00.51.35;	author tg;	state Exp;
branches;
next	1.1.1.8;
commitid	10043FBB5A933C3BB9B;

1.1.1.8
date	2006.04.19.10.15.03;	author tg;	state Exp;
branches;
next	1.1.1.9;
commitid	10044460DB21E1F715C;

1.1.1.9
date	2006.09.20.19.06.49;	author tg;	state Exp;
branches;
next	1.1.1.10;
commitid	10045119150397FC669;

1.1.1.10
date	2007.01.25.16.13.11;	author tg;	state Exp;
branches;
next	1.1.1.11;
commitid	10045B8D7100791C016;

1.1.1.11
date	2007.04.29.20.07.02;	author tg;	state Exp;
branches;
next	1.1.1.12;
commitid	1004634FAED5BC54DF0;

1.1.1.12
date	2008.03.02.20.40.42;	author tg;	state Exp;
branches;
next	1.1.1.13;
commitid	10047CB10DD30FAF062;

1.1.1.13
date	2008.12.16.20.15.33;	author tg;	state Exp;
branches;
next	1.1.1.14;
commitid	10049480C7A2701F5C0;

1.1.1.14
date	2009.03.22.12.03.00;	author tg;	state Exp;
branches;
next	1.1.1.15;
commitid	10049C6290649163EA3;

1.1.1.15
date	2009.10.04.13.25.45;	author tg;	state Exp;
branches;
next	;
commitid	1004AC8A2663BC008C5;


desc
@@


1.22
log
@drop roaming code completely
@
text
@/* $OpenBSD: readconf.c,v 1.177 2009/06/27 09:35:06 andreas Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * Functions for reading the configuration files.
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>

#include <netinet/in.h>

#include <ctype.h>
#include <errno.h>
#include <netdb.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "xmalloc.h"
#include "ssh.h"
#include "compat.h"
#include "cipher.h"
#include "pathnames.h"
#include "log.h"
#include "key.h"
#include "readconf.h"
#include "match.h"
#include "misc.h"
#include "buffer.h"
#include "kex.h"
#include "mac.h"

__RCSID("$MirOS: src/usr.bin/ssh/readconf.c,v 1.21 2014/03/28 22:31:56 tg Exp $");

/* Format of the configuration file:

   # Configuration data is parsed as follows:
   #  1. command line options
   #  2. user-specific file
   #  3. system-wide file
   # Any configuration value is only changed the first time it is set.
   # Thus, host-specific definitions should be at the beginning of the
   # configuration file, and defaults at the end.

   # Host-specific declarations.  These may override anything above.  A single
   # host may match multiple declarations; these are processed in the order
   # that they are given in.

   Host *.ngs.fi ngs.fi
     User foo

   Host fake.com
     Hostname another.host.name.real.org
     User blaah
     Port 34289
     ForwardX11 no
     ForwardAgent no

   Host books.com
     RemoteForward 9999 shadows.cs.hut.fi:9999
     Cipher 3des

   Host fascist.blob.com
     Port 23123
     User tylonen
     PasswordAuthentication no

   Host puukko.hut.fi
     User t35124p
     ProxyCommand ssh-proxy %h %p

   Host *.fr
     PublicKeyAuthentication no

   Host *.su
     Cipher none
     PasswordAuthentication no

   Host vpn.fake.com
     Tunnel yes
     TunnelDevice 3

   # Defaults for various options
   Host *
     ForwardAgent no
     ForwardX11 no
     PasswordAuthentication yes
     RSAAuthentication yes
     RhostsRSAAuthentication yes
     StrictHostKeyChecking yes
     TcpKeepAlive no
     IdentityFile ~/.etc/ssh/identity
     Port 22
     EscapeChar ~

*/

/* Keyword tokens. */

typedef enum {
	oBadOption,
	oForwardAgent, oForwardX11, oForwardX11Trusted, oGatewayPorts,
	oExitOnForwardFailure,
	oPasswordAuthentication, oRSAAuthentication,
	oChallengeResponseAuthentication, oXAuthLocation,
	oIdentityFile, oHostName, oPort, oCipher, oRemoteForward, oLocalForward,
	oUser, oHost, oEscapeChar, oRhostsRSAAuthentication, oProxyCommand,
	oGlobalKnownHostsFile, oUserKnownHostsFile, oConnectionAttempts,
	oBatchMode, oCheckHostIP, oStrictHostKeyChecking, oCompression,
	oCompressionLevel, oTCPKeepAlive, oNumberOfPasswordPrompts,
	oUsePrivilegedPort, oLogLevel, oCiphers, oProtocol, oMacs,
	oGlobalKnownHostsFile2, oUserKnownHostsFile2, oPubkeyAuthentication,
	oKbdInteractiveAuthentication, oKbdInteractiveDevices, oHostKeyAlias,
	oDynamicForward, oPreferredAuthentications, oHostbasedAuthentication,
	oHostKeyAlgorithms, oBindAddress, oSmartcardDevice,
	oClearAllForwardings, oNoHostAuthenticationForLocalhost,
	oEnableSSHKeysign, oRekeyLimit, oVerifyHostKeyDNS, oConnectTimeout,
	oAddressFamily,
	oServerAliveInterval, oServerAliveCountMax, oIdentitiesOnly,
	oSendEnv, oControlPath, oControlMaster, oHashKnownHosts,
	oTunnel, oTunnelDevice, oLocalCommand, oPermitLocalCommand,
	oVisualHostKey,
	oDeprecated, oUnsupported
} OpCodes;

/* Textual representations of the tokens. */

static struct {
	const char *name;
	OpCodes opcode;
} keywords[] = {
	{ "forwardagent", oForwardAgent },
	{ "forwardx11", oForwardX11 },
	{ "forwardx11trusted", oForwardX11Trusted },
	{ "exitonforwardfailure", oExitOnForwardFailure },
	{ "xauthlocation", oXAuthLocation },
	{ "gatewayports", oGatewayPorts },
	{ "useprivilegedport", oUsePrivilegedPort },
	{ "rhostsauthentication", oDeprecated },
	{ "passwordauthentication", oPasswordAuthentication },
	{ "kbdinteractiveauthentication", oKbdInteractiveAuthentication },
	{ "kbdinteractivedevices", oKbdInteractiveDevices },
	{ "rsaauthentication", oRSAAuthentication },
	{ "pubkeyauthentication", oPubkeyAuthentication },
	{ "dsaauthentication", oPubkeyAuthentication },		    /* alias */
	{ "rhostsrsaauthentication", oRhostsRSAAuthentication },
	{ "hostbasedauthentication", oHostbasedAuthentication },
	{ "challengeresponseauthentication", oChallengeResponseAuthentication },
	{ "skeyauthentication", oChallengeResponseAuthentication }, /* alias */
	{ "tisauthentication", oChallengeResponseAuthentication },  /* alias */
	{ "kerberosauthentication", oUnsupported },
	{ "kerberostgtpassing", oUnsupported },
	{ "afstokenpassing", oUnsupported },
	{ "gssapiauthentication", oUnsupported },
	{ "gssapidelegatecredentials", oUnsupported },
	{ "fallbacktorsh", oDeprecated },
	{ "usersh", oDeprecated },
	{ "identityfile", oIdentityFile },
	{ "identityfile2", oIdentityFile },			/* obsolete */
	{ "identitiesonly", oIdentitiesOnly },
	{ "hostname", oHostName },
	{ "hostkeyalias", oHostKeyAlias },
	{ "proxycommand", oProxyCommand },
	{ "port", oPort },
	{ "cipher", oCipher },
	{ "ciphers", oCiphers },
	{ "macs", oMacs },
	{ "protocol", oProtocol },
	{ "remoteforward", oRemoteForward },
	{ "localforward", oLocalForward },
	{ "user", oUser },
	{ "host", oHost },
	{ "escapechar", oEscapeChar },
	{ "globalknownhostsfile", oGlobalKnownHostsFile },
	{ "globalknownhostsfile2", oGlobalKnownHostsFile2 },	/* obsolete */
	{ "userknownhostsfile", oUserKnownHostsFile },
	{ "userknownhostsfile2", oUserKnownHostsFile2 },	/* obsolete */
	{ "connectionattempts", oConnectionAttempts },
	{ "batchmode", oBatchMode },
	{ "checkhostip", oCheckHostIP },
	{ "stricthostkeychecking", oStrictHostKeyChecking },
	{ "compression", oCompression },
	{ "compressionlevel", oCompressionLevel },
	{ "tcpkeepalive", oTCPKeepAlive },
	{ "keepalive", oTCPKeepAlive },				/* obsolete */
	{ "numberofpasswordprompts", oNumberOfPasswordPrompts },
	{ "loglevel", oLogLevel },
	{ "dynamicforward", oDynamicForward },
	{ "preferredauthentications", oPreferredAuthentications },
	{ "hostkeyalgorithms", oHostKeyAlgorithms },
	{ "bindaddress", oBindAddress },
#ifdef SMARTCARD
	{ "smartcarddevice", oSmartcardDevice },
#else
	{ "smartcarddevice", oUnsupported },
#endif
	{ "clearallforwardings", oClearAllForwardings },
	{ "enablesshkeysign", oEnableSSHKeysign },
	{ "verifyhostkeydns", oVerifyHostKeyDNS },
	{ "nohostauthenticationforlocalhost", oNoHostAuthenticationForLocalhost },
	{ "rekeylimit", oRekeyLimit },
	{ "connecttimeout", oConnectTimeout },
	{ "addressfamily", oAddressFamily },
	{ "serveraliveinterval", oServerAliveInterval },
	{ "serveralivecountmax", oServerAliveCountMax },
	{ "sendenv", oSendEnv },
	{ "controlpath", oControlPath },
	{ "controlmaster", oControlMaster },
	{ "hashknownhosts", oHashKnownHosts },
	{ "tunnel", oTunnel },
	{ "tunneldevice", oTunnelDevice },
	{ "localcommand", oLocalCommand },
	{ "permitlocalcommand", oPermitLocalCommand },
	{ "visualhostkey", oVisualHostKey },
	{ "useroaming", oDeprecated },

	{ NULL, oBadOption }
};

/*
 * Adds a local TCP/IP port forward to options.  Never returns if there is an
 * error.
 */

void
add_local_forward(Options *options, const Forward *newfwd)
{
	Forward *fwd;
	extern uid_t original_real_uid;
	if (newfwd->listen_port < IPPORT_RESERVED && original_real_uid != 0)
		fatal("Privileged ports can only be forwarded by root.");
	if (options->num_local_forwards >= SSH_MAX_FORWARDS_PER_DIRECTION)
		fatal("Too many local forwards (max %d).", SSH_MAX_FORWARDS_PER_DIRECTION);
	fwd = &options->local_forwards[options->num_local_forwards++];

	fwd->listen_host = newfwd->listen_host;
	fwd->listen_port = newfwd->listen_port;
	fwd->connect_host = newfwd->connect_host;
	fwd->connect_port = newfwd->connect_port;
}

/*
 * Adds a remote TCP/IP port forward to options.  Never returns if there is
 * an error.
 */

void
add_remote_forward(Options *options, const Forward *newfwd)
{
	Forward *fwd;
	if (options->num_remote_forwards >= SSH_MAX_FORWARDS_PER_DIRECTION)
		fatal("Too many remote forwards (max %d).",
		    SSH_MAX_FORWARDS_PER_DIRECTION);
	fwd = &options->remote_forwards[options->num_remote_forwards++];

	fwd->listen_host = newfwd->listen_host;
	fwd->listen_port = newfwd->listen_port;
	fwd->connect_host = newfwd->connect_host;
	fwd->connect_port = newfwd->connect_port;
}

static void
clear_forwardings(Options *options)
{
	int i;

	for (i = 0; i < options->num_local_forwards; i++) {
		if (options->local_forwards[i].listen_host != NULL)
			xfree(options->local_forwards[i].listen_host);
		xfree(options->local_forwards[i].connect_host);
	}
	options->num_local_forwards = 0;
	for (i = 0; i < options->num_remote_forwards; i++) {
		if (options->remote_forwards[i].listen_host != NULL)
			xfree(options->remote_forwards[i].listen_host);
		xfree(options->remote_forwards[i].connect_host);
	}
	options->num_remote_forwards = 0;
	options->tun_open = SSH_TUNMODE_NO;
}

/*
 * Returns the number of the token pointed to by cp or oBadOption.
 */

static OpCodes
parse_token(const char *cp, const char *filename, int linenum)
{
	u_int i;

	for (i = 0; keywords[i].name; i++)
		if (strcasecmp(cp, keywords[i].name) == 0)
			return keywords[i].opcode;

	error("%s: line %d: Bad configuration option: %s",
	    filename, linenum, cp);
	return oBadOption;
}

/*
 * Processes a single option line as used in the configuration files. This
 * only sets those values that have not already been set.
 */
#define WHITESPACE " \t\r\n"

int
process_config_line(Options *options, const char *host,
		    char *line, const char *filename, int linenum,
		    int *activep)
{
	char *s, **charptr, *endofnumber, *keyword, *arg, *arg2, fwdarg[256];
	int opcode, *intptr, value, value2, scale;
	LogLevel *log_level_ptr;
	long long orig, val64;
	size_t len;
	Forward fwd;

	/* Strip trailing whitespace */
	for (len = strlen(line) - 1; len > 0; len--) {
		if (strchr(WHITESPACE, line[len]) == NULL)
			break;
		line[len] = '\0';
	}

	s = line;
	/* Get the keyword. (Each line is supposed to begin with a keyword). */
	if ((keyword = strdelim(&s)) == NULL)
		return 0;
	/* Ignore leading whitespace. */
	if (*keyword == '\0')
		keyword = strdelim(&s);
	if (keyword == NULL || !*keyword || *keyword == '\n' || *keyword == '#')
		return 0;

	opcode = parse_token(keyword, filename, linenum);

	switch (opcode) {
	case oBadOption:
		/* don't panic, but count bad options */
		return -1;
		/* NOTREACHED */
	case oConnectTimeout:
		intptr = &options->connection_timeout;
parse_time:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing time value.",
			    filename, linenum);
		if ((value = convtime(arg)) == -1)
			fatal("%s line %d: invalid time value.",
			    filename, linenum);
		if (*activep && *intptr == -1)
			*intptr = value;
		break;

	case oForwardAgent:
		intptr = &options->forward_agent;
parse_flag:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing yes/no argument.", filename, linenum);
		value = 0;	/* To avoid compiler warning... */
		if (strcmp(arg, "yes") == 0 || strcmp(arg, "true") == 0)
			value = 1;
		else if (strcmp(arg, "no") == 0 || strcmp(arg, "false") == 0)
			value = 0;
		else
			fatal("%.200s line %d: Bad yes/no argument.", filename, linenum);
		if (*activep && *intptr == -1)
			*intptr = value;
		break;

	case oForwardX11:
		intptr = &options->forward_x11;
		goto parse_flag;

	case oForwardX11Trusted:
		intptr = &options->forward_x11_trusted;
		goto parse_flag;

	case oGatewayPorts:
		intptr = &options->gateway_ports;
		goto parse_flag;

	case oExitOnForwardFailure:
		intptr = &options->exit_on_forward_failure;
		goto parse_flag;

	case oUsePrivilegedPort:
		intptr = &options->use_privileged_port;
		goto parse_flag;

	case oPasswordAuthentication:
		intptr = &options->password_authentication;
		goto parse_flag;

	case oKbdInteractiveAuthentication:
		intptr = &options->kbd_interactive_authentication;
		goto parse_flag;

	case oKbdInteractiveDevices:
		charptr = &options->kbd_interactive_devices;
		goto parse_string;

	case oPubkeyAuthentication:
		intptr = &options->pubkey_authentication;
		goto parse_flag;

	case oRSAAuthentication:
		intptr = &options->rsa_authentication;
		goto parse_flag;

	case oRhostsRSAAuthentication:
		intptr = &options->rhosts_rsa_authentication;
		goto parse_flag;

	case oHostbasedAuthentication:
		intptr = &options->hostbased_authentication;
		goto parse_flag;

	case oChallengeResponseAuthentication:
		intptr = &options->challenge_response_authentication;
		goto parse_flag;

	case oBatchMode:
		intptr = &options->batch_mode;
		goto parse_flag;

	case oCheckHostIP:
		intptr = &options->check_host_ip;
		goto parse_flag;

	case oVerifyHostKeyDNS:
		intptr = &options->verify_host_key_dns;
		goto parse_yesnoask;

	case oStrictHostKeyChecking:
		intptr = &options->strict_host_key_checking;
parse_yesnoask:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing yes/no/ask argument.",
			    filename, linenum);
		value = 0;	/* To avoid compiler warning... */
		if (strcmp(arg, "yes") == 0 || strcmp(arg, "true") == 0)
			value = 1;
		else if (strcmp(arg, "no") == 0 || strcmp(arg, "false") == 0)
			value = 0;
		else if (strcmp(arg, "ask") == 0)
			value = 2;
		else
			fatal("%.200s line %d: Bad yes/no/ask argument.", filename, linenum);
		if (*activep && *intptr == -1)
			*intptr = value;
		break;

	case oCompression:
		intptr = &options->compression;
		goto parse_flag;

	case oTCPKeepAlive:
		intptr = &options->tcp_keep_alive;
		goto parse_flag;

	case oNoHostAuthenticationForLocalhost:
		intptr = &options->no_host_authentication_for_localhost;
		goto parse_flag;

	case oNumberOfPasswordPrompts:
		intptr = &options->number_of_password_prompts;
		goto parse_int;

	case oCompressionLevel:
		intptr = &options->compression_level;
		goto parse_int;

	case oRekeyLimit:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.", filename, linenum);
		if (arg[0] < '0' || arg[0] > '9')
			fatal("%.200s line %d: Bad number.", filename, linenum);
		orig = val64 = strtoll(arg, &endofnumber, 10);
		if (arg == endofnumber)
			fatal("%.200s line %d: Bad number.", filename, linenum);
		switch (toupper(*endofnumber)) {
		case '\0':
			scale = 1;
			break;
		case 'K':
			scale = 1<<10;
			break;
		case 'M':
			scale = 1<<20;
			break;
		case 'G':
			scale = 1<<30;
			break;
		default:
			fatal("%.200s line %d: Invalid RekeyLimit suffix",
			    filename, linenum);
		}
		val64 *= scale;
		/* detect integer wrap and too-large limits */
		if ((val64 / scale) != orig || val64 > UINT_MAX)
			fatal("%.200s line %d: RekeyLimit too large",
			    filename, linenum);
		if (val64 < 16)
			fatal("%.200s line %d: RekeyLimit too small",
			    filename, linenum);
		if (*activep && options->rekey_limit == -1)
			options->rekey_limit = (u_int32_t)val64;
		break;

	case oIdentityFile:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.", filename, linenum);
		if (*activep) {
			intptr = &options->num_identity_files;
			if (*intptr >= SSH_MAX_IDENTITY_FILES)
				fatal("%.200s line %d: Too many identity files specified (max %d).",
				    filename, linenum, SSH_MAX_IDENTITY_FILES);
			charptr = &options->identity_files[*intptr];
			*charptr = xstrdup(arg);
			*intptr = *intptr + 1;
		}
		break;

	case oXAuthLocation:
		charptr=&options->xauth_location;
		goto parse_string;

	case oUser:
		charptr = &options->user;
parse_string:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.", filename, linenum);
		if (*activep && *charptr == NULL)
			*charptr = xstrdup(arg);
		break;

	case oGlobalKnownHostsFile:
		charptr = &options->system_hostfile;
		goto parse_string;

	case oUserKnownHostsFile:
		charptr = &options->user_hostfile;
		goto parse_string;

	case oGlobalKnownHostsFile2:
		charptr = &options->system_hostfile2;
		goto parse_string;

	case oUserKnownHostsFile2:
		charptr = &options->user_hostfile2;
		goto parse_string;

	case oHostName:
		charptr = &options->hostname;
		goto parse_string;

	case oHostKeyAlias:
		charptr = &options->host_key_alias;
		goto parse_string;

	case oPreferredAuthentications:
		charptr = &options->preferred_authentications;
		goto parse_string;

	case oBindAddress:
		charptr = &options->bind_address;
		goto parse_string;

	case oSmartcardDevice:
		charptr = &options->smartcard_device;
		goto parse_string;

	case oProxyCommand:
		charptr = &options->proxy_command;
parse_command:
		if (s == NULL)
			fatal("%.200s line %d: Missing argument.", filename, linenum);
		len = strspn(s, WHITESPACE "=");
		if (*activep && *charptr == NULL)
			*charptr = xstrdup(s + len);
		return 0;

	case oPort:
		intptr = &options->port;
parse_int:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.", filename, linenum);
		if (arg[0] < '0' || arg[0] > '9')
			fatal("%.200s line %d: Bad number.", filename, linenum);

		/* Octal, decimal, or hex format? */
		value = strtol(arg, &endofnumber, 0);
		if (arg == endofnumber)
			fatal("%.200s line %d: Bad number.", filename, linenum);
		if (*activep && *intptr == -1)
			*intptr = value;
		break;

	case oConnectionAttempts:
		intptr = &options->connection_attempts;
		goto parse_int;

	case oCipher:
		intptr = &options->cipher;
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.", filename, linenum);
		value = cipher_number(arg);
		if (value == -1)
			fatal("%.200s line %d: Bad cipher '%s'.",
			    filename, linenum, arg ? arg : "<NONE>");
		if (*activep && *intptr == -1)
			*intptr = value;
		break;

	case oCiphers:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.", filename, linenum);
		if (!ciphers_valid(arg))
			fatal("%.200s line %d: Bad SSH2 cipher spec '%s'.",
			    filename, linenum, arg ? arg : "<NONE>");
		if (*activep && options->ciphers == NULL)
			options->ciphers = xstrdup(arg);
		break;

	case oMacs:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.", filename, linenum);
		if (!mac_valid(arg))
			fatal("%.200s line %d: Bad SSH2 Mac spec '%s'.",
			    filename, linenum, arg ? arg : "<NONE>");
		if (*activep && options->macs == NULL)
			options->macs = xstrdup(arg);
		break;

	case oHostKeyAlgorithms:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.", filename, linenum);
		if (!key_names_valid2(arg))
			fatal("%.200s line %d: Bad protocol 2 host key algorithms '%s'.",
			    filename, linenum, arg ? arg : "<NONE>");
		if (*activep && options->hostkeyalgorithms == NULL)
			options->hostkeyalgorithms = xstrdup(arg);
		break;

	case oProtocol:
		intptr = &options->protocol;
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.", filename, linenum);
		value = proto_spec(arg);
		if (value == SSH_PROTO_UNKNOWN)
			fatal("%.200s line %d: Bad protocol spec '%s'.",
			    filename, linenum, arg ? arg : "<NONE>");
		if (*activep && *intptr == SSH_PROTO_UNKNOWN)
			*intptr = value;
		break;

	case oLogLevel:
		log_level_ptr = &options->log_level;
		arg = strdelim(&s);
		value = log_level_number(arg);
		if (value == SYSLOG_LEVEL_NOT_SET)
			fatal("%.200s line %d: unsupported log level '%s'",
			    filename, linenum, arg ? arg : "<NONE>");
		if (*activep && *log_level_ptr == SYSLOG_LEVEL_NOT_SET)
			*log_level_ptr = (LogLevel) value;
		break;

	case oLocalForward:
	case oRemoteForward:
	case oDynamicForward:
		arg = strdelim(&s);
		if (arg == NULL || *arg == '\0')
			fatal("%.200s line %d: Missing port argument.",
			    filename, linenum);

		if (opcode == oLocalForward ||
		    opcode == oRemoteForward) {
			arg2 = strdelim(&s);
			if (arg2 == NULL || *arg2 == '\0')
				fatal("%.200s line %d: Missing target argument.",
				    filename, linenum);

			/* construct a string for parse_forward */
			snprintf(fwdarg, sizeof(fwdarg), "%s:%s", arg, arg2);
		} else if (opcode == oDynamicForward) {
			strlcpy(fwdarg, arg, sizeof(fwdarg));
		}

		if (parse_forward(&fwd, fwdarg,
		    opcode == oDynamicForward ? 1 : 0,
		    opcode == oRemoteForward ? 1 : 0) == 0)
			fatal("%.200s line %d: Bad forwarding specification.",
			    filename, linenum);

		if (*activep) {
			if (opcode == oLocalForward ||
			    opcode == oDynamicForward)
				add_local_forward(options, &fwd);
			else if (opcode == oRemoteForward)
				add_remote_forward(options, &fwd);
		}
		break;

	case oClearAllForwardings:
		intptr = &options->clear_forwardings;
		goto parse_flag;

	case oHost:
		*activep = 0;
		while ((arg = strdelim(&s)) != NULL && *arg != '\0')
			if (match_pattern(host, arg)) {
				debug("Applying options for %.100s", arg);
				*activep = 1;
				break;
			}
		/* Avoid garbage check below, as strdelim is done. */
		return 0;

	case oEscapeChar:
		intptr = &options->escape_char;
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.", filename, linenum);
		if (arg[0] == '^' && arg[2] == 0 &&
		    (u_char) arg[1] >= 64 && (u_char) arg[1] < 128)
			value = (u_char) arg[1] & 31;
		else if (strlen(arg) == 1)
			value = (u_char) arg[0];
		else if (strcmp(arg, "none") == 0)
			value = SSH_ESCAPECHAR_NONE;
		else {
			fatal("%.200s line %d: Bad escape character.",
			    filename, linenum);
			/* NOTREACHED */
			value = 0;	/* Avoid compiler warning. */
		}
		if (*activep && *intptr == -1)
			*intptr = value;
		break;

	case oAddressFamily:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing address family.",
			    filename, linenum);
		intptr = &options->address_family;
		if (strcasecmp(arg, "inet") == 0)
			value = AF_INET;
		else if (strcasecmp(arg, "inet6") == 0)
			value = AF_INET6;
		else if (strcasecmp(arg, "any") == 0)
			value = AF_UNSPEC;
		else
			fatal("Unsupported AddressFamily \"%s\"", arg);
		if (*activep && *intptr == -1)
			*intptr = value;
		break;

	case oEnableSSHKeysign:
		intptr = &options->enable_ssh_keysign;
		goto parse_flag;

	case oIdentitiesOnly:
		intptr = &options->identities_only;
		goto parse_flag;

	case oServerAliveInterval:
		intptr = &options->server_alive_interval;
		goto parse_time;

	case oServerAliveCountMax:
		intptr = &options->server_alive_count_max;
		goto parse_int;

	case oSendEnv:
		while ((arg = strdelim(&s)) != NULL && *arg != '\0') {
			if (strchr(arg, '=') != NULL)
				fatal("%s line %d: Invalid environment name.",
				    filename, linenum);
			if (!*activep)
				continue;
			if (options->num_send_env >= MAX_SEND_ENV)
				fatal("%s line %d: too many send env.",
				    filename, linenum);
			options->send_env[options->num_send_env++] =
			    xstrdup(arg);
		}
		break;

	case oControlPath:
		charptr = &options->control_path;
		goto parse_string;

	case oControlMaster:
		intptr = &options->control_master;
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing ControlMaster argument.",
			    filename, linenum);
		value = 0;	/* To avoid compiler warning... */
		if (strcmp(arg, "yes") == 0 || strcmp(arg, "true") == 0)
			value = SSHCTL_MASTER_YES;
		else if (strcmp(arg, "no") == 0 || strcmp(arg, "false") == 0)
			value = SSHCTL_MASTER_NO;
		else if (strcmp(arg, "auto") == 0)
			value = SSHCTL_MASTER_AUTO;
		else if (strcmp(arg, "ask") == 0)
			value = SSHCTL_MASTER_ASK;
		else if (strcmp(arg, "autoask") == 0)
			value = SSHCTL_MASTER_AUTO_ASK;
		else
			fatal("%.200s line %d: Bad ControlMaster argument.",
			    filename, linenum);
		if (*activep && *intptr == -1)
			*intptr = value;
		break;

	case oHashKnownHosts:
		intptr = &options->hash_known_hosts;
		goto parse_flag;

	case oTunnel:
		intptr = &options->tun_open;
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing yes/point-to-point/"
			    "ethernet/no argument.", filename, linenum);
		value = 0;	/* silence compiler */
		if (strcasecmp(arg, "ethernet") == 0)
			value = SSH_TUNMODE_ETHERNET;
		else if (strcasecmp(arg, "point-to-point") == 0)
			value = SSH_TUNMODE_POINTOPOINT;
		else if (strcasecmp(arg, "yes") == 0)
			value = SSH_TUNMODE_DEFAULT;
		else if (strcasecmp(arg, "no") == 0)
			value = SSH_TUNMODE_NO;
		else
			fatal("%s line %d: Bad yes/point-to-point/ethernet/"
			    "no argument: %s", filename, linenum, arg);
		if (*activep)
			*intptr = value;
		break;

	case oTunnelDevice:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.", filename, linenum);
		value = a2tun(arg, &value2);
		if (value == SSH_TUNID_ERR)
			fatal("%.200s line %d: Bad tun device.", filename, linenum);
		if (*activep) {
			options->tun_local = value;
			options->tun_remote = value2;
		}
		break;

	case oLocalCommand:
		charptr = &options->local_command;
		goto parse_command;

	case oPermitLocalCommand:
		intptr = &options->permit_local_command;
		goto parse_flag;

	case oVisualHostKey:
		intptr = &options->visual_host_key;
		goto parse_flag;

	case oDeprecated:
		debug("%s line %d: Deprecated option \"%s\"",
		    filename, linenum, keyword);
		return 0;

	case oUnsupported:
		error("%s line %d: Unsupported option \"%s\"",
		    filename, linenum, keyword);
		return 0;

	default:
		fatal("process_config_line: Unimplemented opcode %d", opcode);
	}

	/* Check that there is no garbage at end of line. */
	if ((arg = strdelim(&s)) != NULL && *arg != '\0') {
		fatal("%.200s line %d: garbage at end of line; \"%.200s\".",
		    filename, linenum, arg);
	}
	return 0;
}


/*
 * Reads the config file and modifies the options accordingly.  Options
 * should already be initialized before this call.  This never returns if
 * there is an error.  If the file does not exist, this returns 0.
 */

int
read_config_file(const char *filename, const char *host, Options *options,
    int checkperm)
{
	FILE *f;
	char line[1024];
	int active, linenum;
	int bad_options = 0;

	if ((f = fopen(filename, "r")) == NULL)
		return 0;

	if (checkperm) {
		struct stat sb;

		if (fstat(fileno(f), &sb) == -1)
			fatal("fstat %s: %s", filename, strerror(errno));
		if (((sb.st_uid != 0 && sb.st_uid != getuid()) ||
		    (sb.st_mode & 022) != 0))
			fatal("Bad owner or permissions on %s", filename);
	}

	debug("Reading configuration data %.200s", filename);

	/*
	 * Mark that we are now processing the options.  This flag is turned
	 * on/off by Host specifications.
	 */
	active = 1;
	linenum = 0;
	while (fgets(line, sizeof(line), f)) {
		/* Update line number counter. */
		linenum++;
		if (process_config_line(options, host, line, filename, linenum, &active) != 0)
			bad_options++;
	}
	fclose(f);
	if (bad_options > 0)
		fatal("%s: terminating, %d bad configuration options",
		    filename, bad_options);
	return 1;
}

/*
 * Initializes options to special values that indicate that they have not yet
 * been set.  Read_config_file will only set options with this value. Options
 * are processed in the following order: command line, user config file,
 * system config file.  Last, fill_default_options is called.
 */

void
initialize_options(Options *options)
{
	memset(options, 'X', sizeof(*options));
	options->forward_agent = -1;
	options->forward_x11 = -1;
	options->forward_x11_trusted = -1;
	options->exit_on_forward_failure = -1;
	options->xauth_location = NULL;
	options->gateway_ports = -1;
	options->use_privileged_port = -1;
	options->rsa_authentication = -1;
	options->pubkey_authentication = -1;
	options->challenge_response_authentication = -1;
	options->password_authentication = -1;
	options->kbd_interactive_authentication = -1;
	options->kbd_interactive_devices = NULL;
	options->rhosts_rsa_authentication = -1;
	options->hostbased_authentication = -1;
	options->batch_mode = -1;
	options->check_host_ip = -1;
	options->strict_host_key_checking = -1;
	options->compression = -1;
	options->tcp_keep_alive = -1;
	options->compression_level = -1;
	options->port = -1;
	options->address_family = -1;
	options->connection_attempts = -1;
	options->connection_timeout = -1;
	options->number_of_password_prompts = -1;
	options->cipher = -1;
	options->ciphers = NULL;
	options->macs = NULL;
	options->hostkeyalgorithms = NULL;
	options->protocol = SSH_PROTO_UNKNOWN;
	options->num_identity_files = 0;
	options->hostname = NULL;
	options->host_key_alias = NULL;
	options->proxy_command = NULL;
	options->user = NULL;
	options->escape_char = -1;
	options->system_hostfile = NULL;
	options->user_hostfile = NULL;
	options->system_hostfile2 = NULL;
	options->user_hostfile2 = NULL;
	options->num_local_forwards = 0;
	options->num_remote_forwards = 0;
	options->clear_forwardings = -1;
	options->log_level = SYSLOG_LEVEL_NOT_SET;
	options->preferred_authentications = NULL;
	options->bind_address = NULL;
	options->smartcard_device = NULL;
	options->enable_ssh_keysign = - 1;
	options->no_host_authentication_for_localhost = - 1;
	options->identities_only = - 1;
	options->rekey_limit = - 1;
	options->verify_host_key_dns = -1;
	options->server_alive_interval = -1;
	options->server_alive_count_max = -1;
	options->num_send_env = 0;
	options->control_path = NULL;
	options->control_master = -1;
	options->hash_known_hosts = -1;
	options->tun_open = -1;
	options->tun_local = -1;
	options->tun_remote = -1;
	options->local_command = NULL;
	options->permit_local_command = -1;
	options->visual_host_key = -1;
}

/*
 * Called after processing other sources of option data, this fills those
 * options for which no value has been specified with their default values.
 */

void
fill_default_options(Options *options, struct passwd *pw)
{
	int len;

	if (options->forward_agent == -1)
		options->forward_agent = 0;
	if (options->forward_x11 == -1)
		options->forward_x11 = 0;
	if (options->forward_x11_trusted == -1)
		options->forward_x11_trusted = 0;
	if (options->exit_on_forward_failure == -1)
		options->exit_on_forward_failure = 0;
	if (options->xauth_location == NULL)
		options->xauth_location = (char *)_PATH_XAUTH;
	if (options->gateway_ports == -1)
		options->gateway_ports = 0;
	if (options->use_privileged_port == -1)
		options->use_privileged_port = 0;
	if (options->rsa_authentication == -1)
		options->rsa_authentication = 1;
	if (options->pubkey_authentication == -1)
		options->pubkey_authentication = 1;
	if (options->challenge_response_authentication == -1)
		options->challenge_response_authentication = 1;
	if (options->password_authentication == -1)
		options->password_authentication = 1;
	if (options->kbd_interactive_authentication == -1)
		options->kbd_interactive_authentication = 1;
	if (options->rhosts_rsa_authentication == -1)
		options->rhosts_rsa_authentication = 0;
	if (options->hostbased_authentication == -1)
		options->hostbased_authentication = 0;
	if (options->batch_mode == -1)
		options->batch_mode = 0;
	if (options->check_host_ip == -1)
		options->check_host_ip = 1;
	if (options->strict_host_key_checking == -1)
		options->strict_host_key_checking = 2;	/* 2 is default */
	if (options->compression == -1)
		options->compression = 0;
	if (options->tcp_keep_alive == -1)
		options->tcp_keep_alive = 1;
	if (options->compression_level == -1)
		options->compression_level = 6;
	if (options->port == -1)
		options->port = 0;	/* Filled in ssh_connect. */
	if (options->address_family == -1)
		options->address_family = AF_UNSPEC;
	if (options->connection_attempts == -1)
		options->connection_attempts = 1;
	if (options->number_of_password_prompts == -1)
		options->number_of_password_prompts = 3;
	/* Selected in ssh_login(). */
	if (options->cipher == -1)
		options->cipher = SSH_CIPHER_NOT_SET;
	/* options->ciphers, default set in myproposals.h */
	/* options->macs, default set in myproposals.h */
	/* options->hostkeyalgorithms, default set in myproposals.h */
	if (options->protocol == SSH_PROTO_UNKNOWN)
		options->protocol = SSH_PROTO_1|SSH_PROTO_2;
	if (options->num_identity_files == 0) {
		if (options->protocol & SSH_PROTO_1) {
			len = 2 + strlen(_PATH_SSH_CLIENT_IDENTITY) + 1;
			options->identity_files[options->num_identity_files] =
			    xmalloc(len);
			snprintf(options->identity_files[options->num_identity_files++],
			    len, "~/%.100s", _PATH_SSH_CLIENT_IDENTITY);
		}
		if (options->protocol & SSH_PROTO_2) {
			len = 2 + strlen(_PATH_SSH_CLIENT_ID_RSA) + 1;
			options->identity_files[options->num_identity_files] =
			    xmalloc(len);
			snprintf(options->identity_files[options->num_identity_files++],
			    len, "~/%.100s", _PATH_SSH_CLIENT_ID_RSA);

			len = 2 + strlen(_PATH_SSH_CLIENT_ID_DSA) + 1;
			options->identity_files[options->num_identity_files] =
			    xmalloc(len);
			snprintf(options->identity_files[options->num_identity_files++],
			    len, "~/%.100s", _PATH_SSH_CLIENT_ID_DSA);
		}
	}
	if (options->escape_char == -1)
		options->escape_char = '~';
	if (options->system_hostfile == NULL)
		options->system_hostfile = (char *)_PATH_SSH_SYSTEM_HOSTFILE;
	if (options->user_hostfile == NULL)
		options->user_hostfile =
#ifdef _PATH_SSH_ROOT_HOSTFILE
		    (!pw->pw_dir || !pw->pw_dir[0] || (pw->pw_dir[0] == '/' &&
		    !pw->pw_dir[1])) ? (char *)_PATH_SSH_ROOT_HOSTFILE :
#endif
		    (char *)_PATH_SSH_USER_HOSTFILE;
	if (options->system_hostfile2 == NULL)
		options->system_hostfile2 = (char *)_PATH_SSH_SYSTEM_HOSTFILE2;
	if (options->user_hostfile2 == NULL)
		options->user_hostfile2 = (char *)_PATH_SSH_USER_HOSTFILE2;
	if (options->log_level == SYSLOG_LEVEL_NOT_SET)
		options->log_level = SYSLOG_LEVEL_INFO;
	if (options->clear_forwardings == 1)
		clear_forwardings(options);
	if (options->no_host_authentication_for_localhost == - 1)
		options->no_host_authentication_for_localhost = 0;
	if (options->identities_only == -1)
		options->identities_only = 0;
	if (options->enable_ssh_keysign == -1)
		options->enable_ssh_keysign = 0;
	if (options->rekey_limit == -1)
		options->rekey_limit = 0;
	if (options->verify_host_key_dns == -1)
		options->verify_host_key_dns = 0;
	if (options->server_alive_interval == -1)
		options->server_alive_interval = 0;
	if (options->server_alive_count_max == -1)
		options->server_alive_count_max = 3;
	if (options->control_master == -1)
		options->control_master = 0;
	if (options->hash_known_hosts == -1)
		options->hash_known_hosts = 0;
	if (options->tun_open == -1)
		options->tun_open = SSH_TUNMODE_NO;
	if (options->tun_local == -1)
		options->tun_local = SSH_TUNID_ANY;
	if (options->tun_remote == -1)
		options->tun_remote = SSH_TUNID_ANY;
	if (options->permit_local_command == -1)
		options->permit_local_command = 0;
	if (options->visual_host_key == -1)
		options->visual_host_key = 0;
	/* options->local_command should not be set by default */
	/* options->proxy_command should not be set by default */
	/* options->user will be set in the main program if appropriate */
	/* options->hostname will be set in the main program if appropriate */
	/* options->host_key_alias should not be set by default */
	/* options->preferred_authentications will be set in ssh */
}

/*
 * parse_forward
 * parses a string containing a port forwarding specification of the form:
 *   dynamicfwd == 0
 *	[listenhost:]listenport:connecthost:connectport
 *   dynamicfwd == 1
 *	[listenhost:]listenport
 * returns number of arguments parsed or zero on error
 */
int
parse_forward(Forward *fwd, const char *fwdspec, int dynamicfwd, int remotefwd)
{
	int i;
	char *p, *cp, *fwdarg[4];

	memset(fwd, '\0', sizeof(*fwd));

	cp = p = xstrdup(fwdspec);

	/* skip leading spaces */
	while (isspace(*cp))
		cp++;

	for (i = 0; i < 4; ++i)
		if ((fwdarg[i] = hpdelim(&cp)) == NULL)
			break;

	/* Check for trailing garbage */
	if (cp != NULL)
		i = 0;	/* failure */

	switch (i) {
	case 1:
		fwd->listen_host = NULL;
		fwd->listen_port = a2port(fwdarg[0]);
		fwd->connect_host = xstrdup("socks");
		break;

	case 2:
		fwd->listen_host = xstrdup(cleanhostname(fwdarg[0]));
		fwd->listen_port = a2port(fwdarg[1]);
		fwd->connect_host = xstrdup("socks");
		break;

	case 3:
		fwd->listen_host = NULL;
		fwd->listen_port = a2port(fwdarg[0]);
		fwd->connect_host = xstrdup(cleanhostname(fwdarg[1]));
		fwd->connect_port = a2port(fwdarg[2]);
		break;

	case 4:
		fwd->listen_host = xstrdup(cleanhostname(fwdarg[0]));
		fwd->listen_port = a2port(fwdarg[1]);
		fwd->connect_host = xstrdup(cleanhostname(fwdarg[2]));
		fwd->connect_port = a2port(fwdarg[3]);
		break;
	default:
		i = 0; /* failure */
	}

	xfree(p);

	if (dynamicfwd) {
		if (!(i == 1 || i == 2))
			goto fail_free;
	} else {
		if (!(i == 3 || i == 4))
			goto fail_free;
		if (fwd->connect_port <= 0)
			goto fail_free;
	}

	if (fwd->listen_port < 0 || (!remotefwd && fwd->listen_port == 0))
		goto fail_free;

	if (fwd->connect_host != NULL &&
	    strlen(fwd->connect_host) >= NI_MAXHOST)
		goto fail_free;
	if (fwd->listen_host != NULL &&
	    strlen(fwd->listen_host) >= NI_MAXHOST)
		goto fail_free;


	return (i);

 fail_free:
	if (fwd->connect_host != NULL) {
		xfree(fwd->connect_host);
		fwd->connect_host = NULL;
	}
	if (fwd->listen_host != NULL) {
		xfree(fwd->listen_host);
		fwd->listen_host = NULL;
	}
	return (0);
}
@


1.21
log
@replicate commit “remove experimental, never-enabled JPAKE code; ok markus@@” (djm, 2014/01/29 06:18:35) from upstream
@
text
@d44 1
a44 1
__RCSID("$MirOS: src/usr.bin/ssh/readconf.c,v 1.20 2011/01/15 21:52:40 tg Exp $");
d133 1
a133 1
	oVisualHostKey, oUseRoaming,
d226 1
a226 1
	{ "useroaming", oUseRoaming },
a892 4
	case oUseRoaming:
		intptr = &options->use_roaming;
		goto parse_flag;

a1039 1
	options->use_roaming = -1;
a1175 2
	if (options->use_roaming == -1)
		options->use_roaming = 1;
@


1.20
log
@Introduce /etc/ssh/root:config and /etc/ssh/root:known_hosts
and /etc/ssh/root:authorised_keys for the superuser if his
HOME directory is unset, empty or, not normalised, "/" (root).
十̲CVS: ----------------------------------------------------------------------
@
text
@d44 1
a44 1
__RCSID("$MirOS: src/usr.bin/ssh/readconf.c,v 1.19 2009/10/04 14:29:06 tg Exp $");
d133 1
a133 1
	oVisualHostKey, oUseRoaming, oZeroKnowledgePasswordAuthentication,
a226 6
#ifdef JPAKE
	{ "zeroknowledgepasswordauthentication",
	    oZeroKnowledgePasswordAuthentication },
#else
	{ "zeroknowledgepasswordauthentication", oUnsupported },
#endif
a407 4
	case oZeroKnowledgePasswordAuthentication:
		intptr = &options->zero_knowledge_password_authentication;
		goto parse_flag;

a1045 1
	options->zero_knowledge_password_authentication = -1;
a1184 2
	if (options->zero_knowledge_password_authentication == -1)
		options->zero_knowledge_password_authentication = 0;
@


1.19
log
@• merge newer OpenSSH
• KNF in our diff – style(9)
• some const cleanliness (build with __CRAZY=Yes mostly)
@
text
@d24 1
d44 1
a44 1
__RCSID("$MirOS: src/usr.bin/ssh/readconf.c,v 1.18 2009/10/02 16:58:48 tg Exp $");
d987 1
a987 1
initialize_options(Options * options)
d1065 1
a1065 1
fill_default_options(Options * options)
d1152 6
a1157 1
		options->user_hostfile = (char *)_PATH_SSH_USER_HOSTFILE;
@


1.18
log
@sync ssh_config and manpage with each other
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.176 2009/02/12 03:00:56 djm Exp $ */
d43 1
a43 1
__RCSID("$MirOS: src/usr.bin/ssh/readconf.c,v 1.17 2009/03/22 15:01:18 tg Exp $");
d132 1
a132 1
	oVisualHostKey, oZeroKnowledgePasswordAuthentication,
d225 1
d902 4
d1053 1
d1186 2
@


1.17
log
@merge and tweak ciphers and MACs
@
text
@d43 1
a43 1
__RCSID("$MirOS: src/usr.bin/ssh/readconf.c,v 1.16 2008/12/16 20:55:25 tg Exp $");
d63 1
a63 1
     HostName another.host.name.real.org
@


1.16
log
@fastmerge, do not use yet!
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.173 2008/12/09 02:58:16 djm Exp $ */
d43 1
a43 1
__RCSID("$MirOS: src/usr.bin/ssh/readconf.c,v 1.15 2008/03/02 21:14:20 tg Exp $");
d169 1
a169 1
	{ "identityfile2", oIdentityFile },			/* alias */
d185 2
a186 2
	{ "userknownhostsfile", oUserKnownHostsFile },		/* obsolete */
	{ "globalknownhostsfile2", oGlobalKnownHostsFile2 },
d722 2
a723 1
		    opcode == oDynamicForward ? 1 : 0) == 0)
d1202 1
a1202 1
parse_forward(Forward *fwd, const char *fwdspec, int dynamicfwd)
d1261 1
a1261 1
		if (fwd->connect_port == 0)
d1265 1
a1265 1
	if (fwd->listen_port == 0)
d1271 4
@


1.15
log
@merge’n’fix
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.165 2008/01/19 23:09:49 djm Exp $ */
d43 1
a43 1
__RCSID("$MirOS: src/usr.bin/ssh/readconf.c,v 1.14 2007/04/29 20:23:13 tg Exp $");
d132 1
d161 5
d224 8
d251 1
a251 2
	fwd->listen_host = (newfwd->listen_host == NULL) ?
	    NULL : xstrdup(newfwd->listen_host);
d253 1
a253 1
	fwd->connect_host = xstrdup(newfwd->connect_host);
d271 1
a271 2
	fwd->listen_host = (newfwd->listen_host == NULL) ?
	    NULL : xstrdup(newfwd->listen_host);
d273 1
a273 1
	fwd->connect_host = xstrdup(newfwd->connect_host);
d412 4
d702 1
a706 4
		arg2 = strdelim(&s);
		if (arg2 == NULL || *arg2 == '\0')
			fatal("%.200s line %d: Missing target argument.",
			    filename, linenum);
d708 12
a719 2
		/* construct a string for parse_forward */
		snprintf(fwdarg, sizeof(fwdarg), "%s:%s", arg, arg2);
d721 2
a722 1
		if (parse_forward(&fwd, fwdarg) == 0)
d727 2
a728 1
			if (opcode == oLocalForward)
a734 26
	case oDynamicForward:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing port argument.",
			    filename, linenum);
		memset(&fwd, '\0', sizeof(fwd));
		fwd.connect_host = (char *)"socks";
		fwd.listen_host = hpdelim(&arg);
		if (fwd.listen_host == NULL ||
		    strlen(fwd.listen_host) >= NI_MAXHOST)
			fatal("%.200s line %d: Bad forwarding specification.",
			    filename, linenum);
		if (arg) {
			fwd.listen_port = a2port(arg);
			fwd.listen_host = cleanhostname(fwd.listen_host);
		} else {
			fwd.listen_port = a2port(fwd.listen_host);
			fwd.listen_host = NULL;
		}
		if (fwd.listen_port == 0)
			fatal("%.200s line %d: Badly formatted port number.",
			    filename, linenum);
		if (*activep)
			add_local_forward(options, &fwd);
		break;

d896 4
a937 1
	/* Open the file. */
d1047 2
d1179 4
d1194 1
d1196 2
d1201 1
a1201 1
parse_forward(Forward *fwd, const char *fwdspec)
d1218 1
a1218 1
	/* Check for trailing garbage in 4-arg case*/
d1223 12
d1254 11
a1264 1
	if (fwd->listen_port == 0 || fwd->connect_port == 0)
d1274 1
a1274 1
	if (fwd->connect_host != NULL)
d1276 3
a1278 1
	if (fwd->listen_host != NULL)
d1280 2
@


1.14
log
@merge openssh
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.162 2007/03/20 03:56:12 tedu Exp $ */
d43 1
a43 1
__RCSID("$MirOS: src/usr.bin/ssh/readconf.c,v 1.13 2007/01/25 16:18:36 tg Exp $");
d316 1
a480 1
		intptr = &options->rekey_limit;
d508 1
a508 1
		if ((val64 / scale) != orig || val64 > INT_MAX)
d514 2
a515 2
		if (*activep && *intptr == -1)
			*intptr = (int)val64;
d674 1
a674 1
		intptr = (int *) &options->log_level;
d680 2
a681 2
		if (*activep && (LogLevel) *intptr == SYSLOG_LEVEL_NOT_SET)
			*intptr = (LogLevel) value;
d1231 1
a1231 1
	if (fwd->listen_port == 0 && fwd->connect_port == 0)
@


1.13
log
@automerge, bump vsn
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.161 2007/01/21 01:45:35 stevesk Exp $ */
d43 1
a43 1
__RCSID("$MirOS: src/usr.bin/ssh/readconf.c,v 1.12 2006/09/20 21:41:00 tg Exp $");
d1200 1
a1200 1
	while (*cp && isspace(*cp))
@


1.12
log
@finish merging
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.159 2006/08/03 03:34:42 deraadt Exp $ */
d43 1
a43 1
__RCSID("$MirOS$");
d354 1
a354 1
		if (*intptr == -1)
d527 1
a527 1
			charptr =  &options->identity_files[*intptr];
@


1.11
log
@* merge
* remove all references to GSSAPI, Kerberos and AFS
* uint*_t -> u_int*_t for consistency, like openbsd
  (note: MirOS style(9) suggests uint32_t etc. instead!)
* bump vsn
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.151 2006/03/25 13:17:02 djm Exp $ */
d15 3
a17 2
#include "includes.h"
__RCSID("$MirOS: src/usr.bin/ssh/readconf.c,v 1.10 2006/04/19 10:40:50 tg Exp $");
d19 1
a19 1
#include <sys/stat.h>
d22 6
d29 1
a30 1
#include "xmalloc.h"
d35 1
d39 1
d43 2
d113 1
d144 1
d387 4
d984 1
d1063 2
@


1.10
log
@merge and clean up
@
text
@d16 1
a16 1
__RCSID("$MirOS: src/usr.bin/ssh/readconf.c,v 1.9 2006/02/22 02:16:47 tg Exp $");
a146 5
	{ "kerberosauthentication", oUnsupported },
	{ "kerberostgtpassing", oUnsupported },
	{ "afstokenpassing", oUnsupported },
	{ "gssapiauthentication", oUnsupported },
	{ "gssapidelegatecredentials", oUnsupported },
@


1.9
log
@fix a lot of and kludge a few more __CRAZY problems, sync rcs id
@
text
@d1 1
d16 1
a16 1
RCSID("$MirOS: src/usr.bin/ssh/readconf.c,v 1.8 2006/02/22 01:23:49 tg Exp $");
d20 2
d321 2
a322 1
	keyword = strdelim(&s);
@


1.8
log
@merge; bump version; fix up manpages and includes a little
@
text
@d15 1
a15 1
RCSID("$MirOS: src/usr.bin/ssh/readconf.c,v 1.7 2005/12/20 19:57:33 tg Exp $");
d700 1
a700 1
		fwd.connect_host = "socks";
d1047 1
a1047 1
		options->xauth_location = _PATH_XAUTH;
d1119 1
a1119 1
		options->system_hostfile = _PATH_SSH_SYSTEM_HOSTFILE;
d1121 1
a1121 1
		options->user_hostfile = _PATH_SSH_USER_HOSTFILE;
d1123 1
a1123 1
		options->system_hostfile2 = _PATH_SSH_SYSTEM_HOSTFILE2;
d1125 1
a1125 1
		options->user_hostfile2 = _PATH_SSH_USER_HOSTFILE2;
@


1.7
log
@fastmerge, bump version
@
text
@d15 3
a17 1
RCSID("$MirOS: src/usr.bin/ssh/readconf.c,v 1.6 2005/11/23 19:45:14 tg Exp $");
d304 2
a305 1
	int opcode, *intptr, value, value2;
d470 1
a470 1
		value = strtol(arg, &endofnumber, 10);
d474 3
d478 1
a478 1
			value *= 1<<10;
d481 1
a481 1
			value *= 1<<20;
d484 1
a484 1
			value *= 1<<30;
d486 3
d490 8
d499 1
a499 1
			*intptr = value;
@


1.6
log
@merge
@
text
@d15 1
a15 1
RCSID("$MirOS: src/usr.bin/ssh/readconf.c,v 1.5 2005/11/23 18:04:20 tg Exp $");
d73 4
d114 1
d201 4
d269 1
d302 1
a302 1
	int opcode, *intptr, value;
d551 2
a554 1
		charptr = &options->proxy_command;
d821 43
d1006 5
d1131 9
@


1.5
log
@fastmerge remainder of src/usr.bin
@
text
@d15 1
a15 1
RCSID("$MirOS: src/usr.bin/ssh/readconf.c,v 1.4 2005/06/22 16:11:39 tg Exp $");
d683 1
a683 1
			fwd.listen_host = "";
@


1.4
log
@merge
@
text
@d15 1
a15 1
RCSID("$MirOS: src/usr.bin/ssh/readconf.c,v 1.3 2005/04/14 19:49:34 tg Exp $");
d827 1
a827 1
		     filename, linenum, arg);
@


1.3
log
@merge
@
text
@d15 1
a15 1
RCSID("$MirOS: src/usr.bin/ssh/readconf.c,v 1.2 2005/03/13 18:33:30 tg Exp $");
d731 3
d784 21
a804 1
		goto parse_yesnoask;
@


1.2
log
@merge src/usr.bin
@
text
@d15 1
a15 1
RCSID("$MirOS$");
d109 1
a109 1
	oSendEnv, oControlPath, oControlMaster,
d195 1
d205 1
a205 2
add_local_forward(Options *options, u_short port, const char *host,
		  u_short host_port)
d209 1
a209 1
	if (port < IPPORT_RESERVED && original_real_uid != 0)
d214 6
a219 3
	fwd->port = port;
	fwd->host = xstrdup(host);
	fwd->host_port = host_port;
d228 1
a228 2
add_remote_forward(Options *options, u_short port, const char *host,
		   u_short host_port)
d235 6
a240 3
	fwd->port = port;
	fwd->host = xstrdup(host);
	fwd->host_port = host_port;
d248 5
a252 2
	for (i = 0; i < options->num_local_forwards; i++)
		xfree(options->local_forwards[i].host);
d254 5
a258 2
	for (i = 0; i < options->num_remote_forwards; i++)
		xfree(options->remote_forwards[i].host);
d291 1
a291 1
	char buf[256], *s, **charptr, *endofnumber, *keyword, *arg;
d294 1
a294 2
	u_short fwd_port, fwd_host_port;
	char sfwd_host_port[6];
d297 1
a297 1
	for(len = strlen(line) - 1; len > 0; len--) {
d643 1
a643 1
		if (!arg || *arg == '\0')
d646 3
a648 2
		if ((fwd_port = a2port(arg)) == 0)
			fatal("%.200s line %d: Bad listen port.",
d650 5
a654 6
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing second argument.",
			    filename, linenum);
		if (sscanf(arg, "%255[^:]:%5[0-9]", buf, sfwd_host_port) != 2 &&
		    sscanf(arg, "%255[^/]/%5[0-9]", buf, sfwd_host_port) != 2)
d657 1
a657 3
		if ((fwd_host_port = a2port(sfwd_host_port)) == 0)
			fatal("%.200s line %d: Bad forwarding port.",
			    filename, linenum);
d660 1
a660 2
				add_local_forward(options, fwd_port, buf,
				    fwd_host_port);
d662 1
a662 2
				add_remote_forward(options, fwd_port, buf,
				    fwd_host_port);
d671 15
a685 2
		fwd_port = a2port(arg);
		if (fwd_port == 0)
d689 1
a689 1
			add_local_forward(options, fwd_port, "socks", 0);
d765 2
d783 4
d928 1
d1047 2
d1055 65
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.134 2004/07/11 17:48:47 deraadt Exp $");
d82 1
a82 1
     IdentityFile ~/.ssh/identity
d107 1
a107 1
	oAddressFamily, oGssAuthentication, oGssDelegateCreds,
a139 4
#if defined(GSSAPI)
	{ "gssapiauthentication", oGssAuthentication },
	{ "gssapidelegatecredentials", oGssDelegateCreds },
#else
a141 1
#endif
a387 8
	case oGssAuthentication:
		intptr = &options->gss_authentication;
		goto parse_flag;

	case oGssDelegateCreds:
		intptr = &options->gss_deleg_creds;
		goto parse_flag;

a854 2
	options->gss_authentication = -1;
	options->gss_deleg_creds = -1;
a932 4
	if (options->gss_authentication == -1)
		options->gss_authentication = 0;
	if (options->gss_deleg_creds == -1)
		options->gss_deleg_creds = 0;
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@OpenSSH-current
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.139 2005/03/10 22:01:05 deraadt Exp $");
d109 1
a109 1
	oSendEnv, oControlPath, oControlMaster, oHashKnownHosts,
a199 1
	{ "hashknownhosts", oHashKnownHosts },
d209 2
a210 1
add_local_forward(Options *options, const Forward *newfwd)
d214 1
a214 1
	if (newfwd->listen_port < IPPORT_RESERVED && original_real_uid != 0)
d219 3
a221 6

	fwd->listen_host = (newfwd->listen_host == NULL) ?
	    NULL : xstrdup(newfwd->listen_host);
	fwd->listen_port = newfwd->listen_port;
	fwd->connect_host = xstrdup(newfwd->connect_host);
	fwd->connect_port = newfwd->connect_port;
d230 2
a231 1
add_remote_forward(Options *options, const Forward *newfwd)
d238 3
a240 6

	fwd->listen_host = (newfwd->listen_host == NULL) ?
	    NULL : xstrdup(newfwd->listen_host);
	fwd->listen_port = newfwd->listen_port;
	fwd->connect_host = xstrdup(newfwd->connect_host);
	fwd->connect_port = newfwd->connect_port;
d248 2
a249 5
	for (i = 0; i < options->num_local_forwards; i++) {
		if (options->local_forwards[i].listen_host != NULL)
			xfree(options->local_forwards[i].listen_host);
		xfree(options->local_forwards[i].connect_host);
	}
d251 2
a252 5
	for (i = 0; i < options->num_remote_forwards; i++) {
		if (options->remote_forwards[i].listen_host != NULL)
			xfree(options->remote_forwards[i].listen_host);
		xfree(options->remote_forwards[i].connect_host);
	}
d285 1
a285 1
	char *s, **charptr, *endofnumber, *keyword, *arg, *arg2, fwdarg[256];
d288 2
a289 1
	Forward fwd;
d292 1
a292 1
	for (len = strlen(line) - 1; len > 0; len--) {
d646 1
a646 1
		if (arg == NULL || *arg == '\0')
d649 2
a650 3
		arg2 = strdelim(&s);
		if (arg2 == NULL || *arg2 == '\0')
			fatal("%.200s line %d: Missing target argument.",
d652 6
a657 5

		/* construct a string for parse_forward */
		snprintf(fwdarg, sizeof(fwdarg), "%s:%s", arg, arg2);

		if (parse_forward(&fwd, fwdarg) == 0)
d660 3
a662 1

d665 2
a666 1
				add_local_forward(options, &fwd);
d668 2
a669 1
				add_remote_forward(options, &fwd);
d678 2
a679 15
		memset(&fwd, '\0', sizeof(fwd));
		fwd.connect_host = "socks";
		fwd.listen_host = hpdelim(&arg);
		if (fwd.listen_host == NULL ||
		    strlen(fwd.listen_host) >= NI_MAXHOST)
			fatal("%.200s line %d: Bad forwarding specification.",
			    filename, linenum);
		if (arg) {
			fwd.listen_port = a2port(arg);
			fwd.listen_host = cleanhostname(fwd.listen_host);
		} else {
			fwd.listen_port = a2port(fwd.listen_host);
			fwd.listen_host = "";
		}
		if (fwd.listen_port == 0)
d683 1
a683 1
			add_local_forward(options, &fwd);
a758 2
			if (!*activep)
				continue;
a774 4
	case oHashKnownHosts:
		intptr = &options->hash_known_hosts;
		goto parse_flag;

a917 1
	options->hash_known_hosts = -1;
a1039 2
	if (options->hash_known_hosts == -1)
		options->hash_known_hosts = 0;
a1045 65

/*
 * parse_forward
 * parses a string containing a port forwarding specification of the form:
 *	[listenhost:]listenport:connecthost:connectport
 * returns number of arguments parsed or zero on error
 */
int
parse_forward(Forward *fwd, const char *fwdspec)
{
	int i;
	char *p, *cp, *fwdarg[4];

	memset(fwd, '\0', sizeof(*fwd));

	cp = p = xstrdup(fwdspec);

	/* skip leading spaces */
	while (*cp && isspace(*cp))
		cp++;

	for (i = 0; i < 4; ++i)
		if ((fwdarg[i] = hpdelim(&cp)) == NULL)
			break;

	/* Check for trailing garbage in 4-arg case*/
	if (cp != NULL)
		i = 0;	/* failure */

	switch (i) {
	case 3:
		fwd->listen_host = NULL;
		fwd->listen_port = a2port(fwdarg[0]);
		fwd->connect_host = xstrdup(cleanhostname(fwdarg[1]));
		fwd->connect_port = a2port(fwdarg[2]);
		break;

	case 4:
		fwd->listen_host = xstrdup(cleanhostname(fwdarg[0]));
		fwd->listen_port = a2port(fwdarg[1]);
		fwd->connect_host = xstrdup(cleanhostname(fwdarg[2]));
		fwd->connect_port = a2port(fwdarg[3]);
		break;
	default:
		i = 0; /* failure */
	}

	xfree(p);

	if (fwd->listen_port == 0 && fwd->connect_port == 0)
		goto fail_free;

	if (fwd->connect_host != NULL &&
	    strlen(fwd->connect_host) >= NI_MAXHOST)
		goto fail_free;

	return (i);

 fail_free:
	if (fwd->connect_host != NULL)
		xfree(fwd->connect_host);
	if (fwd->listen_host != NULL)
		xfree(fwd->listen_host);
	return (0);
}
@


1.1.1.3
log
@most current OpenSSH.com
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.141 2005/06/08 11:25:09 djm Exp $");
a743 3
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing address family.",
			    filename, linenum);
d794 1
a794 21
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing ControlMaster argument.",
			    filename, linenum);
		value = 0;	/* To avoid compiler warning... */
		if (strcmp(arg, "yes") == 0 || strcmp(arg, "true") == 0)
			value = SSHCTL_MASTER_YES;
		else if (strcmp(arg, "no") == 0 || strcmp(arg, "false") == 0)
			value = SSHCTL_MASTER_NO;
		else if (strcmp(arg, "auto") == 0)
			value = SSHCTL_MASTER_AUTO;
		else if (strcmp(arg, "ask") == 0)
			value = SSHCTL_MASTER_ASK;
		else if (strcmp(arg, "autoask") == 0)
			value = SSHCTL_MASTER_AUTO_ASK;
		else
			fatal("%.200s line %d: Bad ControlMaster argument.",
			    filename, linenum);
		if (*activep && *intptr == -1)
			*intptr = value;
		break;
@


1.1.1.4
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.142 2005/07/17 07:17:55 djm Exp $");
d840 1
a840 1
		    filename, linenum, arg);
@


1.1.1.5
log
@Import current OpenSSH
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.143 2005/07/30 02:03:47 djm Exp $");
d696 1
a696 1
			fwd.listen_host = NULL;
@


1.1.1.6
log
@OpenSSH is the last missing piece to update before the release
@
text
@d15 1
a15 1
RCSID("$OpenBSD: readconf.c,v 1.145 2005/12/08 18:34:11 reyk Exp $");
a72 4
   Host vpn.fake.com
     Tunnel yes
     TunnelDevice 3

a109 1
	oTunnel, oTunnelDevice, oLocalCommand, oPermitLocalCommand,
a200 4
	{ "tunnel", oTunnel },
	{ "tunneldevice", oTunnelDevice },
	{ "localcommand", oLocalCommand },
	{ "permitlocalcommand", oPermitLocalCommand },
a264 1
	options->tun_open = SSH_TUNMODE_NO;
d297 1
a297 1
	int opcode, *intptr, value, value2;
a553 2
		charptr = &options->proxy_command;
parse_command:
d556 1
a822 43
	case oTunnel:
		intptr = &options->tun_open;
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing yes/point-to-point/"
			    "ethernet/no argument.", filename, linenum);
		value = 0;	/* silence compiler */
		if (strcasecmp(arg, "ethernet") == 0)
			value = SSH_TUNMODE_ETHERNET;
		else if (strcasecmp(arg, "point-to-point") == 0)
			value = SSH_TUNMODE_POINTOPOINT;
		else if (strcasecmp(arg, "yes") == 0)
			value = SSH_TUNMODE_DEFAULT;
		else if (strcasecmp(arg, "no") == 0)
			value = SSH_TUNMODE_NO;
		else
			fatal("%s line %d: Bad yes/point-to-point/ethernet/"
			    "no argument: %s", filename, linenum, arg);
		if (*activep)
			*intptr = value;
		break;

	case oTunnelDevice:
		arg = strdelim(&s);
		if (!arg || *arg == '\0')
			fatal("%.200s line %d: Missing argument.", filename, linenum);
		value = a2tun(arg, &value2);
		if (value == SSH_TUNID_ERR)
			fatal("%.200s line %d: Bad tun device.", filename, linenum);
		if (*activep) {
			options->tun_local = value;
			options->tun_remote = value2;
		}
		break;

	case oLocalCommand:
		charptr = &options->local_command;
		goto parse_command;

	case oPermitLocalCommand:
		intptr = &options->permit_local_command;
		goto parse_flag;

a966 5
	options->tun_open = -1;
	options->tun_local = -1;
	options->tun_remote = -1;
	options->local_command = NULL;
	options->permit_local_command = -1;
a1090 9
	if (options->tun_open == -1)
		options->tun_open = SSH_TUNMODE_NO;
	if (options->tun_local == -1)
		options->tun_local = SSH_TUNID_ANY;
	if (options->tun_remote == -1)
		options->tun_remote = SSH_TUNID_ANY;
	if (options->permit_local_command == -1)
		options->permit_local_command = 0;
	/* options->local_command should not be set by default */
@


1.1.1.7
log
@import OpenSSH-current
@
text
@d15 1
a15 4
RCSID("$OpenBSD: readconf.c,v 1.147 2006/02/20 17:19:54 stevesk Exp $");

#include <sys/types.h>
#include <sys/stat.h>
d307 1
a307 2
	int opcode, *intptr, value, value2, scale;
	long long orig, val64;
d480 1
a480 1
		orig = val64 = strtoll(arg, &endofnumber, 10);
a483 3
		case '\0':
			scale = 1;
			break;
d485 1
a485 1
			scale = 1<<10;
d488 1
a488 1
			scale = 1<<20;
d491 1
a491 1
			scale = 1<<30;
a492 3
		default:
			fatal("%.200s line %d: Invalid RekeyLimit suffix",
			    filename, linenum);
a493 8
		val64 *= scale;
		/* detect integer wrap and too-large limits */
		if ((val64 / scale) != orig || val64 > INT_MAX)
			fatal("%.200s line %d: RekeyLimit too large",
			    filename, linenum);
		if (val64 < 16)
			fatal("%.200s line %d: RekeyLimit too small",
			    filename, linenum);
d495 1
a495 1
			*intptr = (int)val64;
@


1.1.1.8
log
@I decided we'd better upgrade OpenSSH before releasing to the general public
@
text
@a0 1
/* $OpenBSD: readconf.c,v 1.151 2006/03/25 13:17:02 djm Exp $ */
d15 1
a19 2
#include <ctype.h>

d324 1
a324 2
	if ((keyword = strdelim(&s)) == NULL)
		return 0;
@


1.1.1.9
log
@import a few security-wise relevant changes right now
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.159 2006/08/03 03:34:42 deraadt Exp $ */
d15 2
a18 3
#include <sys/socket.h>

#include <netinet/in.h>
a20 6
#include <errno.h>
#include <netdb.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
d22 1
a23 1
#include "ssh.h"
a27 1
#include "key.h"
a30 1
#include "buffer.h"
a101 1
	oExitOnForwardFailure,
a131 1
	{ "exitonforwardfailure", oExitOnForwardFailure },
a383 4
	case oExitOnForwardFailure:
		intptr = &options->exit_on_forward_failure;
		goto parse_flag;

a984 1
	options->exit_on_forward_failure = -1;
a1064 2
	if (options->exit_on_forward_failure == -1)
		options->exit_on_forward_failure = 0;
@


1.1.1.10
log
@update OpenSSH, while we're at it…
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.161 2007/01/21 01:45:35 stevesk Exp $ */
d362 1
a362 1
		if (*activep && *intptr == -1)
d543 1
a543 1
			charptr = &options->identity_files[*intptr];
@


1.1.1.11
log
@import openbsd compress, ssh, perl, sendmail for minor bugfixes
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.162 2007/03/20 03:56:12 tedu Exp $ */
d1222 1
a1222 1
	while (isspace(*cp))
@


1.1.1.12
log
@newer openssh
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.165 2008/01/19 23:09:49 djm Exp $ */
a323 1
	LogLevel *log_level_ptr;
d496 1
d524 1
a524 1
		if ((val64 / scale) != orig || val64 > UINT_MAX)
d530 2
a531 2
		if (*activep && options->rekey_limit == -1)
			options->rekey_limit = (u_int32_t)val64;
d690 1
a690 1
		log_level_ptr = &options->log_level;
d696 2
a697 2
		if (*activep && *log_level_ptr == SYSLOG_LEVEL_NOT_SET)
			*log_level_ptr = (LogLevel) value;
d1253 1
a1253 1
	if (fwd->listen_port == 0 || fwd->connect_port == 0)
@


1.1.1.13
log
@OpenSSH-current
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.173 2008/12/09 02:58:16 djm Exp $ */
a129 1
	oVisualHostKey, oZeroKnowledgePasswordAuthentication,
a225 8
	{ "visualhostkey", oVisualHostKey },
#ifdef JPAKE
	{ "zeroknowledgepasswordauthentication",
	    oZeroKnowledgePasswordAuthentication },
#else
	{ "zeroknowledgepasswordauthentication", oUnsupported },
#endif

d245 2
a246 1
	fwd->listen_host = newfwd->listen_host;
d248 1
a248 1
	fwd->connect_host = newfwd->connect_host;
d266 2
a267 1
	fwd->listen_host = newfwd->listen_host;
d269 1
a269 1
	fwd->connect_host = newfwd->connect_host;
a407 4
	case oZeroKnowledgePasswordAuthentication:
		intptr = &options->zero_knowledge_password_authentication;
		goto parse_flag;

a701 1
	case oDynamicForward:
d706 4
d711 2
a712 12
		if (opcode == oLocalForward ||
		    opcode == oRemoteForward) {
			arg2 = strdelim(&s);
			if (arg2 == NULL || *arg2 == '\0')
				fatal("%.200s line %d: Missing target argument.",
				    filename, linenum);

			/* construct a string for parse_forward */
			snprintf(fwdarg, sizeof(fwdarg), "%s:%s", arg, arg2);
		} else if (opcode == oDynamicForward) {
			strlcpy(fwdarg, arg, sizeof(fwdarg));
		}
d714 1
a714 2
		if (parse_forward(&fwd, fwdarg,
		    opcode == oDynamicForward ? 1 : 0) == 0)
d719 1
a719 2
			if (opcode == oLocalForward ||
			    opcode == oDynamicForward)
d726 26
a912 4
	case oVisualHostKey:
		intptr = &options->visual_host_key;
		goto parse_flag;

d951 1
a1062 2
	options->visual_host_key = -1;
	options->zero_knowledge_password_authentication = -1;
a1196 4
	if (options->visual_host_key == -1)
		options->visual_host_key = 0;
	if (options->zero_knowledge_password_authentication == -1)
		options->zero_knowledge_password_authentication = 0;
a1207 1
 *   dynamicfwd == 0
a1208 2
 *   dynamicfwd == 1
 *	[listenhost:]listenport
d1212 1
a1212 1
parse_forward(Forward *fwd, const char *fwdspec, int dynamicfwd)
d1229 1
a1229 1
	/* Check for trailing garbage */
a1233 12
	case 1:
		fwd->listen_host = NULL;
		fwd->listen_port = a2port(fwdarg[0]);
		fwd->connect_host = xstrdup("socks");
		break;

	case 2:
		fwd->listen_host = xstrdup(cleanhostname(fwdarg[0]));
		fwd->listen_port = a2port(fwdarg[1]);
		fwd->connect_host = xstrdup("socks");
		break;

d1253 1
a1253 11
	if (dynamicfwd) {
		if (!(i == 1 || i == 2))
			goto fail_free;
	} else {
		if (!(i == 3 || i == 4))
			goto fail_free;
		if (fwd->connect_port == 0)
			goto fail_free;
	}

	if (fwd->listen_port == 0)
d1263 1
a1263 1
	if (fwd->connect_host != NULL) {
d1265 1
a1265 3
		fwd->connect_host = NULL;
	}
	if (fwd->listen_host != NULL) {
a1266 2
		fwd->listen_host = NULL;
	}
@


1.1.1.14
log
@OpenSSH 5.2, or so
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.176 2009/02/12 03:00:56 djm Exp $ */
d172 1
a172 1
	{ "identityfile2", oIdentityFile },			/* obsolete */
d188 2
a189 2
	{ "globalknownhostsfile2", oGlobalKnownHostsFile2 },	/* obsolete */
	{ "userknownhostsfile", oUserKnownHostsFile },
d733 1
a733 2
		    opcode == oDynamicForward ? 1 : 0,
		    opcode == oRemoteForward ? 1 : 0) == 0)
d1218 1
a1218 1
parse_forward(Forward *fwd, const char *fwdspec, int dynamicfwd, int remotefwd)
d1277 1
a1277 1
		if (fwd->connect_port <= 0)
d1281 1
a1281 1
	if (fwd->listen_port < 0 || (!remotefwd && fwd->listen_port == 0))
a1286 4
	if (fwd->listen_host != NULL &&
	    strlen(fwd->listen_host) >= NI_MAXHOST)
		goto fail_free;

@


1.1.1.15
log
@Let’s play the version number game – OpenSSH 5.3-current
@
text
@d1 1
a1 1
/* $OpenBSD: readconf.c,v 1.177 2009/06/27 09:35:06 andreas Exp $ */
d130 1
a130 1
	oVisualHostKey, oUseRoaming, oZeroKnowledgePasswordAuthentication,
a227 1
	{ "useroaming", oUseRoaming },
a911 4
	case oUseRoaming:
		intptr = &options->use_roaming;
		goto parse_flag;

a1060 1
	options->use_roaming = -1;
a1196 2
	if (options->use_roaming == -1)
		options->use_roaming = 1;
@


