head	1.24;
access;
symbols
	cvs-200910041320:1.1.1.18
	cvs-200903221200:1.1.1.17
	cvs-200812162015:1.1.1.16
	cvs-200804031830:1.1.1.15
	MIRBSD_10:1.19.0.2
	MIRBSD_10_BASE:1.19
	cvs-200803022030:1.1.1.15
	cvs-200709131337:1.1.1.14
	cvs-200709021830:1.1.1.13
	cvs-200708201200:1.1.1.13
	cvs-200706161500:1.1.1.13
	cvs-200705192215:1.1.1.13
	cvs-200704292000:1.1.1.13
	cvs-200703080900:1.1.1.13
	cvs-200701251600:1.1.1.13
	cvs-200612111600:1.1.1.12
	cvs-200611090230:1.1.1.11
	OPENBSD_4_0:1.1.1.10
	MIRBSD_9_BASE:1.13
	cvs-200606162342:1.1.1.9
	cvs-200606022000:1.1.1.9
	cvs-200604191000:1.1.1.8
	cvs-200602220045:1.1.1.7
	MIRBSD_8:1.7.0.2
	MIRBSD_8_BASE:1.7
	cvs-200512201942:1.1.1.6
	cvs-200511231930:1.1.1.5
	cvs-200507211800:1.1.1.4
	cvs-200506221550:1.1.1.3
	cvs-200505050030:1.1.1.2
	cvs-200504291700:1.1.1.2
	cvs-200504261445:1.1.1.2
	cvs-200504141900:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2014.03.12.23.19.37;	author tg;	state Exp;
branches;
next	1.23;
commitid	1005320EBA21FB9B272;

1.23
date	2011.01.15.21.52.42;	author tg;	state Exp;
branches;
next	1.22;
commitid	1004D32173B08BB4E36;

1.22
date	2009.10.04.14.29.10;	author tg;	state Exp;
branches;
next	1.21;
commitid	1004AC8B1276FC00211;

1.21
date	2009.03.22.15.01.21;	author tg;	state Exp;
branches;
next	1.20;
commitid	10049C652CD5CCC321F;

1.20
date	2008.12.16.20.55.29;	author tg;	state Exp;
branches;
next	1.19;
commitid	100494815C97ECEEDBF;

1.19
date	2008.03.02.21.14.22;	author tg;	state Exp;
branches;
next	1.18;
commitid	10047CB18BB506A8527;

1.18
date	2007.09.13.13.52.55;	author tg;	state Exp;
branches;
next	1.17;
commitid	10046E940B668DE9A0B;

1.17
date	2007.01.25.16.18.38;	author tg;	state Exp;
branches;
next	1.16;
commitid	10045B8D86E5B698AD6;

1.16
date	2006.12.11.20.22.09;	author tg;	state Exp;
branches;
next	1.15;
commitid	100457DBDF745B9BD3B;

1.15
date	2006.11.09.02.42.06;	author tg;	state Exp;
branches;
next	1.14;
commitid	1004552959372C0CB8B;

1.14
date	2006.09.20.21.41.05;	author tg;	state Exp;
branches;
next	1.13;
commitid	1004511B578580E7F04;

1.13
date	2006.06.02.20.50.50;	author tg;	state Exp;
branches;
next	1.12;
commitid	1004480A4952B0D84EA;

1.12
date	2006.04.19.10.40.54;	author tg;	state Exp;
branches;
next	1.11;
commitid	100444613BD3A91C28B;

1.11
date	2006.02.22.02.16.49;	author tg;	state Exp;
branches;
next	1.10;
commitid	10043FBC991512A442B;

1.10
date	2006.02.22.01.23.51;	author tg;	state Exp;
branches;
next	1.9;
commitid	10043FBBD2C2C5E7D81;

1.9
date	2006.01.30.15.47.04;	author tg;	state Exp;
branches;
next	1.8;
commitid	10043DE34ED221FC574;

1.8
date	2006.01.30.15.21.47;	author tg;	state Exp;
branches;
next	1.7;
commitid	10043DE2F1B62BF0E43;

1.7
date	2005.12.20.19.57.36;	author tg;	state Exp;
branches;
next	1.6;
commitid	10043A8623F4C1F637E;

1.6
date	2005.11.23.19.45.15;	author tg;	state Exp;
branches;
next	1.5;
commitid	29f4384c6def7d1;

1.5
date	2005.11.23.18.04.20;	author tg;	state Exp;
branches;
next	1.4;
commitid	af74384af2ab463;

1.4
date	2005.06.22.16.11.39;	author tg;	state Exp;
branches;
next	1.3;
commitid	598b42b98dcf335f;

1.3
date	2005.04.14.19.49.34;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.13.18.33.32;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.29.55;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.29.55;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.14.19.33.29;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.06.22.15.56.28;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	181342b98a38fe99;

1.1.1.4
date	2005.07.21.21.00.34;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	560042e0092f571e;

1.1.1.5
date	2005.11.23.19.34.15;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	116a4384c4467ffc;

1.1.1.6
date	2005.12.20.19.43.46;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	10043A85EF81EF097CF;

1.1.1.7
date	2006.02.22.00.51.36;	author tg;	state Exp;
branches;
next	1.1.1.8;
commitid	10043FBB5A933C3BB9B;

1.1.1.8
date	2006.04.19.10.15.04;	author tg;	state Exp;
branches;
next	1.1.1.9;
commitid	10044460DB21E1F715C;

1.1.1.9
date	2006.06.02.20.31.52;	author tg;	state Exp;
branches;
next	1.1.1.10;
commitid	1004480A0422110D712;

1.1.1.10
date	2006.09.20.19.06.50;	author tg;	state Exp;
branches;
next	1.1.1.11;
commitid	10045119150397FC669;

1.1.1.11
date	2006.11.09.02.38.01;	author tg;	state Exp;
branches;
next	1.1.1.12;
commitid	100455294981A6201C8;

1.1.1.12
date	2006.12.11.16.19.12;	author tg;	state Exp;
branches;
next	1.1.1.13;
commitid	100457D84FB7120C6DA;

1.1.1.13
date	2007.01.25.16.13.20;	author tg;	state Exp;
branches;
next	1.1.1.14;
commitid	10045B8D7100791C016;

1.1.1.14
date	2007.09.13.13.39.05;	author tg;	state Exp;
branches;
next	1.1.1.15;
commitid	10046E93D7724AAC1F8;

1.1.1.15
date	2008.03.02.20.40.42;	author tg;	state Exp;
branches;
next	1.1.1.16;
commitid	10047CB10DD30FAF062;

1.1.1.16
date	2008.12.16.20.15.34;	author tg;	state Exp;
branches;
next	1.1.1.17;
commitid	10049480C7A2701F5C0;

1.1.1.17
date	2009.03.22.12.03.00;	author tg;	state Exp;
branches;
next	1.1.1.18;
commitid	10049C6290649163EA3;

1.1.1.18
date	2009.10.04.13.25.45;	author tg;	state Exp;
branches;
next	;
commitid	1004AC8A2663BC008C5;


desc
@@


1.24
log
@stop using arc4random_stir in ssh-keygen
@
text
@/* $OpenBSD: ssh-keygen.c,v 1.175 2009/08/27 17:33:49 djm Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1994 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * Identity and host key generation and maintenance.
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */

#include <sys/param.h>
#include <sys/socket.h>
#include <sys/stat.h>

#include <openssl/evp.h>
#include <openssl/pem.h>
#include <openssl/err.h>

#include <errno.h>
#include <fcntl.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "xmalloc.h"
#include "key.h"
#include "rsa.h"
#include "authfile.h"
#include "uuencode.h"
#include "buffer.h"
#include "pathnames.h"
#include "log.h"
#include "misc.h"
#include "match.h"
#include "hostfile.h"
#include "dns.h"

#ifdef SMARTCARD
#include "scard.h"
#endif

__RCSID("$MirOS: src/usr.bin/ssh/ssh-keygen.c,v 1.23 2011/01/15 21:52:42 tg Exp $");

/* Number of bits in the RSA/DSA key.  This value can be set on the command line. */
#define DEFAULT_BITS		2048
#define DEFAULT_BITS_DSA	1024
u_int32_t bits = 0;

/*
 * Flag indicating that we just want to change the passphrase.  This can be
 * set on the command line.
 */
int change_passphrase = 0;

/*
 * Flag indicating that we just want to change the comment.  This can be set
 * on the command line.
 */
int change_comment = 0;

int quiet = 0;

int log_level = SYSLOG_LEVEL_INFO;

/* Flag indicating that we want to hash a known_hosts file */
int hash_hosts = 0;
/* Flag indicating that we want lookup a host in known_hosts file */
int find_host = 0;
/* Flag indicating that we want to delete a host from a known_hosts file */
int delete_host = 0;

/* Flag indicating that we just want to see the key fingerprint */
int print_fingerprint = 0;
int print_bubblebabble = 0;

/* The identity file name, given on the command line or entered by the user. */
char identity_file[1024];
int have_identity = 0;

/* This is set to the passphrase if given on the command line. */
char *identity_passphrase = NULL;

/* This is set to the new passphrase if given on the command line. */
char *identity_new_passphrase = NULL;

/* This is set to the new comment if given on the command line. */
char *identity_comment = NULL;

/* Dump public key file in format used by real and the original SSH 2 */
int convert_to_ssh2 = 0;
int convert_from_ssh2 = 0;
int print_public = 0;
int print_generic = 0;

/* Dump public key file in format used by the OpenSSL tool */
int convert_to_ossl = 0;
int convert_from_ossl = 0;

const char *key_type_name = NULL;

/* argv0 */
extern char *__progname;

char hostname[MAXHOSTNAMELEN];

/* moduli.c */
int gen_candidates(FILE *, u_int32_t, u_int32_t, BIGNUM *);
int prime_test(FILE *, FILE *, u_int32_t, u_int32_t);

static void
ask_filename(struct passwd *pw, const char *prompt)
{
	char buf[1024];
	const char *name = NULL;

	if (key_type_name == NULL)
		name = _PATH_SSH_CLIENT_ID_RSA;
	else {
		switch (key_type_from_name((char *)key_type_name)) {
		case KEY_RSA1:
			name = _PATH_SSH_CLIENT_IDENTITY;
			break;
		case KEY_DSA:
			name = _PATH_SSH_CLIENT_ID_DSA;
			break;
		case KEY_RSA:
			name = _PATH_SSH_CLIENT_ID_RSA;
			break;
		default:
			fprintf(stderr, "bad key type\n");
			exit(1);
			break;
		}
	}
	snprintf(identity_file, sizeof(identity_file), "%s/%s", pw->pw_dir, name);
	fprintf(stderr, "%s (%s): ", prompt, identity_file);
	if (fgets(buf, sizeof(buf), stdin) == NULL)
		exit(1);
	buf[strcspn(buf, "\n")] = '\0';
	if (strcmp(buf, "") != 0)
		strlcpy(identity_file, buf, sizeof(identity_file));
	have_identity = 1;
}

static Key *
load_identity(char *filename)
{
	char *pass;
	Key *prv;

	prv = key_load_private(filename, "", NULL);
	if (prv == NULL) {
		if (identity_passphrase)
			pass = xstrdup(identity_passphrase);
		else
			pass = read_passphrase("Enter passphrase: ",
			    RP_ALLOW_STDIN);
		prv = key_load_private(filename, pass, NULL);
		memset(pass, 0, strlen(pass));
		xfree(pass);
	}
	return prv;
}

#define SSH_COM_PUBLIC_BEGIN		"---- BEGIN SSH2 PUBLIC KEY ----"
#define SSH_COM_PUBLIC_END		"---- END SSH2 PUBLIC KEY ----"
#define SSH_COM_PRIVATE_BEGIN		"---- BEGIN SSH2 ENCRYPTED PRIVATE KEY ----"
#define	SSH_COM_PRIVATE_KEY_MAGIC	0x3f6ff9eb

static void
do_convert_to_ssh2(struct passwd *pw)
{
	Key *k;
	u_int len;
	u_char *blob;
	struct stat st;

	if (!have_identity)
		ask_filename(pw, "Enter file in which the key is");
	if (stat(identity_file, &st) < 0) {
		perror(identity_file);
		exit(1);
	}
	if ((k = key_load_public(identity_file, NULL)) == NULL) {
		if ((k = load_identity(identity_file)) == NULL) {
			fprintf(stderr, "load failed\n");
			exit(1);
		}
	}
	if (k->type == KEY_RSA1) {
		fprintf(stderr, "version 1 keys are not supported\n");
		exit(1);
	}
	if (key_to_blob(k, &blob, &len) <= 0) {
		fprintf(stderr, "key_to_blob failed\n");
		exit(1);
	}
	fprintf(stdout, "%s\n", SSH_COM_PUBLIC_BEGIN);
	fprintf(stdout,
	    "Comment: \"%u-bit %s, converted from OpenSSH by %s@@%s\"\n",
	    key_size(k), key_type(k),
	    pw->pw_name, hostname);
	dump_base64(stdout, blob, len);
	fprintf(stdout, "%s\n", SSH_COM_PUBLIC_END);
	key_free(k);
	xfree(blob);
	exit(0);
}

static void
do_convert_to_ossl(struct passwd *pw)
{
	Key *k;
	struct stat st;
	int rv;

	if (!have_identity)
		ask_filename(pw, "Enter file in which the key is");
	if (stat(identity_file, &st) < 0) {
		perror(identity_file);
		exit(1);
	}
	if ((k = key_load_public(identity_file, NULL)) == NULL) {
		if ((k = load_identity(identity_file)) == NULL) {
			fprintf(stderr, "load failed\n");
			exit(1);
		}
	}
	if (k->type == KEY_RSA1) {
		fprintf(stderr, "version 1 keys are not supported\n");
		exit(1);
	}
	if ((rv = !PEM_write_RSA_PUBKEY(stdout, k->rsa)))
		fprintf(stderr, "error during key conversion\n");
	key_free(k);
	exit(rv);
}

static void
buffer_get_bignum_bits(Buffer *b, BIGNUM *value)
{
	u_int bignum_bits = buffer_get_int(b);
	u_int bytes = (bignum_bits + 7) / 8;

	if (buffer_len(b) < bytes)
		fatal("buffer_get_bignum_bits: input buffer too small: "
		    "need %d have %d", bytes, buffer_len(b));
	if (BN_bin2bn(buffer_ptr(b), bytes, value) == NULL)
		fatal("buffer_get_bignum_bits: BN_bin2bn failed");
	buffer_consume(b, bytes);
}

static Key *
do_convert_private_ssh2_from_blob(u_char *blob, u_int blen)
{
	Buffer b;
	Key *key = NULL;
	char *type, *cipher;
	u_char *sig, data[] = "abcde12345";
	int magic, rlen, ktype, i1, i2, i3, i4;
	u_int slen;
	u_long e;

	buffer_init(&b);
	buffer_append(&b, blob, blen);

	magic = buffer_get_int(&b);
	if (magic != SSH_COM_PRIVATE_KEY_MAGIC) {
		error("bad magic 0x%x != 0x%x", magic, SSH_COM_PRIVATE_KEY_MAGIC);
		buffer_free(&b);
		return NULL;
	}
	i1 = buffer_get_int(&b);
	type   = buffer_get_string(&b, NULL);
	cipher = buffer_get_string(&b, NULL);
	i2 = buffer_get_int(&b);
	i3 = buffer_get_int(&b);
	i4 = buffer_get_int(&b);
	debug("ignore (%d %d %d %d)", i1, i2, i3, i4);
	if (strcmp(cipher, "none") != 0) {
		error("unsupported cipher %s", cipher);
		xfree(cipher);
		buffer_free(&b);
		xfree(type);
		return NULL;
	}
	xfree(cipher);

	if (strstr(type, "dsa")) {
		ktype = KEY_DSA;
	} else if (strstr(type, "rsa")) {
		ktype = KEY_RSA;
	} else {
		buffer_free(&b);
		xfree(type);
		return NULL;
	}
	key = key_new_private(ktype);
	xfree(type);

	switch (key->type) {
	case KEY_DSA:
		buffer_get_bignum_bits(&b, key->dsa->p);
		buffer_get_bignum_bits(&b, key->dsa->g);
		buffer_get_bignum_bits(&b, key->dsa->q);
		buffer_get_bignum_bits(&b, key->dsa->pub_key);
		buffer_get_bignum_bits(&b, key->dsa->priv_key);
		break;
	case KEY_RSA:
		e = buffer_get_char(&b);
		debug("e %lx", e);
		if (e < 30) {
			e <<= 8;
			e += buffer_get_char(&b);
			debug("e %lx", e);
			e <<= 8;
			e += buffer_get_char(&b);
			debug("e %lx", e);
		}
		if (!BN_set_word(key->rsa->e, e)) {
			buffer_free(&b);
			key_free(key);
			return NULL;
		}
		buffer_get_bignum_bits(&b, key->rsa->d);
		buffer_get_bignum_bits(&b, key->rsa->n);
		buffer_get_bignum_bits(&b, key->rsa->iqmp);
		buffer_get_bignum_bits(&b, key->rsa->q);
		buffer_get_bignum_bits(&b, key->rsa->p);
		rsa_generate_additional_parameters(key->rsa);
		break;
	}
	rlen = buffer_len(&b);
	if (rlen != 0)
		error("do_convert_private_ssh2_from_blob: "
		    "remaining bytes in key blob %d", rlen);
	buffer_free(&b);

	/* try the key */
	key_sign(key, &sig, &slen, data, sizeof(data));
	key_verify(key, sig, slen, data, sizeof(data));
	xfree(sig);
	return key;
}

static int
get_line(FILE *fp, char *line, size_t len)
{
	int c;
	size_t pos = 0;

	line[0] = '\0';
	while ((c = fgetc(fp)) != EOF) {
		if (pos >= len - 1) {
			fprintf(stderr, "input line too long.\n");
			exit(1);
		}
		switch (c) {
		case '\r':
			c = fgetc(fp);
			if (c != EOF && c != '\n' && ungetc(c, fp) == EOF) {
				fprintf(stderr, "unget: %s\n", strerror(errno));
				exit(1);
			}
			return pos;
		case '\n':
			return pos;
		}
		line[pos++] = c;
		line[pos] = '\0';
	}
	/* We reached EOF */
	return -1;
}

static void
do_convert_from_ssh2(struct passwd *pw)
{
	Key *k;
	int blen;
	u_int len;
	char line[1024];
	u_char blob[8096];
	char encoded[8096];
	struct stat st;
	int escaped = 0, private = 0, ok;
	FILE *fp;

	if (!have_identity)
		ask_filename(pw, "Enter file in which the key is");
	if (stat(identity_file, &st) < 0) {
		perror(identity_file);
		exit(1);
	}
	fp = fopen(identity_file, "r");
	if (fp == NULL) {
		perror(identity_file);
		exit(1);
	}
	encoded[0] = '\0';
	while ((blen = get_line(fp, line, sizeof(line))) != -1) {
		if (line[blen - 1] == '\\')
			escaped++;
		if (strncmp(line, "----", 4) == 0 ||
		    strstr(line, ": ") != NULL) {
			if (strstr(line, SSH_COM_PRIVATE_BEGIN) != NULL)
				private = 1;
			if (strstr(line, " END ") != NULL) {
				break;
			}
			/* fprintf(stderr, "ignore: %s", line); */
			continue;
		}
		if (escaped) {
			escaped--;
			/* fprintf(stderr, "escaped: %s", line); */
			continue;
		}
		strlcat(encoded, line, sizeof(encoded));
	}
	len = strlen(encoded);
	if (((len % 4) == 3) &&
	    (encoded[len-1] == '=') &&
	    (encoded[len-2] == '=') &&
	    (encoded[len-3] == '='))
		encoded[len-3] = '\0';
	blen = uudecode(encoded, blob, sizeof(blob));
	if (blen < 0) {
		fprintf(stderr, "uudecode failed.\n");
		exit(1);
	}
	k = private ?
	    do_convert_private_ssh2_from_blob(blob, blen) :
	    key_from_blob(blob, blen);
	if (k == NULL) {
		fprintf(stderr, "decode blob failed.\n");
		exit(1);
	}
	ok = private ?
	    (k->type == KEY_DSA ?
		 PEM_write_DSAPrivateKey(stdout, k->dsa, NULL, NULL, 0, NULL, NULL) :
		 PEM_write_RSAPrivateKey(stdout, k->rsa, NULL, NULL, 0, NULL, NULL)) :
	    key_write(k, stdout);
	if (!ok) {
		fprintf(stderr, "key write failed\n");
		exit(1);
	}
	key_free(k);
	if (!private)
		fprintf(stdout, "\n");
	fclose(fp);
	exit(0);
}

static __dead void
do_convert_from_ossl(struct passwd *pw)
{
	Key *k;
	struct stat st;
	FILE *fp;
	X509 *x;

	if (!have_identity)
		ask_filename(pw, "Enter file in which the key is");
	if (stat(identity_file, &st) < 0) {
		perror(identity_file);
		exit(1);
	}
	fp = fopen(identity_file, "r");
	if (fp == NULL) {
		perror(identity_file);
		exit(1);
	}
	k = key_new_private(KEY_RSA);
	if (k != NULL) {
		RSA_free(k->rsa);
		k->rsa = NULL;
		x = PEM_read_X509(fp, NULL, NULL, NULL);
		if (x != NULL) {
			EVP_PKEY *pkey;
			if ((pkey = X509_get_pubkey(x)) != NULL)
				k->rsa = pkey->pkey.rsa;
		}
		if (k->rsa == NULL) {
			rewind(fp);
			k->rsa = PEM_read_RSA_PUBKEY(fp, NULL, NULL, NULL);
		}
	}
	if (k == NULL || k->rsa == NULL) {
		unsigned long e;
		ERR_load_crypto_strings();
		while ((e = ERR_get_error()))
			fprintf(stderr, "%s\n", ERR_error_string(e, NULL));
		fprintf(stderr, "decode blob failed.\n");
		exit(1);
	}
	if (!key_write(k, stdout)) {
		fprintf(stderr, "key write failed");
		exit(1);
	}
	key_free(k);
	fprintf(stdout, "\n");
	fclose(fp);
	exit(0);
}

static void
do_print_public(struct passwd *pw)
{
	Key *prv;
	struct stat st;

	if (!have_identity)
		ask_filename(pw, "Enter file in which the key is");
	if (stat(identity_file, &st) < 0) {
		perror(identity_file);
		exit(1);
	}
	prv = load_identity(identity_file);
	if (prv == NULL) {
		fprintf(stderr, "load failed\n");
		exit(1);
	}
	if (!key_write(prv, stdout))
		fprintf(stderr, "key_write failed");
	key_free(prv);
	fprintf(stdout, "\n");
	exit(0);
}

#ifdef SMARTCARD
static void
do_upload(struct passwd *pw, const char *sc_reader_id)
{
	Key *prv = NULL;
	struct stat st;
	int ret;

	if (!have_identity)
		ask_filename(pw, "Enter file in which the key is");
	if (stat(identity_file, &st) < 0) {
		perror(identity_file);
		exit(1);
	}
	prv = load_identity(identity_file);
	if (prv == NULL) {
		error("load failed");
		exit(1);
	}
	ret = sc_put_key(prv, sc_reader_id);
	key_free(prv);
	if (ret < 0)
		exit(1);
	logit("loading key done");
	exit(0);
}

static void
do_download(struct passwd *pw, const char *sc_reader_id)
{
	Key **keys = NULL;
	int i;

	keys = sc_get_keys(sc_reader_id, NULL);
	if (keys == NULL)
		fatal("cannot read public key from smartcard");
	for (i = 0; keys[i]; i++) {
		key_write(keys[i], stdout);
		key_free(keys[i]);
		fprintf(stdout, "\n");
	}
	xfree(keys);
	exit(0);
}
#endif /* SMARTCARD */

static __dead void
do_fingerprint(struct passwd *pw)
{
	FILE *f;
	Key *public;
	char *comment = NULL, *cp, *ep, line[16*1024], *fp, *ra;
	int i, skip = 0, num = 0, invalid = 1;
	enum fp_rep rep;
	enum fp_type fptype;
	struct stat st;

	fptype = print_bubblebabble ? SSH_FP_SHA1 : SSH_FP_MD5;
	rep =    print_bubblebabble ? SSH_FP_BUBBLEBABBLE : SSH_FP_HEX;

	if (!have_identity)
		ask_filename(pw, "Enter file in which the key is");
	if (stat(identity_file, &st) < 0) {
		perror(identity_file);
		exit(1);
	}
	public = key_load_public(identity_file, &comment);
	if (public != NULL) {
		fp = key_fingerprint(public, fptype, rep);
		ra = key_fingerprint(public, SSH_FP_MD5, SSH_FP_RANDOMART);
		printf("%u %s %s (%s)\n", key_size(public), fp, comment,
		    key_type(public));
		if (log_level >= SYSLOG_LEVEL_VERBOSE)
			printf("%s\n", ra);
		key_free(public);
		xfree(comment);
		xfree(ra);
		xfree(fp);
		exit(0);
	}
	if (comment) {
		xfree(comment);
		comment = NULL;
	}

	f = fopen(identity_file, "r");
	if (f != NULL) {
		while (fgets(line, sizeof(line), f)) {
			if ((cp = strchr(line, '\n')) == NULL) {
				error("line %d too long: %.40s...",
				    num + 1, line);
				skip = 1;
				continue;
			}
			num++;
			if (skip) {
				skip = 0;
				continue;
			}
			*cp = '\0';

			/* Skip leading whitespace, empty and comment lines. */
			for (cp = line; *cp == ' ' || *cp == '\t'; cp++)
				;
			if (!*cp || *cp == '\n' || *cp == '#')
				continue;
			i = strtol(cp, &ep, 10);
			if (i == 0 || ep == NULL || (*ep != ' ' && *ep != '\t')) {
				int quoted = 0;
				comment = cp;
				for (; *cp && (quoted || (*cp != ' ' &&
				    *cp != '\t')); cp++) {
					if (*cp == '\\' && cp[1] == '"')
						cp++;	/* Skip both */
					else if (*cp == '"')
						quoted = !quoted;
				}
				if (!*cp)
					continue;
				*cp++ = '\0';
			}
			ep = cp;
			public = key_new(KEY_RSA1);
			if (key_read(public, &cp) != 1) {
				cp = ep;
				key_free(public);
				public = key_new(KEY_UNSPEC);
				if (key_read(public, &cp) != 1) {
					key_free(public);
					continue;
				}
			}
			comment = *cp ? cp : comment;
			fp = key_fingerprint(public, fptype, rep);
			ra = key_fingerprint(public, SSH_FP_MD5, SSH_FP_RANDOMART);
			printf("%u %s %s (%s)\n", key_size(public), fp,
			    comment ? comment : "no comment", key_type(public));
			if (log_level >= SYSLOG_LEVEL_VERBOSE)
				printf("%s\n", ra);
			xfree(ra);
			xfree(fp);
			key_free(public);
			invalid = 0;
		}
		fclose(f);
	}
	if (invalid) {
		printf("%s is not a public key file.\n", identity_file);
		exit(1);
	}
	exit(0);
}

static void
print_host(FILE *f, const char *name, Key *public, int hash)
{
	if (print_fingerprint) {
		enum fp_rep rep;
		enum fp_type fptype;
		char *fp, *ra;

		fptype = print_bubblebabble ? SSH_FP_SHA1 : SSH_FP_MD5;
		rep =    print_bubblebabble ? SSH_FP_BUBBLEBABBLE : SSH_FP_HEX;
		fp = key_fingerprint(public, fptype, rep);
		ra = key_fingerprint(public, SSH_FP_MD5, SSH_FP_RANDOMART);
		printf("%u %s %s (%s)\n", key_size(public), fp, name,
		    key_type(public));
		if (log_level >= SYSLOG_LEVEL_VERBOSE)
			printf("%s\n", ra);
		xfree(ra);
		xfree(fp);
	} else {
		if (hash && (name = host_hash(name, NULL, 0)) == NULL)
			fatal("hash_host failed");
		fprintf(f, "%s ", name);
		if (!key_write(public, f))
			fatal("key_write failed");
		fprintf(f, "\n");
	}
}

static __dead void
do_known_hosts(struct passwd *pw, const char *name)
{
	FILE *in, *out = stdout;
	Key *public;
	char *cp, *cp2, *kp, *kp2;
	char line[16*1024], tmp[MAXPATHLEN], old[MAXPATHLEN];
	int c, skip = 0, inplace = 0, num = 0, invalid = 0, has_unhashed = 0;

	if (!have_identity) {
		cp = tilde_expand_filename(
#ifdef _PATH_SSH_ROOT_HOSTFILE
		    (!pw->pw_dir || !pw->pw_dir[0] || (pw->pw_dir[0] == '/' &&
		    !pw->pw_dir[1])) ? _PATH_SSH_ROOT_HOSTFILE :
#endif
		    _PATH_SSH_USER_HOSTFILE, pw->pw_uid);
		if (strlcpy(identity_file, cp, sizeof(identity_file)) >=
		    sizeof(identity_file))
			fatal("Specified known hosts path too long");
		xfree(cp);
		have_identity = 1;
	}
	if ((in = fopen(identity_file, "r")) == NULL)
		fatal("fopen: %s", strerror(errno));

	/*
	 * Find hosts goes to stdout, hash and deletions happen in-place
	 * A corner case is ssh-keygen -HF foo, which should go to stdout
	 */
	if (!find_host && (hash_hosts || delete_host)) {
		if (strlcpy(tmp, identity_file, sizeof(tmp)) >= sizeof(tmp) ||
		    strlcat(tmp, ".XXXXXXXXXX", sizeof(tmp)) >= sizeof(tmp) ||
		    strlcpy(old, identity_file, sizeof(old)) >= sizeof(old) ||
		    strlcat(old, ".old", sizeof(old)) >= sizeof(old))
			fatal("known_hosts path too long");
		umask(077);
		if ((c = mkstemp(tmp)) == -1)
			fatal("mkstemp: %s", strerror(errno));
		if ((out = fdopen(c, "w")) == NULL) {
			c = errno;
			unlink(tmp);
			fatal("fdopen: %s", strerror(c));
		}
		inplace = 1;
	}

	while (fgets(line, sizeof(line), in)) {
		if ((cp = strchr(line, '\n')) == NULL) {
			error("line %d too long: %.40s...", num + 1, line);
			skip = 1;
			invalid = 1;
			continue;
		}
		num++;
		if (skip) {
			skip = 0;
			continue;
		}
		*cp = '\0';

		/* Skip leading whitespace, empty and comment lines. */
		for (cp = line; *cp == ' ' || *cp == '\t'; cp++)
			;
		if (!*cp || *cp == '\n' || *cp == '#') {
			if (inplace)
				fprintf(out, "%s\n", cp);
			continue;
		}
		/* Find the end of the host name portion. */
		for (kp = cp; *kp && *kp != ' ' && *kp != '\t'; kp++)
			;
		if (*kp == '\0' || *(kp + 1) == '\0') {
			error("line %d missing key: %.40s...",
			    num, line);
			invalid = 1;
			continue;
		}
		*kp++ = '\0';
		kp2 = kp;

		public = key_new(KEY_RSA1);
		if (key_read(public, &kp) != 1) {
			kp = kp2;
			key_free(public);
			public = key_new(KEY_UNSPEC);
			if (key_read(public, &kp) != 1) {
				error("line %d invalid key: %.40s...",
				    num, line);
				key_free(public);
				invalid = 1;
				continue;
			}
		}

		if (*cp == HASH_DELIM) {
			if (find_host || delete_host) {
				cp2 = host_hash(name, cp, strlen(cp));
				if (cp2 == NULL) {
					error("line %d: invalid hashed "
					    "name: %.64s...", num, line);
					invalid = 1;
					continue;
				}
				c = (strcmp(cp2, cp) == 0);
				if (find_host && c) {
					printf("# Host %s found: "
					    "line %d type %s\n", name,
					    num, key_type(public));
					print_host(out, cp, public, 0);
				}
				if (delete_host && !c)
					print_host(out, cp, public, 0);
			} else if (hash_hosts)
				print_host(out, cp, public, 0);
		} else {
			if (find_host || delete_host) {
				c = (match_hostname(name, cp,
				    strlen(cp)) == 1);
				if (find_host && c) {
					printf("# Host %s found: "
					    "line %d type %s\n", name,
					    num, key_type(public));
					print_host(out, name, public,
					    hash_hosts);
				}
				if (delete_host && !c)
					print_host(out, cp, public, 0);
			} else if (hash_hosts) {
				for (cp2 = strsep(&cp, ",");
				    cp2 != NULL && *cp2 != '\0';
				    cp2 = strsep(&cp, ",")) {
					if (strcspn(cp2, "*?!") != strlen(cp2))
						fprintf(stderr, "Warning: "
						    "ignoring host name with "
						    "metacharacters: %.64s\n",
						    cp2);
					else
						print_host(out, cp2, public, 1);
				}
				has_unhashed = 1;
			}
		}
		key_free(public);
	}
	fclose(in);

	if (invalid) {
		fprintf(stderr, "%s is not a valid known_hosts file.\n",
		    identity_file);
		if (inplace) {
			fprintf(stderr, "Not replacing existing known_hosts "
			    "file because of errors\n");
			fclose(out);
			unlink(tmp);
		}
		exit(1);
	}

	if (inplace) {
		fclose(out);

		/* Backup existing file */
		if (unlink(old) == -1 && errno != ENOENT)
			fatal("unlink %.100s: %s", old, strerror(errno));
		if (link(identity_file, old) == -1)
			fatal("link %.100s to %.100s: %s", identity_file, old,
			    strerror(errno));
		/* Move new one into place */
		if (rename(tmp, identity_file) == -1) {
			error("rename\"%s\" to \"%s\": %s", tmp, identity_file,
			    strerror(errno));
			unlink(tmp);
			unlink(old);
			exit(1);
		}

		fprintf(stderr, "%s updated.\n", identity_file);
		fprintf(stderr, "Original contents retained as %s\n", old);
		if (has_unhashed) {
			fprintf(stderr, "WARNING: %s contains unhashed "
			    "entries\n", old);
			fprintf(stderr, "Delete this file to ensure privacy "
			    "of hostnames\n");
		}
	}

	exit(0);
}

/*
 * Perform changing a passphrase.  The argument is the passwd structure
 * for the current user.
 */
static __dead void
do_change_passphrase(struct passwd *pw)
{
	char *comment;
	char *old_passphrase, *passphrase1, *passphrase2;
	struct stat st;
	Key *private;

	if (!have_identity)
		ask_filename(pw, "Enter file in which the key is");
	if (stat(identity_file, &st) < 0) {
		perror(identity_file);
		exit(1);
	}
	/* Try to load the file with empty passphrase. */
	private = key_load_private(identity_file, "", &comment);
	if (private == NULL) {
		if (identity_passphrase)
			old_passphrase = xstrdup(identity_passphrase);
		else
			old_passphrase =
			    read_passphrase("Enter old passphrase: ",
			    RP_ALLOW_STDIN);
		private = key_load_private(identity_file, old_passphrase,
		    &comment);
		memset(old_passphrase, 0, strlen(old_passphrase));
		xfree(old_passphrase);
		if (private == NULL) {
			printf("Bad passphrase.\n");
			exit(1);
		}
	}
	printf("Key has comment '%s'\n", comment);

	/* Ask the new passphrase (twice). */
	if (identity_new_passphrase) {
		passphrase1 = xstrdup(identity_new_passphrase);
		passphrase2 = NULL;
	} else {
		passphrase1 =
			read_passphrase("Enter new passphrase (empty for no "
			    "passphrase): ", RP_ALLOW_STDIN);
		passphrase2 = read_passphrase("Enter same passphrase again: ",
		    RP_ALLOW_STDIN);

		/* Verify that they are the same. */
		if (strcmp(passphrase1, passphrase2) != 0) {
			memset(passphrase1, 0, strlen(passphrase1));
			memset(passphrase2, 0, strlen(passphrase2));
			xfree(passphrase1);
			xfree(passphrase2);
			printf("Pass phrases do not match.  Try again.\n");
			exit(1);
		}
		/* Destroy the other copy. */
		memset(passphrase2, 0, strlen(passphrase2));
		xfree(passphrase2);
	}

	/* Save the file using the new passphrase. */
	if (!key_save_private(private, identity_file, passphrase1, comment)) {
		printf("Saving the key failed: %s.\n", identity_file);
		memset(passphrase1, 0, strlen(passphrase1));
		xfree(passphrase1);
		key_free(private);
		xfree(comment);
		exit(1);
	}
	/* Destroy the passphrase and the copy of the key in memory. */
	memset(passphrase1, 0, strlen(passphrase1));
	xfree(passphrase1);
	key_free(private);		 /* Destroys contents */
	xfree(comment);

	printf("Your identification has been saved with the new passphrase.\n");
	exit(0);
}

/*
 * Print the SSHFP RR.
 */
static int
do_print_resource_record(struct passwd *pw, const char *fname,
    const char *hname)
{
	Key *public;
	char *comment = NULL;
	struct stat st;

	if (fname == NULL)
		ask_filename(pw, "Enter file in which the key is");
	if (stat(fname, &st) < 0) {
		if (errno == ENOENT)
			return 0;
		perror(fname);
		exit(1);
	}
	public = key_load_public(fname, &comment);
	if (public != NULL) {
		export_dns_rr(hname, public, stdout, print_generic);
		key_free(public);
		xfree(comment);
		return 1;
	}
	if (comment)
		xfree(comment);

	printf("failed to read v2 public key from %s.\n", fname);
	exit(1);
}

/*
 * Change the comment of a private key file.
 */
static __dead void
do_change_comment(struct passwd *pw)
{
	char new_comment[1024], *comment, *passphrase;
	Key *private;
	Key *public;
	struct stat st;
	FILE *f;
	int fd;

	if (!have_identity)
		ask_filename(pw, "Enter file in which the key is");
	if (stat(identity_file, &st) < 0) {
		perror(identity_file);
		exit(1);
	}
	private = key_load_private(identity_file, "", &comment);
	if (private == NULL) {
		if (identity_passphrase)
			passphrase = xstrdup(identity_passphrase);
		else if (identity_new_passphrase)
			passphrase = xstrdup(identity_new_passphrase);
		else
			passphrase = read_passphrase("Enter passphrase: ",
			    RP_ALLOW_STDIN);
		/* Try to load using the passphrase. */
		private = key_load_private(identity_file, passphrase, &comment);
		if (private == NULL) {
			memset(passphrase, 0, strlen(passphrase));
			xfree(passphrase);
			printf("Bad passphrase.\n");
			exit(1);
		}
	} else {
		passphrase = xstrdup("");
	}
	if (private->type != KEY_RSA1) {
		fprintf(stderr, "Comments are only supported for RSA1 keys.\n");
		key_free(private);
		exit(1);
	}
	printf("Key now has comment '%s'\n", comment);

	if (identity_comment) {
		strlcpy(new_comment, identity_comment, sizeof(new_comment));
	} else {
		printf("Enter new comment: ");
		fflush(stdout);
		if (!fgets(new_comment, sizeof(new_comment), stdin)) {
			memset(passphrase, 0, strlen(passphrase));
			key_free(private);
			exit(1);
		}
		new_comment[strcspn(new_comment, "\n")] = '\0';
	}

	/* Save the file using the new passphrase. */
	if (!key_save_private(private, identity_file, passphrase, new_comment)) {
		printf("Saving the key failed: %s.\n", identity_file);
		memset(passphrase, 0, strlen(passphrase));
		xfree(passphrase);
		key_free(private);
		xfree(comment);
		exit(1);
	}
	memset(passphrase, 0, strlen(passphrase));
	xfree(passphrase);
	public = key_from_private(private);
	key_free(private);

	strlcat(identity_file, ".pub", sizeof(identity_file));
	fd = open(identity_file, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	if (fd == -1) {
		printf("Could not save your public key in %s\n", identity_file);
		exit(1);
	}
	f = fdopen(fd, "w");
	if (f == NULL) {
		printf("fdopen %s failed\n", identity_file);
		exit(1);
	}
	if (!key_write(public, f))
		fprintf(stderr, "write key failed\n");
	key_free(public);
	fprintf(f, " %s\n", new_comment);
	fclose(f);

	xfree(comment);

	printf("The comment in your key file has been changed.\n");
	exit(0);
}

static __dead void
usage(void)
{
	fprintf(stderr, "usage: %s [options]\n", __progname);
	fprintf(stderr, "Options:\n");
	fprintf(stderr, "  -a trials   Number of trials for screening DH-GEX moduli.\n");
	fprintf(stderr, "  -B          Show bubblebabble digest of key file.\n");
	fprintf(stderr, "  -b bits     Number of bits in the key to create.\n");
	fprintf(stderr, "  -C comment  Provide new comment.\n");
	fprintf(stderr, "  -c          Change comment in private and public key files.\n");
#ifdef SMARTCARD
	fprintf(stderr, "  -D reader   Download public key from smartcard.\n");
#endif /* SMARTCARD */
	fprintf(stderr, "  -E          Convert OpenSSH to OpenSSL public key file.\n");
	fprintf(stderr, "  -e          Convert OpenSSH to RFC 4716 key file.\n");
	fprintf(stderr, "  -F hostname Find hostname in known hosts file.\n");
	fprintf(stderr, "  -f filename Filename of the key file.\n");
	fprintf(stderr, "  -G file     Generate candidates for DH-GEX moduli.\n");
	fprintf(stderr, "  -g          Use generic DNS resource record format.\n");
	fprintf(stderr, "  -H          Hash names in known_hosts file.\n");
	fprintf(stderr, "  -I          Convert OpenSSL to OpenSSH public key file.\n");
	fprintf(stderr, "  -i          Convert RFC 4716 to OpenSSH key file.\n");
	fprintf(stderr, "  -l          Show fingerprint of key file.\n");
	fprintf(stderr, "  -M memory   Amount of memory (MB) to use for generating DH-GEX moduli.\n");
	fprintf(stderr, "  -N phrase   Provide new passphrase.\n");
	fprintf(stderr, "  -P phrase   Provide old passphrase.\n");
	fprintf(stderr, "  -p          Change passphrase of private key file.\n");
	fprintf(stderr, "  -q          Quiet.\n");
	fprintf(stderr, "  -R hostname Remove host from known_hosts file.\n");
	fprintf(stderr, "  -r hostname Print DNS resource record.\n");
	fprintf(stderr, "  -S start    Start point (hex) for generating DH-GEX moduli.\n");
	fprintf(stderr, "  -T file     Screen candidates for DH-GEX moduli.\n");
	fprintf(stderr, "  -t type     Specify type of key to create.\n");
#ifdef SMARTCARD
	fprintf(stderr, "  -U reader   Upload private key to smartcard.\n");
#endif /* SMARTCARD */
	fprintf(stderr, "  -v          Verbose.\n");
	fprintf(stderr, "  -W gen      Generator to use for generating DH-GEX moduli.\n");
	fprintf(stderr, "  -y          Read private key file and print public key.\n");

	exit(1);
}

/*
 * Main program for key management.
 */
int
main(int argc, char **argv)
{
	char dotsshdir[MAXPATHLEN], comment[1024], *passphrase1, *passphrase2;
	char out_file[MAXPATHLEN], *reader_id = NULL;
	char *rr_hostname = NULL;
	Key *private, *public;
	struct passwd *pw;
	struct stat st;
	int opt, type, fd, download = 0;
	u_int32_t memory = 0, generator_wanted = 0, trials = 100;
	int do_gen_candidates = 0, do_screen_candidates = 0;
	BIGNUM *start = NULL;
	FILE *f;
	const char *errstr;

	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

	SSLeay_add_all_algorithms();
	log_init(argv[0], SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_USER, 1);

	/* we need this for the home * directory.  */
	pw = getpwuid(getuid());
	if (!pw) {
		printf("You don't exist, go away!\n");
		exit(1);
	}
	if (gethostname(hostname, sizeof(hostname)) < 0) {
		perror("gethostname");
		exit(1);
	}

	while ((opt = getopt(argc, argv,
	    "a:Bb:cC:dD:EeF:f:G:gHIilM:N:pP:qR:r:S:T:t:U:vW:Xxy")) != -1) {
		switch (opt) {
		case 'b':
			bits = (u_int32_t)strtonum(optarg, 768, 32768, &errstr);
			if (errstr)
				fatal("Bits has bad value %s (%s)",
					optarg, errstr);
			break;
		case 'F':
			find_host = 1;
			rr_hostname = optarg;
			break;
		case 'H':
			hash_hosts = 1;
			break;
		case 'R':
			delete_host = 1;
			rr_hostname = optarg;
			break;
		case 'l':
			print_fingerprint = 1;
			break;
		case 'B':
			print_bubblebabble = 1;
			break;
		case 'p':
			change_passphrase = 1;
			break;
		case 'c':
			change_comment = 1;
			break;
		case 'f':
			if (strlcpy(identity_file, optarg, sizeof(identity_file)) >=
			    sizeof(identity_file))
				fatal("Identity filename too long");
			have_identity = 1;
			break;
		case 'g':
			print_generic = 1;
			break;
		case 'P':
			identity_passphrase = optarg;
			break;
		case 'N':
			identity_new_passphrase = optarg;
			break;
		case 'C':
			identity_comment = optarg;
			break;
		case 'q':
			quiet = 1;
			break;
		case 'e':
		case 'x':
			/* export key */
			convert_to_ssh2 = 1;
			break;
		case 'i':
		case 'X':
			/* import key */
			convert_from_ssh2 = 1;
			break;
		case 'E':
			convert_to_ossl = 1;
			break;
		case 'I':
			convert_from_ossl = 1;
			break;
		case 'y':
			print_public = 1;
			break;
		case 'd':
			key_type_name = "dsa";
			break;
		case 't':
			key_type_name = optarg;
			break;
		case 'D':
			download = 1;
			/*FALLTHROUGH*/
		case 'U':
			reader_id = optarg;
			break;
		case 'v':
			if (log_level == SYSLOG_LEVEL_INFO)
				log_level = SYSLOG_LEVEL_DEBUG1;
			else {
				if (log_level >= SYSLOG_LEVEL_DEBUG1 &&
				    log_level < SYSLOG_LEVEL_DEBUG3)
					log_level++;
			}
			break;
		case 'r':
			rr_hostname = optarg;
			break;
		case 'W':
			generator_wanted = (u_int32_t)strtonum(optarg, 1,
			    UINT_MAX, &errstr);
			if (errstr)
				fatal("Desired generator has bad value: %s (%s)",
					optarg, errstr);
			break;
		case 'a':
			trials = (u_int32_t)strtonum(optarg, 1, UINT_MAX, &errstr);
			if (errstr)
				fatal("Invalid number of trials: %s (%s)",
					optarg, errstr);
			break;
		case 'M':
			memory = (u_int32_t)strtonum(optarg, 1, UINT_MAX, &errstr);
			if (errstr) {
				fatal("Memory limit is %s: %s", errstr, optarg);
			}
			break;
		case 'G':
			do_gen_candidates = 1;
			if (strlcpy(out_file, optarg, sizeof(out_file)) >=
			    sizeof(out_file))
				fatal("Output filename too long");
			break;
		case 'T':
			do_screen_candidates = 1;
			if (strlcpy(out_file, optarg, sizeof(out_file)) >=
			    sizeof(out_file))
				fatal("Output filename too long");
			break;
		case 'S':
			/* XXX - also compare length against bits */
			if (BN_hex2bn(&start, optarg) == 0)
				fatal("Invalid start point.");
			break;
		case '?':
		default:
			usage();
		}
	}

	/* reinit */
	log_init(argv[0], log_level, SYSLOG_FACILITY_USER, 1);

	if (optind < argc) {
		printf("Too many arguments.\n");
		usage();
	}
	if (change_passphrase && change_comment) {
		printf("Can only have one of -p and -c.\n");
		usage();
	}
	if (print_fingerprint && (delete_host || hash_hosts)) {
		printf("Cannot use -l with -D or -R.\n");
		usage();
	}
	if (delete_host || hash_hosts || find_host)
		do_known_hosts(pw, rr_hostname);
	if (print_fingerprint || print_bubblebabble)
		do_fingerprint(pw);
	if (change_passphrase)
		do_change_passphrase(pw);
	if (change_comment)
		do_change_comment(pw);
	if (convert_to_ssh2)
		do_convert_to_ssh2(pw);
	if (convert_from_ssh2)
		do_convert_from_ssh2(pw);
	if (convert_to_ossl)
		do_convert_to_ossl(pw);
	if (convert_from_ossl)
		do_convert_from_ossl(pw);
	if (print_public)
		do_print_public(pw);
	if (rr_hostname != NULL) {
		unsigned int n = 0;

		if (have_identity) {
			n = do_print_resource_record(pw,
			    identity_file, rr_hostname);
			if (n == 0) {
				perror(identity_file);
				exit(1);
			}
			exit(0);
		} else {

			n += do_print_resource_record(pw,
			    _PATH_HOST_RSA_KEY_FILE, rr_hostname);
			n += do_print_resource_record(pw,
			    _PATH_HOST_DSA_KEY_FILE, rr_hostname);

			if (n == 0)
				fatal("no keys found.");
			exit(0);
		}
	}
	if (reader_id != NULL) {
#ifdef SMARTCARD
		if (download)
			do_download(pw, reader_id);
		else
			do_upload(pw, reader_id);
#else /* SMARTCARD */
		fatal("no support for smartcards.");
#endif /* SMARTCARD */
	}

	if (do_gen_candidates) {
		FILE *out = fopen(out_file, "w");

		if (out == NULL) {
			error("Couldn't open modulus candidate file \"%s\": %s",
			    out_file, strerror(errno));
			return (1);
		}
		if (bits == 0)
			bits = DEFAULT_BITS;
		if (gen_candidates(out, memory, bits, start) != 0)
			fatal("modulus candidate generation failed");

		return (0);
	}

	if (do_screen_candidates) {
		FILE *in;
		FILE *out = fopen(out_file, "w");

		if (have_identity && strcmp(identity_file, "-") != 0) {
			if ((in = fopen(identity_file, "r")) == NULL) {
				fatal("Couldn't open modulus candidate "
				    "file \"%s\": %s", identity_file,
				    strerror(errno));
			}
		} else
			in = stdin;

		if (out == NULL) {
			fatal("Couldn't open moduli file \"%s\": %s",
			    out_file, strerror(errno));
		}
		if (prime_test(in, out, trials, generator_wanted) != 0)
			fatal("modulus screening failed");
		return (0);
	}

	(void)arc4random();

	if (key_type_name == NULL)
		key_type_name = "rsa";

	type = key_type_from_name((char *)key_type_name);
	if (type == KEY_UNSPEC) {
		fprintf(stderr, "unknown key type %s\n", key_type_name);
		exit(1);
	}
	if (bits == 0)
		bits = (type == KEY_DSA) ? DEFAULT_BITS_DSA : DEFAULT_BITS;
	if (type == KEY_DSA && bits != 1024)
		fatal("DSA keys must be 1024 bits");
	if (!quiet)
		printf("Generating public/private %s key pair.\n", key_type_name);
	private = key_generate(type, bits);
	if (private == NULL) {
		fprintf(stderr, "key_generate failed\n");
		exit(1);
	}
	public  = key_from_private(private);

	if (!have_identity)
		ask_filename(pw, "Enter file in which to save the key");

	/* Create ~/.etc/ssh directory if it doesn't already exist. */
	snprintf(dotsshdir, sizeof dotsshdir, "%s/%s", pw->pw_dir, _PATH_SSH_USER_DIR);
	if (strstr(identity_file, dotsshdir) != NULL &&
	    stat(dotsshdir, &st) < 0) {
		if (mkdir(dotsshdir, 0700) < 0)
			error("Could not create directory '%s'.", dotsshdir);
		else if (!quiet)
			printf("Created directory '%s'.\n", dotsshdir);
	}
	/* If the file already exists, ask the user to confirm. */
	if (stat(identity_file, &st) >= 0) {
		char yesno[3];
		printf("%s already exists.\n", identity_file);
		printf("Overwrite (y/n)? ");
		fflush(stdout);
		if (fgets(yesno, sizeof(yesno), stdin) == NULL)
			exit(1);
		if (yesno[0] != 'y' && yesno[0] != 'Y')
			exit(1);
	}
	/* Ask for a passphrase (twice). */
	if (identity_passphrase)
		passphrase1 = xstrdup(identity_passphrase);
	else if (identity_new_passphrase)
		passphrase1 = xstrdup(identity_new_passphrase);
	else {
passphrase_again:
		passphrase1 =
			read_passphrase("Enter passphrase (empty for no "
			    "passphrase): ", RP_ALLOW_STDIN);
		passphrase2 = read_passphrase("Enter same passphrase again: ",
		    RP_ALLOW_STDIN);
		if (strcmp(passphrase1, passphrase2) != 0) {
			/*
			 * The passphrases do not match.  Clear them and
			 * retry.
			 */
			memset(passphrase1, 0, strlen(passphrase1));
			memset(passphrase2, 0, strlen(passphrase2));
			xfree(passphrase1);
			xfree(passphrase2);
			printf("Passphrases do not match.  Try again.\n");
			goto passphrase_again;
		}
		/* Clear the other copy of the passphrase. */
		memset(passphrase2, 0, strlen(passphrase2));
		xfree(passphrase2);
	}

	if (identity_comment) {
		strlcpy(comment, identity_comment, sizeof(comment));
	} else {
		/* Create default comment field for the passphrase. */
		snprintf(comment, sizeof comment, "%s@@%s", pw->pw_name, hostname);
	}

	/* Save the key with the given passphrase and comment. */
	if (!key_save_private(private, identity_file, passphrase1, comment)) {
		printf("Saving the key failed: %s.\n", identity_file);
		memset(passphrase1, 0, strlen(passphrase1));
		xfree(passphrase1);
		exit(1);
	}
	/* Clear the passphrase. */
	memset(passphrase1, 0, strlen(passphrase1));
	xfree(passphrase1);

	/* Clear the private key and the random number generator. */
	key_free(private);
	(void)arc4random();

	if (!quiet)
		printf("Your identification has been saved in %s.\n", identity_file);

	strlcat(identity_file, ".pub", sizeof(identity_file));
	fd = open(identity_file, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	if (fd == -1) {
		printf("Could not save your public key in %s\n", identity_file);
		exit(1);
	}
	f = fdopen(fd, "w");
	if (f == NULL) {
		printf("fdopen %s failed\n", identity_file);
		exit(1);
	}
	if (!key_write(public, f))
		fprintf(stderr, "write key failed\n");
	fprintf(f, " %s\n", comment);
	fclose(f);

	if (!quiet) {
		char *fp = key_fingerprint(public, SSH_FP_MD5, SSH_FP_HEX);
		char *ra = key_fingerprint(public, SSH_FP_MD5,
		    SSH_FP_RANDOMART);
		printf("Your public key has been saved in %s.\n",
		    identity_file);
		printf("The key fingerprint is:\n");
		printf("%s %s\n", fp, comment);
		printf("The key's randomart image is:\n");
		printf("%s\n", ra);
		xfree(ra);
		xfree(fp);
	}

	key_free(public);
	exit(0);
}
@


1.23
log
@Introduce /etc/ssh/root:config and /etc/ssh/root:known_hosts
and /etc/ssh/root:authorised_keys for the superuser if his
HOME directory is unset, empty or, not normalised, "/" (root).
十̲CVS: ----------------------------------------------------------------------
@
text
@d48 1
a48 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh-keygen.c,v 1.22 2009/10/04 14:29:10 tg Exp $");
d1440 1
a1440 1
	arc4random_stir();
d1535 1
a1535 1
	arc4random_stir();
@


1.22
log
@• merge newer OpenSSH
• KNF in our diff – style(9)
• some const cleanliness (build with __CRAZY=Yes mostly)
@
text
@d48 1
a48 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh-keygen.c,v 1.21 2009/03/22 15:01:21 tg Exp $");
d728 6
a733 1
		cp = tilde_expand_filename(_PATH_SSH_USER_HOSTFILE, pw->pw_uid);
@


1.21
log
@merge and tweak ciphers and MACs
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.173 2009/02/21 19:32:04 tobias Exp $ */
d16 1
a17 1
#include <sys/socket.h>
d48 1
a48 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh-keygen.c,v 1.20 2008/12/16 20:55:29 tg Exp $");
d606 1
a606 1
		ra = key_fingerprint(public, fptype, SSH_FP_RANDOMART);
d671 1
a671 1
			ra = key_fingerprint(public, fptype, SSH_FP_RANDOMART);
d701 1
a701 1
		ra = key_fingerprint(public, fptype, SSH_FP_RANDOMART);
d988 2
a989 1
do_print_resource_record(struct passwd *pw, char *fname, char *hname)
@


1.20
log
@fastmerge, do not use yet!
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.172 2008/11/07 00:42:12 stevesk Exp $ */
d48 1
a48 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh-keygen.c,v 1.19 2008/03/02 21:14:22 tg Exp $");
d136 1
a136 1
			fprintf(stderr, "bad key type");
d451 1
a451 1
		fprintf(stderr, "key write failed");
d1097 1
a1097 1
		printf("fdopen %s failed", identity_file);
d1101 1
a1101 1
		fprintf(stderr, "write key failed");
d1452 1
a1452 1
		fprintf(stderr, "key_generate failed");
d1542 1
a1542 1
		printf("fdopen %s failed", identity_file);
d1546 1
a1546 1
		fprintf(stderr, "write key failed");
@


1.19
log
@merge’n’fix
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.165 2008/01/19 22:37:19 djm Exp $ */
d48 1
a48 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh-keygen.c,v 1.18 2007/09/13 13:52:55 tg Exp $");
d69 2
d588 1
a588 1
	char *comment = NULL, *cp, *ep, line[16*1024], *fp;
d606 5
a610 1
		printf("%u %s %s\n", key_size(public), fp, comment);
d613 1
d671 6
a676 2
			printf("%u %s %s\n", key_size(public), fp,
			    comment ? comment : "no comment");
d693 23
a715 6
	if (hash && (name = host_hash(name, NULL, 0)) == NULL)
		fatal("hash_host failed");
	fprintf(f, "%s ", name);
	if (!key_write(public, f))
		fatal("key_write failed");
	fprintf(f, "\n");
a1169 1
	int log_level = SYSLOG_LEVEL_INFO;
d1340 4
d1512 1
a1512 1
		/* Create default commend field for the passphrase. */
d1552 2
d1558 3
@


1.18
log
@merge and make UMAC-64 default message integrity whatever
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.162 2007/09/11 15:47:17 gilles Exp $ */
d48 1
a48 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh-keygen.c,v 1.17 2007/01/25 16:18:38 tg Exp $");
d587 1
a587 1
	int i, skip = 0, num = 1, invalid = 1;
d618 3
a620 3
			i = strlen(line) - 1;
			if (line[i] != '\n') {
				error("line %d too long: %.40s...", num, line);
d629 1
a629 1
			line[i] = '\0';
d680 1
a680 1
print_host(FILE *f, char *name, Key *public, int hash)
d697 1
a697 1
	int c, i, skip = 0, inplace = 0, num = 0, invalid = 0, has_unhashed = 0;
d732 2
a733 4
		num++;
		i = strlen(line) - 1;
		if (line[i] != '\n') {
			error("line %d too long: %.40s...", num, line);
d738 1
d743 1
a743 1
		line[i] = '\0';
d807 2
a808 1
					print_host(out, cp, public, hash_hosts);
d832 1
a832 1
		fprintf(stderr, "%s is not a valid known_host file.\n",
@


1.17
log
@automerge, bump vsn
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.160 2007/01/21 01:41:54 stevesk Exp $ */
d48 1
a48 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh-keygen.c,v 1.16 2006/12/11 20:22:09 tg Exp $");
d143 1
a143 2
	if (strchr(buf, '\n'))
		*strchr(buf, '\n') = 0;
d1044 1
a1044 2
		if (strchr(new_comment, '\n'))
			*strchr(new_comment, '\n') = 0;
d1087 1
a1087 1
	fprintf(stderr, "Usage: %s [options]\n", __progname);
@


1.16
log
@* *.c: merge
* sshd.8: fix a merge glitch from prev
* version.h: bump
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.156 2006/11/14 19:41:04 deraadt Exp $ */
d48 1
a48 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh-keygen.c,v 1.15 2006/11/09 02:42:06 tg Exp $");
d272 1
a272 1
	magic  = buffer_get_int(&b);
d284 1
a284 1
	debug("ignore (%d %d %d %d)", i1,i2,i3,i4);
d315 1
a315 1
		e  = buffer_get_char(&b);
d377 2
a378 3
	if (c == EOF)
		return -1;
	return pos;
d636 1
a636 1
				continue ;
a1098 1
	fprintf(stderr, "  -e          Convert OpenSSH to IETF SECSH key file.\n");
d1100 1
a1105 1
	fprintf(stderr, "  -i          Convert IETF SECSH to OpenSSH key file.\n");
d1107 1
@


1.15
log
@merge
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.155 2006/11/06 21:25:28 markus Exp $ */
d48 1
a48 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh-keygen.c,v 1.14 2006/09/20 21:41:05 tg Exp $");
d1134 1
a1134 1
main(int ac, char **av)
d1154 1
a1154 1
	log_init(av[0], SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_USER, 1);
d1167 1
a1167 1
	while ((opt = getopt(ac, av,
d1306 1
a1306 1
	log_init(av[0], log_level, SYSLOG_FACILITY_USER, 1);
d1308 1
a1308 1
	if (optind < ac) {
@


1.14
log
@finish merging
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.154 2006/08/03 03:34:42 deraadt Exp $ */
d48 1
a48 1
__RCSID("$MirOS$");
d253 2
a254 1
	BN_bin2bn(buffer_ptr(b), bytes, value);
@


1.13
log
@* merge
* remove all references to GSSAPI, Kerberos and AFS
* uint*_t -> u_int*_t for consistency, like openbsd
  (note: MirOS style(9) suggests uint32_t etc. instead!)
* bump vsn
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.144 2006/05/17 12:43:34 markus Exp $ */
d15 1
a15 3
#include "includes.h"
__RCSID("$MirOS: src/usr.bin/ssh/ssh-keygen.c,v 1.12 2006/04/19 10:40:54 tg Exp $");

d17 1
d23 8
a36 1
#include "bufaux.h"
d42 1
d47 2
a48 1
#include "dns.h"
@


1.12
log
@merge and clean up
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.143 2006/03/30 11:05:17 dtucker Exp $ */
d16 1
a16 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh-keygen.c,v 1.11 2006/02/22 02:16:49 tg Exp $");
d603 1
a603 1
	if (comment)
d605 2
@


1.11
log
@fix a lot of and kludge a few more __CRAZY problems, sync rcs id
@
text
@d1 1
d16 1
a16 1
RCSID("$MirOS: src/usr.bin/ssh/ssh-keygen.c,v 1.10 2006/02/22 01:23:51 tg Exp $");
d114 1
a114 1
	else
d130 1
a130 1

d342 31
d379 1
a379 1
	char line[1024], *p;
d398 2
a399 6
	while (fgets(line, sizeof(line), fp)) {
		if (!(p = strchr(line, '\n'))) {
			fprintf(stderr, "input line too long.\n");
			exit(1);
		}
		if (p > line && p[-1] == '\\')
a415 1
		*p = '\0';
d950 2
a951 2
static __dead void
do_print_resource_record(struct passwd *pw, char *hname)
d957 1
a957 1
	if (!have_identity)
d959 4
a962 2
	if (stat(identity_file, &st) < 0) {
		perror(identity_file);
d965 1
a965 1
	public = key_load_public(identity_file, &comment);
d970 1
a970 1
		exit(0);
d975 1
a975 1
	printf("failed to read v2 public key from %s.\n", identity_file);
d1160 1
a1160 1
			bits = strtonum(optarg, 768, 32768, &errstr);
d1236 1
d1253 2
a1254 1
			generator_wanted = strtonum(optarg, 1, UINT_MAX, &errstr);
d1260 1
a1260 1
			trials = strtonum(optarg, 1, UINT_MAX, &errstr);
d1266 1
a1266 1
			memory = strtonum(optarg, 1, UINT_MAX, &errstr);
d1324 21
a1344 1
		do_print_resource_record(pw, rr_hostname);
@


1.10
log
@merge; bump version; fix up manpages and includes a little
@
text
@d15 1
a15 1
RCSID("$MirOS: src/usr.bin/ssh/ssh-keygen.c,v 1.9 2006/01/30 15:47:04 tg Exp $");
d94 1
a94 1
char *key_type_name = NULL;
d109 1
a109 1
	char *name = NULL;
d114 1
a114 1
		switch (key_type_from_name(key_type_name)) {
d425 1
a425 1
static void
d547 1
a547 1
static void
d654 1
a654 1
static void
d842 1
a842 1
static void
d923 1
a923 1
static void
d953 1
a953 1
static void
d1047 1
a1047 1
static void
a1109 3
	extern int optind;
	extern char *optarg;

d1349 1
a1349 1
	type = key_type_from_name(key_type_name);
@


1.9
log
@* allow ssh-keygen -I to 'import' RSA public keys embedded in
  X.509 certificates into ssh format as well
* sync documentation for -I and -E
@
text
@d15 3
a17 1
RCSID("$MirOS: src/usr.bin/ssh/ssh-keygen.c,v 1.8 2006/01/30 15:21:47 tg Exp $");
@


1.8
log
@add SSL error output
@
text
@d15 1
a15 1
RCSID("$MirOS: src/usr.bin/ssh/ssh-keygen.c,v 1.7 2005/12/20 19:57:36 tg Exp $");
d429 1
d445 11
a455 1
		k->rsa = PEM_read_RSA_PUBKEY(fp, NULL, NULL, NULL);
@


1.7
log
@fastmerge, bump version
@
text
@d15 1
a15 1
RCSID("$MirOS: src/usr.bin/ssh/ssh-keygen.c,v 1.6 2005/11/23 19:45:15 tg Exp $");
d19 1
d447 4
@


1.6
log
@merge
@
text
@d15 1
a15 1
RCSID("$MirOS: src/usr.bin/ssh/ssh-keygen.c,v 1.5 2005/11/23 18:04:20 tg Exp $");
d1116 1
a1116 1
			bits = strtonum(optarg, 512, 32768, &errstr);
d1339 4
a1344 2
	if (bits == 0)
		bits = (type == KEY_DSA) ? DEFAULT_BITS_DSA : DEFAULT_BITS;
@


1.5
log
@fastmerge remainder of src/usr.bin
@
text
@d15 1
a15 1
RCSID("$MirOS: src/usr.bin/ssh/ssh-keygen.c,v 1.4 2005/06/22 16:11:39 tg Exp $");
d38 4
a41 2
/* Number of bits in the RSA/DSA key.  This value can be changed on the command line. */
u_int32_t bits = 2048;
d1095 3
d1299 2
d1302 1
a1302 1
			fatal("modulus candidate generation failed\n");
d1325 1
a1325 1
			fatal("modulus screening failed\n");
d1331 3
a1333 4
	if (key_type_name == NULL) {
		printf("You must specify a key type (-t).\n");
		usage();
	}
d1341 2
d1353 1
a1353 1
	/* Create ~/.etc/ssh directory if it doesn\'t already exist. */
@


1.4
log
@merge
@
text
@d15 1
a15 1
RCSID("$MirOS: src/usr.bin/ssh/ssh-keygen.c,v 1.3 2005/04/14 19:49:34 tg Exp $");
d811 1
a811 1
			     "of hostnames\n");
@


1.3
log
@merge
@
text
@d15 1
a15 1
RCSID("$MirOS: src/usr.bin/ssh/ssh-keygen.c,v 1.2 2005/03/13 18:33:32 tg Exp $");
d39 1
a39 1
int bits = 1024;
d97 1
a97 1
int gen_candidates(FILE *, int, int, BIGNUM *);
d1082 2
a1083 2
	int opt, type, fd, download = 0, memory = 0;
	int generator_wanted = 0, trials = 100;
d1088 1
d1111 4
a1114 5
			bits = atoi(optarg);
			if (bits < 512 || bits > 32768) {
				printf("Bits has bad value.\n");
				exit(1);
			}
d1140 3
a1142 1
			strlcpy(identity_file, optarg, sizeof(identity_file));
d1203 4
a1206 3
			generator_wanted = atoi(optarg);
			if (generator_wanted < 1)
				fatal("Desired generator has bad value.");
d1209 4
a1212 1
			trials = atoi(optarg);
d1215 4
a1218 1
			memory = atoi(optarg);
d1222 3
a1224 1
			strlcpy(out_file, optarg, sizeof(out_file));
d1228 3
a1230 1
			strlcpy(out_file, optarg, sizeof(out_file));
@


1.2
log
@merge src/usr.bin
@
text
@d15 1
a15 1
RCSID("$MirOS$");
d30 2
d55 7
d623 195
d1032 2
d1035 1
d1037 3
d1042 1
d1044 1
d1046 1
d1050 3
d1055 4
a1058 1
	fprintf(stderr, "  -y          Read private key file and print public key.\n");
a1059 5
	fprintf(stderr, "  -B          Show bubblebabble digest of key file.\n");
	fprintf(stderr, "  -C comment  Provide new comment.\n");
	fprintf(stderr, "  -N phrase   Provide new passphrase.\n");
	fprintf(stderr, "  -P phrase   Provide old passphrase.\n");
	fprintf(stderr, "  -r hostname Print DNS resource record.\n");
a1060 1
	fprintf(stderr, "  -D reader   Download public key from smartcard.\n");
d1063 3
a1065 3

	fprintf(stderr, "  -G file     Generate candidates for DH-GEX moduli\n");
	fprintf(stderr, "  -T file     Screen candidates for DH-GEX moduli\n");
d1078 1
a1078 1
	char *resource_record_hostname = NULL;
d1107 1
a1107 1
	    "a:Bb:cC:dD:Eef:gG:g:IilM:N:pP:qRr:S:T:t:U:vW:Xxy")) != -1) {
d1116 11
a1157 4
		case 'R':
			/* unused */
			exit(0);
			break;
d1198 1
a1198 1
			resource_record_hostname = optarg;
d1241 2
d1259 2
a1260 2
	if (resource_record_hostname != NULL) {
		do_print_resource_record(pw, resource_record_hostname);
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.118 2004/12/23 17:38:07 markus Exp $");
d76 4
d193 29
d412 37
d831 1
d835 1
d894 1
a894 1
	    "degiqpclBRvxXyb:f:t:U:D:P:N:C:r:g:T:G:M:S:a:W:")) != -1) {
d948 6
d1031 4
d1110 1
a1110 1
	/* Create ~/.ssh directory if it doesn\'t already exist. */
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@OpenSSH-current
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.123 2005/04/05 13:45:31 otto Exp $");
a29 2
#include "match.h"
#include "hostfile.h"
a52 7
/* Flag indicating that we want to hash a known_hosts file */
int hash_hosts = 0;
/* Flag indicating that we want lookup a host in known_hosts file */
int find_host = 0;
/* Flag indicating that we want to delete a host from a known_hosts file */
int delete_host = 0;

a543 195
static void
print_host(FILE *f, char *name, Key *public, int hash)
{
	if (hash && (name = host_hash(name, NULL, 0)) == NULL)
		fatal("hash_host failed");
	fprintf(f, "%s ", name);
	if (!key_write(public, f))
		fatal("key_write failed");
	fprintf(f, "\n");
}

static void
do_known_hosts(struct passwd *pw, const char *name)
{
	FILE *in, *out = stdout;
	Key *public;
	char *cp, *cp2, *kp, *kp2;
	char line[16*1024], tmp[MAXPATHLEN], old[MAXPATHLEN];
	int c, i, skip = 0, inplace = 0, num = 0, invalid = 0, has_unhashed = 0;

	if (!have_identity) {
		cp = tilde_expand_filename(_PATH_SSH_USER_HOSTFILE, pw->pw_uid);
		if (strlcpy(identity_file, cp, sizeof(identity_file)) >=
		    sizeof(identity_file))
			fatal("Specified known hosts path too long");
		xfree(cp);
		have_identity = 1;
	}
	if ((in = fopen(identity_file, "r")) == NULL)
		fatal("fopen: %s", strerror(errno));

	/*
	 * Find hosts goes to stdout, hash and deletions happen in-place
	 * A corner case is ssh-keygen -HF foo, which should go to stdout
	 */
	if (!find_host && (hash_hosts || delete_host)) {
		if (strlcpy(tmp, identity_file, sizeof(tmp)) >= sizeof(tmp) ||
		    strlcat(tmp, ".XXXXXXXXXX", sizeof(tmp)) >= sizeof(tmp) ||
		    strlcpy(old, identity_file, sizeof(old)) >= sizeof(old) ||
		    strlcat(old, ".old", sizeof(old)) >= sizeof(old))
			fatal("known_hosts path too long");
		umask(077);
		if ((c = mkstemp(tmp)) == -1)
			fatal("mkstemp: %s", strerror(errno));
		if ((out = fdopen(c, "w")) == NULL) {
			c = errno;
			unlink(tmp);
			fatal("fdopen: %s", strerror(c));
		}
		inplace = 1;
	}

	while (fgets(line, sizeof(line), in)) {
		num++;
		i = strlen(line) - 1;
		if (line[i] != '\n') {
			error("line %d too long: %.40s...", num, line);
			skip = 1;
			invalid = 1;
			continue;
		}
		if (skip) {
			skip = 0;
			continue;
		}
		line[i] = '\0';

		/* Skip leading whitespace, empty and comment lines. */
		for (cp = line; *cp == ' ' || *cp == '\t'; cp++)
			;
		if (!*cp || *cp == '\n' || *cp == '#') {
			if (inplace)
				fprintf(out, "%s\n", cp);
			continue;
		}
		/* Find the end of the host name portion. */
		for (kp = cp; *kp && *kp != ' ' && *kp != '\t'; kp++)
			;
		if (*kp == '\0' || *(kp + 1) == '\0') {
			error("line %d missing key: %.40s...",
			    num, line);
			invalid = 1;
			continue;
		}
		*kp++ = '\0';
		kp2 = kp;

		public = key_new(KEY_RSA1);
		if (key_read(public, &kp) != 1) {
			kp = kp2;
			key_free(public);
			public = key_new(KEY_UNSPEC);
			if (key_read(public, &kp) != 1) {
				error("line %d invalid key: %.40s...",
				    num, line);
				key_free(public);
				invalid = 1;
				continue;
			}
		}

		if (*cp == HASH_DELIM) {
			if (find_host || delete_host) {
				cp2 = host_hash(name, cp, strlen(cp));
				if (cp2 == NULL) {
					error("line %d: invalid hashed "
					    "name: %.64s...", num, line);
					invalid = 1;
					continue;
				}
				c = (strcmp(cp2, cp) == 0);
				if (find_host && c) {
					printf("# Host %s found: "
					    "line %d type %s\n", name,
					    num, key_type(public));
					print_host(out, cp, public, 0);
				}
				if (delete_host && !c)
					print_host(out, cp, public, 0);
			} else if (hash_hosts)
				print_host(out, cp, public, 0);
		} else {
			if (find_host || delete_host) {
				c = (match_hostname(name, cp,
				    strlen(cp)) == 1);
				if (find_host && c) {
					printf("# Host %s found: "
					    "line %d type %s\n", name,
					    num, key_type(public));
					print_host(out, cp, public, hash_hosts);
				}
				if (delete_host && !c)
					print_host(out, cp, public, 0);
			} else if (hash_hosts) {
				for (cp2 = strsep(&cp, ",");
				    cp2 != NULL && *cp2 != '\0';
				    cp2 = strsep(&cp, ",")) {
					if (strcspn(cp2, "*?!") != strlen(cp2))
						fprintf(stderr, "Warning: "
						    "ignoring host name with "
						    "metacharacters: %.64s\n",
						    cp2);
					else
						print_host(out, cp2, public, 1);
				}
				has_unhashed = 1;
			}
		}
		key_free(public);
	}
	fclose(in);

	if (invalid) {
		fprintf(stderr, "%s is not a valid known_host file.\n",
		    identity_file);
		if (inplace) {
			fprintf(stderr, "Not replacing existing known_hosts "
			    "file because of errors\n");
			fclose(out);
			unlink(tmp);
		}
		exit(1);
	}

	if (inplace) {
		fclose(out);

		/* Backup existing file */
		if (unlink(old) == -1 && errno != ENOENT)
			fatal("unlink %.100s: %s", old, strerror(errno));
		if (link(identity_file, old) == -1)
			fatal("link %.100s to %.100s: %s", identity_file, old,
			    strerror(errno));
		/* Move new one into place */
		if (rename(tmp, identity_file) == -1) {
			error("rename\"%s\" to \"%s\": %s", tmp, identity_file,
			    strerror(errno));
			unlink(tmp);
			unlink(old);
			exit(1);
		}

		fprintf(stderr, "%s updated.\n", identity_file);
		fprintf(stderr, "Original contents retained as %s\n", old);
		if (has_unhashed) {
			fprintf(stderr, "WARNING: %s contains unhashed "
			    "entries\n", old);
			fprintf(stderr, "Delete this file to ensure privacy "
			     "of hostnames\n");
		}
	}

	exit(0);
}

a757 2
	fprintf(stderr, "  -a trials   Number of trials for screening DH-GEX moduli.\n");
	fprintf(stderr, "  -B          Show bubblebabble digest of key file.\n");
a758 1
	fprintf(stderr, "  -C comment  Provide new comment.\n");
a759 3
#ifdef SMARTCARD
	fprintf(stderr, "  -D reader   Download public key from smartcard.\n");
#endif /* SMARTCARD */
a760 1
	fprintf(stderr, "  -F hostname Find hostname in known hosts file.\n");
a761 1
	fprintf(stderr, "  -G file     Generate candidates for DH-GEX moduli.\n");
a762 1
	fprintf(stderr, "  -H          Hash names in known_hosts file.\n");
d765 6
a770 1
	fprintf(stderr, "  -M memory   Amount of memory (MB) to use for generating DH-GEX moduli.\n");
a772 3
	fprintf(stderr, "  -p          Change passphrase of private key file.\n");
	fprintf(stderr, "  -q          Quiet.\n");
	fprintf(stderr, "  -R hostname Remove host from known_hosts file.\n");
a773 3
	fprintf(stderr, "  -S start    Start point (hex) for generating DH-GEX moduli.\n");
	fprintf(stderr, "  -T file     Screen candidates for DH-GEX moduli.\n");
	fprintf(stderr, "  -t type     Specify type of key to create.\n");
d775 1
d778 3
a780 3
	fprintf(stderr, "  -v          Verbose.\n");
	fprintf(stderr, "  -W gen      Generator to use for generating DH-GEX moduli.\n");
	fprintf(stderr, "  -y          Read private key file and print public key.\n");
d793 1
a793 1
	char *rr_hostname = NULL;
d822 1
a822 1
	    "degiqpclBHvxXyF:b:f:t:U:D:P:N:C:r:g:R:T:G:M:S:a:W:")) != -1) {
a830 11
		case 'F':
			find_host = 1;
			rr_hostname = optarg;
			break;
		case 'H':
			hash_hosts = 1;
			break;
		case 'R':
			delete_host = 1;
			rr_hostname = optarg;
			break;
d862 4
d900 1
a900 1
			rr_hostname = optarg;
a942 2
	if (delete_host || hash_hosts || find_host)
		do_known_hosts(pw, rr_hostname);
d955 2
a956 2
	if (rr_hostname != NULL) {
		do_print_resource_record(pw, rr_hostname);
@


1.1.1.3
log
@most current OpenSSH.com
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.127 2005/06/08 03:50:00 djm Exp $");
d39 1
a39 1
u_int32_t bits = 2048;
d93 1
a93 1
int gen_candidates(FILE *, u_int32_t, u_int32_t, BIGNUM *);
d1010 2
a1011 2
	int opt, type, fd, download = 0;
	u_int32_t memory = 0, generator_wanted = 0, trials = 100;
a1015 1
	const char *errstr;
d1038 5
a1042 4
			bits = strtonum(optarg, 512, 32768, &errstr);
			if (errstr)
				fatal("Bits has bad value %s (%s)",
					optarg, errstr);
d1068 1
a1068 3
			if (strlcpy(identity_file, optarg, sizeof(identity_file)) >=
			    sizeof(identity_file))
				fatal("Identity filename too long");
d1123 3
a1125 4
			generator_wanted = strtonum(optarg, 1, UINT_MAX, &errstr);
			if (errstr)
				fatal("Desired generator has bad value: %s (%s)",
					optarg, errstr);
d1128 1
a1128 4
			trials = strtonum(optarg, 1, UINT_MAX, &errstr);
			if (errstr)
				fatal("Invalid number of trials: %s (%s)",
					optarg, errstr);
d1131 1
a1131 4
			memory = strtonum(optarg, 1, UINT_MAX, &errstr);
			if (errstr) {
				fatal("Memory limit is %s: %s", errstr, optarg);
			}
d1135 1
a1135 3
			if (strlcpy(out_file, optarg, sizeof(out_file)) >=
			    sizeof(out_file))
				fatal("Output filename too long");
d1139 1
a1139 3
			if (strlcpy(out_file, optarg, sizeof(out_file)) >=
			    sizeof(out_file))
				fatal("Output filename too long");
@


1.1.1.4
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.128 2005/07/17 07:17:55 djm Exp $");
d741 1
a741 1
			    "of hostnames\n");
@


1.1.1.5
log
@Import current OpenSSH
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.133 2005/10/31 11:12:49 djm Exp $");
d38 2
a39 4
/* Number of bits in the RSA/DSA key.  This value can be set on the command line. */
#define DEFAULT_BITS		2048
#define DEFAULT_BITS_DSA	1024
u_int32_t bits = 0;
a1020 3
	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

a1211 2
		if (bits == 0)
			bits = DEFAULT_BITS;
d1213 1
a1213 1
			fatal("modulus candidate generation failed");
d1236 1
a1236 1
			fatal("modulus screening failed");
d1242 4
a1245 3
	if (key_type_name == NULL)
		key_type_name = "rsa";

a1252 2
	if (bits == 0)
		bits = (type == KEY_DSA) ? DEFAULT_BITS_DSA : DEFAULT_BITS;
d1263 1
a1263 1
	/* Create ~/.ssh directory if it doesn't already exist. */
@


1.1.1.6
log
@OpenSSH is the last missing piece to update before the release
@
text
@d15 1
a15 1
RCSID("$OpenBSD: ssh-keygen.c,v 1.135 2005/11/29 02:04:55 dtucker Exp $");
d1044 1
a1044 1
			bits = strtonum(optarg, 768, 32768, &errstr);
d1257 2
a1260 4
	if (type == KEY_DSA && bits != 1024)
		fatal("DSA keys must be 1024 bits");
	if (!quiet)
		printf("Generating public/private %s key pair.\n", key_type_name);
@


1.1.1.7
log
@import OpenSSH-current
@
text
@d15 1
a15 4
RCSID("$OpenBSD: ssh-keygen.c,v 1.136 2006/02/20 17:19:54 stevesk Exp $");

#include <sys/types.h>
#include <sys/stat.h>
@


1.1.1.8
log
@I decided we'd better upgrade OpenSSH before releasing to the general public
@
text
@a0 1
/* $OpenBSD: ssh-keygen.c,v 1.143 2006/03/30 11:05:17 dtucker Exp $ */
d15 1
d109 1
a109 1
	else {
d125 1
a125 1
	}
a307 31
static int
get_line(FILE *fp, char *line, size_t len)
{
	int c;
	size_t pos = 0;

	line[0] = '\0';
	while ((c = fgetc(fp)) != EOF) {
		if (pos >= len - 1) {
			fprintf(stderr, "input line too long.\n");
			exit(1);
		}
		switch (c) {
		case '\r':
			c = fgetc(fp);
			if (c != EOF && c != '\n' && ungetc(c, fp) == EOF) {
				fprintf(stderr, "unget: %s\n", strerror(errno));
				exit(1);
			}
			return pos;
		case '\n':
			return pos;
		}
		line[pos++] = c;
		line[pos] = '\0';
	}
	if (c == EOF)
		return -1;
	return pos;
}

d314 1
a314 1
	char line[1024];
d333 6
a338 2
	while ((blen = get_line(fp, line, sizeof(line))) != -1) {
		if (line[blen - 1] == '\\')
d355 1
d838 2
a839 2
static int
do_print_resource_record(struct passwd *pw, char *fname, char *hname)
d845 1
a845 1
	if (fname == NULL)
d847 2
a848 4
	if (stat(fname, &st) < 0) {
		if (errno == ENOENT)
			return 0;
		perror(fname);
d851 1
a851 1
	public = key_load_public(fname, &comment);
d856 1
a856 1
		return 1;
d861 1
a861 1
	printf("failed to read v2 public key from %s.\n", fname);
d1047 1
a1047 1
			bits = (u_int32_t)strtonum(optarg, 768, 32768, &errstr);
a1116 1
			/*FALLTHROUGH*/
d1133 1
a1133 2
			generator_wanted = (u_int32_t)strtonum(optarg, 1,
			    UINT_MAX, &errstr);
d1139 1
a1139 1
			trials = (u_int32_t)strtonum(optarg, 1, UINT_MAX, &errstr);
d1145 1
a1145 1
			memory = (u_int32_t)strtonum(optarg, 1, UINT_MAX, &errstr);
d1199 1
a1199 21
		unsigned int n = 0;

		if (have_identity) {
			n = do_print_resource_record(pw,
			    identity_file, rr_hostname);
			if (n == 0) {
				perror(identity_file);
				exit(1);
			}
			exit(0);
		} else {

			n += do_print_resource_record(pw,
			    _PATH_HOST_RSA_KEY_FILE, rr_hostname);
			n += do_print_resource_record(pw,
			    _PATH_HOST_DSA_KEY_FILE, rr_hostname);

			if (n == 0)
				fatal("no keys found.");
			exit(0);
		}
@


1.1.1.9
log
@if we're gonna push out another snapshot, we'd better have sshd-current
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.144 2006/05/17 12:43:34 markus Exp $ */
d517 1
a517 1
	if (comment) {
a518 2
		comment = NULL;
	}
@


1.1.1.10
log
@import a few security-wise relevant changes right now
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.154 2006/08/03 03:34:42 deraadt Exp $ */
d15 2
a18 2
#include <sys/socket.h>
#include <sys/param.h>
a22 8
#include <errno.h>
#include <fcntl.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

d29 1
a34 1
#include "dns.h"
d39 1
@


1.1.1.11
log
@OpenSSH 4.5 (security)
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.155 2006/11/06 21:25:28 markus Exp $ */
d218 1
a218 2
	if (BN_bin2bn(buffer_ptr(b), bytes, value) == NULL)
		fatal("buffer_get_bignum_bits: BN_bin2bn failed");
@


1.1.1.12
log
@current OpenSSH
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.156 2006/11/14 19:41:04 deraadt Exp $ */
d1045 1
a1045 1
main(int argc, char **argv)
d1068 1
a1068 1
	log_init(argv[0], SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_USER, 1);
d1081 1
a1081 1
	while ((opt = getopt(argc, argv,
d1214 1
a1214 1
	log_init(argv[0], log_level, SYSLOG_FACILITY_USER, 1);
d1216 1
a1216 1
	if (optind < argc) {
@


1.1.1.13
log
@update OpenSSH, while we're at it…
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.160 2007/01/21 01:41:54 stevesk Exp $ */
d237 1
a237 1
	magic = buffer_get_int(&b);
d249 1
a249 1
	debug("ignore (%d %d %d %d)", i1, i2, i3, i4);
d280 1
a280 1
		e = buffer_get_char(&b);
d342 3
a344 2
	/* We reached EOF */
	return -1;
d550 1
a550 1
				continue;
d1013 1
a1013 1
	fprintf(stderr, "  -e          Convert OpenSSH to RFC 4716 key file.\n");
d1019 1
a1019 1
	fprintf(stderr, "  -i          Convert RFC 4716 to OpenSSH key file.\n");
@


1.1.1.14
log
@Import latest OpenSSH upgrades
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.162 2007/09/11 15:47:17 gilles Exp $ */
d137 2
a138 1
	buf[strcspn(buf, "\n")] = '\0';
d958 2
a959 1
		new_comment[strcspn(new_comment, "\n")] = '\0';
d1002 1
a1002 1
	fprintf(stderr, "usage: %s [options]\n", __progname);
@


1.1.1.15
log
@newer openssh
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.165 2008/01/19 22:37:19 djm Exp $ */
d500 1
a500 1
	int i, skip = 0, num = 0, invalid = 1;
d531 3
a533 3
			if ((cp = strchr(line, '\n')) == NULL) {
				error("line %d too long: %.40s...",
				    num + 1, line);
d542 1
a542 1
			*cp = '\0';
d593 1
a593 1
print_host(FILE *f, const char *name, Key *public, int hash)
d610 1
a610 1
	int c, skip = 0, inplace = 0, num = 0, invalid = 0, has_unhashed = 0;
d645 4
a648 2
		if ((cp = strchr(line, '\n')) == NULL) {
			error("line %d too long: %.40s...", num + 1, line);
a652 1
		num++;
d657 1
a657 1
		*cp = '\0';
d721 1
a721 2
					print_host(out, name, public,
					    hash_hosts);
d745 1
a745 1
		fprintf(stderr, "%s is not a valid known_hosts file.\n",
@


1.1.1.16
log
@OpenSSH-current
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.172 2008/11/07 00:42:12 stevesk Exp $ */
a66 2
int log_level = SYSLOG_LEVEL_INFO;

d499 1
a499 1
	char *comment = NULL, *cp, *ep, line[16*1024], *fp, *ra;
d517 1
a517 5
		ra = key_fingerprint(public, fptype, SSH_FP_RANDOMART);
		printf("%u %s %s (%s)\n", key_size(public), fp, comment,
		    key_type(public));
		if (log_level >= SYSLOG_LEVEL_VERBOSE)
			printf("%s\n", ra);
a519 1
		xfree(ra);
d577 2
a578 6
			ra = key_fingerprint(public, fptype, SSH_FP_RANDOMART);
			printf("%u %s %s (%s)\n", key_size(public), fp,
			    comment ? comment : "no comment", key_type(public));
			if (log_level >= SYSLOG_LEVEL_VERBOSE)
				printf("%s\n", ra);
			xfree(ra);
d595 6
a600 23
	if (print_fingerprint) {
		enum fp_rep rep;
		enum fp_type fptype;
		char *fp, *ra;

		fptype = print_bubblebabble ? SSH_FP_SHA1 : SSH_FP_MD5;
		rep =    print_bubblebabble ? SSH_FP_BUBBLEBABBLE : SSH_FP_HEX;
		fp = key_fingerprint(public, fptype, rep);
		ra = key_fingerprint(public, fptype, SSH_FP_RANDOMART);
		printf("%u %s %s (%s)\n", key_size(public), fp, name,
		    key_type(public));
		if (log_level >= SYSLOG_LEVEL_VERBOSE)
			printf("%s\n", ra);
		xfree(ra);
		xfree(fp);
	} else {
		if (hash && (name = host_hash(name, NULL, 0)) == NULL)
			fatal("hash_host failed");
		fprintf(f, "%s ", name);
		if (!key_write(public, f))
			fatal("key_write failed");
		fprintf(f, "\n");
	}
d1053 1
a1220 4
	if (print_fingerprint && (delete_host || hash_hosts)) {
		printf("Cannot use -l with -D or -R.\n");
		usage();
	}
d1385 1
a1385 1
		/* Create default comment field for the passphrase. */
a1424 2
		char *ra = key_fingerprint(public, SSH_FP_MD5,
		    SSH_FP_RANDOMART);
a1428 3
		printf("The key's randomart image is:\n");
		printf("%s\n", ra);
		xfree(ra);
@


1.1.1.17
log
@OpenSSH 5.2, or so
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.173 2009/02/21 19:32:04 tobias Exp $ */
d130 1
a130 1
			fprintf(stderr, "bad key type\n");
d416 1
a416 1
		fprintf(stderr, "key write failed\n");
d1010 1
a1010 1
		printf("fdopen %s failed\n", identity_file);
d1014 1
a1014 1
		fprintf(stderr, "write key failed\n");
d1356 1
a1356 1
		fprintf(stderr, "key_generate failed\n");
d1446 1
a1446 1
		printf("fdopen %s failed\n", identity_file);
d1450 1
a1450 1
		fprintf(stderr, "write key failed\n");
@


1.1.1.18
log
@Let’s play the version number game – OpenSSH 5.3-current
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-keygen.c,v 1.175 2009/08/27 17:33:49 djm Exp $ */
d16 1
a17 1
#include <sys/stat.h>
d519 1
a519 1
		ra = key_fingerprint(public, SSH_FP_MD5, SSH_FP_RANDOMART);
d584 1
a584 1
			ra = key_fingerprint(public, SSH_FP_MD5, SSH_FP_RANDOMART);
d614 1
a614 1
		ra = key_fingerprint(public, SSH_FP_MD5, SSH_FP_RANDOMART);
@


