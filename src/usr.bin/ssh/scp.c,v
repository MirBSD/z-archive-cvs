head	1.20;
access;
symbols
	cvs-200910041320:1.1.1.14
	cvs-200903221200:1.1.1.14
	cvs-200812162015:1.1.1.14
	cvs-200804031830:1.1.1.13
	MIRBSD_10:1.15.0.2
	MIRBSD_10_BASE:1.15
	cvs-200803022030:1.1.1.13
	cvs-200709131337:1.1.1.12
	cvs-200709021830:1.1.1.12
	cvs-200708201200:1.1.1.12
	cvs-200706161500:1.1.1.11
	cvs-200705192215:1.1.1.10
	cvs-200704292000:1.1.1.10
	cvs-200703080900:1.1.1.10
	cvs-200701251600:1.1.1.10
	cvs-200612111600:1.1.1.9
	cvs-200611090230:1.1.1.9
	OPENBSD_4_0:1.1.1.9
	MIRBSD_9_BASE:1.9
	cvs-200606162342:1.1.1.8
	cvs-200606022000:1.1.1.8
	cvs-200604191000:1.1.1.7
	cvs-200602220045:1.1.1.6
	MIRBSD_8:1.6.0.2
	MIRBSD_8_BASE:1.6
	cvs-200512201942:1.1.1.5
	cvs-200511231930:1.1.1.4
	cvs-200507211800:1.1.1.3
	cvs-200506221550:1.1.1.3
	cvs-200505050030:1.1.1.2
	cvs-200504291700:1.1.1.2
	cvs-200504261445:1.1.1.2
	cvs-200504141900:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2013.10.31.20.07.13;	author tg;	state Exp;
branches;
next	1.19;
commitid	1005272B7081B0E5655;

1.19
date	2009.10.04.14.29.06;	author tg;	state Exp;
branches;
next	1.18;
commitid	1004AC8B1276FC00211;

1.18
date	2008.12.27.21.17.56;	author tg;	state Exp;
branches;
next	1.17;
commitid	10049569B9439744217;

1.17
date	2008.12.16.22.13.28;	author tg;	state Exp;
branches;
next	1.16;
commitid	10049482819766381ED;

1.16
date	2008.12.16.20.55.25;	author tg;	state Exp;
branches;
next	1.15;
commitid	100494815C97ECEEDBF;

1.15
date	2008.03.02.21.14.20;	author tg;	state Exp;
branches;
next	1.14;
commitid	10047CB18BB506A8527;

1.14
date	2007.08.20.12.11.30;	author tg;	state Exp;
branches;
next	1.13;
commitid	10046C985053DA1DB8B;

1.13
date	2007.06.16.15.41.51;	author tg;	state Exp;
branches;
next	1.12;
commitid	100467404D10F2EE204;

1.12
date	2007.01.25.16.18.36;	author tg;	state Exp;
branches;
next	1.11;
commitid	10045B8D86E5B698AD6;

1.11
date	2006.09.20.21.41.01;	author tg;	state Exp;
branches;
next	1.10;
commitid	1004511B578580E7F04;

1.10
date	2006.08.12.14.26.09;	author tg;	state Exp;
branches;
next	1.9;
commitid	10044DDE4FC6BC29E9D;

1.9
date	2006.06.02.20.50.48;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004480A4952B0D84EA;

1.8
date	2006.04.19.10.40.51;	author tg;	state Exp;
branches;
next	1.7;
commitid	100444613BD3A91C28B;

1.7
date	2006.02.22.01.23.50;	author tg;	state Exp;
branches;
next	1.6;
commitid	10043FBBD2C2C5E7D81;

1.6
date	2005.12.20.19.57.33;	author tg;	state Exp;
branches;
next	1.5;
commitid	10043A8623F4C1F637E;

1.5
date	2005.11.23.19.45.14;	author tg;	state Exp;
branches;
next	1.4;
commitid	29f4384c6def7d1;

1.4
date	2005.06.22.16.11.39;	author tg;	state Exp;
branches;
next	1.3;
commitid	598b42b98dcf335f;

1.3
date	2005.04.14.19.49.34;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.13.18.33.30;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.29.52;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.29.52;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.14.19.33.27;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.06.22.15.56.28;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	181342b98a38fe99;

1.1.1.4
date	2005.11.23.19.34.15;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	116a4384c4467ffc;

1.1.1.5
date	2005.12.20.19.43.44;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	10043A85EF81EF097CF;

1.1.1.6
date	2006.02.22.00.51.35;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	10043FBB5A933C3BB9B;

1.1.1.7
date	2006.04.19.10.15.04;	author tg;	state Exp;
branches;
next	1.1.1.8;
commitid	10044460DB21E1F715C;

1.1.1.8
date	2006.06.02.20.31.51;	author tg;	state Exp;
branches;
next	1.1.1.9;
commitid	1004480A0422110D712;

1.1.1.9
date	2006.09.20.19.06.49;	author tg;	state Exp;
branches;
next	1.1.1.10;
commitid	10045119150397FC669;

1.1.1.10
date	2007.01.25.16.13.12;	author tg;	state Exp;
branches;
next	1.1.1.11;
commitid	10045B8D7100791C016;

1.1.1.11
date	2007.06.16.15.11.13;	author tg;	state Exp;
branches;
next	1.1.1.12;
commitid	1004673FD85114A3F32;

1.1.1.12
date	2007.08.20.12.05.35;	author tg;	state Exp;
branches;
next	1.1.1.13;
commitid	10046C9839120FD28DF;

1.1.1.13
date	2008.03.02.20.40.42;	author tg;	state Exp;
branches;
next	1.1.1.14;
commitid	10047CB10DD30FAF062;

1.1.1.14
date	2008.12.16.20.15.33;	author tg;	state Exp;
branches;
next	;
commitid	10049480C7A2701F5C0;


desc
@@


1.20
log
@adapt most __attribute__((…)) occurrences to new KNF style(9)
@
text
@/* $OpenBSD: scp.c,v 1.164 2008/10/10 04:55:16 stevesk Exp $ */
/*
 * scp - secure remote copy.  This is basically patched BSD rcp which
 * uses ssh to do the data transfer (instead of using rcmd).
 *
 * NOTE: This version should NOT be suid root.  (This uses ssh to
 * do the transfer and ssh has the necessary privileges.)
 *
 * 1995 Timo Rinne <tri@@iki.fi>, Tatu Ylonen <ylo@@cs.hut.fi>
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */
/*
 * Copyright © 2013
 *	Thorsten “mirabilos” Glaser <tg@@mirbsd.org>
 * Copyright (c) 1999 Theo de Raadt.  All rights reserved.
 * Copyright (c) 1999 Aaron Campbell.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Parts from:
 *
 * Copyright (c) 1983, 1990, 1992, 1993, 1995
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/poll.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/uio.h>

#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <pwd.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <vis.h>

#include "xmalloc.h"
#include "atomicio.h"
#include "pathnames.h"
#include "log.h"
#include "misc.h"
#include "progressmeter.h"

__RCSID("$MirOS: src/usr.bin/ssh/scp.c,v 1.19 2009/10/04 14:29:06 tg Exp $");

#define COPY_BUFLEN	16384

int do_cmd(char *host, char *remuser, char *cmd, int *fdin, int *fdout);

void bwlimit(int);

/* Struct for addargs */
arglist args;

/* Bandwidth limit */
off_t limit_rate = 0;

/* Name of current file being transferred. */
char *curfile;

/* This is set to non-zero to enable verbose mode. */
int verbose_mode = 0;

/* This is set to zero if the progressmeter is not desired. */
int showprogress = 1;

/* This is the program to execute for the secured connection. ("ssh" or -S) */
const char *ssh_program = _PATH_SSH_PROGRAM;

/* This is used to store the pid of ssh_program */
pid_t do_cmd_pid = -1;

static __dead void
killchild(int signo)
{
	if (do_cmd_pid > 1) {
		kill(do_cmd_pid, signo ? signo : SIGTERM);
		waitpid(do_cmd_pid, NULL, 0);
	}

	if (signo)
		_exit(1);
	exit(1);
}

static int
do_local_cmd(arglist *a)
{
	u_int i;
	int status;
	pid_t pid;

	if (a->num == 0)
		fatal("do_local_cmd: no arguments");

	if (verbose_mode) {
		fprintf(stderr, "Executing:");
		for (i = 0; i < a->num; i++)
			fprintf(stderr, " %s", a->list[i]);
		fprintf(stderr, "\n");
	}
	if ((pid = fork()) == -1)
		fatal("do_local_cmd: fork: %s", strerror(errno));

	if (pid == 0) {
		execvp(a->list[0], a->list);
		perror(a->list[0]);
		exit(1);
	}

	do_cmd_pid = pid;
	signal(SIGTERM, killchild);
	signal(SIGINT, killchild);
	signal(SIGHUP, killchild);

	while (waitpid(pid, &status, 0) == -1)
		if (errno != EINTR)
			fatal("do_local_cmd: waitpid: %s", strerror(errno));

	do_cmd_pid = -1;

	if (!WIFEXITED(status) || WEXITSTATUS(status) != 0)
		return (-1);

	return (0);
}

/*
 * This function executes the given command as the specified user on the
 * given host.  This returns < 0 if execution fails, and >= 0 otherwise. This
 * assigns the input and output file descriptors on success.
 */

int
do_cmd(char *host, char *remuser, char *cmd, int *fdin, int *fdout)
{
	int pin[2], pout[2], reserved[2];

	if (verbose_mode)
		fprintf(stderr,
		    "Executing: program %s host %s, user %s, command %s\n",
		    ssh_program, host,
		    remuser ? remuser : "(unspecified)", cmd);

	/*
	 * Reserve two descriptors so that the real pipes won't get
	 * descriptors 0 and 1 because that will screw up dup2 below.
	 */
	if (pipe(reserved) < 0)
		fatal("pipe: %s", strerror(errno));

	/* Create a socket pair for communicating with ssh. */
	if (pipe(pin) < 0)
		fatal("pipe: %s", strerror(errno));
	if (pipe(pout) < 0)
		fatal("pipe: %s", strerror(errno));

	/* Free the reserved descriptors. */
	close(reserved[0]);
	close(reserved[1]);

	/* Fork a child to execute the command on the remote host using ssh. */
	do_cmd_pid = fork();
	if (do_cmd_pid == 0) {
		/* Child. */
		close(pin[1]);
		close(pout[0]);
		dup2(pin[0], 0);
		dup2(pout[1], 1);
		close(pin[0]);
		close(pout[1]);

		replacearg(&args, 0, "%s", ssh_program);
		if (remuser != NULL)
			addargs(&args, "-l%s", remuser);
		addargs(&args, "%s", host);
		addargs(&args, "%s", cmd);

		execvp(ssh_program, args.list);
		perror(ssh_program);
		exit(1);
	} else if (do_cmd_pid == -1) {
		fatal("fork: %s", strerror(errno));
	}
	/* Parent.  Close the other side, and return the local side. */
	close(pin[0]);
	*fdout = pin[1];
	close(pout[1]);
	*fdin = pout[0];
	signal(SIGTERM, killchild);
	signal(SIGINT, killchild);
	signal(SIGHUP, killchild);
	return 0;
}

typedef struct {
	size_t cnt;
	char *buf;
} BUF;

BUF *allocbuf(BUF *, int, int);
static __dead void lostconn(int);
int okname(char *);
static void run_err(const char *,...) __attribute__((__format__(__printf__, 1, 2)));
void verifydir(char *);

struct passwd *pwd;
uid_t userid;
int errs, remin, remout;
int pflag, iamremote, iamrecursive, targetshouldbedirectory;

#define	CMDNEEDS	64
char cmd[CMDNEEDS];		/* must hold "rcp -r -p -d\0" */

int response(void);
void rsource(char *, struct stat *);
void sink(int, char *[]);
void source(int, char *[]);
void tolocal(int, char *[]);
void toremote(char *, int, char *[]);
static __dead void usage(void);

int
main(int argc, char **argv)
{
	int ch, fflag, tflag, status, n;
	double speed;
	char *targ, *endp, **newargv;

	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

	/* Copy argv, because we modify it */
	newargv = xcalloc(MAX(argc + 1, 1), sizeof(*newargv));
	for (n = 0; n < argc; n++)
		newargv[n] = xstrdup(argv[n]);
	argv = newargv;

	memset(&args, '\0', sizeof(args));
	args.list = NULL;
	addargs(&args, "%s", ssh_program);
	addargs(&args, "-x");
	addargs(&args, "-oForwardAgent no");
	addargs(&args, "-oPermitLocalCommand no");
	addargs(&args, "-oClearAllForwardings yes");

	fflag = tflag = 0;
	while ((ch = getopt(argc, argv, "dfl:prtvBCc:i:P:q1246S:o:F:")) != -1)
		switch (ch) {
		/* User-visible flags. */
		case '1':
		case '2':
		case '4':
		case '6':
		case 'C':
			addargs(&args, "-%c", ch);
			break;
		case 'o':
		case 'c':
		case 'i':
		case 'F':
			addargs(&args, "-%c%s", ch, optarg);
			break;
		case 'P':
			addargs(&args, "-p%s", optarg);
			break;
		case 'B':
			addargs(&args, "-oBatchmode yes");
			break;
		case 'l':
			speed = strtod(optarg, &endp);
			if (speed <= 0 || *endp != '\0')
				usage();
			limit_rate = speed * 1024;
			break;
		case 'p':
			pflag = 1;
			break;
		case 'r':
			iamrecursive = 1;
			break;
		case 'S':
			ssh_program = xstrdup(optarg);
			break;
		case 'v':
			addargs(&args, "-v");
			verbose_mode = 1;
			break;
		case 'q':
			addargs(&args, "-q");
			showprogress = 0;
			break;

		/* Server options. */
		case 'd':
			targetshouldbedirectory = 1;
			break;
		case 'f':	/* "from" */
			iamremote = 1;
			fflag = 1;
			break;
		case 't':	/* "to" */
			iamremote = 1;
			tflag = 1;
			break;
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	if ((pwd = getpwuid(userid = getuid())) == NULL)
		fatal("unknown user %u", (u_int) userid);

	if (!isatty(STDOUT_FILENO))
		showprogress = 0;

	remin = STDIN_FILENO;
	remout = STDOUT_FILENO;

	if (fflag) {
		/* Follow "protocol", send data. */
		(void) response();
		source(argc, argv);
		exit(errs != 0);
	}
	if (tflag) {
		/* Receive data. */
		sink(argc, argv);
		exit(errs != 0);
	}
	if (argc < 2)
		usage();
	if (argc > 2)
		targetshouldbedirectory = 1;

	remin = remout = -1;
	do_cmd_pid = -1;
	/* Command to be executed on remote system using "ssh". */
	(void) snprintf(cmd, sizeof cmd, "scp%s%s%s%s",
	    verbose_mode ? " -v" : "",
	    iamrecursive ? " -r" : "", pflag ? " -p" : "",
	    targetshouldbedirectory ? " -d" : "");

	(void) signal(SIGPIPE, lostconn);

	if ((targ = colon(argv[argc - 1])))	/* Dest is remote host. */
		toremote(targ, argc, argv);
	else {
		if (targetshouldbedirectory)
			verifydir(argv[argc - 1]);
		tolocal(argc, argv);	/* Dest is local host. */
	}
	/*
	 * Finally check the exit status of the ssh process, if one was forked
	 * and no error has occurred yet
	 */
	if (do_cmd_pid != -1 && errs == 0) {
		if (remin != -1)
		    (void) close(remin);
		if (remout != -1)
		    (void) close(remout);
		if (waitpid(do_cmd_pid, &status, 0) == -1)
			errs = 1;
		else {
			if (!WIFEXITED(status) || WEXITSTATUS(status) != 0)
				errs = 1;
		}
	}
	exit(errs != 0);
}

/*
 * atomicio-like wrapper that also applies bandwidth limits and updates
 * the progressmeter counter.
 */
static size_t
scpio(ssize_t (*f)(int, void *, size_t), int fd, void *_p, size_t l, off_t *c)
{
	u_char *p = (u_char *)_p;
	size_t offset;
	ssize_t r;
	struct pollfd pfd;

	pfd.fd = fd;
	pfd.events = f == read ? POLLIN : POLLOUT;
	for (offset = 0; offset < l;) {
		r = f(fd, p + offset, l - offset);
		if (r == 0) {
			errno = EPIPE;
			return offset;
		}
		if (r < 0) {
			if (errno == EINTR)
				continue;
			if (errno == EAGAIN) {
				(void)poll(&pfd, 1, -1); /* Ignore errors */
				continue;
			}
			return offset;
		}
		offset += (size_t)r;
		*c += (off_t)r;
		if (limit_rate)
			bwlimit(r);
	}
	return offset;
}

void
toremote(char *targ, int argc, char **argv)
{
	char *bp, *host, *src, *suser, *thost, *tuser, *arg;
	arglist alist;
	int i;

	memset(&alist, '\0', sizeof(alist));
	alist.list = NULL;

	*targ++ = 0;
	if (*targ == 0)
		targ = (char *)".";

	arg = xstrdup(argv[argc - 1]);
	if ((thost = strrchr(arg, '@@'))) {
		/* user@@host */
		*thost++ = 0;
		tuser = arg;
		if (*tuser == '\0')
			tuser = NULL;
	} else {
		thost = arg;
		tuser = NULL;
	}

	if (tuser != NULL && !okname(tuser)) {
		xfree(arg);
		return;
	}

	for (i = 0; i < argc - 1; i++) {
		src = colon(argv[i]);
		if (src) {	/* remote to remote */
			freeargs(&alist);
			addargs(&alist, "%s", ssh_program);
			if (verbose_mode)
				addargs(&alist, "-v");
			addargs(&alist, "-x");
			addargs(&alist, "-oClearAllForwardings yes");
			addargs(&alist, "-n");

			*src++ = 0;
			if (*src == 0)
				src = (char *)".";
			host = strrchr(argv[i], '@@');

			if (host) {
				*host++ = 0;
				host = cleanhostname(host);
				suser = argv[i];
				if (*suser == '\0')
					suser = pwd->pw_name;
				else if (!okname(suser))
					continue;
				addargs(&alist, "-l");
				addargs(&alist, "%s", suser);
			} else {
				host = cleanhostname(argv[i]);
			}
			addargs(&alist, "%s", host);
			addargs(&alist, "%s", cmd);
			addargs(&alist, "%s", src);
			addargs(&alist, "%s%s%s:%s",
			    tuser ? tuser : "", tuser ? "@@" : "",
			    thost, targ);
			if (do_local_cmd(&alist) != 0)
				errs = 1;
		} else {	/* local to remote */
			if (remin == -1) {
				xasprintf(&bp, "%s -t %s", cmd, targ);
				host = cleanhostname(thost);
				if (do_cmd(host, tuser, bp, &remin,
				    &remout) < 0)
					exit(1);
				if (response() < 0)
					exit(1);
				(void) xfree(bp);
			}
			source(1, argv + i);
		}
	}
	xfree(arg);
}

void
tolocal(int argc, char **argv)
{
	char *bp, *host, *src, *suser;
	arglist alist;
	int i;

	memset(&alist, '\0', sizeof(alist));
	alist.list = NULL;

	for (i = 0; i < argc - 1; i++) {
		if (!(src = colon(argv[i]))) {	/* Local to local. */
			freeargs(&alist);
			addargs(&alist, "%s", _PATH_CP);
			if (iamrecursive)
				addargs(&alist, "-r");
			if (pflag)
				addargs(&alist, "-p");
			addargs(&alist, "%s", argv[i]);
			addargs(&alist, "%s", argv[argc-1]);
			if (do_local_cmd(&alist))
				++errs;
			continue;
		}
		*src++ = 0;
		if (*src == 0)
			src = (char *)".";
		if ((host = strrchr(argv[i], '@@')) == NULL) {
			host = argv[i];
			suser = NULL;
		} else {
			*host++ = 0;
			suser = argv[i];
			if (*suser == '\0')
				suser = pwd->pw_name;
		}
		host = cleanhostname(host);
		xasprintf(&bp, "%s -f %s", cmd, src);
		if (do_cmd(host, suser, bp, &remin, &remout) < 0) {
			(void) xfree(bp);
			++errs;
			continue;
		}
		xfree(bp);
		sink(1, argv + argc - 1);
		(void) close(remin);
		remin = remout = -1;
	}
}

void
source(int argc, char **argv)
{
	struct stat stb;
	static BUF buffer;
	BUF *bp;
	off_t i, statbytes;
	size_t amt;
	int fd = -1, haderr, indx;
	char *last, *name, buf[2048], encname[MAXPATHLEN];
	int len;

	for (indx = 0; indx < argc; ++indx) {
		name = argv[indx];
		statbytes = 0;
		len = strlen(name);
		while (len > 1 && name[len-1] == '/')
			name[--len] = '\0';
		if ((fd = open(name, O_RDONLY|O_NONBLOCK, 0)) < 0)
			goto syserr;
		if (strchr(name, '\n') != NULL) {
			strnvis(encname, name, sizeof(encname), VIS_NL);
			name = encname;
		}
		if (fstat(fd, &stb) < 0) {
syserr:			run_err("%s: %s", name, strerror(errno));
			goto next;
		}
		if (stb.st_size < 0) {
			run_err("%s: %s", name, "Negative file size");
			goto next;
		}
		unset_nonblock(fd);
		switch (stb.st_mode & S_IFMT) {
		case S_IFREG:
			break;
		case S_IFDIR:
			if (iamrecursive) {
				rsource(name, &stb);
				goto next;
			}
			/* FALLTHROUGH */
		default:
			run_err("%s: not a regular file", name);
			goto next;
		}
		if ((last = strrchr(name, '/')) == NULL)
			last = name;
		else
			++last;
		curfile = last;
		if (pflag) {
			/*
			 * Make it compatible with possible future
			 * versions expecting microseconds.
			 */
			(void) snprintf(buf, sizeof buf, "T%lu 0 %lu 0\n",
			    (u_long) (stb.st_mtime < 0 ? 0 : stb.st_mtime),
			    (u_long) (stb.st_atime < 0 ? 0 : stb.st_atime));
			if (verbose_mode) {
				fprintf(stderr, "File mtime %ld atime %ld\n",
				    (long)stb.st_mtime, (long)stb.st_atime);
				fprintf(stderr, "Sending file timestamps: %s",
				    buf);
			}
			(void) atomicio(vwrite, remout, buf, strlen(buf));
			if (response() < 0)
				goto next;
		}
#define	FILEMODEMASK	(S_ISUID|S_ISGID|S_IRWXU|S_IRWXG|S_IRWXO)
		snprintf(buf, sizeof buf, "C%04o %lld %s\n",
		    (u_int) (stb.st_mode & FILEMODEMASK),
		    (long long)stb.st_size, last);
		if (verbose_mode) {
			fprintf(stderr, "Sending file modes: %s", buf);
		}
		(void) atomicio(vwrite, remout, buf, strlen(buf));
		if (response() < 0)
			goto next;
		if ((bp = allocbuf(&buffer, fd, COPY_BUFLEN)) == NULL) {
next:			if (fd != -1) {
				(void) close(fd);
				fd = -1;
			}
			continue;
		}
		if (showprogress)
			start_progress_meter(curfile, stb.st_size, &statbytes);
		set_nonblock(remout);
		for (haderr = i = 0; i < stb.st_size; i += bp->cnt) {
			amt = bp->cnt;
			if (i + (off_t)amt > stb.st_size)
				amt = stb.st_size - i;
			if (!haderr) {
				if (atomicio(read, fd, bp->buf, amt) != amt)
					haderr = errno;
			}
			/* Keep writing after error to retain sync */
			if (haderr) {
				(void)atomicio(vwrite, remout, bp->buf, amt);
				continue;
			}
			if (scpio(vwrite, remout, bp->buf, amt,
			    &statbytes) != amt)
				haderr = errno;
		}
		unset_nonblock(remout);
		if (showprogress)
			stop_progress_meter();

		if (fd != -1) {
			if (close(fd) < 0 && !haderr)
				haderr = errno;
			fd = -1;
		}
		if (!haderr)
			(void) atomicio(vwrite, remout, (char *)"", 1);
		else
			run_err("%s: %s", name, strerror(haderr));
		(void) response();
	}
}

void
rsource(char *name, struct stat *statp)
{
	DIR *dirp;
	struct dirent *dp;
	char *last, *vect[1], path[1100];

	if (!(dirp = opendir(name))) {
		run_err("%s: %s", name, strerror(errno));
		return;
	}
	last = strrchr(name, '/');
	if (last == 0)
		last = name;
	else
		last++;
	if (pflag) {
		(void) snprintf(path, sizeof(path), "T%lu 0 %lu 0\n",
		    (u_long) statp->st_mtime,
		    (u_long) statp->st_atime);
		(void) atomicio(vwrite, remout, path, strlen(path));
		if (response() < 0) {
			closedir(dirp);
			return;
		}
	}
	(void) snprintf(path, sizeof path, "D%04o %d %.1024s\n",
	    (u_int) (statp->st_mode & FILEMODEMASK), 0, last);
	if (verbose_mode)
		fprintf(stderr, "Entering directory: %s", path);
	(void) atomicio(vwrite, remout, path, strlen(path));
	if (response() < 0) {
		closedir(dirp);
		return;
	}
	while ((dp = readdir(dirp)) != NULL) {
		if (dp->d_ino == 0)
			continue;
		if (!strcmp(dp->d_name, ".") || !strcmp(dp->d_name, ".."))
			continue;
		if (strlen(name) + 1 + strlen(dp->d_name) >= sizeof(path) - 1) {
			run_err("%s/%s: name too long", name, dp->d_name);
			continue;
		}
		(void) snprintf(path, sizeof path, "%s/%s", name, dp->d_name);
		vect[0] = path;
		source(1, vect);
	}
	(void) closedir(dirp);
	(void) atomicio(vwrite, remout, (char *)"E\n", 2);
	(void) response();
}

void
bwlimit(int amount)
{
	static struct timeval bwstart, bwend;
	static int lamt, thresh = 16384;
	u_int64_t waitlen;
	struct timespec ts, rm;

	if (!timerisset(&bwstart)) {
		gettimeofday(&bwstart, NULL);
		return;
	}

	lamt += amount;
	if (lamt < thresh)
		return;

	gettimeofday(&bwend, NULL);
	timersub(&bwend, &bwstart, &bwend);
	if (!timerisset(&bwend))
		return;

	lamt *= 8;
	waitlen = (double)1000000L * lamt / limit_rate;

	bwstart.tv_sec = waitlen / 1000000L;
	bwstart.tv_usec = waitlen % 1000000L;

	if (timercmp(&bwstart, &bwend, >)) {
		timersub(&bwstart, &bwend, &bwend);

		/* Adjust the wait time */
		if (bwend.tv_sec) {
			thresh /= 2;
			if (thresh < 2048)
				thresh = 2048;
		} else if (bwend.tv_usec < 10000) {
			thresh *= 2;
			if (thresh > COPY_BUFLEN * 4)
				thresh = COPY_BUFLEN * 4;
		}

		TIMEVAL_TO_TIMESPEC(&bwend, &ts);
		while (nanosleep(&ts, &rm) == -1) {
			if (errno != EINTR)
				break;
			ts = rm;
		}
	}

	lamt = 0;
	gettimeofday(&bwstart, NULL);
}

void
sink(int argc, char **argv)
{
	static BUF buffer;
	struct stat stb;
	enum {
		YES, NO, DISPLAYED
	} wrerr;
	BUF *bp;
	off_t i;
	size_t j, count;
	int amt, exists, first, ofd;
	mode_t mode, omode, mask;
	off_t size, statbytes;
	int setimes, targisdir, wrerrno = 0;
	char ch, *cp, *np, *targ, *vect[1], buf[2048];
	const char *why;
	struct timeval tv[2];

#define	atime	tv[0]
#define	mtime	tv[1]
#define	SCREWUP(str)	{ why = str; goto screwup; }

	setimes = targisdir = 0;
	mask = umask(0);
	if (!pflag)
		(void) umask(mask);
	if (argc != 1) {
		run_err("ambiguous target");
		exit(1);
	}
	targ = *argv;
	if (targetshouldbedirectory)
		verifydir(targ);

	(void) atomicio(vwrite, remout, (char *)"", 1);
	if (stat(targ, &stb) == 0 && S_ISDIR(stb.st_mode))
		targisdir = 1;
	for (first = 1;; first = 0) {
		cp = buf;
		if (atomicio(read, remin, cp, 1) != 1)
			return;
		if (*cp++ == '\n')
			SCREWUP("unexpected <newline>");
		do {
			if (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))
				SCREWUP("lost connection");
			*cp++ = ch;
		} while (cp < &buf[sizeof(buf) - 1] && ch != '\n');
		*cp = 0;
		if (verbose_mode)
			fprintf(stderr, "Sink: %s", buf);

		if (buf[0] == '\01' || buf[0] == '\02') {
			if (iamremote == 0)
				(void) atomicio(vwrite, STDERR_FILENO,
				    buf + 1, strlen(buf + 1));
			if (buf[0] == '\02')
				exit(1);
			++errs;
			continue;
		}
		if (buf[0] == 'E') {
			(void) atomicio(vwrite, remout, (char *)"", 1);
			return;
		}
		if (ch == '\n')
			*--cp = 0;

		cp = buf;
		if (*cp == 'T') {
			setimes++;
			cp++;
			mtime.tv_sec = strtol(cp, &cp, 10);
			if (!cp || *cp++ != ' ')
				SCREWUP("mtime.sec not delimited");
			mtime.tv_usec = strtol(cp, &cp, 10);
			if (!cp || *cp++ != ' ')
				SCREWUP("mtime.usec not delimited");
			atime.tv_sec = strtol(cp, &cp, 10);
			if (!cp || *cp++ != ' ')
				SCREWUP("atime.sec not delimited");
			atime.tv_usec = strtol(cp, &cp, 10);
			if (!cp || *cp++ != '\0')
				SCREWUP("atime.usec not delimited");
			(void) atomicio(vwrite, remout, (char *)"", 1);
			continue;
		}
		if (*cp != 'C' && *cp != 'D') {
			/*
			 * Check for the case "rcp remote:foo\* local:bar".
			 * In this case, the line "No match." can be returned
			 * by the shell before the rcp command on the remote is
			 * executed so the ^Aerror_message convention isn't
			 * followed.
			 */
			if (first) {
				run_err("%s", cp);
				exit(1);
			}
			SCREWUP("expected control record");
		}
		mode = 0;
		for (++cp; cp < buf + 5; cp++) {
			if (*cp < '0' || *cp > '7')
				SCREWUP("bad mode");
			mode = (mode << 3) | (*cp - '0');
		}
		if (*cp++ != ' ')
			SCREWUP("mode not delimited");

		for (size = 0; isdigit(*cp);)
			size = size * 10 + (*cp++ - '0');
		if (*cp++ != ' ')
			SCREWUP("size not delimited");
		if ((strchr(cp, '/') != NULL) || (strcmp(cp, "..") == 0)) {
			run_err("error: unexpected filename: %s", cp);
			exit(1);
		}
		if (targisdir) {
			static char *namebuf;
			static size_t cursize;
			size_t need;

			need = strlen(targ) + strlen(cp) + 250;
			if (need > cursize) {
				if (namebuf)
					xfree(namebuf);
				namebuf = xmalloc(need);
				cursize = need;
			}
			(void) snprintf(namebuf, need, "%s%s%s", targ,
			    strcmp(targ, "/") ? "/" : "", cp);
			np = namebuf;
		} else
			np = targ;
		curfile = cp;
		exists = stat(np, &stb) == 0;
		if (buf[0] == 'D') {
			int mod_flag = pflag;
			if (!iamrecursive)
				SCREWUP("received directory without -r");
			if (exists) {
				if (!S_ISDIR(stb.st_mode)) {
					errno = ENOTDIR;
					goto bad;
				}
				if (pflag)
					(void) chmod(np, mode);
			} else {
				/* Handle copying from a read-only
				   directory */
				mod_flag = 1;
				if (mkdir(np, mode | S_IRWXU) < 0)
					goto bad;
			}
			vect[0] = xstrdup(np);
			sink(1, vect);
			if (setimes) {
				setimes = 0;
				if (utimes(vect[0], tv) < 0)
					run_err("%s: set times: %s",
					    vect[0], strerror(errno));
			}
			if (mod_flag)
				(void) chmod(vect[0], mode);
			if (vect[0])
				xfree(vect[0]);
			continue;
		}
		omode = mode;
		mode |= S_IWRITE;
		if ((ofd = open(np, O_WRONLY|O_CREAT, mode)) < 0) {
bad:			run_err("%s: %s", np, strerror(errno));
			continue;
		}
		(void) atomicio(vwrite, remout, (char *)"", 1);
		if ((bp = allocbuf(&buffer, ofd, COPY_BUFLEN)) == NULL) {
			(void) close(ofd);
			continue;
		}
		cp = bp->buf;
		wrerr = NO;

		statbytes = 0;
		if (showprogress)
			start_progress_meter(curfile, size, &statbytes);
		set_nonblock(remin);
		for (count = i = 0; i < size; i += bp->cnt) {
			amt = bp->cnt;
			if (i + amt > size)
				amt = size - i;
			count += amt;
			do {
				j = scpio(read, remin, cp, amt, &statbytes);
				if (j == 0) {
					run_err("%s", j != EPIPE ?
					    strerror(errno) :
					    "dropped connection");
					exit(1);
				}
				amt -= j;
				cp += j;
			} while (amt > 0);

			if (count == bp->cnt) {
				/* Keep reading so we stay sync'd up. */
				if (wrerr == NO) {
					if (atomicio(vwrite, ofd, bp->buf,
					    count) != count) {
						wrerr = YES;
						wrerrno = errno;
					}
				}
				count = 0;
				cp = bp->buf;
			}
		}
		unset_nonblock(remin);
		if (showprogress)
			stop_progress_meter();
		if (count != 0 && wrerr == NO &&
		    atomicio(vwrite, ofd, bp->buf, count) != count) {
			wrerr = YES;
			wrerrno = errno;
		}
		if (wrerr == NO && (!exists || S_ISREG(stb.st_mode)) &&
		    ftruncate(ofd, size) != 0) {
			run_err("%s: truncate: %s", np, strerror(errno));
			wrerr = DISPLAYED;
		}
		if (pflag) {
			if (exists || omode != mode)
				if (fchmod(ofd, omode)) {
					run_err("%s: set mode: %s",
					    np, strerror(errno));
					wrerr = DISPLAYED;
				}
		} else {
			if (!exists && omode != mode)
				if (fchmod(ofd, omode & ~mask)) {
					run_err("%s: set mode: %s",
					    np, strerror(errno));
					wrerr = DISPLAYED;
				}
		}
		if (close(ofd) == -1) {
			wrerr = YES;
			wrerrno = errno;
		}
		(void) response();
		if (setimes && wrerr == NO) {
			setimes = 0;
			if (utimes(np, tv) < 0) {
				run_err("%s: set times: %s",
				    np, strerror(errno));
				wrerr = DISPLAYED;
			}
		}
		switch (wrerr) {
		case YES:
			run_err("%s: %s", np, strerror(wrerrno));
			break;
		case NO:
			(void) atomicio(vwrite, remout, (char *)"", 1);
			break;
		case DISPLAYED:
			break;
		}
	}
screwup:
	run_err("protocol error: %s", why);
	exit(1);
}

int
response(void)
{
	char ch, *cp, resp, rbuf[2048];

	if (atomicio(read, remin, &resp, sizeof(resp)) != sizeof(resp))
		lostconn(0);

	cp = rbuf;
	switch (resp) {
	case 0:		/* ok */
		return (0);
	default:
		*cp++ = resp;
		/* FALLTHROUGH */
	case 1:		/* error, followed by error msg */
	case 2:		/* fatal error, "" */
		do {
			if (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))
				lostconn(0);
			*cp++ = ch;
		} while (cp < &rbuf[sizeof(rbuf) - 1] && ch != '\n');

		if (!iamremote)
			(void) atomicio(vwrite, STDERR_FILENO, rbuf, cp - rbuf);
		++errs;
		if (resp == 1)
			return (-1);
		exit(1);
	}
	/* NOTREACHED */
}

void
usage(void)
{
	(void) fprintf(stderr,
	    "usage: scp [-1246BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]\n"
	    "           [-l limit] [-o ssh_option] [-P port] [-S program]\n"
	    "           [[user@@]host1:]file1 ... [[user@@]host2:]file2\n");
	exit(1);
}

static void
run_err(const char *fmt,...)
{
	static FILE *fp;
	va_list ap;

	++errs;
	if (fp != NULL || (remout != -1 && (fp = fdopen(remout, "w")))) {
		(void) fprintf(fp, "%c", 0x01);
		(void) fprintf(fp, "scp: ");
		va_start(ap, fmt);
		(void) vfprintf(fp, fmt, ap);
		va_end(ap);
		(void) fprintf(fp, "\n");
		(void) fflush(fp);
	}

	if (!iamremote) {
		va_start(ap, fmt);
		vfprintf(stderr, fmt, ap);
		va_end(ap);
		fprintf(stderr, "\n");
	}
}

void
verifydir(char *cp)
{
	struct stat stb;

	if (!stat(cp, &stb)) {
		if (S_ISDIR(stb.st_mode))
			return;
		errno = ENOTDIR;
	}
	run_err("%s: %s", cp, strerror(errno));
	killchild(0);
}

int
okname(char *cp0)
{
	int c;
	char *cp;

	cp = cp0;
	do {
		c = (int)*cp;
		if (c & 0200)
			goto bad;
		if (!isalpha(c) && !isdigit(c)) {
			switch (c) {
			case '\'':
			case '"':
			case '`':
			case ' ':
			case '#':
				goto bad;
			default:
				break;
			}
		}
	} while (*++cp);
	return (1);

bad:	fprintf(stderr, "%s: invalid user name\n", cp0);
	return (0);
}

BUF *
allocbuf(BUF *bp, int fd, int blksize)
{
	size_t size;
	struct stat stb;

	if (fstat(fd, &stb) < 0) {
		run_err("fstat: %s", strerror(errno));
		return (0);
	}
	size = roundup(stb.st_blksize, blksize);
	if (size == 0)
		size = blksize;
	if (bp->cnt >= size)
		return (bp);
	if (bp->buf == NULL)
		bp->buf = xmalloc(size);
	else
		bp->buf = xrealloc(bp->buf, 1, size);
	memset(bp->buf, 0, size);
	bp->cnt = size;
	return (bp);
}

void
lostconn(int signo)
{
	if (!iamremote)
		write(STDERR_FILENO, "lost connection\n", 16);
	if (signo)
		_exit(1);
	else
		exit(1);
}
@


1.19
log
@• merge newer OpenSSH
• KNF in our diff – style(9)
• some const cleanliness (build with __CRAZY=Yes mostly)
@
text
@d18 2
d104 1
a104 1
__RCSID("$MirOS: src/usr.bin/ssh/scp.c,v 1.18 2008/12/27 21:17:56 tg Exp $");
d264 1
a264 1
static void run_err(const char *,...) __attribute__((format (printf, 1, 2)));
@


1.18
log
@merge and wrap exec/exit functions better
@
text
@d102 1
a102 1
__RCSID("$MirOS: src/usr.bin/ssh/scp.c,v 1.17 2008/12/16 22:13:28 tg Exp $");
d126 1
a126 1
char *ssh_program = _PATH_SSH_PROGRAM;
d131 1
a131 1
static void
d260 1
a260 1
void lostconn(int);
d262 1
a262 1
void run_err(const char *,...);
d279 1
a279 1
void usage(void);
a286 2
	extern char *optarg;
	extern int optind;
d480 1
a480 1
		targ = ".";
d512 1
a512 1
				src = ".";
d579 1
a579 1
			src = ".";
d719 1
a719 1
			(void) atomicio(vwrite, remout, "", 1);
d775 1
a775 1
	(void) atomicio(vwrite, remout, "E\n", 2);
d848 2
a849 1
	char ch, *cp, *np, *targ, *why, *vect[1], buf[2048];
d868 1
a868 1
	(void) atomicio(vwrite, remout, "", 1);
d896 1
a896 1
			(void) atomicio(vwrite, remout, "", 1);
d918 1
a918 1
			(void) atomicio(vwrite, remout, "", 1);
d1009 1
a1009 1
		(void) atomicio(vwrite, remout, "", 1);
d1097 1
a1097 1
			(void) atomicio(vwrite, remout, "", 1);
d1151 1
a1151 1
void
@


1.17
log
@really merge OpenSSH-current into MirBSD Secure SHell 10uA4
@
text
@d102 1
a102 1
__RCSID("$MirOS: src/usr.bin/ssh/scp.c,v 1.16 2008/12/16 20:55:25 tg Exp $");
a163 1
		arc4_preexec();
a236 1
		arc4_preexec();
@


1.16
log
@fastmerge, do not use yet!
@
text
@d102 1
a102 1
__RCSID("$MirOS: src/usr.bin/ssh/scp.c,v 1.15 2008/03/02 21:14:20 tg Exp $");
d164 1
d238 1
@


1.15
log
@merge’n’fix
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.162 2008/01/01 09:06:39 dtucker Exp $ */
d102 1
a102 1
__RCSID("$MirOS: src/usr.bin/ssh/scp.c,v 1.14 2007/08/20 12:11:30 tg Exp $");
d416 1
a416 1
	 * and no error has occured yet
d611 2
a612 1
	off_t i, amt, statbytes;
d633 4
d696 1
a696 1
			if (i + amt > stb.st_size)
@


1.14
log
@MirBSD SecureShell 4.7/#10semel
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.160 2007/08/06 19:16:06 sobrado Exp $ */
d75 1
d102 3
a104 1
__RCSID("$MirOS: src/usr.bin/ssh/scp.c,v 1.13 2007/06/16 15:41:51 tg Exp $");
d433 37
a611 1
	size_t result;
d657 8
a664 2
			    (u_long) stb.st_mtime,
			    (u_long) stb.st_atime);
d679 1
a679 1
		if ((bp = allocbuf(&buffer, fd, 2048)) == NULL) {
d688 1
a688 1
		/* Keep writing after an error so that we stay sync'd up. */
d694 1
a694 2
				result = atomicio(read, fd, bp->buf, amt);
				if (result != amt)
d697 4
a700 7
			if (haderr)
				(void) atomicio(vwrite, remout, bp->buf, amt);
			else {
				result = atomicio(vwrite, remout, bp->buf, amt);
				if (result != amt)
					haderr = errno;
				statbytes += result;
d702 3
a704 2
			if (limit_rate)
				bwlimit(amt);
d706 1
d812 1
a812 1
		} else if (bwend.tv_usec < 100) {
d814 2
a815 2
			if (thresh > 32768)
				thresh = 32768;
d1006 1
a1006 1
		if ((bp = allocbuf(&buffer, ofd, 4096)) == NULL) {
d1016 3
a1018 2
		for (count = i = 0; i < size; i += 4096) {
			amt = 4096;
d1023 1
a1023 1
				j = atomicio(read, remin, cp, amt);
d1025 2
a1026 1
					run_err("%s", j ? strerror(errno) :
a1031 1
				statbytes += j;
a1033 3
			if (limit_rate)
				bwlimit(4096);

d1047 1
@


1.13
log
@sync’n’bump
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.159 2007/06/13 00:21:27 djm Exp $ */
d101 1
a101 1
__RCSID("$MirOS: src/usr.bin/ssh/scp.c,v 1.12 2007/01/25 16:18:36 tg Exp $");
d1101 1
a1101 1
	    "           [[user@@]host1:]file1 [...] [[user@@]host2:]file2\n");
@


1.12
log
@automerge, bump vsn
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.156 2007/01/22 13:06:21 djm Exp $ */
d92 1
d101 1
a101 1
__RCSID("$MirOS: src/usr.bin/ssh/scp.c,v 1.11 2006/09/20 21:41:01 tg Exp $");
d574 1
a574 1
	char *last, *name, buf[2048];
d583 2
d586 2
a587 3
			run_err("%s: skipping, filename contains a newline",
			    name);
			goto next;
a588 2
		if ((fd = open(name, O_RDONLY, 0)) < 0)
			goto syserr;
d593 1
d1013 2
a1014 1
		if (wrerr == NO && ftruncate(ofd, size) != 0) {
@


1.11
log
@finish merging
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.155 2006/08/03 03:34:42 deraadt Exp $ */
d100 1
a100 1
__RCSID("$MirOS$");
d371 1
a371 1
	if (!isatty(STDERR_FILENO))
@


1.10
log
@scp and sftp already disable tty allocation,
so no explicit setting of IPTOS_THROUGHPUT is
required any more
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.142 2006/05/17 12:43:34 markus Exp $ */
d74 1
a74 3
#include "includes.h"
__RCSID("$MirOS: src/usr.bin/ssh/scp.c,v 1.9 2006/06/02 20:50:48 tg Exp $");

d77 2
d82 3
d86 6
d100 2
d280 1
a280 1
	int ch, fflag, tflag, status;
d282 1
a282 1
	char *targ, *endp;
d289 6
@


1.9
log
@* merge
* remove all references to GSSAPI, Kerberos and AFS
* uint*_t -> u_int*_t for consistency, like openbsd
  (note: MirOS style(9) suggests uint32_t etc. instead!)
* bump vsn
@
text
@d75 1
a75 1
__RCSID("$MirOS: src/usr.bin/ssh/scp.c,v 1.8 2006/04/19 10:40:51 tg Exp $");
a281 1
	addargs(&args, "-h");		/* disable tcp lowdelay */
@


1.8
log
@merge and clean up
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.141 2006/04/01 05:50:29 djm Exp $ */
d75 1
a75 1
__RCSID("$MirOS: src/usr.bin/ssh/scp.c,v 1.7 2006/02/22 01:23:50 tg Exp $");
d192 2
a193 1
	pipe(reserved);
d495 1
@


1.7
log
@merge; bump version; fix up manpages and includes a little
@
text
@d1 1
a1 2
/* $MirOS: src/usr.bin/ssh/scp.c,v 1.6 2005/12/20 19:57:33 tg Exp $ */

d75 1
a75 1
RCSID("$MirOS: src/usr.bin/ssh/scp.c,v 1.6 2005/12/20 19:57:33 tg Exp $");
d80 1
d91 1
a91 1
int do_cmd(char *host, char *remuser, char *cmd, int *fdin, int *fdout, int argc);
d178 1
a178 1
do_cmd(char *host, char *remuser, char *cmd, int *fdin, int *fdout, int argc)
a244 1
void nospace(void);
a414 1
	int i, len;
d417 1
d482 1
a482 3
				len = strlen(targ) + CMDNEEDS + 20;
				bp = xmalloc(len);
				(void) snprintf(bp, len, "%s -t %s", cmd, targ);
d485 1
a485 1
				    &remout, argc) < 0)
a498 1
	int i, len;
d501 1
d533 2
a534 4
		len = strlen(src) + CMDNEEDS + 20;
		bp = xmalloc(len);
		(void) snprintf(bp, len, "%s -f %s", cmd, src);
		if (do_cmd(host, suser, bp, &remin, &remout, argc) < 0) {
d779 2
a780 1
	int amt, exists, first, mask, mode, ofd, omode;
d1092 9
a1100 9
	if (fp == NULL && !(fp = fdopen(remout, "w")))
		return;
	(void) fprintf(fp, "%c", 0x01);
	(void) fprintf(fp, "scp: ");
	va_start(ap, fmt);
	(void) vfprintf(fp, fmt, ap);
	va_end(ap);
	(void) fprintf(fp, "\n");
	(void) fflush(fp);
d1172 1
a1172 1
		bp->buf = xrealloc(bp->buf, size);
@


1.6
log
@fastmerge, bump version
@
text
@d1 1
a1 1
/* $MirOS: src/usr.bin/ssh/scp.c,v 1.5 2005/11/23 19:45:14 tg Exp $ */
d76 7
a82 1
RCSID("$MirOS: src/usr.bin/ssh/scp.c,v 1.5 2005/11/23 19:45:14 tg Exp $");
d129 42
d215 1
a215 1
		args.list[0] = ssh_program;
d278 1
d280 1
a280 1
	addargs(&args, "ssh");		/* overwritten with ssh_program */
a389 1
		tolocal(argc, argv);	/* Dest is local host. */
d392 1
d418 4
d439 5
d447 8
a454 2
			static char *ssh_options =
			    "-x -o'ClearAllForwardings yes'";
d459 1
a459 5
			len = strlen(ssh_program) + strlen(argv[i]) +
			    strlen(src) + (tuser ? strlen(tuser) : 0) +
			    strlen(thost) + strlen(targ) +
			    strlen(ssh_options) + CMDNEEDS + 20;
			bp = xmalloc(len);
d466 1
a466 6
				else if (!okname(suser)) {
					xfree(bp);
					continue;
				}
				if (tuser && !okname(tuser)) {
					xfree(bp);
d468 2
a469 8
				}
				snprintf(bp, len,
				    "%s%s %s -n "
				    "-l %s %s %s %s '%s%s%s:%s'",
				    ssh_program, verbose_mode ? " -v" : "",
				    ssh_options, suser, host, cmd, src,
				    tuser ? tuser : "", tuser ? "@@" : "",
				    thost, targ);
a471 7
				snprintf(bp, len,
				    "exec %s%s %s -n %s "
				    "%s %s '%s%s%s:%s'",
				    ssh_program, verbose_mode ? " -v" : "",
				    ssh_options, host, cmd, src,
				    tuser ? tuser : "", tuser ? "@@" : "",
				    thost, targ);
d473 7
a479 3
			if (verbose_mode)
				fprintf(stderr, "Executing: %s\n", bp);
			if (system(bp) != 0)
a480 1
			(void) xfree(bp);
d504 4
d511 9
a519 9
			len = strlen(_PATH_CP) + strlen(argv[i]) +
			    strlen(argv[argc - 1]) + 20;
			bp = xmalloc(len);
			(void) snprintf(bp, len, "exec %s%s%s %s %s", _PATH_CP,
			    iamrecursive ? " -r" : "", pflag ? " -p" : "",
			    argv[i], argv[argc - 1]);
			if (verbose_mode)
				fprintf(stderr, "Executing: %s\n", bp);
			if (system(bp))
a520 1
			(void) xfree(bp);
@


1.5
log
@merge
@
text
@d1 1
a1 1
/* $MirOS: src/usr.bin/ssh/scp.c,v 1.4 2005/06/22 16:11:39 tg Exp $ */
d76 1
a76 1
RCSID("$MirOS: src/usr.bin/ssh/scp.c,v 1.4 2005/06/22 16:11:39 tg Exp $");
d235 1
@


1.4
log
@merge
@
text
@d1 1
a1 1
/* $MirOS: src/usr.bin/ssh/scp.c,v 1.3 2005/04/14 19:49:34 tg Exp $ */
d76 1
a76 1
RCSID("$MirOS: src/usr.bin/ssh/scp.c,v 1.3 2005/04/14 19:49:34 tg Exp $");
d227 3
d572 4
a575 1
next:			(void) close(fd);
d604 5
a608 2
		if (close(fd) < 0 && !haderr)
			haderr = errno;
@


1.3
log
@merge
@
text
@d1 1
a1 1
/* $MirOS: src/usr.bin/ssh/scp.c,v 1.2 2005/03/13 18:33:30 tg Exp $ */
d76 1
a76 1
RCSID("$MirOS: src/usr.bin/ssh/scp.c,v 1.2 2005/03/13 18:33:30 tg Exp $");
d114 1
a114 1
		kill(do_cmd_pid, signo);
d118 3
a120 1
	_exit(1);
d191 1
a191 1
	int cnt;
d505 2
a506 1
	off_t i, amt, result, statbytes;
d582 1
a582 1
					haderr = result >= 0 ? EIO : errno;
d589 1
a589 1
					haderr = result >= 0 ? EIO : errno;
d724 3
a726 2
	off_t i, j;
	int amt, count, exists, first, mask, mode, ofd, omode;
d753 1
a753 1
		if (atomicio(read, remin, cp, 1) <= 0)
d834 1
a834 1
			static int cursize;
d907 1
a907 1
				if (j <= 0) {
d923 2
a924 2
					j = atomicio(vwrite, ofd, bp->buf, count);
					if (j != count) {
d926 1
a926 1
						wrerrno = j >= 0 ? EIO : errno;
d936 1
a936 1
		    (j = atomicio(vwrite, ofd, bp->buf, count)) != count) {
d938 1
a938 1
			wrerrno = j >= 0 ? EIO : errno;
d1067 1
a1067 1
	exit(1);
@


1.2
log
@merge src/usr.bin
@
text
@d1 1
a1 1
/* $MirOS$ */
d76 1
a76 1
RCSID("$MirOS$");
d362 1
a362 1
	char *bp, *host, *src, *suser, *thost, *tuser;
d368 2
a369 1
	if ((thost = strrchr(argv[argc - 1], '@@'))) {
d372 1
a372 1
		tuser = argv[argc - 1];
d376 1
a376 1
		thost = argv[argc - 1];
@


1.1
log
@Initial revision
@
text
@d1 2
d76 1
a76 1
RCSID("$OpenBSD: scp.c,v 1.119 2005/01/24 10:22:06 dtucker Exp $");
d228 1
d503 1
a503 1
	int fd, haderr, indx;
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@OpenSSH-current
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.121 2005/04/02 12:41:16 djm Exp $");
d359 1
a359 1
	char *bp, *host, *src, *suser, *thost, *tuser, *arg;
d365 1
a365 2
	arg = xstrdup(argv[argc - 1]);
	if ((thost = strrchr(arg, '@@'))) {
d368 1
a368 1
		tuser = arg;
d372 1
a372 1
		thost = arg;
@


1.1.1.3
log
@most current OpenSSH.com
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.124 2005/06/17 02:44:33 djm Exp $");
d112 1
a112 1
		kill(do_cmd_pid, signo ? signo : SIGTERM);
d116 1
a116 3
	if (signo)
		_exit(1);
	exit(1);
d187 1
a187 1
	size_t cnt;
d500 1
a500 2
	off_t i, amt, statbytes;
	size_t result;
d576 1
a576 1
					haderr = errno;
d583 1
a583 1
					haderr = errno;
d718 2
a719 3
	off_t i;
	size_t j, count;
	int amt, exists, first, mask, mode, ofd, omode;
d746 1
a746 1
		if (atomicio(read, remin, cp, 1) != 1)
d827 1
a827 1
			static size_t cursize;
d900 1
a900 1
				if (j == 0) {
d916 2
a917 2
					if (atomicio(vwrite, ofd, bp->buf,
					    count) != count) {
d919 1
a919 1
						wrerrno = errno;
d929 1
a929 1
		    atomicio(vwrite, ofd, bp->buf, count) != count) {
d931 1
a931 1
			wrerrno = errno;
d1060 1
a1060 1
	killchild(0);
@


1.1.1.4
log
@Import current OpenSSH
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.127 2005/11/12 18:38:15 deraadt Exp $");
a224 3
	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

d504 1
a504 1
	int fd = -1, haderr, indx;
d566 1
a566 4
next:			if (fd != -1) {
				(void) close(fd);
				fd = -1;
			}
d595 2
a596 5
		if (fd != -1) {
			if (close(fd) < 0 && !haderr)
				haderr = errno;
			fd = -1;
		}
@


1.1.1.5
log
@OpenSSH is the last missing piece to update before the release
@
text
@d74 1
a74 1
RCSID("$OpenBSD: scp.c,v 1.128 2005/12/06 22:38:27 reyk Exp $");
a231 1
	addargs(&args, "-oPermitLocalCommand no");
@


1.1.1.6
log
@import OpenSSH-current
@
text
@d74 1
a74 8
RCSID("$OpenBSD: scp.c,v 1.134 2006/02/20 17:19:54 stevesk Exp $");

#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>

#include <dirent.h>
#include <signal.h>
a120 42
static int
do_local_cmd(arglist *a)
{
	u_int i;
	int status;
	pid_t pid;

	if (a->num == 0)
		fatal("do_local_cmd: no arguments");

	if (verbose_mode) {
		fprintf(stderr, "Executing:");
		for (i = 0; i < a->num; i++)
			fprintf(stderr, " %s", a->list[i]);
		fprintf(stderr, "\n");
	}
	if ((pid = fork()) == -1)
		fatal("do_local_cmd: fork: %s", strerror(errno));

	if (pid == 0) {
		execvp(a->list[0], a->list);
		perror(a->list[0]);
		exit(1);
	}

	do_cmd_pid = pid;
	signal(SIGTERM, killchild);
	signal(SIGINT, killchild);
	signal(SIGHUP, killchild);

	while (waitpid(pid, &status, 0) == -1)
		if (errno != EINTR)
			fatal("do_local_cmd: waitpid: %s", strerror(errno));

	do_cmd_pid = -1;

	if (!WIFEXITED(status) || WEXITSTATUS(status) != 0)
		return (-1);

	return (0);
}

d165 1
a165 1
		replacearg(&args, 0, "%s", ssh_program);
a227 1
	memset(&args, '\0', sizeof(args));
d229 1
a229 1
	addargs(&args, "%s", ssh_program);
d338 1
a340 1
		tolocal(argc, argv);	/* Dest is local host. */
a365 4
	arglist alist;

	memset(&alist, '\0', sizeof(alist));
	alist.list = NULL;
a382 5
	if (tuser != NULL && !okname(tuser)) {
		xfree(arg);
		return;
	}

d386 2
a387 8
			freeargs(&alist);
			addargs(&alist, "%s", ssh_program);
			if (verbose_mode)
				addargs(&alist, "-v");
			addargs(&alist, "-x");
			addargs(&alist, "-oClearAllForwardings yes");
			addargs(&alist, "-n");

d392 5
a396 1

d403 6
a408 1
				else if (!okname(suser))
d410 8
a417 2
				addargs(&alist, "-l");
				addargs(&alist, "%s", suser);
d420 7
d428 3
a430 7
			addargs(&alist, "%s", host);
			addargs(&alist, "%s", cmd);
			addargs(&alist, "%s", src);
			addargs(&alist, "%s%s%s:%s",
			    tuser ? tuser : "", tuser ? "@@" : "",
			    thost, targ);
			if (do_local_cmd(&alist) != 0)
d432 1
a455 4
	arglist alist;

	memset(&alist, '\0', sizeof(alist));
	alist.list = NULL;
d459 9
a467 9
			freeargs(&alist);
			addargs(&alist, "%s", _PATH_CP);
			if (iamrecursive)
				addargs(&alist, "-r");
			if (pflag)
				addargs(&alist, "-p");
			addargs(&alist, "%s", argv[i]);
			addargs(&alist, "%s", argv[argc-1]);
			if (do_local_cmd(&alist))
d469 1
@


1.1.1.7
log
@I decided we'd better upgrade OpenSSH before releasing to the general public
@
text
@a0 1
/* $OpenBSD: scp.c,v 1.141 2006/04/01 05:50:29 djm Exp $ */
d74 1
a79 1
#include <ctype.h>
d90 1
a90 1
int do_cmd(char *host, char *remuser, char *cmd, int *fdin, int *fdout);
d177 1
a177 1
do_cmd(char *host, char *remuser, char *cmd, int *fdin, int *fdout)
d244 1
d414 1
a416 1
	int i;
d481 3
a483 1
				xasprintf(&bp, "%s -t %s", cmd, targ);
d486 1
a486 1
				    &remout) < 0)
d500 1
a502 1
	int i;
d534 4
a537 2
		xasprintf(&bp, "%s -f %s", cmd, src);
		if (do_cmd(host, suser, bp, &remin, &remout) < 0) {
d782 1
a782 2
	int amt, exists, first, ofd;
	mode_t mode, omode, mask;
d1094 9
a1102 9
	if (fp != NULL || (remout != -1 && (fp = fdopen(remout, "w")))) {
		(void) fprintf(fp, "%c", 0x01);
		(void) fprintf(fp, "scp: ");
		va_start(ap, fmt);
		(void) vfprintf(fp, fmt, ap);
		va_end(ap);
		(void) fprintf(fp, "\n");
		(void) fflush(fp);
	}
d1174 1
a1174 1
		bp->buf = xrealloc(bp->buf, 1, size);
@


1.1.1.8
log
@if we're gonna push out another snapshot, we'd better have sshd-current
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.142 2006/05/17 12:43:34 markus Exp $ */
d192 1
a192 2
	if (pipe(reserved) < 0)
		fatal("pipe: %s", strerror(errno));
a492 1
	xfree(arg);
@


1.1.1.9
log
@import a few security-wise relevant changes right now
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.155 2006/08/03 03:34:42 deraadt Exp $ */
d74 2
a75 1
#include <sys/param.h>
a78 2
#include <sys/time.h>
#include <sys/uio.h>
a81 3
#include <errno.h>
#include <fcntl.h>
#include <pwd.h>
a82 6
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
d269 1
a269 1
	int ch, fflag, tflag, status, n;
d271 1
a271 1
	char *targ, *endp, **newargv;
a277 6
	/* Copy argv, because we modify it */
	newargv = xcalloc(MAX(argc + 1, 1), sizeof(*newargv));
	for (n = 0; n < argc; n++)
		newargv[n] = xstrdup(argv[n]);
	argv = newargv;

@


1.1.1.10
log
@update OpenSSH, while we're at it…
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.156 2007/01/22 13:06:21 djm Exp $ */
d370 1
a370 1
	if (!isatty(STDOUT_FILENO))
@


1.1.1.11
log
@Import latest OpenSSH and OpenBSD-libssl
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.159 2007/06/13 00:21:27 djm Exp $ */
a92 1
#include <vis.h>
d572 1
a572 1
	char *last, *name, buf[2048], encname[MAXPATHLEN];
a580 2
		if ((fd = open(name, O_RDONLY|O_NONBLOCK, 0)) < 0)
			goto syserr;
d582 3
a584 2
			strnvis(encname, name, sizeof(encname), VIS_NL);
			name = encname;
d586 2
a591 1
		unset_nonblock(fd);
d1011 1
a1011 2
		if (wrerr == NO && (!exists || S_ISREG(stb.st_mode)) &&
		    ftruncate(ofd, size) != 0) {
@


1.1.1.12
log
@OpenSSH 4.7+1
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.160 2007/08/06 19:16:06 sobrado Exp $ */
d1100 1
a1100 1
	    "           [[user@@]host1:]file1 ... [[user@@]host2:]file2\n");
@


1.1.1.13
log
@newer openssh
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.162 2008/01/01 09:06:39 dtucker Exp $ */
a75 1
#include <sys/poll.h>
a101 2
#define COPY_BUFLEN	16384

a428 37
/*
 * atomicio-like wrapper that also applies bandwidth limits and updates
 * the progressmeter counter.
 */
static size_t
scpio(ssize_t (*f)(int, void *, size_t), int fd, void *_p, size_t l, off_t *c)
{
	u_char *p = (u_char *)_p;
	size_t offset;
	ssize_t r;
	struct pollfd pfd;

	pfd.fd = fd;
	pfd.events = f == read ? POLLIN : POLLOUT;
	for (offset = 0; offset < l;) {
		r = f(fd, p + offset, l - offset);
		if (r == 0) {
			errno = EPIPE;
			return offset;
		}
		if (r < 0) {
			if (errno == EINTR)
				continue;
			if (errno == EAGAIN) {
				(void)poll(&pfd, 1, -1); /* Ignore errors */
				continue;
			}
			return offset;
		}
		offset += (size_t)r;
		*c += (off_t)r;
		if (limit_rate)
			bwlimit(r);
	}
	return offset;
}

d571 1
d617 2
a618 8
			    (u_long) (stb.st_mtime < 0 ? 0 : stb.st_mtime),
			    (u_long) (stb.st_atime < 0 ? 0 : stb.st_atime));
			if (verbose_mode) {
				fprintf(stderr, "File mtime %ld atime %ld\n",
				    (long)stb.st_mtime, (long)stb.st_atime);
				fprintf(stderr, "Sending file timestamps: %s",
				    buf);
			}
d633 1
a633 1
		if ((bp = allocbuf(&buffer, fd, COPY_BUFLEN)) == NULL) {
d642 1
a642 1
		set_nonblock(remout);
d648 2
a649 1
				if (atomicio(read, fd, bp->buf, amt) != amt)
d652 7
a658 4
			/* Keep writing after error to retain sync */
			if (haderr) {
				(void)atomicio(vwrite, remout, bp->buf, amt);
				continue;
d660 2
a661 3
			if (scpio(vwrite, remout, bp->buf, amt,
			    &statbytes) != amt)
				haderr = errno;
a662 1
		unset_nonblock(remout);
d768 1
a768 1
		} else if (bwend.tv_usec < 10000) {
d770 2
a771 2
			if (thresh > COPY_BUFLEN * 4)
				thresh = COPY_BUFLEN * 4;
d962 1
a962 1
		if ((bp = allocbuf(&buffer, ofd, COPY_BUFLEN)) == NULL) {
d972 2
a973 3
		set_nonblock(remin);
		for (count = i = 0; i < size; i += bp->cnt) {
			amt = bp->cnt;
d978 1
a978 1
				j = scpio(read, remin, cp, amt, &statbytes);
d980 1
a980 2
					run_err("%s", j != EPIPE ?
					    strerror(errno) :
d986 1
d989 3
a1004 1
		unset_nonblock(remin);
@


1.1.1.14
log
@OpenSSH-current
@
text
@d1 1
a1 1
/* $OpenBSD: scp.c,v 1.164 2008/10/10 04:55:16 stevesk Exp $ */
d415 1
a415 1
	 * and no error has occurred yet
d610 1
a610 2
	off_t i, statbytes;
	size_t amt;
a630 4
		if (stb.st_size < 0) {
			run_err("%s: %s", name, "Negative file size");
			goto next;
		}
d690 1
a690 1
			if (i + (off_t)amt > stb.st_size)
@


