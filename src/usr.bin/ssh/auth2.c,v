head	1.11;
access;
symbols
	cvs-200910041320:1.1.1.8
	cvs-200903221200:1.1.1.7
	cvs-200812162015:1.1.1.7
	cvs-200804031830:1.1.1.6
	MIRBSD_10:1.8.0.2
	MIRBSD_10_BASE:1.8
	cvs-200803022030:1.1.1.6
	cvs-200709131337:1.1.1.5
	cvs-200709021830:1.1.1.5
	cvs-200708201200:1.1.1.5
	cvs-200706161500:1.1.1.5
	cvs-200705192215:1.1.1.5
	cvs-200704292000:1.1.1.5
	cvs-200703080900:1.1.1.4
	cvs-200701251600:1.1.1.3
	cvs-200612111600:1.1.1.3
	cvs-200611090230:1.1.1.3
	OPENBSD_4_0:1.1.1.3
	MIRBSD_9_BASE:1.4
	cvs-200606162342:1.1.1.2
	cvs-200606022000:1.1.1.2
	cvs-200604191000:1.1.1.2
	cvs-200602220045:1.1.1.1
	MIRBSD_8:1.2.0.2
	MIRBSD_8_BASE:1.2
	cvs-200512201942:1.1.1.1
	cvs-200511231930:1.1.1.1
	cvs-200507211800:1.1.1.1
	cvs-200506221550:1.1.1.1
	cvs-200505050030:1.1.1.1
	cvs-200504291700:1.1.1.1
	cvs-200504261445:1.1.1.1
	cvs-200504141900:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2014.03.28.22.31.55;	author tg;	state Exp;
branches;
next	1.10;
commitid	1005335F87233372394;

1.10
date	2009.10.04.14.29.02;	author tg;	state Exp;
branches;
next	1.9;
commitid	1004AC8B1276FC00211;

1.9
date	2008.12.16.20.55.19;	author tg;	state Exp;
branches;
next	1.8;
commitid	100494815C97ECEEDBF;

1.8
date	2008.03.02.21.14.18;	author tg;	state Exp;
branches;
next	1.7;
commitid	10047CB18BB506A8527;

1.7
date	2007.04.29.20.23.12;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004634FEC2113C55F5;

1.6
date	2007.03.08.10.09.31;	author tg;	state Exp;
branches;
next	1.5;
commitid	10045EFE0F11EDE1747;

1.5
date	2006.09.20.21.40.56;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004511B578580E7F04;

1.4
date	2006.04.19.10.40.44;	author tg;	state Exp;
branches;
next	1.3;
commitid	100444613BD3A91C28B;

1.3
date	2006.02.22.02.16.44;	author tg;	state Exp;
branches;
next	1.2;
commitid	10043FBC991512A442B;

1.2
date	2005.03.13.18.33.30;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.29.52;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.29.52;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.04.19.10.15.02;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	10044460DB21E1F715C;

1.1.1.3
date	2006.09.20.19.06.47;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	10045119150397FC669;

1.1.1.4
date	2007.03.08.09.23.20;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	10045EFD61903FC276A;

1.1.1.5
date	2007.04.29.20.07.00;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	1004634FAED5BC54DF0;

1.1.1.6
date	2008.03.02.20.40.41;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	10047CB10DD30FAF062;

1.1.1.7
date	2008.12.16.20.15.32;	author tg;	state Exp;
branches;
next	1.1.1.8;
commitid	10049480C7A2701F5C0;

1.1.1.8
date	2009.10.04.13.25.44;	author tg;	state Exp;
branches;
next	;
commitid	1004AC8A2663BC008C5;


desc
@@


1.11
log
@replicate commit “remove experimental, never-enabled JPAKE code; ok markus@@” (djm, 2014/01/29 06:18:35) from upstream
@
text
@/* $OpenBSD: auth2.c,v 1.121 2009/06/22 05:39:28 dtucker Exp $ */
/*
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


#include <sys/types.h>
#include <sys/stat.h>
#include <sys/uio.h>

#include <fcntl.h>
#include <pwd.h>
#include <stdarg.h>
#include <string.h>
#include <unistd.h>

#include "atomicio.h"
#include "xmalloc.h"
#include "ssh2.h"
#include "packet.h"
#include "log.h"
#include "buffer.h"
#include "servconf.h"
#include "compat.h"
#include "key.h"
#include "hostfile.h"
#include "auth.h"
#include "dispatch.h"
#include "pathnames.h"
#include "monitor_wrap.h"

__RCSID("$MirOS: src/usr.bin/ssh/auth2.c,v 1.10 2009/10/04 14:29:02 tg Exp $");

/* import */
extern ServerOptions options;
extern u_char *session_id2;
extern u_int session_id2_len;

/* methods */

extern Authmethod method_none;
extern Authmethod method_pubkey;
extern Authmethod method_passwd;
extern Authmethod method_kbdint;
extern Authmethod method_hostbased;

Authmethod *authmethods[] = {
	&method_none,
	&method_pubkey,
	&method_passwd,
	&method_kbdint,
	&method_hostbased,
	NULL
};

/* protocol */

static void input_service_request(int, u_int32_t, void *);
static void input_userauth_request(int, u_int32_t, void *);

/* helper */
static Authmethod *authmethod_lookup(const char *);
static char *authmethods_get(void);

char *
auth2_read_banner(void)
{
	struct stat st;
	char *banner = NULL;
	size_t len, n;
	int fd;

	if ((fd = open(options.banner, O_RDONLY)) == -1)
		return (NULL);
	if (fstat(fd, &st) == -1) {
		close(fd);
		return (NULL);
	}
	if (st.st_size > 1*1024*1024) {
		close(fd);
		return (NULL);
	}

	len = (size_t)st.st_size;		/* truncate */
	banner = xmalloc(len + 1);
	n = atomicio(read, fd, banner, len);
	close(fd);

	if (n != len) {
		xfree(banner);
		return (NULL);
	}
	banner[n] = '\0';

	return (banner);
}

static void
userauth_banner(void)
{
	char *banner = NULL;

	if (options.banner == NULL ||
	    strcasecmp(options.banner, "none") == 0 ||
	    (datafellows & SSH_BUG_BANNER) != 0)
		return;

	if ((banner = PRIVSEP(auth2_read_banner())) == NULL)
		goto done;

	packet_start(SSH2_MSG_USERAUTH_BANNER);
	packet_put_cstring(banner);
	packet_put_cstring("");		/* language, unused */
	packet_send();
	debug("userauth_banner: sent");
done:
	if (banner)
		xfree(banner);
}

/*
 * loop until authctxt->success == TRUE
 */
void
do_authentication2(Authctxt *authctxt)
{
	dispatch_init(&dispatch_protocol_error);
	dispatch_set(SSH2_MSG_SERVICE_REQUEST, &input_service_request);
	dispatch_run(DISPATCH_BLOCK, &authctxt->success, authctxt);
}

/*ARGSUSED*/
static void
input_service_request(int type, u_int32_t seq, void *ctxt)
{
	Authctxt *authctxt = ctxt;
	u_int len;
	int acceptit = 0;
	char *service = packet_get_string(&len);
	packet_check_eom();

	if (authctxt == NULL)
		fatal("input_service_request: no authctxt");

	if (strcmp(service, "ssh-userauth") == 0) {
		if (!authctxt->success) {
			acceptit = 1;
			/* now we can handle user-auth requests */
			dispatch_set(SSH2_MSG_USERAUTH_REQUEST, &input_userauth_request);
		}
	}
	/* XXX all other service requests are denied */

	if (acceptit) {
		packet_start(SSH2_MSG_SERVICE_ACCEPT);
		packet_put_cstring(service);
		packet_send();
		packet_write_wait();
	} else {
		debug("bad service request %s", service);
		packet_disconnect("bad service request %s", service);
	}
	xfree(service);
}

/*ARGSUSED*/
static void
input_userauth_request(int type, u_int32_t seq, void *ctxt)
{
	Authctxt *authctxt = ctxt;
	Authmethod *m = NULL;
	char *user, *service, *method, *style = NULL;
	int authenticated = 0;

	if (authctxt == NULL)
		fatal("input_userauth_request: no authctxt");

	user = packet_get_string(NULL);
	service = packet_get_string(NULL);
	method = packet_get_string(NULL);
	debug("userauth-request for user %s service %s method %s", user, service, method);
	debug("attempt %d failures %d", authctxt->attempt, authctxt->failures);

	if ((style = strchr(user, ':')) != NULL)
		*style++ = 0;

	if (authctxt->attempt++ == 0) {
		/* setup auth context */
		authctxt->pw = PRIVSEP(getpwnamallow(user));
		if (authctxt->pw && strcmp(service, "ssh-connection")==0) {
			authctxt->valid = 1;
			debug2("input_userauth_request: setting up authctxt for %s", user);
		} else {
			logit("input_userauth_request: invalid user %s", user);
			authctxt->pw = fakepw();
		}
		setproctitle("%s%s", authctxt->valid ? user : "unknown",
		    use_privsep ? " [net]" : "");
		authctxt->user = xstrdup(user);
		authctxt->service = xstrdup(service);
		authctxt->style = style ? xstrdup(style) : NULL;
		if (use_privsep)
			mm_inform_authserv(service, style);
		userauth_banner();
	} else if (strcmp(user, authctxt->user) != 0 ||
	    strcmp(service, authctxt->service) != 0) {
		packet_disconnect("Change of username or service not allowed: "
		    "(%s,%s) -> (%s,%s)",
		    authctxt->user, authctxt->service, user, service);
	}
	/* reset state */
	auth2_challenge_stop(authctxt);

	authctxt->postponed = 0;

	/* try to authenticate user */
	m = authmethod_lookup(method);
	if (m != NULL && authctxt->failures < options.max_authtries) {
		debug2("input_userauth_request: try method %s", method);
		authenticated =	m->userauth(authctxt);
	}
	userauth_finish(authctxt, authenticated, method);

	xfree(service);
	xfree(user);
	xfree(method);
}

void
userauth_finish(Authctxt *authctxt, int authenticated, char *method)
{
	char *methods;

	if (!authctxt->valid && authenticated)
		fatal("INTERNAL ERROR: authenticated invalid user %s",
		    authctxt->user);

	/* Special handling for root */
	if (authenticated && authctxt->pw->pw_uid == 0 &&
	    !auth_root_allowed(method))
		authenticated = 0;

	/* Log before sending the reply */
	auth_log(authctxt, authenticated, method, " ssh2");

	if (authctxt->postponed)
		return;

	/* XXX todo: check if multiple auth methods are needed */
	if (authenticated == 1) {
		/* turn off userauth */
		dispatch_set(SSH2_MSG_USERAUTH_REQUEST, &dispatch_protocol_ignore);
		packet_start(SSH2_MSG_USERAUTH_SUCCESS);
		packet_send();
		packet_write_wait();
		/* now we can break out */
		authctxt->success = 1;
	} else {
		/* Allow initial try of "none" auth without failure penalty */
		if (authctxt->attempt > 1 || strcmp(method, "none") != 0)
			authctxt->failures++;
		if (authctxt->failures >= options.max_authtries)
			packet_disconnect(AUTH_FAIL_MSG, authctxt->user);
		methods = authmethods_get();
		packet_start(SSH2_MSG_USERAUTH_FAILURE);
		packet_put_cstring(methods);
		packet_put_char(0);	/* XXX partial success, unused */
		packet_send();
		packet_write_wait();
		xfree(methods);
	}
}

static char *
authmethods_get(void)
{
	Buffer b;
	char *list;
	int i;

	buffer_init(&b);
	for (i = 0; authmethods[i] != NULL; i++) {
		if (strcmp(authmethods[i]->name, "none") == 0)
			continue;
		if (authmethods[i]->enabled != NULL &&
		    *(authmethods[i]->enabled) != 0) {
			if (buffer_len(&b) > 0)
				buffer_append(&b, ",", 1);
			buffer_append(&b, authmethods[i]->name,
			    strlen(authmethods[i]->name));
		}
	}
	buffer_append(&b, "\0", 1);
	list = xstrdup(buffer_ptr(&b));
	buffer_free(&b);
	return list;
}

static Authmethod *
authmethod_lookup(const char *name)
{
	int i;

	if (name != NULL)
		for (i = 0; authmethods[i] != NULL; i++)
			if (authmethods[i]->enabled != NULL &&
			    *(authmethods[i]->enabled) != 0 &&
			    strcmp(name, authmethods[i]->name) == 0)
				return authmethods[i];
	debug2("Unrecognized authentication method name: %s",
	    name ? name : "NULL");
	return NULL;
}

@


1.10
log
@• merge newer OpenSSH
• KNF in our diff – style(9)
• some const cleanliness (build with __CRAZY=Yes mostly)
@
text
@d52 1
a52 1
__RCSID("$MirOS: src/usr.bin/ssh/auth2.c,v 1.9 2008/12/16 20:55:19 tg Exp $");
a65 3
#ifdef JPAKE
extern Authmethod method_jpake;
#endif
a69 3
#ifdef JPAKE
	&method_jpake,
#endif
a232 3
#ifdef JPAKE
	auth2_jpake_stop(authctxt);
#endif
@


1.9
log
@fastmerge, do not use yet!
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.120 2008/11/04 08:22:12 djm Exp $ */
d33 1
a34 1
#include <stdarg.h>
d52 1
a52 1
__RCSID("$MirOS: src/usr.bin/ssh/auth2.c,v 1.8 2008/03/02 21:14:18 tg Exp $");
@


1.8
log
@merge’n’fix
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.116 2007/09/29 00:25:51 dtucker Exp $ */
d26 1
d28 2
d31 1
d35 1
d37 1
d52 1
a52 1
__RCSID("$MirOS: src/usr.bin/ssh/auth2.c,v 1.7 2007/04/29 20:23:12 tg Exp $");
d66 3
d73 3
d91 56
a149 1

d230 1
d239 3
d247 1
a247 1
	if (m != NULL) {
d288 4
a291 1
		if (authctxt->failures++ > options.max_authtries)
d343 1
@


1.7
log
@merge openssh
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.115 2007/04/14 22:01:58 stevesk Exp $ */
d46 1
a46 1
__RCSID("$MirOS: src/usr.bin/ssh/auth2.c,v 1.6 2007/03/08 10:09:31 tg Exp $");
@


1.6
log
@merge OpenSSH 4.6, retain local changes
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.114 2007/03/01 10:28:02 dtucker Exp $ */
d46 1
a46 1
__RCSID("$MirOS: src/usr.bin/ssh/auth2.c,v 1.5 2006/09/20 21:40:56 tg Exp $");
a228 2
#define	DELIM	","

@


1.5
log
@finish merging
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.113 2006/08/03 03:34:41 deraadt Exp $ */
d46 1
a46 1
__RCSID("$MirOS$");
a85 4
	/* challenge-response is implemented via keyboard interactive */
	if (options.challenge_response_authentication)
		options.kbd_interactive_authentication = 1;

@


1.4
log
@merge and clean up
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.110 2006/03/25 13:17:01 djm Exp $ */
d26 1
a26 2
#include "includes.h"
__RCSID("$MirOS: src/usr.bin/ssh/auth2.c,v 1.3 2006/02/22 02:16:44 tg Exp $");
d28 5
a33 1
#include "xmalloc.h"
d36 1
d39 2
d46 2
@


1.3
log
@fix a lot of and kludge a few more __CRAZY problems, sync rcs id
@
text
@d1 1
d27 1
a27 1
RCSID("$MirOS: src/usr.bin/ssh/auth2.c,v 1.2 2005/03/13 18:33:30 tg Exp $");
d87 1
d121 1
@


1.2
log
@merge src/usr.bin
@
text
@d26 1
a26 1
RCSID("$MirOS$");
a68 1
int user_key_allowed(struct passwd *, Key *);
@


1.1
log
@Initial revision
@
text
@d26 1
a26 1
RCSID("$OpenBSD: auth2.c,v 1.107 2004/07/28 09:40:29 markus Exp $");
a38 4
#ifdef GSSAPI
#include "ssh-gss.h"
#endif

a50 3
#ifdef GSSAPI
extern Authmethod method_gssapi;
#endif
a54 3
#ifdef GSSAPI
	&method_gssapi,
#endif
a165 5
#ifdef GSSAPI
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);
	dispatch_set(SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE, NULL);
#endif

@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@I decided we'd better upgrade OpenSSH before releasing to the general public
@
text
@a0 1
/* $OpenBSD: auth2.c,v 1.110 2006/03/25 13:17:01 djm Exp $ */
d26 1
a96 1
/*ARGSUSED*/
a129 1
/*ARGSUSED*/
@


1.1.1.3
log
@import a few security-wise relevant changes right now
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.113 2006/08/03 03:34:41 deraadt Exp $ */
d26 1
d28 1
a28 6
#include <sys/types.h>

#include <pwd.h>
#include <string.h>
#include <stdarg.h>

a29 1
#include "ssh2.h"
a31 1
#include "buffer.h"
a33 2
#include "key.h"
#include "hostfile.h"
d37 2
a41 1
#include "monitor_wrap.h"
@


1.1.1.4
log
@Import OpenSSH 4.6
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.114 2007/03/01 10:28:02 dtucker Exp $ */
d95 4
@


1.1.1.5
log
@import openbsd compress, ssh, perl, sendmail for minor bugfixes
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.115 2007/04/14 22:01:58 stevesk Exp $ */
d243 2
@


1.1.1.6
log
@newer openssh
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.116 2007/09/29 00:25:51 dtucker Exp $ */
d86 1
@


1.1.1.7
log
@OpenSSH-current
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.120 2008/11/04 08:22:12 djm Exp $ */
a27 2
#include <sys/stat.h>
#include <sys/uio.h>
a28 1
#include <fcntl.h>
a31 1
#include <unistd.h>
a32 1
#include "atomicio.h"
a64 3
#ifdef JPAKE
extern Authmethod method_jpake;
#endif
a71 3
#ifdef JPAKE
	&method_jpake,
#endif
a86 56
char *
auth2_read_banner(void)
{
	struct stat st;
	char *banner = NULL;
	size_t len, n;
	int fd;

	if ((fd = open(options.banner, O_RDONLY)) == -1)
		return (NULL);
	if (fstat(fd, &st) == -1) {
		close(fd);
		return (NULL);
	}
	if (st.st_size > 1*1024*1024) {
		close(fd);
		return (NULL);
	}

	len = (size_t)st.st_size;		/* truncate */
	banner = xmalloc(len + 1);
	n = atomicio(read, fd, banner, len);
	close(fd);

	if (n != len) {
		xfree(banner);
		return (NULL);
	}
	banner[n] = '\0';

	return (banner);
}

static void
userauth_banner(void)
{
	char *banner = NULL;

	if (options.banner == NULL ||
	    strcasecmp(options.banner, "none") == 0 ||
	    (datafellows & SSH_BUG_BANNER) != 0)
		return;

	if ((banner = PRIVSEP(auth2_read_banner())) == NULL)
		goto done;

	packet_start(SSH2_MSG_USERAUTH_BANNER);
	packet_put_cstring(banner);
	packet_put_cstring("");		/* language, unused */
	packet_send();
	debug("userauth_banner: sent");
done:
	if (banner)
		xfree(banner);
}

d90 1
a170 1
		userauth_banner();
a178 3
#ifdef JPAKE
	auth2_jpake_stop(authctxt);
#endif
a180 1
	/* XXX move to auth2_gssapi_stop() */
d189 1
a189 1
	if (m != NULL && authctxt->failures < options.max_authtries) {
d230 1
a230 4
		/* Allow initial try of "none" auth without failure penalty */
		if (authctxt->attempt > 1 || strcmp(method, "none") != 0)
			authctxt->failures++;
		if (authctxt->failures >= options.max_authtries)
a281 1

@


1.1.1.8
log
@Let’s play the version number game – OpenSSH 5.3-current
@
text
@d1 1
a1 1
/* $OpenBSD: auth2.c,v 1.121 2009/06/22 05:39:28 dtucker Exp $ */
d33 1
a34 1
#include <string.h>
@


