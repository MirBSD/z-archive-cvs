head	1.7;
access;
symbols
	cvs-200910041320:1.1.1.8
	cvs-200903221200:1.1.1.8
	cvs-200812162015:1.1.1.8
	cvs-200804031830:1.1.1.7
	MIRBSD_10:1.5.0.2
	MIRBSD_10_BASE:1.5
	cvs-200803022030:1.1.1.7
	cvs-200709131337:1.1.1.7
	cvs-200709021830:1.1.1.7
	cvs-200708201200:1.1.1.7
	cvs-200706161500:1.1.1.7
	cvs-200705192215:1.1.1.7
	cvs-200704292000:1.1.1.7
	cvs-200703080900:1.1.1.7
	cvs-200701251600:1.1.1.7
	cvs-200612111600:1.1.1.6
	cvs-200611090230:1.1.1.6
	OPENBSD_4_0:1.1.1.6
	MIRBSD_9_BASE:1.3
	cvs-200606162342:1.1.1.5
	cvs-200606022000:1.1.1.5
	cvs-200604191000:1.1.1.5
	cvs-200602220045:1.1.1.4
	MIRBSD_8:1.1.1.4.0.2
	MIRBSD_8_BASE:1.1.1.4
	cvs-200512201942:1.1.1.4
	cvs-200511231930:1.1.1.4
	cvs-200507211800:1.1.1.3
	cvs-200506221550:1.1.1.3
	cvs-200505050030:1.1.1.2
	cvs-200504291700:1.1.1.2
	cvs-200504261445:1.1.1.2
	cvs-200504141900:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2013.10.31.20.07.11;	author tg;	state Exp;
branches;
next	1.6;
commitid	1005272B7081B0E5655;

1.6
date	2008.12.16.20.55.22;	author tg;	state Exp;
branches;
next	1.5;
commitid	100494815C97ECEEDBF;

1.5
date	2007.01.25.16.18.36;	author tg;	state Exp;
branches;
next	1.4;
commitid	10045B8D86E5B698AD6;

1.4
date	2006.09.20.21.40.58;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004511B578580E7F04;

1.3
date	2006.04.19.10.40.47;	author tg;	state Exp;
branches;
next	1.2;
commitid	100444613BD3A91C28B;

1.2
date	2006.02.22.02.16.45;	author tg;	state Exp;
branches;
next	1.1;
commitid	10043FBC991512A442B;

1.1
date	2005.02.05.17.29.52;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.29.52;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.26.14.54.55;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.06.22.15.56.25;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	181342b98a38fe99;

1.1.1.4
date	2005.11.23.19.34.14;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	116a4384c4467ffc;

1.1.1.5
date	2006.04.19.10.15.03;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	10044460DB21E1F715C;

1.1.1.6
date	2006.09.20.19.06.48;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	10045119150397FC669;

1.1.1.7
date	2007.01.25.16.13.01;	author tg;	state Exp;
branches;
next	1.1.1.8;
commitid	10045B8D7100791C016;

1.1.1.8
date	2008.12.16.20.15.33;	author tg;	state Exp;
branches;
next	;
commitid	10049480C7A2701F5C0;


desc
@@


1.7
log
@adapt most __attribute__((…)) occurrences to new KNF style(9)
@
text
@/* $OpenBSD: dns.c,v 1.25 2008/06/12 00:03:49 dtucker Exp $ */

/*
 * Copyright © 2013
 *	Thorsten “mirabilos” Glaser <tg@@mirbsd.org>
 * Copyright (c) 2003 Wesley Griffin. All rights reserved.
 * Copyright (c) 2003 Jakob Schlyter. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/socket.h>

#include <netdb.h>
#include <stdio.h>
#include <string.h>

#include "xmalloc.h"
#include "key.h"
#include "dns.h"
#include "log.h"

__RCSID("$MirOS: src/usr.bin/ssh/dns.c,v 1.6 2008/12/16 20:55:22 tg Exp $");

static const char *errset_text[] = {
	"success",		/* 0 ERRSET_SUCCESS */
	"out of memory",	/* 1 ERRSET_NOMEMORY */
	"general failure",	/* 2 ERRSET_FAIL */
	"invalid parameter",	/* 3 ERRSET_INVAL */
	"name does not exist",	/* 4 ERRSET_NONAME */
	"data does not exist",	/* 5 ERRSET_NODATA */
};

static const char *
dns_result_totext(unsigned int res)
{
	switch (res) {
	case ERRSET_SUCCESS:
		return errset_text[ERRSET_SUCCESS];
	case ERRSET_NOMEMORY:
		return errset_text[ERRSET_NOMEMORY];
	case ERRSET_FAIL:
		return errset_text[ERRSET_FAIL];
	case ERRSET_INVAL:
		return errset_text[ERRSET_INVAL];
	case ERRSET_NONAME:
		return errset_text[ERRSET_NONAME];
	case ERRSET_NODATA:
		return errset_text[ERRSET_NODATA];
	default:
		return "unknown error";
	}
}

/*
 * Read SSHFP parameters from key buffer.
 */
static int
dns_read_key(u_int8_t *algorithm, u_int8_t *digest_type,
    u_char **digest, u_int *digest_len, const Key *key)
{
	int success = 0;

	switch (key->type) {
	case KEY_RSA:
		*algorithm = SSHFP_KEY_RSA;
		break;
	case KEY_DSA:
		*algorithm = SSHFP_KEY_DSA;
		break;
	default:
		*algorithm = SSHFP_KEY_RESERVED; /* 0 */
	}

	if (*algorithm) {
		*digest_type = SSHFP_HASH_SHA1;
		*digest = key_fingerprint_raw(key, SSH_FP_SHA1, digest_len);
		if (*digest == NULL)
			fatal("dns_read_key: null from key_fingerprint_raw()");
		success = 1;
	} else {
		*digest_type = SSHFP_HASH_RESERVED;
		*digest = NULL;
		*digest_len = 0;
		success = 0;
	}

	return success;
}

/*
 * Read SSHFP parameters from rdata buffer.
 */
static int
dns_read_rdata(u_int8_t *algorithm, u_int8_t *digest_type,
    u_char **digest, u_int *digest_len, u_char *rdata, int rdata_len)
{
	int success = 0;

	*algorithm = SSHFP_KEY_RESERVED;
	*digest_type = SSHFP_HASH_RESERVED;

	if (rdata_len >= 2) {
		*algorithm = rdata[0];
		*digest_type = rdata[1];
		*digest_len = rdata_len - 2;

		if (*digest_len > 0) {
			*digest = (u_char *) xmalloc(*digest_len);
			memcpy(*digest, rdata + 2, *digest_len);
		} else {
			*digest = (u_char *)xstrdup("");
		}

		success = 1;
	}

	return success;
}

/*
 * Check if hostname is numerical.
 * Returns -1 if hostname is numeric, 0 otherwise
 */
static int
is_numeric_hostname(const char *hostname)
{
	struct addrinfo hints, *ai;

	/*
	 * We shouldn't ever get a null host but if we do then log an error
	 * and return -1 which stops DNS key fingerprint processing.
	 */
	if (hostname == NULL) {
		error("is_numeric_hostname called with NULL hostname");
		return -1;
	}

	memset(&hints, 0, sizeof(hints));
	hints.ai_socktype = SOCK_DGRAM;
	hints.ai_flags = AI_NUMERICHOST;

	if (getaddrinfo(hostname, NULL, &hints, &ai) == 0) {
		freeaddrinfo(ai);
		return -1;
	}

	return 0;
}

/*
 * Verify the given hostname, address and host key using DNS.
 * Returns 0 if lookup succeeds, -1 otherwise
 */
int
verify_host_key_dns(const char *hostname,
    struct sockaddr *address  __attribute__((__unused__)),
    const Key *hostkey, int *flags)
{
	u_int counter;
	int result;
	struct rrsetinfo *fingerprints = NULL;

	u_int8_t hostkey_algorithm;
	u_int8_t hostkey_digest_type;
	u_char *hostkey_digest;
	u_int hostkey_digest_len;

	u_int8_t dnskey_algorithm;
	u_int8_t dnskey_digest_type;
	u_char *dnskey_digest;
	u_int dnskey_digest_len;

	*flags = 0;

	debug3("verify_host_key_dns");
	if (hostkey == NULL)
		fatal("No key to look up!");

	if (is_numeric_hostname(hostname)) {
		debug("skipped DNS lookup for numerical hostname");
		return -1;
	}

	result = getrrsetbyname(hostname, DNS_RDATACLASS_IN,
	    DNS_RDATATYPE_SSHFP, 0, &fingerprints);
	if (result) {
		verbose("DNS lookup error: %s", dns_result_totext(result));
		return -1;
	}

	if (fingerprints->rri_flags & RRSET_VALIDATED) {
		*flags |= DNS_VERIFY_SECURE;
		debug("found %d secure fingerprints in DNS",
		    fingerprints->rri_nrdatas);
	} else {
		debug("found %d insecure fingerprints in DNS",
		    fingerprints->rri_nrdatas);
	}

	/* Initialize host key parameters */
	if (!dns_read_key(&hostkey_algorithm, &hostkey_digest_type,
	    &hostkey_digest, &hostkey_digest_len, hostkey)) {
		error("Error calculating host key fingerprint.");
		freerrset(fingerprints);
		return -1;
	}

	if (fingerprints->rri_nrdatas)
		*flags |= DNS_VERIFY_FOUND;

	for (counter = 0; counter < fingerprints->rri_nrdatas; counter++) {
		/*
		 * Extract the key from the answer. Ignore any badly
		 * formatted fingerprints.
		 */
		if (!dns_read_rdata(&dnskey_algorithm, &dnskey_digest_type,
		    &dnskey_digest, &dnskey_digest_len,
		    fingerprints->rri_rdatas[counter].rdi_data,
		    fingerprints->rri_rdatas[counter].rdi_length)) {
			verbose("Error parsing fingerprint from DNS.");
			continue;
		}

		/* Check if the current key is the same as the given key */
		if (hostkey_algorithm == dnskey_algorithm &&
		    hostkey_digest_type == dnskey_digest_type) {

			if (hostkey_digest_len == dnskey_digest_len &&
			    memcmp(hostkey_digest, dnskey_digest,
			    hostkey_digest_len) == 0) {

				*flags |= DNS_VERIFY_MATCH;
			}
		}
		xfree(dnskey_digest);
	}

	xfree(hostkey_digest); /* from key_fingerprint_raw() */
	freerrset(fingerprints);

	if (*flags & DNS_VERIFY_FOUND)
		if (*flags & DNS_VERIFY_MATCH)
			debug("matching host key fingerprint found in DNS");
		else
			debug("mismatching host key fingerprint found in DNS");
	else
		debug("no host key fingerprint found in DNS");

	return 0;
}

/*
 * Export the fingerprint of a key as a DNS resource record
 */
int
export_dns_rr(const char *hostname, const Key *key, FILE *f, int generic)
{
	u_int8_t rdata_pubkey_algorithm = 0;
	u_int8_t rdata_digest_type = SSHFP_HASH_SHA1;
	u_char *rdata_digest;
	u_int rdata_digest_len;

	u_int i;
	int success = 0;

	if (dns_read_key(&rdata_pubkey_algorithm, &rdata_digest_type,
	    &rdata_digest, &rdata_digest_len, key)) {

		if (generic)
			fprintf(f, "%s IN TYPE%d \\# %d %02x %02x ", hostname,
			    DNS_RDATATYPE_SSHFP, 2 + rdata_digest_len,
			    rdata_pubkey_algorithm, rdata_digest_type);
		else
			fprintf(f, "%s IN SSHFP %d %d ", hostname,
			    rdata_pubkey_algorithm, rdata_digest_type);

		for (i = 0; i < rdata_digest_len; i++)
			fprintf(f, "%02x", rdata_digest[i]);
		fprintf(f, "\n");
		xfree(rdata_digest); /* from key_fingerprint_raw() */
		success = 1;
	} else {
		error("export_dns_rr: unsupported algorithm");
	}

	return success;
}
@


1.6
log
@fastmerge, do not use yet!
@
text
@d4 2
d42 1
a42 1
__RCSID("$MirOS: src/usr.bin/ssh/dns.c,v 1.5 2007/01/25 16:18:36 tg Exp $");
d176 1
a176 1
    struct sockaddr *address  __attribute__((unused)),
@


1.5
log
@automerge, bump vsn
@
text
@d1 1
a1 1
/* $OpenBSD: dns.c,v 1.24 2007/01/03 03:01:40 stevesk Exp $ */
d40 1
a40 1
__RCSID("$MirOS: src/usr.bin/ssh/dns.c,v 1.4 2006/09/20 21:40:58 tg Exp $");
d147 9
d160 1
a160 1
	if (getaddrinfo(hostname, "0", &hints, &ai) == 0) {
@


1.4
log
@finish merging
@
text
@d1 1
a1 1
/* $OpenBSD: dns.c,v 1.23 2006/08/03 03:34:42 deraadt Exp $ */
d40 1
a40 1
__RCSID("$MirOS$");
d220 1
a220 1
	for (counter = 0; counter < fingerprints->rri_nrdatas; counter++)  {
@


1.3
log
@merge and clean up
@
text
@d1 1
a1 1
/* $OpenBSD: dns.c,v 1.19 2006/03/25 22:22:43 djm Exp $ */
d28 2
a29 2
#include "includes.h"
__RCSID("$MirOS: src/usr.bin/ssh/dns.c,v 1.2 2006/02/22 02:16:45 tg Exp $");
d32 2
d40 2
@


1.2
log
@fix a lot of and kludge a few more __CRAZY problems, sync rcs id
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.16 2005/10/17 14:13:35 stevesk Exp $	*/
d29 1
a29 1
RCSID("$MirOS: dns.c,v 1.16 2005/10/17 14:13:35 stevesk Exp $");
d125 1
a125 1
			*digest = (u_char *) xstrdup("");
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.10 2004/06/21 17:36:31 avsm Exp $	*/
a27 1

d29 1
a30 5
#include <openssl/bn.h>
#ifdef LWRES
#include <lwres/netdb.h>
#include <dns/result.h>
#else /* LWRES */
a31 1
#endif /* LWRES */
a36 4
#include "uuencode.h"

extern char *__progname;
RCSID("$OpenBSD: dns.c,v 1.10 2004/06/21 17:36:31 avsm Exp $");
a37 1
#ifndef LWRES
a66 2
#endif /* LWRES */

d85 1
a85 1
		*algorithm = SSHFP_KEY_RESERVED;
d91 2
d125 1
a125 1
			*digest = NULL;
d134 20
d160 2
a161 1
verify_host_key_dns(const char *hostname, struct sockaddr *address,
d164 1
a164 1
	int counter;
d180 1
a180 1
	debug3("verify_hostkey_dns");
d184 5
d216 1
a216 1
	for (counter = 0 ; counter < fingerprints->rri_nrdatas ; counter++)  {
d240 1
d243 1
a256 1

d268 1
a268 1
	int i;
d272 1
a272 1
			 &rdata_digest, &rdata_digest_len, key)) {
d285 1
d288 1
a288 1
		error("dns_export_rr: unsupported algorithm");
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@latest fixes from OpenBSD, last update for #8 if nothing weird happens
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.11 2005/04/20 10:05:45 jakob Exp $	*/
d46 1
a46 1
RCSID("$OpenBSD: dns.c,v 1.11 2005/04/20 10:05:45 jakob Exp $");
a144 20
/*
 * Check if hostname is numerical.
 * Returns -1 if hostname is numeric, 0 otherwise
 */
static int
is_numeric_hostname(const char *hostname)
{
	struct addrinfo hints, *ai;

	memset(&hints, 0, sizeof(hints));
	hints.ai_socktype = SOCK_DGRAM;
	hints.ai_flags = AI_NUMERICHOST;

	if (getaddrinfo(hostname, "0", &hints, &ai) == 0) {
		freeaddrinfo(ai);
		return -1;
	}

	return 0;
}
a173 5
	if (is_numeric_hostname(hostname)) {
		debug("skipped DNS lookup for numerical hostname");
		return -1;
	}

@


1.1.1.3
log
@most current OpenSSH.com
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.12 2005/06/17 02:44:32 djm Exp $	*/
d46 1
a46 1
RCSID("$OpenBSD: dns.c,v 1.12 2005/06/17 02:44:32 djm Exp $");
d174 1
a174 1
	u_int counter;
d277 1
a277 1
	u_int i;
@


1.1.1.4
log
@Import current OpenSSH
@
text
@d1 1
a1 1
/*	$OpenBSD: dns.c,v 1.16 2005/10/17 14:13:35 stevesk Exp $	*/
d28 1
a29 1
RCSID("$OpenBSD: dns.c,v 1.16 2005/10/17 14:13:35 stevesk Exp $");
d31 5
d37 1
d43 4
d48 1
d78 2
d98 1
a98 1
		*algorithm = SSHFP_KEY_RESERVED; /* 0 */
a103 2
		if (*digest == NULL)
			fatal("dns_read_key: null from key_fingerprint_raw()");
d136 1
a136 1
			*digest = xstrdup("");
d190 1
a190 1
	debug3("verify_host_key_dns");
d226 1
a226 1
	for (counter = 0; counter < fingerprints->rri_nrdatas; counter++)  {
a249 1
		xfree(dnskey_digest);
a251 1
	xfree(hostkey_digest); /* from key_fingerprint_raw() */
d265 1
d281 1
a281 1
	    &rdata_digest, &rdata_digest_len, key)) {
a293 1
		xfree(rdata_digest); /* from key_fingerprint_raw() */
d296 1
a296 1
		error("export_dns_rr: unsupported algorithm");
@


1.1.1.5
log
@I decided we'd better upgrade OpenSSH before releasing to the general public
@
text
@d1 1
a1 1
/* $OpenBSD: dns.c,v 1.19 2006/03/25 22:22:43 djm Exp $ */
d29 1
d125 1
a125 1
			*digest = (u_char *)xstrdup("");
@


1.1.1.6
log
@import a few security-wise relevant changes right now
@
text
@d1 1
a1 1
/* $OpenBSD: dns.c,v 1.23 2006/08/03 03:34:42 deraadt Exp $ */
d28 1
a28 2
#include <sys/types.h>
#include <sys/socket.h>
a30 2
#include <stdio.h>
#include <string.h>
@


1.1.1.7
log
@update OpenSSH, while we're at it…
@
text
@d1 1
a1 1
/* $OpenBSD: dns.c,v 1.24 2007/01/03 03:01:40 stevesk Exp $ */
d217 1
a217 1
	for (counter = 0; counter < fingerprints->rri_nrdatas; counter++) {
@


1.1.1.8
log
@OpenSSH-current
@
text
@d1 1
a1 1
/* $OpenBSD: dns.c,v 1.25 2008/06/12 00:03:49 dtucker Exp $ */
a144 9
	/*
	 * We shouldn't ever get a null host but if we do then log an error
	 * and return -1 which stops DNS key fingerprint processing.
	 */
	if (hostname == NULL) {
		error("is_numeric_hostname called with NULL hostname");
		return -1;
	}

d149 1
a149 1
	if (getaddrinfo(hostname, NULL, &hints, &ai) == 0) {
@


