head	1.24;
access;
symbols
	cvs-200910041320:1.1.1.18
	cvs-200903221200:1.1.1.17
	cvs-200812162015:1.1.1.16
	cvs-200804031830:1.1.1.15
	MIRBSD_10:1.17.0.2
	MIRBSD_10_BASE:1.17
	cvs-200803022030:1.1.1.14
	cvs-200709131337:1.1.1.13
	cvs-200709021830:1.1.1.12
	cvs-200708201200:1.1.1.11
	cvs-200706161500:1.1.1.11
	cvs-200705192215:1.1.1.11
	cvs-200704292000:1.1.1.11
	cvs-200703080900:1.1.1.11
	cvs-200701251600:1.1.1.11
	cvs-200612111600:1.1.1.10
	cvs-200611090230:1.1.1.10
	OPENBSD_4_0:1.1.1.9
	MIRBSD_9_BASE:1.10
	cvs-200606162342:1.1.1.8
	cvs-200606022000:1.1.1.8
	cvs-200604191000:1.1.1.7
	cvs-200602220045:1.1.1.6
	MIRBSD_8:1.6.0.2
	MIRBSD_8_BASE:1.6
	cvs-200512201942:1.1.1.5
	cvs-200511231930:1.1.1.4
	cvs-200507211800:1.1.1.3
	cvs-200506221550:1.1.1.2
	cvs-200505050030:1.1.1.1
	cvs-200504291700:1.1.1.1
	cvs-200504261445:1.1.1.1
	cvs-200504141900:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2016.03.25.18.55.35;	author tg;	state Exp;
branches;
next	1.23;
commitid	10056F589BF44FCD098;

1.23
date	2009.10.04.14.29.07;	author tg;	state Exp;
branches;
next	1.22;
commitid	1004AC8B1276FC00211;

1.22
date	2009.03.22.15.01.20;	author tg;	state Exp;
branches;
next	1.21;
commitid	10049C652CD5CCC321F;

1.21
date	2008.12.27.21.17.56;	author tg;	state Exp;
branches;
next	1.20;
commitid	10049569B9439744217;

1.20
date	2008.12.16.22.13.29;	author tg;	state Exp;
branches;
next	1.19;
commitid	10049482819766381ED;

1.19
date	2008.12.16.20.55.27;	author tg;	state Exp;
branches;
next	1.18;
commitid	100494815C97ECEEDBF;

1.18
date	2008.04.03.18.39.39;	author tg;	state Exp;
branches;
next	1.17;
commitid	10047F5247E47E55C5E;

1.17
date	2008.03.02.21.14.21;	author tg;	state Exp;
branches
	1.17.2.1;
next	1.16;
commitid	10047CB18BB506A8527;

1.16
date	2007.09.13.13.52.54;	author tg;	state Exp;
branches;
next	1.15;
commitid	10046E940B668DE9A0B;

1.15
date	2007.09.02.18.53.13;	author tg;	state Exp;
branches;
next	1.14;
commitid	10046DB06AF681AF68C;

1.14
date	2007.01.25.16.18.37;	author tg;	state Exp;
branches;
next	1.13;
commitid	10045B8D86E5B698AD6;

1.13
date	2006.10.13.18.40.50;	author tg;	state Exp;
branches;
next	1.12;
commitid	100452FDDB7190872BF;

1.12
date	2006.09.20.21.41.02;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004511B578580E7F04;

1.11
date	2006.07.23.14.19.27;	author tg;	state Exp;
branches;
next	1.10;
commitid	10044C3857E74BD315F;

1.10
date	2006.06.02.20.50.49;	author tg;	state Exp;
branches;
next	1.9;
commitid	1004480A4952B0D84EA;

1.9
date	2006.04.19.10.40.52;	author tg;	state Exp;
branches;
next	1.8;
commitid	100444613BD3A91C28B;

1.8
date	2006.02.22.02.16.48;	author tg;	state Exp;
branches;
next	1.7;
commitid	10043FBC991512A442B;

1.7
date	2006.02.22.01.23.50;	author tg;	state Exp;
branches;
next	1.6;
commitid	10043FBBD2C2C5E7D81;

1.6
date	2005.12.20.19.57.34;	author tg;	state Exp;
branches;
next	1.5;
commitid	10043A8623F4C1F637E;

1.5
date	2005.11.23.19.45.14;	author tg;	state Exp;
branches;
next	1.4;
commitid	29f4384c6def7d1;

1.4
date	2005.11.23.18.04.20;	author tg;	state Exp;
branches;
next	1.3;
commitid	af74384af2ab463;

1.3
date	2005.06.22.16.11.39;	author tg;	state Exp;
branches;
next	1.2;
commitid	598b42b98dcf335f;

1.2
date	2005.03.13.18.33.30;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.29.52;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.17.2.1
date	2008.04.05.20.12.20;	author tg;	state Exp;
branches;
next	;
commitid	10047F7DD234C13F66E;

1.1.1.1
date	2005.02.05.17.29.52;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.06.22.15.56.28;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	181342b98a38fe99;

1.1.1.3
date	2005.07.21.21.00.31;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	560042e0092f571e;

1.1.1.4
date	2005.11.23.19.34.15;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	116a4384c4467ffc;

1.1.1.5
date	2005.12.20.19.43.45;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	10043A85EF81EF097CF;

1.1.1.6
date	2006.02.22.00.51.35;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	10043FBB5A933C3BB9B;

1.1.1.7
date	2006.04.19.10.15.04;	author tg;	state Exp;
branches;
next	1.1.1.8;
commitid	10044460DB21E1F715C;

1.1.1.8
date	2006.06.02.20.31.52;	author tg;	state Exp;
branches;
next	1.1.1.9;
commitid	1004480A0422110D712;

1.1.1.9
date	2006.09.20.19.06.48;	author tg;	state Exp;
branches;
next	1.1.1.10;
commitid	10045119150397FC669;

1.1.1.10
date	2006.11.09.02.38.00;	author tg;	state Exp;
branches;
next	1.1.1.11;
commitid	100455294981A6201C8;

1.1.1.11
date	2007.01.25.16.13.02;	author tg;	state Exp;
branches;
next	1.1.1.12;
commitid	10045B8D7100791C016;

1.1.1.12
date	2007.09.02.18.48.04;	author tg;	state Exp;
branches;
next	1.1.1.13;
commitid	10046DB0574023300F5;

1.1.1.13
date	2007.09.13.13.38.56;	author tg;	state Exp;
branches;
next	1.1.1.14;
commitid	10046E93D7724AAC1F8;

1.1.1.14
date	2008.03.02.20.40.41;	author tg;	state Exp;
branches;
next	1.1.1.15;
commitid	10047CB10DD30FAF062;

1.1.1.15
date	2008.04.03.18.34.31;	author tg;	state Exp;
branches;
next	1.1.1.16;
commitid	10047F5234C593EA799;

1.1.1.16
date	2008.12.16.20.15.33;	author tg;	state Exp;
branches;
next	1.1.1.17;
commitid	10049480C7A2701F5C0;

1.1.1.17
date	2009.03.22.12.03.00;	author tg;	state Exp;
branches;
next	1.1.1.18;
commitid	10049C6290649163EA3;

1.1.1.18
date	2009.10.04.13.25.45;	author tg;	state Exp;
branches;
next	1.1.1.19;
commitid	1004AC8A2663BC008C5;

1.1.1.19
date	2016.03.25.18.26.19;	author tg;	state Exp;
branches;
next	;
commitid	10056F582DE1D4A62E2;


desc
@@


1.24
log
@fastmerge
@
text
@/* $OpenBSD: session.c,v 1.246 2009/04/17 19:23:06 stevesk Exp $ */
/*
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 * SSH2 support by Markus Friedl.
 * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/wait.h>
#include <sys/un.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/queue.h>

#include <ctype.h>
#include <errno.h>
#include <grp.h>
#include <login_cap.h>
#include <paths.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "xmalloc.h"
#include "ssh.h"
#include "ssh1.h"
#include "ssh2.h"
#include "sshpty.h"
#include "packet.h"
#include "buffer.h"
#include "match.h"
#include "uidswap.h"
#include "compat.h"
#include "channels.h"
#include "key.h"
#include "cipher.h"
#include "kex.h"
#include "hostfile.h"
#include "auth.h"
#include "auth-options.h"
#include "pathnames.h"
#include "log.h"
#include "servconf.h"
#include "sshlogin.h"
#include "serverloop.h"
#include "canohost.h"
#include "misc.h"
#include "session.h"
#include "monitor_wrap.h"
#include "sftp.h"

__RCSID("$MirOS: src/usr.bin/ssh/session.c,v 1.23 2009/10/04 14:29:07 tg Exp $");

#define IS_INTERNAL_SFTP(c) \
	(!strncmp(c, INTERNAL_SFTP_NAME, sizeof(INTERNAL_SFTP_NAME) - 1) && \
	 (c[sizeof(INTERNAL_SFTP_NAME) - 1] == '\0' || \
	  c[sizeof(INTERNAL_SFTP_NAME) - 1] == ' ' || \
	  c[sizeof(INTERNAL_SFTP_NAME) - 1] == '\t'))

/* func */

void	session_set_fds(Session *, int, int, int, int);
void	session_pty_cleanup(Session *);
void	session_proctitle(Session *);
int	session_setup_x11fwd(Session *);
int	do_exec_pty(Session *, const char *);
int	do_exec_no_pty(Session *, const char *);
int	do_exec(Session *, const char *);
void	do_login(Session *, const char *);
void	do_child(Session *, const char *) __dead;
void	do_motd(void);
int	check_quietlogin(Session *, const char *);

static void do_authenticated1(Authctxt *);
static void do_authenticated2(Authctxt *);

static int session_pty_req(Session *);

/* import */
extern ServerOptions options;
extern char *__progname;
extern int log_stderr;
extern int debug_flag;
extern u_int utmp_len;
extern int startup_pipe;
extern void destroy_sensitive_data(void);
extern Buffer loginmsg;

/* original command from peer. */
const char *original_command = NULL;

/* data */
static int sessions_first_unused = -1;
static int sessions_nalloc = 0;
static Session *sessions = NULL;

#define SUBSYSTEM_NONE		0
#define SUBSYSTEM_EXT		1
#define SUBSYSTEM_INT_SFTP	2

login_cap_t *lc;

static int is_child = 0;

/* Name and directory of socket for authentication agent forwarding. */
static char *auth_sock_name = NULL;
static char *auth_sock_dir = NULL;

/* removes the agent forwarding socket */

static void
auth_sock_cleanup_proc(struct passwd *pw)
{
	if (auth_sock_name != NULL) {
		temporarily_use_uid(pw);
		unlink(auth_sock_name);
		rmdir(auth_sock_dir);
		auth_sock_name = NULL;
		restore_uid();
	}
}

static int
auth_input_request_forwarding(struct passwd * pw)
{
	Channel *nc;
	int sock = -1;
	struct sockaddr_un sunaddr;

	if (auth_sock_name != NULL) {
		error("authentication forwarding requested twice.");
		return 0;
	}

	/* Temporarily drop privileged uid for mkdir/bind. */
	temporarily_use_uid(pw);

	/* Allocate a buffer for the socket name, and format the name. */
	auth_sock_dir = xstrdup("/tmp/ssh-XXXXXXXXXX");

	/* Create private directory for socket */
	if (mkdtemp(auth_sock_dir) == NULL) {
		packet_send_debug("Agent forwarding disabled: "
		    "mkdtemp() failed: %.100s", strerror(errno));
		restore_uid();
		xfree(auth_sock_dir);
		auth_sock_dir = NULL;
		goto authsock_err;
	}

	xasprintf(&auth_sock_name, "%s/agent.%ld",
	    auth_sock_dir, (long) getpid());

	/* Create the socket. */
	sock = socket(AF_UNIX, SOCK_STREAM, 0);
	if (sock < 0) {
		error("socket: %.100s", strerror(errno));
		restore_uid();
		goto authsock_err;
	}

	/* Bind it to the name. */
	memset(&sunaddr, 0, sizeof(sunaddr));
	sunaddr.sun_family = AF_UNIX;
	strlcpy(sunaddr.sun_path, auth_sock_name, sizeof(sunaddr.sun_path));

	if (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {
		error("bind: %.100s", strerror(errno));
		restore_uid();
		goto authsock_err;
	}

	/* Restore the privileged uid. */
	restore_uid();

	/* Start listening on the socket. */
	if (listen(sock, SSH_LISTEN_BACKLOG) < 0) {
		error("listen: %.100s", strerror(errno));
		goto authsock_err;
	}

	/* Allocate a channel for the authentication agent socket. */
	nc = channel_new("auth socket",
	    SSH_CHANNEL_AUTH_SOCKET, sock, sock, -1,
	    CHAN_X11_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT,
	    0, "auth socket", 1);
	nc->path = xstrdup(auth_sock_name);
	return 1;

 authsock_err:
	if (auth_sock_name != NULL)
		xfree(auth_sock_name);
	if (auth_sock_dir != NULL) {
		rmdir(auth_sock_dir);
		xfree(auth_sock_dir);
	}
	if (sock != -1)
		close(sock);
	auth_sock_name = NULL;
	auth_sock_dir = NULL;
	return 0;
}

static void
display_loginmsg(void)
{
	if (buffer_len(&loginmsg) > 0) {
		buffer_append(&loginmsg, "\0", 1);
		printf("%s", (char *)buffer_ptr(&loginmsg));
		buffer_clear(&loginmsg);
	}
}

void
do_authenticated(Authctxt *authctxt)
{
	setproctitle("%s", authctxt->pw->pw_name);

	/* setup the channel layer */
	if (!no_port_forwarding_flag && options.allow_tcp_forwarding)
		channel_permit_all_opens();

	if (compat20)
		do_authenticated2(authctxt);
	else
		do_authenticated1(authctxt);

	do_cleanup(authctxt);
}

/* Check untrusted xauth strings for metacharacters */
static int
xauth_valid_string(const char *s)
{
	size_t i;

	for (i = 0; s[i] != '\0'; i++) {
		if (!isalnum((u_char)s[i]) &&
		    s[i] != '.' && s[i] != ':' && s[i] != '/' &&
		    s[i] != '-' && s[i] != '_')
		return 0;
	}
	return 1;
}

/*
 * Prepares for an interactive session.  This is called after the user has
 * been successfully authenticated.  During this message exchange, pseudo
 * terminals are allocated, X11, TCP/IP, and authentication agent forwardings
 * are requested, etc.
 */
static void
do_authenticated1(Authctxt *authctxt)
{
	Session *s;
	char *command;
	int success, type, screen_flag;
	int enable_compression_after_reply = 0;
	u_int proto_len, data_len, dlen, compression_level = 0;

	s = session_new();
	if (s == NULL) {
		error("no more sessions");
		return;
	}
	s->authctxt = authctxt;
	s->pw = authctxt->pw;

	/*
	 * We stay in this loop until the client requests to execute a shell
	 * or a command.
	 */
	for (;;) {
		success = 0;

		/* Get a packet from the client. */
		type = packet_read();

		/* Process the packet. */
		switch (type) {
		case SSH_CMSG_REQUEST_COMPRESSION:
			compression_level = packet_get_int();
			packet_check_eom();
			if (compression_level < 1 || compression_level > 9) {
				packet_send_debug("Received invalid compression level %d.",
				    compression_level);
				break;
			}
			if (options.compression == COMP_NONE) {
				debug2("compression disabled");
				break;
			}
			/* Enable compression after we have responded with SUCCESS. */
			enable_compression_after_reply = 1;
			success = 1;
			break;

		case SSH_CMSG_REQUEST_PTY:
			success = session_pty_req(s);
			break;

		case SSH_CMSG_X11_REQUEST_FORWARDING:
			s->auth_proto = packet_get_string(&proto_len);
			s->auth_data = packet_get_string(&data_len);

			screen_flag = packet_get_protocol_flags() &
			    SSH_PROTOFLAG_SCREEN_NUMBER;
			debug2("SSH_PROTOFLAG_SCREEN_NUMBER: %d", screen_flag);

			if (packet_remaining() == 4) {
				if (!screen_flag)
					debug2("Buggy client: "
					    "X11 screen flag missing");
				s->screen = packet_get_int();
			} else {
				s->screen = 0;
			}
			packet_check_eom();
			if (xauth_valid_string(s->auth_proto) &&
			    xauth_valid_string(s->auth_data))
				success = session_setup_x11fwd(s);
			else {
				success = 0;
				error("Invalid X11 forwarding data");
			}
			if (!success) {
				xfree(s->auth_proto);
				xfree(s->auth_data);
				s->auth_proto = NULL;
				s->auth_data = NULL;
			}
			break;

		case SSH_CMSG_AGENT_REQUEST_FORWARDING:
			if (!options.allow_agent_forwarding ||
			    no_agent_forwarding_flag || compat13) {
				debug("Authentication agent forwarding not permitted for this authentication.");
				break;
			}
			debug("Received authentication agent forwarding request.");
			success = auth_input_request_forwarding(s->pw);
			break;

		case SSH_CMSG_PORT_FORWARD_REQUEST:
			if (no_port_forwarding_flag) {
				debug("Port forwarding not permitted for this authentication.");
				break;
			}
			if (!options.allow_tcp_forwarding) {
				debug("Port forwarding not permitted.");
				break;
			}
			debug("Received TCP/IP port forwarding request.");
			if (channel_input_port_forward_request(s->pw->pw_uid == 0,
			    options.gateway_ports) < 0) {
				debug("Port forwarding failed.");
				break;
			}
			success = 1;
			break;

		case SSH_CMSG_MAX_PACKET_SIZE:
			if (packet_set_maxsize(packet_get_int()) > 0)
				success = 1;
			break;

		case SSH_CMSG_EXEC_SHELL:
		case SSH_CMSG_EXEC_CMD:
			if (type == SSH_CMSG_EXEC_CMD) {
				command = packet_get_string(&dlen);
				debug("Exec command '%.500s'", command);
				if (do_exec(s, command) != 0)
					packet_disconnect(
					    "command execution failed");
				xfree(command);
			} else {
				if (do_exec(s, NULL) != 0)
					packet_disconnect(
					    "shell execution failed");
			}
			packet_check_eom();
			session_close(s);
			return;

		default:
			/*
			 * Any unknown messages in this phase are ignored,
			 * and a failure message is returned.
			 */
			logit("Unknown packet type received after authentication: %d", type);
		}
		packet_start(success ? SSH_SMSG_SUCCESS : SSH_SMSG_FAILURE);
		packet_send();
		packet_write_wait();

		/* Enable compression now that we have replied if appropriate. */
		if (enable_compression_after_reply) {
			enable_compression_after_reply = 0;
			packet_start_compression(compression_level);
		}
	}
}

#define USE_PIPES
/*
 * This is called to fork and execute a command when we have no tty.  This
 * will call do_child from the child, and server_loop from the parent after
 * setting up file descriptors and such.
 */
int
do_exec_no_pty(Session *s, const char *command)
{
	pid_t pid;
#ifdef USE_PIPES
	int pin[2], pout[2], perr[2];

	/* Allocate pipes for communicating with the program. */
	if (pipe(pin) < 0) {
		error("%s: pipe in: %.100s", __func__, strerror(errno));
		return -1;
	}
	if (pipe(pout) < 0) {
		error("%s: pipe out: %.100s", __func__, strerror(errno));
		close(pin[0]);
		close(pin[1]);
		return -1;
	}
	if (pipe(perr) < 0) {
		error("%s: pipe err: %.100s", __func__, strerror(errno));
		close(pin[0]);
		close(pin[1]);
		close(pout[0]);
		close(pout[1]);
		return -1;
	}
#else
	int inout[2], err[2];

	/* Uses socket pairs to communicate with the program. */
	if (socketpair(AF_UNIX, SOCK_STREAM, 0, inout) < 0) {
		error("%s: socketpair #1: %.100s", __func__, strerror(errno));
		return -1;
	}
	if (socketpair(AF_UNIX, SOCK_STREAM, 0, err) < 0) {
		error("%s: socketpair #2: %.100s", __func__, strerror(errno));
		close(inout[0]);
		close(inout[1]);
		return -1;
	}
#endif

	if (s == NULL)
		fatal("do_exec_no_pty: no session");

	session_proctitle(s);

	/* Fork the child. */
	switch ((pid = fork())) {
	case -1:
		error("%s: fork: %.100s", __func__, strerror(errno));
#ifdef USE_PIPES
		close(pin[0]);
		close(pin[1]);
		close(pout[0]);
		close(pout[1]);
		close(perr[0]);
		close(perr[1]);
#else
		close(inout[0]);
		close(inout[1]);
		close(err[0]);
		close(err[1]);
#endif
		return -1;
	case 0:
		is_child = 1;

		/* Child.  Reinitialize the log since the pid has changed. */
		log_init(__progname, options.log_level,
		    options.log_facility, log_stderr);

		/*
		 * Create a new session and process group since the 4.4BSD
		 * setlogin() affects the entire process group.
		 */
		if (setsid() < 0)
			error("setsid failed: %.100s", strerror(errno));

#ifdef USE_PIPES
		/*
		 * Redirect stdin.  We close the parent side of the socket
		 * pair, and make the child side the standard input.
		 */
		close(pin[1]);
		if (dup2(pin[0], 0) < 0)
			perror("dup2 stdin");
		close(pin[0]);

		/* Redirect stdout. */
		close(pout[0]);
		if (dup2(pout[1], 1) < 0)
			perror("dup2 stdout");
		close(pout[1]);

		/* Redirect stderr. */
		close(perr[0]);
		if (dup2(perr[1], 2) < 0)
			perror("dup2 stderr");
		close(perr[1]);
#else
		/*
		 * Redirect stdin, stdout, and stderr.  Stdin and stdout will
		 * use the same socket, as some programs (particularly rdist)
		 * seem to depend on it.
		 */
		close(inout[1]);
		close(err[1]);
		if (dup2(inout[0], 0) < 0)	/* stdin */
			perror("dup2 stdin");
		if (dup2(inout[0], 1) < 0)	/* stdout (same as stdin) */
			perror("dup2 stdout");
		close(inout[0]);
		if (dup2(err[0], 2) < 0)	/* stderr */
			perror("dup2 stderr");
		close(err[0]);
#endif

		/* Do processing for the child (exec command etc). */
		do_child(s, command);
		/* NOTREACHED */
	default:
		break;
	}

	s->pid = pid;
	/* Set interactive/non-interactive mode. */
	packet_set_interactive(s->display != NULL);

#ifdef USE_PIPES
	/* We are the parent.  Close the child sides of the pipes. */
	close(pin[0]);
	close(pout[1]);
	close(perr[1]);

	if (compat20) {
		if (s->is_subsystem) {
			close(perr[0]);
			perr[0] = -1;
		}
		session_set_fds(s, pin[1], pout[0], perr[0], 0);
	} else {
		/* Enter the interactive session. */
		server_loop(pid, pin[1], pout[0], perr[0]);
		/* server_loop has closed pin[1], pout[0], and perr[0]. */
	}
#else
	/* We are the parent.  Close the child sides of the socket pairs. */
	close(inout[0]);
	close(err[0]);

	/*
	 * Enter the interactive session.  Note: server_loop must be able to
	 * handle the case that fdin and fdout are the same.
	 */
	if (compat20) {
		session_set_fds(s, inout[1], inout[1],
		    s->is_subsystem ? -1 : err[1], 0);
		if (s->is_subsystem)
			close(err[1]);
	} else {
		server_loop(pid, inout[1], inout[1], err[1]);
		/* server_loop has closed inout[1] and err[1]. */
	}
#endif
	return 0;
}

/*
 * This is called to fork and execute a command when we have a tty.  This
 * will call do_child from the child, and server_loop from the parent after
 * setting up file descriptors, controlling tty, updating wtmp, utmp,
 * lastlog, and other such operations.
 */
int
do_exec_pty(Session *s, const char *command)
{
	int fdout, ptyfd, ttyfd, ptymaster;
	pid_t pid;

	if (s == NULL)
		fatal("do_exec_pty: no session");
	ptyfd = s->ptyfd;
	ttyfd = s->ttyfd;

	/*
	 * Create another descriptor of the pty master side for use as the
	 * standard input.  We could use the original descriptor, but this
	 * simplifies code in server_loop.  The descriptor is bidirectional.
	 * Do this before forking (and cleanup in the child) so as to
	 * detect and gracefully fail out-of-fd conditions.
	 */
	if ((fdout = dup(ptyfd)) < 0) {
		error("%s: dup #1: %s", __func__, strerror(errno));
		close(ttyfd);
		close(ptyfd);
		return -1;
	}
	/* we keep a reference to the pty master */
	if ((ptymaster = dup(ptyfd)) < 0) {
		error("%s: dup #2: %s", __func__, strerror(errno));
		close(ttyfd);
		close(ptyfd);
		close(fdout);
		return -1;
	}

	/* Fork the child. */
	switch ((pid = fork())) {
	case -1:
		error("%s: fork: %.100s", __func__, strerror(errno));
		close(fdout);
		close(ptymaster);
		close(ttyfd);
		close(ptyfd);
		return -1;
	case 0:
		is_child = 1;

		close(fdout);
		close(ptymaster);

		/* Child.  Reinitialize the log because the pid has changed. */
		log_init(__progname, options.log_level,
		    options.log_facility, log_stderr);
		/* Close the master side of the pseudo tty. */
		close(ptyfd);

		/* Make the pseudo tty our controlling tty. */
		pty_make_controlling_tty(&ttyfd, s->tty);

		/* Redirect stdin/stdout/stderr from the pseudo tty. */
		if (dup2(ttyfd, 0) < 0)
			error("dup2 stdin: %s", strerror(errno));
		if (dup2(ttyfd, 1) < 0)
			error("dup2 stdout: %s", strerror(errno));
		if (dup2(ttyfd, 2) < 0)
			error("dup2 stderr: %s", strerror(errno));

		/* Close the extra descriptor for the pseudo tty. */
		close(ttyfd);

		/* record login, etc. similar to login(1) */
		if (!(options.use_login && command == NULL))
			do_login(s, command);

		/*
		 * Do common processing for the child, such as execing
		 * the command.
		 */
		do_child(s, command);
		/* NOTREACHED */
	default:
		break;
	}
	s->pid = pid;

	/* Parent.  Close the slave side of the pseudo tty. */
	close(ttyfd);

	/* Enter interactive session. */
	s->ptymaster = ptymaster;
	packet_set_interactive(1);
	if (compat20) {
		session_set_fds(s, ptyfd, fdout, -1, 1);
	} else {
		server_loop(pid, ptyfd, fdout, -1);
		/* server_loop _has_ closed ptyfd and fdout. */
	}
	return 0;
}

/*
 * This is called to fork and execute a command.  If another command is
 * to be forced, execute that instead.
 */
int
do_exec(Session *s, const char *command)
{
	int ret;

	if (options.adm_forced_command) {
		original_command = command;
		command = options.adm_forced_command;
#ifndef SMALL
		if (IS_INTERNAL_SFTP(command))
			s->is_subsystem = SUBSYSTEM_INT_SFTP;
		else
#endif
		if (s->is_subsystem)
			s->is_subsystem = SUBSYSTEM_EXT;
		debug("Forced command (config) '%.900s'", command);
	} else if (forced_command) {
		original_command = command;
		command = forced_command;
#ifndef SMALL
		if (IS_INTERNAL_SFTP(command))
			s->is_subsystem = SUBSYSTEM_INT_SFTP;
		else
#endif
		if (s->is_subsystem)
			s->is_subsystem = SUBSYSTEM_EXT;
		debug("Forced command (key option) '%.900s'", command);
	}

	if (s->ttyfd != -1)
		ret = do_exec_pty(s, command);
	else
		ret = do_exec_no_pty(s, command);

	original_command = NULL;

	/*
	 * Clear loginmsg: it's the child's responsibility to display
	 * it to the user, otherwise multiple sessions may accumulate
	 * multiple copies of the login messages.
	 */
	buffer_clear(&loginmsg);

	return ret;
}


/* administrative, login(1)-like work */
void
do_login(Session *s, const char *command)
{
	socklen_t fromlen;
	struct sockaddr_storage from;
	struct passwd * pw = s->pw;
	pid_t pid = getpid();

	/*
	 * Get IP address of client. If the connection is not a socket, let
	 * the address be 0.0.0.0.
	 */
	memset(&from, 0, sizeof(from));
	fromlen = sizeof(from);
	if (packet_connection_is_on_socket()) {
		if (getpeername(packet_get_connection_in(),
		    (struct sockaddr *)&from, &fromlen) < 0) {
			debug("getpeername: %.100s", strerror(errno));
			cleanup_exit(255);
		}
	}

	/* Record that there was a login on that tty from the remote host. */
	if (!use_privsep)
		record_login(pid, s->tty, pw->pw_name, pw->pw_uid,
		    get_remote_name_or_ip(utmp_len,
		    options.use_dns),
		    (struct sockaddr *)&from, fromlen);

	if (check_quietlogin(s, command))
		return;

	display_loginmsg();

	do_motd();
}

/*
 * Display the message of the day.
 */
void
do_motd(void)
{
	FILE *f;
	char buf[256];

	if (options.print_motd) {
		f = fopen(login_getcapstr(lc, (char *)"welcome",
		    (char *)"/etc/motd", (char *)"/etc/motd"), "r");
		if (f) {
			while (fgets(buf, sizeof(buf), f))
				fputs(buf, stdout);
			fclose(f);
		}
	}
}


/*
 * Check for quiet login, either .hushlogin or command given.
 */
int
check_quietlogin(Session *s, const char *command)
{
	char buf[256];
	struct passwd *pw = s->pw;
	struct stat st;

	/* Return 1 if .hushlogin exists or a command given. */
	if (command != NULL)
		return 1;
	snprintf(buf, sizeof(buf), "%.200s/.hushlogin", pw->pw_dir);
	if (login_getcapbool(lc, (char *)"hushlogin", 0) || stat(buf, &st) >= 0)
		return 1;
	return 0;
}

/*
 * Sets the value of the given variable in the environment.  If the variable
 * already exists, its value is overridden.
 */
void
child_set_env(char ***envp, u_int *envsizep, const char *name,
	const char *value)
{
	char **env;
	u_int envsize;
	u_int i, namelen;

	/*
	 * Find the slot where the value should be stored.  If the variable
	 * already exists, we reuse the slot; otherwise we append a new slot
	 * at the end of the array, expanding if necessary.
	 */
	env = *envp;
	namelen = strlen(name);
	for (i = 0; env[i]; i++)
		if (strncmp(env[i], name, namelen) == 0 && env[i][namelen] == '=')
			break;
	if (env[i]) {
		/* Reuse the slot. */
		xfree(env[i]);
	} else {
		/* New variable.  Expand if necessary. */
		envsize = *envsizep;
		if (i >= envsize - 1) {
			if (envsize >= 1000)
				fatal("child_set_env: too many env vars");
			envsize += 50;
			env = (*envp) = xrealloc(env, envsize, sizeof(char *));
			*envsizep = envsize;
		}
		/* Need to set the NULL pointer at end of array beyond the new slot. */
		env[i + 1] = NULL;
	}

	/* Allocate space and format the variable in the appropriate slot. */
	env[i] = xmalloc(strlen(name) + 1 + strlen(value) + 1);
	snprintf(env[i], strlen(name) + 1 + strlen(value) + 1, "%s=%s", name, value);
}

/*
 * Reads environment variables from the given file and adds/overrides them
 * into the environment.  If the file does not exist, this does nothing.
 * Otherwise, it must consist of empty lines, comments (line starts with '#')
 * and assignments of the form name=value.  No other forms are allowed.
 */
static void
read_environment_file(char ***env, u_int *envsize,
	const char *filename)
{
	FILE *f;
	char buf[4096];
	char *cp, *value;
	u_int lineno = 0;

	f = fopen(filename, "r");
	if (!f)
		return;

	while (fgets(buf, sizeof(buf), f)) {
		if (++lineno > 1000)
			fatal("Too many lines in environment file %s", filename);
		for (cp = buf; *cp == ' ' || *cp == '\t'; cp++)
			;
		if (!*cp || *cp == '#' || *cp == '\n')
			continue;

		cp[strcspn(cp, "\n")] = '\0';

		value = strchr(cp, '=');
		if (value == NULL) {
			fprintf(stderr, "Bad line %u in %.100s\n", lineno,
			    filename);
			continue;
		}
		/*
		 * Replace the equals sign by nul, and advance value to
		 * the value string.
		 */
		*value = '\0';
		value++;
		child_set_env(env, envsize, cp, value);
	}
	fclose(f);
}

static char **
do_setup_env(Session *s, const char *shell)
{
	char buf[256];
	u_int i, envsize;
	char **env, *laddr;
	struct passwd *pw = s->pw;

	/* Initialize the environment. */
	envsize = 100;
	env = xcalloc(envsize, sizeof(char *));
	env[0] = NULL;

	if (!options.use_login) {
		/* Set basic environment. */
		for (i = 0; i < s->num_env; i++)
			child_set_env(&env, &envsize, s->env[i].name,
			    s->env[i].val);

		child_set_env(&env, &envsize, "USER", pw->pw_name);
		child_set_env(&env, &envsize, "LOGNAME", pw->pw_name);
		child_set_env(&env, &envsize, "HOME", pw->pw_dir);
		if (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETPATH) < 0)
			child_set_env(&env, &envsize, "PATH", _PATH_STDPATH);
		else
			child_set_env(&env, &envsize, "PATH", getenv("PATH"));

		snprintf(buf, sizeof buf, "%.200s/%.50s",
			 _PATH_MAILDIR, pw->pw_name);
		child_set_env(&env, &envsize, "MAIL", buf);

		/* Normal systems set SHELL by default. */
		child_set_env(&env, &envsize, "SHELL", shell);
	}
	if (getenv("TZ"))
		child_set_env(&env, &envsize, "TZ", getenv("TZ"));

	/* Set custom environment options from RSA authentication. */
	if (!options.use_login) {
		while (custom_environment) {
			struct envstring *ce = custom_environment;
			char *str = ce->s;

			for (i = 0; str[i] != '=' && str[i]; i++)
				;
			if (str[i] == '=') {
				str[i] = 0;
				child_set_env(&env, &envsize, str, str + i + 1);
			}
			custom_environment = ce->next;
			xfree(ce->s);
			xfree(ce);
		}
	}

	/* SSH_CLIENT deprecated */
	snprintf(buf, sizeof buf, "%.50s %d %d",
	    get_remote_ipaddr(), get_remote_port(), get_local_port());
	child_set_env(&env, &envsize, "SSH_CLIENT", buf);

	laddr = get_local_ipaddr(packet_get_connection_in());
	snprintf(buf, sizeof buf, "%.50s %d %.50s %d",
	    get_remote_ipaddr(), get_remote_port(), laddr, get_local_port());
	xfree(laddr);
	child_set_env(&env, &envsize, "SSH_CONNECTION", buf);

	if (s->ttyfd != -1)
		child_set_env(&env, &envsize, "SSH_TTY", s->tty);
	if (s->term)
		child_set_env(&env, &envsize, "TERM", s->term);
	if (s->display)
		child_set_env(&env, &envsize, "DISPLAY", s->display);
	if (original_command)
		child_set_env(&env, &envsize, "SSH_ORIGINAL_COMMAND",
		    original_command);
	if (auth_sock_name != NULL)
		child_set_env(&env, &envsize, SSH_AUTHSOCKET_ENV_NAME,
		    auth_sock_name);

	/* read $HOME/.etc/ssh/environment. */
	if (options.permit_user_env && !options.use_login) {
		snprintf(buf, sizeof buf, "%.200s/.etc/ssh/environment",
		    pw->pw_dir);
		read_environment_file(&env, &envsize, buf);
	}
	if (debug_flag) {
		/* dump the environment */
		fprintf(stderr, "Environment:\n");
		for (i = 0; env[i]; i++)
			fprintf(stderr, "  %.200s\n", env[i]);
	}
	return env;
}

/*
 * Run $HOME/.etc/ssh/rc, /etc/ssh/sshrc, or xauth (whichever is found
 * first in this order).
 */
static void
do_rc_files(Session *s, const char *shell)
{
	FILE *f = NULL;
	char cmd[1024];
	int do_xauth;
	struct stat st;

	do_xauth =
	    s->display != NULL && s->auth_proto != NULL && s->auth_data != NULL;

	/* ignore _PATH_SSH_USER_RC for subsystems and admin forced commands */
	if (!s->is_subsystem && options.adm_forced_command == NULL &&
	    !no_user_rc && stat(_PATH_SSH_USER_RC, &st) >= 0) {
		snprintf(cmd, sizeof cmd, "%s -c '%s %s'",
		    shell, _PATH_BSHELL, _PATH_SSH_USER_RC);
		if (debug_flag)
			fprintf(stderr, "Running %s\n", cmd);
		f = popen(cmd, "w");
		if (f) {
			if (do_xauth)
				fprintf(f, "%s %s\n", s->auth_proto,
				    s->auth_data);
			pclose(f);
		} else
			fprintf(stderr, "Could not run %s\n",
			    _PATH_SSH_USER_RC);
	} else if (stat(_PATH_SSH_SYSTEM_RC, &st) >= 0) {
		if (debug_flag)
			fprintf(stderr, "Running %s %s\n", _PATH_BSHELL,
			    _PATH_SSH_SYSTEM_RC);
		f = popen(_PATH_BSHELL " " _PATH_SSH_SYSTEM_RC, "w");
		if (f) {
			if (do_xauth)
				fprintf(f, "%s %s\n", s->auth_proto,
				    s->auth_data);
			pclose(f);
		} else
			fprintf(stderr, "Could not run %s\n",
			    _PATH_SSH_SYSTEM_RC);
	} else if (do_xauth && options.xauth_location != NULL) {
		/* Add authority data to .Xauthority if appropriate. */
		if (debug_flag) {
			fprintf(stderr,
			    "Running %.500s remove %.100s\n",
			    options.xauth_location, s->auth_display);
			fprintf(stderr,
			    "%.500s add %.100s %.100s %.100s\n",
			    options.xauth_location, s->auth_display,
			    s->auth_proto, s->auth_data);
		}
		snprintf(cmd, sizeof cmd, "%s -q -",
		    options.xauth_location);
		f = popen(cmd, "w");
		if (f) {
			fprintf(f, "remove %s\n",
			    s->auth_display);
			fprintf(f, "add %s %s %s\n",
			    s->auth_display, s->auth_proto,
			    s->auth_data);
			pclose(f);
		} else {
			fprintf(stderr, "Could not run %s\n",
			    cmd);
		}
	}
}

static void
do_nologin(struct passwd *pw)
{
	FILE *f = NULL;
	char buf[1024];

	if (!login_getcapbool(lc, (char *)"ignorenologin", 0) && pw->pw_uid)
		f = fopen(login_getcapstr(lc, (char *)"nologin",
		    (char *)_PATH_NOLOGIN, (char *)_PATH_NOLOGIN), (char *)"r");
	if (f) {
		/* /etc/nologin exists.  Print its contents and exit. */
		logit("User %.100s not allowed because %s exists",
		    pw->pw_name, _PATH_NOLOGIN);
		while (fgets(buf, sizeof(buf), f))
			fputs(buf, stderr);
		fclose(f);
		exit(254);
	}
}

/*
 * Chroot into a directory after checking it for safety: all path components
 * must be root-owned directories with strict permissions.
 */
static void
safely_chroot(const char *path, uid_t uid)
{
	const char *cp;
	char component[MAXPATHLEN];
	struct stat st;

	if (*path != '/')
		fatal("chroot path does not begin at root");
	if (strlen(path) >= sizeof(component))
		fatal("chroot path too long");

	/*
	 * Descend the path, checking that each component is a
	 * root-owned directory with strict permissions.
	 */
	for (cp = path; cp != NULL;) {
		if ((cp = strchr(cp, '/')) == NULL)
			strlcpy(component, path, sizeof(component));
		else {
			cp++;
			memcpy(component, path, cp - path);
			component[cp - path] = '\0';
		}
	
		debug3("%s: checking '%s'", __func__, component);

		if (stat(component, &st) != 0)
			fatal("%s: stat(\"%s\"): %s", __func__,
			    component, strerror(errno));
		if (st.st_uid != 0 || (st.st_mode & 022) != 0)
			fatal("bad ownership or modes for chroot "
			    "directory %s\"%s\"", 
			    cp == NULL ? "" : "component ", component);
		if (!S_ISDIR(st.st_mode))
			fatal("chroot path %s\"%s\" is not a directory",
			    cp == NULL ? "" : "component ", component);

	}

	if (chdir(path) == -1)
		fatal("Unable to chdir to chroot path \"%s\": "
		    "%s", path, strerror(errno));
	if (chroot(path) == -1)
		fatal("chroot(\"%s\"): %s", path, strerror(errno));
	if (chdir("/") == -1)
		fatal("%s: chdir(/) after chroot: %s",
		    __func__, strerror(errno));
	verbose("Changed root directory to \"%s\"", path);
}

/* Set login name, uid, gid, and groups. */
void
do_setusercontext(struct passwd *pw)
{
	char *chroot_path, *tmp;

	if (getuid() == 0 || geteuid() == 0) {
		/* Prepare groups */
		if (setusercontext(lc, pw, pw->pw_uid,
		    (LOGIN_SETALL & ~(LOGIN_SETPATH|LOGIN_SETUSER))) < 0) {
			perror("unable to set user context");
			exit(1);
		}

		if (options.chroot_directory != NULL &&
		    strcasecmp(options.chroot_directory, "none") != 0) {
                        tmp = tilde_expand_filename(options.chroot_directory,
			    pw->pw_uid);
			chroot_path = percent_expand(tmp, "h", pw->pw_dir,
			    "u", pw->pw_name, (char *)NULL);
			safely_chroot(chroot_path, pw->pw_uid);
			free(tmp);
			free(chroot_path);
		}

		/* Set UID */
		if (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETUSER) < 0) {
			perror("unable to set user context (setuser)");
			exit(1);
		}
	}
	if (getuid() != pw->pw_uid || geteuid() != pw->pw_uid)
		fatal("Failed to set uids to %u.", (u_int) pw->pw_uid);
}

static void
do_pwchange(Session *s)
{
	fflush(NULL);
	fprintf(stderr, "WARNING: Your password has expired.\n");
	if (s->ttyfd != -1) {
		fprintf(stderr,
		    "You must change your password now and login again!\n");
		execl(_PATH_PASSWD_PROG, "passwd", (char *)NULL);
		perror("passwd");
	} else {
		fprintf(stderr,
		    "Password change required but no TTY available.\n");
	}
	exit(1);
}

static void
launch_login(struct passwd *pw, const char *hostname)
{
	/* Launch login(1). */

	execl("/usr/bin/login", "login", "-h", hostname,
	    "-p", "-f", "--", pw->pw_name, (char *)NULL);

	/* Login couldn't be executed, die. */

	perror("login");
	exit(1);
}

static void
child_close_fds(void)
{
	int i;

	if (packet_get_connection_in() == packet_get_connection_out())
		close(packet_get_connection_in());
	else {
		close(packet_get_connection_in());
		close(packet_get_connection_out());
	}
	/*
	 * Close all descriptors related to channels.  They will still remain
	 * open in the parent.
	 */
	/* XXX better use close-on-exec? -markus */
	channel_close_all();

	/*
	 * Close any extra file descriptors.  Note that there may still be
	 * descriptors left by system functions.  They will be closed later.
	 */
	endpwent();

	/*
	 * Close any extra open file descriptors so that we don't have them
	 * hanging around in clients.  Note that we want to do this after
	 * initgroups, because at least on Solaris 2.3 it leaves file
	 * descriptors open.
	 */
	for (i = 3; i < 64; i++)
		close(i);
}

/*
 * Performs common processing for the child, such as setting up the
 * environment, closing extra file descriptors, setting the user and group
 * ids, and executing the command or shell.
 */
#define ARGV_MAX 10
void
do_child(Session *s, const char *command)
{
	extern char **environ;
	char **env;
	char *argv[ARGV_MAX];
	const char *shell, *shell0, *hostname = NULL;
	struct passwd *pw = s->pw;
	int r = 0;

	/* remove hostkey from the child's memory */
	destroy_sensitive_data();

	/* Force a password change */
	if (s->authctxt->force_pwchange) {
		do_setusercontext(pw);
		child_close_fds();
		do_pwchange(s);
		exit(1);
	}

	/* login(1) is only called if we execute the login shell */
	if (options.use_login && command != NULL)
		options.use_login = 0;

	/*
	 * Login(1) does this as well, and it needs uid 0 for the "-h"
	 * switch, so we let login(1) to this for us.
	 */
	if (!options.use_login) {
		do_nologin(pw);
		do_setusercontext(pw);
	}

	/*
	 * Get the shell from the password data.  An empty shell field is
	 * legal, and means /bin/sh.
	 */
	shell = (pw->pw_shell[0] == '\0') ? _PATH_BSHELL : pw->pw_shell;

	/*
	 * Make sure $SHELL points to the shell from the password file,
	 * even if shell is overridden from login.conf
	 */
	env = do_setup_env(s, shell);

	shell = login_getcapstr(lc, (char *)"shell", (char *)shell, (char *)shell);

	/* we have to stash the hostname before we close our socket. */
	if (options.use_login)
		hostname = get_remote_name_or_ip(utmp_len,
		    options.use_dns);
	/*
	 * Close the connection descriptors; note that this is the child, and
	 * the server will still have the socket open, and it is important
	 * that we do not shutdown it.  Note that the descriptors cannot be
	 * closed before building the environment, as we call
	 * get_remote_ipaddr there.
	 */
	child_close_fds();

	/*
	 * Must take new environment into use so that .etc/ssh/rc,
	 * /etc/ssh/sshrc and xauth are run in the proper environment.
	 */
	environ = env;

	/* Change current directory to the user's home directory. */
	if (chdir(pw->pw_dir) < 0) {
		/* Suppress missing homedir warning for chroot case */
		r = login_getcapbool(lc, (char *)"requirehome", 0);
		if (r || options.chroot_directory == NULL)
			fprintf(stderr, "Could not chdir to home "
			    "directory %s: %s\n", pw->pw_dir,
			    strerror(errno));
		if (r)
			exit(1);
	}

	closefrom(STDERR_FILENO + 1);

	if (!options.use_login)
		do_rc_files(s, shell);

	/* restore SIGPIPE for child */
	signal(SIGPIPE, SIG_DFL);

#ifndef SMALL
	if (s->is_subsystem == SUBSYSTEM_INT_SFTP) {
		int i;
		char *p, *args;

		setproctitle("%s@@%s", s->pw->pw_name, INTERNAL_SFTP_NAME);
		args = xstrdup(command ? command : "sftp-server");
		for (i = 0, (p = strtok(args, " ")); p; (p = strtok(NULL, " ")))
			if (i < ARGV_MAX - 1)
				argv[i++] = p;
		argv[i] = NULL;
		optind = optreset = 1;
		__progname = argv[0];
		exit(sftp_server_main(i, argv, s->pw));
	}
#endif

	if (options.use_login) {
		launch_login(pw, hostname);
		/* NEVERREACHED */
	}

	/* Get the last component of the shell name. */
	if ((shell0 = strrchr(shell, '/')) != NULL)
		shell0++;
	else
		shell0 = shell;

	/*
	 * If we have no command, execute the shell.  In this case, the shell
	 * name to be passed in argv[0] is preceded by '-' to indicate that
	 * this is a login shell.
	 */
	if (!command) {
		char argv0[256];

		/* Start the shell.  Set initial character to '-'. */
		argv0[0] = '-';

		if (strlcpy(argv0 + 1, shell0, sizeof(argv0) - 1)
		    >= sizeof(argv0) - 1) {
			errno = EINVAL;
			perror(shell);
			exit(1);
		}

		/* Execute the shell. */
		argv[0] = argv0;
		argv[1] = NULL;
		execve(shell, argv, env);

		/* Executing the shell failed. */
		perror(shell);
		exit(1);
	}
	/*
	 * Execute the command using the user's shell.  This uses the -c
	 * option to execute the command.
	 */
	argv[0] = (char *) shell0;
	argv[1] = (char *)"-c";
	argv[2] = (char *) command;
	argv[3] = NULL;
	execve(shell, argv, env);
	perror(shell);
	exit(1);
}

void
session_unused(int id)
{
	debug3("%s: session id %d unused", __func__, id);
	if (id >= options.max_sessions ||
	    id >= sessions_nalloc) {
		fatal("%s: insane session id %d (max %d nalloc %d)",
		    __func__, id, options.max_sessions, sessions_nalloc);
	}
	bzero(&sessions[id], sizeof(*sessions));
	sessions[id].self = id;
	sessions[id].used = 0;
	sessions[id].chanid = -1;
	sessions[id].ptyfd = -1;
	sessions[id].ttyfd = -1;
	sessions[id].ptymaster = -1;
	sessions[id].x11_chanids = NULL;
	sessions[id].next_unused = sessions_first_unused;
	sessions_first_unused = id;
}

Session *
session_new(void)
{
	Session *s, *tmp;

	if (sessions_first_unused == -1) {
		if (sessions_nalloc >= options.max_sessions)
			return NULL;
		debug2("%s: allocate (allocated %d max %d)",
		    __func__, sessions_nalloc, options.max_sessions);
		tmp = xrealloc(sessions, sessions_nalloc + 1,
		    sizeof(*sessions));
		if (tmp == NULL) {
			error("%s: cannot allocate %d sessions",
			    __func__, sessions_nalloc + 1);
			return NULL;
		}
		sessions = tmp;
		session_unused(sessions_nalloc++);
	}

	if (sessions_first_unused >= sessions_nalloc ||
	    sessions_first_unused < 0) {
		fatal("%s: insane first_unused %d max %d nalloc %d",
		    __func__, sessions_first_unused, options.max_sessions,
		    sessions_nalloc);
	}

	s = &sessions[sessions_first_unused];
	if (s->used) {
		fatal("%s: session %d already used",
		    __func__, sessions_first_unused);
	}
	sessions_first_unused = s->next_unused;
	s->used = 1;
	s->next_unused = -1;
	debug("session_new: session %d", s->self);

	return s;
}

static void
session_dump(void)
{
	int i;
	for (i = 0; i < sessions_nalloc; i++) {
		Session *s = &sessions[i];

		debug("dump: used %d next_unused %d session %d %p "
		    "channel %d pid %ld",
		    s->used,
		    s->next_unused,
		    s->self,
		    s,
		    s->chanid,
		    (long)s->pid);
	}
}

int
session_open(Authctxt *authctxt, int chanid)
{
	Session *s = session_new();
	debug("session_open: channel %d", chanid);
	if (s == NULL) {
		error("no more sessions");
		return 0;
	}
	s->authctxt = authctxt;
	s->pw = authctxt->pw;
	if (s->pw == NULL || !authctxt->valid)
		fatal("no user for session %d", s->self);
	debug("session_open: session %d: link with channel %d", s->self, chanid);
	s->chanid = chanid;
	return 1;
}

Session *
session_by_tty(char *tty)
{
	int i;
	for (i = 0; i < sessions_nalloc; i++) {
		Session *s = &sessions[i];
		if (s->used && s->ttyfd != -1 && strcmp(s->tty, tty) == 0) {
			debug("session_by_tty: session %d tty %s", i, tty);
			return s;
		}
	}
	debug("session_by_tty: unknown tty %.100s", tty);
	session_dump();
	return NULL;
}

static Session *
session_by_channel(int id)
{
	int i;
	for (i = 0; i < sessions_nalloc; i++) {
		Session *s = &sessions[i];
		if (s->used && s->chanid == id) {
			debug("session_by_channel: session %d channel %d",
			    i, id);
			return s;
		}
	}
	debug("session_by_channel: unknown channel %d", id);
	session_dump();
	return NULL;
}

static Session *
session_by_x11_channel(int id)
{
	int i, j;

	for (i = 0; i < sessions_nalloc; i++) {
		Session *s = &sessions[i];

		if (s->x11_chanids == NULL || !s->used)
			continue;
		for (j = 0; s->x11_chanids[j] != -1; j++) {
			if (s->x11_chanids[j] == id) {
				debug("session_by_x11_channel: session %d "
				    "channel %d", s->self, id);
				return s;
			}
		}
	}
	debug("session_by_x11_channel: unknown channel %d", id);
	session_dump();
	return NULL;
}

static Session *
session_by_pid(pid_t pid)
{
	int i;
	debug("session_by_pid: pid %ld", (long)pid);
	for (i = 0; i < sessions_nalloc; i++) {
		Session *s = &sessions[i];
		if (s->used && s->pid == pid)
			return s;
	}
	error("session_by_pid: unknown pid %ld", (long)pid);
	session_dump();
	return NULL;
}

static int
session_window_change_req(Session *s)
{
	s->col = packet_get_int();
	s->row = packet_get_int();
	s->xpixel = packet_get_int();
	s->ypixel = packet_get_int();
	packet_check_eom();
	pty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);
	return 1;
}

static int
session_pty_req(Session *s)
{
	u_int len;
	int n_bytes;

	if (no_pty_flag) {
		debug("Allocating a pty not permitted for this authentication.");
		return 0;
	}
	if (s->ttyfd != -1) {
		packet_disconnect("Protocol error: you already have a pty.");
		return 0;
	}

	s->term = packet_get_string(&len);

	if (compat20) {
		s->col = packet_get_int();
		s->row = packet_get_int();
	} else {
		s->row = packet_get_int();
		s->col = packet_get_int();
	}
	s->xpixel = packet_get_int();
	s->ypixel = packet_get_int();

	if (strcmp(s->term, "") == 0) {
		xfree(s->term);
		s->term = NULL;
	}

	/* Allocate a pty and open it. */
	debug("Allocating pty.");
	if (!PRIVSEP(pty_allocate(&s->ptyfd, &s->ttyfd, s->tty,
	    sizeof(s->tty)))) {
		if (s->term)
			xfree(s->term);
		s->term = NULL;
		s->ptyfd = -1;
		s->ttyfd = -1;
		error("session_pty_req: session %d alloc failed", s->self);
		return 0;
	}
	debug("session_pty_req: session %d alloc %s", s->self, s->tty);

	/* for SSH1 the tty modes length is not given */
	if (!compat20)
		n_bytes = packet_remaining();
	tty_parse_modes(s->ttyfd, &n_bytes);

	if (!use_privsep)
		pty_setowner(s->pw, s->tty);

	/* Set window size from the packet. */
	pty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);

	packet_check_eom();
	session_proctitle(s);
	return 1;
}

static int
session_subsystem_req(Session *s)
{
	struct stat st;
	u_int len;
	int success = 0;
	char *prog, *cmd, *subsys = packet_get_string(&len);
	u_int i;

	packet_check_eom();
	logit("subsystem request for %.100s", subsys);

	for (i = 0; i < options.num_subsystems; i++) {
		if (strcmp(subsys, options.subsystem_name[i]) == 0) {
			prog = options.subsystem_command[i];
			cmd = options.subsystem_args[i];
#ifndef SMALL
			if (!strcmp(INTERNAL_SFTP_NAME, prog)) {
				s->is_subsystem = SUBSYSTEM_INT_SFTP;
			} else
#endif
			if (stat(prog, &st) < 0) {
				error("subsystem: cannot stat %s: %s", prog,
				    strerror(errno));
				break;
			} else {
				s->is_subsystem = SUBSYSTEM_EXT;
			}
			debug("subsystem: exec() %s", cmd);
			success = do_exec(s, cmd) == 0;
			break;
		}
	}

	if (!success)
		logit("subsystem request for %.100s failed, subsystem not found",
		    subsys);

	xfree(subsys);
	return success;
}

static int
session_x11_req(Session *s)
{
	int success;

	if (s->auth_proto != NULL || s->auth_data != NULL) {
		error("session_x11_req: session %d: "
		    "x11 forwarding already active", s->self);
		return 0;
	}
	s->single_connection = packet_get_char();
	s->auth_proto = packet_get_string(NULL);
	s->auth_data = packet_get_string(NULL);
	s->screen = packet_get_int();
	packet_check_eom();

	if (xauth_valid_string(s->auth_proto) &&
	    xauth_valid_string(s->auth_data))
		success = session_setup_x11fwd(s);
	else {
		success = 0;
		error("Invalid X11 forwarding data");
	}
	if (!success) {
		xfree(s->auth_proto);
		xfree(s->auth_data);
		s->auth_proto = NULL;
		s->auth_data = NULL;
	}
	return success;
}

static int
session_shell_req(Session *s)
{
	packet_check_eom();
	return do_exec(s, NULL) == 0;
}

static int
session_exec_req(Session *s)
{
	u_int len, success;

	char *command = packet_get_string(&len);
	packet_check_eom();
	success = do_exec(s, command) == 0;
	xfree(command);
	return success;
}

static int
session_break_req(Session *s)
{

	packet_get_int();	/* ignored */
	packet_check_eom();

	if (s->ttyfd == -1 || tcsendbreak(s->ttyfd, 0) < 0)
		return 0;
	return 1;
}

static int
session_env_req(Session *s)
{
	char *name, *val;
	u_int name_len, val_len, i;

	name = packet_get_string(&name_len);
	val = packet_get_string(&val_len);
	packet_check_eom();

	/* Don't set too many environment variables */
	if (s->num_env > 128) {
		debug2("Ignoring env request %s: too many env vars", name);
		goto fail;
	}

	for (i = 0; i < options.num_accept_env; i++) {
		if (match_pattern(name, options.accept_env[i])) {
			debug2("Setting env %d: %s=%s", s->num_env, name, val);
			s->env = xrealloc(s->env, s->num_env + 1,
			    sizeof(*s->env));
			s->env[s->num_env].name = name;
			s->env[s->num_env].val = val;
			s->num_env++;
			return (1);
		}
	}
	debug2("Ignoring env request %s: disallowed name", name);

 fail:
	xfree(name);
	xfree(val);
	return (0);
}

static int
session_auth_agent_req(Session *s)
{
	static int called = 0;
	packet_check_eom();
	if (no_agent_forwarding_flag || !options.allow_agent_forwarding) {
		debug("session_auth_agent_req: no_agent_forwarding_flag");
		return 0;
	}
	if (called) {
		return 0;
	} else {
		called = 1;
		return auth_input_request_forwarding(s->pw);
	}
}

int
session_input_channel_req(Channel *c, const char *rtype)
{
	int success = 0;
	Session *s;

	if ((s = session_by_channel(c->self)) == NULL) {
		logit("session_input_channel_req: no session %d req %.100s",
		    c->self, rtype);
		return 0;
	}
	debug("session_input_channel_req: session %d req %s", s->self, rtype);

	/*
	 * a session is in LARVAL state until a shell, a command
	 * or a subsystem is executed
	 */
	if (c->type == SSH_CHANNEL_LARVAL) {
		if (strcmp(rtype, "shell") == 0) {
			success = session_shell_req(s);
		} else if (strcmp(rtype, "exec") == 0) {
			success = session_exec_req(s);
		} else if (strcmp(rtype, "pty-req") == 0) {
			success = session_pty_req(s);
		} else if (strcmp(rtype, "x11-req") == 0) {
			success = session_x11_req(s);
		} else if (strcmp(rtype, "auth-agent-req@@openssh.com") == 0) {
			success = session_auth_agent_req(s);
		} else if (strcmp(rtype, "subsystem") == 0) {
			success = session_subsystem_req(s);
		} else if (strcmp(rtype, "env") == 0) {
			success = session_env_req(s);
		}
	}
	if (strcmp(rtype, "window-change") == 0) {
		success = session_window_change_req(s);
	} else if (strcmp(rtype, "break") == 0) {
		success = session_break_req(s);
	}

	return success;
}

void
session_set_fds(Session *s, int fdin, int fdout, int fderr, int is_tty)
{
	if (!compat20)
		fatal("session_set_fds: called for proto != 2.0");
	/*
	 * now that have a child and a pipe to the child,
	 * we can activate our channel and register the fd's
	 */
	if (s->chanid == -1)
		fatal("no channel for session %d", s->self);
	channel_set_fds(s->chanid,
	    fdout, fdin, fderr,
	    fderr == -1 ? CHAN_EXTENDED_IGNORE : CHAN_EXTENDED_READ,
	    1, is_tty, CHAN_SES_WINDOW_DEFAULT);
}

/*
 * Function to perform pty cleanup. Also called if we get aborted abnormally
 * (e.g., due to a dropped connection).
 */
void
session_pty_cleanup2(Session *s)
{
	if (s == NULL) {
		error("session_pty_cleanup: no session");
		return;
	}
	if (s->ttyfd == -1)
		return;

	debug("session_pty_cleanup: session %d release %s", s->self, s->tty);

	/* Record that the user has logged out. */
	if (s->pid != 0)
		record_logout(s->pid, s->tty);

	/* Release the pseudo-tty. */
	if (getuid() == 0)
		pty_release(s->tty);

	/*
	 * Close the server side of the socket pairs.  We must do this after
	 * the pty cleanup, so that another process doesn't get this pty
	 * while we're still cleaning up.
	 */
	if (s->ptymaster != -1 && close(s->ptymaster) < 0)
		error("close(s->ptymaster/%d): %s",
		    s->ptymaster, strerror(errno));

	/* unlink pty from session */
	s->ttyfd = -1;
}

void
session_pty_cleanup(Session *s)
{
	PRIVSEP(session_pty_cleanup2(s));
}

static const char *
sig2name(int sig)
{
#define SSH_SIG(x) if (sig == SIG ## x) return #x
	SSH_SIG(ABRT);
	SSH_SIG(ALRM);
	SSH_SIG(FPE);
	SSH_SIG(HUP);
	SSH_SIG(ILL);
	SSH_SIG(INT);
	SSH_SIG(KILL);
	SSH_SIG(PIPE);
	SSH_SIG(QUIT);
	SSH_SIG(SEGV);
	SSH_SIG(TERM);
	SSH_SIG(USR1);
	SSH_SIG(USR2);
#undef	SSH_SIG
	return "SIG@@openssh.com";
}

static void
session_close_x11(int id)
{
	Channel *c;

	if ((c = channel_by_id(id)) == NULL) {
		debug("session_close_x11: x11 channel %d missing", id);
	} else {
		/* Detach X11 listener */
		debug("session_close_x11: detach x11 channel %d", id);
		channel_cancel_cleanup(id);
		if (c->ostate != CHAN_OUTPUT_CLOSED)
			chan_mark_dead(c);
	}
}

static void
session_close_single_x11(int id, void *arg)
{
	Session *s;
	u_int i;

	debug3("session_close_single_x11: channel %d", id);
	channel_cancel_cleanup(id);
	if ((s = session_by_x11_channel(id)) == NULL)
		fatal("session_close_single_x11: no x11 channel %d", id);
	for (i = 0; s->x11_chanids[i] != -1; i++) {
		debug("session_close_single_x11: session %d: "
		    "closing channel %d", s->self, s->x11_chanids[i]);
		/*
		 * The channel "id" is already closing, but make sure we
		 * close all of its siblings.
		 */
		if (s->x11_chanids[i] != id)
			session_close_x11(s->x11_chanids[i]);
	}
	xfree(s->x11_chanids);
	s->x11_chanids = NULL;
	if (s->display) {
		xfree(s->display);
		s->display = NULL;
	}
	if (s->auth_proto) {
		xfree(s->auth_proto);
		s->auth_proto = NULL;
	}
	if (s->auth_data) {
		xfree(s->auth_data);
		s->auth_data = NULL;
	}
	if (s->auth_display) {
		xfree(s->auth_display);
		s->auth_display = NULL;
	}
}

static void
session_exit_message(Session *s, int status)
{
	Channel *c;

	if ((c = channel_lookup(s->chanid)) == NULL)
		fatal("session_exit_message: session %d: no channel %d",
		    s->self, s->chanid);
	debug("session_exit_message: session %d channel %d pid %ld",
	    s->self, s->chanid, (long)s->pid);

	if (WIFEXITED(status)) {
		channel_request_start(s->chanid, "exit-status", 0);
		packet_put_int(WEXITSTATUS(status));
		packet_send();
	} else if (WIFSIGNALED(status)) {
		channel_request_start(s->chanid, "exit-signal", 0);
		packet_put_cstring(sig2name(WTERMSIG(status)));
		packet_put_char(WCOREDUMP(status)? 1 : 0);
		packet_put_cstring("");
		packet_put_cstring("");
		packet_send();
	} else {
		/* Some weird exit cause.  Just exit. */
		packet_disconnect("wait returned status %04x.", status);
	}

	/* disconnect channel */
	debug("session_exit_message: release channel %d", s->chanid);

	/*
	 * Adjust cleanup callback attachment to send close messages when
	 * the channel gets EOF. The session will be then be closed
	 * by session_close_by_channel when the childs close their fds.
	 */
	channel_register_cleanup(c->self, session_close_by_channel, 1);

	/*
	 * emulate a write failure with 'chan_write_failed', nobody will be
	 * interested in data we write.
	 * Note that we must not call 'chan_read_failed', since there could
	 * be some more data waiting in the pipe.
	 */
	if (c->ostate != CHAN_OUTPUT_CLOSED)
		chan_write_failed(c);
}

void
session_close(Session *s)
{
	u_int i;

	debug("session_close: session %d pid %ld", s->self, (long)s->pid);
	if (s->ttyfd != -1)
		session_pty_cleanup(s);
	if (s->term)
		xfree(s->term);
	if (s->display)
		xfree(s->display);
	if (s->x11_chanids)
		xfree(s->x11_chanids);
	if (s->auth_display)
		xfree(s->auth_display);
	if (s->auth_data)
		xfree(s->auth_data);
	if (s->auth_proto)
		xfree(s->auth_proto);
	if (s->env != NULL) {
		for (i = 0; i < s->num_env; i++) {
			xfree(s->env[i].name);
			xfree(s->env[i].val);
		}
		xfree(s->env);
	}
	session_proctitle(s);
	session_unused(s->self);
}

void
session_close_by_pid(pid_t pid, int status)
{
	Session *s = session_by_pid(pid);
	if (s == NULL) {
		debug("session_close_by_pid: no session for pid %ld",
		    (long)pid);
		return;
	}
	if (s->chanid != -1)
		session_exit_message(s, status);
	if (s->ttyfd != -1)
		session_pty_cleanup(s);
	s->pid = 0;
}

/*
 * this is called when a channel dies before
 * the session 'child' itself dies
 */
void
session_close_by_channel(int id, void *arg)
{
	Session *s = session_by_channel(id);
	u_int i;

	if (s == NULL) {
		debug("session_close_by_channel: no session for id %d", id);
		return;
	}
	debug("session_close_by_channel: channel %d child %ld",
	    id, (long)s->pid);
	if (s->pid != 0) {
		debug("session_close_by_channel: channel %d: has child", id);
		/*
		 * delay detach of session, but release pty, since
		 * the fd's to the child are already closed
		 */
		if (s->ttyfd != -1)
			session_pty_cleanup(s);
		return;
	}
	/* detach by removing callback */
	channel_cancel_cleanup(s->chanid);

	/* Close any X11 listeners associated with this session */
	if (s->x11_chanids != NULL) {
		for (i = 0; s->x11_chanids[i] != -1; i++) {
			session_close_x11(s->x11_chanids[i]);
			s->x11_chanids[i] = -1;
		}
	}

	s->chanid = -1;
	session_close(s);
}

void
session_destroy_all(void (*closefunc)(Session *))
{
	int i;
	for (i = 0; i < sessions_nalloc; i++) {
		Session *s = &sessions[i];
		if (s->used) {
			if (closefunc != NULL)
				closefunc(s);
			else
				session_close(s);
		}
	}
}

static char *
session_tty_list(void)
{
	static char buf[1024];
	int i;
	buf[0] = '\0';
	for (i = 0; i < sessions_nalloc; i++) {
		Session *s = &sessions[i];
		if (s->used && s->ttyfd != -1) {
			if (buf[0] != '\0')
				strlcat(buf, ",", sizeof buf);
			strlcat(buf, strrchr(s->tty, '/') + 1, sizeof buf);
		}
	}
	if (buf[0] == '\0')
		strlcpy(buf, "notty", sizeof buf);
	return buf;
}

void
session_proctitle(Session *s)
{
	if (s->pw == NULL)
		error("no user for session %d", s->self);
	else
		setproctitle("%s@@%s", s->pw->pw_name, session_tty_list());
}

int
session_setup_x11fwd(Session *s)
{
	struct stat st;
	char display[512], auth_display[512];
	char hostname[MAXHOSTNAMELEN];
	u_int i;

	if (no_x11_forwarding_flag) {
		packet_send_debug("X11 forwarding disabled in user configuration file.");
		return 0;
	}
	if (!options.x11_forwarding) {
		debug("X11 forwarding disabled in server configuration file.");
		return 0;
	}
	if (!options.xauth_location ||
	    (stat(options.xauth_location, &st) == -1)) {
		packet_send_debug("No xauth program; cannot forward with spoofing.");
		return 0;
	}
	if (options.use_login) {
		packet_send_debug("X11 forwarding disabled; "
		    "not compatible with UseLogin=yes.");
		return 0;
	}
	if (s->display != NULL) {
		debug("X11 display already set.");
		return 0;
	}
	if (x11_create_display_inet(options.x11_display_offset,
	    options.x11_use_localhost, s->single_connection,
	    &s->display_number, &s->x11_chanids) == -1) {
		debug("x11_create_display_inet failed.");
		return 0;
	}
	for (i = 0; s->x11_chanids[i] != -1; i++) {
		channel_register_cleanup(s->x11_chanids[i],
		    session_close_single_x11, 0);
	}

	/* Set up a suitable value for the DISPLAY variable. */
	if (gethostname(hostname, sizeof(hostname)) < 0)
		fatal("gethostname: %.100s", strerror(errno));
	/*
	 * auth_display must be used as the displayname when the
	 * authorisation entry is added with xauth(1).  This will be
	 * different than the DISPLAY string for localhost displays.
	 */
	if (options.x11_use_localhost) {
		snprintf(display, sizeof display, "localhost:%u.%u",
		    s->display_number, s->screen);
		snprintf(auth_display, sizeof auth_display, "unix:%u.%u",
		    s->display_number, s->screen);
		s->display = xstrdup(display);
		s->auth_display = xstrdup(auth_display);
	} else {
		snprintf(display, sizeof display, "%.400s:%u.%u", hostname,
		    s->display_number, s->screen);
		s->display = xstrdup(display);
		s->auth_display = xstrdup(display);
	}

	return 1;
}

static void
do_authenticated2(Authctxt *authctxt)
{
	server_loop2(authctxt);
}

void
do_cleanup(Authctxt *authctxt)
{
	static int called = 0;

	debug("do_cleanup");

	/* no cleanup if we're in the child for login shell */
	if (is_child)
		return;

	/* avoid double cleanup */
	if (called)
		return;
	called = 1;

	if (authctxt == NULL || !authctxt->authenticated)
		return;

	/* remove agent socket */
	auth_sock_cleanup_proc(authctxt->pw);

	/*
	 * Cleanup ptys/utmp only if privsep is disabled,
	 * or if running in monitor.
	 */
	if (!use_privsep || mm_is_monitor())
		session_destroy_all(session_pty_cleanup2);
}
@


1.23
log
@• merge newer OpenSSH
• KNF in our diff – style(9)
• some const cleanliness (build with __CRAZY=Yes mostly)
@
text
@d43 1
d83 1
a83 1
__RCSID("$MirOS: src/usr.bin/ssh/session.c,v 1.22 2009/03/22 15:01:20 tg Exp $");
d262 15
d350 7
a356 1
			success = session_setup_x11fwd(s);
d1735 7
a1741 1
	success = session_setup_x11fwd(s);
@


1.22
log
@merge and tweak ciphers and MACs
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.245 2009/01/22 09:46:01 djm Exp $ */
d82 1
a82 1
__RCSID("$MirOS: src/usr.bin/ssh/session.c,v 1.21 2008/12/27 21:17:56 tg Exp $");
a91 1
Session *session_new(void);
d790 2
a791 2
		f = fopen(login_getcapstr(lc, "welcome", "/etc/motd",
		    "/etc/motd"), "r");
d815 1
a815 1
	if (login_getcapbool(lc, "hushlogin", 0) || stat(buf, &st) >= 0)
d1082 3
a1084 3
	if (!login_getcapbool(lc, "ignorenologin", 0) && pw->pw_uid)
		f = fopen(login_getcapstr(lc, "nologin", _PATH_NOLOGIN,
		    _PATH_NOLOGIN), "r");
d1303 1
a1303 1
	shell = login_getcapstr(lc, "shell", (char *)shell, (char *)shell);
d1327 1
a1327 1
		r = login_getcapbool(lc, "requirehome", 0);
a1345 1
		extern int optind, optreset;
d1349 1
a1349 1
		setproctitle("%s@@internal-sftp-server", s->pw->pw_name);
d1404 1
a1404 1
	argv[1] = "-c";
d1909 1
a1909 1
static char *
@


1.21
log
@merge and wrap exec/exit functions better
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.244 2008/11/09 12:34:47 tobias Exp $ */
d82 1
a82 1
__RCSID("$MirOS: src/usr.bin/ssh/session.c,v 1.20 2008/12/16 22:13:29 tg Exp $");
d218 1
a218 1
	strlcpy(nc->path, auth_sock_name, sizeof(nc->path));
@


1.20
log
@really merge OpenSSH-current into MirBSD Secure SHell 10uA4
@
text
@d82 1
a82 1
__RCSID("$MirOS: src/usr.bin/ssh/session.c,v 1.19 2008/12/16 20:55:27 tg Exp $");
a1194 1
		arc4_preexec();
a1208 1
	arc4_preexec();
a1394 1
		arc4_preexec();
a1408 1
	arc4_preexec();
@


1.19
log
@fastmerge, do not use yet!
@
text
@d82 1
a82 1
__RCSID("$MirOS: src/usr.bin/ssh/session.c,v 1.18 2008/04/03 18:39:39 tg Exp $");
d1195 1
d1210 1
d1397 1
d1412 1
@


1.18
log
@fastmerge
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.233 2008/03/26 21:28:14 djm Exp $ */
d41 1
d82 7
a88 1
__RCSID("$MirOS: src/usr.bin/ssh/session.c,v 1.17 2008/03/02 21:14:21 tg Exp $");
d93 1
a93 1
void	session_set_fds(Session *, int, int, int);
d97 3
a99 3
void	do_exec_pty(Session *, const char *);
void	do_exec_no_pty(Session *, const char *);
void	do_exec(Session *, const char *);
d101 1
a101 1
__dead void do_child(Session *, const char *);
d124 3
a126 2
#define MAX_SESSIONS 10
Session	sessions[MAX_SESSIONS];
d158 1
a158 1
	int sock;
d170 1
a170 3
	auth_sock_name = xmalloc(MAXPATHLEN);
	auth_sock_dir = xmalloc(MAXPATHLEN);
	strlcpy(auth_sock_dir, "/tmp/ssh-XXXXXXXXXX", MAXPATHLEN);
a176 1
		xfree(auth_sock_name);
a177 1
		auth_sock_name = NULL;
d179 1
a179 1
		return 0;
d181 3
a183 2
	snprintf(auth_sock_name, MAXPATHLEN, "%s/agent.%ld",
		 auth_sock_dir, (long) getpid());
d187 5
a191 2
	if (sock < 0)
		packet_disconnect("socket: %.100s", strerror(errno));
d198 5
a202 2
	if (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0)
		packet_disconnect("bind: %.100s", strerror(errno));
d208 4
a211 2
	if (listen(sock, SSH_LISTEN_BACKLOG) < 0)
		packet_disconnect("listen: %.100s", strerror(errno));
d220 13
d345 2
a346 1
			if (no_agent_forwarding_flag || compat13) {
d382 3
a384 1
				do_exec(s, command);
d387 3
a389 1
				do_exec(s, NULL);
d414 1
d420 1
a420 1
void
d424 2
d427 20
d448 1
d450 12
a461 4
	if (socketpair(AF_UNIX, SOCK_STREAM, 0, inout) < 0 ||
	    socketpair(AF_UNIX, SOCK_STREAM, 0, err) < 0)
		packet_disconnect("Could not create socket pairs: %.100s",
				  strerror(errno));
d468 18
a485 1
	if ((pid = fork()) == 0) {
d489 2
a490 1
		log_init(__progname, options.log_level, options.log_facility, log_stderr);
d499 22
d530 1
a530 1
		if (dup2(inout[0], 1) < 0)	/* stdout.  Note: same socket as stdin. */
d532 1
d535 2
d541 2
d544 1
a544 2
	if (pid < 0)
		packet_disconnect("fork failed: %.100s", strerror(errno));
d549 18
d576 4
a579 1
		session_set_fds(s, inout[1], inout[1], s->is_subsystem ? -1 : err[1]);
d584 2
d594 1
a594 1
void
d605 22
d628 9
a636 1
	if ((pid = fork()) == 0) {
d639 3
d643 2
a644 1
		log_init(__progname, options.log_level, options.log_facility, log_stderr);
d666 4
a669 1
		/* Do common processing for the child, such as execing the command. */
d672 2
a674 2
	if (pid < 0)
		packet_disconnect("fork failed: %.100s", strerror(errno));
d680 1
a680 13
	/*
	 * Create another descriptor of the pty master side for use as the
	 * standard input.  We could use the original descriptor, but this
	 * simplifies code in server_loop.  The descriptor is bidirectional.
	 */
	fdout = dup(ptyfd);
	if (fdout < 0)
		packet_disconnect("dup #1 failed: %.100s", strerror(errno));

	/* we keep a reference to the pty master */
	ptymaster = dup(ptyfd);
	if (ptymaster < 0)
		packet_disconnect("dup #2 failed: %.100s", strerror(errno));
a681 2

	/* Enter interactive session. */
d684 1
a684 1
		session_set_fds(s, ptyfd, fdout, -1);
d689 1
d696 1
a696 1
void
d699 2
d705 1
a705 1
		if (strcmp(INTERNAL_SFTP_NAME, command) == 0)
d716 1
a716 1
		if (strcmp(INTERNAL_SFTP_NAME, command) == 0)
d726 1
a726 1
		do_exec_pty(s, command);
d728 1
a728 1
		do_exec_no_pty(s, command);
d738 2
d823 1
a823 1
 * already exists, its value is overriden.
d1022 1
a1022 1
	    !no_user_rc &&  (stat(_PATH_SSH_USER_RC, &st) >= 0)) {
d1266 1
d1327 7
a1333 3
		fprintf(stderr, "Could not chdir to home directory %s: %s\n",
		    pw->pw_dir, strerror(errno));
		if (login_getcapbool(lc, "requirehome", 0))
d1352 1
a1352 1
		args = strdup(command ? command : "sftp-server");
d1414 21
d1438 36
a1473 24
	int i;
	static int did_init = 0;
	if (!did_init) {
		debug("session_new: init");
		for (i = 0; i < MAX_SESSIONS; i++) {
			sessions[i].used = 0;
		}
		did_init = 1;
	}
	for (i = 0; i < MAX_SESSIONS; i++) {
		Session *s = &sessions[i];
		if (! s->used) {
			memset(s, 0, sizeof(*s));
			s->chanid = -1;
			s->ptyfd = -1;
			s->ttyfd = -1;
			s->used = 1;
			s->self = i;
			s->x11_chanids = NULL;
			debug("session_new: session %d", i);
			return s;
		}
	}
	return NULL;
d1480 1
a1480 1
	for (i = 0; i < MAX_SESSIONS; i++) {
d1482 3
a1484 1
		debug("dump: used %d session %d %p channel %d pid %ld",
d1486 1
d1516 1
a1516 1
	for (i = 0; i < MAX_SESSIONS; i++) {
d1532 1
a1532 1
	for (i = 0; i < MAX_SESSIONS; i++) {
d1535 2
a1536 1
			debug("session_by_channel: session %d channel %d", i, id);
d1550 1
a1550 1
	for (i = 0; i < MAX_SESSIONS; i++) {
d1573 1
a1573 1
	for (i = 0; i < MAX_SESSIONS; i++) {
d1629 2
a1630 1
	if (!PRIVSEP(pty_allocate(&s->ptyfd, &s->ttyfd, s->tty, sizeof(s->tty)))) {
d1686 1
a1686 2
			do_exec(s, cmd);
			success = 1;
d1729 1
a1729 2
	do_exec(s, NULL);
	return 1;
d1735 2
a1736 1
	u_int len;
d1739 1
a1739 1
	do_exec(s, command);
d1741 1
a1741 1
	return 1;
d1751 1
a1751 2
	if (s->ttyfd == -1 ||
	    tcsendbreak(s->ttyfd, 0) < 0)
d1796 1
a1796 1
	if (no_agent_forwarding_flag) {
d1852 1
a1852 1
session_set_fds(Session *s, int fdin, int fdout, int fderr)
d1865 1
a1865 2
	    1,
	    CHAN_SES_WINDOW_DEFAULT);
d1897 3
a1899 2
	if (close(s->ptymaster) < 0)
		error("close(s->ptymaster/%d): %s", s->ptymaster, strerror(errno));
a2054 1
	s->used = 0;
d2063 1
d2127 1
a2127 1
	for (i = 0; i < MAX_SESSIONS; i++) {
d2144 1
a2144 1
	for (i = 0; i < MAX_SESSIONS; i++) {
@


1.17
log
@merge’n’fix
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.230 2008/02/22 05:58:56 djm Exp $ */
d81 1
a81 1
__RCSID("$MirOS: src/usr.bin/ssh/session.c,v 1.16 2007/09/13 13:52:54 tg Exp $");
d862 3
a864 2
	/* ignore _PATH_SSH_USER_RC for subsystems */
	if (!s->is_subsystem && (stat(_PATH_SSH_USER_RC, &st) >= 0)) {
@


1.17.2.1
log
@MFC all OpenSSL and OpenSSH fixes (≥ 3 CVEs), requested by bsiegert@@ who will update errata10.hts himself ☻
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.233 2008/03/26 21:28:14 djm Exp $ */
d81 1
a81 1
__RCSID("$MirOS: src/usr.bin/ssh/session.c,v 1.18 2008/04/03 18:39:39 tg Exp $");
d862 2
a863 3
	/* ignore _PATH_SSH_USER_RC for subsystems and admin forced commands */
	if (!s->is_subsystem && options.adm_forced_command == NULL &&
	    !no_user_rc &&  (stat(_PATH_SSH_USER_RC, &st) >= 0)) {
@


1.16
log
@merge and make UMAC-64 default message integrity whatever
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.224 2007/09/11 15:47:17 gilles Exp $ */
d76 1
d79 1
d81 1
a81 1
__RCSID("$MirOS: src/usr.bin/ssh/session.c,v 1.15 2007/09/02 18:53:13 tg Exp $");
d120 4
d548 7
d559 7
d938 55
d997 2
d1000 1
d1002 1
a1002 1
		    (LOGIN_SETALL & ~LOGIN_SETPATH)) < 0) {
d1006 17
d1098 2
a1099 1
__dead void
d1104 1
a1104 1
	char *argv[10];
d1173 2
d1181 18
d1471 5
d1480 2
a1483 1
			s->is_subsystem = 1;
d1806 1
a1806 1
		packet_put_char(WCOREDUMP(status));
@


1.15
log
@merge (luckily no need to change the distrib/special/sshd)
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.223 2007/08/23 02:55:51 djm Exp $ */
d79 1
a79 1
__RCSID("$MirOS: src/usr.bin/ssh/session.c,v 1.14 2007/01/25 16:18:37 tg Exp $");
d713 3
a715 2
		if (strchr(cp, '\n'))
			*strchr(cp, '\n') = '\0';
@


1.14
log
@automerge, bump vsn
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.221 2007/01/21 01:41:54 stevesk Exp $ */
d44 1
d79 1
a79 1
__RCSID("$MirOS: src/usr.bin/ssh/session.c,v 1.13 2006/10/13 18:40:50 tg Exp $");
a117 1
#ifdef HAVE_LOGIN_CAP
a118 1
#endif
a612 1
#ifdef HAVE_LOGIN_CAP
a614 3
#else
		f = fopen("/etc/motd", "r");
#endif
a637 1
#ifdef HAVE_LOGIN_CAP
a639 4
#else
	if (stat(buf, &st) >= 0)
		return 1;
#endif
a753 1
#ifdef HAVE_LOGIN_CAP
a757 3
#else
		child_set_env(&env, &envsize, "PATH", _PATH_STDPATH);
#endif
a902 1
#ifdef HAVE_LOGIN_CAP
a905 4
#else
	if (pw->pw_uid)
		f = fopen(_PATH_NOLOGIN, "r");
#endif
a921 1
#ifdef HAVE_LOGIN_CAP
a926 17
#else
		if (setlogin(pw->pw_name) < 0)
			error("setlogin failed: %s", strerror(errno));
		if (setgid(pw->pw_gid) < 0) {
			perror("setgid");
			exit(1);
		}
		/* Initialize the group list. */
		if (initgroups(pw->pw_name, pw->pw_gid) < 0) {
			perror("initgroups");
			exit(1);
		}
		endgrent();

		/* Permanently switch to the desired uid. */
		permanently_set_uid(pw);
#endif
a1046 1
#ifdef HAVE_LOGIN_CAP
a1047 1
#endif
a1071 1
#ifdef HAVE_LOGIN_CAP
a1073 1
#endif
@


1.13
log
@merge the 4.0 equivalent of 015_ssh.patch
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.220 2006/10/09 23:36:11 djm Exp $ */
d78 1
a78 1
__RCSID("$MirOS: src/usr.bin/ssh/session.c,v 1.12 2006/09/20 21:41:02 tg Exp $");
d1549 1
a1549 1
			success =  session_pty_req(s);
d1674 1
a1674 1
	if ((s  = session_by_x11_channel(id)) == NULL)
@


1.12
log
@finish merging
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.219 2006/08/29 10:40:19 djm Exp $ */
d78 1
a78 1
__RCSID("$MirOS$");
d752 1
a752 1
	env = xmalloc(envsize * sizeof(char *));
@


1.11
log
@fix spelling and pubkey authentication
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.203 2006/04/20 21:53:44 djm Exp $ */
d36 1
a36 3
#include "includes.h"
__RCSID("$MirOS: src/usr.bin/ssh/session.c,v 1.10 2006/06/02 20:50:49 tg Exp $");

d40 1
d42 2
d45 1
d47 4
d52 1
a55 1
#include "xmalloc.h"
d63 4
a66 1
#include "bufaux.h"
a75 1
#include "kex.h"
d78 2
d332 5
a336 1
			channel_input_port_forward_request(s->pw->pw_uid == 0, options.gateway_ports);
d540 5
a544 1
	if (forced_command) {
d547 1
a547 1
		debug("Forced command '%.900s'", command);
d1121 1
a1121 1
	signal(SIGPIPE,  SIG_DFL);
d1385 1
a1385 1
	char *cmd, *subsys = packet_get_string(&len);
d1393 4
a1396 3
			cmd = options.subsystem_command[i];
			if (stat(cmd, &st) < 0) {
				error("subsystem: cannot stat %s: %s", cmd,
d1774 6
a1779 3
	for (i = 0; i < s->num_env; i++) {
		xfree(s->env[i].name);
		xfree(s->env[i].val);
a1780 2
	if (s->env != NULL)
		xfree(s->env);
d1972 1
a1972 1
	if (authctxt == NULL)
@


1.10
log
@* merge
* remove all references to GSSAPI, Kerberos and AFS
* uint*_t -> u_int*_t for consistency, like openbsd
  (note: MirOS style(9) suggests uint32_t etc. instead!)
* bump vsn
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/usr.bin/ssh/session.c,v 1.9 2006/04/19 10:40:52 tg Exp $");
d1910 1
a1910 1
	 * authorization entry is added with xauth(1).  This will be
@


1.9
log
@merge and clean up
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.202 2006/03/25 13:17:02 djm Exp $ */
d37 1
a37 1
__RCSID("$MirOS: src/usr.bin/ssh/session.c,v 1.8 2006/02/22 02:16:48 tg Exp $");
a373 7
#ifdef USE_PIPES
	int pin[2], pout[2], perr[2];
	/* Allocate pipes for communicating with the program. */
	if (pipe(pin) < 0 || pipe(pout) < 0 || pipe(perr) < 0)
		packet_disconnect("Could not create pipes: %.100s",
				  strerror(errno));
#else /* USE_PIPES */
a379 1
#endif /* USE_PIPES */
a398 22
#ifdef USE_PIPES
		/*
		 * Redirect stdin.  We close the parent side of the socket
		 * pair, and make the child side the standard input.
		 */
		close(pin[1]);
		if (dup2(pin[0], 0) < 0)
			perror("dup2 stdin");
		close(pin[0]);

		/* Redirect stdout. */
		close(pout[0]);
		if (dup2(pout[1], 1) < 0)
			perror("dup2 stdout");
		close(pout[1]);

		/* Redirect stderr. */
		close(perr[0]);
		if (dup2(perr[1], 2) < 0)
			perror("dup2 stderr");
		close(perr[1]);
#else /* USE_PIPES */
a411 1
#endif /* USE_PIPES */
a421 5
#ifdef USE_PIPES
	/* We are the parent.  Close the child sides of the pipes. */
	close(pin[0]);
	close(pout[1]);
	close(perr[1]);
a422 12
	if (compat20) {
		if (s->is_subsystem) {
			close(perr[0]);
			perr[0] = -1;
		}
		session_set_fds(s, pin[1], pout[0], perr[0]);
	} else {
		/* Enter the interactive session. */
		server_loop(pid, pin[1], pout[0], perr[0]);
		/* server_loop has closed pin[1], pout[0], and perr[0]. */
	}
#else /* USE_PIPES */
a436 1
#endif /* USE_PIPES */
@


1.8
log
@fix a lot of and kludge a few more __CRAZY problems, sync rcs id
@
text
@d1 1
d37 1
a37 1
RCSID("$MirOS: src/usr.bin/ssh/session.c,v 1.7 2006/02/22 01:23:50 tg Exp $");
d175 1
a175 1
	if (bind(sock, (struct sockaddr *) & sunaddr, sizeof(sunaddr)) < 0)
d614 1
a614 1
		    (struct sockaddr *) & from, &fromlen) < 0) {
d716 1
a716 1
			env = (*envp) = xrealloc(env, envsize * sizeof(char *));
d1523 2
a1524 2
			s->env = xrealloc(s->env, sizeof(*s->env) *
			    (s->num_env + 1));
a1764 1
	s->pid = 0;
d1768 1
a1768 1
	 * the channel gets EOF. The session will be then be closed 
d1826 1
@


1.7
log
@merge; bump version; fix up manpages and includes a little
@
text
@d36 1
a36 1
RCSID("$MirOS: src/usr.bin/ssh/session.c,v 1.6 2005/12/20 19:57:34 tg Exp $");
d80 1
a80 1
void	do_child(Session *, const char *);
d1069 1
a1069 1
void
@


1.6
log
@fastmerge, bump version
@
text
@d36 8
a43 1
RCSID("$MirOS: src/usr.bin/ssh/session.c,v 1.5 2005/11/23 19:45:14 tg Exp $");
a207 9
	/*
	 * Cancel the alarm we set to limit the time taken for
	 * authentication.
	 */
	alarm(0);
	if (startup_pipe != -1) {
		close(startup_pipe);
		startup_pipe = -1;
	}
@


1.5
log
@merge
@
text
@d36 1
a36 1
RCSID("$MirOS: src/usr.bin/ssh/session.c,v 1.4 2005/11/23 18:04:20 tg Exp $");
d1454 1
a1454 1
		    "x11 fowarding already active", s->self);
d1686 1
a1686 1
	if ((c = channel_lookup(id)) == NULL) {
@


1.4
log
@fastmerge remainder of src/usr.bin
@
text
@d36 1
a36 1
RCSID("$MirOS: src/usr.bin/ssh/session.c,v 1.3 2005/06/22 16:11:39 tg Exp $");
d59 1
d265 1
a265 1
			if (!options.compression) {
d1057 1
a1057 1
	 * Close any extra open file descriptors so that we don\'t have them
d1139 1
a1139 1
	/* Change current directory to the user\'s home directory. */
a1740 1
	u_int i;
d1766 9
a1774 1
	channel_cancel_cleanup(s->chanid);
a1782 9
	s->chanid = -1;

	/* Close any X11 listeners associated with this session */
	if (s->x11_chanids != NULL) {
		for (i = 0; s->x11_chanids[i] != -1; i++) {
			session_close_x11(s->x11_chanids[i]);
			s->x11_chanids[i] = -1;
		}
	}
d1826 2
a1827 1
	session_close(s);
d1838 1
d1858 9
d1952 1
a1952 1
		    session_close_single_x11);
@


1.3
log
@merge
@
text
@d36 1
a36 1
RCSID("$MirOS: src/usr.bin/ssh/session.c,v 1.2 2005/03/13 18:33:30 tg Exp $");
d188 5
a192 5
        if (buffer_len(&loginmsg) > 0) {
                buffer_append(&loginmsg, "\0", 1);
                printf("%s", (char *)buffer_ptr(&loginmsg));
                buffer_clear(&loginmsg);
        }
d1226 1
d1300 23
d1451 5
d1681 56
d1740 1
d1776 8
d1798 2
d1838 1
d1910 1
d1936 1
a1936 1
	    &s->display_number) == -1) {
d1940 4
@


1.2
log
@merge src/usr.bin
@
text
@d36 1
a36 1
RCSID("$MirOS$");
d1393 1
a1393 1
	int i;
d1695 1
a1695 1
	int i;
@


1.1
log
@Initial revision
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.181 2004/12/23 17:35:48 markus Exp $");
a60 8
#ifdef KRB5
#include <kafs.h>
#endif

#ifdef GSSAPI
#include "ssh-gss.h"
#endif

a580 8
#ifdef GSSAPI
	if (options.gss_authentication) {
		temporarily_use_uid(s->pw);
		ssh_gssapi_storecreds();
		restore_uid();
	}
#endif

a785 7
#ifdef GSSAPI
	/* Allow any GSSAPI methods that we've used to alter
	 * the childs environment as they see fit
	 */
	ssh_gssapi_do_child(&env, &envsize);
#endif

a851 5
#ifdef KRB5
	if (s->authctxt->krb5_ticket_file)
		child_set_env(&env, &envsize, "KRB5CCNAME",
		    s->authctxt->krb5_ticket_file);
#endif
d856 1
a856 1
	/* read $HOME/.ssh/environment. */
d858 1
a858 1
		snprintf(buf, sizeof buf, "%.200s/.ssh/environment",
d872 1
a872 1
 * Run $HOME/.ssh/rc, /etc/ssh/sshrc, or xauth (whichever is found
d1133 1
a1133 1
	 * Must take new environment into use so that .ssh/rc,
a1137 26
#ifdef KRB5
	/*
	 * At this point, we check to see if AFS is active and if we have
	 * a valid Kerberos 5 TGT. If so, it seems like a good idea to see
	 * if we can (and need to) extend the ticket into an AFS token. If
	 * we don't do this, we run into potential problems if the user's
	 * home directory is in AFS and it's not world-readable.
	 */

	if (options.kerberos_get_afs_token && k_hasafs() &&
	     (s->authctxt->krb5_ctx != NULL)) {
		char cell[64];

		debug("Getting AFS token");

		k_setpag();

		if (k_afs_cell_of_file(pw->pw_dir, cell, sizeof(cell)) == 0)
			krb5_afslog(s->authctxt->krb5_ctx,
			    s->authctxt->krb5_fwd_ccache, cell, NULL);

		krb5_afslog_home(s->authctxt->krb5_ctx,
		    s->authctxt->krb5_fwd_ccache, NULL, NULL, pw->pw_dir);
	}
#endif

a1891 10
#ifdef KRB5
	if (options.kerberos_ticket_cleanup &&
	    authctxt->krb5_ctx)
		krb5_cleanup_proc(authctxt);
#endif

#ifdef GSSAPI
	if (compat20 && options.gss_cleanup_creds)
		ssh_gssapi_cleanup_creds();
#endif
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@most current OpenSSH.com
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.182 2005/06/17 02:44:33 djm Exp $");
d1447 1
a1447 1
	u_int i;
d1749 1
a1749 1
	u_int i;
@


1.1.1.3
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.185 2005/07/17 07:17:55 djm Exp $");
d196 5
a200 5
	if (buffer_len(&loginmsg) > 0) {
		buffer_append(&loginmsg, "\0", 1);
		printf("%s", (char *)buffer_ptr(&loginmsg));
		buffer_clear(&loginmsg);
	}
d1176 1
a1176 1
	    (s->authctxt->krb5_ctx != NULL)) {
a1279 1
			s->x11_chanids = NULL;
a1352 23
session_by_x11_channel(int id)
{
	int i, j;

	for (i = 0; i < MAX_SESSIONS; i++) {
		Session *s = &sessions[i];

		if (s->x11_chanids == NULL || !s->used)
			continue;
		for (j = 0; s->x11_chanids[j] != -1; j++) {
			if (s->x11_chanids[j] == id) {
				debug("session_by_x11_channel: session %d "
				    "channel %d", s->self, id);
				return s;
			}
		}
	}
	debug("session_by_x11_channel: unknown channel %d", id);
	session_dump();
	return NULL;
}

static Session *
a1480 5
	if (s->auth_proto != NULL || s->auth_data != NULL) {
		error("session_x11_req: session %d: "
		    "x11 fowarding already active", s->self);
		return 0;
	}
a1705 56
session_close_x11(int id)
{
	Channel *c;

	if ((c = channel_lookup(id)) == NULL) {
		debug("session_close_x11: x11 channel %d missing", id);
	} else {
		/* Detach X11 listener */
		debug("session_close_x11: detach x11 channel %d", id);
		channel_cancel_cleanup(id);
		if (c->ostate != CHAN_OUTPUT_CLOSED)
			chan_mark_dead(c);
	}
}

static void
session_close_single_x11(int id, void *arg)
{
	Session *s;
	u_int i;

	debug3("session_close_single_x11: channel %d", id);
	channel_cancel_cleanup(id);
	if ((s  = session_by_x11_channel(id)) == NULL)
		fatal("session_close_single_x11: no x11 channel %d", id);
	for (i = 0; s->x11_chanids[i] != -1; i++) {
		debug("session_close_single_x11: session %d: "
		    "closing channel %d", s->self, s->x11_chanids[i]);
		/*
		 * The channel "id" is already closing, but make sure we
		 * close all of its siblings.
		 */
		if (s->x11_chanids[i] != id)
			session_close_x11(s->x11_chanids[i]);
	}
	xfree(s->x11_chanids);
	s->x11_chanids = NULL;
	if (s->display) {
		xfree(s->display);
		s->display = NULL;
	}
	if (s->auth_proto) {
		xfree(s->auth_proto);
		s->auth_proto = NULL;
	}
	if (s->auth_data) {
		xfree(s->auth_data);
		s->auth_data = NULL;
	}
	if (s->auth_display) {
		xfree(s->auth_display);
		s->auth_display = NULL;
	}
}

static void
a1708 1
	u_int i;
a1743 8

	/* Close any X11 listeners associated with this session */
	if (s->x11_chanids != NULL) {
		for (i = 0; s->x11_chanids[i] != -1; i++) {
			session_close_x11(s->x11_chanids[i]);
			s->x11_chanids[i] = -1;
		}
	}
a1757 2
	if (s->x11_chanids)
		xfree(s->x11_chanids);
a1795 1

a1866 1
	u_int i;
d1892 1
a1892 1
	    &s->display_number, &s->x11_chanids) == -1) {
a1895 4
	for (i = 0; s->x11_chanids[i] != -1; i++) {
		channel_register_cleanup(s->x11_chanids[i],
		    session_close_single_x11);
	}
@


1.1.1.4
log
@Import current OpenSSH
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.188 2005/10/30 08:52:17 djm Exp $");
a58 1
#include "kex.h"
d272 1
a272 1
			if (options.compression == COMP_NONE) {
d1084 1
a1084 1
	 * Close any extra open file descriptors so that we don't have them
d1192 1
a1192 1
	/* Change current directory to the user's home directory. */
d1794 1
d1820 1
a1820 9
	s->pid = 0;

	/*
	 * Adjust cleanup callback attachment to send close messages when
	 * the channel gets EOF. The session will be then be closed 
	 * by session_close_by_channel when the childs close their fds.
	 */
	channel_register_cleanup(c->self, session_close_by_channel, 1);

d1829 9
d1881 1
a1881 2
	if (s->ttyfd != -1)
		session_pty_cleanup(s);
a1891 1
	u_int i;
a1910 9

	/* Close any X11 listeners associated with this session */
	if (s->x11_chanids != NULL) {
		for (i = 0; s->x11_chanids[i] != -1; i++) {
			session_close_x11(s->x11_chanids[i]);
			s->x11_chanids[i] = -1;
		}
	}

d1996 1
a1996 1
		    session_close_single_x11, 0);
@


1.1.1.5
log
@OpenSSH is the last missing piece to update before the release
@
text
@d36 1
a36 1
RCSID("$OpenBSD: session.c,v 1.190 2005/12/17 21:13:05 stevesk Exp $");
d1508 1
a1508 1
		    "x11 forwarding already active", s->self);
d1740 1
a1740 1
	if ((c = channel_by_id(id)) == NULL) {
@


1.1.1.6
log
@import OpenSSH-current
@
text
@d36 1
a36 9
RCSID("$OpenBSD: session.c,v 1.196 2006/02/20 17:19:54 stevesk Exp $");

#include <sys/types.h>
#include <sys/wait.h>
#include <sys/un.h>
#include <sys/stat.h>

#include <paths.h>
#include <signal.h>
d209 9
@


1.1.1.7
log
@I decided we'd better upgrade OpenSSH before releasing to the general public
@
text
@a0 1
/* $OpenBSD: session.c,v 1.202 2006/03/25 13:17:02 djm Exp $ */
d36 1
d183 1
a183 1
	if (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0)
d630 1
a630 1
		    (struct sockaddr *)&from, &fromlen) < 0) {
d732 1
a732 1
			env = (*envp) = xrealloc(env, envsize, sizeof(char *));
d1577 2
a1578 2
			s->env = xrealloc(s->env, s->num_env + 1,
			    sizeof(*s->env));
d1819 1
d1823 1
a1823 1
	 * the channel gets EOF. The session will be then be closed
a1880 1
	s->pid = 0;
@


1.1.1.8
log
@if we're gonna push out another snapshot, we'd better have sshd-current
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.203 2006/04/20 21:53:44 djm Exp $ */
d382 7
d395 1
d415 22
d450 1
d461 5
d467 12
d493 1
@


1.1.1.9
log
@import a few security-wise relevant changes right now
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.219 2006/08/29 10:40:19 djm Exp $ */
d36 2
a41 2
#include <sys/socket.h>
#include <sys/param.h>
a42 2
#include <errno.h>
#include <grp.h>
a43 1
#include <pwd.h>
a44 4
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
a45 1
#include "xmalloc.h"
d49 1
d57 1
a57 4
#include "key.h"
#include "cipher.h"
#include "kex.h"
#include "hostfile.h"
d67 1
a67 3
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
d74 4
d330 1
a330 5
			if (channel_input_port_forward_request(s->pw->pw_uid == 0,
			    options.gateway_ports) < 0) {
				debug("Port forwarding failed.");
				break;
			}
d534 1
a534 5
	if (options.adm_forced_command) {
		original_command = command;
		command = options.adm_forced_command;
		debug("Forced command (config) '%.900s'", command);
	} else if (forced_command) {
d537 1
a537 1
		debug("Forced command (key option) '%.900s'", command);
d1157 1
a1157 1
	signal(SIGPIPE, SIG_DFL);
d1421 1
a1421 1
	char *prog, *cmd, *subsys = packet_get_string(&len);
d1429 3
a1431 4
			prog = options.subsystem_command[i];
			cmd = options.subsystem_args[i];
			if (stat(prog, &st) < 0) {
				error("subsystem: cannot stat %s: %s", prog,
d1809 5
a1813 5
	if (s->env != NULL) {
		for (i = 0; i < s->num_env; i++) {
			xfree(s->env[i].name);
			xfree(s->env[i].val);
		}
a1814 1
	}
d2006 1
a2006 1
	if (authctxt == NULL || !authctxt->authenticated)
@


1.1.1.10
log
@OpenSSH 4.5 (security)
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.220 2006/10/09 23:36:11 djm Exp $ */
d766 1
a766 1
	env = xcalloc(envsize, sizeof(char *));
@


1.1.1.11
log
@update OpenSSH, while we're at it…
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.221 2007/01/21 01:41:54 stevesk Exp $ */
d1601 1
a1601 1
			success = session_pty_req(s);
d1726 1
a1726 1
	if ((s = session_by_x11_channel(id)) == NULL)
@


1.1.1.12
log
@more ssh updates
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.223 2007/08/23 02:55:51 djm Exp $ */
a44 1
#include <login_cap.h>
d123 1
d125 1
d628 1
d631 3
d657 1
d660 4
d785 1
d790 3
d943 1
d947 4
d967 1
d973 17
d1110 1
d1112 1
d1163 1
d1166 1
@


1.1.1.13
log
@Import latest OpenSSH upgrades
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.224 2007/09/11 15:47:17 gilles Exp $ */
d727 2
a728 3

		cp[strcspn(cp, "\n")] = '\0';

@


1.1.1.14
log
@newer openssh
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.230 2008/02/22 05:58:56 djm Exp $ */
a76 1
#include "misc.h"
a81 1
#include "sftp.h"
a123 4
#define SUBSYSTEM_NONE		0
#define SUBSYSTEM_EXT		1
#define SUBSYSTEM_INT_SFTP	2

a547 4
		if (strcmp(INTERNAL_SFTP_NAME, command) == 0)
			s->is_subsystem = SUBSYSTEM_INT_SFTP;
		else if (s->is_subsystem)
			s->is_subsystem = SUBSYSTEM_EXT;
a551 4
		if (strcmp(INTERNAL_SFTP_NAME, command) == 0)
			s->is_subsystem = SUBSYSTEM_INT_SFTP;
		else if (s->is_subsystem)
			s->is_subsystem = SUBSYSTEM_EXT;
d562 1
a943 55
/*
 * Chroot into a directory after checking it for safety: all path components
 * must be root-owned directories with strict permissions.
 */
static void
safely_chroot(const char *path, uid_t uid)
{
	const char *cp;
	char component[MAXPATHLEN];
	struct stat st;

	if (*path != '/')
		fatal("chroot path does not begin at root");
	if (strlen(path) >= sizeof(component))
		fatal("chroot path too long");

	/*
	 * Descend the path, checking that each component is a
	 * root-owned directory with strict permissions.
	 */
	for (cp = path; cp != NULL;) {
		if ((cp = strchr(cp, '/')) == NULL)
			strlcpy(component, path, sizeof(component));
		else {
			cp++;
			memcpy(component, path, cp - path);
			component[cp - path] = '\0';
		}
	
		debug3("%s: checking '%s'", __func__, component);

		if (stat(component, &st) != 0)
			fatal("%s: stat(\"%s\"): %s", __func__,
			    component, strerror(errno));
		if (st.st_uid != 0 || (st.st_mode & 022) != 0)
			fatal("bad ownership or modes for chroot "
			    "directory %s\"%s\"", 
			    cp == NULL ? "" : "component ", component);
		if (!S_ISDIR(st.st_mode))
			fatal("chroot path %s\"%s\" is not a directory",
			    cp == NULL ? "" : "component ", component);

	}

	if (chdir(path) == -1)
		fatal("Unable to chdir to chroot path \"%s\": "
		    "%s", path, strerror(errno));
	if (chroot(path) == -1)
		fatal("chroot(\"%s\"): %s", path, strerror(errno));
	if (chdir("/") == -1)
		fatal("%s: chdir(/) after chroot: %s",
		    __func__, strerror(errno));
	verbose("Changed root directory to \"%s\"", path);
}

a947 2
	char *chroot_path, *tmp;

a948 1
		/* Prepare groups */
d950 1
a950 1
		    (LOGIN_SETALL & ~(LOGIN_SETPATH|LOGIN_SETUSER))) < 0) {
a953 17

		if (options.chroot_directory != NULL &&
		    strcasecmp(options.chroot_directory, "none") != 0) {
                        tmp = tilde_expand_filename(options.chroot_directory,
			    pw->pw_uid);
			chroot_path = percent_expand(tmp, "h", pw->pw_dir,
			    "u", pw->pw_name, (char *)NULL);
			safely_chroot(chroot_path, pw->pw_uid);
			free(tmp);
			free(chroot_path);
		}

		/* Set UID */
		if (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETUSER) < 0) {
			perror("unable to set user context (setuser)");
			exit(1);
		}
a1028 1
#define ARGV_MAX 10
d1034 1
a1034 1
	char *argv[ARGV_MAX];
a1128 2
	closefrom(STDERR_FILENO + 1);

a1134 16
	if (s->is_subsystem == SUBSYSTEM_INT_SFTP) {
		extern int optind, optreset;
		int i;
		char *p, *args;

		setproctitle("%s@@internal-sftp-server", s->pw->pw_name);
		args = strdup(command ? command : "sftp-server");
		for (i = 0, (p = strtok(args, " ")); p; (p = strtok(NULL, " ")))
			if (i < ARGV_MAX - 1)
				argv[i++] = p;
		argv[i] = NULL;
		optind = optreset = 1;
		__progname = argv[0];
		exit(sftp_server_main(i, argv, s->pw));
	}

d1407 1
a1407 3
			if (!strcmp(INTERNAL_SFTP_NAME, prog)) {
				s->is_subsystem = SUBSYSTEM_INT_SFTP;
			} else if (stat(prog, &st) < 0) {
a1410 2
			} else {
				s->is_subsystem = SUBSYSTEM_EXT;
d1413 1
d1736 1
a1736 1
		packet_put_char(WCOREDUMP(status)? 1 : 0);
@


1.1.1.15
log
@OpenSSH 5.0
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.233 2008/03/26 21:28:14 djm Exp $ */
d881 2
a882 3
	/* ignore _PATH_SSH_USER_RC for subsystems and admin forced commands */
	if (!s->is_subsystem && options.adm_forced_command == NULL &&
	    !no_user_rc &&  (stat(_PATH_SSH_USER_RC, &st) >= 0)) {
@


1.1.1.16
log
@OpenSSH-current
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.244 2008/11/09 12:34:47 tobias Exp $ */
a41 1
#include <sys/queue.h>
a88 6
#define IS_INTERNAL_SFTP(c) \
	(!strncmp(c, INTERNAL_SFTP_NAME, sizeof(INTERNAL_SFTP_NAME) - 1) && \
	 (c[sizeof(INTERNAL_SFTP_NAME) - 1] == '\0' || \
	  c[sizeof(INTERNAL_SFTP_NAME) - 1] == ' ' || \
	  c[sizeof(INTERNAL_SFTP_NAME) - 1] == '\t'))

d92 1
a92 1
void	session_set_fds(Session *, int, int, int, int);
d96 3
a98 3
int	do_exec_pty(Session *, const char *);
int	do_exec_no_pty(Session *, const char *);
int	do_exec(Session *, const char *);
d123 2
a124 3
static int sessions_first_unused = -1;
static int sessions_nalloc = 0;
static Session *sessions = NULL;
d156 1
a156 1
	int sock = -1;
d168 3
a170 1
	auth_sock_dir = xstrdup("/tmp/ssh-XXXXXXXXXX");
d177 1
d179 1
d181 1
a181 1
		goto authsock_err;
d183 2
a184 3

	xasprintf(&auth_sock_name, "%s/agent.%ld",
	    auth_sock_dir, (long) getpid());
d188 2
a189 5
	if (sock < 0) {
		error("socket: %.100s", strerror(errno));
		restore_uid();
		goto authsock_err;
	}
d196 2
a197 5
	if (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {
		error("bind: %.100s", strerror(errno));
		restore_uid();
		goto authsock_err;
	}
d203 2
a204 4
	if (listen(sock, SSH_LISTEN_BACKLOG) < 0) {
		error("listen: %.100s", strerror(errno));
		goto authsock_err;
	}
a212 13

 authsock_err:
	if (auth_sock_name != NULL)
		xfree(auth_sock_name);
	if (auth_sock_dir != NULL) {
		rmdir(auth_sock_dir);
		xfree(auth_sock_dir);
	}
	if (sock != -1)
		close(sock);
	auth_sock_name = NULL;
	auth_sock_dir = NULL;
	return 0;
d325 1
a325 2
			if (!options.allow_agent_forwarding ||
			    no_agent_forwarding_flag || compat13) {
d361 1
a361 3
				if (do_exec(s, command) != 0)
					packet_disconnect(
					    "command execution failed");
d364 1
a364 3
				if (do_exec(s, NULL) != 0)
					packet_disconnect(
					    "shell execution failed");
a388 1
#define USE_PIPES
d394 1
a394 1
int
a397 2
#ifdef USE_PIPES
	int pin[2], pout[2], perr[2];
a398 20
	/* Allocate pipes for communicating with the program. */
	if (pipe(pin) < 0) {
		error("%s: pipe in: %.100s", __func__, strerror(errno));
		return -1;
	}
	if (pipe(pout) < 0) {
		error("%s: pipe out: %.100s", __func__, strerror(errno));
		close(pin[0]);
		close(pin[1]);
		return -1;
	}
	if (pipe(perr) < 0) {
		error("%s: pipe err: %.100s", __func__, strerror(errno));
		close(pin[0]);
		close(pin[1]);
		close(pout[0]);
		close(pout[1]);
		return -1;
	}
#else
a399 1

d401 4
a404 12
	if (socketpair(AF_UNIX, SOCK_STREAM, 0, inout) < 0) {
		error("%s: socketpair #1: %.100s", __func__, strerror(errno));
		return -1;
	}
	if (socketpair(AF_UNIX, SOCK_STREAM, 0, err) < 0) {
		error("%s: socketpair #2: %.100s", __func__, strerror(errno));
		close(inout[0]);
		close(inout[1]);
		return -1;
	}
#endif

d411 1
a411 18
	switch ((pid = fork())) {
	case -1:
		error("%s: fork: %.100s", __func__, strerror(errno));
#ifdef USE_PIPES
		close(pin[0]);
		close(pin[1]);
		close(pout[0]);
		close(pout[1]);
		close(perr[0]);
		close(perr[1]);
#else
		close(inout[0]);
		close(inout[1]);
		close(err[0]);
		close(err[1]);
#endif
		return -1;
	case 0:
d415 1
a415 2
		log_init(__progname, options.log_level,
		    options.log_facility, log_stderr);
a423 22
#ifdef USE_PIPES
		/*
		 * Redirect stdin.  We close the parent side of the socket
		 * pair, and make the child side the standard input.
		 */
		close(pin[1]);
		if (dup2(pin[0], 0) < 0)
			perror("dup2 stdin");
		close(pin[0]);

		/* Redirect stdout. */
		close(pout[0]);
		if (dup2(pout[1], 1) < 0)
			perror("dup2 stdout");
		close(pout[1]);

		/* Redirect stderr. */
		close(perr[0]);
		if (dup2(perr[1], 2) < 0)
			perror("dup2 stderr");
		close(perr[1]);
#else
d433 1
a433 1
		if (dup2(inout[0], 1) < 0)	/* stdout (same as stdin) */
a434 1
		close(inout[0]);
a436 2
		close(err[0]);
#endif
a440 2
	default:
		break;
d442 2
a443 1

a447 18
#ifdef USE_PIPES
	/* We are the parent.  Close the child sides of the pipes. */
	close(pin[0]);
	close(pout[1]);
	close(perr[1]);

	if (compat20) {
		if (s->is_subsystem) {
			close(perr[0]);
			perr[0] = -1;
		}
		session_set_fds(s, pin[1], pout[0], perr[0], 0);
	} else {
		/* Enter the interactive session. */
		server_loop(pid, pin[1], pout[0], perr[0]);
		/* server_loop has closed pin[1], pout[0], and perr[0]. */
	}
#else
d457 1
a457 4
		session_set_fds(s, inout[1], inout[1],
		    s->is_subsystem ? -1 : err[1], 0);
		if (s->is_subsystem)
			close(err[1]);
a461 2
#endif
	return 0;
d470 1
a470 1
int
a480 22
	/*
	 * Create another descriptor of the pty master side for use as the
	 * standard input.  We could use the original descriptor, but this
	 * simplifies code in server_loop.  The descriptor is bidirectional.
	 * Do this before forking (and cleanup in the child) so as to
	 * detect and gracefully fail out-of-fd conditions.
	 */
	if ((fdout = dup(ptyfd)) < 0) {
		error("%s: dup #1: %s", __func__, strerror(errno));
		close(ttyfd);
		close(ptyfd);
		return -1;
	}
	/* we keep a reference to the pty master */
	if ((ptymaster = dup(ptyfd)) < 0) {
		error("%s: dup #2: %s", __func__, strerror(errno));
		close(ttyfd);
		close(ptyfd);
		close(fdout);
		return -1;
	}

d482 1
a482 9
	switch ((pid = fork())) {
	case -1:
		error("%s: fork: %.100s", __func__, strerror(errno));
		close(fdout);
		close(ptymaster);
		close(ttyfd);
		close(ptyfd);
		return -1;
	case 0:
a484 3
		close(fdout);
		close(ptymaster);

d486 1
a486 2
		log_init(__progname, options.log_level,
		    options.log_facility, log_stderr);
d508 1
a508 4
		/*
		 * Do common processing for the child, such as execing
		 * the command.
		 */
a510 2
	default:
		break;
d512 2
d519 15
a534 1
	s->ptymaster = ptymaster;
d537 1
a537 1
		session_set_fds(s, ptyfd, fdout, -1, 1);
a541 1
	return 0;
d548 1
a548 1
int
a550 2
	int ret;

d554 1
a554 1
		if (IS_INTERNAL_SFTP(command))
d562 1
a562 1
		if (IS_INTERNAL_SFTP(command))
d577 1
a577 1
		ret = do_exec_pty(s, command);
d579 1
a579 1
		ret = do_exec_no_pty(s, command);
a588 2

	return ret;
d672 1
a672 1
 * already exists, its value is overridden.
d883 1
a883 1
	    !no_user_rc && stat(_PATH_SSH_USER_RC, &st) >= 0) {
a1126 1
	int r = 0;
d1213 3
a1215 7
		/* Suppress missing homedir warning for chroot case */
		r = login_getcapbool(lc, "requirehome", 0);
		if (r || options.chroot_directory == NULL)
			fprintf(stderr, "Could not chdir to home "
			    "directory %s: %s\n", pw->pw_dir,
			    strerror(errno));
		if (r)
d1233 1
a1233 1
		args = xstrdup(command ? command : "sftp-server");
a1293 21
void
session_unused(int id)
{
	debug3("%s: session id %d unused", __func__, id);
	if (id >= options.max_sessions ||
	    id >= sessions_nalloc) {
		fatal("%s: insane session id %d (max %d nalloc %d)",
		    __func__, id, options.max_sessions, sessions_nalloc);
	}
	bzero(&sessions[id], sizeof(*sessions));
	sessions[id].self = id;
	sessions[id].used = 0;
	sessions[id].chanid = -1;
	sessions[id].ptyfd = -1;
	sessions[id].ttyfd = -1;
	sessions[id].ptymaster = -1;
	sessions[id].x11_chanids = NULL;
	sessions[id].next_unused = sessions_first_unused;
	sessions_first_unused = id;
}

d1297 24
a1320 36
	Session *s, *tmp;

	if (sessions_first_unused == -1) {
		if (sessions_nalloc >= options.max_sessions)
			return NULL;
		debug2("%s: allocate (allocated %d max %d)",
		    __func__, sessions_nalloc, options.max_sessions);
		tmp = xrealloc(sessions, sessions_nalloc + 1,
		    sizeof(*sessions));
		if (tmp == NULL) {
			error("%s: cannot allocate %d sessions",
			    __func__, sessions_nalloc + 1);
			return NULL;
		}
		sessions = tmp;
		session_unused(sessions_nalloc++);
	}

	if (sessions_first_unused >= sessions_nalloc ||
	    sessions_first_unused < 0) {
		fatal("%s: insane first_unused %d max %d nalloc %d",
		    __func__, sessions_first_unused, options.max_sessions,
		    sessions_nalloc);
	}

	s = &sessions[sessions_first_unused];
	if (s->used) {
		fatal("%s: session %d already used",
		    __func__, sessions_first_unused);
	}
	sessions_first_unused = s->next_unused;
	s->used = 1;
	s->next_unused = -1;
	debug("session_new: session %d", s->self);

	return s;
d1327 1
a1327 1
	for (i = 0; i < sessions_nalloc; i++) {
d1329 1
a1329 3

		debug("dump: used %d next_unused %d session %d %p "
		    "channel %d pid %ld",
a1330 1
		    s->next_unused,
d1360 1
a1360 1
	for (i = 0; i < sessions_nalloc; i++) {
d1376 1
a1376 1
	for (i = 0; i < sessions_nalloc; i++) {
d1379 1
a1379 2
			debug("session_by_channel: session %d channel %d",
			    i, id);
d1393 1
a1393 1
	for (i = 0; i < sessions_nalloc; i++) {
d1416 1
a1416 1
	for (i = 0; i < sessions_nalloc; i++) {
d1472 1
a1472 2
	if (!PRIVSEP(pty_allocate(&s->ptyfd, &s->ttyfd, s->tty,
	    sizeof(s->tty)))) {
d1525 2
a1526 1
			success = do_exec(s, cmd) == 0;
d1569 2
a1570 1
	return do_exec(s, NULL) == 0;
d1576 1
a1576 2
	u_int len, success;

d1579 1
a1579 1
	success = do_exec(s, command) == 0;
d1581 1
a1581 1
	return success;
d1591 2
a1592 1
	if (s->ttyfd == -1 || tcsendbreak(s->ttyfd, 0) < 0)
d1637 1
a1637 1
	if (no_agent_forwarding_flag || !options.allow_agent_forwarding) {
d1693 1
a1693 1
session_set_fds(Session *s, int fdin, int fdout, int fderr, int is_tty)
d1706 2
a1707 1
	    1, is_tty, CHAN_SES_WINDOW_DEFAULT);
d1739 2
a1740 3
	if (s->ptymaster != -1 && close(s->ptymaster) < 0)
		error("close(s->ptymaster/%d): %s",
		    s->ptymaster, strerror(errno));
d1896 1
a1904 1
	session_unused(s->self);
d1968 1
a1968 1
	for (i = 0; i < sessions_nalloc; i++) {
d1985 1
a1985 1
	for (i = 0; i < sessions_nalloc; i++) {
@


1.1.1.17
log
@OpenSSH 5.2, or so
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.245 2009/01/22 09:46:01 djm Exp $ */
d224 1
a224 1
	nc->path = xstrdup(auth_sock_name);
@


1.1.1.18
log
@Let’s play the version number game – OpenSSH 5.3-current
@
text
@d1 1
a1 1
/* $OpenBSD: session.c,v 1.246 2009/04/17 19:23:06 stevesk Exp $ */
d1395 1
a1395 1
		setproctitle("%s@@%s", s->pw->pw_name, INTERNAL_SFTP_NAME);
@


1.1.1.19
log
@methinks we’ll want this
@
text
@a43 1
#include <ctype.h>
a267 15
/* Check untrusted xauth strings for metacharacters */
static int
xauth_valid_string(const char *s)
{
	size_t i;

	for (i = 0; s[i] != '\0'; i++) {
		if (!isalnum((u_char)s[i]) &&
		    s[i] != '.' && s[i] != ':' && s[i] != '/' &&
		    s[i] != '-' && s[i] != '_')
		return 0;
	}
	return 1;
}

d341 1
a341 7
			if (xauth_valid_string(s->auth_proto) &&
			    xauth_valid_string(s->auth_data))
				success = session_setup_x11fwd(s);
			else {
				success = 0;
				error("Invalid X11 forwarding data");
			}
d1755 1
a1755 7
	if (xauth_valid_string(s->auth_proto) &&
	    xauth_valid_string(s->auth_data))
		success = session_setup_x11fwd(s);
	else {
		success = 0;
		error("Invalid X11 forwarding data");
	}
@


