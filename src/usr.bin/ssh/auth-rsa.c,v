head	1.10;
access;
symbols
	cvs-200910041320:1.1.1.7
	cvs-200903221200:1.1.1.7
	cvs-200812162015:1.1.1.7
	cvs-200804031830:1.1.1.6
	MIRBSD_10:1.9.0.2
	MIRBSD_10_BASE:1.9
	cvs-200803022030:1.1.1.6
	cvs-200709131337:1.1.1.6
	cvs-200709021830:1.1.1.6
	cvs-200708201200:1.1.1.6
	cvs-200706161500:1.1.1.6
	cvs-200705192215:1.1.1.6
	cvs-200704292000:1.1.1.6
	cvs-200703080900:1.1.1.6
	cvs-200701251600:1.1.1.6
	cvs-200612111600:1.1.1.6
	cvs-200611090230:1.1.1.6
	OPENBSD_4_0:1.1.1.5
	MIRBSD_9_BASE:1.6
	cvs-200606162342:1.1.1.4
	cvs-200606022000:1.1.1.4
	cvs-200604191000:1.1.1.4
	cvs-200602220045:1.1.1.3
	MIRBSD_8:1.3.0.2
	MIRBSD_8_BASE:1.3
	cvs-200512201942:1.1.1.2
	cvs-200511231930:1.1.1.2
	cvs-200507211800:1.1.1.2
	cvs-200506221550:1.1.1.2
	cvs-200505050030:1.1.1.1
	cvs-200504291700:1.1.1.1
	cvs-200504261445:1.1.1.1
	cvs-200504141900:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2008.12.16.20.55.18;	author tg;	state Exp;
branches;
next	1.9;
commitid	100494815C97ECEEDBF;

1.9
date	2006.11.09.02.42.05;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004552959372C0CB8B;

1.8
date	2006.09.20.21.40.55;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004511B578580E7F04;

1.7
date	2006.07.23.14.19.26;	author tg;	state Exp;
branches;
next	1.6;
commitid	10044C3857E74BD315F;

1.6
date	2006.04.19.10.40.43;	author tg;	state Exp;
branches;
next	1.5;
commitid	100444613BD3A91C28B;

1.5
date	2006.02.22.01.23.48;	author tg;	state Exp;
branches;
next	1.4;
commitid	10043FBBD2C2C5E7D81;

1.4
date	2006.02.21.02.12.25;	author tg;	state Exp;
branches;
next	1.3;
commitid	10043FA771B61F2BE89;

1.3
date	2005.06.22.16.11.39;	author tg;	state Exp;
branches;
next	1.2;
commitid	598b42b98dcf335f;

1.2
date	2005.03.13.18.33.29;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.29.52;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.29.52;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.06.22.15.56.24;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	181342b98a38fe99;

1.1.1.3
date	2006.02.22.00.51.35;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	10043FBB5A933C3BB9B;

1.1.1.4
date	2006.04.19.10.15.02;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	10044460DB21E1F715C;

1.1.1.5
date	2006.09.20.19.06.47;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	10045119150397FC669;

1.1.1.6
date	2006.11.09.02.37.59;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	100455294981A6201C8;

1.1.1.7
date	2008.12.16.20.15.31;	author tg;	state Exp;
branches;
next	;
commitid	10049480C7A2701F5C0;


desc
@@


1.10
log
@fastmerge, do not use yet!
@
text
@/* $OpenBSD: auth-rsa.c,v 1.73 2008/07/02 12:03:51 dtucker Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * RSA-based authentication.  This code determines whether to admit a login
 * based on RSA authentication.  This file also contains functions to check
 * validity of the host key.
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */

#include <sys/types.h>
#include <sys/stat.h>

#include <openssl/rsa.h>
#include <md5.h>

#include <pwd.h>
#include <stdio.h>
#include <string.h>

#include "xmalloc.h"
#include "rsa.h"
#include "packet.h"
#include "ssh1.h"
#include "uidswap.h"
#include "match.h"
#include "buffer.h"
#include "auth-options.h"
#include "pathnames.h"
#include "log.h"
#include "servconf.h"
#include "key.h"
#include "hostfile.h"
#include "auth.h"
#include "monitor_wrap.h"
#include "ssh.h"
#include "misc.h"

__RCSID("$MirOS: src/usr.bin/ssh/auth-rsa.c,v 1.9 2006/11/09 02:42:05 tg Exp $");

/* import */
extern ServerOptions options;

/*
 * Session identifier that is used to bind key exchange and authentication
 * responses to a particular session.
 */
extern u_char session_id[16];

/*
 * The .etc/ssh/authorised_keys file contains public keys, one per line, in the
 * following format:
 *   options bits e n comment
 * where bits, e and n are decimal numbers,
 * and comment is any string of characters up to newline.  The maximum
 * length of a line is SSH_MAX_PUBKEY_BYTES characters.  See sshd(8) for a
 * description of the options.
 */

BIGNUM *
auth_rsa_generate_challenge(Key *key)
{
	BIGNUM *challenge;
	BN_CTX *ctx;

	if ((challenge = BN_new()) == NULL)
		fatal("auth_rsa_generate_challenge: BN_new() failed");
	/* Generate a random challenge. */
	if (BN_rand(challenge, 256, 0, 0) == 0)
		fatal("auth_rsa_generate_challenge: BN_rand failed");
	if ((ctx = BN_CTX_new()) == NULL)
		fatal("auth_rsa_generate_challenge: BN_CTX_new failed");
	if (BN_mod(challenge, challenge, key->rsa->n, ctx) == 0)
		fatal("auth_rsa_generate_challenge: BN_mod failed");
	BN_CTX_free(ctx);

	return challenge;
}

int
auth_rsa_verify_response(Key *key, BIGNUM *challenge, u_char response[16])
{
	u_char buf[32], mdbuf[16];
	MD5_CTX md;
	int len;

	/* don't allow short keys */
	if (BN_num_bits(key->rsa->n) < SSH_RSA_MINIMUM_MODULUS_SIZE) {
		error("auth_rsa_verify_response: RSA modulus too small: %d < minimum %d bits",
		    BN_num_bits(key->rsa->n), SSH_RSA_MINIMUM_MODULUS_SIZE);
		return (0);
	}

	/* The response is MD5 of decrypted challenge plus session id. */
	len = BN_num_bytes(challenge);
	if (len <= 0 || len > 32)
		fatal("auth_rsa_verify_response: bad challenge length %d", len);
	memset(buf, 0, 32);
	BN_bn2bin(challenge, buf + 32 - len);
	MD5Init(&md);
	MD5Update(&md, buf, 32);
	MD5Update(&md, session_id, 16);
	MD5Final(mdbuf, &md);

	/* Verify that the response is the original challenge. */
	if (memcmp(response, mdbuf, 16) != 0) {
		/* Wrong answer. */
		return (0);
	}
	/* Correct answer. */
	return (1);
}

/*
 * Performs the RSA authentication challenge-response dialog with the client,
 * and returns true (non-zero) if the client gave the correct answer to
 * our challenge; returns zero if the client gives a wrong answer.
 */

int
auth_rsa_challenge_dialog(Key *key)
{
	BIGNUM *challenge, *encrypted_challenge;
	u_char response[16];
	int i, success;

	if ((encrypted_challenge = BN_new()) == NULL)
		fatal("auth_rsa_challenge_dialog: BN_new() failed");

	challenge = PRIVSEP(auth_rsa_generate_challenge(key));

	/* Encrypt the challenge with the public key. */
	rsa_public_encrypt(encrypted_challenge, challenge, key->rsa);

	/* Send the encrypted challenge to the client. */
	packet_start(SSH_SMSG_AUTH_RSA_CHALLENGE);
	packet_put_bignum(encrypted_challenge);
	packet_send();
	BN_clear_free(encrypted_challenge);
	packet_write_wait();

	/* Wait for a response. */
	packet_read_expect(SSH_CMSG_AUTH_RSA_RESPONSE);
	for (i = 0; i < 16; i++)
		response[i] = (u_char)packet_get_char();
	packet_check_eom();

	success = PRIVSEP(auth_rsa_verify_response(key, challenge, response));
	BN_clear_free(challenge);
	return (success);
}

/*
 * check if there's user key matching client_n,
 * return key if login is allowed, NULL otherwise
 */

int
auth_rsa_key_allowed(struct passwd *pw, BIGNUM *client_n, Key **rkey)
{
	char line[SSH_MAX_PUBKEY_BYTES], *file;
	int allowed = 0;
	u_int bits;
	FILE *f;
	u_long linenum = 0;
	Key *key;

	/* Temporarily use the user's uid. */
	temporarily_use_uid(pw);

	/* The authorised keys. */
	file = authorised_keys_file(pw);
	debug("trying public RSA key file %s", file);
	f = auth_openkeyfile(file, pw, options.strict_modes);
	if (!f) {
		xfree(file);
		restore_uid();
		return (0);
	}

	/* Flag indicating whether the key is allowed. */
	allowed = 0;

	key = key_new(KEY_RSA1);

	/*
	 * Go though the accepted keys, looking for the current key.  If
	 * found, perform a challenge-response dialog to verify that the
	 * user really has the corresponding private key.
	 */
	while (read_keyfile_line(f, file, line, sizeof(line), &linenum) != -1) {
		char *cp;
		char *key_options;
		int keybits;

		/* Skip leading whitespace, empty and comment lines. */
		for (cp = line; *cp == ' ' || *cp == '\t'; cp++)
			;
		if (!*cp || *cp == '\n' || *cp == '#')
			continue;

		/*
		 * Check if there are options for this key, and if so,
		 * save their starting address and skip the option part
		 * for now.  If there are no options, set the starting
		 * address to NULL.
		 */
		if (*cp < '0' || *cp > '9') {
			int quoted = 0;
			key_options = cp;
			for (; *cp && (quoted || (*cp != ' ' && *cp != '\t')); cp++) {
				if (*cp == '\\' && cp[1] == '"')
					cp++;	/* Skip both */
				else if (*cp == '"')
					quoted = !quoted;
			}
		} else
			key_options = NULL;

		/* Parse the key from the line. */
		if (hostfile_read_key(&cp, &bits, key) == 0) {
			debug("%.100s, line %lu: non ssh1 key syntax",
			    file, linenum);
			continue;
		}
		/* cp now points to the comment part. */

		/* Check if the we have found the desired key (identified by its modulus). */
		if (BN_cmp(key->rsa->n, client_n) != 0)
			continue;

		/* check the real bits  */
		keybits = BN_num_bits(key->rsa->n);
		if (keybits < 0 || bits != (u_int)keybits)
			logit("Warning: %s, line %lu: keysize mismatch: "
			    "actual %d vs. announced %d.",
			    file, linenum, BN_num_bits(key->rsa->n), bits);

		/* We have found the desired key. */
		/*
		 * If our options do not allow this key to be used,
		 * do not send challenge.
		 */
		if (!auth_parse_options(pw, key_options, file, linenum))
			continue;

		/* break out, this key is allowed */
		allowed = 1;
		break;
	}

	/* Restore the privileged uid. */
	restore_uid();

	/* Close the file. */
	xfree(file);
	fclose(f);

	/* return key if allowed */
	if (allowed && rkey != NULL)
		*rkey = key;
	else
		key_free(key);
	return (allowed);
}

/*
 * Performs the RSA authentication dialog with the client.  This returns
 * 0 if the client could not be authenticated, and 1 if authentication was
 * successful.  This may exit if there is a serious protocol violation.
 */
int
auth_rsa(Authctxt *authctxt, BIGNUM *client_n)
{
	Key *key;
	char *fp;
	struct passwd *pw = authctxt->pw;

	/* no user given */
	if (!authctxt->valid)
		return 0;

	if (!PRIVSEP(auth_rsa_key_allowed(pw, client_n, &key))) {
		auth_clear_options();
		return (0);
	}

	/* Perform the challenge-response dialog for this key. */
	if (!auth_rsa_challenge_dialog(key)) {
		/* Wrong response. */
		verbose("Wrong response to RSA authentication challenge.");
		packet_send_debug("Wrong response to RSA authentication challenge.");
		/*
		 * Break out of the loop. Otherwise we might send
		 * another challenge and break the protocol.
		 */
		key_free(key);
		return (0);
	}
	/*
	 * Correct response.  The client has been successfully
	 * authenticated. Note that we have not yet processed the
	 * options; this will be reset if the options cause the
	 * authentication to be rejected.
	 */
	fp = key_fingerprint(key, SSH_FP_MD5, SSH_FP_HEX);
	verbose("Found matching %s key: %s",
	    key_type(key), fp);
	xfree(fp);
	key_free(key);

	packet_send_debug("RSA authentication accepted.");
	return (1);
}
@


1.9
log
@merge
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rsa.c,v 1.72 2006/11/06 21:25:27 markus Exp $ */
d45 1
a45 1
__RCSID("$MirOS: src/usr.bin/ssh/auth-rsa.c,v 1.8 2006/09/20 21:40:55 tg Exp $");
a171 1
	struct stat st;
d180 1
a180 10

	/* Fail quietly if file does not exist */
	if (stat(file, &st) < 0) {
		/* Restore the privileged uid. */
		restore_uid();
		xfree(file);
		return (0);
	}
	/* Open the file containing the authorised keys. */
	f = fopen(file, "r");
a181 7
		/* Restore the privileged uid. */
		restore_uid();
		xfree(file);
		return (0);
	}
	if (options.strict_modes &&
	    secure_filename(f, file, pw, line, sizeof(line)) != 0) {
a182 2
		fclose(f);
		logit("Authentication refused: %s", line);
@


1.8
log
@finish merging
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rsa.c,v 1.71 2006/08/03 03:34:41 deraadt Exp $ */
d45 1
a45 1
__RCSID("$MirOS$");
d75 2
a76 1
	BN_rand(challenge, 256, 0, 0);
d78 3
a80 2
		fatal("auth_rsa_generate_challenge: BN_CTX_new() failed");
	BN_mod(challenge, challenge, key->rsa->n, ctx);
@


1.7
log
@fix spelling and pubkey authentication
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rsa.c,v 1.67 2006/03/25 18:29:35 deraadt Exp $ */
d17 1
a17 3
#include "includes.h"
__RCSID("$MirOS: src/usr.bin/ssh/auth-rsa.c,v 1.6 2006/04/19 10:40:43 tg Exp $");

d23 5
a29 1
#include "xmalloc.h"
d33 1
d38 2
a40 1
#include "hostfile.h"
d45 2
@


1.6
log
@merge and clean up
@
text
@d18 1
a18 1
__RCSID("$MirOS: src/usr.bin/ssh/auth-rsa.c,v 1.5 2006/02/22 01:23:48 tg Exp $");
d51 1
a51 1
 * The .etc/ssh/authorized_keys file contains public keys, one per line, in the
d170 2
a171 2
	/* The authorized keys. */
	file = authorized_keys_file(pw);
d181 1
a181 1
	/* Open the file containing the authorized keys. */
@


1.5
log
@merge; bump version; fix up manpages and includes a little
@
text
@d1 1
d18 1
a18 1
RCSID("$MirOS: src/usr.bin/ssh/auth-rsa.c,v 1.4 2006/02/21 02:12:25 tg Exp $");
d143 1
a143 1
		response[i] = packet_get_char();
@


1.4
log
@use libc MD5, not openssl one
@
text
@d17 3
a19 1
RCSID("$MirOS: src/usr.bin/ssh/auth-rsa.c,v 1.3 2005/06/22 16:11:39 tg Exp $");
@


1.3
log
@merge
@
text
@d17 1
a17 1
RCSID("$MirOS: src/usr.bin/ssh/auth-rsa.c,v 1.2 2005/03/13 18:33:29 tg Exp $");
d20 1
a20 1
#include <openssl/md5.h>
d95 4
a98 4
	MD5_Init(&md);
	MD5_Update(&md, buf, 32);
	MD5_Update(&md, session_id, 16);
	MD5_Final(mdbuf, &md);
@


1.2
log
@merge src/usr.bin
@
text
@d17 1
a17 1
RCSID("$MirOS$");
d208 1
d247 2
a248 1
		if (bits != BN_num_bits(key->rsa->n))
@


1.1
log
@Initial revision
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.62 2004/12/11 01:48:56 dtucker Exp $");
d48 1
a48 1
 * The .ssh/authorized_keys file contains public keys, one per line, in the
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@most current OpenSSH.com
@
text
@d17 1
a17 1
RCSID("$OpenBSD: auth-rsa.c,v 1.63 2005/06/17 02:44:32 djm Exp $");
a207 1
		int keybits;
d246 1
a246 2
		keybits = BN_num_bits(key->rsa->n);
		if (keybits < 0 || bits != (u_int)keybits)
@


1.1.1.3
log
@import OpenSSH-current
@
text
@d17 1
a17 4
RCSID("$OpenBSD: auth-rsa.c,v 1.64 2006/02/20 17:19:53 stevesk Exp $");

#include <sys/types.h>
#include <sys/stat.h>
@


1.1.1.4
log
@I decided we'd better upgrade OpenSSH before releasing to the general public
@
text
@a0 1
/* $OpenBSD: auth-rsa.c,v 1.67 2006/03/25 18:29:35 deraadt Exp $ */
d17 1
d143 1
a143 1
		response[i] = (u_char)packet_get_char();
@


1.1.1.5
log
@import a few security-wise relevant changes right now
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rsa.c,v 1.71 2006/08/03 03:34:41 deraadt Exp $ */
d17 2
a24 5
#include <pwd.h>
#include <stdio.h>
#include <string.h>

#include "xmalloc.h"
d27 1
a30 1
#include "buffer.h"
d35 1
a35 1
#include "key.h"
a36 4
#include "auth.h"
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
@


1.1.1.6
log
@OpenSSH 4.5 (security)
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rsa.c,v 1.72 2006/11/06 21:25:27 markus Exp $ */
d76 1
a76 2
	if (BN_rand(challenge, 256, 0, 0) == 0)
		fatal("auth_rsa_generate_challenge: BN_rand failed");
d78 2
a79 3
		fatal("auth_rsa_generate_challenge: BN_CTX_new failed");
	if (BN_mod(challenge, challenge, key->rsa->n, ctx) == 0)
		fatal("auth_rsa_generate_challenge: BN_mod failed");
@


1.1.1.7
log
@OpenSSH-current
@
text
@d1 1
a1 1
/* $OpenBSD: auth-rsa.c,v 1.73 2008/07/02 12:03:51 dtucker Exp $ */
d173 1
d182 10
a191 1
	f = auth_openkeyfile(file, pw, options.strict_modes);
d193 7
d201 2
@


