head	1.6;
access;
symbols
	cvs-200910041320:1.1.1.8
	cvs-200903221200:1.1.1.8
	cvs-200812162015:1.1.1.7
	cvs-200804031830:1.1.1.6
	MIRBSD_10:1.3.0.2
	MIRBSD_10_BASE:1.3
	cvs-200803022030:1.1.1.5
	cvs-200709131337:1.1.1.5
	cvs-200709021830:1.1.1.5
	cvs-200708201200:1.1.1.5
	cvs-200706161500:1.1.1.5
	cvs-200705192215:1.1.1.5
	cvs-200704292000:1.1.1.5
	cvs-200703080900:1.1.1.5
	cvs-200701251600:1.1.1.5
	cvs-200612111600:1.1.1.5
	cvs-200611090230:1.1.1.5
	OPENBSD_4_0:1.1.1.5
	MIRBSD_9_BASE:1.1.1.4
	cvs-200606162342:1.1.1.4
	cvs-200606022000:1.1.1.4
	cvs-200604191000:1.1.1.4
	cvs-200602220045:1.1.1.3
	MIRBSD_8:1.1.1.3.0.2
	MIRBSD_8_BASE:1.1.1.3
	cvs-200512201942:1.1.1.3
	cvs-200511231930:1.1.1.2
	cvs-200507211800:1.1.1.2
	cvs-200506221550:1.1.1.2
	cvs-200505050030:1.1.1.2
	cvs-200504291700:1.1.1.2
	cvs-200504261445:1.1.1.2
	cvs-200504141900:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2009.03.22.15.01.11;	author tg;	state Exp;
branches;
next	1.5;
commitid	10049C652CD5CCC321F;

1.5
date	2008.12.16.20.55.18;	author tg;	state Exp;
branches;
next	1.4;
commitid	100494815C97ECEEDBF;

1.4
date	2008.04.03.18.39.37;	author tg;	state Exp;
branches;
next	1.3;
commitid	10047F5247E47E55C5E;

1.3
date	2006.09.20.21.40.55;	author tg;	state Exp;
branches
	1.3.2.1;
next	1.2;
commitid	1004511B578580E7F04;

1.2
date	2006.07.23.14.19.26;	author tg;	state Exp;
branches;
next	1.1;
commitid	10044C3857E74BD315F;

1.1
date	2005.02.05.17.29.52;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2008.04.05.20.12.17;	author tg;	state Exp;
branches;
next	;
commitid	10047F7DD234C13F66E;

1.1.1.1
date	2005.02.05.17.29.52;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.14.19.33.21;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.12.20.19.43.42;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	10043A85EF81EF097CF;

1.1.1.4
date	2006.04.19.10.15.02;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	10044460DB21E1F715C;

1.1.1.5
date	2006.09.20.19.06.47;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	10045119150397FC669;

1.1.1.6
date	2008.04.03.18.34.30;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	10047F5234C593EA799;

1.1.1.7
date	2008.12.16.20.15.31;	author tg;	state Exp;
branches;
next	1.1.1.8;
commitid	10049480C7A2701F5C0;

1.1.1.8
date	2009.03.22.12.02.59;	author tg;	state Exp;
branches;
next	;
commitid	10049C6290649163EA3;


desc
@@


1.6
log
@merge and tweak ciphers and MACs
@
text
@/* $OpenBSD: auth-options.c,v 1.44 2009/01/22 10:09:16 djm Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */

#include <sys/types.h>
#include <sys/queue.h>

#include <netdb.h>
#include <pwd.h>
#include <string.h>
#include <stdio.h>
#include <stdarg.h>

#include "xmalloc.h"
#include "match.h"
#include "log.h"
#include "canohost.h"
#include "buffer.h"
#include "channels.h"
#include "auth-options.h"
#include "servconf.h"
#include "misc.h"
#include "key.h"
#include "hostfile.h"
#include "auth.h"
#include "monitor_wrap.h"

__RCSID("$MirOS: src/usr.bin/ssh/auth-options.c,v 1.5 2008/12/16 20:55:18 tg Exp $");

/* Flags set authorised_keys flags */
int no_port_forwarding_flag = 0;
int no_agent_forwarding_flag = 0;
int no_x11_forwarding_flag = 0;
int no_pty_flag = 0;
int no_user_rc = 0;

/* "command=" option. */
char *forced_command = NULL;

/* "environment=" options. */
struct envstring *custom_environment = NULL;

/* "tunnel=" option. */
int forced_tun_device = -1;

extern ServerOptions options;

void
auth_clear_options(void)
{
	no_agent_forwarding_flag = 0;
	no_port_forwarding_flag = 0;
	no_pty_flag = 0;
	no_x11_forwarding_flag = 0;
	no_user_rc = 0;
	while (custom_environment) {
		struct envstring *ce = custom_environment;
		custom_environment = ce->next;
		xfree(ce->s);
		xfree(ce);
	}
	if (forced_command) {
		xfree(forced_command);
		forced_command = NULL;
	}
	forced_tun_device = -1;
	channel_clear_permitted_opens();
	auth_debug_reset();
}

/*
 * return 1 if access is granted, 0 if not.
 * side effect: sets key option flags
 */
int
auth_parse_options(struct passwd *pw, char *opts, char *file, u_long linenum)
{
	const char *cp;
	int i;

	/* reset options */
	auth_clear_options();

	if (!opts)
		return 1;

	while (*opts && *opts != ' ' && *opts != '\t') {
		cp = "no-port-forwarding";
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
			auth_debug_add("Port forwarding disabled.");
			no_port_forwarding_flag = 1;
			opts += strlen(cp);
			goto next_option;
		}
		cp = "no-agent-forwarding";
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
			auth_debug_add("Agent forwarding disabled.");
			no_agent_forwarding_flag = 1;
			opts += strlen(cp);
			goto next_option;
		}
		cp = "no-X11-forwarding";
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
			auth_debug_add("X11 forwarding disabled.");
			no_x11_forwarding_flag = 1;
			opts += strlen(cp);
			goto next_option;
		}
		cp = "no-pty";
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
			auth_debug_add("Pty allocation disabled.");
			no_pty_flag = 1;
			opts += strlen(cp);
			goto next_option;
		}
		cp = "no-user-rc";
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
			auth_debug_add("User rc file execution disabled.");
			no_user_rc = 1;
			opts += strlen(cp);
			goto next_option;
		}
		cp = "command=\"";
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
			opts += strlen(cp);
			forced_command = xmalloc(strlen(opts) + 1);
			i = 0;
			while (*opts) {
				if (*opts == '"')
					break;
				if (*opts == '\\' && opts[1] == '"') {
					opts += 2;
					forced_command[i++] = '"';
					continue;
				}
				forced_command[i++] = *opts++;
			}
			if (!*opts) {
				debug("%.100s, line %lu: missing end quote",
				    file, linenum);
				auth_debug_add("%.100s, line %lu: missing end quote",
				    file, linenum);
				xfree(forced_command);
				forced_command = NULL;
				goto bad_option;
			}
			forced_command[i] = '\0';
			auth_debug_add("Forced command: %.900s", forced_command);
			opts++;
			goto next_option;
		}
		cp = "environment=\"";
		if (options.permit_user_env &&
		    strncasecmp(opts, cp, strlen(cp)) == 0) {
			char *s;
			struct envstring *new_envstring;

			opts += strlen(cp);
			s = xmalloc(strlen(opts) + 1);
			i = 0;
			while (*opts) {
				if (*opts == '"')
					break;
				if (*opts == '\\' && opts[1] == '"') {
					opts += 2;
					s[i++] = '"';
					continue;
				}
				s[i++] = *opts++;
			}
			if (!*opts) {
				debug("%.100s, line %lu: missing end quote",
				    file, linenum);
				auth_debug_add("%.100s, line %lu: missing end quote",
				    file, linenum);
				xfree(s);
				goto bad_option;
			}
			s[i] = '\0';
			auth_debug_add("Adding to environment: %.900s", s);
			debug("Adding to environment: %.900s", s);
			opts++;
			new_envstring = xmalloc(sizeof(struct envstring));
			new_envstring->s = s;
			new_envstring->next = custom_environment;
			custom_environment = new_envstring;
			goto next_option;
		}
		cp = "from=\"";
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
			const char *remote_ip = get_remote_ipaddr();
			const char *remote_host = get_canonical_hostname(
			    options.use_dns);
			char *patterns = xmalloc(strlen(opts) + 1);

			opts += strlen(cp);
			i = 0;
			while (*opts) {
				if (*opts == '"')
					break;
				if (*opts == '\\' && opts[1] == '"') {
					opts += 2;
					patterns[i++] = '"';
					continue;
				}
				patterns[i++] = *opts++;
			}
			if (!*opts) {
				debug("%.100s, line %lu: missing end quote",
				    file, linenum);
				auth_debug_add("%.100s, line %lu: missing end quote",
				    file, linenum);
				xfree(patterns);
				goto bad_option;
			}
			patterns[i] = '\0';
			opts++;
			switch (match_host_and_ip(remote_host, remote_ip,
			    patterns)) {
			case 1:
				xfree(patterns);
				/* Host name matches. */
				goto next_option;
			case -1:
				debug("%.100s, line %lu: invalid criteria",
				    file, linenum);
				auth_debug_add("%.100s, line %lu: "
				    "invalid criteria", file, linenum);
				/* FALLTHROUGH */
			case 0:
				xfree(patterns);
				logit("Authentication tried for %.100s with "
				    "correct key but not from a permitted "
				    "host (host=%.200s, ip=%.200s).",
				    pw->pw_name, remote_host, remote_ip);
				auth_debug_add("Your host '%.200s' is not "
				    "permitted to use this key for login.",
				    remote_host);
				break;
			}
			/* deny access */
			return 0;
		}
		cp = "permitopen=\"";
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
			char *host, *p;
			int port;
			char *patterns = xmalloc(strlen(opts) + 1);

			opts += strlen(cp);
			i = 0;
			while (*opts) {
				if (*opts == '"')
					break;
				if (*opts == '\\' && opts[1] == '"') {
					opts += 2;
					patterns[i++] = '"';
					continue;
				}
				patterns[i++] = *opts++;
			}
			if (!*opts) {
				debug("%.100s, line %lu: missing end quote",
				    file, linenum);
				auth_debug_add("%.100s, line %lu: missing "
				    "end quote", file, linenum);
				xfree(patterns);
				goto bad_option;
			}
			patterns[i] = '\0';
			opts++;
			p = patterns;
			host = hpdelim(&p);
			if (host == NULL || strlen(host) >= NI_MAXHOST) {
				debug("%.100s, line %lu: Bad permitopen "
				    "specification <%.100s>", file, linenum,
				    patterns);
				auth_debug_add("%.100s, line %lu: "
				    "Bad permitopen specification", file,
				    linenum);
				xfree(patterns);
				goto bad_option;
			}
			host = cleanhostname(host);
			if (p == NULL || (port = a2port(p)) <= 0) {
				debug("%.100s, line %lu: Bad permitopen port "
				    "<%.100s>", file, linenum, p ? p : "");
				auth_debug_add("%.100s, line %lu: "
				    "Bad permitopen port", file, linenum);
				xfree(patterns);
				goto bad_option;
			}
			if (options.allow_tcp_forwarding)
				channel_add_permitted_opens(host, port);
			xfree(patterns);
			goto next_option;
		}
		cp = "tunnel=\"";
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
			char *tun = NULL;
			opts += strlen(cp);
			tun = xmalloc(strlen(opts) + 1);
			i = 0;
			while (*opts) {
				if (*opts == '"')
					break;
				tun[i++] = *opts++;
			}
			if (!*opts) {
				debug("%.100s, line %lu: missing end quote",
				    file, linenum);
				auth_debug_add("%.100s, line %lu: missing end quote",
				    file, linenum);
				xfree(tun);
				forced_tun_device = -1;
				goto bad_option;
			}
			tun[i] = '\0';
			forced_tun_device = a2tun(tun, NULL);
			xfree(tun);
			if (forced_tun_device == SSH_TUNID_ERR) {
				debug("%.100s, line %lu: invalid tun device",
				    file, linenum);
				auth_debug_add("%.100s, line %lu: invalid tun device",
				    file, linenum);
				forced_tun_device = -1;
				goto bad_option;
			}
			auth_debug_add("Forced tun device: %d", forced_tun_device);
			opts++;
			goto next_option;
		}
next_option:
		/*
		 * Skip the comma, and move to the next option
		 * (or break out if there are no more).
		 */
		if (!*opts)
			fatal("Bugs in auth-options.c option processing.");
		if (*opts == ' ' || *opts == '\t')
			break;		/* End of options. */
		if (*opts != ',')
			goto bad_option;
		opts++;
		/* Process the next option. */
	}

	if (!use_privsep)
		auth_debug_send();

	/* grant access */
	return 1;

bad_option:
	logit("Bad options in %.100s file, line %lu: %.50s",
	    file, linenum, opts);
	auth_debug_add("Bad options in %.100s file, line %lu: %.50s",
	    file, linenum, opts);

	if (!use_privsep)
		auth_debug_send();

	/* deny access */
	return 0;
}
@


1.5
log
@fastmerge, do not use yet!
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.43 2008/06/10 23:06:19 djm Exp $ */
d36 1
a36 1
__RCSID("$MirOS: src/usr.bin/ssh/auth-options.c,v 1.4 2008/04/03 18:39:37 tg Exp $");
d255 1
a255 1
			u_short port;
d293 1
a293 1
			if (p == NULL || (port = a2port(p)) == 0) {
@


1.4
log
@fastmerge
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.41 2008/03/26 21:28:14 djm Exp $ */
d14 1
d36 1
a36 1
__RCSID("$MirOS: src/usr.bin/ssh/auth-options.c,v 1.3 2006/09/20 21:40:55 tg Exp $");
d226 13
a238 2
			if (match_host_and_ip(remote_host, remote_ip,
			    patterns) != 1) {
d247 1
a247 2
				/* deny access */
				return 0;
d249 2
a250 3
			xfree(patterns);
			/* Host name matches. */
			goto next_option;
@


1.3
log
@finish merging
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.40 2006/08/03 03:34:41 deraadt Exp $ */
d35 1
a35 1
__RCSID("$MirOS: src/usr.bin/ssh/auth-options.c,v 1.2 2006/07/23 14:19:26 tg Exp $");
d42 1
d62 1
d123 7
@


1.3.2.1
log
@MFC all OpenSSL and OpenSSH fixes (≥ 3 CVEs), requested by bsiegert@@ who will update errata10.hts himself ☻
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.41 2008/03/26 21:28:14 djm Exp $ */
d35 1
a35 1
__RCSID("$MirOS: src/usr.bin/ssh/auth-options.c,v 1.4 2008/04/03 18:39:37 tg Exp $");
a41 1
int no_user_rc = 0;
a60 1
	no_user_rc = 0;
a120 7
		cp = "no-user-rc";
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
			auth_debug_add("User rc file execution disabled.");
			no_user_rc = 1;
			opts += strlen(cp);
			goto next_option;
		}
@


1.2
log
@fix spelling and pubkey authentication
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.35 2006/03/25 13:17:01 djm Exp $ */
d13 7
a19 1
#include "includes.h"
d25 1
d30 3
a33 1
#include "auth.h"
d35 1
a35 1
__RCSID("$MirOS$");
d145 1
a145 1
			forced_command[i] = 0;
d177 1
a177 1
			s[i] = 0;
d214 1
a214 1
			patterns[i] = 0;
d259 1
a259 1
			patterns[i] = 0;
d307 1
a307 1
			tun[i] = 0;
@


1.1
log
@Initial revision
@
text
@d1 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.28 2003/06/02 09:17:34 markus Exp $");
d26 3
a28 1
/* Flags set authorized_keys flags */
d40 3
d62 1
d226 1
a226 1
			char host[256], sport[6];
d245 2
a246 2
				auth_debug_add("%.100s, line %lu: missing end quote",
				    file, linenum);
d252 6
a257 4
			if (sscanf(patterns, "%255[^:]:%5[0-9]", host, sport) != 2 &&
			    sscanf(patterns, "%255[^/]/%5[0-9]", host, sport) != 2) {
				debug("%.100s, line %lu: Bad permitopen specification "
				    "<%.100s>", file, linenum, patterns);
d259 2
a260 1
				    "Bad permitopen specification", file, linenum);
d264 4
a267 3
			if ((port = a2port(sport)) == 0) {
				debug("%.100s, line %lu: Bad permitopen port <%.100s>",
				    file, linenum, sport);
d278 35
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@OpenSSH-current
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.31 2005/03/10 22:40:38 deraadt Exp $");
d220 1
a220 1
			char *host, *p;
d239 2
a240 2
				auth_debug_add("%.100s, line %lu: missing "
				    "end quote", file, linenum);
d246 4
a249 6
			p = patterns;
			host = hpdelim(&p);
			if (host == NULL || strlen(host) >= NI_MAXHOST) {
				debug("%.100s, line %lu: Bad permitopen "
				    "specification <%.100s>", file, linenum,
				    patterns);
d251 1
a251 2
				    "Bad permitopen specification", file,
				    linenum);
d255 3
a257 4
			host = cleanhostname(host);
			if (p == NULL || (port = a2port(p)) == 0) {
				debug("%.100s, line %lu: Bad permitopen port "
				    "<%.100s>", file, linenum, p ? p : "");
@


1.1.1.3
log
@OpenSSH is the last missing piece to update before the release
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth-options.c,v 1.33 2005/12/08 18:34:11 reyk Exp $");
a37 3
/* "tunnel=" option. */
int forced_tun_device = -1;

a56 1
	forced_tun_device = -1;
a271 35
		cp = "tunnel=\"";
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
			char *tun = NULL;
			opts += strlen(cp);
			tun = xmalloc(strlen(opts) + 1);
			i = 0;
			while (*opts) {
				if (*opts == '"')
					break;
				tun[i++] = *opts++;
			}
			if (!*opts) {
				debug("%.100s, line %lu: missing end quote",
				    file, linenum);
				auth_debug_add("%.100s, line %lu: missing end quote",
				    file, linenum);
				xfree(tun);
				forced_tun_device = -1;
				goto bad_option;
			}
			tun[i] = 0;
			forced_tun_device = a2tun(tun, NULL);
			xfree(tun);
			if (forced_tun_device == SSH_TUNID_ERR) {
				debug("%.100s, line %lu: invalid tun device",
				    file, linenum);
				auth_debug_add("%.100s, line %lu: invalid tun device",
				    file, linenum);
				forced_tun_device = -1;
				goto bad_option;
			}
			auth_debug_add("Forced tun device: %d", forced_tun_device);
			opts++;
			goto next_option;
		}
@


1.1.1.4
log
@I decided we'd better upgrade OpenSSH before releasing to the general public
@
text
@a0 1
/* $OpenBSD: auth-options.c,v 1.35 2006/03/25 13:17:01 djm Exp $ */
d13 1
@


1.1.1.5
log
@import a few security-wise relevant changes right now
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.40 2006/08/03 03:34:41 deraadt Exp $ */
d13 1
a13 7
#include <sys/types.h>

#include <netdb.h>
#include <pwd.h>
#include <string.h>
#include <stdio.h>
#include <stdarg.h>
a18 1
#include "buffer.h"
d23 1
a23 2
#include "key.h"
#include "hostfile.h"
a24 4
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
#include "monitor_wrap.h"
d134 1
a134 1
			forced_command[i] = '\0';
d166 1
a166 1
			s[i] = '\0';
d203 1
a203 1
			patterns[i] = '\0';
d248 1
a248 1
			patterns[i] = '\0';
d296 1
a296 1
			tun[i] = '\0';
@


1.1.1.6
log
@OpenSSH 5.0
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.41 2008/03/26 21:28:14 djm Exp $ */
a42 1
int no_user_rc = 0;
a61 1
	no_user_rc = 0;
a121 7
		cp = "no-user-rc";
		if (strncasecmp(opts, cp, strlen(cp)) == 0) {
			auth_debug_add("User rc file execution disabled.");
			no_user_rc = 1;
			opts += strlen(cp);
			goto next_option;
		}
@


1.1.1.7
log
@OpenSSH-current
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.43 2008/06/10 23:06:19 djm Exp $ */
a13 1
#include <sys/queue.h>
d226 2
a227 13
			switch (match_host_and_ip(remote_host, remote_ip,
			    patterns)) {
			case 1:
				xfree(patterns);
				/* Host name matches. */
				goto next_option;
			case -1:
				debug("%.100s, line %lu: invalid criteria",
				    file, linenum);
				auth_debug_add("%.100s, line %lu: "
				    "invalid criteria", file, linenum);
				/* FALLTHROUGH */
			case 0:
d236 2
a237 1
				break;
d239 3
a241 2
			/* deny access */
			return 0;
@


1.1.1.8
log
@OpenSSH 5.2, or so
@
text
@d1 1
a1 1
/* $OpenBSD: auth-options.c,v 1.44 2009/01/22 10:09:16 djm Exp $ */
d256 1
a256 1
			int port;
d294 1
a294 1
			if (p == NULL || (port = a2port(p)) <= 0) {
@


