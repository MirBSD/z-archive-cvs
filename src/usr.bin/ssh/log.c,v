head	1.6;
access;
symbols
	cvs-200910041320:1.1.1.5
	cvs-200903221200:1.1.1.5
	cvs-200812162015:1.1.1.5
	cvs-200804031830:1.1.1.4
	MIRBSD_10:1.5.0.2
	MIRBSD_10_BASE:1.5
	cvs-200803022030:1.1.1.4
	cvs-200709131337:1.1.1.4
	cvs-200709021830:1.1.1.4
	cvs-200708201200:1.1.1.4
	cvs-200706161500:1.1.1.4
	cvs-200705192215:1.1.1.4
	cvs-200704292000:1.1.1.3
	cvs-200703080900:1.1.1.3
	cvs-200701251600:1.1.1.3
	cvs-200612111600:1.1.1.3
	cvs-200611090230:1.1.1.3
	OPENBSD_4_0:1.1.1.3
	MIRBSD_9_BASE:1.3
	cvs-200606162342:1.1.1.2
	cvs-200606022000:1.1.1.2
	cvs-200604191000:1.1.1.2
	cvs-200602220045:1.1.1.1
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200512201942:1.1.1.1
	cvs-200511231930:1.1.1.1
	cvs-200507211800:1.1.1.1
	cvs-200506221550:1.1.1.1
	cvs-200505050030:1.1.1.1
	cvs-200504291700:1.1.1.1
	cvs-200504261445:1.1.1.1
	cvs-200504141900:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2008.12.16.20.55.22;	author tg;	state Exp;
branches;
next	1.5;
commitid	100494815C97ECEEDBF;

1.5
date	2007.05.19.22.22.25;	author tg;	state Exp;
branches;
next	1.4;
commitid	100464F78B83D4D02C5;

1.4
date	2006.09.20.21.40.59;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004511B578580E7F04;

1.3
date	2006.04.19.10.40.48;	author tg;	state Exp;
branches;
next	1.2;
commitid	100444613BD3A91C28B;

1.2
date	2006.02.22.02.16.46;	author tg;	state Exp;
branches;
next	1.1;
commitid	10043FBC991512A442B;

1.1
date	2005.02.05.17.29.52;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.29.52;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.04.19.10.15.03;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	10044460DB21E1F715C;

1.1.1.3
date	2006.09.20.19.06.48;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	10045119150397FC669;

1.1.1.4
date	2007.05.19.22.17.17;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	100464F777F381179CF;

1.1.1.5
date	2008.12.16.20.15.33;	author tg;	state Exp;
branches;
next	;
commitid	10049480C7A2701F5C0;


desc
@@


1.6
log
@fastmerge, do not use yet!
@
text
@/* $OpenBSD: log.c,v 1.41 2008/06/10 04:50:25 dtucker Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */
/*
 * Copyright (c) 2000 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
#include <errno.h>
#include <vis.h>

#include "xmalloc.h"
#include "log.h"

__RCSID("$MirOS: src/usr.bin/ssh/log.c,v 1.5 2007/05/19 22:22:25 tg Exp $");

static LogLevel log_level = SYSLOG_LEVEL_INFO;
static int log_on_stderr = 1;
static int log_facility = LOG_AUTH;
static const char *argv0;

extern char *__progname;

/* textual representation of log-facilities/levels */

static struct {
	const char *name;
	SyslogFacility val;
} log_facilities[] = {
	{ "DAEMON",	SYSLOG_FACILITY_DAEMON },
	{ "USER",	SYSLOG_FACILITY_USER },
	{ "AUTH",	SYSLOG_FACILITY_AUTH },
	{ "LOCAL0",	SYSLOG_FACILITY_LOCAL0 },
	{ "LOCAL1",	SYSLOG_FACILITY_LOCAL1 },
	{ "LOCAL2",	SYSLOG_FACILITY_LOCAL2 },
	{ "LOCAL3",	SYSLOG_FACILITY_LOCAL3 },
	{ "LOCAL4",	SYSLOG_FACILITY_LOCAL4 },
	{ "LOCAL5",	SYSLOG_FACILITY_LOCAL5 },
	{ "LOCAL6",	SYSLOG_FACILITY_LOCAL6 },
	{ "LOCAL7",	SYSLOG_FACILITY_LOCAL7 },
	{ NULL,		SYSLOG_FACILITY_NOT_SET }
};

static struct {
	const char *name;
	LogLevel val;
} log_levels[] =
{
	{ "QUIET",	SYSLOG_LEVEL_QUIET },
	{ "FATAL",	SYSLOG_LEVEL_FATAL },
	{ "ERROR",	SYSLOG_LEVEL_ERROR },
	{ "INFO",	SYSLOG_LEVEL_INFO },
	{ "VERBOSE",	SYSLOG_LEVEL_VERBOSE },
	{ "DEBUG",	SYSLOG_LEVEL_DEBUG1 },
	{ "DEBUG1",	SYSLOG_LEVEL_DEBUG1 },
	{ "DEBUG2",	SYSLOG_LEVEL_DEBUG2 },
	{ "DEBUG3",	SYSLOG_LEVEL_DEBUG3 },
	{ NULL,		SYSLOG_LEVEL_NOT_SET }
};

SyslogFacility
log_facility_number(char *name)
{
	int i;

	if (name != NULL)
		for (i = 0; log_facilities[i].name; i++)
			if (strcasecmp(log_facilities[i].name, name) == 0)
				return log_facilities[i].val;
	return SYSLOG_FACILITY_NOT_SET;
}

const char *
log_facility_name(SyslogFacility facility)
{
	u_int i;

	for (i = 0;  log_facilities[i].name; i++)
		if (log_facilities[i].val == facility)
			return log_facilities[i].name;
	return NULL;
}

LogLevel
log_level_number(char *name)
{
	int i;

	if (name != NULL)
		for (i = 0; log_levels[i].name; i++)
			if (strcasecmp(log_levels[i].name, name) == 0)
				return log_levels[i].val;
	return SYSLOG_LEVEL_NOT_SET;
}

const char *
log_level_name(LogLevel level)
{
	u_int i;

	for (i = 0; log_levels[i].name != NULL; i++)
		if (log_levels[i].val == level)
			return log_levels[i].name;
	return NULL;
}

/* Error messages that should be logged. */

void
error(const char *fmt,...)
{
	va_list args;

	va_start(args, fmt);
	do_log(SYSLOG_LEVEL_ERROR, fmt, args);
	va_end(args);
}

void
sigdie(const char *fmt,...)
{
	va_list args;

	va_start(args, fmt);
	do_log(SYSLOG_LEVEL_FATAL, fmt, args);
	va_end(args);
	_exit(1);
}


/* Log this message (information that usually should go to the log). */

void
logit(const char *fmt,...)
{
	va_list args;

	va_start(args, fmt);
	do_log(SYSLOG_LEVEL_INFO, fmt, args);
	va_end(args);
}

/* More detailed messages (information that does not need to go to the log). */

void
verbose(const char *fmt,...)
{
	va_list args;

	va_start(args, fmt);
	do_log(SYSLOG_LEVEL_VERBOSE, fmt, args);
	va_end(args);
}

/* Debugging messages that should not be logged during normal operation. */

void
debug(const char *fmt,...)
{
	va_list args;

	va_start(args, fmt);
	do_log(SYSLOG_LEVEL_DEBUG1, fmt, args);
	va_end(args);
}

void
debug2(const char *fmt,...)
{
	va_list args;

	va_start(args, fmt);
	do_log(SYSLOG_LEVEL_DEBUG2, fmt, args);
	va_end(args);
}

void
debug3(const char *fmt,...)
{
	va_list args;

	va_start(args, fmt);
	do_log(SYSLOG_LEVEL_DEBUG3, fmt, args);
	va_end(args);
}

/*
 * Initialize the log.
 */

void
log_init(const char *av0, LogLevel level, SyslogFacility facility, int on_stderr)
{
	argv0 = av0;

	switch (level) {
	case SYSLOG_LEVEL_QUIET:
	case SYSLOG_LEVEL_FATAL:
	case SYSLOG_LEVEL_ERROR:
	case SYSLOG_LEVEL_INFO:
	case SYSLOG_LEVEL_VERBOSE:
	case SYSLOG_LEVEL_DEBUG1:
	case SYSLOG_LEVEL_DEBUG2:
	case SYSLOG_LEVEL_DEBUG3:
		log_level = level;
		break;
	default:
		fprintf(stderr, "Unrecognized internal syslog level code %d\n",
		    (int) level);
		exit(1);
	}

	log_on_stderr = on_stderr;
	if (on_stderr)
		return;

	switch (facility) {
	case SYSLOG_FACILITY_DAEMON:
		log_facility = LOG_DAEMON;
		break;
	case SYSLOG_FACILITY_USER:
		log_facility = LOG_USER;
		break;
	case SYSLOG_FACILITY_AUTH:
		log_facility = LOG_AUTH;
		break;
	case SYSLOG_FACILITY_LOCAL0:
		log_facility = LOG_LOCAL0;
		break;
	case SYSLOG_FACILITY_LOCAL1:
		log_facility = LOG_LOCAL1;
		break;
	case SYSLOG_FACILITY_LOCAL2:
		log_facility = LOG_LOCAL2;
		break;
	case SYSLOG_FACILITY_LOCAL3:
		log_facility = LOG_LOCAL3;
		break;
	case SYSLOG_FACILITY_LOCAL4:
		log_facility = LOG_LOCAL4;
		break;
	case SYSLOG_FACILITY_LOCAL5:
		log_facility = LOG_LOCAL5;
		break;
	case SYSLOG_FACILITY_LOCAL6:
		log_facility = LOG_LOCAL6;
		break;
	case SYSLOG_FACILITY_LOCAL7:
		log_facility = LOG_LOCAL7;
		break;
	default:
		fprintf(stderr,
		    "Unrecognized internal syslog facility code %d\n",
		    (int) facility);
		exit(1);
	}
}

#define MSGBUFSIZ 1024

void
do_log(LogLevel level, const char *fmt, va_list args)
{
	struct syslog_data sdata = SYSLOG_DATA_INIT;
	char msgbuf[MSGBUFSIZ];
	char fmtbuf[MSGBUFSIZ];
	const char *txt = NULL;
	int pri = LOG_INFO;
	int saved_errno = errno;

	if (level > log_level)
		return;

	switch (level) {
	case SYSLOG_LEVEL_FATAL:
		if (!log_on_stderr)
			txt = "fatal";
		pri = LOG_CRIT;
		break;
	case SYSLOG_LEVEL_ERROR:
		if (!log_on_stderr)
			txt = "error";
		pri = LOG_ERR;
		break;
	case SYSLOG_LEVEL_INFO:
		pri = LOG_INFO;
		break;
	case SYSLOG_LEVEL_VERBOSE:
		pri = LOG_INFO;
		break;
	case SYSLOG_LEVEL_DEBUG1:
		txt = "debug1";
		pri = LOG_DEBUG;
		break;
	case SYSLOG_LEVEL_DEBUG2:
		txt = "debug2";
		pri = LOG_DEBUG;
		break;
	case SYSLOG_LEVEL_DEBUG3:
		txt = "debug3";
		pri = LOG_DEBUG;
		break;
	default:
		txt = "internal error";
		pri = LOG_ERR;
		break;
	}
	if (txt != NULL) {
		snprintf(fmtbuf, sizeof(fmtbuf), "%s: %s", txt, fmt);
		vsnprintf(msgbuf, sizeof(msgbuf), fmtbuf, args);
	} else {
		vsnprintf(msgbuf, sizeof(msgbuf), fmt, args);
	}
	strnvis(fmtbuf, msgbuf, sizeof(fmtbuf), VIS_SAFE|VIS_OCTAL);
	if (log_on_stderr) {
		snprintf(msgbuf, sizeof msgbuf, "%s\r\n", fmtbuf);
		write(STDERR_FILENO, msgbuf, strlen(msgbuf));
	} else {
		openlog_r(argv0 ? argv0 : __progname, LOG_PID, log_facility, &sdata);
		syslog_r(pri, &sdata, "%.500s", fmtbuf);
		closelog_r(&sdata);
	}
	errno = saved_errno;
}
@


1.5
log
@merge
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.40 2007/05/17 07:50:31 djm Exp $ */
d51 1
a51 1
__RCSID("$MirOS: src/usr.bin/ssh/log.c,v 1.4 2006/09/20 21:40:59 tg Exp $");
d109 11
d132 11
@


1.4
log
@finish merging
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.39 2006/08/18 09:13:25 deraadt Exp $ */
d45 1
d51 1
a51 1
__RCSID("$MirOS$");
d283 1
d337 1
@


1.3
log
@merge and clean up
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.31 2006/03/25 13:17:02 djm Exp $ */
d37 1
a37 2
#include "includes.h"
__RCSID("$MirOS: src/usr.bin/ssh/log.c,v 1.2 2006/02/22 02:16:46 tg Exp $");
d39 9
a48 1
#include "xmalloc.h"
d50 1
a50 2
#include <syslog.h>
#include <vis.h>
d132 12
@


1.2
log
@fix a lot of and kludge a few more __CRAZY problems, sync rcs id
@
text
@d1 1
d38 1
a38 1
RCSID("$MirOS: log.c,v 1.29 2003/09/23 20:17:11 markus Exp $");
@


1.1
log
@Initial revision
@
text
@d37 1
a37 1
RCSID("$OpenBSD: log.c,v 1.29 2003/09/23 20:17:11 markus Exp $");
d48 1
a48 1
static char *argv0;
d186 1
a186 1
log_init(char *av0, LogLevel level, SyslogFacility facility, int on_stderr)
d261 1
a261 1
	char *txt = NULL;
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@I decided we'd better upgrade OpenSSH before releasing to the general public
@
text
@a0 1
/* $OpenBSD: log.c,v 1.31 2006/03/25 13:17:02 djm Exp $ */
d37 1
@


1.1.1.3
log
@import a few security-wise relevant changes right now
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.39 2006/08/18 09:13:25 deraadt Exp $ */
d37 4
a40 1
#include <sys/types.h>
a41 4
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
a42 1
#include <unistd.h>
a44 3
#include "xmalloc.h"
#include "log.h"

a124 12
void
sigdie(const char *fmt,...)
{
	va_list args;

	va_start(args, fmt);
	do_log(SYSLOG_LEVEL_FATAL, fmt, args);
	va_end(args);
	_exit(1);
}


@


1.1.1.4
log
@new OpenSSH
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.40 2007/05/17 07:50:31 djm Exp $ */
a44 1
#include <errno.h>
a279 1
	int saved_errno = errno;
a332 1
	errno = saved_errno;
@


1.1.1.5
log
@OpenSSH-current
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.41 2008/06/10 04:50:25 dtucker Exp $ */
a106 11
const char *
log_facility_name(SyslogFacility facility)
{
	u_int i;

	for (i = 0;  log_facilities[i].name; i++)
		if (log_facilities[i].val == facility)
			return log_facilities[i].name;
	return NULL;
}

a118 11
const char *
log_level_name(LogLevel level)
{
	u_int i;

	for (i = 0; log_levels[i].name != NULL; i++)
		if (log_levels[i].val == level)
			return log_levels[i].name;
	return NULL;
}

@


