head	1.18;
access;
symbols
	cvs-200910041320:1.1.1.20
	cvs-200903221200:1.1.1.19
	cvs-200812162015:1.1.1.18
	cvs-200804031830:1.1.1.17
	MIRBSD_10:1.13.0.2
	MIRBSD_10_BASE:1.13
	cvs-200803022030:1.1.1.17
	cvs-200709131337:1.1.1.16
	cvs-200709021830:1.1.1.15
	cvs-200708201200:1.1.1.15
	cvs-200706161500:1.1.1.14
	cvs-200705192215:1.1.1.14
	cvs-200704292000:1.1.1.14
	cvs-200703080900:1.1.1.13
	cvs-200701251600:1.1.1.12
	cvs-200612111600:1.1.1.11
	cvs-200611090230:1.1.1.11
	OPENBSD_4_0:1.1.1.10
	MIRBSD_9_BASE:1.4
	cvs-200606162342:1.1.1.9
	cvs-200606022000:1.1.1.9
	cvs-200604191000:1.1.1.8
	cvs-200602220045:1.1.1.7
	MIRBSD_8:1.1.1.6.0.2
	MIRBSD_8_BASE:1.1.1.6
	cvs-200512201942:1.1.1.6
	cvs-200511231930:1.1.1.5
	cvs-200507211800:1.1.1.4
	cvs-200506221550:1.1.1.3
	cvs-200505050030:1.1.1.2
	cvs-200504291700:1.1.1.2
	cvs-200504261445:1.1.1.2
	cvs-200504141900:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2016.01.14.19.23.00;	author tg;	state Exp;
branches;
next	1.17;
commitid	1005697F5AA3EA7E36D;

1.17
date	2009.10.04.14.29.03;	author tg;	state Exp;
branches;
next	1.16;
commitid	1004AC8B1276FC00211;

1.16
date	2009.10.02.16.58.47;	author tg;	state Exp;
branches;
next	1.15;
commitid	1004AC6315648072669;

1.15
date	2009.03.22.15.01.15;	author tg;	state Exp;
branches;
next	1.14;
commitid	10049C652CD5CCC321F;

1.14
date	2008.12.16.20.55.20;	author tg;	state Exp;
branches;
next	1.13;
commitid	100494815C97ECEEDBF;

1.13
date	2008.03.02.21.14.19;	author tg;	state Exp;
branches;
next	1.12;
commitid	10047CB18BB506A8527;

1.12
date	2007.09.13.13.52.53;	author tg;	state Exp;
branches;
next	1.11;
commitid	10046E940B668DE9A0B;

1.11
date	2007.08.20.12.11.29;	author tg;	state Exp;
branches;
next	1.10;
commitid	10046C985053DA1DB8B;

1.10
date	2007.04.29.20.23.12;	author tg;	state Exp;
branches;
next	1.9;
commitid	1004634FEC2113C55F5;

1.9
date	2007.03.08.10.09.32;	author tg;	state Exp;
branches;
next	1.8;
commitid	10045EFE0F11EDE1747;

1.8
date	2007.01.25.16.18.36;	author tg;	state Exp;
branches;
next	1.7;
commitid	10045B8D86E5B698AD6;

1.7
date	2006.10.13.18.40.50;	author tg;	state Exp;
branches;
next	1.6;
commitid	100452FDDB7190872BF;

1.6
date	2006.09.20.21.40.58;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004511B578580E7F04;

1.5
date	2006.07.23.14.19.27;	author tg;	state Exp;
branches;
next	1.4;
commitid	10044C3857E74BD315F;

1.4
date	2006.06.02.20.50.47;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004480A4952B0D84EA;

1.3
date	2006.04.19.10.40.46;	author tg;	state Exp;
branches;
next	1.2;
commitid	100444613BD3A91C28B;

1.2
date	2006.02.22.01.23.49;	author tg;	state Exp;
branches;
next	1.1;
commitid	10043FBBD2C2C5E7D81;

1.1
date	2005.02.05.17.29.52;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.29.52;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.14.19.33.23;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.06.22.15.56.25;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	181342b98a38fe99;

1.1.1.4
date	2005.07.21.21.00.25;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	560042e0092f571e;

1.1.1.5
date	2005.11.23.19.34.14;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	116a4384c4467ffc;

1.1.1.6
date	2005.12.20.19.43.43;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	10043A85EF81EF097CF;

1.1.1.7
date	2006.02.22.00.51.35;	author tg;	state Exp;
branches;
next	1.1.1.8;
commitid	10043FBB5A933C3BB9B;

1.1.1.8
date	2006.04.19.10.15.03;	author tg;	state Exp;
branches;
next	1.1.1.9;
commitid	10044460DB21E1F715C;

1.1.1.9
date	2006.06.02.20.31.50;	author tg;	state Exp;
branches;
next	1.1.1.10;
commitid	1004480A0422110D712;

1.1.1.10
date	2006.09.20.19.06.48;	author tg;	state Exp;
branches;
next	1.1.1.11;
commitid	10045119150397FC669;

1.1.1.11
date	2006.11.09.02.37.59;	author tg;	state Exp;
branches;
next	1.1.1.12;
commitid	100455294981A6201C8;

1.1.1.12
date	2007.01.25.16.12.58;	author tg;	state Exp;
branches;
next	1.1.1.13;
commitid	10045B8D7100791C016;

1.1.1.13
date	2007.03.08.09.23.20;	author tg;	state Exp;
branches;
next	1.1.1.14;
commitid	10045EFD61903FC276A;

1.1.1.14
date	2007.04.29.20.07.01;	author tg;	state Exp;
branches;
next	1.1.1.15;
commitid	1004634FAED5BC54DF0;

1.1.1.15
date	2007.08.20.12.05.25;	author tg;	state Exp;
branches;
next	1.1.1.16;
commitid	10046C9839120FD28DF;

1.1.1.16
date	2007.09.13.13.38.54;	author tg;	state Exp;
branches;
next	1.1.1.17;
commitid	10046E93D7724AAC1F8;

1.1.1.17
date	2008.03.02.20.40.41;	author tg;	state Exp;
branches;
next	1.1.1.18;
commitid	10047CB10DD30FAF062;

1.1.1.18
date	2008.12.16.20.15.33;	author tg;	state Exp;
branches;
next	1.1.1.19;
commitid	10049480C7A2701F5C0;

1.1.1.19
date	2009.03.22.12.02.59;	author tg;	state Exp;
branches;
next	1.1.1.20;
commitid	10049C6290649163EA3;

1.1.1.20
date	2009.10.04.13.25.44;	author tg;	state Exp;
branches;
next	;
commitid	1004AC8A2663BC008C5;


desc
@@


1.18
log
@drop roaming code completely
@
text
@/* $OpenBSD: clientloop.c,v 1.213 2009/07/05 19:28:33 stevesk Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * The main loop for the interactive session (client side).
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 *
 * Copyright (c) 1999 Theo de Raadt.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * SSH2 support added by Markus Friedl.
 * Copyright (c) 1999, 2000, 2001 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/queue.h>

#include <ctype.h>
#include <errno.h>
#include <paths.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <pwd.h>
#include <unistd.h>

#include "xmalloc.h"
#include "ssh.h"
#include "ssh1.h"
#include "ssh2.h"
#include "packet.h"
#include "buffer.h"
#include "compat.h"
#include "channels.h"
#include "dispatch.h"
#include "key.h"
#include "cipher.h"
#include "kex.h"
#include "log.h"
#include "readconf.h"
#include "clientloop.h"
#include "sshconnect.h"
#include "authfd.h"
#include "atomicio.h"
#include "sshpty.h"
#include "misc.h"
#include "match.h"
#include "msg.h"

__RCSID("$MirOS: src/usr.bin/ssh/clientloop.c,v 1.17 2009/10/04 14:29:03 tg Exp $");

/* import options */
extern Options options;

/* Flag indicating that stdin should be redirected from /dev/null. */
extern int stdin_null_flag;

/* Flag indicating that no shell has been requested */
extern int no_shell_flag;

/* Control socket */
extern int muxserver_sock;

/*
 * Name of the host we are connecting to.  This is the name given on the
 * command line, or the Hostname specified for the user-supplied name in a
 * configuration file.
 */
extern char *host;

/*
 * Flag to indicate that we have received a window change signal which has
 * not yet been processed.  This will cause a message indicating the new
 * window size to be sent to the server a little later.  This is volatile
 * because this is updated in a signal handler.
 */
static volatile sig_atomic_t received_window_change_signal = 0;
static volatile sig_atomic_t received_signal = 0;

/* Flag indicating whether the user's terminal is in non-blocking mode. */
static int in_non_blocking_mode = 0;

/* Common data for the client loop code. */
static volatile sig_atomic_t quit_pending; /* Set non-zero to quit the loop. */
static int escape_char1;	/* Escape character. (proto1 only) */
static int escape_pending1;	/* Last character was an escape (proto1 only) */
static int last_was_cr;		/* Last character was a newline. */
static int exit_status;		/* Used to store the command exit status. */
static int stdin_eof;		/* EOF has been encountered on stderr. */
static Buffer stdin_buffer;	/* Buffer for stdin data. */
static Buffer stdout_buffer;	/* Buffer for stdout data. */
static Buffer stderr_buffer;	/* Buffer for stderr data. */
static u_int buffer_high;/* Soft max buffer size. */
static int connection_in;	/* Connection to server (input). */
static int connection_out;	/* Connection to server (output). */
static int need_rekeying;	/* Set to non-zero if rekeying is requested. */
static int session_closed = 0;	/* In SSH2: login session closed. */

static void client_init_dispatch(void);
int	session_ident = -1;

/* Track escape per proto2 channel */
struct escape_filter_ctx {
	int escape_pending;
	int escape_char;
};

/* Context for channel confirmation replies */
struct channel_reply_ctx {
	const char *request_type;
	int id, do_close;
};

/* Global request success/failure callbacks */
struct global_confirm {
	TAILQ_ENTRY(global_confirm) entry;
	global_confirm_cb *cb;
	void *ctx;
	int ref_count;
};
TAILQ_HEAD(global_confirms, global_confirm);
static struct global_confirms global_confirms =
    TAILQ_HEAD_INITIALIZER(global_confirms);

/*XXX*/
extern Kex *xxx_kex;

void ssh_process_session2_setup(int, int, int, Buffer *);

/* Restores stdin to blocking mode. */

static void
leave_non_blocking(void)
{
	if (in_non_blocking_mode) {
		unset_nonblock(fileno(stdin));
		in_non_blocking_mode = 0;
	}
}

/* Puts stdin terminal in non-blocking mode. */

static void
enter_non_blocking(void)
{
	in_non_blocking_mode = 1;
	set_nonblock(fileno(stdin));
}

/*
 * Signal handler for the window change signal (SIGWINCH).  This just sets a
 * flag indicating that the window has changed.
 */
/*ARGSUSED */
static void
window_change_handler(int sig)
{
	received_window_change_signal = 1;
	signal(SIGWINCH, window_change_handler);
}

/*
 * Signal handler for signals that cause the program to terminate.  These
 * signals must be trapped to restore terminal modes.
 */
/*ARGSUSED */
static void
signal_handler(int sig)
{
	received_signal = sig;
	quit_pending = 1;
}

/*
 * Returns current time in seconds from Jan 1, 1970 with the maximum
 * available resolution.
 */

static double
get_current_time(void)
{
	struct timeval tv;
	gettimeofday(&tv, NULL);
	return (double) tv.tv_sec + (double) tv.tv_usec / 1000000.0;
}

#define SSH_X11_PROTO "MIT-MAGIC-COOKIE-1"
void
client_x11_get_proto(const char *display, const char *xauth_path,
    u_int trusted, char **_proto, char **_data)
{
	char cmd[1024];
	char line[512];
	char xdisplay[512];
	static char proto[512], data[512];
	FILE *f;
	int got_data = 0, generated = 0, do_unlink = 0, i;
	char *xauthdir, *xauthfile;
	struct stat st;

	xauthdir = xauthfile = NULL;
	*_proto = proto;
	*_data = data;
	proto[0] = data[0] = '\0';

	if (xauth_path == NULL ||(stat(xauth_path, &st) == -1)) {
		debug("No xauth program.");
	} else {
		if (display == NULL) {
			debug("x11_get_proto: DISPLAY not set");
			return;
		}
		/*
		 * Handle FamilyLocal case where $DISPLAY does
		 * not match an authorisation entry.  For this we
		 * just try "xauth list unix:displaynum.screennum".
		 * XXX: "localhost" match to determine FamilyLocal
		 *      is not perfect.
		 */
		if (strncmp(display, "localhost:", 10) == 0) {
			snprintf(xdisplay, sizeof(xdisplay), "unix:%s",
			    display + 10);
			display = xdisplay;
		}
		if (trusted == 0) {
			xauthdir = xmalloc(MAXPATHLEN);
			xauthfile = xmalloc(MAXPATHLEN);
			strlcpy(xauthdir, "/tmp/ssh-XXXXXXXXXX", MAXPATHLEN);
			if (mkdtemp(xauthdir) != NULL) {
				do_unlink = 1;
				snprintf(xauthfile, MAXPATHLEN, "%s/xauthfile",
				    xauthdir);
				snprintf(cmd, sizeof(cmd),
				    "%s -f %s generate %s " SSH_X11_PROTO
				    " untrusted timeout 1200 2>" _PATH_DEVNULL,
				    xauth_path, xauthfile, display);
				debug2("x11_get_proto: %s", cmd);
				if (system(cmd) == 0)
					generated = 1;
			}
		}

		/*
		 * When in untrusted mode, we read the cookie only if it was
		 * successfully generated as an untrusted one in the step
		 * above.
		 */
		if (trusted || generated) {
			snprintf(cmd, sizeof(cmd),
			    "%s %s%s list %s 2>" _PATH_DEVNULL,
			    xauth_path,
			    generated ? "-f " : "" ,
			    generated ? xauthfile : "",
			    display);
			debug2("x11_get_proto: %s", cmd);
			f = popen(cmd, "r");
			if (f && fgets(line, sizeof(line), f) &&
			    sscanf(line, "%*s %511s %511s", proto, data) == 2)
				got_data = 1;
			if (f)
				pclose(f);
		} else
			error("Warning: untrusted X11 forwarding setup failed: "
			    "xauth key data not generated");
	}

	if (do_unlink) {
		unlink(xauthfile);
		rmdir(xauthdir);
	}
	if (xauthdir)
		xfree(xauthdir);
	if (xauthfile)
		xfree(xauthfile);

	/*
	 * If we didn't get authentication data, just make up some
	 * data.  The forwarding code will check the validity of the
	 * response anyway, and substitute this data.  The X11
	 * server, however, will ignore this fake data and use
	 * whatever authentication mechanisms it was using otherwise
	 * for the local connection.
	 */
	if (!got_data) {
		u_int32_t rnd = 0;

		logit("Warning: No xauth data; "
		    "using fake authentication data for X11 forwarding.");
		strlcpy(proto, SSH_X11_PROTO, sizeof proto);
		for (i = 0; i < 16; i++) {
			if (i % 4 == 0)
				rnd = arc4random();
			snprintf(data + 2 * i, sizeof data - 2 * i, "%02x",
			    rnd & 0xff);
			rnd >>= 8;
		}
	}
}

/*
 * This is called when the interactive is entered.  This checks if there is
 * an EOF coming on stdin.  We must check this explicitly, as select() does
 * not appear to wake up when redirecting from /dev/null.
 */

static void
client_check_initial_eof_on_stdin(void)
{
	int len;
	char buf[1];

	/*
	 * If standard input is to be "redirected from /dev/null", we simply
	 * mark that we have seen an EOF and send an EOF message to the
	 * server. Otherwise, we try to read a single character; it appears
	 * that for some files, such /dev/null, select() never wakes up for
	 * read for this descriptor, which means that we never get EOF.  This
	 * way we will get the EOF if stdin comes from /dev/null or similar.
	 */
	if (stdin_null_flag) {
		/* Fake EOF on stdin. */
		debug("Sending eof.");
		stdin_eof = 1;
		packet_start(SSH_CMSG_EOF);
		packet_send();
	} else {
		enter_non_blocking();

		/* Check for immediate EOF on stdin. */
		len = read(fileno(stdin), buf, 1);
		if (len == 0) {
			/*
			 * EOF.  Record that we have seen it and send
			 * EOF to server.
			 */
			debug("Sending eof.");
			stdin_eof = 1;
			packet_start(SSH_CMSG_EOF);
			packet_send();
		} else if (len > 0) {
			/*
			 * Got data.  We must store the data in the buffer,
			 * and also process it as an escape character if
			 * appropriate.
			 */
			if ((u_char) buf[0] == escape_char1)
				escape_pending1 = 1;
			else
				buffer_append(&stdin_buffer, buf, 1);
		}
		leave_non_blocking();
	}
}


/*
 * Make packets from buffered stdin data, and buffer them for sending to the
 * connection.
 */

static void
client_make_packets_from_stdin_data(void)
{
	u_int len;

	/* Send buffered stdin data to the server. */
	while (buffer_len(&stdin_buffer) > 0 &&
	    packet_not_very_much_data_to_write()) {
		len = buffer_len(&stdin_buffer);
		/* Keep the packets at reasonable size. */
		if (len > packet_get_maxsize())
			len = packet_get_maxsize();
		packet_start(SSH_CMSG_STDIN_DATA);
		packet_put_string(buffer_ptr(&stdin_buffer), len);
		packet_send();
		buffer_consume(&stdin_buffer, len);
		/* If we have a pending EOF, send it now. */
		if (stdin_eof && buffer_len(&stdin_buffer) == 0) {
			packet_start(SSH_CMSG_EOF);
			packet_send();
		}
	}
}

/*
 * Checks if the client window has changed, and sends a packet about it to
 * the server if so.  The actual change is detected elsewhere (by a software
 * interrupt on Unix); this just checks the flag and sends a message if
 * appropriate.
 */

static void
client_check_window_change(void)
{
	struct winsize ws;

	if (! received_window_change_signal)
		return;
	/** XXX race */
	received_window_change_signal = 0;

	debug2("client_check_window_change: changed");

	if (compat20) {
		channel_send_window_changes();
	} else {
		if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) < 0)
			return;
		packet_start(SSH_CMSG_WINDOW_SIZE);
		packet_put_int((u_int)ws.ws_row);
		packet_put_int((u_int)ws.ws_col);
		packet_put_int((u_int)ws.ws_xpixel);
		packet_put_int((u_int)ws.ws_ypixel);
		packet_send();
	}
}

static void
client_global_request_reply(int type, u_int32_t seq, void *ctxt)
{
	struct global_confirm *gc;

	if ((gc = TAILQ_FIRST(&global_confirms)) == NULL)
		return;
	if (gc->cb != NULL)
		gc->cb(type, seq, gc->ctx);
	if (--gc->ref_count <= 0) {
		TAILQ_REMOVE(&global_confirms, gc, entry);
		bzero(gc, sizeof(*gc));
		xfree(gc);
	}

	packet_set_alive_timeouts(0);
}

static void
server_alive_check(void)
{
	if (packet_inc_alive_timeouts() > options.server_alive_count_max) {
		logit("Timeout, server not responding.");
		cleanup_exit(255);
	}
	packet_start(SSH2_MSG_GLOBAL_REQUEST);
	packet_put_cstring("keepalive@@openssh.com");
	packet_put_char(1);     /* boolean: want reply */
	packet_send();
	/* Insert an empty placeholder to maintain ordering */
	client_register_global_confirm(NULL, NULL);
}

/*
 * Waits until the client can do something (some data becomes available on
 * one of the file descriptors).
 */
static void
client_wait_until_can_do_something(fd_set **readsetp, fd_set **writesetp,
    int *maxfdp, u_int *nallocp, int rekeying)
{
	struct timeval tv, *tvp;
	int ret;

	/* Add any selections by the channel mechanism. */
	channel_prepare_select(readsetp, writesetp, maxfdp, nallocp, rekeying);

	if (!compat20) {
		/* Read from the connection, unless our buffers are full. */
		if (buffer_len(&stdout_buffer) < buffer_high &&
		    buffer_len(&stderr_buffer) < buffer_high &&
		    channel_not_very_much_buffered_data())
			FD_SET(connection_in, *readsetp);
		/*
		 * Read from stdin, unless we have seen EOF or have very much
		 * buffered data to send to the server.
		 */
		if (!stdin_eof && packet_not_very_much_data_to_write())
			FD_SET(fileno(stdin), *readsetp);

		/* Select stdout/stderr if have data in buffer. */
		if (buffer_len(&stdout_buffer) > 0)
			FD_SET(fileno(stdout), *writesetp);
		if (buffer_len(&stderr_buffer) > 0)
			FD_SET(fileno(stderr), *writesetp);
	} else {
		/* channel_prepare_select could have closed the last channel */
		if (session_closed && !channel_still_open() &&
		    !packet_have_data_to_write()) {
			/* clear mask since we did not call select() */
			memset(*readsetp, 0, *nallocp);
			memset(*writesetp, 0, *nallocp);
			return;
		} else {
			FD_SET(connection_in, *readsetp);
		}
	}

	/* Select server connection if have data to write to the server. */
	if (packet_have_data_to_write())
		FD_SET(connection_out, *writesetp);

	if (muxserver_sock != -1)
		FD_SET(muxserver_sock, *readsetp);

	/*
	 * Wait for something to happen.  This will suspend the process until
	 * some selected descriptor can be read, written, or has some other
	 * event pending.
	 */

	if (options.server_alive_interval == 0 || !compat20)
		tvp = NULL;
	else {
		tv.tv_sec = options.server_alive_interval;
		tv.tv_usec = 0;
		tvp = &tv;
	}
	ret = select((*maxfdp)+1, *readsetp, *writesetp, NULL, tvp);
	if (ret < 0) {
		char buf[100];

		/*
		 * We have to clear the select masks, because we return.
		 * We have to return, because the mainloop checks for the flags
		 * set by the signal handlers.
		 */
		memset(*readsetp, 0, *nallocp);
		memset(*writesetp, 0, *nallocp);

		if (errno == EINTR)
			return;
		/* Note: we might still have data in the buffers. */
		snprintf(buf, sizeof buf, "select: %s\r\n", strerror(errno));
		buffer_append(&stderr_buffer, buf, strlen(buf));
		quit_pending = 1;
	} else if (ret == 0)
		server_alive_check();
}

static void
client_suspend_self(Buffer *bin, Buffer *bout, Buffer *berr)
{
	/* Flush stdout and stderr buffers. */
	if (buffer_len(bout) > 0)
		atomicio(vwrite, fileno(stdout), buffer_ptr(bout),
		    buffer_len(bout));
	if (buffer_len(berr) > 0)
		atomicio(vwrite, fileno(stderr), buffer_ptr(berr),
		    buffer_len(berr));

	leave_raw_mode();

	/*
	 * Free (and clear) the buffer to reduce the amount of data that gets
	 * written to swap.
	 */
	buffer_free(bin);
	buffer_free(bout);
	buffer_free(berr);

	/* Send the suspend signal to the program itself. */
	kill(getpid(), SIGTSTP);

	/* Reset window sizes in case they have changed */
	received_window_change_signal = 1;

	/* OK, we have been continued by the user. Reinitialize buffers. */
	buffer_init(bin);
	buffer_init(bout);
	buffer_init(berr);

	enter_raw_mode();
}

static void
client_process_net_input(fd_set *readset)
{
	int len;
	char buf[8192];

	/*
	 * Read input from the server, and add any such data to the buffer of
	 * the packet subsystem.
	 */
	if (FD_ISSET(connection_in, readset)) {
		/* Read as much as possible. */
		len = read(connection_in, buf, sizeof(buf));
		if (len == 0) {
			/*
			 * Received EOF.  The remote host has closed the
			 * connection.
			 */
			snprintf(buf, sizeof buf,
			    "Connection to %.300s closed by remote host.\r\n",
			    host);
			buffer_append(&stderr_buffer, buf, strlen(buf));
			quit_pending = 1;
			return;
		}
		/*
		 * There is a kernel bug on Solaris that causes select to
		 * sometimes wake up even though there is no data available.
		 */
		if (len < 0 && (errno == EAGAIN || errno == EINTR))
			len = 0;

		if (len < 0) {
			/*
			 * An error has encountered.  Perhaps there is a
			 * network problem.
			 */
			snprintf(buf, sizeof buf,
			    "Read from remote host %.300s: %.100s\r\n",
			    host, strerror(errno));
			buffer_append(&stderr_buffer, buf, strlen(buf));
			quit_pending = 1;
			return;
		}
		packet_process_incoming(buf, len);
	}
}

static void
client_status_confirm(int type, Channel *c, void *ctx)
{
	struct channel_reply_ctx *cr = (struct channel_reply_ctx *)ctx;
	char errmsg[256];
	int tochan;

	/* XXX supress on mux _client_ quietmode */
	tochan = options.log_level >= SYSLOG_LEVEL_ERROR &&
	    c->ctl_fd != -1 && c->extended_usage == CHAN_EXTENDED_WRITE;

	if (type == SSH2_MSG_CHANNEL_SUCCESS) {
		debug2("%s request accepted on channel %d",
		    cr->request_type, c->self);
	} else if (type == SSH2_MSG_CHANNEL_FAILURE) {
		if (tochan) {
			snprintf(errmsg, sizeof(errmsg),
			    "%s request failed\r\n", cr->request_type);
		} else {
			snprintf(errmsg, sizeof(errmsg),
			    "%s request failed on channel %d",
			    cr->request_type, c->self);
		}
		/* If error occurred on primary session channel, then exit */
		if (cr->do_close && c->self == session_ident)
			fatal("%s", errmsg);
		/* If error occurred on mux client, append to their stderr */
		if (tochan)
			buffer_append(&c->extended, errmsg, strlen(errmsg));
		else
			error("%s", errmsg);
		if (cr->do_close) {
			chan_read_failed(c);
			chan_write_failed(c);
		}
	}
	xfree(cr);
}

static void
client_abandon_status_confirm(Channel *c, void *ctx)
{
	xfree(ctx);
}

static void
client_expect_confirm(int id, const char *request, int do_close)
{
	struct channel_reply_ctx *cr = xmalloc(sizeof(*cr));

	cr->request_type = request;
	cr->do_close = do_close;

	channel_register_status_confirm(id, client_status_confirm,
	    client_abandon_status_confirm, cr);
}

void
client_register_global_confirm(global_confirm_cb *cb, void *ctx)
{
	struct global_confirm *gc, *last_gc;

	/* Coalesce identical callbacks */
	last_gc = TAILQ_LAST(&global_confirms, global_confirms);
	if (last_gc && last_gc->cb == cb && last_gc->ctx == ctx) {
		if (++last_gc->ref_count >= INT_MAX)
			fatal("%s: last_gc->ref_count = %d",
			    __func__, last_gc->ref_count);
		return;
	}

	gc = xmalloc(sizeof(*gc));
	gc->cb = cb;
	gc->ctx = ctx;
	gc->ref_count = 1;
	TAILQ_INSERT_TAIL(&global_confirms, gc, entry);
}

static void
process_cmdline(void)
{
	void (*handler)(int);
	char *s, *cmd, *cancel_host;
	int delete = 0;
	int local = 0, remote = 0, dynamic = 0;
	int cancel_port;
	Forward fwd;

	bzero(&fwd, sizeof(fwd));
	fwd.listen_host = fwd.connect_host = NULL;

	leave_raw_mode();
	handler = signal(SIGINT, SIG_IGN);
	cmd = s = read_passphrase("\r\nssh> ", RP_ECHO);
	if (s == NULL)
		goto out;
	while (isspace(*s))
		s++;
	if (*s == '-')
		s++;	/* Skip cmdline '-', if any */
	if (*s == '\0')
		goto out;

	if (*s == 'h' || *s == 'H' || *s == '?') {
		logit("Commands:");
		logit("      -L[bind_address:]port:host:hostport    "
		    "Request local forward");
		logit("      -R[bind_address:]port:host:hostport    "
		    "Request remote forward");
		logit("      -D[bind_address:]port                  "
		    "Request dynamic forward");
		logit("      -KR[bind_address:]port                 "
		    "Cancel remote forward");
		if (!options.permit_local_command)
			goto out;
		logit("      !args                                  "
		    "Execute local command");
		goto out;
	}

	if (*s == '!' && options.permit_local_command) {
		s++;
		ssh_local_cmd(s);
		goto out;
	}

	if (*s == 'K') {
		delete = 1;
		s++;
	}
	if (*s == 'L')
		local = 1;
	else if (*s == 'R')
		remote = 1;
	else if (*s == 'D')
		dynamic = 1;
	else {
		logit("Invalid command.");
		goto out;
	}

	if ((local || dynamic) && delete) {
		logit("Not supported.");
		goto out;
	}
	if (remote && delete && !compat20) {
		logit("Not supported for SSH protocol version 1.");
		goto out;
	}

	while (isspace(*++s))
		;

	if (delete) {
		cancel_port = 0;
		cancel_host = hpdelim(&s);	/* may be NULL */
		if (s != NULL) {
			cancel_port = a2port(s);
			cancel_host = cleanhostname(cancel_host);
		} else {
			cancel_port = a2port(cancel_host);
			cancel_host = NULL;
		}
		if (cancel_port <= 0) {
			logit("Bad forwarding close port");
			goto out;
		}
		channel_request_rforward_cancel(cancel_host, cancel_port);
	} else {
		if (!parse_forward(&fwd, s, dynamic, remote)) {
			logit("Bad forwarding specification.");
			goto out;
		}
		if (local || dynamic) {
			if (channel_setup_local_fwd_listener(fwd.listen_host,
			    fwd.listen_port, fwd.connect_host,
			    fwd.connect_port, options.gateway_ports) < 0) {
				logit("Port forwarding failed.");
				goto out;
			}
		} else {
			if (channel_request_remote_forwarding(fwd.listen_host,
			    fwd.listen_port, fwd.connect_host,
			    fwd.connect_port) < 0) {
				logit("Port forwarding failed.");
				goto out;
			}
		}

		logit("Forwarding port.");
	}

out:
	signal(SIGINT, handler);
	enter_raw_mode();
	if (cmd)
		xfree(cmd);
	if (fwd.listen_host != NULL)
		xfree(fwd.listen_host);
	if (fwd.connect_host != NULL)
		xfree(fwd.connect_host);
}

/* 
 * Process the characters one by one, call with c==NULL for proto1 case.
 */
static int
process_escapes(Channel *c, Buffer *bin, Buffer *bout, Buffer *berr,
    char *buf, int len)
{
	char string[1024];
	pid_t pid;
	int bytes = 0;
	u_int i;
	u_char ch;
	char *s;
	int *escape_pendingp, escape_char;
	struct escape_filter_ctx *efc;

	if (c == NULL) {
		escape_pendingp = &escape_pending1;
		escape_char = escape_char1;
	} else {
		if (c->filter_ctx == NULL)
			return 0;
		efc = (struct escape_filter_ctx *)c->filter_ctx;
		escape_pendingp = &efc->escape_pending;
		escape_char = efc->escape_char;
	}
	
	if (len <= 0)
		return (0);

	for (i = 0; i < (u_int)len; i++) {
		/* Get one character at a time. */
		ch = buf[i];

		if (*escape_pendingp) {
			/* We have previously seen an escape character. */
			/* Clear the flag now. */
			*escape_pendingp = 0;

			/* Process the escaped character. */
			switch (ch) {
			case '.':
				/* Terminate the connection. */
				snprintf(string, sizeof string, "%c.\r\n",
				    escape_char);
				buffer_append(berr, string, strlen(string));

				if (c && c->ctl_fd != -1) {
					chan_read_failed(c);
					chan_write_failed(c);
					return 0;
				} else
					quit_pending = 1;
				return -1;

			case 'Z' - 64:
				/* XXX support this for mux clients */
				if (c && c->ctl_fd != -1) {
 noescape:
					snprintf(string, sizeof string,
					    "%c%c escape not available to "
					    "multiplexed sessions\r\n",
					    escape_char, ch);
					buffer_append(berr, string,
					    strlen(string));
					continue;
				}
				/* Suspend the program. Inform the user */
				snprintf(string, sizeof string,
				    "%c^Z [suspend ssh]\r\n", escape_char);
				buffer_append(berr, string, strlen(string));

				/* Restore terminal modes and suspend. */
				client_suspend_self(bin, bout, berr);

				/* We have been continued. */
				continue;

			case 'B':
				if (compat20) {
					snprintf(string, sizeof string,
					    "%cB\r\n", escape_char);
					buffer_append(berr, string,
					    strlen(string));
					channel_request_start(session_ident,
					    "break", 0);
					packet_put_int(1000);
					packet_send();
				}
				continue;

			case 'R':
				if (compat20) {
					if (datafellows & SSH_BUG_NOREKEY)
						logit("Server does not "
						    "support re-keying");
					else
						need_rekeying = 1;
				}
				continue;

			case '&':
				if (c && c->ctl_fd != -1)
					goto noescape;
				/*
				 * Detach the program (continue to serve
				 * connections, but put in background and no
				 * more new connections).
				 */
				/* Restore tty modes. */
				leave_raw_mode();

				/* Stop listening for new connections. */
				channel_stop_listening();

				snprintf(string, sizeof string,
				    "%c& [backgrounded]\n", escape_char);
				buffer_append(berr, string, strlen(string));

				/* Fork into background. */
				pid = fork();
				if (pid < 0) {
					error("fork: %.100s", strerror(errno));
					continue;
				}
				if (pid != 0) {	/* This is the parent. */
					/* The parent just exits. */
					exit(0);
				}
				/* The child continues serving connections. */
				if (compat20) {
					buffer_append(bin, "\004", 1);
					/* fake EOF on stdin */
					return -1;
				} else if (!stdin_eof) {
					/*
					 * Sending SSH_CMSG_EOF alone does not
					 * always appear to be enough.  So we
					 * try to send an EOF character first.
					 */
					packet_start(SSH_CMSG_STDIN_DATA);
					packet_put_string("\004", 1);
					packet_send();
					/* Close stdin. */
					stdin_eof = 1;
					if (buffer_len(bin) == 0) {
						packet_start(SSH_CMSG_EOF);
						packet_send();
					}
				}
				continue;

			case '?':
				if (c && c->ctl_fd != -1) {
					snprintf(string, sizeof string,
"%c?\r\n\
Supported escape sequences:\r\n\
  %c.  - terminate session\r\n\
  %cB  - send a BREAK to the remote system\r\n\
  %cR  - Request rekey (SSH protocol 2 only)\r\n\
  %c#  - list forwarded connections\r\n\
  %c?  - this message\r\n\
  %c%c  - send the escape character by typing it twice\r\n\
(Note that escapes are only recognized immediately after newline.)\r\n",
					    escape_char, escape_char,
					    escape_char, escape_char,
					    escape_char, escape_char,
					    escape_char, escape_char);
				} else {
					snprintf(string, sizeof string,
"%c?\r\n\
Supported escape sequences:\r\n\
  %c.  - terminate connection (and any multiplexed sessions)\r\n\
  %cB  - send a BREAK to the remote system\r\n\
  %cC  - open a command line\r\n\
  %cR  - Request rekey (SSH protocol 2 only)\r\n\
  %c^Z - suspend ssh\r\n\
  %c#  - list forwarded connections\r\n\
  %c&  - background ssh (when waiting for connections to terminate)\r\n\
  %c?  - this message\r\n\
  %c%c  - send the escape character by typing it twice\r\n\
(Note that escapes are only recognized immediately after newline.)\r\n",
					    escape_char, escape_char,
					    escape_char, escape_char,
					    escape_char, escape_char,
					    escape_char, escape_char,
					    escape_char, escape_char,
					    escape_char);
				}
				buffer_append(berr, string, strlen(string));
				continue;

			case '#':
				snprintf(string, sizeof string, "%c#\r\n",
				    escape_char);
				buffer_append(berr, string, strlen(string));
				s = channel_open_message();
				buffer_append(berr, s, strlen(s));
				xfree(s);
				continue;

			case 'C':
				if (c && c->ctl_fd != -1)
					goto noescape;
				process_cmdline();
				continue;

			default:
				if (ch != escape_char) {
					buffer_put_char(bin, escape_char);
					bytes++;
				}
				/* Escaped characters fall through here */
				break;
			}
		} else {
			/*
			 * The previous character was not an escape char.
			 * Check if this is an escape.
			 */
			if (last_was_cr && ch == escape_char) {
				/*
				 * It is. Set the flag and continue to
				 * next character.
				 */
				*escape_pendingp = 1;
				continue;
			}
		}

		/*
		 * Normal character.  Record whether it was a newline,
		 * and append it to the buffer.
		 */
		last_was_cr = (ch == '\r' || ch == '\n');
		buffer_put_char(bin, ch);
		bytes++;
	}
	return bytes;
}

static void
client_process_input(fd_set *readset)
{
	int len;
	char buf[8192];

	/* Read input from stdin. */
	if (FD_ISSET(fileno(stdin), readset)) {
		/* Read as much as possible. */
		len = read(fileno(stdin), buf, sizeof(buf));
		if (len < 0 && (errno == EAGAIN || errno == EINTR))
			return;		/* we'll try again later */
		if (len <= 0) {
			/*
			 * Received EOF or error.  They are treated
			 * similarly, except that an error message is printed
			 * if it was an error condition.
			 */
			if (len < 0) {
				snprintf(buf, sizeof buf, "read: %.100s\r\n",
				    strerror(errno));
				buffer_append(&stderr_buffer, buf, strlen(buf));
			}
			/* Mark that we have seen EOF. */
			stdin_eof = 1;
			/*
			 * Send an EOF message to the server unless there is
			 * data in the buffer.  If there is data in the
			 * buffer, no message will be sent now.  Code
			 * elsewhere will send the EOF when the buffer
			 * becomes empty if stdin_eof is set.
			 */
			if (buffer_len(&stdin_buffer) == 0) {
				packet_start(SSH_CMSG_EOF);
				packet_send();
			}
		} else if (escape_char1 == SSH_ESCAPECHAR_NONE) {
			/*
			 * Normal successful read, and no escape character.
			 * Just append the data to buffer.
			 */
			buffer_append(&stdin_buffer, buf, len);
		} else {
			/*
			 * Normal, successful read.  But we have an escape
			 * character and have to process the characters one
			 * by one.
			 */
			if (process_escapes(NULL, &stdin_buffer,
			    &stdout_buffer, &stderr_buffer, buf, len) == -1)
				return;
		}
	}
}

static void
client_process_output(fd_set *writeset)
{
	int len;
	char buf[100];

	/* Write buffered output to stdout. */
	if (FD_ISSET(fileno(stdout), writeset)) {
		/* Write as much data as possible. */
		len = write(fileno(stdout), buffer_ptr(&stdout_buffer),
		    buffer_len(&stdout_buffer));
		if (len <= 0) {
			if (errno == EINTR || errno == EAGAIN)
				len = 0;
			else {
				/*
				 * An error or EOF was encountered.  Put an
				 * error message to stderr buffer.
				 */
				snprintf(buf, sizeof buf,
				    "write stdout: %.50s\r\n", strerror(errno));
				buffer_append(&stderr_buffer, buf, strlen(buf));
				quit_pending = 1;
				return;
			}
		}
		/* Consume printed data from the buffer. */
		buffer_consume(&stdout_buffer, len);
	}
	/* Write buffered output to stderr. */
	if (FD_ISSET(fileno(stderr), writeset)) {
		/* Write as much data as possible. */
		len = write(fileno(stderr), buffer_ptr(&stderr_buffer),
		    buffer_len(&stderr_buffer));
		if (len <= 0) {
			if (errno == EINTR || errno == EAGAIN)
				len = 0;
			else {
				/*
				 * EOF or error, but can't even print
				 * error message.
				 */
				quit_pending = 1;
				return;
			}
		}
		/* Consume printed characters from the buffer. */
		buffer_consume(&stderr_buffer, len);
	}
}

/*
 * Get packets from the connection input buffer, and process them as long as
 * there are packets available.
 *
 * Any unknown packets received during the actual
 * session cause the session to terminate.  This is
 * intended to make debugging easier since no
 * confirmations are sent.  Any compatible protocol
 * extensions must be negotiated during the
 * preparatory phase.
 */

static void
client_process_buffered_input_packets(void)
{
	dispatch_run(DISPATCH_NONBLOCK, &quit_pending,
	    compat20 ? xxx_kex : NULL);
}

/* scan buf[] for '~' before sending data to the peer */

/* Helper: allocate a new escape_filter_ctx and fill in its escape char */
void *
client_new_escape_filter_ctx(int escape_char)
{
	struct escape_filter_ctx *ret;

	ret = xmalloc(sizeof(*ret));
	ret->escape_pending = 0;
	ret->escape_char = escape_char;
	return (void *)ret;
}

/* Free the escape filter context on channel free */
void
client_filter_cleanup(int cid, void *ctx)
{
	xfree(ctx);
}

int
client_simple_escape_filter(Channel *c, char *buf, int len)
{
	if (c->extended_usage != CHAN_EXTENDED_WRITE)
		return 0;

	return process_escapes(c, &c->input, &c->output, &c->extended,
	    buf, len);
}

static void
client_channel_closed(int id, void *arg)
{
	channel_cancel_cleanup(id);
	session_closed = 1;
	leave_raw_mode();
}

/*
 * Implements the interactive session with the server.  This is called after
 * the user has been authenticated, and a command has been started on the
 * remote host.  If escape_char != SSH_ESCAPECHAR_NONE, it is the character
 * used as an escape character for terminating or suspending the session.
 */

int
client_loop(int have_pty, int escape_char_arg, int ssh2_chan_id)
{
	fd_set *readset = NULL, *writeset = NULL;
	double start_time, total_time;
	int max_fd = 0, max_fd2 = 0, len, rekeying = 0;
	u_int64_t ibytes, obytes;
	u_int nalloc = 0;
	char buf[100];

	debug("Entering interactive session.");

	start_time = get_current_time();

	/* Initialize variables. */
	escape_pending1 = 0;
	last_was_cr = 1;
	exit_status = -1;
	stdin_eof = 0;
	buffer_high = 64 * 1024;
	connection_in = packet_get_connection_in();
	connection_out = packet_get_connection_out();
	max_fd = MAX(connection_in, connection_out);
	if (muxserver_sock != -1)
		max_fd = MAX(max_fd, muxserver_sock);

	if (!compat20) {
		/* enable nonblocking unless tty */
		if (!isatty(fileno(stdin)))
			set_nonblock(fileno(stdin));
		if (!isatty(fileno(stdout)))
			set_nonblock(fileno(stdout));
		if (!isatty(fileno(stderr)))
			set_nonblock(fileno(stderr));
		max_fd = MAX(max_fd, fileno(stdin));
		max_fd = MAX(max_fd, fileno(stdout));
		max_fd = MAX(max_fd, fileno(stderr));
	}
	quit_pending = 0;
	escape_char1 = escape_char_arg;

	/* Initialize buffers. */
	buffer_init(&stdin_buffer);
	buffer_init(&stdout_buffer);
	buffer_init(&stderr_buffer);

	client_init_dispatch();

	/*
	 * Set signal handlers, (e.g. to restore non-blocking mode)
	 * but don't overwrite SIG_IGN, matches behaviour from rsh(1)
	 */
	if (signal(SIGHUP, SIG_IGN) != SIG_IGN)
		signal(SIGHUP, signal_handler);
	if (signal(SIGINT, SIG_IGN) != SIG_IGN)
		signal(SIGINT, signal_handler);
	if (signal(SIGQUIT, SIG_IGN) != SIG_IGN)
		signal(SIGQUIT, signal_handler);
	if (signal(SIGTERM, SIG_IGN) != SIG_IGN)
		signal(SIGTERM, signal_handler);
	signal(SIGWINCH, window_change_handler);

	if (have_pty)
		enter_raw_mode();

	if (compat20) {
		session_ident = ssh2_chan_id;
		if (escape_char_arg != SSH_ESCAPECHAR_NONE)
			channel_register_filter(session_ident,
			    client_simple_escape_filter, NULL,
			    client_filter_cleanup,
			    client_new_escape_filter_ctx(escape_char_arg));
		if (session_ident != -1)
			channel_register_cleanup(session_ident,
			    client_channel_closed, 0);
	} else {
		/* Check if we should immediately send eof on stdin. */
		client_check_initial_eof_on_stdin();
	}

	/* Main loop of the client for the interactive session mode. */
	while (!quit_pending) {

		/* Process buffered packets sent by the server. */
		client_process_buffered_input_packets();

		if (compat20 && session_closed && !channel_still_open())
			break;

		rekeying = (xxx_kex != NULL && !xxx_kex->done);

		if (rekeying) {
			debug("rekeying in progress");
		} else {
			/*
			 * Make packets of buffered stdin data, and buffer
			 * them for sending to the server.
			 */
			if (!compat20)
				client_make_packets_from_stdin_data();

			/*
			 * Make packets from buffered channel data, and
			 * enqueue them for sending to the server.
			 */
			if (packet_not_very_much_data_to_write())
				channel_output_poll();

			/*
			 * Check if the window size has changed, and buffer a
			 * message about it to the server if so.
			 */
			client_check_window_change();

			if (quit_pending)
				break;
		}
		/*
		 * Wait until we have something to do (something becomes
		 * available on one of the descriptors).
		 */
		max_fd2 = max_fd;
		client_wait_until_can_do_something(&readset, &writeset,
		    &max_fd2, &nalloc, rekeying);

		if (quit_pending)
			break;

		/* Do channel operations unless rekeying in progress. */
		if (!rekeying) {
			channel_after_select(readset, writeset);
			if (need_rekeying || packet_need_rekeying()) {
				debug("need rekeying");
				xxx_kex->done = 0;
				kex_send_kexinit(xxx_kex);
				need_rekeying = 0;
			}
		}

		/* Buffer input from the connection.  */
		client_process_net_input(readset);

		/* Accept control connections.  */
		if (muxserver_sock != -1 &&FD_ISSET(muxserver_sock, readset)) {
			if (muxserver_accept_control())
				quit_pending = 1;
		}

		if (quit_pending)
			break;

		if (!compat20) {
			/* Buffer data from stdin */
			client_process_input(readset);
			/*
			 * Process output to stdout and stderr.  Output to
			 * the connection is processed elsewhere (above).
			 */
			client_process_output(writeset);
		}

		/*
		 * Send as much buffered packet data as possible to the
		 * sender.
		 */
		if (FD_ISSET(connection_out, writeset))
			packet_write_poll();
	}
	if (readset)
		xfree(readset);
	if (writeset)
		xfree(writeset);

	/* Terminate the session. */

	/* Stop watching for window change. */
	signal(SIGWINCH, SIG_DFL);

	if (compat20) {
		packet_start(SSH2_MSG_DISCONNECT);
		packet_put_int(SSH2_DISCONNECT_BY_APPLICATION);
		packet_put_cstring("disconnected by user");
		packet_send();
		packet_write_wait();
	}

	channel_free_all();

	if (have_pty)
		leave_raw_mode();

	/* restore blocking io */
	if (!isatty(fileno(stdin)))
		unset_nonblock(fileno(stdin));
	if (!isatty(fileno(stdout)))
		unset_nonblock(fileno(stdout));
	if (!isatty(fileno(stderr)))
		unset_nonblock(fileno(stderr));

	/*
	 * If there was no shell or command requested, there will be no remote
	 * exit status to be returned.  In that case, clear error code if the
	 * connection was deliberately terminated at this end.
	 */
	if (no_shell_flag && received_signal == SIGTERM) {
		received_signal = 0;
		exit_status = 0;
	}

	if (received_signal)
		fatal("Killed by signal %d.", (int) received_signal);

	/*
	 * In interactive mode (with pseudo tty) display a message indicating
	 * that the connection has been closed.
	 */
	if (have_pty && options.log_level != SYSLOG_LEVEL_QUIET) {
		snprintf(buf, sizeof buf,
		    "Connection to %.64s closed.\r\n", host);
		buffer_append(&stderr_buffer, buf, strlen(buf));
	}

	/* Output any buffered data for stdout. */
	while (buffer_len(&stdout_buffer) > 0) {
		len = write(fileno(stdout), buffer_ptr(&stdout_buffer),
		    buffer_len(&stdout_buffer));
		if (len <= 0) {
			error("Write failed flushing stdout buffer.");
			break;
		}
		buffer_consume(&stdout_buffer, len);
	}

	/* Output any buffered data for stderr. */
	while (buffer_len(&stderr_buffer) > 0) {
		len = write(fileno(stderr), buffer_ptr(&stderr_buffer),
		    buffer_len(&stderr_buffer));
		if (len <= 0) {
			error("Write failed flushing stderr buffer.");
			break;
		}
		buffer_consume(&stderr_buffer, len);
	}

	/* Clear and free any buffers. */
	memset(buf, 0, sizeof(buf));
	buffer_free(&stdin_buffer);
	buffer_free(&stdout_buffer);
	buffer_free(&stderr_buffer);

	/* Report bytes transferred, and transfer rates. */
	total_time = get_current_time() - start_time;
	packet_get_state(MODE_IN, NULL, NULL, NULL, &ibytes);
	packet_get_state(MODE_OUT, NULL, NULL, NULL, &obytes);
	verbose("Transferred: sent %llu, received %llu bytes, in %.1f seconds",
	    obytes, ibytes, total_time);
	if (total_time > 0)
		verbose("Bytes per second: sent %.1f, received %.1f",
		    obytes / total_time, ibytes / total_time);
	/* Return the exit status of the program. */
	debug("Exit status %d", exit_status);
	return exit_status;
}

/*********/

static void
client_input_stdout_data(int type, u_int32_t seq, void *ctxt)
{
	u_int data_len;
	char *data = packet_get_string(&data_len);
	packet_check_eom();
	buffer_append(&stdout_buffer, data, data_len);
	memset(data, 0, data_len);
	xfree(data);
}
static void
client_input_stderr_data(int type, u_int32_t seq, void *ctxt)
{
	u_int data_len;
	char *data = packet_get_string(&data_len);
	packet_check_eom();
	buffer_append(&stderr_buffer, data, data_len);
	memset(data, 0, data_len);
	xfree(data);
}
static void
client_input_exit_status(int type, u_int32_t seq, void *ctxt)
{
	exit_status = packet_get_int();
	packet_check_eom();
	/* Acknowledge the exit. */
	packet_start(SSH_CMSG_EXIT_CONFIRMATION);
	packet_send();
	/*
	 * Must wait for packet to be sent since we are
	 * exiting the loop.
	 */
	packet_write_wait();
	/* Flag that we want to exit. */
	quit_pending = 1;
}
static void
client_input_agent_open(int type, u_int32_t seq, void *ctxt)
{
	Channel *c = NULL;
	int remote_id, sock;

	/* Read the remote channel number from the message. */
	remote_id = packet_get_int();
	packet_check_eom();

	/*
	 * Get a connection to the local authentication agent (this may again
	 * get forwarded).
	 */
	sock = ssh_get_authentication_socket();

	/*
	 * If we could not connect the agent, send an error message back to
	 * the server. This should never happen unless the agent dies,
	 * because authentication forwarding is only enabled if we have an
	 * agent.
	 */
	if (sock >= 0) {
		c = channel_new("", SSH_CHANNEL_OPEN, sock, sock,
		    -1, 0, 0, 0, "authentication agent connection", 1);
		c->remote_id = remote_id;
		c->force_drain = 1;
	}
	if (c == NULL) {
		packet_start(SSH_MSG_CHANNEL_OPEN_FAILURE);
		packet_put_int(remote_id);
	} else {
		/* Send a confirmation to the remote host. */
		debug("Forwarding authentication connection.");
		packet_start(SSH_MSG_CHANNEL_OPEN_CONFIRMATION);
		packet_put_int(remote_id);
		packet_put_int(c->self);
	}
	packet_send();
}

static Channel *
client_request_forwarded_tcpip(const char *request_type, int rchan)
{
	Channel *c = NULL;
	char *listen_address, *originator_address;
	u_short listen_port, originator_port;

	/* Get rest of the packet */
	listen_address = packet_get_string(NULL);
	listen_port = packet_get_int();
	originator_address = packet_get_string(NULL);
	originator_port = packet_get_int();
	packet_check_eom();

	debug("client_request_forwarded_tcpip: listen %s port %d, "
	    "originator %s port %d", listen_address, listen_port,
	    originator_address, originator_port);

	c = channel_connect_by_listen_address(listen_port,
	    "forwarded-tcpip", originator_address);

	xfree(originator_address);
	xfree(listen_address);
	return c;
}

static Channel *
client_request_x11(const char *request_type, int rchan)
{
	Channel *c = NULL;
	char *originator;
	u_short originator_port;
	int sock;

	if (!options.forward_x11) {
		error("Warning: ssh server tried X11 forwarding.");
		error("Warning: this is probably a break-in attempt by a "
		    "malicious server.");
		return NULL;
	}
	originator = packet_get_string(NULL);
	if (datafellows & SSH_BUG_X11FWD) {
		debug2("buggy server: x11 request w/o originator_port");
		originator_port = 0;
	} else {
		originator_port = packet_get_int();
	}
	packet_check_eom();
	/* XXX check permission */
	debug("client_request_x11: request from %s %d", originator,
	    originator_port);
	xfree(originator);
	sock = x11_connect_display();
	if (sock < 0)
		return NULL;
	c = channel_new("x11",
	    SSH_CHANNEL_X11_OPEN, sock, sock, -1,
	    CHAN_TCP_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT, 0, "x11", 1);
	c->force_drain = 1;
	return c;
}

static Channel *
client_request_agent(const char *request_type, int rchan)
{
	Channel *c = NULL;
	int sock;

	if (!options.forward_agent) {
		error("Warning: ssh server tried agent forwarding.");
		error("Warning: this is probably a break-in attempt by a "
		    "malicious server.");
		return NULL;
	}
	sock = ssh_get_authentication_socket();
	if (sock < 0)
		return NULL;
	c = channel_new("authentication agent connection",
	    SSH_CHANNEL_OPEN, sock, sock, -1,
	    CHAN_X11_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0,
	    "authentication agent connection", 1);
	c->force_drain = 1;
	return c;
}

int
client_request_tun_fwd(int tun_mode, int local_tun, int remote_tun)
{
	Channel *c;
	int fd;

	if (tun_mode == SSH_TUNMODE_NO)
		return 0;

	if (!compat20) {
		error("Tunnel forwarding is not supported for protocol 1");
		return -1;
	}

	debug("Requesting tun unit %d in mode %d", local_tun, tun_mode);

	/* Open local tunnel device */
	if ((fd = tun_open(local_tun, tun_mode)) == -1) {
		error("Tunnel device open failed.");
		return -1;
	}

	c = channel_new("tun", SSH_CHANNEL_OPENING, fd, fd, -1,
	    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, "tun", 1);
	c->datagram = 1;

	packet_start(SSH2_MSG_CHANNEL_OPEN);
	packet_put_cstring("tun@@openssh.com");
	packet_put_int(c->self);
	packet_put_int(c->local_window_max);
	packet_put_int(c->local_maxpacket);
	packet_put_int(tun_mode);
	packet_put_int(remote_tun);
	packet_send();

	return 0;
}

/* XXXX move to generic input handler */
static void
client_input_channel_open(int type, u_int32_t seq, void *ctxt)
{
	Channel *c = NULL;
	char *ctype;
	int rchan;
	u_int rmaxpack, rwindow, len;

	ctype = packet_get_string(&len);
	rchan = packet_get_int();
	rwindow = packet_get_int();
	rmaxpack = packet_get_int();

	debug("client_input_channel_open: ctype %s rchan %d win %d max %d",
	    ctype, rchan, rwindow, rmaxpack);

	if (strcmp(ctype, "forwarded-tcpip") == 0) {
		c = client_request_forwarded_tcpip(ctype, rchan);
	} else if (strcmp(ctype, "x11") == 0) {
		c = client_request_x11(ctype, rchan);
	} else if (strcmp(ctype, "auth-agent@@openssh.com") == 0) {
		c = client_request_agent(ctype, rchan);
	}
/* XXX duplicate : */
	if (c != NULL) {
		debug("confirm %s", ctype);
		c->remote_id = rchan;
		c->remote_window = rwindow;
		c->remote_maxpacket = rmaxpack;
		if (c->type != SSH_CHANNEL_CONNECTING) {
			packet_start(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION);
			packet_put_int(c->remote_id);
			packet_put_int(c->self);
			packet_put_int(c->local_window);
			packet_put_int(c->local_maxpacket);
			packet_send();
		}
	} else {
		debug("failure %s", ctype);
		packet_start(SSH2_MSG_CHANNEL_OPEN_FAILURE);
		packet_put_int(rchan);
		packet_put_int(SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED);
		if (!(datafellows & SSH_BUG_OPENFAILURE)) {
			packet_put_cstring("open failed");
			packet_put_cstring("");
		}
		packet_send();
	}
	xfree(ctype);
}
static void
client_input_channel_req(int type, u_int32_t seq, void *ctxt)
{
	Channel *c = NULL;
	int exitval, id, reply, success = 0;
	char *rtype;

	id = packet_get_int();
	rtype = packet_get_string(NULL);
	reply = packet_get_char();

	debug("client_input_channel_req: channel %d rtype %s reply %d",
	    id, rtype, reply);

	if (id == -1) {
		error("client_input_channel_req: request for channel -1");
	} else if ((c = channel_lookup(id)) == NULL) {
		error("client_input_channel_req: channel %d: "
		    "unknown channel", id);
	} else if (strcmp(rtype, "eow@@openssh.com") == 0) {
		packet_check_eom();
		chan_rcvd_eow(c);
	} else if (strcmp(rtype, "exit-status") == 0) {
		exitval = packet_get_int();
		if (id == session_ident) {
			success = 1;
			exit_status = exitval;
		} else if (c->ctl_fd == -1) {
			error("client_input_channel_req: unexpected channel %d",
			    session_ident);
		} else {
			atomicio(vwrite, c->ctl_fd, &exitval, sizeof(exitval));
			success = 1;
		}
		packet_check_eom();
	}
	if (reply) {
		packet_start(success ?
		    SSH2_MSG_CHANNEL_SUCCESS : SSH2_MSG_CHANNEL_FAILURE);
		packet_put_int(c->remote_id);
		packet_send();
	}
	xfree(rtype);
}
static void
client_input_global_request(int type, u_int32_t seq, void *ctxt)
{
	char *rtype;
	int want_reply;
	int success = 0;

	rtype = packet_get_string(NULL);
	want_reply = packet_get_char();
	debug("client_input_global_request: rtype %s want_reply %d",
	    rtype, want_reply);
	if (want_reply) {
		packet_start(success ?
		    SSH2_MSG_REQUEST_SUCCESS : SSH2_MSG_REQUEST_FAILURE);
		packet_send();
		packet_write_wait();
	}
	xfree(rtype);
}

void
client_session2_setup(int id, int want_tty, int want_subsystem,
    const char *term, struct termios *tiop, int in_fd, Buffer *cmd, char **env)
{
	int len;
	Channel *c = NULL;

	debug2("%s: id %d", __func__, id);

	if ((c = channel_lookup(id)) == NULL)
		fatal("client_session2_setup: channel %d: unknown channel", id);

	if (want_tty) {
		struct winsize ws;

		/* Store window size in the packet. */
		if (ioctl(in_fd, TIOCGWINSZ, &ws) < 0)
			memset(&ws, 0, sizeof(ws));

		channel_request_start(id, "pty-req", 1);
		client_expect_confirm(id, "PTY allocation", 0);
		packet_put_cstring(term != NULL ? term : "");
		packet_put_int((u_int)ws.ws_col);
		packet_put_int((u_int)ws.ws_row);
		packet_put_int((u_int)ws.ws_xpixel);
		packet_put_int((u_int)ws.ws_ypixel);
		if (tiop == NULL)
			tiop = get_saved_tio();
		tty_make_modes(-1, tiop);
		packet_send();
		/* XXX wait for reply */
		c->client_tty = 1;
	}

	/* Transfer any environment variables from client to server */
	if (options.num_send_env != 0 && env != NULL) {
		int i, j, matched;
		char *name, *val;

		debug("Sending environment.");
		for (i = 0; env[i] != NULL; i++) {
			/* Split */
			name = xstrdup(env[i]);
			if ((val = strchr(name, '=')) == NULL) {
				xfree(name);
				continue;
			}
			*val++ = '\0';

			matched = 0;
			for (j = 0; j < options.num_send_env; j++) {
				if (match_pattern(name, options.send_env[j])) {
					matched = 1;
					break;
				}
			}
			if (!matched) {
				debug3("Ignored env %s", name);
				xfree(name);
				continue;
			}

			debug("Sending env %s = %s", name, val);
			channel_request_start(id, "env", 0);
			packet_put_cstring(name);
			packet_put_cstring(val);
			packet_send();
			xfree(name);
		}
	}

	len = buffer_len(cmd);
	if (len > 0) {
		if (len > 900)
			len = 900;
		if (want_subsystem) {
			debug("Sending subsystem: %.*s",
			    len, (u_char*)buffer_ptr(cmd));
			channel_request_start(id, "subsystem", 1);
			client_expect_confirm(id, "subsystem", 1);
		} else {
			debug("Sending command: %.*s",
			    len, (u_char*)buffer_ptr(cmd));
			channel_request_start(id, "exec", 1);
			client_expect_confirm(id, "exec", 1);
		}
		packet_put_string(buffer_ptr(cmd), buffer_len(cmd));
		packet_send();
	} else {
		channel_request_start(id, "shell", 1);
		client_expect_confirm(id, "shell", 1);
		packet_send();
	}
}

static void
client_init_dispatch_20(void)
{
	dispatch_init(&dispatch_protocol_error);

	dispatch_set(SSH2_MSG_CHANNEL_CLOSE, &channel_input_oclose);
	dispatch_set(SSH2_MSG_CHANNEL_DATA, &channel_input_data);
	dispatch_set(SSH2_MSG_CHANNEL_EOF, &channel_input_ieof);
	dispatch_set(SSH2_MSG_CHANNEL_EXTENDED_DATA, &channel_input_extended_data);
	dispatch_set(SSH2_MSG_CHANNEL_OPEN, &client_input_channel_open);
	dispatch_set(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION, &channel_input_open_confirmation);
	dispatch_set(SSH2_MSG_CHANNEL_OPEN_FAILURE, &channel_input_open_failure);
	dispatch_set(SSH2_MSG_CHANNEL_REQUEST, &client_input_channel_req);
	dispatch_set(SSH2_MSG_CHANNEL_WINDOW_ADJUST, &channel_input_window_adjust);
	dispatch_set(SSH2_MSG_CHANNEL_SUCCESS, &channel_input_status_confirm);
	dispatch_set(SSH2_MSG_CHANNEL_FAILURE, &channel_input_status_confirm);
	dispatch_set(SSH2_MSG_GLOBAL_REQUEST, &client_input_global_request);

	/* rekeying */
	dispatch_set(SSH2_MSG_KEXINIT, &kex_input_kexinit);

	/* global request reply messages */
	dispatch_set(SSH2_MSG_REQUEST_FAILURE, &client_global_request_reply);
	dispatch_set(SSH2_MSG_REQUEST_SUCCESS, &client_global_request_reply);
}

static void
client_init_dispatch_13(void)
{
	dispatch_init(NULL);
	dispatch_set(SSH_MSG_CHANNEL_CLOSE, &channel_input_close);
	dispatch_set(SSH_MSG_CHANNEL_CLOSE_CONFIRMATION, &channel_input_close_confirmation);
	dispatch_set(SSH_MSG_CHANNEL_DATA, &channel_input_data);
	dispatch_set(SSH_MSG_CHANNEL_OPEN_CONFIRMATION, &channel_input_open_confirmation);
	dispatch_set(SSH_MSG_CHANNEL_OPEN_FAILURE, &channel_input_open_failure);
	dispatch_set(SSH_MSG_PORT_OPEN, &channel_input_port_open);
	dispatch_set(SSH_SMSG_EXITSTATUS, &client_input_exit_status);
	dispatch_set(SSH_SMSG_STDERR_DATA, &client_input_stderr_data);
	dispatch_set(SSH_SMSG_STDOUT_DATA, &client_input_stdout_data);

	dispatch_set(SSH_SMSG_AGENT_OPEN, options.forward_agent ?
	    &client_input_agent_open : &deny_input_open);
	dispatch_set(SSH_SMSG_X11_OPEN, options.forward_x11 ?
	    &x11_input_open : &deny_input_open);
}

static void
client_init_dispatch_15(void)
{
	client_init_dispatch_13();
	dispatch_set(SSH_MSG_CHANNEL_CLOSE, &channel_input_ieof);
	dispatch_set(SSH_MSG_CHANNEL_CLOSE_CONFIRMATION, & channel_input_oclose);
}

static void
client_init_dispatch(void)
{
	if (compat20)
		client_init_dispatch_20();
	else if (compat13)
		client_init_dispatch_13();
	else
		client_init_dispatch_15();
}

/* client specific fatal cleanup */
void
cleanup_exit(int i)
{
	leave_raw_mode();
	leave_non_blocking();
	if (options.control_path != NULL && muxserver_sock != -1)
		unlink(options.control_path);
	_exit(i);
}
@


1.17
log
@• merge newer OpenSSH
• KNF in our diff – style(9)
• some const cleanliness (build with __CRAZY=Yes mostly)
@
text
@a102 1
#include "roaming.h"
d104 1
a104 1
__RCSID("$MirOS: src/usr.bin/ssh/clientloop.c,v 1.16 2009/10/02 16:58:47 tg Exp $");
d630 1
a630 1
	int len, cont = 0;
d639 2
a640 2
		len = roaming_read(connection_in, buf, sizeof(buf), &cont);
		if (len == 0 && cont == 0) {
@


1.16
log
@sync ssh_config and manpage with each other
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.209 2009/02/12 03:00:56 djm Exp $ */
d103 1
d105 1
a105 1
__RCSID("$MirOS: src/usr.bin/ssh/clientloop.c,v 1.15 2009/03/22 15:01:15 tg Exp $");
d488 1
a488 1
	keep_alive_timeouts = 0;
d494 1
a494 1
	if (++keep_alive_timeouts > options.server_alive_count_max) {
d631 1
a631 1
	int len;
d640 2
a641 2
		len = read(connection_in, buf, sizeof(buf));
		if (len == 0) {
d1469 8
@


1.15
log
@merge and tweak ciphers and MACs
@
text
@d104 1
a104 1
__RCSID("$MirOS: src/usr.bin/ssh/clientloop.c,v 1.14 2008/12/16 20:55:20 tg Exp $");
d120 1
a120 1
 * command line, or the HostName specified for the user-supplied name in a
@


1.14
log
@fastmerge, do not use yet!
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.207 2008/12/09 22:37:33 stevesk Exp $ */
d104 1
a104 1
__RCSID("$MirOS$");
d760 1
a760 1
	u_short cancel_port;
d838 1
a838 1
		if (cancel_port == 0) {
d844 1
a844 1
		if (!parse_forward(&fwd, s, dynamic ? 1 : 0)) {
d1630 1
a1630 1
	int listen_port, originator_port;
d1656 1
a1656 1
	int originator_port;
@


1.13
log
@merge’n’fix
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.188 2008/02/22 20:44:02 dtucker Exp $ */
d63 1
a63 1
#include <sys/types.h>
d68 1
a68 1
#include <sys/param.h>
a100 1
#include "monitor_fdpass.h"
d104 2
d116 1
a116 1
extern int control_fd;
d139 2
a140 2
static int escape_char;		/* Escape character. */
static int escape_pending;	/* Last character was the escape character */
d142 2
a143 2
static int exit_status;		/* Used to store the exit status of the command. */
static int stdin_eof;		/* EOF has been encountered on standard error. */
a146 1
static u_long stdin_bytes, stdout_bytes, stderr_bytes;
d156 10
a165 9
struct confirm_ctx {
	int want_tty;
	int want_subsys;
	int want_x_fwd;
	int want_agent_fwd;
	Buffer cmd;
	char *term;
	struct termios tio;
	char **env;
d168 11
d386 4
a389 1
			/* EOF.  Record that we have seen it and send EOF to server. */
d400 2
a401 2
			if ((u_char) buf[0] == escape_char)
				escape_pending = 1;
a430 1
		stdin_bytes += len;
d475 12
a487 1
	client_global_request_reply_fwd(type, seq, ctxt);
d501 2
d554 2
a555 2
	if (control_fd != -1)
		FD_SET(control_fd, *readsetp);
d597 2
a598 1
		atomicio(vwrite, fileno(stdout), buffer_ptr(bout), buffer_len(bout));
d600 2
a601 1
		atomicio(vwrite, fileno(stderr), buffer_ptr(berr), buffer_len(berr));
d641 7
a647 3
			/* Received EOF.  The remote host has closed the connection. */
			snprintf(buf, sizeof buf, "Connection to %.300s closed by remote host.\r\n",
				 host);
d660 7
a666 3
			/* An error has encountered.  Perhaps there is a network problem. */
			snprintf(buf, sizeof buf, "Read from remote host %.300s: %.100s\r\n",
				 host, strerror(errno));
d676 1
a676 1
client_subsystem_reply(int type, u_int32_t seq, void *ctxt)
d678 32
a709 16
	int id;
	Channel *c;

	id = packet_get_int();
	packet_check_eom();

	if ((c = channel_lookup(id)) == NULL) {
		error("%s: no channel for id %d", __func__, id);
		return;
	}

	if (type == SSH2_MSG_CHANNEL_SUCCESS)
		debug2("Request suceeded on channel %d", id);
	else if (type == SSH2_MSG_CHANNEL_FAILURE) {
		error("Request failed on channel %d", id);
		channel_free(c);
d711 1
d715 1
a715 1
client_extra_session2_setup(int id, void *arg)
d717 1
a717 41
	struct confirm_ctx *cctx = arg;
	const char *display;
	Channel *c;
	int i;

	if (cctx == NULL)
		fatal("%s: cctx == NULL", __func__);
	if ((c = channel_lookup(id)) == NULL)
		fatal("%s: no channel for id %d", __func__, id);

	display = getenv("DISPLAY");
	if (cctx->want_x_fwd && options.forward_x11 && display != NULL) {
		char *proto, *data;
		/* Get reasonable local authentication information. */
		client_x11_get_proto(display, options.xauth_location,
		    options.forward_x11_trusted, &proto, &data);
		/* Request forwarding with authentication spoofing. */
		debug("Requesting X11 forwarding with authentication spoofing.");
		x11_request_forwarding_with_spoofing(id, display, proto, data);
		/* XXX wait for reply */
	}

	if (cctx->want_agent_fwd && options.forward_agent) {
		debug("Requesting authentication agent forwarding.");
		channel_request_start(id, "auth-agent-req@@openssh.com", 0);
		packet_send();
	}

	client_session2_setup(id, cctx->want_tty, cctx->want_subsys,
	    cctx->term, &cctx->tio, c->rfd, &cctx->cmd, cctx->env,
	    client_subsystem_reply);

	c->confirm_ctx = NULL;
	buffer_free(&cctx->cmd);
	xfree(cctx->term);
	if (cctx->env != NULL) {
		for (i = 0; cctx->env[i] != NULL; i++)
			xfree(cctx->env[i]);
		xfree(cctx->env);
	}
	xfree(cctx);
d721 1
a721 1
client_process_control(fd_set *readset)
d723 1
a723 10
	Buffer m;
	Channel *c;
	int client_fd, new_fd[3], ver, allowed, window, packetmax;
	socklen_t addrlen;
	struct sockaddr_storage addr;
	struct confirm_ctx *cctx;
	char *cmd;
	u_int i, j, len, env_len, command, flags;
	uid_t euid;
	gid_t egid;
d725 2
a726 5
	/*
	 * Accept connection on control socket
	 */
	if (control_fd == -1 || !FD_ISSET(control_fd, readset))
		return;
d728 3
a730 7
	memset(&addr, 0, sizeof(addr));
	addrlen = sizeof(addr);
	if ((client_fd = accept(control_fd,
	    (struct sockaddr*)&addr, &addrlen)) == -1) {
		error("%s accept: %s", __func__, strerror(errno));
		return;
	}
d732 4
a735 13
	if (getpeereid(client_fd, &euid, &egid) < 0) {
		error("%s getpeereid failed: %s", __func__, strerror(errno));
		close(client_fd);
		return;
	}
	if ((euid != 0) && (getuid() != euid)) {
		error("control mode uid mismatch: peer euid %u != uid %u",
		    (u_int) euid, (u_int) getuid());
		close(client_fd);
		return;
	}

	unset_nonblock(client_fd);
d737 6
a742 55
	/* Read command */
	buffer_init(&m);
	if (ssh_msg_recv(client_fd, &m) == -1) {
		error("%s: client msg_recv failed", __func__);
		close(client_fd);
		buffer_free(&m);
		return;
	}
	if ((ver = buffer_get_char(&m)) != SSHMUX_VER) {
		error("%s: wrong client version %d", __func__, ver);
		buffer_free(&m);
		close(client_fd);
		return;
	}

	allowed = 1;
	command = buffer_get_int(&m);
	flags = buffer_get_int(&m);

	buffer_clear(&m);

	switch (command) {
	case SSHMUX_COMMAND_OPEN:
		if (options.control_master == SSHCTL_MASTER_ASK ||
		    options.control_master == SSHCTL_MASTER_AUTO_ASK)
			allowed = ask_permission("Allow shared connection "
			    "to %s? ", host);
		/* continue below */
		break;
	case SSHMUX_COMMAND_TERMINATE:
		if (options.control_master == SSHCTL_MASTER_ASK ||
		    options.control_master == SSHCTL_MASTER_AUTO_ASK)
			allowed = ask_permission("Terminate shared connection "
			    "to %s? ", host);
		if (allowed)
			quit_pending = 1;
		/* FALLTHROUGH */
	case SSHMUX_COMMAND_ALIVE_CHECK:
		/* Reply for SSHMUX_COMMAND_TERMINATE and ALIVE_CHECK */
		buffer_clear(&m);
		buffer_put_int(&m, allowed);
		buffer_put_int(&m, getpid());
		if (ssh_msg_send(client_fd, SSHMUX_VER, &m) == -1) {
			error("%s: client msg_send failed", __func__);
			close(client_fd);
			buffer_free(&m);
			return;
		}
		buffer_free(&m);
		close(client_fd);
		return;
	default:
		error("Unsupported command %d", command);
		buffer_free(&m);
		close(client_fd);
d746 5
a750 130
	/* Reply for SSHMUX_COMMAND_OPEN */
	buffer_clear(&m);
	buffer_put_int(&m, allowed);
	buffer_put_int(&m, getpid());
	if (ssh_msg_send(client_fd, SSHMUX_VER, &m) == -1) {
		error("%s: client msg_send failed", __func__);
		close(client_fd);
		buffer_free(&m);
		return;
	}

	if (!allowed) {
		error("Refused control connection");
		close(client_fd);
		buffer_free(&m);
		return;
	}

	buffer_clear(&m);
	if (ssh_msg_recv(client_fd, &m) == -1) {
		error("%s: client msg_recv failed", __func__);
		close(client_fd);
		buffer_free(&m);
		return;
	}
	if ((ver = buffer_get_char(&m)) != SSHMUX_VER) {
		error("%s: wrong client version %d", __func__, ver);
		buffer_free(&m);
		close(client_fd);
		return;
	}

	cctx = xcalloc(1, sizeof(*cctx));
	cctx->want_tty = (flags & SSHMUX_FLAG_TTY) != 0;
	cctx->want_subsys = (flags & SSHMUX_FLAG_SUBSYS) != 0;
	cctx->want_x_fwd = (flags & SSHMUX_FLAG_X11_FWD) != 0;
	cctx->want_agent_fwd = (flags & SSHMUX_FLAG_AGENT_FWD) != 0;
	cctx->term = buffer_get_string(&m, &len);

	cmd = buffer_get_string(&m, &len);
	buffer_init(&cctx->cmd);
	buffer_append(&cctx->cmd, cmd, strlen(cmd));

	env_len = buffer_get_int(&m);
	env_len = MIN(env_len, 4096);
	debug3("%s: receiving %d env vars", __func__, env_len);
	if (env_len != 0) {
		cctx->env = xcalloc(env_len + 1, sizeof(*cctx->env));
		for (i = 0; i < env_len; i++)
			cctx->env[i] = buffer_get_string(&m, &len);
		cctx->env[i] = NULL;
	}

	debug2("%s: accepted tty %d, subsys %d, cmd %s", __func__,
	    cctx->want_tty, cctx->want_subsys, cmd);
	xfree(cmd);

	/* Gather fds from client */
	for(i = 0; i < 3; i++) {
		if ((new_fd[i] = mm_receive_fd(client_fd)) == -1) {
			error("%s: failed to receive fd %d from slave",
			    __func__, i);
			for (j = 0; j < i; j++)
				close(new_fd[j]);
			for (j = 0; j < env_len; j++)
				xfree(cctx->env[j]);
			if (env_len > 0)
				xfree(cctx->env);
			xfree(cctx->term);
			buffer_free(&cctx->cmd);
			close(client_fd);
			xfree(cctx);
			return;
		}
	}

	debug2("%s: got fds stdin %d, stdout %d, stderr %d", __func__,
	    new_fd[0], new_fd[1], new_fd[2]);

	/* Try to pick up ttymodes from client before it goes raw */
	if (cctx->want_tty && tcgetattr(new_fd[0], &cctx->tio) == -1)
		error("%s: tcgetattr: %s", __func__, strerror(errno));

	/* This roundtrip is just for synchronisation of ttymodes */
	buffer_clear(&m);
	if (ssh_msg_send(client_fd, SSHMUX_VER, &m) == -1) {
		error("%s: client msg_send failed", __func__);
		close(client_fd);
		close(new_fd[0]);
		close(new_fd[1]);
		close(new_fd[2]);
		buffer_free(&m);
		xfree(cctx->term);
		if (env_len != 0) {
			for (i = 0; i < env_len; i++)
				xfree(cctx->env[i]);
			xfree(cctx->env);
		}
		return;
	}
	buffer_free(&m);

	/* enable nonblocking unless tty */
	if (!isatty(new_fd[0]))
		set_nonblock(new_fd[0]);
	if (!isatty(new_fd[1]))
		set_nonblock(new_fd[1]);
	if (!isatty(new_fd[2]))
		set_nonblock(new_fd[2]);

	set_nonblock(client_fd);

	window = CHAN_SES_WINDOW_DEFAULT;
	packetmax = CHAN_SES_PACKET_DEFAULT;
	if (cctx->want_tty) {
		window >>= 1;
		packetmax >>= 1;
	}
	
	c = channel_new("session", SSH_CHANNEL_OPENING,
	    new_fd[0], new_fd[1], new_fd[2], window, packetmax,
	    CHAN_EXTENDED_WRITE, "client-session", /*nonblock*/0);

	/* XXX */
	c->ctl_fd = client_fd;

	debug3("%s: channel_new: %d", __func__, c->self);

	channel_send_open(c->self);
	channel_register_confirm(c->self, client_extra_session2_setup, cctx);
d759 1
a759 1
	int local = 0;
d784 2
d805 7
a811 1
	if (*s != 'L' && *s != 'R') {
d815 2
a816 3
	if (*s == 'L')
		local = 1;
	if (local && delete) {
d820 1
a820 1
	if ((!local || delete) && !compat20) {
d844 1
a844 1
		if (!parse_forward(&fwd, s)) {
d848 1
a848 1
		if (local) {
d878 3
a880 1
/* process the characters one by one */
d882 2
a883 1
process_escapes(Buffer *bin, Buffer *bout, Buffer *berr, char *buf, int len)
d891 2
d894 11
d912 1
a912 1
		if (escape_pending) {
d915 1
a915 1
			escape_pending = 0;
d921 2
a922 1
				snprintf(string, sizeof string, "%c.\r\n", escape_char);
d925 6
a930 1
				quit_pending = 1;
d934 14
a947 3
				/* Suspend the program. */
				/* Print a message to that effect to the user. */
				snprintf(string, sizeof string, "%c^Z [suspend ssh]\r\n", escape_char);
d972 2
a973 1
						logit("Server does not support re-keying");
d980 2
d983 3
a985 2
				 * Detach the program (continue to serve connections,
				 * but put in background and no more new connections).
d1014 3
a1016 3
					 * Sending SSH_CMSG_EOF alone does not always appear
					 * to be enough.  So we try to send an EOF character
					 * first.
d1031 17
a1047 1
				snprintf(string, sizeof string,
d1050 9
a1058 9
%c.  - terminate connection\r\n\
%cB  - send a BREAK to the remote system\r\n\
%cC  - open a command line\r\n\
%cR  - Request rekey (SSH protocol 2 only)\r\n\
%c^Z - suspend ssh\r\n\
%c#  - list forwarded connections\r\n\
%c&  - background ssh (when waiting for connections to terminate)\r\n\
%c?  - this message\r\n\
%c%c  - send the escape character by typing it twice\r\n\
d1060 7
a1066 3
				    escape_char, escape_char, escape_char, escape_char,
				    escape_char, escape_char, escape_char, escape_char,
				    escape_char, escape_char, escape_char);
d1071 2
a1072 1
				snprintf(string, sizeof string, "%c#\r\n", escape_char);
d1080 2
d1095 2
a1096 2
			 * The previous character was not an escape char. Check if this
			 * is an escape.
d1099 5
a1103 2
				/* It is. Set the flag and continue to next character. */
				escape_pending = 1;
d1138 2
a1139 1
				snprintf(buf, sizeof buf, "read: %.100s\r\n", strerror(errno));
d1155 1
a1155 1
		} else if (escape_char == SSH_ESCAPECHAR_NONE) {
d1163 3
a1165 2
			 * Normal, successful read.  But we have an escape character
			 * and have to process the characters one by one.
d1167 2
a1168 2
			if (process_escapes(&stdin_buffer, &stdout_buffer,
			    &stderr_buffer, buf, len) == -1)
d1193 2
a1194 1
				snprintf(buf, sizeof buf, "write stdout: %.50s\r\n", strerror(errno));
a1201 1
		stdout_bytes += len;
d1212 4
a1215 1
				/* EOF or error, but can't even print error message. */
a1221 1
		stderr_bytes += len;
d1240 2
a1241 1
	dispatch_run(DISPATCH_NONBLOCK, &quit_pending, compat20 ? xxx_kex : NULL);
d1246 21
a1266 2
static int
simple_escape_filter(Channel *c, char *buf, int len)
d1268 5
a1272 2
	/* XXX we assume c->extended is writeable */
	return process_escapes(&c->input, &c->output, &c->extended, buf, len);
d1296 1
d1305 1
a1305 1
	escape_pending = 0;
d1313 2
a1314 2
	if (control_fd != -1)
		max_fd = MAX(max_fd, control_fd);
a1327 3
	stdin_bytes = 0;
	stdout_bytes = 0;
	stderr_bytes = 0;
d1329 1
a1329 1
	escape_char = escape_char_arg;
d1357 1
a1357 1
		if (escape_char != SSH_ESCAPECHAR_NONE)
d1359 3
a1361 1
			    simple_escape_filter, NULL);
d1433 4
a1436 1
		client_process_control(readset);
d1451 4
a1454 1
		/* Send as much buffered packet data as possible to the sender. */
d1499 2
a1500 1
		snprintf(buf, sizeof buf, "Connection to %.64s closed.\r\n", host);
a1512 1
		stdout_bytes += len;
a1523 1
		stderr_bytes += len;
d1534 4
a1537 2
	debug("Transferred: stdin %lu, stdout %lu, stderr %lu bytes in %.1f seconds",
	    stdin_bytes, stdout_bytes, stderr_bytes, total_time);
d1539 2
a1540 4
		debug("Bytes per second: stdin %.1f, stdout %.1f, stderr %.1f",
		    stdin_bytes / total_time, stdout_bytes / total_time,
		    stderr_bytes / total_time);

a1630 1
	int sock;
d1639 6
a1644 2
	debug("client_request_forwarded_tcpip: listen %s port %d, originator %s port %d",
	    listen_address, listen_port, originator_address, originator_port);
a1645 10
	sock = channel_connect_by_listen_address(listen_port);
	if (sock < 0) {
		xfree(originator_address);
		xfree(listen_address);
		return NULL;
	}
	c = channel_new("forwarded-tcpip",
	    SSH_CHANNEL_CONNECTING, sock, sock, -1,
	    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0,
	    originator_address, 1);
d1661 2
a1662 1
		error("Warning: this is probably a break-in attempt by a malicious server.");
d1695 2
a1696 1
		error("Warning: this is probably a break-in attempt by a malicious server.");
d1720 1
a1720 1
		error("Tunnel forwarding is not support for protocol 1");
d1816 5
a1820 1
		error("client_input_channel_req: channel %d: unknown channel", id);
d1838 1
a1838 1
		packet_put_int(id);
d1865 1
a1865 2
    const char *term, struct termios *tiop, int in_fd, Buffer *cmd, char **env,
    dispatch_fn *subsys_repl)
a1876 1
		struct termios tio;
d1882 2
a1883 1
		channel_request_start(id, "pty-req", 0);
d1889 3
a1891 2
		tio = get_saved_tio();
		tty_make_modes(-1, tiop != NULL ? tiop : &tio);
d1939 4
a1942 8
			debug("Sending subsystem: %.*s", len, (u_char*)buffer_ptr(cmd));
			channel_request_start(id, "subsystem", subsys_repl != NULL);
			if (subsys_repl != NULL) {
				/* register callback for reply */
				/* XXX we assume that client_loop has already been called */
				dispatch_set(SSH2_MSG_CHANNEL_FAILURE, subsys_repl);
				dispatch_set(SSH2_MSG_CHANNEL_SUCCESS, subsys_repl);
			}
d1944 4
a1947 2
			debug("Sending command: %.*s", len, (u_char*)buffer_ptr(cmd));
			channel_request_start(id, "exec", 0);
d1952 2
a1953 1
		channel_request_start(id, "shell", 0);
d1972 2
d1983 1
d2003 1
d2011 1
d2029 1
a2029 1
	if (options.control_path != NULL && control_fd != -1)
@


1.12
log
@merge and make UMAC-64 default message integrity whatever
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.182 2007/09/04 03:21:03 djm Exp $ */
a151 1
static int server_alive_timeouts = 0;
d461 1
a461 1
	server_alive_timeouts = 0;
d468 1
a468 1
	if (++server_alive_timeouts > options.server_alive_count_max) {
d876 1
d948 3
d1050 4
d1734 1
a1734 1
	    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_WINDOW_DEFAULT, 0,
d1792 1
a1792 1
	    CHAN_X11_WINDOW_DEFAULT, CHAN_TCP_WINDOW_DEFAULT, 0,
@


1.11
log
@MirBSD SecureShell 4.7/#10semel
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.181 2007/08/15 08:14:46 markus Exp $ */
d717 1
a717 1
	u_int i, len, env_len, command, flags;
d865 16
a880 3
	new_fd[0] = mm_receive_fd(client_fd);
	new_fd[1] = mm_receive_fd(client_fd);
	new_fd[2] = mm_receive_fd(client_fd);
@


1.10
log
@merge openssh
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.179 2007/03/20 03:56:12 tedu Exp $ */
d285 23
a307 13
		snprintf(cmd, sizeof(cmd),
		    "%s %s%s list %s 2>" _PATH_DEVNULL,
		    xauth_path,
		    generated ? "-f " : "" ,
		    generated ? xauthfile : "",
		    display);
		debug2("x11_get_proto: %s", cmd);
		f = popen(cmd, "r");
		if (f && fgets(line, sizeof(line), f) &&
		    sscanf(line, "%*s %511s %511s", proto, data) == 2)
			got_data = 1;
		if (f)
			pclose(f);
d1778 38
@


1.9
log
@merge OpenSSH 4.6, retain local changes
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.178 2007/02/20 10:25:14 djm Exp $ */
d930 1
a930 1
	while (*s && isspace(*s))
d977 2
a978 3
	s++;
	while (*s && isspace(*s))
		s++;
@


1.8
log
@automerge, bump vsn
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.177 2007/01/21 01:41:54 stevesk Exp $ */
d702 1
a702 1
	int client_fd, new_fd[3], ver, allowed;
d895 7
d903 1
a903 2
	    new_fd[0], new_fd[1], new_fd[2],
	    CHAN_SES_WINDOW_DEFAULT, CHAN_SES_PACKET_DEFAULT,
@


1.7
log
@merge the 4.0 equivalent of 015_ssh.patch
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.176 2006/10/11 12:38:03 markus Exp $ */
d1752 1
a1752 1
	sock =  ssh_get_authentication_socket();
@


1.6
log
@finish merging
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.175 2006/08/03 03:34:42 deraadt Exp $ */
d459 4
a462 2
	if (++server_alive_timeouts > options.server_alive_count_max)
		packet_disconnect("Timeout, server not responding.");
@


1.5
log
@fix spelling and pubkey authentication
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.163 2006/05/16 09:00:00 markus Exp $ */
a61 1
#include "includes.h"
d63 1
d66 3
d71 1
d74 3
d78 2
d81 1
a84 1
#include "xmalloc.h"
a89 2
#include "buffer.h"
#include "bufaux.h"
d91 1
d931 6
a936 3
		logit("      -Lport:host:hostport    Request local forward");
		logit("      -Rport:host:hostport    Request remote forward");
		logit("      -KRhostport             Cancel remote forward");
d939 2
a940 1
		logit("      !args                   Execute local command");
d1001 1
a1001 1
			channel_request_remote_forwarding(fwd.listen_host,
d1003 4
a1006 1
			    fwd.connect_port);
@


1.4
log
@* merge
* remove all references to GSSAPI, Kerberos and AFS
* uint*_t -> u_int*_t for consistency, like openbsd
  (note: MirOS style(9) suggests uint32_t etc. instead!)
* bump vsn
@
text
@d250 1
a250 1
		 * not match an authorization entry.  For this we
@


1.3
log
@merge and clean up
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.161 2006/03/25 18:30:55 deraadt Exp $ */
d129 1
a129 1
static int quit_pending;	/* Set to non-zero to quit the client loop. */
d842 1
@


1.2
log
@merge; bump version; fix up manpages and includes a little
@
text
@d1 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.154 2006/02/20 17:19:54 stevesk Exp $");
d67 1
d189 1
a189 1

d201 1
a201 1

d433 4
a436 4
		packet_put_int(ws.ws_row);
		packet_put_int(ws.ws_col);
		packet_put_int(ws.ws_xpixel);
		packet_put_int(ws.ws_ypixel);
d580 1
a580 1
client_process_net_input(fd_set * readset)
d688 1
a688 1
client_process_control(fd_set * readset)
d819 1
a819 2
	cctx = xmalloc(sizeof(*cctx));
	memset(cctx, 0, sizeof(*cctx));
d834 1
a834 1
		cctx->env = xmalloc(sizeof(*cctx->env) * (env_len + 1));
d1182 1
a1182 1
client_process_input(fd_set * readset)
d1235 1
a1235 1
client_process_output(fd_set * writeset)
d1879 4
a1882 4
		packet_put_int(ws.ws_col);
		packet_put_int(ws.ws_row);
		packet_put_int(ws.ws_xpixel);
		packet_put_int(ws.ws_ypixel);
@


1.1
log
@Initial revision
@
text
@d62 8
a69 1
RCSID("$OpenBSD: clientloop.c,v 1.134 2004/11/07 00:01:46 djm Exp $");
d87 1
d124 1
a124 1
/* Flag indicating whether the user\'s terminal is in non-blocking mode. */
d151 2
d221 103
d644 1
d653 18
d691 1
a691 1
	int client_fd, new_fd[3], ver, i, allowed;
d696 1
a696 1
	u_int len, env_len, command, flags;
d736 1
a736 1
	if ((ver = buffer_get_char(&m)) != 1) {
d751 2
a752 1
		if (options.control_master == 2)
d758 2
a759 1
		if (options.control_master == 2)
d764 1
a764 1
		/* FALLTHROUGH */	
d770 1
a770 1
		if (ssh_msg_send(client_fd, /* version */1, &m) == -1) {
d790 1
a790 1
	if (ssh_msg_send(client_fd, /* version */1, &m) == -1) {
d811 1
a811 1
	if ((ver = buffer_get_char(&m)) != 1) {
d822 2
d857 1
a857 1
	if (ssh_msg_send(client_fd, /* version */1, &m) == -1) {
d902 1
a902 3
	char *s, *cmd;
	u_short fwd_port, fwd_host_port;
	char buf[1024], sfwd_port[6], sfwd_host_port[6];
d905 2
d925 9
d961 8
a968 3
		if (sscanf(s, "%5[0-9]", sfwd_host_port) != 1) {
			logit("Bad forwarding specification.");
			goto out;
d970 2
a971 2
		if ((fwd_host_port = a2port(sfwd_host_port)) == 0) {
			logit("Bad forwarding port(s).");
d974 1
a974 1
		channel_request_rforward_cancel(fwd_host_port);
d976 1
a976 4
		if (sscanf(s, "%5[0-9]:%255[^:]:%5[0-9]",
		    sfwd_port, buf, sfwd_host_port) != 3 &&
		    sscanf(s, "%5[0-9]/%255[^/]/%5[0-9]",
		    sfwd_port, buf, sfwd_host_port) != 3) {
a979 5
		if ((fwd_port = a2port(sfwd_port)) == 0 ||
		    (fwd_host_port = a2port(sfwd_host_port)) == 0) {
			logit("Bad forwarding port(s).");
			goto out;
		}
d981 3
a983 2
			if (channel_setup_local_fwd_listener(fwd_port, buf,
			    fwd_host_port, options.gateway_ports) < 0) {
d987 6
a992 3
		} else
			channel_request_remote_forwarding(fwd_port, buf,
			    fwd_host_port);
d1014 4
a1017 1
	for (i = 0; i < len; i++) {
d1396 1
a1396 1
			    simple_escape_filter);
d1399 1
a1399 1
			    client_channel_closed);
d1698 1
a1698 1
		error("Warning: this is probably a break in attempt by a malicious server.");
d1731 1
a1731 1
		error("Warning: this is probably a break in attempt by a malicious server.");
d1900 1
a1900 1
				free(name);
d1914 1
a1914 1
				free(name);
d1923 1
a1923 1
			free(name);
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@OpenSSH-current
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.136 2005/03/10 22:01:05 deraadt Exp $");
d630 1
a630 1
		/* FALLTHROUGH */
d766 3
a768 1
	char *s, *cmd, *cancel_host;
a770 2
	u_short cancel_port;
	Forward fwd;
d816 3
a818 8
		cancel_port = 0;
		cancel_host = hpdelim(&s);	/* may be NULL */
		if (s != NULL) {
			cancel_port = a2port(s);
			cancel_host = cleanhostname(cancel_host);
		} else {
			cancel_port = a2port(cancel_host);
			cancel_host = NULL;
d820 2
a821 2
		if (cancel_port == 0) {
			logit("Bad forwarding close port");
d824 1
a824 1
		channel_request_rforward_cancel(cancel_host, cancel_port);
d826 4
a829 1
		if (!parse_forward(&fwd, s)) {
d833 5
d839 2
a840 3
			if (channel_setup_local_fwd_listener(fwd.listen_host,
			    fwd.listen_port, fwd.connect_host,
			    fwd.connect_port, options.gateway_ports) < 0) {
d844 3
a846 6
		} else {
			channel_request_remote_forwarding(fwd.listen_host,
			    fwd.listen_port, fwd.connect_host,
			    fwd.connect_port);
		}

@


1.1.1.3
log
@most current OpenSSH.com
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.139 2005/06/17 02:44:32 djm Exp $");
a210 103
#define SSH_X11_PROTO "MIT-MAGIC-COOKIE-1"
void
client_x11_get_proto(const char *display, const char *xauth_path,
    u_int trusted, char **_proto, char **_data)
{
	char cmd[1024];
	char line[512];
	char xdisplay[512];
	static char proto[512], data[512];
	FILE *f;
	int got_data = 0, generated = 0, do_unlink = 0, i;
	char *xauthdir, *xauthfile;
	struct stat st;

	xauthdir = xauthfile = NULL;
	*_proto = proto;
	*_data = data;
	proto[0] = data[0] = '\0';

	if (xauth_path == NULL ||(stat(xauth_path, &st) == -1)) {
		debug("No xauth program.");
	} else {
		if (display == NULL) {
			debug("x11_get_proto: DISPLAY not set");
			return;
		}
		/*
		 * Handle FamilyLocal case where $DISPLAY does
		 * not match an authorization entry.  For this we
		 * just try "xauth list unix:displaynum.screennum".
		 * XXX: "localhost" match to determine FamilyLocal
		 *      is not perfect.
		 */
		if (strncmp(display, "localhost:", 10) == 0) {
			snprintf(xdisplay, sizeof(xdisplay), "unix:%s",
			    display + 10);
			display = xdisplay;
		}
		if (trusted == 0) {
			xauthdir = xmalloc(MAXPATHLEN);
			xauthfile = xmalloc(MAXPATHLEN);
			strlcpy(xauthdir, "/tmp/ssh-XXXXXXXXXX", MAXPATHLEN);
			if (mkdtemp(xauthdir) != NULL) {
				do_unlink = 1;
				snprintf(xauthfile, MAXPATHLEN, "%s/xauthfile",
				    xauthdir);
				snprintf(cmd, sizeof(cmd),
				    "%s -f %s generate %s " SSH_X11_PROTO
				    " untrusted timeout 1200 2>" _PATH_DEVNULL,
				    xauth_path, xauthfile, display);
				debug2("x11_get_proto: %s", cmd);
				if (system(cmd) == 0)
					generated = 1;
			}
		}
		snprintf(cmd, sizeof(cmd),
		    "%s %s%s list %s . 2>" _PATH_DEVNULL,
		    xauth_path,
		    generated ? "-f " : "" ,
		    generated ? xauthfile : "",
		    display);
		debug2("x11_get_proto: %s", cmd);
		f = popen(cmd, "r");
		if (f && fgets(line, sizeof(line), f) &&
		    sscanf(line, "%*s %511s %511s", proto, data) == 2)
			got_data = 1;
		if (f)
			pclose(f);
	}

	if (do_unlink) {
		unlink(xauthfile);
		rmdir(xauthdir);
	}
	if (xauthdir)
		xfree(xauthdir);
	if (xauthfile)
		xfree(xauthfile);

	/*
	 * If we didn't get authentication data, just make up some
	 * data.  The forwarding code will check the validity of the
	 * response anyway, and substitute this data.  The X11
	 * server, however, will ignore this fake data and use
	 * whatever authentication mechanisms it was using otherwise
	 * for the local connection.
	 */
	if (!got_data) {
		u_int32_t rnd = 0;

		logit("Warning: No xauth data; "
		    "using fake authentication data for X11 forwarding.");
		strlcpy(proto, SSH_X11_PROTO, sizeof proto);
		for (i = 0; i < 16; i++) {
			if (i % 4 == 0)
				rnd = arc4random();
			snprintf(data + 2 * i, sizeof data - 2 * i, "%02x",
			    rnd & 0xff);
			rnd >>= 8;
		}
	}
}

d559 1
a559 1
	int client_fd, new_fd[3], ver, allowed;
d564 1
a564 1
	u_int i, len, env_len, command, flags;
d619 1
a619 2
		if (options.control_master == SSHCTL_MASTER_ASK ||
		    options.control_master == SSHCTL_MASTER_AUTO_ASK)
d625 1
a625 2
		if (options.control_master == SSHCTL_MASTER_ASK ||
		    options.control_master == SSHCTL_MASTER_AUTO_ASK)
d869 1
a869 4
	if (len <= 0)
		return (0);

	for (i = 0; i < (u_int)len; i++) {
@


1.1.1.4
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.141 2005/07/16 01:35:24 djm Exp $");
a142 2
	int want_x_fwd;
	int want_agent_fwd;
a633 1
	const char *display;
a641 18
	display = getenv("DISPLAY");
	if (cctx->want_x_fwd && options.forward_x11 && display != NULL) {
		char *proto, *data;
		/* Get reasonable local authentication information. */
		client_x11_get_proto(display, options.xauth_location,
		    options.forward_x11_trusted, &proto, &data);
		/* Request forwarding with authentication spoofing. */
		debug("Requesting X11 forwarding with authentication spoofing.");
		x11_request_forwarding_with_spoofing(id, display, proto, data);
		/* XXX wait for reply */
	}

	if (cctx->want_agent_fwd && options.forward_agent) {
		debug("Requesting authentication agent forwarding.");
		channel_request_start(id, "auth-agent-req@@openssh.com", 0);
		packet_send();
	}

d707 1
a707 1
	if ((ver = buffer_get_char(&m)) != SSHMUX_VER) {
d741 1
a741 1
		if (ssh_msg_send(client_fd, SSHMUX_VER, &m) == -1) {
d761 1
a761 1
	if (ssh_msg_send(client_fd, SSHMUX_VER, &m) == -1) {
d782 1
a782 1
	if ((ver = buffer_get_char(&m)) != SSHMUX_VER) {
a792 2
	cctx->want_x_fwd = (flags & SSHMUX_FLAG_X11_FWD) != 0;
	cctx->want_agent_fwd = (flags & SSHMUX_FLAG_AGENT_FWD) != 0;
d826 1
a826 1
	if (ssh_msg_send(client_fd, SSHMUX_VER, &m) == -1) {
@


1.1.1.5
log
@Import current OpenSSH
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.145 2005/10/30 08:52:17 djm Exp $");
d116 1
a116 1
/* Flag indicating whether the user's terminal is in non-blocking mode. */
d269 1
a269 1
		    "%s %s%s list %s 2>" _PATH_DEVNULL,
d1382 1
a1382 1
			    client_channel_closed, 0);
d1883 1
a1883 1
				xfree(name);
d1897 1
a1897 1
				xfree(name);
d1906 1
a1906 1
			xfree(name);
@


1.1.1.6
log
@OpenSSH is the last missing piece to update before the release
@
text
@d62 1
a62 1
RCSID("$OpenBSD: clientloop.c,v 1.147 2005/12/07 03:52:22 djm Exp $");
a79 1
#include "sshconnect.h"
a916 9
		if (!options.permit_local_command)
			goto out;
		logit("      !args                   Execute local command");
		goto out;
	}

	if (*s == '!' && options.permit_local_command) {
		s++;
		ssh_local_cmd(s);
@


1.1.1.7
log
@import OpenSSH-current
@
text
@d62 1
a62 9
RCSID("$OpenBSD: clientloop.c,v 1.154 2006/02/20 17:19:54 stevesk Exp $");

#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>

#include <paths.h>
#include <signal.h>
#include <termios.h>
d1389 1
a1389 1
			    simple_escape_filter, NULL);
d1691 1
a1691 1
		error("Warning: this is probably a break-in attempt by a malicious server.");
d1724 1
a1724 1
		error("Warning: this is probably a break-in attempt by a malicious server.");
@


1.1.1.8
log
@I decided we'd better upgrade OpenSSH before releasing to the general public
@
text
@a0 1
/* $OpenBSD: clientloop.c,v 1.161 2006/03/25 18:30:55 deraadt Exp $ */
d62 1
a67 1
#include <ctype.h>
d189 1
a189 1
/*ARGSUSED */
d201 1
a201 1
/*ARGSUSED */
d433 4
a436 4
		packet_put_int((u_int)ws.ws_row);
		packet_put_int((u_int)ws.ws_col);
		packet_put_int((u_int)ws.ws_xpixel);
		packet_put_int((u_int)ws.ws_ypixel);
d580 1
a580 1
client_process_net_input(fd_set *readset)
d688 1
a688 1
client_process_control(fd_set *readset)
d819 2
a820 1
	cctx = xcalloc(1, sizeof(*cctx));
d835 1
a835 1
		cctx->env = xcalloc(env_len + 1, sizeof(*cctx->env));
d1183 1
a1183 1
client_process_input(fd_set *readset)
d1236 1
a1236 1
client_process_output(fd_set *writeset)
d1880 4
a1883 4
		packet_put_int((u_int)ws.ws_col);
		packet_put_int((u_int)ws.ws_row);
		packet_put_int((u_int)ws.ws_xpixel);
		packet_put_int((u_int)ws.ws_ypixel);
@


1.1.1.9
log
@if we're gonna push out another snapshot, we'd better have sshd-current
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.163 2006/05/16 09:00:00 markus Exp $ */
d130 1
a130 1
static volatile sig_atomic_t quit_pending; /* Set non-zero to quit the loop. */
a842 1
	xfree(cmd);
@


1.1.1.10
log
@import a few security-wise relevant changes right now
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.175 2006/08/03 03:34:42 deraadt Exp $ */
d62 1
d64 1
a65 1
#include <sys/ioctl.h>
a66 3
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/param.h>
a68 1
#include <errno.h>
a70 3
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
a71 2
#include <pwd.h>
#include <unistd.h>
a72 1
#include "xmalloc.h"
d76 1
d82 2
a84 1
#include "cipher.h"
d924 3
a926 6
		logit("      -L[bind_address:]port:host:hostport    "
		    "Request local forward");
		logit("      -R[bind_address:]port:host:hostport    "
		    "Request remote forward");
		logit("      -KR[bind_address:]port                 "
		    "Cancel remote forward");
d929 1
a929 2
		logit("      !args                                  "
		    "Execute local command");
d990 1
a990 1
			if (channel_request_remote_forwarding(fwd.listen_host,
d992 1
a992 4
			    fwd.connect_port) < 0) {
				logit("Port forwarding failed.");
				goto out;
			}
@


1.1.1.11
log
@OpenSSH 4.5 (security)
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.176 2006/10/11 12:38:03 markus Exp $ */
d459 2
a460 4
	if (++server_alive_timeouts > options.server_alive_count_max) {
		logit("Timeout, server not responding.");
		cleanup_exit(255);
	}
@


1.1.1.12
log
@update OpenSSH, while we're at it…
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.177 2007/01/21 01:41:54 stevesk Exp $ */
d1752 1
a1752 1
	sock = ssh_get_authentication_socket();
@


1.1.1.13
log
@Import OpenSSH 4.6
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.178 2007/02/20 10:25:14 djm Exp $ */
d702 1
a702 1
	int client_fd, new_fd[3], ver, allowed, window, packetmax;
a894 7
	window = CHAN_SES_WINDOW_DEFAULT;
	packetmax = CHAN_SES_PACKET_DEFAULT;
	if (cctx->want_tty) {
		window >>= 1;
		packetmax >>= 1;
	}
	
d896 2
a897 1
	    new_fd[0], new_fd[1], new_fd[2], window, packetmax,
@


1.1.1.14
log
@import openbsd compress, ssh, perl, sendmail for minor bugfixes
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.179 2007/03/20 03:56:12 tedu Exp $ */
d930 1
a930 1
	while (isspace(*s))
d977 3
a979 2
	while (isspace(*++s))
		;
@


1.1.1.15
log
@OpenSSH 4.7+1
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.181 2007/08/15 08:14:46 markus Exp $ */
d285 13
a297 23

		/*
		 * When in untrusted mode, we read the cookie only if it was
		 * successfully generated as an untrusted one in the step
		 * above.
		 */
		if (trusted || generated) {
			snprintf(cmd, sizeof(cmd),
			    "%s %s%s list %s 2>" _PATH_DEVNULL,
			    xauth_path,
			    generated ? "-f " : "" ,
			    generated ? xauthfile : "",
			    display);
			debug2("x11_get_proto: %s", cmd);
			f = popen(cmd, "r");
			if (f && fgets(line, sizeof(line), f) &&
			    sscanf(line, "%*s %511s %511s", proto, data) == 2)
				got_data = 1;
			if (f)
				pclose(f);
		} else
			error("Warning: untrusted X11 forwarding setup failed: "
			    "xauth key data not generated");
a1767 38
int
client_request_tun_fwd(int tun_mode, int local_tun, int remote_tun)
{
	Channel *c;
	int fd;

	if (tun_mode == SSH_TUNMODE_NO)
		return 0;

	if (!compat20) {
		error("Tunnel forwarding is not support for protocol 1");
		return -1;
	}

	debug("Requesting tun unit %d in mode %d", local_tun, tun_mode);

	/* Open local tunnel device */
	if ((fd = tun_open(local_tun, tun_mode)) == -1) {
		error("Tunnel device open failed.");
		return -1;
	}

	c = channel_new("tun", SSH_CHANNEL_OPENING, fd, fd, -1,
	    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, "tun", 1);
	c->datagram = 1;

	packet_start(SSH2_MSG_CHANNEL_OPEN);
	packet_put_cstring("tun@@openssh.com");
	packet_put_int(c->self);
	packet_put_int(c->local_window_max);
	packet_put_int(c->local_maxpacket);
	packet_put_int(tun_mode);
	packet_put_int(remote_tun);
	packet_send();

	return 0;
}

@


1.1.1.16
log
@Import latest OpenSSH upgrades
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.182 2007/09/04 03:21:03 djm Exp $ */
d717 1
a717 1
	u_int i, j, len, env_len, command, flags;
d865 3
a867 16
	for(i = 0; i < 3; i++) {
		if ((new_fd[i] = mm_receive_fd(client_fd)) == -1) {
			error("%s: failed to receive fd %d from slave",
			    __func__, i);
			for (j = 0; j < i; j++)
				close(new_fd[j]);
			for (j = 0; j < env_len; j++)
				xfree(cctx->env[j]);
			if (env_len > 0)
				xfree(cctx->env);
			xfree(cctx->term);
			buffer_free(&cctx->cmd);
			xfree(cctx);
			return;
		}
	}
@


1.1.1.17
log
@newer openssh
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.188 2008/02/22 20:44:02 dtucker Exp $ */
d152 1
d462 1
a462 1
	keep_alive_timeouts = 0;
d469 1
a469 1
	if (++keep_alive_timeouts > options.server_alive_count_max) {
a876 1
			close(client_fd);
a947 3
	bzero(&fwd, sizeof(fwd));
	fwd.listen_host = fwd.connect_host = NULL;

a1046 4
	if (fwd.listen_host != NULL)
		xfree(fwd.listen_host);
	if (fwd.connect_host != NULL)
		xfree(fwd.connect_host);
d1727 1
a1727 1
	    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0,
d1785 1
a1785 1
	    CHAN_X11_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0,
@


1.1.1.18
log
@OpenSSH-current
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.207 2008/12/09 22:37:33 stevesk Exp $ */
a68 1
#include <sys/queue.h>
d101 1
d115 1
a115 1
extern int muxserver_sock;
d138 2
a139 2
static int escape_char1;	/* Escape character. (proto1 only) */
static int escape_pending1;	/* Last character was an escape (proto1 only) */
d141 2
a142 2
static int exit_status;		/* Used to store the command exit status. */
static int stdin_eof;		/* EOF has been encountered on stderr. */
d146 1
d156 9
a164 4
/* Track escape per proto2 channel */
struct escape_filter_ctx {
	int escape_pending;
	int escape_char;
a166 17
/* Context for channel confirmation replies */
struct channel_reply_ctx {
	const char *request_type;
	int id, do_close;
};

/* Global request success/failure callbacks */
struct global_confirm {
	TAILQ_ENTRY(global_confirm) entry;
	global_confirm_cb *cb;
	void *ctx;
	int ref_count;
};
TAILQ_HEAD(global_confirms, global_confirm);
static struct global_confirms global_confirms =
    TAILQ_HEAD_INITIALIZER(global_confirms);

d374 1
a374 4
			/*
			 * EOF.  Record that we have seen it and send
			 * EOF to server.
			 */
d385 2
a386 2
			if ((u_char) buf[0] == escape_char1)
				escape_pending1 = 1;
d416 1
a460 12
	struct global_confirm *gc;

	if ((gc = TAILQ_FIRST(&global_confirms)) == NULL)
		return;
	if (gc->cb != NULL)
		gc->cb(type, seq, gc->ctx);
	if (--gc->ref_count <= 0) {
		TAILQ_REMOVE(&global_confirms, gc, entry);
		bzero(gc, sizeof(*gc));
		xfree(gc);
	}

d462 1
a475 2
	/* Insert an empty placeholder to maintain ordering */
	client_register_global_confirm(NULL, NULL);
d527 2
a528 2
	if (muxserver_sock != -1)
		FD_SET(muxserver_sock, *readsetp);
d570 1
a570 2
		atomicio(vwrite, fileno(stdout), buffer_ptr(bout),
		    buffer_len(bout));
d572 1
a572 2
		atomicio(vwrite, fileno(stderr), buffer_ptr(berr),
		    buffer_len(berr));
d612 3
a614 7
			/*
			 * Received EOF.  The remote host has closed the
			 * connection.
			 */
			snprintf(buf, sizeof buf,
			    "Connection to %.300s closed by remote host.\r\n",
			    host);
d627 3
a629 7
			/*
			 * An error has encountered.  Perhaps there is a
			 * network problem.
			 */
			snprintf(buf, sizeof buf,
			    "Read from remote host %.300s: %.100s\r\n",
			    host, strerror(errno));
d639 1
a639 1
client_status_confirm(int type, Channel *c, void *ctx)
d641 16
a656 32
	struct channel_reply_ctx *cr = (struct channel_reply_ctx *)ctx;
	char errmsg[256];
	int tochan;

	/* XXX supress on mux _client_ quietmode */
	tochan = options.log_level >= SYSLOG_LEVEL_ERROR &&
	    c->ctl_fd != -1 && c->extended_usage == CHAN_EXTENDED_WRITE;

	if (type == SSH2_MSG_CHANNEL_SUCCESS) {
		debug2("%s request accepted on channel %d",
		    cr->request_type, c->self);
	} else if (type == SSH2_MSG_CHANNEL_FAILURE) {
		if (tochan) {
			snprintf(errmsg, sizeof(errmsg),
			    "%s request failed\r\n", cr->request_type);
		} else {
			snprintf(errmsg, sizeof(errmsg),
			    "%s request failed on channel %d",
			    cr->request_type, c->self);
		}
		/* If error occurred on primary session channel, then exit */
		if (cr->do_close && c->self == session_ident)
			fatal("%s", errmsg);
		/* If error occurred on mux client, append to their stderr */
		if (tochan)
			buffer_append(&c->extended, errmsg, strlen(errmsg));
		else
			error("%s", errmsg);
		if (cr->do_close) {
			chan_read_failed(c);
			chan_write_failed(c);
		}
a657 1
	xfree(cr);
d661 1
a661 1
client_abandon_status_confirm(Channel *c, void *ctx)
d663 41
a703 1
	xfree(ctx);
d707 1
a707 1
client_expect_confirm(int id, const char *request, int do_close)
d709 24
a732 1
	struct channel_reply_ctx *cr = xmalloc(sizeof(*cr));
d734 103
a836 2
	cr->request_type = request;
	cr->do_close = do_close;
d838 43
a880 3
	channel_register_status_confirm(id, client_status_confirm,
	    client_abandon_status_confirm, cr);
}
d882 2
a883 4
void
client_register_global_confirm(global_confirm_cb *cb, void *ctx)
{
	struct global_confirm *gc, *last_gc;
d885 19
a903 6
	/* Coalesce identical callbacks */
	last_gc = TAILQ_LAST(&global_confirms, global_confirms);
	if (last_gc && last_gc->cb == cb && last_gc->ctx == ctx) {
		if (++last_gc->ref_count >= INT_MAX)
			fatal("%s: last_gc->ref_count = %d",
			    __func__, last_gc->ref_count);
d906 25
d932 4
a935 5
	gc = xmalloc(sizeof(*gc));
	gc->cb = cb;
	gc->ctx = ctx;
	gc->ref_count = 1;
	TAILQ_INSERT_TAIL(&global_confirms, gc, entry);
d944 1
a944 1
	int local = 0, remote = 0, dynamic = 0;
a968 2
		logit("      -D[bind_address:]port                  "
		    "Request dynamic forward");
d988 1
a988 7
	if (*s == 'L')
		local = 1;
	else if (*s == 'R')
		remote = 1;
	else if (*s == 'D')
		dynamic = 1;
	else {
d992 3
a994 2

	if ((local || dynamic) && delete) {
d998 1
a998 1
	if (remote && delete && !compat20) {
d1022 1
a1022 1
		if (!parse_forward(&fwd, s, dynamic ? 1 : 0)) {
d1026 1
a1026 1
		if (local || dynamic) {
d1056 1
a1056 3
/* 
 * Process the characters one by one, call with c==NULL for proto1 case.
 */
d1058 1
a1058 2
process_escapes(Channel *c, Buffer *bin, Buffer *bout, Buffer *berr,
    char *buf, int len)
a1065 2
	int *escape_pendingp, escape_char;
	struct escape_filter_ctx *efc;
a1066 11
	if (c == NULL) {
		escape_pendingp = &escape_pending1;
		escape_char = escape_char1;
	} else {
		if (c->filter_ctx == NULL)
			return 0;
		efc = (struct escape_filter_ctx *)c->filter_ctx;
		escape_pendingp = &efc->escape_pending;
		escape_char = efc->escape_char;
	}
	
d1074 1
a1074 1
		if (*escape_pendingp) {
d1077 1
a1077 1
			*escape_pendingp = 0;
d1083 1
a1083 2
				snprintf(string, sizeof string, "%c.\r\n",
				    escape_char);
d1086 1
a1086 6
				if (c && c->ctl_fd != -1) {
					chan_read_failed(c);
					chan_write_failed(c);
					return 0;
				} else
					quit_pending = 1;
d1090 3
a1092 14
				/* XXX support this for mux clients */
				if (c && c->ctl_fd != -1) {
 noescape:
					snprintf(string, sizeof string,
					    "%c%c escape not available to "
					    "multiplexed sessions\r\n",
					    escape_char, ch);
					buffer_append(berr, string,
					    strlen(string));
					continue;
				}
				/* Suspend the program. Inform the user */
				snprintf(string, sizeof string,
				    "%c^Z [suspend ssh]\r\n", escape_char);
d1117 1
a1117 2
						logit("Server does not "
						    "support re-keying");
a1123 2
				if (c && c->ctl_fd != -1)
					goto noescape;
d1125 2
a1126 3
				 * Detach the program (continue to serve
				 * connections, but put in background and no
				 * more new connections).
d1155 3
a1157 3
					 * Sending SSH_CMSG_EOF alone does not
					 * always appear to be enough.  So we
					 * try to send an EOF character first.
d1172 1
a1172 2
				if (c && c->ctl_fd != -1) {
					snprintf(string, sizeof string,
d1175 9
a1183 6
  %c.  - terminate session\r\n\
  %cB  - send a BREAK to the remote system\r\n\
  %cR  - Request rekey (SSH protocol 2 only)\r\n\
  %c#  - list forwarded connections\r\n\
  %c?  - this message\r\n\
  %c%c  - send the escape character by typing it twice\r\n\
d1185 3
a1187 25
					    escape_char, escape_char,
					    escape_char, escape_char,
					    escape_char, escape_char,
					    escape_char, escape_char);
				} else {
					snprintf(string, sizeof string,
"%c?\r\n\
Supported escape sequences:\r\n\
  %c.  - terminate connection (and any multiplexed sessions)\r\n\
  %cB  - send a BREAK to the remote system\r\n\
  %cC  - open a command line\r\n\
  %cR  - Request rekey (SSH protocol 2 only)\r\n\
  %c^Z - suspend ssh\r\n\
  %c#  - list forwarded connections\r\n\
  %c&  - background ssh (when waiting for connections to terminate)\r\n\
  %c?  - this message\r\n\
  %c%c  - send the escape character by typing it twice\r\n\
(Note that escapes are only recognized immediately after newline.)\r\n",
					    escape_char, escape_char,
					    escape_char, escape_char,
					    escape_char, escape_char,
					    escape_char, escape_char,
					    escape_char, escape_char,
					    escape_char);
				}
d1192 1
a1192 2
				snprintf(string, sizeof string, "%c#\r\n",
				    escape_char);
a1199 2
				if (c && c->ctl_fd != -1)
					goto noescape;
d1213 2
a1214 2
			 * The previous character was not an escape char.
			 * Check if this is an escape.
d1217 2
a1218 5
				/*
				 * It is. Set the flag and continue to
				 * next character.
				 */
				*escape_pendingp = 1;
d1253 1
a1253 2
				snprintf(buf, sizeof buf, "read: %.100s\r\n",
				    strerror(errno));
d1269 1
a1269 1
		} else if (escape_char1 == SSH_ESCAPECHAR_NONE) {
d1277 2
a1278 3
			 * Normal, successful read.  But we have an escape
			 * character and have to process the characters one
			 * by one.
d1280 2
a1281 2
			if (process_escapes(NULL, &stdin_buffer,
			    &stdout_buffer, &stderr_buffer, buf, len) == -1)
d1306 1
a1306 2
				snprintf(buf, sizeof buf,
				    "write stdout: %.50s\r\n", strerror(errno));
d1314 1
d1325 1
a1325 4
				/*
				 * EOF or error, but can't even print
				 * error message.
				 */
d1332 1
d1351 1
a1351 2
	dispatch_run(DISPATCH_NONBLOCK, &quit_pending,
	    compat20 ? xxx_kex : NULL);
d1356 2
a1357 3
/* Helper: allocate a new escape_filter_ctx and fill in its escape char */
void *
client_new_escape_filter_ctx(int escape_char)
d1359 2
a1360 23
	struct escape_filter_ctx *ret;

	ret = xmalloc(sizeof(*ret));
	ret->escape_pending = 0;
	ret->escape_char = escape_char;
	return (void *)ret;
}

/* Free the escape filter context on channel free */
void
client_filter_cleanup(int cid, void *ctx)
{
	xfree(ctx);
}

int
client_simple_escape_filter(Channel *c, char *buf, int len)
{
	if (c->extended_usage != CHAN_EXTENDED_WRITE)
		return 0;

	return process_escapes(c, &c->input, &c->output, &c->extended,
	    buf, len);
a1383 1
	u_int64_t ibytes, obytes;
d1392 1
a1392 1
	escape_pending1 = 0;
d1400 2
a1401 2
	if (muxserver_sock != -1)
		max_fd = MAX(max_fd, muxserver_sock);
d1415 3
d1419 1
a1419 1
	escape_char1 = escape_char_arg;
d1447 1
a1447 1
		if (escape_char_arg != SSH_ESCAPECHAR_NONE)
d1449 1
a1449 3
			    client_simple_escape_filter, NULL,
			    client_filter_cleanup,
			    client_new_escape_filter_ctx(escape_char_arg));
d1521 1
a1521 4
		if (muxserver_sock != -1 &&FD_ISSET(muxserver_sock, readset)) {
			if (muxserver_accept_control())
				quit_pending = 1;
		}
d1536 1
a1536 4
		/*
		 * Send as much buffered packet data as possible to the
		 * sender.
		 */
d1581 1
a1581 2
		snprintf(buf, sizeof buf,
		    "Connection to %.64s closed.\r\n", host);
d1594 1
d1606 1
d1617 2
a1618 4
	packet_get_state(MODE_IN, NULL, NULL, NULL, &ibytes);
	packet_get_state(MODE_OUT, NULL, NULL, NULL, &obytes);
	verbose("Transferred: sent %llu, received %llu bytes, in %.1f seconds",
	    obytes, ibytes, total_time);
d1620 4
a1623 2
		verbose("Bytes per second: sent %.1f, received %.1f",
		    obytes / total_time, ibytes / total_time);
d1714 1
d1723 2
a1724 6
	debug("client_request_forwarded_tcpip: listen %s port %d, "
	    "originator %s port %d", listen_address, listen_port,
	    originator_address, originator_port);

	c = channel_connect_by_listen_address(listen_port,
	    "forwarded-tcpip", originator_address);
d1726 10
d1751 1
a1751 2
		error("Warning: this is probably a break-in attempt by a "
		    "malicious server.");
d1784 1
a1784 2
		error("Warning: this is probably a break-in attempt by a "
		    "malicious server.");
d1808 1
a1808 1
		error("Tunnel forwarding is not supported for protocol 1");
d1904 1
a1904 5
		error("client_input_channel_req: channel %d: "
		    "unknown channel", id);
	} else if (strcmp(rtype, "eow@@openssh.com") == 0) {
		packet_check_eom();
		chan_rcvd_eow(c);
d1922 1
a1922 1
		packet_put_int(c->remote_id);
d1949 2
a1950 1
    const char *term, struct termios *tiop, int in_fd, Buffer *cmd, char **env)
d1962 1
d1968 1
a1968 2
		channel_request_start(id, "pty-req", 1);
		client_expect_confirm(id, "PTY allocation", 0);
d1974 2
a1975 3
		if (tiop == NULL)
			tiop = get_saved_tio();
		tty_make_modes(-1, tiop);
d2023 8
a2030 4
			debug("Sending subsystem: %.*s",
			    len, (u_char*)buffer_ptr(cmd));
			channel_request_start(id, "subsystem", 1);
			client_expect_confirm(id, "subsystem", 1);
d2032 2
a2033 4
			debug("Sending command: %.*s",
			    len, (u_char*)buffer_ptr(cmd));
			channel_request_start(id, "exec", 1);
			client_expect_confirm(id, "exec", 1);
d2038 1
a2038 2
		channel_request_start(id, "shell", 1);
		client_expect_confirm(id, "shell", 1);
a2056 2
	dispatch_set(SSH2_MSG_CHANNEL_SUCCESS, &channel_input_status_confirm);
	dispatch_set(SSH2_MSG_CHANNEL_FAILURE, &channel_input_status_confirm);
a2065 1

a2084 1

a2091 1

d2109 1
a2109 1
	if (options.control_path != NULL && muxserver_sock != -1)
@


1.1.1.19
log
@OpenSSH 5.2, or so
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.209 2009/02/12 03:00:56 djm Exp $ */
d759 1
a759 1
	int cancel_port;
d837 1
a837 1
		if (cancel_port <= 0) {
d843 1
a843 1
		if (!parse_forward(&fwd, s, dynamic, remote)) {
d1629 1
a1629 1
	u_short listen_port, originator_port;
d1655 1
a1655 1
	u_short originator_port;
@


1.1.1.20
log
@Let’s play the version number game – OpenSSH 5.3-current
@
text
@d1 1
a1 1
/* $OpenBSD: clientloop.c,v 1.213 2009/07/05 19:28:33 stevesk Exp $ */
a103 1
#include "roaming.h"
d486 1
a486 1
	packet_set_alive_timeouts(0);
d492 1
a492 1
	if (packet_inc_alive_timeouts() > options.server_alive_count_max) {
d629 1
a629 1
	int len, cont = 0;
d638 2
a639 2
		len = roaming_read(connection_in, buf, sizeof(buf), &cont);
		if (len == 0 && cont == 0) {
a1466 8
	if (compat20) {
		packet_start(SSH2_MSG_DISCONNECT);
		packet_put_int(SSH2_DISCONNECT_BY_APPLICATION);
		packet_put_cstring("disconnected by user");
		packet_send();
		packet_write_wait();
	}

@


