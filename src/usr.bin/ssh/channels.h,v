head	1.2;
access;
symbols
	cvs-200910041320:1.1.1.12
	cvs-200903221200:1.1.1.12
	cvs-200812162015:1.1.1.11
	cvs-200804031830:1.1.1.10
	MIRBSD_10:1.1.1.10.0.2
	MIRBSD_10_BASE:1.1.1.10
	cvs-200803022030:1.1.1.10
	cvs-200709131337:1.1.1.10
	cvs-200709021830:1.1.1.10
	cvs-200708201200:1.1.1.10
	cvs-200706161500:1.1.1.10
	cvs-200705192215:1.1.1.9
	cvs-200704292000:1.1.1.9
	cvs-200703080900:1.1.1.9
	cvs-200701251600:1.1.1.9
	cvs-200612111600:1.1.1.9
	cvs-200611090230:1.1.1.9
	OPENBSD_4_0:1.1.1.9
	MIRBSD_9_BASE:1.1.1.8
	cvs-200606162342:1.1.1.8
	cvs-200606022000:1.1.1.8
	cvs-200604191000:1.1.1.8
	cvs-200602220045:1.1.1.7
	MIRBSD_8:1.1.1.6.0.2
	MIRBSD_8_BASE:1.1.1.6
	cvs-200512201942:1.1.1.6
	cvs-200511231930:1.1.1.5
	cvs-200507211800:1.1.1.4
	cvs-200506221550:1.1.1.3
	cvs-200505050030:1.1.1.2
	cvs-200504291700:1.1.1.2
	cvs-200504261445:1.1.1.2
	cvs-200504141900:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2009.10.04.14.29.03;	author tg;	state Exp;
branches;
next	1.1;
commitid	1004AC8B1276FC00211;

1.1
date	2005.02.05.17.29.52;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.29.52;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.14.19.33.23;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.06.22.15.56.24;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	181342b98a38fe99;

1.1.1.4
date	2005.07.21.21.00.25;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	560042e0092f571e;

1.1.1.5
date	2005.11.23.19.34.14;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	116a4384c4467ffc;

1.1.1.6
date	2005.12.20.19.43.43;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	10043A85EF81EF097CF;

1.1.1.7
date	2006.02.22.00.51.35;	author tg;	state Exp;
branches;
next	1.1.1.8;
commitid	10043FBB5A933C3BB9B;

1.1.1.8
date	2006.04.19.10.15.02;	author tg;	state Exp;
branches;
next	1.1.1.9;
commitid	10044460DB21E1F715C;

1.1.1.9
date	2006.09.20.19.06.48;	author tg;	state Exp;
branches;
next	1.1.1.10;
commitid	10045119150397FC669;

1.1.1.10
date	2007.06.16.15.11.12;	author tg;	state Exp;
branches;
next	1.1.1.11;
commitid	1004673FD85114A3F32;

1.1.1.11
date	2008.12.16.20.15.32;	author tg;	state Exp;
branches;
next	1.1.1.12;
commitid	10049480C7A2701F5C0;

1.1.1.12
date	2009.03.22.12.02.59;	author tg;	state Exp;
branches;
next	;
commitid	10049C6290649163EA3;


desc
@@


1.2
log
@• merge newer OpenSSH
• KNF in our diff – style(9)
• some const cleanliness (build with __CRAZY=Yes mostly)
@
text
@/* $MirOS$ */
/* $OpenBSD: channels.h,v 1.98 2009/02/12 03:00:56 djm Exp $ */

/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */
/*
 * Copyright (c) 1999, 2000, 2001, 2002 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef CHANNEL_H
#define CHANNEL_H

/* Definitions for channel types. */
#define SSH_CHANNEL_X11_LISTENER	1	/* Listening for inet X11 conn. */
#define SSH_CHANNEL_PORT_LISTENER	2	/* Listening on a port. */
#define SSH_CHANNEL_OPENING		3	/* waiting for confirmation */
#define SSH_CHANNEL_OPEN		4	/* normal open two-way channel */
#define SSH_CHANNEL_CLOSED		5	/* waiting for close confirmation */
#define SSH_CHANNEL_AUTH_SOCKET		6	/* authentication socket */
#define SSH_CHANNEL_X11_OPEN		7	/* reading first X11 packet */
#define SSH_CHANNEL_INPUT_DRAINING	8	/* sending remaining data to conn */
#define SSH_CHANNEL_OUTPUT_DRAINING	9	/* sending remaining data to app */
#define SSH_CHANNEL_LARVAL		10	/* larval session */
#define SSH_CHANNEL_RPORT_LISTENER	11	/* Listening to a R-style port  */
#define SSH_CHANNEL_CONNECTING		12
#define SSH_CHANNEL_DYNAMIC		13
#define SSH_CHANNEL_ZOMBIE		14	/* Almost dead. */
#define SSH_CHANNEL_MAX_TYPE		15

struct Channel;
typedef struct Channel Channel;

typedef void channel_callback_fn(int, void *);
typedef int channel_infilter_fn(struct Channel *, char *, int);
typedef void channel_filter_cleanup_fn(int, void *);
typedef u_char *channel_outfilter_fn(struct Channel *, u_char **, u_int *);

/* Channel success/failure callbacks */
typedef void channel_confirm_cb(int, struct Channel *, void *);
typedef void channel_confirm_abandon_cb(struct Channel *, void *);
struct channel_confirm {
	TAILQ_ENTRY(channel_confirm) entry;
	channel_confirm_cb *cb;
	channel_confirm_abandon_cb *abandon_cb;
	void *ctx;
};
TAILQ_HEAD(channel_confirms, channel_confirm);

/* Context for non-blocking connects */
struct channel_connect {
	char *host;
	int port;
	struct addrinfo *ai, *aitop;
};

struct Channel {
	int     type;		/* channel type/state */
	int     self;		/* my own channel identifier */
	int     remote_id;	/* channel identifier for remote peer */
	u_int   istate;		/* input from channel (state of receive half) */
	u_int   ostate;		/* output to channel  (state of transmit half) */
	int     flags;		/* close sent/rcvd */
	int     rfd;		/* read fd */
	int     wfd;		/* write fd */
	int     efd;		/* extended fd */
	int     sock;		/* sock fd */
	int     ctl_fd;		/* control fd (client sharing) */
	int     isatty;		/* rfd is a tty */
	int	client_tty;	/* (client) TTY has been requested */
	int     force_drain;	/* force close on iEOF */
	int     delayed;		/* fdset hack */
	Buffer  input;		/* data read from socket, to be sent over
				 * encrypted connection */
	Buffer  output;		/* data received over encrypted connection for
				 * send on socket */
	Buffer  extended;
	char    *path;
		/* path for unix domain sockets, or host name for forwards */
	int     listening_port;	/* port being listened for forwards */
	int     host_port;	/* remote port to connect for forwards */
	char   *remote_name;	/* remote hostname */

	u_int	remote_window;
	u_int	remote_maxpacket;
	u_int	local_window;
	u_int	local_window_max;
	u_int	local_consumed;
	u_int	local_maxpacket;
	int     extended_usage;
	int	single_connection;

	const char *ctype;	/* type */

	/* callback */
	channel_callback_fn	*open_confirm;
	void			*open_confirm_ctx;
	channel_callback_fn	*detach_user;
	int			detach_close;
	struct channel_confirms	status_confirms;

	/* filter */
	channel_infilter_fn	*input_filter;
	channel_outfilter_fn	*output_filter;
	void			*filter_ctx;
	channel_filter_cleanup_fn *filter_cleanup;

	/* keep boundaries */
	int     		datagram;

	/* non-blocking connect */
	struct channel_connect	connect_ctx;
};

#define CHAN_EXTENDED_IGNORE		0
#define CHAN_EXTENDED_READ		1
#define CHAN_EXTENDED_WRITE		2

/* default window/packet sizes for tcp/x11-fwd-channel */
#define CHAN_SES_PACKET_DEFAULT	(32*1024)
#define CHAN_SES_WINDOW_DEFAULT	(64*CHAN_SES_PACKET_DEFAULT)
#define CHAN_TCP_PACKET_DEFAULT	(32*1024)
#define CHAN_TCP_WINDOW_DEFAULT	(64*CHAN_TCP_PACKET_DEFAULT)
#define CHAN_X11_PACKET_DEFAULT	(16*1024)
#define CHAN_X11_WINDOW_DEFAULT	(4*CHAN_X11_PACKET_DEFAULT)

/* possible input states */
#define CHAN_INPUT_OPEN			0
#define CHAN_INPUT_WAIT_DRAIN		1
#define CHAN_INPUT_WAIT_OCLOSE		2
#define CHAN_INPUT_CLOSED		3

/* possible output states */
#define CHAN_OUTPUT_OPEN		0
#define CHAN_OUTPUT_WAIT_DRAIN		1
#define CHAN_OUTPUT_WAIT_IEOF		2
#define CHAN_OUTPUT_CLOSED		3

#define CHAN_CLOSE_SENT			0x01
#define CHAN_CLOSE_RCVD			0x02
#define CHAN_EOF_SENT			0x04
#define CHAN_EOF_RCVD			0x08

#define CHAN_RBUF	16*1024

/* check whether 'efd' is still in use */
#define CHANNEL_EFD_INPUT_ACTIVE(c) \
	(compat20 && c->extended_usage == CHAN_EXTENDED_READ && \
	(c->efd != -1 || \
	buffer_len(&c->extended) > 0))
#define CHANNEL_EFD_OUTPUT_ACTIVE(c) \
	(compat20 && c->extended_usage == CHAN_EXTENDED_WRITE && \
	c->efd != -1 && (!(c->flags & (CHAN_EOF_RCVD|CHAN_CLOSE_RCVD)) || \
	buffer_len(&c->extended) > 0))

/* channel management */

Channel	*channel_by_id(int);
Channel	*channel_lookup(int);
Channel *channel_new(const char *, int, int, int, int, u_int, u_int, int, const char *, int);
void	 channel_set_fds(int, int, int, int, int, int, int, u_int);
void	 channel_free(Channel *);
void	 channel_free_all(void);
void	 channel_stop_listening(void);

void	 channel_send_open(int);
void	 channel_request_start(int, const char *, int);
void	 channel_register_cleanup(int, channel_callback_fn *, int);
void	 channel_register_open_confirm(int, channel_callback_fn *, void *);
void	 channel_register_filter(int, channel_infilter_fn *,
    channel_outfilter_fn *, channel_filter_cleanup_fn *, void *);
void	 channel_register_status_confirm(int, channel_confirm_cb *,
    channel_confirm_abandon_cb *, void *);
void	 channel_cancel_cleanup(int);
int	 channel_close_fd(int *);
void	 channel_send_window_changes(void);

/* protocol handler */

void	 channel_input_close(int, u_int32_t, void *);
void	 channel_input_close_confirmation(int, u_int32_t, void *);
void	 channel_input_data(int, u_int32_t, void *);
void	 channel_input_extended_data(int, u_int32_t, void *);
void	 channel_input_ieof(int, u_int32_t, void *);
void	 channel_input_oclose(int, u_int32_t, void *);
void	 channel_input_open_confirmation(int, u_int32_t, void *);
void	 channel_input_open_failure(int, u_int32_t, void *);
void	 channel_input_port_open(int, u_int32_t, void *);
void	 channel_input_window_adjust(int, u_int32_t, void *);
void	 channel_input_status_confirm(int, u_int32_t, void *);

/* file descriptor handling (read/write) */

void	 channel_prepare_select(fd_set **, fd_set **, int *, u_int*, int);
void     channel_after_select(fd_set *, fd_set *);
void     channel_output_poll(void);

int      channel_not_very_much_buffered_data(void);
void     channel_close_all(void);
int      channel_still_open(void);
char	*channel_open_message(void);
int	 channel_find_open(void);

/* tcp forwarding */
void	 channel_set_af(int af);
void     channel_permit_all_opens(void);
void	 channel_add_permitted_opens(char *, int);
int	 channel_add_adm_permitted_opens(char *, int);
void	 channel_clear_permitted_opens(void);
void	 channel_clear_adm_permitted_opens(void);
void 	 channel_print_adm_permitted_opens(void);
int      channel_input_port_forward_request(int, int);
Channel	*channel_connect_to(const char *, u_short, const char *, const char *);
Channel	*channel_connect_by_listen_address(u_short, const char *, char *);
int	 channel_request_remote_forwarding(const char *, u_short,
	     const char *, u_short);
int	 channel_setup_local_fwd_listener(const char *, u_short,
	     const char *, u_short, int);
void	 channel_request_rforward_cancel(const char *host, u_short port);
int	 channel_setup_remote_fwd_listener(const char *, u_short, int *, int);
int	 channel_cancel_rport_listener(const char *, u_short);

/* x11 forwarding */

int	 x11_connect_display(void);
int	 x11_create_display_inet(int, int, int, u_int *, int **);
void     x11_input_open(int, u_int32_t, void *);
void	 x11_request_forwarding_with_spoofing(int, const char *, const char *,
	     const char *);
void	 deny_input_open(int, u_int32_t, void *);

/* agent forwarding */

void	 auth_request_forwarding(void);

/* channel close */

int	 chan_is_dead(Channel *, int);
void	 chan_mark_dead(Channel *);

/* channel events */

void	 chan_rcvd_oclose(Channel *);
void	 chan_rcvd_eow(Channel *);	/* SSH2-only */
void	 chan_read_failed(Channel *);
void	 chan_ibuf_empty(Channel *);

void	 chan_rcvd_ieof(Channel *);
void	 chan_write_failed(Channel *);
void	 chan_obuf_empty(Channel *);

#endif
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$OpenBSD: channels.h,v 1.75 2004/10/29 21:47:15 djm Exp $	*/
a41 2
#include "buffer.h"

a58 2
#define SSH_CHANNEL_PATH_LEN		256

d63 21
a83 1
typedef int channel_filter_fn(struct Channel *, char *, int);
d106 1
a106 1
	char    path[SSH_CHANNEL_PATH_LEN];
d121 1
a121 1
	char   *ctype;		/* type */
d124 2
a125 1
	channel_callback_fn	*confirm;
d127 2
a128 1
	void			*confirm_ctx;
d131 10
a140 1
	channel_filter_fn	*input_filter;
d149 1
a149 1
#define CHAN_SES_WINDOW_DEFAULT	(4*CHAN_SES_PACKET_DEFAULT)
d151 1
a151 1
#define CHAN_TCP_WINDOW_DEFAULT	(4*CHAN_TCP_PACKET_DEFAULT)
d172 2
d181 1
a181 1
	((c->efd != -1 && !(c->flags & (CHAN_EOF_RCVD|CHAN_CLOSE_RCVD))) || \
d186 1
d188 2
a189 2
Channel *channel_new(char *, int, int, int, int, u_int, u_int, int, char *, int);
void	 channel_set_fds(int, int, int, int, int, int, u_int);
d195 7
a201 4
void	 channel_request_start(int, char *, int);
void	 channel_register_cleanup(int, channel_callback_fn *);
void	 channel_register_confirm(int, channel_callback_fn *, void *);
void	 channel_register_filter(int, channel_filter_fn *);
d218 1
d236 1
d238 11
a248 7
void     channel_input_port_forward_request(int, int);
int	 channel_connect_to(const char *, u_short);
int	 channel_connect_by_listen_address(u_short);
void	 channel_request_remote_forwarding(u_short, const char *, u_short);
void	 channel_request_rforward_cancel(u_short port);
int	 channel_setup_local_fwd_listener(u_short, const char *, u_short, int);
int	 channel_setup_remote_fwd_listener(const char *, u_short, int);
d254 1
a254 1
int	 x11_create_display_inet(int, int, int, u_int *);
d256 2
a257 1
void	 x11_request_forwarding_with_spoofing(int, const char *, const char *);
d272 1
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@OpenSSH-current
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.76 2005/03/01 10:09:52 djm Exp $	*/
d205 3
a207 5
void	 channel_request_remote_forwarding(const char *, u_short,
	     const char *, u_short);
int	 channel_setup_local_fwd_listener(const char *, u_short,
	     const char *, u_short, int);
void	 channel_request_rforward_cancel(const char *host, u_short port);
@


1.1.1.3
log
@most current OpenSSH.com
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.77 2005/06/16 03:38:36 djm Exp $	*/
d218 1
a218 2
void	 x11_request_forwarding_with_spoofing(int, const char *, const char *,
	    const char *);
@


1.1.1.4
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.79 2005/07/17 06:49:04 djm Exp $	*/
d151 1
a151 1
	c->efd != -1 && (!(c->flags & (CHAN_EOF_RCVD|CHAN_CLOSE_RCVD)) || \
d216 1
a216 1
int	 x11_create_display_inet(int, int, int, u_int *, int **);
@


1.1.1.5
log
@Import current OpenSSH
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.80 2005/10/10 10:23:08 djm Exp $	*/
d108 1
a109 2
	channel_callback_fn	*detach_user;
	int			detach_close;
d165 1
a165 1
void	 channel_register_cleanup(int, channel_callback_fn *, int);
@


1.1.1.6
log
@OpenSSH is the last missing piece to update before the release
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.82 2005/12/12 13:46:18 markus Exp $	*/
a113 2

	int     datagram;	/* keep boundaries */
a156 1
Channel	*channel_by_id(int);
@


1.1.1.7
log
@import OpenSSH-current
@
text
@d1 1
a1 1
/*	$OpenBSD: channels.h,v 1.83 2005/12/30 15:56:37 reyk Exp $	*/
d66 1
a66 2
typedef int channel_infilter_fn(struct Channel *, char *, int);
typedef u_char *channel_outfilter_fn(struct Channel *, u_char **, u_int *);
d113 1
a113 2
	channel_infilter_fn	*input_filter;
	channel_outfilter_fn	*output_filter;
a146 2
#define CHAN_RBUF	16*1024

d171 1
a171 1
void	 channel_register_filter(int, channel_infilter_fn *, channel_outfilter_fn *);
@


1.1.1.8
log
@I decided we'd better upgrade OpenSSH before releasing to the general public
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.84 2006/03/25 22:22:42 djm Exp $ */
@


1.1.1.9
log
@import a few security-wise relevant changes right now
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.88 2006/08/03 03:34:42 deraadt Exp $ */
d41 2
a208 1
int	 channel_add_adm_permitted_opens(char *, int);
d210 1
a210 2
void	 channel_clear_adm_permitted_opens(void);
int      channel_input_port_forward_request(int, int);
d213 1
a213 1
int	 channel_request_remote_forwarding(const char *, u_short,
@


1.1.1.10
log
@Import latest OpenSSH and OpenBSD-libssl
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.89 2007/06/11 09:14:00 markus Exp $ */
d124 1
a124 1
#define CHAN_SES_WINDOW_DEFAULT	(64*CHAN_SES_PACKET_DEFAULT)
d126 1
a126 1
#define CHAN_TCP_WINDOW_DEFAULT	(64*CHAN_TCP_PACKET_DEFAULT)
@


1.1.1.11
log
@OpenSSH-current
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.96 2008/06/15 20:06:26 djm Exp $ */
a64 1
typedef void channel_filter_cleanup_fn(int, void *);
a66 18
/* Channel success/failure callbacks */
typedef void channel_confirm_cb(int, struct Channel *, void *);
typedef void channel_confirm_abandon_cb(struct Channel *, void *);
struct channel_confirm {
	TAILQ_ENTRY(channel_confirm) entry;
	channel_confirm_cb *cb;
	channel_confirm_abandon_cb *abandon_cb;
	void *ctx;
};
TAILQ_HEAD(channel_confirms, channel_confirm);

/* Context for non-blocking connects */
struct channel_connect {
	char *host;
	int port;
	struct addrinfo *ai, *aitop;
};

d106 2
a107 2
	channel_callback_fn	*open_confirm;
	void			*open_confirm_ctx;
a109 1
	struct channel_confirms	status_confirms;
a113 5
	void			*filter_ctx;
	channel_filter_cleanup_fn *filter_cleanup;

	/* keep boundaries */
	int     		datagram;
d115 1
a115 2
	/* non-blocking connect */
	struct channel_connect	connect_ctx;
d164 1
a164 1
void	 channel_set_fds(int, int, int, int, int, int, int, u_int);
d172 2
a173 5
void	 channel_register_open_confirm(int, channel_callback_fn *, void *);
void	 channel_register_filter(int, channel_infilter_fn *,
    channel_outfilter_fn *, channel_filter_cleanup_fn *, void *);
void	 channel_register_status_confirm(int, channel_confirm_cb *,
    channel_confirm_abandon_cb *, void *);
a189 1
void	 channel_input_status_confirm(int, u_int32_t, void *);
a209 1
void 	 channel_print_adm_permitted_opens(void);
d211 2
a212 2
Channel	*channel_connect_to(const char *, u_short, char *, char *);
Channel	*channel_connect_by_listen_address(u_short, char *, char *);
d227 1
a227 1
	     const char *);
a241 1
void	 chan_rcvd_eow(Channel *);	/* SSH2-only */
@


1.1.1.12
log
@OpenSSH 5.2, or so
@
text
@d1 1
a1 1
/* $OpenBSD: channels.h,v 1.98 2009/02/12 03:00:56 djm Exp $ */
d58 2
d107 1
a107 1
	char    *path;
d249 1
a249 1
int	 channel_setup_remote_fwd_listener(const char *, u_short, int *, int);
@


