head	1.18;
access;
symbols
	cvs-200910041320:1.1.1.17
	cvs-200903221200:1.1.1.16
	cvs-200812162015:1.1.1.16
	cvs-200804031830:1.1.1.15
	MIRBSD_10:1.12.0.2
	MIRBSD_10_BASE:1.12
	cvs-200803022030:1.1.1.15
	cvs-200709131337:1.1.1.14
	cvs-200709021830:1.1.1.13
	cvs-200708201200:1.1.1.12
	cvs-200706161500:1.1.1.12
	cvs-200705192215:1.1.1.12
	cvs-200704292000:1.1.1.12
	cvs-200703080900:1.1.1.12
	cvs-200701251600:1.1.1.12
	cvs-200612111600:1.1.1.12
	cvs-200611090230:1.1.1.12
	OPENBSD_4_0:1.1.1.11
	MIRBSD_9_BASE:1.7
	cvs-200606162342:1.1.1.10
	cvs-200606022000:1.1.1.9
	cvs-200604191000:1.1.1.8
	cvs-200602220045:1.1.1.7
	MIRBSD_8:1.1.1.6.0.2
	MIRBSD_8_BASE:1.1.1.6
	cvs-200512201942:1.1.1.6
	cvs-200511231930:1.1.1.5
	cvs-200507211800:1.1.1.4
	cvs-200506221550:1.1.1.3
	cvs-200505050030:1.1.1.2
	cvs-200504291700:1.1.1.2
	cvs-200504261445:1.1.1.2
	cvs-200504141900:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2016.01.14.19.23.04;	author tg;	state Exp;
branches;
next	1.17;
commitid	1005697F5AA3EA7E36D;

1.17
date	2009.10.04.16.35.26;	author tg;	state Exp;
branches;
next	1.16;
commitid	1004AC8CEBF3796541F;

1.16
date	2009.10.04.14.29.11;	author tg;	state Exp;
branches;
next	1.15;
commitid	1004AC8B1276FC00211;

1.15
date	2008.12.27.21.17.59;	author tg;	state Exp;
branches;
next	1.14;
commitid	10049569B9439744217;

1.14
date	2008.12.16.22.13.31;	author tg;	state Exp;
branches;
next	1.13;
commitid	10049482819766381ED;

1.13
date	2008.12.16.20.55.31;	author tg;	state Exp;
branches;
next	1.12;
commitid	100494815C97ECEEDBF;

1.12
date	2008.03.02.21.14.23;	author tg;	state Exp;
branches;
next	1.11;
commitid	10047CB18BB506A8527;

1.11
date	2007.09.13.13.52.56;	author tg;	state Exp;
branches;
next	1.10;
commitid	10046E940B668DE9A0B;

1.10
date	2007.09.02.18.53.13;	author tg;	state Exp;
branches;
next	1.9;
commitid	10046DB06AF681AF68C;

1.9
date	2006.10.13.18.40.51;	author tg;	state Exp;
branches;
next	1.8;
commitid	100452FDDB7190872BF;

1.8
date	2006.09.20.21.41.06;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004511B578580E7F04;

1.7
date	2006.06.16.23.47.09;	author tg;	state Exp;
branches;
next	1.6;
commitid	100449343131498EA29;

1.6
date	2006.06.02.20.50.52;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004480A4952B0D84EA;

1.5
date	2006.04.19.10.40.56;	author tg;	state Exp;
branches;
next	1.4;
commitid	100444613BD3A91C28B;

1.4
date	2006.02.22.01.23.52;	author tg;	state Exp;
branches;
next	1.3;
commitid	10043FBBD2C2C5E7D81;

1.3
date	2006.02.21.02.08.42;	author tg;	state Exp;
branches;
next	1.2;
commitid	10043FA75E13B619DFC;

1.2
date	2006.02.20.23.38.27;	author tg;	state Exp;
branches;
next	1.1;
commitid	10043FA52B07B46738A;

1.1
date	2005.02.05.17.29.55;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.29.55;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.14.19.33.31;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.06.22.15.56.28;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	181342b98a38fe99;

1.1.1.4
date	2005.07.21.21.00.35;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	560042e0092f571e;

1.1.1.5
date	2005.11.23.19.34.15;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	116a4384c4467ffc;

1.1.1.6
date	2005.12.20.19.43.46;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	10043A85EF81EF097CF;

1.1.1.7
date	2006.02.22.00.51.36;	author tg;	state Exp;
branches;
next	1.1.1.8;
commitid	10043FBB5A933C3BB9B;

1.1.1.8
date	2006.04.19.10.15.05;	author tg;	state Exp;
branches;
next	1.1.1.9;
commitid	10044460DB21E1F715C;

1.1.1.9
date	2006.06.02.20.31.52;	author tg;	state Exp;
branches;
next	1.1.1.10;
commitid	1004480A0422110D712;

1.1.1.10
date	2006.06.16.23.45.14;	author tg;	state Exp;
branches;
next	1.1.1.11;
commitid	100449342952F660974;

1.1.1.11
date	2006.09.20.19.06.50;	author tg;	state Exp;
branches;
next	1.1.1.12;
commitid	10045119150397FC669;

1.1.1.12
date	2006.11.09.02.38.02;	author tg;	state Exp;
branches;
next	1.1.1.13;
commitid	100455294981A6201C8;

1.1.1.13
date	2007.09.02.18.48.05;	author tg;	state Exp;
branches;
next	1.1.1.14;
commitid	10046DB0574023300F5;

1.1.1.14
date	2007.09.13.13.39.08;	author tg;	state Exp;
branches;
next	1.1.1.15;
commitid	10046E93D7724AAC1F8;

1.1.1.15
date	2008.03.02.20.40.42;	author tg;	state Exp;
branches;
next	1.1.1.16;
commitid	10047CB10DD30FAF062;

1.1.1.16
date	2008.12.16.20.15.34;	author tg;	state Exp;
branches;
next	1.1.1.17;
commitid	10049480C7A2701F5C0;

1.1.1.17
date	2009.10.04.13.25.45;	author tg;	state Exp;
branches;
next	;
commitid	1004AC8A2663BC008C5;


desc
@@


1.18
log
@drop roaming code completely
@
text
@/* $OpenBSD: sshconnect.c,v 1.214 2009/05/28 16:50:16 andreas Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * Code to connect to a remote host, and to perform the client side of the
 * login (authentication) dialog.
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */

#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/time.h>

#include <netinet/in.h>

#include <ctype.h>
#include <errno.h>
#include <netdb.h>
#include <paths.h>
#include <signal.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "xmalloc.h"
#include "ssh.h"
#include "rsa.h"
#include "buffer.h"
#include "packet.h"
#include "uidswap.h"
#include "compat.h"
#include "key.h"
#include "sshconnect.h"
#include "hostfile.h"
#include "log.h"
#include "readconf.h"
#include "atomicio.h"
#include "misc.h"
#include "dns.h"
#include "version.h"

__RCSID("$MirOS: src/usr.bin/ssh/sshconnect.c,v 1.17 2009/10/04 16:35:26 tg Exp $");

char *client_version_string = NULL;
char *server_version_string = NULL;

static int matching_host_key_dns = 0;

/* import */
extern Options options;
extern char *__progname;
extern uid_t original_real_uid;
extern uid_t original_effective_uid;
extern pid_t proxy_command_pid;

static int show_other_keys(const char *, Key *);
static void warn_changed_key(Key *);

/*
 * Connect to the given ssh server using a proxy command.
 */
static int
ssh_proxy_connect(const char *host, u_short port, const char *proxy_command)
{
	char *command_string, *tmp;
	int pin[2], pout[2];
	pid_t pid;
	char *shell, strport[NI_MAXSERV];

	if ((shell = getenv("SHELL")) == NULL)
		shell = (char *)_PATH_BSHELL;

	/* Convert the port number into a string. */
	snprintf(strport, sizeof strport, "%hu", port);

	/*
	 * Build the final command string in the buffer by making the
	 * appropriate substitutions to the given proxy command.
	 *
	 * Use "exec" to avoid "sh -c" processes on some platforms
	 * (e.g. Solaris)
	 */
	xasprintf(&tmp, "exec %s", proxy_command);
	command_string = percent_expand(tmp, "h", host,
	    "p", strport, (char *)NULL);
	xfree(tmp);

	/* Create pipes for communicating with the proxy. */
	if (pipe(pin) < 0 || pipe(pout) < 0)
		fatal("Could not create pipes to communicate with the proxy: %.100s",
		    strerror(errno));

	debug("Executing proxy command: %.500s", command_string);

	/* Fork and execute the proxy command. */
	if ((pid = fork()) == 0) {
		char *argv[10];

		/* Child.  Permanently give up superuser privileges. */
		permanently_drop_suid(original_real_uid);

		/* Redirect stdin and stdout. */
		close(pin[1]);
		if (pin[0] != 0) {
			if (dup2(pin[0], 0) < 0)
				perror("dup2 stdin");
			close(pin[0]);
		}
		close(pout[0]);
		if (dup2(pout[1], 1) < 0)
			perror("dup2 stdout");
		/* Cannot be 1 because pin allocated two descriptors. */
		close(pout[1]);

		/* Stderr is left as it is so that error messages get
		   printed on the user's terminal. */
		argv[0] = shell;
		argv[1] = (char *)"-c";
		argv[2] = command_string;
		argv[3] = NULL;

		/* Execute the proxy command.  Note that we gave up any
		   extra privileges above. */
		execv(argv[0], argv);
		perror(argv[0]);
		exit(1);
	}
	/* Parent. */
	if (pid < 0)
		fatal("fork failed: %.100s", strerror(errno));
	else
		proxy_command_pid = pid; /* save pid to clean up later */

	/* Close child side of the descriptors. */
	close(pin[0]);
	close(pout[1]);

	/* Free the command name. */
	xfree(command_string);

	/* Set the connection file descriptors. */
	packet_set_connection(pout[0], pin[1]);
	packet_set_timeout(options.server_alive_interval,
	    options.server_alive_count_max);

	/* Indicate OK return */
	return 0;
}

/*
 * Creates a (possibly privileged) socket for use as the ssh connection.
 */
static int
ssh_create_socket(int privileged, struct addrinfo *ai)
{
	int sock, gaierr;
	struct addrinfo hints, *res;

	/*
	 * If we are running as root and want to connect to a privileged
	 * port, bind our own socket to a privileged port.
	 */
	if (privileged) {
		int p = IPPORT_RESERVED - 1;
		PRIV_START;
		sock = rresvport_af(&p, ai->ai_family);
		PRIV_END;
		if (sock < 0)
			error("rresvport: af=%d %.100s", ai->ai_family,
			    strerror(errno));
		else
			debug("Allocated local port %d.", p);
		return sock;
	}
	sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
	if (sock < 0)
		error("socket: %.100s", strerror(errno));

	/* Bind the socket to an alternative local IP address */
	if (options.bind_address == NULL)
		return sock;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = ai->ai_family;
	hints.ai_socktype = ai->ai_socktype;
	hints.ai_protocol = ai->ai_protocol;
	hints.ai_flags = AI_PASSIVE;
	gaierr = getaddrinfo(options.bind_address, NULL, &hints, &res);
	if (gaierr) {
		error("getaddrinfo: %s: %s", options.bind_address,
		    ssh_gai_strerror(gaierr));
		close(sock);
		return -1;
	}
	if (bind(sock, res->ai_addr, res->ai_addrlen) < 0) {
		error("bind: %s: %s", options.bind_address, strerror(errno));
		close(sock);
		freeaddrinfo(res);
		return -1;
	}
	freeaddrinfo(res);
	return sock;
}

static int
timeout_connect(int sockfd, const struct sockaddr *serv_addr,
    socklen_t addrlen, int *timeoutp)
{
	fd_set *fdset;
	struct timeval tv, t_start;
	socklen_t optlen;
	int optval, rc, result = -1;

	gettimeofday(&t_start, NULL);

	if (*timeoutp <= 0) {
		result = connect(sockfd, serv_addr, addrlen);
		goto done;
	}

	set_nonblock(sockfd);
	rc = connect(sockfd, serv_addr, addrlen);
	if (rc == 0) {
		unset_nonblock(sockfd);
		result = 0;
		goto done;
	}
	if (errno != EINPROGRESS) {
		result = -1;
		goto done;
	}

	fdset = (fd_set *)xcalloc(howmany(sockfd + 1, NFDBITS),
	    sizeof(fd_mask));
	FD_SET(sockfd, fdset);
	ms_to_timeval(&tv, *timeoutp);

	for (;;) {
		rc = select(sockfd + 1, NULL, fdset, NULL, &tv);
		if (rc != -1 || errno != EINTR)
			break;
	}

	switch (rc) {
	case 0:
		/* Timed out */
		errno = ETIMEDOUT;
		break;
	case -1:
		/* Select error */
		debug("select: %s", strerror(errno));
		break;
	case 1:
		/* Completed or failed */
		optval = 0;
		optlen = sizeof(optval);
		if (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &optval,
		    &optlen) == -1) {
			debug("getsockopt: %s", strerror(errno));
			break;
		}
		if (optval != 0) {
			errno = optval;
			break;
		}
		result = 0;
		unset_nonblock(sockfd);
		break;
	default:
		/* Should not occur */
		fatal("Bogus return (%d) from select()", rc);
	}

	xfree(fdset);

 done:
 	if (result == 0 && *timeoutp > 0) {
		ms_subtract_diff(&t_start, timeoutp);
		if (*timeoutp <= 0) {
			errno = ETIMEDOUT;
			result = -1;
		}
	}

	return (result);
}

/*
 * Opens a TCP/IP connection to the remote server on the given host.
 * The address of the remote host will be returned in hostaddr.
 * If port is 0, the default port will be used.  If needpriv is true,
 * a privileged port will be allocated to make the connection.
 * This requires super-user privileges if needpriv is true.
 * Connection_attempts specifies the maximum number of tries (one per
 * second).  If proxy_command is non-NULL, it specifies the command (with %h
 * and %p substituted for host and port, respectively) to use to contact
 * the daemon.
 */
int
ssh_connect(const char *host, struct sockaddr_storage * hostaddr,
    u_short port, int family, int connection_attempts, int *timeout_ms,
    int want_keepalive, int needpriv, const char *proxy_command)
{
	int gaierr;
	int on = 1;
	int sock = -1, attempt;
	char ntop[NI_MAXHOST], strport[NI_MAXSERV];
	struct addrinfo hints, *ai, *aitop;

	debug2("ssh_connect: needpriv %d", needpriv);

	/* If a proxy command is given, connect using it. */
	if (proxy_command != NULL)
		return ssh_proxy_connect(host, port, proxy_command);

	/* No proxy command. */

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = family;
	hints.ai_socktype = SOCK_STREAM;
	snprintf(strport, sizeof strport, "%u", port);
	if ((gaierr = getaddrinfo(host, strport, &hints, &aitop)) != 0)
		fatal("%s: Could not resolve hostname %.100s: %s", __progname,
		    host, ssh_gai_strerror(gaierr));

	for (attempt = 0; attempt < connection_attempts; attempt++) {
		if (attempt > 0) {
			/* Sleep a moment before retrying. */
			sleep(1);
			debug("Trying again...");
		}
		/*
		 * Loop through addresses for this host, and try each one in
		 * sequence until the connection succeeds.
		 */
		for (ai = aitop; ai; ai = ai->ai_next) {
			if (ai->ai_family != AF_INET && ai->ai_family != AF_INET6)
				continue;
			if (getnameinfo(ai->ai_addr, ai->ai_addrlen,
			    ntop, sizeof(ntop), strport, sizeof(strport),
			    NI_NUMERICHOST|NI_NUMERICSERV) != 0) {
				error("ssh_connect: getnameinfo failed");
				continue;
			}
			debug("Connecting to %.200s [%.100s] port %s.",
				host, ntop, strport);

			/* Create a socket for connecting. */
			sock = ssh_create_socket(needpriv, ai);
			if (sock < 0)
				/* Any error is already output */
				continue;

			if (timeout_connect(sock, ai->ai_addr, ai->ai_addrlen,
			    timeout_ms) >= 0) {
				/* Successful connection. */
				memcpy(hostaddr, ai->ai_addr, ai->ai_addrlen);
				break;
			} else {
				debug("connect to address %s port %s: %s",
				    ntop, strport, strerror(errno));
				close(sock);
				sock = -1;
			}
		}
		if (sock != -1)
			break;	/* Successful connection. */
	}

	freeaddrinfo(aitop);

	/* Return failure if we didn't get a successful connection. */
	if (sock == -1) {
		error("ssh: connect to host %s port %s: %s",
		    host, strport, strerror(errno));
		return (-1);
	}

	debug("Connection established.");

	/* Set SO_KEEPALIVE if requested. */
	if (want_keepalive &&
	    setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, (void *)&on,
	    sizeof(on)) < 0)
		error("setsockopt SO_KEEPALIVE: %.100s", strerror(errno));

	/* Set the connection. */
	packet_set_connection(sock, sock);
	packet_set_timeout(options.server_alive_interval,
	    options.server_alive_count_max);

	return 0;
}

/*
 * Waits for the server identification string, and sends our own
 * identification string.
 */
void
ssh_exchange_identification(int timeout_ms)
{
	char buf[256], remote_version[256];	/* must be same size! */
	int remote_major, remote_minor, mismatch;
	int connection_in = packet_get_connection_in();
	int connection_out = packet_get_connection_out();
	int minor1 = PROTOCOL_MINOR_1;
	u_int i, n;
	size_t len;
	int fdsetsz, remaining, rc;
	struct timeval t_start, t_remaining;
	fd_set *fdset;

	fdsetsz = howmany(connection_in + 1, NFDBITS) * sizeof(fd_mask);
	fdset = xcalloc(1, fdsetsz);

	/* Read other side's version identification. */
	remaining = timeout_ms;
	for (n = 0;;) {
		for (i = 0; i < sizeof(buf) - 1; i++) {
			if (timeout_ms > 0) {
				gettimeofday(&t_start, NULL);
				ms_to_timeval(&t_remaining, remaining);
				FD_SET(connection_in, fdset);
				rc = select(connection_in + 1, fdset, NULL,
				    fdset, &t_remaining);
				ms_subtract_diff(&t_start, &remaining);
				if (rc == 0 || remaining <= 0)
					fatal("Connection timed out during "
					    "banner exchange");
				if (rc == -1) {
					if (errno == EINTR)
						continue;
					fatal("ssh_exchange_identification: "
					    "select: %s", strerror(errno));
				}
			}

			len = atomicio(read, connection_in, &buf[i], 1);

			if (len != 1 && errno == EPIPE)
				fatal("ssh_exchange_identification: "
				    "Connection closed by remote host");
			else if (len != 1)
				fatal("ssh_exchange_identification: "
				    "read: %.100s", strerror(errno));
			if (buf[i] == '\r') {
				buf[i] = '\n';
				buf[i + 1] = 0;
				continue;		/**XXX wait for \n */
			}
			if (buf[i] == '\n') {
				buf[i + 1] = 0;
				break;
			}
			if (++n > 65536)
				fatal("ssh_exchange_identification: "
				    "No banner received");
		}
		buf[sizeof(buf) - 1] = 0;
		if (strncmp(buf, "SSH-", 4) == 0)
			break;
		debug("ssh_exchange_identification: %s", buf);
	}
	server_version_string = xstrdup(buf);
	xfree(fdset);

	/*
	 * Check that the versions match.  In future this might accept
	 * several versions and set appropriate flags to handle them.
	 */
	if (sscanf(server_version_string, "SSH-%d.%d-%[^\n]\n",
	    &remote_major, &remote_minor, remote_version) != 3)
		fatal("Bad remote protocol version identification: '%.100s'", buf);
	debug("Remote protocol version %d.%d, remote software version %.100s",
	    remote_major, remote_minor, remote_version);

	compat_datafellows(remote_version);
	mismatch = 0;

	switch (remote_major) {
	case 1:
		if (remote_minor == 99 &&
		    (options.protocol & SSH_PROTO_2) &&
		    !(options.protocol & SSH_PROTO_1_PREFERRED)) {
			enable_compat20();
			break;
		}
		if (!(options.protocol & SSH_PROTO_1)) {
			mismatch = 1;
			break;
		}
		if (remote_minor < 3) {
			fatal("Remote machine has too old SSH software version.");
		} else if (remote_minor == 3 || remote_minor == 4) {
			/* We speak 1.3, too. */
			enable_compat13();
			minor1 = 3;
			if (options.forward_agent) {
				logit("Agent forwarding disabled for protocol 1.3");
				options.forward_agent = 0;
			}
		}
		break;
	case 2:
		if (options.protocol & SSH_PROTO_2) {
			enable_compat20();
			break;
		}
		/* FALLTHROUGH */
	default:
		mismatch = 1;
		break;
	}
	if (mismatch)
		fatal("Protocol major versions differ: %d vs. %d",
		    (options.protocol & SSH_PROTO_2) ? PROTOCOL_MAJOR_2 : PROTOCOL_MAJOR_1,
		    remote_major);
	/* Send our own protocol version identification. */
	snprintf(buf, sizeof buf, "SSH-%d.%d-%.100s %u%s",
	    compat20 ? PROTOCOL_MAJOR_2 : PROTOCOL_MAJOR_1,
	    compat20 ? PROTOCOL_MINOR_2 : minor1,
	    SSH_VERSION, (unsigned)(arc4random() & 0xFFFF),
	    compat20 ? "\r\n" : "\n");
	if (atomicio(vwrite, connection_out, buf, strlen(buf)) != strlen(buf))
		fatal("write: %.100s", strerror(errno));
	client_version_string = xstrdup(buf);
	chop(client_version_string);
	chop(server_version_string);
	debug("Local version string %.100s", client_version_string);
}

/* defaults to 'no' */
static int
confirm(const char *prompt)
{
	const char *msg, *again = "Please type 'yes' or 'no': ";
	char *p;
	int ret = -1;

	if (options.batch_mode)
		return 0;
	for (msg = prompt;;msg = again) {
		p = read_passphrase(msg, RP_ECHO);
		if (p == NULL ||
		    (p[0] == '\0') || (p[0] == '\n') ||
		    strncasecmp(p, "no", 2) == 0)
			ret = 0;
		if (p && strncasecmp(p, "yes", 3) == 0)
			ret = 1;
		if (p)
			xfree(p);
		if (ret != -1)
			return ret;
	}
}

/*
 * check whether the supplied host key is valid, return -1 if the key
 * is not valid. the user_hostfile will not be updated if 'readonly' is true.
 */
#define RDRW	0
#define RDONLY	1
#define ROQUIET	2
static int
check_host_key(char *hostname, struct sockaddr *hostaddr, u_short port,
    Key *host_key, int readonly, const char *user_hostfile,
    const char *system_hostfile)
{
	Key *file_key;
	const char *type = key_type(host_key);
	char *ip = NULL, *host = NULL;
	char hostline[1000], *hostp, *fp, *ra;
	HostStatus host_status;
	HostStatus ip_status;
	int r, local = 0, host_ip_differ = 0;
	char ntop[NI_MAXHOST];
	char msg[1024];
	int len, host_line, ip_line, cancelled_forwarding = 0;
	const char *host_file = NULL, *ip_file = NULL;
	struct sockaddr_storage ss;

	/*
	 * Force accepting of the host key for loopback/localhost. The
	 * problem is that if the home directory is NFS-mounted to multiple
	 * machines, localhost will refer to a different machine in each of
	 * them, and the user will get bogus HOST_CHANGED warnings.  This
	 * essentially disables host authentication for localhost; however,
	 * this is probably not a real problem.
	 */
	/**  hostaddr == 0! */
	switch (hostaddr->sa_family) {
	case AF_INET:
		memcpy(&ss, hostaddr, sizeof(struct sockaddr_in));
		local = (ntohl(((struct sockaddr_in *)&ss)->
		    sin_addr.s_addr) >> 24) == IN_LOOPBACKNET;
		break;
	case AF_INET6:
		memcpy(&ss, hostaddr, sizeof(struct sockaddr_in6));
		local = IN6_IS_ADDR_LOOPBACK(
		    &(((struct sockaddr_in6 *)&ss)->sin6_addr));
		break;
	default:
		local = 0;
		break;
	}
	if (options.no_host_authentication_for_localhost == 1 && local &&
	    options.host_key_alias == NULL) {
		debug("Forcing accepting of host key for "
		    "loopback/localhost.");
		return 0;
	}

	/*
	 * We don't have the remote ip-address for connections
	 * using a proxy command
	 */
	if (options.proxy_command == NULL) {
		if (getnameinfo(hostaddr, hostaddr->sa_len, ntop, sizeof(ntop),
		    NULL, 0, NI_NUMERICHOST) != 0)
			fatal("check_host_key: getnameinfo failed");
		ip = put_host_port(ntop, port);
	} else {
		ip = xstrdup("<no hostip for proxy command>");
	}

	/*
	 * Turn off check_host_ip if the connection is to localhost, via proxy
	 * command or if we don't have a hostname to compare with
	 */
	if (options.check_host_ip && (local ||
	    strcmp(hostname, ip) == 0 || options.proxy_command != NULL))
		options.check_host_ip = 0;

	/*
	 * Allow the user to record the key under a different name or
	 * differentiate a non-standard port.  This is useful for ssh
	 * tunneling over forwarded connections or if you run multiple
	 * sshd's on different ports on the same machine.
	 */
	if (options.host_key_alias != NULL) {
		host = xstrdup(options.host_key_alias);
		debug("using hostkeyalias: %s", host);
	} else {
		host = put_host_port(hostname, port);
	}

	/*
	 * Store the host key from the known host file in here so that we can
	 * compare it with the key for the IP address.
	 */
	file_key = key_new(host_key->type);

	/*
	 * Check if the host key is present in the user's list of known
	 * hosts or in the systemwide list.
	 */
	host_file = user_hostfile;
	host_status = check_host_in_hostfile(host_file, host, host_key,
	    file_key, &host_line);
	if (host_status == HOST_NEW) {
		host_file = system_hostfile;
		host_status = check_host_in_hostfile(host_file, host, host_key,
		    file_key, &host_line);
	}
	/*
	 * Also perform check for the ip address, skip the check if we are
	 * localhost or the hostname was an ip address to begin with
	 */
	if (options.check_host_ip) {
		Key *ip_key = key_new(host_key->type);

		ip_file = user_hostfile;
		ip_status = check_host_in_hostfile(ip_file, ip, host_key,
		    ip_key, &ip_line);
		if (ip_status == HOST_NEW) {
			ip_file = system_hostfile;
			ip_status = check_host_in_hostfile(ip_file, ip,
			    host_key, ip_key, &ip_line);
		}
		if (host_status == HOST_CHANGED &&
		    (ip_status != HOST_CHANGED || !key_equal(ip_key, file_key)))
			host_ip_differ = 1;

		key_free(ip_key);
	} else
		ip_status = host_status;

	key_free(file_key);

	switch (host_status) {
	case HOST_OK:
		/* The host is known and the key matches. */
		debug("Host '%.200s' is known and matches the %s host key.",
		    host, type);
		debug("Found key in %s:%d", host_file, host_line);
		if (options.check_host_ip && ip_status == HOST_NEW) {
			if (readonly)
				logit("%s host key for IP address "
				    "'%.128s' not in list of known hosts.",
				    type, ip);
			else if (!add_host_to_hostfile(user_hostfile, ip,
			    host_key, options.hash_known_hosts))
				logit("Failed to add the %s host key for IP "
				    "address '%.128s' to the list of known "
				    "hosts (%.30s).", type, ip, user_hostfile);
			else
				logit("Warning: Permanently added the %s host "
				    "key for IP address '%.128s' to the list "
				    "of known hosts.", type, ip);
		} else if (options.visual_host_key) {
			fp = key_fingerprint(host_key, SSH_FP_MD5, SSH_FP_HEX);
			ra = key_fingerprint(host_key, SSH_FP_MD5,
			    SSH_FP_RANDOMART);
			logit("Host key fingerprint is %s\n%s\n", fp, ra);
			xfree(ra);
			xfree(fp);
		}
		break;
	case HOST_NEW:
		if (options.host_key_alias == NULL && port != 0 &&
		    port != SSH_DEFAULT_PORT) {
			debug("checking without port identifier");
			if (check_host_key(hostname, hostaddr, 0, host_key,
			    ROQUIET, user_hostfile, system_hostfile) == 0) {
				debug("found matching key w/out port");
				break;
			}
		}
		if (readonly)
			goto fail;
		/* The host is new. */
		if (options.strict_host_key_checking == 1) {
			/*
			 * User has requested strict host key checking.  We
			 * will not add the host key automatically.  The only
			 * alternative left is to abort.
			 */
			error("No %s host key is known for %.200s and you "
			    "have requested strict checking.", type, host);
			goto fail;
		} else if (options.strict_host_key_checking == 2) {
			char msg1[1024], msg2[1024];

			if (show_other_keys(host, host_key))
				snprintf(msg1, sizeof(msg1),
				    "\nbut keys of different type are already"
				    " known for this host.");
			else
				snprintf(msg1, sizeof(msg1), ".");
			/* The default */
			fp = key_fingerprint(host_key, SSH_FP_MD5, SSH_FP_HEX);
			ra = key_fingerprint(host_key, SSH_FP_MD5,
			    SSH_FP_RANDOMART);
			msg2[0] = '\0';
			if (options.verify_host_key_dns) {
				if (matching_host_key_dns)
					snprintf(msg2, sizeof(msg2),
					    "Matching host key fingerprint"
					    " found in DNS.\n");
				else
					snprintf(msg2, sizeof(msg2),
					    "No matching host key fingerprint"
					    " found in DNS.\n");
			}
			snprintf(msg, sizeof(msg),
			    "The authenticity of host '%.200s (%s)' can't be "
			    "established%s\n"
			    "%s key fingerprint is %s.%s%s\n%s"
			    "Are you sure you want to continue connecting "
			    "(yes/no)? ",
			    host, ip, msg1, type, fp,
			    options.visual_host_key ? "\n" : "",
			    options.visual_host_key ? ra : "",
			    msg2);
			xfree(ra);
			xfree(fp);
			if (!confirm(msg))
				goto fail;
		}
		/*
		 * If not in strict mode, add the key automatically to the
		 * local known_hosts file.
		 */
		if (options.check_host_ip && ip_status == HOST_NEW) {
			snprintf(hostline, sizeof(hostline), "%s,%s",
			    host, ip);
			hostp = hostline;
			if (options.hash_known_hosts) {
				/* Add hash of host and IP separately */
				r = add_host_to_hostfile(user_hostfile, host,
				    host_key, options.hash_known_hosts) &&
				    add_host_to_hostfile(user_hostfile, ip,
				    host_key, options.hash_known_hosts);
			} else {
				/* Add unhashed "host,ip" */
				r = add_host_to_hostfile(user_hostfile,
				    hostline, host_key,
				    options.hash_known_hosts);
			}
		} else {
			r = add_host_to_hostfile(user_hostfile, host, host_key,
			    options.hash_known_hosts);
			hostp = host;
		}

		if (!r)
			logit("Failed to add the host to the list of known "
			    "hosts (%.500s).", user_hostfile);
		else
			logit("Warning: Permanently added '%.200s' (%s) to the "
			    "list of known hosts.", hostp, type);
		break;
	case HOST_CHANGED:
		if (readonly == ROQUIET)
			goto fail;
		if (options.check_host_ip && host_ip_differ) {
			const char *key_msg;
			if (ip_status == HOST_NEW)
				key_msg = "is unknown";
			else if (ip_status == HOST_OK)
				key_msg = "is unchanged";
			else
				key_msg = "has a different value";
			error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
			error("@@       WARNING: POSSIBLE DNS SPOOFING DETECTED!          @@");
			error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
			error("The %s host key for %s has changed,", type, host);
			error("and the key for the corresponding IP address %s", ip);
			error("%s. This could either mean that", key_msg);
			error("DNS SPOOFING is happening or the IP address for the host");
			error("and its host key have changed at the same time.");
			if (ip_status != HOST_NEW)
				error("Offending key for IP in %s:%d", ip_file, ip_line);
		}
		/* The host key has changed. */
		warn_changed_key(host_key);
		error("Add correct host key in %.100s to get rid of this message.",
		    user_hostfile);
		error("Offending key in %s:%d", host_file, host_line);

		/*
		 * If strict host key checking is in use, the user will have
		 * to edit the key manually and we can only abort.
		 */
		if (options.strict_host_key_checking) {
			error("%s host key for %.200s has changed and you have "
			    "requested strict checking.", type, host);
			goto fail;
		}

		/*
		 * If strict host key checking has not been requested, allow
		 * the connection but without MITM-able authentication or
		 * forwarding.
		 */
		if (options.password_authentication) {
			error("Password authentication is disabled to avoid "
			    "man-in-the-middle attacks.");
			options.password_authentication = 0;
			cancelled_forwarding = 1;
		}
		if (options.kbd_interactive_authentication) {
			error("Keyboard-interactive authentication is disabled"
			    " to avoid man-in-the-middle attacks.");
			options.kbd_interactive_authentication = 0;
			options.challenge_response_authentication = 0;
			cancelled_forwarding = 1;
		}
		if (options.challenge_response_authentication) {
			error("Challenge/response authentication is disabled"
			    " to avoid man-in-the-middle attacks.");
			options.challenge_response_authentication = 0;
			cancelled_forwarding = 1;
		}
		if (options.forward_agent) {
			error("Agent forwarding is disabled to avoid "
			    "man-in-the-middle attacks.");
			options.forward_agent = 0;
			cancelled_forwarding = 1;
		}
		if (options.forward_x11) {
			error("X11 forwarding is disabled to avoid "
			    "man-in-the-middle attacks.");
			options.forward_x11 = 0;
			cancelled_forwarding = 1;
		}
		if (options.num_local_forwards > 0 ||
		    options.num_remote_forwards > 0) {
			error("Port forwarding is disabled to avoid "
			    "man-in-the-middle attacks.");
			options.num_local_forwards =
			    options.num_remote_forwards = 0;
			cancelled_forwarding = 1;
		}
		if (options.tun_open != SSH_TUNMODE_NO) {
			error("Tunnel forwarding is disabled to avoid "
			    "man-in-the-middle attacks.");
			options.tun_open = SSH_TUNMODE_NO;
			cancelled_forwarding = 1;
		}
		if (options.exit_on_forward_failure && cancelled_forwarding)
			fatal("Error: forwarding disabled due to host key "
			    "check failure");
		
		/*
		 * XXX Should permit the user to change to use the new id.
		 * This could be done by converting the host key to an
		 * identifying sentence, tell that the host identifies itself
		 * by that sentence, and ask the user if he/she whishes to
		 * accept the authentication.
		 */
		break;
	case HOST_FOUND:
		fatal("internal error");
		break;
	}

	if (options.check_host_ip && host_status != HOST_CHANGED &&
	    ip_status == HOST_CHANGED) {
		snprintf(msg, sizeof(msg),
		    "Warning: the %s host key for '%.200s' "
		    "differs from the key for the IP address '%.128s'"
		    "\nOffending key for IP in %s:%d",
		    type, host, ip, ip_file, ip_line);
		if (host_status == HOST_OK) {
			len = strlen(msg);
			snprintf(msg + len, sizeof(msg) - len,
			    "\nMatching host key in %s:%d",
			    host_file, host_line);
		}
		if (options.strict_host_key_checking == 1) {
			logit("%s", msg);
			error("Exiting, you have requested strict checking.");
			goto fail;
		} else if (options.strict_host_key_checking == 2) {
			strlcat(msg, "\nAre you sure you want "
			    "to continue connecting (yes/no)? ", sizeof(msg));
			if (!confirm(msg))
				goto fail;
		} else {
			logit("%s", msg);
		}
	}

	xfree(ip);
	xfree(host);
	return 0;

fail:
	xfree(ip);
	xfree(host);
	return -1;
}

/* returns 0 if key verifies or -1 if key does NOT verify */
int
verify_host_key(char *host, struct sockaddr *hostaddr, Key *host_key)
{
	struct stat st;
	int flags = 0;

	if (options.verify_host_key_dns &&
	    verify_host_key_dns(host, hostaddr, host_key, &flags) == 0) {

		if (flags & DNS_VERIFY_FOUND) {

			if (options.verify_host_key_dns == 1 &&
			    flags & DNS_VERIFY_MATCH &&
			    flags & DNS_VERIFY_SECURE)
				return 0;

			if (flags & DNS_VERIFY_MATCH) {
				matching_host_key_dns = 1;
			} else {
				warn_changed_key(host_key);
				error("Update the SSHFP RR in DNS with the new "
				    "host key to get rid of this message.");
			}
		}
	}

	/* return ok if the key can be found in an old keyfile */
	if (stat(options.system_hostfile2, &st) == 0 ||
	    stat(options.user_hostfile2, &st) == 0) {
		if (check_host_key(host, hostaddr, options.port, host_key,
		    RDONLY, options.user_hostfile2,
		    options.system_hostfile2) == 0)
			return 0;
	}
	return check_host_key(host, hostaddr, options.port, host_key,
	    RDRW, options.user_hostfile, options.system_hostfile);
}

/*
 * Starts a dialog with the server, and authenticates the current user on the
 * server.  This does not need any extra privileges.  The basic connection
 * to the server must already have been established before this is called.
 * If login fails, this function prints an error and never returns.
 * This function does not require super-user privileges.
 */
void
ssh_login(Sensitive *sensitive, const char *orighost,
    struct sockaddr *hostaddr, struct passwd *pw, int timeout_ms)
{
	char *host, *cp;
	char *server_user, *local_user;

	local_user = xstrdup(pw->pw_name);
	server_user = options.user ? options.user : local_user;

	/* Convert the user-supplied hostname into all lowercase. */
	host = xstrdup(orighost);
	for (cp = host; *cp; cp++)
		if (isupper(*cp))
			*cp = (char)tolower(*cp);

	/* Exchange protocol version identification strings with the server. */
	ssh_exchange_identification(timeout_ms);

	/* Put the connection into non-blocking mode. */
	packet_set_nonblocking();

	/* key exchange */
	/* authenticate user */
	if (compat20) {
		ssh_kex2(host, hostaddr);
		ssh_userauth2(local_user, server_user, host, sensitive);
	} else {
		ssh_kex(host, hostaddr);
		ssh_userauth1(local_user, server_user, host, sensitive);
	}
	xfree(local_user);
}

void
ssh_put_password(char *password)
{
	int size;
	char *padded;

	if (datafellows & SSH_BUG_PASSWORDPAD) {
		packet_put_cstring(password);
		return;
	}
	size = roundup(strlen(password) + 1, 32);
	padded = xcalloc(1, size);
	strlcpy(padded, password, size);
	packet_put_string(padded, size);
	memset(padded, 0, size);
	xfree(padded);
}

static int
show_key_from_file(const char *file, const char *host, int keytype)
{
	Key *found;
	char *fp, *ra;
	int line, ret;

	found = key_new(keytype);
	if ((ret = lookup_key_in_hostfile_by_type(file, host,
	    keytype, found, &line))) {
		fp = key_fingerprint(found, SSH_FP_MD5, SSH_FP_HEX);
		ra = key_fingerprint(found, SSH_FP_MD5, SSH_FP_RANDOMART);
		logit("WARNING: %s key found for host %s\n"
		    "in %s:%d\n"
		    "%s key fingerprint %s.\n%s\n",
		    key_type(found), host, file, line,
		    key_type(found), fp, ra);
		xfree(ra);
		xfree(fp);
	}
	key_free(found);
	return (ret);
}

/* print all known host keys for a given host, but skip keys of given type */
static int
show_other_keys(const char *host, Key *key)
{
	int type[] = { KEY_RSA1, KEY_RSA, KEY_DSA, -1};
	int i, found = 0;

	for (i = 0; type[i] != -1; i++) {
		if (type[i] == key->type)
			continue;
		if (type[i] != KEY_RSA1 &&
		    show_key_from_file(options.user_hostfile2, host, type[i])) {
			found = 1;
			continue;
		}
		if (type[i] != KEY_RSA1 &&
		    show_key_from_file(options.system_hostfile2, host, type[i])) {
			found = 1;
			continue;
		}
		if (show_key_from_file(options.user_hostfile, host, type[i])) {
			found = 1;
			continue;
		}
		if (show_key_from_file(options.system_hostfile, host, type[i])) {
			found = 1;
			continue;
		}
		debug2("no key of type %d for host %s", type[i], host);
	}
	return (found);
}

static void
warn_changed_key(Key *host_key)
{
	char *fp;
	const char *type = key_type(host_key);

	fp = key_fingerprint(host_key, SSH_FP_MD5, SSH_FP_HEX);

	error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
	error("@@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @@");
	error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
	error("IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!");
	error("Someone could be eavesdropping on you right now (man-in-the-middle attack)!");
	error("It is also possible that the %s host key has just been changed.", type);
	error("The fingerprint for the %s key sent by the remote host is\n%s.",
	    type, fp);
	error("Please contact your system administrator.");

	xfree(fp);
}

/*
 * Execute a local command
 */
int
ssh_local_cmd(const char *args)
{
	const char *shell;
	pid_t pid;
	int status;

	if (!options.permit_local_command ||
	    args == NULL || !*args)
		return (1);

	if ((shell = getenv("SHELL")) == NULL)
		shell = _PATH_BSHELL;

	pid = fork();
	if (pid == 0) {
		debug3("Executing %s -c \"%s\"", shell, args);
		execl(shell, shell, "-c", args, (char *)NULL);
		error("Couldn't execute %s -c \"%s\": %s",
		    shell, args, strerror(errno));
		_exit(1);
	} else if (pid == -1)
		fatal("fork failed: %.100s", strerror(errno));
	while (waitpid(pid, &status, 0) == -1)
		if (errno != EINTR)
			fatal("Couldn't wait for child: %s", strerror(errno));

	if (!WIFEXITED(status))
		return (1);

	return (WEXITSTATUS(status));
}
@


1.17
log
@More often than not, I wonder why OpenSSH works *at all*… this time,
fix -Wcast-align issues (except umac.c which is very horrid code anyway)
@
text
@a49 1
#include "roaming.h"
d52 1
a52 1
__RCSID("$MirOS: src/usr.bin/ssh/sshconnect.c,v 1.16 2009/10/04 14:29:11 tg Exp $");
d448 1
a448 1
			len = roaming_atomicio(read, connection_in, &buf[i], 1);
d534 1
a534 2
	if (roaming_atomicio(vwrite, connection_out, buf, strlen(buf))
	    != strlen(buf))
@


1.16
log
@• merge newer OpenSSH
• KNF in our diff – style(9)
• some const cleanliness (build with __CRAZY=Yes mostly)
@
text
@d53 1
a53 1
__RCSID("$MirOS: src/usr.bin/ssh/sshconnect.c,v 1.15 2008/12/27 21:17:59 tg Exp $");
d592 1
d605 2
a606 1
		local = (ntohl(((struct sockaddr_in *)hostaddr)->
d610 1
d612 1
a612 1
		    &(((struct sockaddr_in6 *)hostaddr)->sin6_addr));
@


1.15
log
@merge and wrap exec/exit functions better
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.212 2008/10/14 18:11:33 stevesk Exp $ */
d50 1
d53 1
a53 1
__RCSID("$MirOS: src/usr.bin/ssh/sshconnect.c,v 1.14 2008/12/16 22:13:31 tg Exp $");
d82 1
a82 1
		shell = _PATH_BSHELL;
d129 1
a129 1
		argv[1] = "-c";
d410 1
a410 1
static void
d449 1
a449 1
			len = atomicio(read, connection_in, &buf[i], 1);
d535 2
a536 1
	if (atomicio(vwrite, connection_out, buf, strlen(buf)) != strlen(buf))
d826 1
a826 1
			char *key_msg;
d1146 1
a1146 1
	char *shell;
@


1.14
log
@really merge OpenSSH-current into MirBSD Secure SHell 10uA4
@
text
@d52 1
a52 1
__RCSID("$MirOS: src/usr.bin/ssh/sshconnect.c,v 1.13 2008/12/16 20:55:31 tg Exp $");
a133 1
		arc4_preexec();
a1157 1
		arc4_preexec();
@


1.13
log
@fastmerge, do not use yet!
@
text
@d52 1
a52 1
__RCSID("$MirOS: src/usr.bin/ssh/sshconnect.c,v 1.12 2008/03/02 21:14:23 tg Exp $");
d134 1
d1159 1
@


1.12
log
@merge’n’fix
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.203 2007/12/27 14:22:08 dtucker Exp $ */
d52 1
a52 1
__RCSID("$MirOS: src/usr.bin/ssh/sshconnect.c,v 1.11 2007/09/13 13:52:56 tg Exp $");
a68 17
static void
ms_subtract_diff(struct timeval *start, int *ms)
{
	struct timeval diff, finish;

	gettimeofday(&finish, NULL);
	timersub(&finish, start, &diff);	
	*ms -= (diff.tv_sec * 1000) + (diff.tv_usec / 1000);
}

static void
ms_to_timeval(struct timeval *tv, int ms)
{
	tv->tv_sec = ms / 1000;
	tv->tv_usec = (ms % 1000) * 1000;
}

d153 2
d198 1
a198 1
	gaierr = getaddrinfo(options.bind_address, "0", &hints, &res);
d399 2
d529 1
a529 1
	snprintf(buf, sizeof buf, "SSH-%d.%d-%.100s %d\n",
d532 2
a533 1
	    SSH_VERSION, (int)arc4random() & 0xFFFF);
d582 1
a582 1
	char hostline[1000], *hostp, *fp;
d588 1
a588 1
	int len, host_line, ip_line;
d632 1
d717 7
d730 2
a731 2
			if (check_host_key(hostname, hostaddr, 0, host_key, 2,
			    user_hostfile, system_hostfile) == 0) {
d759 2
d775 1
a775 1
			    "%s key fingerprint is %s.\n%s"
d778 5
a782 1
			    host, ip, msg1, type, fp, msg2);
d835 1
a835 1
			error("and the key for the according IP address %s", ip);
d867 1
d874 1
d880 1
d886 1
d892 1
d900 1
d906 1
d908 4
d1064 1
a1064 1
	char *fp;
d1071 1
d1074 1
a1074 1
		    "%s key fingerprint %s.",
d1076 2
a1077 1
		    key_type(found), fp);
@


1.11
log
@merge and make UMAC-64 default message integrity whatever
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.202 2007/09/04 11:15:55 djm Exp $ */
d52 1
a52 1
__RCSID("$MirOS: src/usr.bin/ssh/sshconnect.c,v 1.10 2007/09/02 18:53:13 tg Exp $");
d216 1
a216 1
		    gai_strerror(gaierr));
d348 2
a349 2
		fatal("%s: %.100s: %s", __progname, host,
		    gai_strerror(gaierr));
@


1.10
log
@merge (luckily no need to change the distrib/special/sshd)
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.201 2007/08/23 03:23:26 djm Exp $ */
d52 1
a52 1
__RCSID("$MirOS: src/usr.bin/ssh/sshconnect.c,v 1.9 2006/10/13 18:40:51 tg Exp $");
d69 17
d232 1
a232 1
    socklen_t addrlen, int timeout)
d235 1
a235 1
	struct timeval tv;
d239 6
a244 2
	if (timeout <= 0)
		return (connect(sockfd, serv_addr, addrlen));
d250 6
a255 1
		return (0);
a256 2
	if (errno != EINPROGRESS)
		return (-1);
d261 1
a261 2
	tv.tv_sec = timeout;
	tv.tv_usec = 0;
d300 10
d326 2
a327 2
    u_short port, int family, int connection_attempts,
    int needpriv, const char *proxy_command)
d380 1
a380 1
			    options.connection_timeout) >= 0) {
d407 1
a407 1
	if (options.tcp_keep_alive &&
d423 1
a423 1
ssh_exchange_identification(void)
d431 7
d440 1
d443 19
a461 1
			size_t len = atomicio(read, connection_in, &buf[i], 1);
d464 2
a465 1
				fatal("ssh_exchange_identification: Connection closed by remote host");
d467 2
a468 1
				fatal("ssh_exchange_identification: read: %.100s", strerror(errno));
d479 2
a480 1
				fatal("ssh_exchange_identification: No banner received");
d488 1
d997 1
a997 1
    struct sockaddr *hostaddr, struct passwd *pw)
d1012 1
a1012 1
	ssh_exchange_identification();
@


1.9
log
@merge the 4.0 equivalent of 015_ssh.patch
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.200 2006/10/10 10:12:45 markus Exp $ */
d52 1
a52 1
__RCSID("$MirOS: src/usr.bin/ssh/sshconnect.c,v 1.8 2006/09/20 21:41:06 tg Exp $");
d78 4
a81 1
	char strport[NI_MAXSERV];
d127 1
a127 1
		argv[0] = _PATH_BSHELL;
@


1.8
log
@finish merging
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.199 2006/08/03 03:34:42 deraadt Exp $ */
d52 1
a52 1
__RCSID("$MirOS$");
d316 3
a318 1
		if (attempt > 0)
d320 1
a320 1

a356 3

		/* Sleep a moment before retrying. */
		sleep(1);
@


1.7
log
@fastmerge, bump vsn
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.185 2006/06/14 10:50:42 djm Exp $ */
d16 1
a16 3
#include "includes.h"
__RCSID("$MirOS: src/usr.bin/ssh/sshconnect.c,v 1.6 2006/06/02 20:50:52 tg Exp $");

d19 4
d25 2
d28 6
d35 1
a36 1
#include "xmalloc.h"
d50 3
d518 3
d522 3
a524 2
check_host_key(char *host, struct sockaddr *hostaddr, Key *host_key,
    int readonly, const char *user_hostfile, const char *system_hostfile)
d528 1
a528 1
	char *ip = NULL;
d575 1
a575 1
		ip = xstrdup(ntop);
d583 2
a584 2
	if (options.check_host_ip &&
	    (local || strcmp(host, ip) == 0 || options.proxy_command != NULL))
d588 4
a591 3
	 * Allow the user to record the key under a different name. This is
	 * useful for ssh tunneling over forwarded connections or if you run
	 * multiple sshd's on different ports on the same machine.
d594 1
a594 1
		host = options.host_key_alias;
d596 2
d666 9
d754 2
d794 1
a794 1
		 * agent forwarding.
d829 5
d875 1
d880 1
d914 3
a916 2
		if (check_host_key(host, hostaddr, host_key, /*readonly*/ 1,
		    options.user_hostfile2, options.system_hostfile2) == 0)
d919 2
a920 2
	return check_host_key(host, hostaddr, host_key, /*readonly*/ 0,
	    options.user_hostfile, options.system_hostfile);
@


1.6
log
@* merge
* remove all references to GSSAPI, Kerberos and AFS
* uint*_t -> u_int*_t for consistency, like openbsd
  (note: MirOS style(9) suggests uint32_t etc. instead!)
* bump vsn
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.182 2006/05/17 12:43:34 markus Exp $ */
d17 1
a17 1
__RCSID("$MirOS: src/usr.bin/ssh/sshconnect.c,v 1.5 2006/04/19 10:40:56 tg Exp $");
d94 1
a94 2
		seteuid(original_real_uid);
		setuid(original_real_uid);
d382 1
a382 1
	u_int i;
d385 1
a385 1
	for (;;) {
d402 2
@


1.5
log
@merge and clean up
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.180 2006/03/25 13:17:02 djm Exp $ */
d17 1
a17 1
__RCSID("$MirOS: src/usr.bin/ssh/sshconnect.c,v 1.4 2006/02/22 01:23:52 tg Exp $");
d303 1
a303 6
	/*
	 * Try to connect several times.  On some machines, the first time
	 * will sometimes fail.  In general socket code appears to behave
	 * quite magically on many machines.
		 */
	for (attempt = 0; ;) {
d307 4
a310 2
		/* Loop through addresses for this host, and try each one in
		   sequence until the connection succeeds. */
a336 6
				/*
				 * Close the failed socket; there appear to
				 * be some problems when reusing a socket for
				 * which connect() has already returned an
				 * error.
				 */
d338 1
d341 1
a341 1
		if (ai)
a343 3
		attempt++;
		if (attempt >= connection_attempts)
			break;
d351 1
a351 1
	if (attempt >= connection_attempts) {
d921 1
@


1.4
log
@merge; bump version; fix up manpages and includes a little
@
text
@d1 1
d17 1
a17 1
RCSID("$MirOS: src/usr.bin/ssh/sshconnect.c,v 1.3 2006/02/21 02:08:42 tg Exp $");
d22 1
a65 1
	size_t len;
d77 1
a77 4
	len = strlen(proxy_command) + 6;
	tmp = xmalloc(len);
	strlcpy(tmp, "exec ", len);
	strlcat(tmp, proxy_command, len);
d205 1
a205 1
	int fdsetsz, optval, rc, result = -1;
d219 2
a220 4
	fdsetsz = howmany(sockfd + 1, NFDBITS) * sizeof(fd_mask);
	fdset = (fd_set *)xmalloc(fdsetsz);

	memset(fdset, 0, fdsetsz);
d915 1
a915 1
			*cp = tolower(*cp);
d945 1
a945 2
	padded = xmalloc(size);
	memset(padded, 0, size);
@


1.3
log
@* cipher.c: use libc md5, not openssl one
* packet.c: add nullmessage content via arc4random_push(3) too
  (used eg. to pad when entering passwords (stty -echo) to prevent attacks)
* all files: fix RCS ID

tested against itself and #8uA2
@
text
@d16 1
a16 1
RCSID("$MirOS: sshconnect.c,v 1.171 2005/12/06 22:38:27 reyk Exp $");
d18 4
a21 1
#include <openssl/bn.h>
@


1.2
log
@* cipher.c: expose (anonymised) session key to arc4random_push(3)
* sshconnect.c, sshd.c: expose 16-bit random value as part of version greeting
* version.h: bump

this is a new MirBSD_Secure_Shell feature: exchanging "randomness"
between connecting hosts (or ssh2 hosts staying connected for rekeying)
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.171 2005/12/06 22:38:27 reyk Exp $");
@


1.1
log
@Initial revision
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.159 2005/01/05 08:51:32 markus Exp $");
a33 1

d39 1
a39 1
int matching_host_key_dns = 0;
d57 1
a57 3
	Buffer command;
	const char *cp;
	char *command_string;
d61 1
d73 7
a79 25
	buffer_init(&command);
	buffer_append(&command, "exec ", 5);

	for (cp = proxy_command; *cp; cp++) {
		if (cp[0] == '%' && cp[1] == '%') {
			buffer_append(&command, "%", 1);
			cp++;
			continue;
		}
		if (cp[0] == '%' && cp[1] == 'h') {
			buffer_append(&command, host, strlen(host));
			cp++;
			continue;
		}
		if (cp[0] == '%' && cp[1] == 'p') {
			buffer_append(&command, strport, strlen(strport));
			cp++;
			continue;
		}
		buffer_append(&command, cp, 1);
	}
	buffer_append(&command, "\0", 1);

	/* Get the final command string. */
	command_string = buffer_ptr(&command);
d133 1
a133 1
	buffer_free(&command);
d226 1
a226 1
	for(;;) {
d232 1
a232 1
	switch(rc) {
a286 1
	struct servent *sp;
a289 8
	/* Get default port if port has not been set. */
	if (port == 0) {
		sp = getservbyname(SSH_SERVICE_NAME, "tcp");
		if (sp)
			port = ntohs(sp->s_port);
		else
			port = SSH_DEFAULT_PORT;
	}
d391 1
a391 1
	int remote_major, remote_minor, i, mismatch;
d395 1
d397 1
a397 1
	/* Read other side\'s version identification. */
d400 5
a404 2
			int len = atomicio(read, connection_in, &buf[i], 1);
			if (len < 0)
a405 2
			if (len != 1)
				fatal("ssh_exchange_identification: Connection closed by remote host");
d475 1
a475 1
	snprintf(buf, sizeof buf, "SSH-%d.%d-%.100s\n",
d478 1
a478 1
	    SSH_VERSION);
d526 1
a526 1
	int local = 0, host_ip_differ = 0;
d544 1
a544 1
		   sin_addr.s_addr) >> 24) == IN_LOOPBACKNET;
d598 1
a598 1
	 * Check if the host key is present in the user\'s list of known
d646 1
a646 1
			    host_key))
d674 2
a675 2
				   "\nbut keys of different type are already"
				   " known for this host.");
d702 4
d707 2
a708 1
			snprintf(hostline, sizeof(hostline), "%s,%s", host, ip);
d710 15
a724 1
		} else
d726 1
d728 1
a728 5
		/*
		 * If not in strict mode, add the key automatically to the
		 * local known_hosts file.
		 */
		if (!add_host_to_hostfile(user_hostfile, hostp, host_key))
d1029 36
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@OpenSSH-current
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.162 2005/03/10 22:01:06 deraadt Exp $");
d246 1
a246 1
	for (;;) {
d252 1
a252 1
	switch (rc) {
d553 1
a553 1
	int r, local = 0, host_ip_differ = 0;
d673 1
a673 1
			    host_key, options.hash_known_hosts))
d729 6
d739 1
a739 23
		if (options.check_host_ip && ip_status == HOST_NEW) {
			snprintf(hostline, sizeof(hostline), "%s,%s",
			    host, ip);
			hostp = hostline;
			if (options.hash_known_hosts) {
				/* Add hash of host and IP separately */
				r = add_host_to_hostfile(user_hostfile, host,
				    host_key, options.hash_known_hosts) &&
				    add_host_to_hostfile(user_hostfile, ip,
				    host_key, options.hash_known_hosts);
			} else {
				/* Add unhashed "host,ip" */
				r = add_host_to_hostfile(user_hostfile,
				    hostline, host_key,
				    options.hash_known_hosts);
			}
		} else {
			r = add_host_to_hostfile(user_hostfile, host, host_key,
			    options.hash_known_hosts);
			hostp = host;
		}

		if (!r)
@


1.1.1.3
log
@most current OpenSSH.com
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.166 2005/06/17 22:53:47 djm Exp $");
d58 3
a60 1
	char *command_string, *tmp;
a63 1
	size_t len;
d75 25
a99 7
	len = strlen(proxy_command) + 6;
	tmp = xmalloc(len);
	strlcpy(tmp, "exec ", len);
	strlcat(tmp, proxy_command, len);
	command_string = percent_expand(tmp, "h", host,
	    "p", strport, (char *)NULL);
	xfree(tmp);
d153 1
a153 1
	xfree(command_string);
d307 1
d311 8
d420 1
a420 1
	int remote_major, remote_minor, mismatch;
a423 1
	u_int i;
d425 1
a425 1
	/* Read other side's version identification. */
d428 4
a431 3
			size_t len = atomicio(read, connection_in, &buf[i], 1);

			if (len != 1 && errno == EPIPE) 
a432 2
			else if (len != 1)
				fatal("ssh_exchange_identification: read: %.100s", strerror(errno));
@


1.1.1.4
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.168 2005/07/17 07:17:55 djm Exp $");
d403 1
a403 1
			if (len != 1 && errno == EPIPE)
d545 1
a545 1
		    sin_addr.s_addr) >> 24) == IN_LOOPBACKNET;
d675 2
a676 2
				    "\nbut keys of different type are already"
				    " known for this host.");
@


1.1.1.5
log
@Import current OpenSSH
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.170 2005/10/30 08:52:18 djm Exp $");
d34 1
d40 1
a40 1
static int matching_host_key_dns = 0;
d599 1
a599 1
	 * Check if the host key is present in the user's list of known
@


1.1.1.6
log
@OpenSSH is the last missing piece to update before the release
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.171 2005/12/06 22:38:27 reyk Exp $");
a1028 36

/*
 * Execute a local command
 */
int
ssh_local_cmd(const char *args)
{
	char *shell;
	pid_t pid;
	int status;

	if (!options.permit_local_command ||
	    args == NULL || !*args)
		return (1);

	if ((shell = getenv("SHELL")) == NULL)
		shell = _PATH_BSHELL;

	pid = fork();
	if (pid == 0) {
		debug3("Executing %s -c \"%s\"", shell, args);
		execl(shell, shell, "-c", args, (char *)NULL);
		error("Couldn't execute %s -c \"%s\": %s",
		    shell, args, strerror(errno));
		_exit(1);
	} else if (pid == -1)
		fatal("fork failed: %.100s", strerror(errno));
	while (waitpid(pid, &status, 0) == -1)
		if (errno != EINTR)
			fatal("Couldn't wait for child: %s", strerror(errno));

	if (!WIFEXITED(status))
		return (1);

	return (WEXITSTATUS(status));
}
@


1.1.1.7
log
@import OpenSSH-current
@
text
@d16 1
a16 1
RCSID("$OpenBSD: sshconnect.c,v 1.175 2006/02/20 17:19:54 stevesk Exp $");
d18 1
a18 5
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>

#include <paths.h>
@


1.1.1.8
log
@I decided we'd better upgrade OpenSSH before releasing to the general public
@
text
@a0 1
/* $OpenBSD: sshconnect.c,v 1.180 2006/03/25 13:17:02 djm Exp $ */
d16 1
a21 1
#include <ctype.h>
d65 1
d77 4
a80 1
	xasprintf(&tmp, "exec %s", proxy_command);
d208 1
a208 1
	int optval, rc, result = -1;
d222 4
a225 2
	fdset = (fd_set *)xcalloc(howmany(sockfd + 1, NFDBITS),
	    sizeof(fd_mask));
d920 1
a920 1
			*cp = (char)tolower(*cp);
d950 2
a951 1
	padded = xcalloc(1, size);
@


1.1.1.9
log
@if we're gonna push out another snapshot, we'd better have sshd-current
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.182 2006/05/17 12:43:34 markus Exp $ */
d303 6
a308 1
	for (attempt = 0; attempt < connection_attempts; attempt++) {
d312 2
a313 4
		/*
		 * Loop through addresses for this host, and try each one in
		 * sequence until the connection succeeds.
		 */
d340 6
a346 1
				sock = -1;
d349 1
a349 1
		if (sock != -1)
d352 3
d362 1
a362 1
	if (sock == -1) {
a931 1
	xfree(local_user);
@


1.1.1.10
log
@Import latest OpenSSH, contains coverity fixes etc.
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.185 2006/06/14 10:50:42 djm Exp $ */
d94 2
a95 1
		permanently_drop_suid(original_real_uid);
d383 1
a383 1
	u_int i, n;
d386 1
a386 1
	for (n = 0;;) {
a402 2
			if (++n > 65536)
				fatal("ssh_exchange_identification: No banner received");
@


1.1.1.11
log
@import a few security-wise relevant changes right now
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.199 2006/08/03 03:34:42 deraadt Exp $ */
d16 2
a20 4
#include <sys/socket.h>
#include <sys/time.h>

#include <netinet/in.h>
a22 2
#include <errno.h>
#include <netdb.h>
a23 6
#include <signal.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
d25 1
a26 1
#include "ssh.h"
a39 1
#include "version.h"
a504 3
#define RDRW	0
#define RDONLY	1
#define ROQUIET	2
d506 2
a507 3
check_host_key(char *hostname, struct sockaddr *hostaddr, u_short port,
    Key *host_key, int readonly, const char *user_hostfile,
    const char *system_hostfile)
d511 1
a511 1
	char *ip = NULL, *host = NULL;
d558 1
a558 1
		ip = put_host_port(ntop, port);
d566 2
a567 2
	if (options.check_host_ip && (local ||
	    strcmp(hostname, ip) == 0 || options.proxy_command != NULL))
d571 3
a573 4
	 * Allow the user to record the key under a different name or
	 * differentiate a non-standard port.  This is useful for ssh
	 * tunneling over forwarded connections or if you run multiple
	 * sshd's on different ports on the same machine.
d576 1
a576 1
		host = xstrdup(options.host_key_alias);
a577 2
	} else {
		host = put_host_port(hostname, port);
a645 9
		if (options.host_key_alias == NULL && port != 0 &&
		    port != SSH_DEFAULT_PORT) {
			debug("checking without port identifier");
			if (check_host_key(hostname, hostaddr, 0, host_key, 2,
			    user_hostfile, system_hostfile) == 0) {
				debug("found matching key w/out port");
				break;
			}
		}
a724 2
		if (readonly == ROQUIET)
			goto fail;
d763 1
a763 1
		 * forwarding.
a797 5
		if (options.tun_open != SSH_TUNMODE_NO) {
			error("Tunnel forwarding is disabled to avoid "
			    "man-in-the-middle attacks.");
			options.tun_open = SSH_TUNMODE_NO;
		}
a838 1
	xfree(host);
a842 1
	xfree(host);
d876 2
a877 3
		if (check_host_key(host, hostaddr, options.port, host_key,
		    RDONLY, options.user_hostfile2,
		    options.system_hostfile2) == 0)
d880 2
a881 2
	return check_host_key(host, hostaddr, options.port, host_key,
	    RDRW, options.user_hostfile, options.system_hostfile);
@


1.1.1.12
log
@OpenSSH 4.5 (security)
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.200 2006/10/10 10:12:45 markus Exp $ */
d314 1
a314 3
		if (attempt > 0) {
			/* Sleep a moment before retrying. */
			sleep(1);
d316 1
a316 1
		}
d353 3
@


1.1.1.13
log
@more ssh updates
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.201 2007/08/23 03:23:26 djm Exp $ */
d76 1
a76 4
	char *shell, strport[NI_MAXSERV];

	if ((shell = getenv("SHELL")) == NULL)
		shell = _PATH_BSHELL;
d122 1
a122 1
		argv[0] = shell;
@


1.1.1.14
log
@Import latest OpenSSH upgrades
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.202 2007/09/04 11:15:55 djm Exp $ */
a66 17
static void
ms_subtract_diff(struct timeval *start, int *ms)
{
	struct timeval diff, finish;

	gettimeofday(&finish, NULL);
	timersub(&finish, start, &diff);	
	*ms -= (diff.tv_sec * 1000) + (diff.tv_usec / 1000);
}

static void
ms_to_timeval(struct timeval *tv, int ms)
{
	tv->tv_sec = ms / 1000;
	tv->tv_usec = (ms % 1000) * 1000;
}

d213 1
a213 1
    socklen_t addrlen, int *timeoutp)
d216 1
a216 1
	struct timeval tv, t_start;
d220 2
a221 6
	gettimeofday(&t_start, NULL);

	if (*timeoutp <= 0) {
		result = connect(sockfd, serv_addr, addrlen);
		goto done;
	}
d227 1
a227 6
		result = 0;
		goto done;
	}
	if (errno != EINPROGRESS) {
		result = -1;
		goto done;
d229 2
d235 2
a236 1
	ms_to_timeval(&tv, *timeoutp);
a274 10

 done:
 	if (result == 0 && *timeoutp > 0) {
		ms_subtract_diff(&t_start, timeoutp);
		if (*timeoutp <= 0) {
			errno = ETIMEDOUT;
			result = -1;
		}
	}

d291 2
a292 2
    u_short port, int family, int connection_attempts, int *timeout_ms,
    int want_keepalive, int needpriv, const char *proxy_command)
d345 1
a345 1
			    timeout_ms) >= 0) {
d372 1
a372 1
	if (want_keepalive &&
d388 1
a388 1
ssh_exchange_identification(int timeout_ms)
a395 7
	size_t len;
	int fdsetsz, remaining, rc;
	struct timeval t_start, t_remaining;
	fd_set *fdset;

	fdsetsz = howmany(connection_in + 1, NFDBITS) * sizeof(fd_mask);
	fdset = xcalloc(1, fdsetsz);
a397 1
	remaining = timeout_ms;
d400 1
a400 19
			if (timeout_ms > 0) {
				gettimeofday(&t_start, NULL);
				ms_to_timeval(&t_remaining, remaining);
				FD_SET(connection_in, fdset);
				rc = select(connection_in + 1, fdset, NULL,
				    fdset, &t_remaining);
				ms_subtract_diff(&t_start, &remaining);
				if (rc == 0 || remaining <= 0)
					fatal("Connection timed out during "
					    "banner exchange");
				if (rc == -1) {
					if (errno == EINTR)
						continue;
					fatal("ssh_exchange_identification: "
					    "select: %s", strerror(errno));
				}
			}

			len = atomicio(read, connection_in, &buf[i], 1);
d403 1
a403 2
				fatal("ssh_exchange_identification: "
				    "Connection closed by remote host");
d405 1
a405 2
				fatal("ssh_exchange_identification: "
				    "read: %.100s", strerror(errno));
d416 1
a416 2
				fatal("ssh_exchange_identification: "
				    "No banner received");
a423 1
	xfree(fdset);
d932 1
a932 1
    struct sockaddr *hostaddr, struct passwd *pw, int timeout_ms)
d947 1
a947 1
	ssh_exchange_identification(timeout_ms);
@


1.1.1.15
log
@newer openssh
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.203 2007/12/27 14:22:08 dtucker Exp $ */
d214 1
a214 1
		    ssh_gai_strerror(gaierr));
d346 2
a347 2
		fatal("%s: Could not resolve hostname %.100s: %s", __progname,
		    host, ssh_gai_strerror(gaierr));
@


1.1.1.16
log
@OpenSSH-current
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.212 2008/10/14 18:11:33 stevesk Exp $ */
d67 17
a167 2
	packet_set_timeout(options.server_alive_interval,
	    options.server_alive_count_max);
d211 1
a211 1
	gaierr = getaddrinfo(options.bind_address, NULL, &hints, &res);
a411 2
	packet_set_timeout(options.server_alive_interval,
	    options.server_alive_count_max);
d540 1
a540 1
	snprintf(buf, sizeof buf, "SSH-%d.%d-%.100s%s",
d543 1
a543 1
	    SSH_VERSION, compat20 ? "\r\n" : "\n");
d592 1
a592 1
	char hostline[1000], *hostp, *fp, *ra;
d598 1
a598 1
	int len, host_line, ip_line, cancelled_forwarding = 0;
a641 1

a725 7
		} else if (options.visual_host_key) {
			fp = key_fingerprint(host_key, SSH_FP_MD5, SSH_FP_HEX);
			ra = key_fingerprint(host_key, SSH_FP_MD5,
			    SSH_FP_RANDOMART);
			logit("Host key fingerprint is %s\n%s\n", fp, ra);
			xfree(ra);
			xfree(fp);
d732 2
a733 2
			if (check_host_key(hostname, hostaddr, 0, host_key,
			    ROQUIET, user_hostfile, system_hostfile) == 0) {
a760 2
			ra = key_fingerprint(host_key, SSH_FP_MD5,
			    SSH_FP_RANDOMART);
d775 1
a775 1
			    "%s key fingerprint is %s.%s%s\n%s"
d778 1
a778 5
			    host, ip, msg1, type, fp,
			    options.visual_host_key ? "\n" : "",
			    options.visual_host_key ? ra : "",
			    msg2);
			xfree(ra);
d831 1
a831 1
			error("and the key for the corresponding IP address %s", ip);
a862 1
			cancelled_forwarding = 1;
a868 1
			cancelled_forwarding = 1;
a873 1
			cancelled_forwarding = 1;
a878 1
			cancelled_forwarding = 1;
a883 1
			cancelled_forwarding = 1;
a890 1
			cancelled_forwarding = 1;
a895 1
			cancelled_forwarding = 1;
a896 4
		if (options.exit_on_forward_failure && cancelled_forwarding)
			fatal("Error: forwarding disabled due to host key "
			    "check failure");
		
d1049 1
a1049 1
	char *fp, *ra;
a1055 1
		ra = key_fingerprint(found, SSH_FP_MD5, SSH_FP_RANDOMART);
d1058 1
a1058 1
		    "%s key fingerprint %s.\n%s\n",
d1060 1
a1060 2
		    key_type(found), fp, ra);
		xfree(ra);
@


1.1.1.17
log
@Let’s play the version number game – OpenSSH 5.3-current
@
text
@d1 1
a1 1
/* $OpenBSD: sshconnect.c,v 1.214 2009/05/28 16:50:16 andreas Exp $ */
a49 1
#include "roaming.h"
d407 1
a407 1
void
d446 1
a446 1
			len = roaming_atomicio(read, connection_in, &buf[i], 1);
d531 1
a531 2
	if (roaming_atomicio(vwrite, connection_out, buf, strlen(buf))
	    != strlen(buf))
@


