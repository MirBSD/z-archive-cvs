head	1.18;
access;
symbols
	cvs-200910041320:1.1.1.12
	cvs-200903221200:1.1.1.11
	cvs-200812162015:1.1.1.10
	cvs-200804031830:1.1.1.9
	MIRBSD_10:1.12.0.2
	MIRBSD_10_BASE:1.12
	cvs-200803022030:1.1.1.9
	cvs-200709131337:1.1.1.8
	cvs-200709021830:1.1.1.8
	cvs-200708201200:1.1.1.8
	cvs-200706161500:1.1.1.8
	cvs-200705192215:1.1.1.7
	cvs-200704292000:1.1.1.7
	cvs-200703080900:1.1.1.7
	cvs-200701251600:1.1.1.7
	cvs-200612111600:1.1.1.7
	cvs-200611090230:1.1.1.7
	OPENBSD_4_0:1.1.1.6
	MIRBSD_9_BASE:1.7
	cvs-200606162342:1.1.1.5
	cvs-200606022000:1.1.1.5
	cvs-200604191000:1.1.1.5
	cvs-200602220045:1.1.1.4
	MIRBSD_8:1.1.1.3.0.2
	MIRBSD_8_BASE:1.1.1.3
	cvs-200512201942:1.1.1.3
	cvs-200511231930:1.1.1.3
	cvs-200507211800:1.1.1.2
	cvs-200506221550:1.1.1.2
	cvs-200505050030:1.1.1.1
	cvs-200504291700:1.1.1.1
	cvs-200504261445:1.1.1.1
	cvs-200504141900:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2016.01.14.19.23.02;	author tg;	state Exp;
branches;
next	1.17;
commitid	1005697F5AA3EA7E36D;

1.17
date	2010.09.21.21.24.37;	author tg;	state Exp;
branches;
next	1.16;
commitid	1004C992261692DCA0F;

1.16
date	2009.10.04.14.29.05;	author tg;	state Exp;
branches;
next	1.15;
commitid	1004AC8B1276FC00211;

1.15
date	2009.03.22.15.01.17;	author tg;	state Exp;
branches;
next	1.14;
commitid	10049C652CD5CCC321F;

1.14
date	2008.12.16.22.13.28;	author tg;	state Exp;
branches;
next	1.13;
commitid	10049482819766381ED;

1.13
date	2008.12.16.20.55.24;	author tg;	state Exp;
branches;
next	1.12;
commitid	100494815C97ECEEDBF;

1.12
date	2008.03.02.21.14.20;	author tg;	state Exp;
branches;
next	1.11;
commitid	10047CB18BB506A8527;

1.11
date	2007.06.16.15.41.50;	author tg;	state Exp;
branches;
next	1.10;
commitid	100467404D10F2EE204;

1.10
date	2006.10.02.23.25.04;	author tg;	state Exp;
branches;
next	1.9;
commitid	10045219FE675E8E795;

1.9
date	2006.09.20.21.41.00;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004511B578580E7F04;

1.8
date	2006.08.18.18.05.49;	author tg;	state Exp;
branches;
next	1.7;
commitid	10044E6018100C580D3;

1.7
date	2006.06.02.20.50.48;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004480A4952B0D84EA;

1.6
date	2006.04.19.10.40.49;	author tg;	state Exp;
branches;
next	1.5;
commitid	100444613BD3A91C28B;

1.5
date	2006.02.22.02.16.47;	author tg;	state Exp;
branches;
next	1.4;
commitid	10043FBC991512A442B;

1.4
date	2006.02.22.01.23.49;	author tg;	state Exp;
branches;
next	1.3;
commitid	10043FBBD2C2C5E7D81;

1.3
date	2006.02.21.02.08.42;	author tg;	state Exp;
branches;
next	1.2;
commitid	10043FA75E13B619DFC;

1.2
date	2006.02.20.23.44.43;	author tg;	state Exp;
branches;
next	1.1;
commitid	10043FA54726FD2F81F;

1.1
date	2005.02.05.17.29.52;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.29.52;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.06.22.15.56.25;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	181342b98a38fe99;

1.1.1.3
date	2005.11.23.19.34.15;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	116a4384c4467ffc;

1.1.1.4
date	2006.02.22.00.51.35;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	10043FBB5A933C3BB9B;

1.1.1.5
date	2006.04.19.10.15.03;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	10044460DB21E1F715C;

1.1.1.6
date	2006.09.20.19.06.49;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	10045119150397FC669;

1.1.1.7
date	2006.11.09.02.38.00;	author tg;	state Exp;
branches;
next	1.1.1.8;
commitid	100455294981A6201C8;

1.1.1.8
date	2007.06.16.15.11.12;	author tg;	state Exp;
branches;
next	1.1.1.9;
commitid	1004673FD85114A3F32;

1.1.1.9
date	2008.03.02.20.40.42;	author tg;	state Exp;
branches;
next	1.1.1.10;
commitid	10047CB10DD30FAF062;

1.1.1.10
date	2008.12.16.20.15.33;	author tg;	state Exp;
branches;
next	1.1.1.11;
commitid	10049480C7A2701F5C0;

1.1.1.11
date	2009.03.22.12.03.00;	author tg;	state Exp;
branches;
next	1.1.1.12;
commitid	10049C6290649163EA3;

1.1.1.12
date	2009.10.04.13.25.45;	author tg;	state Exp;
branches;
next	;
commitid	1004AC8A2663BC008C5;


desc
@@


1.18
log
@drop roaming code completely
@
text
@/* $OpenBSD: packet.c,v 1.166 2009/06/27 09:29:06 andreas Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * This file contains code implementing the packet protocol and communication
 * with the other side.  This same code is used both on client and server side.
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 *
 * SSH2 packet format added by Markus Friedl.
 * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/time.h>

#include <netinet/in_systm.h>
#include <netinet/in.h>
#include <netinet/ip.h>

#include <errno.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>

#include "xmalloc.h"
#include "buffer.h"
#include "packet.h"
#include "crc32.h"
#include "compress.h"
#include "deattack.h"
#include "channels.h"
#include "compat.h"
#include "ssh1.h"
#include "ssh2.h"
#include "cipher.h"
#include "key.h"
#include "kex.h"
#include "mac.h"
#include "log.h"
#include "canohost.h"
#include "misc.h"
#include "ssh.h"

__RCSID("$MirOS: src/usr.bin/ssh/packet.c,v 1.17 2010/09/21 21:24:37 tg Exp $");

const char NULs[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };

#ifdef PACKET_DEBUG
#define DBG(x) x
#else
#define DBG(x)
#endif

#define PACKET_MAX_SIZE (256 * 1024)

struct packet_state {
	u_int32_t seqnr;
	u_int32_t packets;
	u_int64_t blocks;
	u_int64_t bytes;
};

struct packet {
	TAILQ_ENTRY(packet) next;
	u_char type;
	Buffer payload;
};

struct session_state {
	/*
	 * This variable contains the file descriptors used for
	 * communicating with the other side.  connection_in is used for
	 * reading; connection_out for writing.  These can be the same
	 * descriptor, in which case it is assumed to be a socket.
	 */
	int connection_in;
	int connection_out;

	/* Protocol flags for the remote side. */
	u_int remote_protocol_flags;

	/* Encryption context for receiving data.  Only used for decryption. */
	CipherContext receive_context;

	/* Encryption context for sending data.  Only used for encryption. */
	CipherContext send_context;

	/* Buffer for raw input data from the socket. */
	Buffer input;

	/* Buffer for raw output data going to the socket. */
	Buffer output;

	/* Buffer for the partial outgoing packet being constructed. */
	Buffer outgoing_packet;

	/* Buffer for the incoming packet currently being processed. */
	Buffer incoming_packet;

	/* Scratch buffer for packet compression/decompression. */
	Buffer compression_buffer;
	int compression_buffer_ready;

	/*
	 * Flag indicating whether packet compression/decompression is
	 * enabled.
	 */
	int packet_compression;

	/* default maximum packet size */
	u_int max_packet_size;

	/* Flag indicating whether this module has been initialized. */
	int initialized;

	/* Set to true if the connection is interactive. */
	int interactive_mode;

	/* Set to true if we are the server side. */
	int server_side;

	/* Set to true if we are authenticated. */
	int after_authentication;

	int keep_alive_timeouts;

	/* The maximum time that we will wait to send or receive a packet */
	int packet_timeout_ms;

	/* Session key information for Encryption and MAC */
	Newkeys *newkeys[MODE_MAX];
	struct packet_state p_read, p_send;

	u_int64_t max_blocks_in, max_blocks_out;
	u_int32_t rekey_limit;

	/* Session key for protocol v1 */
	u_char ssh1_key[SSH_SESSION_KEY_LENGTH];
	u_int ssh1_keylen;

	/* roundup current message to extra_pad bytes */
	u_char extra_pad;

	/* XXX discard incoming data after MAC error */
	u_int packet_discard;
	Mac *packet_discard_mac;

	/* Used in packet_read_poll2() */
	u_int packlen;

	/* Used in packet_send2 */
	int rekeying;

	/* Used in packet_set_interactive */
	int set_interactive_called;

	/* Used in packet_set_maxsize */
	int set_maxsize_called;

	TAILQ_HEAD(, packet) outgoing;
};

static struct session_state *active_state;

static struct session_state *
alloc_session_state(void)
{
    struct session_state *s = xcalloc(1, sizeof(*s));

    s->connection_in = -1;
    s->connection_out = -1;
    s->max_packet_size = 32768;
    s->packet_timeout_ms = -1;
    return s;
}

static __dead void packet_stop_discard(void);

/* MirOS extension */
static void packet_consume_ignoremsg(void);

/*
 * Sets the descriptors used for communication.  Disables encryption until
 * packet_set_encryption_key is called.
 */
void
packet_set_connection(int fd_in, int fd_out)
{
	Cipher *none = cipher_by_name("none");

	if (none == NULL)
		fatal("packet_set_connection: cannot load cipher 'none'");
	if (active_state == NULL)
		active_state = alloc_session_state();
	active_state->connection_in = fd_in;
	active_state->connection_out = fd_out;
	cipher_init(&active_state->send_context, none, (const u_char *)&fd_in,
	    sizeof(fd_in), NULL, 0, CIPHER_ENCRYPT);
	cipher_init(&active_state->receive_context, none, (const u_char *)&fd_out,
	    sizeof(fd_out), NULL, 0, CIPHER_DECRYPT);
	active_state->newkeys[MODE_IN] = active_state->newkeys[MODE_OUT] = NULL;
	if (!active_state->initialized) {
		active_state->initialized = 1;
		buffer_init(&active_state->input);
		buffer_init(&active_state->output);
		buffer_init(&active_state->outgoing_packet);
		buffer_init(&active_state->incoming_packet);
		TAILQ_INIT(&active_state->outgoing);
		active_state->p_send.packets = active_state->p_read.packets = 0;
	}
}

void
packet_set_timeout(int timeout, int count)
{
	if (timeout == 0 || count == 0) {
		active_state->packet_timeout_ms = -1;
		return;
	}
	if ((INT_MAX / 1000) / count < timeout)
		active_state->packet_timeout_ms = INT_MAX;
	else
		active_state->packet_timeout_ms = timeout * count * 1000;
}

static void
packet_stop_discard(void)
{
	if (active_state->packet_discard_mac) {
		char buf[1024];
		
		memset(buf, 'a', sizeof(buf));
		while (buffer_len(&active_state->incoming_packet) <
		    PACKET_MAX_SIZE)
			buffer_append(&active_state->incoming_packet, buf,
			    sizeof(buf));
		(void) mac_compute(active_state->packet_discard_mac,
		    active_state->p_read.seqnr,
		    buffer_ptr(&active_state->incoming_packet),
		    PACKET_MAX_SIZE);
	}
	logit("Finished discarding for %.200s", get_remote_ipaddr());
	cleanup_exit(255);
}

static void
packet_start_discard(Enc *enc, Mac *mac, u_int packet_length, u_int discard)
{
	if (enc == NULL || !cipher_is_cbc(enc->cipher))
		packet_disconnect("Packet corrupt");
	if (packet_length != PACKET_MAX_SIZE && mac && mac->enabled)
		active_state->packet_discard_mac = mac;
	if (buffer_len(&active_state->input) >= discard)
		packet_stop_discard();
	active_state->packet_discard = discard -
	    buffer_len(&active_state->input);
}

/* Returns 1 if remote host is connected via socket, 0 if not. */

int
packet_connection_is_on_socket(void)
{
	struct sockaddr_storage from, to;
	socklen_t fromlen, tolen;

	/* filedescriptors in and out are the same, so it's a socket */
	if (active_state->connection_in == active_state->connection_out)
		return 1;
	fromlen = sizeof(from);
	memset(&from, 0, sizeof(from));
	if (getpeername(active_state->connection_in, (struct sockaddr *)&from,
	    &fromlen) < 0)
		return 0;
	tolen = sizeof(to);
	memset(&to, 0, sizeof(to));
	if (getpeername(active_state->connection_out, (struct sockaddr *)&to,
	    &tolen) < 0)
		return 0;
	if (fromlen != tolen || memcmp(&from, &to, fromlen) != 0)
		return 0;
	if (from.ss_family != AF_INET && from.ss_family != AF_INET6)
		return 0;
	return 1;
}

/*
 * Exports an IV from the CipherContext required to export the key
 * state back from the unprivileged child to the privileged parent
 * process.
 */

void
packet_get_keyiv(int mode, u_char *iv, u_int len)
{
	CipherContext *cc;

	if (mode == MODE_OUT)
		cc = &active_state->send_context;
	else
		cc = &active_state->receive_context;

	cipher_get_keyiv(cc, iv, len);
}

int
packet_get_keycontext(int mode, u_char *dat)
{
	CipherContext *cc;

	if (mode == MODE_OUT)
		cc = &active_state->send_context;
	else
		cc = &active_state->receive_context;

	return (cipher_get_keycontext(cc, dat));
}

void
packet_set_keycontext(int mode, u_char *dat)
{
	CipherContext *cc;

	if (mode == MODE_OUT)
		cc = &active_state->send_context;
	else
		cc = &active_state->receive_context;

	cipher_set_keycontext(cc, dat);
}

int
packet_get_keyiv_len(int mode)
{
	CipherContext *cc;

	if (mode == MODE_OUT)
		cc = &active_state->send_context;
	else
		cc = &active_state->receive_context;

	return (cipher_get_keyiv_len(cc));
}

void
packet_set_iv(int mode, u_char *dat)
{
	CipherContext *cc;

	if (mode == MODE_OUT)
		cc = &active_state->send_context;
	else
		cc = &active_state->receive_context;

	cipher_set_keyiv(cc, dat);
}

int
packet_get_ssh1_cipher(void)
{
	return (cipher_get_number(active_state->receive_context.cipher));
}

void
packet_get_state(int mode, u_int32_t *seqnr, u_int64_t *blocks, u_int32_t *packets,
    u_int64_t *bytes)
{
	struct packet_state *state;

	state = (mode == MODE_IN) ?
	    &active_state->p_read : &active_state->p_send;
	if (seqnr)
		*seqnr = state->seqnr;
	if (blocks)
		*blocks = state->blocks;
	if (packets)
		*packets = state->packets;
	if (bytes)
		*bytes = state->bytes;
}

void
packet_set_state(int mode, u_int32_t seqnr, u_int64_t blocks, u_int32_t packets,
    u_int64_t bytes)
{
	struct packet_state *state;

	state = (mode == MODE_IN) ?
	    &active_state->p_read : &active_state->p_send;
	state->seqnr = seqnr;
	state->blocks = blocks;
	state->packets = packets;
	state->bytes = bytes;
}

/* returns 1 if connection is via ipv4 */

int
packet_connection_is_ipv4(void)
{
	struct sockaddr_storage to;
	socklen_t tolen = sizeof(to);

	memset(&to, 0, sizeof(to));
	if (getsockname(active_state->connection_out, (struct sockaddr *)&to,
	    &tolen) < 0)
		return 0;
	if (to.ss_family != AF_INET)
		return 0;
	return 1;
}

/* Sets the connection into non-blocking mode. */

void
packet_set_nonblocking(void)
{
	/* Set the socket into non-blocking mode. */
	set_nonblock(active_state->connection_in);

	if (active_state->connection_out != active_state->connection_in)
		set_nonblock(active_state->connection_out);
}

/* Returns the socket used for reading. */

int
packet_get_connection_in(void)
{
	return active_state->connection_in;
}

/* Returns the descriptor used for writing. */

int
packet_get_connection_out(void)
{
	return active_state->connection_out;
}

/* Closes the connection and clears and frees internal data structures. */

void
packet_close(void)
{
	if (!active_state->initialized)
		return;
	active_state->initialized = 0;
	if (active_state->connection_in == active_state->connection_out) {
		shutdown(active_state->connection_out, SHUT_RDWR);
		close(active_state->connection_out);
	} else {
		close(active_state->connection_in);
		close(active_state->connection_out);
	}
	buffer_free(&active_state->input);
	buffer_free(&active_state->output);
	buffer_free(&active_state->outgoing_packet);
	buffer_free(&active_state->incoming_packet);
	if (active_state->compression_buffer_ready) {
		buffer_free(&active_state->compression_buffer);
		buffer_compress_uninit();
	}
	cipher_cleanup(&active_state->send_context);
	cipher_cleanup(&active_state->receive_context);
}

/* Sets remote side protocol flags. */

void
packet_set_protocol_flags(u_int protocol_flags)
{
	active_state->remote_protocol_flags = protocol_flags;
}

/* Returns the remote protocol flags set earlier by the above function. */

u_int
packet_get_protocol_flags(void)
{
	return active_state->remote_protocol_flags;
}

/*
 * Starts packet compression from the next packet on in both directions.
 * Level is compression level 1 (fastest) - 9 (slow, best) as in gzip.
 */

static void
packet_init_compression(void)
{
	if (active_state->compression_buffer_ready == 1)
		return;
	active_state->compression_buffer_ready = 1;
	buffer_init(&active_state->compression_buffer);
}

void
packet_start_compression(int level)
{
	if (active_state->packet_compression && !compat20)
		fatal("Compression already enabled.");
	active_state->packet_compression = 1;
	packet_init_compression();
	buffer_compress_init_send(level);
	buffer_compress_init_recv();
}

/*
 * Causes any further packets to be encrypted using the given key.  The same
 * key is used for both sending and reception.  However, both directions are
 * encrypted independently of each other.
 */

void
packet_set_encryption_key(const u_char *key, u_int keylen,
    int number)
{
	Cipher *cipher = cipher_by_number(number);

	if (cipher == NULL)
		fatal("packet_set_encryption_key: unknown cipher number %d", number);
	if (keylen < 20)
		fatal("packet_set_encryption_key: keylen too small: %d", keylen);
	if (keylen > SSH_SESSION_KEY_LENGTH)
		fatal("packet_set_encryption_key: keylen too big: %d", keylen);
	memcpy(active_state->ssh1_key, key, keylen);
	active_state->ssh1_keylen = keylen;
	cipher_init(&active_state->send_context, cipher, key, keylen, NULL,
	    0, CIPHER_ENCRYPT);
	cipher_init(&active_state->receive_context, cipher, key, keylen, NULL,
	    0, CIPHER_DECRYPT);
}

u_int
packet_get_encryption_key(u_char *key)
{
	if (key == NULL)
		return (active_state->ssh1_keylen);
	memcpy(key, active_state->ssh1_key, active_state->ssh1_keylen);
	return (active_state->ssh1_keylen);
}

/* Start constructing a packet to send. */
void
packet_start(u_char type)
{
	u_char buf[9];
	int len;

	DBG(debug("packet_start[%d]", type));
	len = compat20 ? 6 : 9;
	memset(buf, 0, len - 1);
	buf[len - 1] = type;
	buffer_clear(&active_state->outgoing_packet);
	buffer_append(&active_state->outgoing_packet, buf, len);
}

/* Append payload. */
void
packet_put_char(int value)
{
	char ch = value;

	buffer_append(&active_state->outgoing_packet, &ch, 1);
}

void
packet_put_int(u_int value)
{
	buffer_put_int(&active_state->outgoing_packet, value);
}

void
packet_put_int64(u_int64_t value)
{
	buffer_put_int64(&active_state->outgoing_packet, value);
}

void
packet_put_string(const void *buf, u_int len)
{
	buffer_put_string(&active_state->outgoing_packet, buf, len);
}

void
packet_put_cstring(const char *str)
{
	buffer_put_cstring(&active_state->outgoing_packet, str);
}

void
packet_put_raw(const void *buf, u_int len)
{
	buffer_append(&active_state->outgoing_packet, buf, len);
}

void
packet_put_bignum(BIGNUM * value)
{
	buffer_put_bignum(&active_state->outgoing_packet, value);
}

void
packet_put_bignum2(BIGNUM * value)
{
	buffer_put_bignum2(&active_state->outgoing_packet, value);
}

/*
 * Finalizes and sends the packet.  If the encryption key has been set,
 * encrypts the packet before sending.
 */

static void
packet_send1(void)
{
	u_char buf[8], *cp;
	int i, padding, len;
	u_int checksum;
	u_int32_t rnd = 0;

	/*
	 * If using packet compression, compress the payload of the outgoing
	 * packet.
	 */
	if (active_state->packet_compression) {
		buffer_clear(&active_state->compression_buffer);
		/* Skip padding. */
		buffer_consume(&active_state->outgoing_packet, 8);
		/* padding */
		buffer_append(&active_state->compression_buffer,
		    NULs, 8);
		buffer_compress(&active_state->outgoing_packet,
		    &active_state->compression_buffer);
		buffer_clear(&active_state->outgoing_packet);
		buffer_append(&active_state->outgoing_packet,
		    buffer_ptr(&active_state->compression_buffer),
		    buffer_len(&active_state->compression_buffer));
	}
	/* Compute packet length without padding (add checksum, remove padding). */
	len = buffer_len(&active_state->outgoing_packet) + 4 - 8;

	/* Insert padding. Initialized to zero in packet_start1() */
	padding = 8 - len % 8;
	if (!active_state->send_context.plaintext) {
		cp = buffer_ptr(&active_state->outgoing_packet);
		for (i = 0; i < padding; i++) {
			if (i % 4 == 0)
				rnd = arc4random();
			cp[7 - i] = rnd & 0xff;
			rnd >>= 8;
		}
	}
	buffer_consume(&active_state->outgoing_packet, 8 - padding);

	/* Add check bytes. */
	checksum = ssh_crc32(buffer_ptr(&active_state->outgoing_packet),
	    buffer_len(&active_state->outgoing_packet));
	put_u32(buf, checksum);
	buffer_append(&active_state->outgoing_packet, buf, 4);

#ifdef PACKET_DEBUG
	fprintf(stderr, "packet_send plain: ");
	buffer_dump(&active_state->outgoing_packet);
#endif

	/* Append to output. */
	put_u32(buf, len);
	buffer_append(&active_state->output, buf, 4);
	cp = buffer_append_space(&active_state->output,
	    buffer_len(&active_state->outgoing_packet));
	cipher_crypt(&active_state->send_context, cp,
	    buffer_ptr(&active_state->outgoing_packet),
	    buffer_len(&active_state->outgoing_packet));

#ifdef PACKET_DEBUG
	fprintf(stderr, "encrypted: ");
	buffer_dump(&active_state->output);
#endif
	active_state->p_send.packets++;
	active_state->p_send.bytes += len +
	    buffer_len(&active_state->outgoing_packet);
	buffer_clear(&active_state->outgoing_packet);

	/*
	 * Note that the packet is now only buffered in output.  It won't be
	 * actually sent until packet_write_wait or packet_write_poll is
	 * called.
	 */
}

void
set_newkeys(int mode)
{
	Enc *enc;
	Mac *mac;
	Comp *comp;
	CipherContext *cc;
	u_int64_t *max_blocks;
	int crypt_type;

	debug2("set_newkeys: mode %d", mode);

	if (mode == MODE_OUT) {
		cc = &active_state->send_context;
		crypt_type = CIPHER_ENCRYPT;
		active_state->p_send.packets = active_state->p_send.blocks = 0;
		max_blocks = &active_state->max_blocks_out;
	} else {
		cc = &active_state->receive_context;
		crypt_type = CIPHER_DECRYPT;
		active_state->p_read.packets = active_state->p_read.blocks = 0;
		max_blocks = &active_state->max_blocks_in;
	}
	if (active_state->newkeys[mode] != NULL) {
		debug("set_newkeys: rekeying");
		cipher_cleanup(cc);
		enc  = &active_state->newkeys[mode]->enc;
		mac  = &active_state->newkeys[mode]->mac;
		comp = &active_state->newkeys[mode]->comp;
		mac_clear(mac);
		xfree(enc->name);
		xfree(enc->iv);
		xfree(enc->key);
		xfree(mac->name);
		xfree(mac->key);
		xfree(comp->name);
		xfree(active_state->newkeys[mode]);
	}
	active_state->newkeys[mode] = kex_get_newkeys(mode);
	if (active_state->newkeys[mode] == NULL)
		fatal("newkeys: no keys for mode %d", mode);
	enc  = &active_state->newkeys[mode]->enc;
	mac  = &active_state->newkeys[mode]->mac;
	comp = &active_state->newkeys[mode]->comp;
	if (mac_init(mac) == 0)
		mac->enabled = 1;
	DBG(debug("cipher_init_context: %d", mode));
	cipher_init(cc, enc->cipher, enc->key, enc->key_len,
	    enc->iv, enc->block_size, crypt_type);
	/* Deleting the keys does not gain extra security */
	/* memset(enc->iv,  0, enc->block_size);
	   memset(enc->key, 0, enc->key_len);
	   memset(mac->key, 0, mac->key_len); */
	if ((comp->type == COMP_ZLIB ||
	    (comp->type == COMP_DELAYED &&
	     active_state->after_authentication)) && comp->enabled == 0) {
		packet_init_compression();
		if (mode == MODE_OUT)
			buffer_compress_init_send(6);
		else
			buffer_compress_init_recv();
		comp->enabled = 1;
	}
	/*
	 * The 2^(blocksize*2) limit is too expensive for 3DES,
	 * blowfish, etc, so enforce a 1GB limit for small blocksizes.
	 */
	if (enc->block_size >= 16)
		*max_blocks = (u_int64_t)1 << (enc->block_size*2);
	else
		*max_blocks = ((u_int64_t)1 << 30) / enc->block_size;
	if (active_state->rekey_limit)
		*max_blocks = MIN(*max_blocks,
		    active_state->rekey_limit / enc->block_size);
}

/*
 * Delayed compression for SSH2 is enabled after authentication:
 * This happens on the server side after a SSH2_MSG_USERAUTH_SUCCESS is sent,
 * and on the client side after a SSH2_MSG_USERAUTH_SUCCESS is received.
 */
static void
packet_enable_delayed_compress(void)
{
	Comp *comp = NULL;
	int mode;

	/*
	 * Remember that we are past the authentication step, so rekeying
	 * with COMP_DELAYED will turn on compression immediately.
	 */
	active_state->after_authentication = 1;
	for (mode = 0; mode < MODE_MAX; mode++) {
		/* protocol error: USERAUTH_SUCCESS received before NEWKEYS */
		if (active_state->newkeys[mode] == NULL)
			continue;
		comp = &active_state->newkeys[mode]->comp;
		if (comp && !comp->enabled && comp->type == COMP_DELAYED) {
			packet_init_compression();
			if (mode == MODE_OUT)
				buffer_compress_init_send(6);
			else
				buffer_compress_init_recv();
			comp->enabled = 1;
		}
	}
}

/*
 * Finalize packet in SSH2 format (compress, mac, encrypt, enqueue)
 */
static void
packet_send2_wrapped(void)
{
	u_char type, *cp, *macbuf = NULL;
	u_char padlen, pad;
	u_int packet_length = 0;
	u_int len;
	Enc *enc   = NULL;
	Mac *mac   = NULL;
	Comp *comp = NULL;
	int block_size;

	if (active_state->newkeys[MODE_OUT] != NULL) {
		enc  = &active_state->newkeys[MODE_OUT]->enc;
		mac  = &active_state->newkeys[MODE_OUT]->mac;
		comp = &active_state->newkeys[MODE_OUT]->comp;
	}
	block_size = enc ? enc->block_size : 8;

	cp = buffer_ptr(&active_state->outgoing_packet);
	type = cp[5];

#ifdef PACKET_DEBUG
	fprintf(stderr, "plain:     ");
	buffer_dump(&active_state->outgoing_packet);
#endif

	if (comp && comp->enabled) {
		len = buffer_len(&active_state->outgoing_packet);
		/* skip header, compress only payload */
		buffer_consume(&active_state->outgoing_packet, 5);
		buffer_clear(&active_state->compression_buffer);
		buffer_compress(&active_state->outgoing_packet,
		    &active_state->compression_buffer);
		buffer_clear(&active_state->outgoing_packet);
		buffer_append(&active_state->outgoing_packet, NULs, 5);
		buffer_append(&active_state->outgoing_packet,
		    buffer_ptr(&active_state->compression_buffer),
		    buffer_len(&active_state->compression_buffer));
		DBG(debug("compression: raw %d compressed %d", len,
		    buffer_len(&active_state->outgoing_packet)));
	}

	/* sizeof (packet_len + pad_len + payload) */
	len = buffer_len(&active_state->outgoing_packet);

	/*
	 * calc size of padding, alloc space, get random data,
	 * minimum padding is 4 bytes
	 */
	padlen = block_size - (len % block_size);
	if (padlen < 4)
		padlen += block_size;
	if (active_state->extra_pad) {
		/* will wrap if extra_pad+padlen > 255 */
		active_state->extra_pad =
		    roundup(active_state->extra_pad, block_size);
		pad = active_state->extra_pad -
		    ((len + padlen) % active_state->extra_pad);
		debug3("packet_send2: adding %d (len %d padlen %d extra_pad %d)",
		    pad, len, padlen, active_state->extra_pad);
		padlen += pad;
		active_state->extra_pad = 0;
	}
	cp = buffer_append_space(&active_state->outgoing_packet, padlen);
	if (enc && !active_state->send_context.plaintext) {
		/* random padding */
		arc4random_buf(cp, padlen);
	} else {
		/* clear padding */
		memset(cp, 0, padlen);
	}
	/* packet_length includes payload, padding and padding length field */
	packet_length = buffer_len(&active_state->outgoing_packet) - 4;
	cp = buffer_ptr(&active_state->outgoing_packet);
	put_u32(cp, packet_length);
	cp[4] = padlen;
	DBG(debug("send: len %d (includes padlen %d)", packet_length+4, padlen));

	/* compute MAC over seqnr and packet(length fields, payload, padding) */
	if (mac && mac->enabled) {
		macbuf = mac_compute(mac, active_state->p_send.seqnr,
		    buffer_ptr(&active_state->outgoing_packet),
		    buffer_len(&active_state->outgoing_packet));
		DBG(debug("done calc MAC out #%d", active_state->p_send.seqnr));
	}
	/* encrypt packet and append to output buffer. */
	cp = buffer_append_space(&active_state->output,
	    buffer_len(&active_state->outgoing_packet));
	cipher_crypt(&active_state->send_context, cp,
	    buffer_ptr(&active_state->outgoing_packet),
	    buffer_len(&active_state->outgoing_packet));
	/* append unencrypted MAC */
	if (mac && mac->enabled)
		buffer_append(&active_state->output, macbuf, mac->mac_len);
#ifdef PACKET_DEBUG
	fprintf(stderr, "encrypted: ");
	buffer_dump(&active_state->output);
#endif
	/* increment sequence number for outgoing packets */
	if (++active_state->p_send.seqnr == 0)
		logit("outgoing seqnr wraps around");
	if (++active_state->p_send.packets == 0)
		if (!(datafellows & SSH_BUG_NOREKEY))
			fatal("XXX too many packets with same key");
	active_state->p_send.blocks += (packet_length + 4) / block_size;
	active_state->p_send.bytes += packet_length + 4;
	buffer_clear(&active_state->outgoing_packet);

	if (type == SSH2_MSG_NEWKEYS)
		set_newkeys(MODE_OUT);
	else if (type == SSH2_MSG_USERAUTH_SUCCESS && active_state->server_side)
		packet_enable_delayed_compress();
}

static void
packet_send2(void)
{
	struct packet *p;
	u_char type, *cp;

	cp = buffer_ptr(&active_state->outgoing_packet);
	type = cp[5];

	/* during rekeying we can only send key exchange messages */
	if (active_state->rekeying) {
		if (!((type >= SSH2_MSG_TRANSPORT_MIN) &&
		    (type <= SSH2_MSG_TRANSPORT_MAX))) {
			debug("enqueue packet: %u", type);
			p = xmalloc(sizeof(*p));
			p->type = type;
			memcpy(&p->payload, &active_state->outgoing_packet,
			    sizeof(Buffer));
			buffer_init(&active_state->outgoing_packet);
			TAILQ_INSERT_TAIL(&active_state->outgoing, p, next);
			return;
		}
	}

	/* rekeying starts with sending KEXINIT */
	if (type == SSH2_MSG_KEXINIT)
		active_state->rekeying = 1;

	packet_send2_wrapped();

	/* after a NEWKEYS message we can send the complete queue */
	if (type == SSH2_MSG_NEWKEYS) {
		active_state->rekeying = 0;
		while ((p = TAILQ_FIRST(&active_state->outgoing))) {
			type = p->type;
			debug("dequeue packet: %u", type);
			buffer_free(&active_state->outgoing_packet);
			memcpy(&active_state->outgoing_packet, &p->payload,
			    sizeof(Buffer));
			TAILQ_REMOVE(&active_state->outgoing, p, next);
			xfree(p);
			packet_send2_wrapped();
		}
	}
}

void
packet_send(void)
{
	if (compat20)
		packet_send2();
	else
		packet_send1();
	DBG(debug("packet_send done"));
}

/*
 * Waits until a packet has been received, and returns its type.  Note that
 * no other data is processed until this returns, so this function should not
 * be used during the interactive session.
 */

int
packet_read_seqnr(u_int32_t *seqnr_p)
{
	int type, len, ret, ms_remain;
	fd_set *setp;
	char buf[8192];
	struct timeval timeout, start, *timeoutp = NULL;

	DBG(debug("packet_read()"));

	setp = (fd_set *)xcalloc(howmany(active_state->connection_in + 1,
	    NFDBITS), sizeof(fd_mask));

	/* Since we are blocking, ensure that all written packets have been sent. */
	packet_write_wait();

	/* Stay in the loop until we have received a complete packet. */
	for (;;) {
		/* Try to read a packet from the buffer. */
		type = packet_read_poll_seqnr(seqnr_p);
		if (!compat20 && (
		    type == SSH_SMSG_SUCCESS
		    || type == SSH_SMSG_FAILURE
		    || type == SSH_CMSG_EOF
		    || type == SSH_CMSG_EXIT_CONFIRMATION))
			packet_check_eom();
		/* If we got a packet, return it. */
		if (type != SSH_MSG_NONE) {
			xfree(setp);
			return type;
		}
		/*
		 * Otherwise, wait for some data to arrive, add it to the
		 * buffer, and try again.
		 */
		memset(setp, 0, howmany(active_state->connection_in + 1,
		    NFDBITS) * sizeof(fd_mask));
		FD_SET(active_state->connection_in, setp);

		if (active_state->packet_timeout_ms > 0) {
			ms_remain = active_state->packet_timeout_ms;
			timeoutp = &timeout;
		}
		/* Wait for some data to arrive. */
		for (;;) {
			if (active_state->packet_timeout_ms != -1) {
				ms_to_timeval(&timeout, ms_remain);
				gettimeofday(&start, NULL);
			}
			if ((ret = select(active_state->connection_in + 1, setp,
			    NULL, NULL, timeoutp)) >= 0)
				break;
			if (errno != EAGAIN && errno != EINTR)
				break;
			if (active_state->packet_timeout_ms == -1)
				continue;
			ms_subtract_diff(&start, &ms_remain);
			if (ms_remain <= 0) {
				ret = 0;
				break;
			}
		}
		if (ret == 0) {
			logit("Connection to %.200s timed out while "
			    "waiting to read", get_remote_ipaddr());
			cleanup_exit(255);
		}
		/* Read data from the socket. */
		len = read(active_state->connection_in, buf, sizeof(buf));
		if (len == 0) {
			logit("Connection closed by %.200s", get_remote_ipaddr());
			cleanup_exit(255);
		}
		if (len < 0)
			fatal("Read from socket failed: %.100s", strerror(errno));
		/* Append it to the buffer. */
		packet_process_incoming(buf, len);
	}
	/* NOTREACHED */
}

int
packet_read(void)
{
	return packet_read_seqnr(NULL);
}

/*
 * Waits until a packet has been received, verifies that its type matches
 * that given, and gives a fatal error and exits if there is a mismatch.
 */

void
packet_read_expect(int expected_type)
{
	int type;

	type = packet_read();
	if (type != expected_type)
		packet_disconnect("Protocol error: expected packet type %d, got %d",
		    expected_type, type);
}

/* Checks if a full packet is available in the data received so far via
 * packet_process_incoming.  If so, reads the packet; otherwise returns
 * SSH_MSG_NONE.  This does not wait for data from the connection.
 *
 * SSH_MSG_DISCONNECT is handled specially here.  Also,
 * SSH_MSG_IGNORE messages are skipped by this function and are never returned
 * to higher levels.
 */

static int
packet_read_poll1(void)
{
	u_int len, padded_len;
	u_char *cp, type;
	u_int checksum, stored_checksum;

	/* Check if input size is less than minimum packet size. */
	if (buffer_len(&active_state->input) < 4 + 8)
		return SSH_MSG_NONE;
	/* Get length of incoming packet. */
	cp = buffer_ptr(&active_state->input);
	len = get_u32(cp);
	if (len < 1 + 2 + 2 || len > 256 * 1024)
		packet_disconnect("Bad packet length %u.", len);
	padded_len = (len + 8) & ~7;

	/* Check if the packet has been entirely received. */
	if (buffer_len(&active_state->input) < 4 + padded_len)
		return SSH_MSG_NONE;

	/* The entire packet is in buffer. */

	/* Consume packet length. */
	buffer_consume(&active_state->input, 4);

	/*
	 * Cryptographic attack detector for ssh
	 * (C)1998 CORE-SDI, Buenos Aires Argentina
	 * Ariel Futoransky(futo@@core-sdi.com)
	 */
	if (!active_state->receive_context.plaintext) {
		switch (detect_attack(buffer_ptr(&active_state->input),
		    padded_len)) {
		case DEATTACK_DETECTED:
			packet_disconnect("crc32 compensation attack: "
			    "network attack detected");
		case DEATTACK_DOS_DETECTED:
			packet_disconnect("deattack denial of "
			    "service detected");
		}
	}

	/* Decrypt data to incoming_packet. */
	buffer_clear(&active_state->incoming_packet);
	cp = buffer_append_space(&active_state->incoming_packet, padded_len);
	cipher_crypt(&active_state->receive_context, cp,
	    buffer_ptr(&active_state->input), padded_len);

	buffer_consume(&active_state->input, padded_len);

#ifdef PACKET_DEBUG
	fprintf(stderr, "read_poll plain: ");
	buffer_dump(&active_state->incoming_packet);
#endif

	/* Compute packet checksum. */
	checksum = ssh_crc32(buffer_ptr(&active_state->incoming_packet),
	    buffer_len(&active_state->incoming_packet) - 4);

	/* Skip padding. */
	buffer_consume(&active_state->incoming_packet, 8 - len % 8);

	/* Test check bytes. */
	if (len != buffer_len(&active_state->incoming_packet))
		packet_disconnect("packet_read_poll1: len %d != buffer_len %d.",
		    len, buffer_len(&active_state->incoming_packet));

	cp = (u_char *)buffer_ptr(&active_state->incoming_packet) + len - 4;
	stored_checksum = get_u32(cp);
	if (checksum != stored_checksum)
		packet_disconnect("Corrupted check bytes on input.");
	buffer_consume_end(&active_state->incoming_packet, 4);

	if (active_state->packet_compression) {
		buffer_clear(&active_state->compression_buffer);
		buffer_uncompress(&active_state->incoming_packet,
		    &active_state->compression_buffer);
		buffer_clear(&active_state->incoming_packet);
		buffer_append(&active_state->incoming_packet,
		    buffer_ptr(&active_state->compression_buffer),
		    buffer_len(&active_state->compression_buffer));
	}
	active_state->p_read.packets++;
	active_state->p_read.bytes += padded_len + 4;
	type = buffer_get_char(&active_state->incoming_packet);
	if (type < SSH_MSG_MIN || type > SSH_MSG_MAX)
		packet_disconnect("Invalid ssh1 packet type: %d", type);
	return type;
}

static int
packet_read_poll2(u_int32_t *seqnr_p)
{
	u_int padlen, need;
	u_char *macbuf, *cp, type;
	u_int maclen, block_size;
	Enc *enc   = NULL;
	Mac *mac   = NULL;
	Comp *comp = NULL;

	if (active_state->packet_discard)
		return SSH_MSG_NONE;

	if (active_state->newkeys[MODE_IN] != NULL) {
		enc  = &active_state->newkeys[MODE_IN]->enc;
		mac  = &active_state->newkeys[MODE_IN]->mac;
		comp = &active_state->newkeys[MODE_IN]->comp;
	}
	maclen = mac && mac->enabled ? mac->mac_len : 0;
	block_size = enc ? enc->block_size : 8;

	if (active_state->packlen == 0) {
		/*
		 * check if input size is less than the cipher block size,
		 * decrypt first block and extract length of incoming packet
		 */
		if (buffer_len(&active_state->input) < block_size)
			return SSH_MSG_NONE;
		buffer_clear(&active_state->incoming_packet);
		cp = buffer_append_space(&active_state->incoming_packet,
		    block_size);
		cipher_crypt(&active_state->receive_context, cp,
		    buffer_ptr(&active_state->input), block_size);
		cp = buffer_ptr(&active_state->incoming_packet);
		active_state->packlen = get_u32(cp);
		if (active_state->packlen < 1 + 4 ||
		    active_state->packlen > PACKET_MAX_SIZE) {
#ifdef PACKET_DEBUG
			buffer_dump(&active_state->incoming_packet);
#endif
			logit("Bad packet length %u.", active_state->packlen);
			packet_start_discard(enc, mac, active_state->packlen,
			    PACKET_MAX_SIZE);
			return SSH_MSG_NONE;
		}
		DBG(debug("input: packet len %u", active_state->packlen+4));
		buffer_consume(&active_state->input, block_size);
	}
	/* we have a partial packet of block_size bytes */
	need = 4 + active_state->packlen - block_size;
	DBG(debug("partial packet %d, need %d, maclen %d", block_size,
	    need, maclen));
	if (need % block_size != 0) {
		logit("padding error: need %d block %d mod %d",
		    need, block_size, need % block_size);
		packet_start_discard(enc, mac, active_state->packlen,
		    PACKET_MAX_SIZE - block_size);
		return SSH_MSG_NONE;
	}
	/*
	 * check if the entire packet has been received and
	 * decrypt into incoming_packet
	 */
	if (buffer_len(&active_state->input) < need + maclen)
		return SSH_MSG_NONE;
#ifdef PACKET_DEBUG
	fprintf(stderr, "read_poll enc/full: ");
	buffer_dump(&active_state->input);
#endif
	cp = buffer_append_space(&active_state->incoming_packet, need);
	cipher_crypt(&active_state->receive_context, cp,
	    buffer_ptr(&active_state->input), need);
	buffer_consume(&active_state->input, need);
	/*
	 * compute MAC over seqnr and packet,
	 * increment sequence number for incoming packet
	 */
	if (mac && mac->enabled) {
		macbuf = mac_compute(mac, active_state->p_read.seqnr,
		    buffer_ptr(&active_state->incoming_packet),
		    buffer_len(&active_state->incoming_packet));
		if (memcmp(macbuf, buffer_ptr(&active_state->input),
		    mac->mac_len) != 0) {
			logit("Corrupted MAC on input.");
			if (need > PACKET_MAX_SIZE)
				fatal("internal error need %d", need);
			packet_start_discard(enc, mac, active_state->packlen,
			    PACKET_MAX_SIZE - need);
			return SSH_MSG_NONE;
		}
				
		DBG(debug("MAC #%d ok", active_state->p_read.seqnr));
		buffer_consume(&active_state->input, mac->mac_len);
	}
	/* XXX now it's safe to use fatal/packet_disconnect */
	if (seqnr_p != NULL)
		*seqnr_p = active_state->p_read.seqnr;
	if (++active_state->p_read.seqnr == 0)
		logit("incoming seqnr wraps around");
	if (++active_state->p_read.packets == 0)
		if (!(datafellows & SSH_BUG_NOREKEY))
			fatal("XXX too many packets with same key");
	active_state->p_read.blocks += (active_state->packlen + 4) / block_size;
	active_state->p_read.bytes += active_state->packlen + 4;

	/* get padlen */
	cp = buffer_ptr(&active_state->incoming_packet);
	padlen = cp[4];
	DBG(debug("input: padlen %d", padlen));
	if (padlen < 4)
		packet_disconnect("Corrupted padlen %d on input.", padlen);

	/* skip packet size + padlen, discard padding */
	buffer_consume(&active_state->incoming_packet, 4 + 1);
	buffer_consume_end(&active_state->incoming_packet, padlen);

	DBG(debug("input: len before de-compress %d",
	    buffer_len(&active_state->incoming_packet)));
	if (comp && comp->enabled) {
		buffer_clear(&active_state->compression_buffer);
		buffer_uncompress(&active_state->incoming_packet,
		    &active_state->compression_buffer);
		buffer_clear(&active_state->incoming_packet);
		buffer_append(&active_state->incoming_packet,
		    buffer_ptr(&active_state->compression_buffer),
		    buffer_len(&active_state->compression_buffer));
		DBG(debug("input: len after de-compress %d",
		    buffer_len(&active_state->incoming_packet)));
	}
	/*
	 * get packet type, implies consume.
	 * return length of payload (without type field)
	 */
	type = buffer_get_char(&active_state->incoming_packet);
	if (type < SSH2_MSG_MIN || type >= SSH2_MSG_LOCAL_MIN)
		packet_disconnect("Invalid ssh2 packet type: %d", type);
	if (type == SSH2_MSG_NEWKEYS)
		set_newkeys(MODE_IN);
	else if (type == SSH2_MSG_USERAUTH_SUCCESS &&
	    !active_state->server_side)
		packet_enable_delayed_compress();
#ifdef PACKET_DEBUG
	fprintf(stderr, "read/plain[%d]:\r\n", type);
	buffer_dump(&active_state->incoming_packet);
#endif
	/* reset for next packet */
	active_state->packlen = 0;
	return type;
}

int
packet_read_poll_seqnr(u_int32_t *seqnr_p)
{
	u_int reason, seqnr;
	u_char type;
	char *msg;

	for (;;) {
		if (compat20) {
			type = packet_read_poll2(seqnr_p);
			if (type) {
				active_state->keep_alive_timeouts = 0;
				DBG(debug("received packet type %d", type));
			}
			switch (type) {
			case SSH2_MSG_IGNORE:
				packet_consume_ignoremsg();
				debug3("Received SSH2_MSG_IGNORE");
				break;
			case SSH2_MSG_DEBUG:
				packet_get_char();
				msg = packet_get_string(NULL);
				debug("Remote: %.900s", msg);
				xfree(msg);
				msg = packet_get_string(NULL);
				xfree(msg);
				break;
			case SSH2_MSG_DISCONNECT:
				reason = packet_get_int();
				msg = packet_get_string(NULL);
				logit("Received disconnect from %s: %u: %.400s",
				    get_remote_ipaddr(), reason, msg);
				xfree(msg);
				cleanup_exit(255);
				break;
			case SSH2_MSG_UNIMPLEMENTED:
				seqnr = packet_get_int();
				debug("Received SSH2_MSG_UNIMPLEMENTED for %u",
				    seqnr);
				break;
			default:
				return type;
			}
		} else {
			type = packet_read_poll1();
			switch (type) {
			case SSH_MSG_IGNORE:
				packet_consume_ignoremsg();
				break;
			case SSH_MSG_DEBUG:
				msg = packet_get_string(NULL);
				debug("Remote: %.900s", msg);
				xfree(msg);
				break;
			case SSH_MSG_DISCONNECT:
				msg = packet_get_string(NULL);
				logit("Received disconnect from %s: %.400s",
				    get_remote_ipaddr(), msg);
				cleanup_exit(255);
				break;
			default:
				if (type) {
					DBG(debug("received packet type %d", type));
				}
				return type;
			}
		}
	}
}

int
packet_read_poll(void)
{
	return packet_read_poll_seqnr(NULL);
}

/*
 * Buffers the given amount of input characters.  This is intended to be used
 * together with packet_read_poll.
 */

void
packet_process_incoming(const char *buf, u_int len)
{
	if (active_state->packet_discard) {
		active_state->keep_alive_timeouts = 0; /* ?? */
		if (len >= active_state->packet_discard)
			packet_stop_discard();
		active_state->packet_discard -= len;
		return;
	}
	buffer_append(&active_state->input, buf, len);
}

/* Returns a character from the packet. */

u_int
packet_get_char(void)
{
	char ch;

	buffer_get(&active_state->incoming_packet, &ch, 1);
	return (u_char) ch;
}

/* Returns an integer from the packet data. */

u_int
packet_get_int(void)
{
	return buffer_get_int(&active_state->incoming_packet);
}

/* Returns an 64 bit integer from the packet data. */

u_int64_t
packet_get_int64(void)
{
	return buffer_get_int64(&active_state->incoming_packet);
}

/*
 * Returns an arbitrary precision integer from the packet data.  The integer
 * must have been initialized before this call.
 */

void
packet_get_bignum(BIGNUM * value)
{
	buffer_get_bignum(&active_state->incoming_packet, value);
}

void
packet_get_bignum2(BIGNUM * value)
{
	buffer_get_bignum2(&active_state->incoming_packet, value);
}

void *
packet_get_raw(u_int *length_ptr)
{
	u_int bytes = buffer_len(&active_state->incoming_packet);

	if (length_ptr != NULL)
		*length_ptr = bytes;
	return buffer_ptr(&active_state->incoming_packet);
}

int
packet_remaining(void)
{
	return buffer_len(&active_state->incoming_packet);
}

/*
 * Returns a string from the packet data.  The string is allocated using
 * xmalloc; it is the responsibility of the calling program to free it when
 * no longer needed.  The length_ptr argument may be NULL, or point to an
 * integer into which the length of the string is stored.
 */

void *
packet_get_string(u_int *length_ptr)
{
	return buffer_get_string(&active_state->incoming_packet, length_ptr);
}

void *
packet_get_string_ptr(u_int *length_ptr)
{
	return buffer_get_string_ptr(&active_state->incoming_packet, length_ptr);
}

/*
 * Sends a diagnostic message from the server to the client.  This message
 * can be sent at any time (but not while constructing another message). The
 * message is printed immediately, but only if the client is being executed
 * in verbose mode.  These messages are primarily intended to ease debugging
 * authentication problems.   The length of the formatted message must not
 * exceed 1024 bytes.  This will automatically call packet_write_wait.
 */

void
packet_send_debug(const char *fmt,...)
{
	char buf[1024];
	va_list args;

	if (compat20 && (datafellows & SSH_BUG_DEBUG))
		return;

	va_start(args, fmt);
	vsnprintf(buf, sizeof(buf), fmt, args);
	va_end(args);

	if (compat20) {
		packet_start(SSH2_MSG_DEBUG);
		packet_put_char(0);	/* bool: always display */
		packet_put_cstring(buf);
		packet_put_cstring("");
	} else {
		packet_start(SSH_MSG_DEBUG);
		packet_put_cstring(buf);
	}
	packet_send();
	packet_write_wait();
}

/*
 * Logs the error plus constructs and sends a disconnect packet, closes the
 * connection, and exits.  This function never returns. The error message
 * should not contain a newline.  The length of the formatted message must
 * not exceed 1024 bytes.
 */

void
packet_disconnect(const char *fmt,...)
{
	char buf[1024];
	va_list args;
	static int disconnecting = 0;

	if (disconnecting)	/* Guard against recursive invocations. */
		fatal("packet_disconnect called recursively.");
	disconnecting = 1;

	/*
	 * Format the message.  Note that the caller must make sure the
	 * message is of limited size.
	 */
	va_start(args, fmt);
	vsnprintf(buf, sizeof(buf), fmt, args);
	va_end(args);

	/* Display the error locally */
	logit("Disconnecting: %.100s", buf);

	/* Send the disconnect message to the other side, and wait for it to get sent. */
	if (compat20) {
		packet_start(SSH2_MSG_DISCONNECT);
		packet_put_int(SSH2_DISCONNECT_PROTOCOL_ERROR);
		packet_put_cstring(buf);
		packet_put_cstring("");
	} else {
		packet_start(SSH_MSG_DISCONNECT);
		packet_put_cstring(buf);
	}
	packet_send();
	packet_write_wait();

	/* Stop listening for connections. */
	channel_close_all();

	/* Close the connection. */
	packet_close();
	cleanup_exit(255);
}

/* Checks if there is any buffered output, and tries to write some of the output. */

void
packet_write_poll(void)
{
	int len = buffer_len(&active_state->output);

	if (len > 0) {
		len = write(active_state->connection_out,
		    buffer_ptr(&active_state->output), len);
		if (len == -1) {
			if (errno == EINTR || errno == EAGAIN)
				return;
			fatal("Write failed: %.100s", strerror(errno));
		}
		if (len == 0)
			fatal("Write connection closed");
		buffer_consume(&active_state->output, len);
	}
}

/*
 * Calls packet_write_poll repeatedly until all pending output data has been
 * written.
 */

void
packet_write_wait(void)
{
	fd_set *setp;
	int ret, ms_remain;
	struct timeval start, timeout, *timeoutp = NULL;

	setp = (fd_set *)xcalloc(howmany(active_state->connection_out + 1,
	    NFDBITS), sizeof(fd_mask));
	packet_write_poll();
	while (packet_have_data_to_write()) {
		memset(setp, 0, howmany(active_state->connection_out + 1,
		    NFDBITS) * sizeof(fd_mask));
		FD_SET(active_state->connection_out, setp);

		if (active_state->packet_timeout_ms > 0) {
			ms_remain = active_state->packet_timeout_ms;
			timeoutp = &timeout;
		}
		for (;;) {
			if (active_state->packet_timeout_ms != -1) {
				ms_to_timeval(&timeout, ms_remain);
				gettimeofday(&start, NULL);
			}
			if ((ret = select(active_state->connection_out + 1,
			    NULL, setp, NULL, timeoutp)) >= 0)
				break;
			if (errno != EAGAIN && errno != EINTR)
				break;
			if (active_state->packet_timeout_ms == -1)
				continue;
			ms_subtract_diff(&start, &ms_remain);
			if (ms_remain <= 0) {
				ret = 0;
				break;
			}
		}
		if (ret == 0) {
			logit("Connection to %.200s timed out while "
			    "waiting to write", get_remote_ipaddr());
			cleanup_exit(255);
		}
		packet_write_poll();
	}
	xfree(setp);
}

/* Returns true if there is buffered data to write to the connection. */

int
packet_have_data_to_write(void)
{
	return buffer_len(&active_state->output) != 0;
}

/* Returns true if there is not too much data to write to the connection. */

int
packet_not_very_much_data_to_write(void)
{
	if (active_state->interactive_mode)
		return buffer_len(&active_state->output) < 16384;
	else
		return buffer_len(&active_state->output) < 128 * 1024;
}

static void
packet_set_tos(int interactive)
{
	int tos = interactive ? IPTOS_LOWDELAY : IPTOS_THROUGHPUT;

	if (!packet_connection_is_on_socket() ||
	    !packet_connection_is_ipv4())
		return;
	if (setsockopt(active_state->connection_in, IPPROTO_IP, IP_TOS, &tos,
	    sizeof(tos)) < 0)
		error("setsockopt IP_TOS %d: %.100s:",
		    tos, strerror(errno));
}

/* Informs that the current session is interactive.  Sets IP flags for that. */

void
packet_set_interactive(int interactive)
{
	if (active_state->set_interactive_called)
		return;
	active_state->set_interactive_called = 1;

	/* Record that we are in interactive mode. */
	active_state->interactive_mode = interactive;

	/* Only set socket options if using a socket.  */
	if (!packet_connection_is_on_socket())
		return;
	set_nodelay(active_state->connection_in);
	packet_set_tos(interactive);
}

/* Returns true if the current connection is interactive. */

int
packet_is_interactive(void)
{
	return active_state->interactive_mode;
}

int
packet_set_maxsize(u_int s)
{
	if (active_state->set_maxsize_called) {
		logit("packet_set_maxsize: called twice: old %d new %d",
		    active_state->max_packet_size, s);
		return -1;
	}
	if (s < 4 * 1024 || s > 1024 * 1024) {
		logit("packet_set_maxsize: bad size %d", s);
		return -1;
	}
	active_state->set_maxsize_called = 1;
	debug("packet_set_maxsize: setting to %d", s);
	active_state->max_packet_size = s;
	return s;
}

int
packet_inc_alive_timeouts(void)
{
	return ++active_state->keep_alive_timeouts;
}

void
packet_set_alive_timeouts(int ka)
{
	active_state->keep_alive_timeouts = ka;
}

u_int
packet_get_maxsize(void)
{
	return active_state->max_packet_size;
}

/* roundup current message to pad bytes */
void
packet_add_padding(u_char pad)
{
	active_state->extra_pad = pad;
}

/*
 * 9.2.  Ignored Data Message
 *
 *   byte      SSH_MSG_IGNORE
 *   string    data
 *
 * All implementations MUST understand (and ignore) this message at any
 * time (after receiving the protocol version). No implementation is
 * required to send them. This message can be used as an additional
 * protection measure against advanced traffic analysis techniques.
 */
void
packet_send_ignore(int nbytes)
{
	u_int32_t rnd = 0;
	int i;

	packet_start(compat20 ? SSH2_MSG_IGNORE : SSH_MSG_IGNORE);
	packet_put_int(nbytes);
	for (i = 0; i < nbytes; i++) {
		if (i % 4 == 0)
			rnd = arc4random();
		packet_put_char((u_char)rnd & 0xff);
		rnd >>= 8;
	}
}

#define MAX_PACKETS	(1U<<31)
int
packet_need_rekeying(void)
{
	if (datafellows & SSH_BUG_NOREKEY)
		return 0;
	return
	    (active_state->p_send.packets > MAX_PACKETS) ||
	    (active_state->p_read.packets > MAX_PACKETS) ||
	    (active_state->max_blocks_out &&
	        (active_state->p_send.blocks > active_state->max_blocks_out)) ||
	    (active_state->max_blocks_in &&
	        (active_state->p_read.blocks > active_state->max_blocks_in));
}

void
packet_set_rekey_limit(u_int32_t bytes)
{
	active_state->rekey_limit = bytes;
}

void
packet_set_server(void)
{
	active_state->server_side = 1;
}

void
packet_set_authenticated(void)
{
	active_state->after_authentication = 1;
}

void *
packet_get_input(void)
{
	return (void *)&active_state->input;
}

void *
packet_get_output(void)
{
	return (void *)&active_state->output;
}

void *
packet_get_newkeys(int mode)
{
	return (void *)active_state->newkeys[mode];
}

static void
packet_consume_ignoremsg(void)
{
	u_int n;
	u_int8_t *b;

	if ((b = packet_get_raw(&n)) == NULL)
		return;

	arc4random_pushb_fast(b, n);
}
@


1.17
log
@use arc4random() a bit more efficiently
@
text
@a74 1
#include "roaming.h"
d76 1
a76 1
__RCSID("$MirOS: src/usr.bin/ssh/packet.c,v 1.16 2009/10/04 14:29:05 tg Exp $");
d195 1
a195 1
static struct session_state *active_state, *backup_state;
d1016 1
a1016 1
	int type, len, ret, ms_remain, cont;
d1081 1
a1081 5
		do {
			cont = 0;
			len = roaming_read(active_state->connection_in, buf,
			    sizeof(buf), &cont);
		} while (len == 0 && cont);
a1629 1
	int cont;
d1632 2
a1633 3
		cont = 0;
		len = roaming_write(active_state->connection_out,
		    buffer_ptr(&active_state->output), len, &cont);
d1639 1
a1639 1
		if (len == 0 && !cont)
a1877 47
/*
 * Save the state for the real connection, and use a separate state when
 * resuming a suspended connection.
 */
void
packet_backup_state(void)
{
	struct session_state *tmp;

	close(active_state->connection_in);
	active_state->connection_in = -1;
	close(active_state->connection_out);
	active_state->connection_out = -1;
	if (backup_state)
		tmp = backup_state;
	else
		tmp = alloc_session_state();
	backup_state = active_state;
	active_state = tmp;
}

/*
 * Swap in the old state when resuming a connecion.
 */
void
packet_restore_state(void)
{
	struct session_state *tmp;
	void *buf;
	u_int len;

	tmp = backup_state;
	backup_state = active_state;
	active_state = tmp;
	active_state->connection_in = backup_state->connection_in;
	backup_state->connection_in = -1;
	active_state->connection_out = backup_state->connection_out;
	backup_state->connection_out = -1;
	len = buffer_len(&backup_state->input);
	if (len > 0) {
		buf = buffer_ptr(&backup_state->input);
		buffer_append(&active_state->input, buf, len);
		buffer_clear(&backup_state->input);
		add_recv_bytes(len);
	}
}

@


1.16
log
@• merge newer OpenSSH
• KNF in our diff – style(9)
• some const cleanliness (build with __CRAZY=Yes mostly)
@
text
@d77 1
a77 1
__RCSID("$MirOS: src/usr.bin/ssh/packet.c,v 1.15 2009/03/22 15:01:17 tg Exp $");
d843 1
a843 2
	u_int i, len;
	u_int32_t rnd = 0;
d904 1
a904 6
		for (i = 0; i < padlen; i++) {
			if (i % 4 == 0)
				rnd = arc4random();
			cp[i] = rnd & 0xff;
			rnd >>= 8;
		}
d1941 1
a1941 2
	if (n != 0)
		arc4random_pushb(b, n);
@


1.15
log
@merge and tweak ciphers and MACs
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.160 2009/02/13 11:50:21 markus Exp $ */
d75 1
d77 3
a79 1
__RCSID("$MirOS: src/usr.bin/ssh/packet.c,v 1.14 2008/12/16 22:13:28 tg Exp $");
d89 34
a122 8
/*
 * This variable contains the file descriptors used for communicating with
 * the other side.  connection_in is used for reading; connection_out for
 * writing.  These can be the same descriptor, in which case it is assumed to
 * be a socket.
 */
static int connection_in = -1;
static int connection_out = -1;
d124 2
a125 2
/* Protocol flags for the remote side. */
static u_int remote_protocol_flags = 0;
d127 2
a128 2
/* Encryption context for receiving data.  This is only used for decryption. */
static CipherContext receive_context;
d130 2
a131 2
/* Encryption context for sending data.  This is only used for encryption. */
static CipherContext send_context;
d133 3
a135 2
/* Buffer for raw input data from the socket. */
Buffer input;
d137 5
a141 2
/* Buffer for raw output data going to the socket. */
Buffer output;
d143 2
a144 2
/* Buffer for the partial outgoing packet being constructed. */
static Buffer outgoing_packet;
d146 2
a147 2
/* Buffer for the incoming packet currently being processed. */
static Buffer incoming_packet;
d149 2
a150 3
/* Scratch buffer for packet compression/decompression. */
static Buffer compression_buffer;
static int compression_buffer_ready = 0;
d152 2
a153 2
/* Flag indicating whether packet compression/decompression is enabled. */
static int packet_compression = 0;
d155 2
a156 2
/* default maximum packet size */
u_int max_packet_size = 32768;
d158 1
a158 2
/* Flag indicating whether this module has been initialized. */
static int initialized = 0;
d160 2
a161 2
/* Set to true if the connection is interactive. */
static int interactive_mode = 0;
d163 3
a165 2
/* Set to true if we are the server side. */
static int server_side = 0;
d167 2
a168 2
/* Set to true if we are authenticated. */
static int after_authentication = 0;
d170 3
a172 1
int keep_alive_timeouts = 0;
d174 2
a175 2
/* Set to the maximum time that we will wait to send or receive a packet */
static int packet_timeout_ms = -1;
d177 3
a179 8
/* Session key information for Encryption and MAC */
Newkeys *newkeys[MODE_MAX];
static struct packet_state {
	u_int32_t seqnr;
	u_int32_t packets;
	u_int64_t blocks;
	u_int64_t bytes;
} p_read, p_send;
d181 2
a182 2
static u_int64_t max_blocks_in, max_blocks_out;
static u_int32_t rekey_limit;
d184 2
a185 3
/* Session key for protocol v1 */
static u_char ssh1_key[SSH_SESSION_KEY_LENGTH];
static u_int ssh1_keylen;
d187 2
a188 2
/* roundup current message to extra_pad bytes */
static u_char extra_pad = 0;
d190 2
a191 3
/* XXX discard incoming data after MAC error */
static u_int packet_discard = 0;
static Mac *packet_discard_mac = NULL;
d193 1
a193 4
struct packet {
	TAILQ_ENTRY(packet) next;
	u_char type;
	Buffer payload;
d195 16
a210 1
TAILQ_HEAD(, packet) outgoing;
d226 17
a242 15
	connection_in = fd_in;
	connection_out = fd_out;
	cipher_init(&send_context, none, (const u_char *)&fd_in,
	    sizeof (fd_in), NULL, 0, CIPHER_ENCRYPT);
	cipher_init(&receive_context, none, (const u_char *)&fd_out,
	    sizeof (fd_out), NULL, 0, CIPHER_DECRYPT);
	newkeys[MODE_IN] = newkeys[MODE_OUT] = NULL;
	if (!initialized) {
		initialized = 1;
		buffer_init(&input);
		buffer_init(&output);
		buffer_init(&outgoing_packet);
		buffer_init(&incoming_packet);
		TAILQ_INIT(&outgoing);
		p_send.packets = p_read.packets = 0;
d250 1
a250 1
		packet_timeout_ms = -1;
d254 1
a254 1
		packet_timeout_ms = INT_MAX;
d256 1
a256 1
		packet_timeout_ms = timeout * count * 1000;
d262 1
a262 1
	if (packet_discard_mac) {
d266 7
a272 5
		while (buffer_len(&incoming_packet) < PACKET_MAX_SIZE)
			buffer_append(&incoming_packet, buf, sizeof(buf));
		(void) mac_compute(packet_discard_mac,
		    p_read.seqnr,
		    buffer_ptr(&incoming_packet),
d285 2
a286 2
		packet_discard_mac = mac;
	if (buffer_len(&input) >= discard)
d288 2
a289 1
	packet_discard = discard - buffer_len(&input);
d301 1
a301 1
	if (connection_in == connection_out)
d305 2
a306 1
	if (getpeername(connection_in, (struct sockaddr *)&from, &fromlen) < 0)
d310 2
a311 1
	if (getpeername(connection_out, (struct sockaddr *)&to, &tolen) < 0)
d332 1
a332 1
		cc = &send_context;
d334 1
a334 1
		cc = &receive_context;
d345 1
a345 1
		cc = &send_context;
d347 1
a347 1
		cc = &receive_context;
d358 1
a358 1
		cc = &send_context;
d360 1
a360 1
		cc = &receive_context;
d371 1
a371 1
		cc = &send_context;
d373 1
a373 1
		cc = &receive_context;
d384 1
a384 1
		cc = &send_context;
d386 1
a386 1
		cc = &receive_context;
d394 1
a394 1
	return (cipher_get_number(receive_context.cipher));
d403 2
a404 1
	state = (mode == MODE_IN) ? &p_read : &p_send;
d421 2
a422 1
	state = (mode == MODE_IN) ? &p_read : &p_send;
d438 2
a439 1
	if (getsockname(connection_out, (struct sockaddr *)&to, &tolen) < 0)
d452 1
a452 1
	set_nonblock(connection_in);
d454 2
a455 2
	if (connection_out != connection_in)
		set_nonblock(connection_out);
d463 1
a463 1
	return connection_in;
d471 1
a471 1
	return connection_out;
d479 1
a479 1
	if (!initialized)
d481 4
a484 4
	initialized = 0;
	if (connection_in == connection_out) {
		shutdown(connection_out, SHUT_RDWR);
		close(connection_out);
d486 2
a487 2
		close(connection_in);
		close(connection_out);
d489 6
a494 6
	buffer_free(&input);
	buffer_free(&output);
	buffer_free(&outgoing_packet);
	buffer_free(&incoming_packet);
	if (compression_buffer_ready) {
		buffer_free(&compression_buffer);
d497 2
a498 2
	cipher_cleanup(&send_context);
	cipher_cleanup(&receive_context);
d506 1
a506 1
	remote_protocol_flags = protocol_flags;
d514 1
a514 1
	return remote_protocol_flags;
d525 1
a525 1
	if (compression_buffer_ready == 1)
d527 2
a528 2
	compression_buffer_ready = 1;
	buffer_init(&compression_buffer);
d534 1
a534 1
	if (packet_compression && !compat20)
d536 1
a536 1
	packet_compression = 1;
d560 6
a565 4
	memcpy(ssh1_key, key, keylen);
	ssh1_keylen = keylen;
	cipher_init(&send_context, cipher, key, keylen, NULL, 0, CIPHER_ENCRYPT);
	cipher_init(&receive_context, cipher, key, keylen, NULL, 0, CIPHER_DECRYPT);
d572 3
a574 3
		return (ssh1_keylen);
	memcpy(key, ssh1_key, ssh1_keylen);
	return (ssh1_keylen);
d588 2
a589 2
	buffer_clear(&outgoing_packet);
	buffer_append(&outgoing_packet, buf, len);
d598 1
a598 1
	buffer_append(&outgoing_packet, &ch, 1);
d604 7
a610 1
	buffer_put_int(&outgoing_packet, value);
d616 1
a616 1
	buffer_put_string(&outgoing_packet, buf, len);
d622 1
a622 1
	buffer_put_cstring(&outgoing_packet, str);
d628 1
a628 1
	buffer_append(&outgoing_packet, buf, len);
d634 1
a634 1
	buffer_put_bignum(&outgoing_packet, value);
d640 1
a640 1
	buffer_put_bignum2(&outgoing_packet, value);
d660 2
a661 2
	if (packet_compression) {
		buffer_clear(&compression_buffer);
d663 1
a663 1
		buffer_consume(&outgoing_packet, 8);
d665 8
a672 5
		buffer_append(&compression_buffer, "\0\0\0\0\0\0\0\0", 8);
		buffer_compress(&outgoing_packet, &compression_buffer);
		buffer_clear(&outgoing_packet);
		buffer_append(&outgoing_packet, buffer_ptr(&compression_buffer),
		    buffer_len(&compression_buffer));
d675 1
a675 1
	len = buffer_len(&outgoing_packet) + 4 - 8;
d679 2
a680 2
	if (!send_context.plaintext) {
		cp = buffer_ptr(&outgoing_packet);
d688 1
a688 1
	buffer_consume(&outgoing_packet, 8 - padding);
d691 2
a692 2
	checksum = ssh_crc32(buffer_ptr(&outgoing_packet),
	    buffer_len(&outgoing_packet));
d694 1
a694 1
	buffer_append(&outgoing_packet, buf, 4);
d698 1
a698 1
	buffer_dump(&outgoing_packet);
d703 6
a708 4
	buffer_append(&output, buf, 4);
	cp = buffer_append_space(&output, buffer_len(&outgoing_packet));
	cipher_crypt(&send_context, cp, buffer_ptr(&outgoing_packet),
	    buffer_len(&outgoing_packet));
d712 1
a712 1
	buffer_dump(&output);
d714 4
a717 3
	p_send.packets++;
	p_send.bytes += len + buffer_len(&outgoing_packet);
	buffer_clear(&outgoing_packet);
d739 1
a739 1
		cc = &send_context;
d741 2
a742 2
		p_send.packets = p_send.blocks = 0;
		max_blocks = &max_blocks_out;
d744 1
a744 1
		cc = &receive_context;
d746 2
a747 2
		p_read.packets = p_read.blocks = 0;
		max_blocks = &max_blocks_in;
d749 1
a749 1
	if (newkeys[mode] != NULL) {
d752 3
a754 3
		enc  = &newkeys[mode]->enc;
		mac  = &newkeys[mode]->mac;
		comp = &newkeys[mode]->comp;
d762 1
a762 1
		xfree(newkeys[mode]);
d764 2
a765 2
	newkeys[mode] = kex_get_newkeys(mode);
	if (newkeys[mode] == NULL)
d767 3
a769 3
	enc  = &newkeys[mode]->enc;
	mac  = &newkeys[mode]->mac;
	comp = &newkeys[mode]->comp;
d780 2
a781 2
	    (comp->type == COMP_DELAYED && after_authentication)) &&
	    comp->enabled == 0) {
d797 3
a799 2
	if (rekey_limit)
		*max_blocks = MIN(*max_blocks, rekey_limit / enc->block_size);
d817 1
a817 1
	after_authentication = 1;
d820 1
a820 1
		if (newkeys[mode] == NULL)
d822 1
a822 1
		comp = &newkeys[mode]->comp;
d850 4
a853 4
	if (newkeys[MODE_OUT] != NULL) {
		enc  = &newkeys[MODE_OUT]->enc;
		mac  = &newkeys[MODE_OUT]->mac;
		comp = &newkeys[MODE_OUT]->comp;
d857 1
a857 1
	cp = buffer_ptr(&outgoing_packet);
d862 1
a862 1
	buffer_dump(&outgoing_packet);
d866 1
a866 1
		len = buffer_len(&outgoing_packet);
d868 9
a876 7
		buffer_consume(&outgoing_packet, 5);
		buffer_clear(&compression_buffer);
		buffer_compress(&outgoing_packet, &compression_buffer);
		buffer_clear(&outgoing_packet);
		buffer_append(&outgoing_packet, "\0\0\0\0\0", 5);
		buffer_append(&outgoing_packet, buffer_ptr(&compression_buffer),
		    buffer_len(&compression_buffer));
d878 1
a878 1
		    buffer_len(&outgoing_packet)));
d882 1
a882 1
	len = buffer_len(&outgoing_packet);
d891 1
a891 1
	if (extra_pad) {
d893 4
a896 2
		extra_pad  = roundup(extra_pad, block_size);
		pad = extra_pad - ((len + padlen) % extra_pad);
d898 1
a898 1
		    pad, len, padlen, extra_pad);
d900 1
a900 1
		extra_pad = 0;
d902 2
a903 2
	cp = buffer_append_space(&outgoing_packet, padlen);
	if (enc && !send_context.plaintext) {
d916 2
a917 2
	packet_length = buffer_len(&outgoing_packet) - 4;
	cp = buffer_ptr(&outgoing_packet);
d924 4
a927 4
		macbuf = mac_compute(mac, p_send.seqnr,
		    buffer_ptr(&outgoing_packet),
		    buffer_len(&outgoing_packet));
		DBG(debug("done calc MAC out #%d", p_send.seqnr));
d930 5
a934 3
	cp = buffer_append_space(&output, buffer_len(&outgoing_packet));
	cipher_crypt(&send_context, cp, buffer_ptr(&outgoing_packet),
	    buffer_len(&outgoing_packet));
d937 1
a937 1
		buffer_append(&output, macbuf, mac->mac_len);
d940 1
a940 1
	buffer_dump(&output);
d943 1
a943 1
	if (++p_send.seqnr == 0)
d945 1
a945 1
	if (++p_send.packets == 0)
d948 3
a950 3
	p_send.blocks += (packet_length + 4) / block_size;
	p_send.bytes += packet_length + 4;
	buffer_clear(&outgoing_packet);
d954 1
a954 1
	else if (type == SSH2_MSG_USERAUTH_SUCCESS && server_side)
a960 1
	static int rekeying = 0;
d964 1
a964 1
	cp = buffer_ptr(&outgoing_packet);
d968 1
a968 1
	if (rekeying) {
d974 4
a977 3
			memcpy(&p->payload, &outgoing_packet, sizeof(Buffer));
			buffer_init(&outgoing_packet);
			TAILQ_INSERT_TAIL(&outgoing, p, next);
d984 1
a984 1
		rekeying = 1;
d990 2
a991 2
		rekeying = 0;
		while ((p = TAILQ_FIRST(&outgoing))) {
d994 2
a995 2
			buffer_free(&outgoing_packet);
			memcpy(&outgoing_packet, &p->payload,
d997 1
a997 1
			TAILQ_REMOVE(&outgoing, p, next);
d1023 1
a1023 1
	int type, len, ret, ms_remain;
d1030 2
a1031 2
	setp = (fd_set *)xcalloc(howmany(connection_in+1, NFDBITS),
	    sizeof(fd_mask));
d1055 3
a1057 3
		memset(setp, 0, howmany(connection_in + 1, NFDBITS) *
		    sizeof(fd_mask));
		FD_SET(connection_in, setp);
d1059 2
a1060 2
		if (packet_timeout_ms > 0) {
			ms_remain = packet_timeout_ms;
d1065 1
a1065 1
			if (packet_timeout_ms != -1) {
d1069 2
a1070 2
			if ((ret = select(connection_in + 1, setp, NULL,
			    NULL, timeoutp)) >= 0)
d1072 1
a1072 1
		   	if (errno != EAGAIN && errno != EINTR)
d1074 1
a1074 1
			if (packet_timeout_ms == -1)
d1088 5
a1092 1
		len = read(connection_in, buf, sizeof(buf));
d1144 1
a1144 1
	if (buffer_len(&input) < 4 + 8)
d1147 1
a1147 1
	cp = buffer_ptr(&input);
d1154 1
a1154 1
	if (buffer_len(&input) < 4 + padded_len)
d1160 1
a1160 1
	buffer_consume(&input, 4);
d1167 3
a1169 2
	if (!receive_context.plaintext) {
		switch (detect_attack(buffer_ptr(&input), padded_len)) {
d1180 4
a1183 3
	buffer_clear(&incoming_packet);
	cp = buffer_append_space(&incoming_packet, padded_len);
	cipher_crypt(&receive_context, cp, buffer_ptr(&input), padded_len);
d1185 1
a1185 1
	buffer_consume(&input, padded_len);
d1189 1
a1189 1
	buffer_dump(&incoming_packet);
d1193 2
a1194 2
	checksum = ssh_crc32(buffer_ptr(&incoming_packet),
	    buffer_len(&incoming_packet) - 4);
d1197 1
a1197 1
	buffer_consume(&incoming_packet, 8 - len % 8);
d1200 1
a1200 1
	if (len != buffer_len(&incoming_packet))
d1202 1
a1202 1
		    len, buffer_len(&incoming_packet));
d1204 1
a1204 1
	cp = (u_char *)buffer_ptr(&incoming_packet) + len - 4;
d1208 1
a1208 1
	buffer_consume_end(&incoming_packet, 4);
d1210 12
a1221 10
	if (packet_compression) {
		buffer_clear(&compression_buffer);
		buffer_uncompress(&incoming_packet, &compression_buffer);
		buffer_clear(&incoming_packet);
		buffer_append(&incoming_packet, buffer_ptr(&compression_buffer),
		    buffer_len(&compression_buffer));
	}
	p_read.packets++;
	p_read.bytes += padded_len + 4;
	type = buffer_get_char(&incoming_packet);
a1229 1
	static u_int packet_length = 0;
d1237 1
a1237 1
	if (packet_discard)
d1240 4
a1243 4
	if (newkeys[MODE_IN] != NULL) {
		enc  = &newkeys[MODE_IN]->enc;
		mac  = &newkeys[MODE_IN]->mac;
		comp = &newkeys[MODE_IN]->comp;
d1248 1
a1248 1
	if (packet_length == 0) {
d1253 1
a1253 1
		if (buffer_len(&input) < block_size)
d1255 2
a1256 3
		buffer_clear(&incoming_packet);
		cp = buffer_append_space(&incoming_packet, block_size);
		cipher_crypt(&receive_context, cp, buffer_ptr(&input),
d1258 6
a1263 3
		cp = buffer_ptr(&incoming_packet);
		packet_length = get_u32(cp);
		if (packet_length < 1 + 4 || packet_length > PACKET_MAX_SIZE) {
d1265 1
a1265 1
			buffer_dump(&incoming_packet);
d1267 2
a1268 2
			logit("Bad packet length %u.", packet_length);
			packet_start_discard(enc, mac, packet_length,
d1272 2
a1273 2
		DBG(debug("input: packet len %u", packet_length+4));
		buffer_consume(&input, block_size);
d1276 1
a1276 1
	need = 4 + packet_length - block_size;
d1282 1
a1282 1
		packet_start_discard(enc, mac, packet_length,
d1290 1
a1290 1
	if (buffer_len(&input) < need + maclen)
d1294 1
a1294 1
	buffer_dump(&input);
d1296 4
a1299 3
	cp = buffer_append_space(&incoming_packet, need);
	cipher_crypt(&receive_context, cp, buffer_ptr(&input), need);
	buffer_consume(&input, need);
d1305 5
a1309 4
		macbuf = mac_compute(mac, p_read.seqnr,
		    buffer_ptr(&incoming_packet),
		    buffer_len(&incoming_packet));
		if (memcmp(macbuf, buffer_ptr(&input), mac->mac_len) != 0) {
d1313 1
a1313 1
			packet_start_discard(enc, mac, packet_length,
d1318 2
a1319 2
		DBG(debug("MAC #%d ok", p_read.seqnr));
		buffer_consume(&input, mac->mac_len);
d1323 2
a1324 2
		*seqnr_p = p_read.seqnr;
	if (++p_read.seqnr == 0)
d1326 1
a1326 1
	if (++p_read.packets == 0)
d1329 2
a1330 2
	p_read.blocks += (packet_length + 4) / block_size;
	p_read.bytes += packet_length + 4;
d1333 1
a1333 1
	cp = buffer_ptr(&incoming_packet);
d1340 2
a1341 2
	buffer_consume(&incoming_packet, 4 + 1);
	buffer_consume_end(&incoming_packet, padlen);
d1343 2
a1344 1
	DBG(debug("input: len before de-compress %d", buffer_len(&incoming_packet)));
d1346 7
a1352 5
		buffer_clear(&compression_buffer);
		buffer_uncompress(&incoming_packet, &compression_buffer);
		buffer_clear(&incoming_packet);
		buffer_append(&incoming_packet, buffer_ptr(&compression_buffer),
		    buffer_len(&compression_buffer));
d1354 1
a1354 1
		    buffer_len(&incoming_packet)));
d1360 1
a1360 1
	type = buffer_get_char(&incoming_packet);
d1365 2
a1366 1
	else if (type == SSH2_MSG_USERAUTH_SUCCESS && !server_side)
d1370 1
a1370 1
	buffer_dump(&incoming_packet);
d1373 1
a1373 1
	packet_length = 0;
d1388 1
a1388 1
				keep_alive_timeouts = 0;
d1461 3
a1463 3
	if (packet_discard) {
		keep_alive_timeouts = 0; /* ?? */
		if (len >= packet_discard)
d1465 1
a1465 1
		packet_discard -= len;
d1468 1
a1468 1
	buffer_append(&input, buf, len);
d1478 1
a1478 1
	buffer_get(&incoming_packet, &ch, 1);
d1487 9
a1495 1
	return buffer_get_int(&incoming_packet);
d1506 1
a1506 1
	buffer_get_bignum(&incoming_packet, value);
d1512 1
a1512 1
	buffer_get_bignum2(&incoming_packet, value);
d1518 1
a1518 1
	u_int bytes = buffer_len(&incoming_packet);
d1522 1
a1522 1
	return buffer_ptr(&incoming_packet);
d1528 1
a1528 1
	return buffer_len(&incoming_packet);
d1541 1
a1541 1
	return buffer_get_string(&incoming_packet, length_ptr);
d1547 1
a1547 1
	return buffer_get_string_ptr(&incoming_packet, length_ptr);
d1640 2
a1641 1
	int len = buffer_len(&output);
d1644 3
a1646 1
		len = write(connection_out, buffer_ptr(&output), len);
d1652 1
a1652 1
		if (len == 0)
d1654 1
a1654 1
		buffer_consume(&output, len);
d1670 2
a1671 2
	setp = (fd_set *)xcalloc(howmany(connection_out + 1, NFDBITS),
	    sizeof(fd_mask));
d1674 3
a1676 3
		memset(setp, 0, howmany(connection_out + 1, NFDBITS) *
		    sizeof(fd_mask));
		FD_SET(connection_out, setp);
d1678 2
a1679 2
		if (packet_timeout_ms > 0) {
			ms_remain = packet_timeout_ms;
d1683 1
a1683 1
			if (packet_timeout_ms != -1) {
d1687 2
a1688 2
			if ((ret = select(connection_out + 1, NULL, setp,
			    NULL, timeoutp)) >= 0)
d1690 1
a1690 1
		   	if (errno != EAGAIN && errno != EINTR)
d1692 1
a1692 1
			if (packet_timeout_ms == -1)
d1715 1
a1715 1
	return buffer_len(&output) != 0;
d1723 2
a1724 2
	if (interactive_mode)
		return buffer_len(&output) < 16384;
d1726 1
a1726 1
		return buffer_len(&output) < 128 * 1024;
d1737 1
a1737 1
	if (setsockopt(connection_in, IPPROTO_IP, IP_TOS, &tos,
d1748 1
a1748 3
	static int called = 0;

	if (called)
d1750 1
a1750 1
	called = 1;
d1753 1
a1753 1
	interactive_mode = interactive;
d1758 1
a1758 1
	set_nodelay(connection_in);
d1767 1
a1767 1
	return interactive_mode;
d1773 1
a1773 3
	static int called = 0;

	if (called) {
d1775 1
a1775 1
		    max_packet_size, s);
d1782 1
a1782 1
	called = 1;
d1784 1
a1784 1
	max_packet_size = s;
d1788 18
d1810 1
a1810 1
	extra_pad = pad;
d1847 6
a1852 4
	    (p_send.packets > MAX_PACKETS) ||
	    (p_read.packets > MAX_PACKETS) ||
	    (max_blocks_out && (p_send.blocks > max_blocks_out)) ||
	    (max_blocks_in  && (p_read.blocks > max_blocks_in));
d1858 1
a1858 1
	rekey_limit = bytes;
d1864 1
a1864 1
	server_side = 1;
d1870 66
a1935 1
	after_authentication = 1;
@


1.14
log
@really merge OpenSSH-current into MirBSD Secure SHell 10uA4
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.158 2008/11/21 15:47:38 markus Exp $ */
d76 1
a76 1
__RCSID("$MirOS: src/usr.bin/ssh/packet.c,v 1.13 2008/12/16 20:55:24 tg Exp $");
d84 2
d162 4
d218 30
d1160 3
d1184 1
a1184 1
		if (packet_length < 1 + 4 || packet_length > 256 * 1024) {
d1188 4
a1191 2
			packet_disconnect("Bad packet length %-10u",
			    packet_length);
d1203 3
a1205 1
		packet_disconnect("Bad packet length %-10u", packet_length);
d1228 9
a1236 2
		if (memcmp(macbuf, buffer_ptr(&input), mac->mac_len) != 0)
			packet_disconnect("Corrupted MAC on input.");
d1240 1
d1376 7
@


1.13
log
@fastmerge, do not use yet!
@
text
@d76 1
a76 1
__RCSID("$MirOS: src/usr.bin/ssh/packet.c,v 1.12 2008/03/02 21:14:20 tg Exp $");
a1702 1
/* MirOS extension */
@


1.12
log
@merge’n’fix
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.151 2008/02/22 20:44:02 dtucker Exp $ */
d76 1
a76 1
__RCSID("$MirOS: src/usr.bin/ssh/packet.c,v 1.11 2007/06/16 15:41:50 tg Exp $");
d138 3
d147 1
d195 1
d199 13
d316 2
a317 1
packet_get_state(int mode, u_int32_t *seqnr, u_int64_t *blocks, u_int32_t *packets)
d322 8
a329 3
	*seqnr = state->seqnr;
	*blocks = state->blocks;
	*packets = state->packets;
d333 2
a334 1
packet_set_state(int mode, u_int32_t seqnr, u_int64_t blocks, u_int32_t packets)
d342 1
d616 2
a617 1

d843 1
d917 1
a917 1
	int type, len;
d920 2
d953 4
d958 23
a980 4
		while (select(connection_in + 1, setp, NULL, NULL, NULL) == -1 &&
		    (errno == EAGAIN || errno == EINTR))
			;

d1105 2
d1149 2
a1150 1
			packet_disconnect("Bad packet length %u.", packet_length);
d1159 2
a1160 2
	if (need % block_size != 0)
		fatal("padding error: need %d block %d mod %d",
d1162 2
d1198 1
a1250 1
			keep_alive_timeouts = 0;
d1252 1
d1393 6
d1493 2
a1494 2
		if (len <= 0) {
			if (errno == EAGAIN)
d1496 1
a1496 2
			else
				fatal("Write failed: %.100s", strerror(errno));
d1498 2
d1513 2
d1523 28
a1550 3
		while (select(connection_out + 1, NULL, setp, NULL, NULL) == -1 &&
		    (errno == EAGAIN || errno == EINTR))
			;
@


1.11
log
@sync’n’bump
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.148 2007/06/07 19:37:34 pvalchev Exp $ */
d76 1
a76 1
__RCSID("$MirOS: src/usr.bin/ssh/packet.c,v 1.10 2006/10/02 23:25:04 tg Exp $");
d136 2
d1192 1
d1199 1
@


1.10
log
@client NULL deref on protocol error; Tavis Ormandy, Google Security Team
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.145 2006/09/19 21:14:08 markus Exp $ */
d76 1
a76 1
__RCSID("$MirOS: src/usr.bin/ssh/packet.c,v 1.9 2006/09/20 21:41:00 tg Exp $");
d627 1
a627 1
		memset(mac->key, 0, mac->key_len);
d642 1
a642 1
	if (mac->md != NULL)
d649 2
a650 1
	   memset(enc->key, 0, enc->key_len); */
a1236 1
				xfree(msg);
@


1.9
log
@finish merging
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.144 2006/09/16 19:53:37 djm Exp $ */
d76 1
a76 1
__RCSID("$MirOS$");
d689 3
@


1.8
log
@simplify and speed up by using arc4random_pushb and update a comment
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.131 2006/03/30 09:58:16 djm Exp $ */
d40 1
a40 3
#include "includes.h"
__RCSID("$MirOS: src/usr.bin/ssh/packet.c,v 1.7 2006/06/02 20:50:48 tg Exp $");

d42 2
d46 1
d49 8
a59 1
#include "bufaux.h"
a60 1

a63 1

a66 1

d68 1
d76 2
d674 1
a674 1
 * This happans on the server side after a SSH2_MSG_USERAUTH_SUCCESS is sent,
d998 10
a1007 3
	if (!receive_context.plaintext &&
	    detect_attack(buffer_ptr(&input), padded_len) == DEATTACK_DETECTED)
		packet_disconnect("crc32 compensation attack: network attack detected");
@


1.7
log
@* merge
* remove all references to GSSAPI, Kerberos and AFS
* uint*_t -> u_int*_t for consistency, like openbsd
  (note: MirOS style(9) suggests uint32_t etc. instead!)
* bump vsn
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/usr.bin/ssh/packet.c,v 1.6 2006/04/19 10:40:49 tg Exp $");
a1593 1
	int x;
d1598 2
a1599 12
consumeloop:
	if (n == 0)
		return;
	x = b[--n];
	if (n > 0)
		x = (x << 8) | b[--n];
	if (n > 0)
		x = (x << 8) | b[--n];
	if (n > 0)
		x = (x << 8) | b[--n];
	arc4random_push(x);
	goto consumeloop;
@


1.6
log
@merge and clean up
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/usr.bin/ssh/packet.c,v 1.5 2006/02/22 02:16:47 tg Exp $");
d1593 1
a1593 1
	uint8_t *b;
@


1.5
log
@fix a lot of and kludge a few more __CRAZY problems, sync rcs id
@
text
@d1 1
d41 1
a41 1
RCSID("$MirOS: src/usr.bin/ssh/packet.c,v 1.4 2006/02/22 01:23:49 tg Exp $");
a52 1
#include "getput.h"
d267 1
d280 1
d477 1
d483 1
d489 1
d495 1
d501 1
d507 1
d561 1
a561 1
	PUT_32BIT(buf, checksum);
d570 1
a570 1
	PUT_32BIT(buf, len);
d773 1
a773 1
	PUT_32BIT(cp, packet_length);
d790 1
a790 1
		buffer_append(&output, (char *)macbuf, mac->mac_len);
d880 1
a880 1
	setp = (fd_set *)xmalloc(howmany(connection_in+1, NFDBITS) *
d971 1
a971 1
	len = GET_32BIT(cp);
d991 1
a991 1
	    detect_attack(buffer_ptr(&input), padded_len, NULL) == DEATTACK_DETECTED)
d1019 1
a1019 1
	stored_checksum = GET_32BIT(cp);
d1068 1
a1068 1
		packet_length = GET_32BIT(cp);
a1200 1
				break;
a1224 1
				break;
d1426 1
a1426 1
	setp = (fd_set *)xmalloc(howmany(connection_out + 1, NFDBITS) *
d1491 1
a1491 2
	if (interactive)
		set_nodelay(connection_in);
d1552 1
a1552 1
		packet_put_char(rnd & 0xff);
@


1.4
log
@merge; bump version; fix up manpages and includes a little
@
text
@d40 1
a40 1
RCSID("$MirOS: src/usr.bin/ssh/packet.c,v 1.3 2006/02/21 02:08:42 tg Exp $");
d1163 1
a1163 1
			if (type)
d1165 1
d1214 1
a1214 1
				if (type)
d1216 1
@


1.3
log
@* cipher.c: use libc md5, not openssl one
* packet.c: add nullmessage content via arc4random_push(3) too
  (used eg. to pad when entering passwords (stty -echo) to prevent attacks)
* all files: fix RCS ID

tested against itself and #8uA2
@
text
@d40 1
a40 1
RCSID("$MirOS: packet.c,v 1.120 2005/10/30 08:52:17 djm Exp $");
d44 3
@


1.2
log
@add some more state information
@
text
@d40 1
a40 1
RCSID("$MirBSD: packet.c,v 1.120 2005/10/30 08:52:17 djm Exp $");
d150 3
d1164 1
d1195 1
d1577 25
@


1.1
log
@Initial revision
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.116 2004/10/20 11:48:53 markus Exp $");
d119 6
d163 4
a166 4
	cipher_init(&send_context, none, (const u_char *)"",
	    0, NULL, 0, CIPHER_ENCRYPT);
	cipher_init(&receive_context, none, (const u_char *)"",
	    0, NULL, 0, CIPHER_DECRYPT);
d570 1
a570 1
	 * Note that the packet is now only buffered in output.  It won\'t be
d628 3
a630 1
	if (comp->type != 0 && comp->enabled == 0) {
d651 29
d792 2
d1029 1
a1029 1
	int maclen, block_size;
d1136 2
d1268 1
a1268 1
packet_get_raw(int *length_ptr)
d1270 1
a1270 1
	int bytes = buffer_len(&incoming_packet);
d1560 12
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@most current OpenSSH.com
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.117 2005/06/17 02:44:32 djm Exp $");
d990 1
a990 1
	u_int maclen, block_size;
d1227 1
a1227 1
packet_get_raw(u_int *length_ptr)
d1229 1
a1229 1
	u_int bytes = buffer_len(&incoming_packet);
@


1.1.1.3
log
@Import current OpenSSH
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.120 2005/10/30 08:52:17 djm Exp $");
a118 6
/* Set to true if we are the server side. */
static int server_side = 0;

/* Set to true if we are authenticated. */
static int after_authentication = 0;

d564 1
a564 1
	 * Note that the packet is now only buffered in output.  It won't be
d622 1
a622 3
	if ((comp->type == COMP_ZLIB ||
	    (comp->type == COMP_DELAYED && after_authentication)) &&
	    comp->enabled == 0) {
a642 29
 * Delayed compression for SSH2 is enabled after authentication:
 * This happans on the server side after a SSH2_MSG_USERAUTH_SUCCESS is sent,
 * and on the client side after a SSH2_MSG_USERAUTH_SUCCESS is received.
 */
static void
packet_enable_delayed_compress(void)
{
	Comp *comp = NULL;
	int mode;

	/*
	 * Remember that we are past the authentication step, so rekeying
	 * with COMP_DELAYED will turn on compression immediately.
	 */
	after_authentication = 1;
	for (mode = 0; mode < MODE_MAX; mode++) {
		comp = &newkeys[mode]->comp;
		if (comp && !comp->enabled && comp->type == COMP_DELAYED) {
			packet_init_compression();
			if (mode == MODE_OUT)
				buffer_compress_init_send(6);
			else
				buffer_compress_init_recv();
			comp->enabled = 1;
		}
	}
}

/*
a754 2
	else if (type == SSH2_MSG_USERAUTH_SUCCESS && server_side)
		packet_enable_delayed_compress();
a1096 2
	else if (type == SSH2_MSG_USERAUTH_SUCCESS && !server_side)
		packet_enable_delayed_compress();
a1518 12

void
packet_set_server(void)
{
	server_side = 1;
}

void
packet_set_authenticated(void)
{
	after_authentication = 1;
}
@


1.1.1.4
log
@import OpenSSH-current
@
text
@d40 1
a40 1
RCSID("$OpenBSD: packet.c,v 1.121 2006/02/08 14:38:18 stevesk Exp $");
a43 3
#include <netinet/in_systm.h>
#include <netinet/ip.h>

@


1.1.1.5
log
@I decided we'd better upgrade OpenSSH before releasing to the general public
@
text
@a0 1
/* $OpenBSD: packet.c,v 1.131 2006/03/30 09:58:16 djm Exp $ */
d40 1
d52 1
a263 1

a275 1

a471 1

a476 1

a481 1

a486 1

a491 1

a496 1

d550 1
a550 1
	put_u32(buf, checksum);
d559 1
a559 1
	put_u32(buf, len);
d762 1
a762 1
	put_u32(cp, packet_length);
d779 1
a779 1
		buffer_append(&output, macbuf, mac->mac_len);
d869 1
a869 1
	setp = (fd_set *)xcalloc(howmany(connection_in+1, NFDBITS),
d960 1
a960 1
	len = get_u32(cp);
d980 1
a980 1
	    detect_attack(buffer_ptr(&input), padded_len) == DEATTACK_DETECTED)
d1008 1
a1008 1
	stored_checksum = get_u32(cp);
d1057 1
a1057 1
		packet_length = get_u32(cp);
d1188 1
d1211 1
d1413 1
a1413 1
	setp = (fd_set *)xcalloc(howmany(connection_out + 1, NFDBITS),
d1478 2
a1479 1
	set_nodelay(connection_in);
d1540 1
a1540 1
		packet_put_char((u_char)rnd & 0xff);
@


1.1.1.6
log
@import a few security-wise relevant changes right now
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.144 2006/09/16 19:53:37 djm Exp $ */
d40 2
a41 1
#include <sys/types.h>
a42 3
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/param.h>
a44 1
#include <netinet/in.h>
a46 8
#include <errno.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>

d50 1
d52 1
d56 1
d60 1
a61 1
#include "key.h"
d662 1
a662 1
 * This happens on the server side after a SSH2_MSG_USERAUTH_SUCCESS is sent,
d986 3
a988 10
	if (!receive_context.plaintext) {
		switch (detect_attack(buffer_ptr(&input), padded_len)) {
		case DEATTACK_DETECTED:
			packet_disconnect("crc32 compensation attack: "
			    "network attack detected");
		case DEATTACK_DOS_DETECTED:
			packet_disconnect("deattack denial of "
			    "service detected");
		}
	}
@


1.1.1.7
log
@OpenSSH 4.5 (security)
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.145 2006/09/19 21:14:08 markus Exp $ */
a684 3
		/* protocol error: USERAUTH_SUCCESS received before NEWKEYS */
		if (newkeys[mode] == NULL)
			continue;
@


1.1.1.8
log
@Import latest OpenSSH and OpenBSD-libssl
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.148 2007/06/07 19:37:34 pvalchev Exp $ */
d623 1
a623 1
		mac_clear(mac);
d638 1
a638 1
	if (mac_init(mac) == 0)
d645 1
a645 2
	   memset(enc->key, 0, enc->key_len);
	   memset(mac->key, 0, mac->key_len); */
d1229 1
@


1.1.1.9
log
@newer openssh
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.151 2008/02/22 20:44:02 dtucker Exp $ */
a134 2
int keep_alive_timeouts = 0;

a1185 1
			keep_alive_timeouts = 0;
a1189 1
				debug3("Received SSH2_MSG_IGNORE");
@


1.1.1.10
log
@OpenSSH-current
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.158 2008/11/21 15:47:38 markus Exp $ */
a136 3
/* Set to the maximum time that we will wait to send or receive a packet */
static int packet_timeout_ms = -1;

a142 1
	u_int64_t bytes;
a186 10
		p_send.packets = p_read.packets = 0;
	}
}

void
packet_set_timeout(int timeout, int count)
{
	if (timeout == 0 || count == 0) {
		packet_timeout_ms = -1;
		return;
a187 4
	if ((INT_MAX / 1000) / count < timeout)
		packet_timeout_ms = INT_MAX;
	else
		packet_timeout_ms = timeout * count * 1000;
d294 1
a294 2
packet_get_state(int mode, u_int32_t *seqnr, u_int64_t *blocks, u_int32_t *packets,
    u_int64_t *bytes)
d299 3
a301 8
	if (seqnr)
		*seqnr = state->seqnr;
	if (blocks)
		*blocks = state->blocks;
	if (packets)
		*packets = state->packets;
	if (bytes)
		*bytes = state->bytes;
d305 1
a305 2
packet_set_state(int mode, u_int32_t seqnr, u_int64_t blocks, u_int32_t packets,
    u_int64_t bytes)
a312 1
	state->bytes = bytes;
d586 1
a586 2
	p_send.packets++;
	p_send.bytes += len + buffer_len(&outgoing_packet);
a811 1
	p_send.bytes += packet_length + 4;
d885 1
a885 1
	int type, len, ret, ms_remain;
a887 2
	struct timeval timeout, start, *timeoutp = NULL;

a918 4
		if (packet_timeout_ms > 0) {
			ms_remain = packet_timeout_ms;
			timeoutp = &timeout;
		}
d920 4
a923 23
		for (;;) {
			if (packet_timeout_ms != -1) {
				ms_to_timeval(&timeout, ms_remain);
				gettimeofday(&start, NULL);
			}
			if ((ret = select(connection_in + 1, setp, NULL,
			    NULL, timeoutp)) >= 0)
				break;
		   	if (errno != EAGAIN && errno != EINTR)
				break;
			if (packet_timeout_ms == -1)
				continue;
			ms_subtract_diff(&start, &ms_remain);
			if (ms_remain <= 0) {
				ret = 0;
				break;
			}
		}
		if (ret == 0) {
			logit("Connection to %.200s timed out while "
			    "waiting to read", get_remote_ipaddr());
			cleanup_exit(255);
		}
a1047 2
	p_read.packets++;
	p_read.bytes += padded_len + 4;
d1090 1
a1090 2
			packet_disconnect("Bad packet length %-10u",
			    packet_length);
d1099 2
a1100 2
	if (need % block_size != 0) {
		logit("padding error: need %d block %d mod %d",
a1101 2
		packet_disconnect("Bad packet length %-10u", packet_length);
	}
a1135 1
	p_read.bytes += packet_length + 4;
d1188 2
a1189 2
			if (type) {
				keep_alive_timeouts = 0;
a1190 1
			}
a1325 6
void *
packet_get_string_ptr(u_int *length_ptr)
{
	return buffer_get_string_ptr(&incoming_packet, length_ptr);
}

d1420 2
a1421 2
		if (len == -1) {
			if (errno == EINTR || errno == EAGAIN)
d1423 2
a1424 1
			fatal("Write failed: %.100s", strerror(errno));
a1425 2
		if (len == 0)
			fatal("Write connection closed");
a1438 2
	int ret, ms_remain;
	struct timeval start, timeout, *timeoutp = NULL;
d1447 3
a1449 28

		if (packet_timeout_ms > 0) {
			ms_remain = packet_timeout_ms;
			timeoutp = &timeout;
		}
		for (;;) {
			if (packet_timeout_ms != -1) {
				ms_to_timeval(&timeout, ms_remain);
				gettimeofday(&start, NULL);
			}
			if ((ret = select(connection_out + 1, NULL, setp,
			    NULL, timeoutp)) >= 0)
				break;
		   	if (errno != EAGAIN && errno != EINTR)
				break;
			if (packet_timeout_ms == -1)
				continue;
			ms_subtract_diff(&start, &ms_remain);
			if (ms_remain <= 0) {
				ret = 0;
				break;
			}
		}
		if (ret == 0) {
			logit("Connection to %.200s timed out while "
			    "waiting to write", get_remote_ipaddr());
			cleanup_exit(255);
		}
@


1.1.1.11
log
@OpenSSH 5.2, or so
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.160 2009/02/13 11:50:21 markus Exp $ */
a82 2
#define PACKET_MAX_SIZE (256 * 1024)

a158 4
/* XXX discard incoming data after MAC error */
static u_int packet_discard = 0;
static Mac *packet_discard_mac = NULL;

a207 30
static void
packet_stop_discard(void)
{
	if (packet_discard_mac) {
		char buf[1024];
		
		memset(buf, 'a', sizeof(buf));
		while (buffer_len(&incoming_packet) < PACKET_MAX_SIZE)
			buffer_append(&incoming_packet, buf, sizeof(buf));
		(void) mac_compute(packet_discard_mac,
		    p_read.seqnr,
		    buffer_ptr(&incoming_packet),
		    PACKET_MAX_SIZE);
	}
	logit("Finished discarding for %.200s", get_remote_ipaddr());
	cleanup_exit(255);
}

static void
packet_start_discard(Enc *enc, Mac *mac, u_int packet_length, u_int discard)
{
	if (enc == NULL || !cipher_is_cbc(enc->cipher))
		packet_disconnect("Packet corrupt");
	if (packet_length != PACKET_MAX_SIZE && mac && mac->enabled)
		packet_discard_mac = mac;
	if (buffer_len(&input) >= discard)
		packet_stop_discard();
	packet_discard = discard - buffer_len(&input);
}

a1119 3
	if (packet_discard)
		return SSH_MSG_NONE;

d1141 1
a1141 1
		if (packet_length < 1 + 4 || packet_length > PACKET_MAX_SIZE) {
d1145 2
a1146 4
			logit("Bad packet length %u.", packet_length);
			packet_start_discard(enc, mac, packet_length,
			    PACKET_MAX_SIZE);
			return SSH_MSG_NONE;
d1158 1
a1158 3
		packet_start_discard(enc, mac, packet_length,
		    PACKET_MAX_SIZE - block_size);
		return SSH_MSG_NONE;
d1181 2
a1182 9
		if (memcmp(macbuf, buffer_ptr(&input), mac->mac_len) != 0) {
			logit("Corrupted MAC on input.");
			if (need > PACKET_MAX_SIZE)
				fatal("internal error need %d", need);
			packet_start_discard(enc, mac, packet_length,
			    PACKET_MAX_SIZE - need);
			return SSH_MSG_NONE;
		}
				
a1185 1
	/* XXX now it's safe to use fatal/packet_disconnect */
a1317 7
	if (packet_discard) {
		keep_alive_timeouts = 0; /* ?? */
		if (len >= packet_discard)
			packet_stop_discard();
		packet_discard -= len;
		return;
	}
@


1.1.1.12
log
@Let’s play the version number game – OpenSSH 5.3-current
@
text
@d1 1
a1 1
/* $OpenBSD: packet.c,v 1.166 2009/06/27 09:29:06 andreas Exp $ */
a75 1
#include "roaming.h"
d85 8
a92 6
struct packet_state {
	u_int32_t seqnr;
	u_int32_t packets;
	u_int64_t blocks;
	u_int64_t bytes;
};
d94 2
a95 5
struct packet {
	TAILQ_ENTRY(packet) next;
	u_char type;
	Buffer payload;
};
d97 2
a98 9
struct session_state {
	/*
	 * This variable contains the file descriptors used for
	 * communicating with the other side.  connection_in is used for
	 * reading; connection_out for writing.  These can be the same
	 * descriptor, in which case it is assumed to be a socket.
	 */
	int connection_in;
	int connection_out;
d100 2
a101 2
	/* Protocol flags for the remote side. */
	u_int remote_protocol_flags;
d103 2
a104 2
	/* Encryption context for receiving data.  Only used for decryption. */
	CipherContext receive_context;
d106 2
a107 2
	/* Encryption context for sending data.  Only used for encryption. */
	CipherContext send_context;
d109 2
a110 2
	/* Buffer for raw input data from the socket. */
	Buffer input;
d112 2
a113 2
	/* Buffer for raw output data going to the socket. */
	Buffer output;
d115 3
a117 2
	/* Buffer for the partial outgoing packet being constructed. */
	Buffer outgoing_packet;
d119 2
a120 2
	/* Buffer for the incoming packet currently being processed. */
	Buffer incoming_packet;
d122 2
a123 3
	/* Scratch buffer for packet compression/decompression. */
	Buffer compression_buffer;
	int compression_buffer_ready;
d125 2
a126 5
	/*
	 * Flag indicating whether packet compression/decompression is
	 * enabled.
	 */
	int packet_compression;
d128 2
a129 2
	/* default maximum packet size */
	u_int max_packet_size;
d131 2
a132 2
	/* Flag indicating whether this module has been initialized. */
	int initialized;
d134 2
a135 2
	/* Set to true if the connection is interactive. */
	int interactive_mode;
d137 1
a137 2
	/* Set to true if we are the server side. */
	int server_side;
d139 2
a140 2
	/* Set to true if we are authenticated. */
	int after_authentication;
d142 8
a149 1
	int keep_alive_timeouts;
d151 2
a152 2
	/* The maximum time that we will wait to send or receive a packet */
	int packet_timeout_ms;
d154 3
a156 3
	/* Session key information for Encryption and MAC */
	Newkeys *newkeys[MODE_MAX];
	struct packet_state p_read, p_send;
d158 2
a159 2
	u_int64_t max_blocks_in, max_blocks_out;
	u_int32_t rekey_limit;
d161 3
a163 3
	/* Session key for protocol v1 */
	u_char ssh1_key[SSH_SESSION_KEY_LENGTH];
	u_int ssh1_keylen;
d165 4
a168 20
	/* roundup current message to extra_pad bytes */
	u_char extra_pad;

	/* XXX discard incoming data after MAC error */
	u_int packet_discard;
	Mac *packet_discard_mac;

	/* Used in packet_read_poll2() */
	u_int packlen;

	/* Used in packet_send2 */
	int rekeying;

	/* Used in packet_set_interactive */
	int set_interactive_called;

	/* Used in packet_set_maxsize */
	int set_maxsize_called;

	TAILQ_HEAD(, packet) outgoing;
d170 1
a170 14

static struct session_state *active_state, *backup_state;

static struct session_state *
alloc_session_state(void)
{
    struct session_state *s = xcalloc(1, sizeof(*s));

    s->connection_in = -1;
    s->connection_out = -1;
    s->max_packet_size = 32768;
    s->packet_timeout_ms = -1;
    return s;
}
d183 3
a185 5
	if (active_state == NULL)
		active_state = alloc_session_state();
	active_state->connection_in = fd_in;
	active_state->connection_out = fd_out;
	cipher_init(&active_state->send_context, none, (const u_char *)"",
d187 1
a187 1
	cipher_init(&active_state->receive_context, none, (const u_char *)"",
d189 9
a197 9
	active_state->newkeys[MODE_IN] = active_state->newkeys[MODE_OUT] = NULL;
	if (!active_state->initialized) {
		active_state->initialized = 1;
		buffer_init(&active_state->input);
		buffer_init(&active_state->output);
		buffer_init(&active_state->outgoing_packet);
		buffer_init(&active_state->incoming_packet);
		TAILQ_INIT(&active_state->outgoing);
		active_state->p_send.packets = active_state->p_read.packets = 0;
d205 1
a205 1
		active_state->packet_timeout_ms = -1;
d209 1
a209 1
		active_state->packet_timeout_ms = INT_MAX;
d211 1
a211 1
		active_state->packet_timeout_ms = timeout * count * 1000;
d217 1
a217 1
	if (active_state->packet_discard_mac) {
d221 5
a225 7
		while (buffer_len(&active_state->incoming_packet) <
		    PACKET_MAX_SIZE)
			buffer_append(&active_state->incoming_packet, buf,
			    sizeof(buf));
		(void) mac_compute(active_state->packet_discard_mac,
		    active_state->p_read.seqnr,
		    buffer_ptr(&active_state->incoming_packet),
d238 2
a239 2
		active_state->packet_discard_mac = mac;
	if (buffer_len(&active_state->input) >= discard)
d241 1
a241 2
	active_state->packet_discard = discard -
	    buffer_len(&active_state->input);
d253 1
a253 1
	if (active_state->connection_in == active_state->connection_out)
d257 1
a257 2
	if (getpeername(active_state->connection_in, (struct sockaddr *)&from,
	    &fromlen) < 0)
d261 1
a261 2
	if (getpeername(active_state->connection_out, (struct sockaddr *)&to,
	    &tolen) < 0)
d282 1
a282 1
		cc = &active_state->send_context;
d284 1
a284 1
		cc = &active_state->receive_context;
d295 1
a295 1
		cc = &active_state->send_context;
d297 1
a297 1
		cc = &active_state->receive_context;
d308 1
a308 1
		cc = &active_state->send_context;
d310 1
a310 1
		cc = &active_state->receive_context;
d321 1
a321 1
		cc = &active_state->send_context;
d323 1
a323 1
		cc = &active_state->receive_context;
d334 1
a334 1
		cc = &active_state->send_context;
d336 1
a336 1
		cc = &active_state->receive_context;
d344 1
a344 1
	return (cipher_get_number(active_state->receive_context.cipher));
d353 1
a353 2
	state = (mode == MODE_IN) ?
	    &active_state->p_read : &active_state->p_send;
d370 1
a370 2
	state = (mode == MODE_IN) ?
	    &active_state->p_read : &active_state->p_send;
d386 1
a386 2
	if (getsockname(active_state->connection_out, (struct sockaddr *)&to,
	    &tolen) < 0)
d399 1
a399 1
	set_nonblock(active_state->connection_in);
d401 2
a402 2
	if (active_state->connection_out != active_state->connection_in)
		set_nonblock(active_state->connection_out);
d410 1
a410 1
	return active_state->connection_in;
d418 1
a418 1
	return active_state->connection_out;
d426 1
a426 1
	if (!active_state->initialized)
d428 4
a431 4
	active_state->initialized = 0;
	if (active_state->connection_in == active_state->connection_out) {
		shutdown(active_state->connection_out, SHUT_RDWR);
		close(active_state->connection_out);
d433 2
a434 2
		close(active_state->connection_in);
		close(active_state->connection_out);
d436 6
a441 6
	buffer_free(&active_state->input);
	buffer_free(&active_state->output);
	buffer_free(&active_state->outgoing_packet);
	buffer_free(&active_state->incoming_packet);
	if (active_state->compression_buffer_ready) {
		buffer_free(&active_state->compression_buffer);
d444 2
a445 2
	cipher_cleanup(&active_state->send_context);
	cipher_cleanup(&active_state->receive_context);
d453 1
a453 1
	active_state->remote_protocol_flags = protocol_flags;
d461 1
a461 1
	return active_state->remote_protocol_flags;
d472 1
a472 1
	if (active_state->compression_buffer_ready == 1)
d474 2
a475 2
	active_state->compression_buffer_ready = 1;
	buffer_init(&active_state->compression_buffer);
d481 1
a481 1
	if (active_state->packet_compression && !compat20)
d483 1
a483 1
	active_state->packet_compression = 1;
d507 4
a510 6
	memcpy(active_state->ssh1_key, key, keylen);
	active_state->ssh1_keylen = keylen;
	cipher_init(&active_state->send_context, cipher, key, keylen, NULL,
	    0, CIPHER_ENCRYPT);
	cipher_init(&active_state->receive_context, cipher, key, keylen, NULL,
	    0, CIPHER_DECRYPT);
d517 3
a519 3
		return (active_state->ssh1_keylen);
	memcpy(key, active_state->ssh1_key, active_state->ssh1_keylen);
	return (active_state->ssh1_keylen);
d533 2
a534 2
	buffer_clear(&active_state->outgoing_packet);
	buffer_append(&active_state->outgoing_packet, buf, len);
d543 1
a543 1
	buffer_append(&active_state->outgoing_packet, &ch, 1);
d549 1
a549 7
	buffer_put_int(&active_state->outgoing_packet, value);
}

void
packet_put_int64(u_int64_t value)
{
	buffer_put_int64(&active_state->outgoing_packet, value);
d555 1
a555 1
	buffer_put_string(&active_state->outgoing_packet, buf, len);
d561 1
a561 1
	buffer_put_cstring(&active_state->outgoing_packet, str);
d567 1
a567 1
	buffer_append(&active_state->outgoing_packet, buf, len);
d573 1
a573 1
	buffer_put_bignum(&active_state->outgoing_packet, value);
d579 1
a579 1
	buffer_put_bignum2(&active_state->outgoing_packet, value);
d599 2
a600 2
	if (active_state->packet_compression) {
		buffer_clear(&active_state->compression_buffer);
d602 1
a602 1
		buffer_consume(&active_state->outgoing_packet, 8);
d604 5
a608 8
		buffer_append(&active_state->compression_buffer,
		    "\0\0\0\0\0\0\0\0", 8);
		buffer_compress(&active_state->outgoing_packet,
		    &active_state->compression_buffer);
		buffer_clear(&active_state->outgoing_packet);
		buffer_append(&active_state->outgoing_packet,
		    buffer_ptr(&active_state->compression_buffer),
		    buffer_len(&active_state->compression_buffer));
d611 1
a611 1
	len = buffer_len(&active_state->outgoing_packet) + 4 - 8;
d615 2
a616 2
	if (!active_state->send_context.plaintext) {
		cp = buffer_ptr(&active_state->outgoing_packet);
d624 1
a624 1
	buffer_consume(&active_state->outgoing_packet, 8 - padding);
d627 2
a628 2
	checksum = ssh_crc32(buffer_ptr(&active_state->outgoing_packet),
	    buffer_len(&active_state->outgoing_packet));
d630 1
a630 1
	buffer_append(&active_state->outgoing_packet, buf, 4);
d634 1
a634 1
	buffer_dump(&active_state->outgoing_packet);
d639 4
a642 6
	buffer_append(&active_state->output, buf, 4);
	cp = buffer_append_space(&active_state->output,
	    buffer_len(&active_state->outgoing_packet));
	cipher_crypt(&active_state->send_context, cp,
	    buffer_ptr(&active_state->outgoing_packet),
	    buffer_len(&active_state->outgoing_packet));
d646 1
a646 1
	buffer_dump(&active_state->output);
d648 3
a650 4
	active_state->p_send.packets++;
	active_state->p_send.bytes += len +
	    buffer_len(&active_state->outgoing_packet);
	buffer_clear(&active_state->outgoing_packet);
d672 1
a672 1
		cc = &active_state->send_context;
d674 2
a675 2
		active_state->p_send.packets = active_state->p_send.blocks = 0;
		max_blocks = &active_state->max_blocks_out;
d677 1
a677 1
		cc = &active_state->receive_context;
d679 2
a680 2
		active_state->p_read.packets = active_state->p_read.blocks = 0;
		max_blocks = &active_state->max_blocks_in;
d682 1
a682 1
	if (active_state->newkeys[mode] != NULL) {
d685 3
a687 3
		enc  = &active_state->newkeys[mode]->enc;
		mac  = &active_state->newkeys[mode]->mac;
		comp = &active_state->newkeys[mode]->comp;
d695 1
a695 1
		xfree(active_state->newkeys[mode]);
d697 2
a698 2
	active_state->newkeys[mode] = kex_get_newkeys(mode);
	if (active_state->newkeys[mode] == NULL)
d700 3
a702 3
	enc  = &active_state->newkeys[mode]->enc;
	mac  = &active_state->newkeys[mode]->mac;
	comp = &active_state->newkeys[mode]->comp;
d713 2
a714 2
	    (comp->type == COMP_DELAYED &&
	     active_state->after_authentication)) && comp->enabled == 0) {
d730 2
a731 3
	if (active_state->rekey_limit)
		*max_blocks = MIN(*max_blocks,
		    active_state->rekey_limit / enc->block_size);
d749 1
a749 1
	active_state->after_authentication = 1;
d752 1
a752 1
		if (active_state->newkeys[mode] == NULL)
d754 1
a754 1
		comp = &active_state->newkeys[mode]->comp;
d782 4
a785 4
	if (active_state->newkeys[MODE_OUT] != NULL) {
		enc  = &active_state->newkeys[MODE_OUT]->enc;
		mac  = &active_state->newkeys[MODE_OUT]->mac;
		comp = &active_state->newkeys[MODE_OUT]->comp;
d789 1
a789 1
	cp = buffer_ptr(&active_state->outgoing_packet);
d794 1
a794 1
	buffer_dump(&active_state->outgoing_packet);
d798 1
a798 1
		len = buffer_len(&active_state->outgoing_packet);
d800 7
a806 9
		buffer_consume(&active_state->outgoing_packet, 5);
		buffer_clear(&active_state->compression_buffer);
		buffer_compress(&active_state->outgoing_packet,
		    &active_state->compression_buffer);
		buffer_clear(&active_state->outgoing_packet);
		buffer_append(&active_state->outgoing_packet, "\0\0\0\0\0", 5);
		buffer_append(&active_state->outgoing_packet,
		    buffer_ptr(&active_state->compression_buffer),
		    buffer_len(&active_state->compression_buffer));
d808 1
a808 1
		    buffer_len(&active_state->outgoing_packet)));
d812 1
a812 1
	len = buffer_len(&active_state->outgoing_packet);
d821 1
a821 1
	if (active_state->extra_pad) {
d823 2
a824 4
		active_state->extra_pad =
		    roundup(active_state->extra_pad, block_size);
		pad = active_state->extra_pad -
		    ((len + padlen) % active_state->extra_pad);
d826 1
a826 1
		    pad, len, padlen, active_state->extra_pad);
d828 1
a828 1
		active_state->extra_pad = 0;
d830 2
a831 2
	cp = buffer_append_space(&active_state->outgoing_packet, padlen);
	if (enc && !active_state->send_context.plaintext) {
d844 2
a845 2
	packet_length = buffer_len(&active_state->outgoing_packet) - 4;
	cp = buffer_ptr(&active_state->outgoing_packet);
d852 4
a855 4
		macbuf = mac_compute(mac, active_state->p_send.seqnr,
		    buffer_ptr(&active_state->outgoing_packet),
		    buffer_len(&active_state->outgoing_packet));
		DBG(debug("done calc MAC out #%d", active_state->p_send.seqnr));
d858 3
a860 5
	cp = buffer_append_space(&active_state->output,
	    buffer_len(&active_state->outgoing_packet));
	cipher_crypt(&active_state->send_context, cp,
	    buffer_ptr(&active_state->outgoing_packet),
	    buffer_len(&active_state->outgoing_packet));
d863 1
a863 1
		buffer_append(&active_state->output, macbuf, mac->mac_len);
d866 1
a866 1
	buffer_dump(&active_state->output);
d869 1
a869 1
	if (++active_state->p_send.seqnr == 0)
d871 1
a871 1
	if (++active_state->p_send.packets == 0)
d874 3
a876 3
	active_state->p_send.blocks += (packet_length + 4) / block_size;
	active_state->p_send.bytes += packet_length + 4;
	buffer_clear(&active_state->outgoing_packet);
d880 1
a880 1
	else if (type == SSH2_MSG_USERAUTH_SUCCESS && active_state->server_side)
d887 1
d891 1
a891 1
	cp = buffer_ptr(&active_state->outgoing_packet);
d895 1
a895 1
	if (active_state->rekeying) {
d901 3
a903 4
			memcpy(&p->payload, &active_state->outgoing_packet,
			    sizeof(Buffer));
			buffer_init(&active_state->outgoing_packet);
			TAILQ_INSERT_TAIL(&active_state->outgoing, p, next);
d910 1
a910 1
		active_state->rekeying = 1;
d916 2
a917 2
		active_state->rekeying = 0;
		while ((p = TAILQ_FIRST(&active_state->outgoing))) {
d920 2
a921 2
			buffer_free(&active_state->outgoing_packet);
			memcpy(&active_state->outgoing_packet, &p->payload,
d923 1
a923 1
			TAILQ_REMOVE(&active_state->outgoing, p, next);
d949 1
a949 1
	int type, len, ret, ms_remain, cont;
d956 2
a957 2
	setp = (fd_set *)xcalloc(howmany(active_state->connection_in + 1,
	    NFDBITS), sizeof(fd_mask));
d981 3
a983 3
		memset(setp, 0, howmany(active_state->connection_in + 1,
		    NFDBITS) * sizeof(fd_mask));
		FD_SET(active_state->connection_in, setp);
d985 2
a986 2
		if (active_state->packet_timeout_ms > 0) {
			ms_remain = active_state->packet_timeout_ms;
d991 1
a991 1
			if (active_state->packet_timeout_ms != -1) {
d995 2
a996 2
			if ((ret = select(active_state->connection_in + 1, setp,
			    NULL, NULL, timeoutp)) >= 0)
d998 1
a998 1
			if (errno != EAGAIN && errno != EINTR)
d1000 1
a1000 1
			if (active_state->packet_timeout_ms == -1)
d1014 1
a1014 5
		do {
			cont = 0;
			len = roaming_read(active_state->connection_in, buf,
			    sizeof(buf), &cont);
		} while (len == 0 && cont);
d1066 1
a1066 1
	if (buffer_len(&active_state->input) < 4 + 8)
d1069 1
a1069 1
	cp = buffer_ptr(&active_state->input);
d1076 1
a1076 1
	if (buffer_len(&active_state->input) < 4 + padded_len)
d1082 1
a1082 1
	buffer_consume(&active_state->input, 4);
d1089 2
a1090 3
	if (!active_state->receive_context.plaintext) {
		switch (detect_attack(buffer_ptr(&active_state->input),
		    padded_len)) {
d1101 3
a1103 4
	buffer_clear(&active_state->incoming_packet);
	cp = buffer_append_space(&active_state->incoming_packet, padded_len);
	cipher_crypt(&active_state->receive_context, cp,
	    buffer_ptr(&active_state->input), padded_len);
d1105 1
a1105 1
	buffer_consume(&active_state->input, padded_len);
d1109 1
a1109 1
	buffer_dump(&active_state->incoming_packet);
d1113 2
a1114 2
	checksum = ssh_crc32(buffer_ptr(&active_state->incoming_packet),
	    buffer_len(&active_state->incoming_packet) - 4);
d1117 1
a1117 1
	buffer_consume(&active_state->incoming_packet, 8 - len % 8);
d1120 1
a1120 1
	if (len != buffer_len(&active_state->incoming_packet))
d1122 1
a1122 1
		    len, buffer_len(&active_state->incoming_packet));
d1124 1
a1124 1
	cp = (u_char *)buffer_ptr(&active_state->incoming_packet) + len - 4;
d1128 1
a1128 1
	buffer_consume_end(&active_state->incoming_packet, 4);
d1130 10
a1139 12
	if (active_state->packet_compression) {
		buffer_clear(&active_state->compression_buffer);
		buffer_uncompress(&active_state->incoming_packet,
		    &active_state->compression_buffer);
		buffer_clear(&active_state->incoming_packet);
		buffer_append(&active_state->incoming_packet,
		    buffer_ptr(&active_state->compression_buffer),
		    buffer_len(&active_state->compression_buffer));
	}
	active_state->p_read.packets++;
	active_state->p_read.bytes += padded_len + 4;
	type = buffer_get_char(&active_state->incoming_packet);
d1148 1
d1156 1
a1156 1
	if (active_state->packet_discard)
d1159 4
a1162 4
	if (active_state->newkeys[MODE_IN] != NULL) {
		enc  = &active_state->newkeys[MODE_IN]->enc;
		mac  = &active_state->newkeys[MODE_IN]->mac;
		comp = &active_state->newkeys[MODE_IN]->comp;
d1167 1
a1167 1
	if (active_state->packlen == 0) {
d1172 1
a1172 1
		if (buffer_len(&active_state->input) < block_size)
d1174 3
a1176 2
		buffer_clear(&active_state->incoming_packet);
		cp = buffer_append_space(&active_state->incoming_packet,
d1178 3
a1180 6
		cipher_crypt(&active_state->receive_context, cp,
		    buffer_ptr(&active_state->input), block_size);
		cp = buffer_ptr(&active_state->incoming_packet);
		active_state->packlen = get_u32(cp);
		if (active_state->packlen < 1 + 4 ||
		    active_state->packlen > PACKET_MAX_SIZE) {
d1182 1
a1182 1
			buffer_dump(&active_state->incoming_packet);
d1184 2
a1185 2
			logit("Bad packet length %u.", active_state->packlen);
			packet_start_discard(enc, mac, active_state->packlen,
d1189 2
a1190 2
		DBG(debug("input: packet len %u", active_state->packlen+4));
		buffer_consume(&active_state->input, block_size);
d1193 1
a1193 1
	need = 4 + active_state->packlen - block_size;
d1199 1
a1199 1
		packet_start_discard(enc, mac, active_state->packlen,
d1207 1
a1207 1
	if (buffer_len(&active_state->input) < need + maclen)
d1211 1
a1211 1
	buffer_dump(&active_state->input);
d1213 3
a1215 4
	cp = buffer_append_space(&active_state->incoming_packet, need);
	cipher_crypt(&active_state->receive_context, cp,
	    buffer_ptr(&active_state->input), need);
	buffer_consume(&active_state->input, need);
d1221 4
a1224 5
		macbuf = mac_compute(mac, active_state->p_read.seqnr,
		    buffer_ptr(&active_state->incoming_packet),
		    buffer_len(&active_state->incoming_packet));
		if (memcmp(macbuf, buffer_ptr(&active_state->input),
		    mac->mac_len) != 0) {
d1228 1
a1228 1
			packet_start_discard(enc, mac, active_state->packlen,
d1233 2
a1234 2
		DBG(debug("MAC #%d ok", active_state->p_read.seqnr));
		buffer_consume(&active_state->input, mac->mac_len);
d1238 2
a1239 2
		*seqnr_p = active_state->p_read.seqnr;
	if (++active_state->p_read.seqnr == 0)
d1241 1
a1241 1
	if (++active_state->p_read.packets == 0)
d1244 2
a1245 2
	active_state->p_read.blocks += (active_state->packlen + 4) / block_size;
	active_state->p_read.bytes += active_state->packlen + 4;
d1248 1
a1248 1
	cp = buffer_ptr(&active_state->incoming_packet);
d1255 2
a1256 2
	buffer_consume(&active_state->incoming_packet, 4 + 1);
	buffer_consume_end(&active_state->incoming_packet, padlen);
d1258 1
a1258 2
	DBG(debug("input: len before de-compress %d",
	    buffer_len(&active_state->incoming_packet)));
d1260 5
a1264 7
		buffer_clear(&active_state->compression_buffer);
		buffer_uncompress(&active_state->incoming_packet,
		    &active_state->compression_buffer);
		buffer_clear(&active_state->incoming_packet);
		buffer_append(&active_state->incoming_packet,
		    buffer_ptr(&active_state->compression_buffer),
		    buffer_len(&active_state->compression_buffer));
d1266 1
a1266 1
		    buffer_len(&active_state->incoming_packet)));
d1272 1
a1272 1
	type = buffer_get_char(&active_state->incoming_packet);
d1277 1
a1277 2
	else if (type == SSH2_MSG_USERAUTH_SUCCESS &&
	    !active_state->server_side)
d1281 1
a1281 1
	buffer_dump(&active_state->incoming_packet);
d1284 1
a1284 1
	active_state->packlen = 0;
d1299 1
a1299 1
				active_state->keep_alive_timeouts = 0;
d1369 3
a1371 3
	if (active_state->packet_discard) {
		active_state->keep_alive_timeouts = 0; /* ?? */
		if (len >= active_state->packet_discard)
d1373 1
a1373 1
		active_state->packet_discard -= len;
d1376 1
a1376 1
	buffer_append(&active_state->input, buf, len);
d1386 1
a1386 1
	buffer_get(&active_state->incoming_packet, &ch, 1);
d1395 1
a1395 9
	return buffer_get_int(&active_state->incoming_packet);
}

/* Returns an 64 bit integer from the packet data. */

u_int64_t
packet_get_int64(void)
{
	return buffer_get_int64(&active_state->incoming_packet);
d1406 1
a1406 1
	buffer_get_bignum(&active_state->incoming_packet, value);
d1412 1
a1412 1
	buffer_get_bignum2(&active_state->incoming_packet, value);
d1418 1
a1418 1
	u_int bytes = buffer_len(&active_state->incoming_packet);
d1422 1
a1422 1
	return buffer_ptr(&active_state->incoming_packet);
d1428 1
a1428 1
	return buffer_len(&active_state->incoming_packet);
d1441 1
a1441 1
	return buffer_get_string(&active_state->incoming_packet, length_ptr);
d1447 1
a1447 1
	return buffer_get_string_ptr(&active_state->incoming_packet, length_ptr);
d1540 1
a1540 2
	int len = buffer_len(&active_state->output);
	int cont;
d1543 1
a1543 3
		cont = 0;
		len = roaming_write(active_state->connection_out,
		    buffer_ptr(&active_state->output), len, &cont);
d1549 1
a1549 1
		if (len == 0 && !cont)
d1551 1
a1551 1
		buffer_consume(&active_state->output, len);
d1567 2
a1568 2
	setp = (fd_set *)xcalloc(howmany(active_state->connection_out + 1,
	    NFDBITS), sizeof(fd_mask));
d1571 3
a1573 3
		memset(setp, 0, howmany(active_state->connection_out + 1,
		    NFDBITS) * sizeof(fd_mask));
		FD_SET(active_state->connection_out, setp);
d1575 2
a1576 2
		if (active_state->packet_timeout_ms > 0) {
			ms_remain = active_state->packet_timeout_ms;
d1580 1
a1580 1
			if (active_state->packet_timeout_ms != -1) {
d1584 2
a1585 2
			if ((ret = select(active_state->connection_out + 1,
			    NULL, setp, NULL, timeoutp)) >= 0)
d1587 1
a1587 1
			if (errno != EAGAIN && errno != EINTR)
d1589 1
a1589 1
			if (active_state->packet_timeout_ms == -1)
d1612 1
a1612 1
	return buffer_len(&active_state->output) != 0;
d1620 2
a1621 2
	if (active_state->interactive_mode)
		return buffer_len(&active_state->output) < 16384;
d1623 1
a1623 1
		return buffer_len(&active_state->output) < 128 * 1024;
d1634 1
a1634 1
	if (setsockopt(active_state->connection_in, IPPROTO_IP, IP_TOS, &tos,
d1645 3
a1647 1
	if (active_state->set_interactive_called)
d1649 1
a1649 1
	active_state->set_interactive_called = 1;
d1652 1
a1652 1
	active_state->interactive_mode = interactive;
d1657 1
a1657 1
	set_nodelay(active_state->connection_in);
d1666 1
a1666 1
	return active_state->interactive_mode;
d1672 3
a1674 1
	if (active_state->set_maxsize_called) {
d1676 1
a1676 1
		    active_state->max_packet_size, s);
d1683 1
a1683 1
	active_state->set_maxsize_called = 1;
d1685 1
a1685 1
	active_state->max_packet_size = s;
a1688 18
int
packet_inc_alive_timeouts(void)
{
	return ++active_state->keep_alive_timeouts;
}

void
packet_set_alive_timeouts(int ka)
{
	active_state->keep_alive_timeouts = ka;
}

u_int
packet_get_maxsize(void)
{
	return active_state->max_packet_size;
}

d1693 1
a1693 1
	active_state->extra_pad = pad;
d1730 4
a1733 6
	    (active_state->p_send.packets > MAX_PACKETS) ||
	    (active_state->p_read.packets > MAX_PACKETS) ||
	    (active_state->max_blocks_out &&
	        (active_state->p_send.blocks > active_state->max_blocks_out)) ||
	    (active_state->max_blocks_in &&
	        (active_state->p_read.blocks > active_state->max_blocks_in));
d1739 1
a1739 1
	active_state->rekey_limit = bytes;
d1745 1
a1745 1
	active_state->server_side = 1;
d1751 1
a1751 66
	active_state->after_authentication = 1;
}

void *
packet_get_input(void)
{
	return (void *)&active_state->input;
}

void *
packet_get_output(void)
{
	return (void *)&active_state->output;
}

void *
packet_get_newkeys(int mode)
{
	return (void *)active_state->newkeys[mode];
}

/*
 * Save the state for the real connection, and use a separate state when
 * resuming a suspended connection.
 */
void
packet_backup_state(void)
{
	struct session_state *tmp;

	close(active_state->connection_in);
	active_state->connection_in = -1;
	close(active_state->connection_out);
	active_state->connection_out = -1;
	if (backup_state)
		tmp = backup_state;
	else
		tmp = alloc_session_state();
	backup_state = active_state;
	active_state = tmp;
}

/*
 * Swap in the old state when resuming a connecion.
 */
void
packet_restore_state(void)
{
	struct session_state *tmp;
	void *buf;
	u_int len;

	tmp = backup_state;
	backup_state = active_state;
	active_state = tmp;
	active_state->connection_in = backup_state->connection_in;
	backup_state->connection_in = -1;
	active_state->connection_out = backup_state->connection_out;
	backup_state->connection_out = -1;
	len = buffer_len(&backup_state->input);
	if (len > 0) {
		buf = buffer_ptr(&backup_state->input);
		buffer_append(&active_state->input, buf, len);
		buffer_clear(&backup_state->input);
		add_recv_bytes(len);
	}
@


