head	1.12;
access;
symbols
	cvs-200910041320:1.1.1.13
	cvs-200903221200:1.1.1.12
	cvs-200812162015:1.1.1.12
	cvs-200804031830:1.1.1.11
	MIRBSD_10:1.10.0.2
	MIRBSD_10_BASE:1.10
	cvs-200803022030:1.1.1.11
	cvs-200709131337:1.1.1.10
	cvs-200709021830:1.1.1.9
	cvs-200708201200:1.1.1.9
	cvs-200706161500:1.1.1.9
	cvs-200705192215:1.1.1.9
	cvs-200704292000:1.1.1.8
	cvs-200703080900:1.1.1.7
	cvs-200701251600:1.1.1.7
	cvs-200612111600:1.1.1.6
	cvs-200611090230:1.1.1.6
	OPENBSD_4_0:1.1.1.6
	MIRBSD_9_BASE:1.4
	cvs-200606162342:1.1.1.5
	cvs-200606022000:1.1.1.5
	cvs-200604191000:1.1.1.5
	cvs-200602220045:1.1.1.4
	MIRBSD_8:1.1.1.3.0.2
	MIRBSD_8_BASE:1.1.1.3
	cvs-200512201942:1.1.1.3
	cvs-200511231930:1.1.1.3
	cvs-200507211800:1.1.1.2
	cvs-200506221550:1.1.1.2
	cvs-200505050030:1.1.1.1
	cvs-200504291700:1.1.1.1
	cvs-200504261445:1.1.1.1
	cvs-200504141900:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2009.10.04.14.29.08;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004AC8B1276FC00211;

1.11
date	2008.12.16.20.55.28;	author tg;	state Exp;
branches;
next	1.10;
commitid	100494815C97ECEEDBF;

1.10
date	2008.03.02.21.14.22;	author tg;	state Exp;
branches;
next	1.9;
commitid	10047CB18BB506A8527;

1.9
date	2007.09.13.13.52.54;	author tg;	state Exp;
branches;
next	1.8;
commitid	10046E940B668DE9A0B;

1.8
date	2007.05.19.22.22.26;	author tg;	state Exp;
branches;
next	1.7;
commitid	100464F78B83D4D02C5;

1.7
date	2007.04.29.20.23.14;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004634FEC2113C55F5;

1.6
date	2007.01.25.16.18.37;	author tg;	state Exp;
branches;
next	1.5;
commitid	10045B8D86E5B698AD6;

1.5
date	2006.09.20.21.41.04;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004511B578580E7F04;

1.4
date	2006.04.19.10.40.53;	author tg;	state Exp;
branches;
next	1.3;
commitid	100444613BD3A91C28B;

1.3
date	2006.02.22.02.16.48;	author tg;	state Exp;
branches;
next	1.2;
commitid	10043FBC991512A442B;

1.2
date	2006.02.22.01.23.51;	author tg;	state Exp;
branches;
next	1.1;
commitid	10043FBBD2C2C5E7D81;

1.1
date	2005.02.05.17.29.55;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.29.55;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.06.22.15.56.28;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	181342b98a38fe99;

1.1.1.3
date	2005.11.23.19.34.15;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	116a4384c4467ffc;

1.1.1.4
date	2006.02.22.00.51.36;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	10043FBB5A933C3BB9B;

1.1.1.5
date	2006.04.19.10.15.04;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	10044460DB21E1F715C;

1.1.1.6
date	2006.09.20.19.06.49;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	10045119150397FC669;

1.1.1.7
date	2007.01.25.16.13.16;	author tg;	state Exp;
branches;
next	1.1.1.8;
commitid	10045B8D7100791C016;

1.1.1.8
date	2007.04.29.20.07.02;	author tg;	state Exp;
branches;
next	1.1.1.9;
commitid	1004634FAED5BC54DF0;

1.1.1.9
date	2007.05.19.22.17.19;	author tg;	state Exp;
branches;
next	1.1.1.10;
commitid	100464F777F381179CF;

1.1.1.10
date	2007.09.13.13.39.03;	author tg;	state Exp;
branches;
next	1.1.1.11;
commitid	10046E93D7724AAC1F8;

1.1.1.11
date	2008.03.02.20.40.42;	author tg;	state Exp;
branches;
next	1.1.1.12;
commitid	10047CB10DD30FAF062;

1.1.1.12
date	2008.12.16.20.15.34;	author tg;	state Exp;
branches;
next	1.1.1.13;
commitid	10049480C7A2701F5C0;

1.1.1.13
date	2009.10.04.13.25.45;	author tg;	state Exp;
branches;
next	;
commitid	1004AC8A2663BC008C5;


desc
@@


1.12
log
@• merge newer OpenSSH
• KNF in our diff – style(9)
• some const cleanliness (build with __CRAZY=Yes mostly)
@
text
@/* $OpenBSD: sftp-server.c,v 1.87 2009/08/31 20:56:02 djm Exp $ */
/*
 * Copyright (c) 2000-2004 Markus Friedl.  All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/mount.h>
#include <sys/statvfs.h>

#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <pwd.h>
#include <time.h>
#include <unistd.h>
#include <stdarg.h>

#include "xmalloc.h"
#include "buffer.h"
#include "log.h"
#include "misc.h"
#include "uidswap.h"

#include "sftp.h"
#include "sftp-common.h"

__RCSID("$MirOS: src/usr.bin/ssh/sftp-server.c,v 1.11 2008/12/16 20:55:28 tg Exp $");

extern const char *__progname;

/* helper */
#define get_int64()			buffer_get_int64(&iqueue);
#define get_int()			buffer_get_int(&iqueue);
#define get_string(lenp)		buffer_get_string(&iqueue, lenp);

/* Our verbosity */
LogLevel log_level = SYSLOG_LEVEL_ERROR;

/* Our client */
struct passwd *pw = NULL;
char *client_addr = NULL;

/* input and output queue */
Buffer iqueue;
Buffer oqueue;

/* Version of client */
int version;

/* portable attributes, etc. */

typedef struct Stat Stat;

struct Stat {
	char *name;
	char *long_name;
	Attrib attrib;
};

static int
errno_to_portable(int unixerrno)
{
	int ret = 0;

	switch (unixerrno) {
	case 0:
		ret = SSH2_FX_OK;
		break;
	case ENOENT:
	case ENOTDIR:
	case EBADF:
	case ELOOP:
		ret = SSH2_FX_NO_SUCH_FILE;
		break;
	case EPERM:
	case EACCES:
	case EFAULT:
		ret = SSH2_FX_PERMISSION_DENIED;
		break;
	case ENAMETOOLONG:
	case EINVAL:
		ret = SSH2_FX_BAD_MESSAGE;
		break;
	case ENOSYS:
		ret = SSH2_FX_OP_UNSUPPORTED;
		break;
	default:
		ret = SSH2_FX_FAILURE;
		break;
	}
	return ret;
}

static int
flags_from_portable(int pflags)
{
	int flags = 0;

	if ((pflags & SSH2_FXF_READ) &&
	    (pflags & SSH2_FXF_WRITE)) {
		flags = O_RDWR;
	} else if (pflags & SSH2_FXF_READ) {
		flags = O_RDONLY;
	} else if (pflags & SSH2_FXF_WRITE) {
		flags = O_WRONLY;
	}
	if (pflags & SSH2_FXF_CREAT)
		flags |= O_CREAT;
	if (pflags & SSH2_FXF_TRUNC)
		flags |= O_TRUNC;
	if (pflags & SSH2_FXF_EXCL)
		flags |= O_EXCL;
	return flags;
}

static const char *
string_from_portable(int pflags)
{
	static char ret[128];

	*ret = '\0';

#define PAPPEND(str)	{				\
		if (*ret != '\0')			\
			strlcat(ret, ",", sizeof(ret));	\
		strlcat(ret, str, sizeof(ret));		\
	}

	if (pflags & SSH2_FXF_READ)
		PAPPEND("READ")
	if (pflags & SSH2_FXF_WRITE)
		PAPPEND("WRITE")
	if (pflags & SSH2_FXF_CREAT)
		PAPPEND("CREATE")
	if (pflags & SSH2_FXF_TRUNC)
		PAPPEND("TRUNCATE")
	if (pflags & SSH2_FXF_EXCL)
		PAPPEND("EXCL")

	return ret;
}

static Attrib *
get_attrib(void)
{
	return decode_attrib(&iqueue);
}

/* handle handles */

typedef struct Handle Handle;
struct Handle {
	int use;
	DIR *dirp;
	int fd;
	char *name;
	u_int64_t bytes_read, bytes_write;
	int next_unused;
};

enum {
	HANDLE_UNUSED,
	HANDLE_DIR,
	HANDLE_FILE
};

Handle *handles = NULL;
u_int num_handles = 0;
int first_unused_handle = -1;

static void handle_unused(int i)
{
	handles[i].use = HANDLE_UNUSED;
	handles[i].next_unused = first_unused_handle;
	first_unused_handle = i;
}

static int
handle_new(int use, const char *name, int fd, DIR *dirp)
{
	int i;

	if (first_unused_handle == -1) {
		if (num_handles + 1 <= num_handles)
			return -1;
		num_handles++;
		handles = xrealloc(handles, num_handles, sizeof(Handle));
		handle_unused(num_handles - 1);
	}

	i = first_unused_handle;
	first_unused_handle = handles[i].next_unused;

	handles[i].use = use;
	handles[i].dirp = dirp;
	handles[i].fd = fd;
	handles[i].name = xstrdup(name);
	handles[i].bytes_read = handles[i].bytes_write = 0;

	return i;
}

static int
handle_is_ok(int i, int type)
{
	return i >= 0 && (u_int)i < num_handles && handles[i].use == type;
}

static int
handle_to_string(int handle, char **stringp, int *hlenp)
{
	if (stringp == NULL || hlenp == NULL)
		return -1;
	*stringp = xmalloc(sizeof(int32_t));
	put_u32(*stringp, handle);
	*hlenp = sizeof(int32_t);
	return 0;
}

static int
handle_from_string(const char *handle, u_int hlen)
{
	int val;

	if (hlen != sizeof(int32_t))
		return -1;
	val = get_u32(handle);
	if (handle_is_ok(val, HANDLE_FILE) ||
	    handle_is_ok(val, HANDLE_DIR))
		return val;
	return -1;
}

static char *
handle_to_name(int handle)
{
	if (handle_is_ok(handle, HANDLE_DIR)||
	    handle_is_ok(handle, HANDLE_FILE))
		return handles[handle].name;
	return NULL;
}

static DIR *
handle_to_dir(int handle)
{
	if (handle_is_ok(handle, HANDLE_DIR))
		return handles[handle].dirp;
	return NULL;
}

static int
handle_to_fd(int handle)
{
	if (handle_is_ok(handle, HANDLE_FILE))
		return handles[handle].fd;
	return -1;
}

static void
handle_update_read(int handle, ssize_t bytes)
{
	if (handle_is_ok(handle, HANDLE_FILE) && bytes > 0)
		handles[handle].bytes_read += bytes;
}

static void
handle_update_write(int handle, ssize_t bytes)
{
	if (handle_is_ok(handle, HANDLE_FILE) && bytes > 0)
		handles[handle].bytes_write += bytes;
}

static u_int64_t
handle_bytes_read(int handle)
{
	if (handle_is_ok(handle, HANDLE_FILE))
		return (handles[handle].bytes_read);
	return 0;
}

static u_int64_t
handle_bytes_write(int handle)
{
	if (handle_is_ok(handle, HANDLE_FILE))
		return (handles[handle].bytes_write);
	return 0;
}

static int
handle_close(int handle)
{
	int ret = -1;

	if (handle_is_ok(handle, HANDLE_FILE)) {
		ret = close(handles[handle].fd);
		xfree(handles[handle].name);
		handle_unused(handle);
	} else if (handle_is_ok(handle, HANDLE_DIR)) {
		ret = closedir(handles[handle].dirp);
		xfree(handles[handle].name);
		handle_unused(handle);
	} else {
		errno = ENOENT;
	}
	return ret;
}

static void
handle_log_close(int handle, const char *emsg)
{
	if (handle_is_ok(handle, HANDLE_FILE)) {
		logit("%s%sclose \"%s\" bytes read %llu written %llu",
		    emsg == NULL ? "" : emsg, emsg == NULL ? "" : " ",
		    handle_to_name(handle),
		    (unsigned long long)handle_bytes_read(handle),
		    (unsigned long long)handle_bytes_write(handle));
	} else {
		logit("%s%sclosedir \"%s\"",
		    emsg == NULL ? "" : emsg, emsg == NULL ? "" : " ",
		    handle_to_name(handle));
	}
}

static void
handle_log_exit(void)
{
	u_int i;

	for (i = 0; i < num_handles; i++)
		if (handles[i].use != HANDLE_UNUSED)
			handle_log_close(i, "forced");
}

static int
get_handle(void)
{
	char *handle;
	int val = -1;
	u_int hlen;

	handle = get_string(&hlen);
	if (hlen < 256)
		val = handle_from_string(handle, hlen);
	xfree(handle);
	return val;
}

/* send replies */

static void
send_msg(Buffer *m)
{
	int mlen = buffer_len(m);

	buffer_put_int(&oqueue, mlen);
	buffer_append(&oqueue, buffer_ptr(m), mlen);
	buffer_consume(m, mlen);
}

static const char *
status_to_message(u_int32_t status)
{
	const char *status_messages[] = {
		"Success",			/* SSH_FX_OK */
		"End of file",			/* SSH_FX_EOF */
		"No such file",			/* SSH_FX_NO_SUCH_FILE */
		"Permission denied",		/* SSH_FX_PERMISSION_DENIED */
		"Failure",			/* SSH_FX_FAILURE */
		"Bad message",			/* SSH_FX_BAD_MESSAGE */
		"No connection",		/* SSH_FX_NO_CONNECTION */
		"Connection lost",		/* SSH_FX_CONNECTION_LOST */
		"Operation unsupported",	/* SSH_FX_OP_UNSUPPORTED */
		"Unknown error"			/* Others */
	};
	return (status_messages[MIN(status,SSH2_FX_MAX)]);
}

static void
send_status(u_int32_t id, u_int32_t status)
{
	Buffer msg;

	debug3("request %u: sent status %u", id, status);
	if (log_level > SYSLOG_LEVEL_VERBOSE ||
	    (status != SSH2_FX_OK && status != SSH2_FX_EOF))
		logit("sent status %s", status_to_message(status));
	buffer_init(&msg);
	buffer_put_char(&msg, SSH2_FXP_STATUS);
	buffer_put_int(&msg, id);
	buffer_put_int(&msg, status);
	if (version >= 3) {
		buffer_put_cstring(&msg, status_to_message(status));
		buffer_put_cstring(&msg, "");
	}
	send_msg(&msg);
	buffer_free(&msg);
}
static void
send_data_or_handle(char type, u_int32_t id, const char *data, int dlen)
{
	Buffer msg;

	buffer_init(&msg);
	buffer_put_char(&msg, type);
	buffer_put_int(&msg, id);
	buffer_put_string(&msg, data, dlen);
	send_msg(&msg);
	buffer_free(&msg);
}

static void
send_data(u_int32_t id, const char *data, int dlen)
{
	debug("request %u: sent data len %d", id, dlen);
	send_data_or_handle(SSH2_FXP_DATA, id, data, dlen);
}

static void
send_handle(u_int32_t id, int handle)
{
	char *string;
	int hlen;

	handle_to_string(handle, &string, &hlen);
	debug("request %u: sent handle handle %d", id, handle);
	send_data_or_handle(SSH2_FXP_HANDLE, id, string, hlen);
	xfree(string);
}

static void
send_names(u_int32_t id, int count, const Stat *stats)
{
	Buffer msg;
	int i;

	buffer_init(&msg);
	buffer_put_char(&msg, SSH2_FXP_NAME);
	buffer_put_int(&msg, id);
	buffer_put_int(&msg, count);
	debug("request %u: sent names count %d", id, count);
	for (i = 0; i < count; i++) {
		buffer_put_cstring(&msg, stats[i].name);
		buffer_put_cstring(&msg, stats[i].long_name);
		encode_attrib(&msg, &stats[i].attrib);
	}
	send_msg(&msg);
	buffer_free(&msg);
}

static void
send_attrib(u_int32_t id, const Attrib *a)
{
	Buffer msg;

	debug("request %u: sent attrib have 0x%x", id, a->flags);
	buffer_init(&msg);
	buffer_put_char(&msg, SSH2_FXP_ATTRS);
	buffer_put_int(&msg, id);
	encode_attrib(&msg, a);
	send_msg(&msg);
	buffer_free(&msg);
}

static void
send_statvfs(u_int32_t id, struct statvfs *st)
{
	Buffer msg;
	u_int64_t flag;

	flag = (st->f_flag & ST_RDONLY) ? SSH2_FXE_STATVFS_ST_RDONLY : 0;
	flag |= (st->f_flag & ST_NOSUID) ? SSH2_FXE_STATVFS_ST_NOSUID : 0;

	buffer_init(&msg);
	buffer_put_char(&msg, SSH2_FXP_EXTENDED_REPLY);
	buffer_put_int(&msg, id);
	buffer_put_int64(&msg, st->f_bsize);
	buffer_put_int64(&msg, st->f_frsize);
	buffer_put_int64(&msg, st->f_blocks);
	buffer_put_int64(&msg, st->f_bfree);
	buffer_put_int64(&msg, st->f_bavail);
	buffer_put_int64(&msg, st->f_files);
	buffer_put_int64(&msg, st->f_ffree);
	buffer_put_int64(&msg, st->f_favail);
	buffer_put_int64(&msg, st->f_fsid);
	buffer_put_int64(&msg, flag);
	buffer_put_int64(&msg, st->f_namemax);
	send_msg(&msg);
	buffer_free(&msg);
}

/* parse incoming */

static void
process_init(void)
{
	Buffer msg;

	version = get_int();
	verbose("received client version %d", version);
	buffer_init(&msg);
	buffer_put_char(&msg, SSH2_FXP_VERSION);
	buffer_put_int(&msg, SSH2_FILEXFER_VERSION);
	/* POSIX rename extension */
	buffer_put_cstring(&msg, "posix-rename@@openssh.com");
	buffer_put_cstring(&msg, "1"); /* version */
	/* statvfs extension */
	buffer_put_cstring(&msg, "statvfs@@openssh.com");
	buffer_put_cstring(&msg, "2"); /* version */
	/* fstatvfs extension */
	buffer_put_cstring(&msg, "fstatvfs@@openssh.com");
	buffer_put_cstring(&msg, "2"); /* version */
	send_msg(&msg);
	buffer_free(&msg);
}

static void
process_open(void)
{
	u_int32_t id, pflags;
	Attrib *a;
	char *name;
	int handle, fd, flags, mode, status = SSH2_FX_FAILURE;

	id = get_int();
	name = get_string(NULL);
	pflags = get_int();		/* portable flags */
	debug3("request %u: open flags %d", id, pflags);
	a = get_attrib();
	flags = flags_from_portable(pflags);
	mode = (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a->perm : 0666;
	logit("open \"%s\" flags %s mode 0%o",
	    name, string_from_portable(pflags), mode);
	fd = open(name, flags, mode);
	if (fd < 0) {
		status = errno_to_portable(errno);
	} else {
		handle = handle_new(HANDLE_FILE, name, fd, NULL);
		if (handle < 0) {
			close(fd);
		} else {
			send_handle(id, handle);
			status = SSH2_FX_OK;
		}
	}
	if (status != SSH2_FX_OK)
		send_status(id, status);
	xfree(name);
}

static void
process_close(void)
{
	u_int32_t id;
	int handle, ret, status = SSH2_FX_FAILURE;

	id = get_int();
	handle = get_handle();
	debug3("request %u: close handle %u", id, handle);
	handle_log_close(handle, NULL);
	ret = handle_close(handle);
	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
	send_status(id, status);
}

static void
process_read(void)
{
	char buf[64*1024];
	u_int32_t id, len;
	int handle, fd, ret, status = SSH2_FX_FAILURE;
	u_int64_t off;

	id = get_int();
	handle = get_handle();
	off = get_int64();
	len = get_int();

	debug("request %u: read \"%s\" (handle %d) off %llu len %d",
	    id, handle_to_name(handle), handle, (unsigned long long)off, len);
	if (len > sizeof buf) {
		len = sizeof buf;
		debug2("read change len %d", len);
	}
	fd = handle_to_fd(handle);
	if (fd >= 0) {
		if (lseek(fd, off, SEEK_SET) < 0) {
			error("process_read: seek failed");
			status = errno_to_portable(errno);
		} else {
			ret = read(fd, buf, len);
			if (ret < 0) {
				status = errno_to_portable(errno);
			} else if (ret == 0) {
				status = SSH2_FX_EOF;
			} else {
				send_data(id, buf, ret);
				status = SSH2_FX_OK;
				handle_update_read(handle, ret);
			}
		}
	}
	if (status != SSH2_FX_OK)
		send_status(id, status);
}

static void
process_write(void)
{
	u_int32_t id;
	u_int64_t off;
	u_int len;
	int handle, fd, ret, status = SSH2_FX_FAILURE;
	char *data;

	id = get_int();
	handle = get_handle();
	off = get_int64();
	data = get_string(&len);

	debug("request %u: write \"%s\" (handle %d) off %llu len %d",
	    id, handle_to_name(handle), handle, (unsigned long long)off, len);
	fd = handle_to_fd(handle);
	if (fd >= 0) {
		if (lseek(fd, off, SEEK_SET) < 0) {
			status = errno_to_portable(errno);
			error("process_write: seek failed");
		} else {
/* XXX ATOMICIO ? */
			ret = write(fd, data, len);
			if (ret < 0) {
				error("process_write: write failed");
				status = errno_to_portable(errno);
			} else if ((size_t)ret == len) {
				status = SSH2_FX_OK;
				handle_update_write(handle, ret);
			} else {
				debug2("nothing at all written");
			}
		}
	}
	send_status(id, status);
	xfree(data);
}

static void
process_do_stat(int do_lstat)
{
	Attrib a;
	struct stat st;
	u_int32_t id;
	char *name;
	int ret, status = SSH2_FX_FAILURE;

	id = get_int();
	name = get_string(NULL);
	debug3("request %u: %sstat", id, do_lstat ? "l" : "");
	verbose("%sstat name \"%s\"", do_lstat ? "l" : "", name);
	ret = do_lstat ? lstat(name, &st) : stat(name, &st);
	if (ret < 0) {
		status = errno_to_portable(errno);
	} else {
		stat_to_attrib(&st, &a);
		send_attrib(id, &a);
		status = SSH2_FX_OK;
	}
	if (status != SSH2_FX_OK)
		send_status(id, status);
	xfree(name);
}

static void
process_stat(void)
{
	process_do_stat(0);
}

static void
process_lstat(void)
{
	process_do_stat(1);
}

static void
process_fstat(void)
{
	Attrib a;
	struct stat st;
	u_int32_t id;
	int fd, ret, handle, status = SSH2_FX_FAILURE;

	id = get_int();
	handle = get_handle();
	debug("request %u: fstat \"%s\" (handle %u)",
	    id, handle_to_name(handle), handle);
	fd = handle_to_fd(handle);
	if (fd >= 0) {
		ret = fstat(fd, &st);
		if (ret < 0) {
			status = errno_to_portable(errno);
		} else {
			stat_to_attrib(&st, &a);
			send_attrib(id, &a);
			status = SSH2_FX_OK;
		}
	}
	if (status != SSH2_FX_OK)
		send_status(id, status);
}

static struct timeval *
attrib_to_tv(const Attrib *a)
{
	static struct timeval tv[2];

	tv[0].tv_sec = a->atime;
	tv[0].tv_usec = 0;
	tv[1].tv_sec = a->mtime;
	tv[1].tv_usec = 0;
	return tv;
}

static void
process_setstat(void)
{
	Attrib *a;
	u_int32_t id;
	char *name;
	int status = SSH2_FX_OK, ret;

	id = get_int();
	name = get_string(NULL);
	a = get_attrib();
	debug("request %u: setstat name \"%s\"", id, name);
	if (a->flags & SSH2_FILEXFER_ATTR_SIZE) {
		logit("set \"%s\" size %llu",
		    name, (unsigned long long)a->size);
		ret = truncate(name, a->size);
		if (ret == -1)
			status = errno_to_portable(errno);
	}
	if (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {
		logit("set \"%s\" mode %04o", name, a->perm);
		ret = chmod(name, a->perm & 07777);
		if (ret == -1)
			status = errno_to_portable(errno);
	}
	if (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {
		char buf[64];
		time_t t = a->mtime;

		strftime(buf, sizeof(buf), "%Y%m%d-%H:%M:%S",
		    localtime(&t));
		logit("set \"%s\" modtime %s", name, buf);
		ret = utimes(name, attrib_to_tv(a));
		if (ret == -1)
			status = errno_to_portable(errno);
	}
	if (a->flags & SSH2_FILEXFER_ATTR_UIDGID) {
		logit("set \"%s\" owner %lu group %lu", name,
		    (u_long)a->uid, (u_long)a->gid);
		ret = chown(name, a->uid, a->gid);
		if (ret == -1)
			status = errno_to_portable(errno);
	}
	send_status(id, status);
	xfree(name);
}

static void
process_fsetstat(void)
{
	Attrib *a;
	u_int32_t id;
	int handle, fd, ret;
	int status = SSH2_FX_OK;

	id = get_int();
	handle = get_handle();
	a = get_attrib();
	debug("request %u: fsetstat handle %d", id, handle);
	fd = handle_to_fd(handle);
	if (fd < 0) {
		status = SSH2_FX_FAILURE;
	} else {
		char *name = handle_to_name(handle);

		if (a->flags & SSH2_FILEXFER_ATTR_SIZE) {
			logit("set \"%s\" size %llu",
			    name, (unsigned long long)a->size);
			ret = ftruncate(fd, a->size);
			if (ret == -1)
				status = errno_to_portable(errno);
		}
		if (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {
			logit("set \"%s\" mode %04o", name, a->perm);
			ret = fchmod(fd, a->perm & 07777);
			if (ret == -1)
				status = errno_to_portable(errno);
		}
		if (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {
			char buf[64];
			time_t t = a->mtime;

			strftime(buf, sizeof(buf), "%Y%m%d-%H:%M:%S",
			    localtime(&t));
			logit("set \"%s\" modtime %s", name, buf);
			ret = futimes(fd, attrib_to_tv(a));
			if (ret == -1)
				status = errno_to_portable(errno);
		}
		if (a->flags & SSH2_FILEXFER_ATTR_UIDGID) {
			logit("set \"%s\" owner %lu group %lu", name,
			    (u_long)a->uid, (u_long)a->gid);
			ret = fchown(fd, a->uid, a->gid);
			if (ret == -1)
				status = errno_to_portable(errno);
		}
	}
	send_status(id, status);
}

static void
process_opendir(void)
{
	DIR *dirp = NULL;
	char *path;
	int handle, status = SSH2_FX_FAILURE;
	u_int32_t id;

	id = get_int();
	path = get_string(NULL);
	debug3("request %u: opendir", id);
	logit("opendir \"%s\"", path);
	dirp = opendir(path);
	if (dirp == NULL) {
		status = errno_to_portable(errno);
	} else {
		handle = handle_new(HANDLE_DIR, path, 0, dirp);
		if (handle < 0) {
			closedir(dirp);
		} else {
			send_handle(id, handle);
			status = SSH2_FX_OK;
		}

	}
	if (status != SSH2_FX_OK)
		send_status(id, status);
	xfree(path);
}

static void
process_readdir(void)
{
	DIR *dirp;
	struct dirent *dp;
	char *path;
	int handle;
	u_int32_t id;

	id = get_int();
	handle = get_handle();
	debug("request %u: readdir \"%s\" (handle %d)", id,
	    handle_to_name(handle), handle);
	dirp = handle_to_dir(handle);
	path = handle_to_name(handle);
	if (dirp == NULL || path == NULL) {
		send_status(id, SSH2_FX_FAILURE);
	} else {
		struct stat st;
		char pathname[MAXPATHLEN];
		Stat *stats;
		int nstats = 10, count = 0, i;

		stats = xcalloc(nstats, sizeof(Stat));
		while ((dp = readdir(dirp)) != NULL) {
			if (count >= nstats) {
				nstats *= 2;
				stats = xrealloc(stats, nstats, sizeof(Stat));
			}
/* XXX OVERFLOW ? */
			snprintf(pathname, sizeof pathname, "%s%s%s", path,
			    strcmp(path, "/") ? "/" : "", dp->d_name);
			if (lstat(pathname, &st) < 0)
				continue;
			stat_to_attrib(&st, &(stats[count].attrib));
			stats[count].name = xstrdup(dp->d_name);
			stats[count].long_name = ls_file(dp->d_name, &st, 0);
			count++;
			/* send up to 100 entries in one message */
			/* XXX check packet size instead */
			if (count == 100)
				break;
		}
		if (count > 0) {
			send_names(id, count, stats);
			for (i = 0; i < count; i++) {
				xfree(stats[i].name);
				xfree(stats[i].long_name);
			}
		} else {
			send_status(id, SSH2_FX_EOF);
		}
		xfree(stats);
	}
}

static void
process_remove(void)
{
	char *name;
	u_int32_t id;
	int status = SSH2_FX_FAILURE;
	int ret;

	id = get_int();
	name = get_string(NULL);
	debug3("request %u: remove", id);
	logit("remove name \"%s\"", name);
	ret = unlink(name);
	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
	send_status(id, status);
	xfree(name);
}

static void
process_mkdir(void)
{
	Attrib *a;
	u_int32_t id;
	char *name;
	int ret, mode, status = SSH2_FX_FAILURE;

	id = get_int();
	name = get_string(NULL);
	a = get_attrib();
	mode = (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ?
	    a->perm & 07777 : 0777;
	debug3("request %u: mkdir", id);
	logit("mkdir name \"%s\" mode 0%o", name, mode);
	ret = mkdir(name, mode);
	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
	send_status(id, status);
	xfree(name);
}

static void
process_rmdir(void)
{
	u_int32_t id;
	char *name;
	int ret, status;

	id = get_int();
	name = get_string(NULL);
	debug3("request %u: rmdir", id);
	logit("rmdir name \"%s\"", name);
	ret = rmdir(name);
	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
	send_status(id, status);
	xfree(name);
}

static void
process_realpath(void)
{
	char resolvedname[MAXPATHLEN];
	u_int32_t id;
	char *path;

	id = get_int();
	path = get_string(NULL);
	if (path[0] == '\0') {
		xfree(path);
		path = xstrdup(".");
	}
	debug3("request %u: realpath", id);
	verbose("realpath \"%s\"", path);
	if (realpath(path, resolvedname) == NULL) {
		send_status(id, errno_to_portable(errno));
	} else {
		Stat s;
		attrib_clear(&s.attrib);
		s.name = s.long_name = resolvedname;
		send_names(id, 1, &s);
	}
	xfree(path);
}

static void
process_rename(void)
{
	u_int32_t id;
	char *oldpath, *newpath;
	int status;
	struct stat sb;

	id = get_int();
	oldpath = get_string(NULL);
	newpath = get_string(NULL);
	debug3("request %u: rename", id);
	logit("rename old \"%s\" new \"%s\"", oldpath, newpath);
	status = SSH2_FX_FAILURE;
	if (lstat(oldpath, &sb) == -1)
		status = errno_to_portable(errno);
	else if (S_ISREG(sb.st_mode)) {
		/* Race-free rename of regular files */
		if (link(oldpath, newpath) == -1) {
			if (errno == EOPNOTSUPP) {
				struct stat st;

				/*
				 * fs doesn't support links, so fall back to
				 * stat+rename.  This is racy.
				 */
				if (stat(newpath, &st) == -1) {
					if (rename(oldpath, newpath) == -1)
						status =
						    errno_to_portable(errno);
					else
						status = SSH2_FX_OK;
				}
			} else {
				status = errno_to_portable(errno);
			}
		} else if (unlink(oldpath) == -1) {
			status = errno_to_portable(errno);
			/* clean spare link */
			unlink(newpath);
		} else
			status = SSH2_FX_OK;
	} else if (stat(newpath, &sb) == -1) {
		if (rename(oldpath, newpath) == -1)
			status = errno_to_portable(errno);
		else
			status = SSH2_FX_OK;
	}
	send_status(id, status);
	xfree(oldpath);
	xfree(newpath);
}

static void
process_readlink(void)
{
	u_int32_t id;
	int len;
	char buf[MAXPATHLEN];
	char *path;

	id = get_int();
	path = get_string(NULL);
	debug3("request %u: readlink", id);
	verbose("readlink \"%s\"", path);
	if ((len = readlink(path, buf, sizeof(buf) - 1)) == -1)
		send_status(id, errno_to_portable(errno));
	else {
		Stat s;

		buf[len] = '\0';
		attrib_clear(&s.attrib);
		s.name = s.long_name = buf;
		send_names(id, 1, &s);
	}
	xfree(path);
}

static void
process_symlink(void)
{
	u_int32_t id;
	char *oldpath, *newpath;
	int ret, status;

	id = get_int();
	oldpath = get_string(NULL);
	newpath = get_string(NULL);
	debug3("request %u: symlink", id);
	logit("symlink old \"%s\" new \"%s\"", oldpath, newpath);
	/* this will fail if 'newpath' exists */
	ret = symlink(oldpath, newpath);
	status = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;
	send_status(id, status);
	xfree(oldpath);
	xfree(newpath);
}

static void
process_extended_posix_rename(u_int32_t id)
{
	char *oldpath, *newpath;

	oldpath = get_string(NULL);
	newpath = get_string(NULL);
	debug3("request %u: posix-rename", id);
	logit("posix-rename old \"%s\" new \"%s\"", oldpath, newpath);
	if (rename(oldpath, newpath) == -1)
		send_status(id, errno_to_portable(errno));
	else
		send_status(id, SSH2_FX_OK);
	xfree(oldpath);
	xfree(newpath);
}

static void
process_extended_statvfs(u_int32_t id)
{
	char *path;
	struct statvfs st;

	path = get_string(NULL);
	debug3("request %u: statfs", id);
	logit("statfs \"%s\"", path);

	if (statvfs(path, &st) != 0)
		send_status(id, errno_to_portable(errno));
	else
		send_statvfs(id, &st);
        xfree(path);
}

static void
process_extended_fstatvfs(u_int32_t id)
{
	int handle, fd;
	struct statvfs st;

	handle = get_handle();
	debug("request %u: fstatvfs \"%s\" (handle %u)",
	    id, handle_to_name(handle), handle);
	if ((fd = handle_to_fd(handle)) < 0) {
		send_status(id, SSH2_FX_FAILURE);
		return;
	}
	if (fstatvfs(fd, &st) != 0)
		send_status(id, errno_to_portable(errno));
	else
		send_statvfs(id, &st);
}

static void
process_extended(void)
{
	u_int32_t id;
	char *request;

	id = get_int();
	request = get_string(NULL);
	if (strcmp(request, "posix-rename@@openssh.com") == 0)
		process_extended_posix_rename(id);
	else if (strcmp(request, "statvfs@@openssh.com") == 0)
		process_extended_statvfs(id);
	else if (strcmp(request, "fstatvfs@@openssh.com") == 0)
		process_extended_fstatvfs(id);
	else
		send_status(id, SSH2_FX_OP_UNSUPPORTED);	/* MUST */
	xfree(request);
}

/* stolen from ssh-agent */

static void
process(void)
{
	u_int msg_len;
	u_int buf_len;
	u_int consumed;
	u_int type;
	u_char *cp;

	buf_len = buffer_len(&iqueue);
	if (buf_len < 5)
		return;		/* Incomplete message. */
	cp = buffer_ptr(&iqueue);
	msg_len = get_u32(cp);
	if (msg_len > SFTP_MAX_MSG_LENGTH) {
		error("bad message from %s local user %s",
		    client_addr, pw->pw_name);
		sftp_server_cleanup_exit(11);
	}
	if (buf_len < msg_len + 4)
		return;
	buffer_consume(&iqueue, 4);
	buf_len -= 4;
	type = buffer_get_char(&iqueue);
	switch (type) {
	case SSH2_FXP_INIT:
		process_init();
		break;
	case SSH2_FXP_OPEN:
		process_open();
		break;
	case SSH2_FXP_CLOSE:
		process_close();
		break;
	case SSH2_FXP_READ:
		process_read();
		break;
	case SSH2_FXP_WRITE:
		process_write();
		break;
	case SSH2_FXP_LSTAT:
		process_lstat();
		break;
	case SSH2_FXP_FSTAT:
		process_fstat();
		break;
	case SSH2_FXP_SETSTAT:
		process_setstat();
		break;
	case SSH2_FXP_FSETSTAT:
		process_fsetstat();
		break;
	case SSH2_FXP_OPENDIR:
		process_opendir();
		break;
	case SSH2_FXP_READDIR:
		process_readdir();
		break;
	case SSH2_FXP_REMOVE:
		process_remove();
		break;
	case SSH2_FXP_MKDIR:
		process_mkdir();
		break;
	case SSH2_FXP_RMDIR:
		process_rmdir();
		break;
	case SSH2_FXP_REALPATH:
		process_realpath();
		break;
	case SSH2_FXP_STAT:
		process_stat();
		break;
	case SSH2_FXP_RENAME:
		process_rename();
		break;
	case SSH2_FXP_READLINK:
		process_readlink();
		break;
	case SSH2_FXP_SYMLINK:
		process_symlink();
		break;
	case SSH2_FXP_EXTENDED:
		process_extended();
		break;
	default:
		error("Unknown message %d", type);
		break;
	}
	/* discard the remaining bytes from the current packet */
	if (buf_len < buffer_len(&iqueue)) {
		error("iqueue grew unexpectedly");
		sftp_server_cleanup_exit(255);
	}
	consumed = buf_len - buffer_len(&iqueue);
	if (msg_len < consumed) {
		error("msg_len %d < consumed %d", msg_len, consumed);
		sftp_server_cleanup_exit(255);
	}
	if (msg_len > consumed)
		buffer_consume(&iqueue, msg_len - consumed);
}

/* Cleanup handler that logs active handles upon normal exit */
void
sftp_server_cleanup_exit(int i)
{
	if (pw != NULL && client_addr != NULL) {
		handle_log_exit();
		logit("session closed for local user %s from [%s]",
		    pw->pw_name, client_addr);
	}
	_exit(i);
}

static void
sftp_server_usage(void)
{
	fprintf(stderr,
	    "usage: %s [-he] [-l log_level] [-f log_facility] [-u umask]\n",
	    __progname);
	exit(1);
}

int
sftp_server_main(int argc, char **argv, struct passwd *user_pw)
{
	fd_set *rset, *wset;
	int in, out, max, ch, skipargs = 0, log_stderr = 0;
	ssize_t len, olen, set_size;
	SyslogFacility log_facility = SYSLOG_FACILITY_AUTH;
	char *cp, buf[4*4096];
	const char *errmsg;
	mode_t mask;

	log_init(__progname, log_level, log_facility, log_stderr);

	while (!skipargs && (ch = getopt(argc, argv, "f:l:u:che")) != -1) {
		switch (ch) {
		case 'c':
			/*
			 * Ignore all arguments if we are invoked as a
			 * shell using "sftp-server -c command"
			 */
			skipargs = 1;
			break;
		case 'e':
			log_stderr = 1;
			break;
		case 'l':
			log_level = log_level_number(optarg);
			if (log_level == SYSLOG_LEVEL_NOT_SET)
				error("Invalid log level \"%s\"", optarg);
			break;
		case 'f':
			log_facility = log_facility_number(optarg);
			if (log_facility == SYSLOG_FACILITY_NOT_SET)
				error("Invalid log facility \"%s\"", optarg);
			break;
		case 'u':
			mask = (mode_t)strtonum(optarg, 0, 0777, &errmsg);
			if (errmsg != NULL)
				fatal("Invalid umask \"%s\": %s",
				    optarg, errmsg);
			(void)umask(mask);
			break;
		case 'h':
		default:
			sftp_server_usage();
		}
	}

	log_init(__progname, log_level, log_facility, log_stderr);

	if ((cp = getenv("SSH_CONNECTION")) != NULL) {
		client_addr = xstrdup(cp);
		if ((cp = strchr(client_addr, ' ')) == NULL) {
			error("Malformed SSH_CONNECTION variable: \"%s\"",
			    getenv("SSH_CONNECTION"));
			sftp_server_cleanup_exit(255);
		}
		*cp = '\0';
	} else
		client_addr = xstrdup("UNKNOWN");

	pw = pwcopy(user_pw);

	logit("session opened for local user %s from [%s]",
	    pw->pw_name, client_addr);

	in = dup(STDIN_FILENO);
	out = dup(STDOUT_FILENO);

	max = 0;
	if (in > max)
		max = in;
	if (out > max)
		max = out;

	buffer_init(&iqueue);
	buffer_init(&oqueue);

	set_size = howmany(max + 1, NFDBITS) * sizeof(fd_mask);
	rset = (fd_set *)xmalloc(set_size);
	wset = (fd_set *)xmalloc(set_size);

	for (;;) {
		memset(rset, 0, set_size);
		memset(wset, 0, set_size);

		/*
		 * Ensure that we can read a full buffer and handle
		 * the worst-case length packet it can generate,
		 * otherwise apply backpressure by stopping reads.
		 */
		if (buffer_check_alloc(&iqueue, sizeof(buf)) &&
		    buffer_check_alloc(&oqueue, SFTP_MAX_MSG_LENGTH))
			FD_SET(in, rset);

		olen = buffer_len(&oqueue);
		if (olen > 0)
			FD_SET(out, wset);

		if (select(max+1, rset, wset, NULL, NULL) < 0) {
			if (errno == EINTR)
				continue;
			error("select: %s", strerror(errno));
			sftp_server_cleanup_exit(2);
		}

		/* copy stdin to iqueue */
		if (FD_ISSET(in, rset)) {
			len = read(in, buf, sizeof buf);
			if (len == 0) {
				debug("read eof");
				sftp_server_cleanup_exit(0);
			} else if (len < 0) {
				error("read: %s", strerror(errno));
				sftp_server_cleanup_exit(1);
			} else {
				buffer_append(&iqueue, buf, len);
			}
		}
		/* send oqueue to stdout */
		if (FD_ISSET(out, wset)) {
			len = write(out, buffer_ptr(&oqueue), olen);
			if (len < 0) {
				error("write: %s", strerror(errno));
				sftp_server_cleanup_exit(1);
			} else {
				buffer_consume(&oqueue, len);
			}
		}

		/*
		 * Process requests from client if we can fit the results
		 * into the output buffer, otherwise stop processing input
		 * and let the output queue drain.
		 */
		if (buffer_check_alloc(&oqueue, SFTP_MAX_MSG_LENGTH))
			process();
	}
}
@


1.11
log
@fastmerge, do not use yet!
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.84 2008/06/26 06:10:09 djm Exp $ */
d44 3
a46 1
__RCSID("$MirOS: src/usr.bin/ssh/sftp-server.c,v 1.10 2008/03/02 21:14:22 tg Exp $");
d326 1
a326 1
handle_log_close(int handle, char *emsg)
a1296 2
	extern char *__progname;

d1298 2
a1299 1
	    "usage: %s [-he] [-l log_level] [-f log_facility]\n", __progname);
d1311 2
a1312 3

	extern char *optarg;
	extern char *__progname;
d1316 1
a1316 1
	while (!skipargs && (ch = getopt(argc, argv, "C:f:l:che")) != -1) {
d1338 7
@


1.10
log
@merge’n’fix
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.78 2008/02/27 20:21:15 djm Exp $ */
d21 2
d44 1
a44 1
__RCSID("$MirOS: src/usr.bin/ssh/sftp-server.c,v 1.9 2007/09/13 13:52:54 tg Exp $");
d99 3
d479 27
d521 6
d758 1
a758 1
		ret = chmod(name, a->perm & 0777);
d811 1
a811 1
			ret = fchmod(fd, a->perm & 0777);
d953 1
a953 1
	    a->perm & 0777 : 0777;
d1121 36
d1166 4
@


1.9
log
@merge and make UMAC-64 default message integrity whatever
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.74 2007/09/13 04:39:04 djm Exp $ */
d42 1
a42 1
__RCSID("$MirOS: src/usr.bin/ssh/sftp-server.c,v 1.8 2007/05/19 22:22:26 tg Exp $");
d168 1
d177 9
a185 9
Handle	handles[100];

static void
handle_init(void)
{
	u_int i;

	for (i = 0; i < sizeof(handles)/sizeof(Handle); i++)
		handles[i].use = HANDLE_UNUSED;
d191 18
a208 1
	u_int i;
d210 1
a210 11
	for (i = 0; i < sizeof(handles)/sizeof(Handle); i++) {
		if (handles[i].use == HANDLE_UNUSED) {
			handles[i].use = use;
			handles[i].dirp = dirp;
			handles[i].fd = fd;
			handles[i].name = xstrdup(name);
			handles[i].bytes_read = handles[i].bytes_write = 0;
			return i;
		}
	}
	return -1;
d216 1
a216 2
	return i >= 0 && (u_int)i < sizeof(handles)/sizeof(Handle) &&
	    handles[i].use == type;
a305 1
		handles[handle].use = HANDLE_UNUSED;
d307 1
a309 1
		handles[handle].use = HANDLE_UNUSED;
d311 1
d339 1
a339 1
	for (i = 0; i < sizeof(handles)/sizeof(Handle); i++)
d486 3
d1066 17
d1090 4
a1093 1
	send_status(id, SSH2_FX_OP_UNSUPPORTED);		/* MUST */
d1116 1
a1116 1
		cleanup_exit(11);
d1189 4
a1192 2
	if (buf_len < buffer_len(&iqueue))
		fatal("iqueue grew unexpectedly");
d1194 4
a1197 2
	if (msg_len < consumed)
		fatal("msg_len %d < consumed %d", msg_len, consumed);
d1204 1
a1204 1
cleanup_exit(int i)
d1215 1
a1215 1
usage(void)
d1225 1
a1225 1
main(int argc, char **argv)
a1235 3
	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

d1262 1
a1262 1
			usage();
d1270 2
a1271 2
		if ((cp = strchr(client_addr, ' ')) == NULL)
			fatal("Malformed SSH_CONNECTION variable: \"%s\"",
d1273 2
d1279 1
a1279 3
	if ((pw = getpwuid(getuid())) == NULL)
		fatal("No user found for uid %lu", (u_long)getuid());
	pw = pwcopy(pw);
a1283 2
	handle_init();

d1321 1
a1321 1
			cleanup_exit(2);
d1329 1
a1329 1
				cleanup_exit(0);
d1332 1
a1332 1
				cleanup_exit(1);
d1342 1
a1342 1
				cleanup_exit(1);
@


1.8
log
@merge
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.73 2007/05/17 07:55:29 djm Exp $ */
d42 1
a42 1
__RCSID("$MirOS: src/usr.bin/ssh/sftp-server.c,v 1.7 2007/04/29 20:23:14 tg Exp $");
d1226 1
a1226 1
			if (log_level == SYSLOG_FACILITY_NOT_SET)
@


1.7
log
@merge openssh
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.72 2007/04/18 01:12:43 stevesk Exp $ */
d42 1
a42 1
__RCSID("$MirOS: src/usr.bin/ssh/sftp-server.c,v 1.6 2007/01/25 16:18:37 tg Exp $");
d1197 1
a1197 1
	char *cp;
d1275 9
a1283 1
		FD_SET(in, rset);
a1296 1
			char buf[4*4096];
d1318 8
a1325 2
		/* process requests from client */
		process();
@


1.6
log
@automerge, bump vsn
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.71 2007/01/03 07:22:36 stevesk Exp $ */
d42 1
a42 1
__RCSID("$MirOS: src/usr.bin/ssh/sftp-server.c,v 1.5 2006/09/20 21:41:04 tg Exp $");
d318 2
a319 1
		    handle_bytes_read(handle), handle_bytes_write(handle));
d702 2
a703 1
		logit("set \"%s\" size %llu", name, a->size);
d755 2
a756 1
			logit("set \"%s\" size %llu", name, a->size);
@


1.5
log
@finish merging
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.70 2006/08/03 03:34:42 deraadt Exp $ */
d42 1
a42 1
__RCSID("$MirOS$");
d662 1
a662 1
	if (fd  >= 0) {
@


1.4
log
@merge and clean up
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.57 2006/03/30 09:58:16 djm Exp $ */
d18 2
a19 3
#include "includes.h"
__RCSID("$MirOS: src/usr.bin/ssh/sftp-server.c,v 1.3 2006/02/22 02:16:48 tg Exp $");

d23 9
d33 1
a34 1
#include "bufaux.h"
a35 1
#include "xmalloc.h"
d37 1
d42 2
d48 7
a54 1
#define TRACE				debug
d126 27
d167 1
d198 1
d262 30
d311 25
d362 2
a363 2
static void
send_status(u_int32_t id, u_int32_t status)
a364 1
	Buffer msg;
d377 7
d385 4
a388 1
	TRACE("sent status id %u error %u", id, status);
d394 1
a394 2
		buffer_put_cstring(&msg,
		    status_messages[MIN(status,SSH2_FX_MAX)]);
d416 1
a416 1
	TRACE("sent data id %u len %d", id, dlen);
d427 1
a427 1
	TRACE("sent handle id %u handle %d", id, handle);
d442 1
a442 1
	TRACE("sent names id %u count %d", id, count);
d457 1
a457 1
	TRACE("sent attrib id %u have 0x%x", id, a->flags);
d474 1
a474 1
	TRACE("client version %d", version);
d493 1
d497 2
a498 1
	TRACE("open id %u name %s flags %d mode 0%o", id, name, pflags, mode);
d524 2
a525 1
	TRACE("close id %u handle %d", id, handle);
d544 2
a545 2
	TRACE("read id %u handle %d off %llu len %d", id, handle,
	    (unsigned long long)off, len);
d548 1
a548 1
		logit("read change len %d", len);
d564 1
d586 2
a587 2
	TRACE("write id %u handle %d off %llu len %d", id, handle,
	    (unsigned long long)off, len);
d601 1
d603 1
a603 1
				logit("nothing at all written");
d622 2
a623 1
	TRACE("%sstat id %u name %s", do_lstat ? "l" : "", id, name);
d659 2
a660 1
	TRACE("fstat id %u handle %d", id, handle);
d699 1
a699 1
	TRACE("setstat id %u name %s", id, name);
d701 1
d707 1
d713 6
d724 2
d745 1
a745 1
	TRACE("fsetstat id %u handle %d", id, handle);
d750 2
d753 1
d759 1
d765 6
d776 2
d796 2
a797 1
	TRACE("opendir id %u path %s", id, path);
d827 2
a828 1
	TRACE("readdir id %u handle %d", id, handle);
d835 1
a835 1
		char pathname[1024];
d882 2
a883 1
	TRACE("remove id %u name %s", id, name);
d903 2
a904 1
	TRACE("mkdir id %u name %s mode 0%o", id, name, mode);
d920 2
a921 1
	TRACE("rmdir id %u name %s", id, name);
d941 2
a942 1
	TRACE("realpath id %u path %s", id, path);
d965 2
a966 1
	TRACE("rename id %u old %s new %s", id, oldpath, newpath);
d1017 2
a1018 1
	TRACE("readlink id %u path %s", id, path);
d1042 2
a1043 1
	TRACE("symlink id %u old %s new %s", id, oldpath, newpath);
d1081 3
a1083 2
		error("bad message ");
		exit(11);
d1157 1
a1157 1
		fatal("iqueue grows");
d1165 22
d1188 1
a1188 1
main(void)
d1191 1
a1191 1
	int in, out, max;
d1193 5
d1202 47
a1248 1
	/* XXX should use getopt */
a1251 4
#ifdef DEBUG_SFTP_SERVER
	log_init("sftp-server", SYSLOG_LEVEL_DEBUG1, SYSLOG_FACILITY_AUTH, 0);
#endif

d1280 2
a1281 1
			exit(2);
d1290 1
a1290 1
				exit(0);
d1292 2
a1293 2
				error("read error");
				exit(1);
d1302 2
a1303 2
				error("write error");
				exit(1);
@


1.3
log
@fix a lot of and kludge a few more __CRAZY problems, sync rcs id
@
text
@d1 1
d19 1
a19 1
RCSID("$MirOS: src/usr.bin/ssh/sftp-server.c,v 1.2 2006/02/22 01:23:51 tg Exp $");
a26 1
#include "getput.h"
d173 1
a173 1
	PUT_32BIT(*stringp, handle);
d185 1
a185 1
	val = GET_32BIT(handle);
d700 1
a700 1
		stats = xmalloc(nstats * sizeof(Stat));
d704 1
a704 1
				stats = xrealloc(stats, nstats * sizeof(Stat));
d933 1
a933 1
	msg_len = GET_32BIT(cp);
@


1.2
log
@merge; bump version; fix up manpages and includes a little
@
text
@d18 1
a18 1
RCSID("$MirOS: sftp-server.c,v 1.52 2006/02/20 17:19:54 stevesk Exp $");
d1019 1
a1019 1
main(int ac, char **av)
@


1.1
log
@Initial revision
@
text
@d16 1
d18 5
a22 1
RCSID("$OpenBSD: sftp-server.c,v 1.47 2004/06/25 05:38:48 dtucker Exp $");
d29 1
d137 1
a137 1
	int i;
d146 1
a146 1
	int i;
d163 1
a163 1
	return i >= 0 && i < sizeof(handles)/sizeof(Handle) &&
d484 1
a484 1
			if (ret == -1) {
d487 1
a487 1
			} else if (ret == len) {
d934 1
a934 1
	if (msg_len > 256 * 1024) {
d1025 3
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@most current OpenSSH.com
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sftp-server.c,v 1.48 2005/06/17 02:44:33 djm Exp $");
d131 1
a131 1
	u_int i;
d140 1
a140 1
	u_int i;
d157 1
a157 1
	return i >= 0 && (u_int)i < sizeof(handles)/sizeof(Handle) &&
d478 1
a478 1
			if (ret < 0) {
d481 1
a481 1
			} else if ((size_t)ret == len) {
@


1.1.1.3
log
@Import current OpenSSH
@
text
@d17 1
a17 1
RCSID("$OpenBSD: sftp-server.c,v 1.49 2005/09/13 23:40:07 djm Exp $");
a23 1
#include "misc.h"
a1018 3
	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

@


1.1.1.4
log
@import OpenSSH-current
@
text
@d17 1
a17 6
RCSID("$OpenBSD: sftp-server.c,v 1.52 2006/02/20 17:19:54 stevesk Exp $");

#include <sys/types.h>
#include <sys/stat.h>

#include <dirent.h>
d929 1
a929 1
	if (msg_len > SFTP_MAX_MSG_LENGTH) {
@


1.1.1.5
log
@I decided we'd better upgrade OpenSSH before releasing to the general public
@
text
@a0 1
/* $OpenBSD: sftp-server.c,v 1.57 2006/03/30 09:58:16 djm Exp $ */
d17 1
d26 1
d173 1
a173 1
	put_u32(*stringp, handle);
d185 1
a185 1
	val = get_u32(handle);
d700 1
a700 1
		stats = xcalloc(nstats, sizeof(Stat));
d704 1
a704 1
				stats = xrealloc(stats, nstats, sizeof(Stat));
d933 1
a933 1
	msg_len = get_u32(cp);
@


1.1.1.6
log
@import a few security-wise relevant changes right now
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.70 2006/08/03 03:34:42 deraadt Exp $ */
d17 1
a20 2
#include <sys/time.h>
#include <sys/param.h>
a22 9
#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <pwd.h>
#include <time.h>
#include <unistd.h>
#include <stdarg.h>
a23 1
#include "xmalloc.h"
d25 1
d27 1
a28 1
#include "uidswap.h"
d37 1
a37 7

/* Our verbosity */
LogLevel log_level = SYSLOG_LEVEL_ERROR;

/* Our client */
struct passwd *pw = NULL;
char *client_addr = NULL;
a108 27
static const char *
string_from_portable(int pflags)
{
	static char ret[128];

	*ret = '\0';

#define PAPPEND(str)	{				\
		if (*ret != '\0')			\
			strlcat(ret, ",", sizeof(ret));	\
		strlcat(ret, str, sizeof(ret));		\
	}

	if (pflags & SSH2_FXF_READ)
		PAPPEND("READ")
	if (pflags & SSH2_FXF_WRITE)
		PAPPEND("WRITE")
	if (pflags & SSH2_FXF_CREAT)
		PAPPEND("CREATE")
	if (pflags & SSH2_FXF_TRUNC)
		PAPPEND("TRUNCATE")
	if (pflags & SSH2_FXF_EXCL)
		PAPPEND("EXCL")

	return ret;
}

a122 1
	u_int64_t bytes_read, bytes_write;
a152 1
			handles[i].bytes_read = handles[i].bytes_write = 0;
a215 30
static void
handle_update_read(int handle, ssize_t bytes)
{
	if (handle_is_ok(handle, HANDLE_FILE) && bytes > 0)
		handles[handle].bytes_read += bytes;
}

static void
handle_update_write(int handle, ssize_t bytes)
{
	if (handle_is_ok(handle, HANDLE_FILE) && bytes > 0)
		handles[handle].bytes_write += bytes;
}

static u_int64_t
handle_bytes_read(int handle)
{
	if (handle_is_ok(handle, HANDLE_FILE))
		return (handles[handle].bytes_read);
	return 0;
}

static u_int64_t
handle_bytes_write(int handle)
{
	if (handle_is_ok(handle, HANDLE_FILE))
		return (handles[handle].bytes_write);
	return 0;
}

a234 25
static void
handle_log_close(int handle, char *emsg)
{
	if (handle_is_ok(handle, HANDLE_FILE)) {
		logit("%s%sclose \"%s\" bytes read %llu written %llu",
		    emsg == NULL ? "" : emsg, emsg == NULL ? "" : " ",
		    handle_to_name(handle),
		    handle_bytes_read(handle), handle_bytes_write(handle));
	} else {
		logit("%s%sclosedir \"%s\"",
		    emsg == NULL ? "" : emsg, emsg == NULL ? "" : " ",
		    handle_to_name(handle));
	}
}

static void
handle_log_exit(void)
{
	u_int i;

	for (i = 0; i < sizeof(handles)/sizeof(Handle); i++)
		if (handles[i].use != HANDLE_UNUSED)
			handle_log_close(i, "forced");
}

d261 2
a262 2
static const char *
status_to_message(u_int32_t status)
d264 1
a276 2
	return (status_messages[MIN(status,SSH2_FX_MAX)]);
}
d278 1
a278 9
static void
send_status(u_int32_t id, u_int32_t status)
{
	Buffer msg;

	debug3("request %u: sent status %u", id, status);
	if (log_level > SYSLOG_LEVEL_VERBOSE ||
	    (status != SSH2_FX_OK && status != SSH2_FX_EOF))
		logit("sent status %s", status_to_message(status));
d284 2
a285 1
		buffer_put_cstring(&msg, status_to_message(status));
d307 1
a307 1
	debug("request %u: sent data len %d", id, dlen);
d318 1
a318 1
	debug("request %u: sent handle handle %d", id, handle);
d333 1
a333 1
	debug("request %u: sent names count %d", id, count);
d348 1
a348 1
	debug("request %u: sent attrib have 0x%x", id, a->flags);
d365 1
a365 1
	verbose("received client version %d", version);
a383 1
	debug3("request %u: open flags %d", id, pflags);
d387 1
a387 2
	logit("open \"%s\" flags %s mode 0%o",
	    name, string_from_portable(pflags), mode);
d413 1
a413 2
	debug3("request %u: close handle %u", id, handle);
	handle_log_close(handle, NULL);
d432 2
a433 2
	debug("request %u: read \"%s\" (handle %d) off %llu len %d",
	    id, handle_to_name(handle), handle, (unsigned long long)off, len);
d436 1
a436 1
		debug2("read change len %d", len);
a451 1
				handle_update_read(handle, ret);
d473 2
a474 2
	debug("request %u: write \"%s\" (handle %d) off %llu len %d",
	    id, handle_to_name(handle), handle, (unsigned long long)off, len);
a487 1
				handle_update_write(handle, ret);
d489 1
a489 1
				debug2("nothing at all written");
d508 1
a508 2
	debug3("request %u: %sstat", id, do_lstat ? "l" : "");
	verbose("%sstat name \"%s\"", do_lstat ? "l" : "", name);
d544 1
a544 2
	debug("request %u: fstat \"%s\" (handle %u)",
	    id, handle_to_name(handle), handle);
d583 1
a583 1
	debug("request %u: setstat name \"%s\"", id, name);
a584 1
		logit("set \"%s\" size %llu", name, a->size);
a589 1
		logit("set \"%s\" mode %04o", name, a->perm);
a594 6
		char buf[64];
		time_t t = a->mtime;

		strftime(buf, sizeof(buf), "%Y%m%d-%H:%M:%S",
		    localtime(&t));
		logit("set \"%s\" modtime %s", name, buf);
a599 2
		logit("set \"%s\" owner %lu group %lu", name,
		    (u_long)a->uid, (u_long)a->gid);
d619 1
a619 1
	debug("request %u: fsetstat handle %d", id, handle);
a623 2
		char *name = handle_to_name(handle);

a624 1
			logit("set \"%s\" size %llu", name, a->size);
a629 1
			logit("set \"%s\" mode %04o", name, a->perm);
a634 6
			char buf[64];
			time_t t = a->mtime;

			strftime(buf, sizeof(buf), "%Y%m%d-%H:%M:%S",
			    localtime(&t));
			logit("set \"%s\" modtime %s", name, buf);
a639 2
			logit("set \"%s\" owner %lu group %lu", name,
			    (u_long)a->uid, (u_long)a->gid);
d658 1
a658 2
	debug3("request %u: opendir", id);
	logit("opendir \"%s\"", path);
d688 1
a688 2
	debug("request %u: readdir \"%s\" (handle %d)", id,
	    handle_to_name(handle), handle);
d695 1
a695 1
		char pathname[MAXPATHLEN];
d742 1
a742 2
	debug3("request %u: remove", id);
	logit("remove name \"%s\"", name);
d762 1
a762 2
	debug3("request %u: mkdir", id);
	logit("mkdir name \"%s\" mode 0%o", name, mode);
d778 1
a778 2
	debug3("request %u: rmdir", id);
	logit("rmdir name \"%s\"", name);
d798 1
a798 2
	debug3("request %u: realpath", id);
	verbose("realpath \"%s\"", path);
d821 1
a821 2
	debug3("request %u: rename", id);
	logit("rename old \"%s\" new \"%s\"", oldpath, newpath);
d872 1
a872 2
	debug3("request %u: readlink", id);
	verbose("readlink \"%s\"", path);
d896 1
a896 2
	debug3("request %u: symlink", id);
	logit("symlink old \"%s\" new \"%s\"", oldpath, newpath);
d934 2
a935 3
		error("bad message from %s local user %s",
		    client_addr, pw->pw_name);
		cleanup_exit(11);
d1009 1
a1009 1
		fatal("iqueue grew unexpectedly");
a1016 22
/* Cleanup handler that logs active handles upon normal exit */
void
cleanup_exit(int i)
{
	if (pw != NULL && client_addr != NULL) {
		handle_log_exit();
		logit("session closed for local user %s from [%s]",
		    pw->pw_name, client_addr);
	}
	_exit(i);
}

static void
usage(void)
{
	extern char *__progname;

	fprintf(stderr,
	    "usage: %s [-he] [-l log_level] [-f log_facility]\n", __progname);
	exit(1);
}

d1018 1
a1018 1
main(int argc, char **argv)
d1021 1
a1021 1
	int in, out, max, ch, skipargs = 0, log_stderr = 0;
a1022 5
	SyslogFacility log_facility = SYSLOG_FACILITY_AUTH;
	char *cp;

	extern char *optarg;
	extern char *__progname;
d1027 1
a1027 1
	log_init(__progname, log_level, log_facility, log_stderr);
d1029 1
a1029 27
	while (!skipargs && (ch = getopt(argc, argv, "C:f:l:che")) != -1) {
		switch (ch) {
		case 'c':
			/*
			 * Ignore all arguments if we are invoked as a
			 * shell using "sftp-server -c command"
			 */
			skipargs = 1;
			break;
		case 'e':
			log_stderr = 1;
			break;
		case 'l':
			log_level = log_level_number(optarg);
			if (log_level == SYSLOG_LEVEL_NOT_SET)
				error("Invalid log level \"%s\"", optarg);
			break;
		case 'f':
			log_facility = log_facility_number(optarg);
			if (log_level == SYSLOG_FACILITY_NOT_SET)
				error("Invalid log facility \"%s\"", optarg);
			break;
		case 'h':
		default:
			usage();
		}
	}
d1031 3
a1033 19
	log_init(__progname, log_level, log_facility, log_stderr);

	if ((cp = getenv("SSH_CONNECTION")) != NULL) {
		client_addr = xstrdup(cp);
		if ((cp = strchr(client_addr, ' ')) == NULL)
			fatal("Malformed SSH_CONNECTION variable: \"%s\"",
			    getenv("SSH_CONNECTION"));
		*cp = '\0';
	} else
		client_addr = xstrdup("UNKNOWN");

	if ((pw = getpwuid(getuid())) == NULL)
		fatal("No user found for uid %lu", (u_long)getuid());
	pw = pwcopy(pw);

	logit("session opened for local user %s from [%s]",
	    pw->pw_name, client_addr);

	handle_init();
d1063 1
a1063 2
			error("select: %s", strerror(errno));
			cleanup_exit(2);
d1072 1
a1072 1
				cleanup_exit(0);
d1074 2
a1075 2
				error("read: %s", strerror(errno));
				cleanup_exit(1);
d1084 2
a1085 2
				error("write: %s", strerror(errno));
				cleanup_exit(1);
@


1.1.1.7
log
@update OpenSSH, while we're at it…
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.71 2007/01/03 07:22:36 stevesk Exp $ */
d661 1
a661 1
	if (fd >= 0) {
@


1.1.1.8
log
@import openbsd compress, ssh, perl, sendmail for minor bugfixes
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.72 2007/04/18 01:12:43 stevesk Exp $ */
d317 1
a317 2
		    (unsigned long long)handle_bytes_read(handle),
		    (unsigned long long)handle_bytes_write(handle));
d700 1
a700 2
		logit("set \"%s\" size %llu",
		    name, (unsigned long long)a->size);
d752 1
a752 2
			logit("set \"%s\" size %llu",
			    name, (unsigned long long)a->size);
@


1.1.1.9
log
@new OpenSSH
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.73 2007/05/17 07:55:29 djm Exp $ */
d1196 1
a1196 1
	char *cp, buf[4*4096];
d1274 1
a1274 9
		/*
		 * Ensure that we can read a full buffer and handle
		 * the worst-case length packet it can generate,
		 * otherwise apply backpressure by stopping reads.
		 */
		if (buffer_check_alloc(&iqueue, sizeof(buf)) &&
		    buffer_check_alloc(&oqueue, SFTP_MAX_MSG_LENGTH))
			FD_SET(in, rset);

d1288 1
d1310 2
a1311 8

		/*
		 * Process requests from client if we can fit the results
		 * into the output buffer, otherwise stop processing input
		 * and let the output queue drain.
		 */
		if (buffer_check_alloc(&oqueue, SFTP_MAX_MSG_LENGTH))
			process();
@


1.1.1.10
log
@Import latest OpenSSH upgrades
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.74 2007/09/13 04:39:04 djm Exp $ */
d1225 1
a1225 1
			if (log_facility == SYSLOG_FACILITY_NOT_SET)
@


1.1.1.11
log
@newer openssh
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.78 2008/02/27 20:21:15 djm Exp $ */
a166 1
	int next_unused;
d175 9
a183 9
Handle *handles = NULL;
u_int num_handles = 0;
int first_unused_handle = -1;

static void handle_unused(int i)
{
	handles[i].use = HANDLE_UNUSED;
	handles[i].next_unused = first_unused_handle;
	first_unused_handle = i;
d189 1
a189 1
	int i;
d191 11
a201 18
	if (first_unused_handle == -1) {
		if (num_handles + 1 <= num_handles)
			return -1;
		num_handles++;
		handles = xrealloc(handles, num_handles, sizeof(Handle));
		handle_unused(num_handles - 1);
	}

	i = first_unused_handle;
	first_unused_handle = handles[i].next_unused;

	handles[i].use = use;
	handles[i].dirp = dirp;
	handles[i].fd = fd;
	handles[i].name = xstrdup(name);
	handles[i].bytes_read = handles[i].bytes_write = 0;

	return i;
d207 2
a208 1
	return i >= 0 && (u_int)i < num_handles && handles[i].use == type;
d298 1
a299 1
		handle_unused(handle);
d302 1
a303 1
		handle_unused(handle);
d331 1
a331 1
	for (i = 0; i < num_handles; i++)
a477 3
	/* POSIX rename extension */
	buffer_put_cstring(&msg, "posix-rename@@openssh.com");
	buffer_put_cstring(&msg, "1"); /* version */
a1054 17
process_extended_posix_rename(u_int32_t id)
{
	char *oldpath, *newpath;

	oldpath = get_string(NULL);
	newpath = get_string(NULL);
	debug3("request %u: posix-rename", id);
	logit("posix-rename old \"%s\" new \"%s\"", oldpath, newpath);
	if (rename(oldpath, newpath) == -1)
		send_status(id, errno_to_portable(errno));
	else
		send_status(id, SSH2_FX_OK);
	xfree(oldpath);
	xfree(newpath);
}

static void
d1062 1
a1062 4
	if (strcmp(request, "posix-rename@@openssh.com") == 0)
		process_extended_posix_rename(id);
	else
		send_status(id, SSH2_FX_OP_UNSUPPORTED);	/* MUST */
d1085 1
a1085 1
		sftp_server_cleanup_exit(11);
d1158 2
a1159 4
	if (buf_len < buffer_len(&iqueue)) {
		error("iqueue grew unexpectedly");
		sftp_server_cleanup_exit(255);
	}
d1161 2
a1162 4
	if (msg_len < consumed) {
		error("msg_len %d < consumed %d", msg_len, consumed);
		sftp_server_cleanup_exit(255);
	}
d1169 1
a1169 1
sftp_server_cleanup_exit(int i)
d1180 1
a1180 1
sftp_server_usage(void)
d1190 1
a1190 1
sftp_server_main(int argc, char **argv, struct passwd *user_pw)
d1201 3
d1230 1
a1230 1
			sftp_server_usage();
d1238 2
a1239 2
		if ((cp = strchr(client_addr, ' ')) == NULL) {
			error("Malformed SSH_CONNECTION variable: \"%s\"",
a1240 2
			sftp_server_cleanup_exit(255);
		}
d1245 3
a1247 1
	pw = pwcopy(user_pw);
d1252 2
d1291 1
a1291 1
			sftp_server_cleanup_exit(2);
d1299 1
a1299 1
				sftp_server_cleanup_exit(0);
d1302 1
a1302 1
				sftp_server_cleanup_exit(1);
d1312 1
a1312 1
				sftp_server_cleanup_exit(1);
@


1.1.1.12
log
@OpenSSH-current
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.84 2008/06/26 06:10:09 djm Exp $ */
a21 2
#include <sys/mount.h>
#include <sys/statvfs.h>
a95 3
	case ENOSYS:
		ret = SSH2_FX_OP_UNSUPPORTED;
		break;
a472 27
static void
send_statvfs(u_int32_t id, struct statvfs *st)
{
	Buffer msg;
	u_int64_t flag;

	flag = (st->f_flag & ST_RDONLY) ? SSH2_FXE_STATVFS_ST_RDONLY : 0;
	flag |= (st->f_flag & ST_NOSUID) ? SSH2_FXE_STATVFS_ST_NOSUID : 0;

	buffer_init(&msg);
	buffer_put_char(&msg, SSH2_FXP_EXTENDED_REPLY);
	buffer_put_int(&msg, id);
	buffer_put_int64(&msg, st->f_bsize);
	buffer_put_int64(&msg, st->f_frsize);
	buffer_put_int64(&msg, st->f_blocks);
	buffer_put_int64(&msg, st->f_bfree);
	buffer_put_int64(&msg, st->f_bavail);
	buffer_put_int64(&msg, st->f_files);
	buffer_put_int64(&msg, st->f_ffree);
	buffer_put_int64(&msg, st->f_favail);
	buffer_put_int64(&msg, st->f_fsid);
	buffer_put_int64(&msg, flag);
	buffer_put_int64(&msg, st->f_namemax);
	send_msg(&msg);
	buffer_free(&msg);
}

a487 6
	/* statvfs extension */
	buffer_put_cstring(&msg, "statvfs@@openssh.com");
	buffer_put_cstring(&msg, "2"); /* version */
	/* fstatvfs extension */
	buffer_put_cstring(&msg, "fstatvfs@@openssh.com");
	buffer_put_cstring(&msg, "2"); /* version */
d719 1
a719 1
		ret = chmod(name, a->perm & 07777);
d772 1
a772 1
			ret = fchmod(fd, a->perm & 07777);
d914 1
a914 1
	    a->perm & 07777 : 0777;
a1081 36
process_extended_statvfs(u_int32_t id)
{
	char *path;
	struct statvfs st;

	path = get_string(NULL);
	debug3("request %u: statfs", id);
	logit("statfs \"%s\"", path);

	if (statvfs(path, &st) != 0)
		send_status(id, errno_to_portable(errno));
	else
		send_statvfs(id, &st);
        xfree(path);
}

static void
process_extended_fstatvfs(u_int32_t id)
{
	int handle, fd;
	struct statvfs st;

	handle = get_handle();
	debug("request %u: fstatvfs \"%s\" (handle %u)",
	    id, handle_to_name(handle), handle);
	if ((fd = handle_to_fd(handle)) < 0) {
		send_status(id, SSH2_FX_FAILURE);
		return;
	}
	if (fstatvfs(fd, &st) != 0)
		send_status(id, errno_to_portable(errno));
	else
		send_statvfs(id, &st);
}

static void
a1090 4
	else if (strcmp(request, "statvfs@@openssh.com") == 0)
		process_extended_statvfs(id);
	else if (strcmp(request, "fstatvfs@@openssh.com") == 0)
		process_extended_fstatvfs(id);
@


1.1.1.13
log
@Let’s play the version number game – OpenSSH 5.3-current
@
text
@d1 1
a1 1
/* $OpenBSD: sftp-server.c,v 1.87 2009/08/31 20:56:02 djm Exp $ */
d1297 1
a1297 2
	    "usage: %s [-he] [-l log_level] [-f log_facility] [-u umask]\n",
	    __progname);
a1308 2
	const char *errmsg;
	mode_t mask;
d1315 1
a1315 1
	while (!skipargs && (ch = getopt(argc, argv, "f:l:u:che")) != -1) {
a1336 7
		case 'u':
			mask = (mode_t)strtonum(optarg, 0, 0777, &errmsg);
			if (errmsg != NULL)
				fatal("Invalid umask \"%s\": %s",
				    optarg, errmsg);
			(void)umask(mask);
			break;
@


