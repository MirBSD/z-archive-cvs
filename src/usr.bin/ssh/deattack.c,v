head	1.3;
access;
symbols
	cvs-200910041320:1.1.1.4
	cvs-200903221200:1.1.1.4
	cvs-200812162015:1.1.1.4
	cvs-200804031830:1.1.1.4
	MIRBSD_10:1.2.0.2
	MIRBSD_10_BASE:1.2
	cvs-200803022030:1.1.1.4
	cvs-200709131337:1.1.1.4
	cvs-200709021830:1.1.1.4
	cvs-200708201200:1.1.1.4
	cvs-200706161500:1.1.1.4
	cvs-200705192215:1.1.1.4
	cvs-200704292000:1.1.1.4
	cvs-200703080900:1.1.1.4
	cvs-200701251600:1.1.1.4
	cvs-200612111600:1.1.1.4
	cvs-200611090230:1.1.1.4
	OPENBSD_4_0:1.1.1.4
	MIRBSD_9_BASE:1.1.1.3
	cvs-200606162342:1.1.1.3
	cvs-200606022000:1.1.1.3
	cvs-200604191000:1.1.1.3
	cvs-200602220045:1.1.1.2
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200512201942:1.1.1.1
	cvs-200511231930:1.1.1.1
	cvs-200507211800:1.1.1.1
	cvs-200506221550:1.1.1.1
	cvs-200505050030:1.1.1.1
	cvs-200504291700:1.1.1.1
	cvs-200504261445:1.1.1.1
	cvs-200504141900:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2008.12.16.22.13.27;	author tg;	state Exp;
branches;
next	1.2;
commitid	10049482819766381ED;

1.2
date	2006.09.20.21.40.58;	author tg;	state Exp;
branches;
next	1.1;
commitid	1004511B578580E7F04;

1.1
date	2005.02.05.17.29.52;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.29.52;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.02.22.00.51.35;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	10043FBB5A933C3BB9B;

1.1.1.3
date	2006.04.19.10.15.03;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	10044460DB21E1F715C;

1.1.1.4
date	2006.09.20.19.06.48;	author tg;	state Exp;
branches;
next	;
commitid	10045119150397FC669;


desc
@@


1.3
log
@really merge OpenSSH-current into MirBSD Secure SHell 10uA4
@
text
@/* $OpenBSD: deattack.c,v 1.30 2006/09/16 19:53:37 djm Exp $ */
/*
 * Cryptographic attack detector for ssh - source code
 *
 * Copyright (c) 1998 CORE SDI S.A., Buenos Aires, Argentina.
 *
 * All rights reserved. Redistribution and use in source and binary
 * forms, with or without modification, are permitted provided that
 * this copyright notice is retained.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES ARE DISCLAIMED. IN NO EVENT SHALL CORE SDI S.A. BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY OR
 * CONSEQUENTIAL DAMAGES RESULTING FROM THE USE OR MISUSE OF THIS
 * SOFTWARE.
 *
 * Ariel Futoransky <futo@@core-sdi.com>
 * <http://www.core-sdi.com>
 */

#include <sys/types.h>
#include <sys/time.h>

#include <string.h>
#include <stdio.h>
#include <stdarg.h>

#include "xmalloc.h"
#include "deattack.h"
#include "log.h"
#include "crc32.h"
#include "misc.h"

__RCSID("$MirOS$");

/*
 * CRC attack detection has a worst-case behaviour that is O(N^3) over
 * the number of identical blocks in a packet. This behaviour can be 
 * exploited to create a limited denial of service attack. 
 * 
 * However, because we are dealing with encrypted data, identical
 * blocks should only occur every 2^35 maximally-sized packets or so. 
 * Consequently, we can detect this DoS by looking for identical blocks
 * in a packet.
 *
 * The parameter below determines how many identical blocks we will
 * accept in a single packet, trading off between attack detection and
 * likelihood of terminating a legitimate connection. A value of 32 
 * corresponds to an average of 2^40 messages before an attack is
 * misdetected
 */
#define MAX_IDENTICAL	32

/* SSH Constants */
#define SSH_MAXBLOCKS	(32 * 1024)
#define SSH_BLOCKSIZE	(8)

/* Hashing constants */
#define HASH_MINSIZE	(8 * 1024)
#define HASH_ENTRYSIZE	(2)
#define HASH_FACTOR(x)	((x)*3/2)
#define HASH_UNUSEDCHAR	(0xff)
#define HASH_UNUSED	(0xffff)
#define HASH_IV		(0xfffe)

#define HASH_MINBLOCKS	(7*SSH_BLOCKSIZE)


/* Hash function (Input keys are cipher results) */
#define HASH(x)		get_u32(x)

#define CMP(a, b)	(memcmp(a, b, SSH_BLOCKSIZE))

static void
crc_update(u_int32_t *a, u_int32_t b)
{
	b ^= *a;
	*a = ssh_crc32((u_char *)&b, sizeof(b));
}

/* detect if a block is used in a particular pattern */
static int
check_crc(u_char *S, u_char *buf, u_int32_t len)
{
	u_int32_t crc;
	u_char *c;

	crc = 0;
	for (c = buf; c < buf + len; c += SSH_BLOCKSIZE) {
		if (!CMP(S, c)) {
			crc_update(&crc, 1);
			crc_update(&crc, 0);
		} else {
			crc_update(&crc, 0);
			crc_update(&crc, 0);
		}
	}
	return (crc == 0);
}


/* Detect a crc32 compensation attack on a packet */
int
detect_attack(u_char *buf, u_int32_t len)
{
	static u_int16_t *h = (u_int16_t *) NULL;
	static u_int32_t n = HASH_MINSIZE / HASH_ENTRYSIZE;
	u_int32_t i, j;
	u_int32_t l, same;
	u_char *c;
	u_char *d;

	if (len > (SSH_MAXBLOCKS * SSH_BLOCKSIZE) ||
	    len % SSH_BLOCKSIZE != 0) {
		fatal("detect_attack: bad length %d", len);
	}
	for (l = n; l < HASH_FACTOR(len / SSH_BLOCKSIZE); l = l << 2)
		;

	if (h == NULL) {
		debug("Installing crc compensation attack detector.");
		h = (u_int16_t *) xcalloc(l, HASH_ENTRYSIZE);
		n = l;
	} else {
		if (l > n) {
			h = (u_int16_t *)xrealloc(h, l, HASH_ENTRYSIZE);
			n = l;
		}
	}

	if (len <= HASH_MINBLOCKS) {
		for (c = buf; c < buf + len; c += SSH_BLOCKSIZE) {
			for (d = buf; d < c; d += SSH_BLOCKSIZE) {
				if (!CMP(c, d)) {
					if ((check_crc(c, buf, len)))
						return (DEATTACK_DETECTED);
					else
						break;
				}
			}
		}
		return (DEATTACK_OK);
	}
	memset(h, HASH_UNUSEDCHAR, n * HASH_ENTRYSIZE);

	for (c = buf, same = j = 0; c < (buf + len); c += SSH_BLOCKSIZE, j++) {
		for (i = HASH(c) & (n - 1); h[i] != HASH_UNUSED;
		    i = (i + 1) & (n - 1)) {
			if (!CMP(c, buf + h[i] * SSH_BLOCKSIZE)) {
				if (++same > MAX_IDENTICAL)
					return (DEATTACK_DOS_DETECTED);
				if (check_crc(c, buf, len))
					return (DEATTACK_DETECTED);
				else
					break;
			}
		}
		h[i] = j;
	}
	return (DEATTACK_OK);
}
@


1.2
log
@finish merging
@
text
@d22 1
d38 3
a40 3
 * the number of identical blocks in a packet. This behaviour can be
 * exploited to create a limited denial of service attack.
 *
d42 1
a42 1
 * blocks should only occur every 2^35 maximally-sized packets or so.
d48 1
a48 1
 * likelihood of terminating a legitimate connection. A value of 32
@


1.1
log
@Initial revision
@
text
@d1 1
d21 1
a21 2
#include "includes.h"
RCSID("$OpenBSD: deattack.c,v 1.19 2003/09/18 08:49:45 markus Exp $");
d23 5
d31 21
a51 3
#include "getput.h"
#include "xmalloc.h"
#include "deattack.h"
d69 1
a69 1
#define HASH(x)		GET_32BIT(x)
d77 1
a77 1
	*a = ssh_crc32((u_char *) &b, sizeof(b));
d82 1
a82 2
check_crc(u_char *S, u_char *buf, u_int32_t len,
	  u_char *IV)
a87 4
	if (IV && !CMP(S, IV)) {
		crc_update(&crc, 1);
		crc_update(&crc, 0);
	}
d103 1
a103 1
detect_attack(u_char *buf, u_int32_t len, u_char *IV)
d108 1
a108 1
	u_int32_t l;
d121 1
a121 1
		h = (u_int16_t *) xmalloc(l * HASH_ENTRYSIZE);
d125 1
a125 1
			h = (u_int16_t *) xrealloc(h, l * HASH_ENTRYSIZE);
a131 6
			if (IV && (!CMP(c, IV))) {
				if ((check_crc(c, buf, len, IV)))
					return (DEATTACK_DETECTED);
				else
					break;
			}
d134 1
a134 1
					if ((check_crc(c, buf, len, IV)))
d145 1
a145 4
	if (IV)
		h[HASH(IV) & (n - 1)] = HASH_IV;

	for (c = buf, j = 0; c < (buf + len); c += SSH_BLOCKSIZE, j++) {
d148 4
a151 9
			if (h[i] == HASH_IV) {
				if (!CMP(c, IV)) {
					if (check_crc(c, buf, len, IV))
						return (DEATTACK_DETECTED);
					else
						break;
				}
			} else if (!CMP(c, buf + h[i] * SSH_BLOCKSIZE)) {
				if (check_crc(c, buf, len, IV))
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@import OpenSSH-current
@
text
@d21 1
a21 1
RCSID("$OpenBSD: deattack.c,v 1.20 2006/02/07 03:59:20 stevesk Exp $");
d28 1
@


1.1.1.3
log
@I decided we'd better upgrade OpenSSH before releasing to the general public
@
text
@a0 1
/* $OpenBSD: deattack.c,v 1.27 2006/03/30 09:58:15 djm Exp $ */
d21 1
d26 1
a27 1
#include "misc.h"
d45 1
a45 1
#define HASH(x)		get_u32(x)
d53 1
a53 1
	*a = ssh_crc32((u_char *)&b, sizeof(b));
d58 2
a59 1
check_crc(u_char *S, u_char *buf, u_int32_t len)
d65 4
d84 1
a84 1
detect_attack(u_char *buf, u_int32_t len)
d102 1
a102 1
		h = (u_int16_t *) xcalloc(l, HASH_ENTRYSIZE);
d106 1
a106 1
			h = (u_int16_t *)xrealloc(h, l, HASH_ENTRYSIZE);
d113 6
d121 1
a121 1
					if ((check_crc(c, buf, len)))
d132 3
d138 9
a146 2
			if (!CMP(c, buf + h[i] * SSH_BLOCKSIZE)) {
				if (check_crc(c, buf, len))
@


1.1.1.4
log
@import a few security-wise relevant changes right now
@
text
@d1 1
a1 1
/* $OpenBSD: deattack.c,v 1.30 2006/09/16 19:53:37 djm Exp $ */
d21 1
a21 1
#include <sys/types.h>
a22 5
#include <string.h>
#include <stdio.h>
#include <stdarg.h>

#include "xmalloc.h"
d26 1
a28 18
/*
 * CRC attack detection has a worst-case behaviour that is O(N^3) over
 * the number of identical blocks in a packet. This behaviour can be 
 * exploited to create a limited denial of service attack. 
 * 
 * However, because we are dealing with encrypted data, identical
 * blocks should only occur every 2^35 maximally-sized packets or so. 
 * Consequently, we can detect this DoS by looking for identical blocks
 * in a packet.
 *
 * The parameter below determines how many identical blocks we will
 * accept in a single packet, trading off between attack detection and
 * likelihood of terminating a legitimate connection. A value of 32 
 * corresponds to an average of 2^40 messages before an attack is
 * misdetected
 */
#define MAX_IDENTICAL	32

d84 1
a84 1
	u_int32_t l, same;
d121 1
a121 1
	for (c = buf, same = j = 0; c < (buf + len); c += SSH_BLOCKSIZE, j++) {
a124 2
				if (++same > MAX_IDENTICAL)
					return (DEATTACK_DOS_DETECTED);
@


