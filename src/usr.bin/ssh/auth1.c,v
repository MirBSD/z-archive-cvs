head	1.10;
access;
symbols
	cvs-200910041320:1.1.1.7
	cvs-200903221200:1.1.1.7
	cvs-200812162015:1.1.1.7
	cvs-200804031830:1.1.1.6
	MIRBSD_10:1.8.0.2
	MIRBSD_10_BASE:1.8
	cvs-200803022030:1.1.1.6
	cvs-200709131337:1.1.1.5
	cvs-200709021830:1.1.1.5
	cvs-200708201200:1.1.1.5
	cvs-200706161500:1.1.1.5
	cvs-200705192215:1.1.1.5
	cvs-200704292000:1.1.1.5
	cvs-200703080900:1.1.1.5
	cvs-200701251600:1.1.1.5
	cvs-200612111600:1.1.1.5
	cvs-200611090230:1.1.1.5
	OPENBSD_4_0:1.1.1.5
	MIRBSD_9_BASE:1.6
	cvs-200606162342:1.1.1.4
	cvs-200606022000:1.1.1.4
	cvs-200604191000:1.1.1.4
	cvs-200602220045:1.1.1.3
	MIRBSD_8:1.4.0.2
	MIRBSD_8_BASE:1.4
	cvs-200512201942:1.1.1.3
	cvs-200511231930:1.1.1.3
	cvs-200507211800:1.1.1.3
	cvs-200506221550:1.1.1.2
	cvs-200505050030:1.1.1.1
	cvs-200504291700:1.1.1.1
	cvs-200504261445:1.1.1.1
	cvs-200504141900:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2009.10.04.14.29.01;	author tg;	state Exp;
branches;
next	1.9;
commitid	1004AC8B1276FC00211;

1.9
date	2008.12.16.20.55.19;	author tg;	state Exp;
branches;
next	1.8;
commitid	100494815C97ECEEDBF;

1.8
date	2008.03.02.21.14.18;	author tg;	state Exp;
branches;
next	1.7;
commitid	10047CB18BB506A8527;

1.7
date	2006.09.20.21.40.56;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004511B578580E7F04;

1.6
date	2006.04.19.10.40.44;	author tg;	state Exp;
branches;
next	1.5;
commitid	100444613BD3A91C28B;

1.5
date	2006.02.22.02.16.44;	author tg;	state Exp;
branches;
next	1.4;
commitid	10043FBC991512A442B;

1.4
date	2005.11.23.18.04.19;	author tg;	state Exp;
branches;
next	1.3;
commitid	af74384af2ab463;

1.3
date	2005.06.22.16.11.39;	author tg;	state Exp;
branches;
next	1.2;
commitid	598b42b98dcf335f;

1.2
date	2005.03.13.18.33.29;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.29.52;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.29.52;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.06.22.15.56.24;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	181342b98a38fe99;

1.1.1.3
date	2005.07.21.21.00.23;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	560042e0092f571e;

1.1.1.4
date	2006.04.19.10.15.02;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	10044460DB21E1F715C;

1.1.1.5
date	2006.09.20.19.06.47;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	10045119150397FC669;

1.1.1.6
date	2008.03.02.20.40.41;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	10047CB10DD30FAF062;

1.1.1.7
date	2008.12.16.20.15.31;	author tg;	state Exp;
branches;
next	;
commitid	10049480C7A2701F5C0;


desc
@@


1.10
log
@• merge newer OpenSSH
• KNF in our diff – style(9)
• some const cleanliness (build with __CRAZY=Yes mostly)
@
text
@/* $OpenBSD: auth1.c,v 1.73 2008/07/04 23:30:16 djm Exp $ */
/*
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */

#include <sys/types.h>
#include <sys/queue.h>

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <pwd.h>

#include "xmalloc.h"
#include "rsa.h"
#include "ssh1.h"
#include "packet.h"
#include "buffer.h"
#include "log.h"
#include "servconf.h"
#include "compat.h"
#include "key.h"
#include "hostfile.h"
#include "auth.h"
#include "channels.h"
#include "session.h"
#include "uidswap.h"
#include "monitor_wrap.h"

__RCSID("$MirOS: src/usr.bin/ssh/auth1.c,v 1.9 2008/12/16 20:55:19 tg Exp $");

/* import */
extern ServerOptions options;

static int auth1_process_password(Authctxt *, char *, size_t);
static int auth1_process_rsa(Authctxt *, char *, size_t);
static int auth1_process_rhosts_rsa(Authctxt *, char *, size_t);
static int auth1_process_tis_challenge(Authctxt *, char *, size_t);
static int auth1_process_tis_response(Authctxt *, char *, size_t);

struct AuthMethod1 {
	int type;
	const char *name;
	int *enabled;
	int (*method)(Authctxt *, char *, size_t);
};

const struct AuthMethod1 auth1_methods[] = {
	{
		SSH_CMSG_AUTH_PASSWORD, "password",
		&options.password_authentication, auth1_process_password
	},
	{
		SSH_CMSG_AUTH_RSA, "rsa",
		&options.rsa_authentication, auth1_process_rsa
	},
	{
		SSH_CMSG_AUTH_RHOSTS_RSA, "rhosts-rsa",
		&options.rhosts_rsa_authentication, auth1_process_rhosts_rsa
	},
	{
		SSH_CMSG_AUTH_TIS, "challenge-response",
		&options.challenge_response_authentication,
		auth1_process_tis_challenge
	},
	{
		SSH_CMSG_AUTH_TIS_RESPONSE, "challenge-response",
		&options.challenge_response_authentication,
		auth1_process_tis_response
	},
	{ -1, NULL, NULL, NULL}
};

static const struct AuthMethod1
*lookup_authmethod1(int type)
{
	int i;

	for (i = 0; auth1_methods[i].name != NULL; i++)
		if (auth1_methods[i].type == type)
			return (&(auth1_methods[i]));

	return (NULL);
}

static const char *
get_authname(int type)
{
	const struct AuthMethod1 *a;
	static char buf[64];

	if ((a = lookup_authmethod1(type)) != NULL)
		return (a->name);
	snprintf(buf, sizeof(buf), "bad-auth-msg-%d", type);
	return (buf);
}

/*ARGSUSED*/
static int
auth1_process_password(Authctxt *authctxt, char *info, size_t infolen)
{
	int authenticated = 0;
	char *password;
	u_int dlen;

	/*
	 * Read user password.  It is in plain text, but was
	 * transmitted over the encrypted channel so it is
	 * not visible to an outside observer.
	 */
	password = packet_get_string(&dlen);
	packet_check_eom();

	/* Try authentication with the password. */
	authenticated = PRIVSEP(auth_password(authctxt, password));

	memset(password, 0, dlen);
	xfree(password);

	return (authenticated);
}

/*ARGSUSED*/
static int
auth1_process_rsa(Authctxt *authctxt, char *info, size_t infolen)
{
	int authenticated = 0;
	BIGNUM *n;

	/* RSA authentication requested. */
	if ((n = BN_new()) == NULL)
		fatal("do_authloop: BN_new failed");
	packet_get_bignum(n);
	packet_check_eom();
	authenticated = auth_rsa(authctxt, n);
	BN_clear_free(n);

	return (authenticated);
}

/*ARGSUSED*/
static int
auth1_process_rhosts_rsa(Authctxt *authctxt, char *info, size_t infolen)
{
	int keybits, authenticated = 0;
	u_int bits;
	char *client_user;
	Key *client_host_key;
	u_int ulen;

	/*
	 * Get client user name.  Note that we just have to
	 * trust the client; root on the client machine can
	 * claim to be any user.
	 */
	client_user = packet_get_string(&ulen);

	/* Get the client host key. */
	client_host_key = key_new(KEY_RSA1);
	bits = packet_get_int();
	packet_get_bignum(client_host_key->rsa->e);
	packet_get_bignum(client_host_key->rsa->n);

	keybits = BN_num_bits(client_host_key->rsa->n);
	if (keybits < 0 || bits != (u_int)keybits) {
		verbose("Warning: keysize mismatch for client_host_key: "
		    "actual %d, announced %d",
		    BN_num_bits(client_host_key->rsa->n), bits);
	}
	packet_check_eom();

	authenticated = auth_rhosts_rsa(authctxt, client_user,
	    client_host_key);
	key_free(client_host_key);

	snprintf(info, infolen, " ruser %.100s", client_user);
	xfree(client_user);

	return (authenticated);
}

/*ARGSUSED*/
static int
auth1_process_tis_challenge(Authctxt *authctxt, char *info, size_t infolen)
{
	char *challenge;

	if ((challenge = get_challenge(authctxt)) == NULL)
		return (0);

	debug("sending challenge '%s'", challenge);
	packet_start(SSH_SMSG_AUTH_TIS_CHALLENGE);
	packet_put_cstring(challenge);
	xfree(challenge);
	packet_send();
	packet_write_wait();

	return (-1);
}

/*ARGSUSED*/
static int
auth1_process_tis_response(Authctxt *authctxt, char *info, size_t infolen)
{
	int authenticated = 0;
	char *response;
	u_int dlen;

	response = packet_get_string(&dlen);
	packet_check_eom();
	authenticated = verify_response(authctxt, response);
	memset(response, 'r', dlen);
	xfree(response);

	return (authenticated);
}

/*
 * read packets, try to authenticate the user and
 * return only if authentication is successful
 */
static void
do_authloop(Authctxt *authctxt)
{
	int authenticated = 0;
	char info[1024];
	int type = 0;
	const struct AuthMethod1 *meth;

	debug("Attempting authentication for %s%.100s.",
	    authctxt->valid ? "" : "invalid user ", authctxt->user);

	/* If the user has no password, accept authentication immediately. */
	if (options.password_authentication &&
	    PRIVSEP(auth_password(authctxt, (char *)""))) {
		auth_log(authctxt, 1, "without authentication", "");
		return;
	}

	/* Indicate that authentication is needed. */
	packet_start(SSH_SMSG_FAILURE);
	packet_send();
	packet_write_wait();

	for (;;) {
		/* default to fail */
		authenticated = 0;

		info[0] = '\0';

		/* Get a packet from the client. */
		type = packet_read();
		if (authctxt->failures >= options.max_authtries)
			goto skip;
		if ((meth = lookup_authmethod1(type)) == NULL) {
			logit("Unknown message during authentication: "
			    "type %d", type);
			goto skip;
		}

		if (!*(meth->enabled)) {
			verbose("%s authentication disabled.", meth->name);
			goto skip;
		}

		authenticated = meth->method(authctxt, info, sizeof(info));
		if (authenticated == -1)
			continue; /* "postponed" */

#ifdef BSD_AUTH
		if (authctxt->as) {
			auth_close(authctxt->as);
			authctxt->as = NULL;
		}
#endif
		if (!authctxt->valid && authenticated)
			fatal("INTERNAL ERROR: authenticated invalid user %s",
			    authctxt->user);

		/* Special handling for root */
		if (authenticated && authctxt->pw->pw_uid == 0 &&
		    !auth_root_allowed(meth->name))
			authenticated = 0;

 skip:
		/* Log before sending the reply */
		auth_log(authctxt, authenticated, get_authname(type), info);

		if (authenticated)
			return;

		if (++authctxt->failures >= options.max_authtries)
			packet_disconnect(AUTH_FAIL_MSG, authctxt->user);

		packet_start(SSH_SMSG_FAILURE);
		packet_send();
		packet_write_wait();
	}
}

/*
 * Performs authentication of an incoming connection.  Session key has already
 * been exchanged and encryption is enabled.
 */
void
do_authentication(Authctxt *authctxt)
{
	u_int ulen;
	char *user, *style = NULL;

	/* Get the name of the user that we wish to log in as. */
	packet_read_expect(SSH_CMSG_USER);

	/* Get the user name. */
	user = packet_get_string(&ulen);
	packet_check_eom();

	if ((style = strchr(user, ':')) != NULL)
		*style++ = '\0';

	authctxt->user = user;
	authctxt->style = style;

	/* Verify that the user is a valid user. */
	if ((authctxt->pw = PRIVSEP(getpwnamallow(user))) != NULL)
		authctxt->valid = 1;
	else {
		debug("do_authentication: invalid user %s", user);
		authctxt->pw = fakepw();
	}

	setproctitle("%s%s", authctxt->valid ? user : "unknown",
	    use_privsep ? " [net]" : "");

	/*
	 * If we are not running as root, the user must have the same uid as
	 * the server.
	 */
	if (!use_privsep && getuid() != 0 && authctxt->pw &&
	    authctxt->pw->pw_uid != getuid())
		packet_disconnect("Cannot change user when server not running as root.");

	/*
	 * Loop until the user has been authenticated or the connection is
	 * closed, do_authloop() returns only if authentication is successful
	 */
	do_authloop(authctxt);

	/* The user has been authenticated and accepted. */
	packet_start(SSH_SMSG_SUCCESS);
	packet_send();
	packet_write_wait();
}
@


1.9
log
@fastmerge, do not use yet!
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/usr.bin/ssh/auth1.c,v 1.8 2008/03/02 21:14:18 tg Exp $");
d289 1
a289 1
		    !auth_root_allowed((char *)meth->name))
@


1.8
log
@merge’n’fix
@
text
@d1 1
a1 1
/* $OpenBSD: auth1.c,v 1.71 2007/09/21 08:15:29 djm Exp $ */
d14 1
d37 1
a37 1
__RCSID("$MirOS: src/usr.bin/ssh/auth1.c,v 1.7 2006/09/20 21:40:56 tg Exp $");
d260 2
d299 1
a299 1
		if (authctxt->failures++ > options.max_authtries)
@


1.7
log
@finish merging
@
text
@d1 1
a1 1
/* $OpenBSD: auth1.c,v 1.70 2006/08/03 03:34:41 deraadt Exp $ */
d36 1
a36 1
__RCSID("$MirOS$");
@


1.6
log
@merge and clean up
@
text
@d1 1
a1 1
/* $OpenBSD: auth1.c,v 1.66 2006/03/25 13:17:01 djm Exp $ */
d13 6
a18 2
#include "includes.h"
__RCSID("$MirOS: src/usr.bin/ssh/auth1.c,v 1.5 2006/02/22 02:16:44 tg Exp $");
d28 2
d36 2
@


1.5
log
@fix a lot of and kludge a few more __CRAZY problems, sync rcs id
@
text
@d1 1
d14 1
a14 1
RCSID("$MirOS: src/usr.bin/ssh/auth1.c,v 1.4 2005/11/23 18:04:19 tg Exp $");
d77 1
a77 1
	for(i = 0; auth1_methods[i].name != NULL; i++)
d96 1
d121 1
d139 1
d180 1
d199 1
@


1.4
log
@fastmerge remainder of src/usr.bin
@
text
@d13 1
a13 1
RCSID("$MirOS: src/usr.bin/ssh/auth1.c,v 1.3 2005/06/22 16:11:39 tg Exp $");
d40 1
a40 1
	char *name;
d83 1
a83 1
static char *
d227 1
a227 1
	    PRIVSEP(auth_password(authctxt, ""))) {
d272 1
a272 1
		    !auth_root_allowed(meth->name))
@


1.3
log
@merge
@
text
@d13 1
a13 1
RCSID("$MirOS: src/usr.bin/ssh/auth1.c,v 1.2 2005/03/13 18:33:29 tg Exp $");
d172 1
a172 1
	
d180 1
a180 1
	
@


1.2
log
@merge src/usr.bin
@
text
@d13 1
a13 1
RCSID("$MirOS$");
d32 51
a82 3
/*
 * convert ssh auth msg type into description
 */
d86 77
a162 13
	static char buf[1024];
	switch (type) {
	case SSH_CMSG_AUTH_PASSWORD:
		return "password";
	case SSH_CMSG_AUTH_RSA:
		return "rsa";
	case SSH_CMSG_AUTH_RHOSTS_RSA:
		return "rhosts-rsa";
	case SSH_CMSG_AUTH_RHOSTS:
		return "rhosts";
	case SSH_CMSG_AUTH_TIS:
	case SSH_CMSG_AUTH_TIS_RESPONSE:
		return "challenge-response";
d164 44
a207 2
	snprintf(buf, sizeof buf, "bad-auth-msg-%d", type);
	return buf;
a217 4
	u_int bits;
	Key *client_host_key;
	BIGNUM *n;
	char *client_user, *password;
a218 2
	u_int dlen;
	u_int ulen;
d220 1
d245 5
d251 3
a253 101
		/* Process the packet. */
		switch (type) {
		case SSH_CMSG_AUTH_RHOSTS_RSA:
			if (!options.rhosts_rsa_authentication) {
				verbose("Rhosts with RSA authentication disabled.");
				break;
			}
			/*
			 * Get client user name.  Note that we just have to
			 * trust the client; root on the client machine can
			 * claim to be any user.
			 */
			client_user = packet_get_string(&ulen);

			/* Get the client host key. */
			client_host_key = key_new(KEY_RSA1);
			bits = packet_get_int();
			packet_get_bignum(client_host_key->rsa->e);
			packet_get_bignum(client_host_key->rsa->n);

			if (bits != BN_num_bits(client_host_key->rsa->n))
				verbose("Warning: keysize mismatch for client_host_key: "
				    "actual %d, announced %d",
				    BN_num_bits(client_host_key->rsa->n), bits);
			packet_check_eom();

			authenticated = auth_rhosts_rsa(authctxt, client_user,
			    client_host_key);
			key_free(client_host_key);

			snprintf(info, sizeof info, " ruser %.100s", client_user);
			xfree(client_user);
			break;

		case SSH_CMSG_AUTH_RSA:
			if (!options.rsa_authentication) {
				verbose("RSA authentication disabled.");
				break;
			}
			/* RSA authentication requested. */
			if ((n = BN_new()) == NULL)
				fatal("do_authloop: BN_new failed");
			packet_get_bignum(n);
			packet_check_eom();
			authenticated = auth_rsa(authctxt, n);
			BN_clear_free(n);
			break;

		case SSH_CMSG_AUTH_PASSWORD:
			if (!options.password_authentication) {
				verbose("Password authentication disabled.");
				break;
			}
			/*
			 * Read user password.  It is in plain text, but was
			 * transmitted over the encrypted channel so it is
			 * not visible to an outside observer.
			 */
			password = packet_get_string(&dlen);
			packet_check_eom();

			/* Try authentication with the password. */
			authenticated = PRIVSEP(auth_password(authctxt, password));

			memset(password, 0, strlen(password));
			xfree(password);
			break;

		case SSH_CMSG_AUTH_TIS:
			debug("rcvd SSH_CMSG_AUTH_TIS");
			if (options.challenge_response_authentication == 1) {
				char *challenge = get_challenge(authctxt);
				if (challenge != NULL) {
					debug("sending challenge '%s'", challenge);
					packet_start(SSH_SMSG_AUTH_TIS_CHALLENGE);
					packet_put_cstring(challenge);
					xfree(challenge);
					packet_send();
					packet_write_wait();
					continue;
				}
			}
			break;
		case SSH_CMSG_AUTH_TIS_RESPONSE:
			debug("rcvd SSH_CMSG_AUTH_TIS_RESPONSE");
			if (options.challenge_response_authentication == 1) {
				char *response = packet_get_string(&dlen);
				packet_check_eom();
				authenticated = verify_response(authctxt, response);
				memset(response, 'r', dlen);
				xfree(response);
			}
			break;

		default:
			/*
			 * Any unknown messages will be ignored (and failure
			 * returned) during authentication.
			 */
			logit("Unknown message during authentication: type %d", type);
			break;
d255 5
d272 1
a272 1
		    !auth_root_allowed(get_authname(type)))
d275 1
@


1.1
log
@Initial revision
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.59 2004/07/28 09:40:29 markus Exp $");
a77 3
#ifdef KRB5
	    (!options.kerberos_authentication || options.kerberos_or_local_passwd) &&
#endif
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@most current OpenSSH.com
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.61 2005/06/17 02:44:32 djm Exp $");
d32 3
a34 51
static int auth1_process_password(Authctxt *, char *, size_t);
static int auth1_process_rsa(Authctxt *, char *, size_t);
static int auth1_process_rhosts_rsa(Authctxt *, char *, size_t);
static int auth1_process_tis_challenge(Authctxt *, char *, size_t);
static int auth1_process_tis_response(Authctxt *, char *, size_t);

struct AuthMethod1 {
	int type;
	char *name;
	int *enabled;
	int (*method)(Authctxt *, char *, size_t);
};

const struct AuthMethod1 auth1_methods[] = {
	{
		SSH_CMSG_AUTH_PASSWORD, "password",
		&options.password_authentication, auth1_process_password
	},
	{
		SSH_CMSG_AUTH_RSA, "rsa",
		&options.rsa_authentication, auth1_process_rsa
	},
	{
		SSH_CMSG_AUTH_RHOSTS_RSA, "rhosts-rsa",
		&options.rhosts_rsa_authentication, auth1_process_rhosts_rsa
	},
	{
		SSH_CMSG_AUTH_TIS, "challenge-response",
		&options.challenge_response_authentication,
		auth1_process_tis_challenge
	},
	{
		SSH_CMSG_AUTH_TIS_RESPONSE, "challenge-response",
		&options.challenge_response_authentication,
		auth1_process_tis_response
	},
	{ -1, NULL, NULL, NULL}
};

static const struct AuthMethod1
*lookup_authmethod1(int type)
{
	int i;

	for(i = 0; auth1_methods[i].name != NULL; i++)
		if (auth1_methods[i].type == type)
			return (&(auth1_methods[i]));

	return (NULL);
}

d38 13
a50 77
	const struct AuthMethod1 *a;
	static char buf[64];

	if ((a = lookup_authmethod1(type)) != NULL)
		return (a->name);
	snprintf(buf, sizeof(buf), "bad-auth-msg-%d", type);
	return (buf);
}

static int
auth1_process_password(Authctxt *authctxt, char *info, size_t infolen)
{
	int authenticated = 0;
	char *password;
	u_int dlen;

	/*
	 * Read user password.  It is in plain text, but was
	 * transmitted over the encrypted channel so it is
	 * not visible to an outside observer.
	 */
	password = packet_get_string(&dlen);
	packet_check_eom();

	/* Try authentication with the password. */
	authenticated = PRIVSEP(auth_password(authctxt, password));

	memset(password, 0, dlen);
	xfree(password);

	return (authenticated);
}

static int
auth1_process_rsa(Authctxt *authctxt, char *info, size_t infolen)
{
	int authenticated = 0;
	BIGNUM *n;

	/* RSA authentication requested. */
	if ((n = BN_new()) == NULL)
		fatal("do_authloop: BN_new failed");
	packet_get_bignum(n);
	packet_check_eom();
	authenticated = auth_rsa(authctxt, n);
	BN_clear_free(n);

	return (authenticated);
}

static int
auth1_process_rhosts_rsa(Authctxt *authctxt, char *info, size_t infolen)
{
	int keybits, authenticated = 0;
	u_int bits;
	char *client_user;
	Key *client_host_key;
	u_int ulen;

	/*
	 * Get client user name.  Note that we just have to
	 * trust the client; root on the client machine can
	 * claim to be any user.
	 */
	client_user = packet_get_string(&ulen);

	/* Get the client host key. */
	client_host_key = key_new(KEY_RSA1);
	bits = packet_get_int();
	packet_get_bignum(client_host_key->rsa->e);
	packet_get_bignum(client_host_key->rsa->n);

	keybits = BN_num_bits(client_host_key->rsa->n);
	if (keybits < 0 || bits != (u_int)keybits) {
		verbose("Warning: keysize mismatch for client_host_key: "
		    "actual %d, announced %d",
		    BN_num_bits(client_host_key->rsa->n), bits);
d52 2
a53 44
	packet_check_eom();

	authenticated = auth_rhosts_rsa(authctxt, client_user,
	    client_host_key);
	key_free(client_host_key);

	snprintf(info, infolen, " ruser %.100s", client_user);
	xfree(client_user);
	
	return (authenticated);
}

static int
auth1_process_tis_challenge(Authctxt *authctxt, char *info, size_t infolen)
{
	char *challenge;
	
	if ((challenge = get_challenge(authctxt)) == NULL)
		return (0);

	debug("sending challenge '%s'", challenge);
	packet_start(SSH_SMSG_AUTH_TIS_CHALLENGE);
	packet_put_cstring(challenge);
	xfree(challenge);
	packet_send();
	packet_write_wait();

	return (-1);
}

static int
auth1_process_tis_response(Authctxt *authctxt, char *info, size_t infolen)
{
	int authenticated = 0;
	char *response;
	u_int dlen;

	response = packet_get_string(&dlen);
	packet_check_eom();
	authenticated = verify_response(authctxt, response);
	memset(response, 'r', dlen);
	xfree(response);

	return (authenticated);
d64 4
d69 2
a71 1
	const struct AuthMethod1 *meth;
a98 5
		if ((meth = lookup_authmethod1(type)) == NULL) {
			logit("Unknown message during authentication: "
			    "type %d", type);
			goto skip;
		}
d100 101
a200 3
		if (!*(meth->enabled)) {
			verbose("%s authentication disabled.", meth->name);
			goto skip;
a201 5

		authenticated = meth->method(authctxt, info, sizeof(info));
		if (authenticated == -1)
			continue; /* "postponed" */

d214 1
a214 1
		    !auth_root_allowed(meth->name))
a216 1
 skip:
@


1.1.1.3
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d13 1
a13 1
RCSID("$OpenBSD: auth1.c,v 1.62 2005/07/16 01:35:24 djm Exp $");
d172 1
a172 1

d180 1
a180 1

@


1.1.1.4
log
@I decided we'd better upgrade OpenSSH before releasing to the general public
@
text
@a0 1
/* $OpenBSD: auth1.c,v 1.66 2006/03/25 13:17:01 djm Exp $ */
d13 1
d76 1
a76 1
	for (i = 0; auth1_methods[i].name != NULL; i++)
a94 1
/*ARGSUSED*/
a118 1
/*ARGSUSED*/
a135 1
/*ARGSUSED*/
a175 1
/*ARGSUSED*/
a193 1
/*ARGSUSED*/
@


1.1.1.5
log
@import a few security-wise relevant changes right now
@
text
@d1 1
a1 1
/* $OpenBSD: auth1.c,v 1.70 2006/08/03 03:34:41 deraadt Exp $ */
d13 1
a13 6
#include <sys/types.h>

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <pwd.h>
a22 2
#include "key.h"
#include "hostfile.h"
a26 3
#ifdef GSSAPI
#include "ssh-gss.h"
#endif
@


1.1.1.6
log
@newer openssh
@
text
@d1 1
a1 1
/* $OpenBSD: auth1.c,v 1.71 2007/09/21 08:15:29 djm Exp $ */
d278 1
d283 1
@


1.1.1.7
log
@OpenSSH-current
@
text
@d1 1
a1 1
/* $OpenBSD: auth1.c,v 1.73 2008/07/04 23:30:16 djm Exp $ */
a13 1
#include <sys/queue.h>
a262 2
		if (authctxt->failures >= options.max_authtries)
			goto skip;
d298 1
a298 1
		if (++authctxt->failures >= options.max_authtries)
@


