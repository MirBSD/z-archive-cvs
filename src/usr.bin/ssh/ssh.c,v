head	1.30;
access;
symbols
	cvs-200910041320:1.1.1.20
	cvs-200903221200:1.1.1.19
	cvs-200812162015:1.1.1.18
	cvs-200804031830:1.1.1.17
	MIRBSD_10:1.23.0.2
	MIRBSD_10_BASE:1.23
	cvs-200803022030:1.1.1.17
	cvs-200709131337:1.1.1.16
	cvs-200709021830:1.1.1.15
	cvs-200708201200:1.1.1.15
	cvs-200706161500:1.1.1.14
	cvs-200705192215:1.1.1.13
	cvs-200704292000:1.1.1.13
	cvs-200703080900:1.1.1.13
	cvs-200701251600:1.1.1.13
	cvs-200612111600:1.1.1.12
	cvs-200611090230:1.1.1.12
	OPENBSD_4_0:1.1.1.11
	MIRBSD_9_BASE:1.12
	cvs-200606162342:1.1.1.10
	cvs-200606022000:1.1.1.10
	cvs-200604191000:1.1.1.9
	cvs-200602220045:1.1.1.8
	MIRBSD_8:1.8.0.2
	MIRBSD_8_BASE:1.8
	cvs-200512201942:1.1.1.7
	cvs-200511231930:1.1.1.6
	cvs-200507211800:1.1.1.5
	cvs-200506221550:1.1.1.4
	cvs-200505050030:1.1.1.3
	cvs-200504291700:1.1.1.3
	cvs-200504261445:1.1.1.3
	cvs-200504141900:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2013.10.31.20.07.14;	author tg;	state Exp;
branches;
next	1.29;
commitid	1005272B7081B0E5655;

1.29
date	2011.01.15.21.52.43;	author tg;	state Exp;
branches;
next	1.28;
commitid	1004D32173B08BB4E36;

1.28
date	2009.10.04.14.29.11;	author tg;	state Exp;
branches;
next	1.27;
commitid	1004AC8B1276FC00211;

1.27
date	2009.10.02.16.58.49;	author tg;	state Exp;
branches;
next	1.26;
commitid	1004AC6315648072669;

1.26
date	2009.03.22.15.01.22;	author tg;	state Exp;
branches;
next	1.25;
commitid	10049C652CD5CCC321F;

1.25
date	2008.12.16.22.13.31;	author tg;	state Exp;
branches;
next	1.24;
commitid	10049482819766381ED;

1.24
date	2008.12.16.20.55.30;	author tg;	state Exp;
branches;
next	1.23;
commitid	100494815C97ECEEDBF;

1.23
date	2008.03.02.21.14.23;	author tg;	state Exp;
branches;
next	1.22;
commitid	10047CB18BB506A8527;

1.22
date	2007.09.13.13.52.55;	author tg;	state Exp;
branches;
next	1.21;
commitid	10046E940B668DE9A0B;

1.21
date	2007.08.20.12.11.30;	author tg;	state Exp;
branches;
next	1.20;
commitid	10046C985053DA1DB8B;

1.20
date	2007.08.08.19.09.49;	author tg;	state Exp;
branches;
next	1.19;
commitid	10046BA150E4442DCEC;

1.19
date	2007.07.07.22.46.27;	author tg;	state Exp;
branches;
next	1.18;
commitid	100469017D6725FB9AB;

1.18
date	2007.06.16.15.41.52;	author tg;	state Exp;
branches;
next	1.17;
commitid	100467404D10F2EE204;

1.17
date	2007.01.25.16.18.38;	author tg;	state Exp;
branches;
next	1.16;
commitid	10045B8D86E5B698AD6;

1.16
date	2006.10.13.18.40.51;	author tg;	state Exp;
branches;
next	1.15;
commitid	100452FDDB7190872BF;

1.15
date	2006.09.20.21.41.06;	author tg;	state Exp;
branches;
next	1.14;
commitid	1004511B578580E7F04;

1.14
date	2006.08.12.14.34.14;	author tg;	state Exp;
branches;
next	1.13;
commitid	10044DDE6A973774BEF;

1.13
date	2006.08.12.13.57.11;	author tg;	state Exp;
branches;
next	1.12;
commitid	10044DDDE213D814E74;

1.12
date	2006.06.02.20.50.51;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004480A4952B0D84EA;

1.11
date	2006.04.19.10.40.55;	author tg;	state Exp;
branches;
next	1.10;
commitid	100444613BD3A91C28B;

1.10
date	2006.02.22.02.16.49;	author tg;	state Exp;
branches;
next	1.9;
commitid	10043FBC991512A442B;

1.9
date	2006.02.22.01.23.52;	author tg;	state Exp;
branches;
next	1.8;
commitid	10043FBBD2C2C5E7D81;

1.8
date	2005.12.20.19.57.37;	author tg;	state Exp;
branches;
next	1.7;
commitid	10043A8623F4C1F637E;

1.7
date	2005.11.23.19.45.15;	author tg;	state Exp;
branches;
next	1.6;
commitid	29f4384c6def7d1;

1.6
date	2005.11.23.18.04.21;	author tg;	state Exp;
branches;
next	1.5;
commitid	af74384af2ab463;

1.5
date	2005.06.22.16.11.39;	author tg;	state Exp;
branches;
next	1.4;
commitid	598b42b98dcf335f;

1.4
date	2005.04.26.15.21.50;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2005.04.14.19.49.35;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.13.18.33.33;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.29.55;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.29.55;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.14.19.33.30;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.04.26.14.55.03;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2005.06.22.15.56.28;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	181342b98a38fe99;

1.1.1.5
date	2005.07.21.21.00.35;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	560042e0092f571e;

1.1.1.6
date	2005.11.23.19.34.15;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	116a4384c4467ffc;

1.1.1.7
date	2005.12.20.19.43.46;	author tg;	state Exp;
branches;
next	1.1.1.8;
commitid	10043A85EF81EF097CF;

1.1.1.8
date	2006.02.22.00.51.36;	author tg;	state Exp;
branches;
next	1.1.1.9;
commitid	10043FBB5A933C3BB9B;

1.1.1.9
date	2006.04.19.10.15.05;	author tg;	state Exp;
branches;
next	1.1.1.10;
commitid	10044460DB21E1F715C;

1.1.1.10
date	2006.06.02.20.31.52;	author tg;	state Exp;
branches;
next	1.1.1.11;
commitid	1004480A0422110D712;

1.1.1.11
date	2006.09.20.19.06.50;	author tg;	state Exp;
branches;
next	1.1.1.12;
commitid	10045119150397FC669;

1.1.1.12
date	2006.11.09.02.38.02;	author tg;	state Exp;
branches;
next	1.1.1.13;
commitid	100455294981A6201C8;

1.1.1.13
date	2007.01.25.16.13.24;	author tg;	state Exp;
branches;
next	1.1.1.14;
commitid	10045B8D7100791C016;

1.1.1.14
date	2007.06.16.15.11.13;	author tg;	state Exp;
branches;
next	1.1.1.15;
commitid	1004673FD85114A3F32;

1.1.1.15
date	2007.08.20.12.05.41;	author tg;	state Exp;
branches;
next	1.1.1.16;
commitid	10046C9839120FD28DF;

1.1.1.16
date	2007.09.13.13.39.07;	author tg;	state Exp;
branches;
next	1.1.1.17;
commitid	10046E93D7724AAC1F8;

1.1.1.17
date	2008.03.02.20.40.42;	author tg;	state Exp;
branches;
next	1.1.1.18;
commitid	10047CB10DD30FAF062;

1.1.1.18
date	2008.12.16.20.15.34;	author tg;	state Exp;
branches;
next	1.1.1.19;
commitid	10049480C7A2701F5C0;

1.1.1.19
date	2009.03.22.12.03.00;	author tg;	state Exp;
branches;
next	1.1.1.20;
commitid	10049C6290649163EA3;

1.1.1.20
date	2009.10.04.13.25.45;	author tg;	state Exp;
branches;
next	;
commitid	1004AC8A2663BC008C5;


desc
@@


1.30
log
@adapt most __attribute__((…)) occurrences to new KNF style(9)
@
text
@/* $OpenBSD: ssh.c,v 1.326 2009/07/02 02:11:47 dtucker Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright © 2013
 *	Thorsten “mirabilos” Glaser <tg@@mirbsd.org>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * Ssh client program.  This program can be used to log into a remote machine.
 * The software supports strong authentication, encryption, and forwarding
 * of X11, TCP/IP, and authentication connections.
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 * Copyright (c) 1999 Niels Provos.  All rights reserved.
 * Copyright (c) 2000, 2001, 2002, 2003 Markus Friedl.  All rights reserved.
 *
 * Modified to work with SSL by Niels Provos <provos@@citi.umich.edu>
 * in Canada (German citizen).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/time.h>
#include <sys/ioctl.h>
#include <sys/param.h>
#include <sys/queue.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/stat.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
#include <paths.h>
#include <pwd.h>
#include <signal.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <openssl/evp.h>
#include <openssl/err.h>

#include "xmalloc.h"
#include "ssh.h"
#include "ssh1.h"
#include "ssh2.h"
#include "compat.h"
#include "cipher.h"
#include "packet.h"
#include "buffer.h"
#include "channels.h"
#include "key.h"
#include "authfd.h"
#include "authfile.h"
#include "pathnames.h"
#include "dispatch.h"
#include "clientloop.h"
#include "log.h"
#include "readconf.h"
#include "sshconnect.h"
#include "misc.h"
#include "kex.h"
#include "mac.h"
#include "sshpty.h"
#include "match.h"
#include "msg.h"
#include "uidswap.h"
#include "version.h"

#ifdef SMARTCARD
#include "scard.h"
#endif

__RCSID("$MirOS: src/usr.bin/ssh/ssh.c,v 1.29 2011/01/15 21:52:43 tg Exp $");

extern char *__progname;

/* Flag indicating whether debug mode is on.  May be set on the command line. */
int debug_flag = 0;

/* Flag indicating whether a tty should be allocated */
int tty_flag = 0;
int no_tty_flag = 0;
int force_tty_flag = 0;

/* don't exec a shell */
int no_shell_flag = 0;

/*
 * Flag indicating that nothing should be read from stdin.  This can be set
 * on the command line.
 */
int stdin_null_flag = 0;

/*
 * Flag indicating that ssh should fork after authentication.  This is useful
 * so that the passphrase can be entered manually, and then ssh goes to the
 * background.
 */
int fork_after_authentication_flag = 0;

/*
 * General data structure for command line options and options configurable
 * in configuration files.  See readconf.h.
 */
Options options;

/* optional user configfile */
char *config = NULL;

/*
 * Name of the host we are connecting to.  This is the name given on the
 * command line, or the Hostname specified for the user-supplied name in a
 * configuration file.
 */
char *host;

/* socket address the host resolves to */
struct sockaddr_storage hostaddr;

/* Private host keys. */
Sensitive sensitive_data;

/* Original real UID. */
uid_t original_real_uid;
uid_t original_effective_uid;

/* command to be executed */
Buffer command;

/* Should we execute a command or invoke a subsystem? */
int subsystem_flag = 0;

/* # of replies received for global requests */
static int remote_forward_confirms_received = 0;

/* pid of proxycommand child process */
pid_t proxy_command_pid = 0;

/* mux.c */
extern int muxserver_sock;
extern u_int muxclient_command;


/* Prints a help message to the user.  This function never returns. */

static __dead void
usage(void)
{
	fprintf(stderr,
"usage: ssh [-1246AaCfgMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]\n"
"           [-D [bind_address:]port] [-e escape_char] [-F configfile]\n"
"           [-i identity_file] [-L [bind_address:]port:host:hostport]\n"
"           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]\n"
"           [-R [bind_address:]port:host:hostport] [-S ctl_path]\n"
"           [-w local_tun[:remote_tun]] [user@@]hostname [command]\n"
	);
	exit(255);
}

static int ssh_session(void);
static int ssh_session2(void);
static void load_public_identity_files(void);

/*
 * Main program for the ssh client.
 */
int
main(int ac, char **av)
{
	int i, r, opt, exit_status, use_syslog;
	char *p, *cp, *line, *argv0, buf[MAXPATHLEN];
	struct stat st;
	struct passwd *pw;
	int dummy, timeout_ms;
	struct servent *sp;
	Forward fwd;

	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

	/*
	 * Save the original real uid.  It will be needed later (uid-swapping
	 * may clobber the real uid).
	 */
	original_real_uid = getuid();
	original_effective_uid = geteuid();

	/*
	 * Use uid-swapping to give up root privileges for the duration of
	 * option processing.  We will re-instantiate the rights when we are
	 * ready to create the privileged port, and will permanently drop
	 * them when the port has been created (actually, when the connection
	 * has been made, as we may need to create the port several times).
	 */
	PRIV_END;

	/* If we are installed setuid root be careful to not drop core. */
	if (original_real_uid != original_effective_uid) {
		struct rlimit rlim;
		rlim.rlim_cur = rlim.rlim_max = 0;
		if (setrlimit(RLIMIT_CORE, &rlim) < 0)
			fatal("setrlimit failed: %.100s", strerror(errno));
	}
	/* Get user data. */
	pw = getpwuid(original_real_uid);
	if (!pw) {
		logit("You don't exist, go away!");
		exit(255);
	}
	/* Take a copy of the returned structure. */
	pw = pwcopy(pw);

	/*
	 * Set our umask to something reasonable, as some files are created
	 * with the default umask.  This will make them world-readable but
	 * writable only by the owner, which is ok for all files for which we
	 * don't set the modes explicitly.
	 */
	umask(022);

	/*
	 * Initialize option structure to indicate that no values have been
	 * set.
	 */
	initialize_options(&options);

	/* Parse command-line arguments. */
	host = NULL;
	use_syslog = 0;
	argv0 = av[0];

 again:
	while ((opt = getopt(ac, av, "1246ab:c:e:fghi:kl:m:no:p:qstvx"
	    "ACD:F:I:KL:MNO:PR:S:TVw:XYy")) != -1) {
		switch (opt) {
		case '1':
			options.protocol = SSH_PROTO_1;
			break;
		case '2':
			options.protocol = SSH_PROTO_2;
			break;
		case '4':
			options.address_family = AF_INET;
			break;
		case '6':
			options.address_family = AF_INET6;
			break;
		case 'n':
			stdin_null_flag = 1;
			break;
		case 'f':
			fork_after_authentication_flag = 1;
			stdin_null_flag = 1;
			break;
		case 'x':
			options.forward_x11 = 0;
			break;
		case 'X':
			options.forward_x11 = 1;
			break;
		case 'y':
			use_syslog = 1;
			break;
		case 'Y':
			options.forward_x11 = 1;
			options.forward_x11_trusted = 1;
			break;
		case 'g':
			options.gateway_ports = 1;
			break;
		case 'O':
			if (strcmp(optarg, "check") == 0)
				muxclient_command = SSHMUX_COMMAND_ALIVE_CHECK;
			else if (strcmp(optarg, "exit") == 0)
				muxclient_command = SSHMUX_COMMAND_TERMINATE;
			else
				fatal("Invalid multiplex command.");
			break;
		case 'P':	/* deprecated */
			options.use_privileged_port = 0;
			break;
		case 'a':
			options.forward_agent = 0;
			break;
		case 'A':
			options.forward_agent = 1;
			break;
		case 'k':
		case 'K':
			break;
		case 'i':
			if (stat(optarg, &st) < 0) {
				fprintf(stderr, "Warning: Identity file %s "
				    "not accessible: %s.\n", optarg,
				    strerror(errno));
				break;
			}
			if (options.num_identity_files >=
			    SSH_MAX_IDENTITY_FILES)
				fatal("Too many identity files specified "
				    "(max %d)", SSH_MAX_IDENTITY_FILES);
			options.identity_files[options.num_identity_files++] =
			    xstrdup(optarg);
			break;
		case 'I':
#ifdef SMARTCARD
			options.smartcard_device = xstrdup(optarg);
#else
			fprintf(stderr, "no support for smartcards.\n");
#endif
			break;
		case 't':
			if (tty_flag)
				force_tty_flag = 1;
			tty_flag = 1;
			break;
		case 'v':
			if (debug_flag == 0) {
				debug_flag = 1;
				options.log_level = SYSLOG_LEVEL_DEBUG1;
			} else {
				if (options.log_level < SYSLOG_LEVEL_DEBUG3)
					options.log_level++;
				break;
			}
			/* FALLTHROUGH */
		case 'V':
			fprintf(stderr, "%s, %s\n",
			    SSH_VERSION, SSLeay_version(SSLEAY_VERSION));
			if (opt == 'V')
				exit(0);
			break;
		case 'w':
			if (options.tun_open == -1)
				options.tun_open = SSH_TUNMODE_DEFAULT;
			options.tun_local = a2tun(optarg, &options.tun_remote);
			if (options.tun_local == SSH_TUNID_ERR) {
				fprintf(stderr,
				    "Bad tun device '%s'\n", optarg);
				exit(255);
			}
			break;
		case 'q':
			options.log_level = SYSLOG_LEVEL_QUIET;
			break;
		case 'e':
			if (optarg[0] == '^' && optarg[2] == 0 &&
			    (u_char) optarg[1] >= 64 &&
			    (u_char) optarg[1] < 128)
				options.escape_char = (u_char) optarg[1] & 31;
			else if (strlen(optarg) == 1)
				options.escape_char = (u_char) optarg[0];
			else if (strcmp(optarg, "none") == 0)
				options.escape_char = SSH_ESCAPECHAR_NONE;
			else {
				fprintf(stderr, "Bad escape character '%s'.\n",
				    optarg);
				exit(255);
			}
			break;
		case 'c':
			if (ciphers_valid(optarg)) {
				/* SSH2 only */
				options.ciphers = xstrdup(optarg);
				options.cipher = SSH_CIPHER_INVALID;
			} else {
				/* SSH1 only */
				options.cipher = cipher_number(optarg);
				if (options.cipher == -1) {
					fprintf(stderr,
					    "Unknown cipher type '%s'\n",
					    optarg);
					exit(255);
				}
				if (options.cipher == SSH_CIPHER_3DES)
					options.ciphers = "3des-cbc";
				else if (options.cipher == SSH_CIPHER_BLOWFISH)
					options.ciphers = "blowfish-cbc";
				else
					options.ciphers = (const char *)-1;
			}
			break;
		case 'm':
			if (mac_valid(optarg))
				options.macs = xstrdup(optarg);
			else {
				fprintf(stderr, "Unknown mac type '%s'\n",
				    optarg);
				exit(255);
			}
			break;
		case 'M':
			if (options.control_master == SSHCTL_MASTER_YES)
				options.control_master = SSHCTL_MASTER_ASK;
			else
				options.control_master = SSHCTL_MASTER_YES;
			break;
		case 'p':
			options.port = a2port(optarg);
			if (options.port <= 0) {
				fprintf(stderr, "Bad port '%s'\n", optarg);
				exit(255);
			}
			break;
		case 'l':
			options.user = optarg;
			break;

		case 'L':
			if (parse_forward(&fwd, optarg, 0, 0))
				add_local_forward(&options, &fwd);
			else {
				fprintf(stderr,
				    "Bad local forwarding specification '%s'\n",
				    optarg);
				exit(255);
			}
			break;

		case 'R':
			if (parse_forward(&fwd, optarg, 0, 1)) {
				add_remote_forward(&options, &fwd);
			} else {
				fprintf(stderr,
				    "Bad remote forwarding specification "
				    "'%s'\n", optarg);
				exit(255);
			}
			break;

		case 'D':
			if (parse_forward(&fwd, optarg, 1, 0)) {
				add_local_forward(&options, &fwd);
			} else {
				fprintf(stderr,
				    "Bad dynamic forwarding specification "
				    "'%s'\n", optarg);
				exit(255);
			}
			break;

		case 'C':
			options.compression = 1;
			break;
		case 'N':
			no_shell_flag = 1;
			no_tty_flag = 1;
			break;
		case 'T':
			no_tty_flag = 1;
			break;
		case 'o':
			dummy = 1;
			line = xstrdup(optarg);
			if (process_config_line(&options, host ? host : "",
			    line, "command-line", 0, &dummy) != 0)
				exit(255);
			xfree(line);
			break;
		case 's':
			subsystem_flag = 1;
			break;
		case 'S':
			if (options.control_path != NULL)
				free(options.control_path);
			options.control_path = xstrdup(optarg);
			break;
		case 'b':
			options.bind_address = optarg;
			break;
		case 'F':
			config = optarg;
			break;
		case 'h':
			break;		/* compatibility to MirOS #8 */
		default:
			usage();
		}
	}

	ac -= optind;
	av += optind;

	if (ac > 0 && !host && **av != '-') {
		if (strrchr(*av, '@@')) {
			p = xstrdup(*av);
			cp = strrchr(p, '@@');
			if (cp == NULL || cp == p)
				usage();
			options.user = p;
			*cp = '\0';
			host = ++cp;
		} else
			host = *av;
		if (ac > 1) {
			optind = optreset = 1;
			goto again;
		}
		ac--, av++;
	}

	/* Check that we got a host name. */
	if (!host)
		usage();

	SSLeay_add_all_algorithms();
	ERR_load_crypto_strings();

	/* Initialize the command to execute on remote host. */
	buffer_init(&command);

	/*
	 * Save the command to execute on the remote host in a buffer. There
	 * is no limit on the length of the command, except by the maximum
	 * packet size.  Also sets the tty flag if there is no command.
	 */
	if (!ac) {
		/* No command specified - execute shell on a tty. */
		tty_flag = 1;
		if (subsystem_flag) {
			fprintf(stderr,
			    "You must specify a subsystem to invoke.\n");
			usage();
		}
	} else {
		/* A command has been specified.  Store it into the buffer. */
		for (i = 0; i < ac; i++) {
			if (i)
				buffer_append(&command, " ", 1);
			buffer_append(&command, av[i], strlen(av[i]));
		}
	}

	/* Cannot fork to background if no command. */
	if (fork_after_authentication_flag && buffer_len(&command) == 0 &&
	    !no_shell_flag)
		fatal("Cannot fork into background without a command "
		    "to execute.");

	/* Allocate a tty by default if no command specified. */
	if (buffer_len(&command) == 0)
		tty_flag = 1;

	/* Force no tty */
	if (no_tty_flag)
		tty_flag = 0;
	/* Do not allocate a tty if stdin is not a tty. */
	if ((!isatty(fileno(stdin)) || stdin_null_flag) && !force_tty_flag) {
		if (tty_flag)
			logit("Pseudo-terminal will not be allocated because "
			    "stdin is not a terminal.");
		tty_flag = 0;
	}

	/*
	 * Initialize "log" output.  Since we are the client all output
	 * actually goes to stderr.
	 */
	log_init(argv0,
	    options.log_level == -1 ? SYSLOG_LEVEL_INFO : options.log_level,
	    SYSLOG_FACILITY_USER, !use_syslog);

	/*
	 * Read per-user configuration file.  Ignore the system wide config
	 * file if the user specifies a config file on the command line.
	 */
	if (config != NULL) {
		if (!read_config_file(config, host, &options, 0))
			fatal("Can't open user config file %.100s: "
			    "%.100s", config, strerror(errno));
	} else {
		if (!pw->pw_dir || !pw->pw_dir[0] || (pw->pw_dir[0] == '/' &&
		    !pw->pw_dir[1]))
			r = snprintf(buf, sizeof(buf), "%s",
			    _PATH_SSH_ROOT_CONFFILE);
		else
			r = snprintf(buf, sizeof(buf), "%s/%s", pw->pw_dir,
			    _PATH_SSH_USER_CONFFILE);
		if (r > 0 && (size_t)r < sizeof(buf))
			(void)read_config_file(buf, host, &options, 1);

		/* Read systemwide configuration file after use config. */
		(void)read_config_file(_PATH_HOST_CONFIG_FILE, host,
		    &options, 0);
	}

	/* Fill configuration defaults. */
	fill_default_options(&options, pw);

	channel_set_af(options.address_family);

	/* reinit */
	log_init(argv0, options.log_level, SYSLOG_FACILITY_USER, !use_syslog);

	if (options.user == NULL)
		options.user = xstrdup(pw->pw_name);

	/* Get default port if port has not been set. */
	if (options.port == 0) {
		sp = getservbyname(SSH_SERVICE_NAME, "tcp");
		options.port = sp ? ntohs(sp->s_port) : SSH_DEFAULT_PORT;
	}

	if (options.local_command != NULL) {
		char thishost[NI_MAXHOST];

		if (gethostname(thishost, sizeof(thishost)) == -1)
			fatal("gethostname: %s", strerror(errno));
		snprintf(buf, sizeof(buf), "%d", options.port);
		debug3("expanding LocalCommand: %s", options.local_command);
		cp = options.local_command;
		options.local_command = percent_expand(cp, "d", pw->pw_dir,
		    "h", options.hostname? options.hostname : host,
                    "l", thishost, "n", host, "r", options.user, "p", buf,
                    "u", pw->pw_name, (char *)NULL);
		debug3("expanded LocalCommand: %s", options.local_command);
		xfree(cp);
	}

	if (options.hostname != NULL)
		host = options.hostname;

	/* force lowercase for hostkey matching */
	if (options.host_key_alias != NULL) {
		for (p = options.host_key_alias; *p; p++)
			if (isupper(*p))
				*p = (char)tolower(*p);
	}

	if (options.proxy_command != NULL &&
	    strcmp(options.proxy_command, "none") == 0) {
		xfree(options.proxy_command);
		options.proxy_command = NULL;
	}
	if (options.control_path != NULL &&
	    strcmp(options.control_path, "none") == 0) {
		xfree(options.control_path);
		options.control_path = NULL;
	}

	if (options.control_path != NULL) {
		char thishost[NI_MAXHOST];

		if (gethostname(thishost, sizeof(thishost)) == -1)
			fatal("gethostname: %s", strerror(errno));
		snprintf(buf, sizeof(buf), "%d", options.port);
		cp = tilde_expand_filename(options.control_path,
		    original_real_uid);
		xfree(options.control_path);
		options.control_path = percent_expand(cp, "p", buf, "h", host,
		    "r", options.user, "l", thishost, (char *)NULL);
		xfree(cp);
	}
	if (muxclient_command != 0 && options.control_path == NULL)
		fatal("No ControlPath specified for \"-O\" command");
	if (options.control_path != NULL)
		muxclient(options.control_path);

	timeout_ms = options.connection_timeout * 1000;

	/* Open a connection to the remote host. */
	if (ssh_connect(host, &hostaddr, options.port,
	    options.address_family, options.connection_attempts, &timeout_ms,
	    options.tcp_keep_alive, 
	    original_effective_uid == 0 && options.use_privileged_port,
	    options.proxy_command) != 0)
		exit(255);

	if (timeout_ms > 0)
		debug3("timeout: %d ms remain after connect", timeout_ms);

	/*
	 * If we successfully made the connection, load the host private key
	 * in case we will need it later for combined rsa-rhosts
	 * authentication. This must be done before releasing extra
	 * privileges, because the file is only readable by root.
	 * If we cannot access the private keys, load the public keys
	 * instead and try to execute the ssh-keysign helper instead.
	 */
	sensitive_data.nkeys = 0;
	sensitive_data.keys = NULL;
	sensitive_data.external_keysign = 0;
	if (options.rhosts_rsa_authentication ||
	    options.hostbased_authentication) {
		sensitive_data.nkeys = 3;
		sensitive_data.keys = xcalloc(sensitive_data.nkeys,
		    sizeof(Key));

		PRIV_START;
		sensitive_data.keys[0] = key_load_private_type(KEY_RSA1,
		    _PATH_HOST_KEY_FILE, "", NULL, NULL);
		sensitive_data.keys[1] = key_load_private_type(KEY_DSA,
		    _PATH_HOST_DSA_KEY_FILE, "", NULL, NULL);
		sensitive_data.keys[2] = key_load_private_type(KEY_RSA,
		    _PATH_HOST_RSA_KEY_FILE, "", NULL, NULL);
		PRIV_END;

		if (options.hostbased_authentication == 1 &&
		    sensitive_data.keys[0] == NULL &&
		    sensitive_data.keys[1] == NULL &&
		    sensitive_data.keys[2] == NULL) {
			sensitive_data.keys[1] = key_load_public(
			    _PATH_HOST_DSA_KEY_FILE, NULL);
			sensitive_data.keys[2] = key_load_public(
			    _PATH_HOST_RSA_KEY_FILE, NULL);
			sensitive_data.external_keysign = 1;
		}
	}
	/*
	 * Get rid of any extra privileges that we may have.  We will no
	 * longer need them.  Also, extra privileges could make it very hard
	 * to read identity files and other non-world-readable files from the
	 * user's home directory if it happens to be on a NFS volume where
	 * root is mapped to nobody.
	 */
	if (original_effective_uid == 0) {
		PRIV_START;
		permanently_set_uid(pw);
	}

	/*
	 * Now that we are back to our own permissions, create ~/.etc/ssh
	 * directory if it doesn't already exist.
	 * XXX create ~/.etc first?
	 */
	r = snprintf(buf, sizeof buf, "%s%s%s", pw->pw_dir,
	    strcmp(pw->pw_dir, "/") ? "/" : "", _PATH_SSH_USER_DIR);
	if (r > 0 && (size_t)r < sizeof(buf) && stat(buf, &st) < 0)
		if (mkdir(buf, 0700) < 0)
			error("Could not create directory '%.200s'.", buf);

	/* load options.identity_files */
	load_public_identity_files();

	/* Expand ~ in known host file names. */
	/* XXX mem-leaks: */
	options.system_hostfile =
	    tilde_expand_filename(options.system_hostfile, original_real_uid);
	options.user_hostfile =
	    tilde_expand_filename(options.user_hostfile, original_real_uid);
	options.system_hostfile2 =
	    tilde_expand_filename(options.system_hostfile2, original_real_uid);
	options.user_hostfile2 =
	    tilde_expand_filename(options.user_hostfile2, original_real_uid);

	signal(SIGPIPE, SIG_IGN); /* ignore SIGPIPE early */

	/* Log into the remote system.  Never returns if the login fails. */
	ssh_login(&sensitive_data, host, (struct sockaddr *)&hostaddr,
	    pw, timeout_ms);

	/* We no longer need the private host keys.  Clear them now. */
	if (sensitive_data.nkeys != 0) {
		for (i = 0; i < sensitive_data.nkeys; i++) {
			if (sensitive_data.keys[i] != NULL) {
				/* Destroys contents safely */
				debug3("clear hostkey %d", i);
				key_free(sensitive_data.keys[i]);
				sensitive_data.keys[i] = NULL;
			}
		}
		xfree(sensitive_data.keys);
	}
	for (i = 0; i < options.num_identity_files; i++) {
		if (options.identity_files[i]) {
			xfree(options.identity_files[i]);
			options.identity_files[i] = NULL;
		}
		if (options.identity_keys[i]) {
			key_free(options.identity_keys[i]);
			options.identity_keys[i] = NULL;
		}
	}

	exit_status = compat20 ? ssh_session2() : ssh_session();
	packet_close();

	if (options.control_path != NULL && muxserver_sock != -1)
		unlink(options.control_path);

	/*
	 * Send SIGHUP to proxy command if used. We don't wait() in
	 * case it hangs and instead rely on init to reap the child
	 */
	if (proxy_command_pid > 1)
		kill(proxy_command_pid, SIGHUP);

	return exit_status;
}

/* Callback for remote forward global requests */
static void
ssh_confirm_remote_forward(int type, u_int32_t seq __attribute__((__unused__)),
    void *ctxt)
{
	Forward *rfwd = (Forward *)ctxt;

	/* XXX verbose() on failure? */
	debug("remote forward %s for: listen %d, connect %s:%d",
	    type == SSH2_MSG_REQUEST_SUCCESS ? "success" : "failure",
	    rfwd->listen_port, rfwd->connect_host, rfwd->connect_port);
	if (type == SSH2_MSG_REQUEST_SUCCESS && rfwd->listen_port == 0) {
		logit("Allocated port %u for remote forward to %s:%d",
			packet_get_int(),
			rfwd->connect_host, rfwd->connect_port);
	}
	
	if (type == SSH2_MSG_REQUEST_FAILURE) {
		if (options.exit_on_forward_failure)
			fatal("Error: remote port forwarding failed for "
			    "listen port %d", rfwd->listen_port);
		else
			logit("Warning: remote port forwarding failed for "
			    "listen port %d", rfwd->listen_port);
	}
	if (++remote_forward_confirms_received == options.num_remote_forwards) {
		debug("All remote forwarding requests processed");
		if (fork_after_authentication_flag) {
			fork_after_authentication_flag = 0;
			if (daemon(1, 1) < 0)
				fatal("daemon() failed: %.200s",
				    strerror(errno));
		}
	}
}

static void
ssh_init_forwarding(void)
{
	int success = 0;
	int i;

	/* Initiate local TCP/IP port forwardings. */
	for (i = 0; i < options.num_local_forwards; i++) {
		debug("Local connections to %.200s:%d forwarded to remote "
		    "address %.200s:%d",
		    (options.local_forwards[i].listen_host == NULL) ?
		    (options.gateway_ports ? "*" : "LOCALHOST") :
		    options.local_forwards[i].listen_host,
		    options.local_forwards[i].listen_port,
		    options.local_forwards[i].connect_host,
		    options.local_forwards[i].connect_port);
		success += channel_setup_local_fwd_listener(
		    options.local_forwards[i].listen_host,
		    options.local_forwards[i].listen_port,
		    options.local_forwards[i].connect_host,
		    options.local_forwards[i].connect_port,
		    options.gateway_ports);
	}
	if (i > 0 && success != i && options.exit_on_forward_failure)
		fatal("Could not request local forwarding.");
	if (i > 0 && success == 0)
		error("Could not request local forwarding.");

	/* Initiate remote TCP/IP port forwardings. */
	for (i = 0; i < options.num_remote_forwards; i++) {
		debug("Remote connections from %.200s:%d forwarded to "
		    "local address %.200s:%d",
		    (options.remote_forwards[i].listen_host == NULL) ?
		    "LOCALHOST" : options.remote_forwards[i].listen_host,
		    options.remote_forwards[i].listen_port,
		    options.remote_forwards[i].connect_host,
		    options.remote_forwards[i].connect_port);
		if (channel_request_remote_forwarding(
		    options.remote_forwards[i].listen_host,
		    options.remote_forwards[i].listen_port,
		    options.remote_forwards[i].connect_host,
		    options.remote_forwards[i].connect_port) < 0) {
			if (options.exit_on_forward_failure)
				fatal("Could not request remote forwarding.");
			else
				logit("Warning: Could not request remote "
				    "forwarding.");
		}
		client_register_global_confirm(ssh_confirm_remote_forward,
		    &options.remote_forwards[i]);
	}

	/* Initiate tunnel forwarding. */
	if (options.tun_open != SSH_TUNMODE_NO) {
		if (client_request_tun_fwd(options.tun_open,
		    options.tun_local, options.tun_remote) == -1) {
			if (options.exit_on_forward_failure)
				fatal("Could not request tunnel forwarding.");
			else
				error("Could not request tunnel forwarding.");
		}
	}			
}

static void
check_agent_present(void)
{
	if (options.forward_agent) {
		/* Clear agent forwarding if we don't have an agent. */
		if (!ssh_agent_present())
			options.forward_agent = 0;
	}
}

static int
ssh_session(void)
{
	int type;
	int interactive = 0;
	int have_tty = 0;
	struct winsize ws;
	const char *cp;
	const char *display;

	/* Enable compression if requested. */
	if (options.compression) {
		debug("Requesting compression at level %d.",
		    options.compression_level);

		if (options.compression_level < 1 ||
		    options.compression_level > 9)
			fatal("Compression level must be from 1 (fast) to "
			    "9 (slow, best).");

		/* Send the request. */
		packet_start(SSH_CMSG_REQUEST_COMPRESSION);
		packet_put_int(options.compression_level);
		packet_send();
		packet_write_wait();
		type = packet_read();
		if (type == SSH_SMSG_SUCCESS)
			packet_start_compression(options.compression_level);
		else if (type == SSH_SMSG_FAILURE)
			logit("Warning: Remote host refused compression.");
		else
			packet_disconnect("Protocol error waiting for "
			    "compression response.");
	}
	/* Allocate a pseudo tty if appropriate. */
	if (tty_flag) {
		debug("Requesting pty.");

		/* Start the packet. */
		packet_start(SSH_CMSG_REQUEST_PTY);

		/* Store TERM in the packet.  There is no limit on the
		   length of the string. */
		cp = getenv("TERM");
		if (!cp)
			cp = "";
		packet_put_cstring(cp);

		/* Store window size in the packet. */
		if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) < 0)
			memset(&ws, 0, sizeof(ws));
		packet_put_int((u_int)ws.ws_row);
		packet_put_int((u_int)ws.ws_col);
		packet_put_int((u_int)ws.ws_xpixel);
		packet_put_int((u_int)ws.ws_ypixel);

		/* Store tty modes in the packet. */
		tty_make_modes(fileno(stdin), NULL);

		/* Send the packet, and wait for it to leave. */
		packet_send();
		packet_write_wait();

		/* Read response from the server. */
		type = packet_read();
		if (type == SSH_SMSG_SUCCESS) {
			interactive = 1;
			have_tty = 1;
		} else if (type == SSH_SMSG_FAILURE)
			logit("Warning: Remote host failed or refused to "
			    "allocate a pseudo tty.");
		else
			packet_disconnect("Protocol error waiting for pty "
			    "request response.");
	}
	/* Request X11 forwarding if enabled and DISPLAY is set. */
	display = getenv("DISPLAY");
	if (options.forward_x11 && display != NULL) {
		char *proto, *data;
		/* Get reasonable local authentication information. */
		client_x11_get_proto(display, options.xauth_location,
		    options.forward_x11_trusted, &proto, &data);
		/* Request forwarding with authentication spoofing. */
		debug("Requesting X11 forwarding with authentication "
		    "spoofing.");
		x11_request_forwarding_with_spoofing(0, display, proto, data);

		/* Read response from the server. */
		type = packet_read();
		if (type == SSH_SMSG_SUCCESS) {
			interactive = 1;
		} else if (type == SSH_SMSG_FAILURE) {
			logit("Warning: Remote host denied X11 forwarding.");
		} else {
			packet_disconnect("Protocol error waiting for X11 "
			    "forwarding");
		}
	}
	/* Tell the packet module whether this is an interactive session. */
	packet_set_interactive(interactive);

	/* Request authentication agent forwarding if appropriate. */
	check_agent_present();

	if (options.forward_agent) {
		debug("Requesting authentication agent forwarding.");
		auth_request_forwarding();

		/* Read response from the server. */
		type = packet_read();
		packet_check_eom();
		if (type != SSH_SMSG_SUCCESS)
			logit("Warning: Remote host denied authentication agent forwarding.");
	}

	/* Initiate port forwardings. */
	ssh_init_forwarding();

	/* Execute a local command */
	if (options.local_command != NULL &&
	    options.permit_local_command)
		ssh_local_cmd(options.local_command);

	/*
	 * If requested and we are not interested in replies to remote
	 * forwarding requests, then let ssh continue in the background.
	 */
	if (fork_after_authentication_flag &&
	    (!options.exit_on_forward_failure ||
	    options.num_remote_forwards == 0)) {
		fork_after_authentication_flag = 0;
		if (daemon(1, 1) < 0)
			fatal("daemon() failed: %.200s", strerror(errno));
	}

	/*
	 * If a command was specified on the command line, execute the
	 * command now. Otherwise request the server to start a shell.
	 */
	if (buffer_len(&command) > 0) {
		int len = buffer_len(&command);
		if (len > 900)
			len = 900;
		debug("Sending command: %.*s", len,
		    (u_char *)buffer_ptr(&command));
		packet_start(SSH_CMSG_EXEC_CMD);
		packet_put_string(buffer_ptr(&command), buffer_len(&command));
		packet_send();
		packet_write_wait();
	} else {
		debug("Requesting shell.");
		packet_start(SSH_CMSG_EXEC_SHELL);
		packet_send();
		packet_write_wait();
	}

	/* Enter the interactive session. */
	return client_loop(have_tty, tty_flag ?
	    options.escape_char : SSH_ESCAPECHAR_NONE, 0);
}

/* request pty/x11/agent/tcpfwd/shell for channel */
static void
ssh_session2_setup(int id, void *arg __attribute__((__unused__)))
{
	extern char **environ;
	const char *display;
	int interactive = tty_flag;

	display = getenv("DISPLAY");
	if (options.forward_x11 && display != NULL) {
		char *proto, *data;
		/* Get reasonable local authentication information. */
		client_x11_get_proto(display, options.xauth_location,
		    options.forward_x11_trusted, &proto, &data);
		/* Request forwarding with authentication spoofing. */
		debug("Requesting X11 forwarding with authentication "
		    "spoofing.");
		x11_request_forwarding_with_spoofing(id, display, proto, data);
		interactive = 1;
		/* XXX wait for reply */
	}

	check_agent_present();
	if (options.forward_agent) {
		debug("Requesting authentication agent forwarding.");
		channel_request_start(id, "auth-agent-req@@openssh.com", 0);
		packet_send();
	}

	client_session2_setup(id, tty_flag, subsystem_flag, getenv("TERM"),
	    NULL, fileno(stdin), &command, environ);

	packet_set_interactive(interactive);
}

/* open new channel for a session */
static int
ssh_session2_open(void)
{
	Channel *c;
	int window, packetmax, in, out, err;

	if (stdin_null_flag) {
		in = open(_PATH_DEVNULL, O_RDONLY);
	} else {
		in = dup(STDIN_FILENO);
	}
	out = dup(STDOUT_FILENO);
	err = dup(STDERR_FILENO);

	if (in < 0 || out < 0 || err < 0)
		fatal("dup() in/out/err failed");

	/* enable nonblocking unless tty */
	if (!isatty(in))
		set_nonblock(in);
	if (!isatty(out))
		set_nonblock(out);
	if (!isatty(err))
		set_nonblock(err);

	window = CHAN_SES_WINDOW_DEFAULT;
	packetmax = CHAN_SES_PACKET_DEFAULT;
	if (tty_flag) {
		window >>= 1;
		packetmax >>= 1;
	}
	c = channel_new(
	    "session", SSH_CHANNEL_OPENING, in, out, err,
	    window, packetmax, CHAN_EXTENDED_WRITE,
	    "client-session", /*nonblock*/0);

	debug3("ssh_session2_open: channel_new: %d", c->self);

	channel_send_open(c->self);
	if (!no_shell_flag)
		channel_register_open_confirm(c->self,
		    ssh_session2_setup, NULL);

	return c->self;
}

static int
ssh_session2(void)
{
	int id = -1;

	/* XXX should be pre-session */
	ssh_init_forwarding();

	if (!no_shell_flag || (datafellows & SSH_BUG_DUMMYCHAN))
		id = ssh_session2_open();

	/* If we don't expect to open a new session, then disallow it */
	if (options.control_master == SSHCTL_MASTER_NO &&
	    (datafellows & SSH_NEW_OPENSSH)) {
		debug("Requesting no-more-sessions@@openssh.com");
		packet_start(SSH2_MSG_GLOBAL_REQUEST);
		packet_put_cstring("no-more-sessions@@openssh.com");
		packet_put_char(0);
		packet_send();
	}

	/* Execute a local command */
	if (options.local_command != NULL &&
	    options.permit_local_command)
		ssh_local_cmd(options.local_command);

	/* Start listening for multiplex clients */
	muxserver_listen();

	/* If requested, let ssh continue in the background. */
	if (fork_after_authentication_flag) {
		fork_after_authentication_flag = 0;
		if (daemon(1, 1) < 0)
			fatal("daemon() failed: %.200s", strerror(errno));
	}

	return client_loop(tty_flag, tty_flag ?
	    options.escape_char : SSH_ESCAPECHAR_NONE, id);
}

static void
load_public_identity_files(void)
{
	char *filename, *cp, thishost[NI_MAXHOST];
	char *pwdir = NULL, *pwname = NULL;
	int i = 0;
	Key *public;
	struct passwd *pw;
#ifdef SMARTCARD
	Key **keys;

	if (options.smartcard_device != NULL &&
	    options.num_identity_files < SSH_MAX_IDENTITY_FILES &&
	    (keys = sc_get_keys(options.smartcard_device, NULL)) != NULL) {
		int count = 0;
		for (i = 0; keys[i] != NULL; i++) {
			count++;
			memmove(&options.identity_files[1],
			    &options.identity_files[0],
			    sizeof(char *) * (SSH_MAX_IDENTITY_FILES - 1));
			memmove(&options.identity_keys[1],
			    &options.identity_keys[0],
			    sizeof(Key *) * (SSH_MAX_IDENTITY_FILES - 1));
			options.num_identity_files++;
			options.identity_keys[0] = keys[i];
			options.identity_files[0] = sc_get_key_label(keys[i]);
		}
		if (options.num_identity_files > SSH_MAX_IDENTITY_FILES)
			options.num_identity_files = SSH_MAX_IDENTITY_FILES;
		i = count;
		xfree(keys);
	}
#endif /* SMARTCARD */
	if ((pw = getpwuid(original_real_uid)) == NULL)
		fatal("load_public_identity_files: getpwuid failed");
	pwname = xstrdup(pw->pw_name);
	pwdir = xstrdup(pw->pw_dir);
	if (gethostname(thishost, sizeof(thishost)) == -1)
		fatal("load_public_identity_files: gethostname: %s",
		    strerror(errno));
	for (; i < options.num_identity_files; i++) {
		cp = tilde_expand_filename(options.identity_files[i],
		    original_real_uid);
		filename = percent_expand(cp, "d", pwdir,
		    "u", pwname, "l", thishost, "h", host,
		    "r", options.user, (char *)NULL);
		xfree(cp);
		public = key_load_public(filename, NULL);
		debug("identity file %s type %d", filename,
		    public ? public->type : -1);
		xfree(options.identity_files[i]);
		options.identity_files[i] = filename;
		options.identity_keys[i] = public;
	}
	bzero(pwname, strlen(pwname));
	xfree(pwname);
	bzero(pwdir, strlen(pwdir));
	xfree(pwdir);
}
@


1.29
log
@Introduce /etc/ssh/root:config and /etc/ssh/root:known_hosts
and /etc/ssh/root:authorised_keys for the superuser if his
HOME directory is unset, empty or, not normalised, "/" (root).
十̲CVS: ----------------------------------------------------------------------
@
text
@d4 2
d101 1
a101 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh.c,v 1.28 2009/10/04 14:29:11 tg Exp $");
d821 1
a821 1
ssh_confirm_remote_forward(int type, u_int32_t seq __attribute__((unused)),
d1092 1
a1092 1
ssh_session2_setup(int id, void *arg __attribute__((unused)))
@


1.28
log
@• merge newer OpenSSH
• KNF in our diff – style(9)
• some const cleanliness (build with __CRAZY=Yes mostly)
@
text
@d99 1
a99 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh.c,v 1.27 2009/10/02 16:58:49 tg Exp $");
d598 7
a604 2
		r = snprintf(buf, sizeof buf, "%s/%s", pw->pw_dir,
		    _PATH_SSH_USER_CONFFILE);
d614 1
a614 1
	fill_default_options(&options);
@


1.27
log
@sync ssh_config and manpage with each other
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.325 2009/03/17 21:37:00 markus Exp $ */
d46 1
d99 1
a99 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh.c,v 1.26 2009/03/22 15:01:22 tg Exp $");
a189 4
/* from muxclient.c */
void muxclient(const char *);
void muxserver_listen(void);

d196 2
a197 2
	int i, opt, exit_status, use_syslog;
	char *p, *cp, *line, *argv0, buf[256];
d598 1
a598 1
		snprintf(buf, sizeof buf, "%.100s/%.100s", pw->pw_dir,
d600 2
a601 1
		(void)read_config_file(buf, host, &options, 1);
d747 1
a747 1
	snprintf(buf, sizeof buf, "%.100s%s%.100s", pw->pw_dir,
d749 1
a749 1
	if (stat(buf, &st) < 0)
d814 2
a815 1
ssh_confirm_remote_forward(int type, u_int32_t seq, void *ctxt)
d929 1
a929 1
	char *cp;
d1085 1
a1085 1
ssh_session2_setup(int id, void *arg)
@


1.26
log
@merge and tweak ciphers and MACs
@
text
@d98 1
a98 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh.c,v 1.25 2008/12/16 22:13:31 tg Exp $");
d137 1
a137 1
 * command line, or the HostName specified for the user-supplied name in a
@


1.25
log
@really merge OpenSSH-current into MirBSD Secure SHell 10uA4
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.322 2008/11/01 17:40:33 stevesk Exp $ */
d98 1
a98 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh.c,v 1.24 2008/12/16 20:55:30 tg Exp $");
d200 1
a200 1
	char *p, *cp, *line, buf[256];
d259 1
d429 1
a429 1
			if (options.port == 0) {
d439 1
a439 1
			if (parse_forward(&fwd, optarg, 0))
d450 1
a450 1
			if (parse_forward(&fwd, optarg, 0)) {
d461 1
a461 1
			if (parse_forward(&fwd, optarg, 1)) {
d588 1
a588 1
	log_init(av[0],
d616 1
a616 1
	log_init(av[0], options.log_level, SYSLOG_FACILITY_USER, !use_syslog);
d820 1
d824 6
@


1.24
log
@fastmerge, do not use yet!
@
text
@d44 1
a49 2
#include <sys/types.h>
#include <sys/time.h>
d98 1
a98 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh.c,v 1.23 2008/03/02 21:14:23 tg Exp $");
@


1.23
log
@merge’n’fix
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.309 2008/01/19 20:51:26 djm Exp $ */
d44 2
a45 1
#include <sys/time.h>
a46 1
#include <sys/ioctl.h>
a47 1
#include <sys/un.h>
d49 2
a91 1
#include "monitor_fdpass.h"
d99 1
a99 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh.c,v 1.22 2007/09/13 13:52:55 tg Exp $");
d103 1
a103 1
/* Flag indicating whether debug mode is on.  This can be set on the command line. */
d160 1
a160 1
static int client_global_request_id = 0;
d165 3
a167 2
/* fd to control socket */
int control_fd = -1;
a168 6
/* Multiplexing control command */
static u_int mux_command = 0;

/* Only used in control client mode */
volatile sig_atomic_t control_client_terminate = 0;
u_int control_server_pid = 0;
d176 1
a176 1
"usage: ssh [-1246AaCfgMNnqsTtVvXxY] [-b bind_address] [-c cipher_spec]\n"
d189 4
a192 1
static void control_client(const char *path);
d200 1
a200 1
	int i, opt, exit_status;
d251 4
a254 1
	/* Initialize option structure to indicate that no values have been set. */
d259 1
d262 2
a263 2
	while ((opt = getopt(ac, av,
	    "1246ab:c:e:fghi:kl:m:no:p:qstvxACD:F:I:KL:MNO:PR:S:TVw:XY")) != -1) {
d290 3
d302 1
a302 1
				mux_command = SSHMUX_COMMAND_ALIVE_CHECK;
d304 1
a304 1
				mux_command = SSHMUX_COMMAND_TERMINATE;
d367 2
a368 1
				fprintf(stderr, "Bad tun device '%s'\n", optarg);
d439 1
a439 1
			if (parse_forward(&fwd, optarg))
d450 1
a450 1
			if (parse_forward(&fwd, optarg)) {
d461 2
a462 11
			cp = p = xstrdup(optarg);
			memset(&fwd, '\0', sizeof(fwd));
			fwd.connect_host = (char *)"socks";
			if ((fwd.listen_host = hpdelim(&cp)) == NULL) {
				fprintf(stderr, "Bad dynamic forwarding "
				    "specification '%.100s'\n", optarg);
				exit(255);
			}
			if (cp != NULL) {
				fwd.listen_port = a2port(cp);
				fwd.listen_host = cleanhostname(fwd.listen_host);
d464 3
a466 7
				fwd.listen_port = a2port(fwd.listen_host);
				fwd.listen_host = NULL;
			}

			if (fwd.listen_port == 0) {
				fprintf(stderr, "Bad dynamic port '%s'\n",
				    optarg);
a468 2
			add_local_forward(&options, &fwd);
			xfree(p);
d564 4
a567 2
	if (fork_after_authentication_flag && buffer_len(&command) == 0 && !no_shell_flag)
		fatal("Cannot fork into background without a command to execute.");
d579 2
a580 1
			logit("Pseudo-terminal will not be allocated because stdin is not a terminal.");
d588 3
a590 2
	log_init(av[0], options.log_level == -1 ? SYSLOG_LEVEL_INFO : options.log_level,
	    SYSLOG_FACILITY_USER, 1);
d616 1
a616 1
	log_init(av[0], options.log_level, SYSLOG_FACILITY_USER, 1);
d621 22
a652 6
	/* Get default port if port has not been set. */
	if (options.port == 0) {
		sp = getservbyname(SSH_SERVICE_NAME, "tcp");
		options.port = sp ? ntohs(sp->s_port) : SSH_DEFAULT_PORT;
	}

d677 1
a677 1
	if (mux_command != 0 && options.control_path == NULL)
d680 1
a680 1
		control_client(options.control_path);
d749 2
a750 1
	snprintf(buf, sizeof buf, "%.100s%s%.100s", pw->pw_dir, strcmp(pw->pw_dir, "/") ? "/" : "", _PATH_SSH_USER_DIR);
d771 1
a771 1
	/* Log into the remote system.  This never returns if the login fails. */
d801 1
a801 1
	if (options.control_path != NULL && control_fd != -1)
d814 28
d890 2
d928 2
a929 1
		debug("Requesting compression at level %d.", options.compression_level);
d931 4
a934 2
		if (options.compression_level < 1 || options.compression_level > 9)
			fatal("Compression level must be from 1 (fast) to 9 (slow, best).");
d947 2
a948 1
			packet_disconnect("Protocol error waiting for compression response.");
d985 2
a986 1
			logit("Warning: Remote host failed or refused to allocate a pseudo tty.");
d988 2
a989 1
			packet_disconnect("Protocol error waiting for pty request response.");
d999 2
a1000 1
		debug("Requesting X11 forwarding with authentication spoofing.");
d1010 2
a1011 1
			packet_disconnect("Protocol error waiting for X11 forwarding");
d1039 8
a1046 2
	/* If requested, let ssh continue in the background. */
	if (fork_after_authentication_flag)
d1049 1
d1059 2
a1060 1
		debug("Sending command: %.*s", len, (u_char *)buffer_ptr(&command));
a1076 81
static void
ssh_subsystem_reply(int type, u_int32_t seq, void *ctxt)
{
	int id, len;

	id = packet_get_int();
	len = buffer_len(&command);
	if (len > 900)
		len = 900;
	packet_check_eom();
	if (type == SSH2_MSG_CHANNEL_FAILURE)
		fatal("Request for subsystem '%.*s' failed on channel %d",
		    len, (u_char *)buffer_ptr(&command), id);
}

void
client_global_request_reply_fwd(int type, u_int32_t seq, void *ctxt)
{
	int i;

	i = client_global_request_id++;
	if (i >= options.num_remote_forwards)
		return;
	debug("remote forward %s for: listen %d, connect %s:%d",
	    type == SSH2_MSG_REQUEST_SUCCESS ? "success" : "failure",
	    options.remote_forwards[i].listen_port,
	    options.remote_forwards[i].connect_host,
	    options.remote_forwards[i].connect_port);
	if (type == SSH2_MSG_REQUEST_FAILURE) {
		if (options.exit_on_forward_failure)
			fatal("Error: remote port forwarding failed for "
			    "listen port %d",
			    options.remote_forwards[i].listen_port);
		else
			logit("Warning: remote port forwarding failed for "
			    "listen port %d",
			    options.remote_forwards[i].listen_port);
	}
}

static void
ssh_control_listener(void)
{
	struct sockaddr_un addr;
	mode_t old_umask;

	if (options.control_path == NULL ||
	    options.control_master == SSHCTL_MASTER_NO)
		return;

	debug("setting up multiplex master socket");

	memset(&addr, '\0', sizeof(addr));
	addr.sun_family = AF_UNIX;
	addr.sun_len = offsetof(struct sockaddr_un, sun_path) +
	    strlen(options.control_path) + 1;

	if (strlcpy(addr.sun_path, options.control_path,
	    sizeof(addr.sun_path)) >= sizeof(addr.sun_path))
		fatal("ControlPath too long");

	if ((control_fd = socket(PF_UNIX, SOCK_STREAM, 0)) < 0)
		fatal("%s socket(): %s", __func__, strerror(errno));

	old_umask = umask(0177);
	if (bind(control_fd, (struct sockaddr *)&addr, addr.sun_len) == -1) {
		control_fd = -1;
		if (errno == EINVAL || errno == EADDRINUSE)
			fatal("ControlSocket %s already exists",
			    options.control_path);
		else
			fatal("%s bind(): %s", __func__, strerror(errno));
	}
	umask(old_umask);

	if (listen(control_fd, 64) == -1)
		fatal("%s listen(): %s", __func__, strerror(errno));

	set_nonblock(control_fd);
}

d1092 2
a1093 1
		debug("Requesting X11 forwarding with authentication spoofing.");
d1107 1
a1107 1
	    NULL, fileno(stdin), &command, environ, &ssh_subsystem_reply);
d1153 2
a1154 1
		channel_register_confirm(c->self, ssh_session2_setup, NULL);
d1170 10
d1186 1
a1186 1
	ssh_control_listener();
d1189 2
a1190 1
	if (fork_after_authentication_flag)
d1193 1
d1216 2
a1217 1
			memmove(&options.identity_files[1], &options.identity_files[0],
d1219 2
a1220 1
			memmove(&options.identity_keys[1], &options.identity_keys[0],
a1257 234

static void
control_client_sighandler(int signo)
{
	control_client_terminate = signo;
}

static void
control_client_sigrelay(int signo)
{
	int save_errno = errno;

	if (control_server_pid > 1)
		kill(control_server_pid, signo);

	errno = save_errno;
}

static int
env_permitted(char *env)
{
	int i, ret;
	char name[1024], *cp;

	if ((cp = strchr(env, '=')) == NULL || cp == env)
		return (0);
	ret = snprintf(name, sizeof(name), "%.*s", (int)(cp - env), env);
	if (ret <= 0 || (size_t)ret >= sizeof(name))
		fatal("env_permitted: name '%.100s...' too long", env);

	for (i = 0; i < options.num_send_env; i++)
		if (match_pattern(name, options.send_env[i]))
			return (1);

	return (0);
}

static void
control_client(const char *path)
{
	struct sockaddr_un addr;
	int i, r, fd, sock, exitval[2], num_env;
	Buffer m;
	char *term;
	extern char **environ;
	u_int  flags;

	if (mux_command == 0)
		mux_command = SSHMUX_COMMAND_OPEN;

	switch (options.control_master) {
	case SSHCTL_MASTER_AUTO:
	case SSHCTL_MASTER_AUTO_ASK:
		debug("auto-mux: Trying existing master");
		/* FALLTHROUGH */
	case SSHCTL_MASTER_NO:
		break;
	default:
		return;
	}

	memset(&addr, '\0', sizeof(addr));
	addr.sun_family = AF_UNIX;
	addr.sun_len = offsetof(struct sockaddr_un, sun_path) +
	    strlen(path) + 1;

	if (strlcpy(addr.sun_path, path,
	    sizeof(addr.sun_path)) >= sizeof(addr.sun_path))
		fatal("ControlPath too long");

	if ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) < 0)
		fatal("%s socket(): %s", __func__, strerror(errno));

	if (connect(sock, (struct sockaddr *)&addr, addr.sun_len) == -1) {
		if (mux_command != SSHMUX_COMMAND_OPEN) {
			fatal("Control socket connect(%.100s): %s", path,
			    strerror(errno));
		}
		if (errno == ENOENT)
			debug("Control socket \"%.100s\" does not exist", path);
		else {
			error("Control socket connect(%.100s): %s", path,
			    strerror(errno));
		}
		close(sock);
		return;
	}

	if (stdin_null_flag) {
		if ((fd = open(_PATH_DEVNULL, O_RDONLY)) == -1)
			fatal("open(/dev/null): %s", strerror(errno));
		if (dup2(fd, STDIN_FILENO) == -1)
			fatal("dup2: %s", strerror(errno));
		if (fd > STDERR_FILENO)
			close(fd);
	}

	term = getenv("TERM");

	flags = 0;
	if (tty_flag)
		flags |= SSHMUX_FLAG_TTY;
	if (subsystem_flag)
		flags |= SSHMUX_FLAG_SUBSYS;
	if (options.forward_x11)
		flags |= SSHMUX_FLAG_X11_FWD;
	if (options.forward_agent)
		flags |= SSHMUX_FLAG_AGENT_FWD;

	signal(SIGPIPE, SIG_IGN);

	buffer_init(&m);

	/* Send our command to server */
	buffer_put_int(&m, mux_command);
	buffer_put_int(&m, flags);
	if (ssh_msg_send(sock, SSHMUX_VER, &m) == -1)
		fatal("%s: msg_send", __func__);
	buffer_clear(&m);

	/* Get authorisation status and PID of controlee */
	if (ssh_msg_recv(sock, &m) == -1)
		fatal("%s: msg_recv", __func__);
	if (buffer_get_char(&m) != SSHMUX_VER)
		fatal("%s: wrong version", __func__);
	if (buffer_get_int(&m) != 1)
		fatal("Connection to master denied");
	control_server_pid = buffer_get_int(&m);

	buffer_clear(&m);

	switch (mux_command) {
	case SSHMUX_COMMAND_ALIVE_CHECK:
		fprintf(stderr, "Master running (pid=%d)\r\n",
		    control_server_pid);
		exit(0);
	case SSHMUX_COMMAND_TERMINATE:
		fprintf(stderr, "Exit request sent.\r\n");
		exit(0);
	case SSHMUX_COMMAND_OPEN:
		/* continue below */
		break;
	default:
		fatal("silly mux_command %d", mux_command);
	}

	/* SSHMUX_COMMAND_OPEN */
	buffer_put_cstring(&m, term ? term : "");
	buffer_append(&command, "\0", 1);
	buffer_put_cstring(&m, buffer_ptr(&command));

	if (options.num_send_env == 0 || environ == NULL) {
		buffer_put_int(&m, 0);
	} else {
		/* Pass environment */
		num_env = 0;
		for (i = 0; environ[i] != NULL; i++)
			if (env_permitted(environ[i]))
				num_env++; /* Count */

		buffer_put_int(&m, num_env);

		for (i = 0; environ[i] != NULL && num_env >= 0; i++)
			if (env_permitted(environ[i])) {
				num_env--;
				buffer_put_cstring(&m, environ[i]);
			}
	}

	if (ssh_msg_send(sock, SSHMUX_VER, &m) == -1)
		fatal("%s: msg_send", __func__);

	if (mm_send_fd(sock, STDIN_FILENO) == -1 ||
	    mm_send_fd(sock, STDOUT_FILENO) == -1 ||
	    mm_send_fd(sock, STDERR_FILENO) == -1)
		fatal("%s: send fds failed", __func__);

	/* Wait for reply, so master has a chance to gather ttymodes */
	buffer_clear(&m);
	if (ssh_msg_recv(sock, &m) == -1)
		fatal("%s: msg_recv", __func__);
	if (buffer_get_char(&m) != SSHMUX_VER)
		fatal("%s: wrong version", __func__);
	buffer_free(&m);

	signal(SIGHUP, control_client_sighandler);
	signal(SIGINT, control_client_sighandler);
	signal(SIGTERM, control_client_sighandler);
	signal(SIGWINCH, control_client_sigrelay);

	if (tty_flag)
		enter_raw_mode();

	/*
	 * Stick around until the controlee closes the client_fd.
	 * Before it does, it is expected to write this process' exit
	 * value (one int). This process must read the value and wait for
	 * the closure of the client_fd; if this one closes early, the 
	 * multiplex master will terminate early too (possibly losing data).
	 */
	exitval[0] = 0;
	for (i = 0; !control_client_terminate && i < (int)sizeof(exitval);) {
		r = read(sock, (char *)exitval + i, sizeof(exitval) - i);
		if (r == 0) {
			debug2("Received EOF from master");
			break;
		}
		if (r == -1) {
			if (errno == EINTR)
				continue;
			fatal("%s: read %s", __func__, strerror(errno));
		}
		i += r;
	}

	close(sock);
	leave_raw_mode();
	if (i > (int)sizeof(int))
		fatal("%s: master returned too much data (%d > %zu)",
		    __func__, i, sizeof(int));
	if (control_client_terminate) {
		debug2("Exiting on signal %d", control_client_terminate);
		exitval[0] = 255;
	} else if (i < (int)sizeof(int)) {
		debug2("Control master terminated unexpectedly");
		exitval[0] = 255;
	} else
		debug2("Received exit status from master %d", exitval[0]);

	if (tty_flag && options.log_level != SYSLOG_LEVEL_QUIET)
		fprintf(stderr, "Shared connection to %s master closed.\r\n", host);

	exit(exitval[0]);
}
@


1.22
log
@merge and make UMAC-64 default message integrity whatever
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.303 2007/09/04 11:15:55 djm Exp $ */
d99 1
a99 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh.c,v 1.21 2007/08/20 12:11:30 tg Exp $");
d643 2
a644 1
	    strcmp(options.proxy_command, "none") == 0)
d646 1
d648 2
a649 1
	    strcmp(options.control_path, "none") == 0)
d651 1
d661 1
d984 5
d1212 1
d1241 2
d1249 2
a1250 2
		filename = percent_expand(cp, "d", pw->pw_dir,
		    "u", pw->pw_name, "l", thishost, "h", host,
d1260 4
d1275 2
d1279 2
d1374 2
@


1.21
log
@MirBSD SecureShell 4.7/#10semel
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.301 2007/08/07 07:32:53 djm Exp $ */
d99 1
a99 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh.c,v 1.20 2007/08/08 19:09:49 tg Exp $");
d206 1
a206 1
	int dummy;
d666 2
d670 2
a671 1
	    options.address_family, options.connection_attempts,
d676 3
d755 2
a756 1
	ssh_login(&sensitive_data, host, (struct sockaddr *)&hostaddr, pw);
d1414 4
a1417 3
	mm_send_fd(sock, STDIN_FILENO);
	mm_send_fd(sock, STDOUT_FILENO);
	mm_send_fd(sock, STDERR_FILENO);
@


1.20
log
@more format strings: usr.bin and usr.sbin/[a..timed]
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.300 2007/06/14 22:48:05 djm Exp $ */
d99 1
a99 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh.c,v 1.19 2007/07/07 22:46:27 tg Exp $");
d839 11
a1110 22
	if (options.tun_open != SSH_TUNMODE_NO) {
		Channel *c;
		int fd;

		debug("Requesting tun.");
		if ((fd = tun_open(options.tun_local,
		    options.tun_open)) >= 0) {
			c = channel_new("tun", SSH_CHANNEL_OPENING, fd, fd, -1,
			    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,
			    0, "tun", 1);
			c->datagram = 1;
			packet_start(SSH2_MSG_CHANNEL_OPEN);
			packet_put_cstring("tun@@openssh.com");
			packet_put_int(c->self);
			packet_put_int(c->local_window_max);
			packet_put_int(c->local_maxpacket);
			packet_put_int(options.tun_open);
			packet_put_int(options.tun_remote);
			packet_send();
		}
	}

a1169 1
	ssh_control_listener();
d1179 3
@


1.19
log
@improve textual message
@
text
@d99 1
a99 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh.c,v 1.18 2007/06/16 15:41:52 tg Exp $");
d1461 1
a1461 1
		fatal("%s: master returned too much data (%d > %lu)",
@


1.18
log
@sync’n’bump
@
text
@d99 1
a99 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh.c,v 1.17 2007/01/25 16:18:38 tg Exp $");
d1473 1
a1473 1
		fprintf(stderr, "Shared connection to %s closed.\r\n", host);
@


1.17
log
@automerge, bump vsn
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.295 2007/01/03 03:01:40 stevesk Exp $ */
d99 1
a99 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh.c,v 1.16 2006/10/13 18:40:51 tg Exp $");
d261 1
a261 1
	    "1246ab:c:e:fghi:kl:m:no:p:qstvxACD:F:I:L:MNO:PR:S:TVw:XY")) != -1) {
d313 2
a314 1
			break;		/* compatibility to OpenBSD */
d1287 1
a1287 1
	int i, r, fd, sock, exitval, num_env;
d1436 10
a1445 4
	/* Stick around until the controlee closes the client_fd */
	exitval = 0;
	for (;!control_client_terminate;) {
		r = read(sock, &exitval, sizeof(exitval));
d1450 3
a1452 3
		if (r > 0)
			debug2("Received exit status from master %d", exitval);
		if (r == -1 && errno != EINTR)
d1454 2
a1457 3
	if (control_client_terminate)
		debug2("Exiting on signal %d", control_client_terminate);

a1458 1

d1460 11
d1473 1
a1473 1
		fprintf(stderr, "Connection to master closed.\r\n");
d1475 1
a1475 1
	exit(exitval);
@


1.16
log
@merge the 4.0 equivalent of 015_ssh.patch
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.294 2006/10/06 02:29:19 djm Exp $ */
d99 1
a99 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh.c,v 1.15 2006/09/20 21:41:06 tg Exp $");
d604 1
a604 1
	} else  {
@


1.15
log
@finish merging
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.293 2006/08/03 03:34:42 deraadt Exp $ */
d99 1
a99 1
__RCSID("$MirOS$");
@


1.14
log
@when we got rid of the -c option to rdate(8) because of improved
leap second support code, bsiegert@@ and some OpenBSD guy told me
to better still accept but silently ignore that option.

so, and since scp(1) and sftp(1) don't require any option to not
enable IPTOS_LOWDELAY any more, handle ssh(1) -h the same. thus,
this commit can go into #9-stable (i.e., here).
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.276 2006/04/25 08:02:27 dtucker Exp $ */
d43 2
a44 3
#include "includes.h"
__RCSID("$MirOS: src/usr.bin/ssh/ssh.c,v 1.13 2006/08/12 13:57:11 tg Exp $");

d47 1
d52 3
d56 1
d58 5
d67 1
a72 1
#include "xmalloc.h"
a74 1
#include "bufaux.h"
d93 1
d99 2
d186 1
a186 1
"           [-w tunnel:tunnel] [user@@]hostname [command]\n"
d812 2
d826 1
a826 1
		channel_request_remote_forwarding(
d830 7
a836 1
		    options.remote_forwards[i].connect_port);
d1018 10
a1027 3
	if (type == SSH2_MSG_REQUEST_FAILURE)
		logit("Warning: remote port forwarding failed for listen "
		    "port %d", options.remote_forwards[i].listen_port);
d1211 1
a1211 1
	    (keys = sc_get_keys(options.smartcard_device, NULL)) != NULL ) {
d1238 1
a1238 1
		    "u", pw->pw_name, "l", thishost, "h", host, 
d1266 1
a1266 1
	int i;
d1269 1
a1269 3
	if (strlcpy(name, env, sizeof(name)) >= sizeof(name))
		fatal("env_permitted: name too long");
	if ((cp = strchr(name, '=')) == NULL)
d1271 3
a1273 2

	*cp = '\0';
@


1.13
log
@* readconf.h, ssh.c: move support code for 'ssh -h' into ssh.c entirely
* ssh.c: deprecate -h (big warning)
* ssh.1, ssh.c: don't document -h, -k
@
text
@d44 1
a44 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh.c,v 1.12 2006/06/02 20:50:51 tg Exp $");
a98 1
int no_lowdelay = 0;
d302 1
a302 1
			break;
d501 1
a501 5
			fprintf(stderr,
			    "The -h option is deprecated and will be removed.\n"
			    "Use -T for IPTOS_THROUGHPUT instead.\n");
			no_lowdelay = 1;
			break;
d872 1
a872 1
			cp = (char *)"";
d922 1
a922 1
	packet_set_interactive(no_lowdelay ? 0 : interactive);
d1098 1
a1098 1
	packet_set_interactive(no_lowdelay ? 0 : interactive);
@


1.12
log
@* merge
* remove all references to GSSAPI, Kerberos and AFS
* uint*_t -> u_int*_t for consistency, like openbsd
  (note: MirOS style(9) suggests uint32_t etc. instead!)
* bump vsn
@
text
@d44 1
a44 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh.c,v 1.11 2006/04/19 10:40:55 tg Exp $");
d99 1
d171 1
a171 1
"usage: ssh [-1246AaCfghkMNnqsTtVvXxY] [-b bind_address] [-c cipher_spec]\n"
d502 4
a505 1
			options.no_lowdelay = 1;
d927 1
a927 2
	if (!options.no_lowdelay)
		packet_set_interactive(interactive);
d1103 1
a1103 2
	if (!options.no_lowdelay)
		packet_set_interactive(interactive);
@


1.11
log
@merge and clean up
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.275 2006/03/30 10:41:25 djm Exp $ */
d44 1
a44 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh.c,v 1.10 2006/02/22 02:16:49 tg Exp $");
d681 1
a681 1
		    _PATH_HOST_KEY_FILE, "", NULL);
d683 1
a683 1
		    _PATH_HOST_DSA_KEY_FILE, "", NULL);
d685 1
a685 1
		    _PATH_HOST_RSA_KEY_FILE, "", NULL);
@


1.10
log
@fix a lot of and kludge a few more __CRAZY problems, sync rcs id
@
text
@d1 1
d44 1
a44 1
RCSID("$MirOS: src/usr.bin/ssh/ssh.c,v 1.9 2006/02/22 01:23:52 tg Exp $");
d51 1
d248 1
a248 1
again:
d622 1
a622 1
				*p = tolower(*p);
d639 1
a639 1
		char me[NI_MAXHOST];
d641 1
a641 1
		if (gethostname(me, sizeof(me)) == -1)
d647 1
a647 1
		    "r", options.user, "l", me, (char *)NULL);
d676 1
a676 1
		sensitive_data.keys = xmalloc(sensitive_data.nkeys *
d879 4
a882 4
		packet_put_int(ws.ws_row);
		packet_put_int(ws.ws_col);
		packet_put_int(ws.ws_xpixel);
		packet_put_int(ws.ws_ypixel);
d1031 1
a1031 1
	if (bind(control_fd, (struct sockaddr*)&addr, addr.sun_len) == -1) {
d1179 1
a1179 1
	char *filename;
d1182 1
d1206 5
d1212 1
a1212 1
		filename = tilde_expand_filename(options.identity_files[i],
d1214 4
d1246 2
a1247 1
	strlcpy(name, env, sizeof(name));
d1296 1
a1296 1
	if (connect(sock, (struct sockaddr*)&addr, addr.sun_len) == -1) {
d1302 1
a1302 1
	 		debug("Control socket \"%.100s\" does not exist", path);
d1304 1
a1304 1
	 		error("Control socket connect(%.100s): %s", path,
d1307 12
a1318 12
 		close(sock);
 		return;
 	}

 	if (stdin_null_flag) {
 		if ((fd = open(_PATH_DEVNULL, O_RDONLY)) == -1)
 			fatal("open(/dev/null): %s", strerror(errno));
 		if (dup2(fd, STDIN_FILENO) == -1)
 			fatal("dup2: %s", strerror(errno));
 		if (fd > STDERR_FILENO)
 			close(fd);
 	}
@


1.9
log
@merge; bump version; fix up manpages and includes a little
@
text
@d43 1
a43 1
RCSID("$MirOS: src/usr.bin/ssh/ssh.c,v 1.8 2005/12/20 19:57:37 tg Exp $");
d164 1
a164 1
static void
a193 2
	extern int optind, optreset;
	extern char *optarg;
d389 1
a389 1
					options.ciphers = (char *)-1;
d443 1
a443 1
			fwd.connect_host = "socks";
d871 1
a871 1
			cp = "";
@


1.8
log
@fastmerge, bump version
@
text
@d43 9
a51 1
RCSID("$MirOS: src/usr.bin/ssh/ssh.c,v 1.7 2005/11/23 19:45:15 tg Exp $");
d639 4
d647 1
a647 1
		    "r", options.user, (char *)NULL);
@


1.7
log
@merge
@
text
@d43 1
a43 1
RCSID("$MirOS: src/usr.bin/ssh/ssh.c,v 1.6 2005/11/23 18:04:21 tg Exp $");
d159 9
a167 48
	fprintf(stderr, "Usage: %s [options] host [command]\n", __progname);
	fprintf(stderr, "Options:\n");
	fprintf(stderr, "  -l user     Log in using this user name.\n");
	fprintf(stderr, "  -n          Redirect input from " _PATH_DEVNULL ".\n");
	fprintf(stderr, "  -F config   Config file (default: ~/%s).\n",
	     _PATH_SSH_USER_CONFFILE);
	fprintf(stderr, "  -A          Enable authentication agent forwarding.\n");
	fprintf(stderr, "  -a          Disable authentication agent forwarding (default).\n");
	fprintf(stderr, "  -X          Enable X11 connection forwarding.\n");
	fprintf(stderr, "  -Y          Enable trusted X11 connection forwarding.\n");
	fprintf(stderr, "  -x          Disable X11 connection forwarding (default).\n");
	fprintf(stderr, "  -i file     Identity for public key authentication "
	    "(default: ~/.etc/ssh/identity)\n");
#ifdef SMARTCARD
	fprintf(stderr, "  -I reader   Set smartcard reader.\n");
#endif
	fprintf(stderr, "  -t          Tty; allocate a tty even if command is given.\n");
	fprintf(stderr, "  -T          Do not allocate a tty.\n");
	fprintf(stderr, "  -v          Verbose; display verbose debugging messages.\n");
	fprintf(stderr, "              Multiple -v increases verbosity.\n");
	fprintf(stderr, "  -V          Display version number only.\n");
	fprintf(stderr, "  -q          Quiet; don't display any warning messages.\n");
	fprintf(stderr, "  -f          Fork into background after authentication.\n");
	fprintf(stderr, "  -e char     Set escape character; ``none'' = disable (default: ~).\n");

	fprintf(stderr, "  -c cipher   Select encryption algorithm\n");
	fprintf(stderr, "  -m macs     Specify MAC algorithms for protocol version 2.\n");
	fprintf(stderr, "  -p port     Connect to this port.  Server must be on the same port.\n");
	fprintf(stderr, "  -L [bind_address:]listen-port:host:port   Forward loc. port to rem. addr.\n");
	fprintf(stderr, "  -R [bind_address:]listen-port:host:port   Forward rem. port to loc. addr.\n");
	fprintf(stderr, "              These cause %s to listen for connections on a port, and\n", __progname);
	fprintf(stderr, "              forward them to the other side by connecting to host:port.\n");
	fprintf(stderr, "  -D [bind_address:]port   Dynamic application-level port forwarding.\n");
	fprintf(stderr, "  -C          Enable compression.\n");
	fprintf(stderr, "  -N          Do not execute a shell or command.\n");
	fprintf(stderr, "  -g          Allow remote hosts to connect to forwarded ports.\n");
	fprintf(stderr, "  -1          Force protocol version 1.\n");
	fprintf(stderr, "  -2          Force protocol version 2.\n");
	fprintf(stderr, "  -4          Use IPv4 only.\n");
	fprintf(stderr, "  -6          Use IPv6 only.\n");
	fprintf(stderr, "  -o 'option' Process the option as if it was read from a configuration file.\n");
	fprintf(stderr, "  -s          Invoke command (mandatory) as SSH2 subsystem.\n");
	fprintf(stderr, "  -b addr     Local IP address.\n");
	fprintf(stderr, "  -h          Disable lowdelay TOS type, e.g. for rsync.\n");
	fprintf(stderr, "  -M          Enable session multiplexing master mode.\n");
	fprintf(stderr, "  -S ctl_path Use ctl_path as socket for session multiplexing.\n");
	fprintf(stderr, "  -O ctl_cmd  Pass command to multiplex session master.\n");
	exit(1);
d221 1
a221 1
		exit(1);
d242 1
a242 1
	    "1246ab:c:e:fghi:kl:m:no:p:qstvxACD:F:I:L:MNO:PR:S:TVXY")) != -1) {
d337 9
d361 1
a361 1
				exit(1);
d376 1
a376 1
					exit(1);
d392 1
a392 1
				exit(1);
d405 1
a405 1
				exit(1);
d419 1
a419 1
				exit(1);
d430 1
a430 1
				exit(1);
d441 1
a441 1
				exit(1);
d454 1
a454 1
				exit(1);
d475 1
a475 1
				exit(1);
d648 1
a648 1
		exit(1);
d1063 22
d1150 5
@


1.6
log
@fastmerge remainder of src/usr.bin
@
text
@d43 1
a43 1
RCSID("$MirOS: src/usr.bin/ssh/ssh.c,v 1.5 2005/06/22 16:11:39 tg Exp $");
d191 1
a191 1
	fprintf(stderr, "  -D port     Enable dynamic application-level port forwarding.\n");
d230 3
d478 1
a478 1
				fwd.listen_host = "";
d731 1
a731 1
	 * directory if it doesn\'t already exist.
d828 1
a828 2
		    (options.gateway_ports ? "*" : "LOCALHOST") :
		    options.remote_forwards[i].listen_host,
d844 1
a844 1
		/* Clear agent forwarding if we don\'t have an agent. */
d1046 1
a1046 1
		fatal("%s socket(): %s\n", __func__, strerror(errno));
d1055 1
a1055 1
			fatal("%s bind(): %s\n", __func__, strerror(errno));
d1060 1
a1060 1
		fatal("%s listen(): %s\n", __func__, strerror(errno));
@


1.5
log
@merge
@
text
@d43 1
a43 1
RCSID("$MirOS: src/usr.bin/ssh/ssh.c,v 1.4 2005/04/26 15:21:50 tg Exp $");
d644 6
a669 6
	/* Get default port if port has not been set. */
	if (options.port == 0) {
		sp = getservbyname(SSH_SERVICE_NAME, "tcp");
		options.port = sp ? ntohs(sp->s_port) : SSH_DEFAULT_PORT;
	}

d824 2
a825 2
		    (options.remote_forwards[i].listen_host == NULL) ? 
		    (options.gateway_ports ? "*" : "LOCALHOST") : 
d1071 1
a1071 1
	display = getenv("DISPLAY");	
d1288 1
a1288 1
 
d1297 2
a1298 3
  
	if ((term = getenv("TERM")) == NULL)
		term = "";
d1305 4
d1315 1
a1315 1
	if (ssh_msg_send(sock, /* version */1, &m) == -1)
d1322 1
a1322 1
	if (buffer_get_char(&m) != 1)
d1346 1
a1346 1
	buffer_put_cstring(&m, term);
d1368 1
a1368 1
	if (ssh_msg_send(sock, /* version */1, &m) == -1)
d1379 1
a1379 1
	if (buffer_get_char(&m) != 1)
@


1.4
log
@* merge
* standardise on british spelling
* bump version
@
text
@d43 1
a43 1
RCSID("$MirOS: src/usr.bin/ssh/ssh.c,v 1.3 2005/04/14 19:49:35 tg Exp $");
d148 1
a148 1
static u_int mux_command = SSHMUX_COMMAND_OPEN;
d227 1
d423 4
a426 2
			options.control_master =
			    (options.control_master >= 1) ? 2 : 1;
d647 3
d652 16
a667 2
		options.control_path = tilde_expand_filename(
		   options.control_path, original_real_uid);
a668 2
	if (options.control_path != NULL && options.control_master == 0)
		control_client(options.control_path);
a793 104
#define SSH_X11_PROTO "MIT-MAGIC-COOKIE-1"

static void
x11_get_proto(char **_proto, char **_data)
{
	char cmd[1024];
	char line[512];
	char xdisplay[512];
	static char proto[512], data[512];
	FILE *f;
	int got_data = 0, generated = 0, do_unlink = 0, i;
	char *display, *xauthdir, *xauthfile;
	struct stat st;

	xauthdir = xauthfile = NULL;
	*_proto = proto;
	*_data = data;
	proto[0] = data[0] = '\0';

	if (!options.xauth_location ||
	    (stat(options.xauth_location, &st) == -1)) {
		debug("No xauth program.");
	} else {
		if ((display = getenv("DISPLAY")) == NULL) {
			debug("x11_get_proto: DISPLAY not set");
			return;
		}
		/*
		 * Handle FamilyLocal case where $DISPLAY does
		 * not match an authorization entry.  For this we
		 * just try "xauth list unix:displaynum.screennum".
		 * XXX: "localhost" match to determine FamilyLocal
		 *      is not perfect.
		 */
		if (strncmp(display, "localhost:", 10) == 0) {
			snprintf(xdisplay, sizeof(xdisplay), "unix:%s",
			    display + 10);
			display = xdisplay;
		}
		if (options.forward_x11_trusted == 0) {
			xauthdir = xmalloc(MAXPATHLEN);
			xauthfile = xmalloc(MAXPATHLEN);
			strlcpy(xauthdir, "/tmp/ssh-XXXXXXXXXX", MAXPATHLEN);
			if (mkdtemp(xauthdir) != NULL) {
				do_unlink = 1;
				snprintf(xauthfile, MAXPATHLEN, "%s/xauthfile",
				    xauthdir);
				snprintf(cmd, sizeof(cmd),
				    "%s -f %s generate %s " SSH_X11_PROTO
				    " untrusted timeout 1200 2>" _PATH_DEVNULL,
				    options.xauth_location, xauthfile, display);
				debug2("x11_get_proto: %s", cmd);
				if (system(cmd) == 0)
					generated = 1;
			}
		}
		snprintf(cmd, sizeof(cmd),
		    "%s %s%s list %s . 2>" _PATH_DEVNULL,
		    options.xauth_location,
		    generated ? "-f " : "" ,
		    generated ? xauthfile : "",
		    display);
		debug2("x11_get_proto: %s", cmd);
		f = popen(cmd, "r");
		if (f && fgets(line, sizeof(line), f) &&
		    sscanf(line, "%*s %511s %511s", proto, data) == 2)
			got_data = 1;
		if (f)
			pclose(f);
	}

	if (do_unlink) {
		unlink(xauthfile);
		rmdir(xauthdir);
	}
	if (xauthdir)
		xfree(xauthdir);
	if (xauthfile)
		xfree(xauthfile);

	/*
	 * If we didn't get authentication data, just make up some
	 * data.  The forwarding code will check the validity of the
	 * response anyway, and substitute this data.  The X11
	 * server, however, will ignore this fake data and use
	 * whatever authentication mechanisms it was using otherwise
	 * for the local connection.
	 */
	if (!got_data) {
		u_int32_t rnd = 0;

		logit("Warning: No xauth data; "
		    "using fake authentication data for X11 forwarding.");
		strlcpy(proto, SSH_X11_PROTO, sizeof proto);
		for (i = 0; i < 16; i++) {
			if (i % 4 == 0)
				rnd = arc4random();
			snprintf(data + 2 * i, sizeof data - 2 * i, "%02x",
			    rnd & 0xff);
			rnd >>= 8;
		}
	}
}

d856 1
d918 2
a919 1
	if (options.forward_x11 && getenv("DISPLAY") != NULL) {
d922 2
a923 1
		x11_get_proto(&proto, &data);
d926 1
a926 1
		x11_request_forwarding_with_spoofing(0, proto, data);
d1028 2
a1029 1
	if (options.control_path == NULL || options.control_master <= 0)
d1032 2
d1049 1
a1049 1
		if (errno == EINVAL)
d1068 2
d1071 2
a1072 2
	int interactive = tty_flag;
	if (options.forward_x11 && getenv("DISPLAY") != NULL) {
d1075 2
a1076 1
		x11_get_proto(&proto, &data);
d1079 1
a1079 1
		x11_request_forwarding_with_spoofing(id, proto, data);
d1248 14
d1275 10
a1284 1
 		debug("Couldn't connect to %s: %s", path, strerror(errno));
@


1.3
log
@merge
@
text
@d43 1
a43 1
RCSID("$MirOS: src/usr.bin/ssh/ssh.c,v 1.2 2005/03/13 18:33:33 tg Exp $");
d589 1
a589 1
	if (!isatty(fileno(stdin)) && !force_tty_flag) {
d650 1
a650 1
		control_client(options.control_path); /* This doesn't return */
a1324 9
	if (stdin_null_flag) {
		if ((fd = open(_PATH_DEVNULL, O_RDONLY)) == -1)
			fatal("open(/dev/null): %s", strerror(errno));
		if (dup2(fd, STDIN_FILENO) == -1)
			fatal("dup2: %s", strerror(errno));
		if (fd > STDERR_FILENO)
			close(fd);
	}

d1337 15
a1351 3
	if (connect(sock, (struct sockaddr*)&addr, addr.sun_len) == -1)
		fatal("Couldn't connect to %s: %s", path, strerror(errno));

@


1.2
log
@merge src/usr.bin
@
text
@d43 1
a43 1
RCSID("$MirOS$");
d187 2
a188 2
	fprintf(stderr, "  -L listen-port:host:port   Forward local port to remote address\n");
	fprintf(stderr, "  -R listen-port:host:port   Forward remote port to local address\n");
a220 2
	u_short fwd_port, fwd_host_port;
	char sfwd_port[6], sfwd_host_port[6];
d227 1
d333 2
a334 1
				    "does not exist.\n", optarg);
d437 3
a439 5
		case 'R':
			if (sscanf(optarg, "%5[0-9]:%255[^:]:%5[0-9]",
			    sfwd_port, buf, sfwd_host_port) != 3 &&
			    sscanf(optarg, "%5[0-9]/%255[^/]/%5[0-9]",
			    sfwd_port, buf, sfwd_host_port) != 3) {
d441 1
a441 1
				    "Bad forwarding specification '%s'\n",
d443 1
a443 2
				usage();
				/* NOTREACHED */
d445 6
a450 2
			if ((fwd_port = a2port(sfwd_port)) == 0 ||
			    (fwd_host_port = a2port(sfwd_host_port)) == 0) {
d452 2
a453 1
				    "Bad forwarding port(s) '%s'\n", optarg);
a455 6
			if (opt == 'L')
				add_local_forward(&options, fwd_port, buf,
				    fwd_host_port);
			else if (opt == 'R')
				add_remote_forward(&options, fwd_port, buf,
				    fwd_host_port);
d459 17
a475 2
			fwd_port = a2port(optarg);
			if (fwd_port == 0) {
d480 2
a481 1
			add_local_forward(&options, fwd_port, "socks", 0);
d888 8
a895 4
		debug("Connections to local port %d forwarded to remote address %.200s:%d",
		    options.local_forwards[i].port,
		    options.local_forwards[i].host,
		    options.local_forwards[i].host_port);
d897 4
a900 3
		    options.local_forwards[i].port,
		    options.local_forwards[i].host,
		    options.local_forwards[i].host_port,
d908 8
a915 4
		debug("Connections to remote port %d forwarded to local address %.200s:%d",
		    options.remote_forwards[i].port,
		    options.remote_forwards[i].host,
		    options.remote_forwards[i].host_port);
d917 4
a920 3
		    options.remote_forwards[i].port,
		    options.remote_forwards[i].host,
		    options.remote_forwards[i].host_port);
d1097 3
a1099 3
	    options.remote_forwards[i].port,
	    options.remote_forwards[i].host,
	    options.remote_forwards[i].host_port);
d1101 2
a1102 2
		logit("Warning: remote port forwarding failed for listen port %d",
		    options.remote_forwards[i].port);
d1380 1
a1380 1
		fprintf(stderr, "Master running (pid=%d)\r\n", 
@


1.1
log
@Initial revision
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.230 2004/11/07 17:57:30 jmc Exp $");
d159 47
a205 7
	fprintf(stderr,
"usage: ssh [-1246AaCfgkMNnqsTtVvXxY] [-b bind_address] [-c cipher_spec]\n"
"           [-D port] [-e escape_char] [-F configfile] [-i identity_file]\n"
"           [-L port:host:hostport] [-l login_name] [-m mac_spec] [-O ctl_cmd]\n"
"           [-o option] [-p port] [-R port:host:hostport] [-S ctl_path]\n"
"           [user@@]hostname [command]\n"
	);
d278 1
a278 1
	    "1246ab:c:e:fgi:kl:m:no:p:qstvxACD:F:I:L:MNO:PR:S:TVXY")) != -1) {
a329 1
			options.gss_deleg_creds = 0;
d504 3
d697 1
a697 1
	 * Now that we are back to our own permissions, create ~/.ssh
d699 1
d1000 2
a1001 1
	packet_set_interactive(interactive);
d1149 2
a1150 1
	packet_set_interactive(interactive);
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@OpenSSH-current
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.235 2005/04/06 12:26:06 dtucker Exp $");
d161 3
a163 4
"           [-D port] [-e escape_char] [-F configfile]\n"
"           [-i identity_file] [-L [bind_address:]port:host:hostport]\n"
"           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]\n"
"           [-R [bind_address:]port:host:hostport] [-S ctl_path]\n"
d181 2
a188 1
	Forward fwd;
d295 1
a295 2
				    "not accessible: %s.\n", optarg,
				    strerror(errno));
d398 5
a402 3
			if (parse_forward(&fwd, optarg))
				add_local_forward(&options, &fwd);
			else {
d404 1
a404 1
				    "Bad local forwarding specification '%s'\n",
d406 2
a407 1
				exit(1);
d409 2
a410 6
			break;

		case 'R':
			if (parse_forward(&fwd, optarg)) {
				add_remote_forward(&options, &fwd);
			} else {
d412 1
a412 2
				    "Bad remote forwarding specification "
				    "'%s'\n", optarg);
d415 6
d424 2
a425 17
			cp = p = xstrdup(optarg);
			memset(&fwd, '\0', sizeof(fwd));
			fwd.connect_host = "socks";
			if ((fwd.listen_host = hpdelim(&cp)) == NULL) {
				fprintf(stderr, "Bad dynamic forwarding "
				    "specification '%.100s'\n", optarg);
				exit(1);
			}
			if (cp != NULL) {
				fwd.listen_port = a2port(cp);
				fwd.listen_host = cleanhostname(fwd.listen_host);
			} else {
				fwd.listen_port = a2port(fwd.listen_host);
				fwd.listen_host = "";
			}

			if (fwd.listen_port == 0) {
d430 1
a430 2
			add_local_forward(&options, &fwd);
			xfree(p);
d833 4
a836 8
		debug("Local connections to %.200s:%d forwarded to remote "
		    "address %.200s:%d",
		    (options.local_forwards[i].listen_host == NULL) ?
		    (options.gateway_ports ? "*" : "LOCALHOST") :
		    options.local_forwards[i].listen_host,
		    options.local_forwards[i].listen_port,
		    options.local_forwards[i].connect_host,
		    options.local_forwards[i].connect_port);
d838 3
a840 4
		    options.local_forwards[i].listen_host,
		    options.local_forwards[i].listen_port,
		    options.local_forwards[i].connect_host,
		    options.local_forwards[i].connect_port,
d848 4
a851 8
		debug("Remote connections from %.200s:%d forwarded to "
		    "local address %.200s:%d",
		    (options.remote_forwards[i].listen_host == NULL) ? 
		    (options.gateway_ports ? "*" : "LOCALHOST") : 
		    options.remote_forwards[i].listen_host,
		    options.remote_forwards[i].listen_port,
		    options.remote_forwards[i].connect_host,
		    options.remote_forwards[i].connect_port);
d853 3
a855 4
		    options.remote_forwards[i].listen_host,
		    options.remote_forwards[i].listen_port,
		    options.remote_forwards[i].connect_host,
		    options.remote_forwards[i].connect_port);
d1031 3
a1033 3
	    options.remote_forwards[i].listen_port,
	    options.remote_forwards[i].connect_host,
	    options.remote_forwards[i].connect_port);
d1035 2
a1036 2
		logit("Warning: remote port forwarding failed for listen "
		    "port %d", options.remote_forwards[i].listen_port);
d1313 1
a1313 1
		fprintf(stderr, "Master running (pid=%d)\r\n",
@


1.1.1.3
log
@latest fixes from OpenBSD, last update for #8 if nothing weird happens
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.237 2005/04/26 13:08:37 jakob Exp $");
d548 1
a548 1
	if ((!isatty(fileno(stdin)) || stdin_null_flag) && !force_tty_flag) {
d609 1
a609 1
		control_client(options.control_path);
d1281 9
d1302 3
a1304 15
	if (connect(sock, (struct sockaddr*)&addr, addr.sun_len) == -1) {
 		debug("Couldn't connect to %s: %s", path, strerror(errno));
 		close(sock);
 		return;
 	}
 
 	if (stdin_null_flag) {
 		if ((fd = open(_PATH_DEVNULL, O_RDONLY)) == -1)
 			fatal("open(/dev/null): %s", strerror(errno));
 		if (dup2(fd, STDIN_FILENO) == -1)
 			fatal("dup2: %s", strerror(errno));
 		if (fd > STDERR_FILENO)
 			close(fd);
 	}
  
@


1.1.1.4
log
@most current OpenSSH.com
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.245 2005/06/18 04:30:36 djm Exp $");
d148 1
a148 1
static u_int mux_command = 0;
a187 1
	struct servent *sp;
d384 2
a385 4
			if (options.control_master == SSHCTL_MASTER_YES)
				options.control_master = SSHCTL_MASTER_ASK;
			else
				options.control_master = SSHCTL_MASTER_YES;
a602 3
	if (options.control_path != NULL &&
	    strcmp(options.control_path, "none") == 0)
		options.control_path = NULL;
d605 4
a608 10
		snprintf(buf, sizeof(buf), "%d", options.port);
		cp = tilde_expand_filename(options.control_path,
		    original_real_uid);
		options.control_path = percent_expand(cp, "p", buf, "h", host,
		    "r", options.user, (char *)NULL);
		xfree(cp);
	}
	if (mux_command != 0 && options.control_path == NULL)
		fatal("No ControlPath specified for \"-O\" command");
	if (options.control_path != NULL)
a610 6
	/* Get default port if port has not been set. */
	if (options.port == 0) {
		sp = getservbyname(SSH_SERVICE_NAME, "tcp");
		options.port = sp ? ntohs(sp->s_port) : SSH_DEFAULT_PORT;
	}

d734 104
a899 1
	const char *display;
d961 1
a961 2
	display = getenv("DISPLAY");
	if (options.forward_x11 && display != NULL) {
d964 1
a964 2
		client_x11_get_proto(display, options.xauth_location,
		    options.forward_x11_trusted, &proto, &data);
d967 1
a967 1
		x11_request_forwarding_with_spoofing(0, display, proto, data);
d1068 1
a1068 2
	if (options.control_path == NULL ||
	    options.control_master == SSHCTL_MASTER_NO)
a1070 2
	debug("setting up multiplex master socket");

d1086 1
a1086 1
		if (errno == EINVAL || errno == EADDRINUSE)
d1105 1
a1105 1
	const char *display;
d1107 1
a1107 3

	display = getenv("DISPLAY");	
	if (options.forward_x11 && display != NULL) {
d1110 1
a1110 2
		client_x11_get_proto(display, options.xauth_location,
		    options.forward_x11_trusted, &proto, &data);
d1113 1
a1113 1
		x11_request_forwarding_with_spoofing(id, display, proto, data);
a1280 14
	if (mux_command == 0)
		mux_command = SSHMUX_COMMAND_OPEN;

	switch (options.control_master) {
	case SSHCTL_MASTER_AUTO:
	case SSHCTL_MASTER_AUTO_ASK:
		debug("auto-mux: Trying existing master");
		/* FALLTHROUGH */
	case SSHCTL_MASTER_NO:
		break;
	default:
		return;
	}

d1294 1
a1294 10
		if (mux_command != SSHMUX_COMMAND_OPEN) {
			fatal("Control socket connect(%.100s): %s", path,
			    strerror(errno));
		}
		if (errno == ENOENT)
	 		debug("Control socket \"%.100s\" does not exist", path);
		else {
	 		error("Control socket connect(%.100s): %s", path,
			    strerror(errno));
		}
@


1.1.1.5
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.248 2005/07/16 01:35:24 djm Exp $");
a602 6
	/* Get default port if port has not been set. */
	if (options.port == 0) {
		sp = getservbyname(SSH_SERVICE_NAME, "tcp");
		options.port = sp ? ntohs(sp->s_port) : SSH_DEFAULT_PORT;
	}

d623 6
d782 2
a783 2
		    (options.remote_forwards[i].listen_host == NULL) ?
		    (options.gateway_ports ? "*" : "LOCALHOST") :
d1028 1
a1028 1
	display = getenv("DISPLAY");
d1244 1
a1244 1

d1253 3
a1255 2

	term = getenv("TERM");
a1261 4
	if (options.forward_x11)
		flags |= SSHMUX_FLAG_X11_FWD;
	if (options.forward_agent)
		flags |= SSHMUX_FLAG_AGENT_FWD;
d1268 1
a1268 1
	if (ssh_msg_send(sock, SSHMUX_VER, &m) == -1)
d1275 1
a1275 1
	if (buffer_get_char(&m) != SSHMUX_VER)
d1299 1
a1299 1
	buffer_put_cstring(&m, term ? term : "");
d1321 1
a1321 1
	if (ssh_msg_send(sock, SSHMUX_VER, &m) == -1)
d1332 1
a1332 1
	if (buffer_get_char(&m) != SSHMUX_VER)
@


1.1.1.6
log
@Import current OpenSSH
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.254 2005/10/30 08:52:18 djm Exp $");
d161 1
a161 1
"           [-D [bind_address:]port] [-e escape_char] [-F configfile]\n"
a190 3
	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

d437 1
a437 1
				fwd.listen_host = NULL;
d687 1
a687 1
	 * directory if it doesn't already exist.
d783 2
a784 1
		    "LOCALHOST" : options.remote_forwards[i].listen_host,
d800 1
a800 1
		/* Clear agent forwarding if we don't have an agent. */
d1001 1
a1001 1
		fatal("%s socket(): %s", __func__, strerror(errno));
d1010 1
a1010 1
			fatal("%s bind(): %s", __func__, strerror(errno));
d1015 1
a1015 1
		fatal("%s listen(): %s", __func__, strerror(errno));
@


1.1.1.7
log
@OpenSSH is the last missing piece to update before the release
@
text
@d43 1
a43 1
RCSID("$OpenBSD: ssh.c,v 1.257 2005/12/20 04:41:07 dtucker Exp $");
d165 1
a165 1
"           [-w tunnel:tunnel] [user@@]hostname [command]\n"
d167 1
a167 1
	exit(255);
d221 1
a221 1
		exit(255);
d242 1
a242 1
	    "1246ab:c:e:fgi:kl:m:no:p:qstvxACD:F:I:L:MNO:PR:S:TVw:XY")) != -1) {
a337 9
		case 'w':
			if (options.tun_open == -1)
				options.tun_open = SSH_TUNMODE_DEFAULT;
			options.tun_local = a2tun(optarg, &options.tun_remote);
			if (options.tun_local == SSH_TUNID_ERR) {
				fprintf(stderr, "Bad tun device '%s'\n", optarg);
				exit(255);
			}
			break;
d353 1
a353 1
				exit(255);
d368 1
a368 1
					exit(255);
d384 1
a384 1
				exit(255);
d397 1
a397 1
				exit(255);
d411 1
a411 1
				exit(255);
d422 1
a422 1
				exit(255);
d433 1
a433 1
				exit(255);
d446 1
a446 1
				exit(255);
d467 1
a467 1
				exit(255);
d637 1
a637 1
		exit(255);
a1049 22
	if (options.tun_open != SSH_TUNMODE_NO) {
		Channel *c;
		int fd;

		debug("Requesting tun.");
		if ((fd = tun_open(options.tun_local,
		    options.tun_open)) >= 0) {
			c = channel_new("tun", SSH_CHANNEL_OPENING, fd, fd, -1,
			    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,
			    0, "tun", 1);
			c->datagram = 1;
			packet_start(SSH2_MSG_CHANNEL_OPEN);
			packet_put_cstring("tun@@openssh.com");
			packet_put_int(c->self);
			packet_put_int(c->local_window_max);
			packet_put_int(c->local_maxpacket);
			packet_put_int(options.tun_open);
			packet_put_int(options.tun_remote);
			packet_send();
		}
	}

a1113 5
	/* Execute a local command */
	if (options.local_command != NULL &&
	    options.permit_local_command)
		ssh_local_cmd(options.local_command);

@


1.1.1.8
log
@import OpenSSH-current
@
text
@d43 1
a43 10
RCSID("$OpenBSD: ssh.c,v 1.264 2006/02/20 17:19:54 stevesk Exp $");

#include <sys/resource.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/un.h>
#include <sys/stat.h>

#include <paths.h>
#include <signal.h>
a628 4
		char me[NI_MAXHOST];

		if (gethostname(me, sizeof(me)) == -1)
			fatal("gethostname: %s", strerror(errno));
d633 1
a633 1
		    "r", options.user, "l", me, (char *)NULL);
@


1.1.1.9
log
@I decided we'd better upgrade OpenSSH before releasing to the general public
@
text
@a0 1
/* $OpenBSD: ssh.c,v 1.275 2006/03/30 10:41:25 djm Exp $ */
d43 1
a50 1
#include <ctype.h>
d249 1
a249 1
 again:
d621 1
a621 1
				*p = (char)tolower(*p);
d638 1
a638 1
		char thishost[NI_MAXHOST];
d640 1
a640 1
		if (gethostname(thishost, sizeof(thishost)) == -1)
d646 1
a646 1
		    "r", options.user, "l", thishost, (char *)NULL);
d675 1
a675 1
		sensitive_data.keys = xcalloc(sensitive_data.nkeys,
d877 4
a880 4
		packet_put_int((u_int)ws.ws_row);
		packet_put_int((u_int)ws.ws_col);
		packet_put_int((u_int)ws.ws_xpixel);
		packet_put_int((u_int)ws.ws_ypixel);
d1028 1
a1028 1
	if (bind(control_fd, (struct sockaddr *)&addr, addr.sun_len) == -1) {
d1175 1
a1175 1
	char *filename, *cp, thishost[NI_MAXHOST];
a1177 1
	struct passwd *pw;
a1200 5
	if ((pw = getpwuid(original_real_uid)) == NULL)
		fatal("load_public_identity_files: getpwuid failed");
	if (gethostname(thishost, sizeof(thishost)) == -1)
		fatal("load_public_identity_files: gethostname: %s",
		    strerror(errno));
d1202 1
a1202 1
		cp = tilde_expand_filename(options.identity_files[i],
a1203 4
		filename = percent_expand(cp, "d", pw->pw_dir,
		    "u", pw->pw_name, "l", thishost, "h", host, 
		    "r", options.user, (char *)NULL);
		xfree(cp);
d1232 1
a1232 2
	if (strlcpy(name, env, sizeof(name)) >= sizeof(name))
		fatal("env_permitted: name too long");
d1281 1
a1281 1
	if (connect(sock, (struct sockaddr *)&addr, addr.sun_len) == -1) {
d1287 1
a1287 1
			debug("Control socket \"%.100s\" does not exist", path);
d1289 1
a1289 1
			error("Control socket connect(%.100s): %s", path,
d1292 12
a1303 12
		close(sock);
		return;
	}

	if (stdin_null_flag) {
		if ((fd = open(_PATH_DEVNULL, O_RDONLY)) == -1)
			fatal("open(/dev/null): %s", strerror(errno));
		if (dup2(fd, STDIN_FILENO) == -1)
			fatal("dup2: %s", strerror(errno));
		if (fd > STDERR_FILENO)
			close(fd);
	}
@


1.1.1.10
log
@if we're gonna push out another snapshot, we'd better have sshd-current
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.276 2006/04/25 08:02:27 dtucker Exp $ */
d681 1
a681 1
		    _PATH_HOST_KEY_FILE, "", NULL, NULL);
d683 1
a683 1
		    _PATH_HOST_DSA_KEY_FILE, "", NULL, NULL);
d685 1
a685 1
		    _PATH_HOST_RSA_KEY_FILE, "", NULL, NULL);
@


1.1.1.11
log
@import a few security-wise relevant changes right now
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.293 2006/08/03 03:34:42 deraadt Exp $ */
d43 2
a44 1
#include <sys/types.h>
a47 1
#include <sys/socket.h>
a51 3
#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
a52 1
#include <pwd.h>
a53 5
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
a57 1
#include "xmalloc.h"
d63 1
d66 1
a84 1
#include "version.h"
d175 1
a175 1
"           [-w local_tun[:remote_tun]] [user@@]hostname [command]\n"
a800 2
	if (i > 0 && success != i && options.exit_on_forward_failure)
		fatal("Could not request local forwarding.");
d813 1
a813 1
		if (channel_request_remote_forwarding(
d817 1
a817 7
		    options.remote_forwards[i].connect_port) < 0) {
			if (options.exit_on_forward_failure)
				fatal("Could not request remote forwarding.");
			else
				logit("Warning: Could not request remote "
				    "forwarding.");
		}
d999 3
a1001 10
	if (type == SSH2_MSG_REQUEST_FAILURE) {
		if (options.exit_on_forward_failure)
			fatal("Error: remote port forwarding failed for "
			    "listen port %d",
			    options.remote_forwards[i].listen_port);
		else
			logit("Warning: remote port forwarding failed for "
			    "listen port %d",
			    options.remote_forwards[i].listen_port);
	}
d1185 1
a1185 1
	    (keys = sc_get_keys(options.smartcard_device, NULL)) != NULL) {
d1212 1
a1212 1
		    "u", pw->pw_name, "l", thishost, "h", host,
d1240 1
a1240 1
	int i, ret;
d1243 3
a1245 1
	if ((cp = strchr(env, '=')) == NULL || cp == env)
d1247 2
a1248 3
	ret = snprintf(name, sizeof(name), "%.*s", (int)(cp - env), env);
	if (ret <= 0 || (size_t)ret >= sizeof(name))
		fatal("env_permitted: name '%.100s...' too long", env);
@


1.1.1.12
log
@OpenSSH 4.5 (security)
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.294 2006/10/06 02:29:19 djm Exp $ */
a43 1
#include <sys/time.h>
@


1.1.1.13
log
@update OpenSSH, while we're at it…
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.295 2007/01/03 03:01:40 stevesk Exp $ */
d604 1
a604 1
	} else {
@


1.1.1.14
log
@Import latest OpenSSH and OpenBSD-libssl
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.300 2007/06/14 22:48:05 djm Exp $ */
d180 1
a180 1
"usage: ssh [-1246AaCfgKkMNnqsTtVvXxY] [-b bind_address] [-c cipher_spec]\n"
d262 1
a262 1
	    "1246ab:c:e:fgi:kl:m:no:p:qstvxACD:F:I:KL:MNO:PR:S:TVw:XY")) != -1) {
a315 4
		case 'K':
			options.gss_authentication = 1;
			options.gss_deleg_creds = 1;
			break;
d1285 1
a1285 1
	int i, r, fd, sock, exitval[2], num_env;
d1434 4
a1437 10
	/*
	 * Stick around until the controlee closes the client_fd.
	 * Before it does, it is expected to write this process' exit
	 * value (one int). This process must read the value and wait for
	 * the closure of the client_fd; if this one closes early, the 
	 * multiplex master will terminate early too (possibly losing data).
	 */
	exitval[0] = 0;
	for (i = 0; !control_client_terminate && i < (int)sizeof(exitval);) {
		r = read(sock, (char *)exitval + i, sizeof(exitval) - i);
d1442 3
a1444 3
		if (r == -1) {
			if (errno == EINTR)
				continue;
a1445 2
		}
		i += r;
d1448 3
d1452 1
a1453 11
	if (i > (int)sizeof(int))
		fatal("%s: master returned too much data (%d > %lu)",
		    __func__, i, sizeof(int));
	if (control_client_terminate) {
		debug2("Exiting on signal %d", control_client_terminate);
		exitval[0] = 255;
	} else if (i < (int)sizeof(int)) {
		debug2("Control master terminated unexpectedly");
		exitval[0] = 255;
	} else
		debug2("Received exit status from master %d", exitval[0]);
d1456 1
a1456 1
		fprintf(stderr, "Shared connection to %s closed.\r\n", host);
d1458 1
a1458 1
	exit(exitval[0]);
@


1.1.1.15
log
@OpenSSH 4.7+1
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.301 2007/08/07 07:32:53 djm Exp $ */
a840 11

	/* Initiate tunnel forwarding. */
	if (options.tun_open != SSH_TUNMODE_NO) {
		if (client_request_tun_fwd(options.tun_open,
		    options.tun_local, options.tun_remote) == -1) {
			if (options.exit_on_forward_failure)
				fatal("Could not request tunnel forwarding.");
			else
				error("Could not request tunnel forwarding.");
		}
	}			
d1102 22
d1183 1
a1192 3
	/* Start listening for multiplex clients */
	ssh_control_listener();

@


1.1.1.16
log
@Import latest OpenSSH upgrades
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.303 2007/09/04 11:15:55 djm Exp $ */
d205 1
a205 1
	int dummy, timeout_ms;
a668 2
	timeout_ms = options.connection_timeout * 1000;

d671 1
a671 2
	    options.address_family, options.connection_attempts, &timeout_ms,
	    options.tcp_keep_alive, 
a675 3
	if (timeout_ms > 0)
		debug3("timeout: %d ms remain after connect", timeout_ms);

d751 1
a751 2
	ssh_login(&sensitive_data, host, (struct sockaddr *)&hostaddr,
	    pw, timeout_ms);
d1409 3
a1411 4
	if (mm_send_fd(sock, STDIN_FILENO) == -1 ||
	    mm_send_fd(sock, STDOUT_FILENO) == -1 ||
	    mm_send_fd(sock, STDERR_FILENO) == -1)
		fatal("%s: send fds failed", __func__);
@


1.1.1.17
log
@newer openssh
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.309 2008/01/19 20:51:26 djm Exp $ */
d646 1
a646 2
	    strcmp(options.proxy_command, "none") == 0) {
		xfree(options.proxy_command);
a647 1
	}
d649 1
a649 2
	    strcmp(options.control_path, "none") == 0) {
		xfree(options.control_path);
a650 1
	}
a659 1
		xfree(options.control_path);
a980 5
	/* Execute a local command */
	if (options.local_command != NULL &&
	    options.permit_local_command)
		ssh_local_cmd(options.local_command);

a1203 1
	char *pwdir = NULL, *pwname = NULL;
a1231 2
	pwname = xstrdup(pw->pw_name);
	pwdir = xstrdup(pw->pw_dir);
d1238 2
a1239 2
		filename = percent_expand(cp, "d", pwdir,
		    "u", pwname, "l", thishost, "h", host,
a1248 4
	bzero(pwname, strlen(pwname));
	xfree(pwname);
	bzero(pwdir, strlen(pwdir));
	xfree(pwdir);
a1259 2
	int save_errno = errno;

a1261 2

	errno = save_errno;
a1354 2
	signal(SIGPIPE, SIG_IGN);

@


1.1.1.18
log
@OpenSSH-current
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.322 2008/11/01 17:40:33 stevesk Exp $ */
d44 2
d47 1
a47 2
#include <sys/queue.h>
#include <sys/resource.h>
d49 1
a50 2
#include <sys/types.h>
#include <sys/time.h>
d92 1
d102 1
a102 1
/* Flag indicating whether debug mode is on.  May be set on the command line. */
d159 1
a159 1
static int remote_forward_confirms_received = 0;
d164 5
a168 3
/* mux.c */
extern int muxserver_sock;
extern u_int muxclient_command;
d170 3
d180 1
a180 1
"usage: ssh [-1246AaCfgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]\n"
d193 1
a193 4

/* from muxclient.c */
void muxclient(const char *);
void muxserver_listen(void);
d201 1
a201 1
	int i, opt, exit_status, use_syslog;
d254 1
a254 4
	/*
	 * Initialize option structure to indicate that no values have been
	 * set.
	 */
a258 1
	use_syslog = 0;
d261 2
a262 2
	while ((opt = getopt(ac, av, "1246ab:c:e:fgi:kl:m:no:p:qstvx"
	    "ACD:F:I:KL:MNO:PR:S:TVw:XYy")) != -1) {
a288 3
		case 'y':
			use_syslog = 1;
			break;
d298 1
a298 1
				muxclient_command = SSHMUX_COMMAND_ALIVE_CHECK;
d300 1
a300 1
				muxclient_command = SSHMUX_COMMAND_TERMINATE;
d367 1
a367 2
				fprintf(stderr,
				    "Bad tun device '%s'\n", optarg);
d438 1
a438 1
			if (parse_forward(&fwd, optarg, 0))
d449 1
a449 1
			if (parse_forward(&fwd, optarg, 0)) {
d460 11
a470 2
			if (parse_forward(&fwd, optarg, 1)) {
				add_local_forward(&options, &fwd);
d472 7
a478 3
				fprintf(stderr,
				    "Bad dynamic forwarding specification "
				    "'%s'\n", optarg);
d481 2
d576 2
a577 4
	if (fork_after_authentication_flag && buffer_len(&command) == 0 &&
	    !no_shell_flag)
		fatal("Cannot fork into background without a command "
		    "to execute.");
d589 1
a589 2
			logit("Pseudo-terminal will not be allocated because "
			    "stdin is not a terminal.");
d597 2
a598 3
	log_init(av[0],
	    options.log_level == -1 ? SYSLOG_LEVEL_INFO : options.log_level,
	    SYSLOG_FACILITY_USER, !use_syslog);
d624 1
a624 1
	log_init(av[0], options.log_level, SYSLOG_FACILITY_USER, !use_syslog);
a628 22
	/* Get default port if port has not been set. */
	if (options.port == 0) {
		sp = getservbyname(SSH_SERVICE_NAME, "tcp");
		options.port = sp ? ntohs(sp->s_port) : SSH_DEFAULT_PORT;
	}

	if (options.local_command != NULL) {
		char thishost[NI_MAXHOST];

		if (gethostname(thishost, sizeof(thishost)) == -1)
			fatal("gethostname: %s", strerror(errno));
		snprintf(buf, sizeof(buf), "%d", options.port);
		debug3("expanding LocalCommand: %s", options.local_command);
		cp = options.local_command;
		options.local_command = percent_expand(cp, "d", pw->pw_dir,
		    "h", options.hostname? options.hostname : host,
                    "l", thishost, "n", host, "r", options.user, "p", buf,
                    "u", pw->pw_name, (char *)NULL);
		debug3("expanded LocalCommand: %s", options.local_command);
		xfree(cp);
	}

d639 6
d669 1
a669 1
	if (muxclient_command != 0 && options.control_path == NULL)
d672 1
a672 1
		muxclient(options.control_path);
d740 1
a740 2
	snprintf(buf, sizeof buf, "%.100s%s%.100s", pw->pw_dir,
	    strcmp(pw->pw_dir, "/") ? "/" : "", _PATH_SSH_USER_DIR);
d761 1
a761 1
	/* Log into the remote system.  Never returns if the login fails. */
d791 1
a791 1
	if (options.control_path != NULL && muxserver_sock != -1)
a803 28
/* Callback for remote forward global requests */
static void
ssh_confirm_remote_forward(int type, u_int32_t seq, void *ctxt)
{
	Forward *rfwd = (Forward *)ctxt;

	debug("remote forward %s for: listen %d, connect %s:%d",
	    type == SSH2_MSG_REQUEST_SUCCESS ? "success" : "failure",
	    rfwd->listen_port, rfwd->connect_host, rfwd->connect_port);
	if (type == SSH2_MSG_REQUEST_FAILURE) {
		if (options.exit_on_forward_failure)
			fatal("Error: remote port forwarding failed for "
			    "listen port %d", rfwd->listen_port);
		else
			logit("Warning: remote port forwarding failed for "
			    "listen port %d", rfwd->listen_port);
	}
	if (++remote_forward_confirms_received == options.num_remote_forwards) {
		debug("All remote forwarding requests processed");
		if (fork_after_authentication_flag) {
			fork_after_authentication_flag = 0;
			if (daemon(1, 1) < 0)
				fatal("daemon() failed: %.200s",
				    strerror(errno));
		}
	}
}

a851 2
		client_register_global_confirm(ssh_confirm_remote_forward,
		    &options.remote_forwards[i]);
d888 1
a888 2
		debug("Requesting compression at level %d.",
		    options.compression_level);
d890 2
a891 4
		if (options.compression_level < 1 ||
		    options.compression_level > 9)
			fatal("Compression level must be from 1 (fast) to "
			    "9 (slow, best).");
d904 1
a904 2
			packet_disconnect("Protocol error waiting for "
			    "compression response.");
d941 1
a941 2
			logit("Warning: Remote host failed or refused to "
			    "allocate a pseudo tty.");
d943 1
a943 2
			packet_disconnect("Protocol error waiting for pty "
			    "request response.");
d953 1
a953 2
		debug("Requesting X11 forwarding with authentication "
		    "spoofing.");
d963 1
a963 2
			packet_disconnect("Protocol error waiting for X11 "
			    "forwarding");
d991 2
a992 8
	/*
	 * If requested and we are not interested in replies to remote
	 * forwarding requests, then let ssh continue in the background.
	 */
	if (fork_after_authentication_flag &&
	    (!options.exit_on_forward_failure ||
	    options.num_remote_forwards == 0)) {
		fork_after_authentication_flag = 0;
a994 1
	}
d1004 1
a1004 2
		debug("Sending command: %.*s", len,
		    (u_char *)buffer_ptr(&command));
d1021 81
d1117 1
a1117 2
		debug("Requesting X11 forwarding with authentication "
		    "spoofing.");
d1131 1
a1131 1
	    NULL, fileno(stdin), &command, environ);
d1177 1
a1177 2
		channel_register_open_confirm(c->self,
		    ssh_session2_setup, NULL);
a1192 10
	/* If we don't expect to open a new session, then disallow it */
	if (options.control_master == SSHCTL_MASTER_NO &&
	    (datafellows & SSH_NEW_OPENSSH)) {
		debug("Requesting no-more-sessions@@openssh.com");
		packet_start(SSH2_MSG_GLOBAL_REQUEST);
		packet_put_cstring("no-more-sessions@@openssh.com");
		packet_put_char(0);
		packet_send();
	}

d1199 1
a1199 1
	muxserver_listen();
d1202 1
a1202 2
	if (fork_after_authentication_flag) {
		fork_after_authentication_flag = 0;
a1204 1
	}
d1227 1
a1227 2
			memmove(&options.identity_files[1],
			    &options.identity_files[0],
d1229 1
a1229 2
			memmove(&options.identity_keys[1],
			    &options.identity_keys[0],
d1267 234
@


1.1.1.19
log
@OpenSSH 5.2, or so
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.325 2009/03/17 21:37:00 markus Exp $ */
d199 1
a199 1
	char *p, *cp, *line, *argv0, buf[256];
a259 1
	argv0 = av[0];
d433 1
a433 1
			if (options.port <= 0) {
d443 1
a443 1
			if (parse_forward(&fwd, optarg, 0, 0))
d454 1
a454 1
			if (parse_forward(&fwd, optarg, 0, 1)) {
d465 1
a465 1
			if (parse_forward(&fwd, optarg, 1, 0)) {
d590 1
a590 1
	log_init(argv0,
d618 1
a618 1
	log_init(argv0, options.log_level, SYSLOG_FACILITY_USER, !use_syslog);
a820 1
	/* XXX verbose() on failure? */
a823 6
	if (type == SSH2_MSG_REQUEST_SUCCESS && rfwd->listen_port == 0) {
		logit("Allocated port %u for remote forward to %s:%d",
			packet_get_int(),
			rfwd->connect_host, rfwd->connect_port);
	}
	
@


1.1.1.20
log
@Let’s play the version number game – OpenSSH 5.3-current
@
text
@d1 1
a1 1
/* $OpenBSD: ssh.c,v 1.326 2009/07/02 02:11:47 dtucker Exp $ */
a44 1
#include <sys/param.h>
d198 2
a199 2
	int i, r, opt, exit_status, use_syslog;
	char *p, *cp, *line, *argv0, buf[MAXPATHLEN];
d604 1
a604 1
		r = snprintf(buf, sizeof buf, "%s/%s", pw->pw_dir,
d606 1
a606 2
		if (r > 0 && (size_t)r < sizeof(buf))
			(void)read_config_file(buf, host, &options, 1);
d751 1
a751 1
	r = snprintf(buf, sizeof buf, "%s%s%s", pw->pw_dir,
d753 1
a753 1
	if (r > 0 && (size_t)r < sizeof(buf) && stat(buf, &st) < 0)
@


