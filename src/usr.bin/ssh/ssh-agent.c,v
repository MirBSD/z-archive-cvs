head	1.18;
access;
symbols
	cvs-200910041320:1.1.1.14
	cvs-200903221200:1.1.1.13
	cvs-200812162015:1.1.1.13
	cvs-200804031830:1.1.1.12
	MIRBSD_10:1.13.0.2
	MIRBSD_10_BASE:1.13
	cvs-200803022030:1.1.1.12
	cvs-200709131337:1.1.1.11
	cvs-200709021830:1.1.1.10
	cvs-200708201200:1.1.1.10
	cvs-200706161500:1.1.1.10
	cvs-200705192215:1.1.1.10
	cvs-200704292000:1.1.1.10
	cvs-200703080900:1.1.1.9
	cvs-200701251600:1.1.1.8
	cvs-200612111600:1.1.1.8
	cvs-200611090230:1.1.1.8
	OPENBSD_4_0:1.1.1.7
	MIRBSD_9_BASE:1.7
	cvs-200606162342:1.1.1.6
	cvs-200606022000:1.1.1.5
	cvs-200604191000:1.1.1.4
	cvs-200602220045:1.1.1.3
	MIRBSD_8:1.1.1.2.0.2
	MIRBSD_8_BASE:1.1.1.2
	cvs-200512201942:1.1.1.2
	cvs-200511231930:1.1.1.2
	cvs-200507211800:1.1.1.1
	cvs-200506221550:1.1.1.1
	cvs-200505050030:1.1.1.1
	cvs-200504291700:1.1.1.1
	cvs-200504261445:1.1.1.1
	cvs-200504141900:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2013.10.31.20.07.14;	author tg;	state Exp;
branches;
next	1.17;
commitid	1005272B7081B0E5655;

1.17
date	2009.10.04.14.29.10;	author tg;	state Exp;
branches;
next	1.16;
commitid	1004AC8B1276FC00211;

1.16
date	2008.12.27.21.17.58;	author tg;	state Exp;
branches;
next	1.15;
commitid	10049569B9439744217;

1.15
date	2008.12.16.22.13.30;	author tg;	state Exp;
branches;
next	1.14;
commitid	10049482819766381ED;

1.14
date	2008.12.16.20.55.29;	author tg;	state Exp;
branches;
next	1.13;
commitid	100494815C97ECEEDBF;

1.13
date	2007.10.02.01.20.23;	author tg;	state Exp;
branches;
next	1.12;
commitid	10047019CED77344E80;

1.12
date	2007.09.13.13.52.54;	author tg;	state Exp;
branches;
next	1.11;
commitid	10046E940B668DE9A0B;

1.11
date	2007.04.29.20.23.14;	author tg;	state Exp;
branches;
next	1.10;
commitid	1004634FEC2113C55F5;

1.10
date	2007.03.08.10.09.33;	author tg;	state Exp;
branches;
next	1.9;
commitid	10045EFE0F11EDE1747;

1.9
date	2006.10.13.18.40.50;	author tg;	state Exp;
branches;
next	1.8;
commitid	100452FDDB7190872BF;

1.8
date	2006.09.20.21.41.05;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004511B578580E7F04;

1.7
date	2006.06.16.23.47.09;	author tg;	state Exp;
branches;
next	1.6;
commitid	100449343131498EA29;

1.6
date	2006.06.02.20.50.50;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004480A4952B0D84EA;

1.5
date	2006.04.19.10.40.54;	author tg;	state Exp;
branches;
next	1.4;
commitid	100444613BD3A91C28B;

1.4
date	2006.02.22.02.16.49;	author tg;	state Exp;
branches;
next	1.3;
commitid	10043FBC991512A442B;

1.3
date	2006.02.22.01.23.51;	author tg;	state Exp;
branches;
next	1.2;
commitid	10043FBBD2C2C5E7D81;

1.2
date	2006.02.21.02.12.25;	author tg;	state Exp;
branches;
next	1.1;
commitid	10043FA771B61F2BE89;

1.1
date	2005.02.05.17.29.55;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.29.55;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.11.23.19.34.15;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	116a4384c4467ffc;

1.1.1.3
date	2006.02.22.00.51.36;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	10043FBB5A933C3BB9B;

1.1.1.4
date	2006.04.19.10.15.04;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	10044460DB21E1F715C;

1.1.1.5
date	2006.06.02.20.31.52;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	1004480A0422110D712;

1.1.1.6
date	2006.06.16.23.45.14;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	100449342952F660974;

1.1.1.7
date	2006.09.20.19.06.50;	author tg;	state Exp;
branches;
next	1.1.1.8;
commitid	10045119150397FC669;

1.1.1.8
date	2006.11.09.02.38.01;	author tg;	state Exp;
branches;
next	1.1.1.9;
commitid	100455294981A6201C8;

1.1.1.9
date	2007.03.08.09.23.22;	author tg;	state Exp;
branches;
next	1.1.1.10;
commitid	10045EFD61903FC276A;

1.1.1.10
date	2007.04.29.20.07.03;	author tg;	state Exp;
branches;
next	1.1.1.11;
commitid	1004634FAED5BC54DF0;

1.1.1.11
date	2007.09.13.13.39.04;	author tg;	state Exp;
branches;
next	1.1.1.12;
commitid	10046E93D7724AAC1F8;

1.1.1.12
date	2007.10.02.01.18.58;	author tg;	state Exp;
branches;
next	1.1.1.13;
commitid	10047019C826E5AB753;

1.1.1.13
date	2008.12.16.20.15.34;	author tg;	state Exp;
branches;
next	1.1.1.14;
commitid	10049480C7A2701F5C0;

1.1.1.14
date	2009.10.04.13.25.45;	author tg;	state Exp;
branches;
next	;
commitid	1004AC8A2663BC008C5;


desc
@@


1.18
log
@adapt most __attribute__((…)) occurrences to new KNF style(9)
@
text
@/* $OpenBSD: ssh-agent.c,v 1.162 2009/09/01 14:43:17 djm Exp $ */
/*
 * Author: Tatu Ylonen <ylo@@cs.hut.fi>
 * Copyright © 2013
 *	Thorsten “mirabilos” Glaser <tg@@mirbsd.org>
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * The authentication agent program.
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 *
 * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/time.h>
#include <sys/queue.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/un.h>

#include <openssl/evp.h>
#include <openssl/md5.h>

#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <signal.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "xmalloc.h"
#include "ssh.h"
#include "rsa.h"
#include "buffer.h"
#include "key.h"
#include "authfd.h"
#include "compat.h"
#include "log.h"
#include "misc.h"

__RCSID("$MirOS: src/usr.bin/ssh/ssh-agent.c,v 1.17 2009/10/04 14:29:10 tg Exp $");

#ifdef SMARTCARD
#include "scard.h"
#endif

typedef enum {
	AUTH_UNUSED,
	AUTH_SOCKET,
	AUTH_CONNECTION
} sock_type;

typedef struct {
	int fd;
	sock_type type;
	Buffer input;
	Buffer output;
	Buffer request;
} SocketEntry;

u_int sockets_alloc = 0;
SocketEntry *sockets = NULL;

typedef struct identity {
	TAILQ_ENTRY(identity) next;
	Key *key;
	char *comment;
	u_int death;
	u_int confirm;
} Identity;

typedef struct {
	int nentries;
	TAILQ_HEAD(idqueue, identity) idlist;
} Idtab;

/* private key table, one per protocol version */
Idtab idtable[3];

int max_fd = 0;

/* pid of shell == parent of agent */
pid_t parent_pid = -1;
u_int parent_alive_interval = 0;

/* pathname and directory for AUTH_SOCKET */
char socket_name[MAXPATHLEN];
char socket_dir[MAXPATHLEN];

/* locking */
int locked = 0;
char *lock_passwd = NULL;

extern char *__progname;

/* Default lifetime (0 == forever) */
static int lifetime = 0;

static void
close_socket(SocketEntry *e)
{
	close(e->fd);
	e->fd = -1;
	e->type = AUTH_UNUSED;
	buffer_free(&e->input);
	buffer_free(&e->output);
	buffer_free(&e->request);
}

static void
idtab_init(void)
{
	int i;

	for (i = 0; i <=2; i++) {
		TAILQ_INIT(&idtable[i].idlist);
		idtable[i].nentries = 0;
	}
}

/* return private key table for requested protocol version */
static Idtab *
idtab_lookup(int version)
{
	if (version < 1 || version > 2)
		fatal("internal error, bad protocol version %d", version);
	return &idtable[version];
}

static void
free_identity(Identity *id)
{
	key_free(id->key);
	xfree(id->comment);
	xfree(id);
}

/* return matching private key for given public key */
static Identity *
lookup_identity(Key *key, int version)
{
	Identity *id;

	Idtab *tab = idtab_lookup(version);
	TAILQ_FOREACH(id, &tab->idlist, next) {
		if (key_equal(key, id->key))
			return (id);
	}
	return (NULL);
}

/* Check confirmation of keysign request */
static int
confirm_key(Identity *id)
{
	char *p;
	int ret = -1;

	p = key_fingerprint(id->key, SSH_FP_MD5, SSH_FP_HEX);
	if (ask_permission("Allow use of key %s?\nKey fingerprint %s.",
	    id->comment, p))
		ret = 0;
	xfree(p);

	return (ret);
}

/* send list of supported public keys to 'client' */
static void
process_request_identities(SocketEntry *e, int version)
{
	Idtab *tab = idtab_lookup(version);
	Identity *id;
	Buffer msg;

	buffer_init(&msg);
	buffer_put_char(&msg, (version == 1) ?
	    SSH_AGENT_RSA_IDENTITIES_ANSWER : SSH2_AGENT_IDENTITIES_ANSWER);
	buffer_put_int(&msg, tab->nentries);
	TAILQ_FOREACH(id, &tab->idlist, next) {
		if (id->key->type == KEY_RSA1) {
			buffer_put_int(&msg, BN_num_bits(id->key->rsa->n));
			buffer_put_bignum(&msg, id->key->rsa->e);
			buffer_put_bignum(&msg, id->key->rsa->n);
		} else {
			u_char *blob;
			u_int blen;
			key_to_blob(id->key, &blob, &blen);
			buffer_put_string(&msg, blob, blen);
			xfree(blob);
		}
		buffer_put_cstring(&msg, id->comment);
	}
	buffer_put_int(&e->output, buffer_len(&msg));
	buffer_append(&e->output, buffer_ptr(&msg), buffer_len(&msg));
	buffer_free(&msg);
}

/* ssh1 only */
static void
process_authentication_challenge1(SocketEntry *e)
{
	u_char buf[32], mdbuf[16], session_id[16];
	u_int response_type;
	BIGNUM *challenge;
	Identity *id;
	int i, len;
	Buffer msg;
	MD5_CTX md;
	Key *key;

	buffer_init(&msg);
	key = key_new(KEY_RSA1);
	if ((challenge = BN_new()) == NULL)
		fatal("process_authentication_challenge1: BN_new failed");

	(void) buffer_get_int(&e->request);			/* ignored */
	buffer_get_bignum(&e->request, key->rsa->e);
	buffer_get_bignum(&e->request, key->rsa->n);
	buffer_get_bignum(&e->request, challenge);

	/* Only protocol 1.1 is supported */
	if (buffer_len(&e->request) == 0)
		goto failure;
	buffer_get(&e->request, session_id, 16);
	response_type = buffer_get_int(&e->request);
	if (response_type != 1)
		goto failure;

	id = lookup_identity(key, 1);
	if (id != NULL && (!id->confirm || confirm_key(id) == 0)) {
		Key *private = id->key;
		/* Decrypt the challenge using the private key. */
		if (rsa_private_decrypt(challenge, challenge, private->rsa) <= 0)
			goto failure;

		/* The response is MD5 of decrypted challenge plus session id. */
		len = BN_num_bytes(challenge);
		if (len <= 0 || len > 32) {
			logit("process_authentication_challenge: bad challenge length %d", len);
			goto failure;
		}
		memset(buf, 0, 32);
		BN_bn2bin(challenge, buf + 32 - len);
		MD5_Init(&md);
		MD5_Update(&md, buf, 32);
		MD5_Update(&md, session_id, 16);
		MD5_Final(mdbuf, &md);

		/* Send the response. */
		buffer_put_char(&msg, SSH_AGENT_RSA_RESPONSE);
		for (i = 0; i < 16; i++)
			buffer_put_char(&msg, mdbuf[i]);
		goto send;
	}

failure:
	/* Unknown identity or protocol error.  Send failure. */
	buffer_put_char(&msg, SSH_AGENT_FAILURE);
send:
	buffer_put_int(&e->output, buffer_len(&msg));
	buffer_append(&e->output, buffer_ptr(&msg), buffer_len(&msg));
	key_free(key);
	BN_clear_free(challenge);
	buffer_free(&msg);
}

/* ssh2 only */
static void
process_sign_request2(SocketEntry *e)
{
	u_char *blob, *data, *signature = NULL;
	u_int blen, dlen, slen = 0;
	int odatafellows;
	int ok = -1, flags;
	Buffer msg;
	Key *key;

	datafellows = 0;

	blob = buffer_get_string(&e->request, &blen);
	data = buffer_get_string(&e->request, &dlen);

	flags = buffer_get_int(&e->request);
	odatafellows = datafellows;
	if (flags & SSH_AGENT_OLD_SIGNATURE)
		datafellows = SSH_BUG_SIGBLOB;

	key = key_from_blob(blob, blen);
	if (key != NULL) {
		Identity *id = lookup_identity(key, 2);
		if (id != NULL && (!id->confirm || confirm_key(id) == 0))
			ok = key_sign(id->key, &signature, &slen, data, dlen);
		key_free(key);
	}
	buffer_init(&msg);
	if (ok == 0) {
		buffer_put_char(&msg, SSH2_AGENT_SIGN_RESPONSE);
		buffer_put_string(&msg, signature, slen);
	} else {
		buffer_put_char(&msg, SSH_AGENT_FAILURE);
	}
	buffer_put_int(&e->output, buffer_len(&msg));
	buffer_append(&e->output, buffer_ptr(&msg),
	    buffer_len(&msg));
	buffer_free(&msg);
	xfree(data);
	xfree(blob);
	if (signature != NULL)
		xfree(signature);
	datafellows = odatafellows;
}

/* shared */
static void
process_remove_identity(SocketEntry *e, int version)
{
	u_int blen, bits;
	int success = 0;
	Key *key = NULL;
	u_char *blob;

	switch (version) {
	case 1:
		key = key_new(KEY_RSA1);
		bits = buffer_get_int(&e->request);
		buffer_get_bignum(&e->request, key->rsa->e);
		buffer_get_bignum(&e->request, key->rsa->n);

		if (bits != key_size(key))
			logit("Warning: identity keysize mismatch: actual %u, announced %u",
			    key_size(key), bits);
		break;
	case 2:
		blob = buffer_get_string(&e->request, &blen);
		key = key_from_blob(blob, blen);
		xfree(blob);
		break;
	}
	if (key != NULL) {
		Identity *id = lookup_identity(key, version);
		if (id != NULL) {
			/*
			 * We have this key.  Free the old key.  Since we
			 * don't want to leave empty slots in the middle of
			 * the array, we actually free the key there and move
			 * all the entries between the empty slot and the end
			 * of the array.
			 */
			Idtab *tab = idtab_lookup(version);
			if (tab->nentries < 1)
				fatal("process_remove_identity: "
				    "internal error: tab->nentries %d",
				    tab->nentries);
			TAILQ_REMOVE(&tab->idlist, id, next);
			free_identity(id);
			tab->nentries--;
			success = 1;
		}
		key_free(key);
	}
	buffer_put_int(&e->output, 1);
	buffer_put_char(&e->output,
	    success ? SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE);
}

static void
process_remove_all_identities(SocketEntry *e, int version)
{
	Idtab *tab = idtab_lookup(version);
	Identity *id;

	/* Loop over all identities and clear the keys. */
	for (id = TAILQ_FIRST(&tab->idlist); id;
	    id = TAILQ_FIRST(&tab->idlist)) {
		TAILQ_REMOVE(&tab->idlist, id, next);
		free_identity(id);
	}

	/* Mark that there are no identities. */
	tab->nentries = 0;

	/* Send success. */
	buffer_put_int(&e->output, 1);
	buffer_put_char(&e->output, SSH_AGENT_SUCCESS);
}

/* removes expired keys and returns number of seconds until the next expiry */
static u_int
reaper(void)
{
	u_int deadline = 0, now = time(NULL);
	Identity *id, *nxt;
	int version;
	Idtab *tab;

	for (version = 1; version < 3; version++) {
		tab = idtab_lookup(version);
		for (id = TAILQ_FIRST(&tab->idlist); id; id = nxt) {
			nxt = TAILQ_NEXT(id, next);
			if (id->death == 0)
				continue;
			if (now >= id->death) {
				debug("expiring key '%s'", id->comment);
				TAILQ_REMOVE(&tab->idlist, id, next);
				free_identity(id);
				tab->nentries--;
			} else
				deadline = (deadline == 0) ? id->death :
				    MIN(deadline, id->death);
		}
	}
	if (deadline == 0 || deadline <= now)
		return 0;
	else
		return (deadline - now);
}

static void
process_add_identity(SocketEntry *e, int version)
{
	Idtab *tab = idtab_lookup(version);
	Identity *id;
	int type, success = 0, death = 0, confirm = 0;
	char *type_name, *comment;
	Key *k = NULL;

	switch (version) {
	case 1:
		k = key_new_private(KEY_RSA1);
		(void) buffer_get_int(&e->request);		/* ignored */
		buffer_get_bignum(&e->request, k->rsa->n);
		buffer_get_bignum(&e->request, k->rsa->e);
		buffer_get_bignum(&e->request, k->rsa->d);
		buffer_get_bignum(&e->request, k->rsa->iqmp);

		/* SSH and SSL have p and q swapped */
		buffer_get_bignum(&e->request, k->rsa->q);	/* p */
		buffer_get_bignum(&e->request, k->rsa->p);	/* q */

		/* Generate additional parameters */
		rsa_generate_additional_parameters(k->rsa);
		break;
	case 2:
		type_name = buffer_get_string(&e->request, NULL);
		type = key_type_from_name(type_name);
		xfree(type_name);
		switch (type) {
		case KEY_DSA:
			k = key_new_private(type);
			buffer_get_bignum2(&e->request, k->dsa->p);
			buffer_get_bignum2(&e->request, k->dsa->q);
			buffer_get_bignum2(&e->request, k->dsa->g);
			buffer_get_bignum2(&e->request, k->dsa->pub_key);
			buffer_get_bignum2(&e->request, k->dsa->priv_key);
			break;
		case KEY_RSA:
			k = key_new_private(type);
			buffer_get_bignum2(&e->request, k->rsa->n);
			buffer_get_bignum2(&e->request, k->rsa->e);
			buffer_get_bignum2(&e->request, k->rsa->d);
			buffer_get_bignum2(&e->request, k->rsa->iqmp);
			buffer_get_bignum2(&e->request, k->rsa->p);
			buffer_get_bignum2(&e->request, k->rsa->q);

			/* Generate additional parameters */
			rsa_generate_additional_parameters(k->rsa);
			break;
		default:
			buffer_clear(&e->request);
			goto send;
		}
		break;
	}
	/* enable blinding */
	switch (k->type) {
	case KEY_RSA:
	case KEY_RSA1:
		if (RSA_blinding_on(k->rsa, NULL) != 1) {
			error("process_add_identity: RSA_blinding_on failed");
			key_free(k);
			goto send;
		}
		break;
	}
	comment = buffer_get_string(&e->request, NULL);
	if (k == NULL) {
		xfree(comment);
		goto send;
	}
	while (buffer_len(&e->request)) {
		switch ((type = buffer_get_char(&e->request))) {
		case SSH_AGENT_CONSTRAIN_LIFETIME:
			death = time(NULL) + buffer_get_int(&e->request);
			break;
		case SSH_AGENT_CONSTRAIN_CONFIRM:
			confirm = 1;
			break;
		default:
			error("process_add_identity: "
			    "Unknown constraint type %d", type);
			xfree(comment);
			key_free(k);
			goto send;
		}
	}
	success = 1;
	if (lifetime && !death)
		death = time(NULL) + lifetime;
	if ((id = lookup_identity(k, version)) == NULL) {
		id = xmalloc(sizeof(Identity));
		id->key = k;
		TAILQ_INSERT_TAIL(&tab->idlist, id, next);
		/* Increment the number of identities. */
		tab->nentries++;
	} else {
		key_free(k);
		xfree(id->comment);
	}
	id->comment = comment;
	id->death = death;
	id->confirm = confirm;
send:
	buffer_put_int(&e->output, 1);
	buffer_put_char(&e->output,
	    success ? SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE);
}

/* XXX todo: encrypt sensitive data with passphrase */
static void
process_lock_agent(SocketEntry *e, int lock)
{
	int success = 0;
	char *passwd;

	passwd = buffer_get_string(&e->request, NULL);
	if (locked && !lock && strcmp(passwd, lock_passwd) == 0) {
		locked = 0;
		memset(lock_passwd, 0, strlen(lock_passwd));
		xfree(lock_passwd);
		lock_passwd = NULL;
		success = 1;
	} else if (!locked && lock) {
		locked = 1;
		lock_passwd = xstrdup(passwd);
		success = 1;
	}
	memset(passwd, 0, strlen(passwd));
	xfree(passwd);

	buffer_put_int(&e->output, 1);
	buffer_put_char(&e->output,
	    success ? SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE);
}

static void
no_identities(SocketEntry *e, u_int type)
{
	Buffer msg;

	buffer_init(&msg);
	buffer_put_char(&msg,
	    (type == SSH_AGENTC_REQUEST_RSA_IDENTITIES) ?
	    SSH_AGENT_RSA_IDENTITIES_ANSWER : SSH2_AGENT_IDENTITIES_ANSWER);
	buffer_put_int(&msg, 0);
	buffer_put_int(&e->output, buffer_len(&msg));
	buffer_append(&e->output, buffer_ptr(&msg), buffer_len(&msg));
	buffer_free(&msg);
}

#ifdef SMARTCARD
static void
process_add_smartcard_key(SocketEntry *e)
{
	char *sc_reader_id = NULL, *pin;
	int i, type, version, success = 0, death = 0, confirm = 0;
	Key **keys, *k;
	Identity *id;
	Idtab *tab;

	sc_reader_id = buffer_get_string(&e->request, NULL);
	pin = buffer_get_string(&e->request, NULL);

	while (buffer_len(&e->request)) {
		switch ((type = buffer_get_char(&e->request))) {
		case SSH_AGENT_CONSTRAIN_LIFETIME:
			death = time(NULL) + buffer_get_int(&e->request);
			break;
		case SSH_AGENT_CONSTRAIN_CONFIRM:
			confirm = 1;
			break;
		default:
			error("process_add_smartcard_key: "
			    "Unknown constraint type %d", type);
			xfree(sc_reader_id);
			xfree(pin);
			goto send;
		}
	}
	if (lifetime && !death)
		death = time(NULL) + lifetime;

	keys = sc_get_keys(sc_reader_id, pin);
	xfree(sc_reader_id);
	xfree(pin);

	if (keys == NULL || keys[0] == NULL) {
		error("sc_get_keys failed");
		goto send;
	}
	for (i = 0; keys[i] != NULL; i++) {
		k = keys[i];
		version = k->type == KEY_RSA1 ? 1 : 2;
		tab = idtab_lookup(version);
		if (lookup_identity(k, version) == NULL) {
			id = xmalloc(sizeof(Identity));
			id->key = k;
			id->comment = sc_get_key_label(k);
			id->death = death;
			id->confirm = confirm;
			TAILQ_INSERT_TAIL(&tab->idlist, id, next);
			tab->nentries++;
			success = 1;
		} else {
			key_free(k);
		}
		keys[i] = NULL;
	}
	xfree(keys);
send:
	buffer_put_int(&e->output, 1);
	buffer_put_char(&e->output,
	    success ? SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE);
}

static void
process_remove_smartcard_key(SocketEntry *e)
{
	char *sc_reader_id = NULL, *pin;
	int i, version, success = 0;
	Key **keys, *k = NULL;
	Identity *id;
	Idtab *tab;

	sc_reader_id = buffer_get_string(&e->request, NULL);
	pin = buffer_get_string(&e->request, NULL);
	keys = sc_get_keys(sc_reader_id, pin);
	xfree(sc_reader_id);
	xfree(pin);

	if (keys == NULL || keys[0] == NULL) {
		error("sc_get_keys failed");
		goto send;
	}
	for (i = 0; keys[i] != NULL; i++) {
		k = keys[i];
		version = k->type == KEY_RSA1 ? 1 : 2;
		if ((id = lookup_identity(k, version)) != NULL) {
			tab = idtab_lookup(version);
			TAILQ_REMOVE(&tab->idlist, id, next);
			tab->nentries--;
			free_identity(id);
			success = 1;
		}
		key_free(k);
		keys[i] = NULL;
	}
	xfree(keys);
send:
	buffer_put_int(&e->output, 1);
	buffer_put_char(&e->output,
	    success ? SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE);
}
#endif /* SMARTCARD */

/* dispatch incoming messages */

static void
process_message(SocketEntry *e)
{
	u_int msg_len, type;
	u_char *cp;

	if (buffer_len(&e->input) < 5)
		return;		/* Incomplete message. */
	cp = buffer_ptr(&e->input);
	msg_len = get_u32(cp);
	if (msg_len > 256 * 1024) {
		close_socket(e);
		return;
	}
	if (buffer_len(&e->input) < msg_len + 4)
		return;

	/* move the current input to e->request */
	buffer_consume(&e->input, 4);
	buffer_clear(&e->request);
	buffer_append(&e->request, buffer_ptr(&e->input), msg_len);
	buffer_consume(&e->input, msg_len);
	type = buffer_get_char(&e->request);

	/* check wheter agent is locked */
	if (locked && type != SSH_AGENTC_UNLOCK) {
		buffer_clear(&e->request);
		switch (type) {
		case SSH_AGENTC_REQUEST_RSA_IDENTITIES:
		case SSH2_AGENTC_REQUEST_IDENTITIES:
			/* send empty lists */
			no_identities(e, type);
			break;
		default:
			/* send a fail message for all other request types */
			buffer_put_int(&e->output, 1);
			buffer_put_char(&e->output, SSH_AGENT_FAILURE);
		}
		return;
	}

	debug("type %d", type);
	switch (type) {
	case SSH_AGENTC_LOCK:
	case SSH_AGENTC_UNLOCK:
		process_lock_agent(e, type == SSH_AGENTC_LOCK);
		break;
	/* ssh1 */
	case SSH_AGENTC_RSA_CHALLENGE:
		process_authentication_challenge1(e);
		break;
	case SSH_AGENTC_REQUEST_RSA_IDENTITIES:
		process_request_identities(e, 1);
		break;
	case SSH_AGENTC_ADD_RSA_IDENTITY:
	case SSH_AGENTC_ADD_RSA_ID_CONSTRAINED:
		process_add_identity(e, 1);
		break;
	case SSH_AGENTC_REMOVE_RSA_IDENTITY:
		process_remove_identity(e, 1);
		break;
	case SSH_AGENTC_REMOVE_ALL_RSA_IDENTITIES:
		process_remove_all_identities(e, 1);
		break;
	/* ssh2 */
	case SSH2_AGENTC_SIGN_REQUEST:
		process_sign_request2(e);
		break;
	case SSH2_AGENTC_REQUEST_IDENTITIES:
		process_request_identities(e, 2);
		break;
	case SSH2_AGENTC_ADD_IDENTITY:
	case SSH2_AGENTC_ADD_ID_CONSTRAINED:
		process_add_identity(e, 2);
		break;
	case SSH2_AGENTC_REMOVE_IDENTITY:
		process_remove_identity(e, 2);
		break;
	case SSH2_AGENTC_REMOVE_ALL_IDENTITIES:
		process_remove_all_identities(e, 2);
		break;
#ifdef SMARTCARD
	case SSH_AGENTC_ADD_SMARTCARD_KEY:
	case SSH_AGENTC_ADD_SMARTCARD_KEY_CONSTRAINED:
		process_add_smartcard_key(e);
		break;
	case SSH_AGENTC_REMOVE_SMARTCARD_KEY:
		process_remove_smartcard_key(e);
		break;
#endif /* SMARTCARD */
	default:
		/* Unknown message.  Respond with failure. */
		error("Unknown message %d", type);
		buffer_clear(&e->request);
		buffer_put_int(&e->output, 1);
		buffer_put_char(&e->output, SSH_AGENT_FAILURE);
		break;
	}
}

static void
new_socket(sock_type type, int fd)
{
	u_int i, old_alloc, new_alloc;

	set_nonblock(fd);

	if (fd > max_fd)
		max_fd = fd;

	for (i = 0; i < sockets_alloc; i++)
		if (sockets[i].type == AUTH_UNUSED) {
			sockets[i].fd = fd;
			buffer_init(&sockets[i].input);
			buffer_init(&sockets[i].output);
			buffer_init(&sockets[i].request);
			sockets[i].type = type;
			return;
		}
	old_alloc = sockets_alloc;
	new_alloc = sockets_alloc + 10;
	sockets = xrealloc(sockets, new_alloc, sizeof(sockets[0]));
	for (i = old_alloc; i < new_alloc; i++)
		sockets[i].type = AUTH_UNUSED;
	sockets_alloc = new_alloc;
	sockets[old_alloc].fd = fd;
	buffer_init(&sockets[old_alloc].input);
	buffer_init(&sockets[old_alloc].output);
	buffer_init(&sockets[old_alloc].request);
	sockets[old_alloc].type = type;
}

static int
prepare_select(fd_set **fdrp, fd_set **fdwp, int *fdl, u_int *nallocp,
    struct timeval **tvpp)
{
	u_int i, sz, deadline;
	int n = 0;
	static struct timeval tv;

	for (i = 0; i < sockets_alloc; i++) {
		switch (sockets[i].type) {
		case AUTH_SOCKET:
		case AUTH_CONNECTION:
			n = MAX(n, sockets[i].fd);
			break;
		case AUTH_UNUSED:
			break;
		default:
			fatal("Unknown socket type %d", sockets[i].type);
			break;
		}
	}

	sz = howmany(n+1, NFDBITS) * sizeof(fd_mask);
	if (*fdrp == NULL || sz > *nallocp) {
		if (*fdrp)
			xfree(*fdrp);
		if (*fdwp)
			xfree(*fdwp);
		*fdrp = xmalloc(sz);
		*fdwp = xmalloc(sz);
		*nallocp = sz;
	}
	if (n < *fdl)
		debug("XXX shrink: %d < %d", n, *fdl);
	*fdl = n;
	memset(*fdrp, 0, sz);
	memset(*fdwp, 0, sz);

	for (i = 0; i < sockets_alloc; i++) {
		switch (sockets[i].type) {
		case AUTH_SOCKET:
		case AUTH_CONNECTION:
			FD_SET(sockets[i].fd, *fdrp);
			if (buffer_len(&sockets[i].output) > 0)
				FD_SET(sockets[i].fd, *fdwp);
			break;
		default:
			break;
		}
	}
	deadline = reaper();
	if (parent_alive_interval != 0)
		deadline = (deadline == 0) ? parent_alive_interval :
		    MIN(deadline, parent_alive_interval);
	if (deadline == 0) {
		*tvpp = NULL;
	} else {
		tv.tv_sec = deadline;
		tv.tv_usec = 0;
		*tvpp = &tv;
	}
	return (1);
}

static void
after_select(fd_set *readset, fd_set *writeset)
{
	struct sockaddr_un sunaddr;
	socklen_t slen;
	char buf[1024];
	int len, sock;
	u_int i, orig_alloc;
	uid_t euid;
	gid_t egid;

	for (i = 0, orig_alloc = sockets_alloc; i < orig_alloc; i++)
		switch (sockets[i].type) {
		case AUTH_UNUSED:
			break;
		case AUTH_SOCKET:
			if (FD_ISSET(sockets[i].fd, readset)) {
				slen = sizeof(sunaddr);
				sock = accept(sockets[i].fd,
				    (struct sockaddr *)&sunaddr, &slen);
				if (sock < 0) {
					error("accept from AUTH_SOCKET: %s",
					    strerror(errno));
					break;
				}
				if (getpeereid(sock, &euid, &egid) < 0) {
					error("getpeereid %d failed: %s",
					    sock, strerror(errno));
					close(sock);
					break;
				}
				if ((euid != 0) && (getuid() != euid)) {
					error("uid mismatch: "
					    "peer euid %u != uid %u",
					    (u_int) euid, (u_int) getuid());
					close(sock);
					break;
				}
				new_socket(AUTH_CONNECTION, sock);
			}
			break;
		case AUTH_CONNECTION:
			if (buffer_len(&sockets[i].output) > 0 &&
			    FD_ISSET(sockets[i].fd, writeset)) {
				len = write(sockets[i].fd,
				    buffer_ptr(&sockets[i].output),
				    buffer_len(&sockets[i].output));
				if (len == -1 && (errno == EAGAIN ||
				    errno == EINTR))
					continue;
				if (len <= 0) {
					close_socket(&sockets[i]);
					break;
				}
				buffer_consume(&sockets[i].output, len);
			}
			if (FD_ISSET(sockets[i].fd, readset)) {
				len = read(sockets[i].fd, buf, sizeof(buf));
				if (len == -1 && (errno == EAGAIN ||
				    errno == EINTR))
					continue;
				if (len <= 0) {
					close_socket(&sockets[i]);
					break;
				}
				buffer_append(&sockets[i].input, buf, len);
				process_message(&sockets[i]);
			}
			break;
		default:
			fatal("Unknown type %d", sockets[i].type);
		}
}

static void
cleanup_socket(void)
{
	if (socket_name[0])
		unlink(socket_name);
	if (socket_dir[0])
		rmdir(socket_dir);
}

__dead void
cleanup_exit(int i)
{
	cleanup_socket();
	_exit(i);
}

/*ARGSUSED*/
static __dead void
cleanup_handler(int sig __attribute__((__unused__)))
{
	cleanup_socket();
	_exit(2);
}

static void
check_parent_exists(void)
{
	if (parent_pid != -1 && kill(parent_pid, 0) < 0) {
		/* printf("Parent has died - Authentication agent exiting.\n"); */
		cleanup_socket();
		_exit(2);
	}
}

static __dead void
usage(void)
{
	fprintf(stderr, "usage: %s [options] [command [arg ...]]\n",
	    __progname);
	fprintf(stderr, "Options:\n");
	fprintf(stderr, "  -c          Generate C-shell commands on stdout.\n");
	fprintf(stderr, "  -s          Generate Bourne shell commands on stdout.\n");
	fprintf(stderr, "  -k          Kill the current agent.\n");
	fprintf(stderr, "  -d          Debug mode.\n");
	fprintf(stderr, "  -a socket   Bind agent socket to given name.\n");
	fprintf(stderr, "  -t life     Default identity lifetime (seconds).\n");
	exit(1);
}

int
main(int ac, char **av)
{
	int c_flag = 0, d_flag = 0, k_flag = 0, s_flag = 0;
	int sock, fd, ch, result, saved_errno;
	u_int nalloc;
	char *shell, *pidstr, *agentsocket = NULL;
	const char *format;
	fd_set *readsetp = NULL, *writesetp = NULL;
	struct sockaddr_un sunaddr;
	struct rlimit rlim;
	pid_t pid;
	char pidstrbuf[1 + 3 * sizeof pid];
	struct timeval *tvp = NULL;
	size_t len;

	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

	/* drop */
	setegid(getgid());
	setgid(getgid());

	SSLeay_add_all_algorithms();

	while ((ch = getopt(ac, av, "cdksa:t:")) != -1) {
		switch (ch) {
		case 'c':
			if (s_flag)
				usage();
			c_flag++;
			break;
		case 'k':
			k_flag++;
			break;
		case 's':
			if (c_flag)
				usage();
			s_flag++;
			break;
		case 'd':
			if (d_flag)
				usage();
			d_flag++;
			break;
		case 'a':
			agentsocket = optarg;
			break;
		case 't':
			if ((lifetime = convtime(optarg)) == -1) {
				fprintf(stderr, "Invalid lifetime\n");
				usage();
			}
			break;
		default:
			usage();
		}
	}
	ac -= optind;
	av += optind;

	if (ac > 0 && (c_flag || k_flag || s_flag || d_flag))
		usage();

	if (ac == 0 && !c_flag && !s_flag) {
		shell = getenv("SHELL");
		if (shell != NULL && (len = strlen(shell)) > 2 &&
		    strncmp(shell + len - 3, "csh", 3) == 0)
			c_flag = 1;
	}
	if (k_flag) {
		const char *errstr = NULL;

		pidstr = getenv(SSH_AGENTPID_ENV_NAME);
		if (pidstr == NULL) {
			fprintf(stderr, "%s not set, cannot kill agent\n",
			    SSH_AGENTPID_ENV_NAME);
			exit(1);
		}
		pid = (int)strtonum(pidstr, 2, INT_MAX, &errstr);
		if (errstr) {
			fprintf(stderr,
			    "%s=\"%s\", which is not a good PID: %s\n",
			    SSH_AGENTPID_ENV_NAME, pidstr, errstr);
			exit(1);
		}
		if (kill(pid, SIGTERM) == -1) {
			perror("kill");
			exit(1);
		}
		format = c_flag ? "unsetenv %s;\n" : "unset %s;\n";
		printf(format, SSH_AUTHSOCKET_ENV_NAME);
		printf(format, SSH_AGENTPID_ENV_NAME);
		printf("echo Agent pid %ld killed;\n", (long)pid);
		exit(0);
	}
	parent_pid = getpid();

	if (agentsocket == NULL) {
		/* Create private directory for agent socket */
		strlcpy(socket_dir, "/tmp/ssh-XXXXXXXXXX", sizeof socket_dir);
		if (mkdtemp(socket_dir) == NULL) {
			perror("mkdtemp: private socket dir");
			exit(1);
		}
		snprintf(socket_name, sizeof socket_name, "%s/agent.%ld", socket_dir,
		    (long)parent_pid);
	} else {
		/* Try to use specified agent socket */
		socket_dir[0] = '\0';
		strlcpy(socket_name, agentsocket, sizeof socket_name);
	}

	/*
	 * Create socket early so it will exist before command gets run from
	 * the parent.
	 */
	sock = socket(AF_UNIX, SOCK_STREAM, 0);
	if (sock < 0) {
		perror("socket");
		*socket_name = '\0'; /* Don't unlink any existing file */
		cleanup_exit(1);
	}
	memset(&sunaddr, 0, sizeof(sunaddr));
	sunaddr.sun_family = AF_UNIX;
	strlcpy(sunaddr.sun_path, socket_name, sizeof(sunaddr.sun_path));
	if (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {
		perror("bind");
		*socket_name = '\0'; /* Don't unlink any existing file */
		cleanup_exit(1);
	}
	if (listen(sock, SSH_LISTEN_BACKLOG) < 0) {
		perror("listen");
		cleanup_exit(1);
	}

	/*
	 * Fork, and have the parent execute the command, if any, or present
	 * the socket data.  The child continues as the authentication agent.
	 */
	if (d_flag) {
		log_init(__progname, SYSLOG_LEVEL_DEBUG1, SYSLOG_FACILITY_AUTH, 1);
		format = c_flag ? "setenv %s %s;\n" : "%s=%s; export %s;\n";
		printf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,
		    SSH_AUTHSOCKET_ENV_NAME);
		printf("echo Agent pid %ld;\n", (long)parent_pid);
		goto skip;
	}
	pid = fork();
	if (pid == -1) {
		perror("fork");
		cleanup_exit(1);
	}
	if (pid != 0) {		/* Parent - execute the given command. */
		close(sock);
		snprintf(pidstrbuf, sizeof pidstrbuf, "%ld", (long)pid);
		if (ac == 0) {
			format = c_flag ? "setenv %s %s;\n" : "%s=%s; export %s;\n";
			printf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,
			    SSH_AUTHSOCKET_ENV_NAME);
			printf(format, SSH_AGENTPID_ENV_NAME, pidstrbuf,
			    SSH_AGENTPID_ENV_NAME);
			printf("echo Agent pid %ld;\n", (long)pid);
			exit(0);
		}
		if (setenv(SSH_AUTHSOCKET_ENV_NAME, socket_name, 1) == -1 ||
		    setenv(SSH_AGENTPID_ENV_NAME, pidstrbuf, 1) == -1) {
			perror("setenv");
			exit(1);
		}
		execvp(av[0], av);
		perror(av[0]);
		exit(1);
	}
	/* child */
	log_init(__progname, SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_AUTH, 0);

	if (setsid() == -1) {
		error("setsid: %s", strerror(errno));
		cleanup_exit(1);
	}

	(void)chdir("/");
	if ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {
		/* XXX might close listen socket */
		(void)dup2(fd, STDIN_FILENO);
		(void)dup2(fd, STDOUT_FILENO);
		(void)dup2(fd, STDERR_FILENO);
		if (fd > 2)
			close(fd);
	}

	/* deny core dumps, since memory contains unencrypted private keys */
	rlim.rlim_cur = rlim.rlim_max = 0;
	if (setrlimit(RLIMIT_CORE, &rlim) < 0) {
		error("setrlimit RLIMIT_CORE: %s", strerror(errno));
		cleanup_exit(1);
	}

skip:
	new_socket(AUTH_SOCKET, sock);
	if (ac > 0)
		parent_alive_interval = 10;
	idtab_init();
	if (!d_flag)
		signal(SIGINT, SIG_IGN);
	signal(SIGPIPE, SIG_IGN);
	signal(SIGHUP, cleanup_handler);
	signal(SIGTERM, cleanup_handler);
	nalloc = 0;

	while (1) {
		prepare_select(&readsetp, &writesetp, &max_fd, &nalloc, &tvp);
		result = select(max_fd + 1, readsetp, writesetp, NULL, tvp);
		saved_errno = errno;
		if (parent_alive_interval != 0)
			check_parent_exists();
		(void) reaper();	/* remove expired keys */
		if (result < 0) {
			if (saved_errno == EINTR)
				continue;
			fatal("select: %s", strerror(saved_errno));
		} else if (result > 0)
			after_select(readsetp, writesetp);
	}
	/* NOTREACHED */
}
@


1.17
log
@• merge newer OpenSSH
• KNF in our diff – style(9)
• some const cleanliness (build with __CRAZY=Yes mostly)
@
text
@d4 2
d69 1
a69 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh-agent.c,v 1.16 2008/12/27 21:17:58 tg Exp $");
d994 1
a994 1
cleanup_handler(int sig __attribute__((unused)))
@


1.16
log
@merge and wrap exec/exit functions better
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.159 2008/06/28 14:05:15 djm Exp $ */
d67 1
a67 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh-agent.c,v 1.15 2008/12/16 22:13:30 tg Exp $");
a299 1
	extern int datafellows;
d907 1
a907 1
	u_int i;
d911 1
a911 1
	for (i = 0; i < sockets_alloc; i++)
d944 6
a949 9
				do {
					len = write(sockets[i].fd,
					    buffer_ptr(&sockets[i].output),
					    buffer_len(&sockets[i].output));
					if (len == -1 && (errno == EAGAIN ||
					    errno == EINTR))
						continue;
					break;
				} while (1);
d957 4
a960 7
				do {
					len = read(sockets[i].fd, buf, sizeof(buf));
					if (len == -1 && (errno == EAGAIN ||
					    errno == EINTR))
						continue;
					break;
				} while (1);
d1037 1
d1089 2
a1090 2
		if (shell != NULL &&
		    strncmp(shell + strlen(shell) - 3, "csh", 3) == 0)
@


1.15
log
@really merge OpenSSH-current into MirBSD Secure SHell 10uA4
@
text
@d67 1
a67 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh-agent.c,v 1.14 2008/12/16 20:55:29 tg Exp $");
a1198 1
		arc4_preexec();
@


1.14
log
@fastmerge, do not use yet!
@
text
@d67 1
a67 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh-agent.c,v 1.13 2007/10/02 01:20:23 tg Exp $");
d1199 1
@


1.13
log
@fastmerge
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.157 2007/09/25 23:48:57 canacar Exp $ */
d67 1
a67 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh-agent.c,v 1.12 2007/09/13 13:52:54 tg Exp $");
d300 2
d312 1
d338 1
a517 1
	success = 1;
d519 1
a519 1
		switch (buffer_get_char(&e->request)) {
d527 5
a531 1
			break;
d534 1
d600 1
a600 1
process_add_smartcard_key (SocketEntry *e)
d603 1
a603 1
	int i, version, success = 0, death = 0, confirm = 0;
d612 1
a612 1
		switch (buffer_get_char(&e->request)) {
d620 5
a624 1
			break;
@


1.12
log
@merge and make UMAC-64 default message integrity whatever
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.156 2007/09/09 11:38:01 sobrado Exp $ */
d67 1
a67 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh-agent.c,v 1.11 2007/04/29 20:23:14 tg Exp $");
d446 1
d529 2
a530 2
	if (lookup_identity(k, version) == NULL) {
		Identity *id = xmalloc(sizeof(Identity));
a531 3
		id->comment = comment;
		id->death = death;
		id->confirm = confirm;
d537 1
a537 1
		xfree(comment);
d539 3
@


1.11
log
@merge openssh
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.155 2007/03/19 12:16:42 dtucker Exp $ */
d67 1
a67 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh-agent.c,v 1.10 2007/03/08 10:09:33 tg Exp $");
d1005 1
a1005 1
	fprintf(stderr, "Usage: %s [options] [command [args ...]]\n",
@


1.10
log
@merge OpenSSH 4.6, retain local changes
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.154 2007/02/28 00:55:30 dtucker Exp $ */
d67 1
a67 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh-agent.c,v 1.9 2006/10/13 18:40:50 tg Exp $");
d110 1
d411 2
a412 1
static void
d415 1
a415 1
	u_int now = time(NULL);
d424 3
a426 1
			if (id->death != 0 && now >= id->death) {
d431 3
a433 1
			}
d436 4
d825 2
a826 1
prepare_select(fd_set **fdrp, fd_set **fdwp, int *fdl, u_int *nallocp)
d828 1
a828 1
	u_int i, sz;
d830 1
d874 11
a991 1
/*ARGSUSED*/
d993 1
a993 1
check_parent_exists(int sig)
a994 2
	int save_errno = errno;

d997 2
a998 1
		cleanup_handler(sig); /* safe */
a999 3
	signal(SIGALRM, check_parent_exists);
	alarm(10);
	errno = save_errno;
d1030 1
a1030 1
	struct timeval tv;
d1217 2
a1218 4
	if (ac > 0) {
		signal(SIGALRM, check_parent_exists);
		alarm(10);
	}
d1228 2
a1229 4
		tv.tv_sec = 10;
		tv.tv_usec = 0;
		prepare_select(&readsetp, &writesetp, &max_fd, &nalloc);
		result = select(max_fd + 1, readsetp, writesetp, NULL, &tv);
d1231 3
a1233 1
		reaper();	/* remove expired keys */
@


1.9
log
@merge the 4.0 equivalent of 015_ssh.patch
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.153 2006/10/06 02:29:19 djm Exp $ */
d67 1
a67 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh-agent.c,v 1.8 2006/09/20 21:41:05 tg Exp $");
d423 1
a687 3
	/* kill dead keys */
	reaper();

d1003 1
a1003 1
	int sock, fd, ch;
d1012 1
d1212 2
d1215 5
a1219 2
		if (select(max_fd + 1, readsetp, writesetp, NULL, NULL) < 0) {
			if (errno == EINTR)
d1221 3
a1223 3
			fatal("select: %s", strerror(errno));
		}
		after_select(readsetp, writesetp);
@


1.8
log
@finish merging
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.152 2006/08/04 20:46:05 stevesk Exp $ */
d38 1
a40 1
#include <sys/types.h>
a42 1
#include <sys/time.h>
d67 1
a67 1
__RCSID("$MirOS$");
@


1.7
log
@fastmerge, bump vsn
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.140 2006/06/13 02:17:07 djm Exp $ */
d37 1
a37 3
#include "includes.h"
__RCSID("$MirOS: src/usr.bin/ssh/ssh-agent.c,v 1.6 2006/06/02 20:50:50 tg Exp $");

d40 2
d43 4
d48 2
d52 5
d58 1
a58 3
#include <openssl/evp.h>
#include <md5.h>

a61 2
#include "bufaux.h"
#include "xmalloc.h"
d68 2
d271 4
a274 4
		MD5Init(&md);
		MD5Update(&md, buf, 32);
		MD5Update(&md, session_id, 16);
		MD5Final(mdbuf, &md);
d1006 1
a1006 1
	int sock, fd,  ch;
@


1.6
log
@* merge
* remove all references to GSSAPI, Kerberos and AFS
* uint*_t -> u_int*_t for consistency, like openbsd
  (note: MirOS style(9) suggests uint32_t etc. instead!)
* bump vsn
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.138 2006/05/17 12:43:34 markus Exp $ */
d38 1
a38 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh-agent.c,v 1.5 2006/04/19 10:40:54 tg Exp $");
@


1.5
log
@merge and clean up
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.137 2006/03/30 09:58:16 djm Exp $ */
d38 1
a38 1
__RCSID("$MirOS: src/usr.bin/ssh/ssh-agent.c,v 1.4 2006/02/22 02:16:49 tg Exp $");
d309 1
a310 1
	key_free(key);
@


1.4
log
@fix a lot of and kludge a few more __CRAZY problems, sync rcs id
@
text
@d1 1
d38 1
a38 1
RCSID("$MirOS: src/usr.bin/ssh/ssh-agent.c,v 1.3 2006/02/22 01:23:51 tg Exp $");
a54 1
#include "getput.h"
d104 2
a105 2
char socket_name[1024];
char socket_dir[1024];
d685 1
a685 1
	msg_len = GET_32BIT(cp);
d797 1
a797 4
	if (sockets)
		sockets = xrealloc(sockets, new_alloc * sizeof(sockets[0]));
	else
		sockets = xmalloc(new_alloc * sizeof(sockets[0]));
d878 1
a878 1
				    (struct sockaddr *) &sunaddr, &slen);
d955 1
d963 1
d1057 2
a1058 1
		if (shell != NULL && strncmp(shell + strlen(shell) - 3, "csh", 3) == 0)
d1062 2
d1070 5
a1074 4
		pid = atoi(pidstr);
		if (pid < 1) {
			fprintf(stderr, "%s=\"%s\", which is not a good PID\n",
			    SSH_AGENTPID_ENV_NAME, pidstr);
d1117 1
a1117 1
	if (bind(sock, (struct sockaddr *) & sunaddr, sizeof(sunaddr)) < 0) {
@


1.3
log
@merge; bump version; fix up manpages and includes a little
@
text
@d37 1
a37 1
RCSID("$MirOS: src/usr.bin/ssh/ssh-agent.c,v 1.2 2006/02/21 02:12:25 tg Exp $");
a290 1
	extern int datafellows;
d951 1
a951 1
void
d958 2
a959 2
static void
cleanup_handler(int sig)
d979 1
a979 1
static void
d1000 2
a1001 1
	char *shell, *format, *pidstr, *agentsocket = NULL;
a1004 2
	extern int optind;
	extern char *optarg;
@


1.2
log
@use libc MD5, not openssl one
@
text
@d37 2
d40 5
a44 1
RCSID("$MirOS: ssh-agent.c,v 1.124 2005/10/30 08:52:18 djm Exp $");
@


1.1
log
@Initial revision
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.122 2004/10/29 22:53:56 djm Exp $");
d41 1
a41 1
#include <openssl/md5.h>
d256 4
a259 4
		MD5_Init(&md);
		MD5_Update(&md, buf, 32);
		MD5_Update(&md, session_id, 16);
		MD5_Final(mdbuf, &md);
d354 1
a354 1
			 * don\'t want to leave empty slots in the middle of
d1004 3
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import current OpenSSH
@
text
@d38 1
a38 1
RCSID("$OpenBSD: ssh-agent.c,v 1.124 2005/10/30 08:52:18 djm Exp $");
d354 1
a354 1
			 * don't want to leave empty slots in the middle of
a1003 3
	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

@


1.1.1.3
log
@import OpenSSH-current
@
text
@a36 2
RCSID("$OpenBSD: ssh-agent.c,v 1.129 2006/02/20 17:02:44 stevesk Exp $");

d38 1
a38 6
#include <sys/resource.h>
#include <sys/types.h>
#include <sys/un.h>

#include <paths.h>
#include <signal.h>
@


1.1.1.4
log
@I decided we'd better upgrade OpenSSH before releasing to the general public
@
text
@a0 1
/* $OpenBSD: ssh-agent.c,v 1.137 2006/03/30 09:58:16 djm Exp $ */
d37 1
d55 1
d105 2
a106 2
char socket_name[MAXPATHLEN];
char socket_dir[MAXPATHLEN];
d687 1
a687 1
	msg_len = get_u32(cp);
d799 4
a802 1
	sockets = xrealloc(sockets, new_alloc, sizeof(sockets[0]));
d883 1
a883 1
				    (struct sockaddr *)&sunaddr, &slen);
a959 1
/*ARGSUSED*/
a966 1
/*ARGSUSED*/
d1061 1
a1061 2
		if (shell != NULL &&
		    strncmp(shell + strlen(shell) - 3, "csh", 3) == 0)
a1064 2
		const char *errstr = NULL;

d1071 4
a1074 5
		pid = (int)strtonum(pidstr, 2, INT_MAX, &errstr);
		if (errstr) {
			fprintf(stderr,
			    "%s=\"%s\", which is not a good PID: %s\n",
			    SSH_AGENTPID_ENV_NAME, pidstr, errstr);
d1117 1
a1117 1
	if (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) < 0) {
@


1.1.1.5
log
@if we're gonna push out another snapshot, we'd better have sshd-current
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.138 2006/05/17 12:43:34 markus Exp $ */
a309 1
		key_free(key);
d311 1
@


1.1.1.6
log
@Import latest OpenSSH, contains coverity fixes etc.
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.140 2006/06/13 02:17:07 djm Exp $ */
@


1.1.1.7
log
@import a few security-wise relevant changes right now
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.152 2006/08/04 20:46:05 stevesk Exp $ */
d37 2
a38 1
#include <sys/types.h>
a41 1
#include <sys/socket.h>
d43 3
a45 2
#include <sys/time.h>
#include <sys/param.h>
a49 11
#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <signal.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "xmalloc.h"
d53 2
d998 1
a998 1
	int sock, fd, ch;
@


1.1.1.8
log
@OpenSSH 4.5 (security)
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.153 2006/10/06 02:29:19 djm Exp $ */
a37 1
#include <sys/time.h>
d43 1
@


1.1.1.9
log
@Import OpenSSH 4.6
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.154 2007/02/28 00:55:30 dtucker Exp $ */
a423 1
				debug("expiring key '%s'", id->comment);
d688 3
d1006 1
a1006 1
	int sock, fd, ch, result, saved_errno;
a1015 1
	struct timeval tv;
a1214 2
		tv.tv_sec = 10;
		tv.tv_usec = 0;
d1216 2
a1217 5
		result = select(max_fd + 1, readsetp, writesetp, NULL, &tv);
		saved_errno = errno;
		reaper();	/* remove expired keys */
		if (result < 0) {
			if (saved_errno == EINTR)
d1219 3
a1221 3
			fatal("select: %s", strerror(saved_errno));
		} else if (result > 0)
			after_select(readsetp, writesetp);
@


1.1.1.10
log
@import openbsd compress, ssh, perl, sendmail for minor bugfixes
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.155 2007/03/19 12:16:42 dtucker Exp $ */
a109 1
u_int parent_alive_interval = 0;
d411 1
a411 2
/* removes expired keys and returns number of seconds until the next expiry */
static u_int
d414 1
a414 1
	u_int deadline = 0, now = time(NULL);
d423 1
a423 3
			if (id->death == 0)
				continue;
			if (now >= id->death) {
d428 1
a428 3
			} else
				deadline = (deadline == 0) ? id->death :
				    MIN(deadline, id->death);
a430 4
	if (deadline == 0 || deadline <= now)
		return 0;
	else
		return (deadline - now);
d816 1
a816 2
prepare_select(fd_set **fdrp, fd_set **fdwp, int *fdl, u_int *nallocp,
    struct timeval **tvpp)
d818 1
a818 1
	u_int i, sz, deadline;
a819 1
	static struct timeval tv;
a862 11
	deadline = reaper();
	if (parent_alive_interval != 0)
		deadline = (deadline == 0) ? parent_alive_interval :
		    MIN(deadline, parent_alive_interval);
	if (deadline == 0) {
		*tvpp = NULL;
	} else {
		tv.tv_sec = deadline;
		tv.tv_usec = 0;
		*tvpp = &tv;
	}
d970 1
d972 1
a972 1
check_parent_exists(void)
d974 2
d978 1
a978 2
		cleanup_socket();
		_exit(2);
d980 3
d1014 1
a1014 1
	struct timeval *tvp = NULL;
d1201 4
a1204 2
	if (ac > 0)
		parent_alive_interval = 10;
d1214 4
a1217 2
		prepare_select(&readsetp, &writesetp, &max_fd, &nalloc, &tvp);
		result = select(max_fd + 1, readsetp, writesetp, NULL, tvp);
d1219 1
a1219 3
		if (parent_alive_interval != 0)
			check_parent_exists();
		(void) reaper();	/* remove expired keys */
@


1.1.1.11
log
@Import latest OpenSSH upgrades
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.156 2007/09/09 11:38:01 sobrado Exp $ */
d1006 1
a1006 1
	fprintf(stderr, "usage: %s [options] [command [arg ...]]\n",
@


1.1.1.12
log
@pull in some more fixes from obsd, but not that big unifdef session,
since we undefine BSD auth for bsd.rd (yet)
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.157 2007/09/25 23:48:57 canacar Exp $ */
a446 1
	Identity *id;
d529 2
a530 2
	if ((id = lookup_identity(k, version)) == NULL) {
		id = xmalloc(sizeof(Identity));
d532 3
d540 1
a540 1
		xfree(id->comment);
a541 3
	id->comment = comment;
	id->death = death;
	id->confirm = confirm;
@


1.1.1.13
log
@OpenSSH-current
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.159 2008/06/28 14:05:15 djm Exp $ */
a300 1
	int odatafellows;
a310 1
	odatafellows = datafellows;
a335 1
	datafellows = odatafellows;
d515 1
d517 1
a517 1
		switch ((type = buffer_get_char(&e->request))) {
d525 1
a525 5
			error("process_add_identity: "
			    "Unknown constraint type %d", type);
			xfree(comment);
			key_free(k);
			goto send;
a527 1
	success = 1;
d593 1
a593 1
process_add_smartcard_key(SocketEntry *e)
d596 1
a596 1
	int i, type, version, success = 0, death = 0, confirm = 0;
d605 1
a605 1
		switch ((type = buffer_get_char(&e->request))) {
d613 1
a613 5
			error("process_add_smartcard_key: "
			    "Unknown constraint type %d", type);
			xfree(sc_reader_id);
			xfree(pin);
			goto send;
@


1.1.1.14
log
@Let’s play the version number game – OpenSSH 5.3-current
@
text
@d1 1
a1 1
/* $OpenBSD: ssh-agent.c,v 1.162 2009/09/01 14:43:17 djm Exp $ */
d908 1
a908 1
	u_int i, orig_alloc;
d912 1
a912 1
	for (i = 0, orig_alloc = sockets_alloc; i < orig_alloc; i++)
d945 9
a953 6
				len = write(sockets[i].fd,
				    buffer_ptr(&sockets[i].output),
				    buffer_len(&sockets[i].output));
				if (len == -1 && (errno == EAGAIN ||
				    errno == EINTR))
					continue;
d961 7
a967 4
				len = read(sockets[i].fd, buf, sizeof(buf));
				if (len == -1 && (errno == EAGAIN ||
				    errno == EINTR))
					continue;
a1044 1
	size_t len;
d1096 2
a1097 2
		if (shell != NULL && (len = strlen(shell)) > 2 &&
		    strncmp(shell + len - 3, "csh", 3) == 0)
@


