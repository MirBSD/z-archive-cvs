head	1.22;
access;
symbols
	cvs-200910041320:1.1.1.17
	cvs-200903221200:1.1.1.16
	cvs-200812162015:1.1.1.15
	cvs-200804031830:1.1.1.14
	MIRBSD_10:1.16.0.2
	MIRBSD_10_BASE:1.16
	cvs-200803022030:1.1.1.14
	cvs-200709131337:1.1.1.13
	cvs-200709021830:1.1.1.13
	cvs-200708201200:1.1.1.13
	cvs-200706161500:1.1.1.13
	cvs-200705192215:1.1.1.13
	cvs-200704292000:1.1.1.13
	cvs-200703080900:1.1.1.13
	cvs-200701251600:1.1.1.13
	cvs-200612111600:1.1.1.12
	cvs-200611090230:1.1.1.11
	OPENBSD_4_0:1.1.1.10
	MIRBSD_9_BASE:1.10
	cvs-200606162342:1.1.1.9
	cvs-200606022000:1.1.1.9
	cvs-200604191000:1.1.1.8
	cvs-200602220045:1.1.1.7
	MIRBSD_8:1.7.0.2
	MIRBSD_8_BASE:1.7
	cvs-200512201942:1.1.1.6
	cvs-200511231930:1.1.1.5
	cvs-200507211800:1.1.1.4
	cvs-200506221550:1.1.1.3
	cvs-200505050030:1.1.1.2
	cvs-200504291700:1.1.1.2
	cvs-200504261445:1.1.1.2
	cvs-200504141900:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2010.10.08.20.18.55;	author tg;	state Exp;
branches;
next	1.21;
commitid	1004CAF7CB4313A67AD;

1.21
date	2009.10.04.14.29.09;	author tg;	state Exp;
branches;
next	1.20;
commitid	1004AC8B1276FC00211;

1.20
date	2009.03.22.15.01.20;	author tg;	state Exp;
branches;
next	1.19;
commitid	10049C652CD5CCC321F;

1.19
date	2008.12.27.21.17.58;	author tg;	state Exp;
branches;
next	1.18;
commitid	10049569B9439744217;

1.18
date	2008.12.16.22.13.30;	author tg;	state Exp;
branches;
next	1.17;
commitid	10049482819766381ED;

1.17
date	2008.12.16.20.55.28;	author tg;	state Exp;
branches;
next	1.16;
commitid	100494815C97ECEEDBF;

1.16
date	2008.03.02.21.14.22;	author tg;	state Exp;
branches;
next	1.15;
commitid	10047CB18BB506A8527;

1.15
date	2007.01.25.16.18.37;	author tg;	state Exp;
branches;
next	1.14;
commitid	10045B8D86E5B698AD6;

1.14
date	2006.12.11.20.22.09;	author tg;	state Exp;
branches;
next	1.13;
commitid	100457DBDF745B9BD3B;

1.13
date	2006.10.02.23.26.01;	author tg;	state Exp;
branches;
next	1.12;
commitid	1004521A00B49D3CF7C;

1.12
date	2006.09.20.21.41.04;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004511B578580E7F04;

1.11
date	2006.08.12.14.26.09;	author tg;	state Exp;
branches;
next	1.10;
commitid	10044DDE4FC6BC29E9D;

1.10
date	2006.06.02.20.50.49;	author tg;	state Exp;
branches;
next	1.9;
commitid	1004480A4952B0D84EA;

1.9
date	2006.04.19.10.40.53;	author tg;	state Exp;
branches;
next	1.8;
commitid	100444613BD3A91C28B;

1.8
date	2006.02.22.01.23.51;	author tg;	state Exp;
branches;
next	1.7;
commitid	10043FBBD2C2C5E7D81;

1.7
date	2005.12.20.19.57.35;	author tg;	state Exp;
branches;
next	1.6;
commitid	10043A8623F4C1F637E;

1.6
date	2005.11.23.19.45.15;	author tg;	state Exp;
branches;
next	1.5;
commitid	29f4384c6def7d1;

1.5
date	2005.11.23.18.04.20;	author tg;	state Exp;
branches;
next	1.4;
commitid	af74384af2ab463;

1.4
date	2005.06.22.16.11.39;	author tg;	state Exp;
branches;
next	1.3;
commitid	598b42b98dcf335f;

1.3
date	2005.04.14.19.49.34;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.13.18.33.31;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.29.55;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.29.55;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.14.19.33.29;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.06.22.15.56.28;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	181342b98a38fe99;

1.1.1.4
date	2005.07.21.21.00.32;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	560042e0092f571e;

1.1.1.5
date	2005.11.23.19.34.15;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	116a4384c4467ffc;

1.1.1.6
date	2005.12.20.19.43.45;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	10043A85EF81EF097CF;

1.1.1.7
date	2006.02.22.00.51.36;	author tg;	state Exp;
branches;
next	1.1.1.8;
commitid	10043FBB5A933C3BB9B;

1.1.1.8
date	2006.04.19.10.15.04;	author tg;	state Exp;
branches;
next	1.1.1.9;
commitid	10044460DB21E1F715C;

1.1.1.9
date	2006.06.02.20.31.52;	author tg;	state Exp;
branches;
next	1.1.1.10;
commitid	1004480A0422110D712;

1.1.1.10
date	2006.09.20.19.06.50;	author tg;	state Exp;
branches;
next	1.1.1.11;
commitid	10045119150397FC669;

1.1.1.11
date	2006.11.09.02.38.01;	author tg;	state Exp;
branches;
next	1.1.1.12;
commitid	100455294981A6201C8;

1.1.1.12
date	2006.12.11.16.19.10;	author tg;	state Exp;
branches;
next	1.1.1.13;
commitid	100457D84FB7120C6DA;

1.1.1.13
date	2007.01.25.16.13.17;	author tg;	state Exp;
branches;
next	1.1.1.14;
commitid	10045B8D7100791C016;

1.1.1.14
date	2008.03.02.20.40.42;	author tg;	state Exp;
branches;
next	1.1.1.15;
commitid	10047CB10DD30FAF062;

1.1.1.15
date	2008.12.16.20.15.34;	author tg;	state Exp;
branches;
next	1.1.1.16;
commitid	10049480C7A2701F5C0;

1.1.1.16
date	2009.03.22.12.03.00;	author tg;	state Exp;
branches;
next	1.1.1.17;
commitid	10049C6290649163EA3;

1.1.1.17
date	2009.10.04.13.25.45;	author tg;	state Exp;
branches;
next	;
commitid	1004AC8A2663BC008C5;


desc
@@


1.22
log
@pull in NetBSD SA2010-008, thanks Tonnerre for mentioning
@
text
@/* $OpenBSD: sftp.c,v 1.111 2009/08/18 18:36:21 djm Exp $ */
/*
 * Copyright (c) 2001-2004 Damien Miller <djm@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/statvfs.h>

#include <ctype.h>
#include <errno.h>
#include <glob.h>
#include <histedit.h>
#include <paths.h>
#include <libgen.h>
#include <signal.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <util.h>
#include <stdarg.h>

#include "xmalloc.h"
#include "log.h"
#include "pathnames.h"
#include "misc.h"

#include "sftp.h"
#include "buffer.h"
#include "sftp-common.h"
#include "sftp-client.h"

__RCSID("$MirOS: src/usr.bin/ssh/sftp.c,v 1.21 2009/10/04 14:29:09 tg Exp $");

extern const char *__progname;

/* File to read commands from */
FILE* infile;

/* Are we in batchfile mode? */
int batchmode = 0;

/* Size of buffer used when copying files */
size_t copy_buffer_len = 32768;

/* Number of concurrent outstanding requests */
size_t num_requests = 64;

/* PID of ssh transport process */
static pid_t sshpid = -1;

/* This is set to 0 if the progressmeter is not desired. */
int showprogress = 1;

/* When this option is set, we always recursively download/upload directories */
int global_rflag = 0;

/* When this option is set, the file transfers will always preserve times */
int global_pflag = 0;

/* SIGINT received during command processing */
volatile sig_atomic_t interrupted = 0;

/* I wish qsort() took a separate ctx for the comparison function...*/
int sort_flag;

int remote_glob(struct sftp_conn *, const char *, int,
    int (*)(const char *, int), glob_t *); /* proto for sftp-glob.c */

/* Separators for interactive commands */
#define WHITESPACE " \t\r\n"

/* ls flags */
#define LS_LONG_VIEW	0x01	/* Full view ala ls -l */
#define LS_SHORT_VIEW	0x02	/* Single row view ala ls -1 */
#define LS_NUMERIC_VIEW	0x04	/* Long view with numeric uid/gid */
#define LS_NAME_SORT	0x08	/* Sort by name (default) */
#define LS_TIME_SORT	0x10	/* Sort by mtime */
#define LS_SIZE_SORT	0x20	/* Sort by file size */
#define LS_REVERSE_SORT	0x40	/* Reverse sort order */
#define LS_SHOW_ALL	0x80	/* Don't skip filenames starting with '.' */

#define VIEW_FLAGS	(LS_LONG_VIEW|LS_SHORT_VIEW|LS_NUMERIC_VIEW)
#define SORT_FLAGS	(LS_NAME_SORT|LS_TIME_SORT|LS_SIZE_SORT)

/* Commands for interactive mode */
#define I_CHDIR		1
#define I_CHGRP		2
#define I_CHMOD		3
#define I_CHOWN		4
#define I_DF		24
#define I_GET		5
#define I_HELP		6
#define I_LCHDIR	7
#define I_LLS		8
#define I_LMKDIR	9
#define I_LPWD		10
#define I_LS		11
#define I_LUMASK	12
#define I_MKDIR		13
#define I_PUT		14
#define I_PWD		15
#define I_QUIT		16
#define I_RENAME	17
#define I_RM		18
#define I_RMDIR		19
#define I_SHELL		20
#define I_SYMLINK	21
#define I_VERSION	22
#define I_PROGRESS	23

struct CMD {
	const char *c;
	const int n;
};

static const struct CMD cmds[] = {
	{ "bye",	I_QUIT },
	{ "cd",		I_CHDIR },
	{ "chdir",	I_CHDIR },
	{ "chgrp",	I_CHGRP },
	{ "chmod",	I_CHMOD },
	{ "chown",	I_CHOWN },
	{ "df",		I_DF },
	{ "dir",	I_LS },
	{ "exit",	I_QUIT },
	{ "get",	I_GET },
	{ "mget",	I_GET },
	{ "help",	I_HELP },
	{ "lcd",	I_LCHDIR },
	{ "lchdir",	I_LCHDIR },
	{ "lls",	I_LLS },
	{ "lmkdir",	I_LMKDIR },
	{ "ln",		I_SYMLINK },
	{ "lpwd",	I_LPWD },
	{ "ls",		I_LS },
	{ "lumask",	I_LUMASK },
	{ "mkdir",	I_MKDIR },
	{ "progress",	I_PROGRESS },
	{ "put",	I_PUT },
	{ "mput",	I_PUT },
	{ "pwd",	I_PWD },
	{ "quit",	I_QUIT },
	{ "rename",	I_RENAME },
	{ "rm",		I_RM },
	{ "rmdir",	I_RMDIR },
	{ "symlink",	I_SYMLINK },
	{ "version",	I_VERSION },
	{ "!",		I_SHELL },
	{ "?",		I_HELP },
	{ NULL,			-1}
};

int interactive_loop(int fd_in, int fd_out, char *file1, char *file2);

/* ARGSUSED */
static __dead void
killchild(int signo)
{
	if (sshpid > 1) {
		kill(sshpid, SIGTERM);
		waitpid(sshpid, NULL, 0);
	}

	_exit(1);
}

/* ARGSUSED */
static void
cmd_interrupt(int signo)
{
	const char msg[] = "\rInterrupt  \n";
	int olderrno = errno;

	write(STDERR_FILENO, msg, sizeof(msg) - 1);
	interrupted = 1;
	errno = olderrno;
}

static void
help(void)
{
	printf("Available commands:\n"
	    "bye                                Quit sftp\n"
	    "cd path                            Change remote directory to 'path'\n"
	    "chgrp grp path                     Change group of file 'path' to 'grp'\n"
	    "chmod mode path                    Change permissions of file 'path' to 'mode'\n"
	    "chown own path                     Change owner of file 'path' to 'own'\n"
	    "df [-hi] [path]                    Display statistics for current directory or\n"
	    "                                   filesystem containing 'path'\n"
	    "exit                               Quit sftp\n"
	    "get [-Pr] remote-path [local-path] Download file\n"
	    "help                               Display this help text\n"
	    "lcd path                           Change local directory to 'path'\n"
	    "lls [ls-options [path]]            Display local directory listing\n"
	    "lmkdir path                        Create local directory\n"
	    "ln oldpath newpath                 Symlink remote file\n"
	    "lpwd                               Print local working directory\n"
	    "ls [-1aflnrSt] [path]              Display remote directory listing\n"
	    "lumask umask                       Set local umask to 'umask'\n"
	    "mkdir path                         Create remote directory\n"
	    "progress                           Toggle display of progress meter\n"
	    "put [-Pr] local-path [remote-path] Upload file\n"
	    "pwd                                Display remote working directory\n"
	    "quit                               Quit sftp\n"
	    "rename oldpath newpath             Rename remote file\n"
	    "rm path                            Delete remote file\n"
	    "rmdir path                         Remove remote directory\n"
	    "symlink oldpath newpath            Symlink remote file\n"
	    "version                            Show SFTP version\n"
	    "!command                           Execute 'command' in local shell\n"
	    "!                                  Escape to local shell\n"
	    "?                                  Synonym for help\n");
}

static void
local_do_shell(const char *args)
{
	int status;
	char *shell;
	pid_t pid;

	if (!*args)
		args = NULL;

	if ((shell = getenv("SHELL")) == NULL)
		shell = (char *)_PATH_BSHELL;

	if ((pid = fork()) == -1)
		fatal("Couldn't fork: %s", strerror(errno));

	if (pid == 0) {
		/* XXX: child has pipe fds to ssh subproc open - issue? */
		if (args) {
			debug3("Executing %s -c \"%s\"", shell, args);
			execl(shell, shell, "-c", args, (char *)NULL);
		} else {
			debug3("Executing %s", shell);
			execl(shell, shell, (char *)NULL);
		}
		fprintf(stderr, "Couldn't execute \"%s\": %s\n", shell,
		    strerror(errno));
		_exit(1);
	}
	while (waitpid(pid, &status, 0) == -1)
		if (errno != EINTR)
			fatal("Couldn't wait for child: %s", strerror(errno));
	if (!WIFEXITED(status))
		error("Shell exited abnormally");
	else if (WEXITSTATUS(status))
		error("Shell exited with status %d", WEXITSTATUS(status));
}

static void
local_do_ls(const char *args)
{
	if (!args || !*args)
		local_do_shell(_PATH_LS);
	else {
		int len = strlen(_PATH_LS " ") + strlen(args) + 1;
		char *buf = xmalloc(len);

		/* XXX: quoting - rip quoting code from ftp? */
		snprintf(buf, len, _PATH_LS " %s", args);
		local_do_shell(buf);
		xfree(buf);
	}
}

/* Strip one path (usually the pwd) from the start of another */
static char *
path_strip(char *path, char *strip)
{
	size_t len;

	if (strip == NULL)
		return (xstrdup(path));

	len = strlen(strip);
	if (strncmp(path, strip, len) == 0) {
		if (strip[len - 1] != '/' && path[len] == '/')
			len++;
		return (xstrdup(path + len));
	}

	return (xstrdup(path));
}

static char *
make_absolute(char *p, char *pwd)
{
	char *abs_str;

	/* Derelativise */
	if (p && p[0] != '/') {
		abs_str = path_append(pwd, p);
		xfree(p);
		return(abs_str);
	} else
		return(p);
}

static int
parse_getput_flags(const char *cmd, char **argv, int argc, int *pflag,
    int *rflag)
{
	int ch;

	optind = optreset = 1;
	opterr = 0;

	*rflag = *pflag = 0;
	while ((ch = getopt(argc, argv, "PpRr")) != -1) {
		switch (ch) {
		case 'p':
		case 'P':
			*pflag = 1;
			break;
		case 'r':
		case 'R':
			*rflag = 1;
			break;
		default:
			error("%s: Invalid flag -%c", cmd, optopt);
			return -1;
		}
	}

	return optind;
}

static int
parse_ls_flags(char **argv, int argc, int *lflag)
{
	int ch;

	optind = optreset = 1;
	opterr = 0;

	*lflag = LS_NAME_SORT;
	while ((ch = getopt(argc, argv, "1Saflnrt")) != -1) {
		switch (ch) {
		case '1':
			*lflag &= ~VIEW_FLAGS;
			*lflag |= LS_SHORT_VIEW;
			break;
		case 'S':
			*lflag &= ~SORT_FLAGS;
			*lflag |= LS_SIZE_SORT;
			break;
		case 'a':
			*lflag |= LS_SHOW_ALL;
			break;
		case 'f':
			*lflag &= ~SORT_FLAGS;
			break;
		case 'l':
			*lflag &= ~VIEW_FLAGS;
			*lflag |= LS_LONG_VIEW;
			break;
		case 'n':
			*lflag &= ~VIEW_FLAGS;
			*lflag |= LS_NUMERIC_VIEW|LS_LONG_VIEW;
			break;
		case 'r':
			*lflag |= LS_REVERSE_SORT;
			break;
		case 't':
			*lflag &= ~SORT_FLAGS;
			*lflag |= LS_TIME_SORT;
			break;
		default:
			error("ls: Invalid flag -%c", optopt);
			return -1;
		}
	}

	return optind;
}

static int
parse_df_flags(const char *cmd, char **argv, int argc, int *hflag, int *iflag)
{
	int ch;

	optind = optreset = 1;
	opterr = 0;

	*hflag = *iflag = 0;
	while ((ch = getopt(argc, argv, "hi")) != -1) {
		switch (ch) {
		case 'h':
			*hflag = 1;
			break;
		case 'i':
			*iflag = 1;
			break;
		default:
			error("%s: Invalid flag -%c", cmd, optopt);
			return -1;
		}
	}

	return optind;
}

static int
is_dir(char *path)
{
	struct stat sb;

	/* XXX: report errors? */
	if (stat(path, &sb) == -1)
		return(0);

	return(S_ISDIR(sb.st_mode));
}

static int
remote_is_dir(struct sftp_conn *conn, char *path)
{
	Attrib *a;

	/* XXX: report errors? */
	if ((a = do_stat(conn, path, 1)) == NULL)
		return(0);
	if (!(a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS))
		return(0);
	return(S_ISDIR(a->perm));
}

/* Check whether path returned from glob(..., GLOB_MARK, ...) is a directory */
static int
pathname_is_dir(char *pathname)
{
	size_t l = strlen(pathname);

	return l > 0 && pathname[l - 1] == '/';
}

static int
process_get(struct sftp_conn *conn, char *src, char *dst, char *pwd,
    int pflag, int rflag)
{
	char *abs_src = NULL;
	char *abs_dst = NULL;
	glob_t g;
	char *filename, *tmp=NULL;
	int i, err = 0;

	abs_src = xstrdup(src);
	abs_src = make_absolute(abs_src, pwd);
	memset(&g, 0, sizeof(g));

	debug3("Looking up %s", abs_src);
	if (remote_glob(conn, abs_src, GLOB_MARK, NULL, &g)) {
		error("File \"%s\" not found.", abs_src);
		err = -1;
		goto out;
	}

	/*
	 * If multiple matches then dst must be a directory or
	 * unspecified.
	 */
	if (g.gl_matchc > 1 && dst != NULL && !is_dir(dst)) {
		error("Multiple source paths, but destination "
		    "\"%s\" is not a directory", dst);
		err = -1;
		goto out;
	}

	for (i = 0; g.gl_pathv[i] && !interrupted; i++) {
		tmp = xstrdup(g.gl_pathv[i]);
		if ((filename = basename(tmp)) == NULL) {
			error("basename %s: %s", tmp, strerror(errno));
			xfree(tmp);
			err = -1;
			goto out;
		}

		if (g.gl_matchc == 1 && dst) {
			if (is_dir(dst)) {
				abs_dst = path_append(dst, filename);
			} else {
				abs_dst = xstrdup(dst);
			}
		} else if (dst) {
			abs_dst = path_append(dst, filename);
		} else {
			abs_dst = xstrdup(filename);
		}
		xfree(tmp);

		printf("Fetching %s to %s\n", g.gl_pathv[i], abs_dst);
		if (pathname_is_dir(g.gl_pathv[i]) && (rflag || global_rflag)) {
			if (download_dir(conn, g.gl_pathv[i], abs_dst, NULL, 
			    pflag || global_pflag, 1) == -1)
				err = -1;
		} else {
			if (do_download(conn, g.gl_pathv[i], abs_dst, NULL,
			    pflag || global_pflag) == -1)
				err = -1;
		}
		xfree(abs_dst);
		abs_dst = NULL;
	}

out:
	xfree(abs_src);
	globfree(&g);
	return(err);
}

static int
process_put(struct sftp_conn *conn, char *src, char *dst, char *pwd,
    int pflag, int rflag)
{
	char *tmp_dst = NULL;
	char *abs_dst = NULL;
	char *tmp = NULL, *filename = NULL;
	glob_t g;
	int err = 0;
	int i, dst_is_dir = 1;
	struct stat sb;

	if (dst) {
		tmp_dst = xstrdup(dst);
		tmp_dst = make_absolute(tmp_dst, pwd);
	}

	memset(&g, 0, sizeof(g));
	debug3("Looking up %s", src);
	if (glob(src, GLOB_NOCHECK | GLOB_MARK | GLOB_LIMIT, NULL, &g)) {
		error("File \"%s\" not found.", src);
		err = -1;
		goto out;
	}

	/* If we aren't fetching to pwd then stash this status for later */
	if (tmp_dst != NULL)
		dst_is_dir = remote_is_dir(conn, tmp_dst);

	/* If multiple matches, dst may be directory or unspecified */
	if (g.gl_matchc > 1 && tmp_dst && !dst_is_dir) {
		error("Multiple paths match, but destination "
		    "\"%s\" is not a directory", tmp_dst);
		err = -1;
		goto out;
	}

	for (i = 0; g.gl_pathv[i] && !interrupted; i++) {
		if (stat(g.gl_pathv[i], &sb) == -1) {
			err = -1;
			error("stat %s: %s", g.gl_pathv[i], strerror(errno));
			continue;
		}
		
		tmp = xstrdup(g.gl_pathv[i]);
		if ((filename = basename(tmp)) == NULL) {
			error("basename %s: %s", tmp, strerror(errno));
			xfree(tmp);
			err = -1;
			goto out;
		}

		if (g.gl_matchc == 1 && tmp_dst) {
			/* If directory specified, append filename */
			if (dst_is_dir)
				abs_dst = path_append(tmp_dst, filename);
			else
				abs_dst = xstrdup(tmp_dst);
		} else if (tmp_dst) {
			abs_dst = path_append(tmp_dst, filename);
		} else {
			abs_dst = make_absolute(xstrdup(filename), pwd);
		}
		xfree(tmp);

		printf("Uploading %s to %s\n", g.gl_pathv[i], abs_dst);
		if (pathname_is_dir(g.gl_pathv[i]) && (rflag || global_rflag)) {
			if (upload_dir(conn, g.gl_pathv[i], abs_dst,
			    pflag || global_pflag, 1) == -1)
				err = -1;
		} else {
			if (do_upload(conn, g.gl_pathv[i], abs_dst,
			    pflag || global_pflag) == -1)
				err = -1;
		}
	}

out:
	if (abs_dst)
		xfree(abs_dst);
	if (tmp_dst)
		xfree(tmp_dst);
	globfree(&g);
	return(err);
}

static int
sdirent_comp(const void *aa, const void *bb)
{
	SFTP_DIRENT *a = *(SFTP_DIRENT **)aa;
	SFTP_DIRENT *b = *(SFTP_DIRENT **)bb;
	int rmul = sort_flag & LS_REVERSE_SORT ? -1 : 1;

#define NCMP(a,b) (a == b ? 0 : (a < b ? 1 : -1))
	if (sort_flag & LS_NAME_SORT)
		return (rmul * strcmp(a->filename, b->filename));
	else if (sort_flag & LS_TIME_SORT)
		return (rmul * NCMP(a->a.mtime, b->a.mtime));
	else if (sort_flag & LS_SIZE_SORT)
		return (rmul * NCMP(a->a.size, b->a.size));

	fatal("Unknown ls sort type");
}

/* sftp ls.1 replacement for directories */
static int
do_ls_dir(struct sftp_conn *conn, char *path, char *strip_path, int lflag)
{
	int n;
	u_int c = 1, colspace = 0, columns = 1;
	SFTP_DIRENT **d;

	if ((n = do_readdir(conn, path, &d)) != 0)
		return (n);

	if (!(lflag & LS_SHORT_VIEW)) {
		u_int m = 0, width = 80;
		struct winsize ws;
		char *tmp;

		/* Count entries for sort and find longest filename */
		for (n = 0; d[n] != NULL; n++) {
			if (d[n]->filename[0] != '.' || (lflag & LS_SHOW_ALL))
				m = MAX(m, strlen(d[n]->filename));
		}

		/* Add any subpath that also needs to be counted */
		tmp = path_strip(path, strip_path);
		m += strlen(tmp);
		xfree(tmp);

		if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)
			width = ws.ws_col;

		columns = width / (m + 2);
		columns = MAX(columns, 1);
		colspace = width / columns;
		colspace = MIN(colspace, width);
	}

	if (lflag & SORT_FLAGS) {
		for (n = 0; d[n] != NULL; n++)
			;	/* count entries */
		sort_flag = lflag & (SORT_FLAGS|LS_REVERSE_SORT);
		qsort(d, n, sizeof(*d), sdirent_comp);
	}

	for (n = 0; d[n] != NULL && !interrupted; n++) {
		char *tmp, *fname;

		if (d[n]->filename[0] == '.' && !(lflag & LS_SHOW_ALL))
			continue;

		tmp = path_append(path, d[n]->filename);
		fname = path_strip(tmp, strip_path);
		xfree(tmp);

		if (lflag & LS_LONG_VIEW) {
			if (lflag & LS_NUMERIC_VIEW) {
				char *lname;
				struct stat sb;

				memset(&sb, 0, sizeof(sb));
				attrib_to_stat(&d[n]->a, &sb);
				lname = ls_file(fname, &sb, 1);
				printf("%s\n", lname);
				xfree(lname);
			} else
				printf("%s\n", d[n]->longname);
		} else {
			printf("%-*s", colspace, fname);
			if (c >= columns) {
				printf("\n");
				c = 1;
			} else
				c++;
		}

		xfree(fname);
	}

	if (!(lflag & LS_LONG_VIEW) && (c != 1))
		printf("\n");

	free_sftp_dirents(d);
	return (0);
}

/* sftp ls.1 replacement which handles path globs */
static int
do_globbed_ls(struct sftp_conn *conn, char *path, char *strip_path,
    int lflag)
{
	glob_t g;
	u_int i, c = 1, colspace = 0, columns = 1;
	Attrib *a = NULL;

	memset(&g, 0, sizeof(g));

	if (remote_glob(conn, path, GLOB_MARK|GLOB_NOCHECK|GLOB_BRACE,
	    NULL, &g) || (g.gl_pathc && !g.gl_matchc)) {
		if (g.gl_pathc)
			globfree(&g);
		error("Can't ls: \"%s\" not found", path);
		return (-1);
	}

	if (interrupted)
		goto out;

	/*
	 * If the glob returns a single match and it is a directory,
	 * then just list its contents.
	 */
	if (g.gl_matchc == 1) {
		if ((a = do_lstat(conn, g.gl_pathv[0], 1)) == NULL) {
			globfree(&g);
			return (-1);
		}
		if ((a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) &&
		    S_ISDIR(a->perm)) {
			int err;

			err = do_ls_dir(conn, g.gl_pathv[0], strip_path, lflag);
			globfree(&g);
			return (err);
		}
	}

	if (!(lflag & LS_SHORT_VIEW)) {
		u_int m = 0, width = 80;
		struct winsize ws;

		/* Count entries for sort and find longest filename */
		for (i = 0; g.gl_pathv[i]; i++)
			m = MAX(m, strlen(g.gl_pathv[i]));

		if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)
			width = ws.ws_col;

		columns = width / (m + 2);
		columns = MAX(columns, 1);
		colspace = width / columns;
	}

	for (i = 0; g.gl_pathv[i] && !interrupted; i++, a = NULL) {
		char *fname;

		fname = path_strip(g.gl_pathv[i], strip_path);

		if (lflag & LS_LONG_VIEW) {
			char *lname;
			struct stat sb;

			/*
			 * XXX: this is slow - 1 roundtrip per path
			 * A solution to this is to fork glob() and
			 * build a sftp specific version which keeps the
			 * attribs (which currently get thrown away)
			 * that the server returns as well as the filenames.
			 */
			memset(&sb, 0, sizeof(sb));
			if (a == NULL)
				a = do_lstat(conn, g.gl_pathv[i], 1);
			if (a != NULL)
				attrib_to_stat(a, &sb);
			lname = ls_file(fname, &sb, 1);
			printf("%s\n", lname);
			xfree(lname);
		} else {
			printf("%-*s", colspace, fname);
			if (c >= columns) {
				printf("\n");
				c = 1;
			} else
				c++;
		}
		xfree(fname);
	}

	if (!(lflag & LS_LONG_VIEW) && (c != 1))
		printf("\n");

 out:
	if (g.gl_pathc)
		globfree(&g);

	return (0);
}

static int
do_df(struct sftp_conn *conn, char *path, int hflag, int iflag)
{
	struct sftp_statvfs st;
	char s_used[FMT_SCALED_STRSIZE];
	char s_avail[FMT_SCALED_STRSIZE];
	char s_root[FMT_SCALED_STRSIZE];
	char s_total[FMT_SCALED_STRSIZE];

	if (do_statvfs(conn, path, &st, 1) == -1)
		return -1;
	if (iflag) {
		printf("     Inodes        Used       Avail      "
		    "(root)    %%Capacity\n");
		printf("%11llu %11llu %11llu %11llu         %3llu%%\n",
		    (unsigned long long)st.f_files,
		    (unsigned long long)(st.f_files - st.f_ffree),
		    (unsigned long long)st.f_favail,
		    (unsigned long long)st.f_ffree,
		    (unsigned long long)(100 * (st.f_files - st.f_ffree) /
		    st.f_files));
	} else if (hflag) {
		strlcpy(s_used, "error", sizeof(s_used));
		strlcpy(s_avail, "error", sizeof(s_avail));
		strlcpy(s_root, "error", sizeof(s_root));
		strlcpy(s_total, "error", sizeof(s_total));
		fmt_scaled((st.f_blocks - st.f_bfree) * st.f_frsize, s_used);
		fmt_scaled(st.f_bavail * st.f_frsize, s_avail);
		fmt_scaled(st.f_bfree * st.f_frsize, s_root);
		fmt_scaled(st.f_blocks * st.f_frsize, s_total);
		printf("    Size     Used    Avail   (root)    %%Capacity\n");
		printf("%7sB %7sB %7sB %7sB         %3llu%%\n",
		    s_total, s_used, s_avail, s_root,
		    (unsigned long long)(100 * (st.f_blocks - st.f_bfree) /
		    st.f_blocks));
	} else {
		printf("        Size         Used        Avail       "
		    "(root)    %%Capacity\n");
		printf("%12llu %12llu %12llu %12llu         %3llu%%\n",
		    (unsigned long long)(st.f_frsize * st.f_blocks / 1024),
		    (unsigned long long)(st.f_frsize *
		    (st.f_blocks - st.f_bfree) / 1024),
		    (unsigned long long)(st.f_frsize * st.f_bavail / 1024),
		    (unsigned long long)(st.f_frsize * st.f_bfree / 1024),
		    (unsigned long long)(100 * (st.f_blocks - st.f_bfree) /
		    st.f_blocks));
	}
	return 0;
}

/*
 * Undo escaping of glob sequences in place. Used to undo extra escaping
 * applied in makeargv() when the string is destined for a function that
 * does not glob it.
 */
static void
undo_glob_escape(char *s)
{
	size_t i, j;

	for (i = j = 0;;) {
		if (s[i] == '\0') {
			s[j] = '\0';
			return;
		}
		if (s[i] != '\\') {
			s[j++] = s[i++];
			continue;
		}
		/* s[i] == '\\' */
		++i;
		switch (s[i]) {
		case '?':
		case '[':
		case '*':
		case '\\':
			s[j++] = s[i++];
			break;
		case '\0':
			s[j++] = '\\';
			s[j] = '\0';
			return;
		default:
			s[j++] = '\\';
			s[j++] = s[i++];
			break;
		}
	}
}

/*
 * Split a string into an argument vector using sh(1)-style quoting,
 * comment and escaping rules, but with some tweaks to handle glob(3)
 * wildcards.
 * Returns NULL on error or a NULL-terminated array of arguments.
 */
#define MAXARGS 	128
#define MAXARGLEN	8192
static char **
makeargv(const char *arg, int *argcp)
{
	int argc, quot;
	size_t i, j;
	static char argvs[MAXARGLEN];
	static char *argv[MAXARGS + 1];
	enum { MA_START, MA_SQUOTE, MA_DQUOTE, MA_UNQUOTED } state, q;

	*argcp = argc = 0;
	if (strlen(arg) > sizeof(argvs) - 1) {
 args_too_longs:
		error("string too long");
		return NULL;
	}
	state = MA_START;
	i = j = 0;
	for (;;) {
		if (isspace(arg[i])) {
			if (state == MA_UNQUOTED) {
				/* Terminate current argument */
				argvs[j++] = '\0';
				argc++;
				state = MA_START;
			} else if (state != MA_START)
				argvs[j++] = arg[i];
		} else if (arg[i] == '"' || arg[i] == '\'') {
			q = arg[i] == '"' ? MA_DQUOTE : MA_SQUOTE;
			if (state == MA_START) {
				argv[argc] = argvs + j;
				state = q;
			} else if (state == MA_UNQUOTED) 
				state = q;
			else if (state == q)
				state = MA_UNQUOTED;
			else
				argvs[j++] = arg[i];
		} else if (arg[i] == '\\') {
			if (state == MA_SQUOTE || state == MA_DQUOTE) {
				quot = state == MA_SQUOTE ? '\'' : '"';
				/* Unescape quote we are in */
				/* XXX support \n and friends? */
				if (arg[i + 1] == quot) {
					i++;
					argvs[j++] = arg[i];
				} else if (arg[i + 1] == '?' ||
				    arg[i + 1] == '[' || arg[i + 1] == '*') {
					/*
					 * Special case for sftp: append
					 * double-escaped glob sequence -
					 * glob will undo one level of
					 * escaping. NB. string can grow here.
					 */
					if (j >= sizeof(argvs) - 5)
						goto args_too_longs;
					argvs[j++] = '\\';
					argvs[j++] = arg[i++];
					argvs[j++] = '\\';
					argvs[j++] = arg[i];
				} else {
					argvs[j++] = arg[i++];
					argvs[j++] = arg[i];
				}
			} else {
				if (state == MA_START) {
					argv[argc] = argvs + j;
					state = MA_UNQUOTED;
				}
				if (arg[i + 1] == '?' || arg[i + 1] == '[' ||
				    arg[i + 1] == '*' || arg[i + 1] == '\\') {
					/*
					 * Special case for sftp: append
					 * escaped glob sequence -
					 * glob will undo one level of
					 * escaping.
					 */
					argvs[j++] = arg[i++];
					argvs[j++] = arg[i];
				} else {
					/* Unescape everything */
					/* XXX support \n and friends? */
					i++;
					argvs[j++] = arg[i];
				}
			}
		} else if (arg[i] == '#') {
			if (state == MA_SQUOTE || state == MA_DQUOTE)
				argvs[j++] = arg[i];
			else
				goto string_done;
		} else if (arg[i] == '\0') {
			if (state == MA_SQUOTE || state == MA_DQUOTE) {
				error("Unterminated quoted argument");
				return NULL;
			}
 string_done:
			if (state == MA_UNQUOTED) {
				argvs[j++] = '\0';
				argc++;
			}
			break;
		} else {
			if (state == MA_START) {
				argv[argc] = argvs + j;
				state = MA_UNQUOTED;
			}
			if ((state == MA_SQUOTE || state == MA_DQUOTE) &&
			    (arg[i] == '?' || arg[i] == '[' || arg[i] == '*')) {
				/*
				 * Special case for sftp: escape quoted
				 * glob(3) wildcards. NB. string can grow
				 * here.
				 */
				if (j >= sizeof(argvs) - 3)
					goto args_too_longs;
				argvs[j++] = '\\';
				argvs[j++] = arg[i];
			} else
				argvs[j++] = arg[i];
		}
		i++;
	}
	*argcp = argc;
	return argv;
}

static int
parse_args(const char **cpp, int *pflag, int *rflag, int *lflag, int *iflag, int *hflag,
    unsigned long *n_arg, char **path1, char **path2)
{
	const char *cmd, *cp = *cpp;
	char *cp2, **argv;
	int base = 0;
	long l;
	int i, cmdnum, optidx, argc;

	/* Skip leading whitespace */
	cp = cp + strspn(cp, WHITESPACE);

	/* Ignore blank lines and lines which begin with comment '#' char */
	if (*cp == '\0' || *cp == '#')
		return (0);

	/* Check for leading '-' (disable error processing) */
	*iflag = 0;
	if (*cp == '-') {
		*iflag = 1;
		cp++;
	}

	if ((argv = makeargv(cp, &argc)) == NULL)
		return -1;

	/* Figure out which command we have */
	for (i = 0; cmds[i].c != NULL; i++) {
		if (strcasecmp(cmds[i].c, argv[0]) == 0)
			break;
	}
	cmdnum = cmds[i].n;
	cmd = cmds[i].c;

	/* Special case */
	if (*cp == '!') {
		cp++;
		cmdnum = I_SHELL;
	} else if (cmdnum == -1) {
		error("Invalid command.");
		return -1;
	}

	/* Get arguments and parse flags */
	*lflag = *pflag = *rflag = *hflag = *n_arg = 0;
	*path1 = *path2 = NULL;
	optidx = 1;
	switch (cmdnum) {
	case I_GET:
	case I_PUT:
		if ((optidx = parse_getput_flags(cmd, argv, argc, pflag, rflag)) == -1)
			return -1;
		/* Get first pathname (mandatory) */
		if (argc - optidx < 1) {
			error("You must specify at least one path after a "
			    "%s command.", cmd);
			return -1;
		}
		*path1 = xstrdup(argv[optidx]);
		/* Get second pathname (optional) */
		if (argc - optidx > 1) {
			*path2 = xstrdup(argv[optidx + 1]);
			/* Destination is not globbed */
			undo_glob_escape(*path2);
		}
		break;
	case I_RENAME:
	case I_SYMLINK:
		if (argc - optidx < 2) {
			error("You must specify two paths after a %s "
			    "command.", cmd);
			return -1;
		}
		*path1 = xstrdup(argv[optidx]);
		*path2 = xstrdup(argv[optidx + 1]);
		/* Paths are not globbed */
		undo_glob_escape(*path1);
		undo_glob_escape(*path2);
		break;
	case I_RM:
	case I_MKDIR:
	case I_RMDIR:
	case I_CHDIR:
	case I_LCHDIR:
	case I_LMKDIR:
		/* Get pathname (mandatory) */
		if (argc - optidx < 1) {
			error("You must specify a path after a %s command.",
			    cmd);
			return -1;
		}
		*path1 = xstrdup(argv[optidx]);
		/* Only "rm" globs */
		if (cmdnum != I_RM)
			undo_glob_escape(*path1);
		break;
	case I_DF:
		if ((optidx = parse_df_flags(cmd, argv, argc, hflag,
		    iflag)) == -1)
			return -1;
		/* Default to current directory if no path specified */
		if (argc - optidx < 1)
			*path1 = NULL;
		else {
			*path1 = xstrdup(argv[optidx]);
			undo_glob_escape(*path1);
		}
		break;
	case I_LS:
		if ((optidx = parse_ls_flags(argv, argc, lflag)) == -1)
			return(-1);
		/* Path is optional */
		if (argc - optidx > 0)
			*path1 = xstrdup(argv[optidx]);
		break;
	case I_LLS:
		/* Skip ls command and following whitespace */
		cp = cp + strlen(cmd) + strspn(cp, WHITESPACE);
	case I_SHELL:
		/* Uses the rest of the line */
		break;
	case I_LUMASK:
	case I_CHMOD:
		base = 8;
	case I_CHOWN:
	case I_CHGRP:
		/* Get numeric arg (mandatory) */
		if (argc - optidx < 1)
			goto need_num_arg;
		errno = 0;
		l = strtol(argv[optidx], &cp2, base);
		if (cp2 == argv[optidx] || *cp2 != '\0' ||
		    ((l == LONG_MIN || l == LONG_MAX) && errno == ERANGE) ||
		    l < 0) {
 need_num_arg:
			error("You must supply a numeric argument "
			    "to the %s command.", cmd);
			return -1;
		}
		*n_arg = l;
		if (cmdnum == I_LUMASK)
			break;
		/* Get pathname (mandatory) */
		if (argc - optidx < 2) {
			error("You must specify a path after a %s command.",
			    cmd);
			return -1;
		}
		*path1 = xstrdup(argv[optidx + 1]);
		break;
	case I_QUIT:
	case I_PWD:
	case I_LPWD:
	case I_HELP:
	case I_VERSION:
	case I_PROGRESS:
		break;
	default:
		fatal("Command not implemented");
	}

	*cpp = cp;
	return(cmdnum);
}

static int
parse_dispatch_command(struct sftp_conn *conn, const char *cmd, char **pwd,
    int err_abort)
{
	char *path1, *path2, *tmp;
	int pflag = 0, rflag = 0, lflag = 0, iflag = 0, hflag = 0, cmdnum, i;
	unsigned long n_arg = 0;
	Attrib a, *aa;
	char path_buf[MAXPATHLEN];
	int err = 0;
	glob_t g;

	path1 = path2 = NULL;
	cmdnum = parse_args(&cmd, &pflag, &rflag, &lflag, &iflag, &hflag, &n_arg,
	    &path1, &path2);

	if (iflag != 0)
		err_abort = 0;

	memset(&g, 0, sizeof(g));

	/* Perform command */
	switch (cmdnum) {
	case 0:
		/* Blank line */
		break;
	case -1:
		/* Unrecognized command */
		err = -1;
		break;
	case I_GET:
		err = process_get(conn, path1, path2, *pwd, pflag, rflag);
		break;
	case I_PUT:
		err = process_put(conn, path1, path2, *pwd, pflag, rflag);
		break;
	case I_RENAME:
		path1 = make_absolute(path1, *pwd);
		path2 = make_absolute(path2, *pwd);
		err = do_rename(conn, path1, path2);
		break;
	case I_SYMLINK:
		path2 = make_absolute(path2, *pwd);
		err = do_symlink(conn, path1, path2);
		break;
	case I_RM:
		path1 = make_absolute(path1, *pwd);
		remote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);
		for (i = 0; g.gl_pathv[i] && !interrupted; i++) {
			printf("Removing %s\n", g.gl_pathv[i]);
			err = do_rm(conn, g.gl_pathv[i]);
			if (err != 0 && err_abort)
				break;
		}
		break;
	case I_MKDIR:
		path1 = make_absolute(path1, *pwd);
		attrib_clear(&a);
		a.flags |= SSH2_FILEXFER_ATTR_PERMISSIONS;
		a.perm = 0777;
		err = do_mkdir(conn, path1, &a, 1);
		break;
	case I_RMDIR:
		path1 = make_absolute(path1, *pwd);
		err = do_rmdir(conn, path1);
		break;
	case I_CHDIR:
		path1 = make_absolute(path1, *pwd);
		if ((tmp = do_realpath(conn, path1)) == NULL) {
			err = 1;
			break;
		}
		if ((aa = do_stat(conn, tmp, 0)) == NULL) {
			xfree(tmp);
			err = 1;
			break;
		}
		if (!(aa->flags & SSH2_FILEXFER_ATTR_PERMISSIONS)) {
			error("Can't change directory: Can't check target");
			xfree(tmp);
			err = 1;
			break;
		}
		if (!S_ISDIR(aa->perm)) {
			error("Can't change directory: \"%s\" is not "
			    "a directory", tmp);
			xfree(tmp);
			err = 1;
			break;
		}
		xfree(*pwd);
		*pwd = tmp;
		break;
	case I_LS:
		if (!path1) {
			do_globbed_ls(conn, *pwd, *pwd, lflag);
			break;
		}

		/* Strip pwd off beginning of non-absolute paths */
		tmp = NULL;
		if (*path1 != '/')
			tmp = *pwd;

		path1 = make_absolute(path1, *pwd);
		err = do_globbed_ls(conn, path1, tmp, lflag);
		break;
	case I_DF:
		/* Default to current directory if no path specified */
		if (path1 == NULL)
			path1 = xstrdup(*pwd);
		path1 = make_absolute(path1, *pwd);
		err = do_df(conn, path1, hflag, iflag);
		break;
	case I_LCHDIR:
		if (chdir(path1) == -1) {
			error("Couldn't change local directory to "
			    "\"%s\": %s", path1, strerror(errno));
			err = 1;
		}
		break;
	case I_LMKDIR:
		if (mkdir(path1, 0777) == -1) {
			error("Couldn't create local directory "
			    "\"%s\": %s", path1, strerror(errno));
			err = 1;
		}
		break;
	case I_LLS:
		local_do_ls(cmd);
		break;
	case I_SHELL:
		local_do_shell(cmd);
		break;
	case I_LUMASK:
		umask(n_arg);
		printf("Local umask: %03lo\n", n_arg);
		break;
	case I_CHMOD:
		path1 = make_absolute(path1, *pwd);
		attrib_clear(&a);
		a.flags |= SSH2_FILEXFER_ATTR_PERMISSIONS;
		a.perm = n_arg;
		remote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);
		for (i = 0; g.gl_pathv[i] && !interrupted; i++) {
			printf("Changing mode on %s\n", g.gl_pathv[i]);
			err = do_setstat(conn, g.gl_pathv[i], &a);
			if (err != 0 && err_abort)
				break;
		}
		break;
	case I_CHOWN:
	case I_CHGRP:
		path1 = make_absolute(path1, *pwd);
		remote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);
		for (i = 0; g.gl_pathv[i] && !interrupted; i++) {
			if (!(aa = do_stat(conn, g.gl_pathv[i], 0))) {
				if (err_abort) {
					err = -1;
					break;
				} else
					continue;
			}
			if (!(aa->flags & SSH2_FILEXFER_ATTR_UIDGID)) {
				error("Can't get current ownership of "
				    "remote file \"%s\"", g.gl_pathv[i]);
				if (err_abort) {
					err = -1;
					break;
				} else
					continue;
			}
			aa->flags &= SSH2_FILEXFER_ATTR_UIDGID;
			if (cmdnum == I_CHOWN) {
				printf("Changing owner on %s\n", g.gl_pathv[i]);
				aa->uid = n_arg;
			} else {
				printf("Changing group on %s\n", g.gl_pathv[i]);
				aa->gid = n_arg;
			}
			err = do_setstat(conn, g.gl_pathv[i], aa);
			if (err != 0 && err_abort)
				break;
		}
		break;
	case I_PWD:
		printf("Remote working directory: %s\n", *pwd);
		break;
	case I_LPWD:
		if (!getcwd(path_buf, sizeof(path_buf))) {
			error("Couldn't get local cwd: %s", strerror(errno));
			err = -1;
			break;
		}
		printf("Local working directory: %s\n", path_buf);
		break;
	case I_QUIT:
		/* Processed below */
		break;
	case I_HELP:
		help();
		break;
	case I_VERSION:
		printf("SFTP protocol version %u\n", sftp_proto_version(conn));
		break;
	case I_PROGRESS:
		showprogress = !showprogress;
		if (showprogress)
			printf("Progress meter enabled\n");
		else
			printf("Progress meter disabled\n");
		break;
	default:
		fatal("%d is not implemented", cmdnum);
	}

	if (g.gl_pathc)
		globfree(&g);
	if (path1)
		xfree(path1);
	if (path2)
		xfree(path2);

	/* If an unignored error occurs in batch mode we should abort. */
	if (err_abort && err != 0)
		return (-1);
	else if (cmdnum == I_QUIT)
		return (1);

	return (0);
}

static const char *
prompt(EditLine *el)
{
	return ("sftp> ");
}

int
interactive_loop(int fd_in, int fd_out, char *file1, char *file2)
{
	char *pwd;
	char *dir = NULL;
	char cmd[2048];
	struct sftp_conn *conn;
	int err, interactive;
	EditLine *el = NULL;
	History *hl = NULL;
	HistEvent hev;

	if (!batchmode && isatty(STDIN_FILENO)) {
		if ((el = el_init(__progname, stdin, stdout, stderr)) == NULL)
			fatal("Couldn't initialise editline");
		if ((hl = history_init()) == NULL)
			fatal("Couldn't initialise editline history");
		history(hl, &hev, H_SETSIZE, 100);
		el_set(el, EL_HIST, history, hl);

		el_set(el, EL_PROMPT, prompt);
		el_set(el, EL_EDITOR, "emacs");
		el_set(el, EL_TERMINAL, NULL);
		el_set(el, EL_SIGNAL, 1);
		el_source(el, NULL);
	}

	conn = do_init(fd_in, fd_out, copy_buffer_len, num_requests);
	if (conn == NULL)
		fatal("Couldn't initialise connection to server");

	pwd = do_realpath(conn, ".");
	if (pwd == NULL)
		fatal("Need cwd");

	if (file1 != NULL) {
		dir = xstrdup(file1);
		dir = make_absolute(dir, pwd);

		if (remote_is_dir(conn, dir) && file2 == NULL) {
			printf("Changing to: %s\n", dir);
			snprintf(cmd, sizeof cmd, "cd \"%s\"", dir);
			if (parse_dispatch_command(conn, cmd, &pwd, 1) != 0) {
				xfree(dir);
				xfree(pwd);
				xfree(conn);
				return (-1);
			}
		} else {
			if (file2 == NULL)
				snprintf(cmd, sizeof cmd, "get %s", dir);
			else
				snprintf(cmd, sizeof cmd, "get %s %s", dir,
				    file2);

			err = parse_dispatch_command(conn, cmd, &pwd, 1);
			xfree(dir);
			xfree(pwd);
			xfree(conn);
			return (err);
		}
		xfree(dir);
	}

	setvbuf(stdout, NULL, _IOLBF, 0);
	setvbuf(infile, NULL, _IOLBF, 0);

	interactive = !batchmode && isatty(STDIN_FILENO);
	err = 0;
	for (;;) {
		char *cp;
		const char *line;
		int count = 0;

		signal(SIGINT, SIG_IGN);

		if (el == NULL) {
			if (interactive)
				printf("sftp> ");
			if (fgets(cmd, sizeof(cmd), infile) == NULL) {
				if (interactive)
					printf("\n");
				break;
			}
			if (!interactive) { /* Echo command */
				printf("sftp> %s", cmd);
				if (strlen(cmd) > 0 &&
				    cmd[strlen(cmd) - 1] != '\n')
					printf("\n");
			}
		} else {
			if ((line = el_gets(el, &count)) == NULL || count <= 0) {
				printf("\n");
				break;
			}
			history(hl, &hev, H_ENTER, line);
			if (strlcpy(cmd, line, sizeof(cmd)) >= sizeof(cmd)) {
				fprintf(stderr, "Error: input line too long\n");
				continue;
			}
		}

		cp = strrchr(cmd, '\n');
		if (cp)
			*cp = '\0';

		/* Handle user interrupts gracefully during commands */
		interrupted = 0;
		signal(SIGINT, cmd_interrupt);

		err = parse_dispatch_command(conn, cmd, &pwd, batchmode);
		if (err != 0)
			break;
	}
	xfree(pwd);
	xfree(conn);

	if (el != NULL)
		el_end(el);

	/* err == 1 signifies normal "quit" exit */
	return (err >= 0 ? 0 : -1);
}

static void
connect_to_server(const char *path, char **args, int *in, int *out)
{
	int c_in, c_out;

	int inout[2];

	if (socketpair(AF_UNIX, SOCK_STREAM, 0, inout) == -1)
		fatal("socketpair: %s", strerror(errno));
	*in = *out = inout[0];
	c_in = c_out = inout[1];

	if ((sshpid = fork()) == -1)
		fatal("fork: %s", strerror(errno));
	else if (sshpid == 0) {
		if ((dup2(c_in, STDIN_FILENO) == -1) ||
		    (dup2(c_out, STDOUT_FILENO) == -1)) {
			fprintf(stderr, "dup2: %s\n", strerror(errno));
			_exit(1);
		}
		close(*in);
		close(*out);
		close(c_in);
		close(c_out);

		/*
		 * The underlying ssh is in the same process group, so we must
		 * ignore SIGINT if we want to gracefully abort commands,
		 * otherwise the signal will make it to the ssh process and
		 * kill it too
		 */
		signal(SIGINT, SIG_IGN);
		execvp(path, args);
		fprintf(stderr, "exec: %s: %s\n", path, strerror(errno));
		_exit(1);
	}

	signal(SIGTERM, killchild);
	signal(SIGINT, killchild);
	signal(SIGHUP, killchild);
	close(c_in);
	close(c_out);
}

static __dead void
usage(void)
{
	fprintf(stderr,
	    "usage: %s [-1246Cpqrv] [-B buffer_size] [-b batchfile] [-c cipher]\n"
	    "          [-D sftp_server_path] [-F ssh_config] "
	    "[-i identity_file]\n"
	    "          [-o ssh_option] [-P port] [-R num_requests] "
	    "[-S program]\n"
	    "          [-s subsystem | sftp_server] host\n"
	    "       %s [user@@]host[:file ...]\n"
	    "       %s [user@@]host[:dir[/]]\n"
	    "       %s -b batchfile [user@@]host\n",
	    __progname, __progname, __progname, __progname);
	exit(1);
}

int
main(int argc, char **argv)
{
	int in, out, ch, err;
	char *host, *userhost, *cp, *file2 = NULL;
	int debug_level = 0, sshver = 2;
	char *file1 = NULL;
	const char *sftp_server = NULL;
	const char *ssh_program = _PATH_SSH_PROGRAM;
	char *sftp_direct = NULL;
	LogLevel ll = SYSLOG_LEVEL_INFO;
	arglist args;

	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

	memset(&args, '\0', sizeof(args));
	args.list = NULL;
	addargs(&args, "%s", ssh_program);
	addargs(&args, "-oForwardX11 no");
	addargs(&args, "-oForwardAgent no");
	addargs(&args, "-oPermitLocalCommand no");
	addargs(&args, "-oClearAllForwardings yes");

	ll = SYSLOG_LEVEL_INFO;
	infile = stdin;

	while ((ch = getopt(argc, argv,
	    "1246hqrvCc:D:i:o:s:S:b:B:F:P:R:")) != -1) {
		switch (ch) {
		/* Passed through to ssh(1) */
		case '4':
		case '6':
		case 'C':
			addargs(&args, "-%c", ch);
			break;
		/* Passed through to ssh(1) with argument */
		case 'F':
		case 'c':
		case 'i':
		case 'o':
			addargs(&args, "-%c%s", ch, optarg);
			break;
		case 'q':
			showprogress = 0;
			addargs(&args, "-%c", ch);
			break;
		case 'P':
			addargs(&args, "-oPort %s", optarg);
			break;
		case 'v':
			if (debug_level < 3) {
				addargs(&args, "-v");
				ll = SYSLOG_LEVEL_DEBUG1 + debug_level;
			}
			debug_level++;
			break;
		case '1':
			sshver = 1;
			if (sftp_server == NULL)
				sftp_server = _PATH_SFTP_SERVER;
			break;
		case '2':
			sshver = 2;
			break;
		case 'B':
			copy_buffer_len = strtol(optarg, &cp, 10);
			if (copy_buffer_len == 0 || *cp != '\0')
				fatal("Invalid buffer size \"%s\"", optarg);
			break;
		case 'b':
			if (batchmode)
				fatal("Batch file already specified.");

			/* Allow "-" as stdin */
			if (strcmp(optarg, "-") != 0 &&
			    (infile = fopen(optarg, "r")) == NULL)
				fatal("%s (%s).", strerror(errno), optarg);
			showprogress = 0;
			batchmode = 1;
			addargs(&args, "-obatchmode yes");
			break;
		case 'p':
			global_pflag = 1;
			break;
		case 'D':
			sftp_direct = optarg;
			break;
		case 'r':
			global_rflag = 1;
			break;
		case 'R':
			num_requests = strtol(optarg, &cp, 10);
			if (num_requests == 0 || *cp != '\0')
				fatal("Invalid number of requests \"%s\"",
				    optarg);
			break;
		case 's':
			sftp_server = optarg;
			break;
		case 'S':
			ssh_program = optarg;
			replacearg(&args, 0, "%s", ssh_program);
			break;
		case 'h':
		default:
			usage();
		}
	}

	if (!isatty(STDERR_FILENO))
		showprogress = 0;

	log_init(argv[0], ll, SYSLOG_FACILITY_USER, 1);

	if (sftp_direct == NULL) {
		if (optind == argc || argc > (optind + 2))
			usage();

		userhost = xstrdup(argv[optind]);
		file2 = argv[optind+1];

		if ((host = strrchr(userhost, '@@')) == NULL)
			host = userhost;
		else {
			*host++ = '\0';
			if (!userhost[0]) {
				fprintf(stderr, "Missing username\n");
				usage();
			}
			addargs(&args, "-l%s", userhost);
		}

		if ((cp = colon(host)) != NULL) {
			*cp++ = '\0';
			file1 = cp;
		}

		host = cleanhostname(host);
		if (!*host) {
			fprintf(stderr, "Missing hostname\n");
			usage();
		}

		addargs(&args, "-oProtocol %d", sshver);

		/* no subsystem if the server-spec contains a '/' */
		if (sftp_server == NULL || strchr(sftp_server, '/') == NULL)
			addargs(&args, "-s");

		addargs(&args, "%s", host);
		addargs(&args, "%s", (sftp_server != NULL ?
		    sftp_server : "sftp"));

		if (!batchmode)
			fprintf(stderr, "Connecting to %s...\n", host);
		connect_to_server(ssh_program, args.list, &in, &out);
	} else {
		args.list = NULL;
		addargs(&args, "sftp-server");

		if (!batchmode)
			fprintf(stderr, "Attaching to %s...\n", sftp_direct);
		connect_to_server(sftp_direct, args.list, &in, &out);
	}
	freeargs(&args);

	err = interactive_loop(in, out, file1, file2);

	close(in);
	close(out);
	if (batchmode)
		fclose(infile);

	while (waitpid(sshpid, NULL, 0) == -1)
		if (errno != EINTR)
			fatal("Couldn't wait for ssh process: %s",
			    strerror(errno));

	exit(err == 0 ? 0 : 1);
}
@


1.21
log
@• merge newer OpenSSH
• KNF in our diff – style(9)
• some const cleanliness (build with __CRAZY=Yes mostly)
@
text
@d49 1
a49 1
__RCSID("$MirOS: src/usr.bin/ssh/sftp.c,v 1.20 2009/03/22 15:01:20 tg Exp $");
d550 1
a550 1
	if (glob(src, GLOB_NOCHECK | GLOB_MARK, NULL, &g)) {
@


1.20
log
@merge and tweak ciphers and MACs
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.107 2009/02/02 11:15:14 dtucker Exp $ */
d30 1
d49 3
a51 1
__RCSID("$MirOS: src/usr.bin/ssh/sftp.c,v 1.19 2008/12/27 21:17:58 tg Exp $");
d71 6
d173 1
a173 1
static void
d208 1
a208 1
	    "get [-P] remote-path [local-path]  Download file\n"
d219 1
a219 1
	    "put [-P] local-path [remote-path]  Upload file\n"
d243 1
a243 1
		shell = _PATH_BSHELL;
a305 15
path_append(char *p1, char *p2)
{
	char *ret;
	size_t len = strlen(p1) + strlen(p2) + 2;

	ret = xmalloc(len);
	strlcpy(ret, p1, len);
	if (p1[0] != '\0' && p1[strlen(p1) - 1] != '/')
		strlcat(ret, "/", len);
	strlcat(ret, p2, len);

	return(ret);
}

static char *
d320 2
a321 21
infer_path(const char *p, char **ifp)
{
	char *cp;

	cp = strrchr(p, '/');
	if (cp == NULL) {
		*ifp = xstrdup(p);
		return(0);
	}

	if (!cp[1]) {
		error("Invalid path");
		return(-1);
	}

	*ifp = xstrdup(cp + 1);
	return(0);
}

static int
parse_getput_flags(const char *cmd, char **argv, int argc, int *pflag)
a322 1
	extern int opterr, optind, optopt, optreset;
d328 2
a329 2
	*pflag = 0;
	while ((ch = getopt(argc, argv, "Pp")) != -1) {
d335 4
a350 1
	extern int opterr, optind, optopt, optreset;
a399 1
	extern int opterr, optind, optopt, optreset;
d448 9
d458 2
a459 1
process_get(struct sftp_conn *conn, char *src, char *dst, char *pwd, int pflag)
a462 1
	char *tmp;
d464 2
a465 2
	int err = 0;
	int i;
d469 1
a470 1
	memset(&g, 0, sizeof(g));
d472 1
a472 1
	if (remote_glob(conn, abs_src, 0, NULL, &g)) {
d478 7
a484 4
	/* If multiple matches, dst must be a directory or unspecified */
	if (g.gl_matchc > 1 && dst && !is_dir(dst)) {
		error("Multiple files match, but \"%s\" is not a directory",
		    dst);
d490 4
a493 1
		if (infer_path(g.gl_pathv[i], &tmp)) {
a498 2
			/* If directory specified, append filename */
			xfree(tmp);
d500 2
a501 7
				if (infer_path(g.gl_pathv[0], &tmp)) {
					err = 1;
					goto out;
				}
				abs_dst = path_append(dst, tmp);
				xfree(tmp);
			} else
d503 1
d505 5
a509 4
			abs_dst = path_append(dst, tmp);
			xfree(tmp);
		} else
			abs_dst = tmp;
d512 9
a520 2
		if (do_download(conn, g.gl_pathv[i], abs_dst, pflag) == -1)
			err = -1;
d532 2
a533 1
process_put(struct sftp_conn *conn, char *src, char *dst, char *pwd, int pflag)
d537 1
a537 1
	char *tmp;
d540 1
a540 1
	int i;
d550 1
a550 1
	if (glob(src, GLOB_NOCHECK, NULL, &g)) {
d556 4
d561 3
a563 3
	if (g.gl_matchc > 1 && tmp_dst && !remote_is_dir(conn, tmp_dst)) {
		error("Multiple files match, but \"%s\" is not a directory",
		    tmp_dst);
d574 5
a578 7

		if (!S_ISREG(sb.st_mode)) {
			error("skipping non-regular file %s",
			    g.gl_pathv[i]);
			continue;
		}
		if (infer_path(g.gl_pathv[i], &tmp)) {
d585 3
a587 8
			if (remote_is_dir(conn, tmp_dst)) {
				if (infer_path(g.gl_pathv[0], &tmp)) {
					err = 1;
					goto out;
				}
				abs_dst = path_append(tmp_dst, tmp);
				xfree(tmp);
			} else
a588 1

d590 5
a594 4
			abs_dst = path_append(tmp_dst, tmp);
			xfree(tmp);
		} else
			abs_dst = make_absolute(tmp, pwd);
d597 9
a605 2
		if (do_upload(conn, g.gl_pathv[i], abs_dst, pflag) == -1)
			err = -1;
d1046 1
a1046 1
parse_args(const char **cpp, int *pflag, int *lflag, int *iflag, int *hflag,
d1090 1
a1090 1
	*lflag = *pflag = *hflag = *n_arg = 0;
d1096 1
a1096 1
		if ((optidx = parse_getput_flags(cmd, argv, argc, pflag)) == -1)
d1216 1
a1216 1
	int pflag = 0, lflag = 0, iflag = 0, hflag = 0, cmdnum, i;
d1224 1
a1224 1
	cmdnum = parse_args(&cmd, &pflag, &lflag, &iflag, &hflag, &n_arg,
d1242 1
a1242 1
		err = process_get(conn, path1, path2, *pwd, pflag);
d1245 1
a1245 1
		err = process_put(conn, path1, path2, *pwd, pflag);
d1271 1
a1271 1
		err = do_mkdir(conn, path1, &a);
d1443 1
a1443 1
static char *
a1459 1
	extern char *__progname;
d1574 1
a1574 1
connect_to_server(char *path, char **args, int *in, int *out)
d1617 1
a1617 1
static void
a1619 2
	extern char *__progname;

d1621 6
a1626 3
	    "usage: %s [-1Cv] [-B buffer_size] [-b batchfile] [-F ssh_config]\n"
	    "            [-o ssh_option] [-P sftp_server_path] [-R num_requests]\n"
	    "            [-S program] [-s subsystem | sftp_server] host\n"
d1629 2
a1630 1
	    "       %s -b batchfile [user@@]host\n", __progname, __progname, __progname, __progname);
d1640 4
a1643 2
	char *file1 = NULL, *sftp_server = NULL;
	char *ssh_program = _PATH_SSH_PROGRAM, *sftp_direct = NULL;
a1645 2
	extern int optind;
	extern char *optarg;
d1661 2
a1662 1
	while ((ch = getopt(argc, argv, "1hvCo:s:S:b:B:F:P:R:")) != -1) {
d1664 3
d1668 15
a1682 1
			addargs(&args, "-C");
a1690 4
		case 'F':
		case 'o':
			addargs(&args, "-%c%s", ch, optarg);
			break;
d1696 2
a1697 2
		case 's':
			sftp_server = optarg;
d1699 4
a1702 3
		case 'S':
			ssh_program = optarg;
			replacearg(&args, 0, "%s", ssh_program);
d1716 4
a1719 1
		case 'P':
d1722 2
a1723 4
		case 'B':
			copy_buffer_len = strtol(optarg, &cp, 10);
			if (copy_buffer_len == 0 || *cp != '\0')
				fatal("Invalid buffer size \"%s\"", optarg);
d1731 7
@


1.19
log
@merge and wrap exec/exit functions better
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.106 2008/12/09 15:35:00 sobrado Exp $ */
d48 1
a48 1
__RCSID("$MirOS: src/usr.bin/ssh/sftp.c,v 1.18 2008/12/16 22:13:30 tg Exp $");
d1218 2
a1219 2
	int pflag, lflag, iflag, hflag, cmdnum, i;
	unsigned long n_arg;
@


1.18
log
@really merge OpenSSH-current into MirBSD Secure SHell 10uA4
@
text
@d48 1
a48 1
__RCSID("$MirOS: src/usr.bin/ssh/sftp.c,v 1.17 2008/12/16 20:55:28 tg Exp $");
a240 1
		arc4_preexec();
a1607 1
		arc4_preexec();
@


1.17
log
@fastmerge, do not use yet!
@
text
@d48 1
a48 1
__RCSID("$MirOS: src/usr.bin/ssh/sftp.c,v 1.16 2008/03/02 21:14:22 tg Exp $");
d241 1
d1609 1
@


1.16
log
@merge’n’fix
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.99 2008/01/20 00:38:30 djm Exp $ */
d23 1
d35 1
d48 1
a48 1
__RCSID("$MirOS: src/usr.bin/ssh/sftp.c,v 1.15 2007/01/25 16:18:37 tg Exp $");
d60 1
a60 1
size_t num_requests = 16;
d98 1
d131 1
d190 31
a220 28
	printf("Available commands:\n");
	printf("cd path                       Change remote directory to 'path'\n");
	printf("lcd path                      Change local directory to 'path'\n");
	printf("chgrp grp path                Change group of file 'path' to 'grp'\n");
	printf("chmod mode path               Change permissions of file 'path' to 'mode'\n");
	printf("chown own path                Change owner of file 'path' to 'own'\n");
	printf("help                          Display this help text\n");
	printf("get remote-path [local-path]  Download file\n");
	printf("lls [ls-options [path]]       Display local directory listing\n");
	printf("ln oldpath newpath            Symlink remote file\n");
	printf("lmkdir path                   Create local directory\n");
	printf("lpwd                          Print local working directory\n");
	printf("ls [path]                     Display remote directory listing\n");
	printf("lumask umask                  Set local umask to 'umask'\n");
	printf("mkdir path                    Create remote directory\n");
	printf("progress                      Toggle display of progress meter\n");
	printf("put local-path [remote-path]  Upload file\n");
	printf("pwd                           Display remote working directory\n");
	printf("exit                          Quit sftp\n");
	printf("quit                          Quit sftp\n");
	printf("rename oldpath newpath        Rename remote file\n");
	printf("rmdir path                    Remove remote directory\n");
	printf("rm path                       Delete remote file\n");
	printf("symlink oldpath newpath       Symlink remote file\n");
	printf("version                       Show SFTP version\n");
	printf("!command                      Execute 'command' in local shell\n");
	printf("!                             Escape to local shell\n");
	printf("?                             Synonym for help\n");
d348 1
a348 1
	extern int optind, optreset, opterr;
d362 1
a362 1
			error("%s: Invalid flag -%c", cmd, ch);
d373 1
a373 1
	extern int optind, optreset, opterr;
d412 28
a439 1
			error("ls: Invalid flag -%c", ch);
d823 50
d1048 1
a1048 1
parse_args(const char **cpp, int *pflag, int *lflag, int *iflag,
d1092 1
a1092 1
	*lflag = *pflag = *n_arg = 0;
d1144 12
d1218 1
a1218 1
	int pflag, lflag, iflag, cmdnum, i;
d1226 1
a1226 1
	cmdnum = parse_args(&cmd, &pflag, &lflag, &iflag, &n_arg,
d1320 7
d1370 2
a1371 1
				if (err != 0 && err_abort)
d1373 1
a1373 1
				else
d1379 2
a1380 1
				if (err != 0 && err_abort)
d1382 1
a1382 1
				else
d1629 2
a1630 2
	    "       %s [[user@@]host[:file [file]]]\n"
	    "       %s [[user@@]host[:dir[/]]]\n"
@


1.15
log
@automerge, bump vsn
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.96 2007/01/03 04:09:15 stevesk Exp $ */
d24 1
d46 1
a46 1
__RCSID("$MirOS: src/usr.bin/ssh/sftp.c,v 1.14 2006/12/11 20:22:09 tg Exp $");
d339 1
a339 1
parse_getput_flags(const char **cpp, int *pflag)
d341 2
a342 1
	const char *cp = *cpp;
d344 6
a349 3
	/* Check for flags */
	if (cp[0] == '-' && cp[1] && strchr(WHITESPACE, cp[2])) {
		switch (cp[1]) {
d355 2
a356 2
			error("Invalid flag -%c", cp[1]);
			return(-1);
a357 2
		cp += 2;
		*cpp = cp + strspn(cp, WHITESPACE);
d360 1
a360 1
	return(0);
d364 1
a364 1
parse_ls_flags(const char **cpp, int *lflag)
d366 5
a370 1
	const char *cp = *cpp;
a371 1
	/* Defaults */
d373 34
a406 38

	/* Check for flags */
	if (cp++[0] == '-') {
		for (; strchr(WHITESPACE, *cp) == NULL; cp++) {
			switch (*cp) {
			case 'l':
				*lflag &= ~VIEW_FLAGS;
				*lflag |= LS_LONG_VIEW;
				break;
			case '1':
				*lflag &= ~VIEW_FLAGS;
				*lflag |= LS_SHORT_VIEW;
				break;
			case 'n':
				*lflag &= ~VIEW_FLAGS;
				*lflag |= LS_NUMERIC_VIEW|LS_LONG_VIEW;
				break;
			case 'S':
				*lflag &= ~SORT_FLAGS;
				*lflag |= LS_SIZE_SORT;
				break;
			case 't':
				*lflag &= ~SORT_FLAGS;
				*lflag |= LS_TIME_SORT;
				break;
			case 'r':
				*lflag |= LS_REVERSE_SORT;
				break;
			case 'f':
				*lflag &= ~SORT_FLAGS;
				break;
			case 'a':
				*lflag |= LS_SHOW_ALL;
				break;
			default:
				error("Invalid flag -%c", *cp);
				return(-1);
			}
a407 1
		*cpp = cp + strspn(cp, WHITESPACE);
d410 1
a410 67
	return(0);
}

static int
get_pathname(const char **cpp, char **path)
{
	const char *cp = *cpp, *end;
	char quot;
	u_int i, j;

	cp += strspn(cp, WHITESPACE);
	if (!*cp) {
		*cpp = cp;
		*path = NULL;
		return (0);
	}

	*path = xmalloc(strlen(cp) + 1);

	/* Check for quoted filenames */
	if (*cp == '\"' || *cp == '\'') {
		quot = *cp++;

		/* Search for terminating quote, unescape some chars */
		for (i = j = 0; i <= strlen(cp); i++) {
			if (cp[i] == quot) {	/* Found quote */
				i++;
				(*path)[j] = '\0';
				break;
			}
			if (cp[i] == '\0') {	/* End of string */
				error("Unterminated quote");
				goto fail;
			}
			if (cp[i] == '\\') {	/* Escaped characters */
				i++;
				if (cp[i] != '\'' && cp[i] != '\"' &&
				    cp[i] != '\\') {
					error("Bad escaped character '\\%c'",
					    cp[i]);
					goto fail;
				}
			}
			(*path)[j++] = cp[i];
		}

		if (j == 0) {
			error("Empty quotes");
			goto fail;
		}
		*cpp = cp + i + strspn(cp + i, WHITESPACE);
	} else {
		/* Read to end of filename */
		end = strpbrk(cp, WHITESPACE);
		if (end == NULL)
			end = strchr(cp, '\0');
		*cpp = end + strspn(end, WHITESPACE);

		memcpy(*path, cp, end - cp);
		(*path)[end - cp] = '\0';
	}
	return (0);

 fail:
	xfree(*path);
	*path = NULL;
	return (-1);
a425 11
is_reg(char *path)
{
	struct stat sb;

	if (stat(path, &sb) == -1)
		fatal("stat %s: %s", path, strerror(errno));

	return(S_ISREG(sb.st_mode));
}

static int
d513 1
d522 1
a522 1
	if (glob(src, 0, NULL, &g)) {
d537 7
a543 1
		if (!is_reg(g.gl_pathv[i])) {
d789 174
d968 1
a968 1
	char *cp2;
d971 1
a971 1
	int i, cmdnum;
d987 3
d991 2
a992 8
	for (i = 0; cmds[i].c; i++) {
		int cmdlen = strlen(cmds[i].c);

		/* Check for command followed by whitespace */
		if (!strncasecmp(cp, cmds[i].c, cmdlen) &&
		    strchr(WHITESPACE, cp[cmdlen])) {
			cp += cmdlen;
			cp = cp + strspn(cp, WHITESPACE);
a993 1
		}
d1004 1
a1004 1
		return (-1);
d1010 1
d1014 2
a1015 2
		if (parse_getput_flags(&cp, pflag))
			return(-1);
d1017 1
a1017 3
		if (get_pathname(&cp, path1))
			return(-1);
		if (*path1 == NULL) {
d1020 8
a1027 1
			return(-1);
a1028 3
		/* Try to get second pathname (optional) */
		if (get_pathname(&cp, path2))
			return(-1);
d1032 1
a1032 5
		if (get_pathname(&cp, path1))
			return(-1);
		if (get_pathname(&cp, path2))
			return(-1);
		if (!*path1 || !*path2) {
d1035 1
a1035 1
			return(-1);
d1037 5
d1050 1
a1050 3
		if (get_pathname(&cp, path1))
			return(-1);
		if (*path1 == NULL) {
d1053 1
a1053 1
			return(-1);
d1055 4
d1061 1
a1061 1
		if (parse_ls_flags(&cp, lflag))
d1064 2
a1065 2
		if (get_pathname(&cp, path1))
			return(-1);
d1068 2
a1073 1
		base = 8;
d1079 2
d1082 5
a1086 3
		l = strtol(cp, &cp2, base);
		if (cp2 == cp || ((l == LONG_MIN || l == LONG_MAX) &&
		    errno == ERANGE) || l < 0) {
d1089 1
a1089 1
			return(-1);
a1090 1
		cp = cp2;
d1092 1
a1092 1
		if (cmdnum == I_LUMASK && strchr(WHITESPACE, *cp))
a1093 7
		if (cmdnum == I_LUMASK || !strchr(WHITESPACE, *cp)) {
			error("You must supply a numeric argument "
			    "to the %s command.", cmd);
			return(-1);
		}
		cp += strspn(cp, WHITESPACE);

d1095 1
a1095 3
		if (get_pathname(&cp, path1))
			return(-1);
		if (*path1 == NULL) {
d1098 1
a1098 1
			return(-1);
d1100 1
@


1.14
log
@* *.c: merge
* sshd.8: fix a merge glitch from prev
* version.h: bump
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.94 2006/11/23 01:35:11 ray Exp $ */
d45 1
a45 1
__RCSID("$MirOS: src/usr.bin/ssh/sftp.c,v 1.13 2006/10/02 23:26:01 tg Exp $");
d158 1
d170 1
d1534 1
a1534 1
			addargs(&args, "-l%s",userhost);
@


1.13
log
@Use S_IS* macros insted of masking with S_IF* flags. The latter may
have multiple bits set, which lead to surprising results. Spotted by
Paul Stoeber, more to come. ok millert@@ pedro@@ jaredy@@ djm@@

Clear errno before calling the strtol functions.
From Paul Stoeber <x0001 at x dot de1 dot cc>.
OK deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.93 2006/09/30 17:48:22 ray Exp $ */
d45 1
a45 1
__RCSID("$MirOS: src/usr.bin/ssh/sftp.c,v 1.12 2006/09/20 21:41:04 tg Exp $");
d290 1
a290 1
	int len = strlen(p1) + strlen(p2) + 2;
d294 1
a294 1
	if (p1[strlen(p1) - 1] != '/')
@


1.12
log
@finish merging
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.91 2006/08/03 03:34:42 deraadt Exp $ */
d45 1
a45 1
__RCSID("$MirOS$");
d485 1
a485 1
	return(sb.st_mode & S_IFDIR);
d509 1
a509 1
	return(a->perm & S_IFDIR);
d969 1
@


1.11
log
@scp and sftp already disable tty allocation,
so no explicit setting of IPTOS_THROUGHPUT is
required any more
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.82 2006/05/17 12:43:34 markus Exp $ */
d18 1
a18 3
#include "includes.h"
__RCSID("$MirOS: src/usr.bin/ssh/sftp.c,v 1.10 2006/06/02 20:50:49 tg Exp $");

d22 1
d24 1
d29 5
a34 1
#include "buffer.h"
d41 1
d45 2
@


1.10
log
@* merge
* remove all references to GSSAPI, Kerberos and AFS
* uint*_t -> u_int*_t for consistency, like openbsd
  (note: MirOS style(9) suggests uint32_t etc. instead!)
* bump vsn
@
text
@d19 1
a19 1
__RCSID("$MirOS: src/usr.bin/ssh/sftp.c,v 1.9 2006/04/19 10:40:53 tg Exp $");
a1435 1
	addargs(&args, "-h");		/* disable tcp lowdelay */
@


1.9
log
@merge and clean up
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.80 2006/03/27 23:15:46 djm Exp $ */
d19 1
a19 1
__RCSID("$MirOS: src/usr.bin/ssh/sftp.c,v 1.8 2006/02/22 01:23:51 tg Exp $");
d542 1
a566 2
	if (abs_dst)
		xfree(abs_dst);
a1362 10
#ifdef USE_PIPES
	int pin[2], pout[2];

	if ((pipe(pin) == -1) || (pipe(pout) == -1))
		fatal("pipe: %s", strerror(errno));
	*in = pin[0];
	*out = pout[1];
	c_in = pout[0];
	c_out = pin[1];
#else /* USE_PIPES */
a1368 1
#endif /* USE_PIPES */
@


1.8
log
@merge; bump version; fix up manpages and includes a little
@
text
@d1 1
d19 1
a19 1
RCSID("$MirOS: src/usr.bin/ssh/sftp.c,v 1.7 2005/12/20 19:57:35 tg Exp $");
d239 1
a239 1
		error("Shell exited abormally");
d1280 1
d1293 1
d1350 1
d1447 1
a1447 1
	addargs(&args, ssh_program);
@


1.7
log
@fastmerge, bump version
@
text
@d18 1
d20 3
a22 1
RCSID("$MirOS: src/usr.bin/ssh/sftp.c,v 1.6 2005/11/23 19:45:15 tg Exp $");
d26 2
d1441 1
d1443 1
a1443 1
	addargs(&args, "ssh");		/* overwritten with ssh_program */
d1479 1
a1555 1
		args.list[0] = ssh_program;
d1568 1
@


1.6
log
@merge
@
text
@d19 1
a19 1
RCSID("$MirOS: src/usr.bin/ssh/sftp.c,v 1.5 2005/11/23 18:04:20 tg Exp $");
d1441 1
@


1.5
log
@fastmerge remainder of src/usr.bin
@
text
@d19 1
a19 1
RCSID("$MirOS: src/usr.bin/ssh/sftp.c,v 1.4 2005/06/22 16:11:39 tg Exp $");
d695 2
d1235 1
a1235 1
	int err;
d1294 1
d1304 2
a1305 1
			printf("sftp> ");
d1307 2
a1308 1
				printf("\n");
d1311 6
a1316 2
			if (batchmode) /* Echo command */
				printf("%s", cmd);
d1318 2
a1319 1
			if ((line = el_gets(el, &count)) == NULL || count <= 0)
d1321 1
d1343 3
d1433 3
@


1.4
log
@merge
@
text
@d19 1
a19 1
RCSID("$MirOS: src/usr.bin/ssh/sftp.c,v 1.3 2005/04/14 19:49:34 tg Exp $");
d1462 1
a1462 1
			   (infile = fopen(optarg, "r")) == NULL)
@


1.3
log
@merge
@
text
@d19 1
a19 1
RCSID("$MirOS: src/usr.bin/ssh/sftp.c,v 1.2 2005/03/13 18:33:31 tg Exp $");
d402 1
a402 1
	int i, j;
d662 2
a663 1
	int n, c = 1, colspace = 0, columns = 1;
d670 1
a670 1
		int m = 0, width = 80;
d746 1
a746 1
	int i, c = 1, colspace = 0, columns = 1;
d782 1
a782 1
		int m = 0, width = 80;
@


1.2
log
@merge src/usr.bin
@
text
@d19 1
a19 1
RCSID("$MirOS$");
d355 1
a355 1
		for(; strchr(WHITESPACE, *cp) == NULL; cp++) {
d1465 1
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.61 2005/01/24 10:22:06 dtucker Exp $");
d1420 1
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@OpenSSH-current
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.63 2005/03/10 22:01:05 deraadt Exp $");
d355 1
a355 1
		for (; strchr(WHITESPACE, *cp) == NULL; cp++) {
a1463 1
			addargs(&args, "-obatchmode yes");
@


1.1.1.3
log
@most current OpenSSH.com
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.64 2005/06/17 02:44:33 djm Exp $");
d402 1
a402 1
	u_int i, j;
d662 1
a662 2
	int n;
	u_int c = 1, colspace = 0, columns = 1;
d669 1
a669 1
		u_int m = 0, width = 80;
d745 1
a745 1
	u_int i, c = 1, colspace = 0, columns = 1;
d781 1
a781 1
		u_int m = 0, width = 80;
@


1.1.1.4
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.65 2005/07/17 07:17:55 djm Exp $");
d1461 1
a1461 1
			    (infile = fopen(optarg, "r")) == NULL)
@


1.1.1.5
log
@Import current OpenSSH
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.68 2005/10/31 06:15:04 dtucker Exp $");
a694 2
		for (n = 0; d[n] != NULL; n++)
			;	/* count entries */
d1233 1
a1233 1
	int err, interactive;
a1291 1
	interactive = !batchmode && isatty(STDIN_FILENO);
d1301 1
a1301 2
			if (interactive)
				printf("sftp> ");
d1303 1
a1303 2
				if (interactive)
					printf("\n");
d1306 2
a1307 6
			if (!interactive) { /* Echo command */
				printf("sftp> %s", cmd);
				if (strlen(cmd) > 0 &&
				    cmd[strlen(cmd) - 1] != '\n')
					printf("\n");
			}
d1309 1
a1309 2
			if ((line = el_gets(el, &count)) == NULL || count <= 0) {
				printf("\n");
a1310 1
			}
a1331 3
	if (el != NULL)
		el_end(el);

a1418 3
	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

@


1.1.1.6
log
@OpenSSH is the last missing piece to update before the release
@
text
@d19 1
a19 1
RCSID("$OpenBSD: sftp.c,v 1.69 2005/12/06 22:38:27 reyk Exp $");
a1439 1
	addargs(&args, "-oPermitLocalCommand no");
@


1.1.1.7
log
@import OpenSSH-current
@
text
@a17 1
RCSID("$OpenBSD: sftp.c,v 1.75 2006/02/20 17:19:54 stevesk Exp $");
d19 1
a19 4
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
a22 2
#include <paths.h>
#include <signal.h>
a1435 1
	memset(&args, '\0', sizeof(args));
d1437 1
a1437 1
	addargs(&args, ssh_program);
a1471 1
			replacearg(&args, 0, "%s", ssh_program);
d1548 1
a1560 1
	freeargs(&args);
@


1.1.1.8
log
@I decided we'd better upgrade OpenSSH before releasing to the general public
@
text
@a0 1
/* $OpenBSD: sftp.c,v 1.80 2006/03/27 23:15:46 djm Exp $ */
d18 1
d239 1
a239 1
		error("Shell exited abnormally");
a1279 1
				xfree(conn);
a1291 1
			xfree(conn);
a1347 1
	xfree(conn);
d1444 1
a1444 1
	addargs(&args, "%s", ssh_program);
@


1.1.1.9
log
@if we're gonna push out another snapshot, we'd better have sshd-current
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.82 2006/05/17 12:43:34 markus Exp $ */
a541 1
			xfree(tmp);
d566 2
d1364 10
d1380 1
@


1.1.1.10
log
@import a few security-wise relevant changes right now
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.91 2006/08/03 03:34:42 deraadt Exp $ */
d18 3
a21 1
#include <sys/ioctl.h>
a23 2
#include <sys/socket.h>
#include <sys/param.h>
a24 1
#include <errno.h>
a28 5
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdarg.h>
d30 1
a36 1
#include "buffer.h"
@


1.1.1.11
log
@OpenSSH 4.5 (security)
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.93 2006/09/30 17:48:22 ray Exp $ */
d484 1
a484 1
	return(S_ISDIR(sb.st_mode));
d508 1
a508 1
	return(S_ISDIR(a->perm));
a967 1
		errno = 0;
@


1.1.1.12
log
@current OpenSSH
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.94 2006/11/23 01:35:11 ray Exp $ */
d289 1
a289 1
	size_t len = strlen(p1) + strlen(p2) + 2;
d293 1
a293 1
	if (p1[0] != '\0' && p1[strlen(p1) - 1] != '/')
@


1.1.1.13
log
@update OpenSSH, while we're at it…
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.96 2007/01/03 04:09:15 stevesk Exp $ */
a156 1
/* ARGSUSED */
a167 1
/* ARGSUSED */
d1531 1
a1531 1
			addargs(&args, "-l%s", userhost);
@


1.1.1.14
log
@newer openssh
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.99 2008/01/20 00:38:30 djm Exp $ */
a24 1
#include <ctype.h>
d337 1
a337 1
parse_getput_flags(const char *cmd, char **argv, int argc, int *pflag)
d339 1
a339 2
	extern int optind, optreset, opterr;
	int ch;
d341 3
a343 6
	optind = optreset = 1;
	opterr = 0;

	*pflag = 0;
	while ((ch = getopt(argc, argv, "Pp")) != -1) {
		switch (ch) {
d349 2
a350 2
			error("%s: Invalid flag -%c", cmd, ch);
			return -1;
d352 2
d356 1
a356 1
	return optind;
d360 1
a360 1
parse_ls_flags(char **argv, int argc, int *lflag)
d362 1
a362 2
	extern int optind, optreset, opterr;
	int ch;
d364 2
a365 2
	optind = optreset = 1;
	opterr = 0;
d367 90
a456 35
	*lflag = LS_NAME_SORT;
	while ((ch = getopt(argc, argv, "1Saflnrt")) != -1) {
		switch (ch) {
		case '1':
			*lflag &= ~VIEW_FLAGS;
			*lflag |= LS_SHORT_VIEW;
			break;
		case 'S':
			*lflag &= ~SORT_FLAGS;
			*lflag |= LS_SIZE_SORT;
			break;
		case 'a':
			*lflag |= LS_SHOW_ALL;
			break;
		case 'f':
			*lflag &= ~SORT_FLAGS;
			break;
		case 'l':
			*lflag &= ~VIEW_FLAGS;
			*lflag |= LS_LONG_VIEW;
			break;
		case 'n':
			*lflag &= ~VIEW_FLAGS;
			*lflag |= LS_NUMERIC_VIEW|LS_LONG_VIEW;
			break;
		case 'r':
			*lflag |= LS_REVERSE_SORT;
			break;
		case 't':
			*lflag &= ~SORT_FLAGS;
			*lflag |= LS_TIME_SORT;
			break;
		default:
			error("ls: Invalid flag -%c", ch);
			return -1;
d458 10
d469 1
d471 4
a474 1
	return optind;
d490 11
a587 1
	struct stat sb;
d596 1
a596 1
	if (glob(src, GLOB_NOCHECK, NULL, &g)) {
d611 1
a611 7
		if (stat(g.gl_pathv[i], &sb) == -1) {
			err = -1;
			error("stat %s: %s", g.gl_pathv[i], strerror(errno));
			continue;
		}

		if (!S_ISREG(sb.st_mode)) {
a856 174
/*
 * Undo escaping of glob sequences in place. Used to undo extra escaping
 * applied in makeargv() when the string is destined for a function that
 * does not glob it.
 */
static void
undo_glob_escape(char *s)
{
	size_t i, j;

	for (i = j = 0;;) {
		if (s[i] == '\0') {
			s[j] = '\0';
			return;
		}
		if (s[i] != '\\') {
			s[j++] = s[i++];
			continue;
		}
		/* s[i] == '\\' */
		++i;
		switch (s[i]) {
		case '?':
		case '[':
		case '*':
		case '\\':
			s[j++] = s[i++];
			break;
		case '\0':
			s[j++] = '\\';
			s[j] = '\0';
			return;
		default:
			s[j++] = '\\';
			s[j++] = s[i++];
			break;
		}
	}
}

/*
 * Split a string into an argument vector using sh(1)-style quoting,
 * comment and escaping rules, but with some tweaks to handle glob(3)
 * wildcards.
 * Returns NULL on error or a NULL-terminated array of arguments.
 */
#define MAXARGS 	128
#define MAXARGLEN	8192
static char **
makeargv(const char *arg, int *argcp)
{
	int argc, quot;
	size_t i, j;
	static char argvs[MAXARGLEN];
	static char *argv[MAXARGS + 1];
	enum { MA_START, MA_SQUOTE, MA_DQUOTE, MA_UNQUOTED } state, q;

	*argcp = argc = 0;
	if (strlen(arg) > sizeof(argvs) - 1) {
 args_too_longs:
		error("string too long");
		return NULL;
	}
	state = MA_START;
	i = j = 0;
	for (;;) {
		if (isspace(arg[i])) {
			if (state == MA_UNQUOTED) {
				/* Terminate current argument */
				argvs[j++] = '\0';
				argc++;
				state = MA_START;
			} else if (state != MA_START)
				argvs[j++] = arg[i];
		} else if (arg[i] == '"' || arg[i] == '\'') {
			q = arg[i] == '"' ? MA_DQUOTE : MA_SQUOTE;
			if (state == MA_START) {
				argv[argc] = argvs + j;
				state = q;
			} else if (state == MA_UNQUOTED) 
				state = q;
			else if (state == q)
				state = MA_UNQUOTED;
			else
				argvs[j++] = arg[i];
		} else if (arg[i] == '\\') {
			if (state == MA_SQUOTE || state == MA_DQUOTE) {
				quot = state == MA_SQUOTE ? '\'' : '"';
				/* Unescape quote we are in */
				/* XXX support \n and friends? */
				if (arg[i + 1] == quot) {
					i++;
					argvs[j++] = arg[i];
				} else if (arg[i + 1] == '?' ||
				    arg[i + 1] == '[' || arg[i + 1] == '*') {
					/*
					 * Special case for sftp: append
					 * double-escaped glob sequence -
					 * glob will undo one level of
					 * escaping. NB. string can grow here.
					 */
					if (j >= sizeof(argvs) - 5)
						goto args_too_longs;
					argvs[j++] = '\\';
					argvs[j++] = arg[i++];
					argvs[j++] = '\\';
					argvs[j++] = arg[i];
				} else {
					argvs[j++] = arg[i++];
					argvs[j++] = arg[i];
				}
			} else {
				if (state == MA_START) {
					argv[argc] = argvs + j;
					state = MA_UNQUOTED;
				}
				if (arg[i + 1] == '?' || arg[i + 1] == '[' ||
				    arg[i + 1] == '*' || arg[i + 1] == '\\') {
					/*
					 * Special case for sftp: append
					 * escaped glob sequence -
					 * glob will undo one level of
					 * escaping.
					 */
					argvs[j++] = arg[i++];
					argvs[j++] = arg[i];
				} else {
					/* Unescape everything */
					/* XXX support \n and friends? */
					i++;
					argvs[j++] = arg[i];
				}
			}
		} else if (arg[i] == '#') {
			if (state == MA_SQUOTE || state == MA_DQUOTE)
				argvs[j++] = arg[i];
			else
				goto string_done;
		} else if (arg[i] == '\0') {
			if (state == MA_SQUOTE || state == MA_DQUOTE) {
				error("Unterminated quoted argument");
				return NULL;
			}
 string_done:
			if (state == MA_UNQUOTED) {
				argvs[j++] = '\0';
				argc++;
			}
			break;
		} else {
			if (state == MA_START) {
				argv[argc] = argvs + j;
				state = MA_UNQUOTED;
			}
			if ((state == MA_SQUOTE || state == MA_DQUOTE) &&
			    (arg[i] == '?' || arg[i] == '[' || arg[i] == '*')) {
				/*
				 * Special case for sftp: escape quoted
				 * glob(3) wildcards. NB. string can grow
				 * here.
				 */
				if (j >= sizeof(argvs) - 3)
					goto args_too_longs;
				argvs[j++] = '\\';
				argvs[j++] = arg[i];
			} else
				argvs[j++] = arg[i];
		}
		i++;
	}
	*argcp = argc;
	return argv;
}

d862 1
a862 1
	char *cp2, **argv;
d865 1
a865 1
	int i, cmdnum, optidx, argc;
d881 3
a883 2
	if ((argv = makeargv(cp, &argc)) == NULL)
		return -1;
d885 5
a889 3
	/* Figure out which command we have */
	for (i = 0; cmds[i].c != NULL; i++) {
		if (strcasecmp(cmds[i].c, argv[0]) == 0)
d891 1
d902 1
a902 1
		return -1;
a907 1
	optidx = 1;
d911 2
a912 2
		if ((optidx = parse_getput_flags(cmd, argv, argc, pflag)) == -1)
			return -1;
d914 3
a916 1
		if (argc - optidx < 1) {
d919 1
a919 8
			return -1;
		}
		*path1 = xstrdup(argv[optidx]);
		/* Get second pathname (optional) */
		if (argc - optidx > 1) {
			*path2 = xstrdup(argv[optidx + 1]);
			/* Destination is not globbed */
			undo_glob_escape(*path2);
d921 3
d927 5
a931 1
		if (argc - optidx < 2) {
d934 1
a934 1
			return -1;
a935 5
		*path1 = xstrdup(argv[optidx]);
		*path2 = xstrdup(argv[optidx + 1]);
		/* Paths are not globbed */
		undo_glob_escape(*path1);
		undo_glob_escape(*path2);
d944 3
a946 1
		if (argc - optidx < 1) {
d949 1
a949 1
			return -1;
a950 4
		*path1 = xstrdup(argv[optidx]);
		/* Only "rm" globs */
		if (cmdnum != I_RM)
			undo_glob_escape(*path1);
d953 1
a953 1
		if ((optidx = parse_ls_flags(argv, argc, lflag)) == -1)
d956 2
a957 2
		if (argc - optidx > 0)
			*path1 = xstrdup(argv[optidx]);
a959 2
		/* Skip ls command and following whitespace */
		cp = cp + strlen(cmd) + strspn(cp, WHITESPACE);
d964 1
a969 2
		if (argc - optidx < 1)
			goto need_num_arg;
d971 3
a973 5
		l = strtol(argv[optidx], &cp2, base);
		if (cp2 == argv[optidx] || *cp2 != '\0' ||
		    ((l == LONG_MIN || l == LONG_MAX) && errno == ERANGE) ||
		    l < 0) {
 need_num_arg:
d976 1
a976 1
			return -1;
d978 1
d980 1
a980 1
		if (cmdnum == I_LUMASK)
d982 7
d990 3
a992 1
		if (argc - optidx < 2) {
d995 1
a995 1
			return -1;
a996 1
		*path1 = xstrdup(argv[optidx + 1]);
@


1.1.1.15
log
@OpenSSH-current
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.106 2008/12/09 15:35:00 sobrado Exp $ */
a23 1
#include <sys/statvfs.h>
a34 1
#include <util.h>
d57 1
a57 1
size_t num_requests = 64;
a94 1
#define I_DF		24
a126 1
	{ "df",		I_DF },
d185 28
a212 31
	printf("Available commands:\n"
	    "bye                                Quit sftp\n"
	    "cd path                            Change remote directory to 'path'\n"
	    "chgrp grp path                     Change group of file 'path' to 'grp'\n"
	    "chmod mode path                    Change permissions of file 'path' to 'mode'\n"
	    "chown own path                     Change owner of file 'path' to 'own'\n"
	    "df [-hi] [path]                    Display statistics for current directory or\n"
	    "                                   filesystem containing 'path'\n"
	    "exit                               Quit sftp\n"
	    "get [-P] remote-path [local-path]  Download file\n"
	    "help                               Display this help text\n"
	    "lcd path                           Change local directory to 'path'\n"
	    "lls [ls-options [path]]            Display local directory listing\n"
	    "lmkdir path                        Create local directory\n"
	    "ln oldpath newpath                 Symlink remote file\n"
	    "lpwd                               Print local working directory\n"
	    "ls [-1aflnrSt] [path]              Display remote directory listing\n"
	    "lumask umask                       Set local umask to 'umask'\n"
	    "mkdir path                         Create remote directory\n"
	    "progress                           Toggle display of progress meter\n"
	    "put [-P] local-path [remote-path]  Upload file\n"
	    "pwd                                Display remote working directory\n"
	    "quit                               Quit sftp\n"
	    "rename oldpath newpath             Rename remote file\n"
	    "rm path                            Delete remote file\n"
	    "rmdir path                         Remove remote directory\n"
	    "symlink oldpath newpath            Symlink remote file\n"
	    "version                            Show SFTP version\n"
	    "!command                           Execute 'command' in local shell\n"
	    "!                                  Escape to local shell\n"
	    "?                                  Synonym for help\n");
d340 1
a340 1
	extern int opterr, optind, optopt, optreset;
d354 1
a354 1
			error("%s: Invalid flag -%c", cmd, optopt);
d365 1
a365 1
	extern int opterr, optind, optopt, optreset;
d404 1
a404 28
			error("ls: Invalid flag -%c", optopt);
			return -1;
		}
	}

	return optind;
}

static int
parse_df_flags(const char *cmd, char **argv, int argc, int *hflag, int *iflag)
{
	extern int opterr, optind, optopt, optreset;
	int ch;

	optind = optreset = 1;
	opterr = 0;

	*hflag = *iflag = 0;
	while ((ch = getopt(argc, argv, "hi")) != -1) {
		switch (ch) {
		case 'h':
			*hflag = 1;
			break;
		case 'i':
			*iflag = 1;
			break;
		default:
			error("%s: Invalid flag -%c", cmd, optopt);
a787 50
static int
do_df(struct sftp_conn *conn, char *path, int hflag, int iflag)
{
	struct sftp_statvfs st;
	char s_used[FMT_SCALED_STRSIZE];
	char s_avail[FMT_SCALED_STRSIZE];
	char s_root[FMT_SCALED_STRSIZE];
	char s_total[FMT_SCALED_STRSIZE];

	if (do_statvfs(conn, path, &st, 1) == -1)
		return -1;
	if (iflag) {
		printf("     Inodes        Used       Avail      "
		    "(root)    %%Capacity\n");
		printf("%11llu %11llu %11llu %11llu         %3llu%%\n",
		    (unsigned long long)st.f_files,
		    (unsigned long long)(st.f_files - st.f_ffree),
		    (unsigned long long)st.f_favail,
		    (unsigned long long)st.f_ffree,
		    (unsigned long long)(100 * (st.f_files - st.f_ffree) /
		    st.f_files));
	} else if (hflag) {
		strlcpy(s_used, "error", sizeof(s_used));
		strlcpy(s_avail, "error", sizeof(s_avail));
		strlcpy(s_root, "error", sizeof(s_root));
		strlcpy(s_total, "error", sizeof(s_total));
		fmt_scaled((st.f_blocks - st.f_bfree) * st.f_frsize, s_used);
		fmt_scaled(st.f_bavail * st.f_frsize, s_avail);
		fmt_scaled(st.f_bfree * st.f_frsize, s_root);
		fmt_scaled(st.f_blocks * st.f_frsize, s_total);
		printf("    Size     Used    Avail   (root)    %%Capacity\n");
		printf("%7sB %7sB %7sB %7sB         %3llu%%\n",
		    s_total, s_used, s_avail, s_root,
		    (unsigned long long)(100 * (st.f_blocks - st.f_bfree) /
		    st.f_blocks));
	} else {
		printf("        Size         Used        Avail       "
		    "(root)    %%Capacity\n");
		printf("%12llu %12llu %12llu %12llu         %3llu%%\n",
		    (unsigned long long)(st.f_frsize * st.f_blocks / 1024),
		    (unsigned long long)(st.f_frsize *
		    (st.f_blocks - st.f_bfree) / 1024),
		    (unsigned long long)(st.f_frsize * st.f_bavail / 1024),
		    (unsigned long long)(st.f_frsize * st.f_bfree / 1024),
		    (unsigned long long)(100 * (st.f_blocks - st.f_bfree) /
		    st.f_blocks));
	}
	return 0;
}

d963 1
a963 1
parse_args(const char **cpp, int *pflag, int *lflag, int *iflag, int *hflag,
d1007 1
a1007 1
	*lflag = *pflag = *hflag = *n_arg = 0;
a1058 12
	case I_DF:
		if ((optidx = parse_df_flags(cmd, argv, argc, hflag,
		    iflag)) == -1)
			return -1;
		/* Default to current directory if no path specified */
		if (argc - optidx < 1)
			*path1 = NULL;
		else {
			*path1 = xstrdup(argv[optidx]);
			undo_glob_escape(*path1);
		}
		break;
d1121 1
a1121 1
	int pflag, lflag, iflag, hflag, cmdnum, i;
d1129 1
a1129 1
	cmdnum = parse_args(&cmd, &pflag, &lflag, &iflag, &hflag, &n_arg,
a1222 7
	case I_DF:
		/* Default to current directory if no path specified */
		if (path1 == NULL)
			path1 = xstrdup(*pwd);
		path1 = make_absolute(path1, *pwd);
		err = do_df(conn, path1, hflag, iflag);
		break;
d1266 1
a1266 2
				if (err_abort) {
					err = -1;
d1268 1
a1268 1
				} else
d1274 1
a1274 2
				if (err_abort) {
					err = -1;
d1276 1
a1276 1
				} else
d1523 2
a1524 2
	    "       %s [user@@]host[:file ...]\n"
	    "       %s [user@@]host[:dir[/]]\n"
@


1.1.1.16
log
@OpenSSH 5.2, or so
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.107 2009/02/02 11:15:14 dtucker Exp $ */
d1217 2
a1218 2
	int pflag = 0, lflag = 0, iflag = 0, hflag = 0, cmdnum, i;
	unsigned long n_arg = 0;
@


1.1.1.17
log
@Let’s play the version number game – OpenSSH 5.3-current
@
text
@d1 1
a1 1
/* $OpenBSD: sftp.c,v 1.111 2009/08/18 18:36:21 djm Exp $ */
a30 1
#include <libgen.h>
a66 6
/* When this option is set, we always recursively download/upload directories */
int global_rflag = 0;

/* When this option is set, the file transfers will always preserve times */
int global_pflag = 0;

d198 1
a198 1
	    "get [-Pr] remote-path [local-path] Download file\n"
d209 1
a209 1
	    "put [-Pr] local-path [remote-path] Upload file\n"
d296 15
d325 21
a345 2
parse_getput_flags(const char *cmd, char **argv, int argc, int *pflag,
    int *rflag)
d353 2
a354 2
	*rflag = *pflag = 0;
	while ((ch = getopt(argc, argv, "PpRr")) != -1) {
a359 4
		case 'r':
		case 'R':
			*rflag = 1;
			break;
a470 1
/* Check whether path returned from glob(..., GLOB_MARK, ...) is a directory */
d472 1
a472 10
pathname_is_dir(char *pathname)
{
	size_t l = strlen(pathname);

	return l > 0 && pathname[l - 1] == '/';
}

static int
process_get(struct sftp_conn *conn, char *src, char *dst, char *pwd,
    int pflag, int rflag)
d476 1
d478 2
a479 2
	char *filename, *tmp=NULL;
	int i, err = 0;
d483 1
a484 1

d486 1
a486 1
	if (remote_glob(conn, abs_src, GLOB_MARK, NULL, &g)) {
d492 4
a495 7
	/*
	 * If multiple matches then dst must be a directory or
	 * unspecified.
	 */
	if (g.gl_matchc > 1 && dst != NULL && !is_dir(dst)) {
		error("Multiple source paths, but destination "
		    "\"%s\" is not a directory", dst);
d501 1
a501 4
		tmp = xstrdup(g.gl_pathv[i]);
		if ((filename = basename(tmp)) == NULL) {
			error("basename %s: %s", tmp, strerror(errno));
			xfree(tmp);
d507 2
d510 7
a516 2
				abs_dst = path_append(dst, filename);
			} else {
a517 1
			}
d519 4
a522 5
			abs_dst = path_append(dst, filename);
		} else {
			abs_dst = xstrdup(filename);
		}
		xfree(tmp);
d525 2
a526 9
		if (pathname_is_dir(g.gl_pathv[i]) && (rflag || global_rflag)) {
			if (download_dir(conn, g.gl_pathv[i], abs_dst, NULL, 
			    pflag || global_pflag, 1) == -1)
				err = -1;
		} else {
			if (do_download(conn, g.gl_pathv[i], abs_dst, NULL,
			    pflag || global_pflag) == -1)
				err = -1;
		}
d538 1
a538 2
process_put(struct sftp_conn *conn, char *src, char *dst, char *pwd,
    int pflag, int rflag)
d542 1
a542 1
	char *tmp = NULL, *filename = NULL;
d545 1
a545 1
	int i, dst_is_dir = 1;
d555 1
a555 1
	if (glob(src, GLOB_NOCHECK | GLOB_MARK, NULL, &g)) {
a560 4
	/* If we aren't fetching to pwd then stash this status for later */
	if (tmp_dst != NULL)
		dst_is_dir = remote_is_dir(conn, tmp_dst);

d562 3
a564 3
	if (g.gl_matchc > 1 && tmp_dst && !dst_is_dir) {
		error("Multiple paths match, but destination "
		    "\"%s\" is not a directory", tmp_dst);
d575 7
a581 5
		
		tmp = xstrdup(g.gl_pathv[i]);
		if ((filename = basename(tmp)) == NULL) {
			error("basename %s: %s", tmp, strerror(errno));
			xfree(tmp);
d588 8
a595 3
			if (dst_is_dir)
				abs_dst = path_append(tmp_dst, filename);
			else
d597 1
d599 4
a602 5
			abs_dst = path_append(tmp_dst, filename);
		} else {
			abs_dst = make_absolute(xstrdup(filename), pwd);
		}
		xfree(tmp);
d605 2
a606 9
		if (pathname_is_dir(g.gl_pathv[i]) && (rflag || global_rflag)) {
			if (upload_dir(conn, g.gl_pathv[i], abs_dst,
			    pflag || global_pflag, 1) == -1)
				err = -1;
		} else {
			if (do_upload(conn, g.gl_pathv[i], abs_dst,
			    pflag || global_pflag) == -1)
				err = -1;
		}
d1047 1
a1047 1
parse_args(const char **cpp, int *pflag, int *rflag, int *lflag, int *iflag, int *hflag,
d1091 1
a1091 1
	*lflag = *pflag = *rflag = *hflag = *n_arg = 0;
d1097 1
a1097 1
		if ((optidx = parse_getput_flags(cmd, argv, argc, pflag, rflag)) == -1)
d1217 1
a1217 1
	int pflag = 0, rflag = 0, lflag = 0, iflag = 0, hflag = 0, cmdnum, i;
d1225 1
a1225 1
	cmdnum = parse_args(&cmd, &pflag, &rflag, &lflag, &iflag, &hflag, &n_arg,
d1243 1
a1243 1
		err = process_get(conn, path1, path2, *pwd, pflag, rflag);
d1246 1
a1246 1
		err = process_put(conn, path1, path2, *pwd, pflag, rflag);
d1272 1
a1272 1
		err = do_mkdir(conn, path1, &a, 1);
d1625 3
a1627 6
	    "usage: %s [-1246Cpqrv] [-B buffer_size] [-b batchfile] [-c cipher]\n"
	    "          [-D sftp_server_path] [-F ssh_config] "
	    "[-i identity_file]\n"
	    "          [-o ssh_option] [-P port] [-R num_requests] "
	    "[-S program]\n"
	    "          [-s subsystem | sftp_server] host\n"
d1630 1
a1630 2
	    "       %s -b batchfile [user@@]host\n",
	    __progname, __progname, __progname, __progname);
d1661 1
a1661 2
	while ((ch = getopt(argc, argv,
	    "1246hqrvCc:D:i:o:s:S:b:B:F:P:R:")) != -1) {
a1662 3
		/* Passed through to ssh(1) */
		case '4':
		case '6':
d1664 1
a1664 15
			addargs(&args, "-%c", ch);
			break;
		/* Passed through to ssh(1) with argument */
		case 'F':
		case 'c':
		case 'i':
		case 'o':
			addargs(&args, "-%c%s", ch, optarg);
			break;
		case 'q':
			showprogress = 0;
			addargs(&args, "-%c", ch);
			break;
		case 'P':
			addargs(&args, "-oPort %s", optarg);
d1673 4
d1682 2
a1683 2
		case '2':
			sshver = 2;
d1685 3
a1687 4
		case 'B':
			copy_buffer_len = strtol(optarg, &cp, 10);
			if (copy_buffer_len == 0 || *cp != '\0')
				fatal("Invalid buffer size \"%s\"", optarg);
d1701 1
a1701 4
		case 'p':
			global_pflag = 1;
			break;
		case 'D':
d1704 4
a1707 2
		case 'r':
			global_rflag = 1;
a1714 7
		case 's':
			sftp_server = optarg;
			break;
		case 'S':
			ssh_program = optarg;
			replacearg(&args, 0, "%s", ssh_program);
			break;
@


