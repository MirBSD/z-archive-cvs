head	1.26;
access;
symbols
	cvs-200910041320:1.1.1.15
	cvs-200903221200:1.1.1.14
	cvs-200812162015:1.1.1.13
	cvs-200804031830:1.1.1.12
	MIRBSD_10:1.19.0.2
	MIRBSD_10_BASE:1.19
	cvs-200803022030:1.1.1.12
	cvs-200709131337:1.1.1.11
	cvs-200709021830:1.1.1.11
	cvs-200708201200:1.1.1.11
	cvs-200706161500:1.1.1.11
	cvs-200705192215:1.1.1.11
	cvs-200704292000:1.1.1.11
	cvs-200703080900:1.1.1.9
	cvs-200701251600:1.1.1.8
	cvs-200612111600:1.1.1.7
	cvs-200611090230:1.1.1.7
	OPENBSD_4_0:1.1.1.7
	MIRBSD_9_BASE:1.9
	cvs-200606162342:1.1.1.6
	cvs-200606022000:1.1.1.6
	cvs-200604191000:1.1.1.6
	cvs-200602220045:1.1.1.5
	MIRBSD_8:1.6.0.2
	MIRBSD_8_BASE:1.6
	cvs-200512201942:1.1.1.5
	cvs-200511231930:1.1.1.4
	cvs-200507211800:1.1.1.3
	cvs-200506221550:1.1.1.3
	cvs-200505050030:1.1.1.2
	cvs-200504291700:1.1.1.2
	cvs-200504261445:1.1.1.2
	cvs-200504141900:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2018.05.03.01.32.46;	author tg;	state Exp;
branches;
next	1.25;
commitid	1005AEA669C604AC341;

1.25
date	2014.03.28.22.31.57;	author tg;	state Exp;
branches;
next	1.24;
commitid	1005335F87233372394;

1.24
date	2011.01.15.21.52.41;	author tg;	state Exp;
branches;
next	1.23;
commitid	1004D32173B08BB4E36;

1.23
date	2009.10.04.14.29.07;	author tg;	state Exp;
branches;
next	1.22;
commitid	1004AC8B1276FC00211;

1.22
date	2009.03.22.15.01.19;	author tg;	state Exp;
branches;
next	1.21;
commitid	10049C652CD5CCC321F;

1.21
date	2008.12.16.22.13.29;	author tg;	state Exp;
branches;
next	1.20;
commitid	10049482819766381ED;

1.20
date	2008.12.16.20.55.26;	author tg;	state Exp;
branches;
next	1.19;
commitid	100494815C97ECEEDBF;

1.19
date	2008.03.02.21.14.21;	author tg;	state Exp;
branches;
next	1.18;
commitid	10047CB18BB506A8527;

1.18
date	2007.04.29.20.23.13;	author tg;	state Exp;
branches;
next	1.17;
commitid	1004634FEC2113C55F5;

1.17
date	2007.03.18.04.27.34;	author tg;	state Exp;
branches;
next	1.16;
commitid	10045FCBFC419085D08;

1.16
date	2007.03.08.10.09.32;	author tg;	state Exp;
branches;
next	1.15;
commitid	10045EFE0F11EDE1747;

1.15
date	2007.01.25.16.18.37;	author tg;	state Exp;
branches;
next	1.14;
commitid	10045B8D86E5B698AD6;

1.14
date	2006.09.21.21.54.43;	author tg;	state Exp;
branches;
next	1.13;
commitid	10045130A235D034322;

1.13
date	2006.09.21.21.48.58;	author tg;	state Exp;
branches;
next	1.12;
commitid	100451308CB77F69B71;

1.12
date	2006.09.21.21.47.31;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004513087842C65EF9;

1.11
date	2006.09.20.21.41.02;	author tg;	state Exp;
branches;
next	1.10;
commitid	1004511B578580E7F04;

1.10
date	2006.07.23.14.19.27;	author tg;	state Exp;
branches;
next	1.9;
commitid	10044C3857E74BD315F;

1.9
date	2006.06.02.20.50.48;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004480A4952B0D84EA;

1.8
date	2006.04.19.10.40.51;	author tg;	state Exp;
branches;
next	1.7;
commitid	100444613BD3A91C28B;

1.7
date	2006.02.22.02.16.48;	author tg;	state Exp;
branches;
next	1.6;
commitid	10043FBC991512A442B;

1.6
date	2005.12.20.19.57.34;	author tg;	state Exp;
branches;
next	1.5;
commitid	10043A8623F4C1F637E;

1.5
date	2005.11.23.19.45.14;	author tg;	state Exp;
branches;
next	1.4;
commitid	29f4384c6def7d1;

1.4
date	2005.06.22.16.11.39;	author tg;	state Exp;
branches;
next	1.3;
commitid	598b42b98dcf335f;

1.3
date	2005.04.14.19.49.34;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.13.18.33.30;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.29.52;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.29.52;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.14.19.33.28;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.06.22.15.56.28;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	181342b98a38fe99;

1.1.1.4
date	2005.11.23.19.34.15;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	116a4384c4467ffc;

1.1.1.5
date	2005.12.20.19.43.44;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	10043A85EF81EF097CF;

1.1.1.6
date	2006.04.19.10.15.04;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	10044460DB21E1F715C;

1.1.1.7
date	2006.09.20.19.06.49;	author tg;	state Exp;
branches;
next	1.1.1.8;
commitid	10045119150397FC669;

1.1.1.8
date	2007.01.25.16.13.13;	author tg;	state Exp;
branches;
next	1.1.1.9;
commitid	10045B8D7100791C016;

1.1.1.9
date	2007.03.08.09.23.22;	author tg;	state Exp;
branches;
next	1.1.1.10;
commitid	10045EFD61903FC276A;

1.1.1.10
date	2007.03.18.04.26.55;	author tg;	state Exp;
branches;
next	1.1.1.11;
commitid	10045FCBF95192DD462;

1.1.1.11
date	2007.04.29.20.07.02;	author tg;	state Exp;
branches;
next	1.1.1.12;
commitid	1004634FAED5BC54DF0;

1.1.1.12
date	2008.03.02.20.40.42;	author tg;	state Exp;
branches;
next	1.1.1.13;
commitid	10047CB10DD30FAF062;

1.1.1.13
date	2008.12.16.20.15.33;	author tg;	state Exp;
branches;
next	1.1.1.14;
commitid	10049480C7A2701F5C0;

1.1.1.14
date	2009.03.22.12.03.00;	author tg;	state Exp;
branches;
next	1.1.1.15;
commitid	10049C6290649163EA3;

1.1.1.15
date	2009.10.04.13.25.45;	author tg;	state Exp;
branches;
next	;
commitid	1004AC8A2663BC008C5;


desc
@@


1.26
log
@implement a new config directive MaskRemoteAddress

this is suitable for either hiding a̲l̲l̲ remote identities (if used globally)
or the identity of successful logins (for a Match block — e.g. for anoncvs)
@
text
@/* $OpenBSD: servconf.c,v 1.195 2009/04/14 21:10:54 jj Exp $ */
/*
 * Copyright (c) 1995 Tatu Ylonen <ylo@@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>

#include <netdb.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>
#include <stdarg.h>
#include <errno.h>

#include "xmalloc.h"
#include "ssh.h"
#include "log.h"
#include "buffer.h"
#include "servconf.h"
#include "compat.h"
#include "pathnames.h"
#include "misc.h"
#include "cipher.h"
#include "key.h"
#include "kex.h"
#include "mac.h"
#include "match.h"
#include "channels.h"
#include "groupaccess.h"
#include "canohost.h"

__RCSID("$MirOS: src/usr.bin/ssh/servconf.c,v 1.24 2011/01/15 21:52:41 tg Exp $");

static void add_listen_addr(ServerOptions *, char *, int);
static void add_one_listen_addr(ServerOptions *, char *, int);

/* Use of privilege separation or not */
extern int use_privsep;
extern Buffer cfg;

/* Initializes the server options to their default values. */

void
initialize_server_options(ServerOptions *options)
{
	memset(options, 0, sizeof(*options));
	options->num_ports = 0;
	options->ports_from_cmdline = 0;
	options->listen_addrs = NULL;
	options->address_family = -1;
	options->num_host_key_files = 0;
	options->pid_file = NULL;
	options->server_key_bits = -1;
	options->login_grace_time = -1;
	options->key_regeneration_time = -1;
	options->permit_root_login = PERMIT_NOT_SET;
	options->ignore_rhosts = -1;
	options->ignore_user_known_hosts = -1;
	options->print_motd = -1;
	options->print_lastlog = -1;
	options->x11_forwarding = -1;
	options->x11_display_offset = -1;
	options->x11_use_localhost = -1;
	options->xauth_location = NULL;
	options->strict_modes = -1;
	options->tcp_keep_alive = -1;
	options->log_facility = SYSLOG_FACILITY_NOT_SET;
	options->log_level = SYSLOG_LEVEL_NOT_SET;
	options->rhosts_rsa_authentication = -1;
	options->hostbased_authentication = -1;
	options->hostbased_uses_name_from_packet_only = -1;
	options->rsa_authentication = -1;
	options->pubkey_authentication = -1;
	options->password_authentication = -1;
	options->kbd_interactive_authentication = -1;
	options->challenge_response_authentication = -1;
	options->permit_empty_passwd = -1;
	options->permit_user_env = -1;
	options->use_login = -1;
	options->compression = -1;
	options->allow_tcp_forwarding = -1;
	options->allow_agent_forwarding = -1;
	options->num_allow_users = 0;
	options->num_deny_users = 0;
	options->num_allow_groups = 0;
	options->num_deny_groups = 0;
	options->ciphers = NULL;
	options->macs = NULL;
	options->protocol = SSH_PROTO_UNKNOWN;
	options->gateway_ports = -1;
	options->num_subsystems = 0;
	options->max_startups_begin = -1;
	options->max_startups_rate = -1;
	options->max_startups = -1;
	options->max_authtries = -1;
	options->max_sessions = -1;
	options->banner = NULL;
	options->use_dns = -1;
	options->client_alive_interval = -1;
	options->client_alive_count_max = -1;
	options->authorised_keys_file1 = NULL;
	options->authorised_keys_file2 = NULL;
	options->num_accept_env = 0;
	options->permit_tun = -1;
	options->num_permitted_opens = -1;
	options->adm_forced_command = NULL;
	options->chroot_directory = NULL;
	options->mask_remote = -1;
}

void
fill_default_server_options(ServerOptions *options)
{
	if (options->protocol == SSH_PROTO_UNKNOWN)
		options->protocol = SSH_PROTO_1|SSH_PROTO_2;
	if (options->num_host_key_files == 0) {
		/* fill default hostkeys for protocols */
		if (options->protocol & SSH_PROTO_1)
			options->host_key_files[options->num_host_key_files++] =
			    (char *)_PATH_HOST_KEY_FILE;
		if (options->protocol & SSH_PROTO_2) {
			options->host_key_files[options->num_host_key_files++] =
			    (char *)_PATH_HOST_RSA_KEY_FILE;
			options->host_key_files[options->num_host_key_files++] =
			    (char *)_PATH_HOST_DSA_KEY_FILE;
		}
	}
	if (options->num_ports == 0)
		options->ports[options->num_ports++] = SSH_DEFAULT_PORT;
	if (options->listen_addrs == NULL)
		add_listen_addr(options, NULL, 0);
	if (options->pid_file == NULL)
		options->pid_file = (char *)_PATH_SSH_DAEMON_PID_FILE;
	if (options->server_key_bits == -1)
		options->server_key_bits = 1024;
	if (options->login_grace_time == -1)
		options->login_grace_time = 120;
	if (options->key_regeneration_time == -1)
		options->key_regeneration_time = 3600;
	if (options->permit_root_login == PERMIT_NOT_SET)
		options->permit_root_login = PERMIT_NO;
	if (options->ignore_rhosts == -1)
		options->ignore_rhosts = 1;
	if (options->ignore_user_known_hosts == -1)
		options->ignore_user_known_hosts = 0;
	if (options->print_motd == -1)
		options->print_motd = 1;
	if (options->print_lastlog == -1)
		options->print_lastlog = 1;
	if (options->x11_forwarding == -1)
		options->x11_forwarding = 0;
	if (options->x11_display_offset == -1)
		options->x11_display_offset = 10;
	if (options->x11_use_localhost == -1)
		options->x11_use_localhost = 1;
	if (options->xauth_location == NULL)
		options->xauth_location = (char *)_PATH_XAUTH;
	if (options->strict_modes == -1)
		options->strict_modes = 1;
	if (options->tcp_keep_alive == -1)
		options->tcp_keep_alive = 1;
	if (options->log_facility == SYSLOG_FACILITY_NOT_SET)
		options->log_facility = SYSLOG_FACILITY_AUTH;
	if (options->log_level == SYSLOG_LEVEL_NOT_SET)
		options->log_level = SYSLOG_LEVEL_INFO;
	if (options->rhosts_rsa_authentication == -1)
		options->rhosts_rsa_authentication = 0;
	if (options->hostbased_authentication == -1)
		options->hostbased_authentication = 0;
	if (options->hostbased_uses_name_from_packet_only == -1)
		options->hostbased_uses_name_from_packet_only = 0;
	if (options->rsa_authentication == -1)
		options->rsa_authentication = 1;
	if (options->pubkey_authentication == -1)
		options->pubkey_authentication = 1;
	if (options->password_authentication == -1)
		options->password_authentication = 1;
	if (options->kbd_interactive_authentication == -1)
		options->kbd_interactive_authentication = 0;
	if (options->challenge_response_authentication == -1)
		options->challenge_response_authentication = 1;
	if (options->permit_empty_passwd == -1)
		options->permit_empty_passwd = 0;
	if (options->permit_user_env == -1)
		options->permit_user_env = 0;
	if (options->use_login == -1)
		options->use_login = 0;
	if (options->compression == -1)
		options->compression = COMP_DELAYED;
	if (options->allow_tcp_forwarding == -1)
		options->allow_tcp_forwarding = 1;
	if (options->allow_agent_forwarding == -1)
		options->allow_agent_forwarding = 1;
	if (options->gateway_ports == -1)
		options->gateway_ports = 0;
	if (options->max_startups == -1)
		options->max_startups = 10;
	if (options->max_startups_rate == -1)
		options->max_startups_rate = 100;		/* 100% */
	if (options->max_startups_begin == -1)
		options->max_startups_begin = options->max_startups;
	if (options->max_authtries == -1)
		options->max_authtries = DEFAULT_AUTH_FAIL_MAX;
	if (options->max_sessions == -1)
		options->max_sessions = DEFAULT_SESSIONS_MAX;
	if (options->use_dns == -1)
		options->use_dns = 1;
	if (options->client_alive_interval == -1)
		options->client_alive_interval = 0;
	if (options->client_alive_count_max == -1)
		options->client_alive_count_max = 3;
	if (options->authorised_keys_file2 == NULL) {
		/* authorised_keys_file2 falls back to authorised_keys_file1 */
		if (options->authorised_keys_file1 != NULL)
			options->authorised_keys_file2 = options->authorised_keys_file1;
		else
			options->authorised_keys_file2 = (char *)_PATH_SSH_USER_PERMITTED_KEYS2;
	}
	if (options->authorised_keys_file1 == NULL)
		options->authorised_keys_file1 = (char *)_PATH_SSH_USER_PERMITTED_KEYS;
	if (options->permit_tun == -1)
		options->permit_tun = SSH_TUNMODE_NO;

	/* Turn privilege separation on by default */
	if (use_privsep == -1)
		use_privsep = 1;

	if (options->mask_remote == -1)
		options->mask_remote = 0;
}

/* Keyword tokens. */
typedef enum {
	sBadOption,		/* == unknown option */
	sPort, sHostKeyFile, sServerKeyBits, sLoginGraceTime, sKeyRegenerationTime,
	sPermitRootLogin, sLogFacility, sLogLevel,
	sRhostsRSAAuthentication, sRSAAuthentication,
	sChallengeResponseAuthentication,
	sPasswordAuthentication, sKbdInteractiveAuthentication,
	sListenAddress, sAddressFamily,
	sPrintMotd, sPrintLastLog, sIgnoreRhosts,
	sX11Forwarding, sX11DisplayOffset, sX11UseLocalhost,
	sStrictModes, sEmptyPasswd, sTCPKeepAlive,
	sPermitUserEnvironment, sUseLogin, sAllowTcpForwarding, sCompression,
	sAllowUsers, sDenyUsers, sAllowGroups, sDenyGroups,
	sIgnoreUserKnownHosts, sCiphers, sMacs, sProtocol, sPidFile,
	sGatewayPorts, sPubkeyAuthentication, sXAuthLocation, sSubsystem,
	sMaxStartups, sMaxAuthTries, sMaxSessions,
	sBanner, sUseDNS, sHostbasedAuthentication,
	sHostbasedUsesNameFromPacketOnly, sClientAliveInterval,
	sClientAliveCountMax, sAuthorisedKeysFile, sAuthorisedKeysFile2,
	sAcceptEnv, sPermitTunnel,
	sMatch, sPermitOpen, sForceCommand, sChrootDirectory,
	sUsePrivilegeSeparation, sAllowAgentForwarding,
	sMaskRemote,
	sDeprecated, sUnsupported
} ServerOpCodes;

#define SSHCFG_GLOBAL	0x01	/* allowed in main section of sshd_config */
#define SSHCFG_MATCH	0x02	/* allowed inside a Match section */
#define SSHCFG_ALL	(SSHCFG_GLOBAL|SSHCFG_MATCH)

/* Textual representation of the tokens. */
static struct {
	const char *name;
	ServerOpCodes opcode;
	u_int flags;
} keywords[] = {
	{ "port", sPort, SSHCFG_GLOBAL },
	{ "hostkey", sHostKeyFile, SSHCFG_GLOBAL },
	{ "hostdsakey", sHostKeyFile, SSHCFG_GLOBAL },		/* alias */
	{ "pidfile", sPidFile, SSHCFG_GLOBAL },
	{ "serverkeybits", sServerKeyBits, SSHCFG_GLOBAL },
	{ "logingracetime", sLoginGraceTime, SSHCFG_GLOBAL },
	{ "keyregenerationinterval", sKeyRegenerationTime, SSHCFG_GLOBAL },
	{ "permitrootlogin", sPermitRootLogin, SSHCFG_ALL },
	{ "syslogfacility", sLogFacility, SSHCFG_GLOBAL },
	{ "loglevel", sLogLevel, SSHCFG_GLOBAL },
	{ "rhostsauthentication", sDeprecated, SSHCFG_GLOBAL },
	{ "rhostsrsaauthentication", sRhostsRSAAuthentication, SSHCFG_ALL },
	{ "hostbasedauthentication", sHostbasedAuthentication, SSHCFG_ALL },
	{ "hostbasedusesnamefrompacketonly", sHostbasedUsesNameFromPacketOnly, SSHCFG_GLOBAL },
	{ "rsaauthentication", sRSAAuthentication, SSHCFG_ALL },
	{ "pubkeyauthentication", sPubkeyAuthentication, SSHCFG_ALL },
	{ "dsaauthentication", sPubkeyAuthentication, SSHCFG_GLOBAL }, /* alias */
	{ "kerberosauthentication", sUnsupported, SSHCFG_ALL },
	{ "kerberosorlocalpasswd", sUnsupported, SSHCFG_GLOBAL },
	{ "kerberosticketcleanup", sUnsupported, SSHCFG_GLOBAL },
	{ "kerberosgetafstoken", sUnsupported, SSHCFG_GLOBAL },
	{ "kerberostgtpassing", sUnsupported, SSHCFG_GLOBAL },
	{ "afstokenpassing", sUnsupported, SSHCFG_GLOBAL },
	{ "gssapiauthentication", sUnsupported, SSHCFG_ALL },
	{ "gssapicleanupcredentials", sUnsupported, SSHCFG_GLOBAL },
	{ "passwordauthentication", sPasswordAuthentication, SSHCFG_ALL },
	{ "kbdinteractiveauthentication", sKbdInteractiveAuthentication, SSHCFG_ALL },
	{ "challengeresponseauthentication", sChallengeResponseAuthentication, SSHCFG_GLOBAL },
	{ "skeyauthentication", sChallengeResponseAuthentication, SSHCFG_GLOBAL }, /* alias */
	{ "checkmail", sDeprecated, SSHCFG_GLOBAL },
	{ "listenaddress", sListenAddress, SSHCFG_GLOBAL },
	{ "addressfamily", sAddressFamily, SSHCFG_GLOBAL },
	{ "printmotd", sPrintMotd, SSHCFG_GLOBAL },
	{ "printlastlog", sPrintLastLog, SSHCFG_GLOBAL },
	{ "ignorerhosts", sIgnoreRhosts, SSHCFG_GLOBAL },
	{ "ignoreuserknownhosts", sIgnoreUserKnownHosts, SSHCFG_GLOBAL },
	{ "x11forwarding", sX11Forwarding, SSHCFG_ALL },
	{ "x11displayoffset", sX11DisplayOffset, SSHCFG_ALL },
	{ "x11uselocalhost", sX11UseLocalhost, SSHCFG_ALL },
	{ "xauthlocation", sXAuthLocation, SSHCFG_GLOBAL },
	{ "strictmodes", sStrictModes, SSHCFG_GLOBAL },
	{ "permitemptypasswords", sEmptyPasswd, SSHCFG_ALL },
	{ "permituserenvironment", sPermitUserEnvironment, SSHCFG_GLOBAL },
	{ "uselogin", sUseLogin, SSHCFG_GLOBAL },
	{ "compression", sCompression, SSHCFG_GLOBAL },
	{ "tcpkeepalive", sTCPKeepAlive, SSHCFG_GLOBAL },
	{ "keepalive", sTCPKeepAlive, SSHCFG_GLOBAL },	/* obsolete alias */
	{ "allowtcpforwarding", sAllowTcpForwarding, SSHCFG_ALL },
	{ "allowagentforwarding", sAllowAgentForwarding, SSHCFG_ALL },
	{ "allowusers", sAllowUsers, SSHCFG_GLOBAL },
	{ "denyusers", sDenyUsers, SSHCFG_GLOBAL },
	{ "allowgroups", sAllowGroups, SSHCFG_GLOBAL },
	{ "denygroups", sDenyGroups, SSHCFG_GLOBAL },
	{ "ciphers", sCiphers, SSHCFG_GLOBAL },
	{ "macs", sMacs, SSHCFG_GLOBAL },
	{ "protocol", sProtocol, SSHCFG_GLOBAL },
	{ "gatewayports", sGatewayPorts, SSHCFG_ALL },
	{ "subsystem", sSubsystem, SSHCFG_GLOBAL },
	{ "maxstartups", sMaxStartups, SSHCFG_GLOBAL },
	{ "maxauthtries", sMaxAuthTries, SSHCFG_ALL },
	{ "maxsessions", sMaxSessions, SSHCFG_ALL },
	{ "banner", sBanner, SSHCFG_ALL },
	{ "usedns", sUseDNS, SSHCFG_GLOBAL },
	{ "verifyreversemapping", sDeprecated, SSHCFG_GLOBAL },
	{ "reversemappingcheck", sDeprecated, SSHCFG_GLOBAL },
	{ "clientaliveinterval", sClientAliveInterval, SSHCFG_GLOBAL },
	{ "clientalivecountmax", sClientAliveCountMax, SSHCFG_GLOBAL },
	{ "authorizedkeysfile", sDeprecated, SSHCFG_GLOBAL },
	{ "authorizedkeysfile2", sDeprecated, SSHCFG_GLOBAL },
	{ "authorisedkeysfile", sAuthorisedKeysFile, SSHCFG_GLOBAL },
	{ "authorisedkeysfile2", sAuthorisedKeysFile2, SSHCFG_GLOBAL },
	{ "useprivilegeseparation", sUsePrivilegeSeparation, SSHCFG_GLOBAL},
	{ "acceptenv", sAcceptEnv, SSHCFG_GLOBAL },
	{ "permittunnel", sPermitTunnel, SSHCFG_GLOBAL },
	{ "match", sMatch, SSHCFG_ALL },
	{ "permitopen", sPermitOpen, SSHCFG_ALL },
	{ "forcecommand", sForceCommand, SSHCFG_ALL },
	{ "chrootdirectory", sChrootDirectory, SSHCFG_ALL },
	{ "maskremoteaddress", sMaskRemote, SSHCFG_ALL },
	{ NULL, sBadOption, 0 }
};

static struct {
	int val;
	const char *text;
} tunmode_desc[] = {
	{ SSH_TUNMODE_NO, "no" },
	{ SSH_TUNMODE_POINTOPOINT, "point-to-point" },
	{ SSH_TUNMODE_ETHERNET, "ethernet" },
	{ SSH_TUNMODE_YES, "yes" },
	{ -1, NULL }
};

/*
 * Returns the number of the token pointed to by cp or sBadOption.
 */

static ServerOpCodes
parse_token(const char *cp, const char *filename,
	    int linenum, u_int *flags)
{
	u_int i;

	for (i = 0; keywords[i].name; i++)
		if (strcasecmp(cp, keywords[i].name) == 0) {
			*flags = keywords[i].flags;
			return keywords[i].opcode;
		}

	error("%s: line %d: Bad configuration option: %s",
	    filename, linenum, cp);
	return sBadOption;
}

static void
add_listen_addr(ServerOptions *options, char *addr, int port)
{
	u_int i;

	if (options->num_ports == 0)
		options->ports[options->num_ports++] = SSH_DEFAULT_PORT;
	if (options->address_family == -1)
		options->address_family = AF_UNSPEC;
	if (port == 0)
		for (i = 0; i < options->num_ports; i++)
			add_one_listen_addr(options, addr, options->ports[i]);
	else
		add_one_listen_addr(options, addr, port);
}

static void
add_one_listen_addr(ServerOptions *options, char *addr, int port)
{
	struct addrinfo hints, *ai, *aitop;
	char strport[NI_MAXSERV];
	int gaierr;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = options->address_family;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_flags = (addr == NULL) ? AI_PASSIVE : 0;
	snprintf(strport, sizeof strport, "%d", port);
	if ((gaierr = getaddrinfo(addr, strport, &hints, &aitop)) != 0)
		fatal("bad addr or host: %s (%s)",
		    addr ? addr : "<NULL>",
		    ssh_gai_strerror(gaierr));
	for (ai = aitop; ai->ai_next; ai = ai->ai_next)
		;
	ai->ai_next = options->listen_addrs;
	options->listen_addrs = aitop;
}

/*
 * The strategy for the Match blocks is that the config file is parsed twice.
 *
 * The first time is at startup.  activep is initialized to 1 and the
 * directives in the global context are processed and acted on.  Hitting a
 * Match directive unsets activep and the directives inside the block are
 * checked for syntax only.
 *
 * The second time is after a connection has been established but before
 * authentication.  activep is initialized to 2 and global config directives
 * are ignored since they have already been processed.  If the criteria in a
 * Match block is met, activep is set and the subsequent directives
 * processed and actioned until EOF or another Match block unsets it.  Any
 * options set are copied into the main server config.
 *
 * Potential additions/improvements:
 *  - Add Match support for pre-kex directives, eg Protocol, Ciphers.
 *
 *  - Add a Tag directive (idea from David Leonard) ala pf, eg:
 *	Match Address 192.168.0.*
 *		Tag trusted
 *	Match Group wheel
 *		Tag trusted
 *	Match Tag trusted
 *		AllowTcpForwarding yes
 *		GatewayPorts clientspecified
 *		[...]
 *
 *  - Add a PermittedChannelRequests directive
 *	Match Group shell
 *		PermittedChannelRequests session,forwarded-tcpip
 */

static int
match_cfg_line_group(const char *grps, int line, const char *user)
{
	int result = 0;
	struct passwd *pw;

	if (user == NULL)
		goto out;

	if ((pw = getpwnam(user)) == NULL) {
		debug("Can't match group at line %d because user %.100s does "
		    "not exist", line, user);
	} else if (ga_init(pw->pw_name, pw->pw_gid) == 0) {
		debug("Can't Match group because user %.100s not in any group "
		    "at line %d", user, line);
	} else if (ga_match_pattern_list(grps) != 1) {
		debug("user %.100s does not match group list %.100s at line %d",
		    user, grps, line);
	} else {
		debug("user %.100s matched group list %.100s at line %d", user,
		    grps, line);
		result = 1;
	}
out:
	ga_free();
	return result;
}

static int
match_cfg_line(char **condition, int line, const char *user, const char *host,
    const char *address)
{
	int result = 1;
	char *arg, *attrib, *cp = *condition;
	size_t len;

	if (user == NULL)
		debug3("checking syntax for 'Match %s'", cp);
	else
		debug3("checking match for '%s' user %s host %s addr %s", cp,
		    user ? user : "(null)", host ? host : "(null)",
		    address ? address : "(null)");

	while ((attrib = strdelim(&cp)) && *attrib != '\0') {
		if ((arg = strdelim(&cp)) == NULL || *arg == '\0') {
			error("Missing Match criteria for %s", attrib);
			return -1;
		}
		len = strlen(arg);
		if (strcasecmp(attrib, "user") == 0) {
			if (!user) {
				result = 0;
				continue;
			}
			if (match_pattern_list(user, arg, len, 0) != 1)
				result = 0;
			else
				debug("user %.100s matched 'User %.100s' at "
				    "line %d", user, arg, line);
		} else if (strcasecmp(attrib, "group") == 0) {
			switch (match_cfg_line_group(arg, line, user)) {
			case -1:
				return -1;
			case 0:
				result = 0;
			}
		} else if (strcasecmp(attrib, "host") == 0) {
			if (!host) {
				result = 0;
				continue;
			}
			if (match_hostname(host, arg, len) != 1)
				result = 0;
			else
				debug("connection from %.100s matched 'Host "
				    "%.100s' at line %d", host, arg, line);
		} else if (strcasecmp(attrib, "address") == 0) {
			switch (addr_match_list(address, arg)) {
			case 1:
				debug("connection from %.100s matched 'Address "
				    "%.100s' at line %d", address, arg, line);
				break;
			case 0:
			case -1:
				result = 0;
				break;
			case -2:
				return -1;
			}
		} else {
			error("Unsupported Match attribute %s", attrib);
			return -1;
		}
	}
	if (user != NULL)
		debug3("match %sfound", result ? "" : "not ");
	*condition = cp;
	return result;
}

#define WHITESPACE " \t\r\n"

int
process_server_config_line(ServerOptions *options, char *line,
    const char *filename, int linenum, int *activep, const char *user,
    const char *host, const char *address)
{
	char *cp, **charptr, *arg, *p;
	int cmdline = 0, *intptr, value, n;
	SyslogFacility *log_facility_ptr;
	LogLevel *log_level_ptr;
	ServerOpCodes opcode;
	int port;
	u_int i, flags = 0;
	size_t len;

	cp = line;
	if ((arg = strdelim(&cp)) == NULL)
		return 0;
	/* Ignore leading whitespace */
	if (*arg == '\0')
		arg = strdelim(&cp);
	if (!arg || !*arg || *arg == '#')
		return 0;
	intptr = NULL;
	charptr = NULL;
	opcode = parse_token(arg, filename, linenum, &flags);

	if (activep == NULL) { /* We are processing a command line directive */
		cmdline = 1;
		activep = &cmdline;
	}
	if (*activep && opcode != sMatch)
		debug3("%s:%d setting %s %s", filename, linenum, arg, cp);
	if (*activep == 0 && !(flags & SSHCFG_MATCH)) {
		if (user == NULL) {
			fatal("%s line %d: Directive '%s' is not allowed "
			    "within a Match block", filename, linenum, arg);
		} else { /* this is a directive we have already processed */
			while (arg)
				arg = strdelim(&cp);
			return 0;
		}
	}

	switch (opcode) {
	case sBadOption:
		return -1;
	case sPort:
		/* ignore ports from configfile if cmdline specifies ports */
		if (options->ports_from_cmdline)
			return 0;
		if (options->listen_addrs != NULL)
			fatal("%s line %d: ports must be specified before "
			    "ListenAddress.", filename, linenum);
		if (options->num_ports >= MAX_PORTS)
			fatal("%s line %d: too many ports.",
			    filename, linenum);
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing port number.",
			    filename, linenum);
		options->ports[options->num_ports++] = a2port(arg);
		if (options->ports[options->num_ports-1] <= 0)
			fatal("%s line %d: Badly formatted port number.",
			    filename, linenum);
		break;

	case sServerKeyBits:
		intptr = &options->server_key_bits;
 parse_int:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing integer value.",
			    filename, linenum);
		value = atoi(arg);
		if (*activep && *intptr == -1)
			*intptr = value;
		break;

	case sLoginGraceTime:
		intptr = &options->login_grace_time;
 parse_time:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing time value.",
			    filename, linenum);
		if ((value = convtime(arg)) == -1)
			fatal("%s line %d: invalid time value.",
			    filename, linenum);
		if (*intptr == -1)
			*intptr = value;
		break;

	case sKeyRegenerationTime:
		intptr = &options->key_regeneration_time;
		goto parse_time;

	case sListenAddress:
		arg = strdelim(&cp);
		if (arg == NULL || *arg == '\0')
			fatal("%s line %d: missing address",
			    filename, linenum);
		/* check for bare IPv6 address: no "[]" and 2 or more ":" */
		if (strchr(arg, '[') == NULL && (p = strchr(arg, ':')) != NULL
		    && strchr(p+1, ':') != NULL) {
			add_listen_addr(options, arg, 0);
			break;
		}
		p = hpdelim(&arg);
		if (p == NULL)
			fatal("%s line %d: bad address:port usage",
			    filename, linenum);
		p = cleanhostname(p);
		if (arg == NULL)
			port = 0;
		else if ((port = a2port(arg)) <= 0)
			fatal("%s line %d: bad port number", filename, linenum);

		add_listen_addr(options, p, port);

		break;

	case sAddressFamily:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing address family.",
			    filename, linenum);
		intptr = &options->address_family;
		if (options->listen_addrs != NULL)
			fatal("%s line %d: address family must be specified before "
			    "ListenAddress.", filename, linenum);
		if (strcasecmp(arg, "inet") == 0)
			value = AF_INET;
		else if (strcasecmp(arg, "inet6") == 0)
			value = AF_INET6;
		else if (strcasecmp(arg, "any") == 0)
			value = AF_UNSPEC;
		else
			fatal("%s line %d: unsupported address family \"%s\".",
			    filename, linenum, arg);
		if (*intptr == -1)
			*intptr = value;
		break;

	case sHostKeyFile:
		intptr = &options->num_host_key_files;
		if (*intptr >= MAX_HOSTKEYS)
			fatal("%s line %d: too many host keys specified (max %d).",
			    filename, linenum, MAX_HOSTKEYS);
		charptr = &options->host_key_files[*intptr];
 parse_filename:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing file name.",
			    filename, linenum);
		if (*activep && *charptr == NULL) {
			*charptr = tilde_expand_filename(arg, getuid());
			/* increase optional counter */
			if (intptr != NULL)
				*intptr = *intptr + 1;
		}
		break;

	case sPidFile:
		charptr = &options->pid_file;
		goto parse_filename;

	case sPermitRootLogin:
		intptr = &options->permit_root_login;
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing yes/"
			    "without-password/forced-commands-only/no "
			    "argument.", filename, linenum);
		value = 0;	/* silence compiler */
		if (strcmp(arg, "without-password") == 0)
			value = PERMIT_NO_PASSWD;
		else if (strcmp(arg, "forced-commands-only") == 0)
			value = PERMIT_FORCED_ONLY;
		else if (strcmp(arg, "yes") == 0)
			value = PERMIT_YES;
		else if (strcmp(arg, "no") == 0)
			value = PERMIT_NO;
		else
			fatal("%s line %d: Bad yes/"
			    "without-password/forced-commands-only/no "
			    "argument: %s", filename, linenum, arg);
		if (*activep && *intptr == -1)
			*intptr = value;
		break;

	case sIgnoreRhosts:
		intptr = &options->ignore_rhosts;
 parse_flag:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing yes/no argument.",
			    filename, linenum);
		value = 0;	/* silence compiler */
		if (strcmp(arg, "yes") == 0)
			value = 1;
		else if (strcmp(arg, "no") == 0)
			value = 0;
		else
			fatal("%s line %d: Bad yes/no argument: %s",
				filename, linenum, arg);
		if (*activep && *intptr == -1)
			*intptr = value;
		break;

	case sIgnoreUserKnownHosts:
		intptr = &options->ignore_user_known_hosts;
		goto parse_flag;

	case sRhostsRSAAuthentication:
		intptr = &options->rhosts_rsa_authentication;
		goto parse_flag;

	case sHostbasedAuthentication:
		intptr = &options->hostbased_authentication;
		goto parse_flag;

	case sHostbasedUsesNameFromPacketOnly:
		intptr = &options->hostbased_uses_name_from_packet_only;
		goto parse_flag;

	case sRSAAuthentication:
		intptr = &options->rsa_authentication;
		goto parse_flag;

	case sPubkeyAuthentication:
		intptr = &options->pubkey_authentication;
		goto parse_flag;

	case sPasswordAuthentication:
		intptr = &options->password_authentication;
		goto parse_flag;

	case sKbdInteractiveAuthentication:
		intptr = &options->kbd_interactive_authentication;
		goto parse_flag;

	case sChallengeResponseAuthentication:
		intptr = &options->challenge_response_authentication;
		goto parse_flag;

	case sPrintMotd:
		intptr = &options->print_motd;
		goto parse_flag;

	case sPrintLastLog:
		intptr = &options->print_lastlog;
		goto parse_flag;

	case sX11Forwarding:
		intptr = &options->x11_forwarding;
		goto parse_flag;

	case sX11DisplayOffset:
		intptr = &options->x11_display_offset;
		goto parse_int;

	case sX11UseLocalhost:
		intptr = &options->x11_use_localhost;
		goto parse_flag;

	case sXAuthLocation:
		charptr = &options->xauth_location;
		goto parse_filename;

	case sStrictModes:
		intptr = &options->strict_modes;
		goto parse_flag;

	case sTCPKeepAlive:
		intptr = &options->tcp_keep_alive;
		goto parse_flag;

	case sEmptyPasswd:
		intptr = &options->permit_empty_passwd;
		goto parse_flag;

	case sPermitUserEnvironment:
		intptr = &options->permit_user_env;
		goto parse_flag;

	case sUseLogin:
		intptr = &options->use_login;
		goto parse_flag;

	case sCompression:
		intptr = &options->compression;
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing yes/no/delayed "
			    "argument.", filename, linenum);
		value = 0;	/* silence compiler */
		if (strcmp(arg, "delayed") == 0)
			value = COMP_DELAYED;
		else if (strcmp(arg, "yes") == 0)
			value = COMP_ZLIB;
		else if (strcmp(arg, "no") == 0)
			value = COMP_NONE;
		else
			fatal("%s line %d: Bad yes/no/delayed "
			    "argument: %s", filename, linenum, arg);
		if (*intptr == -1)
			*intptr = value;
		break;

	case sGatewayPorts:
		intptr = &options->gateway_ports;
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing yes/no/clientspecified "
			    "argument.", filename, linenum);
		value = 0;	/* silence compiler */
		if (strcmp(arg, "clientspecified") == 0)
			value = 2;
		else if (strcmp(arg, "yes") == 0)
			value = 1;
		else if (strcmp(arg, "no") == 0)
			value = 0;
		else
			fatal("%s line %d: Bad yes/no/clientspecified "
			    "argument: %s", filename, linenum, arg);
		if (*activep && *intptr == -1)
			*intptr = value;
		break;

	case sUseDNS:
		intptr = &options->use_dns;
		goto parse_flag;

	case sLogFacility:
		log_facility_ptr = &options->log_facility;
		arg = strdelim(&cp);
		value = log_facility_number(arg);
		if (value == SYSLOG_FACILITY_NOT_SET)
			fatal("%.200s line %d: unsupported log facility '%s'",
			    filename, linenum, arg ? arg : "<NONE>");
		if (*log_facility_ptr == -1)
			*log_facility_ptr = (SyslogFacility) value;
		break;

	case sLogLevel:
		log_level_ptr = &options->log_level;
		arg = strdelim(&cp);
		value = log_level_number(arg);
		if (value == SYSLOG_LEVEL_NOT_SET)
			fatal("%.200s line %d: unsupported log level '%s'",
			    filename, linenum, arg ? arg : "<NONE>");
		if (*log_level_ptr == -1)
			*log_level_ptr = (LogLevel) value;
		break;

	case sAllowTcpForwarding:
		intptr = &options->allow_tcp_forwarding;
		goto parse_flag;

	case sAllowAgentForwarding:
		intptr = &options->allow_agent_forwarding;
		goto parse_flag;

	case sUsePrivilegeSeparation:
		intptr = &use_privsep;
		goto parse_flag;

	case sAllowUsers:
		while ((arg = strdelim(&cp)) && *arg != '\0') {
			if (options->num_allow_users >= MAX_ALLOW_USERS)
				fatal("%s line %d: too many allow users.",
				    filename, linenum);
			options->allow_users[options->num_allow_users++] =
			    xstrdup(arg);
		}
		break;

	case sDenyUsers:
		while ((arg = strdelim(&cp)) && *arg != '\0') {
			if (options->num_deny_users >= MAX_DENY_USERS)
				fatal("%s line %d: too many deny users.",
				    filename, linenum);
			options->deny_users[options->num_deny_users++] =
			    xstrdup(arg);
		}
		break;

	case sAllowGroups:
		while ((arg = strdelim(&cp)) && *arg != '\0') {
			if (options->num_allow_groups >= MAX_ALLOW_GROUPS)
				fatal("%s line %d: too many allow groups.",
				    filename, linenum);
			options->allow_groups[options->num_allow_groups++] =
			    xstrdup(arg);
		}
		break;

	case sDenyGroups:
		while ((arg = strdelim(&cp)) && *arg != '\0') {
			if (options->num_deny_groups >= MAX_DENY_GROUPS)
				fatal("%s line %d: too many deny groups.",
				    filename, linenum);
			options->deny_groups[options->num_deny_groups++] = xstrdup(arg);
		}
		break;

	case sCiphers:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing argument.", filename, linenum);
		if (!ciphers_valid(arg))
			fatal("%s line %d: Bad SSH2 cipher spec '%s'.",
			    filename, linenum, arg ? arg : "<NONE>");
		if (options->ciphers == NULL)
			options->ciphers = xstrdup(arg);
		break;

	case sMacs:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing argument.", filename, linenum);
		if (!mac_valid(arg))
			fatal("%s line %d: Bad SSH2 mac spec '%s'.",
			    filename, linenum, arg ? arg : "<NONE>");
		if (options->macs == NULL)
			options->macs = xstrdup(arg);
		break;

	case sProtocol:
		intptr = &options->protocol;
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing argument.", filename, linenum);
		value = proto_spec(arg);
		if (value == SSH_PROTO_UNKNOWN)
			fatal("%s line %d: Bad protocol spec '%s'.",
			    filename, linenum, arg ? arg : "<NONE>");
		if (*intptr == SSH_PROTO_UNKNOWN)
			*intptr = value;
		break;

	case sSubsystem:
		if (options->num_subsystems >= MAX_SUBSYSTEMS) {
			fatal("%s line %d: too many subsystems defined.",
			    filename, linenum);
		}
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing subsystem name.",
			    filename, linenum);
		if (!*activep) {
			arg = strdelim(&cp);
			break;
		}
		for (i = 0; i < options->num_subsystems; i++)
			if (strcmp(arg, options->subsystem_name[i]) == 0)
				fatal("%s line %d: Subsystem '%s' already defined.",
				    filename, linenum, arg);
		options->subsystem_name[options->num_subsystems] = xstrdup(arg);
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing subsystem command.",
			    filename, linenum);
		options->subsystem_command[options->num_subsystems] = xstrdup(arg);

		/* Collect arguments (separate to executable) */
		p = xstrdup(arg);
		len = strlen(p) + 1;
		while ((arg = strdelim(&cp)) != NULL && *arg != '\0') {
			len += 1 + strlen(arg);
			p = xrealloc(p, 1, len);
			strlcat(p, " ", len);
			strlcat(p, arg, len);
		}
		options->subsystem_args[options->num_subsystems] = p;
		options->num_subsystems++;
		break;

	case sMaxStartups:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing MaxStartups spec.",
			    filename, linenum);
		if ((n = sscanf(arg, "%d:%d:%d",
		    &options->max_startups_begin,
		    &options->max_startups_rate,
		    &options->max_startups)) == 3) {
			if (options->max_startups_begin >
			    options->max_startups ||
			    options->max_startups_rate > 100 ||
			    options->max_startups_rate < 1)
				fatal("%s line %d: Illegal MaxStartups spec.",
				    filename, linenum);
		} else if (n != 1)
			fatal("%s line %d: Illegal MaxStartups spec.",
			    filename, linenum);
		else
			options->max_startups = options->max_startups_begin;
		break;

	case sMaxAuthTries:
		intptr = &options->max_authtries;
		goto parse_int;

	case sMaxSessions:
		intptr = &options->max_sessions;
		goto parse_int;

	case sBanner:
		charptr = &options->banner;
		goto parse_filename;

	/*
	 * These options can contain %X options expanded at
	 * connect time, so that you can specify paths like:
	 *
	 * AuthorisedKeysFile	/etc/ssh_keys/%u
	 */
	case sAuthorisedKeysFile:
	case sAuthorisedKeysFile2:
		charptr = (opcode == sAuthorisedKeysFile) ?
		    &options->authorised_keys_file1 :
		    &options->authorised_keys_file2;
		goto parse_filename;

	case sClientAliveInterval:
		intptr = &options->client_alive_interval;
		goto parse_time;

	case sClientAliveCountMax:
		intptr = &options->client_alive_count_max;
		goto parse_int;

	case sAcceptEnv:
		while ((arg = strdelim(&cp)) && *arg != '\0') {
			if (strchr(arg, '=') != NULL)
				fatal("%s line %d: Invalid environment name.",
				    filename, linenum);
			if (options->num_accept_env >= MAX_ACCEPT_ENV)
				fatal("%s line %d: too many allow env.",
				    filename, linenum);
			if (!*activep)
				break;
			options->accept_env[options->num_accept_env++] =
			    xstrdup(arg);
		}
		break;

	case sPermitTunnel:
		intptr = &options->permit_tun;
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing yes/point-to-point/"
			    "ethernet/no argument.", filename, linenum);
		value = -1;
		for (i = 0; tunmode_desc[i].val != -1; i++)
			if (strcmp(tunmode_desc[i].text, arg) == 0) {
				value = tunmode_desc[i].val;
				break;
			}
		if (value == -1)
			fatal("%s line %d: Bad yes/point-to-point/ethernet/"
			    "no argument: %s", filename, linenum, arg);
		if (*intptr == -1)
			*intptr = value;
		break;

	case sMatch:
		if (cmdline)
			fatal("Match directive not supported as a command-line "
			   "option");
		value = match_cfg_line(&cp, linenum, user, host, address);
		if (value < 0)
			fatal("%s line %d: Bad Match condition", filename,
			    linenum);
		*activep = value;
		break;

	case sPermitOpen:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing PermitOpen specification",
			    filename, linenum);
		n = options->num_permitted_opens;	/* modified later */
		if (strcmp(arg, "any") == 0) {
			if (*activep && n == -1) {
				channel_clear_adm_permitted_opens();
				options->num_permitted_opens = 0;
			}
			break;
		}
		if (*activep && n == -1)
			channel_clear_adm_permitted_opens();
		for (; arg != NULL && *arg != '\0'; arg = strdelim(&cp)) {
			p = hpdelim(&arg);
			if (p == NULL)
				fatal("%s line %d: missing host in PermitOpen",
				    filename, linenum);
			p = cleanhostname(p);
			if (arg == NULL || (port = a2port(arg)) <= 0)
				fatal("%s line %d: bad port number in "
				    "PermitOpen", filename, linenum);
			if (*activep && n == -1)
				options->num_permitted_opens =
				    channel_add_adm_permitted_opens(p, port);
		}
		break;

	case sForceCommand:
		if (cp == NULL)
			fatal("%.200s line %d: Missing argument.", filename,
			    linenum);
		len = strspn(cp, WHITESPACE);
		if (*activep && options->adm_forced_command == NULL)
			options->adm_forced_command = xstrdup(cp + len);
		return 0;

	case sChrootDirectory:
		charptr = &options->chroot_directory;

		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing file name.",
			    filename, linenum);
		if (*activep && *charptr == NULL)
			*charptr = xstrdup(arg);
		break;

	case sMaskRemote:
		intptr = &options->mask_remote;
		goto parse_flag;

	case sDeprecated:
		logit("%s line %d: Deprecated option %s",
		    filename, linenum, arg);
		while (arg)
		    arg = strdelim(&cp);
		break;

	case sUnsupported:
		logit("%s line %d: Unsupported option %s",
		    filename, linenum, arg);
		while (arg)
		    arg = strdelim(&cp);
		break;

	default:
		fatal("%s line %d: Missing handler for opcode %s (%d)",
		    filename, linenum, arg, opcode);
	}
	if ((arg = strdelim(&cp)) != NULL && *arg != '\0')
		fatal("%s line %d: garbage at end of line; \"%.200s\".",
		    filename, linenum, arg);
	return 0;
}

/* Reads the server configuration file. */

void
load_server_config(const char *filename, Buffer *conf)
{
	char line[1024], *cp;
	FILE *f;

	debug2("%s: filename %s", __func__, filename);
	if ((f = fopen(filename, "r")) == NULL) {
		perror(filename);
		exit(1);
	}
	buffer_clear(conf);
	while (fgets(line, sizeof(line), f)) {
		/*
		 * Trim out comments and strip whitespace
		 * NB - preserve newlines, they are needed to reproduce
		 * line numbers later for error messages
		 */
		if ((cp = strchr(line, '#')) != NULL)
			memcpy(cp, "\n", 2);
		cp = line + strspn(line, " \t\r");

		buffer_append(conf, cp, strlen(cp));
	}
	buffer_append(conf, "\0", 1);
	fclose(f);
	debug2("%s: done config len = %d", __func__, buffer_len(conf));
}

void
parse_server_match_config(ServerOptions *options, const char *user,
    const char *host, const char *address)
{
	ServerOptions mo;

	initialize_server_options(&mo);
	parse_server_config(&mo, "reprocess config", &cfg, user, host, address);
	copy_set_server_options(options, &mo, 0);
}

/* Helper macros */
#define M_CP_INTOPT(n) do {\
	if (src->n != -1) \
		dst->n = src->n; \
} while (0)
#define M_CP_STROPT(n) do {\
	if (src->n != NULL) { \
		if (dst->n != NULL) \
			xfree(dst->n); \
		dst->n = src->n; \
	} \
} while(0)

/*
 * Copy any supported values that are set.
 *
 * If the preauth flag is set, we do not bother copying the string or
 * array values that are not used pre-authentication, because any that we
 * do use must be explictly sent in mm_getpwnamallow().
 */
void
copy_set_server_options(ServerOptions *dst, ServerOptions *src, int preauth)
{
	M_CP_INTOPT(password_authentication);
	M_CP_INTOPT(rsa_authentication);
	M_CP_INTOPT(pubkey_authentication);
	M_CP_INTOPT(hostbased_authentication);
	M_CP_INTOPT(kbd_interactive_authentication);
	M_CP_INTOPT(permit_root_login);
	M_CP_INTOPT(permit_empty_passwd);

	M_CP_INTOPT(allow_tcp_forwarding);
	M_CP_INTOPT(allow_agent_forwarding);
	M_CP_INTOPT(gateway_ports);
	M_CP_INTOPT(x11_display_offset);
	M_CP_INTOPT(x11_forwarding);
	M_CP_INTOPT(x11_use_localhost);
	M_CP_INTOPT(max_sessions);
	M_CP_INTOPT(max_authtries);

	M_CP_STROPT(banner);
	if (preauth)
		return;
	M_CP_STROPT(adm_forced_command);
	M_CP_STROPT(chroot_directory);
	M_CP_INTOPT(mask_remote);
}

#undef M_CP_INTOPT
#undef M_CP_STROPT

void
parse_server_config(ServerOptions *options, const char *filename, Buffer *conf,
    const char *user, const char *host, const char *address)
{
	int active, linenum, bad_options = 0;
	char *cp, *obuf, *cbuf;

	debug2("%s: config %s len %d", __func__, filename, buffer_len(conf));

	obuf = cbuf = xstrdup(buffer_ptr(conf));
	active = user ? 0 : 1;
	linenum = 1;
	while ((cp = strsep(&cbuf, "\n")) != NULL) {
		if (process_server_config_line(options, cp, filename,
		    linenum++, &active, user, host, address) != 0)
			bad_options++;
	}
	xfree(obuf);
	if (bad_options > 0)
		fatal("%s: terminating, %d bad configuration options",
		    filename, bad_options);
}

static const char *
fmt_intarg(ServerOpCodes code, int val)
{
	if (code == sAddressFamily) {
		switch (val) {
		case AF_INET:
			return "inet";
		case AF_INET6:
			return "inet6";
		case AF_UNSPEC:
			return "any";
		default:
			return "UNKNOWN";
		}
	}
	if (code == sPermitRootLogin) {
		switch (val) {
		case PERMIT_NO_PASSWD:
			return "without-password";
		case PERMIT_FORCED_ONLY:
			return "forced-commands-only";
		case PERMIT_YES:
			return "yes";
		}
	}
	if (code == sProtocol) {
		switch (val) {
		case SSH_PROTO_1:
			return "1";
		case SSH_PROTO_2:
			return "2";
		case (SSH_PROTO_1|SSH_PROTO_2):
			return "2,1";
		default:
			return "UNKNOWN";
		}
	}
	if (code == sGatewayPorts && val == 2)
		return "clientspecified";
	if (code == sCompression && val == COMP_DELAYED)
		return "delayed";
	switch (val) {
	case -1:
		return "unset";
	case 0:
		return "no";
	case 1:
		return "yes";
	}
	return "UNKNOWN";
}

static const char *
lookup_opcode_name(ServerOpCodes code)
{
	u_int i;

	for (i = 0; keywords[i].name != NULL; i++)
		if (keywords[i].opcode == code)
			return(keywords[i].name);
	return "UNKNOWN";
}

static void
dump_cfg_int(ServerOpCodes code, int val)
{
	printf("%s %d\n", lookup_opcode_name(code), val);
}

static void
dump_cfg_fmtint(ServerOpCodes code, int val)
{
	printf("%s %s\n", lookup_opcode_name(code), fmt_intarg(code, val));
}

static void
dump_cfg_string(ServerOpCodes code, const char *val)
{
	if (val == NULL)
		return;
	printf("%s %s\n", lookup_opcode_name(code), val);
}

static void
dump_cfg_strarray(ServerOpCodes code, u_int count, char **vals)
{
	u_int i;

	for (i = 0; i < count; i++)
		printf("%s %s\n", lookup_opcode_name(code),  vals[i]);
}

void
dump_config(ServerOptions *o)
{
	u_int i;
	int ret;
	struct addrinfo *ai;
	char addr[NI_MAXHOST], port[NI_MAXSERV];
	const char *s = NULL;

	/* these are usually at the top of the config */
	for (i = 0; i < o->num_ports; i++)
		printf("port %d\n", o->ports[i]);
	dump_cfg_fmtint(sProtocol, o->protocol);
	dump_cfg_fmtint(sAddressFamily, o->address_family);

	/* ListenAddress must be after Port */
	for (ai = o->listen_addrs; ai; ai = ai->ai_next) {
		if ((ret = getnameinfo(ai->ai_addr, ai->ai_addrlen, addr,
		    sizeof(addr), port, sizeof(port),
		    NI_NUMERICHOST|NI_NUMERICSERV)) != 0) {
			error("getnameinfo failed: %.100s",
			    (ret != EAI_SYSTEM) ? gai_strerror(ret) :
			    strerror(errno));
		} else {
			if (ai->ai_family == AF_INET6)
				printf("listenaddress [%s]:%s\n", addr, port);
			else
				printf("listenaddress %s:%s\n", addr, port);
		}
	}

	/* integer arguments */
	dump_cfg_int(sServerKeyBits, o->server_key_bits);
	dump_cfg_int(sLoginGraceTime, o->login_grace_time);
	dump_cfg_int(sKeyRegenerationTime, o->key_regeneration_time);
	dump_cfg_int(sX11DisplayOffset, o->x11_display_offset);
	dump_cfg_int(sMaxAuthTries, o->max_authtries);
	dump_cfg_int(sMaxSessions, o->max_sessions);
	dump_cfg_int(sClientAliveInterval, o->client_alive_interval);
	dump_cfg_int(sClientAliveCountMax, o->client_alive_count_max);

	/* formatted integer arguments */
	dump_cfg_fmtint(sPermitRootLogin, o->permit_root_login);
	dump_cfg_fmtint(sIgnoreRhosts, o->ignore_rhosts);
	dump_cfg_fmtint(sIgnoreUserKnownHosts, o->ignore_user_known_hosts);
	dump_cfg_fmtint(sRhostsRSAAuthentication, o->rhosts_rsa_authentication);
	dump_cfg_fmtint(sHostbasedAuthentication, o->hostbased_authentication);
	dump_cfg_fmtint(sHostbasedUsesNameFromPacketOnly,
	    o->hostbased_uses_name_from_packet_only);
	dump_cfg_fmtint(sRSAAuthentication, o->rsa_authentication);
	dump_cfg_fmtint(sPubkeyAuthentication, o->pubkey_authentication);
#ifdef KRB5
	dump_cfg_fmtint(sKerberosAuthentication, o->kerberos_authentication);
	dump_cfg_fmtint(sKerberosOrLocalPasswd, o->kerberos_or_local_passwd);
	dump_cfg_fmtint(sKerberosTicketCleanup, o->kerberos_ticket_cleanup);
	dump_cfg_fmtint(sKerberosGetAFSToken, o->kerberos_get_afs_token);
#endif
#ifdef GSSAPI
	dump_cfg_fmtint(sGssAuthentication, o->gss_authentication);
	dump_cfg_fmtint(sGssCleanupCreds, o->gss_cleanup_creds);
#endif
	dump_cfg_fmtint(sPasswordAuthentication, o->password_authentication);
	dump_cfg_fmtint(sKbdInteractiveAuthentication,
	    o->kbd_interactive_authentication);
	dump_cfg_fmtint(sChallengeResponseAuthentication,
	    o->challenge_response_authentication);
	dump_cfg_fmtint(sPrintMotd, o->print_motd);
	dump_cfg_fmtint(sPrintLastLog, o->print_lastlog);
	dump_cfg_fmtint(sX11Forwarding, o->x11_forwarding);
	dump_cfg_fmtint(sX11UseLocalhost, o->x11_use_localhost);
	dump_cfg_fmtint(sStrictModes, o->strict_modes);
	dump_cfg_fmtint(sTCPKeepAlive, o->tcp_keep_alive);
	dump_cfg_fmtint(sEmptyPasswd, o->permit_empty_passwd);
	dump_cfg_fmtint(sPermitUserEnvironment, o->permit_user_env);
	dump_cfg_fmtint(sUseLogin, o->use_login);
	dump_cfg_fmtint(sCompression, o->compression);
	dump_cfg_fmtint(sGatewayPorts, o->gateway_ports);
	dump_cfg_fmtint(sUseDNS, o->use_dns);
	dump_cfg_fmtint(sAllowTcpForwarding, o->allow_tcp_forwarding);
	dump_cfg_fmtint(sUsePrivilegeSeparation, use_privsep);
	dump_cfg_fmtint(sMaskRemote, o->mask_remote);

	/* string arguments */
	dump_cfg_string(sPidFile, o->pid_file);
	dump_cfg_string(sXAuthLocation, o->xauth_location);
	dump_cfg_string(sCiphers, o->ciphers);
	dump_cfg_string(sMacs, o->macs);
	dump_cfg_string(sBanner, o->banner);
	dump_cfg_string(sAuthorisedKeysFile, o->authorised_keys_file1);
	dump_cfg_string(sAuthorisedKeysFile2, o->authorised_keys_file2);
	dump_cfg_string(sForceCommand, o->adm_forced_command);

	/* string arguments requiring a lookup */
	dump_cfg_string(sLogLevel, log_level_name(o->log_level));
	dump_cfg_string(sLogFacility, log_facility_name(o->log_facility));

	/* string array arguments */
	dump_cfg_strarray(sHostKeyFile, o->num_host_key_files,
	     o->host_key_files);
	dump_cfg_strarray(sAllowUsers, o->num_allow_users, o->allow_users);
	dump_cfg_strarray(sDenyUsers, o->num_deny_users, o->deny_users);
	dump_cfg_strarray(sAllowGroups, o->num_allow_groups, o->allow_groups);
	dump_cfg_strarray(sDenyGroups, o->num_deny_groups, o->deny_groups);
	dump_cfg_strarray(sAcceptEnv, o->num_accept_env, o->accept_env);

	/* other arguments */
	for (i = 0; i < o->num_subsystems; i++)
		printf("subsystem %s %s\n", o->subsystem_name[i],
		    o->subsystem_args[i]);

	printf("maxstartups %d:%d:%d\n", o->max_startups_begin,
	    o->max_startups_rate, o->max_startups);

	for (i = 0; tunmode_desc[i].val != -1; i++)
		if (tunmode_desc[i].val == o->permit_tun) {
			s = tunmode_desc[i].text;
			break;
		}
	dump_cfg_string(sPermitTunnel, s);

	channel_print_adm_permitted_opens();
}

void
process_config_mask_remote(ServerOptions *options)
{
	if (options->mask_remote == 1) {
		if (!mask_remote_identity) {
			mask_remote_identity = 1;
			debug("Enabling masking of the remote identity");
		}
	} else if (mask_remote_identity) {
		debug("DISabling masking of the remote identity");
		mask_remote_identity = 0;
	}
}
@


1.25
log
@replicate commit “remove experimental, never-enabled JPAKE code; ok markus@@” (djm, 2014/01/29 06:18:35) from upstream
@
text
@d42 1
d120 1
d239 3
d267 1
d359 1
d1196 4
d1311 1
d1512 1
d1554 14
@


1.24
log
@Introduce /etc/ssh/root:config and /etc/ssh/root:known_hosts
and /etc/ssh/root:authorised_keys for the superuser if his
HOME directory is unset, empty or, not normalised, "/" (root).
十̲CVS: ----------------------------------------------------------------------
@
text
@d43 1
a43 1
__RCSID("$MirOS: src/usr.bin/ssh/servconf.c,v 1.23 2009/10/04 14:29:07 tg Exp $");
a118 1
	options->zero_knowledge_password_authentication = -1;
a232 2
	if (options->zero_knowledge_password_authentication == -1)
		options->zero_knowledge_password_authentication = 0;
a261 1
	sZeroKnowledgePasswordAuthentication,
a303 5
#ifdef JPAKE
	{ "zeroknowledgepasswordauthentication", sZeroKnowledgePasswordAuthentication, SSHCFG_ALL },
#else
	{ "zeroknowledgepasswordauthentication", sUnsupported, SSHCFG_ALL },
#endif
a797 4
	case sZeroKnowledgePasswordAuthentication:
		intptr = &options->zero_knowledge_password_authentication;
		goto parse_flag;

a1282 1
	M_CP_INTOPT(zero_knowledge_password_authentication);
a1480 4
#ifdef JPAKE
	dump_cfg_fmtint(sZeroKnowledgePasswordAuthentication,
	    o->zero_knowledge_password_authentication);
#endif
@


1.23
log
@• merge newer OpenSSH
• KNF in our diff – style(9)
• some const cleanliness (build with __CRAZY=Yes mostly)
@
text
@d43 1
a43 1
__RCSID("$MirOS: src/usr.bin/ssh/servconf.c,v 1.22 2009/03/22 15:01:19 tg Exp $");
d112 1
a112 1
	options->authorised_keys_file = NULL;
d224 3
a226 3
		/* authorised_keys_file2 falls back to authorised_keys_file */
		if (options->authorised_keys_file != NULL)
			options->authorised_keys_file2 = options->authorised_keys_file;
d230 2
a231 2
	if (options->authorised_keys_file == NULL)
		options->authorised_keys_file = (char *)_PATH_SSH_USER_PERMITTED_KEYS;
d1095 1
a1095 1
		    &options->authorised_keys_file :
d1525 1
a1525 1
	dump_cfg_string(sAuthorisedKeysFile, o->authorised_keys_file);
@


1.22
log
@merge and tweak ciphers and MACs
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.194 2009/01/22 10:02:34 djm Exp $ */
d43 1
a43 1
__RCSID("$MirOS: src/usr.bin/ssh/servconf.c,v 1.21 2008/12/16 22:13:29 tg Exp $");
d367 1
a367 1
	char *text;
d1284 1
a1284 1
 * If the preauth flag is set, we do not bother copying the the string or
d1440 2
a1441 1
	char addr[NI_MAXHOST], port[NI_MAXSERV], *s = NULL;
@


1.21
log
@really merge OpenSSH-current into MirBSD Secure SHell 10uA4
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.193 2008/12/09 03:20:42 stevesk Exp $ */
d43 1
a43 1
__RCSID("$MirOS: src/usr.bin/ssh/servconf.c,v 1.20 2008/12/16 20:55:26 tg Exp $");
d45 2
a46 2
static void add_listen_addr(ServerOptions *, char *, u_short);
static void add_one_listen_addr(ServerOptions *, char *, u_short);
d398 1
a398 1
add_listen_addr(ServerOptions *options, char *addr, u_short port)
d414 1
a414 1
add_one_listen_addr(ServerOptions *options, char *addr, u_short port)
d424 1
a424 1
	snprintf(strport, sizeof strport, "%u", port);
d580 1
a580 1
	u_short port;
d631 1
a631 1
		if (options->ports[options->num_ports-1] == 0)
d684 1
a684 1
		else if ((port = a2port(arg)) == 0)
d1173 1
a1173 1
			if (arg == NULL || (port = a2port(arg)) == 0)
@


1.20
log
@fastmerge, do not use yet!
@
text
@d43 1
a43 1
__RCSID("$MirOS: src/usr.bin/ssh/servconf.c,v 1.19 2008/03/02 21:14:21 tg Exp $");
d1524 2
a1525 2
	dump_cfg_string(sAuthorizedKeysFile, o->authorized_keys_file);
	dump_cfg_string(sAuthorizedKeysFile2, o->authorized_keys_file2);
@


1.19
log
@merge’n’fix
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.177 2008/02/10 10:54:28 djm Exp $ */
d15 1
d25 1
d43 1
a43 1
__RCSID("$MirOS: src/usr.bin/ssh/servconf.c,v 1.18 2007/04/29 20:23:13 tg Exp $");
d93 1
d107 1
d119 1
d146 1
a146 1
		options->server_key_bits = 768;
d203 2
d215 2
d234 2
d258 1
a258 1
	sMaxStartups, sMaxAuthTries,
d264 2
a265 1
	sUsePrivilegeSeparation,
d308 5
d332 1
d343 2
a344 1
	{ "maxauthtries", sMaxAuthTries, SSHCFG_GLOBAL },
d365 11
a471 2
	u_int ngrps = 0;
	char *arg, *p, *cp, *grplist[MAX_MATCH_GROUPS];
a473 14
	/*
	 * Even if we do not have a user yet, we still need to check for
	 * valid syntax.
	 */
	arg = cp = xstrdup(grps);
	while ((p = strsep(&cp, ",")) != NULL && *p != '\0') {
		if (ngrps >= MAX_MATCH_GROUPS) {
			error("line %d: too many groups in Match Group", line);
			result = -1;
			goto out;
		}
		grplist[ngrps++] = p;
	}

d483 3
a485 3
	} else if (ga_match(grplist, ngrps) != 1) {
		debug("user %.100s does not match group %.100s at line %d",
		    user, arg, line);
d487 2
a488 2
		debug("user %.100s matched group %.100s at line %d", user,
		    arg, line);
a492 1
	xfree(arg);
d545 7
a551 1
			if (!address) {
d553 3
a555 1
				continue;
a556 5
			if (match_hostname(address, arg, len) != 1)
				result = 0;
			else
				debug("connection from %.100s matched 'Address "
				    "%.100s' at line %d", address, arg, line);
d638 1
a638 1
parse_int:
d650 1
a650 1
parse_time:
d719 1
a719 1
parse_filename:
d762 1
a762 1
parse_flag:
d807 4
d933 4
d1078 4
d1128 7
a1134 10
		value = 0;	/* silence compiler */
		if (strcasecmp(arg, "ethernet") == 0)
			value = SSH_TUNMODE_ETHERNET;
		else if (strcasecmp(arg, "point-to-point") == 0)
			value = SSH_TUNMODE_POINTOPOINT;
		else if (strcasecmp(arg, "yes") == 0)
			value = SSH_TUNMODE_YES;
		else if (strcasecmp(arg, "no") == 0)
			value = SSH_TUNMODE_NO;
		else
d1296 2
a1298 1
	M_CP_INTOPT(permit_root_login);
d1301 1
d1306 2
d1341 217
@


1.18
log
@merge openssh
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.172 2007/04/23 10:15:39 dtucker Exp $ */
d41 1
a41 1
__RCSID("$MirOS: src/usr.bin/ssh/servconf.c,v 1.17 2007/03/18 04:27:34 tg Exp $");
d114 1
d252 1
a252 1
	sMatch, sPermitOpen, sForceCommand,
d274 1
a274 1
	{ "permitrootlogin", sPermitRootLogin, SSHCFG_GLOBAL },
d342 1
d398 1
a398 1
		    gai_strerror(gaierr));
d561 2
d740 1
a740 1
		if (*intptr == -1)
d888 1
a888 1
		intptr = (int *) &options->log_facility;
d894 2
a895 2
		if (*intptr == -1)
			*intptr = (SyslogFacility) value;
d899 1
a899 1
		intptr = (int *) &options->log_level;
d905 2
a906 2
		if (*intptr == -1)
			*intptr = (LogLevel) value;
d1057 1
d1166 11
d1272 1
d1284 1
@


1.17
log
@this makes our secure shell match what's in OpenBSD 4.1
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.171 2007/03/09 05:20:06 dtucker Exp $ */
d41 1
a41 1
__RCSID("$MirOS: src/usr.bin/ssh/servconf.c,v 1.16 2007/03/08 10:09:32 tg Exp $");
a529 1
			debug("address '%s' arg '%s'", address, arg);
@


1.16
log
@merge OpenSSH 4.6, retain local changes
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.170 2007/03/01 10:28:02 dtucker Exp $ */
d41 1
a41 1
__RCSID("$MirOS: src/usr.bin/ssh/servconf.c,v 1.15 2007/01/25 16:18:37 tg Exp $");
a1293 4

	/* challenge-response is implemented via keyboard interactive */
	if (options->challenge_response_authentication == 1)
		options->kbd_interactive_authentication = 1;
@


1.15
log
@automerge, bump vsn
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.167 2006/12/14 10:01:14 dtucker Exp $ */
d41 1
a41 1
__RCSID("$MirOS: src/usr.bin/ssh/servconf.c,v 1.14 2006/09/21 21:54:43 tg Exp $");
d277 2
a278 2
	{ "rhostsrsaauthentication", sRhostsRSAAuthentication, SSHCFG_GLOBAL },
	{ "hostbasedauthentication", sHostbasedAuthentication, SSHCFG_GLOBAL },
d280 2
a281 2
	{ "rsaauthentication", sRSAAuthentication, SSHCFG_GLOBAL },
	{ "pubkeyauthentication", sPubkeyAuthentication, SSHCFG_GLOBAL },
d283 1
a283 1
	{ "kerberosauthentication", sUnsupported, SSHCFG_GLOBAL },
d289 1
a289 1
	{ "gssapiauthentication", sUnsupported, SSHCFG_GLOBAL },
d292 1
a292 1
	{ "kbdinteractiveauthentication", sKbdInteractiveAuthentication, SSHCFG_GLOBAL },
d876 1
a876 1
		if (*intptr == -1)
d1228 13
d1251 14
a1264 9
	if (src->password_authentication != -1)
		dst->password_authentication = src->password_authentication;
	if (src->permit_empty_passwd != -1)
		dst->permit_empty_passwd = src->permit_empty_passwd;
	if (src->banner != NULL) {
		if (dst->banner != NULL)
			xfree(dst->banner);
		dst->banner = src->banner;
	}
d1267 1
a1267 15
	if (src->allow_tcp_forwarding != -1)
		dst->allow_tcp_forwarding = src->allow_tcp_forwarding;
	if (src->gateway_ports != -1)
		dst->gateway_ports = src->gateway_ports;
	if (src->adm_forced_command != NULL) {
		if (dst->adm_forced_command != NULL)
			xfree(dst->adm_forced_command);
		dst->adm_forced_command = src->adm_forced_command;
	}
	if (src->x11_display_offset != -1)
		dst->x11_display_offset = src->x11_display_offset;
	if (src->x11_forwarding != -1)
		dst->x11_forwarding = src->x11_forwarding;
	if (src->x11_use_localhost != -1)
		dst->x11_use_localhost = src->x11_use_localhost;
d1270 3
d1294 4
@


1.14
log
@* document the changes in the Match directive
* catch some of the changed cases for OpenSSH compatibility
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.165 2006/08/14 12:40:25 dtucker Exp $ */
d41 1
a41 1
__RCSID("$MirOS: src/usr.bin/ssh/servconf.c,v 1.13 2006/09/21 21:48:58 tg Exp $");
d1128 1
d1130 1
a1130 1
			if (*activep) {
d1136 2
d1147 1
a1147 2
			if (*activep && options->num_permitted_opens == -1) {
				channel_clear_adm_permitted_opens();
a1149 1
			}
@


1.13
log
@Apply openbsd-ssh-match-permitempty.patch also by Darren Tucker
Message-ID: <20060921033637.GA8862@@gate.dtucker.net>

He says this one was not tested yet
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/usr.bin/ssh/servconf.c,v 1.12 2006/09/21 21:47:31 tg Exp $");
d331 2
@


1.12
log
@Apply openbsd-ssh-match-preauth.patch From: Darren Tucker <dtucker@@zip.com.au>
Message-ID: <20060921033637.GA8862@@gate.dtucker.net>
@
text
@d41 1
a41 1
__RCSID("$MirOS: src/usr.bin/ssh/servconf.c,v 1.11 2006/09/20 21:41:02 tg Exp $");
d307 1
a307 1
	{ "permitemptypasswords", sEmptyPasswd, SSHCFG_GLOBAL },
d1237 2
@


1.11
log
@finish merging
@
text
@d41 1
a41 1
__RCSID("$MirOS$");
d291 1
a291 1
	{ "passwordauthentication", sPasswordAuthentication, SSHCFG_GLOBAL },
d325 1
a325 1
	{ "banner", sBanner, SSHCFG_GLOBAL },
d1222 1
a1222 1
	copy_set_server_options(options, &mo);
d1225 7
a1231 1
/* Copy any (supported) values that are set */
d1233 1
a1233 1
copy_set_server_options(ServerOptions *dst, ServerOptions *src)
d1235 9
@


1.10
log
@fix spelling and pubkey authentication
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.150 2006/03/25 13:17:02 djm Exp $ */
d13 2
a14 2
#include "includes.h"
__RCSID("$MirOS: src/usr.bin/ssh/servconf.c,v 1.9 2006/06/02 20:50:48 tg Exp $");
d16 10
d28 1
a29 1
#include "xmalloc.h"
d34 1
d37 5
d48 1
d112 2
a113 3

	/* Needs to be accessable in many places */
	use_privsep = -1;
d251 1
d256 4
d264 1
d266 74
a339 63
	{ "port", sPort },
	{ "hostkey", sHostKeyFile },
	{ "hostdsakey", sHostKeyFile },					/* alias */
	{ "pidfile", sPidFile },
	{ "serverkeybits", sServerKeyBits },
	{ "logingracetime", sLoginGraceTime },
	{ "keyregenerationinterval", sKeyRegenerationTime },
	{ "permitrootlogin", sPermitRootLogin },
	{ "syslogfacility", sLogFacility },
	{ "loglevel", sLogLevel },
	{ "rhostsauthentication", sDeprecated },
	{ "rhostsrsaauthentication", sRhostsRSAAuthentication },
	{ "hostbasedauthentication", sHostbasedAuthentication },
	{ "hostbasedusesnamefrompacketonly", sHostbasedUsesNameFromPacketOnly },
	{ "rsaauthentication", sRSAAuthentication },
	{ "pubkeyauthentication", sPubkeyAuthentication },
	{ "dsaauthentication", sPubkeyAuthentication },			/* alias */
	{ "passwordauthentication", sPasswordAuthentication },
	{ "kbdinteractiveauthentication", sKbdInteractiveAuthentication },
	{ "challengeresponseauthentication", sChallengeResponseAuthentication },
	{ "skeyauthentication", sChallengeResponseAuthentication }, /* alias */
	{ "checkmail", sDeprecated },
	{ "listenaddress", sListenAddress },
	{ "addressfamily", sAddressFamily },
	{ "printmotd", sPrintMotd },
	{ "printlastlog", sPrintLastLog },
	{ "ignorerhosts", sIgnoreRhosts },
	{ "ignoreuserknownhosts", sIgnoreUserKnownHosts },
	{ "x11forwarding", sX11Forwarding },
	{ "x11displayoffset", sX11DisplayOffset },
	{ "x11uselocalhost", sX11UseLocalhost },
	{ "xauthlocation", sXAuthLocation },
	{ "strictmodes", sStrictModes },
	{ "permitemptypasswords", sEmptyPasswd },
	{ "permituserenvironment", sPermitUserEnvironment },
	{ "uselogin", sUseLogin },
	{ "compression", sCompression },
	{ "tcpkeepalive", sTCPKeepAlive },
	{ "keepalive", sTCPKeepAlive },				/* obsolete alias */
	{ "allowtcpforwarding", sAllowTcpForwarding },
	{ "allowusers", sAllowUsers },
	{ "denyusers", sDenyUsers },
	{ "allowgroups", sAllowGroups },
	{ "denygroups", sDenyGroups },
	{ "ciphers", sCiphers },
	{ "macs", sMacs },
	{ "protocol", sProtocol },
	{ "gatewayports", sGatewayPorts },
	{ "subsystem", sSubsystem },
	{ "maxstartups", sMaxStartups },
	{ "maxauthtries", sMaxAuthTries },
	{ "banner", sBanner },
	{ "usedns", sUseDNS },
	{ "verifyreversemapping", sDeprecated },
	{ "reversemappingcheck", sDeprecated },
	{ "clientaliveinterval", sClientAliveInterval },
	{ "clientalivecountmax", sClientAliveCountMax },
	{ "authorisedkeysfile", sAuthorisedKeysFile },
	{ "authorisedkeysfile2", sAuthorisedKeysFile2 },
	{ "useprivilegeseparation", sUsePrivilegeSeparation},
	{ "acceptenv", sAcceptEnv },
	{ "permittunnel", sPermitTunnel },
	{ NULL, sBadOption }
d348 1
a348 1
	    int linenum)
d353 2
a354 1
		if (strcasecmp(cp, keywords[i].name) == 0)
d356 1
d401 150
d553 2
a554 1
    const char *filename, int linenum)
d557 1
a557 1
	int *intptr, value, n;
d560 2
a561 1
	u_int i;
d573 19
a591 1
	opcode = parse_token(arg, filename, linenum);
d623 1
a623 1
		if (*intptr == -1)
d703 1
a703 1
		if (*charptr == NULL) {
d754 1
a754 1
		if (*intptr == -1)
d925 1
a925 1
				fatal( "%s line %d: too many deny users.",
d995 4
d1009 11
d1060 1
a1060 1
		charptr = (opcode == sAuthorisedKeysFile ) ?
d1081 2
d1110 49
d1215 34
a1248 1
parse_server_config(ServerOptions *options, const char *filename, Buffer *conf)
d1250 1
a1250 1
	int linenum, bad_options = 0;
d1256 1
d1260 1
a1260 1
		    linenum++) != 0)
@


1.9
log
@* merge
* remove all references to GSSAPI, Kerberos and AFS
* uint*_t -> u_int*_t for consistency, like openbsd
  (note: MirOS style(9) suggests uint32_t etc. instead!)
* bump vsn
@
text
@d14 1
a14 1
__RCSID("$MirOS: src/usr.bin/ssh/servconf.c,v 1.8 2006/04/19 10:40:51 tg Exp $");
d91 2
a92 2
	options->authorized_keys_file = NULL;
	options->authorized_keys_file2 = NULL;
d197 4
a200 4
	if (options->authorized_keys_file2 == NULL) {
		/* authorized_keys_file2 falls back to authorized_keys_file */
		if (options->authorized_keys_file != NULL)
			options->authorized_keys_file2 = options->authorized_keys_file;
d202 1
a202 1
			options->authorized_keys_file2 = (char *)_PATH_SSH_USER_PERMITTED_KEYS2;
d204 2
a205 2
	if (options->authorized_keys_file == NULL)
		options->authorized_keys_file = (char *)_PATH_SSH_USER_PERMITTED_KEYS;
d233 1
a233 1
	sClientAliveCountMax, sAuthorizedKeysFile, sAuthorizedKeysFile2,
d301 2
a302 2
	{ "authorizedkeysfile", sAuthorizedKeysFile },
	{ "authorizedkeysfile2", sAuthorizedKeysFile2 },
d836 1
a836 1
	 * AuthorizedKeysFile	/etc/ssh_keys/%u
d838 5
a842 5
	case sAuthorizedKeysFile:
	case sAuthorizedKeysFile2:
		charptr = (opcode == sAuthorizedKeysFile ) ?
		    &options->authorized_keys_file :
		    &options->authorized_keys_file2;
@


1.8
log
@merge and clean up
@
text
@d14 1
a14 1
__RCSID("$MirOS: src/usr.bin/ssh/servconf.c,v 1.7 2006/02/22 02:16:48 tg Exp $");
a260 8
	{ "kerberosauthentication", sUnsupported },
	{ "kerberosorlocalpasswd", sUnsupported },
	{ "kerberosticketcleanup", sUnsupported },
	{ "kerberosgetafstoken", sUnsupported },
	{ "kerberostgtpassing", sUnsupported },
	{ "afstokenpassing", sUnsupported },
	{ "gssapiauthentication", sUnsupported },
	{ "gssapicleanupcredentials", sUnsupported },
@


1.7
log
@fix a lot of and kludge a few more __CRAZY problems, sync rcs id
@
text
@d1 1
d14 1
a14 1
RCSID("$MirOS: src/usr.bin/ssh/servconf.c,v 1.6 2005/12/20 19:57:34 tg Exp $");
d385 2
a386 1
	arg = strdelim(&cp);
@


1.6
log
@fastmerge, bump version
@
text
@d13 1
a13 1
RCSID("$MirOS: src/usr.bin/ssh/servconf.c,v 1.5 2005/11/23 19:45:14 tg Exp $");
d108 1
a108 1
			    _PATH_HOST_KEY_FILE;
d111 1
a111 1
			    _PATH_HOST_RSA_KEY_FILE;
d113 1
a113 1
			    _PATH_HOST_DSA_KEY_FILE;
d121 1
a121 1
		options->pid_file = _PATH_SSH_DAEMON_PID_FILE;
d145 1
a145 1
		options->xauth_location = _PATH_XAUTH;
d201 1
a201 1
			options->authorized_keys_file2 = _PATH_SSH_USER_PERMITTED_KEYS2;
d204 1
a204 1
		options->authorized_keys_file = _PATH_SSH_USER_PERMITTED_KEYS;
@


1.5
log
@merge
@
text
@d13 1
a13 1
RCSID("$MirOS: src/usr.bin/ssh/servconf.c,v 1.4 2005/06/22 16:11:39 tg Exp $");
d93 1
d205 2
d233 1
a233 1
	sAcceptEnv,
d312 1
d872 22
@


1.4
log
@merge
@
text
@d13 1
a13 1
RCSID("$MirOS: src/usr.bin/ssh/servconf.c,v 1.3 2005/04/14 19:49:34 tg Exp $");
d176 1
a176 1
		options->compression = 1;
d447 6
d637 17
a653 1
		goto parse_flag;
@


1.3
log
@merge
@
text
@d13 1
a13 1
RCSID("$MirOS: src/usr.bin/ssh/servconf.c,v 1.2 2005/03/13 18:33:30 tg Exp $");
d334 1
a334 1
	int i;
d374 1
a374 1
	int *intptr, value, i, n;
d377 1
d463 3
@


1.2
log
@merge src/usr.bin
@
text
@d13 1
a13 1
RCSID("$MirOS$");
d376 1
d443 2
a444 2
		if (!arg || *arg == '\0' || strncmp(arg, "[]", 2) == 0)
			fatal("%s line %d: missing inet addr.",
d446 11
a456 13
		if (*arg == '[') {
			if ((p = strchr(arg, ']')) == NULL)
				fatal("%s line %d: bad ipv6 inet addr usage.",
				    filename, linenum);
			arg++;
			memmove(p, p+1, strlen(p+1)+1);
		} else if (((p = strchr(arg, ':')) == NULL) ||
			    (strchr(p+1, ':') != NULL)) {
			add_listen_addr(options, arg, 0);
			break;
		}
		if (*p == ':') {
			u_short port;
a457 16
			p++;
			if (*p == '\0')
				fatal("%s line %d: bad inet addr:port usage.",
				    filename, linenum);
			else {
				*(p-1) = '\0';
				if ((port = a2port(p)) == 0)
					fatal("%s line %d: bad port number.",
					    filename, linenum);
				add_listen_addr(options, arg, port);
			}
		} else if (*p == '\0')
			add_listen_addr(options, arg, 0);
		else
			fatal("%s line %d: bad inet addr usage.",
			    filename, linenum);
d631 17
a647 1
		goto parse_flag;
d907 1
a907 1
	while((cp = strsep(&cbuf, "\n")) != NULL) {
@


1.1
log
@Initial revision
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.138 2004/12/23 23:11:00 djm Exp $");
a64 6
	options->kerberos_authentication = -1;
	options->kerberos_or_local_passwd = -1;
	options->kerberos_ticket_cleanup = -1;
	options->kerberos_get_afs_token = -1;
	options->gss_authentication=-1;
	options->gss_cleanup_creds = -1;
d128 1
a128 1
		options->permit_root_login = PERMIT_YES;
a162 12
	if (options->kerberos_authentication == -1)
		options->kerberos_authentication = 0;
	if (options->kerberos_or_local_passwd == -1)
		options->kerberos_or_local_passwd = 1;
	if (options->kerberos_ticket_cleanup == -1)
		options->kerberos_ticket_cleanup = 1;
	if (options->kerberos_get_afs_token == -1)
		options->kerberos_get_afs_token = 0;
	if (options->gss_authentication == -1)
		options->gss_authentication = 0;
	if (options->gss_cleanup_creds == -1)
		options->gss_cleanup_creds = 1;
d216 1
a216 3
	sKerberosAuthentication, sKerberosOrLocalPasswd, sKerberosTicketCleanup,
	sKerberosGetAFSToken,
	sKerberosTgtPassing, sChallengeResponseAuthentication,
d230 1
a230 1
	sGssAuthentication, sGssCleanupCreds, sAcceptEnv,
a256 6
#ifdef KRB5
	{ "kerberosauthentication", sKerberosAuthentication },
	{ "kerberosorlocalpasswd", sKerberosOrLocalPasswd },
	{ "kerberosticketcleanup", sKerberosTicketCleanup },
	{ "kerberosgetafstoken", sKerberosGetAFSToken },
#else
a260 1
#endif
a262 4
#ifdef GSSAPI
	{ "gssapiauthentication", sGssAuthentication },
	{ "gssapicleanupcredentials", sGssCleanupCreds },
#else
a264 1
#endif
a585 24
	case sKerberosAuthentication:
		intptr = &options->kerberos_authentication;
		goto parse_flag;

	case sKerberosOrLocalPasswd:
		intptr = &options->kerberos_or_local_passwd;
		goto parse_flag;

	case sKerberosTicketCleanup:
		intptr = &options->kerberos_ticket_cleanup;
		goto parse_flag;

	case sKerberosGetAFSToken:
		intptr = &options->kerberos_get_afs_token;
		goto parse_flag;

	case sGssAuthentication:
		intptr = &options->gss_authentication;
		goto parse_flag;

	case sGssCleanupCreds:
		intptr = &options->gss_cleanup_creds;
		goto parse_flag;

@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@OpenSSH-current
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.140 2005/03/10 22:01:05 deraadt Exp $");
a407 1
	u_short port;
d474 2
a475 2
		if (arg == NULL || *arg == '\0')
			fatal("%s line %d: missing address",
d477 13
a489 11
		p = hpdelim(&arg);
		if (p == NULL)
			fatal("%s line %d: bad address:port usage",
			    filename, linenum);
		p = cleanhostname(p);
		if (arg == NULL)
			port = 0;
		else if ((port = a2port(arg)) == 0)
			fatal("%s line %d: bad port number", filename, linenum);

		add_listen_addr(options, p, port);
d491 16
d704 1
a704 17
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing yes/no/clientspecified "
			    "argument.", filename, linenum);
		value = 0;	/* silence compiler */
		if (strcmp(arg, "clientspecified") == 0)
			value = 2;
		else if (strcmp(arg, "yes") == 0)
			value = 1;
		else if (strcmp(arg, "no") == 0)
			value = 0;
		else
			fatal("%s line %d: Bad yes/no/clientspecified "
			    "argument: %s", filename, linenum, arg);
		if (*intptr == -1)
			*intptr = value;
		break;
d964 1
a964 1
	while ((cp = strsep(&cbuf, "\n")) != NULL) {
@


1.1.1.3
log
@most current OpenSSH.com
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.142 2005/06/17 02:44:33 djm Exp $");
d366 1
a366 1
	u_int i;
d406 1
a406 1
	int *intptr, value, n;
a408 1
	u_int i;
a493 3
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing address family.",
			    filename, linenum);
@


1.1.1.4
log
@Import current OpenSSH
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.144 2005/08/06 10:03:12 dtucker Exp $");
d194 1
a194 1
		options->compression = COMP_DELAYED;
a478 6
		/* check for bare IPv6 address: no "[]" and 2 or more ":" */
		if (strchr(arg, '[') == NULL && (p = strchr(arg, ':')) != NULL
		    && strchr(p+1, ':') != NULL) {
			add_listen_addr(options, arg, 0);
			break;
		}
d687 1
a687 17
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing yes/no/delayed "
			    "argument.", filename, linenum);
		value = 0;	/* silence compiler */
		if (strcmp(arg, "delayed") == 0)
			value = COMP_DELAYED;
		else if (strcmp(arg, "yes") == 0)
			value = COMP_ZLIB;
		else if (strcmp(arg, "no") == 0)
			value = COMP_NONE;
		else
			fatal("%s line %d: Bad yes/no/delayed "
			    "argument: %s", filename, linenum, arg);
		if (*intptr == -1)
			*intptr = value;
		break;
@


1.1.1.5
log
@OpenSSH is the last missing piece to update before the release
@
text
@d13 1
a13 1
RCSID("$OpenBSD: servconf.c,v 1.146 2005/12/08 18:34:11 reyk Exp $");
a98 1
	options->permit_tun = -1;
a221 2
	if (options->permit_tun == -1)
		options->permit_tun = SSH_TUNMODE_NO;
d250 1
a250 1
	sGssAuthentication, sGssCleanupCreds, sAcceptEnv, sPermitTunnel,
a340 1
	{ "permittunnel", sPermitTunnel },
a923 22
	case sPermitTunnel:
		intptr = &options->permit_tun;
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: Missing yes/point-to-point/"
			    "ethernet/no argument.", filename, linenum);
		value = 0;	/* silence compiler */
		if (strcasecmp(arg, "ethernet") == 0)
			value = SSH_TUNMODE_ETHERNET;
		else if (strcasecmp(arg, "point-to-point") == 0)
			value = SSH_TUNMODE_POINTOPOINT;
		else if (strcasecmp(arg, "yes") == 0)
			value = SSH_TUNMODE_YES;
		else if (strcasecmp(arg, "no") == 0)
			value = SSH_TUNMODE_NO;
		else
			fatal("%s line %d: Bad yes/point-to-point/ethernet/"
			    "no argument: %s", filename, linenum, arg);
		if (*intptr == -1)
			*intptr = value;
		break;

@


1.1.1.6
log
@I decided we'd better upgrade OpenSSH before releasing to the general public
@
text
@a0 1
/* $OpenBSD: servconf.c,v 1.150 2006/03/25 13:17:02 djm Exp $ */
d13 1
d416 1
a416 2
	if ((arg = strdelim(&cp)) == NULL)
		return 0;
@


1.1.1.7
log
@import a few security-wise relevant changes right now
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.165 2006/08/14 12:40:25 dtucker Exp $ */
d13 1
a13 2
#include <sys/types.h>
#include <sys/socket.h>
a14 10
#include <netdb.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>
#include <stdarg.h>

#include "xmalloc.h"
a16 1
#include "buffer.h"
d18 1
a22 1
#include "key.h"
a24 3
#include "match.h"
#include "channels.h"
#include "groupaccess.h"
a30 1
extern Buffer cfg;
d100 3
a102 2
	options->num_permitted_opens = -1;
	options->adm_forced_command = NULL;
a253 1
	sMatch, sPermitOpen, sForceCommand,
a257 4
#define SSHCFG_GLOBAL	0x01	/* allowed in main section of sshd_config */
#define SSHCFG_MATCH	0x02	/* allowed inside a Match section */
#define SSHCFG_ALL	(SSHCFG_GLOBAL|SSHCFG_MATCH)

a261 1
	u_int flags;
d263 17
a279 17
	{ "port", sPort, SSHCFG_GLOBAL },
	{ "hostkey", sHostKeyFile, SSHCFG_GLOBAL },
	{ "hostdsakey", sHostKeyFile, SSHCFG_GLOBAL },		/* alias */
	{ "pidfile", sPidFile, SSHCFG_GLOBAL },
	{ "serverkeybits", sServerKeyBits, SSHCFG_GLOBAL },
	{ "logingracetime", sLoginGraceTime, SSHCFG_GLOBAL },
	{ "keyregenerationinterval", sKeyRegenerationTime, SSHCFG_GLOBAL },
	{ "permitrootlogin", sPermitRootLogin, SSHCFG_GLOBAL },
	{ "syslogfacility", sLogFacility, SSHCFG_GLOBAL },
	{ "loglevel", sLogLevel, SSHCFG_GLOBAL },
	{ "rhostsauthentication", sDeprecated, SSHCFG_GLOBAL },
	{ "rhostsrsaauthentication", sRhostsRSAAuthentication, SSHCFG_GLOBAL },
	{ "hostbasedauthentication", sHostbasedAuthentication, SSHCFG_GLOBAL },
	{ "hostbasedusesnamefrompacketonly", sHostbasedUsesNameFromPacketOnly, SSHCFG_GLOBAL },
	{ "rsaauthentication", sRSAAuthentication, SSHCFG_GLOBAL },
	{ "pubkeyauthentication", sPubkeyAuthentication, SSHCFG_GLOBAL },
	{ "dsaauthentication", sPubkeyAuthentication, SSHCFG_GLOBAL }, /* alias */
d281 4
a284 4
	{ "kerberosauthentication", sKerberosAuthentication, SSHCFG_GLOBAL },
	{ "kerberosorlocalpasswd", sKerberosOrLocalPasswd, SSHCFG_GLOBAL },
	{ "kerberosticketcleanup", sKerberosTicketCleanup, SSHCFG_GLOBAL },
	{ "kerberosgetafstoken", sKerberosGetAFSToken, SSHCFG_GLOBAL },
d286 4
a289 4
	{ "kerberosauthentication", sUnsupported, SSHCFG_GLOBAL },
	{ "kerberosorlocalpasswd", sUnsupported, SSHCFG_GLOBAL },
	{ "kerberosticketcleanup", sUnsupported, SSHCFG_GLOBAL },
	{ "kerberosgetafstoken", sUnsupported, SSHCFG_GLOBAL },
d291 2
a292 2
	{ "kerberostgtpassing", sUnsupported, SSHCFG_GLOBAL },
	{ "afstokenpassing", sUnsupported, SSHCFG_GLOBAL },
d294 2
a295 2
	{ "gssapiauthentication", sGssAuthentication, SSHCFG_GLOBAL },
	{ "gssapicleanupcredentials", sGssCleanupCreds, SSHCFG_GLOBAL },
d297 2
a298 2
	{ "gssapiauthentication", sUnsupported, SSHCFG_GLOBAL },
	{ "gssapicleanupcredentials", sUnsupported, SSHCFG_GLOBAL },
d300 46
a345 49
	{ "passwordauthentication", sPasswordAuthentication, SSHCFG_GLOBAL },
	{ "kbdinteractiveauthentication", sKbdInteractiveAuthentication, SSHCFG_GLOBAL },
	{ "challengeresponseauthentication", sChallengeResponseAuthentication, SSHCFG_GLOBAL },
	{ "skeyauthentication", sChallengeResponseAuthentication, SSHCFG_GLOBAL }, /* alias */
	{ "checkmail", sDeprecated, SSHCFG_GLOBAL },
	{ "listenaddress", sListenAddress, SSHCFG_GLOBAL },
	{ "addressfamily", sAddressFamily, SSHCFG_GLOBAL },
	{ "printmotd", sPrintMotd, SSHCFG_GLOBAL },
	{ "printlastlog", sPrintLastLog, SSHCFG_GLOBAL },
	{ "ignorerhosts", sIgnoreRhosts, SSHCFG_GLOBAL },
	{ "ignoreuserknownhosts", sIgnoreUserKnownHosts, SSHCFG_GLOBAL },
	{ "x11forwarding", sX11Forwarding, SSHCFG_ALL },
	{ "x11displayoffset", sX11DisplayOffset, SSHCFG_ALL },
	{ "x11uselocalhost", sX11UseLocalhost, SSHCFG_ALL },
	{ "xauthlocation", sXAuthLocation, SSHCFG_GLOBAL },
	{ "strictmodes", sStrictModes, SSHCFG_GLOBAL },
	{ "permitemptypasswords", sEmptyPasswd, SSHCFG_GLOBAL },
	{ "permituserenvironment", sPermitUserEnvironment, SSHCFG_GLOBAL },
	{ "uselogin", sUseLogin, SSHCFG_GLOBAL },
	{ "compression", sCompression, SSHCFG_GLOBAL },
	{ "tcpkeepalive", sTCPKeepAlive, SSHCFG_GLOBAL },
	{ "keepalive", sTCPKeepAlive, SSHCFG_GLOBAL },	/* obsolete alias */
	{ "allowtcpforwarding", sAllowTcpForwarding, SSHCFG_ALL },
	{ "allowusers", sAllowUsers, SSHCFG_GLOBAL },
	{ "denyusers", sDenyUsers, SSHCFG_GLOBAL },
	{ "allowgroups", sAllowGroups, SSHCFG_GLOBAL },
	{ "denygroups", sDenyGroups, SSHCFG_GLOBAL },
	{ "ciphers", sCiphers, SSHCFG_GLOBAL },
	{ "macs", sMacs, SSHCFG_GLOBAL },
	{ "protocol", sProtocol, SSHCFG_GLOBAL },
	{ "gatewayports", sGatewayPorts, SSHCFG_ALL },
	{ "subsystem", sSubsystem, SSHCFG_GLOBAL },
	{ "maxstartups", sMaxStartups, SSHCFG_GLOBAL },
	{ "maxauthtries", sMaxAuthTries, SSHCFG_GLOBAL },
	{ "banner", sBanner, SSHCFG_GLOBAL },
	{ "usedns", sUseDNS, SSHCFG_GLOBAL },
	{ "verifyreversemapping", sDeprecated, SSHCFG_GLOBAL },
	{ "reversemappingcheck", sDeprecated, SSHCFG_GLOBAL },
	{ "clientaliveinterval", sClientAliveInterval, SSHCFG_GLOBAL },
	{ "clientalivecountmax", sClientAliveCountMax, SSHCFG_GLOBAL },
	{ "authorizedkeysfile", sAuthorizedKeysFile, SSHCFG_GLOBAL },
	{ "authorizedkeysfile2", sAuthorizedKeysFile2, SSHCFG_GLOBAL },
	{ "useprivilegeseparation", sUsePrivilegeSeparation, SSHCFG_GLOBAL},
	{ "acceptenv", sAcceptEnv, SSHCFG_GLOBAL },
	{ "permittunnel", sPermitTunnel, SSHCFG_GLOBAL },
	{ "match", sMatch, SSHCFG_ALL },
	{ "permitopen", sPermitOpen, SSHCFG_ALL },
	{ "forcecommand", sForceCommand, SSHCFG_ALL },
	{ NULL, sBadOption, 0 }
d354 1
a354 1
	    int linenum, u_int *flags)
d359 1
a359 2
		if (strcasecmp(cp, keywords[i].name) == 0) {
			*flags = keywords[i].flags;
a360 1
		}
a404 150
/*
 * The strategy for the Match blocks is that the config file is parsed twice.
 *
 * The first time is at startup.  activep is initialized to 1 and the
 * directives in the global context are processed and acted on.  Hitting a
 * Match directive unsets activep and the directives inside the block are
 * checked for syntax only.
 *
 * The second time is after a connection has been established but before
 * authentication.  activep is initialized to 2 and global config directives
 * are ignored since they have already been processed.  If the criteria in a
 * Match block is met, activep is set and the subsequent directives
 * processed and actioned until EOF or another Match block unsets it.  Any
 * options set are copied into the main server config.
 *
 * Potential additions/improvements:
 *  - Add Match support for pre-kex directives, eg Protocol, Ciphers.
 *
 *  - Add a Tag directive (idea from David Leonard) ala pf, eg:
 *	Match Address 192.168.0.*
 *		Tag trusted
 *	Match Group wheel
 *		Tag trusted
 *	Match Tag trusted
 *		AllowTcpForwarding yes
 *		GatewayPorts clientspecified
 *		[...]
 *
 *  - Add a PermittedChannelRequests directive
 *	Match Group shell
 *		PermittedChannelRequests session,forwarded-tcpip
 */

static int
match_cfg_line_group(const char *grps, int line, const char *user)
{
	int result = 0;
	u_int ngrps = 0;
	char *arg, *p, *cp, *grplist[MAX_MATCH_GROUPS];
	struct passwd *pw;

	/*
	 * Even if we do not have a user yet, we still need to check for
	 * valid syntax.
	 */
	arg = cp = xstrdup(grps);
	while ((p = strsep(&cp, ",")) != NULL && *p != '\0') {
		if (ngrps >= MAX_MATCH_GROUPS) {
			error("line %d: too many groups in Match Group", line);
			result = -1;
			goto out;
		}
		grplist[ngrps++] = p;
	}

	if (user == NULL)
		goto out;

	if ((pw = getpwnam(user)) == NULL) {
		debug("Can't match group at line %d because user %.100s does "
		    "not exist", line, user);
	} else if (ga_init(pw->pw_name, pw->pw_gid) == 0) {
		debug("Can't Match group because user %.100s not in any group "
		    "at line %d", user, line);
	} else if (ga_match(grplist, ngrps) != 1) {
		debug("user %.100s does not match group %.100s at line %d",
		    user, arg, line);
	} else {
		debug("user %.100s matched group %.100s at line %d", user,
		    arg, line);
		result = 1;
	}
out:
	ga_free();
	xfree(arg);
	return result;
}

static int
match_cfg_line(char **condition, int line, const char *user, const char *host,
    const char *address)
{
	int result = 1;
	char *arg, *attrib, *cp = *condition;
	size_t len;

	if (user == NULL)
		debug3("checking syntax for 'Match %s'", cp);
	else
		debug3("checking match for '%s' user %s host %s addr %s", cp,
		    user ? user : "(null)", host ? host : "(null)",
		    address ? address : "(null)");

	while ((attrib = strdelim(&cp)) && *attrib != '\0') {
		if ((arg = strdelim(&cp)) == NULL || *arg == '\0') {
			error("Missing Match criteria for %s", attrib);
			return -1;
		}
		len = strlen(arg);
		if (strcasecmp(attrib, "user") == 0) {
			if (!user) {
				result = 0;
				continue;
			}
			if (match_pattern_list(user, arg, len, 0) != 1)
				result = 0;
			else
				debug("user %.100s matched 'User %.100s' at "
				    "line %d", user, arg, line);
		} else if (strcasecmp(attrib, "group") == 0) {
			switch (match_cfg_line_group(arg, line, user)) {
			case -1:
				return -1;
			case 0:
				result = 0;
			}
		} else if (strcasecmp(attrib, "host") == 0) {
			if (!host) {
				result = 0;
				continue;
			}
			if (match_hostname(host, arg, len) != 1)
				result = 0;
			else
				debug("connection from %.100s matched 'Host "
				    "%.100s' at line %d", host, arg, line);
		} else if (strcasecmp(attrib, "address") == 0) {
			debug("address '%s' arg '%s'", address, arg);
			if (!address) {
				result = 0;
				continue;
			}
			if (match_hostname(address, arg, len) != 1)
				result = 0;
			else
				debug("connection from %.100s matched 'Address "
				    "%.100s' at line %d", address, arg, line);
		} else {
			error("Unsupported Match attribute %s", attrib);
			return -1;
		}
	}
	if (user != NULL)
		debug3("match %sfound", result ? "" : "not ");
	*condition = cp;
	return result;
}

#define WHITESPACE " \t\r\n"

d407 1
a407 2
    const char *filename, int linenum, int *activep, const char *user,
    const char *host, const char *address)
d410 1
a410 1
	int cmdline = 0, *intptr, value, n;
d413 1
a413 2
	u_int i, flags = 0;
	size_t len;
d425 1
a425 19
	opcode = parse_token(arg, filename, linenum, &flags);

	if (activep == NULL) { /* We are processing a command line directive */
		cmdline = 1;
		activep = &cmdline;
	}
	if (*activep && opcode != sMatch)
		debug3("%s:%d setting %s %s", filename, linenum, arg, cp);
	if (*activep == 0 && !(flags & SSHCFG_MATCH)) {
		if (user == NULL) {
			fatal("%s line %d: Directive '%s' is not allowed "
			    "within a Match block", filename, linenum, arg);
		} else { /* this is a directive we have already processed */
			while (arg)
				arg = strdelim(&cp);
			return 0;
		}
	}

d457 1
a457 1
		if (*activep && *intptr == -1)
d537 1
a537 1
		if (*activep && *charptr == NULL) {
d588 1
a588 1
		if (*activep && *intptr == -1)
d783 1
a783 1
				fatal("%s line %d: too many deny users.",
a852 4
		if (!*activep) {
			arg = strdelim(&cp);
			break;
		}
a862 11

		/* Collect arguments (separate to executable) */
		p = xstrdup(arg);
		len = strlen(p) + 1;
		while ((arg = strdelim(&cp)) != NULL && *arg != '\0') {
			len += 1 + strlen(arg);
			p = xrealloc(p, 1, len);
			strlcat(p, " ", len);
			strlcat(p, arg, len);
		}
		options->subsystem_args[options->num_subsystems] = p;
d903 1
a903 1
		charptr = (opcode == sAuthorizedKeysFile) ?
a923 2
			if (!*activep)
				break;
a950 49
	case sMatch:
		if (cmdline)
			fatal("Match directive not supported as a command-line "
			   "option");
		value = match_cfg_line(&cp, linenum, user, host, address);
		if (value < 0)
			fatal("%s line %d: Bad Match condition", filename,
			    linenum);
		*activep = value;
		break;

	case sPermitOpen:
		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing PermitOpen specification",
			    filename, linenum);
		if (strcmp(arg, "any") == 0) {
			if (*activep) {
				channel_clear_adm_permitted_opens();
				options->num_permitted_opens = 0;
			}
			break;
		}
		for (; arg != NULL && *arg != '\0'; arg = strdelim(&cp)) {
			p = hpdelim(&arg);
			if (p == NULL)
				fatal("%s line %d: missing host in PermitOpen",
				    filename, linenum);
			p = cleanhostname(p);
			if (arg == NULL || (port = a2port(arg)) == 0)
				fatal("%s line %d: bad port number in "
				    "PermitOpen", filename, linenum);
			if (*activep && options->num_permitted_opens == -1) {
				channel_clear_adm_permitted_opens();
				options->num_permitted_opens =
				    channel_add_adm_permitted_opens(p, port);
			}
		}
		break;

	case sForceCommand:
		if (cp == NULL)
			fatal("%.200s line %d: Missing argument.", filename,
			    linenum);
		len = strspn(cp, WHITESPACE);
		if (*activep && options->adm_forced_command == NULL)
			options->adm_forced_command = xstrdup(cp + len);
		return 0;

d1007 1
a1007 34
parse_server_match_config(ServerOptions *options, const char *user,
    const char *host, const char *address)
{
	ServerOptions mo;

	initialize_server_options(&mo);
	parse_server_config(&mo, "reprocess config", &cfg, user, host, address);
	copy_set_server_options(options, &mo);
}

/* Copy any (supported) values that are set */
void
copy_set_server_options(ServerOptions *dst, ServerOptions *src)
{
	if (src->allow_tcp_forwarding != -1)
		dst->allow_tcp_forwarding = src->allow_tcp_forwarding;
	if (src->gateway_ports != -1)
		dst->gateway_ports = src->gateway_ports;
	if (src->adm_forced_command != NULL) {
		if (dst->adm_forced_command != NULL)
			xfree(dst->adm_forced_command);
		dst->adm_forced_command = src->adm_forced_command;
	}
	if (src->x11_display_offset != -1)
		dst->x11_display_offset = src->x11_display_offset;
	if (src->x11_forwarding != -1)
		dst->x11_forwarding = src->x11_forwarding;
	if (src->x11_use_localhost != -1)
		dst->x11_use_localhost = src->x11_use_localhost;
}

void
parse_server_config(ServerOptions *options, const char *filename, Buffer *conf,
    const char *user, const char *host, const char *address)
d1009 1
a1009 1
	int active, linenum, bad_options = 0;
a1014 1
	active = user ? 0 : 1;
d1018 1
a1018 1
		    linenum++, &active, user, host, address) != 0)
@


1.1.1.8
log
@update OpenSSH, while we're at it…
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.167 2006/12/14 10:01:14 dtucker Exp $ */
a1179 1
		n = options->num_permitted_opens;	/* modified later */
d1181 1
a1181 1
			if (*activep && n == -1) {
a1186 2
		if (*activep && n == -1)
			channel_clear_adm_permitted_opens();
d1196 2
a1197 1
			if (*activep && n == -1)
d1200 1
@


1.1.1.9
log
@Import OpenSSH 4.6
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.170 2007/03/01 10:28:02 dtucker Exp $ */
d295 2
a296 2
	{ "rhostsrsaauthentication", sRhostsRSAAuthentication, SSHCFG_ALL },
	{ "hostbasedauthentication", sHostbasedAuthentication, SSHCFG_ALL },
d298 2
a299 2
	{ "rsaauthentication", sRSAAuthentication, SSHCFG_ALL },
	{ "pubkeyauthentication", sPubkeyAuthentication, SSHCFG_ALL },
d302 1
a302 1
	{ "kerberosauthentication", sKerberosAuthentication, SSHCFG_ALL },
d307 1
a307 1
	{ "kerberosauthentication", sUnsupported, SSHCFG_ALL },
d315 1
a315 1
	{ "gssapiauthentication", sGssAuthentication, SSHCFG_ALL },
d318 1
a318 1
	{ "gssapiauthentication", sUnsupported, SSHCFG_ALL },
d321 2
a322 2
	{ "passwordauthentication", sPasswordAuthentication, SSHCFG_ALL },
	{ "kbdinteractiveauthentication", sKbdInteractiveAuthentication, SSHCFG_ALL },
d355 1
a355 1
	{ "banner", sBanner, SSHCFG_ALL },
d928 1
a928 1
		if (*activep && *intptr == -1)
d1277 1
a1277 1
	copy_set_server_options(options, &mo, 0);
d1280 1
a1280 20
/* Helper macros */
#define M_CP_INTOPT(n) do {\
	if (src->n != -1) \
		dst->n = src->n; \
} while (0)
#define M_CP_STROPT(n) do {\
	if (src->n != NULL) { \
		if (dst->n != NULL) \
			xfree(dst->n); \
		dst->n = src->n; \
	} \
} while(0)

/*
 * Copy any supported values that are set.
 *
 * If the preauth flag is set, we do not bother copying the the string or
 * array values that are not used pre-authentication, because any that we
 * do use must be explictly sent in mm_getpwnamallow().
 */
d1282 1
a1282 1
copy_set_server_options(ServerOptions *dst, ServerOptions *src, int preauth)
d1284 15
a1298 18
	M_CP_INTOPT(password_authentication);
	M_CP_INTOPT(gss_authentication);
	M_CP_INTOPT(rsa_authentication);
	M_CP_INTOPT(pubkey_authentication);
	M_CP_INTOPT(kerberos_authentication);
	M_CP_INTOPT(hostbased_authentication);
	M_CP_INTOPT(kbd_interactive_authentication);

	M_CP_INTOPT(allow_tcp_forwarding);
	M_CP_INTOPT(gateway_ports);
	M_CP_INTOPT(x11_display_offset);
	M_CP_INTOPT(x11_forwarding);
	M_CP_INTOPT(x11_use_localhost);

	M_CP_STROPT(banner);
	if (preauth)
		return;
	M_CP_STROPT(adm_forced_command);
a1300 3
#undef M_CP_INTOPT
#undef M_CP_STROPT

a1321 4

	/* challenge-response is implemented via keyboard interactive */
	if (options->challenge_response_authentication == 1)
		options->kbd_interactive_authentication = 1;
@


1.1.1.10
log
@Move C/R -> kbdint special case to after the defaults have been
loaded, which makes ChallengeResponse default to yes again.  This
was broken by the Match changes and not fixed properly subsequently.
Found by okan at demirmen.com, ok djm@@ "please do it" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.171 2007/03/09 05:20:06 dtucker Exp $ */
d1347 4
@


1.1.1.11
log
@import openbsd compress, ssh, perl, sendmail for minor bugfixes
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.172 2007/04/23 10:15:39 dtucker Exp $ */
d558 1
@


1.1.1.12
log
@newer openssh
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.177 2008/02/10 10:54:28 djm Exp $ */
a117 1
	options->chroot_directory = NULL;
d269 1
a269 1
	sMatch, sPermitOpen, sForceCommand, sChrootDirectory,
d291 1
a291 1
	{ "permitrootlogin", sPermitRootLogin, SSHCFG_ALL },
a368 1
	{ "chrootdirectory", sChrootDirectory, SSHCFG_ALL },
d424 1
a424 1
		    ssh_gai_strerror(gaierr));
a586 2
	SyslogFacility *log_facility_ptr;
	LogLevel *log_level_ptr;
d764 1
a764 1
		if (*activep && *intptr == -1)
d936 1
a936 1
		log_facility_ptr = &options->log_facility;
d942 2
a943 2
		if (*log_facility_ptr == -1)
			*log_facility_ptr = (SyslogFacility) value;
d947 1
a947 1
		log_level_ptr = &options->log_level;
d953 2
a954 2
		if (*log_level_ptr == -1)
			*log_level_ptr = (LogLevel) value;
a1104 1

a1212 11
	case sChrootDirectory:
		charptr = &options->chroot_directory;

		arg = strdelim(&cp);
		if (!arg || *arg == '\0')
			fatal("%s line %d: missing file name.",
			    filename, linenum);
		if (*activep && *charptr == NULL)
			*charptr = xstrdup(arg);
		break;

a1308 1
	M_CP_INTOPT(permit_root_login);
a1319 1
	M_CP_STROPT(chroot_directory);
@


1.1.1.13
log
@OpenSSH-current
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.193 2008/12/09 03:20:42 stevesk Exp $ */
a14 1
#include <sys/queue.h>
a23 1
#include <errno.h>
a94 1
	options->allow_agent_forwarding = -1;
a107 1
	options->max_sessions = -1;
a118 1
	options->zero_knowledge_password_authentication = -1;
d145 1
a145 1
		options->server_key_bits = 1024;
a213 2
	if (options->allow_agent_forwarding == -1)
		options->allow_agent_forwarding = 1;
a223 2
	if (options->max_sessions == -1)
		options->max_sessions = DEFAULT_SESSIONS_MAX;
a240 2
	if (options->zero_knowledge_password_authentication == -1)
		options->zero_knowledge_password_authentication = 0;
d265 1
a265 1
	sMaxStartups, sMaxAuthTries, sMaxSessions,
d271 1
a271 2
	sUsePrivilegeSeparation, sAllowAgentForwarding,
	sZeroKnowledgePasswordAuthentication,
a325 5
#ifdef JPAKE
	{ "zeroknowledgepasswordauthentication", sZeroKnowledgePasswordAuthentication, SSHCFG_ALL },
#else
	{ "zeroknowledgepasswordauthentication", sUnsupported, SSHCFG_ALL },
#endif
d338 1
a338 1
	{ "permitemptypasswords", sEmptyPasswd, SSHCFG_ALL },
a344 1
	{ "allowagentforwarding", sAllowAgentForwarding, SSHCFG_ALL },
d355 1
a355 2
	{ "maxauthtries", sMaxAuthTries, SSHCFG_ALL },
	{ "maxsessions", sMaxSessions, SSHCFG_ALL },
a373 11
static struct {
	int val;
	char *text;
} tunmode_desc[] = {
	{ SSH_TUNMODE_NO, "no" },
	{ SSH_TUNMODE_POINTOPOINT, "point-to-point" },
	{ SSH_TUNMODE_ETHERNET, "ethernet" },
	{ SSH_TUNMODE_YES, "yes" },
	{ -1, NULL }
};

d470 2
d474 14
d497 3
a499 3
	} else if (ga_match_pattern_list(grps) != 1) {
		debug("user %.100s does not match group list %.100s at line %d",
		    user, grps, line);
d501 2
a502 2
		debug("user %.100s matched group list %.100s at line %d", user,
		    grps, line);
d507 1
d560 7
a566 2
			switch (addr_match_list(address, arg)) {
			case 1:
a568 8
				break;
			case 0:
			case -1:
				result = 0;
				break;
			case -2:
				return -1;
			}
d650 1
a650 1
 parse_int:
d662 1
a662 1
 parse_time:
d731 1
a731 1
 parse_filename:
d774 1
a774 1
 parse_flag:
a842 4
	case sZeroKnowledgePasswordAuthentication:
		intptr = &options->zero_knowledge_password_authentication;
		goto parse_flag;

a964 4
	case sAllowAgentForwarding:
		intptr = &options->allow_agent_forwarding;
		goto parse_flag;

a1105 4
	case sMaxSessions:
		intptr = &options->max_sessions;
		goto parse_int;

d1152 10
a1161 7
		value = -1;
		for (i = 0; tunmode_desc[i].val != -1; i++)
			if (strcmp(tunmode_desc[i].text, arg) == 0) {
				value = tunmode_desc[i].val;
				break;
			}
		if (value == -1)
a1324 1
	M_CP_INTOPT(zero_knowledge_password_authentication);
a1325 1
	M_CP_INTOPT(permit_empty_passwd);
a1327 1
	M_CP_INTOPT(allow_agent_forwarding);
a1331 2
	M_CP_INTOPT(max_sessions);
	M_CP_INTOPT(max_authtries);
a1364 217

static const char *
fmt_intarg(ServerOpCodes code, int val)
{
	if (code == sAddressFamily) {
		switch (val) {
		case AF_INET:
			return "inet";
		case AF_INET6:
			return "inet6";
		case AF_UNSPEC:
			return "any";
		default:
			return "UNKNOWN";
		}
	}
	if (code == sPermitRootLogin) {
		switch (val) {
		case PERMIT_NO_PASSWD:
			return "without-password";
		case PERMIT_FORCED_ONLY:
			return "forced-commands-only";
		case PERMIT_YES:
			return "yes";
		}
	}
	if (code == sProtocol) {
		switch (val) {
		case SSH_PROTO_1:
			return "1";
		case SSH_PROTO_2:
			return "2";
		case (SSH_PROTO_1|SSH_PROTO_2):
			return "2,1";
		default:
			return "UNKNOWN";
		}
	}
	if (code == sGatewayPorts && val == 2)
		return "clientspecified";
	if (code == sCompression && val == COMP_DELAYED)
		return "delayed";
	switch (val) {
	case -1:
		return "unset";
	case 0:
		return "no";
	case 1:
		return "yes";
	}
	return "UNKNOWN";
}

static const char *
lookup_opcode_name(ServerOpCodes code)
{
	u_int i;

	for (i = 0; keywords[i].name != NULL; i++)
		if (keywords[i].opcode == code)
			return(keywords[i].name);
	return "UNKNOWN";
}

static void
dump_cfg_int(ServerOpCodes code, int val)
{
	printf("%s %d\n", lookup_opcode_name(code), val);
}

static void
dump_cfg_fmtint(ServerOpCodes code, int val)
{
	printf("%s %s\n", lookup_opcode_name(code), fmt_intarg(code, val));
}

static void
dump_cfg_string(ServerOpCodes code, const char *val)
{
	if (val == NULL)
		return;
	printf("%s %s\n", lookup_opcode_name(code), val);
}

static void
dump_cfg_strarray(ServerOpCodes code, u_int count, char **vals)
{
	u_int i;

	for (i = 0; i < count; i++)
		printf("%s %s\n", lookup_opcode_name(code),  vals[i]);
}

void
dump_config(ServerOptions *o)
{
	u_int i;
	int ret;
	struct addrinfo *ai;
	char addr[NI_MAXHOST], port[NI_MAXSERV], *s = NULL;

	/* these are usually at the top of the config */
	for (i = 0; i < o->num_ports; i++)
		printf("port %d\n", o->ports[i]);
	dump_cfg_fmtint(sProtocol, o->protocol);
	dump_cfg_fmtint(sAddressFamily, o->address_family);

	/* ListenAddress must be after Port */
	for (ai = o->listen_addrs; ai; ai = ai->ai_next) {
		if ((ret = getnameinfo(ai->ai_addr, ai->ai_addrlen, addr,
		    sizeof(addr), port, sizeof(port),
		    NI_NUMERICHOST|NI_NUMERICSERV)) != 0) {
			error("getnameinfo failed: %.100s",
			    (ret != EAI_SYSTEM) ? gai_strerror(ret) :
			    strerror(errno));
		} else {
			if (ai->ai_family == AF_INET6)
				printf("listenaddress [%s]:%s\n", addr, port);
			else
				printf("listenaddress %s:%s\n", addr, port);
		}
	}

	/* integer arguments */
	dump_cfg_int(sServerKeyBits, o->server_key_bits);
	dump_cfg_int(sLoginGraceTime, o->login_grace_time);
	dump_cfg_int(sKeyRegenerationTime, o->key_regeneration_time);
	dump_cfg_int(sX11DisplayOffset, o->x11_display_offset);
	dump_cfg_int(sMaxAuthTries, o->max_authtries);
	dump_cfg_int(sMaxSessions, o->max_sessions);
	dump_cfg_int(sClientAliveInterval, o->client_alive_interval);
	dump_cfg_int(sClientAliveCountMax, o->client_alive_count_max);

	/* formatted integer arguments */
	dump_cfg_fmtint(sPermitRootLogin, o->permit_root_login);
	dump_cfg_fmtint(sIgnoreRhosts, o->ignore_rhosts);
	dump_cfg_fmtint(sIgnoreUserKnownHosts, o->ignore_user_known_hosts);
	dump_cfg_fmtint(sRhostsRSAAuthentication, o->rhosts_rsa_authentication);
	dump_cfg_fmtint(sHostbasedAuthentication, o->hostbased_authentication);
	dump_cfg_fmtint(sHostbasedUsesNameFromPacketOnly,
	    o->hostbased_uses_name_from_packet_only);
	dump_cfg_fmtint(sRSAAuthentication, o->rsa_authentication);
	dump_cfg_fmtint(sPubkeyAuthentication, o->pubkey_authentication);
#ifdef KRB5
	dump_cfg_fmtint(sKerberosAuthentication, o->kerberos_authentication);
	dump_cfg_fmtint(sKerberosOrLocalPasswd, o->kerberos_or_local_passwd);
	dump_cfg_fmtint(sKerberosTicketCleanup, o->kerberos_ticket_cleanup);
	dump_cfg_fmtint(sKerberosGetAFSToken, o->kerberos_get_afs_token);
#endif
#ifdef GSSAPI
	dump_cfg_fmtint(sGssAuthentication, o->gss_authentication);
	dump_cfg_fmtint(sGssCleanupCreds, o->gss_cleanup_creds);
#endif
#ifdef JPAKE
	dump_cfg_fmtint(sZeroKnowledgePasswordAuthentication,
	    o->zero_knowledge_password_authentication);
#endif
	dump_cfg_fmtint(sPasswordAuthentication, o->password_authentication);
	dump_cfg_fmtint(sKbdInteractiveAuthentication,
	    o->kbd_interactive_authentication);
	dump_cfg_fmtint(sChallengeResponseAuthentication,
	    o->challenge_response_authentication);
	dump_cfg_fmtint(sPrintMotd, o->print_motd);
	dump_cfg_fmtint(sPrintLastLog, o->print_lastlog);
	dump_cfg_fmtint(sX11Forwarding, o->x11_forwarding);
	dump_cfg_fmtint(sX11UseLocalhost, o->x11_use_localhost);
	dump_cfg_fmtint(sStrictModes, o->strict_modes);
	dump_cfg_fmtint(sTCPKeepAlive, o->tcp_keep_alive);
	dump_cfg_fmtint(sEmptyPasswd, o->permit_empty_passwd);
	dump_cfg_fmtint(sPermitUserEnvironment, o->permit_user_env);
	dump_cfg_fmtint(sUseLogin, o->use_login);
	dump_cfg_fmtint(sCompression, o->compression);
	dump_cfg_fmtint(sGatewayPorts, o->gateway_ports);
	dump_cfg_fmtint(sUseDNS, o->use_dns);
	dump_cfg_fmtint(sAllowTcpForwarding, o->allow_tcp_forwarding);
	dump_cfg_fmtint(sUsePrivilegeSeparation, use_privsep);

	/* string arguments */
	dump_cfg_string(sPidFile, o->pid_file);
	dump_cfg_string(sXAuthLocation, o->xauth_location);
	dump_cfg_string(sCiphers, o->ciphers);
	dump_cfg_string(sMacs, o->macs);
	dump_cfg_string(sBanner, o->banner);
	dump_cfg_string(sAuthorizedKeysFile, o->authorized_keys_file);
	dump_cfg_string(sAuthorizedKeysFile2, o->authorized_keys_file2);
	dump_cfg_string(sForceCommand, o->adm_forced_command);

	/* string arguments requiring a lookup */
	dump_cfg_string(sLogLevel, log_level_name(o->log_level));
	dump_cfg_string(sLogFacility, log_facility_name(o->log_facility));

	/* string array arguments */
	dump_cfg_strarray(sHostKeyFile, o->num_host_key_files,
	     o->host_key_files);
	dump_cfg_strarray(sAllowUsers, o->num_allow_users, o->allow_users);
	dump_cfg_strarray(sDenyUsers, o->num_deny_users, o->deny_users);
	dump_cfg_strarray(sAllowGroups, o->num_allow_groups, o->allow_groups);
	dump_cfg_strarray(sDenyGroups, o->num_deny_groups, o->deny_groups);
	dump_cfg_strarray(sAcceptEnv, o->num_accept_env, o->accept_env);

	/* other arguments */
	for (i = 0; i < o->num_subsystems; i++)
		printf("subsystem %s %s\n", o->subsystem_name[i],
		    o->subsystem_args[i]);

	printf("maxstartups %d:%d:%d\n", o->max_startups_begin,
	    o->max_startups_rate, o->max_startups);

	for (i = 0; tunmode_desc[i].val != -1; i++)
		if (tunmode_desc[i].val == o->permit_tun) {
			s = tunmode_desc[i].text;
			break;
		}
	dump_cfg_string(sPermitTunnel, s);

	channel_print_adm_permitted_opens();
}
@


1.1.1.14
log
@OpenSSH 5.2, or so
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.194 2009/01/22 10:02:34 djm Exp $ */
d43 2
a44 2
static void add_listen_addr(ServerOptions *, char *, int);
static void add_one_listen_addr(ServerOptions *, char *, int);
d426 1
a426 1
add_listen_addr(ServerOptions *options, char *addr, int port)
d442 1
a442 1
add_one_listen_addr(ServerOptions *options, char *addr, int port)
d452 1
a452 1
	snprintf(strport, sizeof strport, "%d", port);
d608 1
a608 1
	int port;
d659 1
a659 1
		if (options->ports[options->num_ports-1] <= 0)
d712 1
a712 1
		else if ((port = a2port(arg)) <= 0)
d1225 1
a1225 1
			if (arg == NULL || (port = a2port(arg)) <= 0)
@


1.1.1.15
log
@Let’s play the version number game – OpenSSH 5.3-current
@
text
@d1 1
a1 1
/* $OpenBSD: servconf.c,v 1.195 2009/04/14 21:10:54 jj Exp $ */
d1336 1
a1336 1
 * If the preauth flag is set, we do not bother copying the string or
@


