head	1.19;
access;
symbols
	MIRBSD_10:1.7.0.2
	MIRBSD_10_BASE:1.7
	MIRBSD_9_BASE:1.1.1.2
	MIRBSD_8:1.1.1.2.0.2
	MIRBSD_8_BASE:1.1.1.2
	cvs-200507211800:1.1.1.2
	cvs-200504291700:1.1.1.2
	cvs-200504170300:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2019.07.21.01.50.23;	author tg;	state Exp;
branches;
next	1.18;
commitid	1005D33C4F90B583C08;

1.18
date	2019.07.21.01.00.11;	author tg;	state Exp;
branches;
next	1.17;
commitid	1005D33B9306366BF11;

1.17
date	2019.07.21.00.25.07;	author tg;	state Exp;
branches;
next	1.16;
commitid	1005D33B0E628D34A17;

1.16
date	2019.07.20.23.46.14;	author tg;	state Exp;
branches;
next	1.15;
commitid	1005D33A7E067E7E7C8;

1.15
date	2019.07.20.23.42.30;	author tg;	state Exp;
branches;
next	1.14;
commitid	1005D33A700262BF465;

1.14
date	2019.07.20.23.21.42;	author tg;	state Exp;
branches;
next	1.12;
commitid	1005D33A21B2FE85D47;

1.12
date	2019.07.20.23.19.34;	author tg;	state Exp;
branches;
next	1.11;
commitid	1005D33A19F05DD5AE3;

1.11
date	2019.07.20.23.07.33;	author tg;	state Exp;
branches;
next	1.10;
commitid	1005D339ECA4DB77754;

1.10
date	2016.01.02.21.33.08;	author tg;	state Exp;
branches;
next	1.9;
commitid	10056884200442406AA;

1.9
date	2009.04.16.12.17.46;	author tg;	state Exp;
branches;
next	1.8;
commitid	10049E721F35ACA3135;

1.8
date	2008.11.18.21.14.30;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004923304D64BCEE84;

1.7
date	2007.08.24.14.20.08;	author tg;	state Exp;
branches;
next	1.6;
commitid	10046CEE8E817DEC27F;

1.6
date	2007.07.05.23.09.38;	author tg;	state Exp;
branches;
next	1.5;
commitid	100468D7A224CDB6D5A;

1.5
date	2007.01.05.03.41.16;	author tg;	state Exp;
branches;
next	1.4;
commitid	100459DC89F29920C98;

1.4
date	2006.11.17.02.57.21;	author tg;	state Exp;
branches;
next	1.3;
commitid	100455D2502687F55C2;

1.3
date	2006.11.17.02.48.09;	author tg;	state Exp;
branches;
next	1.2;
commitid	100455D22F746FFE563;

1.2
date	2006.11.17.02.06.07;	author tg;	state Exp;
branches;
next	1.1;
commitid	100455D192632D109AB;

1.1
date	2005.02.05.17.29.25;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.29.25;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.17.03.31.22;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2019.07.20.23.15.20;	author tg;	state Exp;
branches;
next	;
commitid	1005D33A09C0AFD96DE;


desc
@@


1.19
log
@crazy russkij
@
text
@/*	$OpenBSD: io.c,v 1.29+backports from 1.49 2005/04/15 14:28:56 otto Exp $	*/

/*
 * Copyright (c) 1989, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 2019
 *	mirabilos <m@@mirbsd.org>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/uio.h>
#include <sys/wait.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#ifdef UNICODE
#define _ALL_SOURCE
#include <iconv.h>
#endif
#include <locale.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#ifndef ioweg
#define ioweg iovec /* cf. MirBSD writev(2) manpage; do NOT move! */
#endif

#include "pathnames.h"
#include "calendar.h"

__COPYRIGHT("@@(#) Copyright (c) 1989, 1993\n\
	The Regents of the University of California.  All rights reserved.\n");
__SCCSID("@@(#)calendar.c  8.3 (Berkeley) 3/25/94");
__RCSID("$MirOS: src/usr.bin/calendar/io.c,v 1.18 2019/07/21 01:00:11 tg Exp $");

struct ioweg header[] = {
	{ "From: ", 6 },
	{ NULL, 0 },
	{ " (Reminder Service)\nTo: ", 24 },
	{ NULL, 0 },
	{ "\nSubject: ", 10 },
	{ NULL, 0 },
#ifdef UNICODE
	{ "'s Calendar\nMIME-Version: 1.0\n"
	  "Content-type: text/plain; charset=utf-8\n"
	  "Precedence: bulk\n", 87 },
#else
	{ "'s Calendar\nPrecedence: bulk\n", 29 },
#endif
	{ "Auto-Submitted: auto-generated\n\n", 32 },
};

#ifdef UNICODE
iconv_t s_conv;
#endif

void
cal(void)
{
	int printing;
	char *p;
	FILE *fp;
	int ch, l, i, bodun = 0, bodun_maybe = 0;
	int var;
	char buf[2048 + 1], *prefix = NULL;
#ifdef UNICODE
	char buf2[2048 * 4 + 1];
#endif
	struct event *events, *cur_evt, *ev1 = NULL, *tmp;
	struct match *m;
	size_t nlen;
	const char *hfyear[3] = {
		"%1$d: %2$d year(s) ago",
		"%1$d: this year",
		"%1$d: in %2$d year(s)"
	};
	char anniv = 0;

	events = NULL;
	cur_evt = NULL;
	if ((fp = opencal()) == NULL)
		return;
	s_conv = (iconv_t)-1;
	for (printing = 0; fgets(buf, sizeof(buf), stdin) != NULL;) {
		if ((p = strchr(buf, '\n')) != NULL)
			*p = '\0';
		else
			while ((ch = getchar()) != '\n' && ch != EOF);
		for (l = strlen(buf); l > 0 && isspace(buf[l - 1]); l--)
			;
		buf[l] = '\0';
		if (buf[0] == '\0')
			continue;
		if (strncmp(buf, "LANG=", 5) == 0) {
#ifdef UNICODE
			{
				const char *s_charset;

				if (s_conv != (iconv_t)-1)
					iconv_close(s_conv);
				if ((s_charset = strchr(buf, '.')) == NULL)
					s_charset = buf + 5;
				else
					++s_charset;
				if (s_charset[0] == 'C' && s_charset[1] == '\0')
					++s_charset;
				s_conv = (*s_charset == '\0') ? (iconv_t)-1 :
				    iconv_open("UTF-8", s_charset);
			}
#endif
			(void) setlocale(LC_ALL, buf + 5);
			setnnames();
			if (!strcmp(buf + 5, "ru_RU.KOI8-R") ||
			    !strcmp(buf + 5, "uk_UA.KOI8-U") ||
			    !strcmp(buf + 5, "by_BY.KOI8-B")) {
				bodun_maybe++;
				bodun = 0;
				free(prefix);
				prefix = NULL;
			} else
				bodun = bodun_maybe = 0;
			continue;
		}
#ifdef UNICODE
		if (s_conv != (iconv_t)-1) {
			const char *src = buf;
			char *dst = buf2;
			size_t slen = strlen(buf), dlen = sizeof (buf2);

			__iconv(s_conv, &src, &slen, &dst, &dlen, 1, NULL);
			*dst = '\0';
			if (slen)
				strlcat(buf2, src, sizeof (buf2));
		} else
			memmove(buf2, buf, strlen(buf) + 1);
#define buf buf2
#endif
		if (strncmp(buf, "CALENDAR=", 9) == 0) {
			char *ep;

			if (buf[9] == '\0')
				calendar = 0;
			else if (!strcasecmp(buf + 9, "julian")) {
				calendar = JULIAN;
				errno = 0;
				julian = strtoul(buf + 14, &ep, 10);
				if (buf[0] == '\0' || *ep != '\0')
					julian = 13;
				if ((errno == ERANGE && julian == ULONG_MAX) ||
				    julian > 14)
					errx(1, "Julian calendar offset is too large");
			} else if (!strcasecmp(buf + 9, "gregorian"))
				calendar = GREGORIAN;
			else if (!strcasecmp(buf + 9, "lunar"))
				calendar = LUNAR;
		} else if (strncmp(buf, "ANNIV=", 6) == 0) {
			anniv = 1;
			if (buf[6] == '1' && !buf[7])
				continue;
			p = buf + 6;
			for (i = 0; i < 3; ++i) {
				if (!*p)
					break;
				hfyear[i] = p;
				while (*p && *p != 0x1C) {
					if (*p++ != '%')
						continue;
					if (*p == '%') {
						++p;
						continue;
					}
					if ((*p == '1' || *p == '2') &&
					    p[1] == '$' && p[2] == 'd') {
						p += 3;
						continue;
					}
					/* double the % */
					memmove(p, p - 1,
					    sizeof(buf) - ((p - 1) - buf));
					++p;
				}
				l = *p;
				*p++ = '\0';
				if ((hfyear[i] = strdup(hfyear[i])) == NULL)
					err(1, NULL);
				if (!l)
					break;
			}
			continue;
		} else if (bodun_maybe && strncmp(buf, "BODUN=", 6) == 0) {
			bodun++;
			free(prefix);
			if ((prefix = strdup(buf + 6)) == NULL)
				err(1, NULL);
			continue;
		}
		/* User defined names for special events */
		if ((p = strchr(buf, '='))) {
			for (i = 0; i < NUMEV; i++) {
				if (strncasecmp(buf, spev[i].name, spev[i].nlen) == 0 &&
				    (p - buf == spev[i].nlen) && buf[spev[i].nlen + 1]) {
					p++;
					if (spev[i].uname != NULL)
						free(spev[i].uname);
					if ((spev[i].uname = strdup(p)) == NULL)
						err(1, NULL);
					spev[i].ulen = strlen(p);
					i = NUMEV + 1;
				}
			}
			if (i > NUMEV)
				continue;
		}
		if (buf[0] != '\t') {
			printing = (m = isnow(buf, bodun)) ? 1 : 0;
			if ((p = strchr(buf, '\t')) == NULL) {
				printing = 0;
				continue;
			}
			/* Need the following to catch hardwired "variable"
			 * dates */
			if (p > buf && p[-1] == '*')
				var = 1;
			else
				var = 0;
			if (printing) {
				struct match *foo;

				ev1 = NULL;
				while (m) {
					cur_evt = (struct event *) malloc(sizeof(struct event));
					if (cur_evt == NULL)
						err(1, NULL);

					cur_evt->when = m->when;
					cur_evt->year = m->year;
					snprintf(cur_evt->print_date,
					    sizeof(cur_evt->print_date), "%s%c",
					    m->print_date, (var + m->var) ? '*' : ' ');
					if (ev1) {
						cur_evt->desc = ev1->desc;
						cur_evt->ldesc = NULL;
					} else {
						if (m->bodun && prefix) {
							int l1 = strlen(prefix);
							int l2 = strlen(p);
							int len = l1 + l2 + 2;
							if ((cur_evt->ldesc =
							    malloc(len)) == NULL)
								err(1, NULL);
							snprintf(cur_evt->ldesc, len,
							    "\t%s %s", prefix, p + 1);
						} else if ((cur_evt->ldesc =
						    strdup(p)) == NULL)
							err(1, NULL);
						cur_evt->desc = &(cur_evt->ldesc);
						ev1 = cur_evt;
					}
					insert(&events, cur_evt);
					foo = m;
					m = m->next;
					free(foo);
				}
			}
		} else if (printing) {
			nlen = strlen(ev1->ldesc) + strlen(buf) + 2;
			if ((ev1->ldesc = realloc(ev1->ldesc, nlen)) == NULL)
				err(1, NULL);
			snprintf(ev1->ldesc, nlen, "%s\n%s", ev1->ldesc, buf);
		}
	}
#ifdef UNICODE
#undef buf
#endif
	tmp = events;
	while (tmp) {
		if (!anniv) {
 noanniv:
			fprintf(fp, "%s%s\n", tmp->print_date, *(tmp->desc));
		} else {
			p = *(tmp->desc);
			if (*p++ != '\t')
				goto noanniv;
			if (isdigit(p[0]) && isdigit(p[1]) && isdigit(p[2]) &&
			    isdigit(p[3]) && p[4] == ',' && isspace(p[5])) {
				p[4] = '\0';
				i = atoi(p);
				p += 6;
				while (isspace(*p))
					++p;
			} else if ((nlen = strlen(p)) < 7 ||
			    (nlen -= (l = ((uint8_t)p[nlen - 1] == 0xB5U &&
			    (uint8_t)p[nlen - 2] == 0xD0U &&
			    p[nlen - 3] == '-' ? 3 :
			    (uint8_t)p[nlen - 1] == 0xB3U &&
			    (uint8_t)p[nlen - 2] == 0xD0U ? 2 : 0))) < 7) {
				goto noanniv;
			} else if (isdigit(p[nlen - 1]) &&
			    isdigit(p[nlen - 2]) &&
			    (i = (isdigit(p[nlen - 3]) &&
			    isdigit(p[nlen - 4]) &&
			    isspace(p[nlen - 5]) && p[nlen - 6] == ',' ? 6 :
			    l && isdigit(p[nlen - 3]) &&
			    isspace(p[nlen - 4]) && p[nlen - 5] == ',' ? 5 :
			    l &&
			    isspace(p[nlen - 3]) && p[nlen - 4] == ',' ? 4 :
			    0))) {
				p[nlen - i] = '\0';
				p[nlen] = '\0';
				i = atoi(p + (nlen - (i - 2)));
			} else
				goto noanniv;
			l = tmp->year - i;
			snprintf(buf, sizeof(buf), hfyear[1 - sgn(l)],
			    i, abs(l));
			fprintf(fp, "%s\t%s, %s\n", tmp->print_date, p, buf);
		}
		tmp = tmp->next;
	}
	tmp = events;
	while (tmp) {
		events = tmp;
		free(tmp->ldesc);
		tmp = tmp->next;
		free(events);
	}
	closecal(fp);
}

int
getfield(char *p, char **endp, int *flags)
{
	int val, var, i;
	char *start, savech;

	for (; !isdigit(*p) && !isalpha(*p) && *p != '*' && *p != '\t'; ++p)
		;
	if (*p == '*') {			/* `*' is every month */
		*flags |= F_ISMONTH;
		*endp = p+1;
		return (-1);	/* means 'every month' */
	}
	if (isdigit(*p)) {
		val = strtol(p, &p, 10);	/* if 0, it's failure */
		for (; !isdigit(*p) && !isalpha(*p) && *p != '*'; ++p)
			;
		*endp = p;
		return (val);
	}
	for (start = p; isalpha(*++p);)
		;

	/* Sunday-1 */
	if (*p == '+' || *p == '-')
	    for(; isdigit(*++p);)
		;

	savech = *p;
	*p = '\0';

	/* Month */
	if ((val = getmonth(start)) != 0)
		*flags |= F_ISMONTH;

	/* Day */
	else if ((val = getday(start)) != 0) {
	    *flags |= F_ISDAY;

	    /* variable weekday */
	    if ((var = getdayvar(start)) != 0) {
		if (var <= 5 && var >= -4)
		    val += var * 10;
#ifdef DEBUG
		printf("var: %d\n", var);
#endif
	    }
	}

	/* Try specials (Easter, Paskha, ...) */
	else {
		for (i = 0; i < NUMEV; i++) {
			if (strncasecmp(start, spev[i].name, spev[i].nlen) == 0) {
				start += spev[i].nlen;
				val = i + 1;
				i = NUMEV + 1;
			} else if (spev[i].uname != NULL &&
			    strncasecmp(start, spev[i].uname, spev[i].ulen) == 0) {
				start += spev[i].ulen;
				val = i + 1;
				i = NUMEV + 1;
			}
		}
		if (i > NUMEV) {
			switch(*start) {
			case '-':
			case '+':
			   var = atoi(start);
			   if (var > 365 || var < -365)
				   return (0); /* Someone is just being silly */
			   val += (NUMEV + 1) * var;
			   /* We add one to the matching event and multiply by
			    * (NUMEV + 1) so as not to return 0 if there's a match.
			    * val will overflow if there is an obscenely large
			    * number of special events. */
			   break;
			}
		*flags |= F_SPECIAL;
		}
		if (!(*flags & F_SPECIAL)) {
		/* undefined rest */
			*p = savech;
			return (0);
		}
	}
	for (*p = savech; !isdigit(*p) && !isalpha(*p) && *p != '*' && *p != '\t'; ++p)
		;
	*endp = p;
	return (val);
}


FILE *
opencal(void)
{
	int pdes[2];
	volatile int fdin; /* vfork clobber warning, needs investigation */
	struct stat st;

	/* open up calendar file as stdin */
	if ((fdin = open(calendarFile, O_RDONLY)) == -1 ||
	    fstat(fdin, &st) == -1 || !S_ISREG(st.st_mode)) {
		if (!doall) {
			char *home = getenv("HOME");
			if (home == NULL || *home == '\0')
				errx(1, "cannot get home directory");
			if (!(chdir(home) == 0 &&
			    chdir(calendarHome) == 0 &&
			    (fdin = open(calendarFile, O_RDONLY)) != -1))
				errx(1, "no calendar file: \"%s\" or \"~/%s/%s\"",
				    calendarFile, calendarHome, calendarFile);
		}
	}

	if (pipe(pdes) == -1) {
		close(fdin);
		return (NULL);
	}
	switch (vfork()) {
	case -1:			/* error */
		(void)close(pdes[0]);
		(void)close(pdes[1]);
		close(fdin);
		return (NULL);
	case 0:
		dup2(fdin, STDIN_FILENO);
		/* child -- set stdout to pipe input */
		if (pdes[1] != STDOUT_FILENO) {
			(void)dup2(pdes[1], STDOUT_FILENO);
			(void)close(pdes[1]);
		}
		(void)close(pdes[0]);
		/*
		 * Set stderr to /dev/null.  Necessary so that cron does not
		 * wait for cpp to finish if it's running calendar -a.
		 */
		if (doall) {
			int fderr;
			fderr = open(_PATH_DEVNULL, O_WRONLY, 0);
			if (fderr == -1)
				_exit(0);
			(void)dup2(fderr, STDERR_FILENO);
			(void)close(fderr);
		}
		execl(_PATH_CPP, "cpp", "-traditional", "-undef", "-U__GNUC__",
#ifdef UNICODE
		    "-DUNICODE",
#endif
		    "-P", "-I.", _PATH_INCLUDE, NULL);
		warn(_PATH_CPP);
		_exit(1);
	}
	/* parent -- set stdin to pipe output */
	(void)dup2(pdes[0], STDIN_FILENO);
	(void)close(pdes[0]);
	(void)close(pdes[1]);

	/* not reading all calendar files, just set output to stdout */
	if (!doall)
		return (stdout);

	/* set output to a temporary file, so if no output don't send mail */
	return(tmpfile());
}

void
closecal(FILE *fp)
{
	struct stat sbuf;
	int nread, pdes[2], status;
	char buf[1024];
	pid_t pid = -1;

	if (!doall)
		return;

	(void)rewind(fp);
	if (fstat(fileno(fp), &sbuf) || !sbuf.st_size)
		goto done;
	if (pipe(pdes) == -1)
		goto done;
	switch ((pid = vfork())) {
	case -1:			/* error */
		(void)close(pdes[0]);
		(void)close(pdes[1]);
		goto done;
	case 0:
		/* child -- set stdin to pipe output */
		if (pdes[0] != STDIN_FILENO) {
			(void)dup2(pdes[0], STDIN_FILENO);
			(void)close(pdes[0]);
		}
		(void)close(pdes[1]);
		execl(_PATH_SENDMAIL, "sendmail", "-i", "-t", "-F",
		    "\"Reminder Service\"", (char *)NULL);
		warn(_PATH_SENDMAIL);
		_exit(1);
	}
	/* parent -- write to pipe input */
	(void)close(pdes[0]);

	header[1].iov_base = header[3].iov_base = pw->pw_name;
	header[1].iov_len = header[3].iov_len = strlen(pw->pw_name);
	writev(pdes[1], header, 8);
	while ((nread = read(fileno(fp), buf, sizeof(buf))) > 0)
		(void)write(pdes[1], buf, nread);
	(void)close(pdes[1]);
done:	(void)fclose(fp);
	if (pid != -1) {
		while (waitpid(pid, &status, 0) == -1) {
			if (errno != EINTR)
				break;
		}
	}
}


void
insert(struct event **head, struct event *cur_evt)
{
	struct event *tmp, *tmp2;

	if (*head) {
		/* Insert this one in order */
		tmp = *head;
		tmp2 = NULL;
		while (tmp->next &&
		    tmp->when <= cur_evt->when) {
			tmp2 = tmp;
			tmp = tmp->next;
		}
		if (tmp->when > cur_evt->when) {
			cur_evt->next = tmp;
			if (tmp2)
				tmp2->next = cur_evt;
			else
				*head = cur_evt;
		} else {
			cur_evt->next = tmp->next;
			tmp->next = cur_evt;
		}
	} else {
		*head = cur_evt;
		cur_evt->next = NULL;
	}
}
@


1.18
log
@parametrise anniversary handling
@
text
@d66 1
a66 1
__RCSID("$MirOS: src/usr.bin/calendar/io.c,v 1.17 2019/07/21 00:25:07 tg Exp $");
d323 6
a328 1
			} else if ((nlen = strlen(p)) < 7) {
d331 12
a342 5
			    isdigit(p[nlen - 2]) && isdigit(p[nlen - 3]) &&
			    isdigit(p[nlen - 4]) && isspace(p[nlen - 5]) &&
			    p[nlen - 6] == ',') {
				p[nlen - 6] = '\0';
				i = atoi(p + (nlen - 4));
@


1.17
log
@implement “YYYY, text” and “text, YYYY” entries as anniversaries
and display them specially
@
text
@d6 2
d66 1
a66 1
__RCSID("$MirOS: src/usr.bin/calendar/io.c,v 1.11 2019/07/20 23:07:33 tg Exp $");
d109 1
d188 34
d309 1
a309 1
		if (0) {
@


1.16
log
@fix indent, no change
@
text
@d102 5
d231 1
d272 29
a300 1
		(void)fprintf(fp, "%s%s\n", tmp->print_date, *(tmp->desc));
@


1.15
log
@fix indent, no change
@
text
@d221 23
a243 18
				cur_evt = (struct event *) malloc(sizeof(struct event));
				if (cur_evt == NULL)
					err(1, NULL);

				cur_evt->when = m->when;
				snprintf(cur_evt->print_date,
				    sizeof(cur_evt->print_date), "%s%c",
				    m->print_date, (var + m->var) ? '*' : ' ');
				if (ev1) {
					cur_evt->desc = ev1->desc;
					cur_evt->ldesc = NULL;
				} else {
					if (m->bodun && prefix) {
						int l1 = strlen(prefix);
						int l2 = strlen(p);
						int len = l1 + l2 + 2;
						if ((cur_evt->ldesc =
						    malloc(len)) == NULL)
d245 7
a251 12
						snprintf(cur_evt->ldesc, len,
						    "\t%s %s", prefix, p + 1);
					} else if ((cur_evt->ldesc =
					    strdup(p)) == NULL)
						err(1, NULL);
					cur_evt->desc = &(cur_evt->ldesc);
					ev1 = cur_evt;
				}
				insert(&events, cur_evt);
				foo = m;
				m = m->next;
				free(foo);
d254 1
a254 2
		}
		else if (printing) {
@


1.14
log
@more __CRAZY=Yes cleanliness
@
text
@d190 10
a199 9
			if (strncasecmp(buf, spev[i].name, spev[i].nlen) == 0 &&
			    (p - buf == spev[i].nlen) && buf[spev[i].nlen + 1]) {
				p++;
				if (spev[i].uname != NULL)
					free(spev[i].uname);
				if ((spev[i].uname = strdup(p)) == NULL)
					err(1, NULL);
				spev[i].ulen = strlen(p);
				i = NUMEV + 1;
d201 2
a202 3
			}
		if (i > NUMEV)
			continue;
@


1.12
log
@merge
@
text
@d99 1
a99 1
	struct event *events, *cur_evt, *ev1, *tmp;
d375 2
a376 1
	int pdes[2], fdin;
@


1.11
log
@begin making this __CRAZY clean
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.29 2005/04/15 14:28:56 otto Exp $	*/
a50 1
#include <tzfile.h>
d52 1
d64 1
a64 1
__RCSID("$MirOS: src/usr.bin/calendar/io.c,v 1.10 2016/01/02 21:33:08 tg Exp $");
d67 6
a72 6
	{"From: ", 6},
	{NULL, 0},
	{" (Reminder Service)\nTo: ", 24},
	{NULL, 0},
	{"\nSubject: ", 10},
	{NULL, 0},
d74 3
a76 3
	{"'s Calendar\nMIME-Version: 1.0\n"
	 "Content-type: text/plain; charset=utf-8\n"
	 "Precedence: bulk\n\n", 88},
d78 1
a78 1
	{"'s Calendar\nPrecedence: bulk\n\n",  30},
d80 1
d142 1
a142 2
				if (prefix)
					free(prefix);
d182 1
a182 2
			if (prefix)
				free(prefix);
d273 1
a273 2
		if (tmp->ldesc)
			free(tmp->ldesc);
d388 1
a388 1
				errx(1, "no calendar file: ``%s'' or ``~/%s/%s''",
d393 2
a394 1
	if (pipe(pdes) < 0)
d396 1
d401 1
d450 1
d458 1
a458 1
	if (pipe(pdes) < 0)
d460 1
a460 1
	switch (vfork()) {
d482 1
a482 1
	writev(pdes[1], header, 7);
d487 6
a492 2
	while (wait(&status) >= 0)
		;
@


1.10
log
@remove #ifndef __MirBSD__ before setlocale(); related changes
@
text
@d54 4
d64 1
a64 1
__RCSID("$MirOS: src/usr.bin/calendar/io.c,v 1.9 2009/04/16 12:17:46 tg Exp $");
d66 1
a66 1
struct iovec header[] = {
d283 1
a283 3
getfield(p, endp, flags)
	char *p, **endp;
	int *flags;
d444 1
a444 2
closecal(fp)
	FILE *fp;
d491 1
a491 3
insert(head, cur_evt)
	struct event **head;
	struct event *cur_evt;
@


1.9
log
@revert to r1.7 – works with GNU cpp and Reiser CCCP
pcc cpp can FOAD ☺
@
text
@d60 1
a60 1
__RCSID("$MirOS: src/usr.bin/calendar/io.c,v 1.7 2007/08/24 14:20:08 tg Exp $");
a129 1
#ifndef __MirBSD__
a130 1
#endif
@


1.8
log
@cpp
@
text
@d422 1
a422 1
		execl(_PATH_CPP, "cpp", "-t",
@


1.7
log
@• add -std=gnu99 to default CFLAGS
• first round of assorted fixes
@
text
@d60 1
a60 1
__RCSID("$MirOS: src/usr.bin/calendar/io.c,v 1.6 2007/07/05 23:09:38 tg Exp $");
d422 1
a422 1
		execl(_PATH_CPP, "cpp", "-traditional", "-undef", "-U__GNUC__",
@


1.6
log
@• #ifdef __MirBSD__
  do not use setlocale() and nl_langinfo(), hardcode it
  #endif
• rcs ids

should greatly reduce space usage of ramdisc
@
text
@d43 1
d60 1
a60 1
__RCSID("$MirOS: src/usr.bin/calendar/io.c,v 1.5 2007/01/05 03:41:16 tg Exp $");
d148 2
a149 1
			char *src = buf, *dst = buf2;
@


1.5
log
@correctly reset the бодун (bodun, "hangover") when
leaving soviet union territory
@
text
@d59 1
a59 1
__RCSID("$MirOS: src/usr.bin/calendar/io.c,v 1.4 2006/11/17 02:57:21 tg Exp $");
d129 1
d131 1
@


1.4
log
@don't leak iconv fds ☺
@
text
@d59 1
a59 1
__RCSID("$MirOS: src/usr.bin/calendar/io.c,v 1.3 2006/11/17 02:48:09 tg Exp $");
d140 1
a140 1
				bodun_maybe = 0;
@


1.3
log
@hack utf-8 ;) UTSL for more info
@
text
@d59 1
a59 1
__RCSID("$MirOS: src/usr.bin/calendar/io.c,v 1.2 2006/11/17 02:06:07 tg Exp $");
d117 2
@


1.2
log
@whitespace
@
text
@d42 3
d59 1
a59 1
__RCSID("$MirOS$");
d68 5
d74 1
d77 3
d90 3
d101 1
d113 14
d140 15
a154 1
		} else if (strncmp(buf, "CALENDAR=", 9) == 0) {
d255 3
d417 4
a420 1
		    "-P", "-I.", _PATH_INCLUDE, (char *)NULL);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.28 2004/12/10 15:31:01 mickey Exp $	*/
a31 14
#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1989, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)calendar.c  8.3 (Berkeley) 3/25/94";
#else
static const char rcsid[] = "$OpenBSD: io.c,v 1.28 2004/12/10 15:31:01 mickey Exp $";
#endif
#endif /* not lint */

a34 1
#include <sys/types.h>
d53 4
d167 1
a167 1
				
d306 1
a306 1
		*flags |= F_SPECIAL;	
d357 1
a357 1
		/* 
d369 2
a370 2
		execl(_PATH_CPP, "cpp", "-traditional", "-P", "-I.",
		    _PATH_INCLUDE, (char *)NULL);
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@some more updates/fixes from obsd
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.29 2005/04/15 14:28:56 otto Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: io.c,v 1.29 2005/04/15 14:28:56 otto Exp $";
d380 2
a381 2
		execl(_PATH_CPP, "cpp", "-traditional", "-undef", "-U__GNUC__",
		    "-P", "-I.", _PATH_INCLUDE, (char *)NULL);
@


1.1.1.3
log
@backport some fixes from OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.29+backports from 1.49 2005/04/15 14:28:56 otto Exp $	*/
d32 15
d62 1
a63 1
#include <limits.h>
d70 7
a76 8
	{ "From: ", 6 },
	{ NULL, 0 },
	{ " (Reminder Service)\nTo: ", 24 },
	{ NULL, 0 },
	{ "\nSubject: ", 10 },
	{ NULL, 0 },
	{ "'s Calendar\nPrecedence: bulk\n",  29 },
	{ "Auto-Submitted: auto-generated\n\n", 32 },
d115 2
a116 1
				free(prefix);
d141 2
a142 1
			free(prefix);
d230 2
a231 1
		free(tmp->ldesc);
d239 3
a241 1
getfield(char *p, char **endp, int *flags)
d348 1
a348 1
				errx(1, "no calendar file: \"%s\" or \"~/%s/%s\"",
d353 1
a353 2
	if (pipe(pdes) == -1) {
		close(fdin);
a354 1
	}
a358 1
		close(fdin);
d368 1
a368 1
		/*
d399 2
a400 1
closecal(FILE *fp)
a404 1
	pid_t pid = -1;
d412 1
a412 1
	if (pipe(pdes) == -1)
d414 1
a414 1
	switch ((pid = vfork())) {
d436 1
a436 1
	writev(pdes[1], header, 8);
d441 2
a442 6
	if (pid != -1) {
		while (waitpid(pid, &status, 0) == -1) {
			if (errno != EINTR)
				break;
		}
	}
d447 3
a449 1
insert(struct event **head, struct event *cur_evt)
@


