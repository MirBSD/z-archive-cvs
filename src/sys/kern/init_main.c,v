head	1.40;
access;
symbols
	tg-beforemerge-ksrc10:1.1.1.2
	MIRBSD_10:1.19.0.2
	MIRBSD_10_BASE:1.19
	MIRBSD_9_BASE:1.9
	MIRBSD_8:1.5.0.2
	MIRBSD_8_BASE:1.5
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.40
date	2019.01.05.13.30.53;	author tg;	state Exp;
branches;
next	1.39;
commitid	1005C30B1A05E192EA5;

1.39
date	2018.01.07.23.27.34;	author tg;	state Exp;
branches;
next	1.38;
commitid	1005A52ACF9654215C5;

1.38
date	2017.08.07.20.18.23;	author tg;	state Exp;
branches;
next	1.37;
commitid	1005988C69344442E37;

1.37
date	2017.01.29.00.51.07;	author tg;	state Exp;
branches;
next	1.36;
commitid	100588D3C8F09DC1F20;

1.36
date	2016.01.02.20.05.09;	author tg;	state Exp;
branches;
next	1.35;
commitid	10056882D871C1C3E41;

1.35
date	2015.01.02.13.54.21;	author tg;	state Exp;
branches;
next	1.34;
commitid	10054A6A31E3A41516F;

1.34
date	2014.01.11.18.16.16;	author tg;	state Exp;
branches;
next	1.33;
commitid	10052D18A8038CC3F4D;

1.33
date	2014.01.04.20.25.00;	author tg;	state Exp;
branches;
next	1.32;
commitid	10052C86E2F00C31DB5;

1.32
date	2013.01.01.17.31.04;	author tg;	state Exp;
branches;
next	1.31;
commitid	10050E31D6B7FB977FF;

1.31
date	2012.01.14.18.59.29;	author tg;	state Exp;
branches;
next	1.30;
commitid	1004F11D0A671854233;

1.30
date	2011.02.19.14.41.37;	author tg;	state Exp;
branches;
next	1.29;
commitid	1004D5FD6AD4C707315;

1.29
date	2011.01.03.17.49.35;	author tg;	state Exp;
branches;
next	1.28;
commitid	1004D220C4445D53F23;

1.28
date	2010.09.19.18.55.39;	author tg;	state Exp;
branches;
next	1.27;
commitid	1004C965C8F46717878;

1.27
date	2010.09.12.18.20.01;	author tg;	state Exp;
branches;
next	1.26;
commitid	1004C8D19CE4D7E4CD9;

1.26
date	2010.01.06.18.52.19;	author tg;	state Exp;
branches;
next	1.25;
commitid	1004B44DBF909E317C9;

1.25
date	2009.11.09.19.43.46;	author tg;	state Exp;
branches;
next	1.24;
commitid	1004AF870EF5AE8038B;

1.24
date	2009.02.22.17.06.27;	author tg;	state Exp;
branches;
next	1.23;
commitid	10049A185F539B9D87C;

1.23
date	2009.01.02.05.16.32;	author tg;	state Exp;
branches;
next	1.22;
commitid	100495DA33F62ABDC14;

1.22
date	2008.11.08.23.04.21;	author tg;	state Exp;
branches;
next	1.21;
commitid	10049161AB22DF5DFC5;

1.21
date	2008.06.13.14.00.05;	author tg;	state Exp;
branches;
next	1.20;
commitid	10048527D4D464F8F7D;

1.20
date	2008.04.09.05.45.42;	author tg;	state Exp;
branches;
next	1.19;
commitid	10047FC57D909BED61F;

1.19
date	2008.02.24.12.47.19;	author tg;	state Exp;
branches;
next	1.18;
commitid	10047C167561750E7A3;

1.18
date	2007.09.28.18.44.00;	author tg;	state Exp;
branches;
next	1.17;
commitid	10046FD4B7B40BB609F;

1.17
date	2007.09.02.18.15.23;	author tg;	state Exp;
branches;
next	1.16;
commitid	10046DAFDA42175DFC7;

1.16
date	2007.07.21.10.42.55;	author tg;	state Exp;
branches;
next	1.15;
commitid	10046A1E33B3A9C2EC3;

1.15
date	2007.03.02.03.13.28;	author tg;	state Exp;
branches;
next	1.14;
commitid	10045E7958604F58BEB;

1.14
date	2006.12.31.17.03.35;	author tg;	state Exp;
branches;
next	1.13;
commitid	1004597ED530A62698E;

1.13
date	2006.10.08.00.24.44;	author tg;	state Exp;
branches;
next	1.12;
commitid	100452845255DA75FEF;

1.12
date	2006.08.22.21.51.39;	author tg;	state Exp;
branches;
next	1.11;
commitid	10044EB7C746813A3BA;

1.11
date	2006.08.19.15.51.47;	author tg;	state Exp;
branches;
next	1.10;
commitid	10044E7338B699E2713;

1.10
date	2006.08.19.00.05.50;	author tg;	state Exp;
branches;
next	1.9;
commitid	10044E655EB25A87BE4;

1.9
date	2006.06.16.18.43.32;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004492FB84114AC13E;

1.8
date	2006.05.26.12.04.59;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004476EF36CAFEBABE;

1.7
date	2006.03.29.21.35.40;	author tg;	state Exp;
branches;
next	1.6;
commitid	100442AFDBF671C210A;

1.6
date	2006.01.01.20.44.58;	author tg;	state Exp;
branches;
next	1.5;
commitid	10043B83F5E626F777F;

1.5
date	2005.07.04.03.36.33;	author tg;	state Exp;
branches
	1.5.2.1;
next	1.4;
commitid	27eb42c8ae53acb0;

1.4
date	2005.05.15.01.15.31;	author tg;	state Exp;
branches;
next	1.3;
commitid	4d164286a2913a37;

1.3
date	2005.03.14.22.05.04;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.06.21.28.00;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.28.50;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.5.2.1
date	2006.01.02.03.29.12;	author tg;	state Exp;
branches;
next	;
commitid	10043B89E1E59C4A1A8;

1.1.1.1
date	2005.02.05.17.28.50;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.07.04.02.59.38;	author tg;	state Exp;
branches;
next	;
commitid	5e8342c8a625da8f;


desc
@@


1.40
log
@2019
@
text
@/**	$MirOS: src/sys/kern/init_main.c,v 1.39 2018/01/07 23:27:34 tg Exp $ */
/*	$OpenBSD: init_main.c,v 1.120 2004/11/23 19:08:55 miod Exp $	*/
/*	$NetBSD: init_main.c,v 1.84.4.1 1996/06/02 09:08:06 mrg Exp $	*/
/*	$OpenBSD: kern_xxx.c,v 1.9 2003/08/15 20:32:18 tedu Exp $	*/
/*	$NetBSD: kern_xxx.c,v 1.32 1996/04/22 01:38:41 christos Exp $	*/

/*
 * Copyright (c) 1990-2002, 2003, 2004, 2005, 2006, 2011, 2014
 *	Thorsten "mirabilos" Glaser <tg@@mirbsd.org>
 * Copyright (c) 1995 Christopher G. Demetriou.  All rights reserved.
 * Copyright (c) 1982, 1986, 1989, 1991, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)init_main.c	8.9 (Berkeley) 1/21/94
 */

#include <sys/param.h>
#include <sys/filedesc.h>
#include <sys/file.h>
#include <sys/errno.h>
#include <sys/exec.h>
#include <sys/kernel.h>
#include <sys/kthread.h>
#include <sys/mount.h>
#include <sys/proc.h>
#include <sys/resourcevar.h>
#include <sys/signalvar.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/vnode.h>
#include <sys/tty.h>
#include <sys/conf.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/socketvar.h>
#include <sys/lockf.h>
#include <sys/protosw.h>
#include <sys/reboot.h>
#include <sys/user.h>
#ifdef	SYSVSHM
#include <sys/shm.h>
#endif
#ifdef	SYSVSEM
#include <sys/sem.h>
#endif
#ifdef	SYSVMSG
#include <sys/msg.h>
#endif
#include <sys/domain.h>
#include <sys/mbuf.h>
#include <sys/pipe.h>

#include <sys/syscall.h>
#include <sys/syscallargs.h>

#include <dev/rndvar.h>

#include <ufs/ufs/quota.h>

#include <machine/cpu.h>

#include <uvm/uvm.h>

#include <net/if.h>
#include <net/raw_cb.h>

#if defined(CRYPTO)
#include <crypto/cryptodev.h>
#include <crypto/cryptosoft.h>
#endif
#include <crypto/randimpl.h>

#if defined(NFSSERVER) || defined(NFSCLIENT)
extern void nfs_init(void);
#endif

/* used by kernfs */
const char	copyright[] =
"Copyright (c) 1982, 1986, 1989, 1991, 1993\n"
"\tThe Regents of the University of California.  All rights reserved.\n"
"Copyright (c) 1995-2004 OpenBSD. All rights reserved.  http://www.OpenBSD.org\n"
"Copyright (c) 2002-2019 MirBSD and contributors.  http://mirbsd.de\n";

/* Components of the first process -- never freed. */
struct	session session0;
struct	pgrp pgrp0;
struct	proc proc0;
struct	pcred cred0;
struct	plimit limit0;
struct	vmspace vmspace0;
struct	sigacts sigacts0;
#ifndef curproc
struct	proc *curproc;
#endif
struct	proc *initproc;

int	cmask = CMASK;
extern	struct user *proc0paddr;
extern volatile int ticks;	/* XXX should move to sys/x*.h */

void	(*md_diskconf)(void) = NULL;
struct	vnode *rootvp, *swapdev_vp;
int	boothowto;
struct	timeval boottime;
struct	timeval runtime;
__volatile int start_init_exec;		/* semaphore for start_init() */

/* XXX return int so gcc -Werror won't complain */
int	main(void *);
void	check_console(struct proc *);
void	start_init(void *);
void	start_cleaner(void *);
void	start_update(void *);
void	start_reaper(void *);
void	start_crypto(void *);
void	init_exec(void);
void	init_ssp(void);
void	kqueue_init(void);

extern char sigcode[], esigcode[];
#ifdef	SYSCALL_DEBUG
extern char *syscallnames[];
#endif

struct emul emul_native = {
	"native",
	NULL,
	sendsig,
	SYS_syscall,
	SYS_MAXSYSCALL,
	sysent,
#ifdef	SYSCALL_DEBUG
	syscallnames,
#else
	NULL,
#endif
	0,
	copyargs,
	setregs,
	NULL,
	sigcode,
	esigcode,
	EMUL_ENABLED | EMUL_NATIVE,
};


/*
 * System startup; initialise the world, create process 0, mount root
 * filesystem, and fork to create init and pagedaemon.  Most of the
 * hard work is done in the lower-level initialization routines including
 * startup(), which does memory initialization and autoconfiguration.
 */
int
main(/* XXX should go away */ void *framep)
{
	struct proc *p;
	struct pdevinit *pdev;
	quad_t lim;
	int s, i;
	extern struct pdevinit pdevinit[];
	extern void scheduler_start(void);
	extern void disk_init(void);
	extern void endtsleep(void *);
	extern void realitexpire(void *);

	/*
	 * Initialise the current process pointer (curproc) before
	 * any possible traps/probes to simplify trap processing.
	 */
	curproc = p = &proc0;

	/*
	 * Initialise timeouts.
	 */
	timeout_startup();

	/*
	 * Attempt to find console and initialise
	 * in case of early panic or other messages.
	 */
	config_init();		/* init autoconfiguration data structures */
	consinit();
	printf("%s\n", copyright);
	rnd_lopool_addv(ticks);

	uvm_init();
	disk_init();		/* must come before autoconfiguration */
	tty_init();		/* initialise ttys */
	cpu_startup();

	/*
	 * Initialise mbufs.  Do this now because we might attempt to
	 * allocate mbufs or mbuf clusters during autoconfiguration.
	 */
	mbinit();

	/* Initalise sockets. */
	soinit();

	/* Initialise sysctls (must be done before any processes run) */
	sysctl_init();

	/*
	 * Initialise process and pgrp structures.
	 */
	procinit();

	/* Initialise file locking. */
	lf_init();

	/*
	 * Initialise filedescriptors.
	 */
	filedesc_init();

	/*
	 * Initialise pipes.
	 */
	pipe_init();

	/*
	 * Initialise kqueues.
	 */
	kqueue_init();

	/*
	 * Create process 0 (the swapper).
	 */
	LIST_INSERT_HEAD(&allproc, p, p_list);
	p->p_pgrp = &pgrp0;
	LIST_INSERT_HEAD(PIDHASH(0), p, p_hash);
	LIST_INSERT_HEAD(PGRPHASH(0), &pgrp0, pg_hash);
	LIST_INIT(&pgrp0.pg_members);
	LIST_INSERT_HEAD(&pgrp0.pg_members, p, p_pglist);

	pgrp0.pg_session = &session0;
	session0.s_count = 1;
	session0.s_leader = p;

	p->p_flag = P_INMEM | P_SYSTEM | P_NOCLDWAIT;
	p->p_stat = SRUN;
	p->p_nice = NZERO;
	p->p_emul = &emul_native;
	bcopy("swapper", p->p_comm, sizeof ("swapper"));

	/* Init timeouts. */
	timeout_set(&p->p_sleep_to, endtsleep, p);
	timeout_set(&p->p_realit_to, realitexpire, p);

	/* Create credentials. */
	cred0.p_refcnt = 1;
	p->p_cred = &cred0;
	p->p_ucred = crget();
	p->p_ucred->cr_ngroups = 1;	/* group 0 */

	/* Initialise signal state for process 0. */
	signal_init();
	p->p_sigacts = &sigacts0;
	siginit(p);

	/* Create the file descriptor table. */
	p->p_fd = fdinit(NULL);

	/* Create the limits structures. */
	p->p_limit = &limit0;
	for (i = 0; i < sizeof(p->p_rlimit)/sizeof(p->p_rlimit[0]); i++)
		limit0.pl_rlimit[i].rlim_cur =
		    limit0.pl_rlimit[i].rlim_max = RLIM_INFINITY;
	limit0.pl_rlimit[RLIMIT_NOFILE].rlim_cur = NOFILE;
	limit0.pl_rlimit[RLIMIT_NOFILE].rlim_max = MIN(NOFILE_MAX,
	    (maxfiles - NOFILE > NOFILE) ?  maxfiles - NOFILE : NOFILE);
	limit0.pl_rlimit[RLIMIT_NPROC].rlim_cur = MAXUPRC;
	lim = ptoa(uvmexp.free);
	limit0.pl_rlimit[RLIMIT_RSS].rlim_max = lim;
	limit0.pl_rlimit[RLIMIT_MEMLOCK].rlim_max = lim;
	limit0.pl_rlimit[RLIMIT_MEMLOCK].rlim_cur = lim / 3;
	limit0.p_refcnt = 1;

	/* Allocate a prototype map so we have something to fork. */
	uvmspace_init(&vmspace0, pmap_kernel(), round_page(VM_MIN_ADDRESS),
	    trunc_page(VM_MAX_ADDRESS), TRUE);
	p->p_vmspace = &vmspace0;

	p->p_addr = proc0paddr;				/* XXX */

	/*
	 * We continue to place resource usage info in the
	 * user struct so they're pageable.
	 */
	p->p_stats = &p->p_addr->u_stats;

	/*
	 * Charge root for one process.
	 */
	(void)chgproccnt(0, 1);

	/* Initialise run queues */
	rqinit();

	/* Configure the devices */
	cpu_configure();

	/* Configure virtual memory system, set vm rlimits. */
	uvm_init_limits(p);

	/* Initialise the filesystems. */
#if defined(NFSSERVER) || defined(NFSCLIENT)
	nfs_init();			/* initialise server/shared data */
#endif
	vfsinit();

	/* Start real time and statistics clocks. */
	initclocks();

#ifdef	SYSVSHM
	/* Initialise System V style shared memory. */
	shminit();
#endif

#ifdef	SYSVSEM
	/* Initialise System V style semaphores. */
	seminit();
#endif

#ifdef	SYSVMSG
	/* Initialise System V style message queues. */
	msginit();
#endif

#ifdef __sparc__
	/* insert a little delay here to let things settle down */
	delay(10000);
#endif
	/* Attach pseudo-devices. */
	randomattach();
	for (pdev = pdevinit; pdev->pdev_attach != NULL; pdev++)
		if (pdev->pdev_count > 0)
			(*pdev->pdev_attach)(pdev->pdev_count);
	rnd_lopool_addv(ticks);

#ifdef	CRYPTO
	swcr_init();
#endif	/* CRYPTO */

	/*
	 * Initialise protocols.  Block reception of incoming packets
	 * until everything is ready.
	 */
	s = splimp();
	ifinit();
	domaininit();
	if_attachdomain();
	splx(s);

	/* initialise stack protector */
	init_ssp();

	/* init exec and emul */
	init_exec();

	/* Start the scheduler */
	scheduler_start();

	/*
	 * Create process 1 (init(8)).  We do this now, as Unix has
	 * historically had init be process 1, and changing this would
	 * probably upset a lot of people.
	 *
	 * Note that process 1 won't immediately exec init(8), but will
	 * wait for us to inform it that the root filesystem has been
	 * mounted.
	 */
	if (fork1(p, SIGCHLD, FORK_FORK, NULL, 0, start_init, NULL, NULL,
	    &initproc))
		panic("fork init");

	/*
	 * Create any kernel threads who's creation was deferred because
	 * initproc had not yet been created.
	 */
	kthread_run_deferred_queue();

	/*
	 * Now that device driver threads have been created, wait for
	 * them to finish any deferred autoconfiguration.  Note we don't
	 * need to lock this semaphore, since we haven't booted any
	 * secondary processors, yet.
	 */
	while (config_pending)
		(void) tsleep((void *)&config_pending, PWAIT, "cfpend", 0);

	dostartuphooks();

	/* Configure root/swap devices */
	if (md_diskconf)
		(*md_diskconf)();

	/* Mount the root filesystem. */
	if (vfs_mountroot())
		panic("cannot mount root");
	CIRCLEQ_FIRST(&mountlist)->mnt_flag |= MNT_ROOTFS;

	/* Get the vnode for '/'.  Set p->p_fd->fd_cdir to reference it. */
	if (VFS_ROOT(mountlist.cqh_first, &rootvnode))
		panic("cannot find root vnode");
	p->p_fd->fd_cdir = rootvnode;
	VREF(p->p_fd->fd_cdir);
	VOP_UNLOCK(rootvnode, 0, p);
	p->p_fd->fd_rdir = NULL;

	uvm_swap_init();

	/*
	 * Now that root is mounted, we can fixup initproc's CWD
	 * info.  All other processes are kthreads, which merely
	 * share proc0's CWD info.
	 */
	initproc->p_fd->fd_cdir = rootvnode;
	VREF(initproc->p_fd->fd_cdir);
	initproc->p_fd->fd_rdir = NULL;

	/*
	 * Now can look at time, having had a chance to verify the time
	 * from the filesystem.  Reset p->p_rtime as it may have been
	 * munched in mi_switch() after the time got set.
	 */
	runtime = mono_time = boottime = time;
	LIST_FOREACH(p, &allproc, p_list) {
		p->p_stats->p_start = boottime;
		p->p_rtime.tv_sec = p->p_rtime.tv_usec = 0;
	}

	/* Create the pageout daemon kernel thread. */
	if (kthread_create(uvm_pageout, NULL, NULL, "pagedaemon"))
		panic("fork pagedaemon");

	/* Create the reaper daemon kernel thread. */
	if (kthread_create(start_reaper, NULL, NULL, "reaper"))
		panic("fork reaper");

	/* Create the cleaner daemon kernel thread. */
	if (kthread_create(start_cleaner, NULL, NULL, "cleaner"))
		panic("fork cleaner");

	/* Create the update daemon kernel thread. */
	if (kthread_create(start_update, NULL, NULL, "update"))
		panic("fork update");

	/* Create the aiodone daemon kernel thread. */ 
	if (kthread_create(uvm_aiodone_daemon, NULL, NULL, "aiodoned"))
		panic("fork aiodoned");

#ifdef CRYPTO
	/* Create the crypto kernel thread. */
	if (kthread_create(start_crypto, NULL, NULL, "crypto"))
		panic("crypto thread");
#endif	/* CRYPTO */

#if defined(I586_CPU) || defined(I686_CPU)
	/* this adds the TSC too, if pentium_mhz!=0 */
	rnd_lopool_add(&pentium_mhz, sizeof(pentium_mhz));
#endif

	randompid = 1;

	/*
	 * Okay, now we can let init(8) exec!  It's off to userland!
	 */
	start_init_exec = 1;
	wakeup((void *)&start_init_exec);

	/* The scheduler is an infinite loop. */
	uvm_scheduler();
	/* NOTREACHED */
}

/*
 * List of paths to try when searching for "init".
 */
static char *initpaths[] = {
	"/sbin/init",
	"/sbin/oinit",
	"/sbin/init.bak",
	NULL,
};

void
check_console(struct proc *p)
{
	struct nameidata nd;
	int error;

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_SYSSPACE, "/dev/console", p);
	error = namei(&nd);
	if (error) {
		if (error == ENOENT)
			printf("warning: /dev/console does not exist\n");
		else
			printf("warning: /dev/console error %d\n", error);
	} else
		vrele(nd.ni_vp);
}

/*
 * Start the initial user process; try exec'ing each pathname in "initpaths".
 * The program is invoked with one argument containing the boot flags.
 */
void
start_init(void *arg)
{
	struct proc *p = arg;
	vaddr_t addr;
	struct sys_execve_args /* {
		syscallarg(const char *) path;
		syscallarg(char *const *) argp;
		syscallarg(char *const *) envp;
	} */ args;
	int options, error;
	long i;
	register_t retval[2];
	char flags[4], *flagsp;
	char **pathp, *path, *ucp, **uap, *arg0, *arg1 = NULL;

	/*
	 * Now in process 1.
	 */

	/*
	 * Wait for main() to tell us that it's safe to exec.
	 */
	while (start_init_exec == 0)
		(void) tsleep((void *)&start_init_exec, PWAIT, "initexec", 0);

	check_console(p);

	/*
	 * Need just enough stack to hold the faked-up "execve()" arguments.
	 */
#ifdef	MACHINE_STACK_GROWS_UP
	addr = USRSTACK;
#else
	addr = USRSTACK - PAGE_SIZE;
#endif
	if (uvm_map(&p->p_vmspace->vm_map, &addr, PAGE_SIZE,
	    NULL, UVM_UNKNOWN_OFFSET, 0,
	    UVM_MAPFLAG(UVM_PROT_RW, UVM_PROT_ALL, UVM_INH_COPY,
	    UVM_ADV_NORMAL, UVM_FLAG_FIXED|UVM_FLAG_OVERLAY|UVM_FLAG_COPYONW)))
		panic("init: couldn't allocate argument space");
	p->p_vmspace->vm_maxsaddr = (caddr_t)addr;

	for (pathp = &initpaths[0]; (path = *pathp) != NULL; pathp++) {
#ifdef	MACHINE_STACK_GROWS_UP
		ucp = (char *)addr;
#else
		ucp = (char *)(addr + PAGE_SIZE);
#endif
		/*
		 * Construct the boot flag argument.
		 */
		flagsp = flags;
		*flagsp++ = '-';
		options = 0;

		if (boothowto & RB_SINGLE) {
			*flagsp++ = 's';
			options = 1;
		}
#ifdef	notyet
		if (boothowto & RB_FASTBOOT) {
			*flagsp++ = 'f';
			options = 1;
		}
#endif

		/*
		 * Move out the flags (arg 1), if necessary.
		 */
		if (options != 0) {
			*flagsp++ = '\0';
			i = flagsp - flags;
#ifdef	DEBUG
			printf("init: copying out flags `%s' %d\n", flags, i);
#endif
#ifdef	MACHINE_STACK_GROWS_UP
			arg1 = ucp;
			(void)copyout((caddr_t)flags, (caddr_t)ucp, i);
			ucp += i;
#else
			(void)copyout((caddr_t)flags, (caddr_t)(ucp -= i), i);
			arg1 = ucp;
#endif
		}

		/*
		 * Move out the file name (also arg 0).
		 */
		i = strlen(path) + 1;
#ifdef	DEBUG
		printf("init: copying out path `%s' %d\n", path, i);
#endif
#ifdef	MACHINE_STACK_GROWS_UP
		arg0 = ucp;
		(void)copyout((caddr_t)path, (caddr_t)ucp, i);
		ucp += i;
		ucp = (caddr_t)ALIGN((u_long)ucp);
		uap = (char **)ucp + 3;
#else
		(void)copyout((caddr_t)path, (caddr_t)(ucp -= i), i);
		arg0 = ucp;
		uap = (char **)((u_long)ucp & ~ALIGNBYTES);
#endif

		/*
		 * Move out the arg pointers.
		 */
		i = 0;
		copyout(&i, (caddr_t)--uap, sizeof(register_t)); /* terminator */
		if (options != 0)
			copyout(&arg1, (caddr_t)--uap, sizeof(register_t));
		copyout(&arg0, (caddr_t)--uap, sizeof(register_t));

		/*
		 * Point at the arguments.
		 */
		SCARG(&args, path) = arg0;
		SCARG(&args, argp) = uap;
		SCARG(&args, envp) = NULL;

		/*
		 * Now try to exec the program.  If can't for any reason
		 * other than it doesn't exist, complain.
		 */
		if ((error = sys_execve(p, &args, retval)) == 0)
			return;
		if (error != ENOENT)
			printf("exec %s: error %d\n", path, error);
	}
	printf("init: not found\n");
	panic("no init");
}

void
start_update(void *arg)
{
	sched_sync(curproc);
	/* NOTREACHED */
}

void
start_cleaner(void *arg)
{
	buf_daemon(curproc);
	/* NOTREACHED */
}

void
start_reaper(void *arg)
{
	reaper();
	/* NOTREACHED */
}

#ifdef	CRYPTO
void
start_crypto(void *arg)
{
	crypto_thread();
	/* NOTREACHED */
}
#endif	/* CRYPTO */

/* ARGSUSED */
int
sys_reboot(struct proc *p, void *v, register_t *retval)
{
	struct sys_reboot_args /* {
		syscallarg(int) opt;
	} */ *uap = v;
	int error;

	if ((error = suser(p, 0)) != 0)
		return (error);
	rnd_flush();
	boot(SCARG(uap, opt));
	return (0);
}

#ifdef SYSCALL_DEBUG
#define	SCDEBUG_CALLS		0x0001	/* show calls */
#define	SCDEBUG_RETURNS		0x0002	/* show returns */
#define	SCDEBUG_ALL		0x0004	/* even syscalls that are implemented */
#define	SCDEBUG_SHOWARGS	0x0008	/* show arguments to calls */

int	scdebug = SCDEBUG_CALLS|SCDEBUG_RETURNS|SCDEBUG_SHOWARGS;

void
scdebug_call(struct proc *p, register_t code, register_t args[])
{
	struct sysent *sy;
	struct emul *em;
	int i;

	if (!(scdebug & SCDEBUG_CALLS))
		return;

	em = p->p_emul;
	sy = &em->e_sysent[code];
	if (!(scdebug & SCDEBUG_ALL || code < 0 || code >= em->e_nsysent ||
	     sy->sy_call == sys_nosys))
		return;

	printf("proc %d (%s): %s num ", p->p_pid, p->p_comm, em->e_name);
	if (code < 0 || code >= em->e_nsysent)
		printf("OUT OF RANGE (%d)", code);
	else {
		printf("%d call: %s", code, em->e_syscallnames[code]);
		if (scdebug & SCDEBUG_SHOWARGS) {
			printf("(");
			for (i = 0; i < sy->sy_argsize / sizeof(register_t);
			    i++)
				printf("%s0x%lx", i == 0 ? "" : ", ",
				    (long)args[i]);
			printf(")");
		}
	}
	printf("\n");
}

void
scdebug_ret(p, code, error, retval)
	struct proc *p;
	register_t code;
	int error;
	register_t retval[];
{
	struct sysent *sy;
	struct emul *em;

	if (!(scdebug & SCDEBUG_RETURNS))
		return;

	em = p->p_emul;
	sy = &em->e_sysent[code];
	if (!(scdebug & SCDEBUG_ALL || code < 0 || code >= em->e_nsysent ||
	    sy->sy_call == sys_nosys))
		return;

	printf("proc %d (%s): %s num ", p->p_pid, p->p_comm, em->e_name);
	if (code < 0 || code >= em->e_nsysent)
		printf("OUT OF RANGE (%d)", code);
	else
		printf("%d ret: err = %d, rv = 0x%lx,0x%lx", code,
		    error, (long)retval[0], (long)retval[1]);
	printf("\n");
}
#endif /* SYSCALL_DEBUG */
@


1.39
log
@2018
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.38 2017/08/07 20:18:23 tg Exp $ */
d111 1
a111 1
"Copyright (c) 2002-2018 MirBSD and contributors.  http://mirbsd.de\n";
@


1.38
log
@filesystem
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.37 2017/01/29 00:51:07 tg Exp $ */
d111 1
a111 1
"Copyright (c) 2002-2017 The MirOS Project and contributors.  http://mirbsd.de\n";
@


1.37
log
@2017
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.35 2015/01/02 13:54:21 tg Exp $ */
d335 1
a335 1
	/* Initialise the file systems. */
d399 1
a399 1
	 * wait for us to inform it that the root file system has been
d427 1
a427 1
	/* Mount the root file system. */
d453 1
a453 1
	 * from the file system.  Reset p->p_rtime as it may have been
@


1.36
log
@2016
@
text
@d111 1
a111 1
"Copyright (c) 2002-2016 The MirOS Project and contributors.  http://mirbsd.de\n";
@


1.35
log
@2015; another year of the rolling release (and yes, new snapshots will be coming soonish)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.34 2014/01/11 18:16:16 tg Exp $ */
d111 1
a111 1
"Copyright (c) 2002-2015 The MirOS Project and contributors.  http://mirbsd.de\n";
@


1.34
log
@there is precisely zero reason to use random()/srandom() even in the kernel (since we initialise arc4random statically)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.33 2014/01/04 20:25:00 tg Exp $ */
d111 1
a111 1
"Copyright (c) 2002-2014 The MirOS Project and contributors.  http://mirbsd.de\n";
@


1.33
log
@2014
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.32 2013/01/01 17:31:04 tg Exp $ */
d8 1
a8 1
 * Copyright (c) 1990-2002, 2003, 2004, 2005, 2006, 2011
a492 1
	srandom(arc4random());
@


1.32
log
@2013
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.31 2012/01/14 18:59:29 tg Exp $ */
d111 1
a111 1
"Copyright (c) 2002-2013 The MirOS Project and contributors.  http://mirbsd.de\n";
@


1.31
log
@© 2012 (in most places where it’s appropriate)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.30 2011/02/19 14:41:37 tg Exp $ */
d111 1
a111 1
"Copyright (c) 2002-2012 The MirOS Project and contributors.  http://mirbsd.de\n";
@


1.30
log
@• kernel: merge rnd_flush() declarations into <randimpl.h>
• randomioctl: let RNDSTIRARC4 invoke rnd_flush() if called from init(8)
• init, reboot/halt: use unified "pathnames.h"
• init: use RNDSTIRARC4 to reset all pools (lopool, arc4random) on halt
• init: write 2048 bytes to /var/db/host.random to make it an even 8 KiB
• init: redesign code for that, minimise sleep calls, tested with tempo-
  rary printf/warning/etc. calls in userspace and kernel
• init: upon SIGTSTP, invoke RNDSTIRARC4 to help halt/reboot
• halt/reboot: do similar things like init wrt. signals, output, seed file
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.29 2011/01/03 17:49:35 tg Exp $ */
d111 1
a111 1
"Copyright (c) 2002-2011 The MirOS Project and contributors.  http://mirbsd.de\n";
@


1.29
log
@2011
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.28 2010/09/19 18:55:39 tg Exp $ */
d8 1
a8 1
 * Copyright (c) 1990-2002, 2003, 2004, 2005, 2006
d100 1
a105 2
extern void rnd_flush(void);

@


1.28
log
@the promised new RNG (play with RNDEBUG in crypto/randimpl.h to make
it verbose; I did, for a while and a bit of fine-tuning)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.27 2010/09/12 18:20:01 tg Exp $ */
d112 1
a112 1
"Copyright (c) 2002-2010 The MirOS Project and contributors.  http://mirbsd.de\n";
@


1.27
log
@part 1: remove the addpool, replace with dummy lopool
do not install this, it reduces entropy
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.26 2010/01/06 18:52:19 tg Exp $ */
d105 1
a105 1
extern void rnd_shutdown(void);
d714 1
a714 1
	rnd_shutdown();
@


1.26
log
@welcome to Y2k01
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.25 2009/11/09 19:43:46 tg Exp $ */
d214 1
a214 1
	rnd_addpool_add(ticks);
d369 1
a369 1
	rnd_addpool_add(ticks);
d491 1
a491 1
	rnd_bootpool_add(&pentium_mhz, sizeof(pentium_mhz));
@


1.25
log
@improve RNG stuff with proper hashing
(checked arc4* stuff to avoid short cycles; OpenBSD already ensured that)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.24 2009/02/22 17:06:27 tg Exp $ */
d112 1
a112 1
"Copyright (c) 2002-2009 The MirOS Project and contributors.  http://mirbsd.de\n";
@


1.24
log
@at kernel entry on shutdown (SYS_reboot), before shutting down the VFS,
add the wrandom(4) pool to arc4random(9) and stir the latter, so that
the superblock entropy fields and other places get the maximum possible
out of it
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.23 2009/01/02 05:16:32 tg Exp $ */
d369 1
a369 1
	rnd_bootpool_add(&ticks, sizeof (ticks));
d490 2
a491 5
	if (pentium_mhz) {
		unsigned long long tmptsc;
		__asm __volatile("rdtsc" : "=A" (tmptsc));
		rnd_bootpool_add(&tmptsc, sizeof (tmptsc));
	}
@


1.23
log
@bump, regenerate, etc.
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.22 2008/11/08 23:04:21 tg Exp $ */
d105 2
d717 1
@


1.22
log
@more mass conversions, including ancient eMail addresses
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.21 2008/06/13 14:00:05 tg Exp $ */
d110 1
a110 1
"Copyright (c) 2002-2008 The MirOS Project and contributors.  http://mirbsd.de\n";
@


1.21
log
@• get rid of rnd_bootpool* now that we can use rnd_addpool_add() early
• drain the rnd_addpool not a 32-burst every half minute or so, but
  one word at a time about every second ± ½
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.20 2008/04/09 05:45:42 tg Exp $ */
d9 1
a9 1
 *	Thorsten "mirabile" Glaser <tg@@66h.42h.de>
@


1.20
log
@new macro rnd_bootpool_add for
• simplifying operations on rnd_bootpool
• allowing to use it _past_ enqueueing of rnd_bootpool into user pool
  near end of kernel boot-up (think PCMCIA NIC hot-plug¹)

¹) yes, despite RFC1750 and with Vutral’s idea
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.19 2008/02/24 12:47:19 tg Exp $ */
d367 1
a367 1
	rnd_bootpool += ticks;
a494 2
	add_true_randomness(rnd_bootpool);
	rnd_bootpool = rnd_bootpool_done = 1;
@


1.19
log
@2008
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.18 2007/09/28 18:44:00 tg Exp $ */
d491 1
a491 2
		rnd_bootpool = adler32(rnd_bootpool, (uint8_t *)&tmptsc,
		    sizeof (tmptsc));
d496 1
@


1.18
log
@• srandom.c: fix a calculation error
• init_main.c: add homepage
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.17 2007/09/02 18:15:23 tg Exp $ */
d110 1
a110 1
"Copyright (c) 2002-2007 The MirOS Project and contributors.  http://mirbsd.de\n";
@


1.17
log
@Theo is right and it’s illegal to strip _any_ copyright notices, I suppose.
So put back the (c) OpenBSD during boot-up, I hope they don’t think this is
endorsing or anything again…
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.16 2007/07/21 10:42:55 tg Exp $ */
d110 1
a110 1
"Copyright (c) 2002-2007 The MirOS Project and its contributors.\n";
@


1.16
log
@eew. can't use rdtsc if the CPU doesn't have it now can we?
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.15 2007/03/02 03:13:28 tg Exp $ */
d106 5
a110 3
const char copyright[] =
    "Copyright (c) 2002-2007 The MirOS Project and its contributors.\n"
    "See /usr/share/doc/legal/1stREAD or source for all (c) statements";
@


1.15
log
@• make the kernel use the adler32() stuff in src/kern, whose sources
  live in the z part but that, logically, more belongs to the c part
• export adler32 (over <sys/systm.h> -> libkern -> <libckern.h>) and
  the rnd_bootpool (via <sys/systm.h> directly) to all of the kernel
• adler32 for the kernel moves to libkern
• adler32 for the i386 bootloader moves to libsa
• adler32 for the sparc bootloader moves to libkern
• userland libz is not affected (yet); make depend still pulls it in

tested by building a GENERIC, a bsd.rd with it, a cdrom9.fs with the
new bootloader (i386), qemu'ing that
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.14 2006/12/31 17:03:35 tg Exp $ */
d486 1
a486 1
	{
@


1.14
log
@bump to 2007
remove a superfluous cast
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.13 2006/10/08 00:24:44 tg Exp $ */
a145 2
extern unsigned long adler32(unsigned long, const char *, unsigned);

a185 1
	extern uint32_t rnd_bootpool;
@


1.13
log
@add a few more entropy sources, some suggested by Vutral, but don't
scan for /*/PUTTY.RND and /*/RANDSEED.BIN ;-) and remove a stupid one;
move dmesg.boot code for installer from install.sub into firstrun
code, and initialise a counter in rnd.c to zero which was previously not (oO)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.12 2006/08/22 21:51:39 tg Exp $ */
d107 1
a107 1
    "Copyright (c) 2002-2006 The MirOS Project and its contributors.\n"
d213 1
a213 1
	rnd_addpool_add((u_long)ticks);
@


1.12
log
@use the machdep.console_device sysctl(3) instead
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.11 2006/08/19 15:51:47 tg Exp $ */
d146 2
a185 1
	struct timeval rtv;
d488 9
a496 2
	microtime(&rtv);
	add_true_randomness(rtv.tv_sec ^ rtv.tv_usec);
@


1.11
log
@change consdev= to look more like rootdev= before it's too widespread
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.10 2006/08/19 00:05:50 tg Exp $ */
a100 2
#include <dev/cons.h>

a486 11
	/* Help /etc/rc to determine which device is the console */
	if (cn_tab == NULL)
		printf("consdev=NULL\n");
	else
		printf("consdev=%s %d,%d\n",
		    cn_tab->cn_pri == CN_DEAD ? "DEAD" :
		    cn_tab->cn_pri == CN_NORMAL ? "NORMAL" :
		    cn_tab->cn_pri == CN_INTERNAL ? "INTERNAL" :
		    cn_tab->cn_pri == CN_REMOTE ? "REMOTE" : "UNKNOWN",
		    major(cn_tab->cn_dev), minor(cn_tab->cn_dev));

@


1.10
log
@add a printf telling userland which device is the console
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.9 2006/06/16 18:43:32 tg Exp $ */
d491 1
a491 1
		printf("consdev: NULL\n");
d493 1
a493 1
		printf("consdev: %s %d,%d\n",
@


1.9
log
@make the sparc port, finally, usable (with native executables only though)
by adding a delay after pseudo-device initialisation, and bring back the
full kernel configuration
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.8 2006/05/26 12:04:59 tg Exp $ */
d101 2
d489 11
@


1.8
log
@* add entropy from lower memory (at boot-up) and
  kernel msg buffer (at its initialisation time)
  into random pool
* don't initialise with ticks repeatedly
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.6 2006/01/01 20:44:58 tg Exp $ */
d174 1
a174 1
 * System startup; initialize the world, create process 0, mount root
d195 1
a195 1
	 * Initialize the current process pointer (curproc) before
d201 1
a201 1
	 * Initialize timeouts.
d206 1
a206 1
	 * Attempt to find console and initialize
d220 1
a220 1
	 * Initialize mbufs.  Do this now because we might attempt to
d225 1
a225 1
	/* Initalize sockets. */
d228 1
a228 1
	/* Initialize sysctls (must be done before any processes run) */
d232 1
a232 1
	 * Initialize process and pgrp structures.
d236 1
a236 1
	/* Initialize file locking. */
d240 1
a240 1
	 * Initialize filedescriptors.
d245 1
a245 1
	 * Initialize pipes.
d250 1
a250 1
	 * Initialize kqueues.
d284 1
a284 1
	/* Initialize signal state for process 0. */
d325 1
a325 1
	/* Initialize run queues */
d334 1
a334 1
	/* Initialize the file systems. */
d336 1
a336 1
	nfs_init();			/* initialize server/shared data */
d344 1
a344 1
	/* Initialize System V style shared memory. */
d349 1
a349 1
	/* Initialize System V style semaphores. */
d354 1
a354 1
	/* Initialize System V style message queues. */
d358 4
d374 1
a374 1
	 * Initialize protocols.  Block reception of incoming packets
@


1.7
log
@sync licencing information
@
text
@d187 1
d363 1
a363 1
	rnd_addpool_add((u_long)ticks);
d484 3
a486 3
	srandom((u_long)(rtv.tv_sec ^ rtv.tv_usec));
	rnd_addpool_add((u_long)ticks ^ rtv.tv_usec);

@


1.6
log
@2006 here, too
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.5 2005/07/04 03:36:33 tg Exp $ */
d108 1
a108 1
    "For a full list of copyright statements see /usr/share/doc/legal/*";
@


1.5
log
@* finish outstanding merges
* make that damn thing build again
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.4 2005/05/15 01:15:31 tg Exp $ */
d8 1
a8 1
 * Copyright (c) 1990-2002, 2003, 2004, 2005
d107 1
a107 1
    "Copyright (c) 2002-2005 The MirOS Project and its contributors.\n"
@


1.5.2.1
log
@un-out-of-date, welcome to 2006
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.5 2005/07/04 03:36:33 tg Exp $ */
d107 1
a107 1
    "Copyright (c) 2002-2006 The MirOS Project and its contributors.\n"
@


1.4
log
@hubertf@@netbsd.org was mildly surprised when booting OpenBSD that
they, inconsistently, display the UCB copyright but not the TNF one.

To be consistent, only display MirOS copyright with a pointer to
the full legal text. We're big enough a project so we can do it,
plus MirOS comes as a package: kernel, userland, ports and the attitude.
@
text
@d1 2
a2 2
/**	$MirOS: src/sys/kern/init_main.c,v 1.3 2005/03/14 22:05:04 tg Exp $ */
/*	$OpenBSD: init_main.c,v 1.113 2004/04/01 00:27:51 tedu Exp $	*/
d132 1
a186 1
	register_t rval[2];
d387 28
d437 9
d450 5
a454 2
	p->p_stats->p_start = runtime = mono_time = boottime = time;
	p->p_rtime.tv_sec = p->p_rtime.tv_usec = 0;
d456 1
a456 5
	/* Create process 1 (init(8)). */
	if (fork1(p, SIGCHLD, FORK_FORK, NULL, 0, start_init, NULL, rval))
		panic("fork init");

	/* Create process 2, the pageout daemon kernel thread. */
d460 1
a460 1
	/* Create process 3, the reaper daemon kernel thread. */
d464 1
a464 1
	/* Create process 4, the cleaner daemon kernel thread. */
d468 1
a468 1
	/* Create process 5, the update daemon kernel thread. */
d472 1
a472 1
	/* Create process 6, the aiodone daemon kernel thread. */
d476 2
a477 2
#ifdef	CRYPTO
	/* Create process 7, the crypto kernel thread. */
a481 3
	/* Create any other deferred kernel threads. */
	kthread_run_deferred_queue();

d487 7
d546 3
a548 1
	initproc = p;
d551 1
a551 1
	 * Now in process 1.
d553 3
@


1.3
log
@regenerate about everything regeneratable
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/kern/init_main.c,v 1.2 2005/03/06 21:28:00 tg Exp $ */
d105 4
a108 5
const char	copyright[] =
"Copyright (c) 1982, 1986, 1989, 1991, 1993\n"
"\tThe Regents of the University of California.  All rights reserved.\n"
"Copyright (c) 1995-2004 OpenBSD. All rights reserved.  http://www.OpenBSD.org\n"
"Copyright (c) 2002-2005 The MirOS Project.  http://www.MirBSD.org/\n";
@


1.2
log
@* merge src/sys/
  (at least the better part of it)
* revert IPv6 networking to OpenBSD, since
  I didn't get IPV4_MAPPED addresses working :(
@
text
@d1 1
a1 1
/**	$MirOS$ */
d8 1
a8 1
 * Copyright (c) 2002, 2003, 2004, 2005
d109 1
a109 1
"Copyright (c) 1990-2002 MirBSD; 2002-2005 The MirOS Project.  http://MirBSD.de/\n";
@


1.1
log
@Initial revision
@
text
@d1 1
d4 2
d8 2
d69 1
a69 1
#ifdef SYSVSHM
d72 1
a72 1
#ifdef SYSVSEM
d75 1
a75 1
#ifdef SYSVMSG
d108 2
a109 1
"Copyright (c) 1995-2004 OpenBSD. All rights reserved.  http://www.OpenBSD.org\n";
d126 1
a133 4
#if !defined(NO_PROPOLICE)
long	__guard[8];
#endif

d143 1
d147 1
a147 1
#ifdef SYSCALL_DEBUG
d158 1
a158 1
#ifdef SYSCALL_DEBUG
a178 1
/* XXX return int, so gcc -Werror won't complain */
d180 1
a180 2
main(framep)
	void *framep;				/* XXX should go away */
d212 1
d216 1
a216 1
	tty_init();		/* initialise tty's */
d220 1
a220 1
	 * Initialize mbuf's.  Do this now because we might attempt to
d343 1
a343 1
#ifdef SYSVSHM
d348 1
a348 1
#ifdef SYSVSEM
d353 1
a353 1
#ifdef SYSVMSG
d363 1
d365 1
a365 1
#ifdef CRYPTO
d367 2
a368 2
#endif /* CRYPTO */
	
d379 2
a380 8
#ifdef GPROF
	/* Initialize kernel profiling. */
	kmstartup();
#endif

#if !defined(NO_PROPOLICE)
	arc4random_bytes(__guard, sizeof(__guard));
#endif
d437 1
a437 1
	/* Create process 6, the aiodone daemon kernel thread. */ 
d441 1
a441 1
#ifdef CRYPTO
d445 1
a445 1
#endif /* CRYPTO */
d452 1
d471 1
a471 2
check_console(p)
	struct proc *p;
d492 1
a492 2
start_init(arg)
	void *arg;
d517 1
a517 1
#ifdef MACHINE_STACK_GROWS_UP
d522 1
a522 1
	if (uvm_map(&p->p_vmspace->vm_map, &addr, PAGE_SIZE, 
d530 1
a530 1
#ifdef MACHINE_STACK_GROWS_UP
d546 1
a546 1
#ifdef notyet
d559 1
a559 1
#ifdef DEBUG
d562 1
a562 1
#ifdef MACHINE_STACK_GROWS_UP
d576 1
a576 1
#ifdef DEBUG
d579 1
a579 1
#ifdef MACHINE_STACK_GROWS_UP
d621 1
a621 2
start_update(arg)
	void *arg;
d628 1
a628 2
start_cleaner(arg)
	void *arg;
d635 1
a635 2
start_reaper(arg)
	void *arg;
d641 1
a641 1
#ifdef CRYPTO
d643 1
a643 2
start_crypto(arg)
	void *arg;
d648 86
a733 1
#endif /* CRYPTO */
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@   Log message:
   Create the init process earlier, before the root filesystem is mounted,
   and have it stall on a semaphore. This allows all kthread creations which
   could have been requested during autoconf to be processed before root
   is mounted as well.

   This causes umass devices attached to any usb with flags 1 (such as on macppc)
   to configure properly instead of panicing the kernel at mountroot time.

   From NetBSD; tested by various.
   From: Miod Vallat (miod [at.gif] cvs.openbsd.org)
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.120 2004/11/23 19:08:55 miod Exp $	*/
a125 1
__volatile int start_init_exec;		/* semaphore for start_init() */
d185 1
a389 28
	/*
	 * Create process 1 (init(8)).  We do this now, as Unix has
	 * historically had init be process 1, and changing this would
	 * probably upset a lot of people.
	 *
	 * Note that process 1 won't immediately exec init(8), but will
	 * wait for us to inform it that the root file system has been
	 * mounted.
	 */
	if (fork1(p, SIGCHLD, FORK_FORK, NULL, 0, start_init, NULL, NULL,
	    &initproc))
		panic("fork init");

	/*
	 * Create any kernel threads who's creation was deferred because
	 * initproc had not yet been created.
	 */
	kthread_run_deferred_queue();

	/*
	 * Now that device driver threads have been created, wait for
	 * them to finish any deferred autoconfiguration.  Note we don't
	 * need to lock this semaphore, since we haven't booted any
	 * secondary processors, yet.
	 */
	while (config_pending)
		(void) tsleep((void *)&config_pending, PWAIT, "cfpend", 0);

a411 9
	 * Now that root is mounted, we can fixup initproc's CWD
	 * info.  All other processes are kthreads, which merely
	 * share proc0's CWD info.
	 */
	initproc->p_fd->fd_cdir = rootvnode;
	VREF(initproc->p_fd->fd_cdir);
	initproc->p_fd->fd_rdir = NULL;

	/*
d416 6
a421 5
	runtime = mono_time = boottime = time;
	LIST_FOREACH(p, &allproc, p_list) {
		p->p_stats->p_start = boottime;
		p->p_rtime.tv_sec = p->p_rtime.tv_usec = 0;
	}
d423 1
a423 1
	/* Create the pageout daemon kernel thread. */
d427 1
a427 1
	/* Create the reaper daemon kernel thread. */
d431 1
a431 1
	/* Create the cleaner daemon kernel thread. */
d435 1
a435 1
	/* Create the update daemon kernel thread. */
d439 1
a439 1
	/* Create the aiodone daemon kernel thread. */ 
d444 1
a444 1
	/* Create the crypto kernel thread. */
d449 3
a455 7

	/*
	 * Okay, now we can let init(8) exec!  It's off to userland!
	 */
	start_init_exec = 1;
	wakeup((void *)&start_init_exec);

d510 2
a514 7

	/*
	 * Wait for main() to tell us that it's safe to exec.
	 */
	while (start_init_exec == 0)
		(void) tsleep((void *)&start_init_exec, PWAIT, "initexec", 0);

@

