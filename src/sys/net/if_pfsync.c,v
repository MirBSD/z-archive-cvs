head	1.4;
access;
symbols
	tg-beforemerge-ksrc10:1.1.1.2
	MIRBSD_10:1.4.0.2
	MIRBSD_10_BASE:1.4
	MIRBSD_9_BASE:1.3
	MIRBSD_8:1.3.0.2
	MIRBSD_8_BASE:1.3
	cvs-200512191930:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2006.10.17.20.48.49;	author tg;	state Exp;
branches;
next	1.3;
commitid	100453541560606E94A;

1.3
date	2005.12.20.19.41.29;	author tg;	state Exp;
branches;
next	1.2;
commitid	10043A85DFB227044E6;

1.2
date	2005.12.19.22.22.10;	author tg;	state Exp;
branches;
next	1.1;
commitid	10043A7329D76D1C6CD;

1.1
date	2005.02.05.17.29.04;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.29.04;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.12.19.19.38.30;	author tg;	state Exp;
branches;
next	;
commitid	10043A70C2C02EA4B14;


desc
@@


1.4
log
@fix a couple of time_t bugs, allowing us to run in 2000, 2100 and 2200.
status is:
* 2000 (31 bit)
  -> everything works as we had
* 2100 (32 bit)
  -> strftime +%s, ls won't work
  -> ffs uses 32-bit (signed or unsigned?) m/a/ctimes
     (UFS2 uses 64-bit m/a/c/btimes)
* 2200 (33 bit)
  -> network doesn't work any more (ssh confirmed, ping maybe?)
  -> we cannot shutdown any more
  -> touch/ls still works and wraps
@
text
@/*	$OpenBSD: if_pfsync.c,v 1.32 2004/04/30 22:08:18 mcbride Exp $	*/

/*
 * Copyright (c) 2002 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "bpfilter.h"
#include "pfsync.h"

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/timeout.h>

#include <net/if.h>
#include <net/if_types.h>
#include <net/route.h>
#include <net/bpf.h>
#include <netinet/tcp.h>
#include <netinet/tcp_seq.h>

#ifdef	INET
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#endif

#ifdef INET6
#ifndef INET
#include <netinet/in.h>
#endif
#include <netinet6/nd6.h>
#endif /* INET6 */

#include "carp.h"
#if NCARP > 0
extern int carp_suppress_preempt;
#endif

#include <net/pfvar.h>
#include <net/if_pfsync.h>

#define PFSYNC_MINMTU	\
    (sizeof(struct pfsync_header) + sizeof(struct pf_state))

#ifdef PFSYNCDEBUG
#define DPRINTF(x)    do { if (pfsyncdebug) printf x ; } while (0)
int pfsyncdebug;
#else
#define DPRINTF(x)
#endif

struct pfsync_softc	pfsyncif;
struct pfsyncstats	pfsyncstats;

void	pfsyncattach(int);
void	pfsync_setmtu(struct pfsync_softc *, int);
int	pfsync_insert_net_state(struct pfsync_state *);
int	pfsyncoutput(struct ifnet *, struct mbuf *, struct sockaddr *,
	    struct rtentry *);
int	pfsyncioctl(struct ifnet *, u_long, caddr_t);
void	pfsyncstart(struct ifnet *);

struct mbuf *pfsync_get_mbuf(struct pfsync_softc *, u_int8_t, void **);
int	pfsync_request_update(struct pfsync_state_upd *, struct in_addr *);
int	pfsync_sendout(struct pfsync_softc *);
void	pfsync_timeout(void *);
void	pfsync_send_bus(struct pfsync_softc *, u_int8_t);
void	pfsync_bulk_update(void *);
void	pfsync_bulkfail(void *);

int	pfsync_sync_ok;
extern int ifqmaxlen;
extern struct timeval time;
extern struct timeval mono_time;
extern int hz;

void
pfsyncattach(int npfsync)
{
	struct ifnet *ifp;

	pfsync_sync_ok = 1;
	bzero(&pfsyncif, sizeof(pfsyncif));
	pfsyncif.sc_mbuf = NULL;
	pfsyncif.sc_mbuf_net = NULL;
	pfsyncif.sc_statep.s = NULL;
	pfsyncif.sc_statep_net.s = NULL;
	pfsyncif.sc_maxupdates = 128;
	pfsyncif.sc_sendaddr.s_addr = INADDR_PFSYNC_GROUP;
	pfsyncif.sc_ureq_received = 0;
	pfsyncif.sc_ureq_sent = 0;
	ifp = &pfsyncif.sc_if;
	strlcpy(ifp->if_xname, "pfsync0", sizeof ifp->if_xname);
	ifp->if_softc = &pfsyncif;
	ifp->if_ioctl = pfsyncioctl;
	ifp->if_output = pfsyncoutput;
	ifp->if_start = pfsyncstart;
	ifp->if_type = IFT_PFSYNC;
	ifp->if_snd.ifq_maxlen = ifqmaxlen;
	ifp->if_hdrlen = PFSYNC_HDRLEN;
	pfsync_setmtu(&pfsyncif, MCLBYTES);
	timeout_set(&pfsyncif.sc_tmo, pfsync_timeout, &pfsyncif);
	timeout_set(&pfsyncif.sc_bulk_tmo, pfsync_bulk_update, &pfsyncif);
	timeout_set(&pfsyncif.sc_bulkfail_tmo, pfsync_bulkfail, &pfsyncif);
	if_attach(ifp);
	if_alloc_sadl(ifp);

#if NBPFILTER > 0
	bpfattach(&pfsyncif.sc_if.if_bpf, ifp, DLT_PFSYNC, PFSYNC_HDRLEN);
#endif
}

/*
 * Start output on the pfsync interface.
 */
void
pfsyncstart(struct ifnet *ifp)
{
	struct mbuf *m;
	int s;

	for (;;) {
		s = splimp();
		IF_DROP(&ifp->if_snd);
		IF_DEQUEUE(&ifp->if_snd, m);
		splx(s);

		if (m == NULL)
			return;
		else
			m_freem(m);
	}
}

int
pfsync_insert_net_state(struct pfsync_state *sp)
{
	struct pf_state	*st = NULL;
	struct pf_rule *r = NULL;
	struct pfi_kif	*kif;

	if (sp->creatorid == 0 && pf_status.debug >= PF_DEBUG_MISC) {
		printf("pfsync_insert_net_state: invalid creator id:"
		    " %08x\n", ntohl(sp->creatorid));
		return (EINVAL);
	}

	kif = pfi_lookup_create(sp->ifname);
	if (kif == NULL) {
		if (pf_status.debug >= PF_DEBUG_MISC)
			printf("pfsync_insert_net_state: "
			    "unknown interface: %s\n", sp->ifname);
		/* skip this state */
		return (0);
	}

	/*
	 * Just use the default rule until we have infrastructure to find the
	 * best matching rule.
	 */
	r = &pf_default_rule;

	if (!r->max_states || r->states < r->max_states)
		st = pool_get(&pf_state_pl, PR_NOWAIT);
	if (st == NULL) {
		pfi_maybe_destroy(kif);
		return (ENOMEM);
	}
	bzero(st, sizeof(*st));

	st->rule.ptr = r;
	/* XXX get pointers to nat_rule and anchor */

	/* fill in the rest of the state entry */
	pf_state_host_ntoh(&sp->lan, &st->lan);
	pf_state_host_ntoh(&sp->gwy, &st->gwy);
	pf_state_host_ntoh(&sp->ext, &st->ext);

	pf_state_peer_ntoh(&sp->src, &st->src);
	pf_state_peer_ntoh(&sp->dst, &st->dst);

	bcopy(&sp->rt_addr, &st->rt_addr, sizeof(st->rt_addr));
	st->creation = ntohl(sp->creation) + time.tv_sec;
	st->expire = ntohl(sp->expire) + time.tv_sec;

	st->af = sp->af;
	st->proto = sp->proto;
	st->direction = sp->direction;
	st->log = sp->log;
	st->timeout = sp->timeout;
	st->allow_opts = sp->allow_opts;

	bcopy(sp->id, &st->id, sizeof(st->id));
	st->creatorid = sp->creatorid;
	st->sync_flags = sp->sync_flags | PFSTATE_FROMSYNC;


	if (pf_insert_state(kif, st)) {
		pfi_maybe_destroy(kif);
		pool_put(&pf_state_pl, st);
		return (EINVAL);
	}

	return (0);
}

void
pfsync_input(struct mbuf *m, ...)
{
	struct ip *ip = mtod(m, struct ip *);
	struct pfsync_header *ph;
	struct pfsync_softc *sc = &pfsyncif;
	struct pf_state *st, key;
	struct pfsync_state *sp;
	struct pfsync_state_upd *up;
	struct pfsync_state_del *dp;
	struct pfsync_state_clr *cp;
	struct pfsync_state_upd_req *rup;
	struct pfsync_state_bus *bus;
	struct in_addr src;
	struct mbuf *mp;
	int iplen, action, error, i, s, count, offp, sfail, stale = 0;

	pfsyncstats.pfsyncs_ipackets++;

	/* verify that we have a sync interface configured */
	if (!sc->sc_sync_ifp || !pf_status.running)
		goto done;

	/* verify that the packet came in on the right interface */
	if (sc->sc_sync_ifp != m->m_pkthdr.rcvif) {
		pfsyncstats.pfsyncs_badif++;
		goto done;
	}

	/* verify that the IP TTL is 255.  */
	if (ip->ip_ttl != PFSYNC_DFLTTL) {
		pfsyncstats.pfsyncs_badttl++;
		goto done;
	}

	iplen = ip->ip_hl << 2;

	if (m->m_pkthdr.len < iplen + sizeof(*ph)) {
		pfsyncstats.pfsyncs_hdrops++;
		goto done;
	}

	if (iplen + sizeof(*ph) > m->m_len) {
		if ((m = m_pullup(m, iplen + sizeof(*ph))) == NULL) {
			pfsyncstats.pfsyncs_hdrops++;
			goto done;
		}
		ip = mtod(m, struct ip *);
	}
	ph = (struct pfsync_header *)((char *)ip + iplen);

	/* verify the version */
	if (ph->version != PFSYNC_VERSION) {
		pfsyncstats.pfsyncs_badver++;
		goto done;
	}

	action = ph->action;
	count = ph->count;

	/* make sure it's a valid action code */
	if (action >= PFSYNC_ACT_MAX) {
		pfsyncstats.pfsyncs_badact++;
		goto done;
	}

	/* Cheaper to grab this now than having to mess with mbufs later */
	src = ip->ip_src;

	switch (action) {
	case PFSYNC_ACT_CLR: {
		struct pfi_kif	*kif;
		u_int32_t creatorid;
		if ((mp = m_pulldown(m, iplen + sizeof(*ph),
		    sizeof(*cp), &offp)) == NULL) {
			pfsyncstats.pfsyncs_badlen++;
			return;
		}
		cp = (struct pfsync_state_clr *)(mp->m_data + offp);
		creatorid = cp->creatorid;

		s = splsoftnet();
		if (cp->ifname[0] == '\0') {
			RB_FOREACH(st, pf_state_tree_id, &tree_id) {
				if (st->creatorid == creatorid)
					st->timeout = PFTM_PURGE;
			}
		} else {
			kif = pfi_lookup_if(cp->ifname);
			if (kif == NULL) {
				if (pf_status.debug >= PF_DEBUG_MISC)
					printf("pfsync_input: PFSYNC_ACT_CLR "
					    "bad interface: %s\n", cp->ifname);
				splx(s);
				goto done;
			}
			RB_FOREACH(st, pf_state_tree_lan_ext,
			    &kif->pfik_lan_ext) {
				if (st->creatorid == creatorid) {
					st->timeout = PFTM_PURGE;
					pf_purge_expired_state(st);
				}
			}
		}
		splx(s);

		break;
	}
	case PFSYNC_ACT_INS:
		if ((mp = m_pulldown(m, iplen + sizeof(*ph),
		    count * sizeof(*sp), &offp)) == NULL) {
			pfsyncstats.pfsyncs_badlen++;
			return;
		}

		s = splsoftnet();
		for (i = 0, sp = (struct pfsync_state *)(mp->m_data + offp);
		    i < count; i++, sp++) {
			/* check for invalid values */
			if (sp->timeout >= PFTM_MAX ||
			    sp->src.state > PF_TCPS_PROXY_DST ||
			    sp->dst.state > PF_TCPS_PROXY_DST ||
			    sp->direction > PF_OUT ||
			    (sp->af != AF_INET && sp->af != AF_INET6)) {
				if (pf_status.debug >= PF_DEBUG_MISC)
					printf("pfsync_insert: PFSYNC_ACT_INS: "
					    "invalid value\n");
				pfsyncstats.pfsyncs_badstate++;
				continue;
			}

			if ((error = pfsync_insert_net_state(sp))) {
				if (error == ENOMEM) {
					splx(s);
					goto done;
				}
				continue;
			}
		}
		splx(s);
		break;
	case PFSYNC_ACT_UPD:
		if ((mp = m_pulldown(m, iplen + sizeof(*ph),
		    count * sizeof(*sp), &offp)) == NULL) {
			pfsyncstats.pfsyncs_badlen++;
			return;
		}

		s = splsoftnet();
		for (i = 0, sp = (struct pfsync_state *)(mp->m_data + offp);
		    i < count; i++, sp++) {
			/* check for invalid values */
			if (sp->timeout >= PFTM_MAX ||
			    sp->src.state > PF_TCPS_PROXY_DST ||
			    sp->dst.state > PF_TCPS_PROXY_DST) {
				if (pf_status.debug >= PF_DEBUG_MISC)
					printf("pfsync_insert: PFSYNC_ACT_UPD: "
					    "invalid value\n");
				pfsyncstats.pfsyncs_badstate++;
				continue;
			}

			bcopy(sp->id, &key.id, sizeof(key.id));
			key.creatorid = sp->creatorid;

			st = pf_find_state_byid(&key);
			if (st == NULL) {
				/* insert the update */
				if (pfsync_insert_net_state(sp))
					pfsyncstats.pfsyncs_badstate++;
				continue;
			}
			sfail = 0;
			if (st->proto == IPPROTO_TCP) {
				/*
				 * The state should never go backwards except
				 * for syn-proxy states.  Neither should the
				 * sequence window slide backwards.
				 */
				if (st->src.state > sp->src.state &&
				    (st->src.state < PF_TCPS_PROXY_SRC ||
				    sp->src.state >= PF_TCPS_PROXY_SRC))
					sfail = 1;
				else if (st->dst.state > sp->dst.state)
					sfail = 2;
				else if (SEQ_GT(st->src.seqlo,
				    ntohl(sp->src.seqlo)))
					sfail = 3;
				else if (st->dst.state >= TCPS_SYN_SENT &&
				    SEQ_GT(st->dst.seqlo, ntohl(sp->dst.seqlo)))
					sfail = 4;
			} else {
				/*
				 * Non-TCP protocol state machine always go
				 * forwards
				 */
				if (st->src.state > sp->src.state)
					sfail = 5;
				else if ( st->dst.state > sp->dst.state)
					sfail = 6;
			}
			if (sfail) {
				if (pf_status.debug >= PF_DEBUG_MISC)
					printf("pfsync: ignoring stale update "
					    "(%d) id: %016llx "
					    "creatorid: %08x\n", sfail,
					    betoh64(st->id),
					    ntohl(st->creatorid));
				pfsyncstats.pfsyncs_badstate++;

				/* we have a better state, send it out */
				if (sc->sc_mbuf != NULL && !stale)
					pfsync_sendout(sc);
				stale++;
				pfsync_pack_state(PFSYNC_ACT_UPD, st, 0);
				continue;
			}
			pf_state_peer_ntoh(&sp->src, &st->src);
			pf_state_peer_ntoh(&sp->dst, &st->dst);
			st->expire = ntohl(sp->expire) + time.tv_sec;
			st->timeout = sp->timeout;
		}
		if (stale && sc->sc_mbuf != NULL)
			pfsync_sendout(sc);
		splx(s);
		break;
	/*
	 * It's not strictly necessary for us to support the "uncompressed"
	 * delete action, but it's relatively simple and maintains consistency.
	 */
	case PFSYNC_ACT_DEL:
		if ((mp = m_pulldown(m, iplen + sizeof(*ph),
		    count * sizeof(*sp), &offp)) == NULL) {
			pfsyncstats.pfsyncs_badlen++;
			return;
		}

		s = splsoftnet();
		for (i = 0, sp = (struct pfsync_state *)(mp->m_data + offp);
		    i < count; i++, sp++) {
			bcopy(sp->id, &key.id, sizeof(key.id));
			key.creatorid = sp->creatorid;

			st = pf_find_state_byid(&key);
			if (st == NULL) {
				pfsyncstats.pfsyncs_badstate++;
				continue;
			}
			st->timeout = PFTM_PURGE;
			st->sync_flags |= PFSTATE_FROMSYNC;
			pf_purge_expired_state(st);
		}
		splx(s);
		break;
	case PFSYNC_ACT_UPD_C: {
		int update_requested = 0;

		if ((mp = m_pulldown(m, iplen + sizeof(*ph),
		    count * sizeof(*up), &offp)) == NULL) {
			pfsyncstats.pfsyncs_badlen++;
			return;
		}

		s = splsoftnet();
		for (i = 0, up = (struct pfsync_state_upd *)(mp->m_data + offp);
		    i < count; i++, up++) {
			/* check for invalid values */
			if (up->timeout >= PFTM_MAX ||
			    up->src.state > PF_TCPS_PROXY_DST ||
			    up->dst.state > PF_TCPS_PROXY_DST) {
				if (pf_status.debug >= PF_DEBUG_MISC)
					printf("pfsync_insert: "
					    "PFSYNC_ACT_UPD_C: "
					    "invalid value\n");
				pfsyncstats.pfsyncs_badstate++;
				continue;
			}

			bcopy(up->id, &key.id, sizeof(key.id));
			key.creatorid = up->creatorid;

			st = pf_find_state_byid(&key);
			if (st == NULL) {
				/* We don't have this state. Ask for it. */
				error = pfsync_request_update(up, &src);
				if (error == ENOMEM) {
					splx(s);
					goto done;
				}
				update_requested = 1;
				pfsyncstats.pfsyncs_badstate++;
				continue;
			}
			sfail = 0;
			if (st->proto == IPPROTO_TCP) {
				/*
				 * The state should never go backwards except
				 * for syn-proxy states.  Neither should the
				 * sequence window slide backwards.
				 */
				if (st->src.state > up->src.state &&
				    (st->src.state < PF_TCPS_PROXY_SRC ||
				    up->src.state >= PF_TCPS_PROXY_SRC))
					sfail = 1;
				else if (st->dst.state > up->dst.state)
					sfail = 2;
				else if (SEQ_GT(st->src.seqlo,
				    ntohl(up->src.seqlo)))
					sfail = 3;
				else if (st->dst.state >= TCPS_SYN_SENT &&
				    SEQ_GT(st->dst.seqlo, ntohl(up->dst.seqlo)))
					sfail = 4;
			} else {
				/*
				 * Non-TCP protocol state machine always go
				 * forwards
				 */
				if (st->src.state > up->src.state)
					sfail = 5;
				else if (st->dst.state > up->dst.state)
					sfail = 6;
			}
			if (sfail) {
				if (pf_status.debug >= PF_DEBUG_MISC)
					printf("pfsync: ignoring stale update "
					    "(%d) id: %016llx "
					    "creatorid: %08x\n", sfail,
					    betoh64(st->id),
					    ntohl(st->creatorid));
				pfsyncstats.pfsyncs_badstate++;

				/* we have a better state, send it out */
				if ((!stale || update_requested) &&
				    sc->sc_mbuf != NULL) {
					pfsync_sendout(sc);
					update_requested = 0;
				}
				stale++;
				pfsync_pack_state(PFSYNC_ACT_UPD, st, 0);
				continue;
			}
			pf_state_peer_ntoh(&up->src, &st->src);
			pf_state_peer_ntoh(&up->dst, &st->dst);
			st->expire = ntohl(up->expire) + time.tv_sec;
			st->timeout = up->timeout;
		}
		if ((update_requested || stale) && sc->sc_mbuf)
			pfsync_sendout(sc);
		splx(s);
		break;
	}
	case PFSYNC_ACT_DEL_C:
		if ((mp = m_pulldown(m, iplen + sizeof(*ph),
		    count * sizeof(*dp), &offp)) == NULL) {
			pfsyncstats.pfsyncs_badlen++;
			return;
		}

		s = splsoftnet();
		for (i = 0, dp = (struct pfsync_state_del *)(mp->m_data + offp);
		    i < count; i++, dp++) {
			bcopy(dp->id, &key.id, sizeof(key.id));
			key.creatorid = dp->creatorid;

			st = pf_find_state_byid(&key);
			if (st == NULL) {
				pfsyncstats.pfsyncs_badstate++;
				continue;
			}
			st->timeout = PFTM_PURGE;
			st->sync_flags |= PFSTATE_FROMSYNC;
			pf_purge_expired_state(st);
		}
		splx(s);
		break;
	case PFSYNC_ACT_INS_F:
	case PFSYNC_ACT_DEL_F:
		/* not implemented */
		break;
	case PFSYNC_ACT_UREQ:
		if ((mp = m_pulldown(m, iplen + sizeof(*ph),
		    count * sizeof(*rup), &offp)) == NULL) {
			pfsyncstats.pfsyncs_badlen++;
			return;
		}

		s = splsoftnet();
		if (sc->sc_mbuf != NULL)
			pfsync_sendout(sc);
		for (i = 0,
		    rup = (struct pfsync_state_upd_req *)(mp->m_data + offp);
		    i < count; i++, rup++) {
			bcopy(rup->id, &key.id, sizeof(key.id));
			key.creatorid = rup->creatorid;

			if (key.id == 0 && key.creatorid == 0) {
				sc->sc_ureq_received = mono_time.tv_sec;
				if (pf_status.debug >= PF_DEBUG_MISC)
					printf("pfsync: received "
					    "bulk update request\n");
				pfsync_send_bus(sc, PFSYNC_BUS_START);
				timeout_add(&sc->sc_bulk_tmo, 1 * hz);
			} else {
				st = pf_find_state_byid(&key);
				if (st == NULL) {
					pfsyncstats.pfsyncs_badstate++;
					continue;
				}
				pfsync_pack_state(PFSYNC_ACT_UPD, st, 0);
			}
		}
		if (sc->sc_mbuf != NULL)
			pfsync_sendout(sc);
		splx(s);
		break;
	case PFSYNC_ACT_BUS:
		/* If we're not waiting for a bulk update, who cares. */
		if (sc->sc_ureq_sent == 0)
			break;

		if ((mp = m_pulldown(m, iplen + sizeof(*ph),
		    sizeof(*bus), &offp)) == NULL) {
			pfsyncstats.pfsyncs_badlen++;
			return;
		}
		bus = (struct pfsync_state_bus *)(mp->m_data + offp);
		switch (bus->status) {
		case PFSYNC_BUS_START:
			timeout_add(&sc->sc_bulkfail_tmo,
			    pf_pool_limits[PF_LIMIT_STATES].limit /
			    (PFSYNC_BULKPACKETS * sc->sc_maxcount));
			if (pf_status.debug >= PF_DEBUG_MISC)
				printf("pfsync: received bulk "
				    "update start\n");
			break;
		case PFSYNC_BUS_END:
			if (mono_time.tv_sec - ntohl(bus->endtime) >=
			    sc->sc_ureq_sent) {
				/* that's it, we're happy */
				sc->sc_ureq_sent = 0;
				sc->sc_bulk_tries = 0;
				timeout_del(&sc->sc_bulkfail_tmo);
#if NCARP > 0
				if (!pfsync_sync_ok)
					carp_suppress_preempt--;
#endif
				pfsync_sync_ok = 1;
				if (pf_status.debug >= PF_DEBUG_MISC)
					printf("pfsync: received valid "
					    "bulk update end\n");
			} else {
				if (pf_status.debug >= PF_DEBUG_MISC)
					printf("pfsync: received invalid "
					    "bulk update end: bad timestamp\n");
			}
			break;
		}
		break;
	}

done:
	if (m)
		m_freem(m);
}

int
pfsyncoutput(struct ifnet *ifp, struct mbuf *m, struct sockaddr *dst,
	struct rtentry *rt)
{
	m_freem(m);
	return (0);
}

/* ARGSUSED */
int
pfsyncioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct proc *p = curproc;
	struct pfsync_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *)data;
	struct ip_moptions *imo = &sc->sc_imo;
	struct pfsyncreq pfsyncr;
	struct ifnet    *sifp;
	int s, error;

	switch (cmd) {
	case SIOCSIFADDR:
	case SIOCAIFADDR:
	case SIOCSIFDSTADDR:
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP)
			ifp->if_flags |= IFF_RUNNING;
		else
			ifp->if_flags &= ~IFF_RUNNING;
		break;
	case SIOCSIFMTU:
		if (ifr->ifr_mtu < PFSYNC_MINMTU)
			return (EINVAL);
		if (ifr->ifr_mtu > MCLBYTES)
			ifr->ifr_mtu = MCLBYTES;
		s = splnet();
		if (ifr->ifr_mtu < ifp->if_mtu)
			pfsync_sendout(sc);
		pfsync_setmtu(sc, ifr->ifr_mtu);
		splx(s);
		break;
	case SIOCGETPFSYNC:
		bzero(&pfsyncr, sizeof(pfsyncr));
		if (sc->sc_sync_ifp)
			strlcpy(pfsyncr.pfsyncr_syncif,
			    sc->sc_sync_ifp->if_xname, IFNAMSIZ);
		pfsyncr.pfsyncr_maxupdates = sc->sc_maxupdates;
		if ((error = copyout(&pfsyncr, ifr->ifr_data, sizeof(pfsyncr))))
			return (error);
		break;
	case SIOCSETPFSYNC:
		if ((error = suser(p, p->p_acflag)) != 0)
			return (error);
		if ((error = copyin(ifr->ifr_data, &pfsyncr, sizeof(pfsyncr))))
			return (error);

		if (pfsyncr.pfsyncr_maxupdates > 255)
			return (EINVAL);
		sc->sc_maxupdates = pfsyncr.pfsyncr_maxupdates;

		if (pfsyncr.pfsyncr_syncif[0] == 0) {
			sc->sc_sync_ifp = NULL;
			if (sc->sc_mbuf_net != NULL) {
				/* Don't keep stale pfsync packets around. */
				s = splnet();
				m_freem(sc->sc_mbuf_net);
				sc->sc_mbuf_net = NULL;
				sc->sc_statep_net.s = NULL;
				splx(s);
			}
			break;
		}
		if ((sifp = ifunit(pfsyncr.pfsyncr_syncif)) == NULL)
			return (EINVAL);
		else if (sifp == sc->sc_sync_ifp)
			break;

		s = splnet();
		if (sifp->if_mtu < sc->sc_if.if_mtu ||
		    (sc->sc_sync_ifp != NULL &&
		    sifp->if_mtu < sc->sc_sync_ifp->if_mtu) ||
		    sifp->if_mtu < MCLBYTES - sizeof(struct ip))
			pfsync_sendout(sc);
		sc->sc_sync_ifp = sifp;

		pfsync_setmtu(sc, sc->sc_if.if_mtu);

		if (imo->imo_num_memberships > 0) {
			in_delmulti(imo->imo_membership[--imo->imo_num_memberships]);
			imo->imo_multicast_ifp = NULL;
		}

		if (sc->sc_sync_ifp) {
			struct in_addr addr;

			addr.s_addr = INADDR_PFSYNC_GROUP;
			if ((imo->imo_membership[0] =
			    in_addmulti(&addr, sc->sc_sync_ifp)) == NULL) {
				splx(s);
				return (ENOBUFS);
			}
			imo->imo_num_memberships++;
			imo->imo_multicast_ifp = sc->sc_sync_ifp;
			imo->imo_multicast_ttl = PFSYNC_DFLTTL;
			imo->imo_multicast_loop = 0;

			/* Request a full state table update. */
			sc->sc_ureq_sent = mono_time.tv_sec;
#if NCARP > 0
			if (pfsync_sync_ok)
				carp_suppress_preempt++;
#endif
			pfsync_sync_ok = 0;
			if (pf_status.debug >= PF_DEBUG_MISC)
				printf("pfsync: requesting bulk update\n");
			timeout_add(&sc->sc_bulkfail_tmo, 5 * hz);
			error = pfsync_request_update(NULL, NULL);
			if (error == ENOMEM) {
				splx(s);
				return(ENOMEM);
			}
			pfsync_sendout(sc);
		}
		splx(s);

		break;

	default:
		return (ENOTTY);
	}

	return (0);
}

void
pfsync_setmtu(struct pfsync_softc *sc, int mtu_req)
{
	int mtu;

	if (sc->sc_sync_ifp && sc->sc_sync_ifp->if_mtu < mtu_req)
		mtu = sc->sc_sync_ifp->if_mtu;
	else
		mtu = mtu_req;

	sc->sc_maxcount = (mtu - sizeof(struct pfsync_header)) /
	    sizeof(struct pfsync_state);
	if (sc->sc_maxcount > 254)
	    sc->sc_maxcount = 254;
	sc->sc_if.if_mtu = sizeof(struct pfsync_header) +
	    sc->sc_maxcount * sizeof(struct pfsync_state);
}

struct mbuf *
pfsync_get_mbuf(struct pfsync_softc *sc, u_int8_t action, void **sp)
{
	struct pfsync_header *h;
	struct mbuf *m;
	int len;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL) {
		sc->sc_if.if_oerrors++;
		return (NULL);
	}

	switch (action) {
	case PFSYNC_ACT_CLR:
		len = sizeof(struct pfsync_header) +
		    sizeof(struct pfsync_state_clr);
		break;
	case PFSYNC_ACT_UPD_C:
		len = (sc->sc_maxcount * sizeof(struct pfsync_state_upd)) +
		    sizeof(struct pfsync_header);
		break;
	case PFSYNC_ACT_DEL_C:
		len = (sc->sc_maxcount * sizeof(struct pfsync_state_del)) +
		    sizeof(struct pfsync_header);
		break;
	case PFSYNC_ACT_UREQ:
		len = (sc->sc_maxcount * sizeof(struct pfsync_state_upd_req)) +
		    sizeof(struct pfsync_header);
		break;
	case PFSYNC_ACT_BUS:
		len = sizeof(struct pfsync_header) +
		    sizeof(struct pfsync_state_bus);
		break;
	default:
		len = (sc->sc_maxcount * sizeof(struct pfsync_state)) +
		    sizeof(struct pfsync_header);
		break;
	}

	if (len > MHLEN) {
		MCLGET(m, M_DONTWAIT);
		if ((m->m_flags & M_EXT) == 0) {
			m_free(m);
			sc->sc_if.if_oerrors++;
			return (NULL);
		}
		m->m_data += (MCLBYTES - len) &~ (sizeof(long) - 1);
	} else
		MH_ALIGN(m, len);

	m->m_pkthdr.rcvif = NULL;
	m->m_pkthdr.len = m->m_len = sizeof(struct pfsync_header);
	h = mtod(m, struct pfsync_header *);
	h->version = PFSYNC_VERSION;
	h->af = 0;
	h->count = 0;
	h->action = action;

	*sp = (void *)((char *)h + PFSYNC_HDRLEN);
	timeout_add(&sc->sc_tmo, hz);
	return (m);
}

int
pfsync_pack_state(u_int8_t action, struct pf_state *st, int compress)
{
	struct ifnet *ifp = &pfsyncif.sc_if;
	struct pfsync_softc *sc = ifp->if_softc;
	struct pfsync_header *h, *h_net;
	struct pfsync_state *sp = NULL;
	struct pfsync_state_upd *up = NULL;
	struct pfsync_state_del *dp = NULL;
	struct pf_rule *r;
	time_t secs;
	int s, ret = 0;
	u_int8_t i = 255, newaction = 0;

	/*
	 * If a packet falls in the forest and there's nobody around to
	 * hear, does it make a sound?
	 */
	if (ifp->if_bpf == NULL && sc->sc_sync_ifp == NULL) {
		/* Don't leave any stale pfsync packets hanging around. */
		if (sc->sc_mbuf != NULL) {
			m_freem(sc->sc_mbuf);
			sc->sc_mbuf = NULL;
			sc->sc_statep.s = NULL;
		}
		return (0);
	}

	if (action >= PFSYNC_ACT_MAX)
		return (EINVAL);

	s = splnet();
	if (sc->sc_mbuf == NULL) {
		if ((sc->sc_mbuf = pfsync_get_mbuf(sc, action,
		    (void *)&sc->sc_statep.s)) == NULL) {
			splx(s);
			return (ENOMEM);
		}
		h = mtod(sc->sc_mbuf, struct pfsync_header *);
	} else {
		h = mtod(sc->sc_mbuf, struct pfsync_header *);
		if (h->action != action) {
			pfsync_sendout(sc);
			if ((sc->sc_mbuf = pfsync_get_mbuf(sc, action,
			    (void *)&sc->sc_statep.s)) == NULL) {
				splx(s);
				return (ENOMEM);
			}
			h = mtod(sc->sc_mbuf, struct pfsync_header *);
		} else {
			/*
			 * If it's an update, look in the packet to see if
			 * we already have an update for the state.
			 */
			if (action == PFSYNC_ACT_UPD && sc->sc_maxupdates) {
				struct pfsync_state *usp =
				    (void *)((char *)h + PFSYNC_HDRLEN);

				for (i = 0; i < h->count; i++) {
					if (!memcmp(usp->id, &st->id,
					    PFSYNC_ID_LEN) &&
					    usp->creatorid == st->creatorid) {
						sp = usp;
						sp->updates++;
						break;
					}
					usp++;
				}
			}
		}
	}

	secs = time.tv_sec;

	st->pfsync_time = mono_time.tv_sec;
	TAILQ_REMOVE(&state_updates, st, u.s.entry_updates);
	TAILQ_INSERT_TAIL(&state_updates, st, u.s.entry_updates);

	if (sp == NULL) {
		/* not a "duplicate" update */
		i = 255;
		sp = sc->sc_statep.s++;
		sc->sc_mbuf->m_pkthdr.len =
		    sc->sc_mbuf->m_len += sizeof(struct pfsync_state);
		h->count++;
		bzero(sp, sizeof(*sp));

		bcopy(&st->id, sp->id, sizeof(sp->id));
		sp->creatorid = st->creatorid;

		strlcpy(sp->ifname, st->u.s.kif->pfik_name, sizeof(sp->ifname));
		pf_state_host_hton(&st->lan, &sp->lan);
		pf_state_host_hton(&st->gwy, &sp->gwy);
		pf_state_host_hton(&st->ext, &sp->ext);

		bcopy(&st->rt_addr, &sp->rt_addr, sizeof(sp->rt_addr));

		sp->creation = htonl(secs - st->creation);
		sp->packets[0] = htonl(st->packets[0]);
		sp->packets[1] = htonl(st->packets[1]);
		sp->bytes[0] = htonl(st->bytes[0]);
		sp->bytes[1] = htonl(st->bytes[1]);
		if ((r = st->rule.ptr) == NULL)
			sp->rule = htonl(-1);
		else
			sp->rule = htonl(r->nr);
		if ((r = st->anchor.ptr) == NULL)
			sp->anchor = htonl(-1);
		else
			sp->anchor = htonl(r->nr);
		sp->af = st->af;
		sp->proto = st->proto;
		sp->direction = st->direction;
		sp->log = st->log;
		sp->allow_opts = st->allow_opts;
		sp->timeout = st->timeout;

		sp->sync_flags = st->sync_flags & PFSTATE_NOSYNC;
	}

	pf_state_peer_hton(&st->src, &sp->src);
	pf_state_peer_hton(&st->dst, &sp->dst);

	if (st->expire <= secs)
		sp->expire = htonl(0);
	else
		sp->expire = htonl(st->expire - secs);

	/* do we need to build "compressed" actions for network transfer? */
	if (sc->sc_sync_ifp && compress) {
		switch (action) {
		case PFSYNC_ACT_UPD:
			newaction = PFSYNC_ACT_UPD_C;
			break;
		case PFSYNC_ACT_DEL:
			newaction = PFSYNC_ACT_DEL_C;
			break;
		default:
			/* by default we just send the uncompressed states */
			break;
		}
	}

	if (newaction) {
		if (sc->sc_mbuf_net == NULL) {
			if ((sc->sc_mbuf_net = pfsync_get_mbuf(sc, newaction,
			    (void *)&sc->sc_statep_net.s)) == NULL) {
				splx(s);
				return (ENOMEM);
			}
		}
		h_net = mtod(sc->sc_mbuf_net, struct pfsync_header *);

		switch (newaction) {
		case PFSYNC_ACT_UPD_C:
			if (i != 255) {
				up = (void *)((char *)h_net +
				    PFSYNC_HDRLEN + (i * sizeof(*up)));
				up->updates++;
			} else {
				h_net->count++;
				sc->sc_mbuf_net->m_pkthdr.len =
				    sc->sc_mbuf_net->m_len += sizeof(*up);
				up = sc->sc_statep_net.u++;

				bzero(up, sizeof(*up));
				bcopy(&st->id, up->id, sizeof(up->id));
				up->creatorid = st->creatorid;
			}
			up->timeout = st->timeout;
			up->expire = sp->expire;
			up->src = sp->src;
			up->dst = sp->dst;
			break;
		case PFSYNC_ACT_DEL_C:
			sc->sc_mbuf_net->m_pkthdr.len =
			    sc->sc_mbuf_net->m_len += sizeof(*dp);
			dp = sc->sc_statep_net.d++;
			h_net->count++;

			bzero(dp, sizeof(*dp));
			bcopy(&st->id, dp->id, sizeof(dp->id));
			dp->creatorid = st->creatorid;
			break;
		}
	}

	if (h->count == sc->sc_maxcount ||
	    (sc->sc_maxupdates && (sp->updates >= sc->sc_maxupdates)))
		ret = pfsync_sendout(sc);

	splx(s);
	return (ret);
}

/* This must be called in splnet() */
int
pfsync_request_update(struct pfsync_state_upd *up, struct in_addr *src)
{
	struct ifnet *ifp = &pfsyncif.sc_if;
	struct pfsync_header *h;
	struct pfsync_softc *sc = ifp->if_softc;
	struct pfsync_state_upd_req *rup;
	int ret;

	if (sc->sc_mbuf == NULL) {
		if ((sc->sc_mbuf = pfsync_get_mbuf(sc, PFSYNC_ACT_UREQ,
		    (void *)&sc->sc_statep.s)) == NULL)
			return (ENOMEM);
		h = mtod(sc->sc_mbuf, struct pfsync_header *);
	} else {
		h = mtod(sc->sc_mbuf, struct pfsync_header *);
		if (h->action != PFSYNC_ACT_UREQ) {
			pfsync_sendout(sc);
			if ((sc->sc_mbuf = pfsync_get_mbuf(sc, PFSYNC_ACT_UREQ,
			    (void *)&sc->sc_statep.s)) == NULL)
				return (ENOMEM);
			h = mtod(sc->sc_mbuf, struct pfsync_header *);
		}
	}

	if (src != NULL)
		sc->sc_sendaddr = *src;
	sc->sc_mbuf->m_pkthdr.len = sc->sc_mbuf->m_len += sizeof(*rup);
	h->count++;
	rup = sc->sc_statep.r++;
	bzero(rup, sizeof(*rup));
	if (up != NULL) {
		bcopy(up->id, rup->id, sizeof(rup->id));
		rup->creatorid = up->creatorid;
	}

	if (h->count == sc->sc_maxcount)
		ret = pfsync_sendout(sc);

	return (ret);
}

int
pfsync_clear_states(u_int32_t creatorid, char *ifname)
{
	struct ifnet *ifp = &pfsyncif.sc_if;
	struct pfsync_softc *sc = ifp->if_softc;
	struct pfsync_state_clr *cp;
	int s, ret;

	s = splnet();
	if (sc->sc_mbuf != NULL)
		pfsync_sendout(sc);
	if ((sc->sc_mbuf = pfsync_get_mbuf(sc, PFSYNC_ACT_CLR,
	    (void *)&sc->sc_statep.c)) == NULL) {
		splx(s);
		return (ENOMEM);
	}
	sc->sc_mbuf->m_pkthdr.len = sc->sc_mbuf->m_len += sizeof(*cp);
	cp = sc->sc_statep.c;
	cp->creatorid = creatorid;
	if (ifname != NULL)
		strlcpy(cp->ifname, ifname, IFNAMSIZ);

	ret = (pfsync_sendout(sc));
	splx(s);
	return (ret);
}

void
pfsync_timeout(void *v)
{
	struct pfsync_softc *sc = v;
	int s;

	s = splnet();
	pfsync_sendout(sc);
	splx(s);
}

/* This must be called in splnet() */
void
pfsync_send_bus(struct pfsync_softc *sc, u_int8_t status)
{
	struct pfsync_state_bus *bus;

	if (sc->sc_mbuf != NULL)
		pfsync_sendout(sc);

	if (pfsync_sync_ok &&
	    (sc->sc_mbuf = pfsync_get_mbuf(sc, PFSYNC_ACT_BUS,
	    (void *)&sc->sc_statep.b)) != NULL) {
		sc->sc_mbuf->m_pkthdr.len = sc->sc_mbuf->m_len += sizeof(*bus);
		bus = sc->sc_statep.b;
		bus->creatorid = pf_status.hostid;
		bus->status = status;
		bus->endtime = htonl(mono_time.tv_sec - sc->sc_ureq_received);
		pfsync_sendout(sc);
	}
}

void
pfsync_bulk_update(void *v)
{
	struct pfsync_softc *sc = v;
	int s, i = 0;
	struct pf_state *state;

	s = splnet();
	if (sc->sc_mbuf != NULL)
		pfsync_sendout(sc);

	/*
	 * Grab at most PFSYNC_BULKPACKETS worth of states which have not
	 * been sent since the latest request was made.
	 */
	while ((state = TAILQ_FIRST(&state_updates)) != NULL &&
	    ++i < (sc->sc_maxcount * PFSYNC_BULKPACKETS)) {
		if (state->pfsync_time > sc->sc_ureq_received) {
			/* we're done */
			pfsync_send_bus(sc, PFSYNC_BUS_END);
			sc->sc_ureq_received = 0;
			timeout_del(&sc->sc_bulk_tmo);
			if (pf_status.debug >= PF_DEBUG_MISC)
				printf("pfsync: bulk update complete\n");
			break;
		} else {
			/* send an update and move to end of list */
			if (!state->sync_flags)
				pfsync_pack_state(PFSYNC_ACT_UPD, state, 0);
			state->pfsync_time = mono_time.tv_sec;
			TAILQ_REMOVE(&state_updates, state, u.s.entry_updates);
			TAILQ_INSERT_TAIL(&state_updates, state,
			    u.s.entry_updates);

			/* look again for more in a bit */
			timeout_add(&sc->sc_bulk_tmo, 1);
		}
	}
	if (sc->sc_mbuf != NULL)
		pfsync_sendout(sc);
	splx(s);
}

void
pfsync_bulkfail(void *v)
{
	struct pfsync_softc *sc = v;
	int s, error;

	if (sc->sc_bulk_tries++ < PFSYNC_MAX_BULKTRIES) {
		/* Try again in a bit */
		timeout_add(&sc->sc_bulkfail_tmo, 5 * hz);
		s = splnet();
		error = pfsync_request_update(NULL, NULL);
		if (error == ENOMEM) {
			if (pf_status.debug >= PF_DEBUG_MISC)
				printf("pfsync: cannot allocate mbufs for "
				    "bulk update\n");
		} else 
			pfsync_sendout(sc);
		splx(s);
	} else {
		/* Pretend like the transfer was ok */
		sc->sc_ureq_sent = 0;
		sc->sc_bulk_tries = 0;
#if NCARP > 0
		if (!pfsync_sync_ok)
			carp_suppress_preempt--;
#endif
		pfsync_sync_ok = 1;
		if (pf_status.debug >= PF_DEBUG_MISC)
			printf("pfsync: failed to receive "
			    "bulk update status\n");
		timeout_del(&sc->sc_bulkfail_tmo);
	}
}

/* This must be called in splnet() */
int
pfsync_sendout(sc)
	struct pfsync_softc *sc;
{
	struct ifnet *ifp = &sc->sc_if;
	struct mbuf *m;

	timeout_del(&sc->sc_tmo);

	if (sc->sc_mbuf == NULL)
		return (0);
	m = sc->sc_mbuf;
	sc->sc_mbuf = NULL;
	sc->sc_statep.s = NULL;

#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m);
#endif

	if (sc->sc_mbuf_net) {
		m_freem(m);
		m = sc->sc_mbuf_net;
		sc->sc_mbuf_net = NULL;
		sc->sc_statep_net.s = NULL;
	}

	if (sc->sc_sync_ifp) {
		struct ip *ip;
		struct ifaddr *ifa;
		struct sockaddr sa;

		M_PREPEND(m, sizeof(struct ip), M_DONTWAIT);
		if (m == NULL) {
			pfsyncstats.pfsyncs_onomem++;
			return (0);
		}
		ip = mtod(m, struct ip *);
		ip->ip_v = IPVERSION;
		ip->ip_hl = sizeof(*ip) >> 2;
		ip->ip_tos = IPTOS_LOWDELAY;
		ip->ip_len = htons(m->m_pkthdr.len);
		ip->ip_id = htons(ip_randomid());
		ip->ip_off = htons(IP_DF);
		ip->ip_ttl = PFSYNC_DFLTTL;
		ip->ip_p = IPPROTO_PFSYNC;
		ip->ip_sum = 0;

		bzero(&sa, sizeof(sa));
		sa.sa_family = AF_INET;
		ifa = ifaof_ifpforaddr(&sa, sc->sc_sync_ifp);
		if (ifa == NULL)
			return (0);
		ip->ip_src.s_addr = ifatoia(ifa)->ia_addr.sin_addr.s_addr;

		if (sc->sc_sendaddr.s_addr == INADDR_PFSYNC_GROUP)
			m->m_flags |= M_MCAST;
		ip->ip_dst = sc->sc_sendaddr;
		sc->sc_sendaddr.s_addr = INADDR_PFSYNC_GROUP;

		pfsyncstats.pfsyncs_opackets++;

		if (ip_output(m, NULL, NULL, IP_RAWOUTPUT, &sc->sc_imo, NULL))
			pfsyncstats.pfsyncs_oerrors++;
	} else
		m_freem(m);

	return (0);
}
@


1.3
log
@Revert almost everything of the diff which updated PF.

Reason: pppoe(4) did not work any more (and HERC crashed, too).
Probable cause: the interface groups code.

I do not have time to look into this.
@
text
@d927 1
a927 1
	u_long secs;
@


1.2
log
@another in-between merge of fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.c,v 1.59 2005/11/04 08:24:14 mcbride Exp $	*/
d29 2
a39 1
#include <sys/kernel.h>
a44 2
#include <netinet/in.h>
#include <netinet/if_ether.h>
d49 1
d57 3
a70 3
#include "bpfilter.h"
#include "pfsync.h"

d86 1
a86 4
int	pfsync_alloc_scrub_memory(struct pfsync_state_peer *,
	    struct pf_state_peer *);
int	pfsync_insert_net_state(struct pfsync_state *, u_int8_t);
void	pfsync_update_net_tdb(struct pfsync_tdb *);
a94 2
int	pfsync_tdb_sendout(struct pfsync_softc *);
int	pfsync_sendout_mbuf(struct pfsync_softc *, struct mbuf *);
a95 1
void	pfsync_tdb_timeout(void *);
d102 3
a114 1
	pfsyncif.sc_mbuf_tdb = NULL;
a116 1
	pfsyncif.sc_statep_tdb.t = NULL;
a117 1
	pfsyncif.sc_sync_peer.s_addr = INADDR_PFSYNC_GROUP;
a120 2
	pfsyncif.sc_bulk_send_next = NULL;
	pfsyncif.sc_bulk_terminator = NULL;
d130 1
a130 1
	pfsync_setmtu(&pfsyncif, ETHERMTU);
a131 1
	timeout_set(&pfsyncif.sc_tdb_tmo, pfsync_tdb_timeout, &pfsyncif);
d165 1
a165 15
pfsync_alloc_scrub_memory(struct pfsync_state_peer *s,
    struct pf_state_peer *d)
{
	if (s->scrub.scrub_flag && d->scrub == NULL) {
		d->scrub = pool_get(&pf_state_scrub_pl, PR_NOWAIT);
		if (d->scrub == NULL)
			return (ENOMEM);
		bzero(d->scrub, sizeof(*d->scrub));
	}

	return (0);
}

int
pfsync_insert_net_state(struct pfsync_state *sp, u_int8_t chksum_flag)
d177 1
a177 1
	kif = pfi_kif_get(sp->ifname);
d187 2
a188 2
	 * If the ruleset checksums match, it's safe to associate the state
	 * with the rule of that number.
d190 1
a190 5
	if (sp->rule != htonl(-1) && sp->anchor == htonl(-1) && chksum_flag)
		r = pf_main_ruleset.rules[
		    PF_RULESET_FILTER].active.ptr_array[ntohl(sp->rule)];
	else
		r = &pf_default_rule;
d195 1
a195 1
		pfi_kif_unref(kif, PFI_KIF_REF_NONE);
a199 10
	/* allocate memory for scrub info */
	if (pfsync_alloc_scrub_memory(&sp->src, &st->src) ||
	    pfsync_alloc_scrub_memory(&sp->dst, &st->dst)) {
		pfi_kif_unref(kif, PFI_KIF_REF_NONE);
		if (st->src.scrub)
			pool_put(&pf_state_scrub_pl, st->src.scrub);
		pool_put(&pf_state_pl, st);
		return (ENOMEM);
	}

a202 3
	/* XXX when we have nat_rule/anchors, use STATE_INC_COUNTERS */
	r->states++;

d212 2
a213 2
	st->creation = time_second - ntohl(sp->creation);
	st->expire = ntohl(sp->expire) + time_second;
d224 2
a225 1
	st->sync_flags = PFSTATE_FROMSYNC;
d228 1
a228 7
		pfi_kif_unref(kif, PFI_KIF_REF_NONE);
		/* XXX when we have nat_rule/anchors, use STATE_DEC_COUNTERS */
		r->states--;
		if (st->dst.scrub)
			pool_put(&pf_state_scrub_pl, st->dst.scrub);
		if (st->src.scrub)
			pool_put(&pf_state_scrub_pl, st->src.scrub);
d242 1
a242 2
	struct pf_state *st;
	struct pf_state_cmp key;
a248 1
	struct pfsync_tdb *pt;
a251 1
	u_int8_t chksum_flag = 0;
a304 3
	if (!bcmp(&ph->pf_chksum, &pf_status.pf_chksum, PF_MD5_DIGEST_LENGTH))
		chksum_flag++;

a306 1
		struct pf_state *nexts;
d319 3
a321 7
			for (st = RB_MIN(pf_state_tree_id, &tree_id);
			    st; st = nexts) {
				nexts = RB_NEXT(pf_state_tree_id, &tree_id, st);
				if (st->creatorid == creatorid) {
					st->sync_flags |= PFSTATE_FROMSYNC;
					pf_unlink_state(st);
				}
d324 5
a328 1
			if ((kif = pfi_kif_get(cp->ifname)) == NULL) {
d330 1
a330 1
				return;
d332 2
a333 4
			for (st = RB_MIN(pf_state_tree_lan_ext,
			    &kif->pfik_lan_ext); st; st = nexts) {
				nexts = RB_NEXT(pf_state_tree_lan_ext,
				    &kif->pfik_lan_ext, st);
d335 2
a336 2
					st->sync_flags |= PFSTATE_FROMSYNC;
					pf_unlink_state(st);
d367 1
a367 2
			if ((error = pfsync_insert_net_state(sp,
			    chksum_flag))) {
a386 2
			int flags = PFSYNC_FLAG_STALE;

d404 1
a404 1
				if (pfsync_insert_net_state(sp, chksum_flag))
d419 2
d424 1
a424 12
				else if (st->dst.state > sp->dst.state) {
					/* There might still be useful
					 * information about the src state here,
					 * so import that part of the update,
					 * then "fail" so we send the updated
					 * state back to the peer who is missing
					 * our what we know. */
					pf_state_peer_ntoh(&sp->src, &st->src);
					/* XXX do anything with timeouts? */
					sfail = 7;
					flags = 0;
				} else if (st->dst.state >= TCPS_SYN_SENT &&
d434 1
a434 1
				else if (st->dst.state > sp->dst.state)
d439 1
a439 1
					printf("pfsync: %s stale update "
d441 1
a441 3
					    "creatorid: %08x\n",
					    (sfail < 7 ?  "ignoring"
					     : "partial"), sfail,
d446 5
a450 9
				if (!(sp->sync_flags & PFSTATE_STALE)) {
					/* we have a better state, send it */
					if (sc->sc_mbuf != NULL && !stale)
						pfsync_sendout(sc);
					stale++;
					if (!st->sync_flags)
						pfsync_pack_state(
						    PFSYNC_ACT_UPD, st, flags);
				}
a452 1
	    		pfsync_alloc_scrub_memory(&sp->dst, &st->dst);
d455 1
a455 1
			st->expire = ntohl(sp->expire) + time_second;
d484 1
d486 1
a486 1
			pf_unlink_state(st);
d574 1
a574 3
				if (!st->sync_flags)
					pfsync_pack_state(PFSYNC_ACT_UPD, st,
					    PFSYNC_FLAG_STALE);
a576 1
	    		pfsync_alloc_scrub_memory(&up->dst, &st->dst);
d579 1
a579 1
			st->expire = ntohl(up->expire) + time_second;
d605 1
d607 1
a607 1
			pf_unlink_state(st);
a632 4
				if (sc->sc_bulk_send_next == NULL)
					sc->sc_bulk_send_next =
					    TAILQ_FIRST(&state_list);
				sc->sc_bulk_terminator = sc->sc_bulk_send_next;
d644 1
a644 3
				if (!st->sync_flags)
					pfsync_pack_state(PFSYNC_ACT_UPD,
					    st, 0);
a693 12
	case PFSYNC_ACT_TDB_UPD:
		if ((mp = m_pulldown(m, iplen + sizeof(*ph),
		    count * sizeof(*pt), &offp)) == NULL) {
			pfsyncstats.pfsyncs_badlen++;
			return;
		}
		s = splsoftnet();
		for (i = 0, pt = (struct pfsync_tdb *)(mp->m_data + offp);
		    i < count; i++, pt++)
			pfsync_update_net_tdb(pt);
		splx(s);
		break;
d745 1
a745 1
			strlcpy(pfsyncr.pfsyncr_syncdev,
a746 1
		pfsyncr.pfsyncr_syncpeer = sc->sc_sync_peer;
a756 6
		if (pfsyncr.pfsyncr_syncpeer.s_addr == 0)
			sc->sc_sync_peer.s_addr = INADDR_PFSYNC_GROUP;
		else
			sc->sc_sync_peer.s_addr =
			    pfsyncr.pfsyncr_syncpeer.s_addr;

d761 1
a761 1
		if (pfsyncr.pfsyncr_syncdev[0] == 0) {
a770 4
			if (imo->imo_num_memberships > 0) {
				in_delmulti(imo->imo_membership[--imo->imo_num_memberships]);
				imo->imo_multicast_ifp = NULL;
			}
d773 1
a773 2

		if ((sifp = ifunit(pfsyncr.pfsyncr_syncdev)) == NULL)
d775 2
d793 1
a793 2
		if (sc->sc_sync_ifp &&
		    sc->sc_sync_peer.s_addr == INADDR_PFSYNC_GROUP) {
a795 6
			if (!(sc->sc_sync_ifp->if_flags & IFF_MULTICAST)) {
				sc->sc_sync_ifp = NULL;
				splx(s);
				return (EADDRNOTAVAIL);
			}

a796 1

a798 1
				sc->sc_sync_ifp = NULL;
a805 1
		}
a806 2
		if (sc->sc_sync_ifp ||
		    sc->sc_sendaddr.s_addr != INADDR_PFSYNC_GROUP) {
d820 1
a820 1
				return (ENOMEM);
a886 4
	case PFSYNC_ACT_TDB_UPD:
		len = (sc->sc_maxcount * sizeof(struct pfsync_tdb)) +
		    sizeof(struct pfsync_header);
		break;
a910 3
	if (action != PFSYNC_ACT_TDB_UPD)
		bcopy(&pf_status.pf_chksum, &h->pf_chksum,
		    PF_MD5_DIGEST_LENGTH);
d913 1
a913 4
	if (action == PFSYNC_ACT_TDB_UPD)
		timeout_add(&sc->sc_tdb_tmo, hz);
	else
		timeout_add(&sc->sc_tmo, hz);
d918 1
a918 1
pfsync_pack_state(u_int8_t action, struct pf_state *st, int flags)
d935 1
a935 2
	if (ifp->if_bpf == NULL && sc->sc_sync_ifp == NULL &&
	    sc->sc_sync_peer.s_addr == INADDR_PFSYNC_GROUP) {
d989 1
a989 1
	secs = time_second;
d992 2
d1015 4
a1018 4
		pf_state_counter_hton(st->packets[0], sp->packets[0]);
		pf_state_counter_hton(st->packets[1], sp->packets[1]);
		pf_state_counter_hton(st->bytes[0], sp->bytes[0]);
		pf_state_counter_hton(st->bytes[1], sp->bytes[1]);
d1034 1
a1034 2
		if (flags & PFSYNC_FLAG_STALE)
			sp->sync_flags |= PFSTATE_STALE;
d1046 1
a1046 1
	if (sc->sc_sync_ifp && flags & PFSYNC_FLAG_COMPRESS) {
d1120 1
a1120 1
	int ret = 0;
a1192 11
void
pfsync_tdb_timeout(void *v)
{
	struct pfsync_softc *sc = v;
	int s;

	s = splnet();
	pfsync_tdb_sendout(sc);
	splx(s);
}

d1229 13
a1241 7
	state = sc->sc_bulk_send_next;
	if (state)
		do {
			/* send state update if syncable and not already sent */
			if (!state->sync_flags
			    && state->timeout < PFTM_MAX
			    && state->pfsync_time <= sc->sc_ureq_received) {
d1243 4
a1246 2
				i++;
			}
d1248 3
a1250 22
			/* figure next state to send */
			state = TAILQ_NEXT(state, u.s.entry_list);

			/* wrap to start of list if we hit the end */
			if (!state)
				state = TAILQ_FIRST(&state_list);
		} while (i < sc->sc_maxcount * PFSYNC_BULKPACKETS &&
		    state != sc->sc_bulk_terminator);

	if (!state || state == sc->sc_bulk_terminator) {
		/* we're done */
		pfsync_send_bus(sc, PFSYNC_BUS_END);
		sc->sc_ureq_received = 0;
		sc->sc_bulk_send_next = NULL;
		sc->sc_bulk_terminator = NULL;
		timeout_del(&sc->sc_bulk_tmo);
		if (pf_status.debug >= PF_DEBUG_MISC)
			printf("pfsync: bulk update complete\n");
	} else {
		/* look again for more in a bit */
		timeout_add(&sc->sc_bulk_tmo, 1);
		sc->sc_bulk_send_next = state;
d1272 1
a1272 1
		} else
d1293 2
a1294 1
pfsync_sendout(struct pfsync_softc *sc)
d1319 4
a1322 30
	return pfsync_sendout_mbuf(sc, m);
}

int
pfsync_tdb_sendout(struct pfsync_softc *sc)
{
	struct ifnet *ifp = &sc->sc_if;
	struct mbuf *m;

	timeout_del(&sc->sc_tdb_tmo);

	if (sc->sc_mbuf_tdb == NULL)
		return (0);
	m = sc->sc_mbuf_tdb;
	sc->sc_mbuf_tdb = NULL;
	sc->sc_statep_tdb.t = NULL;

#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m);
#endif

	return pfsync_sendout_mbuf(sc, m);
}

int
pfsync_sendout_mbuf(struct pfsync_softc *sc, struct mbuf *m)
{
	struct sockaddr sa;
	struct ip *ip;
a1323 2
	if (sc->sc_sync_ifp ||
	    sc->sc_sync_peer.s_addr != INADDR_PFSYNC_GROUP) {
d1341 5
a1345 1
		ip->ip_src.s_addr = INADDR_ANY;
d1350 1
a1350 1
		sc->sc_sendaddr.s_addr = sc->sc_sync_peer.s_addr;
a1360 161

/* Update an in-kernel tdb. Silently fail if no tdb is found. */
void
pfsync_update_net_tdb(struct pfsync_tdb *pt)
{
	struct tdb		*tdb;
	int			 s;

	/* check for invalid values */
	pt->spi = htonl(pt->spi);
	if (pt->spi <= SPI_RESERVED_MAX ||
	    (pt->dst.sa.sa_family != AF_INET &&
	     pt->dst.sa.sa_family != AF_INET6))
		goto bad;

	if (pt->dst.sa.sa_family == AF_INET)
		pt->dst.sin.sin_addr.s_addr =
		    htonl(pt->dst.sin.sin_addr.s_addr);

	s = spltdb();
	tdb = gettdb(pt->spi, &pt->dst, pt->sproto);
	if (tdb) {
		/*
		 * When a failover happens, the master's rpl is probably above
		 * what we see here (we may be up to a second late), so
		 * increase it a bit to manage most such situations.
		 *
		 * For now, just add an offset that is likely to be larger
		 * than the number of packets we can see in one second. The RFC
		 * just says the next packet must have a higher seq value.
		 *
		 * XXX What is a good algorithm for this? We could use
		 * a rate-determined increase, but to know it, we would have
		 * to extend struct tdb.
		 * XXX pt->rpl can wrap over MAXINT, but if so the real tdb
		 * will soon be replaced anyway. For now, just don't handle
		 * this edge case.
		 */
#define RPL_INCR 16384
		pt->rpl = ntohl(pt->rpl) + RPL_INCR;
		pt->cur_bytes = betoh64(pt->cur_bytes);

		/* Neither replay nor byte counter should ever decrease. */
		if (pt->rpl < tdb->tdb_rpl ||
		    pt->cur_bytes < tdb->tdb_cur_bytes) {
			splx(s);
			goto bad;
		}

		tdb->tdb_rpl = pt->rpl;
		tdb->tdb_cur_bytes = pt->cur_bytes;
	}
	splx(s);
	return;

 bad:
	if (pf_status.debug >= PF_DEBUG_MISC)
		printf("pfsync_insert: PFSYNC_ACT_TDB_UPD: "
		    "invalid value\n");
	pfsyncstats.pfsyncs_badstate++;
	return;
}

/* One of our local tdbs have been updated, need to sync rpl with others */
int
pfsync_update_tdb(struct tdb *tdb)
{
	struct ifnet *ifp = &pfsyncif.sc_if;
	struct pfsync_softc *sc = ifp->if_softc;
	struct pfsync_header *h;
	struct pfsync_tdb *pt = NULL;
	int s, i, ret;

	if (ifp->if_bpf == NULL && sc->sc_sync_ifp == NULL &&
	    sc->sc_sync_peer.s_addr == INADDR_PFSYNC_GROUP) {
		/* Don't leave any stale pfsync packets hanging around. */
		if (sc->sc_mbuf_tdb != NULL) {
			m_freem(sc->sc_mbuf_tdb);
			sc->sc_mbuf_tdb = NULL;
			sc->sc_statep_tdb.t = NULL;
		}
		return (0);
	}

	s = splnet();
	if (sc->sc_mbuf_tdb == NULL) {
		if ((sc->sc_mbuf_tdb = pfsync_get_mbuf(sc, PFSYNC_ACT_TDB_UPD,
		    (void *)&sc->sc_statep_tdb.t)) == NULL) {
			splx(s);
			return (ENOMEM);
		}
		h = mtod(sc->sc_mbuf_tdb, struct pfsync_header *);
	} else {
		h = mtod(sc->sc_mbuf_tdb, struct pfsync_header *);
		if (h->action != PFSYNC_ACT_TDB_UPD) {
			/*
			 * XXX will never happen as long as there's
			 * only one "TDB action".
			 */
			pfsync_tdb_sendout(sc);
			sc->sc_mbuf_tdb = pfsync_get_mbuf(sc,
			    PFSYNC_ACT_TDB_UPD, (void *)&sc->sc_statep_tdb.t);
			if (sc->sc_mbuf_tdb == NULL) {
				splx(s);
				return (ENOMEM);
			}
			h = mtod(sc->sc_mbuf_tdb, struct pfsync_header *);
		} else if (sc->sc_maxupdates) {
			/*
			 * If it's an update, look in the packet to see if
			 * we already have an update for the state.
			 */
			struct pfsync_tdb *u =
			    (void *)((char *)h + PFSYNC_HDRLEN);
			int hash = tdb_hash(tdb->tdb_spi, &tdb->tdb_dst,
			    tdb->tdb_sproto);

			for (i = 0; !pt && i < h->count; i++) {
				/* XXX Ugly, u is network ordered. */
				if (u->dst.sa.sa_family == AF_INET)
					u->dst.sin.sin_addr.s_addr =
					    ntohl(u->dst.sin.sin_addr.s_addr);
				if (tdb_hash(ntohl(u->spi), &u->dst,
				    u->sproto) == hash) {
					pt = u;
					pt->updates++;
				}
				if (u->dst.sa.sa_family == AF_INET)
					u->dst.sin.sin_addr.s_addr =
					    htonl(u->dst.sin.sin_addr.s_addr);
				u++;
			}
		}
	}

	if (pt == NULL) {
		/* not a "duplicate" update */
		pt = sc->sc_statep_tdb.t++;
		sc->sc_mbuf_tdb->m_pkthdr.len =
		    sc->sc_mbuf_tdb->m_len += sizeof(struct pfsync_tdb);
		h->count++;
		bzero(pt, sizeof(*pt));

		pt->spi = htonl(tdb->tdb_spi);
		memcpy(&pt->dst, &tdb->tdb_dst, sizeof pt->dst);
		if (pt->dst.sa.sa_family == AF_INET)
			pt->dst.sin.sin_addr.s_addr =
			    htonl(pt->dst.sin.sin_addr.s_addr);
		pt->sproto = tdb->tdb_sproto;
	}

	pt->rpl = htonl(tdb->tdb_rpl);
	pt->cur_bytes = htobe64(tdb->tdb_cur_bytes);

	if (h->count == sc->sc_maxcount ||
	    (sc->sc_maxupdates && (pt->updates >= sc->sc_maxupdates)))
		ret = pfsync_tdb_sendout(sc);

	splx(s);
	return (ret);
}
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.c,v 1.32 2004/04/30 22:08:18 mcbride Exp $	*/
a28 2
#include "bpfilter.h"
#include "pfsync.h"
d38 1
d44 2
a49 1
#include <netinet/in.h>
a56 3
#ifndef INET
#include <netinet/in.h>
#endif
d68 3
d86 4
a89 1
int	pfsync_insert_net_state(struct pfsync_state *);
d98 2
d101 1
a107 3
extern struct timeval time;
extern struct timeval mono_time;
extern int hz;
d118 1
d121 1
d123 1
d127 2
d138 1
a138 1
	pfsync_setmtu(&pfsyncif, MCLBYTES);
d140 1
d174 15
a188 1
pfsync_insert_net_state(struct pfsync_state *sp)
d200 1
a200 1
	kif = pfi_lookup_create(sp->ifname);
d210 2
a211 2
	 * Just use the default rule until we have infrastructure to find the
	 * best matching rule.
d213 5
a217 1
	r = &pf_default_rule;
d222 1
a222 1
		pfi_maybe_destroy(kif);
d227 10
d240 3
d252 2
a253 2
	st->creation = ntohl(sp->creation) + time.tv_sec;
	st->expire = ntohl(sp->expire) + time.tv_sec;
d264 1
a264 2
	st->sync_flags = sp->sync_flags | PFSTATE_FROMSYNC;

d267 7
a273 1
		pfi_maybe_destroy(kif);
d287 2
a288 1
	struct pf_state *st, key;
d295 1
d299 1
d353 3
d358 1
d371 7
a377 3
			RB_FOREACH(st, pf_state_tree_id, &tree_id) {
				if (st->creatorid == creatorid)
					st->timeout = PFTM_PURGE;
d380 1
a380 5
			kif = pfi_lookup_if(cp->ifname);
			if (kif == NULL) {
				if (pf_status.debug >= PF_DEBUG_MISC)
					printf("pfsync_input: PFSYNC_ACT_CLR "
					    "bad interface: %s\n", cp->ifname);
d382 1
a382 1
				goto done;
d384 4
a387 2
			RB_FOREACH(st, pf_state_tree_lan_ext,
			    &kif->pfik_lan_ext) {
d389 2
a390 2
					st->timeout = PFTM_PURGE;
					pf_purge_expired_state(st);
d421 2
a422 1
			if ((error = pfsync_insert_net_state(sp))) {
d442 2
d461 1
a461 1
				if (pfsync_insert_net_state(sp))
a475 2
				else if (st->dst.state > sp->dst.state)
					sfail = 2;
d479 12
a490 1
				else if (st->dst.state >= TCPS_SYN_SENT &&
d500 1
a500 1
				else if ( st->dst.state > sp->dst.state)
d505 1
a505 1
					printf("pfsync: ignoring stale update "
d507 3
a509 1
					    "creatorid: %08x\n", sfail,
d514 9
a522 5
				/* we have a better state, send it out */
				if (sc->sc_mbuf != NULL && !stale)
					pfsync_sendout(sc);
				stale++;
				pfsync_pack_state(PFSYNC_ACT_UPD, st, 0);
d525 1
d528 1
a528 1
			st->expire = ntohl(sp->expire) + time.tv_sec;
a556 1
			st->timeout = PFTM_PURGE;
d558 1
a558 1
			pf_purge_expired_state(st);
d646 3
a648 1
				pfsync_pack_state(PFSYNC_ACT_UPD, st, 0);
d651 1
d654 1
a654 1
			st->expire = ntohl(up->expire) + time.tv_sec;
a679 1
			st->timeout = PFTM_PURGE;
d681 1
a681 1
			pf_purge_expired_state(st);
d707 4
d722 3
a724 1
				pfsync_pack_state(PFSYNC_ACT_UPD, st, 0);
d774 12
d837 1
a837 1
			strlcpy(pfsyncr.pfsyncr_syncif,
d839 1
d850 6
d860 1
a860 1
		if (pfsyncr.pfsyncr_syncif[0] == 0) {
d870 4
d876 2
a877 1
		if ((sifp = ifunit(pfsyncr.pfsyncr_syncif)) == NULL)
a878 2
		else if (sifp == sc->sc_sync_ifp)
			break;
d895 2
a896 1
		if (sc->sc_sync_ifp) {
d899 6
d906 1
d909 1
d917 1
d919 2
d934 1
a934 1
				return(ENOMEM);
d1001 4
d1029 3
d1034 4
a1037 1
	timeout_add(&sc->sc_tmo, hz);
d1042 1
a1042 1
pfsync_pack_state(u_int8_t action, struct pf_state *st, int compress)
d1059 2
a1060 1
	if (ifp->if_bpf == NULL && sc->sc_sync_ifp == NULL) {
d1114 1
a1114 1
	secs = time.tv_sec;
a1116 2
	TAILQ_REMOVE(&state_updates, st, u.s.entry_updates);
	TAILQ_INSERT_TAIL(&state_updates, st, u.s.entry_updates);
d1138 4
a1141 4
		sp->packets[0] = htonl(st->packets[0]);
		sp->packets[1] = htonl(st->packets[1]);
		sp->bytes[0] = htonl(st->bytes[0]);
		sp->bytes[1] = htonl(st->bytes[1]);
d1157 2
a1158 1
		sp->sync_flags = st->sync_flags & PFSTATE_NOSYNC;
d1170 1
a1170 1
	if (sc->sc_sync_ifp && compress) {
d1244 1
a1244 1
	int ret;
d1317 11
d1364 7
a1370 13
	while ((state = TAILQ_FIRST(&state_updates)) != NULL &&
	    ++i < (sc->sc_maxcount * PFSYNC_BULKPACKETS)) {
		if (state->pfsync_time > sc->sc_ureq_received) {
			/* we're done */
			pfsync_send_bus(sc, PFSYNC_BUS_END);
			sc->sc_ureq_received = 0;
			timeout_del(&sc->sc_bulk_tmo);
			if (pf_status.debug >= PF_DEBUG_MISC)
				printf("pfsync: bulk update complete\n");
			break;
		} else {
			/* send an update and move to end of list */
			if (!state->sync_flags)
d1372 2
a1373 4
			state->pfsync_time = mono_time.tv_sec;
			TAILQ_REMOVE(&state_updates, state, u.s.entry_updates);
			TAILQ_INSERT_TAIL(&state_updates, state,
			    u.s.entry_updates);
d1375 22
a1396 3
			/* look again for more in a bit */
			timeout_add(&sc->sc_bulk_tmo, 1);
		}
d1418 1
a1418 1
		} else 
d1439 1
a1439 2
pfsync_sendout(sc)
	struct pfsync_softc *sc;
d1464 30
a1493 4
	if (sc->sc_sync_ifp) {
		struct ip *ip;
		struct ifaddr *ifa;
		struct sockaddr sa;
d1495 2
d1514 1
a1514 5
		sa.sa_family = AF_INET;
		ifa = ifaof_ifpforaddr(&sa, sc->sc_sync_ifp);
		if (ifa == NULL)
			return (0);
		ip->ip_src.s_addr = ifatoia(ifa)->ia_addr.sin_addr.s_addr;
d1519 1
a1519 1
		sc->sc_sendaddr.s_addr = INADDR_PFSYNC_GROUP;
d1530 161
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@For ftp-proxy(8) we need newer OpenIPF. I think it's time to import
pf-current from OpenBSD, since it's so buggy anyway... but I tagged
the old files in case something goes wrong.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_pfsync.c,v 1.59 2005/11/04 08:24:14 mcbride Exp $	*/
d29 2
a39 1
#include <sys/kernel.h>
a44 2
#include <netinet/in.h>
#include <netinet/if_ether.h>
d49 1
d57 3
a70 3
#include "bpfilter.h"
#include "pfsync.h"

d86 1
a86 4
int	pfsync_alloc_scrub_memory(struct pfsync_state_peer *,
	    struct pf_state_peer *);
int	pfsync_insert_net_state(struct pfsync_state *, u_int8_t);
void	pfsync_update_net_tdb(struct pfsync_tdb *);
a94 2
int	pfsync_tdb_sendout(struct pfsync_softc *);
int	pfsync_sendout_mbuf(struct pfsync_softc *, struct mbuf *);
a95 1
void	pfsync_tdb_timeout(void *);
d102 3
a114 1
	pfsyncif.sc_mbuf_tdb = NULL;
a116 1
	pfsyncif.sc_statep_tdb.t = NULL;
a117 1
	pfsyncif.sc_sync_peer.s_addr = INADDR_PFSYNC_GROUP;
a120 2
	pfsyncif.sc_bulk_send_next = NULL;
	pfsyncif.sc_bulk_terminator = NULL;
d130 1
a130 1
	pfsync_setmtu(&pfsyncif, ETHERMTU);
a131 1
	timeout_set(&pfsyncif.sc_tdb_tmo, pfsync_tdb_timeout, &pfsyncif);
d165 1
a165 15
pfsync_alloc_scrub_memory(struct pfsync_state_peer *s,
    struct pf_state_peer *d)
{
	if (s->scrub.scrub_flag && d->scrub == NULL) {
		d->scrub = pool_get(&pf_state_scrub_pl, PR_NOWAIT);
		if (d->scrub == NULL)
			return (ENOMEM);
		bzero(d->scrub, sizeof(*d->scrub));
	}

	return (0);
}

int
pfsync_insert_net_state(struct pfsync_state *sp, u_int8_t chksum_flag)
d177 1
a177 1
	kif = pfi_kif_get(sp->ifname);
d187 2
a188 2
	 * If the ruleset checksums match, it's safe to associate the state
	 * with the rule of that number.
d190 1
a190 5
	if (sp->rule != htonl(-1) && sp->anchor == htonl(-1) && chksum_flag)
		r = pf_main_ruleset.rules[
		    PF_RULESET_FILTER].active.ptr_array[ntohl(sp->rule)];
	else
		r = &pf_default_rule;
d195 1
a195 1
		pfi_kif_unref(kif, PFI_KIF_REF_NONE);
a199 10
	/* allocate memory for scrub info */
	if (pfsync_alloc_scrub_memory(&sp->src, &st->src) ||
	    pfsync_alloc_scrub_memory(&sp->dst, &st->dst)) {
		pfi_kif_unref(kif, PFI_KIF_REF_NONE);
		if (st->src.scrub)
			pool_put(&pf_state_scrub_pl, st->src.scrub);
		pool_put(&pf_state_pl, st);
		return (ENOMEM);
	}

a202 3
	/* XXX when we have nat_rule/anchors, use STATE_INC_COUNTERS */
	r->states++;

d212 2
a213 2
	st->creation = time_second - ntohl(sp->creation);
	st->expire = ntohl(sp->expire) + time_second;
d224 2
a225 1
	st->sync_flags = PFSTATE_FROMSYNC;
d228 1
a228 7
		pfi_kif_unref(kif, PFI_KIF_REF_NONE);
		/* XXX when we have nat_rule/anchors, use STATE_DEC_COUNTERS */
		r->states--;
		if (st->dst.scrub)
			pool_put(&pf_state_scrub_pl, st->dst.scrub);
		if (st->src.scrub)
			pool_put(&pf_state_scrub_pl, st->src.scrub);
d242 1
a242 2
	struct pf_state *st;
	struct pf_state_cmp key;
a248 1
	struct pfsync_tdb *pt;
a251 1
	u_int8_t chksum_flag = 0;
a304 3
	if (!bcmp(&ph->pf_chksum, &pf_status.pf_chksum, PF_MD5_DIGEST_LENGTH))
		chksum_flag++;

a306 1
		struct pf_state *nexts;
d319 3
a321 7
			for (st = RB_MIN(pf_state_tree_id, &tree_id);
			    st; st = nexts) {
				nexts = RB_NEXT(pf_state_tree_id, &tree_id, st);
				if (st->creatorid == creatorid) {
					st->sync_flags |= PFSTATE_FROMSYNC;
					pf_unlink_state(st);
				}
d324 5
a328 1
			if ((kif = pfi_kif_get(cp->ifname)) == NULL) {
d330 1
a330 1
				return;
d332 2
a333 4
			for (st = RB_MIN(pf_state_tree_lan_ext,
			    &kif->pfik_lan_ext); st; st = nexts) {
				nexts = RB_NEXT(pf_state_tree_lan_ext,
				    &kif->pfik_lan_ext, st);
d335 2
a336 2
					st->sync_flags |= PFSTATE_FROMSYNC;
					pf_unlink_state(st);
d367 1
a367 2
			if ((error = pfsync_insert_net_state(sp,
			    chksum_flag))) {
a386 2
			int flags = PFSYNC_FLAG_STALE;

d404 1
a404 1
				if (pfsync_insert_net_state(sp, chksum_flag))
d419 2
d424 1
a424 12
				else if (st->dst.state > sp->dst.state) {
					/* There might still be useful
					 * information about the src state here,
					 * so import that part of the update,
					 * then "fail" so we send the updated
					 * state back to the peer who is missing
					 * our what we know. */
					pf_state_peer_ntoh(&sp->src, &st->src);
					/* XXX do anything with timeouts? */
					sfail = 7;
					flags = 0;
				} else if (st->dst.state >= TCPS_SYN_SENT &&
d434 1
a434 1
				else if (st->dst.state > sp->dst.state)
d439 1
a439 1
					printf("pfsync: %s stale update "
d441 1
a441 3
					    "creatorid: %08x\n",
					    (sfail < 7 ?  "ignoring"
					     : "partial"), sfail,
d446 5
a450 9
				if (!(sp->sync_flags & PFSTATE_STALE)) {
					/* we have a better state, send it */
					if (sc->sc_mbuf != NULL && !stale)
						pfsync_sendout(sc);
					stale++;
					if (!st->sync_flags)
						pfsync_pack_state(
						    PFSYNC_ACT_UPD, st, flags);
				}
a452 1
	    		pfsync_alloc_scrub_memory(&sp->dst, &st->dst);
d455 1
a455 1
			st->expire = ntohl(sp->expire) + time_second;
d484 1
d486 1
a486 1
			pf_unlink_state(st);
d574 1
a574 3
				if (!st->sync_flags)
					pfsync_pack_state(PFSYNC_ACT_UPD, st,
					    PFSYNC_FLAG_STALE);
a576 1
	    		pfsync_alloc_scrub_memory(&up->dst, &st->dst);
d579 1
a579 1
			st->expire = ntohl(up->expire) + time_second;
d605 1
d607 1
a607 1
			pf_unlink_state(st);
d632 1
a632 5
				sc->sc_ureq_received = time_uptime;
				if (sc->sc_bulk_send_next == NULL)
					sc->sc_bulk_send_next =
					    TAILQ_FIRST(&state_list);
				sc->sc_bulk_terminator = sc->sc_bulk_send_next;
d644 1
a644 3
				if (!st->sync_flags)
					pfsync_pack_state(PFSYNC_ACT_UPD,
					    st, 0);
d672 1
a672 1
			if (time_uptime - ntohl(bus->endtime) >=
a693 12
	case PFSYNC_ACT_TDB_UPD:
		if ((mp = m_pulldown(m, iplen + sizeof(*ph),
		    count * sizeof(*pt), &offp)) == NULL) {
			pfsyncstats.pfsyncs_badlen++;
			return;
		}
		s = splsoftnet();
		for (i = 0, pt = (struct pfsync_tdb *)(mp->m_data + offp);
		    i < count; i++, pt++)
			pfsync_update_net_tdb(pt);
		splx(s);
		break;
d745 1
a745 1
			strlcpy(pfsyncr.pfsyncr_syncdev,
a746 1
		pfsyncr.pfsyncr_syncpeer = sc->sc_sync_peer;
a756 6
		if (pfsyncr.pfsyncr_syncpeer.s_addr == 0)
			sc->sc_sync_peer.s_addr = INADDR_PFSYNC_GROUP;
		else
			sc->sc_sync_peer.s_addr =
			    pfsyncr.pfsyncr_syncpeer.s_addr;

d761 1
a761 1
		if (pfsyncr.pfsyncr_syncdev[0] == 0) {
a770 4
			if (imo->imo_num_memberships > 0) {
				in_delmulti(imo->imo_membership[--imo->imo_num_memberships]);
				imo->imo_multicast_ifp = NULL;
			}
d773 1
a773 2

		if ((sifp = ifunit(pfsyncr.pfsyncr_syncdev)) == NULL)
d775 2
d793 1
a793 2
		if (sc->sc_sync_ifp &&
		    sc->sc_sync_peer.s_addr == INADDR_PFSYNC_GROUP) {
a795 6
			if (!(sc->sc_sync_ifp->if_flags & IFF_MULTICAST)) {
				sc->sc_sync_ifp = NULL;
				splx(s);
				return (EADDRNOTAVAIL);
			}

a796 1

a798 1
				sc->sc_sync_ifp = NULL;
a805 1
		}
a806 2
		if (sc->sc_sync_ifp ||
		    sc->sc_sendaddr.s_addr != INADDR_PFSYNC_GROUP) {
d808 1
a808 1
			sc->sc_ureq_sent = time_uptime;
d820 1
a820 1
				return (ENOMEM);
a886 4
	case PFSYNC_ACT_TDB_UPD:
		len = (sc->sc_maxcount * sizeof(struct pfsync_tdb)) +
		    sizeof(struct pfsync_header);
		break;
a910 3
	if (action != PFSYNC_ACT_TDB_UPD)
		bcopy(&pf_status.pf_chksum, &h->pf_chksum,
		    PF_MD5_DIGEST_LENGTH);
d913 1
a913 4
	if (action == PFSYNC_ACT_TDB_UPD)
		timeout_add(&sc->sc_tdb_tmo, hz);
	else
		timeout_add(&sc->sc_tmo, hz);
d918 1
a918 1
pfsync_pack_state(u_int8_t action, struct pf_state *st, int flags)
d935 1
a935 2
	if (ifp->if_bpf == NULL && sc->sc_sync_ifp == NULL &&
	    sc->sc_sync_peer.s_addr == INADDR_PFSYNC_GROUP) {
d989 1
a989 1
	secs = time_second;
d991 3
a993 1
	st->pfsync_time = time_uptime;
d1015 4
a1018 4
		pf_state_counter_hton(st->packets[0], sp->packets[0]);
		pf_state_counter_hton(st->packets[1], sp->packets[1]);
		pf_state_counter_hton(st->bytes[0], sp->bytes[0]);
		pf_state_counter_hton(st->bytes[1], sp->bytes[1]);
d1034 1
a1034 2
		if (flags & PFSYNC_FLAG_STALE)
			sp->sync_flags |= PFSTATE_STALE;
d1046 1
a1046 1
	if (sc->sc_sync_ifp && flags & PFSYNC_FLAG_COMPRESS) {
d1120 1
a1120 1
	int ret = 0;
a1192 11
void
pfsync_tdb_timeout(void *v)
{
	struct pfsync_softc *sc = v;
	int s;

	s = splnet();
	pfsync_tdb_sendout(sc);
	splx(s);
}

d1209 1
a1209 1
		bus->endtime = htonl(time_uptime - sc->sc_ureq_received);
d1229 13
a1241 7
	state = sc->sc_bulk_send_next;
	if (state)
		do {
			/* send state update if syncable and not already sent */
			if (!state->sync_flags
			    && state->timeout < PFTM_MAX
			    && state->pfsync_time <= sc->sc_ureq_received) {
d1243 4
a1246 2
				i++;
			}
d1248 3
a1250 22
			/* figure next state to send */
			state = TAILQ_NEXT(state, u.s.entry_list);

			/* wrap to start of list if we hit the end */
			if (!state)
				state = TAILQ_FIRST(&state_list);
		} while (i < sc->sc_maxcount * PFSYNC_BULKPACKETS &&
		    state != sc->sc_bulk_terminator);

	if (!state || state == sc->sc_bulk_terminator) {
		/* we're done */
		pfsync_send_bus(sc, PFSYNC_BUS_END);
		sc->sc_ureq_received = 0;
		sc->sc_bulk_send_next = NULL;
		sc->sc_bulk_terminator = NULL;
		timeout_del(&sc->sc_bulk_tmo);
		if (pf_status.debug >= PF_DEBUG_MISC)
			printf("pfsync: bulk update complete\n");
	} else {
		/* look again for more in a bit */
		timeout_add(&sc->sc_bulk_tmo, 1);
		sc->sc_bulk_send_next = state;
d1272 1
a1272 1
		} else
d1293 2
a1294 1
pfsync_sendout(struct pfsync_softc *sc)
d1319 4
a1322 30
	return pfsync_sendout_mbuf(sc, m);
}

int
pfsync_tdb_sendout(struct pfsync_softc *sc)
{
	struct ifnet *ifp = &sc->sc_if;
	struct mbuf *m;

	timeout_del(&sc->sc_tdb_tmo);

	if (sc->sc_mbuf_tdb == NULL)
		return (0);
	m = sc->sc_mbuf_tdb;
	sc->sc_mbuf_tdb = NULL;
	sc->sc_statep_tdb.t = NULL;

#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m);
#endif

	return pfsync_sendout_mbuf(sc, m);
}

int
pfsync_sendout_mbuf(struct pfsync_softc *sc, struct mbuf *m)
{
	struct sockaddr sa;
	struct ip *ip;
a1323 2
	if (sc->sc_sync_ifp ||
	    sc->sc_sync_peer.s_addr != INADDR_PFSYNC_GROUP) {
d1341 5
a1345 1
		ip->ip_src.s_addr = INADDR_ANY;
d1350 1
a1350 1
		sc->sc_sendaddr.s_addr = sc->sc_sync_peer.s_addr;
a1360 161

/* Update an in-kernel tdb. Silently fail if no tdb is found. */
void
pfsync_update_net_tdb(struct pfsync_tdb *pt)
{
	struct tdb		*tdb;
	int			 s;

	/* check for invalid values */
	pt->spi = htonl(pt->spi);
	if (pt->spi <= SPI_RESERVED_MAX ||
	    (pt->dst.sa.sa_family != AF_INET &&
	     pt->dst.sa.sa_family != AF_INET6))
		goto bad;

	if (pt->dst.sa.sa_family == AF_INET)
		pt->dst.sin.sin_addr.s_addr =
		    htonl(pt->dst.sin.sin_addr.s_addr);

	s = spltdb();
	tdb = gettdb(pt->spi, &pt->dst, pt->sproto);
	if (tdb) {
		/*
		 * When a failover happens, the master's rpl is probably above
		 * what we see here (we may be up to a second late), so
		 * increase it a bit to manage most such situations.
		 *
		 * For now, just add an offset that is likely to be larger
		 * than the number of packets we can see in one second. The RFC
		 * just says the next packet must have a higher seq value.
		 *
		 * XXX What is a good algorithm for this? We could use
		 * a rate-determined increase, but to know it, we would have
		 * to extend struct tdb.
		 * XXX pt->rpl can wrap over MAXINT, but if so the real tdb
		 * will soon be replaced anyway. For now, just don't handle
		 * this edge case.
		 */
#define RPL_INCR 16384
		pt->rpl = ntohl(pt->rpl) + RPL_INCR;
		pt->cur_bytes = betoh64(pt->cur_bytes);

		/* Neither replay nor byte counter should ever decrease. */
		if (pt->rpl < tdb->tdb_rpl ||
		    pt->cur_bytes < tdb->tdb_cur_bytes) {
			splx(s);
			goto bad;
		}

		tdb->tdb_rpl = pt->rpl;
		tdb->tdb_cur_bytes = pt->cur_bytes;
	}
	splx(s);
	return;

 bad:
	if (pf_status.debug >= PF_DEBUG_MISC)
		printf("pfsync_insert: PFSYNC_ACT_TDB_UPD: "
		    "invalid value\n");
	pfsyncstats.pfsyncs_badstate++;
	return;
}

/* One of our local tdbs have been updated, need to sync rpl with others */
int
pfsync_update_tdb(struct tdb *tdb)
{
	struct ifnet *ifp = &pfsyncif.sc_if;
	struct pfsync_softc *sc = ifp->if_softc;
	struct pfsync_header *h;
	struct pfsync_tdb *pt = NULL;
	int s, i, ret;

	if (ifp->if_bpf == NULL && sc->sc_sync_ifp == NULL &&
	    sc->sc_sync_peer.s_addr == INADDR_PFSYNC_GROUP) {
		/* Don't leave any stale pfsync packets hanging around. */
		if (sc->sc_mbuf_tdb != NULL) {
			m_freem(sc->sc_mbuf_tdb);
			sc->sc_mbuf_tdb = NULL;
			sc->sc_statep_tdb.t = NULL;
		}
		return (0);
	}

	s = splnet();
	if (sc->sc_mbuf_tdb == NULL) {
		if ((sc->sc_mbuf_tdb = pfsync_get_mbuf(sc, PFSYNC_ACT_TDB_UPD,
		    (void *)&sc->sc_statep_tdb.t)) == NULL) {
			splx(s);
			return (ENOMEM);
		}
		h = mtod(sc->sc_mbuf_tdb, struct pfsync_header *);
	} else {
		h = mtod(sc->sc_mbuf_tdb, struct pfsync_header *);
		if (h->action != PFSYNC_ACT_TDB_UPD) {
			/*
			 * XXX will never happen as long as there's
			 * only one "TDB action".
			 */
			pfsync_tdb_sendout(sc);
			sc->sc_mbuf_tdb = pfsync_get_mbuf(sc,
			    PFSYNC_ACT_TDB_UPD, (void *)&sc->sc_statep_tdb.t);
			if (sc->sc_mbuf_tdb == NULL) {
				splx(s);
				return (ENOMEM);
			}
			h = mtod(sc->sc_mbuf_tdb, struct pfsync_header *);
		} else if (sc->sc_maxupdates) {
			/*
			 * If it's an update, look in the packet to see if
			 * we already have an update for the state.
			 */
			struct pfsync_tdb *u =
			    (void *)((char *)h + PFSYNC_HDRLEN);
			int hash = tdb_hash(tdb->tdb_spi, &tdb->tdb_dst,
			    tdb->tdb_sproto);

			for (i = 0; !pt && i < h->count; i++) {
				/* XXX Ugly, u is network ordered. */
				if (u->dst.sa.sa_family == AF_INET)
					u->dst.sin.sin_addr.s_addr =
					    ntohl(u->dst.sin.sin_addr.s_addr);
				if (tdb_hash(ntohl(u->spi), &u->dst,
				    u->sproto) == hash) {
					pt = u;
					pt->updates++;
				}
				if (u->dst.sa.sa_family == AF_INET)
					u->dst.sin.sin_addr.s_addr =
					    htonl(u->dst.sin.sin_addr.s_addr);
				u++;
			}
		}
	}

	if (pt == NULL) {
		/* not a "duplicate" update */
		pt = sc->sc_statep_tdb.t++;
		sc->sc_mbuf_tdb->m_pkthdr.len =
		    sc->sc_mbuf_tdb->m_len += sizeof(struct pfsync_tdb);
		h->count++;
		bzero(pt, sizeof(*pt));

		pt->spi = htonl(tdb->tdb_spi);
		memcpy(&pt->dst, &tdb->tdb_dst, sizeof pt->dst);
		if (pt->dst.sa.sa_family == AF_INET)
			pt->dst.sin.sin_addr.s_addr =
			    htonl(pt->dst.sin.sin_addr.s_addr);
		pt->sproto = tdb->tdb_sproto;
	}

	pt->rpl = htonl(tdb->tdb_rpl);
	pt->cur_bytes = htobe64(tdb->tdb_cur_bytes);

	if (h->count == sc->sc_maxcount ||
	    (sc->sc_maxupdates && (pt->updates >= sc->sc_maxupdates)))
		ret = pfsync_tdb_sendout(sc);

	splx(s);
	return (ret);
}
@

