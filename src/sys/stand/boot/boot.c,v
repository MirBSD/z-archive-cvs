head	1.23;
access;
symbols
	tg-use_ldscript:1.22.0.2
	tg-beforemerge-ksrc10:1.1.1.2
	cvs-200808011000:1.1.1.2
	MIRBSD_10:1.11.0.2
	MIRBSD_10_BASE:1.11
	MIRBSD_9_BASE:1.7
	MIRBSD_8:1.2.0.2
	MIRBSD_8_BASE:1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2018.04.28.02.14.36;	author tg;	state Exp;
branches;
next	1.22;
commitid	1005AE3D91A742324FF;

1.22
date	2009.10.24.16.04.38;	author tg;	state Exp;
branches;
next	1.21;
commitid	1004AE3258C5BEAE46D;

1.21
date	2009.10.24.15.39.40;	author tg;	state Exp;
branches;
next	1.20;
commitid	1004AE31FBD2F85D47B;

1.20
date	2009.02.01.10.31.13;	author tg;	state Exp;
branches;
next	1.19;
commitid	100498579EA106BEEDE;

1.19
date	2009.01.31.18.48.13;	author tg;	state Exp;
branches;
next	1.18;
commitid	10049849CFD216B8270;

1.18
date	2009.01.14.22.22.42;	author tg;	state Exp;
branches;
next	1.17;
commitid	100496E65BC344A5FF9;

1.17
date	2009.01.12.17.36.04;	author tg;	state Exp;
branches;
next	1.16;
commitid	100496B7F9043C26B46;

1.16
date	2009.01.11.13.09.20;	author tg;	state Exp;
branches;
next	1.15;
commitid	1004969EF8A0591EE40;

1.15
date	2008.12.31.16.38.34;	author tg;	state Exp;
branches;
next	1.14;
commitid	100495BA02136D7BE32;

1.14
date	2008.08.01.12.39.09;	author tg;	state Exp;
branches;
next	1.13;
commitid	100489303F432B4030A;

1.13
date	2008.08.01.11.56.10;	author tg;	state Exp;
branches;
next	1.12;
commitid	1004892F9EB64DCA2B2;

1.12
date	2008.08.01.11.25.04;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004892F2924667C00D;

1.11
date	2007.08.24.13.59.58;	author tg;	state Exp;
branches;
next	1.10;
commitid	10046CEE45A5FBA725C;

1.10
date	2006.11.21.02.53.39;	author tg;	state Exp;
branches;
next	1.9;
commitid	10045626A132AE542D0;

1.9
date	2006.10.13.19.18.04;	author tg;	state Exp;
branches;
next	1.8;
commitid	100452FE67757921301;

1.8
date	2006.08.19.12.45.48;	author tg;	state Exp;
branches;
next	1.7;
commitid	10044E7080820F3E8BE;

1.7
date	2006.04.10.19.15.16;	author tg;	state Exp;
branches;
next	1.6;
commitid	100443AAED715F67477;

1.6
date	2006.04.10.18.43.35;	author tg;	state Exp;
branches;
next	1.5;
commitid	100443AA75F4C8F5E69;

1.5
date	2006.04.06.22.02.33;	author tg;	state Exp;
branches;
next	1.4;
commitid	10044358FD707BCCCC3;

1.4
date	2006.04.06.00.05.33;	author tg;	state Exp;
branches;
next	1.3;
commitid	10044345B5E19C12E71;

1.3
date	2006.04.05.22.12.16;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004434408D12C01CCC;

1.2
date	2005.03.06.21.28.32;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.29.15;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.29.15;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2008.08.01.10.28.38;	author tg;	state Exp;
branches;
next	;
commitid	1004892E54805BE97AB;


desc
@@


1.23
log
@i386 and documentation part for -D argument to boot
@
text
@/**	$MirOS: src/sys/stand/boot/boot.c,v 1.21 2009/10/24 15:39:40 tg Exp $	*/
/*	$OpenBSD: boot.c,v 1.36 2007/06/26 10:34:41 tom Exp $	*/

/*
 * Copyright (c) 2002, 2003, 2004, 2006, 2009, 2018 mirabilos
 * Copyright (c) 2003 Dale Rahn
 * Copyright (c) 1997,1998 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/reboot.h>
#include <sys/stat.h>
#include <libsa.h>
#include <lib/libsa/loadfile.h>
#ifdef IN_PXEBOOT
#include <pxe.h>

extern int have_pxe;
extern BOOTPLAYER bootplayer;
#endif

#include "cmd.h"

#ifndef MBSD_PREFIX
#define MBSD_PREFIX ""
#endif

static const char *const kernels[] = {
	MBSD_PREFIX "/bsd",
#if !defined(SMALL_BOOT)
	MBSD_PREFIX "/bsd.old",
#endif
	NULL
};

char prog_ident[40];
char *progname = "BOOT";

extern const char version[];
extern int doboot;
int bootprompt = 1;
uint32_t hook_value = 0;

void
boot(dev_t bootdev)
{
	const char *bootfile = kernels[0];
	int fd, i = 0, try = 0, st = -1;
	u_long marks[MARK_MAX];
#ifdef IN_PXEBOOT
	uint32_t ip;
#endif
#if defined(IN_PXEBOOT) || !defined(SMALL_BOOT)
	char myconf[64];
#endif

	machdep();

	snprintf(prog_ident, sizeof(prog_ident),
	    "MirBSD boot %s", version);
	printf(">> %s\n>> booting from device %Xh",
	    prog_ident, bootdev);

	devboot(bootdev, cmd.bootdev);
	printf(" = %s\n", cmd.bootdev);
	memcpy(cmd.image, bootfile, strlen(bootfile) + 1);

	cmd.conf = NULL;
	if (strlen(cmd_buf)) {
		/* command line was passed from previous loader */
		cmd.cmd = NULL;
		cmd.timeout = 0;
		doboot = 0;
		if (docmd())
			goto try_boot;
		st = 0;
		bootprompt = 1;
		goto try_cmd;
	}
#ifdef IN_PXEBOOT
	ip = bootplayer.yip;

	/*
	 * Let's be non-intrusive.. We try to get our /$IP/boot.cfg
	 * first, and if that fails, fall back to /boot.cfg, and
	 * if that fails, do no boot.cfg at all.
	 * Pim van Pelt / Paul de Weerd 20040328
	 */
	if (have_pxe > 0) {
		cmd.boothowto = 0;
		snprintf(myconf, sizeof (myconf),
		    MBSD_PREFIX "/%d.%d.%d.%d/boot.cfg",
		    ip & 0xff, (ip >> 8) & 0xff, (ip >> 16) & 0xff, ip >> 24);
		cmd.conf = myconf;
		cmd.addr = (void *)DEFAULT_KERNEL_ADDRESS;
		cmd.timeout = 5;

		st = read_conf();
	} else
#endif
#if !defined(SMALL_BOOT)
	if (hook_value) {
		cmd.boothowto = 0;
		snprintf(myconf, sizeof (myconf), MBSD_PREFIX "/boot.%d",
		    (hook_value % 999));
		cmd.conf = myconf;
		cmd.addr = (void *)DEFAULT_KERNEL_ADDRESS;
		cmd.timeout = 5;

		st = read_conf();
	}
#endif

	if (st < 0) {
#if defined(IN_PXEBOOT) || !defined(SMALL_BOOT)
		if (cmd.conf)
			printf("Attempt to read %s failed.\n", cmd.conf);
#endif
		cmd.boothowto = 0;
		cmd.conf = MBSD_PREFIX "/boot.cfg";
		cmd.addr = (void *)DEFAULT_KERNEL_ADDRESS;
		cmd.timeout = 5;

		st = read_conf();
	}
	if (!bootprompt)
		snprintf(cmd.path, sizeof cmd.path, "%s:%s",
		    cmd.bootdev, cmd.image);

 try_cmd:
	while (1) {
		/* no boot.cfg, or no boot cmd in there */
		if (bootprompt && st <= 0)
			do {
				printf("boot> ");
			} while(!getcmd());
 try_boot:
		st = 0;
		bootprompt = 1;	/* allow reselect should we fail */

		printf("booting %s: ", cmd.path);
		marks[MARK_START] = (u_long)cmd.addr;
		if ((fd = loadfile(cmd.path, marks,
		    (cmd.boothowto & RB_NO_KSYMS) ?
		    (LOAD_ALL & ~LOAD_SYM) : LOAD_ALL)) != -1) {
			close(fd);
			break;
		}

		if (kernels[++i] == NULL) {
			try += 1;
			bootfile = kernels[i = 0];
		} else
			bootfile = kernels[i];
		memcpy(cmd.image, bootfile, strlen(bootfile) + 1);
		printf(" failed(%d).%s%s\n", errno,
		    (cmd.timeout) ? " will try " : "",
		    (cmd.timeout) ? bootfile : "");

		if (cmd.timeout) {
			if (try < 2)
				cmd.timeout++;
			else {
				printf("Turning timeout off.\n");
				cmd.timeout = doboot = 0;
			}
		}
	}

	/* exec */
	run_loadfile(marks, cmd.boothowto);
}
@


1.22
log
@now do something with the command line passed ☺

execute it. (and skip the BOOTSELECT_HOOK.) for <mrud:#grml>
@
text
@d5 1
a5 1
 * Copyright (c) 2002, 2003, 2004, 2006, 2009 Thorsten Glaser
d166 3
a168 1
		if ((fd = loadfile(cmd.path, marks, LOAD_ALL)) != -1) {
@


1.21
log
@save (and display) command line passed to us from
• DOS (PSP)
• SYSLINUX COMBOOT (PSP)
• GRUB (Multiboot)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/stand/boot/boot.c,v 1.20 2009/02/01 10:31:13 tg Exp $	*/
a79 3
	printf("cmd_buf (%X) on entry: size=%d len=%d content='%s'\n\n\n", (unsigned)cmd_buf, sizeof(cmd_buf), strlen(cmd_buf), cmd_buf);
	memhexdump(cmd_buf, 0, strlen(cmd_buf) + 1);

d92 11
d153 1
d160 1
@


1.20
log
@allow the user to change the default location of boot.cfg etc.
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/stand/boot/boot.c,v 1.19 2009/01/31 18:48:13 tg Exp $	*/
d80 3
@


1.19
log
@really do turn off the timeout when saying so
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/stand/boot/boot.c,v 1.18 2009/01/14 22:22:42 tg Exp $	*/
d47 4
d52 1
a52 1
	"/bsd",
d54 1
a54 1
	"/bsd.old",
d77 1
a77 1
	char myconf[32];
d103 2
a104 1
		snprintf(myconf, sizeof(myconf), "/%d.%d.%d.%d/boot.cfg",
d116 1
a116 1
		snprintf(myconf, sizeof (myconf), "/boot.%d",
d132 1
a132 1
		cmd.conf = "/boot.cfg";
@


1.18
log
@get rid of strlcpy here (most things are safe or we sell rope anyway)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/stand/boot/boot.c,v 1.17 2009/01/12 17:36:04 tg Exp $	*/
d5 1
a5 1
 * Copyright (c) 2002, 2003, 2004, 2006 Thorsten Glaser
d58 2
a59 1
extern	const char version[];
d166 1
a166 1
			else
d168 2
@


1.17
log
@move two other huge blobs into the 3000h segment
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/stand/boot/boot.c,v 1.16 2009/01/11 13:09:20 tg Exp $	*/
d84 1
a84 1
	strlcpy(cmd.image, bootfile, sizeof(cmd.image));
d157 1
a157 1
		strlcpy(cmd.image, bootfile, sizeof(cmd.image));
@


1.16
log
@join in more pxeboot functionality
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/stand/boot/boot.c,v 1.15 2008/12/31 16:38:34 tg Exp $	*/
a58 1
struct cmd_state cmd;
@


1.15
log
@shrink fdboot, nuke unused junk
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/stand/boot/boot.c,v 1.14 2008/08/01 12:39:09 tg Exp $	*/
d41 1
d97 7
a103 6
	cmd.boothowto = 0;
	snprintf(myconf, sizeof(myconf), "/%d.%d.%d.%d/boot.cfg",
	    ip & 0xff, (ip >> 8) & 0xff, (ip >> 16) & 0xff, (ip >> 24) & 0xff);
	cmd.conf = myconf;
	cmd.addr = (void *)DEFAULT_KERNEL_ADDRESS;
	cmd.timeout = 5;
d105 4
a108 2
	st = read_conf();
#elif !defined(SMALL_BOOT)
@


1.14
log
@remove unused code (for testing the bootloader on unix)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/stand/boot/boot.c,v 1.13 2008/08/01 11:56:10 tg Exp $	*/
d48 1
d50 1
@


1.13
log
@it's boot.cfg not boot.conf *sigh*
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/stand/boot/boot.c,v 1.12 2008/08/01 11:25:04 tg Exp $	*/
a167 9

#ifdef _TEST
int
main()
{
	boot(0);
	return 0;
}
#endif
@


1.12
log
@merge and reduce diff to obsd
XXX not yet tested
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/stand/boot/boot.c,v 1.11 2007/08/24 13:59:58 tg Exp $	*/
d132 1
a132 1
		/* no boot.conf, or no boot cmd in there */
@


1.11
log
@don’t bitch about “I can’t open tftp:/1.2.3.4/boot.cfg” after successfully
opening and reading it… baka
@
text
@d1 2
a2 2
/**	$MirOS: src/sys/stand/boot/boot.c,v 1.10 2006/11/21 02:53:39 tg Exp $	*/
/*	$OpenBSD: boot.c,v 1.30 2004/01/29 00:54:08 tom Exp $	*/
d55 1
a55 1
extern const char version[];
d64 1
a64 1
	int i = 0, try = 0, st = -1;
d136 1
a136 1
			} while (!getcmd());
d142 2
a143 1
		if (loadfile(cmd.path, marks, LOAD_ALL) >= 0)
d145 1
@


1.10
log
@remove dead and insecure code
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/stand/boot/boot.c,v 1.9 2006/10/13 19:18:04 tg Exp $	*/
d84 1
d101 1
a101 2
	if ((st = read_conf()))
		printf("Attempt to read %s failed.\n", cmd.conf);
d111 1
a111 2
		if ((st = read_conf()) < 0)
			printf("Attempt to read %s failed.\n", cmd.conf);
d116 4
@


1.9
log
@move /etc/boot.cfg and friends to /
agreed bsiegert@@
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/stand/boot/boot.c,v 1.8 2006/08/19 12:45:48 tg Exp $	*/
a37 1
#include <lib/libkern/funcs.h>
@


1.8
log
@attempt at shrinking the floppy
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/stand/boot/boot.c,v 1.7 2006/04/10 19:15:16 tg Exp $	*/
d90 1
a90 1
	 * first, and if that fails, fall back to /etc/boot.cfg, and
d106 1
a106 1
		snprintf(myconf, sizeof (myconf), "/etc/boot.%d",
d119 1
a119 1
		cmd.conf = "/etc/boot.cfg";
@


1.7
log
@fix misleading error message
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/stand/boot/boot.c,v 1.6 2006/04/10 18:43:35 tg Exp $	*/
d5 1
a5 1
 * Copyright (c) 2002, 2003, 2004 Thorsten Glaser
d70 1
d72 1
d103 1
a103 1
#else
@


1.6
log
@too bad: %03x isn't implemented in libsa, go back to %d (sad)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/stand/boot/boot.c,v 1.5 2006/04/06 22:02:33 tg Exp $	*/
d110 1
a110 1
		if ((st = read_conf()))
@


1.5
log
@change hook semantics: low order 12 bits can be used to select
boot configuration; anything above is ignored except for the
fact to change the 'is there a hook thing' stuff (boot.000 can
thus be used with 0x1000); also use hex and zero-pad
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/stand/boot/boot.c,v 1.4 2006/04/06 00:05:33 tg Exp $	*/
d104 2
a105 2
		snprintf(myconf, sizeof (myconf), "/etc/boot.%03x",
		    (hook_value & 0xFFF));
@


1.4
log
@unbreak
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/stand/boot/boot.c,v 1.3 2006/04/05 22:12:16 tg Exp $	*/
d104 2
a105 1
		snprintf(myconf, sizeof(myconf), "/etc/boot.%d", hook_value);
@


1.3
log
@add the ability to hook something into the (CD) boot loader,
and select a different 'boot.cfg' file (boot.%d) based upon it
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/stand/boot/boot.c,v 1.2 2005/03/06 21:28:32 tg Exp $	*/
d69 1
a70 1
#endif
@


1.2
log
@* merge src/sys/
  (at least the better part of it)
* revert IPv6 networking to OpenBSD, since
  I didn't get IPV4_MAPPED addresses working :(
@
text
@d1 1
a1 1
/**	$MirOS$	*/
d59 1
d65 1
a65 1
	int i = 0, try = 0, st;
d101 12
a114 3
#else
	{
#endif
@


1.1
log
@Initial revision
@
text
@d1 1
d5 1
d39 5
a48 1
	"/obsd",
d56 1
a56 1
extern	const char version[];
d66 4
d74 3
a76 2
	    ">> OpenBSD/" MACHINE " %s %s", progname, version);
	printf("%s\n", prog_ident);
d79 1
d81 10
d92 3
a94 1
	cmd.conf = "/etc/boot.conf";
d98 14
a111 1
	st = read_conf();
d121 1
a121 1
			} while(!getcmd());
d132 1
a132 1
			bootfile = kernels[i=0];
d136 8
a143 6
		printf(" failed(%d). will try %s\n", errno, bootfile);

		if (try < 2)
			cmd.timeout++;
		else {
			if (cmd.timeout)
a144 1
			cmd.timeout = 0;
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@import bootloader-related pieces from openbsd, as first part of the
aspired 4.4 merge… and something else
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.36 2007/06/26 10:34:41 tom Exp $	*/
d40 6
a45 3
#ifndef KERNEL
#define KERNEL "/bsd"
#endif
a51 2

/* bootprompt can be set by MD code to avoid prompt first time round */
a52 1
char *kernelfile = KERNEL;		/* can be changed by MD code */
d57 2
a58 2
	int fd;
	int try = 0, st;
d68 1
a68 1
	strlcpy(cmd.image, kernelfile, sizeof(cmd.image));
d90 1
a90 2
		if ((fd = loadfile(cmd.path, marks, LOAD_ALL)) != -1) {
			close(fd);
a91 1
		}
d93 11
a103 9
		kernelfile = KERNEL;
		try++;
		strlcpy(cmd.image, kernelfile, sizeof(cmd.image));
		printf(" failed(%d). will try %s\n", errno, kernelfile);

		if (try < 2) {
			if (cmd.timeout > 0)
				cmd.timeout++;
		} else {
@

