head	1.3;
access;
symbols;
locks; strict;
comment	@ * @;


1.3
date	2010.07.25.16.36.18;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004C4C672D35F3668C;

1.2
date	2009.02.22.12.25.37;	author tg;	state Exp;
branches;
next	1.1;
commitid	10049A1443C27538055;

1.1
date	2009.02.16.21.21.02;	author tg;	state Exp;
branches;
next	;
commitid	1004999D6C503898A56;


desc
@@


1.3
log
@let the BIOS initialise the TPM and associated buses (also more failsafe)
inspired by http://www.mail-archive.com/linux-kernel@@vger.kernel.org/msg82847.html
@
text
@/* $MirOS: src/sys/arch/i386/pci/ich_tpm.c,v 1.2 2009/02/22 12:25:37 tg Exp $ */

/*-
 * Copyright (c) 2009, 2010
 *	Thorsten Glaser <tg@@mirbsd.org>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <machine/bus.h>
#include <dev/ic/tpm.h>
#include <dev/pci/pcidevs.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>

/* PCI configuration addresses */
#define PCI_GEN1_DEC			0xE4
#define PCI_LPC_EN			0xE6
#define PCI_GEN2_DEC			0xEC

/* TPM Base */
#define TPM_ATMEL_BASE			0x400

extern struct cfdriver tpm_cd;

void ichpcib_attach_tpm(struct device *, struct device *,
    struct pci_attach_args *);

struct cfattach ich_tpm_ca = {
	sizeof (struct tpm_softc), tpm_match, tpm_attach
};


void ichpcib_attach_tpm(struct device *parent, struct device *self,
    struct pci_attach_args *pa)
{
	enum tpm_chip_type chiptype = TPM_INVALID_CHIP;
	struct tpm_attach_args ta;
	struct cfdata cf;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_INTEL) {
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_INTEL_82801BA_LPC:
			chiptype = ICH2LPC;
			break;
		case PCI_PRODUCT_INTEL_82801CAM_LPC:
			chiptype = ICH3LPCM;
			break;
		case PCI_PRODUCT_INTEL_82801DB_LPC:
			chiptype = ICH4LPC;
			break;
		case PCI_PRODUCT_INTEL_82801DBM_LPC:
			chiptype = ICH4LPCM;
			break;
		}
	}

	if (chiptype == TPM_INVALID_CHIP)
		return;

	bzero(&ta, sizeof (ta));
	ta.chiptype = chiptype;

	bzero(&cf, sizeof (cf));
	cf.cf_attach = &ich_tpm_ca;
	cf.cf_driver = &tpm_cd;
	config_attach(self, &cf, &ta, NULL);
}
@


1.2
log
@untested: I don’t like this line in dmesg:
│tpm0 (root) at 0x400 (Intel ICH4 LPC-M), version 1.1.0.6, vendor ATML

try to change “(root)” into “at ichpcib0”
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/pci/ich_tpm.c,v 1.1 2009/02/16 21:21:02 tg Exp $ */
d4 1
a4 1
 * Copyright (c) 2009
a54 1
	int lpcenable, tpminfo;
a77 21
	/* Enable the LPC */
	lpcenable = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_GEN1_DEC);
	lpcenable |= 0x20000000;
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_GEN1_DEC, lpcenable);
	/* Verify it was turned on */
	if ((chiptype == ICH3LPCM) || (chiptype == ICH4LPCM)) {
		lpcenable = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_GEN1_DEC);
		if ((lpcenable & 0x20000000) == 0) {
			printf("tpm: cannot enable LPC\n");
			return;
		}
	}

	/* Initialise TPM */
	tpminfo = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_GEN2_DEC);
	tpminfo = (tpminfo & 0xffff0000) | (TPM_ATMEL_BASE & 0xfff0);
	/* if ((chiptype == ICH3LPCM) || (chiptype == ICH4LPCM)) */
		tpminfo |= 0x00000001;
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_GEN2_DEC, tpminfo);


a78 1
	ta.base = TPM_ATMEL_BASE;
@


1.1
log
@functional TPM driver, from Joshua Stein’s efforts
• tested with a slightly hacked user space library (GPL) from IBM:
  RMD160 (tpm-3.2.0.tar.gz) = 80bae009bdfeaaba5d4f2ce371bde630cf6913d1
  ‣ /dev/tpm not /dev/tpm0
  ‣ comment out ioctl
  ‣ for entropy testing of the RNG, slurp 768 bytes in each call
    (more aren’t returned on my IBM Stinkpad X40)
• TODO: make /dev/tpm available only if kern.usercrypto=1
• TODO: similar to VIA C3 HW RNG, feed into kernel pool from TPM, unless
  the device is already opened from user space
  ‣ XXX do we want/need to do a full reset once it was opened?
  ‣ XXX do we take it back once user space had addressed it?
• TODO: write tpm(4) manual page, regen MAKEDEV(8)

Think about it. (Hah, how bleu from me.) Why not let cprng(8) do the deed?
(Of course, in-kernel operation is much cooler. But it may block, and in
any case, it adds complexity. Plus, we only allow one user space programme
to actually access the device.)

Tests with mirports/math/ent on a 64 KiB sample looked good, although the
TPM is a very slow HW RNG (about 1KB/s even at the largest block size my
exemplar could do, which is not guaranteed by the standard anyway).

*winks Theo* Every bit counts. Even if it may not be worth it for crypto.

PS: someone with actual kernel coding experience might want to help me
    to attach the tpm0 at ichpcib0, which I couldn’t get quite right…
    for now, tpm0 attaches at mainbus0 or root, similar to powernowhack0…
    the match function falses constantly unless manually called from the
    ichpcib attach routine – but it is at least better than jsg’s trick
@
text
@d1 1
a1 1
/* $MirOS: src/share/misc/licence.template,v 1.28 2008/11/14 15:33:44 tg Rel $ */
d107 1
a107 1
	config_attach(NULL, &cf, &ta, NULL);
@

