head	1.16;
access;
symbols
	tg-beforemerge-ksrc10:1.1.1.1
	MIRBSD_10:1.11.0.2
	MIRBSD_10_BASE:1.11
	MIRBSD_9_BASE:1.8
	MIRBSD_8:1.2.0.2
	MIRBSD_8_BASE:1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2018.12.15.03.47.50;	author tg;	state Exp;
branches;
next	1.15;
commitid	1005C147964542F35C6;

1.15
date	2017.08.07.20.18.11;	author tg;	state Exp;
branches;
next	1.14;
commitid	1005988C69344442E37;

1.14
date	2010.09.19.19.14.39;	author tg;	state Exp;
branches;
next	1.13;
commitid	1004C96612772B54750;

1.13
date	2010.09.19.18.55.31;	author tg;	state Exp;
branches;
next	1.12;
commitid	1004C965C8F46717878;

1.12
date	2008.11.08.23.04.03;	author tg;	state Exp;
branches;
next	1.11;
commitid	10049161AB22DF5DFC5;

1.11
date	2007.09.28.18.58.24;	author tg;	state Exp;
branches;
next	1.10;
commitid	10046FD4EDE67B99486;

1.10
date	2007.09.28.18.33.23;	author tg;	state Exp;
branches;
next	1.9;
commitid	10046FD48A70BF91C15;

1.9
date	2006.07.21.16.30.36;	author tg;	state Exp;
branches;
next	1.8;
commitid	10044C101073826DFD6;

1.8
date	2006.04.12.23.12.34;	author tg;	state Exp;
branches;
next	1.7;
commitid	100443D89750F43938C;

1.7
date	2006.04.12.23.08.03;	author tg;	state Exp;
branches;
next	1.6;
commitid	100443D886574551FE3;

1.6
date	2006.04.11.09.24.23;	author tg;	state Exp;
branches;
next	1.5;
commitid	100443B75D346FF4CC9;

1.5
date	2006.04.06.22.20.24;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004435940954E2E4B7;

1.4
date	2006.04.06.20.44.05;	author tg;	state Exp;
branches;
next	1.3;
commitid	10044357DA5237AA305;

1.3
date	2006.04.06.10.50.38;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004434F24E300C5CA7;

1.2
date	2005.03.06.21.26.57;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.27.24;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.27.24;	author tg;	state Exp;
branches;
next	;


desc
@@


1.16
log
@some optimisation, and rework the emulation npxdna handling
@
text
@/**	$MirOS: src/sys/arch/i386/i386/autoconf.c,v 1.15 2017/08/07 20:18:11 tg Exp $	*/
/*	$OpenBSD: autoconf.c,v 1.52 2003/10/15 03:56:21 david Exp $	*/
/*	$NetBSD: autoconf.c,v 1.20 1996/05/03 19:41:56 christos Exp $	*/

/*-
 * Copyright (c) 2004, 2007, 2018
 *	mirabilos <m@@mirbsd.org>
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * William Jolitz.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)autoconf.c	7.1 (Berkeley) 5/9/91
 */

/*
 * Setup the system to run on the current machine.
 *
 * cpu_configure() is called at boot time and initializes the vba
 * device tables and the memory controller monitoring.  Available
 * devices are determined (from possibilities mentioned in ioconf.c),
 * and the drivers are initialized.
 */
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/dkstat.h>
#include <sys/disklabel.h>
#include <sys/conf.h>
#include <sys/reboot.h>
#include <sys/device.h>

#include <uvm/uvm_extern.h>

#include <machine/pte.h>
#include <machine/cpu.h>
#include <machine/gdt.h>
#include <machine/biosvar.h>

#include <dev/cons.h>

int findblkmajor(struct device *dv);
char *findblkname(int);

void rootconf(void);
void swapconf(void);
void setroot(void);
void diskconf(void);

/*
 * The following several variables are related to
 * the configuration process, and are used in initializing
 * the machine.
 */
dev_t	bootdev = 0;		/* bootdevice, initialized in locore.s */
char	root_devname[16];

/* Support for VIA C3 RNG */
#ifdef I686_CPU
extern struct timeout viac3_rnd_tmo;
extern u_char	viac3_rnd_present;
void		viac3_rnd(void *);

#ifdef CRYPTO
extern u_char	viac3_crypto_present;
void		viac3_crypto_setup(void);
#endif /* CRYPTO */
#endif

/*
 * Determine i/o configuration for a machine.
 */
void
cpu_configure()
{
	/*
	 * Note, on i386, configure is not running under splhigh unlike other
	 * architectures.  This fact is used by the pcmcia irq line probing.
	 */

	startrtclock();

	gdt_init();		/* XXX - pcibios uses gdt stuff */

	if (config_rootfound("mainbus", NULL) == NULL)
		panic("cpu_configure: mainbus not configured");

	printf("biomask %x netmask %x ttymask %x\n", (u_short)IMASK(IPL_BIO),
	    (u_short)IMASK(IPL_NET), (u_short)IMASK(IPL_TTY));

	spl0();

	/*
	 * We can not know which is our root disk, defer
	 * until we can checksum blocks to figure it out.
	 */
	md_diskconf = diskconf;
	cold = 0;

	/* Set up proc0's TSS and LDT (after the FPU is configured). */
	i386_proc0_tss_ldt_init();

#ifdef I686_CPU
	/*
	 * At this point the RNG is running, and if FSXR is set we can
	 * use it.  Here we setup a periodic timeout to collect the data.
	 * Well, actually the random device has not yet attached, but
	 * we can eat data anyway, so no harm.
	 */
	if (viac3_rnd_present) {
		timeout_set(&viac3_rnd_tmo, viac3_rnd, &viac3_rnd_tmo);
		viac3_rnd(NULL);
	}
#ifdef CRYPTO
	/*
	 * Also, if the chip has crypto available, enable it.
	 */
	if (viac3_crypto_present)
		viac3_crypto_setup();
#endif /* CRYPTO */
#endif
}

/*
 * Now that we are fully operational, we can checksum the
 * disks, and using some heuristics, hopefully are able to
 * always determine the correct root disk.
 */
void
diskconf()
{
	/*
	 * Configure root, swap, and dump area.  This is
	 * currently done by running the same checksum
	 * algorithm over all known disks, as was done in
	 * /boot.  Then we basically fixup the *dev vars
	 * from the info we gleaned from this.
	 */
	dkcsumattach();

	rootconf();
	swapconf();
	dumpconf();
}

/*
 * Configure swap space and related parameters.
 */
void
swapconf()
{
	register struct swdevt *swp;
	register int nblks;

	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		int maj = major(swp->sw_dev);

		if (maj > nblkdev)
			break;
		if (bdevsw[maj].d_psize) {
			nblks = (*bdevsw[maj].d_psize)(swp->sw_dev);
			if (nblks != -1 &&
			    (swp->sw_nblks == 0 || swp->sw_nblks > nblks))
				swp->sw_nblks = nblks;
			swp->sw_nblks = ctod(dtoc(swp->sw_nblks));
		}
	}
}

#define	DOSWAP			/* change swdevt and dumpdev */

static struct {
	char *name;
	int maj;
} nam2blk[] = {
	{ "wd", 0 },
	{ "sw", 1 },
	{ "fd", 2 },
	{ "wt", 3 },
	{ "sd", 4 },
	{ "cd", 6 },
	{ "mcd", 7 },
	{ "rd", 17 },
	{ "raid", 19 }
};

int
findblkmajor(dv)
	struct device *dv;
{
	char *name = dv->dv_xname;
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name))
		    == 0)
			return (nam2blk[i].maj);
	return (-1);
}

char *
findblkname(maj)
	int maj;
{
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (maj == nam2blk[i].maj)
			return (nam2blk[i].name);
	return (NULL);
}

dev_t	argdev = NODEV;
int	nswap;
long	dumplo;

/*
 * Attempt to find the device from which we were booted.
 * If we can do so, and not instructed not to do so,
 * change rootdev to correspond to the load device.
 */
void
setroot()
{
	int  majdev, mindev, unit, part, adaptor;
	dev_t orootdev;
#ifdef DOSWAP
	dev_t temp = 0;
#endif
	struct swdevt *swp;

	if (boothowto & RB_DFLTROOT ||
	    (bootdev & B_MAGICMASK) != (u_long)B_DEVMAGIC)
		return;
	majdev = B_TYPE(bootdev);
	if (findblkname(majdev) == NULL)
		return;
	adaptor = B_ADAPTOR(bootdev);
	part = B_PARTITION(bootdev);
	unit = B_UNIT(bootdev);
	mindev = (unit * MAXPARTITIONS) + part;
	orootdev = rootdev;
	rootdev = makedev(majdev, mindev);
	/*
	 * If the original rootdev is the same as the one
	 * just calculated, don't need to adjust the swap configuration.
	 */
	snprintf(root_devname, 16, "%s%d%c", \
	    findblkname(majdev), unit, part + 'a');
	printf("root on %s\n", root_devname);
	if (rootdev == orootdev)
		return;

#ifdef DOSWAP
	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (majdev == major(swp->sw_dev) &&
		    mindev/MAXPARTITIONS == minor(swp->sw_dev)/MAXPARTITIONS) {
			temp = swdevt[0].sw_dev;
			swdevt[0].sw_dev = swp->sw_dev;
			swp->sw_dev = temp;
			break;
		}
	}
	if (swp->sw_dev == NODEV)
		return;

	/*
	 * If dumpdev was the same as the old primary swap device, move
	 * it to the new primary swap device.
	 */
	if (temp == dumpdev)
		dumpdev = swdevt[0].sw_dev;
#endif
}

#include "wd.h"
#if NWD > 0
extern	struct cfdriver wd_cd;
#endif
#include "sd.h"
#if NSD > 0
extern	struct cfdriver sd_cd;
#endif
#include "cd.h"
#if NCD > 0
extern	struct cfdriver cd_cd;
#endif
#include "mcd.h"
#if NMCD > 0
extern	struct cfdriver mcd_cd;
#endif
#include "fd.h"
#if NFD > 0
extern	struct cfdriver fd_cd;
#endif
#include "rd.h"
#if NRD > 0
extern	struct cfdriver rd_cd;
#endif
#include "raid.h"
#if NRAID > 0
extern	struct cfdriver raid_cd;
#endif

struct	genericconf {
	struct cfdriver *gc_driver;
	char *gc_name;
	dev_t gc_major;
} genericconf[] = {
#if NWD > 0
	{ &wd_cd,  "wd",  0 },
#endif
#if NFD > 0
	{ &fd_cd,  "fd",  2 },
#endif
#if NSD > 0
	{ &sd_cd,  "sd",  4 },
#endif
#if NCD > 0
	{ &cd_cd,  "cd",  6 },
#endif
#if NMCD > 0
	{ &mcd_cd, "mcd", 7 },
#endif
#if NRD > 0
	{ &rd_cd,  "rd",  17 },
#endif
#if NRAID > 0
	{ &raid_cd,  "raid",  19 },
#endif
	{ 0 }
};

void
rootconf()
{
	register struct genericconf *gc;
	int unit, part = 0;
	char *num;
	extern int rootdev_override;

	if (rootdev_override)
		mountroot = dk_mountroot;

#ifdef INSTALL
	if (B_TYPE(bootdev) == 2) {
		printf("\n\nInsert filesystem floppy...\n");
		if (!(boothowto & RB_ASKNAME)) {
			cnpollc(TRUE);
			cngetc();
			cnpollc(FALSE);
		}
	}
#endif

#ifdef RAMDISK_HOOKS
	if (boothowto & RB_ASKNAME)
		goto retry;
	if (!rootdev_override) {
		/* this block ends at noask: */
		char name[128] = "rd0a";
		extern size_t rd_root_image_siz;
		extern char rd_root_image_cmp[], rd_root_image[];

		if (!memcmp(rd_root_image, rd_root_image_cmp,
		    rd_root_image_siz))
			goto noask;
		boothowto |= RB_ASKNAME;
		goto ramtry;
#else
	if (boothowto & RB_ASKNAME) {
		char name[128];
#endif
 retry:
		printf("root device? ");
		cnpollc(TRUE);
		getsn(name, sizeof name);
		cnpollc(FALSE);
		if (*name == '\0')
			goto noask;
#ifdef RAMDISK_HOOKS
 ramtry:
#endif
		if (!strcmp(name, "nfs")) {
#ifdef NFSCLIENT
			mountroot = nfs_mountroot;
			rootdev = NODEV;
			swdevt[0].sw_dev = NODEV;
			dumpdev = NODEV;
			goto noask;
#else
			printf("NFS is not supported.\n");
			goto retry;
#endif
		}
		for (gc = genericconf; gc->gc_driver; gc++)
			if (gc->gc_driver->cd_ndevs &&
			    strncmp(gc->gc_name, name,
			    strlen(gc->gc_name)) == 0)
				break;
		if (gc->gc_driver) {
			num = &name[strlen(gc->gc_name)];

			unit = -2;
			do {
				if (unit != -2 && *num >= 'a' &&
				    *num <= 'a'+MAXPARTITIONS-1 &&
				    num[1] == '\0') {
					part = *num++ - 'a';
					break;
				}
				if (unit == -2)
					unit = 0;
				unit = (unit * 10) + *num - '0';
				if (*num < '0' || *num > '9')
					unit = -1;
			} while (unit != -1 && *++num);

			if (unit < 0) {
				printf("%s: not a unit number\n",
				    &name[strlen(gc->gc_name)]);
			} else if (unit > gc->gc_driver->cd_ndevs ||
			    gc->gc_driver->cd_devs[unit] == NULL) {
				printf("%d: no such unit\n", unit);
			} else {
				snprintf(root_devname, 16, "%s%d%c", \
				    gc->gc_name, unit, part + 'a');
				printf("root on %s\n", root_devname);
				rootdev = makedev(gc->gc_major,
				    unit * MAXPARTITIONS + part);
				goto doswap;
			}
		}
		printf("use one of: nfs ");
		for (gc = genericconf; gc->gc_driver; gc++) {
			for (unit=0; unit < gc->gc_driver->cd_ndevs; unit++) {
				if (gc->gc_driver->cd_devs[unit])
					printf("%s%d[a-%c] ", gc->gc_name,
					    unit, 'a'+MAXPARTITIONS-1);
			}
		}
		printf("\n");
		goto retry;
	}
 noask:
	if (mountroot == NULL) {
		/* 'swap generic' */
		setroot();
	} else {
		/* preconfigured */
		int  majdev, unit, part;

		majdev = major(rootdev);
		if (findblkname(majdev) == NULL)
			return;
		part = minor(rootdev) % MAXPARTITIONS;
		unit = minor(rootdev) / MAXPARTITIONS;
		snprintf(root_devname, 16, "%s%d%c", \
		    findblkname(majdev), unit, part + 'a');
		printf("root on %s\n", root_devname);
		return;
	}

 doswap:
#ifndef DISKLESS
	mountroot = dk_mountroot;
#endif
	swdevt[0].sw_dev = argdev = dumpdev =
	    makedev(major(rootdev), minor(rootdev) + 1);
	/* swap size and dumplo set during autoconfigure */
}
@


1.15
log
@filesystem
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/i386/autoconf.c,v 1.14 2010/09/19 19:14:39 tg Exp $	*/
d6 2
a7 2
 * Copyright (c) 2004, 2007
 *	Thorsten “mirabilos” Glaser <tg@@mirbsd.org>
d86 1
a86 1
extern int	viac3_rnd_present;
d90 1
a90 1
extern int	viac3_crypto_present;
@


1.14
log
@we can use arc4random() “always”, even on a cold system, now
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/i386/autoconf.c,v 1.13 2010/09/19 18:55:31 tg Exp $	*/
d372 1
a372 1
		printf("\n\nInsert file system floppy...\n");
@


1.13
log
@the promised new RNG (play with RNDEBUG in crypto/randimpl.h to make
it verbose; I did, for a while and a bit of fine-tuning)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/i386/autoconf.c,v 1.12 2008/11/08 23:04:03 tg Exp $	*/
d132 2
@


1.12
log
@more mass conversions, including ancient eMail addresses
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/i386/autoconf.c,v 1.11 2007/09/28 18:58:24 tg Exp $	*/
a133 3
		extern int arc4random_seedfreq, hz;
		int s;

d135 1
a135 6
		viac3_rnd(&viac3_rnd_tmo);

		/* we can probably afford re-seeding this every minute */
		s = splhigh();
		arc4random_seedfreq = hz << 6;
		splx(s);
@


1.11
log
@might need splhigh() protection
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/i386/autoconf.c,v 1.10 2007/09/28 18:33:23 tg Exp $	*/
d7 1
a7 1
 *	Thorsten “mirabilos” Glaser <tg@@66h.42h.de>
@


1.10
log
@• do not always srandom(), once is enough, it’s not supposed to be crypto-
  graphically good anyway, just continuous
• new int arc4random_seedfreq; contains the frequency of arc4random(9)
  re-seeds, by default still 10 minutes
• if a VIA C3 Hardware RNG is found, re-seed every minute (ok 64 seconds…)
• bump © years, sync licence etc.
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/i386/autoconf.c,v 1.9 2006/07/21 16:30:36 tg Exp $	*/
d135 1
d141 1
d143 1
@


1.9
log
@refine /dev/rd0c-as-swap detection algorithm
in the kernel, use memcmp i.p.v. strncmp for comparing memory regions
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/i386/autoconf.c,v 1.8 2006/04/12 23:12:34 tg Exp $	*/
d6 2
a7 2
 * Copyright (c) 2004
 *	Thorsten "mirabile" Glaser <tg@@66h.42h.de>
d134 2
d138 3
@


1.8
log
@missed dumpdev
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/i386/autoconf.c,v 1.7 2006/04/12 23:08:03 tg Exp $	*/
d388 1
a388 1
		if (!strncmp(rd_root_image, rd_root_image_cmp,
@


1.7
log
@add nfs support for 'boot -a'
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/i386/autoconf.c,v 1.6 2006/04/11 09:24:23 tg Exp $	*/
d412 1
@


1.6
log
@hopefully fix 'boot -a' for UKC'd rootdev kernels
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/i386/autoconf.c,v 1.5 2006/04/06 22:20:24 tg Exp $	*/
d379 1
a379 1
#ifdef	RAMDISK_HOOKS
d404 1
a404 1
#ifdef	RAMDISK_HOOKS
d407 11
d456 1
a456 1
		printf("use one of: ");
@


1.5
log
@* even if RAMDISK_HOOKS is defined and a ramdisk image given in
  the kernel image, do *not* automatically set the root device
  to 'rd0a' if rootdev_override is set (speeds up the live CD)
* KNF the labels while here (one space indent, start at col. 2)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/i386/autoconf.c,v 1.4 2006/04/06 20:44:05 tg Exp $	*/
d380 2
a387 2
		if (boothowto & RB_ASKNAME)
			goto retry;
@


1.4
log
@"how to not do things"... duplicate information and forget to sync
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/i386/autoconf.c,v 1.3 2006/04/06 10:50:38 tg Exp $	*/
d380 2
a381 1
	{
d397 1
a397 1
retry:
d405 1
a405 1
ramtry:
d456 1
a456 1
noask:
d475 1
a475 1
doswap:
@


1.3
log
@implement rootdev_override to prevent our hand-written changed rootdev
to be overwritten from something derived from the boot loader in case
of 'config bsd swap generic'

XXX this is dangerous if you set the rootdev to NODEV on a non-generic
XXX but it might still work (reset to generic) and isn't too supported
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/i386/autoconf.c,v 1.2 2005/03/06 21:26:57 tg Exp $	*/
d365 3
d456 1
a456 1
	if (!rootdev_override && mountroot == NULL) {
@


1.2
log
@* merge src/sys/
  (at least the better part of it)
* revert IPv6 networking to OpenBSD, since
  I didn't get IPV4_MAPPED addresses working :(
@
text
@d1 1
a1 1
/**	$MirOS$	*/
d363 1
d453 1
a453 1
	if (mountroot == NULL) {
@


1.1
log
@Initial revision
@
text
@d1 1
d6 2
d44 1
a44 1
 * cpu_configure() is called at boot time and initializes the vba 
d81 1
d271 3
a273 1
	printf("root on %s%d%c\n", findblkname(majdev), unit, part + 'a');
d367 2
a368 1
		if (!(boothowto & RB_ASKNAME))
d370 2
d375 14
d391 1
d399 3
d432 3
a434 2
				printf("root on %s%d%c\n", gc->gc_name, unit,
				    'a' + part);
d453 1
a453 1
		/* `swap generic' */
d464 3
a466 1
		printf("root on %s%d%c\n", findblkname(majdev), unit, part + 'a');
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@
