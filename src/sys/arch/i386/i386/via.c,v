head	1.7;
access;
symbols
	tg-beforemerge-ksrc10:1.1.1.1
	MIRBSD_10:1.1.1.1.0.6
	MIRBSD_10_BASE:1.1.1.1
	MIRBSD_9_BASE:1.1.1.1
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2018.12.15.03.56.08;	author tg;	state Exp;
branches;
next	1.6;
commitid	1005C147B6F4A7DC09D;

1.6
date	2018.12.15.03.47.51;	author tg;	state Exp;
branches;
next	1.5;
commitid	1005C147964542F35C6;

1.5
date	2011.07.17.20.50.28;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004E234B241AE97F1B;

1.4
date	2010.09.19.18.55.31;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004C965C8F46717878;

1.3
date	2008.03.27.22.39.08;	author tg;	state Exp;
branches;
next	1.2;
commitid	10047EC212806BE2132;

1.2
date	2008.03.21.20.57.29;	author tg;	state Exp;
branches;
next	1.1;
commitid	10047E420D8027C8058;

1.1
date	2005.02.05.17.27.25;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.27.25;	author tg;	state Exp;
branches
	1.1.1.1.4.1;
next	1.1.1.2;

1.1.1.2
date	2011.07.17.20.40.08;	author tg;	state Exp;
branches;
next	;
commitid	1004E2348A93C0100CC;

1.1.1.1.4.1
date	2007.10.21.17.48.12;	author tg;	state Exp;
branches;
next	1.1.1.1.4.2;
commitid	100471B90DA5FEF29CA;

1.1.1.1.4.2
date	2007.10.21.18.18.28;	author tg;	state Exp;
branches;
next	1.1.1.1.4.3;
commitid	100471B980419E94AE5;

1.1.1.1.4.3
date	2008.03.20.16.51.05;	author tg;	state Exp;
branches;
next	1.1.1.1.4.4;
commitid	10047E2946B53F3F802;

1.1.1.1.4.4
date	2008.03.21.01.06.37;	author tg;	state Exp;
branches;
next	1.1.1.1.4.5;
commitid	10047E30A1C1F33779E;

1.1.1.1.4.5
date	2008.03.21.01.14.58;	author tg;	state Exp;
branches;
next	1.1.1.1.4.6;
commitid	10047E30C246B31B7A5;

1.1.1.1.4.6
date	2008.03.21.02.55.05;	author tg;	state Exp;
branches;
next	1.1.1.1.4.7;
commitid	10047E323973A02435C;

1.1.1.1.4.7
date	2008.03.21.02.55.35;	author tg;	state Exp;
branches;
next	1.1.1.1.4.8;
commitid	10047E323AF5DF40B60;

1.1.1.1.4.8
date	2008.03.21.04.07.15;	author tg;	state Exp;
branches;
next	1.1.1.1.4.9;
commitid	10047E3345F6EED9B0A;

1.1.1.1.4.9
date	2008.03.21.18.09.23;	author tg;	state Exp;
branches;
next	1.1.1.1.4.10;
commitid	10047E3F9D2776B0AC4;

1.1.1.1.4.10
date	2008.03.21.18.19.30;	author tg;	state Exp;
branches;
next	1.1.1.1.4.11;
commitid	10047E3FC4351A77D2C;

1.1.1.1.4.11
date	2008.03.21.18.43.46;	author tg;	state Exp;
branches;
next	1.1.1.1.4.12;
commitid	10047E401F812810981;

1.1.1.1.4.12
date	2008.03.21.18.53.21;	author tg;	state Exp;
branches;
next	1.1.1.1.4.13;
commitid	10047E4042F20A3271B;

1.1.1.1.4.13
date	2008.03.21.19.24.27;	author tg;	state Exp;
branches;
next	1.1.1.1.4.14;
commitid	10047E40B5654BE0B29;

1.1.1.1.4.14
date	2008.03.21.19.47.51;	author tg;	state Exp;
branches;
next	;
commitid	10047E410F63BD58C1C;


desc
@@


1.7
log
@more space saving
@
text
@/**	$MirOS: src/sys/arch/i386/i386/via.c,v 1.6 2018/12/15 03:47:51 tg Exp $ */
/*	$OpenBSD: via.c,v 1.1 2004/04/11 18:12:10 deraadt Exp $	*/
/* + 1.2 1.7 1.8 1.13p 1.15 1.16 1.19 1.21 1.25 1.26 1.27 1.28 */
/*	$NetBSD: machdep.c,v 1.214 1996/11/10 03:16:17 thorpej Exp $	*/

/*-
 * Copyright (c) 2008, 2011, 2018
 *	mirabilos <m@@mirbsd.org>
 * Copyright (c) 2003 Jason Wright
 * Copyright (c) 2003, 2004 Theo de Raadt
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/signalvar.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/exec.h>
#include <sys/buf.h>
#include <sys/reboot.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/timeout.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/extent.h>
#include <sys/sysctl.h>

#ifdef CRYPTO
#include <crypto/cryptodev.h>
#include <crypto/rijndael.h>
#endif

#include <uvm/uvm_extern.h>

#include <machine/cpu.h>
#include <machine/cpufunc.h>
#include <machine/gdt.h>
#include <machine/pio.h>
#include <machine/bus.h>
#include <machine/psl.h>
#include <machine/reg.h>
#include <machine/specialreg.h>
#include <machine/biosvar.h>

#include <dev/rndvar.h>

void	viac3_rnd(void *);

#ifdef CRYPTO

struct viac3_session {
	u_int32_t	ses_ekey[4 * (MAXNR + 1) + 4] __RIJNDAEL_ALIGNED;
	u_int32_t	ses_dkey[4 * (MAXNR + 1) + 4] __RIJNDAEL_ALIGNED;
	u_int32_t	ses_cw0;
	int		ses_klen;
	int		ses_used;
	int		ses_pad;			/* to multiple of 16 */
} __RIJNDAEL_ALIGNED;

struct viac3_softc {
	u_int32_t		op_cw[4] __RIJNDAEL_ALIGNED;
	u_int8_t		op_iv[16] __RIJNDAEL_ALIGNED;
	void			*op_buf;

	/* normal softc stuff */
	int32_t			sc_cid;
	int			sc_nsessions;
	struct viac3_session	*sc_sessions;
} __RIJNDAEL_ALIGNED;

#define VIAC3_SESSION(sid)		((sid) & 0x0fffffff)
#define	VIAC3_SID(crd,ses)		(((crd) << 28) | ((ses) & 0x0fffffff))

static struct viac3_softc *vc3_sc;

void viac3_crypto_setup(void);
int viac3_crypto_newsession(u_int32_t *, struct cryptoini *);
int viac3_crypto_process(struct cryptop *);
int viac3_crypto_freesession(u_int64_t);
static __inline void viac3_cbc(void *, void *, void *, void *, int, void *);

static uint32_t viac3_r_cw[4] __RIJNDAEL_ALIGNED;
static uint8_t viac3_r_iv[16] __RIJNDAEL_ALIGNED;
static uint8_t viac3_r_buf[PAGE_SIZE] __RIJNDAEL_ALIGNED;

void viac3_rijndael_decrypt(rijndael_ctx *, u_char *, u_char *, u_char *, int);
void viac3_rijndael_encrypt(rijndael_ctx *, u_char *, u_char *, u_char *, int);
void viac3_rijndael_cbc(rijndael_ctx *, u_char *, u_char *, u_char *, int, int);
int viac3_rijndael_set_key(rijndael_ctx *, u_char *, int);
int viac3_rijndael_set_key_enc_only(rijndael_ctx *, u_char *, int);

void
viac3_crypto_setup(void)
{
	int algs[CRYPTO_ALGORITHM_MAX + 1];

	if ((vc3_sc = malloc(sizeof(*vc3_sc), M_DEVBUF,
	    M_NOWAIT|M_ZERO)) == NULL)
		return;		/* YYY bitch? */

	bzero(algs, sizeof(algs));
	algs[CRYPTO_AES_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;

	vc3_sc->sc_cid = crypto_get_driverid(0);
	if (vc3_sc->sc_cid < 0) {
		free(vc3_sc, M_DEVBUF);
		return;		/* YYY bitch? */
	}

	crypto_register(vc3_sc->sc_cid, algs, viac3_crypto_newsession,
	    viac3_crypto_freesession, viac3_crypto_process);

	/* take over */
	rijndael_set_key_fast = viac3_rijndael_set_key;
	rijndael_set_key_enc_only_fast = viac3_rijndael_set_key_enc_only;
	rijndael_cbc_decrypt_fast = viac3_rijndael_decrypt;
	rijndael_cbc_encrypt_fast = viac3_rijndael_encrypt;
	printf("cpu0: VIA C3 AES functions used for swapencrypt\n");
}

int
viac3_crypto_newsession(u_int32_t *sidp, struct cryptoini *cri)
{
	struct viac3_softc *sc = vc3_sc;
	struct viac3_session *ses = NULL;
	int sesn, i, cw0;

	if (sc == NULL || sidp == NULL || cri == NULL ||
	    cri->cri_next != NULL || cri->cri_alg != CRYPTO_AES_CBC)
		return (EINVAL);

	switch (cri->cri_klen) {
	case 128:
		cw0 = C3_CRYPT_CWLO_KEY128;
		break;
	case 192:
		cw0 = C3_CRYPT_CWLO_KEY192;
		break;
	case 256:
		cw0 = C3_CRYPT_CWLO_KEY256;
		break;
	default:
		return (EINVAL);
	}
	cw0 |= C3_CRYPT_CWLO_ALG_AES | C3_CRYPT_CWLO_KEYGEN_SW |
	    C3_CRYPT_CWLO_NORMAL;

	if (sc->sc_sessions == NULL) {
		ses = sc->sc_sessions = (struct viac3_session *)malloc(
		    sizeof(*ses), M_DEVBUF, M_NOWAIT);
		if (ses == NULL)
			return (ENOMEM);
		sesn = 0;
		sc->sc_nsessions = 1;
	} else {
		for (sesn = 0; sesn < sc->sc_nsessions; sesn++) {
			if (sc->sc_sessions[sesn].ses_used == 0) {
				ses = &sc->sc_sessions[sesn];
				break;
			}
		}

		if (ses == NULL) {
			sesn = sc->sc_nsessions;
			ses = (struct viac3_session *)malloc((sesn + 1) *
			    sizeof(*ses), M_DEVBUF, M_NOWAIT);
			if (ses == NULL)
				return (ENOMEM);
			bcopy(sc->sc_sessions, ses, sesn * sizeof(*ses));
			explicit_bzero(sc->sc_sessions, sesn * sizeof(*ses));
			free(sc->sc_sessions, M_DEVBUF);
			sc->sc_sessions = ses;
			ses = &sc->sc_sessions[sesn];
			sc->sc_nsessions++;
		}
	}

	bzero(ses, sizeof(*ses));
	ses->ses_used = 1;

	ses->ses_klen = cri->cri_klen;
	ses->ses_cw0 = cw0;

	/* Build expanded keys for both directions */
	rijndaelKeySetupEnc(ses->ses_ekey, cri->cri_key, cri->cri_klen);
	rijndaelKeySetupDec(ses->ses_dkey, cri->cri_key, cri->cri_klen);
	for (i = 0; i < 4 * (MAXNR + 1); i++) {
		ses->ses_ekey[i] = ntohl(ses->ses_ekey[i]);
		ses->ses_dkey[i] = ntohl(ses->ses_dkey[i]);
	}

	*sidp = VIAC3_SID(0, sesn);
	return (0);
}

int
viac3_crypto_freesession(u_int64_t tid)
{
	struct viac3_softc *sc = vc3_sc;
	int sesn;
	u_int32_t sid = ((u_int32_t)tid) & 0xffffffff;

	if (sc == NULL)
		return (EINVAL);
	sesn = VIAC3_SESSION(sid);
	if (sesn >= sc->sc_nsessions)
		return (EINVAL);
	explicit_bzero(&sc->sc_sessions[sesn], sizeof(sc->sc_sessions[sesn]));
	return (0);
}

static __inline void
viac3_cbc(void *cw, void *src, void *dst, void *key, int rep,
    void *iv)
{
	unsigned int creg0;

	creg0 = rcr0();		/* Permit access to SIMD/FPU path */
	lcr0(creg0 & ~(CR0_EM|CR0_TS));

	/* ensure the key is reloaded */
	__asm __volatile("pushfl; popfl");
	/* actual encryption */
	__asm__ volatile("rep xcrypt-cbc"
	    : "+a" (iv), "+S" (src), "+D" (dst)
	    : "b" (key), "c" (rep), "d" (cw)
	    : "memory", "cc");

	lcr0(creg0);
}

int
viac3_crypto_process(struct cryptop *crp)
{
	struct viac3_softc *sc = vc3_sc;
	struct viac3_session *ses;
	struct cryptodesc *crd;
	int sesn, err = 0;
	u_int32_t *key;

	if (crp == NULL || crp->crp_callback == NULL) {
		return (EINVAL);
	}
	crd = crp->crp_desc;
	if (crd == NULL || crd->crd_next != NULL ||
	    crd->crd_alg != CRYPTO_AES_CBC || 
	    (crd->crd_len % 16) != 0) {
		err = EINVAL;
		goto out;
	}

	sesn = VIAC3_SESSION(crp->crp_sid);
	if (sesn >= sc->sc_nsessions) {
		err = EINVAL;
		goto out;
	}
	ses = &sc->sc_sessions[sesn];
	if (ses->ses_used == 0) {
		err = EINVAL;
		goto out;
	}

	sc->op_buf = (char *)malloc(crd->crd_len, M_DEVBUF, M_NOWAIT);
	if (sc->op_buf == NULL) {
		err = ENOMEM;
		goto out;
	}

	if (crd->crd_flags & CRD_F_ENCRYPT) {
		sc->op_cw[0] = ses->ses_cw0 | C3_CRYPT_CWLO_ENCRYPT;
		key = ses->ses_ekey;
		if (crd->crd_flags & CRD_F_IV_EXPLICIT)
			bcopy(crd->crd_iv, sc->op_iv, 16);
		else
			arc4random_buf(sc->op_iv, 16);

		if ((crd->crd_flags & CRD_F_IV_PRESENT) == 0) {
			if (crp->crp_flags & CRYPTO_F_IMBUF)
				m_copyback((struct mbuf *)crp->crp_buf,
				    crd->crd_inject, 16, sc->op_iv);
			else if (crp->crp_flags & CRYPTO_F_IOV)
				cuio_copyback((struct uio *)crp->crp_buf,
				    crd->crd_inject, 16, sc->op_iv);
			else
				bcopy(sc->op_iv,
				    crp->crp_buf + crd->crd_inject, 16);
		}
	} else {
		sc->op_cw[0] = ses->ses_cw0 | C3_CRYPT_CWLO_DECRYPT;
		key = ses->ses_dkey;
		if (crd->crd_flags & CRD_F_IV_EXPLICIT)
			bcopy(crd->crd_iv, sc->op_iv, 16);
		else {
			if (crp->crp_flags & CRYPTO_F_IMBUF)
				m_copydata((struct mbuf *)crp->crp_buf,
				    crd->crd_inject, 16, sc->op_iv);
			else if (crp->crp_flags & CRYPTO_F_IOV)
				cuio_copydata((struct uio *)crp->crp_buf,
				    crd->crd_inject, 16, sc->op_iv);
			else
				bcopy(crp->crp_buf + crd->crd_inject,
				    sc->op_iv, 16);
		}
	}

	if (crp->crp_flags & CRYPTO_F_IMBUF)
		m_copydata((struct mbuf *)crp->crp_buf,
		    crd->crd_skip, crd->crd_len, sc->op_buf);
	else if (crp->crp_flags & CRYPTO_F_IOV)
		cuio_copydata((struct uio *)crp->crp_buf,
		    crd->crd_skip, crd->crd_len, sc->op_buf);
	else
		bcopy(crp->crp_buf + crd->crd_skip, sc->op_buf, crd->crd_len);

	sc->op_cw[1] = sc->op_cw[2] = sc->op_cw[3] = 0;
	viac3_cbc(&sc->op_cw, sc->op_buf, sc->op_buf, key,
	    crd->crd_len / 16, sc->op_iv);

	if (crp->crp_flags & CRYPTO_F_IMBUF)
		m_copyback((struct mbuf *)crp->crp_buf,
		    crd->crd_skip, crd->crd_len, sc->op_buf);
	else if (crp->crp_flags & CRYPTO_F_IOV)
		cuio_copyback((struct uio *)crp->crp_buf,
		    crd->crd_skip, crd->crd_len, sc->op_buf);
	else
		bcopy(sc->op_buf, crp->crp_buf + crd->crd_skip, crd->crd_len);

out:
	if (sc->op_buf != NULL) {
		explicit_bzero(sc->op_buf, crd->crd_len);
		free(sc->op_buf, M_DEVBUF);
		sc->op_buf = NULL;
	}
	crp->crp_etype = err;
	crypto_done(crp);
	return (err);
}

int
viac3_rijndael_set_key(rijndael_ctx *ctx, u_char *key, int bits)
{
	int i, cw0;

	if ((i = rijndael_set_key(ctx, key, bits)))
		return (i);

	switch (bits) {
	case 128:
		cw0 = C3_CRYPT_CWLO_KEY128;
		break;
	case 192:
		cw0 = C3_CRYPT_CWLO_KEY192;
		break;
	case 256:
		cw0 = C3_CRYPT_CWLO_KEY256;
		break;
	default:
		return (0);
	}

	for (i = 0; i < 4 * (MAXNR + 1); i++) {
		ctx->ek[i] = bswap32(ctx->ek[i]);
		ctx->dk[i] = bswap32(ctx->dk[i]);
	}

	ctx->hwcr_info.via.cw0 = cw0 | C3_CRYPT_CWLO_ALG_AES |
	    C3_CRYPT_CWLO_KEYGEN_SW | C3_CRYPT_CWLO_NORMAL;
	ctx->hwcr_id = RIJNDAEL_HWCR_VIA;
	return (0);
}

int
viac3_rijndael_set_key_enc_only(rijndael_ctx *ctx, u_char *key, int bits)
{
	int i, cw0;

	if ((i = rijndael_set_key_enc_only(ctx, key, bits)))
		return (i);

	switch (bits) {
	case 128:
		cw0 = C3_CRYPT_CWLO_KEY128;
		break;
	case 192:
		cw0 = C3_CRYPT_CWLO_KEY192;
		break;
	case 256:
		cw0 = C3_CRYPT_CWLO_KEY256;
		break;
	default:
		return (0);
	}

	for (i = 0; i < 4 * (MAXNR + 1); i++)
		ctx->ek[i] = bswap32(ctx->ek[i]);

	ctx->hwcr_info.via.cw0 = cw0 | C3_CRYPT_CWLO_ALG_AES |
	    C3_CRYPT_CWLO_KEYGEN_SW | C3_CRYPT_CWLO_NORMAL;
	ctx->hwcr_id = RIJNDAEL_HWCR_VIA;
	return (0);
}

void
viac3_rijndael_cbc(rijndael_ctx *ctx, u_char *iv, u_char *src, u_char *dst,
    int nblocks, int encr)
{
	size_t len;

	bzero(viac3_r_cw, sizeof(viac3_r_cw));
	viac3_r_cw[0] = ctx->hwcr_info.via.cw0 |
	    (encr ? C3_CRYPT_CWLO_ENCRYPT : C3_CRYPT_CWLO_DECRYPT);

	if (iv != NULL)
		memcpy(viac3_r_iv, iv, sizeof(viac3_r_iv));

	/* use viac3_r_buf to handle a page at a time */
	while (nblocks) {
		len = MIN(sizeof(viac3_r_buf), nblocks * 16);
		nblocks -= len / 16;

		memcpy(viac3_r_buf, src, len);

		viac3_cbc(&viac3_r_cw, viac3_r_buf, viac3_r_buf,
		    encr ? ctx->ek : ctx->dk, len / 16, viac3_r_iv);
		/* adjust IV manually (sigh) */
		memcpy(viac3_r_iv, encr ? viac3_r_buf : src,
		    sizeof(viac3_r_iv));

		memcpy(dst, viac3_r_buf, len);
		src += len;
		dst += len;
	}

	if (iv != NULL)
		memcpy(iv, viac3_r_iv, sizeof(viac3_r_iv));

	explicit_bzero(viac3_r_iv, sizeof(viac3_r_iv));
	explicit_bzero(viac3_r_buf, sizeof(viac3_r_buf));
}

void
viac3_rijndael_encrypt(rijndael_ctx *ctx, u_char *iv, u_char *src,
    u_char *dst, int nblocks)
{
	if (ctx->hwcr_id == RIJNDAEL_HWCR_VIA)
		viac3_rijndael_cbc(ctx, iv, src, dst, nblocks, 1);
	else
		rijndael_cbc_encrypt(ctx, iv, src, dst, nblocks);
}

void
viac3_rijndael_decrypt(rijndael_ctx *ctx, u_char *iv, u_char *src,
    u_char *dst, int nblocks)
{
	if (ctx->hwcr_id == RIJNDAEL_HWCR_VIA)
		viac3_rijndael_cbc(ctx, iv, src, dst, nblocks, 0);
	else
		rijndael_cbc_decrypt(ctx, iv, src, dst, nblocks);
}
#endif /* CRYPTO */

#if defined(I686_CPU)
/*
 * Note, the VIA C3 Nehemiah provides 4 internal 8-byte buffers, which
 * store random data, and can be accessed a lot quicker than waiting
 * for new data to be generated.  As we are using every 8th bit only
 * due to whitening. Since the RNG generates in excess of 21KB/s at
 * it's worst, collecting 64 bytes worth of entropy should not affect
 * things significantly.
 *
 * Note, due to some weirdness in the RNG, we need at least 7 bytes
 * extra on the end of our buffer.  Also, there is an outside chance
 * that the VIA RNG can "wedge", as the generated bit-rate is variable.
 * We could do all sorts of startup testing and things, but
 * frankly, I don't really see the point.  If the RNG wedges, then the
 * chances of you having a defective CPU are very high.  Let it wedge.
 *
 * Adding to the whole confusion, in order to access the RNG, we need
 * to have FXSR support enabled, and the correct FPU enable bits must
 * be there to enable the FPU in kernel.  It would be nice if all this
 * mumbo-jumbo was not needed in order to use the RNG.  Oh well, life
 * does go on...
 */
#define VIAC3_RNG_BUFSIZ	16		/* 32bit words */
struct timeout viac3_rnd_tmo;
u_char viac3_rnd_present;

void
viac3_rnd(void *v __unused)
{
	unsigned int *p, i, rv, creg0, len = VIAC3_RNG_BUFSIZ;
	static int buffer[VIAC3_RNG_BUFSIZ + 2];	/* XXX why + 2? */

	creg0 = rcr0();		/* Permit access to SIMD/FPU path */
	lcr0(creg0 & ~(CR0_EM|CR0_TS));

	/*
	 * Here we collect the random data from the VIA C3 RNG.  We make
	 * sure that we turn on maximum whitening (%edx[0,1] == "11"), so
	 * that we get the best random data possible.
	 */
	__asm __volatile("rep xstore-rng"
	    : "=a" (rv) : "d" (3), "D" (buffer), "c" (len*sizeof(int))
	    : "memory", "cc");

	lcr0(creg0);

	for (i = 0, p = buffer; i < VIAC3_RNG_BUFSIZ; i++, p++)
		add_true_randomness(*p);

	timeout_add(&viac3_rnd_tmo, (hz > 100) ? (hz / 100) : 1);
}

#endif /* defined(I686_CPU) */
@


1.6
log
@some optimisation, and rework the emulation npxdna handling
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/i386/via.c,v 1.5 2011/07/17 20:50:28 tg Exp $ */
a62 2
u_char	viac3_crypto_present;

a89 1
extern u_char i386_has_xcrypt;
a126 1
	i386_has_xcrypt = viac3_crypto_present;
@


1.5
log
@merge openbsd; keep IV zero’d
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/i386/via.c,v 1.4 2010/09/19 18:55:31 tg Exp $ */
d7 2
a8 2
 * Copyright (c) 2008, 2011
 *	Thorsten Glaser <tg@@mirbsd.org>
d63 1
a63 1
int viac3_crypto_present;
d92 1
a92 1
extern int i386_has_xcrypt;
d505 1
a505 1
int viac3_rnd_present;
@


1.4
log
@the promised new RNG (play with RNDEBUG in crypto/randimpl.h to make
it verbose; I did, for a while and a bit of fine-tuning)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/i386/via.c,v 1.3 2008/03/27 22:39:08 tg Exp $ */
d3 1
d7 2
a8 20
 * Copyright (c) 2008
 *	Thorsten “mirabilos” Glaser <tg@@mirbsd.de>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided “AS IS” and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person’s immediate fault when using the work as intended.
 */

/*-
d62 1
a62 1
void viac3_rnd(void *);
d65 1
d67 1
d69 2
a70 3
	u_int32_t	ses_ekey[4*(MAXNR+1)+4] __RIJNDAEL_ALIGNED;
	u_int32_t	ses_dkey[4*(MAXNR+1)+4] __RIJNDAEL_ALIGNED;
	u_int8_t	ses_iv[16] __RIJNDAEL_ALIGNED;
d115 2
a116 1
	if ((vc3_sc = malloc(sizeof(*vc3_sc), M_DEVBUF, M_NOWAIT)) == NULL)
a117 1
	bzero(vc3_sc, sizeof(*vc3_sc));
d123 2
a124 1
	if (vc3_sc->sc_cid < 0)
d126 1
d130 1
a130 1
	i386_has_xcrypt = 1;
d189 1
a189 1
			bzero(sc->sc_sessions, sesn * sizeof(*ses));
a199 1
	get_random_bytes(ses->ses_iv, sizeof(ses->ses_iv));
d227 1
a227 1
	bzero(&sc->sc_sessions[sesn], sizeof(sc->sc_sessions[sesn]));
d241 1
a241 1
	__asm__ volatile("pushfl; popfl");
d261 1
a261 2
		err = EINVAL;
		goto out;
d265 1
a265 1
	    crd->crd_alg != CRYPTO_AES_CBC ||
d277 4
d294 1
a294 1
			bcopy(ses->ses_iv, sc->op_iv, 16);
a346 13
	/* copy out last block for use as next session IV */
	if (crd->crd_flags & CRD_F_ENCRYPT) {
		if (crp->crp_flags & CRYPTO_F_IMBUF)
			m_copydata((struct mbuf *)crp->crp_buf,
			    crd->crd_skip + crd->crd_len - 16, 16, ses->ses_iv);
		else if (crp->crp_flags & CRYPTO_F_IOV)
			cuio_copydata((struct uio *)crp->crp_buf,
			    crd->crd_skip + crd->crd_len - 16, 16, sc->op_iv);
		else
			bcopy(crp->crp_buf + crd->crd_skip + crd->crd_len - 16,
			    sc->op_iv, 16);
	}

d349 1
a349 1
		bzero(sc->op_buf, crd->crd_len);
d428 1
a428 1
	bzero(viac3_r_cw, sizeof (viac3_r_cw));
d432 2
a433 4
	if (iv == NULL)
		bzero(viac3_r_iv, sizeof (viac3_r_iv));
	else
		memcpy(viac3_r_iv, iv, sizeof (viac3_r_iv));
d437 1
a437 1
		len = MIN(sizeof (viac3_r_buf), nblocks * 16);
d446 1
a446 1
		    sizeof (viac3_r_iv));
d454 4
a457 1
		memcpy(iv, viac3_r_iv, sizeof (viac3_r_iv));
d532 1
@


1.3
log
@• if SMALL_KERNEL (and not i386 and CRYPTO), reduce rĳndæl alignment to 4
  bytes, as the 16 byte alignment is only required for the VIA C3/C7 ACE
• VIA C3 code: use a single buffer the size of one page, instead of one
  buffer malloc(9)d and free(9)d for every request *AND* a buffer of 16
  bytes only for the case of it not working
  ‣ great speed-up (I think)
  ‣ if SMALL_KERNEL and !CRYPTO, we don’t include this code anyway
  ‣ we usually crypt one page (swap) or 512 bytes (vnd) only anyway
untested
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/i386/via.c,v 1.2 2008/03/21 20:57:29 tg Exp $ */
d532 1
a532 1
viac3_rnd(void *v)
a533 1
	struct timeout *tmo = v;
d554 1
a554 1
	timeout_add(tmo, (hz > 100) ? (hz / 100) : 1);
@


1.2
log
@merge the tg-crypto-improvements branch in their entirety:
• more efficient uvm_swap_encrypt code
• kernel-global AES-CBC (128, 192, 256) API
• kernel-global fast-AES API through function pointers
• VIA C3/C7 PadLock™ is eligible for the fast API
• hifn(4) and friends are not: modern CPUs are faster in software sometimes
• fix a data corruption bug in the VIA HW-AES code
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/i386/via.c,v 1.1.1.1.4.14 2008/03/21 19:47:51 tg Exp $ */
d84 3
a86 3
	u_int32_t	ses_ekey[4*(MAXNR+1)+4] __attribute__((aligned (16)));
	u_int32_t	ses_dkey[4*(MAXNR+1)+4] __attribute__((aligned (16)));
	u_int8_t	ses_iv[16] __attribute__((aligned (16)));
d91 1
a91 1
} __attribute__((aligned (16)));
d94 2
a95 2
	u_int32_t		op_cw[4] __attribute__((aligned (16)));
	u_int8_t		op_iv[16] __attribute__((aligned (16)));
d102 1
a102 1
} __attribute__((aligned (16)));
d116 3
a118 3
static uint32_t viac3_r_cw[4] __attribute__((aligned (16)));
static uint8_t viac3_r_iv[16] __attribute__((aligned (16)));
static uint8_t viac3_r_buf[16] __attribute__((aligned (16)));
d451 1
a451 2
	void *op_buf;
	size_t len = nblocks * sizeof (viac3_r_buf);
d462 6
a467 21
	if ((op_buf = malloc(len, M_DEVBUF, M_NOWAIT)) == NULL) {
		/* may be OOM situation (swapencrypt?) but warn/inform */
		printf("%s: notice: cannot allocate %lu bytes", __func__, len);

		/* use viac3_r_buf to handle 16 bytes at a time only */
		while (nblocks--) {
			memcpy(viac3_r_buf, src, sizeof (viac3_r_buf));

			viac3_cbc(&viac3_r_cw, viac3_r_buf, viac3_r_buf,
			    encr ? ctx->ek : ctx->dk, 1, viac3_r_iv);
			/* adjust IV manually (sigh) */
			memcpy(viac3_r_iv, encr ? viac3_r_buf : src,
			    sizeof (viac3_r_iv));

			memcpy(dst, viac3_r_buf, sizeof (viac3_r_buf));
			src += sizeof (viac3_r_buf);
			dst += sizeof (viac3_r_buf);
		}
	} else {
		/* handle all blocks at once */
		memcpy(op_buf, src, len);
d469 2
a470 2
		viac3_cbc(&viac3_r_cw, op_buf, op_buf,
		    encr ? ctx->ek : ctx->dk, nblocks, viac3_r_iv);
d472 1
a472 2
		memcpy(viac3_r_iv,
		    (encr ? op_buf : src) + len - sizeof (viac3_r_iv),
d475 3
a477 4
		memcpy(dst, op_buf, len);

		bzero(op_buf, len);
		free(op_buf, M_DEVBUF);
@


1.1
log
@Initial revision
@
text
@d1 1
d6 20
d79 1
a79 1
void	viac3_rnd(void *);
a81 1

a82 1

d84 3
a86 3
	u_int32_t	ses_ekey[4 * (MAXNR + 1) + 4];	/* 128 bit aligned */
	u_int32_t	ses_dkey[4 * (MAXNR + 1) + 4];	/* 128 bit aligned */
	u_int8_t	ses_iv[16];			/* 128 bit aligned */
d91 1
a91 1
};
d94 2
a95 2
	u_int32_t		op_cw[4];		/* 128 bit aligned */
	u_int8_t		op_iv[16];		/* 128 bit aligned */
d102 1
a102 1
};
d116 10
d145 7
d255 6
a260 4
	/* Do the deed */
	__asm __volatile("pushfl; popfl");
	__asm __volatile("rep xcrypt-cbc" :
	    : "a" (iv), "b" (key), "c" (rep), "d" (cw), "S" (src), "D" (dst)
d281 1
a281 1
	    crd->crd_alg != CRYPTO_AES_CBC || 
d383 138
a574 1

@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@pull in a number of openbsd revisions (catches up with 4.8erratum006 too)
@
text
@a1 1
/* + 1.2 1.7 1.8 1.13p 1.15 1.16 1.19 1.21 1.25 1.26 1.27 1.28 */
d67 1
d102 1
a102 2
	if ((vc3_sc = malloc(sizeof(*vc3_sc), M_DEVBUF,
	    M_NOWAIT|M_ZERO)) == NULL)
d104 1
d110 1
a110 2
	if (vc3_sc->sc_cid < 0) {
		free(vc3_sc, M_DEVBUF);
a111 1
	}
d115 1
a115 1
	i386_has_xcrypt = viac3_crypto_present;
d167 1
a167 1
			explicit_bzero(sc->sc_sessions, sesn * sizeof(*ses));
d178 1
d206 1
a206 1
	explicit_bzero(&sc->sc_sessions[sesn], sizeof(sc->sc_sessions[sesn]));
d238 2
a239 1
		return (EINVAL);
a254 4
	if (ses->ses_used == 0) {
		err = EINVAL;
		goto out;
	}
d268 1
a268 1
			arc4random_buf(sc->op_iv, 16);
d321 13
d336 1
a336 1
		explicit_bzero(sc->op_buf, crd->crd_len);
@


1.1.1.1.4.1
log
@begin implementing the VIA C3 hwcrypt operations
missing: rijndael.c does ECB only, we need xcrypt-ecb call in via.c now
@
text
@a0 1
/**	$MirOS$ */
a4 1
 * Copyright (c) 2007 Thorsten Glaser
d58 1
a58 1
void viac3_rnd(void *);
d61 1
a63 5
void viac3_rijndael_decrypt(rijndael_ctx *, u_char *, u_char *);
void viac3_rijndael_encrypt(rijndael_ctx *, u_char *, u_char *);
int viac3_rijndael_set_key(rijndael_ctx *, u_char *, int);
int viac3_rijndael_set_key_enc_only(rijndael_ctx *, u_char *, int);

a344 110
int
viac3_rijndael_set_key(rijndael_ctx *ctx, u_char *key, int bits)
{
	int i, cw0;

	if ((i = rijndael_set_key(ctx, key, bits)))
		return (i);

	switch (bits) {
	case 128:
		cw0 = C3_CRYPT_CWLO_KEY128;
		break;
	case 192:
		cw0 = C3_CRYPT_CWLO_KEY192;
		break;
	case 256:
		cw0 = C3_CRYPT_CWLO_KEY256;
		break;
	default:
		return (0);
	}
	cw0 |= C3_CRYPT_CWLO_ALG_AES | C3_CRYPT_CWLO_KEYGEN_SW |
	    C3_CRYPT_CWLO_NORMAL;

	ctx->hwcr_info.via.cw0 = cw0;

	for (i = 0; i < 4 * (MAXNR + 1); i++) {
		ctx->ek[i] = ntohl(ctx->ek[i]);
		ctx->dk[i] = ntohl(ctx->dk[i]);
	}

	ctx->hwcr_nr = RIJNDAEL_HWCR_VIA;
	return (0);
}

int
viac3_rijndael_set_key_enc_only(rijndael_ctx *ctx, u_char *key, int bits)
{
	int i, cw0;

	if ((i = rijndael_set_key_enc_only(ctx, key, bits)))
		return (i);

	switch (bits) {
	case 128:
		cw0 = C3_CRYPT_CWLO_KEY128;
		break;
	case 192:
		cw0 = C3_CRYPT_CWLO_KEY192;
		break;
	case 256:
		cw0 = C3_CRYPT_CWLO_KEY256;
		break;
	default:
		return (0);
	}
	cw0 |= C3_CRYPT_CWLO_ALG_AES | C3_CRYPT_CWLO_KEYGEN_SW |
	    C3_CRYPT_CWLO_NORMAL;

	ctx->hwcr_info.via.cw0 = cw0;

	for (i = 0; i < 4 * (MAXNR + 1); i++)
		ctx->ek[i] = ntohl(ctx->ek[i]);

	ctx->hwcr_nr = RIJNDAEL_HWCR_VIA;
	return (0);
}

#if 0
void
viac3_rijndael_encrypt(rijndael_ctx *ctx, u_char *src, u_char *dst)
{
	uint32_t op_cw[4];
	uint8_t op_buf[...] __attribute__((aligned (16)));

	if (ctx->hwcr_nr != RIJNDAEL_HWCR_VIA) {
		rijndael_encrypt(ctx, src, dst);
		return;
	}

	memmove(op_buf, src, sizeof (op_buf));

	op_cw[0] = ctx->hwcr_info.via.cw0 | C3_CRYPT_CWLO_ENCRYPT;
	op_cw[1] = op_cw[2] = op_cw[3] = 0;
	viac3_ecb(&op_cw, src, dst, ctx->ek, sizeof (op_buf) / 16, …?);

	memmove(dst, op_buf, sizeof (op_buf));
}

void
viac3_rijndael_decrypt(rijndael_ctx *ctx, u_char *src, u_char *dst)
{
	uint32_t op_cw[4];
	uint8_t op_buf[...] __attribute__((aligned (16)));

	if (ctx->hwcr_nr != RIJNDAEL_HWCR_VIA) {
		rijndael_encrypt(ctx, src, dst);
		return;
	}

	memmove(op_buf, src, sizeof (op_buf));

	op_cw[0] = ctx->hwcr_info.via.cw0 | C3_CRYPT_CWLO_DECRYPT;
	op_cw[1] = op_cw[2] = op_cw[3] = 0;
	viac3_ecb(&op_cw, src, dst, ctx->ek, sizeof (op_buf) / 16, …?);

	memmove(dst, op_buf, sizeof (op_buf));
}
#endif /* 0 */

d399 1
@


1.1.1.1.4.2
log
@I think I can test that now with an LKM
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/i386/via.c,v 1.1.1.1.4.1 2007/10/21 17:48:12 tg Exp $ */
a66 1
void viac3_rijndael_xcrypt(rijndael_ctx *, u_char *, u_char *, int);
a100 1
static __inline void viac3_ecb(void *, void *, void *, void *, int);
d217 2
a218 18
viac3_ecb(void *cw, void *src, void *dst, void *key, int rep)
{
	unsigned int creg0;

	creg0 = rcr0();		/* Permit access to SIMD/FPU path */
	lcr0(creg0 & ~(CR0_EM|CR0_TS));

	/* Do the deed */
	__asm __volatile("pushfl; popfl");
	__asm __volatile("rep xcrypt-ecb" :
	    : "b" (key), "c" (rep), "d" (cw), "S" (src), "D" (dst)
	    : "memory", "cc");

	lcr0(creg0);
}

static __inline void
viac3_cbc(void *cw, void *src, void *dst, void *key, int rep, void *iv)
d372 4
a381 2
	ctx->hwcr_info.via.cw0 = cw0 | C3_CRYPT_CWLO_ALG_AES |
	    C3_CRYPT_CWLO_KEYGEN_SW | C3_CRYPT_CWLO_NORMAL;
d407 4
a414 2
	ctx->hwcr_info.via.cw0 = cw0 | C3_CRYPT_CWLO_ALG_AES |
	    C3_CRYPT_CWLO_KEYGEN_SW | C3_CRYPT_CWLO_NORMAL;
d419 1
d421 1
a421 1
viac3_rijndael_xcrypt(rijndael_ctx *ctx, u_char *src, u_char *dst, int encr)
d423 9
a431 2
	uint32_t op_cw[4] __attribute__((aligned (16))) = { 0, 0, 0, 0 };
	uint8_t op_buf[16] __attribute__((aligned (16)));
d433 5
a437 5
	memcpy(op_buf, src, sizeof (op_buf));
	op_cw[0] = ctx->hwcr_info.via.cw0 |
	    encr ? C3_CRYPT_CWLO_ENCRYPT : C3_CRYPT_CWLO_DECRYPT;
	viac3_ecb(&op_cw, op_buf, op_buf, encr ? ctx->ek : ctx->dk, 1);
	memcpy(dst, op_buf, sizeof (op_buf));
d441 1
a441 1
viac3_rijndael_encrypt(rijndael_ctx *ctx, u_char *src, u_char *dst)
d443 4
a446 3
	if (ctx->hwcr_nr == RIJNDAEL_HWCR_VIA)
		viac3_rijndael_xcrypt(ctx, src, dst, 1);
	else
d448 10
d459 1
a460 8
void
viac3_rijndael_decrypt(rijndael_ctx *ctx, u_char *src, u_char *dst)
{
	if (ctx->hwcr_nr == RIJNDAEL_HWCR_VIA)
		viac3_rijndael_xcrypt(ctx, src, dst, 0);
	else
		rijndael_decrypt(ctx, src, dst);
}
@


1.1.1.1.4.3
log
@revert all of the old diffs for the tg-crypto-improvements branch,
except the alignment changes to the rĳndaël ctx structure
@
text
@d1 1
d6 1
d60 1
a60 1
void	viac3_rnd(void *);
d63 1
d65 5
a69 1
#ifdef CRYPTO
d102 1
d219 18
a236 2
viac3_cbc(void *cw, void *src, void *dst, void *key, int rep,
    void *iv)
d267 1
a267 1
	    crd->crd_alg != CRYPTO_AES_CBC ||
d369 94
a516 1

@


1.1.1.1.4.4
log
@this should, in theory, be enough to support hw crypto (padlock) in the
same manner as rijndael.c’s new CBC functions
@
text
@a0 1
/**	$MirOS$ */
a6 1
 * Copyright (c) 2008 Thorsten Glaser
d58 1
a58 1
void viac3_rnd(void *);
d72 1
a72 1
} __attribute__((aligned (16)));
d83 1
a83 1
} __attribute__((aligned (16)));
a96 7
void viac3_rijndael_decrypt(rijndael_ctx *, u_char *, u_char *, u_char *, int);
void viac3_rijndael_encrypt(rijndael_ctx *, u_char *, u_char *, u_char *, int);
void viac3_rijndael_cbc_xcrypt(rijndael_ctx *, u_char *, u_char *, u_char *,
    int, bool);
int viac3_rijndael_set_key(rijndael_ctx *, u_char *, int);
int viac3_rijndael_set_key_enc_only(rijndael_ctx *, u_char *, int);

a344 116
int
viac3_rijndael_set_key(rijndael_ctx *ctx, u_char *key, int bits)
{
	int i, cw0;

	if ((i = rijndael_set_key(ctx, key, bits)))
		return (i);

	switch (bits) {
	case 128:
		cw0 = C3_CRYPT_CWLO_KEY128;
		break;
	case 192:
		cw0 = C3_CRYPT_CWLO_KEY192;
		break;
	case 256:
		cw0 = C3_CRYPT_CWLO_KEY256;
		break;
	default:
		return (0);
	}

	for (i = 0; i < 4 * (MAXNR + 1); i++) {
		ctx->ek[i] = bswap32(ctx->ek[i]);
		ctx->dk[i] = bswap32(ctx->dk[i]);
	}

	ctx->hwcr_info.via.cw0 = cw0 | C3_CRYPT_CWLO_ALG_AES |
	    C3_CRYPT_CWLO_KEYGEN_SW | C3_CRYPT_CWLO_NORMAL;
	ctx->hwcr_id = RIJNDAEL_HWCR_VIA;
	return (0);
}

int
viac3_rijndael_set_key_enc_only(rijndael_ctx *ctx, u_char *key, int bits)
{
	int i, cw0;

	if ((i = rijndael_set_key_enc_only(ctx, key, bits)))
		return (i);

	switch (bits) {
	case 128:
		cw0 = C3_CRYPT_CWLO_KEY128;
		break;
	case 192:
		cw0 = C3_CRYPT_CWLO_KEY192;
		break;
	case 256:
		cw0 = C3_CRYPT_CWLO_KEY256;
		break;
	default:
		return (0);
	}

	for (i = 0; i < 4 * (MAXNR + 1); i++)
		ctx->ek[i] = bswap32(ctx->ek[i]);

	ctx->hwcr_info.via.cw0 = cw0 | C3_CRYPT_CWLO_ALG_AES |
	    C3_CRYPT_CWLO_KEYGEN_SW | C3_CRYPT_CWLO_NORMAL;
	ctx->hwcr_id = RIJNDAEL_HWCR_VIA;
	return (0);
}

void
viac3_rijndael_cbc_xcrypt(rijndael_ctx *ctx, u_char *iv, u_char *src,
    u_char *dst, int nblocks, bool encr)
{
	uint32_t op_cw[4] __attribute__((aligned (16))) = { 0, 0, 0, 0 };
	uint8_t op_iv[16] __attribute__((aligned (16)));
//	uint8_t a_blk[16] __attribute__((aligned (16)));
	void *op_buf;
	size_t len = nblocks * 16;

	op_cw[0] = ctx->hwcr_info.via.cw0 |
	    encr ? C3_CRYPT_CWLO_ENCRYPT : C3_CRYPT_CWLO_DECRYPT;
	memcpy(op_iv, iv, sizeof (op_iv));

	op_buf = (char *)malloc(len, M_DEVBUF, M_NOWAIT);
	if (op_buf == NULL) {
		printf("%s: cannot allocate %lu bytes for buffer,"
		    " data corrupted\n", __func__, len);
		return;
	}

	memcpy(op_buf, src, len);
	viac3_cbc(&op_cw, op_buf, op_buf, encr ? ctx->ek : ctx->dk,
	    nblocks, op_iv);
	memcpy(dst, op_buf, len);

	bzero(op_buf, len);
	free(op_buf, M_DEVBUF);

	/* we have to adjust the IV manually */
	memcpy(iv, (encr ? dst : src) + len - sizeof (op_iv), sizeof (op_iv));
}

void
viac3_rijndael_encrypt(rijndael_ctx *ctx, u_char *iv, u_char *src,
    u_char *dst, int nblocks)
{
	if (ctx->hwcr_id == RIJNDAEL_HWCR_VIA)
		viac3_rijndael_cbc_xcrypt(ctx, iv, src, dst, nblocks, true);
	else
		rijndael_cbc_encrypt(ctx, iv, src, dst, nblocks);
}

void
viac3_rijndael_decrypt(rijndael_ctx *ctx, u_char *iv, u_char *src,
    u_char *dst, int nblocks)
{
	if (ctx->hwcr_id == RIJNDAEL_HWCR_VIA)
		viac3_rijndael_cbc_xcrypt(ctx, iv, src, dst, nblocks, false);
	else
		rijndael_cbc_decrypt(ctx, iv, src, dst, nblocks);
}
@


1.1.1.1.4.5
log
@support NULL IVs here, too
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/i386/via.c,v 1.1.1.1.4.4 2008/03/21 01:06:37 tg Exp $ */
d430 1
a430 4
	if (iv == NULL)
		bzero(op_iv, sizeof (op_iv));
	else
		memcpy(op_iv, iv, sizeof (op_iv));
d447 2
a448 4
	if (iv != NULL)
		/* we have to adjust the IV manually */
		memcpy(iv, (encr ? dst : src) + len - sizeof (op_iv),
		    sizeof (op_iv));
@


1.1.1.1.4.6
log
@one cannot use "bool" inside the kernel :(
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/i386/via.c,v 1.1.1.1.4.5 2008/03/21 01:14:58 tg Exp $ */
d102 1
a102 1
    int, int);
d420 1
a420 1
    u_char *dst, int nblocks, int encr)
d461 1
a461 1
		viac3_rijndael_cbc_xcrypt(ctx, iv, src, dst, nblocks, 1);
d471 1
a471 1
		viac3_rijndael_cbc_xcrypt(ctx, iv, src, dst, nblocks, 0);
@


1.1.1.1.4.7
log
@now that this compiles, take over, so that we can test if the
functions work, using our fine LKM
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/i386/via.c,v 1.1.1.1.4.6 2008/03/21 02:55:05 tg Exp $ */
a124 7

	/* take over */
	rijndael_set_key_fast = viac3_rijndael_set_key;
	rijndael_set_key_enc_only_fast = viac3_rijndael_set_key_enc_only;
	rijndael_cbc_decrypt_fast = viac3_rijndael_decrypt;
	rijndael_cbc_encrypt_fast = viac3_rijndael_encrypt;
	printf("cpu0: VIA C3 AES functions used for swapencrypt\n");
@


1.1.1.1.4.8
log
@• if we want to use this for swapencrypt, we must also be
  able to handle an OOM situation where malloc(9) fails
• same fix as for sys/crypto/rijndael.c
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/i386/via.c,v 1.1.1.1.4.7 2008/03/21 02:55:35 tg Exp $ */
d431 1
a431 1
	uint8_t a_blk[16] __attribute__((aligned (16)));
a442 1

d444 4
a447 2
		/* may be OOM situation (swapencrypt?) but warn/inform */
		printf("%s: cannot allocate %lu bytes", __func__, len);
d449 4
a452 19
		/* use a_blk to handle 16 bytes at a time only */
		while (nblocks--) {
			memcpy(a_blk, src, sizeof (a_blk));
			viac3_cbc(&op_cw, a_blk, a_blk,
			    encr ? ctx->ek : ctx->dk, 1, op_iv);
			/* adjust IV manually (sigh) */
			memcpy(op_iv, encr ? a_blk : src, sizeof (op_iv));
			memcpy(dst, a_blk, sizeof (a_blk));
			src += sizeof (a_blk);
			dst += sizeof (a_blk);
		}
	} else {
		memcpy(op_buf, src, len);
		viac3_cbc(&op_cw, op_buf, op_buf, encr ? ctx->ek : ctx->dk,
		    nblocks, op_iv);
		/* adjust IV manually (sigh) */
		memcpy(op_iv, (encr ? op_buf : src) + len - sizeof (op_iv),
		    sizeof (op_iv));
		memcpy(dst, op_buf, len);
d454 2
a455 3
		bzero(op_buf, len);
		free(op_buf, M_DEVBUF);
	}
d458 3
a460 1
		memcpy(iv, op_iv, sizeof (op_iv));
@


1.1.1.1.4.9
log
@I think using __attribute__((aligned)) is impossible for stack variables
I may be mistaken, but otherwise this behaviour would be unexplainable
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/i386/via.c,v 1.1.1.1.4.8 2008/03/21 04:07:15 tg Exp $ */
a424 4
static uint32_t cbc_xcrypt_op_cw[4] __attribute__((aligned (16)));
static uint8_t cbc_xcrypt_op_iv[16] __attribute__((aligned (16)));
static uint8_t cbc_xcrypt_a_blk[16] __attribute__((aligned (16)));

d429 5
a433 2
	void *cbc_xcrypt_op_buf;
	size_t len = nblocks * sizeof (cbc_xcrypt_a_blk);
d435 1
a435 1
	cbc_xcrypt_op_cw[0] = ctx->hwcr_info.via.cw0 |
a436 1
	cbc_xcrypt_op_cw[1] = cbc_xcrypt_op_cw[2] = cbc_xcrypt_op_cw[3] = 0;
d438 1
a438 1
		bzero(cbc_xcrypt_op_iv, sizeof (cbc_xcrypt_op_iv));
d440 1
a440 1
		memcpy(cbc_xcrypt_op_iv, iv, sizeof (cbc_xcrypt_op_iv));
d442 1
a442 1
	cbc_xcrypt_op_buf = (char *)malloc(len, M_DEVBUF, M_NOWAIT);
d444 1
a444 1
	if (cbc_xcrypt_op_buf == NULL) {
d448 1
a448 1
		/* use cbc_xcrypt_a_blk to handle 16 bytes at a time only */
d450 3
a452 5
			memcpy(cbc_xcrypt_a_blk, src,
			    sizeof (cbc_xcrypt_a_blk));
			viac3_cbc(&cbc_xcrypt_op_cw, cbc_xcrypt_a_blk,
			    cbc_xcrypt_a_blk, encr ? ctx->ek : ctx->dk, 1,
			    cbc_xcrypt_op_iv);
d454 4
a457 6
			memcpy(cbc_xcrypt_op_iv, encr ? cbc_xcrypt_a_blk : src,
			    sizeof (cbc_xcrypt_op_iv));
			memcpy(dst, cbc_xcrypt_a_blk,
			    sizeof (cbc_xcrypt_a_blk));
			src += sizeof (cbc_xcrypt_a_blk);
			dst += sizeof (cbc_xcrypt_a_blk);
d460 3
a462 4
		memcpy(cbc_xcrypt_op_buf, src, len);
		viac3_cbc(&cbc_xcrypt_op_cw, cbc_xcrypt_op_buf,
		    cbc_xcrypt_op_buf, encr ? ctx->ek : ctx->dk,
		    nblocks, cbc_xcrypt_op_iv);
d464 3
a466 5
		memcpy(cbc_xcrypt_op_iv,
		    (encr ? cbc_xcrypt_op_buf : src) +
		    len - sizeof (cbc_xcrypt_op_iv),
		    sizeof (cbc_xcrypt_op_iv));
		memcpy(dst, cbc_xcrypt_op_buf, len);
d468 2
a469 2
		bzero(cbc_xcrypt_op_buf, len);
		free(cbc_xcrypt_op_buf, M_DEVBUF);
d473 1
a473 1
		memcpy(iv, cbc_xcrypt_op_iv, sizeof (cbc_xcrypt_op_iv));
@


1.1.1.1.4.10
log
@man 7 operator… priorities…
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/i386/via.c,v 1.1.1.1.4.9 2008/03/21 18:09:23 tg Exp $ */
d437 1
a437 1
	    (encr ? C3_CRYPT_CWLO_ENCRYPT : C3_CRYPT_CWLO_DECRYPT);
@


1.1.1.1.4.11
log
@malloc debugging
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/i386/via.c,v 1.1.1.1.4.10 2008/03/21 18:19:30 tg Exp $ */
a444 1
printf("%s: got %lu bytes at %p from malloc\n", __func__, len, cbc_xcrypt_op_buf);
a477 1
printf("%s: trying to free at %p ...\n", __func__, cbc_xcrypt_op_buf);
@


1.1.1.1.4.12
log
@I think this clobbers it
damn optimisations!
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/i386/via.c,v 1.1.1.1.4.11 2008/03/21 18:43:46 tg Exp $ */
d239 1
a239 1
	    : "a", "b", "c", "d", "S", "D", "memory", "cc");
@


1.1.1.1.4.13
log
@Okay, das war ein Schuß in den Ofen.

re-read the gcc texinfo documentation on extended assembly syntax,
constraints, etc.; rewrite the actual CPU call; fix data corruption
bug apparently also existing in OpenBSD
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/i386/via.c,v 1.1.1.1.4.12 2008/03/21 18:53:21 tg Exp $ */
d235 5
a239 5
	__asm__ volatile("pushfl; popfl");
	__asm__ volatile("rep xcrypt-cbc"
	    : "+a" (iv), "+S" (src), "+D" (dst)
	    : "b" (key), "c" (rep), "d" (cw)
	    : "memory", "cc");
@


1.1.1.1.4.14
log
@optimise and beautify; remove debugging crap
@
text
@d1 1
a1 1
/**	$MirOS$ */
a5 20
 * Copyright (c) 2008
 *	Thorsten “mirabilos” Glaser <tg@@mirbsd.de>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided “AS IS” and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person’s immediate fault when using the work as intended.
 */

/*-
d8 1
d63 1
d65 1
d67 3
a69 3
	u_int32_t	ses_ekey[4*(MAXNR+1)+4] __attribute__((aligned (16)));
	u_int32_t	ses_dkey[4*(MAXNR+1)+4] __attribute__((aligned (16)));
	u_int8_t	ses_iv[16] __attribute__((aligned (16)));
d77 2
a78 2
	u_int32_t		op_cw[4] __attribute__((aligned (16)));
	u_int8_t		op_iv[16] __attribute__((aligned (16)));
a98 4
static uint32_t viac3_r_cw[4] __attribute__((aligned (16)));
static uint8_t viac3_r_iv[16] __attribute__((aligned (16)));
static uint8_t viac3_r_buf[16] __attribute__((aligned (16)));

d101 2
a102 1
void viac3_rijndael_cbc(rijndael_ctx *, u_char *, u_char *, u_char *, int, int);
a234 1
	/* ensure the key is reloaded */
a235 1
	/* actual encryption */
d425 4
d430 2
a431 2
viac3_rijndael_cbc(rijndael_ctx *ctx, u_char *iv, u_char *src, u_char *dst,
    int nblocks, int encr)
d433 2
a434 2
	void *op_buf;
	size_t len = nblocks * sizeof (viac3_r_buf);
d436 1
a436 2
	bzero(viac3_r_cw, sizeof (viac3_r_cw));
	viac3_r_cw[0] = ctx->hwcr_info.via.cw0 |
d438 1
a438 1

d440 1
a440 1
		bzero(viac3_r_iv, sizeof (viac3_r_iv));
d442 4
a445 1
		memcpy(viac3_r_iv, iv, sizeof (viac3_r_iv));
d447 1
a447 1
	if ((op_buf = malloc(len, M_DEVBUF, M_NOWAIT)) == NULL) {
d449 1
a449 1
		printf("%s: notice: cannot allocate %lu bytes", __func__, len);
d451 1
a451 1
		/* use viac3_r_buf to handle 16 bytes at a time only */
d453 5
a457 4
			memcpy(viac3_r_buf, src, sizeof (viac3_r_buf));

			viac3_cbc(&viac3_r_cw, viac3_r_buf, viac3_r_buf,
			    encr ? ctx->ek : ctx->dk, 1, viac3_r_iv);
d459 6
a464 6
			memcpy(viac3_r_iv, encr ? viac3_r_buf : src,
			    sizeof (viac3_r_iv));

			memcpy(dst, viac3_r_buf, sizeof (viac3_r_buf));
			src += sizeof (viac3_r_buf);
			dst += sizeof (viac3_r_buf);
d467 4
a470 5
		/* handle all blocks at once */
		memcpy(op_buf, src, len);

		viac3_cbc(&viac3_r_cw, op_buf, op_buf,
		    encr ? ctx->ek : ctx->dk, nblocks, viac3_r_iv);
d472 9
a480 8
		memcpy(viac3_r_iv,
		    (encr ? op_buf : src) + len - sizeof (viac3_r_iv),
		    sizeof (viac3_r_iv));

		memcpy(dst, op_buf, len);

		bzero(op_buf, len);
		free(op_buf, M_DEVBUF);
d484 1
a484 1
		memcpy(iv, viac3_r_iv, sizeof (viac3_r_iv));
d492 1
a492 1
		viac3_rijndael_cbc(ctx, iv, src, dst, nblocks, 1);
d502 1
a502 1
		viac3_rijndael_cbc(ctx, iv, src, dst, nblocks, 0);
d560 1
@


