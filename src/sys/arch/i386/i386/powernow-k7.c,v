head	1.10;
access;
symbols
	MIRBSD_10:1.9.0.4
	MIRBSD_10_BASE:1.9
	MIRBSD_9_BASE:1.9
	MIRBSD_8:1.7.0.2
	MIRBSD_8_BASE:1.7
	mirbsd:1.1.7;
locks; strict;
comment	@ * @;


1.10
date	2008.11.08.23.04.04;	author tg;	state Exp;
branches;
next	1.9;
commitid	10049161AB22DF5DFC5;

1.9
date	2006.06.15.19.18.51;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004491B2706C2443B2;

1.8
date	2006.02.26.01.17.26;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004401019D54AE94F2;

1.7
date	2005.06.29.17.05.18;	author tg;	state Exp;
branches;
next	1.6;
commitid	95942c2d4d3a7eb;

1.6
date	2005.05.27.03.11.02;	author tg;	state Exp;
branches;
next	1.5;
commitid	dad42968fc881af;

1.5
date	2005.05.06.12.32.05;	author tg;	state Exp;
branches;
next	1.4;
commitid	4b77427b6308b079;

1.4
date	2005.05.05.23.06.25;	author tg;	state Exp;
branches;
next	1.3;
commitid	479f427aa6db5a5d;

1.3
date	2005.05.04.21.41.35;	author tg;	state Exp;
branches;
next	1.2;
commitid	457d4279418fcda6;

1.2
date	2005.05.04.18.12.39;	author tg;	state Exp;
branches;
next	1.1;
commitid	6b5442790f8aa337;

1.1
date	2005.03.06.16.33.43;	author tg;	state Exp;
branches
	1.1.7.1;
next	;

1.1.7.1
date	2005.03.06.16.33.43;	author tg;	state Exp;
branches;
next	;


desc
@@


1.10
log
@more mass conversions, including ancient eMail addresses
@
text
@/* $MirOS: src/sys/arch/i386/i386/powernow-k7.c,v 1.9 2006/06/15 19:18:51 tg Exp $ */
/* $OpenBSD: powernow-k7.c,v 1.3 2004/08/05 04:56:05 tedu Exp $ */

#ifndef SMALL_KERNEL

/* #define K7PN_DEBUG */

/*-
 * Copyright (c) 2005 Thorsten "mirabilos" Glaser <tg@@MirBSD.de>
 * Copyright (c) 2004 Martin "deadbug" VÃ©giard <deadbug@@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* AMD POWERNOW(tm) K7 driver */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/sysctl.h>
#include <sys/device.h>

#include <dev/isa/isareg.h>

#include <machine/cpu.h>
#include <machine/bus.h>

#define BIOS_START		0xC0000
#define	BIOS_LEN		0x40000

#define MSR_K7_CTL		0xC0010041
#define CTL_SET_FID		0x0000000000010000ULL
#define CTL_SET_VID		0x0000000000020000ULL

struct psb_s {
	char signature[10];	/* AMDK7PNOW! */
	uint8_t version;
	uint8_t flags;
	uint16_t ttime;		/* Min Settling time */
	uint8_t reserved;
	uint8_t n_pst;		/* number of PSTs */
};

struct pst_s {
	uint32_t signature;	/* CPU ID */
	uint8_t fsb;		/* Front Side Bus frequency (Mhz) */
	uint8_t fid;		/* Max Frequency code */
	uint8_t vid;		/* Max Voltage code */
	uint8_t n_states;	/* Number of states */
};

struct state_s {
	uint8_t fid;		/* Frequency code */
	uint8_t vid;		/* Voltage code */
};

/* Taken from powernow-k7.c/Linux by Dave Jones */
static int fid_codes[32] = {
	110, 115, 120, 125, 50, 55, 60, 65,
	70, 75, 80, 85, 90, 95, 100, 105,
	30, 190, 40, 200, 130, 135, 140, 210,
	150, 225, 160, 165, 170, 180, -1, -1
};

static unsigned int k7pnow_fsb;
unsigned int k7pnow_ttime;
unsigned int k7pnow_nstates;
int k7pnow_state = -1;
struct k7pnow_freq_table_s {
	unsigned int frequency;
	struct state_s state;
} *k7pnow_freq_table;

static char *k7pnow_biosmem;
static struct psb_s *psb;

static int powernowhack_match(struct device *, void *, void *);
static void powernowhack_attach(struct device *, struct device *, void *);

struct cfattach powernowhack_ca = {
	sizeof(struct device), powernowhack_match, powernowhack_attach
};

struct cfdriver powernowhack_cd = {
	NULL, "powernowhack", DV_DULL
};


void
k7_powernow_init(void)
{
#ifdef K7PN_DEBUG
	printf("k7_powernow_init: called\n");
#endif
	k7pnow_state = -2;
}

static int
powernowhack_match(struct device *parent, void *match, void *aux)
{
	bus_space_handle_t bh;
	const char *ptr;
	unsigned i;

	if (__predict_false(aux == NULL))
		return 0;
	if (__predict_true(strcmp((ptr = *(char **)aux), "powernowhack")))
		return 0;

	if (k7pnow_state == -1) {
#ifdef K7PN_DEBUG
		printf("powernowhack_match: not attaching\n");
#endif
		return 0;
	} else if (k7pnow_state != -2) {
		printf("powernowhack_match: already attached\n");
		return 0;
	}
	k7pnow_state = -3;

	/* Look in the 0xE000 : 0xFFFF range for PST tables */
	if (bus_space_map(I386_BUS_SPACE_MEM, BIOS_START,
	    BIOS_LEN, 0, &bh)) {
		printf("powernowhack_match: couldn't map BIOS\n");
		return 0;
	}
	k7pnow_biosmem = malloc(BIOS_LEN, M_DEVBUF, M_NOWAIT);
	memcpy(k7pnow_biosmem, (void *)bh, BIOS_LEN);
	bus_space_unmap(I386_BUS_SPACE_MEM, bh, BIOS_LEN);

	ptr = k7pnow_biosmem;
	for (i = 0; i < BIOS_LEN; i += 16, ptr += 16)
		if (__predict_false(!memcmp(ptr, "AMDK7PNOW!", 10))) {
			psb = (struct psb_s *)ptr;
			k7pnow_ttime = psb->ttime;

			/* Only this version is supported */
			if (psb->version == 0x12)
				return 1;
		}

	psb = NULL;
	free(k7pnow_biosmem, M_DEVBUF);
	k7pnow_biosmem = NULL;
	return 0;
}

static int
k7pnow_dump(int i, struct pst_s *pst)
{
	printf("PST #%03X: CPUID %08X, FSB %d MHz, Max Freq %d MHz\n", i,
	    pst->signature, pst->fsb, pst->fsb * fid_codes[pst->fid] / 10);
	return 0;
}

static int
k7pnow_cpuid(int i, struct pst_s *pst)
{
	extern int cpu_id;

	return (pst->signature == cpu_id);
}

static int
k7pnow_bynumber(int i, struct pst_s *pst)
{
	return (i == k7pnow_state);
}

static struct state_s *
k7pnow_iter(int (*fn)(int, struct pst_s *))
{
	char *ptr = (char *)psb;
	struct pst_s *pst;
	int num;

	ptr += sizeof(struct psb_s);
	/* Find the right PST */
	for (num = 1; num <= psb->n_pst; ++num) {
		pst = (struct pst_s *)ptr;
		ptr += sizeof(struct pst_s);

		if ((*fn)(num, pst)) {
			k7pnow_fsb = pst->fsb;
			k7pnow_nstates = pst->n_states;
			return (struct state_s *)ptr;
		}
		ptr += sizeof(struct state_s) * pst->n_states;
	}
	return NULL;
}

static void
powernowhack_attach(struct device *parent, struct device *self, void *aux)
{
	extern int cpu_id;
	struct state_s *s;
	unsigned i, j;

	printf("\n");
	if (k7pnow_state != -3) {
		printf("powernowhack_attach: not matched %d\n", k7pnow_state);
		goto out;
	}

	if ((self->dv_cfdata->cf_flags & 0x4000) == 0x4000) {
		printf("powernowhack0: these PSTs are known\n");
		k7pnow_iter(k7pnow_dump);
		if ((self->dv_cfdata->cf_flags & 0x0FFF) == 0x0FFF)
			printf("powernowhack0: need PST matching"
			    " CPUID %08X\n", cpu_id);
	}

	if ((self->dv_cfdata->cf_flags & 0x8000) == 0)
		if ((s = k7pnow_iter(k7pnow_cpuid)) != NULL)
			goto found;

	if ((self->dv_cfdata->cf_flags & 0x0FFF) == 0)
		printf("powernowhack0: cannot find PST matching"
		    " CPUID %08X\n", cpu_id);

	if ((self->dv_cfdata->cf_flags & 0x0FFF) == 0x0FFF) {
		printf("powernowhack0: manual mode disabled by user"
		    " (flags 0xnFFF)\n");
		goto out;
	}

	if ((self->dv_cfdata->cf_flags & 0x4FFF) == 0) {
		printf("powernowhack0: tried these PSTs\n");
		k7pnow_iter(k7pnow_dump);
	}

	k7pnow_state = self->dv_cfdata->cf_flags & 0x0FFF;
	if (k7pnow_state == 0) {
		printf("powernowhack0: use flags 0x0nnn to select"
		    " correct PST, trying to use #001\n");
		k7pnow_state = 1;
	}

	if ((s = k7pnow_iter(k7pnow_bynumber)) != NULL)
		goto found;
	printf("powernowhack0: PST #%03X unavailable\n", k7pnow_state);
	goto out;

found:
	/* poor C has no push/pop */
	{
		register struct state_s *s2 = s;
		for (i = 0, j = 0; i < k7pnow_nstates; ++i, ++s2)
			if (__predict_true((s2->fid != 0) && (s2->vid != 0)))
				++j;
	}

	if (j == 0) {
		printf("powernowhack0: %d states, none available\n", i);
		goto out;
	}
	printf("cpu0: AMD K7 POWERNOW: %d states, %d available\n", i, j);
	k7pnow_nstates = j;

	k7pnow_freq_table = malloc(sizeof(struct k7pnow_freq_table_s) * j,
	    M_DEVBUF, M_WAITOK);

	for (i = 0; i < j; ++i) {
		while (__predict_false((s->fid == 0) || (s->vid == 0)))
			++s;
		k7pnow_freq_table[i].frequency = k7pnow_fsb
		    * fid_codes[s->fid] / 10;
		k7pnow_freq_table[i].state.fid = s->fid;
		k7pnow_freq_table[i].state.vid = s->vid;
		++s;
	}

	/* On bootup the frequency should be at its maximum */
	k7pnow_state = j - 1;

#ifdef K7PN_DEBUG
	for (i = 0; i < j; i++) {
		printf("\tstate %d\tFrequency %d\tFID %d, VID %d\n", i,
		    k7pnow_freq_table[i].frequency,
		    k7pnow_freq_table[i].state.fid,
		    k7pnow_freq_table[i].state.vid);
	}
#else
	j = 0;
	for (i = 0; i < k7pnow_nstates; i++) {
		if (j) {
			printf(", ");
		} else {
			printf("powernowhack0: frequencies available: ");
			++j;
		}
		printf("%d", k7pnow_freq_table[i].frequency);
	}
	printf(".\n");
#endif
	cpu_setperf = k7_powernow_setperf;

out:
	k7pnow_state = -4;
	free(k7pnow_biosmem, M_DEVBUF);
	k7pnow_biosmem = NULL;
	return;
}

int
k7_powernow_setperf(int level)
{
	unsigned int low, high, freq, i;
	uint32_t sgtc, vid = 0, fid = 0;
	uint64_t ctl;

	high = k7pnow_freq_table[k7pnow_nstates - 1].frequency;
	low = k7pnow_freq_table[0].frequency;
	freq = low + (high - low) * level / 100;

#ifdef K7PN_DEBUG
	printf("powernowhack0: setperf: level=%d, freq=%d\n", level, freq);
#endif

	for (i = 0; i < k7pnow_nstates; i++)
		/* Do we know how to set that frequency? */
		if (__predict_false(k7pnow_freq_table[i].frequency >= freq))
			break;
	fid = k7pnow_freq_table[i].state.fid;
	vid = k7pnow_freq_table[i].state.vid;

#ifdef K7PN_DEBUG
	printf("powernowhack0: found @@%d freq %d: fid %d, vid %d\n",
	    i, k7pnow_freq_table[i].frequency, fid, vid);
#endif

	/* Already set? */
	if (k7pnow_state == i) {
#ifdef K7PN_DEBUG
		printf("powernowhack0: leaving state %d unchanged\n", i);
#endif
		return 0;
	}
#ifdef K7PN_DEBUG
	printf("powernowhack0: setting new state %d (old state %d)\n",
	    i, k7pnow_state);
#endif

	/* Get CTL and only modify fid/vid/sgtc */
	ctl = rdmsr(MSR_K7_CTL);

	/* FID */
	ctl &= 0xFFFFFFFFFFFFFF00ULL;
	ctl |= fid;

	/* VID */
	ctl &= 0xFFFFFFFFFFFF00FFULL;
	ctl |= vid << 8;

	/* SGTC */
	if ((sgtc = k7pnow_ttime * 100) < 10000) sgtc = 10000;
	ctl &= 0xFFF00000FFFFFFFFULL;
	ctl |= (uint64_t)sgtc << 32;

	if (k7pnow_freq_table[k7pnow_state].frequency > freq) {
		wrmsr(MSR_K7_CTL, ctl | CTL_SET_FID);
		wrmsr(MSR_K7_CTL, ctl | CTL_SET_VID);
	} else {
		wrmsr(MSR_K7_CTL, ctl | CTL_SET_VID);
		wrmsr(MSR_K7_CTL, ctl | CTL_SET_FID);
	}
	ctl = rdmsr(MSR_K7_CTL);
	k7pnow_state = i;

	return 0;
}
#endif /* !SMALL_KERNEL */
@


1.9
log
@mirbsd.org, 66h.42h.de, bsdadvocacy.org, and whatnot
we changed that too often, try to clean up the mess
mostly outside the www/ module which is dead anyway.
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/i386/powernow-k7.c,v 1.8 2006/02/26 01:17:26 tg Exp $ */
d9 1
a9 1
 * Copyright (c) 2005 Thorsten "mirabile" Glaser <tg@@MirBSD.de>
@


1.8
log
@re-calibrate cycle counter on ANY hw.setperf write (which succeeded),
not just K7 powernow
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/i386/powernow-k7.c,v 1.7 2005/06/29 17:05:18 tg Exp $ */
d9 1
a9 1
 * Copyright (c) 2005 Thorsten "mirabile" Glaser <tg@@MirBSD.org>
@


1.7
log
@* fix spelling of deadbug's name
* add some more length for option bios (by deadbug)
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/i386/powernow-k7.c,v 1.6 2005/05/27 03:11:02 tg Exp $ */
a391 9
#ifdef K7PN_DEBUG
	printf("powernowhack0: calibrating...");
#endif
	i = splhigh();
	calibrate_cyclecounter();
	splx(i);
#ifdef K7PN_DEBUG
	printf("done\n");
#endif
a393 1

@


1.6
log
@I _think_ calibrating the TSC should be done at splhigh
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/i386/powernow-k7.c,v 1.5 2005/05/06 12:32:05 tg Exp $ */
d10 1
a10 1
 * Copyright (c) 2004 Martin "deadbug" Végiard <deadbug@@gmail.com>
d36 1
a36 1
/* AMD POWERNOW K7 driver */
d49 2
a50 2
#define BIOS_START		0xE0000
#define	BIOS_LEN		0x20000
@


1.5
log
@* clean up k7pnow_cur_freq abuse
* make some variables non-static so they can be changed
  via an LKM later (for systems with a HORRIDLY broken BIOS)
* shorten messages (on mana.66h.42h.de the dmesg buffer overruns)
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/i386/powernow-k7.c,v 1.4 2005/05/05 23:06:25 tg Exp $ */
d395 1
d397 1
@


1.4
log
@* teach mainbus0 about its powernowhack0 attachement
* prevent powernowhack0 from attaching as ANY mainbus0 attachement
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/i386/powernow-k7.c,v 1.3 2005/05/04 21:41:35 tg Exp $ */
d79 1
a79 1
static int k7pnow_fid_codes[32] = {
d87 4
a90 4
static unsigned int k7pnow_cur_freq;
static unsigned int k7pnow_ttime;
static unsigned int k7pnow_nstates;
static struct k7pnow_freq_table_s {
a94 1
static int k7pnow_state = -1;
d172 2
a173 3
	printf("PST #%03X: CPUID = 0x%08X, Max Freq = %d MHz,"
	    " FSB Freq = %d MHz\n", i, pst->signature,
	    pst->fsb * k7pnow_fid_codes[pst->fid] / 10, pst->fsb);
d231 1
a231 1
			printf("powernowhack0: need PST matching your"
d240 1
a240 1
		printf("powernowhack0: cannot find PST matching your"
d256 1
a256 1
		printf("powernowhack0: use flags 0x0nnn to select the"
d289 1
a289 1
		    * k7pnow_fid_codes[s->fid] / 10;
a296 1
	k7pnow_cur_freq = k7pnow_freq_table[k7pnow_state].frequency;
d311 1
a311 1
			printf("powernowhack0: Available Frequencies: ");
a364 1
	k7pnow_state = i;
d382 1
a382 1
	if (k7pnow_cur_freq > freq) {
d390 1
@


1.3
log
@* throw out illegal frequencies (fid=0 or vid=0) earlier
* various small optimisations
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/i386/powernow-k7.c,v 1.2 2005/05/04 18:12:39 tg Exp $ */
a48 2
#include "powernowhack.h"

a77 6
/* For ourselves */
struct k7pnow_freq_table_s {
	unsigned int frequency;
	struct state_s state;
};

d79 1
a79 1
int k7pnow_fid_codes[32] = {
d90 4
a93 1
static struct k7pnow_freq_table_s *k7pnow_freq_table;
a97 1
static int mypst;
d124 1
a124 1
	char *ptr;
d127 5
d155 1
a155 1
		if (!memcmp(ptr, "AMDK7PNOW!", 10)) {
d188 1
a188 1
k7pnow_mypst(int i, struct pst_s *pst)
d190 1
a190 1
	return (i == mypst);
a227 1
	k7pnow_state = -4;
d230 1
a230 1
		printf("powernowhack0: the following PSTs are available\n");
d252 1
a252 1
		printf("powernowhack0: tried the following PSTs\n");
d256 2
a257 2
	mypst = self->dv_cfdata->cf_flags & 0x0FFF;
	if (mypst == 0) {
d259 2
a260 2
		    " correct PST\npowernowhack0: trying to use PST #001\n");
		mypst = 1;
d263 1
a263 1
	if ((s = k7pnow_iter(k7pnow_mypst)) != NULL)
d265 1
a265 1
	printf("powernowhack0: PST #%03X unavailable\n", mypst);
d271 1
a271 1
		struct state_s *s2 = s;
d273 1
a273 1
			if ((s2->fid != 0) && (s2->vid != 0))
d288 1
a288 1
		while ((s->fid == 0) || (s->vid == 0))
d324 1
d347 1
a347 1
		if (k7pnow_freq_table[i].frequency >= freq)
@


1.2
log
@turn the K7 PowerNow driver into a device with flags,
changeable via UKC. Also, no action is taken if the speed
is not changed any more, we don't hold lock on 128 KiB of
unused RAM, allow selection of the correct PST or none at
all, list available PSTs verbosely, show available (but
not unusable (fid/vid == 0)) frequencies, offer a debug
mode for K7PN developers, have a nice manual page, do not
disturb on non-K7 boxen at all, look nice in general, use
more static functions and variables where possible, ...
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/i386/powernow-k7.c,v 1.1.7.1 2005/03/06 16:33:43 tg Exp $ */
d51 1
a51 1
#define BIOS_START		0xe0000
a57 2
#define cpufreq(x)		k7pnow_fsb * k7pnow_fid_codes[x] / 10

d94 5
a98 11
/* Prototypes */
int powernowhack_match(struct device *, void *, void *);
void powernowhack_attach(struct device *, struct device *, void *);
struct state_s *k7pnow_iter(int (*)(int, struct pst_s *));

/* Static variables */
unsigned int k7pnow_fsb;
unsigned int k7pnow_cur_freq;
unsigned int k7pnow_ttime;
unsigned int k7pnow_nstates;
struct k7pnow_freq_table_s *k7pnow_freq_table;
d105 3
a115 1
/* Functions */
d126 1
a126 1
int
d194 1
a194 1
struct state_s *
d217 1
a217 1
void
d271 7
a277 2
	k7pnow_freq_table = malloc(sizeof(struct k7pnow_freq_table_s) *
	    k7pnow_nstates, M_TEMP, M_WAITOK);
d279 18
a296 3
	for (i = 0; i < k7pnow_nstates; i++, s++) {
		k7pnow_freq_table[i].frequency = cpufreq(s->fid);
		k7pnow_freq_table[i].state = *s;
d300 1
a300 1
	k7pnow_state = i - 1;
a302 4
	printf("cpu0: AMD K7 POWERNOW: %d available states\n",
	    k7pnow_nstates);

	j = 0;
d304 1
a304 1
	for (i = 0; i < k7pnow_nstates; i++) {
a308 7
		if ((k7pnow_freq_table[i].state.fid != 0)
		    && (k7pnow_freq_table[i].state.vid != 0))
			j = 1;
	}
	if (!j) {
		printf("powernowhack0: No frequency available\n");
		goto out;
d311 1
d313 5
a317 10
		if ((k7pnow_freq_table[i].state.fid != 0)
		    && (k7pnow_freq_table[i].state.vid != 0)) {
			if (j) {
				printf(", ");
			} else {
				printf("powernowhack0: Available"
				    " Frequencies: ");
				j++;
			}
			printf("%d", k7pnow_freq_table[i].frequency);
d319 1
d321 1
a321 6
	if (j) {
		printf(".\n");
	} else {
		printf("none (can't happen)\n");
		goto out;
	}
d346 1
a346 1
	for (i = 0; i < k7pnow_nstates; i++) {
d348 1
a348 3
		if (k7pnow_freq_table[i].frequency >= freq) {
			fid = k7pnow_freq_table[i].state.fid;
			vid = k7pnow_freq_table[i].state.vid;
d350 2
a351 2
		}
	}
a357 3
	if (fid == 0 || vid == 0)
		return EINVAL;

@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $MirOS$ */
d4 7
a10 2
/*
 * Copyright (c) 2004 Martin Végiard.
d42 1
d49 2
d66 1
a66 1
	uint8_t n_pst;
d70 1
a70 1
	uint32_t signature;
d82 1
d85 1
a85 1
	struct state_s *state;
d96 5
d108 8
d117 14
a130 2
/* Prototypes */
struct state_s *k7_powernow_getstates(uint32_t, int);
d132 2
a133 2
struct state_s *
k7_powernow_getstates(uint32_t signature, int override)
d135 1
a135 3
	unsigned int i, j;
	struct psb_s *psb;
	struct pst_s *pst;
d137 1
a137 2
	static char *ptr1 = NULL;
	bus_space_handle_t bh;
d139 8
a146 4
	if (override && (ptr1 != NULL)) {
		pst = (struct pst_s *) ptr1;
		ptr = ptr1 + sizeof(struct pst_s);
		goto found;
d148 1
d150 5
a154 7
	/*
	 * Look in the 0xe0000 - 0x20000 physical address
	 * range for the pst tables; 16 byte blocks
	 */
	if (bus_space_map(I386_BUS_SPACE_MEM, BIOS_START, BIOS_LEN, 0, &bh)) {
		printf("k7_powernow: couldn't map BIOS\n");
		return NULL;
d156 2
a157 2
	ptr = malloc(BIOS_LEN, M_DEVBUF, M_NOWAIT);
	memcpy(ptr, (void *)bh, BIOS_LEN);
d160 4
a163 5
	for (i = 0; i < BIOS_LEN; i += 16, ptr += 16) {
		if (memcmp(ptr, "AMDK7PNOW!", 10) == 0) {
			psb = (struct psb_s *) ptr;
			ptr += sizeof(struct psb_s);

d167 69
a235 2
			if (psb->version != 0x12)
				return 0;
d237 80
a316 22
			ptr1 = ptr;
			/* Find the right PST */
			for (j = 0; j < psb->n_pst; j++) {
				pst = (struct pst_s *) ptr;
				ptr += sizeof(struct pst_s);

				/* Use the first PST with matching CPUID */
				if (signature == pst->signature) {
					/*
					 * XXX I need more info on this.
					 * For now, let's just ignore it
					 */
					if ((signature & 0xFF) == 0x60)
						return 0;

				found:
					k7pnow_fsb = pst->fsb;
					k7pnow_nstates = pst->n_states;
					return (struct state_s *)ptr;
				} else
					ptr += sizeof(struct state_s) *
					    pst->n_states;
d318 1
a318 13
			printf("k7_powernow: could not find power state "
			    "table for your CPUID %08X.\n\tThis is usually "
			    "a sign for a broken BIOS. Tried these IDs:\n\t",
			    signature);
			ptr = ptr1;
			for (j = 0; j < psb->n_pst; j++) {
				pst = (struct pst_s *) ptr;
				ptr += sizeof(struct pst_s);
				printf("%s%08X", j ? ", " : "",
				    pst->signature);
			}
			printf("\n");
			return 0;
d321 13
a333 2
	/* printf("Power state table not found\n"); */
	return 0;
d347 4
d354 2
a355 2
			fid = k7pnow_freq_table[i].state->fid;
			vid = k7pnow_freq_table[i].state->vid;
d360 5
d366 14
a379 1
		return (-1);
d406 3
d410 4
a413 1
	return (0);
d416 1
a416 35
void
k7_powernow_init(int flags)
{
	extern int cpu_id;
	uint32_t signature = cpu_id;
	unsigned int i;
	struct state_s *s;
	static int allowed = 0;

	if (flags == 1)
		allowed = 1;

	if ((flags == 2) && !allowed)
		return;

	s = k7_powernow_getstates(signature, (flags == 2) ? 1 : 0);
	if (s == 0)
		return;

	k7pnow_freq_table = malloc(sizeof(struct k7pnow_freq_table_s) *
	    k7pnow_nstates, M_TEMP, M_WAITOK);

	for (i = 0; i < k7pnow_nstates; i++, s++) {
		k7pnow_freq_table[i].frequency = cpufreq(s->fid);
		k7pnow_freq_table[i].state = s;
	}

	/* On bootup the frequency should be at its max */
	k7pnow_cur_freq = k7pnow_freq_table[i-1].frequency;

	printf("cpu0: AMD POWERNOW: %d available states%s\n",
	    k7pnow_nstates, (flags == 2) ? ", overriding BIOS" : "");
	cpu_setperf = k7_powernow_setperf;
	allowed = 0;
}
@


1.1.7.1
log
@Add some missing files, such as some ISDN4BSD stuff,
documentation, tmac and tab files, TAI64 etc.
@
text
@@
