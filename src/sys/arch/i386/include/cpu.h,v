head	1.14;
access;
symbols
	tg-beforemerge-ksrc10:1.1.1.1
	MIRBSD_10:1.6.0.2
	MIRBSD_10_BASE:1.6
	MIRBSD_9_BASE:1.5
	MIRBSD_8:1.4.0.2
	MIRBSD_8_BASE:1.4
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2018.12.15.03.56.11;	author tg;	state Exp;
branches;
next	1.13;
commitid	1005C147B6F4A7DC09D;

1.13
date	2018.12.15.03.47.52;	author tg;	state Exp;
branches;
next	1.12;
commitid	1005C147964542F35C6;

1.12
date	2018.12.14.21.28.09;	author tg;	state Exp;
branches;
next	1.11;
commitid	1005C142058354E0A9A;

1.11
date	2010.07.25.16.37.59;	author tg;	state Exp;
branches;
next	1.10;
commitid	1004C4C685B2784BE9E;

1.10
date	2009.03.01.11.58.32;	author tg;	state Exp;
branches;
next	1.9;
commitid	10049AA78645C680558;

1.9
date	2008.06.13.13.11.50;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004852721E130137B5;

1.8
date	2008.04.09.05.07.02;	author tg;	state Exp;
branches;
next	1.7;
commitid	10047FC4ED06FC54B95;

1.7
date	2008.04.09.04.58.12;	author tg;	state Exp;
branches;
next	1.6;
commitid	10047FC4C81287BDAE9;

1.6
date	2006.10.17.23.16.44;	author tg;	state Exp;
branches;
next	1.5;
commitid	100453563A91A6A305E;

1.5
date	2006.02.26.01.17.27;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004401019D54AE94F2;

1.4
date	2005.05.05.23.11.28;	author tg;	state Exp;
branches;
next	1.3;
commitid	6602427aa824a12d;

1.3
date	2005.05.04.18.12.39;	author tg;	state Exp;
branches;
next	1.2;
commitid	6b5442790f8aa337;

1.2
date	2005.03.06.21.26.59;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.27.25;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.27.25;	author tg;	state Exp;
branches;
next	;


desc
@@


1.14
log
@more space saving
@
text
@/**	$MirOS: src/sys/arch/i386/include/cpu.h,v 1.13 2018/12/15 03:47:52 tg Exp $ */
/*	$OpenBSD: cpu.h,v 1.59 2004/04/02 22:28:41 tedu Exp $	*/
/*	$NetBSD: cpu.h,v 1.35 1996/05/05 19:29:26 christos Exp $	*/

/*-
 * Copyright (c) 2006, 2008, 2010, 2018
 *	mirabilos <m@@mirbsd.org>
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * William Jolitz.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)cpu.h	5.4 (Berkeley) 5/9/91
 */

#ifndef _I386_CPU_H_
#define _I386_CPU_H_

/*
 * Definitions unique to i386 cpu support.
 */
#include <machine/psl.h>
#include <machine/frame.h>
#include <machine/segments.h>

/*
 * definitions of cpu-dependent requirements
 * referenced in generic code
 */
#define	cpu_swapin(p)			/* nothing */

/*
 * Arguments to hardclock, softclock and statclock
 * encapsulate the previous machine state in an opaque
 * clockframe; for now, use generic intrframe.
 *
 * XXX intrframe has a lot of gunk we don't need.
 */
#define clockframe intrframe

#define	CLKF_USERMODE(frame)	USERMODE((frame)->if_cs, (frame)->if_eflags)
#define	CLKF_PC(frame)		((frame)->if_eip)
#define	CLKF_INTR(frame)	(IDXSEL((frame)->if_cs) == GICODE_SEL)

/*
 * Preempt the current process if in interrupt from user mode,
 * or after the current trap/syscall if in system mode.
 */
int	want_resched;		/* resched() was called */
#define	need_resched()		(want_resched = 1, setsoftast())

/*
 * Give a profiling tick to the current process when the user profiling
 * buffer pages are invalid.  On the i386, request an ast to send us
 * through trap(), marking the proc as needing a profiling tick.
 */
#define	need_proftick(p)	((p)->p_flag |= P_OWEUPC, setsoftast())

/*
 * Notify the current process (p) that it has a signal pending,
 * process as soon as possible.
 */
#define	signotify(p)		setsoftast()

/*
 * We need a machine-independent name for this.
 */
#define	DELAY(x)		delay(x)
void	delay(int);

#if defined(I586_CPU) || defined(I686_CPU)
/*
 * High resolution clock support (Pentium only)
 */
void	calibrate_cyclecounter(void);
#ifndef	HZ
#ifndef PENTIUM_BROKEN_TSC
extern u_quad_t pentium_base_tsc;
#define CPU_CLOCKUPDATE()						\
	do {								\
		if (pentium_mhz) {					\
			__asm __volatile("cli\n"			\
					 "rdtsc\n"			\
					 "sti\n"			\
					 : "=A" (pentium_base_tsc)	\
					 : );				\
		}							\
	} while (0)
#endif /* !PENTIUM_BROKEN_TSC */
#define CPU_HARDCLOCKENT_DECL						\
	static u_quad_t cpu_hce_tsc
#define CPU_HARDCLOCKENT() do {						\
	if (pentium_mhz) {						\
		u_quad_t cpu_hce_val = cpu_hce_tsc;			\
									\
		__asm __volatile("cli\n"				\
				 "rdtsc\n"				\
				 "sti\n"				\
				 : "=A" (cpu_hce_tsc) : );		\
		HARDCLOCKENT_APPLY(cpu_hce_tsc - cpu_hce_val);		\
	}								\
} while (0)
#endif /* !HZ */
#define	__do_calibrate_cyclecounter(rvptr)				\
	do {								\
		if (pentium_mhz) {					\
			int i = splhigh();				\
			calibrate_cyclecounter();			\
			splx(i);					\
		}							\
	} while (0)
#else /* !(I586_CPU || I686_CPU) */
#define __do_calibrate_cyclecounter(rvptr)	/* nothing */
#endif /* !(I586_CPU || I686_CPU) */

/*
 * pull in #defines for kinds of processors
 */
#include <machine/cputypes.h>

struct cpu_nocpuid_nameclass {
	int cpu_vendor;
	const char *cpu_vendorname;
	const char *cpu_name;
	int cpu_class;
	void (*cpu_setup)(const char *, int, int);
};

struct cpu_cpuid_nameclass {
	const char *cpu_id;
	int cpu_vendor;
	const char *cpu_vendorname;
	struct cpu_cpuid_family {
		int cpu_class;
		const char *cpu_models[CPU_MAXMODEL+2];
		void (*cpu_setup)(const char *, int, int);
	} cpu_family[CPU_MAXFAMILY - CPU_MINFAMILY + 1];
};

struct cpu_cpuid_feature {
	int feature_bit;
	const char *feature_name;
};

#ifdef _KERNEL
extern int cpu;
extern int cpu_class;
extern int cpu_feature;
extern int cpu_ecxfeature;
extern int cpu_apmwarn;
extern int cpu_apmhalt;
extern int cpuid_level;
extern const struct cpu_nocpuid_nameclass i386_nocpuid_cpus[];
extern const struct cpu_cpuid_nameclass i386_cpuid_cpus[];

#if defined(I586_CPU) || defined(I686_CPU)
extern int pentium_mhz;
#endif

#ifdef I586_CPU
/* F00F bug fix stuff for pentium cpu */
extern u_char cpu_f00f_bug;
void fix_f00f(void);
#endif

/* dkcsum.c */
void	dkcsumattach(void);

extern u_char i386_use_fxsave;
extern u_char i386_has_sse;
extern u_char i386_has_sse2;

/* machdep.c */
void	dumpconf(void);
void	cpu_reset(void) __dead;
void	i386_proc0_tss_ldt_init(void);
void	cpuid(u_int32_t, u_int32_t *);

/* locore.s */
struct region_descriptor;
void	lgdt(struct region_descriptor *);
void	fillw(short, void *, size_t);

struct pcb;
void	savectx(struct pcb *);
void	switch_exit(struct proc *);
void	proc_trampoline(void);

/* clock.c */
void	initrtclock(void);
void	startrtclock(void);
void	rtcdrain(void *);

/* est.c */
#if !defined(SMALL_KERNEL) && defined(I686_CPU)
void	est_init(const char *);
int     est_cpuspeed(int *);
int     est_setperf(int);
#endif

/* longrun.c */
#if !defined(SMALL_KERNEL) && defined(I586_CPU)
void	longrun_init(void);
int	longrun_cpuspeed(int *);
int	longrun_setperf(int);
#endif

/* p4tcc.c */
#if !defined(SMALL_KERNEL) && defined(I686_CPU)
void	p4tcc_init(int, int);
int     p4tcc_setperf(int);
#endif

void	k6_powernow_init(void);
int	k6_powernow_setperf(int);
void	k7_powernow_init(void);
int	k7_powernow_setperf(int);


/* npx.c */
void	npxdrop(void);
void	npxsave(void);

#ifdef USER_LDT
/* sys_machdep.h */
extern int user_ldt_enable;
int	i386_get_ldt(struct proc *, void *, register_t *);
int	i386_set_ldt(struct proc *, void *, register_t *);
#endif

#if defined(GPL_MATH_EMULATE)
/* contrib/gnu/emu387/fpemul/math_emulate.c */
int	math_emulate(struct trapframe *);
#endif

/* isa_machdep.c */
void	isa_defaultirq(void);
int	isa_nmi(void);

/* pmap.c */
void	pmap_bootstrap(vaddr_t);

/* vm_machdep.c */
int	kvtop(caddr_t);

#ifdef VM86
/* vm86.c */
void	vm86_gpfault(struct proc *, int);
#endif /* VM86 */

#ifdef GENERIC
/* swapgeneric.c */
void	setconf(void);
#endif /* GENERIC */

#endif /* _KERNEL */

/*
 * CTL_MACHDEP definitions.
 */
#define	CPU_CONSDEV		1	/* dev_t: console terminal device */
#define	CPU_BIOS		2	/* BIOS variables */
#define	CPU_BLK2CHR		3	/* convert blk maj into chr one */
#define	CPU_CHR2BLK		4	/* convert chr maj into blk one */
#define CPU_ALLOWAPERTURE	5	/* allow mmap of /dev/xf86 */
#define CPU_CPUVENDOR		6	/* cpuid vendor string */
#define CPU_CPUID		7	/* cpuid */
#define CPU_CPUFEATURE		8	/* cpuid features */
#define CPU_APMWARN		9	/* APM battery warning percentage */
#define CPU_KBDRESET		10	/* keyboard reset under pcvt */
#define CPU_APMHALT		11	/* halt -p hack */
#define CPU_USERLDT		12
#define CPU_OSFXSR		13	/* uses FXSAVE/FXRSTOR */
#define CPU_SSE			14	/* supports SSE */
#define CPU_SSE2		15	/* supports SSE2 */
#define CPU_XCRYPT		16	/* supports VIA xcrypt in userland */
#define CPU_APVRESET		17	/* reset VGA on panic() if XF86 */
#define CPU_MAXID		18	/* number of valid machdep ids */

#define	CTL_MACHDEP_NAMES { \
	{ 0, 0 }, \
	{ "console_device", CTLTYPE_STRUCT }, \
	{ "bios", CTLTYPE_INT }, \
	{ "blk2chr", CTLTYPE_STRUCT }, \
	{ "chr2blk", CTLTYPE_STRUCT }, \
	{ "allowaperture", CTLTYPE_INT }, \
	{ "cpuvendor", CTLTYPE_STRING }, \
	{ "cpuid", CTLTYPE_INT }, \
	{ "cpufeature", CTLTYPE_INT }, \
	{ "apmwarn", CTLTYPE_INT }, \
	{ "kbdreset", CTLTYPE_INT }, \
	{ "apmhalt", CTLTYPE_INT }, \
	{ "userldt", CTLTYPE_INT }, \
	{ "osfxsr", CTLTYPE_INT }, \
	{ "sse", CTLTYPE_INT }, \
	{ "sse2", CTLTYPE_INT }, \
	{ "xcrypt", CTLTYPE_INT }, \
	{ "apvreset", CTLTYPE_INT }, \
}

#endif /* !_I386_CPU_H_ */
@


1.13
log
@some optimisation, and rework the emulation npxdna handling
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/include/cpu.h,v 1.12 2018/12/14 21:28:09 tg Exp $ */
d187 1
a187 1
extern int cpu_f00f_bug;
@


1.12
log
@reintegrate (as external contrib thingy, completely separate) the 387 emulation
up to the point where “make depend” succeeds and code bugs remain
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/include/cpu.h,v 1.11 2010/07/25 16:37:59 tg Exp $ */
d6 2
a7 2
 * Copyright (c) 2006, 2008, 2010
 *	Thorsten Glaser <tg@@mirbsd.org>
d194 3
a196 3
extern int i386_use_fxsave;
extern int i386_has_sse;
extern int i386_has_sse2;
@


1.11
log
@allow disabling use of the TSC for timekeeping (not CPU frequency stuff
and entropy stuff, though) via new compile-time option, for pfau.mb.o
(don’t know *yet* if that helps, though…)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/include/cpu.h,v 1.10 2009/03/01 11:58:32 tg Exp $ */
d256 5
@


1.10
log
@make cpu_reset() __dead and remove superfluous code
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/include/cpu.h,v 1.9 2008/06/13 13:11:50 tg Exp $ */
d6 2
a7 2
 * Copyright (c) 2006, 2008
 *	Thorsten Glaser <tg@@mirbsd.de>
d102 1
d114 1
d128 1
a128 1
#endif
d137 1
a137 1
#else
d139 1
a139 1
#endif
@


1.9
log
@speedup: only process rnd_addpool_allow check while draining, not adding
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/include/cpu.h,v 1.8 2008/04/09 05:07:02 tg Exp $ */
d198 1
a198 1
void	cpu_reset(void);
@


1.8
log
@only add to pool the VJ-whitening between _two_ deltas now
this is pretty much like cprng but with the TSC
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/include/cpu.h,v 1.7 2008/04/09 04:58:12 tg Exp $ */
d116 1
a116 1
	if (pentium_mhz && rnd_addpool_allow) {				\
@


1.7
log
@if we have a TSC (Pentium or so), add, HZ (usually 100) times per second,
the VJ-whitened (delta’d, like VIA RNG) TSC difference into the pool
→ could use the C0 timer on MIPS for this, for instance, IFF the board has
  an extra quartz for HZ intr (hardclock(9)) generation
⇒ need to find out what to use on ARM, SPARC
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/include/cpu.h,v 1.6 2006/10/17 23:16:44 tg Exp $ */
d117 1
a117 2
		u_quad_t cpu_hce_val = cpu_hce_tsc, cpu_hce_ent = 0;	\
		u_quad_t cpu_hce_mask = 0x8000000000000000ULL;		\
d123 1
a123 11
		cpu_hce_val = cpu_hce_tsc - cpu_hce_val;		\
		while (cpu_hce_mask) {					\
			if (cpu_hce_val & cpu_hce_mask) {		\
				cpu_hce_ent <<= 1;			\
				if (cpu_hce_tsc & cpu_hce_mask)		\
					cpu_hce_ent++;			\
			}						\
			cpu_hce_mask >>= 1;				\
		}							\
		rnd_addpool_add(cpu_hce_ent & 0xFFFFFFFF);		\
		rnd_addpool_add(cpu_hce_ent >> 32);			\
@


1.6
log
@Implement a new feature:
* new sysctl machdep.apvreset (CPU_APVRESET) default value: 1
* new global: void (*panic_hook)(void) = NULL; <sys/systm.h>
* new global: void (*panic_hook_display)(void) = NULL; (not declared)
* panic(): if (panic_hook != NULL) call it before printf()
* vga: on init, panic_hook_display = vga_panic_hook;
* aperture: on open, IF machdep.apvreset != 0, panic_hook = panic_hook_display;
  on close, panic_hook = NULL;

The vga_panic_hook() function at the moment does nothing (only
a debugging printf), but will contain code to reset the VGA video
mode to a sane, text mode, state. The code is of course only af-
fected if XF86 is active, and this is (as of yet) i386 specific.

This will help people dropping from X into ddb(4) and not seeing anything.
Not yet, though.
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/include/cpu.h,v 1.5 2006/02/26 01:17:27 tg Exp $ */
d6 1
a6 1
 * Copyright (c) 2006
d113 24
@


1.5
log
@re-calibrate cycle counter on ANY hw.setperf write (which succeeded),
not just K7 powernow
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/include/cpu.h,v 1.4 2005/05/05 23:11:28 tg Exp $ */
d282 2
a283 1
#define CPU_MAXID		17	/* number of valid machdep ids */
d303 1
@


1.4
log
@remove some (FBSD, iBCS2, SVR4 emul; GPL'd FPU emul) junk
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/include/cpu.h,v 1.3 2005/05/04 18:12:39 tg Exp $ */
d6 2
d114 10
@


1.3
log
@turn the K7 PowerNow driver into a device with flags,
changeable via UKC. Also, no action is taken if the speed
is not changed any more, we don't hold lock on 128 KiB of
unused RAM, allow selection of the correct PST or none at
all, list available PSTs verbosely, show available (but
not unusable (fid/vid == 0)) frequencies, offer a debug
mode for K7PN developers, have a nice manual page, do not
disturb on non-K7 boxen at all, look nice in general, use
more static functions and variables where possible, ...
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/include/cpu.h,v 1.2 2005/03/06 21:26:59 tg Exp $ */
a221 5
#if defined(GPL_MATH_EMULATE)
/* math_emulate.c */
int	math_emulate(struct trapframe *);
#endif

@


1.2
log
@* merge src/sys/
  (at least the better part of it)
* revert IPv6 networking to OpenBSD, since
  I didn't get IPV4_MAPPED addresses working :(
@
text
@d1 1
a1 1
/**	$MirOS$ */
d214 1
a214 1
void	k7_powernow_init(int);
@


1.1
log
@Initial revision
@
text
@d1 1
d214 2
d256 1
a256 1
/* 
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@
