head	1.34;
access;
symbols
	tg-use_ldscript:1.33.0.2
	tg-beforemerge-ksrc10:1.1.1.3
	cvs-200808011000:1.1.1.3
	MIRBSD_10:1.30.0.2
	MIRBSD_10_BASE:1.30
	MIRBSD_9_BASE:1.17
	MIRBSD_8:1.5.0.2
	MIRBSD_8_BASE:1.5
	cvs-200507032030:1.1.1.2
	cvs-200505050030:1.1.1.2
	cvs-200504291700:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.34
date	2009.11.22.14.53.41;	author tg;	state Exp;
branches;
next	1.33;
commitid	1004B09507705A9F610;

1.33
date	2009.06.07.13.08.57;	author tg;	state Exp;
branches;
next	1.32;
commitid	1004A2BBC007F97FAA2;

1.32
date	2009.06.07.11.46.28;	author tg;	state Exp;
branches;
next	1.31;
commitid	1004A2BA8982BB20062;

1.31
date	2009.01.31.18.51.19;	author tg;	state Exp;
branches;
next	1.30;
commitid	10049849D7F07A9D7B9;

1.30
date	2007.07.31.21.43.57;	author tg;	state Exp;
branches;
next	1.29;
commitid	10046AFAD1758A98969;

1.29
date	2007.07.05.09.26.34;	author tg;	state Exp;
branches;
next	1.28;
commitid	100468CB95A5BE50BE7;

1.28
date	2007.06.12.21.58.25;	author tg;	state Exp;
branches;
next	1.27;
commitid	100466F170341A3478B;

1.27
date	2007.05.24.22.07.08;	author tg;	state Exp;
branches;
next	1.26;
commitid	10046560C8C6AFD1EC3;

1.26
date	2007.03.02.03.07.08;	author tg;	state Exp;
branches;
next	1.25;
commitid	10045E794CE72D9E600;

1.25
date	2007.03.02.03.03.32;	author tg;	state Exp;
branches;
next	1.24;
commitid	10045E794160EBAF4CF;

1.24
date	2007.02.26.17.39.10;	author tg;	state Exp;
branches;
next	1.23;
commitid	10045E31B486EF8EEF1;

1.23
date	2007.02.26.16.47.46;	author tg;	state Exp;
branches;
next	1.22;
commitid	10045E30F4529CE07DB;

1.22
date	2007.02.26.03.32.18;	author tg;	state Exp;
branches;
next	1.21;
commitid	10045E254CF4A28A92F;

1.21
date	2007.02.26.03.14.16;	author tg;	state Exp;
branches;
next	1.20;
commitid	10045E2509945FFB721;

1.20
date	2007.02.26.02.57.37;	author tg;	state Exp;
branches;
next	1.19;
commitid	10045E24CB0209C3D77;

1.19
date	2007.02.26.02.52.47;	author tg;	state Exp;
branches;
next	1.18;
commitid	10045E24B6E7262EB74;

1.18
date	2006.07.23.23.41.28;	author tg;	state Exp;
branches;
next	1.17;
commitid	10044C409313E5D0B2B;

1.17
date	2006.04.19.11.03.15;	author tg;	state Exp;
branches;
next	1.16;
commitid	100444618F36937A45D;

1.16
date	2006.04.08.00.09.12;	author tg;	state Exp;
branches;
next	1.15;
commitid	1004436FF382FA3C464;

1.15
date	2006.04.08.00.03.00;	author tg;	state Exp;
branches;
next	1.14;
commitid	1004436FDBF0901CB05;

1.14
date	2006.04.08.00.00.09;	author tg;	state Exp;
branches;
next	1.13;
commitid	1004436FD0C32ACE3F2;

1.13
date	2006.04.07.23.57.47;	author tg;	state Exp;
branches;
next	1.12;
commitid	1004436FC891E876A1A;

1.12
date	2006.04.07.23.53.07;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004436FB712C575223;

1.11
date	2006.04.07.23.47.52;	author tg;	state Exp;
branches;
next	1.10;
commitid	1004436FA3862DB1920;

1.10
date	2006.04.07.23.25.29;	author tg;	state Exp;
branches;
next	1.9;
commitid	1004436F47C35376972;

1.9
date	2006.04.07.22.46.45;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004436EBE72AC02B5D;

1.8
date	2006.04.07.22.45.48;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004436EBAA05175939;

1.7
date	2006.04.06.11.07.31;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004434F66517D09156;

1.6
date	2006.01.03.03.07.56;	author tg;	state Exp;
branches;
next	1.5;
commitid	10043B9EA9D72EB0673;

1.5
date	2005.12.04.13.27.00;	author tg;	state Exp;
branches;
next	1.4;
commitid	75d74392eea76843;

1.4
date	2005.12.04.13.05.40;	author tg;	state Exp;
branches;
next	1.3;
commitid	59dd4392e9a38694;

1.3
date	2005.04.29.18.34.58;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.06.21.27.05;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.27.28;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.27.28;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.29.17.05.47;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.08.01.10.28.37;	author tg;	state Exp;
branches;
next	;
commitid	1004892E54805BE97AB;


desc
@@


1.34
log
@if -h and/or -s not given and both disklabel and sysctl fail,
enable -A automagically
@
text
@/**	$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.33 2009/06/07 13:08:57 tg Exp $ */
/*	$OpenBSD: installboot.c,v 1.47 2004/07/15 21:44:16 tom Exp $	*/
/*	$NetBSD: installboot.c,v 1.5 1995/11/17 23:23:50 gwr Exp $ */

/*-
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2009
 *	Thorsten Glaser <tg@@mirbsd.org>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 *-
 * Notes:
 *	- this still splits by geometry, even if bootxx does that
 *	  by itself for quite a while
 *	- the -M option could be implemented similar to bxinst.i386
 *	- this is superfluous once we have getextent_ffs and a frontend
 */

/*
 * Copyright (c) 1997 Michael Shalayeff
 * Copyright (c) 1994 Paul Kranenburg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Paul Kranenburg.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/mount.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/disklabel.h>
#include <sys/dkio.h>
#include <sys/ioctl.h>
#include <ufs/ufs/dinode.h>
#include <ufs/ufs/dir.h>
#include <ufs/ffs/fs.h>
#include <sys/reboot.h>
#include <sys/errno.h>

#include <uvm/uvm_extern.h>
#include <sys/sysctl.h>

#include <machine/cpu.h>
#include <machine/biosvar.h>

#include <err.h>
#include <a.out.h>
#include <sys/exec_elf.h>
#include <fcntl.h>
#include <nlist.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <util.h>

__RCSID("$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.33 2009/06/07 13:08:57 tg Exp $");

extern const char *__progname;
int	verbose, nowrite, nheads, nsectors, userspec = 0;
char	*boot, *proto, *dev, *realdev;
struct nlist nl[] = {
#define X_BLOCK_COUNT	0
	{{"_bkcnt"}},
#define X_BLOCK_TABLE	1
	{{"_bktbl"}},
#define	X_NUM_SECS	2
	{{"_geoms"}},
#define	X_NUM_HEADS	3
	{{"_geomh"}},
#define	X_PARTP		4
	{{"_partp"}},
#define X_START		5
	{{"__start"}},
	{{NULL}}
};

u_int8_t *block_count_p;	/* block count var. in prototype image */
u_int8_t *block_table_p;	/* block number array in prototype image */
u_int8_t *num_heads_p;		/* number of tracks per cylinder */
u_int8_t *num_secs_p;		/* number of sectors per track */
uint8_t  *partp_p;		/* user defined partition type */
uint8_t  *start_p;		/* begin (0000:7C00) of PBR */
u_int8_t *bblkend;		/* end of boot block table (+1) */
int	maxblocklen;		/* size of this array */
int	curblocklen = 0;	/* actually used up bytes */
int	force_mbr = 0;		/* install into MBR */
int	userpt = 0;		/* user defined partition type, self-local */

int biosdev;

static const char T_warning[] = "warning: ";

char		*loadprotoblocks(char *, long *);
int		loadblocknums(char *, int, struct disklabel *);
static void	devread(int, void *, daddr_t, size_t, char *);
static __dead void usage(void);
static int	record_block(u_int8_t *, daddr_t, u_int);
static int	do_record(u_int8_t *, daddr_t, u_int);


static void
usage(void)
{
	fprintf(stderr, "usage:\t%s [-Anv] [-P part] [-s sec-per-track] "
	    "[-h track-per-cyl]\n", __progname);
	fprintf(stderr, "\t    boot bootxx device\n");
	exit(1);
}

int
read_pt(int f, long offs, struct dos_mbr *target, size_t secsize)
{
#ifdef	DEBUG
	fprintf(stderr, "debug: read_pt at %d (0x%X)\n", offs, offs);
#endif
	if (lseek(f, (off_t)offs * secsize, SEEK_SET) < 0)
		return -1;
	if (read(f, target, secsize) < secsize)
		return -1;
	return 0;
}

int
scan_pt(struct dos_partition *dp, u_int8_t what)
{
	int part;

	for (part = 0; part < NDOSPART; ++part) {
		if ((!get_le(&dp[part].dp_size)) || (dp[part].dp_typ != what))
			continue;
		fprintf(stderr, "# found partition %d: "
		    "type %02X ofs %d (0x%Xh) size %d (0x%X)%s\n",
		    part, dp[part].dp_typ,
		    get_le(&dp[part].dp_start), get_le(&dp[part].dp_start),
		    get_le(&dp[part].dp_size), get_le(&dp[part].dp_size),
		    ( ((what == DOSPTYP_EXTENDL) || (what == DOSPTYP_EXTENDLX)
		       || (what == DOSPTYP_EXTEND)) ? ", chaining..." : "."));
		return part;
	}
	return NDOSPART;
}

int
main(int argc, char *argv[])
{
	int	c;
	int	devfd;
	char	*protostore;
	long	protosize;
	struct stat sb;
	struct disklabel dl;
	struct dos_mbr mbr;
	struct dos_partition *dp;
	off_t startoff = 0;
	int mib[4];
	size_t size;
	dev_t devno;
	bios_diskinfo_t di;
	long mbrofs;
	int mbrpart;

	fprintf(stderr, "MirOS BSD installboot " __BOOT_VER "\n");

	nsectors = nheads = -1;
	while ((c = getopt(argc, argv, "1Ah:MnP:s:v")) != -1) {
		switch (c) {
		case '1':
			break;
		case 'A':
			nheads = 0;
			nsectors = 99;
			userspec = 1;
			break;
		case 'h':
			nheads = atoi(optarg);
			if (nheads < 1 || nheads > 256) {
				warnx("invalid value for -h");
				nheads = -1;
			} else	userspec = 1;
			break;
		case 'M':
#if 0
			++force_mbr;
#else
			fprintf(stderr, "error: -M not supported yet!\n");
#endif
			break;
		case 'n':
			/* Do not actually write the bootblock to disk */
			nowrite = 1;
			break;
		case 'P':
			userpt = (int)strtonum(optarg, 1, 255, NULL);
			if (!userpt) {
				warnx("invalid value for -P");
				userpt = 0;
			}
			break;
		case 's':
			nsectors = atoi(optarg);
			if (nsectors < 1 || nsectors > 63) {
				warnx("invalid value for -s");
				nsectors = -1;
			} else	userspec = 1;
			break;
		case 'v':
			/* Chat */
			verbose = 1;
			break;
		default:
			usage();
		}
	}

	if (argc - optind < 3) {
		usage();
	}

	boot = argv[optind];
	proto = argv[optind + 1];
	realdev = dev = argv[optind + 2];

	/* Open and check raw disk device */
	if ((devfd = opendev(dev, (nowrite? O_RDONLY:O_RDWR),
			     OPENDEV_PART, &realdev)) < 0)
		err(1, "open: %s", realdev);

	if (verbose) {
		fprintf(stderr, "boot: %s\n", boot);
		fprintf(stderr, "proto: %s\n", proto);
		fprintf(stderr, "device: %s\n", realdev);
	}

	if (ioctl(devfd, DIOCGDINFO, &dl) != 0)
		err(1, "disklabel: %s", realdev);

	/* check disklabel */
	if (dl.d_magic != DISKMAGIC)
		err(1, "bad disklabel magic=%0x8x", dl.d_magic);

	/* warn on unknown disklabel types */
	if (dl.d_type == 0)
		warnx("disklabel type unknown");

	/* Load proto blocks into core */
	if ((protostore = loadprotoblocks(proto, &protosize)) == NULL)
		exit(1);

	/* XXX - Paranoia: Make sure size is aligned! */
	if (protosize & (DEV_BSIZE - 1))
		err(1, "proto %s bad size=%ld", proto, protosize);

	/* Write patched proto bootblocks into the superblock */
	if (protosize > SBSIZE - DEV_BSIZE)
		errx(1, "proto bootblocks too big");

	if (fstat(devfd, &sb) < 0)
		err(1, "stat: %s", realdev);

	if (!S_ISCHR(sb.st_mode))
		errx(1, "%s: Not a character device", realdev);

	if (nheads == -1 || nsectors == -1) {
		mib[0] = CTL_MACHDEP;
		mib[1] = CPU_CHR2BLK;
		mib[2] = sb.st_rdev;
		size = sizeof(devno);
		if(sysctl(mib, 3, &devno, &size, NULL, 0) >= 0) {
			devno = MAKEBOOTDEV(major(devno), 0, 0,
			    DISKUNIT(devno), RAW_PART);
			mib[0] = CTL_MACHDEP;
			mib[1] = CPU_BIOS;
			mib[2] = BIOS_DISKINFO;
			mib[3] = devno;
			size = sizeof(di);
			if(sysctl(mib, 4, &di, &size, NULL, 0) >= 0) {
				nheads = di.bios_heads;
				nsectors = di.bios_sectors;
			}
		}
	}

	/* Extract and load block numbers */
	if (loadblocknums(boot, devfd, &dl) != 0)
		exit(1);

	/* Sync filesystems (to clean in-memory superblock?) */
	sync(); sleep(1);

	if (dl.d_type != 0 && dl.d_type != DTYPE_FLOPPY &&
	    dl.d_type != DTYPE_VND && !force_mbr) {
		mbrofs = DOSBBSECTOR;
 loop:		if (read_pt(devfd, mbrofs, &mbr, dl.d_secsize))
			err(4, "can't read partition table");

		if (mbr.dmbr_sign != DOSMBR_SIGNATURE)
			errx(1, "broken MBR");

		dp = mbr.dmbr_parts;
		for (mbrpart = 0; mbrpart < NDOSPART; ++mbrpart)
			set_le(&dp[mbrpart].dp_start,
			    get_le(&dp[mbrpart].dp_start) + mbrofs);

		if (userpt) if ((mbrpart = scan_pt(dp, userpt)) < NDOSPART) {
			warnx("using USER partition, type %02Xh", userpt);
			goto found;
		}
		if ((mbrpart = scan_pt(dp, DOSPTYP_MIRBSD)) < NDOSPART)
			goto found;
		if ((mbrpart = scan_pt(dp, DOSPTYP_OPENBSD)) < NDOSPART) {
			warnx("using OpenBSD partition!");
			goto found;
		}
		if ((mbrpart = scan_pt(dp, DOSPTYP_NETBSD)) < NDOSPART) {
			warnx("using NetBSD partition!");
			goto found;
		}
		if ((mbrpart = scan_pt(dp, DOSPTYP_FREEBSD)) < NDOSPART) {
			warnx("using FreeBSD partition!");
			goto found;
		}

		/* no native partition found, try extended ones */
		if ((mbrpart = scan_pt(dp, DOSPTYP_EXTEND)) == NDOSPART)
		    if ((mbrpart = scan_pt(dp, DOSPTYP_EXTENDL)) == NDOSPART)
		    if ((mbrpart = scan_pt(dp, DOSPTYP_EXTENDLX)) == NDOSPART)
			errx(1, "no BSD partition");

		/* found extended partition, loop back */
		mbrofs = get_le(&dp[mbrpart].dp_start);
		goto loop;

 found:		startoff = (off_t)get_le(&dp[mbrpart].dp_start);
	}

	while (bblkend < (block_table_p + maxblocklen))
		if (((ptrdiff_t)(bblkend - start_p) & 0xFFCF) == 0x01C2)
			*bblkend++ = 0;
		else
			*bblkend++ = arc4random() & 0xFF;

	if (nheads == -1 || nsectors == -1) {
		fprintf(stderr, "%sUnable to get BIOS geometry, "
		    "must/should specify -h and -s\n%sthe drive "
		    "may not boot in non-LBA mode\n", T_warning, T_warning);
		nsectors = -1;
	}

	fprintf(stderr, "writing bootblock to sector %ld (0x%lX)\n",
	    (long)startoff, (unsigned long)startoff);
	if (nsectors == 99 || nsectors == -1) {
		if (verbose || nsectors == -1)
			fprintf(stderr, "%susing automatic disc geometry\n",
			    nsectors == -1 ? T_warning : "");
		nheads = 0;
		nsectors = 0;
	} else if (verbose)
		fprintf(stderr, "using disc geometry of %d heads, %d sectors"
		    " per track\n", nheads, nsectors);
	startoff *= dl.d_secsize;

	*num_heads_p = nheads & 255;
	*(num_heads_p + 1) = nheads >> 8;
	*num_secs_p = nsectors & 63;
	*partp_p = userpt;

	if (!nowrite) {
		if (lseek(devfd, startoff, SEEK_SET) < 0 ||
		    write(devfd, protostore, protosize) != protosize)
			err(1, "write bootstrap");
	}

	(void)close(devfd);

	return 0;
}

char *
loadprotoblocks(char *fname, long *size)
{
	int	fd;
	size_t	tdsize;		/* text+data size */
	char	*bp;
	struct	nlist *nlp;
	Elf_Ehdr eh;
	Elf_Word phsize;
	Elf_Phdr *ph;

	fd = -1;
	bp = NULL;

	/* Locate block number array in proto file */
	if (nlist(fname, nl) != 0) {
		warnx("nlist: %s: symbols not found", fname);
		return NULL;
	}
	/* Validate symbol types (global data). */
	for (nlp = nl; nlp->n_un.n_name; nlp++) {
		if (nlp->n_type != (N_TEXT) && nlp->n_type != (N_DATA)) {
			warnx("nlist: %s: wrong type %x", nlp->n_un.n_name,
			nlp->n_type);
			return NULL;
		}
	}

	if ((fd = open(fname, O_RDONLY)) < 0) {
		warn("open: %s", fname);
		return NULL;
	}
	if (read(fd, &eh, sizeof(eh)) != sizeof(eh)) {
		warn("read: %s", fname);
		goto bad;
	}
	if (!IS_ELF(eh)) {
		errx(1, "%s: bad magic: 0x%02x%02x%02x%02x",
		boot,
		eh.e_ident[EI_MAG0], eh.e_ident[EI_MAG1],
		eh.e_ident[EI_MAG2], eh.e_ident[EI_MAG3]);
	}

	/*
	 * We have to include the exec header in the beginning of
	 * the buffer, and leave extra space at the end in case
	 * the actual write to disk wants to skip the header.
	 */

	/* program load header */
	if (eh.e_phnum != 1) {
		errx(1, "%s: only supports one ELF load section", boot);
	}
	phsize = eh.e_phnum * sizeof(Elf_Phdr);
	ph = malloc(phsize);
	if (ph == NULL) {
		errx(1, "%s: unable to allocate program header space",
		    boot);
	}
	lseek(fd, eh.e_phoff, SEEK_SET);

	if (read(fd, ph, phsize) != phsize) {
		errx(1, "%s: unable to read program header space", boot);
	}

	tdsize = ph->p_filesz;

	/*
	 * Allocate extra space here because the caller may copy
	 * the boot block starting at the end of the exec header.
	 * This prevents reading beyond the end of the buffer.
	 */
	if ((bp = calloc(tdsize, 1)) == NULL) {
		warnx("malloc: %s: no memory", fname);
		goto bad;
	}
	/* Read the rest of the file. */
	lseek(fd, ph->p_offset, SEEK_SET);
	if (read(fd, bp, tdsize) != tdsize) {
		warn("read: %s", fname);
		goto bad;
	}

	*size = tdsize;	/* not aligned to DEV_BSIZE */

	/* Calculate the symbols' locations within the proto file */
#define SYMADDR(x)	((uint8_t *)(bp + nl[x].n_value - nl[X_START].n_value))
	block_count_p = SYMADDR(X_BLOCK_COUNT);
	block_table_p = SYMADDR(X_BLOCK_TABLE);
	num_heads_p = SYMADDR(X_NUM_HEADS);
	num_secs_p = SYMADDR(X_NUM_SECS);
	partp_p = SYMADDR(X_PARTP);
	start_p = SYMADDR(X_START);
	maxblocklen = *block_count_p;
	if (force_mbr) maxblocklen -= 64;

	if (verbose) {
		fprintf(stderr, "%s: entry point %#x\n", fname, eh.e_entry);
		fprintf(stderr, "proto bootblock size %ld\n", *size);
		fprintf(stderr,
		    "room for average %d filesystem blocks (%d bytes) at %#lx\n",
		    (int)(((double)maxblocklen)/4.5), maxblocklen,
		    nl[X_BLOCK_TABLE].n_value);
	}

	close(fd);
	return bp;

 bad:
	if (bp)
		free(bp);
	if (fd >= 0)
		close(fd);
	return NULL;
}

static void
devread(int fd, void *buf, daddr_t blk, size_t size, char *msg)
{
	if (lseek(fd, dbtob((off_t)blk), SEEK_SET) != dbtob((off_t)blk))
		err(1, "%s: devread: lseek", msg);

	if (read(fd, buf, size) != size)
		err(1, "%s: devread: read", msg);
}

static char sblock[SBSIZE];

int
loadblocknums(char *boot, int devfd, struct disklabel *dl)
{
	int		i, fd;
	struct stat	statbuf, sb;
	struct statfs	statfsbuf;
	struct partition *pl;
	struct fs	*fs;
	char		*buf;
	daddr_t		blk, *ap;
	struct ufs1_dinode	*ip;
	int		ndb;
	u_int8_t	*bt;
	int		mib[4];
	size_t		size;
	dev_t dev;

	/*
	 * Open 2nd-level boot program and record the block numbers
	 * it occupies on the filesystem represented by 'devfd'.
	 */

	/* Make sure the (probably new) boot file is on disk. */
	sync(); sleep(1);

	if ((fd = open(boot, O_RDONLY)) < 0)
		err(1, "open: %s", boot);

	if (fstatfs(fd, &statfsbuf) != 0)
		err(1, "statfs: %s", boot);

	if (strncmp(statfsbuf.f_fstypename, "ffs", MFSNAMELEN) &&
	    strncmp(statfsbuf.f_fstypename, "ufs", MFSNAMELEN) ) {
		errx(1, "%s: must be on an FFS filesystem", boot);
	}

#if 0
	if (read(fd, &eh, sizeof(eh)) != sizeof(eh)) {
		errx(1, "read: %s", boot);
	}

	if (!IS_ELF(eh)) {
		errx(1, "%s: bad magic: 0x%02x%02x%02x%02x",
		boot,
		eh.e_ident[EI_MAG0], eh.e_ident[EI_MAG1],
		eh.e_ident[EI_MAG2], eh.e_ident[EI_MAG3]);
	}
#endif

	if (fsync(fd) != 0)
		err(1, "fsync: %s", boot);

	if (fstat(fd, &statbuf) != 0)
		err(1, "fstat: %s", boot);

	if (fstat(devfd, &sb) != 0)
		err(1, "fstat: %s", realdev);

	/* check devices */
	mib[0] = CTL_MACHDEP;
	mib[1] = CPU_CHR2BLK;
	mib[2] = sb.st_rdev;
	size = sizeof(dev);
	if (sysctl(mib, 3, &dev, &size, NULL, 0) >= 0)
		if (statbuf.st_dev / MAXPARTITIONS != dev / MAXPARTITIONS)
			errx(1, "cross-device install");

	pl = &dl->d_partitions[DISKPART(statbuf.st_dev)];
	close(fd);

	/* Read superblock */
	devread(devfd, sblock, pl->p_offset + SBLOCK, SBSIZE, "superblock");
	fs = (struct fs *)sblock;

	/* Sanity-check super-block. */
	if (fs->fs_magic != FS_MAGIC)
		errx(1, "Bad magic number in superblock");
	if (fs->fs_inopb <= 0)
		err(1, "Bad inopb=%d in superblock", fs->fs_inopb);

	/* Read inode */
	if ((buf = malloc(fs->fs_bsize)) == NULL)
		errx(1, "No memory for filesystem block");

	blk = fsbtodb(fs, ino_to_fsba(fs, statbuf.st_ino));
	devread(devfd, buf, pl->p_offset + blk, fs->fs_bsize, "inode");
	ip = (struct ufs1_dinode *)(buf) + ino_to_fsbo(fs, statbuf.st_ino);

	/*
	 * Have the inode.  Figure out how many blocks we need.
	 */
	ndb = howmany(ip->di_size, fs->fs_bsize);
	if (ndb <= 0)
		errx(1, "No blocks to load");
	if (verbose)
		fprintf(stderr, "Will load %d blocks of size %d each.\n",
			ndb, fs->fs_bsize);

	if ((dl->d_type != 0 && dl->d_type != DTYPE_FLOPPY &&
	    dl->d_type != DTYPE_VND) || (userspec && nsectors != 99)) {
		/* adjust disklabel w/ synthetic geometry */
		dl->d_nsectors = nsectors;
		dl->d_secpercyl = dl->d_nsectors * nheads;
	}

	if (verbose)
		fprintf(stderr, "Using disk geometry of %u sectors and %u heads.\n",
			dl->d_nsectors, dl->d_secpercyl/dl->d_nsectors);

	/*
	 * Get the block numbers; we don't handle fragments
	 */
	ap = ip->di_db;
	bt = block_table_p;
	for (i = 0; i < NDADDR && *ap && ndb; i++, ap++, ndb--)
		bt += record_block(bt, pl->p_offset + fsbtodb(fs, *ap),
					    fs->fs_bsize / 512);
	if (ndb != 0) {

		/*
		 * Just one level of indirections; there isn't much room
		 * for more in the 2nd-level /boot anyway.
		 */
		blk = fsbtodb(fs, ip->di_ib[0]);
		devread(devfd, buf, pl->p_offset + blk, fs->fs_bsize,
			"indirect block");
		ap = (daddr_t *)buf;
		for (; i < NINDIR(fs) && *ap && ndb; i++, ap++, ndb--)
			bt += record_block(bt, pl->p_offset + fsbtodb(fs, *ap),
					   fs->fs_bsize / 512);
	}

	bt += record_block(bt, 0, 0);

	if ((bblkend = bt) > (block_table_p + maxblocklen))
		errx(1, "Too many blocks");

	if (verbose)
		fprintf(stderr, "%s: %d entries total (%d bytes)\n",
			boot, block_count_p[0], curblocklen);

	return 0;
}

static int
record_block(u_int8_t *bt, daddr_t blk, u_int bs)
{
	static u_int W_num = 0;
	static daddr_t W_ofs = 0;

	int flush = 0, cache = 0, retval = 0;
	int i;

	if (!blk) {
		++flush;
	} else if (!W_ofs) {
		++cache;
	} else if (blk == (W_ofs+W_num)) {
		++cache;
	} else {
		++flush;
		++cache;
	}

	if (flush) {
		/*
		 * Flush the blocks cached to the disc.
		 * Obey the track boundaries if possible.
		 */
		if (!W_num) goto flush_end;
		if ((nheads == -1) || (nsectors == -1) || (nsectors == 99)) {
			retval += do_record(bt+retval, W_ofs, W_num);
			goto flush_end;
		}

		i = W_ofs % nsectors;		/* sector within track -1 */
		if (i < (nsectors-1)) {
			i = nsectors - i;
			if (i > W_num) i=W_num;
			retval += do_record(bt+retval, W_ofs, i);
			W_ofs += i;
			W_num -= i;
		}

		while (W_num > nsectors) {
			retval += do_record(bt+retval, W_ofs, nsectors);
			W_ofs += nsectors;
			W_num -= nsectors;
		}

		if (W_num)
			retval += do_record(bt+retval, W_ofs, W_num);

	flush_end:
		W_ofs=0; W_num=0;
	}

	if (cache) {
		if (!W_ofs) W_ofs = blk;
		W_num += bs;
	}

	return (retval);
}

static int
do_record(u_int8_t *bt, daddr_t blk, u_int bs)
{
	static u_int i = 0;
	u_int8_t tv, len;
	u_int64_t bk, wbk;
	u_int j;
	int wbs, retval = 0;
	u_int8_t *wbt;

	if ((!blk) || (!bt))
		return 0;

	if (bs > 768)	/* after that there's VGA memory */
		errx(1, "Too many blocks in a chunk!");

	wbs = bs;
	wbt = bt;
	bk = blk;
	if (verbose)
		fprintf(stderr, "%2d: %2d @@%lld (0x%08llX)\n",
		    i, bs, bk, bk);

	do {
		++i;

		if (bk < 0x0000000000000100ULL)
			len = 0;
		else if (bk < 0x0000000000010000ULL)
			len = 1;
		else if (bk < 0x0000000001000000ULL)
			len = 2;
		else if (bk < 0x0000000100000000ULL)
			len = 3;
		else if (bk < 0x0000010000000000ULL)
			len = 4;
		else if (bk < 0x0001000000000000ULL)
			len = 5;
		else if (bk < 0x0100000000000000ULL)
			len = 6;
		else	len = 7;

		if (wbs < 33)
			tv = (len << 5) | (wbs - 1);
		  else	tv = (len << 5) | 31;

		*(wbt++) = tv;
		wbk = bk;
		bk += 1 + (tv & 31);
		for (j = 0; j <= len; ++j) {
			*(wbt++) = (wbk & 0xFF);
			wbk >>= 8;
		}

		wbs -= 32;
		retval += (len+2);
	} while (wbs > 0);

	*block_count_p = i;
	curblocklen += retval;
	return (retval);
}
@


1.33
log
@add notes
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.32 2009/06/07 11:46:28 tg Exp $ */
d95 1
a95 1
__RCSID("$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.32 2009/06/07 11:46:28 tg Exp $");
d130 2
d382 4
a385 7
		fprintf(stderr, "warning: Unable to get BIOS geometry, "
		    "must/should specify -h and -s\nwarning: the drive "
		    "may not boot in non-LBA mode\n");
		if (nheads == -1 && dl.d_nsectors > 0)
			nheads = dl.d_secpercyl / dl.d_nsectors;
		if (nsectors == -1)
			nsectors = dl.d_nsectors;
d390 4
a393 1
	if (nsectors == 99) {
a395 2
		if (verbose)
			fprintf(stderr, "using automatic disc geometry\n");
@


1.32
log
@add the -A flag to installboot, too
I was able to successfully boot a grub2 rescue prompt with this
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.31 2009/01/31 18:51:19 tg Exp $ */
d23 6
d95 1
a95 1
__RCSID("$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.31 2009/01/31 18:51:19 tg Exp $");
@


1.31
log
@new bootmagic, bootxx: reading only one sector at a time, ignoring
what the BIOS thinks it can do or cannotâ€¦

note: bootxx.sh (self-installing bootblocks) and installboot(8/i386)
both still break up entries at track boundaries, which is no longer
needed because of the single-sector reads
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.30 2007/07/31 21:43:57 tg Exp $ */
d89 1
a89 1
__RCSID("$MirOS: src/share/misc/licence.template,v 1.28 2008/11/14 15:33:44 tg Rel $");
d135 1
a135 1
	fprintf(stderr, "usage:\t%s [-nv] [-P part] [-s sec-per-track] "
d196 1
a196 1
	while ((c = getopt(argc, argv, "1h:MnP:s:v")) != -1) {
d200 5
d385 6
a390 1
	if (verbose)
d638 1
a638 1
	    dl->d_type != DTYPE_VND) || userspec ) {
d709 1
a709 1
		if ((nheads == -1) || (nsectors == -1)) {
@


1.30
log
@make sure the four bytes where the partition table might have its filesy-
stem type ID fields are zero'd not arc4random'd
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.29 2007/07/05 09:26:34 tg Exp $ */
d6 2
a7 2
 * Copyright (c) 2003, 2004, 2005, 2006, 2007
 *	Thorsten Glaser <tg@@mirbsd.de>
a14 4
 * Advertising materials mentioning features or use of this work must
 * display the following acknowledgement:
 *	This product includes material provided by Thorsten Glaser.
 *
d89 1
a89 1
__RCSID("$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.29 2007/07/05 09:26:34 tg Exp $");
d96 1
a96 1
	{{"_blkcnt"}},
d98 1
a98 1
	{{"_blktbl"}},
d100 1
a100 1
	{{"_bpbspt"}},
d102 1
a102 1
	{{"_bpbtpc"}},
d135 1
a135 1
	fprintf(stderr, "usage:\t%s [-1npv] [-P part] [-s sec-per-track] "
a137 2
	fprintf(stderr, "\t    [-S sector] -I bootstart bootend bootxx device\n");
	fprintf(stderr, "\t    [-S sector] -i bootstart bootlen bootxx device\n");
d191 1
a191 4
	int mbrpart, usembrpart = 0;
	/* do *not* use off_t */
	u_long isoofs = 0, isolen = 0, imaofs = 0, imasec = 0;
	bool flag_oneonly = false;
d196 1
a196 1
	while ((c = getopt(argc, argv, "1h:I:i:MnP:pS:s:v")) != -1) {
a198 1
			flag_oneonly = true;
a206 10
		case 'I':
			isoofs = (off_t)strtoll(optarg, NULL, 0);
			if (isoofs < 1)
				errx(1, "invalid bootstart argument");
			break;
		case 'i':
			imaofs = (off_t)strtoll(optarg, NULL, 0);
			if (imaofs < 1)
				errx(1, "invalid bootstart argument");
			break;
a224 8
		case 'p':
			++usembrpart;
			break;
		case 'S':
			imasec = (off_t)strtoll(optarg, NULL, 0);
			if (imasec < 0)
				errx(1, "invalid sector argument");
			break;
a240 4
	if ((isoofs && imaofs) || (!isoofs && !imaofs && imasec) ||
	    (usembrpart && !imaofs) || (usembrpart && imasec))
		usage();

d249 4
a252 17
	if (isoofs || imaofs) {
		isolen = (off_t)strtoll(boot, NULL, 0);
		if (isolen <= (isoofs ? isoofs : 4))
			errx(1, "invalid boot%s argument",
			    isoofs ? "end" : "len");
		if (isoofs) {
			isolen = isolen - isoofs + 1;
			imaofs = isoofs << 2;
		}
		if ((devfd = open(dev, (nowrite ? O_RDONLY : O_RDWR))) < 0)
			err(1, "open: %s", dev);
	} else {
		/* Open and check raw disk device */
		if ((devfd = opendev(dev, (nowrite? O_RDONLY:O_RDWR),
				     OPENDEV_PART, &realdev)) < 0)
			err(1, "open: %s", realdev);
	}
d255 1
a255 5
		if (imaofs)
			fprintf(stderr, "boot: %lu %lu\n", imaofs,
			    isolen * (isoofs ? 4 : 1));
		else
			fprintf(stderr, "boot: %s\n", boot);
a259 3
	if (imaofs)
		goto do_loadproto;

a270 1
 do_loadproto:
a285 28
	if (imaofs) {
		u_int8_t *bt;

		if (verbose)
			fprintf(stderr, "Will load %lu blocks of size "
			    "%d each.\n", isolen, isoofs ? 2048 : 512);
		bt = block_table_p;
		while (isolen) {
			bt += record_block(bt, imaofs, (isoofs ? 4 : 1));
			imaofs += (isoofs ? 4 : 1);
			isolen--;
		}
		bt += record_block(bt, 0, 0);

		if ((bblkend = bt) > (block_table_p + maxblocklen))
			errx(1, "Too many blocks");

		if (verbose)
			fprintf(stderr, "%s: %d entries total (%d bytes)\n",
			    boot, block_count_p[0], curblocklen);

		if (usembrpart)
			goto do_mbrpart;

		startoff = imasec;
		goto do_write;
	}

d318 2
a319 2
 do_mbrpart:	mbrofs = DOSBBSECTOR;
 loop:		if (read_pt(devfd, mbrofs, &mbr, imaofs ? 512 : dl.d_secsize))
a361 1
 do_write:
a371 5
		if (imaofs) {
			/* sane values for today's HDDs, for Live HDDs */
			nheads = 16;
			nsectors = 63;
		}
d379 1
a379 1
	    (long) startoff, (unsigned long)startoff);
d382 2
a383 4
		    " per track\nreading %s at a time from the disc\n",
		    nheads, nsectors, flag_oneonly ? "only one sector" :
		    "as many sectors as possible");
	startoff *= imaofs ? 512 : dl.d_secsize;
a389 3
	if (flag_oneonly)
		num_secs_p[1] = 0x80;

d487 7
a493 6
	block_count_p = (u_int8_t *) (bp + nl[X_BLOCK_COUNT].n_value);
	block_table_p = (u_int8_t *) (bp + nl[X_BLOCK_TABLE].n_value);
	num_heads_p = (u_int8_t *) (bp + nl[X_NUM_HEADS].n_value);
	num_secs_p = (u_int8_t *) (bp + nl[X_NUM_SECS].n_value);
	partp_p = (uint8_t *) (bp + nl[X_PARTP].n_value);
	start_p = (uint8_t *) (bp + nl[X_START].n_value);
@


1.29
log
@sync usage()
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.28 2007/06/12 21:58:25 tg Exp $ */
d85 1
d87 1
d93 1
a93 1
__RCSID("$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.28 2007/06/12 21:58:25 tg Exp $");
d109 2
d119 1
d445 4
a448 1
		*bblkend++ = arc4random() & 0xFF;
d584 1
@


1.28
log
@make cross-buildable (or rather buildable at all)
i386: constify a little
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.27 2007/05/24 22:07:08 tg Exp $ */
d91 1
a91 1
__RCSID("$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.27 2007/05/24 22:07:08 tg Exp $");
d134 1
a134 1
	fprintf(stderr, "usage:\t%s [-n] [-v] [-s sec-per-track] "
@


1.27
log
@abuse the â€œslackâ€ in the PBR, trailing the block table, as entropy store
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.26 2007/03/02 03:07:08 tg Exp $ */
d91 1
a91 1
__RCSID("$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.26 2007/03/02 03:07:08 tg Exp $");
d93 1
a93 1
extern	char *__progname;
@


1.26
log
@for -i/-I use sort of sane values for today's HDDs
(some are */255/63 but most appear */16/63)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.25 2007/03/02 03:03:32 tg Exp $ */
d91 1
a91 1
__RCSID("$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.25 2007/03/02 03:03:32 tg Exp $");
d115 1
d348 1
a348 1
		if (bt > (block_table_p + maxblocklen))
d439 3
d745 1
a745 1
	if (bt > (block_table_p + maxblocklen))
@


1.25
log
@prevent division by zero
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.24 2007/02/26 17:39:10 tg Exp $ */
d91 1
a91 1
__RCSID("$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.24 2007/02/26 17:39:10 tg Exp $");
d442 5
@


1.24
log
@if 256 heads are allowed, don't pass them as 0 heads, d'oh
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.23 2007/02/26 16:47:46 tg Exp $ */
d91 1
a91 1
__RCSID("$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.23 2007/02/26 16:47:46 tg Exp $");
d442 1
a442 1
		if (nheads == -1)
@


1.23
log
@256 heads is ok
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.22 2007/02/26 03:32:18 tg Exp $ */
d91 1
a91 1
__RCSID("$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.22 2007/02/26 03:32:18 tg Exp $");
d457 3
a459 2
	*num_heads_p = nheads;
	*num_secs_p = nsectors;
d463 1
a463 1
		num_heads_p[1] = 0x80;
@


1.22
log
@automatic geometry adjustion and more verbose output
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.21 2007/02/26 03:14:16 tg Exp $ */
d91 1
a91 1
__RCSID("$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.21 2007/02/26 03:14:16 tg Exp $");
d206 1
a206 1
			if (nheads < 1 || nheads > 255) {
@


1.21
log
@fix passing of the flag
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.20 2007/02/26 02:57:37 tg Exp $ */
d91 1
a91 1
__RCSID("$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.20 2007/02/26 02:57:37 tg Exp $");
a383 5
	if (nheads == -1 || nsectors == -1)
		fprintf(stderr, "warning: Unable to get BIOS geometry, "
		    "must/should specify -h and -s\nwarning: the drive "
		    "may not boot in non-LBA mode\n");

d438 10
d450 5
@


1.20
log
@of course our elements can be @@object type too
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.19 2007/02/26 02:52:47 tg Exp $ */
d91 1
a91 1
__RCSID("$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.19 2007/02/26 02:52:47 tg Exp $");
a388 3
	if (flag_oneonly)
		nheads |= 0x8000;

d451 3
@


1.19
log
@no, we do need the sectors count for CHS conversation;
on the other hand, the high bytes of head (and sector)
count values are free to use, e.g. for flagsâ€¦
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.18 2006/07/23 23:41:28 tg Exp $ */
d91 1
a91 1
__RCSID("$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.18 2006/07/23 23:41:28 tg Exp $");
d486 1
a486 1
		if (nlp->n_type != (N_TEXT)) {
@


1.18
log
@rename ldsec to bootxx to match all other arches
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.17 2006/04/19 11:03:15 tg Exp $ */
d6 1
a6 1
 * Copyright (c) 2003, 2004, 2005, 2006
d9 5
a13 6
 * Licensee is hereby permitted to deal in this work without restric-
 * tion, including unlimited rights to use, publicly perform, modify,
 * merge, distribute, sell, give away or sublicence, provided all co-
 * pyright notices above, these terms and the disclaimer are retained
 * in all redistributions or reproduced in accompanying documentation
 * or other materials provided with binary redistributions.
d15 2
a16 2
 * All advertising materials mentioning features or use of this soft-
 * ware must display the following acknowledgement:
d19 8
a26 8
 * Licensor offers the work "AS IS" and WITHOUT WARRANTY of any kind,
 * express, or implied, to the maximum extent permitted by applicable
 * law, without malicious intent or gross negligence; in no event may
 * licensor, an author or contributor be held liable for any indirect
 * or other damage, or direct damage except proven a consequence of a
 * direct error of said person and intended use of this work, loss or
 * other issues arising in any way out of its use, even if advised of
 * the possibility of such damage or existence of a nontrivial bug.
d84 1
d91 1
a91 1
__RCSID("$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.17 2006/04/19 11:03:15 tg Exp $");
d194 1
d199 1
a199 1
	while ((c = getopt(argc, argv, "h:I:i:MnP:pS:s:v")) != -1) {
d201 3
d206 1
a206 1
			if (nheads < 1 || nheads > 256) {
d389 3
@


1.17
log
@fix: off_t back to u_long (format strings, etc.)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.16 2006/04/08 00:09:12 tg Exp $ */
d91 1
a91 1
__RCSID("$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.16 2006/04/08 00:09:12 tg Exp $");
d135 3
a137 3
	fprintf(stderr, "\t    boot ldsec device\n");
	fprintf(stderr, "\t    [-S sector] -I bootstart bootend ldsec device\n");
	fprintf(stderr, "\t    [-S sector] -i bootstart bootlen ldsec device\n");
@


1.16
log
@can use MBR partitions with -i now
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.15 2006/04/08 00:03:00 tg Exp $ */
d91 1
a91 1
__RCSID("$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.15 2006/04/08 00:03:00 tg Exp $");
d192 2
a193 1
	off_t isoofs = 0, isolen = 0, imaofs = 0, imasec = 0;
@


1.15
log
@clarify (man) and fix (code) sector size for new -S option
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.14 2006/04/08 00:00:09 tg Exp $ */
d91 1
a91 1
__RCSID("$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.14 2006/04/08 00:00:09 tg Exp $");
d191 1
a191 1
	int mbrpart;
d197 1
a197 1
	while ((c = getopt(argc, argv, "h:I:i:MnP:S:s:v")) != -1) {
d234 3
d258 2
a259 1
	if ((isoofs && imaofs) || (!isoofs && !imaofs && imasec))
d349 3
d393 2
a394 2
		mbrofs = DOSBBSECTOR;
 loop:		if (read_pt(devfd, mbrofs, &mbr, dl.d_secsize))
@


1.14
log
@implement -S startsector option for writing the -I or -i first-stage
boot loader sector to anyplace else than sector 0
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.13 2006/04/07 23:57:47 tg Exp $ */
d91 1
a91 1
__RCSID("$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.13 2006/04/07 23:57:47 tg Exp $");
d433 1
a433 2
	if (!imaofs)
		startoff *= dl.d_secsize;
@


1.13
log
@convert offsets from long to off_t
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.12 2006/04/07 23:53:07 tg Exp $ */
d91 1
a91 1
__RCSID("$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.12 2006/04/07 23:53:07 tg Exp $");
d136 2
a137 2
	fprintf(stderr, "\t    -I bootstart bootend ldsec device\n");
	fprintf(stderr, "\t    -i bootstart bootlen ldsec device\n");
d192 1
a192 1
	off_t isoofs = 0, isolen = 0, imaofs = 0;
d197 1
a197 1
	while ((c = getopt(argc, argv, "h:I:i:MnP:s:v")) != -1) {
d234 5
d255 1
a255 1
	if (isoofs && imaofs)
d345 1
a345 1
		startoff = 0;
@


1.12
log
@-P -h -s actually do make sense with -I -i
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.11 2006/04/07 23:47:52 tg Exp $ */
d91 1
a91 1
__RCSID("$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.11 2006/04/07 23:47:52 tg Exp $");
d192 1
a192 1
	long isoofs = 0, isolen = 0, imaofs = 0;
d207 1
a207 1
			isoofs = strtol(optarg, NULL, 0);
d212 1
a212 1
			imaofs = strtol(optarg, NULL, 0);
d262 1
a262 1
		isolen = strtol(boot, NULL, 0);
@


1.11
log
@use more of the existing infrastructure
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.10 2006/04/07 23:25:29 tg Exp $ */
d91 1
a91 1
__RCSID("$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.10 2006/04/07 23:25:29 tg Exp $");
d125 1
a125 1
static void	usage(void);
d134 4
a137 5
	    "[-h track-per-cyl] boot ldsec device\n", __progname);
	fprintf(stderr, "\t%s [-n] [-v] -I bootstart bootend ldsec file.iso\n",
	    __progname);
	fprintf(stderr, "\t%s [-n] [-v] -i bootstart bootlen ldsec file.ima\n",
	    __progname);
d250 1
a250 2
	if ((isoofs && imaofs) || ((isoofs || imaofs) &&
	    (userpt || (nsectors != -1) || (nheads != -1))))
@


1.10
log
@* Add the ability to install the first-stage boot loader onto the first
  sector of either a CD-ROM image (ISO 9660) or a normal hard disc ima-
  ge file (or even real hard disc) and insert the block map for a /boot
  which is stored as contiguous set of CD (2048 bytes) or HD (512 bytes
  of course) sectors. Since our /boot can read FFS and ISO9660 and does
  not care whether it's a CD or hard disc or floppy, this actually does
  work in contrast to what I tried... add caveats to manual page.
* rant about the above in my wlog
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.7 2006/04/06 11:07:31 tg Exp $ */
d91 1
a91 1
__RCSID("$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.9 2006/04/07 22:46:45 tg Exp $");
d342 2
a343 6
		if (!nowrite) {
			if (write(devfd, protostore, protosize) != protosize)
				err(1, "write bootstrap");
		}
		close(devfd);
		return (0);
d384 1
a384 1
loop:		if (read_pt(devfd, mbrofs, &mbr, dl.d_secsize))
d424 1
a424 1
found:		startoff = (off_t)get_le(&dp[mbrpart].dp_start);
d427 1
d430 2
a431 1
	startoff *= dl.d_secsize;
@


1.9
log
@neither does record_block
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.8 2006/04/07 22:45:48 tg Exp $ */
d6 2
a7 2
 * Copyright (c) 2003, 2004, 2005
 *	Thorsten "mirabile" Glaser <tg@@66h.42h.de>
d16 4
d91 1
a91 1
__RCSID("$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.8 2006/04/07 22:45:48 tg Exp $");
d133 1
a133 1
	fprintf(stderr, "usage: %s [-n] [-v] [-s sec-per-track] "
d135 4
d193 1
d198 1
a198 1
	while ((c = getopt(argc, argv, "h:MnP:s:v")) != -1) {
d207 10
d251 4
d263 17
a279 4
	/* Open and check raw disk device */
	if ((devfd = opendev(dev, (nowrite? O_RDONLY:O_RDWR),
			     OPENDEV_PART, &realdev)) < 0)
		err(1, "open: %s", realdev);
d282 5
a286 1
		fprintf(stderr, "boot: %s\n", boot);
d291 3
d305 1
d321 29
@


1.8
log
@do_record doesn't need a 'struct disklabel *dl'
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.7 2006/04/06 11:07:31 tg Exp $ */
d87 1
a87 1
__RCSID("$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.7 2006/04/06 11:07:31 tg Exp $");
d122 2
a123 5
static int	record_block(u_int8_t *, daddr_t, u_int, struct disklabel *);

static int record_block(u_int8_t *bt, daddr_t blk, u_int bs,
	struct disklabel *dl);
static int do_record(u_int8_t *bt, daddr_t blk, u_int bs);
d619 1
a619 1
					    fs->fs_bsize / 512, dl);
d632 1
a632 1
					   fs->fs_bsize / 512, dl);
d635 1
a635 1
	bt += record_block(bt, 0, 0, dl);
d648 1
a648 1
record_block(u_int8_t *bt, daddr_t blk, u_int bs, struct disklabel *dl)
@


1.7
log
@rename ffspbr to ldsec - it's not UFS specific anyway,
it's just the loading sector with map (á la lilo)

also simplify
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.6 2006/01/03 03:07:56 tg Exp $ */
d87 1
a87 1
__RCSID("$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.6 2006/01/03 03:07:56 tg Exp $");
d126 1
a126 2
static int do_record(u_int8_t *bt, daddr_t blk, u_int bs,
	struct disklabel *dl);
d677 1
a677 1
			retval += do_record(bt+retval, W_ofs, W_num, dl);
d685 1
a685 1
			retval += do_record(bt+retval, W_ofs, i, dl);
d691 1
a691 1
			retval += do_record(bt+retval, W_ofs, nsectors, dl);
d697 1
a697 1
			retval += do_record(bt+retval, W_ofs, W_num, dl);
d712 1
a712 1
do_record(u_int8_t *bt, daddr_t blk, u_int bs, struct disklabel *dl)
@


1.6
log
@* add missing \n
* indent
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.5 2005/12/04 13:27:00 tg Exp $ */
d87 1
a87 1
__RCSID("$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.5 2005/12/04 13:27:00 tg Exp $");
d134 1
a134 1
	    "[-h track-per-cyl] boot ffspbr device\n", __progname);
@


1.5
log
@use strtonum not atoi, and document -P kludge
XXX installboot(8,i386) sucks and should be replaced
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.4 2005/12/04 13:05:40 tg Exp $ */
d87 1
a87 1
__RCSID("$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.4 2005/12/04 13:05:40 tg Exp $");
d305 3
a307 1
		fprintf(stderr, "warning: Unable to get BIOS geometry, must/should specify -h and -s\nwarning: the drive may not boot in non-LBA mode");
@


1.4
log
@use the partp hack to specify a user-defined partition type to be given
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.3 2005/04/29 18:34:58 tg Exp $ */
d87 1
a87 1
__RCSID("$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.3 2005/04/29 18:34:58 tg Exp $");
d214 2
a215 2
			userpt = atoi(optarg);
			if (userpt < 1 || userpt > 255) {
@


1.3
log
@(tentative) merge, more to come
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.2 2005/03/06 21:27:05 tg Exp $ */
d6 1
a6 1
 * Copyright (c) 2003, 2004
d16 8
a23 7
 * Licensor hereby provides this work "AS IS" and WITHOUT WARRANTY of
 * any kind, expressed or implied, to the maximum extent permitted by
 * applicable law, but with the warranty of being written without ma-
 * licious intent or gross negligence; in no event shall licensor, an
 * author or contributor be held liable for any damage, direct, indi-
 * rect or other, however caused, arising in any way out of the usage
 * of this work, even if advised of the possibility of such damage.
d87 1
a87 1
__RCSID("$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.2 2005/03/06 21:27:05 tg Exp $");
d101 2
d110 1
d114 1
a123 2
static const char RCSId[]="$MirOS: src/sys/arch/i386/stand/installboot/installboot.c,v 1.2 2005/03/06 21:27:05 tg Exp $";

d193 1
a193 1
	while ((c = getopt(argc, argv, "Mvnh:s:")) != -1) {
d195 7
d209 10
a218 6
		case 'h':
			nheads = atoi(optarg);
			if (nheads < 1 || nheads > 256) {
				warnx("invalid value for -h");
				nheads = -1;
			} else	userspec = 1;
a226 4
		case 'n':
			/* Do not actually write the bootblock to disk */
			nowrite = 1;
			break;
d328 4
d334 2
a335 1
		if ((mbrpart = scan_pt(dp, DOSPTYP_OPENBSD)) < NDOSPART)
d337 1
d366 1
d469 1
@


1.2
log
@* merge src/sys/
  (at least the better part of it)
* revert IPv6 networking to OpenBSD, since
  I didn't get IPV4_MAPPED addresses working :(
@
text
@d1 2
a2 2
/**	$MirOS$ */
/*	$OpenBSD: installboot.c,v 1.46 2004/05/05 04:33:56 mickey Exp $	*/
d86 1
a86 1
__RCSID("$MirOS$");
d119 1
a119 1
static const char RCSId[]="$MirOS$";
d500 1
a500 1
	int mib[4];
@


1.1
log
@Initial revision
@
text
@d1 1
d5 20
a25 1
 * Copyright (c) 2003 Tom Cosgrove <tom.cosgrove@@arches-consulting.com>
d67 1
d86 1
a86 6
struct	sym_data {
	char		*sym_name;		/* Must be initialised */
	int		sym_size;		/* And this one */
	int		sym_set;		/* Rest set at runtime */
	u_int32_t	sym_value;
};
d89 1
a89 1
int	verbose, nowrite = 0;
d91 10
a100 9
struct sym_data pbr_symbols[] = {
	{"_fs_bsize_p",	2},
	{"_fs_bsize_s",	2},
	{"_fsbtodb",	1},
	{"_p_offset",	4},
	{"_inodeblk",	4},
	{"_inodedbl",	4},
	{"_nblocks",	2},
	{NULL}
d103 7
a109 2
#define INODESEG	0x07e0	/* where we will put /boot's inode's block */
#define BOOTSEG		0x07c0	/* biosboot loaded here */
d111 1
a111 1
#define INODEOFF  ((INODESEG-BOOTSEG) << 4)
d113 2
a114 2
static char	*loadproto(char *, long *);
static int	getbootparams(char *, int, struct disklabel *);
a115 2
static void	sym_set_value(struct sym_data *, char *, u_int32_t);
static void	pbr_set_symbols(char *, char *, struct sym_data *);
d117 9
d130 2
a131 1
	fprintf(stderr, "usage: %s [-nv] boot biosboot device\n", __progname);
d135 33
a167 5
/*
 * Read information about /boot's inode and filesystem parameters, then
 * put biosboot (partition boot record) on the target drive with these
 * parameters patched in.
 */
d175 13
a187 5
	struct	stat sb;
	struct	disklabel dl;
	struct	dos_mbr mbr;
	struct	dos_partition *dp;
	off_t	startoff = 0;
d189 2
a190 1
	while ((c = getopt(argc, argv, "vn")) != -1) {
d192 21
d214 1
a214 1
			/* Do not actually write the bootblock to disk. */
d218 1
a218 1
			/* Give more information. */
d226 1
a226 1
	if (argc - optind < 3)
d228 1
d234 1
a234 1
	/* Open and check raw disk device. */
d236 1
a236 1
	    OPENDEV_PART, &realdev)) < 0)
d248 1
a248 1
	/* Check disklabel. */
d252 1
a252 1
	/* Warn on unknown disklabel types. */
d256 2
a257 2
	/* Load proto blocks into core. */
	if ((protostore = loadproto(proto, &protosize)) == NULL)
d262 1
a262 1
		errx(1, "proto %s bad size=%ld", proto, protosize);
d264 1
a264 1
	/* Write patched proto bootblock(s) into the superblock. */
d272 21
a292 1
		errx(1, "%s: not a character device", realdev);
d294 5
a298 2
	/* Get bootstrap parameters that are to be patched into proto. */
	if (getbootparams(boot, devfd, &dl) != 0)
d301 2
a302 7
	/* Patch the parameters into the proto bootstrap sector. */
	pbr_set_symbols(proto, protostore, pbr_symbols);

	if (!nowrite) {
		/* Sync filesystems (to clean in-memory superblock?). */
		sync(); sleep(1);
	}
d305 4
a308 4
	    dl.d_type != DTYPE_VND) {
		if (lseek(devfd, (off_t)DOSBBSECTOR, SEEK_SET) < 0 ||
		    read(devfd, &mbr, sizeof(mbr)) < sizeof(mbr))
			err(4, "can't read master boot record");
d313 16
a328 12
		/* Find OpenBSD partition. */
		for (dp = mbr.dmbr_parts; dp < &mbr.dmbr_parts[NDOSPART];
		    dp++) {
			if (dp->dp_size && dp->dp_typ == DOSPTYP_OPENBSD) {
				startoff = (off_t)dp->dp_start * dl.d_secsize;
				fprintf(stderr, "using MBR partition %ld: "
				    "type %d (0x%02x) offset %d (0x%x)\n",
				    (long)(dp - mbr.dmbr_parts),
				    dp->dp_typ, dp->dp_typ,
				    dp->dp_start, dp->dp_start);
				break;
			}
d330 12
a341 3
		/* Don't check for old part number, that is ;-p */
		if (dp >= &mbr.dmbr_parts[NDOSPART])
			errx(1, "no OpenBSD partition");
d344 7
d362 2
a363 5
/*
 * Load the prototype boot sector (biosboot) into memory.
 */
static char *
loadproto(char *fname, long *size)
d368 1
d373 2
a374 2
	if ((fd = open(fname, O_RDONLY)) < 0)
		err(1, "%s", fname);
d376 13
a388 2
	if (read(fd, &eh, sizeof(eh)) != sizeof(eh))
		errx(1, "%s: read failed", fname);
d390 9
a398 1
	if (!IS_ELF(eh))
d400 4
a403 3
		    boot,
		    eh.e_ident[EI_MAG0], eh.e_ident[EI_MAG1],
		    eh.e_ident[EI_MAG2], eh.e_ident[EI_MAG3]);
d411 4
a414 5
	/* Program load header. */
	if (eh.e_phnum != 1)
		errx(1, "%s: %u ELF load sections (only support 1)",
		    boot, eh.e_phnum);

d417 4
a420 3
	if (ph == NULL)
		err(1, NULL);

d423 3
a425 2
	if (read(fd, ph, phsize) != phsize)
		errx(1, "%s: can't read header", boot);
d435 2
a436 1
		err(1, NULL);
a437 1

d441 2
a442 1
		errx(1, "%s: read failed", fname);
d447 8
d458 4
d466 7
d487 2
a488 6
/*
 * Read information about /boot's inode, then put this and filesystem
 * parameters from the superblock into pbr_symbols.
 */
static int
getbootparams(char *boot, int devfd, struct disklabel *dl)
d490 1
a490 1
	int		fd;
d499 2
a500 1
	int		mib[4];
d502 1
a502 1
	dev_t		dev;
d505 2
a506 5
	 * Open 2nd-level boot program and record enough details about
	 * where it is on the filesystem represented by `devfd'
	 * (inode block, offset within that block, and various filesystem
	 * parameters essentially taken from the superblock) for biosboot
	 * to be able to load it later.
d519 3
a521 2
	    strncmp(statfsbuf.f_fstypename, "ufs", MFSNAMELEN) )
		errx(1, "%s: not on an FFS filesystem", boot);
d524 1
a524 1
	if (read(fd, &eh, sizeof(eh)) != sizeof(eh))
d526 1
d530 3
a532 3
		    boot,
		    eh.e_ident[EI_MAG0], eh.e_ident[EI_MAG1],
		    eh.e_ident[EI_MAG2], eh.e_ident[EI_MAG3]);
d545 1
a545 1
	/* Check devices. */
d550 1
a550 1
	if (sysctl(mib, 3, &dev, &size, NULL, 0) >= 0) {
a552 1
	}
d557 1
a557 1
	/* Read superblock. */
d567 1
a567 1
	/* Read inode. */
d569 1
a569 1
		err(1, NULL);
a571 1

d576 1
a576 2
	 * Have the inode.  Figure out how many filesystem blocks (not disk
	 * sectors) there are for biosboot to load.
d581 14
d597 1
a597 2
	 * Now set the values that will need to go into biosboot
	 * (the partition boot record, a.k.a. the PBR).
a598 6
	sym_set_value(pbr_symbols, "_fs_bsize_p", (fs->fs_bsize / 16));
	sym_set_value(pbr_symbols, "_fs_bsize_s", (fs->fs_bsize / 512));
	sym_set_value(pbr_symbols, "_fsbtodb", fs->fs_fsbtodb);
	sym_set_value(pbr_symbols, "_p_offset", pl->p_offset);
	sym_set_value(pbr_symbols, "_inodeblk",
	    ino_to_fsba(fs, statbuf.st_ino));
d600 27
a626 13
	sym_set_value(pbr_symbols, "_inodedbl",
	    ((((char *)ap) - buf) + INODEOFF));
	sym_set_value(pbr_symbols, "_nblocks", ndb);

	if (verbose) {
		fprintf(stderr, "%s is %d blocks x %d bytes\n",
		    boot, ndb, fs->fs_bsize);
		fprintf(stderr, "fs block shift %u; part offset %u; "
		    "inode block %u, offset %u\n",
		    fs->fs_fsbtodb, pl->p_offset,
		    ino_to_fsba(fs, statbuf.st_ino),
		    ((((char *)ap) - buf) + INODEOFF));
	}
d631 2
a632 2
static void
sym_set_value(struct sym_data *sym_list, char *sym, u_int32_t value)
d634 27
a660 1
	struct sym_data *p;
d662 20
a681 3
	for (p = sym_list; p->sym_name != NULL; p++) {
		if (strcmp(p->sym_name, sym) == 0)
			break;
d684 4
a687 5
	if (p->sym_name == NULL)
		errx(1, "%s: no such symbol", sym);

	if (p->sym_set)
		errx(1, "%s already set", p->sym_name);
d689 1
a689 2
	p->sym_value = value;
	p->sym_set = 1;
d692 2
a693 6
/*
 * Write the parameters stored in sym_list into the in-memory copy of
 * the prototype biosboot (proto), ready for it to be written to disk.
 */
static void
pbr_set_symbols(char *fname, char *proto, struct sym_data *sym_list)
d695 49
a743 52
	struct sym_data *sym;
	struct nlist	*nl;
	char		*vp;
	u_int32_t	*lp;
	u_int16_t	*wp;
	u_int8_t	*bp;

	for (sym = sym_list; sym->sym_name != NULL; sym++) {
		if (!sym->sym_set)
			errx(1, "%s not set", sym->sym_name);

		/* Allocate space for 2; second is null-terminator for list. */
		nl = calloc(2, sizeof(struct nlist));
		if (nl == NULL)
			err(1, NULL);

		nl->n_un.n_name = sym->sym_name;

		if (nlist(fname, nl) != 0)
			errx(1, "%s: symbol %s not found",
			    fname, sym->sym_name);

		if (nl->n_type != (N_TEXT))
			errx(1, "%s: %s: wrong type (%x)",
			    fname, sym->sym_name, nl->n_type);

		/* Get a pointer to where the symbol's value needs to go. */
		vp = proto + nl->n_value;

		switch (sym->sym_size) {
		case 4:					/* u_int32_t */
			lp = (u_int32_t *) vp;
			*lp = sym->sym_value;
			break;
		case 2:					/* u_int16_t */
			if (sym->sym_value >= 0x10000)	/* out of range */
				errx(1, "%s: symbol out of range (%u)",
				    sym->sym_name, sym->sym_value);
			wp = (u_int16_t *) vp;
			*wp = (u_int16_t) sym->sym_value;
			break;
		case 1:					/* u_int16_t */
			if (sym->sym_value >= 0x100)	/* out of range */
				errx(1, "%s: symbol out of range (%u)",
				    sym->sym_name, sym->sym_value);
			bp = (u_int8_t *) vp;
			*bp = (u_int8_t) sym->sym_value;
			break;
		default:
			errx(1, "%s: bad symbol size %d",
			    sym->sym_name, sym->sym_size);
			/* NOTREACHED */
d746 7
a752 2
		free(nl);
	}
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@improve my Frankenstein OS (*wink* you know who you are) further
sans wchar_t of course

this is the essence of reading >1200 commit messages which suck
due to not having the new format of ours...
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.47 2004/07/15 21:44:16 tom Exp $	*/
d337 1
a337 1
	int		mib[3];
@


1.1.1.3
log
@import bootloader-related pieces from openbsd, as first part of the
aspired 4.4 mergeâ€¦ and something else
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.52 2008/06/25 15:26:44 reyk Exp $	*/
a96 1
static long	findopenbsd(int, struct disklabel *, off_t, int *);
d119 2
a121 2
	long	start = 0;
	int	n = 8;
d161 1
a161 1
		err(1, "bad disklabel magic=0x%08x", dl.d_magic);
d199 7
d207 15
a221 4
		start = findopenbsd(devfd, &dl, (off_t)DOSBBSECTOR, &n);
		if (start == -1)
 			errx(1, "no OpenBSD partition");
		startoff = (off_t)start * dl.d_secsize;
a234 50
long
findopenbsd(int devfd, struct disklabel *dl, off_t mbroff, int *n)
{
	struct		dos_mbr mbr;
	struct		dos_partition *dp;
	off_t		startoff;
	long		start;

	/* Limit the number of recursions */
	if (!(*n)--)
		return (-1);

	if (lseek(devfd, mbroff, SEEK_SET) < 0 ||
	    read(devfd, &mbr, sizeof(mbr)) != sizeof(mbr))
		err(4, "can't read master boot record");

	if (mbr.dmbr_sign != DOSMBR_SIGNATURE)
		errx(1, "broken MBR");

	for (dp = mbr.dmbr_parts; dp < &mbr.dmbr_parts[NDOSPART];
	    dp++) {
		if (!dp->dp_size)
			continue;
		startoff = (off_t)dp->dp_start * dl->d_secsize;
		if (dp->dp_typ == DOSPTYP_OPENBSD) {
			fprintf(stderr, "using MBR partition %ld: "
			    "type %d (0x%02x) offset %d (0x%x)\n",
			    (long)(dp - mbr.dmbr_parts),
			    dp->dp_typ, dp->dp_typ,
			    dp->dp_start, dp->dp_start);
			break;
		} else if (dp->dp_typ == DOSPTYP_EXTEND ||
		    dp->dp_typ == DOSPTYP_EXTENDL) {
			fprintf(stderr, "extended partition %ld: "
			    "type %d (0x%02x) offset %d (0x%x)\n",
			    (long)(dp - mbr.dmbr_parts),
			    dp->dp_typ, dp->dp_typ,
			    dp->dp_start, dp->dp_start);
			start = findopenbsd(devfd, dl, startoff, n);
			if (start != -1)
				return (dp->dp_start + start);
		}
	}
	/* Don't check for old part number, that is ;-p */
	if (dp >= &mbr.dmbr_parts[NDOSPART])
		return (-1);

	return (dp->dp_start);
}

d442 1
a442 1
		    "inode block %lld, offset %ld\n",
@


