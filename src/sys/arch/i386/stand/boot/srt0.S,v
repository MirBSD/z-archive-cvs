head	1.86;
access;
symbols
	tg-use_ldscript:1.82.0.2
	tg-beforemerge-ksrc10:1.1.1.1
	cvs-200808011000:1.1.1.1
	MIRBSD_10:1.11.0.2
	MIRBSD_10_BASE:1.11
	MIRBSD_9_BASE:1.8
	MIRBSD_8:1.3.0.2
	MIRBSD_8_BASE:1.3
	cvs-200507032030:1.1.1.1
	cvs-200505050030:1.1.1.1
	cvs-200504291700:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@# @;


1.86
date	2018.10.07.01.10.58;	author tg;	state Exp;
branches;
next	1.85;
commitid	1005BB95CA10BF418E8;

1.85
date	2012.09.02.22.08.48;	author tg;	state Exp;
branches;
next	1.84;
commitid	1005043D8F918342F3C;

1.84
date	2009.10.27.16.00.05;	author tg;	state Exp;
branches;
next	1.83;
commitid	1004AE718FF2242033D;

1.83
date	2009.10.27.15.38.32;	author tg;	state Exp;
branches;
next	1.82;
commitid	1004AE714011AB511BC;

1.82
date	2009.10.27.14.34.49;	author tg;	state Exp;
branches
	1.82.2.1;
next	1.81;
commitid	1004AE705114E6341C1;

1.81
date	2009.10.27.13.23.38;	author tg;	state Exp;
branches;
next	1.80;
commitid	1004AE6F46E6356CBDC;

1.80
date	2009.10.24.16.12.01;	author tg;	state Exp;
branches;
next	1.79;
commitid	1004AE327462D095EBC;

1.79
date	2009.10.24.15.39.41;	author tg;	state Exp;
branches;
next	1.78;
commitid	1004AE31FBD2F85D47B;

1.78
date	2009.10.24.14.19.36;	author tg;	state Exp;
branches;
next	1.77;
commitid	1004AE30D0821BEF25B;

1.77
date	2009.10.24.14.16.51;	author tg;	state Exp;
branches;
next	1.76;
commitid	1004AE30C6434977ABE;

1.76
date	2009.08.09.19.39.40;	author tg;	state Exp;
branches;
next	1.75;
commitid	1004A7F259B3D7C9644;

1.75
date	2009.08.09.18.51.41;	author tg;	state Exp;
branches;
next	1.74;
commitid	1004A7F1A1B76A4634B;

1.74
date	2009.03.15.17.27.44;	author tg;	state Exp;
branches;
next	1.73;
commitid	10049BD3AA302B02AAA;

1.73
date	2009.03.15.17.14.14;	author tg;	state Exp;
branches;
next	1.72;
commitid	10049BD3767005E1F75;

1.72
date	2009.01.31.18.51.18;	author tg;	state Exp;
branches;
next	1.71;
commitid	10049849D7F07A9D7B9;

1.71
date	2009.01.12.21.25.23;	author tg;	state Exp;
branches;
next	1.70;
commitid	100496BB55314A29F4C;

1.70
date	2009.01.12.21.00.16;	author tg;	state Exp;
branches;
next	1.69;
commitid	100496BAF691BA6E804;

1.69
date	2009.01.12.20.13.12;	author tg;	state Exp;
branches;
next	1.68;
commitid	100496BA4687F022625;

1.68
date	2009.01.12.19.42.00;	author tg;	state Exp;
branches;
next	1.67;
commitid	100496B9D181B12242E;

1.67
date	2009.01.12.19.39.21;	author tg;	state Exp;
branches;
next	1.66;
commitid	100496B9C570A2B6734;

1.66
date	2009.01.12.18.07.22;	author tg;	state Exp;
branches;
next	1.65;
commitid	100496B86EE452CAA71;

1.65
date	2009.01.12.17.42.51;	author tg;	state Exp;
branches;
next	1.64;
commitid	100496B811F75F060D9;

1.64
date	2009.01.12.17.36.03;	author tg;	state Exp;
branches;
next	1.63;
commitid	100496B7F9043C26B46;

1.63
date	2009.01.12.17.04.03;	author tg;	state Exp;
branches;
next	1.62;
commitid	100496B77FB5AA43124;

1.62
date	2009.01.11.23.16.19;	author tg;	state Exp;
branches;
next	1.61;
commitid	100496A7DDB40A4E132;

1.61
date	2009.01.11.22.52.35;	author tg;	state Exp;
branches;
next	1.60;
commitid	100496A784468CD00EF;

1.60
date	2009.01.11.22.51.16;	author tg;	state Exp;
branches;
next	1.59;
commitid	100496A77C05D310FBB;

1.59
date	2009.01.11.19.49.19;	author tg;	state Exp;
branches;
next	1.58;
commitid	100496A4D3521ECBFCB;

1.58
date	2009.01.11.17.08.29;	author tg;	state Exp;
branches;
next	1.57;
commitid	100496A279425497225;

1.57
date	2009.01.11.14.50.26;	author tg;	state Exp;
branches;
next	1.56;
commitid	100496A07264B6C9A0D;

1.56
date	2009.01.11.14.47.37;	author tg;	state Exp;
branches;
next	1.55;
commitid	100496A069A2DE72405;

1.55
date	2009.01.11.14.40.27;	author tg;	state Exp;
branches;
next	1.54;
commitid	100496A04CF0C3726C0;

1.54
date	2009.01.11.14.11.27;	author tg;	state Exp;
branches;
next	1.53;
commitid	1004969FE1962CEA699;

1.53
date	2009.01.10.20.28.27;	author tg;	state Exp;
branches;
next	1.52;
commitid	1004969050259BEA59F;

1.52
date	2009.01.10.19.21.26;	author tg;	state Exp;
branches;
next	1.51;
commitid	1004968F52E60C45C25;

1.51
date	2009.01.10.18.15.09;	author tg;	state Exp;
branches;
next	1.50;
commitid	1004968E59B158ABED9;

1.50
date	2009.01.10.14.49.03;	author tg;	state Exp;
branches;
next	1.49;
commitid	1004968B5690CAD8165;

1.49
date	2009.01.10.14.38.49;	author tg;	state Exp;
branches;
next	1.48;
commitid	1004968B3060A76F359;

1.48
date	2009.01.10.14.30.44;	author tg;	state Exp;
branches;
next	1.47;
commitid	1004968B11F735D2DEA;

1.47
date	2009.01.10.13.58.57;	author tg;	state Exp;
branches;
next	1.46;
commitid	1004968A9A5662F59EA;

1.46
date	2009.01.10.13.41.18;	author tg;	state Exp;
branches;
next	1.45;
commitid	1004968A59443A02B58;

1.45
date	2009.01.10.13.24.46;	author tg;	state Exp;
branches;
next	1.44;
commitid	1004968A1AF6EDF5D38;

1.44
date	2009.01.10.12.12.19;	author tg;	state Exp;
branches;
next	1.43;
commitid	100496890B52F059A0D;

1.43
date	2009.01.03.13.43.32;	author tg;	state Exp;
branches;
next	1.42;
commitid	100495F6B566145BE45;

1.42
date	2009.01.02.20.55.53;	author tg;	state Exp;
branches;
next	1.41;
commitid	100495E7F7000772168;

1.41
date	2009.01.02.20.55.28;	author tg;	state Exp;
branches;
next	1.40;
commitid	100495E7F5417E508EF;

1.40
date	2009.01.02.20.52.28;	author tg;	state Exp;
branches;
next	1.39;
commitid	100495E7E7A366F834A;

1.39
date	2009.01.02.16.38.36;	author tg;	state Exp;
branches;
next	1.38;
commitid	100495E430D546F7076;

1.38
date	2009.01.02.16.18.21;	author tg;	state Exp;
branches;
next	1.37;
commitid	100495E3E645EC888FF;

1.37
date	2009.01.02.07.43.23;	author tg;	state Exp;
branches;
next	1.36;
commitid	100495DC5AB158C2E71;

1.36
date	2009.01.02.07.35.31;	author tg;	state Exp;
branches;
next	1.35;
commitid	100495DC3C87EB82C6A;

1.35
date	2009.01.02.07.26.36;	author tg;	state Exp;
branches;
next	1.34;
commitid	100495DC1BA7FDF680F;

1.34
date	2009.01.02.06.37.02;	author tg;	state Exp;
branches;
next	1.33;
commitid	100495DB6255008F65A;

1.33
date	2009.01.02.05.45.02;	author tg;	state Exp;
branches;
next	1.32;
commitid	100495DA9EE0F0AAD40;

1.32
date	2009.01.02.05.40.56;	author tg;	state Exp;
branches;
next	1.31;
commitid	100495DA8FE6668E0AD;

1.31
date	2009.01.02.05.30.54;	author tg;	state Exp;
branches;
next	1.30;
commitid	100495DA6A310C4A436;

1.30
date	2009.01.02.05.16.33;	author tg;	state Exp;
branches;
next	1.29;
commitid	100495DA33F62ABDC14;

1.29
date	2009.01.02.04.58.40;	author tg;	state Exp;
branches;
next	1.28;
commitid	100495D9F177CADA327;

1.28
date	2009.01.02.04.27.43;	author tg;	state Exp;
branches;
next	1.27;
commitid	100495D97D1455B7664;

1.27
date	2009.01.02.04.22.36;	author tg;	state Exp;
branches;
next	1.26;
commitid	100495D969C35B72810;

1.26
date	2009.01.02.04.14.35;	author tg;	state Exp;
branches;
next	1.25;
commitid	100495D94B3443F7EAF;

1.25
date	2009.01.02.04.13.53;	author tg;	state Exp;
branches;
next	1.24;
commitid	100495D94990658ED64;

1.24
date	2009.01.01.22.23.24;	author tg;	state Exp;
branches;
next	1.23;
commitid	100495D426E338F663B;

1.23
date	2009.01.01.19.13.32;	author tg;	state Exp;
branches;
next	1.22;
commitid	100495D15EF73E02B25;

1.22
date	2009.01.01.17.46.19;	author tg;	state Exp;
branches;
next	1.21;
commitid	100495D00F40CC2CEE6;

1.21
date	2008.12.31.16.38.36;	author tg;	state Exp;
branches;
next	1.20;
commitid	100495BA02136D7BE32;

1.20
date	2008.12.28.22.19.07;	author tg;	state Exp;
branches;
next	1.19;
commitid	1004957FB673323DDA5;

1.19
date	2008.12.28.20.16.19;	author tg;	state Exp;
branches;
next	1.18;
commitid	1004957DE8C248018FB;

1.18
date	2008.12.28.19.04.31;	author tg;	state Exp;
branches;
next	1.17;
commitid	1004957CDD62B4D72F5;

1.17
date	2008.12.28.17.32.18;	author tg;	state Exp;
branches;
next	1.16;
commitid	1004957B82F66B8FA83;

1.16
date	2008.12.28.16.18.08;	author tg;	state Exp;
branches;
next	1.15;
commitid	1004957A6CB60D6ED0C;

1.15
date	2008.12.28.16.12.10;	author tg;	state Exp;
branches;
next	1.14;
commitid	1004957A55B13F1B17A;

1.14
date	2008.08.05.19.07.46;	author tg;	state Exp;
branches;
next	1.13;
commitid	1004898A5185AD0AD68;

1.13
date	2008.08.05.19.05.01;	author tg;	state Exp;
branches;
next	1.12;
commitid	1004898A46C6ED28D83;

1.12
date	2008.08.05.17.57.07;	author tg;	state Exp;
branches;
next	1.11;
commitid	100489894510593D3DC;

1.11
date	2007.03.18.02.45.52;	author tg;	state Exp;
branches;
next	1.10;
commitid	10045FCA7EF3FB4FAF2;

1.10
date	2006.12.11.23.55.01;	author tg;	state Exp;
branches;
next	1.9;
commitid	100457DEFC626A6A05C;

1.9
date	2006.08.19.14.20.28;	author tg;	state Exp;
branches;
next	1.8;
commitid	10044E71E3D359AC2FA;

1.8
date	2006.05.15.20.47.05;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004468E8C548985FB8;

1.7
date	2006.04.10.20.54.46;	author tg;	state Exp;
branches;
next	1.6;
commitid	100443AC62A57A9506C;

1.6
date	2006.04.10.19.11.52;	author tg;	state Exp;
branches;
next	1.5;
commitid	100443AAE0A49D44564;

1.5
date	2006.04.10.19.10.50;	author tg;	state Exp;
branches;
next	1.4;
commitid	100443AADBE25E05304;

1.4
date	2006.04.05.22.12.17;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004434408D12C01CCC;

1.3
date	2005.12.04.13.22.16;	author tg;	state Exp;
branches;
next	1.2;
commitid	3c454392ed956526;

1.2
date	2005.03.06.21.27.03;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.27.28;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.82.2.1
date	2009.10.27.15.10.50;	author tg;	state Exp;
branches;
next	1.82.2.2;
commitid	1004AE70D6303F6EF50;

1.82.2.2
date	2009.10.27.15.31.18;	author tg;	state Exp;
branches;
next	;
commitid	1004AE7125727D3440D;

1.1.1.1
date	2005.02.05.17.27.28;	author tg;	state Exp;
branches;
next	;


desc
@@


1.86
log
@spelling cleanup: “programme” is distinct from “program”; even in
British English, the latter is used for computer programs, while
the former serves for things like the TV programme, or a programme
to plant trees
@
text
@/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.85 2012/09/02 22:08:48 tg Exp $ */

/*-
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2012
 *	Thorsten Glaser <tg@@mirbsd.org>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 */

#include "stand/boot/cmd.h"

	.intel_syntax noprefix
	.text
	.code16

	/* extern */
	.globl	real_to_prot
	.globl	prot_to_real
	.globl	boot
	.globl	_edata
	.globl	_end
	.globl	_rtt
#ifdef USE_PXE
	.globl	have_pxe
#endif
	/* global */
	.globl	_start
	.globl	bios_bootpte
	.globl	i386_userpt
	.globl	i386_biosdev
	.globl	i386_biosflags
	.globl	i386_dosdev
	.globl	pxe_bang
	.globl	pxe_plus
	.globl	pxecall_addr
	.globl	lmbm_num
	.globl	lmbm_ofs

_start:	cli
	call	Linit
Lrval:	.p2align 2
	. = _start + 4
	/*	  ffffddpp	(f)lags user(p)artype (d)rive */
Ldrvi:	.long	0x696D4F00	/* drive information and magic */
	i386_userpt = Ldrvi
	i386_biosdev = Ldrvi + 1
	i386_biosflags = Ldrvi + 2
		/*-
		 * 01101101 = flags invalid
		 * xxxxxx00 = nothing special about drives
		 * xxxxxx01 = i386_dosdev valid, DOS interface
		 * xxxxxx10 = pxelinux or invalid FOOlinux
		 * xxxxxx11 = syslinux/extlinux/isolinux
		 * xxxxx1xx = probably booted via PXE
		 */
	i386_dosdev = Ldrvi + 3
		/*-
		 * if PXE: 0 = do not scan, 1 = do scan
		 */
	.size	i386_userpt,1
	.size	i386_biosdev,1
	.size	i386_biosflags,1
	.size	i386_dosdev,1
	. = _start + 8
pxe_bang:
	.size	pxe_bang,4
	.long	0		/* address of !PXE structure */
	. = _start + 12
pxe_plus:
	.size	pxe_plus,4
	.long	0		/* address of PXENV+ structure */
	. = _start + 16
bios_bootpte:
	.size	bios_bootpte,16
	.long	0, 0, 0, 0	/* 16 bytes from initial DS:SI */
	. = _start + 32
pxecall_addr:
	.size	pxecall_addr,4
	.long	0		/* PXE RM entry point (FAR pointer) */
lmbm_num:
	.size	lmbm_num,4
	.long	0		/* number of Loadable MultiBoot Modules */
lmbm_ofs:
	.size	lmbm_ofs,4
	.long	0		/* address of LMBM table, if loaded */

#ifndef SMALL_BOOT
	/* Multiboot header */
	.p2align 2
Lmbhdr:	.long	0x1BADB002		/* magic */
	.long	0x00010000		/* flags */
	.long	-0x1BADB002-0x00010000	/* checksum */
	/* the addresses are all bounced to 1 MiB */
	.long	Lmbhdr - SA_LINKADDR + 0x00100000	/* header_addr */
	.long	0x00100000				/* load_addr */
	.long	0					/* load_end_addr */
	.long	0					/* bss_end_addr */
	.long	Lmbrun - SA_LINKADDR + 0x00100000	/* entry_addr */
#endif

	/* pointer to ldbsd.com command line or 1 (DOS/COMBOOT PSP) */
Largp:	.long	0

Linit:	/* qemu sucks, int3 doesn’t work */
	push	ds
	push	si
	xor	si,si
	mov	ds,si
	mov	cl,0xCB
	xchg	ds:[si],cl
	/* set a “b *0” to stop at this point */
	lcall	0x0000,0x0000
	xchg	ds:[si],cl
	pop	si
	pop	ds

#ifndef SMALL_BOOT
	mov	cx,es
	shl	ecx,16
	mov	cx,bx		/* ECX: PXENV+ */
	mov	bp,sp
	mov	edi,[bp+6]	/* EDI: !PXE */
	rol	esi,16
	mov	si,ds		/* ESI: SI:DS */
#endif

	xor	ebp,ebp
	push	ebp
	popfd
	pop	bp

	/* make cs:(e)bx = offset _start */
	lea	ebx,[ebp + offset _start - offset Lrval]
	/* make ebp = flat offset _start */
	mov	bp,cs
	shl	ebp,4
	add	ebp,ebx
	/* make ax = _start + 64K (approx.) */
	mov	eax,ebp
	shr	eax,4
	add	ax,0x1000
	/* set up initial stack */
	mov	ss,ax
	mov	esp,0x00003FEC

	/* first stage: before relocation */

	/* set up segment registers */
	mov	ax,cs
	mov	ds,ax
	mov	es,ax

#ifdef SMALL_BOOT
	xor	eax,eax
	mov	ah,dl
	mov	al,ds:[ebx + offset Ldrvi - offset _start]
	mov	ds:[ebx + offset Ldrvi - offset _start],eax
#else
	/* store away structure pointers */
	mov	ds:[ebx + offset pxe_plus - offset _start],ecx
	mov	ds:[ebx + offset pxe_bang - offset _start],edi
	cmp	byte ptr ds:[ebx + offset i386_biosflags - offset _start],0x6D
	je	1f
	mov	ds,si
	rol	esi,16
	lea	di,[ebx + offset bios_bootpte - offset _start]
	movsd
	movsd
	movsd
	movsd
	mov	ax,cs
	mov	ds,ax
	jmp	3f
1:	xor	eax,eax
	mov	ah,dl
	cmp	ebp,0x00007C00
	jne	2f
	or	eax,0x01040000		/* PXE, do scan */
2:	mov	al,ds:[ebx + offset Ldrvi - offset _start]
	mov	ds:[ebx + offset Ldrvi - offset _start],eax
3:	/* find out if we're a DOS or SYSLINUX COMBOOT program */
	cmp	bx,0x0100
	jne	Lnocom
	cmp	word ptr ds:[0],0x20CD
	jne	Lnocom

	/* store magic flag to Largp for using the command line */
	inc	byte ptr ds:[ebx + offset Largp - offset _start]

	push	ebp
	push	ebx

	xor	eax,eax
	/* from DOS or SYSLINUX: no PXE or bootpte */
	lea	edi,[ebx + offset pxe_bang - offset _start]
	mov	cx,6
	rep	stosd

	mov	ah,0x30		/* get DOS version */
	int	0x21
	cmp	eax,0x59530000
	jne	Lnolx
	cmp	ecx,0x4E490000
	jne	Lnolx
	cmp	edx,0x58550000
	jne	Lnolx
	cmp	ebx,0x4C530000
	jne	Lnolx

	/* SYSLINUX */
	mov	ax,0x0005	/* SYSLINUX: force text mode */
	int	0x22
	mov	ax,0x000A	/* SYSLINUX: get information */
	int	0x22
	push	cs
	pop	ds
	pop	ecx
	cmp	al,0x31
	jb	Linvlinux
	je	Lsyslinux
	cmp	al,0x34
	ja	Linvlinux
	je	Lextlinux
	cmp	al,0x33
	je	Lisolinux

Lpxelinux:
	mov	ax,es
	shl	eax,16
	mov	ax,bx
	mov	ds:[ecx + offset pxe_bang - offset _start],eax
	mov	ds:[ecx + offset pxe_plus - offset _start],eax
	xor	edx,edx
	mov	dh,4		/* probably PXE :) but do not scan */
	mov	bx,3		/* clean up but retain PXE and UNDI */
	jmp	Lislx

Lsyslinux:
Lextlinux:
	mov	eax,es:[bx]
	mov	ds:[ecx + offset bios_bootpte - offset _start],eax
	mov	eax,es:[bx+4]
	mov	ds:[ecx + offset bios_bootpte - offset _start + 4],eax
	mov	eax,es:[bx+8]
	mov	ds:[ecx + offset bios_bootpte - offset _start + 8],eax
	mov	eax,es:[bx+12]
	mov	ds:[ecx + offset bios_bootpte - offset _start + 12],eax
Lisolinux:
Linvlinux:
	and	edx,0xFF
	mov	dh,1
	xor	bx,bx		/* clean up everything */
Lislx:	or	dh,2
	shl	edx,8
	mov	dl,ds:[ecx + offset Ldrvi - offset _start]
	mov	ds:[ecx + offset Ldrvi - offset _start],edx

	mov	ax,0x000C	/* SYSLINUX: final cleanup */
	mov	dx,bx		/* see above */
	int	0x22
	jmp	Liscom

Lnolx:	/* DOS */
	mov	ah,0x19
	int	0x21
	push	cs
	pop	ds
	pop	ecx
	lea	ebx,[ecx + offset Ldrvi - offset _start]
	mov	ah,al		/* ign ign dosdrv dosdrv */
	cmp	al,2
	jb	1f		/* floppy (BIOS 00h, 01h) for DOS A:, B: */
	mov	al,0x80		/* fake BIOS 80h for DOS C:, D:, E:, ... */
1:	shl	eax,8		/* ign dosdrv biosdrv zero */
	inc	ax		/* 01 = flag: DOS drive valid */
	xchg	ah,al		/* ign dosdrv flag=1 biosdrv */
	shl	eax,8		/* dosdrv flag biosdrv zero */
	mov	al,ds:[bx]	/* dosdrv flag biosdrv partp */
	mov	ds:[bx],eax

Liscom:	pop	ebp
	xor	eax,eax
	push	eax
	popfd
Lnocom:	/* flags are (already) okay */
#endif

	/* load source address (_start) normalised */
	mov	ebx,ebp
	shr	ebx,4
	/* subtract 128 for DOS/COMBOOT PSP command line */
	sub	bx,(128/16)
	mov	ds,bx
	mov	si,bp
	and	si,0x000F

	/* check if we need to relocate */
	cmp	ebp,SA_LINKADDR
	je	LdoRel		/* to set up the stack */
	cmp	ebp,0x1C000
	jbe	LdoRel		/* way below target */
	cmp	ebp,0x50000
	jae	LdoRel		/* somewhat above target */

	/* eek, relocate twice */
	mov	ax,0x7000
	mov	ss,ax
	mov	sp,0x3FFC
	mov	ax,0x6000
	push	ax
	/* subtract 128 for DOS/COMBOOT PSP command line */
	sub	ax,(128/16)
	mov	es,ax
	xor	di,di
	mov	eax,offset LdoRel - offset _start
	push	ax
	push	es
	push	di
	/* min. 0xFF00 max. code size + 0x80 PSP cmdline */
	mov	cx,0xFFF0
	rep	movsb
	pop	si
	pop	ds
	lret

LdoRel:	mov	ax,0x3000
	mov	ss,ax
	mov	esp,0x0000FF7C
	cmp	ebp,SA_LINKADDR
	je	LisRel

	/* subtract 128 for DOS/COMBOOT PSP command line */
	mov	ax,(SA_LINKSEG - (128/16))
	mov	es,ax
	xor	di,di
	/* same as above */
	mov	cx,0xFFF0
	rep	movsb

	/* assumes flags=0, SS:ESP set up to 3000:0000FF7Ch */
LisRel:	mov	ax,SA_LINKSEG
	mov	ds,ax
	mov	es,ax
	push	ax
	mov	eax,offset Lstart - offset _start
	push	ax
	lret

	/* whew, we're relocated */
Lstart:
	/* check for presence of command line */
	mov	esi,offset Largp - offset _start
	mov	eax,[si]
	or	eax,eax
	jz	Lnocmd
#ifdef BOOTSELECT_HOOK
	xor	ebx,ebx
#endif
	cmp	eax,1		/* magic */
	jne	Liscmd
	/* we have a DOS/COMBOOT PSP, analyse it */
	mov	ax,ds
	push	ax
	sub	ax,(128/16)
	mov	ds,ax
	xor	cx,cx
	mov	cl,byte ptr ds:[0]
	mov	si,1
1:	or	cx,cx
	jz	Lpspno
	lodsb
	cmp	al,0x09		/* tab */
	je	2f
	cmp	al,0x0D		/* CR */
	je	2f
	cmp	al,0x20		/* space */
	jne	3f
2:	dec	cx
	jmp	1b
3:	dec	si
	mov	di,si
	add	di,cx
	dec	di
4:	mov	al,[di]
	cmp	al,0x09		/* tab */
	je	5f
	cmp	al,0x0D		/* CR */
	je	5f
	cmp	al,0x20		/* space */
	jne	6f
5:	dec	cx
	jz	Lpspno
	dec	di
	jmp	4b
6:	inc	di
	xor	eax,eax
	mov	[di],al		/* convert to NUL-terminated */
	/* DS:SI now points to NUL-terminated argv (SI < 0x80) */
	mov	ax,ds
	shl	eax,4
	add	ax,si
	pop	ds
	/* store flat pointer to NUL-terminated argv into Largp */
	mov	esi,offset Largp - offset _start
	mov	[si],eax
#ifdef BOOTSELECT_HOOK
	xor	ebx,ebx
#endif
	jmp	Liscmd

Lpspno:	pop	ds
	xor	eax,eax
	mov	esi,offset Largp - offset _start
	mov	[si],eax
Lnocmd:	/* no command line found */
#ifdef BOOTSELECT_HOOK
	sti
	.globl	Lhook
	call	Lhook
	mov	ebx,eax
#endif
Liscmd:	/* a command line was found */

	call	real_to_prot
Lsta32:	.code32
	/* ensure stack is 32-bit aligned */
	mov	esp,0x0003FF7C
	/* zero out .bss section */
	xor	eax,eax
	push	eax
	popfd
	mov	ecx,offset _end
	mov	edi,offset _edata
	sub	ecx,edi
	rep	stosb

	/* zero out stack segment lower parts */
	mov	edi,offset ssbss_beg
	mov	ecx,offset ssbss_end - offset ssbss_beg
	rep	stosb

#ifdef BOOTSELECT_HOOK
	/* store user choice */
	mov	[hook_value],ebx
#endif

	/* store command line, if any */
	mov	esi,[Largp]
	or	esi,esi
	jz	1f
	mov	ecx,(CMD_BUFF_SIZE - 1)
	mov	edi,offset cmd_buf
	rep	movsb
	/* NUL-terminate potentially too long multiboot cmdline */
	mov	al,0
	stosb
1:

	movzx	eax,byte ptr [i386_biosdev]
	push	eax
	call	boot
	jmp	_rtt

#ifndef SMALL_BOOT
	/* Multiboot entry point */
	.p2align 4,0x90
Lmbrun:	mov	esp,0x0003FF7C
	xor	eax,eax
	push	eax
	popfd

	/* set a “b *0” to stop at this point */
	push	[eax]
	mov	byte ptr [eax],0xC3
	call	eax
	pop	[eax]

	mov	esi,0x00100000
	mov	edi,SA_LINKADDR
	mov	ecx,0x4000
	rep	movsd
	mov	eax,offset Lmb2rm
	jmp	eax
	/* relocated */
Lmb2rm:	mov	edi,offset Ldrvi
	mov	edx,[ebx+12]		/* boot_device */
	shr	edx,16
	mov	eax,edx
	mov	al,[edi]	/* user partition type */
	stosd			/* drive information */
	xor	eax,eax
	stosd			/* pxe_bang */
	stosd			/* pxe_plus */
	stosd			/* partition */
	stosd			/* partition */
	stosd			/* partition */
	stosd			/* partition */
#ifdef USE_PXE
	mov	[have_pxe],eax	/* do not even try */
#endif

	mov	eax,[ebx]
	and	eax,(1 << 2)	/* do we have command line? */
	jz	1f		/* nope */
	mov	esi,[ebx+16]	/* pointer */
	/*
	 * annoyingly enough, the first word on the command line
	 * is our own pathname, so we must skip it
	 */
4:	lodsb
	or	al,al		/* NUL */
	jz	1f
	cmp	al,0x09		/* tab */
	je	2f
	cmp	al,0x0A		/* LF */
	je	2f
	cmp	al,0x0D		/* CR */
	je	2f
	cmp	al,0x20		/* space */
	jne	4b
2:	lodsb
	or	al,al		/* NUL */
	jz	1f
	cmp	al,0x09		/* tab */
	je	2b
	cmp	al,0x0A		/* LF */
	je	2b
	cmp	al,0x0D		/* CR */
	je	2b
	cmp	al,0x20		/* space */
	je	2b
	dec	esi
	mov	edi,esi
	mov	ecx,CMD_BUFF_SIZE
	xor	eax,eax
	repne	scasb
3:	dec	edi
	mov	al,[edi]
	cmp	al,0x09		/* tab */
	je	3b
	cmp	al,0x0A		/* LF */
	je	3b
	cmp	al,0x0D		/* CR */
	je	3b
	cmp	al,0x20		/* space */
	je	3b

	/* got a non-empty command line */
	mov	byte ptr [edi+1],0
	mov	[Largp],esi

	/* got no command line */
1:	mov	eax,[ebx]
	and	eax,(1 << 3)	/* do we have modules? */
	jz	Lnombm		/* nope */
	mov	eax,[ebx+20]	/* how many? */
	mov	[lmbm_num],eax
	mov	eax,[ebx+24]	/* module information */
	mov	[lmbm_ofs],eax
Lnombm:

	lgdt	Gdtr
	call	prot_to_real	/* converts stack */
	.code16
	jmp	LisRel
#endif

#ifdef USE_PXE
	.code32
	.globl	pxecall_bang
pxecall_bang:
	push	ebp
	mov	ebp,esp
	pushfd
	push	ebx
	push	esi
	push	edi

	mov	ebx,[ebp+8]
	mov	edi,offset pxe_command_buf - offset bounce_buf

	call	prot_to_real
	.code16
	sti

	push	ss
	push	di
	push	bx
	lcall	ds:[32]		/* pxecall_addr */
	add	sp,6
	movzx	ebx,ax

	call	real_to_prot
	.code32

	mov	eax,ebx
	pop	edi
	pop	esi
	pop	ebx
	popfd
	pop	ebp
	ret

	.globl	pxecall_plus
pxecall_plus:
	push	ebp
	mov	ebp,esp
	pushfd
	push	ebx
	push	esi
	push	edi

	mov	ebx,[ebp+8]
	mov	edi,offset pxe_command_buf - offset bounce_buf

	call	prot_to_real
	.code16
	sti

	push	ss
	pop	es
	lcall	ds:[32]		/* pxecall_addr */
	movzx	ebx,ax

	call	real_to_prot
	.code32

	mov	eax,ebx
	pop	edi
	pop	esi
	pop	ebx
	popfd
	pop	ebp
	ret
#endif


	bounce_buf = 0x30000
	.globl	bounce_buf
	.size	bounce_buf, 4096

	crc_table = bounce_buf + 4096
	.globl	crc_table
	.size	crc_table, 1024

	pxe_command_buf = crc_table + 1024
	.globl	pxe_command_buf
	.size	pxe_command_buf, 256

	sa_fixed_table = pxe_command_buf + 256
	.globl	sa_fixed_table
	.size	sa_fixed_table, 2176

	biosdev_lba_buf = sa_fixed_table + 2176
	.globl	biosdev_lba_buf
	.size	biosdev_lba_buf, 16

	cmd_buf = biosdev_lba_buf + 16
	.globl	cmd_buf
	.size	cmd_buf, CMD_BUFF_SIZE

	/* last; size unknown (<0x1000) */
	cmd = cmd_buf + CMD_BUFF_SIZE
	.globl	cmd
	.size	cmd, CMD_STRUCT_SIZE

	ssbss_beg = bounce_buf
	ssbss_end = cmd + 0x0900
@


1.85
log
@even #ifdef SMALL_BOOT we need to know our DL register later on
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.84 2009/10/27 16:00:05 tg Exp $ */
d194 1
a194 1
3:	/* find out if we're a DOS or SYSLINUX COMBOOT programme */
@


1.84
log
@set the breakpoint at 0000:0000h (16-bit) or 0x00000000 (32-bit), with
a RETF (16-bit) or RET (32-bit) but backing up the old content

tested
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.83 2009/10/27 15:38:32 tg Exp $ */
d4 1
a4 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009
d166 6
a171 1
#ifndef SMALL_BOOT
@


1.83
log
@always have the 0x70000 break debugging code, for the sake of easier…
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.82 2009/10/27 14:34:49 tg Exp $ */
d119 9
a127 7
	push	ax
	mov	ax,0x7000
	mov	ds,ax
	mov	byte ptr ds:[0],0xCB
	/* set a “b *0x70000” to stop at this point */
	lcall	0x7000,0x0000
	pop	ax
d479 7
@


1.82
log
@fix: PXELINUX flag was not correctly saved after detection
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.81 2009/10/27 13:23:38 tg Exp $ */
d117 1
a117 2
Linit:
#if 0	/* qemu sucks, int3 doesn't work */
d123 1
a123 1
	/* set a b *0x70000 to stop this */
d127 1
a127 1
#endif
@


1.82.2.1
log
@attempt to move *all* of .bss to 3000:0000h and up
(when loaded via gPXE+PXELINUX, fighting memory corruption?)

XXX we *really* need a position-independent or relocatable boot
XXX loader; sadly, gcc’s idea of PIC/PIE cannot be of any help…
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.82 2009/10/27 14:34:49 tg Exp $ */
d30 5
a34 2
	.globl	__bss_end
	.globl	__bss_start
a35 3
	.globl	boot
	.globl	prot_to_real
	.globl	real_to_prot
a37 1
	.globl	pxe_command_buf
d439 2
a440 2
	mov	ecx,offset __bss_end
	mov	edi,offset __bss_start
d442 6
a447 2
	shr	ecx,2
	rep	stosd
d580 1
a580 2
	/* truncated by __bss_start = 3000:0000 */
	mov	edi,offset pxe_command_buf
d614 1
a614 2
	/* truncated by __bss_start = 3000:0000 */
	mov	edi,offset pxe_command_buf
d636 33
@


1.82.2.2
log
@the address of bounce_buf is hardcoded in places…
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.82.2.1 2009/10/27 15:10:50 tg Exp $ */
d578 1
a578 1
	mov	edi,offset pxe_command_buf - 0x30000
d613 1
a613 1
	mov	edi,offset pxe_command_buf - 0x30000
a634 22

	.bss

	.globl	bounce_buf
	.size	bounce_buf, 4096
bounce_buf:
	.space	4096

	.globl	crc_table
	.size	crc_table, 1024
crc_table:
	.space	1024

	.globl	sa_fixed_table
	.size	sa_fixed_table, 2176
sa_fixed_table:
	.space	2176

	.globl	biosdev_lba_buf
	.size	biosdev_lba_buf, 16
biosdev_lba_buf:
	.space	16
@


1.81
log
@add some debugging code
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.80 2009/10/24 16:12:01 tg Exp $ */
d241 1
a241 1
	mov	ah,4		/* probably PXE :) but do not scan */
@


1.80
log
@since we relocate to 0x40000 but copy the previous 128 bytes from the PSP
too, which end up at 0x3FF80, move the stack from 0x3FFFC to 0x3FF7C
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.79 2009/10/24 15:39:41 tg Exp $ */
d118 11
@


1.79
log
@save (and display) command line passed to us from
• DOS (PSP)
• SYSLINUX COMBOOT (PSP)
• GRUB (Multiboot)
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.78 2009/10/24 14:19:36 tg Exp $ */
d324 1
a324 1
	mov	esp,0x0000FFFC
d336 1
a336 1
	/* assumes flags=0, SS:ESP set up to 3000:0000FFFCh */
d423 1
a423 1
	mov	esp,0x0003FFFC
d463 1
a463 1
Lmbrun:	mov	esp,0x0003FFFC
@


1.78
log
@move cmd_buf[] to ssbss section
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.77 2009/10/24 14:16:51 tg Exp $ */
d114 3
d183 3
d287 2
d307 2
d315 1
d328 2
a329 1
	mov	ax,SA_LINKSEG
d332 1
d347 65
d418 1
d443 12
d492 51
@


1.77
log
@compile time size test for certain structures
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.76 2009/08/09 19:39:40 tg Exp $ */
d505 4
d510 1
a510 1
	cmd = biosdev_lba_buf + 16
@


1.76
log
@we absolutely needed to save space (cf. liveboot numbers below), so use an
mksh script (endian-neutral) to pre-fixup the IDT instead of generating one
at run/initialisation time from 16 bit code

XXX I wonder how the LZMA decompressor and ustarfs will fit… it’d probably
XXX be best to indeed compress the 32-bit code part with a rather simple
XXX algorithm to separate the 16-bit setup code part, multiboot kernel,
XXX coloured bootselection code, etc. from what’ll really be needed later

   text    data     bss     dec     hex filename
  59466    2024    3716   65206    feb6 boot.elf
  57778    2024    3716   63518    f81e boot.elf
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.75 2009/08/09 18:51:41 tg Exp $ */
d508 1
a508 1
	.size	cmd, 0x0900	/* approx. 0x8C8 */
@


1.75
log
@Add new (virtual) filesystem “lmbm” (Loadable MultiBoot Modules, like LKM)
that contains the modules we got passed when loaded as Multiboot OS Kernel
as per the spec. Quirks:
• case sensitive
• supports “ls” on its (virtual) root directory
• does *not* support filesystems (cuts off both the directory part of the
  module string passed and the directory part when opening a file, but the
  root directory can only be opened as “/” or “/.” (or “lmbm:/”, etc.)
• assumes that we and all modules are loaded below 20 MiB in RAM
• moves modules on filesystem initialisation (virtual disc probe) to just
  above 20 MiB in RAM
• assumes the kernel will fit below 20 MiB in RAM, too
• does not affect non-multiboot operation
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.74 2009/03/15 17:27:44 tg Exp $ */
a29 1
	.globl	idt_init
d333 1
a333 1
Lstart:	call	idt_init
@


1.74
log
@quell relocation warnings
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.73 2009/03/15 17:14:14 tg Exp $ */
d50 2
d94 6
d373 1
a373 2
Lmbrun:	mov	edx,[ebx+12]		/* boot_device */
	mov	esp,0x0003FFFC
d385 1
d401 9
@


1.73
log
@make pxe_bang and pxe_plus always bear the addresses of the
respective structures; use new pxecall_addr for calling fns
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.72 2009/01/31 18:51:18 tg Exp $ */
d49 1
d88 4
a400 6

	.p2align 2
	.globl	pxecall_addr
pxecall_addr:
	.long	0

d420 1
a420 1
	lcall	ds:[pxecall_addr]
d453 1
a453 1
	lcall	ds:[pxecall_addr]
@


1.72
log
@new bootmagic, bootxx: reading only one sector at a time, ignoring
what the BIOS thinks it can do or cannot…

note: bootxx.sh (self-installing bootblocks) and installboot(8/i386)
both still break up entries at track boundaries, which is no longer
needed because of the single-sector reads
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.71 2009/01/12 21:25:23 tg Exp $ */
d396 6
d421 1
a421 1
	lcall	ds:[8]		/* pxe_bang */
d454 1
a454 1
	lcall	ds:[12]		/* pxe_plus */
@


1.71
log
@have_pxe is dependent on USE_PXE
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.70 2009/01/12 21:00:16 tg Exp $ */
d55 1
a55 1
Ldrvi:	.long	0x6A6D4F00	/* drive information */
@


1.70
log
@solution seems to be to just keep interrupts disabled in protected mode oO
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.69 2009/01/12 20:13:12 tg Exp $ */
d37 1
a37 1
#ifndef SMALL_BOOT
d384 1
d386 1
@


1.69
log
@more paranoia
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.68 2009/01/12 19:42:00 tg Exp $ */
a351 2
	sti

@


1.68
log
@fix asm, this is still not TASM
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.67 2009/01/12 19:39:21 tg Exp $ */
d331 2
a336 1
	sti
d352 2
a420 1
	sti
a452 1
	sti
@


1.67
log
@interrupts, flags paranoia, use registers ipv stack if possible,
return anything from the (*pxe_call)() and use CALL FAR instead
of double-return trick, etc.
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.66 2009/01/12 18:07:22 tg Exp $ */
d412 1
a412 1
	lcall	dword ptr ds:[8]	/* pxe_bang */
d446 1
a446 1
	lcall	dword ptr ds:[12]	/* pxe_plus */
@


1.66
log
@more cool pxe calls
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.65 2009/01/12 17:42:51 tg Exp $ */
d75 1
d79 1
d83 1
d326 1
a326 1
	push	eax
a328 1
	cli
d333 3
d348 1
a348 1
	pop	dword ptr [hook_value]
d397 1
d403 1
a403 3
	mov	ecx,[pxe_bang]
	mov	ebp,offset pxe_command_buf - offset bounce_buf
	mov	edx,offset pxecall_bang_rt - offset _start
a404 1
	cli
d410 1
a410 1
	push	bp
d412 1
a412 5
	push	cs
	push	dx
	push	ecx
	lret
pxecall_bang_rt:
d414 1
a415 1
	cli
d420 1
d424 1
d432 1
a437 1
	mov	ecx,[pxe_plus]
a438 1
	mov	edx,offset pxecall_plus_rt - offset _start
a439 1
	cli
d446 3
a448 6
	push	cs
	push	dx
	push	ecx
	lret
pxecall_plus_rt:
	cli
d453 1
d457 1
@


1.65
log
@initialise the “.bss moved to fardata/stack segment” to zero too
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.64 2009/01/12 17:36:03 tg Exp $ */
d386 79
@


1.64
log
@move two other huge blobs into the 3000h segment
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.63 2009/01/12 17:04:03 tg Exp $ */
d336 5
d410 3
@


1.63
log
@in an attempt to get code+data+bss into 65280 bytes (not there yet),
move the crc32 table to the „stack“ (and FARDATA) segment
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.62 2009/01/11 23:16:19 tg Exp $ */
d393 5
a397 1
	biosdev_lba_buf = pxe_command_buf + 256
d400 5
@


1.62
log
@be a bit more anal about segment selectors, which helps… oO
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.61 2009/01/11 22:52:35 tg Exp $ */
d385 5
a389 1
	pxe_command_buf = bounce_buf + 4096
@


1.61
log
@to hell with cmd_buf now…
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.60 2009/01/11 22:51:16 tg Exp $ */
a328 4
	mov	ax,ds
	mov	fs,ax
	mov	gs,ax

@


1.60
log
@do not use the OS stack (if we're close to 65280 bytes, this comes
in dangerously); do not use our istack; instead, pen and paper modelled,
use an almost 16 KiB stack behind a maximum of 64 KiB of code+data
we bring with us, and change the relocation model *again* (sigh…)
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.59 2009/01/11 19:49:19 tg Exp $ */
a338 4
	/* zero out temporary stack */
	mov	edi,offset cmd_buf
	mov	ecx,CMD_BUFF_SIZE
	rep	stosb
a384 8
	.p2align 4
	.globl	cmd_buf
	.size	cmd_buf, CMD_BUFF_SIZE
cmd_buf:
	.long	0xDEADBEEF
	. = cmd_buf + CMD_BUFF_SIZE - 4
	.long	0xCAFEBABE

@


1.59
log
@• better initialisation code
• much more annotations
• run longer with the previous loader's stack (esp. for DOS/SYSLINUX)
• do extra jumps and stack switches
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.58 2009/01/11 17:08:29 tg Exp $ */
d99 1
a99 4
Linit:	xor	eax,eax
	push	eax
	popfd
	pop	ax
d101 7
a107 1
	mov	bp,sp		/* for later (!PXE pointer) */
a108 1
	push	dx
d110 20
a129 13
	// flags 0
	// 0ax = x:Lrval noreloc
	// ecx = trash
	// edx = trash (original dx)
	// Tbx = x:offset PXENV+
	// Tsp = x:original stack usable pointer
	// Tbp = x:original stack original pointer (incl. !PXE at +4)
	// Tsi = x:offset partition table entry
	// edi = trash
	//  es = segment PXENV+
	//  cs = ?
	//  ss = ?
	//  ds = segment partition table entry
d131 1
a131 2
	/* find out current position in memory */
	lea	ecx,[eax + offset _start - offset Lrval]
d133 2
a134 5
	shl	eax,4
	lea	edx,[eax + ecx]

	// 0cx = offset _start rel. CS
	// edx = linear _start noreloc
d137 4
a140 10
	/* store away the partition and two PXE structures */
	rol	ebx,16
	mov	bx,es
	rol	ebx,16
	mov	cs:[ecx + offset pxe_plus - offset _start],ebx
	mov	ebx,ss:[bp+4]
	mov	cs:[ecx + offset pxe_bang - offset _start],ebx
	xor	ebx,ebx
	pop	bx		/* initial DX */
	cmp	byte ptr cs:[ecx + offset i386_biosflags - offset _start],0x6D
d142 3
a144 3
	push	cs
	pop	es
	lea	di,[ecx + offset bios_bootpte - offset _start]
d149 2
d152 3
a154 2
1:	shl	bx,8
	cmp	edx,0x00007C00
d156 5
a160 14
	or	ebx,0x01040000		/* PXE, do scan */
2:	mov	bl,cs:[ecx + offset Ldrvi - offset _start]
	mov	cs:[ecx + offset Ldrvi - offset _start],ebx
3:
#endif

	/* set up segments */
	mov	ax,cs
	mov	ds,ax
	mov	es,ax

#ifndef SMALL_BOOT
	/* find out if we're a DOS or SYSLINUX programme */
	cmp	cx,0x0100
d165 3
a167 1
	/* from DOS or SYSLINUX no PXE */
d169 4
a172 5
	mov	ds:[ecx + offset pxe_bang - offset _start],eax
	mov	ds:[ecx + offset pxe_plus - offset _start],eax

	push	edx
	push	ecx
d174 1
a174 1
	mov	ah,0x30		/* DOS/SYSLINUX: get DOS version */
d190 2
d206 2
a207 2
	mov	cs:[ecx + offset pxe_bang - offset _start],eax
	mov	cs:[ecx + offset pxe_plus - offset _start],eax
d209 1
a209 1
	mov	dh,4		/* probably PXE :) but do not scan */
d211 1
a211 1
	jmp	Loklx
d216 1
a216 1
	mov	cs:[ecx + offset bios_bootpte - offset _start],eax
d218 1
a218 1
	mov	cs:[ecx + offset bios_bootpte - offset _start + 4],eax
d220 1
a220 1
	mov	cs:[ecx + offset bios_bootpte - offset _start + 8],eax
d222 1
a222 1
	mov	cs:[ecx + offset bios_bootpte - offset _start + 12],eax
d228 1
a228 1
Loklx:	or	dh,2
d230 2
a231 2
	mov	dl,cs:[ecx + offset Ldrvi - offset _start]
	mov	cs:[ecx + offset Ldrvi - offset _start],edx
a232 1
	push	ecx
d236 1
a236 2
	pop	ecx
	jmp	Lokcom		/* we're done */
d241 2
d253 2
a254 2
	mov	al,cs:[bx]	/* dosdrv flag biosdrv partp */
	mov	cs:[bx],eax
d256 1
a256 1
Lokcom:
d260 1
a260 3

	pop	edx
Lnocom:
d263 2
a264 20
	cmp	edx,SA_LINKADDR
	je	LisRel

	// flags 0
	// eax = trash
	// 0cx = offset _start rel. CS (PRESERVE)
	// edx = linear _start noreloc (PRESERVE)
	// ebx = trash
	// Tsp = x:original stack usable pointer
	// ebp = trash
	// esi = trash
	// edi = trash
	//  es = trash
	//  cs = ?
	//  ss = ?
	//  ds = trash

	/* set up initial stack */
	lea	eax,[edx + offset cmd_buf + CMD_BUFF_SIZE - 4 - offset _start]
	mov	ebx,eax
d266 2
a267 9
	and	bx,0xF000	/* BX:AX = far ptr initial stack */
	and	ax,0xFFFC
	mov	ss,bx
	movzx	esp,ax

	// 0sp = bit  0..15 of istack
	//  ss = bit 16..19 of istack

	mov	si,dx
a268 3
	mov	eax,edx
	shr	eax,4
	mov	ds,ax		/* DS:SI = _start (noreloc) min. */
d270 7
a276 2
	// Tsi = _start (noreloc) bit 0..3
	//  ds = _start (noreloc) bit 4..19
d278 4
a281 6
	cmp	edx,0x30000
	jb	LdoRel
	cmp	edx,0x4FFFF
	ja	LdoRel

	/* relocate twice, ugh */
d283 1
d286 4
d292 3
d296 1
a296 6
	// ecx = trash
	//  es = 0x6000
	// location 6000:0000h

	mov	ax,es
	mov	ds,ax
d298 3
a300 1
	mov	esp,offset cmd_buf + CMD_BUFF_SIZE - 4 - offset _start
d302 1
a302 32
	// 0sp = istack rel. _start
	//  ss = 0x6000 (seg _start)
	//  ds = 0x6000

	push	ds
	mov	eax,offset LdoRel - offset _start
	push	ax
	xor	si,si

	// jump to 6000:LdoRel
	// ds:si = 6000:0000h
	// ss:sp = 6000:istack

	lret


	// flags 0
	// eax = trash
	// ecx = trash
	// edx = linear _start noreloc
	// ebx = trash
	// Tsp = some usable stack pointer
	// ebp = trash
	// Tsi = from where to move (bit 0..3)
	// edi = trash
	//  es = trash
	//  cs = ?
	//  ss = some usable stack segment outside ]30000;4FFFF]
	//  ds = from where to move (bit 4..19)
	// code position outside ]30000;4FFFF]

LdoRel:	mov	ax,SA_LINKSEG
d308 2
a309 20
	// flags 0
	// eax = trash
	// ecx = trash
	// edx = linear _start noreloc
	// ebx = trash
	// Tsp = some usable stack pointer
	// ebp = trash
	// esi = trash
	// edi = trash
	//  es = trash
	//  cs = ?
	//  ss = ?
	//  ds = trash
	// code position 4000:0000

LisRel:	xor	eax,eax
	push	eax
	popfd

	mov	ax,SA_LINKSEG
a311 3
	mov	fs,ax
	mov	gs,ax

d318 1
a318 24
Lstart:	mov	ax,0x3000
	mov	ss,ax
	mov	esp,0x0000FFFC

	// 0sp = 0x0000FFFC	final stack
	//  ss = 0x3000		final stack

	// flags 0
	// eax = 0
	// ecx = trash
	// edx = trash
	// ebx = trash
	// 0sp = ofs final stack (0x0000FFFC)
	// ebp = trash
	// esi = trash
	// edi = trash
	//  es = SA_LINKSEG
	//  cs = SA_LINKSEG
	//  ss = seg final stack (0x3000)
	//  ds = SA_LINKSEG
	//  fs = SA_LINKSEG
	//  gs = SA_LINKSEG

	call	idt_init
d358 4
a361 1
	cld
d369 1
a369 6
Lmb2rm:	mov	esp,0x0003FFFC
	xor	eax,eax
	push	eax
	popfd

	mov	edi,offset Ldrvi
d372 1
a372 1
	lodsb			/* user partition type */
d384 1
a384 1
	call	prot_to_real
@


1.58
log
@replace the OpenBSD BIOS disc I/O code with something more legible
with less overhead ;-)
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.57 2009/01/11 14:50:26 tg Exp $ */
d108 14
d123 7
a129 5
	sub	ax,offset Lrval - offset _start
	movzx	ecx,ax		/* CS:ECX = far ptr of _start noreloc */
	mov	dx,cs
	shl	edx,4
	add	dx,ax		/* EDX = linear address of _start noreloc */
a159 9
	/* set up initial stack */
	lea	eax,[edx + offset cmd_buf + CMD_BUFF_SIZE - 4 - offset _start]
	mov	ebx,eax
	shr	ebx,4
	and	bx,0xF000	/* BX:AX = far ptr initial stack */
	and	ax,0xFFFC
	mov	ss,bx
	movzx	esp,ax

a163 9
	mov	fs,ax
	mov	gs,ax

	/*-
	 * DS = ES = FS = GS	== CS
	 * CS:(E)CX = flat:EDX	== _start (noreloc)
	 * SS:ESP		== initial stack
	 * EFLAGS		== 0
	 */
d172 5
d237 1
d241 1
a268 6
	/*-
	 * CS:(E)CX = flat:EDX	== _start (noreloc)
	 * SS:ESP		== valid, initial stack
	 * EFLAGS		== valid, sane
	 */

d272 26
d304 3
d319 4
d327 7
a333 2
	push	ax
	mov	eax,offset LdoRel
d336 5
d343 16
d365 18
a382 3
LisRel:	mov	ax,0x3000
	mov	ss,ax
	mov	esp,0x0000FFFC
d387 1
a387 1
Lmb16e:	mov	fs,ax
d389 1
d391 1
a391 1
	mov	eax,offset Lstart
a392 4

	xor	eax,eax
	push	eax
	popfd
d396 24
a419 1
Lstart:	call	idt_init
d429 1
a429 1
	.code32
d489 1
a489 2
	mov	ax,SA_LINKSEG
	jmp	Lmb16e
@


1.57
log
@• only ever do PXE if “probably” booted from PXE
• disable the scan unless the startup address matches
• disable the scan, always, if called from multiboot
  (GNU GRUB 0.9x is just helpless)
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.56 2009/01/11 14:47:37 tg Exp $ */
d415 4
@


1.56
log
@hide multiboot stuff from SMALL_BOOT
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.55 2009/01/11 14:40:27 tg Exp $ */
d37 3
d68 3
d138 1
a138 1
	or	ebx,0x00040000		/* PXE */
d210 1
a210 1
	mov	dh,4		/* probably PXE :) */
d391 1
@


1.55
log
@move the pxe_command_buf to lower memory (between bounce_buf and stack),
as it's a rather large yet non-static structure

this marks the point where pxeboot(8) can/will no longer be built
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.54 2009/01/11 14:11:27 tg Exp $ */
d79 1
d91 1
d356 1
d391 1
@


1.54
log
@• fix pxeboot flagging
• attempt to preserve DL in the “machine exec sector” case
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.53 2009/01/10 20:28:27 tg Exp $ */
d400 4
@


1.53
log
@shuffle some defns around
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.52 2009/01/10 19:21:26 tg Exp $ */
d94 1
a94 2
	pop	dx

d98 1
d101 5
a105 6
	sub	dx,offset Lrval - offset _start
	movzx	ecx,dx		/* CS:ECX = far ptr of _start noreloc */
	mov	ax,cs
	shl	eax,4
	add	ax,dx
	mov	edx,eax		/* EDX = linear address of _start noreloc */
d115 2
d118 1
a118 1
	je	2f
d126 3
a128 2
	jmp	2f
1:	cmp	edx,0x00007C00
d130 4
a133 4
	mov	ebx,0x00040000
	mov	bl,cs:[ecx + offset Ldrvi - offset _start]
	mov	cs:cs:[ecx + offset Ldrvi - offset _start],ebx
2:
d137 1
a137 1
	add	eax,offset cmd_buf + CMD_BUFF_SIZE - 4 - offset _start
@


1.52
log
@set a “PXE” flag when booted at 0x00007C00 or via PXELINUX
if this is set and the passed PXENV+ or !PXE are valid, it
shall assume tftp: as default device
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.51 2009/01/10 18:15:09 tg Exp $ */
d41 3
@


1.51
log
@new loader and stuff (new bootxx too, *incompatible*!)
still not usable until biosdev/-probe rewrite though…

syslinux, dos, multiboot operation not tested yet, either
@
text
@d1 1
a1 1
/* $MirOS: src/share/misc/licence.template,v 1.28 2008/11/14 15:33:44 tg Rel $ */
d53 8
d114 1
a114 1
	je	1f
d122 7
a128 1
1:
d197 1
d218 2
a219 1
	or	cs:[ecx + offset Ldrvi - offset _start],edx
@


1.50
log
@comment out tori stuff, will be merged into biosdev access
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.49 2009/01/10 14:38:49 tg Exp $ */
d5 1
a5 1
 *	Thorsten Glaser <tg@@mirbsd.de>
a20 15
 *-
 * Initialisation code for second-stage or stand-alone boot loader.
 *
 * This code is responsible for:
 * - setting up a known environment, with no knowledge about current
 *   CPU state (except that we are in real mode and DL is the BIOS
 *   boot device)
 * - relocate ourselves to a known sane location (4000:0000h)
 * - checking if we're called from an El Torito bootable CD-ROM via
 *   the BIOS, or from a PBR, or from within MS-DOS, and take
 *   appropiate set-up action
 * - for El Torito, load in the full boot code again, as we cannot
 *   guarantee that faulty BIOSes load more than the first 2048 bytes
 * - set up some variables, load GDT, set up protected mode and
 *   jump into C code
a22 2
#include <machine/asm.h>
#include <assym.h>
d29 1
a29 41
/* It's hard to fight vs. broken BIOSes */
#ifdef	UTEST
#ifdef	UHARD
/* XXX does not work on Intel Mac with broken BIOS.EFI app */
#define	UD(x)	push bp; mov bp,(0x4040 + x); \
		gs mov [(0x0C80 + (2 * x))], bp; pop bp; \
		push ax; xor ax,ax; int 0x16; pop ax
#ifdef	UANAL
#define	UDX(x)	push bp; mov bp,(0x0940 + x); \
		gs mov [0x0C80], bp; pop bp; \
		push ax; xor ax,ax; int 0x16; pop ax
#else	/* UTEST, UHARD, not UANAL */
#define	UDX(x)	/* nothing */
#endif	/* UTEST, UHARD, not UANAL */
#else	/* UTEST, not UHARD */
#define	UD(x)	push bp; mov bp,(0x4040 + x); \
		gs mov [(0x0C80 + (2 * x))], bp; pop bp
#ifdef	UANAL
#define	UDX(x)	push bp; mov bp,(0x0940 + x); \
		gs mov [0x0C80], bp; pop bp
#else	/* UTEST, not UHARD, not UANAL */
#define	UDX(x)	/* nothing */
#endif	/* UTEST, not UHARD, not UANAL */
#endif	/* UTEST, not UHARD */
#define	UD32(x)	mov ebx,(0xB8A00 + (2 * x)); \
		mov word ptr [ebx],(0x4040 + x)
#else	/* not UTEST */
#define	UD(x)	/* nothing */
#define	UD32(x)	/* nothing */
#define	UDX(x)	/* nothing */
#endif	/* not UTEST */

	.globl	Gdtr
	.globl	_C_LABEL(_rtt)
	.globl	_rval
	.globl	_start
	.globl	_C_LABEL(bios_bootdev)
	.globl	_C_LABEL(bios_bootpte)
	.globl	_C_LABEL(boot)
	.globl	_C_LABEL(edata)
	.globl	_C_LABEL(end)
a31 1
#ifndef SMALL_BOOT
d33 10
a42 1
#endif
a44 12
	jmp	Lstart
	. = _start + 0x08	/* "EL TORITO BOOT INFO TABLE" */
	.long	0		/* #no longer# filled in by mkisofs: */
	.long	0xcafebabe	/* LBA address of boot file */
	.p2align 4
_C_LABEL(bios_bootpte):
	.long	0, 0, 0, 0
	.p2align 4
Ltblk:	.long	0x13,0,0,0	/* El Torito parameter block */
	.byte	0,0,0
	. = _start + 0x4C
Lstart:	cld
d46 94
a139 5
_rval:	.long	0x6A6D4F00	/* _start + 0x50 */
Linit:	pop	di
	mov	ax,0xB800
	mov	gs,ax		/* for UD() */
	UD(0)			/** @@: we're here */
d141 10
a150 10
	cmp	di,0x0150	/* test for .COM offset */
	jne	Ldxok
	mov	dl,0x80		/* fake HDD boot on DOS */
	/* begin SYSLINUX tests */
	cmp	word ptr cs:[0],0x20CD
	jne	Ldxok		/* no DOS PSP */
	push	gs
	push	di
	push	dx
	mov	eax,0x00003000	/* AH=30h: get DOS version */
d160 2
a164 1
	xor	cx,cx		/* ISOLINUX >= 3.73: emulation */
d166 22
a187 18
	xor	di,di		/* for later: 0=HD 1=CD 2=emul */
	cmp	al,0x31		/* 31h: SYSLINUX */
	jb	Llxok
	je	Llxdx
	cmp	al,0x34		/* 34h: EXTLINUX */
	ja	Llxok
	je	Llxdx
	cmp	al,0x33		/* 33h: ISOLINUX */
	jb	Llxok		/* 32h: PXELINUX (no drive in DL) */
	inc	di
	or	ch,ch
	jz	Llxdx		/* El Torito no emulation */
	inc	di		/* El Torito FDD/HDD emulation */
Llxdx:	pop	ax		/* we have a drive in DL */
	push	dx
	or	di,di
	jnz	Llxok		/* CD have no MBR entry */
	/* copy boot partition entry */
d189 1
a189 1
	mov	cs:[0x0150+_C_LABEL(bios_bootpte)-_rval],eax
d191 1
a191 1
	mov	cs:[0x0150+_C_LABEL(bios_bootpte)-_rval+4],eax
d193 1
a193 1
	mov	cs:[0x0150+_C_LABEL(bios_bootpte)-_rval+8],eax
d195 10
a204 2
	mov	cs:[0x0150+_C_LABEL(bios_bootpte)-_rval+12],eax
Llxok:	push	di
d206 1
a206 1
	xor	dx,dx		/* clean up everything */
d208 20
a227 15
	pop	cx
	cmp	cl,2
	jne	Lnolx		/* HDD or El Torito no emulation */
	push	cs
	pop	ds
	mov	ax,0x4B00	/* BIOS: terminate emulation */
	mov	dl,0x7F		/* ... on all drives */
	mov	si,0x0150+Ltblk-_rval
	int	0x13
Lnolx:	pop	dx
	pop	di
	pop	gs
	/* end SYSLINUX tests */
#endif
Ldxok:	xor	eax,eax
d230 12
a241 13
	UD(1)			/** A: flags set */
	mov	ax,di
	test	al,0x0F		/* test for alignment */
Lirrf:	jnz	Lirrf		/* forever loop */
	shr	ax,4
	mov	cx,cs
	add	ax,cx		/* ax:0000 is now _start+0x50 */
	mov	ecx,offset _rval - SA_LINKADDR
	shr	ecx,4
	sub	ax,cx		/* source */
	mov	ss,ax
	mov	esp,offset cmd_buf - SA_LINKADDR + CMD_BUFF_SIZE - 4
	cmp	ax,SA_LINKSEG
d243 15
a257 26
	UD(2)			/** B: relocation needed */
	cmp	ax,SA_LINKSEG - 0x1000		/* lower boundry */
	jb	Lrel2		/* below target area, relocate once */
	cmp	ax,SA_LINKSEG + 0x1000		/* upper boundary */
	ja	Lrel2		/* above target area, relocate once */
	/* within target area, relocate twice */
	UD(3)			/** C: relocate twice */
	mov	bx,SA_LINKSEG + 0x2000
	mov	es,bx		/* safe target: above */
	mov	ds,ax		/* original source */
	xor	si,si
	xor	di,di
	mov	cx,0x4000
	rep	movsd
	push	es
	mov	eax,offset Lrel1 - SA_LINKADDR
	push	ax
	mov	ax,es		/* target -> new source */
	lret
Lrel1:	mov	ss,ax
	mov	esp,offset cmd_buf - SA_LINKADDR + CMD_BUFF_SIZE - 4
Lrel2:	mov	ds,ax		/* source (original or above) */
	UD(4)			/** D: relocate once */
	mov	ax,SA_LINKSEG
	mov	es,ax		/* new target: final destination */
	xor	si,si
d259 2
a260 2
	mov	cx,0x4000
	rep	movsd
d262 4
a265 2
LisRel:	UD(5)			/** E: done reloc, or not needed */
	mov	ax,SA_LINKSEG
d267 1
a267 1
	mov	eax,offset Lmain - SA_LINKADDR
d269 1
d272 5
a276 3
/*
 * Code which can assume sane location
 */
d278 1
a278 2
Lmain:	UD(6)			/** F: jump successful */
	mov	ax,0x3000
d281 2
a282 1
	mov	ax,cs
d285 2
a286 6
	push	dx
	call	idt_init
	sti

	/* check if drive is a CD */
	xor	ax,ax
d288 1
a288 28
#ifndef SMALL_BOOT
	cmp	dl,0x88
	jae	1f
	push	dx
	mov	ah,0x41
	mov	bx,0x55aa
	int	0x13
	pop	dx
	jc	LnoCD
	cmp	bx,0xaa55
	jne	LnoCD
	or	ah,ah
	jz	LnoCD
1:	/* this may be a CD */
	mov	esi,offset Ltblk - SA_LINKADDR
	mov	byte ptr [si],0x13
	push	dx
	mov	ax,0x4B01
	int	0x13
	pop	dx
	jc	LnoCD
	cmp	byte ptr [si+2],dl
	jne	LnoCD
	test	byte ptr [si+1],0x0F
	jnz	LnoCD
	/* we have a CD in no emulation mode */
	pop	ax
	inc	ax
a289 1
#endif
d291 7
a297 1
LnoCD:
d299 2
a300 1
	UD(37)			/** e: calling the hook */
d302 1
a302 1
	mov	esi,eax
d304 1
a304 6
	UD(14)			/** N: preparing 32-bit */
	pop	dx
	shl	edx,16
	pop	dx
	mov	ebx,offset _rval - SA_LINKADDR
	mov	dh,[bx]		/* carry this over to VPAM */
d311 1
a311 6
	push	edx
#ifdef BOOTSELECT_HOOK
	push	esi
#endif
	UD32(15)		/** O: 32-bit reached */
	UD32(16)		/** P: PMM initialised */
d314 2
a315 2
	mov	ecx,offset _C_LABEL(end)
	mov	edi,offset _C_LABEL(edata)
d318 1
d322 1
d324 2
a325 3
	/* store saved hook value */
	pop	ecx
	mov	[_C_LABEL(hook_value)],ecx
a326 19
	/* store saved BIOS boot device */
	pop	eax
	mov	[_C_LABEL(userpt)],ah
	xor	edx,edx
	mov	dl,al
	push	edx
	mov	[_C_LABEL(bios_bootdev)],edx
#ifndef SMALL_BOOT
	shr	eax,16
	test	al,1
	jz	1f
//	mov	[_C_LABEL(i386_toridev)],edx
1:
#endif
	UD32(17)		/** Q: jump into C code */
	/* jump into boot loader C code */
	call	_C_LABEL(boot)
	UD32(35)		/** c: return from C code */
	jmp	_C_LABEL(_rtt)
d328 4
a331 14
#ifndef SMALL_BOOT
	/*
	 * Multiboot header and entry point
	 */
	.p2align 4
Lmbhdr:	.long	0x1BADB002		/* magic */
	.long	0x00010000		/* flags */
	.long	-0x1BADB002-0x00010000	/* checksum */
	/* the addresses are all bounced to 1 MiB */
	.long	Lmbhdr - SA_LINKADDR + 0x00100000	/* header_addr */
	.long	0x00100000				/* load_addr */
	.long	0					/* load_end_addr */
	.long	0					/* bss_end_addr */
	.long	Lmbrun - SA_LINKADDR + 0x00100000	/* entry_addr */
d333 2
d336 1
a336 8
	shr	edx,24
	mov	esp,offset cmd_buf + CMD_BUFF_SIZE - 4
	and	esp,0xFFFFFFFC
	/* relocate */
	xor	eax,eax
	push	eax
	popfd
	/* Note: GRUB does not support loading below 1 MiB */
d339 1
a339 1
	mov	ecx,0x4000		/* 64 KiB in dwords */
d344 1
a344 10
Lmb2rm:	lgdt	Gdtr
	call	prot_to_real
	.code16
	mov	ax,0xB800
	mov	gs,ax
	mov	bx,SA_LINKSEG
	push	dx
	mov	ax,bx
	add	ah,0x10
	push	ax
d348 19
a366 2
	jmp	LisRel
#endif
@


1.49
log
@move bounce buffer out of .bss section to bottom of SS
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.48 2009/01/10 14:30:44 tg Exp $ */
a83 3
#ifndef SMALL_BOOT
	.globl	_C_LABEL(i386_toridev)
#endif
d333 1
a333 1
	mov	[_C_LABEL(i386_toridev)],edx
@


1.48
log
@use cmd_buf as istack replacement (warning: smallish)
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.47 2009/01/10 13:58:57 tg Exp $ */
d400 2
a401 2
	.bss
	.globl	_C_LABEL(bounce_buf)
a402 3
	.p2align 4
_C_LABEL(bounce_buf):
	.skip	4096
@


1.47
log
@rename pmm_init into idt_init and let it run in 16 bit mode already,
so that we can use real_to_prot for the actual switch
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.46 2009/01/10 13:41:18 tg Exp $ */
d40 1
d198 1
a198 1
	mov	esp,offset istackend - SA_LINKADDR
d221 1
a221 1
	mov	esp,offset istackend - SA_LINKADDR
d317 3
d362 2
a363 1
	mov	esp,offset istackend
d393 3
a395 1
istackbeg:
d397 1
a397 2
	. = istackbeg + 512
istackend:
@


1.46
log
@new memory layout, part 1
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.45 2009/01/10 13:24:46 tg Exp $ */
d89 2
a90 1
	.globl	_ASM_LABEL(pmm_init)
d242 1
a242 1
	mov	ax,SA_LINKSEG
d244 1
a244 1
	mov	esp,offset istackend - SA_LINKADDR
d249 1
d290 1
a290 1
	push	eax
a297 3
#ifdef BOOTSELECT_HOOK
	pop	esi
#endif
d299 1
a299 10
	addr32 data32 lgdt (Gdtr - SA_LINKADDR)
	mov	ax,1
	lmsw	ax		/* switch to protected mode */
	data32 jmp 8,offset Lpmode

	/*
	 * 32-bit code in 16-bit code segment
	 * attention when adding code fragments below!
	 */

d301 1
a301 5
Lpmode:	mov	eax,0x10
	mov	ss,ax
	mov	esp,0x0003FFFC
	mov	es,ax
	mov	ds,ax
a308 1
	call	_ASM_LABEL(pmm_init)
d315 1
a315 11
	/* 1) align */
1:	test	di,3
	jz	2f
	stosb
	dec	ecx
	jnz	1b
	/* 2) rest in whole dwords, don’t care about overhang */
2:	add	ecx,3
	shr	ecx,2
	cld
	rep	stosd
a376 2
	mov	ss,bx
	mov	esp,offset istackend - SA_LINKADDR
@


1.45
log
@switch LOADADDR → LINKADDR
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.44 2009/01/10 12:12:19 tg Exp $ */
d28 1
a28 1
 * - relocate ourselves to a known sane location (0x4012:0x0000)
d313 1
a313 1
	mov	esp,0x0000FFFC
@


1.44
log
@pmm_leave is now redundant
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.43 2009/01/03 13:43:32 tg Exp $ */
d28 1
a28 1
 * - relocate ourselves to a known sane location (0x4000:0x0120)
a33 3
 * - if faulty BIOS makes problems, use the table which can be written
 *   with 'mkisofs -no-emul-boot -boot-load-size 4 -boot-info-table'
 *   into the image to locate start of the boot file; always load 64K
d230 1
a230 1
	mov	ax,SA_LOADSEG
d232 1
a232 1
	mov	eax,offset Lmain - SA_LOADADDR
d267 1
a267 1
	mov	esi,offset Ltblk - SA_LOADADDR
d294 1
a294 1
	mov	ebx,offset _rval - SA_LOADADDR
d300 1
a300 1
	addr32 data32 lgdt (Gdtr - SA_LOADADDR)
@


1.43
log
@• cut down on stack usage
• improve reliability (especially on 64K and larger reads)
• remove alloca
• nuke tori transfer buffer
by making use of a paragraph-aligned 4 KiB bounce buffer very early in
the .bss section (allocated in srt0.S, which is first in link)

XXX biosdev.c ist eine Ausgeburt an Häßlichkeit!
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.42 2009/01/02 20:55:53 tg Exp $ */
d94 1
a94 1
	.globl	_ASM_LABEL(pmm_leave)
d400 1
a400 2
	mov	ebx,offset Lmbret - SA_LINKADDR
	call	_ASM_LABEL(pmm_leave)	/* gidt.S */
d402 1
a402 1
Lmbret:	mov	ax,0xB800
@


1.42
log
@typo
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.41 2009/01/02 20:55:28 tg Exp $ */
d424 7
@


1.41
log
@remove some SYSLINUX junk
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.40 2009/01/02 20:52:28 tg Exp $ */
d173 1
a173 1
	jne	Lnolz		/* HDD or El Torito no emulation */
@


1.40
log
@use an internal 512-byte stack early on, instead of relying on
magic memory locations and the like, except for the first CALL
used to find out our location in memory, which uses the stack
provided by the bootloader
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.39 2009/01/02 16:38:36 tg Exp $ */
d152 2
a153 2
	jz	Llxdx		/* no HDD emulation */
	inc	di
d172 2
a173 1
	jcxz	Lnolx		/* HDD */
a175 3
	inc	byte ptr ds:[0x0151]
	dec	cx
	jcxz	Lnolx		/* CD, no emulation mode */
@


1.39
log
@make fdboot smaller again, by ifdeffing out the bootbuf part which
isn’t called from the ifdeffed cmd_i386.c anyway
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.38 2009/01/02 16:18:21 tg Exp $ */
d108 2
a109 4
	. = _start + 0x43
Lstart:	mov	ax,cs
	mov	ss,ax
	mov	esp,0xFFFC	/* cross fingers */
d200 2
a204 1
	mov	bx,SA_LINKSEG + 0x2000		/* stack above */
a206 1
	mov	bx,SA_LINKSEG - 0x2000		/* stack below */
a210 3
	xor	bx,bx		/* stack at very bottom */
	mov	ss,bx		/* safe stack */
	mov	sp,0xFFFC
d219 1
a219 1
	mov	eax,offset Lrel2 - SA_LINKADDR
a221 1
	mov	bx,SA_LINKSEG - 0x2000		/* stack below */
d223 2
a228 2
	mov	ss,bx		/* stack (above or below) */
	mov	sp,0xFFFC
d246 1
a246 1
	mov	ax,SA_LOADSEG + 0x1000
d248 1
a248 1
	mov	sp,0xFFFC	/* another nearly-64K for stack */
d388 1
a388 1
	mov	esp,0x00028000		/* minimal stack */
d407 1
a407 1
	mov	bx,SA_LOADSEG
d409 1
a409 1
	mov	esp,0xC0
d419 7
@


1.38
log
@add more comments
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.37 2009/01/02 07:43:23 tg Exp $ */
d93 3
d409 1
a409 1
	call	pmm_leave		/* gidt.S */
@


1.37
log
@unbreak fdboot, similar as pxeboot
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.36 2009/01/02 07:35:31 tg Exp $ */
d396 1
@


1.36
log
@clean up

(I can’t machine boot/exec into DOS, but I can machine exec into grub
and boot DOS from there, w00t but WTF?)
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.35 2009/01/02 07:26:36 tg Exp $ */
d86 1
d88 1
@


1.35
log
@double relocation code and better stack usage fix syslinux
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.34 2009/01/02 06:37:02 tg Exp $ */
a112 104

#if 1
	push	dx
	mov	ax,cs
	mov	bx,1760

	mov	dl,ah
	shr	dl,4
	mov	dh,0x20
	add	dl,0x30
	cmp	dl,0x39
	jbe	1f
	add	dl,7
1:	gs mov	[bx],dx
	add	bx,2
	shl	ax,4

	mov	dl,ah
	shr	dl,4
	mov	dh,0x20
	add	dl,0x30
	cmp	dl,0x39
	jbe	1f
	add	dl,7
1:	gs mov	[bx],dx
	add	bx,2
	shl	ax,4

	mov	dl,ah
	shr	dl,4
	mov	dh,0x20
	add	dl,0x30
	cmp	dl,0x39
	jbe	1f
	add	dl,7
1:	gs mov	[bx],dx
	add	bx,2
	shl	ax,4

	mov	dl,ah
	shr	dl,4
	mov	dh,0x20
	add	dl,0x30
	cmp	dl,0x39
	jbe	1f
	add	dl,7
1:	gs mov	[bx],dx
	add	bx,2
	shl	ax,4

	mov	dl,0x3a
	mov	dh,0x20
	gs mov	[bx],dx
	add	bx,2

	mov	ax,di

	mov	dl,ah
	shr	dl,4
	mov	dh,0x20
	add	dl,0x30
	cmp	dl,0x39
	jbe	1f
	add	dl,7
1:	gs mov	[bx],dx
	add	bx,2
	shl	ax,4

	mov	dl,ah
	shr	dl,4
	mov	dh,0x20
	add	dl,0x30
	cmp	dl,0x39
	jbe	1f
	add	dl,7
1:	gs mov	[bx],dx
	add	bx,2
	shl	ax,4

	mov	dl,ah
	shr	dl,4
	mov	dh,0x20
	add	dl,0x30
	cmp	dl,0x39
	jbe	1f
	add	dl,7
1:	gs mov	[bx],dx
	add	bx,2
	shl	ax,4

	mov	dl,ah
	shr	dl,4
	mov	dh,0x20
	add	dl,0x30
	cmp	dl,0x39
	jbe	1f
	add	dl,7
1:	gs mov	[bx],dx
	add	bx,2
	shl	ax,4

	pop	dx
#endif

d196 1
a196 1
	sub	ax,cx
d200 2
a201 2
	mov	bx,SA_LINKSEG + 0x2000
	cmp	ax,SA_LINKSEG - 0x1000
d203 2
a204 2
	mov	bx,SA_LINKSEG - 0x2000
	cmp	ax,SA_LINKSEG + 0x1000
d208 1
a208 1
	xor	bx,bx
d212 2
a213 2
	mov	es,bx		/* safe target */
	mov	ds,ax
d221 2
a222 2
	mov	ax,es
	mov	bx,SA_LINKSEG - 0x2000
d224 1
a224 1
Lrel2:	mov	ds,ax
d227 2
a228 2
	mov	es,ax
	mov	ss,bx
a235 1
	/* relocation truncation workaround */
@


1.34
log
@be more stack conservative and add some debugging code
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.33 2009/01/02 05:45:02 tg Exp $ */
a109 3
	mov	ax,cs
	mov	ss,ax
	lea	sp,[di-8]
d117 1
a117 1
	mov	bx,3040
d298 36
a333 3
	mov	cx,ax
	sub	cx,RL_VAL
	cld
d335 3
a337 23
	UD(2)			/** B: alignment okay */
	mov	bx,SA_LOADSEG
	cmp	cx,bx
	je	LisRel		/* already relocated */
	jnb	LdoRel		/* loaded above target address */
	UD(3)			/** C: below target */
	std
	dec	si		/* loaded below target addr, go backwards */
LdoRel:	UD(4)			/** D: doing reloc */
	xor	cx,cx
	dec	cx
	mov	di,si
	sub	ax,5		/* make up for stuff above _rval */
	mov	ds,ax
	add	bx,(RL_VAL) - 5	/* dito */
	mov	es,bx

	mov	bp,ax
	cmp	ax,bx
	jae	1f
	mov	bp,bx
1:	mov	ss,bp
	mov	sp,0xfffc
a338 1
	rep	movsb
a339 1
	cld
d359 1
@


1.33
log
@squish one last bug in checking for El Torito
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.32 2009/01/02 05:40:56 tg Exp $ */
d103 4
a106 5
	. = _start + 0x41
Lstart:	mov	bx,SA_LOADSEG
	mov	ss,bx
	mov	esp,0xC0
	sti
d110 3
d116 104
a226 1
	push	bx
a288 1
	pop	bx
d291 1
a291 7
Ldxok:	push	dx
	mov	ax,bx
	add	ah,0x10		/* add 64K (apparent max. code size) */
	push	ax		/* future SS */
	add	ah,0x10		/* add that 64K for a safe buffer */
	mov	fs,ax		/* for buffer I/O */
	xor	eax,eax
d306 2
a307 1
	cmp	cx,bx		/* bx is still SA_LOADSEG */
d321 8
d344 1
a344 2
	pop	ax		/* saved future stack base */
	pop	dx		/* saved BIOS drive */
@


1.32
log
@missed a .globl
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.31 2009/01/02 05:30:54 tg Exp $ */
d265 1
d268 1
d270 2
@


1.31
log
@align right
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.30 2009/01/02 05:16:33 tg Exp $ */
d86 1
@


1.30
log
@bump, regenerate, etc.
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.29 2009/01/02 04:58:40 tg Exp $ */
d322 1
a322 1
1:	test	cl,3
@


1.29
log
@remove toridev kludge and probe the bios boot device for El Torito in
no emulation mode… if so, set the flag
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.28 2009/01/02 04:27:43 tg Exp $ */
d4 1
a4 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008
a12 4
 * Advertising materials mentioning features or use of this work must
 * display the following acknowledgement:
 *	This product includes material provided by Thorsten Glaser.
 *
@


1.28
log
@more junk removals
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.27 2009/01/02 04:22:36 tg Exp $ */
a93 1
	.globl	_C_LABEL(tori_bootflag)
a105 4
	.p2align 2
_C_LABEL(tori_bootflag):
	.long	0
Lbdev:	.byte	0		/* local copy of BIOS boot device */
d247 1
a247 2
	mov	ebx,offset Lbdev - SA_LOADADDR
	mov	[bx],dl
d249 3
d253 25
a277 11
	mov	ebx,offset _rval - SA_LOADADDR
	mov	eax,[bx]
	mov	al,0		/* partp (patched in) doesn't matter */
	cmp	eax,0x6A6D4F00
	je	LpreFD
	xor	eax,eax
	dec	eax
	mov	al,dl
	mov	ebx,offset _C_LABEL(tori_bootflag) - SA_LOADADDR
	mov	[bx],eax
#endif /* !SMALL_BOOT */
d279 1
a279 1
LpreFD:	/* prepare booting */
d286 3
a288 3
	xor	edx,edx
	mov	ebx,offset Lbdev - SA_LOADADDR
	mov	dl,[bx]		/* carry this over to VPAM */
d290 1
a290 1
	mov	dh,[bx]
d342 4
a345 3
	pop	edx
	mov	[_C_LABEL(userpt)],dh
	mov	dh,0
d348 7
@


1.27
log
@remove most #ifdef stuff to make this manageable
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.26 2009/01/02 04:14:35 tg Exp $ */
d97 1
a97 1
	jmp	_star2
d100 1
a100 1
Lbofs:	.long	0xcafebabe	/* LBA address of boot file */
d112 1
a112 1
_star2:	mov	bx,SA_LOADSEG
d236 1
a236 1
	mov	eax,offset Lstart - SA_LOADADDR
d244 1
a244 1
Lstart:	UD(6)			/** F: jump successful */
a288 63
#ifdef	LOUD
	/*
	 * debugging routines for LOUD mode
	 */
LiscdM:	.ascii	"CD Drive "			/* drive no */
Liscd0:	.ascii	"00 on "			/* load seg */
Liscd1:	.ascii	"0000:0000, "			/* sectors  */
Liscd2:	.ascii	"0000 sectors starting at "	/* img offs */
Liscd3:	.asciz	"00000000 LBA\r\n"
LisfdM:	.ascii	"BIOS Drive "			/* bootdev */
Lisfd0:	.asciz	"00 initialized.\r\n"

LdebFD:	/* debug message for floppy/hdd boot */
	mov	al,[Lbdev]
	mov	di,offset Lisfd0
	call	LpBY
	mov	si,offset LisfdM
	jmp	Lotxt

#ifndef SMALL_BOOT
LdebCD:	/* debug message for El Torito boot */
	mov	di,offset Liscd0
	mov	al,[Lbdev]
	call	LpBY
	mov	di,offset Liscd1
	mov	ax,[12+Ltblk]
	call	LpWO
	mov	di,offset Liscd2
	mov	ax,[14+Ltblk]
	call	LpWO
	mov	di,offset Liscd3
	mov	eax,[4+Ltblk]
	call	LpDW
	mov	si,offset LiscdM
	jmp	Lotxt
#endif

/* the formatting routines */

LpDW:	push	eax
	shr	eax,16
	call	LpWO
	pop	eax
	/* fall-through */
LpWO:	push	ax
	xchg	ah,al
	call	LpBY
	pop	ax
	/* fall-through */
LpBY:	mov	ah,al
	and	ah,0x0F
	shr	al,4
	add	ax,0x3030
	cmp	al,0x39
	jna	4f
	add	al,7
4:	cmp	ah,0x39
	jna	5f
	add	ah,7
5:	stosw
	ret
#endif

a341 9
#ifdef	DEBUG_OFS
	. = _start + 0x0900
Lofsd:	.long	0xfeedcafe	/* just another bad magic */
#endif

	/*
	 * End of File. Attention, 32-bit mode!
	 */

@


1.26
log
@make /usr/mdec/boot aka bootbsd.com multiboot-compliant
(means: can be loaded from grub)
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.24 2009/01/01 22:23:24 tg Exp $ */
a94 3
#if 0 /* ndef SMALL_BOOT */
	.globl	_C_LABEL(tori_pblk)
#endif
a239 16
#if 0 /* ndef SMALL_BOOT */
/*
 * Stuff which MUST NOT be placed in the .bss section
 */

_C_LABEL(tori_bootflag):
	.long	0
_C_LABEL(tori_pblk):
Ltblk:	.long	0x13,0,0,0	/* El Torito parameter block */
	.byte	0,0,0
Lbdev:	.byte	0		/* local copy of BIOS boot device */
Llba:	.word	0x0010		/* LBA parameter block */
	.word	0x0001
	.long	0,0,0
#endif

a253 16
#ifdef	EXTRALOUD
	call	L..e1
	.asciz	"00 at DL\r\n"
L..e1:	mov	al,dl
	pop	si
	mov	di,si
	call	LpBY
	call	Lotxt
#endif
#ifdef	LOUD
	mov	si,offset Lsrt0
	call	Lotxt
#endif
#ifdef	DEBUG_OFS
	mov	[Lofsd],esi
#endif
d255 1
a255 3
#ifdef SMALL_BOOT
	jmp	LpreFD /* L..12 */
#else
a259 1
#if 1
a265 111
	jmp	LpreFD
#else
	jne	LfCD
#ifdef	WANT_ELTORITO_CHECK */
	/* check for El Torito */
	mov	ax,0x4B01
	mov	si,offset Ltblk
	int	0x13
#ifdef	EXTRALOUD
	pushf
	pusha
	pushf
	call	L..e2
	.ascii	"Load SPEC returned, DL = "
L..e21:	.ascii	"00; CF="
L..e22:	.ascii	"00; [SI+2]="
L..e23:	.asciz	"00\r\n"
L..e2:	xor	ax,ax
	pop	bp
	popf
	adc	al,0
	mov	di,offset L..e22
	call	LpBY
	mov	al,dl
	mov	di,offset L..e21
	call	LpBY
	mov	al,[si+2]
	mov	di,offset L..e23
	call	LpBY
	mov	si,bp
	call	Lotxt
	popa
	popf
#endif
	jc	LnoCD
	UD(7)			/** G: El Torito found */
	xor	eax,eax
	dec	eax
	mov	al,dl
	mov	[_C_LABEL(tori_bootflag)],eax

	/*
	 * now we have to find out where on the CD-ROM the bootable
	 * image is located (looking for "default" image)
	 */

	/* get boot record */
	mov	eax,0x11
	call	LcdLDS		/* loads to FS:0x0000 */
	UD(8)			/** H: boot record loaded */
	fs mov	eax,[0]
	cmp	eax,0x30444300	/* '\0CD001' magic */
	jne	LbmCD		/* bad magic CD */

	/* get boot catalogue */
	fs mov	eax,[0x47]
	call	LcdLDS
	UD(9)			/** I: boot catalogue loaded */
	fs mov	ax,[0]
	dec	ax
	jne	LbmCD
	fs mov	ax,[0x1E]
	cmp	ax,0xAA55
	jne	LbmCD
	fs mov	ax,[0x20]
	cmp	ax,0x0088	/* no emulation, default entry */
	jne	LbmCD
	fs mov	eax,[0x28]	/* address */
	UD(10)			/** J: boot image found, no fake */
#else	/* not WANT_ELTORITO_CHECK */
	jmp	LnoCD
#endif	/* not def WANT_ELTORITO_CHECK */

LisCD:	mov	bx,SA_LINKSEG	/* target segment */
	inc	eax		/* don't load the first sector again */
	add	bx,0x80		/* 2048 bytes in paragraphs */
	UDX(2)
	mov	byte ptr [2+Llba],31	/* we don't load more anyways */
	push	fs
	mov	fs,bx
	call	LcdLDS
	UDX(3)
	pop	fs
	UD(11)			/** K: boot image loaded */
#ifdef	DEBUG_OFS
	mov	eax,[Lofsd]
	cmp	eax,0xfeedcafe
	je	L..37
	UD(37)			/** e: magic check failed */
#ifdef	LOUD
	call	L..37a
	.asciz	"Load magic failed!\r\nPress a key to reboot..."
L..37a:	pop	si
	call	Lotxt
#endif
L..37l:	mov	ah,1
	int	0x16
	jz	L..37l		/* crude hack for Intel Mac */
	mov	ah,0		/* ACK the key for the PIC */
	int	0x16
	jmp	0xF000,0xFFF0

#endif
L..37:	jmp	LpreCD		/* prepare boot from CD */

LfCD:	xor	eax,eax
	dec	eax
	mov	al,dl
	mov	[_C_LABEL(tori_bootflag)],eax
	jmp	LpreFD
#endif /* 0 */
a267 128
#ifdef	LOUD
Lotxt:	lodsb
	or	al,al
	je	Lretn
	mov	ah,0x0E
	mov	bx,7
	int	0x10
	jmp	Lotxt

Lsrt0:	.ascii	"MirOS boot v"
	.ascii	__BOOT_VER
	.asciz	" srt0 initialising\r\n"
#endif

#ifndef SMALL_BOOT
#if 0
LcdLDS:	pusha
	push	eax
	UDX(4)
#ifdef	EXTRALOUD
	pusha
	call	L..e3
	.ascii	"called LDS at LBA="
L..e31:	.ascii	"00000000 DL="
L..e32:	.ascii	"00 #="
L..e33:	.asciz	"0000 "
L..e3:	mov	di,offset L..e31
	call	LpDW
	mov	al,dl
	pop	si
	mov	di,offset L..e32
	call	LpBY
	mov	di,offset L..e33
	mov	ax,[2+Llba]
	call	LpWO
	call	Lotxt
	popa
	pop	eax
	push	eax
#endif
	xor	bp,bp
	mov	[8+Llba],eax	/* block number */
	mov	ax,fs
	mov	[6+Llba],ax	/* transfer address */
LcdLD0:	mov	ah,0x42
	mov	si,offset Llba
	int	0x13
#ifdef	UANAL
	pushf
	UDX(5)
	popf
#endif
	jc	LcdLD1
	UDX(6)
	pop	eax
	popa
Lretn:	ret
LcdLD1:	pusha
	UDX(33)
	xor	ah,ah
	int	0x13
	mov	ax,0x0E40
	mov	bx,7
	int	0x10
	popa
	inc	bp
	cmp	bp,5
	jb	LcdLD0
	UDX(34)
	UD(33)			/** a: CD read failed */
	/* FALL-THROUGH */

LbmCD:	UD(34)			/** b: CD bad magic */
#ifdef	LOUD
	call	L..34
	.asciz	"Bad Magic reading from CD\r\n"
L..34:	pop	si
	call	Lotxt
#endif
	xor	eax,eax		/* reset to default floppy boot */
	mov	[_C_LABEL(tori_bootflag)],eax
	/* FALL-THROUGH */

LnoCD:	mov	ebp,0xcafebabe	/* kludge! */
	mov	eax,ebp
	xchg	eax,[Lbofs]	/* only once */
	cmp	eax,ebp
	je	L..12
	push	eax
	UD(36)			/** d: attention fake torito */
#ifdef	LOUD
	call	L..36
	.asciz	"Attention: faking El Torito boot!\r\n"
L..36:	pop	si
	call	Lotxt
#endif
	UDX(1)
	mov	dl,[Lbdev]
	xor	eax,eax
	dec	eax
	mov	al,dl
	mov	[_C_LABEL(tori_bootflag)],eax
	mov	[2+Ltblk],al
	mov	ax,0x07C0
	mov	[12+Ltblk],ax
	mov	ax,32
	mov	[14+Ltblk],ax
	pop	eax
	mov	[4+Ltblk],eax
	jmp	LisCD		/* and be it the devil */
#endif /* !SMALL_BOOT */

	/* "real" floppy boot */
L..12:	UD(12)			/** L: floppy boot */
#ifdef	LOUD
	call	LdebFD		/* debug msgs */
#endif
	jmp	LpreFD

#ifndef SMALL_BOOT
LpreCD:	UD(13)			/** M: cd-rom boot */
#ifdef	LOUD
	call	LdebCD		/* debug msgs */
#endif
	/* FALL-THROUGH */
#endif
#endif /* 0 */

@


1.25
log
@optimise
@
text
@d690 48
@


1.24
log
@use more sensible .bss zeroing
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.23 2009/01/01 19:13:32 tg Exp $ */
d209 1
a209 1
	and	ax,0x000F	/* test for alignment */
a210 1
	mov	ax,di
@


1.23
log
@get rid of relocational truncations
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.22 2009/01/01 17:46:19 tg Exp $ */
d655 8
a662 1
	push	ecx
a665 3
	pop	ecx
	and	ecx,0x00000003
	rep	stosb
@


1.22
log
@rename uint32_t bios_bootpart[2] into uint32_t bios_bootpte[4]
and preserve the whole partition record (table entry)
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.21 2008/12/31 16:38:36 tg Exp $ */
d190 1
a190 1
	mov	si,offset Ltblk
d237 6
a242 1
	jmp	SA_LOADSEG,offset Lstart
d272 2
a273 1
	mov	[Lbdev],dl
d294 2
a295 1
	mov	eax,[_rval]
d303 2
a304 1
	mov	[_C_LABEL(tori_bootflag)],eax
d554 4
a557 2
	mov	dl,[Lbdev]	/* carry this over to VPAM */
	mov	dh,[_rval]
@


1.21
log
@shrink fdboot, nuke unused junk
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.20 2008/12/28 22:19:07 tg Exp $ */
d89 1
a89 1
	.globl	_C_LABEL(bios_bootpart)
d104 3
a106 8
Lbdev:	.byte	0		/* local copy of BIOS boot device */
#ifndef SMALL_BOOT
_C_LABEL(tori_bootflag):
	.long	0
	.p2align 2
_C_LABEL(bios_bootpart):
Lbbpo:	.long	0
Lbbps:	.long	0
d110 4
a113 1
#endif
d168 5
d174 1
a174 1
	mov	cs:[0x0150+Lbbpo-_rval],eax
d176 1
a176 1
	mov	cs:[0x0150+Lbbps-_rval],eax
@


1.20
log
@fix a simple off-by-0x0100 error (the other one), to make CD boot work
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.19 2008/12/28 20:16:19 tg Exp $ */
d102 1
a102 1
	.long	0		/* filled in by mkisofs: */
a103 1
#if 1 /* def SMALL_BOOT */
d105 1
a107 1
#endif
a111 1
#ifndef SMALL_BOOT
@


1.19
log
@fill in the bios_bootpart array with partition info from DS:SI, if lucky
(SYSLINUX only, we don’t care about our PBR since we assume it has a label)
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.18 2008/12/28 19:04:31 tg Exp $ */
d184 1
a184 1
	inc	byte ptr [_rval + 1]
@


1.18
log
@new two-long array bios_bootpart[]
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.17 2008/12/28 17:32:18 tg Exp $ */
d109 1
d111 2
a112 1
	.long	0, 0
d170 6
@


1.17
log
@make /usr/mdec/boot into a SYSLINUX module called “boot.com”
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.16 2008/12/28 16:18:08 tg Exp $ */
d89 1
d109 2
@


1.16
log
@kludge for MS-DOS boot: fake HDD boot by forcing DL to 80h
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.15 2008/12/28 16:12:10 tg Exp $ */
d108 5
d124 1
d128 58
@


1.15
log
@• if a partition type is patched in, don’t botch the comparision
• micro-optimise an add;sub sequence while here
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.14 2008/08/05 19:07:46 tg Exp $ */
d108 1
a108 1
	. = _start + 0x40
a112 1
	push	dx
d119 4
@


1.14
log
@unbreak
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.13 2008/08/05 19:05:01 tg Exp $ */
d153 1
a153 2
	add	bx,RL_VAL
	sub	bx,5		/* dito */
d210 1
@


1.13
log
@comment out ☺ enough code to make this actually work
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.12 2008/08/05 17:57:07 tg Exp $ */
d208 1
a208 1
	jmp	L..12
@


1.12
log
@hack: if bootloader is passed some magic, assume new-style soon-to-be
El Torito sorta boot

I’m doing this now since I don’t want this to wait for the other changes
required in the bootloading process… it’ll take long to get right

hacked in Chaostreff Basel, Muttenz, .ch, with bsiegert@@ sitting next to me
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.11 2007/03/18 02:45:52 tg Exp $ */
d4 1
a4 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007
d94 1
a94 1
#ifndef SMALL_BOOT
d103 1
a103 1
#ifdef SMALL_BOOT
d161 1
a161 1
#ifndef SMALL_BOOT
d212 8
d221 1
a221 2

#ifdef	WANT_ELTORITO_CHECK
a290 6
LfCD:	xor	eax,eax
	dec	eax
	mov	al,dl
	mov	[_C_LABEL(tori_bootflag)],eax
	jmp	LpreFD

d319 1
d322 7
d346 1
d457 1
@


1.11
log
@more Intel Mac stuff (done for now)
@
text
@d1 1
a1 1
/* $MirOS: src/share/misc/licence.template,v 1.20 2006/12/11 21:04:56 tg Rel $ */
d210 4
d284 6
@


1.10
log
@mostly administrative licence sync w/ current template
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.9 2006/08/19 14:20:28 tg Exp $ */
d4 1
a4 1
 * Copyright (c) 2003, 2004, 2005, 2006
d55 1
d302 4
a305 1
	xor	ax,ax
@


1.9
log
@attempt to shrink fdboot even more
@
text
@d1 1
a1 1
/* $MirOS: src/share/misc/licence.template,v 1.14 2006/08/09 19:35:23 tg Rel $ */
d7 5
a11 6
 * Licensee is hereby permitted to deal in this work without restric-
 * tion, including unlimited rights to use, publicly perform, modify,
 * merge, distribute, sell, give away or sublicence, provided all co-
 * pyright notices above, these terms and the disclaimer are retained
 * in all redistributions or reproduced in accompanying documentation
 * or other materials provided with binary redistributions.
d17 8
a24 8
 * Licensor offers the work "AS IS" and WITHOUT WARRANTY of any kind,
 * express, or implied, to the maximum extent permitted by applicable
 * law, without malicious intent or gross negligence; in no event may
 * licensor, an author or contributor be held liable for any indirect
 * or other damage, or direct damage except proven a consequence of a
 * direct error of said person and intended use of this work, loss or
 * other issues arising in any way out of its use, even if advised of
 * the possibility of such damage or existence of a defect.
@


1.8
log
@save us almost 3 kB of code on the boot floppy
which won't ever be used as "no emulation" image
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.7 2006/04/10 20:54:46 tg Exp $ */
d14 2
a15 2
 * All advertising materials mentioning features or use of this soft-
 * ware must display the following acknowledgement:
d25 1
a25 1
 * the possibility of such damage or existence of a nontrivial bug.
d33 1
a33 1
 * - relocate ourselfes to a known sane location (0x4000:0x0120)
a92 1
#ifndef FFS_ONLY
d94 1
d103 5
d161 1
a165 1
#ifndef FFS_ONLY
a174 2
#else
Lbdev:	.byte	0		/* local copy of BIOS boot device */
d207 1
a207 1
#ifdef FFS_ONLY
d307 1
a307 1
#endif /* !FFS_ONLY */
d323 1
a323 1
#ifndef FFS_ONLY
d418 1
a418 1
#endif /* !FFS_ONLY */
d427 1
a427 1
#ifndef FFS_ONLY
d473 1
a473 1
#ifndef FFS_ONLY
@


1.7
log
@remove superfluous code
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.6 2006/04/10 19:11:52 tg Exp $ */
d93 1
d96 1
d160 1
d170 3
d204 3
d304 1
d320 1
d415 1
d424 1
d430 1
d470 1
d486 1
@


1.6
log
@disable debugging code now not needed
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.5 2006/04/10 19:10:50 tg Exp $ */
a420 1
	xor	eax,eax
a422 5
#if 0
	add	ax,0x4030
		gs mov [(0x0C86)], ax; \
		push ax; xor ax,ax; int 0x16; pop ax
#endif
a533 5
#if 0
	mov ebx,(0xB8C88); \
	add	cx,0x4030
		mov word ptr [ebx],cx
#endif
@


1.5
log
@fix hook stuff, enable liveboot
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.4 2006/04/05 22:12:17 tg Exp $ */
d424 1
a424 1
#if 1
d540 1
a540 1
#if 1
@


1.4
log
@add the ability to hook something into the (CD) boot loader,
and select a different 'boot.cfg' file (boot.%d) based upon it
@
text
@d1 1
a1 1
/* $MirOS: src/share/misc/licence.template,v 1.6 2006/01/24 22:24:02 tg Rel $ */
d424 5
d517 1
a520 1
	push	edx
d536 10
a551 4
#ifdef BOOTSELECT_HOOK
	pop	ecx
	mov	[_C_LABEL(hook_value)],ecx
#endif
@


1.3
log
@implement "user partition type" in the bootloader
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/boot/srt0.S,v 1.2 2005/03/06 21:27:03 tg Exp $ */
d4 2
a5 2
 * Copyright (c) 2003, 2004, 2005
 *	Thorsten "mirabile" Glaser <tg@@66h.42h.de>
d419 6
d429 3
d512 3
d537 4
@


1.2
log
@* merge src/sys/
  (at least the better part of it)
* revert IPv6 networking to OpenBSD, since
  I didn't get IPV4_MAPPED addresses working :(
@
text
@d1 1
a1 1
/* $MirOS: src/share/misc/licence.template,v 1.2 2005/03/03 19:43:30 tg Rel $ */
d4 1
a4 1
 * Copyright (c) 2003, 2004
d18 8
a25 7
 * Licensor hereby provides this work "AS IS" and WITHOUT WARRANTY of
 * any kind, expressed or implied, to the maximum extent permitted by
 * applicable law, but with the warranty of being written without ma-
 * licious intent or gross negligence; in no event shall licensor, an
 * author or contributor be held liable for any damage, direct, indi-
 * rect or other, however caused, arising in any way out of the usage
 * of this work, even if advised of the possibility of such damage.
d108 1
a108 1
_rval:	.ascii	"\03Omi"	/* _start + 0x50 */
d422 1
d520 4
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: srt0.S,v 1.14 2003/11/22 09:18:25 grange Exp $	*/
d3 10
a12 3
/*
 * Copyright (c) 1997 Michael Shalayeff
 * All rights reserved.
d14 3
a16 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
d18 9
a26 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d28 15
d44 1
d48 3
a50 1
#define BOOTSTACK 0xfffc
d52 32
a83 3
	.globl	_C_LABEL(end)
	.globl	_C_LABEL(edata)
	.globl	_C_LABEL(boot)
d85 2
d88 3
d92 318
a409 1
	.globl	Gdtr
d411 3
a413 10
	.text
	.code16
	.globl	_start
_start:
	popl %eax
	cmpl $BOOTMAGIC, %eax
	je	1f
#ifdef DEBUG
	movl	$0xb80a0, %ebx
	addr32 movl $0x07420742, (%ebx)
d415 6
a420 2
1:
	popl %edx
d422 71
a492 8
	pushl	%cs
	popl	%ds
	addr32 data32 lgdt	(Gdtr - LINKADDR)
	movl	%cr0, %eax
	orl $CR0_PE, %eax
	data32 movl %eax, %cr0
	data32 ljmp $8, $1f
1:
d494 9
a502 11
	movl	$0x10,%eax
	mov	%ax,%ds
	mov	%ax,%ss
	mov	%ax,%es
	mov	%ax,%fs
	mov	%ax,%gs
	movl	$BOOTSTACK,%esp
	pushl	%edx
	movl	%edx, _C_LABEL(bios_bootdev)

	/* Now do it all */
d504 8
a511 9
#ifdef DEBUG
	movl	$0xb80a4, %ebx
	movl	$0x07520752, (%ebx)
#endif
	/* zero .bss */
	xorl	%eax, %eax
	movl	$_C_LABEL(end), %ecx
	subl	$_C_LABEL(edata),%ecx
	movl	$_C_LABEL(edata), %edi
d513 8
a520 2
	rep;	stosb

d522 2
d525 4
a528 1
	jmp	_C_LABEL(_rtt)
d530 3
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@
