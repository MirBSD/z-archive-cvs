head	1.14;
access;
symbols
	tg-use_ldscript:1.13.0.2
	MIRBSD_10:1.6.0.2
	MIRBSD_10_BASE:1.6;
locks; strict;
comment	@# @;


1.14
date	2014.10.18.12.09.59;	author tg;	state Exp;
branches;
next	1.13;
commitid	1005442587954325DC4;

1.13
date	2009.03.04.10.50.28;	author tg;	state Exp;
branches;
next	1.12;
commitid	10049AE5CF60B3CDCB8;

1.12
date	2009.01.31.23.39.55;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004984E12E32956022;

1.11
date	2009.01.31.18.50.07;	author tg;	state Exp;
branches;
next	1.10;
commitid	10049849D6E1D2BFC97;

1.10
date	2009.01.31.15.50.44;	author tg;	state Exp;
branches;
next	1.9;
commitid	100498472F85954CA8E;

1.9
date	2009.01.17.11.21.51;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004971BECB121B12BB;

1.8
date	2009.01.02.05.16.34;	author tg;	state Exp;
branches;
next	1.7;
commitid	100495DA33F62ABDC14;

1.7
date	2008.12.28.20.15.23;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004957DE6019224611;

1.6
date	2007.03.18.02.29.58;	author tg;	state Exp;
branches;
next	1.5;
commitid	10045FCA3DA0D22D284;

1.5
date	2007.02.26.17.07.19;	author tg;	state Exp;
branches;
next	1.4;
commitid	10045E313DA26662F20;

1.4
date	2007.02.26.02.11.33;	author tg;	state Exp;
branches;
next	1.3;
commitid	10045E241DC524D9D5F;

1.3
date	2007.02.26.01.51.46;	author tg;	state Exp;
branches;
next	1.2;
commitid	10045E23D490C2785F8;

1.2
date	2007.02.26.01.46.49;	author tg;	state Exp;
branches;
next	1.1;
commitid	10045E23C2031C2A1D9;

1.1
date	2007.02.26.00.13.27;	author tg;	state Exp;
branches;
next	;
commitid	10045E226230C5AAABC;


desc
@@


1.14
log
@add/enhance comments from some further research (beyond MS-DOS®) reading
http://homepage.ntlworld.com/jonathan.deboynepollard/FGA/pcat-boot-process.html
@
text
@/* $MirOS: src/sys/arch/i386/stand/mbr/mbr.S,v 1.13 2009/03/04 10:50:28 tg Exp $ */

/*-
 * Copyright (c) 2009, 2014
 *	Thorsten “mirabilos” Glaser <tg@@mirbsd.org>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 *-
 * Compile commands:
 *	$ gcc -D_ASM_SOURCE -DBOOTMANAGER -D__BOOT_VER=\"0AA6\" -c mbr.S
 *	$ ld -nostdlib -Ttext 0x0600 -N -Bstatic -e _start -o mbrmgr.elf mbr.o
 *	$ objcopy -O binary mbrmgr.elf mbrmgr
 *	$ gcc -D_ASM_SOURCE -DBOOT_QUIET -D__BOOT_VER=\"0AA6\" -c mbr.S
 *	$ ld -nostdlib -Ttext 0x0600 -N -Bstatic -e _start -o mbrldr.elf mbr.o
 *	$ objcopy -O binary mbrldr.elf mbrldr
 *-
 * Known bugs:
 * + Relocation is to 0000:0600 but advice is to use 7C00‥FFFF as
 *   scratchpad; also, only 64 KiB RAM can be assumed (and no 386,
 *   but we control the environment for this to be a requirement)
 * + ES:DI must be preserved, always
 * + (not a bug) we set DL instead of relying on the BIOS
 * + DH should be zero
 */

	.intel_syntax noprefix
	.code16
	.text

	.globl	_start
_start:	xor	eax,eax
	mov	ss,ax
	mov	sp,offset Lstack
	push	eax
	popfd
	mov	ds,ax
	mov	es,ax
	mov	si,offset Lbadr
	mov	di,offset _start
	mov	cx,0x0200	/* size of one sector */
	push	si		/* load / return address */
	push	ax
	push	offset Lmain
	rep	movsb
	lret

	/* entry message */
Lemsg:	.ascii	"Mir-"
	.ascii	__BOOT_VER
#ifdef BOOTMANAGER
	/* Lem<nn> are patch points */
	.ascii	": 0="
Lem00:	.ascii	"00 1="
Lem01:	.ascii	"00 2="
Lem02:	.ascii	"00 3="
Lem03:	.ascii	"00 4=hd0 5=fd0  Enter=default (timeout)\r\n"
#endif
	.asciz	">"

	/* failure message */
Lfmsg:	.asciz	"bad magic\r\n"

#if 1
	/* okay boot message */
Lbmsg:	.asciz	" OK\r"
#endif

	/* output NUL-terminated string from ds:si */
Lotxt0:	mov	ah,0x0E
	mov	bx,7
	int	0x10
Lotxt:	lodsb
	or	al,al
	jnz	Lotxt0
	ret

Lmain:	sti
#ifdef BOOTMANAGER
	/* patch the partition type values into the message */
	mov	di,offset Lem00
	mov	al,ds:[Lptab + 0x04]
	call	LpBY
	mov	di,offset Lem01
	mov	al,ds:[Lptab + 0x14]
	call	LpBY
	mov	di,offset Lem02
	mov	al,ds:[Lptab + 0x24]
	call	LpBY
	mov	di,offset Lem03
	mov	al,ds:[Lptab + 0x34]
	call	LpBY
#endif
#if !defined(BOOT_QUIET) || defined(BOOTMANAGER)
	mov	si,offset Lemsg
	call	Lotxt
#endif

	/* fake invalid partition entry for MBR/FDD boot */
	mov	di,offset Lptab + 0x40
	xor	eax,eax
	stosw
	inc	ax
	stosw
	dec	ax
	stosd
	stosd

	/* force bad magic if sector load fails */
	mov	ds:[Lbmag],al

#ifdef BOOTMANAGER
#if 0 /* see above, eax is already zero here */
	xor	ax,ax		/* read CMOS clock ticks since midnight */
#endif
	int	0x1A		/* 32-bit result in cx:dx */
	mov	di,cx		/* save it in edi for later */
	shl	edi,16
	mov	di,dx
	add	edi,183		/* 10 seconds, rounded up one tick */
	Lptmo = . - 4		/* offset of the "183" above */

	/* input loop with timeout */
Lwkey:	mov	ah,1
	int	0x16		/* check if a key was pressed */
	jnz	Lgkey		/* yeap */
	/* delay loop */
	xor	ax,ax
	int	0x1A
	shl	ecx,16
	mov	cx,dx
	or	al,al		/* past midnight? */
	jz	Lsday		/* no */
	add	ecx,1573040	/* should be 1572480, but according to RBIL… */
Lsday:	cmp	ecx,edi		/* time is over? */
	mov	al,13
	ja	Lfkey		/* yep, fake a return keypress */
	jmp	Lwkey

	/* input loop without timeout */
Lgkey:	mov	ah,1
	int	0x16		/* check if a key was pressed */
	jz	Lgkey
	mov	ah,0
	int	0x16
#endif /* BOOTMANAGER */
Lfkey:	mov	bx,offset Lptab
	mov	dl,0x80		/* drive to load from */
#ifndef BOOTMANAGER
	jmp	Lscan
#else
	sub	al,13
	je	Lscan		/* CR / Return / Enter */
	jb	Lgkey		/* invalid input */
	sub	al,('0' - 13)
	jb	Lgkey		/* invalid input */
	cmp	al,5		/* floppy */
	ja	Lgkey		/* invalid input */
	jb	LdoHD		/* hard disc */
	mov	dl,0		/* drive to load from */
	dec	ax		/* 5 -> 4 */
#endif
LdoHD:	shl	al,4		/* 0..4 where 4 is virtual partition */
	add	bl,al		/* we boot this one */
	jmp	Lboot

	/* scan the partition table for an active partition */
Lscan:	mov	al,[dpart]	/* try hard-coded by fdisk(8) 'fdef' first */
	cmp	al,3
	jbe	LdoHD
Lspar:	cmp	byte ptr [bx],0x80
	je	Lboot		/* found an active partition */
	add	bl,0x10
	cmp	bl,0xFE		/* BX = 0x07FE = Lptab + 0x40 */
	jb	Lspar
	/* boot the virtual partition #4 (MBR) */

Lboot:	/* try to boot, first LBA (we're on a HDD) then CHS */
	mov	[bx],dl		/* drive (0x80 or 0x00) */
	mov	si,offset Lpblk	/* LBA parameter block */
	mov	di,si
	mov	ax,0x0010
	stosw			/* size of LBA parameter block */
	mov	al,1
	stosw			/* number of sectors to load */
	pop	ax
	push	ax
	push	bx
	stosw			/* load address offset */
	xor	ax,ax
	stosw			/* load address segment */
	mov	eax,[bx+8]
	stosd			/* LBA offset of start sector (low 32 bit) */
	xor	ax,ax
	stosw			/* high 32 bit */
	stosw			/* high 32 bit */
	mov	ah,0x42		/* LBA extended read */
	call	Lload		/* try to boot that */
	pop	si		/* edited partition table entry */
	pop	bx		/* load offset (ES=CS=SS=DS=0000h) */
	push	bx
	push	si
	mov	ax,0x0201	/* CHS read 0x01 sectors */
	mov	cx,[si+2]	/* cylinder; sector number */
	mov	dx,[si]		/* head; drive number */
	call	Lload
	mov	si,offset Lfmsg
	call	Lotxt
#if 0
Lfail:	jmp	Lfail
#else
	xor	ax,ax
	int	0x16
	ljmp	0xF000,0xFFF0
#endif

Lload:	mov	bp,4		/* number of tries */
Lldlp:	pusha
	int	0x13
	popa
	jc	Lldre		/* error, try again */
	cmp	word ptr ds:[Lbmag],0xAA55
	jne	Lldre		/* bad magic, try again */
#if 0
	mov	ax,0x0E0D	/* output a carriage return */
	xor	bx,bx
	int	0x10
#else
	mov	si,offset Lbmsg
	call	Lotxt
#endif
	pop	si		/* Lload return address */
	pop	si		/* partition table entry */
	mov	dl,[si]
	/* EAX must not be 0x54504721 (ensured by Lotxt) */
	/* DL is set; DH should be zero (but isn’t) */
	/* DS:SI point to partition table entry, actually used by some */
	cli			/* be nice :) */
	ret			/* jump to 0000:7C00h */
Lldre:	pusha
	xor	ax,ax		/* reset drive */
	int	0x13
	popa
	dec	bp		/* another try left? */
	jnz	Lldlp
	ret

#ifdef BOOTMANAGER
LpBY:	mov	ah,al
	shr	al,4
	and	ah,0x0F
	add	ax,0x3030
	cmp	al,0x39
	jbe	LpBY1
	add	al,7
LpBY1:	cmp	ah,0x39
	jbe	LpBY2
	add	ah,7
LpBY2:	stosw
	ret
#endif

	. = _start + 0x01B7
	.globl	dpart
	.size	dpart,1
dpart:	.byte	0xFF		/* default partition [0..3] or none */

	. = _start + 0x01B8
Lntid:	.long	0		/* Microsoft® NT® volume identifier */
Lpad1:	.byte	0, 0

	. = _start + 0x01BE
	/* partition table */
Lptab:	.long	0, 0, 0, 0	/* partition entry #0 */
	.long	0, 0, 0, 0	/* partition entry #1 */
	.long	0, 0, 0, 0	/* partition entry #2 */
	/* partition entry #3 + pre-installation hint */
	.word	0, 0, 0, 0, 0
	. = _start + 0x01F8
	.size	Lhint,2
#ifdef BOOTMANAGER
Lhint:	.word	(Lptmo - _start)
#else
Lhint:	.word	0xFFFF
#endif
Lpad2:	.word	0, 0

	. = _start + 0x01FE
Lpmag:	.word	0xAA55		/* BIOS boot magic */

	Lstack = 0x4000
	Lpblk = 0x5000

	Lbadr = 0x7C00
	Lbmag = Lbadr + 0x01FE
@


1.13
log
@for mika: #ifdef BOOT_QUIET, do not echo anything, behave as simple loader
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/mbr/mbr.S,v 1.12 2009/01/31 23:39:55 tg Exp $ */
d4 2
a5 2
 * Copyright (c) 2009
 *	Thorsten Glaser <tg@@mirbsd.org>
d29 8
d247 3
a249 1
	/* DS:SI point to partition table entry, DL is set */
@


1.12
log
@easier compilation/linkage process; no binary change
inspired by bootxx, but still looking somewhat awkward
(it’s much easier with gas, ld & co. when starting at 0)

fun though, both MBR and PBR code shrunk during the rewrite…
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/mbr/mbr.S,v 1.11 2009/01/31 18:50:07 tg Exp $ */
d26 3
d98 1
d101 1
@


1.11
log
@do not take two on one line, it makes trouble sometimes
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/mbr/mbr.S,v 1.10 2009/01/31 15:50:44 tg Exp $ */
d24 2
a25 3
 *	$ ld -nostdlib -Ttext 0 -N -Bstatic -o mbrmgr.elf mbr.o
 *	$ objcopy -O binary mbrmgr.elf mbrmgr.tmp
 *	$ dd if=mbrmgr.tmp bs=1 skip=0x0600 of=mbrmgr
a31 1
	. = 0x0600
@


1.10
log
@completely (almost) rewritten MBR to address the Parallels Desktop bug

current agenda is to have robust tools doing one-sector-at-a-time xfer
automatically if no manual way to enable them exists, and simply using
LBA xfers if talking to a hdd or CD by default without checking for it
to be supported by the BIOS, falling back to CHS if failing ONLY
@
text
@d1 1
a1 1
/* $MirOS: src/share/misc/licence.template,v 1.28 2008/11/14 15:33:44 tg Rel $ */
d52 2
a53 1
Lemsg:	.ascii	"Mir-" __BOOT_VER
@


1.9
log
@• we do not use spaces after commas in assembly, even in .size pseudo-ops
• restore the use of [GL][DT]ENTRY in bootxx and make it not depend on
  <machine/asm.h> in mbr
• add comments

Prompted by mika@@grml
@
text
@d4 1
a4 1
 * Copyright (c) 2004, 2005, 2007, 2008, 2009
d23 4
a26 3
 *	$ gcc -D_ASM_SOURCE -DBOOTMANAGER -D__BOOT_VER=\"0AA5\" -c mbr.S
 *	$ ld -nostdlib -Ttext 0 -N -Bstatic --oformat binary mbr.o -o mbrmgr
 * __BOOT_VER must be a string of max. 4 bytes (there simply is no more space)
a28 11
/* we somewhat assume ELF binutils with this, others might work... */
#define _ASM_LABEL(x)	x
#define FTYPE(x)	.type x,@@function
#define OTYPE(x)	.type x,@@object

#define LDENTRY(x)	OTYPE(_ASM_LABEL(x)); _ASM_LABEL(x):
#define LTENTRY(x)	FTYPE(_ASM_LABEL(x)); _ASM_LABEL(x):
#define GDENTRY(x)	.globl _ASM_LABEL(x); LDENTRY(x)
#define GTENTRY(x)	.globl _ASM_LABEL(x); LTENTRY(x)

/* ... as long as they do Intel syntax (since 1999 or earlier) */
d33 5
a37 2
GTENTRY(_start)
	xor	eax,eax
a39 8
	/* set up stack from 07A0:FFFC (0x179FC) down */
	add	ax,0x07A0
	mov	ss,ax
	mov	sp,0xFFFC
	sti
	push	ax		/* for retf */
	push	offset Lmain
	/* set up code and data at 07A0:0000 (0x07A00) = 0000:7A00 up */
d42 6
a47 4
	/* move ourselves just below 0x07C00 target load address */
	mov	si,0x0200
	xor	di,di
	mov	cx,si
a48 1
	/* jump to 'cs:offset Lmain' */
d52 1
a52 2
LDENTRY(Lmsg)
	.ascii	"Mir-" __BOOT_VER
d54 1
a54 1
	/* Lm<nn> are patch points */
d56 4
a59 8
LDENTRY(Lm00)
	.ascii	"00 1="
LDENTRY(Lm01)
	.ascii	"00 2="
LDENTRY(Lm02)
	.ascii	"00 3="
LDENTRY(Lm03)
	.ascii	"00 4=MBR 5=fdd CR=std\r\n"
d63 7
a69 3
	/* message that we cannot boot correctly */
LDENTRY(Lmsgf)
	.asciz	"bad magic\r\n"
d80 1
a80 1
Lmain:	mov	si,offset Lmsg
d83 2
a84 2
	mov	di,offset Lm00
	mov	al,ds:[0x01C2]
d86 2
a87 2
	mov	di,offset Lm01
	mov	al,ds:[0x01D2]
d89 2
a90 2
	mov	di,offset Lm02
	mov	al,ds:[0x01E2]
d92 2
a93 2
	mov	di,offset Lm03
	mov	al,ds:[0x01F2]
d96 1
d98 16
a113 5
#ifndef BOOTMANAGER
	mov	bx,offset Lptab	/* we boot "this one" */
#define Lkeyp	Labend
#else
	/* selection code */
d115 1
d119 1
a119 3
	mov	di,dx		/* 32-bit result in edi */
	.size	Ltimeout,4
OTYPE(Ltimeout)
d121 6
a126 4
	Ltimeout = . - 4	/* offset of the "183" above */
Lilp:	mov	ah,1		/* check if key was was pressed */
	int	0x16
	jnz	Lkeyp		/* yep */
d136 9
a144 7
	ja	Lscanp		/* yes, fake a return keypress */
	jmp	Lilp		/* no, jump back to the input */
	/* below: input loop without timeout */
Lkeyp:	mov	ah,1		/* check if a key was pressed */
	int	0x16		/* bizarre hack for Intel Macintosh ― if */
	jz	Lkeyp		/* none was pressed, loop, else below fails */
	xor	ah,ah		/* get pressed key */
d146 16
a161 19
	mov	bx,offset Lptab	/* we boot "this one" */
	sub	al,13		/* return */
	jb	Lkeyp		/* illegal */
	je	Lscanp
	sub	al,0x30-13	/* '0' */
	jb	Lkeyp		/* illegal */
	xor	ebp,ebp		/* LBA offset '0' */
	xor	dx,dx		/* CHS values 0/0/1 */
	xor	cx,cx
	inc	cx
	cmp	al,5
	ja	Lkeyp		/* illegal */
	je	LbCHS		/* 5: floppy */
	cmp	al,4
	je	Lbjmp		/* 4: MBR */
	shl	al,4
	add	bl,al
	jmp	LbLBA		/* 0..3: partition */
Lscanp:	/* "return" */
d163 4
d168 5
a172 6
	mov	al,[apart]	/* first: hard-coded by fdisk(8) 'fdef' */
	cmp	al,3		/* 0..3 are valid */
	jbe	Lscan2		/* got one */
Lscan1:	/* iterate over partition table entries */
	cmp	byte ptr [bx],0x80
	je	LbLBA		/* found an active partition */
d174 8
a181 14
	cmp	bl,0xFE
	jb	Lscan1		/* repeat for 4 partitions */
	jmp	Lkeyp		/* no active partition found */
Lscan2:	shl	al,4		/* partition table number (0..3) -> offset */
	add	bl,al
	/* try to boot (LBA first, then CHS) */
LbLBA:	mov	dx,[bx]		/* 0x01BE .. 0x01BF -> CHS values, part 1 */
	mov	cx,[bx+2]	/* 0x01C0 .. 0x01C1 -> CHS values, part 2 */
	mov	ebp,[bx+8]	/* 0x01C6 .. 0x01C9 -> LBA value "start" */
Lbjmp:	/* got LBA values in ebp, CHS values in cx:dx */
	push	bx		/* partition table entry, or junk */
	mov	dl,0x80
	xor	si,si
	xor	di,di		/* LBA parm blk overwrites begin of code */
d183 1
a183 1
	stosw			/* word: pblk size 0x0010 bytes */
d185 5
a189 3
	stosw			/* word: # of sectors = 0x0001 */
	mov	ax,0x7C00
	stosw			/* word: dst offset */
d191 3
a193 3
	stosw			/* word: dst segment */
	mov	eax,ebp
	stosd
d195 2
a196 14
	stosw
	stosw			/* qword: LBA offset of start sector */
	/* do we really have LBA functions? */
	pusha
	mov	ah,0x41		/* LBA installation check */
	mov	bx,0x55AA	/* magic */
	int	0x13
	jc	LbCHS		/* CF set -> nope, use CHS */
	cmp	bx,0xAA55	/* magic */
	jne	LbCHS		/* bad magic -> nope, use CHS */
	and	cl,1		/* API subset support bitmap */
	jz	LbCHS		/* extended disc access funcs unsupported */
	popa
	/* try to load it using LBA */
d198 10
a207 7
	call	Ltry		/* try to boot that */
	/* didn't work, try CHS next */
LbCHS:	mov	ax,0x0201	/* load 0x01 sector */
	mov	bx,0x0200	/* to ES:0200 = 0x07C00 */
	call	Ltry
Labend:	/* we can't boot, abort */
	mov	si,offset Lmsgf
d209 7
a215 1
Lablp:	jmp	Lablp
d217 2
a218 3
Ltry:	mov	bp,4		/* number of tries */
	mov	ds:[0x3FE],bp	/* place where later should be 0x55 0xAA magic */
Ltry0:	pusha
d221 4
a224 3
	jc	Ltry9		/* error? again. */
	cmp	word ptr ds:[0x3FE],0xAA55
	jne	Ltry9		/* bad magic? again. */
d227 6
a232 1
	pop	si		/* return address */
d234 2
a235 5
	push	bx
	push	word ptr 0x7C00	/* retf address */
	push	dx		/* drive we loaded from */
	int	0x10
	pop	dx
d237 2
a238 2
	lret			/* jump to 0000:7C00 */
Ltry9:	pusha
d242 2
a243 2
	dec	bp
	jnz	Ltry0		/* retry */
d261 8
a268 4
	. = 0x01B7
	.size	apart,1
LDENTRY(apart)
	.byte	0xFF		/* default partition [0..3] or none */
d270 1
a270 5
	. = 0x01B8
	/* Microsoft® NT volume ID, or so I think */

	. = 0x01BE
LDENTRY(Lptab)
d272 9
a280 7

	. = 0x01F8
	/* this is pre-installation only */
	.size	L___hint,2
LDENTRY(L___hint)
#ifdef	BOOTMANAGER
	.word	Ltimeout	/* timeout, measured in ticks, for fdisk */
d282 1
a282 1
	.word	0xFFFF
d284 7
a290 1
LDENTRY(L___rest)
d292 2
a293 4
	. = 0x01FE
	.size	L___magic,2
LDENTRY(L___magic)
	.word	0xAA55
@


1.8
log
@bump, regenerate, etc.
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/mbr/mbr.S,v 1.7 2008/12/28 20:15:23 tg Exp $ */
d4 2
a5 2
 * Copyright (c) 2004, 2005, 2007, 2008
 *	Thorsten Glaser <tg@@mirbsd.de>
d21 5
d28 4
a31 1
#include <machine/asm.h>
d38 1
d122 1
a122 1
	.size	Ltimeout, 4
d267 1
a267 1
	.size	apart, 1
d280 1
a280 1
	.size	L___hint, 2
d290 1
a290 1
	.size	L___magic, 2
@


1.7
log
@from the SYSLINUX comboot documentation:
        Normal boot sectors expect DL to contain the drive number,
        and, for hard drives (DL >= 80h) DS:SI to contain a pointer to
        the 16-byte partition table entry.

⇒ adhere to it
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/mbr/mbr.S,v 1.6 2007/03/18 02:29:58 tg Exp $ */
d4 1
a4 1
 * Copyright (c) 2004, 2005, 2007
a12 4
 * Advertising materials mentioning features or use of this work must
 * display the following acknowledgement:
 *	This product includes material provided by Thorsten Glaser.
 *
@


1.6
log
@Intel Mac hack: wait until EFI-emulated BIOS signals that a key is
pressed, only then ask the BIOS to give us the key
• from Tom Cosgrove, who applied this fix to libsa/bioscons for that other BSD
• cost is the “wait for keypress then reboot” on bad magic handler, which
  now invokes an endless loop, but since we “sti” ctrl-alt-del ought to work
• adds one more available byte, used to make text message better looking
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/mbr/mbr.S,v 1.5 2007/02/26 17:07:19 tg Exp $ */
d73 1
a73 1
	.ascii	"00 4=MBR 5=fdd Ret=deflt\r\n"
d107 1
d109 2
a110 1
#ifdef BOOTMANAGER
d141 1
a159 2
#else
#define Lkeyp	Labend
d179 1
d229 2
@


1.5
log
@bad magic
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/mbr/mbr.S,v 1.4 2007/02/26 02:11:33 tg Exp $ */
d73 1
a73 1
	.ascii	"00 4=MBR 5=fdd CR=deflt\r\n"
d134 4
a137 1
Lkeyp:	xor	ah,ah		/* get pressed key */
d215 1
a215 3
	xor	ax,ax		/* wait for any keypress */
	int	0x16
	jmp	0xF000,0xFFF0	/* reset */
@


1.4
log
@switch to a newer, more compact, PBR as well
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/mbr/mbr.S,v 1.3 2007/02/26 01:51:46 tg Exp $ */
d217 1
a217 1
	mov	ds:[0x3FE],bp	/* place where later should be 0x55AA magic */
d222 1
a222 1
	cmp	word ptr ds:[0x3FE],0x55AA
@


1.3
log
@better, keep locals local
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/mbr/mbr.S,v 1.2 2007/02/26 01:46:49 tg Exp $ */
d115 2
a117 2
	.type	Ltimeout, @@object
	.size	Ltimeout, 4
@


1.2
log
@give us meaningful disasms
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/mbr/mbr.S,v 1.1 2007/02/26 00:13:27 tg Exp $ */
d29 5
d38 1
a38 1
ALTENTRY(_start)
d61 1
a61 1
DENTRY(Lmsg)
d66 1
a66 1
DENTRY(Lm00)
d68 1
a68 1
DENTRY(Lm01)
d70 1
a70 1
DENTRY(Lm02)
d72 1
a72 1
DENTRY(Lm03)
d78 1
a78 1
DENTRY(Lmsgf)
d258 1
a258 1
DENTRY(apart)
d265 1
a265 1
DENTRY(Lptab)
d271 1
a271 1
DENTRY(L___hint)
d277 1
a277 1
DENTRY(L___rest)
d281 1
a281 1
DENTRY(L___magic)
@


1.1
log
@re-order the MBR stuff and improve functionality and comments;
actually check for usability of LBA functions before using them
@
text
@d1 1
a1 1
/* $MirOS: src/share/misc/licence.template,v 1.20 2006/12/11 21:04:56 tg Rel $ */
d27 2
d33 2
a34 3
	.globl	_start
	.type	_start, @@function
_start:	xor	eax,eax
d56 2
a57 1
Lmsg:	.ascii	"Mir-" __BOOT_VER
d61 8
a68 4
Lm00:	.ascii	"00 1="
Lm01:	.ascii	"00 2="
Lm02:	.ascii	"00 3="
Lm03:	.ascii	"00 4=MBR 5=fdd CR=deflt\r\n"
d73 2
a74 1
Lmsgf:	.asciz	"bad magic\r\n"
d102 1
a102 1
	mov	bx,offset ptab	/* we boot "this one" */
d111 1
a111 1
	.type	Ltimeout, @@data
a251 1
	.type	apart, @@object
d253 2
a254 1
apart:	.byte	0xFF		/* default partition [0..3] or none */
d260 2
a261 1
ptab:	/* partition table */
d264 3
d268 1
a268 4
	/* this is pre-installation only */
	.type	hint, @@object
	.size	hint, 2
hint:	.word	Ltimeout	/* timeout, measured in ticks, for fdisk */
d272 1
d275 3
a277 3
	.type	magic, @@object
	.size	magic, 2
magic:	.word	0xAA55
@

