head	1.26;
access;
symbols
	tg-use_ldscript:1.25.0.2
	MIRBSD_10:1.9.0.2
	MIRBSD_10_BASE:1.9;
locks; strict;
comment	@# @;


1.26
date	2010.12.01.19.56.58;	author tg;	state Exp;
branches;
next	1.25;
commitid	1004CF6A89472F8D29F;

1.25
date	2009.06.29.20.50.59;	author tg;	state Exp;
branches;
next	1.24;
commitid	1004A49292C66B6FB4D;

1.24
date	2009.06.29.20.26.10;	author tg;	state Exp;
branches;
next	1.23;
commitid	1004A4923254C26E6EF;

1.23
date	2009.06.29.20.10.26;	author tg;	state Exp;
branches;
next	1.22;
commitid	1004A491FC3492C15C0;

1.22
date	2009.06.29.20.01.45;	author tg;	state Exp;
branches;
next	1.21;
commitid	1004A491DB51BAB1E6B;

1.21
date	2009.06.07.13.07.46;	author tg;	state Exp;
branches;
next	1.20;
commitid	1004A2BBAFA4B0EDDF2;

1.20
date	2009.06.07.12.02.37;	author tg;	state Exp;
branches;
next	1.19;
commitid	1004A2BAC12547F8E38;

1.19
date	2009.06.07.11.30.23;	author tg;	state Exp;
branches;
next	1.18;
commitid	1004A2BA4A60120871F;

1.18
date	2009.05.26.19.26.29;	author tg;	state Exp;
branches;
next	1.17;
commitid	1004A1C424912B13620;

1.17
date	2009.02.08.20.57.14;	author tg;	state Exp;
branches;
next	1.16;
commitid	100498F47426C8BA0A1;

1.16
date	2009.01.31.18.51.19;	author tg;	state Exp;
branches;
next	1.15;
commitid	10049849D7F07A9D7B9;

1.15
date	2009.01.17.11.21.50;	author tg;	state Exp;
branches;
next	1.14;
commitid	1004971BECB121B12BB;

1.14
date	2009.01.10.23.53.27;	author tg;	state Exp;
branches;
next	1.13;
commitid	100496935032026509B;

1.13
date	2009.01.10.23.52.48;	author tg;	state Exp;
branches;
next	1.12;
commitid	100496934E335C7CEBF;

1.12
date	2009.01.10.18.15.10;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004968E59B158ABED9;

1.11
date	2009.01.02.05.01.46;	author tg;	state Exp;
branches;
next	1.10;
commitid	100495D9FCE7857009B;

1.10
date	2008.08.05.17.57.08;	author tg;	state Exp;
branches;
next	1.9;
commitid	100489894510593D3DC;

1.9
date	2007.09.28.20.51.27;	author tg;	state Exp;
branches;
next	1.8;
commitid	10046FD696406ED65C5;

1.8
date	2007.05.26.21.57.39;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004658AD292457D584;

1.7
date	2007.02.26.17.39.10;	author tg;	state Exp;
branches;
next	1.6;
commitid	10045E31B486EF8EEF1;

1.6
date	2007.02.26.04.08.56;	author tg;	state Exp;
branches;
next	1.5;
commitid	10045E25D381E5D76B5;

1.5
date	2007.02.26.03.53.00;	author tg;	state Exp;
branches;
next	1.4;
commitid	10045E259B37F1BC44C;

1.4
date	2007.02.26.03.07.07;	author tg;	state Exp;
branches;
next	1.3;
commitid	10045E24ED104593E34;

1.3
date	2007.02.26.02.52.46;	author tg;	state Exp;
branches;
next	1.2;
commitid	10045E24B6E7262EB74;

1.2
date	2007.02.26.02.35.04;	author tg;	state Exp;
branches;
next	1.1;
commitid	10045E247684469D467;

1.1
date	2007.02.26.02.11.33;	author tg;	state Exp;
branches;
next	;
commitid	10045E241DC524D9D5F;


desc
@@


1.26
log
@the “pacify mikap” commit (MirBSD part): ISOLINUX hackish loading support
@
text
@/* $MirOS: src/sys/arch/i386/stand/bootxx/bootxx.S,v 1.25 2009/06/29 20:50:59 tg Exp $ */

/*-
 * Copyright (c) 2009
 *	Thorsten Glaser <tg@@mirbsd.org>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 */

	.intel_syntax noprefix
	.section .comment
	.ascii	"$MirOS: src/sys/arch/i386/stand/bootxx/bootxx.S,v 1.25 2009/06/29 20:50:59 tg Exp $"
#if defined(BOOT_GRUB)
	.ascii	" +t:GRUB"
#elif defined(BOOT_ISOLINUX)
	.ascii	" +t:ILNX"
#else
	.ascii	" +t:MBSD"
#endif
#ifdef BPB_SPACE
	.ascii	" +s:BPB"
#else
	.ascii	" +s:MBR"
#endif
	.byte	0

	.code16
	.text

	.globl	_start
	.type	_start,@@function
_start:	/* bootxx entry point 07C00 */
#ifdef BPB_SPACE
	jmp	Linit
	nop
	. = _start + 3
L_BPB:	.ascii	"MirOSBSD"
	. = L_BPB + 0x3F
	.byte	0x29
	. = L_BPB + 0x44
	.ascii	"MirOSBSDldr"
	.ascii	"FATnn   "
#endif
Linit:	xor	ecx,ecx
	mov	ss,cx
	mov	sp,0x7BFC
	push	ecx
	popfd
#ifdef BOOT_ISOLINUX
	push	es		/* $PnP header */
	push	di
#endif
	mov	es,cx
#if defined(BOOT_GRUB) || defined(BOOT_ISOLINUX)
	mov	si,0x7C00	/* 0000:_start pre-reloc */
#else
	mov	di,0x7C00	/* DS:SI is set by BIOS! */
	push	di
	/* save partition table entry */
	mov	cl,16
	rep	movsb
	pop	si
#endif
	mov	ds,cx
	mov	bx,SA_LINKSEG
	push	bx
	push	bx
	mov	es,bx
	mov	di,offset _start
	mov	ch,2		/* 512 bytes */
	rep	movsb
	pop	ds
	push	offset Lmain
	lret

	Lpblk = _start + 0x10
	Lebss = Lpblk + 0x18	/* make sure this is < Lmmsg */

Lemsg:	.ascii	__BOOT_VER
	.asciz	" Loading "
#ifndef BOOT_GRUB
Lmmsg:	.ascii	"bad magic"
#endif
Lfmsg:	.ascii	" error"
Lbmsg:	.asciz	"\r\n"

	.globl	bkcnt
	.type	bkcnt,@@object
	.size	bkcnt,1
bkcnt:	.byte	(bkend - bktbl)

	.globl	geomh
	.type	geomh,@@object
	.size	geomh,2
geomh:	.word	2		/* 1..256 = tracks per cylinder */

	.globl	geoms
	.type	geoms,@@object
	.size	geoms,2
	/* set to 0 for auto geometry */
geoms:	.word	18		/* 1..63 = sectors per track */

	.globl	partp
	.type	partp,@@object
	.size	partp,1
partp:	.byte	0
Ldrv:	.byte	0x80		/* must be at partp + 1 */

Lload:	.word	LsLBA

#ifdef BOOT_ISOLINUX
Lpnp:	.long	0
#endif

	/* output NUL-terminated string from ds:si */
Lotxt0:	mov	ah,0x0E
	mov	bx,7
	int	0x10
Lotxt:	lodsb
	or	al,al
	jnz	Lotxt0
	ret

Lbarf:	call	Lotxt
	mov	ax,offset LsCHS
	xchg	ax,[Lload]
	cmp	ax,offset LsCHS
	jne	Lretr
	xor	ax,ax
	int	0x16
	jmp	0xF000,0xFFF0

Lmain:	sti
	mov	[Ldrv],dl
#ifdef BOOT_ISOLINUX
	pop	eax		/* $PnP header */
	mov	[Lpnp],eax
#endif
	mov	si,offset Lemsg
	cmp	dl,0x80
	jb	Lbarf		/* floppy: only try CHS */
	call	Lotxt
	/* FALLTHROUGH */

Lretr:	xor	bx,bx		/* load offset (begin) */
	mov	si,offset bktbl
	movzx	bp,byte ptr [bkcnt]
Lloop:	lodsb
	/*-
	 * AL contains bitmasked:  aaabbbbb
	 * -> a = (number of bytes - 1) that follow	(-> CX)
	 * -> b = (number of sectors - 1) to load	(-> DI)
	 * BX contains current load address offset
	 * SI contains pointer to data being processed
	 * BP contains number of entries to process
	 */

	/* decode */
	movzx	cx,al
	shr	cl,5
	and	ax,0x1F
	inc	ax
	inc	cx
	push	ax		/* later DI */

	/* create LBA parameter block */
	mov	di,offset Lpblk
	mov	ax,0x0010
	stosw
	mov	al,1
	stosw
	mov	ax,bx
	stosw
	mov	ax,cs
	stosw
	rep	movsb		/* copy CX bytes */
	xor	ax,ax		/* pad with 8 (up to 7 needed) NUL bytes */
	stosw
	stosw
	stosw
	stosw

	pop	di
	/*-
	 * Lpblk, Ldrv are filled in completely
	 * CS = DS = ES = SA_LINKSEG = 0x4000
	 * DI = number of sectors to still load
	 * BX = load offset (segment CS)
	 * BP = number of entries to load, including this one
	 * SI = pointer to next entry to load
	 */
	push	bp
	push	si
Lld1s:	mov	si,offset Lpblk
	call	[Lload]
	mov	bp,4		/* number of retries */
	mov	dl,[Ldrv]
Lldlp:	pusha
	stc
	int	0x13
	pushf
	mov	ax,0x0E2E	/* "dot" as progress meter */
	mov	bx,7
	int	0x10
	popf
	sti
	popa
	jnc	Lldok
	dec	bp
	pusha
	pushf
	xor	ax,ax		/* reset drive */
	int	0x13
	popf
	mov	si,offset Lfmsg
	jz	Lbarf
	mov	ax,0x0E30	/* number as fail meter */
	add	ax,bp
	mov	bx,7
	int	0x10
	popa
	jmp	Lldlp
Lldok:	/* increment load address by sector size */
	mov	ah,2		/* 512 bytes */
	.globl	secsz
	.type	secsz,@@object
	.size	secsz,1
	secsz = . - 1		/* the "2" above */
L...1:	add	bh,ah		/* add the 512 bytes */
	mov	4[si],bx
	add	ah,bh		/* again */
	jc	Ldone		/* last block completes (64 KiB - bootxx) */
	/* increment quadword by one */
	add	dword ptr 8[si],1
	adc	dword ptr 12[si],0
	/* load next sector */
	dec	di
	jnz	Lld1s
	pop	si
	pop	bp
	dec	bp
	jnz	Lloop
	/* FALLTHROUGH */

Ldone:	/* check bootloader magic */
#if defined(BOOT_GRUB)
	/* no magic */
#elif defined(BOOT_ISOLINUX)
	xor	ecx,ecx
	push	ecx		/* partition offset (qword) */
	push	ecx		/* partition offset (qword) */
	mov	eax,[Lpnp]
	push	eax		/* ES, DI */
	mov	ax,[Ldrv]
	push	ax		/* DX */
	mov	ax,[geomh]
	push	ax		/* # of heads */
	mov	ax,[geoms]
	push	ax		/* # of sectors per track */
	xor	bx,bx
	mov	ax,[Lload]
	cmp	ax,offset LsCHS	/* so-called CBIOS */
	je	Lilx1
	inc	bx		/* so-called EBIOS */
Lilx1:	push	bx		/* ebios flag */
	push	cx		/* target CS */
	mov	eax,ds:[0x40]	/* location of magic in ISOLINUX.BIN */
	mov	si,offset Lmmsg
	cmp	eax,0x7078C0FB	/* magic */
	jne	Lbarf
#else
	xor	eax,eax
	push	ax		/* return address */
	mov	ax,[partp]
	xchg	eax,ds:[4]	/* location of magic in /boot */
	cmp	eax,0x696D4F00
	mov	si,offset Lmmsg
	jne	Lbarf
#endif
	mov	si,offset Lbmsg
	call	Lotxt
#if defined(BOOT_GRUB) || defined(BOOT_ISOLINUX)
#if defined(BOOT_GRUB)
	xor	edx,edx
	push	dx		/* initial CS */
	dec	edx		/* EDX := FFFFFFFF */
	mov	dl,[Ldrv]	/* boot BIOS drive number */
	mov	ax,0x8200
#elif defined(BOOT_ISOLINUX)
	mov	ax,0x7C44
#endif
	push	ax		/* initial IP */
	cli			/* be nice to a GNU every once in a while */
	lret
#else
	mov	si,offset _start
	ret
#endif

	/* obtain drive geometry */
Lgeom:	pusha
	push	es
#if 0
	/*
	 * According to RBIL, this is needed to guard against
	 * BIOS bugs, but we don’t read out the table anyway.
	 */
	xor	di,di
	mov	es,di
#endif
	mov	ah,8
	mov	dl,[Ldrv]
	stc
	int	0x13
	sti
	pop	es
	mov	si,offset Lfmsg
	jc	Lbarf
	/* process returned values */
	and	cl,0x3F		/* number of sectors per track */
	mov	[geoms],cl	/* high byte is 0 anyway */
	movzx	ax,dh
	inc	ax		/* maximum index -> number of heads */
	mov	[geomh],ax
	popa
	/* FALLTHROUGH */

LsCHS:	mov	cx,[geoms]
	jcxz	Lgeom
	mov	ax,8[si]
	mov	dx,10[si]
	div	cx
	inc	dx		/* remainder: sector */
	xor	cx,cx
	xchg	cx,dx
	div	word ptr [geomh]
	shl	ah,6		/* quotient: cylinder */
	xchg	ah,al
	or	cx,ax
	mov	dh,dl		/* remainder: head */
	mov	ax,0x0201
	ret

LsLBA:	mov	ah,0x42
	ret

	.globl	bktbl
	.type	bktbl,@@object
bktbl:	.long	0xCAFEBABE

#ifndef BPB_SPACE
	/* ensure we have space for a partition table */
	. = _start + 0x01BE
	.byte	0
#endif

	/* bxinst requires bktbl to end at 510 */
	. = _start + 0x01FE
	/* bkend is required by installboot(8) still */
	.globl	bkend
	.type	bkend,@@object
bkend:	.word	0xAA55
@


1.25
log
@• sync cleanfiles
• use parsable "feature indicators" in the rcs id
• if BPB, don’t not-do $RANDOM in the MBR places, there is no ptab…
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/bootxx/bootxx.S,v 1.24 2009/06/29 20:26:10 tg Exp $ */
d25 2
a26 2
	.ascii	"$MirOS: src/sys/arch/i386/stand/bootxx/bootxx.S,v 1.24 2009/06/29 20:26:10 tg Exp $"
#ifdef BOOT_GRUB
d28 2
d62 4
d67 1
a67 1
#ifdef BOOT_GRUB
d124 4
d148 4
d259 26
a284 1
#ifndef BOOT_GRUB
d295 2
a296 4
#ifndef BOOT_GRUB
	mov	si,offset _start
	ret
#else
d302 3
d308 3
@


1.24
log
@• if BOOT_GRUB: remove superfluous saving of BIOS’ DS:SI (not needed, as
  grub doesn’t look at it) and the bad magic string
• if BPB_SPACE: new, reserve space for a FAT12/16/28 BPB at the beginning
  but skip reserving MBR space at the end
• rcsid: encode GRUB/MBSD boot(8/i386) as well as BPB/MBR too
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/bootxx/bootxx.S,v 1.23 2009/06/29 20:10:26 tg Exp $ */
d25 1
a25 1
	.ascii	"$MirOS: src/sys/arch/i386/stand/bootxx/bootxx.S,v 1.23 2009/06/29 20:10:26 tg Exp $"
d27 1
a27 1
	.ascii	" GRUB"
d29 1
a29 1
	.ascii	" MBSD"
d32 1
a32 1
	.ascii	" BPB"
d34 1
a34 1
	.ascii	" MBR"
@


1.23
log
@preserve bootxx.S rcsid in bxinst.sh
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/bootxx/bootxx.S,v 1.22 2009/06/29 20:01:45 tg Exp $ */
d25 12
a36 1
	.asciz	"$MirOS: src/sys/arch/i386/stand/bootxx/bootxx.S,v 1.22 2009/06/29 20:01:45 tg Exp $"
d44 12
a55 1
	xor	ecx,ecx
d61 4
a64 1
	mov	di,0x7C00	/* 0000:_start pre-reloc */
d70 1
d88 1
d90 1
d321 1
d325 1
@


1.22
log
@unify stack between grub and boot pre-setup
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/bootxx/bootxx.S,v 1.21 2009/06/07 13:07:46 tg Exp $ */
d24 3
@


1.21
log
@The ability to generate a partition table and a partition for the grml
manifold-boot™ ISO without having to sacrifice these 64 bytes of block
table beforehand (bxinst only) by means of two new options:
• -g C:H:S works like bxinst.sparc and initiates creating a partition
• -M no (no=1‥4) makes room for the partition table

If neither -g nor -M are given, nothing is changed.
If -g and -M are given and valid, a partition is created with these values.
If -g is given but -M isn’t, it defaults to the last partition.
If -M is given but -g isn’t, the partition table is merely NUL’d.

The partition type passed from the -p option will be used.
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/bootxx/bootxx.S,v 1.19 2009/06/07 11:30:23 tg Exp $ */
d29 2
a30 5
_start:	xor	ecx,ecx
#ifdef BOOT_GRUB
	mov	bx,0x3000	/* we load to 08000 so put stack further up */
	mov	ss,bx
#else
d32 1
a32 2
#endif
	mov	sp,0xFFFC
@


1.20
log
@Mika also wants a partition table embedded in the bootsector of his
manifold-boot™ ISOs, because otherwise a 700M ISO on a 2G USB stick
would be a sensational waste of space (and I agree)

works with installboot(8) but not self-installing as of now, plus I
have to actually test it
@
text
@d294 1
a294 1
#ifdef USE_PTAB
d296 3
a298 1
#else
d300 1
a300 1
#endif
d303 1
a303 3
bkend:
	. = _start + 0x01FE
	.word	0xAA55
@


1.19
log
@Implement Auto-Geometry Detection feature, which, since we’re being used
by grml for manifold-boot™ ISOs over isohybrid, was a feature request by
Mika Prokop. Tested with floppies in qemu; only affects CHS not LBA.
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/bootxx/bootxx.S,v 1.18 2009/05/26 19:26:29 tg Exp $ */
d294 3
d298 1
d301 3
a303 1
bkend:	.word	0xAA55
@


1.18
log
@the ability to boot a GNU GRUB from our bootxx{,.sh},
designed for Mika Prokop to use with grml GNU/Linux

note: a GNU GRUB2 core.img file was tested, a grub-legacy
stage2 would be too large, the limit is 65280 bytes
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/bootxx/bootxx.S,v 1.17 2009/02/08 20:57:14 tg Exp $ */
d80 1
d115 1
a119 1

d215 1
d243 31
a273 1
LsCHS:	mov	ax,8[si]
d275 1
a275 1
	div	word ptr [geoms]
@


1.17
log
@gecko2@@ prodded me to investigate into a problem I had once (and no more
afterwards) but could reproduce after he did: by trying to boot a fresh-
ly installed from the FOSDEM 2009 ISO system.

The first stage boot loader (bootxx) would load 4 filesystem blocks of
16 KiB each == 128 sectors of the second stage boot loader (ldbsd.com),
because that’s what installboot(8) tells it – size in filesystem blocks.
Now the first stage boot loader is located at 4000:FE00h, whereas the
second stage boot loader begins at 4000:0000h. In the end, the last of
these 128 sectors ends up overwriting the code it loads it.

It did not appear for me any more because, due to sheer luck, the last
sector contained only no-ops (possibly 00h bytes), so it basically fell
through from 4000:FFFFh to 4000:0000h due to a 16 bit wrap.

This fix checks the bounds of the load address to see if the end of the
next sector load would wrap the boundary. Unless the size of a sector
were smaller than the size of bootxx, it would catch all possible cases.
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/bootxx/bootxx.S,v 1.16 2009/01/31 18:51:19 tg Exp $ */
d30 4
d35 1
d216 1
d224 1
d227 1
d230 10
@


1.16
log
@new bootmagic, bootxx: reading only one sector at a time, ignoring
what the BIOS thinks it can do or cannot…

note: bootxx.sh (self-installing bootblocks) and installboot(8/i386)
both still break up entries at track boundaries, which is no longer
needed because of the single-sector reads
@
text
@d1 1
a1 1
/* $MirOS: src/share/misc/licence.template,v 1.28 2008/11/14 15:33:44 tg Rel $ */
d190 1
a190 1
	add	bh,2		/* 512 bytes */
d195 4
a198 1
L...1:	mov	4[si],bx
d210 1
a210 1
	/* check bootloader magic */
@


1.15
log
@• we do not use spaces after commas in assembly, even in .size pseudo-ops
• restore the use of [GL][DT]ENTRY in bootxx and make it not depend on
  <machine/asm.h> in mbr
• add comments

Prompted by mika@@grml
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/bootxx/bootxx.S,v 1.14 2009/01/10 23:53:27 tg Exp $ */
d4 1
a4 1
 * Copyright (c) 2003, 2004, 2005, 2007, 2009
a22 11
/* we somewhat assume ELF binutils with this, others might work... */
#define _ASM_LABEL(x)	x
#define FTYPE(x)	.type x,@@function
#define OTYPE(x)	.type x,@@object

#define LDENTRY(x)	OTYPE(_ASM_LABEL(x)); _ASM_LABEL(x):
#define LTENTRY(x)	FTYPE(_ASM_LABEL(x)); _ASM_LABEL(x):
#define GDENTRY(x)	.globl _ASM_LABEL(x); LDENTRY(x)
#define GTENTRY(x)	.globl _ASM_LABEL(x); LTENTRY(x)

/* ... as long as they do Intel syntax (since 1999 or earlier) */
d27 4
a30 7
GTENTRY(_start)
	xor	ax,ax
	push	ax
	popf
	/* set up stack from 07C0:FFFC (0x17BFC) down */
	add	ax,0x07C0
	mov	ss,ax
d32 18
a49 3
	push	ds
	push	si
	push	ax		/* for retf */
a50 4
	/* set up code and data at 07C0:0000 (0x07C00) = 0000:7C00 up */
	mov	ds,ax
	mov	es,ax
	/* jump to 'cs:offset Lmain' */
d53 4
a56 2
LDENTRY(Lmsg)
	.ascii	__BOOT_VER
d58 18
d77 2
a78 17
LDENTRY(Lerr)
	.ascii	"bad magic"
LDENTRY(Lldf)
	.ascii	" ERR"
LDENTRY(Lcrlf)
	.asciz	"\r\n"

#define BLKCNT	(blkend - blktbl)
GDENTRY(blkcnt)
	.byte	BLKCNT
	.size	blkcnt,1

LDENTRY(Lldp)
	.word	LsLBA

GDENTRY(partp)
	.byte	0		/* must be Ldrv - 1 */
d80 2
a81 2
LDENTRY(Ldrv)
	.byte	0x80
d83 1
a83 7
GDENTRY(bpbspt)
	.word	18
	.size	bpbspt,2

GDENTRY(bpbtpc)
	.word	2
	.size	bpbtpc,2
d86 1
a86 2
LTENTRY(Lotxt0)
	mov	ah,0x0E
d89 1
a89 2
GTENTRY(Lotxt)
	lodsb
d94 6
a99 9
	/* If something went wrong, but we didn't yet try the subrouting
	 * to cope with broken BIOSes and Soekris, redo from start.
	 */
Lbarf:	call	Lotxt			/* something went wrong */
	mov	ax,offset LsBRK		/* offset of broken-BIOS load sub */
	xchg	ax,[Lldp]
	cmp	ax,offset LsBRK		/* broken BIOS sub already tried? */
	jne	LbLBA
	xor	ah,ah
d103 5
a107 4
LTENTRY(Lmain)
	mov	[Ldrv],dl	/* save boot device */
	/* say hello */
	mov	si,offset Lmsg
d109 13
a121 42
	/* check for single-block CHS */
	mov	ax,offset LsBRK
	xchg	bh,[bpbspt+1]
	and	bh,0x80
	jnz	LbCHS		/* yep, hardcoded via bootloader */
	push	ax
	mov	ah,2		/* get shift state of keyboard */
	int	0x16
	and	al,3		/* any shift key pressed? */
	pop	ax
	jnz	LbCHS		/* if so, go to single sector mode */
	/* check for LBA vs. CHS */
	mov	ah,0x41		/* LBA installation check */
	mov	bx,0x55AA	/* magic */
	int	0x13
	mov	ax,offset LsCHS
	jc	LbCHS		/* CF set -> nope, use CHS */
	cmp	bx,0xAA55	/* magic */
	jne	LbCHS		/* bad magic -> nope, use CHS */
	and	cl,1		/* API subset support bitmap */
	jnz	LbLBA		/* extended disc access funcs supported */

LbCHS:	mov	word ptr ds:[Lldp],ax
LbLBA:	xor	di,di
	push	di		/* 0 */
	mov	ax,0x0010
	stosw
	push	di		/* 2 */
	mov	ax,SA_LINKSEG	/* libsa constant */
	mov	fs,ax		/* for magic check and booting */
	push	ax		/* running counter, for loading */
	mov	si,offset blktbl
	mov	cl,[blkcnt]
Lmlp1:	/* main load loop */
	xor	eax,eax
	lodsb
	/*
	 * al contains bitmasked:
	 * aaabbbbb
	 * -> a=number of bytes-1 that follow	(-> dl)
	 * -> b=number of sectors-1 to load	(-> al)
	 * si, cl contain what is to be processed
a123 4
	pop	bx
	pop	di
	push	di

d125 3
a127 3
	mov	dl,al
	shr	dl,5
	and	al,0x1F
d129 2
a130 2
	inc	dx
	stosd
d132 7
a138 1
	xchg	ax,bx		/* load segment */
d140 4
a143 13
	shl	bx,(9 - 4)	/* number of sectors, times their size,
				   divided by size of one paragraph */
	secsizofs = . - 1
	.globl	secsizofs
	.size	secsizofs,1
	add	bx,ax		/* increment load addr. segment accordingly */
	push	bx		/* and save for next round */
	push	cx		/* save blkcnt */

Lmlp2:	movsb			/* copy over as many bytes as needed */
	dec	dl
	jne	Lmlp2
	xor	ax,ax		/* pad with up to 7 NUL-bytes */
d149 8
a156 9
	/*
	 * at this point, we have the following:
	 * si points to the _next_ entry to load
	 * on top of stack, there is the number of
	 *    entries to load, including the current one
	 * the _next_ load address is below that on the stack
	 * below that, 0x0002 (for DI) is on the stack
	 * the LBA parameter block is filled in.
	 * BX is set up to the load segment (offset = const. 0000)
d158 5
a162 1
	/* call subroutine that does the actual loading */
d164 2
a165 73
	call	[Lldp]
	/* and loop back */
	pop	cx
	dec	cl
	jne	Lmlp1

	/* ok, second-stage boot loader is in memory, starting FS:[0000] */
	xor	eax,eax
	mov	ax,[partp]
	/* check some "random" ASCII string, i.e. the boot magic */
	xchg	eax,fs:[4]
	cmp	eax,0x6A6D4F00
	mov	si,offset Lerr		/* "bad magic" */
	jne	Lbarf			/* it isn't correct, barf out */
	/* new line, for the fine look */
	mov	si,offset Lcrlf
	call	Lotxt
	/* set up and jump into /boot */
	pop	si			/* running counter */
	pop	si			/* 2 */
	pop	cx			/* 0 */
	pop	si			/* original SI */
	pop	ds			/* original DS */
	push	fs			/* load segment */
	push	cx			/* 0 */
	lret

	/* LBA boot routine */
LsLBA:	push	si			/* save blktbl offset */
	mov	ah,0x42			/* BIOS routine loadLBA */
	xor	si,si			/* offset parblk */
	call	LsINT			/* call BIOS subroutine */
	pop	si
Lretn:	ret

	/* some broken BIOSes don't allow multi-sector transfers... */
LsBRK:	mov	dh,1
	xchg	dh,ds:[2]		/* number of sectors to load */
LsBR0:	push	dx
	call	LsCHS			/* chain to default CHS loader */
	pop	dx
	dec	dh
	je	Lretn			/* loop one by one over the sectors */
	add	word ptr ds:[6],32	/* size of a sector in paragraphs */
	inc	dword ptr ds:[8]
	jmp	LsBR0

	/* CHS boot routine */
LsCHS:	push	dx
	/* LBA -> CHS */
	mov	ax,ds:[8]
	mov	dx,ds:[10]
	div	word ptr [bpbspt]
	inc	dx			/* quotient AX, remainder DX */
	push	dx			/* sector */
	xor	dx,dx
	div	word ptr [bpbtpc]
	pop	cx			/* cylinder AX, head DX */
	shl	ah,6
	xchg	ah,al
	or	cx,ax
	mov	dh,dl
	pop	ax
	mov	dl,al
	/* call the BIOS */
	mov	ah,2
	mov	al,ds:[2]
	xor	bx,bx

	/* call the interrupt */
LsINT:	mov	bp,4			/* number of retries */
LsIN0:	pusha
	mov	es,ds:[6]
a166 3
	push	ds
	pop	es
	/* progress meter */
d168 1
a168 1
	mov	ax,0x0E2E
d170 1
a170 1
	int	0x10			/* output a dot */
d172 1
d174 1
a174 1
	jnc	Lretn
d177 5
a181 1
	mov	si,offset Lldf
d183 1
a183 1
	mov	ax,0x0E30		/* say it fails */
a186 2
	xor	ax,ax
	int	0x13
d188 31
a218 1
	jmp	LsIN0
d220 16
a235 2
GDENTRY(blktbl)
	/* free space for block table till end of sector */
d237 8
a244 4
	. = 0x1FE
GDENTRY(blkend)
	.word	0xAA55
	.size	blkend,2
@


1.14
log
@no “sti” here, we want “cli” when entering boot(8/i386)…
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/bootxx/bootxx.S,v 1.13 2009/01/10 23:52:48 tg Exp $ */
d23 11
d38 1
a38 3
	.type	_start, @@function
	.globl	_start
_start:
d56 2
a57 1
Lmsg:	.ascii	__BOOT_VER
d60 6
a65 3
Lerr:	.ascii	"bad magic"
Lldf:	.ascii	" ERR"
Lcrlf:	.asciz	"\r\n"
d68 20
a87 22
	.size	blkcnt, 1
	.type	blkcnt, @@object
	.globl	blkcnt
blkcnt:	.byte	BLKCNT

Lldp:	.word	LsLBA

	.size	partp, 1
	.type	partp, @@object
	.globl	partp
partp:	.byte	0		/* must be Ldrv - 1 */
Ldrv:	.byte	0x80

	.size	bpbspt, 2
	.type	bpbspt, @@object
	.globl	bpbspt
bpbspt:	.word	18

	.size	bpbtpc, 2
	.type	bpbtpc, @@object
	.globl	bpbtpc
bpbtpc:	.word	2
d90 2
a91 2
	.globl	Lotxt
Lotxt0:	mov	ah,0x0E
d94 2
a95 1
Lotxt:	lodsb
d112 2
a113 1
Lmain:	mov	[Ldrv],dl	/* save boot device */
d179 1
a179 1
	.size	secsizofs, 1
d302 1
a302 3
	.type	blktbl, @@object
	.globl	blktbl
blktbl:
d306 1
a306 3
	.size	blkend, 2
	.globl	blkend
blkend:
d308 1
@


1.13
log
@magic required for nlist(3), gah!
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/bootxx/bootxx.S,v 1.12 2009/01/10 18:15:10 tg Exp $ */
a36 1
	sti
@


1.12
log
@new loader and stuff (new bootxx too, *incompatible*!)
still not usable until biosdev/-probe rewrite though…

syslinux, dos, multiboot operation not tested yet, either
@
text
@d1 1
a1 1
/* $MirOS: src/share/misc/licence.template,v 1.28 2008/11/14 15:33:44 tg Rel $ */
d27 1
d57 1
d64 1
d70 1
d75 1
d290 1
@


1.11
log
@remove the kludge now
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/bootxx/bootxx.S,v 1.10 2008/08/05 17:57:08 tg Exp $ */
d5 1
a5 1
 *	Thorsten Glaser <tg@@mirbsd.de>
a22 7
#include <machine/asm.h>

#define LDENTRY(x)	OTYPE(_ASM_LABEL(x)); _ASM_LABEL(x):
#define LTENTRY(x)	FTYPE(_ASM_LABEL(x)); _ASM_LABEL(x):
#define GDENTRY(x)	.globl _ASM_LABEL(x); LDENTRY(x)
#define GTENTRY(x)	.globl _ASM_LABEL(x); LTENTRY(x)

d27 5
a31 4
GTENTRY(_start)
	xor	eax,eax
	push	eax
	popfd
d37 2
d47 1
a47 2
LDENTRY(Lmsg)
	.ascii	__BOOT_VER
d50 3
a52 6
LDENTRY(Lerr)
	.ascii	"bad magic"
LDENTRY(Lldf)
	.ascii	" ERR"
LDENTRY(Lcrlf)
	.asciz	"\r\n"
d56 2
a57 2
GDENTRY(blkcnt)
	.byte	BLKCNT
d59 1
a59 2
LDENTRY(Lldp)
	.word	LsLBA
a60 2
LDENTRY(Ldrv)
	.byte	0x80
d62 3
a64 2
GDENTRY(partp)
	.byte	0		/* must be Ldrv + 1 */
d67 2
a68 2
GDENTRY(bpbspt)
	.word	18
d71 2
a72 2
GDENTRY(bpbtpc)
	.word	2
d75 2
a76 2
LTENTRY(Lotxt0)
	mov	ah,0x0E
d79 1
a79 2
GTENTRY(Lotxt)
	lodsb
d96 1
a96 2
LTENTRY(Lmain)
	mov	[Ldrv],dl	/* save boot device */
d124 1
d127 1
a127 1
	push	di
d162 1
d195 2
a196 2
	push	fs
	push	cx
d198 2
a199 1
	cmp	dword ptr fs:[0x50],0x6A6D4F00
d206 7
a212 2
	mov	dx,[Ldrv]
	mov	fs:[0x50],dh
d285 2
a286 1
GDENTRY(blktbl)
d291 2
a292 1
GDENTRY(blkend)
@


1.10
log
@hack: if bootloader is passed some magic, assume new-style soon-to-be
El Torito sorta boot

I’m doing this now since I don’t want this to wait for the other changes
required in the bootloading process… it’ll take long to get right

hacked in Chaostreff Basel, Muttenz, .ch, with bsiegert@@ sitting next to me
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/bootxx/bootxx.S,v 1.9 2007/09/28 20:51:27 tg Exp $ */
d4 1
a4 1
 * Copyright (c) 2003, 2004, 2005, 2007
a12 4
 * Advertising materials mentioning features or use of this work must
 * display the following acknowledgement:
 *	This product includes material provided by Thorsten Glaser.
 *
d208 1
a208 7
	mov	eax,0x6A6D4F00
	/* manipulate here, but first byte MBZ */
	magicofs = . - 3
	.globl	magicofs

	xchg	eax,dword ptr fs:[0x50]
	cmp	eax,0x6A6D4F00
@


1.9
log
@fix typo
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/bootxx/bootxx.S,v 1.8 2007/05/26 21:57:39 tg Exp $ */
d175 2
d212 7
a218 1
	cmp	dword ptr fs:[0x50],0x6A6D4F00
@


1.8
log
@by data corruption, the live cd was unable to boot as live HDD in qemu
we assumed the BIOS would not trash the high 16 bits of eax… sounds as
if that weren't true, and DOS debug.com is an 8086 debugger only and I
thusly was unaware of it. initialise eax back to zero before using it.
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/bootxx/bootxx.S,v 1.7 2007/02/26 17:39:10 tg Exp $ */
d42 1
a42 1
	/* set up stack from 07A0:FFFC (0x179FC) down */
@


1.7
log
@if 256 heads are allowed, don't pass them as 0 heads, d'oh
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/bootxx/bootxx.S,v 1.6 2007/02/26 04:08:56 tg Exp $ */
d149 1
d166 1
a166 1
	and	ax,0x1F
d169 1
a169 1
	stosd			/* high 16 bits of eax should be zero */
@


1.6
log
@if shift is pressed (no 3 sec delay like in livecd boot tho, sorry)
it will now directly switch to 1-sector mode

known to not work in qemu due to emulation constraints (some ops
are infinitesimally quick), but using -1 to installboot(8) works
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/bootxx/bootxx.S,v 1.5 2007/02/26 03:53:00 tg Exp $ */
d118 1
a118 1
	xchg	bh,[bpbtpc+1]
@


1.5
log
@improve progress meter
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/bootxx/bootxx.S,v 1.4 2007/02/26 03:07:07 tg Exp $ */
d120 7
a126 1
	jnz	LbCHS
@


1.4
log
@I'm stupid
* lodsb+stosb -> movsb
* forgot the padding (stosw is smaller than stosd, I know it's slower…)
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/bootxx/bootxx.S,v 1.3 2007/02/26 02:52:46 tg Exp $ */
a193 4
	/* progress meter */
	mov	ax,0x0E2E
	mov	bx,7
	int	0x10			/* output a dot */
d263 6
d275 1
a275 3
	xor	ax,ax
	int	0x13
	mov	ax,0x0E40		/* say it fails */
d279 2
@


1.3
log
@no, we do need the sectors count for CHS conversation;
on the other hand, the high bytes of head (and sector)
count values are free to use, e.g. for flags…
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/bootxx/bootxx.S,v 1.2 2007/02/26 02:35:04 tg Exp $ */
d172 1
a172 2
Lmlp2:	lodsb			/* copy over as many bytes as needed */
	stosb
d175 5
@


1.2
log
@fix loadseg handling
@
text
@d1 1
a1 1
/* $MirOS: src/sys/arch/i386/stand/bootxx/bootxx.S,v 1.1 2007/02/26 02:11:33 tg Exp $ */
d118 3
a120 2
	cmp	word ptr [bpbspt],1
	je	LbCHS
@


1.1
log
@switch to a newer, more compact, PBR as well
@
text
@d1 1
a1 1
/* $MirOS: src/share/misc/licence.template,v 1.20 2006/12/11 21:04:56 tg Rel $ */
d116 5
a120 1
	/* check for LBA */
d124 1
d131 1
a131 1
LbCHS:	mov	word ptr ds:[Lldp],offset LsCHS
d165 1
a165 1
	shl	bx,(9-4)	/* number of sectors, times their size,
d229 1
a229 3
	mov	ax,es
	add	ax,32			/* size of a sector in paragraphs */
	mov	es,ax
d258 1
a258 2
	push	fs
	pop	es
@

