head	1.28;
access;
symbols
	tg-use_ldscript:1.25.0.2
	MIRBSD_10:1.5.0.2
	MIRBSD_10_BASE:1.5;
locks; strict;
comment	@# @;


1.28
date	2010.11.12.21.20.35;	author tg;	state Exp;
branches;
next	1.27;
commitid	1004CDDAFAA23CF5BA6;

1.27
date	2010.11.12.21.11.00;	author tg;	state Exp;
branches;
next	1.26;
commitid	1004CDDAD6A6CDD2454;

1.26
date	2010.11.12.21.05.26;	author tg;	state Exp;
branches;
next	1.25;
commitid	1004CDDAC25755F9C62;

1.25
date	2009.07.24.16.27.56;	author tg;	state Exp;
branches;
next	1.24;
commitid	1004A69E120646108E1;

1.24
date	2009.06.29.20.51.00;	author tg;	state Exp;
branches;
next	1.23;
commitid	1004A49292C66B6FB4D;

1.23
date	2009.06.29.20.10.26;	author tg;	state Exp;
branches;
next	1.22;
commitid	1004A491FC3492C15C0;

1.22
date	2009.06.29.19.48.37;	author tg;	state Exp;
branches;
next	1.21;
commitid	1004A491AAB678758BF;

1.21
date	2009.06.29.16.41.13;	author tg;	state Exp;
branches;
next	1.20;
commitid	1004A48EE653AE90C2B;

1.20
date	2009.06.07.18.00.43;	author tg;	state Exp;
branches;
next	1.19;
commitid	1004A2C0054357910E7;

1.19
date	2009.06.07.17.53.29;	author tg;	state Exp;
branches;
next	1.18;
commitid	1004A2BFEA74B2413EE;

1.18
date	2009.06.07.13.07.46;	author tg;	state Exp;
branches;
next	1.17;
commitid	1004A2BBAFA4B0EDDF2;

1.17
date	2009.06.07.12.09.31;	author tg;	state Exp;
branches;
next	1.16;
commitid	1004A2BAE091FD8FFBE;

1.16
date	2009.06.07.11.30.23;	author tg;	state Exp;
branches;
next	1.15;
commitid	1004A2BA4A60120871F;

1.15
date	2009.02.08.20.47.48;	author tg;	state Exp;
branches;
next	1.14;
commitid	100498F45016F6A033E;

1.14
date	2009.02.02.22.50.28;	author tg;	state Exp;
branches;
next	1.13;
commitid	100498778BC0F208DDF;

1.13
date	2009.02.02.22.48.55;	author tg;	state Exp;
branches;
next	1.12;
commitid	100498778534FD0E23F;

1.12
date	2009.02.01.15.50.09;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004985C48E6A4A6925;

1.11
date	2009.01.31.18.59.18;	author tg;	state Exp;
branches;
next	1.10;
commitid	10049849F82428123D2;

1.10
date	2009.01.31.18.51.19;	author tg;	state Exp;
branches;
next	1.9;
commitid	10049849D7F07A9D7B9;

1.9
date	2009.01.02.05.01.46;	author tg;	state Exp;
branches;
next	1.8;
commitid	100495D9FCE7857009B;

1.8
date	2008.10.21.01.20.30;	author tg;	state Exp;
branches;
next	1.7;
commitid	10048FD2E7257A22B7B;

1.7
date	2008.10.20.23.15.38;	author tg;	state Exp;
branches;
next	1.6;
commitid	10048FD1115625F39EB;

1.6
date	2008.08.05.17.57.08;	author tg;	state Exp;
branches;
next	1.5;
commitid	100489894510593D3DC;

1.5
date	2008.03.03.13.56.41;	author tg;	state Exp;
branches;
next	1.4;
commitid	10047CC03862CFCEB4C;

1.4
date	2007.10.20.23.28.11;	author tg;	state Exp;
branches;
next	1.3;
commitid	100471A8F184C4BAFBF;

1.3
date	2007.10.20.22.40.18;	author tg;	state Exp;
branches;
next	1.2;
commitid	100471A83DA723D1788;

1.2
date	2007.10.20.21.59.02;	author tg;	state Exp;
branches;
next	1.1;
commitid	100471A7A3448802CAA;

1.1
date	2007.10.20.21.28.40;	author tg;	state Exp;
branches;
next	;
commitid	100471A730C69C24D84;


desc
@@


1.28
log
@• correct an option parsing bug
• capitalise Error and Warning like the sparc bootxx/mkbxinst do
@
text
@#!/bin/mksh
rcsid='$MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.27 2010/11/12 21:11:00 tg Exp $'
#-
# Copyright (c) 2007, 2008, 2009
#	Thorsten Glaser <tg@@mirbsd.org>
#
# Provided that these terms and disclaimer and all copyright notices
# are retained or reproduced in an accompanying document, permission
# is granted to deal in this work without restriction, including un-
# limited rights to use, publicly perform, distribute, sell, modify,
# merge, give away, or sublicence.
#
# This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
# the utmost extent permitted by applicable law, neither express nor
# implied; without malicious intent or gross negligence. In no event
# may a licensor, author or contributor be held liable for indirect,
# direct, other damage, loss, or other issues arising in any way out
# of dealing in the work, even if advised of the possibility of such
# damage or existence of a defect, except proven that it results out
# of said person's immediate fault when using the work as intended.
#-
# Create a self-installing bootxx for i386 (32 bit).
# Arguments: $1 = ELF (i386) bootxx, linked
# Output: shell script to stdout

function die {
	rv=$1; shift
	print -u2 -- "$@@"
	exit $rv
}

[[ -s $1 ]] || die 1 Cannot read input file "'$1'"

nm $1 |&
while read -p adr typ sym; do
	[[ $sym = @@(_start|bkcnt|bktbl|geomh|geoms|partp|secsz) ]] || continue
	eval typeset -i10 sym_$sym=0x\$adr
done

T=$(mktemp /tmp/bxinst.XXXXXXXXXX) || die 255 Cannot create temporary file
objcopy --set-section-flags .comment=alloc,contents,load,data \
    -O binary -j .comment $1 $T
rcsidS=$(<$T)
objcopy -O binary $1 $T
thecode=$(dd if=$T bs=1 count=$((sym_bktbl - sym__start)) 2>/dev/null | \
    hexdump -ve '1/1 "0x%02X "')
rm -f $T

print '#!/usr/bin/env mksh'
print "# $rcsid"
print "# \$miros:${rcsid#*:}"
print "# \$miros:${rcsidS#*:}"
cat <<'EOF'
#-
# Copyright (c) 2007, 2008, 2009, 2010
#	Thorsten Glaser <tg@@mirbsd.org>
#
# Provided that these terms and disclaimer and all copyright notices
# are retained or reproduced in an accompanying document, permission
# is granted to deal in this work without restriction, including un‐
# limited rights to use, publicly perform, distribute, sell, modify,
# merge, give away, or sublicence.
#
# This work is provided “AS IS” and WITHOUT WARRANTY of any kind, to
# the utmost extent permitted by applicable law, neither express nor
# implied; without malicious intent or gross negligence. In no event
# may a licensor, author or contributor be held liable for indirect,
# direct, other damage, loss, or other issues arising in any way out
# of dealing in the work, even if advised of the possibility of such
# damage or existence of a defect, except proven that it results out
# of said person’s immediate fault when using the work as intended.
#-
# Self-installing 32-bit x86 boot blocks for MirOS BSD/i386
# Reads a list of extents (firstblock lastblock) from standard input
# and writes bootxx to standard output, which can subsequentially be
# stored as partition boot record (or floppy boot sector) on disc.

EOF
print set -A thecode $thecode
print typeset -i ofs_bkcnt=$((sym_bkcnt - sym__start))
print typeset -i ofs_geomh=$((sym_geomh - sym__start))
print typeset -i ofs_geoms=$((sym_geoms - sym__start))
print typeset -i ofs_partp=$((sym_partp - sym__start))
print typeset -i ofs_secsz=$((sym_secsz - sym__start))
print typeset -i begptr=$((sym_bktbl - sym__start))
cat <<'EOF'
typeset -Uui8 thecode

typeset -Uui16 curptr=begptr
typeset -i wnum=0 wofs=0 wrec=0 bkend=0x1FE

function do_record {
	typeset -Ui blk=$1 cnt=$2 n
	typeset -Uui16 x=blk y

	(( blk && cnt )) || return

	print -u2 "$wrec @@0x${curptr#16#}: $cnt @@$blk (0x${x#16#})"

	while (( cnt )); do
		let wrec++
		(( n = blk < 0x00000100 ? 0 :
		    blk < 0x00010000 ? 1 :
		    blk < 0x01000000 ? 2 : 3 ))
		(( x = cnt < 33 ? cnt : 32 ))
		(( y = blk ))
		print -u2 " - 0x${curptr#16#}: $((x)) (0x${x#16#}) @@ $blk" \
		    "(0x${y#16#})"
		(( thecode[curptr++] = (n++ << 5) | (x - 1) ))
		(( blk += x ))
		(( cnt -= x ))
		while (( n-- )); do
			(( thecode[curptr++] = y & 0xFF ))
			(( y >>= 8 ))
		done
	done
}

function record_block {
	typeset -Ui blk=$1

	if (( !blk || (wofs && blk != (wofs + wnum)) )); then
		# flush the blocks from the cache
		(( wnum )) && do_record $wofs $wnum
		wofs=0
		wnum=0
	fi
	if (( blk )); then
		# record some new block into the cache
		(( wofs )) || let wofs=blk
		(( wnum += 1 << sscale ))
	fi
}

typeset -i partp=0 numheads=0 numsecs=0 sscale=0 bsh=9 mbrpno=0 mbrptp=0 pofs=0
set -A g_code 0 0 0

while getopts ":0:1AB:g:h:M:O:p:S:s:" ch; do
	case $ch {
	(0)	;;
	(1)	;;
	(A)	numheads=0
		numsecs=99
		;;
	(B)	if (( (bsh = OPTARG) < 9 || OPTARG > 15 )); then
			print -u2 Error: invalid block size "2^'$OPTARG'"
			exit 1
		fi
		;;
	(g)	if [[ $OPTARG != +([0-9]):+([0-9]):+([0-9]) ]]; then
			print -u2 Error: invalid geometry code "'$OPTARG'"
			exit 1
		fi
		saveIFS=$IFS
		IFS=:
		set -A g_code -- $OPTARG
		IFS=$saveIFS ;;
	(h)	if (( (numheads = OPTARG) < 1 || OPTARG > 256 )); then
			print -u2 Warning: invalid head count "'$OPTARG'"
			numheads=0
		fi ;;
	(M)	if [[ $OPTARG != +([0-9])?(:?(0[Xx])+([0-9])) ]]; then
			print -u2 Warning: invalid partition info "'$OPTARG'"
			mbrpno=0
			mbrptp=0
		else
			saveIFS=$IFS
			IFS=:
			set -A mbr_code -- $OPTARG
			IFS=$saveIFS
			(( mbrpno = mbr_code[0] ))
			(( mbrptp = mbr_code[1] ))
			if (( mbrpno < 1 || mbrpno > 4 )); then
				print -u2 Warning: invalid partition \
				    number "'$OPTARG'"
				mbrpno=0
			fi
			if (( mbrptp < 1 || mbrptp > 255 )); then
				print -u2 Warning: invalid partition \
				    type "'$OPTARG'"
				mbrptp=0
			fi
		fi ;;
	(O)	if [[ $OPTARG != +([0-9]) ]]; then
			print -u2 Warning: invalid partition offset "'$OPTARG'"
		else
			pofs=$OPTARG
		fi ;;
	(p)	if (( (partp = OPTARG) < 1 || OPTARG > 255 )); then
			print -u2 Warning: invalid partition type "'$OPTARG'"
			partp=0
		fi ;;
	(S)	if (( (sscale = OPTARG) < 0 || OPTARG > 24 )); then
			print -u2 Error: invalid input scale "'$OPTARG'"
			exit 1
		fi ;;
	(s)	if (( (numsecs = OPTARG) < 1 || OPTARG > 63 )); then
			print -u2 Warning: invalid sector count "'$OPTARG'"
			numsecs=0
		fi ;;
	(*)	print -u2 'Syntax:
	bxinst [-1A] [-B blocksize] [-g C:H:S] [-h heads] [-M pno(1..4)[:typ]]
	    [-O partitionofs] [-p type] [-S scale] [-s secs] <sectorlist | \\
	    dd of=image conv=notrunc
Default values: blocksize=9 heads=16 sectors=63 part.ofs=0 type=0x27 scale=0
    partno=4 if -g (create MBR partition) is given; -A = auto boot geometry'
		exit 1 ;;
	}
done
shift $((OPTIND - 1))

typeset -Ui psz=0	# must be unsigned
if (( g_code[0] )); then
	# bounds check partition table values, calculate total sectors
	if (( g_code[0] < 1 || g_code[1] < 1 || g_code[1] > 256 ||
	    g_code[2] < 1 || g_code[2] > 63 )); then
		print -u2 Invalid geometry, values out of bounds.
	elif [[ $(print "(${g_code[0]} * ${g_code[1]} * ${g_code[2]})" \
	    "> 4294967295" | bc) = 1 ]]; then
		print -u2 Invalid geometry, more than 2 TiB of data.
	else
		# we know it's <= 2^32-1
		(( psz = g_code[0] * g_code[1] * g_code[2] ))
	fi
fi
if (( psz )); then
	print -u2 geometry is $psz sectors \($(print \
	    "$psz * $((1 << bsh))" | bc) bytes\) in ${g_code[0]} cylinders, \
	    ${g_code[1]} heads, ${g_code[2]} sectors per track
	if (( numsecs == 0 || (numsecs != 99 && numheads == 0) )); then
		print -u2 Warning: using these values for C/H/S boot
		numheads=${g_code[1]}
		numsecs=${g_code[2]}
	fi
	(( mbrpno )) || mbrpno=4	# default partition number
fi
if (( mbrpno )); then
	bkend=0x1BE
	(( psz )) || print -u2 Warning: no geometry given, will not \
	    create an MBR partition table entry
fi

if (( numsecs == 99 )); then
	numheads=0
	numsecs=0
else
	if (( !numheads )); then
		print -u2 Warning: using default value of 16 heads
		numheads=16
	fi

	if (( !numsecs )); then
		print -u2 Warning: using default value of 63 sectors
		numsecs=63
	fi
fi

# read in the extents
while read firstblock lastblock junk; do
	while (( firstblock <= lastblock )); do
		record_block $((firstblock++ << sscale))
	done
done
record_block 0	# just flush
print -u2 "using $wrec blocks, $((curptr-begptr)) bytes ($((bkend-curptr)) free)"

# fill the block table
if (( curptr-- > bkend )); then
	print -u2 Error: too many blocks
	exit 1
fi
while (( ++curptr < bkend )); do
EOF
if [[ $rcsidS = *@@(+s:BPB)* ]]; then cat <<'EOF'
	(( thecode[curptr] = RANDOM & 0xFF ))
EOF
else cat <<'EOF'
	(( thecode[curptr] = (curptr & 0xFCF) == 0x1C2 ? 0 : RANDOM & 0xFF ))
	# ensure the “active” flag is never set to 0x00 or 0x80
	if (( ((curptr + 2) & 0xFCF) == 0x01C0 )); then
		(( thecode[curptr] & 0x7F )) || let --curptr
	fi
EOF
fi
cat <<'EOF'
done
thecode[510]=0x55
thecode[511]=0xAA

# fill in other data
(( thecode[ofs_bkcnt] = wrec ))
(( thecode[ofs_geomh] = numheads & 0xFF ))
(( thecode[ofs_geomh + 1] = numheads >> 8 ))
(( thecode[ofs_geoms] = numsecs ))
(( thecode[ofs_partp] = partp ))
print -u2 "using sectors of 2^$bsh = $((1 << bsh)) bytes"
(( thecode[ofs_secsz] = (1 << (bsh - 8)) ))

# create an MBR partition if desired
if (( psz )); then
	(( mbrpno = 0x1BE + ((mbrpno - 1) * 16) ))
	set -A o_code	# g_code equivalent for partition offset
	(( o_code[2] = pofs % g_code[2] + 1 ))
	(( o_code[1] = pofs / g_code[2] ))
	(( o_code[0] = o_code[1] / g_code[1] + 1 ))
	(( o_code[1] = o_code[1] % g_code[1] + 1 ))
	# boot flag; C/H/S offset
	thecode[mbrpno++]=0x80
	(( thecode[mbrpno++] = o_code[1] - 1 ))
	(( cylno = o_code[0] > 1024 ? 1023 : o_code[0] - 1 ))
	(( thecode[mbrpno++] = o_code[2] | ((cylno & 0x0300) >> 2) ))
	(( thecode[mbrpno++] = cylno & 0x00FF ))
	# partition type; C/H/S end
	(( thecode[mbrpno++] = (mbrptp ? mbrptp : partp ? partp : 0x27) ))
	(( thecode[mbrpno++] = g_code[1] - 1 ))
	(( cylno = g_code[0] > 1024 ? 1023 : g_code[0] - 1 ))
	(( thecode[mbrpno++] = g_code[2] | ((cylno & 0x0300) >> 2) ))
	(( thecode[mbrpno++] = cylno & 0x00FF ))
	# partition offset, size (LBA)
	(( thecode[mbrpno++] = pofs & 0xFF ))
	(( thecode[mbrpno++] = (pofs >> 8) & 0xFF ))
	(( thecode[mbrpno++] = (pofs >> 16) & 0xFF ))
	(( thecode[mbrpno++] = (pofs >> 24) & 0xFF ))
	(( pssz = psz - pofs ))
	(( thecode[mbrpno++] = pssz & 0xFF ))
	(( thecode[mbrpno++] = (pssz >> 8) & 0xFF ))
	(( thecode[mbrpno++] = (pssz >> 16) & 0xFF ))
	(( thecode[mbrpno++] = (pssz >> 24) & 0xFF ))
fi

# create the output string
ostr=
curptr=0
while (( curptr < 512 )); do
	ostr=$ostr\\0${thecode[curptr++]#8#}
done

# over and out
print -n "$ostr"
exit 0
EOF
exit 0
@


1.27
log
@ouch, partition size is ≠ partition end if non-zero offset is present…
@
text
@d2 1
a2 1
rcsid='$MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.26 2010/11/12 21:05:26 tg Exp $'
d146 1
a146 1
			print -u2 error: invalid block size "2^'$OPTARG'"
d159 1
a159 1
			print -u2 warning: invalid head count "'$OPTARG'"
d163 1
a163 1
			print -u2 warning: invalid partition info "'$OPTARG'"
d166 17
a182 14
		fi
		saveIFS=$IFS
		IFS=:
		set -A mbr_code -- $OPTARG
		IFS=$saveIFS
		(( mbrpno = mbr_code[0] ))
		(( mbrptp = mbr_code[1] ))
		if (( mbrpno < 1 || mbrpno > 4 )); then
			print -u2 warning: invalid partition number "'$OPTARG'"
			mbrpno=0
		fi
		if (( mbrptp < 1 || mbrptp > 255 )); then
			print -u2 warning: invalid partition type "'$OPTARG'"
			mbrptp=0
d185 1
a185 1
			print -u2 warning: invalid partition offset "'$OPTARG'"
d190 1
a190 1
			print -u2 warning: invalid partition type "'$OPTARG'"
d194 1
a194 1
			print -u2 error: invalid input scale "'$OPTARG'"
d198 1
a198 1
			print -u2 warning: invalid sector count "'$OPTARG'"
d231 1
a231 1
		print -u2 warning: using these values for C/H/S boot
d239 1
a239 1
	(( psz )) || print -u2 warning: no geometry given, will not \
d248 1
a248 1
		print -u2 warning: using default value of 16 heads
d253 1
a253 1
		print -u2 warning: using default value of 63 sectors
d269 1
a269 1
	print -u2 error: too many blocks
@


1.26
log
@implement partition offset (experimental) for wbx@@
@
text
@d2 1
a2 1
rcsid='$MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.25 2009/07/24 16:27:56 tg Exp $'
d321 5
a325 4
	(( thecode[mbrpno++] = psz & 0xFF ))
	(( thecode[mbrpno++] = (psz >> 8) & 0xFF ))
	(( thecode[mbrpno++] = (psz >> 16) & 0xFF ))
	(( thecode[mbrpno++] = (psz >> 24) & 0xFF ))
@


1.25
log
@sync usage for r1.21
@
text
@d2 1
a2 1
rcsid='$MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.24 2009/06/29 20:51:00 tg Exp $'
d55 1
a55 1
# Copyright (c) 2007, 2008, 2009
d135 1
a135 1
typeset -i partp=0 numheads=0 numsecs=0 sscale=0 bsh=9 mbrpno=0 mbrptp=0
d138 1
a138 1
while getopts ":0:1AB:g:h:M:p:S:s:" ch; do
d181 5
d200 1
a200 1
	    [-p partitiontype] [-S scale] [-s sectors] <sectorlist | \\
d202 1
a202 1
Default values: blocksize=9 heads=16 sectors=63 partitiontype=0x27 scale=0
d299 6
d306 5
a310 3
	thecode[mbrpno++]=0
	thecode[mbrpno++]=1
	thecode[mbrpno++]=0
d316 5
a320 4
	thecode[mbrpno++]=0
	thecode[mbrpno++]=0
	thecode[mbrpno++]=0
	thecode[mbrpno++]=0
@


1.24
log
@• sync cleanfiles
• use parsable "feature indicators" in the rcs id
• if BPB, don’t not-do $RANDOM in the MBR places, there is no ptab…
@
text
@d2 1
a2 1
rcsid='$MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.23 2009/06/29 20:10:26 tg Exp $'
d194 1
a194 1
	bxinst [-1A] [-B blocksize] [-g C:H:S] [-h heads] [-M partno(1..4)]
@


1.23
log
@preserve bootxx.S rcsid in bxinst.sh
@
text
@d2 1
a2 1
rcsid='$MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.22 2009/06/29 19:48:37 tg Exp $'
d265 5
d275 3
@


1.22
log
@unsigned
@
text
@d2 1
a2 1
rcsid='$MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.21 2009/06/29 16:41:13 tg Exp $'
d41 3
d52 1
@


1.21
log
@enhance the -M option with a second, optional, colon-separated argument
denoting the partition type to use for creating the pseudo MBR partiti-
on instead of the -p argument or the default of 0x27, to be used with a
MirBSD™ bootloader which wants to read from 0x27 for disklabels but use
the 0x96 type for ISO 9660 filesystems on a CD
@
text
@d2 1
a2 1
rcsid='$MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.20 2009/06/07 18:00:43 tg Exp $'
d89 1
a89 1
	typeset -i blk=$1 cnt=$2 n
d116 1
a116 1
	typeset -i sv blk=$1
@


1.20
log
@fix the partition table (end cylinder off-by-one)
@
text
@d2 1
a2 1
rcsid='$MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.19 2009/06/07 17:53:29 tg Exp $'
d131 1
a131 1
typeset -i partp=0 numheads=0 numsecs=0 sscale=0 bsh=9 mbrpno=0
d158 12
a169 1
	(M)	if (( (mbrpno = OPTARG) < 1 || OPTARG > 4 )); then
d172 4
d286 1
a286 1
	(( thecode[mbrpno++] = (partp ? partp : 0x27) ))
@


1.19
log
@typo, caught debugging grml2usb.git/grml2iso
@
text
@d2 1
a2 1
rcsid='$MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.18 2009/06/07 13:07:46 tg Exp $'
d273 1
a273 1
	(( cylno = g_code[0] > 1023 ? 1023 : g_code[0] ))
@


1.18
log
@The ability to generate a partition table and a partition for the grml
manifold-boot™ ISO without having to sacrifice these 64 bytes of block
table beforehand (bxinst only) by means of two new options:
• -g C:H:S works like bxinst.sparc and initiates creating a partition
• -M no (no=1‥4) makes room for the partition table

If neither -g nor -M are given, nothing is changed.
If -g and -M are given and valid, a partition is created with these values.
If -g is given but -M isn’t, it defaults to the last partition.
If -M is given but -g isn’t, the partition table is merely NUL’d.

The partition type passed from the -p option will be used.
@
text
@d2 1
a2 1
rcsid='$MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.17 2009/06/07 12:09:31 tg Exp $'
d191 1
a191 1
	elif [[ $(print "(${g_code[0]} * ${g_code[1]} * {g_code[2]})" \
@


1.17
log
@make the block end into a variable, similar to installboot(8), but const
@
text
@d2 1
a2 1
rcsid='$MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.16 2009/06/07 11:30:23 tg Exp $'
d86 1
a86 1
typeset -i wnum=0 wofs=0 wrec=0 bkend=510
d131 2
a132 1
typeset -i partp=0 numheads=0 numsecs=0 sscale=0 bsh=9
d134 1
a134 1
while getopts ":0:1AB:h:p:S:s:" ch; do
d146 8
d158 4
d175 5
a179 3
	bxinst [-1A] [-B blocksize] [-h heads] [-p partitiontype] [-S scale]
	    [-s sectors] <sectorlist | dd of=image conv=notrunc
Default values: blocksize=9 heads=16 sectors=63 partitiontype=0x27 scale=0'
d185 31
d264 22
@


1.16
log
@Implement Auto-Geometry Detection feature, which, since we’re being used
by grml for manifold-boot™ ISOs over isohybrid, was a feature request by
Mika Prokop. Tested with floppies in qemu; only affects CHS not LBA.
@
text
@d2 1
a2 1
rcsid='$MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.15 2009/02/08 20:47:48 tg Exp $'
d86 1
a86 1
typeset -i wnum=0 wofs=0 wrec=0
d192 1
a192 1
print -u2 "using $wrec blocks, $((curptr-begptr)) bytes ($((510-curptr)) free)"
d195 1
a195 1
if (( curptr-- > 510 )); then
d199 1
a199 1
while (( ++curptr < 510 )); do
@


1.15
log
@limit sector size to [9;15] instead of [8;15] log2
(256 byte sectors are no longer supported)

this is in preparation of a bootxx change (bugfix)
@
text
@d2 1
a2 1
rcsid='$MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.14 2009/02/02 22:50:28 tg Exp $'
d133 1
a133 1
while getopts ":0:1B:h:p:S:s:" ch; do
d137 3
d162 1
a162 1
	bxinst [-1] [-B blocksize] [-h heads] [-p partitiontype] [-S scale]
d170 8
a177 4
if (( !numheads )); then
	print -u2 warning: using default value of 16 heads
	numheads=16
fi
d179 4
a182 3
if (( !numsecs )); then
	print -u2 warning: using default value of 63 sectors
	numsecs=63
@


1.14
log
@and just because I don’t like rev 1.13, remove some optimisation making
it slower anyway
@
text
@d2 1
a2 1
rcsid='$MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.13 2009/02/02 22:48:55 tg Exp $'
d137 1
a137 1
	(B)	if (( (bsh = OPTARG) < 8 || OPTARG > 15 )); then
@


1.13
log
@fix wrong block count being displayed in some cases bug
(the sum of the individual entries was correct)

leftover from an older cosmetic
@
text
@d2 1
a2 1
rcsid='$MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.12 2009/02/01 15:50:09 tg Exp $'
d208 1
a208 1
(( bsh == 9 )) || (( thecode[ofs_secsz] = (1 << (bsh - 8)) ))
@


1.12
log
@• in the sparc self-installing boot blocks, create a _working_ i386
  CD-ROM disklabel iff -0 is used and a geometry is given
  (the exact values, such as device type ATAPI, are currently hard-
  coded, but the pack name and geometry can be used)
  ‣ this matches the -0 behaviour for the Sun disklabel
• clean these two up a little
@
text
@d2 1
a2 1
rcsid='$MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.11 2009/01/31 18:59:18 tg Exp $'
d89 1
a89 2
	typeset -i blk=$1 cnt=$2
	typeset -i n=cnt+100
d94 1
a94 1
	print -u2 "$wrec @@0x${curptr#16#}: ${n#1} @@$blk (0x${x#16#})"
@


1.11
log
@do not split any more, but display the splitting by entry boundaries
@
text
@d2 1
a2 1
rcsid='$MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.10 2009/01/31 18:51:19 tg Exp $'
d22 2
a23 2
# Create a self-installing bootxx for i386.
# Arguments: $1 = ELF bootxx, linked
d40 1
a40 1
T=$(mktemp /tmp/tmp.XXXXXXXXXX) || die 255 Cannot create temporary file
d69 1
a69 1
# Self-installing i386 boot blocks for MirOS BSD
@


1.10
log
@new bootmagic, bootxx: reading only one sector at a time, ignoring
what the BIOS thinks it can do or cannot…

note: bootxx.sh (self-installing bootblocks) and installboot(8/i386)
both still break up entries at track boundaries, which is no longer
needed because of the single-sector reads
@
text
@d2 1
a2 1
rcsid='$MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.9 2009/01/02 05:01:46 tg Exp $'
d103 3
a106 1
		(( y = blk ))
d121 1
a121 15
		if (( wnum )); then
			if (( (sv = wofs % numsecs) < (numsecs - 1) )); then
				(( sv = numsecs - sv ))
				(( sv = sv > wnum ? wnum : sv ))
				do_record $wofs $sv
				let wofs+=sv wnum-=sv
			fi

			while (( wnum > numsecs )); do
				do_record $wofs $numsecs
				let wofs+=numsecs wnum-=numsecs
			done

			(( wnum )) && do_record $wofs $wnum
		fi
@


1.9
log
@remove the kludge now
@
text
@d2 1
a2 1
rcsid='$MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.8 2008/10/21 01:20:30 tg Exp $'
d36 1
a36 1
	[[ $sym = @@(_start|blkcnt|blktbl|bpbspt|bpbtpc|partp|secsizofs) ]] || continue
d42 1
a42 2
thecode=$(dd if=$T bs=1\
    skip=$sym__start count=$((sym_blktbl - sym__start)) 2>/dev/null | \
d76 3
a78 3
print typeset -i ofs_blkcnt=$((sym_blkcnt - sym__start))
print typeset -i ofs_numheads=$((sym_bpbtpc - sym__start))
print typeset -i ofs_numsecs=$((sym_bpbspt - sym__start))
d80 2
a81 2
print typeset -i begptr=$((sym_blktbl - sym__start))
print typeset -i ofs_secsiz=$((sym_secsizofs - sym__start))
d144 1
a144 1
typeset -i flag_one=0 partp=0 numheads=0 numsecs=0 sscale=0 bsz=5
d149 2
a150 2
	(1)	flag_one=1 ;;
	(B)	if (( (bsz = OPTARG) < 4 || OPTARG > 15 )); then
a153 5
		if (( (bsz != 9) && (bsz != 11) )); then
			print -u2 error: cannot handle blocks !512 !2048 yet
			exit 1	# for now
		fi
		(( bsz -= 4 ))
d172 1
a172 1
	bxinst [-1] [-h heads] [-p partitiontype] [-S scale]
d174 1
a174 1
Default values: heads=16 sectors=63 partitiontype=0x27 scale=0'
d206 4
d215 4
a218 5
(( thecode[ofs_blkcnt] = wrec ))
(( thecode[ofs_numheads] = numheads & 0xFF ))
(( thecode[ofs_numheads + 1] = numheads >> 8 ))
(( thecode[ofs_numsecs] = numsecs ))
(( flag_one )) && thecode[ofs_numsecs + 1]=0x80
d220 2
a221 4
if (( bsz != 5 )); then
	print -u2 "using sectors of 2^$((bsz + 4)) bytes"
	(( thecode[ofs_secsiz] = bsz ))
fi
@


1.8
log
@mop up
@
text
@d2 1
a2 1
rcsid='$MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.7 2008/10/20 23:15:38 tg Exp $'
d4 2
a5 2
# Copyright (c) 2007, 2008
#	Thorsten Glaser <tg@@mirbsd.de>
a12 4
# Advertising materials mentioning features or use of this work must
# display the following acknowledgement:
#	This product includes material provided by Thorsten Glaser.
#
d36 1
a36 1
	[[ $sym = @@(_start|blkcnt|blktbl|bpbspt|bpbtpc|partp|magicofs|secsizofs) ]] || continue
d52 2
a53 2
# Copyright (c) 2007, 2008
#	Thorsten Glaser <tg@@mirbsd.de>
a81 1
print typeset -i ofs_magic=$((sym_magicofs - sym__start))
a225 1
	(( thecode[ofs_magic]++ ))
@


1.7
log
@what began as simple sparc output correcture let me see what a mess this is…
@
text
@d2 1
a2 1
# $MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.6 2008/08/05 17:57:08 tg Exp $
a29 2
rcsid='$MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.6 2008/08/05 17:57:08 tg Exp $'

d89 1
a236 1
typeset -Uui8 thecode
@


1.6
log
@hack: if bootloader is passed some magic, assume new-style soon-to-be
El Torito sorta boot

I’m doing this now since I don’t want this to wait for the other changes
required in the bootloading process… it’ll take long to get right

hacked in Chaostreff Basel, Muttenz, .ch, with bsiegert@@ sitting next to me
@
text
@d2 1
a2 1
# $MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.5 2008/03/03 13:56:41 tg Exp $
d30 1
a30 1
rcsid='$MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.5 2008/03/03 13:56:41 tg Exp $'
d63 1
a63 1
# is granted to deal in this work without restriction, including un-
d67 1
a67 1
# This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
d74 1
a74 1
# of said person's immediate fault when using the work as intended.
d110 1
a110 1
		(( thecode[curptr++] = (n << 5) | (x - 1) ))
a113 1
		(( n++ ))
d141 2
a142 1
		let wofs=0 wnum=0
d183 1
a183 2
	(*)	cat >&2 <<'EOD'
Syntax:
d186 1
a186 2
Default values: heads=16 sectors=63 partitiontype=0x27 scale=0
EOD
d212 1
a212 1
if (( curptr > 510 )); then
d216 2
a217 6
while (( curptr < 510 )); do
	if (( (curptr & 0xFCF) == 0x1C2 )); then
		(( thecode[curptr++] = 0 ))
	else
		(( thecode[curptr++] = RANDOM & 0xFF ))
	fi
d219 2
a220 2
(( thecode[curptr++] = 0x55 ))
(( thecode[curptr++] = 0xAA ))
d227 1
a227 1
(( flag_one )) && (( thecode[ofs_numsecs + 1] = 0x80 ))
d238 1
a238 1
typeset -Uui8 vo
d240 1
a240 2
	(( vo = thecode[curptr++] ))
	ostr="$ostr\\0${vo#8#}"
@


1.5
log
@since objcopy trashes /dev/stdout permissions when asked to use that
as the output “file” and there seems to be no easy way to fix this
in the source, use a temporary file ourselfes

GNU saftware sucks, after all…
@
text
@d2 1
a2 1
# $MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.4 2007/10/20 23:28:11 tg Exp $
d30 1
a30 1
rcsid='$MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.4 2007/10/20 23:28:11 tg Exp $'
d42 1
a42 1
	[[ $sym = @@(_start|blkcnt|blktbl|bpbspt|bpbtpc|partp) ]] || continue
d58 1
a58 1
# Copyright (c) 2007
d88 2
d151 1
a151 1
typeset -i flag_one=0 partp=0 numheads=0 numsecs=0 sscale=0
d153 1
a153 1
while getopts ":0:1h:p:S:s:" ch; do
d157 10
d235 5
@


1.4
log
@make the -0 option have an argument, use that for chaining stuff
@
text
@d2 1
a2 1
# $MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.3 2007/10/20 22:40:18 tg Exp $
d4 1
a4 1
# Copyright (c) 2007
d30 1
a30 1
rcsid='$MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.3 2007/10/20 22:40:18 tg Exp $'
d46 4
a49 2
thecode=$(objcopy -O binary $1 /dev/stdout | \
    dd bs=1 skip=$sym__start count=$((sym_blktbl - sym__start)) 2>/dev/null | \
d51 1
@


1.3
log
@add new flag -0: make this sector-0-based
(no-op for i386, prepends a couple of zeroes for sparc)
@
text
@d2 1
a2 1
# $MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.2 2007/10/20 21:59:02 tg Exp $
d30 1
a30 1
rcsid='$MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.2 2007/10/20 21:59:02 tg Exp $'
d148 1
a148 1
while getopts ":01h:p:S:s:" ch; do
@


1.2
log
@enable the entropy addition
@
text
@d2 1
a2 1
# $MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.1 2007/10/20 21:28:40 tg Exp $
d30 1
a30 1
rcsid='$MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.1 2007/10/20 21:28:40 tg Exp $'
d148 1
a148 1
while getopts ":1h:p:S:s:" ch; do
d150 1
@


1.1
log
@self-installing boot blocks for i386, yay!
@
text
@d2 1
a2 1
# $MirOS: src/share/misc/licence.template,v 1.20 2006/12/11 21:04:56 tg Rel $
d30 1
a30 1
rcsid='$MirOS: src/sys/arch/sparc/stand/bootxx/mkbxinst.sh,v 1.2 2007/10/20 20:25:32 tg Exp $'
d203 1
a203 1
#	if (( curptr & 0xFCF == 0x1C2 )); then
d205 3
a207 3
#	else
#		(( thecode[curptr++] = RANDOM & 0xFF ))
#	fi
@

