head	1.19;
access;
symbols
	tg-use_ldscript:1.18.0.2
	tg-beforemerge-ksrc10:1.1.1.3
	cvs-200808011000:1.1.1.3
	MIRBSD_10:1.4.0.2
	MIRBSD_10_BASE:1.4
	MIRBSD_9_BASE:1.3
	MIRBSD_8:1.3.0.2
	MIRBSD_8_BASE:1.3
	cvs-200507032030:1.1.1.2
	cvs-200505050030:1.1.1.2
	cvs-200504302230:1.1.1.2
	cvs-200504291700:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2010.01.10.20.18.54;	author tg;	state Exp;
branches;
next	1.18;
commitid	1004B4A3588743BF0D3;

1.18
date	2009.10.04.16.49.43;	author tg;	state Exp;
branches;
next	1.17;
commitid	1004AC8D234283AB203;

1.17
date	2009.08.11.13.23.59;	author tg;	state Exp;
branches;
next	1.16;
commitid	1004A8170C73C4BAD74;

1.16
date	2009.08.11.11.06.24;	author tg;	state Exp;
branches;
next	1.15;
commitid	1004A8150C570570014;

1.15
date	2009.08.09.18.51.43;	author tg;	state Exp;
branches;
next	1.14;
commitid	1004A7F1A1B76A4634B;

1.14
date	2009.01.11.00.32.40;	author tg;	state Exp;
branches;
next	1.13;
commitid	10049693E0D60AE6F9B;

1.13
date	2009.01.10.23.05.28;	author tg;	state Exp;
branches;
next	1.12;
commitid	100496929CB3DC03F81;

1.12
date	2009.01.10.22.18.53;	author tg;	state Exp;
branches;
next	1.11;
commitid	10049691EDB67E0F5CA;

1.11
date	2009.01.10.20.28.28;	author tg;	state Exp;
branches;
next	1.10;
commitid	1004969050259BEA59F;

1.10
date	2009.01.10.14.49.04;	author tg;	state Exp;
branches;
next	1.9;
commitid	1004968B5690CAD8165;

1.9
date	2009.01.02.16.56.47;	author tg;	state Exp;
branches;
next	1.8;
commitid	100495E475F1C1A5BEF;

1.8
date	2009.01.02.04.58.41;	author tg;	state Exp;
branches;
next	1.7;
commitid	100495D9F177CADA327;

1.7
date	2009.01.01.23.27.46;	author tg;	state Exp;
branches;
next	1.6;
commitid	100495D518178CEC992;

1.6
date	2008.08.01.12.39.08;	author tg;	state Exp;
branches;
next	1.5;
commitid	100489303F432B4030A;

1.5
date	2008.08.01.11.24.59;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004892F2924667C00D;

1.4
date	2006.08.19.14.20.30;	author tg;	state Exp;
branches;
next	1.3;
commitid	10044E71E3D359AC2FA;

1.3
date	2005.04.29.18.34.59;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.06.21.27.06;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.27.29;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.27.29;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.29.17.05.47;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.08.01.10.28.38;	author tg;	state Exp;
branches;
next	;
commitid	1004892E54805BE97AB;


desc
@@


1.19
log
@• kern: new KERNISUSR (defined by libc and libmdsup, but not by either
  bootloader or kernel), enables new NUSRCS, UIF_NUSRCS
• move MD strncmp() to kern
• move MI {str,wcs}case{,n}cmp to kern
• make wcs* functions NU not KU as we don’t need them in the kernel YET
• move __main to NU (it’s a joke anyway, I think)
• bootloader: make devsw_prefix_match case-insensitive
@
text
@/**	$MirOS: src/sys/arch/i386/stand/libsa/dev_i386.c,v 1.18 2009/10/04 16:49:43 tg Exp $	*/
/*	$OpenBSD: dev_i386.c,v 1.30 2007/06/27 20:29:37 mk Exp $	*/

/*
 * Copyright (c) 2009 Thorsten Glaser
 * Copyright (c) 2004 Tom Cosgrove
 * Copyright (c) 1996-1999 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#define USE_PXE

#ifdef SMALL_BOOT
#undef USE_PXE
#endif

#include "libsa.h"
#include "biosdev.h"
#include <sys/param.h>
#include <dev/cons.h>
#include <sys/disklabel.h>
#include "disk.h"

extern int debug;

#ifdef USE_PXE
extern char use_bootmac;
#endif

/* XXX use slot for 'rd' for 'hd' pseudo-device */
const char bdevs[][4] = {
	"wd", "", "fd", "", "sd", "st", "cd", "mcd",
	"", "", "", "", "", "", "", "scd", "", "hd", ""
};
const int nbdevs = NENTS(bdevs);

const char cdevs[][4] = {
	"cn", "", "", "", "", "", "", "",
	"com", "", "", "", "pc"
};
const int ncdevs = NENTS(cdevs);

/* pass dev_t to the open routines */
int
devopen(struct open_file *f, const char *fname, char **file)
{
	char *cp;
	int rc = 1;
	struct devsw_prefix_match *dm;

	*file = cp = (char *)fname;

#ifdef DEBUG
	if (debug)
		printf("devopen(%s):", fname);
#endif

	/* get the colon-separated device prefix */
	while (*cp && *cp != ':')
		++cp;

	/**
	 * (*file) = "pref:rest"
	 * cp ------------^
	 */
#ifdef DEBUG
	if (debug) {
		if (*cp) {
			char *pp = *file;

			printf(" pfx:[");
			while (pp < cp)
				putchar(*pp++);
			putchar(']');
		} else
			printf(" {no prefix}");
	}
#endif
	for (dm = devsw_match; dm->devops; ++dm) {
#ifdef DEBUG
		if (debug)
			printf(" match?[%s%s%s]", dm->devops->dv_name,
			    dm->prefix[0] ? "?" : "", dm->prefix);
#endif
		if (dm->prefix[0])
			/*
			 * want a prefix; loop if the file has none
			 * or it does not match
			 */
			if (!*cp || strncasecmp(*file, dm->prefix,
			    cp - *file)) {
#ifdef DEBUG
				if (debug)
					printf("=NO");
#endif
				continue;
			}
		/* prefix matches or is not requested */
		f->f_ops = dm->fsops;
		f->f_dev = dm->devops;
		*file = dm->strip && *cp ? cp + 1 : (char *)fname;
		if ((rc = (*f->f_dev->dv_open)(f, file)) == 0) {
#ifdef USE_PXE
			use_bootmac = dm->networked;
#endif
#ifdef DEBUG
			if (debug)
				printf("=OK(%s) net=%d dev=%s fs=%s\n", *file,
				    dm->networked,
				    f->f_dev ? f->f_dev->dv_name : "(NULL)",
				    f->f_ops ? f->f_ops->name : "(NULL)");
#endif
			return (0);
		}
#ifdef DEBUG
		if (debug)
			printf("=%u", rc);
#endif
	}

	*file = (char *)fname;
	f->f_ops = NULL;
	if (f->f_flags & F_NODEV)
		f->f_dev = NULL;
	else
		/* XXX why? and is this correct? */
		f->f_dev = &devsw[0];
#ifdef DEBUG
	if (debug)
		printf(" FAIL %s%s\n", f->f_dev ? "dev=" : "nodev",
		    f->f_dev ? f->f_dev->dv_name : "");
#endif
	return (rc);
}

void
devboot(dev_t bootdev __unused, char *p)
{
	char *cp;
	if (start_dip) {
		cp = start_dip->name;
		while ((*p++ = *cp++))
			;
		--p;
		if (p[-1] >= '0' && p[-1] <= '9')
			*p++ = 'a';
	}
	*p = '\0';
}

int pch_pos = 0;

void
putchar(int c)
{
	switch (c) {
	case '\177':	/* DEL erases */
		cnputc('\b');
		cnputc(' ');
	case '\b':
		cnputc('\b');
		if (pch_pos)
			pch_pos--;
		break;
	case '\t':
		do
			cnputc(' ');
		while (++pch_pos % 8);
		break;
	case '\n':
	case '\r':
		cnputc(c);
		pch_pos=0;
		break;
	default:
		cnputc(c);
		pch_pos++;
		break;
	}
}

int
getchar(void)
{
	register int c = cngetc();

	if (c == '\r')
		c = '\n';

	if ((c < ' ' && c != '\n') || c == '\177')
		return c;

	putchar(c);

	return c;
}

char ttyname_buf[8];

char *
ttyname(int fd __unused)
{
	snprintf(ttyname_buf, sizeof ttyname_buf, "%s%d",
	    cdevs[major(cn_tab->cn_dev)], minor(cn_tab->cn_dev));

	return ttyname_buf;
}

dev_t
ttydev(char *name)
{
	int i, unit = -1;
	char *no = name + strlen(name) - 1;

	while (no >= name && *no >= '0' && *no <= '9')
		unit = (unit < 0 ? 0 : (unit * 10)) + *no-- - '0';
	if (no < name || unit < 0)
		return NODEV;
	for (i = 0; i < ncdevs; i++)
		if (strncmp(name, cdevs[i], no - name + 1) == 0)
			return (makedev(i, unit));
	return NODEV;
}

int
cnspeed(dev_t dev, int sp)
{
	if (major(dev) == 8)	/* comN */
		return (comspeed(dev, sp));

	/* pc0 and anything else */
	return 9600;
}
@


1.18
log
@more nonsensical code cleanup, I give up, this is horrid
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/dev_i386.c,v 1.17 2009/08/11 13:23:59 tg Exp $	*/
d111 2
a112 1
			if (!*cp || strncmp(*file, dm->prefix, cp - *file)) {
@


1.17
log
@Totally revamp the virtual device code.

Unbreak:
• floppy access (BIOS)
• hard disc access (BIOS)
• CD-ROM El Torito access (BIOS)
• cd9660, fat, ffs (filesystems)

Not tested:
• tftp, nfs (PXE, NET, filesystems)
• lmbmfs (lmbm)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/dev_i386.c,v 1.14 2009/01/11 00:32:40 tg Exp $	*/
d157 1
a157 1
devboot(dev_t bootdev, char *p)
d221 1
a221 1
ttyname(int fd)
@


1.16
log
@fix more debugging
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/dev_i386.c,v 1.15 2009/08/09 18:51:43 tg Exp $	*/
a46 6
#ifndef SMALL_BOOT
extern const char *fs_name[];
extern struct devsw *fs_type[];
extern int nfsname;
#endif

d48 1
a48 2
extern struct devsw netsw[];
extern char *bootmac;		/* gets passed to kernel for network boot */
d68 3
a70 5
	struct devsw *dp = devsw;
#ifndef SMALL_BOOT
	char *p, *stripdev;
#endif
	int i, rc = 1;
d72 1
a72 1
	*file = (char *)fname;
d79 8
a86 20
#ifndef SMALL_BOOT
	/* make sure we have a prefix, e.g. hd0a: or tftp: */
	for (p = (char *)fname; *p != ':' && *p != '\0'; ) p++;
	if (*p != ':')
		goto do_local;
	stripdev = p + 1;

	for (i = 0; i < nfsname; i++) {
		if ((fs_name[i] != NULL) &&
		    (strncmp(fname, fs_name[i], p - fname) == 0)) {

			/* Force oopen() etc to use this filesystem. */
			f->f_ops = &file_system[i];
			f->f_dev = dp = fs_type[i];

			rc = (*dp->dv_open)(f, NULL);
			if (rc == 0)
				*file = stripdev;
			else
				f->f_dev = NULL;
d88 10
a97 9
			if (debug)
				printf("(%s)\n", *file);
#endif
#ifdef USE_PXE
			if (fs_type[i] != &netsw[0])
				bootmac = NULL;
#endif
			return rc;
		}
a98 13

	/*
	 * Assume that any network filesystems would be caught by the
	 * code above, so that the next phase of devopen() is only for
	 * local devices.
	 *
	 * Clear bootmac, to signal that we loaded this file from a
	 * non-network device.
	 */
 do_local:
#ifdef USE_PXE
	bootmac = NULL;
#endif
d100 1
a100 2

	for (i = 0; i < ndevs && rc != 0; dp++, i++) {
d103 22
a124 1
			printf(" %s: ", dp->dv_name);
a125 2
		if ((rc = (*dp->dv_open)(f, file)) == 0) {
			f->f_dev = dp;
d127 5
a131 1
			printf("ok(%s)\n", *file);
d133 1
a133 1
			return 0;
d136 2
a137 2
		else if (debug)
			printf("%d", rc);
d139 1
d141 7
a147 1
	}
d150 2
a151 1
		putchar('\n');
d153 1
a153 5

	if ((f->f_flags & F_NODEV) == 0)
		f->f_dev = dp;

	return rc;
@


1.15
log
@Add new (virtual) filesystem “lmbm” (Loadable MultiBoot Modules, like LKM)
that contains the modules we got passed when loaded as Multiboot OS Kernel
as per the spec. Quirks:
• case sensitive
• supports “ls” on its (virtual) root directory
• does *not* support filesystems (cuts off both the directory part of the
  module string passed and the directory part when opening a file, but the
  root directory can only be opened as “/” or “/.” (or “lmbm:/”, etc.)
• assumes that we and all modules are loaded below 20 MiB in RAM
• moves modules on filesystem initialisation (virtual disc probe) to just
  above 20 MiB in RAM
• assumes the kernel will fit below 20 MiB in RAM, too
• does not affect non-multiboot operation
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/dev_i386.c,v 1.14 2009/01/11 00:32:40 tg Exp $	*/
d110 1
a110 1
				putchar('\n');
d141 3
@


1.14
log
@restore FFS and CD9660 boot from hard disc
maybe FFS from floppy (untested)

CD9660 from CD-ROM doesn't work yet
PXE (tftp) untested
PXE (nfs) – did it ever work? no idea…
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/dev_i386.c,v 1.13 2009/01/10 23:05:28 tg Exp $	*/
d47 1
a47 1
#ifdef USE_PXE
d49 1
d51 3
a54 1

d76 1
a76 1
#ifdef USE_PXE
d88 2
a89 2
#ifdef USE_PXE
	/* Make sure we have a prefix, e.g. hd0a: or tftp:. */
d101 1
a101 1
			f->f_dev = dp = &netsw[0];
d112 4
d129 1
d132 1
@


1.13
log
@device assignment
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/dev_i386.c,v 1.12 2009/01/10 22:18:53 tg Exp $	*/
d159 3
a161 1
		p[-1] = 'a';
@


1.12
log
@more work towards unifying devices (and network)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/dev_i386.c,v 1.11 2009/01/10 20:28:28 tg Exp $	*/
d42 2
d154 7
a160 18
#ifndef SMALL_BOOT
//	if (i386_toridev) {	//XXX
		*p++ = 'c';
		*p++ = 'd';
		*p++ = '0';
		*p++ = 'a';
		*p = '\0';
		printf(" (El Torito)");
		return;
//	}
#endif
	if (bootdev & 0x80)
		*p++ = 'h';
	else
		*p++ = 'f';
	*p++ = 'd';
	*p++ = '0' + (bootdev & 0x7f);
	*p++ = 'a';
@


1.11
log
@shuffle some defns around
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/dev_i386.c,v 1.10 2009/01/10 14:49:04 tg Exp $	*/
d5 2
d32 6
d45 8
d71 4
a74 1
	register int i, rc = 1;
d80 41
a120 1
		printf("devopen:");
@


1.10
log
@comment out tori stuff, will be merged into biosdev access
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/dev_i386.c,v 1.9 2009/01/02 16:56:47 tg Exp $	*/
a36 4
#ifndef SMALL_BOOT
int i386_bootdev;
#endif

a93 2
	i386_bootdev = bootdev;

@


1.9
log
@it's El Torito, not ISO 9660, which we check for
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/dev_i386.c,v 1.8 2009/01/02 04:58:41 tg Exp $	*/
a38 1
int i386_toridev = 0;
d100 1
a100 1
	if (i386_toridev) {
d108 1
a108 1
	}
@


1.8
log
@remove toridev kludge and probe the bios boot device for El Torito in
no emulation mode… if so, set the flag
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/dev_i386.c,v 1.7 2009/01/01 23:27:46 tg Exp $	*/
d107 1
a107 1
		printf(" (ISO 9660 device)");
@


1.7
log
@expose some more things beyond file scope
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/dev_i386.c,v 1.6 2008/08/01 12:39:08 tg Exp $	*/
d36 5
a40 1
extern u_int32_t tori_bootflag;
d99 1
a99 1
	extern int i386_bootdev;
d101 1
a101 2
	i386_bootdev = bootdev;
	if ((tori_bootflag) && (bootdev == (tori_bootflag & 0xFF))) {
@


1.6
log
@remove unused code (for testing the bootloader on unix)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/dev_i386.c,v 1.5 2008/08/01 11:24:59 tg Exp $	*/
d95 3
@


1.5
log
@merge and reduce diff to obsd
XXX not yet tested
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/dev_i386.c,v 1.4 2006/08/19 14:20:30 tg Exp $	*/
a93 8
#ifdef _TEST
	*p++ = '/';
	*p++ = 'd';
	*p++ = 'e';
	*p++ = 'v';
	*p++ = '/';
	*p++ = 'r';
#endif
@


1.4
log
@attempt to shrink fdboot even more
@
text
@d1 2
a2 2
/**	$MirOS: src/sys/arch/i386/stand/libsa/dev_i386.c,v 1.3 2005/04/29 18:34:59 tg Exp $	*/
/*	$OpenBSD: dev_i386.c,v 1.29 2004/06/23 00:21:49 tom Exp $	*/
d40 1
a40 1
	"wd", "", "fd", "wt", "sd", "st", "cd", "mcd",
@


1.3
log
@(tentative) merge, more to come
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/dev_i386.c,v 1.2 2005/03/06 21:27:06 tg Exp $	*/
d102 1
d112 1
@


1.2
log
@* merge src/sys/
  (at least the better part of it)
* revert IPv6 networking to OpenBSD, since
  I didn't get IPV4_MAPPED addresses working :(
@
text
@d1 2
a2 2
/**	$MirOS$	*/
/*	$OpenBSD: dev_i386.c,v 1.28 2004/03/09 19:12:12 tom Exp $	*/
@


1.1
log
@Initial revision
@
text
@d1 1
d36 1
d102 9
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@improve my Frankenstein OS (*wink* you know who you are) further
sans wchar_t of course

this is the essence of reading >1200 commit messages which suck
due to not having the new format of ours...
@
text
@d1 1
a1 1
/*	$OpenBSD: dev_i386.c,v 1.29 2004/06/23 00:21:49 tom Exp $	*/
d100 6
a105 12
	if (bootdev & 0x100) {
		*p++ = 'c';
		*p++ = 'd';
		*p++ = '0';
	} else {
		if (bootdev & 0x80)
			*p++ = 'h';
		else
			*p++ = 'f';
		*p++ = 'd';
		*p++ = '0' + (bootdev & 0x7f);
	}
@


1.1.1.3
log
@import bootloader-related pieces from openbsd, as first part of the
aspired 4.4 merge… and something else
@
text
@d1 1
a1 1
/*	$OpenBSD: dev_i386.c,v 1.30 2007/06/27 20:29:37 mk Exp $	*/
d38 1
a38 1
	"wd", "", "fd", "", "sd", "st", "cd", "mcd",
@


