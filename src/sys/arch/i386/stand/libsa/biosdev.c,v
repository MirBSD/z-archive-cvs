head	1.48;
access;
symbols
	tg-use_ldscript:1.44.0.2
	tg-beforemerge-ksrc10:1.1.1.3
	cvs-200808011000:1.1.1.3
	MIRBSD_10:1.5.0.2
	MIRBSD_10_BASE:1.5
	MIRBSD_9_BASE:1.4
	MIRBSD_8:1.4.0.2
	MIRBSD_8_BASE:1.4
	cvs-200507032030:1.1.1.2
	cvs-200505050030:1.1.1.2
	cvs-200504302230:1.1.1.2
	cvs-200504291700:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.48
date	2017.12.19.00.56.20;	author tg;	state Exp;
branches;
next	1.47;
commitid	1005A38636B714CDF30;

1.47
date	2012.12.23.19.19.48;	author tg;	state Exp;
branches;
next	1.46;
commitid	10050D7594151F63418;

1.46
date	2012.12.23.18.12.39;	author tg;	state Exp;
branches;
next	1.45;
commitid	10050D7496E5E30AA2A;

1.45
date	2010.01.10.19.21.37;	author tg;	state Exp;
branches;
next	1.44;
commitid	1004B4A28CB0F23DD4D;

1.44
date	2009.08.11.13.23.59;	author tg;	state Exp;
branches;
next	1.43;
commitid	1004A8170C73C4BAD74;

1.43
date	2009.08.11.10.53.35;	author tg;	state Exp;
branches;
next	1.42;
commitid	1004A814DC3707880DA;

1.42
date	2009.02.03.00.02.02;	author tg;	state Exp;
branches;
next	1.41;
commitid	1004987898A404A6C98;

1.41
date	2009.02.02.23.59.49;	author tg;	state Exp;
branches;
next	1.40;
commitid	1004987882B40CCE76D;

1.40
date	2009.02.01.14.39.19;	author tg;	state Exp;
branches;
next	1.39;
commitid	1004985B4163353DDF2;

1.39
date	2009.01.31.16.07.22;	author tg;	state Exp;
branches;
next	1.38;
commitid	1004984771A1EE4AE4D;

1.38
date	2009.01.26.15.27.08;	author tg;	state Exp;
branches;
next	1.37;
commitid	100497DD60F73F09573;

1.37
date	2009.01.11.22.49.51;	author tg;	state Exp;
branches;
next	1.36;
commitid	100496A779E6B72B416;

1.36
date	2009.01.11.17.18.33;	author tg;	state Exp;
branches;
next	1.35;
commitid	100496A29F9738E2C8A;

1.35
date	2009.01.11.17.14.45;	author tg;	state Exp;
branches;
next	1.34;
commitid	100496A29137974ACF0;

1.34
date	2009.01.11.17.08.29;	author tg;	state Exp;
branches;
next	1.33;
commitid	100496A279425497225;

1.33
date	2009.01.11.13.58.07;	author tg;	state Exp;
branches;
next	1.32;
commitid	1004969FAEE52C66E84;

1.32
date	2009.01.11.13.43.47;	author tg;	state Exp;
branches;
next	1.31;
commitid	1004969F7A61782737D;

1.31
date	2009.01.11.13.36.05;	author tg;	state Exp;
branches;
next	1.30;
commitid	1004969F59F7F1E8AC2;

1.30
date	2009.01.11.13.28.49;	author tg;	state Exp;
branches;
next	1.29;
commitid	1004969F42476354ECD;

1.29
date	2009.01.11.01.46.20;	author tg;	state Exp;
branches;
next	1.28;
commitid	10049694F4F21E414B8;

1.28
date	2009.01.11.00.32.40;	author tg;	state Exp;
branches;
next	1.27;
commitid	10049693E0D60AE6F9B;

1.27
date	2009.01.10.23.43.08;	author tg;	state Exp;
branches;
next	1.26;
commitid	100496932A33C227F0C;

1.26
date	2009.01.10.22.18.53;	author tg;	state Exp;
branches;
next	1.25;
commitid	10049691EDB67E0F5CA;

1.25
date	2009.01.10.20.28.27;	author tg;	state Exp;
branches;
next	1.24;
commitid	1004969050259BEA59F;

1.24
date	2009.01.10.18.15.10;	author tg;	state Exp;
branches;
next	1.23;
commitid	1004968E59B158ABED9;

1.23
date	2009.01.03.16.21.40;	author tg;	state Exp;
branches;
next	1.22;
commitid	100495F90934BC831F6;

1.22
date	2009.01.03.16.16.08;	author tg;	state Exp;
branches;
next	1.21;
commitid	100495F8F482340060E;

1.21
date	2009.01.03.16.14.24;	author tg;	state Exp;
branches;
next	1.20;
commitid	100495F8EF243D91BDC;

1.20
date	2009.01.03.13.43.33;	author tg;	state Exp;
branches;
next	1.19;
commitid	100495F6B566145BE45;

1.19
date	2009.01.02.05.16.34;	author tg;	state Exp;
branches;
next	1.18;
commitid	100495DA33F62ABDC14;

1.18
date	2009.01.01.17.46.20;	author tg;	state Exp;
branches;
next	1.17;
commitid	100495D00F40CC2CEE6;

1.17
date	2008.12.31.16.38.36;	author tg;	state Exp;
branches;
next	1.16;
commitid	100495BA02136D7BE32;

1.16
date	2008.12.31.16.37.38;	author tg;	state Exp;
branches;
next	1.15;
commitid	100495B9FDB3B73D341;

1.15
date	2008.12.28.21.23.24;	author tg;	state Exp;
branches;
next	1.14;
commitid	1004957EE6321FC5835;

1.14
date	2008.12.28.20.17.32;	author tg;	state Exp;
branches;
next	1.12;
commitid	1004957DEC40055D006;

1.12
date	2008.12.28.18.58.32;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004957CC6D6A3F15BA;

1.11
date	2008.12.28.18.57.28;	author tg;	state Exp;
branches;
next	1.10;
commitid	1004957CC277E585315;

1.10
date	2008.12.28.18.18.04;	author tg;	state Exp;
branches;
next	1.9;
commitid	1004957C2E623513D7B;

1.9
date	2008.12.28.05.45.10;	author tg;	state Exp;
branches;
next	1.8;
commitid	100495712664DD4921A;

1.8
date	2008.12.28.03.40.15;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004956F51A5A046245;

1.7
date	2008.11.08.23.04.07;	author tg;	state Exp;
branches;
next	1.6;
commitid	10049161AB22DF5DFC5;

1.6
date	2008.08.01.11.24.59;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004892F2924667C00D;

1.5
date	2006.08.19.14.20.29;	author tg;	state Exp;
branches;
next	1.4;
commitid	10044E71E3D359AC2FA;

1.4
date	2005.12.04.13.22.16;	author tg;	state Exp;
branches;
next	1.3;
commitid	3c454392ed956526;

1.3
date	2005.04.29.18.34.59;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.06.21.27.05;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.27.28;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.27.28;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.29.17.05.47;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.08.01.10.28.37;	author tg;	state Exp;
branches;
next	;
commitid	1004892E54805BE97AB;


desc
@@


1.48
log
@https → http, nowadays (unwillingly) considered proper
@
text
@/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.47 2012/12/23 19:19:48 tg Exp $ */
/*	$OpenBSD: biosdev.c,v 1.74 2008/06/25 15:32:18 reyk Exp $	*/

/*
 * Copyright (c) 1996 Michael Shalayeff
 * Copyright (c) 2003 Tobias Weingartner
 * Copyright (c) 2002, 2003, 2004, 2005, 2008, 2009, 2012
 *	Thorsten "mirabilos" Glaser <tg@@mirbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/reboot.h>
#include <sys/disklabel.h>
#include <machine/tss.h>
#include <machine/biosvar.h>
#include <lib/libsa/saerrno.h>
#include <lib/libsa/ustar.h>
#include <isofs/cd9660/iso.h>
#include "disk.h"
#include "debug.h"
#include "libsa.h"
#include "biosdev.h"

const char *biosdisk_err(u_int);
int biosdisk_errno(u_int);

extern int biosdev_lbaprobe(int drive);
extern int biosdev_CHS(int ah, int dev, int cyl, int head, int sec, int nsec);
extern int biosdev_LBA(int ah, int dev, u_int blk_lo, u_int blk_hi, int nsec);

extern int debug;
int i386_flag_oldbios = 0;

/*
 * reset disk system
 */
int
biosdreset(int dev)
{
	int rv;

	__asm __volatile (DOINT(0x13) "; setc %b0" : "=a" (rv)
	    : "0" (0), "d" (dev) : "%ecx", "cc");

	return ((rv & 0xff)? rv >> 8 : 0);
}

/*
 * Fill out a bios_diskinfo_t for this device.
 * Return 0 if all ok.
 * Return 1 if not ok.
 */
int
bios_getdiskinfo(int dev, bios_diskinfo_t *pdi)
{
	u_int rv;
	int lback;

	/* kernel interface, binary compatibility */
	pdi->old_bios_edd = -1;

	pdi->flags &= ~(BDI_LBA | BDI_EL_TORITO);
	lback = biosdev_lbaprobe(dev);

	/* Just reset, don't check return code */
	rv = biosdreset(dev);

	if (lback & 0x10) {
		pdi->bios_number = dev;
		/* CD-ROM, we don’t care what the BIOS says for CHS or LBA */
		pdi->bios_heads = 16;
		pdi->bios_cylinders = 16;
		pdi->bios_sectors = 32;
		/* http://www.mirbsd.org/permalinks/news_e20090126-tg.htm */
		pdi->flags |= BDI_LBA | BDI_EL_TORITO;
		pdi->old_bios_edd = (lback | 9) & 7;
		return (0);
	}

#ifdef BIOS_DEBUG
	if (debug)
		printf("getinfo: try #8, 0x%x, %p\n", dev, pdi);
#endif
	__asm __volatile (DOINT(0x13) "\n\t"
	    "setc %b0; movzbl %h1, %1\n\t"
	    "movzbl %%cl, %3; andb $0x3f, %b3\n\t"
	    "xchgb %%cl, %%ch; rolb $2, %%ch"
	    : "=a" (rv), "=d" (pdi->bios_heads),
	      "=c" (pdi->bios_cylinders),
	      "=b" (pdi->bios_sectors)
	    : "0" (0x0800), "1" (dev) : "cc");

#ifdef BIOS_DEBUG
	if (debug) {
		printf("getinfo: got #8\n");
		printf("disk 0x%x: %d,%d,%d\n", dev, pdi->bios_cylinders,
		    pdi->bios_heads, pdi->bios_sectors);
	}
#endif

	if (rv & 0xFF) {
		if ((lback & 0x09) != 0x09)
			return (1);
		printf("bios_getdiskinfo(%X): LBA but no CHS: %X\n", dev, lback);
		pdi->bios_heads = 15;
		pdi->bios_cylinders = 15;
		pdi->bios_sectors = 63;
	}

	/* Fix up info */
	pdi->bios_number = dev;
	pdi->bios_heads++;
	pdi->bios_cylinders &= 0x3ff;
	pdi->bios_cylinders++;

	if ((lback & 0x09) == 0x09) {
		pdi->flags |= BDI_LBA;
		pdi->old_bios_edd = lback & 7;
	} else if (pdi->bios_cylinders < 2 || pdi->bios_heads < 2 ||
	    pdi->bios_sectors < 1) {
#ifdef BIOS_DEBUG
		printf("sanity: c/h/s values insane: %d/%d/%d\n",
		    pdi->bios_cylinders, pdi->bios_heads, pdi->bios_sectors);
#endif
		return (1);
	}

	return (0);
}

/*
 * Read given sector, handling retry/errors/etc.
 */
int
biosd_io(int rw, bios_diskinfo_t *bd, daddr_t off, int nsect, void *buf)
{
	int rv, n, ssh = 0, i, spre = 0;
	volatile int c, h, s; /* fsck gcc, uninitialised it is not */

#ifndef SMALL_BOOT
	/* we do all I/O in 512 byte sectors, the El Torito BIOS doesn't */
	if (bd->flags & BDI_EL_TORITO) {
		ssh = 2;	/* sector shift */
		/* read only part of a CD sector */
		if (off & 3) {
			spre = off & 3;
			off -= spre;
			nsect += spre;
		}
		/* odd nsect does not matter, we read CDs one by one */
	}
#endif

 loop:
	n = (ssh || i386_flag_oldbios) ? 1 << ssh : MIN(nsect, 4096/512);
	if (!(bd->flags & BDI_LBA)) {
		/* note: BDI_EL_TORITO implies BDI_LBA, d/w about ssh here */
		btochs(off, c, h, s, bd->bios_heads, bd->bios_sectors);
		if (s + n >= bd->bios_sectors)
			n = bd->bios_sectors - s;
	}
	if ((buf || spre) && rw != F_READ)
		memmove(bounce_buf + spre * 512, buf ? buf : bounce_buf,
		    MIN(n - spre, nsect) * 512);
	/* try operation up to 5 times */
	rv = 1;
	i = 5;
	while (rv && i--) {
		if (bd->flags & BDI_LBA) {
#if 0
			printf(" trying biosdev_LBA(%X, %X, %d, %d, %d)",
			    rw == F_READ ? 0x42 : 0x43, bd->bios_number,
			    (int)((off >> ssh) & 0xFFFFFFFF),
			    (int)(sizeof (daddr_t) > 4 ?
			    (off >> ssh) >> 32 : 0), n >> ssh);
#endif
			rv = biosdev_LBA(rw == F_READ ? 0x42 : 0x43,
			    bd->bios_number, (off >> ssh) & 0xFFFFFFFF,
			    sizeof (daddr_t) > 4 ? (off >> ssh) >> 32 : 0,
			    n >> ssh);
		} else {
#if 0
			printf(" trying biosdev_CHS(%X, %X, %d, %d, %d, %d)",
			    rw == F_READ ? 0x02 : 0x03, bd->bios_number,
			    c, h, s, n);
#endif
			rv = biosdev_CHS(rw == F_READ ? 0x02 : 0x03,
			    bd->bios_number, c, h, s, n);
		}
/*		printf(" => %X\n", rv);	*/
		switch (rv) {
		case 0x11:	/* ECC corrected */
			rv = 0;
		case 0x00:	/* no errors */
			break;
		default:	/* all other errors */
#ifdef BIOS_DEBUG
			if (debug)
				printf("\nBIOS error 0x%X (%s)\n",
				    rv, biosdisk_err(rv));
#endif
			biosdreset(bd->bios_number);
			break;
		}
	}
#ifdef BIOS_DEBUG
	if (debug) {
		if (rv != 0)
			printf("=0x%x(%s)", rv, biosdisk_err(rv));
		putchar('\n');
	}
#endif
	if (rv)
		return (rv);
	if ((buf || spre) && rw == F_READ)
		memmove(buf ? buf : bounce_buf, bounce_buf + spre * 512,
		    MIN(n - spre, nsect) * 512);
	if ((nsect -= n) <= 0)
		return (0);
	if (!buf) {
#ifndef SMALL_BOOT
		printf("panic: cannot loop biosd_io on bounce_buf\n");
#endif
		return (0);
	}
	buf += (n - spre) * 512;
	off += n;
	spre = 0;
	goto loop;
}

/*
 * Try to read the bsd label on the given BIOS device
 */
const char *
bios_getdisklabel(bios_diskinfo_t *bd, struct disklabel *label)
{
	daddr_t off = 0;
	struct dos_mbr *mbr = (struct dos_mbr *)bounce_buf;
	int error, i;
	long mbrofs;

	/* Sanity check */
	if (bd->bios_heads == 0 || bd->bios_sectors == 0)
		return ("failed to read disklabel");

	/* MBR is a harddisk thing */
	if (bd->bios_number & 0x80) {
		/* Read MBR */
		mbrofs = DOSBBSECTOR;
 loop:
		error = biosd_io(F_READ, bd, mbrofs, 1, NULL);
		if (error)
			return (biosdisk_err(error));

		if (!memcmp((char *)mbr + offsetof(ustar_hdr_t, magic),
		    ustar_magic_version, sizeof(ustar_magic_version)))
			return "found ustar magic\n";

		/* check mbr signature */
		if (mbr->dmbr_sign != DOSMBR_SIGNATURE)
			return "bad MBR signature\n";

		/* extend all start offsets by mbrofs */
		for (i = 0; i < NDOSPART; i++)
			mbr->dmbr_parts[i].dp_start += mbrofs;

		/* Search for MirBSD partition */
		if (i386_userpt) for (i = 0; off == 0 && i < NDOSPART; i++)
			if (mbr->dmbr_parts[i].dp_typ == i386_userpt)
				off = i + 1;
		if (!off) for (i = 0; off == 0 && i < NDOSPART; i++)
			if (mbr->dmbr_parts[i].dp_typ == DOSPTYP_MIRBSD)
				off = i + 1;

		/* just in case */
		if (!off) for (i = 0; off == 0 && i < NDOSPART; i++)
			if (mbr->dmbr_parts[i].dp_typ == DOSPTYP_OPENBSD)
				off = i + 1;

		/* just in case */
		if (!off) for (i = 0; off == 0 && i < NDOSPART; i++)
			if (mbr->dmbr_parts[i].dp_typ == DOSPTYP_NETBSD)
				off = i + 1;

		/* just in case */
		if (!off) {
		    for (i = 0; off == 0 && i < NDOSPART; i++)
			if (mbr->dmbr_parts[i].dp_typ == DOSPTYP_EXTEND) {
				mbrofs = mbr->dmbr_parts[i].dp_start;
				goto loop;
			}
		    for (i = 0; off == 0 && i < NDOSPART; i++)
			if (mbr->dmbr_parts[i].dp_typ == DOSPTYP_EXTENDL) {
				mbrofs = mbr->dmbr_parts[i].dp_start;
				goto loop;
			}
		    for (i = 0; off == 0 && i < NDOSPART; i++)
			if (mbr->dmbr_parts[i].dp_typ == DOSPTYP_EXTENDLX) {
				mbrofs = mbr->dmbr_parts[i].dp_start;
				goto loop;
			}
		}
	}
	if (off) {
		off = mbr->dmbr_parts[off - 1].dp_start + LABELSECTOR;
	} else
		off = LABELSECTOR;

	/* Load BSD disklabel */
#ifdef BIOS_DEBUG
	if (debug)
		printf("loading disklabel @@ %u\n", off);
#endif
	/* read disklabel */
	error = biosd_io(F_READ, bd, off, 1, NULL);

	if (error)
		return ("failed to read disklabel");

	/* Fill in disklabel */
	return (getdisklabel(bounce_buf, label));
}

int
biosopen(struct open_file *f, ...)
{
	va_list ap;
	register char *cp, **file;
	dev_t unit, part;
	struct diskinfo *dip;
	int i;

	va_start(ap, f);
	file = va_arg(ap, char **);
	va_end(ap);

	if (file == NULL || (cp = *file) == NULL)
		return (EINVAL);

#ifdef BIOS_DEBUG
	if (debug)
		printf("biosopen(%s)\n", cp);
#endif

	f->f_devdata = NULL;

	/* search for device specification */
	while (*cp != ':' && *cp)
		++cp;
	if (*cp == '\0' || cp - *file < 2) {
		cp = *file;
		goto nodevspec;
	}

	for (dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list))
		if (!strncmp(*file, dip->name, cp - *file - 1))
			break;
	if (!dip) {
		cp = *file;
		goto nodevspec;
	}

	/* get partition */
	unit = cp[-2] - '0';
	part = cp[-1] - 'a';
	++cp;

	bootdev_dip = dip;

	/* Fix up bootdev */
	{ dev_t bsd_dev;
		bsd_dev = dip->bios_info.bsd_dev;
		dip->bsddev = MAKEBOOTDEV(B_TYPE(bsd_dev), B_ADAPTOR(bsd_dev),
		    B_CONTROLLER(bsd_dev), unit, part);
		dip->bootdev = MAKEBOOTDEV(B_TYPE(bsd_dev), B_ADAPTOR(bsd_dev),
		    B_CONTROLLER(bsd_dev), B_UNIT(bsd_dev), part);
	}

 nodevspec:
	if ((dip = bootdev_dip) == NULL)
		if ((dip = bootdev_dip = start_dip) == NULL)
			return (EADAPT);

#ifdef BIOS_DEBUG
	if (debug) {
		printf("BIOS geometry: heads=%u, s/t=%u; EDD=%s\n",
		    dip->bios_info.bios_heads, dip->bios_info.bios_sectors,
		    dip->bios_info.flags & BDI_LBA ? "on" : "off");
	}
#endif

	/* Try for disklabel again (might be removable media) */
	if ((i = disk_trylabel(dip)))
		return (i);

	f->f_devdata = dip;

	if (*cp != 0)
		*file = cp;
	else
		f->f_flags |= F_RAW;

	return 0;
}

const u_char bidos_errs[] =
#ifndef SMALL_BOOT
/* ignored	"\x00" "successful completion\0" */
		"\x01" "invalid function/parameter\0"
		"\x02" "address mark not found\0"
		"\x03" "write-protected\0"
		"\x04" "sector not found\0"
		"\x05" "reset failed\0"
		"\x06" "disk changed\0"
		"\x07" "drive parameter activity failed\0"
		"\x08" "DMA overrun\0"
		"\x09" "data boundary error\0"
		"\x0A" "bad sector detected\0"
		"\x0B" "bad track detected\0"
		"\x0C" "invalid media\0"
		"\x0E" "control data address mark detected\0"
		"\x0F" "DMA arbitration level out of range\0"
		"\x10" "uncorrectable CRC or ECC error on read\0"
/* ignored	"\x11" "data ECC corrected\0" */
		"\x20" "controller failure\0"
		"\x31" "no media in drive\0"
		"\x32" "incorrect drive type in CMOS\0"
		"\x40" "seek failed\0"
		"\x80" "operation timed out\0"
		"\xAA" "drive not ready\0"
		"\xB0" "volume not locked in drive\0"
		"\xB1" "volume locked in drive\0"
		"\xB2" "volume not removable\0"
		"\xB3" "volume in use\0"
		"\xB4" "lock count exceeded\0"
		"\xB5" "valid eject request failed\0"
		"\xBB" "undefined error\0"
		"\xCC" "write fault\0"
		"\xE0" "status register error\0"
		"\xFF" "sense operation failed\0"
#endif
		"\x00" "\0";

const char *
biosdisk_err(u_int error)
{
	register const u_char *p = bidos_errs;

	while (*p && *p != error)
		while (*p++);

	return ++p;
}

const struct biosdisk_errors {
	u_char error;
	u_char errno;
} tab[] = {
	{ 0x01, EINVAL },
	{ 0x03, EROFS },
	{ 0x08, EINVAL },
	{ 0x09, EINVAL },
	{ 0x0A, EBSE },
	{ 0x0B, EBSE },
	{ 0x0C, ENXIO },
	{ 0x0D, EINVAL },
	{ 0x10, EECC },
	{ 0x20, EHER },
	{ 0x31, ENXIO },
	{ 0x32, ENXIO },
	{ 0x00, EIO }
};

int
biosdisk_errno(u_int error)
{
	register const struct biosdisk_errors *p;

	if (error == 0)
		return 0;

	for (p = tab; p->error && p->error != error; p++);

	return p->errno;
}

int
biosstrategy(void *devdata, int rw, daddr_t blk, size_t size, void *buf,
    size_t *rsize)
{
	struct diskinfo *dip = (struct diskinfo *)devdata;
	bios_diskinfo_t *bd = &dip->bios_info;
	u_int8_t error = 0;
	size_t nsect;

	nsect = (size + DEV_BSIZE-1) / DEV_BSIZE;
	if (rsize != NULL)
		blk += dip->disklabel.
			d_partitions[B_PARTITION(dip->bsddev)].p_offset;

	/* Read all, sub-functions handle track boundaries */
	error = biosd_io(rw, bd, blk, nsect, buf);

#ifdef BIOS_DEBUG
	if (debug) {
		if (error != 0)
			printf("=0x%x(%s)", error, biosdisk_err(error));
		putchar('\n');
	}
#endif

	if (rsize != NULL)
		*rsize = nsect * DEV_BSIZE;

	return (biosdisk_errno(error));
}

int
biosclose(struct open_file *f)
{
	f->f_devdata = NULL;

	return 0;
}

int
biosioctl(struct open_file *f, u_long cmd, void *data)
{
	return 0;
}

int
disk_trylabel(struct diskinfo *dip)
{
	const char *st = NULL;
	bios_diskinfo_t *bd = &dip->bios_info;
	struct dos_mbr *mbr = (struct dos_mbr *)bounce_buf;
	int i, totsiz;

	if (dip->bios_info.flags & BDI_GOODLABEL)
		return (0);

	if (dip->bios_info.flags & BDI_BADLABEL) {
		st = bios_getdisklabel(&dip->bios_info, &dip->disklabel);
		if (st == NULL)
			dip->bios_info.flags &= ~BDI_BADLABEL;
	}

	if (dip->bios_info.flags & BDI_BADLABEL ||
	    !(dip->bios_info.flags & BDI_GOODLABEL)) {
#ifndef SMALL_BOOT
		int maybe_sun = 0;

		/* create an imaginary disk label */

		st = "failed to read disklabel";
		if (bd->bios_heads == 0 || bd->bios_sectors == 0)
			goto out;

		totsiz = 2880;

		if (!(bd->bios_number & 0x80) || bd->flags & BDI_EL_TORITO ||
		    (bios_bootpte.active & 0x7F) /* || !bios_bootpte.partyp */)
			bios_bootpte.partyp = 0;
		if (bd->bios_number & 0x80) {
			/* read MBR */
			i = biosd_io(F_READ, bd, DOSBBSECTOR, 1, NULL);
			if (i)
				goto nombr;
			if (!memcmp((char *)mbr + offsetof(ustar_hdr_t, magic),
			    ustar_magic_version, sizeof(ustar_magic_version)))
				goto nombr;
			if (mbr->dmbr_sign != DOSMBR_SIGNATURE)
				goto nombr;
			if (bounce_buf[0x1FC] == 0xDA &&
			    bounce_buf[0x1FD] == 0xBE) {
				for (i = 0x080; i < 0x088; ++i)
					if (bounce_buf[i])
						break;
				if (i == 0x088) {
					maybe_sun = 1;
					bios_bootpte.partyp = 0;
				}
			}
			for (i = 0; i < NDOSPART; i++)
				if (mbr->dmbr_parts[i].dp_typ &&
				    (mbr->dmbr_parts[i].dp_start +
				    mbr->dmbr_parts[i].dp_size > totsiz))
					totsiz = mbr->dmbr_parts[i].dp_start +
					    mbr->dmbr_parts[i].dp_size;
			goto mbrok;
		}
 nombr:
		for (i = 0; i < NDOSPART; i++)
			mbr->dmbr_parts[i].dp_typ = 0;
 mbrok:

		dip->disklabel.d_secsize = 512;
		dip->disklabel.d_ntracks = bd->bios_heads;
		dip->disklabel.d_nsectors = bd->bios_sectors;
		dip->disklabel.d_secpercyl = dip->disklabel.d_ntracks *
		    dip->disklabel.d_nsectors;
		totsiz += dip->disklabel.d_secpercyl - 1;
		dip->disklabel.d_ncylinders = totsiz /
		    dip->disklabel.d_secpercyl;
		memcpy(dip->disklabel.d_typename, "FAKE", 5);
		dip->disklabel.d_type = DTYPE_VND;
		strncpy(dip->disklabel.d_packname, "fictitious",
		    sizeof (dip->disklabel.d_packname));
		dip->disklabel.d_secperunit = dip->disklabel.d_ncylinders *
		    dip->disklabel.d_secpercyl;
		totsiz = dip->disklabel.d_secperunit;
		dip->disklabel.d_rpm = 3600;
		dip->disklabel.d_interleave = 1;

		dip->disklabel.d_bbsize = 8192;
		dip->disklabel.d_sbsize = 65536;

		bzero(dip->disklabel.d_partitions,
		    sizeof (dip->disklabel.d_partitions));

		if (bios_bootpte.partyp &&
		    (bios_bootpte.p_ofs || bios_bootpte.p_siz)) {
			/* 'a' partition passed from MBR/SYSLINUX */
			dip->disklabel.d_partitions[0].p_offset = bios_bootpte.p_ofs;
			dip->disklabel.d_partitions[0].p_size = bios_bootpte.p_siz;
			dip->disklabel.d_partitions[0].p_fstype = FS_MANUAL;
		} else {
			/* 'a' partition covering the "whole" disk */
			dip->disklabel.d_partitions[0].p_offset = 0;
			dip->disklabel.d_partitions[0].p_size = totsiz;
			dip->disklabel.d_partitions[0].p_fstype =
			    maybe_sun ? FS_MANUAL : FS_OTHER;
		}

		/* The raw partition is special */
		dip->disklabel.d_partitions[RAW_PART].p_offset = 0;
		dip->disklabel.d_partitions[RAW_PART].p_size = totsiz;
		dip->disklabel.d_partitions[RAW_PART].p_fstype = FS_UNUSED;

		for (i = 0; i < NDOSPART; i++) {
			if (!mbr->dmbr_parts[i].dp_typ)
				continue;
			dip->disklabel.d_partitions[RAW_PART+i+1].p_offset =
			    mbr->dmbr_parts[i].dp_start;
			dip->disklabel.d_partitions[RAW_PART+i+1].p_size =
			    mbr->dmbr_parts[i].dp_size;
			dip->disklabel.d_partitions[RAW_PART+i+1].p_fstype =
			    FS_MANUAL;
			if (dip->disklabel.d_partitions[0].p_fstype ==
			    FS_MANUAL)
				continue;
			/* a GUID Partition Table cannot become 'a' slice */
			if (mbr->dmbr_parts[i].dp_typ == 0xEE)
				continue;
			/* 'a' partition covering the first partition */
			dip->disklabel.d_partitions[0].p_offset =
			    mbr->dmbr_parts[i].dp_start;
			dip->disklabel.d_partitions[0].p_size =
			    mbr->dmbr_parts[i].dp_size;
			dip->disklabel.d_partitions[0].p_fstype = FS_MANUAL;
		}
#else /* SMALL_BOOT */
		/* check if ustar, if so fake a disklabel */

		st = "failed to read disklabel";
		if (bd->bios_heads == 0 || bd->bios_sectors == 0)
			goto out;

		totsiz = 2880;

		i = biosd_io(F_READ, bd, DOSBBSECTOR, 1, NULL);
		if (i)
			goto out;
		if (memcmp((char *)mbr + offsetof(ustar_hdr_t, magic),
		    ustar_magic_version, sizeof(ustar_magic_version)))
			goto out;

		dip->disklabel.d_secsize = 512;
		dip->disklabel.d_ntracks = bd->bios_heads;
		dip->disklabel.d_nsectors = bd->bios_sectors;
		dip->disklabel.d_secpercyl = dip->disklabel.d_ntracks *
		    dip->disklabel.d_nsectors;
		totsiz += dip->disklabel.d_secpercyl - 1;
		dip->disklabel.d_ncylinders = totsiz /
		    dip->disklabel.d_secpercyl;
		memcpy(dip->disklabel.d_typename, "FAKE", 5);
		dip->disklabel.d_type = DTYPE_VND;
		strncpy(dip->disklabel.d_packname, "fictitious",
		    sizeof (dip->disklabel.d_packname));
		dip->disklabel.d_secperunit = dip->disklabel.d_ncylinders *
		    dip->disklabel.d_secpercyl;
		totsiz = dip->disklabel.d_secperunit;
		dip->disklabel.d_rpm = 300;
		dip->disklabel.d_interleave = 1;

		dip->disklabel.d_bbsize = 8192;
		dip->disklabel.d_sbsize = 65536;

		bzero(dip->disklabel.d_partitions,
		    sizeof (dip->disklabel.d_partitions));

		/* 'a' partition covering the "whole" disk */
		dip->disklabel.d_partitions[0].p_offset = 0;
		dip->disklabel.d_partitions[0].p_size = totsiz;
		dip->disklabel.d_partitions[0].p_fstype = FS_MANUAL;

		/* The raw partition is special */
		dip->disklabel.d_partitions[RAW_PART].p_offset = 0;
		dip->disklabel.d_partitions[RAW_PART].p_size = totsiz;
		dip->disklabel.d_partitions[RAW_PART].p_fstype = FS_UNUSED;
#endif
		dip->disklabel.d_npartitions = MAXPARTITIONS;

		dip->disklabel.d_magic = DISKMAGIC;
		dip->disklabel.d_magic2 = DISKMAGIC;
		dip->disklabel.d_checksum = dkcksum(&dip->disklabel);

		dip->bios_info.flags &= ~BDI_BADLABEL;
		dip->bios_info.flags |= BDI_GOODLABEL;
		st = NULL;
	}
 out:
	if ((dip->bios_info.flags & BDI_BADLABEL) && st == NULL)
		st = "*none*";
	if (st != NULL) {
		printf("%s\n", st);
		return ERDLAB;
	}

	return (0);
}
@


1.47
log
@when faking a disklabel, skip GPT partitions when determining the 'a' slice

should fix bsd4grml fails-to-boot with the grml64 daily ISO as reported by Zhenech
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.45 2010/01/10 19:21:37 tg Exp $ */
d97 1
a97 1
		/* https://www.mirbsd.org/permalinks/news_e20090126-tg.htm */
@


1.46
log
@fix extended partition support broken in the ocvs:
revision 1.31
date: 2004/01/02 23:47:47;  author: tg;  state: Exp;  lines: +26 -4;
extended partition support for the bootloader

*all* partition entries need to have their start offset
adjusted by their respective partition table’s offset,
so do it, for all at once, before scanning

XXX this code looks so… wrong, well ugly
@
text
@d677 3
@


1.45
log
@new ustarfs for the bootloader (fdboot only ATM, since boot’s too huge)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.44 2009/08/11 13:23:59 tg Exp $ */
d7 1
a7 1
 * Copyright (c) 2002, 2003, 2004, 2005, 2008, 2009
d287 4
d292 1
a292 2
		if (i386_userpt) for (i = 0; off == 0 && i < NDOSPART; i++) {
			mbr->dmbr_parts[i].dp_start += mbrofs;
a294 1
		}
@


1.44
log
@Totally revamp the virtual device code.

Unbreak:
• floppy access (BIOS)
• hard disc access (BIOS)
• CD-ROM El Torito access (BIOS)
• cd9660, fat, ffs (filesystems)

Not tested:
• tftp, nfs (PXE, NET, filesystems)
• lmbmfs (lmbm)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.43 2009/08/11 10:53:35 tg Exp $ */
d40 1
d279 4
a557 1
#ifndef SMALL_BOOT
d560 1
a560 1
	int i, totsiz, maybe_sun = 0;
a563 1
#endif
a570 1
#ifndef SMALL_BOOT
d573 3
d592 3
d682 33
d716 16
a744 1
#endif
@


1.43
log
@fix debug output
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.42 2009/02/03 00:02:02 tg Exp $ */
d351 1
a351 1
	cp = *(file = va_arg(ap, char **));
d354 3
@


1.42
log
@hmpf. hacko. this is what I get for committing from a sparc.
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.40 2009/02/01 14:39:19 tg Exp $ */
d402 1
a402 1
		    bd->flags & BDI_LBA ? "on" : "off");
@


1.41
log
@it was nice while it lasted… but a 2048 byte BSD disklabel on a hard disc
won’t work either (and setting the sector size in it to 0 panics the ker-
nel, quite nice local DoS attack by the way, thanks for all the blowfish)

⇒ revert the writing-the-disklabel code altogether
  ‣ make -N option ignored (and undocumented)
⇒ hack: if the MBR looks like a Sun disklabel faked by us (i.e. no exten-
  ded partition magic, but DABE and forced 55AA, and no 0x27 partition or
  recognisable BSD LE disklabel), ignore it for ‘a’ slice detection)

untested
@
text
@d577 1
a577 1
		    (bios_bootpte.active & 0x7F) || /* !bios_bootpte.partyp */)
@


1.40
log
@I could cry…
• fix split-sector reads if buf==NULL (we use the bounce buffer)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.39 2009/01/31 16:07:22 tg Exp $ */
d553 1
a553 1
	int i, totsiz;
d577 1
a577 1
		    (bios_bootpte.active & 0x7F) /* || !bios_bootpte.partyp */)
d586 10
d643 2
a644 1
			dip->disklabel.d_partitions[0].p_fstype = FS_OTHER;
@


1.39
log
@(tentative) code to use an El Torito device if 4B01/INT13 succeeds, which
is only checked if the drive number is >= 88h though, ignoring whether the
BIOS actually tells us it’s LBA (EDD) capable

untested
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.38 2009/01/26 15:27:08 tg Exp $ */
d184 2
a185 2
	if (buf && rw != F_READ)
		memcpy(bounce_buf + spre * 512, buf,
d237 2
a238 2
	if (buf && rw == F_READ)
		memcpy(buf, bounce_buf + spre * 512,
@


1.38
log
@some BIOSen (like VMware Server 2) do not return error status for CDs,
but a bogus geometry; catch them too

- fixes VMware
- still works on qemu
- nightlily@@midnightbsd kindly tested this on virtualpc
- parallels status: unknown

why in all world does the bootloader not access the CD if the C/H/S
geometry is bogus, anyway? why does it probe CHS before LBA? W.T.F!
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.37 2009/01/11 22:49:51 tg Exp $ */
d84 3
d90 12
d123 7
a129 7
	lback = biosdev_lbaprobe(dev);

	if ((rv & 0xff) && ((lback & 0x19) != 0x19)) {
		if ((lback & 0x09) == 0x09)
			printf("bios_getdiskinfo(%X): LBA but no CHS, not "
			    "a CD-ROM? please report %X\n", dev, lback);
		return 1;
a137 1
	pdi->flags &= ~(BDI_LBA | BDI_EL_TORITO);
a140 6
		if (lback & 0x10) {
			pdi->bios_heads = 16;
			pdi->bios_cylinders = 16;
			pdi->bios_sectors = 32;
			pdi->flags |= BDI_EL_TORITO;
		}
@


1.37
log
@try to support CD partial reads (yuck)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.36 2009/01/11 17:18:33 tg Exp $ */
d110 2
a111 7
	if (rv & 0xff) {
		if ((lback & 0x19) == 0x19) {
			/* CD-ROM, LBA (only) */
			pdi->bios_heads = 15;
			pdi->bios_cylinders = 15;
			pdi->bios_sectors = 32;
		} else if ((lback & 0x09) == 0x09) {
d114 1
a114 3
			return 1;
		} else
			return 1;
d127 4
a130 1
		if (lback & 0x10)
d132 3
a134 6
		/* skip sanity check for CHS options in EDD mode */
		return (0);
	}

	/* Sanity check */
	if (!pdi->bios_cylinders || !pdi->bios_heads || !pdi->bios_sectors) {
d136 1
a136 1
		printf("sanity: c/h/s value zero: %d/%d/%d\n",
d139 1
a139 1
		return(1);
d142 1
a142 8
	if (pdi->bios_heads < 2) {
#ifdef BIOS_DEBUG
		printf("sanity: c/h/s heads < 2\n");
#endif
		return(1);
	}

	return 0;
@


1.36
log
@retain binary compatibility to current kernels, oops
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.35 2009/01/11 17:14:45 tg Exp $ */
d165 1
a165 1
	int rv, n, ssh, i;
d168 1
d170 10
a179 4
	if ((ssh = bd->flags & BDI_EL_TORITO ? 2 : 0))	/* sector shift */
#ifndef SMALL_BOOT
		if ((off & 3) || (nsect & 3))
			printf("panic: El Torito odd read %d@@%d\n", nsect, off)
a180 1
		;
d183 1
a183 1
	n = i386_flag_oldbios ? 1 << ssh : MIN(nsect, 4096/512);
d191 2
a192 1
		memcpy(bounce_buf, buf, n * 512);
d244 3
a246 2
		memcpy(buf, bounce_buf, n * 512);
	if ((nsect -= n) == 0)
d254 1
a254 1
	buf += n * 512;
d256 1
@


1.35
log
@El Torito is always LBA
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.34 2009/01/11 17:08:29 tg Exp $ */
d81 3
d133 1
@


1.34
log
@replace the OpenBSD BIOS disc I/O code with something more legible
with less overhead ;-)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.33 2009/01/11 13:58:07 tg Exp $ */
d165 6
a170 1
	ssh = bd->flags & BDI_EL_TORITO ? 2 : 0;	/* sector shift */
d175 2
a176 1
		btochs(off >> ssh, c, h, s, bd->bios_heads, bd->bios_sectors);
d178 1
a178 1
			n = ssh ? 1 << ssh : bd->bios_sectors - s;
d202 1
a202 1
			    c, h, s, n >> ssh);
d205 1
a205 1
			    bd->bios_number, c, h, s, n >> ssh);
@


1.33
log
@remove bios_edd member, do LBA via a flag, use my routine instead of
OpenBSD’s to detect LBA and El Torito, mop up
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.32 2009/01/11 13:43:47 tg Exp $ */
a48 5
static __inline int CHS_rw_real (int, int, int, int, int, int, void *);
static __inline int CHS_rw (int, int, int, int, int, int, void *);
static __inline int EDD_rw (int, int, u_int64_t, u_int32_t, void *);
static __inline int real_io(int, bios_diskinfo_t *, daddr_t, int, void *);

d50 2
a55 18
#if 0
struct biosdisk {
	bios_diskinfo_t *bios_info;
	dev_t	bsddev;
	struct disklabel disklabel;
};
#endif

struct EDD_CB {
	u_int8_t  edd_len;	/* size of packet */
	u_int8_t  edd_res1;	/* reserved */
	u_int8_t  edd_nblk;	/* # of blocks to transfer */
	u_int8_t  edd_res2;	/* reserved */
	u_int16_t edd_off;	/* address of buffer (offset) */
	u_int16_t edd_seg;	/* address of buffer (segment) */
	u_int64_t edd_daddr;	/* starting block */
};

a155 78
 * Read/Write a block from given place using the BIOS.
 */
static __inline int
CHS_rw(int rw, int dev, int cyl, int head, int sect, int nsect, void *buf)
{
	int rv = 0;

	if (!i386_flag_oldbios)
		return CHS_rw_real(rw, dev, cyl, head, sect, nsect, buf);

	while (!rv && nsect) {
		rv = CHS_rw_real(rw, dev, cyl, head, sect, 1, buf);
		++sect;
		--nsect;
		buf += 512;
	}
	return rv;
}

/*
 * Do the actual (sector-wise or multi-block) BIOS disc I/O in CHS mode.
 */
static __inline int
CHS_rw_real(int rw, int dev, int cyl, int head, int sect, int nsect, void *buf)
{
	int rv;

	rw = rw == F_READ ? 2 : 3;
	BIOS_regs.biosr_es = (u_int32_t)buf >> 4;
	__asm __volatile ("movb %b7, %h1\n\t"
	    "movb %b6, %%dh\n\t"
	    "andl $0xf, %4\n\t"
	    /* cylinder; the highest 2 bits of cyl is in %cl */
	    "xchgb %%ch, %%cl\n\t"
	    "rorb  $2, %%cl\n\t"
	    "orb %b5, %%cl\n\t"
	    "inc %%cx\n\t"
	    DOINT(0x13) "\n\t"
	    "setc %b0"
	    : "=a" (rv)
	    : "0" (nsect), "d" (dev), "c" (cyl),
	      "b" (buf), "m" (sect), "m" (head),
	      "m" (rw)
	    : "cc", "memory");

	return ((rv & 0xff)? rv >> 8 : 0);
}

static __inline int
EDD_rw(int rw, int dev, u_int64_t daddr, u_int32_t nblk, void *buf)
{
	int rv;
	volatile static struct EDD_CB cb;

	/* Zero out reserved stuff */
	cb.edd_res1 = 0;
	cb.edd_res2 = 0;

	/* Fill in parameters */
	cb.edd_len = sizeof(cb);
	cb.edd_nblk = nblk;
	cb.edd_seg = ((u_int32_t)buf >> 4) & 0xffff;
	cb.edd_off = (u_int32_t)buf & 0xf;
	cb.edd_daddr = daddr;

	/* if offset/segment are zero, punt */
	if (!cb.edd_seg && !cb.edd_off)
		return 1;

	/* Call extended read/write (with disk packet) */
	BIOS_regs.biosr_ds = (u_int32_t)&cb >> 4;
	__asm __volatile (DOINT(0x13) "; setc %b0" : "=a" (rv)
	    : "0" ((rw == F_READ)? 0x4200: 0x4300),
	      "d" (dev), "S" ((int) (&cb) & 0xf) : "%ecx", "cc");
	return ((rv & 0xff)? rv >> 8 : 0);
}

/*
d161 5
a165 1
	int n, rv;
d168 6
a173 1
	n = MIN(nsect, 4096/DEV_BSIZE);	/* nsect to try this iteration */
d175 5
a179 39
		memcpy(bounce_buf, buf, n * DEV_BSIZE);
	if ((rv = real_io(rw, bd, off, n, bounce_buf)))
		return (rv);
	if (buf && rw == F_READ)
		memcpy(buf, bounce_buf, n * DEV_BSIZE);
	if ((nsect -= n)) {
		if (!buf) {
#ifndef SMALL_BOOT
			printf("panic: cannot loop biosd_io on bounce_buf\n");
#endif
			return (0);
		}
		buf += n * DEV_BSIZE;
		off += n;
		goto loop;
	}
	return (0);
}

static __inline int
real_io(int rw, bios_diskinfo_t *bd, daddr_t off, int nsect, void *buf)
{
	int dev = bd->bios_number;
	int j, error;

	if (bd->flags & BDI_EL_TORITO) {
		/*
		 * sys/lib/libsa/cd9600.c converts 2,048-byte CD sectors
		 * to DEV_BSIZE blocks before calling the device strategy
		 * routine.  However, the El Torito spec says that the
		 * BIOS will work in 2,048-byte sectors.  So shift back.
		 */
		off >>= (ISO_DEFAULT_BLOCK_SHIFT - DEV_BSHIFT);
		nsect >>= (ISO_DEFAULT_BLOCK_SHIFT - DEV_BSHIFT);
	}

	/* Try to do operation up to 5 times */
	for (error = 1, j = 5; j-- && error; ) {
		/* CHS or LBA access? */
d181 11
a191 1
			error = EDD_rw(rw, dev, off, nsect, buf);
d193 7
a199 22
			int cyl, head, sect;
			size_t i, n;
			char *p = buf;

			/* Handle track boundaries */
			for (error = i = 0; error == 0 && i < nsect;
			    i += n, off += n, p += n * DEV_BSIZE) {

				btochs(off, cyl, head, sect, bd->bios_heads,
				    bd->bios_sectors);

				if ((sect + (nsect - i)) >= bd->bios_sectors)
					n = bd->bios_sectors - sect;
				else
					n = nsect - i;

				error = CHS_rw(rw, dev, cyl, head, sect, n, p);

				/* ECC corrected */
				if (error == 0x11)
					error = 0;
			}
d201 2
a202 2
		switch (error) {
		case 0x00:	/* No errors */
d204 2
a205 1
			error = 0;
d207 1
a207 2

		default:	/* All other errors */
d210 2
a211 2
				printf("\nBIOS error 0x%x (%s)\n",
				    error, biosdisk_err(error));
d213 1
a213 1
			biosdreset(dev);
a216 1

d219 2
a220 2
		if (error != 0)
			printf("=0x%x(%s)", error, biosdisk_err(error));
d224 15
a238 2

	return error;
@


1.32
log
@improve the LBA check
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.31 2009/01/11 13:36:05 tg Exp $ */
d100 1
d125 3
d129 4
a132 4
		if (dev >= 0x88 && (biosdev_lbaprobe(dev) & 16)) {
			/* fake for CD-ROMs */
			pdi->bios_heads = 1;
			pdi->bios_cylinders = 100;
d134 4
a137 1
			pdi->flags |= BDI_EL_TORITO;
d148 8
a155 44
	/* NOTE:
	 * This currently hangs/reboots some machines
	 * The IBM ThinkPad 750ED for one.
	 *
	 * Funny that an IBM/MS extension would not be
	 * implemented by an IBM system...
	 *
	 * Future hangs (when reported) can be "fixed"
	 * with getSYSCONFaddr() and an exceptions list.
	 */
	if (dev & 0x80 && (dev == 0x80 || dev == 0x81 || dev == 0xFF /*bios_bootdev*/)) {
		int bm;

#ifdef BIOS_DEBUG
		if (debug)
			printf("getinfo: try #41, 0x%x\n", dev);
#endif
		/* EDD support check */
		__asm __volatile(DOINT(0x13) "; setc %b0"
			 : "=a" (rv), "=c" (bm)
			 : "0" (0x4100), "b" (0x55aa), "d" (dev) : "cc");
		if (!(rv & 0xff) && (BIOS_regs.biosr_bx & 0xffff) == 0xaa55)
			pdi->bios_edd = (bm & 0xffff) | ((rv & 0xff) << 16);
		else
			pdi->bios_edd = -1;

#ifdef BIOS_DEBUG
		if (debug) {
			printf("getinfo: got #41\n");
			printf("disk 0x%x: 0x%x\n", dev, bm);
		}
#endif
		/*
		 * If extended disk access functions are not supported
		 * there is not much point on doing EDD.
		 */
		if (!(pdi->bios_edd & EXT_BM_EDA))
			pdi->bios_edd = -1;
	} else
		pdi->bios_edd = -1;

	/* Skip sanity check for CHS options in EDD mode. */
	if (pdi->bios_edd != -1)
		return 0;
a165 1
	/* CD-ROMs sometimes return heads == 1 */
d304 1
a304 1
		if (bd->bios_edd != -1) {
d504 1
a504 1
		printf("BIOS geometry: heads=%u, s/t=%u; EDD=%d\n",
d506 1
a506 1
		    dip->bios_info.bios_edd);
@


1.31
log
@better bios_bootpte sanitisation: use a C structure type
(although I *still* don't understand why I can have
	extern uint32_t bios_bootpte[4];
	bzero(bios_bootpte, 16);
but must now write
	extern struct { … } bios_bootpte;
	bzero(&bios_bootpte, 16);
which is one of the reasons I think asm is superiour than C)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.30 2009/01/11 13:28:49 tg Exp $ */
d125 1
a125 1
		if (dev >= 0x88 && (biosdev_lbaprobe(dev) & 3) == 3) {
@


1.30
log
@clean up unused variable
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.29 2009/01/11 01:46:20 tg Exp $ */
d711 2
a712 3
		    (((char *)bios_bootpte)[0] & 0x7F) ||
		    !((char *)bios_bootptr)[4])
			bzero(bios_bootpte, 16);
d757 2
a758 1
		if (bios_bootpte[2] || bios_bootpte[3]) {
d760 2
a761 2
			dip->disklabel.d_partitions[0].p_offset = bios_bootpte[2];
			dip->disklabel.d_partitions[0].p_size = bios_bootpte[3];
@


1.29
log
@another more check on bios_bootpte – XXX why is there not a single
reliable way?

possible ways out of this dilemma:
• add disklabels to the CDs
• maybe add direct partition access and DOS access orthogonal to slices?
  (needs rewrite of all of the code, period. too much for now…)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.28 2009/01/11 00:32:40 tg Exp $ */
d479 1
a479 1
	register char	*cp, **file;
d482 1
a482 1
	int biosdev;
a515 2
	biosdev = dip->bios_info.bios_number;

d541 2
a542 2
	if ((biosdev = disk_trylabel(dip)))
		return (biosdev);
@


1.28
log
@restore FFS and CD9660 boot from hard disc
maybe FFS from floppy (untested)

CD9660 from CD-ROM doesn't work yet
PXE (tftp) untested
PXE (nfs) – did it ever work? no idea…
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.27 2009/01/10 23:43:08 tg Exp $ */
d713 2
a714 1
		    (*((char *)bios_bootpte) & 0x7F))
@


1.27
log
@fix cd0 detection, etc.
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.26 2009/01/10 22:18:53 tg Exp $ */
d320 1
a320 3
	if (bd->flags & BDI_EL_TORITO) {	/* It's a CD device */
		dev &= 0xff;			/* Mask out this flag bit */

d490 1
a490 1
		printf("%s\n", cp);
d712 3
d729 1
a729 2
		} else
			bzero(bios_bootpte, 16);
d760 1
a760 1
			/* 'a' partition passed from SYSLINUX */
@


1.26
log
@more work towards unifying devices (and network)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.25 2009/01/10 20:28:27 tg Exp $ */
d54 2
d124 10
a133 2
	if (rv & 0xff)
		return 1;
@


1.25
log
@shuffle some defns around
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.24 2009/01/10 18:15:10 tg Exp $ */
d472 1
a472 1
	dev_t maj, unit, part;
d486 1
d488 5
a492 6
	cp += 2;
	if (cp[2] != ':') {
		if (cp[3] != ':')
			return ENOENT;
		else
			cp++;
d495 6
a500 8
	for (maj = 0; maj < nbdevs && strncmp(*file, bdevs[maj], cp - *file); )
	    maj++;
	if (maj >= nbdevs) {
		printf("Unknown device: ");
		for (cp = *file; *cp != ':'; cp++)
			putchar(*cp);
		putchar('\n');
		return EADAPT;
a502 7
	/* get unit */
	if ('0' <= *cp && *cp <= '9')
		unit = *cp++ - '0';
	else {
		printf("Bad unit number\n");
		return EUNIT;
	}
d504 3
a506 13
	if ('a' <= *cp && *cp <= 'p')
		part = *cp++ - 'a';
	else {
		printf("Bad partition id\n");
		return EPART;
	}

	if (*cp == ':')
		cp++;
	if (*cp != 0)
		*file = cp;
	else
		f->f_flags |= F_RAW;
d508 1
a508 15
	biosdev = unit;
	switch (maj) {
	case 0:  /* wd */
	case 4:  /* sd */
	case 17: /* hd */
		biosdev |= 0x80;
		break;
	case 2:  /* fd */
		break;
	case 6:  /* cd */
		biosdev = 0xFF /*bios_bootdev*/ & 0xff;
		break;
	default:
		return ENXIO;
	}
d510 1
a510 2
	/* Find device */
	bootdev_dip = dip = dklookup(biosdev);
d521 4
a524 4
#if 0
	dip->bios_info.bsd_dev = dip->bootdev;
	bootdev = dip->bootdev;
#endif
a539 2
	if (*cp == ':')
		cp++;
@


1.24
log
@new loader and stuff (new bootxx too, *incompatible*!)
still not usable until biosdev/-probe rewrite though…

syslinux, dos, multiboot operation not tested yet, either
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.23 2009/01/03 16:21:40 tg Exp $ */
a54 4
#ifndef SMALL_BOOT
extern uint32_t bios_bootpte[4];
#endif
extern uint8_t i386_userpt;
@


1.23
log
@more -Wstack-larger-than-255: do direct bounce buffer I/O when getting
the MBR and disklabel (dangerous but possible)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.22 2009/01/03 16:16:08 tg Exp $ */
d58 1
a58 1
int bios_bootdev;
a59 1
int userpt = 0;
d145 1
a145 1
	if (dev & 0x80 && (dev == 0x80 || dev == 0x81 || dev == bios_bootdev)) {
d413 1
a413 1
		if (userpt) for (i = 0; off == 0 && i < NDOSPART; i++) {
d415 1
a415 1
			if (mbr->dmbr_parts[i].dp_typ == userpt)
d541 1
a541 1
		biosdev = bios_bootdev & 0xff;
@


1.22
log
@if biosd_io buf arg is NULL, do I/O on bounce buffer
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.21 2009/01/03 16:14:24 tg Exp $ */
d392 1
a392 2
	char *buf;
	struct dos_mbr mbr;
a394 1
	const char *rv;
d404 2
a405 1
loop:		error = biosd_io(F_READ, bd, mbrofs, 1, &mbr);
d410 1
a410 1
		if (mbr.dmbr_sign != DOSMBR_SIGNATURE)
d415 2
a416 2
			mbr.dmbr_parts[i].dp_start += mbrofs;
			if (mbr.dmbr_parts[i].dp_typ == userpt)
d420 1
a420 1
			if (mbr.dmbr_parts[i].dp_typ == DOSPTYP_MIRBSD)
d425 1
a425 1
			if (mbr.dmbr_parts[i].dp_typ == DOSPTYP_OPENBSD)
d430 1
a430 1
			if (mbr.dmbr_parts[i].dp_typ == DOSPTYP_NETBSD)
d436 2
a437 2
			if (mbr.dmbr_parts[i].dp_typ == DOSPTYP_EXTEND) {
				mbrofs = mbr.dmbr_parts[i].dp_start;
d441 2
a442 2
			if (mbr.dmbr_parts[i].dp_typ == DOSPTYP_EXTENDL) {
				mbrofs = mbr.dmbr_parts[i].dp_start;
d446 2
a447 2
			if (mbr.dmbr_parts[i].dp_typ == DOSPTYP_EXTENDLX) {
				mbrofs = mbr.dmbr_parts[i].dp_start;
d453 1
a453 1
		off = mbr.dmbr_parts[off - 1].dp_start + LABELSECTOR;
a457 1
	buf = alloc(DEV_BSIZE);
d463 3
a465 2
	if ((error = biosd_io(F_READ, bd, off, 1, buf))) {
		free(buf, DEV_BSIZE);
a466 1
	}
d469 1
a469 3
	rv = getdisklabel(buf, label);
	free(buf, DEV_BSIZE);
	return (rv);
d721 1
a721 1
	struct dos_mbr mbr;
d747 1
a747 1
			i = biosd_io(F_READ, bd, DOSBBSECTOR, 1, &mbr);
d750 1
a750 1
			if (mbr.dmbr_sign != DOSMBR_SIGNATURE)
d753 5
a757 5
				if (mbr.dmbr_parts[i].dp_typ &&
				    (mbr.dmbr_parts[i].dp_start +
				    mbr.dmbr_parts[i].dp_size > totsiz))
					totsiz = mbr.dmbr_parts[i].dp_start +
					    mbr.dmbr_parts[i].dp_size;
d763 1
a763 1
			mbr.dmbr_parts[i].dp_typ = 0;
d808 1
a808 1
			if (!mbr.dmbr_parts[i].dp_typ)
d811 1
a811 1
			    mbr.dmbr_parts[i].dp_start;
d813 1
a813 1
			    mbr.dmbr_parts[i].dp_size;
d821 1
a821 1
			    mbr.dmbr_parts[i].dp_start;
d823 1
a823 1
			    mbr.dmbr_parts[i].dp_size;
@


1.21
log
@oops, do I/O on the bounce buffer
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.20 2009/01/03 13:43:33 tg Exp $ */
d289 1
a289 1
	if (rw != F_READ)
d293 1
a293 1
	if (rw == F_READ)
d296 6
@


1.20
log
@• cut down on stack usage
• improve reliability (especially on 64K and larger reads)
• remove alloca
• nuke tori transfer buffer
by making use of a paragraph-aligned 4 KiB bounce buffer very early in
the .bss section (allocated in srt0.S, which is first in link)

XXX biosdev.c ist eine Ausgeburt an Häßlichkeit!
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.19 2009/01/02 05:16:34 tg Exp $ */
d291 1
a291 1
	if ((rv = real_io(rw, bd, off, n, buf)))
@


1.19
log
@bump, regenerate, etc.
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.18 2009/01/01 17:46:20 tg Exp $ */
d52 1
d285 21
a307 2
	void *bb;
	int bbsize = nsect * DEV_BSIZE;
a321 17
	/*
	 * Use a bounce buffer to not cross 64k DMA boundary, and to
	 * not access 1 MB or above.
	 */
	if (((((u_int32_t)buf) & ~0xffff) !=
	    (((u_int32_t)buf + bbsize) & ~0xffff)) ||
	    (((u_int32_t)buf) >= 0x100000)) {
		/*
		 * XXX we believe that all the io is buffered
		 * by fs routines, so no big reads anyway
		 */
		bb = alloca(bbsize);
		if (rw != F_READ)
			bcopy(buf, bb, bbsize);
	} else
		bb = buf;

d326 1
a326 1
			error = EDD_rw(rw, dev, off, nsect, bb);
d330 1
a330 1
			char *p = bb;
a367 3
	if (bb != buf && rw == F_READ)
		bcopy(bb, buf, bbsize);

d390 1
d453 1
a453 1
	buf = alloca(DEV_BSIZE);
d459 2
a460 3
	error = biosd_io(F_READ, bd, off, 1, buf);

	if (error)
d462 1
d465 3
a467 1
	return (getdisklabel(buf, label));
@


1.18
log
@rename uint32_t bios_bootpart[2] into uint32_t bios_bootpte[4]
and preserve the whole partition record (table entry)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.17 2008/12/31 16:38:36 tg Exp $ */
d7 1
a7 1
 * Copyright (c) 2002, 2003, 2004, 2005, 2008
@


1.17
log
@shrink fdboot, nuke unused junk
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.15 2008/12/28 21:23:24 tg Exp $ */
d55 1
a55 1
extern uint32_t bios_bootpart[2];
d755 1
a755 1
			bios_bootpart[0] = bios_bootpart[1] = 0;
d785 1
a785 1
		if (bios_bootpart[0] || bios_bootpart[1]) {
d787 2
a788 2
			dip->disklabel.d_partitions[0].p_offset = bios_bootpart[0];
			dip->disklabel.d_partitions[0].p_size = bios_bootpart[1];
@


1.16
log
@logic error, st (error string) may already have been set
@
text
@d54 1
d56 1
d714 1
d721 1
d729 1
d835 1
@


1.15
log
@* mbrok can only be reached for HDDs
* ensure partition info is clear(ed) for nōn-HDDs
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.14 2008/12/28 20:17:32 tg Exp $ */
d828 1
a828 1
	if (dip->bios_info.flags & BDI_BADLABEL)
@


1.14
log
@if a partition is passed in bios_bootpart[], use its boundaries instead
of the first MBR partition or, if nōn-existant, the whole disc, when
faking a disklabel if none is there

XXX this can have weird results if none is passed to SYSLINUX
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.12 2008/12/28 18:58:32 tg Exp $ */
d748 3
a750 2
		}
		goto mbrok;
@


1.12
log
@miscalculation
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.11 2008/12/28 18:57:28 tg Exp $ */
d54 1
d779 11
a789 4
		/* 'a' partition covering the "whole" disk */
		dip->disklabel.d_partitions[0].p_offset = 0;
		dip->disklabel.d_partitions[0].p_size = totsiz;
		dip->disklabel.d_partitions[0].p_fstype = FS_OTHER;
@


1.11
log
@fake a label if none found (experimental!)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.10 2008/12/28 18:18:04 tg Exp $ */
d732 1
a732 1
		totsiz = 1474560;
@


1.10
log
@try disklabel again if bad (might be removable media) in “machine label” too
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.9 2008/12/28 05:45:10 tg Exp $ */
d710 7
a716 1
	const char *st;
d718 1
a718 1
	if (dip->bios_info.flags & BDI_BADLABEL){
d720 27
a746 3
		if (st != NULL) {
			printf("%s\n", st);
			return ERDLAB;
d748 76
a823 1
		dip->bios_info.flags &= !BDI_BADLABEL;
d825 1
@


1.9
log
@allow superfloppy style access to HDDs with no MBR MirBSD partition
(including USB sticks), d’oh
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.8 2008/12/28 03:40:15 tg Exp $ */
d566 2
a567 9
	if (dip->bios_info.flags & BDI_BADLABEL){
		const char *st = bios_getdisklabel(&dip->bios_info,
		    &dip->disklabel);
		if (st != NULL) {
			printf("%s\n", st);
			return ERDLAB;
		}
		dip->bios_info.flags &= !BDI_BADLABEL;
	}
d706 16
@


1.8
log
@make “boot msdos.sys” (without a ‘/’ before the filename) work
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.7 2008/11/08 23:04:07 tg Exp $ */
d382 1
a382 1
	daddr_t off = LABELSECTOR;
a404 1
		off = 0;
d442 2
a443 3
		if (!off)
			return("no BSD partition\n");

@


1.7
log
@more mass conversions, including ancient eMail addresses
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.6 2008/08/01 11:24:59 tg Exp $ */
d519 2
a520 1
	cp++;	/* skip ':' */
d580 2
a581 1
	cp++;	/* skip ':' */
@


1.6
log
@merge and reduce diff to obsd
XXX not yet tested
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.5 2006/08/19 14:20:29 tg Exp $ */
d8 1
a8 1
 *	Thorsten "mirabilos" Glaser <tg@@66h.42h.de>
@


1.5
log
@attempt to shrink fdboot even more
@
text
@d1 2
a2 2
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.4 2005/12/04 13:22:16 tg Exp $ */
/*	$OpenBSD: biosdev.c,v 1.69 2004/06/23 00:21:49 tom Exp $	*/
d7 2
a8 2
 * Copyright (c) 2002, 2003, 2004, 2005
 *	Thorsten "mirabile" Glaser <tg@@66h.42h.de>
d105 1
a105 1
		printf("getinfo: try #8, 0x%X, %p\n", dev, pdi);
d119 1
a119 1
		printf("disk 0x%X: %d,%d,%d\n", dev, pdi->bios_cylinders,
a121 1
	getchar();
d132 10
a141 17
	/* Sanity check */
	if (!pdi->bios_cylinders || !pdi->bios_heads || !pdi->bios_sectors) {
#ifdef BIOS_DEBUG
		printf("sanity: c/h/s value zero: %d/%d/%d\n",
		    pdi->bios_cylinders, pdi->bios_heads, pdi->bios_sectors);
#endif
		return(1);
	}

	/* CD-ROMs sometimes return heads == 1 */
	if (pdi->bios_heads < 2) {
#ifdef BIOS_DEBUG
		printf("sanity: c/h/s heads < 2\n");
#endif
		return(1);
	}

d144 1
d147 1
a147 1
			printf("getinfo: try #41, 0x%X\n", dev);
d157 1
d160 2
a161 2
			printf("getinfo: got #41: %X\n", pdi->bios_edd);
			printf("disk 0x%X: 0x%X\n", dev, bm);
a162 1
		getchar();
d164 6
d173 21
d286 1
a286 1
	if (bd->flags & BDI_ELTORITO) {		/* It's a CD device */
d301 1
a301 1
	 * not access above 1 MB.
d305 1
a305 1
	    (((u_int32_t)buf) > 0x100000)) {
d312 1
a312 1
			memmove(bb, buf, bbsize);
d353 3
a355 5
			if (debug) {
				printf("\nBIOS error 0x%X (%s)\n",
					error, biosdisk_err(error));
				getchar();
			}
d363 1
a363 1
		memmove(buf, bb, bbsize);
d368 1
a368 1
			printf("=0x%X(%s)", error, biosdisk_err(error));
d454 1
a454 1
		printf("loading disklabel @@%u\n", off);
d494 2
a495 3
	for (maj = 0; maj < nbdevs &&
	     strncmp(*file, bdevs[maj], cp - *file); maj++)
		;
d567 1
a567 1
	if(dip->bios_info.flags & BDI_BADLABEL) {
d689 1
a689 1
			printf("=0x%X(%s)", error, biosdisk_err(error));
@


1.4
log
@implement "user partition type" in the bootloader
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.3 2005/04/29 18:34:59 tg Exp $ */
d372 1
a372 1
		return "failed to read disklabel";
d441 2
a442 2
	if(error)
		return("failed to read disklabel (try again if floppy!)");
d572 1
d606 1
@


1.3
log
@(tentative) merge, more to come
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/biosdev.c,v 1.2 2005/03/06 21:27:05 tg Exp $ */
d7 1
a7 1
 * Copyright (c) 2002, 2003, 2004
d56 1
d387 2
a388 1
		for (off = 0, i = 0; off == 0 && i < NDOSPART; i++) {
d390 4
a395 1
		}
@


1.2
log
@* merge src/sys/
  (at least the better part of it)
* revert IPv6 networking to OpenBSD, since
  I didn't get IPV4_MAPPED addresses working :(
@
text
@d1 2
a2 2
/**	$MirOS$ */
/*	$OpenBSD: biosdev.c,v 1.68 2004/03/09 19:12:12 tom Exp $	*/
d40 1
d263 1
d265 20
a284 3
	/* use a bounce buffer to not cross 64k DMA boundary */
	if ((((u_int32_t)buf) & ~0xffff) !=
	    (((u_int32_t)buf + nsect * DEV_BSIZE) & ~0xffff)) {
d289 1
a289 1
		bb = alloca(nsect * DEV_BSIZE);
d291 1
a291 1
			memmove(bb, buf, nsect * DEV_BSIZE);
d344 1
a344 1
		memmove(buf, bb, nsect * DEV_BSIZE);
d512 3
@


1.1
log
@Initial revision
@
text
@d1 1
d7 2
d45 2
a46 2
static const char *biosdisk_err(u_int);
static int biosdisk_errno(u_int);
d48 3
a50 2
static int CHS_rw (int, int, int, int, int, int, void *);
static int EDD_rw (int, int, u_int64_t, u_int32_t, void *);
d54 1
d77 1
a77 1
static int
d103 1
a103 1
		printf("getinfo: try #8, 0x%x, %p\n", dev, pdi);
d117 1
a117 1
		printf("disk 0x%x: %d,%d,%d\n", dev, pdi->bios_cylinders,
d120 1
d132 7
a138 2
	if (!pdi->bios_cylinders || !pdi->bios_heads || !pdi->bios_sectors)
		return 1;
d141 6
a146 2
	if (pdi->bios_heads < 2)
		return 1;
a147 10
	/* NOTE:
	 * This currently hangs/reboots some machines
	 * The IBM Thinkpad 750ED for one.
	 *
	 * Funny that an IBM/MS extension would not be
	 * implemented by an IBM system...
	 *
	 * Future hangs (when reported) can be "fixed"
	 * with getSYSCONFaddr() and an exceptions list.
	 */
a149 1

d152 1
a152 1
			printf("getinfo: try #41, 0x%x\n", dev);
a161 1

d164 2
a165 2
			printf("getinfo: got #41\n");
			printf("disk 0x%x: 0x%x\n", dev, bm);
d167 1
a168 6
		/*
		 * If extended disk access functions are not supported
		 * there is not much point on doing EDD.
		 */
		if (!(pdi->bios_edd & EXT_BM_EDA))
			pdi->bios_edd = -1;
d181 20
d272 1
a272 1
			bcopy(buf, bb, nsect * DEV_BSIZE);
d313 5
a317 3
			if (debug)
				printf("\nBIOS error 0x%x (%s)\n",
				    error, biosdisk_err(error));
d325 1
a325 1
		bcopy(bb, buf, nsect * DEV_BSIZE);
d330 1
a330 1
			printf("=0x%x(%s)", error, biosdisk_err(error));
d348 1
d357 2
a358 1
		error = biosd_io(F_READ, bd, DOSBBSECTOR, 1, &mbr);
d366 9
a374 2
		/* Search for OpenBSD partition */
		for (off = 0, i = 0; off == 0 && i < NDOSPART; i++)
d376 1
a376 1
				off = mbr.dmbr_parts[i].dp_start + LABELSECTOR;
d379 3
a381 5
		if (off == 0)
			for (off = 0, i = 0; off == 0 && i < NDOSPART; i++)
				if (mbr.dmbr_parts[i].dp_typ == DOSPTYP_NETBSD)
					off = mbr.dmbr_parts[i].dp_start +
					    LABELSECTOR;
d383 22
a404 2
		if (off == 0)
			return "no BSD partition\n";
d412 1
a412 1
		printf("loading disklabel @@ %u\n", off);
d417 2
a418 2
	if (error)
		return "failed to read disklabel";
d452 3
a454 2
	for (maj = 0; maj < nbdevs && strncmp(*file, bdevs[maj], cp - *file); )
	    maj++;
d523 1
a523 1
	if (dip->bios_info.flags & BDI_BADLABEL){
d526 1
a526 2
#ifdef BIOS_DEBUG
		if (debug && st)
a527 5
#endif
		if (!st) {
			dip->bios_info.flags &= ~BDI_BADLABEL;
			dip->bios_info.flags |= BDI_GOODLABEL;
		} else
d529 2
d535 6
d580 1
a580 1
static const char *
d610 1
a610 1
static int
d643 1
a643 1
			printf("=0x%x(%s)", error, biosdisk_err(error));
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@improve my Frankenstein OS (*wink* you know who you are) further
sans wchar_t of course

this is the essence of reading >1200 commit messages which suck
due to not having the new format of ours...
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.69 2004/06/23 00:21:49 tom Exp $	*/
a36 1
#include <isofs/cd9660/iso.h>
a49 1
int bios_cddev = -1;		/* Set by srt0 if coming from CD */
a243 4
	int bbsize = nsect * DEV_BSIZE;

	if (bd->flags & BDI_EL_TORITO) {	/* It's a CD device */
		dev &= 0xff;			/* Mask out this flag bit */
d245 3
a247 17
		/*
		 * sys/lib/libsa/cd9600.c converts 2,048-byte CD sectors
		 * to DEV_BSIZE blocks before calling the device strategy
		 * routine.  However, the El Torito spec says that the
		 * BIOS will work in 2,048-byte sectors.  So shift back.
		 */
		off >>= (ISO_DEFAULT_BLOCK_SHIFT - DEV_BSHIFT);
		nsect >>= (ISO_DEFAULT_BLOCK_SHIFT - DEV_BSHIFT);
	}

	/*
	 * Use a bounce buffer to not cross 64k DMA boundary, and to
	 * not access above 1 MB.
	 */
	if (((((u_int32_t)buf) & ~0xffff) !=
	    (((u_int32_t)buf + bbsize) & ~0xffff)) ||
	    (((u_int32_t)buf) > 0x100000)) {
d252 1
a252 1
		bb = alloca(bbsize);
d254 1
a254 1
			bcopy(buf, bb, bbsize);
d305 1
a305 1
		bcopy(bb, buf, bbsize);
a444 3
	case 6:  /* cd */
		biosdev = bios_bootdev & 0xff;
		break;
@


1.1.1.3
log
@import bootloader-related pieces from openbsd, as first part of the
aspired 4.4 merge… and something else
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.74 2008/06/25 15:32:18 reyk Exp $	*/
a48 3
static daddr_t findopenbsd(bios_diskinfo_t *, daddr_t, daddr_t *,
    const char **, int *);

d127 8
d137 1
a137 1
	 * The IBM ThinkPad 750ED for one.
a175 12
	/* Skip sanity check for CHS options in EDD mode. */
	if (pdi->bios_edd != -1)
		return 0;

	/* Sanity check */
	if (!pdi->bios_cylinders || !pdi->bios_heads || !pdi->bios_sectors)
		return 1;

	/* CD-ROMs sometimes return heads == 1 */
	if (pdi->bios_heads < 2)
		return 1;

d263 1
a263 1
	 * not access 1 MB or above.
d267 1
a267 1
	    (((u_int32_t)buf) >= 0x100000)) {
a340 62
static daddr_t
findopenbsd(bios_diskinfo_t *bd, daddr_t off, daddr_t *roff, const char **err,
    int *n)
{
	int error, i;
	struct dos_mbr mbr;
	struct dos_partition *dp;

	/* Limit the number of recursions */
	if (!(*n)--) {
		*err = "too many extended partitions";
		return (0);
	}

	/* Read MBR */
	error = biosd_io(F_READ, bd, off, 1, &mbr);
	if (error) {
		*err = biosdisk_err(error);
		return (0);
	}

	/* check mbr signature */
	if (mbr.dmbr_sign != DOSMBR_SIGNATURE) {
		*err = "bad MBR signature\n";
		return (0);
	}

	/* Search for OpenBSD partition */
	for (off = 0, i = 0; off == 0 && i < NDOSPART; i++) {
		dp = &mbr.dmbr_parts[i];
#ifdef BIOS_DEBUG
		if (debug)
			printf("found partition %u: "
			    "type %u (0x%x) offset %u (0x%x)\n",
			    (int)(dp - mbr.dmbr_parts),
			    dp->dp_typ, dp->dp_typ,
			    dp->dp_start, dp->dp_start);
#endif
		if (dp->dp_typ == DOSPTYP_OPENBSD)
			off = dp->dp_start;
		else if (dp->dp_typ == DOSPTYP_EXTEND ||
		    dp->dp_typ == DOSPTYP_EXTENDL) {
			off = findopenbsd(bd, dp->dp_start, roff, err, n);
			if (off != 0)
				*roff = dp->dp_start;
		}
	}

#ifdef BIOS_DEBUG
	if (debug)
		printf("using offset %u\n", off);
#endif

	if (off == 0) {
		if (*err == NULL)
			*err = "no OpenBSD partition\n";
		return (0);
	}

	return (off);
}

d344 1
a344 1
	daddr_t off = 0, roff = 0;
d346 2
a347 3
	const char *err = NULL;
	int error;
	int n = 8;
d350 1
a350 2
	if (bd->bios_edd == -1 &&
	    (bd->bios_heads == 0 || bd->bios_sectors == 0))
d355 25
a379 8
		off = findopenbsd(bd, DOSBBSECTOR, &roff, &err, &n);
		if (off == 0) {
			if (err != NULL)
				return (err);
 			return "no OpenBSD partition\n";
		}
	}
	off = LABELSECTOR + off + roff;
@


