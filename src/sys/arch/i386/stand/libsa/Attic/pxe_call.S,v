head	1.5;
access;
symbols
	tg-beforemerge-ksrc10:1.1.1.3
	cvs-200808011000:1.1.1.3
	MIRBSD_10:1.1.1.2.0.4
	MIRBSD_10_BASE:1.1.1.2
	MIRBSD_9_BASE:1.1.1.2
	MIRBSD_8:1.1.1.2.0.2
	MIRBSD_8_BASE:1.1.1.2
	cvs-200507032030:1.1.1.2
	cvs-200505050030:1.1.1.2
	cvs-200504302230:1.1.1.2
	cvs-200504291700:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@# @;


1.5
date	2009.01.12.18.07.23;	author tg;	state dead;
branches;
next	1.4;
commitid	100496B86EE452CAA71;

1.4
date	2009.01.10.12.32.53;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004968956D7B5782AF;

1.3
date	2009.01.10.12.09.26;	author tg;	state Exp;
branches;
next	1.2;
commitid	10049688FF731469C29;

1.2
date	2009.01.10.11.58.01;	author tg;	state Exp;
branches;
next	1.1;
commitid	10049688D4C6703171F;

1.1
date	2005.02.05.17.27.29;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.27.29;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.29.17.05.49;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.08.01.10.28.38;	author tg;	state Exp;
branches;
next	;
commitid	1004892E54805BE97AB;


desc
@@


1.5
log
@more cool pxe calls
@
text
@/*	$OpenBSD: pxe_call.S,v 1.4 2006/01/02 00:26:29 tom Exp $ */
/*	$NetBSD: pxe_call.S,v 1.2 2002/03/27 17:24:22 kanaoka Exp $	*/

/*
 * Copyright 2001 Wasabi Systems, Inc.
 * All rights reserved.
 *
 * Written by Jason R. Thorpe for Wasabi Systems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed for the NetBSD Project by
 *	Wasabi Systems, Inc.
 * 4. The name of Wasabi Systems, Inc. may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Low level PXE BIOS call glue.
 */

#include <machine/asm.h>
#include <assym.h>

#include "gidt.h"

	.globl	prot_to_real
	.globl	real_to_prot

ENTRY(pxecall_bangpxe)
	.code32
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	pushl	%ecx
	pushl	%edx

	/* For simplicity, just move all 32 bits. */
	movl	8(%ebp), %ebx

	pushw	_C_LABEL(pxe_command_buf_seg)
	pushw	_C_LABEL(pxe_command_buf_off)
	pushw	%bx

	cli
	call	prot_to_real			/* Enter real mode */
	.code16

	sti
	/* The encoding is: 0x9a offlo offhi seglo seghi */
	lcall	$0, $0xffff
	.globl	_C_LABEL(bangpxe_off)
_C_LABEL(bangpxe_off) = . - 4
	.globl	_C_LABEL(bangpxe_seg)
_C_LABEL(bangpxe_seg) = . - 2

	cli
	call	real_to_prot			/* Leave real mode */
	.code32

	add	$6, %esp

	popl	%edx
	popl	%ecx
	popl	%ebx
	popl	%ebp
	ret

ENTRY(pxecall_pxenv)
	.code32
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	pushl	%ecx
	pushl	%edx
	pushl	%edi

	/*
         * Using the PXENV+ calling convention, the (16 bit) function
         * number is passed in %bx, with the address of the command
         * buffer in %es:%di.
	 */
	movl	8(%ebp), %ebx	/* For simplicity, just move all 32 bits. */

	/*
	 * prot_to_real() will set %es to BOOTSEG, so we just need to set
	 * %(e)di up here.  Remember to relocate it!
	 */
	movl	$_C_LABEL(pxe_command_buf), %edi
	subl	$SA_LINKADDR, %edi

	cli
	call	prot_to_real			/* Enter real mode */
	.code16

	/* The encoding is: 0x9a offlo offhi seglo seghi */
	lcall	$0, $0xffff
	.globl	_C_LABEL(pxenv_off)
_C_LABEL(pxenv_off) = . - 4
	.globl	_C_LABEL(pxenv_seg)
_C_LABEL(pxenv_seg) = . - 2

	cli
	call	real_to_prot			/* Leave real mode */
	.code32

	popl	%edi
	popl	%edx
	popl	%ecx
	popl	%ebx
	popl	%ebp
	ret

	.end
@


1.4
log
@preserve ESP(16:19) into real mode SS, and real mode SS:SP into ESP(0:19);
sprinkle a few cli insns
@
text
@@


1.3
log
@move prot_to_real and real_to_prot to gidt.S for global use and
generalisation; begin not caring about _C_LABEL()
@
text
@d48 3
d66 1
d113 1
d124 1
a134 3
	.globl	prot_to_real
	.globl	real_to_prot

@


1.2
log
@LINKADDR, LINKSEG, LOADADDR, LOADSEG, SA_{LINK,LOAD}{ADDR,SEG} cleanup
@
text
@a128 5
/*
 * prot_to_real()
 *
 * Switch the processor back into real mode.
 */
a129 46
prot_to_real:
	.code32
	ljmp	$S16TEXT, $p2r16 - SA_LINKADDR
p2r16:
	.code16

	movw	$S16DATA, %ax
	movw	%ax, %ds
	movw	%ax, %es

	movl	%cr0, %eax		/* Disable protected mode */
	andl 	$~CR0_PE, %eax
	movl	%eax, %cr0

	/* reload real cs:ip */
	data32 ljmp	$(SA_LINKADDR >> 4), $p2r16real - SA_LINKADDR
p2r16real:
	xorw	%ax, %ax		/* Reset segment registers: */
	movw	%ax, %ss		/* %ss: for our stack */

	movw	$SA_LINKADDR >> 4, %ax	/* We're linked to SA_LINKADDR/16:0000 */
	movw	%ax, %ds		/* %ds: so we can get at Idtr_real */

	.extern	Idtr_real
	data32 addr32 lidt (Idtr_real - SA_LINKADDR);	/* Set up IDT for real mode */

	movw	%cs, %ax
	movw	%ax, %ds
	movw	%ax, %es		/* Set %ds = %es = %cs */

	/*
	 * We were called from 32-bit mode, so there's a 32-bit
	 * return address on the stack.  No segment.  This is within
	 * the flat memory model, so we need to adjust it back so
	 * that it's relative to our 16-bit %cs.
	 */
	popl	%eax
	subl	$SA_LINKADDR, %eax
	pushw	%ax
	ret

/*
 * real_to_prot()
 *
 * Switch the processor back into protected mode.
 */
a130 29
real_to_prot:
	.code16

	movw	$SA_LINKADDR >> 4, %ax	/* We're linked to SA_LINKADDR/16:0000 */
	movw	%ax, %ds
	data32 addr32 lgdt (Gdtr - SA_LINKADDR)	/* Reload the GDT */

	movl	%cr0, %eax		/* Enable protected mode */
	orl	$CR0_PE, %eax
	movl	%eax, %cr0

	data32 ljmp	$S32TEXT, $r2p32 /* Reload %cs, flush pipeline */
r2p32:
	.code32
	/* Reload 32-bit %ds, %ss, %es */
	movl	$S32DATA, %eax
	mov	%ax, %ds
	mov	%ax, %ss
	mov	%ax, %es

	/* Load IDT for debugger and DOS/BIOS interface */
	.extern	Idtr
	lidt	Idtr

	xorl	%eax, %eax
	popw	%ax			/* 16-bit return addr on stack */
	addl	$SA_LINKADDR, %eax
	pushl	%eax			/* Now have correct 32-bit ret addr */
	ret
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: pxe_call.S,v 1.1 2004/03/19 13:48:18 tom Exp $ */
d95 13
a107 2
	/* For simplicity, just move all 32 bits. */
	movl	8(%ebp), %ebx
a111 3
	/* prot_to_real() has already set %es to BOOTSEG */
	lea	_C_LABEL(pxe_command_buf), %di

d137 1
a137 1
	ljmp	$S16TEXT, $p2r16 - LINKADDR
d150 1
a150 1
	data32 ljmp	$(LINKADDR >> 4), $p2r16real - LINKADDR
d153 3
a156 1
	movw	%ax, %ss		/* %ss: for our stack */
d159 1
a159 1
	data32 addr32 lidt Idtr_real;	/* Set up IDT for real mode */
d172 1
a172 1
	subl	$LINKADDR, %eax
d185 3
a187 3
	xorw	%ax, %ax
	movw	%ax, %ds		/* Load %ds so we can get at Gdtr */
	data32 addr32 lgdt Gdtr		/* Load the GDT */
d208 1
a208 1
	addl	$LINKADDR, %eax
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@improve my Frankenstein OS (*wink* you know who you are) further
sans wchar_t of course

this is the essence of reading >1200 commit messages which suck
due to not having the new format of ours...
@
text
@d1 1
a1 1
/*	$OpenBSD: pxe_call.S,v 1.3 2005/04/25 23:09:04 tom Exp $ */
d145 1
a147 3
	movw	$LINKADDR >> 4, %ax	/* We're linked to LINKADDR/16:0000 */
	movw	%ax, %ds		/* %ds: so we can get at Idtr_real */

d149 1
a149 1
	data32 addr32 lidt (Idtr_real - LINKADDR);	/* Set up IDT for real mode */
d175 3
a177 3
	movw	$LINKADDR >> 4, %ax	/* We're linked to LINKADDR/16:0000 */
	movw	%ax, %ds
	data32 addr32 lgdt (Gdtr - LINKADDR)	/* Reload the GDT */
@


1.1.1.3
log
@import bootloader-related pieces from openbsd, as first part of the
aspired 4.4 mergeâ€¦ and something else
@
text
@d1 1
a1 1
/*	$OpenBSD: pxe_call.S,v 1.4 2006/01/02 00:26:29 tom Exp $ */
d95 2
a96 13
	/*
         * Using the PXENV+ calling convention, the (16 bit) function
         * number is passed in %bx, with the address of the command
         * buffer in %es:%di.
	 */
	movl	8(%ebp), %ebx	/* For simplicity, just move all 32 bits. */

	/*
	 * prot_to_real() will set %es to BOOTSEG, so we just need to set
	 * %(e)di up here.  Remember to relocate it!
	 */
	movl	$_C_LABEL(pxe_command_buf), %edi
	subl	$LINKADDR, %edi
d101 3
@


