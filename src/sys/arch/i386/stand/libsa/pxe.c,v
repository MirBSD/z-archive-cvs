head	1.22;
access;
symbols
	tg-use_ldscript:1.22.0.2
	tg-beforemerge-ksrc10:1.1.1.3
	cvs-200808011000:1.1.1.3
	MIRBSD_10:1.3.0.4
	MIRBSD_10_BASE:1.3
	MIRBSD_9_BASE:1.3
	MIRBSD_8:1.3.0.2
	MIRBSD_8_BASE:1.3
	cvs-200507032030:1.1.1.2
	cvs-200505050030:1.1.1.2
	cvs-200504302230:1.1.1.2
	cvs-200504291700:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2009.10.27.13.54.28;	author tg;	state Exp;
branches
	1.22.2.1;
next	1.21;
commitid	1004AE6FB9F32247080;

1.21
date	2009.10.27.13.30.05;	author tg;	state Exp;
branches;
next	1.20;
commitid	1004AE6F5F14E590CEA;

1.20
date	2009.10.27.13.10.52;	author tg;	state Exp;
branches;
next	1.19;
commitid	1004AE6F16B0F4750A9;

1.19
date	2009.03.15.17.14.14;	author tg;	state Exp;
branches;
next	1.18;
commitid	10049BD3767005E1F75;

1.18
date	2009.01.12.19.39.22;	author tg;	state Exp;
branches;
next	1.17;
commitid	100496B9C570A2B6734;

1.17
date	2009.01.12.19.38.09;	author tg;	state Exp;
branches;
next	1.16;
commitid	100496B9C35652EA82B;

1.16
date	2009.01.12.19.04.12;	author tg;	state Exp;
branches;
next	1.15;
commitid	100496B94381CC5BC46;

1.15
date	2009.01.12.18.07.23;	author tg;	state Exp;
branches;
next	1.14;
commitid	100496B86EE452CAA71;

1.14
date	2009.01.11.14.50.27;	author tg;	state Exp;
branches;
next	1.13;
commitid	100496A07264B6C9A0D;

1.13
date	2009.01.11.14.40.28;	author tg;	state Exp;
branches;
next	1.12;
commitid	100496A04CF0C3726C0;

1.12
date	2009.01.11.14.38.32;	author tg;	state Exp;
branches;
next	1.11;
commitid	100496A047B6CC979DF;

1.11
date	2009.01.11.14.38.04;	author tg;	state Exp;
branches;
next	1.10;
commitid	100496A04635123ACF0;

1.10
date	2009.01.10.22.21.24;	author tg;	state Exp;
branches;
next	1.9;
commitid	10049691F7369936F85;

1.9
date	2009.01.10.22.18.54;	author tg;	state Exp;
branches;
next	1.8;
commitid	10049691EDB67E0F5CA;

1.8
date	2009.01.10.20.29.42;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004969054E72D49084;

1.7
date	2009.01.10.20.28.28;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004969050259BEA59F;

1.6
date	2009.01.10.13.03.40;	author tg;	state Exp;
branches;
next	1.5;
commitid	10049689CC34D57A5B2;

1.5
date	2008.09.06.22.20.59;	author tg;	state Exp;
branches;
next	1.4;
commitid	10048C3024808C8EDD3;

1.4
date	2008.08.01.11.25.00;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004892F2924667C00D;

1.3
date	2005.04.29.18.34.59;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.06.21.27.07;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.27.29;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.22.2.1
date	2009.10.27.15.10.51;	author tg;	state Exp;
branches;
next	;
commitid	1004AE70D6303F6EF50;

1.1.1.1
date	2005.02.05.17.27.29;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.29.17.05.48;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.08.01.10.28.38;	author tg;	state Exp;
branches;
next	;
commitid	1004892E54805BE97AB;


desc
@@


1.22
log
@new command "machine pxe", although I somehow don't think it helps much…
@
text
@/**	$MirOS: src/sys/arch/i386/stand/libsa/pxe.c,v 1.21 2009/10/27 13:30:05 tg Exp $ */
/*	$OpenBSD: pxe.c,v 1.5 2007/07/27 17:46:56 tom Exp $ */
/*	$NetBSD: pxe.c,v 1.5 2003/03/11 18:29:00 drochner Exp $	*/

/*
 * Copyright 2001 Wasabi Systems, Inc.
 * All rights reserved.
 *
 * Written by Jason R. Thorpe for Wasabi Systems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed for the NetBSD Project by
 *	Wasabi Systems, Inc.
 * 4. The name of Wasabi Systems, Inc. may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 2009 Thorsten Glaser
 * Copyright (c) 2000 Alfred Perlstein <alfred@@freebsd.org>
 * All rights reserved.
 * Copyright (c) 2000 Paul Saab <ps@@freebsd.org>
 * All rights reserved.
 * Copyright (c) 2000 John Baldwin <jhb@@freebsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Support for the Intel Preboot Execution Environment (PXE).
 *
 * PXE provides a UDP implementation as well as a UNDI network device
 * driver.  UNDI is much more complicated to use than PXE UDP, so we
 * use PXE UDP as a cheap and easy way to get PXE support.
 */

#include <sys/param.h>
#include <sys/socket.h>

#ifdef _STANDALONE
#include <sys/slibkern.h>
#else
#include <string.h>
#endif

#include <net/if.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#include <netinet/udp.h>
#include <netinet/udp_var.h>

#include <libsa.h>
#include <lib/libsa/net.h>
#include <lib/libsa/bootp.h>

#include <stand/boot/bootarg.h>

#include "pxeboot.h"
#include "pxe.h"
#include "pxe_netif.h"

#define PXE_LOUD 0

extern uint32_t pxe_bang;
extern uint32_t pxe_plus;
extern uint32_t pxecall_addr;

int have_pxe = -1;

int (*pxe_call)(u_int16_t);
int Xpxe(void);

extern int pxecall_bang(u_int16_t);
extern int pxecall_plus(u_int16_t);

extern char pxe_command_buf[256];

BOOTPLAYER bootplayer;

struct in_addr servip;			/* for tftp */	/* XXX init this */

extern char *bootmac;			/* To pass to kernel */

/* static struct btinfo_netif bi_netif; */

/*****************************************************************************
 * This section is a replacement for libsa/udp.c
 *****************************************************************************/

/* Caller must leave room for ethernet, ip, and udp headers in front!! */
ssize_t
pxesendudp(struct iodesc *d, void *pkt, size_t len)
{
	t_PXENV_UDP_WRITE *uw = (void *) pxe_command_buf;

	uw->status = 0;

	uw->ip = d->destip.s_addr;
	uw->gw = gateip.s_addr;
	uw->src_port = d->myport;
	uw->dst_port = d->destport;
	uw->buffer_size = len;
	uw->buffer.segment = VTOPSEG(pkt);
	uw->buffer.offset = VTOPOFF(pkt);

	pxe_call(PXENV_UDP_WRITE);

	if (uw->status != PXENV_STATUS_SUCCESS) {
		/* XXX This happens a lot; it shouldn't. */
		if (uw->status != PXENV_STATUS_FAILURE)
			printf("sendudp: PXENV_UDP_WRITE failed: 0x%x\n",
			    uw->status);
		return -1;
	}

	return len;
}

/*
 * Receive a UDP packet and validate it for us.
 * Caller leaves room for the headers (Ether, IP, UDP).
 */
ssize_t
pxereadudp(struct iodesc *d, void *pkt, size_t len, time_t tleft)
{
	t_PXENV_UDP_READ *ur = (void *) pxe_command_buf;
	struct udphdr *uh;
	struct ip *ip;

	uh = (struct udphdr *)pkt - 1;
	ip = (struct ip *)uh - 1;

	bzero(ur, sizeof(*ur));

	ur->dest_ip = d->myip.s_addr;
	ur->d_port = d->myport;
	ur->buffer_size = len;
	ur->buffer.segment = VTOPSEG(pkt);
	ur->buffer.offset = VTOPOFF(pkt);

	/* XXX Timeout unused. */

	pxe_call(PXENV_UDP_READ);

	if (ur->status != PXENV_STATUS_SUCCESS) {
		/* XXX This happens a lot; it shouldn't. */
		if (ur->status != PXENV_STATUS_FAILURE)
			printf("readudp: PXENV_UDP_READ_failed: 0x%x\n",
			    ur->status);
		return -1;
	}

	ip->ip_src.s_addr = ur->src_ip;
	uh->uh_sport = ur->s_port;
	uh->uh_dport = d->myport;

	return ur->buffer_size;
}

/*
 * netif layer:
 *  open, close, shutdown: called from dev_net.c
 *  socktodesc: called by network protocol modules
 *
 * We only allow one open socket.
 */

static struct iodesc desc;

int
pxe_netif_open()
{
	t_PXENV_UDP_OPEN *uo = (void *) pxe_command_buf;

#ifdef NETIF_DEBUG
	printf("pxe_netif_open()\n");
#endif
	if (have_pxe < 0)
		pxe_init(0);
	if (!have_pxe)
		return (-1);

	/* BI_ADD(&bi_netif, BTINFO_NETIF, sizeof(bi_netif)); */

	bzero(uo, sizeof(*uo));

	uo->src_ip = bootplayer.yip;

	pxe_call(PXENV_UDP_OPEN);

	if (uo->status != PXENV_STATUS_SUCCESS) {
		printf("\npxe_netif_open: PXENV_UDP_OPEN failed: 0x%x\n",
		    uo->status);
		return -1;
	}

	bcopy(bootplayer.CAddr, desc.myea, ETHER_ADDR_LEN);
	bootmac = bootplayer.CAddr;

	/*
	 * Since the PXE BIOS has already done DHCP, make sure we
	 * don't reuse any of its transaction IDs.
	 */
	desc.xid = bootplayer.ident;

	return 0;
}

void
pxe_netif_close(sock)
	int sock;
{
	t_PXENV_UDP_CLOSE *uc = (void *) pxe_command_buf;

#ifdef NETIF_DEBUG
	if (sock != 0)
		printf("pxe_netif_close: sock=%d\n", sock);
#endif

	uc->status = 0;

	pxe_call(PXENV_UDP_CLOSE);

	if (uc->status != PXENV_STATUS_SUCCESS)
		printf("pxe_netif_end: PXENV_UDP_CLOSE failed: 0x%x\n",
		    uc->status);
}

void
pxe_netif_shutdown()
{
#ifdef NETIF_DEBUG
	printf("pxe_netif_shutdown()\n");
#endif

	pxe_shutdown();
}

struct iodesc *
pxesocktodesc(sock)
	int sock;
{

#ifdef NETIF_DEBUG
	if (sock != 0)
		return 0;
	else
#endif
		return &desc;
}

/*****************************************************************************
 * PXE initialization and support routines
 *****************************************************************************/

/* static struct btinfo_netif bi_netif; */

void
pxeprobe(void)
{
	if (have_pxe < 0) {
		pxe_init(1);
	}
}

#define try_pxenv(cp) do {					\
	pxenv = (pxenv_t *)cp;					\
	if (pxenv->Signature[0] == 'P' &&			\
	    pxenv->Signature[1] == 'X' &&			\
	    pxenv->Signature[2] == 'E' &&			\
	    pxenv->Signature[3] == 'N' &&			\
	    pxenv->Signature[4] == 'V' &&			\
	    pxenv->Signature[5] == '+') {			\
		for (i = 0, ucp = (u_int8_t *)cp, cksum = 0;	\
		     i < pxenv->Length; i++)			\
			cksum += ucp[i];			\
		if (cksum != 0) {				\
			printf("\npxe_init: bad cksum (0x%x) "	\
			    "for PXENVplus at 0x%lx\n", cksum,	\
			    (u_long) cp);			\
			pxenv = NULL;				\
		}						\
	} else							\
		pxenv = NULL;					\
} while (/* CONSTCOND */ 0)

#define try_pxe(cp) do {					\
	pxe = (pxe_t *)cp;					\
	if (pxe->Signature[0] == '!' &&				\
	    pxe->Signature[1] == 'P' &&				\
	    pxe->Signature[2] == 'X' &&				\
	    pxe->Signature[3] == 'E') {				\
		for (i = 0, ucp = (u_int8_t *)cp, cksum = 0;	\
		     i < pxe->StructLength; i++)		\
			cksum += ucp[i];			\
		if (cksum != 0) {				\
			printf("pxe_init: bad cksum (0x%x) "	\
			    "for bangPXE at 0x%lx\n", cksum,	\
			    (u_long) cp);			\
			pxe = NULL;				\
		}						\
	} else							\
		pxe = NULL;					\
} while (/* CONSTCOND */ 0)

int
pxe_init(int quiet)
{
	t_PXENV_GET_CACHED_INFO *gci = (void *) pxe_command_buf;
	pxenv_t *pxenv;
	pxe_t *pxe;
	char *cp;
	int i;
	u_int8_t cksum, *ucp;

	if (have_pxe >= 0) {
#if PXE_LOUD
		printf(" {no:have_pxe=%d}", have_pxe);
#endif
		return (have_pxe == 0 ? 1 : 0);
	}
	have_pxe = 0;
	if (!(i386_biosflags & 4)) {
#if PXE_LOUD
		printf(" {pxe_unlikely}");
#endif
		return (1);	/* not “probably” booted from PXE */
	}

	/*
	 * Checking for the presence of PXE is a machine-dependent
	 * operation.  On the IA-32, this can be done two ways:
	 *
	 *	Int 0x1a function 0x5650
	 *
	 *	Scan memory for the !PXE or PXENV+ signatures
	 *
	 * We do the latter, since the Int method returns a pointer
	 * to a deprecated structure (PXENV+).
	 */

	pxenv = NULL;
	pxe = NULL;

	if (pxe_plus) {
#if PXE_LOUD
		printf(" {try:plus=%X:%X}", pxe_plus >> 16,
		    pxe_plus & 0xFFFF);
#endif
		try_pxenv(PTOV(pxe_plus >> 16, pxe_plus & 0xFFFF));
	}

	if (pxe_bang) {
#if PXE_LOUD
		printf(" {try:bang=%X:%X}", pxe_bang >> 16,
		    pxe_bang & 0xFFFF);
#endif
		try_pxe(PTOV(pxe_bang >> 16, pxe_bang & 0xFFFF));
	}

	if (pxe_plus == pxe_bang && (pxe || pxenv)) {
#if PXE_LOUD
		printf(" {pxelinux}");
#endif
		goto got_one;	/* probably from SYSLINUX */
	}

	if (!(i386_dosdev & 1)) {
#if PXE_LOUD
		printf(" {pxe_disabled}");
#endif
		return (1);	/* PXE scan disabled */
	}

	for (cp = (char *)0x90000; cp >= (char *)0x10000; cp -= 0x10) {
		if (pxenv == NULL)
			try_pxenv(cp);
		if (pxe == NULL)
			try_pxe(cp);

		if (pxe != NULL && pxenv != NULL)
			break;
	}

	if (pxe == NULL && pxenv == NULL) {
#if !PXE_LOUD
		if (!quiet)
#endif
			printf("pxe_init: No PXE BIOS found.\n");
		return 1;
	}
#if PXE_LOUD
	printf(" {scan:pxenv=%X,pxe=%X}", (unsigned)pxenv, (unsigned)pxe);
#endif

 got_one:
	if (pxenv && (pxenv != PTOV(pxe_plus >> 16, pxe_plus & 0xFFFF)))
		pxe_plus = (((uint32_t)pxenv & 0xFFFF0) << 12) |
		    ((uint32_t)pxenv & 0x0000F);
	if (pxe && (pxe != PTOV(pxe_bang >> 16, pxe_bang & 0xFFFF)))
		pxe_bang = (((uint32_t)pxe & 0xFFFF0) << 12) |
		    ((uint32_t)pxe & 0x0000F);

	if (pxenv == NULL) {
		/* assert(pxe != NULL); */

		printf(quiet ? " pxe!" : "PXE present\n");
	} else {				/* pxenv != NULL */
		int bang = 0;

		if (pxenv->Version >= 0x0201 && pxe != NULL) {
			/* 2.1 or greater -- don't use PXENV+ */
			bang = 1;
		}

		if (quiet) {
			printf(" pxe%c[%d.%d]",
			    (bang ? '!' : '+'),
			    (pxenv->Version >> 8) & 0xff,
			     pxenv->Version & 0xff);
		} else {
			printf("PXE BIOS Version %d.%d\n",
			    (pxenv->Version >> 8) & 0xff,
			     pxenv->Version & 0xff);
		}

		if (bang) {
			pxenv = NULL;
		}
	}

	if (pxenv == NULL) {
		pxe_call = pxecall_bang;
		pxecall_addr = ((uint32_t)pxe->EntryPointSP.segment << 16) |
		    pxe->EntryPointSP.offset;
	} else {
		pxe_call = pxecall_plus;
		pxecall_addr = ((uint32_t)pxenv->RMEntry.segment << 16) |
		    pxenv->RMEntry.offset;
	}

	/*
	 * Get the cached info from the server's Discovery reply packet.
	 */
	bzero(gci, sizeof(*gci));
	gci->PacketType = PXENV_PACKET_TYPE_CACHED_REPLY;
	pxe_call(PXENV_GET_CACHED_INFO);

	if (gci->Status != PXENV_STATUS_SUCCESS) {
		printf("\npxeinfo: PXENV_GET_CACHED_INFO failed: 0x%x\n",
		    gci->Status);
		return 1;
	}

	memcpy(&bootplayer, PTOV(gci->Buffer.segment, gci->Buffer.offset),
	    gci->BufferSize);

	bcopy(&bootplayer.yip, &myip.s_addr, sizeof(myip.s_addr));
	bcopy(&bootplayer.sip, &servip.s_addr, sizeof(servip.s_addr));

        /* Compute our "natural" netmask. */
	if (IN_CLASSA(myip.s_addr))
		netmask = IN_CLASSA_NET;
	else if (IN_CLASSB(myip.s_addr))
		netmask = IN_CLASSB_NET;
	else
		netmask = IN_CLASSC_NET;

	have_pxe = 1;
	return 0;
}

void
pxeinfo(void)
{
	u_int8_t *p;
#ifdef PXE_DEBUG
	t_PXENV_UNDI_GET_NIC_TYPE *gnt = (void *) pxe_command_buf;
#endif

	if (have_pxe <= 0) {
		printf(" %s\n", have_pxe ? "err" : "none");
		return;
	}

	printf(" %s %X mac %s", pxe_call == pxecall_bang ? "!PXE" : "PXENV+",
	    (unsigned)pxecall_addr, ether_sprintf(bootplayer.CAddr));
	p = (u_int8_t *)&myip.s_addr;
	printf(", ip %d.%d.%d.%d", p[0], p[1], p[2], p[3]);
	p = (u_int8_t *)&servip.s_addr;
	printf(", server %d.%d.%d.%d", p[0], p[1], p[2], p[3]);

#ifdef PXE_DEBUG
	/*
	 * Get network interface information.
	 */
	bzero(gnt, sizeof(*gnt));
	pxe_call(PXENV_UNDI_GET_NIC_TYPE);

	if (gnt->Status != PXENV_STATUS_SUCCESS) {
		printf("\npxeinfo: PXENV_UNDI_GET_NIC_TYPE failed: 0x%x\n",
		    gnt->Status);
		return;
	}

	switch (gnt->NicType) {
	case PCI_NIC:
	case CardBus_NIC:
		/* strncpy(bi_netif.ifname, "pxe", sizeof(bi_netif.ifname)); */
		/* bi_netif.bus = BI_BUS_PCI; */
		/* bi_netif.addr.tag = gnt->info.pci.BusDevFunc; */

		printf("\nPXE: Using %s device at bus %d device %d function %d\n",
		    gnt->NicType == PCI_NIC ? "PCI" : "CardBus",
		    (gnt->info.pci.BusDevFunc >> 8) & 0xff,
		    (gnt->info.pci.BusDevFunc >> 3) & 0x1f,
		    gnt->info.pci.BusDevFunc & 0x7);
		break;

	case PnP_NIC:
		/* XXX Make bootinfo work with this. */
		printf("\nPXE: Using PnP device at 0x%x\n",
		    gnt->info.pnp.CardSelNum);
	}
#endif
}

void
pxe_shutdown(void)
{
	int try;
	t_PXENV_UNLOAD_STACK *unload = (void *) pxe_command_buf;
	t_PXENV_UNDI_SHUTDOWN *shutdown = (void *) pxe_command_buf;
#ifdef PXE_DEBUG
	t_PXENV_UDP_CLOSE *close = (void *) pxe_command_buf;
#endif

	if (pxe_call == NULL)
		return;

	/* Close any open UDP connections.  Ignore return value. */
	pxe_call(PXENV_UDP_CLOSE);
#ifdef PXE_DEBUG
	printf("pxe_shutdown: PXENV_UDP_CLOSE returned 0x%x\n", close->status);
#endif

	/* Sometimes PXENV_UNDI_SHUTDOWN doesn't work at first */
	for (try = 3; try > 0; try--) {
		pxe_call(PXENV_UNDI_SHUTDOWN);

		if (shutdown->Status == PXENV_STATUS_SUCCESS)
			break;

		printf("pxe_shutdown: PXENV_UNDI_SHUTDOWN failed: 0x%x\n",
		    shutdown->Status);

		if (try != 1)
			sleep(1);
	}

	/* Have multiple attempts at PXENV_UNLOAD_STACK, too */
	for (try = 3; try > 0; try--) {
		pxe_call(PXENV_UNLOAD_STACK);

		if (unload->Status == PXENV_STATUS_SUCCESS)
			break;

		printf("pxe_shutdown: PXENV_UNLOAD_STACK failed: 0x%x\n",
		    unload->Status);

		if (try != 1)
			sleep(1);
	}
}

extern void pxecheck(void);

int
Xpxe(void)
{
	have_pxe = -1;
#if 0
	pxe_plus = pxe_bang = 0;	/* override potentially passed stuff */
#endif
	i386_biosflags |= 4;		/* no pxe_unlikely */
	i386_dosdev |= 1;		/* no pxe_disabled */

	if (pxe_init(0))
		printf("Sorry, scan for PXE yielded no result.\n");
	else {
		printf("Yes, we have found a PXE boot ROM.\n=>");
		i386_biosflags &= ~4;	/* tftp is not the boot device */
		pxecheck();
		pxeinfo();
		putchar('\n');
	}
	return (0);
}
@


1.22.2.1
log
@attempt to move *all* of .bss to 3000:0000h and up
(when loaded via gPXE+PXELINUX, fighting memory corruption?)

XXX we *really* need a position-independent or relocatable boot
XXX loader; sadly, gcc’s idea of PIC/PIE cannot be of any help…
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/pxe.c,v 1.22 2009/10/27 13:54:28 tg Exp $ */
d122 1
a122 1
char pxe_command_buf[256];
@


1.21
log
@more debugging code
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/pxe.c,v 1.20 2009/10/27 13:10:52 tg Exp $ */
d117 1
d194 1
a194 1
			printf("readudp: PXENV_UDP_READ_failed: 0x%0x\n",
d393 1
a393 1
		printf(" {try:plus=%04X:%04X}", pxe_plus >> 16,
d401 1
a401 1
		printf(" {try:bang=%04X:%04X}", pxe_bang >> 16,
d532 1
a532 1
	printf(" %s %05X mac %s", pxe_call == pxecall_bang ? "!PXE" : "PXENV+",
d621 24
@


1.20
log
@support TSR-loaded PXE ROMs
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/pxe.c,v 1.19 2009/03/15 17:14:14 tg Exp $ */
d108 2
d361 4
a364 1
	if (have_pxe >= 0)
d366 1
d368 4
a371 1
	if (!(i386_biosflags & 4))
d373 1
d390 5
a394 1
	if (pxe_plus)
d396 1
d398 5
a402 1
	if (pxe_bang)
d404 1
d406 4
a409 1
	if (pxe_plus == pxe_bang && (pxe || pxenv))
d411 1
d413 4
a416 1
	if (!(i386_dosdev & 1))
d418 1
d431 4
a434 1
		if (!quiet) printf("pxe_init: No PXE BIOS found.\n");
d437 3
d531 2
a532 1
	printf(" mac %s", ether_sprintf(bootplayer.CAddr));
@


1.19
log
@make pxe_bang and pxe_plus always bear the addresses of the
respective structures; use new pxecall_addr for calling fns
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/pxe.c,v 1.18 2009/01/12 19:39:22 tg Exp $ */
d392 1
a392 1
	for (cp = (char *)0xa0000; cp >= (char *)0x10000; cp -= 0x10) {
@


1.18
log
@interrupts, flags paranoia, use registers ipv stack if possible,
return anything from the (*pxe_call)() and use CALL FAR instead
of double-return trick, etc.
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/pxe.c,v 1.16 2009/01/12 19:04:12 tg Exp $ */
d110 1
d408 7
d445 2
a446 2
		pxe_bang = pxe->EntryPointSP.segment;
		pxe_bang = (pxe_bang << 16) | pxe->EntryPointSP.offset;
d449 2
a450 2
		pxe_plus = pxenv->RMEntry.segment;
		pxe_plus = (pxe_plus << 16) | pxenv->RMEntry.offset;
@


1.17
log
@fix a logic error
@
text
@d113 1
a113 1
void	(*pxe_call)(u_int16_t);
d115 2
a116 2
extern void pxecall_bang(u_int16_t);
extern void pxecall_plus(u_int16_t);
@


1.16
log
@both PXENV+ and !PXE structures must be paragraph aligned
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/pxe.c,v 1.15 2009/01/12 18:07:23 tg Exp $ */
d385 1
a385 1
	if (pxe_plus == pxe_bang && (!pxe || !pxenv))
@


1.15
log
@more cool pxe calls
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/pxe.c,v 1.14 2009/01/11 14:50:27 tg Exp $ */
d391 1
a391 1
	for (cp = (char *)0xa0000; cp > (char *)0x10000; cp -= 2) {
@


1.14
log
@• only ever do PXE if “probably” booted from PXE
• disable the scan unless the startup address matches
• disable the scan, always, if called from multiboot
  (GNU GRUB 0.9x is just helpless)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/pxe.c,v 1.13 2009/01/11 14:40:28 tg Exp $ */
d115 2
a116 2
void	pxecall_bangpxe(u_int16_t);	/* pxe_call.S */
void	pxecall_pxenv(u_int16_t);	/* pxe_call.S */
a297 6
u_int16_t pxe_command_buf_seg;
u_int16_t pxe_command_buf_off;

extern u_int16_t bangpxe_off, bangpxe_seg;
extern u_int16_t pxenv_off, pxenv_seg;

d436 3
a438 3
		pxe_call = pxecall_bangpxe;
		bangpxe_off = pxe->EntryPointSP.offset;
		bangpxe_seg = pxe->EntryPointSP.segment;
d440 3
a442 3
		pxe_call = pxecall_pxenv;
		pxenv_off = pxenv->RMEntry.offset;
		pxenv_seg = pxenv->RMEntry.segment;
a445 7
	 * Pre-compute the segment/offset of the pxe_command_buf
	 * to make things nicer in the low-level calling glue.
	 */
	pxe_command_buf_seg = VTOPSEG(pxe_command_buf);
	pxe_command_buf_off = VTOPOFF(pxe_command_buf);

	/*
@


1.13
log
@move the pxe_command_buf to lower memory (between bounce_buf and stack),
as it's a rather large yet non-static structure

this marks the point where pxeboot(8) can/will no longer be built
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/pxe.c,v 1.12 2009/01/11 14:38:32 tg Exp $ */
d367 2
d394 3
@


1.12
log
@remove the scan exemption
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/pxe.c,v 1.11 2009/01/11 14:38:04 tg Exp $ */
d118 1
a118 1
char pxe_command_buf[256];
@


1.11
log
@do *not* embed “!PXE” or “PXENV+” in the binary
this is better than exempting our own space from the search,
due to relocation
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/pxe.c,v 1.10 2009/01/10 22:21:24 tg Exp $ */
a110 2
extern uint8_t _start, _end;

a392 3
		if (cp == (void *)&_end)
			cp = (void *)&_start;

@


1.10
log
@restrict scanning to area *outside* of our own .text
@
text
@d1 1
a1 1
/*	$MirOS: src/sys/arch/i386/stand/libsa/pxe.c,v 1.9 2009/01/10 22:18:54 tg Exp $ */
d41 1
d318 6
a323 3
	if (memcmp(pxenv->Signature, S_SIZE("PXENV+")) != 0)	\
		pxenv = NULL;					\
	else {							\
d329 1
a329 1
			    "for PXENV+ at 0x%lx\n", cksum,	\
d333 2
a334 1
	}							\
d339 4
a342 3
	if (memcmp(pxe->Signature, S_SIZE("!PXE")) != 0)	\
		pxe = NULL;					\
	else {							\
d348 1
a348 1
			    "for !PXE at 0x%lx\n", cksum,	\
d352 2
a353 1
	}							\
@


1.9
log
@more work towards unifying devices (and network)
@
text
@d1 1
a1 1
/*	$MirOS: src/sys/arch/i386/stand/libsa/pxe.c,v 1.8 2009/01/10 20:29:42 tg Exp $ */
d110 2
d388 3
@


1.8
log
@headers
@
text
@d1 1
a1 1
/*	$MirOS: src/sys/arch/i386/stand/libsa/pxe.c,v 1.7 2009/01/10 20:28:28 tg Exp $ */
d107 3
d313 34
d376 9
d386 4
a389 33
		if (pxenv == NULL) {
			pxenv = (pxenv_t *)cp;
			if (memcmp(pxenv->Signature, S_SIZE("PXENV+")) != 0)
				pxenv = NULL;
			else {
				for (i = 0, ucp = (u_int8_t *)cp, cksum = 0;
				     i < pxenv->Length; i++)
					cksum += ucp[i];
				if (cksum != 0) {
					printf("\npxe_init: bad cksum (0x%x) "
					    "for PXENV+ at 0x%lx\n", cksum,
					    (u_long) cp);
					pxenv = NULL;
				}
			}
		}

		if (pxe == NULL) {
			pxe = (pxe_t *)cp;
			if (memcmp(pxe->Signature, S_SIZE("!PXE")) != 0)
				pxe = NULL;
			else {
				for (i = 0, ucp = (u_int8_t *)cp, cksum = 0;
				     i < pxe->StructLength; i++)
					cksum += ucp[i];
				if (cksum != 0) {
					printf("pxe_init: bad cksum (0x%x) "
					    "for !PXE at 0x%lx\n", cksum,
					    (u_long) cp);
					pxe = NULL;
				}
			}
		}
d400 1
@


1.7
log
@shuffle some defns around
@
text
@d1 1
a1 1
/*	$MirOS: src/sys/arch/i386/stand/libsa/pxe.c,v 1.6 2009/01/10 13:03:40 tg Exp $ */
d97 1
a97 1
#include <lib/libsa/stand.h>
a101 1
#include <machine/biosvar.h>
@


1.6
log
@fix
@
text
@d1 1
a1 1
/*	$MirOS$ */
d442 1
a442 2
	memcpy(&bootplayer,
	    SEGOFF2FLAT(gci->Buffer.segment, gci->Buffer.offset),
@


1.5
log
@move lib/libkern/libkern.h to sys/slibkern.h where it gets installed,
since other installed headers reference it (e.g. for building LKMs)
@
text
@d1 1
d108 2
a206 1
static int pxe_inited;
d217 5
a221 5
	if (!pxe_inited) {
		if (pxe_init(0) != 0)
			return -1;
		pxe_inited = 1;
	}
d306 2
a307 4
	if (!pxe_inited) {
		if (pxe_init(1) == 0) {
			pxe_inited = 1;
		}
d321 4
d457 1
d469 5
@


1.4
log
@merge and reduce diff to obsd
XXX not yet tested
@
text
@d81 1
a81 1
#include <lib/libkern/libkern.h>
@


1.3
log
@(tentative) merge, more to come
@
text
@d1 1
a1 2
/**	$MirOS: src/sys/arch/i386/stand/libsa/pxe.c,v 1.2 2005/03/06 21:27:07 tg Exp $	*/
/*	$OpenBSD: pxe.c,v 1.3 2005/03/13 22:07:23 tom Exp $ */
d100 3
d118 2
d169 1
a169 1
	memset(ur, 0, sizeof(*ur));
d222 1
a222 1
	memset(uo, 0, sizeof(*uo));
d229 1
a229 1
		printf("pxe_netif_open: PXENV_UDP_OPEN failed: 0x%x\n",
d234 2
a235 1
	memmove(desc.myea, bootplayer.CAddr, ETHER_ADDR_LEN);
d428 1
a428 1
	memset(gci, 0, sizeof(*gci));
d438 1
a438 1
	memmove(&bootplayer,
d442 2
a443 2
	memmove(&myip.s_addr, &bootplayer.yip, sizeof(myip.s_addr));
	memmove(&servip.s_addr, &bootplayer.sip, sizeof(servip.s_addr));
d474 1
a474 1
	memset(gnt, 0, sizeof(*gnt));
@


1.2
log
@* merge src/sys/
  (at least the better part of it)
* revert IPv6 networking to OpenBSD, since
  I didn't get IPV4_MAPPED addresses working :(
@
text
@d1 2
a2 2
/**	$MirOS$	*/
/*	$OpenBSD: pxe.c,v 1.1 2004/03/19 13:48:18 tom Exp $ */
d379 1
a379 2
	}
	else {				/* pxenv != NULL */
d392 1
a392 2
		}
		else {
d403 1
a403 1
	if (pxe != NULL) {
@


1.1
log
@Initial revision
@
text
@d1 1
d165 1
a165 1
	bzero(ur, sizeof(*ur));
d218 1
a218 1
	bzero(uo, sizeof(*uo));
d230 1
a230 1
	bcopy(bootplayer.CAddr, desc.myea, ETHER_ADDR_LEN);
d425 1
a425 1
	bzero(gci, sizeof(*gci));
d435 1
a435 1
	memcpy(&bootplayer,
d439 2
a440 2
	bcopy(&bootplayer.yip, &myip.s_addr, sizeof(myip.s_addr));
	bcopy(&bootplayer.sip, &servip.s_addr, sizeof(servip.s_addr));
d471 1
a471 1
	bzero(gnt, sizeof(*gnt));
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@improve my Frankenstein OS (*wink* you know who you are) further
sans wchar_t of course

this is the essence of reading >1200 commit messages which suck
due to not having the new format of ours...
@
text
@d1 1
a1 1
/*	$OpenBSD: pxe.c,v 1.3 2005/03/13 22:07:23 tom Exp $ */
d378 2
a379 1
	} else {				/* pxenv != NULL */
d392 2
a393 1
		} else {
d404 1
a404 1
	if (pxenv == NULL) {
@


1.1.1.3
log
@import bootloader-related pieces from openbsd, as first part of the
aspired 4.4 merge… and something else
@
text
@d1 1
a1 1
/*	$OpenBSD: pxe.c,v 1.5 2007/07/27 17:46:56 tom Exp $ */
a99 3
#include <stand/boot/bootarg.h>
#include <machine/biosvar.h>

a114 2
extern char *bootmac;			/* To pass to kernel */

d224 1
a224 1
		printf("\npxe_netif_open: PXENV_UDP_OPEN failed: 0x%x\n",
a229 1
	bootmac = bootplayer.CAddr;
@


