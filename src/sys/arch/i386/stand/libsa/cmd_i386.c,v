head	1.28;
access;
symbols
	tg-use_ldscript:1.27.0.2
	tg-beforemerge-ksrc10:1.1.1.2
	cvs-200808011000:1.1.1.2
	MIRBSD_10:1.3.0.2
	MIRBSD_10_BASE:1.3
	MIRBSD_9_BASE:1.2
	MIRBSD_8:1.2.0.2
	MIRBSD_8_BASE:1.2
	cvs-200507032030:1.1.1.1
	cvs-200505050030:1.1.1.1
	cvs-200504302230:1.1.1.1
	cvs-200504291700:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.28
date	2012.05.26.16.22.53;	author tg;	state Exp;
branches;
next	1.27;
commitid	1004FC1034D2FA6D8FB;

1.27
date	2009.10.27.13.37.28;	author tg;	state Exp;
branches;
next	1.26;
commitid	1004AE6F7A57356F898;

1.26
date	2009.10.24.15.57.11;	author tg;	state Exp;
branches;
next	1.25;
commitid	1004AE323E248593E76;

1.25
date	2009.10.04.16.49.43;	author tg;	state Exp;
branches;
next	1.24;
commitid	1004AC8D234283AB203;

1.24
date	2009.01.11.13.36.05;	author tg;	state Exp;
branches;
next	1.23;
commitid	1004969F59F7F1E8AC2;

1.23
date	2009.01.11.00.32.40;	author tg;	state Exp;
branches;
next	1.22;
commitid	10049693E0D60AE6F9B;

1.22
date	2009.01.10.22.18.53;	author tg;	state Exp;
branches;
next	1.21;
commitid	10049691EDB67E0F5CA;

1.21
date	2009.01.10.20.28.28;	author tg;	state Exp;
branches;
next	1.20;
commitid	1004969050259BEA59F;

1.20
date	2009.01.02.20.37.30;	author tg;	state Exp;
branches;
next	1.19;
commitid	100495E7B1F18E55756;

1.19
date	2009.01.02.20.21.54;	author tg;	state Exp;
branches;
next	1.18;
commitid	100495E7752030AE5DA;

1.18
date	2009.01.02.04.58.41;	author tg;	state Exp;
branches;
next	1.17;
commitid	100495D9F177CADA327;

1.17
date	2009.01.02.02.13.21;	author tg;	state Exp;
branches;
next	1.16;
commitid	100495D78586304F02A;

1.16
date	2009.01.02.01.45.44;	author tg;	state Exp;
branches;
next	1.15;
commitid	100495D71D8397C7FCA;

1.15
date	2009.01.02.01.42.07;	author tg;	state Exp;
branches;
next	1.14;
commitid	100495D70FE181F1D55;

1.14
date	2009.01.01.23.59.02;	author tg;	state Exp;
branches;
next	1.13;
commitid	100495D58D45CD48443;

1.13
date	2009.01.01.23.29.00;	author tg;	state Exp;
branches;
next	1.12;
commitid	100495D51D05535E102;

1.12
date	2009.01.01.22.59.35;	author tg;	state Exp;
branches;
next	1.11;
commitid	100495D4AD91866874F;

1.11
date	2009.01.01.22.53.43;	author tg;	state Exp;
branches;
next	1.10;
commitid	100495D497E670D62A2;

1.10
date	2009.01.01.21.46.38;	author tg;	state Exp;
branches;
next	1.9;
commitid	100495D39C42DC869AB;

1.9
date	2008.12.28.18.56.11;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004957CBE16FA2F10B;

1.8
date	2008.12.28.18.18.04;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004957C2E623513D7B;

1.7
date	2008.12.28.18.10.09;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004957C10F46A47A24;

1.6
date	2008.08.01.12.39.07;	author tg;	state Exp;
branches;
next	1.5;
commitid	100489303F432B4030A;

1.5
date	2008.08.01.11.33.41;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004892F4A852F49ACD;

1.4
date	2008.08.01.11.24.59;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004892F2924667C00D;

1.3
date	2006.08.19.14.20.30;	author tg;	state Exp;
branches;
next	1.2;
commitid	10044E71E3D359AC2FA;

1.2
date	2005.03.06.21.27.05;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.27.28;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.27.28;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2008.08.01.10.28.37;	author tg;	state Exp;
branches;
next	;
commitid	1004892E54805BE97AB;


desc
@@


1.28
log
@Grml’s GRUB is becoming too fat a̲g̲a̲i̲n̲, allow 4 segments for the image
(and cross fingers we do not ever run into low-memory situations)
@
text
@/**	$MirOS: src/sys/arch/i386/stand/libsa/cmd_i386.c,v 1.27 2009/10/27 13:37:28 tg Exp $	*/
/*	$OpenBSD: cmd_i386.c,v 1.29 2006/09/18 21:14:15 mpf Exp $	*/

/*
 * Copyright (c) 1997-1999 Michael Shalayeff
 * Copyright (c) 1997 Tobias Weingartner
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/reboot.h>
#include <machine/biosvar.h>
#include <sys/disklabel.h>
#include "disk.h"
#include "debug.h"
#include "biosdev.h"
#include "libsa.h"
#include <cmd.h>
#include "cmd_i386.h"

extern const char version[];
extern int i386_flag_oldbios;

/* From gidt.S */
__dead void bootbuf(void *codebuf, uint32_t codesize, uint32_t code_esdi,
    int dl, uint32_t initial_csip);
__dead void rtdos(void);

#ifndef SMALL_BOOT
int
Xdiskinfo(void)
{
	dump_diskinfo();
	return 0;
}

int
Xlabel(void)
{
	char *dname = cmd.bootdev;
	struct diskinfo *dip;
	int d = 0;

	if (cmd.argc > 2) {
		printf("machine label [{cd,fd,hd}<0123>]\n");
		return (0);
	} else if (cmd.argc == 2)
		dname = cmd.argv[1];

	if ((dname[0] != 'c' && dname[0] != 'f' && dname[0] != 'h') ||
	    dname[1] != 'd' || dname[2] < '0' || dname[2] > '9') {
		printf("Invalid device!\n");
		return (0);
	}

	for (dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list))
		if (!strncmp(dip->name, dname, 3))
			break;
	if (!dip) {
		printf("Device for %cd%c not found\n", dname[0], dname[2]);
		return (0);
	}
	printf("Disklabel for device %x (%cd%c): ", dip->bios_info.bios_number,
	    dname[0], dname[2]);
	if ((dip->bios_info.flags & BDI_BADLABEL) &&
	    (d = disk_trylabel(dip)))
		return (0);
	putchar('\n');
	for (d = 0; d < dip->disklabel.d_npartitions; ++d)
		if (dip->disklabel.d_partitions[d].p_fstype ||
		    dip->disklabel.d_partitions[d].p_size ||
		    dip->disklabel.d_partitions[d].p_offset)
			printf("%c (%u): %u @@ %u\n", 'a' + d,
			    dip->disklabel.d_partitions[d].p_fstype,
			    dip->disklabel.d_partitions[d].p_size,
			    dip->disklabel.d_partitions[d].p_offset);
	return (0);
}

#ifdef DEBUG
int
Xregs(void)
{
	DUMP_REGS;
	return 0;
}
#endif

int
Xboot(void)
{
	int dev, part, st;
	bios_diskinfo_t *bd = NULL;
	char *buf;
	uint32_t baddr;
	struct diskinfo *dip;

	if (cmd.argc != 2) {
		printf("machine boot {cd,fd,hd}<0123>[abcd]\n");
		printf("Where [0123] is the disk number,"
		    " and [abcd] is the partition.\n");
		return 0;
	}

	/* Check arg */
	if (cmd.argv[1][0] != 'f' && cmd.argv[1][0] != 'h')
		goto bad;
	if (cmd.argv[1][1] != 'd')
		goto bad;
	if (cmd.argv[1][2] < '0' || cmd.argv[1][2] > '3')
		goto bad;
	if ((cmd.argv[1][3] < 'a' || cmd.argv[1][3] > 'd') &&
	    cmd.argv[1][3] != '\0')
		goto bad;

	printf("Booting from %s ", cmd.argv[1]);

	for (dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list))
		if (!strncmp(cmd.argv[1], dip->name, 3))
			break;
	if (!dip)
		goto bad;

	dev = dip->bios_info.bios_number;
	part = (cmd.argv[1][3] - 'a');

	if (part >= 0)
		printf("[%x,%d]\n", dev, part);
	else
		printf("[%x]\n", dev);

	/* get a paragraph-aligned buffer */
	buf = alloc(DEV_BSIZE + 16);
	baddr = (intptr_t)buf;
	baddr = (baddr + 15) & ~15;
	buf = (void *)((intptr_t)baddr);

	/* Read boot sector from device */
	bd = &dip->bios_info;
	st = biosd_io(F_READ, bd, 0, 1, buf);
	if (st)
		goto bad;

	if (part < 0) {
		/* boot whole sector; just zero bootpart */
		bzero(&bios_bootpte, 16);
	} else {
		memcpy(&bios_bootpte, buf + DOSPARTOFF + part * 16, 16);
		if ((st = biosd_io(F_READ, bd, bios_bootpte.p_ofs, 1, buf)))
			goto bad;
	}

	/* Load %dl, ljmp */
	baddr = 0x00007C00;
	gateA20(0);
	bootbuf(buf, 512, baddr, dev, baddr);

bad:
	printf("Invalid device!\n");
	return 0;
}
#endif

int
Xmemory(void)
{
	if (cmd.argc >= 2) {
		int i;
		/* parse the memory specs */

		for (i = 1; i < cmd.argc; i++) {
			char *p;
			long long addr, size;

			p = cmd.argv[i];

			size = strtoll(p + 1, &p, 0);
			if (*p && *p == '@@')
				addr = strtoll(p + 1, NULL, 0);
			else
				addr = 0;
			if (addr == 0 && (*p != '@@' || size == 0)) {
				printf("bad language\n");
				return 0;
			} else {
				switch (cmd.argv[i][0]) {
				case '-':
					mem_delete(addr, addr + size);
					break;
				case '+':
					mem_add(addr, addr + size);
					break;
				default :
					printf("bad OP\n");
					return 0;
				}
			}
		}
	}

	dump_biosmem(NULL);

	return 0;
}

int
Xoldbios(void)
{
#ifndef SMALL_BOOT
	printf("Old BIOS / Soekris helper now turned: ");
#endif
	if (i386_flag_oldbios) {
#ifndef SMALL_BOOT
		printf("OFF\n");
#endif
		i386_flag_oldbios = 0;
	} else {
#ifndef SMALL_BOOT
		printf("ON\n");
#endif
		i386_flag_oldbios = 1;
	}
#ifdef SMALL_BOOT
	printf("%d\n", i386_flag_oldbios);
#endif

	return 0;
}

#ifndef SMALL_BOOT
int
Xmdexec(void)
{
	int fd, sz, type = 0;
	char *buf;
	uint32_t baddr, jaddr = 0xF000FFF0;
	struct stat sb;

	if (cmd.argc == 2 && !strcmp(cmd.argv[1], "dos")) {
		gateA20(0);
		rtdos();
	}

	if (cmd.argc != 3) {
 synerr:
		printf("machine exec dos\n");
		printf("machine exec <type> <file>\n");
		printf("	types: grub sector\n");
		return (0);
	}

	if (!strcmp(cmd.argv[1], "sector")) {
		type = 1;
		sz = 65520;
	} else if (!strcmp(cmd.argv[1], "grub")) {
		type = 2;
		sz = 262144;
	} else
		goto synerr;

	if ((fd = open(qualify(cmd.argv[2]), 0)) < 0) {
		printf("open(%s): %s\n", cmd.argv[2], strerror(errno));
		return (0);
	}

	sb.st_size = 0;
	if (fstat(fd, &sb) < 0 || sb.st_size <= 0)
		printf("cannot stat %s, assuming %d bytes\n", cmd.argv[2], sz);
	else {
		printf("allocating %d bytes for %s (fallback was %d bytes)\n",
		    (int)sb.st_size, cmd.argv[2], sz);
		sz = (int)sb.st_size;
	}

	buf = alloc(sz + 15);
	baddr = (intptr_t)buf;
	baddr = (baddr + 15) & ~15;
	buf = (void *)((intptr_t)baddr);

	if ((sz = read(fd, buf, sz)) < 0) {
		printf("read error\n");
		close(fd);
		return(0);
	}

	close(fd);
	printf("Loaded %d bytes for %s %s\n", sz, cmd.argv[1], cmd.argv[2]);

	switch (type) {
	case 1:
		baddr = 0x07C00000;
		jaddr = 0x00007C00;
		break;
	case 2:
		baddr = 0x08000000;
		jaddr = 0x00008200;
		break;
	}

	gateA20(0);
	bootbuf(buf, sz, baddr, i386_biosdev, jaddr);
}
#endif
@


1.27
log
@move cmd_machine from cmd_i386.c to conf.c
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/cmd_i386.c,v 1.26 2009/10/24 15:57:11 tg Exp $	*/
d279 1
a279 1
		sz = 163840;
@


1.26
log
@new “machine exec dos” to return from ldbsd.com to syslinux (tested) or DOS
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/cmd_i386.c,v 1.25 2009/10/04 16:49:43 tg Exp $	*/
d41 1
a41 1

a45 12
#ifndef SMALL_BOOT
int Xboot(void);
int Xdiskinfo(void);
int Xlabel(void);
int Xmdexec(void);
#endif
int Xmemory(void);
#ifndef SMALL_BOOT
int Xregs(void);
#endif
int Xoldbios(void);

a50 17
const struct cmd_table cmd_machine[] = {
#ifndef SMALL_BOOT
	{ "boot",	CMDT_CMD, Xboot },
	{ "diskinfo",	CMDT_CMD, Xdiskinfo },
	{ "exec",	CMDT_CMD, Xmdexec },
	{ "label",	CMDT_CMD, Xlabel },
#endif
	{ "memory",	CMDT_CMD, Xmemory },
#ifndef SMALL_BOOT
#ifdef DEBUG
	{ "regs",	CMDT_CMD, Xregs },
#endif
#endif
	{ "oldbios",	CMDT_CMD, Xoldbios },
	{ NULL, 0, NULL }
};

@


1.25
log
@more nonsensical code cleanup, I give up, this is horrid
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/cmd_i386.c,v 1.24 2009/01/11 13:36:05 tg Exp $	*/
d61 1
d290 5
d297 1
@


1.24
log
@better bios_bootpte sanitisation: use a C structure type
(although I *still* don't understand why I can have
	extern uint32_t bios_bootpte[4];
	bzero(bios_bootpte, 16);
but must now write
	extern struct { … } bios_bootpte;
	bzero(&bios_bootpte, 16);
which is one of the reasons I think asm is superiour than C)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/cmd_i386.c,v 1.23 2009/01/11 00:32:40 tg Exp $	*/
d76 1
a76 1
	{ NULL, 0 }
a280 2
extern uint8_t i386_biosdev;

@


1.23
log
@restore FFS and CD9660 boot from hard disc
maybe FFS from floppy (untested)

CD9660 from CD-ROM doesn't work yet
PXE (tftp) untested
PXE (nfs) – did it ever work? no idea…
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/cmd_i386.c,v 1.22 2009/01/10 22:18:53 tg Exp $	*/
d196 1
a196 1
		bzero(bios_bootpte, 16);
d198 2
a199 2
		memcpy(bios_bootpte, buf + DOSPARTOFF + part * 16, 16);
		if ((st = biosd_io(F_READ, bd, bios_bootpte[2], 1, buf)))
@


1.22
log
@more work towards unifying devices (and network)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/cmd_i386.c,v 1.21 2009/01/10 20:28:28 tg Exp $	*/
d113 2
a114 1
	printf("Disklabel for device %x (%cd%c): ", d, dname[0], dname[2]);
d168 7
a174 2
	dev = (cmd.argv[1][0] == 'h')?0x80:0;
	dev += (cmd.argv[1][2] - '0');
a188 5
	for (dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list))
		if (!strncmp(cmd.argv[1], dip->name, 3))
			break;
	if (!dip)
		goto bad;
@


1.21
log
@shuffle some defns around
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/cmd_i386.c,v 1.20 2009/01/02 20:37:30 tg Exp $	*/
a44 1
extern struct disklist_lh disklist;
d106 2
a107 7
	for (dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list)) {
		d = dip->bios_info.bios_number;

		if ((((dip->bios_info.flags & BDI_EL_TORITO) ? 'c' :
		    d & 0x80 ? 'h' : 'f') == dname[0]) &&
		    (((dip->bios_info.flags & BDI_EL_TORITO) ? 0 :
		    d & 0x7F) == (dname[2] - '0')))
a108 1
	}
d145 1
d183 6
a188 1
	bd = bios_dklookup(dev);
@


1.20
log
@do use stat now
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/cmd_i386.c,v 1.19 2009/01/02 20:21:54 tg Exp $	*/
a47 4
extern uint32_t bios_bootpte[4];
#endif

#ifndef SMALL_BOOT
d281 2
d347 1
a347 1
	bootbuf(buf, sz, baddr, i386_bootdev, jaddr);
@


1.19
log
@increase the size a grub can be to 160 KiB… the grml Schluchtenscheißer
one is ridiculously close to 128 KiB already

XXX make sure all filesystems can do stat() and use that instead, to
XXX reduce the failability in low-RAM cases
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/cmd_i386.c,v 1.18 2009/01/02 04:58:41 tg Exp $	*/
d291 1
d314 9
@


1.18
log
@remove toridev kludge and probe the bios boot device for El Torito in
no emulation mode… if so, set the flag
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/cmd_i386.c,v 1.17 2009/01/02 02:13:21 tg Exp $	*/
d304 1
a304 1
		sz = 131040;
@


1.17
log
@allow for bigger sizes for grub1/stage2
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/cmd_i386.c,v 1.16 2009/01/02 01:45:44 tg Exp $	*/
a48 1
int i386_bootdev;
@


1.16
log
@allow for loading all of the up-to-65280 bytes
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/cmd_i386.c,v 1.15 2009/01/02 01:42:07 tg Exp $	*/
d300 1
a300 1
	if (!strcmp(cmd.argv[1], "sector"))
d302 2
a303 1
	else if (!strcmp(cmd.argv[1], "grub"))
d305 2
a306 1
	else
d314 1
a314 1
	buf = alloc(65295);
d319 1
a319 1
	if ((sz = read(fd, buf, 65280)) < 0) {
@


1.15
log
@add “machine exec grub <file>”
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/cmd_i386.c,v 1.14 2009/01/01 23:59:02 tg Exp $	*/
d328 2
a329 1
		jaddr = baddr = 0x00007C00;
d332 1
a332 1
		baddr = 0x00008000;
@


1.14
log
@split between buffer target address ES:DI and later initial CS:IP
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/cmd_i386.c,v 1.13 2009/01/01 23:29:00 tg Exp $	*/
d296 1
a296 1
		printf("	types: sector\n");
d302 2
d330 4
@


1.13
log
@new command: machine exec
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/cmd_i386.c,v 1.12 2009/01/01 22:59:35 tg Exp $	*/
d65 2
a66 1
__dead void bootbuf(void *codebuf, uint32_t codesize, int dl, uint32_t csip);
d211 1
a211 1
	bootbuf(buf, 512, dev, baddr);
d291 1
a291 1
	uint32_t baddr;
d326 1
a326 1
		baddr = 0x00007C00;
d331 1
a331 1
	bootbuf(buf, sz, i386_bootdev, baddr);
@


1.12
log
@fix the command to do the actual partition boot record load already,
and pass the partition table entry in DS:SI
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/cmd_i386.c,v 1.11 2009/01/01 22:53:43 tg Exp $	*/
d49 1
d56 1
d71 1
d283 50
@


1.11
log
@disable A20 before booting another system

XXX still cannot boot into DOS like this, wtf?
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/cmd_i386.c,v 1.10 2009/01/01 21:46:38 tg Exp $	*/
d48 4
d178 1
a178 1
	if (part > 0)
d195 7
a201 9
	/* Frob boot flag in buffer from HD */
	if ((dev & 0x80) && (part > 0)){
		int i, j;

		for (i = 0, j = DOSPARTOFF; i < 4; i++, j += 16)
			if (part == i)
				buf[j] |= 0x80;
			else
				buf[j] &= ~0x80;
@


1.10
log
@rewrite bootbuf to pass something in DS:SI and have extensions for
the future that might make more sense or help with the other stuff
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/cmd_i386.c,v 1.9 2008/12/28 18:56:11 tg Exp $	*/
d204 1
@


1.9
log
@fix
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/cmd_i386.c,v 1.8 2008/12/28 18:18:04 tg Exp $	*/
d59 1
a59 1
int bootbuf(void *, int);
d147 2
a148 1
	char buf[DEV_BSIZE], *dest = (void *)BOOTBIOS_ADDR;
d179 6
d203 2
a204 2
	bcopy(buf, dest, DEV_BSIZE);
	bootbuf(dest, dev);
@


1.8
log
@try disklabel again if bad (might be removable media) in “machine label” too
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/cmd_i386.c,v 1.7 2008/12/28 18:10:09 tg Exp $	*/
d114 1
a114 1
		printf("Device for %c%d%c not found\n", dname[0], dname[2]);
@


1.7
log
@new “machine label” command, had been desired for ages
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/cmd_i386.c,v 1.6 2008/08/01 12:39:07 tg Exp $	*/
d118 2
a119 2
	if (dip->bios_info.flags & BDI_BADLABEL) {
		printf("%s\n", "*none*");
a120 1
	}
@


1.6
log
@remove unused code (for testing the bootloader on unix)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/cmd_i386.c,v 1.5 2008/08/01 11:33:41 tg Exp $	*/
d45 1
d50 1
d65 1
d85 49
d151 1
a151 1
		printf("machine boot {fd,hd}<0123>[abcd]\n");
@


1.5
log
@apm turnoff code is dead
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/cmd_i386.c,v 1.4 2008/08/01 11:24:59 tg Exp $	*/
a77 1
#ifndef _TEST
a78 1
#endif
a93 1
#ifndef _TEST
a149 1
#endif
@


1.4
log
@merge and reduce diff to obsd
XXX not yet tested
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/i386/stand/libsa/cmd_i386.c,v 1.3 2006/08/19 14:20:30 tg Exp $	*/
a68 1
	{ "off",	CMDT_CMD, Xturnoff },
@


1.3
log
@attempt to shrink fdboot even more
@
text
@d1 2
a2 2
/**	$MirOS: src/sys/arch/i386/stand/libsa/cmd_i386.c,v 1.2 2005/03/06 21:27:05 tg Exp $	*/
/*	$OpenBSD: cmd_i386.c,v 1.28 2004/03/09 19:12:12 tom Exp $	*/
a52 1
int Xturnoff(void);
a94 21
Xturnoff(void)
{
	int a1, a2;
	a1 = a2 = -1;
	switch(cmd.argc)
	{
	case 0:
		printf("machine off [dev [how] ]\n");
		return 0;
	case 1:
		break;
	case 3:
		a2 = strtol(cmd.argv[2], NULL, 0);
	case 2:
		a1 = strtol(cmd.argv[1], NULL, 0);
	}
	apmturnoff(a1, a2);
	return 0;
}

int
d126 2
a127 2
	if (part >= 0)
		printf("[%X,%d]\n", dev, part);
d129 1
a129 1
		printf("[%X]\n", dev);
d138 1
a138 1
	if((dev & 0x80) && (part >= 0)) {
a146 1
	apm_reset();
d149 1
a149 1
	memmove(dest, buf, DEV_BSIZE);
d168 1
a168 1
			long addr, size;
d172 1
a172 1
			size = strtol(p + 1, &p, 0);
d174 1
a174 1
				addr = strtol(p + 1, NULL, 0);
@


1.2
log
@* merge src/sys/
  (at least the better part of it)
* revert IPv6 networking to OpenBSD, since
  I didn't get IPV4_MAPPED addresses working :(
@
text
@d1 1
a1 1
/**	$MirOS$	*/
d46 1
d49 1
d51 1
d54 1
d61 1
d64 1
d66 1
d71 1
d76 1
d180 1
d227 1
d229 1
d231 1
d233 1
d236 1
d238 1
d241 3
@


1.1
log
@Initial revision
@
text
@d1 1
d44 1
d50 2
d63 2
d87 21
d139 2
a140 2
	if (part > 0)
		printf("[%x,%d]\n", dev, part);
d142 1
a142 1
		printf("[%x]\n", dev);
d151 1
a151 1
	if ((dev & 0x80) && (part > 0)){
d160 1
d163 1
a163 1
	bcopy(buf, dest, DEV_BSIZE);
d213 15
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@import bootloader-related pieces from openbsd, as first part of the
aspired 4.4 merge… and something else
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.29 2006/09/18 21:14:15 mpf Exp $	*/
d153 1
a153 1
			long long addr, size;
d157 1
a157 1
			size = strtoll(p + 1, &p, 0);
d159 1
a159 1
				addr = strtoll(p + 1, NULL, 0);
@

