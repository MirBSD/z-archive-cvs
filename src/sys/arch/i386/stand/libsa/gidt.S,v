head	1.31;
access;
symbols
	tg-use_ldscript:1.31.0.2
	tg-beforemerge-ksrc10:1.1.1.5
	cvs-200808011000:1.1.1.5
	MIRBSD_10:1.1.1.4.0.4
	MIRBSD_10_BASE:1.1.1.4
	MIRBSD_9_BASE:1.1.1.4
	MIRBSD_8:1.1.1.4.0.2
	MIRBSD_8_BASE:1.1.1.4
	cvs-200507032030:1.1.1.4
	cvs-200505050030:1.1.1.3
	cvs-200504302230:1.1.1.3
	cvs-200504291700:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@# @;


1.31
date	2009.10.24.15.57.11;	author tg;	state Exp;
branches;
next	1.30;
commitid	1004AE323E248593E76;

1.30
date	2009.08.09.19.39.41;	author tg;	state Exp;
branches;
next	1.29;
commitid	1004A7F259B3D7C9644;

1.29
date	2009.03.15.18.16.13;	author tg;	state Exp;
branches;
next	1.28;
commitid	10049BD45F24CFD1A96;

1.28
date	2009.02.02.15.59.55;	author tg;	state Exp;
branches;
next	1.27;
commitid	1004987185B1EEEC274;

1.27
date	2009.01.12.21.02.14;	author tg;	state Exp;
branches;
next	1.26;
commitid	100496BAFE20F807B09;

1.26
date	2009.01.12.20.13.13;	author tg;	state Exp;
branches;
next	1.25;
commitid	100496BA4687F022625;

1.25
date	2009.01.12.19.37.17;	author tg;	state Exp;
branches;
next	1.24;
commitid	100496B9BFB4964B1B9;

1.24
date	2009.01.11.23.16.20;	author tg;	state Exp;
branches;
next	1.23;
commitid	100496A7DDB40A4E132;

1.23
date	2009.01.11.23.08.08;	author tg;	state Exp;
branches;
next	1.22;
commitid	100496A7BD45319E7D6;

1.22
date	2009.01.11.22.27.17;	author tg;	state Exp;
branches;
next	1.21;
commitid	100496A725C58F29C02;

1.21
date	2009.01.11.20.35.21;	author tg;	state Exp;
branches;
next	1.20;
commitid	100496A581400179BDB;

1.20
date	2009.01.11.20.16.32;	author tg;	state Exp;
branches;
next	1.19;
commitid	100496A539F785CD352;

1.19
date	2009.01.10.13.58.58;	author tg;	state Exp;
branches;
next	1.18;
commitid	1004968A9A5662F59EA;

1.18
date	2009.01.10.13.41.19;	author tg;	state Exp;
branches;
next	1.17;
commitid	1004968A59443A02B58;

1.17
date	2009.01.10.12.39.08;	author tg;	state Exp;
branches;
next	1.16;
commitid	100496896FF1B4FDBF8;

1.16
date	2009.01.10.12.32.52;	author tg;	state Exp;
branches;
next	1.15;
commitid	1004968956D7B5782AF;

1.15
date	2009.01.10.12.20.57;	author tg;	state Exp;
branches;
next	1.14;
commitid	100496892BD57D4C9CC;

1.14
date	2009.01.10.12.12.19;	author tg;	state Exp;
branches;
next	1.13;
commitid	100496890B52F059A0D;

1.13
date	2009.01.10.12.10.39;	author tg;	state Exp;
branches;
next	1.12;
commitid	1004968905271ECEAD8;

1.12
date	2009.01.10.12.09.26;	author tg;	state Exp;
branches;
next	1.11;
commitid	10049688FF731469C29;

1.11
date	2009.01.02.16.38.37;	author tg;	state Exp;
branches;
next	1.10;
commitid	100495E430D546F7076;

1.10
date	2009.01.02.04.14.35;	author tg;	state Exp;
branches;
next	1.9;
commitid	100495D94B3443F7EAF;

1.9
date	2009.01.02.02.18.56;	author tg;	state Exp;
branches;
next	1.8;
commitid	100495D799B602C0BCB;

1.8
date	2009.01.02.02.13.21;	author tg;	state Exp;
branches;
next	1.7;
commitid	100495D78586304F02A;

1.7
date	2009.01.02.02.06.23;	author tg;	state Exp;
branches;
next	1.6;
commitid	100495D7699275996DF;

1.6
date	2009.01.02.01.38.43;	author tg;	state Exp;
branches;
next	1.5;
commitid	100495D703134FED34B;

1.5
date	2009.01.01.23.59.02;	author tg;	state Exp;
branches;
next	1.4;
commitid	100495D58D45CD48443;

1.4
date	2009.01.01.21.46.38;	author tg;	state Exp;
branches;
next	1.3;
commitid	100495D39C42DC869AB;

1.3
date	2009.01.01.19.45.38;	author tg;	state Exp;
branches;
next	1.2;
commitid	100495D1D77209B13CE;

1.2
date	2009.01.01.19.45.02;	author tg;	state Exp;
branches;
next	1.1;
commitid	100495D1D4A4967AB14;

1.1
date	2005.02.05.17.27.29;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.27.29;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.29.17.05.48;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.04.30.22.36.55;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2005.07.03.23.10.02;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	eaf42c870607a86;

1.1.1.5
date	2008.08.01.10.28.38;	author tg;	state Exp;
branches;
next	;
commitid	1004892E54805BE97AB;


desc
@@


1.31
log
@new “machine exec dos” to return from ldbsd.com to syslinux (tested) or DOS
@
text
@/*	$MirOS: src/sys/arch/i386/stand/libsa/gidt.S,v 1.30 2009/08/09 19:39:41 tg Exp $ */
/*	$OpenBSD: gidt.S,v 1.32 2006/12/26 19:30:44 tom Exp $	*/

/*
 * Copyright (c) 2008, 2009 Thorsten Glaser
 * Copyright (c) 1997 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

	.file "gidt.S"

#include <machine/asm.h>
#define _LOCORE
#include <machine/trap.h>
#include <debug_md.h>
#undef _LOCORE
#include <assym.h>

#include "gidt.h"

	.globl	_C_LABEL(BIOS_regs)

	.text
	.code32

	.globl	_C_LABEL(_rtt)
ENTRY(_rtt)
#ifdef GIDT_DEBUG
	movl	$0xb8000, %ebx
	movl	$0x4f514f51, (%ebx)
#endif
	movw	$0x1234, %ax
	movw	%ax, 0x472	/* warm boot */

	/* Try to use the KBD to reboot system */
	movb	$0xfe, %al
	outb	%al, $0x64

	movl	$0x5000, %ecx
1:	inb	$0x84, %al
	loop	1b

	movb	$0xfe, %al
	outb	%al, $0x64

#ifdef GIDT_DEBUG
	movl	$0xb8000, %ebx
	movl	$0x07310731, (%ebx)
#endif

	/* Try to cause a triple fault... */
	lidt    Idtr_reset
	xorl	%eax, %eax
	divl	%eax, %eax

	/* Again... */
	int $0x8

	/* Again... */
	movl	$0, %esp	/* segment violation */
	ret

	/*
	 * set up the protected mode Interrupt Descriptor Table
	 */

#ifdef __STDC__
#define IPROC(n)	X##n
#define IEMU(n)		IPROC(emu##n)
#define idtb(b)		idte(emu##b)
#else
#define IPROC(n)	X/**/n
#define IEMU(n)		IPROC(emu/**/n)
#define idtb(b)		idte(emu/**/b)
#endif

#define idte(e) \
	.long	IPROC(e), ((S32TEXT) << 16) | ((0x80 | SDT_SYS386TGT) << 8)

	.p2align 4
	.globl	idt_for_fixup
idt_for_fixup:
	idte(de); idte(db); idte(nmi); idte(bp); idte(of); idte(br)
	idte(ud); idte(nm); idte(df);  idte(fo); idte(ts); idte(np)
	idte(ss); idte(gp); idte(pf);  idte(xx); idte(mf); idte(ac)
	idte(mc)
	idte(xx); idte(xx); idte(xx);  idte(xx); idte(xx); idte(xx)
	idte(xx); idte(xx); idte(xx);  idte(xx); idte(xx); idte(xx)
	idte(xx) 
		/* Maskable interrupts (32-255) */
		/* BIOS entry points (32-63) */
		/* DOS entry points (64-80) */
	idtb(0);  idtb(1);  idtb(2);  idtb(3);  idtb(4);  idtb(5)
	idtb(6);  idtb(7);  idtb(8);  idtb(9);  idtb(10); idtb(11)
	idtb(12); idtb(13); idtb(14); idtb(15); idtb(16); idtb(17)
	idtb(18); idtb(19); idtb(20); idtb(21); idtb(22); idtb(23)
	idtb(24); idtb(25); idtb(26); idtb(27); idtb(28); idtb(29)
	idtb(30); idtb(31); idtb(32); idtb(33); idtb(34); idtb(35)
	idtb(36); idtb(37); idtb(38); idtb(39); idtb(40); idtb(41)
	idtb(42); idtb(43); idtb(44); idtb(45); idtb(46); idtb(47)
	.globl	idt_fixup_end
idt_fixup_end:

	.balign 8
	.globl	Idtr
Idtr:	.word	idt_fixup_end - idt_for_fixup - 1
	.long	idt_for_fixup
	.word	0

	.balign	8
	.globl	Idtr_real
Idtr_real:	.word	1023
		.long	0
		.word	0

	.balign	8
Idtr_reset:	.long	0, 0

	.balign	8
gdt:
		/* 0x00 : null */
	.space	8
		/* 0x08 : flat code */
	.word	0xFFFF			# lolimit
	.word	0			# lobase
	.byte	0			# midbase
	.byte	SDT_MEMERAC | 0 | 0x80	# RXAC, dpl = 0, present
	.byte	0xf | 0 | 0x40 | 0x80	# hilimit, xx, 32bit, 4k granularity
	.byte	0			# hibase
		/* 0x10 : flat data */
	.word	0xFFFF			# lolimit
	.word	0			# lobase
	.byte	0			# midbase
	.byte	SDT_MEMRWA | 0 | 0x80	# RWA, dpl = 0, present
	.byte	0xf | 0 | 0x40 | 0x80	# hilimit, xx, 32bit, 4k granularity
	.byte	0			# hibase
		/* 0x18 : 16 bit code */
	.word	0xFFFF				# lolimit
	.word	(SA_LINKADDR & 0xffff)		# lobase
	.byte	(SA_LINKADDR >> 16) & 0xff	# midbase
	.byte	SDT_MEMERAC | 0 | 0x80		# RXAC, dpl = 0, present
	.byte	0x0 | 0 | 0 | 0		# hilimit, xx, 16bit, byte granularity
	.byte	(SA_LINKADDR >> 20) & 0xff	# hibase
		/* 0x20 : 16 bit data */
	.word	0xFFFF				# lolimit
	.word	(SA_LINKADDR & 0xffff)		# lobase
	.byte	(SA_LINKADDR >> 16) & 0xff	# midbase
	.byte	SDT_MEMRWA | 0 | 0x80		# RWA, dpl = 0, present
	.byte	0x0 | 0 | 0 | 0		# hilimit, xx, 16bit, byte granularity
	.byte	(SA_LINKADDR >> 20) & 0xff	# hibase

.globl Gdtr
Gdtr:	.word	. - gdt - 1
	.long	gdt
	.word	0

#define IENTRY(name,type) \
IPROC(name): \
	pushl	$type ; \
	jmp	1f
#define IENTRY_ERR(name,err,type) \
IPROC(name): \
	pushl	$err ; \
	pushl	$type ; \
	jmp	1f

IPROC(xx):
	pushl	$1
	pushl	$T_RESERVED
	jmp	1f

IENTRY_ERR(de,0,T_DIVIDE)	/* #DE divide by zero */
IENTRY_ERR(db,0,T_TRCTRAP)	/* #DB debug */
IENTRY_ERR(nmi,0,T_NMI)		/* NMI */
IENTRY_ERR(bp,0,T_BPTFLT)	/* #BP breakpoint */
IENTRY_ERR(of,0,T_OFLOW)	/* #OF overflow */
IENTRY_ERR(br,0,T_BOUND)	/* #BR BOUND range exceeded */
IENTRY_ERR(ud,0,T_PRIVINFLT)	/* #UD invalid opcode */
IENTRY_ERR(nm,0,T_DNA)		/* #NM device not available */
IENTRY(df,T_DOUBLEFLT)		/* #DF double fault */
IENTRY_ERR(fo,0,T_FPOPFLT)	/* #FO coprocessor segment overrun */
IENTRY(ts,T_TSSFLT)		/* #TS invalid TSS */
IENTRY(np,T_SEGNPFLT)		/* #NP segment not present */
IENTRY(ss,T_STKFLT)		/* #SS stack fault */
IENTRY(gp,T_PROTFLT)		/* #GP general protection */
IENTRY(pf,T_PAGEFLT)		/* #PF page fault */
IENTRY_ERR(mf,0,T_ARITHTRAP)	/* #MF floating point error */
IENTRY(ac,T_ALIGNFLT)		/* #AC alignment check */
IENTRY(mc,T_MACHK)		/* #MC machine check */

	.globl	alltraps
1:	/* save on jumps */
	jmp	alltraps

#define	IEMUENT(n)	IEMU(n): pushl $n; jmp 1f

IEMUENT(0);  IEMUENT(1);  IEMUENT(2);  IEMUENT(3)
IEMUENT(4);  IEMUENT(5);  IEMUENT(6);  IEMUENT(7)
IEMUENT(8);  IEMUENT(9);  IEMUENT(10); IEMUENT(11)
IEMUENT(12); IEMUENT(13); IEMUENT(14); IEMUENT(15)
IEMUENT(16); IEMUENT(17); IEMUENT(18); IEMUENT(19)
IEMUENT(20); IEMUENT(21); IEMUENT(22); IEMUENT(23)
IEMUENT(24); IEMUENT(25); IEMUENT(26); IEMUENT(27)
IEMUENT(28); IEMUENT(29); IEMUENT(30); IEMUENT(31)
1:	jmp	EMUh	/* redirect for short jumps */
IEMUENT(32); IEMUENT(33); IEMUENT(34); IEMUENT(35)
IEMUENT(36); IEMUENT(37); IEMUENT(38); IEMUENT(39)
IEMUENT(40); IEMUENT(41); IEMUENT(42); IEMUENT(43)
IEMUENT(44); IEMUENT(45); IEMUENT(46); IEMUENT(47)
1:	jmp	EMUh

/*
 * entry point for BIOS real-mode interface
 * all the magic for real-prot mode switching is here
 *
 * Call:	%eax, %ecx, %edx, %ebx, %ebp, %esi, %edi, %es, %ds
 * Return:	%eax, %edx, %ecx, %eflags (as returned from BIOS)
 *
 */
	.globl	EMUh
	.balign	8, 0x90
	.intel_syntax noprefix
EMUh:
	xchg	[esp],eax
	mov	[LemuNR],al
	pop	eax

	push	ebx
	push	ebp
	push	esi
	push	edi
	push	ds
	push	es
	push	fs
	push	gs

	push	eax
	mov	eax,[BIOS_regs + BIOSR_DS]
	push	eax
	mov	eax,[BIOS_regs + BIOSR_ES]
	push	eax

	call	prot_to_real
	.code16

	pop	eax
	mov	es,ax
	pop	eax
	mov	ds,ax
	pop	eax

	sti
	int	0
	LemuNR = . - 1
	cli

	push	eax
	lahf
	push	eax
	xor	eax,eax
	mov	ax,es
	push	eax

	call	real_to_prot
	.code32

	mov	[BIOS_regs + BIOSR_CX],ecx
	mov	[BIOS_regs + BIOSR_DX],edx
	mov	[BIOS_regs + BIOSR_BX],ebx
	mov	[BIOS_regs + BIOSR_BP],ebp
	mov	[BIOS_regs + BIOSR_SI],esi
	mov	[BIOS_regs + BIOSR_DI],edi
	pop	eax
	mov	[BIOS_regs + BIOSR_ES],eax
	pop	ebx
	pop	eax
	mov	[BIOS_regs + BIOSR_AX],eax

	pushfd
	pop	ebp
	and	ebp,0xFFFFBFFF		/* clear NT flag */
	push	ebp
	popfd

	pop	gs
	pop	fs
	pop	es
	pop	ds
	pop	edi
	pop	esi
	pop	ebp
	mov	[esp+12],bh
	pop	ebx
	iret

#ifndef SMALL_BOOT
/* Return to DOS or SYSLINUX */
ENTRY(rtdos)
	call	prot_to_real
	.code16
	mov	ax,0x4C00
	int	0x21
1:	jmp	1b
	.code32
/* Call buffer at 07c0:0000 in real mode to simulate a BIOS boot */
ENTRY(bootbuf)
	pop	eax		/* Don't need return address */
	pop	esi		/* Buffer Source (linear) */
	pop	ecx		/* Size */
	pop	ebp		/* Buffer Target (ES:DI) */
	pop	ebx		/* Device and flags */
	pop	edi		/* Initial CS:IP */

	xor	edx,edx
	dec	edx		/* EDX = 0xFFFFFFFF */
	mov	dl,bl		/* EDX = 0xFFFFFFzz (z = device) */

	call	prot_to_real
	.code16

	/* set up flags, real mode stack */
	xor	eax,eax
	mov	ss,ax
	mov	esp,0x000006F0
	push	eax
	popf

	/*-
	 * Now the machine status is as follows:
	 * - CS = DS = ES = 4000h = (SA_LINKSEG)
	 * - SS:SP = 0000:06F0h (to make room for !PXE ptr)
	 * - EFLAGS = 0
	 * - ESI = linear address of source buffer (must be para aligned)
	 * - ECX = source buffer size (up to 64 KiB)
	 * - EBP = target address as ES:DI (FAR pointer)
	 * - EDI = initial CS:IP (FAR pointer)
	 * - EBX = bootbuf flags, currently unused
	 * - EDX = drive
	 * - _C_LABEL(bios_bootpte) = future DS:SI contents (16by)
	 * - 0000:0600h .. 0000:07FFh are available to put the boot
	 *   partition table entry in, according to SYSLINUX docs;
	 *   we also move certain relocation code there, and our
	 *   stack is also positioned in there
	 * - we assume ECX > (“ES”<<4)|“DI” [EBP]
	 * - “DI” is almost certainly 0 and should be
	 */

	mov	eax,edi
	shr	eax,16
	push	ax		/* future CS */
	push	di		/* future IP */
	mov	eax,ds:[8]
	push	eax		/* !PXE structure RM address */
	mov	eax,ds:[12]
	push	eax		/* PXENV+ structure RM address */
	push	edx		/* future DL (drive) */
	push	ecx		/* source buffer size */
	shr	esi,4
	push	si		/* source buffer segment */
	mov	eax,ebp
	shr	eax,16
	push	ax		/* buffer ES */
	push	bp		/* buffer DI */
	xor	ecx,ecx
	mov	es,cx
	mov	edi,0x0600
	mov	esi,offset _C_LABEL(bios_bootpte) - SA_LINKADDR
	mov	cx,4
	rep	movsd
	push	es		/* temporary CS */
	push	di		/* temporary IP */
	call	Ltcend
Ltcbeg:	/* temporary relocation code, copied to 0000:0610h */
	pop	di		/* buffer target (DI) */
	pop	es		/* buffer target (ES) */
	pop	ds		/* source buffer segment */
Ltcbig:	pop	ecx		/* source buffer size */
	xor	si,si		/* source buffer offset */
	cmp	ecx,0x00010000
	jb	Ltcseg
	/* copy 64 KiB, reduce, retry */
	sub	ecx,0x00010000
	push	ecx
	mov	ecx,0x4000	/* 64 KiB in dwords */
	push	di
	rep	movsd
	pop	di
	mov	ax,ds
	add	ax,0x1000
	mov	ds,ax
	mov	ax,es
	add	ax,0x1000
	mov	es,ax
	jmp	Ltcbig
Ltcseg:	rep	movsb
Ltcrun:	xor	ax,ax
	mov	ds,ax
	mov	si,0x0600
	pop	edx		/* drive */
	pop	bx		/* PXENV+ offset */
	pop	es		/* PXENV+ segment */
	pop	edi		/* !PXE */
	mov	bp,sp
	mov	[bp+8],edi
	lret			/* future CS:IP on stack */
Ltcend:	pop	si		/* offset Ltcbeg */
	mov	cx,offset Ltcend - offset Ltcbeg
	rep	movsb
	lret			/* temporary CS:IP (0000:0610h) on stack */
#endif

/*-
 * Switch from protected mode to real mode.
 * Registers trashed: EAX 
 * CS = DS = ES = SA_LINKSEG
 * SS:SP = old flat:ESP
 */
	.code32
	.globl	prot_to_real
prot_to_real:
	cli
	/* switch to 16 bit code size */
	ljmp	S16TEXT,offset Lp2r32 - SA_LINKADDR
Lp2r32:	.code16
	mov	ax,S16DATA
	mov	ds,ax
	mov	es,ax
	mov	fs,ax
	mov	gs,ax
	mov	ss,ax
	/* disable protected mode */
	mov	eax,cr0
	and	eax,~CR0_PE
	mov	cr0,eax
	/* switch to 16 bit data size */
	data32 ljmp SA_LINKSEG,offset Lp2r16 - SA_LINKADDR
Lp2r16:	/* convert ESP to SS:SP */
	mov	eax,esp
	shr	eax,4
	and	ax,0xF000
	mov	ss,ax
	and	esp,0x0000FFFF
	/* load real mode segments */
	mov	ax,cs
	mov	ds,ax
	mov	es,ax
	mov	fs,ax
	mov	gs,ax
	/* load real mode IDT */
	data32 addr32 lidt (Idtr_real - SA_LINKADDR)
	/* fix up return address */
	pop	eax
	sub	eax,SA_LINKADDR
	push	ax
	ret

/*-
 * Switch from real mode to protected mode.
 * Registers trashed: EAX 
 * CS = S32TEXT
 * DS = ES = SS = S32DATA
 * ESP = flat, old (SS<<4)|SP
 */
	.code16
	.globl	real_to_prot
real_to_prot:
	cli
	/* fix up return address */
	xor	eax,eax
	pop	ax
	add	eax,SA_LINKADDR
	push	eax
	/* load GDT via data segment */
	mov	ax,SA_LINKSEG
	mov	ds,ax
	data32 addr32 lgdt (Gdtr - SA_LINKADDR)
	/* convert SS:SP to ESP */
	xor	eax,eax
	mov	ax,ss
	shl	eax,4
	and	esp,0x0000FFFF
	add	esp,eax
	/* enter protected mode */
	mov	eax,cr0
	or	eax,CR0_PE
	mov	cr0,eax
	/* switch to 32 bit */
	data32 ljmp S32TEXT,offset Lr2p32
Lr2p32:	.code32
	mov	eax,S32DATA
	mov	ds,ax
	mov	es,ax
	mov	fs,ax
	mov	gs,ax
	mov	ss,ax
	/* load protected mode IDT */
	lidt	Idtr
	ret
@


1.30
log
@we absolutely needed to save space (cf. liveboot numbers below), so use an
mksh script (endian-neutral) to pre-fixup the IDT instead of generating one
at run/initialisation time from 16 bit code

XXX I wonder how the LZMA decompressor and ustarfs will fit… it’d probably
XXX be best to indeed compress the 32-bit code part with a rather simple
XXX algorithm to separate the 16-bit setup code part, multiboot kernel,
XXX coloured bootselection code, etc. from what’ll really be needed later

   text    data     bss     dec     hex filename
  59466    2024    3716   65206    feb6 boot.elf
  57778    2024    3716   63518    f81e boot.elf
@
text
@d1 1
a1 1
/*	$MirOS: src/sys/arch/i386/stand/libsa/gidt.S,v 1.29 2009/03/15 18:16:13 tg Exp $ */
d319 8
@


1.29
log
@pass the PXENV+ and !PXE structure pointers to "machine exec"d loaders
@
text
@d1 1
a1 1
/*	$MirOS: src/sys/arch/i386/stand/libsa/gidt.S,v 1.28 2009/02/02 15:59:55 tg Exp $ */
d86 1
a86 3
	 * set up the protected mode Interrupt Descriptor Table:
	 * first, reserve space for 80 entries, 8 bytes each,
	 * then the IDT descriptor.
a87 9
	.p2align 4
idt:
	. = idt + (80 * 8)
	.globl Idtr
Idtr:	.word	. - idt - 1
	.long	idt
	.word	0		/* XXX what for? */

	.intel_syntax noprefix
d99 2
a100 6
#define idte(e)						\
	mov	ebx,offset IPROC(e);			\
	mov	ax,bx; stosw;				\
	mov	ax,S32TEXT; stosw;			\
	mov	eax,ebx;				\
	mov	ax,(0x80 | SDT_SYS386TGT)<<8; stosd	\
d102 3
a104 6
	.globl	idt_init
	.code16
idt_init:
	mov	edi,offset idt - SA_LINKADDR
	cld
		/* internal / CPU (0-31) */
d123 2
d126 5
a130 4
	ret
	.code32

	.att_syntax
d132 1
a132 1
	.align	8
d138 1
a138 1
	.align	8
d141 1
a141 1
	.align	8
@


1.28
log
@apparently, GRUB2 needs EDX not just DL set, with the high 24 bits set
to 0xFF, for CD boot to work (or maybe the entire partition?)
⇒ reading the actual corresponding source code helps, especially with
  wondering where cdboot.img comes from… 1.95 doesn’t cut it
@
text
@d1 1
a1 1
/*	$MirOS: src/sys/arch/i386/stand/libsa/gidt.S,v 1.27 2009/01/12 21:02:14 tg Exp $ */
d353 1
a353 1
	mov	esp,0x000006FC
d360 1
a360 1
	 * - SS:SP = 0000:06FCh
d381 4
d428 6
a433 1
	pop	edx
@


1.27
log
@more interesting EMUh code (gah, root of all evil… that is)
@
text
@d1 1
a1 1
/*	$MirOS: src/sys/arch/i386/stand/libsa/gidt.S,v 1.26 2009/01/12 20:13:13 tg Exp $ */
d340 1
a340 1
	pop	edx		/* Device (and flags) */
d343 4
d366 2
a367 2
	 * - EDX = bootbuf flags, currently unused
	 * -  DL = drive
d381 1
a381 1
	push	dx		/* future DL (drive) */
d424 1
a424 1
	pop	dx
@


1.26
log
@more paranoia
@
text
@d1 1
a1 1
/*	$MirOS: src/sys/arch/i386/stand/libsa/gidt.S,v 1.25 2009/01/12 19:37:17 tg Exp $ */
d292 1
d294 2
a295 1
	pushfd
d312 1
d316 1
d329 1
a330 5

	push	eax
	lahf
	mov	[esp+12],ah
	pop	eax
@


1.25
log
@make prot_to_real and real_to_prot do an implicit cli
@
text
@d1 1
a1 1
/*	$MirOS: src/sys/arch/i386/stand/libsa/gidt.S,v 1.24 2009/01/11 23:16:20 tg Exp $ */
a291 1
	cli
a437 4
	/* fix up return address */
	pop	eax
	sub	eax,SA_LINKADDR
	push	ax
d467 4
d484 5
a513 5
	/* fix up return address */
	xor	eax,eax
	pop	ax
	add	eax,SA_LINKADDR
	push	eax
@


1.24
log
@be a bit more anal about segment selectors, which helps… oO
@
text
@d1 1
a1 1
/*	$MirOS: src/sys/arch/i386/stand/libsa/gidt.S,v 1.23 2009/01/11 23:08:08 tg Exp $ */
a336 1
	cli
d438 1
d484 1
@


1.23
log
@be closer to original EMUh in not saving DS
now it doesn't trap any more in SYSLINUX but simply hangs, like DOS :(
@
text
@d1 1
a1 1
/*	$MirOS: src/sys/arch/i386/stand/libsa/gidt.S,v 1.22 2009/01/11 22:27:17 tg Exp $ */
d449 3
d468 2
d504 2
@


1.22
log
@better real_to_prot and prot_to_real conversions
@
text
@d1 1
a1 1
/*	$MirOS: src/sys/arch/i386/stand/libsa/gidt.S,v 1.21 2009/01/11 20:35:21 tg Exp $ */
d289 1
d292 1
a298 2
	mov	ax,ds
	push	eax
a311 2
	mov	[BIOS_regs + BIOSR_DS],eax
	pop	eax
@


1.21
log
@this time, condition codes for real
I fell into the iret trap
@
text
@d1 1
a1 1
/*	$MirOS: src/sys/arch/i386/stand/libsa/gidt.S,v 1.20 2009/01/11 20:16:32 tg Exp $ */
d457 4
a460 3
Lp2r16:	mov	eax,esp
	rol	eax,16
	shl	ax,12
d462 2
a463 3
	xor	ax,ax
	rol	eax,16
	mov	esp,eax
d481 5
d489 2
a490 5
	add	ax,sp
	mov	esp,eax
	mov	ax,SA_LINKSEG
	mov	ds,ax
	data32 addr32 lgdt (Gdtr - SA_LINKADDR)
@


1.20
log
@replace the EMUh* code with something that possibly works better
(at least, I understand it better)

XXX still, DOINT() is somewhat evil…
@
text
@d1 1
a1 1
/*	$MirOS: src/sys/arch/i386/stand/libsa/gidt.S,v 1.19 2009/01/10 13:58:58 tg Exp $ */
d329 5
@


1.19
log
@rename pmm_init into idt_init and let it run in 16 bit mode already,
so that we can use real_to_prot for the actual switch
@
text
@d1 1
a1 1
/*	$MirOS: src/sys/arch/i386/stand/libsa/gidt.S,v 1.18 2009/01/10 13:41:19 tg Exp $ */
d258 2
a259 1
	.align	8, 0x90
d261 12
a272 9
	/* save %eax */
	mov	%eax, 3f
	pop	%eax

	pusha
	push	%ds
	push	%es
	push	%fs
	push	%gs
d274 5
a278 2
	/* save BIOS int vector */
	mov	%al, intno
d283 5
a287 1
	push	%ds
d289 2
a290 22
	addr32  movw (_C_LABEL(BIOS_regs)+(BIOSR_ES) - SA_LINKADDR), %ax
	movw	%ax, %es
	addr32  movw (_C_LABEL(BIOS_regs)+(BIOSR_DS) - SA_LINKADDR), %ax
	movw	%ax, %ds

	# data32 movl $Leax, %eax
	.byte	0x66, 0xb8
3:	.long	0x90909090

	;sti
	int	$0
intno	= . - 1
	;cli

	pop	%ds

	addr32 movl %ebx, (_C_LABEL(BIOS_regs)+(BIOSR_BX) - SA_LINKADDR)
	movw	%es, %bx
	addr32 movw %bx, (_C_LABEL(BIOS_regs)+(BIOSR_ES) - SA_LINKADDR)
	movb	%ah, %bh
	lahf
	xchgb	%ah, %bh
d292 7
a298 1
	addr32 movl %eax, (2f - SA_LINKADDR)
d303 12
a314 17
	# movl $Leax, %eax
	.byte 0xb8
2:	.long 0x90909090

	/* pass BIOS return values back to caller */
	movl	%eax, 0xb*4(%esp)
	movl	%ecx, 0xa*4(%esp)
	movl	%edx, 0x9*4(%esp)
	movb	%bh , 0xe*4(%esp)

	/* clear NT flag in eflags */
	/* Martin Fredriksson <martin@@gbg.netman.se> */
	pushf
	pop	%eax
	and	$0xffffbfff, %eax
	push	%eax
	popf
d316 13
a328 13
	/* save registers into save area */
	movl	%eax, _C_LABEL(BIOS_regs)+BIOSR_AX
	movl	%ecx, _C_LABEL(BIOS_regs)+BIOSR_CX
	movl	%edx, _C_LABEL(BIOS_regs)+BIOSR_DX
	movl	%ebp, _C_LABEL(BIOS_regs)+BIOSR_BP
	movl	%esi, _C_LABEL(BIOS_regs)+BIOSR_SI
	movl	%edi, _C_LABEL(BIOS_regs)+BIOSR_DI

	pop	%gs
	pop	%fs
	pop	%es
	pop	%ds
	popa
a330 1
	.intel_syntax noprefix
@


1.18
log
@new memory layout, part 1
@
text
@d1 1
a1 1
/*	$MirOS: src/sys/arch/i386/stand/libsa/gidt.S,v 1.17 2009/01/10 12:39:08 tg Exp $ */
d114 7
a120 7
	mov	al,0; stosb;				\
	mov	al,(0x80 | SDT_SYS386TGT); stosb;	\
	mov	eax,ebx; shr eax,16; stosw		\

	.globl	_ASM_LABEL(pmm_init)
pmm_init:
	mov	edi,offset idt
a141 1
	lidt	Idtr
d143 1
@


1.17
log
@fix thinkos
@
text
@d1 1
a1 1
/*	$MirOS: src/sys/arch/i386/stand/libsa/gidt.S,v 1.16 2009/01/10 12:32:52 tg Exp $ */
d5 1
d363 1
a363 1
	 * - CS = DS = ES = 4012h = (SA_LINKADDR >> 4)
@


1.16
log
@preserve ESP(16:19) into real mode SS, and real mode SS:SP into ESP(0:19);
sprinkle a few cli insns
@
text
@d1 1
a1 1
/*	$MirOS: src/sys/arch/i386/stand/libsa/gidt.S,v 1.15 2009/01/10 12:20:57 tg Exp $ */
d273 1
d303 1
d338 1
d343 6
a348 8
	pop	%eax		/* Don't need return address */
	pop	%esi		/* Buffer Source (linear) */
	pop	%ecx		/* Size */
	pop	%ebp		/* Buffer Target (ES:DI) */
	pop	%edx		/* Device (and flags) */
	pop	%edi		/* Initial CS:IP */

	.intel_syntax noprefix
d351 1
d433 1
d471 1
a471 1
	data32 addr32 lidt (offset Idtr_real - SA_LINKADDR)
d491 1
a491 1
	data32 addr32 lgdt (offset Gdtr - SA_LINKADDR)
a510 1
#endif
@


1.15
log
@macro → inline
@
text
@d1 1
a1 1
/*	$MirOS: src/sys/arch/i386/stand/libsa/gidt.S,v 1.14 2009/01/10 12:12:19 tg Exp $ */
d436 1
a436 1
 * SS = 0000 (SP preserved)
d457 8
a464 1
Lp2r16:	mov	ax,cs
a466 2
	xor	ax,ax
	mov	ss,ax
d475 2
a476 1
 * DS = ES = SS = S32DATA (ESP preserved)
d481 5
@


1.14
log
@pmm_leave is now redundant
@
text
@d1 1
a1 1
/*	$MirOS: src/sys/arch/i386/stand/libsa/gidt.S,v 1.13 2009/01/10 12:10:39 tg Exp $ */
a41 78
#ifdef GIDT_DEBUG
#define	gidt_debug0		; \
	mov	$0xb8000, %eax	; \
	mov	$0x47314730, (%eax)
#define	gidt_debug1		; \
	mov	$(0xb8000 - SA_LINKADDR), %eax	; \
	mov	$0x4f314f30, (%eax)
#define	gidt_debug2		; \
	mov	$0xb8004, %eax	; \
	mov	$0x47334732, (%eax)
#define	gidt_debug3		; \
	mov	$0xb8004, %eax	; \
	mov	$0x4f334f32, (%eax)
#define gidt_debug4		; \
	movl	$0xb8008, %eax	; \
	movl	$0x47344733, (%eax)
#else
#define gidt_debug0 /* gidt_debug0 */
#define gidt_debug1 /* gidt_debug1 */
#define gidt_debug2 /* gidt_debug2 */
#define gidt_debug3 /* gidt_debug3 */
#define gidt_debug4 /* gidt_debug4 */
#endif

#define prot2real						\
	gidt_debug0;						\
								\
	ljmp	$S16TEXT, $1f - SA_LINKADDR;			\
1:								\
	.code16;						\
	movw	$S16DATA, %ax;					\
	movw	%ax, %ds;					\
	movw	%ax, %es;					\
	gidt_debug1;						\
								\
	movl	%cr0, %eax;	/* disable pmmm */		\
	andl 	$~CR0_PE, %eax;					\
	movl	%eax, %cr0;					\
								\
	/* reload real cs:ip */					\
	data32 ljmp	$(SA_LINKADDR >> 4), $1f - SA_LINKADDR;	\
1:								\
	movw	%cs, %ax;	/* setup: %ds, %es = %cs */	\
	movw	%ax, %ds;					\
	movw	%ax, %es;					\
	xorw	%ax, %ax;	/* setup: %ss = 0x0000 */	\
	movw	%ax, %ss;					\
								\
	gidt_debug2;						\
								\
	data32 addr32 lidt (Idtr_real - SA_LINKADDR); /* load idtr for real mode */

#define real2prot						\
	gidt_debug3;						\
								\
	movw	$SA_LINKADDR >> 4, %ax;				\
	movw	%ax, %ds;					\
	data32 addr32 lgdt (Gdtr - SA_LINKADDR);		\
								\
	movl	%cr0, %eax;	/* enable pmmm */		\
	orl	$CR0_PE, %eax;					\
	movl	%eax, %cr0;					\
								\
	data32 ljmp	$S32TEXT, $1f;   /* reload %cs,flush pipeline */\
1:								\
	.code32;						\
	/* reload 32bit %ds, %ss, %es */			\
	mov	$S32DATA, %eax;					\
	mov	%ax, %ds;					\
	mov	%ax, %ss;					\
	mov	%ax, %es;					\
								\
	gidt_debug4;						\
								\
	/* load idtr for debugger and DOS/BIOS iface */		\
	lidt	Idtr;


d445 19
a463 4
	.att_syntax
	prot2real
	.intel_syntax noprefix
	.code16
d475 16
a490 4
	.att_syntax
	real2prot
	.intel_syntax noprefix
	.code32
@


1.13
log
@macro invocations → calls
@
text
@d1 1
a1 1
/*	$MirOS: src/sys/arch/i386/stand/libsa/gidt.S,v 1.12 2009/01/10 12:09:26 tg Exp $ */
a509 8
	.code32
	.globl	_ASM_LABEL(pmm_leave)
pmm_leave:
	.att_syntax
	prot2real
	.intel_syntax noprefix
	jmp	bx

@


1.12
log
@move prot_to_real and real_to_prot to gidt.S for global use and
generalisation; begin not caring about _C_LABEL()
@
text
@d1 1
a1 1
/*	$MirOS: src/sys/arch/i386/stand/libsa/gidt.S,v 1.11 2009/01/02 16:38:37 tg Exp $ */
d350 1
a350 1
	prot2real
d379 1
a379 1
	real2prot
a423 1
	prot2real		/* Switch */
d427 2
@


1.11
log
@make fdboot smaller again, by ifdeffing out the bootbuf part which
isn’t called from the ifdeffed cmd_i386.c anyway
@
text
@d1 1
a1 1
/*	$MirOS: src/sys/arch/i386/stand/libsa/gidt.S,v 1.10 2009/01/02 04:14:35 tg Exp $ */
d516 39
a555 2

	.end
@


1.10
log
@make /usr/mdec/boot aka bootbsd.com multiboot-compliant
(means: can be loaded from grub)
@
text
@d1 1
a1 1
/*	$MirOS: src/sys/arch/i386/stand/libsa/gidt.S,v 1.9 2009/01/02 02:18:56 tg Exp $ */
d47 1
a47 1
	mov	$(0xb8000 - LINKADDR), %eax	; \
d69 1
a69 1
	ljmp	$S16TEXT, $1f - LINKADDR;			\
d82 1
a82 1
	data32 ljmp	$(LINKADDR >> 4), $1f - LINKADDR;	\
d92 1
a92 1
	data32 addr32 lidt (Idtr_real - LINKADDR); /* load idtr for real mode */
d97 1
a97 1
	movw	$LINKADDR >> 4, %ax;				\
d99 1
a99 1
	data32 addr32 lgdt (Gdtr - LINKADDR); 	/* load the gdtr */	\
d124 1
a124 2
	.globl	_ASM_LABEL(pmm_init)
	.globl	_ASM_LABEL(pmm_leave)
a125 1

d195 1
d252 4
a255 4
	.word	0xFFFF			# lolimit
	.word	(LINKADDR & 0xffff)	# lobase
	.byte	(LINKADDR >> 16) & 0xff	# midbase
	.byte	SDT_MEMERAC | 0 | 0x80	# RXAC, dpl = 0, present
d257 1
a257 1
	.byte	(LINKADDR >> 20) & 0xff	# hibase
d259 4
a262 4
	.word	0xFFFF			# lolimit
	.word	(LINKADDR & 0xffff)	# lobase
	.byte	(LINKADDR >> 16) & 0xff	# midbase
	.byte	SDT_MEMRWA | 0 | 0x80	# RWA, dpl = 0, present
d264 1
a264 1
	.byte	(LINKADDR >> 20) & 0xff	# hibase
d354 1
a354 1
	addr32  movw (_C_LABEL(BIOS_regs)+(BIOSR_ES) - LINKADDR), %ax
d356 1
a356 1
	addr32  movw (_C_LABEL(BIOS_regs)+(BIOSR_DS) - LINKADDR), %ax
d370 1
a370 1
	addr32 movl %ebx, (_C_LABEL(BIOS_regs)+(BIOSR_BX) - LINKADDR)
d372 1
a372 1
	addr32 movw %bx, (_C_LABEL(BIOS_regs)+(BIOSR_ES) - LINKADDR)
d377 1
a377 1
	addr32 movl %eax, (2f - LINKADDR)
d414 1
d437 1
a437 1
	 * - CS = DS = ES = 4012h = (LINKADDR >> 4)
d470 1
a470 1
	mov	esi,offset _C_LABEL(bios_bootpte) - LINKADDR
d510 1
d516 1
@


1.9
log
@finally be able to load grub-legacy too: move our stack out of the way
@
text
@d1 1
a1 1
/*	$MirOS: src/sys/arch/i386/stand/libsa/gidt.S,v 1.8 2009/01/02 02:13:21 tg Exp $ */
d125 1
d509 7
@


1.8
log
@allow for bigger sizes for grub1/stage2
@
text
@d1 1
a1 1
/*	$MirOS: src/sys/arch/i386/stand/libsa/gidt.S,v 1.6 2009/01/02 01:38:43 tg Exp $ */
d430 1
a430 1
	mov	esp,0x0000FFFC
d437 1
a437 1
	 * - SS:SP = 0000:FFFCh
d448 4
a451 1
	 *   we also move certain relocation code there
@


1.7
log
@damned as(1) makes
	mov cx,[expr]
out of
	mov cx,offset foo - bar
but
	mov cx,expr
out of
	mov cx,offset foo - offset bar
, which is what we want
@
text
@d456 1
a456 1
	push	cx		/* source buffer size */
d476 1
a476 1
	pop	cx		/* source buffer size */
d478 18
a495 2
	rep	movsb
	xor	ax,ax
@


1.6
log
@prevent a couple of possible interrupt and stack races
@
text
@d1 1
a1 1
/*	$MirOS: src/sys/arch/i386/stand/libsa/gidt.S,v 1.5 2009/01/01 23:59:02 tg Exp $ */
a483 1
	Ltcsz = . - Ltcbeg
d485 1
a485 1
	mov	cx,Ltcsz
@


1.5
log
@split between buffer target address ES:DI and later initial CS:IP
@
text
@d1 1
a1 1
/*	$MirOS: src/sys/arch/i386/stand/libsa/gidt.S,v 1.4 2009/01/01 21:46:38 tg Exp $ */
d416 1
a427 1
	cli
d429 2
a432 2
	mov	ss,ax
	mov	esp,0x0000FFFC
@


1.4
log
@rewrite bootbuf to pass something in DS:SI and have extensions for
the future that might make more sense or help with the other stuff
@
text
@d1 1
a1 1
/*	$MirOS: src/sys/arch/i386/stand/libsa/gidt.S,v 1.3 2009/01/01 19:45:38 tg Exp $ */
d417 1
a417 1
	pop	%esi		/* Buffer */
d419 1
d441 2
a442 1
	 * - EDI = target address and initial CS:IP (FAR pointer)
d459 4
a462 2
	push	ax		/* future CS (ES) */
	push	di		/* future IP (DI) */
d473 2
a474 2
	pop	di		/* future IP (DI) */
	pop	es		/* future CS (ES) */
@


1.3
log
@don't lie, OpenBSD!
@
text
@d1 1
a1 1
/*	$MirOS: src/sys/arch/i386/stand/libsa/gidt.S,v 1.2 2009/01/01 19:45:02 tg Exp $ */
d418 3
a420 1
	pop	%edx		/* Device */
d423 3
a425 1
	/* Set up stack */
d427 21
a447 4
	xor	%ax, %ax
	mov	%ax, %ss
	mov	$0xfffc, %esp
	sti
d449 36
a484 2
	/* Jump to buffer */
	ljmp $0x0, $0x7c00
@


1.2
log
@create the IDT dynamically, removes all of the relocation warnings too
@
text
@d1 1
a1 1
/*	$MirOS$ */
d84 1
a84 1
	movw	%cs, %ax;	/* setup: %ds, %es, %ss = %cs */ \
d87 1
a87 1
	xorw	%ax, %ax;					\
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$OpenBSD: gidt.S,v 1.28 2004/03/19 13:48:18 tom Exp $	*/
d73 2
a74 2
	mov	%ax, %ds;					\
	mov	%ax, %es;					\
d84 5
a88 4
	xor	%ax, %ax;	/* setup: %ds, %es, %ss */	\
	mov	%ax, %ds;					\
	mov	%ax, %es;					\
	mov	%ax, %ss;					\
d92 1
a92 1
	data32 addr32 lidt Idtr_real;	/* load idtr for real mode */
d97 3
a99 1
	data32 addr32 lgdt Gdtr;	/* load the gdtr */	\
d151 1
a151 1
	/* Try to cause a tripple fault... */
d163 12
a174 5
	.align	8, 0x90
pmm_init:
	/* load idtr for interrupts */
	lidt	Idtr
	ret
d176 1
d181 1
d185 1
d187 13
a199 6
	.align 8, 0x90
idt:
#define idte(e)	\
	.short	IPROC(e); .short (S32TEXT); \
	.short	((0x80|SDT_SYS386TGT) << 8); .short (LINKADDR >> 16)
/* internal (0-31) */
a209 5
#ifdef __STDC__
#define idtb(b)	idte(emu##b)
#else
#define idtb(b)	idte(emu/**/b)
#endif
d218 5
a222 5
#undef idte
	.globl	Idtr
Idtr:	.word	. - idt - 1
	.long	idt
	.word	0
d256 1
a256 1
	.byte	0xf | 0 | 0 | 0		# hilimit, xx, 16bit, byte granularity
d263 1
a263 1
	.byte	0xf | 0 | 0 | 0		# hilimit, xx, 16bit, byte granularity
d296 2
a297 2
IENTRY(ts,T_TSSFLT)		/* #TS innvalid TSS */
IENTRY(np,T_SEGNPFLT)		/* #NP segmant not present */
d354 4
a357 4
	addr32  mov _C_LABEL(BIOS_regs)+(BIOSR_ES), %eax
	mov	%ax, %es
	addr32  mov _C_LABEL(BIOS_regs)+(BIOSR_DS), %eax
	mov	%ax, %ds
d370 3
a372 3
	addr32 mov %ebx, _C_LABEL(BIOS_regs)+(BIOSR_BX)
	mov	%es, %bx
	addr32 mov %ebx, _C_LABEL(BIOS_regs)+(BIOSR_ES)
d377 1
a377 1
	addr32 mov %eax, 2f
d386 3
a388 3
	mov	%eax, 0xb*4(%esp)
	mov	%ecx, 0xa*4(%esp)
	mov	%edx, 0x9*4(%esp)
d400 6
a405 6
	mov	%eax, _C_LABEL(BIOS_regs)+BIOSR_AX
	mov	%ecx, _C_LABEL(BIOS_regs)+BIOSR_CX
	mov	%edx, _C_LABEL(BIOS_regs)+BIOSR_DX
	mov	%ebp, _C_LABEL(BIOS_regs)+BIOSR_BP
	mov	%esi, _C_LABEL(BIOS_regs)+BIOSR_SI
	mov	%edi, _C_LABEL(BIOS_regs)+BIOSR_DI
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@improve my Frankenstein OS (*wink* you know who you are) further
sans wchar_t of course

this is the essence of reading >1200 commit messages which suck
due to not having the new format of ours...
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.29 2005/04/25 23:09:04 tom Exp $	*/
d72 2
a73 2
	movw	%ax, %ds;					\
	movw	%ax, %es;					\
d83 4
a86 5
	movw	%cs, %ax;	/* setup: %ds, %es, %ss = %cs */ \
	movw	%ax, %ds;					\
	movw	%ax, %es;					\
	xorw	%ax, %ax;					\
	movw	%ax, %ss;					\
d90 1
a90 1
	data32 addr32 lidt (Idtr_real - LINKADDR); /* load idtr for real mode */
d95 1
a95 3
	movw	$LINKADDR >> 4, %ax;				\
	movw	%ax, %ds;					\
	data32 addr32 lgdt (Gdtr - LINKADDR); 	/* load the gdtr */	\
d240 1
a240 1
	.byte	0x0 | 0 | 0 | 0		# hilimit, xx, 16bit, byte granularity
d247 1
a247 1
	.byte	0x0 | 0 | 0 | 0		# hilimit, xx, 16bit, byte granularity
d338 4
a341 4
	addr32  movw (_C_LABEL(BIOS_regs)+(BIOSR_ES) - LINKADDR), %ax
	movw	%ax, %es
	addr32  movw (_C_LABEL(BIOS_regs)+(BIOSR_DS) - LINKADDR), %ax
	movw	%ax, %ds
d354 3
a356 3
	addr32 movw %bx, (_C_LABEL(BIOS_regs)+(BIOSR_BX) - LINKADDR)
	movw	%es, %bx
	addr32 movw %bx, (_C_LABEL(BIOS_regs)+(BIOSR_ES) - LINKADDR)
d361 1
a361 1
	addr32 movl %eax, (2f - LINKADDR)
d370 3
a372 3
	movl	%eax, 0xb*4(%esp)
	movl	%ecx, 0xa*4(%esp)
	movl	%edx, 0x9*4(%esp)
d384 6
a389 6
	movl	%eax, _C_LABEL(BIOS_regs)+BIOSR_AX
	movl	%ecx, _C_LABEL(BIOS_regs)+BIOSR_CX
	movl	%edx, _C_LABEL(BIOS_regs)+BIOSR_DX
	movl	%ebp, _C_LABEL(BIOS_regs)+BIOSR_BP
	movl	%esi, _C_LABEL(BIOS_regs)+BIOSR_SI
	movl	%edi, _C_LABEL(BIOS_regs)+BIOSR_DI
@


1.1.1.3
log
@support for ext2fs large files, and a bootloader bugfix
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.30 2005/04/30 16:14:35 tom Exp $	*/
d357 1
a357 1
	addr32 movl %ebx, (_C_LABEL(BIOS_regs)+(BIOSR_BX) - LINKADDR)
@


1.1.1.4
log
@while I'm here anyway...
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.31 2005/05/31 23:08:47 jmc Exp $	*/
d283 2
a284 2
IENTRY(ts,T_TSSFLT)		/* #TS invalid TSS */
IENTRY(np,T_SEGNPFLT)		/* #NP segment not present */
@


1.1.1.5
log
@import bootloader-related pieces from openbsd, as first part of the
aspired 4.4 merge… and something else
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.32 2006/12/26 19:30:44 tom Exp $	*/
d150 1
a150 1
	/* Try to cause a triple fault... */
@


