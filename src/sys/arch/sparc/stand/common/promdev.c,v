head	1.9;
access;
symbols
	tg-beforemerge-ksrc10:1.1.1.1
	MIRBSD_10:1.2.0.2
	MIRBSD_10_BASE:1.2
	MIRBSD_9_BASE:1.2
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2018.04.28.01.50.58;	author tg;	state Exp;
branches;
next	1.8;
commitid	1005AE3D3891E602D4C;

1.8
date	2010.09.12.18.31.35;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004C8D1C8C6446AD76;

1.7
date	2010.01.16.20.56.07;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004B5227F669D8B3E6;

1.6
date	2009.08.11.13.24.00;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004A8170C73C4BAD74;

1.5
date	2009.04.17.18.57.08;	author tg;	state Exp;
branches;
next	1.4;
commitid	10049E8D11A2584B057;

1.4
date	2009.02.01.16.12.31;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004985CA0575C03812;

1.3
date	2008.07.13.19.42.40;	author tg;	state Exp;
branches;
next	1.2;
commitid	100487A5AB509C87D3D;

1.2
date	2006.06.16.21.52.53;	author tg;	state Exp;
branches;
next	1.1;
commitid	1004493283B5D0D1060;

1.1
date	2005.02.05.17.27.43;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.27.43;	author tg;	state Exp;
branches;
next	;


desc
@@


1.9
log
@new boot flag -D to disable debugger symbols loading (sparc part), experimental
@
text
@/**	$MirOS: src/sys/arch/sparc/stand/common/promdev.c,v 1.8 2010/09/12 18:31:35 tg Exp $ */
/*	$OpenBSD: promdev.c,v 1.9 2003/08/14 17:13:57 deraadt Exp $	*/
/*	$NetBSD: promdev.c,v 1.16 1995/11/14 15:04:01 pk Exp $ */

/*
 * Copyright (c) 1993 Paul Kranenburg
 * Copyright (c) 1995 Gordon W. Ross
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Paul Kranenburg.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Note: the `#ifndef BOOTXX' in here serve to queeze the code size
 * of the 1st-stage boot program.
 */
#include <sys/param.h>
#include <sys/reboot.h>
#include <machine/idprom.h>
#include <machine/oldmon.h>
#include <machine/ctlreg.h>

#include <lib/libsa/stand.h>

#include <sparc/stand/common/promdev.h>

void bzero(void *, size_t);

int	obp_close(struct open_file *);
int	obp_strategy(void *, int, daddr_t, size_t, void *, size_t *);
ssize_t	obp_xmit(struct promdata *, void *, size_t);
ssize_t	obp_recv(struct promdata *, void *, size_t);
int	prom0_close(struct open_file *);
int	prom0_strategy(void *, int, daddr_t, size_t, void *, size_t *);
void	prom0_iclose(struct saioreq *);
int	prom0_iopen(struct promdata *);
ssize_t	prom0_xmit(struct promdata *, void *, size_t);
ssize_t	prom0_recv(struct promdata *, void *, size_t);

static char	*prom_mapin(u_long, int, int);

int	getdevtype(int, char *);
int	getprop(int, char *, void *, int);
char	*getpropstring(int, char *);

static void	prom0_fake(void);

#if !defined(BOOTXX) && !defined(SMALL_BOOT)
int net_open(struct promdata *);
int net_close(struct promdata *);
#endif
int getticks(void);

#ifndef SMALL_BOOT
extern struct filesystem file_system_nfs[];
extern struct filesystem file_system_cd9660[];
#endif
#ifdef USE_USTARFS
extern struct filesystem file_system_ustarfs[];
#endif
extern struct filesystem file_system_ufs[];

int
prom_open(struct open_file *f, ...)
{
	return 0;
}

int
prom_ioctl(struct open_file *f, u_long c, void *d)
{
	return EIO;
}

struct devsw devsw[] = {
	{ "prom0", prom0_strategy, prom_open, prom0_close, prom_ioctl },
	{ "prom", obp_strategy, prom_open, obp_close, prom_ioctl }
};

char	*prom_bootdevice;
char	*prom_bootfile;
int	prom_boothow;

struct	promvec	*promvec;
static int	saveecho;

#ifndef SMALL_BOOT
extern const char progname[];
#endif

void
prom_init()
{
	register char *cp, *dp;
#ifndef BOOTXX
	register char *ap;
#endif

	if (cputyp == CPU_SUN4)
		prom0_fake();

	if (promvec->pv_romvec_vers >= 2) {
#ifndef BOOTXX
		static char filestore[16];
#endif

		prom_bootdevice = *promvec->pv_v2bootargs.v2_bootpath;

#ifndef BOOTXX
		cp = *promvec->pv_v2bootargs.v2_bootargs;
		dp = prom_bootfile = filestore;
		while (*cp && *cp != '-')
			*dp++ = *cp++;
		while (dp > prom_bootfile && *--dp == ' ');
		*++dp = '\0';
		ap = cp;
#endif
	} else {
		static char bootstore[16];
		dp = prom_bootdevice = bootstore;
		cp = (*promvec->pv_v0bootargs)->ba_argv[0];
		while (*cp) {
			*dp++ = *cp;
			if (*cp++ == ')')
				break;
		}
		*dp = '\0';
#ifndef BOOTXX
		prom_bootfile = (*promvec->pv_v0bootargs)->ba_kernel;
		ap = (*promvec->pv_v0bootargs)->ba_argv[1];
#endif
	}

#ifndef BOOTXX
	if (ap == NULL || *ap != '-')
		return;

	while (*ap) {
		switch (*ap++) {
		case 'a':
			prom_boothow |= RB_ASKNAME;
			break;
		case 'c':
			prom_boothow |= RB_CONFIG;
			break;
		case 'D':
			prom_boothow |= RB_NO_KSYMS;
			break;
		case 'd':
			prom_boothow |= RB_KDB;
			debug = 1;
			break;
		case 's':
			prom_boothow |= RB_SINGLE;
			break;
		}
	}
#endif

#ifndef SMALL_BOOT
	printf(">> MirBSD %s " __BOOT_VER "\n", progname);
#endif
}

#define ADDFS(f)	bcopy(f, file_system + nfsys++, sizeof(struct fs_ops))

int
devopen(f, fname, file)
	struct open_file *f;
	const char *fname;
	char **file;
{
	int	error = 0, fd = 0;
	struct	promdata *pd;

	pd = (struct promdata *)alloc(sizeof *pd);

	if (cputyp == CPU_SUN4) {
		error = prom0_iopen(pd);
#ifndef BOOTXX
		pd->xmit = prom0_xmit;
		pd->recv = prom0_recv;
#endif
	} else {
		fd = (promvec->pv_romvec_vers >= 2)
			? (*promvec->pv_v2devops.v2_open)(prom_bootdevice)
			: (*promvec->pv_v0devops.v0_open)(prom_bootdevice);
		if (fd == 0) {
			error = ENXIO;
		} else {
			pd->fd = fd;
#ifndef BOOTXX
			pd->xmit = obp_xmit;
			pd->recv = obp_recv;
#endif
		}
	}

	if (error) {
		printf("Can't open device `%s'\n", prom_bootdevice);
		return (error);
	}

#ifdef BOOTXX
	pd->devtype = DT_BLOCK;
#else /* BOOTXX */
	pd->devtype = getdevtype(fd, prom_bootdevice);
	/* Assume type BYTE is a raw device */
	if (pd->devtype != DT_BYTE)
		*file = (char *)fname;

	nfsys = 0;
#ifndef SMALL_BOOT
	if (pd->devtype == DT_NET) {
		ADDFS(file_system_nfs);
		if ((error = net_open(pd)) != 0) {
			printf("Can't open network device `%s'\n",
				prom_bootdevice);
			return error;
		}
	} else
#endif
	    {
		ADDFS(file_system_ufs);
#ifndef SMALL_BOOT
		ADDFS(file_system_cd9660);
#endif
#ifdef USE_USTARFS
		ADDFS(file_system_ustarfs);
#endif
	}
#endif /* BOOTXX */

	f->f_dev = &devsw[cputyp == CPU_SUN4 ? 0 : 1];
	f->f_devdata = (void *)pd;
	return 0;
}

int
obp_strategy(devdata, flag, dblk, size, buf, rsize)
	void	*devdata;
	int	flag;
	daddr_t	dblk;
	size_t	size;
	void	*buf;
	size_t	*rsize;
{
	int	error = 0;
	struct	promdata *pd = (struct promdata *)devdata;
	int	fd = pd->fd;

#ifdef DEBUG_PROM
	printf("promstrategy: size=%d dblk=%d\n", size, dblk);
#endif

	if (promvec->pv_romvec_vers >= 2) {
		if (pd->devtype == DT_BLOCK)
			(*promvec->pv_v2devops.v2_seek)(fd, 0, dbtob(dblk));

		*rsize = (*((flag == F_READ) ?
		    (u_int (*)(int, char *, size_t))promvec->pv_v2devops.v2_read :
		    (u_int (*)(int, char *, size_t))promvec->pv_v2devops.v2_write))
		    (fd, buf, size);
	} else {
		int n = (*((flag == F_READ) ?
		    (u_int (*)(int, int, daddr_t, void *))promvec->pv_v0devops.v0_rbdev :
		    (u_int (*)(int, int, daddr_t, void *))promvec->pv_v0devops.v0_wbdev))
		    (fd, btodb(size), dblk, buf);
		*rsize = dbtob(n);
	}

#ifdef DEBUG_PROM
	printf("rsize = %x\n", *rsize);
#endif
	return error;
}

/*
 * On old-monitor machines, things work differently.
 */
int
prom0_strategy(devdata, flag, dblk, size, buf, rsize)
	void	*devdata;
	int	flag;
	daddr_t	dblk;
	size_t	size;
	void	*buf;
	size_t	*rsize;
{
	struct promdata	*pd = devdata;
	struct saioreq	*si;
	struct om_boottable *ops;
	char	*dmabuf;
	int	si_flag;
	size_t	xcnt;

	si = pd->si;
	ops = si->si_boottab;

#ifdef DEBUG_PROM
	printf("prom_strategy: size=%d dblk=%d\n", size, dblk);
#endif

	dmabuf = dvma_mapin(buf, size);

	si->si_bn = dblk;
	si->si_ma = dmabuf;
	si->si_cc = size;

	si_flag = (flag == F_READ) ? SAIO_F_READ : SAIO_F_WRITE;
	xcnt = (*ops->b_strategy)(si, si_flag);
	dvma_mapout(dmabuf, size);

#ifdef DEBUG_PROM
	printf("disk_strategy: xcnt = %x\n", xcnt);
#endif

	if (xcnt <= 0)
		return (EIO);

	*rsize = xcnt;
	return (0);
}

int
obp_close(f)
	struct open_file *f;
{
	struct promdata *pd = f->f_devdata;
	register int fd = pd->fd;

#if !defined(BOOTXX) && !defined(SMALL_BOOT)
	if (pd->devtype == DT_NET)
		net_close(pd);
#endif
	if (promvec->pv_romvec_vers >= 2)
		(void)(*promvec->pv_v2devops.v2_close)(fd);
	else
		(void)(*promvec->pv_v0devops.v0_close)(fd);
	return 0;
}

int
prom0_close(f)
	struct open_file *f;
{
	struct promdata *pd = f->f_devdata;

#if !defined(BOOTXX) && !defined(SMALL_BOOT)
	if (pd->devtype == DT_NET)
		net_close(pd);
#endif
	prom0_iclose(pd->si);
	pd->si = NULL;
	*romp->echo = saveecho; /* Hmm, probably must go somewhere else */
	return 0;
}

#ifndef BOOTXX
ssize_t
obp_xmit(pd, buf, len)
	struct	promdata *pd;
	void	*buf;
	size_t	len;
{
	return (promvec->pv_romvec_vers >= 2
		? (*promvec->pv_v2devops.v2_write)(pd->fd, buf, len)
		: (*promvec->pv_v0devops.v0_wnet)(pd->fd, len, buf));
}

ssize_t
obp_recv(pd, buf, len)
	struct	promdata *pd;
	void	*buf;
	size_t	len;
{
	int n;

	n = (promvec->pv_romvec_vers >= 2
		? (*promvec->pv_v2devops.v2_read)(pd->fd, buf, len)
		: (*promvec->pv_v0devops.v0_rnet)(pd->fd, len, buf));
	return (n == -2 ? 0 : n);
}

ssize_t
prom0_xmit(pd, buf, len)
	struct	promdata *pd;
	void	*buf;
	size_t	len;
{
	struct saioreq	*si;
	struct saif	*sif;
	char		*dmabuf;
	int		rv;

	si = pd->si;
	sif = si->si_sif;
	if (sif == NULL) {
		printf("xmit: not a network device\n");
		return (-1);
	}
	dmabuf = dvma_mapin(buf, len);
	rv = sif->sif_xmit(si->si_devdata, dmabuf, len);
	dvma_mapout(dmabuf, len);

	return (ssize_t)(rv ? -1 : len);
}

ssize_t
prom0_recv(pd, buf, len)
	struct	promdata *pd;
	void	*buf;
	size_t	len;
{
	struct saioreq	*si;
	struct saif	*sif;
	char		*dmabuf;
	int		rv;

	si = pd->si;
	sif = si->si_sif;
	dmabuf = dvma_mapin(buf, len);
	rv = sif->sif_poll(si->si_devdata, dmabuf);
	dvma_mapout(dmabuf, len);

	return (ssize_t)rv;
}

int
getchar()
{
	char c;
	register int n;

	if (promvec->pv_romvec_vers > 2)
		while ((n = (*promvec->pv_v2devops.v2_read)
			(*promvec->pv_v2bootargs.v2_fd0, (caddr_t)&c, 1)) != 1);
	else {
                /* SUN4 PROM: must turn off local echo */
                struct om_vector *oldpvec = (struct om_vector *)PROM_BASE;
                int saveecho = 0;

                if (CPU_ISSUN4) {
                        saveecho = *(oldpvec->echo);
                        *(oldpvec->echo) = 0;
                }
                c = (*promvec->pv_getchar)();
                if (CPU_ISSUN4)
                        *(oldpvec->echo) = saveecho;
	}

	if (c == '\r')
		c = '\n';
	return (c);
}

int
cngetc(void)
{
	return getchar();
}

int
peekchar(void)
{
	char c;
	register int n;

	if (promvec->pv_romvec_vers > 2) {
		n = (*promvec->pv_v2devops.v2_read)
			(*promvec->pv_v2bootargs.v2_fd0, (caddr_t)&c, 1);
		if (n < 0)
			return -1;
	} else
		c = (*promvec->pv_nbgetchar)();

	if (c == '\r')
		c = '\n';
	return (c);
}
#endif

static void
pv_putchar(int c)
{
	char c0 = c;

	if (promvec->pv_romvec_vers > 2)
		(*promvec->pv_v2devops.v2_write)
			(*promvec->pv_v2bootargs.v2_fd1, &c0, 1);
	else
		(*promvec->pv_putchar)(c);
}

void
putchar(c)
	int c;
{

	if (c == '\n')
		pv_putchar('\r');
	pv_putchar(c);
}

void
_rtt()
{
	promvec->pv_halt();
}

#ifndef BOOTXX
#ifndef SMALL_BOOT
int hz = 1000;

time_t
getsecs(void)
{
	register int ticks = getticks();
	return ((time_t)(ticks / hz));
}

int
getticks(void)
{
	if (promvec->pv_romvec_vers >= 2) {
		char c;
		(void)(*promvec->pv_v2devops.v2_read)
			(*promvec->pv_v2bootargs.v2_fd0, (caddr_t)&c, 0);
	} else {
		(void)(*promvec->pv_nbgetchar)();
	}
	return *(promvec->pv_ticks);
}

void
prom_getether(int fd, u_char *ea)
{
	if (cputyp == CPU_SUN4) {
		static struct idprom sun4_idprom;
		u_char *src, *dst;
		int len, x;

		if (sun4_idprom.id_format == 0) {
			dst = (char *)&sun4_idprom;
			src = (char *)AC_IDPROM;
			len = sizeof(struct idprom);
			do {
				x = lduba(src++, ASI_CONTROL);
				*dst++ = x;
			} while (--len > 0);
		}
		bcopy(sun4_idprom.id_ether, ea, 6);
	} else if (promvec->pv_romvec_vers <= 2) {
		(void)(*promvec->pv_enaddr)(fd, (char *)ea);
	} else {
		char buf[64];
		snprintf(buf, sizeof buf, "%x mac-address drop swap 6 cmove", ea);
		promvec->pv_fortheval.v2_eval(buf);
	}
}
#endif

/*
 * A number of well-known devices on sun4s.
 */
static struct dtab {
	char	*name;
	int	type;
} dtab[] = {
	{ "sd",	DT_BLOCK },
	{ "st",	DT_BLOCK },
	{ "xd",	DT_BLOCK },
	{ "xy",	DT_BLOCK },
	{ "fd",	DT_BLOCK },
	{ "le",	DT_NET },
	{ "ie",	DT_NET },
	{ NULL, 0 }
};

int
getdevtype(fd, name)
	int	fd;
	char	*name;
{
	if (promvec->pv_romvec_vers >= 2) {
		int node = (*promvec->pv_v2devops.v2_fd_phandle)(fd);
		char *cp = getpropstring(node, "device_type");
		if (strcmp(cp, "block") == 0)
			return DT_BLOCK;
		else if (strcmp(cp, "network") == 0)
			return DT_NET;
		else if (strcmp(cp, "byte") == 0)
			return DT_BYTE;
	} else {
		struct dtab *dp;
		for (dp = dtab; dp->name; dp++) {
			if (name[0] == dp->name[0] &&
			    name[1] == dp->name[1])
				return dp->type;
		}
	}
	return 0;
}

/*
 * OpenPROM nodes & property routines (from <sparc/autoconf.c>).
 */
int
getprop(node, name, buf, bufsiz)
	int node;
	char *name;
	void *buf;
	register int bufsiz;
{
	register struct nodeops *no;
	register int len;

	no = promvec->pv_nodeops;
	len = no->no_proplen(node, name);
	if (len > bufsiz) {
		printf("node %x property %s length %d > %d\n",
		    node, name, len, bufsiz);
		return (0);
	}
	no->no_getprop(node, name, buf);
	return (len);
}

/*
 * Return a string property.  There is a (small) limit on the length;
 * the string is fetched into a static buffer which is overwritten on
 * subsequent calls.
 */
char *
getpropstring(node, name)
	int node;
	char *name;
{
	register int len;
	static char stringbuf[64];

	len = getprop(node, name, (void *)stringbuf, sizeof stringbuf - 1);
	if (len == -1)
		len = 0;
	stringbuf[len] = '\0';	/* usually unnecessary */
	return (stringbuf);
}
#endif /* BOOTXX */

/*
 * Old monitor routines
 */

#include <machine/pte.h>

struct saioreq prom_si;
static int promdev_inuse;

int
prom0_iopen(pd)
	struct promdata	*pd;
{
	struct om_bootparam *bp;
	struct om_boottable *ops;
	struct devinfo *dip;
	struct saioreq *si;
	int	error;

	if (promdev_inuse)
		return(EMFILE);

	bp = *romp->bootParam;
	ops = bp->bootTable;
	dip = ops->b_devinfo;

#ifdef DEBUG_PROM
	printf("Boot device type: %s\n", ops->b_desc);
	printf("d_devbytes=%d\n", dip->d_devbytes);
	printf("d_dmabytes=%d\n", dip->d_dmabytes);
	printf("d_localbytes=%d\n", dip->d_localbytes);
	printf("d_stdcount=%d\n", dip->d_stdcount);
	printf("d_stdaddrs[%d]=%x\n", bp->ctlrNum, dip->d_stdaddrs[bp->ctlrNum]);
	printf("d_devtype=%d\n", dip->d_devtype);
	printf("d_maxiobytes=%d\n", dip->d_maxiobytes);
#endif

	dvma_init();

	si = &prom_si;
	bzero((caddr_t)si, sizeof(*si));
	si->si_boottab = ops;
	si->si_ctlr = bp->ctlrNum;
	si->si_unit = bp->unitNum;
	si->si_boff = bp->partNum;

	if (si->si_ctlr > dip->d_stdcount) {
		printf("Invalid controller number\n");
		return(ENXIO);
	}

	if (dip->d_devbytes) {
		si->si_devaddr = prom_mapin(dip->d_stdaddrs[si->si_ctlr],
			dip->d_devbytes, dip->d_devtype);
#ifdef	DEBUG_PROM
		printf("prom_iopen: devaddr=0x%x pte=0x%x\n",
			si->si_devaddr,
			getpte((u_long)si->si_devaddr & ~PGOFSET));
#endif
	}

	if (dip->d_dmabytes) {
		si->si_dmaaddr = dvma_alloc(dip->d_dmabytes);
#ifdef	DEBUG_PROM
		printf("prom_iopen: dmaaddr=0x%x\n", si->si_dmaaddr);
#endif
	}

	if (dip->d_localbytes) {
		si->si_devdata = alloc(dip->d_localbytes);
#ifdef	DEBUG_PROM
		printf("prom_iopen: devdata=0x%x\n", si->si_devdata);
#endif
	}

	/* OK, call the PROM device open routine. */
	error = (*ops->b_open)(si);
	if (error != 0) {
		printf("prom_iopen: \"%s\" error=%d\n",
			   ops->b_desc, error);
		return (ENXIO);
	}
#ifdef	DEBUG_PROM
	printf("prom_iopen: succeeded, error=%d\n", error);
#endif

	pd->si = si;
	promdev_inuse++;
	return (0);
}

void
prom0_iclose(si)
	struct saioreq *si;
{
	struct om_boottable *ops;
	struct devinfo *dip;

	if (promdev_inuse == 0)
		return;

	ops = si->si_boottab;
	dip = ops->b_devinfo;

	(*ops->b_close)(si);

	if (si->si_dmaaddr) {
		dvma_free(si->si_dmaaddr, dip->d_dmabytes);
		si->si_dmaaddr = NULL;
	}

	promdev_inuse = 0;
}

static struct mapinfo {
	int maptype;
	int pgtype;
	int base;
} prom_mapinfo[] = {
	{ MAP_MAINMEM,   PG_OBMEM, 0 },
	{ MAP_OBIO,      PG_OBIO,  0 },
	{ MAP_MBMEM,     PG_VME16, 0xFF000000 },
	{ MAP_MBIO,      PG_VME16, 0xFFFF0000 },
	{ MAP_VME16A16D, PG_VME16, 0xFFFF0000 },
	{ MAP_VME16A32D, PG_VME32, 0xFFFF0000 },
	{ MAP_VME24A16D, PG_VME16, 0xFF000000 },
	{ MAP_VME24A32D, PG_VME32, 0xFF000000 },
	{ MAP_VME32A16D, PG_VME16, 0 },
	{ MAP_VME32A32D, PG_VME32, 0 },
};
static size_t prom_mapinfo_cnt = sizeof(prom_mapinfo) / sizeof(prom_mapinfo[0]);

/* The virtual address we will use for PROM device mappings. */
static u_long prom_devmap = MONSHORTSEG;

static char *
prom_mapin(physaddr, length, maptype)
	u_long physaddr;
	int length, maptype;
{
	int i, pa, pte, va;

	if (length > (4*NBPG))
		panic("prom_mapin: length=%d", length);

	for (i = 0; i < prom_mapinfo_cnt; i++)
		if (prom_mapinfo[i].maptype == maptype)
			goto found;
	panic("prom_mapin: invalid maptype %d", maptype);
found:

	pte = prom_mapinfo[i].pgtype;
	pte |= (PG_V|PG_W|PG_S|PG_NC);
	pa = prom_mapinfo[i].base;
	pa += physaddr;
	pte |= ((pa >> PGSHIFT) & PG_PFNUM);

	va = prom_devmap;
	do {
		setpte(va, pte);
		va += NBPG;
		pte += 1;
		length -= NBPG;
	} while (length > 0);
	return ((char *)(prom_devmap | (pa & PGOFSET)));
}

void
prom0_fake()
{
static	struct promvec promvecstore;

	promvec = &promvecstore;

	promvec->pv_stdin = romp->inSource;
	promvec->pv_stdout = romp->outSink;
	promvec->pv_putchar = romp->putChar;
	promvec->pv_putstr = romp->fbWriteStr;
	promvec->pv_nbgetchar = romp->mayGet;
	promvec->pv_getchar = romp->getChar;
	promvec->pv_romvec_vers = 0;            /* eek! */
	promvec->pv_reboot = romp->reBoot;
	promvec->pv_abort = romp->abortEntry;
	promvec->pv_setctxt = romp->setcxsegmap;
	promvec->pv_v0bootargs = (struct v0bootargs **)(romp->bootParam);
	promvec->pv_halt = romp->exitToMon;
	promvec->pv_ticks = romp->nmiClock;
	saveecho = *romp->echo;
	*romp->echo = 0;
}
@


1.8
log
@make random() a possible early alternative until arc4random(9) works
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/sparc/stand/common/promdev.c,v 1.7 2010/01/16 20:56:07 tg Exp $ */
d169 3
@


1.7
log
@add ustarfs to the floppy bootloader (untested)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/sparc/stand/common/promdev.c,v 1.6 2009/08/11 13:24:00 tg Exp $ */
a51 3
/* u_long	_randseed = 1; */


@


1.6
log
@Totally revamp the virtual device code.

Unbreak:
• floppy access (BIOS)
• hard disc access (BIOS)
• CD-ROM El Torito access (BIOS)
• cd9660, fat, ffs (filesystems)

Not tested:
• tftp, nfs (PXE, NET, filesystems)
• lmbmfs (lmbm)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/sparc/stand/common/promdev.c,v 1.5 2009/04/17 18:57:08 tg Exp $ */
d84 3
d188 2
d235 1
d238 1
a238 1
		bcopy(file_system_nfs, file_system, sizeof(struct fs_ops));
d244 1
a244 1
	} else {
d246 2
a247 1
		bcopy(file_system_ufs, file_system, sizeof(struct fs_ops));
d249 5
a253 2
		bcopy(&file_system_cd9660, file_system + 1, sizeof file_system[0]);
		nfsys = 2;
a254 1
#endif
@


1.5
log
@make fdboot smaller
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/sparc/stand/common/promdev.c,v 1.4 2009/02/01 16:12:31 tg Exp $ */
a102 2
int	ndevs = (sizeof(devsw)/sizeof(devsw[0]));

@


1.4
log
@switch to MirBSD style versions
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/arch/sparc/stand/common/promdev.c,v 1.3 2008/07/13 19:42:40 tg Exp $ */
d112 1
d114 1
d182 1
d184 1
d528 1
d577 1
a577 1

@


1.3
log
@like with i386, provide a 4.2FFS-only floppy boot loader, to make them fit
@
text
@d1 1
a1 1
/**	$MirOS$ */
d112 2
d179 2
@


1.2
log
@with virtue and a cross-developing environment,
make this almost usable (not tested the result)
@
text
@d1 1
d74 1
d77 1
d80 1
d83 1
d224 1
d233 1
d235 1
d239 1
d313 1
a313 1
	
d340 1
a340 1
#ifndef BOOTXX
d357 1
a357 1
#ifndef BOOTXX
d442 1
a442 1
 
d454 1
a454 1
                }       
d464 1
a464 1
 
d476 1
a476 1
 
d507 1
a507 1
 
d779 1
a779 1
	{ MAP_MBIO,      PG_VME16, 0xFFFF0000 }, 
@


1.1
log
@Initial revision
@
text
@d49 2
d73 4
d110 4
a113 1
	register char	*ap, *cp, *dp;
d119 1
d121 1
d180 1
a180 1
	int	error = 0, fd;
d778 1
a778 1
static prom_mapinfo_cnt = sizeof(prom_mapinfo) / sizeof(prom_mapinfo[0]);
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@
