head	1.20;
access;
symbols
	MIRBSD_10:1.3.0.4
	MIRBSD_10_BASE:1.3
	MIRBSD_9_BASE:1.3
	MIRBSD_8:1.3.0.2
	MIRBSD_8_BASE:1.3;
locks; strict;
comment	@ * @;


1.20
date	2011.01.03.19.00.17;	author tg;	state Exp;
branches;
next	1.19;
commitid	1004D221CD9561B78B4;

1.19
date	2011.01.03.18.38.00;	author tg;	state Exp;
branches;
next	1.18;
commitid	1004D22178E7AE9AE97;

1.18
date	2011.01.03.17.42.01;	author tg;	state Exp;
branches;
next	1.17;
commitid	1004D220A5A37AC4463;

1.17
date	2010.01.10.19.17.15;	author tg;	state Exp;
branches;
next	1.16;
commitid	1004B4A27CF5F44E8ED;

1.16
date	2010.01.10.17.47.52;	author tg;	state Exp;
branches;
next	1.15;
commitid	1004B4A12CD3855DD1B;

1.15
date	2009.03.13.20.40.58;	author tg;	state Exp;
branches;
next	1.14;
commitid	10049BAC4F11B1C6735;

1.14
date	2009.01.15.21.42.50;	author tg;	state Exp;
branches;
next	1.13;
commitid	100496FADE54811A35B;

1.13
date	2009.01.15.21.32.27;	author tg;	state Exp;
branches;
next	1.12;
commitid	100496FAB7505CEF8AC;

1.12
date	2009.01.03.12.43.05;	author tg;	state Exp;
branches;
next	1.11;
commitid	100495F5D6C613D50F5;

1.11
date	2008.12.28.21.25.12;	author tg;	state Exp;
branches;
next	1.10;
commitid	1004957EE7F2C32DD85;

1.10
date	2008.12.28.06.26.10;	author tg;	state Exp;
branches;
next	1.9;
commitid	10049571C0458E224FF;

1.9
date	2008.12.28.05.29.07;	author tg;	state Exp;
branches;
next	1.8;
commitid	10049570E9955828A99;

1.8
date	2008.12.28.05.18.59;	author tg;	state Exp;
branches;
next	1.7;
commitid	10049570C375CCF1E89;

1.7
date	2008.12.28.05.17.59;	author tg;	state Exp;
branches;
next	1.6;
commitid	10049570C1867F30FE9;

1.6
date	2008.12.28.05.17.16;	author tg;	state Exp;
branches;
next	1.5;
commitid	10049570BE53A7948FF;

1.5
date	2008.11.08.23.04.24;	author tg;	state Exp;
branches;
next	1.4;
commitid	10049161AB22DF5DFC5;

1.4
date	2008.09.06.22.21.04;	author tg;	state Exp;
branches;
next	1.3;
commitid	10048C3024808C8EDD3;

1.3
date	2005.12.17.05.46.26;	author tg;	state Exp;
branches;
next	1.2;
commitid	10043A3A3E65E20A413;

1.2
date	2005.08.07.15.50.46;	author tg;	state Exp;
branches;
next	1.1;
commitid	5fc542f62de76f57;

1.1
date	2005.08.07.15.37.42;	author tg;	state Exp;
branches;
next	;
commitid	14d842f62ad14cb0;


desc
@@


1.20
log
@__CRAZY
@
text
@/*-
 * Copyright (c) 2005, 2008, 2009, 2011
 *	Thorsten Glaser <tg@@mirbsd.org>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 */

#include <sys/param.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/slibkern.h>
#include <lib/libsa/stand.h>
#include <lib/libsa/fat.h>

__RCSID("$MirOS: src/sys/lib/libsa/fat.c,v 1.19 2011/01/03 18:38:00 tg Exp $");

#if BYTE_ORDER != LITTLE_ENDIAN
#define getlew(ofs) (buf[(ofs)] + ((unsigned)buf[(ofs) + 1] << 8))
#define getled(ofs) (getlew(ofs) + (getlew((ofs) + 2) << 16))
#else
#define getlew(ofs) (*((uint16_t *)(&buf[(ofs)])))
#define getled(ofs) (*((uint32_t *)(&buf[(ofs)])))
#endif

enum fat_type {
	FAT12, FAT16, FAT28
};

struct fat_file {
	struct open_file *open_file;	/* our "parent" structure */
	uint32_t rootofs;		/* root offset (FAT12/FAT16) */
	uint32_t invalc;		/* first invalid cluster no. */
	uint32_t firstds;		/* first data sector */
	char *fatbuf;			/* sector buffer (FAT) */
	uint32_t fatsec;		/* which sector is buffered */
	char *databuf;			/* cluster buffer (data) */
	uint32_t datasec;		/* which cluster is buffered */
	uint32_t nodecluster;		/* current node: cluster */
	uint32_t nodeseekp;		/* current node: file offset */
	uint32_t nodesize;		/* current node: file size */
	uint16_t ress;			/* BPB: reserved sectors */
	uint16_t bpc;			/* BPB: bytes per cluster */
	uint8_t nodetype;		/* 1=directory 2=file */
	enum fat_type type;		/* FAT12, FAT16 or FAT28 */
};

static int rd(struct open_file *, void *, daddr_t, size_t);
static uint32_t getfat(struct fat_file *, uint32_t);
static int search_dir(struct open_file *, char *);

static unsigned char fat_dirbuf[32];

#define fillbuf(ff)	rd((ff)->open_file, (ff)->databuf, \
			    ((ff)->datasec - 2) * ((ff)->bpc / 512) + \
			    (ff)->firstds, (ff)->bpc)
#define locase(c)	(((c) < 'A') || ((c) > 'Z') ? (c) : (c) - 'A' + 'a')

static int
rd(struct open_file *f, void *buf, daddr_t blk, size_t size)
{
	size_t buflen;
	int rv;

	twiddle();
	if ((rv = (f->f_dev->dv_strategy)(f->f_devdata, F_READ,
	    blk, size, buf, &buflen)))
		;
	else if (buflen != size)
		rv = EIO;
	return (rv);
}

static uint32_t
getfat(struct fat_file *ff, uint32_t entry)
{
	uint32_t fofs, fsec, secofs, rv = 0, b;
	char *buf;

	b = (ff->type == FAT12) ? 1024 : 512;
	if (ff->fatbuf == NULL) {
		ff->fatbuf = alloc(b);
		ff->fatsec = 0;
	}
	buf = ff->fatbuf;

	fofs = (ff->type == FAT16) ? (entry << 1) :
	    ((ff->type == FAT28) ? (entry << 2) :
	    (entry + (entry / 2)));
	fsec = ff->ress + (fofs / 512);
	secofs = fofs % 512;

	if (fsec != ff->fatsec) {
		if ((rv = rd(ff->open_file, buf, fsec, b))) {
			free(buf, b);
			ff->fatbuf = NULL;
			return (rv | 0x80000000);
		}
		ff->fatsec = fsec;
	}

	switch (ff->type) {
	case FAT28:
		rv = getled(secofs) & 0x0FFFFFFF;
		break;
	case FAT16:
		rv = getlew(secofs);
		break;
	case FAT12:
		rv = getlew(secofs);
		if (entry & 1)
			rv >>= 4;
		else
			rv &= 0x0FFF;
		break;
	}
	return (rv);
}

int
fat_open(char *path, struct open_file *f)
{
	struct fat_file *ff;
	unsigned char *buf;
	int rv;
	uint32_t spc, nfats, rootcnt, spd, spf, dblk;

	/* allocate fs specific data structure */
	ff = alloc(sizeof (struct fat_file));
	bzero(ff, sizeof (struct fat_file));
	f->f_fsdata = ff;
	ff->open_file = f;

	/* allocate space and read BPB */
	buf = alloc(512);
	if ((rv = rd(f, buf, 0, 512)))
		goto out;

	/* parse BPB */
	rv = EINVAL;
	if (((buf[0] != 0xEB) || (buf[2] != 0x90)) && (buf[0] != 0xE9))
		goto out;
	if ((buf[510] != 0x55) || (buf[511] != 0xAA))
		goto out;

	/* only 512 Bytes per sector for now */
	if (getlew(11) != 512)
		goto out;

	spc = buf[13];
	if (!spc || spc > 0x40 || (spc & (spc - 1)))
		/* 0, > 0x40, or not a power of two */
		goto out;
	ff->bpc = spc * 512;
	if ((ff->ress = getlew(14)) < 1)
		goto out;
	nfats = buf[16];
	rootcnt = (getlew(17) * 32 + 511) / 512;
	spd = getlew(19);
	spf = getlew(22);
	if (!spd)
		spd = getled(32);
	if (!spf)
		spf = getled(36);
	ff->rootofs = ff->ress + (nfats * spf);
	ff->firstds = ff->rootofs + rootcnt;
	dblk = (spd - ff->firstds) / spc;
	ff->type = (dblk < 4085) ? FAT12 : ((dblk < 65525) ? FAT16 : FAT28);
	switch (ff->type) {
	case FAT12:
		ff->invalc = 0x0FF7;
		break;
	case FAT16:
		ff->invalc = 0xFFF7;
		break;
	case FAT28:
		ff->invalc = 0x0FFFFFF7;
		if ((ff->rootofs = getled(44)) < 2)
			goto out;
		break;
	}

	ff->nodetype = 1;	/* 1 = directory, 2 = file */
	ff->nodecluster = 1;	/* 1 = root directory (special) */
	ff->nodeseekp = 0;
	if (ff->type == FAT28)
		/* we have a real root directory file */
		ff->nodecluster = ff->rootofs;
	else
		ff->nodesize = rootcnt * 512;

	while (*path) {
		char c, *cp, *npath;
		size_t len;

		/* remove extra separators */
		while (*path == '/')
			++path;
		if (*path == '\0')
			break;

		/* check that current node is a directory */
		if (ff->nodetype != 1) {
			rv = ENOTDIR;
			goto out;
		}

		/* get next component of path name */
		len = 0;
		cp = path;
		while (((c = *cp) != '\0') && (c != '/')) {
			if (++len > 14) {
				rv = ENOENT;
				goto out;
			}
			cp++;
		}
		if (cp == path + 1 && *path == '.') {
			path = cp;
			continue;
		}
		npath = cp;
		*cp = '\0';

		/* look up component in current directory */
		rv = search_dir(f, path);
		*cp = c;
		if (rv)
			goto out;
		path = npath;
	}

	/* found terminal component */
	rv = 0;
 out:
	free(buf, 512);
	if (rv) {
		if (ff->fatbuf)
			free(ff->fatbuf, (ff->type == FAT12) ? 1024 : 512);
		if (ff->databuf)
			free(ff->databuf, ff->bpc);
		free(ff, sizeof (struct fat_file));
	}
	return (rv);
}

int
fat_close(struct open_file *f)
{
	struct fat_file *ff;

	if (f == NULL)
		return (0);

	ff = f->f_fsdata;
	if (ff) {
		if (ff->fatbuf)
			free(ff->fatbuf, (ff->type == FAT12) ? 1024 : 512);
		if (ff->databuf)
			free(ff->databuf, ff->bpc);
		free(ff, sizeof (struct fat_file));
	}
	return (0);
}

int
fat_read(struct open_file *f, void *buf_, size_t size, size_t *resid)
{
	struct fat_file *ff = f->f_fsdata;
	int rv = 0, otmp, isroot = 0, blksiz = ff->bpc;
	size_t stmp;
	char *buf = buf_;

	if (!ff->databuf) {
		ff->databuf = alloc(ff->bpc);
		ff->datasec = 0;
	}

	if (ff->nodecluster == 1) {
		isroot = 1;
		blksiz = 512;
	}

	if (ff->datasec == 0) {
		int skip = (ff->nodeseekp / ff->bpc);
		ff->datasec = ff->nodecluster;
		if (ff->datasec == 1) {
			ff->datasec = ff->nodeseekp / 512 + ff->rootofs;
			if ((rv = rd(f, ff->databuf, ff->datasec, 512))) {
				ff->datasec = 0;
				goto out;
			}
			goto filled;
		}
		if ((ff->datasec == 0) || (ff->datasec >= ff->invalc)) {
 invclust:
			ff->datasec = rv = 0;
			goto out;
		}
		while (skip--) {
			ff->datasec = getfat(ff, ff->datasec);
			if ((ff->datasec == 0) || (ff->datasec >= ff->invalc))
				goto invclust;
		}
		if ((rv = fillbuf(ff))) {
 rderr:
			ff->datasec = 0;
			goto out;
		}
	}
 filled:

	while (size > 0) {
		/* don't read beyond EOF */
		if (ff->nodesize && (ff->nodeseekp >= ff->nodesize))
			break;

		otmp = ff->nodeseekp % blksiz;
		stmp = blksiz - otmp;
		if (ff->nodesize && (ff->nodesize - ff->nodeseekp) < stmp)
			stmp = ff->nodesize - ff->nodeseekp;
		if (stmp >= size)
			stmp = size;
		memmove(buf, ff->databuf + otmp, stmp);

		size -= stmp;
		buf += stmp;
		ff->nodeseekp += stmp;

		if (ff->nodeseekp % blksiz == 0) {
			if (isroot) {
				ff->datasec++;
				if ((rv = rd(f, ff->databuf, ff->datasec, 512)))
					goto rderr;
				goto refilled;
			}
			ff->datasec = getfat(ff, ff->datasec);
			if ((ff->datasec >= ff->invalc) || (rv = fillbuf(ff)))
				ff->datasec = 0;
			if (ff->datasec == 0 && size)
				goto out;
 refilled:		;
 		}
	}
 out:
	if (resid)
		*resid = size;
	return (rv);
}

int
fat_write(struct open_file *f __unused, void *buf __unused,
    size_t size __unused, size_t *resid __unused)
{
	return (EROFS);
}

off_t
fat_seek(struct open_file *f, off_t offset, int where)
{
	switch (where) {
	case SEEK_SET:
		((struct fat_file *)f->f_fsdata)->nodeseekp = offset;
		break;
	case SEEK_CUR:
		((struct fat_file *)f->f_fsdata)->nodeseekp += offset;
		break;
	case SEEK_END:
		((struct fat_file *)f->f_fsdata)->nodeseekp =
		    ((struct fat_file *)f->f_fsdata)->nodesize + offset;
		break;
	default:
		return (-1);
	}
	/* invalidate file data buffer */
	((struct fat_file *)f->f_fsdata)->datasec = 0;
	return (((struct fat_file *)f->f_fsdata)->nodeseekp);
}

int
fat_stat(struct open_file *f, struct stat *sb)
{
	/* quick and dirty */
	bzero(sb, sizeof (struct stat));
	sb->st_mode = (((struct fat_file *)f->f_fsdata)->nodetype == 1) ?
	    040555 : 0444;
	sb->st_size = ((struct fat_file *)f->f_fsdata)->nodesize;

	return (0);
}

int
fat_readdir(struct open_file *f, char *name)
{
	int rv;
	char ch, *cp;
	size_t sr;

	/* reset? */
	if (name == NULL) {
		fat_seek(f, 0, SEEK_SET);
		return (0);
	}

	*name = '\0';
 getrec:
	if ((rv = fat_read(f, fat_dirbuf, sizeof (fat_dirbuf), &sr)))
		return (rv);
	if (sr)
		return (EIO);
	/* end of directory? */
	if (fat_dirbuf[0] == 0)
		return (ENOENT);
	/* deleted file? */
	if (fat_dirbuf[0] == 0xE5)
		goto getrec;
	/* part of long filename? */
	if ((fat_dirbuf[11] & 0x3F) == 0x0F)
		goto getrec;
	/* volume label or FCFS symlink? */
	if ((fat_dirbuf[11] & 0xC8))
		goto getrec;
	/* okay, we have a directory or regular file */
	cp = fat_dirbuf;
	rv = 0;
	while (*cp != 0x20) {
		ch = *cp++;
		*name++ = locase(ch);
		if (++rv == 8)
			break;
	}
	cp = fat_dirbuf + 8;
	if (*cp != 0x20)
		*name++ = '.';
	rv = 0;
	while (*cp != 0x20) {
		ch = *cp++;
		*name++ = locase(ch);
		if (++rv == 3)
			break;
	}
	*name++ = '\0';

	return (0);
}

static int
search_dir(struct open_file *f, char *name)
{
	struct fat_file *ff = f->f_fsdata;
	int rv;
	char fn[14];
	char *buf = fat_dirbuf;

	if ((rv = fat_readdir(f, NULL)))
		return (rv);
	while ((rv = fat_readdir(f, fn)) == 0)
		if (!strcmp(fn, name)) {
			/* found a match, follow it */
			ff->nodecluster = getlew(20) << 16 | getlew(26);
			ff->nodesize = getled(28);
			if (ff->nodecluster < 2 && ff->nodesize != 0)
				return (ENOENT);
			ff->nodeseekp = 0;
			ff->nodetype = (buf[11] & 0x10) ? 1 : 2;
			/* invalidate file data buffer */
			ff->datasec = 0;
			return (0);
		}
	return (ENOENT);
}
@


1.19
log
@better way to check if something is a power of two: ((x) & ((x) - 1))
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/sys/lib/libsa/fat.c,v 1.18 2011/01/03 17:42:01 tg Exp $");
d279 1
a279 1
fat_read(struct open_file *f, void *buf, size_t size, size_t *resid)
d284 1
d364 2
a365 1
fat_write(struct open_file *f, void *buf, size_t size, size_t *resid)
@


1.18
log
@validate sectors-per-cluster as read from BPB, to protect against bogus
values that may even cause division by zero (thanks to Maciej Debski for
the bug report at Grml)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/sys/lib/libsa/fat.c,v 1.17 2010/01/10 19:17:15 tg Exp $");
d163 1
a163 1
	if (!spc || spc > 0x40 || spc != (1 << (ffs(spc) - 1)))
@


1.17
log
@correct errno value
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2008, 2009
d28 1
a28 1
__RCSID("$MirOS: src/sys/lib/libsa/fat.c,v 1.16 2010/01/10 17:47:52 tg Exp $");
d163 3
@


1.16
log
@even here, SEEK_END is size+ofs not size-ofs, says even stand.h
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/sys/lib/libsa/fat.c,v 1.15 2009/03/13 20:40:58 tg Exp $");
d82 1
a82 1
		rv = EINVAL;
@


1.15
log
@readdir reset did not invalidate data buffer; use seek for both

found during cd9660 rewrite-from-“scratch”
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/sys/lib/libsa/fat.c,v 1.14 2009/01/15 21:42:50 tg Exp $");
d377 1
a377 1
		    ((struct fat_file *)f->f_fsdata)->nodesize - offset;
@


1.14
log
@save on temporaries and some memset → bzero
(we can’t really kill all bzero calls anyway)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/sys/lib/libsa/fat.c,v 1.13 2009/01/15 21:32:27 tg Exp $");
d408 1
a408 1
		((struct fat_file *)f->f_fsdata)->nodeseekp = 0;
@


1.13
log
@I just realised readdir is supposed to return errnos, so be it. Tested.
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/sys/lib/libsa/fat.c,v 1.12 2009/01/03 12:43:05 tg Exp $");
d142 1
a142 1
	memset(ff, 0, sizeof (struct fat_file));
a367 2
	struct fat_file *ff = f->f_fsdata;

d370 1
a370 1
		ff->nodeseekp = offset;
d373 1
a373 1
		ff->nodeseekp += offset;
d376 2
a377 1
		ff->nodeseekp = ff->nodesize - offset;
d383 2
a384 2
	ff->datasec = 0;
	return (ff->nodeseekp);
a389 2
	struct fat_file *ff = f->f_fsdata;

d391 4
a394 3
	memset(sb, 0, sizeof (struct stat));
	sb->st_mode = (ff->nodetype == 1) ? 040555 : 0444;
	sb->st_size = ff->nodesize;
a401 1
	struct fat_file *ff = f->f_fsdata;
d408 1
a408 1
		ff->nodeseekp = 0;
@


1.12
log
@buf is always, so always free it
@
text
@d2 1
a2 1
 * Copyright (c) 2005, 2008
d28 1
a28 1
__RCSID("$MirOS: src/sys/lib/libsa/fat.c,v 1.11 2008/12/28 21:25:12 tg Exp $");
d420 1
a420 1
		return (-1);
d423 1
a423 1
		return (-1);
@


1.11
log
@• calculate the amount of data left we can serve correctly:
  either sectorsize-pointerInSector _or_ filesize-pointerInFile
  but not filesize-pointerInFile-pointerInSector
  (this went havoc at ofs 256 (secsize 512) of last root dir entry)
• abort correctly if the root directory is *full* (and we mean full)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/sys/lib/libsa/fat.c,v 1.10 2008/12/28 06:26:10 tg Exp $");
d245 1
a245 2
	if (buf)
		free(buf, 512);
@


1.10
log
@FAT28 fix (confirmed): since the root directory has no size, just
do the cluster chain end check for it, and assume full clusters
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/sys/lib/libsa/fat.c,v 1.9 2008/12/28 05:29:07 tg Exp $");
d328 1
a328 1
		stmp = blksiz;
a330 1
		stmp -= otmp;
d416 1
d423 1
a423 2
	if (fat_dirbuf[0] == 0) {
		*name = '\0';
a424 1
	}
@


1.9
log
@overhaul and re-enable this, as it’s at least usable in some cases
(FAT12, FAT28 need testing, and can you say spoofdisklabel?)
@
text
@d28 1
a28 1
__RCSID("$MirOS: src/share/misc/licence.template,v 1.28 2008/11/14 15:33:44 tg Rel $");
d328 4
a331 1
		stmp = MIN(blksiz, ff->nodesize - ff->nodeseekp) - otmp;
@


1.8
log
@if a directory is the root directory on first access, it will be it
on second access as well (the FAT28 case still needs to be tested,
but this is enough on a small FAt16 filesystem)
@
text
@a0 2
/* $MirOS: src/sys/lib/libsa/fat.c,v 1.7 2008/12/28 05:17:59 tg Exp $ */

d2 2
a3 9
 * Copyright (c) 2005
 *	Thorsten "mirabilos" Glaser <tg@@mirbsd.org>
 *
 * Licensee is hereby permitted to deal in this work without restric-
 * tion, including unlimited rights to use, publicly perform, modify,
 * merge, distribute, sell, give away or sublicence, provided all co-
 * pyright notices above, these terms and the disclaimer are retained
 * in all redistributions or reproduced in accompanying documentation
 * or other materials provided with binary redistributions.
d5 5
a9 3
 * All advertising materials mentioning features or use of this soft-
 * ware must display the following acknowledgement:
 *	This product includes material provided by Thorsten Glaser.
d11 8
a18 8
 * Licensor offers the work "AS IS" and WITHOUT WARRANTY of any kind,
 * express, or implied, to the maximum extent permitted by applicable
 * law, without malicious intent or gross negligence; in no event may
 * licensor, an author or contributor be held liable for any indirect
 * or other damage, or direct damage except proven a consequence of a
 * direct error of said person and intended use of this work, loss or
 * other issues arising in any way out of its use, even if advised of
 * the possibility of such damage or existence of a nontrivial bug.
d28 2
a62 2
static __inline int fillbuf(struct fat_file *);
static __inline unsigned char locase(unsigned char);
d66 5
d244 1
a244 1
out:
d305 1
a305 1
invclust:
d315 1
a315 1
rderr:
d320 1
a320 1
filled:
d328 1
a328 1
		stmp = blksiz - otmp;
d337 1
a337 1
		if ((blksiz - otmp) >= size) {
d345 1
a345 1
			if ((rv = fillbuf(ff))) {
d347 4
a350 5
				if (size)
					goto out;
			}
refilled:		;
		}
d352 1
a352 1
out:
d405 1
a405 1
	char *cp;
d414 1
a414 1
getrec:
d437 2
a438 1
		*name++ = locase(*cp++);
d447 2
a448 1
		*name++ = locase(*cp++);
a481 15

static __inline int
fillbuf(struct fat_file *ff)
{
	return (rd(ff->open_file, ff->databuf,
	    (ff->datasec - 2) * (ff->bpc / 512) + ff->firstds, ff->bpc));
}

static __inline unsigned char
locase(unsigned char c)
{
	if ((c < 'A') || (c > 'Z'))
		return (c);
	return (c - 'A' + 'a');
}
@


1.7
log
@aid in debugging, simplify
@
text
@d1 1
a1 1
/* $MirOS: src/sys/lib/libsa/fat.c,v 1.6 2008/12/28 05:17:16 tg Exp $ */
d290 5
a298 2
			isroot = 1;
			blksiz = 512;
@


1.6
log
@allow it to stat zero-size files and access a directory’s dot entry
@
text
@d1 1
a1 1
/* $MirOS: src/sys/lib/libsa/fat.c,v 1.5 2008/11/08 23:04:24 tg Exp $ */
d82 4
a85 4
		return (rv);
	if (buflen != size)
		return (EINVAL);
	return (0);
@


1.5
log
@more mass conversions, including ancient eMail addresses
@
text
@d1 1
a1 1
/* $MirOS: src/sys/lib/libsa/fat.c,v 1.4 2008/09/06 22:21:04 tg Exp $ */
d229 4
d469 2
a470 1
			if (ff->nodecluster < 2)
a472 1
			ff->nodesize = getled(28);
@


1.4
log
@move lib/libkern/libkern.h to sys/slibkern.h where it gets installed,
since other installed headers reference it (e.g. for building LKMs)
@
text
@d1 1
a1 1
/* $MirOS: src/sys/lib/libsa/fat.c,v 1.3 2005/12/17 05:46:26 tg Exp $ */
d5 1
a5 1
 *	Thorsten "mirabile" Glaser <tg@@66h.42h.de>
@


1.3
log
@big fat licence update (I left some which are bsiegert@@'s alone though)
also, remove licence boilerplate from some .h files who don't deserve it
and remove and add some advertising clauses because I say so
@
text
@d1 1
a1 1
/* $MirOS: src/sys/lib/libsa/fat.c,v 1.2 2005/08/07 15:50:46 tg Exp $ */
d31 1
a31 1
#include <lib/libkern/libkern.h>
@


1.2
log
@compile fixes
@
text
@d1 1
a1 1
/* $MirOS: src/sys/lib/libsa/fat.c,v 1.1 2005/08/07 15:37:42 tg Exp $ */
d14 12
a25 7
 * Licensor hereby provides this work "AS IS" and WITHOUT WARRANTY of
 * any kind, expressed or implied, to the maximum extent permitted by
 * applicable law, but with the warranty of being written without ma-
 * licious intent or gross negligence; in no event shall licensor, an
 * author or contributor be held liable for any damage, direct, indi-
 * rect or other, however caused, arising in any way out of the usage
 * of this work, even if advised of the possibility of such damage.
@


1.1
log
@add first draft of FCFS read-only driver for boot(8)
@
text
@d1 1
a1 1
/* $MirOS: src/share/misc/licence.template,v 1.2 2005/03/03 19:43:30 tg Rel $ */
d27 1
d43 1
a43 1
	struct open_file open_file;	/* our "parent" structure */
d64 1
d66 1
a66 1
static char fat_dirbuf[32];
d75 2
a76 2
	if (rv = (f->f_dev->dv_strategy)(f->f_devdata, F_READ,
	    blk, size, buf, &buflen))
d80 1
d86 1
a86 1
	uint32_t fofs, fsec, secofs, rv, b;
d103 1
a103 1
		if (rv = rd(ff->open_file, buf, fsec, b)) {
d133 1
a133 1
	char *buf;
d145 1
a145 1
	if (rv = rd(f, buf, 0, 512))
d173 1
a173 1
	dblk = (spd - firstds) / spc;
d218 2
a219 2
			if (++len > MAXNAMLEN) {
				rc = ENOENT;
d273 1
a273 1
	int rv, otmp, isroot = 0, blksiz = ff->bpc;
d288 1
a288 1
			if (rv = rd(f, ff->databuf, ff->datasec, 512)) {
d304 1
a304 1
		if (rv = fillbuf(ff)) {
d330 1
a330 1
				if (rv = rd(f, ff->databuf, ff->datasec, 512))
d335 1
a335 1
			if (rv = fillbuf(ff)) {
d340 1
a340 1
refilled:
d397 1
a397 1
	size_t *sr;
d406 1
a406 1
	if (rv = fat_read(f, fat_dirbuf, sizeof (fat_dirbuf)), &sr)
d428 1
a428 1
		*name++ = *cp++;
d437 1
a437 1
		*name++ = *cp++;
d454 1
a454 1
	if (rv = fat_readdir(f, NULL))
d457 1
a457 1
		if (!stricmp(fn, name)) {
d478 8
@

