head	1.6;
access;
symbols
	tg-beforemerge-ksrc10:1.1.1.1
	cvs-200808011000:1.1.1.1
	MIRBSD_10:1.4.0.4
	MIRBSD_10_BASE:1.4
	MIRBSD_9_BASE:1.4
	MIRBSD_8:1.4.0.2
	MIRBSD_8_BASE:1.4
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2008.09.06.22.21.04;	author tg;	state Exp;
branches;
next	1.5;
commitid	10048C3024808C8EDD3;

1.5
date	2008.08.01.11.25.03;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004892F2924667C00D;

1.4
date	2005.12.19.18.25.04;	author tg;	state Exp;
branches;
next	1.3;
commitid	10043A6FAFD3336FE80;

1.3
date	2005.11.23.21.55.22;	author tg;	state Exp;
branches;
next	1.2;
commitid	31c34384e5559fcb;

1.2
date	2005.03.06.21.28.08;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.28.59;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.28.59;	author tg;	state Exp;
branches;
next	;


desc
@@


1.6
log
@move lib/libkern/libkern.h to sys/slibkern.h where it gets installed,
since other installed headers reference it (e.g. for building LKMs)
@
text
@/*	$OpenBSD: tftp.c,v 1.2 2004/04/02 04:39:51 deraadt Exp $	*/
/*	$NetBSD: tftp.c,v 1.15 2003/08/18 15:45:29 dsl Exp $	 */

/*
 * Copyright (c) 1996
 *	Matthias Drochner.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Simple TFTP implementation for libsa.
 * Assumes:
 *  - socket descriptor (int) at open_file->f_devdata
 *  - server host IP in global servip
 * Restrictions:
 *  - read only
 *  - lseek only with SEEK_SET or SEEK_CUR
 *  - no big time differences between transfers (<tftp timeout)
 */

/*
 * XXX Does not currently implement:
 * XXX
 * XXX LIBSA_NO_FS_CLOSE
 * XXX LIBSA_NO_FS_SEEK
 * XXX LIBSA_NO_FS_WRITE
 * XXX LIBSA_NO_FS_SYMLINK (does this even make sense?)
 * XXX LIBSA_FS_SINGLECOMPONENT (does this even make sense?)
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/slibkern.h>
#include <netinet/in.h>
#include <netinet/udp.h>
#include <netinet/in_systm.h>

#include "stand.h"
#include "net.h"
#include "netif.h"

#include "tftp.h"

extern struct in_addr servip;

static int      tftpport = 2000;

#define RSPACE 520		/* max data packet, rounded up */

struct tftp_handle {
	struct iodesc  *iodesc;
	int             currblock;	/* contents of lastdata */
	int             islastblock;	/* flag */
	int             validsize;
	int             off;
	const char     *path;	/* saved for re-requests */
	struct {
		u_char header[HEADER_SIZE];
		struct tftphdr t;
		u_char space[RSPACE];
	} lastdata;
};

static const int tftperrors[8] = {
	0,			/* ??? */
	ENOENT,
	EPERM,
	ENOSPC,
	EINVAL,			/* ??? */
	EINVAL,			/* ??? */
	EEXIST,
	EINVAL			/* ??? */
};

ssize_t recvtftp(struct iodesc *, void *, size_t, time_t);
int tftp_makereq(struct tftp_handle *);
int tftp_getnextblock(struct tftp_handle *);
#ifndef TFTP_NOTERMINATE
void tftp_terminate(struct tftp_handle *);
#endif

ssize_t
recvtftp(struct iodesc *d, void *pkt, size_t len, time_t tleft)
{
	ssize_t n;
	struct tftphdr *t;

	errno = 0;

	n = readudp(d, pkt, len, tleft);

	if (n < 4)
		return -1;

	t = (struct tftphdr *) pkt;
	switch (ntohs(t->th_opcode)) {
	case DATA:
		if (htons(t->th_block) != d->xid) {
			/*
			 * Expected block?
			 */
			return -1;
		}
		if (d->xid == 1) {
			/*
			 * First data packet from new port.
			 */
			struct udphdr *uh;
			uh = (struct udphdr *) pkt - 1;
			d->destport = uh->uh_sport;
		} /* else check uh_sport has not changed??? */
		return (n - (t->th_data - (char *)t));
	case ERROR:
		if ((unsigned) ntohs(t->th_code) >= 8) {
			printf("illegal tftp error %d\n", ntohs(t->th_code));
			errno = EIO;
		} else {
#ifdef DEBUG
			printf("tftp-error %d\n", ntohs(t->th_code));
#endif
			errno = tftperrors[ntohs(t->th_code)];
		}
		return -1;
	default:
#ifdef DEBUG
		printf("tftp type %d not handled\n", ntohs(t->th_opcode));
#endif
		return -1;
	}
}

/* send request, expect first block (or error) */
int
tftp_makereq(struct tftp_handle *h)
{
	struct {
		u_char header[HEADER_SIZE];
		struct tftphdr  t;
		u_char space[FNAME_SIZE + 6];
	} wbuf;
	char           *wtail;
	int             l;
	ssize_t         res;
	struct tftphdr *t;

	bzero(&wbuf, sizeof(wbuf));

	wbuf.t.th_opcode = htons((u_short) RRQ);
	wtail = wbuf.t.th_stuff;
	l = strlen(h->path);
	bcopy(h->path, wtail, l + 1);
	wtail += l + 1;
	bcopy("octet", wtail, 6);
	wtail += 6;

	t = &h->lastdata.t;

	/* h->iodesc->myport = htons(--tftpport); */
	h->iodesc->myport = htons(tftpport + (getsecs() & 0x3ff));
	h->iodesc->destport = htons(IPPORT_TFTP);
	h->iodesc->xid = 1;	/* expected block */

	res = sendrecv(h->iodesc, sendudp, &wbuf.t, wtail - (char *) &wbuf.t,
	    recvtftp, t, sizeof(*t) + RSPACE);

	if (res == -1)
		return errno;

	h->currblock = 1;
	h->validsize = res;
	h->islastblock = 0;
	if (res < SEGSIZE)
		h->islastblock = 1;	/* very short file */
	return 0;
}

/* ack block, expect next */
int
tftp_getnextblock(struct tftp_handle *h)
{
	struct {
		u_char header[HEADER_SIZE];
		struct tftphdr t;
	} wbuf;
	char           *wtail;
	int             res;
	struct tftphdr *t;

	bzero(&wbuf, sizeof(wbuf));

	wbuf.t.th_opcode = htons((u_short) ACK);
	wbuf.t.th_block = htons((u_short) h->currblock);
	wtail = (char *) &wbuf.t.th_data;

	t = &h->lastdata.t;

	h->iodesc->xid = h->currblock + 1;	/* expected block */

	res = sendrecv(h->iodesc, sendudp, &wbuf.t, wtail - (char *) &wbuf.t,
	    recvtftp, t, sizeof(*t) + RSPACE);

	if (res == -1)		/* 0 is OK! */
		return errno;

	h->currblock++;
	h->validsize = res;
	if (res < SEGSIZE)
		h->islastblock = 1;	/* EOF */
	return 0;
}

#ifndef TFTP_NOTERMINATE
void
tftp_terminate(struct tftp_handle *h)
{
	struct {
		u_char header[HEADER_SIZE];
		struct tftphdr t;
	} wbuf;
	char           *wtail;

	bzero(&wbuf, sizeof(wbuf));

	if (h->islastblock) {
		wbuf.t.th_opcode = htons((u_short) ACK);
		wbuf.t.th_block = htons((u_short) h->currblock);
	} else {
		wbuf.t.th_opcode = htons((u_short) ERROR);
		wbuf.t.th_code = htons((u_short) ENOSPACE); /* ??? */
	}
	wtail = (char *) &wbuf.t.th_data;

	(void) sendudp(h->iodesc, &wbuf.t, wtail - (char *) &wbuf.t);
}
#endif

int
tftp_open(char *path, struct open_file *f)
{
	struct tftp_handle *tftpfile;
	struct iodesc  *io;
	int             res;

	tftpfile = (struct tftp_handle *) alloc(sizeof(*tftpfile));
	if (tftpfile == NULL)
		return ENOMEM;

	tftpfile->iodesc = io = socktodesc(*(int *) (f->f_devdata));
	io->destip = servip;
	tftpfile->off = 0;
	tftpfile->path = path;	/* XXXXXXX we hope it's static */

	res = tftp_makereq(tftpfile);

	if (res) {
		free(tftpfile, sizeof(*tftpfile));
		return res;
	}
	f->f_fsdata = (void *) tftpfile;
	return 0;
}

int
tftp_read(struct open_file *f, void *addr, size_t size, size_t *resid)
{
	struct tftp_handle *tftpfile;
#if !defined(LIBSA_NO_TWIDDLE)
	static int tc = 0;
#endif
	tftpfile = (struct tftp_handle *) f->f_fsdata;

	while (size > 0) {
		int needblock;
		size_t count;

		needblock = tftpfile->off / SEGSIZE + 1;

		if (tftpfile->currblock > needblock) {	/* seek backwards */
#ifndef TFTP_NOTERMINATE
			tftp_terminate(tftpfile);
#endif
			/* Don't bother to check retval: it worked for open() */
			tftp_makereq(tftpfile);
		}

		while (tftpfile->currblock < needblock) {
			int res;

#if !defined(LIBSA_NO_TWIDDLE)
			if ((tc++ % 16) == 0)
				twiddle();
#endif
			res = tftp_getnextblock(tftpfile);
			if (res) {	/* no answer */
#ifdef DEBUG
				printf("tftp: read error (block %d->%d)\n",
				    tftpfile->currblock, needblock);
#endif
				return res;
			}
			if (tftpfile->islastblock)
				break;
		}

		if (tftpfile->currblock == needblock) {
			size_t offinblock, inbuffer;

			offinblock = tftpfile->off % SEGSIZE;

			inbuffer = tftpfile->validsize - offinblock;
			if (inbuffer < 0) {
#ifdef DEBUG
				printf("tftp: invalid offset %d\n",
				    tftpfile->off);
#endif
				return EINVAL;
			}
			count = (size < inbuffer ? size : inbuffer);
			bcopy(tftpfile->lastdata.t.th_data + offinblock,
			    addr, count);

			addr = (caddr_t)addr + count;
			tftpfile->off += count;
			size -= count;

			if ((tftpfile->islastblock) && (count == inbuffer))
				break;	/* EOF */
		} else {
#ifdef DEBUG
			printf("tftp: block %d not found\n", needblock);
#endif
			return EINVAL;
		}

	}

	if (resid != NULL)
		*resid = size;
	return 0;
}

int
tftp_close(struct open_file *f)
{
	struct tftp_handle *tftpfile;
	tftpfile = (struct tftp_handle *) f->f_fsdata;

#ifdef TFTP_NOTERMINATE
	/* let it time out ... */
#else
	tftp_terminate(tftpfile);
#endif

	free(tftpfile, sizeof(*tftpfile));
	return 0;
}

int
tftp_write(struct open_file *f, void *start, size_t size, size_t *resid)
{
	return EROFS;
}

int
tftp_stat(struct open_file *f, struct stat *sb)
{
	struct tftp_handle *tftpfile;
	tftpfile = (struct tftp_handle *) f->f_fsdata;

	sb->st_mode = 0444;
	sb->st_nlink = 1;
	sb->st_uid = 0;
	sb->st_gid = 0;
	sb->st_size = -1;

	return 0;
}

off_t
tftp_seek(struct open_file *f, off_t offset, int where)
{
	struct tftp_handle *tftpfile;
	tftpfile = (struct tftp_handle *) f->f_fsdata;

	switch (where) {
	case SEEK_SET:
		tftpfile->off = offset;
		break;
	case SEEK_CUR:
		tftpfile->off += offset;
		break;
	default:
		errno = EOFFSET;
		return -1;
	}

	return (tftpfile->off);
}

/*
 * Not implemented.
 */
#ifndef NO_READDIR
int
tftp_readdir(struct open_file *f, char *name)
{
	return EROFS;
}
#endif
@


1.5
log
@merge and reduce diff to obsd
XXX not yet tested
@
text
@d52 1
a55 1
#include <lib/libkern/libkern.h>
@


1.4
log
@I broke pxeboot in commitid 31c34384e5559fcb with a typo/thinko
Unbreak, tested both uncompressed and compressed bsd.rd
@
text
@a0 1
/**	$MirOS: src/sys/lib/libsa/tftp.c,v 1.2 2005/03/06 21:28:08 tg Exp $	*/
d165 1
a165 1
	memset(&wbuf, 0, sizeof(wbuf));
d170 1
a170 1
	memmove(wtail, h->path, l + 1);
d172 1
a172 1
	memmove(wtail, "octet", 6);
d208 1
a208 1
	memset(&wbuf, 0, sizeof(wbuf));
d241 1
a241 1
	memset(&wbuf, 0, sizeof(wbuf));
d264 1
a264 1
	if (!tftpfile)
d338 2
a339 2
			memmove(addr,
			    tftpfile->lastdata.t.th_data + offinblock, count);
d356 1
a356 1
	if (resid)
@


1.3
log
@fix some more cases of NULL usage in boot loader
@
text
@d357 1
a357 1
	if (!resid)
@


1.2
log
@* merge src/sys/
  (at least the better part of it)
* revert IPv6 networking to OpenBSD, since
  I didn't get IPV4_MAPPED addresses working :(
@
text
@d1 1
a1 1
/**	$MirOS$	*/
d265 1
a265 1
	if (tftpfile == NULL)
d357 1
a357 1
	if (resid != NULL)
@


1.1
log
@Initial revision
@
text
@d1 1
d166 1
a166 1
	bzero(&wbuf, sizeof(wbuf));
d171 1
a171 1
	bcopy(h->path, wtail, l + 1);
d173 1
a173 1
	bcopy("octet", wtail, 6);
d209 1
a209 1
	bzero(&wbuf, sizeof(wbuf));
d242 1
a242 1
	bzero(&wbuf, sizeof(wbuf));
d339 2
a340 2
			bcopy(tftpfile->lastdata.t.th_data + offinblock,
			    addr, count);
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@
