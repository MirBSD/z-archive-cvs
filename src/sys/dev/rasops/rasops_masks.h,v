head	1.1;
branch	1.1.1;
access;
symbols
	tg-beforemerge-ksrc10:1.1.1.2
	MIRBSD_10:1.1.1.2.0.2
	MIRBSD_10_BASE:1.1.1.2
	cvs-200702062030:1.1.1.2
	MIRBSD_9_BASE:1.1.1.1
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2005.02.05.17.28.35;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.28.35;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.02.06.20.51.47;	author tg;	state Exp;
branches;
next	;
commitid	10045C8EA6658CBB47A;


desc
@@


1.1
log
@Initial revision
@
text
@/*	$OpenBSD: rasops_masks.h,v 1.1 2001/03/18 04:32:45 nate Exp $ */
/* 	$NetBSD: rasops_masks.h,v 1.5 2000/06/13 13:37:01 ad Exp $	*/

/*-
 * Copyright (c) 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Andrew Doran.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _RASOPS_MASKS_H_
#define _RASOPS_MASKS_H_ 1

#include <sys/types.h>
#include <machine/endian.h>

/*
 * Convenience macros. To get around the problem of dealing with properly
 * ordered bits on little-endian machines, we just convert everything to
 * big-endian and back again when we're done.
 *
 * MBL: move bits left
 * MBR: move bits right
 * MBE: make big-endian
 */
#if BYTE_ORDER == BIG_ENDIAN

#define MBL(x,y)	((y) > 31 ? 0 : (x) >> (y))
#define MBR(x,y)    	((y) > 31 ? 0 : (x) << (y))
#define MBE(x)		(x)

#else

#define MBL(x,y)    	((y) > 31 ? 0 : MBE(MBE(x) << (y)))
#define MBR(x,y)    	((y) > 31 ? 0 : MBE(MBE(x) >> (y)))
#define MBE(x)		( (((x) & 0x000000FFU) << 24) \
                        | (((x) & 0x0000FF00U) <<  8) \
                        | (((x) & 0x00FF0000U) >>  8) \
                        | (((x) & 0xFF000000U) >> 24) )
#endif

/*
 * Using GETBITS() and PUTBITS() inside a loop mightn't be such a good idea.
 * There's probably some CSE and strength-reduction that the compiler won't
 * even think about - really should have a few assumptions/separate cases.
 */

/* Get a number of bits ( <= 32 ) from *sp and store in dw */
#define GETBITS(sp, x, w, dw) do {					\
	dw = MBL(*(sp), (x));						\
	if (((x) + (w)) > 32)						\
		dw |= (MBR((sp)[1], 32 - (x))); 			\
} while(0);

/* Put a number of bits ( <= 32 ) from sw to *dp */
#define PUTBITS(sw, x, w, dp) do {					\
	int n = (x) + (w) - 32;						\
									\
	if (n <= 0) {							\
		n = rasops_pmask[x & 31][w & 31];			\
		*(dp) = (*(dp) & ~n) | (MBR(sw, x) & n);		\
	} else {							\
		*(dp) = (*(dp) & rasops_rmask[x]) | (MBR((sw), x));	\
		(dp)[1] = ((dp)[1] & rasops_rmask[n]) |			\
			(MBL(sw, 32-(x)) & rasops_lmask[n]);		\
	}								\
} while(0);

/* rasops_masks.c */
extern const int32_t	rasops_lmask[32+1];
extern const int32_t	rasops_rmask[32+1];
extern const int32_t	rasops_pmask[32][32];

#endif /* _RASOPS_MASKS_H_ */
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@import current wscons & friends code from OpenBSD
in the hope it will be useful
@
text
@d1 1
a1 1
/*	$OpenBSD: rasops_masks.h,v 1.3 2006/08/04 06:28:10 miod Exp $ */
d55 1
d59 1
a60 2
#if BYTE_ORDER == BIG_ENDIAN
#define MBE(x)		(x)
d62 7
a68 10
#define MBE(x) \
({ \
	u_int32_t tmp = (x); \
	tmp = ((tmp >>  1) & 0x55555555) | ((tmp <<  1) & 0xaaaaaaaa); \
	tmp = ((tmp >>  2) & 0x33333333) | ((tmp <<  2) & 0xcccccccc); \
	tmp = ((tmp >>  4) & 0x0f0f0f0f) | ((tmp <<  4) & 0xf0f0f0f0); \
	tmp = ((tmp >>  8) & 0x00ff00ff) | ((tmp <<  8) & 0xff00ff00); \
	tmp = ((tmp >> 16) & 0x0000ffff) | ((tmp << 16) & 0xffff0000); \
	tmp; \
})
a98 1
#if BYTE_ORDER == BIG_ENDIAN
a101 7
#define	rasops_masks_init()	do { } while (0)
#else
extern int32_t	rasops_lmask[32+1];
extern int32_t	rasops_rmask[32+1];
extern int32_t	rasops_pmask[32][32];
void	rasops_masks_init(void);
#endif
@

