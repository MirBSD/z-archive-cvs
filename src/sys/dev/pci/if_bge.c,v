head	1.7;
access;
symbols
	tg-beforemerge-ksrc10:1.1.1.1
	MIRBSD_10:1.3.0.2
	MIRBSD_10_BASE:1.3
	MIRBSD_9_BASE:1.2
	MIRBSD_8:1.2.0.2
	MIRBSD_8_BASE:1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2012.07.05.19.09.21;	author bsiegert;	state Exp;
branches;
next	1.6;
commitid	1004FF5E63B5EA71B9C;

1.6
date	2012.07.03.20.01.16;	author bsiegert;	state Exp;
branches;
next	1.5;
commitid	1004FF34F5E5219E8F1;

1.5
date	2011.11.11.21.25.41;	author bsiegert;	state Exp;
branches;
next	1.4;
commitid	1004EBD928805FCEF13;

1.4
date	2011.11.06.20.43.56;	author bsiegert;	state Exp;
branches;
next	1.3;
commitid	1004EB6F1A237DB1EFD;

1.3
date	2006.09.22.13.17.02;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004513E24C477152EB;

1.2
date	2005.03.06.21.27.47;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.28.21;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.28.21;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.11.06.20.33.55;	author bsiegert;	state Exp;
branches;
next	;
commitid	1004EB6EF3661C11CAB;


desc
@@


1.7
log
@Cherry-pick some revisions (marked on top of the files) to support the bge
card in one of my build boxes (a BCM5751). It actually works!
@
text
@/*	$OpenBSD: if_bge.c,v 1.27 2004/05/29 23:07:48 naddy Exp $	*/
/*
 * - additional incorporated revisions: 1.29, 1.34-1.36
 *
 * Copyright (c) 2001 Wind River Systems
 * Copyright (c) 1997, 1998, 1999, 2001
 *	Bill Paul <wpaul@@windriver.com>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: if_bge.c,v 1.25 2002/11/14 23:54:49 sam Exp $
 */

/*
 * Broadcom BCM570x family gigabit ethernet driver for FreeBSD.
 *
 * Written by Bill Paul <wpaul@@windriver.com>
 * Senior Engineer, Wind River Systems
 */

/*
 * The Broadcom BCM5700 is based on technology originally developed by
 * Alteon Networks as part of the Tigon I and Tigon II gigabit ethernet
 * MAC chips. The BCM5700, sometimes refered to as the Tigon III, has
 * two on-board MIPS R4000 CPUs and can have as much as 16MB of external
 * SSRAM. The BCM5700 supports TCP, UDP and IP checksum offload, jumbo
 * frames, highly configurable RX filtering, and 16 RX and TX queues
 * (which, along with RX filter rules, can be used for QOS applications).
 * Other features, such as TCP segmentation, may be available as part
 * of value-added firmware updates. Unlike the Tigon I and Tigon II,
 * firmware images can be stored in hardware and need not be compiled
 * into the driver.
 *
 * The BCM5700 supports the PCI v2.2 and PCI-X v1.0 standards, and will
 * function in a 32-bit/64-bit 33/66MHz bus, or a 64-bit/133MHz bus.
 *
 * The BCM5701 is a single-chip solution incorporating both the BCM5700
 * MAC and a BCM5401 10/100/1000 PHY. Unlike the BCM5700, the BCM5701
 * does not support external SSRAM.
 *
 * Broadcom also produces a variation of the BCM5700 under the "Altima"
 * brand name, which is functionally similar but lacks PCI-X support.
 *
 * Without external SSRAM, you can only have at most 4 TX rings,
 * and the use of the mini RX ring is disabled. This seems to imply
 * that these features are simply not available on the BCM5701. As a
 * result, this driver does not implement any support for the mini RX
 * ring.
 */

#include "bpfilter.h"
#include "vlan.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/socket.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#include <netinet/if_ether.h>
#endif

#if NVLAN > 0
#include <net/if_types.h>
#include <net/if_vlan_var.h>
#endif

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>
#include <dev/mii/miidevs.h>
#include <dev/mii/brgphyreg.h>

#include <dev/pci/if_bgereg.h>

/* #define BGE_CHECKSUM */

int bge_probe(struct device *, void *, void *);
void bge_attach(struct device *, struct device *, void *);
void bge_release_resources(struct bge_softc *);
void bge_txeof(struct bge_softc *);
void bge_rxeof(struct bge_softc *);

void bge_tick(void *);
void bge_stats_update(struct bge_softc *);
void bge_stats_update_regs(struct bge_softc *);
int bge_encap(struct bge_softc *, struct mbuf *, u_int32_t *);

int bge_intr(void *);
void bge_start(struct ifnet *);
int bge_ioctl(struct ifnet *, u_long, caddr_t);
void bge_init(void *);
void bge_stop(struct bge_softc *);
void bge_watchdog(struct ifnet *);
void bge_shutdown(void *);
int bge_ifmedia_upd(struct ifnet *);
void bge_ifmedia_sts(struct ifnet *, struct ifmediareq *);

u_int8_t bge_eeprom_getbyte(struct bge_softc *, int, u_int8_t *);
int bge_read_eeprom(struct bge_softc *, caddr_t, int, int);

void bge_setmulti(struct bge_softc *);

void bge_handle_events(struct bge_softc *);
int bge_alloc_jumbo_mem(struct bge_softc *);
void bge_free_jumbo_mem(struct bge_softc *);
void *bge_jalloc(struct bge_softc *);
void bge_jfree(caddr_t, u_int, void *);
int bge_newbuf_std(struct bge_softc *, int, struct mbuf *);
int bge_newbuf_jumbo(struct bge_softc *, int, struct mbuf *);
int bge_init_rx_ring_std(struct bge_softc *);
void bge_free_rx_ring_std(struct bge_softc *);
int bge_init_rx_ring_jumbo(struct bge_softc *);
void bge_free_rx_ring_jumbo(struct bge_softc *);
void bge_free_tx_ring(struct bge_softc *);
int bge_init_tx_ring(struct bge_softc *);

int bge_chipinit(struct bge_softc *);
int bge_blockinit(struct bge_softc *);

#ifdef notdef
u_int8_t bge_vpd_readbyte(struct bge_softc *, int);
void bge_vpd_read_res(struct bge_softc *, struct vpd_res *, int);
void bge_vpd_read(struct bge_softc *);
#endif

u_int32_t bge_readmem_ind(struct bge_softc *, int);
void bge_writemem_ind(struct bge_softc *, int, int);
#ifdef notdef
u_int32_t bge_readreg_ind(struct bge_softc *, int);
#endif
void bge_writereg_ind(struct bge_softc *, int, int);

int bge_miibus_readreg(struct device *, int, int);
void bge_miibus_writereg(struct device *, int, int, int);
void bge_miibus_statchg(struct device *);

void bge_reset(struct bge_softc *);

#define BGE_DEBUG
#ifdef BGE_DEBUG
#define DPRINTF(x)	if (bgedebug) printf x
#define DPRINTFN(n,x)	if (bgedebug >= (n)) printf x
int	bgedebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

/*
 * Various supported device vendors/types and their names. Note: the
 * spec seems to indicate that the hardware still has Alteon's vendor
 * ID burned into it, though it will always be overridden by the vendor
 * ID in the EEPROM. Just to be safe, we cover all possibilities.
 */
const struct pci_matchid bge_devices[] = {
	{ PCI_VENDOR_ALTEON, PCI_PRODUCT_ALTEON_BCM5700 },
	{ PCI_VENDOR_ALTEON, PCI_PRODUCT_ALTEON_BCM5701 },

	{ PCI_VENDOR_ALTIMA, PCI_PRODUCT_ALTIMA_AC1000 },
	{ PCI_VENDOR_ALTIMA, PCI_PRODUCT_ALTIMA_AC1001 },
	{ PCI_VENDOR_ALTIMA, PCI_PRODUCT_ALTIMA_AC9100 },

	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5700 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5701 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5702 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5702X },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5703 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5703X },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5704C },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5704S },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5705 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5705K },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5705M },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5705M_ALT },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5750 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5750M },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5751 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5782 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5788 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5901 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5901A2 },

	{ PCI_VENDOR_SCHNEIDERKOCH, PCI_PRODUCT_SCHNEIDERKOCH_SK9D21 },

	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C996 },
};

u_int32_t
bge_readmem_ind(sc, off)
	struct bge_softc *sc;
	int off;
{
	struct pci_attach_args	*pa = &(sc->bge_pa);

	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_MEMWIN_BASEADDR, off);
	return (pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_MEMWIN_DATA));
}

void
bge_writemem_ind(sc, off, val)
	struct bge_softc *sc;
	int off, val;
{
	struct pci_attach_args	*pa = &(sc->bge_pa);

	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_MEMWIN_BASEADDR, off);
	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_MEMWIN_DATA, val);
}

#ifdef notdef
u_int32_t
bge_readreg_ind(sc, off)
	struct bge_softc *sc;
	int off;
{
	struct pci_attach_args	*pa = &(sc->bge_pa);

	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_REG_BASEADDR, off);
	return(pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_REG_DATA));
}
#endif

void
bge_writereg_ind(sc, off, val)
	struct bge_softc *sc;
	int off, val;
{
	struct pci_attach_args	*pa = &(sc->bge_pa);

	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_REG_BASEADDR, off);
	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_REG_DATA, val);
}

#ifdef notdef
u_int8_t
bge_vpd_readbyte(sc, addr)
	struct bge_softc *sc;
	int addr;
{
	int i;
	u_int32_t val;
	struct pci_attach_args	*pa = &(sc->bge_pa);

	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_VPD_ADDR, addr);
	for (i = 0; i < BGE_TIMEOUT * 10; i++) {
		DELAY(10);
		if (pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_VPD_ADDR) &
		    BGE_VPD_FLAG)
			break;
	}

	if (i == BGE_TIMEOUT * 10) {
		printf("%s: VPD read timed out\n", sc->bge_dev.dv_xname);
		return(0);
	}

	val = pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_VPD_DATA);

	return((val >> ((addr % 4) * 8)) & 0xFF);
}

void
bge_vpd_read_res(sc, res, addr)
	struct bge_softc *sc;
	struct vpd_res *res;
	int addr;
{
	int i;
	u_int8_t *ptr;

	ptr = (u_int8_t *)res;
	for (i = 0; i < sizeof(struct vpd_res); i++)
		ptr[i] = bge_vpd_readbyte(sc, i + addr);
}

void
bge_vpd_read(sc)
	struct bge_softc *sc;
{
	int pos = 0, i;
	struct vpd_res res;

	if (sc->bge_vpd_prodname != NULL)
		free(sc->bge_vpd_prodname, M_DEVBUF);
	if (sc->bge_vpd_readonly != NULL)
		free(sc->bge_vpd_readonly, M_DEVBUF);
	sc->bge_vpd_prodname = NULL;
	sc->bge_vpd_readonly = NULL;

	bge_vpd_read_res(sc, &res, pos);

	if (res.vr_id != VPD_RES_ID) {
		printf("%s: bad VPD resource id: expected %x got %x\n",
			sc->bge_dev.dv_xname, VPD_RES_ID, res.vr_id);
		return;
	}

	pos += sizeof(res);
	sc->bge_vpd_prodname = malloc(res.vr_len + 1, M_DEVBUF, M_NOWAIT);
	if (sc->bge_vpd_prodname == NULL)
		panic("bge_vpd_read");
	for (i = 0; i < res.vr_len; i++)
		sc->bge_vpd_prodname[i] = bge_vpd_readbyte(sc, i + pos);
	sc->bge_vpd_prodname[i] = '\0';
	pos += i;

	bge_vpd_read_res(sc, &res, pos);

	if (res.vr_id != VPD_RES_READ) {
		printf("%s: bad VPD resource id: expected %x got %x\n",
		    sc->bge_dev.dv_xname, VPD_RES_READ, res.vr_id);
		return;
	}

	pos += sizeof(res);
	sc->bge_vpd_readonly = malloc(res.vr_len, M_DEVBUF, M_NOWAIT);
	if (sc->bge_vpd_readonly == NULL)
		panic("bge_vpd_read");
	for (i = 0; i < res.vr_len + 1; i++)
		sc->bge_vpd_readonly[i] = bge_vpd_readbyte(sc, i + pos);
}
#endif

/*
 * Read a byte of data stored in the EEPROM at address 'addr.' The
 * BCM570x supports both the traditional bitbang interface and an
 * auto access interface for reading the EEPROM. We use the auto
 * access method.
 */
u_int8_t
bge_eeprom_getbyte(sc, addr, dest)
	struct bge_softc *sc;
	int addr;
	u_int8_t *dest;
{
	int i;
	u_int32_t byte = 0;

	/*
	 * Enable use of auto EEPROM access so we can avoid
	 * having to use the bitbang method.
	 */
	BGE_SETBIT(sc, BGE_MISC_LOCAL_CTL, BGE_MLC_AUTO_EEPROM);

	/* Reset the EEPROM, load the clock period. */
	CSR_WRITE_4(sc, BGE_EE_ADDR,
	    BGE_EEADDR_RESET|BGE_EEHALFCLK(BGE_HALFCLK_384SCL));
	DELAY(20);

	/* Issue the read EEPROM command. */
	CSR_WRITE_4(sc, BGE_EE_ADDR, BGE_EE_READCMD | addr);

	/* Wait for completion */
	for(i = 0; i < BGE_TIMEOUT * 10; i++) {
		DELAY(10);
		if (CSR_READ_4(sc, BGE_EE_ADDR) & BGE_EEADDR_DONE)
			break;
	}

	if (i == BGE_TIMEOUT * 10) {
		printf("%s: eeprom read timed out\n", sc->bge_dev.dv_xname);
		return(0);
	}

	/* Get result. */
	byte = CSR_READ_4(sc, BGE_EE_DATA);

	*dest = (byte >> ((addr % 4) * 8)) & 0xFF;

	return(0);
}

/*
 * Read a sequence of bytes from the EEPROM.
 */
int
bge_read_eeprom(sc, dest, off, cnt)
	struct bge_softc *sc;
	caddr_t dest;
	int off;
	int cnt;
{
	int err = 0, i;
	u_int8_t byte = 0;

	for (i = 0; i < cnt; i++) {
		err = bge_eeprom_getbyte(sc, off + i, &byte);
		if (err)
			break;
		*(dest + i) = byte;
	}

	return(err ? 1 : 0);
}

int
bge_miibus_readreg(dev, phy, reg)
	struct device *dev;
	int phy, reg;
{
	struct bge_softc *sc = (struct bge_softc *)dev;
	u_int32_t val, autopoll;
	int i;

	/*
	 * Broadcom's own driver always assumes the internal
	 * PHY is at GMII address 1. On some chips, the PHY responds
	 * to accesses at all addresses, which could cause us to
	 * bogusly attach the PHY 32 times at probe type. Always
	 * restricting the lookup to address 1 is simpler than
	 * trying to figure out which chips revisions should be
	 * special-cased.
	 */
	if (phy != 1)
		return(0);

	/* Reading with autopolling on may trigger PCI errors */
	autopoll = CSR_READ_4(sc, BGE_MI_MODE);
	if (autopoll & BGE_MIMODE_AUTOPOLL) {
		BGE_CLRBIT(sc, BGE_MI_MODE, BGE_MIMODE_AUTOPOLL);
		DELAY(40);
	}

	CSR_WRITE_4(sc, BGE_MI_COMM, BGE_MICMD_READ|BGE_MICOMM_BUSY|
	    BGE_MIPHY(phy)|BGE_MIREG(reg));

	for (i = 0; i < BGE_TIMEOUT; i++) {
		val = CSR_READ_4(sc, BGE_MI_COMM);
		if (!(val & BGE_MICOMM_BUSY))
			break;
	}

	if (i == BGE_TIMEOUT) {
		printf("%s: PHY read timed out\n", sc->bge_dev.dv_xname);
		val = 0;
		goto done;
	}

	val = CSR_READ_4(sc, BGE_MI_COMM);

done:
	if (autopoll & BGE_MIMODE_AUTOPOLL) {
		BGE_SETBIT(sc, BGE_MI_MODE, BGE_MIMODE_AUTOPOLL);
		DELAY(40);
	}

	if (val & BGE_MICOMM_READFAIL)
		return(0);

	return(val & 0xFFFF);
}

void
bge_miibus_writereg(dev, phy, reg, val)
	struct device *dev;
	int phy, reg, val;
{
	struct bge_softc *sc = (struct bge_softc *)dev;
	u_int32_t autopoll;
	int i;

	/* Reading with autopolling on may trigger PCI errors */
	autopoll = CSR_READ_4(sc, BGE_MI_MODE);
	if (autopoll & BGE_MIMODE_AUTOPOLL) {
		BGE_CLRBIT(sc, BGE_MI_MODE, BGE_MIMODE_AUTOPOLL);
		DELAY(40);
	}

	CSR_WRITE_4(sc, BGE_MI_COMM, BGE_MICMD_WRITE|BGE_MICOMM_BUSY|
	    BGE_MIPHY(phy)|BGE_MIREG(reg)|val);

	for (i = 0; i < BGE_TIMEOUT; i++) {
		if (!(CSR_READ_4(sc, BGE_MI_COMM) & BGE_MICOMM_BUSY))
			break;
	}

	if (autopoll & BGE_MIMODE_AUTOPOLL) {
		BGE_SETBIT(sc, BGE_MI_MODE, BGE_MIMODE_AUTOPOLL);
		DELAY(40);
	}

	if (i == BGE_TIMEOUT) {
		printf("%s: PHY read timed out\n", sc->bge_dev.dv_xname);
	}
}

void
bge_miibus_statchg(dev)
	struct device *dev;
{
	struct bge_softc *sc = (struct bge_softc *)dev;
	struct mii_data *mii = &sc->bge_mii;

	BGE_CLRBIT(sc, BGE_MAC_MODE, BGE_MACMODE_PORTMODE);
	if (IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_T) {
		BGE_SETBIT(sc, BGE_MAC_MODE, BGE_PORTMODE_GMII);
	} else {
		BGE_SETBIT(sc, BGE_MAC_MODE, BGE_PORTMODE_MII);
	}

	if ((mii->mii_media_active & IFM_GMASK) == IFM_FDX) {
		BGE_CLRBIT(sc, BGE_MAC_MODE, BGE_MACMODE_HALF_DUPLEX);
	} else {
		BGE_SETBIT(sc, BGE_MAC_MODE, BGE_MACMODE_HALF_DUPLEX);
	}
}

/*
 * Handle events that have triggered interrupts.
 */
void
bge_handle_events(sc)
	struct bge_softc		*sc;
{

	return;
}

/*
 * Memory management for jumbo frames.
 */

int
bge_alloc_jumbo_mem(sc)
	struct bge_softc		*sc;
{
	caddr_t			ptr, kva;
	bus_dma_segment_t	seg;
	int		i, rseg;
	struct bge_jpool_entry   *entry;

	/* Grab a big chunk o' storage. */
	if (bus_dmamem_alloc(sc->bge_dmatag, BGE_JMEM, PAGE_SIZE, 0,
			     &seg, 1, &rseg, BUS_DMA_NOWAIT)) {
		printf("%s: can't alloc rx buffers\n", sc->bge_dev.dv_xname);
		return (ENOBUFS);
	}
	if (bus_dmamem_map(sc->bge_dmatag, &seg, rseg, BGE_JMEM, &kva,
			   BUS_DMA_NOWAIT)) {
		printf("%s: can't map dma buffers (%ld bytes)\n",
		    sc->bge_dev.dv_xname, BGE_JMEM);
		bus_dmamem_free(sc->bge_dmatag, &seg, rseg);
		return (ENOBUFS);
	}
	if (bus_dmamap_create(sc->bge_dmatag, BGE_JMEM, 1, BGE_JMEM, 0,
	    BUS_DMA_NOWAIT, &sc->bge_cdata.bge_rx_jumbo_map)) {
		printf("%s: can't create dma map\n", sc->bge_dev.dv_xname);
		bus_dmamem_unmap(sc->bge_dmatag, kva, BGE_JMEM);
		bus_dmamem_free(sc->bge_dmatag, &seg, rseg);
		return (ENOBUFS);
	}
	if (bus_dmamap_load(sc->bge_dmatag, sc->bge_cdata.bge_rx_jumbo_map,
			    kva, BGE_JMEM, NULL, BUS_DMA_NOWAIT)) {
		printf("%s: can't load dma map\n", sc->bge_dev.dv_xname);
		bus_dmamap_destroy(sc->bge_dmatag,
				   sc->bge_cdata.bge_rx_jumbo_map);
		bus_dmamem_unmap(sc->bge_dmatag, kva, BGE_JMEM);
		bus_dmamem_free(sc->bge_dmatag, &seg, rseg);
		return (ENOBUFS);
	}
	sc->bge_cdata.bge_jumbo_buf = (caddr_t)kva;
	DPRINTFN(1,("bge_jumbo_buf = 0x%08X\n", (unsigned int)
	    sc->bge_cdata.bge_jumbo_buf));

	LIST_INIT(&sc->bge_jfree_listhead);
	LIST_INIT(&sc->bge_jinuse_listhead);

	/*
	 * Now divide it up into 9K pieces and save the addresses
	 * in an array.
	 */
	ptr = sc->bge_cdata.bge_jumbo_buf;
	for (i = 0; i < BGE_JSLOTS; i++) {
		sc->bge_cdata.bge_jslots[i] = ptr;
		ptr += BGE_JLEN;
		entry = malloc(sizeof(struct bge_jpool_entry),
		    M_DEVBUF, M_NOWAIT);
		if (entry == NULL) {
			bus_dmamap_unload(sc->bge_dmatag,
					  sc->bge_cdata.bge_rx_jumbo_map);
			bus_dmamap_destroy(sc->bge_dmatag,
					   sc->bge_cdata.bge_rx_jumbo_map);
			bus_dmamem_unmap(sc->bge_dmatag, kva, BGE_JMEM);
			bus_dmamem_free(sc->bge_dmatag, &seg, rseg);
			sc->bge_cdata.bge_jumbo_buf = NULL;
			printf("%s: no memory for jumbo buffer queue!\n",
			    sc->bge_dev.dv_xname);
			return(ENOBUFS);
		}
		entry->slot = i;
		LIST_INSERT_HEAD(&sc->bge_jfree_listhead,
				 entry, jpool_entries);
	}

	return(0);
}

/*
 * Allocate a jumbo buffer.
 */
void *
bge_jalloc(sc)
	struct bge_softc		*sc;
{
	struct bge_jpool_entry   *entry;

	entry = LIST_FIRST(&sc->bge_jfree_listhead);

	if (entry == NULL) {
		printf("%s: no free jumbo buffers\n", sc->bge_dev.dv_xname);
		return(NULL);
	}

	LIST_REMOVE(entry, jpool_entries);
	LIST_INSERT_HEAD(&sc->bge_jinuse_listhead, entry, jpool_entries);
	return(sc->bge_cdata.bge_jslots[entry->slot]);
}

/*
 * Release a jumbo buffer.
 */
void
bge_jfree(buf, size, arg)
	caddr_t		buf;
	u_int		size;
	void		*arg;
{
	struct bge_jpool_entry *entry;
	struct bge_softc *sc;
	int i;

	/* Extract the softc struct pointer. */
	sc = (struct bge_softc *)arg;

	if (sc == NULL)
		panic("bge_jfree: can't find softc pointer!");

	/* calculate the slot this buffer belongs to */

	i = ((vaddr_t)buf
	     - (vaddr_t)sc->bge_cdata.bge_jumbo_buf) / BGE_JLEN;

	if ((i < 0) || (i >= BGE_JSLOTS))
		panic("bge_jfree: asked to free buffer that we don't manage!");

	entry = LIST_FIRST(&sc->bge_jinuse_listhead);
	if (entry == NULL)
		panic("bge_jfree: buffer not in use!");
	entry->slot = i;
	LIST_REMOVE(entry, jpool_entries);
	LIST_INSERT_HEAD(&sc->bge_jfree_listhead, entry, jpool_entries);
}


/*
 * Intialize a standard receive ring descriptor.
 */
int
bge_newbuf_std(sc, i, m)
	struct bge_softc	*sc;
	int			i;
	struct mbuf		*m;
{
	struct mbuf		*m_new = NULL;
	struct bge_rx_bd	*r;
	bus_dmamap_t		rxmap = sc->bge_cdata.bge_rx_std_map[i];

	if (m == NULL) {
		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL) {
			return(ENOBUFS);
		}

		MCLGET(m_new, M_DONTWAIT);
		if (!(m_new->m_flags & M_EXT)) {
			m_freem(m_new);
			return(ENOBUFS);
		}
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
	} else {
		m_new = m;
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
		m_new->m_data = m_new->m_ext.ext_buf;
	}

	if (bus_dmamap_load_mbuf(sc->bge_dmatag, rxmap, m_new, BUS_DMA_NOWAIT))
		return(ENOBUFS);

	if (!sc->bge_rx_alignment_bug)
		m_adj(m_new, ETHER_ALIGN);
	sc->bge_cdata.bge_rx_std_chain[i] = m_new;
	r = &sc->bge_rdata->bge_rx_std_ring[i];
	BGE_HOSTADDR(r->bge_addr, rxmap->dm_segs[0].ds_addr +
	    (sc->bge_rx_alignment_bug ? 0 : ETHER_ALIGN));
	r->bge_flags = BGE_RXBDFLAG_END;
	r->bge_len = m_new->m_len;
	r->bge_idx = i;

	return(0);
}

/*
 * Initialize a jumbo receive ring descriptor. This allocates
 * a jumbo buffer from the pool managed internally by the driver.
 */
int
bge_newbuf_jumbo(sc, i, m)
	struct bge_softc *sc;
	int i;
	struct mbuf *m;
{
	struct mbuf *m_new = NULL;
	struct bge_rx_bd *r;

	if (m == NULL) {
		caddr_t			*buf = NULL;

		/* Allocate the mbuf. */
		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL) {
			return(ENOBUFS);
		}

		/* Allocate the jumbo buffer */
		buf = bge_jalloc(sc);
		if (buf == NULL) {
			m_freem(m_new);
			return(ENOBUFS);
		}

		/* Attach the buffer to the mbuf. */
		m_new->m_len = m_new->m_pkthdr.len = BGE_JUMBO_FRAMELEN;
		MEXTADD(m_new, buf, BGE_JUMBO_FRAMELEN, 0, bge_jfree, sc);
	} else {
		m_new = m;
		m_new->m_data = m_new->m_ext.ext_buf;
		m_new->m_ext.ext_size = BGE_JUMBO_FRAMELEN;
	}

	if (!sc->bge_rx_alignment_bug)
		m_adj(m_new, ETHER_ALIGN);
	/* Set up the descriptor. */
	r = &sc->bge_rdata->bge_rx_jumbo_ring[i];
	sc->bge_cdata.bge_rx_jumbo_chain[i] = m_new;
	BGE_HOSTADDR(r->bge_addr, BGE_JUMBO_DMA_ADDR(sc, m_new) +
	    (sc->bge_rx_alignment_bug ? 0 : ETHER_ALIGN));
	r->bge_flags = BGE_RXBDFLAG_END|BGE_RXBDFLAG_JUMBO_RING;
	r->bge_len = m_new->m_len;
	r->bge_idx = i;

	return(0);
}

/*
 * The standard receive ring has 512 entries in it. At 2K per mbuf cluster,
 * that's 1MB or memory, which is a lot. For now, we fill only the first
 * 256 ring entries and hope that our CPU is fast enough to keep up with
 * the NIC.
 */
int
bge_init_rx_ring_std(sc)
	struct bge_softc *sc;
{
	int i;

	for (i = 0; i < BGE_STD_RX_RING_CNT; i++) {
		if (bus_dmamap_create(sc->bge_dmatag, MCLBYTES, 1, MCLBYTES,
		    0, BUS_DMA_NOWAIT, &sc->bge_cdata.bge_rx_std_map[i]))
			return(ENOBUFS);
	}

	for (i = 0; i < BGE_SSLOTS; i++) {
		if (bge_newbuf_std(sc, i, NULL) == ENOBUFS)
			return(ENOBUFS);
	}

	sc->bge_std = i - 1;
	CSR_WRITE_4(sc, BGE_MBX_RX_STD_PROD_LO, sc->bge_std);

	return(0);
}

void
bge_free_rx_ring_std(sc)
	struct bge_softc *sc;
{
	int i;

	for (i = 0; i < BGE_STD_RX_RING_CNT; i++) {
		if (sc->bge_cdata.bge_rx_std_chain[i] != NULL) {
			m_freem(sc->bge_cdata.bge_rx_std_chain[i]);
			sc->bge_cdata.bge_rx_std_chain[i] = NULL;
			bus_dmamap_unload(sc->bge_dmatag,
					  sc->bge_cdata.bge_rx_std_map[i]);
		}
		bzero((char *)&sc->bge_rdata->bge_rx_std_ring[i],
		    sizeof(struct bge_rx_bd));
	}
}

int
bge_init_rx_ring_jumbo(sc)
	struct bge_softc *sc;
{
	int i;
	struct bge_rcb *rcb;

	for (i = 0; i < BGE_JUMBO_RX_RING_CNT; i++) {
		if (bge_newbuf_jumbo(sc, i, NULL) == ENOBUFS)
			return(ENOBUFS);
	};

	sc->bge_jumbo = i - 1;

	rcb = &sc->bge_rdata->bge_info.bge_jumbo_rx_rcb;
	rcb->bge_maxlen_flags = BGE_RCB_MAXLEN_FLAGS(0, 0);
	CSR_WRITE_4(sc, BGE_RX_JUMBO_RCB_MAXLEN_FLAGS, rcb->bge_maxlen_flags);

	CSR_WRITE_4(sc, BGE_MBX_RX_JUMBO_PROD_LO, sc->bge_jumbo);

	return(0);
}

void
bge_free_rx_ring_jumbo(sc)
	struct bge_softc *sc;
{
	int i;

	for (i = 0; i < BGE_JUMBO_RX_RING_CNT; i++) {
		if (sc->bge_cdata.bge_rx_jumbo_chain[i] != NULL) {
			m_freem(sc->bge_cdata.bge_rx_jumbo_chain[i]);
			sc->bge_cdata.bge_rx_jumbo_chain[i] = NULL;
		}
		bzero((char *)&sc->bge_rdata->bge_rx_jumbo_ring[i],
		    sizeof(struct bge_rx_bd));
	}
}

void
bge_free_tx_ring(sc)
	struct bge_softc *sc;
{
	int i;

	if (sc->bge_rdata->bge_tx_ring == NULL)
		return;

	for (i = 0; i < BGE_TX_RING_CNT; i++) {
		if (sc->bge_cdata.bge_tx_chain[i] != NULL) {
			m_freem(sc->bge_cdata.bge_tx_chain[i]);
			sc->bge_cdata.bge_tx_chain[i] = NULL;
			bus_dmamap_unload(sc->bge_dmatag,
					  sc->bge_cdata.bge_tx_map[i]);
		}
		bzero((char *)&sc->bge_rdata->bge_tx_ring[i],
		    sizeof(struct bge_tx_bd));
	}
}

int
bge_init_tx_ring(sc)
	struct bge_softc *sc;
{
	int i;

	sc->bge_txcnt = 0;
	sc->bge_tx_saved_considx = 0;

	CSR_WRITE_4(sc, BGE_MBX_TX_HOST_PROD0_LO, 0);
	/* 5700 b2 errata */
	if (sc->bge_chiprev == BGE_CHIPREV_5700_BX)
		CSR_WRITE_4(sc, BGE_MBX_TX_HOST_PROD0_LO, 0);

	CSR_WRITE_4(sc, BGE_MBX_TX_NIC_PROD0_LO, 0);
	/* 5700 b2 errata */
	if (sc->bge_chiprev == BGE_CHIPREV_5700_BX)
		CSR_WRITE_4(sc, BGE_MBX_TX_NIC_PROD0_LO, 0);

	for (i = 0; i < BGE_TX_RING_CNT; i++) {
		if (bus_dmamap_create(sc->bge_dmatag, MCLBYTES, BGE_NTXSEG,
		    MCLBYTES, 0, BUS_DMA_NOWAIT, &sc->bge_cdata.bge_tx_map[i]))
			return(ENOBUFS);
	}

	return(0);
}

void
bge_setmulti(sc)
	struct bge_softc *sc;
{
	struct arpcom		*ac = &sc->arpcom;
	struct ifnet		*ifp = &ac->ac_if;
	struct ether_multi	*enm;
	struct ether_multistep  step;
	u_int32_t		hashes[4] = { 0, 0, 0, 0 };
	u_int32_t		h;
	int			i;

	/* First, zot all the existing filters. */
	for (i = 0; i < 4; i++)
		CSR_WRITE_4(sc, BGE_MAR0 + (i * 4), 0);

	/* Now program new ones. */
allmulti:
	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
		for (i = 0; i < 4; i++)
			CSR_WRITE_4(sc, BGE_MAR0 + (i * 4), 0xFFFFFFFF);
		return;
	}

	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			ifp->if_flags |= IFF_ALLMULTI;
			goto allmulti;
		}
		h = ether_crc32_le(enm->enm_addrlo, ETHER_ADDR_LEN) & 0x7F;
		hashes[(h & 0x60) >> 5] |= 1 << (h & 0x1F);
		ETHER_NEXT_MULTI(step, enm);
	}

	for (i = 0; i < 4; i++)
		CSR_WRITE_4(sc, BGE_MAR0 + (i * 4), hashes[i]);
}

/*
 * Do endian, PCI and DMA initialization. Also check the on-board ROM
 * self-test results.
 */
int
bge_chipinit(sc)
	struct bge_softc *sc;
{
	struct pci_attach_args	*pa = &(sc->bge_pa);
	u_int32_t dma_rw_ctl;
	int i;

#ifdef BGE_CHECKSUM
	sc->arpcom.ac_if.if_capabilities =
	  IFCAP_CSUM_IPv4 | IFCAP_CSUM_TCPv4 | IFCAP_CSUM_UDPv4;
#endif

	/* Set endianness before we access any non-PCI registers. */
#if BYTE_ORDER == BIG_ENDIAN
	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_MISC_CTL,
	    BGE_BIGENDIAN_INIT);
#else
	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_MISC_CTL,
	    BGE_LITTLEENDIAN_INIT);
#endif

	/*
	 * Check the 'ROM failed' bit on the RX CPU to see if
	 * self-tests passed.
	 */
	if (CSR_READ_4(sc, BGE_RXCPU_MODE) & BGE_RXCPUMODE_ROMFAIL) {
		printf("%s: RX CPU self-diagnostics failed!\n",
		    sc->bge_dev.dv_xname);
		return(ENODEV);
	}

	/* Clear the MAC control register */
	CSR_WRITE_4(sc, BGE_MAC_MODE, 0);

	/*
	 * Clear the MAC statistics block in the NIC's
	 * internal memory.
	 */
	for (i = BGE_STATS_BLOCK;
	    i < BGE_STATS_BLOCK_END + 1; i += sizeof(u_int32_t))
		BGE_MEMWIN_WRITE(pa->pa_pc, pa->pa_tag, i, 0);

	for (i = BGE_STATUS_BLOCK;
	    i < BGE_STATUS_BLOCK_END + 1; i += sizeof(u_int32_t))
		BGE_MEMWIN_WRITE(pa->pa_pc, pa->pa_tag, i, 0);

	/* Set up the PCI DMA control register. */
	if (sc->bge_pcie) {
		dma_rw_ctl = BGE_PCI_READ_CMD | BGE_PCI_WRITE_CMD |
		    (0xf << BGE_PCIDMARWCTL_RD_WAT_SHIFT) |
		    (0x2 << BGE_PCIDMARWCTL_WR_WAT_SHIFT);
	} else if (pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_PCISTATE) &
	    BGE_PCISTATE_PCI_BUSMODE) {
		/* Conventional PCI bus */
		dma_rw_ctl = BGE_PCI_READ_CMD | BGE_PCI_WRITE_CMD |
		    (0x7 << BGE_PCIDMARWCTL_RD_WAT_SHIFT) |
		    (0x7 << BGE_PCIDMARWCTL_WR_WAT_SHIFT) |
		    (0x0f);
	} else {
		/* PCI-X bus */
		/*
		 * The 5704 uses a different encoding of read/write
		 * watermarks.
		 */
		if (BGE_ASICREV(sc->bge_asicrev) == BGE_ASICREV_BCM5704)
			dma_rw_ctl = BGE_PCI_READ_CMD|BGE_PCI_WRITE_CMD |
			    (0x7 << BGE_PCIDMARWCTL_RD_WAT_SHIFT) |
			    (0x3 << BGE_PCIDMARWCTL_WR_WAT_SHIFT);
		else
			dma_rw_ctl = BGE_PCI_READ_CMD|BGE_PCI_WRITE_CMD |
			    (0x3 << BGE_PCIDMARWCTL_RD_WAT_SHIFT) |
			    (0x3 << BGE_PCIDMARWCTL_WR_WAT_SHIFT) |
			    (0x0F);

		/*
		 * 5703 and 5704 need ONEDMA_AT_ONCE as a workaround
		 * for hardware bugs.
		 */
		if (sc->bge_asicrev == BGE_ASICREV_BCM5703 ||
		    sc->bge_asicrev == BGE_ASICREV_BCM5704) {
			u_int32_t tmp;

			tmp = CSR_READ_4(sc, BGE_PCI_CLKCTL) & 0x1f;
			if (tmp == 0x6 || tmp == 0x7)
				dma_rw_ctl |= BGE_PCIDMARWCTL_ONEDMA_ATONCE;
		}
 	}
 
	if (sc->bge_asicrev == BGE_ASICREV_BCM5703 ||
	    sc->bge_asicrev == BGE_ASICREV_BCM5704 ||
	    sc->bge_asicrev == BGE_ASICREV_BCM5705 ||
	    sc->bge_asicrev == BGE_ASICREV_BCM5750)
		dma_rw_ctl &= ~BGE_PCIDMARWCTL_MINDMA;

	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_DMA_RW_CTL, dma_rw_ctl);

	/*
	 * Set up general mode register.
	 */
#ifndef BGE_CHECKSUM
	CSR_WRITE_4(sc, BGE_MODE_CTL, BGE_MODECTL_WORDSWAP_NONFRAME|
		    BGE_MODECTL_BYTESWAP_DATA|BGE_MODECTL_WORDSWAP_DATA|
		    BGE_MODECTL_MAC_ATTN_INTR|BGE_MODECTL_HOST_SEND_BDS|
		    BGE_MODECTL_TX_NO_PHDR_CSUM|BGE_MODECTL_RX_NO_PHDR_CSUM);
#else
	CSR_WRITE_4(sc, BGE_MODE_CTL, BGE_MODECTL_WORDSWAP_NONFRAME|
		    BGE_MODECTL_BYTESWAP_DATA|BGE_MODECTL_WORDSWAP_DATA|
		    BGE_MODECTL_MAC_ATTN_INTR|BGE_MODECTL_HOST_SEND_BDS);
#endif

	/*
	 * Disable memory write invalidate.  Apparently it is not supported
	 * properly by these devices.
	 */
	PCI_CLRBIT(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
	    PCI_COMMAND_INVALIDATE_ENABLE);

#ifdef __brokenalpha__
	/*
	 * Must insure that we do not cross an 8K (bytes) boundary
	 * for DMA reads.  Our highest limit is 1K bytes.  This is a
	 * restriction on some ALPHA platforms with early revision
	 * 21174 PCI chipsets, such as the AlphaPC 164lx
	 */
	PCI_SETBIT(pa->pa_pc, pa->pa_tag, BGE_PCI_DMA_RW_CTL,
	    BGE_PCI_READ_BNDRY_1024);
#endif

	/* Set the timer prescaler (always 66MHz) */
	CSR_WRITE_4(sc, BGE_MISC_CFG, 65 << 1/*BGE_32BITTIME_66MHZ*/);

	return(0);
}

int
bge_blockinit(sc)
	struct bge_softc *sc;
{
	struct bge_rcb		*rcb;
	vaddr_t			rcb_addr;
	int			i;

	/*
	 * Initialize the memory window pointer register so that
	 * we can access the first 32K of internal NIC RAM. This will
	 * allow us to set up the TX send ring RCBs and the RX return
	 * ring RCBs, plus other things which live in NIC memory.
	 */
	CSR_WRITE_4(sc, BGE_PCI_MEMWIN_BASEADDR, 0);

	/* Note: the BCM5704 has a smaller bmuf space than the other chips */

	if (sc->bge_asicrev != BGE_ASICREV_BCM5705 &&
	    sc->bge_asicrev != BGE_ASICREV_BCM5750) {
		/* Configure mbuf memory pool */
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_BASEADDR,
		    (sc->bge_extram) ? BGE_EXT_SSRAM : BGE_BUFFPOOL_1);
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_LEN,
		    (sc->bge_asicrev == BGE_ASICREV_BCM5704) ? 0x10000:0x18000);
 
		/* Configure DMA resource pool */
		CSR_WRITE_4(sc, BGE_BMAN_DMA_DESCPOOL_BASEADDR,
		    BGE_DMA_DESCRIPTORS);
		CSR_WRITE_4(sc, BGE_BMAN_DMA_DESCPOOL_LEN, 0x2000);
	}

	/* Configure mbuf pool watermarks */
	if (sc->bge_asicrev == BGE_ASICREV_BCM5705 ||
	    sc->bge_asicrev == BGE_ASICREV_BCM5750) {
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_READDMA_LOWAT, 0x0);
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_MACRX_LOWAT, 0x10);
	} else {
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_READDMA_LOWAT, 0x50);
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_MACRX_LOWAT, 0x20);
	}
	CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_HIWAT, 0x60);

	/* Configure DMA resource watermarks */
	CSR_WRITE_4(sc, BGE_BMAN_DMA_DESCPOOL_LOWAT, 5);
	CSR_WRITE_4(sc, BGE_BMAN_DMA_DESCPOOL_HIWAT, 10);

	/* Enable buffer manager */
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705 &&
	    sc->bge_asicrev != BGE_ASICREV_BCM5750) {
		CSR_WRITE_4(sc, BGE_BMAN_MODE,
		    BGE_BMANMODE_ENABLE|BGE_BMANMODE_LOMBUF_ATTN);

		/* Poll for buffer manager start indication */
		for (i = 0; i < BGE_TIMEOUT; i++) {
			if (CSR_READ_4(sc, BGE_BMAN_MODE) & BGE_BMANMODE_ENABLE)
				break;
			DELAY(10);
		}

		if (i == BGE_TIMEOUT) {
			printf("%s: buffer manager failed to start\n",
			    sc->bge_dev.dv_xname);
			return(ENXIO);
		}
	}

	/* Enable flow-through queues */
	CSR_WRITE_4(sc, BGE_FTQ_RESET, 0xFFFFFFFF);
	CSR_WRITE_4(sc, BGE_FTQ_RESET, 0);

	/* Wait until queue initialization is complete */
	for (i = 0; i < BGE_TIMEOUT; i++) {
		if (CSR_READ_4(sc, BGE_FTQ_RESET) == 0)
			break;
		DELAY(10);
	}

	if (i == BGE_TIMEOUT) {
		printf("%s: flow-through queue init failed\n",
		    sc->bge_dev.dv_xname);
		return(ENXIO);
	}

	/* Initialize the standard RX ring control block */
	rcb = &sc->bge_rdata->bge_info.bge_std_rx_rcb;
	BGE_HOSTADDR(rcb->bge_hostaddr, BGE_RING_DMA_ADDR(sc, bge_rx_std_ring));
	if (sc->bge_asicrev == BGE_ASICREV_BCM5705 ||
	    sc->bge_asicrev == BGE_ASICREV_BCM5750)
		rcb->bge_maxlen_flags = BGE_RCB_MAXLEN_FLAGS(512, 0);
	else
		rcb->bge_maxlen_flags =
		    BGE_RCB_MAXLEN_FLAGS(BGE_MAX_FRAMELEN, 0);
	if (sc->bge_extram)
		rcb->bge_nicaddr = BGE_EXT_STD_RX_RINGS;
	else
		rcb->bge_nicaddr = BGE_STD_RX_RINGS;
	CSR_WRITE_4(sc, BGE_RX_STD_RCB_HADDR_HI, rcb->bge_hostaddr.bge_addr_hi);
	CSR_WRITE_4(sc, BGE_RX_STD_RCB_HADDR_LO, rcb->bge_hostaddr.bge_addr_lo);
	CSR_WRITE_4(sc, BGE_RX_STD_RCB_MAXLEN_FLAGS, rcb->bge_maxlen_flags);
	CSR_WRITE_4(sc, BGE_RX_STD_RCB_NICADDR, rcb->bge_nicaddr);

	/*
	 * Initialize the jumbo RX ring control block
	 * We set the 'ring disabled' bit in the flags
	 * field until we're actually ready to start
	 * using this ring (i.e. once we set the MTU
	 * high enough to require it).
	 */
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705 &&
	    sc->bge_asicrev != BGE_ASICREV_BCM5750) {
		rcb = &sc->bge_rdata->bge_info.bge_jumbo_rx_rcb;
		BGE_HOSTADDR(rcb->bge_hostaddr,
		    BGE_RING_DMA_ADDR(sc, bge_rx_jumbo_ring));
		rcb->bge_maxlen_flags =
		    BGE_RCB_MAXLEN_FLAGS(BGE_MAX_FRAMELEN,
		        BGE_RCB_FLAG_RING_DISABLED);
		if (sc->bge_extram)
			rcb->bge_nicaddr = BGE_EXT_JUMBO_RX_RINGS;
		else
			rcb->bge_nicaddr = BGE_JUMBO_RX_RINGS;

		CSR_WRITE_4(sc, BGE_RX_JUMBO_RCB_HADDR_HI,
		    rcb->bge_hostaddr.bge_addr_hi);
		CSR_WRITE_4(sc, BGE_RX_JUMBO_RCB_HADDR_LO,
		    rcb->bge_hostaddr.bge_addr_lo);
		CSR_WRITE_4(sc, BGE_RX_JUMBO_RCB_MAXLEN_FLAGS,
		    rcb->bge_maxlen_flags);
		CSR_WRITE_4(sc, BGE_RX_JUMBO_RCB_NICADDR,
		    rcb->bge_nicaddr);

		/* Set up dummy disabled mini ring RCB */
		rcb = &sc->bge_rdata->bge_info.bge_mini_rx_rcb;
		rcb->bge_maxlen_flags =
		    BGE_RCB_MAXLEN_FLAGS(0, BGE_RCB_FLAG_RING_DISABLED);
		CSR_WRITE_4(sc, BGE_RX_MINI_RCB_MAXLEN_FLAGS,
		    rcb->bge_maxlen_flags);
	}

	/*
	 * Set the BD ring replentish thresholds. The recommended
	 * values are 1/8th the number of descriptors allocated to
	 * each ring.
	 */
	CSR_WRITE_4(sc, BGE_RBDI_STD_REPL_THRESH, BGE_STD_RX_RING_CNT/8);
	CSR_WRITE_4(sc, BGE_RBDI_JUMBO_REPL_THRESH, BGE_JUMBO_RX_RING_CNT/8);

	/*
	 * Disable all unused send rings by setting the 'ring disabled'
	 * bit in the flags field of all the TX send ring control blocks.
	 * These are located in NIC memory.
	 */
	rcb_addr = BGE_MEMWIN_START + BGE_SEND_RING_RCB;
	for (i = 0; i < BGE_TX_RINGS_EXTSSRAM_MAX; i++) {
		RCB_WRITE_4(sc, rcb_addr, bge_maxlen_flags,
		    BGE_RCB_MAXLEN_FLAGS(0, BGE_RCB_FLAG_RING_DISABLED));
		RCB_WRITE_4(sc, rcb_addr, bge_nicaddr, 0);
		rcb_addr += sizeof(struct bge_rcb);
	}

	/* Configure TX RCB 0 (we use only the first ring) */
	rcb_addr = BGE_MEMWIN_START + BGE_SEND_RING_RCB;
	RCB_WRITE_4(sc, rcb_addr, bge_hostaddr.bge_addr_hi, 0);
	RCB_WRITE_4(sc, rcb_addr, bge_hostaddr.bge_addr_lo,
		    BGE_RING_DMA_ADDR(sc, bge_tx_ring));
	RCB_WRITE_4(sc, rcb_addr, bge_nicaddr,
		    BGE_NIC_TXRING_ADDR(0, BGE_TX_RING_CNT));
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705 &&
	    sc->bge_asicrev != BGE_ASICREV_BCM5750)
		RCB_WRITE_4(sc, rcb_addr, bge_maxlen_flags,
		    BGE_RCB_MAXLEN_FLAGS(BGE_TX_RING_CNT, 0));

	/* Disable all unused RX return rings */
	rcb_addr = BGE_MEMWIN_START + BGE_RX_RETURN_RING_RCB;
	for (i = 0; i < BGE_RX_RINGS_MAX; i++) {
		RCB_WRITE_4(sc, rcb_addr, bge_hostaddr.bge_addr_hi, 0);
		RCB_WRITE_4(sc, rcb_addr, bge_hostaddr.bge_addr_lo, 0);
		RCB_WRITE_4(sc, rcb_addr, bge_maxlen_flags,
		    BGE_RCB_MAXLEN_FLAGS(sc->bge_return_ring_cnt,
			BGE_RCB_FLAG_RING_DISABLED));
		RCB_WRITE_4(sc, rcb_addr, bge_nicaddr, 0);
		CSR_WRITE_4(sc, BGE_MBX_RX_CONS0_LO +
		    (i * (sizeof(u_int64_t))), 0);
		rcb_addr += sizeof(struct bge_rcb);
	}

	/* Initialize RX ring indexes */
	CSR_WRITE_4(sc, BGE_MBX_RX_STD_PROD_LO, 0);
	CSR_WRITE_4(sc, BGE_MBX_RX_JUMBO_PROD_LO, 0);
	CSR_WRITE_4(sc, BGE_MBX_RX_MINI_PROD_LO, 0);

	/*
	 * Set up RX return ring 0
	 * Note that the NIC address for RX return rings is 0x00000000.
	 * The return rings live entirely within the host, so the
	 * nicaddr field in the RCB isn't used.
	 */
	rcb_addr = BGE_MEMWIN_START + BGE_RX_RETURN_RING_RCB;
	RCB_WRITE_4(sc, rcb_addr, bge_hostaddr.bge_addr_hi, 0);
	RCB_WRITE_4(sc, rcb_addr, bge_hostaddr.bge_addr_lo,
		    BGE_RING_DMA_ADDR(sc, bge_rx_return_ring));
	RCB_WRITE_4(sc, rcb_addr, bge_nicaddr, 0x00000000);
	RCB_WRITE_4(sc, rcb_addr, bge_maxlen_flags,
	    BGE_RCB_MAXLEN_FLAGS(sc->bge_return_ring_cnt, 0));

	/* Set random backoff seed for TX */
	CSR_WRITE_4(sc, BGE_TX_RANDOM_BACKOFF,
	    sc->arpcom.ac_enaddr[0] + sc->arpcom.ac_enaddr[1] +
	    sc->arpcom.ac_enaddr[2] + sc->arpcom.ac_enaddr[3] +
	    sc->arpcom.ac_enaddr[4] + sc->arpcom.ac_enaddr[5] +
	    BGE_TX_BACKOFF_SEED_MASK);

	/* Set inter-packet gap */
	CSR_WRITE_4(sc, BGE_TX_LENGTHS, 0x2620);

	/*
	 * Specify which ring to use for packets that don't match
	 * any RX rules.
	 */
	CSR_WRITE_4(sc, BGE_RX_RULES_CFG, 0x08);

	/*
	 * Configure number of RX lists. One interrupt distribution
	 * list, sixteen active lists, one bad frames class.
	 */
	CSR_WRITE_4(sc, BGE_RXLP_CFG, 0x181);

	/* Inialize RX list placement stats mask. */
	CSR_WRITE_4(sc, BGE_RXLP_STATS_ENABLE_MASK, 0x007FFFFF);
	CSR_WRITE_4(sc, BGE_RXLP_STATS_CTL, 0x1);

	/* Disable host coalescing until we get it set up */
	CSR_WRITE_4(sc, BGE_HCC_MODE, 0x00000000);

	/* Poll to make sure it's shut down. */
	for (i = 0; i < BGE_TIMEOUT; i++) {
		if (!(CSR_READ_4(sc, BGE_HCC_MODE) & BGE_HCCMODE_ENABLE))
			break;
		DELAY(10);
	}

	if (i == BGE_TIMEOUT) {
		printf("%s: host coalescing engine failed to idle\n",
		    sc->bge_dev.dv_xname);
		return(ENXIO);
	}

	/* Set up host coalescing defaults */
	CSR_WRITE_4(sc, BGE_HCC_RX_COAL_TICKS, sc->bge_rx_coal_ticks);
	CSR_WRITE_4(sc, BGE_HCC_TX_COAL_TICKS, sc->bge_tx_coal_ticks);
	CSR_WRITE_4(sc, BGE_HCC_RX_MAX_COAL_BDS, sc->bge_rx_max_coal_bds);
	CSR_WRITE_4(sc, BGE_HCC_TX_MAX_COAL_BDS, sc->bge_tx_max_coal_bds);
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705 &&
	    sc->bge_asicrev != BGE_ASICREV_BCM5750) {
		CSR_WRITE_4(sc, BGE_HCC_RX_COAL_TICKS_INT, 0);
		CSR_WRITE_4(sc, BGE_HCC_TX_COAL_TICKS_INT, 0);
	}
	CSR_WRITE_4(sc, BGE_HCC_RX_MAX_COAL_BDS_INT, 0);
	CSR_WRITE_4(sc, BGE_HCC_TX_MAX_COAL_BDS_INT, 0);

	/* Set up address of statistics block */
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705 &&
	    sc->bge_asicrev != BGE_ASICREV_BCM5750) {
		CSR_WRITE_4(sc, BGE_HCC_STATS_ADDR_HI, 0);
		CSR_WRITE_4(sc, BGE_HCC_STATS_ADDR_LO,
			    BGE_RING_DMA_ADDR(sc, bge_info.bge_stats));

		CSR_WRITE_4(sc, BGE_HCC_STATS_BASEADDR, BGE_STATS_BLOCK);
		CSR_WRITE_4(sc, BGE_HCC_STATUSBLK_BASEADDR, BGE_STATUS_BLOCK);
		CSR_WRITE_4(sc, BGE_HCC_STATS_TICKS, sc->bge_stat_ticks);
	}

	/* Set up address of status block */
	CSR_WRITE_4(sc, BGE_HCC_STATUSBLK_ADDR_HI, 0);
	CSR_WRITE_4(sc, BGE_HCC_STATUSBLK_ADDR_LO,
		    BGE_RING_DMA_ADDR(sc, bge_status_block));

	sc->bge_rdata->bge_status_block.bge_idx[0].bge_rx_prod_idx = 0;
	sc->bge_rdata->bge_status_block.bge_idx[0].bge_tx_cons_idx = 0;

	/* Turn on host coalescing state machine */
	CSR_WRITE_4(sc, BGE_HCC_MODE, BGE_HCCMODE_ENABLE);

	/* Turn on RX BD completion state machine and enable attentions */
	CSR_WRITE_4(sc, BGE_RBDC_MODE,
	    BGE_RBDCMODE_ENABLE|BGE_RBDCMODE_ATTN);

	/* Turn on RX list placement state machine */
	CSR_WRITE_4(sc, BGE_RXLP_MODE, BGE_RXLPMODE_ENABLE);

	/* Turn on RX list selector state machine. */
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705 &&
	    sc->bge_asicrev != BGE_ASICREV_BCM5750)
		CSR_WRITE_4(sc, BGE_RXLS_MODE, BGE_RXLSMODE_ENABLE);

	/* Turn on DMA, clear stats */
	CSR_WRITE_4(sc, BGE_MAC_MODE, BGE_MACMODE_TXDMA_ENB|
	    BGE_MACMODE_RXDMA_ENB|BGE_MACMODE_RX_STATS_CLEAR|
	    BGE_MACMODE_TX_STATS_CLEAR|BGE_MACMODE_RX_STATS_ENB|
	    BGE_MACMODE_TX_STATS_ENB|BGE_MACMODE_FRMHDR_DMA_ENB|
	    (sc->bge_tbi ? BGE_PORTMODE_TBI : BGE_PORTMODE_MII));

	/* Set misc. local control, enable interrupts on attentions */
	CSR_WRITE_4(sc, BGE_MISC_LOCAL_CTL, BGE_MLC_INTR_ONATTN);

#ifdef notdef
	/* Assert GPIO pins for PHY reset */
	BGE_SETBIT(sc, BGE_MISC_LOCAL_CTL, BGE_MLC_MISCIO_OUT0|
	    BGE_MLC_MISCIO_OUT1|BGE_MLC_MISCIO_OUT2);
	BGE_SETBIT(sc, BGE_MISC_LOCAL_CTL, BGE_MLC_MISCIO_OUTEN0|
	    BGE_MLC_MISCIO_OUTEN1|BGE_MLC_MISCIO_OUTEN2);
#endif

	/* Turn on DMA completion state machine */
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705 &&
	    sc->bge_asicrev != BGE_ASICREV_BCM5750)
		CSR_WRITE_4(sc, BGE_DMAC_MODE, BGE_DMACMODE_ENABLE);

	/* Turn on write DMA state machine */
	CSR_WRITE_4(sc, BGE_WDMA_MODE,
	    BGE_WDMAMODE_ENABLE|BGE_WDMAMODE_ALL_ATTNS);

	/* Turn on read DMA state machine */
	CSR_WRITE_4(sc, BGE_RDMA_MODE,
	    BGE_RDMAMODE_ENABLE|BGE_RDMAMODE_ALL_ATTNS);

	/* Turn on RX data completion state machine */
	CSR_WRITE_4(sc, BGE_RDC_MODE, BGE_RDCMODE_ENABLE);

	/* Turn on RX BD initiator state machine */
	CSR_WRITE_4(sc, BGE_RBDI_MODE, BGE_RBDIMODE_ENABLE);

	/* Turn on RX data and RX BD initiator state machine */
	CSR_WRITE_4(sc, BGE_RDBDI_MODE, BGE_RDBDIMODE_ENABLE);

	/* Turn on Mbuf cluster free state machine */
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705 &&
	    sc->bge_asicrev != BGE_ASICREV_BCM5750)
		CSR_WRITE_4(sc, BGE_MBCF_MODE, BGE_MBCFMODE_ENABLE);

	/* Turn on send BD completion state machine */
	CSR_WRITE_4(sc, BGE_SBDC_MODE, BGE_SBDCMODE_ENABLE);

	/* Turn on send data completion state machine */
	CSR_WRITE_4(sc, BGE_SDC_MODE, BGE_SDCMODE_ENABLE);

	/* Turn on send data initiator state machine */
	CSR_WRITE_4(sc, BGE_SDI_MODE, BGE_SDIMODE_ENABLE);

	/* Turn on send BD initiator state machine */
	CSR_WRITE_4(sc, BGE_SBDI_MODE, BGE_SBDIMODE_ENABLE);

	/* Turn on send BD selector state machine */
	CSR_WRITE_4(sc, BGE_SRS_MODE, BGE_SRSMODE_ENABLE);

	CSR_WRITE_4(sc, BGE_SDI_STATS_ENABLE_MASK, 0x007FFFFF);
	CSR_WRITE_4(sc, BGE_SDI_STATS_CTL,
	    BGE_SDISTATSCTL_ENABLE|BGE_SDISTATSCTL_FASTER);

	/* ack/clear link change events */
	CSR_WRITE_4(sc, BGE_MAC_STS, BGE_MACSTAT_SYNC_CHANGED|
	    BGE_MACSTAT_CFG_CHANGED|BGE_MACSTAT_MI_COMPLETE|
	    BGE_MACSTAT_LINK_CHANGED);

	/* Enable PHY auto polling (for MII/GMII only) */
	if (sc->bge_tbi) {
		CSR_WRITE_4(sc, BGE_MI_STS, BGE_MISTS_LINK);
 	} else {
		BGE_SETBIT(sc, BGE_MI_MODE, BGE_MIMODE_AUTOPOLL|10<<16);
		if (sc->bge_asicrev == BGE_ASICREV_BCM5700)
			CSR_WRITE_4(sc, BGE_MAC_EVT_ENB,
			    BGE_EVTENB_MI_INTERRUPT);
	}

	/* Enable link state change attentions. */
	BGE_SETBIT(sc, BGE_MAC_EVT_ENB, BGE_EVTENB_LINK_CHANGED);

	return(0);
}

/*
 * Probe for a Broadcom chip. Check the PCI vendor and device IDs
 * against our list and return its name if we find a match. Note
 * that since the Broadcom controller contains VPD support, we
 * can get the device name string from the controller itself instead
 * of the compiled-in string. This is a little slow, but it guarantees
 * we'll always announce the right product name.
 */
int
bge_probe(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
{
	return (pci_matchbyid((struct pci_attach_args *)aux, bge_devices,
	    sizeof(bge_devices)/sizeof(bge_devices[0])));
}

void
bge_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct bge_softc	*sc = (struct bge_softc *)self;
	struct pci_attach_args	*pa = aux;
	pci_chipset_tag_t	pc = pa->pa_pc;
	pci_intr_handle_t	ih;
	const char		*intrstr = NULL;
	bus_addr_t		iobase;
	bus_size_t		iosize;
	bus_dma_segment_t	seg;
	int			s, rseg;
	u_int32_t		hwcfg = 0;
	u_int32_t		mac_addr = 0;
	u_int32_t		command;
	struct ifnet		*ifp;
	int			error = 0;
	caddr_t			kva;

	s = splimp();

	sc->bge_pa = *pa;

	/*
	 * Map control/status registers.
	 */
	DPRINTFN(5, ("Map control/status regs\n"));
	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	command |= PCI_COMMAND_MEM_ENABLE | PCI_COMMAND_MASTER_ENABLE;
	pci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);
	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);

	if (!(command & PCI_COMMAND_MEM_ENABLE)) {
		printf("%s: failed to enable memory mapping!\n",
		    sc->bge_dev.dv_xname);
		error = ENXIO;
		goto fail;
	}

	DPRINTFN(5, ("pci_mem_find\n"));
	if (pci_mem_find(pc, pa->pa_tag, BGE_PCI_BAR0, &iobase,
			 &iosize, NULL)) {
		printf(": can't find mem space\n");
		goto fail;
	}

	DPRINTFN(5, ("bus_space_map\n"));
	if (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->bge_bhandle)) {
		printf(": can't map mem space\n");
		goto fail;
	}

	sc->bge_btag = pa->pa_memt;

	DPRINTFN(5, ("pci_intr_map\n"));
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		goto fail;
	}

	DPRINTFN(5, ("pci_intr_string\n"));
	intrstr = pci_intr_string(pc, ih);

	DPRINTFN(5, ("pci_intr_establish\n"));
	sc->bge_intrhand = pci_intr_establish(pc, ih, IPL_NET, bge_intr, sc,
	    sc->bge_dev.dv_xname);

	if (sc->bge_intrhand == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		goto fail;
	}
	printf(": %s", intrstr);

	/* Save ASIC rev. */

	sc->bge_chipid =
            pci_conf_read(pc, pa->pa_tag, BGE_PCI_MISC_CTL) &
            BGE_PCIMISCCTL_ASICREV;
        sc->bge_asicrev = BGE_ASICREV(sc->bge_chipid);
        sc->bge_chiprev = BGE_CHIPREV(sc->bge_chipid);

	/*
	 * XXX: Broadcom Linux driver.  Not in specs or eratta.
	 * PCI-Express?
	 */
	if (sc->bge_asicrev == BGE_ASICREV_BCM5750) {
		u_int32_t v;

		v = pci_conf_read(pc, pa->pa_tag, BGE_PCI_MSI_CAPID);
		if (((v >> 8) & 0xff) == BGE_PCIE_CAPID_REG) {
			v = pci_conf_read(pc, pa->pa_tag, BGE_PCIE_CAPID_REG);
			if ((v & 0xff) == BGE_PCIE_CAPID)
				sc->bge_pcie = 1;
		}
	}

	/* Try to reset the chip. */
	DPRINTFN(5, ("bge_reset\n"));
	bge_reset(sc);

	if (bge_chipinit(sc)) {
		printf("%s: chip initialization failed\n",
		    sc->bge_dev.dv_xname);
		bge_release_resources(sc);
		error = ENXIO;
		goto fail;
	}

	/*
	 * Get station address from the EEPROM.
	 */
	mac_addr = bge_readmem_ind(sc, 0x0c14);
	if ((mac_addr >> 16) == 0x484b) {
		sc->arpcom.ac_enaddr[0] = (u_char)(mac_addr >> 8);
		sc->arpcom.ac_enaddr[1] = (u_char)mac_addr;
		mac_addr = bge_readmem_ind(sc, 0x0c18);
		sc->arpcom.ac_enaddr[2] = (u_char)(mac_addr >> 24);
		sc->arpcom.ac_enaddr[3] = (u_char)(mac_addr >> 16);
		sc->arpcom.ac_enaddr[4] = (u_char)(mac_addr >> 8);
		sc->arpcom.ac_enaddr[5] = (u_char)mac_addr;
	} else if (bge_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,
	    BGE_EE_MAC_OFFSET + 2, ETHER_ADDR_LEN)) {
		printf("%s: failed to read station address\n", sc->bge_dev.dv_xname);
		bge_release_resources(sc);
		error = ENXIO;
		goto fail;
	}

	/*
	 * A Broadcom chip was detected. Inform the world.
	 */
	printf(" address %s\n",
	    ether_sprintf(sc->arpcom.ac_enaddr));

	/* Allocate the general information block and ring buffers. */
	sc->bge_dmatag = pa->pa_dmat;
	DPRINTFN(5, ("bus_dmamem_alloc\n"));
	if (bus_dmamem_alloc(sc->bge_dmatag, sizeof(struct bge_ring_data),
			     PAGE_SIZE, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) {
		printf("%s: can't alloc rx buffers\n", sc->bge_dev.dv_xname);
		goto fail;
	}
	DPRINTFN(5, ("bus_dmamem_map\n"));
	if (bus_dmamem_map(sc->bge_dmatag, &seg, rseg,
			   sizeof(struct bge_ring_data), &kva,
			   BUS_DMA_NOWAIT)) {
		printf("%s: can't map dma buffers (%d bytes)\n",
		    sc->bge_dev.dv_xname, (int)sizeof(struct bge_ring_data));
		bus_dmamem_free(sc->bge_dmatag, &seg, rseg);
		goto fail;
	}
	DPRINTFN(5, ("bus_dmamem_create\n"));
	if (bus_dmamap_create(sc->bge_dmatag, sizeof(struct bge_ring_data), 1,
	    sizeof(struct bge_ring_data), 0,
	    BUS_DMA_NOWAIT, &sc->bge_ring_map)) {
		printf("%s: can't create dma map\n", sc->bge_dev.dv_xname);
		bus_dmamem_unmap(sc->bge_dmatag, kva,
				 sizeof(struct bge_ring_data));
		bus_dmamem_free(sc->bge_dmatag, &seg, rseg);
		goto fail;
	}
	DPRINTFN(5, ("bus_dmamem_load\n"));
	if (bus_dmamap_load(sc->bge_dmatag, sc->bge_ring_map, kva,
			    sizeof(struct bge_ring_data), NULL,
			    BUS_DMA_NOWAIT)) {
		bus_dmamap_destroy(sc->bge_dmatag, sc->bge_ring_map);
		bus_dmamem_unmap(sc->bge_dmatag, kva,
				 sizeof(struct bge_ring_data));
		bus_dmamem_free(sc->bge_dmatag, &seg, rseg);
		goto fail;
	}

	DPRINTFN(5, ("bzero\n"));
	sc->bge_rdata = (struct bge_ring_data *)kva;

	bzero(sc->bge_rdata, sizeof(struct bge_ring_data));

	/*
	 * Try to allocate memory for jumbo buffers.
	 * The 5705 does not appear to support jumbo frames.
	 */
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705 &&
	    sc->bge_asicrev != BGE_ASICREV_BCM5750) {
		if (bge_alloc_jumbo_mem(sc)) {
			printf("%s: jumbo buffer allocation failed\n",
			    sc->bge_dev.dv_xname);
			error = ENXIO;
			goto fail;
		}
	}

	/* Set default tuneable values. */
	sc->bge_stat_ticks = BGE_TICKS_PER_SEC;
	sc->bge_rx_coal_ticks = 150;
	sc->bge_tx_coal_ticks = 150;
	sc->bge_rx_max_coal_bds = 64;
	sc->bge_tx_max_coal_bds = 128;

	/* 5705 limits RX return ring to 512 entries. */
	if (sc->bge_asicrev == BGE_ASICREV_BCM5705 ||
	    sc->bge_asicrev == BGE_ASICREV_BCM5750)
		sc->bge_return_ring_cnt = BGE_RETURN_RING_CNT_5705;
	else
		sc->bge_return_ring_cnt = BGE_RETURN_RING_CNT;

	/* Set up ifnet structure */
	ifp = &sc->arpcom.ac_if;
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = bge_ioctl;
	ifp->if_output = ether_output;
	ifp->if_start = bge_start;
	ifp->if_watchdog = bge_watchdog;
	ifp->if_baudrate = 1000000000;
	ifp->if_mtu = ETHERMTU;
	IFQ_SET_MAXLEN(&ifp->if_snd, BGE_TX_RING_CNT - 1);
	IFQ_SET_READY(&ifp->if_snd);
	DPRINTFN(5, ("bcopy\n"));
	bcopy(sc->bge_dev.dv_xname, ifp->if_xname, IFNAMSIZ);

	ifp->if_capabilities = IFCAP_VLAN_MTU;

	/*
	 * Do MII setup.
	 */
	DPRINTFN(5, ("mii setup\n"));
	sc->bge_mii.mii_ifp = ifp;
	sc->bge_mii.mii_readreg = bge_miibus_readreg;
	sc->bge_mii.mii_writereg = bge_miibus_writereg;
	sc->bge_mii.mii_statchg = bge_miibus_statchg;

	/*
	 * Figure out what sort of media we have by checking the hardware
	 * config word in the first 32K of internal NIC memory, or fall back to
	 * examining the EEPROM if necessary.  Note: on some BCM5700 cards,
	 * this value seems to be unset. If that's the case, we have to rely on
	 * identifying the NIC by its PCI subsystem ID, as we do below for the
	 * SysKonnect SK-9D41.
	 */
	if (bge_readmem_ind(sc, BGE_SOFTWARE_GENCOMM_SIG) == BGE_MAGIC_NUMBER)
		hwcfg = bge_readmem_ind(sc, BGE_SOFTWARE_GENCOMM_NICCFG);
	else {
		bge_read_eeprom(sc, (caddr_t)&hwcfg, BGE_EE_HWCFG_OFFSET,
		    sizeof(hwcfg));
		hwcfg = ntohl(hwcfg);
	}
	
	if ((hwcfg & BGE_HWCFG_MEDIA) == BGE_MEDIA_FIBER)	    
		sc->bge_tbi = 1;

	/* The SysKonnect SK-9D41 is a 1000baseSX card. */
	if ((pci_conf_read(pc, pa->pa_tag, BGE_PCI_SUBSYS) >> 16) ==
	    SK_SUBSYSID_9D41)
		sc->bge_tbi = 1;

	if (sc->bge_tbi) {
		ifmedia_init(&sc->bge_ifmedia, IFM_IMASK, bge_ifmedia_upd,
		    bge_ifmedia_sts);
		ifmedia_add(&sc->bge_ifmedia, IFM_ETHER|IFM_1000_SX, 0, NULL);
		ifmedia_add(&sc->bge_ifmedia, IFM_ETHER|IFM_1000_SX|IFM_FDX,
			    0, NULL);
		ifmedia_add(&sc->bge_ifmedia, IFM_ETHER|IFM_AUTO, 0, NULL);
		ifmedia_set(&sc->bge_ifmedia, IFM_ETHER|IFM_AUTO);
		sc->bge_ifmedia.ifm_media = sc->bge_ifmedia.ifm_cur->ifm_media;
	} else {
		/*
		 * Do transceiver setup.
		 */
		ifmedia_init(&sc->bge_mii.mii_media, 0, bge_ifmedia_upd,
			     bge_ifmedia_sts);
		mii_attach(&sc->bge_dev, &sc->bge_mii, 0xffffffff,
			   MII_PHY_ANY, MII_OFFSET_ANY, 0);
		
		if (LIST_FIRST(&sc->bge_mii.mii_phys) == NULL) {
			printf("%s: no PHY found!\n", sc->bge_dev.dv_xname);
			ifmedia_add(&sc->bge_mii.mii_media,
				    IFM_ETHER|IFM_MANUAL, 0, NULL);
			ifmedia_set(&sc->bge_mii.mii_media,
				    IFM_ETHER|IFM_MANUAL);
		} else
			ifmedia_set(&sc->bge_mii.mii_media,
				    IFM_ETHER|IFM_AUTO);
	}

	/*
	 * When using the BCM5701 in PCI-X mode, data corruption has
	 * been observed in the first few bytes of some received packets.
	 * Aligning the packet buffer in memory eliminates the corruption.
	 * Unfortunately, this misaligns the packet payloads.  On platforms
	 * which do not support unaligned accesses, we will realign the
	 * payloads by copying the received packets.
	 */
	switch (sc->bge_chipid) {
	case BGE_CHIPID_BCM5701_A0:
	case BGE_CHIPID_BCM5701_B0:
	case BGE_CHIPID_BCM5701_B2:
	case BGE_CHIPID_BCM5701_B5:
		/* If in PCI-X mode, work around the alignment bug. */
		if ((pci_conf_read(pc, pa->pa_tag, BGE_PCI_PCISTATE) &
		    (BGE_PCISTATE_PCI_BUSMODE | BGE_PCISTATE_PCI_BUSSPEED)) ==
		    BGE_PCISTATE_PCI_BUSSPEED)
			sc->bge_rx_alignment_bug = 1;
		break;
	}

	/*
	 * Call MI attach routine.
	 */
	DPRINTFN(5, ("if_attach\n"));
	if_attach(ifp);
	DPRINTFN(5, ("ether_ifattach\n"));
	ether_ifattach(ifp);
	DPRINTFN(5, ("timeout_set\n"));
	timeout_set(&sc->bge_timeout, bge_tick, sc);
fail:
	splx(s);
}

void
bge_release_resources(sc)
	struct bge_softc *sc;
{
	if (sc->bge_vpd_prodname != NULL)
		free(sc->bge_vpd_prodname, M_DEVBUF);

	if (sc->bge_vpd_readonly != NULL)
		free(sc->bge_vpd_readonly, M_DEVBUF);

#ifdef fake
	if (sc->bge_intrhand != NULL)
		bus_teardown_intr(dev, sc->bge_irq, sc->bge_intrhand);

	if (sc->bge_irq != NULL)
		bus_release_resource(dev, SYS_RES_IRQ, 0, sc->bge_irq);

	if (sc->bge_res != NULL)
		bus_release_resource(dev, SYS_RES_MEMORY,
		    BGE_PCI_BAR0, sc->bge_res);

	if (sc->bge_rdata != NULL)
		contigfree(sc->bge_rdata,
		    sizeof(struct bge_ring_data), M_DEVBUF);
#endif
}

void
bge_reset(sc)
	struct bge_softc *sc;
{
	struct pci_attach_args *pa = &sc->bge_pa;
	u_int32_t cachesize, command, pcistate, reset;
	int i, val = 0;

	/* Save some important PCI state. */
	cachesize = pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_CACHESZ);
	command = pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_CMD);
	pcistate = pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_PCISTATE);

	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_MISC_CTL,
	    BGE_PCIMISCCTL_INDIRECT_ACCESS|BGE_PCIMISCCTL_MASK_PCI_INTR|
	    BGE_PCIMISCCTL_ENDIAN_WORDSWAP|BGE_PCIMISCCTL_PCISTATE_RW);

	reset = BGE_MISCCFG_RESET_CORE_CLOCKS|(65<<1);

	/* XXX: Broadcom Linux driver. */
	if (sc->bge_pcie) {
		if (CSR_READ_4(sc, 0x7e2c) == 0x60)	/* PCIE 1.0 */
			CSR_WRITE_4(sc, 0x7e2c, 0x20);
		if (sc->bge_chipid != BGE_CHIPID_BCM5750_A0) {
			/* Prevent PCIE link training during global reset */
			CSR_WRITE_4(sc, BGE_MISC_CFG, (1<<29));
			reset |= (1<<29);
		}
	}

	/* Issue global reset */
	bge_writereg_ind(sc, BGE_MISC_CFG, reset);

	DELAY(1000);

	/* XXX: Broadcom Linux driver. */
	if (sc->bge_pcie) {
		if (sc->bge_chipid == BGE_CHIPID_BCM5750_A0) {
			uint32_t v;

			DELAY(500000); /* wait for link training to complete */
			v = pci_conf_read(pa->pa_pc, pa->pa_tag, 0xc4);
			pci_conf_write(pa->pa_pc, pa->pa_tag, 0xc4, v | (1<<15));
		}
		/* Set PCIE max payload size and clear error status. */
		pci_conf_write(pa->pa_pc, pa->pa_tag, 0xd8, 0xf5000);
	}

	/* Reset some of the PCI state that got zapped by reset */
	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_MISC_CTL,
	    BGE_PCIMISCCTL_INDIRECT_ACCESS|BGE_PCIMISCCTL_MASK_PCI_INTR|
	    BGE_PCIMISCCTL_ENDIAN_WORDSWAP|BGE_PCIMISCCTL_PCISTATE_RW);
	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_CACHESZ, cachesize);
	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_CMD, command);
	bge_writereg_ind(sc, BGE_MISC_CFG, (65 << 1));

	/* Enable memory arbiter. */
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705 &&
	    sc->bge_asicrev != BGE_ASICREV_BCM5750)
		CSR_WRITE_4(sc, BGE_MARB_MODE, BGE_MARBMODE_ENABLE);

	/*
	 * Prevent PXE restart: write a magic number to the
	 * general communications memory at 0xB50.
	 */
	bge_writemem_ind(sc, BGE_SOFTWARE_GENCOMM, BGE_MAGIC_NUMBER);
	/*
	 * Poll the value location we just wrote until
	 * we see the 1's complement of the magic number.
	 * This indicates that the firmware initialization
	 * is complete.
	 */
	for (i = 0; i < BGE_TIMEOUT; i++) {
		val = bge_readmem_ind(sc, BGE_SOFTWARE_GENCOMM);
		if (val == ~BGE_MAGIC_NUMBER)
			break;
		DELAY(10);
	}

	if (i == BGE_TIMEOUT) {
		printf("%s: firmware handshake timed out\n",
		    sc->bge_dev.dv_xname);
		return;
	}

	/*
	 * XXX Wait for the value of the PCISTATE register to
	 * return to its original pre-reset state. This is a
	 * fairly good indicator of reset completion. If we don't
	 * wait for the reset to fully complete, trying to read
	 * from the device's non-PCI registers may yield garbage
	 * results.
	 */
	for (i = 0; i < BGE_TIMEOUT; i++) {
		if (pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_PCISTATE) ==
		    pcistate)
			break;
		DELAY(10);
	}

	/* Fix up byte swapping */
	CSR_WRITE_4(sc, BGE_MODE_CTL, BGE_MODECTL_BYTESWAP_NONFRAME|
	    BGE_MODECTL_BYTESWAP_DATA);

	CSR_WRITE_4(sc, BGE_MAC_MODE, 0);

	/*
	 * The 5704 in TBI mode apparently needs some special
	 * adjustment to insure the SERDES drive level is set
	 * to 1.2V.
	 */
	if (sc->bge_asicrev == BGE_ASICREV_BCM5704 && sc->bge_tbi) {
		uint32_t serdescfg;
		serdescfg = CSR_READ_4(sc, BGE_SERDES_CFG);
		serdescfg = (serdescfg & ~0xFFF) | 0x880;
		CSR_WRITE_4(sc, BGE_SERDES_CFG, serdescfg);
	}

	/* XXX: Broadcom Linux driver. */
	if (sc->bge_pcie && sc->bge_chipid != BGE_CHIPID_BCM5750_A0) {
		uint32_t v;
		v = CSR_READ_4(sc, 0x7c00);
		CSR_WRITE_4(sc, 0x7c00, v | (1<<25));
	}
	DELAY(10000);
}

/*
 * Frame reception handling. This is called if there's a frame
 * on the receive return list.
 *
 * Note: we have to be able to handle two possibilities here:
 * 1) the frame is from the jumbo receive ring
 * 2) the frame is from the standard receive ring
 */

void
bge_rxeof(sc)
	struct bge_softc *sc;
{
	struct ifnet *ifp;
	int stdcnt = 0, jumbocnt = 0;

	ifp = &sc->arpcom.ac_if;

	while(sc->bge_rx_saved_considx !=
	    sc->bge_rdata->bge_status_block.bge_idx[0].bge_rx_prod_idx) {
		struct bge_rx_bd	*cur_rx;
		u_int32_t		rxidx;
		struct mbuf		*m = NULL;
#if NVLAN > 0
		u_int16_t		vlan_tag = 0;
		int			have_tag = 0;
#endif
#ifdef BGE_CHECKSUM
		int			sumflags = 0;
#endif

		cur_rx = &sc->bge_rdata->
			bge_rx_return_ring[sc->bge_rx_saved_considx];

		rxidx = cur_rx->bge_idx;
		BGE_INC(sc->bge_rx_saved_considx, sc->bge_return_ring_cnt);

#if NVLAN > 0
		if (cur_rx->bge_flags & BGE_RXBDFLAG_VLAN_TAG) {
			have_tag = 1;
			vlan_tag = cur_rx->bge_vlan_tag;
		}
#endif

		if (cur_rx->bge_flags & BGE_RXBDFLAG_JUMBO_RING) {
			BGE_INC(sc->bge_jumbo, BGE_JUMBO_RX_RING_CNT);
			m = sc->bge_cdata.bge_rx_jumbo_chain[rxidx];
			sc->bge_cdata.bge_rx_jumbo_chain[rxidx] = NULL;
			jumbocnt++;
			if (cur_rx->bge_flags & BGE_RXBDFLAG_ERROR) {
				ifp->if_ierrors++;
				bge_newbuf_jumbo(sc, sc->bge_jumbo, m);
				continue;
			}
			if (bge_newbuf_jumbo(sc, sc->bge_jumbo,
					     NULL)== ENOBUFS) {
				ifp->if_ierrors++;
				bge_newbuf_jumbo(sc, sc->bge_jumbo, m);
				continue;
			}
		} else {
			BGE_INC(sc->bge_std, BGE_STD_RX_RING_CNT);
			m = sc->bge_cdata.bge_rx_std_chain[rxidx];
			sc->bge_cdata.bge_rx_std_chain[rxidx] = NULL;
			bus_dmamap_unload(sc->bge_dmatag,
					  sc->bge_cdata.bge_rx_std_map[rxidx]);
			stdcnt++;
			if (cur_rx->bge_flags & BGE_RXBDFLAG_ERROR) {
				ifp->if_ierrors++;
				bge_newbuf_std(sc, sc->bge_std, m);
				continue;
			}
			if (bge_newbuf_std(sc, sc->bge_std,
			    NULL) == ENOBUFS) {
				ifp->if_ierrors++;
				bge_newbuf_std(sc, sc->bge_std, m);
				continue;
			}
		}

		ifp->if_ipackets++;
#ifdef __STRICT_ALIGNMENT
		/*
		 * The i386 allows unaligned accesses, but for other
		 * platforms we must make sure the payload is aligned.
		 */
		if (sc->bge_rx_alignment_bug) {
			bcopy(m->m_data, m->m_data + ETHER_ALIGN,
			    cur_rx->bge_len);
			m->m_data += ETHER_ALIGN;
		}
#endif
		m->m_pkthdr.len = m->m_len = cur_rx->bge_len - ETHER_CRC_LEN; 
		m->m_pkthdr.rcvif = ifp;

#if NBPFILTER > 0
		/*
		 * Handle BPF listeners. Let the BPF user see the packet.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m);
#endif

#ifdef BGE_CHECKSUM
		if ((cur_rx->bge_ip_csum ^ 0xffff) == 0)
			sumflags |= M_IPV4_CSUM_IN_OK;
		else
			sumflags |= M_IPV4_CSUM_IN_BAD;
#if 0
		if (cur_rx->bge_flags & BGE_RXBDFLAG_TCP_UDP_CSUM) {
			m->m_pkthdr.csum_data =
				cur_rx->bge_tcp_udp_csum;
			m->m_pkthdr.csum_flags |= CSUM_DATA_VALID;
		}
#endif
		m->m_pkthdr.csum = sumflags;
		sumflags = 0;
#endif

#if NVLAN > 0
		/*
		 * If we received a packet with a vlan tag, pass it
		 * to vlan_input() instead of ether_input().
		 */
		if (have_tag) {
			vlan_input_tag(m, vlan_tag);
			have_tag = vlan_tag = 0;
			continue;
		}
#endif
		ether_input_mbuf(ifp, m);
	}

	CSR_WRITE_4(sc, BGE_MBX_RX_CONS0_LO, sc->bge_rx_saved_considx);
	if (stdcnt)
		CSR_WRITE_4(sc, BGE_MBX_RX_STD_PROD_LO, sc->bge_std);
	if (jumbocnt)
		CSR_WRITE_4(sc, BGE_MBX_RX_JUMBO_PROD_LO, sc->bge_jumbo);
}

void
bge_txeof(sc)
	struct bge_softc *sc;
{
	struct bge_tx_bd *cur_tx = NULL;
	struct ifnet *ifp;

	ifp = &sc->arpcom.ac_if;

	/*
	 * Go through our tx ring and free mbufs for those
	 * frames that have been sent.
	 */
	while (sc->bge_tx_saved_considx !=
	    sc->bge_rdata->bge_status_block.bge_idx[0].bge_tx_cons_idx) {
		u_int32_t		idx = 0;

		idx = sc->bge_tx_saved_considx;
		cur_tx = &sc->bge_rdata->bge_tx_ring[idx];
		if (cur_tx->bge_flags & BGE_TXBDFLAG_END)
			ifp->if_opackets++;
		if (sc->bge_cdata.bge_tx_chain[idx] != NULL) {
			m_freem(sc->bge_cdata.bge_tx_chain[idx]);
			sc->bge_cdata.bge_tx_chain[idx] = NULL;
			bus_dmamap_unload(sc->bge_dmatag,
					  sc->bge_cdata.bge_tx_map[idx]);
		}
		sc->bge_txcnt--;
		BGE_INC(sc->bge_tx_saved_considx, BGE_TX_RING_CNT);
		ifp->if_timer = 0;
	}

	if (cur_tx != NULL)
		ifp->if_flags &= ~IFF_OACTIVE;
}

int
bge_intr(xsc)
	void *xsc;
{
	struct bge_softc *sc;
	struct ifnet *ifp;
	u_int32_t status, mimode;

	sc = xsc;
	ifp = &sc->arpcom.ac_if;

#ifdef notdef
	/* Avoid this for now -- checking this register is expensive. */
	/* Make sure this is really our interrupt. */
	if (!(CSR_READ_4(sc, BGE_MISC_LOCAL_CTL) & BGE_MLC_INTR_STATE))
		return (0);
#endif
	/* Ack interrupt and stop others from occurring. */
	CSR_WRITE_4(sc, BGE_MBX_IRQ0_LO, 1);

	/*
	 * Process link state changes.
	 * Grrr. The link status word in the status block does
	 * not work correctly on the BCM5700 rev AX and BX chips,
	 * according to all available information. Hence, we have
	 * to enable MII interrupts in order to properly obtain
	 * async link changes. Unfortunately, this also means that
	 * we have to read the MAC status register to detect link
	 * changes, thereby adding an additional register access to
	 * the interrupt handler.
	 */

	if (sc->bge_asicrev == BGE_ASICREV_BCM5700) {
		status = CSR_READ_4(sc, BGE_MAC_STS);
		if (status & BGE_MACSTAT_MI_INTERRUPT) {
			sc->bge_link = 0;
			timeout_del(&sc->bge_timeout);
			bge_tick(sc);
			/* Clear the interrupt */
			CSR_WRITE_4(sc, BGE_MAC_EVT_ENB,
			    BGE_EVTENB_MI_INTERRUPT);
			bge_miibus_readreg(&sc->bge_dev, 1, BRGPHY_MII_ISR);
			bge_miibus_writereg(&sc->bge_dev, 1, BRGPHY_MII_IMR,
			    BRGPHY_INTRS);
		}
	} else {
		if ((sc->bge_rdata->bge_status_block.bge_status &
		    BGE_STATFLAG_UPDATED) &&
		    (sc->bge_rdata->bge_status_block.bge_status &
		    BGE_STATFLAG_LINKSTATE_CHANGED)) {
			sc->bge_rdata->bge_status_block.bge_status &=
			    ~(BGE_STATFLAG_UPDATED | 
				BGE_STATFLAG_LINKSTATE_CHANGED);
			/*
			 * Sometimes PCS encoding errors are detected in
			 * TBI mode (on fiber NICs), and for some reason
			 * the chip will signal them as link changes.
			 * If we get a link change event, but the 'PCS 
			 * encoding bit' in the MAC status register
			 * is set, don't bother doing a link check.
			 * This avoids spurious "gigabit link up" messages
			 * that sometimes appear on fiber NICs during
			 * periods of heavy traffic. (There should be no
			 * effect on copper NICs).
			 *
			 * If we do have a copper NIC (bge_tbi == 0) then
			 * check that the AUTOPOLL bit is set before
			 * processing the event as a real link change.
			 * Turning AUTOPOLL on and off in the MII read/write
			 * functions will often trigger a link status
			 * interrupt for no reason.
			 */
			status = CSR_READ_4(sc, BGE_MAC_STS);
			mimode = CSR_READ_4(sc, BGE_MI_MODE);
			if (!(status & (BGE_MACSTAT_PORT_DECODE_ERROR | 
			    BGE_MACSTAT_MI_COMPLETE)) && (!sc->bge_tbi &&
			    (mimode & BGE_MIMODE_AUTOPOLL))) {
				sc->bge_link = 0;
				timeout_del(&sc->bge_timeout);
				bge_tick(sc);
			}
			/* Clear the interrupt */
			CSR_WRITE_4(sc, BGE_MAC_STS, BGE_MACSTAT_SYNC_CHANGED|
			    BGE_MACSTAT_CFG_CHANGED|BGE_MACSTAT_MI_COMPLETE|
			    BGE_MACSTAT_LINK_CHANGED);

			/* Force flush the status block cached by PCI bridge */
			CSR_READ_4(sc, BGE_MBX_IRQ0_LO);	
		}
	}

	if (ifp->if_flags & IFF_RUNNING) {
		/* Check RX return ring producer/consumer */
		bge_rxeof(sc);

		/* Check TX ring producer/consumer */
		bge_txeof(sc);
	}

	bge_handle_events(sc);

	/* Re-enable interrupts. */
	CSR_WRITE_4(sc, BGE_MBX_IRQ0_LO, 0);

	if (ifp->if_flags & IFF_RUNNING && !IFQ_IS_EMPTY(&ifp->if_snd))
		bge_start(ifp);

	return (1);
}

void
bge_tick(xsc)
	void *xsc;
{
	struct bge_softc *sc = xsc;
	struct mii_data *mii = &sc->bge_mii;
	struct ifmedia *ifm = NULL;
	struct ifnet *ifp = &sc->arpcom.ac_if;
	int s;

	s = splimp();

	if (sc->bge_asicrev == BGE_ASICREV_BCM5705 ||
	    sc->bge_asicrev == BGE_ASICREV_BCM5750)
		bge_stats_update_regs(sc);
	else
		bge_stats_update(sc);
	timeout_add(&sc->bge_timeout, hz);
	if (sc->bge_link) {
		splx(s);
		return;
	}

	if (sc->bge_tbi) {
		ifm = &sc->bge_ifmedia;
		if (CSR_READ_4(sc, BGE_MAC_STS) &
		    BGE_MACSTAT_TBI_PCS_SYNCHED) {
			sc->bge_link++;
			if (sc->bge_asicrev == BGE_ASICREV_BCM5704)
				BGE_CLRBIT(sc, BGE_MAC_MODE,
				    BGE_MACMODE_TBI_SEND_CFGS);
			CSR_WRITE_4(sc, BGE_MAC_STS, 0xFFFFFFFF);
			if (!IFQ_IS_EMPTY(&ifp->if_snd))
				bge_start(ifp);
		}
		splx(s);
		return;
	}

	mii_tick(mii);

	if (!sc->bge_link && mii->mii_media_status & IFM_ACTIVE &&
	    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE) {
		sc->bge_link++;
		if (!IFQ_IS_EMPTY(&ifp->if_snd))
			bge_start(ifp);
	}

	splx(s);
}

void
bge_stats_update_regs(sc)
	struct bge_softc *sc;
{
	struct ifnet *ifp;
	struct bge_mac_stats_regs stats;
	u_int32_t *s;
	int i;

	ifp = &sc->arpcom.ac_if;

	s = (u_int32_t *)&stats;
	for (i = 0; i < sizeof(struct bge_mac_stats_regs); i += 4) {
		*s = CSR_READ_4(sc, BGE_RX_STATS + i);
		s++;
	}

	ifp->if_collisions +=
	   (stats.dot3StatsSingleCollisionFrames +
	   stats.dot3StatsMultipleCollisionFrames +
	   stats.dot3StatsExcessiveCollisions +
	   stats.dot3StatsLateCollisions) -
	   ifp->if_collisions;

	return;
}

void
bge_stats_update(sc)
	struct bge_softc *sc;
{
	struct ifnet *ifp = &sc->arpcom.ac_if;
	bus_size_t stats = BGE_MEMWIN_START + BGE_STATS_BLOCK;

#define READ_STAT(sc, stats, stat) \
	  CSR_READ_4(sc, stats + offsetof(struct bge_stats, stat))

	ifp->if_collisions +=
	  (READ_STAT(sc, stats,
	       txstats.dot3StatsSingleCollisionFrames.bge_addr_lo) +
	   READ_STAT(sc, stats,
	       txstats.dot3StatsMultipleCollisionFrames.bge_addr_lo) +
	   READ_STAT(sc, stats,
	       txstats.dot3StatsExcessiveCollisions.bge_addr_lo) +
	   READ_STAT(sc, stats,
	       txstats.dot3StatsLateCollisions.bge_addr_lo)) -
	  ifp->if_collisions;

#undef READ_STAT

#ifdef notdef
	ifp->if_collisions +=
	   (sc->bge_rdata->bge_info.bge_stats.dot3StatsSingleCollisionFrames +
	   sc->bge_rdata->bge_info.bge_stats.dot3StatsMultipleCollisionFrames +
	   sc->bge_rdata->bge_info.bge_stats.dot3StatsExcessiveCollisions +
	   sc->bge_rdata->bge_info.bge_stats.dot3StatsLateCollisions) -
	   ifp->if_collisions;
#endif
}

/*
 * Encapsulate an mbuf chain in the tx ring  by coupling the mbuf data
 * pointers to descriptors.
 */
int
bge_encap(sc, m_head, txidx)
	struct bge_softc *sc;
	struct mbuf *m_head;
	u_int32_t *txidx;
{
	struct bge_tx_bd	*f = NULL;
	u_int32_t		frag, cur, cnt = 0;
	u_int16_t		csum_flags = 0;
	bus_dmamap_t		txmap;
	int			i = 0;
#if NVLAN > 0
	struct ifvlan		*ifv = NULL;

	if ((m_head->m_flags & (M_PROTO1|M_PKTHDR)) == (M_PROTO1|M_PKTHDR) &&
	    m_head->m_pkthdr.rcvif != NULL)
		ifv = m_head->m_pkthdr.rcvif->if_softc;
#endif

	cur = frag = *txidx;

#ifdef BGE_CHECKSUM
	if (m_head->m_pkthdr.csum) {
		if (m_head->m_pkthdr.csum & M_IPV4_CSUM_OUT)
			csum_flags |= BGE_TXBDFLAG_IP_CSUM;
		if (m_head->m_pkthdr.csum & (M_TCPV4_CSUM_OUT |
					     M_UDPV4_CSUM_OUT))
			csum_flags |= BGE_TXBDFLAG_TCP_UDP_CSUM;
#ifdef fake
		if (m_head->m_flags & M_LASTFRAG)
			csum_flags |= BGE_TXBDFLAG_IP_FRAG_END;
		else if (m_head->m_flags & M_FRAG)
			csum_flags |= BGE_TXBDFLAG_IP_FRAG;
#endif
	}
#endif

	/*
	 * Start packing the mbufs in this chain into
	 * the fragment pointers. Stop when we run out
	 * of fragments or hit the end of the mbuf chain.
	 */
	txmap = sc->bge_cdata.bge_tx_map[frag];
	if (bus_dmamap_load_mbuf(sc->bge_dmatag, txmap, m_head,
	    BUS_DMA_NOWAIT))
		return(ENOBUFS);

	for (i = 0; i < txmap->dm_nsegs; i++) {
		f = &sc->bge_rdata->bge_tx_ring[frag];
		if (sc->bge_cdata.bge_tx_chain[frag] != NULL)
			break;
		BGE_HOSTADDR(f->bge_addr, txmap->dm_segs[i].ds_addr);
		f->bge_len = txmap->dm_segs[i].ds_len;
		f->bge_flags = csum_flags;
#if NVLAN > 0
		if (ifv != NULL) {
			f->bge_flags |= BGE_TXBDFLAG_VLAN_TAG;
			f->bge_vlan_tag = ifv->ifv_tag;
		} else {
			f->bge_vlan_tag = 0;
		}
#endif
		/*
		 * Sanity check: avoid coming within 16 descriptors
		 * of the end of the ring.
		 */
		if ((BGE_TX_RING_CNT - (sc->bge_txcnt + cnt)) < 16)
			return(ENOBUFS);
		cur = frag;
		BGE_INC(frag, BGE_TX_RING_CNT);
		cnt++;
	}

	if (frag == sc->bge_tx_saved_considx)
		return(ENOBUFS);

	sc->bge_rdata->bge_tx_ring[cur].bge_flags |= BGE_TXBDFLAG_END;
	sc->bge_cdata.bge_tx_chain[cur] = m_head;
	sc->bge_txcnt += cnt;

	*txidx = frag;

	return(0);
}

/*
 * Main transmit routine. To avoid having to do mbuf copies, we put pointers
 * to the mbuf data regions directly in the transmit descriptors.
 */
void
bge_start(ifp)
	struct ifnet *ifp;
{
	struct bge_softc *sc;
	struct mbuf *m_head = NULL;
	u_int32_t prodidx = 0;
	int pkts = 0;

	sc = ifp->if_softc;

	if (!sc->bge_link && ifp->if_snd.ifq_len < 10)
		return;

	prodidx = CSR_READ_4(sc, BGE_MBX_TX_HOST_PROD0_LO);

	while(sc->bge_cdata.bge_tx_chain[prodidx] == NULL) {
		IFQ_POLL(&ifp->if_snd, m_head);
		if (m_head == NULL)
			break;

		/*
		 * XXX
		 * safety overkill.  If this is a fragmented packet chain
		 * with delayed TCP/UDP checksums, then only encapsulate
		 * it if we have enough descriptors to handle the entire
		 * chain at once.
		 * (paranoia -- may not actually be needed)
		 */
#ifdef fake
		if (m_head->m_flags & M_FIRSTFRAG &&
		    m_head->m_pkthdr.csum_flags & (CSUM_DELAY_DATA)) {
			if ((BGE_TX_RING_CNT - sc->bge_txcnt) <
			    m_head->m_pkthdr.csum_data + 16) {
				ifp->if_flags |= IFF_OACTIVE;
				break;
			}
		}
#endif

		/*
		 * Pack the data into the transmit ring. If we
		 * don't have room, set the OACTIVE flag and wait
		 * for the NIC to drain the ring.
		 */
		if (bge_encap(sc, m_head, &prodidx)) {
			ifp->if_flags |= IFF_OACTIVE;
			break;
		}

		/* now we are committed to transmit the packet */
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
		pkts++;

#if NBPFILTER > 0
		/*
		 * If there's a BPF listener, bounce a copy of this frame
		 * to him.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m_head);
#endif
	}
	if (pkts == 0)
		return;

	/* Transmit */
	CSR_WRITE_4(sc, BGE_MBX_TX_HOST_PROD0_LO, prodidx);
	/* 5700 b2 errata */
	if (sc->bge_chiprev == BGE_CHIPREV_5700_BX)
		CSR_WRITE_4(sc, BGE_MBX_TX_HOST_PROD0_LO, 0);

	/*
	 * Set a timeout in case the chip goes out to lunch.
	 */
	ifp->if_timer = 5;
}

void
bge_init(xsc)
	void *xsc;
{
	struct bge_softc *sc = xsc;
	struct ifnet *ifp;
	u_int16_t *m;
	int s;

	s = splimp();

	ifp = &sc->arpcom.ac_if;

	if (ifp->if_flags & IFF_RUNNING) {
		splx(s);
		return;
	}

	/* Cancel pending I/O and flush buffers. */
	bge_stop(sc);
	bge_reset(sc);
	bge_chipinit(sc);

	/*
	 * Init the various state machines, ring
	 * control blocks and firmware.
	 */
	if (bge_blockinit(sc)) {
		printf("%s: initialization failure\n", sc->bge_dev.dv_xname);
		splx(s);
		return;
	}

	ifp = &sc->arpcom.ac_if;

	/* Specify MTU. */
	CSR_WRITE_4(sc, BGE_RX_MTU, ifp->if_mtu +
	    ETHER_HDR_LEN + ETHER_CRC_LEN + ETHER_VLAN_ENCAP_LEN);

	/* Load our MAC address. */
	m = (u_int16_t *)&sc->arpcom.ac_enaddr[0];
	CSR_WRITE_4(sc, BGE_MAC_ADDR1_LO, htons(m[0]));
	CSR_WRITE_4(sc, BGE_MAC_ADDR1_HI, (htons(m[1]) << 16) | htons(m[2]));

	/* Enable or disable promiscuous mode as needed. */
	if (ifp->if_flags & IFF_PROMISC) {
		BGE_SETBIT(sc, BGE_RX_MODE, BGE_RXMODE_RX_PROMISC);
	} else {
		BGE_CLRBIT(sc, BGE_RX_MODE, BGE_RXMODE_RX_PROMISC);
	}

	/* Program multicast filter. */
	bge_setmulti(sc);

	/* Init RX ring. */
	bge_init_rx_ring_std(sc);

	/*
	 * Workaround for a bug in 5705 ASIC rev A0. Poll the NIC's
	 * memory to insure that the chip has in fact read the first
	 * entry of the ring.
	 */
	if (sc->bge_chipid == BGE_CHIPID_BCM5705_A0) {
		u_int32_t		v, i;
		for (i = 0; i < 10; i++) {
			DELAY(20);
			v = bge_readmem_ind(sc, BGE_STD_RX_RINGS + 8);
			if (v == (MCLBYTES - ETHER_ALIGN))
				break;
		}
		if (i == 10)
			printf("%s: 5705 A0 chip failed to load RX ring\n",
			    sc->bge_dev.dv_xname);
	}

	/* Init jumbo RX ring. */
	if (ifp->if_mtu > (ETHERMTU + ETHER_HDR_LEN + ETHER_CRC_LEN))
		bge_init_rx_ring_jumbo(sc);

	/* Init our RX return ring index */
	sc->bge_rx_saved_considx = 0;

	/* Init TX ring. */
	bge_init_tx_ring(sc);

	/* Turn on transmitter */
	BGE_SETBIT(sc, BGE_TX_MODE, BGE_TXMODE_ENABLE);

	/* Turn on receiver */
	BGE_SETBIT(sc, BGE_RX_MODE, BGE_RXMODE_ENABLE);

	/* Tell firmware we're alive. */
	BGE_SETBIT(sc, BGE_MODE_CTL, BGE_MODECTL_STACKUP);

	/* Enable host interrupts. */
	BGE_SETBIT(sc, BGE_PCI_MISC_CTL, BGE_PCIMISCCTL_CLEAR_INTA);
	BGE_CLRBIT(sc, BGE_PCI_MISC_CTL, BGE_PCIMISCCTL_MASK_PCI_INTR);
	CSR_WRITE_4(sc, BGE_MBX_IRQ0_LO, 0);

	bge_ifmedia_upd(ifp);

	ifp->if_flags |= IFF_RUNNING;
	ifp->if_flags &= ~IFF_OACTIVE;

	splx(s);

	timeout_add(&sc->bge_timeout, hz);
}

/*
 * Set media options.
 */
int
bge_ifmedia_upd(ifp)
	struct ifnet *ifp;
{
	struct bge_softc *sc = ifp->if_softc;
	struct mii_data *mii = &sc->bge_mii;
	struct ifmedia *ifm = &sc->bge_ifmedia;

	/* If this is a 1000baseX NIC, enable the TBI port. */
	if (sc->bge_tbi) {
		if (IFM_TYPE(ifm->ifm_media) != IFM_ETHER)
			return(EINVAL);
		switch(IFM_SUBTYPE(ifm->ifm_media)) {
		case IFM_AUTO:
			/*
			 * The BCM5704 ASIC appears to have a special
			 * mechanism for programming the autoneg
			 * advertisement registers in TBI mode.
			 */
			if (sc->bge_asicrev == BGE_ASICREV_BCM5704) {
				uint32_t sgdig;
				CSR_WRITE_4(sc, BGE_TX_TBI_AUTONEG, 0);
				sgdig = CSR_READ_4(sc, BGE_SGDIG_CFG);
				sgdig |= BGE_SGDIGCFG_AUTO|
				    BGE_SGDIGCFG_PAUSE_CAP|
				    BGE_SGDIGCFG_ASYM_PAUSE;
				CSR_WRITE_4(sc, BGE_SGDIG_CFG,
				    sgdig|BGE_SGDIGCFG_SEND);
				DELAY(5);
				CSR_WRITE_4(sc, BGE_SGDIG_CFG, sgdig);
			}
			break;
		case IFM_1000_SX:
			if ((ifm->ifm_media & IFM_GMASK) == IFM_FDX) {
				BGE_CLRBIT(sc, BGE_MAC_MODE,
				    BGE_MACMODE_HALF_DUPLEX);
			} else {
				BGE_SETBIT(sc, BGE_MAC_MODE,
				    BGE_MACMODE_HALF_DUPLEX);
			}
			break;
		default:
			return(EINVAL);
		}
		return(0);
	}

	sc->bge_link = 0;
	if (mii->mii_instance) {
		struct mii_softc *miisc;
		for (miisc = LIST_FIRST(&mii->mii_phys); miisc != NULL;
		    miisc = LIST_NEXT(miisc, mii_list))
			mii_phy_reset(miisc);
	}
	mii_mediachg(mii);

	return(0);
}

/*
 * Report current media status.
 */
void
bge_ifmedia_sts(ifp, ifmr)
	struct ifnet *ifp;
	struct ifmediareq *ifmr;
{
	struct bge_softc *sc = ifp->if_softc;
	struct mii_data *mii = &sc->bge_mii;

	if (sc->bge_tbi) {
		ifmr->ifm_status = IFM_AVALID;
		ifmr->ifm_active = IFM_ETHER;
		if (CSR_READ_4(sc, BGE_MAC_STS) &
		    BGE_MACSTAT_TBI_PCS_SYNCHED)
			ifmr->ifm_status |= IFM_ACTIVE;
		ifmr->ifm_active |= IFM_1000_SX;
		if (CSR_READ_4(sc, BGE_MAC_MODE) & BGE_MACMODE_HALF_DUPLEX)
			ifmr->ifm_active |= IFM_HDX;
		else
			ifmr->ifm_active |= IFM_FDX;
		return;
	}

	mii_pollstat(mii);
	ifmr->ifm_active = mii->mii_media_active;
	ifmr->ifm_status = mii->mii_media_status;
}

int
bge_ioctl(ifp, command, data)
	struct ifnet *ifp;
	u_long command;
	caddr_t data;
{
	struct bge_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *) data;
	struct ifaddr *ifa = (struct ifaddr *)data;
	int s, error = 0;
	struct mii_data *mii;

	s = splimp();

	if ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {
		splx(s);
		return (error);
	}

	switch(command) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		switch (ifa->ifa_addr->sa_family) {
#ifdef INET
		case AF_INET:
			bge_init(sc);
			arp_ifinit(&sc->arpcom, ifa);
			break;
#endif /* INET */
		default:
			bge_init(sc);
			break;
		}
		break;
	case SIOCSIFMTU:
		/* Disallow jumbo frames on 5705. */
		if (((sc->bge_asicrev == BGE_ASICREV_BCM5705 ||
		      sc->bge_asicrev == BGE_ASICREV_BCM5750) &&
		    ifr->ifr_mtu > ETHERMTU) || ifr->ifr_mtu > BGE_JUMBO_MTU)
			error = EINVAL;
		else
			ifp->if_mtu = ifr->ifr_mtu;
		break;
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			/*
			 * If only the state of the PROMISC flag changed,
			 * then just use the 'set promisc mode' command
			 * instead of reinitializing the entire NIC. Doing
			 * a full re-init means reloading the firmware and
			 * waiting for it to start up, which may take a
			 * second or two.
			 */
			if (ifp->if_flags & IFF_RUNNING &&
			    ifp->if_flags & IFF_PROMISC &&
			    !(sc->bge_if_flags & IFF_PROMISC)) {
				BGE_SETBIT(sc, BGE_RX_MODE,
				    BGE_RXMODE_RX_PROMISC);
			} else if (ifp->if_flags & IFF_RUNNING &&
			    !(ifp->if_flags & IFF_PROMISC) &&
			    sc->bge_if_flags & IFF_PROMISC) {
				BGE_CLRBIT(sc, BGE_RX_MODE,
				    BGE_RXMODE_RX_PROMISC);
			} else
				bge_init(sc);
		} else {
			if (ifp->if_flags & IFF_RUNNING) {
				bge_stop(sc);
			}
		}
		sc->bge_if_flags = ifp->if_flags;
		error = 0;
		break;
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (command == SIOCADDMULTI)
			? ether_addmulti(ifr, &sc->arpcom)
			: ether_delmulti(ifr, &sc->arpcom);

		if (error == ENETRESET) {
			if (ifp->if_flags & IFF_RUNNING)
				bge_setmulti(sc);
			error = 0;
		}
		break;
	case SIOCSIFMEDIA:
	case SIOCGIFMEDIA:
		if (sc->bge_tbi) {
			error = ifmedia_ioctl(ifp, ifr, &sc->bge_ifmedia,
			    command);
		} else {
			mii = &sc->bge_mii;
			error = ifmedia_ioctl(ifp, ifr, &mii->mii_media,
			    command);
		}
		error = 0;
		break;
	default:
		error = EINVAL;
		break;
	}

	splx(s);

	return(error);
}

void
bge_watchdog(ifp)
	struct ifnet *ifp;
{
	struct bge_softc *sc;

	sc = ifp->if_softc;

	printf("%s: watchdog timeout -- resetting\n", sc->bge_dev.dv_xname);

	ifp->if_flags &= ~IFF_RUNNING;
	bge_init(sc);

	ifp->if_oerrors++;
}

/*
 * Stop the adapter and free any mbufs allocated to the
 * RX and TX lists.
 */
void
bge_stop(sc)
	struct bge_softc *sc;
{
	struct ifnet *ifp = &sc->arpcom.ac_if;
	struct ifmedia_entry *ifm;
	struct mii_data *mii;
	int mtmp, itmp;

	timeout_del(&sc->bge_timeout);

	/*
	 * Disable all of the receiver blocks
	 */
	BGE_CLRBIT(sc, BGE_RX_MODE, BGE_RXMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_RBDI_MODE, BGE_RBDIMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_RXLP_MODE, BGE_RXLPMODE_ENABLE);
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705 &&
	    sc->bge_asicrev != BGE_ASICREV_BCM5750)
		BGE_CLRBIT(sc, BGE_RXLS_MODE, BGE_RXLSMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_RDBDI_MODE, BGE_RBDIMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_RDC_MODE, BGE_RDCMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_RBDC_MODE, BGE_RBDCMODE_ENABLE);

	/*
	 * Disable all of the transmit blocks
	 */
	BGE_CLRBIT(sc, BGE_SRS_MODE, BGE_SRSMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_SBDI_MODE, BGE_SBDIMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_SDI_MODE, BGE_SDIMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_RDMA_MODE, BGE_RDMAMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_SDC_MODE, BGE_SDCMODE_ENABLE);
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705 &&
	    sc->bge_asicrev != BGE_ASICREV_BCM5750)
		BGE_CLRBIT(sc, BGE_DMAC_MODE, BGE_DMACMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_SBDC_MODE, BGE_SBDCMODE_ENABLE);

	/*
	 * Shut down all of the memory managers and related
	 * state machines.
	 */
	BGE_CLRBIT(sc, BGE_HCC_MODE, BGE_HCCMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_WDMA_MODE, BGE_WDMAMODE_ENABLE);
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705 &&
	    sc->bge_asicrev != BGE_ASICREV_BCM5750)
		BGE_CLRBIT(sc, BGE_MBCF_MODE, BGE_MBCFMODE_ENABLE);
	CSR_WRITE_4(sc, BGE_FTQ_RESET, 0xFFFFFFFF);
	CSR_WRITE_4(sc, BGE_FTQ_RESET, 0);
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705 &&
	    sc->bge_asicrev != BGE_ASICREV_BCM5750) {
		BGE_CLRBIT(sc, BGE_BMAN_MODE, BGE_BMANMODE_ENABLE);
		BGE_CLRBIT(sc, BGE_MARB_MODE, BGE_MARBMODE_ENABLE);
	}

	/* Disable host interrupts. */
	BGE_SETBIT(sc, BGE_PCI_MISC_CTL, BGE_PCIMISCCTL_MASK_PCI_INTR);
	CSR_WRITE_4(sc, BGE_MBX_IRQ0_LO, 1);

	/*
	 * Tell firmware we're shutting down.
	 */
	BGE_CLRBIT(sc, BGE_MODE_CTL, BGE_MODECTL_STACKUP);

	/* Free the RX lists. */
	bge_free_rx_ring_std(sc);

	/* Free jumbo RX list. */
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705 &&
	    sc->bge_asicrev != BGE_ASICREV_BCM5750)
		bge_free_rx_ring_jumbo(sc);

	/* Free TX buffers. */
	bge_free_tx_ring(sc);

	/*
	 * Isolate/power down the PHY, but leave the media selection
	 * unchanged so that things will be put back to normal when
	 * we bring the interface back up.
	 */
	if (!sc->bge_tbi) {
		mii = &sc->bge_mii;
		itmp = ifp->if_flags;
		ifp->if_flags |= IFF_UP;
		ifm = mii->mii_media.ifm_cur;
		mtmp = ifm->ifm_media;
		ifm->ifm_media = IFM_ETHER|IFM_NONE;
		mii_mediachg(mii);
		ifm->ifm_media = mtmp;
		ifp->if_flags = itmp;
	}

	sc->bge_link = 0;

	sc->bge_tx_saved_considx = BGE_TXCONS_UNSET;

	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
}

/*
 * Stop all chip I/O so that the kernel's probe routines don't
 * get confused by errant DMAs when rebooting.
 */
void
bge_shutdown(xsc)
	void *xsc;
{
	struct bge_softc *sc = (struct bge_softc *)xsc;

	bge_stop(sc);
	bge_reset(sc);
}

struct cfattach bge_ca = {
	sizeof(struct bge_softc), bge_probe, bge_attach
};

struct cfdriver bge_cd = {
	0, "bge", DV_IFNET
};
@


1.6
log
@Revert the bge(4) update, just make it build with the new miidevs and pcidevs.
I am going to try to do this in a different way. At least, the bge driver in
GENERIC should work.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.25 2004/04/12 06:56:42 brad Exp $	*/
d3 2
a145 1
u_int32_t bge_crc(caddr_t);
d217 1
d220 3
d297 1
a297 1
	if (i == BGE_TIMEOUT) {
d405 1
a405 1
	if (i == BGE_TIMEOUT) {
a933 19
#define BGE_POLY	0xEDB88320

u_int32_t
bge_crc(addr)
	caddr_t addr;
{
	u_int32_t idx, bit, data, crc;

	/* Compute CRC for the address value. */
	crc = 0xFFFFFFFF; /* initial value */

	for (idx = 0; idx < 6; idx++) {
		for (data = *addr++, bit = 0; bit < 8; bit++, data >>= 1)
			crc = (crc >> 1) ^ (((crc ^ data) & 1) ? BGE_POLY : 0);
	}

	return(crc & 0x7F);
}

d946 6
a957 5
	/* First, zot all the existing filters. */
	for (i = 0; i < 4; i++)
		CSR_WRITE_4(sc, BGE_MAR0 + (i * 4), 0);

	/* Now program new ones. */
d960 5
a964 1
		h = bge_crc(LLADDR((struct sockaddr_dl *)enm->enm_addrlo));
d1025 5
a1029 1
	if (pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_PCISTATE) &
d1068 2
a1069 1
	    sc->bge_asicrev == BGE_ASICREV_BCM5705)
d1130 2
a1131 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705) {
d1145 2
a1146 1
	if (sc->bge_asicrev == BGE_ASICREV_BCM5705) {
d1160 2
a1161 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705) {
d1199 2
a1200 1
	if (sc->bge_asicrev == BGE_ASICREV_BCM5705)
d1221 2
a1222 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705) {
d1279 2
a1280 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
d1364 2
a1365 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705) {
d1373 2
a1374 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705) {
d1403 2
a1404 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
d1426 2
a1427 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
d1448 2
a1449 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
d1588 23
d1646 1
a1646 1
	printf(": address: %s\n",
a1691 8
	/* Save ASIC rev. */

	sc->bge_chipid =
	    pci_conf_read(pc, pa->pa_tag, BGE_PCI_MISC_CTL) &
	    BGE_PCIMISCCTL_ASICREV;
	sc->bge_asicrev = BGE_ASICREV(sc->bge_chipid);
	sc->bge_chiprev = BGE_CHIPREV(sc->bge_chipid);

d1696 2
a1697 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705) {
d1714 2
a1715 1
	if (sc->bge_asicrev == BGE_ASICREV_BCM5705)
d1735 2
d1778 1
d1865 1
a1865 1
	u_int32_t cachesize, command, pcistate;
d1877 13
d1891 1
a1891 2
	bge_writereg_ind(sc, BGE_MISC_CFG,
	    BGE_MISCCFG_RESET_CORE_CLOCKS|(65<<1));
d1895 13
d1917 2
a1918 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
d1966 18
d2169 1
a2169 1
	u_int32_t status;
d2227 7
d2236 1
d2238 2
a2239 1
			    BGE_MACSTAT_MI_COMPLETE))) {
d2285 2
a2286 1
	if (sc->bge_asicrev == BGE_ASICREV_BCM5705)
d2301 3
d2592 1
a2592 1
	    ETHER_HDR_LEN + ETHER_CRC_LEN);
d2681 17
d2792 2
a2793 1
		if ((sc->bge_asicrev == BGE_ASICREV_BCM5705 &&
d2831 7
a2837 2
		if (ifp->if_flags & IFF_RUNNING) {
			bge_setmulti(sc);
d2900 2
a2901 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
d2915 2
a2916 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
d2926 2
a2927 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
d2931 2
a2932 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705) {
d2950 2
a2951 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
@


1.5
log
@Start to roll back some of the incompatible changes which were also
imported: remove bge_activate, rework bge_newbuf a bit.
@
text
@d1 1
a1 3
/*	$MirOS: src/sys/dev/pci/if_bge.c,v 1.4 2011/11/06 20:43:56 bsiegert Exp $	*/
/*	$OpenBSD: if_bge.c,v 1.307 2011/06/22 16:44:27 tedu Exp $	*/

d38 1
a38 1
 * Broadcom BCM57xx/BCM590x family ethernet driver for OpenBSD.
d49 1
a49 1
 * SSRAM. The BCM5700 supports TCP, UDP and IP checksum offload, Jumbo
a83 1
#include <sys/timeout.h>
a106 5
#ifdef __sparc64__
#include <sparc64/autoconf.h>
#include <dev/ofw/openfirm.h>
#endif

d118 1
a118 1
#define ETHER_MIN_NOPAD		(ETHER_MIN_LEN - ETHER_CRC_LEN) /* i.e., 60 */
a119 1
const struct bge_revision * bge_lookup_rev(u_int32_t);
d122 1
a122 9

struct cfattach bge_ca = {
	sizeof(struct bge_softc), bge_probe, bge_attach, NULL, NULL
};

struct cfdriver bge_cd = {
	NULL, "bge", DV_IFNET
};

a128 1
int bge_cksum_pad(struct mbuf *);
a129 1
int bge_compact_dma_runt(struct mbuf *);
a134 1
void bge_stop_block(struct bge_softc *, bus_size_t, u_int32_t);
d137 1
a140 2
u_int8_t bge_nvram_getbyte(struct bge_softc *, int, u_int8_t *);
int bge_read_nvram(struct bge_softc *, caddr_t, int, int);
d144 2
a145 1
void bge_iff(struct bge_softc *);
d147 9
a155 1
int bge_newbuf_jumbo(struct bge_softc *, int);
a156 1
void bge_fill_rx_ring_jumbo(struct bge_softc *);
a157 7

int bge_newbuf(struct bge_softc *, int);
int bge_init_rx_ring_std(struct bge_softc *);
void bge_rxtick(void *);
void bge_fill_rx_ring_std(struct bge_softc *);
void bge_free_rx_ring_std(struct bge_softc *);

d161 1
a161 1
void bge_chipinit(struct bge_softc *);
d164 6
d172 3
a175 1
void bge_writembx(struct bge_softc *, int, int);
a181 1
void bge_link_upd(struct bge_softc *);
d183 1
d185 2
a186 2
#define DPRINTF(x)	do { if (bgedebug) printf x; } while (0)
#define DPRINTFN(n,x)	do { if (bgedebug >= (n)) printf x; } while (0)
a204 1
	{ PCI_VENDOR_ALTIMA, PCI_PRODUCT_ALTIMA_AC1003 },
a206 2
	{ PCI_VENDOR_APPLE, PCI_PRODUCT_APPLE_BCM5701 },

a209 1
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5702_ALT },
a211 1
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5703_ALT },
a214 1
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5704S_ALT },
a215 2
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5705F },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5705K },
a217 34
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5714 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5714S },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5715 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5715S },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5717 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5718 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5720 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5721 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5722 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5723 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5724 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5750 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5750M },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5751 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5751F },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5751M },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5752 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5752M },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5753 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5753F },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5753M },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5754 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5754M },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5755 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5755M },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5756 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5761 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5761E },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5761S },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5761SE },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5764 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5780 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5780S },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5781 },
a218 7
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5784 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5785F },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5785G },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5786 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5787 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5787F },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5787M },
a219 1
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5789 },
a221 17
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5903M },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5906 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5906M },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57760 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57761 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57765 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57780 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57781 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57785 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57788 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57790 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57791 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57795 },

	{ PCI_VENDOR_FUJITSU, PCI_PRODUCT_FUJITSU_PW008GE4 },
	{ PCI_VENDOR_FUJITSU, PCI_PRODUCT_FUJITSU_PW008GE5 },
	{ PCI_VENDOR_FUJITSU, PCI_PRODUCT_FUJITSU_PP250_450_LAN },
d225 1
a225 106
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C996 }
};

#define BGE_IS_5705_PLUS(sc)		((sc)->bge_flags & BGE_5705_PLUS)
#define BGE_IS_5750_PLUS(sc)		((sc)->bge_flags & BGE_5750_PLUS)
#define BGE_IS_5755_PLUS(sc)		((sc)->bge_flags & BGE_5755_PLUS)
#define BGE_IS_5700_FAMILY(sc)		((sc)->bge_flags & BGE_5700_FAMILY)
#define BGE_IS_5714_FAMILY(sc)		((sc)->bge_flags & BGE_5714_FAMILY)
#define BGE_IS_JUMBO_CAPABLE(sc)	((sc)->bge_flags & BGE_JUMBO_CAPABLE)

static const struct bge_revision {
	u_int32_t		br_chipid;
	const char		*br_name;
} bge_revisions[] = {
	{ BGE_CHIPID_BCM5700_A0, "BCM5700 A0" },
	{ BGE_CHIPID_BCM5700_A1, "BCM5700 A1" },
	{ BGE_CHIPID_BCM5700_B0, "BCM5700 B0" },
	{ BGE_CHIPID_BCM5700_B1, "BCM5700 B1" },
	{ BGE_CHIPID_BCM5700_B2, "BCM5700 B2" },
	{ BGE_CHIPID_BCM5700_B3, "BCM5700 B3" },
	{ BGE_CHIPID_BCM5700_ALTIMA, "BCM5700 Altima" },
	{ BGE_CHIPID_BCM5700_C0, "BCM5700 C0" },
	{ BGE_CHIPID_BCM5701_A0, "BCM5701 A0" },
	{ BGE_CHIPID_BCM5701_B0, "BCM5701 B0" },
	{ BGE_CHIPID_BCM5701_B2, "BCM5701 B2" },
	{ BGE_CHIPID_BCM5701_B5, "BCM5701 B5" },
	/* the 5702 and 5703 share the same ASIC ID */
	{ BGE_CHIPID_BCM5703_A0, "BCM5702/5703 A0" },
	{ BGE_CHIPID_BCM5703_A1, "BCM5702/5703 A1" },
	{ BGE_CHIPID_BCM5703_A2, "BCM5702/5703 A2" },
	{ BGE_CHIPID_BCM5703_A3, "BCM5702/5703 A3" },
	{ BGE_CHIPID_BCM5703_B0, "BCM5702/5703 B0" },
	{ BGE_CHIPID_BCM5704_A0, "BCM5704 A0" },
	{ BGE_CHIPID_BCM5704_A1, "BCM5704 A1" },
	{ BGE_CHIPID_BCM5704_A2, "BCM5704 A2" },
	{ BGE_CHIPID_BCM5704_A3, "BCM5704 A3" },
	{ BGE_CHIPID_BCM5704_B0, "BCM5704 B0" },
	{ BGE_CHIPID_BCM5705_A0, "BCM5705 A0" },
	{ BGE_CHIPID_BCM5705_A1, "BCM5705 A1" },
	{ BGE_CHIPID_BCM5705_A2, "BCM5705 A2" },
	{ BGE_CHIPID_BCM5705_A3, "BCM5705 A3" },
	{ BGE_CHIPID_BCM5750_A0, "BCM5750 A0" },
	{ BGE_CHIPID_BCM5750_A1, "BCM5750 A1" },
	{ BGE_CHIPID_BCM5750_A3, "BCM5750 A3" },
	{ BGE_CHIPID_BCM5750_B0, "BCM5750 B0" },
	{ BGE_CHIPID_BCM5750_B1, "BCM5750 B1" },
	{ BGE_CHIPID_BCM5750_C0, "BCM5750 C0" },
	{ BGE_CHIPID_BCM5750_C1, "BCM5750 C1" },
	{ BGE_CHIPID_BCM5750_C2, "BCM5750 C2" },
	{ BGE_CHIPID_BCM5714_A0, "BCM5714 A0" },
	{ BGE_CHIPID_BCM5752_A0, "BCM5752 A0" },
	{ BGE_CHIPID_BCM5752_A1, "BCM5752 A1" },
	{ BGE_CHIPID_BCM5752_A2, "BCM5752 A2" },
	{ BGE_CHIPID_BCM5714_B0, "BCM5714 B0" },
	{ BGE_CHIPID_BCM5714_B3, "BCM5714 B3" },
	{ BGE_CHIPID_BCM5715_A0, "BCM5715 A0" },
	{ BGE_CHIPID_BCM5715_A1, "BCM5715 A1" },
	{ BGE_CHIPID_BCM5715_A3, "BCM5715 A3" },
	{ BGE_CHIPID_BCM5755_A0, "BCM5755 A0" },
	{ BGE_CHIPID_BCM5755_A1, "BCM5755 A1" },
	{ BGE_CHIPID_BCM5755_A2, "BCM5755 A2" },
	{ BGE_CHIPID_BCM5755_C0, "BCM5755 C0" },
	{ BGE_CHIPID_BCM5761_A0, "BCM5761 A0" },
	{ BGE_CHIPID_BCM5761_A1, "BCM5761 A1" },
	{ BGE_CHIPID_BCM5784_A0, "BCM5784 A0" },
	{ BGE_CHIPID_BCM5784_A1, "BCM5784 A1" },
	/* the 5754 and 5787 share the same ASIC ID */
	{ BGE_CHIPID_BCM5787_A0, "BCM5754/5787 A0" },
	{ BGE_CHIPID_BCM5787_A1, "BCM5754/5787 A1" },
	{ BGE_CHIPID_BCM5787_A2, "BCM5754/5787 A2" },
	{ BGE_CHIPID_BCM5906_A1, "BCM5906 A1" },
	{ BGE_CHIPID_BCM5906_A2, "BCM5906 A2" },
	{ BGE_CHIPID_BCM57780_A0, "BCM57780 A0" },
	{ BGE_CHIPID_BCM57780_A1, "BCM57780 A1" },

	{ 0, NULL }
};

/*
 * Some defaults for major revisions, so that newer steppings
 * that we don't know about have a shot at working.
 */
static const struct bge_revision bge_majorrevs[] = {
	{ BGE_ASICREV_BCM5700, "unknown BCM5700" },
	{ BGE_ASICREV_BCM5701, "unknown BCM5701" },
	/* 5702 and 5703 share the same ASIC ID */
	{ BGE_ASICREV_BCM5703, "unknown BCM5703" },
	{ BGE_ASICREV_BCM5704, "unknown BCM5704" },
	{ BGE_ASICREV_BCM5705, "unknown BCM5705" },
	{ BGE_ASICREV_BCM5750, "unknown BCM5750" },
	{ BGE_ASICREV_BCM5714_A0, "unknown BCM5714" },
	{ BGE_ASICREV_BCM5752, "unknown BCM5752" },
	{ BGE_ASICREV_BCM5780, "unknown BCM5780" },
	{ BGE_ASICREV_BCM5714, "unknown BCM5714" },
	{ BGE_ASICREV_BCM5755, "unknown BCM5755" },
	{ BGE_ASICREV_BCM5761, "unknown BCM5761" },
	{ BGE_ASICREV_BCM5784, "unknown BCM5784" },
	{ BGE_ASICREV_BCM5785, "unknown BCM5785" },
	/* 5754 and 5787 share the same ASIC ID */
	{ BGE_ASICREV_BCM5787, "unknown BCM5754/5787" },
	{ BGE_ASICREV_BCM5906, "unknown BCM5906" },
	{ BGE_ASICREV_BCM57780, "unknown BCM57780" },
	{ BGE_ASICREV_BCM5717, "unknown BCM5717" },
	{ BGE_ASICREV_BCM57765, "unknown BCM57765" },

	{ 0, NULL }
d229 3
a231 1
bge_readmem_ind(struct bge_softc *sc, int off)
d240 3
a242 1
bge_writemem_ind(struct bge_softc *sc, int off, int val)
d250 5
a254 2
void
bge_writereg_ind(struct bge_softc *sc, int off, int val)
d259 1
a259 1
	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_REG_DATA, val);
d261 1
d264 3
a266 1
bge_writembx(struct bge_softc *sc, int off, int val)
d268 1
a268 2
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906)
		off += BGE_LPMBX_IRQ0_HI - BGE_MBX_IRQ0_HI;
d270 2
a271 1
	CSR_WRITE_4(sc, off, val);
d274 1
d276 3
a278 1
bge_nvram_getbyte(struct bge_softc *sc, int addr, u_int8_t *dest)
a279 1
	u_int32_t access, byte = 0;
d281 2
d284 1
a284 16
	/* Lock. */
	CSR_WRITE_4(sc, BGE_NVRAM_SWARB, BGE_NVRAMSWARB_SET1);
	for (i = 0; i < 8000; i++) {
		if (CSR_READ_4(sc, BGE_NVRAM_SWARB) & BGE_NVRAMSWARB_GNT1)
			break;
		DELAY(20);
	}
	if (i == 8000)
		return (1);

	/* Enable access. */
	access = CSR_READ_4(sc, BGE_NVRAM_ACCESS);
	CSR_WRITE_4(sc, BGE_NVRAM_ACCESS, access | BGE_NVRAMACC_ENABLE);

	CSR_WRITE_4(sc, BGE_NVRAM_ADDR, addr & 0xfffffffc);
	CSR_WRITE_4(sc, BGE_NVRAM_CMD, BGE_NVRAM_READCMD);
d287 2
a288 2
		if (CSR_READ_4(sc, BGE_NVRAM_CMD) & BGE_NVRAMCMD_DONE) {
			DELAY(10);
a289 1
		}
d292 3
a294 3
	if (i == BGE_TIMEOUT * 10) {
		printf("%s: nvram read timed out\n", sc->bge_dev.dv_xname);
		return (1);
d297 1
a297 2
	/* Get result. */
	byte = CSR_READ_4(sc, BGE_NVRAM_RDDATA);
d299 2
a300 1
	*dest = (swap32(byte) >> ((addr % 4) * 8)) & 0xFF;
d302 8
a309 6
	/* Disable access. */
	CSR_WRITE_4(sc, BGE_NVRAM_ACCESS, access);

	/* Unlock. */
	CSR_WRITE_4(sc, BGE_NVRAM_SWARB, BGE_NVRAMSWARB_CLR1);
	CSR_READ_4(sc, BGE_NVRAM_SWARB);
d311 3
a313 1
	return (0);
d316 3
a318 6
/*
 * Read a sequence of bytes from NVRAM.
 */

int
bge_read_nvram(struct bge_softc *sc, caddr_t dest, int off, int cnt)
d320 2
a321 2
	int err = 0, i;
	u_int8_t byte = 0;
d323 14
a336 2
	if (BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5906)
		return (1);
d338 15
a352 5
	for (i = 0; i < cnt; i++) {
		err = bge_nvram_getbyte(sc, off + i, &byte);
		if (err)
			break;
		*(dest + i) = byte;
d355 6
a360 1
	return (err ? 1 : 0);
d362 1
d371 4
a374 1
bge_eeprom_getbyte(struct bge_softc *sc, int addr, u_int8_t *dest)
d400 1
a400 1
	if (i == BGE_TIMEOUT * 10) {
d402 1
a402 1
		return (1);
d410 1
a410 1
	return (0);
d417 5
a421 1
bge_read_eeprom(struct bge_softc *sc, caddr_t dest, int off, int cnt)
d433 1
a433 1
	return (err ? 1 : 0);
d437 3
a439 1
bge_miibus_readreg(struct device *dev, int phy, int reg)
d455 1
a455 1
		return (0);
a459 1
		BGE_STS_CLRBIT(sc, BGE_STS_AUTOPOLL);
d467 1
a467 2
	for (i = 0; i < 200; i++) {
		delay(1);
a470 1
		delay(10);
d473 1
a473 1
	if (i == 200) {
a482 1
		BGE_STS_SETBIT(sc, BGE_STS_AUTOPOLL);
d488 1
a488 1
		return (0);
d490 1
a490 1
	return (val & 0xFFFF);
d494 3
a496 1
bge_miibus_writereg(struct device *dev, int phy, int reg, int val)
d505 1
a506 3
		BGE_STS_CLRBIT(sc, BGE_STS_AUTOPOLL);
		BGE_CLRBIT(sc, BGE_MI_MODE, BGE_MIMODE_AUTOPOLL);
		DELAY(10); /* 40 usec is supposed to be adequate */
d512 1
a512 2
	for (i = 0; i < 200; i++) {
		delay(1);
a514 1
		delay(10);
a517 1
		BGE_STS_SETBIT(sc, BGE_STS_AUTOPOLL);
d522 1
a522 1
	if (i == 200) {
d528 2
a529 1
bge_miibus_statchg(struct device *dev)
a533 9
	/*
	 * Get flow control negotiation result.
	 */
	if (IFM_SUBTYPE(mii->mii_media.ifm_cur->ifm_media) == IFM_AUTO &&
	    (mii->mii_media_active & IFM_ETH_FMASK) != sc->bge_flowflags) {
		sc->bge_flowflags = mii->mii_media_active & IFM_ETH_FMASK;
		mii->mii_media_active &= ~IFM_ETH_FMASK;
	}

d535 1
a535 2
	if (IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_T ||
	    IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_SX)
d537 1
a537 1
	else
d539 1
d541 1
a541 1
	if ((mii->mii_media_active & IFM_GMASK) == IFM_FDX)
d543 1
a543 1
	else
d545 2
d548 7
a554 7
	/*
	 * 802.3x flow control
	 */
	if (sc->bge_flowflags & IFM_ETH_RXPAUSE)
		BGE_SETBIT(sc, BGE_RX_MODE, BGE_RXMODE_FLOWCTL_ENABLE);
	else
		BGE_CLRBIT(sc, BGE_RX_MODE, BGE_RXMODE_FLOWCTL_ENABLE);
d556 1
a556 4
	if (sc->bge_flowflags & IFM_ETH_TXPAUSE)
		BGE_SETBIT(sc, BGE_TX_MODE, BGE_TXMODE_FLOWCTL_ENABLE);
	else
		BGE_CLRBIT(sc, BGE_TX_MODE, BGE_TXMODE_FLOWCTL_ENABLE);
d560 1
a560 1
 * Intialize a standard receive ring descriptor.
d562 1
d564 2
a565 1
bge_newbuf(struct bge_softc *sc, int i)
d567 4
a570 4
	bus_dmamap_t		dmap = sc->bge_cdata.bge_rx_std_map[i];
	struct bge_rx_bd	*r = &sc->bge_rdata->bge_rx_std_ring[i];
	struct mbuf		*m;
	int			error;
d572 11
a582 2
	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (!m)
d584 6
a589 4
	
	MCLGET(m, M_DONTWAIT);
	if (!(m->m_flags & M_EXT)) {
		m_freem(m);
d592 7
a598 8
	m->m_len = m->m_pkthdr.len = MCLBYTES;
	if (!(sc->bge_flags & BGE_RX_ALIGNBUG))
	    m_adj(m, ETHER_ALIGN);

	error = bus_dmamap_load_mbuf(sc->bge_dmatag, dmap, m,
	    BUS_DMA_READ|BUS_DMA_NOWAIT);
	if (error) {
		m_freem(m);
d601 33
d635 2
a636 9
	bus_dmamap_sync(sc->bge_dmatag, dmap, 0, dmap->dm_mapsize,
	    BUS_DMASYNC_PREREAD);
	sc->bge_cdata.bge_rx_std_chain[i] = m;

	bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
	    offsetof(struct bge_ring_data, bge_rx_std_ring) +
		i * sizeof (struct bge_rx_bd),
	    sizeof (struct bge_rx_bd),
	    BUS_DMASYNC_POSTWRITE);
d638 8
a645 4
	BGE_HOSTADDR(r->bge_addr, dmap->dm_segs[0].ds_addr);
	r->bge_flags = BGE_RXBDFLAG_END;
	r->bge_len = m->m_len;
	r->bge_idx = i;
d647 1
a647 5
	bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
	    offsetof(struct bge_ring_data, bge_rx_std_ring) +
		i * sizeof (struct bge_rx_bd),
	    sizeof (struct bge_rx_bd),
	    BUS_DMASYNC_PREWRITE);
d649 4
a652 1
	sc->bge_std_cnt++;
d654 3
a656 1
	return (0);
d660 1
a660 1
 * Initialize a Jumbo receive ring descriptor.
d662 5
a666 2
int
bge_newbuf_jumbo(struct bge_softc *sc, int i)
d668 25
a692 4
	bus_dmamap_t		dmap = sc->bge_cdata.bge_rx_jumbo_map[i];
	struct bge_ext_rx_bd	*r = &sc->bge_rdata->bge_rx_jumbo_ring[i];
	struct mbuf		*m;
	int			error;
a693 13
	m = MCLGETI(NULL, M_DONTWAIT, &sc->arpcom.ac_if, BGE_JLEN);
	if (!m)
		return (ENOBUFS);
	m->m_len = m->m_pkthdr.len = BGE_JUMBO_FRAMELEN;
	if (!(sc->bge_flags & BGE_RX_ALIGNBUG))
	    m_adj(m, ETHER_ALIGN);

	error = bus_dmamap_load_mbuf(sc->bge_dmatag, dmap, m,
	    BUS_DMA_READ|BUS_DMA_NOWAIT);
	if (error) {
		m_freem(m);
		return (ENOBUFS);
	}
d695 29
a723 35
	bus_dmamap_sync(sc->bge_dmatag, dmap, 0, dmap->dm_mapsize,
	    BUS_DMASYNC_PREREAD);
	sc->bge_cdata.bge_rx_jumbo_chain[i] = m;

	bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
	    offsetof(struct bge_ring_data, bge_rx_jumbo_ring) +
		i * sizeof (struct bge_ext_rx_bd),
	    sizeof (struct bge_ext_rx_bd),
	    BUS_DMASYNC_POSTWRITE);

	/*
	 * Fill in the extended RX buffer descriptor.
	 */
	r->bge_bd.bge_flags = BGE_RXBDFLAG_JUMBO_RING | BGE_RXBDFLAG_END;
	r->bge_bd.bge_idx = i;
	r->bge_len3 = r->bge_len2 = r->bge_len1 = 0;
	switch (dmap->dm_nsegs) {
	case 4:
		BGE_HOSTADDR(r->bge_addr3, dmap->dm_segs[3].ds_addr);
		r->bge_len3 = dmap->dm_segs[3].ds_len;
		/* FALLTHROUGH */
	case 3:
		BGE_HOSTADDR(r->bge_addr2, dmap->dm_segs[2].ds_addr);
		r->bge_len2 = dmap->dm_segs[2].ds_len;
		/* FALLTHROUGH */
	case 2:
		BGE_HOSTADDR(r->bge_addr1, dmap->dm_segs[1].ds_addr);
		r->bge_len1 = dmap->dm_segs[1].ds_len;
		/* FALLTHROUGH */
	case 1:
		BGE_HOSTADDR(r->bge_bd.bge_addr, dmap->dm_segs[0].ds_addr);
		r->bge_bd.bge_len = dmap->dm_segs[0].ds_len;
		break;
	default:
		panic("%s: %d segments", __func__, dmap->dm_nsegs);
d726 12
a737 5
	bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
	    offsetof(struct bge_ring_data, bge_rx_jumbo_ring) +
		i * sizeof (struct bge_ext_rx_bd),
	    sizeof (struct bge_ext_rx_bd),
	    BUS_DMASYNC_PREWRITE);
d739 1
a739 3
	sc->bge_jumbo_cnt++;

	return (0);
d743 2
a744 4
 * The standard receive ring has 512 entries in it. At 2K per mbuf cluster,
 * that's 1MB or memory, which is a lot. For now, we fill only the first
 * 256 ring entries and hope that our CPU is fast enough to keep up with
 * the NIC.
d747 4
a750 1
bge_init_rx_ring_std(struct bge_softc *sc)
d752 2
a753 1
	int i;
d755 2
a756 2
	if (ISSET(sc->bge_flags, BGE_RXRING_VALID))
		return (0);
d758 4
a761 7
	for (i = 0; i < BGE_STD_RX_RING_CNT; i++) {
		if (bus_dmamap_create(sc->bge_dmatag, MCLBYTES, 1, MCLBYTES, 0,
		    BUS_DMA_WAITOK | BUS_DMA_ALLOCNOW,
		    &sc->bge_cdata.bge_rx_std_map[i]) != 0) {
			printf("%s: unable to create dmamap for slot %d\n",
			    sc->bge_dev.dv_xname, i);
			goto uncreate;
a762 3
		bzero(&sc->bge_rdata->bge_rx_std_ring[i],
		    sizeof(struct bge_rx_bd));
	}
d764 6
a769 3
	sc->bge_std = BGE_STD_RX_RING_CNT - 1;
	sc->bge_std_cnt = 0;
	bge_fill_rx_ring_std(sc);
d771 7
a777 8
	SET(sc->bge_flags, BGE_RXRING_VALID);

	return (0);

uncreate:
	while (--i) {
		bus_dmamap_destroy(sc->bge_dmatag,
		    sc->bge_cdata.bge_rx_std_map[i]);
a778 2
	return (1);
}
d780 10
a789 5
void
bge_rxtick(void *arg)
{
	struct bge_softc *sc = arg;
	int s;
d791 1
a791 8
	s = splnet();
	if (ISSET(sc->bge_flags, BGE_RXRING_VALID) &&
	    sc->bge_std_cnt <= 8)
		bge_fill_rx_ring_std(sc);
	if (ISSET(sc->bge_flags, BGE_JUMBO_RXRING_VALID) &&
	    sc->bge_jumbo_cnt <= 8)
		bge_fill_rx_ring_jumbo(sc);
	splx(s);
d794 9
a802 2
void
bge_fill_rx_ring_std(struct bge_softc *sc)
a804 1
	int post = 0;
d806 5
a810 3
	i = sc->bge_std;
	while (sc->bge_std_cnt < BGE_STD_RX_RING_CNT) {
		BGE_INC(i, BGE_STD_RX_RING_CNT);
d812 3
a814 5
		if (bge_newbuf(sc, i) != 0)
			break;

		sc->bge_std = i;
		post = 1;
d817 2
a818 2
	if (post)
		bge_writembx(sc, BGE_MBX_RX_STD_PROD_LO, sc->bge_std);
d820 1
a820 6
	/*
	 * bge always needs more than 8 packets on the ring. if we cant do
	 * that now, then try again later.
	 */
	if (sc->bge_std_cnt <= 8)
		timeout_add(&sc->bge_rxtimeout, 1);
d824 2
a825 1
bge_free_rx_ring_std(struct bge_softc *sc)
a826 2
	bus_dmamap_t dmap;
	struct mbuf *m;
a828 3
	if (!ISSET(sc->bge_flags, BGE_RXRING_VALID))
		return;

d830 2
a831 7
		dmap = sc->bge_cdata.bge_rx_std_map[i];
		m = sc->bge_cdata.bge_rx_std_chain[i];
		if (m != NULL) {
			bus_dmamap_sync(sc->bge_dmatag, dmap, 0,
			    dmap->dm_mapsize, BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->bge_dmatag, dmap);
			m_freem(m);
d833 2
d836 1
a836 3
		bus_dmamap_destroy(sc->bge_dmatag, dmap);
		sc->bge_cdata.bge_rx_std_map[i] = NULL;
		bzero(&sc->bge_rdata->bge_rx_std_ring[i],
a838 2

	CLR(sc->bge_flags, BGE_RXRING_VALID);
d842 2
a843 1
bge_init_rx_ring_jumbo(struct bge_softc *sc)
a844 1
	volatile struct bge_rcb *rcb;
d846 1
a846 3

	if (ISSET(sc->bge_flags, BGE_JUMBO_RXRING_VALID))
		return (0);
d849 3
a851 14
		if (bus_dmamap_create(sc->bge_dmatag, BGE_JLEN, 4, BGE_JLEN, 0,
		    BUS_DMA_WAITOK | BUS_DMA_ALLOCNOW,
		    &sc->bge_cdata.bge_rx_jumbo_map[i]) != 0) {
			printf("%s: unable to create dmamap for slot %d\n",
			    sc->bge_dev.dv_xname, i);
			goto uncreate;
		}
		bzero(&sc->bge_rdata->bge_rx_jumbo_ring[i],
		    sizeof(struct bge_ext_rx_bd));
	}

	sc->bge_jumbo = BGE_JUMBO_RX_RING_CNT - 1;
	sc->bge_jumbo_cnt = 0;
	bge_fill_rx_ring_jumbo(sc);
d853 1
a853 1
	SET(sc->bge_flags, BGE_JUMBO_RXRING_VALID);
d856 1
a856 2
	rcb->bge_maxlen_flags =
	    BGE_RCB_MAXLEN_FLAGS(0, BGE_RCB_FLAG_USE_EXT_RX_BD);
d859 1
a859 1
	return (0);
d861 1
a861 6
uncreate:
	while (--i) {
		bus_dmamap_destroy(sc->bge_dmatag,
		    sc->bge_cdata.bge_rx_jumbo_map[i]);
	}
	return (1);
d865 2
a866 29
bge_fill_rx_ring_jumbo(struct bge_softc *sc)
{
	int i;
	int post = 0;

	i = sc->bge_jumbo;
	while (sc->bge_jumbo_cnt < BGE_JUMBO_RX_RING_CNT) {
		BGE_INC(i, BGE_JUMBO_RX_RING_CNT);

		if (bge_newbuf_jumbo(sc, i) != 0)
			break;

		sc->bge_jumbo = i;
		post = 1;
	}

	if (post)
		bge_writembx(sc, BGE_MBX_RX_JUMBO_PROD_LO, sc->bge_jumbo);

	/*
	 * bge always needs more than 8 packets on the ring. if we cant do
	 * that now, then try again later.
	 */
	if (sc->bge_jumbo_cnt <= 8)
		timeout_add(&sc->bge_rxtimeout, 1);
}

void
bge_free_rx_ring_jumbo(struct bge_softc *sc)
a867 2
	bus_dmamap_t dmap;
	struct mbuf *m;
a869 3
	if (!ISSET(sc->bge_flags, BGE_JUMBO_RXRING_VALID))
		return;

d871 2
a872 7
		dmap = sc->bge_cdata.bge_rx_jumbo_map[i];
		m = sc->bge_cdata.bge_rx_jumbo_chain[i];
		if (m != NULL) {
			bus_dmamap_sync(sc->bge_dmatag, dmap, 0,
			    dmap->dm_mapsize, BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->bge_dmatag, dmap);
			m_freem(m);
d875 2
a876 4
		bus_dmamap_destroy(sc->bge_dmatag, dmap);
		sc->bge_cdata.bge_rx_jumbo_map[i] = NULL;
		bzero(&sc->bge_rdata->bge_rx_jumbo_ring[i],
		    sizeof(struct bge_ext_rx_bd));
a877 2

	CLR(sc->bge_flags, BGE_JUMBO_RXRING_VALID);
d881 2
a882 1
bge_free_tx_ring(struct bge_softc *sc)
a884 1
	struct txdmamap_pool_entry *dma;
d886 1
a886 1
	if (!(sc->bge_flags & BGE_TXRING_VALID))
d893 2
a894 3
			SLIST_INSERT_HEAD(&sc->txdma_list, sc->txdma[i],
					    link);
			sc->txdma[i] = 0;
d896 1
a896 1
		bzero(&sc->bge_rdata->bge_tx_ring[i],
a898 8

	while ((dma = SLIST_FIRST(&sc->txdma_list))) {
		SLIST_REMOVE_HEAD(&sc->txdma_list, link);
		bus_dmamap_destroy(sc->bge_dmatag, dma->dmamap);
		free(dma, M_DEVBUF);
	}

	sc->bge_flags &= ~BGE_TXRING_VALID;
d902 2
a903 1
bge_init_tx_ring(struct bge_softc *sc)
a905 5
	bus_dmamap_t dmamap;
	struct txdmamap_pool_entry *dma;

	if (sc->bge_flags & BGE_TXRING_VALID)
		return (0);
d910 9
a918 10
	/* Initialize transmit producer index for host-memory send ring. */
	sc->bge_tx_prodidx = 0;
	bge_writembx(sc, BGE_MBX_TX_HOST_PROD0_LO, sc->bge_tx_prodidx);
	if (BGE_CHIPREV(sc->bge_chipid) == BGE_CHIPREV_5700_BX)
		bge_writembx(sc, BGE_MBX_TX_HOST_PROD0_LO, sc->bge_tx_prodidx);

	/* NIC-memory send ring not used; initialize to zero. */
	bge_writembx(sc, BGE_MBX_TX_NIC_PROD0_LO, 0);
	if (BGE_CHIPREV(sc->bge_chipid) == BGE_CHIPREV_5700_BX)
		bge_writembx(sc, BGE_MBX_TX_NIC_PROD0_LO, 0);
a919 1
	SLIST_INIT(&sc->txdma_list);
d921 3
a923 15
		if (bus_dmamap_create(sc->bge_dmatag, BGE_JLEN,
		    BGE_NTXSEG, BGE_JLEN, 0, BUS_DMA_NOWAIT,
		    &dmamap))
			return (ENOBUFS);
		if (dmamap == NULL)
			panic("dmamap NULL in bge_init_tx_ring");
		dma = malloc(sizeof(*dma), M_DEVBUF, M_NOWAIT);
		if (dma == NULL) {
			printf("%s: can't alloc txdmamap_pool_entry\n",
			    sc->bge_dev.dv_xname);
			bus_dmamap_destroy(sc->bge_dmatag, dmamap);
			return (ENOMEM);
		}
		dma->dmamap = dmamap;
		SLIST_INSERT_HEAD(&sc->txdma_list, dma, link);
d926 18
a943 1
	sc->bge_flags |= BGE_TXRING_VALID;
d945 1
a945 1
	return (0);
d949 2
a950 1
bge_iff(struct bge_softc *sc)
d956 9
a964 2
	u_int8_t		hashes[16];
	u_int32_t		h, rxmode;
d967 2
a968 14
	rxmode = CSR_READ_4(sc, BGE_RX_MODE) & ~BGE_RXMODE_RX_PROMISC;
	ifp->if_flags &= ~IFF_ALLMULTI;
	memset(hashes, 0x00, sizeof(hashes));

	if (ifp->if_flags & IFF_PROMISC) {
		ifp->if_flags |= IFF_ALLMULTI;
		rxmode |= BGE_RXMODE_RX_PROMISC;
	} else if (ac->ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		memset(hashes, 0xff, sizeof(hashes));
	} else {
		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			h = ether_crc32_le(enm->enm_addrlo, ETHER_ADDR_LEN);
d970 6
a975 4
			setbit(hashes, h & 0x7F);

			ETHER_NEXT_MULTI(step, enm);
		}
d978 2
a979 3
	bus_space_write_raw_region_4(sc->bge_btag, sc->bge_bhandle, BGE_MAR0,
	    hashes, sizeof(hashes));
	CSR_WRITE_4(sc, BGE_RX_MODE, rxmode);
d983 2
a984 1
 * Do endian, PCI and DMA initialization.
d986 3
a988 2
void
bge_chipinit(struct bge_softc *sc)
d994 5
d1000 4
d1005 12
a1016 1
	    BGE_INIT);
d1033 9
a1041 10
	/*
	 * Set up the PCI DMA control register.
	 */
	dma_rw_ctl = BGE_PCIDMARWCTL_RD_CMD_SHIFT(6) |
	    BGE_PCIDMARWCTL_WR_CMD_SHIFT(7);

	if (sc->bge_flags & BGE_PCIE) {
		/* Read watermark not used, 128 bytes for write. */
		dma_rw_ctl |= BGE_PCIDMARWCTL_WR_WAT_SHIFT(3);
	} else if (sc->bge_flags & BGE_PCIX) {
d1043 12
a1054 17
		if (BGE_IS_5714_FAMILY(sc)) {
			/* 256 bytes for read and write. */
			dma_rw_ctl |= BGE_PCIDMARWCTL_RD_WAT_SHIFT(2) |
			    BGE_PCIDMARWCTL_WR_WAT_SHIFT(2);

			if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5780)
				dma_rw_ctl |= BGE_PCIDMARWCTL_ONEDMA_ATONCE_GLOBAL;
			else
				dma_rw_ctl |= BGE_PCIDMARWCTL_ONEDMA_ATONCE_LOCAL;
		} else if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704) {
			/* 1536 bytes for read, 384 bytes for write. */
			dma_rw_ctl |= BGE_PCIDMARWCTL_RD_WAT_SHIFT(7) |
			    BGE_PCIDMARWCTL_WR_WAT_SHIFT(3);
		} else {
			/* 384 bytes for read and write. */
			dma_rw_ctl |= BGE_PCIDMARWCTL_RD_WAT_SHIFT(3) |
			    BGE_PCIDMARWCTL_WR_WAT_SHIFT(3) |
a1055 1
		}
d1057 6
a1062 2
		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5703 ||
		    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704) {
a1064 1
			/* Set ONEDMA_ATONCE for hardware workaround. */
d1066 2
a1067 6
			if (tmp == 6 || tmp == 7)
				dma_rw_ctl |=
				    BGE_PCIDMARWCTL_ONEDMA_ATONCE_GLOBAL;

			/* Set PCI-X DMA write workaround. */
			dma_rw_ctl |= BGE_PCIDMARWCTL_ASRT_ALL_BE;
d1069 1
a1069 14
	} else {
		/* Conventional PCI bus: 256 bytes for read and write. */
		dma_rw_ctl |= BGE_PCIDMARWCTL_RD_WAT_SHIFT(7) |
		    BGE_PCIDMARWCTL_WR_WAT_SHIFT(7);

		if (BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5705 &&
		    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5750)
			dma_rw_ctl |= 0x0F;
	}

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5701)
		dma_rw_ctl |= BGE_PCIDMARWCTL_USE_MRM |
		    BGE_PCIDMARWCTL_ASRT_ALL_BE;
d1071 3
a1073 2
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5703 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704)
d1081 3
a1083 1
	CSR_WRITE_4(sc, BGE_MODE_CTL, BGE_DMA_SWAP_OPTIONS|
d1085 6
a1090 11
		    BGE_MODECTL_TX_NO_PHDR_CSUM);

	/*
	 * BCM5701 B5 have a bug causing data corruption when using
	 * 64-bit DMA reads, which can be terminated early and then
	 * completed later as 32-bit accesses, in combination with
	 * certain bridges.
	 */
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5701 &&
	    sc->bge_chipid == BGE_CHIPID_BCM5701_B5)
		BGE_SETBIT(sc, BGE_MODE_CTL, BGE_MODECTL_FORCE_PCI32);
d1113 1
a1113 8
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906) {
		DELAY(40);	/* XXX */

		/* Put PHY into ready state */
		BGE_CLRBIT(sc, BGE_MISC_CFG, BGE_MISCCFG_EPHY_IDDQ);
		CSR_READ_4(sc, BGE_MISC_CFG); /* Flush */
		DELAY(40);
	}
d1117 2
a1118 1
bge_blockinit(struct bge_softc *sc)
d1120 1
a1120 1
	volatile struct bge_rcb		*rcb;
a1122 2
	bge_hostaddr		taddr;
	u_int32_t		val;
d1132 4
a1135 2
	/* Configure mbuf memory pool */
	if (BGE_IS_5700_FAMILY(sc)) {
d1137 4
a1140 7
		    BGE_BUFFPOOL_1);

		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704)
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_LEN, 0x10000);
		else
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_LEN, 0x18000);

d1148 1
a1148 3
	/* new Broadcom docs strongly recommend these: */
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57765) {
d1150 1
a1150 12
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_MACRX_LOWAT, 0x2a);
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_HIWAT, 0xa0);
	} else if (BGE_IS_5705_PLUS(sc)) {
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_READDMA_LOWAT, 0x0);

		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906) {
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_MACRX_LOWAT, 0x04);
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_HIWAT, 0x10);
		} else {
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_MACRX_LOWAT, 0x10);
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_HIWAT, 0x60);
		}
a1153 1
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_HIWAT, 0x60);
d1155 1
d1162 3
a1164 2
	CSR_WRITE_4(sc, BGE_BMAN_MODE,
	    BGE_BMANMODE_ENABLE|BGE_BMANMODE_LOMBUF_ATTN);
d1166 6
a1171 6
	/* Poll for buffer manager start indication */
	for (i = 0; i < 2000; i++) {
		if (CSR_READ_4(sc, BGE_BMAN_MODE) & BGE_BMANMODE_ENABLE)
			break;
		DELAY(10);
	}
d1173 5
a1177 4
	if (i == 2000) {
		printf("%s: buffer manager failed to start\n",
		    sc->bge_dev.dv_xname);
		return (ENXIO);
d1185 1
a1185 1
	for (i = 0; i < 2000; i++) {
d1191 1
a1191 1
	if (i == 2000) {
d1194 1
a1194 1
		return (ENXIO);
d1200 1
a1200 5
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57765)
		rcb->bge_maxlen_flags = (BGE_RCB_MAXLEN_FLAGS(512, 0) |
					(ETHER_MAX_DIX_LEN << 2));
	else if (BGE_IS_5705_PLUS(sc))
d1204 5
a1208 2
		    BGE_RCB_MAXLEN_FLAGS(ETHER_MAX_DIX_LEN, 0);
	rcb->bge_nicaddr = BGE_STD_RX_RINGS;
d1215 1
a1215 1
	 * Initialize the Jumbo RX ring control block
d1221 1
a1221 1
	if (BGE_IS_JUMBO_CAPABLE(sc)) {
d1225 7
a1231 3
		rcb->bge_maxlen_flags = BGE_RCB_MAXLEN_FLAGS(0,
		    BGE_RCB_FLAG_USE_EXT_RX_BD | BGE_RCB_FLAG_RING_DISABLED);
		rcb->bge_nicaddr = BGE_JUMBO_RX_RINGS;
d1248 1
a1249 14
		bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
		    offsetof(struct bge_ring_data, bge_info),
		    sizeof (struct bge_gib),
		    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
	}

	/* Choose de-pipeline mode for BCM5906 A0, A1 and A2. */
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906) {
		if (sc->bge_chipid == BGE_CHIPID_BCM5906_A0 ||
		    sc->bge_chipid == BGE_CHIPID_BCM5906_A1 ||
		    sc->bge_chipid == BGE_CHIPID_BCM5906_A2)
			CSR_WRITE_4(sc, BGE_ISO_PKT_TX,
			    (CSR_READ_4(sc, BGE_ISO_PKT_TX) & ~3) | 2);
	}
d1251 1
a1251 1
	 * Set the BD ring replenish thresholds. The recommended
d1253 4
a1256 13
	 * each ring, but since we try to avoid filling the entire
	 * ring we set these to the minimal value of 8.  This needs to
	 * be done on several of the supported chip revisions anyway,
	 * to work around HW bugs.
	 */
	CSR_WRITE_4(sc, BGE_RBDI_STD_REPL_THRESH, 8);
	CSR_WRITE_4(sc, BGE_RBDI_JUMBO_REPL_THRESH, 8);

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57765) {
		CSR_WRITE_4(sc, BGE_STD_REPL_LWM, 4);
		CSR_WRITE_4(sc, BGE_JUMBO_REPL_LWM, 4);
	}
d1273 3
a1275 3
	BGE_HOSTADDR(taddr, BGE_RING_DMA_ADDR(sc, bge_tx_ring));
	RCB_WRITE_4(sc, rcb_addr, bge_hostaddr.bge_addr_hi, taddr.bge_addr_hi);
	RCB_WRITE_4(sc, rcb_addr, bge_hostaddr.bge_addr_lo, taddr.bge_addr_lo);
d1278 1
a1278 1
	if (BGE_IS_5700_FAMILY(sc))
d1291 1
a1291 1
		bge_writembx(sc, BGE_MBX_RX_CONS0_LO +
d1297 3
a1299 3
	bge_writembx(sc, BGE_MBX_RX_STD_PROD_LO, 0);
	bge_writembx(sc, BGE_MBX_RX_JUMBO_PROD_LO, 0);
	bge_writembx(sc, BGE_MBX_RX_MINI_PROD_LO, 0);
d1308 3
a1310 3
	BGE_HOSTADDR(taddr, BGE_RING_DMA_ADDR(sc, bge_rx_return_ring));
	RCB_WRITE_4(sc, rcb_addr, bge_hostaddr.bge_addr_hi, taddr.bge_addr_hi);
	RCB_WRITE_4(sc, rcb_addr, bge_hostaddr.bge_addr_lo, taddr.bge_addr_lo);
d1345 1
a1345 1
	for (i = 0; i < 2000; i++) {
d1351 1
a1351 1
	if (i == 2000) {
d1354 1
a1354 1
		return (ENXIO);
d1362 1
a1362 1
	if (BGE_IS_5700_FAMILY(sc)) {
d1370 1
a1370 1
	if (BGE_IS_5700_FAMILY(sc)) {
d1381 3
a1383 3
	BGE_HOSTADDR(taddr, BGE_RING_DMA_ADDR(sc, bge_status_block));
	CSR_WRITE_4(sc, BGE_HCC_STATUSBLK_ADDR_HI, taddr.bge_addr_hi);
	CSR_WRITE_4(sc, BGE_HCC_STATUSBLK_ADDR_LO, taddr.bge_addr_lo);
d1399 1
a1399 1
	if (BGE_IS_5700_FAMILY(sc))
a1401 12
	val = BGE_MACMODE_TXDMA_ENB | BGE_MACMODE_RXDMA_ENB |
	    BGE_MACMODE_RX_STATS_CLEAR | BGE_MACMODE_TX_STATS_CLEAR |
	    BGE_MACMODE_RX_STATS_ENB | BGE_MACMODE_TX_STATS_ENB |
	    BGE_MACMODE_FRMHDR_DMA_ENB;

	if (sc->bge_flags & BGE_PHY_FIBER_TBI)
	    val |= BGE_PORTMODE_TBI;
	else if (sc->bge_flags & BGE_PHY_FIBER_MII)
	    val |= BGE_PORTMODE_GMII;
	else
	    val |= BGE_PORTMODE_MII;

d1403 5
a1407 1
	CSR_WRITE_4(sc, BGE_MAC_MODE, val);
d1421 1
a1421 1
	if (BGE_IS_5700_FAMILY(sc))
a1423 9
	val = BGE_WDMAMODE_ENABLE|BGE_WDMAMODE_ALL_ATTNS;

	/* Enable host coalescing bug fix. */
	if (BGE_IS_5755_PLUS(sc))
		val |= BGE_WDMAMODE_STATUS_TAG_FIX;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5785)
		val |= BGE_WDMAMODE_BURST_ALL_DATA;

d1425 2
a1426 16
	CSR_WRITE_4(sc, BGE_WDMA_MODE, val);

	val = BGE_RDMAMODE_ENABLE|BGE_RDMAMODE_ALL_ATTNS;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717)
		val |= BGE_RDMAMODE_MULT_DMA_RD_DIS;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5784 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5785 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57780)
		val |= BGE_RDMAMODE_BD_SBD_CRPT_ATTN |
		       BGE_RDMAMODE_MBUF_RBD_CRPT_ATTN |
		       BGE_RDMAMODE_MBUF_SBD_CRPT_ATTN;

	if (sc->bge_flags & BGE_PCIE)
		val |= BGE_RDMAMODE_FIFO_LONG_BURST;
d1429 2
a1430 1
	CSR_WRITE_4(sc, BGE_RDMA_MODE, val);
d1442 1
a1442 1
	if (BGE_IS_5700_FAMILY(sc))
a1447 5
	val = BGE_SDCMODE_ENABLE;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5761)
		val |= BGE_SDCMODE_CDELAY;

d1449 1
a1449 1
	CSR_WRITE_4(sc, BGE_SDC_MODE, val);
d1470 1
a1470 1
	if (sc->bge_flags & BGE_PHY_FIBER_TBI) {
a1472 1
		BGE_STS_SETBIT(sc, BGE_STS_AUTOPOLL);
d1474 1
a1474 1
		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700)
a1478 11
	/*
	 * Clear any pending link state attention.
	 * Otherwise some link state change events may be lost until attention
	 * is cleared by bge_intr() -> bge_link_upd() sequence.
	 * It's not necessary on newer BCM chips - perhaps enabling link
	 * state change attentions implies clearing pending attention.
	 */
	CSR_WRITE_4(sc, BGE_MAC_STS, BGE_MACSTAT_SYNC_CHANGED|
	    BGE_MACSTAT_CFG_CHANGED|BGE_MACSTAT_MI_COMPLETE|
	    BGE_MACSTAT_LINK_CHANGED);

d1482 1
a1482 19
	return (0);
}

const struct bge_revision *
bge_lookup_rev(u_int32_t chipid)
{
	const struct bge_revision *br;

	for (br = bge_revisions; br->br_name != NULL; br++) {
		if (br->br_chipid == chipid)
			return (br);
	}

	for (br = bge_majorrevs; br->br_name != NULL; br++) {
		if (br->br_chipid == BGE_ASICREV(chipid))
			return (br);
	}

	return (NULL);
d1494 4
a1497 1
bge_probe(struct device *parent, void *match, void *aux)
d1499 2
a1500 1
	return (pci_matchbyid(aux, bge_devices, nitems(bge_devices)));
d1504 3
a1506 1
bge_attach(struct device *parent, struct device *self, void *aux)
a1510 2
	const struct bge_revision *br;
	pcireg_t		pm_ctl, memtype, subid, reg;
d1513 2
a1514 1
	bus_size_t		size;
d1516 1
a1516 1
	int			rseg, gotenaddr = 0, aspm_off;
d1519 1
a1519 1
	u_int32_t		misccfg;
d1521 1
d1523 2
a1524 3
#ifdef __sparc64__
	char			name[32];
#endif
a1527 2
	subid = pci_conf_read(pc, pa->pa_tag, PCI_SUBSYS_ID_REG);

d1532 11
d1544 3
a1546 4
	DPRINTFN(5, ("pci_mapreg_map\n"));
	memtype = pci_mapreg_type(pa->pa_pc, pa->pa_tag, BGE_PCI_BAR0);
	if (pci_mapreg_map(pa, BGE_PCI_BAR0, memtype, 0, &sc->bge_btag,
	    &sc->bge_bhandle, NULL, &size, 0)) {
d1548 7
a1554 1
		return;
d1557 2
d1562 1
a1562 1
		goto fail_1;
d1568 3
a1570 12
	/*
	 * Kludge for 5700 Bx bug: a hardware bug (PCIX byte enable?)
	 * can clobber the chip's PCI config-space power control registers,
	 * leaving the card in D3 powersave state.
	 * We do not have memory-mapped registers in this state,
	 * so force device into D0 state before starting initialization.
	 */
	pm_ctl = pci_conf_read(pc, pa->pa_tag, BGE_PCI_PWRMGMT_CMD);
	pm_ctl &= ~(PCI_PWR_D0|PCI_PWR_D1|PCI_PWR_D2|PCI_PWR_D3);
	pm_ctl |= (1 << 8) | PCI_PWR_D0 ; /* D0 state */
	pci_conf_write(pc, pa->pa_tag, BGE_PCI_PWRMGMT_CMD, pm_ctl);
	DELAY(1000);	/* 27 usec is allegedly sufficent */
d1572 6
a1577 176
	/*
	 * Save ASIC rev.
	 */
	sc->bge_chipid =
	     (pci_conf_read(pc, pa->pa_tag, BGE_PCI_MISC_CTL)
	      >> BGE_PCIMISCCTL_ASICREV_SHIFT);

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_USE_PRODID_REG) {
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5717 ||
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5718 ||
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5724)
			sc->bge_chipid = pci_conf_read(pc, pa->pa_tag,
			    BGE_PCI_GEN2_PRODID_ASICREV);
		else if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM57761 ||
			 PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM57765 ||
			 PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM57781 ||
			 PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM57785 ||
			 PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM57791 ||
			 PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM57795)
			sc->bge_chipid = pci_conf_read(pc, pa->pa_tag,
			    BGE_PCI_GEN15_PRODID_ASICREV);
		else
			sc->bge_chipid = pci_conf_read(pc, pa->pa_tag,
			    BGE_PCI_PRODID_ASICREV);
	}

	printf(", ");
	br = bge_lookup_rev(sc->bge_chipid);
	if (br == NULL)
		printf("unknown ASIC (0x%x)", sc->bge_chipid);
	else
		printf("%s (0x%x)", br->br_name, sc->bge_chipid);

	/*
	 * PCI Express or PCI-X controller check.
	 */
	if (pci_get_capability(pa->pa_pc, pa->pa_tag, PCI_CAP_PCIEXPRESS,
	    &aspm_off, NULL) != 0) {
		/* Disable PCIe Active State Power Management (ASPM). */
		reg = pci_conf_read(pa->pa_pc, pa->pa_tag,
		    aspm_off + PCI_PCIE_LCSR);
		reg &= ~(PCI_PCIE_LCSR_ASPM_L0S | PCI_PCIE_LCSR_ASPM_L1);
		pci_conf_write(pa->pa_pc, pa->pa_tag,
		    aspm_off + PCI_PCIE_LCSR, reg);
		sc->bge_flags |= BGE_PCIE;
	} else {
		if ((pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_PCISTATE) &
		    BGE_PCISTATE_PCI_BUSMODE) == 0)
			sc->bge_flags |= BGE_PCIX;
	}

	/*
	 * SEEPROM check.
	 */
#ifdef __sparc64__
	/*
	 * Onboard interfaces on UltraSPARC systems generally don't
	 * have a SEEPROM fitted.  These interfaces, and cards that
	 * have FCode, are named "network" by the PROM, whereas cards
	 * without FCode show up as "ethernet".  Since we don't really
	 * need the information from the SEEPROM on cards that have
	 * FCode it's fine to pretend they don't have one.
	 */
	if (OF_getprop(PCITAG_NODE(pa->pa_tag), "name", name,
	    sizeof(name)) > 0 && strcmp(name, "network") == 0)
		sc->bge_flags |= BGE_NO_EEPROM;
#endif
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5701 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5703 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704)
		sc->bge_flags |= BGE_5700_FAMILY;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5714_A0 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5780 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5714)
		sc->bge_flags |= BGE_5714_FAMILY;

	/* Intentionally exclude BGE_ASICREV_BCM5906 */
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5755 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5761 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5784 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5785 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5787 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57765 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57780)
		sc->bge_flags |= BGE_5755_PLUS;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5750 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5752 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906 ||
	    BGE_IS_5755_PLUS(sc) ||
	    BGE_IS_5714_FAMILY(sc))
		sc->bge_flags |= BGE_5750_PLUS;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5705 ||
	    BGE_IS_5750_PLUS(sc))
		sc->bge_flags |= BGE_5705_PLUS;

	/*
	 * When using the BCM5701 in PCI-X mode, data corruption has
	 * been observed in the first few bytes of some received packets.
	 * Aligning the packet buffer in memory eliminates the corruption.
	 * Unfortunately, this misaligns the packet payloads.  On platforms
	 * which do not support unaligned accesses, we will realign the
	 * payloads by copying the received packets.
	 */
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5701 &&
	    sc->bge_flags & BGE_PCIX)
		sc->bge_flags |= BGE_RX_ALIGNBUG;

	if (BGE_IS_5700_FAMILY(sc))
		sc->bge_flags |= BGE_JUMBO_CAPABLE;

	if ((BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5701) &&
	    PCI_VENDOR(subid) == DELL_VENDORID)
		sc->bge_flags |= BGE_NO_3LED;

	misccfg = CSR_READ_4(sc, BGE_MISC_CFG);
	misccfg &= BGE_MISCCFG_BOARD_ID_MASK;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5705 &&
	    (misccfg == BGE_MISCCFG_BOARD_ID_5788 ||
	     misccfg == BGE_MISCCFG_BOARD_ID_5788M))
		sc->bge_flags |= BGE_IS_5788;

	if ((BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5703 &&
	     (misccfg == 0x4000 || misccfg == 0x8000)) ||
	    (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5705 &&
	     PCI_VENDOR(pa->pa_id) == PCI_VENDOR_BROADCOM &&
	     (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5901 ||
	      PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5901A2 ||
	      PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5705F)) ||
	    (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_BROADCOM &&
	     (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5751F ||
	      PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5753F ||
	      PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5787F)) ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM57790 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906)
		sc->bge_flags |= BGE_10_100_ONLY;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700 ||
	    (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5705 &&
	     (sc->bge_chipid != BGE_CHIPID_BCM5705_A0 &&
	      sc->bge_chipid != BGE_CHIPID_BCM5705_A1)) ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906)
		sc->bge_flags |= BGE_NO_ETH_WIRE_SPEED;

	if (sc->bge_chipid == BGE_CHIPID_BCM5701_A0 ||
	    sc->bge_chipid == BGE_CHIPID_BCM5701_B0)
		sc->bge_flags |= BGE_PHY_CRC_BUG;
	if (BGE_CHIPREV(sc->bge_chipid) == BGE_CHIPREV_5703_AX ||
	    BGE_CHIPREV(sc->bge_chipid) == BGE_CHIPREV_5704_AX)
		sc->bge_flags |= BGE_PHY_ADC_BUG;
	if (sc->bge_chipid == BGE_CHIPID_BCM5704_A0)
		sc->bge_flags |= BGE_PHY_5704_A0_BUG;

	if ((BGE_IS_5705_PLUS(sc)) &&
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5906 &&
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5717 &&
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5785 &&
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM57765 &&
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM57780) {
		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5755 ||
		    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5761 ||
		    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5784 ||
		    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5787) {
			if (PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_BROADCOM_BCM5722 &&
			    PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_BROADCOM_BCM5756)
				sc->bge_flags |= BGE_PHY_JITTER_BUG;
			if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5755M)
				sc->bge_flags |= BGE_PHY_ADJUST_TRIM;
		} else
			sc->bge_flags |= BGE_PHY_BER_BUG;
d1579 1
d1585 6
a1590 7
	bge_chipinit(sc);

#ifdef __sparc64__
	if (!gotenaddr) {
		if (OF_getprop(PCITAG_NODE(pa->pa_tag), "local-mac-address",
		    sc->arpcom.ac_enaddr, ETHER_ADDR_LEN) == ETHER_ADDR_LEN)
			gotenaddr = 1;
a1591 1
#endif
d1596 15
a1610 12
	if (!gotenaddr) {
		mac_addr = bge_readmem_ind(sc, 0x0c14);
		if ((mac_addr >> 16) == 0x484b) {
			sc->arpcom.ac_enaddr[0] = (u_char)(mac_addr >> 8);
			sc->arpcom.ac_enaddr[1] = (u_char)mac_addr;
			mac_addr = bge_readmem_ind(sc, 0x0c18);
			sc->arpcom.ac_enaddr[2] = (u_char)(mac_addr >> 24);
			sc->arpcom.ac_enaddr[3] = (u_char)(mac_addr >> 16);
			sc->arpcom.ac_enaddr[4] = (u_char)(mac_addr >> 8);
			sc->arpcom.ac_enaddr[5] = (u_char)mac_addr;
			gotenaddr = 1;
		}
a1611 2
	if (!gotenaddr) {
		int mac_offset = BGE_EE_MAC_OFFSET;
d1613 5
a1617 26
		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906)
			mac_offset = BGE_EE_MAC_OFFSET_5906;

		if (bge_read_nvram(sc, (caddr_t)&sc->arpcom.ac_enaddr,
		    mac_offset + 2, ETHER_ADDR_LEN) == 0)
			gotenaddr = 1;
	}
	if (!gotenaddr && (!(sc->bge_flags & BGE_NO_EEPROM))) {
		if (bge_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,
		    BGE_EE_MAC_OFFSET + 2, ETHER_ADDR_LEN) == 0)
			gotenaddr = 1;
	}

#ifdef __sparc64__
	if (!gotenaddr) {
		extern void myetheraddr(u_char *);

		myetheraddr(sc->arpcom.ac_enaddr);
		gotenaddr = 1;
	}
#endif

	if (!gotenaddr) {
		printf(": failed to read station address\n");
		goto fail_1;
	}
d1624 2
a1625 2
		printf(": can't alloc rx buffers\n");
		goto fail_1;
d1631 4
a1634 3
		printf(": can't map dma buffers (%lu bytes)\n",
		    sizeof(struct bge_ring_data));
		goto fail_2;
d1640 5
a1644 2
		printf(": can't create dma map\n");
		goto fail_3;
d1650 5
a1654 1
		goto fail_4;
d1662 21
d1686 1
d1688 1
a1688 2
	sc->bge_tx_coal_ticks = 300;
	sc->bge_tx_max_coal_bds = 400;
d1691 3
a1693 3
	if (BGE_IS_5700_FAMILY(sc) ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57765)
a1694 2
	else
		sc->bge_return_ring_cnt = BGE_RETURN_RING_CNT_5705;
d1701 1
d1704 2
a1707 5

	/* lwm must be greater than the replenish threshold */
	m_clsetwms(ifp, MCLBYTES, 17, BGE_STD_RX_RING_CNT);
	m_clsetwms(ifp, BGE_JLEN, 17, BGE_JUMBO_RX_RING_CNT);

a1710 19
	ifp->if_capabilities = IFCAP_VLAN_MTU;

#if NVLAN > 0
	ifp->if_capabilities |= IFCAP_VLAN_HWTAGGING;
#endif

	/*
	 * 5700 B0 chips do not support checksumming correctly due
	 * to hardware bugs.
	 */
	if (sc->bge_chipid != BGE_CHIPID_BCM5700_B0)
		ifp->if_capabilities |= IFCAP_CSUM_IPv4;
#if 0	/* TCP/UDP checksum offload breaks with pf(4) */
		ifp->if_capabilities |= IFCAP_CSUM_TCPv4|IFCAP_CSUM_UDPv4;
#endif

	if (BGE_IS_JUMBO_CAPABLE(sc))
		ifp->if_hardmtu = BGE_JUMBO_MTU;

d1730 3
a1732 6
	else if (!(sc->bge_flags & BGE_NO_EEPROM)) {
		if (bge_read_eeprom(sc, (caddr_t)&hwcfg, BGE_EE_HWCFG_OFFSET,
		    sizeof(hwcfg))) {
			printf(": failed to read media type\n");
			goto fail_5;
		}
d1735 3
d1740 3
a1742 26
	if (PCI_PRODUCT(subid) == SK_SUBSYSID_9D41 ||
	    (hwcfg & BGE_HWCFG_MEDIA) == BGE_MEDIA_FIBER) {
		if (BGE_IS_5714_FAMILY(sc) ||
		    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717)
		    sc->bge_flags |= BGE_PHY_FIBER_MII;
		else
		    sc->bge_flags |= BGE_PHY_FIBER_TBI;
	}

	/* Hookup IRQ last. */
	DPRINTFN(5, ("pci_intr_establish\n"));
	sc->bge_intrhand = pci_intr_establish(pc, ih, IPL_NET, bge_intr, sc,
	    sc->bge_dev.dv_xname);
	if (sc->bge_intrhand == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		goto fail_5;
	}

	/*
	 * A Broadcom chip was detected. Inform the world.
	 */
	printf(": %s, address %s\n", intrstr,
	    ether_sprintf(sc->arpcom.ac_enaddr));
d1744 1
a1744 1
	if (sc->bge_flags & BGE_PHY_FIBER_TBI) {
a1751 1
		sc->bge_ifmedia.ifm_media = sc->bge_ifmedia.ifm_cur->ifm_media;
a1752 2
		int mii_flags;

a1757 3
		mii_flags = MIIF_DOPAUSE;
		if (sc->bge_flags & BGE_PHY_FIBER_MII)
			mii_flags |= MIIF_HAVEFIBER;
d1759 1
a1759 1
			   MII_PHY_ANY, MII_OFFSET_ANY, mii_flags);
d1773 21
d1796 1
d1798 1
d1800 1
a1800 1

d1802 3
a1804 2
	timeout_set(&sc->bge_rxtimeout, bge_rxtick, sc);
	return;
d1806 6
a1811 2
fail_5:
	bus_dmamap_unload(sc->bge_dmatag, sc->bge_ring_map);
d1813 2
a1814 2
fail_4:
	bus_dmamap_destroy(sc->bge_dmatag, sc->bge_ring_map);
d1816 15
a1830 9
fail_3:
	bus_dmamem_unmap(sc->bge_dmatag, kva,
	    sizeof(struct bge_ring_data));

fail_2:
	bus_dmamem_free(sc->bge_dmatag, &seg, rseg);

fail_1:
	bus_space_unmap(sc->bge_btag, sc->bge_bhandle, size);
d1834 2
a1835 1
bge_reset(struct bge_softc *sc)
d1838 1
a1838 2
	pcireg_t cachesize, command, pcistate, new_pcistate;
	u_int32_t reset;
a1849 29
	/* Disable fastboot on controllers that support it. */
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5752 ||
	    BGE_IS_5755_PLUS(sc))
		CSR_WRITE_4(sc, BGE_FASTBOOT_PC, 0);

	reset = BGE_MISCCFG_RESET_CORE_CLOCKS|(65<<1);

	if (sc->bge_flags & BGE_PCIE) {
		if (CSR_READ_4(sc, 0x7e2c) == 0x60) {
			/* PCI Express 1.0 system */
			CSR_WRITE_4(sc, 0x7e2c, 0x20);
		}
		if (sc->bge_chipid != BGE_CHIPID_BCM5750_A0) {
			/*
			 * Prevent PCI Express link training
			 * during global reset.
			 */
			CSR_WRITE_4(sc, BGE_MISC_CFG, (1<<29));
			reset |= (1<<29);
		}
	}

	/*
	 * Set GPHY Power Down Override to leave GPHY
	 * powered up in D0 uninitialized.
	 */
	if (BGE_IS_5705_PLUS(sc))
		reset |= BGE_MISCCFG_KEEP_GPHY_POWER;

d1851 2
a1852 14
	bge_writereg_ind(sc, BGE_MISC_CFG, reset);

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906) {
		u_int32_t status, ctrl;

		status = CSR_READ_4(sc, BGE_VCPU_STATUS);
		CSR_WRITE_4(sc, BGE_VCPU_STATUS,
		    status | BGE_VCPU_STATUS_DRV_RESET);
		ctrl = CSR_READ_4(sc, BGE_VCPU_EXT_CTRL);
		CSR_WRITE_4(sc, BGE_VCPU_EXT_CTRL,
		    ctrl & ~BGE_VCPU_EXT_CTRL_HALT_CPU);

		sc->bge_flags |= BGE_NO_EEPROM;
	}
a1855 17
	if (sc->bge_flags & BGE_PCIE) {
		if (sc->bge_chipid == BGE_CHIPID_BCM5750_A0) {
			pcireg_t v;

			DELAY(500000); /* wait for link training to complete */
			v = pci_conf_read(pa->pa_pc, pa->pa_tag, 0xc4);
			pci_conf_write(pa->pa_pc, pa->pa_tag, 0xc4, v | (1<<15));
		}

		/*
		 * Set PCI Express max payload size to 128 bytes
		 * and clear error status.
		 */
		pci_conf_write(pa->pa_pc, pa->pa_tag,
		    BGE_PCI_CONF_DEV_CTRL, 0xf5000);
	}

d1865 1
a1865 6
	if (BGE_IS_5714_FAMILY(sc)) {
		u_int32_t val;

		val = CSR_READ_4(sc, BGE_MARB_MODE);
		CSR_WRITE_4(sc, BGE_MARB_MODE, BGE_MARBMODE_ENABLE | val);
	} else
d1868 1
a1868 1
 	/*
d1873 12
d1886 4
a1889 27
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906) {
		for (i = 0; i < BGE_TIMEOUT; i++) {
			val = CSR_READ_4(sc, BGE_VCPU_STATUS);
			if (val & BGE_VCPU_STATUS_INIT_DONE)
				break;
			DELAY(100);
		}

		if (i >= BGE_TIMEOUT)
			printf("%s: reset timed out\n", sc->bge_dev.dv_xname);
	} else {
		/*
		 * Poll until we see 1's complement of the magic number.
		 * This indicates that the firmware initialization
		 * is complete.  We expect this to fail if no SEEPROM
		 * is fitted.
		 */
		for (i = 0; i < BGE_TIMEOUT; i++) {
			val = bge_readmem_ind(sc, BGE_SOFTWARE_GENCOMM);
			if (val == ~BGE_MAGIC_NUMBER)
				break;
			DELAY(10);
		}

		if (i >= BGE_TIMEOUT && (!(sc->bge_flags & BGE_NO_EEPROM)))
			printf("%s: firmware handshake timed out\n",
			   sc->bge_dev.dv_xname);
d1901 2
a1902 4
		new_pcistate = pci_conf_read(pa->pa_pc, pa->pa_tag,
		    BGE_PCI_PCISTATE);
		if ((new_pcistate & ~BGE_PCISTATE_RESERVED) ==
		    (pcistate & ~BGE_PCISTATE_RESERVED))
a1905 5
	if ((new_pcistate & ~BGE_PCISTATE_RESERVED) != 
	    (pcistate & ~BGE_PCISTATE_RESERVED)) {
		DPRINTFN(5, ("%s: pcistate failed to revert\n",
		    sc->bge_dev.dv_xname));
	}
d1908 2
a1909 1
	CSR_WRITE_4(sc, BGE_MODE_CTL, BGE_DMA_SWAP_OPTIONS);
a1912 25
	/*
	 * The 5704 in TBI mode apparently needs some special
	 * adjustment to insure the SERDES drive level is set
	 * to 1.2V.
	 */
	if (sc->bge_flags & BGE_PHY_FIBER_TBI &&
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704) {
		u_int32_t serdescfg;

		serdescfg = CSR_READ_4(sc, BGE_SERDES_CFG);
		serdescfg = (serdescfg & ~0xFFF) | 0x880;
		CSR_WRITE_4(sc, BGE_SERDES_CFG, serdescfg);
	}

	if (sc->bge_flags & BGE_PCIE &&
	    sc->bge_chipid != BGE_CHIPID_BCM5750_A0 &&
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5717 &&
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5785 &&
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM57765) {
		u_int32_t v;

		/* Enable PCI Express bug fix */
		v = CSR_READ_4(sc, 0x7c00);
		CSR_WRITE_4(sc, 0x7c00, v | (1<<25));
	}
d1926 2
a1927 1
bge_rxeof(struct bge_softc *sc)
a1929 1
	uint16_t rx_prod, rx_cons;
a1930 11
	bus_dmamap_t dmamap;
	bus_addr_t offset, toff;
	bus_size_t tlen;
	int tosync;

	rx_cons = sc->bge_rx_saved_considx;
	rx_prod = sc->bge_rdata->bge_status_block.bge_idx[0].bge_rx_prod_idx;

	/* Nothing to do */
	if (rx_cons == rx_prod)
		return;
d1934 3
a1936 24
	bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
	    offsetof(struct bge_ring_data, bge_status_block),
	    sizeof (struct bge_status_block),
	    BUS_DMASYNC_POSTREAD);

	offset = offsetof(struct bge_ring_data, bge_rx_return_ring);
	tosync = rx_prod - rx_cons;

	toff = offset + (rx_cons * sizeof (struct bge_rx_bd));

	if (tosync < 0) {
		tlen = (sc->bge_return_ring_cnt - rx_cons) *
		    sizeof (struct bge_rx_bd);
		bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
		    toff, tlen, BUS_DMASYNC_POSTREAD);
		tosync = -tosync;
	}

	bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
	    offset, tosync * sizeof (struct bge_rx_bd),
	    BUS_DMASYNC_POSTREAD);

	while (rx_cons != rx_prod) {
		struct bge_rx_bd	*cur_rx;
d1939 7
d1947 2
a1948 1
		cur_rx = &sc->bge_rdata->bge_rx_return_ring[rx_cons];
d1951 8
a1958 1
		BGE_INC(rx_cons, sc->bge_return_ring_cnt);
d1961 1
a1963 1

a1964 7
			sc->bge_jumbo_cnt--;

			dmamap = sc->bge_cdata.bge_rx_jumbo_map[rxidx];
			bus_dmamap_sync(sc->bge_dmatag, dmamap, 0,
			    dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->bge_dmatag, dmamap);

d1966 8
a1973 1
				m_freem(m);
d1977 1
d1980 2
a1981 1

a1982 7
			sc->bge_std_cnt--;

			dmamap = sc->bge_cdata.bge_rx_std_map[rxidx];
			bus_dmamap_sync(sc->bge_dmatag, dmamap, 0,
			    dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->bge_dmatag, dmamap);

d1984 8
a1991 1
				m_freem(m);
d2002 1
a2002 1
		if (sc->bge_flags & BGE_RX_ALIGNBUG) {
d2011 1
d2013 1
a2013 2
		 * 5700 B0 chips do not support checksumming correctly due
		 * to hardware bugs.
d2015 3
a2017 16
		if (sc->bge_chipid != BGE_CHIPID_BCM5700_B0) {
			if (cur_rx->bge_flags & BGE_RXBDFLAG_IP_CSUM) {
				if (cur_rx->bge_ip_csum == 0xFFFF)
					m->m_pkthdr.csum_flags |=
					    M_IPV4_CSUM_IN_OK;
				else
					m->m_pkthdr.csum_flags |=
					    M_IPV4_CSUM_IN_BAD;
			}
			if (cur_rx->bge_flags & BGE_RXBDFLAG_TCP_UDP_CSUM &&
			    m->m_pkthdr.len >= ETHER_MIN_NOPAD) {
				if (cur_rx->bge_tcp_udp_csum == 0xFFFF)
					m->m_pkthdr.csum_flags |=
					    M_TCP_CSUM_IN_OK|M_UDP_CSUM_IN_OK;
			}
		}
d2019 10
a2028 4
#if NVLAN > 0
		if (cur_rx->bge_flags & BGE_RXBDFLAG_VLAN_TAG) {
			m->m_pkthdr.ether_vtag = cur_rx->bge_vlan_tag;
			m->m_flags |= M_VLANTAG;
d2031 3
d2035 1
a2035 1
#if NBPFILTER > 0
d2037 2
a2038 1
		 * Handle BPF listeners. Let the BPF user see the packet.
d2040 5
a2044 2
		if (ifp->if_bpf)
			bpf_mtap_ether(ifp->if_bpf, m, BPF_DIRECTION_IN);
a2045 1

d2049 1
a2049 2
	sc->bge_rx_saved_considx = rx_cons;
	bge_writembx(sc, BGE_MBX_RX_CONS0_LO, sc->bge_rx_saved_considx);
d2051 1
a2051 1
		bge_fill_rx_ring_std(sc);
d2053 1
a2053 1
		bge_fill_rx_ring_jumbo(sc);
d2057 2
a2058 1
bge_txeof(struct bge_softc *sc)
a2061 10
	struct txdmamap_pool_entry *dma;
	bus_addr_t offset, toff;
	bus_size_t tlen;
	int tosync;
	struct mbuf *m;

	/* Nothing to do */
	if (sc->bge_tx_saved_considx ==
	    sc->bge_rdata->bge_status_block.bge_idx[0].bge_tx_cons_idx)
		return;
a2064 23
	bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
	    offsetof(struct bge_ring_data, bge_status_block),
	    sizeof (struct bge_status_block),
	    BUS_DMASYNC_POSTREAD);

	offset = offsetof(struct bge_ring_data, bge_tx_ring);
	tosync = sc->bge_rdata->bge_status_block.bge_idx[0].bge_tx_cons_idx -
	    sc->bge_tx_saved_considx;

	toff = offset + (sc->bge_tx_saved_considx * sizeof (struct bge_tx_bd));

	if (tosync < 0) {
		tlen = (BGE_TX_RING_CNT - sc->bge_tx_saved_considx) *
		    sizeof (struct bge_tx_bd);
		bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
		    toff, tlen, BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
		tosync = -tosync;
	}

	bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
	    offset, tosync * sizeof (struct bge_tx_bd),
	    BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);

d2077 2
a2078 2
		m = sc->bge_cdata.bge_tx_chain[idx];
		if (m != NULL) {
d2080 2
a2081 8
			dma = sc->txdma[idx];
			bus_dmamap_sync(sc->bge_dmatag, dma->dmamap, 0,
			    dma->dmamap->dm_mapsize, BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->bge_dmatag, dma->dmamap);
			SLIST_INSERT_HEAD(&sc->txdma_list, dma, link);
			sc->txdma[idx] = NULL;

			m_freem(m);
d2085 1
d2088 1
a2088 1
	if (sc->bge_txcnt < BGE_TX_RING_CNT - 16)
a2089 2
	if (sc->bge_txcnt == 0)
		ifp->if_timer = 0;
d2093 2
a2094 1
bge_intr(void *xsc)
d2098 1
a2098 1
	u_int32_t statusword;
d2103 8
a2110 22
	/* It is possible for the interrupt to arrive before
	 * the status block is updated prior to the interrupt.
	 * Reading the PCI State register will confirm whether the
	 * interrupt is ours and will flush the status block.
	 */

	/* read status word from status block */
	statusword = sc->bge_rdata->bge_status_block.bge_status;

	if ((statusword & BGE_STATFLAG_UPDATED) ||
	    (!(CSR_READ_4(sc, BGE_PCI_PCISTATE) & BGE_PCISTATE_INTR_NOT_ACTIVE))) {

		/* Ack interrupt and stop others from occurring. */
		bge_writembx(sc, BGE_MBX_IRQ0_LO, 1);
			
		/* clear status word */
		sc->bge_rdata->bge_status_block.bge_status = 0;

		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700 ||
		    statusword & BGE_STATFLAG_LINKSTATE_CHANGED ||
		    BGE_STS_BIT(sc, BGE_STS_LINK_EVT))
			bge_link_upd(sc);
d2112 56
a2167 3
		if (ifp->if_flags & IFF_RUNNING) {
			/* Check RX return ring producer/consumer */
			bge_rxeof(sc);
d2169 2
a2170 2
			/* Check TX ring producer/consumer */
			bge_txeof(sc);
d2172 5
d2178 8
a2185 2
		/* Re-enable interrupts. */
		bge_writembx(sc, BGE_MBX_IRQ0_LO, 0);
d2187 1
d2190 1
a2190 3
		return (1);
	} else
		return (0);
d2194 2
a2195 1
bge_tick(void *xsc)
d2199 2
d2203 1
a2203 1
	s = splnet();
d2205 1
a2205 1
	if (BGE_IS_5705_PLUS(sc))
d2209 5
d2215 14
a2228 17
	if (sc->bge_flags & BGE_PHY_FIBER_TBI) {
		/*
		 * Since in TBI mode auto-polling can't be used we should poll
		 * link status manually. Here we register pending link event
		 * and trigger interrupt.
		 */
		BGE_STS_SETBIT(sc, BGE_STS_LINK_EVT);
		BGE_SETBIT(sc, BGE_MISC_LOCAL_CTL, BGE_MLC_INTR_SET);
	} else {
		/*
		 * Do not touch PHY if we have link up. This could break
		 * IPMI/ASF mode or produce extra input errors.
		 * (extra input errors was reported for bcm5701 & bcm5704).
		 */
		if (!BGE_STS_BIT(sc, BGE_STS_LINK))
			mii_tick(mii);
	}       
d2230 6
a2235 1
	timeout_add_sec(&sc->bge_timeout, 1);
d2241 2
a2242 1
bge_stats_update_regs(struct bge_softc *sc)
d2244 4
a2247 1
	struct ifnet *ifp = &sc->arpcom.ac_if;
d2249 1
a2249 2
	ifp->if_collisions += CSR_READ_4(sc, BGE_MAC_STATS +
	    offsetof(struct bge_mac_stats_regs, etherStatsCollisions));
d2251 5
a2255 1
	ifp->if_ierrors += CSR_READ_4(sc, BGE_RXLP_LOCSTAT_IFIN_DROPS);
d2257 6
a2262 1
	ifp->if_ierrors += CSR_READ_4(sc, BGE_RXLP_LOCSTAT_IFIN_ERRORS);
d2264 1
a2264 1
	ifp->if_ierrors += CSR_READ_4(sc, BGE_RXLP_LOCSTAT_OUT_OF_BDS);
d2268 2
a2269 1
bge_stats_update(struct bge_softc *sc)
a2272 1
	u_int32_t cnt;
d2277 10
a2286 19
	cnt = READ_STAT(sc, stats, txstats.etherStatsCollisions.bge_addr_lo);
	ifp->if_collisions += (u_int32_t)(cnt - sc->bge_tx_collisions);
	sc->bge_tx_collisions = cnt;

	cnt = READ_STAT(sc, stats, ifInDiscards.bge_addr_lo);
	ifp->if_ierrors += (u_int32_t)(cnt - sc->bge_rx_discards);
	sc->bge_rx_discards = cnt;

	cnt = READ_STAT(sc, stats, ifInErrors.bge_addr_lo);
	ifp->if_ierrors += (u_int32_t)(cnt - sc->bge_rx_inerrors);
	sc->bge_rx_inerrors = cnt;

	cnt = READ_STAT(sc, stats, nicNoMoreRxBDs.bge_addr_lo);
	ifp->if_ierrors += (u_int32_t)(cnt - sc->bge_rx_overruns);
	sc->bge_rx_overruns = cnt;

	cnt = READ_STAT(sc, stats, txstats.ifOutDiscards.bge_addr_lo);
	ifp->if_oerrors += (u_int32_t)(cnt - sc->bge_tx_discards);
	sc->bge_tx_discards = cnt;
a2288 1
}
d2290 7
a2296 56
/*
 * Compact outbound packets to avoid bug with DMA segments less than 8 bytes.
 */
int
bge_compact_dma_runt(struct mbuf *pkt)
{
	struct mbuf	*m, *prev, *n = NULL;
	int 		totlen, newprevlen;

	prev = NULL;
	totlen = 0;

	for (m = pkt; m != NULL; prev = m,m = m->m_next) {
		int mlen = m->m_len;
		int shortfall = 8 - mlen ;

		totlen += mlen;
		if (mlen == 0)
			continue;
		if (mlen >= 8)
			continue;

		/* If we get here, mbuf data is too small for DMA engine.
		 * Try to fix by shuffling data to prev or next in chain.
		 * If that fails, do a compacting deep-copy of the whole chain.
		 */

		/* Internal frag. If fits in prev, copy it there. */
		if (prev && M_TRAILINGSPACE(prev) >= m->m_len) {
			bcopy(m->m_data, prev->m_data+prev->m_len, mlen);
			prev->m_len += mlen;
			m->m_len = 0;
			/* XXX stitch chain */
			prev->m_next = m_free(m);
			m = prev;
			continue;
		} else if (m->m_next != NULL &&
			   M_TRAILINGSPACE(m) >= shortfall &&
			   m->m_next->m_len >= (8 + shortfall)) {
			/* m is writable and have enough data in next, pull up. */

			bcopy(m->m_next->m_data, m->m_data+m->m_len, shortfall);
			m->m_len += shortfall;
			m->m_next->m_len -= shortfall;
			m->m_next->m_data += shortfall;
		} else if (m->m_next == NULL || 1) {
			/* Got a runt at the very end of the packet.
			 * borrow data from the tail of the preceding mbuf and
			 * update its length in-place. (The original data is still
			 * valid, so we can do this even if prev is not writable.)
			 */

			/* if we'd make prev a runt, just move all of its data. */
#ifdef DEBUG
			KASSERT(prev != NULL /*, ("runt but null PREV")*/);
			KASSERT(prev->m_len >= 8 /*, ("runt prev")*/);
a2297 34
			if ((prev->m_len - shortfall) < 8)
				shortfall = prev->m_len;

			newprevlen = prev->m_len - shortfall;

			MGET(n, M_NOWAIT, MT_DATA);
			if (n == NULL)
				return (ENOBUFS);
			KASSERT(m->m_len + shortfall < MLEN
				/*,
				  ("runt %d +prev %d too big\n", m->m_len, shortfall)*/);

			/* first copy the data we're stealing from prev */
			bcopy(prev->m_data + newprevlen, n->m_data, shortfall);

			/* update prev->m_len accordingly */
			prev->m_len -= shortfall;

			/* copy data from runt m */
			bcopy(m->m_data, n->m_data + shortfall, m->m_len);

			/* n holds what we stole from prev, plus m */
			n->m_len = shortfall + m->m_len;

			/* stitch n into chain and free m */
			n->m_next = m->m_next;
			prev->m_next = n;
			/* KASSERT(m->m_next == NULL); */
			m->m_next = NULL;
			m_free(m);
			m = n;	/* for continuing loop */
		}
	}
	return (0);
d2301 1
a2301 45
 * Pad outbound frame to ETHER_MIN_NOPAD for an unusual reason.
 * The bge hardware will pad out Tx runts to ETHER_MIN_NOPAD,
 * but when such padded frames employ the bge IP/TCP checksum offload,
 * the hardware checksum assist gives incorrect results (possibly
 * from incorporating its own padding into the UDP/TCP checksum; who knows).
 * If we pad such runts with zeros, the onboard checksum comes out correct.
 */
int
bge_cksum_pad(struct mbuf *m)
{
	int padlen = ETHER_MIN_NOPAD - m->m_pkthdr.len;
	struct mbuf *last;

	/* If there's only the packet-header and we can pad there, use it. */
	if (m->m_pkthdr.len == m->m_len && M_TRAILINGSPACE(m) >= padlen) {
		last = m;
	} else {
		/*
		 * Walk packet chain to find last mbuf. We will either
		 * pad there, or append a new mbuf and pad it.
		 */
		for (last = m; last->m_next != NULL; last = last->m_next);
		if (M_TRAILINGSPACE(last) < padlen) {
			/* Allocate new empty mbuf, pad it. Compact later. */
			struct mbuf *n;

			MGET(n, M_DONTWAIT, MT_DATA);
			if (n == NULL)
				return (ENOBUFS);
			n->m_len = 0;
			last->m_next = n;
			last = n;
		}
	}
	
	/* Now zero the pad area, to avoid the bge cksum-assist bug. */
	memset(mtod(last, caddr_t) + last->m_len, 0, padlen);
	last->m_len += padlen;
	m->m_pkthdr.len += padlen;

	return (0);
}

/*
 * Encapsulate an mbuf chain in the tx ring by coupling the mbuf data
d2305 4
a2308 1
bge_encap(struct bge_softc *sc, struct mbuf *m_head, u_int32_t *txidx)
d2311 1
a2311 1
	u_int32_t		frag, cur;
d2313 1
a2313 2
	struct txdmamap_pool_entry *dma;
	bus_dmamap_t dmamap;
d2315 7
d2325 3
a2327 2
	if (m_head->m_pkthdr.csum_flags) {
		if (m_head->m_pkthdr.csum_flags & M_IPV4_CSUM_OUT)
d2329 2
a2330 2
		if (m_head->m_pkthdr.csum_flags & (M_TCP_CSUM_OUT |
		    M_UDP_CSUM_OUT)) {
d2332 6
a2337 4
			if (m_head->m_pkthdr.len < ETHER_MIN_NOPAD &&
			    bge_cksum_pad(m_head) != 0)
				return (ENOBUFS);
		}
d2339 1
a2339 17

	if (!(BGE_CHIPREV(sc->bge_chipid) == BGE_CHIPREV_5700_BX))
		goto doit;

	/*
	 * bcm5700 Revision B silicon cannot handle DMA descriptors with
	 * less than eight bytes.  If we encounter a teeny mbuf
	 * at the end of a chain, we can pad.  Otherwise, copy.
	 */
	if (bge_compact_dma_runt(m_head) != 0)
		return (ENOBUFS);

doit:
	dma = SLIST_FIRST(&sc->txdma_list);
	if (dma == NULL)
		return (ENOBUFS);
	dmamap = dma->dmamap;
d2346 2
a2347 1
	if (bus_dmamap_load_mbuf(sc->bge_dmatag, dmamap, m_head,
d2349 1
a2349 1
		return (ENOBUFS);
d2351 1
a2351 5
	/* Check if we have enough free send BDs. */
	if (sc->bge_txcnt + dmamap->dm_nsegs >= BGE_TX_RING_CNT)
		goto fail_unload;

	for (i = 0; i < dmamap->dm_nsegs; i++) {
d2355 2
a2356 2
		BGE_HOSTADDR(f->bge_addr, dmamap->dm_segs[i].ds_addr);
		f->bge_len = dmamap->dm_segs[i].ds_len;
a2357 1
		f->bge_vlan_tag = 0;
d2359 1
a2359 1
		if (m_head->m_flags & M_VLANTAG) {
d2361 3
a2363 1
			f->bge_vlan_tag = m_head->m_pkthdr.ether_vtag;
d2366 6
d2374 1
a2376 6
	if (i < dmamap->dm_nsegs)
		goto fail_unload;

	bus_dmamap_sync(sc->bge_dmatag, dmamap, 0, dmamap->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

d2378 1
a2378 1
		goto fail_unload;
d2382 1
a2382 3
	SLIST_REMOVE_HEAD(&sc->txdma_list, link);
	sc->txdma[cur] = dma;
	sc->bge_txcnt += dmamap->dm_nsegs;
d2386 1
a2386 6
	return (0);

fail_unload:
	bus_dmamap_unload(sc->bge_dmatag, dmamap);

	return (ENOBUFS);
d2394 2
a2395 1
bge_start(struct ifnet *ifp)
d2398 3
a2400 3
	struct mbuf *m_head;
	u_int32_t prodidx;
	int pkts;
d2404 1
a2404 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
a2405 4
	if (!BGE_STS_BIT(sc, BGE_STS_LINK))
		return;

	prodidx = sc->bge_tx_prodidx;
d2407 1
a2407 5
	for (pkts = 0; !IFQ_IS_EMPTY(&ifp->if_snd);) {
		if (sc->bge_txcnt > BGE_TX_RING_CNT - 16) {
			ifp->if_flags |= IFF_OACTIVE;
			break;
		}
d2409 1
d2415 19
d2453 1
a2453 1
			bpf_mtap_ether(ifp->if_bpf, m_head, BPF_DIRECTION_OUT);
d2460 4
a2463 5
	bge_writembx(sc, BGE_MBX_TX_HOST_PROD0_LO, prodidx);
	if (BGE_CHIPREV(sc->bge_chipid) == BGE_CHIPREV_5700_BX)
		bge_writembx(sc, BGE_MBX_TX_HOST_PROD0_LO, prodidx);

	sc->bge_tx_prodidx = prodidx;
d2472 2
a2473 1
bge_init(void *xsc)
a2477 1
	u_int32_t rxmode;
d2480 1
a2480 1
	s = splnet();
d2484 5
d2504 5
a2508 7
	/* Specify MRU. */
	if (BGE_IS_JUMBO_CAPABLE(sc))
		CSR_WRITE_4(sc, BGE_RX_MTU,
			BGE_JUMBO_FRAMELEN + ETHER_VLAN_ENCAP_LEN);
	else
		CSR_WRITE_4(sc, BGE_RX_MTU,
			ETHER_MAX_LEN + ETHER_VLAN_ENCAP_LEN);
d2515 5
a2519 3
	if (!(ifp->if_capabilities & IFCAP_VLAN_HWTAGGING)) {
		/* Disable hardware decapsulation of VLAN frames. */
		BGE_SETBIT(sc, BGE_RX_MODE, BGE_RXMODE_RX_KEEP_VLAN_DIAG);
d2522 2
a2523 2
	/* Program promiscuous mode and multicast filters. */
	bge_iff(sc);
d2546 2
a2547 2
	/* Init Jumbo RX ring. */
	if (BGE_IS_JUMBO_CAPABLE(sc))
a2552 7
	/* Init our RX/TX stat counters. */
	sc->bge_tx_collisions = 0;
	sc->bge_rx_discards = 0;
	sc->bge_rx_inerrors = 0;
	sc->bge_rx_overruns = 0;
	sc->bge_tx_discards = 0;

a2558 5
	rxmode = BGE_RXMODE_ENABLE;

	if (BGE_IS_5755_PLUS(sc))
		rxmode |= BGE_RXMODE_RX_IPV6_CSUM_ENABLE;

d2560 1
a2560 3
	BGE_SETBIT(sc, BGE_RX_MODE, rxmode);

	CSR_WRITE_4(sc, BGE_MAX_RX_FRAME_LOWAT, 2);
d2568 1
a2568 1
	bge_writembx(sc, BGE_MBX_IRQ0_LO, 0);
d2577 1
a2577 1
	timeout_add_sec(&sc->bge_timeout, 1);
d2584 2
a2585 1
bge_ifmedia_upd(struct ifnet *ifp)
d2592 1
a2592 1
	if (sc->bge_flags & BGE_PHY_FIBER_TBI) {
d2594 1
a2594 1
			return (EINVAL);
a2596 20
			/*
			 * The BCM5704 ASIC appears to have a special
			 * mechanism for programming the autoneg
			 * advertisement registers in TBI mode.
			 */
			if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704) {
				u_int32_t sgdig;
				sgdig = CSR_READ_4(sc, BGE_SGDIG_STS);
				if (sgdig & BGE_SGDIGSTS_DONE) {
					CSR_WRITE_4(sc, BGE_TX_TBI_AUTONEG, 0);
					sgdig = CSR_READ_4(sc, BGE_SGDIG_CFG);
					sgdig |= BGE_SGDIGCFG_AUTO |
					    BGE_SGDIGCFG_PAUSE_CAP |
					    BGE_SGDIGCFG_ASYM_PAUSE;
					CSR_WRITE_4(sc, BGE_SGDIG_CFG,
					    sgdig | BGE_SGDIGCFG_SEND);
					DELAY(5);
					CSR_WRITE_4(sc, BGE_SGDIG_CFG, sgdig);
				}
			}
d2608 1
a2608 1
			return (EINVAL);
d2610 1
a2610 2
		/* XXX 802.3x flow control for 1000BASE-SX */
		return (0);
d2613 1
a2613 1
	BGE_STS_SETBIT(sc, BGE_STS_LINK_EVT);
d2616 2
a2617 1
		LIST_FOREACH(miisc, &mii->mii_phys, mii_list)
d2622 1
a2622 15
	/*
	 * Force an interrupt so that we will call bge_link_upd
	 * if needed and clear any pending link state attention.
	 * Without this we are not getting any further interrupts
	 * for link state changes and thus will not UP the link and
	 * not be able to send in bge_start. The only way to get
	 * things working was to receive a packet and get a RX intr.
	 */
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700 ||
	    sc->bge_flags & BGE_IS_5788)
		BGE_SETBIT(sc, BGE_MISC_LOCAL_CTL, BGE_MLC_INTR_SET);
	else
		BGE_SETBIT(sc, BGE_HCC_MODE, BGE_HCCMODE_COAL_NOW);

	return (0);
d2629 3
a2631 1
bge_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)
d2636 1
a2636 1
	if (sc->bge_flags & BGE_PHY_FIBER_TBI) {
d2640 1
a2640 1
		    BGE_MACSTAT_TBI_PCS_SYNCHED) {
a2641 4
		} else {
			ifmr->ifm_active |= IFM_NONE;
			return;
		}
d2651 1
a2652 2
	ifmr->ifm_active = (mii->mii_media_active & ~IFM_ETH_FMASK) |
	    sc->bge_flowflags;
d2656 4
a2659 1
bge_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
a2661 1
	struct ifaddr *ifa = (struct ifaddr *) data;
d2663 1
d2667 6
a2672 1
	s = splnet();
d2677 3
a2679 1
		if (!(ifp->if_flags & IFF_RUNNING))
a2680 2
#ifdef INET
		if (ifa->ifa_addr->sa_family == AF_INET)
d2682 1
d2684 12
a2696 1

d2699 19
a2717 3
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
d2720 1
a2720 1
			if (ifp->if_flags & IFF_RUNNING)
d2722 10
a2733 1

a2734 20
		/* XXX Flow control is not supported for 1000BASE-SX */
		if (sc->bge_flags & BGE_PHY_FIBER_TBI) {
			ifr->ifr_media &= ~IFM_ETH_FMASK;
			sc->bge_flowflags = 0;
		}

		/* Flow control requires full-duplex mode. */
		if (IFM_SUBTYPE(ifr->ifr_media) == IFM_AUTO ||
		    (ifr->ifr_media & IFM_FDX) == 0) {
		    	ifr->ifr_media &= ~IFM_ETH_FMASK;
		}
		if (IFM_SUBTYPE(ifr->ifr_media) != IFM_AUTO) {
			if ((ifr->ifr_media & IFM_ETH_FMASK) == IFM_FLOW) {
				/* We can do both TXPAUSE and RXPAUSE. */
				ifr->ifr_media |=
				    IFM_ETH_TXPAUSE | IFM_ETH_RXPAUSE;
			}
			sc->bge_flowflags = ifr->ifr_media & IFM_ETH_FMASK;
		}
		/* FALLTHROUGH */
d2736 1
a2736 1
		if (sc->bge_flags & BGE_PHY_FIBER_TBI) {
d2744 1
a2745 1

d2747 2
a2748 1
		error = ether_ioctl(ifp, &sc->arpcom, command, data);
d2751 1
a2751 5
	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			bge_iff(sc);
		error = 0;
	}
d2753 1
a2753 2
	splx(s);
	return (error);
d2757 2
a2758 1
bge_watchdog(struct ifnet *ifp)
d2766 1
a2771 17
void
bge_stop_block(struct bge_softc *sc, bus_size_t reg, u_int32_t bit)
{
	int i;

	BGE_CLRBIT(sc, reg, bit);

	for (i = 0; i < BGE_TIMEOUT; i++) {
		if ((CSR_READ_4(sc, reg) & bit) == 0)
			return;
		delay(100);
	}

	DPRINTFN(5, ("%s: block failed to stop: reg 0x%lx, bit 0x%08x\n",
	    sc->bge_dev.dv_xname, (u_long) reg, bit));
}

d2777 2
a2778 1
bge_stop(struct bge_softc *sc)
a2785 3
	timeout_del(&sc->bge_rxtimeout);

	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
d2790 8
a2797 8
	bge_stop_block(sc, BGE_RX_MODE, BGE_RXMODE_ENABLE);
	bge_stop_block(sc, BGE_RBDI_MODE, BGE_RBDIMODE_ENABLE);
	bge_stop_block(sc, BGE_RXLP_MODE, BGE_RXLPMODE_ENABLE);
	if (BGE_IS_5700_FAMILY(sc))
		bge_stop_block(sc, BGE_RXLS_MODE, BGE_RXLSMODE_ENABLE);
	bge_stop_block(sc, BGE_RDBDI_MODE, BGE_RBDIMODE_ENABLE);
	bge_stop_block(sc, BGE_RDC_MODE, BGE_RDCMODE_ENABLE);
	bge_stop_block(sc, BGE_RBDC_MODE, BGE_RBDCMODE_ENABLE);
d2802 8
a2809 8
	bge_stop_block(sc, BGE_SRS_MODE, BGE_SRSMODE_ENABLE);
	bge_stop_block(sc, BGE_SBDI_MODE, BGE_SBDIMODE_ENABLE);
	bge_stop_block(sc, BGE_SDI_MODE, BGE_SDIMODE_ENABLE);
	bge_stop_block(sc, BGE_RDMA_MODE, BGE_RDMAMODE_ENABLE);
	bge_stop_block(sc, BGE_SDC_MODE, BGE_SDCMODE_ENABLE);
	if (BGE_IS_5700_FAMILY(sc))
		bge_stop_block(sc, BGE_DMAC_MODE, BGE_DMACMODE_ENABLE);
	bge_stop_block(sc, BGE_SBDC_MODE, BGE_SBDCMODE_ENABLE);
d2815 4
a2818 5
	bge_stop_block(sc, BGE_HCC_MODE, BGE_HCCMODE_ENABLE);
	bge_stop_block(sc, BGE_WDMA_MODE, BGE_WDMAMODE_ENABLE);
	if (BGE_IS_5700_FAMILY(sc))
		bge_stop_block(sc, BGE_MBCF_MODE, BGE_MBCFMODE_ENABLE);

d2821 3
a2823 4

	if (BGE_IS_5700_FAMILY(sc)) {
		bge_stop_block(sc, BGE_BMAN_MODE, BGE_BMANMODE_ENABLE);
		bge_stop_block(sc, BGE_MARB_MODE, BGE_MARBMODE_ENABLE);
d2828 1
a2828 1
	bge_writembx(sc, BGE_MBX_IRQ0_LO, 1);
d2839 1
a2839 1
	if (BGE_IS_JUMBO_CAPABLE(sc))
d2850 1
a2850 1
	if (!(sc->bge_flags & BGE_PHY_FIBER_TBI)) {
d2862 2
d2866 1
a2866 2
	/* Clear MAC's link state (PHY may still have link UP). */
	BGE_STS_CLRBIT(sc, BGE_STS_LINK);
d2869 4
d2874 2
a2875 1
bge_link_upd(struct bge_softc *sc)
d2877 1
a2877 4
	struct ifnet *ifp = &sc->arpcom.ac_if;
	struct mii_data *mii = &sc->bge_mii;
	u_int32_t status;
	int link;
d2879 3
a2881 2
	/* Clear 'pending link event' flag */
	BGE_STS_CLRBIT(sc, BGE_STS_LINK_EVT);
d2883 3
a2885 16
	/*
	 * Process link state changes.
	 * Grrr. The link status word in the status block does
	 * not work correctly on the BCM5700 rev AX and BX chips,
	 * according to all available information. Hence, we have
	 * to enable MII interrupts in order to properly obtain
	 * async link changes. Unfortunately, this also means that
	 * we have to read the MAC status register to detect link
	 * changes, thereby adding an additional register access to
	 * the interrupt handler.
	 *
	 */
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700) {
		status = CSR_READ_4(sc, BGE_MAC_STS);
		if (status & BGE_MACSTAT_MI_INTERRUPT) {
			mii_pollstat(mii);
d2887 3
a2889 75
			if (!BGE_STS_BIT(sc, BGE_STS_LINK) &&
			    mii->mii_media_status & IFM_ACTIVE &&
			    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE)
				BGE_STS_SETBIT(sc, BGE_STS_LINK);
			else if (BGE_STS_BIT(sc, BGE_STS_LINK) &&
			    (!(mii->mii_media_status & IFM_ACTIVE) ||
			    IFM_SUBTYPE(mii->mii_media_active) == IFM_NONE))
				BGE_STS_CLRBIT(sc, BGE_STS_LINK);

			/* Clear the interrupt */
			CSR_WRITE_4(sc, BGE_MAC_EVT_ENB,
			    BGE_EVTENB_MI_INTERRUPT);
			bge_miibus_readreg(&sc->bge_dev, 1, BRGPHY_MII_ISR);
			bge_miibus_writereg(&sc->bge_dev, 1, BRGPHY_MII_IMR,
			    BRGPHY_INTRS);
		}
		return;
	} 

	if (sc->bge_flags & BGE_PHY_FIBER_TBI) {
		status = CSR_READ_4(sc, BGE_MAC_STS);
		if (status & BGE_MACSTAT_TBI_PCS_SYNCHED) {
			if (!BGE_STS_BIT(sc, BGE_STS_LINK)) {
				BGE_STS_SETBIT(sc, BGE_STS_LINK);
				if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704)
					BGE_CLRBIT(sc, BGE_MAC_MODE,
					    BGE_MACMODE_TBI_SEND_CFGS);
				CSR_WRITE_4(sc, BGE_MAC_STS, 0xFFFFFFFF);
				status = CSR_READ_4(sc, BGE_MAC_MODE);
				ifp->if_link_state =
				    (status & BGE_MACMODE_HALF_DUPLEX) ?
				    LINK_STATE_HALF_DUPLEX :
				    LINK_STATE_FULL_DUPLEX;
				if_link_state_change(ifp);
				ifp->if_baudrate = IF_Gbps(1);
			}
		} else if (BGE_STS_BIT(sc, BGE_STS_LINK)) {
			BGE_STS_CLRBIT(sc, BGE_STS_LINK);
			ifp->if_link_state = LINK_STATE_DOWN;
			if_link_state_change(ifp);
			ifp->if_baudrate = 0;
		}
        /*
	 * Discard link events for MII/GMII cards if MI auto-polling disabled.
	 * This should not happen since mii callouts are locked now, but
	 * we keep this check for debug.
	 */
	} else if (BGE_STS_BIT(sc, BGE_STS_AUTOPOLL)) {
		/* 
		 * Some broken BCM chips have BGE_STATFLAG_LINKSTATE_CHANGED bit
		 * in status word always set. Workaround this bug by reading
		 * PHY link status directly.
		 */
		link = (CSR_READ_4(sc, BGE_MI_STS) & BGE_MISTS_LINK)?
		    BGE_STS_LINK : 0;

		if (BGE_STS_BIT(sc, BGE_STS_LINK) != link) {
			mii_pollstat(mii);

			if (!BGE_STS_BIT(sc, BGE_STS_LINK) &&
			    mii->mii_media_status & IFM_ACTIVE &&
			    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE)
				BGE_STS_SETBIT(sc, BGE_STS_LINK);
			else if (BGE_STS_BIT(sc, BGE_STS_LINK) &&
			    (!(mii->mii_media_status & IFM_ACTIVE) ||
			    IFM_SUBTYPE(mii->mii_media_active) == IFM_NONE))
				BGE_STS_CLRBIT(sc, BGE_STS_LINK);
		}
	}

	/* Clear the attention */
	CSR_WRITE_4(sc, BGE_MAC_STS, BGE_MACSTAT_SYNC_CHANGED|
	    BGE_MACSTAT_CFG_CHANGED|BGE_MACSTAT_MI_COMPLETE|
	    BGE_MACSTAT_LINK_CHANGED);
}
@


1.4
log
@merge
@
text
@d1 1
a1 1
/*	$MirOS$	*/
a130 1
int bge_activate(struct device *, int);
d133 1
a133 1
	sizeof(struct bge_softc), bge_probe, bge_attach, NULL, bge_activate
d734 1
a734 1
	m = MCLGETI(NULL, M_DONTWAIT, &sc->arpcom.ac_if, MCLBYTES);
d737 6
a2305 25
int
bge_activate(struct device *self, int act)
{
	struct bge_softc *sc = (struct bge_softc *)self;
	struct ifnet *ifp = &sc->arpcom.ac_if;
	int rv = 0;

	switch (act) {
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
	case DVACT_SUSPEND:
		rv = config_activate_children(self, act);
		if (ifp->if_flags & IFF_RUNNING)
			bge_stop(sc);
		break;
	case DVACT_RESUME:
		if (ifp->if_flags & IFF_UP)
			bge_init(sc);
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

@


1.3
log
@size_t and ptrdiff_t fallout - kernel
@
text
@d1 3
a3 1
/*	$OpenBSD: if_bge.c,v 1.25 2004/04/12 06:56:42 brad Exp $	*/
d40 1
a40 1
 * Broadcom BCM570x family gigabit ethernet driver for FreeBSD.
d51 1
a51 1
 * SSRAM. The BCM5700 supports TCP, UDP and IP checksum offload, jumbo
d86 1
d110 5
d126 1
a126 1
/* #define BGE_CHECKSUM */
d128 1
d131 10
a140 1
void bge_release_resources(struct bge_softc *);
d147 1
d149 1
d155 1
a157 1
void bge_shutdown(void *);
d161 2
d166 6
a171 2
u_int32_t bge_crc(caddr_t);
void bge_setmulti(struct bge_softc *);
d173 1
a173 7
void bge_handle_events(struct bge_softc *);
int bge_alloc_jumbo_mem(struct bge_softc *);
void bge_free_jumbo_mem(struct bge_softc *);
void *bge_jalloc(struct bge_softc *);
void bge_jfree(caddr_t, u_int, void *);
int bge_newbuf_std(struct bge_softc *, int, struct mbuf *);
int bge_newbuf_jumbo(struct bge_softc *, int, struct mbuf *);
d175 2
d178 1
a178 2
int bge_init_rx_ring_jumbo(struct bge_softc *);
void bge_free_rx_ring_jumbo(struct bge_softc *);
d182 1
a182 1
int bge_chipinit(struct bge_softc *);
a184 6
#ifdef notdef
u_int8_t bge_vpd_readbyte(struct bge_softc *, int);
void bge_vpd_read_res(struct bge_softc *, struct vpd_res *, int);
void bge_vpd_read(struct bge_softc *);
#endif

a186 3
#ifdef notdef
u_int32_t bge_readreg_ind(struct bge_softc *, int);
#endif
d188 1
d195 1
a196 1
#define BGE_DEBUG
d198 2
a199 2
#define DPRINTF(x)	if (bgedebug) printf x
#define DPRINTFN(n,x)	if (bgedebug >= (n)) printf x
d218 1
d221 2
d226 1
d229 1
d233 1
d235 2
d239 34
d274 7
d282 1
d285 17
d305 106
a410 1
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C996 },
d414 1
a414 3
bge_readmem_ind(sc, off)
	struct bge_softc *sc;
	int off;
d423 1
a423 3
bge_writemem_ind(sc, off, val)
	struct bge_softc *sc;
	int off, val;
d431 2
a432 5
#ifdef notdef
u_int32_t
bge_readreg_ind(sc, off)
	struct bge_softc *sc;
	int off;
d437 1
a437 1
	return(pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_REG_DATA));
a438 1
#endif
d441 1
a441 3
bge_writereg_ind(sc, off, val)
	struct bge_softc *sc;
	int off, val;
d443 2
a444 1
	struct pci_attach_args	*pa = &(sc->bge_pa);
d446 1
a446 2
	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_REG_BASEADDR, off);
	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_REG_DATA, val);
a448 1
#ifdef notdef
d450 1
a450 3
bge_vpd_readbyte(sc, addr)
	struct bge_softc *sc;
	int addr;
d452 1
a453 2
	u_int32_t val;
	struct pci_attach_args	*pa = &(sc->bge_pa);
d455 16
a470 1
	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_VPD_ADDR, addr);
d473 2
a474 2
		if (pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_VPD_ADDR) &
		    BGE_VPD_FLAG)
d476 1
d479 3
a481 3
	if (i == BGE_TIMEOUT) {
		printf("%s: VPD read timed out\n", sc->bge_dev.dv_xname);
		return(0);
d484 4
a487 1
	val = pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_VPD_DATA);
d489 2
a490 2
	return((val >> ((addr % 4) * 8)) & 0xFF);
}
d492 3
a494 8
void
bge_vpd_read_res(sc, res, addr)
	struct bge_softc *sc;
	struct vpd_res *res;
	int addr;
{
	int i;
	u_int8_t *ptr;
d496 1
a496 3
	ptr = (u_int8_t *)res;
	for (i = 0; i < sizeof(struct vpd_res); i++)
		ptr[i] = bge_vpd_readbyte(sc, i + addr);
d499 6
a504 3
void
bge_vpd_read(sc)
	struct bge_softc *sc;
d506 2
a507 2
	int pos = 0, i;
	struct vpd_res res;
d509 2
a510 14
	if (sc->bge_vpd_prodname != NULL)
		free(sc->bge_vpd_prodname, M_DEVBUF);
	if (sc->bge_vpd_readonly != NULL)
		free(sc->bge_vpd_readonly, M_DEVBUF);
	sc->bge_vpd_prodname = NULL;
	sc->bge_vpd_readonly = NULL;

	bge_vpd_read_res(sc, &res, pos);

	if (res.vr_id != VPD_RES_ID) {
		printf("%s: bad VPD resource id: expected %x got %x\n",
			sc->bge_dev.dv_xname, VPD_RES_ID, res.vr_id);
		return;
	}
d512 5
a516 15
	pos += sizeof(res);
	sc->bge_vpd_prodname = malloc(res.vr_len + 1, M_DEVBUF, M_NOWAIT);
	if (sc->bge_vpd_prodname == NULL)
		panic("bge_vpd_read");
	for (i = 0; i < res.vr_len; i++)
		sc->bge_vpd_prodname[i] = bge_vpd_readbyte(sc, i + pos);
	sc->bge_vpd_prodname[i] = '\0';
	pos += i;

	bge_vpd_read_res(sc, &res, pos);

	if (res.vr_id != VPD_RES_READ) {
		printf("%s: bad VPD resource id: expected %x got %x\n",
		    sc->bge_dev.dv_xname, VPD_RES_READ, res.vr_id);
		return;
d519 1
a519 6
	pos += sizeof(res);
	sc->bge_vpd_readonly = malloc(res.vr_len, M_DEVBUF, M_NOWAIT);
	if (sc->bge_vpd_readonly == NULL)
		panic("bge_vpd_read");
	for (i = 0; i < res.vr_len + 1; i++)
		sc->bge_vpd_readonly[i] = bge_vpd_readbyte(sc, i + pos);
a520 1
#endif
d529 1
a529 4
bge_eeprom_getbyte(sc, addr, dest)
	struct bge_softc *sc;
	int addr;
	u_int8_t *dest;
d555 1
a555 1
	if (i == BGE_TIMEOUT) {
d557 1
a557 1
		return(0);
d565 1
a565 1
	return(0);
d572 1
a572 5
bge_read_eeprom(sc, dest, off, cnt)
	struct bge_softc *sc;
	caddr_t dest;
	int off;
	int cnt;
d584 1
a584 1
	return(err ? 1 : 0);
d588 1
a588 3
bge_miibus_readreg(dev, phy, reg)
	struct device *dev;
	int phy, reg;
d604 1
a604 1
		return(0);
d609 1
d617 2
a618 1
	for (i = 0; i < BGE_TIMEOUT; i++) {
d622 1
d625 1
a625 1
	if (i == BGE_TIMEOUT) {
d635 1
d641 1
a641 1
		return(0);
d643 1
a643 1
	return(val & 0xFFFF);
d647 1
a647 3
bge_miibus_writereg(dev, phy, reg, val)
	struct device *dev;
	int phy, reg, val;
d656 2
d659 1
a659 1
		DELAY(40);
d665 2
a666 1
	for (i = 0; i < BGE_TIMEOUT; i++) {
d669 1
d673 1
d678 1
a678 1
	if (i == BGE_TIMEOUT) {
d684 1
a684 2
bge_miibus_statchg(dev)
	struct device *dev;
d689 9
d699 2
a700 1
	if (IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_T) {
d702 1
a702 1
	} else {
a703 1
	}
d705 1
a705 1
	if ((mii->mii_media_active & IFM_GMASK) == IFM_FDX) {
d707 1
a707 1
	} else {
a708 2
	}
}
d710 7
a716 7
/*
 * Handle events that have triggered interrupts.
 */
void
bge_handle_events(sc)
	struct bge_softc		*sc;
{
d718 4
a721 1
	return;
d725 1
a725 1
 * Memory management for jumbo frames.
a726 1

d728 1
a728 2
bge_alloc_jumbo_mem(sc)
	struct bge_softc		*sc;
d730 4
a733 4
	caddr_t			ptr, kva;
	bus_dma_segment_t	seg;
	int		i, rseg;
	struct bge_jpool_entry   *entry;
d735 2
a736 18
	/* Grab a big chunk o' storage. */
	if (bus_dmamem_alloc(sc->bge_dmatag, BGE_JMEM, PAGE_SIZE, 0,
			     &seg, 1, &rseg, BUS_DMA_NOWAIT)) {
		printf("%s: can't alloc rx buffers\n", sc->bge_dev.dv_xname);
		return (ENOBUFS);
	}
	if (bus_dmamem_map(sc->bge_dmatag, &seg, rseg, BGE_JMEM, &kva,
			   BUS_DMA_NOWAIT)) {
		printf("%s: can't map dma buffers (%ld bytes)\n",
		    sc->bge_dev.dv_xname, BGE_JMEM);
		bus_dmamem_free(sc->bge_dmatag, &seg, rseg);
		return (ENOBUFS);
	}
	if (bus_dmamap_create(sc->bge_dmatag, BGE_JMEM, 1, BGE_JMEM, 0,
	    BUS_DMA_NOWAIT, &sc->bge_cdata.bge_rx_jumbo_map)) {
		printf("%s: can't create dma map\n", sc->bge_dev.dv_xname);
		bus_dmamem_unmap(sc->bge_dmatag, kva, BGE_JMEM);
		bus_dmamem_free(sc->bge_dmatag, &seg, rseg);
d738 8
a745 8
	}
	if (bus_dmamap_load(sc->bge_dmatag, sc->bge_cdata.bge_rx_jumbo_map,
			    kva, BGE_JMEM, NULL, BUS_DMA_NOWAIT)) {
		printf("%s: can't load dma map\n", sc->bge_dev.dv_xname);
		bus_dmamap_destroy(sc->bge_dmatag,
				   sc->bge_cdata.bge_rx_jumbo_map);
		bus_dmamem_unmap(sc->bge_dmatag, kva, BGE_JMEM);
		bus_dmamem_free(sc->bge_dmatag, &seg, rseg);
a747 33
	sc->bge_cdata.bge_jumbo_buf = (caddr_t)kva;
	DPRINTFN(1,("bge_jumbo_buf = 0x%08X\n", (unsigned int)
	    sc->bge_cdata.bge_jumbo_buf));

	LIST_INIT(&sc->bge_jfree_listhead);
	LIST_INIT(&sc->bge_jinuse_listhead);

	/*
	 * Now divide it up into 9K pieces and save the addresses
	 * in an array.
	 */
	ptr = sc->bge_cdata.bge_jumbo_buf;
	for (i = 0; i < BGE_JSLOTS; i++) {
		sc->bge_cdata.bge_jslots[i] = ptr;
		ptr += BGE_JLEN;
		entry = malloc(sizeof(struct bge_jpool_entry),
		    M_DEVBUF, M_NOWAIT);
		if (entry == NULL) {
			bus_dmamap_unload(sc->bge_dmatag,
					  sc->bge_cdata.bge_rx_jumbo_map);
			bus_dmamap_destroy(sc->bge_dmatag,
					   sc->bge_cdata.bge_rx_jumbo_map);
			bus_dmamem_unmap(sc->bge_dmatag, kva, BGE_JMEM);
			bus_dmamem_free(sc->bge_dmatag, &seg, rseg);
			sc->bge_cdata.bge_jumbo_buf = NULL;
			printf("%s: no memory for jumbo buffer queue!\n",
			    sc->bge_dev.dv_xname);
			return(ENOBUFS);
		}
		entry->slot = i;
		LIST_INSERT_HEAD(&sc->bge_jfree_listhead,
				 entry, jpool_entries);
	}
d749 9
a757 2
	return(0);
}
d759 4
a762 8
/*
 * Allocate a jumbo buffer.
 */
void *
bge_jalloc(sc)
	struct bge_softc		*sc;
{
	struct bge_jpool_entry   *entry;
d764 5
a768 1
	entry = LIST_FIRST(&sc->bge_jfree_listhead);
d770 1
a770 4
	if (entry == NULL) {
		printf("%s: no free jumbo buffers\n", sc->bge_dev.dv_xname);
		return(NULL);
	}
d772 1
a772 3
	LIST_REMOVE(entry, jpool_entries);
	LIST_INSERT_HEAD(&sc->bge_jinuse_listhead, entry, jpool_entries);
	return(sc->bge_cdata.bge_jslots[entry->slot]);
d776 1
a776 1
 * Release a jumbo buffer.
d778 2
a779 5
void
bge_jfree(buf, size, arg)
	caddr_t		buf;
	u_int		size;
	void		*arg;
d781 18
a798 3
	struct bge_jpool_entry *entry;
	struct bge_softc *sc;
	int i;
d800 36
a835 2
	/* Extract the softc struct pointer. */
	sc = (struct bge_softc *)arg;
d837 5
a841 2
	if (sc == NULL)
		panic("bge_jfree: can't find softc pointer!");
d843 1
a843 1
	/* calculate the slot this buffer belongs to */
d845 1
a845 12
	i = ((vaddr_t)buf
	     - (vaddr_t)sc->bge_cdata.bge_jumbo_buf) / BGE_JLEN;

	if ((i < 0) || (i >= BGE_JSLOTS))
		panic("bge_jfree: asked to free buffer that we don't manage!");

	entry = LIST_FIRST(&sc->bge_jinuse_listhead);
	if (entry == NULL)
		panic("bge_jfree: buffer not in use!");
	entry->slot = i;
	LIST_REMOVE(entry, jpool_entries);
	LIST_INSERT_HEAD(&sc->bge_jfree_listhead, entry, jpool_entries);
a847 1

d849 4
a852 1
 * Intialize a standard receive ring descriptor.
d855 1
a855 4
bge_newbuf_std(sc, i, m)
	struct bge_softc	*sc;
	int			i;
	struct mbuf		*m;
d857 12
a868 14
	struct mbuf		*m_new = NULL;
	struct bge_rx_bd	*r;
	bus_dmamap_t		rxmap = sc->bge_cdata.bge_rx_std_map[i];

	if (m == NULL) {
		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL) {
			return(ENOBUFS);
		}

		MCLGET(m_new, M_DONTWAIT);
		if (!(m_new->m_flags & M_EXT)) {
			m_freem(m_new);
			return(ENOBUFS);
d870 2
a871 5
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
	} else {
		m_new = m;
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
		m_new->m_data = m_new->m_ext.ext_buf;
d874 3
a876 31
	if (bus_dmamap_load_mbuf(sc->bge_dmatag, rxmap, m_new, BUS_DMA_NOWAIT))
		return(ENOBUFS);

	if (!sc->bge_rx_alignment_bug)
		m_adj(m_new, ETHER_ALIGN);
	sc->bge_cdata.bge_rx_std_chain[i] = m_new;
	r = &sc->bge_rdata->bge_rx_std_ring[i];
	BGE_HOSTADDR(r->bge_addr, rxmap->dm_segs[0].ds_addr +
	    (sc->bge_rx_alignment_bug ? 0 : ETHER_ALIGN));
	r->bge_flags = BGE_RXBDFLAG_END;
	r->bge_len = m_new->m_len;
	r->bge_idx = i;

	return(0);
}

/*
 * Initialize a jumbo receive ring descriptor. This allocates
 * a jumbo buffer from the pool managed internally by the driver.
 */
int
bge_newbuf_jumbo(sc, i, m)
	struct bge_softc *sc;
	int i;
	struct mbuf *m;
{
	struct mbuf *m_new = NULL;
	struct bge_rx_bd *r;

	if (m == NULL) {
		caddr_t			*buf = NULL;
d878 1
a878 5
		/* Allocate the mbuf. */
		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL) {
			return(ENOBUFS);
		}
d880 1
a880 6
		/* Allocate the jumbo buffer */
		buf = bge_jalloc(sc);
		if (buf == NULL) {
			m_freem(m_new);
			return(ENOBUFS);
		}
d882 4
a885 7
		/* Attach the buffer to the mbuf. */
		m_new->m_len = m_new->m_pkthdr.len = BGE_JUMBO_FRAMELEN;
		MEXTADD(m_new, buf, BGE_JUMBO_FRAMELEN, 0, bge_jfree, sc);
	} else {
		m_new = m;
		m_new->m_data = m_new->m_ext.ext_buf;
		m_new->m_ext.ext_size = BGE_JUMBO_FRAMELEN;
d887 2
d890 5
a894 10
	if (!sc->bge_rx_alignment_bug)
		m_adj(m_new, ETHER_ALIGN);
	/* Set up the descriptor. */
	r = &sc->bge_rdata->bge_rx_jumbo_ring[i];
	sc->bge_cdata.bge_rx_jumbo_chain[i] = m_new;
	BGE_HOSTADDR(r->bge_addr, BGE_JUMBO_DMA_ADDR(sc, m_new) +
	    (sc->bge_rx_alignment_bug ? 0 : ETHER_ALIGN));
	r->bge_flags = BGE_RXBDFLAG_END|BGE_RXBDFLAG_JUMBO_RING;
	r->bge_len = m_new->m_len;
	r->bge_idx = i;
d896 8
a903 1
	return(0);
d906 2
a907 9
/*
 * The standard receive ring has 512 entries in it. At 2K per mbuf cluster,
 * that's 1MB or memory, which is a lot. For now, we fill only the first
 * 256 ring entries and hope that our CPU is fast enough to keep up with
 * the NIC.
 */
int
bge_init_rx_ring_std(sc)
	struct bge_softc *sc;
d910 5
d916 2
a917 5
	for (i = 0; i < BGE_STD_RX_RING_CNT; i++) {
		if (bus_dmamap_create(sc->bge_dmatag, MCLBYTES, 1, MCLBYTES,
		    0, BUS_DMA_NOWAIT, &sc->bge_cdata.bge_rx_std_map[i]))
			return(ENOBUFS);
	}
d919 2
a920 3
	for (i = 0; i < BGE_SSLOTS; i++) {
		if (bge_newbuf_std(sc, i, NULL) == ENOBUFS)
			return(ENOBUFS);
d923 2
a924 2
	sc->bge_std = i - 1;
	CSR_WRITE_4(sc, BGE_MBX_RX_STD_PROD_LO, sc->bge_std);
d926 6
a931 1
	return(0);
d935 1
a935 2
bge_free_rx_ring_std(sc)
	struct bge_softc *sc;
d937 2
d941 3
d945 7
a951 2
		if (sc->bge_cdata.bge_rx_std_chain[i] != NULL) {
			m_freem(sc->bge_cdata.bge_rx_std_chain[i]);
a952 2
			bus_dmamap_unload(sc->bge_dmatag,
					  sc->bge_cdata.bge_rx_std_map[i]);
d954 3
a956 1
		bzero((char *)&sc->bge_rdata->bge_rx_std_ring[i],
d959 2
d964 1
a964 2
bge_init_rx_ring_jumbo(sc)
	struct bge_softc *sc;
d966 1
d968 3
a970 1
	struct bge_rcb *rcb;
d973 14
a986 3
		if (bge_newbuf_jumbo(sc, i, NULL) == ENOBUFS)
			return(ENOBUFS);
	};
d988 1
a988 1
	sc->bge_jumbo = i - 1;
d991 2
a992 1
	rcb->bge_maxlen_flags = BGE_RCB_MAXLEN_FLAGS(0, 0);
d995 29
a1023 1
	CSR_WRITE_4(sc, BGE_MBX_RX_JUMBO_PROD_LO, sc->bge_jumbo);
d1025 6
a1030 1
	return(0);
d1034 1
a1034 2
bge_free_rx_ring_jumbo(sc)
	struct bge_softc *sc;
d1036 2
d1040 3
d1044 7
a1050 2
		if (sc->bge_cdata.bge_rx_jumbo_chain[i] != NULL) {
			m_freem(sc->bge_cdata.bge_rx_jumbo_chain[i]);
d1053 4
a1056 2
		bzero((char *)&sc->bge_rdata->bge_rx_jumbo_ring[i],
		    sizeof(struct bge_rx_bd));
d1058 2
d1063 1
a1063 2
bge_free_tx_ring(sc)
	struct bge_softc *sc;
d1066 1
d1068 1
a1068 1
	if (sc->bge_rdata->bge_tx_ring == NULL)
d1075 3
a1077 2
			bus_dmamap_unload(sc->bge_dmatag,
					  sc->bge_cdata.bge_tx_map[i]);
d1079 1
a1079 1
		bzero((char *)&sc->bge_rdata->bge_tx_ring[i],
d1082 8
d1093 1
a1093 2
bge_init_tx_ring(sc)
	struct bge_softc *sc;
d1096 5
d1105 10
a1114 9
	CSR_WRITE_4(sc, BGE_MBX_TX_HOST_PROD0_LO, 0);
	/* 5700 b2 errata */
	if (sc->bge_chiprev == BGE_CHIPREV_5700_BX)
		CSR_WRITE_4(sc, BGE_MBX_TX_HOST_PROD0_LO, 0);

	CSR_WRITE_4(sc, BGE_MBX_TX_NIC_PROD0_LO, 0);
	/* 5700 b2 errata */
	if (sc->bge_chiprev == BGE_CHIPREV_5700_BX)
		CSR_WRITE_4(sc, BGE_MBX_TX_NIC_PROD0_LO, 0);
d1116 1
d1118 15
a1132 3
		if (bus_dmamap_create(sc->bge_dmatag, MCLBYTES, BGE_NTXSEG,
		    MCLBYTES, 0, BUS_DMA_NOWAIT, &sc->bge_cdata.bge_tx_map[i]))
			return(ENOBUFS);
d1135 1
a1135 18
	return(0);
}

#define BGE_POLY	0xEDB88320

u_int32_t
bge_crc(addr)
	caddr_t addr;
{
	u_int32_t idx, bit, data, crc;

	/* Compute CRC for the address value. */
	crc = 0xFFFFFFFF; /* initial value */

	for (idx = 0; idx < 6; idx++) {
		for (data = *addr++, bit = 0; bit < 8; bit++, data >>= 1)
			crc = (crc >> 1) ^ (((crc ^ data) & 1) ? BGE_POLY : 0);
	}
d1137 1
a1137 1
	return(crc & 0x7F);
d1141 1
a1141 2
bge_setmulti(sc)
	struct bge_softc *sc;
d1147 7
a1153 3
	u_int32_t		hashes[4] = { 0, 0, 0, 0 };
	u_int32_t		h;
	int			i;
d1155 10
a1164 5
	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
		for (i = 0; i < 4; i++)
			CSR_WRITE_4(sc, BGE_MAR0 + (i * 4), 0xFFFFFFFF);
		return;
	}
d1166 1
a1166 3
	/* First, zot all the existing filters. */
	for (i = 0; i < 4; i++)
		CSR_WRITE_4(sc, BGE_MAR0 + (i * 4), 0);
d1168 2
a1169 6
	/* Now program new ones. */
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		h = bge_crc(LLADDR((struct sockaddr_dl *)enm->enm_addrlo));
		hashes[(h & 0x60) >> 5] |= 1 << (h & 0x1F);
		ETHER_NEXT_MULTI(step, enm);
d1172 3
a1174 2
	for (i = 0; i < 4; i++)
		CSR_WRITE_4(sc, BGE_MAR0 + (i * 4), hashes[i]);
d1178 1
a1178 2
 * Do endian, PCI and DMA initialization. Also check the on-board ROM
 * self-test results.
d1180 2
a1181 3
int
bge_chipinit(sc)
	struct bge_softc *sc;
a1186 5
#ifdef BGE_CHECKSUM
	sc->arpcom.ac_if.if_capabilities =
	  IFCAP_CSUM_IPv4 | IFCAP_CSUM_TCPv4 | IFCAP_CSUM_UDPv4;
#endif

a1187 1
#if BYTE_ORDER == BIG_ENDIAN
d1189 1
a1189 5
	    BGE_BIGENDIAN_INIT);
#else
	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_MISC_CTL,
	    BGE_LITTLEENDIAN_INIT);
#endif
d1191 1
a1191 11
	/*
	 * Check the 'ROM failed' bit on the RX CPU to see if
	 * self-tests passed.
	 */
	if (CSR_READ_4(sc, BGE_RXCPU_MODE) & BGE_RXCPUMODE_ROMFAIL) {
		printf("%s: RX CPU self-diagnostics failed!\n",
		    sc->bge_dev.dv_xname);
		return(ENODEV);
	}

	/* Clear the MAC control register */
d1206 10
a1215 9
	/* Set up the PCI DMA control register. */
	if (pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_PCISTATE) &
	    BGE_PCISTATE_PCI_BUSMODE) {
		/* Conventional PCI bus */
		dma_rw_ctl = BGE_PCI_READ_CMD | BGE_PCI_WRITE_CMD |
		    (0x7 << BGE_PCIDMARWCTL_RD_WAT_SHIFT) |
		    (0x7 << BGE_PCIDMARWCTL_WR_WAT_SHIFT) |
		    (0x0f);
	} else {
d1217 17
a1233 12
		/*
		 * The 5704 uses a different encoding of read/write
		 * watermarks.
		 */
		if (BGE_ASICREV(sc->bge_asicrev) == BGE_ASICREV_BCM5704)
			dma_rw_ctl = BGE_PCI_READ_CMD|BGE_PCI_WRITE_CMD |
			    (0x7 << BGE_PCIDMARWCTL_RD_WAT_SHIFT) |
			    (0x3 << BGE_PCIDMARWCTL_WR_WAT_SHIFT);
		else
			dma_rw_ctl = BGE_PCI_READ_CMD|BGE_PCI_WRITE_CMD |
			    (0x3 << BGE_PCIDMARWCTL_RD_WAT_SHIFT) |
			    (0x3 << BGE_PCIDMARWCTL_WR_WAT_SHIFT) |
d1235 1
d1237 2
a1238 6
		/*
		 * 5703 and 5704 need ONEDMA_AT_ONCE as a workaround
		 * for hardware bugs.
		 */
		if (sc->bge_asicrev == BGE_ASICREV_BCM5703 ||
		    sc->bge_asicrev == BGE_ASICREV_BCM5704) {
d1241 1
d1243 6
a1248 2
			if (tmp == 0x6 || tmp == 0x7)
				dma_rw_ctl |= BGE_PCIDMARWCTL_ONEDMA_ATONCE;
d1250 14
a1263 1
 	}
d1265 2
a1266 3
	if (sc->bge_asicrev == BGE_ASICREV_BCM5703 ||
	    sc->bge_asicrev == BGE_ASICREV_BCM5704 ||
	    sc->bge_asicrev == BGE_ASICREV_BCM5705)
d1274 1
a1274 3
#ifndef BGE_CHECKSUM
	CSR_WRITE_4(sc, BGE_MODE_CTL, BGE_MODECTL_WORDSWAP_NONFRAME|
		    BGE_MODECTL_BYTESWAP_DATA|BGE_MODECTL_WORDSWAP_DATA|
d1276 11
a1286 6
		    BGE_MODECTL_TX_NO_PHDR_CSUM|BGE_MODECTL_RX_NO_PHDR_CSUM);
#else
	CSR_WRITE_4(sc, BGE_MODE_CTL, BGE_MODECTL_WORDSWAP_NONFRAME|
		    BGE_MODECTL_BYTESWAP_DATA|BGE_MODECTL_WORDSWAP_DATA|
		    BGE_MODECTL_MAC_ATTN_INTR|BGE_MODECTL_HOST_SEND_BDS);
#endif
d1309 8
a1316 1
	return(0);
d1320 1
a1320 2
bge_blockinit(sc)
	struct bge_softc *sc;
d1322 1
a1322 1
	struct bge_rcb		*rcb;
d1325 2
d1336 9
a1344 1
	/* Note: the BCM5704 has a smaller bmuf space than the other chips */
a1345 7
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705) {
		/* Configure mbuf memory pool */
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_BASEADDR,
		    (sc->bge_extram) ? BGE_EXT_SSRAM : BGE_BUFFPOOL_1);
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_LEN,
		    (sc->bge_asicrev == BGE_ASICREV_BCM5704) ? 0x10000:0x18000);
 
d1353 7
a1359 1
	if (sc->bge_asicrev == BGE_ASICREV_BCM5705) {
d1361 8
a1368 1
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_MACRX_LOWAT, 0x10);
d1372 1
a1373 1
	CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_HIWAT, 0x60);
d1380 2
a1381 3
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705) {
		CSR_WRITE_4(sc, BGE_BMAN_MODE,
		    BGE_BMANMODE_ENABLE|BGE_BMANMODE_LOMBUF_ATTN);
d1383 6
a1388 6
		/* Poll for buffer manager start indication */
		for (i = 0; i < BGE_TIMEOUT; i++) {
			if (CSR_READ_4(sc, BGE_BMAN_MODE) & BGE_BMANMODE_ENABLE)
				break;
			DELAY(10);
		}
d1390 4
a1393 5
		if (i == BGE_TIMEOUT) {
			printf("%s: buffer manager failed to start\n",
			    sc->bge_dev.dv_xname);
			return(ENXIO);
		}
d1401 1
a1401 1
	for (i = 0; i < BGE_TIMEOUT; i++) {
d1407 1
a1407 1
	if (i == BGE_TIMEOUT) {
d1410 1
a1410 1
		return(ENXIO);
d1416 5
a1420 1
	if (sc->bge_asicrev == BGE_ASICREV_BCM5705)
d1424 2
a1425 5
		    BGE_RCB_MAXLEN_FLAGS(BGE_MAX_FRAMELEN, 0);
	if (sc->bge_extram)
		rcb->bge_nicaddr = BGE_EXT_STD_RX_RINGS;
	else
		rcb->bge_nicaddr = BGE_STD_RX_RINGS;
d1432 1
a1432 1
	 * Initialize the jumbo RX ring control block
d1438 1
a1438 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705) {
d1442 3
a1444 7
		rcb->bge_maxlen_flags =
		    BGE_RCB_MAXLEN_FLAGS(BGE_MAX_FRAMELEN,
		        BGE_RCB_FLAG_RING_DISABLED);
		if (sc->bge_extram)
			rcb->bge_nicaddr = BGE_EXT_JUMBO_RX_RINGS;
		else
			rcb->bge_nicaddr = BGE_JUMBO_RX_RINGS;
d1461 14
a1475 1

d1477 1
a1477 1
	 * Set the BD ring replentish thresholds. The recommended
d1479 13
a1491 4
	 * each ring.
	 */
	CSR_WRITE_4(sc, BGE_RBDI_STD_REPL_THRESH, BGE_STD_RX_RING_CNT/8);
	CSR_WRITE_4(sc, BGE_RBDI_JUMBO_REPL_THRESH, BGE_JUMBO_RX_RING_CNT/8);
d1508 3
a1510 3
	RCB_WRITE_4(sc, rcb_addr, bge_hostaddr.bge_addr_hi, 0);
	RCB_WRITE_4(sc, rcb_addr, bge_hostaddr.bge_addr_lo,
		    BGE_RING_DMA_ADDR(sc, bge_tx_ring));
d1513 1
a1513 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
d1526 1
a1526 1
		CSR_WRITE_4(sc, BGE_MBX_RX_CONS0_LO +
d1532 3
a1534 3
	CSR_WRITE_4(sc, BGE_MBX_RX_STD_PROD_LO, 0);
	CSR_WRITE_4(sc, BGE_MBX_RX_JUMBO_PROD_LO, 0);
	CSR_WRITE_4(sc, BGE_MBX_RX_MINI_PROD_LO, 0);
d1543 3
a1545 3
	RCB_WRITE_4(sc, rcb_addr, bge_hostaddr.bge_addr_hi, 0);
	RCB_WRITE_4(sc, rcb_addr, bge_hostaddr.bge_addr_lo,
		    BGE_RING_DMA_ADDR(sc, bge_rx_return_ring));
d1580 1
a1580 1
	for (i = 0; i < BGE_TIMEOUT; i++) {
d1586 1
a1586 1
	if (i == BGE_TIMEOUT) {
d1589 1
a1589 1
		return(ENXIO);
d1597 1
a1597 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705) {
d1605 1
a1605 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705) {
d1616 3
a1618 3
	CSR_WRITE_4(sc, BGE_HCC_STATUSBLK_ADDR_HI, 0);
	CSR_WRITE_4(sc, BGE_HCC_STATUSBLK_ADDR_LO,
		    BGE_RING_DMA_ADDR(sc, bge_status_block));
d1634 1
a1634 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
d1637 12
d1650 1
a1650 5
	CSR_WRITE_4(sc, BGE_MAC_MODE, BGE_MACMODE_TXDMA_ENB|
	    BGE_MACMODE_RXDMA_ENB|BGE_MACMODE_RX_STATS_CLEAR|
	    BGE_MACMODE_TX_STATS_CLEAR|BGE_MACMODE_RX_STATS_ENB|
	    BGE_MACMODE_TX_STATS_ENB|BGE_MACMODE_FRMHDR_DMA_ENB|
	    (sc->bge_tbi ? BGE_PORTMODE_TBI : BGE_PORTMODE_MII));
d1664 1
a1664 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
d1667 9
d1677 16
a1692 2
	CSR_WRITE_4(sc, BGE_WDMA_MODE,
	    BGE_WDMAMODE_ENABLE|BGE_WDMAMODE_ALL_ATTNS);
d1695 1
a1695 2
	CSR_WRITE_4(sc, BGE_RDMA_MODE,
	    BGE_RDMAMODE_ENABLE|BGE_RDMAMODE_ALL_ATTNS);
d1707 1
a1707 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
d1713 5
d1719 1
a1719 1
	CSR_WRITE_4(sc, BGE_SDC_MODE, BGE_SDCMODE_ENABLE);
d1740 1
a1740 1
	if (sc->bge_tbi) {
d1743 1
d1745 1
a1745 1
		if (sc->bge_asicrev == BGE_ASICREV_BCM5700)
d1750 11
d1764 19
a1782 1
	return(0);
d1794 1
a1794 4
bge_probe(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d1796 1
a1796 2
	return (pci_matchbyid((struct pci_attach_args *)aux, bge_devices,
	    sizeof(bge_devices)/sizeof(bge_devices[0])));
d1800 1
a1800 3
bge_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d1805 2
d1809 1
a1809 2
	bus_addr_t		iobase;
	bus_size_t		iosize;
d1811 1
a1811 1
	int			s, rseg;
d1814 1
a1814 1
	u_int32_t		command;
a1815 1
	int			error = 0;
d1817 3
d1821 1
a1821 1
	s = splimp();
d1823 1
a1823 1
	sc->bge_pa = *pa;
a1828 11
	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	command |= PCI_COMMAND_MEM_ENABLE | PCI_COMMAND_MASTER_ENABLE;
	pci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);
	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);

	if (!(command & PCI_COMMAND_MEM_ENABLE)) {
		printf("%s: failed to enable memory mapping!\n",
		    sc->bge_dev.dv_xname);
		error = ENXIO;
		goto fail;
	}
d1830 4
a1833 3
	DPRINTFN(5, ("pci_mem_find\n"));
	if (pci_mem_find(pc, pa->pa_tag, BGE_PCI_BAR0, &iobase,
			 &iosize, NULL)) {
d1835 1
a1835 7
		goto fail;
	}

	DPRINTFN(5, ("bus_space_map\n"));
	if (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->bge_bhandle)) {
		printf(": can't map mem space\n");
		goto fail;
a1837 2
	sc->bge_btag = pa->pa_memt;

d1841 1
a1841 1
		goto fail;
d1847 112
a1958 3
	DPRINTFN(5, ("pci_intr_establish\n"));
	sc->bge_intrhand = pci_intr_establish(pc, ih, IPL_NET, bge_intr, sc,
	    sc->bge_dev.dv_xname);
d1960 76
a2035 6
	if (sc->bge_intrhand == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		goto fail;
a2036 1
	printf(": %s", intrstr);
d2042 7
a2048 6
	if (bge_chipinit(sc)) {
		printf("%s: chip initialization failed\n",
		    sc->bge_dev.dv_xname);
		bge_release_resources(sc);
		error = ENXIO;
		goto fail;
d2050 1
d2055 27
a2081 15
	mac_addr = bge_readmem_ind(sc, 0x0c14);
	if ((mac_addr >> 16) == 0x484b) {
		sc->arpcom.ac_enaddr[0] = (u_char)(mac_addr >> 8);
		sc->arpcom.ac_enaddr[1] = (u_char)mac_addr;
		mac_addr = bge_readmem_ind(sc, 0x0c18);
		sc->arpcom.ac_enaddr[2] = (u_char)(mac_addr >> 24);
		sc->arpcom.ac_enaddr[3] = (u_char)(mac_addr >> 16);
		sc->arpcom.ac_enaddr[4] = (u_char)(mac_addr >> 8);
		sc->arpcom.ac_enaddr[5] = (u_char)mac_addr;
	} else if (bge_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,
	    BGE_EE_MAC_OFFSET + 2, ETHER_ADDR_LEN)) {
		printf("%s: failed to read station address\n", sc->bge_dev.dv_xname);
		bge_release_resources(sc);
		error = ENXIO;
		goto fail;
d2084 13
a2096 5
	/*
	 * A Broadcom chip was detected. Inform the world.
	 */
	printf(": address: %s\n",
	    ether_sprintf(sc->arpcom.ac_enaddr));
d2103 2
a2104 2
		printf("%s: can't alloc rx buffers\n", sc->bge_dev.dv_xname);
		goto fail;
d2110 3
a2112 4
		printf("%s: can't map dma buffers (%d bytes)\n",
		    sc->bge_dev.dv_xname, (int)sizeof(struct bge_ring_data));
		bus_dmamem_free(sc->bge_dmatag, &seg, rseg);
		goto fail;
d2118 2
a2119 5
		printf("%s: can't create dma map\n", sc->bge_dev.dv_xname);
		bus_dmamem_unmap(sc->bge_dmatag, kva,
				 sizeof(struct bge_ring_data));
		bus_dmamem_free(sc->bge_dmatag, &seg, rseg);
		goto fail;
d2125 1
a2125 5
		bus_dmamap_destroy(sc->bge_dmatag, sc->bge_ring_map);
		bus_dmamem_unmap(sc->bge_dmatag, kva,
				 sizeof(struct bge_ring_data));
		bus_dmamem_free(sc->bge_dmatag, &seg, rseg);
		goto fail;
a2132 21
	/* Save ASIC rev. */

	sc->bge_chipid =
	    pci_conf_read(pc, pa->pa_tag, BGE_PCI_MISC_CTL) &
	    BGE_PCIMISCCTL_ASICREV;
	sc->bge_asicrev = BGE_ASICREV(sc->bge_chipid);
	sc->bge_chiprev = BGE_CHIPREV(sc->bge_chipid);

	/*
	 * Try to allocate memory for jumbo buffers.
	 * The 5705 does not appear to support jumbo frames.
	 */
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705) {
		if (bge_alloc_jumbo_mem(sc)) {
			printf("%s: jumbo buffer allocation failed\n",
			    sc->bge_dev.dv_xname);
			error = ENXIO;
			goto fail;
		}
	}

a2135 1
	sc->bge_tx_coal_ticks = 150;
d2137 2
a2138 1
	sc->bge_tx_max_coal_bds = 128;
d2141 5
a2145 1
	if (sc->bge_asicrev == BGE_ASICREV_BCM5705)
a2146 2
	else
		sc->bge_return_ring_cnt = BGE_RETURN_RING_CNT;
a2152 1
	ifp->if_output = ether_output;
a2154 2
	ifp->if_baudrate = 1000000000;
	ifp->if_mtu = ETHERMTU;
d2157 5
d2165 19
d2203 6
a2208 3
	else {
		bge_read_eeprom(sc, (caddr_t)&hwcfg, BGE_EE_HWCFG_OFFSET,
		    sizeof(hwcfg));
a2210 3
	
	if ((hwcfg & BGE_HWCFG_MEDIA) == BGE_MEDIA_FIBER)	    
		sc->bge_tbi = 1;
d2213 26
a2238 3
	if ((pci_conf_read(pc, pa->pa_tag, BGE_PCI_SUBSYS) >> 16) ==
	    SK_SUBSYSID_9D41)
		sc->bge_tbi = 1;
d2240 1
a2240 1
	if (sc->bge_tbi) {
d2248 1
d2250 2
d2257 3
d2261 1
a2261 1
			   MII_PHY_ANY, MII_OFFSET_ANY, 0);
a2274 21
	 * When using the BCM5701 in PCI-X mode, data corruption has
	 * been observed in the first few bytes of some received packets.
	 * Aligning the packet buffer in memory eliminates the corruption.
	 * Unfortunately, this misaligns the packet payloads.  On platforms
	 * which do not support unaligned accesses, we will realign the
	 * payloads by copying the received packets.
	 */
	switch (sc->bge_chipid) {
	case BGE_CHIPID_BCM5701_A0:
	case BGE_CHIPID_BCM5701_B0:
	case BGE_CHIPID_BCM5701_B2:
	case BGE_CHIPID_BCM5701_B5:
		/* If in PCI-X mode, work around the alignment bug. */
		if ((pci_conf_read(pc, pa->pa_tag, BGE_PCI_PCISTATE) &
		    (BGE_PCISTATE_PCI_BUSMODE | BGE_PCISTATE_PCI_BUSSPEED)) ==
		    BGE_PCISTATE_PCI_BUSSPEED)
			sc->bge_rx_alignment_bug = 1;
		break;
	}

	/*
a2276 1
	DPRINTFN(5, ("if_attach\n"));
a2277 1
	DPRINTFN(5, ("ether_ifattach\n"));
d2279 1
a2279 1
	DPRINTFN(5, ("timeout_set\n"));
d2281 18
a2298 2
fail:
	splx(s);
d2301 2
a2302 3
void
bge_release_resources(sc)
	struct bge_softc *sc;
d2304 3
a2306 2
	if (sc->bge_vpd_prodname != NULL)
		free(sc->bge_vpd_prodname, M_DEVBUF);
d2308 16
a2323 18
	if (sc->bge_vpd_readonly != NULL)
		free(sc->bge_vpd_readonly, M_DEVBUF);

#ifdef fake
	if (sc->bge_intrhand != NULL)
		bus_teardown_intr(dev, sc->bge_irq, sc->bge_intrhand);

	if (sc->bge_irq != NULL)
		bus_release_resource(dev, SYS_RES_IRQ, 0, sc->bge_irq);

	if (sc->bge_res != NULL)
		bus_release_resource(dev, SYS_RES_MEMORY,
		    BGE_PCI_BAR0, sc->bge_res);

	if (sc->bge_rdata != NULL)
		contigfree(sc->bge_rdata,
		    sizeof(struct bge_ring_data), M_DEVBUF);
#endif
d2327 1
a2327 2
bge_reset(sc)
	struct bge_softc *sc;
d2330 2
a2331 1
	u_int32_t cachesize, command, pcistate;
d2343 29
d2373 14
a2386 2
	bge_writereg_ind(sc, BGE_MISC_CFG,
	    BGE_MISCCFG_RESET_CORE_CLOCKS|(65<<1));
d2390 17
d2416 6
a2421 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
d2424 1
a2424 1
	/*
a2428 12
	/*
	 * Poll the value location we just wrote until
	 * we see the 1's complement of the magic number.
	 * This indicates that the firmware initialization
	 * is complete.
	 */
	for (i = 0; i < BGE_TIMEOUT; i++) {
		val = bge_readmem_ind(sc, BGE_SOFTWARE_GENCOMM);
		if (val == ~BGE_MAGIC_NUMBER)
			break;
		DELAY(10);
	}
d2430 28
a2457 5
	if (i == BGE_TIMEOUT) {
		printf("%s: firmware handshake timed out\n",
		    sc->bge_dev.dv_xname);
		return;
	}
d2468 4
a2471 2
		if (pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_PCISTATE) ==
		    pcistate)
d2475 5
d2482 1
a2482 2
	CSR_WRITE_4(sc, BGE_MODE_CTL, BGE_MODECTL_BYTESWAP_NONFRAME|
	    BGE_MODECTL_BYTESWAP_DATA);
d2486 25
d2524 1
a2524 2
bge_rxeof(sc)
	struct bge_softc *sc;
d2527 1
d2529 11
d2543 23
a2565 2
	while(sc->bge_rx_saved_considx !=
	    sc->bge_rdata->bge_status_block.bge_idx[0].bge_rx_prod_idx) {
a2568 7
#if NVLAN > 0
		u_int16_t		vlan_tag = 0;
		int			have_tag = 0;
#endif
#ifdef BGE_CHECKSUM
		int			sumflags = 0;
#endif
d2570 1
a2570 2
		cur_rx = &sc->bge_rdata->
			bge_rx_return_ring[sc->bge_rx_saved_considx];
d2573 1
a2573 8
		BGE_INC(sc->bge_rx_saved_considx, sc->bge_return_ring_cnt);

#if NVLAN > 0
		if (cur_rx->bge_flags & BGE_RXBDFLAG_VLAN_TAG) {
			have_tag = 1;
			vlan_tag = cur_rx->bge_vlan_tag;
		}
#endif
a2575 1
			BGE_INC(sc->bge_jumbo, BGE_JUMBO_RX_RING_CNT);
d2578 1
d2580 7
d2588 1
a2588 8
				ifp->if_ierrors++;
				bge_newbuf_jumbo(sc, sc->bge_jumbo, m);
				continue;
			}
			if (bge_newbuf_jumbo(sc, sc->bge_jumbo,
					     NULL)== ENOBUFS) {
				ifp->if_ierrors++;
				bge_newbuf_jumbo(sc, sc->bge_jumbo, m);
a2591 1
			BGE_INC(sc->bge_std, BGE_STD_RX_RING_CNT);
d2594 1
a2594 2
			bus_dmamap_unload(sc->bge_dmatag,
					  sc->bge_cdata.bge_rx_std_map[rxidx]);
d2596 7
d2604 1
a2604 8
				ifp->if_ierrors++;
				bge_newbuf_std(sc, sc->bge_std, m);
				continue;
			}
			if (bge_newbuf_std(sc, sc->bge_std,
			    NULL) == ENOBUFS) {
				ifp->if_ierrors++;
				bge_newbuf_std(sc, sc->bge_std, m);
d2615 1
a2615 1
		if (sc->bge_rx_alignment_bug) {
a2623 1
#if NBPFILTER > 0
d2625 2
a2626 1
		 * Handle BPF listeners. Let the BPF user see the packet.
d2628 16
a2643 3
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m);
#endif
d2645 4
a2648 10
#ifdef BGE_CHECKSUM
		if ((cur_rx->bge_ip_csum ^ 0xffff) == 0)
			sumflags |= M_IPV4_CSUM_IN_OK;
		else
			sumflags |= M_IPV4_CSUM_IN_BAD;
#if 0
		if (cur_rx->bge_flags & BGE_RXBDFLAG_TCP_UDP_CSUM) {
			m->m_pkthdr.csum_data =
				cur_rx->bge_tcp_udp_csum;
			m->m_pkthdr.csum_flags |= CSUM_DATA_VALID;
a2650 3
		m->m_pkthdr.csum = sumflags;
		sumflags = 0;
#endif
d2652 1
a2652 1
#if NVLAN > 0
d2654 1
a2654 2
		 * If we received a packet with a vlan tag, pass it
		 * to vlan_input() instead of ether_input().
d2656 2
a2657 5
		if (have_tag) {
			vlan_input_tag(m, vlan_tag);
			have_tag = vlan_tag = 0;
			continue;
		}
d2659 1
d2663 2
a2664 1
	CSR_WRITE_4(sc, BGE_MBX_RX_CONS0_LO, sc->bge_rx_saved_considx);
d2666 1
a2666 1
		CSR_WRITE_4(sc, BGE_MBX_RX_STD_PROD_LO, sc->bge_std);
d2668 1
a2668 1
		CSR_WRITE_4(sc, BGE_MBX_RX_JUMBO_PROD_LO, sc->bge_jumbo);
d2672 1
a2672 2
bge_txeof(sc)
	struct bge_softc *sc;
d2676 10
d2689 23
d2724 2
a2725 2
		if (sc->bge_cdata.bge_tx_chain[idx] != NULL) {
			m_freem(sc->bge_cdata.bge_tx_chain[idx]);
d2727 8
a2734 2
			bus_dmamap_unload(sc->bge_dmatag,
					  sc->bge_cdata.bge_tx_map[idx]);
a2737 1
		ifp->if_timer = 0;
d2740 1
a2740 1
	if (cur_tx != NULL)
d2742 2
d2747 1
a2747 2
bge_intr(xsc)
	void *xsc;
d2751 1
a2751 1
	u_int32_t status;
d2756 22
a2777 8
#ifdef notdef
	/* Avoid this for now -- checking this register is expensive. */
	/* Make sure this is really our interrupt. */
	if (!(CSR_READ_4(sc, BGE_MISC_LOCAL_CTL) & BGE_MLC_INTR_STATE))
		return (0);
#endif
	/* Ack interrupt and stop others from occurring. */
	CSR_WRITE_4(sc, BGE_MBX_IRQ0_LO, 1);
d2779 3
a2781 11
	/*
	 * Process link state changes.
	 * Grrr. The link status word in the status block does
	 * not work correctly on the BCM5700 rev AX and BX chips,
	 * according to all available information. Hence, we have
	 * to enable MII interrupts in order to properly obtain
	 * async link changes. Unfortunately, this also means that
	 * we have to read the MAC status register to detect link
	 * changes, thereby adding an additional register access to
	 * the interrupt handler.
	 */
d2783 2
a2784 12
	if (sc->bge_asicrev == BGE_ASICREV_BCM5700) {
		status = CSR_READ_4(sc, BGE_MAC_STS);
		if (status & BGE_MACSTAT_MI_INTERRUPT) {
			sc->bge_link = 0;
			timeout_del(&sc->bge_timeout);
			bge_tick(sc);
			/* Clear the interrupt */
			CSR_WRITE_4(sc, BGE_MAC_EVT_ENB,
			    BGE_EVTENB_MI_INTERRUPT);
			bge_miibus_readreg(&sc->bge_dev, 1, BRGPHY_MII_ISR);
			bge_miibus_writereg(&sc->bge_dev, 1, BRGPHY_MII_IMR,
			    BRGPHY_INTRS);
a2785 31
	} else {
		if ((sc->bge_rdata->bge_status_block.bge_status &
		    BGE_STATFLAG_UPDATED) &&
		    (sc->bge_rdata->bge_status_block.bge_status &
		    BGE_STATFLAG_LINKSTATE_CHANGED)) {
			sc->bge_rdata->bge_status_block.bge_status &=
			    ~(BGE_STATFLAG_UPDATED | 
				BGE_STATFLAG_LINKSTATE_CHANGED);
			/*
			 * Sometimes PCS encoding errors are detected in
			 * TBI mode (on fiber NICs), and for some reason
			 * the chip will signal them as link changes.
			 * If we get a link change event, but the 'PCS 
			 * encoding bit' in the MAC status register
			 * is set, don't bother doing a link check.
			 * This avoids spurious "gigabit link up" messages
			 * that sometimes appear on fiber NICs during
			 * periods of heavy traffic. (There should be no
			 * effect on copper NICs).
			 */
			status = CSR_READ_4(sc, BGE_MAC_STS);
			if (!(status & (BGE_MACSTAT_PORT_DECODE_ERROR | 
			    BGE_MACSTAT_MI_COMPLETE))) {
				sc->bge_link = 0;
				timeout_del(&sc->bge_timeout);
				bge_tick(sc);
			}
			/* Clear the interrupt */
			CSR_WRITE_4(sc, BGE_MAC_STS, BGE_MACSTAT_SYNC_CHANGED|
			    BGE_MACSTAT_CFG_CHANGED|BGE_MACSTAT_MI_COMPLETE|
			    BGE_MACSTAT_LINK_CHANGED);
d2787 2
a2788 14
			/* Force flush the status block cached by PCI bridge */
			CSR_READ_4(sc, BGE_MBX_IRQ0_LO);	
		}
	}

	if (ifp->if_flags & IFF_RUNNING) {
		/* Check RX return ring producer/consumer */
		bge_rxeof(sc);

		/* Check TX ring producer/consumer */
		bge_txeof(sc);
	}

	bge_handle_events(sc);
a2789 4
	/* Re-enable interrupts. */
	CSR_WRITE_4(sc, BGE_MBX_IRQ0_LO, 0);

	if (ifp->if_flags & IFF_RUNNING && !IFQ_IS_EMPTY(&ifp->if_snd))
d2792 3
a2794 1
	return (1);
d2798 1
a2798 2
bge_tick(xsc)
	void *xsc;
a2801 2
	struct ifmedia *ifm = NULL;
	struct ifnet *ifp = &sc->arpcom.ac_if;
d2804 1
a2804 1
	s = splimp();
d2806 1
a2806 1
	if (sc->bge_asicrev == BGE_ASICREV_BCM5705)
a2809 5
	timeout_add(&sc->bge_timeout, hz);
	if (sc->bge_link) {
		splx(s);
		return;
	}
d2811 17
a2827 12
	if (sc->bge_tbi) {
		ifm = &sc->bge_ifmedia;
		if (CSR_READ_4(sc, BGE_MAC_STS) &
		    BGE_MACSTAT_TBI_PCS_SYNCHED) {
			sc->bge_link++;
			CSR_WRITE_4(sc, BGE_MAC_STS, 0xFFFFFFFF);
			if (!IFQ_IS_EMPTY(&ifp->if_snd))
				bge_start(ifp);
		}
		splx(s);
		return;
	}
d2829 1
a2829 8
	mii_tick(mii);

	if (!sc->bge_link && mii->mii_media_status & IFM_ACTIVE &&
	    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE) {
		sc->bge_link++;
		if (!IFQ_IS_EMPTY(&ifp->if_snd))
			bge_start(ifp);
	}
d2835 1
a2835 2
bge_stats_update_regs(sc)
	struct bge_softc *sc;
d2837 1
a2837 4
	struct ifnet *ifp;
	struct bge_mac_stats_regs stats;
	u_int32_t *s;
	int i;
d2839 2
a2840 1
	ifp = &sc->arpcom.ac_if;
d2842 1
a2842 5
	s = (u_int32_t *)&stats;
	for (i = 0; i < sizeof(struct bge_mac_stats_regs); i += 4) {
		*s = CSR_READ_4(sc, BGE_RX_STATS + i);
		s++;
	}
d2844 1
a2844 6
	ifp->if_collisions +=
	   (stats.dot3StatsSingleCollisionFrames +
	   stats.dot3StatsMultipleCollisionFrames +
	   stats.dot3StatsExcessiveCollisions +
	   stats.dot3StatsLateCollisions) -
	   ifp->if_collisions;
d2846 1
a2846 1
	return;
d2850 1
a2850 2
bge_stats_update(sc)
	struct bge_softc *sc;
d2854 1
d2859 19
a2877 10
	ifp->if_collisions +=
	  (READ_STAT(sc, stats,
	       txstats.dot3StatsSingleCollisionFrames.bge_addr_lo) +
	   READ_STAT(sc, stats,
	       txstats.dot3StatsMultipleCollisionFrames.bge_addr_lo) +
	   READ_STAT(sc, stats,
	       txstats.dot3StatsExcessiveCollisions.bge_addr_lo) +
	   READ_STAT(sc, stats,
	       txstats.dot3StatsLateCollisions.bge_addr_lo)) -
	  ifp->if_collisions;
d2880 13
d2894 44
a2937 7
#ifdef notdef
	ifp->if_collisions +=
	   (sc->bge_rdata->bge_info.bge_stats.dot3StatsSingleCollisionFrames +
	   sc->bge_rdata->bge_info.bge_stats.dot3StatsMultipleCollisionFrames +
	   sc->bge_rdata->bge_info.bge_stats.dot3StatsExcessiveCollisions +
	   sc->bge_rdata->bge_info.bge_stats.dot3StatsLateCollisions) -
	   ifp->if_collisions;
d2939 78
d3020 1
a3020 1
 * Encapsulate an mbuf chain in the tx ring  by coupling the mbuf data
d3024 1
a3024 4
bge_encap(sc, m_head, txidx)
	struct bge_softc *sc;
	struct mbuf *m_head;
	u_int32_t *txidx;
d3027 1
a3027 1
	u_int32_t		frag, cur, cnt = 0;
d3029 2
a3030 1
	bus_dmamap_t		txmap;
a3031 7
#if NVLAN > 0
	struct ifvlan		*ifv = NULL;

	if ((m_head->m_flags & (M_PROTO1|M_PKTHDR)) == (M_PROTO1|M_PKTHDR) &&
	    m_head->m_pkthdr.rcvif != NULL)
		ifv = m_head->m_pkthdr.rcvif->if_softc;
#endif
d3035 2
a3036 3
#ifdef BGE_CHECKSUM
	if (m_head->m_pkthdr.csum) {
		if (m_head->m_pkthdr.csum & M_IPV4_CSUM_OUT)
d3038 2
a3039 2
		if (m_head->m_pkthdr.csum & (M_TCPV4_CSUM_OUT |
					     M_UDPV4_CSUM_OUT))
d3041 4
a3044 6
#ifdef fake
		if (m_head->m_flags & M_LASTFRAG)
			csum_flags |= BGE_TXBDFLAG_IP_FRAG_END;
		else if (m_head->m_flags & M_FRAG)
			csum_flags |= BGE_TXBDFLAG_IP_FRAG;
#endif
d3046 17
a3062 1
#endif
d3069 1
a3069 2
	txmap = sc->bge_cdata.bge_tx_map[frag];
	if (bus_dmamap_load_mbuf(sc->bge_dmatag, txmap, m_head,
d3071 1
a3071 1
		return(ENOBUFS);
d3073 5
a3077 1
	for (i = 0; i < txmap->dm_nsegs; i++) {
d3081 2
a3082 2
		BGE_HOSTADDR(f->bge_addr, txmap->dm_segs[i].ds_addr);
		f->bge_len = txmap->dm_segs[i].ds_len;
d3084 1
d3086 1
a3086 1
		if (ifv != NULL) {
d3088 1
a3088 3
			f->bge_vlan_tag = ifv->ifv_tag;
		} else {
			f->bge_vlan_tag = 0;
a3090 6
		/*
		 * Sanity check: avoid coming within 16 descriptors
		 * of the end of the ring.
		 */
		if ((BGE_TX_RING_CNT - (sc->bge_txcnt + cnt)) < 16)
			return(ENOBUFS);
a3092 1
		cnt++;
d3095 6
d3102 1
a3102 1
		return(ENOBUFS);
d3106 3
a3108 1
	sc->bge_txcnt += cnt;
d3112 6
a3117 1
	return(0);
d3125 1
a3125 2
bge_start(ifp)
	struct ifnet *ifp;
d3128 3
a3130 3
	struct mbuf *m_head = NULL;
	u_int32_t prodidx = 0;
	int pkts = 0;
d3134 1
a3134 1
	if (!sc->bge_link && ifp->if_snd.ifq_len < 10)
d3136 4
d3141 5
a3145 1
	prodidx = CSR_READ_4(sc, BGE_MBX_TX_HOST_PROD0_LO);
a3146 1
	while(sc->bge_cdata.bge_tx_chain[prodidx] == NULL) {
a3151 19
		 * XXX
		 * safety overkill.  If this is a fragmented packet chain
		 * with delayed TCP/UDP checksums, then only encapsulate
		 * it if we have enough descriptors to handle the entire
		 * chain at once.
		 * (paranoia -- may not actually be needed)
		 */
#ifdef fake
		if (m_head->m_flags & M_FIRSTFRAG &&
		    m_head->m_pkthdr.csum_flags & (CSUM_DELAY_DATA)) {
			if ((BGE_TX_RING_CNT - sc->bge_txcnt) <
			    m_head->m_pkthdr.csum_data + 16) {
				ifp->if_flags |= IFF_OACTIVE;
				break;
			}
		}
#endif

		/*
d3171 1
a3171 1
			bpf_mtap(ifp->if_bpf, m_head);
d3178 5
a3182 4
	CSR_WRITE_4(sc, BGE_MBX_TX_HOST_PROD0_LO, prodidx);
	/* 5700 b2 errata */
	if (sc->bge_chiprev == BGE_CHIPREV_5700_BX)
		CSR_WRITE_4(sc, BGE_MBX_TX_HOST_PROD0_LO, 0);
d3191 1
a3191 2
bge_init(xsc)
	void *xsc;
d3196 1
d3199 1
a3199 1
	s = splimp();
a3202 5
	if (ifp->if_flags & IFF_RUNNING) {
		splx(s);
		return;
	}

d3218 7
a3224 5
	ifp = &sc->arpcom.ac_if;

	/* Specify MTU. */
	CSR_WRITE_4(sc, BGE_RX_MTU, ifp->if_mtu +
	    ETHER_HDR_LEN + ETHER_CRC_LEN);
d3231 3
a3233 5
	/* Enable or disable promiscuous mode as needed. */
	if (ifp->if_flags & IFF_PROMISC) {
		BGE_SETBIT(sc, BGE_RX_MODE, BGE_RXMODE_RX_PROMISC);
	} else {
		BGE_CLRBIT(sc, BGE_RX_MODE, BGE_RXMODE_RX_PROMISC);
d3236 2
a3237 2
	/* Program multicast filter. */
	bge_setmulti(sc);
d3260 2
a3261 2
	/* Init jumbo RX ring. */
	if (ifp->if_mtu > (ETHERMTU + ETHER_HDR_LEN + ETHER_CRC_LEN))
d3267 7
d3280 5
d3286 3
a3288 1
	BGE_SETBIT(sc, BGE_RX_MODE, BGE_RXMODE_ENABLE);
d3296 1
a3296 1
	CSR_WRITE_4(sc, BGE_MBX_IRQ0_LO, 0);
d3305 1
a3305 1
	timeout_add(&sc->bge_timeout, hz);
d3312 1
a3312 2
bge_ifmedia_upd(ifp)
	struct ifnet *ifp;
d3319 1
a3319 1
	if (sc->bge_tbi) {
d3321 1
a3321 1
			return(EINVAL);
d3324 20
d3355 1
a3355 1
			return(EINVAL);
d3357 2
a3358 1
		return(0);
d3361 1
a3361 1
	sc->bge_link = 0;
d3364 1
a3364 2
		for (miisc = LIST_FIRST(&mii->mii_phys); miisc != NULL;
		    miisc = LIST_NEXT(miisc, mii_list))
d3369 15
a3383 1
	return(0);
d3390 1
a3390 3
bge_ifmedia_sts(ifp, ifmr)
	struct ifnet *ifp;
	struct ifmediareq *ifmr;
d3395 1
a3395 1
	if (sc->bge_tbi) {
d3399 1
a3399 1
		    BGE_MACSTAT_TBI_PCS_SYNCHED)
d3401 4
a3413 1
	ifmr->ifm_active = mii->mii_media_active;
d3415 2
d3420 1
a3420 4
bge_ioctl(ifp, command, data)
	struct ifnet *ifp;
	u_long command;
	caddr_t data;
d3423 1
a3424 1
	struct ifaddr *ifa = (struct ifaddr *)data;
d3428 1
a3428 6
	s = splimp();

	if ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {
		splx(s);
		return (error);
	}
d3433 2
a3434 1
		switch (ifa->ifa_addr->sa_family) {
d3436 1
a3436 2
		case AF_INET:
			bge_init(sc);
a3437 1
			break;
a3438 12
		default:
			bge_init(sc);
			break;
		}
		break;
	case SIOCSIFMTU:
		/* Disallow jumbo frames on 5705. */
		if ((sc->bge_asicrev == BGE_ASICREV_BCM5705 &&
		    ifr->ifr_mtu > ETHERMTU) || ifr->ifr_mtu > BGE_JUMBO_MTU)
			error = EINVAL;
		else
			ifp->if_mtu = ifr->ifr_mtu;
d3440 1
d3443 3
a3445 19
			/*
			 * If only the state of the PROMISC flag changed,
			 * then just use the 'set promisc mode' command
			 * instead of reinitializing the entire NIC. Doing
			 * a full re-init means reloading the firmware and
			 * waiting for it to start up, which may take a
			 * second or two.
			 */
			if (ifp->if_flags & IFF_RUNNING &&
			    ifp->if_flags & IFF_PROMISC &&
			    !(sc->bge_if_flags & IFF_PROMISC)) {
				BGE_SETBIT(sc, BGE_RX_MODE,
				    BGE_RXMODE_RX_PROMISC);
			} else if (ifp->if_flags & IFF_RUNNING &&
			    !(ifp->if_flags & IFF_PROMISC) &&
			    sc->bge_if_flags & IFF_PROMISC) {
				BGE_CLRBIT(sc, BGE_RX_MODE,
				    BGE_RXMODE_RX_PROMISC);
			} else
d3448 1
a3448 1
			if (ifp->if_flags & IFF_RUNNING) {
a3449 1
			}
a3450 2
		sc->bge_if_flags = ifp->if_flags;
		error = 0;
d3452 20
a3471 5
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		if (ifp->if_flags & IFF_RUNNING) {
			bge_setmulti(sc);
			error = 0;
d3473 1
a3473 2
		break;
	case SIOCSIFMEDIA:
d3475 1
a3475 1
		if (sc->bge_tbi) {
a3482 1
		error = 0;
d3484 1
d3486 7
a3492 2
		error = EINVAL;
		break;
d3496 1
a3496 2

	return(error);
d3500 1
a3500 2
bge_watchdog(ifp)
	struct ifnet *ifp;
a3507 1
	ifp->if_flags &= ~IFF_RUNNING;
d3513 17
d3535 1
a3535 2
bge_stop(sc)
	struct bge_softc *sc;
d3543 3
d3550 8
a3557 8
	BGE_CLRBIT(sc, BGE_RX_MODE, BGE_RXMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_RBDI_MODE, BGE_RBDIMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_RXLP_MODE, BGE_RXLPMODE_ENABLE);
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
		BGE_CLRBIT(sc, BGE_RXLS_MODE, BGE_RXLSMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_RDBDI_MODE, BGE_RBDIMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_RDC_MODE, BGE_RDCMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_RBDC_MODE, BGE_RBDCMODE_ENABLE);
d3562 8
a3569 8
	BGE_CLRBIT(sc, BGE_SRS_MODE, BGE_SRSMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_SBDI_MODE, BGE_SBDIMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_SDI_MODE, BGE_SDIMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_RDMA_MODE, BGE_RDMAMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_SDC_MODE, BGE_SDCMODE_ENABLE);
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
		BGE_CLRBIT(sc, BGE_DMAC_MODE, BGE_DMACMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_SBDC_MODE, BGE_SBDCMODE_ENABLE);
d3575 5
a3579 4
	BGE_CLRBIT(sc, BGE_HCC_MODE, BGE_HCCMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_WDMA_MODE, BGE_WDMAMODE_ENABLE);
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
		BGE_CLRBIT(sc, BGE_MBCF_MODE, BGE_MBCFMODE_ENABLE);
d3582 4
a3585 3
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705) {
		BGE_CLRBIT(sc, BGE_BMAN_MODE, BGE_BMANMODE_ENABLE);
		BGE_CLRBIT(sc, BGE_MARB_MODE, BGE_MARBMODE_ENABLE);
d3590 1
a3590 1
	CSR_WRITE_4(sc, BGE_MBX_IRQ0_LO, 1);
d3601 1
a3601 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
d3612 1
a3612 1
	if (!sc->bge_tbi) {
a3623 2
	sc->bge_link = 0;

d3626 2
a3627 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
a3629 4
/*
 * Stop all chip I/O so that the kernel's probe routines don't
 * get confused by errant DMAs when rebooting.
 */
d3631 1
a3631 2
bge_shutdown(xsc)
	void *xsc;
d3633 4
a3636 1
	struct bge_softc *sc = (struct bge_softc *)xsc;
d3638 78
a3715 3
	bge_stop(sc);
	bge_reset(sc);
}
d3717 10
a3726 3
struct cfattach bge_ca = {
	sizeof(struct bge_softc), bge_probe, bge_attach
};
d3728 5
a3732 3
struct cfdriver bge_cd = {
	0, "bge", DV_IFNET
};
@


1.2
log
@* merge src/sys/
  (at least the better part of it)
* revert IPv6 networking to OpenBSD, since
  I didn't get IPV4_MAPPED addresses working :(
@
text
@d580 1
a580 1
		printf("%s: can't map dma buffers (%d bytes)\n",
d1632 1
a1632 1
		    sc->bge_dev.dv_xname, sizeof(struct bge_ring_data));
@


1.1
log
@Initial revision
@
text
@d602 2
a603 1
	DPRINTFN(1,("bge_jumbo_buf = 0x%08X\n", sc->bge_cdata.bge_jumbo_buf));
d1521 1
a1521 1
	int			unit, error = 0;
d1607 1
a1607 1
		printf("bge%d: failed to read station address\n", unit);
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import current version of bge(4) from OpenBSD
@
text
@d1 1
a1 2
/*	$OpenBSD: if_bge.c,v 1.307 2011/06/22 16:44:27 tedu Exp $	*/

d38 1
a38 1
 * Broadcom BCM57xx/BCM590x family ethernet driver for OpenBSD.
d49 1
a49 1
 * SSRAM. The BCM5700 supports TCP, UDP and IP checksum offload, Jumbo
a83 1
#include <sys/timeout.h>
a106 5
#ifdef __sparc64__
#include <sparc64/autoconf.h>
#include <dev/ofw/openfirm.h>
#endif

d118 1
a118 1
#define ETHER_MIN_NOPAD		(ETHER_MIN_LEN - ETHER_CRC_LEN) /* i.e., 60 */
a119 1
const struct bge_revision * bge_lookup_rev(u_int32_t);
d122 1
a122 10
int bge_activate(struct device *, int);

struct cfattach bge_ca = {
	sizeof(struct bge_softc), bge_probe, bge_attach, NULL, bge_activate
};

struct cfdriver bge_cd = {
	NULL, "bge", DV_IFNET
};

a128 1
int bge_cksum_pad(struct mbuf *);
a129 1
int bge_compact_dma_runt(struct mbuf *);
a134 1
void bge_stop_block(struct bge_softc *, bus_size_t, u_int32_t);
d137 1
a140 2
u_int8_t bge_nvram_getbyte(struct bge_softc *, int, u_int8_t *);
int bge_read_nvram(struct bge_softc *, caddr_t, int, int);
d144 2
a145 1
void bge_iff(struct bge_softc *);
d147 9
a155 1
int bge_newbuf_jumbo(struct bge_softc *, int);
a156 1
void bge_fill_rx_ring_jumbo(struct bge_softc *);
a157 7

int bge_newbuf(struct bge_softc *, int);
int bge_init_rx_ring_std(struct bge_softc *);
void bge_rxtick(void *);
void bge_fill_rx_ring_std(struct bge_softc *);
void bge_free_rx_ring_std(struct bge_softc *);

d161 1
a161 1
void bge_chipinit(struct bge_softc *);
d164 6
d172 3
a175 1
void bge_writembx(struct bge_softc *, int, int);
a181 1
void bge_link_upd(struct bge_softc *);
d183 1
d185 2
a186 2
#define DPRINTF(x)	do { if (bgedebug) printf x; } while (0)
#define DPRINTFN(n,x)	do { if (bgedebug >= (n)) printf x; } while (0)
a204 1
	{ PCI_VENDOR_ALTIMA, PCI_PRODUCT_ALTIMA_AC1003 },
a206 2
	{ PCI_VENDOR_APPLE, PCI_PRODUCT_APPLE_BCM5701 },

a209 1
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5702_ALT },
a211 1
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5703_ALT },
a214 1
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5704S_ALT },
a215 2
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5705F },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5705K },
a217 34
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5714 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5714S },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5715 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5715S },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5717 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5718 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5720 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5721 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5722 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5723 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5724 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5750 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5750M },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5751 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5751F },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5751M },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5752 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5752M },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5753 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5753F },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5753M },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5754 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5754M },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5755 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5755M },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5756 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5761 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5761E },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5761S },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5761SE },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5764 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5780 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5780S },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5781 },
a218 7
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5784 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5785F },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5785G },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5786 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5787 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5787F },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5787M },
a219 1
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5789 },
a221 17
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5903M },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5906 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5906M },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57760 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57761 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57765 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57780 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57781 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57785 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57788 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57790 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57791 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57795 },

	{ PCI_VENDOR_FUJITSU, PCI_PRODUCT_FUJITSU_PW008GE4 },
	{ PCI_VENDOR_FUJITSU, PCI_PRODUCT_FUJITSU_PW008GE5 },
	{ PCI_VENDOR_FUJITSU, PCI_PRODUCT_FUJITSU_PP250_450_LAN },
d225 1
a225 106
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C996 }
};

#define BGE_IS_5705_PLUS(sc)		((sc)->bge_flags & BGE_5705_PLUS)
#define BGE_IS_5750_PLUS(sc)		((sc)->bge_flags & BGE_5750_PLUS)
#define BGE_IS_5755_PLUS(sc)		((sc)->bge_flags & BGE_5755_PLUS)
#define BGE_IS_5700_FAMILY(sc)		((sc)->bge_flags & BGE_5700_FAMILY)
#define BGE_IS_5714_FAMILY(sc)		((sc)->bge_flags & BGE_5714_FAMILY)
#define BGE_IS_JUMBO_CAPABLE(sc)	((sc)->bge_flags & BGE_JUMBO_CAPABLE)

static const struct bge_revision {
	u_int32_t		br_chipid;
	const char		*br_name;
} bge_revisions[] = {
	{ BGE_CHIPID_BCM5700_A0, "BCM5700 A0" },
	{ BGE_CHIPID_BCM5700_A1, "BCM5700 A1" },
	{ BGE_CHIPID_BCM5700_B0, "BCM5700 B0" },
	{ BGE_CHIPID_BCM5700_B1, "BCM5700 B1" },
	{ BGE_CHIPID_BCM5700_B2, "BCM5700 B2" },
	{ BGE_CHIPID_BCM5700_B3, "BCM5700 B3" },
	{ BGE_CHIPID_BCM5700_ALTIMA, "BCM5700 Altima" },
	{ BGE_CHIPID_BCM5700_C0, "BCM5700 C0" },
	{ BGE_CHIPID_BCM5701_A0, "BCM5701 A0" },
	{ BGE_CHIPID_BCM5701_B0, "BCM5701 B0" },
	{ BGE_CHIPID_BCM5701_B2, "BCM5701 B2" },
	{ BGE_CHIPID_BCM5701_B5, "BCM5701 B5" },
	/* the 5702 and 5703 share the same ASIC ID */
	{ BGE_CHIPID_BCM5703_A0, "BCM5702/5703 A0" },
	{ BGE_CHIPID_BCM5703_A1, "BCM5702/5703 A1" },
	{ BGE_CHIPID_BCM5703_A2, "BCM5702/5703 A2" },
	{ BGE_CHIPID_BCM5703_A3, "BCM5702/5703 A3" },
	{ BGE_CHIPID_BCM5703_B0, "BCM5702/5703 B0" },
	{ BGE_CHIPID_BCM5704_A0, "BCM5704 A0" },
	{ BGE_CHIPID_BCM5704_A1, "BCM5704 A1" },
	{ BGE_CHIPID_BCM5704_A2, "BCM5704 A2" },
	{ BGE_CHIPID_BCM5704_A3, "BCM5704 A3" },
	{ BGE_CHIPID_BCM5704_B0, "BCM5704 B0" },
	{ BGE_CHIPID_BCM5705_A0, "BCM5705 A0" },
	{ BGE_CHIPID_BCM5705_A1, "BCM5705 A1" },
	{ BGE_CHIPID_BCM5705_A2, "BCM5705 A2" },
	{ BGE_CHIPID_BCM5705_A3, "BCM5705 A3" },
	{ BGE_CHIPID_BCM5750_A0, "BCM5750 A0" },
	{ BGE_CHIPID_BCM5750_A1, "BCM5750 A1" },
	{ BGE_CHIPID_BCM5750_A3, "BCM5750 A3" },
	{ BGE_CHIPID_BCM5750_B0, "BCM5750 B0" },
	{ BGE_CHIPID_BCM5750_B1, "BCM5750 B1" },
	{ BGE_CHIPID_BCM5750_C0, "BCM5750 C0" },
	{ BGE_CHIPID_BCM5750_C1, "BCM5750 C1" },
	{ BGE_CHIPID_BCM5750_C2, "BCM5750 C2" },
	{ BGE_CHIPID_BCM5714_A0, "BCM5714 A0" },
	{ BGE_CHIPID_BCM5752_A0, "BCM5752 A0" },
	{ BGE_CHIPID_BCM5752_A1, "BCM5752 A1" },
	{ BGE_CHIPID_BCM5752_A2, "BCM5752 A2" },
	{ BGE_CHIPID_BCM5714_B0, "BCM5714 B0" },
	{ BGE_CHIPID_BCM5714_B3, "BCM5714 B3" },
	{ BGE_CHIPID_BCM5715_A0, "BCM5715 A0" },
	{ BGE_CHIPID_BCM5715_A1, "BCM5715 A1" },
	{ BGE_CHIPID_BCM5715_A3, "BCM5715 A3" },
	{ BGE_CHIPID_BCM5755_A0, "BCM5755 A0" },
	{ BGE_CHIPID_BCM5755_A1, "BCM5755 A1" },
	{ BGE_CHIPID_BCM5755_A2, "BCM5755 A2" },
	{ BGE_CHIPID_BCM5755_C0, "BCM5755 C0" },
	{ BGE_CHIPID_BCM5761_A0, "BCM5761 A0" },
	{ BGE_CHIPID_BCM5761_A1, "BCM5761 A1" },
	{ BGE_CHIPID_BCM5784_A0, "BCM5784 A0" },
	{ BGE_CHIPID_BCM5784_A1, "BCM5784 A1" },
	/* the 5754 and 5787 share the same ASIC ID */
	{ BGE_CHIPID_BCM5787_A0, "BCM5754/5787 A0" },
	{ BGE_CHIPID_BCM5787_A1, "BCM5754/5787 A1" },
	{ BGE_CHIPID_BCM5787_A2, "BCM5754/5787 A2" },
	{ BGE_CHIPID_BCM5906_A1, "BCM5906 A1" },
	{ BGE_CHIPID_BCM5906_A2, "BCM5906 A2" },
	{ BGE_CHIPID_BCM57780_A0, "BCM57780 A0" },
	{ BGE_CHIPID_BCM57780_A1, "BCM57780 A1" },

	{ 0, NULL }
};

/*
 * Some defaults for major revisions, so that newer steppings
 * that we don't know about have a shot at working.
 */
static const struct bge_revision bge_majorrevs[] = {
	{ BGE_ASICREV_BCM5700, "unknown BCM5700" },
	{ BGE_ASICREV_BCM5701, "unknown BCM5701" },
	/* 5702 and 5703 share the same ASIC ID */
	{ BGE_ASICREV_BCM5703, "unknown BCM5703" },
	{ BGE_ASICREV_BCM5704, "unknown BCM5704" },
	{ BGE_ASICREV_BCM5705, "unknown BCM5705" },
	{ BGE_ASICREV_BCM5750, "unknown BCM5750" },
	{ BGE_ASICREV_BCM5714_A0, "unknown BCM5714" },
	{ BGE_ASICREV_BCM5752, "unknown BCM5752" },
	{ BGE_ASICREV_BCM5780, "unknown BCM5780" },
	{ BGE_ASICREV_BCM5714, "unknown BCM5714" },
	{ BGE_ASICREV_BCM5755, "unknown BCM5755" },
	{ BGE_ASICREV_BCM5761, "unknown BCM5761" },
	{ BGE_ASICREV_BCM5784, "unknown BCM5784" },
	{ BGE_ASICREV_BCM5785, "unknown BCM5785" },
	/* 5754 and 5787 share the same ASIC ID */
	{ BGE_ASICREV_BCM5787, "unknown BCM5754/5787" },
	{ BGE_ASICREV_BCM5906, "unknown BCM5906" },
	{ BGE_ASICREV_BCM57780, "unknown BCM57780" },
	{ BGE_ASICREV_BCM5717, "unknown BCM5717" },
	{ BGE_ASICREV_BCM57765, "unknown BCM57765" },

	{ 0, NULL }
d229 3
a231 1
bge_readmem_ind(struct bge_softc *sc, int off)
d240 3
a242 1
bge_writemem_ind(struct bge_softc *sc, int off, int val)
d250 5
a254 2
void
bge_writereg_ind(struct bge_softc *sc, int off, int val)
d259 1
a259 1
	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_REG_DATA, val);
d261 1
d264 3
a266 1
bge_writembx(struct bge_softc *sc, int off, int val)
d268 1
a268 2
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906)
		off += BGE_LPMBX_IRQ0_HI - BGE_MBX_IRQ0_HI;
d270 2
a271 1
	CSR_WRITE_4(sc, off, val);
d274 1
d276 3
a278 1
bge_nvram_getbyte(struct bge_softc *sc, int addr, u_int8_t *dest)
a279 1
	u_int32_t access, byte = 0;
d281 2
d284 1
a284 16
	/* Lock. */
	CSR_WRITE_4(sc, BGE_NVRAM_SWARB, BGE_NVRAMSWARB_SET1);
	for (i = 0; i < 8000; i++) {
		if (CSR_READ_4(sc, BGE_NVRAM_SWARB) & BGE_NVRAMSWARB_GNT1)
			break;
		DELAY(20);
	}
	if (i == 8000)
		return (1);

	/* Enable access. */
	access = CSR_READ_4(sc, BGE_NVRAM_ACCESS);
	CSR_WRITE_4(sc, BGE_NVRAM_ACCESS, access | BGE_NVRAMACC_ENABLE);

	CSR_WRITE_4(sc, BGE_NVRAM_ADDR, addr & 0xfffffffc);
	CSR_WRITE_4(sc, BGE_NVRAM_CMD, BGE_NVRAM_READCMD);
d287 2
a288 2
		if (CSR_READ_4(sc, BGE_NVRAM_CMD) & BGE_NVRAMCMD_DONE) {
			DELAY(10);
a289 1
		}
d292 3
a294 3
	if (i == BGE_TIMEOUT * 10) {
		printf("%s: nvram read timed out\n", sc->bge_dev.dv_xname);
		return (1);
d297 1
a297 2
	/* Get result. */
	byte = CSR_READ_4(sc, BGE_NVRAM_RDDATA);
d299 2
a300 1
	*dest = (swap32(byte) >> ((addr % 4) * 8)) & 0xFF;
d302 8
a309 6
	/* Disable access. */
	CSR_WRITE_4(sc, BGE_NVRAM_ACCESS, access);

	/* Unlock. */
	CSR_WRITE_4(sc, BGE_NVRAM_SWARB, BGE_NVRAMSWARB_CLR1);
	CSR_READ_4(sc, BGE_NVRAM_SWARB);
d311 3
a313 1
	return (0);
d316 3
a318 6
/*
 * Read a sequence of bytes from NVRAM.
 */

int
bge_read_nvram(struct bge_softc *sc, caddr_t dest, int off, int cnt)
d320 2
a321 2
	int err = 0, i;
	u_int8_t byte = 0;
d323 14
a336 2
	if (BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5906)
		return (1);
d338 15
a352 5
	for (i = 0; i < cnt; i++) {
		err = bge_nvram_getbyte(sc, off + i, &byte);
		if (err)
			break;
		*(dest + i) = byte;
d355 6
a360 1
	return (err ? 1 : 0);
d362 1
d371 4
a374 1
bge_eeprom_getbyte(struct bge_softc *sc, int addr, u_int8_t *dest)
d400 1
a400 1
	if (i == BGE_TIMEOUT * 10) {
d402 1
a402 1
		return (1);
d410 1
a410 1
	return (0);
d417 5
a421 1
bge_read_eeprom(struct bge_softc *sc, caddr_t dest, int off, int cnt)
d433 1
a433 1
	return (err ? 1 : 0);
d437 3
a439 1
bge_miibus_readreg(struct device *dev, int phy, int reg)
d455 1
a455 1
		return (0);
a459 1
		BGE_STS_CLRBIT(sc, BGE_STS_AUTOPOLL);
d467 1
a467 2
	for (i = 0; i < 200; i++) {
		delay(1);
a470 1
		delay(10);
d473 1
a473 1
	if (i == 200) {
a482 1
		BGE_STS_SETBIT(sc, BGE_STS_AUTOPOLL);
d488 1
a488 1
		return (0);
d490 1
a490 1
	return (val & 0xFFFF);
d494 3
a496 1
bge_miibus_writereg(struct device *dev, int phy, int reg, int val)
d505 1
a506 3
		BGE_STS_CLRBIT(sc, BGE_STS_AUTOPOLL);
		BGE_CLRBIT(sc, BGE_MI_MODE, BGE_MIMODE_AUTOPOLL);
		DELAY(10); /* 40 usec is supposed to be adequate */
d512 1
a512 2
	for (i = 0; i < 200; i++) {
		delay(1);
a514 1
		delay(10);
a517 1
		BGE_STS_SETBIT(sc, BGE_STS_AUTOPOLL);
d522 1
a522 1
	if (i == 200) {
d528 2
a529 1
bge_miibus_statchg(struct device *dev)
a533 9
	/*
	 * Get flow control negotiation result.
	 */
	if (IFM_SUBTYPE(mii->mii_media.ifm_cur->ifm_media) == IFM_AUTO &&
	    (mii->mii_media_active & IFM_ETH_FMASK) != sc->bge_flowflags) {
		sc->bge_flowflags = mii->mii_media_active & IFM_ETH_FMASK;
		mii->mii_media_active &= ~IFM_ETH_FMASK;
	}

d535 1
a535 2
	if (IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_T ||
	    IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_SX)
d537 1
a537 1
	else
d539 1
d541 1
a541 1
	if ((mii->mii_media_active & IFM_GMASK) == IFM_FDX)
d543 1
a543 1
	else
d545 2
d548 7
a554 7
	/*
	 * 802.3x flow control
	 */
	if (sc->bge_flowflags & IFM_ETH_RXPAUSE)
		BGE_SETBIT(sc, BGE_RX_MODE, BGE_RXMODE_FLOWCTL_ENABLE);
	else
		BGE_CLRBIT(sc, BGE_RX_MODE, BGE_RXMODE_FLOWCTL_ENABLE);
d556 1
a556 4
	if (sc->bge_flowflags & IFM_ETH_TXPAUSE)
		BGE_SETBIT(sc, BGE_TX_MODE, BGE_TXMODE_FLOWCTL_ENABLE);
	else
		BGE_CLRBIT(sc, BGE_TX_MODE, BGE_TXMODE_FLOWCTL_ENABLE);
d560 1
a560 1
 * Intialize a standard receive ring descriptor.
d562 1
d564 2
a565 1
bge_newbuf(struct bge_softc *sc, int i)
d567 4
a570 4
	bus_dmamap_t		dmap = sc->bge_cdata.bge_rx_std_map[i];
	struct bge_rx_bd	*r = &sc->bge_rdata->bge_rx_std_ring[i];
	struct mbuf		*m;
	int			error;
d572 18
a589 2
	m = MCLGETI(NULL, M_DONTWAIT, &sc->arpcom.ac_if, MCLBYTES);
	if (!m)
d591 8
a598 8
	m->m_len = m->m_pkthdr.len = MCLBYTES;
	if (!(sc->bge_flags & BGE_RX_ALIGNBUG))
	    m_adj(m, ETHER_ALIGN);

	error = bus_dmamap_load_mbuf(sc->bge_dmatag, dmap, m,
	    BUS_DMA_READ|BUS_DMA_NOWAIT);
	if (error) {
		m_freem(m);
d601 32
d634 2
a635 9
	bus_dmamap_sync(sc->bge_dmatag, dmap, 0, dmap->dm_mapsize,
	    BUS_DMASYNC_PREREAD);
	sc->bge_cdata.bge_rx_std_chain[i] = m;

	bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
	    offsetof(struct bge_ring_data, bge_rx_std_ring) +
		i * sizeof (struct bge_rx_bd),
	    sizeof (struct bge_rx_bd),
	    BUS_DMASYNC_POSTWRITE);
d637 8
a644 4
	BGE_HOSTADDR(r->bge_addr, dmap->dm_segs[0].ds_addr);
	r->bge_flags = BGE_RXBDFLAG_END;
	r->bge_len = m->m_len;
	r->bge_idx = i;
d646 1
a646 5
	bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
	    offsetof(struct bge_ring_data, bge_rx_std_ring) +
		i * sizeof (struct bge_rx_bd),
	    sizeof (struct bge_rx_bd),
	    BUS_DMASYNC_PREWRITE);
d648 4
a651 1
	sc->bge_std_cnt++;
d653 3
a655 1
	return (0);
d659 1
a659 1
 * Initialize a Jumbo receive ring descriptor.
d661 5
a665 2
int
bge_newbuf_jumbo(struct bge_softc *sc, int i)
d667 25
a691 4
	bus_dmamap_t		dmap = sc->bge_cdata.bge_rx_jumbo_map[i];
	struct bge_ext_rx_bd	*r = &sc->bge_rdata->bge_rx_jumbo_ring[i];
	struct mbuf		*m;
	int			error;
a692 13
	m = MCLGETI(NULL, M_DONTWAIT, &sc->arpcom.ac_if, BGE_JLEN);
	if (!m)
		return (ENOBUFS);
	m->m_len = m->m_pkthdr.len = BGE_JUMBO_FRAMELEN;
	if (!(sc->bge_flags & BGE_RX_ALIGNBUG))
	    m_adj(m, ETHER_ALIGN);

	error = bus_dmamap_load_mbuf(sc->bge_dmatag, dmap, m,
	    BUS_DMA_READ|BUS_DMA_NOWAIT);
	if (error) {
		m_freem(m);
		return (ENOBUFS);
	}
d694 29
a722 35
	bus_dmamap_sync(sc->bge_dmatag, dmap, 0, dmap->dm_mapsize,
	    BUS_DMASYNC_PREREAD);
	sc->bge_cdata.bge_rx_jumbo_chain[i] = m;

	bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
	    offsetof(struct bge_ring_data, bge_rx_jumbo_ring) +
		i * sizeof (struct bge_ext_rx_bd),
	    sizeof (struct bge_ext_rx_bd),
	    BUS_DMASYNC_POSTWRITE);

	/*
	 * Fill in the extended RX buffer descriptor.
	 */
	r->bge_bd.bge_flags = BGE_RXBDFLAG_JUMBO_RING | BGE_RXBDFLAG_END;
	r->bge_bd.bge_idx = i;
	r->bge_len3 = r->bge_len2 = r->bge_len1 = 0;
	switch (dmap->dm_nsegs) {
	case 4:
		BGE_HOSTADDR(r->bge_addr3, dmap->dm_segs[3].ds_addr);
		r->bge_len3 = dmap->dm_segs[3].ds_len;
		/* FALLTHROUGH */
	case 3:
		BGE_HOSTADDR(r->bge_addr2, dmap->dm_segs[2].ds_addr);
		r->bge_len2 = dmap->dm_segs[2].ds_len;
		/* FALLTHROUGH */
	case 2:
		BGE_HOSTADDR(r->bge_addr1, dmap->dm_segs[1].ds_addr);
		r->bge_len1 = dmap->dm_segs[1].ds_len;
		/* FALLTHROUGH */
	case 1:
		BGE_HOSTADDR(r->bge_bd.bge_addr, dmap->dm_segs[0].ds_addr);
		r->bge_bd.bge_len = dmap->dm_segs[0].ds_len;
		break;
	default:
		panic("%s: %d segments", __func__, dmap->dm_nsegs);
d725 12
a736 5
	bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
	    offsetof(struct bge_ring_data, bge_rx_jumbo_ring) +
		i * sizeof (struct bge_ext_rx_bd),
	    sizeof (struct bge_ext_rx_bd),
	    BUS_DMASYNC_PREWRITE);
d738 1
a738 3
	sc->bge_jumbo_cnt++;

	return (0);
d742 2
a743 4
 * The standard receive ring has 512 entries in it. At 2K per mbuf cluster,
 * that's 1MB or memory, which is a lot. For now, we fill only the first
 * 256 ring entries and hope that our CPU is fast enough to keep up with
 * the NIC.
d746 4
a749 1
bge_init_rx_ring_std(struct bge_softc *sc)
d751 2
a752 1
	int i;
d754 2
a755 2
	if (ISSET(sc->bge_flags, BGE_RXRING_VALID))
		return (0);
d757 4
a760 7
	for (i = 0; i < BGE_STD_RX_RING_CNT; i++) {
		if (bus_dmamap_create(sc->bge_dmatag, MCLBYTES, 1, MCLBYTES, 0,
		    BUS_DMA_WAITOK | BUS_DMA_ALLOCNOW,
		    &sc->bge_cdata.bge_rx_std_map[i]) != 0) {
			printf("%s: unable to create dmamap for slot %d\n",
			    sc->bge_dev.dv_xname, i);
			goto uncreate;
a761 3
		bzero(&sc->bge_rdata->bge_rx_std_ring[i],
		    sizeof(struct bge_rx_bd));
	}
d763 6
a768 3
	sc->bge_std = BGE_STD_RX_RING_CNT - 1;
	sc->bge_std_cnt = 0;
	bge_fill_rx_ring_std(sc);
d770 7
a776 8
	SET(sc->bge_flags, BGE_RXRING_VALID);

	return (0);

uncreate:
	while (--i) {
		bus_dmamap_destroy(sc->bge_dmatag,
		    sc->bge_cdata.bge_rx_std_map[i]);
a777 2
	return (1);
}
d779 10
a788 5
void
bge_rxtick(void *arg)
{
	struct bge_softc *sc = arg;
	int s;
d790 1
a790 8
	s = splnet();
	if (ISSET(sc->bge_flags, BGE_RXRING_VALID) &&
	    sc->bge_std_cnt <= 8)
		bge_fill_rx_ring_std(sc);
	if (ISSET(sc->bge_flags, BGE_JUMBO_RXRING_VALID) &&
	    sc->bge_jumbo_cnt <= 8)
		bge_fill_rx_ring_jumbo(sc);
	splx(s);
d793 9
a801 2
void
bge_fill_rx_ring_std(struct bge_softc *sc)
a803 1
	int post = 0;
d805 5
a809 3
	i = sc->bge_std;
	while (sc->bge_std_cnt < BGE_STD_RX_RING_CNT) {
		BGE_INC(i, BGE_STD_RX_RING_CNT);
d811 3
a813 5
		if (bge_newbuf(sc, i) != 0)
			break;

		sc->bge_std = i;
		post = 1;
d816 2
a817 2
	if (post)
		bge_writembx(sc, BGE_MBX_RX_STD_PROD_LO, sc->bge_std);
d819 1
a819 6
	/*
	 * bge always needs more than 8 packets on the ring. if we cant do
	 * that now, then try again later.
	 */
	if (sc->bge_std_cnt <= 8)
		timeout_add(&sc->bge_rxtimeout, 1);
d823 2
a824 1
bge_free_rx_ring_std(struct bge_softc *sc)
a825 2
	bus_dmamap_t dmap;
	struct mbuf *m;
a827 3
	if (!ISSET(sc->bge_flags, BGE_RXRING_VALID))
		return;

d829 2
a830 7
		dmap = sc->bge_cdata.bge_rx_std_map[i];
		m = sc->bge_cdata.bge_rx_std_chain[i];
		if (m != NULL) {
			bus_dmamap_sync(sc->bge_dmatag, dmap, 0,
			    dmap->dm_mapsize, BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->bge_dmatag, dmap);
			m_freem(m);
d832 2
d835 1
a835 3
		bus_dmamap_destroy(sc->bge_dmatag, dmap);
		sc->bge_cdata.bge_rx_std_map[i] = NULL;
		bzero(&sc->bge_rdata->bge_rx_std_ring[i],
a837 2

	CLR(sc->bge_flags, BGE_RXRING_VALID);
d841 2
a842 1
bge_init_rx_ring_jumbo(struct bge_softc *sc)
a843 1
	volatile struct bge_rcb *rcb;
d845 1
a845 3

	if (ISSET(sc->bge_flags, BGE_JUMBO_RXRING_VALID))
		return (0);
d848 3
a850 14
		if (bus_dmamap_create(sc->bge_dmatag, BGE_JLEN, 4, BGE_JLEN, 0,
		    BUS_DMA_WAITOK | BUS_DMA_ALLOCNOW,
		    &sc->bge_cdata.bge_rx_jumbo_map[i]) != 0) {
			printf("%s: unable to create dmamap for slot %d\n",
			    sc->bge_dev.dv_xname, i);
			goto uncreate;
		}
		bzero(&sc->bge_rdata->bge_rx_jumbo_ring[i],
		    sizeof(struct bge_ext_rx_bd));
	}

	sc->bge_jumbo = BGE_JUMBO_RX_RING_CNT - 1;
	sc->bge_jumbo_cnt = 0;
	bge_fill_rx_ring_jumbo(sc);
d852 1
a852 1
	SET(sc->bge_flags, BGE_JUMBO_RXRING_VALID);
d855 1
a855 2
	rcb->bge_maxlen_flags =
	    BGE_RCB_MAXLEN_FLAGS(0, BGE_RCB_FLAG_USE_EXT_RX_BD);
d858 1
a858 1
	return (0);
d860 1
a860 6
uncreate:
	while (--i) {
		bus_dmamap_destroy(sc->bge_dmatag,
		    sc->bge_cdata.bge_rx_jumbo_map[i]);
	}
	return (1);
d864 2
a865 29
bge_fill_rx_ring_jumbo(struct bge_softc *sc)
{
	int i;
	int post = 0;

	i = sc->bge_jumbo;
	while (sc->bge_jumbo_cnt < BGE_JUMBO_RX_RING_CNT) {
		BGE_INC(i, BGE_JUMBO_RX_RING_CNT);

		if (bge_newbuf_jumbo(sc, i) != 0)
			break;

		sc->bge_jumbo = i;
		post = 1;
	}

	if (post)
		bge_writembx(sc, BGE_MBX_RX_JUMBO_PROD_LO, sc->bge_jumbo);

	/*
	 * bge always needs more than 8 packets on the ring. if we cant do
	 * that now, then try again later.
	 */
	if (sc->bge_jumbo_cnt <= 8)
		timeout_add(&sc->bge_rxtimeout, 1);
}

void
bge_free_rx_ring_jumbo(struct bge_softc *sc)
a866 2
	bus_dmamap_t dmap;
	struct mbuf *m;
a868 3
	if (!ISSET(sc->bge_flags, BGE_JUMBO_RXRING_VALID))
		return;

d870 2
a871 7
		dmap = sc->bge_cdata.bge_rx_jumbo_map[i];
		m = sc->bge_cdata.bge_rx_jumbo_chain[i];
		if (m != NULL) {
			bus_dmamap_sync(sc->bge_dmatag, dmap, 0,
			    dmap->dm_mapsize, BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->bge_dmatag, dmap);
			m_freem(m);
d874 2
a875 4
		bus_dmamap_destroy(sc->bge_dmatag, dmap);
		sc->bge_cdata.bge_rx_jumbo_map[i] = NULL;
		bzero(&sc->bge_rdata->bge_rx_jumbo_ring[i],
		    sizeof(struct bge_ext_rx_bd));
a876 2

	CLR(sc->bge_flags, BGE_JUMBO_RXRING_VALID);
d880 2
a881 1
bge_free_tx_ring(struct bge_softc *sc)
a883 1
	struct txdmamap_pool_entry *dma;
d885 1
a885 1
	if (!(sc->bge_flags & BGE_TXRING_VALID))
d892 2
a893 3
			SLIST_INSERT_HEAD(&sc->txdma_list, sc->txdma[i],
					    link);
			sc->txdma[i] = 0;
d895 1
a895 1
		bzero(&sc->bge_rdata->bge_tx_ring[i],
a897 8

	while ((dma = SLIST_FIRST(&sc->txdma_list))) {
		SLIST_REMOVE_HEAD(&sc->txdma_list, link);
		bus_dmamap_destroy(sc->bge_dmatag, dma->dmamap);
		free(dma, M_DEVBUF);
	}

	sc->bge_flags &= ~BGE_TXRING_VALID;
d901 2
a902 1
bge_init_tx_ring(struct bge_softc *sc)
a904 5
	bus_dmamap_t dmamap;
	struct txdmamap_pool_entry *dma;

	if (sc->bge_flags & BGE_TXRING_VALID)
		return (0);
d909 9
a917 10
	/* Initialize transmit producer index for host-memory send ring. */
	sc->bge_tx_prodidx = 0;
	bge_writembx(sc, BGE_MBX_TX_HOST_PROD0_LO, sc->bge_tx_prodidx);
	if (BGE_CHIPREV(sc->bge_chipid) == BGE_CHIPREV_5700_BX)
		bge_writembx(sc, BGE_MBX_TX_HOST_PROD0_LO, sc->bge_tx_prodidx);

	/* NIC-memory send ring not used; initialize to zero. */
	bge_writembx(sc, BGE_MBX_TX_NIC_PROD0_LO, 0);
	if (BGE_CHIPREV(sc->bge_chipid) == BGE_CHIPREV_5700_BX)
		bge_writembx(sc, BGE_MBX_TX_NIC_PROD0_LO, 0);
a918 1
	SLIST_INIT(&sc->txdma_list);
d920 3
a922 15
		if (bus_dmamap_create(sc->bge_dmatag, BGE_JLEN,
		    BGE_NTXSEG, BGE_JLEN, 0, BUS_DMA_NOWAIT,
		    &dmamap))
			return (ENOBUFS);
		if (dmamap == NULL)
			panic("dmamap NULL in bge_init_tx_ring");
		dma = malloc(sizeof(*dma), M_DEVBUF, M_NOWAIT);
		if (dma == NULL) {
			printf("%s: can't alloc txdmamap_pool_entry\n",
			    sc->bge_dev.dv_xname);
			bus_dmamap_destroy(sc->bge_dmatag, dmamap);
			return (ENOMEM);
		}
		dma->dmamap = dmamap;
		SLIST_INSERT_HEAD(&sc->txdma_list, dma, link);
d925 18
a942 1
	sc->bge_flags |= BGE_TXRING_VALID;
d944 1
a944 1
	return (0);
d948 2
a949 1
bge_iff(struct bge_softc *sc)
d955 9
a963 2
	u_int8_t		hashes[16];
	u_int32_t		h, rxmode;
d966 2
a967 14
	rxmode = CSR_READ_4(sc, BGE_RX_MODE) & ~BGE_RXMODE_RX_PROMISC;
	ifp->if_flags &= ~IFF_ALLMULTI;
	memset(hashes, 0x00, sizeof(hashes));

	if (ifp->if_flags & IFF_PROMISC) {
		ifp->if_flags |= IFF_ALLMULTI;
		rxmode |= BGE_RXMODE_RX_PROMISC;
	} else if (ac->ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		memset(hashes, 0xff, sizeof(hashes));
	} else {
		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			h = ether_crc32_le(enm->enm_addrlo, ETHER_ADDR_LEN);
d969 6
a974 4
			setbit(hashes, h & 0x7F);

			ETHER_NEXT_MULTI(step, enm);
		}
d977 2
a978 3
	bus_space_write_raw_region_4(sc->bge_btag, sc->bge_bhandle, BGE_MAR0,
	    hashes, sizeof(hashes));
	CSR_WRITE_4(sc, BGE_RX_MODE, rxmode);
d982 2
a983 1
 * Do endian, PCI and DMA initialization.
d985 3
a987 2
void
bge_chipinit(struct bge_softc *sc)
d993 5
d999 1
d1001 15
a1015 1
	    BGE_INIT);
d1032 9
a1040 10
	/*
	 * Set up the PCI DMA control register.
	 */
	dma_rw_ctl = BGE_PCIDMARWCTL_RD_CMD_SHIFT(6) |
	    BGE_PCIDMARWCTL_WR_CMD_SHIFT(7);

	if (sc->bge_flags & BGE_PCIE) {
		/* Read watermark not used, 128 bytes for write. */
		dma_rw_ctl |= BGE_PCIDMARWCTL_WR_WAT_SHIFT(3);
	} else if (sc->bge_flags & BGE_PCIX) {
d1042 12
a1053 17
		if (BGE_IS_5714_FAMILY(sc)) {
			/* 256 bytes for read and write. */
			dma_rw_ctl |= BGE_PCIDMARWCTL_RD_WAT_SHIFT(2) |
			    BGE_PCIDMARWCTL_WR_WAT_SHIFT(2);

			if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5780)
				dma_rw_ctl |= BGE_PCIDMARWCTL_ONEDMA_ATONCE_GLOBAL;
			else
				dma_rw_ctl |= BGE_PCIDMARWCTL_ONEDMA_ATONCE_LOCAL;
		} else if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704) {
			/* 1536 bytes for read, 384 bytes for write. */
			dma_rw_ctl |= BGE_PCIDMARWCTL_RD_WAT_SHIFT(7) |
			    BGE_PCIDMARWCTL_WR_WAT_SHIFT(3);
		} else {
			/* 384 bytes for read and write. */
			dma_rw_ctl |= BGE_PCIDMARWCTL_RD_WAT_SHIFT(3) |
			    BGE_PCIDMARWCTL_WR_WAT_SHIFT(3) |
a1054 1
		}
d1056 6
a1061 2
		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5703 ||
		    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704) {
a1063 1
			/* Set ONEDMA_ATONCE for hardware workaround. */
d1065 2
a1066 6
			if (tmp == 6 || tmp == 7)
				dma_rw_ctl |=
				    BGE_PCIDMARWCTL_ONEDMA_ATONCE_GLOBAL;

			/* Set PCI-X DMA write workaround. */
			dma_rw_ctl |= BGE_PCIDMARWCTL_ASRT_ALL_BE;
d1068 1
a1068 14
	} else {
		/* Conventional PCI bus: 256 bytes for read and write. */
		dma_rw_ctl |= BGE_PCIDMARWCTL_RD_WAT_SHIFT(7) |
		    BGE_PCIDMARWCTL_WR_WAT_SHIFT(7);

		if (BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5705 &&
		    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5750)
			dma_rw_ctl |= 0x0F;
	}

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5701)
		dma_rw_ctl |= BGE_PCIDMARWCTL_USE_MRM |
		    BGE_PCIDMARWCTL_ASRT_ALL_BE;
d1070 3
a1072 2
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5703 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704)
d1080 3
a1082 1
	CSR_WRITE_4(sc, BGE_MODE_CTL, BGE_DMA_SWAP_OPTIONS|
d1084 6
a1089 11
		    BGE_MODECTL_TX_NO_PHDR_CSUM);

	/*
	 * BCM5701 B5 have a bug causing data corruption when using
	 * 64-bit DMA reads, which can be terminated early and then
	 * completed later as 32-bit accesses, in combination with
	 * certain bridges.
	 */
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5701 &&
	    sc->bge_chipid == BGE_CHIPID_BCM5701_B5)
		BGE_SETBIT(sc, BGE_MODE_CTL, BGE_MODECTL_FORCE_PCI32);
d1112 1
a1112 8
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906) {
		DELAY(40);	/* XXX */

		/* Put PHY into ready state */
		BGE_CLRBIT(sc, BGE_MISC_CFG, BGE_MISCCFG_EPHY_IDDQ);
		CSR_READ_4(sc, BGE_MISC_CFG); /* Flush */
		DELAY(40);
	}
d1116 2
a1117 1
bge_blockinit(struct bge_softc *sc)
d1119 1
a1119 1
	volatile struct bge_rcb		*rcb;
a1121 2
	bge_hostaddr		taddr;
	u_int32_t		val;
d1131 4
a1134 2
	/* Configure mbuf memory pool */
	if (BGE_IS_5700_FAMILY(sc)) {
d1136 4
a1139 7
		    BGE_BUFFPOOL_1);

		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704)
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_LEN, 0x10000);
		else
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_LEN, 0x18000);

d1147 1
a1147 3
	/* new Broadcom docs strongly recommend these: */
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57765) {
d1149 1
a1149 12
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_MACRX_LOWAT, 0x2a);
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_HIWAT, 0xa0);
	} else if (BGE_IS_5705_PLUS(sc)) {
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_READDMA_LOWAT, 0x0);

		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906) {
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_MACRX_LOWAT, 0x04);
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_HIWAT, 0x10);
		} else {
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_MACRX_LOWAT, 0x10);
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_HIWAT, 0x60);
		}
a1152 1
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_HIWAT, 0x60);
d1154 1
d1161 3
a1163 2
	CSR_WRITE_4(sc, BGE_BMAN_MODE,
	    BGE_BMANMODE_ENABLE|BGE_BMANMODE_LOMBUF_ATTN);
d1165 6
a1170 6
	/* Poll for buffer manager start indication */
	for (i = 0; i < 2000; i++) {
		if (CSR_READ_4(sc, BGE_BMAN_MODE) & BGE_BMANMODE_ENABLE)
			break;
		DELAY(10);
	}
d1172 5
a1176 4
	if (i == 2000) {
		printf("%s: buffer manager failed to start\n",
		    sc->bge_dev.dv_xname);
		return (ENXIO);
d1184 1
a1184 1
	for (i = 0; i < 2000; i++) {
d1190 1
a1190 1
	if (i == 2000) {
d1193 1
a1193 1
		return (ENXIO);
d1199 1
a1199 5
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57765)
		rcb->bge_maxlen_flags = (BGE_RCB_MAXLEN_FLAGS(512, 0) |
					(ETHER_MAX_DIX_LEN << 2));
	else if (BGE_IS_5705_PLUS(sc))
d1203 5
a1207 2
		    BGE_RCB_MAXLEN_FLAGS(ETHER_MAX_DIX_LEN, 0);
	rcb->bge_nicaddr = BGE_STD_RX_RINGS;
d1214 1
a1214 1
	 * Initialize the Jumbo RX ring control block
d1220 1
a1220 1
	if (BGE_IS_JUMBO_CAPABLE(sc)) {
d1224 7
a1230 3
		rcb->bge_maxlen_flags = BGE_RCB_MAXLEN_FLAGS(0,
		    BGE_RCB_FLAG_USE_EXT_RX_BD | BGE_RCB_FLAG_RING_DISABLED);
		rcb->bge_nicaddr = BGE_JUMBO_RX_RINGS;
d1247 1
a1248 14
		bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
		    offsetof(struct bge_ring_data, bge_info),
		    sizeof (struct bge_gib),
		    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
	}

	/* Choose de-pipeline mode for BCM5906 A0, A1 and A2. */
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906) {
		if (sc->bge_chipid == BGE_CHIPID_BCM5906_A0 ||
		    sc->bge_chipid == BGE_CHIPID_BCM5906_A1 ||
		    sc->bge_chipid == BGE_CHIPID_BCM5906_A2)
			CSR_WRITE_4(sc, BGE_ISO_PKT_TX,
			    (CSR_READ_4(sc, BGE_ISO_PKT_TX) & ~3) | 2);
	}
d1250 1
a1250 1
	 * Set the BD ring replenish thresholds. The recommended
d1252 4
a1255 13
	 * each ring, but since we try to avoid filling the entire
	 * ring we set these to the minimal value of 8.  This needs to
	 * be done on several of the supported chip revisions anyway,
	 * to work around HW bugs.
	 */
	CSR_WRITE_4(sc, BGE_RBDI_STD_REPL_THRESH, 8);
	CSR_WRITE_4(sc, BGE_RBDI_JUMBO_REPL_THRESH, 8);

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57765) {
		CSR_WRITE_4(sc, BGE_STD_REPL_LWM, 4);
		CSR_WRITE_4(sc, BGE_JUMBO_REPL_LWM, 4);
	}
d1272 3
a1274 3
	BGE_HOSTADDR(taddr, BGE_RING_DMA_ADDR(sc, bge_tx_ring));
	RCB_WRITE_4(sc, rcb_addr, bge_hostaddr.bge_addr_hi, taddr.bge_addr_hi);
	RCB_WRITE_4(sc, rcb_addr, bge_hostaddr.bge_addr_lo, taddr.bge_addr_lo);
d1277 1
a1277 1
	if (BGE_IS_5700_FAMILY(sc))
d1290 1
a1290 1
		bge_writembx(sc, BGE_MBX_RX_CONS0_LO +
d1296 3
a1298 3
	bge_writembx(sc, BGE_MBX_RX_STD_PROD_LO, 0);
	bge_writembx(sc, BGE_MBX_RX_JUMBO_PROD_LO, 0);
	bge_writembx(sc, BGE_MBX_RX_MINI_PROD_LO, 0);
d1307 3
a1309 3
	BGE_HOSTADDR(taddr, BGE_RING_DMA_ADDR(sc, bge_rx_return_ring));
	RCB_WRITE_4(sc, rcb_addr, bge_hostaddr.bge_addr_hi, taddr.bge_addr_hi);
	RCB_WRITE_4(sc, rcb_addr, bge_hostaddr.bge_addr_lo, taddr.bge_addr_lo);
d1344 1
a1344 1
	for (i = 0; i < 2000; i++) {
d1350 1
a1350 1
	if (i == 2000) {
d1353 1
a1353 1
		return (ENXIO);
d1361 1
a1361 1
	if (BGE_IS_5700_FAMILY(sc)) {
d1369 1
a1369 1
	if (BGE_IS_5700_FAMILY(sc)) {
d1380 3
a1382 3
	BGE_HOSTADDR(taddr, BGE_RING_DMA_ADDR(sc, bge_status_block));
	CSR_WRITE_4(sc, BGE_HCC_STATUSBLK_ADDR_HI, taddr.bge_addr_hi);
	CSR_WRITE_4(sc, BGE_HCC_STATUSBLK_ADDR_LO, taddr.bge_addr_lo);
d1398 1
a1398 1
	if (BGE_IS_5700_FAMILY(sc))
a1400 12
	val = BGE_MACMODE_TXDMA_ENB | BGE_MACMODE_RXDMA_ENB |
	    BGE_MACMODE_RX_STATS_CLEAR | BGE_MACMODE_TX_STATS_CLEAR |
	    BGE_MACMODE_RX_STATS_ENB | BGE_MACMODE_TX_STATS_ENB |
	    BGE_MACMODE_FRMHDR_DMA_ENB;

	if (sc->bge_flags & BGE_PHY_FIBER_TBI)
	    val |= BGE_PORTMODE_TBI;
	else if (sc->bge_flags & BGE_PHY_FIBER_MII)
	    val |= BGE_PORTMODE_GMII;
	else
	    val |= BGE_PORTMODE_MII;

d1402 5
a1406 1
	CSR_WRITE_4(sc, BGE_MAC_MODE, val);
d1420 1
a1420 1
	if (BGE_IS_5700_FAMILY(sc))
a1422 9
	val = BGE_WDMAMODE_ENABLE|BGE_WDMAMODE_ALL_ATTNS;

	/* Enable host coalescing bug fix. */
	if (BGE_IS_5755_PLUS(sc))
		val |= BGE_WDMAMODE_STATUS_TAG_FIX;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5785)
		val |= BGE_WDMAMODE_BURST_ALL_DATA;

d1424 2
a1425 16
	CSR_WRITE_4(sc, BGE_WDMA_MODE, val);

	val = BGE_RDMAMODE_ENABLE|BGE_RDMAMODE_ALL_ATTNS;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717)
		val |= BGE_RDMAMODE_MULT_DMA_RD_DIS;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5784 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5785 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57780)
		val |= BGE_RDMAMODE_BD_SBD_CRPT_ATTN |
		       BGE_RDMAMODE_MBUF_RBD_CRPT_ATTN |
		       BGE_RDMAMODE_MBUF_SBD_CRPT_ATTN;

	if (sc->bge_flags & BGE_PCIE)
		val |= BGE_RDMAMODE_FIFO_LONG_BURST;
d1428 2
a1429 1
	CSR_WRITE_4(sc, BGE_RDMA_MODE, val);
d1441 1
a1441 1
	if (BGE_IS_5700_FAMILY(sc))
a1446 5
	val = BGE_SDCMODE_ENABLE;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5761)
		val |= BGE_SDCMODE_CDELAY;

d1448 1
a1448 1
	CSR_WRITE_4(sc, BGE_SDC_MODE, val);
d1469 1
a1469 1
	if (sc->bge_flags & BGE_PHY_FIBER_TBI) {
a1471 1
		BGE_STS_SETBIT(sc, BGE_STS_AUTOPOLL);
d1473 1
a1473 1
		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700)
a1477 11
	/*
	 * Clear any pending link state attention.
	 * Otherwise some link state change events may be lost until attention
	 * is cleared by bge_intr() -> bge_link_upd() sequence.
	 * It's not necessary on newer BCM chips - perhaps enabling link
	 * state change attentions implies clearing pending attention.
	 */
	CSR_WRITE_4(sc, BGE_MAC_STS, BGE_MACSTAT_SYNC_CHANGED|
	    BGE_MACSTAT_CFG_CHANGED|BGE_MACSTAT_MI_COMPLETE|
	    BGE_MACSTAT_LINK_CHANGED);

d1481 1
a1481 19
	return (0);
}

const struct bge_revision *
bge_lookup_rev(u_int32_t chipid)
{
	const struct bge_revision *br;

	for (br = bge_revisions; br->br_name != NULL; br++) {
		if (br->br_chipid == chipid)
			return (br);
	}

	for (br = bge_majorrevs; br->br_name != NULL; br++) {
		if (br->br_chipid == BGE_ASICREV(chipid))
			return (br);
	}

	return (NULL);
d1493 4
a1496 1
bge_probe(struct device *parent, void *match, void *aux)
d1498 2
a1499 1
	return (pci_matchbyid(aux, bge_devices, nitems(bge_devices)));
d1503 3
a1505 1
bge_attach(struct device *parent, struct device *self, void *aux)
a1509 2
	const struct bge_revision *br;
	pcireg_t		pm_ctl, memtype, subid, reg;
d1512 2
a1513 1
	bus_size_t		size;
d1515 1
a1515 1
	int			rseg, gotenaddr = 0, aspm_off;
d1518 1
a1518 1
	u_int32_t		misccfg;
d1520 1
d1522 2
a1523 3
#ifdef __sparc64__
	char			name[32];
#endif
a1526 2
	subid = pci_conf_read(pc, pa->pa_tag, PCI_SUBSYS_ID_REG);

d1531 11
d1543 3
a1545 4
	DPRINTFN(5, ("pci_mapreg_map\n"));
	memtype = pci_mapreg_type(pa->pa_pc, pa->pa_tag, BGE_PCI_BAR0);
	if (pci_mapreg_map(pa, BGE_PCI_BAR0, memtype, 0, &sc->bge_btag,
	    &sc->bge_bhandle, NULL, &size, 0)) {
d1547 7
a1553 1
		return;
d1556 2
d1561 1
a1561 1
		goto fail_1;
d1567 3
a1569 12
	/*
	 * Kludge for 5700 Bx bug: a hardware bug (PCIX byte enable?)
	 * can clobber the chip's PCI config-space power control registers,
	 * leaving the card in D3 powersave state.
	 * We do not have memory-mapped registers in this state,
	 * so force device into D0 state before starting initialization.
	 */
	pm_ctl = pci_conf_read(pc, pa->pa_tag, BGE_PCI_PWRMGMT_CMD);
	pm_ctl &= ~(PCI_PWR_D0|PCI_PWR_D1|PCI_PWR_D2|PCI_PWR_D3);
	pm_ctl |= (1 << 8) | PCI_PWR_D0 ; /* D0 state */
	pci_conf_write(pc, pa->pa_tag, BGE_PCI_PWRMGMT_CMD, pm_ctl);
	DELAY(1000);	/* 27 usec is allegedly sufficent */
d1571 6
a1576 176
	/*
	 * Save ASIC rev.
	 */
	sc->bge_chipid =
	     (pci_conf_read(pc, pa->pa_tag, BGE_PCI_MISC_CTL)
	      >> BGE_PCIMISCCTL_ASICREV_SHIFT);

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_USE_PRODID_REG) {
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5717 ||
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5718 ||
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5724)
			sc->bge_chipid = pci_conf_read(pc, pa->pa_tag,
			    BGE_PCI_GEN2_PRODID_ASICREV);
		else if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM57761 ||
			 PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM57765 ||
			 PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM57781 ||
			 PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM57785 ||
			 PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM57791 ||
			 PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM57795)
			sc->bge_chipid = pci_conf_read(pc, pa->pa_tag,
			    BGE_PCI_GEN15_PRODID_ASICREV);
		else
			sc->bge_chipid = pci_conf_read(pc, pa->pa_tag,
			    BGE_PCI_PRODID_ASICREV);
	}

	printf(", ");
	br = bge_lookup_rev(sc->bge_chipid);
	if (br == NULL)
		printf("unknown ASIC (0x%x)", sc->bge_chipid);
	else
		printf("%s (0x%x)", br->br_name, sc->bge_chipid);

	/*
	 * PCI Express or PCI-X controller check.
	 */
	if (pci_get_capability(pa->pa_pc, pa->pa_tag, PCI_CAP_PCIEXPRESS,
	    &aspm_off, NULL) != 0) {
		/* Disable PCIe Active State Power Management (ASPM). */
		reg = pci_conf_read(pa->pa_pc, pa->pa_tag,
		    aspm_off + PCI_PCIE_LCSR);
		reg &= ~(PCI_PCIE_LCSR_ASPM_L0S | PCI_PCIE_LCSR_ASPM_L1);
		pci_conf_write(pa->pa_pc, pa->pa_tag,
		    aspm_off + PCI_PCIE_LCSR, reg);
		sc->bge_flags |= BGE_PCIE;
	} else {
		if ((pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_PCISTATE) &
		    BGE_PCISTATE_PCI_BUSMODE) == 0)
			sc->bge_flags |= BGE_PCIX;
	}

	/*
	 * SEEPROM check.
	 */
#ifdef __sparc64__
	/*
	 * Onboard interfaces on UltraSPARC systems generally don't
	 * have a SEEPROM fitted.  These interfaces, and cards that
	 * have FCode, are named "network" by the PROM, whereas cards
	 * without FCode show up as "ethernet".  Since we don't really
	 * need the information from the SEEPROM on cards that have
	 * FCode it's fine to pretend they don't have one.
	 */
	if (OF_getprop(PCITAG_NODE(pa->pa_tag), "name", name,
	    sizeof(name)) > 0 && strcmp(name, "network") == 0)
		sc->bge_flags |= BGE_NO_EEPROM;
#endif
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5701 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5703 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704)
		sc->bge_flags |= BGE_5700_FAMILY;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5714_A0 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5780 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5714)
		sc->bge_flags |= BGE_5714_FAMILY;

	/* Intentionally exclude BGE_ASICREV_BCM5906 */
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5755 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5761 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5784 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5785 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5787 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57765 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57780)
		sc->bge_flags |= BGE_5755_PLUS;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5750 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5752 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906 ||
	    BGE_IS_5755_PLUS(sc) ||
	    BGE_IS_5714_FAMILY(sc))
		sc->bge_flags |= BGE_5750_PLUS;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5705 ||
	    BGE_IS_5750_PLUS(sc))
		sc->bge_flags |= BGE_5705_PLUS;

	/*
	 * When using the BCM5701 in PCI-X mode, data corruption has
	 * been observed in the first few bytes of some received packets.
	 * Aligning the packet buffer in memory eliminates the corruption.
	 * Unfortunately, this misaligns the packet payloads.  On platforms
	 * which do not support unaligned accesses, we will realign the
	 * payloads by copying the received packets.
	 */
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5701 &&
	    sc->bge_flags & BGE_PCIX)
		sc->bge_flags |= BGE_RX_ALIGNBUG;

	if (BGE_IS_5700_FAMILY(sc))
		sc->bge_flags |= BGE_JUMBO_CAPABLE;

	if ((BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5701) &&
	    PCI_VENDOR(subid) == DELL_VENDORID)
		sc->bge_flags |= BGE_NO_3LED;

	misccfg = CSR_READ_4(sc, BGE_MISC_CFG);
	misccfg &= BGE_MISCCFG_BOARD_ID_MASK;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5705 &&
	    (misccfg == BGE_MISCCFG_BOARD_ID_5788 ||
	     misccfg == BGE_MISCCFG_BOARD_ID_5788M))
		sc->bge_flags |= BGE_IS_5788;

	if ((BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5703 &&
	     (misccfg == 0x4000 || misccfg == 0x8000)) ||
	    (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5705 &&
	     PCI_VENDOR(pa->pa_id) == PCI_VENDOR_BROADCOM &&
	     (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5901 ||
	      PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5901A2 ||
	      PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5705F)) ||
	    (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_BROADCOM &&
	     (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5751F ||
	      PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5753F ||
	      PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5787F)) ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM57790 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906)
		sc->bge_flags |= BGE_10_100_ONLY;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700 ||
	    (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5705 &&
	     (sc->bge_chipid != BGE_CHIPID_BCM5705_A0 &&
	      sc->bge_chipid != BGE_CHIPID_BCM5705_A1)) ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906)
		sc->bge_flags |= BGE_NO_ETH_WIRE_SPEED;

	if (sc->bge_chipid == BGE_CHIPID_BCM5701_A0 ||
	    sc->bge_chipid == BGE_CHIPID_BCM5701_B0)
		sc->bge_flags |= BGE_PHY_CRC_BUG;
	if (BGE_CHIPREV(sc->bge_chipid) == BGE_CHIPREV_5703_AX ||
	    BGE_CHIPREV(sc->bge_chipid) == BGE_CHIPREV_5704_AX)
		sc->bge_flags |= BGE_PHY_ADC_BUG;
	if (sc->bge_chipid == BGE_CHIPID_BCM5704_A0)
		sc->bge_flags |= BGE_PHY_5704_A0_BUG;

	if ((BGE_IS_5705_PLUS(sc)) &&
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5906 &&
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5717 &&
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5785 &&
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM57765 &&
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM57780) {
		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5755 ||
		    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5761 ||
		    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5784 ||
		    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5787) {
			if (PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_BROADCOM_BCM5722 &&
			    PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_BROADCOM_BCM5756)
				sc->bge_flags |= BGE_PHY_JITTER_BUG;
			if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5755M)
				sc->bge_flags |= BGE_PHY_ADJUST_TRIM;
		} else
			sc->bge_flags |= BGE_PHY_BER_BUG;
d1578 1
d1584 6
a1589 7
	bge_chipinit(sc);

#ifdef __sparc64__
	if (!gotenaddr) {
		if (OF_getprop(PCITAG_NODE(pa->pa_tag), "local-mac-address",
		    sc->arpcom.ac_enaddr, ETHER_ADDR_LEN) == ETHER_ADDR_LEN)
			gotenaddr = 1;
a1590 1
#endif
d1595 15
a1609 12
	if (!gotenaddr) {
		mac_addr = bge_readmem_ind(sc, 0x0c14);
		if ((mac_addr >> 16) == 0x484b) {
			sc->arpcom.ac_enaddr[0] = (u_char)(mac_addr >> 8);
			sc->arpcom.ac_enaddr[1] = (u_char)mac_addr;
			mac_addr = bge_readmem_ind(sc, 0x0c18);
			sc->arpcom.ac_enaddr[2] = (u_char)(mac_addr >> 24);
			sc->arpcom.ac_enaddr[3] = (u_char)(mac_addr >> 16);
			sc->arpcom.ac_enaddr[4] = (u_char)(mac_addr >> 8);
			sc->arpcom.ac_enaddr[5] = (u_char)mac_addr;
			gotenaddr = 1;
		}
a1610 2
	if (!gotenaddr) {
		int mac_offset = BGE_EE_MAC_OFFSET;
d1612 5
a1616 26
		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906)
			mac_offset = BGE_EE_MAC_OFFSET_5906;

		if (bge_read_nvram(sc, (caddr_t)&sc->arpcom.ac_enaddr,
		    mac_offset + 2, ETHER_ADDR_LEN) == 0)
			gotenaddr = 1;
	}
	if (!gotenaddr && (!(sc->bge_flags & BGE_NO_EEPROM))) {
		if (bge_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,
		    BGE_EE_MAC_OFFSET + 2, ETHER_ADDR_LEN) == 0)
			gotenaddr = 1;
	}

#ifdef __sparc64__
	if (!gotenaddr) {
		extern void myetheraddr(u_char *);

		myetheraddr(sc->arpcom.ac_enaddr);
		gotenaddr = 1;
	}
#endif

	if (!gotenaddr) {
		printf(": failed to read station address\n");
		goto fail_1;
	}
d1623 2
a1624 2
		printf(": can't alloc rx buffers\n");
		goto fail_1;
d1630 4
a1633 3
		printf(": can't map dma buffers (%lu bytes)\n",
		    sizeof(struct bge_ring_data));
		goto fail_2;
d1639 5
a1643 2
		printf(": can't create dma map\n");
		goto fail_3;
d1649 5
a1653 1
		goto fail_4;
d1661 21
d1685 1
d1687 1
a1687 2
	sc->bge_tx_coal_ticks = 300;
	sc->bge_tx_max_coal_bds = 400;
d1690 3
a1692 3
	if (BGE_IS_5700_FAMILY(sc) ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57765)
a1693 2
	else
		sc->bge_return_ring_cnt = BGE_RETURN_RING_CNT_5705;
d1700 1
d1703 2
a1706 5

	/* lwm must be greater than the replenish threshold */
	m_clsetwms(ifp, MCLBYTES, 17, BGE_STD_RX_RING_CNT);
	m_clsetwms(ifp, BGE_JLEN, 17, BGE_JUMBO_RX_RING_CNT);

a1709 19
	ifp->if_capabilities = IFCAP_VLAN_MTU;

#if NVLAN > 0
	ifp->if_capabilities |= IFCAP_VLAN_HWTAGGING;
#endif

	/*
	 * 5700 B0 chips do not support checksumming correctly due
	 * to hardware bugs.
	 */
	if (sc->bge_chipid != BGE_CHIPID_BCM5700_B0)
		ifp->if_capabilities |= IFCAP_CSUM_IPv4;
#if 0	/* TCP/UDP checksum offload breaks with pf(4) */
		ifp->if_capabilities |= IFCAP_CSUM_TCPv4|IFCAP_CSUM_UDPv4;
#endif

	if (BGE_IS_JUMBO_CAPABLE(sc))
		ifp->if_hardmtu = BGE_JUMBO_MTU;

d1729 3
a1731 6
	else if (!(sc->bge_flags & BGE_NO_EEPROM)) {
		if (bge_read_eeprom(sc, (caddr_t)&hwcfg, BGE_EE_HWCFG_OFFSET,
		    sizeof(hwcfg))) {
			printf(": failed to read media type\n");
			goto fail_5;
		}
d1734 3
d1739 3
a1741 26
	if (PCI_PRODUCT(subid) == SK_SUBSYSID_9D41 ||
	    (hwcfg & BGE_HWCFG_MEDIA) == BGE_MEDIA_FIBER) {
		if (BGE_IS_5714_FAMILY(sc) ||
		    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717)
		    sc->bge_flags |= BGE_PHY_FIBER_MII;
		else
		    sc->bge_flags |= BGE_PHY_FIBER_TBI;
	}

	/* Hookup IRQ last. */
	DPRINTFN(5, ("pci_intr_establish\n"));
	sc->bge_intrhand = pci_intr_establish(pc, ih, IPL_NET, bge_intr, sc,
	    sc->bge_dev.dv_xname);
	if (sc->bge_intrhand == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		goto fail_5;
	}

	/*
	 * A Broadcom chip was detected. Inform the world.
	 */
	printf(": %s, address %s\n", intrstr,
	    ether_sprintf(sc->arpcom.ac_enaddr));
d1743 1
a1743 1
	if (sc->bge_flags & BGE_PHY_FIBER_TBI) {
a1750 1
		sc->bge_ifmedia.ifm_media = sc->bge_ifmedia.ifm_cur->ifm_media;
a1751 2
		int mii_flags;

a1756 3
		mii_flags = MIIF_DOPAUSE;
		if (sc->bge_flags & BGE_PHY_FIBER_MII)
			mii_flags |= MIIF_HAVEFIBER;
d1758 1
a1758 1
			   MII_PHY_ANY, MII_OFFSET_ANY, mii_flags);
d1772 21
d1795 1
d1797 1
d1799 1
a1799 1

d1801 2
a1802 18
	timeout_set(&sc->bge_rxtimeout, bge_rxtick, sc);
	return;

fail_5:
	bus_dmamap_unload(sc->bge_dmatag, sc->bge_ring_map);

fail_4:
	bus_dmamap_destroy(sc->bge_dmatag, sc->bge_ring_map);

fail_3:
	bus_dmamem_unmap(sc->bge_dmatag, kva,
	    sizeof(struct bge_ring_data));

fail_2:
	bus_dmamem_free(sc->bge_dmatag, &seg, rseg);

fail_1:
	bus_space_unmap(sc->bge_btag, sc->bge_bhandle, size);
d1805 3
a1807 2
int
bge_activate(struct device *self, int act)
d1809 5
a1813 3
	struct bge_softc *sc = (struct bge_softc *)self;
	struct ifnet *ifp = &sc->arpcom.ac_if;
	int rv = 0;
d1815 15
a1829 16
	switch (act) {
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
	case DVACT_SUSPEND:
		rv = config_activate_children(self, act);
		if (ifp->if_flags & IFF_RUNNING)
			bge_stop(sc);
		break;
	case DVACT_RESUME:
		if (ifp->if_flags & IFF_UP)
			bge_init(sc);
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
d1833 2
a1834 1
bge_reset(struct bge_softc *sc)
d1837 1
a1837 2
	pcireg_t cachesize, command, pcistate, new_pcistate;
	u_int32_t reset;
a1848 29
	/* Disable fastboot on controllers that support it. */
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5752 ||
	    BGE_IS_5755_PLUS(sc))
		CSR_WRITE_4(sc, BGE_FASTBOOT_PC, 0);

	reset = BGE_MISCCFG_RESET_CORE_CLOCKS|(65<<1);

	if (sc->bge_flags & BGE_PCIE) {
		if (CSR_READ_4(sc, 0x7e2c) == 0x60) {
			/* PCI Express 1.0 system */
			CSR_WRITE_4(sc, 0x7e2c, 0x20);
		}
		if (sc->bge_chipid != BGE_CHIPID_BCM5750_A0) {
			/*
			 * Prevent PCI Express link training
			 * during global reset.
			 */
			CSR_WRITE_4(sc, BGE_MISC_CFG, (1<<29));
			reset |= (1<<29);
		}
	}

	/*
	 * Set GPHY Power Down Override to leave GPHY
	 * powered up in D0 uninitialized.
	 */
	if (BGE_IS_5705_PLUS(sc))
		reset |= BGE_MISCCFG_KEEP_GPHY_POWER;

d1850 2
a1851 14
	bge_writereg_ind(sc, BGE_MISC_CFG, reset);

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906) {
		u_int32_t status, ctrl;

		status = CSR_READ_4(sc, BGE_VCPU_STATUS);
		CSR_WRITE_4(sc, BGE_VCPU_STATUS,
		    status | BGE_VCPU_STATUS_DRV_RESET);
		ctrl = CSR_READ_4(sc, BGE_VCPU_EXT_CTRL);
		CSR_WRITE_4(sc, BGE_VCPU_EXT_CTRL,
		    ctrl & ~BGE_VCPU_EXT_CTRL_HALT_CPU);

		sc->bge_flags |= BGE_NO_EEPROM;
	}
a1854 17
	if (sc->bge_flags & BGE_PCIE) {
		if (sc->bge_chipid == BGE_CHIPID_BCM5750_A0) {
			pcireg_t v;

			DELAY(500000); /* wait for link training to complete */
			v = pci_conf_read(pa->pa_pc, pa->pa_tag, 0xc4);
			pci_conf_write(pa->pa_pc, pa->pa_tag, 0xc4, v | (1<<15));
		}

		/*
		 * Set PCI Express max payload size to 128 bytes
		 * and clear error status.
		 */
		pci_conf_write(pa->pa_pc, pa->pa_tag,
		    BGE_PCI_CONF_DEV_CTRL, 0xf5000);
	}

d1864 1
a1864 6
	if (BGE_IS_5714_FAMILY(sc)) {
		u_int32_t val;

		val = CSR_READ_4(sc, BGE_MARB_MODE);
		CSR_WRITE_4(sc, BGE_MARB_MODE, BGE_MARBMODE_ENABLE | val);
	} else
d1867 1
a1867 1
 	/*
d1872 12
d1885 5
a1889 7
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906) {
		for (i = 0; i < BGE_TIMEOUT; i++) {
			val = CSR_READ_4(sc, BGE_VCPU_STATUS);
			if (val & BGE_VCPU_STATUS_INIT_DONE)
				break;
			DELAY(100);
		}
d1891 3
a1893 24
		if (i >= BGE_TIMEOUT)
			printf("%s: reset timed out\n", sc->bge_dev.dv_xname);
	} else {
		/*
		 * Poll until we see 1's complement of the magic number.
		 * This indicates that the firmware initialization
		 * is complete.  We expect this to fail if no SEEPROM
		 * is fitted.
		 */
		for (i = 0; i < BGE_TIMEOUT; i++) {
			val = bge_readmem_ind(sc, BGE_SOFTWARE_GENCOMM);
			if (val == ~BGE_MAGIC_NUMBER)
				break;
			DELAY(10);
		}

		if (i >= BGE_TIMEOUT && (!(sc->bge_flags & BGE_NO_EEPROM)))
			printf("%s: firmware handshake timed out\n",
			   sc->bge_dev.dv_xname);
	}

	/*
	 * XXX Wait for the value of the PCISTATE register to
	 * return to its original pre-reset state. This is a
d1900 2
a1901 4
		new_pcistate = pci_conf_read(pa->pa_pc, pa->pa_tag,
		    BGE_PCI_PCISTATE);
		if ((new_pcistate & ~BGE_PCISTATE_RESERVED) ==
		    (pcistate & ~BGE_PCISTATE_RESERVED))
a1904 5
	if ((new_pcistate & ~BGE_PCISTATE_RESERVED) != 
	    (pcistate & ~BGE_PCISTATE_RESERVED)) {
		DPRINTFN(5, ("%s: pcistate failed to revert\n",
		    sc->bge_dev.dv_xname));
	}
d1907 2
a1908 1
	CSR_WRITE_4(sc, BGE_MODE_CTL, BGE_DMA_SWAP_OPTIONS);
a1911 25
	/*
	 * The 5704 in TBI mode apparently needs some special
	 * adjustment to insure the SERDES drive level is set
	 * to 1.2V.
	 */
	if (sc->bge_flags & BGE_PHY_FIBER_TBI &&
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704) {
		u_int32_t serdescfg;

		serdescfg = CSR_READ_4(sc, BGE_SERDES_CFG);
		serdescfg = (serdescfg & ~0xFFF) | 0x880;
		CSR_WRITE_4(sc, BGE_SERDES_CFG, serdescfg);
	}

	if (sc->bge_flags & BGE_PCIE &&
	    sc->bge_chipid != BGE_CHIPID_BCM5750_A0 &&
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5717 &&
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5785 &&
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM57765) {
		u_int32_t v;

		/* Enable PCI Express bug fix */
		v = CSR_READ_4(sc, 0x7c00);
		CSR_WRITE_4(sc, 0x7c00, v | (1<<25));
	}
d1925 2
a1926 1
bge_rxeof(struct bge_softc *sc)
a1928 1
	uint16_t rx_prod, rx_cons;
a1929 11
	bus_dmamap_t dmamap;
	bus_addr_t offset, toff;
	bus_size_t tlen;
	int tosync;

	rx_cons = sc->bge_rx_saved_considx;
	rx_prod = sc->bge_rdata->bge_status_block.bge_idx[0].bge_rx_prod_idx;

	/* Nothing to do */
	if (rx_cons == rx_prod)
		return;
d1933 2
a1934 23
	bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
	    offsetof(struct bge_ring_data, bge_status_block),
	    sizeof (struct bge_status_block),
	    BUS_DMASYNC_POSTREAD);

	offset = offsetof(struct bge_ring_data, bge_rx_return_ring);
	tosync = rx_prod - rx_cons;

	toff = offset + (rx_cons * sizeof (struct bge_rx_bd));

	if (tosync < 0) {
		tlen = (sc->bge_return_ring_cnt - rx_cons) *
		    sizeof (struct bge_rx_bd);
		bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
		    toff, tlen, BUS_DMASYNC_POSTREAD);
		tosync = -tosync;
	}

	bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
	    offset, tosync * sizeof (struct bge_rx_bd),
	    BUS_DMASYNC_POSTREAD);

	while (rx_cons != rx_prod) {
d1938 7
d1946 2
a1947 1
		cur_rx = &sc->bge_rdata->bge_rx_return_ring[rx_cons];
d1950 8
a1957 1
		BGE_INC(rx_cons, sc->bge_return_ring_cnt);
d1960 1
a1962 1

a1963 7
			sc->bge_jumbo_cnt--;

			dmamap = sc->bge_cdata.bge_rx_jumbo_map[rxidx];
			bus_dmamap_sync(sc->bge_dmatag, dmamap, 0,
			    dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->bge_dmatag, dmamap);

d1965 8
a1972 1
				m_freem(m);
d1976 1
d1979 2
a1980 1

a1981 7
			sc->bge_std_cnt--;

			dmamap = sc->bge_cdata.bge_rx_std_map[rxidx];
			bus_dmamap_sync(sc->bge_dmatag, dmamap, 0,
			    dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->bge_dmatag, dmamap);

d1983 8
a1990 1
				m_freem(m);
d2001 1
a2001 1
		if (sc->bge_flags & BGE_RX_ALIGNBUG) {
d2010 1
d2012 1
a2012 2
		 * 5700 B0 chips do not support checksumming correctly due
		 * to hardware bugs.
d2014 3
a2016 16
		if (sc->bge_chipid != BGE_CHIPID_BCM5700_B0) {
			if (cur_rx->bge_flags & BGE_RXBDFLAG_IP_CSUM) {
				if (cur_rx->bge_ip_csum == 0xFFFF)
					m->m_pkthdr.csum_flags |=
					    M_IPV4_CSUM_IN_OK;
				else
					m->m_pkthdr.csum_flags |=
					    M_IPV4_CSUM_IN_BAD;
			}
			if (cur_rx->bge_flags & BGE_RXBDFLAG_TCP_UDP_CSUM &&
			    m->m_pkthdr.len >= ETHER_MIN_NOPAD) {
				if (cur_rx->bge_tcp_udp_csum == 0xFFFF)
					m->m_pkthdr.csum_flags |=
					    M_TCP_CSUM_IN_OK|M_UDP_CSUM_IN_OK;
			}
		}
d2018 10
a2027 4
#if NVLAN > 0
		if (cur_rx->bge_flags & BGE_RXBDFLAG_VLAN_TAG) {
			m->m_pkthdr.ether_vtag = cur_rx->bge_vlan_tag;
			m->m_flags |= M_VLANTAG;
d2030 3
d2034 1
a2034 1
#if NBPFILTER > 0
d2036 2
a2037 1
		 * Handle BPF listeners. Let the BPF user see the packet.
d2039 5
a2043 2
		if (ifp->if_bpf)
			bpf_mtap_ether(ifp->if_bpf, m, BPF_DIRECTION_IN);
a2044 1

d2048 1
a2048 2
	sc->bge_rx_saved_considx = rx_cons;
	bge_writembx(sc, BGE_MBX_RX_CONS0_LO, sc->bge_rx_saved_considx);
d2050 1
a2050 1
		bge_fill_rx_ring_std(sc);
d2052 1
a2052 1
		bge_fill_rx_ring_jumbo(sc);
d2056 2
a2057 1
bge_txeof(struct bge_softc *sc)
a2060 10
	struct txdmamap_pool_entry *dma;
	bus_addr_t offset, toff;
	bus_size_t tlen;
	int tosync;
	struct mbuf *m;

	/* Nothing to do */
	if (sc->bge_tx_saved_considx ==
	    sc->bge_rdata->bge_status_block.bge_idx[0].bge_tx_cons_idx)
		return;
a2063 23
	bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
	    offsetof(struct bge_ring_data, bge_status_block),
	    sizeof (struct bge_status_block),
	    BUS_DMASYNC_POSTREAD);

	offset = offsetof(struct bge_ring_data, bge_tx_ring);
	tosync = sc->bge_rdata->bge_status_block.bge_idx[0].bge_tx_cons_idx -
	    sc->bge_tx_saved_considx;

	toff = offset + (sc->bge_tx_saved_considx * sizeof (struct bge_tx_bd));

	if (tosync < 0) {
		tlen = (BGE_TX_RING_CNT - sc->bge_tx_saved_considx) *
		    sizeof (struct bge_tx_bd);
		bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
		    toff, tlen, BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
		tosync = -tosync;
	}

	bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
	    offset, tosync * sizeof (struct bge_tx_bd),
	    BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);

d2076 2
a2077 2
		m = sc->bge_cdata.bge_tx_chain[idx];
		if (m != NULL) {
d2079 2
a2080 8
			dma = sc->txdma[idx];
			bus_dmamap_sync(sc->bge_dmatag, dma->dmamap, 0,
			    dma->dmamap->dm_mapsize, BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->bge_dmatag, dma->dmamap);
			SLIST_INSERT_HEAD(&sc->txdma_list, dma, link);
			sc->txdma[idx] = NULL;

			m_freem(m);
d2084 1
d2087 1
a2087 1
	if (sc->bge_txcnt < BGE_TX_RING_CNT - 16)
a2088 2
	if (sc->bge_txcnt == 0)
		ifp->if_timer = 0;
d2092 2
a2093 1
bge_intr(void *xsc)
d2097 1
a2097 1
	u_int32_t statusword;
d2102 8
a2109 22
	/* It is possible for the interrupt to arrive before
	 * the status block is updated prior to the interrupt.
	 * Reading the PCI State register will confirm whether the
	 * interrupt is ours and will flush the status block.
	 */

	/* read status word from status block */
	statusword = sc->bge_rdata->bge_status_block.bge_status;

	if ((statusword & BGE_STATFLAG_UPDATED) ||
	    (!(CSR_READ_4(sc, BGE_PCI_PCISTATE) & BGE_PCISTATE_INTR_NOT_ACTIVE))) {

		/* Ack interrupt and stop others from occurring. */
		bge_writembx(sc, BGE_MBX_IRQ0_LO, 1);
			
		/* clear status word */
		sc->bge_rdata->bge_status_block.bge_status = 0;

		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700 ||
		    statusword & BGE_STATFLAG_LINKSTATE_CHANGED ||
		    BGE_STS_BIT(sc, BGE_STS_LINK_EVT))
			bge_link_upd(sc);
d2111 56
a2166 3
		if (ifp->if_flags & IFF_RUNNING) {
			/* Check RX return ring producer/consumer */
			bge_rxeof(sc);
d2168 2
a2169 2
			/* Check TX ring producer/consumer */
			bge_txeof(sc);
d2171 9
d2181 1
a2181 2
		/* Re-enable interrupts. */
		bge_writembx(sc, BGE_MBX_IRQ0_LO, 0);
d2183 4
d2189 1
a2189 3
		return (1);
	} else
		return (0);
d2193 2
a2194 1
bge_tick(void *xsc)
d2198 2
d2202 1
a2202 1
	s = splnet();
d2204 1
a2204 1
	if (BGE_IS_5705_PLUS(sc))
d2208 5
d2214 14
a2227 17
	if (sc->bge_flags & BGE_PHY_FIBER_TBI) {
		/*
		 * Since in TBI mode auto-polling can't be used we should poll
		 * link status manually. Here we register pending link event
		 * and trigger interrupt.
		 */
		BGE_STS_SETBIT(sc, BGE_STS_LINK_EVT);
		BGE_SETBIT(sc, BGE_MISC_LOCAL_CTL, BGE_MLC_INTR_SET);
	} else {
		/*
		 * Do not touch PHY if we have link up. This could break
		 * IPMI/ASF mode or produce extra input errors.
		 * (extra input errors was reported for bcm5701 & bcm5704).
		 */
		if (!BGE_STS_BIT(sc, BGE_STS_LINK))
			mii_tick(mii);
	}       
d2229 6
a2234 1
	timeout_add_sec(&sc->bge_timeout, 1);
d2240 2
a2241 1
bge_stats_update_regs(struct bge_softc *sc)
d2243 4
a2246 1
	struct ifnet *ifp = &sc->arpcom.ac_if;
d2248 1
a2248 2
	ifp->if_collisions += CSR_READ_4(sc, BGE_MAC_STATS +
	    offsetof(struct bge_mac_stats_regs, etherStatsCollisions));
d2250 5
a2254 1
	ifp->if_ierrors += CSR_READ_4(sc, BGE_RXLP_LOCSTAT_IFIN_DROPS);
d2256 6
a2261 1
	ifp->if_ierrors += CSR_READ_4(sc, BGE_RXLP_LOCSTAT_IFIN_ERRORS);
d2263 1
a2263 1
	ifp->if_ierrors += CSR_READ_4(sc, BGE_RXLP_LOCSTAT_OUT_OF_BDS);
d2267 2
a2268 1
bge_stats_update(struct bge_softc *sc)
a2271 1
	u_int32_t cnt;
d2276 10
a2285 19
	cnt = READ_STAT(sc, stats, txstats.etherStatsCollisions.bge_addr_lo);
	ifp->if_collisions += (u_int32_t)(cnt - sc->bge_tx_collisions);
	sc->bge_tx_collisions = cnt;

	cnt = READ_STAT(sc, stats, ifInDiscards.bge_addr_lo);
	ifp->if_ierrors += (u_int32_t)(cnt - sc->bge_rx_discards);
	sc->bge_rx_discards = cnt;

	cnt = READ_STAT(sc, stats, ifInErrors.bge_addr_lo);
	ifp->if_ierrors += (u_int32_t)(cnt - sc->bge_rx_inerrors);
	sc->bge_rx_inerrors = cnt;

	cnt = READ_STAT(sc, stats, nicNoMoreRxBDs.bge_addr_lo);
	ifp->if_ierrors += (u_int32_t)(cnt - sc->bge_rx_overruns);
	sc->bge_rx_overruns = cnt;

	cnt = READ_STAT(sc, stats, txstats.ifOutDiscards.bge_addr_lo);
	ifp->if_oerrors += (u_int32_t)(cnt - sc->bge_tx_discards);
	sc->bge_tx_discards = cnt;
a2287 1
}
d2289 7
a2295 56
/*
 * Compact outbound packets to avoid bug with DMA segments less than 8 bytes.
 */
int
bge_compact_dma_runt(struct mbuf *pkt)
{
	struct mbuf	*m, *prev, *n = NULL;
	int 		totlen, newprevlen;

	prev = NULL;
	totlen = 0;

	for (m = pkt; m != NULL; prev = m,m = m->m_next) {
		int mlen = m->m_len;
		int shortfall = 8 - mlen ;

		totlen += mlen;
		if (mlen == 0)
			continue;
		if (mlen >= 8)
			continue;

		/* If we get here, mbuf data is too small for DMA engine.
		 * Try to fix by shuffling data to prev or next in chain.
		 * If that fails, do a compacting deep-copy of the whole chain.
		 */

		/* Internal frag. If fits in prev, copy it there. */
		if (prev && M_TRAILINGSPACE(prev) >= m->m_len) {
			bcopy(m->m_data, prev->m_data+prev->m_len, mlen);
			prev->m_len += mlen;
			m->m_len = 0;
			/* XXX stitch chain */
			prev->m_next = m_free(m);
			m = prev;
			continue;
		} else if (m->m_next != NULL &&
			   M_TRAILINGSPACE(m) >= shortfall &&
			   m->m_next->m_len >= (8 + shortfall)) {
			/* m is writable and have enough data in next, pull up. */

			bcopy(m->m_next->m_data, m->m_data+m->m_len, shortfall);
			m->m_len += shortfall;
			m->m_next->m_len -= shortfall;
			m->m_next->m_data += shortfall;
		} else if (m->m_next == NULL || 1) {
			/* Got a runt at the very end of the packet.
			 * borrow data from the tail of the preceding mbuf and
			 * update its length in-place. (The original data is still
			 * valid, so we can do this even if prev is not writable.)
			 */

			/* if we'd make prev a runt, just move all of its data. */
#ifdef DEBUG
			KASSERT(prev != NULL /*, ("runt but null PREV")*/);
			KASSERT(prev->m_len >= 8 /*, ("runt prev")*/);
a2296 34
			if ((prev->m_len - shortfall) < 8)
				shortfall = prev->m_len;

			newprevlen = prev->m_len - shortfall;

			MGET(n, M_NOWAIT, MT_DATA);
			if (n == NULL)
				return (ENOBUFS);
			KASSERT(m->m_len + shortfall < MLEN
				/*,
				  ("runt %d +prev %d too big\n", m->m_len, shortfall)*/);

			/* first copy the data we're stealing from prev */
			bcopy(prev->m_data + newprevlen, n->m_data, shortfall);

			/* update prev->m_len accordingly */
			prev->m_len -= shortfall;

			/* copy data from runt m */
			bcopy(m->m_data, n->m_data + shortfall, m->m_len);

			/* n holds what we stole from prev, plus m */
			n->m_len = shortfall + m->m_len;

			/* stitch n into chain and free m */
			n->m_next = m->m_next;
			prev->m_next = n;
			/* KASSERT(m->m_next == NULL); */
			m->m_next = NULL;
			m_free(m);
			m = n;	/* for continuing loop */
		}
	}
	return (0);
d2300 1
a2300 45
 * Pad outbound frame to ETHER_MIN_NOPAD for an unusual reason.
 * The bge hardware will pad out Tx runts to ETHER_MIN_NOPAD,
 * but when such padded frames employ the bge IP/TCP checksum offload,
 * the hardware checksum assist gives incorrect results (possibly
 * from incorporating its own padding into the UDP/TCP checksum; who knows).
 * If we pad such runts with zeros, the onboard checksum comes out correct.
 */
int
bge_cksum_pad(struct mbuf *m)
{
	int padlen = ETHER_MIN_NOPAD - m->m_pkthdr.len;
	struct mbuf *last;

	/* If there's only the packet-header and we can pad there, use it. */
	if (m->m_pkthdr.len == m->m_len && M_TRAILINGSPACE(m) >= padlen) {
		last = m;
	} else {
		/*
		 * Walk packet chain to find last mbuf. We will either
		 * pad there, or append a new mbuf and pad it.
		 */
		for (last = m; last->m_next != NULL; last = last->m_next);
		if (M_TRAILINGSPACE(last) < padlen) {
			/* Allocate new empty mbuf, pad it. Compact later. */
			struct mbuf *n;

			MGET(n, M_DONTWAIT, MT_DATA);
			if (n == NULL)
				return (ENOBUFS);
			n->m_len = 0;
			last->m_next = n;
			last = n;
		}
	}
	
	/* Now zero the pad area, to avoid the bge cksum-assist bug. */
	memset(mtod(last, caddr_t) + last->m_len, 0, padlen);
	last->m_len += padlen;
	m->m_pkthdr.len += padlen;

	return (0);
}

/*
 * Encapsulate an mbuf chain in the tx ring by coupling the mbuf data
d2304 4
a2307 1
bge_encap(struct bge_softc *sc, struct mbuf *m_head, u_int32_t *txidx)
d2310 1
a2310 1
	u_int32_t		frag, cur;
d2312 1
a2312 2
	struct txdmamap_pool_entry *dma;
	bus_dmamap_t dmamap;
d2314 7
d2324 3
a2326 2
	if (m_head->m_pkthdr.csum_flags) {
		if (m_head->m_pkthdr.csum_flags & M_IPV4_CSUM_OUT)
d2328 2
a2329 2
		if (m_head->m_pkthdr.csum_flags & (M_TCP_CSUM_OUT |
		    M_UDP_CSUM_OUT)) {
d2331 6
a2336 4
			if (m_head->m_pkthdr.len < ETHER_MIN_NOPAD &&
			    bge_cksum_pad(m_head) != 0)
				return (ENOBUFS);
		}
d2338 1
a2338 17

	if (!(BGE_CHIPREV(sc->bge_chipid) == BGE_CHIPREV_5700_BX))
		goto doit;

	/*
	 * bcm5700 Revision B silicon cannot handle DMA descriptors with
	 * less than eight bytes.  If we encounter a teeny mbuf
	 * at the end of a chain, we can pad.  Otherwise, copy.
	 */
	if (bge_compact_dma_runt(m_head) != 0)
		return (ENOBUFS);

doit:
	dma = SLIST_FIRST(&sc->txdma_list);
	if (dma == NULL)
		return (ENOBUFS);
	dmamap = dma->dmamap;
d2345 2
a2346 1
	if (bus_dmamap_load_mbuf(sc->bge_dmatag, dmamap, m_head,
d2348 1
a2348 5
		return (ENOBUFS);

	/* Check if we have enough free send BDs. */
	if (sc->bge_txcnt + dmamap->dm_nsegs >= BGE_TX_RING_CNT)
		goto fail_unload;
d2350 1
a2350 1
	for (i = 0; i < dmamap->dm_nsegs; i++) {
d2354 2
a2355 2
		BGE_HOSTADDR(f->bge_addr, dmamap->dm_segs[i].ds_addr);
		f->bge_len = dmamap->dm_segs[i].ds_len;
a2356 1
		f->bge_vlan_tag = 0;
d2358 1
a2358 1
		if (m_head->m_flags & M_VLANTAG) {
d2360 3
a2362 1
			f->bge_vlan_tag = m_head->m_pkthdr.ether_vtag;
d2365 6
d2373 1
a2375 6
	if (i < dmamap->dm_nsegs)
		goto fail_unload;

	bus_dmamap_sync(sc->bge_dmatag, dmamap, 0, dmamap->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

d2377 1
a2377 1
		goto fail_unload;
d2381 1
a2381 3
	SLIST_REMOVE_HEAD(&sc->txdma_list, link);
	sc->txdma[cur] = dma;
	sc->bge_txcnt += dmamap->dm_nsegs;
d2385 1
a2385 6
	return (0);

fail_unload:
	bus_dmamap_unload(sc->bge_dmatag, dmamap);

	return (ENOBUFS);
d2393 2
a2394 1
bge_start(struct ifnet *ifp)
d2397 3
a2399 3
	struct mbuf *m_head;
	u_int32_t prodidx;
	int pkts;
d2403 1
a2403 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
a2404 4
	if (!BGE_STS_BIT(sc, BGE_STS_LINK))
		return;

	prodidx = sc->bge_tx_prodidx;
d2406 1
a2406 5
	for (pkts = 0; !IFQ_IS_EMPTY(&ifp->if_snd);) {
		if (sc->bge_txcnt > BGE_TX_RING_CNT - 16) {
			ifp->if_flags |= IFF_OACTIVE;
			break;
		}
d2408 1
d2414 19
d2452 1
a2452 1
			bpf_mtap_ether(ifp->if_bpf, m_head, BPF_DIRECTION_OUT);
d2459 4
a2462 5
	bge_writembx(sc, BGE_MBX_TX_HOST_PROD0_LO, prodidx);
	if (BGE_CHIPREV(sc->bge_chipid) == BGE_CHIPREV_5700_BX)
		bge_writembx(sc, BGE_MBX_TX_HOST_PROD0_LO, prodidx);

	sc->bge_tx_prodidx = prodidx;
d2471 2
a2472 1
bge_init(void *xsc)
a2476 1
	u_int32_t rxmode;
d2479 1
a2479 1
	s = splnet();
d2483 5
d2503 5
a2507 7
	/* Specify MRU. */
	if (BGE_IS_JUMBO_CAPABLE(sc))
		CSR_WRITE_4(sc, BGE_RX_MTU,
			BGE_JUMBO_FRAMELEN + ETHER_VLAN_ENCAP_LEN);
	else
		CSR_WRITE_4(sc, BGE_RX_MTU,
			ETHER_MAX_LEN + ETHER_VLAN_ENCAP_LEN);
d2514 5
a2518 3
	if (!(ifp->if_capabilities & IFCAP_VLAN_HWTAGGING)) {
		/* Disable hardware decapsulation of VLAN frames. */
		BGE_SETBIT(sc, BGE_RX_MODE, BGE_RXMODE_RX_KEEP_VLAN_DIAG);
d2521 2
a2522 2
	/* Program promiscuous mode and multicast filters. */
	bge_iff(sc);
d2545 2
a2546 2
	/* Init Jumbo RX ring. */
	if (BGE_IS_JUMBO_CAPABLE(sc))
a2551 7
	/* Init our RX/TX stat counters. */
	sc->bge_tx_collisions = 0;
	sc->bge_rx_discards = 0;
	sc->bge_rx_inerrors = 0;
	sc->bge_rx_overruns = 0;
	sc->bge_tx_discards = 0;

a2557 5
	rxmode = BGE_RXMODE_ENABLE;

	if (BGE_IS_5755_PLUS(sc))
		rxmode |= BGE_RXMODE_RX_IPV6_CSUM_ENABLE;

d2559 1
a2559 3
	BGE_SETBIT(sc, BGE_RX_MODE, rxmode);

	CSR_WRITE_4(sc, BGE_MAX_RX_FRAME_LOWAT, 2);
d2567 1
a2567 1
	bge_writembx(sc, BGE_MBX_IRQ0_LO, 0);
d2576 1
a2576 1
	timeout_add_sec(&sc->bge_timeout, 1);
d2583 2
a2584 1
bge_ifmedia_upd(struct ifnet *ifp)
d2591 1
a2591 1
	if (sc->bge_flags & BGE_PHY_FIBER_TBI) {
d2593 1
a2593 1
			return (EINVAL);
a2595 20
			/*
			 * The BCM5704 ASIC appears to have a special
			 * mechanism for programming the autoneg
			 * advertisement registers in TBI mode.
			 */
			if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704) {
				u_int32_t sgdig;
				sgdig = CSR_READ_4(sc, BGE_SGDIG_STS);
				if (sgdig & BGE_SGDIGSTS_DONE) {
					CSR_WRITE_4(sc, BGE_TX_TBI_AUTONEG, 0);
					sgdig = CSR_READ_4(sc, BGE_SGDIG_CFG);
					sgdig |= BGE_SGDIGCFG_AUTO |
					    BGE_SGDIGCFG_PAUSE_CAP |
					    BGE_SGDIGCFG_ASYM_PAUSE;
					CSR_WRITE_4(sc, BGE_SGDIG_CFG,
					    sgdig | BGE_SGDIGCFG_SEND);
					DELAY(5);
					CSR_WRITE_4(sc, BGE_SGDIG_CFG, sgdig);
				}
			}
d2607 1
a2607 1
			return (EINVAL);
d2609 1
a2609 2
		/* XXX 802.3x flow control for 1000BASE-SX */
		return (0);
d2612 1
a2612 1
	BGE_STS_SETBIT(sc, BGE_STS_LINK_EVT);
d2615 2
a2616 1
		LIST_FOREACH(miisc, &mii->mii_phys, mii_list)
d2621 1
a2621 15
	/*
	 * Force an interrupt so that we will call bge_link_upd
	 * if needed and clear any pending link state attention.
	 * Without this we are not getting any further interrupts
	 * for link state changes and thus will not UP the link and
	 * not be able to send in bge_start. The only way to get
	 * things working was to receive a packet and get a RX intr.
	 */
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700 ||
	    sc->bge_flags & BGE_IS_5788)
		BGE_SETBIT(sc, BGE_MISC_LOCAL_CTL, BGE_MLC_INTR_SET);
	else
		BGE_SETBIT(sc, BGE_HCC_MODE, BGE_HCCMODE_COAL_NOW);

	return (0);
d2628 3
a2630 1
bge_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)
d2635 1
a2635 1
	if (sc->bge_flags & BGE_PHY_FIBER_TBI) {
d2639 1
a2639 1
		    BGE_MACSTAT_TBI_PCS_SYNCHED) {
a2640 4
		} else {
			ifmr->ifm_active |= IFM_NONE;
			return;
		}
d2650 1
a2651 2
	ifmr->ifm_active = (mii->mii_media_active & ~IFM_ETH_FMASK) |
	    sc->bge_flowflags;
d2655 4
a2658 1
bge_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
a2660 1
	struct ifaddr *ifa = (struct ifaddr *) data;
d2662 1
d2666 6
a2671 1
	s = splnet();
d2676 3
a2678 1
		if (!(ifp->if_flags & IFF_RUNNING))
a2679 2
#ifdef INET
		if (ifa->ifa_addr->sa_family == AF_INET)
d2681 1
d2683 12
a2695 1

d2698 19
a2716 3
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
d2719 1
a2719 1
			if (ifp->if_flags & IFF_RUNNING)
d2721 10
a2732 1

a2733 20
		/* XXX Flow control is not supported for 1000BASE-SX */
		if (sc->bge_flags & BGE_PHY_FIBER_TBI) {
			ifr->ifr_media &= ~IFM_ETH_FMASK;
			sc->bge_flowflags = 0;
		}

		/* Flow control requires full-duplex mode. */
		if (IFM_SUBTYPE(ifr->ifr_media) == IFM_AUTO ||
		    (ifr->ifr_media & IFM_FDX) == 0) {
		    	ifr->ifr_media &= ~IFM_ETH_FMASK;
		}
		if (IFM_SUBTYPE(ifr->ifr_media) != IFM_AUTO) {
			if ((ifr->ifr_media & IFM_ETH_FMASK) == IFM_FLOW) {
				/* We can do both TXPAUSE and RXPAUSE. */
				ifr->ifr_media |=
				    IFM_ETH_TXPAUSE | IFM_ETH_RXPAUSE;
			}
			sc->bge_flowflags = ifr->ifr_media & IFM_ETH_FMASK;
		}
		/* FALLTHROUGH */
d2735 1
a2735 1
		if (sc->bge_flags & BGE_PHY_FIBER_TBI) {
d2743 1
a2744 1

d2746 2
a2747 1
		error = ether_ioctl(ifp, &sc->arpcom, command, data);
d2750 1
a2750 5
	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			bge_iff(sc);
		error = 0;
	}
d2752 1
a2752 2
	splx(s);
	return (error);
d2756 2
a2757 1
bge_watchdog(struct ifnet *ifp)
d2765 1
a2770 17
void
bge_stop_block(struct bge_softc *sc, bus_size_t reg, u_int32_t bit)
{
	int i;

	BGE_CLRBIT(sc, reg, bit);

	for (i = 0; i < BGE_TIMEOUT; i++) {
		if ((CSR_READ_4(sc, reg) & bit) == 0)
			return;
		delay(100);
	}

	DPRINTFN(5, ("%s: block failed to stop: reg 0x%lx, bit 0x%08x\n",
	    sc->bge_dev.dv_xname, (u_long) reg, bit));
}

d2776 2
a2777 1
bge_stop(struct bge_softc *sc)
a2784 3
	timeout_del(&sc->bge_rxtimeout);

	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
d2789 8
a2796 8
	bge_stop_block(sc, BGE_RX_MODE, BGE_RXMODE_ENABLE);
	bge_stop_block(sc, BGE_RBDI_MODE, BGE_RBDIMODE_ENABLE);
	bge_stop_block(sc, BGE_RXLP_MODE, BGE_RXLPMODE_ENABLE);
	if (BGE_IS_5700_FAMILY(sc))
		bge_stop_block(sc, BGE_RXLS_MODE, BGE_RXLSMODE_ENABLE);
	bge_stop_block(sc, BGE_RDBDI_MODE, BGE_RBDIMODE_ENABLE);
	bge_stop_block(sc, BGE_RDC_MODE, BGE_RDCMODE_ENABLE);
	bge_stop_block(sc, BGE_RBDC_MODE, BGE_RBDCMODE_ENABLE);
d2801 8
a2808 8
	bge_stop_block(sc, BGE_SRS_MODE, BGE_SRSMODE_ENABLE);
	bge_stop_block(sc, BGE_SBDI_MODE, BGE_SBDIMODE_ENABLE);
	bge_stop_block(sc, BGE_SDI_MODE, BGE_SDIMODE_ENABLE);
	bge_stop_block(sc, BGE_RDMA_MODE, BGE_RDMAMODE_ENABLE);
	bge_stop_block(sc, BGE_SDC_MODE, BGE_SDCMODE_ENABLE);
	if (BGE_IS_5700_FAMILY(sc))
		bge_stop_block(sc, BGE_DMAC_MODE, BGE_DMACMODE_ENABLE);
	bge_stop_block(sc, BGE_SBDC_MODE, BGE_SBDCMODE_ENABLE);
d2814 4
a2817 5
	bge_stop_block(sc, BGE_HCC_MODE, BGE_HCCMODE_ENABLE);
	bge_stop_block(sc, BGE_WDMA_MODE, BGE_WDMAMODE_ENABLE);
	if (BGE_IS_5700_FAMILY(sc))
		bge_stop_block(sc, BGE_MBCF_MODE, BGE_MBCFMODE_ENABLE);

d2820 3
a2822 4

	if (BGE_IS_5700_FAMILY(sc)) {
		bge_stop_block(sc, BGE_BMAN_MODE, BGE_BMANMODE_ENABLE);
		bge_stop_block(sc, BGE_MARB_MODE, BGE_MARBMODE_ENABLE);
d2827 1
a2827 1
	bge_writembx(sc, BGE_MBX_IRQ0_LO, 1);
d2838 1
a2838 1
	if (BGE_IS_JUMBO_CAPABLE(sc))
d2849 1
a2849 1
	if (!(sc->bge_flags & BGE_PHY_FIBER_TBI)) {
d2861 2
d2865 1
a2865 2
	/* Clear MAC's link state (PHY may still have link UP). */
	BGE_STS_CLRBIT(sc, BGE_STS_LINK);
d2868 4
d2873 2
a2874 1
bge_link_upd(struct bge_softc *sc)
d2876 1
a2876 4
	struct ifnet *ifp = &sc->arpcom.ac_if;
	struct mii_data *mii = &sc->bge_mii;
	u_int32_t status;
	int link;
d2878 3
a2880 2
	/* Clear 'pending link event' flag */
	BGE_STS_CLRBIT(sc, BGE_STS_LINK_EVT);
d2882 3
a2884 16
	/*
	 * Process link state changes.
	 * Grrr. The link status word in the status block does
	 * not work correctly on the BCM5700 rev AX and BX chips,
	 * according to all available information. Hence, we have
	 * to enable MII interrupts in order to properly obtain
	 * async link changes. Unfortunately, this also means that
	 * we have to read the MAC status register to detect link
	 * changes, thereby adding an additional register access to
	 * the interrupt handler.
	 *
	 */
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700) {
		status = CSR_READ_4(sc, BGE_MAC_STS);
		if (status & BGE_MACSTAT_MI_INTERRUPT) {
			mii_pollstat(mii);
d2886 3
a2888 75
			if (!BGE_STS_BIT(sc, BGE_STS_LINK) &&
			    mii->mii_media_status & IFM_ACTIVE &&
			    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE)
				BGE_STS_SETBIT(sc, BGE_STS_LINK);
			else if (BGE_STS_BIT(sc, BGE_STS_LINK) &&
			    (!(mii->mii_media_status & IFM_ACTIVE) ||
			    IFM_SUBTYPE(mii->mii_media_active) == IFM_NONE))
				BGE_STS_CLRBIT(sc, BGE_STS_LINK);

			/* Clear the interrupt */
			CSR_WRITE_4(sc, BGE_MAC_EVT_ENB,
			    BGE_EVTENB_MI_INTERRUPT);
			bge_miibus_readreg(&sc->bge_dev, 1, BRGPHY_MII_ISR);
			bge_miibus_writereg(&sc->bge_dev, 1, BRGPHY_MII_IMR,
			    BRGPHY_INTRS);
		}
		return;
	} 

	if (sc->bge_flags & BGE_PHY_FIBER_TBI) {
		status = CSR_READ_4(sc, BGE_MAC_STS);
		if (status & BGE_MACSTAT_TBI_PCS_SYNCHED) {
			if (!BGE_STS_BIT(sc, BGE_STS_LINK)) {
				BGE_STS_SETBIT(sc, BGE_STS_LINK);
				if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704)
					BGE_CLRBIT(sc, BGE_MAC_MODE,
					    BGE_MACMODE_TBI_SEND_CFGS);
				CSR_WRITE_4(sc, BGE_MAC_STS, 0xFFFFFFFF);
				status = CSR_READ_4(sc, BGE_MAC_MODE);
				ifp->if_link_state =
				    (status & BGE_MACMODE_HALF_DUPLEX) ?
				    LINK_STATE_HALF_DUPLEX :
				    LINK_STATE_FULL_DUPLEX;
				if_link_state_change(ifp);
				ifp->if_baudrate = IF_Gbps(1);
			}
		} else if (BGE_STS_BIT(sc, BGE_STS_LINK)) {
			BGE_STS_CLRBIT(sc, BGE_STS_LINK);
			ifp->if_link_state = LINK_STATE_DOWN;
			if_link_state_change(ifp);
			ifp->if_baudrate = 0;
		}
        /*
	 * Discard link events for MII/GMII cards if MI auto-polling disabled.
	 * This should not happen since mii callouts are locked now, but
	 * we keep this check for debug.
	 */
	} else if (BGE_STS_BIT(sc, BGE_STS_AUTOPOLL)) {
		/* 
		 * Some broken BCM chips have BGE_STATFLAG_LINKSTATE_CHANGED bit
		 * in status word always set. Workaround this bug by reading
		 * PHY link status directly.
		 */
		link = (CSR_READ_4(sc, BGE_MI_STS) & BGE_MISTS_LINK)?
		    BGE_STS_LINK : 0;

		if (BGE_STS_BIT(sc, BGE_STS_LINK) != link) {
			mii_pollstat(mii);

			if (!BGE_STS_BIT(sc, BGE_STS_LINK) &&
			    mii->mii_media_status & IFM_ACTIVE &&
			    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE)
				BGE_STS_SETBIT(sc, BGE_STS_LINK);
			else if (BGE_STS_BIT(sc, BGE_STS_LINK) &&
			    (!(mii->mii_media_status & IFM_ACTIVE) ||
			    IFM_SUBTYPE(mii->mii_media_active) == IFM_NONE))
				BGE_STS_CLRBIT(sc, BGE_STS_LINK);
		}
	}

	/* Clear the attention */
	CSR_WRITE_4(sc, BGE_MAC_STS, BGE_MACSTAT_SYNC_CHANGED|
	    BGE_MACSTAT_CFG_CHANGED|BGE_MACSTAT_MI_COMPLETE|
	    BGE_MACSTAT_LINK_CHANGED);
}
@

