head	1.7;
access;
symbols
	tg-beforemerge-ksrc10:1.1.1.4
	MIRBSD_10:1.7.0.2
	MIRBSD_10_BASE:1.7
	cvs-200702062030:1.1.1.4
	MIRBSD_9_BASE:1.5
	MIRBSD_8:1.4.0.2
	MIRBSD_8_BASE:1.4
	cvs-200507032030:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2007.02.07.05.06.24;	author tg;	state Exp;
branches;
next	1.6;
commitid	10045C95C1B0E7E9B85;

1.6
date	2007.02.06.20.54.50;	author tg;	state Exp;
branches;
next	1.5;
commitid	10045C8EB2F4CD8021C;

1.5
date	2006.05.25.12.20.25;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004475A0E83E9B8F47;

1.4
date	2005.07.21.21.52.20;	author tg;	state Exp;
branches;
next	1.3;
commitid	181c42e0191f67ef;

1.3
date	2005.07.04.01.15.48;	author tg;	state Exp;
branches;
next	1.2;
commitid	529442c88dcc63a0;

1.2
date	2005.03.06.21.27.58;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.28.45;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.28.45;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.07.04.01.13.57;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	76bf42c88d6bc5d8;

1.1.1.3
date	2005.07.21.21.39.44;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	5f0d42e015f52f66;

1.1.1.4
date	2007.02.06.20.51.48;	author tg;	state Exp;
branches;
next	;
commitid	10045C8EA6658CBB47A;


desc
@@


1.7
log
@* vga, ega: prevent running off the colour<->wscolour arrays
* all ws* drivers: change unpack_attr() last argument from
  "ul" (1=underlined/0=not) to "flags" which can take these
  values, OR'd together:
  - WSATTR_UNDERLINE (as before)
  - WSATTR_REVERSE (if WSCREEN_REVERSE and not WSSCREEN_WSCOLORS)
  - WSATTR_HILIT
* wsdisplay.c (inverse_char): instead of the current logic to
  invert and flip back a character when the wsmouse pointer
  goes over it, which left bold characters inverse or blinking
  characters without their blinking attribute, keep the old
  flags, toggle the WSATTR_REVERSE attribute for screens that
  can do that, swap as used otherwise (the fg and bg values
  will be &'d with 0x07 anyway, so we don't need to do that,
  and the other attributes are kept in flags)
* rasops: the "attr" was coded until now as
  ffffffffbbbbbbbb0000000000000BFu
  where f=fg, b=bg, B=bg-is-grey, F=fg-is-grey, u=underlined
  and we now encode it as
  ffffffffbbbbbbbb000000000000iBFu
  where i=inverse, the others as above, and 'i' is only set
  when we set the fg/bg colour before testing for WSATTR_REVERSE
  in rasops_alloc_?attr() but not if we do the WSATTR_WSCOLORS swap

This fixes junk left behind by the text mode mouse cursor
when leaving its trail on bold or blinking text. Only vga
could be tested; ega should be the same.

XXX vga/ega mono fg-white underlined seems crazy to me,
XXX 0x01 should expand to fg=white bg=black attr=underlined IMHO
@
text
@/* $MirOS: src/sys/dev/wscons/wsdisplay.c,v 1.6 2007/02/06 20:54:50 tg Exp $ */
/* $OpenBSD: wsdisplay.c,v 1.75 2007/01/07 13:28:04 miod Exp $ */
/* $NetBSD: wsdisplay.c,v 1.82 2005/02/27 00:27:52 perry Exp $ */

/*
 * Copyright (c) 1996, 1997 Christopher G. Demetriou.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christopher G. Demetriou
 *	for the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef	SMALL_KERNEL
#define WSMOUSED_SUPPORT
#define	BURNER_SUPPORT
#define	WSDISPLAY_SCROLLBACK_SUPPORT
#endif

#include <sys/param.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/malloc.h>
#include <sys/syslog.h>
#include <sys/systm.h>
#include <sys/tty.h>
#include <sys/signalvar.h>
#include <sys/errno.h>
#include <sys/fcntl.h>
#include <sys/vnode.h>
#include <sys/timeout.h>
#include <sys/poll.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wsksymvar.h>
#include <dev/wscons/wsksymdef.h>
#include <dev/wscons/wsemulvar.h>
#include <dev/wscons/wscons_callbacks.h>
#include <dev/cons.h>

#include "wsdisplay.h"
#include "wskbd.h"
#include "wsmouse.h"
#include "wsmux.h"

#if NWSKBD > 0
#include <dev/wscons/wseventvar.h>
#include <dev/wscons/wsmuxvar.h>
#endif

#if NWSMOUSE > 0
#include <dev/wscons/wsmousevar.h>
#endif

#include "wsmoused.h"

#if NWSMOUSE > 0
extern struct cfdriver wsmouse_cd;
#endif /* NWSMOUSE > 0 */

struct wsscreen_internal {
	const struct wsdisplay_emulops *emulops;
	void	*emulcookie;

	const struct wsscreen_descr *scrdata;

	const struct wsemul_ops *wsemul;
	void	*wsemulcookie;
};

struct wsscreen {
	struct wsscreen_internal *scr_dconf;

	struct tty *scr_tty;
	int	scr_hold_screen;		/* hold tty output */

	int scr_flags;
#define SCR_OPEN 1		/* is it open? */
#define SCR_WAITACTIVE 2	/* someone waiting on activation */
#define SCR_GRAPHICS 4		/* graphics mode, no text (emulation) output */
#define	SCR_DUMBFB 8		/* in use as dumb fb (iff SCR_GRAPHICS) */

#ifdef WSDISPLAY_COMPAT_USL
	const struct wscons_syncops *scr_syncops;
	void *scr_synccookie;
#endif

#ifdef WSDISPLAY_COMPAT_RAWKBD
	int scr_rawkbd;
#endif

	struct wsdisplay_softc *sc;

#ifdef WSMOUSED_SUPPORT
	/* mouse console support via wsmoused(8) */
	unsigned short mouse;		/* mouse cursor position */
	unsigned short cursor;		/* selection cursor position (if
					different from mouse cursor pos) */
	unsigned short cpy_start;	/* position of the copy start mark*/
	unsigned short cpy_end;		/* position of the copy end mark */
	unsigned short orig_start;	/* position of the original sel. start*/
	unsigned short orig_end;	/* position of the original sel. end */
#define MOUSE_VISIBLE	(1 << 0)	/* flag, the mouse cursor is visible */
#define SEL_EXISTS	(1 << 1)	/* flag, a selection exists */
#define SEL_IN_PROGRESS (1 << 2)	/* flag, a selection is in progress */
#define SEL_EXT_AFTER	(1 << 3)	/* flag, selection is extended after */
#define BLANK_TO_EOL	(1 << 4)	/* flag, there are only blanks
					   characters to eol */
#define SEL_BY_CHAR	(1 << 5)	/* flag, select character by character*/
#define SEL_BY_WORD	(1 << 6)	/* flag, select word by word */
#define SEL_BY_LINE	(1 << 7)	/* flag, select line by line */

#define IS_MOUSE_VISIBLE(ws) ((ws)->mouse_flags & MOUSE_VISIBLE)
#define IS_SEL_EXISTS(ws) ((ws)->mouse_flags & SEL_EXISTS)
#define IS_SEL_IN_PROGRESS(ws) ((ws)->mouse_flags & SEL_IN_PROGRESS)
#define IS_SEL_EXT_AFTER(ws) ((ws)->mouse_flags & SEL_EXT_AFTER)
#define IS_BLANK_TO_EOL(ws) ((ws)->mouse_flags & BLANK_TO_EOL)
#define IS_SEL_BY_CHAR(ws) ((ws)->mouse_flags & SEL_BY_CHAR)
#define IS_SEL_BY_WORD(ws) ((ws)->mouse_flags & SEL_BY_WORD)
#define IS_SEL_BY_LINE(ws) ((ws)->mouse_flags & SEL_BY_LINE)
	unsigned char mouse_flags;	/* flags, status of the mouse */
#endif	/* WSMOUSED_SUPPORT */
};

struct wsscreen *wsscreen_attach(struct wsdisplay_softc *, int, const char *,
	    const struct wsscreen_descr *, void *, int, int, long);
void	wsscreen_detach(struct wsscreen *);
int	wsdisplay_addscreen(struct wsdisplay_softc *, int, const char *,
	    const char *);
int	wsdisplay_getscreen(struct wsdisplay_softc *,
	    struct wsdisplay_addscreendata *);
void	wsdisplay_shutdownhook(void *);
void	wsdisplay_addscreen_print(struct wsdisplay_softc *, int, int);
void	wsdisplay_closescreen(struct wsdisplay_softc *, struct wsscreen *);
int	wsdisplay_delscreen(struct wsdisplay_softc *, int, int);
void	wsdisplay_burner(void *v);

struct wsdisplay_softc {
	struct device sc_dv;

	const struct wsdisplay_accessops *sc_accessops;
	void	*sc_accesscookie;

	const struct wsscreen_list *sc_scrdata;

	struct wsscreen *sc_scr[WSDISPLAY_MAXSCREEN];
	int sc_focusidx;	/* available only if sc_focus isn't null */
	struct wsscreen *sc_focus;

#ifdef BURNER_SUPPORT
	struct timeout sc_burner;
	int	sc_burnoutintvl;
	int	sc_burninintvl;
	int	sc_burnout;
	int	sc_burnman;
	int	sc_burnflags;
#endif

	struct wsdisplay_font sc_fonts[WSDISPLAY_MAXFONT];

	int	sc_isconsole;

	int sc_flags;
#define SC_SWITCHPENDING 1
	int sc_screenwanted, sc_oldscreen; /* valid with SC_SWITCHPENDING */

#if NWSKBD > 0
	struct wsevsrc *sc_input;
#ifdef WSDISPLAY_COMPAT_RAWKBD
	int sc_rawkbd;
#endif
#endif /* NWSKBD > 0 */

#ifdef WSMOUSED_SUPPORT
	dev_t wsmoused_dev; /* device opened by wsmoused(8), when active */
	int wsmoused_sleep; /* true when wsmoused(8) is sleeping */
#endif
};

extern struct cfdriver wsdisplay_cd;

/* Autoconfiguration definitions. */
int	wsdisplay_emul_match(struct device *, void *, void *);
void	wsdisplay_emul_attach(struct device *, struct device *, void *);
int	wsdisplay_emul_detach(struct device *, int);

struct cfdriver wsdisplay_cd = {
	NULL, "wsdisplay", DV_TTY
};

struct cfattach wsdisplay_emul_ca = {
	sizeof(struct wsdisplay_softc), wsdisplay_emul_match,
	    wsdisplay_emul_attach, wsdisplay_emul_detach
};

void	wsdisplaystart(struct tty *);
int	wsdisplayparam(struct tty *, struct termios *);

/* Internal macros, functions, and variables. */
#define	WSDISPLAYUNIT(dev)		(minor(dev) >> 8)
#define	WSDISPLAYSCREEN(dev)		(minor(dev) & 0xff)
#define ISWSDISPLAYCTL(dev)		(WSDISPLAYSCREEN(dev) == 255)
#define WSDISPLAYMINOR(unit, screen)	(((unit) << 8) | (screen))

#define	WSSCREEN_HAS_TTY(scr)		((scr)->scr_tty != NULL)

void	wsdisplay_common_attach(struct wsdisplay_softc *sc,
	    int console, int mux, const struct wsscreen_list *,
	    const struct wsdisplay_accessops *accessops,
	    void *accesscookie, u_int defaultscreens);
int	wsdisplay_common_detach(struct wsdisplay_softc *, int);

#ifdef WSDISPLAY_COMPAT_RAWKBD
int	wsdisplay_update_rawkbd(struct wsdisplay_softc *, struct wsscreen *);
#endif

int	wsdisplay_console_initted;
struct wsdisplay_softc *wsdisplay_console_device;
struct wsscreen_internal wsdisplay_console_conf;

int	wsdisplay_getc_dummy(dev_t);
void	wsdisplay_pollc(dev_t, int);

int	wsdisplay_cons_pollmode;
void	(*wsdisplay_cons_kbd_pollc)(dev_t, int);

struct consdev wsdisplay_cons = {
	NULL, NULL, wsdisplay_getc_dummy, wsdisplay_cnputc,
	    wsdisplay_pollc, NULL, NODEV, CN_NORMAL
};

#ifndef WSDISPLAY_DEFAULTSCREENS
#define WSDISPLAY_DEFAULTSCREENS	1
#endif
int	wsdisplay_defaultscreens = WSDISPLAY_DEFAULTSCREENS;

int	wsdisplay_switch1(void *, int, int);
int	wsdisplay_switch2(void *, int, int);
int	wsdisplay_switch3(void *, int, int);

int	wsdisplay_clearonclose;

#ifdef WSMOUSED_SUPPORT
char *Copybuffer;
u_int Copybuffer_size;
char Paste_avail;
#endif

struct wsscreen *
wsscreen_attach(struct wsdisplay_softc *sc, int console, const char *emul,
    const struct wsscreen_descr *type, void *cookie, int ccol, int crow,
    long defattr)
{
	struct wsscreen_internal *dconf;
	struct wsscreen *scr;

	scr = malloc(sizeof(struct wsscreen), M_DEVBUF, M_NOWAIT);
	if (!scr)
		return (NULL);

	if (console) {
		dconf = &wsdisplay_console_conf;
		/*
		 * Tell the emulation about the callback argument.
		 * The other stuff is already there.
		 */
		(void)(*dconf->wsemul->attach)(1, 0, 0, 0, 0, scr, 0);
	} else { /* not console */
		dconf = malloc(sizeof(struct wsscreen_internal),
		    M_DEVBUF, M_NOWAIT);
		if (dconf == NULL)
			goto fail;
		dconf->emulops = type->textops;
		dconf->emulcookie = cookie;
		if (dconf->emulops == NULL ||
		    (dconf->wsemul = wsemul_pick(emul)) == NULL)
			goto fail;
		dconf->wsemulcookie = (*dconf->wsemul->attach)(0, type, cookie,
		    ccol, crow, scr, defattr);
		if (dconf->wsemulcookie == NULL)
			goto fail;
		dconf->scrdata = type;
	}

	scr->scr_dconf = dconf;

	scr->scr_tty = ttymalloc();
	scr->scr_hold_screen = 0;
	scr->scr_flags = 0;

#ifdef WSDISPLAY_COMPAT_USL
	scr->scr_syncops = NULL;
#endif

	scr->sc = sc;
#ifdef WSMOUSED_SUPPORT
	scr->mouse_flags = 0;
#endif
#ifdef WSDISPLAY_COMPAT_RAWKBD
	scr->scr_rawkbd = 0;
#endif
	return (scr);

fail:
	if (dconf != NULL)
		free(dconf, M_DEVBUF);
	free(scr, M_DEVBUF);
	return (NULL);
}

void
wsscreen_detach(struct wsscreen *scr)
{
	int ccol, crow; /* XXX */

	if (WSSCREEN_HAS_TTY(scr)) {
		timeout_del(&scr->scr_tty->t_rstrt_to);
		ttyfree(scr->scr_tty);
	}
	(*scr->scr_dconf->wsemul->detach)(scr->scr_dconf->wsemulcookie,
	    &ccol, &crow);
	free(scr->scr_dconf, M_DEVBUF);
	free(scr, M_DEVBUF);
}

const struct wsscreen_descr *
wsdisplay_screentype_pick(const struct wsscreen_list *scrdata, const char *name)
{
	int i;
	const struct wsscreen_descr *scr;

	KASSERT(scrdata->nscreens > 0);

	if (name == NULL || *name == '\0')
		return (scrdata->screens[0]);

	for (i = 0; i < scrdata->nscreens; i++) {
		scr = scrdata->screens[i];
		if (!strncmp(name, scr->name, WSSCREEN_NAME_SIZE))
			return (scr);
	}

	return (0);
}

/*
 * print info about attached screen
 */
void
wsdisplay_addscreen_print(struct wsdisplay_softc *sc, int idx, int count)
{
	printf("%s: screen %d", sc->sc_dv.dv_xname, idx);
	if (count > 1)
		printf("-%d", idx + (count-1));
	printf(" added (%s, %s emulation)\n",
	    sc->sc_scr[idx]->scr_dconf->scrdata->name,
	    sc->sc_scr[idx]->scr_dconf->wsemul->name);
}

int
wsdisplay_addscreen(struct wsdisplay_softc *sc, int idx,
    const char *screentype, const char *emul)
{
	const struct wsscreen_descr *scrdesc;
	int error;
	void *cookie;
	int ccol, crow;
	long defattr;
	struct wsscreen *scr;
	int s;

	if (idx < 0 || idx >= WSDISPLAY_MAXSCREEN)
		return (EINVAL);
	if (sc->sc_scr[idx] != NULL)
		return (EBUSY);

	scrdesc = wsdisplay_screentype_pick(sc->sc_scrdata, screentype);
	if (!scrdesc)
		return (ENXIO);
	error = (*sc->sc_accessops->alloc_screen)(sc->sc_accesscookie,
	    scrdesc, &cookie, &ccol, &crow, &defattr);
	if (error)
		return (error);

	scr = wsscreen_attach(sc, 0, emul, scrdesc,
	    cookie, ccol, crow, defattr);
	if (scr == NULL) {
		(*sc->sc_accessops->free_screen)(sc->sc_accesscookie, cookie);
		return (ENXIO);
	}

	sc->sc_scr[idx] = scr;

	/* if no screen has focus yet, activate the first we get */
	s = spltty();
	if (!sc->sc_focus) {
		(*sc->sc_accessops->show_screen)(sc->sc_accesscookie,
		    scr->scr_dconf->emulcookie, 0, 0, 0);
		sc->sc_focusidx = idx;
		sc->sc_focus = scr;
	}
	splx(s);

#ifdef WSMOUSED_SUPPORT
	allocate_copybuffer(sc); /* enlarge the copy buffer is necessary */
#endif
	return (0);
}

int
wsdisplay_getscreen(struct wsdisplay_softc *sc,
    struct wsdisplay_addscreendata *sd)
{
	struct wsscreen *scr;

	if (sd->idx < 0 && sc->sc_focus)
		sd->idx = sc->sc_focusidx;

	if (sd->idx < 0 || sd->idx >= WSDISPLAY_MAXSCREEN)
		return (EINVAL);

	scr = sc->sc_scr[sd->idx];
	if (scr == NULL)
		return (ENXIO);

	strncpy(sd->screentype, scr->scr_dconf->scrdata->name,
	    WSSCREEN_NAME_SIZE);
	strncpy(sd->emul, scr->scr_dconf->wsemul->name, WSEMUL_NAME_SIZE);

	return (0);
}

void
wsdisplay_closescreen(struct wsdisplay_softc *sc, struct wsscreen *scr)
{
	int maj, mn, idx;

	/* hangup */
	if (WSSCREEN_HAS_TTY(scr)) {
		struct tty *tp = scr->scr_tty;
		(*linesw[tp->t_line].l_modem)(tp, 0);
	}

	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == wsdisplayopen)
			break;
	/* locate the screen index */
	for (idx = 0; idx < WSDISPLAY_MAXSCREEN; idx++)
		if (scr == sc->sc_scr[idx])
			break;
#ifdef DIAGNOSTIC
	if (idx == WSDISPLAY_MAXSCREEN)
		panic("wsdisplay_forceclose: bad screen");
#endif

	/* nuke the vnodes */
	mn = WSDISPLAYMINOR(sc->sc_dv.dv_unit, idx);
	vdevgone(maj, mn, mn, VCHR);
}

int
wsdisplay_delscreen(struct wsdisplay_softc *sc, int idx, int flags)
{
	struct wsscreen *scr;
	int s;
	void *cookie;

	if (idx < 0 || idx >= WSDISPLAY_MAXSCREEN)
		return (EINVAL);
	if ((scr = sc->sc_scr[idx]) == NULL)
		return (ENXIO);

	if (scr->scr_dconf == &wsdisplay_console_conf ||
#ifdef WSDISPLAY_COMPAT_USL
	    scr->scr_syncops ||
#endif
	    ((scr->scr_flags & SCR_OPEN) && !(flags & WSDISPLAY_DELSCR_FORCE)))
		return (EBUSY);

	wsdisplay_closescreen(sc, scr);

	/*
	 * delete pointers, so neither device entries
	 * nor keyboard input can reference it anymore
	 */
	s = spltty();
	if (sc->sc_focus == scr) {
		sc->sc_focus = 0;
#ifdef WSDISPLAY_COMPAT_RAWKBD
		wsdisplay_update_rawkbd(sc, 0);
#endif
	}
	sc->sc_scr[idx] = 0;
	splx(s);

	/*
	 * Wake up processes waiting for the screen to
	 * be activated. Sleepers must check whether
	 * the screen still exists.
	 */
	if (scr->scr_flags & SCR_WAITACTIVE)
		wakeup(scr);

	/* save a reference to the graphics screen */
	cookie = scr->scr_dconf->emulcookie;

	wsscreen_detach(scr);

	(*sc->sc_accessops->free_screen)(sc->sc_accesscookie, cookie);

	if ((flags & WSDISPLAY_DELSCR_QUIET) == 0)
		printf("%s: screen %d deleted\n", sc->sc_dv.dv_xname, idx);
	return (0);
}

/*
 * Autoconfiguration functions.
 */
int
wsdisplay_emul_match(struct device *parent, void *match, void *aux)
{
	struct cfdata *cf = match;
	struct wsemuldisplaydev_attach_args *ap = aux;

	if (cf->wsemuldisplaydevcf_console != WSEMULDISPLAYDEVCF_CONSOLE_UNK) {
		/*
		 * If console-ness of device specified, either match
		 * exactly (at high priority), or fail.
		 */
		if (cf->wsemuldisplaydevcf_console != 0 && ap->console != 0)
			return (10);
		else
			return (0);
	}

	/* If console-ness unspecified, it wins. */
	return (1);
}

void
wsdisplay_emul_attach(struct device *parent, struct device *self, void *aux)
{
	struct wsdisplay_softc *sc = (struct wsdisplay_softc *)self;
	struct wsemuldisplaydev_attach_args *ap = aux;

	wsdisplay_common_attach(sc, ap->console,
	    sc->sc_dv.dv_cfdata->wsemuldisplaydevcf_mux, ap->scrdata,
	    ap->accessops, ap->accesscookie, ap->defaultscreens);

	if (ap->console && cn_tab == &wsdisplay_cons) {
		int maj;

		/* locate the major number */
		for (maj = 0; maj < nchrdev; maj++)
			if (cdevsw[maj].d_open == wsdisplayopen)
				break;

		cn_tab->cn_dev = makedev(maj, WSDISPLAYMINOR(self->dv_unit, 0));
	}
}

/*
 * Detach a display.
 */
int
wsdisplay_emul_detach(struct device *self, int flags)
{
	struct wsdisplay_softc *sc = (struct wsdisplay_softc *)self;

	return (wsdisplay_common_detach(sc, flags));
}

int
wsdisplay_common_detach(struct wsdisplay_softc *sc, int flags)
{
	int i;
	int rc;

	/* We don't support detaching the console display yet. */
	if (sc->sc_isconsole)
		return (EBUSY);

	/* Delete all screens managed by this display */
	for (i = 0; i < WSDISPLAY_MAXSCREEN; i++)
		if (sc->sc_scr[i] != NULL) {
			if ((rc = wsdisplay_delscreen(sc, i,
			    WSDISPLAY_DELSCR_QUIET | (flags & DETACH_FORCE ?
			     WSDISPLAY_DELSCR_FORCE : 0))) != 0)
				return (rc);
		}

#ifdef BURNER_SUPPORT
	timeout_del(&sc->sc_burner);
#endif

#if NWSKBD > 0
	if (sc->sc_input != NULL) {
#if NWSMUX > 0
		wsmux_detach_sc(sc->sc_input);	/* XXX not exactly correct */
		/*
		 * XXX
		 * If we created a standalone mux (dmux), we should destroy it
		 * there, but there is currently no support for this in wsmux.
		 */
#else
		if ((rc = wskbd_set_display((struct device *)sc->sc_input,
		    NULL)) != 0)
			return (rc);
#endif
	}
#endif

	return (0);
}

/* Print function (for parent devices). */
int
wsemuldisplaydevprint(void *aux, const char *pnp)
{
#if 0 /* -Wunused */
	struct wsemuldisplaydev_attach_args *ap = aux;
#endif

	if (pnp)
		printf("wsdisplay at %s", pnp);
#if 0 /* don't bother; it's ugly */
	printf(" console %d", ap->console);
#endif

	return (UNCONF);
}

void
wsdisplay_common_attach(struct wsdisplay_softc *sc, int console, int kbdmux,
    const struct wsscreen_list *scrdata,
    const struct wsdisplay_accessops *accessops, void *accesscookie,
    u_int defaultscreens)
{
	static int hookset = 0;
	int i, start = 0;
#if NWSKBD > 0
	struct wsevsrc *kme;
#if NWSMUX > 0
	struct wsmux_softc *mux;

	if (kbdmux >= 0)
		mux = wsmux_getmux(kbdmux);
	else
		mux = wsmux_create("dmux", sc->sc_dv.dv_unit);
	/* XXX panic()ing isn't nice, but attach cannot fail */
	if (mux == NULL)
		panic("wsdisplay_common_attach: no memory");
	sc->sc_input = &mux->sc_base;
	mux->sc_displaydv = &sc->sc_dv;
	if (kbdmux >= 0)
		printf(" mux %d", kbdmux);
#else
#if 0	/* not worth keeping, especially since the default value is not -1... */
	if (kbdmux >= 0)
		printf(" (mux ignored)");
#endif
#endif	/* NWSMUX > 0 */
#endif	/* NWSKBD > 0 */

	sc->sc_isconsole = console;

	if (console) {
		KASSERT(wsdisplay_console_initted);
		KASSERT(wsdisplay_console_device == NULL);

		sc->sc_scr[0] = wsscreen_attach(sc, 1, 0, 0, 0, 0, 0, 0);
		if (sc->sc_scr[0] == NULL)
			return;
		wsdisplay_console_device = sc;

		printf(": console (%s, %s emulation)",
		       wsdisplay_console_conf.scrdata->name,
		       wsdisplay_console_conf.wsemul->name);

#if NWSKBD > 0
		kme = wskbd_set_console_display(&sc->sc_dv, sc->sc_input);
		if (kme != NULL)
			printf(", using %s", kme->me_dv.dv_xname);
#if NWSMUX == 0
		sc->sc_input = kme;
#endif
#endif

		sc->sc_focusidx = 0;
		sc->sc_focus = sc->sc_scr[0];
		start = 1;
	}
	printf("\n");

#if NWSKBD > 0 && NWSMUX > 0
	wsmux_set_display(mux, &sc->sc_dv);
#endif

	sc->sc_accessops = accessops;
	sc->sc_accesscookie = accesscookie;
	sc->sc_scrdata = scrdata;

	/*
	 * Set up a number of virtual screens if wanted. The
	 * WSDISPLAYIO_ADDSCREEN ioctl is more flexible, so this code
	 * is for special cases like installation kernels, as well as
	 * sane multihead defaults.
	 */
	if (defaultscreens == 0)
		defaultscreens = wsdisplay_defaultscreens;
	for (i = start; i < defaultscreens; i++) {
		if (wsdisplay_addscreen(sc, i, 0, 0))
			break;
	}

	if (i > start)
		wsdisplay_addscreen_print(sc, start, i-start);

#ifdef BURNER_SUPPORT
	sc->sc_burnoutintvl = (hz * WSDISPLAY_DEFBURNOUT) / 1000;
	sc->sc_burninintvl = (hz * WSDISPLAY_DEFBURNIN ) / 1000;
	sc->sc_burnflags = 0;	/* off by default */
	timeout_set(&sc->sc_burner, wsdisplay_burner, sc);
	sc->sc_burnout = sc->sc_burnoutintvl;
	wsdisplay_burn(sc, sc->sc_burnflags);
#endif

	if (hookset == 0)
		shutdownhook_establish(wsdisplay_shutdownhook, NULL);
	hookset = 1;

#if NWSKBD > 0 && NWSMUX == 0
	if (console == 0) {
		/*
		 * In the non-wsmux world, always connect wskbd0 and wsdisplay0
		 * together.
		 */
		extern struct cfdriver wskbd_cd;

		if (wskbd_cd.cd_ndevs != 0 && sc->sc_dv.dv_unit == 0) {
			if (wsdisplay_set_kbd(&sc->sc_dv,
			    (struct wsevsrc *)wskbd_cd.cd_devs[0]) == 0)
				wskbd_set_display(wskbd_cd.cd_devs[0],
				    &sc->sc_dv);
		}
	}
#endif
}

void
wsdisplay_cnattach(const struct wsscreen_descr *type, void *cookie, int ccol,
    int crow, long defattr)
{
	const struct wsemul_ops *wsemul;

	KASSERT(!wsdisplay_console_initted);
	KASSERT(type->nrows > 0);
	KASSERT(type->ncols > 0);
	KASSERT(crow < type->nrows);
	KASSERT(ccol < type->ncols);

	wsdisplay_console_conf.emulops = type->textops;
	wsdisplay_console_conf.emulcookie = cookie;
	wsdisplay_console_conf.scrdata = type;

	wsemul = wsemul_pick(""); /* default */
	wsdisplay_console_conf.wsemul = wsemul;
	wsdisplay_console_conf.wsemulcookie =
	    (*wsemul->cnattach)(type, cookie, ccol, crow, defattr);

	cn_tab = &wsdisplay_cons;

	wsdisplay_console_initted = 1;
}

/*
 * Tty and cdevsw functions.
 */
int
wsdisplayopen(dev_t dev, int flag, int mode, struct proc *p)
{
	struct wsdisplay_softc *sc;
	struct tty *tp;
	int unit, newopen, error;
	struct wsscreen *scr;

	unit = WSDISPLAYUNIT(dev);
	if (unit >= wsdisplay_cd.cd_ndevs ||	/* make sure it was attached */
	    (sc = wsdisplay_cd.cd_devs[unit]) == NULL)
		return (ENXIO);

	if (ISWSDISPLAYCTL(dev))
		return (0);

	if (WSDISPLAYSCREEN(dev) >= WSDISPLAY_MAXSCREEN)
		return (ENXIO);
	if ((scr = sc->sc_scr[WSDISPLAYSCREEN(dev)]) == NULL)
		return (ENXIO);

	if (WSSCREEN_HAS_TTY(scr)) {
		tp = scr->scr_tty;
		tp->t_oproc = wsdisplaystart;
		tp->t_param = wsdisplayparam;
		tp->t_dev = dev;
		newopen = (tp->t_state & TS_ISOPEN) == 0;
		if (newopen) {
			ttychars(tp);
			tp->t_iflag = TTYDEF_IFLAG;
			tp->t_oflag = TTYDEF_OFLAG;
			tp->t_cflag = TTYDEF_CFLAG;
			tp->t_lflag = TTYDEF_LFLAG;
			tp->t_ispeed = tp->t_ospeed = TTYDEF_SPEED;
			wsdisplayparam(tp, &tp->t_termios);
			ttsetwater(tp);
		} else if ((tp->t_state & TS_XCLUDE) != 0 &&
			   p->p_ucred->cr_uid != 0)
			return (EBUSY);
		tp->t_state |= TS_CARR_ON;

		error = ((*linesw[tp->t_line].l_open)(dev, tp));
		if (error)
			return (error);

		if (newopen) {
			/* set window sizes as appropriate, and reset
			   the emulation */
			tp->t_winsize.ws_row = scr->scr_dconf->scrdata->nrows;
			tp->t_winsize.ws_col = scr->scr_dconf->scrdata->ncols;
		}
	}

	scr->scr_flags |= SCR_OPEN;
	return (0);
}

int
wsdisplayclose(dev_t dev, int flag, int mode, struct proc *p)
{
	struct wsdisplay_softc *sc;
	struct tty *tp;
	int unit;
	struct wsscreen *scr;

	unit = WSDISPLAYUNIT(dev);
	sc = wsdisplay_cd.cd_devs[unit];

	if (ISWSDISPLAYCTL(dev))
		return (0);

	if ((scr = sc->sc_scr[WSDISPLAYSCREEN(dev)]) == NULL)
		return (ENXIO);

	if (WSSCREEN_HAS_TTY(scr)) {
		if (scr->scr_hold_screen) {
			int s;

			/* XXX RESET KEYBOARD LEDS, etc. */
			s = spltty();	/* avoid conflict with keyboard */
			wsdisplay_kbdholdscreen((struct device *)sc, 0);
			splx(s);
		}
		tp = scr->scr_tty;
		(*linesw[tp->t_line].l_close)(tp, flag);
		ttyclose(tp);
	}

#ifdef WSDISPLAY_COMPAT_USL
	if (scr->scr_syncops)
		(*scr->scr_syncops->destroy)(scr->scr_synccookie);
#endif

	scr->scr_flags &= ~SCR_GRAPHICS;
	(*scr->scr_dconf->wsemul->reset)(scr->scr_dconf->wsemulcookie,
					 WSEMUL_RESET);
	if (wsdisplay_clearonclose)
		(*scr->scr_dconf->wsemul->reset)
			(scr->scr_dconf->wsemulcookie, WSEMUL_CLEARSCREEN);

#ifdef WSDISPLAY_COMPAT_RAWKBD
	if (scr->scr_rawkbd) {
		int kbmode = WSKBD_TRANSLATED;
		(void) wsdisplay_internal_ioctl(sc, scr, WSKBDIO_SETMODE,
		    (caddr_t)&kbmode, FWRITE, p);
	}
#endif

	scr->scr_flags &= ~SCR_OPEN;

#ifdef WSMOUSED_SUPPORT
	/* remove the selection at logout */
	if (Copybuffer)
		bzero(Copybuffer, Copybuffer_size);
	Paste_avail = 0;
#endif

	return (0);
}

int
wsdisplayread(dev_t dev, struct uio *uio, int flag)
{
	struct wsdisplay_softc *sc;
	struct tty *tp;
	int unit;
	struct wsscreen *scr;

	unit = WSDISPLAYUNIT(dev);
	sc = wsdisplay_cd.cd_devs[unit];

	if (ISWSDISPLAYCTL(dev))
		return (0);

	if ((scr = sc->sc_scr[WSDISPLAYSCREEN(dev)]) == NULL)
		return (ENXIO);

	if (!WSSCREEN_HAS_TTY(scr))
		return (ENODEV);

	tp = scr->scr_tty;
	return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
}

int
wsdisplaywrite(dev_t dev, struct uio *uio, int flag)
{
	struct wsdisplay_softc *sc;
	struct tty *tp;
	int unit;
	struct wsscreen *scr;

	unit = WSDISPLAYUNIT(dev);
	sc = wsdisplay_cd.cd_devs[unit];

	if (ISWSDISPLAYCTL(dev))
		return (0);

	if ((scr = sc->sc_scr[WSDISPLAYSCREEN(dev)]) == NULL)
		return (ENXIO);

	if (!WSSCREEN_HAS_TTY(scr))
		return (ENODEV);

	tp = scr->scr_tty;
	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
}

struct tty *
wsdisplaytty(dev_t dev)
{
	struct wsdisplay_softc *sc;
	int unit;
	struct wsscreen *scr;

	unit = WSDISPLAYUNIT(dev);
	sc = wsdisplay_cd.cd_devs[unit];

	if (ISWSDISPLAYCTL(dev))
		panic("wsdisplaytty() on ctl device");

	if ((scr = sc->sc_scr[WSDISPLAYSCREEN(dev)]) == NULL)
		return (NULL);

	return (scr->scr_tty);
}

int
wsdisplayioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct wsdisplay_softc *sc;
	struct tty *tp;
	int unit, error;
	struct wsscreen *scr;

	unit = WSDISPLAYUNIT(dev);
	sc = wsdisplay_cd.cd_devs[unit];

#ifdef WSDISPLAY_COMPAT_USL
	error = wsdisplay_usl_ioctl1(sc, cmd, data, flag, p);
	if (error >= 0)
		return (error);
#endif

	if (ISWSDISPLAYCTL(dev))
		return (wsdisplay_cfg_ioctl(sc, cmd, data, flag, p));

	if (WSDISPLAYSCREEN(dev) >= WSDISPLAY_MAXSCREEN)
		return (ENODEV);

	if ((scr = sc->sc_scr[WSDISPLAYSCREEN(dev)]) == NULL)
		return (ENXIO);

	if (WSSCREEN_HAS_TTY(scr)) {
		tp = scr->scr_tty;

/* printf("disc\n"); */
		/* do the line discipline ioctls first */
		error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
		if (error >= 0)
			return (error);

/* printf("tty\n"); */
		/* then the tty ioctls */
		error = ttioctl(tp, cmd, data, flag, p);
		if (error >= 0)
			return (error);
	}

#ifdef WSDISPLAY_COMPAT_USL
	error = wsdisplay_usl_ioctl2(sc, scr, cmd, data, flag, p);
	if (error >= 0)
		return (error);
#endif

	error = wsdisplay_internal_ioctl(sc, scr, cmd, data, flag, p);
	return (error != -1 ? error : ENOTTY);
}

int
wsdisplay_param(struct device *dev, u_long cmd, struct wsdisplay_param *dp)
{
	struct wsdisplay_softc *sc = (struct wsdisplay_softc *)dev;

	return ((*sc->sc_accessops->ioctl)(sc->sc_accesscookie, cmd,
	    (caddr_t)dp, 0, NULL));
}

int
wsdisplay_internal_ioctl(struct wsdisplay_softc *sc, struct wsscreen *scr,
    u_long cmd, caddr_t data, int flag, struct proc *p)
{
	int error;

#if NWSKBD > 0
	struct wsevsrc *inp;

#ifdef WSDISPLAY_COMPAT_RAWKBD
	switch (cmd) {
	case WSKBDIO_SETMODE:
		if ((flag & FWRITE) == 0)
			return (EACCES);
		scr->scr_rawkbd = (*(int *)data == WSKBD_RAW);
		return (wsdisplay_update_rawkbd(sc, scr));
	case WSKBDIO_GETMODE:
		*(int *)data = (scr->scr_rawkbd ?
				WSKBD_RAW : WSKBD_TRANSLATED);
		return (0);
	}
#endif
	inp = sc->sc_input;
	if (inp != NULL) {
		error = wsevsrc_display_ioctl(inp, cmd, data, flag, p);
		if (error >= 0)
			return (error);
	}
#endif /* NWSKBD > 0 */

	switch (cmd) {
	case WSDISPLAYIO_SMODE:
	case WSDISPLAYIO_USEFONT:
#ifdef BURNER_SUPPORT
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_SBURNER:
#endif
	case WSDISPLAYIO_SETSCREEN:
		if ((flag & FWRITE) == 0)
			return (EACCES);
	}

	switch (cmd) {
	case WSDISPLAYIO_GMODE:
		if (scr->scr_flags & SCR_GRAPHICS) {
			if (scr->scr_flags & SCR_DUMBFB)
				*(u_int *)data = WSDISPLAYIO_MODE_DUMBFB;
			else
				*(u_int *)data = WSDISPLAYIO_MODE_MAPPED;
		} else
			*(u_int *)data = WSDISPLAYIO_MODE_EMUL;
		return (0);

	case WSDISPLAYIO_SMODE:
#define d (*(int *)data)
		if (d != WSDISPLAYIO_MODE_EMUL &&
		    d != WSDISPLAYIO_MODE_MAPPED &&
		    d != WSDISPLAYIO_MODE_DUMBFB)
			return (EINVAL);

		scr->scr_flags &= ~SCR_GRAPHICS;
		if (d == WSDISPLAYIO_MODE_MAPPED ||
		    d == WSDISPLAYIO_MODE_DUMBFB) {
			scr->scr_flags |= SCR_GRAPHICS |
			    ((d == WSDISPLAYIO_MODE_DUMBFB) ?  SCR_DUMBFB : 0);

#ifdef WSMOUSED_SUPPORT
			/*
			 * wsmoused cohabitation with X-Window support
			 * X-Window is starting
			 */
			wsmoused_release(sc);
#endif

#ifdef BURNER_SUPPORT
			/* disable the burner while X is running */
			if (sc->sc_burnout)
				timeout_del(&sc->sc_burner);
#endif
		} else {
#ifdef BURNER_SUPPORT
			/* reenable the burner after exiting from X */
			if (!sc->sc_burnman)
				wsdisplay_burn(sc, sc->sc_burnflags);
#endif

#ifdef WSMOUSED_SUPPORT
			/*
			 * wsmoused cohabitation with X-Window support
			 * X-Window is ending
			 */
			wsmoused_wakeup(sc);
#endif
		}

		(void)(*sc->sc_accessops->ioctl)(sc->sc_accesscookie, cmd, data,
		    flag, p);

		return (0);
#undef d

	case WSDISPLAYIO_USEFONT:
#define d ((struct wsdisplay_font *)data)
		if (!sc->sc_accessops->load_font)
			return (EINVAL);
		d->data = 0;
		error = (*sc->sc_accessops->load_font)(sc->sc_accesscookie,
		    scr->scr_dconf->emulcookie, d);
		if (!error)
			(*scr->scr_dconf->wsemul->reset)
			    (scr->scr_dconf->wsemulcookie, WSEMUL_SYNCFONT);
		return (error);
#undef d
#ifdef BURNER_SUPPORT
	case WSDISPLAYIO_GVIDEO:
		*(u_int *)data = !sc->sc_burnman;
		break;

	case WSDISPLAYIO_SVIDEO:
		if (*(u_int *)data != WSDISPLAYIO_VIDEO_OFF &&
		    *(u_int *)data != WSDISPLAYIO_VIDEO_ON)
			return (EINVAL);
		if (sc->sc_accessops->burn_screen == NULL)
			return (EOPNOTSUPP);
		(*sc->sc_accessops->burn_screen)(sc->sc_accesscookie,
		     *(u_int *)data, sc->sc_burnflags);
		break;

	case WSDISPLAYIO_GBURNER:
#define d ((struct wsdisplay_burner *)data)
		d->on  = sc->sc_burninintvl  * 1000 / hz;
		d->off = sc->sc_burnoutintvl * 1000 / hz;
		d->flags = sc->sc_burnflags;
		return (0);

	case WSDISPLAYIO_SBURNER:
		if (d->flags & ~(WSDISPLAY_BURN_VBLANK | WSDISPLAY_BURN_KBD |
		    WSDISPLAY_BURN_MOUSE | WSDISPLAY_BURN_OUTPUT))
			error = EINVAL;
		else {
			error = 0;
			sc->sc_burnflags = d->flags;
			/* disable timeout if necessary */
			if ((sc->sc_burnflags & (WSDISPLAY_BURN_OUTPUT |
			    WSDISPLAY_BURN_KBD | WSDISPLAY_BURN_MOUSE)) == 0) {
				if (sc->sc_burnout)
					timeout_del(&sc->sc_burner);
			}
		}
		if (d->on) {
			error = 0;
			sc->sc_burninintvl = hz * d->on / 1000;
			if (sc->sc_burnman)
				sc->sc_burnout = sc->sc_burninintvl;
		}
		if (d->off) {
			error = 0;
			sc->sc_burnoutintvl = hz * d->off / 1000;
			if (!sc->sc_burnman) {
				sc->sc_burnout = sc->sc_burnoutintvl;
				/* reinit timeout if changed */
				if ((scr->scr_flags & SCR_GRAPHICS) == 0)
					wsdisplay_burn(sc, sc->sc_burnflags);
			}
		}
		return (error);
#undef d
#endif	/* BURNER_SUPPORT */
	case WSDISPLAYIO_GETSCREEN:
		return (wsdisplay_getscreen(sc,
		    (struct wsdisplay_addscreendata *)data));

	case WSDISPLAYIO_SETSCREEN:
		return (wsdisplay_switch((void *)sc, *(int *)data, 1));
	}

	/* check ioctls for display */
	return ((*sc->sc_accessops->ioctl)(sc->sc_accesscookie, cmd, data,
	    flag, p));
}

int
wsdisplay_cfg_ioctl(struct wsdisplay_softc *sc, u_long cmd, caddr_t data,
    int flag, struct proc *p)
{
	int error;
	void *buf;
	size_t fontsz;
#if NWSKBD > 0
	struct wsevsrc *inp;
#endif

	switch (cmd) {
#ifdef WSMOUSED_SUPPORT
	case WSDISPLAYIO_WSMOUSED:
		error = wsmoused(sc, cmd, data, flag, p);
		return (error);
#endif
	case WSDISPLAYIO_ADDSCREEN:
#define d ((struct wsdisplay_addscreendata *)data)
		if ((error = wsdisplay_addscreen(sc, d->idx,
		    d->screentype, d->emul)) == 0)
			wsdisplay_addscreen_print(sc, d->idx, 0);
		return (error);
#undef d
	case WSDISPLAYIO_DELSCREEN:
#define d ((struct wsdisplay_delscreendata *)data)
		return (wsdisplay_delscreen(sc, d->idx, d->flags));
#undef d
	case WSDISPLAYIO_GETSCREEN:
		return (wsdisplay_getscreen(sc,
		    (struct wsdisplay_addscreendata *)data));
	case WSDISPLAYIO_SETSCREEN:
		return (wsdisplay_switch((void *)sc, *(int *)data, 1));
	case WSDISPLAYIO_LDFONT:
#define d ((struct wsdisplay_font *)data)
		if (!sc->sc_accessops->load_font)
			return (EINVAL);
		if (d->index >= WSDISPLAY_MAXFONT)
			return (EINVAL);
		fontsz = d->fontheight * d->stride * d->numchars;
		if (fontsz > WSDISPLAY_MAXFONTSZ)
			return (EINVAL);

		buf = malloc(fontsz, M_DEVBUF, M_WAITOK);
		error = copyin(d->data, buf, fontsz);
		if (error) {
			free(buf, M_DEVBUF);
			return (error);
		}
		d->data = buf;
		error =
		  (*sc->sc_accessops->load_font)(sc->sc_accesscookie, 0, d);
		if (error)
			free(buf, M_DEVBUF);
		else if (d->index >= 0 || d->index < WSDISPLAY_MAXFONT)
			sc->sc_fonts[d->index] = *d;
		return (error);

	case WSDISPLAYIO_LSFONT:
		if (d->index < 0 || d->index >= WSDISPLAY_MAXFONT)
			return (EINVAL);
		*d = sc->sc_fonts[d->index];
		return (0);

	case WSDISPLAYIO_DELFONT:
		if (!sc->sc_accessops->delete_font)
			return (EINVAL);
		if (d->index <= 0 || d->index >= WSDISPLAY_MAXFONT)
			return (EINVAL);

		error =
		  (*sc->sc_accessops->delete_font)(sc->sc_accesscookie, 0, d->index);
		if (error)
			return (error);

		free(sc->sc_fonts[d->index].data, M_DEVBUF);
		sc->sc_fonts[d->index].data = NULL;
		sc->sc_fonts[d->index].name[0] = '\0';
		return 0;
#undef d

#if NWSKBD > 0
	case WSMUXIO_ADD_DEVICE:
#define d ((struct wsmux_device *)data)
		if (d->idx == -1 && d->type == WSMUX_KBD)
			d->idx = wskbd_pickfree();
#undef d
		/* fall into */
	case WSMUXIO_INJECTEVENT:
	case WSMUXIO_REMOVE_DEVICE:
	case WSMUXIO_LIST_DEVICES:
		inp = sc->sc_input;
		if (inp == NULL)
			return (ENXIO);
		return (wsevsrc_ioctl(inp, cmd, data, flag,p));
#endif /* NWSKBD > 0 */

	}
	return (EINVAL);
}

paddr_t
wsdisplaymmap(dev_t dev, off_t offset, int prot)
{
	struct wsdisplay_softc *sc = wsdisplay_cd.cd_devs[WSDISPLAYUNIT(dev)];
	struct wsscreen *scr;

	if (ISWSDISPLAYCTL(dev))
		return (-1);

	if ((scr = sc->sc_scr[WSDISPLAYSCREEN(dev)]) == NULL)
		return (-1);

	if (!(scr->scr_flags & SCR_GRAPHICS))
		return (-1);

	/* pass mmap to display */
	return ((*sc->sc_accessops->mmap)(sc->sc_accesscookie, offset, prot));
}

int
wsdisplaypoll(dev_t dev, int events, struct proc *p)
{
	struct wsdisplay_softc *sc = wsdisplay_cd.cd_devs[WSDISPLAYUNIT(dev)];
	struct wsscreen *scr;

	if (ISWSDISPLAYCTL(dev))
		return (0);

	if ((scr = sc->sc_scr[WSDISPLAYSCREEN(dev)]) == NULL)
		return (POLLERR);

	if (!WSSCREEN_HAS_TTY(scr))
		return (POLLERR);

	return (ttpoll(dev, events, p));
}

int
wsdisplaykqfilter(dev_t dev, struct knote *kn)
{
	struct wsdisplay_softc *sc = wsdisplay_cd.cd_devs[WSDISPLAYUNIT(dev)];
	struct wsscreen *scr;

	if (ISWSDISPLAYCTL(dev))
		return (1);

	if ((scr = sc->sc_scr[WSDISPLAYSCREEN(dev)]) == NULL)
		return (1);

	if (WSSCREEN_HAS_TTY(scr))
		return (ttkqfilter(dev, kn));
	else
		return (1);
}

void
wsdisplaystart(struct tty *tp)
{
	struct wsdisplay_softc *sc;
	struct wsscreen *scr;
	int s, n, unit;
	u_char *buf;

	unit = WSDISPLAYUNIT(tp->t_dev);
	if (unit >= wsdisplay_cd.cd_ndevs ||
	    (sc = wsdisplay_cd.cd_devs[unit]) == NULL)
		return;

	s = spltty();
	if (tp->t_state & (TS_TIMEOUT | TS_BUSY | TS_TTSTOP)) {
		splx(s);
		return;
	}
	if (tp->t_outq.c_cc == 0 && tp->t_wsel.si_selpid == 0)
		goto low;

	if ((scr = sc->sc_scr[WSDISPLAYSCREEN(tp->t_dev)]) == NULL) {
		splx(s);
		return;
	}
	if (scr->scr_hold_screen) {
		tp->t_state |= TS_TIMEOUT;
		splx(s);
		return;
	}
	tp->t_state |= TS_BUSY;
	splx(s);

	/*
	 * Drain output from ring buffer.
	 * The output will normally be in one contiguous chunk, but when the
	 * ring wraps, it will be in two pieces.. one at the end of the ring,
	 * the other at the start.  For performance, rather than loop here,
	 * we output one chunk, see if there's another one, and if so, output
	 * it too.
	 */

	n = ndqb(&tp->t_outq, 0);
	buf = tp->t_outq.c_cf;

	if (!(scr->scr_flags & SCR_GRAPHICS)) {
#ifdef BURNER_SUPPORT
		wsdisplay_burn(sc, WSDISPLAY_BURN_OUTPUT);
#endif
#ifdef WSMOUSED_SUPPORT
		if (scr == sc->sc_focus) {
			if (IS_SEL_EXISTS(sc->sc_focus))
				/* hide a potential selection */
				remove_selection(sc);
			/* hide a potential mouse cursor */
			mouse_hide(sc);
		}
#endif
		(*scr->scr_dconf->wsemul->output)(scr->scr_dconf->wsemulcookie,
		    buf, n, 0);
	}
	ndflush(&tp->t_outq, n);

	if ((n = ndqb(&tp->t_outq, 0)) > 0) {
		buf = tp->t_outq.c_cf;

		if (!(scr->scr_flags & SCR_GRAPHICS)) {
#ifdef BURNER_SUPPORT
			wsdisplay_burn(sc, WSDISPLAY_BURN_OUTPUT);
#endif
			(*scr->scr_dconf->wsemul->output)
			    (scr->scr_dconf->wsemulcookie, buf, n, 0);
		}
		ndflush(&tp->t_outq, n);
	}

	s = spltty();
	tp->t_state &= ~TS_BUSY;
	/* Come back if there's more to do */
	if (tp->t_outq.c_cc) {
		tp->t_state |= TS_TIMEOUT;
		timeout_add(&tp->t_rstrt_to, (hz > 128) ? (hz / 128) : 1);
	}
	if (tp->t_outq.c_cc <= tp->t_lowat) {
low:
		if (tp->t_state & TS_ASLEEP) {
			tp->t_state &= ~TS_ASLEEP;
			wakeup((caddr_t)&tp->t_outq);
		}
		selwakeup(&tp->t_wsel);
	}
	splx(s);
}

int
wsdisplaystop(struct tty *tp, int flag)
{
	int s;

	s = spltty();
	if (ISSET(tp->t_state, TS_BUSY))
		if (!ISSET(tp->t_state, TS_TTSTOP))
			SET(tp->t_state, TS_FLUSH);
	splx(s);

	return (0);
}

/* Set line parameters. */
int
wsdisplayparam(struct tty *tp, struct termios *t)
{

	tp->t_ispeed = t->c_ispeed;
	tp->t_ospeed = t->c_ospeed;
	tp->t_cflag = t->c_cflag;
	return (0);
}

/*
 * Callbacks for the emulation code.
 */
void
wsdisplay_emulbell(void *v)
{
	struct wsscreen *scr = v;

	if (scr == NULL)		/* console, before real attach */
		return;

	if (scr->scr_flags & SCR_GRAPHICS) /* can this happen? */
		return;

	(void) wsdisplay_internal_ioctl(scr->sc, scr, WSKBDIO_BELL, NULL,
	    FWRITE, NULL);
}

void
wsdisplay_emulinput(void *v, const u_char *data, u_int count)
{
	struct wsscreen *scr = v;
	struct tty *tp;

	if (v == NULL)			/* console, before real attach */
		return;

	if (scr->scr_flags & SCR_GRAPHICS) /* XXX can't happen */
		return;
	if (!WSSCREEN_HAS_TTY(scr))
		return;

	tp = scr->scr_tty;
	while (count-- > 0)
		(*linesw[tp->t_line].l_rint)(*data++, tp);
}

/*
 * Calls from the keyboard interface.
 */
void
wsdisplay_kbdinput(struct device *dev, keysym_t ks)
{
	struct wsdisplay_softc *sc = (struct wsdisplay_softc *)dev;
	struct wsscreen *scr;
	char *dp;
	int count;
	struct tty *tp;

	KASSERT(sc != NULL);

	scr = sc->sc_focus;

	if (!scr || !WSSCREEN_HAS_TTY(scr))
		return;

	tp = scr->scr_tty;

	if (KS_GROUP(ks) == KS_GROUP_Ascii)
		(*linesw[tp->t_line].l_rint)(KS_VALUE(ks), tp);
	else {
		count = (*scr->scr_dconf->wsemul->translate)
		    (scr->scr_dconf->wsemulcookie, ks, &dp);
		while (count-- > 0)
			(*linesw[tp->t_line].l_rint)(*dp++, tp);
	}
}

#ifdef WSDISPLAY_COMPAT_RAWKBD
int
wsdisplay_update_rawkbd(struct wsdisplay_softc *sc, struct wsscreen *scr)
{
#if NWSKBD > 0
	int s, raw, data, error;
	struct wsevsrc *inp;

	s = spltty();

	raw = (scr ? scr->scr_rawkbd : 0);

	if (scr != sc->sc_focus || sc->sc_rawkbd == raw) {
		splx(s);
		return (0);
	}

	data = raw ? WSKBD_RAW : WSKBD_TRANSLATED;
	inp = sc->sc_input;
	if (inp == NULL) {
		splx(s);
		return (ENXIO);
	}
	error = wsevsrc_display_ioctl(inp, WSKBDIO_SETMODE, &data, FWRITE, 0);
	if (!error)
		sc->sc_rawkbd = raw;
	splx(s);
	return (error);
#else
	return (0);
#endif
}
#endif

int
wsdisplay_switch3(void *arg, int error, int waitok)
{
	struct wsdisplay_softc *sc = arg;
	int no;
	struct wsscreen *scr;

#ifdef WSDISPLAY_COMPAT_USL
	if (!(sc->sc_flags & SC_SWITCHPENDING)) {
		printf("wsdisplay_switch3: not switching\n");
		return (EINVAL);
	}

	no = sc->sc_screenwanted;
	if (no < 0 || no >= WSDISPLAY_MAXSCREEN)
		panic("wsdisplay_switch3: invalid screen %d", no);
	scr = sc->sc_scr[no];
	if (!scr) {
		printf("wsdisplay_switch3: screen %d disappeared\n", no);
		error = ENXIO;
	}

	if (error) {
		/* try to recover, avoid recursion */

		if (sc->sc_oldscreen == WSDISPLAY_NULLSCREEN) {
			printf("wsdisplay_switch3: giving up\n");
			sc->sc_focus = 0;
#ifdef WSDISPLAY_COMPAT_RAWKBD
			wsdisplay_update_rawkbd(sc, 0);
#endif
			sc->sc_flags &= ~SC_SWITCHPENDING;
			return (error);
		}

		sc->sc_screenwanted = sc->sc_oldscreen;
		sc->sc_oldscreen = WSDISPLAY_NULLSCREEN;
		return (wsdisplay_switch1(arg, 0, waitok));
	}
#else
	/*
	 * If we do not have syncops support, we come straight from
	 * wsdisplay_switch2 which has already validated our arguments
	 * and did not sleep.
	 */
	no = sc->sc_screenwanted;
	scr = sc->sc_scr[no];
#endif

	sc->sc_flags &= ~SC_SWITCHPENDING;

	if (!error && (scr->scr_flags & SCR_WAITACTIVE))
		wakeup(scr);
	return (error);
}

int
wsdisplay_switch2(void *arg, int error, int waitok)
{
	struct wsdisplay_softc *sc = arg;
	int no;
	struct wsscreen *scr;

	if (!(sc->sc_flags & SC_SWITCHPENDING)) {
		printf("wsdisplay_switch2: not switching\n");
		return (EINVAL);
	}

	no = sc->sc_screenwanted;
	if (no < 0 || no >= WSDISPLAY_MAXSCREEN)
		panic("wsdisplay_switch2: invalid screen %d", no);
	scr = sc->sc_scr[no];
	if (!scr) {
		printf("wsdisplay_switch2: screen %d disappeared\n", no);
		error = ENXIO;
	}

	if (error) {
		/* try to recover, avoid recursion */

		if (sc->sc_oldscreen == WSDISPLAY_NULLSCREEN) {
			printf("wsdisplay_switch2: giving up\n");
			sc->sc_focus = 0;
			sc->sc_flags &= ~SC_SWITCHPENDING;
			return (error);
		}

		sc->sc_screenwanted = sc->sc_oldscreen;
		sc->sc_oldscreen = WSDISPLAY_NULLSCREEN;
		return (wsdisplay_switch1(arg, 0, waitok));
	}

	sc->sc_focusidx = no;
	sc->sc_focus = scr;

#ifdef WSDISPLAY_COMPAT_RAWKBD
	(void) wsdisplay_update_rawkbd(sc, scr);
#endif
	/* keyboard map??? */

#ifdef WSDISPLAY_COMPAT_USL
#define wsswitch_cb3 ((void (*)(void *, int, int))wsdisplay_switch3)
	if (scr->scr_syncops) {
		error = (*scr->scr_syncops->attach)(scr->scr_synccookie, waitok,
		    sc->sc_isconsole && wsdisplay_cons_pollmode ?
		      0 : wsswitch_cb3, sc);
		if (error == EAGAIN) {
			/* switch will be done asynchronously */
			return (0);
		}
	}
#endif

	return (wsdisplay_switch3(sc, error, waitok));
}

int
wsdisplay_switch1(void *arg, int error, int waitok)
{
	struct wsdisplay_softc *sc = arg;
	int no;
	struct wsscreen *scr;

	if (!(sc->sc_flags & SC_SWITCHPENDING)) {
		printf("wsdisplay_switch1: not switching\n");
		return (EINVAL);
	}

	no = sc->sc_screenwanted;
	if (no == WSDISPLAY_NULLSCREEN) {
		sc->sc_flags &= ~SC_SWITCHPENDING;
		if (!error) {
			sc->sc_focus = 0;
		}
		wakeup(sc);
		return (error);
	}
	if (no < 0 || no >= WSDISPLAY_MAXSCREEN)
		panic("wsdisplay_switch1: invalid screen %d", no);
	scr = sc->sc_scr[no];
	if (!scr) {
		printf("wsdisplay_switch1: screen %d disappeared\n", no);
		error = ENXIO;
	}

	if (error) {
		sc->sc_flags &= ~SC_SWITCHPENDING;
		return (error);
	}

#define wsswitch_cb2 ((void (*)(void *, int, int))wsdisplay_switch2)
	error = (*sc->sc_accessops->show_screen)(sc->sc_accesscookie,
	    scr->scr_dconf->emulcookie, waitok,
	    sc->sc_isconsole && wsdisplay_cons_pollmode ? 0 : wsswitch_cb2, sc);
	if (error == EAGAIN) {
		/* switch will be done asynchronously */
		return (0);
	}

	return (wsdisplay_switch2(sc, error, waitok));
}

int
wsdisplay_switch(struct device *dev, int no, int waitok)
{
	struct wsdisplay_softc *sc = (struct wsdisplay_softc *)dev;
	int s, res = 0;
	struct wsscreen *scr;

	if (no != WSDISPLAY_NULLSCREEN) {
		if (no < 0 || no >= WSDISPLAY_MAXSCREEN)
			return (EINVAL);
		if (sc->sc_scr[no] == NULL)
			return (ENXIO);
	}

	s = spltty();

	if ((sc->sc_focus && no == sc->sc_focusidx) ||
	    (sc->sc_focus == NULL && no == WSDISPLAY_NULLSCREEN)) {
		splx(s);
		return (0);
	}

	if (sc->sc_flags & SC_SWITCHPENDING) {
		splx(s);
		return (EBUSY);
	}

	sc->sc_flags |= SC_SWITCHPENDING;
	sc->sc_screenwanted = no;

	splx(s);

	scr = sc->sc_focus;
	if (!scr) {
		sc->sc_oldscreen = WSDISPLAY_NULLSCREEN;
		return (wsdisplay_switch1(sc, 0, waitok));
	} else
		sc->sc_oldscreen = sc->sc_focusidx;


#ifdef WSMOUSED_SUPPORT
	/*
	 *  wsmoused cohabitation with X-Window support
	 *
	 *  Detect switch from a graphic to text console and vice-versa
	 *  This only happen when switching from X-Window to text mode and
	 *  switching back from text mode to X-Window.
	 *
	 *  scr_flags is not yet flagged with SCR_GRAPHICS when X-Window starts
	 *  (KD_GRAPHICS ioctl happens after VT_ACTIVATE ioctl in
	 *  xf86OpenPcvt()). Conversely, scr_flags is no longer flagged with
	 *  SCR_GRAPHICS when X-Window stops. In this case, the first of the
	 *  three following 'if' statements is evaluated.
	 *  We handle wsmoused(8) events the WSDISPLAYIO_SMODE ioctl.
	 */

	if (!(scr->scr_flags & SCR_GRAPHICS) &&
	    (!(sc->sc_scr[no]->scr_flags & SCR_GRAPHICS))) {
		/* switching from a text console to another text console */
		/* XXX evaluated when the X-server starts or stops, see above */

		/* remove a potential wsmoused(8) selection */
		mouse_remove(sc);
	}

	if (!(scr->scr_flags & SCR_GRAPHICS) &&
	    (sc->sc_scr[no]->scr_flags & SCR_GRAPHICS)) {
		/* switching from a text console to a graphic console */

		/* remote a potential wsmoused(8) selection */
		mouse_remove(sc);
		wsmoused_release(sc);
	}

	if ((scr->scr_flags & SCR_GRAPHICS) &&
	    !(sc->sc_scr[no]->scr_flags & SCR_GRAPHICS)) {
		/* switching from a graphic console to a text console */

		wsmoused_wakeup(sc);
	}
#endif	/* WSMOUSED_SUPPORT */

#ifdef WSDISPLAY_COMPAT_USL
#define wsswitch_cb1 ((void (*)(void *, int, int))wsdisplay_switch1)
	if (scr->scr_syncops) {
		res = (*scr->scr_syncops->detach)(scr->scr_synccookie, waitok,
		    sc->sc_isconsole && wsdisplay_cons_pollmode ?
		      0 : wsswitch_cb1, sc);
		if (res == EAGAIN) {
			/* switch will be done asynchronously */
			return (0);
		}
	} else if (scr->scr_flags & SCR_GRAPHICS) {
		/* no way to save state */
		res = EBUSY;
	}
#endif

	return (wsdisplay_switch1(sc, res, waitok));
}

void
wsdisplay_reset(struct device *dev, enum wsdisplay_resetops op)
{
	struct wsdisplay_softc *sc = (struct wsdisplay_softc *)dev;
	struct wsscreen *scr;

	KASSERT(sc != NULL);
	scr = sc->sc_focus;

	if (!scr)
		return;

	switch (op) {
	case WSDISPLAY_RESETEMUL:
		(*scr->scr_dconf->wsemul->reset)(scr->scr_dconf->wsemulcookie,
		    WSEMUL_RESET);
		break;
	case WSDISPLAY_RESETCLOSE:
		wsdisplay_closescreen(sc, scr);
		break;
	}
}

#ifdef WSDISPLAY_COMPAT_USL
/*
 * Interface for (external) VT switch / process synchronization code
 */
int
wsscreen_attach_sync(struct wsscreen *scr, const struct wscons_syncops *ops,
    void *cookie)
{
	if (scr->scr_syncops) {
		/*
		 * The screen is already claimed.
		 * Check if the owner is still alive.
		 */
		if ((*scr->scr_syncops->check)(scr->scr_synccookie))
			return (EBUSY);
	}
	scr->scr_syncops = ops;
	scr->scr_synccookie = cookie;
	return (0);
}

int
wsscreen_detach_sync(struct wsscreen *scr)
{
	if (!scr->scr_syncops)
		return (EINVAL);
	scr->scr_syncops = 0;
	return (0);
}

int
wsscreen_lookup_sync(struct wsscreen *scr,
    const struct wscons_syncops *ops, /* used as ID */
    void **cookiep)
{
	if (!scr->scr_syncops || ops != scr->scr_syncops)
		return (EINVAL);
	*cookiep = scr->scr_synccookie;
	return (0);
}
#endif

/*
 * Interface to virtual screen stuff
 */
int
wsdisplay_maxscreenidx(struct wsdisplay_softc *sc)
{
	return (WSDISPLAY_MAXSCREEN - 1);
}

int
wsdisplay_screenstate(struct wsdisplay_softc *sc, int idx)
{
	if (idx < 0 || idx >= WSDISPLAY_MAXSCREEN)
		return (EINVAL);
	if (!sc->sc_scr[idx])
		return (ENXIO);
	return ((sc->sc_scr[idx]->scr_flags & SCR_OPEN) ? EBUSY : 0);
}

int
wsdisplay_getactivescreen(struct wsdisplay_softc *sc)
{
	return (sc->sc_focus ? sc->sc_focusidx : WSDISPLAY_NULLSCREEN);
}

int
wsscreen_switchwait(struct wsdisplay_softc *sc, int no)
{
	struct wsscreen *scr;
	int s, res = 0;

	if (no == WSDISPLAY_NULLSCREEN) {
		s = spltty();
		while (sc->sc_focus && res == 0) {
			res = tsleep(sc, PCATCH, "wswait", 0);
		}
		splx(s);
		return (res);
	}

	if (no < 0 || no >= WSDISPLAY_MAXSCREEN)
		return (ENXIO);
	scr = sc->sc_scr[no];
	if (!scr)
		return (ENXIO);

	s = spltty();
	if (scr != sc->sc_focus) {
		scr->scr_flags |= SCR_WAITACTIVE;
		res = tsleep(scr, PCATCH, "wswait", 0);
		if (scr != sc->sc_scr[no])
			res = ENXIO; /* disappeared in the meantime */
		else
			scr->scr_flags &= ~SCR_WAITACTIVE;
	}
	splx(s);
	return (res);
}

void
wsdisplay_kbdholdscreen(struct device *dev, int hold)
{
	struct wsdisplay_softc *sc = (struct wsdisplay_softc *)dev;
	struct wsscreen *scr;

	scr = sc->sc_focus;

	if (hold)
		scr->scr_hold_screen = 1;
	else {
		scr->scr_hold_screen = 0;
		timeout_add(&scr->scr_tty->t_rstrt_to, 0); /* "immediate" */
	}
}

#if NWSKBD > 0
void
wsdisplay_set_console_kbd(struct wsevsrc *src)
{
	if (wsdisplay_console_device == NULL) {
		src->me_dispdv = NULL;
		return;
	}
#if NWSMUX > 0
	if (wsmux_attach_sc((struct wsmux_softc *)
			    wsdisplay_console_device->sc_input, src)) {
		src->me_dispdv = NULL;
		return;
	}
#else
	wsdisplay_console_device->sc_input = src;
#endif
	src->me_dispdv = &wsdisplay_console_device->sc_dv;
}

#if NWSMUX == 0
int
wsdisplay_set_kbd(struct device *disp, struct wsevsrc *kbd)
{
	struct wsdisplay_softc *sc = (struct wsdisplay_softc *)disp;

	if (sc->sc_input != NULL)
		return (EBUSY);

	sc->sc_input = kbd;

	return (0);
}
#endif

#endif /* NWSKBD > 0 */

/*
 * Console interface.
 */
void
wsdisplay_cnputc(dev_t dev, int i)
{
	struct wsscreen_internal *dc;
	char c = i;

	if (!wsdisplay_console_initted)
		return;

	if (wsdisplay_console_device != NULL &&
	    (wsdisplay_console_device->sc_scr[0] != NULL) &&
	    (wsdisplay_console_device->sc_scr[0]->scr_flags & SCR_GRAPHICS))
		return;

	dc = &wsdisplay_console_conf;
#ifdef BURNER_SUPPORT
	/*wsdisplay_burn(wsdisplay_console_device, WSDISPLAY_BURN_OUTPUT);*/
#endif
	(*dc->wsemul->output)(dc->wsemulcookie, &c, 1, 1);
}

int
wsdisplay_getc_dummy(dev_t dev)
{
	/* panic? */
	return (0);
}

void
wsdisplay_pollc(dev_t dev, int on)
{

	wsdisplay_cons_pollmode = on;

	/* notify to fb drivers */
	if (wsdisplay_console_device != NULL &&
	    wsdisplay_console_device->sc_accessops->pollc != NULL)
		(*wsdisplay_console_device->sc_accessops->pollc)
		    (wsdisplay_console_device->sc_accesscookie, on);

	/* notify to kbd drivers */
	if (wsdisplay_cons_kbd_pollc)
		(*wsdisplay_cons_kbd_pollc)(dev, on);
}

void
wsdisplay_set_cons_kbd(int (*get)(dev_t), void (*poll)(dev_t, int),
    void (*bell)(dev_t, u_int, u_int, u_int))
{
	wsdisplay_cons.cn_getc = get;
	wsdisplay_cons.cn_bell = bell;
	wsdisplay_cons_kbd_pollc = poll;
}

void
wsdisplay_unset_cons_kbd()
{
	wsdisplay_cons.cn_getc = wsdisplay_getc_dummy;
	wsdisplay_cons.cn_bell = NULL;
	wsdisplay_cons_kbd_pollc = 0;
}

/*
 * Switch the console display to it's first screen.
 */
void
wsdisplay_switchtoconsole()
{
	struct wsdisplay_softc *sc;
	struct wsscreen *scr;

	if (wsdisplay_console_device != NULL) {
		sc = wsdisplay_console_device;
		if ((scr = sc->sc_scr[0]) == NULL)
			return;
		(*sc->sc_accessops->show_screen)(sc->sc_accesscookie,
		    scr->scr_dconf->emulcookie, 0, NULL, NULL);
	}
}

#ifdef WSDISPLAY_SCROLLBACK_SUPPORT
void
wsscrollback(void *arg, int op)
{
	struct wsdisplay_softc *sc = arg;
	int lines;

	if (op == WSDISPLAY_SCROLL_RESET)
		lines = 0;
	else {
		lines = sc->sc_focus->scr_dconf->scrdata->nrows - 1;
		if (op == WSDISPLAY_SCROLL_BACKWARD)
			lines = -lines;
	}

	if (sc->sc_accessops->scrollback) {
		(*sc->sc_accessops->scrollback)(sc->sc_accesscookie,
		    sc->sc_focus->scr_dconf->emulcookie, lines);
	}
}
#endif

#ifdef BURNER_SUPPORT
void
wsdisplay_burn(void *v, u_int flags)
{
	struct wsdisplay_softc *sc = v;

	if ((flags & sc->sc_burnflags & (WSDISPLAY_BURN_OUTPUT |
	    WSDISPLAY_BURN_KBD | WSDISPLAY_BURN_MOUSE)) &&
	    sc->sc_accessops->burn_screen) {
		if (sc->sc_burnout)
			timeout_add(&sc->sc_burner, sc->sc_burnout);
		if (sc->sc_burnman)
			sc->sc_burnout = 0;
	}
}

void
wsdisplay_burner(void *v)
{
	struct wsdisplay_softc *sc = v;
	int s;

	if (sc->sc_accessops->burn_screen) {
		(*sc->sc_accessops->burn_screen)(sc->sc_accesscookie,
		    sc->sc_burnman, sc->sc_burnflags);
		s = spltty();
		if (sc->sc_burnman) {
			sc->sc_burnout = sc->sc_burnoutintvl;
			timeout_add(&sc->sc_burner, sc->sc_burnout);
		} else
			sc->sc_burnout = sc->sc_burninintvl;
		sc->sc_burnman = !sc->sc_burnman;
		splx(s);
	}
}
#endif

/*
 * Switch the console at shutdown.
 */
void
wsdisplay_shutdownhook(void *arg)
{
	wsdisplay_switchtoconsole();
}

#ifdef WSMOUSED_SUPPORT
/*
 * wsmoused(8) support functions
 */

/* pointer to the current screen wsdisplay_softc structure */
static struct wsdisplay_softc *sc = NULL;

/*
 * Main function, called from wsdisplay_cfg_ioctl.
 */
int
wsmoused(struct wsdisplay_softc *ws_sc, u_long cmd, caddr_t data,
    int flag, struct proc *p)
{
	int error = -1;
	struct wscons_event mouse_event = *(struct wscons_event *)data;

	if (cmd == WSDISPLAYIO_WSMOUSED) {
		if (IS_MOTION_EVENT(mouse_event.type)) {
			motion_event(mouse_event.type, mouse_event.value);
			return (0);
		}
		if (IS_BUTTON_EVENT(mouse_event.type)) {
			/* XXX tv_sec contains the number of clicks */
			if (mouse_event.type == WSCONS_EVENT_MOUSE_DOWN) {
				button_event(mouse_event.value,
				    mouse_event.time.tv_sec);
			} else
				button_event(mouse_event.value, 0);
			return (0);
		}
		if (IS_CTRL_EVENT(mouse_event.type)) {
			return (ctrl_event(mouse_event.type, mouse_event.value,
			    ws_sc, p));
		}
	}
	return (error);
}

/*
 * Mouse motion events
 */
void
motion_event(u_int type, int value)
{
	switch (type) {
		case WSCONS_EVENT_MOUSE_DELTA_X:
			mouse_moverel(value, 0);
			break;
		case WSCONS_EVENT_MOUSE_DELTA_Y:
			mouse_moverel(0, 0 - value);
			break;
		case WSCONS_EVENT_MOUSE_DELTA_Z:
			mouse_zaxis(value);
			break;
		default:
			break;
	}
}

/*
 * Button clicks events
 */
void
button_event(int button, int clicks)
{
	switch (button) {
	case MOUSE_COPY_BUTTON:
		switch (clicks % 4) {
		case 0: /* button is up */
			mouse_copy_end();
			mouse_copy_selection();
			break;
		case 1: /* single click */
			mouse_copy_start();
			mouse_copy_selection();
			break;
		case 2: /* double click */
			mouse_copy_word();
			mouse_copy_selection();
			break;
		case 3: /* triple click */
			mouse_copy_line();
			mouse_copy_selection();
			break;
		default:
			break;
		}
		break;

	case MOUSE_PASTE_BUTTON:
		switch (clicks) {
		case 0: /* button is up */
			break;
		default: /* paste */
			mouse_paste();
			break;
		}
		break;

	case MOUSE_EXTEND_BUTTON:
		switch (clicks) {
		case 0: /* button is up */
			break;
		default: /* extend the selection */
			mouse_copy_extend_after();
			break;
		}
		break;

	default:
		break;
	}
}

/*
 * Control events
 */
int
ctrl_event(u_int type, int value, struct wsdisplay_softc *ws_sc, struct proc *p)
{
	int i, error = 0;

	if (type == WSCONS_EVENT_WSMOUSED_ON) {
		if (!ws_sc->sc_accessops->getchar)
			/* no wsmoused(8) support in the display driver */
			return (1);
		/* initialization of globals */
		sc = ws_sc;
		allocate_copybuffer(sc);
		Paste_avail = 0;
		ws_sc->wsmoused_dev = value;
	}
	if (type == WSCONS_EVENT_WSMOUSED_OFF) {
		Paste_avail = 0;
		ws_sc->wsmoused_dev = 0;
		return (0);
	}
	if (type == WSCONS_EVENT_WSMOUSED_SLEEP) {
		/* sleeping until next switch to text mode */
		ws_sc->wsmoused_sleep = 1;
		error = 0;
		while (ws_sc->wsmoused_sleep && error == 0)
			error = tsleep(&ws_sc->wsmoused_sleep, PPAUSE,
			    "wsmoused_sleep", 0);
		return (error);
	}
	for (i = 0 ; i < WSDISPLAY_DEFAULTSCREENS ; i++)
		if (sc->sc_scr[i]) {
			sc->sc_scr[i]->mouse =
				((WS_NCOLS(sc->sc_scr[i]) *
				  WS_NROWS(sc->sc_scr[i])) / 2);
			sc->sc_scr[i]->cursor = sc->sc_scr[i]->mouse;
			sc->sc_scr[i]->cpy_start = 0;
			sc->sc_scr[i]->cpy_end = 0;
			sc->sc_scr[i]->orig_start = 0;
			sc->sc_scr[i]->orig_end = 0;
			sc->sc_scr[i]->mouse_flags = 0;
		}
	return (0);
}

void
mouse_moverel(char dx, char dy)
{
	unsigned short old_mouse = MOUSE;
	unsigned char mouse_col = (MOUSE % N_COLS);
	unsigned char mouse_row = (MOUSE / N_COLS);

	/* wscons has support for screen saver via the WSDISPLAYIO_{G,S}VIDEO
	   with WSDISPLAY_VIDEO_OFF and WSDISPLAY_VIDEO_ON values.
	   However, none of the pc display driver (pcdisplay.c or vga.c)
	   support this ioctl. Only the alpha display driver (tga.c) support it.

	   When screen saver support is available, /usr/sbin/screenblank can be
	   used with the -m option, so that mice movements stop the screen
	   saver.
	 */

	/* update position */

	if (mouse_col + dx >= MAXCOL)
		mouse_col = MAXCOL;
	else {
		if (mouse_col + dx <= 0)
			mouse_col = 0;
		else
			mouse_col += dx;
	}
	if (mouse_row + dy >= MAXROW)
		mouse_row = MAXROW;
	else {
		if (mouse_row + dy <= 0)
			mouse_row = 0;
		else
			mouse_row += dy;
	}
	MOUSE = XY_TO_POS(mouse_col, mouse_row);
	/* if we have moved */
	if (old_mouse != MOUSE) {
		if (IS_SEL_IN_PROGRESS(sc->sc_focus)) {
			/* selection in progress */
			mouse_copy_extend();
		} else {
			inverse_char(MOUSE);
			if (IS_MOUSE_VISIBLE(sc->sc_focus))
				inverse_char(old_mouse);
			else
				MOUSE_FLAGS |= MOUSE_VISIBLE;
		}
	}
}

void
inverse_char(unsigned short pos)
{
	struct wsscreen_internal *dconf;
	struct wsdisplay_charcell cell;
	int fg, bg;
	int flags;
	int tmp;
	long attr;

	dconf = sc->sc_focus->scr_dconf;

	GETCHAR(pos, &cell);

	/*
	 * flags can be at most
	 * WSATTR_UNDERLINE | WSATTR_REVERSE | WSATTR_HILIT
	 * if WSSCREEN_WSCOLORS then no WSATTR_REVERSE
	 */
	(*dconf->emulops->unpack_attr)(dconf->emulcookie, cell.attr, &fg,
	    &bg, &flags);

	/*
	 * Display the mouse cursor as a color inverted cell whenever
	 * possible. If this is not possible, ask for the video reverse
	 * attribute.
	 */
	if (dconf->scrdata->capabilities & WSSCREEN_WSCOLORS) {
		flags |= WSATTR_WSCOLORS;
		tmp = fg;
		fg = bg;
		bg = tmp;
	} else if (dconf->scrdata->capabilities & WSSCREEN_REVERSE) {
		flags ^= WSATTR_REVERSE;
	}
	if ((*dconf->emulops->alloc_attr)(dconf->emulcookie, fg, bg, flags,
	    &attr) == 0) {
		cell.attr = attr;
		PUTCHAR(pos, cell.uc, cell.attr);
	}
}

void
inverse_region(unsigned short start, unsigned short end)
{
	unsigned short current_pos;
	unsigned short abs_end;

	/* sanity check, useful because 'end' can be (0 - 1) = 65535 */
	abs_end = N_COLS * N_ROWS;
	if (end > abs_end)
		return;
	current_pos = start;
	while (current_pos <= end)
		inverse_char(current_pos++);
}

/*
 * Return the number of contiguous blank characters between the right margin
 * if border == 1 or between the next non-blank character and the current mouse
 * cursor if border == 0
 */
unsigned char
skip_spc_right(char border)
{
	struct wsdisplay_charcell cell;
	unsigned short current = CPY_END;
	unsigned short mouse_col = (CPY_END % N_COLS);
	unsigned short limit = current + (N_COLS - mouse_col - 1);
	unsigned char res = 0;

	while (GETCHAR(current, &cell) == 0 && cell.uc == ' ' &&
	    current <= limit) {
		current++;
		res++;
	}
	if (border == BORDER) {
		if (current > limit)
			return (res - 1);
		else
			return (0);
	} else {
		if (res)
			return (res - 1);
		else
			return (res);
	}
}

/*
 * Return the number of contiguous blank characters between the first of the
 * contiguous blank characters and the current mouse cursor
 */
unsigned char
skip_spc_left(void)
{
	struct wsdisplay_charcell cell;
	short current = CPY_START;
	unsigned short mouse_col = (MOUSE % N_COLS);
	unsigned short limit = current - mouse_col;
	unsigned char res = 0;

	while (GETCHAR(current, &cell) == 0 && cell.uc == ' ' &&
	    current >= limit) {
		current--;
		res++;
	}
	if (res)
		res--;
	return (res);
}

/*
 * Class of characters
 * Stolen from xterm sources of the Xfree project (see cvs tag below)
 * $TOG: button.c /main/76 1997/07/30 16:56:19 kaleb $
 */
static const int charClass[256] = {
/* NUL  SOH  STX  ETX  EOT  ENQ  ACK  BEL */
    32,   1,   1,   1,   1,   1,   1,   1,
/*  BS   HT   NL   VT   NP   CR   SO   SI */
     1,  32,   1,   1,   1,   1,   1,   1,
/* DLE  DC1  DC2  DC3  DC4  NAK  SYN  ETB */
     1,   1,   1,   1,   1,   1,   1,   1,
/* CAN   EM  SUB  ESC   FS   GS   RS   US */
     1,   1,   1,   1,   1,   1,   1,   1,
/*  SP    !    "    #    $    %    &    ' */
    32,  33,  34,  35,  36,  37,  38,  39,
/*   (    )    *    +    ,    -    .    / */
    40,  41,  42,  43,  44,  45,  46,  47,
/*   0    1    2    3    4    5    6    7 */
    48,  48,  48,  48,  48,  48,  48,  48,
/*   8    9    :    ;    <    =    >    ? */
    48,  48,  58,  59,  60,  61,  62,  63,
/*   @@    A    B    C    D    E    F    G */
    64,  48,  48,  48,  48,  48,  48,  48,
/*   H    I    J    K    L    M    N    O */
    48,  48,  48,  48,  48,  48,  48,  48,
/*   P    Q    R    S    T    U    V    W */
    48,  48,  48,  48,  48,  48,  48,  48,
/*   X    Y    Z    [    \    ]    ^    _ */
    48,  48,  48,  91,  92,  93,  94,  48,
/*   `    a    b    c    d    e    f    g */
    96,  48,  48,  48,  48,  48,  48,  48,
/*   h    i    j    k    l    m    n    o */
    48,  48,  48,  48,  48,  48,  48,  48,
/*   p    q    r    s    t    u    v    w */
    48,  48,  48,  48,  48,  48,  48,  48,
/*   x    y    z    {    |    }    ~  DEL */
    48,  48,  48, 123, 124, 125, 126,   1,
/* x80  x81  x82  x83  IND  NEL  SSA  ESA */
     1,   1,   1,   1,   1,   1,   1,   1,
/* HTS  HTJ  VTS  PLD  PLU   RI  SS2  SS3 */
     1,   1,   1,   1,   1,   1,   1,   1,
/* DCS  PU1  PU2  STS  CCH   MW  SPA  EPA */
     1,   1,   1,   1,   1,   1,   1,   1,
/* x98  x99  x9A  CSI   ST  OSC   PM  APC */
     1,   1,   1,   1,   1,   1,   1,   1,
/*   -    i   c/    L   ox   Y-    |   So */
   160, 161, 162, 163, 164, 165, 166, 167,
/*  ..   c0   ip   <<    _        R0    - */
   168, 169, 170, 171, 172, 173, 174, 175,
/*   o   +-    2    3    '    u   q|    . */
   176, 177, 178, 179, 180, 181, 182, 183,
/*   ,    1    2   >>  1/4  1/2  3/4    ? */
   184, 185, 186, 187, 188, 189, 190, 191,
/*  A`   A'   A^   A~   A:   Ao   AE   C, */
    48,  48,  48,  48,  48,  48,  48,  48,
/*  E`   E'   E^   E:   I`   I'   I^   I: */
    48,  48,  48,  48,  48,  48,  48,  48,
/*  D-   N~   O`   O'   O^   O~   O:    X */
    48,  48,  48,  48,  48,  48,  48, 216,
/*  O/   U`   U'   U^   U:   Y'    P    B */
    48,  48,  48,  48,  48,  48,  48,  48,
/*  a`   a'   a^   a~   a:   ao   ae   c, */
    48,  48,  48,  48,  48,  48,  48,  48,
/*  e`   e'   e^   e:    i`  i'   i^   i: */
    48,  48,  48,  48,  48,  48,  48,  48,
/*   d   n~   o`   o'   o^   o~   o:   -: */
    48,  48,  48,  48,  48,  48,  48,  248,
/*  o/   u`   u'   u^   u:   y'    P   y: */
    48,  48,  48,  48,  48,  48,  48,  48
};

/*
 * Find the first blank beginning after the current cursor position
 */
unsigned char
skip_char_right(unsigned short offset)
{
	struct wsdisplay_charcell cell;
	unsigned short current = offset;
	unsigned short limit = current + (N_COLS - (MOUSE % N_COLS) - 1);
	unsigned char class;
	unsigned char res = 0;

	GETCHAR(current, &cell);
	class = charClass[cell.uc & 0xff];
	while (GETCHAR(current, &cell) == 0 &&
	    charClass[cell.uc & 0xff] == class && current <= limit) {
		current++;
		res++;
	}
	if (res)
		res--;
	return (res);
}

/*
 * Find the first non-blank character before the cursor position
 */
unsigned char
skip_char_left(unsigned short offset)
{
	struct wsdisplay_charcell cell;
	short current = offset;
	unsigned short limit = current - (MOUSE % N_COLS);
	unsigned char class;
	unsigned char res = 0;

	GETCHAR(current, &cell);
	class = charClass[cell.uc & 0xff];
	while (GETCHAR(current, &cell) == 0 &&
	    charClass[cell.uc & 0xff] == class && current >= limit) {
		current--;
		res++;
	}
	if (res)
		res--;
	return (res);
}

/*
 * Compare character classes
 */
unsigned char
class_cmp(unsigned short first, unsigned short second)
{
	struct wsdisplay_charcell cell;
	unsigned char first_class;
	unsigned char second_class;

	if (GETCHAR(first, &cell) != 0)
		return (1);
	first_class = charClass[cell.uc & 0xff];
	if (GETCHAR(second, &cell) != 0)
		return (1);
	second_class = charClass[cell.uc & 0xff];

	if (first_class != second_class)
		return (1);
	else
		return (0);
}

/*
 * Beginning of a copy operation
 */
void
mouse_copy_start(void)
{
	unsigned char right;
	/* if no selection, then that's the first one */

	if (!Paste_avail)
		Paste_avail = 1;

	/* remove the previous selection */

	if (IS_SEL_EXISTS(sc->sc_focus))
		remove_selection(sc);

	/* initial show of the cursor */
	if (!IS_MOUSE_VISIBLE(sc->sc_focus))
		inverse_char(MOUSE);

	CPY_START = MOUSE;
	CPY_END = MOUSE;
	ORIG_START = CPY_START;
	ORIG_END = CPY_END;
	CURSOR = CPY_END + 1; /* init value */

	right = skip_spc_right(BORDER); /* useful later, in mouse_copy_extend */
	if (right)
		MOUSE_FLAGS |= BLANK_TO_EOL;

	MOUSE_FLAGS |= SEL_IN_PROGRESS;
	MOUSE_FLAGS |= SEL_EXISTS;
	MOUSE_FLAGS |= SEL_BY_CHAR; /* select by char */
	MOUSE_FLAGS &= ~SEL_BY_WORD;
	MOUSE_FLAGS &= ~SEL_BY_LINE;
	MOUSE_FLAGS &= ~MOUSE_VISIBLE; /* cursor hidden in selection */
}

/*
 * Copy of the word under the cursor
 */
void
mouse_copy_word()
{
	struct wsdisplay_charcell cell;
	unsigned char right;
	unsigned char left;

	if (IS_SEL_EXISTS(sc->sc_focus))
		remove_selection(sc);

	if (IS_MOUSE_VISIBLE(sc->sc_focus))
		inverse_char(MOUSE);

	CPY_START = MOUSE;
	CPY_END = MOUSE;

	if (GETCHAR(MOUSE, &cell) == 0 && IS_ALPHANUM(cell.uc)) {
		right = skip_char_right(CPY_END);
		left = skip_char_left(CPY_START);
	} else {
		right = skip_spc_right(NO_BORDER);
		left = skip_spc_left();
	}

	CPY_START -= left;
	CPY_END += right;
	ORIG_START = CPY_START;
	ORIG_END = CPY_END;
	CURSOR = CPY_END + 1; /* init value, never happen */
	inverse_region(CPY_START, CPY_END);

	MOUSE_FLAGS |= SEL_IN_PROGRESS;
	MOUSE_FLAGS |= SEL_EXISTS;
	MOUSE_FLAGS &= ~SEL_BY_CHAR;
	MOUSE_FLAGS |= SEL_BY_WORD;
	MOUSE_FLAGS &= ~SEL_BY_LINE;

	/* mouse cursor hidden in the selection */
	MOUSE_FLAGS &= ~BLANK_TO_EOL;
	MOUSE_FLAGS &= ~MOUSE_VISIBLE;
}

/*
 * Copy of the current line
 */
void
mouse_copy_line(void)
{
	unsigned char row = MOUSE / N_COLS;

	if (IS_SEL_EXISTS(sc->sc_focus))
		remove_selection(sc);

	if (IS_MOUSE_VISIBLE(sc->sc_focus))
		inverse_char(MOUSE);

	CPY_START = row * N_COLS;
	CPY_END = CPY_START + (N_COLS - 1);
	ORIG_START = CPY_START;
	ORIG_END = CPY_END;
	CURSOR = CPY_END + 1;
	inverse_region(CPY_START, CPY_END);

	MOUSE_FLAGS |= SEL_IN_PROGRESS;
	MOUSE_FLAGS |= SEL_EXISTS;
	MOUSE_FLAGS &= ~SEL_BY_CHAR;
	MOUSE_FLAGS &= ~SEL_BY_WORD;
	MOUSE_FLAGS |= SEL_BY_LINE;

	/* mouse cursor hidden in the selection */
	MOUSE_FLAGS &= ~BLANK_TO_EOL;
	MOUSE_FLAGS &= ~MOUSE_VISIBLE;
}

/*
 * End of a copy operation
 */
void
mouse_copy_end(void)
{
	MOUSE_FLAGS &= ~(SEL_IN_PROGRESS);
	if (IS_SEL_BY_WORD(sc->sc_focus) || IS_SEL_BY_LINE(sc->sc_focus)) {
		if (CURSOR != (CPY_END + 1))
			inverse_char(CURSOR);
		CURSOR = CPY_END + 1;
	}
}


/*
 * Generic selection extend function
 */
void
mouse_copy_extend(void)
{
	if (IS_SEL_BY_CHAR(sc->sc_focus))
		mouse_copy_extend_char();
	if (IS_SEL_BY_WORD(sc->sc_focus))
		mouse_copy_extend_word();
	if (IS_SEL_BY_LINE(sc->sc_focus))
		mouse_copy_extend_line();
}

/*
 * Extend a selected region, character by character
 */
void
mouse_copy_extend_char()
{
	unsigned char right;

	if (!IS_SEL_EXT_AFTER(sc->sc_focus)) {

		if (IS_BLANK_TO_EOL(sc->sc_focus)) {
			/*
			 * First extension of selection. We handle special
			 * cases of blank characters to eol
			 */

			right = skip_spc_right(BORDER);
			if (MOUSE > ORIG_START) {
				/* the selection goes to the lower part of
				   the screen */

				/* remove the previous cursor, start of
				   selection is now next line */
				inverse_char(CPY_START);
				CPY_START += (right + 1);
				CPY_END = CPY_START;
				ORIG_START = CPY_START;
				/* simulate the initial mark */
				inverse_char(CPY_START);
			} else {
				/* the selection goes to the upper part
				   of the screen */
				/* remove the previous cursor, start of
				   selection is now at the eol */
				inverse_char(CPY_START);
				ORIG_START += (right + 1);
				CPY_START = ORIG_START - 1;
				CPY_END = ORIG_START - 1;
				/* simulate the initial mark */
				inverse_char(CPY_START);
			}
			MOUSE_FLAGS &= ~ BLANK_TO_EOL;
		}

		if (MOUSE < ORIG_START && CPY_END >= ORIG_START) {
			/* we go to the upper part of the screen */

			/* reverse the old selection region */
			remove_selection(sc);
			CPY_END = ORIG_START - 1;
			CPY_START = ORIG_START;
		}
		if (CPY_START < ORIG_START && MOUSE >= ORIG_START) {
			/* we go to the lower part of the screen */

			/* reverse the old selection region */

			remove_selection(sc);
			CPY_START = ORIG_START;
			CPY_END = ORIG_START - 1;
		}
		/* restore flags cleared in remove_selection() */
		MOUSE_FLAGS |= SEL_IN_PROGRESS;
		MOUSE_FLAGS |= SEL_EXISTS;
	}
	/* beginning of common part */

	if (MOUSE >= ORIG_START) {

		/* lower part of the screen */
		if (MOUSE > CPY_END) {
			/* extending selection */
			inverse_region(CPY_END + 1, MOUSE);
		} else {
			/* reducing selection */
			inverse_region(MOUSE + 1, CPY_END);
		}
		CPY_END = MOUSE;
	} else {
		/* upper part of the screen */
		if (MOUSE < CPY_START) {
			/* extending selection */
			inverse_region(MOUSE,CPY_START - 1);
		} else {
			/* reducing selection */
			inverse_region(CPY_START,MOUSE - 1);
		}
		CPY_START = MOUSE;
	}
	/* end of common part */
}

/*
 * Extend a selected region, word by word
 */
void
mouse_copy_extend_word(void)
{
	unsigned short old_cpy_end;
	unsigned short old_cpy_start;

	if (!IS_SEL_EXT_AFTER(sc->sc_focus)) {

		/* remove cursor in selection (black one) */

		if (CURSOR != (CPY_END + 1))
			inverse_char(CURSOR);

		/* now, switch between lower and upper part of the screen */

		if (MOUSE < ORIG_START && CPY_END >= ORIG_START) {
			/* going to the upper part of the screen */
			inverse_region(ORIG_END + 1, CPY_END);
			CPY_END = ORIG_END;
		}

		if (MOUSE > ORIG_END && CPY_START <= ORIG_START) {
			/* going to the lower part of the screen */
			inverse_region(CPY_START, ORIG_START - 1);
			CPY_START = ORIG_START;
		}
	}

	if (MOUSE >= ORIG_START) {
		/* lower part of the screen */

		if (MOUSE > CPY_END) {
			/* extending selection */

			old_cpy_end = CPY_END;
			CPY_END = MOUSE + skip_char_right(MOUSE);
			inverse_region(old_cpy_end + 1, CPY_END);
		} else {
			if (class_cmp(MOUSE, MOUSE + 1)) {
				/* reducing selection (remove last word) */
				old_cpy_end = CPY_END;
				CPY_END = MOUSE;
				inverse_region(CPY_END + 1, old_cpy_end);
			} else {
				old_cpy_end = CPY_END;
				CPY_END = MOUSE + skip_char_right(MOUSE);
				if (CPY_END != old_cpy_end) {
					/* reducing selection, from the end of
					 * next word */
					inverse_region(CPY_END + 1,
					    old_cpy_end);
				}
			}
		}
	} else {
		/* upper part of the screen */
		if (MOUSE < CPY_START) {
			/* extending selection */
			old_cpy_start = CPY_START;
			CPY_START = MOUSE - skip_char_left(MOUSE);
			inverse_region(CPY_START, old_cpy_start - 1);
		} else {
			if (class_cmp(MOUSE - 1, MOUSE)) {
				/* reducing selection (remove last word) */
				old_cpy_start = CPY_START;
				CPY_START = MOUSE;
				inverse_region(old_cpy_start,
				    CPY_START - 1);
			} else {
				old_cpy_start = CPY_START;
				CPY_START = MOUSE - skip_char_left(MOUSE);
				if (CPY_START != old_cpy_start) {
					inverse_region(old_cpy_start,
					    CPY_START - 1);
				}
			}
		}
	}

	if (!IS_SEL_EXT_AFTER(sc->sc_focus)) {
		/* display new cursor */
		CURSOR = MOUSE;
		inverse_char(CURSOR);
	}
}

/*
 * Extend a selected region, line by line
 */
void
mouse_copy_extend_line(void)
{
	unsigned short old_row;
	unsigned short new_row;
	unsigned short old_cpy_start;
	unsigned short old_cpy_end;

	if (!IS_SEL_EXT_AFTER(sc->sc_focus)) {
		/* remove cursor in selection (black one) */

		if (CURSOR != (CPY_END + 1))
			inverse_char(CURSOR);

		/* now, switch between lower and upper part of the screen */

		if (MOUSE < ORIG_START && CPY_END >= ORIG_START) {
			/* going to the upper part of the screen */
			inverse_region(ORIG_END + 1, CPY_END);
			CPY_END = ORIG_END;
		}

		if (MOUSE > ORIG_END && CPY_START <= ORIG_START) {
			/* going to the lower part of the screen */
			inverse_region(CPY_START, ORIG_START - 1);
			CPY_START = ORIG_START;
		}
	}

	if (MOUSE >= ORIG_START) {
		/* lower part of the screen */
		if (CURSOR == (CPY_END + 1))
			CURSOR = CPY_END;
		old_row = CURSOR / N_COLS;
		new_row = MOUSE / N_COLS;
		old_cpy_end = CPY_END;
		CPY_END = (new_row * N_COLS) + MAXCOL;
		if (new_row > old_row)
			inverse_region(old_cpy_end + 1, CPY_END);
		else if (new_row < old_row)
			inverse_region(CPY_END + 1, old_cpy_end);
	} else {
		/* upper part of the screen */
		old_row = CURSOR / N_COLS;
		new_row = MOUSE / N_COLS;
		old_cpy_start = CPY_START;
		CPY_START = new_row * N_COLS;
		if (new_row < old_row)
			inverse_region(CPY_START, old_cpy_start - 1);
		else if (new_row > old_row)
			inverse_region(old_cpy_start, CPY_START - 1);
	}

	if (!IS_SEL_EXT_AFTER(sc->sc_focus)) {
		/* display new cursor */
		CURSOR = MOUSE;
		inverse_char(CURSOR);
	}
}

void
mouse_hide(struct wsdisplay_softc *sc)
{
	if (IS_MOUSE_VISIBLE(sc->sc_focus)) {
		inverse_char(MOUSE);
		MOUSE_FLAGS &= ~MOUSE_VISIBLE;
	}
}

/*
 * Add an extension to a selected region, word by word
 */
void
mouse_copy_extend_after(void)
{
	unsigned short start_dist;
	unsigned short end_dist;

	if (IS_SEL_EXISTS(sc->sc_focus)) {
		MOUSE_FLAGS |= SEL_EXT_AFTER;
		mouse_hide(sc); /* hide current cursor */

		if (CPY_START > MOUSE)
			start_dist = CPY_START - MOUSE;
		else
			start_dist = MOUSE - CPY_START;
		if (MOUSE > CPY_END)
			end_dist = MOUSE - CPY_END;
		else
			end_dist = CPY_END - MOUSE;
		if (start_dist < end_dist) {
			/* upper part of the screen*/
			ORIG_START = MOUSE + 1;
			/* only used in mouse_copy_extend_line() */
			CURSOR = CPY_START;
		} else {
			/* lower part of the screen */
			ORIG_START = MOUSE;
			/* only used in mouse_copy_extend_line() */
			CURSOR = CPY_END;
		}
		if (IS_SEL_BY_CHAR(sc->sc_focus))
			mouse_copy_extend_char();
		if (IS_SEL_BY_WORD(sc->sc_focus))
			mouse_copy_extend_word();
		if (IS_SEL_BY_LINE(sc->sc_focus))
			mouse_copy_extend_line();
		mouse_copy_selection();
	}
}

/*
 * Remove a previously selected region
 */
void
remove_selection(struct wsdisplay_softc *sc)
{
	if (IS_SEL_EXT_AFTER(sc->sc_focus)) {
		/* reset the flag indicating an extension of selection */
		MOUSE_FLAGS &= ~SEL_EXT_AFTER;
	}
	inverse_region(CPY_START, CPY_END);
	MOUSE_FLAGS &= ~SEL_IN_PROGRESS;
	MOUSE_FLAGS &= ~SEL_EXISTS;
}

/*
 * Put the current visual selection in the selection buffer
 */
void
mouse_copy_selection(void)
{
	struct wsdisplay_charcell cell;
	unsigned short current = 0;
	unsigned short blank = current;
	unsigned short buf_end = ((N_COLS + 1) * N_ROWS);
	unsigned short sel_cur;
	unsigned short sel_end;

	sel_cur = CPY_START;
	sel_end = CPY_END;

	while (sel_cur <= sel_end && current < buf_end - 1) {
		if (GETCHAR(sel_cur, &cell) != 0)
			break;
		Copybuffer[current] = cell.uc;
		if (!IS_SPACE(Copybuffer[current]))
			blank = current + 1; /* first blank after non-blank */
		current++;
		if (POS_TO_X(sel_cur) == MAXCOL) {
			/* we are on the last col of the screen */
			Copybuffer[blank] = '\r'; /* carriage return */
			current = blank + 1; /* restart just after the carriage
					       return in the buffer */
			blank = current;
		}
		sel_cur++;
	}

	Copybuffer[current] = '\0';
}

/*
 * Paste the current selection
 */
void
mouse_paste(void)
{
	unsigned short len;
	unsigned char *current = Copybuffer;

	if (Paste_avail) {
		for (len = strlen(Copybuffer) ; len > 0; len--) {
			(*linesw[sc->sc_focus->scr_tty->t_line].l_rint)
			    (*current++, sc->sc_focus->scr_tty);
		}
	}
}

/*
 * Handle the z axis.
 * The z axis (roller or wheel) is mapped by default to scrollback.
 */
void
mouse_zaxis(int z)
{
	if (z < 0)
		wsscrollback(sc, WSDISPLAY_SCROLL_BACKWARD);
	else
		wsscrollback(sc, WSDISPLAY_SCROLL_FORWARD);
}

/*
 * Allocate the copy buffer. The size is:
 * (cols + 1) * (rows)
 * (+1 for '\n' at the end of lines),
 * where cols and rows are the maximum of column and rows of all screens.
 */
void
allocate_copybuffer(struct wsdisplay_softc *sc)
{
	int nscreens = sc->sc_scrdata->nscreens;
	int i,s;
	const struct wsscreen_descr **screens_list = sc->sc_scrdata->screens;
	const struct wsscreen_descr *current;
	unsigned short size = Copybuffer_size;

	s = spltty();
	for (i = 0; i < nscreens; i++) {
		current = *screens_list;
		if (( (current->ncols + 1) * current->nrows) > size)
			size = ((current->ncols + 1) * current->nrows);
			screens_list++;
	}
	if ((size != Copybuffer_size) && (Copybuffer_size != 0)) {
		bzero(Copybuffer, Copybuffer_size);
		free(Copybuffer, M_DEVBUF);
	}
	if ((Copybuffer = (char *)malloc(size, M_DEVBUF, M_NOWAIT)) == NULL) {
		printf("wscons: copybuffer memory malloc failed\n");
		Copybuffer_size = 0;
	}
	Copybuffer_size = size;
	splx(s);
}


/* Remove selection and cursor on current screen */
void
mouse_remove(struct wsdisplay_softc *sc)
{
	if (IS_SEL_EXISTS(sc->sc_focus))
		remove_selection(sc);

	mouse_hide(sc);
}

/* Send a wscons event to notify wsmoused(8) to release the mouse device */
void
wsmoused_release(struct wsdisplay_softc *sc)
{
#if NWSMOUSE > 0
	struct device *wsms_dev = NULL;
	struct device **wsms_dev_list;
	int is_wsmouse = 0;
#if NWSMUX > 0
	int is_wsmux = 0;
#endif /* NWSMUX > 0 */

	if (sc->wsmoused_dev) {
		/* wsmoused(8) is running */

		wsms_dev_list = (struct device **) wsmouse_cd.cd_devs;
		if (!wsms_dev_list)
			/* no wsmouse device exists */
			return ;

		/* test whether device opened by wsmoused(8) is a wsmux device
		 * (/dev/wsmouse) or a wsmouse device (/dev/wsmouse{0..n} */

#if NWSMUX > 0
		/* obtain major of /dev/wsmouse multiplexor device */
		/* XXX first member of wsmux_softc is of type struct device */
		if (cdevsw[major(sc->wsmoused_dev)].d_open == wsmuxopen)
			is_wsmux = 1;

		if (is_wsmux && (minor(sc->wsmoused_dev) == WSMOUSEDEVCF_MUX)) {
			/* /dev/wsmouse case */
			/* XXX at least, wsmouse0 exist */
			wsms_dev = wsms_dev_list[0];
		}
#endif /* NWSMUX > 0 */

		/* obtain major of /dev/wsmouse{0..n} devices */
		if (wsmouse_cd.cd_ndevs > 0) {
			if (cdevsw[major(sc->wsmoused_dev)].d_open ==
			     wsmouseopen)
				is_wsmouse = 1;
		}

		if (is_wsmouse && (minor(sc->wsmoused_dev) <= NWSMOUSE)) {
			/* /dev/wsmouseX case */
			if (minor(sc->wsmoused_dev) < wsmouse_cd.cd_ndevs) {
				wsms_dev =
				    wsms_dev_list[minor(sc->wsmoused_dev)];
			}
			else
				/* no corresponding /dev/wsmouseX device */
				return;
		}

		/* inject event to notify wsmoused(8) to close mouse device */
		if (wsms_dev != NULL)
			wsmouse_input(wsms_dev, 0, 0, 0, 0,
				      WSMOUSE_INPUT_WSMOUSED_CLOSE);

	}
#endif /* NWSMOUSE > 0 */
}

/* Wakeup wsmoused(8), so that the mouse device can be reopened */
void
wsmoused_wakeup(struct wsdisplay_softc *sc)
{
#if NWSMOUSE > 0
	if (sc->wsmoused_dev) {
		sc->wsmoused_sleep = 0;
		wakeup(&sc->wsmoused_sleep);
	}
#endif /* NWSMOUSE > 0 */
}
#endif /* WSMOUSED_SUPPORT */
@


1.6
log
@fastmerge
@
text
@d1 1
a1 1
/* $MirOS: src/sys/dev/wscons/wsdisplay.c,v 1.5 2006/05/25 12:20:25 tg Exp $ */
d2421 1
a2421 1
	int fg, bg, ul;
d2430 5
d2436 1
a2436 1
	    &bg, &ul);
a2442 1
	flags = 0;
d2449 1
a2449 1
		flags |= WSATTR_REVERSE;
d2451 2
a2452 2
	if ((*dconf->emulops->alloc_attr)(dconf->emulcookie, fg, bg, flags |
	    (ul ? WSATTR_UNDERLINE : 0), &attr) == 0) {
@


1.5
log
@add WSDISPLAY_SCROLLBACK_SUPPORT as kernel option
previously, SCROLLBACK_SUPPORT was defined #ifndef SMALL_KERNEL
but I like namespaced defns better
(commented out in GENERIC because it has no SMALL_KERNEL)
@
text
@d1 2
a2 2
/* $MirOS: src/sys/dev/wscons/wsdisplay.c,v 1.4 2005/07/21 21:52:20 tg Exp $ */
/* $OpenBSD: wsdisplay.c,v 1.61 2005/07/17 10:43:24 miod Exp $ */
d56 1
a65 2
#include <dev/ic/pcdisplay.h>

d107 2
d111 1
d210 1
d218 1
a218 1
	    wsdisplay_emul_attach,
d235 2
a236 1
	    void *accesscookie);
d292 1
a292 1
		(*dconf->wsemul->attach)(1, 0, 0, 0, 0, scr, 0);
d296 2
a297 4
		if (dconf == NULL) {
			free(scr, M_DEVBUF);
			return (NULL);
		}
d300 7
a306 10
		if (dconf->emulops != NULL &&
		    (dconf->wsemul = wsemul_pick(emul)) != NULL) {
			dconf->wsemulcookie =
			    (*dconf->wsemul->attach)(0, type, cookie,
				ccol, crow, scr, defattr);
		} else {
			free(dconf, M_DEVBUF);
			free(scr, M_DEVBUF);
			return (NULL);
		}
d316 4
a319 1
	scr->scr_syncops = 0;
d328 6
d500 1
d502 1
d504 1
a504 1
		return(EBUSY);
d537 2
a538 1
	printf("%s: screen %d deleted\n", sc->sc_dv.dv_xname, idx);
d574 1
a574 1
	    ap->accessops, ap->accesscookie);
d588 11
a598 1
/* Print function (for parent devices). */
d600 1
a600 1
wsemuldisplaydevprint(void *aux, const char *pnp)
d602 18
a619 2
#if 0 /* -Wunused */
	struct wsemuldisplaydev_attach_args *ap = aux;
d622 15
a636 4
	if (pnp)
		printf("wsdisplay at %s", pnp);
#if 0 /* don't bother; it's ugly */
	printf(" console %d", ap->console);
d639 1
a639 1
	return (UNCONF);
d644 1
a644 1
wsdisplaydevprint(void *aux, const char *pnp)
d647 1
a647 1
	struct wsdisplaydev_attach_args *ap = aux;
d652 3
d662 2
a663 1
    const struct wsdisplay_accessops *accessops, void *accesscookie)
d732 2
a733 1
	 * is for special cases like installation kernels.
d735 3
a737 1
	for (i = start; i < wsdisplay_defaultscreens; i++) {
d757 17
d893 1
d896 1
d909 1
a909 1
		    (caddr_t)&kbmode, 0, p);
d1012 3
d1064 3
a1066 1
	    case WSKBDIO_SETMODE:
d1069 1
a1069 1
	    case WSKBDIO_GETMODE:
d1076 5
a1080 5
	if (inp == NULL)
		return (ENXIO);
	error = wsevsrc_display_ioctl(inp, cmd, data, flag, p);
	if (error >= 0)
		return (error);
d1084 12
d1220 1
a1220 1
#endif
d1364 1
a1364 1
		return (ENXIO);
d1367 1
a1367 1
		return (ENODEV);
d1600 1
a1600 1
	error = wsevsrc_display_ioctl(inp, WSKBDIO_SETMODE, &data, 0, 0);
d1618 1
d1650 9
d1711 1
d1722 1
d1855 1
d1869 1
d1897 1
d1937 1
d2033 16
d2419 6
a2424 2
	u_int16_t uc;
	u_int16_t attr;
d2426 1
a2426 2
	uc = GET_FULLCHAR(pos);
	attr = uc;
d2428 1
a2428 2
	if ((attr >> 8) == 0)
		attr = (FG_LIGHTGREY << 8);
d2430 22
a2451 3
	attr = (((attr >> 8) & 0x88) | ((((attr >> 8) >> 4) |
		((attr >> 8) << 4)) & 0x77)) ;
	PUTCHAR(pos, (u_int) (uc & 0x00FF), (long) attr);
d2477 1
d2483 2
a2484 1
	while ((GETCHAR(current) == ' ') && (current <= limit)) {
d2508 1
d2514 2
a2515 1
	while ((GETCHAR(current) == ' ') && (current >= limit)) {
d2602 1
d2605 1
a2605 1
	unsigned char class = charClass[GETCHAR(current)];
d2608 4
a2611 2
	while ((charClass[GETCHAR(current)] == class)
		&& (current <= limit)) {
d2626 1
d2629 1
a2629 1
	unsigned char class = charClass[GETCHAR(current)];
d2632 4
a2635 1
	while ((charClass[GETCHAR(current)] == class) && (current >= limit)) {
d2650 1
d2654 6
a2659 2
	first_class = charClass[GETCHAR(first)];
	second_class = charClass[GETCHAR(second)];
d2712 1
d2725 1
a2725 1
	if (IS_ALPHANUM(MOUSE)) {
d3128 1
d3139 3
a3141 1
		Copybuffer[current] = (GETCHAR(sel_cur));
d3278 1
a3278 1
			if (minor(sc->wsmoused_dev) <= wsmouse_cd.cd_ndevs) {
@


1.4
log
@merge and bump patchlevel (kernel only)
@
text
@d1 1
a1 1
/* $MirOS: src/sys/dev/wscons/wsdisplay.c,v 1.3 2005/07/04 01:15:48 tg Exp $ */
d38 1
a38 1
#define	SCROLLBACK_SUPPORT
d2011 1
a2011 1
#ifdef SCROLLBACK_SUPPORT
@


1.3
log
@fastmerge
@
text
@d1 2
a2 2
/* $MirOS: src/sys/dev/wscons/wsdisplay.c,v 1.2 2005/03/06 21:27:58 tg Exp $ */
/* $OpenBSD: wsdisplay.c,v 1.60 2005/06/02 07:34:14 miod Exp $ */
a172 2
	struct wseventvar sc_evar;

a226 1
#define	WSSCREEN_HAS_EMULATOR(scr)	((scr)->scr_dconf->wsemul != NULL)
d285 1
a285 1
		 * If there's an emulation, tell it about the callback argument.
d288 1
a288 2
		if (dconf->wsemul != NULL)
			(*dconf->wsemul->attach)(1, 0, 0, 0, 0, scr, 0);
d298 2
a299 7
		if (dconf->emulops) {
			dconf->wsemul = wsemul_pick(emul);
			if (dconf->wsemul == NULL) {
				free(dconf, M_DEVBUF);
				free(scr, M_DEVBUF);
				return (NULL);
			}
d303 5
a307 2
		} else
			dconf->wsemul = NULL;
d315 1
a315 4
	if (WSSCREEN_HAS_EMULATOR(scr))
		scr->scr_flags = 0;
	else
		scr->scr_flags = SCR_GRAPHICS;
d337 2
a338 3
	if (WSSCREEN_HAS_EMULATOR(scr))
		(*scr->scr_dconf->wsemul->detach)(scr->scr_dconf->wsemulcookie,
		    &ccol, &crow);
d372 3
a374 6
	printf(" added (%s", sc->sc_scr[idx]->scr_dconf->scrdata->name);
	if (WSSCREEN_HAS_EMULATOR(sc->sc_scr[idx])) {
		printf(", %s emulation",
		    sc->sc_scr[idx]->scr_dconf->wsemul->name);
	}
	printf(")\n");
d778 1
a778 1
		if (newopen && WSSCREEN_HAS_EMULATOR(scr)) {
d780 1
a780 1
			 the emulation */
a782 2

			/* wsdisplay_set_emulation() */
d824 6
a829 9
	if (WSSCREEN_HAS_EMULATOR(scr)) {
		scr->scr_flags &= ~SCR_GRAPHICS;
		(*scr->scr_dconf->wsemul->reset)(scr->scr_dconf->wsemulcookie,
						 WSEMUL_RESET);
		if (wsdisplay_clearonclose)
			(*scr->scr_dconf->wsemul->reset)
				(scr->scr_dconf->wsemulcookie,
				 WSEMUL_CLEARSCREEN);
	}
d1022 5
a1026 7
	    if (WSSCREEN_HAS_EMULATOR(scr)) {
		    scr->scr_flags &= ~SCR_GRAPHICS;
		    if (d == WSDISPLAYIO_MODE_MAPPED ||
			d == WSDISPLAYIO_MODE_DUMBFB) {
			    scr->scr_flags |= SCR_GRAPHICS |
				((d == WSDISPLAYIO_MODE_DUMBFB) ?
				    SCR_DUMBFB : 0);
d1029 5
a1033 5
			    /*
			     * wsmoused cohabitation with X-Window support
			     * X-Window is starting
			     */
			    wsmoused_release(sc);
d1037 3
a1039 3
			    /* disable the burner while X is running */
			    if (sc->sc_burnout)
				    timeout_del(&sc->sc_burner);
d1041 1
a1041 2
		    }
		    else {
d1043 3
a1045 3
			    /* reenable the burner after exiting from X */
			    if (!sc->sc_burnman)
				    wsdisplay_burn(sc, sc->sc_burnflags);
d1049 7
a1055 10
			    /*
			     * wsmoused cohabitation with X-Window support
			     * X-Window is ending
			     */

			    wsmoused_wakeup(sc);
#endif
		    }
	    } else if (d == WSDISPLAYIO_MODE_EMUL)
		    return (EINVAL);
d1057 1
a1057 1
	    (void)(*sc->sc_accessops->ioctl)(sc->sc_accesscookie, cmd, data,
d1060 1
a1060 1
	    return (0);
d1070 1
a1070 1
		if (!error && WSSCREEN_HAS_EMULATOR(scr))
a1344 1
		KASSERT(WSSCREEN_HAS_EMULATOR(scr));
a1365 1
			KASSERT(WSSCREEN_HAS_EMULATOR(scr));
d1478 1
a1478 1
	else if (WSSCREEN_HAS_EMULATOR(scr)) {
a1782 2
		if (!WSSCREEN_HAS_EMULATOR(scr))
			break;
@


1.2
log
@* merge src/sys/
  (at least the better part of it)
* revert IPv6 networking to OpenBSD, since
  I didn't get IPV4_MAPPED addresses working :(
@
text
@d1 3
a3 3
/* $MirOS$ */
/* $OpenBSD: wsdisplay.c,v 1.53 2004/03/09 22:41:57 miod Exp $ */
/* $NetBSD: wsdisplay.c,v 1.37.4.1 2000/06/30 16:27:53 simonb Exp $ */
d35 5
a39 1
#include <sys/cdefs.h>
d67 1
d78 2
a79 2
#include "wsmousevar.h"
#endif /* NWSMOUSE > 0 */
d107 1
a107 1
#define	SCR_DUMBFB 8		/* in use as dumb framebuffer (iff SCR_GRAPHICS) */
d117 1
d145 1
d148 12
a159 10
struct wsscreen *wsscreen_attach(struct wsdisplay_softc *, int,
	const char *, const struct wsscreen_descr *, void *, int, int, long);
void wsscreen_detach(struct wsscreen *);
int wsdisplay_addscreen(struct wsdisplay_softc *, int, const char *, const char *);
int wsdisplay_getscreen(struct wsdisplay_softc *, struct wsdisplay_addscreendata *);
void wsdisplay_shutdownhook(void *);
void wsdisplay_addscreen_print(struct wsdisplay_softc *, int, int);
void wsdisplay_closescreen(struct wsdisplay_softc *, struct wsscreen *);
int wsdisplay_delscreen(struct wsdisplay_softc *, int, int);
void wsdisplay_burner(void *v);
d173 3
d182 1
d193 1
a193 1
	struct wsmux_softc *sc_muxdv;
d199 1
d202 1
a205 3
#if NWSMUX > 0
extern struct wsmux_softc **wsmuxdevs;
#endif /* NWSMUX > 0 */
d208 2
a209 4
int wsdisplay_emul_match(struct device *, void *, void *);
void wsdisplay_emul_attach(struct device *, struct device *, void *);
int wsdisplay_noemul_match(struct device *, void *, void *);
void wsdisplay_noemul_attach(struct device *, struct device *, void *);
d220 2
a221 8
struct cfattach wsdisplay_noemul_ca = {
	sizeof(struct wsdisplay_softc), wsdisplay_noemul_match,
	    wsdisplay_noemul_attach,
};

void wsdisplaystart(struct tty *);
int wsdisplayparam(struct tty *, struct termios *);

d232 2
a233 2
void wsdisplay_common_attach(struct wsdisplay_softc *sc,
	    int console, const struct wsscreen_list *,
d238 1
a238 1
int wsdisplay_update_rawkbd(struct wsdisplay_softc *, struct wsscreen *);
d241 1
a241 1
int wsdisplay_console_initted;
d245 2
a246 2
int wsdisplay_getc_dummy(dev_t);
void wsdisplay_pollc(dev_t, int);
d248 2
a249 2
int wsdisplay_cons_pollmode;
void (*wsdisplay_cons_kbd_pollc)(dev_t, int);
d257 1
a257 1
# define WSDISPLAY_DEFAULTSCREENS	1
d259 1
a259 1
int wsdisplay_defaultscreens = WSDISPLAY_DEFAULTSCREENS;
d261 3
a263 3
int wsdisplay_switch1(void *, int, int);
int wsdisplay_switch2(void *, int, int);
int wsdisplay_switch3(void *, int, int);
d265 1
a265 1
int wsdisplay_clearonclose;
d267 1
d271 1
d274 3
a276 8
wsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)
	struct wsdisplay_softc *sc;
	int console;
	const char *emul;
	const struct wsscreen_descr *type;
	void *cookie;
	int ccol, crow;
	long defattr;
d283 1
a283 1
		return (scr);
d295 1
a295 1
			       M_DEVBUF, M_NOWAIT);
d310 2
a311 2
			  (*dconf->wsemul->attach)(0, type, cookie,
						   ccol, crow, scr, defattr);
d328 1
d330 1
d338 1
a338 2
wsscreen_detach(scr)
	struct wsscreen *scr;
d348 1
a348 1
						  &ccol, &crow);
d354 1
a354 3
wsdisplay_screentype_pick(scrdata, name)
	const struct wsscreen_list *scrdata;
	const char *name;
d377 1
a377 3
wsdisplay_addscreen_print(sc, idx, count)
	struct wsdisplay_softc *sc;
	int idx, count;
d385 1
a385 1
			sc->sc_scr[idx]->scr_dconf->wsemul->name);
d391 2
a392 4
wsdisplay_addscreen(sc, idx, screentype, emul)
	struct wsdisplay_softc *sc;
	int idx;
	const char *screentype, *emul;
d411 1
a411 1
			scrdesc, &cookie, &ccol, &crow, &defattr);
d416 1
a416 1
			      cookie, ccol, crow, defattr);
d418 1
a418 2
		(*sc->sc_accessops->free_screen)(sc->sc_accesscookie,
						 cookie);
d428 1
a428 2
						 scr->scr_dconf->emulcookie,
						 0, 0, 0);
d434 1
d436 1
d441 2
a442 3
wsdisplay_getscreen(sc, sd)
	struct wsdisplay_softc *sc;
	struct wsdisplay_addscreendata *sd;
d464 1
a464 3
wsdisplay_closescreen(sc, scr)
	struct wsdisplay_softc *sc;
	struct wsscreen *scr;
d493 1
a493 3
wsdisplay_delscreen(sc, idx, flags)
	struct wsdisplay_softc *sc;
	int idx, flags;
d501 1
a501 2
	scr = sc->sc_scr[idx];
	if (!scr)
d538 1
a538 2
	(*sc->sc_accessops->free_screen)(sc->sc_accesscookie,
					 cookie);
d548 1
a548 4
wsdisplay_emul_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d553 1
a553 2
	if (cf->wsemuldisplaydevcf_console !=
	    WSEMULDISPLAYDEVCF_CONSOLE_UNK) {
d558 1
a558 2
		if (cf->wsemuldisplaydevcf_console != 0 &&
		    ap->console != 0)
d569 1
a569 3
wsdisplay_emul_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d574 3
a576 2
	wsdisplay_common_attach(sc, ap->console, ap->scrdata,
				ap->accessops, ap->accesscookie);
d592 1
a592 3
wsemuldisplaydevprint(aux, pnp)
	void *aux;
	const char *pnp;
a606 25
int
wsdisplay_noemul_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
{
#if 0 /* -Wunused */
	struct wsdisplaydev_attach_args *ap = aux;
#endif

	/* Always match. */
	return (1);
}

void
wsdisplay_noemul_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct wsdisplay_softc *sc = (struct wsdisplay_softc *)self;
	struct wsdisplaydev_attach_args *ap = aux;

	wsdisplay_common_attach(sc, 0, NULL, ap->accessops, ap->accesscookie);
}

d609 1
a609 3
wsdisplaydevprint(aux, pnp)
	void *aux;
	const char *pnp;
d622 3
a624 6
wsdisplay_common_attach(sc, console, scrdata, accessops, accesscookie)
	struct wsdisplay_softc *sc;
	int console;
	const struct wsscreen_list *scrdata;
	const struct wsdisplay_accessops *accessops;
	void *accesscookie;
d629 3
a631 1
	struct device *dv;
d633 6
a638 2
	sc->sc_muxdv = wsmux_create("dmux", sc->sc_dv.dv_unit);
	if (!sc->sc_muxdv)
d640 8
a647 1
	sc->sc_muxdv->sc_displaydv = &sc->sc_dv;
d649 2
d668 6
a673 2
		if ((dv = wskbd_set_console_display(&sc->sc_dv, sc->sc_muxdv)))
			printf(", using %s", dv->dv_xname);
d682 4
d703 1
d705 1
a705 1
	sc->sc_burninintvl  = (hz * WSDISPLAY_DEFBURNIN ) / 1000;
d710 1
d718 2
a719 5
wsdisplay_cnattach(type, cookie, ccol, crow, defattr)
	const struct wsscreen_descr *type;
	void *cookie;
	int ccol, crow;
	long defattr;
d735 2
a736 3
	wsdisplay_console_conf.wsemulcookie = (*wsemul->cnattach)(type, cookie,
								  ccol, crow,
								  defattr);
d747 1
a747 4
wsdisplayopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d764 1
a764 2
	scr = sc->sc_scr[WSDISPLAYSCREEN(dev)];
	if (!scr)
d806 1
a806 4
wsdisplayclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d819 2
a820 1
	scr = sc->sc_scr[WSDISPLAYSCREEN(dev)];
d853 1
a853 1
						(caddr_t)&kbmode, 0, p);
d859 1
d864 1
d870 1
a870 4
wsdisplayread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
d883 2
a884 1
	scr = sc->sc_scr[WSDISPLAYSCREEN(dev)];
d894 1
a894 4
wsdisplaywrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
d907 2
a908 1
	scr = sc->sc_scr[WSDISPLAYSCREEN(dev)];
d918 1
a918 2
wsdisplaytty(dev)
	dev_t dev;
d930 2
a931 1
	scr = sc->sc_scr[WSDISPLAYSCREEN(dev)];
d937 1
a937 6
wsdisplayioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d956 2
a957 1
	scr = sc->sc_scr[WSDISPLAYSCREEN(dev)];
d986 1
a986 4
wsdisplay_param(dev, cmd, dp)
	struct device *dev;
	u_long cmd;
	struct wsdisplay_param *dp;
d989 1
d991 1
a991 1
					   (caddr_t)dp, 0, NULL));
d995 2
a996 7
wsdisplay_internal_ioctl(sc, scr, cmd, data, flag, p)
	struct wsdisplay_softc *sc;
	struct wsscreen *scr;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d1001 2
d1014 4
a1017 1
	error = wsmux_displayioctl(&sc->sc_muxdv->sc_dv, cmd, data, flag, p);
d1048 1
d1054 1
d1056 1
d1060 1
d1063 1
d1067 1
d1069 1
d1076 1
d1099 1
d1147 2
a1148 1
				wsdisplay_burn(sc, sc->sc_burnflags);
d1153 1
d1168 2
a1169 6
wsdisplay_cfg_ioctl(sc, cmd, data, flag, p)
	struct wsdisplay_softc *sc;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d1174 2
a1175 2
#if defined(COMPAT_14) && NWSKBD > 0
	struct wsmux_device wsmuxdata;
d1179 1
d1183 1
d1249 1
a1249 28
#ifdef COMPAT_14
	case _O_WSDISPLAYIO_SETKEYBOARD:
#define d ((struct wsdisplay_kbddata *)data)
		switch (d->op) {
		case _O_WSDISPLAY_KBD_ADD:
			if (d->idx == -1) {
				d->idx = wskbd_pickfree();
				if (d->idx == -1)
					return (ENXIO);
			}
			wsmuxdata.type = WSMUX_KBD;
			wsmuxdata.idx = d->idx;
			return (wsmuxdoioctl(&sc->sc_muxdv->sc_dv,
					     WSMUX_ADD_DEVICE,
					     (caddr_t)&wsmuxdata, flag, p));
		case _O_WSDISPLAY_KBD_DEL:
			wsmuxdata.type = WSMUX_KBD;
			wsmuxdata.idx = d->idx;
			return (wsmuxdoioctl(&sc->sc_muxdv->sc_dv,
					     WSMUX_REMOVE_DEVICE,
					     (caddr_t)&wsmuxdata, flag, p));
		default:
			return (EINVAL);
		}
#undef d
#endif

	case WSMUX_ADD_DEVICE:
d1255 7
a1261 4
	case WSMUX_INJECTEVENT:
	case WSMUX_REMOVE_DEVICE:
	case WSMUX_LIST_DEVICES:
		return (wsmuxdoioctl(&sc->sc_muxdv->sc_dv, cmd, data, flag,p));
d1269 1
a1269 4
wsdisplaymmap(dev, offset, prot)
	dev_t dev;
	off_t offset;
	int prot;
d1277 2
a1278 1
	scr = sc->sc_scr[WSDISPLAYSCREEN(dev)];
d1288 1
a1288 4
wsdisplaypoll(dev, events, p)
	dev_t dev;
	int events;
	struct proc *p;
d1296 5
a1300 1
	scr = sc->sc_scr[WSDISPLAYSCREEN(dev)];
d1302 1
a1302 4
	if (WSSCREEN_HAS_TTY(scr))
		return (ttpoll(dev, events, p));
	else
		return (0);
d1306 1
a1306 3
wsdisplaykqfilter(dev, kn)
	dev_t dev;
	struct knote *kn;
d1314 2
a1315 1
	scr = sc->sc_scr[WSDISPLAYSCREEN(dev)];
d1324 1
a1324 2
wsdisplaystart(tp)
	struct tty *tp;
d1344 4
a1347 1
	scr = sc->sc_scr[WSDISPLAYSCREEN(tp->t_dev)];
d1370 1
d1372 2
d1381 1
d1392 1
d1394 1
d1403 5
a1407 4

	tp->t_state |= TS_TIMEOUT;
	timeout_add(&tp->t_rstrt_to, (hz > 128) ? (hz / 128) : 1);

d1410 1
a1410 1
		if (tp->t_state&TS_ASLEEP) {
d1420 1
a1420 3
wsdisplaystop(tp, flag)
	struct tty *tp;
	int flag;
d1435 1
a1435 3
wsdisplayparam(tp, t)
	struct tty *tp;
	struct termios *t;
d1448 1
a1448 2
wsdisplay_emulbell(v)
	void *v;
d1459 1
a1459 1
					FWRITE, NULL);
d1463 1
a1463 4
wsdisplay_emulinput(v, data, count)
	void *v;
	const u_char *data;
	u_int count;
d1485 1
a1485 3
wsdisplay_kbdinput(dev, ks)
	struct device *dev;
	keysym_t ks;
d1514 1
a1514 3
wsdisplay_update_rawkbd(sc, scr)
	struct wsdisplay_softc *sc;
	struct wsscreen *scr;
d1516 1
d1518 2
d1524 1
a1524 2
	if (scr != sc->sc_focus ||
	    sc->sc_rawkbd == raw) {
d1530 6
a1535 2
	error = wsmux_displayioctl(&sc->sc_muxdv->sc_dv, WSKBDIO_SETMODE,
				   (caddr_t)&data, 0, 0);
d1540 3
d1547 1
a1547 3
wsdisplay_switch3(arg, error, waitok)
	void *arg;
	int error, waitok;
d1576 1
a1576 1
		sc->sc_flags &= ~SC_SWITCHPENDING;
d1593 1
a1593 3
wsdisplay_switch2(arg, error, waitok)
	void *arg;
	int error, waitok;
d1639 2
a1640 1
	  sc->sc_isconsole && wsdisplay_cons_pollmode ? 0 : wsswitch_cb3, sc);
d1651 1
a1651 3
wsdisplay_switch1(arg, error, waitok)
	void *arg;
	int error, waitok;
d1686 2
a1687 3
						 scr->scr_dconf->emulcookie,
						 waitok,
	  sc->sc_isconsole && wsdisplay_cons_pollmode ? 0 : wsswitch_cb2, sc);
d1697 1
a1697 3
wsdisplay_switch(dev, no, waitok)
	struct device *dev;
	int no, waitok;
d1703 6
a1708 4

	if (no != WSDISPLAY_NULLSCREEN &&
	    (no < 0 || no >= WSDISPLAY_MAXSCREEN || !sc->sc_scr[no]))
		return (ENXIO);
d1736 1
a1749 1
	 *
d1776 1
d1781 2
a1782 1
	  sc->sc_isconsole && wsdisplay_cons_pollmode ? 0 : wsswitch_cb1, sc);
d1796 1
a1796 3
wsdisplay_reset(dev, op)
	struct device *dev;
	enum wsdisplay_resetops op;
d1812 1
a1812 1
						 WSEMUL_RESET);
d1824 2
a1825 4
wsscreen_attach_sync(scr, ops, cookie)
	struct wsscreen *scr;
	const struct wscons_syncops *ops;
	void *cookie;
d1841 1
a1841 2
wsscreen_detach_sync(scr)
	struct wsscreen *scr;
d1850 3
a1852 4
wsscreen_lookup_sync(scr, ops, cookiep)
	struct wsscreen *scr;
	const struct wscons_syncops *ops; /* used as ID */
	void **cookiep;
d1864 1
a1864 2
wsdisplay_maxscreenidx(sc)
	struct wsdisplay_softc *sc;
d1870 1
a1870 3
wsdisplay_screenstate(sc, idx)
	struct wsdisplay_softc *sc;
	int idx;
d1880 1
a1880 2
wsdisplay_getactivescreen(sc)
	struct wsdisplay_softc *sc;
d1886 1
a1886 3
wsscreen_switchwait(sc, no)
	struct wsdisplay_softc *sc;
	int no;
d1920 1
a1920 3
wsdisplay_kbdholdscreen(dev, hold)
	struct device *dev;
	int hold;
d1936 2
a1937 3
struct device *
wsdisplay_set_console_kbd(kbddv)
	struct device *kbddv;
d1939 14
a1952 5
	if (!wsdisplay_console_device)
		return (0);
	if (wskbd_add_mux(kbddv->dv_unit, wsdisplay_console_device->sc_muxdv))
		return (0);
	return (&wsdisplay_console_device->sc_dv);
d1960 1
a1960 3
wsdisplay_cnputc(dev, i)
	dev_t dev;
	int i;
d1969 1
d1974 1
d1976 1
d1981 1
a1981 2
wsdisplay_getc_dummy(dev)
	dev_t dev;
d1988 1
a1988 3
wsdisplay_pollc(dev, on)
	dev_t dev;
	int on;
a1989 5
	struct wsdisplay_softc *sc = NULL;
	int unit = WSDISPLAYUNIT(dev);

	if (unit < wsdisplay_cd.cd_ndevs)
		sc = wsdisplay_cd.cd_devs[unit];
d1994 4
a1997 2
	if (sc != NULL && sc->sc_accessops->pollc != NULL)
		(*sc->sc_accessops->pollc)(sc->sc_accesscookie, on);
d2005 2
a2006 4
wsdisplay_set_cons_kbd(get, poll, bell)
	int (*get)(dev_t);
	void (*poll)(dev_t, int);
	void (*bell)(dev_t, u_int, u_int, u_int);
d2032 2
a2033 1
		scr = sc->sc_scr[0];
d2039 1
d2041 1
a2041 3
wsscrollback(arg, op)
	void *arg;
	int op;
d2059 1
d2061 1
d2063 1
a2063 3
wsdisplay_burn(v, flags)
	void *v;
	u_int flags;
d2078 1
a2078 2
wsdisplay_burner(v)
	void *v;
d2096 1
d2102 1
a2102 2
wsdisplay_shutdownhook(arg)
	void *arg;
d2107 1
a2111 1

d2120 1
a2120 1
		int flag, struct proc *p)
d2473 2
a2474 1
    48,  48,  48,  48,  48,  48,  48,  48};
a3096 2


d3171 1
@


1.1
log
@Initial revision
@
text
@d1 1
d1265 14
a1278 1
		return (EINVAL);
d1826 1
a1826 1
	
d1831 1
a1831 1
	
d2303 1
a2303 1
	int i, error;
d3227 1
a3227 1
		if (wsms_dev != NULL) 
d3230 1
a3230 1
		
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@lastly some drivers
@
text
@d1 2
a2 2
/* $OpenBSD: wsdisplay.c,v 1.60 2005/06/02 07:34:14 miod Exp $ */
/* $NetBSD: wsdisplay.c,v 1.82 2005/02/27 00:27:52 perry Exp $ */
d34 1
a34 5
#ifndef	SMALL_KERNEL
#define WSMOUSED_SUPPORT
#define	BURNER_SUPPORT
#define	SCROLLBACK_SUPPORT
#endif
a61 1
#include "wsdisplay.h"
d72 2
a73 2
#include <dev/wscons/wsmousevar.h>
#endif
d101 1
a101 1
#define	SCR_DUMBFB 8		/* in use as dumb fb (iff SCR_GRAPHICS) */
a110 1
#ifdef WSMOUSED_SUPPORT
a137 1
#endif	/* WSMOUSED_SUPPORT */
d140 10
a149 12
struct wsscreen *wsscreen_attach(struct wsdisplay_softc *, int, const char *,
	    const struct wsscreen_descr *, void *, int, int, long);
void	wsscreen_detach(struct wsscreen *);
int	wsdisplay_addscreen(struct wsdisplay_softc *, int, const char *,
	    const char *);
int	wsdisplay_getscreen(struct wsdisplay_softc *,
	    struct wsdisplay_addscreendata *);
void	wsdisplay_shutdownhook(void *);
void	wsdisplay_addscreen_print(struct wsdisplay_softc *, int, int);
void	wsdisplay_closescreen(struct wsdisplay_softc *, struct wsscreen *);
int	wsdisplay_delscreen(struct wsdisplay_softc *, int, int);
void	wsdisplay_burner(void *v);
a162 3
	struct wseventvar sc_evar;

#ifdef BURNER_SUPPORT
a168 1
#endif
d179 1
a179 1
	struct wsevsrc *sc_input;
a184 1
#ifdef WSMOUSED_SUPPORT
a186 1
#endif
d190 3
d195 4
a198 2
int	wsdisplay_emul_match(struct device *, void *, void *);
void	wsdisplay_emul_attach(struct device *, struct device *, void *);
d209 8
a216 2
void	wsdisplaystart(struct tty *);
int	wsdisplayparam(struct tty *, struct termios *);
d227 2
a228 2
void	wsdisplay_common_attach(struct wsdisplay_softc *sc,
	    int console, int mux, const struct wsscreen_list *,
d233 1
a233 1
int	wsdisplay_update_rawkbd(struct wsdisplay_softc *, struct wsscreen *);
d236 1
a236 1
int	wsdisplay_console_initted;
d240 2
a241 2
int	wsdisplay_getc_dummy(dev_t);
void	wsdisplay_pollc(dev_t, int);
d243 2
a244 2
int	wsdisplay_cons_pollmode;
void	(*wsdisplay_cons_kbd_pollc)(dev_t, int);
d252 1
a252 1
#define WSDISPLAY_DEFAULTSCREENS	1
d254 1
a254 1
int	wsdisplay_defaultscreens = WSDISPLAY_DEFAULTSCREENS;
d256 3
a258 3
int	wsdisplay_switch1(void *, int, int);
int	wsdisplay_switch2(void *, int, int);
int	wsdisplay_switch3(void *, int, int);
d260 1
a260 1
int	wsdisplay_clearonclose;
a261 1
#ifdef WSMOUSED_SUPPORT
a264 1
#endif
d267 8
a274 3
wsscreen_attach(struct wsdisplay_softc *sc, int console, const char *emul,
    const struct wsscreen_descr *type, void *cookie, int ccol, int crow,
    long defattr)
d281 1
a281 1
		return (NULL);
d293 1
a293 1
		    M_DEVBUF, M_NOWAIT);
d308 2
a309 2
			    (*dconf->wsemul->attach)(0, type, cookie,
				ccol, crow, scr, defattr);
a325 1
#ifdef WSMOUSED_SUPPORT
a326 1
#endif
d334 2
a335 1
wsscreen_detach(struct wsscreen *scr)
d345 1
a345 1
		    &ccol, &crow);
d351 3
a353 1
wsdisplay_screentype_pick(const struct wsscreen_list *scrdata, const char *name)
d376 3
a378 1
wsdisplay_addscreen_print(struct wsdisplay_softc *sc, int idx, int count)
d386 1
a386 1
		    sc->sc_scr[idx]->scr_dconf->wsemul->name);
d392 4
a395 2
wsdisplay_addscreen(struct wsdisplay_softc *sc, int idx,
    const char *screentype, const char *emul)
d414 1
a414 1
	    scrdesc, &cookie, &ccol, &crow, &defattr);
d419 1
a419 1
	    cookie, ccol, crow, defattr);
d421 2
a422 1
		(*sc->sc_accessops->free_screen)(sc->sc_accesscookie, cookie);
d432 2
a433 1
		    scr->scr_dconf->emulcookie, 0, 0, 0);
a438 1
#ifdef WSMOUSED_SUPPORT
a439 1
#endif
d444 3
a446 2
wsdisplay_getscreen(struct wsdisplay_softc *sc,
    struct wsdisplay_addscreendata *sd)
d468 3
a470 1
wsdisplay_closescreen(struct wsdisplay_softc *sc, struct wsscreen *scr)
d499 3
a501 1
wsdisplay_delscreen(struct wsdisplay_softc *sc, int idx, int flags)
d509 2
a510 1
	if ((scr = sc->sc_scr[idx]) == NULL)
d547 2
a548 1
	(*sc->sc_accessops->free_screen)(sc->sc_accesscookie, cookie);
d558 4
a561 1
wsdisplay_emul_match(struct device *parent, void *match, void *aux)
d566 2
a567 1
	if (cf->wsemuldisplaydevcf_console != WSEMULDISPLAYDEVCF_CONSOLE_UNK) {
d572 2
a573 1
		if (cf->wsemuldisplaydevcf_console != 0 && ap->console != 0)
d584 3
a586 1
wsdisplay_emul_attach(struct device *parent, struct device *self, void *aux)
d591 2
a592 3
	wsdisplay_common_attach(sc, ap->console,
	    sc->sc_dv.dv_cfdata->wsemuldisplaydevcf_mux, ap->scrdata,
	    ap->accessops, ap->accesscookie);
d608 3
a610 1
wsemuldisplaydevprint(void *aux, const char *pnp)
d625 25
d652 3
a654 1
wsdisplaydevprint(void *aux, const char *pnp)
d667 6
a672 3
wsdisplay_common_attach(struct wsdisplay_softc *sc, int console, int kbdmux,
    const struct wsscreen_list *scrdata,
    const struct wsdisplay_accessops *accessops, void *accesscookie)
d677 1
a677 3
	struct wsevsrc *kme;
#if NWSMUX > 0
	struct wsmux_softc *mux;
d679 2
a680 6
	if (kbdmux >= 0)
		mux = wsmux_getmux(kbdmux);
	else
		mux = wsmux_create("dmux", sc->sc_dv.dv_unit);
	/* XXX panic()ing isn't nice, but attach cannot fail */
	if (mux == NULL)
d682 1
a682 8
	sc->sc_input = &mux->sc_base;
	mux->sc_displaydv = &sc->sc_dv;
	if (kbdmux >= 0)
		printf(" mux %d", kbdmux);
#else
#if 0	/* not worth keeping, especially since the default value is not -1... */
	if (kbdmux >= 0)
		printf(" (mux ignored)");
a683 2
#endif	/* NWSMUX > 0 */
#endif	/* NWSKBD > 0 */
d701 2
a702 6
		kme = wskbd_set_console_display(&sc->sc_dv, sc->sc_input);
		if (kme != NULL)
			printf(", using %s", kme->me_dv.dv_xname);
#if NWSMUX == 0
		sc->sc_input = kme;
#endif
a710 4
#if NWSKBD > 0 && NWSMUX > 0
	wsmux_set_display(mux, &sc->sc_dv);
#endif

a727 1
#ifdef BURNER_SUPPORT
d729 1
a729 1
	sc->sc_burninintvl = (hz * WSDISPLAY_DEFBURNIN ) / 1000;
a733 1
#endif
d741 5
a745 2
wsdisplay_cnattach(const struct wsscreen_descr *type, void *cookie, int ccol,
    int crow, long defattr)
d761 3
a763 2
	wsdisplay_console_conf.wsemulcookie =
	    (*wsemul->cnattach)(type, cookie, ccol, crow, defattr);
d774 4
a777 1
wsdisplayopen(dev_t dev, int flag, int mode, struct proc *p)
d794 2
a795 1
	if ((scr = sc->sc_scr[WSDISPLAYSCREEN(dev)]) == NULL)
d837 4
a840 1
wsdisplayclose(dev_t dev, int flag, int mode, struct proc *p)
d853 1
a853 2
	if ((scr = sc->sc_scr[WSDISPLAYSCREEN(dev)]) == NULL)
		return (ENXIO);
d886 1
a886 1
		    (caddr_t)&kbmode, 0, p);
a891 1
#ifdef WSMOUSED_SUPPORT
a895 1
#endif
d901 4
a904 1
wsdisplayread(dev_t dev, struct uio *uio, int flag)
d917 1
a917 2
	if ((scr = sc->sc_scr[WSDISPLAYSCREEN(dev)]) == NULL)
		return (ENXIO);
d927 4
a930 1
wsdisplaywrite(dev_t dev, struct uio *uio, int flag)
d943 1
a943 2
	if ((scr = sc->sc_scr[WSDISPLAYSCREEN(dev)]) == NULL)
		return (ENXIO);
d953 2
a954 1
wsdisplaytty(dev_t dev)
d966 1
a966 2
	if ((scr = sc->sc_scr[WSDISPLAYSCREEN(dev)]) == NULL)
		return (NULL);
d972 6
a977 1
wsdisplayioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
d996 1
a996 2
	if ((scr = sc->sc_scr[WSDISPLAYSCREEN(dev)]) == NULL)
		return (ENXIO);
d1025 4
a1028 1
wsdisplay_param(struct device *dev, u_long cmd, struct wsdisplay_param *dp)
a1030 1

d1032 1
a1032 1
	    (caddr_t)dp, 0, NULL));
d1036 7
a1042 2
wsdisplay_internal_ioctl(struct wsdisplay_softc *sc, struct wsscreen *scr,
    u_long cmd, caddr_t data, int flag, struct proc *p)
a1046 2
	struct wsevsrc *inp;

d1058 1
a1058 4
	inp = sc->sc_input;
	if (inp == NULL)
		return (ENXIO);
	error = wsevsrc_display_ioctl(inp, cmd, data, flag, p);
a1088 1
#ifdef WSMOUSED_SUPPORT
a1093 1
#endif
a1094 1
#ifdef BURNER_SUPPORT
a1097 1
#endif
a1099 1
#ifdef BURNER_SUPPORT
a1102 1
#endif
a1103 1
#ifdef WSMOUSED_SUPPORT
a1109 1
#endif
a1131 1
#ifdef BURNER_SUPPORT
d1179 1
a1179 2
				if ((scr->scr_flags & SCR_GRAPHICS) == 0)
					wsdisplay_burn(sc, sc->sc_burnflags);
a1183 1
#endif
d1198 6
a1203 2
wsdisplay_cfg_ioctl(struct wsdisplay_softc *sc, u_long cmd, caddr_t data,
    int flag, struct proc *p)
d1208 2
a1209 2
#if NWSKBD > 0
	struct wsevsrc *inp;
a1212 1
#ifdef WSMOUSED_SUPPORT
a1215 1
#endif
d1268 28
a1295 1
	case WSMUXIO_ADD_DEVICE:
d1301 4
a1304 7
	case WSMUXIO_INJECTEVENT:
	case WSMUXIO_REMOVE_DEVICE:
	case WSMUXIO_LIST_DEVICES:
		inp = sc->sc_input;
		if (inp == NULL)
			return (ENXIO);
		return (wsevsrc_ioctl(inp, cmd, data, flag,p));
d1312 4
a1315 1
wsdisplaymmap(dev_t dev, off_t offset, int prot)
d1323 1
a1323 2
	if ((scr = sc->sc_scr[WSDISPLAYSCREEN(dev)]) == NULL)
		return (-1);
d1333 4
a1336 1
wsdisplaypoll(dev_t dev, int events, struct proc *p)
d1344 1
a1344 2
	if ((scr = sc->sc_scr[WSDISPLAYSCREEN(dev)]) == NULL)
		return (ENXIO);
d1346 4
a1349 4
	if (!WSSCREEN_HAS_TTY(scr))
		return (ENODEV);

	return (ttpoll(dev, events, p));
d1353 3
a1355 1
wsdisplaykqfilter(dev_t dev, struct knote *kn)
d1363 1
a1363 2
	if ((scr = sc->sc_scr[WSDISPLAYSCREEN(dev)]) == NULL)
		return (1);
d1372 2
a1373 1
wsdisplaystart(struct tty *tp)
d1393 1
a1393 4
	if ((scr = sc->sc_scr[WSDISPLAYSCREEN(tp->t_dev)]) == NULL) {
		splx(s);
		return;
	}
a1415 1
#ifdef BURNER_SUPPORT
a1416 2
#endif
#ifdef WSMOUSED_SUPPORT
a1423 1
#endif
a1433 1
#ifdef BURNER_SUPPORT
a1434 1
#endif
d1443 4
a1446 5
	/* Come back if there's more to do */
	if (tp->t_outq.c_cc) {
		tp->t_state |= TS_TIMEOUT;
		timeout_add(&tp->t_rstrt_to, (hz > 128) ? (hz / 128) : 1);
	}
d1449 1
a1449 1
		if (tp->t_state & TS_ASLEEP) {
d1459 3
a1461 1
wsdisplaystop(struct tty *tp, int flag)
d1476 3
a1478 1
wsdisplayparam(struct tty *tp, struct termios *t)
d1491 2
a1492 1
wsdisplay_emulbell(void *v)
d1503 1
a1503 1
	    FWRITE, NULL);
d1507 4
a1510 1
wsdisplay_emulinput(void *v, const u_char *data, u_int count)
d1532 3
a1534 1
wsdisplay_kbdinput(struct device *dev, keysym_t ks)
d1563 3
a1565 1
wsdisplay_update_rawkbd(struct wsdisplay_softc *sc, struct wsscreen *scr)
a1566 1
#if NWSKBD > 0
a1567 2
	struct wsevsrc *inp;

d1572 2
a1573 1
	if (scr != sc->sc_focus || sc->sc_rawkbd == raw) {
d1579 2
a1580 6
	inp = sc->sc_input;
	if (inp == NULL) {
		splx(s);
		return (ENXIO);
	}
	error = wsevsrc_display_ioctl(inp, WSKBDIO_SETMODE, &data, 0, 0);
a1584 3
#else
	return (0);
#endif
d1589 3
a1591 1
wsdisplay_switch3(void *arg, int error, int waitok)
d1620 1
a1620 1
			sc->sc_flags &= ~SC_SWITCHPENDING;
d1637 3
a1639 1
wsdisplay_switch2(void *arg, int error, int waitok)
d1685 1
a1685 2
		    sc->sc_isconsole && wsdisplay_cons_pollmode ?
		      0 : wsswitch_cb3, sc);
d1696 3
a1698 1
wsdisplay_switch1(void *arg, int error, int waitok)
d1733 3
a1735 2
	    scr->scr_dconf->emulcookie, waitok,
	    sc->sc_isconsole && wsdisplay_cons_pollmode ? 0 : wsswitch_cb2, sc);
d1745 3
a1747 1
wsdisplay_switch(struct device *dev, int no, int waitok)
d1753 4
a1756 6
	if (no != WSDISPLAY_NULLSCREEN) {
		if (no < 0 || no >= WSDISPLAY_MAXSCREEN)
			return (EINVAL);
		if (sc->sc_scr[no] == NULL)
			return (ENXIO);
	}
a1783 1
#ifdef WSMOUSED_SUPPORT
d1797 1
a1823 1
#endif	/* WSMOUSED_SUPPORT */
d1828 1
a1828 2
		    sc->sc_isconsole && wsdisplay_cons_pollmode ?
		      0 : wsswitch_cb1, sc);
d1842 3
a1844 1
wsdisplay_reset(struct device *dev, enum wsdisplay_resetops op)
d1860 1
a1860 1
		    WSEMUL_RESET);
d1872 4
a1875 2
wsscreen_attach_sync(struct wsscreen *scr, const struct wscons_syncops *ops,
    void *cookie)
d1891 2
a1892 1
wsscreen_detach_sync(struct wsscreen *scr)
d1901 4
a1904 3
wsscreen_lookup_sync(struct wsscreen *scr,
    const struct wscons_syncops *ops, /* used as ID */
    void **cookiep)
d1916 2
a1917 1
wsdisplay_maxscreenidx(struct wsdisplay_softc *sc)
d1923 3
a1925 1
wsdisplay_screenstate(struct wsdisplay_softc *sc, int idx)
d1935 2
a1936 1
wsdisplay_getactivescreen(struct wsdisplay_softc *sc)
d1942 3
a1944 1
wsscreen_switchwait(struct wsdisplay_softc *sc, int no)
d1978 3
a1980 1
wsdisplay_kbdholdscreen(struct device *dev, int hold)
d1996 3
a1998 2
void
wsdisplay_set_console_kbd(struct wsevsrc *src)
d2000 5
a2004 14
	if (wsdisplay_console_device == NULL) {
		src->me_dispdv = NULL;
		return;
	}
#if NWSMUX > 0
	if (wsmux_attach_sc((struct wsmux_softc *)
			    wsdisplay_console_device->sc_input, src)) {
		src->me_dispdv = NULL;
		return;
	}
#else
	wsdisplay_console_device->sc_input = src;
#endif
	src->me_dispdv = &wsdisplay_console_device->sc_dv;
d2012 3
a2014 1
wsdisplay_cnputc(dev_t dev, int i)
a2022 1
	    (wsdisplay_console_device->sc_scr[0] != NULL) &&
a2026 1
#ifdef BURNER_SUPPORT
a2027 1
#endif
d2032 2
a2033 1
wsdisplay_getc_dummy(dev_t dev)
d2040 3
a2042 1
wsdisplay_pollc(dev_t dev, int on)
d2044 5
d2053 2
a2054 4
	if (wsdisplay_console_device != NULL &&
	    wsdisplay_console_device->sc_accessops->pollc != NULL)
		(*wsdisplay_console_device->sc_accessops->pollc)
		    (wsdisplay_console_device->sc_accesscookie, on);
d2062 4
a2065 2
wsdisplay_set_cons_kbd(int (*get)(dev_t), void (*poll)(dev_t, int),
    void (*bell)(dev_t, u_int, u_int, u_int))
d2091 1
a2091 2
		if ((scr = sc->sc_scr[0]) == NULL)
			return;
a2096 1
#ifdef SCROLLBACK_SUPPORT
d2098 3
a2100 1
wsscrollback(void *arg, int op)
a2117 1
#endif
a2118 1
#ifdef BURNER_SUPPORT
d2120 3
a2122 1
wsdisplay_burn(void *v, u_int flags)
d2137 2
a2138 1
wsdisplay_burner(void *v)
a2155 1
#endif
d2161 2
a2162 1
wsdisplay_shutdownhook(void *arg)
a2166 1
#ifdef WSMOUSED_SUPPORT
d2171 1
d2180 1
a2180 1
    int flag, struct proc *p)
d2533 1
a2533 2
    48,  48,  48,  48,  48,  48,  48,  48
};
d3156 2
a3231 1
#endif /* WSMOUSED_SUPPORT */
@


1.1.1.3
log
@merge more OpenBSD-HEAD stuff
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.61 2005/07/17 10:43:24 miod Exp $ */
d172 2
d228 1
d287 1
a287 1
		 * Tell the emulation about the callback argument.
d290 2
a291 1
		(*dconf->wsemul->attach)(1, 0, 0, 0, 0, scr, 0);
d301 7
a307 2
		if (dconf->emulops != NULL &&
		    (dconf->wsemul = wsemul_pick(emul)) != NULL) {
d311 2
a312 5
		} else {
			free(dconf, M_DEVBUF);
			free(scr, M_DEVBUF);
			return (NULL);
		}
d320 4
a323 1
	scr->scr_flags = 0;
d345 3
a347 2
	(*scr->scr_dconf->wsemul->detach)(scr->scr_dconf->wsemulcookie,
	    &ccol, &crow);
d381 6
a386 3
	printf(" added (%s, %s emulation)\n",
	    sc->sc_scr[idx]->scr_dconf->scrdata->name,
	    sc->sc_scr[idx]->scr_dconf->wsemul->name);
d790 1
a790 1
		if (newopen) {
d792 1
a792 1
			   the emulation */
d795 2
d838 9
a846 6
	scr->scr_flags &= ~SCR_GRAPHICS;
	(*scr->scr_dconf->wsemul->reset)(scr->scr_dconf->wsemulcookie,
					 WSEMUL_RESET);
	if (wsdisplay_clearonclose)
		(*scr->scr_dconf->wsemul->reset)
			(scr->scr_dconf->wsemulcookie, WSEMUL_CLEARSCREEN);
d1039 7
a1045 5
		scr->scr_flags &= ~SCR_GRAPHICS;
		if (d == WSDISPLAYIO_MODE_MAPPED ||
		    d == WSDISPLAYIO_MODE_DUMBFB) {
			scr->scr_flags |= SCR_GRAPHICS |
			    ((d == WSDISPLAYIO_MODE_DUMBFB) ?  SCR_DUMBFB : 0);
d1048 5
a1052 5
			/*
			 * wsmoused cohabitation with X-Window support
			 * X-Window is starting
			 */
			wsmoused_release(sc);
d1056 3
a1058 3
			/* disable the burner while X is running */
			if (sc->sc_burnout)
				timeout_del(&sc->sc_burner);
d1060 2
a1061 1
		} else {
d1063 3
a1065 3
			/* reenable the burner after exiting from X */
			if (!sc->sc_burnman)
				wsdisplay_burn(sc, sc->sc_burnflags);
d1069 10
a1078 7
			/*
			 * wsmoused cohabitation with X-Window support
			 * X-Window is ending
			 */
			wsmoused_wakeup(sc);
#endif
		}
d1080 1
a1080 1
		(void)(*sc->sc_accessops->ioctl)(sc->sc_accesscookie, cmd, data,
d1083 1
a1083 1
		return (0);
d1093 1
a1093 1
		if (!error)
d1355 1
d1377 1
d1490 1
a1490 1
	else {
d1795 2
@


1.1.1.4
log
@import current wscons & friends code from OpenBSD
in the hope it will be useful
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.75 2007/01/07 13:28:04 miod Exp $ */
a54 1
#include <sys/poll.h>
d64 2
a106 2

#ifdef WSDISPLAY_COMPAT_USL
a108 1
#endif
a206 1
int	wsdisplay_emul_detach(struct device *, int);
d214 1
a214 1
	    wsdisplay_emul_attach, wsdisplay_emul_detach
d231 1
a231 2
	    void *accesscookie, u_int defaultscreens);
int	wsdisplay_common_detach(struct wsdisplay_softc *, int);
d287 1
a287 1
		(void)(*dconf->wsemul->attach)(1, 0, 0, 0, 0, scr, 0);
d291 4
a294 2
		if (dconf == NULL)
			goto fail;
d297 10
a306 7
		if (dconf->emulops == NULL ||
		    (dconf->wsemul = wsemul_pick(emul)) == NULL)
			goto fail;
		dconf->wsemulcookie = (*dconf->wsemul->attach)(0, type, cookie,
		    ccol, crow, scr, defattr);
		if (dconf->wsemulcookie == NULL)
			goto fail;
d316 1
a316 4
#ifdef WSDISPLAY_COMPAT_USL
	scr->scr_syncops = NULL;
#endif

a324 6

fail:
	if (dconf != NULL)
		free(dconf, M_DEVBUF);
	free(scr, M_DEVBUF);
	return (NULL);
a490 1
#ifdef WSDISPLAY_COMPAT_USL
a491 1
#endif
d493 1
a493 1
		return (EBUSY);
d526 1
a526 2
	if ((flags & WSDISPLAY_DELSCR_QUIET) == 0)
		printf("%s: screen %d deleted\n", sc->sc_dv.dv_xname, idx);
d562 1
a562 1
	    ap->accessops, ap->accesscookie, ap->defaultscreens);
d576 1
a576 3
/*
 * Detach a display.
 */
d578 1
a578 1
wsdisplay_emul_detach(struct device *self, int flags)
d580 2
a581 26
	struct wsdisplay_softc *sc = (struct wsdisplay_softc *)self;

	return (wsdisplay_common_detach(sc, flags));
}

int
wsdisplay_common_detach(struct wsdisplay_softc *sc, int flags)
{
	int i;
	int rc;

	/* We don't support detaching the console display yet. */
	if (sc->sc_isconsole)
		return (EBUSY);

	/* Delete all screens managed by this display */
	for (i = 0; i < WSDISPLAY_MAXSCREEN; i++)
		if (sc->sc_scr[i] != NULL) {
			if ((rc = wsdisplay_delscreen(sc, i,
			    WSDISPLAY_DELSCR_QUIET | (flags & DETACH_FORCE ?
			     WSDISPLAY_DELSCR_FORCE : 0))) != 0)
				return (rc);
		}

#ifdef BURNER_SUPPORT
	timeout_del(&sc->sc_burner);
d584 4
a587 15
#if NWSKBD > 0
	if (sc->sc_input != NULL) {
#if NWSMUX > 0
		wsmux_detach_sc(sc->sc_input);	/* XXX not exactly correct */
		/*
		 * XXX
		 * If we created a standalone mux (dmux), we should destroy it
		 * there, but there is currently no support for this in wsmux.
		 */
#else
		if ((rc = wskbd_set_display((struct device *)sc->sc_input,
		    NULL)) != 0)
			return (rc);
#endif
	}
d590 1
a590 1
	return (0);
d595 1
a595 1
wsemuldisplaydevprint(void *aux, const char *pnp)
d598 1
a598 1
	struct wsemuldisplaydev_attach_args *ap = aux;
a602 3
#if 0 /* don't bother; it's ugly */
	printf(" console %d", ap->console);
#endif
d610 1
a610 2
    const struct wsdisplay_accessops *accessops, void *accesscookie,
    u_int defaultscreens)
d679 1
a679 2
	 * is for special cases like installation kernels, as well as
	 * sane multihead defaults.
d681 1
a681 3
	if (defaultscreens == 0)
		defaultscreens = wsdisplay_defaultscreens;
	for (i = start; i < defaultscreens; i++) {
a700 17

#if NWSKBD > 0 && NWSMUX == 0
	if (console == 0) {
		/*
		 * In the non-wsmux world, always connect wskbd0 and wsdisplay0
		 * together.
		 */
		extern struct cfdriver wskbd_cd;

		if (wskbd_cd.cd_ndevs != 0 && sc->sc_dv.dv_unit == 0) {
			if (wsdisplay_set_kbd(&sc->sc_dv,
			    (struct wsevsrc *)wskbd_cd.cd_devs[0]) == 0)
				wskbd_set_display(wskbd_cd.cd_devs[0],
				    &sc->sc_dv);
		}
	}
#endif
a819 1
#ifdef WSDISPLAY_COMPAT_USL
a821 1
#endif
d834 1
a834 1
		    (caddr_t)&kbmode, FWRITE, p);
a936 3
	if (WSDISPLAYSCREEN(dev) >= WSDISPLAY_MAXSCREEN)
		return (ENODEV);

d986 1
a986 3
	case WSKBDIO_SETMODE:
		if ((flag & FWRITE) == 0)
			return (EACCES);
d989 1
a989 1
	case WSKBDIO_GETMODE:
d996 5
a1000 5
	if (inp != NULL) {
		error = wsevsrc_display_ioctl(inp, cmd, data, flag, p);
		if (error >= 0)
			return (error);
	}
a1003 12
	case WSDISPLAYIO_SMODE:
	case WSDISPLAYIO_USEFONT:
#ifdef BURNER_SUPPORT
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_SBURNER:
#endif
	case WSDISPLAYIO_SETSCREEN:
		if ((flag & FWRITE) == 0)
			return (EACCES);
	}

	switch (cmd) {
d1128 1
a1128 1
#endif	/* BURNER_SUPPORT */
d1259 1
a1259 1
		return (POLLERR);
d1262 1
a1262 1
		return (POLLERR);
d1495 1
a1495 1
	error = wsevsrc_display_ioctl(inp, WSKBDIO_SETMODE, &data, FWRITE, 0);
a1512 1
#ifdef WSDISPLAY_COMPAT_USL
a1543 9
#else
	/*
	 * If we do not have syncops support, we come straight from
	 * wsdisplay_switch2 which has already validated our arguments
	 * and did not sleep.
	 */
	no = sc->sc_screenwanted;
	scr = sc->sc_scr[no];
#endif
a1595 1
#ifdef WSDISPLAY_COMPAT_USL
a1605 1
#endif
a1737 1
#ifdef WSDISPLAY_COMPAT_USL
a1750 1
#endif
a1777 1
#ifdef WSDISPLAY_COMPAT_USL
a1816 1
#endif
a1911 16

#if NWSMUX == 0
int
wsdisplay_set_kbd(struct device *disp, struct wsevsrc *kbd)
{
	struct wsdisplay_softc *sc = (struct wsdisplay_softc *)disp;

	if (sc->sc_input != NULL)
		return (EBUSY);

	sc->sc_input = kbd;

	return (0);
}
#endif

d2282 2
a2283 6
	struct wsscreen_internal *dconf;
	struct wsdisplay_charcell cell;
	int fg, bg, ul;
	int flags;
	int tmp;
	long attr;
d2285 2
a2286 1
	dconf = sc->sc_focus->scr_dconf;
d2288 2
a2289 1
	GETCHAR(pos, &cell);
d2291 3
a2293 22
	(*dconf->emulops->unpack_attr)(dconf->emulcookie, cell.attr, &fg,
	    &bg, &ul);

	/*
	 * Display the mouse cursor as a color inverted cell whenever
	 * possible. If this is not possible, ask for the video reverse
	 * attribute.
	 */
	flags = 0;
	if (dconf->scrdata->capabilities & WSSCREEN_WSCOLORS) {
		flags |= WSATTR_WSCOLORS;
		tmp = fg;
		fg = bg;
		bg = tmp;
	} else if (dconf->scrdata->capabilities & WSSCREEN_REVERSE) {
		flags |= WSATTR_REVERSE;
	}
	if ((*dconf->emulops->alloc_attr)(dconf->emulcookie, fg, bg, flags |
	    (ul ? WSATTR_UNDERLINE : 0), &attr) == 0) {
		cell.attr = attr;
		PUTCHAR(pos, cell.uc, cell.attr);
	}
a2318 1
	struct wsdisplay_charcell cell;
d2324 1
a2324 2
	while (GETCHAR(current, &cell) == 0 && cell.uc == ' ' &&
	    current <= limit) {
a2347 1
	struct wsdisplay_charcell cell;
d2353 1
a2353 2
	while (GETCHAR(current, &cell) == 0 && cell.uc == ' ' &&
	    current >= limit) {
a2439 1
	struct wsdisplay_charcell cell;
d2442 1
a2442 1
	unsigned char class;
d2445 2
a2446 4
	GETCHAR(current, &cell);
	class = charClass[cell.uc & 0xff];
	while (GETCHAR(current, &cell) == 0 &&
	    charClass[cell.uc & 0xff] == class && current <= limit) {
a2460 1
	struct wsdisplay_charcell cell;
d2463 1
a2463 1
	unsigned char class;
d2466 1
a2466 4
	GETCHAR(current, &cell);
	class = charClass[cell.uc & 0xff];
	while (GETCHAR(current, &cell) == 0 &&
	    charClass[cell.uc & 0xff] == class && current >= limit) {
a2480 1
	struct wsdisplay_charcell cell;
d2484 2
a2485 6
	if (GETCHAR(first, &cell) != 0)
		return (1);
	first_class = charClass[cell.uc & 0xff];
	if (GETCHAR(second, &cell) != 0)
		return (1);
	second_class = charClass[cell.uc & 0xff];
a2537 1
	struct wsdisplay_charcell cell;
d2550 1
a2550 1
	if (GETCHAR(MOUSE, &cell) == 0 && IS_ALPHANUM(cell.uc)) {
a2952 1
	struct wsdisplay_charcell cell;
d2963 1
a2963 3
		if (GETCHAR(sel_cur, &cell) != 0)
			break;
		Copybuffer[current] = cell.uc;
d3100 1
a3100 1
			if (minor(sc->wsmoused_dev) < wsmouse_cd.cd_ndevs) {
@


