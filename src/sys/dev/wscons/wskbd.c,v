head	1.9;
access;
symbols
	tg-beforemerge-ksrc10:1.1.1.8
	MIRBSD_10:1.9.0.2
	MIRBSD_10_BASE:1.9
	cvs-200702062030:1.1.1.7
	MIRBSD_9_BASE:1.6
	MIRBSD_8:1.5.0.2
	MIRBSD_8_BASE:1.5
	cvs-200507032030:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2007.02.06.22.29.15;	author tg;	state Exp;
branches;
next	1.8;
commitid	10045C9014B756877EE;

1.8
date	2007.02.06.22.27.25;	author tg;	state Exp;
branches;
next	1.7;
commitid	10045C900E4417D3AC6;

1.7
date	2007.02.06.20.54.51;	author tg;	state Exp;
branches;
next	1.6;
commitid	10045C8EB2F4CD8021C;

1.6
date	2006.05.25.12.20.26;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004475A0E83E9B8F47;

1.5
date	2005.07.21.21.52.21;	author tg;	state Exp;
branches;
next	1.4;
commitid	181c42e0191f67ef;

1.4
date	2005.07.04.03.36.33;	author tg;	state Exp;
branches;
next	1.3;
commitid	27eb42c8ae53acb0;

1.3
date	2005.07.04.01.15.48;	author tg;	state Exp;
branches;
next	1.2;
commitid	529442c88dcc63a0;

1.2
date	2005.05.13.06.46.33;	author tg;	state Exp;
branches;
next	1.1;
commitid	5bc442844d55aa0f;

1.1
date	2005.02.05.17.28.46;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.28.46;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.07.04.01.13.58;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	76bf42c88d6bc5d8;

1.1.1.3
date	2005.07.04.02.34.29;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	68bb42c8a04988a4;

1.1.1.4
date	2005.07.04.02.38.16;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	2f5642c8a12ea6cd;

1.1.1.5
date	2005.07.04.02.39.43;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	741842c8a185ec98;

1.1.1.6
date	2005.07.21.21.39.45;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	5f0d42e015f52f66;

1.1.1.7
date	2007.02.06.20.51.56;	author tg;	state Exp;
branches;
next	1.1.1.8;
commitid	10045C8EA6658CBB47A;

1.1.1.8
date	2007.02.06.22.27.00;	author tg;	state Exp;
branches;
next	;
commitid	10045C900CB406A880B;


desc
@@


1.9
log
@it must be WSDISPLAY_SCROLLBACK_SUPPORT not SCROLLBACK_SUPPORT, oops
@
text
@/* $MirOS: src/sys/dev/wscons/wskbd.c,v 1.8 2007/02/06 22:27:25 tg Exp $ */
/* $OpenBSD: wskbd.c,v 1.53 2006/08/14 17:41:08 miod Exp $ */
/* $NetBSD: wskbd.c,v 1.80 2005/05/04 01:52:16 augustss Exp $ */

/*
 * Copyright (c) 1996, 1997 Christopher G. Demetriou.  All rights reserved.
 *
 * Keysym translator:
 * Contributed to The NetBSD Foundation by Juergen Hannken-Illjes.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christopher G. Demetriou
 *	for the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)kbd.c	8.2 (Berkeley) 10/30/93
 */

/*
 * Keyboard driver (/dev/wskbd*).  Translates incoming bytes to ASCII or
 * to `wscons_events' and passes them up to the appropriate reader.
 */

#include <sys/param.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/syslog.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <sys/malloc.h>
#include <sys/tty.h>
#include <sys/signalvar.h>
#include <sys/errno.h>
#include <sys/fcntl.h>
#include <sys/vnode.h>

#include <ddb/db_var.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wskbdvar.h>
#include <dev/wscons/wsksymdef.h>
#include <dev/wscons/wsksymvar.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wseventvar.h>
#include <dev/wscons/wscons_callbacks.h>

#include "audio.h"		/* NAUDIO (mixer tuning) */
#include "wsdisplay.h"
#include "wskbd.h"
#include "wsmux.h"

#ifdef	SMALL_KERNEL
#undef	NWSKBD_HOTKEY
#define	NWSKBD_HOTKEY 0
#else
#define	BURNER_SUPPORT
#define	WSDISPLAY_SCROLLBACK_SUPPORT
#endif

#ifdef WSKBD_DEBUG
#define DPRINTF(x)	if (wskbddebug) printf x
int	wskbddebug = 0;
#else
#define DPRINTF(x)
#endif

#include <dev/wscons/wsmuxvar.h>

struct wskbd_internal {
	const struct wskbd_mapdata *t_keymap;

	const struct wskbd_consops *t_consops;
	void	*t_consaccesscookie;

	int	t_modifiers;
	int	t_composelen;		/* remaining entries in t_composebuf */
	keysym_t t_composebuf[2];

	int	t_flags;
#define WSKFL_METAESC 1

#define MAXKEYSYMSPERKEY 2 /* ESC <key> at max */
	keysym_t t_symbols[MAXKEYSYMSPERKEY];

	struct wskbd_softc *t_sc;	/* back pointer */
};

struct wskbd_softc {
	struct wsevsrc	sc_base;

	struct wskbd_internal *id;

	const struct wskbd_accessops *sc_accessops;
	void *sc_accesscookie;

	int	sc_ledstate;

	int	sc_isconsole;

	struct wskbd_bell_data sc_bell_data;
	struct wskbd_keyrepeat_data sc_keyrepeat_data;

	int	sc_repeating;		/* we've called timeout() */
	int	sc_repkey;
	struct timeout sc_repeat_ch;
	u_int	sc_repeat_type;
	int	sc_repeat_value;

	int	sc_translating;		/* xlate to chars for emulation */

	int	sc_maplen;		/* number of entries in sc_map */
	struct wscons_keymap *sc_map;	/* current translation map */
	kbd_t	sc_layout; /* current layout */

	int	sc_refcnt;
	u_char	sc_dying;		/* device is being detached */
};

#define MOD_SHIFT_L		(1 << 0)
#define MOD_SHIFT_R		(1 << 1)
#define MOD_SHIFTLOCK		(1 << 2)
#define MOD_CAPSLOCK		(1 << 3)
#define MOD_CONTROL_L		(1 << 4)
#define MOD_CONTROL_R		(1 << 5)
#define MOD_META_L		(1 << 6)
#define MOD_META_R		(1 << 7)
#define MOD_MODESHIFT		(1 << 8)
#define MOD_NUMLOCK		(1 << 9)
#define MOD_COMPOSE		(1 << 10)
#define MOD_HOLDSCREEN		(1 << 11)
#define MOD_COMMAND		(1 << 12)
#define MOD_COMMAND1		(1 << 13)
#define MOD_COMMAND2		(1 << 14)
#define MOD_MODELOCK		(1 << 15)

#define MOD_ANYSHIFT		(MOD_SHIFT_L | MOD_SHIFT_R | MOD_SHIFTLOCK)
#define MOD_ANYCONTROL		(MOD_CONTROL_L | MOD_CONTROL_R)
#define MOD_ANYMETA		(MOD_META_L | MOD_META_R)

#define MOD_ONESET(id, mask)	(((id)->t_modifiers & (mask)) != 0)
#define MOD_ALLSET(id, mask)	(((id)->t_modifiers & (mask)) == (mask))

keysym_t ksym_upcase(keysym_t);

int	wskbd_match(struct device *, void *, void *);
void	wskbd_attach(struct device *, struct device *, void *);
int	wskbd_detach(struct device *, int);
int	wskbd_activate(struct device *, enum devact);

int	wskbd_displayioctl(struct device *, u_long, caddr_t, int, struct proc *);

void	update_leds(struct wskbd_internal *);
void	update_modifier(struct wskbd_internal *, u_int, int, int);
int	internal_command(struct wskbd_softc *, u_int *, keysym_t, keysym_t);
int	wskbd_translate(struct wskbd_internal *, u_int, int);
int	wskbd_enable(struct wskbd_softc *, int);
#if NWSDISPLAY > 0
void	change_displayparam(struct wskbd_softc *, int, int, int);
void	wskbd_holdscreen(struct wskbd_softc *, int);
#endif

int	wskbd_do_ioctl_sc(struct wskbd_softc *, u_long, caddr_t, int,
	    struct proc *);
void	wskbd_deliver_event(struct wskbd_softc *sc, u_int type, int value);

#if NWSMUX > 0
int	wskbd_mux_open(struct wsevsrc *, struct wseventvar *);
int	wskbd_mux_close(struct wsevsrc *);
#else
#define	wskbd_mux_open NULL
#define	wskbd_mux_close NULL
#endif

int	wskbd_do_open(struct wskbd_softc *, struct wseventvar *);
int	wskbd_do_ioctl(struct device *, u_long, caddr_t, int, struct proc *);

struct cfdriver wskbd_cd = {
	NULL, "wskbd", DV_TTY
};

struct cfattach wskbd_ca = {
	sizeof (struct wskbd_softc), wskbd_match, wskbd_attach,
	wskbd_detach, wskbd_activate
};

extern int kbd_reset;

#ifndef WSKBD_DEFAULT_BELL_PITCH
#define	WSKBD_DEFAULT_BELL_PITCH	400	/* 400Hz */
#endif
#ifndef WSKBD_DEFAULT_BELL_PERIOD
#define	WSKBD_DEFAULT_BELL_PERIOD	100	/* 100ms */
#endif
#ifndef WSKBD_DEFAULT_BELL_VOLUME
#define	WSKBD_DEFAULT_BELL_VOLUME	50	/* 50% volume */
#endif

struct wskbd_bell_data wskbd_default_bell_data = {
	WSKBD_BELL_DOALL,
	WSKBD_DEFAULT_BELL_PITCH,
	WSKBD_DEFAULT_BELL_PERIOD,
	WSKBD_DEFAULT_BELL_VOLUME,
};

#ifndef WSKBD_DEFAULT_KEYREPEAT_DEL1
#define	WSKBD_DEFAULT_KEYREPEAT_DEL1	400	/* 400ms to start repeating */
#endif
#ifndef WSKBD_DEFAULT_KEYREPEAT_DELN
#define	WSKBD_DEFAULT_KEYREPEAT_DELN	100	/* 100ms to between repeats */
#endif

struct wskbd_keyrepeat_data wskbd_default_keyrepeat_data = {
	WSKBD_KEYREPEAT_DOALL,
	WSKBD_DEFAULT_KEYREPEAT_DEL1,
	WSKBD_DEFAULT_KEYREPEAT_DELN,
};

#if NWSMUX > 0 || NWSDISPLAY > 0
struct wssrcops wskbd_srcops = {
	WSMUX_KBD,
	wskbd_mux_open, wskbd_mux_close, wskbd_do_ioctl,
	wskbd_displayioctl,
#if NWSDISPLAY > 0
	wskbd_set_display
#else
	NULL
#endif
};
#endif

#if NWSDISPLAY > 0
void wskbd_repeat(void *v);
#endif

static int wskbd_console_initted;
static struct wskbd_softc *wskbd_console_device;
static struct wskbd_internal wskbd_console_data;

void	wskbd_update_layout(struct wskbd_internal *, kbd_t);

void
wskbd_update_layout(struct wskbd_internal *id, kbd_t enc)
{
	if (enc & KB_METAESC)
		id->t_flags |= WSKFL_METAESC;
	else
		id->t_flags &= ~WSKFL_METAESC;
}

/*
 * Print function (for parent devices).
 */
int
wskbddevprint(void *aux, const char *pnp)
{
#if 0
	struct wskbddev_attach_args *ap = aux;
#endif

	if (pnp)
		printf("wskbd at %s", pnp);
#if 0
	printf(" console %d", ap->console);
#endif

	return (UNCONF);
}

int
wskbd_match(struct device *parent, void *match, void *aux)
{
	struct cfdata *cf = match;
	struct wskbddev_attach_args *ap = aux;

	if (cf->wskbddevcf_console != WSKBDDEVCF_CONSOLE_UNK) {
		/*
		 * If console-ness of device specified, either match
		 * exactly (at high priority), or fail.
		 */
		if (cf->wskbddevcf_console != 0 && ap->console != 0)
			return (10);
		else
			return (0);
	}

	/* If console-ness unspecified, it wins. */
	return (1);
}

void
wskbd_attach(struct device *parent, struct device *self, void *aux)
{
	struct wskbd_softc *sc = (struct wskbd_softc *)self;
	struct wskbddev_attach_args *ap = aux;
#if NWSMUX > 0
	int mux, error;
#endif

	sc->sc_isconsole = ap->console;

#if NWSMUX > 0 || NWSDISPLAY > 0
	sc->sc_base.me_ops = &wskbd_srcops;
#endif
#if NWSMUX > 0
	mux = sc->sc_base.me_dv.dv_cfdata->wskbddevcf_mux;
	if (ap->console) {
		/* Ignore mux for console; it always goes to the console mux. */
		/* printf(" (mux %d ignored for console)", mux); */
		mux = -1;
	}
	if (mux >= 0)
		printf(" mux %d", mux);
#else
#if 0	/* not worth keeping, especially since the default value is not -1... */
	if (sc->sc_base.me_dv.dv_cfdata->wskbddevcf_mux >= 0)
		printf(" (mux ignored)");
#endif
#endif	/* NWSMUX > 0 */

	if (ap->console) {
		sc->id = &wskbd_console_data;
	} else {
		sc->id = malloc(sizeof(struct wskbd_internal),
		    M_DEVBUF, M_WAITOK);
		bzero(sc->id, sizeof(struct wskbd_internal));
		sc->id->t_keymap = ap->keymap;
		wskbd_update_layout(sc->id, ap->keymap->layout);
	}

#if NWSDISPLAY > 0
	timeout_set(&sc->sc_repeat_ch, wskbd_repeat, sc);
#endif

	sc->id->t_sc = sc;

	sc->sc_accessops = ap->accessops;
	sc->sc_accesscookie = ap->accesscookie;
	sc->sc_repeating = 0;
	sc->sc_translating = 1;
	sc->sc_ledstate = -1; /* force update */

	if (wskbd_load_keymap(sc->id->t_keymap,
	    &sc->sc_map, &sc->sc_maplen) != 0)
		panic("cannot load keymap");

	sc->sc_layout = sc->id->t_keymap->layout;

	/* set default bell and key repeat data */
	sc->sc_bell_data = wskbd_default_bell_data;
	sc->sc_keyrepeat_data = wskbd_default_keyrepeat_data;

	if (ap->console) {
		KASSERT(wskbd_console_initted); 
		KASSERT(wskbd_console_device == NULL);

		wskbd_console_device = sc;

		printf(": console keyboard");

#if NWSDISPLAY > 0
		wsdisplay_set_console_kbd(&sc->sc_base); /* sets me_dispdv */
		if (sc->sc_displaydv != NULL)
			printf(", using %s", sc->sc_displaydv->dv_xname);
#endif
	}
	printf("\n");

#if NWSMUX > 0
	if (mux >= 0) {
		error = wsmux_attach_sc(wsmux_getmux(mux), &sc->sc_base);
		if (error)
			printf("%s: attach error=%d\n",
			    sc->sc_base.me_dv.dv_xname, error);
	}
#endif

#if WSDISPLAY > 0 && NWSMUX == 0
	if (ap->console == 0) {
		/*
		 * In the non-wsmux world, always connect wskbd0 and wsdisplay0
		 * together.
		 */
		extern struct cfdriver wsdisplay_cd;

		if (wsdisplay_cd.cd_ndevs != 0 && self->dv_unit == 0) {
			if (wskbd_set_display(self,
			    wsdisplay_cd.cd_devs[0]) == 0)
				wsdisplay_set_kbd(wsdisplay_cd.cd_devs[0],
				    (struct wsevsrc *)sc);
		}
	}
#endif

#if NWSKBD_HOTKEY > 0
	wskbd_hotkey_init();
#endif
}

void    
wskbd_cnattach(const struct wskbd_consops *consops, void *conscookie,
    const struct wskbd_mapdata *mapdata)
{

	KASSERT(!wskbd_console_initted);

	wskbd_console_data.t_keymap = mapdata;
	wskbd_update_layout(&wskbd_console_data, mapdata->layout);

	wskbd_console_data.t_consops = consops;
	wskbd_console_data.t_consaccesscookie = conscookie;

#if NWSDISPLAY > 0
	wsdisplay_set_cons_kbd(wskbd_cngetc, wskbd_cnpollc, wskbd_cnbell);
#endif

	wskbd_console_initted = 1;
}

void    
wskbd_cndetach()
{
	KASSERT(wskbd_console_initted);

	wskbd_console_data.t_keymap = 0;

	wskbd_console_data.t_consops = 0;
	wskbd_console_data.t_consaccesscookie = 0;

#if NWSDISPLAY > 0
	wsdisplay_unset_cons_kbd();
#endif

	wskbd_console_initted = 0;
}

#if NWSDISPLAY > 0
void
wskbd_repeat(void *v)
{
	struct wskbd_softc *sc = (struct wskbd_softc *)v;
	int s = spltty();

	if (!sc->sc_repeating) {
		/*
		 * race condition: a "key up" event came in when wskbd_repeat()
		 * was already called but not yet spltty()'d
		 */
		splx(s);
		return;
	}
	if (sc->sc_translating) {
		/* deliver keys */
		if (sc->sc_base.me_dispdv != NULL) {
			int i;
			for (i = 0; i < sc->sc_repeating; i++)
				wsdisplay_kbdinput(sc->sc_base.me_dispdv,
				    sc->id->t_symbols[i]);
		}
	} else {
		/* queue event */
		wskbd_deliver_event(sc, sc->sc_repeat_type,
		    sc->sc_repeat_value);
	}
	if (sc->sc_keyrepeat_data.delN != 0)
		timeout_add(&sc->sc_repeat_ch,
		    (hz * sc->sc_keyrepeat_data.delN) / 1000);
	splx(s);
}
#endif

int
wskbd_activate(struct device *self, enum devact act)
{
	struct wskbd_softc *sc = (struct wskbd_softc *)self;

	if (act == DVACT_DEACTIVATE)
		sc->sc_dying = 1;
	return (0);
}

/*
 * Detach a keyboard.  To keep track of users of the softc we keep
 * a reference count that's incremented while inside, e.g., read.
 * If the keyboard is active and the reference count is > 0 (0 is the
 * normal state) we post an event and then wait for the process
 * that had the reference to wake us up again.  Then we blow away the
 * vnode and return (which will deallocate the softc).
 */
int
wskbd_detach(struct device  *self, int flags)
{
	struct wskbd_softc *sc = (struct wskbd_softc *)self;
	struct wseventvar *evar;
	int maj, mn;
	int s;

#if NWSMUX > 0
	/* Tell parent mux we're leaving. */
	if (sc->sc_base.me_parent != NULL)
		wsmux_detach_sc(&sc->sc_base);
#endif

#if NWSDISPLAY > 0
	if (sc->sc_repeating) {
		sc->sc_repeating = 0;
		timeout_del(&sc->sc_repeat_ch);
	}
#endif

	if (sc->sc_isconsole) {
		KASSERT(wskbd_console_device == sc);
		wskbd_console_device = NULL;
	}

	evar = sc->sc_base.me_evp;
	if (evar != NULL && evar->io != NULL) {
		s = spltty();
		if (--sc->sc_refcnt >= 0) {
			/* Wake everyone by generating a dummy event. */
			if (++evar->put >= WSEVENT_QSIZE)
				evar->put = 0;
			WSEVENT_WAKEUP(evar);
			/* Wait for processes to go away. */
			if (tsleep(sc, PZERO, "wskdet", hz * 60))
				printf("wskbd_detach: %s didn't detach\n",
				       sc->sc_base.me_dv.dv_xname);
		}
		splx(s);
	}

	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == wskbdopen)
			break;

	/* Nuke the vnodes for any open instances. */
	mn = self->dv_unit;
	vdevgone(maj, mn, mn, VCHR);

	return (0);
}

void
wskbd_input(struct device *dev, u_int type, int value)
{
	struct wskbd_softc *sc = (struct wskbd_softc *)dev; 
#if NWSDISPLAY > 0
	int num, i;
#endif

#if NWSDISPLAY > 0
	if (sc->sc_repeating) {
		sc->sc_repeating = 0;
		timeout_del(&sc->sc_repeat_ch);
	}

	/*
	 * If /dev/wskbdN is not connected in event mode translate and
	 * send upstream.
	 */
	if (sc->sc_translating) {
#ifdef BURNER_SUPPORT
		if (type == WSCONS_EVENT_KEY_DOWN && sc->sc_displaydv != NULL)
			wsdisplay_burn(sc->sc_displaydv, WSDISPLAY_BURN_KBD);
#endif
		num = wskbd_translate(sc->id, type, value);
		if (num > 0) {
			if (sc->sc_base.me_dispdv != NULL) {
#ifdef WSDISPLAY_SCROLLBACK_SUPPORT
				/* XXX - Shift_R+PGUP(release) emits PrtSc */
				if (sc->id->t_symbols[0] != KS_Print_Screen) {
					wsscrollback(sc->sc_base.me_dispdv,
					    WSDISPLAY_SCROLL_RESET);
				}
#endif
				for (i = 0; i < num; i++) {
					wsdisplay_kbdinput(sc->sc_base.me_dispdv,
					    sc->id->t_symbols[i]);
				}
			}

			if (sc->sc_keyrepeat_data.del1 != 0) {
				sc->sc_repeating = num;
				timeout_add(&sc->sc_repeat_ch,
				    (hz * sc->sc_keyrepeat_data.del1) / 1000);
			}
		}
		return;
	}
#endif

	wskbd_deliver_event(sc, type, value);

#if NWSDISPLAY > 0
	/* Repeat key presses if enabled. */
	if (type == WSCONS_EVENT_KEY_DOWN && sc->sc_keyrepeat_data.del1 != 0) {
		sc->sc_repeat_type = type;
		sc->sc_repeat_value = value;
		sc->sc_repeating = 1;
		timeout_add(&sc->sc_repeat_ch,
		    (hz * sc->sc_keyrepeat_data.del1) / 1000);
	}
#endif
}

/*
 * Keyboard is generating events.  Turn this keystroke into an
 * event and put it in the queue.  If the queue is full, the
 * keystroke is lost (sorry!).
 */
void
wskbd_deliver_event(struct wskbd_softc *sc, u_int type, int value)
{
	struct wseventvar *evar;
	struct wscons_event *ev;
	struct timeval xxxtime;
	int put;

	evar = sc->sc_base.me_evp;

	if (evar == NULL) {
		DPRINTF(("wskbd_input: not open\n"));
		return;
	}

#ifdef DIAGNOSTIC
	if (evar->q == NULL) {
		printf("wskbd_input: evar->q=NULL\n");
		return;
	}
#endif

	put = evar->put;
	ev = &evar->q[put];
	put = (put + 1) % WSEVENT_QSIZE;
	if (put == evar->get) {
		log(LOG_WARNING, "%s: event queue overflow\n",
		    sc->sc_base.me_dv.dv_xname);
		return;
	}
	ev->type = type;
	ev->value = value;
	microtime(&xxxtime);
	TIMEVAL_TO_TIMESPEC(&xxxtime, &ev->time);
	evar->put = put;
	WSEVENT_WAKEUP(evar);
}

#ifdef WSDISPLAY_COMPAT_RAWKBD
void
wskbd_rawinput(struct device *dev, u_char *buf, int len)
{
#if NWSDISPLAY > 0
	struct wskbd_softc *sc = (struct wskbd_softc *)dev;
	int i;

	if (sc->sc_base.me_dispdv != NULL)
		for (i = 0; i < len; i++)
			wsdisplay_kbdinput(sc->sc_base.me_dispdv, buf[i]);
	/* this is KS_GROUP_Ascii */
#endif
}
#endif /* WSDISPLAY_COMPAT_RAWKBD */

#if NWSDISPLAY > 0
void
wskbd_holdscreen(struct wskbd_softc *sc, int hold)
{
	int new_state;

	if (sc->sc_base.me_dispdv != NULL) {
		wsdisplay_kbdholdscreen(sc->sc_base.me_dispdv, hold);
		new_state = sc->sc_ledstate;
		if (hold)
			new_state |= WSKBD_LED_SCROLL;
		else
			new_state &= ~WSKBD_LED_SCROLL;
		if (new_state != sc->sc_ledstate) {
			(*sc->sc_accessops->set_leds)(sc->sc_accesscookie,
						      new_state);
			sc->sc_ledstate = new_state;
		}
	}
}
#endif

int
wskbd_enable(struct wskbd_softc *sc, int on)
{
	int error;

#if NWSDISPLAY > 0
	if (sc->sc_base.me_dispdv != NULL)
		return (0);

	/* Always cancel auto repeat when fiddling with the kbd. */
	if (sc->sc_repeating) {
		sc->sc_repeating = 0;
		timeout_del(&sc->sc_repeat_ch);
	}
#endif

	error = (*sc->sc_accessops->enable)(sc->sc_accesscookie, on);
	DPRINTF(("wskbd_enable: sc=%p on=%d res=%d\n", sc, on, error));
	return (error);
}

#if NWSMUX > 0
int
wskbd_mux_open(struct wsevsrc *me, struct wseventvar *evp)
{
	struct wskbd_softc *sc = (struct wskbd_softc *)me;

	if (sc->sc_dying)
		return (EIO);

	if (sc->sc_base.me_evp != NULL)
		return (EBUSY);

	return (wskbd_do_open(sc, evp));
}
#endif

int
wskbdopen(dev_t dev, int flags, int mode, struct proc *p)
{
	struct wskbd_softc *sc;
	struct wseventvar *evar;
	int unit, error;

	unit = minor(dev);
	if (unit >= wskbd_cd.cd_ndevs ||	/* make sure it was attached */
	    (sc = wskbd_cd.cd_devs[unit]) == NULL)
		return (ENXIO);

#if NWSMUX > 0
	DPRINTF(("wskbdopen: %s mux=%p p=%p\n", sc->sc_base.me_dv.dv_xname,
		 sc->sc_base.me_parent, p));
#endif

	if (sc->sc_dying)
		return (EIO);

	if ((flags & (FREAD | FWRITE)) == FWRITE) {
		/* Not opening for read, only ioctl is available. */
		return (0);
	}

#if NWSMUX > 0
	if (sc->sc_base.me_parent != NULL) {
		/* Grab the keyboard out of the greedy hands of the mux. */
		DPRINTF(("wskbdopen: detach\n"));
		wsmux_detach_sc(&sc->sc_base);
	}
#endif

	if (sc->sc_base.me_evp != NULL)
		return (EBUSY);

	evar = &sc->sc_base.me_evar;
	wsevent_init(evar);
	evar->io = p;

	error = wskbd_do_open(sc, evar);
	if (error) {
		DPRINTF(("wskbdopen: %s open failed\n",
			 sc->sc_base.me_dv.dv_xname));
		sc->sc_base.me_evp = NULL;
		wsevent_fini(evar);
	}
	return (error);
}

int
wskbd_do_open(struct wskbd_softc *sc, struct wseventvar *evp)
{
	sc->sc_base.me_evp = evp;
	sc->sc_translating = 0;

	return (wskbd_enable(sc, 1));
}

int
wskbdclose(dev_t dev, int flags, int mode, struct proc *p)
{
	struct wskbd_softc *sc =
	    (struct wskbd_softc *)wskbd_cd.cd_devs[minor(dev)];
	struct wseventvar *evar = sc->sc_base.me_evp;

	if (evar == NULL)
		/* not open for read */
		return (0);

	sc->sc_base.me_evp = NULL;
	sc->sc_translating = 1;
	(void)wskbd_enable(sc, 0);
	wsevent_fini(evar);

	return (0);
}

#if NWSMUX > 0
int
wskbd_mux_close(struct wsevsrc *me)
{
	struct wskbd_softc *sc = (struct wskbd_softc *)me;

	sc->sc_base.me_evp = NULL;
	sc->sc_translating = 1;
	(void)wskbd_enable(sc, 0);

	return (0);
}
#endif

int
wskbdread(dev_t dev, struct uio *uio, int flags)
{
	struct wskbd_softc *sc = wskbd_cd.cd_devs[minor(dev)];
	int error;

	if (sc->sc_dying)
		return (EIO);

#ifdef DIAGNOSTIC
	if (sc->sc_base.me_evp == NULL) {
		printf("wskbdread: evp == NULL\n");
		return (EINVAL);
	}
#endif

	sc->sc_refcnt++;
	error = wsevent_read(&sc->sc_base.me_evar, uio, flags);
	if (--sc->sc_refcnt < 0) {
		wakeup(sc);
		error = EIO;
	}
	return (error);
}

int
wskbdioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	return (wskbd_do_ioctl(wskbd_cd.cd_devs[minor(dev)], cmd, data, flag,p));
}

/* A wrapper around the ioctl() workhorse to make reference counting easy. */
int
wskbd_do_ioctl(struct device *dv, u_long cmd, caddr_t data, int flag,
    struct proc *p)
{
	struct wskbd_softc *sc = (struct wskbd_softc *)dv;
	int error;

	sc->sc_refcnt++;
	error = wskbd_do_ioctl_sc(sc, cmd, data, flag, p);
	if (--sc->sc_refcnt < 0)
		wakeup(sc);
	return (error);
}

int
wskbd_do_ioctl_sc(struct wskbd_softc *sc, u_long cmd, caddr_t data, int flag,
     struct proc *p)
{
	int error;

	/*      
	 * Try the generic ioctls that the wskbd interface supports.
	 */
	switch (cmd) {
	case FIONBIO:		/* we will remove this someday (soon???) */
		return (0);

	case FIOASYNC:
		if (sc->sc_base.me_evp == NULL)
			return (EINVAL);
		sc->sc_base.me_evp->async = *(int *)data != 0;
		return (0);

	case FIOSETOWN:
		if (sc->sc_base.me_evp == NULL)
			return (EINVAL);
		if (-*(int *)data != sc->sc_base.me_evp->io->p_pgid &&
		    *(int *)data != sc->sc_base.me_evp->io->p_pid)
			return (EPERM);
		return (0);
		   
	case TIOCSPGRP:
		if (sc->sc_base.me_evp == NULL)
			return (EINVAL);
		if (*(int *)data != sc->sc_base.me_evp->io->p_pgid)
			return (EPERM);
		return (0);
	}

	/*
	 * Try the keyboard driver for WSKBDIO ioctls.  It returns -1
	 * if it didn't recognize the request.
	 */
	error = wskbd_displayioctl(&sc->sc_base.me_dv, cmd, data, flag, p);
	return (error != -1 ? error : ENOTTY);
}

/*
 * WSKBDIO ioctls, handled in both emulation mode and in ``raw'' mode.
 * Some of these have no real effect in raw mode, however.
 */
int
wskbd_displayioctl(struct device *dev, u_long cmd, caddr_t data, int flag,
    struct proc *p)
{
	struct wskbd_softc *sc = (struct wskbd_softc *)dev;
	struct wskbd_bell_data *ubdp, *kbdp;
	struct wskbd_keyrepeat_data *ukdp, *kkdp;
	struct wskbd_map_data *umdp;
	struct wskbd_mapdata md;
	kbd_t enc;
	void *buf;
	int len, error;

	switch (cmd) {
	case WSKBDIO_BELL:
	case WSKBDIO_COMPLEXBELL:
	case WSKBDIO_SETBELL:
	case WSKBDIO_SETKEYREPEAT:
	case WSKBDIO_SETDEFAULTKEYREPEAT:
	case WSKBDIO_SETMAP:
	case WSKBDIO_SETENCODING:
		if ((flag & FWRITE) == 0)
			return (EACCES);
	}

	switch (cmd) {
#define	SETBELL(dstp, srcp, dfltp)					\
    do {								\
	(dstp)->pitch = ((srcp)->which & WSKBD_BELL_DOPITCH) ?		\
	    (srcp)->pitch : (dfltp)->pitch;				\
	(dstp)->period = ((srcp)->which & WSKBD_BELL_DOPERIOD) ?	\
	    (srcp)->period : (dfltp)->period;				\
	(dstp)->volume = ((srcp)->which & WSKBD_BELL_DOVOLUME) ?	\
	    (srcp)->volume : (dfltp)->volume;				\
	(dstp)->which = WSKBD_BELL_DOALL;				\
    } while (0)

	case WSKBDIO_BELL:
		return ((*sc->sc_accessops->ioctl)(sc->sc_accesscookie,
		    WSKBDIO_COMPLEXBELL, (caddr_t)&sc->sc_bell_data, flag, p));

	case WSKBDIO_COMPLEXBELL:
		ubdp = (struct wskbd_bell_data *)data;
		SETBELL(ubdp, ubdp, &sc->sc_bell_data);
		return ((*sc->sc_accessops->ioctl)(sc->sc_accesscookie,
		    WSKBDIO_COMPLEXBELL, (caddr_t)ubdp, flag, p));

	case WSKBDIO_SETBELL:
		kbdp = &sc->sc_bell_data;
setbell:
		ubdp = (struct wskbd_bell_data *)data;
		SETBELL(kbdp, ubdp, kbdp);
		return (0);

	case WSKBDIO_GETBELL:
		kbdp = &sc->sc_bell_data;
getbell:
		ubdp = (struct wskbd_bell_data *)data;
		SETBELL(ubdp, kbdp, kbdp);
		return (0);

	case WSKBDIO_SETDEFAULTBELL:
		if ((error = suser(p, 0)) != 0)
			return (error);
		kbdp = &wskbd_default_bell_data;
		goto setbell;


	case WSKBDIO_GETDEFAULTBELL:
		kbdp = &wskbd_default_bell_data;
		goto getbell;

#undef SETBELL

#define	SETKEYREPEAT(dstp, srcp, dfltp)					\
    do {								\
	(dstp)->del1 = ((srcp)->which & WSKBD_KEYREPEAT_DODEL1) ?	\
	    (srcp)->del1 : (dfltp)->del1;				\
	(dstp)->delN = ((srcp)->which & WSKBD_KEYREPEAT_DODELN) ?	\
	    (srcp)->delN : (dfltp)->delN;				\
	(dstp)->which = WSKBD_KEYREPEAT_DOALL;				\
    } while (0)

	case WSKBDIO_SETKEYREPEAT:
		kkdp = &sc->sc_keyrepeat_data;
setkeyrepeat:
		ukdp = (struct wskbd_keyrepeat_data *)data;
		SETKEYREPEAT(kkdp, ukdp, kkdp);
		return (0);

	case WSKBDIO_GETKEYREPEAT:
		kkdp = &sc->sc_keyrepeat_data;
getkeyrepeat:
		ukdp = (struct wskbd_keyrepeat_data *)data;
		SETKEYREPEAT(ukdp, kkdp, kkdp);
		return (0);

	case WSKBDIO_SETDEFAULTKEYREPEAT:
		if ((error = suser(p, 0)) != 0)
			return (error);
		kkdp = &wskbd_default_keyrepeat_data;
		goto setkeyrepeat;


	case WSKBDIO_GETDEFAULTKEYREPEAT:
		kkdp = &wskbd_default_keyrepeat_data;
		goto getkeyrepeat;

#undef SETKEYREPEAT

	case WSKBDIO_SETMAP:
		umdp = (struct wskbd_map_data *)data;
		if (umdp->maplen > WSKBDIO_MAXMAPLEN)
			return (EINVAL);

		len = umdp->maplen * sizeof(struct wscons_keymap);
		buf = malloc(len, M_TEMP, M_WAITOK);
		error = copyin(umdp->map, buf, len);
		if (error == 0) {
			wskbd_init_keymap(umdp->maplen,
					  &sc->sc_map, &sc->sc_maplen);
			memcpy(sc->sc_map, buf, len);
			/* drop the variant bits handled by the map */
			sc->sc_layout = KB_USER |
			      (KB_VARIANT(sc->sc_layout) & KB_HANDLEDBYWSKBD);
			wskbd_update_layout(sc->id, sc->sc_layout);
		}
		free(buf, M_TEMP);
		return(error);

	case WSKBDIO_GETMAP:
		umdp = (struct wskbd_map_data *)data;
		if (umdp->maplen > sc->sc_maplen)
			umdp->maplen = sc->sc_maplen;
		error = copyout(sc->sc_map, umdp->map,
				umdp->maplen*sizeof(struct wscons_keymap));
		return(error);

	case WSKBDIO_GETENCODING:
		*((kbd_t *) data) = sc->sc_layout;
		return(0);

	case WSKBDIO_SETENCODING:
		enc = *((kbd_t *)data);
		if (KB_ENCODING(enc) == KB_USER) {
			/* user map must already be loaded */
			if (KB_ENCODING(sc->sc_layout) != KB_USER)
				return (EINVAL);
			/* map variants make no sense */
			if (KB_VARIANT(enc) & ~KB_HANDLEDBYWSKBD)
				return (EINVAL);
		} else {
			md = *(sc->id->t_keymap); /* structure assignment */
			md.layout = enc;
			error = wskbd_load_keymap(&md, &sc->sc_map,
						  &sc->sc_maplen);
			if (error)
				return(error);
		}
		sc->sc_layout = enc;
		wskbd_update_layout(sc->id, enc);
		return (0);
	}

	/*
	 * Try the keyboard driver for WSKBDIO ioctls.  It returns -1
	 * if it didn't recognize the request, and in turn we return
	 * -1 if we didn't recognize the request.
	 */
/* printf("kbdaccess\n"); */
	error = (*sc->sc_accessops->ioctl)(sc->sc_accesscookie, cmd, data,
					   flag, p);
#ifdef WSDISPLAY_COMPAT_RAWKBD
	if (!error && cmd == WSKBDIO_SETMODE && *(int *)data == WSKBD_RAW) {
		int s = spltty();
		sc->id->t_modifiers &= ~(MOD_SHIFT_L | MOD_SHIFT_R
					 | MOD_CONTROL_L | MOD_CONTROL_R
					 | MOD_META_L | MOD_META_R
					 | MOD_COMMAND
					 | MOD_COMMAND1 | MOD_COMMAND2);
#if NWSDISPLAY > 0
		if (sc->sc_repeating) {
			sc->sc_repeating = 0;
			timeout_del(&sc->sc_repeat_ch);
		}
#endif
		splx(s);
	}
#endif
	return (error);
}

int
wskbdpoll(dev_t dev, int events, struct proc *p)
{
	struct wskbd_softc *sc = wskbd_cd.cd_devs[minor(dev)];

	if (sc->sc_base.me_evp == NULL)
		return (EINVAL);
	return (wsevent_poll(sc->sc_base.me_evp, events, p));
}

#if NWSDISPLAY > 0

int
wskbd_pickfree()
{
	int i;
	struct wskbd_softc *sc;

	for (i = 0; i < wskbd_cd.cd_ndevs; i++) {
		if ((sc = wskbd_cd.cd_devs[i]) == NULL)
			continue;
		if (sc->sc_displaydv == NULL)
			return (i);
	}
	return (-1);
}

struct wsevsrc *
wskbd_set_console_display(struct device *displaydv, struct wsevsrc *me)
{
	struct wskbd_softc *sc = wskbd_console_device;

	if (sc == NULL)
		return (NULL);
	sc->sc_base.me_dispdv = displaydv;
#if NWSMUX > 0
	(void)wsmux_attach_sc((struct wsmux_softc *)me, &sc->sc_base);
#endif
	return (&sc->sc_base);
}

int
wskbd_set_display(struct device *dv, struct device *displaydv)
{
	struct wskbd_softc *sc = (struct wskbd_softc *)dv;
	struct device *odisplaydv;
	int error;

	DPRINTF(("wskbd_set_display: %s odisp=%p disp=%p cons=%d\n",
		 dv->dv_xname, sc->sc_base.me_dispdv, displaydv, 
		 sc->sc_isconsole));

	if (sc->sc_isconsole)
		return (EBUSY);

	if (displaydv != NULL) {
		if (sc->sc_base.me_dispdv != NULL)
			return (EBUSY);
	} else {
		if (sc->sc_base.me_dispdv == NULL)
			return (ENXIO);
	}

	odisplaydv = sc->sc_base.me_dispdv;
	sc->sc_base.me_dispdv = NULL;
	error = wskbd_enable(sc, displaydv != NULL);
	sc->sc_base.me_dispdv = displaydv;
	if (error) {
		sc->sc_base.me_dispdv = odisplaydv;
		return (error);
	}

	if (displaydv)
		printf("%s: connecting to %s\n",
		       sc->sc_base.me_dv.dv_xname, displaydv->dv_xname);
	else
		printf("%s: disconnecting from %s\n",
		       sc->sc_base.me_dv.dv_xname, odisplaydv->dv_xname);

	return (0);
}

#endif	/* NWSDISPLAY > 0 */

#if NWSMUX > 0
int
wskbd_add_mux(int unit, struct wsmux_softc *muxsc)
{
	struct wskbd_softc *sc;

	if (unit < 0 || unit >= wskbd_cd.cd_ndevs ||
	    (sc = wskbd_cd.cd_devs[unit]) == NULL)
		return (ENXIO);

	if (sc->sc_base.me_parent != NULL || sc->sc_base.me_evp != NULL)
		return (EBUSY);

	return (wsmux_attach_sc(muxsc, &sc->sc_base));
}
#endif

/*
 * Console interface.
 */
int
wskbd_cngetc(dev_t dev)
{
	static int num = 0;
	static int pos;
	u_int type;
	int data;
	keysym_t ks;

	if (!wskbd_console_initted)
		return 0;

	if (wskbd_console_device != NULL &&
	    !wskbd_console_device->sc_translating)
		return 0;

	for(;;) {
		if (num-- > 0) {
			ks = wskbd_console_data.t_symbols[pos++];
			if (KS_GROUP(ks) == KS_GROUP_Ascii)
				return (KS_VALUE(ks));	
		} else {
			(*wskbd_console_data.t_consops->getc)
				(wskbd_console_data.t_consaccesscookie,
				 &type, &data);
			num = wskbd_translate(&wskbd_console_data, type, data);
			pos = 0;
		}
	}
}

void
wskbd_cnpollc(dev_t dev, int poll)
{

	if (!wskbd_console_initted)
		return;

	if (wskbd_console_device != NULL &&
	    !wskbd_console_device->sc_translating)
		return;

	(*wskbd_console_data.t_consops->pollc)
	    (wskbd_console_data.t_consaccesscookie, poll);
}

void
wskbd_cnbell(dev_t dev, u_int pitch, u_int period, u_int volume)
{
	if (!wskbd_console_initted)
		return;

	if ((pitch == 0) || (period == 0) || (volume == 0))
		return;

	if (wskbd_console_data.t_consops->bell != NULL)
		(*wskbd_console_data.t_consops->bell)
		    (wskbd_console_data.t_consaccesscookie, pitch, period,
			volume);
}

void
update_leds(struct wskbd_internal *id)
{
	int new_state;

	new_state = 0;
	if (id->t_modifiers & (MOD_SHIFTLOCK | MOD_CAPSLOCK))
		new_state |= WSKBD_LED_CAPS;
	if (id->t_modifiers & MOD_NUMLOCK)
		new_state |= WSKBD_LED_NUM;
	if (id->t_modifiers & MOD_COMPOSE)
		new_state |= WSKBD_LED_COMPOSE;
	if (id->t_modifiers & MOD_HOLDSCREEN)
		new_state |= WSKBD_LED_SCROLL;

	if (id->t_sc && new_state != id->t_sc->sc_ledstate) {
		(*id->t_sc->sc_accessops->set_leds)
		    (id->t_sc->sc_accesscookie, new_state);
		id->t_sc->sc_ledstate = new_state;
	}
}

void
update_modifier(struct wskbd_internal *id, u_int type, int toggle, int mask)
{
	if (toggle) {
		if (type == WSCONS_EVENT_KEY_DOWN)
			id->t_modifiers ^= mask;
	} else {
		if (type == WSCONS_EVENT_KEY_DOWN)
			id->t_modifiers |= mask;
		else
			id->t_modifiers &= ~mask;
	}
}

#if NWSDISPLAY > 0
void
change_displayparam(struct wskbd_softc *sc, int param, int updown,
    int wraparound)
{
	int res;
	struct wsdisplay_param dp;

	dp.param = param;
	res = wsdisplay_param(sc->sc_base.me_dispdv, WSDISPLAYIO_GETPARAM, &dp);

	if (res == EINVAL)
		return; /* no such parameter */

	dp.curval += updown;
	if (dp.max < dp.curval)
		dp.curval = wraparound ? dp.min : dp.max;
	else
	if (dp.curval < dp.min)
		dp.curval = wraparound ? dp.max : dp.min;
	wsdisplay_param(sc->sc_base.me_dispdv, WSDISPLAYIO_SETPARAM, &dp);
}
#endif

int
internal_command(struct wskbd_softc *sc, u_int *type, keysym_t ksym,
    keysym_t ksym2)
{
	switch (ksym) {
	case KS_Cmd:
		update_modifier(sc->id, *type, 0, MOD_COMMAND);
		ksym = ksym2;
		break;

	case KS_Cmd1:
		update_modifier(sc->id, *type, 0, MOD_COMMAND1);
		break;

	case KS_Cmd2:
		update_modifier(sc->id, *type, 0, MOD_COMMAND2);
		break;
	}

	if (*type != WSCONS_EVENT_KEY_DOWN)
		return (0);

#ifdef WSDISPLAY_SCROLLBACK_SUPPORT
#if NWSDISPLAY > 0
	switch (ksym) {
	case KS_Cmd_ScrollBack:
		if (MOD_ONESET(sc->id, MOD_ANYSHIFT)) {
			if (sc->sc_displaydv != NULL)
				wsscrollback(sc->sc_displaydv,
				    WSDISPLAY_SCROLL_BACKWARD);
			return (1);
		}
		break;

	case KS_Cmd_ScrollFwd:
		if (MOD_ONESET(sc->id, MOD_ANYSHIFT)) {
			if (sc->sc_displaydv != NULL)
				wsscrollback(sc->sc_displaydv,
				    WSDISPLAY_SCROLL_FORWARD);
			return (1);
		}
		break;
	}
#endif
#endif

	if (!MOD_ONESET(sc->id, MOD_COMMAND) &&
	    !MOD_ALLSET(sc->id, MOD_COMMAND1 | MOD_COMMAND2))
		return (0);

#ifdef DDB
	if (ksym == KS_Cmd_Debugger) {
		if (sc->sc_isconsole && db_console)
			Debugger();
		/* discard this key (ddb discarded command modifiers) */
		*type = WSCONS_EVENT_KEY_UP;
		return (1);
	}
#endif

#if NWSDISPLAY > 0
	if (sc->sc_base.me_dispdv == NULL)
		return (0);

	switch (ksym) {
	case KS_Cmd_Screen0:
	case KS_Cmd_Screen1:
	case KS_Cmd_Screen2:
	case KS_Cmd_Screen3:
	case KS_Cmd_Screen4:
	case KS_Cmd_Screen5:
	case KS_Cmd_Screen6:
	case KS_Cmd_Screen7:
	case KS_Cmd_Screen8:
	case KS_Cmd_Screen9:
	case KS_Cmd_Screen10:
	case KS_Cmd_Screen11:
		wsdisplay_switch(sc->sc_displaydv, ksym - KS_Cmd_Screen0, 0);
		return (1);
	case KS_Cmd_ResetEmul:
		wsdisplay_reset(sc->sc_displaydv, WSDISPLAY_RESETEMUL);
		return (1);
	case KS_Cmd_ResetClose:
		wsdisplay_reset(sc->sc_displaydv, WSDISPLAY_RESETCLOSE);
		return (1);
#if defined(__i386__) || defined(__amd64__)
	case KS_Cmd_KbdReset:
		if (kbd_reset == 1) {
			kbd_reset = 0;
			psignal(initproc, SIGUSR1);
		}
		return (1);
#endif
	case KS_Cmd_BacklightOn:
	case KS_Cmd_BacklightOff:
	case KS_Cmd_BacklightToggle:
		change_displayparam(sc, WSDISPLAYIO_PARAM_BACKLIGHT,
		    ksym == KS_Cmd_BacklightOff ? -1 : 1,
		    ksym == KS_Cmd_BacklightToggle ? 1 : 0);
		return (1);
	case KS_Cmd_BrightnessUp:
	case KS_Cmd_BrightnessDown:
	case KS_Cmd_BrightnessRotate:
		change_displayparam(sc, WSDISPLAYIO_PARAM_BRIGHTNESS,
		    ksym == KS_Cmd_BrightnessDown ? -1 : 1,
		    ksym == KS_Cmd_BrightnessRotate ? 1 : 0);
		return (1);
	case KS_Cmd_ContrastUp:
	case KS_Cmd_ContrastDown:
	case KS_Cmd_ContrastRotate:
		change_displayparam(sc, WSDISPLAYIO_PARAM_CONTRAST,
		    ksym == KS_Cmd_ContrastDown ? -1 : 1,
		    ksym == KS_Cmd_ContrastRotate ? 1 : 0);
		return (1);
	}
#endif
	return (0);
}

int
wskbd_translate(struct wskbd_internal *id, u_int type, int value)
{
	struct wskbd_softc *sc = id->t_sc;
	keysym_t ksym, res, *group;
	struct wscons_keymap kpbuf, *kp;
	int gindex, iscommand = 0;

	if (type == WSCONS_EVENT_ALL_KEYS_UP) {
#if NWSDISPLAY > 0
		if (sc != NULL && sc->sc_repeating) {
			sc->sc_repeating = 0;
			timeout_del(&sc->sc_repeat_ch);
		}
#endif
		id->t_modifiers &= ~(MOD_SHIFT_L | MOD_SHIFT_R |
		    MOD_CONTROL_L | MOD_CONTROL_R |
		    MOD_META_L | MOD_META_R |
		    MOD_MODESHIFT | MOD_MODELOCK |
		    MOD_COMMAND | MOD_COMMAND1 | MOD_COMMAND2);
		update_leds(id);
		return (0);
	}

	if (sc != NULL) {
		if (value < 0 || value >= sc->sc_maplen) {
#ifdef DEBUG
			printf("wskbd_translate: keycode %d out of range\n",
			       value);
#endif
			return (0);
		}
		kp = sc->sc_map + value;
	} else {
		kp = &kpbuf;
		wskbd_get_mapentry(id->t_keymap, value, kp);
	}

	/* if this key has a command, process it first */
	if (sc != NULL && kp->command != KS_voidSymbol)
		iscommand = internal_command(sc, &type, kp->command,
		    kp->group1[0]);

	/* Now update modifiers */
	switch (kp->group1[0]) {
	case KS_Shift_L:
		update_modifier(id, type, 0, MOD_SHIFT_L);
		break;

	case KS_Shift_R:
		update_modifier(id, type, 0, MOD_SHIFT_R);
		break;

	case KS_Shift_Lock:
		update_modifier(id, type, 1, MOD_SHIFTLOCK);
		break;

	case KS_Caps_Lock:
		update_modifier(id, type, 1, MOD_CAPSLOCK);
		break;

	case KS_Control_L:
		update_modifier(id, type, 0, MOD_CONTROL_L);
		break;

	case KS_Control_R:
		update_modifier(id, type, 0, MOD_CONTROL_R);
		break;

	case KS_Alt_L:
		update_modifier(id, type, 0, MOD_META_L);
		break;

	case KS_Alt_R:
		update_modifier(id, type, 0, MOD_META_R);
		break;

	case KS_Mode_switch:
		update_modifier(id, type, 0, MOD_MODESHIFT);
		break;

	case KS_Mode_Lock:
		update_modifier(id, type, 1, MOD_MODELOCK);
		break;

	case KS_Num_Lock:
		update_modifier(id, type, 1, MOD_NUMLOCK);
		break;

#if NWSDISPLAY > 0
	case KS_Hold_Screen:
		if (sc != NULL) {
			update_modifier(id, type, 1, MOD_HOLDSCREEN);
			wskbd_holdscreen(sc, id->t_modifiers & MOD_HOLDSCREEN);
		}
		break;

	default:
		if (sc != NULL && sc->sc_repeating &&
		    ((type == WSCONS_EVENT_KEY_UP && value != sc->sc_repkey) ||
		     (type == WSCONS_EVENT_KEY_DOWN && value == sc->sc_repkey)))
			return (0);
		break;
#endif
	}

#if NWSDISPLAY > 0
	if (sc != NULL) {
		if (sc->sc_repeating) {
			sc->sc_repeating = 0;
			timeout_del(&sc->sc_repeat_ch);
		}
		sc->sc_repkey = value;
	}
#endif

	/* If this is a key release or we are in command mode, we are done */
	if (type != WSCONS_EVENT_KEY_DOWN || iscommand) {
		update_leds(id);
		return (0);
	}

	/* Get the keysym */
	if (id->t_modifiers & (MOD_MODESHIFT|MOD_MODELOCK) &&
	    !MOD_ONESET(id, MOD_ANYCONTROL))
		group = & kp->group2[0];
	else
		group = & kp->group1[0];

	if ((id->t_modifiers & MOD_NUMLOCK) &&
	    KS_GROUP(group[1]) == KS_GROUP_Keypad) {
		gindex = !MOD_ONESET(id, MOD_ANYSHIFT);
		ksym = group[gindex];
	} else {
		/* CAPS alone should only affect letter keys */
		if ((id->t_modifiers & (MOD_CAPSLOCK | MOD_ANYSHIFT)) ==
		    MOD_CAPSLOCK) {
			gindex = 0;
			ksym = ksym_upcase(group[0]);
		} else {
			gindex = MOD_ONESET(id, MOD_ANYSHIFT);
			ksym = group[gindex];
		}
	}

#if NWSKBD_HOTKEY > 0
	/* Submit Audio keys for hotkey processing */
	if (KS_GROUP(ksym) == KS_GROUP_Function) {
		switch (ksym) {
#if NAUDIO > 0
		case KS_AudioMute:
		case KS_AudioLower:
		case KS_AudioRaise:
			wskbd_hotkey_put(ksym);
			return (0);
#endif
		default:
			break;
		}
	}
#endif

	/* Process compose sequence and dead accents */
	res = KS_voidSymbol;

	switch (KS_GROUP(ksym)) {
	case KS_GROUP_Ascii:
	case KS_GROUP_Keypad:
	case KS_GROUP_Function:
		res = ksym;
		break;

	case KS_GROUP_Mod:
		if (ksym == KS_Multi_key) {
			update_modifier(id, 1, 0, MOD_COMPOSE);
			id->t_composelen = 2;
		}
		break;

	case KS_GROUP_Dead:
		if (id->t_composelen == 0) {
			update_modifier(id, 1, 0, MOD_COMPOSE);
			id->t_composelen = 1;
			id->t_composebuf[0] = ksym;
		} else
			res = ksym;
		break;
	}

	if (res == KS_voidSymbol) {
		update_leds(id);
		return (0);
	}

	if (id->t_composelen > 0) {
		/*
		 * If the compose key also serves as AltGr (i.e. set to both
		 * KS_Multi_key and KS_Mode_switch), and would provide a valid,
		 * distinct combination as AltGr, leave compose mode.
	 	 */
		if (id->t_composelen == 2 && group == &kp->group2[0]) {
			if (kp->group1[gindex] != kp->group2[gindex])
				id->t_composelen = 0;
		}

		if (id->t_composelen != 0) {
			id->t_composebuf[2 - id->t_composelen] = res;
			if (--id->t_composelen == 0) {
				res = wskbd_compose_value(id->t_composebuf);
				update_modifier(id, 0, 0, MOD_COMPOSE);
			} else {
				return (0);
			}
		}
	}

	update_leds(id);

	/* We are done, return the symbol */
	if (KS_GROUP(res) == KS_GROUP_Ascii) {
		if (MOD_ONESET(id, MOD_ANYCONTROL)) {
			if ((res >= KS_at && res <= KS_z) || res == KS_space)
				res = res & 0x1f;
			else if (res == KS_2)
				res = 0x00;
			else if (res >= KS_3 && res <= KS_7)
				res = KS_Escape + (res - KS_3);
			else if (res == KS_8)
				res = KS_Delete;
		}
		if (MOD_ONESET(id, MOD_ANYMETA)) {
			if (id->t_flags & WSKFL_METAESC) {
				id->t_symbols[0] = KS_Escape;
				id->t_symbols[1] = res;
				return (2);
			} else
				res |= 0x80;
		}
	}

	id->t_symbols[0] = res;
	return (1);
}
@


1.8
log
@merge
@
text
@d1 1
a1 1
/* $MirOS: src/sys/dev/wscons/wskbd.c,v 1.7 2007/02/06 20:54:51 tg Exp $ */
d119 1
a119 1
#define	SCROLLBACK_SUPPORT
@


1.7
log
@fastmerge
@
text
@d1 1
a1 1
/* $MirOS: src/sys/dev/wscons/wskbd.c,v 1.6 2006/05/25 12:20:26 tg Exp $ */
d678 1
d705 2
a706 1
	nanotime(&ev->time);
@


1.6
log
@add WSDISPLAY_SCROLLBACK_SUPPORT as kernel option
previously, SCROLLBACK_SUPPORT was defined #ifndef SMALL_KERNEL
but I like namespaced defns better
(commented out in GENERIC because it has no SMALL_KERNEL)
@
text
@d1 2
a2 2
/* $MirOS: src/sys/dev/wscons/wskbd.c,v 1.5 2005/07/21 21:52:21 tg Exp $ */
/* $OpenBSD: wskbd.c,v 1.45 2005/07/08 02:26:07 marc Exp $ */
a82 5
#ifndef	SMALL_KERNEL
#define	BURNER_SUPPORT
#define	WSDISPLAY_SCROLLBACK_SUPPORT
#endif

d109 1
d111 1
d114 8
a212 5
#if NWSDISPLAY > 0
int	wskbd_set_display(struct device *, struct wsevsrc *);
#else
#define	wskbd_set_display NULL
#endif
d284 6
a289 1
	wskbd_displayioctl, wskbd_set_display
d438 21
a677 1
	struct timeval xxxtime;
d704 1
a704 2
	microtime(&xxxtime);
	TIMEVAL_TO_TIMESPEC(&xxxtime, &ev->time);
d983 12
a1006 2
		if ((flag & FWRITE) == 0)
			return (EACCES);
a1010 2
		if ((flag & FWRITE) == 0)
			return (EACCES);
a1016 2
		if ((flag & FWRITE) == 0)
			return (EACCES);
a1052 2
		if ((flag & FWRITE) == 0)
			return (EACCES);
a1079 2
		if ((flag & FWRITE) == 0)
			return (EACCES);
a1111 2
		if ((flag & FWRITE) == 0)
			return (EACCES);
d1203 1
a1203 1
wskbd_set_display(struct device *dv, struct wsevsrc *me)
a1205 1
	struct device *displaydv = me != NULL ? me->me_dispdv : NULL;
d1209 2
a1210 2
	DPRINTF(("wskbd_set_display: %s me=%p odisp=%p disp=%p cons=%d\n",
		 dv->dv_xname, me, sc->sc_base.me_dispdv, displaydv, 
d1514 6
d1650 17
@


1.5
log
@merge and bump patchlevel (kernel only)
@
text
@d1 1
a1 1
/* $MirOS: src/sys/dev/wscons/wskbd.c,v 1.4 2005/07/04 03:36:33 tg Exp $ */
d85 1
a85 1
#define	SCROLLBACK_SUPPORT
d605 1
a605 1
#ifdef SCROLLBACK_SUPPORT
d1385 1
a1385 1
#ifdef SCROLLBACK_SUPPORT
@


1.4
log
@* finish outstanding merges
* make that damn thing build again
@
text
@d1 2
a2 2
/* $MirOS: src/sys/dev/wscons/wskbd.c,v 1.3 2005/07/04 01:15:48 tg Exp $ */
/* $OpenBSD: wskbd.c,v 1.44 2005/06/02 07:31:17 miod Exp $ */
a123 1
#if NWSMUX > 0 || NWSDISPLAY > 0
a124 1
#endif
d1477 1
a1478 1
	}
@


1.3
log
@fastmerge
@
text
@d1 1
a1 1
/* $MirOS: src/sys/dev/wscons/wskbd.c,v 1.2 2005/05/13 06:46:33 tg Exp $ */
d654 1
d681 2
a682 1
	nanotime(&ev->time);
@


1.2
log
@here too: return if nothing to beep
@
text
@d1 3
a3 3
/* $MirOS$ */
/* $OpenBSD: wskbd.c,v 1.40 2004/04/05 06:22:07 miod Exp $ */
/* $NetBSD: wskbd.c,v 1.38 2000/03/23 07:01:47 thorpej Exp $ */
a37 2
#include <sys/cdefs.h>

d83 5
d110 1
a112 1
#include <dev/wscons/wsdisplayvar.h>
d138 1
a138 1
	int t_flags;
d148 1
a148 1
	struct device	sc_dv;
a156 2
	struct wseventvar sc_events;	/* event queue state */

a157 3
#if NWSDISPLAY > 0
	struct device	*sc_displaydv;
#endif
d165 2
d172 1
a172 4
	kbd_t sc_layout; /* current layout */

	int		sc_refcnt;
	u_char		sc_dying;	/* device is being detached */
d174 2
a175 3
#if NWSMUX > 0 || NWSDISPLAY > 0
	struct wsmux_softc *sc_mux;
#endif
a198 1
	/* these should result in precise 0 or 1, see wskbd_translate() XXX */
d209 31
a239 20
int wskbd_displayioctl(struct device *, u_long, caddr_t, int, struct proc *p);
int	wskbd_set_display(struct device *, struct wsmux_softc *);
int	wskbd_isset_display(struct device *);

inline void update_leds(struct wskbd_internal *);
inline void update_modifier(struct wskbd_internal *, u_int, int, int);
int internal_command(struct wskbd_softc *, u_int *, keysym_t, keysym_t);
int wskbd_translate(struct wskbd_internal *, u_int, int);
int wskbd_enable(struct wskbd_softc *, int);
#if NWSDISPLAY > 0
void change_displayparam(struct wskbd_softc *, int, int, int);
void wskbd_holdscreen(struct wskbd_softc *, int);
#endif

int	wskbd_do_ioctl(struct wskbd_softc *, u_long, caddr_t, 
			    int, struct proc *);

int	wskbddoclose(struct device *, int, int, struct proc *);
int	wskbddoioctl(struct device *, u_long, caddr_t, int, 
			  struct proc *);
a249 2
extern struct cfdriver wskbd_cd;

d283 4
a286 3
struct wsmuxops wskbd_muxops = {
	wskbdopen, wskbddoclose, wskbddoioctl, wskbd_displayioctl,
	wskbd_set_display, wskbd_isset_display
d298 1
a298 1
void wskbd_update_layout(struct wskbd_internal *, kbd_t);
d301 1
a301 3
wskbd_update_layout(id, enc)
	struct wskbd_internal *id;
	kbd_t enc;
a302 1

d313 1
a313 3
wskbddevprint(aux, pnp)
	void *aux;
	const char *pnp;
d329 1
a329 4
wskbd_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d350 1
a350 3
wskbd_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d354 2
a355 2
#if NWSMUX > 0 || NWSDISPLAY > 0
	int mux;
a357 3
#if NWSDISPLAY > 0
	sc->sc_displaydv = NULL;
#endif
d361 8
a368 4
	mux = sc->sc_dv.dv_cfdata->wskbddevcf_mux;
	if (sc->sc_isconsole && mux != WSKBDDEVCF_MUX_DEFAULT) {
		printf(" (mux %d ignored for console)", mux);
		mux = WSKBDDEVCF_MUX_DEFAULT;
d370 1
a370 1
	if (mux != WSKBDDEVCF_MUX_DEFAULT)
d372 4
d377 1
d383 1
a383 1
				M_DEVBUF, M_WAITOK);
a396 1
	sc->sc_events.io = NULL;			/* sanity */
d402 1
a402 1
			      &sc->sc_map, &sc->sc_maplen) != 0)
d420 2
a421 1
		if ((sc->sc_displaydv = wsdisplay_set_console_kbd(self)))
d428 5
a432 4
	if (mux != WSKBDDEVCF_MUX_DEFAULT) {
		wsmux_attach(mux, WSMUX_KBD, &sc->sc_dv, &sc->sc_events, 
			     &sc->sc_mux, &wskbd_muxops);
		wsdisplay_set_console_kbd(self);
a434 1

d438 2
a439 4
wskbd_cnattach(consops, conscookie, mapdata)
	const struct wskbd_consops *consops;
	void *conscookie;
	const struct wskbd_mapdata *mapdata;
d476 1
a476 2
wskbd_repeat(v)
	void *v;
d489 16
a504 8
	if (sc->sc_displaydv != NULL) {
		int i;
		for (i = 0; i < sc->sc_repeating; i++)
			wsdisplay_kbdinput(sc->sc_displaydv,
					   sc->id->t_symbols[i]);
	}
	timeout_add(&sc->sc_repeat_ch,
	    (hz * sc->sc_keyrepeat_data.delN) / 1000);
d510 1
a510 3
wskbd_activate(self, act)
	struct device *self;
	enum devact act;
d512 4
a515 1
	/* XXX should we do something more? */
d528 1
a528 3
wskbd_detach(self, flags)
	struct device  *self;
	int flags;
a533 5
#if NWSMUX > 0
	int mux;
#endif

	sc->sc_dying = 1;
d536 3
a538 3
	mux = sc->sc_dv.dv_cfdata->wskbddevcf_mux;
	if (mux != WSKBDDEVCF_MUX_DEFAULT)
		wsmux_detach(mux, &sc->sc_dv);
d553 2
a554 2
	evar = &sc->sc_events;
	if (evar->io) {
d564 1
a564 1
				       sc->sc_dv.dv_xname);
d582 1
a582 4
wskbd_input(dev, type, value)
	struct device *dev;
	u_int type;
	int value;
a584 3
	struct wscons_event *ev;
	struct wseventvar *evar;
	struct timeval xxxtime;
a587 1
	int put;
d590 5
d596 1
a596 1
	 * If /dev/wskbd is not connected in event mode translate and
d600 1
d603 1
d606 2
a607 1
			if (sc->sc_displaydv != NULL) {
d610 1
a610 1
					wsscrollback(sc->sc_displaydv,
d613 1
d615 1
a615 1
					wsdisplay_kbdinput(sc->sc_displaydv,
d620 5
a624 3
			sc->sc_repeating = num;
			timeout_add(&sc->sc_repeat_ch,
			    (hz * sc->sc_keyrepeat_data.del1) / 1000);
d630 27
a656 5
	/*
	 * Keyboard is generating events.  Turn this keystroke into an
	 * event and put it in the queue.  If the queue is full, the
	 * keystroke is lost (sorry!).
	 */
d658 2
a659 2
	/* no one to receive; punt!*/
	if (sc->sc_events.io == NULL)
d661 1
d663 5
a667 4
#if NWSMUX > 0
	if (sc->sc_mux)
		evar = &sc->sc_mux->sc_events;
	else
a668 1
		evar = &sc->sc_events;
d675 1
a675 1
		    sc->sc_dv.dv_xname);
d680 1
a680 2
	microtime(&xxxtime);
	TIMEVAL_TO_TIMESPEC(&xxxtime, &ev->time);
d687 1
a687 4
wskbd_rawinput(dev, buf, len)
	struct device *dev;
	u_char *buf;
	int len;
d693 3
a695 2
	for (i = 0; i < len; i++)
		wsdisplay_kbdinput(sc->sc_displaydv, buf[i]);
d703 1
a703 3
wskbd_holdscreen(sc, hold)
	struct wskbd_softc *sc;
	int hold;
d707 2
a708 2
	if (sc->sc_displaydv != NULL) {
		wsdisplay_kbdholdscreen(sc->sc_displaydv, hold);
d724 1
a724 3
wskbd_enable(sc, on)
	struct wskbd_softc *sc;
	int on;
d726 1
a726 1
	int res;
a727 2
	/* XXX reference count? */
	if (!on && (!sc->sc_translating
d729 8
a736 1
		    || sc->sc_displaydv
d738 16
a753 1
		))
d756 1
a756 2
	res = (*sc->sc_accessops->enable)(sc->sc_accesscookie, on);
	return (res);
d758 1
d761 1
a761 4
wskbdopen(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
d764 2
a765 1
	int unit;
d772 5
d780 1
a780 1
	if (!(flags & FREAD)) {
d786 5
a790 2
	if (sc->sc_mux)
		return (EBUSY);
d793 1
a793 1
	if (sc->sc_events.io)			/* and that it's not in use */
d796 3
a798 2
	sc->sc_events.io = p;
	wsevent_init(&sc->sc_events);		/* may cause sleep */
d800 8
a807 4
	sc->sc_translating = 0;

	wskbd_enable(sc, 1);
	return (0);
d811 1
a811 4
wskbdclose(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
d813 4
a816 1
	return (wskbddoclose(wskbd_cd.cd_devs[minor(dev)], flags, mode, p));
d820 1
a820 4
wskbddoclose(dv, flags, mode, p)
	struct device *dv;
	int flags, mode;
	struct proc *p;
d822 3
a824 1
	struct wskbd_softc *sc = (struct wskbd_softc *)dv;
d826 2
a827 2
	if (!(flags & FREAD)) {
		/* Nothing to do, because open didn't do anything. */
a828 1
	}
d830 1
d832 2
d835 12
a846 2
	wsevent_fini(&sc->sc_events);
	sc->sc_events.io = NULL;
a847 1
	wskbd_enable(sc, 0);
d850 1
d853 1
a853 4
wskbdread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
d861 7
d869 1
a869 1
	error = wsevent_read(&sc->sc_events, uio, flags);
d878 1
a878 6
wskbdioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d880 1
a880 1
	return (wskbddoioctl(wskbd_cd.cd_devs[minor(dev)], cmd, data, flag,p));
d885 2
a886 6
wskbddoioctl(dv, cmd, data, flag, p)
	struct device *dv;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d892 1
a892 1
	error = wskbd_do_ioctl(sc, cmd, data, flag, p);
d899 2
a900 6
wskbd_do_ioctl(sc, cmd, data, flag, p)
	struct wskbd_softc *sc;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d912 3
a914 1
		sc->sc_events.async = *(int *)data != 0;
d917 8
d926 3
a928 1
		if (*(int *)data != sc->sc_events.io->p_pgid)
d937 1
a937 1
	error = wskbd_displayioctl((struct device *)sc, cmd, data, flag, p);
d946 2
a947 6
wskbd_displayioctl(dev, cmd, data, flag, p)
	struct device *dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
a1027 5
		if ((ukdp->which & WSKBD_KEYREPEAT_DODEL1 &&
		     (hz * ukdp->del1) / 1000 <= 0) ||
		    (ukdp->which & WSKBD_KEYREPEAT_DODELN &&
		     (hz * ukdp->delN) / 1000 <= 0))
			return (EINVAL);
d1057 2
a1058 1
		len = umdp->maplen*sizeof(struct wscons_keymap);
d1098 5
a1102 5
				md.layout = enc;
				error = wskbd_load_keymap(&md, &sc->sc_map,
							  &sc->sc_maplen);
				if (error)
			return(error);
d1138 1
a1138 4
wskbdpoll(dev, events, p)
	dev_t dev;
	int events;
	struct proc *p;
d1142 3
a1144 1
	return (wsevent_poll(&sc->sc_events, events, p));
d1164 2
a1165 4
struct device *
wskbd_set_console_display(displaydv, muxsc)
	struct device *displaydv;
	struct wsmux_softc *muxsc;
d1169 7
a1175 6
	if (!sc)
		return (0);
	sc->sc_displaydv = displaydv;
	(void)wsmux_attach_sc(muxsc, WSMUX_KBD, &sc->sc_dv, &sc->sc_events, 
			      &sc->sc_mux, &wskbd_muxops);
	return (&sc->sc_dv);
d1179 1
a1179 3
wskbd_set_display(dv, muxsc)
	struct device *dv;
	struct wsmux_softc *muxsc;
d1182 1
a1182 1
	struct device *displaydv = muxsc ? muxsc->sc_displaydv : 0;
d1186 2
a1187 2
	DPRINTF(("wskbd_set_display: %s mux=%p disp=%p odisp=%p cons=%d\n",
		 dv->dv_xname, muxsc, sc->sc_displaydv, displaydv, 
d1193 2
a1194 2
	if (displaydv) {
		if (sc->sc_displaydv)
d1197 1
a1197 1
		if (sc->sc_displaydv == NULL)
d1201 2
a1202 3
	odisplaydv = sc->sc_displaydv;
	sc->sc_displaydv = displaydv;

d1204 1
d1206 1
a1206 1
		sc->sc_displaydv = odisplaydv;
d1212 1
a1212 1
		       sc->sc_dv.dv_xname, displaydv->dv_xname);
d1215 1
a1215 1
		       sc->sc_dv.dv_xname, odisplaydv->dv_xname);
d1220 1
a1220 11
int
wskbd_isset_display(dv)
	struct device *dv;
{
	struct wskbd_softc *sc = (struct wskbd_softc *)dv;

	if (sc->sc_displaydv != NULL)
		return (1);

	return (0);
}
d1222 1
d1224 1
a1224 3
wskbd_add_mux(unit, muxsc)
	int unit;
	struct wsmux_softc *muxsc;
a1227 2
	DPRINTF(("wskbd_add_mux: %d %s %p\n", unit, muxsc->sc_dv.dv_xname,
		 muxsc->sc_displaydv));
d1232 1
a1232 1
	if (sc->sc_mux || sc->sc_events.io)
d1235 1
a1235 2
	return (wsmux_attach_sc(muxsc, WSMUX_KBD, &sc->sc_dv, &sc->sc_events, 
				&sc->sc_mux, &wskbd_muxops));
d1237 1
a1237 17

int
wskbd_rem_mux(unit, muxsc)
	int unit;
	struct wsmux_softc *muxsc;
{
	struct wskbd_softc *sc;

	DPRINTF(("wskbd_rem_mux: %d %s\n", unit, muxsc->sc_dv.dv_xname));
	if (unit < 0 || unit >= wskbd_cd.cd_ndevs ||
	    (sc = wskbd_cd.cd_devs[unit]) == NULL)
		return (ENXIO);

	return (wsmux_detach_sc(muxsc, &sc->sc_dv));
}

#endif /* NWSDISPLAY > 0 */
d1243 1
a1243 2
wskbd_cngetc(dev)
	dev_t dev;
d1261 2
a1262 1
			return (KS_VALUE(ks));	
d1274 1
a1274 3
wskbd_cnpollc(dev, poll)
	dev_t dev;
	int poll;
d1289 1
a1289 3
wskbd_cnbell(dev, pitch, period, volume)
	dev_t dev;
	u_int pitch, period, volume;
d1303 2
a1304 3
inline void
update_leds(id)
	struct wskbd_internal *id;
d1325 2
a1326 6
inline void
update_modifier(id, type, toggle, mask)
	struct wskbd_internal *id;
	u_int type;
	int toggle;
	int mask;
d1341 2
a1342 3
change_displayparam(sc, param, updown, wraparound)
	struct wskbd_softc *sc;
	int param, updown, wraparound;
a1346 3
	if (sc->sc_displaydv == NULL)
		return;

d1348 1
a1348 1
	res = wsdisplay_param(sc->sc_displaydv, WSDISPLAYIO_GETPARAM, &dp);
d1359 1
a1359 1
	wsdisplay_param(sc->sc_displaydv, WSDISPLAYIO_SETPARAM, &dp);
d1364 2
a1365 4
internal_command(sc, type, ksym, ksym2)
	struct wskbd_softc *sc;
	u_int *type;
	keysym_t ksym, ksym2;
d1385 1
d1407 1
a1412 1
	switch (ksym) {
d1414 1
a1414 1
	case KS_Cmd_Debugger:
d1420 1
d1424 4
d1440 1
a1440 3
		if (sc->sc_displaydv != NULL)
			wsdisplay_switch(sc->sc_displaydv,
			    ksym - KS_Cmd_Screen0, 0);
d1443 1
a1443 2
		if (sc->sc_displaydv != NULL)
			wsdisplay_reset(sc->sc_displaydv, WSDISPLAY_RESETEMUL);
d1446 1
a1446 2
		if (sc->sc_displaydv != NULL)
			wsdisplay_reset(sc->sc_displaydv, WSDISPLAY_RESETCLOSE);
d1460 2
a1461 2
				    ksym == KS_Cmd_BacklightOff ? -1 : 1,
				    ksym == KS_Cmd_BacklightToggle ? 1 : 0);
d1467 2
a1468 2
				    ksym == KS_Cmd_BrightnessDown ? -1 : 1,
				    ksym == KS_Cmd_BrightnessRotate ? 1 : 0);
d1474 2
a1475 2
				    ksym == KS_Cmd_ContrastDown ? -1 : 1,
				    ksym == KS_Cmd_ContrastRotate ? 1 : 0);
d1483 1
a1483 4
wskbd_translate(id, type, value)
	struct wskbd_internal *id;
	u_int type;
	int value;
d1491 5
a1495 5
		id->t_modifiers &= ~(MOD_SHIFT_L | MOD_SHIFT_R
				| MOD_CONTROL_L | MOD_CONTROL_R
				| MOD_META_L | MOD_META_R
				| MOD_MODESHIFT | MOD_MODELOCK
				| MOD_COMMAND | MOD_COMMAND1 | MOD_COMMAND2);
d1517 1
a1517 1
					     kp->group1[0]);
d1577 2
a1578 1
				return (0);
d1695 1
a1695 1
			res |= 0x80;
@


1.1
log
@Initial revision
@
text
@d1 1
d1275 3
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@lastly some drivers
@
text
@d1 2
a2 2
/* $OpenBSD: wskbd.c,v 1.44 2005/06/02 07:31:17 miod Exp $ */
/* $NetBSD: wskbd.c,v 1.80 2005/05/04 01:52:16 augustss Exp $ */
d37 2
a83 5
#ifndef	SMALL_KERNEL
#define	BURNER_SUPPORT
#define	SCROLLBACK_SUPPORT
#endif

a105 1
#include <dev/wscons/wsdisplayvar.h>
d108 1
d134 1
a134 1
	int	t_flags;
d144 1
a144 1
	struct wsevsrc	sc_base;
d153 2
d156 3
a165 2
	u_int	sc_repeat_type;
	int	sc_repeat_value;
d171 4
a174 1
	kbd_t	sc_layout; /* current layout */
d176 3
a178 2
	int	sc_refcnt;
	u_char	sc_dying;		/* device is being detached */
d202 1
d213 20
a232 31
int	wskbd_displayioctl(struct device *, u_long, caddr_t, int, struct proc *);
#if NWSDISPLAY > 0
int	wskbd_set_display(struct device *, struct wsevsrc *);
#else
#define	wskbd_set_display NULL
#endif

void	update_leds(struct wskbd_internal *);
void	update_modifier(struct wskbd_internal *, u_int, int, int);
int	internal_command(struct wskbd_softc *, u_int *, keysym_t, keysym_t);
int	wskbd_translate(struct wskbd_internal *, u_int, int);
int	wskbd_enable(struct wskbd_softc *, int);
#if NWSDISPLAY > 0
void	change_displayparam(struct wskbd_softc *, int, int, int);
void	wskbd_holdscreen(struct wskbd_softc *, int);
#endif

int	wskbd_do_ioctl_sc(struct wskbd_softc *, u_long, caddr_t, int,
	    struct proc *);
void	wskbd_deliver_event(struct wskbd_softc *sc, u_int type, int value);

#if NWSMUX > 0
int	wskbd_mux_open(struct wsevsrc *, struct wseventvar *);
int	wskbd_mux_close(struct wsevsrc *);
#else
#define	wskbd_mux_open NULL
#define	wskbd_mux_close NULL
#endif

int	wskbd_do_open(struct wskbd_softc *, struct wseventvar *);
int	wskbd_do_ioctl(struct device *, u_long, caddr_t, int, struct proc *);
d243 2
d278 3
a280 4
struct wssrcops wskbd_srcops = {
	WSMUX_KBD,
	wskbd_mux_open, wskbd_mux_close, wskbd_do_ioctl,
	wskbd_displayioctl, wskbd_set_display
d292 1
a292 1
void	wskbd_update_layout(struct wskbd_internal *, kbd_t);
d295 3
a297 1
wskbd_update_layout(struct wskbd_internal *id, kbd_t enc)
d299 1
d310 3
a312 1
wskbddevprint(void *aux, const char *pnp)
d328 4
a331 1
wskbd_match(struct device *parent, void *match, void *aux)
d352 3
a354 1
wskbd_attach(struct device *parent, struct device *self, void *aux)
d358 2
a359 2
#if NWSMUX > 0
	int mux, error;
d362 3
d368 4
a371 8
	sc->sc_base.me_ops = &wskbd_srcops;
#endif
#if NWSMUX > 0
	mux = sc->sc_base.me_dv.dv_cfdata->wskbddevcf_mux;
	if (ap->console) {
		/* Ignore mux for console; it always goes to the console mux. */
		/* printf(" (mux %d ignored for console)", mux); */
		mux = -1;
d373 1
a373 1
	if (mux >= 0)
a374 4
#else
#if 0	/* not worth keeping, especially since the default value is not -1... */
	if (sc->sc_base.me_dv.dv_cfdata->wskbddevcf_mux >= 0)
		printf(" (mux ignored)");
a375 1
#endif	/* NWSMUX > 0 */
d381 1
a381 1
		    M_DEVBUF, M_WAITOK);
d395 1
d401 1
a401 1
	    &sc->sc_map, &sc->sc_maplen) != 0)
d419 1
a419 2
		wsdisplay_set_console_kbd(&sc->sc_base); /* sets me_dispdv */
		if (sc->sc_displaydv != NULL)
d426 4
a429 5
	if (mux >= 0) {
		error = wsmux_attach_sc(wsmux_getmux(mux), &sc->sc_base);
		if (error)
			printf("%s: attach error=%d\n",
			    sc->sc_base.me_dv.dv_xname, error);
d432 1
d436 4
a439 2
wskbd_cnattach(const struct wskbd_consops *consops, void *conscookie,
    const struct wskbd_mapdata *mapdata)
d476 2
a477 1
wskbd_repeat(void *v)
d490 8
a497 16
	if (sc->sc_translating) {
		/* deliver keys */
		if (sc->sc_base.me_dispdv != NULL) {
			int i;
			for (i = 0; i < sc->sc_repeating; i++)
				wsdisplay_kbdinput(sc->sc_base.me_dispdv,
				    sc->id->t_symbols[i]);
		}
	} else {
		/* queue event */
		wskbd_deliver_event(sc, sc->sc_repeat_type,
		    sc->sc_repeat_value);
	}
	if (sc->sc_keyrepeat_data.delN != 0)
		timeout_add(&sc->sc_repeat_ch,
		    (hz * sc->sc_keyrepeat_data.delN) / 1000);
d503 3
a505 1
wskbd_activate(struct device *self, enum devact act)
d507 1
a507 4
	struct wskbd_softc *sc = (struct wskbd_softc *)self;

	if (act == DVACT_DEACTIVATE)
		sc->sc_dying = 1;
d520 3
a522 1
wskbd_detach(struct device  *self, int flags)
d528 5
d535 3
a537 3
	/* Tell parent mux we're leaving. */
	if (sc->sc_base.me_parent != NULL)
		wsmux_detach_sc(&sc->sc_base);
d552 2
a553 2
	evar = sc->sc_base.me_evp;
	if (evar != NULL && evar->io != NULL) {
d563 1
a563 1
				       sc->sc_base.me_dv.dv_xname);
d581 4
a584 1
wskbd_input(struct device *dev, u_int type, int value)
d587 3
d593 1
a595 5
	if (sc->sc_repeating) {
		sc->sc_repeating = 0;
		timeout_del(&sc->sc_repeat_ch);
	}

d597 1
a597 1
	 * If /dev/wskbdN is not connected in event mode translate and
a600 1
#ifdef BURNER_SUPPORT
a602 1
#endif
d605 1
a605 2
			if (sc->sc_base.me_dispdv != NULL) {
#ifdef SCROLLBACK_SUPPORT
d608 1
a608 1
					wsscrollback(sc->sc_base.me_dispdv,
a610 1
#endif
d612 1
a612 1
					wsdisplay_kbdinput(sc->sc_base.me_dispdv,
d617 3
a619 5
			if (sc->sc_keyrepeat_data.del1 != 0) {
				sc->sc_repeating = num;
				timeout_add(&sc->sc_repeat_ch,
				    (hz * sc->sc_keyrepeat_data.del1) / 1000);
			}
d625 5
a629 25
	wskbd_deliver_event(sc, type, value);

#if NWSDISPLAY > 0
	/* Repeat key presses if enabled. */
	if (type == WSCONS_EVENT_KEY_DOWN && sc->sc_keyrepeat_data.del1 != 0) {
		sc->sc_repeat_type = type;
		sc->sc_repeat_value = value;
		sc->sc_repeating = 1;
		timeout_add(&sc->sc_repeat_ch,
		    (hz * sc->sc_keyrepeat_data.del1) / 1000);
	}
#endif
}

/*
 * Keyboard is generating events.  Turn this keystroke into an
 * event and put it in the queue.  If the queue is full, the
 * keystroke is lost (sorry!).
 */
void
wskbd_deliver_event(struct wskbd_softc *sc, u_int type, int value)
{
	struct wseventvar *evar;
	struct wscons_event *ev;
	int put;
d631 2
a632 4
	evar = sc->sc_base.me_evp;

	if (evar == NULL) {
		DPRINTF(("wskbd_input: not open\n"));
a633 1
	}
d635 4
a638 5
#ifdef DIAGNOSTIC
	if (evar->q == NULL) {
		printf("wskbd_input: evar->q=NULL\n");
		return;
	}
d640 1
d647 1
a647 1
		    sc->sc_base.me_dv.dv_xname);
d652 2
a653 1
	nanotime(&ev->time);
d660 4
a663 1
wskbd_rawinput(struct device *dev, u_char *buf, int len)
d669 2
a670 3
	if (sc->sc_base.me_dispdv != NULL)
		for (i = 0; i < len; i++)
			wsdisplay_kbdinput(sc->sc_base.me_dispdv, buf[i]);
d678 3
a680 1
wskbd_holdscreen(struct wskbd_softc *sc, int hold)
d684 2
a685 2
	if (sc->sc_base.me_dispdv != NULL) {
		wsdisplay_kbdholdscreen(sc->sc_base.me_dispdv, hold);
d701 3
a703 1
wskbd_enable(struct wskbd_softc *sc, int on)
d705 1
a705 1
	int error;
d707 2
d710 1
a710 8
	if (sc->sc_base.me_dispdv != NULL)
		return (0);

	/* Always cancel auto repeat when fiddling with the kbd. */
	if (sc->sc_repeating) {
		sc->sc_repeating = 0;
		timeout_del(&sc->sc_repeat_ch);
	}
d712 1
a712 16

	error = (*sc->sc_accessops->enable)(sc->sc_accesscookie, on);
	DPRINTF(("wskbd_enable: sc=%p on=%d res=%d\n", sc, on, error));
	return (error);
}

#if NWSMUX > 0
int
wskbd_mux_open(struct wsevsrc *me, struct wseventvar *evp)
{
	struct wskbd_softc *sc = (struct wskbd_softc *)me;

	if (sc->sc_dying)
		return (EIO);

	if (sc->sc_base.me_evp != NULL)
d715 2
a716 1
	return (wskbd_do_open(sc, evp));
a717 1
#endif
d720 4
a723 1
wskbdopen(dev_t dev, int flags, int mode, struct proc *p)
d726 1
a726 2
	struct wseventvar *evar;
	int unit, error;
a732 5
#if NWSMUX > 0
	DPRINTF(("wskbdopen: %s mux=%p p=%p\n", sc->sc_base.me_dv.dv_xname,
		 sc->sc_base.me_parent, p));
#endif

d736 1
a736 1
	if ((flags & (FREAD | FWRITE)) == FWRITE) {
d742 2
a743 5
	if (sc->sc_base.me_parent != NULL) {
		/* Grab the keyboard out of the greedy hands of the mux. */
		DPRINTF(("wskbdopen: detach\n"));
		wsmux_detach_sc(&sc->sc_base);
	}
d746 1
a746 1
	if (sc->sc_base.me_evp != NULL)
d749 4
a752 3
	evar = &sc->sc_base.me_evar;
	wsevent_init(evar);
	evar->io = p;
d754 2
a755 8
	error = wskbd_do_open(sc, evar);
	if (error) {
		DPRINTF(("wskbdopen: %s open failed\n",
			 sc->sc_base.me_dv.dv_xname));
		sc->sc_base.me_evp = NULL;
		wsevent_fini(evar);
	}
	return (error);
d759 4
a762 1
wskbd_do_open(struct wskbd_softc *sc, struct wseventvar *evp)
d764 1
a764 4
	sc->sc_base.me_evp = evp;
	sc->sc_translating = 0;

	return (wskbd_enable(sc, 1));
d768 4
a771 1
wskbdclose(dev_t dev, int flags, int mode, struct proc *p)
d773 1
a773 3
	struct wskbd_softc *sc =
	    (struct wskbd_softc *)wskbd_cd.cd_devs[minor(dev)];
	struct wseventvar *evar = sc->sc_base.me_evp;
d775 2
a776 2
	if (evar == NULL)
		/* not open for read */
d778 1
a779 1
	sc->sc_base.me_evp = NULL;
a780 2
	(void)wskbd_enable(sc, 0);
	wsevent_fini(evar);
d782 2
a783 12
	return (0);
}

#if NWSMUX > 0
int
wskbd_mux_close(struct wsevsrc *me)
{
	struct wskbd_softc *sc = (struct wskbd_softc *)me;

	sc->sc_base.me_evp = NULL;
	sc->sc_translating = 1;
	(void)wskbd_enable(sc, 0);
d785 1
a787 1
#endif
d790 4
a793 1
wskbdread(dev_t dev, struct uio *uio, int flags)
a800 7
#ifdef DIAGNOSTIC
	if (sc->sc_base.me_evp == NULL) {
		printf("wskbdread: evp == NULL\n");
		return (EINVAL);
	}
#endif

d802 1
a802 1
	error = wsevent_read(&sc->sc_base.me_evar, uio, flags);
d811 6
a816 1
wskbdioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
d818 1
a818 1
	return (wskbd_do_ioctl(wskbd_cd.cd_devs[minor(dev)], cmd, data, flag,p));
d823 6
a828 2
wskbd_do_ioctl(struct device *dv, u_long cmd, caddr_t data, int flag,
    struct proc *p)
d834 1
a834 1
	error = wskbd_do_ioctl_sc(sc, cmd, data, flag, p);
d841 6
a846 2
wskbd_do_ioctl_sc(struct wskbd_softc *sc, u_long cmd, caddr_t data, int flag,
     struct proc *p)
d858 1
a858 3
		if (sc->sc_base.me_evp == NULL)
			return (EINVAL);
		sc->sc_base.me_evp->async = *(int *)data != 0;
a860 8
	case FIOSETOWN:
		if (sc->sc_base.me_evp == NULL)
			return (EINVAL);
		if (-*(int *)data != sc->sc_base.me_evp->io->p_pgid &&
		    *(int *)data != sc->sc_base.me_evp->io->p_pid)
			return (EPERM);
		return (0);
		   
d862 1
a862 3
		if (sc->sc_base.me_evp == NULL)
			return (EINVAL);
		if (*(int *)data != sc->sc_base.me_evp->io->p_pgid)
d871 1
a871 1
	error = wskbd_displayioctl(&sc->sc_base.me_dv, cmd, data, flag, p);
d880 6
a885 2
wskbd_displayioctl(struct device *dev, u_long cmd, caddr_t data, int flag,
    struct proc *p)
d966 5
d1000 1
a1000 2

		len = umdp->maplen * sizeof(struct wscons_keymap);
d1040 5
a1044 5
			md.layout = enc;
			error = wskbd_load_keymap(&md, &sc->sc_map,
						  &sc->sc_maplen);
			if (error)
				return(error);
d1080 4
a1083 1
wskbdpoll(dev_t dev, int events, struct proc *p)
d1087 1
a1087 3
	if (sc->sc_base.me_evp == NULL)
		return (EINVAL);
	return (wsevent_poll(sc->sc_base.me_evp, events, p));
d1107 4
a1110 2
struct wsevsrc *
wskbd_set_console_display(struct device *displaydv, struct wsevsrc *me)
d1114 6
a1119 7
	if (sc == NULL)
		return (NULL);
	sc->sc_base.me_dispdv = displaydv;
#if NWSMUX > 0
	(void)wsmux_attach_sc((struct wsmux_softc *)me, &sc->sc_base);
#endif
	return (&sc->sc_base);
d1123 3
a1125 1
wskbd_set_display(struct device *dv, struct wsevsrc *me)
d1128 1
a1128 1
	struct device *displaydv = me != NULL ? me->me_dispdv : NULL;
d1132 2
a1133 2
	DPRINTF(("wskbd_set_display: %s me=%p odisp=%p disp=%p cons=%d\n",
		 dv->dv_xname, me, sc->sc_base.me_dispdv, displaydv, 
d1139 2
a1140 2
	if (displaydv != NULL) {
		if (sc->sc_base.me_dispdv != NULL)
d1143 1
a1143 1
		if (sc->sc_base.me_dispdv == NULL)
d1147 3
a1149 2
	odisplaydv = sc->sc_base.me_dispdv;
	sc->sc_base.me_dispdv = NULL;
a1150 1
	sc->sc_base.me_dispdv = displaydv;
d1152 1
a1152 1
		sc->sc_base.me_dispdv = odisplaydv;
d1158 1
a1158 1
		       sc->sc_base.me_dv.dv_xname, displaydv->dv_xname);
d1161 1
a1161 1
		       sc->sc_base.me_dv.dv_xname, odisplaydv->dv_xname);
d1166 11
a1176 1
#endif	/* NWSDISPLAY > 0 */
a1177 1
#if NWSMUX > 0
d1179 3
a1181 1
wskbd_add_mux(int unit, struct wsmux_softc *muxsc)
d1185 2
d1191 1
a1191 1
	if (sc->sc_base.me_parent != NULL || sc->sc_base.me_evp != NULL)
d1194 2
a1195 1
	return (wsmux_attach_sc(muxsc, &sc->sc_base));
d1197 17
a1213 1
#endif
d1219 2
a1220 1
wskbd_cngetc(dev_t dev)
d1238 1
a1238 2
			if (KS_GROUP(ks) == KS_GROUP_Ascii)
				return (KS_VALUE(ks));	
d1250 3
a1252 1
wskbd_cnpollc(dev_t dev, int poll)
d1267 3
a1269 1
wskbd_cnbell(dev_t dev, u_int pitch, u_int period, u_int volume)
d1280 3
a1282 2
void
update_leds(struct wskbd_internal *id)
d1303 6
a1308 2
void
update_modifier(struct wskbd_internal *id, u_int type, int toggle, int mask)
d1323 3
a1325 2
change_displayparam(struct wskbd_softc *sc, int param, int updown,
    int wraparound)
d1330 3
d1334 1
a1334 1
	res = wsdisplay_param(sc->sc_base.me_dispdv, WSDISPLAYIO_GETPARAM, &dp);
d1345 1
a1345 1
	wsdisplay_param(sc->sc_base.me_dispdv, WSDISPLAYIO_SETPARAM, &dp);
d1350 4
a1353 2
internal_command(struct wskbd_softc *sc, u_int *type, keysym_t ksym,
    keysym_t ksym2)
a1372 1
#ifdef SCROLLBACK_SUPPORT
a1393 1
#endif
d1399 1
d1401 1
a1401 1
	if (ksym == KS_Cmd_Debugger) {
a1406 1
	}
a1409 4
	if (sc->sc_base.me_dispdv == NULL)
		return (0);

	switch (ksym) {
d1422 3
a1424 1
		wsdisplay_switch(sc->sc_displaydv, ksym - KS_Cmd_Screen0, 0);
d1427 2
a1428 1
		wsdisplay_reset(sc->sc_displaydv, WSDISPLAY_RESETEMUL);
d1431 2
a1432 1
		wsdisplay_reset(sc->sc_displaydv, WSDISPLAY_RESETCLOSE);
d1446 2
a1447 2
		    ksym == KS_Cmd_BacklightOff ? -1 : 1,
		    ksym == KS_Cmd_BacklightToggle ? 1 : 0);
d1453 2
a1454 2
		    ksym == KS_Cmd_BrightnessDown ? -1 : 1,
		    ksym == KS_Cmd_BrightnessRotate ? 1 : 0);
d1460 2
a1461 2
		    ksym == KS_Cmd_ContrastDown ? -1 : 1,
		    ksym == KS_Cmd_ContrastRotate ? 1 : 0);
d1469 4
a1472 1
wskbd_translate(struct wskbd_internal *id, u_int type, int value)
d1480 5
a1484 5
		id->t_modifiers &= ~(MOD_SHIFT_L | MOD_SHIFT_R |
		    MOD_CONTROL_L | MOD_CONTROL_R |
		    MOD_META_L | MOD_META_R |
		    MOD_MODESHIFT | MOD_MODELOCK |
		    MOD_COMMAND | MOD_COMMAND1 | MOD_COMMAND2);
d1506 1
a1506 1
		    kp->group1[0]);
d1566 1
a1566 2
			return (0);
		break;
d1683 1
a1683 1
				res |= 0x80;
@


1.1.1.3
log
@timecounters
@
text
@d679 1
a679 2
	microtime(&xxxtime);
	TIMEVAL_TO_TIMESPEC(&xxxtime, &ev->time);
@


1.1.1.4
log
@timecounters
@
text
@a583 1
	struct timeval xxxtime;
@


1.1.1.5
log
@timecounters
@
text
@d584 1
a653 1
	struct timeval xxxtime;
@


1.1.1.6
log
@merge more OpenBSD-HEAD stuff
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.45 2005/07/08 02:26:07 marc Exp $ */
d123 1
d125 1
d1475 1
a1476 1
#endif
@


1.1.1.7
log
@import current wscons & friends code from OpenBSD
in the hope it will be useful
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.53 2006/08/14 17:41:08 miod Exp $ */
d82 5
a112 1
#include "audio.h"		/* NAUDIO (mixer tuning) */
a113 1
#include "wskbd.h"
a115 8
#ifdef	SMALL_KERNEL
#undef	NWSKBD_HOTKEY
#define	NWSKBD_HOTKEY 0
#else
#define	BURNER_SUPPORT
#define	SCROLLBACK_SUPPORT
#endif

d207 5
d283 1
a283 6
	wskbd_displayioctl,
#if NWSDISPLAY > 0
	wskbd_set_display
#else
	NULL
#endif
a431 21

#if WSDISPLAY > 0 && NWSMUX == 0
	if (ap->console == 0) {
		/*
		 * In the non-wsmux world, always connect wskbd0 and wsdisplay0
		 * together.
		 */
		extern struct cfdriver wsdisplay_cd;

		if (wsdisplay_cd.cd_ndevs != 0 && self->dv_unit == 0) {
			if (wskbd_set_display(self,
			    wsdisplay_cd.cd_devs[0]) == 0)
				wsdisplay_set_kbd(wsdisplay_cd.cd_devs[0],
				    (struct wsevsrc *)sc);
		}
	}
#endif

#if NWSKBD_HOTKEY > 0
	wskbd_hotkey_init();
#endif
d651 1
d678 2
a679 1
	nanotime(&ev->time);
a957 12
	case WSKBDIO_BELL:
	case WSKBDIO_COMPLEXBELL:
	case WSKBDIO_SETBELL:
	case WSKBDIO_SETKEYREPEAT:
	case WSKBDIO_SETDEFAULTKEYREPEAT:
	case WSKBDIO_SETMAP:
	case WSKBDIO_SETENCODING:
		if ((flag & FWRITE) == 0)
			return (EACCES);
	}

	switch (cmd) {
d970 2
d976 2
d984 2
d1022 2
d1051 2
d1085 2
d1178 1
a1178 1
wskbd_set_display(struct device *dv, struct device *displaydv)
d1181 1
d1185 2
a1186 2
	DPRINTF(("wskbd_set_display: %s odisp=%p disp=%p cons=%d\n",
		 dv->dv_xname, sc->sc_base.me_dispdv, displaydv, 
a1486 6
#if NWSDISPLAY > 0
		if (sc != NULL && sc->sc_repeating) {
			sc->sc_repeating = 0;
			timeout_del(&sc->sc_repeat_ch);
		}
#endif
a1616 17
#if NWSKBD_HOTKEY > 0
	/* Submit Audio keys for hotkey processing */
	if (KS_GROUP(ksym) == KS_GROUP_Function) {
		switch (ksym) {
#if NAUDIO > 0
		case KS_AudioMute:
		case KS_AudioLower:
		case KS_AudioRaise:
			wskbd_hotkey_put(ksym);
			return (0);
#endif
		default:
			break;
		}
	}
#endif

@


1.1.1.8
log
@no nanotime for us yet
@
text
@a676 1
	struct timeval xxxtime;
d703 1
a703 2
	microtime(&xxxtime);
	TIMEVAL_TO_TIMESPEC(&xxxtime, &ev->time);
@


