head	1.1;
branch	1.1.1;
access;
symbols
	tg-beforemerge-ksrc10:1.1.1.6
	MIRBSD_10:1.1.1.6.0.2
	MIRBSD_10_BASE:1.1.1.6
	cvs-200702062030:1.1.1.5
	MIRBSD_9_BASE:1.1.1.4
	MIRBSD_8:1.1.1.4.0.2
	MIRBSD_8_BASE:1.1.1.4
	cvs-200507032030:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2005.02.05.17.28.47;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.28.47;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.07.04.01.13.58;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	76bf42c88d6bc5d8;

1.1.1.3
date	2005.07.04.02.40.54;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	154642c8a1ccf9ed;

1.1.1.4
date	2005.07.04.02.41.22;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	20ea42c8a1e819cf;

1.1.1.5
date	2007.02.06.20.51.58;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	10045C8EA6658CBB47A;

1.1.1.6
date	2007.02.06.23.12.43;	author tg;	state Exp;
branches;
next	;
commitid	10045C90B81112B5A51;


desc
@@


1.1
log
@Initial revision
@
text
@/*	$OpenBSD: wsmux.c,v 1.11 2003/09/23 16:51:12 millert Exp $	*/
/*	$NetBSD: wsmux.c,v 1.9 2000/05/28 10:33:14 takemura Exp $	*/

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * Author: Lennart Augustsson <augustss@@carlstedt.se>
 *         Carlstedt Research & Technology
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include "wsmux.h"
#include "wsdisplay.h"
#include "wskbd.h"

#if NWSMUX > 0 || (NWSDISPLAY > 0 && NWSKBD > 0)

/*
 * wscons mux device.
 *
 * The mux device is a collection of real mice and keyboards and acts as 
 * a merge point for all the events from the different real devices.
 */

#include <sys/param.h>
#include <sys/conf.h>
#include <sys/ioctl.h>
#include <sys/fcntl.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/proc.h>
#include <sys/queue.h>
#include <sys/syslog.h>
#include <sys/systm.h>
#include <sys/tty.h>
#include <sys/signalvar.h>
#include <sys/device.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wseventvar.h>
#include <dev/wscons/wscons_callbacks.h>
#include <dev/wscons/wsmuxvar.h>

#ifdef WSMUX_DEBUG
#define DPRINTF(x)	if (wsmuxdebug) printf x
int	wsmuxdebug = 0;
#else
#define DPRINTF(x)
#endif

struct wsplink {
	LIST_ENTRY(wsplink) next;
	int type;
	struct wsmux_softc *mux; /* our mux device */
	/* The rest of the fields reflect a value in the multiplexee. */
	struct device *sc;	/* softc */
	struct wseventvar *sc_mevents; /* event var */
	struct wsmux_softc **sc_muxp; /* pointer to us */
	struct wsmuxops *sc_ops;
};

int wsmuxdoclose(struct device *, int, int, struct proc *);
int wsmux_set_display(struct device *, struct wsmux_softc *);
int wsmux_isset_display(struct device *);

#if NWSMUX > 0
void wsmuxattach(int);

struct wsmuxops wsmux_muxops = {
	wsmuxopen, wsmuxdoclose, wsmuxdoioctl, wsmux_displayioctl,
	wsmux_set_display, wsmux_isset_display
};

void wsmux_setmax(int n);

int nwsmux = 0;
struct wsmux_softc **wsmuxdevs = NULL;

void
wsmux_setmax(n)
	int n;
{
	int i;
	struct wsmux_softc **wsmuxdevs_tmp = NULL;

	if (n >= nwsmux) {
		if (wsmuxdevs != NULL) {
			wsmuxdevs_tmp = malloc(nwsmux * sizeof(*wsmuxdevs_tmp),
			    M_DEVBUF, M_NOWAIT);
			if (wsmuxdevs_tmp == 0)
				panic("wsmux_setmax: no mem");
			for (i = 0; i < nwsmux; i++)
				wsmuxdevs_tmp[i] = wsmuxdevs[i];
			free(wsmuxdevs, M_DEVBUF);
		}

		wsmuxdevs = malloc((n + 1) * sizeof(*wsmuxdevs), 
		    M_DEVBUF, M_NOWAIT);
		if (wsmuxdevs == NULL)
			panic("wsmux_setmax: no memory");
		memset(wsmuxdevs, 0, (n + 1) * sizeof(*wsmuxdevs));
		if (wsmuxdevs_tmp != NULL) {
			for (i = 0; i < nwsmux; i++)
				wsmuxdevs[i] = wsmuxdevs_tmp[i];
			free(wsmuxdevs_tmp, M_DEVBUF);
		}
		nwsmux = n + 1;
	}
}

/* From upper level */
void
wsmuxattach(n)
	int n;
{
	int i;

	wsmux_setmax(n);	/* Make sure we have room for all muxes. */

	/* Make sure all muxes are there. */
	for (i = 0; i < nwsmux; i++)
		if (wsmuxdevs[i] == NULL)
			wsmuxdevs[i] = wsmux_create("wsmux", i);
}

/* From mouse or keyboard. */
void
wsmux_attach(n, type, dsc, ev, psp, ops)
	int n;
	int type;
        struct device *dsc;
	struct wseventvar *ev;
	struct wsmux_softc **psp;
	struct wsmuxops *ops;
{
	struct wsmux_softc *sc;
	int error;

	DPRINTF(("wsmux_attach: n=%d\n", n));
	wsmux_setmax(n);
	sc = wsmuxdevs[n];
	if (sc == 0) {
		sc = wsmux_create("wsmux", n);
		if (sc == 0) {
			printf("wsmux: attach out of memory\n");
			return;
		}
		wsmuxdevs[n] = sc;
	}
	error = wsmux_attach_sc(sc, type, dsc, ev, psp, ops);
	if (error)
		printf("wsmux_attach: error=%d\n", error);
}

/* From mouse or keyboard. */
void
wsmux_detach(n, dsc)
	int n;
        struct device *dsc;
{
#ifdef DIAGNOSTIC
	int error;

	if (n >= nwsmux || n < 0) {
		printf("wsmux_detach: detach is out of range\n");
		return;
	}
	if ((error = wsmux_detach_sc(wsmuxdevs[n], dsc)))
		printf("wsmux_detach: error=%d\n", error);
#else
	(void)wsmux_detach_sc(wsmuxdevs[n], dsc);
#endif
}

int
wsmuxopen(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
{
	struct wsmux_softc *sc;
	struct wsplink *m;
	int unit, error, nopen, lasterror;

	unit = minor(dev);
	if (unit >= nwsmux ||	/* make sure it was attached */
	    (sc = wsmuxdevs[unit]) == NULL)
		return (ENXIO);

	DPRINTF(("wsmuxopen: %s: sc=%p\n", sc->sc_dv.dv_xname, sc));
	if (!(flags & FREAD)) {
		/* Not opening for read, only ioctl is available. */
		return (0);
	}

	if (sc->sc_events.io)
		return (EBUSY);

	sc->sc_events.io = p;
	sc->sc_flags = flags;
	sc->sc_mode = mode;
	sc->sc_p = p;
	wsevent_init(&sc->sc_events);		/* may cause sleep */

	nopen = 0;
	lasterror = 0;
	for (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {
		if (!m->sc_mevents->io && !*m->sc_muxp) {
			DPRINTF(("wsmuxopen: %s: m=%p dev=%s\n", 
				 sc->sc_dv.dv_xname, m, m->sc->dv_xname));
			error = m->sc_ops->dopen(makedev(0, m->sc->dv_unit),
						 flags, mode, p);
			if (error) {
				/* Ignore opens that fail */
				lasterror = error;
				DPRINTF(("wsmuxopen: open failed %d\n", 
					 error));
			} else {
				nopen++;
				*m->sc_muxp = sc;
			}
		}
	}

	if (nopen == 0 && lasterror != 0) {
		wsevent_fini(&sc->sc_events);
		sc->sc_events.io = NULL;
		return (lasterror);
	}

	return (0);
}

int
wsmuxclose(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
{
	return wsmuxdoclose(&wsmuxdevs[minor(dev)]->sc_dv, flags, mode, p);
}

int
wsmuxread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	struct wsmux_softc *sc = wsmuxdevs[minor(dev)];

	if (!sc->sc_events.io)
		return (EACCES);

	return (wsevent_read(&sc->sc_events, uio, flags));
}

int
wsmuxioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	return wsmuxdoioctl(&wsmuxdevs[minor(dev)]->sc_dv, cmd, data, flag, p);
}

int
wsmuxpoll(dev, events, p)
	dev_t dev;
	int events;
	struct proc *p;
{
	struct wsmux_softc *sc = wsmuxdevs[minor(dev)];

	if (!sc->sc_events.io)
		return (EACCES);

	return (wsevent_poll(&sc->sc_events, events, p));
}

int
wsmux_add_mux(unit, muxsc)
	int unit;
	struct wsmux_softc *muxsc;
{
	struct wsmux_softc *sc, *m;

	if (unit < 0 || unit >= nwsmux || (sc = wsmuxdevs[unit]) == NULL)
		return (ENXIO);

	DPRINTF(("wsmux_add_mux: %s to %s\n", sc->sc_dv.dv_xname,
		 muxsc->sc_dv.dv_xname));

	if (sc->sc_mux || sc->sc_events.io)
		return (EBUSY);

	/* The mux we are adding must not be an ancestor of it. */
	for (m = muxsc->sc_mux; m; m = m->sc_mux)
		if (m == sc)
			return (EINVAL);

	return (wsmux_attach_sc(muxsc, WSMUX_MUX, &sc->sc_dv, &sc->sc_events, 
				&sc->sc_mux, &wsmux_muxops));
}

int
wsmux_rem_mux(unit, muxsc)
	int unit;
	struct wsmux_softc *muxsc;
{
	struct wsmux_softc *sc;

	if (unit < 0 || unit >= nwsmux || (sc = wsmuxdevs[unit]) == NULL)
		return (ENXIO);
	
	DPRINTF(("wsmux_rem_mux: %s from %s\n", sc->sc_dv.dv_xname,
		 muxsc->sc_dv.dv_xname));

	return (wsmux_detach_sc(muxsc, &sc->sc_dv));
}

#endif /* NWSMUX > 0 */

struct wsmux_softc *
wsmux_create(name, unit)
	const char *name;
	int unit;
{
	struct wsmux_softc *sc;

	DPRINTF(("wsmux_create: allocating\n"));
	sc = malloc(sizeof *sc, M_DEVBUF, M_NOWAIT);
	if (!sc)
		return (0);
	memset(sc, 0, sizeof *sc);
	LIST_INIT(&sc->sc_reals);
	snprintf(sc->sc_dv.dv_xname, sizeof sc->sc_dv.dv_xname,
		 "%s%d", name, unit);
	sc->sc_dv.dv_unit = unit;
	return (sc);
}

int
wsmux_attach_sc(sc, type, dsc, ev, psp, ops)
	struct wsmux_softc *sc;
	int type;
        struct device *dsc;
	struct wseventvar *ev;
	struct wsmux_softc **psp;
	struct wsmuxops *ops;
{
	struct wsplink *m;
	int error;

	DPRINTF(("wsmux_attach_sc: %s: type=%d dsc=%p, *psp=%p\n",
		 sc->sc_dv.dv_xname, type, dsc, *psp));
	m = malloc(sizeof *m, M_DEVBUF, M_NOWAIT);
	if (m == 0)
		return (ENOMEM);
	m->type = type;
	m->mux = sc;
	m->sc = dsc;
	m->sc_mevents = ev;
	m->sc_muxp = psp;
	m->sc_ops = ops;
	LIST_INSERT_HEAD(&sc->sc_reals, m, next);

	if (sc->sc_displaydv) {
		/* This is a display mux, so attach the new device to it. */
		DPRINTF(("wsmux_attach_sc: %s: set display %p\n", 
			 sc->sc_dv.dv_xname, sc->sc_displaydv));
		error = 0;
		if (m->sc_ops->dsetdisplay) {
			error = m->sc_ops->dsetdisplay(m->sc, sc);
			/* Ignore that the console already has a display. */
			if (error == EBUSY)
				error = 0;
			if (!error) {
				*m->sc_muxp = sc;
#ifdef WSDISPLAY_COMPAT_RAWKBD
				DPRINTF(("wsmux_attach_sc: on %s set rawkbd=%d\n",
					 m->sc->dv_xname, sc->sc_rawkbd));
				(void)m->sc_ops->dioctl(m->sc, 
					     WSKBDIO_SETMODE, 
					     (caddr_t)&sc->sc_rawkbd,
					     0, 0);
#endif
			}
		}
	} else if (sc->sc_events.io) {
		/* Mux is open, so open the new subdevice */
		DPRINTF(("wsmux_attach_sc: %s: calling open of %s\n",
			 sc->sc_dv.dv_xname, m->sc->dv_xname));
		/* mux already open, join in */
		error = m->sc_ops->dopen(makedev(0, m->sc->dv_unit),
					 sc->sc_flags, sc->sc_mode, sc->sc_p);
		if (!error)
			*m->sc_muxp = sc;
	} else {
		DPRINTF(("wsmux_attach_sc: %s not open\n",
			 sc->sc_dv.dv_xname));
		error = 0;
	}
	DPRINTF(("wsmux_attach_sc: done sc=%p psp=%p *psp=%p\n", 
		 sc, psp, *psp));

	return (error);
}

int
wsmux_detach_sc(sc, dsc)
	struct wsmux_softc *sc;
        struct device *dsc;
{
	struct wsplink *m;
	int error = 0;

	DPRINTF(("wsmux_detach_sc: %s: dsc=%p\n", sc->sc_dv.dv_xname, dsc));
#ifdef DIAGNOSTIC
	if (sc == 0) {
		printf("wsmux_detach_sc: not allocated\n");
		return (ENXIO);
	}
#endif

	for (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {
		if (m->sc == dsc)
			break;
	}
#ifdef DIAGNOSTIC
	if (!m) {
		printf("wsmux_detach_sc: not found\n");
		return (ENXIO);
	}
#endif
	if (sc->sc_displaydv ||
	    (m->sc_ops->dissetdisplay && m->sc_ops->dissetdisplay(m->sc))) {
		if (m->sc_ops->dsetdisplay)
			error = m->sc_ops->dsetdisplay(m->sc, 0);
		if (error)
			return (error);
		*m->sc_muxp = 0;
	} else if (*m->sc_muxp) {
		DPRINTF(("wsmux_detach_sc: close\n"));
		/* mux device is open, so close multiplexee */
		m->sc_ops->dclose(m->sc, FREAD, 0, 0);
		*m->sc_muxp = 0;
	}

	LIST_REMOVE(m, next);

	free(m, M_DEVBUF);
	DPRINTF(("wsmux_detach_sc: done sc=%p\n", sc));
	return (0);
}

int wsmuxdoclose(dv, flags, mode, p)
	struct device *dv;
	int flags, mode;
	struct proc *p;
{
	struct wsmux_softc *sc = (struct wsmux_softc *)dv;
	struct wsplink *m;

	DPRINTF(("wsmuxclose: %s: sc=%p\n", sc->sc_dv.dv_xname, sc));
	if (!(flags & FREAD)) {
		/* Nothing to do, because open didn't do anything. */
		return (0);
	}

	for (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {
		if (*m->sc_muxp == sc) {
			DPRINTF(("wsmuxclose %s: m=%p dev=%s\n", 
				 sc->sc_dv.dv_xname, m, m->sc->dv_xname));
			m->sc_ops->dclose(m->sc, flags, mode, p);
			*m->sc_muxp = 0;
		}
	}

	wsevent_fini(&sc->sc_events);
	sc->sc_events.io = NULL;

	return (0);
}

int
wsmuxdoioctl(dv, cmd, data, flag, p)
	struct device *dv;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	struct wsmux_softc *sc = (struct wsmux_softc *)dv;
	struct wsplink *m;
	int error, ok;
	int s, put, get, n;
	struct wseventvar *evar;
	struct wscons_event *ev;
	struct timeval xxxtime;
	struct wsmux_device_list *l;

	DPRINTF(("wsmuxdoioctl: %s: sc=%p, cmd=%08lx\n", 
		 sc->sc_dv.dv_xname, sc, cmd));

	switch (cmd) {
	case WSMUX_INJECTEVENT:
		/* Inject an event, e.g., from moused. */
		if (!sc->sc_events.io)
			return (EACCES);

		evar = &sc->sc_events;
		s = spltty();
		get = evar->get;
		put = evar->put;
		if (++put % WSEVENT_QSIZE == get) {
			put--;
			splx(s);
			return (ENOSPC);
		}
		if (put >= WSEVENT_QSIZE)
			put = 0;
		ev = &evar->q[put];
		*ev = *(struct wscons_event *)data;
		microtime(&xxxtime);
		TIMEVAL_TO_TIMESPEC(&xxxtime, &ev->time);
		evar->put = put;
		WSEVENT_WAKEUP(evar);
		splx(s);
		return (0);
	case WSMUX_ADD_DEVICE:
#define d ((struct wsmux_device *)data)
		switch (d->type) {
#if NWSMOUSE > 0
		case WSMUX_MOUSE:
			return (wsmouse_add_mux(d->idx, sc));
#endif
#if NWSKBD > 0
		case WSMUX_KBD:
			return (wskbd_add_mux(d->idx, sc));
#endif
#if NWSMUX > 0
		case WSMUX_MUX:
			return (wsmux_add_mux(d->idx, sc));
#endif
		default:
			return (EINVAL);
		}
	case WSMUX_REMOVE_DEVICE:
		switch (d->type) {
#if NWSMOUSE > 0
		case WSMUX_MOUSE:
			return (wsmouse_rem_mux(d->idx, sc));
#endif
#if NWSKBD > 0
		case WSMUX_KBD:
			return (wskbd_rem_mux(d->idx, sc));
#endif
#if NWSMUX > 0
		case WSMUX_MUX:
			return (wsmux_rem_mux(d->idx, sc));
#endif
		default:
			return (EINVAL);
		}
#undef d
	case WSMUX_LIST_DEVICES:
		l = (struct wsmux_device_list *)data;
		for (n = 0, m = LIST_FIRST(&sc->sc_reals);
		     n < WSMUX_MAXDEV && m != NULL;
		     m = LIST_NEXT(m, next)) {
			l->devices[n].type = m->type;
			l->devices[n].idx = m->sc->dv_unit;
			n++;
		}
		l->ndevices = n;
		return (0);
#ifdef WSDISPLAY_COMPAT_RAWKBD
	case WSKBDIO_SETMODE:
		sc->sc_rawkbd = *(int *)data;
		DPRINTF(("wsmuxdoioctl: save rawkbd = %d\n", sc->sc_rawkbd));
		break;
#endif
	case FIOASYNC:
		sc->sc_events.async = *(int *)data != 0;
		return (0);
	case TIOCSPGRP:
		if (*(int *)data != sc->sc_events.io->p_pgid)
			return (EPERM);
		return (0);
	default:
		break;
	}

	if (sc->sc_events.io == NULL && sc->sc_displaydv == NULL)
		return (EACCES);

	/* Return 0 if any of the ioctl() succeeds, otherwise the last error */
	error = 0;
	ok = 0;
	for (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {
		DPRINTF(("wsmuxdoioctl: m=%p *m->sc_muxp=%p sc=%p\n",
			 m, *m->sc_muxp, sc));
		if (*m->sc_muxp == sc) {
			DPRINTF(("wsmuxdoioctl: %s: m=%p dev=%s\n", 
				 sc->sc_dv.dv_xname, m, m->sc->dv_xname));
			error = m->sc_ops->dioctl(m->sc, cmd, data, flag, p);
			if (!error)
				ok = 1;
		}
	}
	if (ok)
		error = 0;

	return (error);
}

int
wsmux_displayioctl(dv, cmd, data, flag, p)
	struct device *dv;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	struct wsmux_softc *sc = (struct wsmux_softc *)dv;
	struct wsplink *m;
	int error, ok;

	DPRINTF(("wsmux_displayioctl: %s: sc=%p, cmd=%08lx\n", 
		 sc->sc_dv.dv_xname, sc, cmd));

#ifdef WSDISPLAY_COMPAT_RAWKBD
	if (cmd == WSKBDIO_SETMODE) {
		sc->sc_rawkbd = *(int *)data;
		DPRINTF(("wsmux_displayioctl: rawkbd = %d\n", sc->sc_rawkbd));
	}		
#endif

	/* 
	 * Return 0 if any of the ioctl() succeeds, otherwise the last error.
	 * Return -1 if no mux component accepts the ioctl.
	 */
	error = -1;
	ok = 0;
	for (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {
		DPRINTF(("wsmux_displayioctl: m=%p sc=%p sc_muxp=%p\n", 
			 m, sc, *m->sc_muxp));
		if (m->sc_ops->ddispioctl && *m->sc_muxp == sc) {
			error = m->sc_ops->ddispioctl(m->sc, cmd, data,
						      flag, p);
			DPRINTF(("wsmux_displayioctl: m=%p dev=%s ==> %d\n", 
				 m, m->sc->dv_xname, error));
			if (!error)
				ok = 1;
		}
	}
	if (ok)
		error = 0;

	return (error);
}

int
wsmux_set_display(dv, muxsc)
	struct device *dv;
	struct wsmux_softc *muxsc;
{
	struct wsmux_softc *sc = (struct wsmux_softc *)dv;
	struct wsmux_softc *nsc = muxsc ? sc : 0;
	struct device *displaydv = muxsc ? muxsc->sc_displaydv : 0;
	struct device *odisplaydv;
	struct wsplink *m;
	int error, ok;

	DPRINTF(("wsmux_set_display: %s: displaydv=%p\n",
		 sc->sc_dv.dv_xname, displaydv));

	if (displaydv) {
		if (sc->sc_displaydv)
			return (EBUSY);
	} else {
		if (sc->sc_displaydv == NULL)
			return (ENXIO);
	}

	odisplaydv = sc->sc_displaydv;
	sc->sc_displaydv = displaydv;

	if (displaydv)
		printf("%s: connecting to %s\n",
		       sc->sc_dv.dv_xname, displaydv->dv_xname);
	ok = 0;
	error = 0;
	for (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {
		if (m->sc_ops->dsetdisplay &&
		    (nsc ? m->sc_mevents->io == 0 && *m->sc_muxp == 0 : 
		           *m->sc_muxp == sc)) {
			error = m->sc_ops->dsetdisplay(m->sc, nsc);
			DPRINTF(("wsmux_set_display: m=%p dev=%s error=%d\n", 
				 m, m->sc->dv_xname, error));
			if (!error) {
				ok = 1;
				*m->sc_muxp = nsc;
#ifdef WSDISPLAY_COMPAT_RAWKBD
				DPRINTF(("wsmux_set_display: on %s set rawkbd=%d\n",
					 m->sc->dv_xname, sc->sc_rawkbd));
				(void)m->sc_ops->dioctl(m->sc, 
					     WSKBDIO_SETMODE, 
					     (caddr_t)&sc->sc_rawkbd,
					     0, 0);
#endif
			}
		}
	}
	if (ok)
		error = 0;

	if (displaydv == NULL)
		printf("%s: disconnecting from %s\n", 
		       sc->sc_dv.dv_xname, odisplaydv->dv_xname);

	return (error);
}

int
wsmux_isset_display(dv)
	struct device *dv;
{
	struct wsmux_softc *sc = (struct wsmux_softc *)dv;

	if (sc->sc_displaydv != NULL)
		return (1);

	return (0);
}

#endif /* NWSMUX > 0 || (NWSDISPLAY > 0 && NWSKBD > 0) */
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@lastly some drivers
@
text
@d1 2
a2 2
/*	$OpenBSD: wsmux.c,v 1.14 2005/05/15 19:03:47 deraadt Exp $	*/
/*      $NetBSD: wsmux.c,v 1.37 2005/04/30 03:47:12 augustss Exp $      */
d5 1
a5 1
 * Copyright (c) 1998, 2005 The NetBSD Foundation, Inc.
d44 2
a67 1
#include <dev/wscons/wsksymdef.h>
a73 1
#define DPRINTFN(n,x)	if (wsmuxdebug > (n)) printf x
a76 1
#define DPRINTFN(n,x)
d79 10
a88 13
/*
 * The wsmux pseudo device is used to multiplex events from several wsmouse,
 * wskbd, and/or wsmux devices together.
 * The devices connected together form a tree with muxes in the interior
 * and real devices (mouse and kbd) at the leaves.  The special case of
 * a tree with one node (mux or other) is supported as well.
 * Only the device at the root of the tree can be opened (if a non-root
 * device is opened the subtree rooted at that point is severed from the
 * containing tree).  When the root is opened it allocates a wseventvar
 * struct which all the nodes in the tree will send their events too.
 * An ioctl() performed on the root is propagated to all the nodes.
 * There are also ioctl() operations to add and remove nodes from a tree.
 */
d90 11
a100 2
int	wsmux_mux_open(struct wsevsrc *, struct wseventvar *);
int	wsmux_mux_close(struct wsevsrc *);
d102 1
a102 1
void	wsmux_do_open(struct wsmux_softc *, struct wseventvar *);
d104 2
a105 6
void	wsmux_do_close(struct wsmux_softc *);
#if NWSDISPLAY > 0
int	wsmux_evsrc_set_display(struct device *, struct wsevsrc *);
#else
#define wsmux_evsrc_set_display NULL
#endif
d107 6
a112 3
int	wsmux_do_displayioctl(struct device *dev, u_long cmd, caddr_t data,
	    int flag, struct proc *p);
int	wsmux_do_ioctl(struct device *, u_long, caddr_t,int,struct proc *);
d114 24
a137 9
int	wsmux_add_mux(int, struct wsmux_softc *);

void	wsmuxattach(int);

struct wssrcops wsmux_srcops = {
	WSMUX_MUX,
	wsmux_mux_open, wsmux_mux_close, wsmux_do_ioctl, wsmux_do_displayioctl,
	wsmux_evsrc_set_display
};
d141 2
a142 1
wsmuxattach(int n)
d144 8
d154 9
a162 7
/* Keep track of all muxes that have been allocated */
int nwsmux = 0;
struct wsmux_softc **wsmuxdevs = NULL;

/* Return mux n, create if necessary */
struct wsmux_softc *
wsmux_getmux(int n)
d165 1
a165 21
	struct wsmux_softc **new, **old;
	int i;

	/* Make sure there is room for mux n in the table */
	if (n >= nwsmux) {
		old = wsmuxdevs;
		new = (struct wsmux_softc **)
		    malloc((n + 1) * sizeof (*wsmuxdevs), M_DEVBUF, M_NOWAIT);
		if (new == NULL) {
			printf("wsmux_getmux: no memory for mux %d\n", n);
			return (NULL);
		}
		if (old != NULL)
			bcopy(old, new, nwsmux * sizeof(*wsmuxdevs));
		for (i = nwsmux; i < (n + 1); i++)
			new[i] = NULL;
		wsmuxdevs = new;
		nwsmux = n + 1;
		if (old != NULL)
			free(old, M_DEVBUF);
	}
d167 2
d170 1
a170 1
	if (sc == NULL) {
d172 1
a172 1
		if (sc == NULL)
d174 2
d178 23
a200 1
	return (sc);
a202 3
/*
 * open() of the pseudo device from device table.
 */
d204 4
a207 1
wsmuxopen(dev_t dev, int flags, int mode, struct proc *p)
d210 2
a211 2
	struct wseventvar *evar;
	int unit;
d214 2
a215 2
	sc = wsmux_getmux(unit);
	if (sc == NULL)
d218 2
a219 3
	DPRINTF(("wsmuxopen: %s: sc=%p p=%p\n", sc->sc_base.me_dv.dv_xname, sc, p));
	
	if ((flags & (FREAD | FWRITE)) == FWRITE) {
d224 1
a224 8
	if (sc->sc_base.me_parent != NULL) {
		/* Grab the mux out of the greedy hands of the parent mux. */
		DPRINTF(("wsmuxopen: detach\n"));
		wsmux_detach_sc(&sc->sc_base);
	}

	if (sc->sc_base.me_evp != NULL)
		/* Already open. */
d227 25
a251 6
	evar = &sc->sc_base.me_evar;
	wsevent_init(evar);
	evar->io = p;
#ifdef WSDISPLAY_COMPAT_RAWKBD
	sc->sc_rawkbd = 0;
#endif
d253 5
a257 1
	wsmux_do_open(sc, evar);
a261 3
/*
 * Open of a mux via the parent mux.
 */
d263 13
a275 1
wsmux_mux_open(struct wsevsrc *me, struct wseventvar *evar)
d277 1
a277 1
	struct wsmux_softc *sc = (struct wsmux_softc *)me;
d279 2
a280 10
#ifdef DIAGNOSTIC
	if (sc->sc_base.me_evp != NULL) {
		printf("wsmux_mux_open: busy\n");
		return (EBUSY);
	}
	if (sc->sc_base.me_parent == NULL) {
		printf("wsmux_mux_open: no parent\n");
		return (EINVAL);
	}
#endif
d282 2
a283 1
	wsmux_do_open(sc, evar);
d285 9
a293 1
	return (0);
d296 5
a300 3
/* Common part of opening a mux. */
void
wsmux_do_open(struct wsmux_softc *sc, struct wseventvar *evar)
d302 1
a302 4
	struct wsevsrc *me;
#ifdef DIAGNOSTIC
	int error;
#endif
d304 2
a305 1
	sc->sc_base.me_evp = evar; /* remember event variable, mark as open */
d307 1
a307 22
	/* Open all children. */
	CIRCLEQ_FOREACH(me, &sc->sc_cld, me_next) {
		DPRINTF(("wsmuxopen: %s: m=%p dev=%s\n",
			 sc->sc_base.me_dv.dv_xname, me, me->me_dv.dv_xname));
#ifdef DIAGNOSTIC
		if (me->me_evp != NULL) {
			printf("wsmuxopen: dev already in use\n");
			continue;
		}
		if (me->me_parent != sc) {
			printf("wsmux_do_open: bad child=%p\n", me);
			continue;
		}
		error = wsevsrc_open(me, evar);
		if (error) {
			DPRINTF(("wsmuxopen: open failed %d\n", error));
		}
#else
		/* ignore errors, failing children will not be marked open */
		(void)wsevsrc_open(me, evar);
#endif
	}
a309 3
/*
 * close() of the pseudo device from device table.
 */
d311 3
a313 1
wsmuxclose(dev_t dev, int flags, int mode, struct proc *p)
d315 7
a321 3
	struct wsmux_softc *sc =
	    (struct wsmux_softc *)wsmuxdevs[minor(dev)];
	struct wseventvar *evar = sc->sc_base.me_evp;
d323 7
a329 3
	if (evar == NULL)
		/* Not open for read */
		return (0);
d331 2
a332 4
	wsmux_do_close(sc);
	sc->sc_base.me_evp = NULL;
	wsevent_fini(evar);
	return (0);
a334 3
/*
 * Close of a mux via the parent mux.
 */
d336 3
a338 1
wsmux_mux_close(struct wsevsrc *me)
d340 30
a369 3
	me->me_evp = NULL;
	wsmux_do_close((struct wsmux_softc *)me);
	return (0);
d372 8
a379 3
/* Common part of closing a mux. */
void
wsmux_do_close(struct wsmux_softc *sc)
d381 2
a382 1
	struct wsevsrc *me;
d384 12
a395 1
	DPRINTF(("wsmuxclose: %s: sc=%p\n", sc->sc_base.me_dv.dv_xname, sc));
d397 21
a417 8
	/* Close all the children. */
	CIRCLEQ_FOREACH(me, &sc->sc_cld, me_next) {
		DPRINTF(("wsmuxclose %s: m=%p dev=%s\n",
			 sc->sc_base.me_dv.dv_xname, me, me->me_dv.dv_xname));
#ifdef DIAGNOSTIC
		if (me->me_parent != sc) {
			printf("wsmuxclose: bad child=%p\n", me);
			continue;
d419 13
a431 3
#endif
		(void)wsevsrc_close(me);
		me->me_evp = NULL;
d433 4
a438 3
/*
 * read() of the pseudo device from device table.
 */
d440 3
a442 1
wsmuxread(dev_t dev, struct uio *uio, int flags)
d444 2
a445 3
	struct wsmux_softc *sc = wsmuxdevs[minor(dev)];
	struct wseventvar *evar;
	int error;
d447 1
a447 2
	evar = sc->sc_base.me_evp;
	if (evar == NULL) {
d449 4
a452 2
		/* XXX can we get here? */
		printf("wsmuxread: not open\n");
d454 23
a476 1
		return (EINVAL);
d479 5
a483 6
	DPRINTFN(5,("wsmuxread: %s event read evar=%p\n",
		    sc->sc_base.me_dv.dv_xname, evar));
	error = wsevent_read(evar, uio, flags);
	DPRINTFN(5,("wsmuxread: %s event read ==> error=%d\n",
		    sc->sc_base.me_dv.dv_xname, error));
	return (error);
d486 4
a489 5
/*
 * ioctl of the pseudo device from device table.
 */
int
wsmuxioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
d491 22
a512 1
	return wsmux_do_ioctl(&wsmuxdevs[minor(dev)]->sc_base.me_dv, cmd, data, flag, p);
a514 3
/*
 * ioctl of a mux via the parent mux, continuation of wsmuxioctl().
 */
d516 6
a521 2
wsmux_do_ioctl(struct device *dv, u_long cmd, caddr_t data, int flag,
    struct proc *p)
d524 1
a524 1
	struct wsevsrc *me;
d529 1
d532 2
a533 2
	DPRINTF(("wsmux_do_ioctl: %s: enter sc=%p, cmd=%08lx\n",
		 sc->sc_base.me_dv.dv_xname, sc, cmd));
d536 1
a536 1
	case WSMUXIO_INJECTEVENT:
d538 2
a539 8
		DPRINTF(("%s: inject\n", sc->sc_base.me_dv.dv_xname));

		evar = sc->sc_base.me_evp;
		if (evar == NULL) {
			/* No event sink, so ignore it. */
			DPRINTF(("wsmux_do_ioctl: event ignored\n"));
			return (0);
		}
d541 1
a544 1
		ev = &evar->q[put];
d552 1
d554 2
a555 1
		nanotime(&ev->time);
d560 1
a560 1
	case WSMUXIO_ADD_DEVICE:
a561 2
		DPRINTF(("%s: add type=%d, no=%d\n", sc->sc_base.me_dv.dv_xname,
			 d->type, d->idx));
d571 1
d574 1
d578 16
a593 11
	case WSMUXIO_REMOVE_DEVICE:
		DPRINTF(("%s: rem type=%d, no=%d\n", sc->sc_base.me_dv.dv_xname,
			 d->type, d->idx));
		/* Locate the device */
		CIRCLEQ_FOREACH(me, &sc->sc_cld, me_next) {
			if (me->me_ops->type == d->type &&
			    me->me_dv.dv_unit == d->idx) {
				DPRINTF(("wsmux_do_ioctl: detach\n"));
				wsmux_detach_sc(me);
				return (0);
			}
a594 1
		return (EINVAL);
d596 1
a596 3

	case WSMUXIO_LIST_DEVICES:
		DPRINTF(("%s: list\n", sc->sc_base.me_dv.dv_xname));
d598 5
a602 6
		n = 0;
		CIRCLEQ_FOREACH(me, &sc->sc_cld, me_next) {
			if (n >= WSMUX_MAXDEV)
				break;
			l->devices[n].type = me->me_ops->type;
			l->devices[n].idx = me->me_dv.dv_unit;
d610 1
a610 1
		DPRINTF(("wsmux_do_ioctl: save rawkbd = %d\n", sc->sc_rawkbd));
a612 4
	case FIONBIO:
		DPRINTF(("%s: FIONBIO\n", sc->sc_base.me_dv.dv_xname));
		return (0);

d614 1
a614 14
		DPRINTF(("%s: FIOASYNC\n", sc->sc_base.me_dv.dv_xname));
		evar = sc->sc_base.me_evp;
		if (evar == NULL)
			return (EINVAL);
		evar->async = *(int *)data != 0;
		return (0);
	case FIOSETOWN:
		DPRINTF(("%s: FIOSETOWN\n", sc->sc_base.me_dv.dv_xname));
		evar = sc->sc_base.me_evp;
		if (evar == NULL)
			return (EINVAL);
		if (-*(int *)data != evar->io->p_pgid
		    && *(int *)data != evar->io->p_pid)
			return (EPERM);
d617 1
a617 5
		DPRINTF(("%s: TIOCSPGRP\n", sc->sc_base.me_dv.dv_xname));
		evar = sc->sc_base.me_evp;
		if (evar == NULL)
			return (EINVAL);
		if (*(int *)data != evar->io->p_pgid)
a620 1
		DPRINTF(("%s: unknown\n", sc->sc_base.me_dv.dv_xname));
d624 1
a624 5
	if (sc->sc_base.me_evp == NULL
#if NWSDISPLAY > 0
	    && sc->sc_displaydv == NULL
#endif
	    )
d630 9
a638 6
	CIRCLEQ_FOREACH(me, &sc->sc_cld, me_next) {
#ifdef DIAGNOSTIC
		/* XXX check evp? */
		if (me->me_parent != sc) {
			printf("wsmux_do_ioctl: bad child %p\n", me);
			continue;
a639 7
#endif
		error = wsevsrc_ioctl(me, cmd, data, flag, p);
		DPRINTF(("wsmux_do_ioctl: %s: me=%p dev=%s ==> %d\n",
			 sc->sc_base.me_dv.dv_xname, me, me->me_dv.dv_xname,
			 error));
		if (!error)
			ok = 1;
d641 1
a641 1
	if (ok) {
a642 94
		if (cmd == WSKBDIO_SETENCODING) {
			sc->sc_kbd_layout = *((kbd_t *)data);
		}

	}

	return (error);
}

/*
 * poll() of the pseudo device from device table.
 */
int
wsmuxpoll(dev_t dev, int events, struct proc *p)
{
	struct wsmux_softc *sc = wsmuxdevs[minor(dev)];

	if (sc->sc_base.me_evp == NULL) {
#ifdef DIAGNOSTIC
		printf("wsmuxpoll: not open\n");
#endif
		return (EACCES);
	}

	return (wsevent_poll(sc->sc_base.me_evp, events, p));
}

/*
 * Add mux unit as a child to muxsc.
 */
int
wsmux_add_mux(int unit, struct wsmux_softc *muxsc)
{
	struct wsmux_softc *sc, *m;

	sc = wsmux_getmux(unit);
	if (sc == NULL)
		return (ENXIO);

	DPRINTF(("wsmux_add_mux: %s(%p) to %s(%p)\n",
		 sc->sc_base.me_dv.dv_xname, sc, muxsc->sc_base.me_dv.dv_xname,
		 muxsc));

	if (sc->sc_base.me_parent != NULL || sc->sc_base.me_evp != NULL)
		return (EBUSY);

	/* The mux we are adding must not be an ancestor of itself. */
	for (m = muxsc; m != NULL ; m = m->sc_base.me_parent)
		if (m == sc)
			return (EINVAL);

	return (wsmux_attach_sc(muxsc, &sc->sc_base));
}

/* Create a new mux softc. */
struct wsmux_softc *
wsmux_create(const char *name, int unit)
{
	struct wsmux_softc *sc;

	DPRINTF(("wsmux_create: allocating\n"));
	sc = malloc(sizeof *sc, M_DEVBUF, M_NOWAIT);
	if (sc == NULL)
		return (NULL);
	bzero(sc, sizeof *sc);
	CIRCLEQ_INIT(&sc->sc_cld);
	snprintf(sc->sc_base.me_dv.dv_xname, sizeof sc->sc_base.me_dv.dv_xname,
		 "%s%d", name, unit);
	sc->sc_base.me_dv.dv_unit = unit;
	sc->sc_base.me_ops = &wsmux_srcops;
	sc->sc_kbd_layout = KB_NONE;
	return (sc);
}

/* Attach me as a child to sc. */
int
wsmux_attach_sc(struct wsmux_softc *sc, struct wsevsrc *me)
{
	int error;

	if (sc == NULL)
		return (EINVAL);

	DPRINTF(("wsmux_attach_sc: %s(%p): type=%d\n",
		 sc->sc_base.me_dv.dv_xname, sc, me->me_ops->type));

#ifdef DIAGNOSTIC
	if (me->me_parent != NULL) {
		printf("wsmux_attach_sc: busy\n");
		return (EBUSY);
	}
#endif
	me->me_parent = sc;
	CIRCLEQ_INSERT_TAIL(&sc->sc_cld, me, me_next);
a643 43
	error = 0;
#if NWSDISPLAY > 0
	if (sc->sc_displaydv != NULL) {
		/* This is a display mux, so attach the new device to it. */
		DPRINTF(("wsmux_attach_sc: %s: set display %p\n",
			 sc->sc_base.me_dv.dv_xname, sc->sc_displaydv));
		if (me->me_ops->dsetdisplay != NULL) {
			error = wsevsrc_set_display(me, &sc->sc_base);
			/* Ignore that the console already has a display. */
			if (error == EBUSY)
				error = 0;
			if (!error) {
#ifdef WSDISPLAY_COMPAT_RAWKBD
				DPRINTF(("wsmux_attach_sc: %s set rawkbd=%d\n",
					 me->me_dv.dv_xname, sc->sc_rawkbd));
				(void)wsevsrc_ioctl(me, WSKBDIO_SETMODE,
						    &sc->sc_rawkbd, 0, 0);
#endif
				if (sc->sc_kbd_layout != KB_NONE)
					(void)wsevsrc_ioctl(me,
					    WSKBDIO_SETENCODING,
					    &sc->sc_kbd_layout, FWRITE, 0);
			}
		}
	}
#endif
	if (sc->sc_base.me_evp != NULL) {
		/* Mux is open, so open the new subdevice */
		DPRINTF(("wsmux_attach_sc: %s: calling open of %s\n",
			 sc->sc_base.me_dv.dv_xname, me->me_dv.dv_xname));
		error = wsevsrc_open(me, sc->sc_base.me_evp);
	} else {
		DPRINTF(("wsmux_attach_sc: %s not open\n",
			 sc->sc_base.me_dv.dv_xname));
	}

	if (error) {
		me->me_parent = NULL;
		CIRCLEQ_REMOVE(&sc->sc_cld, me, me_next);
	}

	DPRINTF(("wsmux_attach_sc: %s(%p) done, error=%d\n",
		 sc->sc_base.me_dv.dv_xname, sc, error));
a646 39
/* Remove me from the parent. */
void
wsmux_detach_sc(struct wsevsrc *me)
{
	struct wsmux_softc *sc = me->me_parent;

	DPRINTF(("wsmux_detach_sc: %s(%p) parent=%p\n",
		 me->me_dv.dv_xname, me, sc));

#ifdef DIAGNOSTIC
	if (sc == NULL) {
		printf("wsmux_detach_sc: %s has no parent\n",
		       me->me_dv.dv_xname);
		return;
	}
#endif

#if NWSDISPLAY > 0
	if (sc->sc_displaydv != NULL) {
		if (me->me_ops->dsetdisplay != NULL)
			/* ignore error, there's nothing we can do */
			(void)wsevsrc_set_display(me, NULL);
	} else
#endif
		if (me->me_evp != NULL) {
		DPRINTF(("wsmux_detach_sc: close\n"));
		/* mux device is open, so close multiplexee */
		(void)wsevsrc_close(me);
	}

	CIRCLEQ_REMOVE(&sc->sc_cld, me, me_next);
	me->me_parent = NULL;

	DPRINTF(("wsmux_detach_sc: done sc=%p\n", sc));
}

/*
 * Display ioctl() of a mux via the parent mux.
 */
d648 6
a653 2
wsmux_do_displayioctl(struct device *dv, u_long cmd, caddr_t data, int flag,
    struct proc *p)
d656 1
a656 1
	struct wsevsrc *me;
d659 2
a660 2
	DPRINTF(("wsmux_displayioctl: %s: sc=%p, cmd=%08lx\n",
		 sc->sc_base.me_dv.dv_xname, sc, cmd));
d666 1
a666 1
	}
d669 1
a669 1
	/*
d675 8
a682 12
	CIRCLEQ_FOREACH(me, &sc->sc_cld, me_next) {
		DPRINTF(("wsmux_displayioctl: me=%p\n", me));
#ifdef DIAGNOSTIC
		if (me->me_parent != sc) {
			printf("wsmux_displayioctl: bad child %p\n", me);
			continue;
		}
#endif
		if (me->me_ops->ddispioctl != NULL) {
			error = wsevsrc_display_ioctl(me, cmd, data, flag, p);
			DPRINTF(("wsmux_displayioctl: me=%p dev=%s ==> %d\n",
				 me, me->me_dv.dv_xname, error));
a692 4
#if NWSDISPLAY > 0
/*
 * Set display of a mux via the parent mux.
 */
d694 3
a696 1
wsmux_evsrc_set_display(struct device *dv, struct wsevsrc *ame)
a697 1
	struct wsmux_softc *muxsc = (struct wsmux_softc *)ame;
d699 5
a703 1
	struct device *displaydv = muxsc ? muxsc->sc_displaydv : NULL;
d706 1
a706 1
		 sc->sc_base.me_dv.dv_xname, displaydv));
d708 2
a709 2
	if (displaydv != NULL) {
		if (sc->sc_displaydv != NULL)
a715 11
	return wsmux_set_display(sc, displaydv);
}

int
wsmux_set_display(struct wsmux_softc *sc, struct device *displaydv)
{
	struct device *odisplaydv;
	struct wsevsrc *me;
	struct wsmux_softc *nsc = displaydv ? sc : NULL;
	int error, ok;

d719 3
a721 4
	if (displaydv) {
		DPRINTF(("%s: connecting to %s\n",
		       sc->sc_base.me_dv.dv_xname, displaydv->dv_xname));
	}
d724 7
a730 11
	CIRCLEQ_FOREACH(me, &sc->sc_cld,me_next) {
#ifdef DIAGNOSTIC
		if (me->me_parent != sc) {
			printf("wsmux_set_display: bad child parent %p\n", me);
			continue;
		}
#endif
		if (me->me_ops->dsetdisplay != NULL) {
			error = wsevsrc_set_display(me, &nsc->sc_base);
			DPRINTF(("wsmux_set_display: m=%p dev=%s error=%d\n",
				 me, me->me_dv.dv_xname, error));
d733 1
d735 6
a740 5
				DPRINTF(("wsmux_set_display: %s set rawkbd=%d\n"
,
					 me->me_dv.dv_xname, sc->sc_rawkbd));
				(void)wsevsrc_ioctl(me, WSKBDIO_SETMODE,
						    &sc->sc_rawkbd, 0, 0);
d748 3
a750 4
	if (displaydv == NULL) {
		DPRINTF(("%s: disconnecting from %s\n",
		       sc->sc_base.me_dv.dv_xname, odisplaydv->dv_xname));
	}
d754 14
a767 1
#endif /* NWSDISPLAY > 0 */
@


1.1.1.3
log
@timecounters
@
text
@d402 1
a402 2
		microtime(&xxxtime);
		TIMEVAL_TO_TIMESPEC(&xxxtime, &ev->time);
@


1.1.1.4
log
@timecounters
@
text
@a372 1
	struct timeval xxxtime;
@


1.1.1.5
log
@import current wscons & friends code from OpenBSD
in the hope it will be useful
@
text
@d1 1
a1 1
/*	$OpenBSD: wsmux.c,v 1.19 2006/11/01 03:37:24 tedu Exp $	*/
a63 1
#include <sys/poll.h>
d101 1
a101 1
int	wsmux_evsrc_set_display(struct device *, struct device *);
d373 1
a380 11
	case WSMUXIO_ADD_DEVICE:
	case WSMUXIO_REMOVE_DEVICE:
#ifdef WSDISPLAY_COMPAT_RAWKBD
	case WSKBDIO_SETMODE:
#endif
		if ((flag & FWRITE) == 0)
			return (EACCES);
	}

	switch (cmd) {
	case WSMUXIO_INJECTEVENT:
d383 1
d403 2
a404 1
		nanotime(&ev->time);
d542 1
a542 1
		return (POLLERR);
d623 1
a623 1
			error = wsevsrc_set_display(me, sc->sc_displaydv);
d632 1
a632 1
						    &sc->sc_rawkbd, FWRITE, 0);
d752 1
a752 1
wsmux_evsrc_set_display(struct device *dv, struct device *displaydv)
d754 1
d756 1
d797 1
a797 1
			error = wsevsrc_set_display(me, nsc->sc_displaydv);
d807 1
a807 1
						    &sc->sc_rawkbd, FWRITE, 0);
@


1.1.1.6
log
@more nanotime
@
text
@a373 1
	struct timeval xxxtime;
d413 1
a413 2
		microtime(&xxxtime);
		TIMEVAL_TO_TIMESPEC(&xxxtime, &ev->time);
@


