head	1.1;
branch	1.1.1;
access;
symbols
	tg-beforemerge-ksrc10:1.1.1.5
	MIRBSD_10:1.1.1.5.0.2
	MIRBSD_10_BASE:1.1.1.5
	cvs-200702062030:1.1.1.4
	MIRBSD_9_BASE:1.1.1.3
	MIRBSD_8:1.1.1.3.0.2
	MIRBSD_8_BASE:1.1.1.3
	cvs-200507032030:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2005.02.05.17.28.46;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.28.46;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.07.04.01.13.58;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	76bf42c88d6bc5d8;

1.1.1.3
date	2005.07.04.02.39.44;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	741842c8a185ec98;

1.1.1.4
date	2007.02.06.20.51.58;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	10045C8EA6658CBB47A;

1.1.1.5
date	2007.02.06.23.10.41;	author tg;	state Exp;
branches;
next	;
commitid	10045C90B040EB94697;


desc
@@


1.1
log
@Initial revision
@
text
@/* $OpenBSD: wsmouse.c,v 1.12 2003/09/23 16:51:12 millert Exp $ */
/* $NetBSD: wsmouse.c,v 1.12 2000/05/01 07:36:58 takemura Exp $ */

/*
 * Copyright (c) 1996, 1997 Christopher G. Demetriou.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christopher G. Demetriou
 *	for the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/cdefs.h>

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ms.c	8.1 (Berkeley) 6/11/93
 */

/*
 * Mouse driver.
 */

#include <sys/param.h>
#include <sys/conf.h>
#include <sys/ioctl.h>
#include <sys/fcntl.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/syslog.h>
#include <sys/systm.h>
#include <sys/tty.h>
#include <sys/signalvar.h>
#include <sys/device.h>
#include <sys/vnode.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsmousevar.h>
#include <dev/wscons/wseventvar.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rndvar.h>

#include "wsmouse.h"
#include "wsmux.h"
#include "wsdisplay.h"
#include "wskbd.h"

#if NWSMUX > 0
#include <dev/wscons/wsmuxvar.h>
#endif

#define	INVALID_X	INT_MAX
#define	INVALID_Y	INT_MAX
#define	INVALID_Z	INT_MAX

struct wsmouse_softc {
	struct device	sc_dv;

	const struct wsmouse_accessops *sc_accessops;
	void		*sc_accesscookie;

	int		sc_ready;	/* accepting events */
	struct wseventvar sc_events;	/* event queue state */

	u_int		sc_mb;		/* mouse button state */
	u_int		sc_ub;		/* user button state */
	int		sc_dx;		/* delta-x */
	int		sc_dy;		/* delta-y */
	int		sc_dz;		/* delta-z */
	int		sc_x;		/* absolute-x */
	int		sc_y;		/* absolute-y */
	int		sc_z;		/* absolute-z */

	int		sc_refcnt;
	u_char		sc_dying;	/* device is being detached */

#if NWSMUX > 0
	struct wsmux_softc *sc_mux;
#endif
};

int	wsmouse_match(struct device *, void *, void *);
void	wsmouse_attach(struct device *, struct device *, void *);
int	wsmouse_detach(struct device *, int);
int	wsmouse_activate(struct device *, enum devact);

int	wsmouse_do_ioctl(struct wsmouse_softc *, u_long, caddr_t, 
			      int, struct proc *);

int	wsmousedoclose(struct device *, int, int, struct proc *);
int	wsmousedoioctl(struct device *, u_long, caddr_t, int, 
			    struct proc *);

struct cfdriver wsmouse_cd = {
	NULL, "wsmouse", DV_TTY
};

struct cfattach wsmouse_ca = {
	sizeof (struct wsmouse_softc), wsmouse_match, wsmouse_attach,
	wsmouse_detach, wsmouse_activate
};

#if NWSMOUSE > 0
extern struct cfdriver wsmouse_cd;
#endif /* NWSMOUSE > 0 */

#if NWSMUX > 0
struct wsmuxops wsmouse_muxops = {
	wsmouseopen, wsmousedoclose, wsmousedoioctl, 0, 0, 0
};
#endif

/*
 * Print function (for parent devices).
 */
int
wsmousedevprint(aux, pnp)
	void *aux;
	const char *pnp;
{

	if (pnp)
		printf("wsmouse at %s", pnp);
	return (UNCONF);
}

int
wsmouse_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
{
	return (1);
}

void
wsmouse_attach(parent, self, aux)
        struct device *parent, *self;
	void *aux;
{
        struct wsmouse_softc *sc = (struct wsmouse_softc *)self;
	struct wsmousedev_attach_args *ap = aux;
#if NWSMUX > 0
	int mux;
#endif

	sc->sc_accessops = ap->accessops;
	sc->sc_accesscookie = ap->accesscookie;
	sc->sc_ready = 0;				/* sanity */

#if NWSMUX > 0
	mux = sc->sc_dv.dv_cfdata->wsmousedevcf_mux;
	if (mux != WSMOUSEDEVCF_MUX_DEFAULT) {
		wsmux_attach(mux, WSMUX_MOUSE, &sc->sc_dv, &sc->sc_events,
			     &sc->sc_mux, &wsmouse_muxops);
		printf(" mux %d", mux);
	}
#endif

	printf("\n");
}

int
wsmouse_activate(self, act)
	struct device *self;
	enum devact act;
{
	/* XXX should we do something more? */
	return (0);
}

/*
 * Detach a mouse.  To keep track of users of the softc we keep
 * a reference count that's incremented while inside, e.g., read.
 * If the mouse is active and the reference count is > 0 (0 is the
 * normal state) we post an event and then wait for the process
 * that had the reference to wake us up again.  Then we blow away the
 * vnode and return (which will deallocate the softc).
 */
int
wsmouse_detach(self, flags)
	struct device  *self;
	int flags;
{
	struct wsmouse_softc *sc = (struct wsmouse_softc *)self;
	struct wseventvar *evar;
	int maj, mn;
	int s;
#if NWSMUX > 0
	int mux;
#endif

	sc->sc_dying = 1;

#if NWSMUX > 0
	mux = sc->sc_dv.dv_cfdata->wsmousedevcf_mux;
	if (mux != WSMOUSEDEVCF_MUX_DEFAULT)
		wsmux_detach(mux, &sc->sc_dv);
#endif

	evar = &sc->sc_events;
	if (evar->io) {
		s = spltty();
		if (--sc->sc_refcnt >= 0) {
			/* Wake everyone by generating a dummy event. */
			if (++evar->put >= WSEVENT_QSIZE)
				evar->put = 0;
			WSEVENT_WAKEUP(evar);
			/* Wait for processes to go away. */
			if (tsleep(sc, PZERO, "wsmdet", hz * 60))
				printf("wsmouse_detach: %s didn't detach\n",
				       sc->sc_dv.dv_xname);
		}
		splx(s);
	}

	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == wsmouseopen)
			break;

	/* Nuke the vnodes for any open instances (calls close). */
	mn = self->dv_unit;
	vdevgone(maj, mn, mn, VCHR);

	return (0);
}

void
wsmouse_input(wsmousedev, btns, x, y, z, flags)
	struct device *wsmousedev;
	u_int btns;			/* 0 is up */
	int x, y, z;
	u_int flags;
{
	struct wsmouse_softc *sc = (struct wsmouse_softc *)wsmousedev;
	struct wscons_event *ev;
	struct wseventvar *evar;
	int mb, ub, d, get, put, any;

        /*
         * Discard input if not ready.
         */
	if (sc->sc_ready == 0)
		return;

	add_mouse_randomness(x ^ y ^ z ^ btns);

#if NWSMUX > 0
	if (sc->sc_mux)
		evar = &sc->sc_mux->sc_events;
	else
#endif
		evar = &sc->sc_events;

	sc->sc_mb = btns;
	if (!(flags & WSMOUSE_INPUT_ABSOLUTE_X))
		sc->sc_dx += x;
	if (!(flags & WSMOUSE_INPUT_ABSOLUTE_Y))
		sc->sc_dy += y;
	if (!(flags & WSMOUSE_INPUT_ABSOLUTE_Z))
		sc->sc_dz += z;

	/*
	 * We have at least one event (mouse button, delta-X, or
	 * delta-Y; possibly all three, and possibly three separate
	 * button events).  Deliver these events until we are out
	 * of changes or out of room.  As events get delivered,
	 * mark them `unchanged'.
	 */
	ub = sc->sc_ub;
	any = 0;
	get = evar->get;
	put = evar->put;
	ev = &evar->q[put];

	/* NEXT prepares to put the next event, backing off if necessary */
#define	NEXT								\
	if ((++put) % WSEVENT_QSIZE == get) {				\
		put--;							\
		goto out;						\
	}
	/* ADVANCE completes the `put' of the event */
#define	ADVANCE								\
	ev++;								\
	if (put >= WSEVENT_QSIZE) {					\
		put = 0;						\
		ev = &evar->q[0];				\
	}								\
	any = 1
	/* TIMESTAMP sets `time' field of the event to the current time */
#define TIMESTAMP							\
	do {								\
		int s;							\
		s = splhigh();						\
		TIMEVAL_TO_TIMESPEC(&time, &ev->time);			\
		splx(s);						\
	} while (0)

	if (flags & WSMOUSE_INPUT_ABSOLUTE_X) {
		if (sc->sc_x != x) {
			NEXT;
			ev->type = WSCONS_EVENT_MOUSE_ABSOLUTE_X;
			ev->value = x;
			TIMESTAMP;
			ADVANCE;
			sc->sc_x = x;
		}
	} else {
		if (sc->sc_dx) {
			NEXT;
			ev->type = WSCONS_EVENT_MOUSE_DELTA_X;
			ev->value = sc->sc_dx;
			TIMESTAMP;
			ADVANCE;
			sc->sc_dx = 0;
		}
	}
	if (flags & WSMOUSE_INPUT_ABSOLUTE_Y) {
		if (sc->sc_y != y) {
			NEXT;
			ev->type = WSCONS_EVENT_MOUSE_ABSOLUTE_Y;
			ev->value = y;
			TIMESTAMP;
			ADVANCE;
			sc->sc_y = y;
		}
	} else {
		if (sc->sc_dy) {
			NEXT;
			ev->type = WSCONS_EVENT_MOUSE_DELTA_Y;
			ev->value = sc->sc_dy;
			TIMESTAMP;
			ADVANCE;
			sc->sc_dy = 0;
		}
	}
	if (flags & WSMOUSE_INPUT_ABSOLUTE_Z) {
		if (sc->sc_z != z) {
			NEXT;
			ev->type = WSCONS_EVENT_MOUSE_ABSOLUTE_Z;
			ev->value = z;
			TIMESTAMP;
			ADVANCE;
			sc->sc_z = z;
		}
	} else {
		if (sc->sc_dz) {
			NEXT;
			ev->type = WSCONS_EVENT_MOUSE_DELTA_Z;
			ev->value = sc->sc_dz;
			TIMESTAMP;
			ADVANCE;
			sc->sc_dz = 0;
		}
	}

	mb = sc->sc_mb;
	while ((d = mb ^ ub) != 0) {
		/*
		 * Mouse button change.  Find the first change and drop
		 * it into the event queue.
		 */
		NEXT;
		ev->value = ffs(d) - 1;

		KASSERT(ev->value >= 0);

		d = 1 << ev->value;
		ev->type =
		    (mb & d) ? WSCONS_EVENT_MOUSE_DOWN : WSCONS_EVENT_MOUSE_UP;
		TIMESTAMP;
		ADVANCE;
		ub ^= d;
	}

	/* XXX fake wscons_event notifying wsmoused(8) to close mouse device */
	if (flags & WSMOUSE_INPUT_WSMOUSED_CLOSE) {
			NEXT;
			ev->type = WSCONS_EVENT_WSMOUSED_CLOSE;
			ev->value = 0;
			TIMESTAMP;
			ADVANCE;
	}

out:
	if (any) {
		sc->sc_ub = ub;
		evar->put = put;
		WSEVENT_WAKEUP(evar);
		/* wsdisplay_burn(sc->sc_displaydv, WSDISPLAY_BURN_MOUSE); */
	}
}

int
wsmouseopen(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
{
#if NWSMOUSE > 0
	struct wsmouse_softc *sc;
	int error, unit;

	unit = minor(dev);
	if (unit >= wsmouse_cd.cd_ndevs ||	/* make sure it was attached */
	    (sc = wsmouse_cd.cd_devs[unit]) == NULL)
		return (ENXIO);

	if (sc->sc_dying)
		return (EIO);

	if ((flags & (FREAD | FWRITE)) == FWRITE)
		return (0);			/* always allow open for write
						   so ioctl() is possible. */

#if NWSMUX > 0
	if (sc->sc_mux)
		return (EBUSY);
#endif

	if (sc->sc_events.io)			/* and that it's not in use */
		return (EBUSY);

	sc->sc_events.io = p;
	wsevent_init(&sc->sc_events);		/* may cause sleep */

	sc->sc_ready = 1;			/* start accepting events */
	sc->sc_x = INVALID_X;
	sc->sc_y = INVALID_Y;
	sc->sc_z = INVALID_Z;

	/* enable the device, and punt if that's not possible */
	error = (*sc->sc_accessops->enable)(sc->sc_accesscookie);
	if (error) {
		sc->sc_ready = 0;		/* stop accepting events */
		wsevent_fini(&sc->sc_events);
		sc->sc_events.io = NULL;
		return (error);
	}

	return (0);
#else
	return (ENXIO);
#endif /* NWSMOUSE > 0 */
}

int
wsmouseclose(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
{
#if NWSMOUSE > 0
	return (wsmousedoclose(wsmouse_cd.cd_devs[minor(dev)], 
			       flags, mode, p));
#else
	return (ENXIO);
#endif /* NWSMOUSE > 0 */
}

#if NWSMOUSE > 0
int
wsmousedoclose(dv, flags, mode, p)
	struct device *dv;
	int flags, mode;
	struct proc *p;
{
	struct wsmouse_softc *sc = (struct wsmouse_softc *)dv;

	if ((flags & (FREAD | FWRITE)) == FWRITE)
		return (0);			/* see wsmouseopen() */

	(*sc->sc_accessops->disable)(sc->sc_accesscookie);

	sc->sc_ready = 0;			/* stop accepting events */
	wsevent_fini(&sc->sc_events);
	sc->sc_events.io = NULL;
	return (0);
}
#endif /* NWSMOUSE > 0 */

int
wsmouseread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
#if NWSMOUSE > 0
	struct wsmouse_softc *sc = wsmouse_cd.cd_devs[minor(dev)];
	int error;

	if (sc->sc_dying)
		return (EIO);

	sc->sc_refcnt++;
	error = wsevent_read(&sc->sc_events, uio, flags);
	if (--sc->sc_refcnt < 0) {
		wakeup(sc);
		error = EIO;
	}
	return (error);
#else
	return (ENXIO);
#endif /* NWSMOUSE > 0 */
}

int
wsmouseioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
#if NWSMOUSE > 0
	return (wsmousedoioctl(wsmouse_cd.cd_devs[minor(dev)],
			       cmd, data, flag, p));
#else
	return (ENXIO);
#endif /* NWSMOUSE > 0 */
}

#if NWSMOUSE > 0
/* A wrapper around the ioctl() workhorse to make reference counting easy. */
int
wsmousedoioctl(dv, cmd, data, flag, p)
	struct device *dv;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	struct wsmouse_softc *sc = (struct wsmouse_softc *)dv;
	int error;

	sc->sc_refcnt++;
	error = wsmouse_do_ioctl(sc, cmd, data, flag, p);
	if (--sc->sc_refcnt < 0)
		wakeup(sc);
	return (error);
}

int
wsmouse_do_ioctl(sc, cmd, data, flag, p)
	struct wsmouse_softc *sc;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	int error;

	if (sc->sc_dying)
		return (EIO);

	/*
	 * Try the generic ioctls that the wsmouse interface supports.
	 */
	switch (cmd) {
	case FIONBIO:		/* we will remove this someday (soon???) */
		return (0);

	case FIOASYNC:
		sc->sc_events.async = *(int *)data != 0;
		return (0);

	case TIOCSPGRP:
		if (*(int *)data != sc->sc_events.io->p_pgid)
			return (EPERM);
		return (0);
	}

	/*
	 * Try the mouse driver for WSMOUSEIO ioctls.  It returns -1
	 * if it didn't recognize the request.
	 */
	error = (*sc->sc_accessops->ioctl)(sc->sc_accesscookie, cmd,
	    data, flag, p);
	return (error != -1 ? error : ENOTTY);
}
#endif /* NWSMOUSE > 0 */

int
wsmousepoll(dev, events, p)
	dev_t dev;
	int events;
	struct proc *p;
{
#if NWSMOUSE > 0
	struct wsmouse_softc *sc = wsmouse_cd.cd_devs[minor(dev)];

	return (wsevent_poll(&sc->sc_events, events, p));
#else
	return (0);
#endif /* NWSMOUSE > 0 */
}

#if NWSMUX > 0
int
wsmouse_add_mux(unit, muxsc)
	int unit;
	struct wsmux_softc *muxsc;
{
	struct wsmouse_softc *sc;

	if (unit < 0 || unit >= wsmouse_cd.cd_ndevs ||
	    (sc = wsmouse_cd.cd_devs[unit]) == NULL)
		return (ENXIO);

	if (sc->sc_mux || sc->sc_events.io)
		return (EBUSY);

	return (wsmux_attach_sc(muxsc, WSMUX_MOUSE, &sc->sc_dv, &sc->sc_events, 
				&sc->sc_mux, &wsmouse_muxops));
}

int
wsmouse_rem_mux(unit, muxsc)
	int unit;
	struct wsmux_softc *muxsc;
{
	struct wsmouse_softc *sc;

	if (unit < 0 || unit >= wsmouse_cd.cd_ndevs ||
	    (sc = wsmouse_cd.cd_devs[unit]) == NULL)
		return (ENXIO);

	return (wsmux_detach_sc(muxsc, &sc->sc_dv));
}

#endif
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@lastly some drivers
@
text
@d1 2
a2 2
/* $OpenBSD: wsmouse.c,v 1.16 2005/06/01 18:50:30 miod Exp $ */
/* $NetBSD: wsmouse.c,v 1.35 2005/02/27 00:27:52 perry Exp $ */
d34 2
a79 4
#ifndef	SMALL_KERNEL
#define	BURNER_SUPPORT
#endif

d99 1
d104 1
a105 8

#if defined(WSMUX_DEBUG) && NWSMUX > 0
#define	DPRINTF(x)	if (wsmuxdebug) printf x
#define	DPRINTFN(n,x)	if (wsmuxdebug > (n)) printf x
extern int wsmuxdebug;
#else
#define	DPRINTF(x)
#define	DPRINTFN(n,x)
d113 1
a113 1
	struct wsevsrc	sc_base;
d118 3
d132 4
d146 1
a146 5
#if NWSMUX > 0
int	wsmouse_mux_open(struct wsevsrc *, struct wseventvar *);
int	wsmouse_mux_close(struct wsevsrc *);
#endif

a148 1
int	wsmousedoopen(struct wsmouse_softc *, struct wseventvar *);
d159 4
d164 2
a165 3
struct wssrcops wsmouse_srcops = {
	WSMUX_MOUSE,
	wsmouse_mux_open, wsmouse_mux_close, wsmousedoioctl, NULL, NULL
d173 3
a175 1
wsmousedevprint(void *aux, const char *pnp)
d184 4
a187 1
wsmouse_match(struct device *parent, void *match, void *aux)
d193 3
a195 1
wsmouse_attach(struct device *parent, struct device *self, void *aux)
d197 1
a197 1
	struct wsmouse_softc *sc = (struct wsmouse_softc *)self;
d200 1
a200 1
	int mux, error;
d205 1
d208 5
a212 8
	sc->sc_base.me_ops = &wsmouse_srcops;
	mux = sc->sc_base.me_dv.dv_cfdata->wsmousedevcf_mux;
	if (mux >= 0) {
		error = wsmux_attach_sc(wsmux_getmux(mux), &sc->sc_base);
		if (error)
			printf(" attach error=%d", error);
		else
			printf(" mux %d", mux);
a213 4
#else
#if 0	/* not worth keeping, especially since the default value is not -1... */
	if (sc->sc_base.me_dv.dv_cfdata->wsmousedevcf_mux >= 0)
		printf(" (mux ignored)");
a214 1
#endif	/* NWSMUX > 0 */
d220 3
a222 1
wsmouse_activate(struct device *self, enum devact act)
d224 1
a224 4
	struct wsmouse_softc *sc = (struct wsmouse_softc *)self;

	if (act == DVACT_DEACTIVATE)
		sc->sc_dying = 1;
d237 3
a239 1
wsmouse_detach(struct device *self, int flags)
d245 5
d252 3
a254 5
	/* Tell parent mux we're leaving. */
	if (sc->sc_base.me_parent != NULL) {
		DPRINTF(("wsmouse_detach:\n"));
		wsmux_detach_sc(&sc->sc_base);
	}
d257 2
a258 3
	/* If we're open ... */
	evar = sc->sc_base.me_evp;
	if (evar != NULL && evar->io != NULL) {
d268 1
a268 1
				       sc->sc_base.me_dv.dv_xname);
d286 5
a290 2
wsmouse_input(struct device *wsmousedev, u_int btns, /* 0 is up */
    int x, int y, int z, u_int flags)
d297 4
a300 7
	add_mouse_randomness(x ^ y ^ z ^ btns);

	/*
	 * Discard input if not ready.
	 */
	evar = sc->sc_base.me_evp;
	if (evar == NULL)
d303 1
a303 6
#ifdef DIAGNOSTIC
	if (evar->q == NULL) {
		printf("wsmouse_input: evar->q=NULL\n");
		return;
	}
#endif
d306 3
a308 2
	DPRINTFN(5,("wsmouse_input: %s mux=%p, evar=%p\n",
		    sc->sc_base.me_dv.dv_xname, sc->sc_base.me_parent, evar));
d310 1
d350 4
a353 1
		getnanotime(&ev->time);					\
d435 5
a439 5
		NEXT;
		ev->type = WSCONS_EVENT_WSMOUSED_CLOSE;
		ev->value = 0;
		TIMESTAMP;
		ADVANCE;
a441 4
#undef	TIMESTAMP
#undef	ADVANCE
#undef	NEXT

a446 1
#ifdef BURNER_SUPPORT
a447 5
#endif
#if NWSMUX > 0
		DPRINTFN(5,("wsmouse_input: %s wakeup evar=%p\n",
			    sc->sc_base.me_dv.dv_xname, evar));
#endif
d452 4
a455 1
wsmouseopen(dev_t dev, int flags, int mode, struct proc *p)
d457 1
a458 1
	struct wseventvar *evar;
a465 5
#if NWSMUX > 0
	DPRINTF(("wsmouseopen: %s mux=%p p=%p\n", sc->sc_base.me_dv.dv_xname,
		 sc->sc_base.me_parent, p));
#endif

d473 6
a478 1
	if (sc->sc_base.me_evp != NULL)
d481 2
a482 3
	evar = &sc->sc_base.me_evar;
	wsevent_init(evar);
	evar->io = p;
d484 7
a490 1
	error = wsmousedoopen(sc, evar);
d492 4
a495 4
		DPRINTF(("wsmouseopen: %s open failed\n",
			 sc->sc_base.me_dv.dv_xname));
		sc->sc_base.me_evp = NULL;
		wsevent_fini(evar);
d497 19
a515 1
	return (error);
d518 1
d520 4
a523 1
wsmouseclose(dev_t dev, int flags, int mode, struct proc *p)
d525 1
a525 3
	struct wsmouse_softc *sc =
	    (struct wsmouse_softc *)wsmouse_cd.cd_devs[minor(dev)];
	struct wseventvar *evar = sc->sc_base.me_evp;
a529 4
	if (evar == NULL)
		/* not open for read */
		return (0);
	sc->sc_base.me_evp = NULL;
a530 1
	wsevent_fini(evar);
d532 3
d537 1
d540 4
a543 13
wsmousedoopen(struct wsmouse_softc *sc, struct wseventvar *evp)
{
	sc->sc_base.me_evp = evp;
	sc->sc_x = INVALID_X;
	sc->sc_y = INVALID_Y;
	sc->sc_z = INVALID_Z;

	/* enable the device, and punt if that's not possible */
	return (*sc->sc_accessops->enable)(sc->sc_accesscookie);
}

int
wsmouseread(dev_t dev, struct uio *uio, int flags)
d545 1
a551 7
#ifdef DIAGNOSTIC
	if (sc->sc_base.me_evp == NULL) {
		printf("wsmouseread: evp == NULL\n");
		return (EINVAL);
	}
#endif

d553 1
a553 1
	error = wsevent_read(sc->sc_base.me_evp, uio, flags);
d559 3
d565 6
a570 1
wsmouseioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
d572 1
d574 4
a577 1
	    cmd, data, flag, p));
d580 1
d583 6
a588 2
wsmousedoioctl(struct device *dv, u_long cmd, caddr_t data, int flag,
    struct proc *p)
d601 6
a606 2
wsmouse_do_ioctl(struct wsmouse_softc *sc, u_long cmd, caddr_t data, int flag,
    struct proc *p)
d621 1
a621 11
		if (sc->sc_base.me_evp == NULL)
			return (EINVAL);
		sc->sc_base.me_evp->async = *(int *)data != 0;
		return (0);

	case FIOSETOWN:
		if (sc->sc_base.me_evp == NULL)
			return (EINVAL);
		if (-*(int *)data != sc->sc_base.me_evp->io->p_pgid
		    && *(int *)data != sc->sc_base.me_evp->io->p_pid)
			return (EPERM);
d625 1
a625 3
		if (sc->sc_base.me_evp == NULL)
			return (EINVAL);
		if (*(int *)data != sc->sc_base.me_evp->io->p_pgid)
d638 1
d641 4
a644 1
wsmousepoll(dev_t dev, int events, struct proc *p)
d646 1
d649 4
a652 3
	if (sc->sc_base.me_evp == NULL)
		return (EINVAL);
	return (wsevent_poll(sc->sc_base.me_evp, events, p));
d657 3
a659 1
wsmouse_mux_open(struct wsevsrc *me, struct wseventvar *evp)
d661 5
a665 1
	struct wsmouse_softc *sc = (struct wsmouse_softc *)me;
d667 1
a667 1
	if (sc->sc_base.me_evp != NULL)
d670 2
a671 1
	return wsmousedoopen(sc, evp);
d675 3
a677 12
wsmouse_mux_close(struct wsevsrc *me)
{
	struct wsmouse_softc *sc = (struct wsmouse_softc *)me;

	sc->sc_base.me_evp = NULL;
	(*sc->sc_accessops->disable)(sc->sc_accesscookie);

	return (0);
}

int
wsmouse_add_mux(int unit, struct wsmux_softc *muxsc)
d685 2
a686 2
	if (sc->sc_base.me_parent != NULL || sc->sc_base.me_evp != NULL)
		return (EBUSY);
d688 1
a688 3
	return (wsmux_attach_sc(muxsc, &sc->sc_base));
}
#endif	/* NWSMUX > 0 */
@


1.1.1.3
log
@timecounters
@
text
@d353 1
a353 4
		int s;							\
		s = splhigh();						\
		TIMEVAL_TO_TIMESPEC(&time, &ev->time);			\
		splx(s);						\
@


1.1.1.4
log
@import current wscons & friends code from OpenBSD
in the hope it will be useful
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.18 2006/11/01 03:37:24 tedu Exp $ */
a93 1
#include <sys/poll.h>
d353 4
a356 1
		getnanotime(&ev->time);					\
a595 9

	switch (cmd) {
	case FIOASYNC:
	case FIOSETOWN:
	case TIOCSPGRP:
		if ((flag & FWRITE) == 0)
			return (EACCES);
	}

d637 1
a637 1
		return (POLLERR);
@


1.1.1.5
log
@no getnanotime for us yet
@
text
@d354 1
a354 4
		int s;							\
		s = splhigh();						\
		TIMEVAL_TO_TIMESPEC(&time, &ev->time);			\
		splx(s);						\
@


