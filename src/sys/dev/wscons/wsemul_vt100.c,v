head	1.4;
access;
symbols
	tg-beforemerge-ksrc10:1.1.1.3
	MIRBSD_10:1.1.1.3.0.2
	MIRBSD_10_BASE:1.1.1.3
	cvs-200702062030:1.1.1.3
	MIRBSD_9_BASE:1.1.1.2
	MIRBSD_8:1.1.1.2.0.2
	MIRBSD_8_BASE:1.1.1.2
	cvs-200507032030:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2009.12.24.11.05.02;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004B334A9E53F2176F;

1.3
date	2009.07.25.12.47.43;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004A6AFED76934A48F;

1.2
date	2009.07.24.17.41.04;	author tg;	state Exp;
branches;
next	1.1;
commitid	1004A69F22361681705;

1.1
date	2005.02.05.17.28.46;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.28.46;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.07.04.01.13.58;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	76bf42c88d6bc5d8;

1.1.1.3
date	2007.02.06.20.51.51;	author tg;	state Exp;
branches;
next	;
commitid	10045C8EA6658CBB47A;


desc
@@


1.4
log
@change default kernel color from (7,1 | 7,0) to (1,7 | 1,7) colour/mono
XXX WS_KERNEL_MONOATTR effect not tested yet

idea for this new scheme by bsiegert@@; letâ€™s see if we all like it
(at least there is no bluescreen any more now)
@
text
@/* $MirOS: src/sys/dev/wscons/wsemul_vt100.c,v 1.3 2009/07/25 12:47:43 tg Exp $ */
/* $OpenBSD: wsemul_vt100.c,v 1.17 2007/01/07 13:31:36 miod Exp $ */
/* $NetBSD: wsemul_vt100.c,v 1.13 2000/04/28 21:56:16 mycroft Exp $ */

/*
 * Copyright (c) 2009
 *	Thorsten Glaser <tg@@mirbsd.org>
 * Copyright (c) 1998
 *	Matthias Drochner.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#ifndef	SMALL_KERNEL
#define	JUMP_SCROLL
#endif

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/malloc.h>
#include <sys/fcntl.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wsemulvar.h>
#include <dev/wscons/wsemul_vt100var.h>
#include <dev/wscons/ascii.h>

void	*wsemul_vt100_cnattach(const struct wsscreen_descr *, void *,
				  int, int, long);
void	*wsemul_vt100_attach(int console, const struct wsscreen_descr *,
				  void *, int, int, void *, long);
void	wsemul_vt100_output(void *cookie, const u_char *data, u_int count,
				 int);
void	wsemul_vt100_detach(void *cookie, u_int *crowp, u_int *ccolp);
void	wsemul_vt100_resetop(void *, enum wsemul_resetops);

const struct wsemul_ops wsemul_vt100_ops = {
	"vt100",
	wsemul_vt100_cnattach,
	wsemul_vt100_attach,
	wsemul_vt100_output,
	wsemul_vt100_translate,
	wsemul_vt100_detach,
	wsemul_vt100_resetop
};

struct wsemul_vt100_emuldata wsemul_vt100_console_emuldata;

/* re-use this as a mere indicator for MirBSD extension ESC x 1, x=()*+ */
#define mbsd_stf ((void *)&wsemul_vt100_console_emuldata)

void wsemul_vt100_init(struct wsemul_vt100_emuldata *,
			    const struct wsscreen_descr *, void *, int, int,
			    long);

void wsemul_vt100_output_normal(struct wsemul_vt100_emuldata *, u_char,
				     int);
void wsemul_vt100_output_c0c1(struct wsemul_vt100_emuldata *, u_char,
				   int);
void wsemul_vt100_nextline(struct wsemul_vt100_emuldata *);
typedef u_int vt100_handler(struct wsemul_vt100_emuldata *, u_char);
vt100_handler
wsemul_vt100_output_esc,
wsemul_vt100_output_csi,
wsemul_vt100_output_scs94,
wsemul_vt100_output_scs94_percent,
wsemul_vt100_output_scs96,
wsemul_vt100_output_scs96_percent,
wsemul_vt100_output_esc_hash,
wsemul_vt100_output_esc_spc,
wsemul_vt100_output_string,
wsemul_vt100_output_string_esc,
wsemul_vt100_output_dcs,
wsemul_vt100_output_dcs_dollar;

#define	VT100_EMUL_STATE_NORMAL		0	/* normal processing */
#define	VT100_EMUL_STATE_ESC		1	/* got ESC */
#define	VT100_EMUL_STATE_CSI		2	/* got CSI (ESC[) */
#define	VT100_EMUL_STATE_SCS94		3	/* got ESC{()*+} */
#define	VT100_EMUL_STATE_SCS94_PERCENT	4	/* got ESC{()*+}% */
#define	VT100_EMUL_STATE_SCS96		5	/* got ESC{-./} */
#define	VT100_EMUL_STATE_SCS96_PERCENT	6	/* got ESC{-./}% */
#define	VT100_EMUL_STATE_ESC_HASH	7	/* got ESC# */
#define	VT100_EMUL_STATE_ESC_SPC	8	/* got ESC<SPC> */
#define	VT100_EMUL_STATE_STRING		9	/* waiting for ST (ESC\) */
#define	VT100_EMUL_STATE_STRING_ESC	10	/* waiting for ST, got ESC */
#define	VT100_EMUL_STATE_DCS		11	/* got DCS (ESC P) */
#define	VT100_EMUL_STATE_DCS_DOLLAR	12	/* got DCS<p>$ */

vt100_handler *vt100_output[] = {
	wsemul_vt100_output_esc,
	wsemul_vt100_output_csi,
	wsemul_vt100_output_scs94,
	wsemul_vt100_output_scs94_percent,
	wsemul_vt100_output_scs96,
	wsemul_vt100_output_scs96_percent,
	wsemul_vt100_output_esc_hash,
	wsemul_vt100_output_esc_spc,
	wsemul_vt100_output_string,
	wsemul_vt100_output_string_esc,
	wsemul_vt100_output_dcs,
	wsemul_vt100_output_dcs_dollar,
};

void
wsemul_vt100_init(edp, type, cookie, ccol, crow, defattr)
	struct wsemul_vt100_emuldata *edp;
	const struct wsscreen_descr *type;
	void *cookie;
	int ccol, crow;
	long defattr;
{
	edp->emulops = type->textops;
	edp->emulcookie = cookie;
	edp->scrcapabilities = type->capabilities;
	edp->nrows = type->nrows;
	edp->ncols = type->ncols;
	edp->crow = crow;
	edp->ccol = ccol;
	edp->defattr = defattr;
}

void *
wsemul_vt100_cnattach(type, cookie, ccol, crow, defattr)
	const struct wsscreen_descr *type;
	void *cookie;
	int ccol, crow;
	long defattr;
{
	struct wsemul_vt100_emuldata *edp;
	int res;

	edp = &wsemul_vt100_console_emuldata;
	wsemul_vt100_init(edp, type, cookie, ccol, crow, defattr);
#ifdef DIAGNOSTIC
	edp->console = 1;
#endif
	edp->cbcookie = NULL;

#ifndef WS_KERNEL_FG
#define WS_KERNEL_FG WSCOL_BLUE
#endif
#ifndef WS_KERNEL_BG
#define WS_KERNEL_BG WSCOL_WHITE
#endif
#ifndef WS_KERNEL_COLATTR
#define WS_KERNEL_COLATTR 0
#endif
#ifndef WS_KERNEL_MONOATTR
#define WS_KERNEL_MONOATTR (WSATTR_REVERSE | WSATTR_UNDERLINE)
#endif
	if (type->capabilities & WSSCREEN_WSCOLORS)
		res = (*edp->emulops->alloc_attr)(cookie,
					    WS_KERNEL_FG, WS_KERNEL_BG,
					    WS_KERNEL_COLATTR | WSATTR_WSCOLORS,
					    &edp->kernattr);
	else
		res = (*edp->emulops->alloc_attr)(cookie, 0, 0,
					    WS_KERNEL_MONOATTR,
					    &edp->kernattr);
	if (res)
		edp->kernattr = defattr;

	edp->tabs = NULL;
	edp->dblwid = NULL;
	edp->dw = 0;
	edp->dcsarg = 0;
	edp->isolatin1tab = edp->decgraphtab = edp->dectechtab = NULL;
	edp->nrctab = NULL;
	wsemul_vt100_reset(edp);
	return (edp);
}

void *
wsemul_vt100_attach(console, type, cookie, ccol, crow, cbcookie, defattr)
	int console;
	const struct wsscreen_descr *type;
	void *cookie;
	int ccol, crow;
	void *cbcookie;
	long defattr;
{
	struct wsemul_vt100_emuldata *edp;

	if (console) {
		edp = &wsemul_vt100_console_emuldata;
#ifdef DIAGNOSTIC
		KASSERT(edp->console == 1);
#endif
	} else {
		edp = malloc(sizeof *edp, M_DEVBUF, M_NOWAIT);
		if (edp == NULL)
			return (NULL);
		wsemul_vt100_init(edp, type, cookie, ccol, crow, defattr);
#ifdef DIAGNOSTIC
		edp->console = 0;
#endif
	}
	edp->cbcookie = cbcookie;

	edp->tabs = malloc(edp->ncols, M_DEVBUF, M_NOWAIT);
	edp->dblwid = malloc(edp->nrows, M_DEVBUF, M_NOWAIT);
	if (edp->dblwid != NULL)
		memset(edp->dblwid, 0, edp->nrows);
	edp->dw = 0;
	edp->dcsarg = malloc(DCS_MAXLEN, M_DEVBUF, M_NOWAIT);
	edp->isolatin1tab = malloc(128 * sizeof(int), M_DEVBUF, M_NOWAIT);
	edp->decgraphtab = malloc(128 * sizeof(int), M_DEVBUF, M_NOWAIT);
	edp->dectechtab = malloc(128 * sizeof(int), M_DEVBUF, M_NOWAIT);
	edp->nrctab = malloc(128 * sizeof(int), M_DEVBUF, M_NOWAIT);
	vt100_initchartables(edp);
	wsemul_vt100_reset(edp);
	return (edp);
}

void
wsemul_vt100_detach(cookie, crowp, ccolp)
	void *cookie;
	u_int *crowp, *ccolp;
{
	struct wsemul_vt100_emuldata *edp = cookie;

	*crowp = edp->crow;
	*ccolp = edp->ccol;
#define f(ptr) if (ptr) {free(ptr, M_DEVBUF); ptr = NULL;}
	f(edp->tabs)
	f(edp->dblwid)
	f(edp->dcsarg)
	f(edp->isolatin1tab)
	f(edp->decgraphtab)
	f(edp->dectechtab)
	f(edp->nrctab)
#undef f
	if (edp != &wsemul_vt100_console_emuldata)
		free(edp, M_DEVBUF);
}

void
wsemul_vt100_resetop(cookie, op)
	void *cookie;
	enum wsemul_resetops op;
{
	struct wsemul_vt100_emuldata *edp = cookie;

	switch (op) {
	case WSEMUL_RESET:
		wsemul_vt100_reset(edp);
		break;
	case WSEMUL_SYNCFONT:
		vt100_initchartables(edp);
		break;
	case WSEMUL_CLEARSCREEN:
		wsemul_vt100_ed(edp, 2);
		edp->ccol = edp->crow = 0;
		(*edp->emulops->cursor)(edp->emulcookie,
					edp->flags & VTFL_CURSORON, 0, 0);
		break;
	default:
		break;
	}
}

void
wsemul_vt100_reset(edp)
	struct wsemul_vt100_emuldata *edp;
{
	int i;

	edp->state = VT100_EMUL_STATE_NORMAL;
	edp->flags = VTFL_DECAWM | VTFL_CURSORON;
	edp->bkgdattr = edp->curattr = edp->defattr;
	edp->attrflags = 0;
	edp->fgcol = WSCOL_WHITE;
	edp->bgcol = WSCOL_BLACK;
	edp->scrreg_startrow = 0;
	edp->scrreg_nrows = edp->nrows;
	if (edp->tabs) {
		memset(edp->tabs, 0, edp->ncols);
		for (i = 8; i < edp->ncols; i += 8)
			edp->tabs[i] = 1;
	}
	edp->dcspos = 0;
	edp->dcstype = 0;
	edp->chartab_G[0] = NULL;
	edp->chartab_G[1] = edp->nrctab; /* ??? */
	edp->chartab_G[2] = edp->isolatin1tab;
	edp->chartab_G[3] = edp->isolatin1tab;
	edp->chartab0 = 0;
	edp->chartab1 = 2;
	edp->sschartab = 0;
}

/*
 * Move the cursor to the next line if possible. If the cursor is at
 * the bottom of the scroll area, then scroll it up. If the cursor is
 * at the bottom of the screen then don't move it down.
 */
void
wsemul_vt100_nextline(struct wsemul_vt100_emuldata *edp)
{
	if (ROWS_BELOW == 0) {
		/* Bottom of the scroll region. */
	  	wsemul_vt100_scrollup(edp, 1);
	} else {
		if ((edp->crow+1) < edp->nrows)
			/* Cursor not at the bottom of the screen. */
			edp->crow++;
		CHECK_DW;
	}
}	

/*
 * now all the state machine bits
 */

void
wsemul_vt100_output_normal(edp, c, kernel)
	struct wsemul_vt100_emuldata *edp;
	u_char c;
	int kernel;
{
	u_int *ct, dc;

	if ((edp->flags & (VTFL_LASTCHAR | VTFL_DECAWM)) ==
	    (VTFL_LASTCHAR | VTFL_DECAWM)) {
		wsemul_vt100_nextline(edp);
		edp->ccol = 0;
		edp->flags &= ~VTFL_LASTCHAR;
	}

	if (c & 0x80) {
		c &= 0x7f;
		ct = edp->chartab_G[edp->chartab1];
	} else {
		if (edp->sschartab) {
			ct = edp->chartab_G[edp->sschartab];
			edp->sschartab = 0;
		} else
			ct = edp->chartab_G[edp->chartab0];
	}
	dc = (ct == mbsd_stf ? c | 0x80 : ct ? ct[c] : c);

	if ((edp->flags & VTFL_INSERTMODE) && COLS_LEFT)
		COPYCOLS(edp->ccol, edp->ccol + 1, COLS_LEFT);

	(*edp->emulops->putchar)(edp->emulcookie, edp->crow,
				 edp->ccol << edp->dw, dc,
				 kernel ? edp->kernattr : edp->curattr);

	if (COLS_LEFT)
		edp->ccol++;
	else
		edp->flags |= VTFL_LASTCHAR;
}

void
wsemul_vt100_output_c0c1(edp, c, kernel)
	struct wsemul_vt100_emuldata *edp;
	u_char c;
	int kernel;
{
	u_int n;

	switch (c) {
	case ASCII_NUL:
	default:
		/* ignore */
		break;
	case ASCII_BEL:
		wsdisplay_emulbell(edp->cbcookie);
		break;
	case ASCII_BS:
		if (edp->ccol > 0) {
			edp->ccol--;
			edp->flags &= ~VTFL_LASTCHAR;
		}
		break;
	case ASCII_CR:
		edp->ccol = 0;
		edp->flags &= ~VTFL_LASTCHAR;
		break;
	case ASCII_HT:
		if (edp->tabs) {
			if (!COLS_LEFT)
				break;
			for (n = edp->ccol + 1; n < NCOLS - 1; n++)
				if (edp->tabs[n])
					break;
		} else {
			n = edp->ccol + min(8 - (edp->ccol & 7), COLS_LEFT);
		}
		edp->ccol = n;
		break;
	case ASCII_SO: /* LS1 */
		edp->chartab0 = 1;
		break;
	case ASCII_SI: /* LS0 */
		edp->chartab0 = 0;
		break;
	case ASCII_ESC:
		if (kernel) {
			printf("wsemul_vt100_output_c0c1: ESC in kernel "
			    "output ignored\n");
			break;	/* ignore the ESC */
		}

		if (edp->state == VT100_EMUL_STATE_STRING) {
			/* might be a string end */
			edp->state = VT100_EMUL_STATE_STRING_ESC;
		} else {
			/* XXX cancel current escape sequence */
			edp->state = VT100_EMUL_STATE_ESC;
		}
		break;
#if 0
	case CSI: /* 8-bit */
		/* XXX cancel current escape sequence */
		edp->nargs = 0;
		memset(edp->args, 0, sizeof (edp->args));
		edp->modif1 = edp->modif2 = '\0';
		edp->state = VT100_EMUL_STATE_CSI;
		break;
	case DCS: /* 8-bit */
		/* XXX cancel current escape sequence */
		edp->nargs = 0;
		memset(edp->args, 0, sizeof (edp->args));
		edp->state = VT100_EMUL_STATE_DCS;
		break;
	case ST: /* string end 8-bit */
		/* XXX only in VT100_EMUL_STATE_STRING */
		wsemul_vt100_handle_dcs(edp);
		return (VT100_EMUL_STATE_NORMAL);
#endif
	case ASCII_LF:
	case ASCII_VT:
	case ASCII_FF:
		wsemul_vt100_nextline(edp);
		break;
	}
}

u_int
wsemul_vt100_output_esc(edp, c)
	struct wsemul_vt100_emuldata *edp;
	u_char c;
{
	u_int newstate = VT100_EMUL_STATE_NORMAL;
	int i;

	switch (c) {
	case '[': /* CSI */
		edp->nargs = 0;
		memset(edp->args, 0, sizeof (edp->args));
		edp->modif1 = edp->modif2 = '\0';
		newstate = VT100_EMUL_STATE_CSI;
		break;
	case '7': /* DECSC */
		edp->flags |= VTFL_SAVEDCURS;
		edp->savedcursor_row = edp->crow;
		edp->savedcursor_col = edp->ccol;
		edp->savedattr = edp->curattr;
		edp->savedbkgdattr = edp->bkgdattr;
		edp->savedattrflags = edp->attrflags;
		edp->savedfgcol = edp->fgcol;
		edp->savedbgcol = edp->bgcol;
		for (i = 0; i < 4; i++)
			edp->savedchartab_G[i] = edp->chartab_G[i];
		edp->savedchartab0 = edp->chartab0;
		edp->savedchartab1 = edp->chartab1;
		break;
	case '8': /* DECRC */
		if ((edp->flags & VTFL_SAVEDCURS) == 0)
			break;
		edp->crow = edp->savedcursor_row;
		edp->ccol = edp->savedcursor_col;
		edp->curattr = edp->savedattr;
		edp->bkgdattr = edp->savedbkgdattr;
		edp->attrflags = edp->savedattrflags;
		edp->fgcol = edp->savedfgcol;
		edp->bgcol = edp->savedbgcol;
		for (i = 0; i < 4; i++)
			edp->chartab_G[i] = edp->savedchartab_G[i];
		edp->chartab0 = edp->savedchartab0;
		edp->chartab1 = edp->savedchartab1;
		break;
	case '=': /* DECKPAM application mode */
		edp->flags |= VTFL_APPLKEYPAD;
		break;
	case '>': /* DECKPNM numeric mode */
		edp->flags &= ~VTFL_APPLKEYPAD;
		break;
	case 'E': /* NEL */
		edp->ccol = 0;
		/* FALLTHRU */
	case 'D': /* IND */
		wsemul_vt100_nextline(edp);
		break;
	case 'H': /* HTS */
		if (edp->tabs != NULL)
			edp->tabs[edp->ccol] = 1;
		break;
	case '~': /* LS1R */
		edp->chartab1 = 1;
		break;
	case 'n': /* LS2 */
		edp->chartab0 = 2;
		break;
	case '}': /* LS2R */
		edp->chartab1 = 2;
		break;
	case 'o': /* LS3 */
		edp->chartab0 = 3;
		break;
	case '|': /* LS3R */
		edp->chartab1 = 3;
		break;
	case 'N': /* SS2 */
		edp->sschartab = 2;
		break;
	case 'O': /* SS3 */
		edp->sschartab = 3;
		break;
	case 'M': /* RI */
		if (ROWS_ABOVE > 0) {
			edp->crow--;
			CHECK_DW;
			break;
		}
		wsemul_vt100_scrolldown(edp, 1);
		break;
	case 'P': /* DCS */
		edp->nargs = 0;
		memset(edp->args, 0, sizeof (edp->args));
		newstate = VT100_EMUL_STATE_DCS;
		break;
	case 'c': /* RIS */
		wsemul_vt100_reset(edp);
		wsemul_vt100_ed(edp, 2);
		edp->ccol = edp->crow = 0;
		break;
	case '(': case ')': case '*': case '+': /* SCS */
		edp->designating = c - '(';
		newstate = VT100_EMUL_STATE_SCS94;
		break;
	case '-': case '.': case '/': /* SCS */
		edp->designating = c - '-' + 1;
		newstate = VT100_EMUL_STATE_SCS96;
		break;
	case '#':
		newstate = VT100_EMUL_STATE_ESC_HASH;
		break;
	case ' ': /* 7/8 bit */
		newstate = VT100_EMUL_STATE_ESC_SPC;
		break;
	case ']': /* OSC operating system command */
	case '^': /* PM privacy message */
	case '_': /* APC application program command */
		/* ignored */
		newstate = VT100_EMUL_STATE_STRING;
		break;
	case '<': /* exit VT52 mode - ignored */
		break;
	    default:
#ifdef VT100_PRINTUNKNOWN
		printf("ESC%c unknown\n", c);
#endif
		break;
	}

	return (newstate);
}

u_int
wsemul_vt100_output_scs94(edp, c)
	struct wsemul_vt100_emuldata *edp;
	u_char c;
{
	u_int newstate = VT100_EMUL_STATE_NORMAL;

	switch (c) {
	case '%': /* probably DEC supplemental graphic */
		newstate = VT100_EMUL_STATE_SCS94_PERCENT;
		break;
	case 'A': /* british / national */
		edp->chartab_G[edp->designating] = edp->nrctab;
		break;
	case 'B': /* ASCII */
		edp->chartab_G[edp->designating] = 0;
		break;
	case '<': /* user preferred supplemental */
		/* XXX not really "user" preferred */
		edp->chartab_G[edp->designating] = edp->isolatin1tab;
		break;
	case '0': /* DEC special graphic */
		edp->chartab_G[edp->designating] = edp->decgraphtab;
		break;
	case '>': /* DEC tech */
		edp->chartab_G[edp->designating] = edp->dectechtab;
		break;
	case '|': /* MirBSD straight-to-font Meta-ASCII (128..255) */
		edp->chartab_G[edp->designating] = mbsd_stf;
		break;
	    default:
#ifdef VT100_PRINTUNKNOWN
		printf("ESC%c%c unknown\n", edp->designating + '(', c);
#endif
		break;
	}
	return (newstate);
}

u_int
wsemul_vt100_output_scs94_percent(edp, c)
	struct wsemul_vt100_emuldata *edp;
	u_char c;
{
	switch (c) {
	case '5': /* DEC supplemental graphic */
		/* XXX there are differences */
		edp->chartab_G[edp->designating] = edp->isolatin1tab;
		break;
	    default:
#ifdef VT100_PRINTUNKNOWN
		printf("ESC%c%%%c unknown\n", edp->designating + '(', c);
#endif
		break;
	}
	return (VT100_EMUL_STATE_NORMAL);
}

u_int
wsemul_vt100_output_scs96(edp, c)
	struct wsemul_vt100_emuldata *edp;
	u_char c;
{
	u_int newstate = VT100_EMUL_STATE_NORMAL;
	int nrc;

	switch (c) {
	case '%': /* probably portugese */
		newstate = VT100_EMUL_STATE_SCS96_PERCENT;
		break;
	case 'A': /* ISO-latin-1 supplemental */
		edp->chartab_G[edp->designating] = edp->isolatin1tab;
		break;
	case '4': /* dutch */
		nrc = 1;
		goto setnrc;
	case '5': case 'C': /* finnish */
		nrc = 2;
		goto setnrc;
	case 'R': /* french */
		nrc = 3;
		goto setnrc;
	case 'Q': /* french canadian */
		nrc = 4;
		goto setnrc;
	case 'K': /* german */
		nrc = 5;
		goto setnrc;
	case 'Y': /* italian */
		nrc = 6;
		goto setnrc;
	case 'E': case '6': /* norwegian / danish */
		nrc = 7;
		goto setnrc;
	case 'Z': /* spanish */
		nrc = 9;
		goto setnrc;
	case '7': case 'H': /* swedish */
		nrc = 10;
		goto setnrc;
	case '=': /* swiss */
		nrc = 11;
setnrc:
		if (vt100_setnrc(edp, nrc) == 0) /* what table ??? */
			break;
		/* else FALLTHROUGH */
	    default:
#ifdef VT100_PRINTUNKNOWN
		printf("ESC%c%c unknown\n", edp->designating + '-' - 1, c);
#endif
		break;
	}
	return (newstate);
}

u_int
wsemul_vt100_output_scs96_percent(edp, c)
	struct wsemul_vt100_emuldata *edp;
	u_char c;
{
	switch (c) {
	case '6': /* portugese */
		if (vt100_setnrc(edp, 8) == 0)
			break;
		/* else FALLTHROUGH */
	    default:
#ifdef VT100_PRINTUNKNOWN
		printf("ESC%c%%%c unknown\n", edp->designating + '-' - 1, c);
#endif
		break;
	}
	return (VT100_EMUL_STATE_NORMAL);
}

u_int
wsemul_vt100_output_esc_spc(edp, c)
	struct wsemul_vt100_emuldata *edp;
	u_char c;
{
	switch (c) {
	case 'F': /* 7-bit controls */
	case 'G': /* 8-bit controls */
#ifdef VT100_PRINTNOTIMPL
		printf("ESC<SPC>%c ignored\n", c);
#endif
		break;
	    default:
#ifdef VT100_PRINTUNKNOWN
		printf("ESC<SPC>%c unknown\n", c);
#endif
		break;
	}
	return (VT100_EMUL_STATE_NORMAL);
}

u_int
wsemul_vt100_output_string(edp, c)
	struct wsemul_vt100_emuldata *edp;
	u_char c;
{
	if (edp->dcstype && edp->dcspos < DCS_MAXLEN)
		edp->dcsarg[edp->dcspos++] = c;
	return (VT100_EMUL_STATE_STRING);
}

u_int
wsemul_vt100_output_string_esc(edp, c)
	struct wsemul_vt100_emuldata *edp;
	u_char c;
{
	if (c == '\\') { /* ST complete */
		wsemul_vt100_handle_dcs(edp);
		return (VT100_EMUL_STATE_NORMAL);
	} else
		return (VT100_EMUL_STATE_STRING);
}

u_int
wsemul_vt100_output_dcs(edp, c)
	struct wsemul_vt100_emuldata *edp;
	u_char c;
{
	u_int newstate = VT100_EMUL_STATE_DCS;

	switch (c) {
	case '0': case '1': case '2': case '3': case '4':
	case '5': case '6': case '7': case '8': case '9':
		/* argument digit */
		if (edp->nargs > VT100_EMUL_NARGS - 1)
			break;
		edp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +
		    (c - '0');
		break;
	case ';': /* argument terminator */
		edp->nargs++;
		break;
	    default:
		edp->nargs++;
		if (edp->nargs > VT100_EMUL_NARGS) {
#ifdef VT100_DEBUG
			printf("vt100: too many arguments\n");
#endif
			edp->nargs = VT100_EMUL_NARGS;
		}
		newstate = VT100_EMUL_STATE_STRING;
		switch (c) {
		case '$':
			newstate = VT100_EMUL_STATE_DCS_DOLLAR;
			break;
		case '{': /* DECDLD soft charset */
		case '!': /* DECRQUPSS user preferred supplemental set */
			/* 'u' must follow - need another state */
		case '|': /* DECUDK program F6..F20 */
#ifdef VT100_PRINTNOTIMPL
			printf("DCS%c ignored\n", c);
#endif
			break;
		    default:
#ifdef VT100_PRINTUNKNOWN
			printf("DCS%c (%d, %d) unknown\n", c, ARG(0), ARG(1));
#endif
			break;
		}
	}

	return (newstate);
}

u_int
wsemul_vt100_output_dcs_dollar(edp, c)
	struct wsemul_vt100_emuldata *edp;
	u_char c;
{
	switch (c) {
	case 'p': /* DECRSTS terminal state restore */
	case 'q': /* DECRQSS control function request */
#ifdef VT100_PRINTNOTIMPL
		printf("DCS$%c ignored\n", c);
#endif
		break;
	case 't': /* DECRSPS restore presentation state */
		switch (ARG(0)) {
		case 0: /* error */
			break;
		case 1: /* cursor information restore */
#ifdef VT100_PRINTNOTIMPL
			printf("DCS1$t ignored\n");
#endif
			break;
		case 2: /* tab stop restore */
			edp->dcspos = 0;
			edp->dcstype = DCSTYPE_TABRESTORE;
			break;
		    default:
#ifdef VT100_PRINTUNKNOWN
			printf("DCS%d$t unknown\n", ARG(0));
#endif
			break;
		}
		break;
	    default:
#ifdef VT100_PRINTUNKNOWN
		printf("DCS$%c (%d, %d) unknown\n", c, ARG(0), ARG(1));
#endif
		break;
	}
	return (VT100_EMUL_STATE_STRING);
}

u_int
wsemul_vt100_output_esc_hash(edp, c)
	struct wsemul_vt100_emuldata *edp;
	u_char c;
{
	int i;

	switch (c) {
	case '5': /*  DECSWL single width, single height */
		if (edp->dblwid != NULL && edp->dw != 0) {
			for (i = 0; i < edp->ncols / 2; i++)
				(*edp->emulops->copycols)(edp->emulcookie,
							  edp->crow,
							  2 * i, i, 1);
			(*edp->emulops->erasecols)(edp->emulcookie, edp->crow,
						   i, edp->ncols - i,
						   edp->bkgdattr);
			edp->dblwid[edp->crow] = 0;
			edp->dw = 0;
		}
		break;
	case '6': /*  DECDWL double width, single height */
	case '3': /*  DECDHL double width, double height, top half */
	case '4': /*  DECDHL double width, double height, bottom half */
		if (edp->dblwid != NULL && edp->dw == 0) {
			for (i = edp->ncols / 2 - 1; i >= 0; i--)
				(*edp->emulops->copycols)(edp->emulcookie,
							  edp->crow,
							  i, 2 * i, 1);
			for (i = 0; i < edp->ncols / 2; i++)
				(*edp->emulops->erasecols)(edp->emulcookie,
							   edp->crow,
							   2 * i + 1, 1,
							   edp->bkgdattr);
			edp->dblwid[edp->crow] = 1;
			edp->dw = 1;
			if (edp->ccol > (edp->ncols >> 1) - 1)
				edp->ccol = (edp->ncols >> 1) - 1;
		}
		break;
	case '8': { /* DECALN */
		int i, j;
		for (i = 0; i < edp->nrows; i++)
			for (j = 0; j < edp->ncols; j++)
				(*edp->emulops->putchar)(edp->emulcookie, i, j,
							 'E', edp->curattr);
		}
		edp->ccol = 0;
		edp->crow = 0;
		break;
	    default:
#ifdef VT100_PRINTUNKNOWN
		printf("ESC#%c unknown\n", c);
#endif
		break;
	}
	return (VT100_EMUL_STATE_NORMAL);
}

u_int
wsemul_vt100_output_csi(edp, c)
	struct wsemul_vt100_emuldata *edp;
	u_char c;
{
	u_int newstate = VT100_EMUL_STATE_CSI;

	switch (c) {
	case '0': case '1': case '2': case '3': case '4':
	case '5': case '6': case '7': case '8': case '9':
		/* argument digit */
		if (edp->nargs > VT100_EMUL_NARGS - 1)
			break;
		edp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +
		    (c - '0');
		break;
	case ';': /* argument terminator */
		edp->nargs++;
		break;
	case '?': /* DEC specific */
	case '>': /* DA query */
		edp->modif1 = c;
		break;
	case '!':
	case '"':
	case '$':
	case '&':
		edp->modif2 = c;
		break;
	    default: /* end of escape sequence */
		edp->nargs++;
		if (edp->nargs > VT100_EMUL_NARGS) {
#ifdef VT100_DEBUG
			printf("vt100: too many arguments\n");
#endif
			edp->nargs = VT100_EMUL_NARGS;
		}
		wsemul_vt100_handle_csi(edp, c);
		newstate = VT100_EMUL_STATE_NORMAL;
		break;
	}
	return (newstate);
}

void
wsemul_vt100_output(cookie, data, count, kernel)
	void *cookie;
	const u_char *data;
	u_int count;
	int kernel;
{
	struct wsemul_vt100_emuldata *edp = cookie;
#ifdef JUMP_SCROLL
	const u_char *eot;
	u_char curchar;
	u_int cnt, pos, lines;
#endif

#ifdef DIAGNOSTIC
	if (kernel && !edp->console)
		panic("wsemul_vt100_output: kernel output, not console");
#endif

	if (edp->flags & VTFL_CURSORON)
		(*edp->emulops->cursor)(edp->emulcookie, 0,
				edp->crow, edp->ccol << edp->dw);

	for (; count > 0; data++, count--) {
#ifdef JUMP_SCROLL
		/*
		 * If we are at the bottom of the scrolling area, count
		 * newlines until an escape sequence appears.
		 */
		if ((edp->state == VT100_EMUL_STATE_NORMAL || kernel) &&
		    ROWS_BELOW == 0) {
			lines = 0;
			pos = edp->ccol;
			for (eot = data, cnt = count; cnt != 0; eot++, cnt--) {
				curchar = *eot;
				/*
				 * Only char for which
				 * wsemul_vt100_output_c0c1() will switch
				 * to escape mode, for now.
				 * Revisit this when this changes...
				 */
				if (curchar == ASCII_ESC)
					break;

				if (ISSET(edp->flags, VTFL_DECAWM))
				    switch (curchar) {
				    case ASCII_BS:
					if (pos > 0)
						pos--;
					break;
				    case ASCII_CR:
					pos = 0;
					break;
				    case ASCII_HT:
					if (edp->tabs) {
						pos++;
						while (pos < NCOLS - 1 &&
						    edp->tabs[pos] == 0)
							pos++;
					} else {
						pos = (pos + 7) & ~7;
						if (pos >= NCOLS)
							pos = NCOLS - 1;
					}
					break;
				    default:
					if ((curchar & 0x7f) < 0x20)
						break;
					if (pos++ >= NCOLS) {
						pos = 0;
						curchar = ASCII_LF;
					}
					break;
				    }

				if (curchar == ASCII_LF ||
				    curchar == ASCII_VT ||
				    curchar == ASCII_FF) {
					if (++lines >= edp->scrreg_nrows - 1)
						break;
				}
			}

			if (lines > 1) {
				wsemul_vt100_scrollup(edp, lines);
				edp->crow -= lines;
			}
		}
#endif

		if ((*data & 0x7f) < 0x20) {
			wsemul_vt100_output_c0c1(edp, *data, kernel);
			continue;
		}

		if (edp->state == VT100_EMUL_STATE_NORMAL || kernel) {
			wsemul_vt100_output_normal(edp, *data, kernel);
			continue;
		}
#ifdef DIAGNOSTIC
		if (edp->state > sizeof(vt100_output) / sizeof(vt100_output[0]))
			panic("wsemul_vt100: invalid state %d", edp->state);
#endif
		edp->state = vt100_output[edp->state - 1](edp, *data);
	}

	if (edp->flags & VTFL_CURSORON)
		(*edp->emulops->cursor)(edp->emulcookie, 1,
				edp->crow, edp->ccol << edp->dw);
}
@


1.3
log
@ESC sequence chars cannot be C0, only visible ASCII; move the
MirBSD straight-to-font Meta-ASCII mapping to ESC x "|" instead
(for x in "(" ")" "*" "+")
@
text
@d1 1
a1 1
/* $MirOS: src/sys/dev/wscons/wsemul_vt100.c,v 1.2 2009/07/24 17:41:04 tg Exp $ */
d162 1
a162 1
#define WS_KERNEL_FG WSCOL_WHITE
d165 1
a165 1
#define WS_KERNEL_BG WSCOL_BLUE
d171 1
a171 1
#define WS_KERNEL_MONOATTR 0
@


1.2
log
@MirBSD extension:
ESC x 1, for x in "(" ")" "*" "+", designates Meta-ASCII (bit7:=1)
@
text
@d1 1
a1 1
/* $MirOS$ */
d621 1
a621 1
	case 1: /* MirBSD straight-to-font Meta-ASCII (128..255) */
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/* $OpenBSD: wsemul_vt100.c,v 1.9 2004/04/02 04:39:51 deraadt Exp $ */
d6 2
d33 4
d70 3
d81 1
d83 1
a83 1
static vt100_handler
d185 2
a186 2
	edp->tabs = 0;
	edp->dblwid = 0;
d189 2
a190 2
	edp->isolatin1tab = edp->decgraphtab = edp->dectechtab = 0;
	edp->nrctab = 0;
d212 3
a214 1
		edp = malloc(sizeof *edp, M_DEVBUF, M_WAITOK);
d224 2
a225 1
	memset(edp->dblwid, 0, edp->nrows);
d246 1
a246 1
#define f(ptr) if (ptr) {free(ptr, M_DEVBUF); ptr = 0;}
d305 1
a305 1
	edp->chartab_G[0] = 0;
d315 19
d347 1
a347 5
		if (ROWS_BELOW > 0) {
			edp->crow++;
			CHECK_DW;
		} else
			wsemul_vt100_scrollup(edp, 1);
d362 1
a362 1
	dc = (ct ? ct[c] : c);
d386 2
a387 2
	    case ASCII_NUL:
	    default:
d390 1
a390 1
	    case ASCII_BEL:
d393 1
a393 1
	    case ASCII_BS:
d399 1
a399 1
	    case ASCII_CR:
d403 1
a403 1
	    case ASCII_HT:
d415 1
a415 1
	    case ASCII_SO: /* LS1 */
d418 1
a418 1
	    case ASCII_SI: /* LS0 */
d421 1
a421 1
	    case ASCII_ESC:
d437 1
a437 1
	    case CSI: /* 8-bit */
d444 1
a444 1
	    case DCS: /* 8-bit */
d450 1
a450 1
	    case ST: /* string end 8-bit */
d455 4
a458 8
	    case ASCII_LF:
	    case ASCII_VT:
	    case ASCII_FF:
		if (ROWS_BELOW > 0) {
			edp->crow++;
			CHECK_DW;
		} else
			wsemul_vt100_scrollup(edp, 1);
d472 1
a472 1
	    case '[': /* CSI */
d478 2
a479 1
	    case '7': /* DECSC */
d492 3
a494 1
	    case '8': /* DECRC */
d507 1
a507 1
	    case '=': /* DECKPAM application mode */
d510 1
a510 1
	    case '>': /* DECKPNM numeric mode */
d513 1
a513 1
	    case 'E': /* NEL */
d516 2
a517 7
	    case 'D': /* IND */
		if (ROWS_BELOW > 0) {
			edp->crow++;
			CHECK_DW;
			break;
		}
		wsemul_vt100_scrollup(edp, 1);
d519 3
a521 3
	    case 'H': /* HTS */
		KASSERT(edp->tabs != 0);
		edp->tabs[edp->ccol] = 1;
d523 1
a523 1
	    case '~': /* LS1R */
d526 1
a526 1
	    case 'n': /* LS2 */
d529 1
a529 1
	    case '}': /* LS2R */
d532 1
a532 1
	    case 'o': /* LS3 */
d535 1
a535 1
	    case '|': /* LS3R */
d538 1
a538 1
	    case 'N': /* SS2 */
d541 1
a541 1
	    case 'O': /* SS3 */
d544 1
a544 1
	    case 'M': /* RI */
d552 1
a552 1
	    case 'P': /* DCS */
d557 1
a557 1
	    case 'c': /* RIS */
d562 1
a562 1
	    case '(': case ')': case '*': case '+': /* SCS */
d566 1
a566 1
	    case '-': case '.': case '/': /* SCS */
d570 1
a570 1
	    case '#':
d573 1
a573 1
	    case ' ': /* 7/8 bit */
d576 3
a578 3
	    case ']': /* OSC operating system command */
	    case '^': /* PM privacy message */
	    case '_': /* APC application program command */
d582 1
a582 1
	    case '<': /* exit VT52 mode - ignored */
d602 1
a602 1
	    case '%': /* probably DEC supplemental graphic */
d605 1
a605 1
	    case 'A': /* british / national */
d608 1
a608 1
	    case 'B': /* ASCII */
d611 1
a611 1
	    case '<': /* user preferred supplemental */
d615 1
a615 1
	    case '0': /* DEC special graphic */
d618 1
a618 1
	    case '>': /* DEC tech */
d621 3
d639 1
a639 1
	    case '5': /* DEC supplemental graphic */
d661 1
a661 1
	    case '%': /* probably portugese */
d664 1
a664 1
	    case 'A': /* ISO-latin-1 supplemental */
d667 1
a667 1
	    case '4': /* dutch */
d670 1
a670 1
	    case '5': case 'C': /* finnish */
d673 1
a673 1
	    case 'R': /* french */
d676 1
a676 1
	    case 'Q': /* french canadian */
d679 1
a679 1
	    case 'K': /* german */
d682 1
a682 1
	    case 'Y': /* italian */
d685 1
a685 1
	    case 'E': case '6': /* norwegian / danish */
d688 1
a688 1
	    case 'Z': /* spanish */
d691 1
a691 1
	    case '7': case 'H': /* swedish */
d694 1
a694 1
	    case '=': /* swiss */
d697 3
a699 2
		vt100_setnrc(edp, nrc); /* what table ??? */
		break;
d715 4
a718 3
	    case '6': /* portugese */
		vt100_setnrc(edp, 8);
		break;
d721 1
a721 1
		printf("ESC%c%%%c unknown\n", edp->designating + '-', c);
d734 2
a735 2
	    case 'F': /* 7-bit controls */
	    case 'G': /* 8-bit controls */
d779 2
a780 2
	    case '0': case '1': case '2': case '3': case '4':
	    case '5': case '6': case '7': case '8': case '9':
d787 1
a787 1
	    case ';': /* argument terminator */
d800 1
a800 1
		    case '$':
d803 2
a804 2
		    case '{': /* DECDLD soft charset */
		    case '!': /* DECRQUPSS user preferred supplemental set */
d806 1
a806 1
		    case '|': /* DECUDK program F6..F20 */
d828 2
a829 2
	    case 'p': /* DECRSTS terminal state restore */
	    case 'q': /* DECRQSS control function request */
d834 1
a834 1
	    case 't': /* DECRSPS restore presentation state */
d836 1
a836 1
		    case 0: /* error */
d838 1
a838 1
		    case 1: /* cursor information restore */
d843 1
a843 1
		    case 2: /* tab stop restore */
d871 2
a872 2
	    case '5': /*  DECSWL single width, single height */
		if (edp->dw) {
d884 4
a887 4
	    case '6': /*  DECDWL double width, single height */
	    case '3': /*  DECDHL double width, double height, top half */
	    case '4': /*  DECDHL double width, double height, bottom half */
		if (!edp->dw) {
d903 1
a903 1
	    case '8': { /* DECALN */
d930 2
a931 2
	    case '0': case '1': case '2': case '3': case '4':
	    case '5': case '6': case '7': case '8': case '9':
d938 1
a938 1
	    case ';': /* argument terminator */
d941 2
a942 2
	    case '?': /* DEC specific */
	    case '>': /* DA query */
d945 4
a948 4
	    case '!':
	    case '"':
	    case '$':
	    case '&':
d974 5
d986 1
a986 1
	(*edp->emulops->cursor)(edp->emulcookie, 0,
d988 1
d990 66
d1060 1
d1071 1
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@lastly some drivers
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.12 2004/12/25 20:40:33 deraadt Exp $ */
a70 1
void wsemul_vt100_nextline(struct wsemul_vt100_emuldata *);
d72 1
a72 1
vt100_handler
a300 19
 * Move the cursor to the next line if possible. If the cursor is at
 * the bottom of the scroll area, then scroll it up. If the cursor is
 * at the bottom of the screen then don't move it down.
 */
void
wsemul_vt100_nextline(struct wsemul_vt100_emuldata *edp)
{
	if (ROWS_BELOW == 0) {
		/* Bottom of the scroll region. */
	  	wsemul_vt100_scrollup(edp, 1);
	} else {
		if ((edp->crow+1) < edp->nrows)
			/* Cursor not at the bottom of the screen. */
			edp->crow++;
		CHECK_DW;
	}
}	

/*
d314 5
a318 1
		wsemul_vt100_nextline(edp);
d429 5
a433 1
		wsemul_vt100_nextline(edp);
a453 1
		edp->flags |= VTFL_SAVEDCURS;
a466 2
		if ((edp->flags & VTFL_SAVEDCURS) == 0)
			break;
d489 6
a494 1
		wsemul_vt100_nextline(edp);
d953 1
a953 1
		(*edp->emulops->cursor)(edp->emulcookie, 0,
@


1.1.1.3
log
@import current wscons & friends code from OpenBSD
in the hope it will be useful
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.17 2007/01/07 13:31:36 miod Exp $ */
a29 4
#ifndef	SMALL_KERNEL
#define	JUMP_SCROLL
#endif

d175 2
a176 2
	edp->tabs = NULL;
	edp->dblwid = NULL;
d179 2
a180 2
	edp->isolatin1tab = edp->decgraphtab = edp->dectechtab = NULL;
	edp->nrctab = NULL;
d202 1
a202 3
		edp = malloc(sizeof *edp, M_DEVBUF, M_NOWAIT);
		if (edp == NULL)
			return (NULL);
d212 1
a212 2
	if (edp->dblwid != NULL)
		memset(edp->dblwid, 0, edp->nrows);
d233 1
a233 1
#define f(ptr) if (ptr) {free(ptr, M_DEVBUF); ptr = NULL;}
d292 1
a292 1
	edp->chartab_G[0] = NULL;
d373 2
a374 2
	case ASCII_NUL:
	default:
d377 1
a377 1
	case ASCII_BEL:
d380 1
a380 1
	case ASCII_BS:
d386 1
a386 1
	case ASCII_CR:
d390 1
a390 1
	case ASCII_HT:
d402 1
a402 1
	case ASCII_SO: /* LS1 */
d405 1
a405 1
	case ASCII_SI: /* LS0 */
d408 1
a408 1
	case ASCII_ESC:
d424 1
a424 1
	case CSI: /* 8-bit */
d431 1
a431 1
	case DCS: /* 8-bit */
d437 1
a437 1
	case ST: /* string end 8-bit */
d442 3
a444 3
	case ASCII_LF:
	case ASCII_VT:
	case ASCII_FF:
d459 1
a459 1
	case '[': /* CSI */
d465 1
a465 1
	case '7': /* DECSC */
d479 1
a479 1
	case '8': /* DECRC */
d494 1
a494 1
	case '=': /* DECKPAM application mode */
d497 1
a497 1
	case '>': /* DECKPNM numeric mode */
d500 1
a500 1
	case 'E': /* NEL */
d503 1
a503 1
	case 'D': /* IND */
d506 3
a508 3
	case 'H': /* HTS */
		if (edp->tabs != NULL)
			edp->tabs[edp->ccol] = 1;
d510 1
a510 1
	case '~': /* LS1R */
d513 1
a513 1
	case 'n': /* LS2 */
d516 1
a516 1
	case '}': /* LS2R */
d519 1
a519 1
	case 'o': /* LS3 */
d522 1
a522 1
	case '|': /* LS3R */
d525 1
a525 1
	case 'N': /* SS2 */
d528 1
a528 1
	case 'O': /* SS3 */
d531 1
a531 1
	case 'M': /* RI */
d539 1
a539 1
	case 'P': /* DCS */
d544 1
a544 1
	case 'c': /* RIS */
d549 1
a549 1
	case '(': case ')': case '*': case '+': /* SCS */
d553 1
a553 1
	case '-': case '.': case '/': /* SCS */
d557 1
a557 1
	case '#':
d560 1
a560 1
	case ' ': /* 7/8 bit */
d563 3
a565 3
	case ']': /* OSC operating system command */
	case '^': /* PM privacy message */
	case '_': /* APC application program command */
d569 1
a569 1
	case '<': /* exit VT52 mode - ignored */
d589 1
a589 1
	case '%': /* probably DEC supplemental graphic */
d592 1
a592 1
	case 'A': /* british / national */
d595 1
a595 1
	case 'B': /* ASCII */
d598 1
a598 1
	case '<': /* user preferred supplemental */
d602 1
a602 1
	case '0': /* DEC special graphic */
d605 1
a605 1
	case '>': /* DEC tech */
d623 1
a623 1
	case '5': /* DEC supplemental graphic */
d645 1
a645 1
	case '%': /* probably portugese */
d648 1
a648 1
	case 'A': /* ISO-latin-1 supplemental */
d651 1
a651 1
	case '4': /* dutch */
d654 1
a654 1
	case '5': case 'C': /* finnish */
d657 1
a657 1
	case 'R': /* french */
d660 1
a660 1
	case 'Q': /* french canadian */
d663 1
a663 1
	case 'K': /* german */
d666 1
a666 1
	case 'Y': /* italian */
d669 1
a669 1
	case 'E': case '6': /* norwegian / danish */
d672 1
a672 1
	case 'Z': /* spanish */
d675 1
a675 1
	case '7': case 'H': /* swedish */
d678 1
a678 1
	case '=': /* swiss */
d681 2
a682 3
		if (vt100_setnrc(edp, nrc) == 0) /* what table ??? */
			break;
		/* else FALLTHROUGH */
d698 3
a700 4
	case '6': /* portugese */
		if (vt100_setnrc(edp, 8) == 0)
			break;
		/* else FALLTHROUGH */
d703 1
a703 1
		printf("ESC%c%%%c unknown\n", edp->designating + '-' - 1, c);
d716 2
a717 2
	case 'F': /* 7-bit controls */
	case 'G': /* 8-bit controls */
d761 2
a762 2
	case '0': case '1': case '2': case '3': case '4':
	case '5': case '6': case '7': case '8': case '9':
d769 1
a769 1
	case ';': /* argument terminator */
d782 1
a782 1
		case '$':
d785 2
a786 2
		case '{': /* DECDLD soft charset */
		case '!': /* DECRQUPSS user preferred supplemental set */
d788 1
a788 1
		case '|': /* DECUDK program F6..F20 */
d810 2
a811 2
	case 'p': /* DECRSTS terminal state restore */
	case 'q': /* DECRQSS control function request */
d816 1
a816 1
	case 't': /* DECRSPS restore presentation state */
d818 1
a818 1
		case 0: /* error */
d820 1
a820 1
		case 1: /* cursor information restore */
d825 1
a825 1
		case 2: /* tab stop restore */
d853 2
a854 2
	case '5': /*  DECSWL single width, single height */
		if (edp->dblwid != NULL && edp->dw != 0) {
d866 4
a869 4
	case '6': /*  DECDWL double width, single height */
	case '3': /*  DECDHL double width, double height, top half */
	case '4': /*  DECDHL double width, double height, bottom half */
		if (edp->dblwid != NULL && edp->dw == 0) {
d885 1
a885 1
	case '8': { /* DECALN */
d912 2
a913 2
	case '0': case '1': case '2': case '3': case '4':
	case '5': case '6': case '7': case '8': case '9':
d920 1
a920 1
	case ';': /* argument terminator */
d923 2
a924 2
	case '?': /* DEC specific */
	case '>': /* DA query */
d927 4
a930 4
	case '!':
	case '"':
	case '$':
	case '&':
a955 5
#ifdef JUMP_SCROLL
	const u_char *eot;
	u_char curchar;
	u_int cnt, pos, lines;
#endif
a964 1

a965 66
#ifdef JUMP_SCROLL
		/*
		 * If we are at the bottom of the scrolling area, count
		 * newlines until an escape sequence appears.
		 */
		if ((edp->state == VT100_EMUL_STATE_NORMAL || kernel) &&
		    ROWS_BELOW == 0) {
			lines = 0;
			pos = edp->ccol;
			for (eot = data, cnt = count; cnt != 0; eot++, cnt--) {
				curchar = *eot;
				/*
				 * Only char for which
				 * wsemul_vt100_output_c0c1() will switch
				 * to escape mode, for now.
				 * Revisit this when this changes...
				 */
				if (curchar == ASCII_ESC)
					break;

				if (ISSET(edp->flags, VTFL_DECAWM))
				    switch (curchar) {
				    case ASCII_BS:
					if (pos > 0)
						pos--;
					break;
				    case ASCII_CR:
					pos = 0;
					break;
				    case ASCII_HT:
					if (edp->tabs) {
						pos++;
						while (pos < NCOLS - 1 &&
						    edp->tabs[pos] == 0)
							pos++;
					} else {
						pos = (pos + 7) & ~7;
						if (pos >= NCOLS)
							pos = NCOLS - 1;
					}
					break;
				    default:
					if ((curchar & 0x7f) < 0x20)
						break;
					if (pos++ >= NCOLS) {
						pos = 0;
						curchar = ASCII_LF;
					}
					break;
				    }

				if (curchar == ASCII_LF ||
				    curchar == ASCII_VT ||
				    curchar == ASCII_FF) {
					if (++lines >= edp->scrreg_nrows - 1)
						break;
				}
			}

			if (lines > 1) {
				wsemul_vt100_scrollup(edp, lines);
				edp->crow -= lines;
			}
		}
#endif

a969 1

a979 1

@


