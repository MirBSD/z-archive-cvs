head	1.79;
access;
symbols
	tg-beforemerge-ksrc10:1.1.1.4
	MIRBSD_10:1.33.0.4
	MIRBSD_10_BASE:1.33
	MIRBSD_9_BASE:1.21
	tg-rndaddpool-debug:1.20.0.2
	MIRBSD_8:1.4.0.2
	MIRBSD_8_BASE:1.4
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.79
date	2019.08.25.22.20.51;	author tg;	state Exp;
branches;
next	1.78;
commitid	1005D63096C6637033A;

1.78
date	2019.08.25.21.26.01;	author tg;	state Exp;
branches;
next	1.77;
commitid	1005D62FCDC7F4EA8E0;

1.77
date	2017.08.09.10.50.07;	author tg;	state Exp;
branches;
next	1.76;
commitid	100598AE8E34CCF9581;

1.76
date	2017.08.08.15.14.46;	author tg;	state Exp;
branches;
next	1.75;
commitid	1005989D5710E59BF98;

1.75
date	2014.02.20.00.30.24;	author tg;	state Exp;
branches;
next	1.74;
commitid	10053054CA71B859DC9;

1.74
date	2013.10.24.08.32.37;	author tg;	state Exp;
branches;
next	1.73;
commitid	1005268DAE46A5CAE15;

1.73
date	2011.11.20.18.54.46;	author tg;	state Exp;
branches;
next	1.72;
commitid	1004EC94CC144CEC290;

1.72
date	2011.02.19.14.41.36;	author tg;	state Exp;
branches;
next	1.71;
commitid	1004D5FD6AD4C707315;

1.71
date	2010.12.24.00.11.00;	author tg;	state Exp;
branches;
next	1.70;
commitid	1004D13E5244D978DD8;

1.70
date	2010.12.23.19.25.32;	author tg;	state Exp;
branches;
next	1.69;
commitid	1004D13A2417F2232C8;

1.69
date	2010.09.25.14.11.46;	author tg;	state Exp;
branches;
next	1.68;
commitid	1004C9E03397C26FA1E;

1.68
date	2010.09.25.01.29.34;	author tg;	state Exp;
branches;
next	1.67;
commitid	1004C9D50823DFFA28B;

1.67
date	2010.09.24.21.37.34;	author tg;	state Exp;
branches;
next	1.66;
commitid	1004C9D1A1633B6D2E3;

1.66
date	2010.09.24.21.31.19;	author tg;	state Exp;
branches;
next	1.65;
commitid	1004C9D17EF4AAFFCE9;

1.65
date	2010.09.24.20.35.12;	author tg;	state Exp;
branches;
next	1.64;
commitid	1004C9D0B38596B6444;

1.64
date	2010.09.24.19.59.09;	author tg;	state Exp;
branches;
next	1.63;
commitid	1004C9D02C32F9ABA6D;

1.63
date	2010.09.19.18.55.34;	author tg;	state Exp;
branches;
next	1.62;
commitid	1004C965C8F46717878;

1.62
date	2010.09.12.19.02.15;	author tg;	state Exp;
branches;
next	1.61;
commitid	1004C8D23B831318D31;

1.61
date	2010.09.12.18.50.25;	author tg;	state Exp;
branches;
next	1.60;
commitid	1004C8D20FC68053736;

1.60
date	2010.09.12.18.20.00;	author tg;	state Exp;
branches;
next	1.59;
commitid	1004C8D19CE4D7E4CD9;

1.59
date	2010.09.12.12.24.30;	author tg;	state Exp;
branches;
next	1.58;
commitid	1004C8CC69150D1B4BD;

1.58
date	2010.01.28.23.00.45;	author tg;	state Exp;
branches;
next	1.57;
commitid	1004B6216F010CD4496;

1.57
date	2010.01.06.19.11.53;	author tg;	state Exp;
branches;
next	1.56;
commitid	1004B44E03412A89242;

1.56
date	2010.01.06.17.52.33;	author tg;	state Exp;
branches;
next	1.55;
commitid	1004B44CDF76EA71CDB;

1.55
date	2009.11.09.21.36.40;	author tg;	state Exp;
branches;
next	1.54;
commitid	1004AF88B6210E6BBB3;

1.54
date	2009.11.09.20.11.56;	author tg;	state Exp;
branches;
next	1.53;
commitid	1004AF877472390A74C;

1.53
date	2009.11.09.19.49.27;	author tg;	state Exp;
branches;
next	1.52;
commitid	1004AF872556D775AC4;

1.52
date	2009.11.09.19.43.45;	author tg;	state Exp;
branches;
next	1.51;
commitid	1004AF870EF5AE8038B;

1.51
date	2009.02.22.17.06.26;	author tg;	state Exp;
branches;
next	1.50;
commitid	10049A185F539B9D87C;

1.50
date	2009.01.29.17.53.29;	author tg;	state Exp;
branches;
next	1.49;
commitid	1004981EC3226B1450A;

1.49
date	2009.01.21.19.46.53;	author tg;	state Exp;
branches;
next	1.48;
commitid	10049777BBE4DF923C6;

1.48
date	2008.12.26.19.58.06;	author tg;	state Exp;
branches;
next	1.47;
commitid	100495537633C63E0D6;

1.47
date	2008.11.13.00.19.00;	author tg;	state Exp;
branches;
next	1.46;
commitid	100491B72610A0B4932;

1.46
date	2008.07.26.19.40.51;	author tg;	state Exp;
branches;
next	1.45;
commitid	100488B7DCB62D12C2B;

1.45
date	2008.07.12.16.15.15;	author tg;	state Exp;
branches;
next	1.44;
commitid	1004878D81E0053C1D0;

1.44
date	2008.07.10.14.39.24;	author tg;	state Exp;
branches;
next	1.43;
commitid	10048761F304136E092;

1.43
date	2008.07.08.13.43.12;	author tg;	state Exp;
branches;
next	1.42;
commitid	10048736F031A71E520;

1.42
date	2008.07.08.13.25.28;	author tg;	state Exp;
branches;
next	1.41;
commitid	10048736A6C78B7F150;

1.41
date	2008.07.08.13.20.04;	author tg;	state Exp;
branches;
next	1.40;
commitid	100487368DB7C3C0CE4;

1.40
date	2008.06.13.14.00.04;	author tg;	state Exp;
branches;
next	1.39;
commitid	10048527D4D464F8F7D;

1.39
date	2008.06.13.13.11.50;	author tg;	state Exp;
branches;
next	1.38;
commitid	1004852721E130137B5;

1.38
date	2008.04.09.05.45.41;	author tg;	state Exp;
branches;
next	1.37;
commitid	10047FC57D909BED61F;

1.37
date	2008.03.22.22.58.41;	author tg;	state Exp;
branches;
next	1.36;
commitid	10047E58F3353EBD9BA;

1.36
date	2008.03.22.22.54.17;	author tg;	state Exp;
branches;
next	1.35;
commitid	10047E58DF92B63D5BB;

1.35
date	2008.03.22.22.26.29;	author tg;	state Exp;
branches;
next	1.34;
commitid	10047E57FC91F0D4F1A;

1.34
date	2008.03.21.19.22.16;	author tg;	state Exp;
branches;
next	1.33;
commitid	10047E40AFE44E65982;

1.33
date	2007.09.28.18.33.24;	author tg;	state Exp;
branches
	1.33.4.1;
next	1.32;
commitid	10046FD48A70BF91C15;

1.32
date	2007.09.24.16.56.23;	author tg;	state Exp;
branches;
next	1.31;
commitid	10046F7EC32124255D0;

1.31
date	2007.09.24.16.24.25;	author tg;	state Exp;
branches;
next	1.30;
commitid	10046F7E3C545DA7572;

1.30
date	2007.08.24.14.15.05;	author tg;	state Exp;
branches;
next	1.29;
commitid	10046CEE7E37D5DCB3F;

1.29
date	2007.07.26.10.16.21;	author tg;	state Exp;
branches;
next	1.28;
commitid	10046A874532AD148D2;

1.28
date	2007.06.27.18.33.04;	author tg;	state Exp;
branches;
next	1.27;
commitid	1004682AD576DE15368;

1.27
date	2007.02.02.16.45.07;	author tg;	state Exp;
branches;
next	1.26;
commitid	10045C36A7B5DB2058E;

1.26
date	2006.10.08.00.24.43;	author tg;	state Exp;
branches;
next	1.25;
commitid	100452845255DA75FEF;

1.25
date	2006.10.03.20.23.56;	author tg;	state Exp;
branches;
next	1.24;
commitid	1004522C65D1DCF6C98;

1.24
date	2006.08.22.20.58.24;	author tg;	state Exp;
branches;
next	1.23;
commitid	10044EB6F0E3FCA4304;

1.23
date	2006.08.18.12.29.52;	author tg;	state Exp;
branches;
next	1.22;
commitid	10044E5B2BC1BD5DDC8;

1.22
date	2006.06.29.13.27.36;	author tg;	state Exp;
branches;
next	1.21;
commitid	10044A3D52C39EC17B5;

1.21
date	2006.05.28.23.35.20;	author tg;	state Exp;
branches;
next	1.20;
commitid	100447A339A097D44B1;

1.20
date	2006.05.28.13.24.54;	author tg;	state Exp;
branches
	1.20.2.1;
next	1.19;
commitid	1004479A4562E49A173;

1.19
date	2006.05.28.13.19.11;	author tg;	state Exp;
branches;
next	1.18;
commitid	1004479A3517746A8D0;

1.18
date	2006.05.28.02.55.16;	author tg;	state Exp;
branches;
next	1.17;
commitid	1004479112757429F47;

1.17
date	2006.05.28.02.52.58;	author tg;	state Exp;
branches;
next	1.16;

1.16
date	2006.05.28.01.50.14;	author tg;	state Exp;
branches;
next	1.15;

1.15
date	2006.05.26.12.04.59;	author tg;	state Exp;
branches;
next	1.14;
commitid	1004476EF36CAFEBABE;

1.14
date	2006.05.07.07.06.32;	author tg;	state Exp;
branches;
next	1.13;
commitid	100445D9C825C570209;

1.13
date	2006.05.07.06.54.46;	author tg;	state Exp;
branches;
next	1.12;
commitid	100445D99B5084761F0;

1.12
date	2006.04.11.00.32.52;	author tg;	state Exp;
branches;
next	1.11;
commitid	100443AF9346F76C59A;

1.11
date	2006.04.11.00.29.51;	author tg;	state Exp;
branches;
next	1.10;
commitid	100443AF8346F2D196C;

1.10
date	2006.04.11.00.23.41;	author tg;	state Exp;
branches;
next	1.9;
commitid	100443AF6D06492E539;

1.9
date	2006.03.27.09.25.23;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004427AF807DDD5CA8;

1.8
date	2006.02.27.20.45.30;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004403647A07609421;

1.7
date	2006.02.23.01.29.32;	author tg;	state Exp;
branches;
next	1.6;
commitid	10043FD100E561F2298;

1.6
date	2006.02.23.01.28.27;	author tg;	state Exp;
branches;
next	1.5;
commitid	10043FD0F3B7B6DD667;

1.5
date	2006.02.23.01.18.20;	author tg;	state Exp;
branches;
next	1.4;
commitid	10043FD0CF30CCBD1F1;

1.4
date	2005.07.07.14.01.59;	author tg;	state Exp;
branches
	1.4.2.1;
next	1.3;
commitid	7eb842cd35eab21d;

1.3
date	2005.07.04.00.10.41;	author tg;	state Exp;
branches;
next	1.2;
commitid	374642c87e71f89d;

1.2
date	2005.03.06.21.27.35;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.27.48;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.33.4.1
date	2008.07.08.13.27.50;	author tg;	state Exp;
branches;
next	;
commitid	10048736AFA24714F87;

1.20.2.1
date	2006.05.28.19.24.59;	author tg;	state Exp;
branches;
next	;
commitid	1004479F89D06CF5B19;

1.4.2.1
date	2006.04.11.00.34.14;	author tg;	state Exp;
branches;
next	;
commitid	100443AF98142650B20;

1.1.1.1
date	2005.02.05.17.27.48;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.07.04.00.01.27;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	679142c87c5628b2;

1.1.1.3
date	2005.07.07.14.00.21;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	264042cd35824ee0;

1.1.1.4
date	2008.07.10.14.36.42;	author tg;	state Exp;
branches;
next	;
commitid	10048761E8F7F89D358;


desc
@@


1.79
log
@fix initial_entropy and _randseed reading:
• use the latter for locore
• concatenate them for randomattach, hash for enqueue_randomness
• switch to explicit_bzero in many places
@
text
@/* $MirOS: src/sys/dev/rnd.c,v 1.78 2019/08/25 21:26:01 tg Exp $ */

/*-
 * rnd.c -- A strong random number generator
 *
 * Copyright (c) 2000, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
 *		 2010, 2013, 2014, 2019
 *	mirabilos <m@@mirbsd.org>
 * Copyright (c) 1996, 1997, 2000-2002 Michael Shalayeff.
 *
 * Copyright Theodore Ts'o, 1994, 1995, 1996, 1997, 1998, 1999.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, and the entire permission notice in its entirety,
 *    including the disclaimer of warranties.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote
 *    products derived from this software without specific prior
 *    written permission.
 *
 * ALTERNATIVELY, this product may be distributed under the terms of
 * the GNU Public License, in which case the provisions of the GPL are
 * required INSTEAD OF the above restrictions.  (This clause is
 * necessary due to a potential bad interaction between the GPL and
 * the restrictions contained in a BSD-style copyright.)
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*-
 * (now, with legal B.S. out of the way.....)
 *
 * This routine gathers environmental noise from device drivers, etc.,
 * and returns good random numbers, suitable for cryptographic use.
 * Besides the obvious cryptographic uses, these numbers are also good
 * for seeding TCP sequence numbers, and other places where it is
 * desirable to have numbers which are not only random, but hard to
 * predict by an attacker.
 *
 * Theory of operation
 * ===================
 *
 * Computers are very predictable devices.  Hence it is extremely hard
 * to produce truly random numbers on a computer --- as opposed to
 * pseudo-random numbers, which can be easily generated by using an
 * algorithm.  Unfortunately, it is very easy for attackers to guess
 * the sequence of pseudo-random number generators, and for some
 * applications this is not acceptable.  Instead, we must try to
 * gather "environmental noise" from the computer's environment, which
 * must be hard for outside attackers to observe and use to
 * generate random numbers.  In a Unix environment, this is best done
 * from inside the kernel.
 *
 * Sources of randomness from the environment include inter-keyboard
 * timings, inter-interrupt timings from some interrupts, and other
 * events which are both (a) non-deterministic and (b) hard for an
 * outside observer to measure.  Randomness from these sources is
 * added to the "entropy pool", which is mixed using a CRC-like function.
 * This is not cryptographically strong, but it is adequate assuming
 * the randomness is not chosen maliciously, and it is fast enough that
 * the overhead of doing it on every interrupt is very reasonable.
 * As random bytes are mixed into the entropy pool, the routines keep
 * an *estimate* of how many bits of randomness have been stored into
 * the random number generator's internal state.
 *
 * When random bytes are desired, they are obtained by taking the MD5
 * hash of the content of the entropy pool.  The MD5 hash avoids
 * exposing the internal state of the entropy pool.  It is believed to
 * be computationally infeasible to derive any useful information
 * about the input of MD5 from its output.  Even if it is possible to
 * analyze MD5 in some clever way, as long as the amount of data
 * returned from the generator is less than the inherent entropy in
 * the pool, the output data is totally unpredictable.  For this
 * reason, the routine decreases its internal estimate of how many
 * bits of "true randomness" are contained in the entropy pool as it
 * outputs random numbers.
 *
 * If this estimate goes to zero, the routine can still generate
 * random numbers; however, an attacker may (at least in theory) be
 * able to infer the future output of the generator from prior
 * outputs.  This requires successful cryptanalysis of MD5, which is
 * believed to be not feasible, but there is a remote possibility.
 * Nonetheless, these numbers should be useful for the vast majority
 * of purposes.
 *
 * Exported interfaces ---- output
 * ===============================
 *
 * There are three exported interfaces.
 * The first one is designed to be used from within the kernel:
 *
 *	void get_random_bytes(void *buf, size_t nbytes);
 *
 * This interface will return the requested number of random bytes,
 * and place it in the requested buffer.
 *
 * Two other interfaces are two character devices /dev/random and
 * /dev/urandom.  /dev/random is suitable for use when very high
 * quality randomness is desired (for example, for key generation or
 * one-time pads), as it will only return a maximum of the number of
 * bits of randomness (as estimated by the random number generator)
 * contained in the entropy pool.
 *
 * The /dev/urandom device does not have this limit, and will return
 * as many bytes as were requested.  As more and more random bytes
 * requested without giving time for the entropy pool to recharge,
 * this will result in random numbers that are merely cryptographically
 * strong.  For many applications, however, this is acceptable.
 *
 * On OpenBSD and MirBSD, the /dev/arandom device will return the
 * output of an arcfour stream cipher, which is periodically reseeded
 * from the kernel pool. All applications are strongly encouraged to
 * use the /dev/arandom device for all their entropy needs instead,
 * as it will never deplete the kernel's entropy pool.
 *
 * On OpenBSD and MirBSD, the /dev/prandom device will return numbers
 * from random() calls, which, while not secure or random at all, are
 * blazingly fast. Do not use.
 *
 * On MirBSD, /dev/wrandom (with the same minor number as /dev/prandom)
 * exports a user-writable, non-privileged interface to get entropic
 * bytes from userspace into the kernel. See /sys/crypto/random.c for
 * more information on this.
 *
 * Exported interfaces ---- input
 * ==============================
 *
 * The current exported interfaces for gathering environmental noise
 * from the devices are:
 *
 *	void add_true_randomness(int data);
 *	void add_timer_randomness(int data);
 *	void add_mouse_randomness(int mouse_data);
 *	void add_tty_randomness(int c);
 *	void add_disk_randomness(int n);
 *	void add_net_randomness(int isr);
 *	void add_auvis_randomness(int n);
 *	void add_imacs_randomness(int data);
 *
 * add_true_randomness() uses true random number generators present
 * on some cryptographic and system chipsets.  Entropy accounting
 * is not quitable, no timing is done, supplied 32 bits of pure entropy
 * are hashed into the pool plain and blindly, increasing the counter.
 *
 * add_timer_randomness() uses the random driver itselves timing,
 * measuring extract_entropy() and rndioctl() execution times.
 *
 * add_mouse_randomness() uses the mouse interrupt timing, as well as
 * the reported position of the mouse from the hardware.
 *
 * add_net_randomness() times the finishing time of net input.
 *
 * add_tty_randomness() uses the inter-keypress timing, as well as the
 * character as random inputs into the entropy pool.
 *
 * add_disk_randomness() times the finishing time of disk requests as well
 * as feeding both xfer size & time into the entropy pool.
 *
 * add_auvis_randomness() times the finishing of audio/video codec dma
 * requests for both recording and playback, apparently supplies quite
 * a lot of entropy. I'd blame it on low resolution audio clock generators.
 *
 * add_imacs_randomness() is called from keyboard drivers in order
 * to be able to use things that won't end up as tty randomness,
 * such as (local) meta/alt/ctrl/shift key events.
 *
 * All of these routines (except for add_true_randomness() of course)
 * try to estimate how many bits of randomness are in a particular
 * randomness source.  They do this by keeping track of the first and
 * second order deltas of the event timings.
 *
 * Ensuring unpredictability at system startup
 * ============================================
 *
 * When any operating system starts up, it will go through a sequence
 * of actions that are fairly predictable by an adversary, especially
 * if the start-up does not involve interaction with a human operator.
 * This reduces the actual number of bits of unpredictability in the
 * entropy pool below the value in entropy_count.  In order to
 * counteract this effect, it helps to carry information in the
 * entropy pool across shut-downs and start-ups.  To do this, put the
 * following lines in appropriate script which is run during the boot
 * sequence:
 *
 *	echo "Initializing random number generator..."
 *	# Carry a random seed from start-up to start-up
 *	# Load and then save 512 bytes, which is the size of the entropy pool
 *	if [ -f /etc/random-seed ]; then
 *		cat /etc/random-seed >/dev/urandom
 *	fi
 *	dd if=/dev/urandom of=/etc/random-seed count=1
 *
 * and the following lines in appropriate script which is run when
 * the system is shutting down:
 *
 *	# Carry a random seed from shut-down to start-up
 *	# Save 512 bytes, which is the size of the entropy pool
 *	echo "Saving random seed..."
 *	dd if=/dev/urandom of=/etc/random-seed count=1
 *
 * On a MirBSD system, /etc/rc does this in a slightly more
 * sophisticated way. The kernel also contains a seed.
 *
 * Effectively, these commands cause the contents of the entropy pool
 * to be saved at shutdown time and reloaded into the entropy pool at
 * start-up.  (The 'dd' in the addition to the bootup script is to
 * make sure that /etc/random-seed is different for every start-up,
 * even if the system crashes without executing rc.shutdown) Even with
 * complete knowledge of the start-up activities, predicting the state
 * of the entropy pool requires knowledge of the previous history of
 * the system.
 *
 * Configuring the random(4) driver under MirBSD
 * =============================================
 *
 * The special files for the random(4) driver should have been created
 * during the installation process.  However, if your system does not have
 * /dev/random and /dev/[s|u|p|a|w]random created already, they can be
 * created by using the MAKEDEV(8) script in /dev:
 *
 *	/dev/MAKEDEV random
 *
 * Check MAKEDEV for information about major and minor numbers.
 *
 * Acknowledgements:
 * =================
 *
 * Ideas for constructing this random number generator were derived
 * from Pretty Good Privacy's random number generator, and from private
 * discussions with Phil Karn.  Colin Plumb provided a faster random
 * number generator, which speeds up the mixing function of the entropy
 * pool, taken from PGPfone.  Dale Worley has also contributed many
 * useful ideas and suggestions to improve this driver.
 *
 * Any flaws in the design are solely my responsibility, and should
 * not be attributed to the Phil, Colin, or any of the authors of PGP.
 *
 * Further background information on this topic may be obtained from
 * RFC 1750, "Randomness Recommendations for Security", by Donald
 * Eastlake, Steve Crocker, and Jeff Schiller.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/disk.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/mount.h>
#include <sys/fcntl.h>
#include <sys/vnode.h>
#include <sys/syscallargs.h>
#include <sys/sysctl.h>
#include <sys/timeout.h>
#include <sys/poll.h>

#include <syskern/md5.h>
#include <crypto/randimpl.h>

#include <dev/rndioctl.h>

/*
 * The pool is stirred with a primitive polynomial of degree 128
 * over GF(2), namely x^128 + x^99 + x^59 + x^31 + x^9 + x^7 + 1.
 * For a pool of size 64, try x^64+x^62+x^38+x^10+x^6+x+1.
 */
#define POOLBITS (POOLWORDS*32)
#define POOLBYTES (POOLWORDS*4)
#if POOLWORDS == 2048
#define	TAP1	1638
#define	TAP2	1231
#define	TAP3	819
#define	TAP4	411
#define	TAP5	1
#elif POOLWORDS == 1024	/* also (819, 616, 410, 207, 2) */
#define	TAP1	817
#define	TAP2	615
#define	TAP3	412
#define	TAP4	204
#define	TAP5	1
#elif POOLWORDS == 512	/* also (409,307,206,102,2), (409,309,205,103,2) */
#define	TAP1	411
#define	TAP2	308
#define	TAP3	208
#define	TAP4	104
#define	TAP5	1
#elif POOLWORDS == 256
#define	TAP1	205
#define	TAP2	155
#define	TAP3	101
#define	TAP4	52
#define	TAP5	1
#elif POOLWORDS == 128	/* also (103, 78, 51, 27, 2) */
#define	TAP1	103
#define	TAP2	76
#define	TAP3	51
#define	TAP4	25
#define	TAP5	1
#elif POOLWORDS == 64
#define	TAP1	52
#define	TAP2	39
#define	TAP3	26
#define	TAP4	14
#define	TAP5	1
#elif POOLWORDS == 32
#define	TAP1	26
#define	TAP2	20
#define	TAP3	14
#define	TAP4	7
#define	TAP5	1
#else
#error No primitive polynomial available for chosen POOLWORDS
#endif

/*-
 * For the purposes of better mixing, we use the CRC-32 polynomial as
 * well to make a twisted Generalized Feedback Shift Register
 *
 * (See M. Matsumoto & Y. Kurita, 1992.  Twisted GFSR generators.  ACM
 * Transactions on Modeling and Computer Simulation 2(3):179-194.
 * Also see M. Matsumoto & Y. Kurita, 1994.  Twisted GFSR generators
 * II.  ACM Transactions on Mdeling and Computer Simulation 4:254-266)
 *
 * Thanks to Colin Plumb for suggesting this.
 *
 * We have not analyzed the resultant polynomial to prove it primitive;
 * in fact it almost certainly isn't.  Nonetheless, the irreducible factors
 * of a random large-degree polynomial over GF(2) are more than large enough
 * that periodicity is not a concern.
 *
 * The input hash is much less sensitive than the output hash.  All
 * we want from it is to be a good non-cryptographic hash -
 * i.e. to not produce collisions when fed "random" data of the sort
 * we expect to see.  As long as the pool state differs for different
 * inputs, we have preserved the input entropy and done a good job.
 * The fact that an intelligent attacker can construct inputs that
 * will produce controlled alterations to the pool's state is not
 * important because we don't consider such inputs to contribute any
 * randomness.  The only property we need with respect to them is that
 * the attacker can't increase his/her knowledge of the pool's state.
 * Since all additions are reversible (knowing the final state and the
 * input, you can reconstruct the initial state), if an attacker has
 * any uncertainty about the initial state, he/she can only shuffle
 * that uncertainty about, but never cause any collisions (which would
 * decrease the uncertainty).
 *
 * The chosen system lets the state of the pool be (essentially) the input
 * modulo the generator polynomial.  Now, for random primitive polynomials,
 * this is a universal class of hash functions, meaning that the chance
 * of a collision is limited by the attacker's knowledge of the generator
 * polynomial, so if it is chosen at random, an attacker can never force
 * a collision.  Here, we use a fixed polynomial, but we *can* assume that
 * ###--> it is unknown to the processes generating the input entropy. <-###
 * Because of this important property, this is a good, collision-resistant
 * hash; hash collisions will occur no more often than chance.
 */

/* pIII/333 reported to have some drops w/ these numbers */
#define QEVLEN (1024 / sizeof(struct rand_event))
#define QEVSLOW (QEVLEN * 3 / 4) /* yet another 0.75 for 60-minutes hour /-; */
#define QEVSBITS 10

/* There is one of these per entropy source */
struct timer_rand_state {
	u_int	last_time;
	u_int	last_delta;
	u_int	last_delta2;
	u_int	dont_count_entropy : 1;
	u_int	max_entropy : 1;
};

struct rand_event {
	struct timer_rand_state *re_state;
	u_int re_nbits;
	u_int re_time;
	u_int re_val;
};

struct timeout rnd_timeout;
struct timer_rand_state rnd_states[RND_SRC_NUM];
struct rand_event rnd_event_space[QEVLEN];
struct rand_event *rnd_event_head = rnd_event_space;
struct rand_event *rnd_event_tail = rnd_event_space;
struct selinfo rnd_rsel, rnd_wsel;

void filt_rndrdetach(struct knote *kn);
int filt_rndread(struct knote *kn, long hint);

struct filterops rndread_filtops =
	{ 1, NULL, filt_rndrdetach, filt_rndread};

void filt_rndwdetach(struct knote *kn);
int filt_rndwrite(struct knote *kn, long hint);

struct filterops rndwrite_filtops =
	{ 1, NULL, filt_rndwdetach, filt_rndwrite};

struct rndstats rndstats;

static __inline u_int32_t
roll(u_int32_t w, int i)
{
#ifdef i386
	__asm ("roll %%cl, %0" : "+r" (w) : "c" (i));
#else
	w = (w << i) | (w >> (32 - i));
#endif
	return w;
}

/* must be called at a proper spl, returns ptr to the next event */
static __inline struct rand_event *
rnd_get(void)
{
	struct rand_event *p = rnd_event_tail;

	if (p == rnd_event_head)
		return NULL;

	if (p + 1 >= &rnd_event_space[QEVLEN])
		rnd_event_tail = rnd_event_space;
	else
		rnd_event_tail++;

	return p;
}

/* must be called at a proper spl, returns next available item */
static __inline struct rand_event *
rnd_put(void)
{
	struct rand_event *p = rnd_event_head + 1;

	if (p >= &rnd_event_space[QEVLEN])
		p = rnd_event_space;

	if (p == rnd_event_tail)
		return NULL;

	return rnd_event_head = p;
}

/* must be called at a proper spl, returns number of items in the queue */
static __inline int
rnd_qlen(void)
{
	int len = rnd_event_head - rnd_event_tail;
	return (len < 0)? -len : len;
}

void dequeue_randomness(void *);

static void add_entropy_words(const u_int32_t *, u_int n);
void extract_entropy(register u_int8_t *, int);

void
rndpool_init(void)
{
	timeout_set(&rnd_timeout, dequeue_randomness, NULL);

	random_state.add_ptr = 0;
	random_state.entropy_count = 0;
	rnd_states[RND_SRC_TIMER].dont_count_entropy = 1;
	rnd_states[RND_SRC_TRUE].dont_count_entropy = 1;
	rnd_states[RND_SRC_TRUE].max_entropy = 1;

	bzero(&rndstats, sizeof(rndstats));
	bzero(&rnd_event_space, sizeof(rnd_event_space));
}

int
randomopen(dev_t dev, int flag, int mode, struct proc *p)
{
	return (minor(dev) < RND_NODEV ? 0 : ENXIO);
}

int
randomclose(dev, flag, mode, p)
	dev_t	dev;
	int	flag;
	int	mode;
	struct proc *p;
{
	return 0;
}

/*
 * This function adds a byte into the entropy pool.  It does not
 * update the entropy estimate.  The caller must do this if appropriate.
 *
 * The pool is stirred with a primitive polynomial of degree 128
 * over GF(2), namely x^128 + x^99 + x^59 + x^31 + x^9 + x^7 + 1.
 * For a pool of size 64, try x^64+x^62+x^38+x^10+x^6+x+1.
 *
 * We rotate the input word by a changing number of bits, to help
 * assure that all bits in the entropy get toggled.  Otherwise, if we
 * consistently feed the entropy pool small numbers (like jiffies and
 * scancodes, for example), the upper bits of the entropy pool don't
 * get affected. --- TYT, 10/11/95
 */
static void
add_entropy_words(buf, n)
	const u_int32_t *buf;
	u_int n;
{
	static const u_int32_t twist_table[8] = {
		0x00000000, 0x3b6e20c8, 0x76dc4190, 0x4db26158,
		0xedb88320, 0xd6d6a3e8, 0x9b64c2b0, 0xa00ae278
	};

	for (; n--; buf++) {
		register u_int32_t w = roll(*buf, random_state.input_rotate);
		register u_int i = random_state.add_ptr =
		    (random_state.add_ptr - 1) & (POOLWORDS - 1);
		/*
		 * Normally, we add 7 bits of rotation to the pool.
		 * At the beginning of the pool, add an extra 7 bits
		 * rotation, so that successive passes spread the
		 * input bits across the pool evenly.
		 */
		random_state.input_rotate =
		    (random_state.input_rotate + (i? 7 : 14)) & 31;

		/* XOR in the various taps */
		w ^= random_state.pool[(i+TAP1) & (POOLWORDS-1)] ^
		     random_state.pool[(i+TAP2) & (POOLWORDS-1)] ^
		     random_state.pool[(i+TAP3) & (POOLWORDS-1)] ^
		     random_state.pool[(i+TAP4) & (POOLWORDS-1)] ^
		     random_state.pool[(i+TAP5) & (POOLWORDS-1)] ^
		     random_state.pool[i];
		random_state.pool[i] = (w >> 3) ^ twist_table[w & 7];
	}
}

/*
 * This function adds entropy to the entropy pool by using timing
 * delays.  It uses the timer_rand_state structure to make an estimate
 * of how many bits of entropy this call has added to the pool.
 *
 * The number "val" is also added to the pool - it should somehow describe
 * the type of event which just happened.  Currently the values of 0-255
 * are for keyboard scan codes, 256 and upwards - for interrupts.
 * On the i386, this is assumed to be at most 16 bits, and the high bits
 * are used for a high-resolution timer.
 *
 */
void
enqueue_randomness(int state, int val)
{
	register struct timer_rand_state *p;
	register struct rand_event *rep;
	int s;
	struct {
		struct timeval tv;
		int val, state, delta2, delta3;
		u_int d_time_, d_nbits;
#define time_ drop.d_time_
#define nbits drop.d_nbits
		struct timer_rand_state p;
		char why[sizeof(val) == 4 ? 1 : -1];
	} drop;

	drop.val = val;
	if ((drop.state = state) == RND_SRC_LPC)
		state = RND_SRC_TRUE;

	/* we sometimes get here before randomattach() */
	if (!rnd_attached) {
		/* cache, since we get a *lot* of information here, early */
		drop.why[0] = 1;
		rnd_lopool_addh(&drop, sizeof(drop));
		return;
	}
#define rndebugtmp(x) drop.state == RND_SRC_ ## x ? #x :
	RNDEBUG(RD_ENQUEUE, "rnd: enqueue(%s, %u)\n",
	    rndebugtmp(TRUE)
	    rndebugtmp(TIMER)
	    rndebugtmp(MOUSE)
	    rndebugtmp(TTY)
	    rndebugtmp(DISK)
	    rndebugtmp(NET)
	    rndebugtmp(AUVIS)
	    rndebugtmp(IMACS)
	    rndebugtmp(LPC)
	    "unknown", val);
#undef rndebugtmp

#ifdef DIAGNOSTIC
	if (state < 0 || state >= RND_SRC_NUM)
		return;
#endif

	p = &rnd_states[state];
	val += state << 13;

	microtime(&drop.tv);
	time_ = drop.tv.tv_usec + (drop.tv.tv_sec << 20);
	nbits = 0;

	/*
	 * Calculate the number of bits of randomness that we probably
	 * added.  We take into account the first and second order
	 * deltas in order to make our estimate.
	 */
	if (!p->dont_count_entropy) {
		register int	delta, delta2, delta3;
		delta  = time_  - p->last_time;
		delta2 = delta  - p->last_delta;
		delta3 = delta2 - p->last_delta2;

		if (delta < 0) delta = -delta;
		if (delta2 < 0) delta2 = -delta2;
		if (delta3 < 0) delta3 = -delta3;
		if (delta > delta2) delta = delta2;
		if (delta > delta3) delta = delta3;
		delta3 = delta >>= 1;
		/*
		 * delta &= 0xfff;
		 * we don't do it since our time sheet is different from linux
		 */

		if (delta & 0xffff0000) {
			nbits = 16;
			delta >>= 16;
		}
		if (delta & 0xff00) {
			nbits += 8;
			delta >>= 8;
		}
		if (delta & 0xf0) {
			nbits += 4;
			delta >>= 4;
		}
		if (delta & 0xc) {
			nbits += 2;
			delta >>= 2;
		}
		if (delta & 2) {
			nbits += 1;
			delta >>= 1;
		}
		if (delta & 1)
			nbits++;

#ifdef DIAGNOSTIC
		if (nbits >= 32) {
			/* sanity check, shouldn’t happen */
			RNDEBUG(RD_ALWAYS, "rnd: nbits (%u) >= 32", nbits);
			drop.why[0] = 4;
			goto do_a_drop_with_delta;
		}
#endif

		/*
		 * the logic is to drop low-entropy entries,
		 * in hope for dequeuing to be more randomfull
		 */
		if (rnd_qlen() > QEVSLOW && nbits < QEVSBITS) {
			rndstats.rnd_drople++;
			drop.why[0] = 2;
#ifdef DIAGNOSTIC
 do_a_drop_with_delta:
#endif
			drop.delta2 = delta2;
			drop.delta3 = delta3;
			goto do_a_drop;
		}
		p->last_time = time_;
		p->last_delta  = delta3;
		p->last_delta2 = delta2;
	} else if (p->max_entropy)
		/* 31 = (8 * sizeof(val) - 1) see assertion in struct{}drop */
		nbits = drop.state == RND_SRC_LPC ? 24 : 31;

	s = splhigh();
	if ((rep = rnd_put()) == NULL) {
		rndstats.rnd_drops++;
		splx(s);
		drop.why[0] = 3;
 do_a_drop:
		/* if we have a drop, put the randomfull[sic!]ness to use */
		drop.p = *p;
		rnd_lopool_add(&drop, sizeof(drop));
		return;
	}

	rep->re_state = p;
	rep->re_nbits = nbits;
	rep->re_time = time_;
	rep->re_val = val;

	rndstats.rnd_enqs++;
	rndstats.rnd_ed[nbits]++;
	rndstats.rnd_sc[state]++;
	rndstats.rnd_sb[state] += nbits;

	if (rnd_qlen() > QEVSLOW/2 && !random_state.tmo) {
		random_state.tmo++;
		timeout_add(&rnd_timeout, 1);
	}
	splx(s);
#undef time_
#undef nbits
}

void
dequeue_randomness(void *v __unused)
{
	register struct rand_event *rep;
	u_int32_t buf[2];
	u_int nbits;
	int s;

	timeout_del(&rnd_timeout);
	rndstats.rnd_deqs++;

	s = splhigh();
	while ((rep = rnd_get())) {

		buf[0] = rep->re_time;
		buf[1] = rep->re_val;
		nbits = rep->re_nbits;
		splx(s);

		add_entropy_words(buf, 2);

		rndstats.rnd_total += nbits;
		random_state.entropy_count += nbits;
		if (random_state.entropy_count > POOLBITS)
			random_state.entropy_count = POOLBITS;

		if (random_state.asleep && random_state.entropy_count > 8) {
			RNDEBUG(RD_WAIT, "rnd: wakeup[%u]{%u}\n",
			    random_state.asleep, random_state.entropy_count);
			random_state.asleep--;
			wakeup((void *)&random_state.asleep);
			selwakeup(&rnd_rsel);
			KNOTE(&rnd_rsel.si_note, 0);
		}

		s = splhigh();
	}

	random_state.tmo = 0;
	splx(s);
}

#if POOLWORDS % 16
#error extract_entropy() assumes that POOLWORDS is a multiple of 16 words.
#endif

/*
 * This function extracts randomness from the entropy pool, and
 * returns it in a buffer.  This function computes how many remaining
 * bits of entropy are left in the pool, but it does not restrict the
 * number of bytes that are actually obtained.
 */
void
extract_entropy(buf, nbytes)
	register u_int8_t *buf;
	int	nbytes;
{
	u_char buffer[16];
	MD5_CTX tmp;
	u_int i;
	int s;

	add_timer_randomness(nbytes);

	while (nbytes) {
		if (nbytes < sizeof(buffer) / 2)
			i = nbytes;
		else
			i = sizeof(buffer) / 2;

		/* Hash the pool to get the output */
		MD5Init(&tmp);
		s = splhigh();
		MD5Update(&tmp, (void *)random_state.pool,
		    sizeof(random_state.pool));
		if (random_state.entropy_count / 8 > i)
			random_state.entropy_count -= i * 8;
		else
			random_state.entropy_count = 0;
		splx(s);
		MD5Final(buffer, &tmp);

		/*
		 * In case the hash function has some recognizable
		 * output pattern, we fold it in half.
		 */
		buffer[0] ^= buffer[15];
		buffer[1] ^= buffer[14];
		buffer[2] ^= buffer[13];
		buffer[3] ^= buffer[12];
		buffer[4] ^= buffer[11];
		buffer[5] ^= buffer[10];
		buffer[6] ^= buffer[ 9];
		buffer[7] ^= buffer[ 8];

		/* Copy data to destination buffer */
		bcopy(buffer, buf, i);
		nbytes -= i;
		buf += i;

		/* Modify pool so next hash will produce different results */
		add_timer_randomness(nbytes);
		dequeue_randomness(&random_state);
	}

	/* Wipe data from memory */
	explicit_bzero(&tmp, sizeof(tmp));
	explicit_bzero(buffer, sizeof(buffer));
}

/*
 * This function is the exported kernel interface.  It returns some
 * number of good random numbers, suitable for seeding TCP sequence
 * numbers, etc.
 */
void
get_random_bytes(buf, nbytes)
	void	*buf;
	size_t	nbytes;
{
	extract_entropy((u_int8_t *) buf, nbytes);
	rndstats.rnd_used += nbytes * 8;
}

int
randomread(dev_t dev, struct uio *uio, int ioflag)
{
	size_t n;
	int rv = 0;
	uint16_t *buf;

	if (uio->uio_resid == 0)
		return (0);

	MALLOC(buf, uint16_t *, POOLBYTES, M_TEMP, M_WAITOK);
	add_timer_randomness((u_long)dev ^ (u_long)uio ^ (u_long)buf);

	while (rv == 0 && uio->uio_resid > 0) {
		n = min(uio->uio_resid, POOLBYTES);

		switch (minor(dev)) {
		case RND_SRND:
			/*
			 * check if we have enough entropy left in the
			 * rndpool to answer a request (partially)
			 */
			if (random_state.entropy_count < 16 * 8) {
				if (ioflag & IO_NDELAY) {
					rv = EWOULDBLOCK;
					break;
				}
				RNDEBUG(RD_WAIT, "rnd: sleep[%u]\n",
				    random_state.asleep);
				++random_state.asleep;
				++rndstats.rnd_waits;
				rv = tsleep(&random_state.asleep,
				    PWAIT | PCATCH, "rndrd", 0);
				RNDEBUG(RD_WAIT, "rnd: awakened(%d)\n", rv);
				if (rv)
					break;
			}
			/* check how much entropy we have left */
			if (n > random_state.entropy_count / 8)
				n = random_state.entropy_count / 8;
			++rndstats.rnd_reads;
			/* FALLTHROUGH */

		case RND_URND:
			/* deplete the rndpool, no matter what */
			RNDEBUG(RD_OUTPUT, "rnd: %lu bytes output\n",
			    (u_long)n);
			get_random_bytes(buf, n);
			break;

		case RND_RND:
			/*
			 * Originally intended as direct interface to
			 * a HW RNG, which we will never do; map this
			 * to read from arc4random and write to lopool
			 * for compat with other OSes.
			 */
		case RND_PRND:
			/*
			 * This is /dev/prandom on read (old, but now
			 * mapped to arc4random) and /dev/wrandom on
			 * write (mapped to the lopool), and always
			 * writable, even for regulat users.
			 */
		case RND_ARND:
			arc4random_buf(buf, n);
			break;

		default:
			rv = ENXIO;
		}

		if (rv == 0 && n > 0)
			rv = uiomove((caddr_t)buf, n, uio);
		/* yield here on SMP */
	}

	add_timer_randomness((u_long)dev ^ (u_long)uio ^ (u_long)buf);
	FREE(buf, M_TEMP);
	return (rv);
}

int
randompoll(dev, events, p)
	dev_t	dev;
	int	events;
	struct proc *p;
{
	int revents;

	revents = events & (POLLOUT | POLLWRNORM);	/* always writable */
	if (events & (POLLIN | POLLRDNORM)) {
		if (minor(dev) == RND_SRND && random_state.entropy_count <= 0)
			selrecord(p, &rnd_rsel);
		else
			revents |= events & (POLLIN | POLLRDNORM);
	}

	return (revents);
}

int
randomkqfilter(dev_t dev, struct knote *kn)
{
	struct klist *klist;
	int s;

	switch (kn->kn_filter) {
	case EVFILT_READ:
		klist = &rnd_rsel.si_note;
		kn->kn_fop = &rndread_filtops;
		break;
	case EVFILT_WRITE:
		klist = &rnd_wsel.si_note;
		kn->kn_fop = &rndwrite_filtops;
		break;
	default:
		return (1);
	}
	kn->kn_hook = (void *)&random_state;

	s = splhigh();
	SLIST_INSERT_HEAD(klist, kn, kn_selnext);
	splx(s);

	return (0);
}

void
filt_rndrdetach(struct knote *kn)
{
	int s = splhigh();

	SLIST_REMOVE(&rnd_rsel.si_note, kn, knote, kn_selnext);
	splx(s);
}

int
filt_rndread(struct knote *kn, long hint)
{
	/* this is a singleton, thus we don't use kn->kn_hook */
	kn->kn_data = random_state.entropy_count;
	return (random_state.entropy_count > 0);
}

void
filt_rndwdetach(struct knote *kn)
{
	int s = splhigh();

	SLIST_REMOVE(&rnd_wsel.si_note, kn, knote, kn_selnext);
	splx(s);
}

int
filt_rndwrite(kn, hint)
	struct knote *kn;
	long hint;
{
	return (1);
}

int
randomwrite(dev_t dev, struct uio *uio, int flags)
{
	size_t n;
	int rv = 0;
	uint8_t *buf;
	int newdata = 0;

	/* see randomread() for some explanations */

	if (securelevel > 1)
		switch (minor(dev)) {
		case RND_RND:
		case RND_PRND:
			break;
		case RND_ARND:
			if (suser(curproc, 0) == 0 && curproc->p_pid == 1 &&
			    random_state.entropy_count >= 80) {
				/* allow init(8) nice_death to work */
				break;
			}
			/* FALLTHROUGH */
		default:
			return (EPERM);
		}

	if (uio->uio_resid == 0)
		return (0);

	MALLOC(buf, uint8_t *, POOLBYTES, M_TEMP, M_WAITOK);
	add_timer_randomness((u_long)dev ^ (u_long)uio ^ (u_long)buf);

	while (rv == 0 && uio->uio_resid > 0) {
		n = min(uio->uio_resid, POOLBYTES);

		if ((rv = uiomove((caddr_t)buf, n, uio)))
			break;

		switch (minor(dev)) {
		case RND_RND:
		case RND_PRND:
			rnd_lopool_add(buf, n);
			break;
		default:
			if (n % sizeof(uint32_t)) {
				uint32_t v = arc4random();
				while (n % sizeof(uint32_t)) {
					buf[n++] = v & 0xFF;
					v >>= 8;
				}
			}
			add_entropy_words((void *)buf, n / sizeof(uint32_t));
			newdata = 1;
			break;
		}
	}

	if (newdata && minor(dev) == RND_ARND)
		arc4random_reinit(NULL);

	add_timer_randomness((u_long)dev ^ (u_long)uio ^ (u_long)buf);
	FREE(buf, M_TEMP);
	return (rv);
}

int
randomioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	int rv = 0, s;
	u_int cnt;

	switch (cmd) {
	case RNDSTIRARC4:
		if (securelevel > 1 && suser(p, 0) == 0 &&
		    p->p_pid == 1 && random_state.entropy_count >= 80) {
			/* allow init(8) nice_death to work */
			break;
		}
		/* FALLTHROUGH */
	case RNDADDRNDNESS:
	case RNDADDTOENTCNT:
	case RNDZAPENTCNT:
		if (securelevel > 1)
			rv = EPERM;
		else
		    /* FALLTHROUGH */
	case RNDCLRSTATS:
		    if (suser(p, 0) != 0)
			rv = EPERM;
		break;
	}

	if (!rv) switch (cmd) {
	case FIOASYNC:
		/* rnd has no async flag in softc so this is really a no-op */
	case FIONBIO:
		/* handled in the upper FS layer */
		break;

	case RNDGETENTCNT:
		s = splhigh();
		cnt = random_state.entropy_count;
		splx(s);
		memcpy(data, &cnt, sizeof(u_int));
		break;

	case RNDADDTOENTCNT:
		memcpy(&cnt, data, sizeof(u_int));
		s = splhigh();
		if ((random_state.entropy_count += cnt) > POOLBITS)
			random_state.entropy_count = POOLBITS;
		splx(s);
		break;

	case RNDZAPENTCNT:
		s = splhigh();
		random_state.entropy_count = 0;
		splx(s);
		break;

	case RNDSTIRARC4:
		if (p->p_pid == 1) {
			RNDEBUG(RD_ALWAYS, "rnd: init called, ");
			rnd_flush();
		} else if (random_state.entropy_count < 80)
			rv = EAGAIN;
		else
			arc4random_reinit(NULL);
		break;

	case RNDCLRSTATS:
		s = splhigh();
		bzero(&rndstats, sizeof(rndstats));
		splx(s);
		break;

	case RNDADDRNDNESS: {
		const struct rnd_add_randomness *sar = (const void *)data;
		size_t i = sar->count;

		if (i > sizeof(sar->buf) / sizeof(sar->buf[0]))
			rv = EINVAL;
		else if (sar->source == 0)
			/* just add; i==0 will be caught */
			add_entropy_words(sar->buf, i);
		else if (i > 0)
			while (i--)
				enqueue_randomness(sar->source, sar->buf[i]);
		break;
	}

	default:
		rv = ENOTTY;
	}

	return (rv);
}

int
sys_getentropy(struct proc *p, void *v, register_t *retval)
{
	struct sys_getentropy_args /* {
		syscallarg(void *) buf;
		syscallarg(size_t) nbyte;
	} */ *uap = v;
	char buf[256];
	size_t nbyte;
	int error;

	if ((nbyte = SCARG(uap, nbyte)) > sizeof(buf))
		return (EIO);

	if (copyin(SCARG(uap, buf), buf, nbyte) == 0)
		rnd_lopool_add(buf, nbyte);

	arc4random_buf(buf, nbyte);
	if ((error = copyout(buf, SCARG(uap, buf), nbyte)) != 0)
		return (error);
	explicit_bzero(buf, sizeof(buf));
	retval[0] = 0;
	return (0);
}
@


1.78
log
@allow init(8) write+stir access to arandom(4) in high securelevels,
for system shutdown; correct and update related info in manpage
@
text
@d1 1
a1 1
/* $MirOS: src/sys/dev/rnd.c,v 1.75 2014/02/20 00:30:24 tg Exp $ */
d7 2
a8 2
 *		 2010, 2013, 2014
 *	Thorsten Glaser <tg@@mirbsd.org>
d827 2
a828 2
	bzero(&tmp, sizeof(tmp));
	bzero(buffer, sizeof(buffer));
@


1.77
log
@I just know I’ll hate myself later if I don’t make it bidi right from the beginning
@
text
@d1022 7
d1079 7
a1088 1
	case RNDSTIRARC4:
@


1.76
log
@flesh out the getentropy syscall, I have a feeling we’ll need it eventually
@
text
@d264 1
d267 1
d1160 1
d1163 1
a1163 1
	if (SCARG(uap, nbyte) > sizeof(buf))
d1165 6
a1170 2
	arc4random_buf(buf, SCARG(uap, nbyte));
	if ((error = copyout(buf, SCARG(uap, buf), SCARG(uap, nbyte))) != 0)
@


1.75
log
@permit /dev/random to be read from (arc4random) and written to (lopool)
@
text
@d1 1
a1 1
/* $MirOS: src/sys/dev/rnd.c,v 1.74 2013/10/24 08:32:37 tg Exp $ */
d1149 20
@


1.74
log
@do not give the users an insecure random device at hand, period.

now /dev/[pw]random still writes to the lopool but reads from arc4random(9)
(important: do not depend on this behaviour, they used to return insecure
data; use /dev/wrandom only for writing and always read /dev/arandom)
@
text
@d1 1
a1 1
/* $MirOS: src/sys/dev/rnd.c,v 1.73 2011/11/20 18:54:46 tg Exp $ */
d7 1
a7 1
 *		 2010, 2013
a852 9
	/*
	 * /dev/random was intended as a direct interface to a hardware
	 * RNG, which we will probably never do; HW RNGs are expected to
	 * contribute bits directly into a kernel pool, either rndpool
	 * or lopool (if it cannot be trusted). So, this will fail.
	 */
	if (minor(dev) == RND_RND)
		return (EIO);

d893 7
d901 6
d1013 10
a1022 3
	/* RND_PRND is /dev/wrandom and always writable */
	if (minor(dev) != RND_PRND && securelevel > 1)
		return (EPERM);
a1026 4
	/* see randomread() for explanation */
	if (minor(dev) == RND_RND)
		return (ENXIO);

d1035 4
a1038 1
		if (minor(dev) == RND_PRND)
d1040 2
a1041 1
		else {
d1050 2
a1052 1
		newdata = 1;
d1055 1
a1055 1
	if (minor(dev) == RND_ARND && newdata)
@


1.73
log
@• use common <syskern/md5.h> with /usr/include/md5.h@@ for userspace compat
• switch kernel <crypto/md5.h> users to <syskern/md5.h>
• fix underestimated __attribute__((__bounded__ …)) argument
• this is an interface definition and as such not copyrightable
@
text
@d1 1
a1 1
/* $MirOS: src/sys/dev/rnd.c,v 1.72 2011/02/19 14:41:36 tg Exp $ */
d7 1
a7 1
 *		 2010
d902 1
a902 8
		case RND_PRND: {
			size_t i = (n + 1) / 2;

			while (i--)
				buf[i] = random() & 0xFFFF;
			break;
		}

@


1.72
log
@• kernel: merge rnd_flush() declarations into <randimpl.h>
• randomioctl: let RNDSTIRARC4 invoke rnd_flush() if called from init(8)
• init, reboot/halt: use unified "pathnames.h"
• init: use RNDSTIRARC4 to reset all pools (lopool, arc4random) on halt
• init: write 2048 bytes to /var/db/host.random to make it an even 8 KiB
• init: redesign code for that, minimise sleep calls, tested with tempo-
  rary printf/warning/etc. calls in userspace and kernel
• init: upon SIGTSTP, invoke RNDSTIRARC4 to help halt/reboot
• halt/reboot: do similar things like init wrt. signals, output, seed file
@
text
@d1 1
a1 1
/* $MirOS: src/sys/dev/rnd.c,v 1.71 2010/12/24 00:11:00 tg Exp $ */
d270 1
a270 1
#include <crypto/md5.h>
@


1.71
log
@fix build; make omalloc default; sync lists (objc, lynx)
@
text
@d1 1
a1 1
/* $MirOS: src/sys/dev/rnd.c,v 1.70 2010/12/23 19:25:32 tg Exp $ */
d6 2
a7 1
 * Copyright (c) 2000, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d1108 4
a1111 1
		if (random_state.entropy_count < 80)
@


1.70
log
@fast-forward through OpenBSD-current RNG:
src/sys/dev/rnd.c,v 1.105
src/lib/libc/crypt/arc4random.c,v 1.22
this fixes some small issues. also, optimise a little and correct comments.
@
text
@d1 1
a1 1
/* $MirOS: src/sys/dev/rnd.c,v 1.69 2010/09/25 14:11:46 tg Exp $ */
d673 1
d675 1
@


1.69
log
@since 1004C9D50823DFFA28B this is no longer true, simplify / reduce diff against vendor
@
text
@d1 1
a1 2
/**	$MirOS: src/sys/dev/rnd.c,v 1.68 2010/09/25 01:29:34 tg Exp $ */
/*	$OpenBSD: rnd.c,v 1.78 2005/07/07 00:11:24 djm Exp $	*/
d3 1
a3 1
/*
a9 2
 * Version 1.89, last modified 19-Sep-99
 *
d44 1
a44 1
/*
d327 1
a327 1
/*
a391 1
struct random_bucket random_state;
d471 1
a471 1
	timeout_set(&rnd_timeout, dequeue_randomness, &random_state);
d484 1
a484 5
randomopen(dev, flag, mode, p)
	dev_t	dev;
	int	flag;
	int	mode;
	struct proc *p;
d486 1
a486 1
	return (minor (dev) < RND_NODEV) ? 0 : ENXIO;
d572 1
a572 1
		char why;
d579 1
a579 1
	/* XXX on i386 and maybe sparc we get here before randomattach() */
d581 2
a582 3
#if 1
		/* since we get a *lot* of information here, early */
		drop.why = 1;
a583 3
#else
		RNDEBUG(RD_ALWAYS, "rnd: premature enqueue_randomness\n");
#endif
d609 1
a609 1
	time_ = drop.tv.tv_usec ^ drop.tv.tv_sec;
d657 9
d672 2
a673 1
			drop.why = 2;
d682 2
a683 1
		nbits = drop.state == RND_SRC_LPC ? 24 : 8 * sizeof(val) - 1;
d689 1
a689 1
		drop.why = 3;
d717 1
a717 2
dequeue_randomness(v)
	void *v;
a718 1
	struct random_bucket *rs = v;
d738 3
a740 3
		rs->entropy_count += nbits;
		if (rs->entropy_count > POOLBITS)
			rs->entropy_count = POOLBITS;
d742 1
a742 1
		if (rs->asleep && rs->entropy_count > 8) {
d744 3
a746 3
			    rs->asleep, rs->entropy_count);
			rs->asleep--;
			wakeup((void *)&rs->asleep);
d754 1
a754 1
	rs->tmo = 0;
a772 1
	struct random_bucket *rs = &random_state;
d789 4
a792 3
		MD5Update(&tmp, (u_int8_t*)rs->pool, sizeof(rs->pool));
		if (rs->entropy_count / 8 > i)
			rs->entropy_count -= i * 8;
d794 1
a794 1
			rs->entropy_count = 0;
d823 1
a823 1
	bzero(&buffer, sizeof(buffer));
d917 1
d1011 1
d1044 1
d1047 1
a1047 1
	if (minor(dev) == RND_ARND && rv == 0)
a1060 2
	add_timer_randomness((u_long)p ^ (u_long)data ^ cmd);

a1135 1
	add_timer_randomness((u_long)p ^ (u_long)data ^ cmd);
@


1.68
log
@a shame to waste all the entropy in queue drops (high or low watermark)…
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.67 2010/09/24 21:37:34 tg Exp $ */
d592 1
a592 1
		rnd_lopool_add(&drop, sizeof(drop));
@


1.67
log
@if source==0 “just add”, without touching statistics
add_entropy_words(*, 0) is a nop, which is fine for us
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.66 2010/09/24 21:31:19 tg Exp $ */
d568 1
a568 1
enqueue_randomness(int ustate, int val)
d572 14
a585 5
	struct timeval	tv;
	u_int	time_, nbits;
	int s, state;

	state = ustate == RND_SRC_LPC ? RND_SRC_TRUE : ustate;
d591 2
a592 1
		rnd_lopool_addv(val + (state << 29));
d598 1
a598 1
#define rndebugtmp(x) state == RND_SRC_ ## x ? #x :
d608 1
d620 2
a621 2
	microtime(&tv);
	time_ = tv.tv_usec ^ tv.tv_sec;
d675 4
a678 1
			return;
d684 1
a684 1
		nbits = (ustate == RND_SRC_LPC) ? 24 : (8 * sizeof(val) - 1);
d690 5
d713 2
@


1.66
log
@new ioctl RNDADDRNDNESS which works kinda like Linux’ RNDADDENTROPY
in that it doesn’t separate the entropy-to-kernel transfer between
write and ioctl, but it has, like all ioctls, a fixed argument size
and can (new!) take a source, e.g. RND_SRC_MOUSE¹, argument inside
struct rnd_add_randomness.source (int). currently limited to 16 32-bit
words (64 bytes), but as ekeyd, for which this interface is intended,
writes only 32 bytes at a time it seems fine to me.

① tested with mircvs://contrib/hosted/tg/e2k.c modified slightly
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.65 2010/09/24 20:35:12 tg Exp $ */
d1104 3
@


1.65
log
@count feedback from the arc4random/lopool-collapse combined result
only as 24 bits, not 31, for the doubleword, to balance inputs better
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.64 2010/09/24 19:59:09 tg Exp $ */
d1043 1
d1098 12
@


1.64
log
@• move rstat from bits to bytes (except distribution, of course)
• re-use RND_SRC_AUDIO for video and rename it RND_SRC_AUVIS
• switch to using add_auvis_entropy() in MirBSD code
• let RND_SRC_IMACS take up former RND_SRC_VIDEO’s place in statistics
• keep statistics for lopool en- and dequeues as well
• let rstat look ok also on 80x24 terminal
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.63 2010/09/19 18:55:34 tg Exp $ */
d568 1
a568 2
enqueue_randomness(state, val)
	int	state, val;
d574 3
a576 1
	int s;
d670 1
a670 1
		nbits = 8 * sizeof(val) - 1;
@


1.63
log
@the promised new RNG (play with RNDEBUG in crypto/randimpl.h to make
it verbose; I did, for a while and a bit of fine-tuning)
@
text
@d1 1
a1 1
/**	$MirOS$ */
d154 1
a154 2
 *	void add_audio_randomness(int n);
 *	void add_video_randomness(int n);
d176 1
a176 1
 * add_audio_randomness() times the finishing of audio codec dma
a179 2
 * add_video_randomness() does the same for video cards, I suppose.
 *
d182 1
a182 1
 * such as meta/alt/ctrl/shift key events.
d568 2
a569 1
enqueue_randomness(int rstate, int val)
d575 1
a575 1
	int s, sstate;
d580 2
a581 2
		/* since we get a *lot* of information here */
		rnd_lopool_addv(val + (rstate << 28));
d587 1
a587 1
#define rndebugtmp(x) rstate == RND_SRC_ ## x ? #x :
d595 1
a595 2
	    rndebugtmp(AUDIO)
	    rndebugtmp(VIDEO)
a599 2
	sstate = rstate == RND_SRC_IMACS ? RND_SRC_TTY : rstate;

d601 1
a601 1
	if (sstate < 0 || sstate >= RND_SRC_NUM)
d605 2
a606 2
	p = &rnd_states[rstate];
	val += rstate << 13;
d685 2
a686 2
	rndstats.rnd_sc[sstate]++;
	rndstats.rnd_sb[sstate] += nbits;
@


1.62
log
@use monotonic time for the push pools; when todr is initialised, add that
so we get the date+time into it as well
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.61 2010/09/12 18:50:25 tg Exp $ */
d8 1
a8 1
 *	Thorsten “mirabilos” Glaser <tg@@mirbsd.org>
d10 3
d109 1
a109 1
 *	void get_random_bytes(void *buf, int nbytes);
d127 15
a150 1
 *	void add_net_randomness(int isr);
d153 1
d155 2
d181 6
d209 1
a209 1
 *		cat /etc/random-seed >/dev/arandom
d221 2
a222 2
 * For example, on MirBSD systems, the appropriate script
 * is called /etc/rc in both cases.
d233 2
a234 2
 * Configuring the random(4) driver under MirOS
 * ============================================
d238 2
a239 2
 * /dev/random and /dev/{s,u,a,p,w}random created already, they can be
 * created by using the MAKEDEV(8) script as follows:
d241 1
a241 1
 *	# cd /dev; ./MAKEDEV random
d255 3
a262 2
#undef RNDEBUG

a273 1
#include <sys/kernel.h>
d276 1
a277 1
#include <dev/rndvar.h>
a279 9
extern int hz;

#ifdef	RNDEBUG
int	rnd_debug = 0x0000;
#define	RD_INPUT	0x000f	/* input data */
#define	RD_OUTPUT	0x00f0	/* output data */
#define	RD_WAIT		0x0100	/* sleep/wakeup for good data */
#endif

d335 1
a335 1
 * well to make a twisted Generalised Feedback Shift Register
d377 1
a377 1
#define QEVLEN (1024 / sizeof (struct rand_event))
a380 10
/* There is actually only one of these, globally. */
struct random_bucket {
	u_int	add_ptr;
	u_int	entropy_count;
	u_char	input_rotate;
	u_int32_t pool[POOLWORDS];
	u_int	asleep;
	u_int	tmo;
};

a389 7
struct arc4_stream {
	u_int8_t s[256];
	u_int	 cnt;
	u_int8_t i;
	u_int8_t j;
};

a397 1
struct timeout arc4reinit_timeout, arc4add_timeout;
a398 1
struct arc4_stream arc4random_state;
a416 2
static int rnd_attached;
static int arc4random_initialised;
a417 5
int arc4random_seedfreq = 0;

/* from sys/conf/newvers.sh */
extern unsigned char initial_entropy[16];
static int initial_entropy_ptr = -1;
d427 1
a427 1
	return (w);
d437 1
a437 1
		return (NULL);
d444 1
a444 1
	return (p);
d457 1
a457 1
		return (NULL);
d459 1
a459 1
	return (rnd_event_head = p);
d467 1
a467 1
	return ((len < 0) ? -len : len);
d473 1
a473 39
    /* XXX no bounded attribute: size is in ints, not in chars */
void extract_entropy(register u_int8_t *, int)
    __attribute__((bounded (string, 1, 2)));

static u_int8_t arc4_getbyte(void);
static void arc4_addrandom(register const uint8_t *, size_t)
    __attribute__((bounded (string, 1, 2)));
void arc4_stir(void);
void arc4_reinit(void *v);
static void arc4maybeinit(void);
static void arc4_depool(void *);
void rnd_shutdown(void);

/* Arcfour random stream generator.  This code is derived from section
 * 17.1 of Applied Cryptography, second edition, which describes a
 * stream cipher allegedly compatible with RSA Labs "RC4" cipher (the
 * actual description of which is a trade secret).  The same algorithm
 * is used as a stream cipher called "arcfour" in Tatu Ylonen's ssh
 * package.
 *
 * The initialization function here has been modified to not discard
 * the old state, and it's input always includes the time of day in
 * microseconds.  Moreover, bytes from the stream may at any point be
 * diverted to multiple processes or even kernel functions desiring
 * random numbers.  This increases the strength of the random stream,
 * but makes it impossible to use this code for encryption, since there
 * is no way to ever reproduce the same stream of random bytes.
 *
 * RC4 is a registered trademark of RSA Laboratories.
 */

static u_int8_t
arc4_getbyte(void)
{
	register u_int8_t si, sj, ret;
	int s;

	if (!rnd_attached)
		return (random() & 0xFF);
a474 87
	s = splhigh();
	rndstats.arc4_reads++;
	if (arc4random_state.cnt++ > 2097152)
		/* reinit on next high-level function call */
		arc4random_initialised = 0;
	arc4random_state.i++;
	si = arc4random_state.s[arc4random_state.i];
	arc4random_state.j += si;
	sj = arc4random_state.s[arc4random_state.j];
	arc4random_state.s[arc4random_state.i] = sj;
	arc4random_state.s[arc4random_state.j] = si;
	ret = arc4random_state.s[(si + sj) & 0xff];
	splx(s);
	return (ret);
}

void
arc4_stir(void)
{
	u_int8_t buf[256];
	register u_int8_t cf;
	register int n, s;
	int len;

	cf = arc4_getbyte() & 0xFF;

	microtime((struct timeval *)buf);
	len = random_state.entropy_count / 8; /* XXX maybe a half? */
	if (len > sizeof (buf) - sizeof (struct timeval))
		len = sizeof (buf) - sizeof (struct timeval);
	get_random_bytes(buf + sizeof (struct timeval), len);
	len += sizeof (struct timeval);

	s = splhigh();
	if ((initial_entropy_ptr >= 0) /* initialised */ &&
	    (initial_entropy_ptr < sizeof (initial_entropy)) /* not full */ &&
	    (random_state.entropy_count > 8) /* some real entropy left */) {
		uint8_t tmpbuf; /* coz extract_entropy can fill the pool too */

		extract_entropy(&tmpbuf, 1);
		if (initial_entropy_ptr < sizeof (initial_entropy))
			initial_entropy[initial_entropy_ptr++] = tmpbuf;
		else /* don't waste it */
			buf[0] ^= tmpbuf;
	}
	if (initial_entropy_ptr != sizeof (initial_entropy))
		for (n = 255; n >= 0; n--)
			buf[n] = buf[n % len];
	else {
		/* the slow pool is full, use and empty it */
		for (n = 255; n >= 0; n--)
			buf[n] = buf[n % len] ^
			    initial_entropy[n % sizeof (initial_entropy)];
		bzero(initial_entropy, sizeof (initial_entropy));
		initial_entropy_ptr = 0;
	}
	arc4_addrandom(buf, sizeof (buf));
	arc4random_state.cnt = 0;
	rndstats.arc4_stirs += len;
	rndstats.arc4_nstirs++;
	splx(s);

	/*
	 * Throw away the first N words of output, as suggested in the
	 * paper "Weaknesses in the Key Scheduling Algorithm of RC4"
	 * by Fluher, Mantin, and Shamir.  (N = 256 in our case.)
	 */
	/* Additionally, throw away a pseudo-random number of bytes. */
	n = 256 * 4 + (random() & 7) + (arc4_getbyte() & 7) + cf;
	while (n--)
		arc4_getbyte();
}

static void
arc4maybeinit(void)
{
	if (!arc4random_initialised && rnd_attached) {
		timeout_add(&arc4reinit_timeout, arc4random_seedfreq);
		arc4random_initialised++;
		arc4_stir();
	}
}

/*
 * called by timeout to mark arc4 for stirring,
 * actual stirring happens on any access attempt.
 */
d476 1
a476 1
arc4_reinit(void *v)
a477 39
	arc4random_initialised = 0;
}

u_int32_t
arc4random(void)
{
	arc4maybeinit();
	if (arc4_getbyte() & 1)
		(void)arc4_getbyte();
	return ((arc4_getbyte() << 24) | (arc4_getbyte() << 16)
		| (arc4_getbyte() << 8) | arc4_getbyte());
}

void
arc4random_bytes(void *buf, size_t n)
{
	u_int8_t *cp = buf;
	u_int8_t *end = cp + n;

	arc4maybeinit();
	n = arc4_getbyte() % 3;
	while (n--)
		(void)arc4_getbyte();
	while (cp < end)
		*cp++ = arc4_getbyte();
}

void
randomattach(void)
{
	int i;

	if (rnd_attached) {
#ifdef RNDEBUG
		printf("random: second attach\n");
#endif
		return;
	}

a478 2
	timeout_set(&arc4reinit_timeout, arc4_reinit, NULL);
	timeout_set(&arc4add_timeout, arc4_depool, NULL);
d486 2
a487 31
	bzero(&rndstats, sizeof (rndstats));
	bzero(&rnd_event_space, sizeof (rnd_event_space));

	for (i = 0; i < 256; i++)
		arc4random_state.s[i] = i;
	arc4random_state.i = 0;
	arc4random_state.j = 0;
	arc4_reinit(NULL);
	if (!arc4random_seedfreq)
		arc4random_seedfreq = hz << 9;	/* approx. 8½ minutes */

	++rnd_attached;

	/* this one is generated from newvers.sh */
	add_true_randomness(initial_entropy[0] << 24 |
	    initial_entropy[1] << 16 |
	    initial_entropy[2] << 8 | initial_entropy[3]);
	add_true_randomness(initial_entropy[4] << 24 |
	    initial_entropy[5] << 16 |
	    initial_entropy[6] << 8 | initial_entropy[7]);
	add_true_randomness(initial_entropy[8] << 24 |
	    initial_entropy[9] << 16 |
	    initial_entropy[10] << 8 | initial_entropy[11]);
	add_true_randomness(initial_entropy[12] << 24 |
	    initial_entropy[13] << 16 |
	    initial_entropy[14] << 8 | initial_entropy[15]);
	/* prevent leaks through drivers, LKMs, etc. */
	bzero(initial_entropy, 16);
	initial_entropy_ptr = 0;

	timeout_add(&arc4add_timeout, hz << 6);
d491 5
a495 1
randomopen(dev_t dev, int flag, int mode, struct proc *p)
d497 1
a497 1
	return ((minor (dev) < RND_NODEV) ? 0 : ENXIO);
d501 5
a505 1
randomclose(dev_t dev, int flag, int mode, struct proc *p)
d507 1
a507 1
	return (0);
d525 3
a527 1
add_entropy_words(const u_int32_t *buf, u_int n)
d571 1
a571 1
enqueue_randomness(int xstate, int val)
d575 12
a586 6
	struct timeval tv;
	u_int xtime, nbits;
	int s;
	int state = xstate;

	if (!rnd_attached)
d588 14
d603 1
a603 7
	if ((xstate == RND_SRC_TRUST) || (xstate == RND_SRC_POOL))
		state = RND_SRC_TRUE;
	else if (xstate == RND_SRC_IMACS) {
		state = RND_SRC_TTY;
		val += xstate << 13;
	} else
		val += state << 13;
d606 1
a606 1
	if (state < 0 || state >= RND_SRC_NUM)
d610 2
a611 1
	p = &rnd_states[state];
d614 1
a614 1
	xtime = tv.tv_usec ^ tv.tv_sec;
d624 3
a626 3
		delta  = xtime	- p->last_time;
		delta2 = delta	- p->last_delta;
		delta3 = delta2	- p->last_delta2;
d670 1
a670 1
		p->last_time = xtime;
d673 2
a674 4
	} else if (xstate == RND_SRC_POOL)
		nbits = 1;
	else if (p->max_entropy)
		nbits = 8 * sizeof (val);
d685 1
a685 1
	rep->re_time = xtime;
d688 4
a691 6
	if ((xstate < RND_SRC_NUM) || (xstate == RND_SRC_IMACS)) {
		rndstats.rnd_enqs++;
		rndstats.rnd_ed[nbits]++;
		rndstats.rnd_sc[state]++;
		rndstats.rnd_sb[state] += nbits;
	}
d701 2
a702 1
dequeue_randomness(void *v)
d729 2
a730 6
#ifdef	RNDEBUG
			if (rnd_debug & RD_WAIT)
				printf("rnd: wakeup[%u]{%u}\n",
				    rs->asleep,
				    rs->entropy_count);
#endif
d745 1
a745 1
#error	extract_entropy() assumes that POOLWORDS is a multiple of 16 words.
d755 3
a757 1
extract_entropy(register u_int8_t *buf, int nbytes)
a763 4
	static int recursively_called = 0;

	if (!recursively_called)
		add_timer_randomness(nbytes);
d765 1
a765 14
	if (!recursively_called && (rs->entropy_count >= 8) &&
	    (initial_entropy_ptr >= 0) && (rs->entropy_count / 8 <= nbytes)) {
		/* this extraction would deplete the pool entirely */
		if (initial_entropy_ptr < sizeof (initial_entropy)) {
			/* so save one byte of real entropy to an extra pool */
			s = splhigh();
			add_timer_randomness(initial_entropy_ptr);
			recursively_called = 1;
			extract_entropy(&initial_entropy[initial_entropy_ptr++],
			    1);
			recursively_called = 0;
			splx(s);
		}
	}
d768 4
a771 1
		i = MIN(nbytes, sizeof (buffer) / 2);
d776 1
a776 1
		MD5Update(&tmp, (u_int8_t*)rs->pool, sizeof (rs->pool));
d808 2
a809 2
	bzero(&tmp, sizeof (tmp));
	bzero(&buffer, sizeof (buffer));
d818 3
a820 1
get_random_bytes(void *buf, size_t nbytes)
d822 1
a822 1
	extract_entropy((u_int8_t *)buf, nbytes);
d829 3
a831 3
	int		ret = 0;
	int		i;
	u_int32_t 	*buf;
d834 1
a834 1
		return 0;
d836 10
a845 1
	MALLOC(buf, u_int32_t *, POOLBYTES, M_TEMP, M_WAITOK);
d848 2
a849 2
	while (!ret && uio->uio_resid > 0) {
		int n = min(POOLBYTES, uio->uio_resid);
d851 1
a851 4
		switch(minor(dev)) {
		case RND_RND:
			ret = EIO;	/* no chip -- error */
			break;
d853 4
d859 1
a859 1
					ret = EWOULDBLOCK;
d862 5
a866 8
#ifdef	RNDEBUG
				if (rnd_debug & RD_WAIT)
					printf("rnd: sleep[%u]\n",
					    random_state.asleep);
#endif
				random_state.asleep++;
				rndstats.rnd_waits++;
				ret = tsleep(&random_state.asleep,
d868 2
a869 5
#ifdef	RNDEBUG
				if (rnd_debug & RD_WAIT)
					printf("rnd: awakened(%d)\n", ret);
#endif
				if (ret)
d872 1
d875 3
a877 5
			rndstats.rnd_reads++;
#ifdef	RNDEBUG
			if (rnd_debug & RD_OUTPUT)
				printf("rnd: %u possible output\n", n);
#endif
d879 4
a882 5
			get_random_bytes((char *)buf, n);
#ifdef	RNDEBUG
			if (rnd_debug & RD_OUTPUT)
				printf("rnd: %u bytes for output\n", n);
#endif
d884 4
a887 2
		case RND_PRND:
			i = (n + 3) / 4;
d889 1
a889 1
				buf[i] = random() << 16 | (random() & 0xFFFF);
d891 2
d894 1
a894 1
			arc4random_bytes(buf, n);
d896 1
d898 1
a898 1
			ret = ENXIO;
d900 3
a902 2
		if (n != 0 && ret == 0)
			ret = uiomove((caddr_t)buf, n, uio);
d907 1
a907 1
	return (ret);
d911 4
a914 1
randompoll(dev_t dev, int events, struct proc *p)
d968 3
a970 4
	struct random_bucket *rs = (struct random_bucket *)kn->kn_hook;

	kn->kn_data = (int)rs->entropy_count;
	return rs->entropy_count > 0;
d983 3
a985 1
filt_rndwrite(struct knote *kn, long hint)
d993 3
a995 2
	int		ret = 0;
	u_int32_t	*buf;
d997 2
a998 1
	if (securelevel > 1)
d1001 4
d1008 1
a1008 4
	if (uio->uio_resid == 0)
		return (0);

	MALLOC(buf, u_int32_t *, POOLBYTES, M_TEMP, M_WAITOK);
d1011 2
a1012 2
	while (!ret && uio->uio_resid > 0) {
		u_short	n = min(POOLBYTES, uio->uio_resid);
d1014 11
a1024 9
		ret = uiomove((caddr_t)buf, n, uio);
		if (!ret) {
			if (minor(dev) == RND_PRND)
				rnd_lopool_add(buf, n);
			else {
				while (n % sizeof (u_int32_t))
					((u_int8_t *)buf)[n++] = arc4_getbyte();
				n /= sizeof (uint32_t);
				add_entropy_words(buf, n);
d1026 1
d1030 2
a1031 2
	if (minor(dev) == RND_ARND && !ret)
		arc4random_initialised = 0;
d1035 1
a1035 1
	return (ret);
d1041 1
a1041 1
	int s, ret = 0;
d1047 10
a1056 2
	case FIOASYNC:
		/* rnd has no async flag in softc so this is really a no-op. */
d1058 1
d1060 3
d1064 1
a1064 1
		/* Handled in the upper FS layer. */
d1069 1
a1069 1
		*(u_int *)data = random_state.entropy_count;
d1071 1
d1073 1
d1075 5
a1079 10
		if ((suser(p, 0) != 0) || (securelevel > 1))
			ret = EPERM;
		else {
			cnt = *(u_int *)data;
			s = splhigh();
			random_state.entropy_count += cnt;
			if (random_state.entropy_count > POOLBITS)
				random_state.entropy_count = POOLBITS;
			splx(s);
		}
d1081 1
d1083 3
a1085 7
		if ((suser(p, 0) != 0) || (securelevel > 1))
			ret = EPERM;
		else {
			s = splhigh();
			random_state.entropy_count = 0;
			splx(s);
		}
d1087 1
d1089 4
a1092 9
		if ((suser(p, 0) != 0) || (securelevel > 1))
			ret = EPERM;
		else if (random_state.entropy_count < 64)
			ret = EAGAIN;
		else {
			s = splhigh();
			arc4random_initialised = 0;
			splx(s);
		}
d1094 1
d1096 3
a1098 7
		if (suser(p, 0) != 0)
			ret = EPERM;
		else {
			s = splhigh();
			bzero(&rndstats, sizeof (rndstats));
			splx(s);
		}
d1100 1
d1102 1
a1102 1
		ret = ENOTTY;
d1106 1
a1106 126
	return (ret);
}

static void
arc4_depool(void *v __attribute__((unused)))
{
	if (rnd_attached &&
	    arc4random_initialised /* otherwise we stir fully */ &&
	    random_state.entropy_count > 256 /* >32 bytes left */) {
		union {
			uint8_t arr[1];
			struct {
				struct timeval tv;
				uint8_t ent[8];
			} st;
		} buf;
		int s;

		microtime(&buf.st.tv);
		get_random_bytes(buf.st.ent, sizeof (buf.st.ent));
		s = splhigh();
		arc4_addrandom(buf.arr, sizeof (buf));
		splx(s);
	}

	/* 64 ±32 seconds */
	timeout_add(&arc4add_timeout, (hz << 5) + arc4random_uniform(hz << 6));
}

static void
arc4_addrandom(register const uint8_t *buf, size_t len)
{
	register uint8_t si;
	register int n;

	arc4random_state.i--;
	for (n = 0; n < 256; n++) {
		arc4random_state.i++;
		si = arc4random_state.s[arc4random_state.i];
		arc4random_state.j += si + buf[n % len];
		arc4random_state.s[arc4random_state.i] =
		    arc4random_state.s[arc4random_state.j];
		arc4random_state.s[arc4random_state.j] = si;
	}
	arc4random_state.i++;
	arc4random_state.j = arc4random_state.i;
}

void
rnd_shutdown(void)
{
	int s;

	s = splhigh();
//	arc4_addrandom((void *)rnd_addpool_buf,
//	    rnd_addpool_size * sizeof (uint32_t));
	arc4_reinit(NULL);
	splx(s);
}

struct rnd_pooladd {
	union {
		struct timeval tv;
#if defined(I586_CPU) || defined(I686_CPU)
		unsigned long long tsc;
#endif
	} u;
	const void *sp, *dp;
	size_t sz;
};

void rnd_pool_add(struct rnd_pooladd *, const void *, size_t);

void
rnd_pool_add(struct rnd_pooladd *sa, const void *d, size_t n)
{
#if defined(I586_CPU) || defined(I686_CPU)
	if (pentium_mhz) {
		__asm __volatile("rdtsc" : "=A" (sa->u.tsc));
	} else
#endif
	    {
		/* cannot use memcpy since mono_time is volatile */
		sa->u.tv.tv_sec = mono_time.tv_sec;
		sa->u.tv.tv_usec = mono_time.tv_usec;
	}
	sa->sp = sa;

	// addtopool: sa, sizeof(*sa)
	// addtopool: d, n
	// poolcontent += n
}

void
rnd_bootpool_add(const void *vp, size_t n)
{
	struct rnd_pooladd pa;
	uint32_t h;

	pa.dp = vp;
	pa.sz = n;

	do {
		h = arc4random() & 0xFFFFFF00;
	} while (!h);

	h = OAAT0Final(OAAT0Update(h, vp, n));
	rnd_pool_add(&pa, &h, sizeof(h));
}

void
rnd_lopool_add(const void *buf, size_t len)
{
	struct rnd_pooladd pa;

	pa.dp = buf;
	pa.sz = len;
	rnd_pool_add(&pa, buf, len);
}

void
rnd_lopool_addv(unsigned long v)
{
	struct rnd_pooladd pa;

	rnd_pool_add(&pa, &v, sizeof(v));
@


1.61
log
@a bit more like it's supposed to work
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.60 2010/09/12 18:20:00 tg Exp $ */
d1366 3
a1368 3
		/* cannot use memcpy since time is volatile */
		sa->u.tv.tv_sec = time.tv_sec;
		sa->u.tv.tv_usec = time.tv_usec;
@


1.60
log
@part 1: remove the addpool, replace with dummy lopool
do not install this, it reduces entropy
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.59 2010/09/12 12:24:30 tg Exp $ */
d1344 3
a1346 7
void
rnd_bootpool_add(const void *vp, size_t n)
{
	register uint32_t h;
	struct {
		union {
			struct timeval tv;
d1348 1
a1348 1
			unsigned long long tsc;
d1350 4
a1353 9
		} u;
		const void *sp, *dp;
		size_t sz;
		uint32_t h;
	} fs;

	do {
		h = arc4random() & 0xFFFFFF00;
	} while (!h);
d1355 1
a1355 3
	fs.sp = &fs;
	fs.dp = vp;
	fs.sz = n;
d1357 3
d1362 1
a1362 1
		__asm __volatile("rdtsc" : "=A" (fs.u.tsc));
d1367 2
a1368 2
		fs.u.tv.tv_sec = time.tv_sec;
		fs.u.tv.tv_usec = time.tv_usec;
d1370 19
d1391 1
a1391 2
	fs.h = h;
	rnd_lopool_add(&fs, sizeof(fs));
d1397 5
d1407 3
a1409 1
	rnd_lopool_add(&v, sizeof(v));
@


1.59
log
@• kern/c/arc4random_uniform.c, kern/include/libckern.h: move
  arc4random_uniform(3) implementation here
• kern/c/Makefile.inc: build arc4random_uniform.c kernel/user
• lib/libc/crypt/arc4random.c, sys/dev/rnd.c: remove implementation here
• sys/dev/rndvar.h: prototype is now in <libckern.h>
• contrib/code/Snippets/arc4random.c: sync with master implementation
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.58 2010/01/28 23:00:45 tg Exp $ */
a165 11
 *	rnd_addpool_add(uint32_t n)
 *
 * This macro xors its argument into a temporary pool, if that pool is
 * not already full. The pool itself is poured once about every minute
 * into the random pool using add_true_randomness() if it contains data.
 * The pool is sized at 32 (rnd_addpool_size) uint32_ts FOR A REASON!
 *
 * This function can be disabled using the "kern.pushrand" sysctl.
 * The buffer can be filled with writes to /dev/wrandom unless the
 * sysctl has the value 0 (zero).
 *
d397 1
a397 1
struct timeout rnd_timeout, rnd_addpool_timeout;
a418 3
uint32_t rnd_addpool_buf[rnd_addpool_size];
int rnd_addpool_num = 0, rnd_addpool_allow = 1;
static int rnd_addpool_ptr;
a491 1
static void rnd_addpool_reinit(void *);
a653 1
	timeout_set(&rnd_addpool_timeout, rnd_addpool_reinit, NULL);
a690 1
	timeout_add(&rnd_addpool_timeout, hz);
a1196 3
			while (n % sizeof (u_int32_t))
				((u_int8_t *) buf)[n++] = arc4_getbyte();
			n /= sizeof (uint32_t);
d1198 5
a1202 3
				while (n)
					rnd_addpool_add(buf[--n]);
			else
d1204 1
a1287 28
rnd_addpool_reinit(void *v)
{
	register uint32_t j;

#ifdef DIAGNOSTIC
	if (!rnd_attached) {
		printf("random: premature call of rnd_addpool_reinit\n");
		timeout_add(&rnd_addpool_timeout, hz << 6);
		return;
	}
#endif

	if (!rnd_addpool_allow) {
		/* reschedule to try again in ~four minutes if disabled */
		timeout_add(&rnd_addpool_timeout, hz << 8);
		return;
	}

	j = rnd_addpool_buf[rnd_addpool_ptr];
	rnd_addpool_buf[rnd_addpool_ptr] = 0;
	rnd_addpool_ptr = (rnd_addpool_ptr + 1) % rnd_addpool_size;
	if (j && ++j)	/* don't add all zeroes or all ones */
		enqueue_randomness(RND_SRC_POOL, j ^ arc4random());

	timeout_add(&rnd_addpool_timeout, (hz >> 1) + arc4random_uniform(hz));
}

static void
d1338 2
a1339 2
	arc4_addrandom((void *)rnd_addpool_buf,
	    rnd_addpool_size * sizeof (uint32_t));
a1348 1
		uint8_t theone, thenul, thernd, adelim;
d1357 1
a1363 5
	fs.theone = 0x80;
	fs.thenul = fs.adelim = 0;
	do {
		fs.thernd = arc4random() & 0xFF;
	} while (!fs.thernd);
d1379 14
a1392 3
	h = OAAT0Final(OAAT0Update(OAAT0Update(h, vp, n),
	    (void *)&fs, sizeof(fs)));
	rnd_addpool_add(h);
@


1.58
log
@assign 1 instead of 32 bits urandom-pool-count to doublewords
read from the wrandom pool to not skew the stats too bad

XXX this all needs a rewrite anyway
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.57 2010/01/06 19:11:53 tg Exp $ */
a653 45
/*
 * Calculate a uniformly distributed random number less than upper_bound
 * avoiding "modulo bias".
 *
 * Uniformity is achieved by generating new random numbers until the one
 * returned is outside the range [0, 2**32 % upper_bound).  This
 * guarantees the selected random number will be inside
 * [2**32 % upper_bound, 2**32) which maps back to [0, upper_bound)
 * after reduction modulo upper_bound.
 */
u_int32_t
arc4random_uniform(u_int32_t upper_bound)
{
	u_int32_t r, min;

	if (upper_bound < 2)
		return 0;

#if (ULONG_MAX > 0xFFFFFFFFUL)
	min = 0x100000000UL % upper_bound;
#else
	/* Calculate (2**32 % upper_bound) avoiding 64-bit math */
	if (upper_bound > 0x80000000U)
		/* 2**32 - upper_bound (only one "value area") */
		min = 1 + ~upper_bound;
	else
		/* (2**32 - x) % x == 2**32 % x when x <= 2**31 */
		min = (0xFFFFFFFFU - upper_bound + 1) % upper_bound;
#endif

	/*
	 * This could theoretically loop forever but each retry has
	 * p > 0.5 (worst case, usually far better) of selecting a
	 * number inside the range we need, so it should rarely need
	 * to re-roll.
	 */
	for (;;) {
		r = arc4random();
		if (r >= min)
			break;
	}

	return r % upper_bound;
}

@


1.57
log
@With the test programme below, I also have double-checked the
arc4random_uniform interna. Thus, sync it across all the dif-
ferent implemementations for better comprehension.

begin 644 test.c.gz
M'XL(```````"`UV036O#,`R&S_:O>-=1L)MN)$X(A7X<=^JUL,-@@C"6EAM0=
M:=(:UNRW3[83ME076=*C5[(>M?FLVJ+$ZMP4^O1\V'"N3<./']J(RTD7DG]S
MUE(JS]X;V#GJ/%N&3*I<)E642]6QK;Q?<LXLUH@@)NAYT54)$D<4*L4WBWG;;
MK03),M)RZ*B"*2SU,A*FFG_J/80+-X0N!C(HL#":R-KS"2+\6+<&8QW*ZES>
M84+$]J6W'9Z"\`Q04E)K(MWXT,Z"XC^><$>/L:Y?T/WE(:QQN^$OHK'2J7W5
M=+*]F-CU-%Z\(L^"3]5,#2_OW\QD[J_JFD`FAEM+$AW=6M)\&E^735L;6I3B
+CO\"?M$\_-(!````
`
end
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.56 2010/01/06 17:52:33 tg Exp $ */
d914 3
a916 1
	} else if (p->max_entropy)
@


1.56
log
@fix a coding error in the KSA found by myself reading several descriptions of aRC4
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.55 2009/11/09 21:36:40 tg Exp $ */
d7 1
a7 1
 * Copyright (c) 2000, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
d672 1
a672 1
#if (ULONG_MAX > 0xffffffffUL)
d676 4
a679 3
	if (upper_bound > 0x80000000)
		min = 1 + ~upper_bound;		/* 2**32 - upper_bound */
	else {
d681 1
a681 2
		min = ((0xffffffff - upper_bound) + 1) % upper_bound;
	}
@


1.55
log
@bump libc minor, to be able to pull in OAAT hash helper functions,
as well as globalise the hashpad things; sync mirmake and kernel
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.54 2009/11/09 20:11:56 tg Exp $ */
d1416 1
@


1.54
log
@reinit arc4 after $some_lot_of bytes, so that we never get the
full 2³⁰ or so bytes required to crack the stream, since we
count them anyway
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.53 2009/11/09 19:49:27 tg Exp $ */
a266 5
/* these will be in <libckern.h> (included via <sys/systm.h>) some day */
extern uint32_t _oaat_update(register uint32_t, register const uint8_t *,
    register size_t) __attribute__((bounded (string, 2, 3)));
extern uint32_t _oaat_final(register uint32_t);

d1471 1
a1471 1
	h = _oaat_final(_oaat_update(_oaat_update(h, vp, n),
@


1.53
log
@do more explicit initialisation to 0
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.52 2009/11/09 19:43:45 tg Exp $ */
d544 3
a546 1
	arc4random_state.cnt++;
@


1.52
log
@improve RNG stuff with proper hashing
(checked arc4* stuff to avoid short cycles; OpenBSD already ensured that)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.51 2009/02/22 17:06:26 tg Exp $ */
d730 2
@


1.51
log
@at kernel entry on shutdown (SYS_reboot), before shutting down the VFS,
add the wrandom(4) pool to arc4random(9) and stir the latter, so that
the superblock entropy fields and other places get the maximum possible
out of it
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.50 2009/01/29 17:53:29 tg Exp $ */
d267 5
d1431 45
@


1.50
log
@* flesh out arc4_addrandom
* do not stir arc4random(9) whenever the "slow pool" is full
* add another timeouty routine, called every 64±32sec, which
  extracts 8 bytes (an "extraction unit") and adds it (and a
  timestamp) to the "arandom pool" like arc4random_addrandom
  does, iff the "main pool" has more! than 32 bytes worth of
  entropy left

this should improve overall entropy consumption and distribution,
introducing a slight favour towards arandom(4) away from srandom(4)
and urandom(4) -- get a VIA C3 system if you need the latter, as on
them, srandom spits out 128 KiB or so in a second (woah).
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.49 2009/01/21 19:46:53 tg Exp $ */
d508 1
d1414 12
@


1.49
log
@similarily as in user space
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.48 2008/12/26 19:58:06 tg Exp $ */
d408 2
a409 1
struct timeout rnd_timeout, arc4_timeout, rnd_addpool_timeout;
d501 2
d507 1
d554 1
a554 1
	register u_int8_t si, cf;
a567 1
	arc4random_state.i--;
d590 1
a590 9
	for (n = 0; n < 256; n++) {
		arc4random_state.i++;
		si = arc4random_state.s[arc4random_state.i];
		arc4random_state.j += si + buf[n];
		arc4random_state.s[arc4random_state.i] =
		    arc4random_state.s[arc4random_state.j];
		arc4random_state.s[arc4random_state.j] = si;
	}
	arc4random_state.j = arc4random_state.i;
d611 1
a611 1
		timeout_add(&arc4_timeout, arc4random_seedfreq);
d709 2
a710 1
	timeout_set(&arc4_timeout, arc4_reinit, NULL);
d748 1
d1020 1
a1020 2
		} else
			arc4_reinit(NULL);
d1369 44
@


1.48
log
@wtf?
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.47 2008/11/13 00:19:00 tg Exp $ */
d7 1
a7 1
 * Copyright (c) 2000, 2002, 2003, 2004, 2005, 2006, 2007, 2008
d550 1
a550 1
	register u_int8_t si;
d554 2
a605 3
	for (n = 0; n < 256 * 4; n++)
		arc4_getbyte();

d607 2
a608 1
	for (n = (random() & 7) + (arc4_getbyte() & 7); n; --n)
d636 2
d650 2
a653 2
	while (n--)
		(void)arc4_getbyte();
@


1.47
log
@reduce standard arc4random seed frequency a little, because due to our
higher number of entropy sources, the pool gets more full more quickly
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.46 2008/07/26 19:40:51 tg Exp $ */
a702 1
	/* this one is generated from newvers.sh */
@


1.46
log
@now that we have the name IMACSing, use it in various places
instead of the previous “just how do we call it”-temporaries
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.45 2008/07/12 16:15:15 tg Exp $ */
d8 1
a8 1
 *	Thorsten “mirabilos” Glaser <tg@@mirbsd.de>
a727 1
	/* 10 minutes, per dm@@openbsd's suggestion */
d729 1
a729 1
		arc4random_seedfreq = 10 * 60 * hz;
@


1.45
log
@• dev/rnd*: implement new add_kbint_randomness() macro for keyboard-
  (and/or) interactive entropy (currently the same as add_tty_randomness,
  but will change in the future)
• zskbd(4/sparc): feed raw scancode entropy into pool too, like pckbd(4)
  does on i386, so that nōn-serial-console users can tap on shift, ctrl,
  alt, meta and the likes before or during e.g. ssh key generation
• pckbc.c: use new add_kbint_randomness ipv add_tty_randomness
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.44 2008/07/10 14:39:24 tg Exp $ */
d839 1
a839 1
	else if (xstate == RND_SRC_KBI) {
d927 1
a927 1
	if ((xstate < RND_SRC_NUM) || (xstate == RND_SRC_KBI)) {
@


1.44
log
@merge
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.43 2008/07/08 13:43:12 tg Exp $ */
d839 5
a850 1
	val += state << 13;
d927 1
a927 1
	if (xstate < RND_SRC_NUM) {
@


1.43
log
@bounds checking
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.42 2008/07/08 13:25:28 tg Exp $ */
d654 45
d1367 1
a1367 1
	timeout_add(&rnd_addpool_timeout, (hz >> 1) + (arc4random() % hz));
@


1.42
log
@really allow premature use of arc4random(9) [safely returning values
generated from random() instead] – r1.28 cid 1004682AD576DE15368 was
a nice try but not enough
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.41 2008/07/08 13:20:04 tg Exp $ */
d495 3
a497 1
void extract_entropy(register u_int8_t *, int);
@


1.41
log
@• since homsn is so afraid of wrandom(4) and Tonnerre mentions possible
  birthday attacks, instead of modulating the LSB we now XOR the entire
  value with an arc4random(9)-generated one before adding, which, while
  not adding extra entropy (due to the loop issue), prevents these, and
  since there’s a distance of 2 pools, we do not have back coupling.
• do _not_ use random(), as it’s used for PIDs by the scheduler, or so,
  says the hints, use arc4random() instead
• #ifdef DIAGNOSTIC code that could never have been executed, add a de-
  bugging message, and do *not* forget to re-schedule (oO)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.40 2008/06/13 14:00:04 tg Exp $ */
d613 2
a614 3
	if (!arc4random_initialised) {
		if (rnd_attached)
			timeout_add(&arc4_timeout, arc4random_seedfreq);
@


1.40
log
@• get rid of rnd_bootpool* now that we can use rnd_addpool_add() early
• drain the rnd_addpool not a 32-burst every half minute or so, but
  one word at a time about every second ± ½
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.38 2008/04/09 05:45:41 tg Exp $ */
d1301 4
a1304 1
	if (!rnd_attached)
d1306 2
d1319 1
a1319 1
		enqueue_randomness(RND_SRC_POOL, j - (random() & 1));
d1321 1
a1321 1
	timeout_add(&rnd_addpool_timeout, (hz >> 1) + (random() % hz));
@


1.39
log
@speedup: only process rnd_addpool_allow check while draining, not adding
@
text
@d429 1
a429 1
uint32_t rnd_addpool_buf[rnd_addpool_size], rnd_bootpool = 1 /* adler32 */;
d431 1
d435 1
a435 1
int arc4random_seedfreq = 0, rnd_bootpool_done = 0;
d687 1
a687 3
	timeout_add(&rnd_addpool_timeout, hz << 5);
	/* this one is enqueued in init_main.c */
	rnd_bootpool ^= random() << 8;
d704 2
a1298 1
	register int i;
d1305 2
a1306 2
		/* reschedule to try again in eight minutes if disabled */
		timeout_add(&rnd_addpool_timeout, hz << 9);
d1310 5
a1314 7
	/* add this user-space and untrusted bucket to random pool */
	for (i = 0; i < rnd_addpool_size; ++i)
		if ((j = rnd_addpool_buf[i]))	/* don't add all zeroes */
			if (++j)		/* don't add all ones */
				enqueue_randomness(RND_SRC_POOL,
				    j - (random() & 1));
	bzero(rnd_addpool_buf, sizeof (rnd_addpool_buf));
d1316 1
a1316 2
	/* re-schedule this routine in about 32..40 seconds (randomised) */
	timeout_add(&rnd_addpool_timeout, (hz << 5) + (random() % (hz << 3)));
@


1.38
log
@new macro rnd_bootpool_add for
• simplifying operations on rnd_bootpool
• allowing to use it _past_ enqueueing of rnd_bootpool into user pool
  near end of kernel boot-up (think PCMCIA NIC hot-plug¹)

¹) yes, despite RFC1750 and with Vutral’s idea
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.37 2008/03/22 22:58:41 tg Exp $ */
d430 1
a430 1
uint32_t rnd_addpool_num = 0, rnd_addpool_allow = 1;
d1191 1
a1191 2
	if (minor(dev) == RND_RND ||
	    ((minor(dev) == RND_PRND) && !rnd_addpool_allow))
@


1.37
log
@thinko (compile fix)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.36 2008/03/22 22:54:17 tg Exp $ */
d434 1
a434 1
int arc4random_seedfreq = 0;
@


1.36
log
@refacture: we only want to use the slow pool if it's full,
we only want to fill it if it's enabled and not full,
we can use it if we just filled it up to max,
and we always must fill in buf[0‥255], no matter what
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.35 2008/03/22 22:26:29 tg Exp $ */
d563 3
a565 1
		extract_entropy(&si, 1);
d567 1
a567 1
			initial_entropy[initial_entropy_ptr++] = si;
d569 1
a569 1
			buf[0] ^= si;
@


1.35
log
@Another step towards recomming arandom(4) for high-quality high-security
use (and arc4random(3) gets improved as well):

As suggested by Bruce Schneier’s Yarrow paper, split the arandom(4) source
into a “slow pool” and a “fast pool”, the latter being what we already had,
the former being the new thing: the uint8_t initial_entropy[16] array in-
troduced with commitid 10047E40AFE44E65982 is employed, after the initial
enqueue of its content into the pool and bzero(3)ing it (and setting the
value of initial_entropy_ptr from the initial -1 to 0), to keep a 128-bit
“slow pool” (with initial_entropy_ptr ranging from 0‥15) which is XOR’d
into the 256 octets stirring the arcfour state IFF it’s full. The “slow
pool” is filled whenever any entropy is dequeued from the main pool to an
amount that would deplete it, or on arc4 stirs if we’ve got an octet left
after eating up some pool data. The slow pool mixes into all of the fast
pool upon emptying.

While care has been taken on designing this, srandom(4) may be affected as
its check for the data size read being smaller than entropy_count comes be-
fore the dequeue action (which, in turn, _can_ extract eight more bits if
the pool would be emptied). Suggestion is to use very small reads, if you
must use srandom(4), or to use arandom(4) instead (or just mix both).
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.34 2008/03/21 19:22:16 tg Exp $ */
d560 10
a569 2
	if (initial_entropy_ptr < 0) {
		/* before initial slow pool depletion */
d572 1
a572 11
	} else if (initial_entropy_ptr < sizeof (initial_entropy)) {
		/* add into the slow pool if we still have real entropy */
		if (random_state.entropy_count > 8) {
			uint8_t tbuf;

			/* tmp buffer, in case extract_entropy does this too */
			extract_entropy(&tbuf, 1);
			if (initial_entropy_ptr < sizeof (initial_entropy))
				initial_entropy[initial_entropy_ptr++] = tbuf;
		}
	} else {
@


1.34
log
@I thought this could be nice: add 128 bits of boot entropy to each kernel
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.33 2007/09/28 18:33:24 tg Exp $ */
d7 1
a7 1
 * Copyright (c) 2000, 2002, 2003, 2004, 2005, 2006, 2007
d436 4
d560 22
d585 1
a585 1
		arc4random_state.j += si + buf[n % len];
a656 1
	extern unsigned char initial_entropy[16];
d704 1
d955 4
d960 15
a974 1
	add_timer_randomness(nbytes);
@


1.33
log
@• do not always srandom(), once is enough, it’s not supposed to be crypto-
  graphically good anyway, just continuous
• new int arc4random_seedfreq; contains the frequency of arc4random(9)
  re-seeds, by default still 10 minutes
• if a VIA C3 Hardware RNG is found, re-seed every minute (ok 64 seconds…)
• bump © years, sync licence etc.
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.32 2007/09/24 16:56:23 tg Exp $ */
d630 2
d664 15
@


1.33.4.1
log
@MFC: what was I thinking? on a premature arc4random_maybeinit() call,
either by arc4random() or by arc4random_getbytes(), rnd_attached was
0 and arc4random_initialised 0, but we set arc4random_initialised to
1 without doing the deed…
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.33 2007/09/28 18:33:24 tg Exp $ */
d586 3
a588 2
	if (!arc4random_initialised && rnd_attached) {
		timeout_add(&arc4_timeout, arc4random_seedfreq);
@


1.32
log
@let arc4random_bytes() do the fuzziness trick instead
doesn't really hurt the only two other uses, and saves some bytes
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.31 2007/09/24 16:24:25 tg Exp $ */
d7 2
a8 2
 * Copyright (c) 2000, 2002, 2003, 2004, 2005, 2006
 *	Thorsten "mirabilos" Glaser <tg@@mirbsd.de>
d223 1
a223 1
 * /dev/random and /dev/{s,u,a,p}random created already, they can be
d265 2
d408 1
a408 1
struct timeout rnd_timeout, arc4_timeout, prnd_timeout, rnd_addpool_timeout;
d434 1
d436 2
a437 5
void srandom(u_long);
void prnd_reinit(void *);
void rnd_addpool_reinit(void *);

static u_int32_t roll(u_int32_t w, int i)
d448 1
a448 1
static struct rand_event *
d465 1
a465 1
static struct rand_event *
d480 1
a480 1
static int
d496 1
d579 1
a579 1
	for (n = (random() & 0x0F); n; --n)
a585 2
	extern int hz;

a586 1
		/* 10 minutes, per dm@@'s suggestion */
d588 1
a588 1
			timeout_add(&arc4_timeout, 10 * 60 * hz);
a612 16
prnd_reinit(void *v)
{
	extern int hz;
	extern volatile int ticks;

	if (!rnd_attached) {
		srandom(ticks ^ time.tv_sec);
		return;
	}

	timeout_add(&prnd_timeout, hz << 8);
	/* re-seed the PRNG about once every 4-and-a-bit minutes */
	srandom(arc4random());
}

void
a639 1
	timeout_set(&prnd_timeout, prnd_reinit, NULL);
a641 2
	prnd_reinit(NULL);

d654 3
a656 1
	timeout_add(&rnd_addpool_timeout, hz << 5);
d659 1
d995 1
a995 1
#ifdef RNDEBUG
d1004 1
a1004 1
#ifdef RNDEBUG
d1014 1
a1014 1
#ifdef RNDEBUG
d1020 1
a1020 1
#ifdef RNDEBUG
d1235 1
a1235 1
void
a1237 1
	extern int hz;
@


1.31
log
@rate-limit the /dev/arandom and sysctl KERN_ARND output a little,
to reduce the danger arising from recognisable output patterns as
shown in the Schneier paper discussing PRNGs (I was thinking of a
programme pulling high-rate from /dev/arandom)

this is not the best I can do, but it's quite ok (and uneven)

now we’d ideally have some kind of pool fed with very conservati-
vely measured entropy, maybe 32 bits or so, and xoring the buffer
in arc4_stir with that before using it, to protect against a high
rate pull from /dev/srandom
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.30 2007/08/24 14:15:05 tg Exp $ */
d637 1
d640 2
d1049 1
a1049 9
		{
			u_int8_t *cp = (u_int8_t *) buf;
			u_int8_t *end = cp + n;
			arc4maybeinit();
			while (cp < end)
				*cp++ = arc4_getbyte();
			i = arc4_getbyte() % 3;
			while (i--)
				(void)arc4_getbyte();
a1050 1
		}
@


1.30
log
@hopefully fix all the “timeout_add: not initialis̲ed” panic()s…
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.29 2007/07/26 10:16:21 tg Exp $ */
d1052 3
@


1.29
log
@pad with (1‥3) arc4random(9) instead of NUL bytes, since the entropy adder
assumes 32 bit for randomwrite()
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.28 2007/06/27 18:33:04 tg Exp $ */
d435 1
a435 1
static void rnd_addpool_reinit(void *);
d589 2
a590 1
		timeout_add(&arc4_timeout, 10 * 60 * hz);
d620 5
d627 1
a627 1
	srandom(rnd_attached ? arc4random() : (ticks ^ time.tv_sec));
d672 1
a672 1
	rnd_addpool_reinit(NULL);
d1256 1
a1256 1
static void
d1263 6
a1268 3
	if (!rnd_addpool_allow || !rnd_attached) {
		/* reschedule in eight minutes if disabled, a half on boot */
		timeout_add(&rnd_addpool_timeout, hz << (rnd_attached ? 9 : 5));
@


1.28
log
@if premature use of arc4random(), don't timeout_add an uninitialised
value before panic()ing, return a random() value instead
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.27 2007/02/02 16:45:07 tg Exp $ */
d1161 1
a1161 1
				((u_int8_t *) buf)[n++] = 0;
@


1.27
log
@make /dev/wrandom as alias for /dev/prandom but allow it to
be written to - I plan to emulate our entropy suite on other
OSes where /dev/prandom may be read-only emulated by pipes
or similar means
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.26 2006/10/08 00:24:43 tg Exp $ */
d521 3
a589 4
#ifdef DIAGNOSTIC
		if (!rnd_attached)
			panic("arc4maybeinit: premature");
#endif
@


1.26
log
@add a few more entropy sources, some suggested by Vutral, but don't
scan for /*/PUTTY.RND and /*/RANDSEED.BIN ;-) and remove a stupid one;
move dmesg.boot code for installer from install.sub into firstrun
code, and initialise a counter in rnd.c to zero which was previously not (oO)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.25 2006/10/03 20:23:56 tg Exp $ */
d174 1
a174 1
 * The buffer can be filled with writes to /dev/prandom unless the
@


1.25
log
@SECURITY: if the kern.pushrand sysctl is enabled (default), unprivilegued
users can bring a system (locally) to ddb(4) if writing approx. POOLBYTES
bytes to /dev/prandom (off-by-one-uint32_t buffer read). Possibly fixed.
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.24 2006/08/22 20:58:24 tg Exp $ */
d428 1
a428 1
uint32_t rnd_addpool_num, rnd_addpool_allow = 1;
@


1.24
log
@double the size of the addpool buffer, now that it isn't
accounted for as "true randomness" (but still added)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.23 2006/08/18 12:29:52 tg Exp $ */
d1163 1
d1165 2
a1166 2
				for (n >>= 2; n; --n)
					rnd_addpool_add(buf[n]);
d1168 1
a1168 1
				add_entropy_words(buf, n / 4);
@


1.23
log
@slightly improve the addpool; don't count its input as 'true entropy'
since it isn't (pending a post-#9bis redesign in -current)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.22 2006/06/29 13:27:36 tg Exp $ */
d171 1
a171 1
 * The pool is sized at 16 (rnd_addpool_size) uint32_ts FOR A REASON!
d843 1
a843 1
	if (state == xstate) {
@


1.22
log
@remove pretty useless "re-initialise random() on writes to /dev/prandom",
it ust bloats the code ;) and the PRND is re-initialised anyway automatically
also, correct spelling and make two variables static while here
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.21 2006/05/28 23:35:20 tg Exp $ */
d745 1
a745 1
enqueue_randomness(int state, int val)
d752 1
d757 3
d843 6
a848 4
	rndstats.rnd_enqs++;
	rndstats.rnd_ed[nbits]++;
	rndstats.rnd_sc[state]++;
	rndstats.rnd_sb[state] += nbits;
d1267 2
a1268 1
				add_true_randomness(j - (random() & 1));
@


1.21
log
@speed up first processing of the addpool buffer
(at boot, more things happen)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.20 2006/05/28 13:24:54 tg Exp $ */
d327 1
a327 1
 * well to make a twisted Generalized Feedback Shift Register
d429 2
a430 2
int rnd_attached;
int arc4random_initialized;
d584 1
a584 1
	if (!arc4random_initialized) {
d591 1
a591 1
		arc4random_initialized++;
d603 1
a603 1
	arc4random_initialized = 0;
d1166 1
a1166 3
		arc4random_initialized = 0;
	if (minor(dev) == RND_PRND && !ret)
		srandom(arc4random());
d1223 1
a1223 1
			arc4random_initialized = 0;
@


1.20
log
@* rnd_addpool_add: instead of complicated buffer backtracing,
  just process all over the buffer (512 bit, so a SHA-2 fits)
  discarding all all-zero and all-ones entries, keep the ran-
  domising to prevent attack vector, bzero the addpool buffer
  afterwards and don't care about the ringbuffer counter
  speeds up by some amount; 16 32-bit words is still small
* add_true_randomness: an int is 32 not 31 bits, account pro-
  perly if you try to account, dear mickey
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.19 2006/05/28 13:19:11 tg Exp $ */
d1254 2
a1255 2
		/* reschedule in about eight minutes, it's disabled anyway */
		timeout_add(&rnd_addpool_timeout, hz << 9);
@


1.20.2.1
log
@I intended to commit this because my debugging script:
| while sleep 2; do
|	set -A foo $(sysctl kern.random)
|	let i=${foo[56]}
|	printf '%16s' "$i ($((i / 32)))"
| done
didn't display anything worthwhile, but I had forgotten
about the initial delay where rnd(4) is not yet attached;
it works now (icmp, tcp, rdate all contribute; filling it
manually via /dev/prandom adds 16 32-bit values; the in-
terval is randomised).
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.20 2006/05/28 13:24:54 tg Exp $ */
d1260 1
a1260 7
#ifdef RNADDPOOL_DEBUG
	printf("rnd_addpool_reinit:");
#endif
	for (i = 0; i < rnd_addpool_size; ++i) {
#ifdef RNADDPOOL_DEBUG
		printf(" <%d:%08X", i, rnd_addpool_buf[i]);
#endif
d1262 1
a1262 4
			if (++j) {		/* don't add all ones */
#ifdef RNADDPOOL_DEBUG
				printf(" ok");
#endif
a1263 8
			}
#ifdef RNADDPOOL_DEBUG
		printf(">");
#endif
	}
#ifdef RNADDPOOL_DEBUG
	printf("\n");
#endif
a1265 3
#ifdef RNADDPOOL_DEBUG
	timeout_add(&rnd_addpool_timeout, hz << 4);	/* 16 seconds */
#else
a1267 1
#endif
@


1.19
log
@* randomwrite() is always called after attach
* speed up srandom
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.18 2006/05/28 02:55:16 tg Exp $ */
d825 1
a825 1
		nbits = 8 * sizeof (val) - 1;
d1250 2
a1251 1
	register int i = rnd_addpool_num;
d1260 5
a1264 11
	if (!i)
		i = rnd_addpool_size;
	while ((--i != rnd_addpool_num) && (rnd_addpool_buf[i])) {
		if (--rnd_addpool_buf[i])
			add_true_randomness(rnd_addpool_buf[i] +
			     (random() & 1));
		rnd_addpool_buf[i] = 0;
		if (!i)
			i = rnd_addpool_size;
	}
	rnd_addpool_num = i;
@


1.18
log
@missing parens
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.17 2006/05/28 02:52:58 tg Exp $ */
d1168 1
a1168 1
		srandom(rnd_attached ? arc4random() : time.tv_sec);
@


1.17
log
@strip out "all bits 0", "all bits 1" and randomise to prevent
attack vector, all in once
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.13 2006/05/07 06:54:46 tg Exp $ */
d1263 2
a1264 1
			add_true_randomness(rnd_addpool_buf[i] + random() & 1);
@


1.16
log
@fix reschedule intervals for addpool cleaner
(now: 8.5 min if off, 32..40 sec if on)
@
text
@d1262 2
a1263 1
		add_true_randomness(rnd_addpool_buf[i]);
@


1.15
log
@* add entropy from lower memory (at boot-up) and
  kernel msg buffer (at its initialisation time)
  into random pool
* don't initialise with ticks repeatedly
@
text
@a1250 2
	/* empty about once every minute by default */
	int delay = hz << 6;
d1253 2
a1254 2
		/* reschedule in four and a bit minutes, it's off anyway */
		timeout_add(&rnd_addpool_timeout, hz << 8);
a1257 2
	delay += (arc4random() & 15) - 8; /* randomise re-schedule interval */

d1269 2
a1270 2
	/* re-schedule this routine */
	timeout_add(&rnd_addpool_timeout, delay);
@


1.14
log
@clean up the code a little (spacing, KNF, ...)
@
text
@d427 1
a427 1
uint32_t rnd_addpool_buf[rnd_addpool_size];
d670 2
@


1.13
log
@disallow some writing/flushing operations on the rnd device
when the system is in "highly secure mode", inspired by gecko2
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.12 2006/04/11 00:32:52 tg Exp $ */
d369 1
a369 1
#define QEVLEN (1024 / sizeof(struct rand_event))
d394 1
a394 1
	u_int	cnt;
d444 1
a444 1
	return w;
d454 1
a454 1
		return NULL;
d461 1
a461 1
	return p;
d474 1
a474 1
		return NULL;
d476 1
a476 1
	return rnd_event_head = p;
d484 1
a484 1
	return (len < 0)? -len : len;
d543 1
a543 1
	microtime((struct timeval *) buf);
d545 2
a546 2
	if (len > sizeof(buf) - sizeof(struct timeval))
		len = sizeof(buf) - sizeof(struct timeval);
d548 1
a548 1
	len += sizeof(struct timeval);
d661 2
a662 2
	bzero(&rndstats, sizeof(rndstats));
	bzero(&rnd_event_space, sizeof(rnd_event_space));
d675 1
a675 1
	return (minor (dev) < RND_NODEV) ? 0 : ENXIO;
d681 1
a681 1
	return 0;
d747 2
a748 2
	struct timeval	tv;
	u_int	time, nbits;
d763 1
a763 1
	time = tv.tv_usec ^ tv.tv_sec;
d773 3
a775 3
		delta  = time   - p->last_time;
		delta2 = delta  - p->last_delta;
		delta3 = delta2 - p->last_delta2;
d819 1
a819 1
		p->last_time = time;
d823 1
a823 1
		nbits = 8 * sizeof(val) - 1;
d834 1
a834 1
	rep->re_time = time;
d918 1
a918 4
		if (nbytes < sizeof(buffer) / 2)
			i = nbytes;
		else
			i = sizeof(buffer) / 2;
d923 1
a923 1
		MD5Update(&tmp, (u_int8_t*)rs->pool, sizeof(rs->pool));
d955 2
a956 2
	bzero(&tmp, sizeof(tmp));
	bzero(&buffer, sizeof(buffer));
d967 1
a967 1
	extract_entropy((u_int8_t *) buf, nbytes);
d985 1
a985 1
		int	n = min(POOLBYTES, uio->uio_resid);
d997 1
a997 1
#ifdef	RNDEBUG
d1006 1
a1006 1
#ifdef	RNDEBUG
d1016 1
a1016 1
#ifdef	RNDEBUG
d1022 1
a1022 1
#ifdef	RNDEBUG
d1050 1
a1050 1
	return ret;
d1140 1
a1140 1
		return ENXIO;
d1143 1
a1143 1
		return 0;
d1153 1
a1153 1
			while (n % sizeof(u_int32_t))
d1170 1
a1170 1
	return ret;
d1176 2
a1177 2
	int	s, ret = 0;
	u_int	cnt;
d1196 1
a1196 4
		if (securelevel > 1)
			return (EPERM);

		if (suser(p, 0) != 0)
d1208 1
a1208 4
		if (securelevel > 1)
			return (EPERM);

		if (suser(p, 0) != 0)
d1217 1
a1217 4
		if (securelevel > 1)
			return (EPERM);

		if (suser(p, 0) != 0)
d1232 1
a1232 1
			bzero(&rndstats, sizeof(rndstats));
d1241 1
a1241 1
	return ret;
@


1.12
log
@reduce time to once every minute (approx.) and use plus/minus on
the randomising interval; adjust comments accordingly
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.11 2006/04/11 00:29:51 tg Exp $ */
d1138 3
d1199 3
d1214 3
d1226 3
@


1.11
log
@* fix thinko: instead of every two (and a bit) minutes we were
  emptying the userland-randomness bucket four times a minute.
* fix spelling: anyways -> anyway
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.10 2006/04/11 00:23:41 tg Exp $ */
d1249 2
a1250 1
	int delay = hz << 7;
d1258 1
a1258 1
	delay |= arc4random() & 15;
d1260 1
a1260 1
	/* add cksum-pool to random pool about once every 2.x minutes */
d1271 1
@


1.10
log
@randomise the time when the next emptying of the addbuf pool is scheduled
a little (only increase it to further reduce low-enough drop rate)
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.9 2006/03/27 09:25:23 tg Exp $ */
d1249 1
a1249 1
	int delay = hz << 4;
d1252 1
a1252 1
		/* reschedule in four and a bit minutes, it's off anyways */
@


1.9
log
@change type of assembly-accessed variables to uint32_t
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.8 2006/02/27 20:45:30 tg Exp $ */
d1249 1
d1257 2
d1270 1
a1270 1
	timeout_add(&rnd_addpool_timeout, hz << 4);
@


1.8
log
@* skip the timeout_del in rnd_addpool_reinit
* make rnd_addpool_reinit static to ensure it's only being called from this
  file and check it's not called shortly before a timeout to make the above
  commit safe
* verify that timeout_add with the timeout already en queue is safe
* move the other timeout_add calls up in the function to reschedule them to
  a later point in time if called directly
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.7 2006/02/23 01:29:32 tg Exp $ */
d428 1
a428 2
size_t rnd_addpool_num;
int rnd_addpool_allow = 1;
@


1.7
log
@add timer randomness on randomread
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.6 2006/02/23 01:28:27 tg Exp $ */
d436 1
a436 1
void rnd_addpool_reinit(void *);
d586 2
a593 2
		/* 10 minutes, per dm@@'s suggestion */
		timeout_add(&arc4_timeout, 10 * 60 * hz);
d621 1
a623 1
	timeout_add(&prnd_timeout, hz << 8);
d1245 1
a1245 1
void
a1250 2
	timeout_del(&rnd_addpool_timeout);

@


1.6
log
@* on /dev/prandom writes, re-seed internal PRNG too
  (which is being used e.f. for /dev/prandom reads)
* on /dev/*random writes, add timer randomness
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.5 2006/02/23 01:18:20 tg Exp $ */
d986 1
d1052 1
@


1.5
log
@* make arc4maybeinit static
* initialise PRNG a little bit earlier
* always carry over a few old PRNG (random()) bits
* fix comments, update licence year
* improve srandom() logic
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.4 2005/07/07 14:01:59 tg Exp $ */
d1145 1
d1164 2
d1167 1
@


1.4
log
@merge
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.3 2005/07/04 00:10:41 tg Exp $ */
d7 2
a8 2
 * Copyright (c) 2000, 2002, 2003, 2004, 2005
 *	Thorsten "mirabile" Glaser <tg@@66h.42h.de>
d194 1
a194 1
 *		cat /etc/random-seed >/dev/urandom
d258 1
d496 1
a496 1
void arc4maybeinit(void);
d580 1
a580 1
void
d621 2
a622 2
	/* seed the PRNG about once every 4-and-a-bit minutes */
	srandom(rnd_attached ? arc4random() : (random() ^ (ticks * hz)));
d654 2
a667 1
	prnd_reinit(NULL);
@


1.4.2.1
log
@MFC: make code match comments, re-schedule once about every 2 minutes
@
text
@d1 1
a1 1
/**	$MirOS: src/sys/dev/rnd.c,v 1.4 2005/07/07 14:01:59 tg Exp $ */
d1262 1
a1262 1
	timeout_add(&rnd_addpool_timeout, hz << 7);
@


1.3
log
@merge
@
text
@d1 2
a2 2
/**	$MirOS: src/sys/dev/rnd.c,v 1.2 2005/03/06 21:27:35 tg Exp $ */
/*	$OpenBSD: rnd.c,v 1.77 2005/05/27 16:33:27 ho Exp $	*/
d910 3
d917 4
a920 2
		MD5_CTX tmp;
		int i, s;
d926 2
a927 2
		if (rs->entropy_count / 8 > nbytes)
			rs->entropy_count -= nbytes * 8;
a931 1
		bzero(&tmp, sizeof(tmp));
d947 1
a947 4
		if (nbytes < sizeof(buffer) / 2)
			bcopy(buffer, buf, i = nbytes);
		else
			bcopy(buffer, buf, i = sizeof(buffer) / 2);
d957 1
@


1.2
log
@* merge src/sys/
  (at least the better part of it)
* revert IPv6 networking to OpenBSD, since
  I didn't get IPV4_MAPPED addresses working :(
@
text
@d1 2
a2 2
/**	$MirOS$ */
/*	$OpenBSD: rnd.c,v 1.75 2005/01/27 18:18:20 mickey Exp $	*/
d490 1
a490 1
static __inline void extract_entropy(register u_int8_t *, int);
d493 1
a493 1
static __inline void arc4_stir(void);
d535 1
a535 1
static void
d734 1
a734 1
 * The number "num" is also added to the pool - it should somehow describe
d905 1
a905 1
static void
@


1.1
log
@Initial revision
@
text
@d1 1
d7 2
a9 3
 *
 * Version 1.89, last modified 19-Sep-99
 *
d166 11
d206 2
a207 2
 * For example, on OpenBSD systems, the appropriate scripts are
 * usually /etc/rc.local and /etc/rc.shutdown, respectively.
d218 2
a219 2
 * Configuring the random(4) driver under OpenBSD
 * ==============================================
d223 2
a224 2
 * /dev/random and /dev/[s|u|p|a]random created already, they can be created
 * by using the MAKEDEV(8) script in /dev:
d226 1
a226 1
 *	/dev/MAKEDEV random
a239 3
 * Any flaws in the design are solely my responsibility, and should
 * not be attributed to the Phil, Colin, or any of the authors of PGP.
 *
d405 1
a405 1
struct timeout rnd_timeout, arc4_timeout;
d426 3
d433 5
a437 1
static __inline u_int32_t roll(u_int32_t w, int i)
d448 1
a448 1
static __inline struct rand_event *
d465 1
a465 1
static __inline struct rand_event *
d480 1
a480 1
static __inline int
d535 1
a535 1
static __inline void
d573 4
d601 1
a601 2
arc4_reinit(v)
	void *v;
d615 11
d650 2
d665 2
d668 1
a668 1
	rnd_attached = 1;
d672 1
a672 5
randomopen(dev, flag, mode, p)
	dev_t	dev;
	int	flag;
	int	mode;
	struct proc *p;
d678 1
a678 5
randomclose(dev, flag, mode, p)
	dev_t	dev;
	int	flag;
	int	mode;
	struct proc *p;
d698 1
a698 3
add_entropy_words(buf, n)
	const u_int32_t *buf;
	u_int n;
d742 1
a742 2
enqueue_randomness(state, val)
	int	state, val;
a749 1
	/* XXX on sparc we get here before randomattach() */
d849 1
a849 2
dequeue_randomness(v)
	void *v;
d896 1
a896 1
#error extract_entropy() assumes that POOLWORDS is a multiple of 16 words.
d905 2
a906 4
static __inline void
extract_entropy(buf, nbytes)
	register u_int8_t *buf;
	int	nbytes;
d965 1
a965 3
get_random_bytes(buf, nbytes)
	void	*buf;
	size_t	nbytes;
d972 1
a972 4
randomread(dev, uio, ioflag)
	dev_t	dev;
	struct uio *uio;
	int	ioflag;
d1052 1
a1052 4
randompoll(dev, events, p)
	dev_t	dev;
	int	events;
	struct proc *p;
d1104 1
a1104 3
filt_rndread(kn, hint)
	struct knote *kn;
	long hint;
d1122 1
a1122 3
filt_rndwrite(kn, hint)
	struct knote *kn;
	long hint;
d1128 1
a1128 4
randomwrite(dev, uio, flags)
	dev_t	dev;
	struct uio *uio;
	int	flags;
d1133 2
a1134 1
	if (minor(dev) == RND_RND || minor(dev) == RND_PRND)
d1149 5
a1153 1
			add_entropy_words(buf, n / 4);
d1165 1
a1165 6
randomioctl(dev, cmd, data, flag, p)
	dev_t	dev;
	u_long	cmd;
	caddr_t	data;
	int	flag;
	struct proc *p;
d1234 28
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@sync all standard devices and "better midi stuff"
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.77 2005/05/27 16:33:27 ho Exp $	*/
d475 1
a475 1
void extract_entropy(register u_int8_t *, int);
d478 1
a478 1
void arc4_stir(void);
d520 1
a520 1
void
d711 1
a711 1
 * The number "val" is also added to the pool - it should somehow describe
d885 1
a885 1
void
@


1.1.1.3
log
@sync against OpenBSD-HEAD
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.78 2005/07/07 00:11:24 djm Exp $	*/
a891 3
	MD5_CTX tmp;
	u_int i;
	int s;
d896 2
a897 4
		if (nbytes < sizeof(buffer) / 2)
			i = nbytes;
		else
			i = sizeof(buffer) / 2;
d903 2
a904 2
		if (rs->entropy_count / 8 > i)
			rs->entropy_count -= i * 8;
d909 1
d925 4
a928 1
		bcopy(buffer, buf, i);
a937 1
	bzero(&tmp, sizeof(tmp));
@


1.1.1.4
log
@+arc4random_uniform
@
text
@a606 45
/*
 * Calculate a uniformly distributed random number less than upper_bound
 * avoiding "modulo bias".
 *
 * Uniformity is achieved by generating new random numbers until the one
 * returned is outside the range [0, 2**32 % upper_bound).  This
 * guarantees the selected random number will be inside
 * [2**32 % upper_bound, 2**32) which maps back to [0, upper_bound)
 * after reduction modulo upper_bound.
 */
u_int32_t
arc4random_uniform(u_int32_t upper_bound)
{
	u_int32_t r, min;

	if (upper_bound < 2)
		return 0;

#if (ULONG_MAX > 0xffffffffUL)
	min = 0x100000000UL % upper_bound;
#else
	/* Calculate (2**32 % upper_bound) avoiding 64-bit math */
	if (upper_bound > 0x80000000)
		min = 1 + ~upper_bound;		/* 2**32 - upper_bound */
	else {
		/* (2**32 - x) % x == 2**32 % x when x <= 2**31 */
		min = ((0xffffffff - upper_bound) + 1) % upper_bound;
	}
#endif

	/*
	 * This could theoretically loop forever but each retry has
	 * p > 0.5 (worst case, usually far better) of selecting a
	 * number inside the range we need, so it should rarely need
	 * to re-roll.
	 */
	for (;;) {
		r = arc4random();
		if (r >= min)
			break;
	}

	return r % upper_bound;
}

@


