head	1.15;
access;
symbols;
locks; strict;
comment	@ * @;


1.15
date	2019.08.25.22.20.50;	author tg;	state Exp;
branches;
next	1.14;
commitid	1005D63096C6637033A;

1.14
date	2015.07.07.18.00.42;	author tg;	state Exp;
branches;
next	1.13;
commitid	100559C13E400E6958B;

1.13
date	2015.07.07.17.56.27;	author tg;	state Exp;
branches;
next	1.12;
commitid	100559C12D32913AA6D;

1.12
date	2014.02.20.00.57.23;	author tg;	state Exp;
branches;
next	1.11;
commitid	100530552A55A17FDBE;

1.11
date	2014.02.19.22.17.25;	author tg;	state Exp;
branches;
next	1.10;
commitid	10053052D75174BBEE8;

1.10
date	2014.02.19.17.43.28;	author tg;	state Exp;
branches;
next	1.9;
commitid	1005304ED413F0CF25C;

1.9
date	2011.07.18.13.11.07;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004E2430C67A8B2271;

1.8
date	2011.07.09.19.09.39;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004E18A7874577A698;

1.7
date	2011.07.06.22.22.11;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004E14E010182825E7;

1.6
date	2011.02.19.14.41.39;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004D5FD6AD4C707315;

1.5
date	2010.09.25.11.33.17;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004C9DDE155213E77F;

1.4
date	2010.09.24.20.35.13;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004C9D0B38596B6444;

1.3
date	2010.09.24.19.59.08;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004C9D02C32F9ABA6D;

1.2
date	2010.09.21.17.42.51;	author tg;	state Exp;
branches;
next	1.1;
commitid	1004C98EEA9684B3BEB;

1.1
date	2010.09.19.18.55.33;	author tg;	state Exp;
branches;
next	;
commitid	1004C965C8F46717878;


desc
@@


1.15
log
@fix initial_entropy and _randseed reading:
• use the latter for locore
• concatenate them for randomattach, hash for enqueue_randomness
• switch to explicit_bzero in many places
@
text
@/* $MirOS: src/sys/crypto/randcore.c,v 1.12 2014/02/20 00:57:23 tg Exp $ */

/*-
 * Copyright © 2010, 2011, 2014, 2019
 *	mirabilos <m@@mirbsd.org>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un‐
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided “AS IS” and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person’s immediate fault when using the work as intended.
 *-
 * This file contains the core random device implementation and stee‐
 * ring point for the random subsystem in MirBSD. It also contains an
 * implementation of the “lopool”, i.e. a hashed pool where userspace
 * non-root processes and the kernel can send “untrusted” entropy to,
 * which then is periodically “collapsed” into an arcfour state named
 * lopool_collapse which in turn is used by arc4random_reinit when it
 * stirs the main arcfour state used in arc4random(9).
 */

#define IN_RANDOM_CORE

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/kernel.h>
#include <sys/timeout.h>
#include <crypto/randimpl.h>
#include <mirhash.h>

/* import from vers.c generated by conf/newvers.sh */
extern uint32_t _randseed;
/* only bytes actually changed by config(8) */
extern unsigned char initial_entropy[16];

struct rnd_pooladd {
	union {
		struct timeval tv;
#if defined(I586_CPU) || defined(I686_CPU)
		unsigned long long tsc;
#endif
	} u;
	const void *sp, *dp;
	size_t sz;
};

void rnd_lopool_dequeue(void *);

/*
 * This variable secures the following things: rndpool (tytso code) is
 * operational; timeouts for arc4random and lopool-collapse can be run;
 * lopool-collapse arcfour state has been initialised
 */
uint8_t rnd_attached = 0;

size_t lopool_content = 0;
uint32_t lopool_uhash[32];
uint8_t lopool_uptr = 0;

struct arcfour_status lopool_collapse;
struct timeout arc4random_timeout;
struct timeout rnd_lopool_timeout;

/*
 * Backend routine for adding some bytes, together with pointer,
 * size, stack, and timing information, into the hash lopool.
 * We use the BAFH transformation only for folding the user-
 * specified information into 32 BAFH states (128 bytes)
 * and count the bytes we added. (rnd_lopool_addh adds an BAFH
 * hash of the data, not the data itself.) Once the content is
 * 128 bytes or more, rnd_lopool_dequeue collapses them into
 * lopool_collapse where it will be picked up by the next run
 * of the arc4random(9) stir function.
 */
static void
rnd_pool_add(struct rnd_pooladd *sa, const void *d, size_t n)
{
	int s;

#if defined(I586_CPU) || defined(I686_CPU)
	if (pentium_mhz) {
		__asm __volatile("rdtsc" : "=A" (sa->u.tsc));
	} else
#endif
	    {
		/* cannot use memcpy since mono_time is volatile */
		sa->u.tv.tv_sec = mono_time.tv_sec;
		sa->u.tv.tv_usec = mono_time.tv_usec;
	}
	sa->sp = sa;

	RNDEBUG(RD_HASHLOPOOL, "rnd: lopool += %lu(%lu) bytes\n",
	    (u_long)n, (u_long)sa->sz);

	s = splhigh();
	arc4random_roundhash(lopool_uhash, &lopool_uptr, sa, sizeof(*sa));
	arc4random_roundhash(lopool_uhash, &lopool_uptr, d, n);
	lopool_content += n;
	rndstats.lopool_bytes += n;
	++rndstats.lopool_enq;
	splx(s);
}

/*
 * called from most of the initialisation code; historical because
 * we used to be unable to run either lopool’s antecessor or
 * arc4random itself early in the boot process; nowadays, this is
 * merely a “big data” function, e.g. for the pre-start log message
 * buffer, which may have leftovers from the last kernel, or some
 * filesystem superblock or other data of few entropic value
 */
void
rnd_lopool_addh(const void *vp, size_t n)
{
	struct rnd_pooladd pa;
	uint32_t h;

	h = arc4random();
	BAFHUpdateMem_reg(h, vp, n);
	BAFHFinish_reg(h);

	pa.dp = vp;
	pa.sz = n;
	rnd_pool_add(&pa, &h, sizeof(h));
}

/* these two directly add their argument into the lopool */

/* pointer and length, read data */
void
rnd_lopool_add(const void *buf, size_t len)
{
	struct rnd_pooladd pa;

	pa.dp = buf;
	pa.sz = len;
	rnd_pool_add(&pa, buf, len);
}

/* integral argument, passed on the stack */
void
rnd_lopool_addv(unsigned long v)
{
	struct rnd_pooladd pa;

	pa.sz = 0;
	rnd_pool_add(&pa, &v, sizeof(v));
}

#ifndef rnd_lopool_addvq
/* for use by the hardclockent routines: no RNDEBUG, no counting */
void
rnd_lopool_addvq(unsigned long v)
{
	int s;

	s = splhigh();
	arc4random_roundhash(lopool_uhash, &lopool_uptr, &v, sizeof(v));
	splx(s);
}
#endif

/*
 * This is the function called all 1‥3 seconds to collapse the
 * lopool’s hash into its arcfour state if there was enough data.
 */
void
rnd_lopool_dequeue(void *arg __unused)
{
	int s;
	struct timeval tv[2];

	s = splhigh();

	if (!rnd_attached) {
		RNDEBUG(RD_ALWAYS, "rnd: lopool dequeue before attach\n");
		goto out;
	}

	/* if we were called directly instead of from timeout */
	timeout_del(&rnd_lopool_timeout);

	if (lopool_content >= 128) {
		RNDEBUG(RD_ARC4LOPOOL, "rnd: lopool dequeues %lu bytes\n",
		    (u_long)lopool_content);

		/* add current time (mono and TAI) first */
		tv[0].tv_sec = mono_time.tv_sec;
		tv[0].tv_usec = mono_time.tv_usec;
		tv[1].tv_sec = time.tv_sec;
		tv[1].tv_usec = time.tv_usec;
		arc4random_roundhash(lopool_uhash, &lopool_uptr, tv,
		    sizeof(tv));

		/* finalise all 32 one-at-a-time hashes */
		for (lopool_uptr = 0; lopool_uptr < 32; ++lopool_uptr)
			BAFHFinish_mem(lopool_uhash[lopool_uptr]);

		/* stir the collapse pool with the result */
		arcfour_ksa(&lopool_collapse, (void *)lopool_uhash,
		    sizeof(lopool_uhash));

		/* assert(lopool_uptr == 32); */
		while (lopool_uptr--)
			/* re-initialise all 32 BAFH states from RNG */
			lopool_uhash[lopool_uptr] = arc4random();

		/* sync statistic data / counter */
		lopool_content = 0;
		lopool_uptr = 0;

		/*
		 * note: we don't throw away the “early keystream” like
		 * with arc4random(9) because this is never used/exposed
		 * to anything save arc4random_reinit, and we don’t care
		 * about bias here either, this is just for distribution
		 */

		++rndstats.lopool_deq;
	}

	/* 1 + [0;2[ seconds */
	timeout_add(&rnd_lopool_timeout, hz + arc4random_uniform(hz << 1));

 out:
	splx(s);
}


void
randomattach(void)
{
	register uint32_t h;
	struct {
		uint32_t rs;
		unsigned char ie[16];
	} bootloader_entropy;

	if (rnd_attached) {
		RNDEBUG(RD_ALWAYS, "random: second attach\n");
		return;
	}

	timeout_set(&arc4random_timeout, arc4random_reinit, NULL);
	timeout_set(&rnd_lopool_timeout, rnd_lopool_dequeue, NULL);

	/* dev/rnd.c */
	rndpool_init();

	/* this dword is where also locore.s writes to */
	bootloader_entropy.rs = _randseed;
	memcpy(bootloader_entropy.ie, initial_entropy, 16);

	h = arc4random();
	BAFHUpdateMem_reg(h, &bootloader_entropy, sizeof(bootloader_entropy));
	BAFHFinish_reg(h);
	add_true_randomness(h);

	arcfour_init(&lopool_collapse);
	arcfour_ksa(&lopool_collapse,
	    (const void *)&bootloader_entropy, sizeof(bootloader_entropy));

	/* just in case there’s something actually using these */
	explicit_bzero(&bootloader_entropy, sizeof(bootloader_entropy));
	arc4random_buf(initial_entropy, 16);
	_randseed = arc4random();

	rnd_attached = 1;
	/* initialises both lopool and arc4random timeouts */
	rnd_flush();
}


/* called from RNDSTIRARC4 ioctl by pid 1, during boot and reboot */
void
rnd_flush(void)
{
	int s;

	RNDEBUG(RD_ALWAYS, "rnd: flushing\n");
	s = splhigh();
	if (lopool_content < 128)
		/* force rnd_lopool_dequeue() to act */
		lopool_content = 128;
	rnd_lopool_dequeue(NULL);
	arc4random_reinit(NULL);
	splx(s);
}
@


1.14
log
@save 3 bytes
@
text
@d4 2
a5 2
 * Copyright © 2010, 2011, 2014
 *	Thorsten Glaser <tg@@mirbsd.org>
d243 6
d260 9
d270 3
a272 8
	/* this dword is where also locore.s writes to */
	add_true_randomness(
	    ((uint32_t)initial_entropy[3] << 24) |
	    ((uint32_t)initial_entropy[2] << 16) |
	    ((uint32_t)initial_entropy[1] << 8) |
	    (uint32_t)initial_entropy[0]);
	memcpy(initial_entropy, &_randseed, 4);
	arcfour_ksa(&lopool_collapse, initial_entropy, 16);
d274 1
@


1.13
log
@antecedere
@
text
@d64 1
a64 1
int rnd_attached = 0;
@


1.12
log
@tweak initialisation and add comments

I’m now mostly happy with this, except that initial_entropy is the only
thing config(8) changes (can change, with our ABI, at the moment) and
is only folded into arc4random(9) after randomattach which is quite late.

If we need more speed, change the interrupt adds to write into a 16-byte
small buffer (plus counters) and enqueue them with HZ only, similar to
what tytso recently did in Linux. But, not now (not SMP anyway).
@
text
@d1 1
a1 1
/* $MirOS: src/sys/crypto/randcore.c,v 1.11 2014/02/19 22:17:25 tg Exp $ */
d116 1
a116 1
 * we used to be unable to run either lopool’s predecessor or
@


1.11
log
@reuse another 31 bit of entropy free’d by nuking random()/srandom()
@
text
@d1 1
a1 1
/* $MirOS: src/sys/crypto/randcore.c,v 1.10 2014/02/19 17:43:28 tg Exp $ */
d42 2
a44 1
extern uint32_t _randseed;
d220 1
d251 1
d255 1
d263 3
a269 4

	/* just in case there’s something actually using this */
	arc4random_buf(initial_entropy, 16);
	_randseed = arc4random();
d273 1
@


1.10
log
@replace OAAT, NZAT, NZAAT with BAFH in virtually all places; bump libc major
@
text
@d1 1
a1 1
/* $MirOS: src/sys/crypto/randcore.c,v 1.9 2011/07/18 13:11:07 tg Exp $ */
d43 1
a251 1
	arcfour_ksa(&lopool_collapse, initial_entropy + 4, 12);
d257 2
d266 1
@


1.9
log
@make the handling of uint8_t initial_entropy[16] (the one created
by newvers.sh and updated by config(8)) better and fix a typo

missing: bring its first octet into arc4random(9)'s state really
early, i.e. after the lomem hashing, but way before randomattach
(ideally before its first use)
@
text
@d1 1
a1 1
/* $MirOS: src/sys/crypto/randcore.c,v 1.8 2011/07/09 19:09:39 tg Exp $ */
d4 1
a4 1
 * Copyright © 2010, 2011
d39 1
a39 1
#include <nzat.h>
d75 3
a77 3
 * We use the NZAT hash transformation only for folding the user-
 * specified information into 32 NZAT hash states (128 bytes)
 * and count the bytes we added. (rnd_lopool_addh adds an NZAAT
d127 2
a128 2
	NZATUpdateMem(h, vp, n);
	NZAATFinish(h);
d205 1
a205 1
			NZAATFinish(lopool_uhash[lopool_uptr]);
d213 1
a213 1
			/* re-initialise all 32 NZAAT hashes from RNG */
@


1.8
log
@we don't use OAAT any more
@
text
@d1 1
a1 1
/* $MirOS: src/sys/crypto/randcore.c,v 1.7 2011/07/06 22:22:11 tg Exp $ */
d251 1
a251 1
	arcfour_ksa(&lopool_collapse, initial_entropy, 12);
d253 4
a256 4
	    ((uint32_t)initial_entropy[12] << 24) |
	    ((uint32_t)initial_entropy[13] << 16) |
	    ((uint32_t)initial_entropy[14] << 8) |
	    (uint32_t)initial_entropy[15]);
@


1.7
log
@replace uses of OAAT hash in all its variants by NZAT (mksh internal) or NZAAT (all others)
@
text
@d1 1
a1 1
/* $MirOS: src/sys/crypto/randcore.c,v 1.6 2011/02/19 14:41:39 tg Exp $ */
d75 2
a76 2
 * We use Bob Jenkins’ one-at-a-time hash only for folding the
 * user-specified information into 32 NZAAT hashes (128 bytes)
@


1.6
log
@• kernel: merge rnd_flush() declarations into <randimpl.h>
• randomioctl: let RNDSTIRARC4 invoke rnd_flush() if called from init(8)
• init, reboot/halt: use unified "pathnames.h"
• init: use RNDSTIRARC4 to reset all pools (lopool, arc4random) on halt
• init: write 2048 bytes to /var/db/host.random to make it an even 8 KiB
• init: redesign code for that, minimise sleep calls, tested with tempo-
  rary printf/warning/etc. calls in userspace and kernel
• init: upon SIGTSTP, invoke RNDSTIRARC4 to help halt/reboot
• halt/reboot: do similar things like init wrt. signals, output, seed file
@
text
@d1 1
a1 1
/* $MirOS: src/sys/crypto/randcore.c,v 1.5 2010/09/25 11:33:17 tg Exp $ */
d4 1
a4 1
 * Copyright © 2010
d39 1
d76 2
a77 2
 * user-specified information into 32 oaat hashes (128 bytes)
 * and count the bytes we added. (rnd_lopool_addh adds an oaat
d126 3
a128 4
	do {
		h = arc4random() & 0xFFFFFF00;
	} while (!h);
	h = OAAT0Final(OAAT0Update(h, vp, n));
d205 1
a205 2
			lopool_uhash[lopool_uptr] =
			    OAAT0Final(lopool_uhash[lopool_uptr]);
d213 2
a214 5
			/* re-initialise all 32 oaat hashes from RNG */
			do {
				lopool_uhash[lopool_uptr] =
				    arc4random() & 0xFFFFFF00;
			} while (!lopool_uhash[lopool_uptr]);
@


1.5
log
@oops, changed the wrong call in 1004C9D0B38596B6444
@
text
@d1 1
a1 1
/* $MirOS: src/sys/crypto/randcore.c,v 1.4 2010/09/24 20:35:13 tg Exp $ */
a54 1
void rnd_flush(void);
@


1.4
log
@count feedback from the arc4random/lopool-collapse combined result
only as 24 bits, not 31, for the doubleword, to balance inputs better
@
text
@d1 1
a1 1
/* $MirOS: src/sys/crypto/randcore.c,v 1.3 2010/09/24 19:59:08 tg Exp $ */
d257 1
a257 1
	enqueue_randomness(RND_SRC_LPC, (int)(
d261 1
a261 1
	    (uint32_t)initial_entropy[15]));
@


1.3
log
@• move rstat from bits to bytes (except distribution, of course)
• re-use RND_SRC_AUDIO for video and rename it RND_SRC_AUVIS
• switch to using add_auvis_entropy() in MirBSD code
• let RND_SRC_IMACS take up former RND_SRC_VIDEO’s place in statistics
• keep statistics for lopool en- and dequeues as well
• let rstat look ok also on 80x24 terminal
@
text
@d1 1
a1 1
/* $MirOS: src/sys/crypto/randcore.c,v 1.2 2010/09/21 17:42:51 tg Exp $ */
d257 5
a261 3
	add_true_randomness((initial_entropy[12] << 24) |
	    (initial_entropy[13] << 16) | (initial_entropy[14] << 8) |
	    initial_entropy[15]);
@


1.2
log
@better names
@
text
@d1 1
a1 1
/* $MirOS: src/sys/crypto/randcore.c,v 1.1 2010/09/19 18:55:33 tg Exp $ */
d107 2
d230 2
@


1.1
log
@the promised new RNG (play with RNDEBUG in crypto/randimpl.h to make
it verbose; I did, for a while and a bit of fine-tuning)
@
text
@d1 1
a1 1
/* $MirOS: src/share/misc/licence.template,v 1.28 2008/11/14 15:33:44 tg Rel $ */
d77 1
a77 1
 * and count the bytes we added. (rnd_bootpool_add adds an oaat
d119 1
a119 1
rnd_bootpool_add(const void *vp, size_t n)
@

