head	1.10;
access;
symbols;
locks; strict;
comment	@ * @;


1.10
date	2019.08.25.22.20.50;	author tg;	state Exp;
branches;
next	1.9;
commitid	1005D63096C6637033A;

1.9
date	2016.08.23.13.48.02;	author tg;	state Exp;
branches;
next	1.8;
commitid	10057BC542A2B3595E2;

1.8
date	2014.03.13.06.09.48;	author tg;	state Exp;
branches;
next	1.7;
commitid	10053214BA25A4D9779;

1.7
date	2014.03.13.06.07.38;	author tg;	state Exp;
branches;
next	1.6;
commitid	10053214B1F286D6B90;

1.6
date	2014.01.11.18.16.16;	author tg;	state Exp;
branches;
next	1.5;
commitid	10052D18A8038CC3F4D;

1.5
date	2012.10.19.18.59.41;	author tg;	state Exp;
branches;
next	1.4;
commitid	1005081A33215C2F05A;

1.4
date	2010.12.23.19.25.31;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004D13A2417F2232C8;

1.3
date	2010.10.01.16.21.16;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004CA60A46560D4DA5;

1.2
date	2010.09.25.11.33.17;	author tg;	state Exp;
branches;
next	1.1;
commitid	1004C9DDE155213E77F;

1.1
date	2010.09.19.18.55.33;	author tg;	state Exp;
branches;
next	;
commitid	1004C965C8F46717878;


desc
@@


1.10
log
@fix initial_entropy and _randseed reading:
• use the latter for locore
• concatenate them for randomattach, hash for enqueue_randomness
• switch to explicit_bzero in many places
@
text
@/* $MirOS: src/sys/crypto/arc4random.c,v 1.9 2016/08/23 13:48:02 tg Exp $ */

/*-
 * Copyright © 2010, 2014, 2016, 2019
 *	mirabilos <m@@mirbsd.org>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un‐
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided “AS IS” and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person’s immediate fault when using the work as intended.
 *-
 * Always working arc4random(9) implementation; the arcfour state has
 * been initialised at kernel compile time by newvers.sh for us. Once
 * the random device has attached, arc4random_reinit() will be called
 * from a timeout, or when enough bytes are consumed, and restir with
 * entropy from both the rndpool and the lopool.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/timeout.h>
#include <crypto/randimpl.h>

/* import from random.c */
extern struct timeout arc4random_timeout;
extern struct arcfour_status lopool_collapse;

/* import from vers.c generated by conf/newvers.sh */
extern struct arcfour_status initial_arc4random;

size_t arc4random_count = 0;

/*
 * 8 MiB seems like a sane limit to protect against reading
 * enough stream cipher output to try and attack the key
 */
#ifndef ARC4RANDOM_MAXBYTES
#define ARC4RANDOM_MAXBYTES	(8 * 1048576)
#endif

u_int32_t
arc4random(void)
{
	uint32_t v;
	int s;

	s = splhigh();

	rndstats.arc4_reads += 4;
	if (arc4random_count >= ARC4RANDOM_MAXBYTES - 4)
		arc4random_reinit(NULL);
	arc4random_count += 4;

	/* skip an output byte randomly for whitening */
	if ((arcfour_byte(&lopool_collapse) & 1))
		(void)arcfour_byte(&initial_arc4random);

	v = ((uint32_t)arcfour_byte(&initial_arc4random) << 24) |
	    ((uint32_t)arcfour_byte(&initial_arc4random) << 16) |
	    ((uint32_t)arcfour_byte(&initial_arc4random) << 8) |
	    ((uint32_t)arcfour_byte(&initial_arc4random));

	splx(s);
	return (v);
}

void
arc4random_buf(void *buf_, size_t len)
{
	size_t n;
	uint8_t *buf = (uint8_t *)buf_;
	int s;

	if (!len)
		return;
	s = splhigh();
	rndstats.arc4_reads += len;
	goto into_the_loop;

	/* operate in chunks of 128 output bytes to give interrupts a chance */
	while (len) {
		s = splhigh();
 into_the_loop:
		/* skip a few output bytes randomly for whitening */
		n = arcfour_byte(&lopool_collapse) & 3;
		while (n--)
			(void)arcfour_byte(&initial_arc4random);

		n = min(len, 128);
		len -= n;

		/*
		 * using 128 here, not n, to speed up; the difference
		 * is not worth mentioning, and it’s also more secure
		 */
		if (arc4random_count >= (ARC4RANDOM_MAXBYTES - 128))
			arc4random_reinit(NULL);
		arc4random_count += n;

		while (n--)
			*buf++ = arcfour_byte(&initial_arc4random);

		splx(s);
	}
}

/*
 * Stir the arcfour state used by arc4random(9). This function is
 * called via a periodic timeout (approximately every 8½ minutes)
 * as well as from a consumer when approx. 8 MiB were used up.
 */
void
arc4random_reinit(void *arg __unused)
{
	size_t n;
	struct {
		uint8_t chars[192];
		struct timeval tv;
	} buf;
	int s;

	s = splhigh();

	if (!rnd_attached) {
		RNDEBUG(RD_ALWAYS, "rnd: reinit before attach\n");
		goto out;
	}

	/* if we were called directly instead of from timeout */
	timeout_del(&arc4random_timeout);

	/* half the poolbits, minimum 8, maximum 128 bytes */
	n = max(8, min(128, (random_state.entropy_count / 16)));
	rndstats.arc4_stirs += n;

	RNDEBUG(RD_ARC4RANDOM, "rnd: reinit at %lu with %lu bytes\n",
	    (u_long)arc4random_count, (u_long)n);
	get_random_bytes(buf.chars, n);

	while (n < 192)
		buf.chars[n++] = arcfour_byte(&lopool_collapse);
	buf.tv.tv_sec = mono_time.tv_sec;
	buf.tv.tv_usec = mono_time.tv_usec;
	/* carry over */
	n = arcfour_byte(&initial_arc4random) & 7;
	/* re-key */
	arcfour_ksa(&initial_arc4random, (void *)&buf, sizeof(buf));
	arc4random_count = 0;
	++rndstats.arc4_nstirs;

	/*
	 * skip early keystream for security,
	 * plus a random amount for whitening
	 */
	n += 256 * 12 +
	    (arcfour_byte(&lopool_collapse) & 7) +
	    (arcfour_byte(&initial_arc4random) & 7);
	while (n--)
		(void)arcfour_byte(&initial_arc4random);

	/* contribute our (lopool,rndpool,arc4pool) result */
	n = ((uint32_t)arcfour_byte(&initial_arc4random) << 24) |
	    ((uint32_t)arcfour_byte(&initial_arc4random) << 16) |
	    ((uint32_t)arcfour_byte(&initial_arc4random) << 8) |
	    ((uint32_t)arcfour_byte(&initial_arc4random));
	enqueue_randomness(RND_SRC_LPC, (int)n);
	n = (arcfour_byte(&initial_arc4random) & 3) +
	    (arcfour_byte(&lopool_collapse) & 3);
	while (n--)
		(void)arcfour_byte(&initial_arc4random);

	/* zero out temp. key buffer */
	explicit_bzero(&buf, sizeof(buf));

	/* call us again in approx. 8½ minutes, minus [0‥32[ seconds */
	timeout_add(&arc4random_timeout,
	    (hz << 9) - arc4random_uniform(hz << 5));

 out:
	splx(s);
}
@


1.9
log
@reduce max amount of bytes an arc4random_buf(3|9) caller can get even more
@
text
@d1 1
a1 1
/* $MirOS: src/sys/crypto/arc4random.c,v 1.8 2014/03/13 06:09:48 tg Exp $ */
d4 1
a4 1
 * Copyright © 2010, 2014, 2016
d184 1
a184 1
	bzero(&buf, sizeof(buf));
@


1.8
log
@use the lopool_collapse to decide how much to skip from the main arc4 pool
(gives us better dynamicity as the former is repooled every second if needed)
@
text
@d1 1
a1 1
/* $MirOS: src/sys/crypto/arc4random.c,v 1.6 2014/01/11 18:16:16 tg Exp $ */
d4 2
a5 2
 * Copyright © 2010, 2014
 *	Thorsten Glaser <tg@@mirbsd.org>
d91 1
a91 1
	/* operate in chunks of 256 output bytes to give interrupts a chance */
d100 1
a100 1
		n = min(len, 256);
d104 1
a104 1
		 * using 256 here, not n, to speed up; the difference
d107 1
a107 1
		if (arc4random_count >= (ARC4RANDOM_MAXBYTES - 256))
@


1.7
log
@fix comment

XXX consider reiniting arc4random(9) double so often, maybe?
XXX maybe if the pool is full or sth…
@
text
@d65 2
a66 2
	/* skip 1‥2 output bytes randomly for whitening */
	if ((arcfour_byte(&initial_arc4random) & 1))
d95 2
a96 2
		/* skip 1‥4 output bytes randomly for whitening */
		n = arcfour_byte(&initial_arc4random) & 3;
@


1.6
log
@there is precisely zero reason to use random()/srandom() even in the kernel (since we initialise arc4random statically)
@
text
@d1 1
a1 1
/* $MirOS: src/sys/crypto/arc4random.c,v 1.5 2012/10/19 18:59:41 tg Exp $ */
d121 1
a121 1
 * as well as from a consumer when approx. 2 MiB were used up.
@


1.5
log
@The arc4random code in libevent suggests to look at the papers in more
detail and skip 256 * 12 bytes (plus fuzz) instead of 256 * 4 bytes
@
text
@d1 1
a1 1
/* $MirOS: src/sys/crypto/arc4random.c,v 1.4 2010/12/23 19:25:31 tg Exp $ */
d4 1
a4 1
 * Copyright © 2010
d166 1
a166 1
	n += 256 * 12 + (random() & 7) +
@


1.4
log
@fast-forward through OpenBSD-current RNG:
src/sys/dev/rnd.c,v 1.105
src/lib/libc/crypt/arc4random.c,v 1.22
this fixes some small issues. also, optimise a little and correct comments.
@
text
@d1 1
a1 1
/* $MirOS: src/sys/crypto/arc4random.c,v 1.3 2010/10/01 16:21:16 tg Exp $ */
d166 1
a166 1
	n += 256 * 4 + (random() & 7) +
@


1.3
log
@8 MiB is reasonable enough, because the normal use case would have the
arc4random restirs happen from the timeout, not from the limit on read
bytes; make ARC4RANDOM_MAXBYTES configurable though (just in case)
@
text
@d1 1
a1 1
/* $MirOS: src/sys/crypto/arc4random.c,v 1.2 2010/09/25 11:33:17 tg Exp $ */
d66 1
a66 2
	v = arcfour_byte(&initial_arc4random) & 1;
	while (v--)
@


1.2
log
@oops, changed the wrong call in 1004C9D0B38596B6444
@
text
@d1 1
a1 1
/* $MirOS: src/sys/crypto/arc4random.c,v 1.1 2010/09/19 18:55:33 tg Exp $ */
d45 1
a45 1
 * 4 MiB seems like a sane limit to protect against reading
d48 3
a50 1
#define ARC4RANDOM_MAXBYTES	(4 * 1048576)
@


1.1
log
@the promised new RNG (play with RNDEBUG in crypto/randimpl.h to make
it verbose; I did, for a while and a bit of fine-tuning)
@
text
@d1 1
a1 1
/* $MirOS: src/share/misc/licence.template,v 1.28 2008/11/14 15:33:44 tg Rel $ */
d176 1
a176 1
	add_true_randomness(n);
@

