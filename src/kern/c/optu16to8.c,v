head	1.3;
access;
symbols;
locks; strict;
comment	@ * @;


1.3
date	2014.02.09.22.35.51;	author tg;	state Exp;
branches;
next	1.2;
commitid	10052F802DB25EB293D;

1.2
date	2008.11.22.09.02.33;	author tg;	state Exp;
branches;
next	1.1;
commitid	1004927CA84091CE619;

1.1
date	2008.08.01.23.24.01;	author tg;	state Exp;
branches;
next	;
commitid	10048939B085B2C5840;


desc
@@


1.3
log
@nuke the restrict qualifiers; C99 says this makes no externally visible difference and is only a compiler hint and a limitation to the interface implementor
@
text
@/*-
 * Copyright (c) 2008
 *	Thorsten Glaser <tg@@mirbsd.org>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 *
 * The author reserves the right to steward the OPTU encoding forms.
 *-
 * Note: this only works because OPTU is the *only* available locale.
 */

#include <libckern.h>
#ifdef _KERN_HOSTED
#include <errno.h>
#endif

__RCSID("$MirOS: src/kern/c/optu16to8.c,v 1.2 2008/11/22 09:02:33 tg Exp $");

#ifdef _KERN_HOSTED
static size_t _optu16to8(uint8_t *, wchar_t, mbstate_t *);

size_t
wcrtomb(char *s, wchar_t wc, mbstate_t *ps)
{
	static mbstate_t w_state = { 0, 0 };

	return (_optu16to8((uint8_t *)s, wc, ps ? ps : &w_state));
}
#endif

size_t
optu16to8(char *s, wchar_t wc, mbstate_t *ps)
{
	static mbstate_t o_state = { 0, 0 };

#ifdef _KERN_HOSTED
	return (_optu16to8((uint8_t *)s, wc, ps ? ps : &o_state));
}

static size_t
_optu16to8(uint8_t *s, wchar_t wc, mbstate_t *ps)
{
#endif
	uint8_t count, *src = (uint8_t *)s;

#ifndef _KERN_HOSTED
	if (__predict_false(ps == NULL))
		ps = &o_state;
#endif

	if ((count = ps->count) == 3) {
#ifdef _KERN_HOSTED
		errno = EINVAL;
#endif
		return ((size_t)(-1));
	}

	if (__predict_false(s == NULL)) {
		ps->count = 0;
		return (count + 1);
	}

	while (__predict_false(count)) {
		/* process any remnants from previous conversion state */
		*s++ = ((ps->value >> (6 * --count)) & 0x3F) | 0x80;
	}

	if (__predict_false(wc > WCHAR_MAX)) {
#ifdef _KERN_HOSTED
		errno = EILSEQ;
#endif
		return ((size_t)(-1));
	} else if (__predict_true(wc < 0x80 || iswoctet(wc))) {
		/* count is already 0 */
		*s++ = wc & 0xFF;
	} else if (wc < 0x0800) {
		count = 1;
		*s++ = (wc >> 6) | 0xC0;
	} else {
		count = 2;
		*s++ = (wc >> 12) | 0xE0;
	}

	while (__predict_false(count)) {
		*s++ = ((wc >> (6 * --count)) & 0x3F) | 0x80;
	}
	ps->count = 0;
	return ((size_t)((uint8_t *)s - src));
}
@


1.2
log
@new macro: iswoctet(3)

use of this macro also fixes a bug in optu8to16vis(3) which could
errorneously map 0xFF80…0xFFFF wide characters to raw octets
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/kern/c/optu16to8.c,v 1.1 2008/08/01 23:24:01 tg Exp $");
d33 1
a33 1
static size_t _optu16to8(uint8_t * restrict, wchar_t, mbstate_t * restrict);
d36 1
a36 1
wcrtomb(char * restrict s, wchar_t wc, mbstate_t * restrict ps)
d40 1
a40 1
	return (_optu16to8((uint8_t * restrict)s, wc, ps ? ps : &w_state));
d45 1
a45 1
optu16to8(char * restrict s, wchar_t wc, mbstate_t * restrict ps)
d50 1
a50 1
	return (_optu16to8((uint8_t * restrict)s, wc, ps ? ps : &o_state));
d54 1
a54 1
_optu16to8(uint8_t * restrict s, wchar_t wc, mbstate_t * restrict ps)
@


1.1
log
@• OPTU-8 ⇐⇒ OPTU-16 conversion routines (libc, kernel, !bootloader)
• optu16to8(3) replaces wcrtomb(3) in libc
@
text
@d30 1
a30 1
__RCSID("$MirOS$");
d86 1
a86 1
	} else if (__predict_true(wc < 0x80 || (wc & 0xFF80) == 0xEF80)) {
@

