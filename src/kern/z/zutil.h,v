head	1.12;
access;
symbols
	zlib-1_2_8:1.1.117.2
	MIRBSD_10:1.1.117.1.0.2
	MIRBSD_10_BASE:1.1.117.1
	zlib-1_2_3:1.1.117.1
	libz:1.1.117;
locks; strict;
comment	@ * @;


1.12
date	2013.10.31.20.06.14;	author tg;	state Exp;
branches;
next	1.11;
commitid	1005272B7081B0E5655;

1.11
date	2013.09.10.21.24.18;	author tg;	state Exp;
branches;
next	1.10;
commitid	100522F8E1B1B771E75;

1.10
date	2013.09.10.21.14.00;	author tg;	state Exp;
branches;
next	1.9;
commitid	100522F8BB01BF7E561;

1.9
date	2013.08.06.17.13.06;	author tg;	state Exp;
branches;
next	1.8;
commitid	10052012E9F67D27FA9;

1.8
date	2013.08.05.21.27.36;	author tg;	state Exp;
branches;
next	1.7;
commitid	100520018AA4F2BDEB7;

1.7
date	2010.09.21.17.53.03;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004C98F10B2881757C;

1.6
date	2010.09.12.17.25.12;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004C8D0CFC67848FA7;

1.5
date	2010.01.14.10.35.06;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004B4EF3714CE901BC;

1.4
date	2009.10.04.16.49.42;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004AC8D234283AB203;

1.3
date	2008.08.01.15.12.13;	author tg;	state Exp;
branches;
next	1.2;
commitid	100489327E0712F419E;

1.2
date	2008.04.10.20.57.03;	author tg;	state Exp;
branches;
next	1.1;
commitid	10047FE7F3355317E49;

1.1
date	2007.02.06.20.09.46;	author tg;	state Exp;
branches
	1.1.117.1;
next	;
commitid	10045C8E09012013E61;

1.1.117.1
date	2007.02.06.20.09.46;	author tg;	state Exp;
branches;
next	1.1.117.2;
commitid	10045C8E09012013E61;

1.1.117.2
date	2013.08.05.19.24.25;	author tg;	state Exp;
branches;
next	;
commitid	10051FFFBFC7B2E5803;


desc
@@


1.12
log
@adapt most __attribute__((…)) occurrences to new KNF style(9)
@
text
@/* $MirOS: src/kern/z/zutil.h,v 1.11 2013/09/10 21:24:18 tg Exp $ */

/* zutil.h -- internal interface and configuration of the compression library
 * Copyright © 2013
 *	Thorsten “mirabilos” Glaser <tg@@mirbsd.org>
 * Copyright (C) 1995-2013 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* @@(#) $Id$ */

#ifndef ZUTIL_H
#define ZUTIL_H

#if defined(__unix__)
#include <sys/param.h>
#endif

#ifdef HAVE_HIDDEN
#  define ZLIB_INTERNAL __attribute__((__visibility__("hidden")))
#else
#  define ZLIB_INTERNAL
#endif

#include "zlib.h"

#undef zRCSID
#if defined(_STANDALONE)
#  include <stand.h>
#  include <sys/stddef.h>
#  define zRCSID(x)	/* nothing */
#  define NO_ERRNO_H
#elif defined(_KERNEL)
#  include <sys/systm.h>
#  include <sys/stddef.h>
#  include <dev/rndvar.h>
#  define zRCSID(x)	/* nothing */
#  define NO_ERRNO_H
#elif defined(STDC) && !defined(Z_SOLO)
#  if !(defined(_WIN32_WCE) && defined(_MSC_VER))
#    include <stddef.h>
#  endif
#  include <string.h>
#  include <stdlib.h>
#  define zRCSID(x)	__RCSID(x);
#endif

#ifdef Z_SOLO
   typedef long ptrdiff_t;  /* guess -- will be caught if guess is wrong */
#endif

#ifndef local
#  define local static
#endif
/* compile with -Dlocal if your debugger can't find static symbols */

typedef unsigned char  uch;
typedef uch FAR uchf;
typedef unsigned short ush;
typedef ush FAR ushf;
typedef unsigned long  ulg;

extern z_const char * const z_errmsg[10]; /* indexed by 2-zlib_error */
/* (size given to avoid silly warnings with Visual C++) */

#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]

#define ERR_RETURN(strm,err) \
  return (strm->msg = ERR_MSG(err), (err))
/* To be used only when the state is known to be valid */

        /* common constants */

#ifndef DEF_WBITS
#  define DEF_WBITS MAX_WBITS
#endif
/* default windowBits for decompression. MAX_WBITS is for compression only */

#if MAX_MEM_LEVEL >= 8
#  define DEF_MEM_LEVEL 8
#else
#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
#endif
/* default memLevel */

#define STORED_BLOCK 0
#define STATIC_TREES 1
#define DYN_TREES    2
/* The three kinds of block type */

#define MIN_MATCH  3
#define MAX_MATCH  258
/* The minimum and maximum match lengths */

#define PRESET_DICT 0x20 /* preset dictionary flag in zlib header */

        /* target dependencies */

#if defined(MSDOS) || (defined(WINDOWS) && !defined(WIN32))
#  define OS_CODE  0x00
#  ifndef Z_SOLO
#    if defined(__TURBOC__) || defined(__BORLANDC__)
#      if (__STDC__ == 1) && (defined(__LARGE__) || defined(__COMPACT__))
         /* Allow compilation with ANSI keywords only enabled */
         void _Cdecl farfree( void *block );
         void *_Cdecl farmalloc( unsigned long nbytes );
#      else
#        include <alloc.h>
#      endif
#    else /* MSC or DJGPP */
#      include <malloc.h>
#    endif
#  endif
#endif

#ifdef AMIGA
#  define OS_CODE  0x01
#endif

#if defined(VAXC) || defined(VMS)
#  define OS_CODE  0x02
#  define F_OPEN(name, mode) \
     fopen((name), (mode), "mbc=60", "ctx=stm", "rfm=fix", "mrs=512")
#endif

#if defined(ATARI) || defined(atarist)
#  define OS_CODE  0x05
#endif

#ifdef OS2
#  define OS_CODE  0x06
#  if defined(M_I86) && !defined(Z_SOLO)
#    include <malloc.h>
#  endif
#endif

#if defined(MACOS) || defined(TARGET_OS_MAC)
#  define OS_CODE  0x07
#  ifndef Z_SOLO
#    if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
#      include <unix.h> /* for fdopen */
#    else
#      ifndef fdopen
#        define fdopen(fd,mode) NULL /* No fdopen() */
#      endif
#    endif
#  endif
#endif

#ifdef TOPS20
#  define OS_CODE  0x0a
#endif

#ifdef WIN32
#  ifndef __CYGWIN__  /* Cygwin is Unix, not Win32 */
#    define OS_CODE  0x0b
#  endif
#endif

#ifdef __50SERIES /* Prime/PRIMOS */
#  define OS_CODE  0x0f
#endif

#if defined(_BEOS_) || defined(RISCOS)
#  define fdopen(fd,mode) NULL /* No fdopen() */
#endif

#if (defined(_MSC_VER) && (_MSC_VER > 600)) && !defined __INTERIX
#  if defined(_WIN32_WCE)
#    define fdopen(fd,mode) NULL /* No fdopen() */
#    ifndef _PTRDIFF_T_DEFINED
       typedef int ptrdiff_t;
#      define _PTRDIFF_T_DEFINED
#    endif
#  else
#    define fdopen(fd,type)  _fdopen(fd,type)
#  endif
#endif

#if defined(__BORLANDC__) && !defined(MSDOS)
  #pragma warn -8004
  #pragma warn -8008
  #pragma warn -8066
#endif

/* provide prototypes for these when building zlib without LFS */
#if !defined(_WIN32) && \
    (!defined(_LARGEFILE64_SOURCE) || _LFS64_LARGEFILE-0 == 0)
    ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));
    ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));
#endif

        /* common defaults */

#ifndef OS_CODE
#  define OS_CODE  0x03  /* assume Unix */
#endif

#ifndef F_OPEN
#  define F_OPEN(name, mode) fopen((name), (mode))
#endif

         /* functions */

#if defined(pyr) || defined(Z_SOLO)
#  define NO_MEMCPY
#endif
#if defined(SMALL_MEDIUM) && !defined(_MSC_VER) && !defined(__SC__)
 /* Use our own functions for small and medium model with MSC <= 5.0.
  * You may have to use the same strategy for Borland C (untested).
  * The __SC__ check is for Symantec.
  */
#  define NO_MEMCPY
#endif
#if defined(STDC) && !defined(HAVE_MEMCPY) && !defined(NO_MEMCPY)
#  define HAVE_MEMCPY
#endif
#if defined(_KERNEL)
#  define zmemcpy	memmove
#  define zmemcmp	memcmp
#  define zmemzero	bzero
#elif defined(BSD)
#  define zmemcpy	memcpy
#  define zmemcmp	memcmp
#  define zmemzero	bzero
#elif defined(__unix__)
#  define zmemcpy	memcpy
#  define zmemcmp	memcmp
#  define zmemzero(d,l)	memset((d), '\0', (l))
#elif defined(HAVE_MEMCPY)
#  ifdef SMALL_MEDIUM /* MSDOS small or medium model */
#    define zmemcpy _fmemcpy
#    define zmemcmp _fmemcmp
#    define zmemzero(dest, len) _fmemset(dest, 0, len)
#  else
#    define zmemcpy memcpy
#    define zmemcmp memcmp
#    define zmemzero(dest, len) memset(dest, 0, len)
#  endif
#else
   void ZLIB_INTERNAL zmemcpy OF((Bytef* dest, const Bytef* source, uInt len));
   int ZLIB_INTERNAL zmemcmp OF((const Bytef* s1, const Bytef* s2, uInt len));
   void ZLIB_INTERNAL zmemzero OF((Bytef* dest, uInt len));
#endif

/* Diagnostic functions */
#if defined(DEBUG) && !defined(ZLIB_FREESTANDING)
#  include <stdio.h>
   extern int ZLIB_INTERNAL z_verbose;
   extern void ZLIB_INTERNAL z_error OF((char *m));
#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
#  define Trace(x) {if (z_verbose>=0) fprintf x ;}
#  define Tracev(x) {if (z_verbose>0) fprintf x ;}
#  define Tracevv(x) {if (z_verbose>1) fprintf x ;}
#  define Tracec(c,x) {if (z_verbose>0 && (c)) fprintf x ;}
#  define Tracecv(c,x) {if (z_verbose>1 && (c)) fprintf x ;}
#else
#  define Assert(cond,msg)
#  define Trace(x)
#  define Tracev(x)
#  define Tracevv(x)
#  define Tracec(c,x)
#  define Tracecv(c,x)
#endif

#ifndef Z_SOLO
   voidpf ZLIB_INTERNAL zcalloc OF((voidpf opaque, unsigned items,
                                    unsigned size));
   void ZLIB_INTERNAL zcfree  OF((voidpf opaque, voidpf ptr));
#endif

#define ZALLOC(strm, items, size) \
           (*((strm)->zalloc))((strm)->opaque, (items), (size))
#define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr))
#define TRY_FREE(s, p) {if (p) ZFREE(s, p);}

/* Reverse the bytes in a 32-bit value */
#define ZSWAP32(q) ((((q) >> 24) & 0xff) + (((q) >> 8) & 0xff00) + \
                    (((q) & 0xff00) << 8) + (((q) & 0xff) << 24))

#if defined(ZLIB_NO_ADLERPUSH) || defined(ZLIB_NO_CRC32PUSH)
#define zADDRND(x)	/* nothing */
#elif defined(_STANDALONE)
#define zADDRND(x)	/* nothing */
#elif defined(_KERNEL)
#define zADDRND(x)	rnd_lopool_addv(x)
#elif defined(arc4random_pushb_fast)
/* user-space, with new, faster functions */
#define zADDRND(x)	arc4random_pushb_fast(&x, sizeof(x))
#else
/* user-space, old arc4random API which was too slow */
#define zADDRND(x)	/* nothing */
#endif

#endif /* ZUTIL_H */
@


1.11
log
@move <stddef.h> to <sys/stddef.h>
@
text
@d1 1
a1 1
/* $MirOS: src/kern/z/zutil.h,v 1.10 2013/09/10 21:14:00 tg Exp $ */
d4 2
d25 1
a25 1
#  define ZLIB_INTERNAL __attribute__((visibility ("hidden")))
@


1.10
log
@<stddef.h> is safe, even for kernel and bootloader… and needed, apparently
@
text
@d1 1
a1 1
/* $MirOS: src/kern/z/zutil.h,v 1.9 2013/08/06 17:13:06 tg Exp $ */
d33 1
a33 1
#  include <stddef.h>
d38 1
a39 1
#  include <stddef.h>
@


1.9
log
@bootloader (-DSMALL) doesn’t deflate nor compile zutil.c
so it’s fine to move that stuff back to inflate code only
@
text
@d1 1
a1 1
/* $MirOS: src/kern/z/zutil.h,v 1.8 2013/08/05 21:27:36 tg Exp $ */
d33 1
d39 1
@


1.8
log
@begin updating zlib

XXX ZCONST is gone, check the tree for it
XXX textproc/libxml* need updates, says zlib upstream
@
text
@d1 1
a1 1
/* $MirOS: src/kern/z/zutil.h,v 1.7 2010/09/21 17:53:03 tg Exp $ */
a68 4
#ifdef SMALL
#define ERR_RETURN(strm,err) \
  return (strm->msg = "error", (err))
#else
a70 1
#endif
a295 7
#ifdef SMALL
ZEXTERN const char zERRMSG[];
#define zSETSMSG(x)	strm->msg = zERRMSG
#else
#define zSETSMSG(x)	strm->msg = x
#endif

@


1.7
log
@now that I’m done, re-enable zADDRND in-kernel as well
@
text
@d1 1
a1 1
/* $MirOS: src/kern/z/zutil.h,v 1.6 2010/09/12 17:25:12 tg Exp $ */
d4 1
a4 1
 * Copyright (C) 1995-2005 Jean-loup Gailly.
d13 2
d22 6
a27 1
#define ZLIB_INTERNAL
d40 2
a41 2
#elif defined(STDC)
#  ifndef _WIN32_WCE
d48 3
a50 16
#ifdef NO_ERRNO_H
#   ifdef _WIN32_WCE
      /* The Microsoft C Run-Time Library for Windows CE doesn't have
       * errno.  We define it as a global variable to simplify porting.
       * Its value is always 0 and should not be used.  We rename it to
       * avoid conflict with other libraries that use the same workaround.
       */
#     define errno z_errno
#   endif
# ifndef _SYS_ERRNO_H_
    extern int errno;
# endif
#else
#  ifndef _WIN32_WCE
#    include <errno.h>
#  endif
d64 1
a64 1
extern const char * const z_errmsg[10]; /* indexed by 2-zlib_error */
d69 4
d75 1
d107 11
a117 7
#  if defined(__TURBOC__) || defined(__BORLANDC__)
#    if(__STDC__ == 1) && (defined(__LARGE__) || defined(__COMPACT__))
       /* Allow compilation with ANSI keywords only enabled */
       void _Cdecl farfree( void *block );
       void *_Cdecl farmalloc( unsigned long nbytes );
#    else
#      include <alloc.h>
a118 2
#  else /* MSC or DJGPP */
#    include <malloc.h>
d138 2
a139 2
#  ifdef M_I86
     #include <malloc.h>
d145 7
a151 5
#  if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
#    include <unix.h> /* for fdopen */
#  else
#    ifndef fdopen
#      define fdopen(fd,mode) NULL /* No fdopen() */
d174 1
a174 1
#if (defined(_MSC_VER) && (_MSC_VER > 600))
d186 13
d211 1
a211 34
#if defined(STDC99) || (defined(__TURBOC__) && __TURBOC__ >= 0x550)
#  ifndef HAVE_VSNPRINTF
#    define HAVE_VSNPRINTF
#  endif
#endif
#if defined(__CYGWIN__)
#  ifndef HAVE_VSNPRINTF
#    define HAVE_VSNPRINTF
#  endif
#endif
#ifndef HAVE_VSNPRINTF
#  ifdef MSDOS
     /* vsnprintf may exist on some MS-DOS compilers (DJGPP?),
        but for now we just assume it doesn't. */
#    define NO_vsnprintf
#  endif
#  ifdef __TURBOC__
#    define NO_vsnprintf
#  endif
#  ifdef WIN32
     /* In Win32, vsnprintf is available as the "non-ANSI" _vsnprintf. */
#    if !defined(vsnprintf) && !defined(NO_vsnprintf)
#      define vsnprintf _vsnprintf
#    endif
#  endif
#  ifdef __SASC
#    define NO_vsnprintf
#  endif
#endif
#ifdef VMS
#  define NO_vsnprintf
#endif

#if defined(pyr)
d247 3
a249 3
   extern void zmemcpy  OF((Bytef* dest, const Bytef* source, uInt len));
   extern int  zmemcmp  OF((const Bytef* s1, const Bytef* s2, uInt len));
   extern void zmemzero OF((Bytef* dest, uInt len));
d255 2
a256 2
   extern int z_verbose;
   extern void z_error    OF((char *m));
d272 5
a276 3

voidpf zcalloc OF((voidpf opaque, unsigned items, unsigned size));
void   zcfree  OF((voidpf opaque, voidpf ptr));
d283 4
d301 7
@


1.6
log
@now that we have arc4random_pushb_fast, bring back but optimise zADDRND()
@
text
@d1 1
a1 1
/* $MirOS: src/kern/z/zutil.h,v 1.4 2009/10/04 16:49:42 tg Exp $ */
d30 1
d303 1
a303 1
#define zADDRND(x)	/* nothing, for now */
@


1.5
log
@Remove zADDRND() – this cuts down 'zgrep -F sshd messages.0.gz' time for
the following file on an IBM X40 (1.4 GHz Pentium-M) dramatically:
    0m7.24s real     0m4.01s user     0m3.23s system
    0m0.10s real     0m0.10s user     0m0.00s system
method  crc      date   time  compressed  uncompressed  ratio  uncompressed_name
deflate e87edc2a Jan 14 09:00      57182        446614  87.2%  messages.0

I don’t know why this is so critical a code path, but the sheer amount
of saved CPU time (both user and system) is worth the loss.
@
text
@d297 14
@


1.4
log
@more nonsensical code cleanup, I give up, this is horrid
@
text
@d1 1
a1 1
/* $MirOS: src/kern/z/zutil.h,v 1.3 2008/08/01 15:12:13 tg Exp $ */
a296 17
#if defined(ZLIB_NO_ADLERPUSH) || defined(ZLIB_NO_CRC32PUSH)
#define zADDRND(x)	/* nothing */
#elif defined(_STANDALONE)
#define zADDRND(x)	/* nothing */
#elif defined(_KERNEL)
#include <sys/kernel.h>	/* for time */
#include <dev/rndvar.h>
#define zADDRND(x)	rnd_addpool_add((x) ^ (uint32_t)time.tv_sec)
#else /* userland */
/* XXX non-gcc compilers? */
#define zADDRND(x)	__extension__({				\
	uint32_t zADDRND_x = ((uint32_t)(x));			\
								\
	arc4random_pushk(&zADDRND_x, sizeof (zADDRND_x));	\
})
#endif

@


1.3
log
@make this kernel-able
@
text
@d1 1
a1 1
/* $MirOS: src/kern/z/zutil.h,v 1.2 2008/04/10 20:57:03 tg Exp $ */
d49 1
d51 1
@


1.2
log
@sync with src/lib/libz/zutil.h,v 1.13
@
text
@d1 1
a1 1
/* $MirOS$ */
d27 1
d31 1
@


1.1
log
@Initial revision
@
text
@d1 2
a12 2
/* @@(#) $Id$ */

d16 4
d23 8
a30 1
#ifdef STDC
d36 1
d71 1
a71 1
  return (strm->msg = (char*)ERR_MSG(err), (err))
d236 13
a248 1
#ifdef HAVE_MEMCPY
d265 1
a265 1
#ifdef DEBUG
d293 17
@


1.1.117.1
log
@Import the necessary parts of current zlib distribution and some of their docs
@
text
@@


1.1.117.2
log
@update zlib
@
text
@d2 1
a2 1
 * Copyright (C) 1995-2013 Jean-loup Gailly.
d16 1
a16 6
#ifdef HAVE_HIDDEN
#  define ZLIB_INTERNAL __attribute__((visibility ("hidden")))
#else
#  define ZLIB_INTERNAL
#endif

d19 2
a20 2
#if defined(STDC) && !defined(Z_SOLO)
#  if !(defined(_WIN32_WCE) && defined(_MSC_VER))
d26 14
a39 3

#ifdef Z_SOLO
   typedef long ptrdiff_t;  /* guess -- will be caught if guess is wrong */
d53 1
a53 1
extern z_const char * const z_errmsg[10]; /* indexed by 2-zlib_error */
d59 1
a59 1
  return (strm->msg = ERR_MSG(err), (err))
d91 7
a97 11
#  ifndef Z_SOLO
#    if defined(__TURBOC__) || defined(__BORLANDC__)
#      if (__STDC__ == 1) && (defined(__LARGE__) || defined(__COMPACT__))
         /* Allow compilation with ANSI keywords only enabled */
         void _Cdecl farfree( void *block );
         void *_Cdecl farmalloc( unsigned long nbytes );
#      else
#        include <alloc.h>
#      endif
#    else /* MSC or DJGPP */
#      include <malloc.h>
d99 2
d120 2
a121 2
#  if defined(M_I86) && !defined(Z_SOLO)
#    include <malloc.h>
d127 5
a131 7
#  ifndef Z_SOLO
#    if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
#      include <unix.h> /* for fdopen */
#    else
#      ifndef fdopen
#        define fdopen(fd,mode) NULL /* No fdopen() */
#      endif
d154 1
a154 1
#if (defined(_MSC_VER) && (_MSC_VER > 600)) && !defined __INTERIX
a165 13
#if defined(__BORLANDC__) && !defined(MSDOS)
  #pragma warn -8004
  #pragma warn -8008
  #pragma warn -8066
#endif

/* provide prototypes for these when building zlib without LFS */
#if !defined(_WIN32) && \
    (!defined(_LARGEFILE64_SOURCE) || _LFS64_LARGEFILE-0 == 0)
    ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));
    ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));
#endif

d178 34
a211 1
#if defined(pyr) || defined(Z_SOLO)
d235 3
a237 3
   void ZLIB_INTERNAL zmemcpy OF((Bytef* dest, const Bytef* source, uInt len));
   int ZLIB_INTERNAL zmemcmp OF((const Bytef* s1, const Bytef* s2, uInt len));
   void ZLIB_INTERNAL zmemzero OF((Bytef* dest, uInt len));
d243 2
a244 2
   extern int ZLIB_INTERNAL z_verbose;
   extern void ZLIB_INTERNAL z_error OF((char *m));
d260 3
a262 5
#ifndef Z_SOLO
   voidpf ZLIB_INTERNAL zcalloc OF((voidpf opaque, unsigned items,
                                    unsigned size));
   void ZLIB_INTERNAL zcfree  OF((voidpf opaque, voidpf ptr));
#endif
a268 4
/* Reverse the bytes in a 32-bit value */
#define ZSWAP32(q) ((((q) >> 24) & 0xff) + (((q) >> 8) & 0xff00) + \
                    (((q) & 0xff00) << 8) + (((q) & 0xff) << 24))

@

