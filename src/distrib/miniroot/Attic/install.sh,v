head	1.16;
access;
symbols
	MIRBSD_9_BASE:1.14
	MIRBSD_8:1.9.0.2
	MIRBSD_8_BASE:1.9
	cvs-200507211800:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@# @;


1.16
date	2006.08.17.19.34.18;	author tg;	state dead;
branches;
next	1.15;
commitid	10044E4C48801BF3A85;

1.15
date	2006.08.16.18.46.14;	author tg;	state Exp;
branches;
next	1.14;
commitid	10044E367FF357E2D31;

1.14
date	2006.06.17.00.17.56;	author tg;	state Exp;
branches;
next	1.13;
commitid	10044934A444586884F;

1.13
date	2006.05.16.22.46.12;	author tg;	state Exp;
branches;
next	1.12;
commitid	100446A56465221DED9;

1.12
date	2006.02.24.12.05.57;	author tg;	state Exp;
branches;
next	1.11;
commitid	10043FEF69E50D75FCE;

1.11
date	2006.01.11.20.48.06;	author tg;	state Exp;
branches;
next	1.10;
commitid	10043C56F155C46D380;

1.10
date	2005.12.28.15.11.16;	author tg;	state Exp;
branches;
next	1.9;
commitid	10043B2AACE2E11F69A;

1.9
date	2005.12.21.17.52.13;	author tg;	state Exp;
branches;
next	1.8;
commitid	10043A9965D295593F2;

1.8
date	2005.12.18.01.55.45;	author tg;	state Exp;
branches;
next	1.7;
commitid	10043A4C16A2CCD38A5;

1.7
date	2005.12.15.00.51.18;	author tg;	state Exp;
branches;
next	1.6;
commitid	10043A0BE01725F0BA4;

1.6
date	2005.12.06.12.44.02;	author tg;	state Exp;
branches;
next	1.5;
commitid	7dcd439587a55612;

1.5
date	2005.07.24.16.24.23;	author tg;	state Exp;
branches;
next	1.4;
commitid	416242e3c0c77089;

1.4
date	2005.07.01.13.31.29;	author tg;	state Exp;
branches;
next	1.3;
commitid	c1d42c545bfd3b1;

1.3
date	2005.05.20.19.40.23;	author tg;	state Exp;
branches;
next	1.2;
commitid	5c1f428e3ce59a47;

1.2
date	2005.03.06.18.58.04;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.22.10;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.22.10;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.07.01.12.58.54;	author tg;	state Exp;
branches;
next	;
commitid	b3242c53e16d354;


desc
@@


1.16
log
@move stuff required for images from miniroot/ and ramdisk/ to common/

PS: now's probably the time to not merge these with openbsd any more

PPS: this commit sponsored by johl's DEC VT320 @@9600,8n1 on NetBSD 1.6.1/pmax
@
text
@#!/bin/mksh
# $MirOS: src/distrib/miniroot/install.sh,v 1.15 2006/08/16 18:46:14 tg Exp $
# $OpenBSD: install.sh,v 1.152 2005/04/21 21:41:33 krw Exp $
# $NetBSD: install.sh,v 1.5.2.8 1996/08/27 18:15:05 gwr Exp $
#
# Copyright (c) 1997-2004 Todd Miller, Theo de Raadt, Ken Westerback
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# Copyright (c) 1996 The NetBSD Foundation, Inc.
# All rights reserved.
#
# This code is derived from software contributed to The NetBSD Foundation
# by Jason R. Thorpe.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. All advertising materials mentioning features or use of this software
#    must display the following acknowledgement:
#        This product includes software developed by the NetBSD
#        Foundation, Inc. and its contributors.
# 4. Neither the name of The NetBSD Foundation nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
# ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#

#	OpenBSD installation script.
#	In a perfect world, this would be a nice C program, with a reasonable
#	user interface.

# The name of the file holding the list of configured filesystems.
FILESYSTEMS=/tmp/filesystems

# The name of the file holding the list of non-default configured swap devices.
SWAPLIST=/tmp/swaplist

# install.sub needs to know the MODE
MODE=install

# include common subroutines and initialization code
. install.sub

# If /etc/fstab already exists, skip disk initialization.
if [ ! -f /etc/fstab ]; then
	# Install the shadowed disktab file; lets us write to it for temporary
	# purposes without mounting the miniroot read-write.
	[ -f /etc/disktab.shadow ] && cp /etc/disktab.shadow /tmp/disktab.shadow

	DISK=
	_DKDEVS=$DKDEVS

	while :; do
		_DKDEVS=$(rmel "$DISK" $_DKDEVS)

		# Always do ROOTDISK first, and repeat until
		# it is configured acceptably.
		if isin $ROOTDISK $_DKDEVS; then
			resp=$ROOTDISK
			rm -f /tmp/fstab
			# Make sure empty files exist so we don't have to
			# keep checking for their existence before grep'ing.
			cat /dev/null >$FILESYSTEMS
			cat /dev/null >$SWAPLIST
		else
			# Force the user to think and type in a disk name by
			# making 'done' the default choice.
			ask_which "disk" "do you wish to initialise" "$_DKDEVS" done "No more disks to initialise"
			[[ $resp == done ]] && break
		fi

		DISK=$resp
		makedev $DISK || continue

		# Deal with disklabels, including editing the root disklabel
		# and labeling additional disks. This is machine-dependent since
		# some platforms may not be able to provide this functionality.
		# /tmp/fstab.$DISK is created here with 'disklabel -f'.
		rm -f /tmp/*.$DISK
		md_prep_disklabel $DISK

		# Get the lists of BSD and swap partitions.
		unset _partitions _psizes _mount_points
		_i=0
		disklabel $DISK 2>&1 | sed -ne '/^ *[a-p]: /p' >/tmp/disklabel.$DISK
		while read _dev _size _offset _type _rest; do
			_pp=${DISK}${_dev%:}
			_ps=$_size

			if [[ $_pp == $ROOTDEV ]]; then
				echo "$ROOTDEV /" >$FILESYSTEMS
				continue
			elif [[ $_pp == $SWAPDEV || $_type == swap ]]; then
				echo "$_pp" >>$SWAPLIST
				continue
			elif [[ $_type != *BSD ]]; then
				continue
			fi

			_partitions[$_i]=$_pp
			_psizes[$_i]=$_ps

			# Set _mount_points[$_i].
			if [[ -f /tmp/fstab.$DISK ]]; then
				while read _pp _mp _rest; do
					[[ $_pp == "/dev/${_partitions[$_i]}" ]] || continue
					# Ignore mount points that have already been specified.
					[[ -n $(grep " $_mp\$" $FILESYSTEMS) ]] && break
					isin $_mp ${_mount_points[*]} && break
					# Ignore '/' for any partition but ROOTDEV. Check just
					# in case ROOTDEV isn't first partition processed.
					[[ $_mp == '/' ]] && break
					# Otherwise, record user specified mount point.
					_mount_points[$_i]=$_mp
				done </tmp/fstab.$DISK
			fi
			: $(( _i += 1 ))
		done </tmp/disklabel.$DISK

		if [[ $DISK == $ROOTDISK && -z $(grep "^$ROOTDEV /$" $FILESYSTEMS) ]]; then
			echo "ERROR: No root partition ($ROOTDEV)."
			DISK=
			continue
		fi

		# If there are no BSD partitions go on to next disk.
		[[ ${#_partitions[*]} -gt 0 ]] || continue

		# Now prompt the user for the mount points.
		_i=0
		while :; do
			_pp=${_partitions[$_i]}
			_ps=$(( ${_psizes[$_i]} / 2 ))
			_mp=${_mount_points[$_i]}

			# Get the mount point from the user
			ask "Mount point for ${_pp} (size=${_ps}k)? (or 'none' or 'done')" "$_mp"
			case $resp in
			"")	;;
			none)	_mp=
				;;
			done)	break
				;;
			/*)	set -- $(grep " $resp\$" $FILESYSTEMS)
				_pp=$1
				if [[ -z $_pp ]]; then
					# Mount point wasn't specified on a
					# previous disk. Has it been specified
					# on this one?
					_j=0
					for _pp in ${_partitions[*]} ""; do
						if [[ $_i -ne $_j ]]; then
							[[ $resp == ${_mount_points[$_j]} ]] && break
						fi
						: $(( _j += 1 ))
					done
				fi
				if [[ -n $_pp ]]; then
					echo "Invalid response: $_pp is already being mounted at $resp."
					continue
				fi
				_mp=$resp
				;;
			*)	echo "Invalid response: mount point must be an absolute path!"
				continue
				;;
			esac

			_mount_points[$_i]=$_mp

			: $(( _i += 1))
			[ $_i -ge ${#_partitions[*]} ] && _i=0
		done

		# Append mount information to $FILESYSTEMS
		_i=0
		for _pp in ${_partitions[*]}; do
			_mp=${_mount_points[$_i]}
			[ "$_mp" ] && echo "$_pp $_mp" >>$FILESYSTEMS
			: $(( _i += 1 ))
		done
	done

	cat <<__EOT

MirBSD filesystems:
$(<$FILESYSTEMS)

The next step *DESTROYS* all existing data on these partitions!
__EOT

	ask_yn "Are you really sure that you're ready to proceed?"
	[[ $resp == n ]] && { echo "Ok, try again later." ; exit ; }

	# Read $FILESYSTEMS, creating a new filesystem on each listed
	# partition and saving the partition and mount point information
	# for subsequent sorting by mount point.
	_i=0
	unset _partitions _mount_points
	while read _pp _mp; do
		_OPT=
		[[ $_mp == / ]] && _OPT=$MDROOTFSOPT
		newfs -q $_OPT /dev/r$_pp

		_partitions[$_i]=$_pp
		_mount_points[$_i]=$_mp
		: $(( _i += 1 ))
	done <$FILESYSTEMS

	# Write fstab entries to /tmp/fstab in mount point alphabetic
	# order to enforce a rational mount order.
	for _mp in $(bsort ${_mount_points[*]}); do
		_i=0
		for _pp in ${_partitions[*]}; do
			if [ "$_mp" = "${_mount_points[$_i]}" ]; then
				echo -n "/dev/$_pp $_mp ffs rw,softdep"
				# Only '/' is neither nodev nor nosuid. i.e.
				# it can obviously *always* contain devices or
				# setuid programs.
				#
				# Every other mounted filesystem is nodev. If
				# the user chooses to mount /dev as a separate
				# filesystem, then on the user's head be it.
				#
				# The only directories that install puts suid
				# binaries into (as of 3.2) are:
				#
				# /sbin
				# /usr/bin
				# /usr/sbin
				# /usr/libexec
				# /usr/libexec/auth
				# /usr/X11R6/bin
				#
				# and ports and users can do who knows what
				# to /usr/local and sub directories thereof.
				#
				# So try to ensure that only filesystems that
				# are mounted at or above these directories
				# can contain suid programs. In the case of
				# /usr/libexec, give blanket permission for
				# subdirectories.
				if [[ $_mp == / ]]; then
					# / can hold devices and suid programs.
					echo " 1 1"
				else
					# No devices anywhere but /.
					echo -n ",nodev"
					case $_mp in
					# A few directories are allowed suid.
					/sbin|/usr)			;;
					/usr/bin|/usr/sbin)		;;
					/usr/libexec|/usr/libexec/*)	;;
					/usr/local|/usr/local/*)	;;
					/usr/X11R6|/usr/X11R6/bin)	;;
					# But all others are not.
					*)	echo -n ",nosuid"	;;
					esac
					echo " 1 2"
				fi
			fi
			: $(( _i += 1 ))
		done
	done >>/tmp/fstab

	# Append all non-default swap devices to fstab.
	while read _dev; do
		[[ $_dev == $SWAPDEV ]] || \
			echo "/dev/$_dev none swap sw 0 0" >>/tmp/fstab
	done <$SWAPLIST

	munge_fstab
fi

mount_fs "-o async"

# Set hostname.
#
# Use existing hostname (short form) as the default value because we could
# be restarting an install.
#
# Don't ask for, but don't discard, domain information provided by the user.
#
# Only apply the new value if the new short form name differs from the existing
# one. This preserves any existing domain information in the hostname.
ask_until "\nSystem hostname? (short form, e.g. 'foo')" "$(hostname -s)"
[[ ${resp%%.*} != $(hostname -s) ]] && hostname $resp

# Remove existing network configuration files in /tmp to ensure they don't leak
# onto the installed system in the case of a restarted install. Any information
# contained within them should be accessible via ifconfig, hostname, route,
# etc.
( cd /tmp; rm -f host* my* resolv.* dhclient.* )

# Always create new hosts file.
cat >/tmp/hosts <<__EOT
::1 localhost
127.0.0.1 localhost
::1 $(hostname -s)
127.0.0.1 $(hostname -s)
__EOT

ask_yn "Configure the network?" yes
[[ $resp == y ]] && donetconfig

install_sets

# Remount all filesystems in /etc/fstab with the options from /etc/fstab, i.e.
# without any options such as async which may have been used in the first
# mount.
while read _dev _mp _fstype _opt _rest; do
	mount -u -o $_opt $_dev $_mp ||	exit
done </etc/fstab

# Handle questions...
questions

# Create initial user as root replacement
cat <<EOF
We will now create a user account on your system, which you can then
use to log in and work with the system, as well as do administrative
tasks using sudo(8). The newly created user account will be added to
the class 'staff', and the group 'wheel' for being able to use sudo,
as well as 'wsrc' and 'staff'. You might want to add yourself to the
groups 'operator', 'audio', etc. manually later.
EOF
_oifs=$IFS
IFS=; _rootuser=; full=; _rootuid=3000
while :; do
	ask_until "User name?" $_rootuser
	_rootuser=$resp
	ask "Full name?" $full
	full=$resp
	ask "User ID?" $_rootuid
	let _rootuid=$resp
	askpass "Password? (will not echo)"
	_password=$resp
	askpass "Password? (again)"

	if (( (_rootuid < 1000) || (_rootuid > 32765) )); then
		print UID mismatch, must be between 1000 and 32765.
	elif [[ $resp != $_password ]]; then
		print Passwords do not match.
	elif [[ $_rootuser != @@([a-z])*([a-z0-9]) ]]; then
		print Username is not alphanumeric.
	elif [[ $full = *:* ]]; then
		print Full name contains a colon.
	else
		ask_yn "Everything ok?"
		[[ $resp = y ]] && break
	fi
done
IFS=$_oifs
_rootline=":$_rootuid:$_rootuid:staff:0:0:$full:/home/$_rootuser:/bin/mksh"

set_timezone

echo -n "Saving configuration files..."

# Save any leases obtained during install.
( cd /var/db
[ -f dhclient.leases ] && mv dhclient.leases /mnt/var/db/. )

# Move configuration files from /tmp to /mnt/etc.
( cd /tmp
hostname >myname

# Add FQDN to /tmp/hosts entries, changing lines of the form '1.2.3.4 hostname'
# to '1.2.3.4 hostname.$FQDN hostname'. Leave untouched any lines containing
# domain information or aliases. The user added those manually.
_dn=$(get_fqdn)
while read _addr _hn _aliases; do
	if [[ -n $_aliases || $_hn != ${_hn%%.*} || -z $_dn ]]; then
		echo "$_addr $_hn $_aliases"
	else
		echo "$_addr $_hn.$_dn $_hn"
	fi
done <hosts >hosts.new
mv hosts.new hosts

# Prepend interesting comments from installed hosts and dhclient.conf files
# to /tmp/hosts and /tmp/dhclient.conf.
save_comments hosts
save_comments dhclient.conf

# Possible files: fstab, myname, sysctl.conf
#                 dhclient.conf resolv.conf resolv.conf.tail
#		  hostname.* hosts
for _f in fstab my* *.conf *.tail host* ttys; do
	[[ -f $_f ]] && mv $_f /mnt/etc/.
done )

[[ -s /tmp/kbdtype ]] && \
    print keyboard.encoding=$(</tmp/kbdtype) >>/mnt/etc/wsconsctl.conf

# Amend target fstab by kernfs (BSD) / sysfs (Linux) and procfs (both)
[[ $MODE == install ]] && cat >>/mnt/etc/fstab <<__EOF
kern /kern kernfs rw,noauto 0 0
proc /proc procfs rw,linux 0 0
__EOF

# Generate initial user
ed -s /mnt/etc/master.passwd <<EOF
\$i
$_rootuser:$(/mnt/usr/bin/encrypt -b 8 -- "$_password")$_rootline
.
wq
EOF
ed -s /mnt/etc/group <<EOF
/^wheel:/s/\$/,$_rootuser/
/^wsrc:/s/\$/$_rootuser/
/^staff:/s/\$/,$_rootuser/
\$i
$_rootuser:*:$_rootuid:
.
wq
EOF
print "%g/@@ROOT@@/s//$_rootuser/\nwq" | ed -s /mnt/etc/sudoers
cp -r /mnt/etc/skel /mnt/home/$_rootuser
chmod 711 /mnt/home/$_rootuser
chown -R $_rootuid:$_rootuid /mnt/home/$_rootuser
/mnt/usr/sbin/pwd_mkdb -pd /mnt/etc master.passwd

echo -n "done.\nGenerating initial host.random file..."
dd if=/dev/arandom of=/mnt/var/db/host.random bs=1024 count=16 >/dev/null 2>&1
chmod 600 /mnt/var/db/host.random
echo "done."

# Perform final steps common to both an install and an upgrade.
finish_up
@


1.15
log
@prefer arc4random and don't htonl() its return value
@
text
@d2 1
a2 1
# $MirOS: src/distrib/miniroot/install.sh,v 1.14 2006/06/17 00:17:56 tg Exp $
@


1.14
log
@ask at least that question earlier
@
text
@d2 1
a2 1
# $MirOS: src/distrib/miniroot/install.sh,v 1.13 2006/05/16 22:46:12 tg Exp $
d461 1
a461 1
dd if=/dev/urandom of=/mnt/var/db/host.random bs=1024 count=16 >/dev/null 2>&1
@


1.13
log
@sync with reality
Commit ID:      1004427B52C11E7C73D
@
text
@d2 1
a2 1
# $MirOS: src/distrib/miniroot/install.sh,v 1.12 2006/02/24 12:05:57 tg Exp $
d392 2
a464 2
set_timezone

@


1.12
log
@there cannot be a /mnt/var/db/host.random in the very instant
after newfs(8)ing then mount(8)ing it there... d'oh!
@
text
@d2 1
a2 1
# $MirOS: src/distrib/miniroot/install.sh,v 1.11 2006/01/11 20:48:06 tg Exp $
d459 1
a459 1
dd if=/dev/urandom of=/mnt/var/db/host.random bs=1024 count=64 >/dev/null 2>&1
@


1.11
log
@default: passwd_timeout=0 for "root" user
@
text
@d2 1
a2 1
# $MirOS: src/distrib/miniroot/install.sh,v 1.10 2005/12/28 15:11:16 tg Exp $
a312 20
# Seed from random if exists
if [ -e /mnt/var/db/host.random ]; then
	dd if=/dev/prandom bs=256 count=1 >/tmp/rand
	dd if=/dev/arandom bs=256 count=94 >>/tmp/rand
	SUMS="$(cksum /tmp/rand) $RANDOM $(ls -lR /) $PPID $SECONDS $$ $(dd if=/dev/srandom bs=8 count=1)"
	RANDOM=$(echo "$SUMS" | cksum -o 1 | while read a b; do echo $a; done)
	dd if=/dev/prandom bs=256 count=1 >>/tmp/rand
	dd if=/dev/urandom bs=256 count=96 >>/tmp/rand
	cat /mnt/var/db/host.random >/dev/arandom
	dd if=/dev/arandom bs=256 count=1 >>/tmp/rand
	dd if=/dev/urandom bs=1024 count=63 >>/tmp/rand
	SUMS="$(cksum /mnt/var/db/host.random) $RANDOM $(cksum -o 1 /tmp/rand)"
	cat /tmp/rand >/var/db/host.random
	dd if=/dev/prandom bs=256 count=1 >/tmp/rand
	dd if=/dev/urandom bs=256 count=1 >>/tmp/rand
	echo "$SUMS" >>/tmp/rand
	cat /tmp/rand >/dev/arandom
	rm /tmp/rand
fi

@


1.10
log
@* add the user to the groups 'staff' and 'wsrc' (for ports) too
* allow alphanumeric user names as long as they start with a letter

candidate for MFC
@
text
@d2 1
a2 1
# $MirOS: src/distrib/miniroot/install.sh,v 1.9 2005/12/21 17:52:13 tg Exp $
d472 1
a472 1
print "/^@@ROOT@@/s//$_rootuser/\nwq" | ed -s /mnt/etc/sudoers
@


1.9
log
@first round of fixes
@
text
@d2 1
a2 1
# $MirOS: src/distrib/miniroot/install.sh,v 1.8 2005/12/18 01:55:45 tg Exp $
d379 3
a381 1
the class 'staff', and the group 'wheel' for being able to use sudo.
d400 2
a401 2
	elif [[ $_rootuser != *([a-z]) ]]; then
		print Username is not alphabetic.
d465 2
@


1.8
log
@change the installer (untested): creates a user (with populated ~)
which can do sudo with his own password, don't set root password any more

Inspired by talking with Hubert Feyrer who had tried out OpenBSD once,
planned for almost a year already, committed now before the release.

no veto by bsiegert@@ received
@
text
@d2 1
a2 1
# $MirOS: src/distrib/miniroot/install.sh,v 1.7 2005/12/15 00:51:18 tg Exp $
d396 1
a396 1
	elif [[ $resp != $pass ]]; then
d468 1
a468 1
print "/^@@ROOT@@/s//$_rootuser\nwq" | ed -s /mnt/etc/sudoers
d472 1
d474 2
a475 2
echo "done.\nGenerating initial host.random file..."
dd if=/dev/urandom of=/mnt/var/db/host.random bs=1024 count=64
@


1.7
log
@be more visible when generating the initial host.random file,
as I've seen it to not appear (I wonder why); also use the
ramdisk's /dev/urandom and dd instead.
@
text
@d2 1
a2 1
# $MirOS: src/distrib/miniroot/install.sh,v 1.6 2005/12/06 12:44:02 tg Exp $
a361 13
_oifs=$IFS
IFS=
while :; do
	askpass "Password for root account? (will not echo)"
	_password=$resp

	askpass "Password for root account? (again)"
	[[ $resp == $_password ]] && break

	echo "Passwords do not match, try again."
done
IFS=$_oifs

d374 36
d454 18
a471 5
_encr=$(/mnt/usr/bin/encrypt -b 8 -- "$_password")
echo "1,s@@^root::@@root:${_encr}:@@
w
q" | ed /mnt/etc/master.passwd 2>/dev/null
/mnt/usr/sbin/pwd_mkdb -p -d /mnt/etc /etc/master.passwd
@


1.6
log
@british spelling
@
text
@d2 1
a2 1
# $MirOS: src/distrib/miniroot/install.sh,v 1.5 2005/07/24 16:24:23 tg Exp $
d437 3
a439 4
echo -n "done.\nGenerating initial host.random file..."
( cd /mnt/var/db
/mnt/bin/dd if=/mnt/dev/urandom of=host.random bs=1024 count=64 >/dev/null 2>&1
chmod 600 host.random >/dev/null 2>&1 )
@


1.5
log
@handle /etc/kbdtype removal
@
text
@d2 1
a2 1
# $MirOS: src/distrib/miniroot/install.sh,v 1.4 2005/07/01 13:31:29 tg Exp $
d104 1
a104 1
			ask_which "disk" "do you wish to initialize" "$_DKDEVS" done "No more disks to initialize"
@


1.4
log
@EXPERIMENTAL merge the installer
PLEASE TEST
@
text
@d2 1
a2 1
# $MirOS: src/distrib/miniroot/install.sh,v 1.3 2005/05/20 19:40:23 tg Exp $
d415 1
a415 1
# Possible files: fstab, kbdtype, myname, sysctl.conf
d418 1
a418 1
for _f in fstab kbdtype my* *.conf *.tail host* ttys; do
d422 3
@


1.3
log
@it sucks to have to sacrifice 8 precious Mebibytes on a CF
or RAID-1 if we don't need it there or at all

ok bsiegert@@
@
text
@d1 3
a3 3
#!/bin/sh
# $MirOS: src/distrib/miniroot/install.sh,v 1.2 2005/03/06 18:58:04 tg Exp $
# $OpenBSD: install.sh,v 1.142 2004/03/23 02:39:38 krw Exp $
d89 1
a89 1
	while : ; do
d109 1
d129 1
a129 1
			elif [[ $_type == swap ]]; then
d139 1
a139 1
			# If the user assigned a mount point, use it if possible.
d156 4
a159 21
		if [[ $DISK == $ROOTDISK ]]; then
			# Ensure that ROOTDEV was configured.
			if [[ -n $(grep "^$ROOTDEV /$" $FILESYSTEMS) ]]; then
				echo "The root filesystem will be mounted on $ROOTDEV."
			else
				echo "ERROR: Unable to mount the root filesystem on $ROOTDEV."
				DISK=
			fi
			# Ensure that $SWAPDEV was configured as swap space.
			if [[ -n $(grep "^$SWAPDEV" $SWAPLIST) ]]; then
				echo "$SWAPDEV will be used for swap space."
				# But we really don't want it in the installed
				# /etc/fstab.
				grep -v "^$SWAPDEV" $SWAPLIST >$SWAPLIST.tmp
				mv $SWAPLIST.tmp $SWAPLIST
			else
				echo "ERROR: Unable to use $SWAPDEV for swap space."
				ask_yn "Do you REALLY want to go without any swap?"
				[[ $resp = n ]] && DISK=
			fi
			[[ -n $DISK ]] || echo "You must reconfigure $ROOTDISK."
d162 2
a163 2
		# If there are no BSD partitions, or $DISK has been reset, go on to next disk.
		[[ ${#_partitions[*]} -gt 0 && -n $DISK ]] || continue
d165 1
a165 1
		# Now prompt the user for the mount points. Loop until "done" entered.
d167 1
a167 1
		while : ; do
d222 1
a222 2
You have configured the following partitions and mount points:

d225 1
a225 1
The next step creates a filesystem on each partition, ERASING existing data.
d229 1
a229 1
	[[ $resp == n ]] && { echo "ok, try again later..." ; exit ; }
d237 3
a239 1
		newfs -q /dev/r$_pp
d304 2
a305 1
		echo "/dev/$_dev none swap sw 0 0" >>/tmp/fstab
d364 1
a364 2
resp=
while [[ -z $resp ]]; do
d369 3
a371 4
	if [ "$_password" != "$resp" ]; then
		echo "Passwords do not match, try again."
		resp=
	fi
d418 1
a418 1
for _f in fstab kbdtype myname *.conf *.tail host*; do
d435 3
a437 2
dd if=/dev/urandom of=/mnt/var/db/host.random bs=1024 count=64 >/dev/null 2>&1
chmod 600 /mnt/var/db/host.random
@


1.2
log
@merge src/distrib
@
text
@d2 1
a2 1
# $MirOS$
d172 2
a173 1
				DISK=
@


1.1
log
@Initial revision
@
text
@d2 3
a4 2
#	$OpenBSD: install.sh,v 1.142 2004/03/23 02:39:38 krw Exp $
#	$NetBSD: install.sh,v 1.5.2.8 1996/08/27 18:15:05 gwr Exp $
d90 1
a90 1
		_DKDEVS=`rmel "$DISK" $_DKDEVS`
d150 1
a150 1
				done < /tmp/fstab.$DISK
d153 1
a153 1
		done < /tmp/disklabel.$DISK
d168 1
a168 1
				grep -v "^$SWAPDEV" $SWAPLIST > $SWAPLIST.tmp
d235 1
a235 1
	cat << __EOT
d262 1
a262 1
	for _mp in `bsort ${_mount_points[*]}`; do
d266 1
a266 1
				echo -n "/dev/$_pp $_mp ffs rw"
d314 1
a314 1
	done >> /tmp/fstab
d319 1
a319 1
	done < $SWAPLIST
d326 20
d365 1
a365 1
cat > /tmp/hosts << __EOT
d397 1
a397 1
done < /etc/fstab
d410 1
a410 1
hostname > myname
d422 1
a422 1
done < hosts > hosts.new
d430 1
a430 1
# Possible files: fstab, kbdtype, myname, mygate, sysctl.conf
d433 1
a433 1
for _f in fstab kbdtype my* *.conf *.tail host*; do
d437 7
a443 1
_encr=`/mnt/usr/bin/encrypt -b 8 -- "$_password"`
d446 1
a446 1
q" | ed /mnt/etc/master.passwd 2> /dev/null
d450 2
a451 3
( cd /mnt/var/db
dd if=/mnt/dev/urandom of=host.random bs=1024 count=64 >/dev/null 2>&1
chmod 600 host.random >/dev/null 2>&1 )
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@update from OpenBSD-current
@
text
@d1 2
a2 2
#!/bin/ksh
#	$OpenBSD: install.sh,v 1.152 2005/04/21 21:41:33 krw Exp $
d88 1
a88 1
	while :; do
a107 1
		makedev $DISK || continue
d127 1
a127 1
			elif [[ $_pp == $SWAPDEV || $_type == swap ]]; then
d137 1
a137 1
			# Set _mount_points[$_i].
d149 1
a149 1
				done </tmp/fstab.$DISK
d152 1
a152 1
		done </tmp/disklabel.$DISK
d154 20
a173 4
		if [[ $DISK == $ROOTDISK && -z $(grep "^$ROOTDEV /$" $FILESYSTEMS) ]]; then
			echo "ERROR: No root partition ($ROOTDEV)."
			DISK=
			continue
d176 2
a177 2
		# If there are no BSD partitions go on to next disk.
		[[ ${#_partitions[*]} -gt 0 ]] || continue
d179 1
a179 1
		# Now prompt the user for the mount points.
d181 1
a181 1
		while :; do
d234 3
a236 1
	cat <<__EOT
a237 1
OpenBSD filesystems:
d240 1
a240 1
The next step *DESTROYS* all existing data on these partitions!
d244 1
a244 1
	[[ $resp == n ]] && { echo "Ok, try again later." ; exit ; }
d252 1
a252 3
		_OPT=
		[[ $_mp == / ]] && _OPT=$MDROOTFSOPT
		newfs -q $_OPT /dev/r$_pp
d313 1
a313 1
	done >>/tmp/fstab
d317 2
a318 3
		[[ $_dev == $SWAPDEV ]] || \
			echo "/dev/$_dev none swap sw 0 0" >>/tmp/fstab
	done <$SWAPLIST
d344 1
a344 1
cat >/tmp/hosts <<__EOT
d356 2
a357 1
while :; do
d362 4
a365 3
	[[ $resp == $_password ]] && break

	echo "Passwords do not match, try again."
d376 1
a376 1
done </etc/fstab
d389 1
a389 1
hostname >myname
d401 1
a401 1
done <hosts >hosts.new
d412 1
a412 1
for _f in fstab kbdtype my* *.conf *.tail host* ttys; do
d419 1
a419 1
q" | /mnt/bin/ed /mnt/etc/master.passwd 2>/dev/null
d424 1
a424 1
/mnt/bin/dd if=/mnt/dev/urandom of=host.random bs=1024 count=64 >/dev/null 2>&1
@

