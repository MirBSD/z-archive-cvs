head	1.25;
access;
symbols
	MIRBSD_9_BASE:1.23
	MIRBSD_8:1.19.0.2
	MIRBSD_8_BASE:1.19
	cvs-200507211800:1.1.1.3
	openbsd:1.1.1;
locks; strict;
comment	@# @;


1.25
date	2006.08.17.19.34.19;	author tg;	state dead;
branches;
next	1.24;
commitid	10044E4C48801BF3A85;

1.24
date	2006.08.17.14.00.29;	author tg;	state Exp;
branches;
next	1.23;
commitid	10044E4768E1041267A;

1.23
date	2006.06.16.15.57.52;	author tg;	state Exp;
branches;
next	1.22;
commitid	1004492D5123321B794;

1.22
date	2006.04.06.11.15.50;	author tg;	state Exp;
branches;
next	1.21;
commitid	1004434F86B46610753;

1.21
date	2006.03.16.13.41.57;	author tg;	state Exp;
branches;
next	1.20;
commitid	10044196AAB6E990A50;

1.20
date	2006.01.11.20.42.12;	author tg;	state Exp;
branches;
next	1.19;
commitid	10043C56DB356C9140A;

1.19
date	2005.12.23.13.16.03;	author tg;	state Exp;
branches;
next	1.18;
commitid	10043ABF87518B1F401;

1.18
date	2005.12.21.18.14.57;	author tg;	state Exp;
branches;
next	1.17;
commitid	10043A99BB26DBF3BFB;

1.17
date	2005.12.19.17.09.48;	author tg;	state Exp;
branches;
next	1.16;
commitid	10043A6E8A913BED43A;

1.16
date	2005.12.07.12.45.55;	author tg;	state Exp;
branches;
next	1.15;
commitid	4396D98B0E26CA4;

1.15
date	2005.12.07.07.34.34;	author tg;	state Exp;
branches;
next	1.14;
commitid	04396908e7996900;

1.14
date	2005.12.06.12.53.37;	author tg;	state Exp;
branches;
next	1.13;
commitid	28d4439589d43ffd;

1.13
date	2005.12.06.12.44.02;	author tg;	state Exp;
branches;
next	1.12;
commitid	7dcd439587a55612;

1.12
date	2005.12.06.12.42.19;	author tg;	state Exp;
branches;
next	1.11;
commitid	263c439587392398;

1.11
date	2005.11.19.21.50.38;	author tg;	state Exp;
branches;
next	1.10;
commitid	7a04437f9e3de1f6;

1.10
date	2005.09.26.22.55.26;	author tg;	state Exp;
branches;
next	1.9;
commitid	41f543387c5e41db;

1.9
date	2005.07.24.16.44.13;	author tg;	state Exp;
branches;
next	1.8;
commitid	377c42e3c570e5b3;

1.8
date	2005.07.01.13.31.30;	author tg;	state Exp;
branches;
next	1.7;
commitid	c1d42c545bfd3b1;

1.7
date	2005.06.14.13.36.09;	author tg;	state Exp;
branches;
next	1.6;
commitid	f2342aedd454bfe;

1.6
date	2005.05.09.08.47.15;	author tg;	state Exp;
branches;
next	1.5;
commitid	45b5427f239a1762;

1.5
date	2005.05.05.00.40.50;	author tg;	state Exp;
branches;
next	1.4;
commitid	293f42796b7ecc91;

1.4
date	2005.05.04.11.38.50;	author tg;	state Exp;
branches;
next	1.3;
commitid	5f604278b4521df4;

1.3
date	2005.04.29.16.37.44;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.06.18.58.04;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.22.10;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.22.10;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.07.01.12.58.54;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	b3242c53e16d354;

1.1.1.3
date	2005.07.21.20.45.44;	author tg;	state Exp;
branches;
next	;
commitid	560042e0092f571e;


desc
@@


1.25
log
@move stuff required for images from miniroot/ and ramdisk/ to common/

PS: now's probably the time to not merge these with openbsd any more

PPS: this commit sponsored by johl's DEC VT320 @@9600,8n1 on NetBSD 1.6.1/pmax
@
text
@# $MirOS: src/distrib/miniroot/install.sub,v 1.24 2006/08/17 14:00:29 tg Exp $
# $OpenBSD: install.sub,v 1.388 2005/07/02 00:55:48 uwe Exp $
# $NetBSD: install.sub,v 1.5.2.8 1996/09/02 23:25:02 pk Exp $
#
# Copyright (c) 2003, 2004, 2005
#	Thorsten "mirabile" Glaser <tg@@66h.42h.de>
# Copyright (c) 1997-2005 Todd Miller, Theo de Raadt, Ken Westerback
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# Copyright (c) 1996 The NetBSD Foundation, Inc.
# All rights reserved.
#
# This code is derived from software contributed to The NetBSD Foundation
# by Jason R. Thorpe.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. All advertising materials mentioning features or use of this software
#    must display the following acknowledgement:
#        This product includes software developed by the NetBSD
#        Foundation, Inc. and its contributors.
# 4. Neither the name of The NetBSD Foundation nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
# ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#

# MirBSD install/upgrade script common subroutines and initialization code

# Include machine-dependent functions and definitions.
#
# The following functions must be provided:
#	md_congrats()		  - display friendly message
#	md_installboot()	  - install boot-blocks on disk
#	md_prep_disklabel()	  - put an OpenBSD disklabel on the disk
#
# The following variables can be provided if required:
#	MDSETS	    - list of files to add to THESETS
#	MDTERM      - 'vt220' assumed if not provided
#	MDFSTYPE    - nothing assumed if not provided
#	MDFSOPTS    - nothing assumed if not provided
#	MDDKDEVS    - '/^r*a*[swi]d[0-9][0-9]* /s/ .*//p' assumed if not provided
#	MDCDDEVS    - '/^cd[0-9][0-9]* /s/ .*//p'    assumed if not provided
#	MDMTDEVS    - '/^[cmsw]t[0-9][0-9]* /s/ .*//p'
#	MDXAPERTURE - set machdep.allowaperture=value in sysctl.conf
. install.md

set_term() {
	local _tables

	[[ -n $TERM ]] && return
	local TERMS=vt100,vt220,wsvt25,dumb,$MDTERM
	echo "Possible types: ${MDTERMS:-${TERMS%,}}"
	ask "Terminal type?" ${MDTERM:-vt220}
	TERM=$resp
	export TERM

	[[ -x /sbin/kbd ]] || return
	_tables=$(bsort $(kbd -l | egrep -v "^(user|tables|encoding)"))
	while :; do
		ask "kbd(8) mapping? ('?' for list)" "none"
		case $resp in
		none)	return ;;
		"?")	echo "Major tables: $_tables" ;;
		*)	kbd $resp && { echo $resp >/tmp/kbdtype ; return ; } ;;
		esac
	done
}

welcome() {
	local _q

	cat <<__EOT

Welcome to the ${OBSD} $MODE program.

This program will help you $MODE MirOS. At any prompt except password prompts
you can run a shell command by typing '!foo', or escape to a shell by typing
'!'. Default answers are shown in []'s and are selected by just RETURN, but
sometimes there is no default. At any time you can exit this programme by
pressing Control-C and then RETURN, but quitting during an $MODE can leave
your system in an inconsistent state.

__EOT

	# Configure the terminal and keyboard.
	set_term

	cat <<__EOT

IS YOUR DATA BACKED UP? As with anything that modifies disk contents, this
program can cause SIGNIFICANT data loss.

__EOT

	case $MODE in
	upgrade)
		cat <<__EOT
NOTE: before your system has been upgraded, you must manually merge any changes
to files in the 'etc' and 'xetc' sets into the files already on your system.

__EOT
		_q="Proceed with upgrade?"
		;;

	install)
		cat <<__EOT
It is often helpful to have the installation notes handy. For complex disk
configurations, relevant disk hardware manuals and a calculator are useful.

__EOT

		if [ -f /etc/fstab ]; then
			cat <<__EOT
You seem to be trying to restart an interrupted installation! You can skip
the disk preparation steps and continue, or you can reboot and start over.

__EOT
			_q="Skip disk initialization?"
		else
			_q="Proceed with install?"
		fi
		;;
	esac

	ask_yn "$_q"
	if [[ $resp == n ]]; then
		cat <<__EOT

Enter 'halt -p' or 'reboot' at the prompt to gracefully exit MirBSD.
You can then power cycle the machine and boot BSD or your other OSes.
__EOT
		exit
	fi

	echo "Cool! Let's get to it."
}

scan_dmesg() {
	bsort $(sed -ne "$1" /var/run/dmesg.boot)
}

get_ifdevs() {
	ifconfig -a \
	    | egrep -v '^[[:space:]]|(bridge|enc|gif|gre|lo|pflog|pfsync|ppp|sl|tun|vlan)[[:digit:]]+:' \
	    | sed -ne 's/^\(.*\):.*/\1/p'
}

# Get the first (lowest unit #) serial device if any, if MDSERIAL is set.
# NOTE: Only single digit serial devices (<dev>0 -> <dev>9) are looked for.
get_serialdev() {
	local _d _bd _td

	[[ -n $MDSERIAL ]] || exit
	set -- $MDSERIAL
	_d=$1
	_bd=$2
	_td=$3
	set -- $(scan_dmesg "/^${_d}\([0-9]\) .*/s//\1/p")
	echo "$_bd$1 $_td$1"
}

get_drive() {
	ask_which "$1" "contains the $MODE media" "$2"
	[[ $resp == done ]] && return 1
	makedev $resp || return 1
	return 0
}

get_partition() {
	local _drive=$1 _fstypes=$2 _part _fst

	# Create file /tmp/parts.$_drive where each line is of the
	# form "<partition letter> <fs type>".
	disklabel $_drive 2>/dev/null		\
		| grep '^  [a-p]: '		\
		| egrep -v "swap|unused"	\
		| sed -e 's/^  \(.\):  *[^ ]*  *[^ ]*  *\([^ ]*\) .*/\1 \2/' \
		>/tmp/parts.$_drive

	disklabel $_drive 2>/dev/null | grep '^  .:'

	ask_which "$_drive partition" "has the $MODE sets" \
		 "$(sed -e 's/^\(.\).*/\1/' /tmp/parts.$_drive)"
	[[ $resp == done ]] && return 1

	_part=$resp
	_fst=$(sed -ne "/^$_part /s///p" /tmp/parts.$_drive)

	ask_which "filesystem type" "should be used to mount $_drive$_part" "$_fst $_fstypes ffs"
	case $resp in
	done)	return 1 ;;
	$_fst)	resp="$_part" ;;
	*)	resp="$_part $resp" ;;
	esac

	return 0
}

# Ask for a password, saving the input in $resp.
#    Display $1 as the prompt.
#    *Don't* allow the '!' options that ask does.
#    *Don't* echo input.
askpass() {
	set -o noglob
	stty -echo
	read resp?"$1 "
	stty echo
	set +o noglob
	echo
}

# Ask for user input.
#
#    $1    = the question to ask the user
#    $2    = the default answer
#
# Save the user input (or the default) in $resp.
#
# Allow the user to escape to shells ('!') or execute commands
# ('!foo') before entering the input.
ask() {
	local _question=$1 _default=$2

	set -o noglob
	while :; do
		echo -n "$_question "
		[[ -z $_default ]] || echo -n "[$_default] "
		read resp
		case $resp in
		!)	echo "Type 'exit' to return to install."
			sh
			;;
		!*)	eval ${resp#?}
			;;
		*)	: ${resp:=$_default}
			break
			;;
		esac
	done
	set +o noglob
}

# Ask for user input until a non-empty reply is entered.
#
#    $1    = the question to ask the user
#    $2    = the default answer
#
# Save the user input (or the default) in $resp.
ask_until() {
	resp=
	while [[ -z $resp ]]; do
		ask "$1" "$2"
	done
}

# Ask the user for a y or n, and insist on 'y', 'yes', 'n' or 'no'.
#
#    $1    = the question to ask the user
#    $2    = the default answer (assumed to be 'n' if empty).
#
# Return 'y' or 'n' in $resp.
ask_yn() {
	local _q=$1 _a=${2:-no} _resp
	typeset -l _resp

	while :; do
		ask "$_q" "$_a"
		_resp=$resp
		case $_resp in
		y|yes)	resp=y; return ;;
		n|no)	resp=n; return ;;
		esac
	done
 }

# Ask for the user to select one value from a list, or 'done'.
#
# $1 = name of the list items (disk, cd, etc.)
# $2 = question to ask
# $3 = list of valid choices
# $4 = default choice, if it is not specified use the first item in $3
# $5 = error message if no items in $3, defaults to 'No $1s found.'
#
# At exit $resp holds selected item, or 'done'
ask_which() {
	local _name=$1 _query=$2 _list=$3 _def=$4 _err=$5

	set -- $_list
	if (( $# < 1 )); then
		echo "${_err:=No ${_name}s found}."
		resp=done
		return
	fi
	: ${_def:=$1}

	# Eliminate extraneous (especially trailing) whitespace in _list.
	_list="$*"

	while :; do
		# Put both lines in ask prompt, rather than use a
		# separate 'echo' to ensure the entire question is
		# re-ask'ed after a '!' or '!foo' shell escape.
		ask "Available ${_name}s are: $_list.\nWhich one $_query? (or 'done')" "$_def"

		# Quote $resp to prevent user from confusing isin() by
		# entering something like 'a a'.
		isin "$resp" $_list done && break
		echo "'$resp' is not a valid choice."
	done
}

# test the first argument against the remaining ones, return success on a match
isin() {
	local	_a=$1 _b

	shift
	for _b; do
		[[ $_a == $_b ]] && return 0
	done
	return 1
}

# add first argument to list formed by the remaining arguments
# adds to the tail if the element does not already exist
addel() {
	local	_a=$1

	shift

	echo -n "$*"
	isin "$_a" $* || echo -n " $_a"
}

# remove all occurrences of first argument from list formed by
# the remaining arguments
rmel() {
	local	_a=$1 _b

	shift
	for _b; do
		[[ $_a != $_b ]] && echo -n "$_b "
	done
}

bsort() {
	local _l _a=$1 _b

	[[ $# -gt 0 ]] || return

	shift
	for _b; do
		if [[ $_a != $_b ]]; then
			if [[ $_a >$_b ]]; then
				_l="$_a $_l"; _a=$_b
			else
				_l="$_b $_l"
			fi
		fi
	done

	# Output the smallest value found.
	echo -n "$_a "

	# Sort remaining values.
	bsort $_l
}

# Add interesting/useful comments from mnt/etc/$1 to /tmp/$1.
#
# $1 == file in /tmp and /mnt/etc directories
save_comments() {
	local _file=$1

	if [[ -f /mnt/etc/$_file ]]; then
		grep "^#" /mnt/etc/$_file >/tmp/$_file.new
		[[ -f /tmp/$_file ]] && cat /tmp/$_file >>/tmp/$_file.new
		mv /tmp/$_file.new /tmp/$_file
	fi
}

# Offer to edit a file in /tmp and execute ${EDITOR} to do so if the user
# accepts the offer.
#
# $1 == file in /tmp to edit
edit_tmp_file() {
	local _file=$1

	ask_yn "Edit $_file with $EDITOR?"
	[[ $resp == y ]] && $EDITOR /tmp/$_file
}

# Offer to shell out for manual network configuration, and do so if
# the user accepts the offer.
manual_net_cfg() {
	ask_yn "Do you want to do any manual network configuration?"

	[[ $resp == y ]] && { echo "Type 'exit' to return to $MODE."; sh; }
}

# log in via ftp to host $1 as user $2 with password $3
# and return a list of all files in the directory $4 on stdout
ftp_list_files() {
	ftp ${_ftp_active} -V -n "$1" <<__EOT
user "$2" "$3"
cd "$4"
ls
quit
__EOT
}

# Create a device.
#
# $1 = name of the device to create.
makedev() {
	local _dev=$1

	if [[ ! -r /dev/MAKEDEV ]]; then
		echo "MAKEDEV not found. Can't create device nodes."
		return 1
	fi

	cd /dev; mksh MAKEDEV $_dev || return 1 ; cd - >/dev/null
}

# Create an entry in the hosts file. If an entry with the
# same symbolic name and address family already exists, delete it.
# $1 - IP address (v6 if it contains ':', else v4)
# $2 - symbolic name
addhostent() {
	local _addr=$1 _name=$2

	sed "/^[0-9a-fA-F]*[:.].* $_name\$/d" /tmp/hosts >/tmp/hosts.new
	mv /tmp/hosts.new /tmp/hosts

	echo "$_addr $_name" >>/tmp/hosts
}

# Show list of available sets and let the user select which sets to install.
#
# $1 = available sets
# $2 = already selected sets
#
# Set $resp to list of selected sets.
select_sets() {
	local _avail=$1 _selected=$2 _next _f _action

	cat <<__EOT

Select sets by entering a set name, a file name pattern or 'all'. De-select
sets by prepending a '-' to the set name, file name pattern or 'all'. Selected
sets are labelled '[x]'.
__EOT
	while :; do
		_action=
		_next=
		echo
		for _f in $_avail; do
			if isin $_f $_selected; then
				echo "	[X] $_f"
			else
				echo "	[ ] $_f"
				: ${_next:=$_f}
			fi
		done
		: ${_next:=done}

		ask "Set name? (or 'done')" "$_next"
		case $resp in
		done)	break ;;
		-*)	_action=rmel ;;
		esac

		: ${_action:=addel}
		resp=${resp#+|-}

		case $resp in
		"")	continue ;;
		all)	resp=* ;;
		esac

		# Use @@($resp) rather than just $resp to protect
		# against silly user input that might cause syntax
		# errors.
		for _f in $_avail; do
			eval "case $_f in
			@@($resp)) _selected=\`$_action $_f \$_selected\` ;;
			esac"
		done
	done

	resp=$_selected
}

configure_ifs() {
	local _IFDEVS=$IFDEVS _ifs _name _media _hn

	while :; do
		ask_which "interface" "do you wish to initialise" "$_IFDEVS" \
			"" "No more interfaces to initialise"
		[[ $resp == done ]] && break

		_ifs=$resp
		_hn=/tmp/hostname.$_ifs

		# Get symbolic name - will be used in DHCP requests.
		ask "Symbolic (host) name for $_ifs?" "$(hostname -s)"
		_name=$resp

		# Get and apply media options.
		_media=$(ifconfig -m $_ifs | grep "media ")
		if [[ -n $_media ]]; then
			cat <<__EOT
The media options for $_ifs are currently
$(ifconfig -m $_ifs | sed -n '/supported/D;/media:/p')
__EOT
			ask_yn "Do you want to change the media options?"
			case $resp in
			y)	cat <<__EOT
Supported media options for $_ifs are:
$_media
__EOT
				ask "Media options for $_ifs?"
				_media=$resp
				ifconfig $_ifs $_media || return 1
				;;
			n)	_media=
				;;
			esac
		fi

		rm -f $_hn
		v4_config "$_ifs" "$_media" "$_name" "$_hn"
		v6_config "$_ifs" "$_media" "$_name" "$_hn"

		[[ -f $_hn ]] && _IFDEVS=$(rmel "$_ifs" $_IFDEVS)
	done
}

# Output '<UP | DOWN> [<addr> <netmask> <rest of inet line>]'.
#
# $1 == interface
v4_info() {
	ifconfig $1 inet | sed -n '
		1s/.*<UP,.*/UP/p
		1s/.*<.*/DOWN/p
		/inet/s/netmask//
		/inet/s///p'
}

# Obtain and output the inet6 information related to the given
# interface. Should output '<UP/DOWN> <addr> <prefixlen> <rest of inet line> '.
#
# $1 == interface
v6_info() {
	ifconfig $1 inet6 | sed -n '
		1s/.*<UP,.*/UP/p
		1s/.*<.*/DOWN/p
		/scopeid/d
		/inet6/s///p'
}

# Construct etc/dhclient.conf and issue DHCP request. Return FALSE if
# no IP address assigned to $1.
#
# $1 == interface
# $2 == hostname (optional).
dhcp_request() {
	local _ifs=$1 _hn=$2

	echo "lookup file bind" >/etc/resolv.conf.tail

	if [[ -n $_hn ]]; then
		_hn="send host-name \"$_hn\";"
		echo "Issuing hostname-associated DHCP request for $_ifs."
	else
		echo "Issuing free-roaming DHCP request for $_ifs."
	fi

	cat >/etc/dhclient.conf <<__EOT
initial-interval 1;
$_hn
request subnet-mask, broadcast-address, routers, domain-name,
	domain-name-servers, host-name;
__EOT

	dhclient $_ifs

	set -- $(v4_info $_ifs)

	if [[ $1 == UP && -n $2 ]]; then
		# Move configuration files to where they will be copied to the
		# installed system. Overwrites configuration information from
		# last successful dhcp attempt.
		mv /etc/dhclient.conf /tmp/dhclient.conf
		mv /etc/resolv.conf.tail /tmp/resolv.conf.tail
		return 0
	fi
	
	ifconfig $_ifs delete down
	rm /etc/dhclient.conf /etc/resolv.conf.tail
	return 1
}

v4_config() {
	local _ifs=$1 _media=$2 _name=$3 _hn=$4 _prompt

	set -- $(v4_info $_ifs)
	if [[ -n $2 ]]; then
		ifconfig $_ifs inet $2 delete
		[[ $2 != "0.0.0.0" ]] && { _addr=$2; _mask=$3; }
	fi

	[[ -x /sbin/dhclient ]] && _prompt=" or 'dhcp'"
	_prompt="IPv4 address for $_ifs? (or 'none'$_prompt)"

	ask_until "$_prompt" "$_addr"
	case $resp in
	none)	;;
	dhcp)	if [[ ! -x /sbin/dhclient ]]; then
			echo "DHCP not possible - no /sbin/dhclient."
		elif dhcp_request $_ifs "$_name" || dhcp_request $_ifs ; then
			addhostent "127.0.0.1" "$_name"
			echo "dhcp NONE NONE NONE $_media" >>$_hn
		fi
		;;
	*)	_addr=$resp
		ask_until "Netmask?" "${_mask:=255.255.255.0}"
		if ifconfig $_ifs inet $_addr netmask $resp up ; then
			addhostent "$_addr" "$_name"
			echo "inet $_addr $resp NONE $_media" >$_hn
		fi
		;;
	esac
}

v6_config() {
	local _ifs=$1 _media=$2 _name=$3 _hn=$4 _addr _prefixlen _prompt

	ifconfig lo0 inet6 >/dev/null 2>&1 || return

	set -- $(v6_info $_ifs)
	[[ -n $2 ]] && { _addr=$2; _prefixlen=$3; }

	[[ -x /sbin/rtsol ]] && _prompt="or 'rtsol' "
	_prompt="IPv6 address for $_ifs? (${_prompt}or 'none')"
	ask_until "$_prompt" "${_addr:-none}"

	case $resp in
	none)	return
		;;
	rtsol)	[[ ! -x /sbin/rtsol ]] && { echo "No /sbin/rtsol." ; return ; }
		sysctl -w net.inet6.ip6.accept_rtadv=1
		ifconfig $_ifs up
		rtsol $_ifs
		addhostent "::1" "$_name"
		echo "up\nrtsol $media" >>$_hn
		return
		;;
	esac

	_addr=$resp
	ask_until "IPv6 prefix length for $_ifs?" "${_prefixlen:=64}"
	ifconfig $_ifs inet6 $_addr prefixlen $resp up || return
	echo "inet6 $_addr $resp $media" >>$_hn
	addhostent "$_addr" "$_name"

	v6_defroute $_ifs
	[[ $resp == none ]] && return
	route -n add -inet6 default "$resp" || return
	echo "!route -qn add -inet6 default $resp" >>$_hn
}

v4_defroute() {
	local _dr _prompt=" or 'none'"

	[[ -x /sbin/dhclient ]] && _prompt=", 'dhcp'$_prompt"
	_prompt="Default IPv4 route? (IPv4 address$_prompt)"

	_dr=$(route -n show -inet | sed -ne '/^default */{s///; s/ .*//; p;}')
	[[ -f /tmp/dhclient.conf ]] && _dr=dhcp

	while :; do
		ask_until "$_prompt" "$_dr"
		[[ $resp == @@(none|dhcp) ]] && break
		route delete -inet default >/dev/null 2>&1
		route -n add -inet default "$resp" && {
			echo "route -n add -inet default $resp" \
			    >/tmp/hostname.local
			break
		}
		# Put the old default route back. The new one did not work.
		route -n add -inet default $_dr >/dev/null 2>&1
	done
}

v6_defroute() {
	local _if=$1 _routers _oifs

	if [[ -z $(route -n show -inet6 | sed -ne '/^default */{s///; s/ .*//; p;}') ]]; then
		resp=none
		return
	fi

	if [[ -x /sbin/ping6 ]]; then
		_routers=$(ping6 -n -c 2 ff02::2%$_if 2>&1 | sed -n \
			-e '/bytes from/{s/^.*from //;s/,.*$//;p;}')
	fi

	_oifs=$IFS
	IFS=
	PS3="IPv6 default router? (list #, IPv6 address or 'none'): "
	select i in $_routers; do
		case $i in
		"")	resp=$REPLY
			[[ -n $resp ]] && break
			;;
		*)	resp=$i
			break
			;;
		esac
	done
	IFS=$_oifs
}

# Much of this is gratuitously stolen from /etc/netstart.
enable_network() {
	local _netfile

	# Copy any required or optional files found
	for _netfile in hosts dhclient.conf resolv.conf resolv.conf.tail protocols services; do
		if [ -f /mnt/etc/${_netfile} ]; then
			cp /mnt/etc/${_netfile} /etc/${_netfile}
		fi
	done

	# Set the address for the loopback interface. Bringing the
	# interface up, automatically invokes the IPv6 address ::1.
	ifconfig lo0 inet 127.0.0.1

	# configure all of the non-loopback interfaces which we know about.
	# refer to hostname.if(5)
	for hn in /mnt/etc/hostname.*; do
		# Strip off /mnt/etc/hostname. prefix
		if=${hn#/mnt/etc/hostname.}

		# Check for ifconfig'able interface.
		ifconfig $if >/dev/null 2>&1 || continue

		# Now parse the hostname.* file
		while :; do
			if [ "$cmd2" ]; then
				# we are carrying over from the 'read dt dtaddr' last time
				set -- $cmd2
				af=$1 name=$2 mask=$3 bcaddr=$4 ext1=$5 cmd2=
				# make sure and get any remaining args in ext2, like the read below
				i=1; while [ i -lt 6 -a -n "$1" ]; do shift; let i=i+1; done
				ext2="$@@"
			else
				# read the next line or exit the while loop
				read af name mask bcaddr ext1 ext2 || break
			fi
			# $af can be "dhcp", "up", "rtsol", an address family, commands, or
			# a comment.
			case $af in
			"route"|"!route")
				routep="-n $name"
				[ x"$name" = x"+n" ] && routep=
				cmd="/sbin/route ${routep} ${mask} ${bcaddr} ${ext1} ${ext2}"
				;;
			"#"*|"!"*|"bridge"|"")
				# skip comments, user commands, bridges,
				# and empty lines
				continue
				;;
			"dhcp")	[ "$name" = "NONE" ] && name=
				[ "$mask" = "NONE" ] && mask=
				[ "$bcaddr" = "NONE" ] && bcaddr=
				ifconfig $if $name $mask $bcaddr $ext1 $ext2 down
				cmd="dhclient $if"
				;;
			"rtsol")
				ifconfig $if $name $mask $bcaddr $ext1 $ext2 up
				rtsif="$rtsif $if"
				cmd=
				;;
			"up")
				# The only one of these guaranteed to be set is $if
				# the remaining ones exist so that media controls work
				cmd="ifconfig $if $name $mask $bcaddr $ext1 $ext2 up"
				;;
			*)	read dt dtaddr
				if [ "$name" = "alias" ]; then
					# perform a 'shift' of sorts
					alias=$name
					name=$mask
					mask=$bcaddr
					bcaddr=$ext1
					ext1=$ext2
					ext2=
				else
					alias=
				fi
				cmd="ifconfig $if $af $alias $name "
				case $dt in
				dest)	cmd="$cmd $dtaddr"
					;;
				[a-z!]*)
					cmd2="$dt $dtaddr"
					;;
				esac
				if [ ! -n "$name" ]; then
					echo "/mnt/etc/hostname.$if: invalid network configuration file"
					return
				fi
				case $af in
				inet)	[ "$mask" ] && cmd="$cmd netmask $mask"
					if [ "$bcaddr" -a "$bcaddr" != "NONE" ]; then
						cmd="$cmd broadcast $bcaddr"
					fi
					[ "$alias" ] && rtcmd="; route -qn add -host $name 127.0.0.1"
					;;
				inet6)
					[ "$mask" ] && cmd="$cmd prefixlen $mask"
					cmd="$cmd $bcaddr"
					;;
				*)	cmd="$cmd $mask $bcaddr"
				esac
				cmd="$cmd $ext1 $ext2$rtcmd" rtcmd=
				;;
			esac
			eval "$cmd"
		done </mnt/etc/hostname.$if
	done

	# Use loopback, not the wire.
	route -qn add -host $(hostname) 127.0.0.1 >/dev/null
	route -qn add -net 127 127.0.0.1 -reject >/dev/null

	# Grab default route, if existent
	if [ -s /mnt/etc/hostname.local ]; then
		cmd="$(grep ^route /mnt/etc/hostname.local | grep default)"
		[[ -n $cmd ]] && eval "$cmd"
	fi

	# Display results...
	echo "Network interface configuration:"
	ifconfig -am

	# enable the resolver if resolv.conf is available
	route -n show
	if [ -f /etc/resolv.conf ]; then
		echo "\nResolver enabled."
	else
		echo "\nResolver not enabled."
	fi
}

# Install a user-selected subset of the files in $2 from the source
# named in $1. Display an error message for failed installs so the
# user will know to try again.
install_files() {
	local _src=$1 _files=$2 _f _sets _get_sets

	# Initialize _sets to the list of sets found in _src, and initialize
	# _get_sets to the intersection of _sets and DEFAULTSETS.
	#
	# Sets will be installed in the order given in THESETS to ensure proper
	# installation. So, to minimize user confusion display the sets in the
	# order in which they will be installed.
	for _f in $THESETS; do
		isin $_f $_files || continue;
		_sets=$(addel $_f $_sets)
		isin $_f $DEFAULTSETS && _get_sets=$(addel $_f $_get_sets)
	done

	if [[ -z $_sets ]]; then
		# Show $_src, but delete any ftp password.
		cat <<__EOT
No $OBSD sets were found at

	$(echo $_src | sed -e 's/\(^ftp:\/\/[^/]*\)\(:[^/]*\)\(@@.*\)/\1\3/')

Set names are: $THESETS
__EOT
		return
	fi

	select_sets "$_sets" "$_get_sets"

	[[ -n $resp ]] || return
	_get_sets=$resp

	ask_yn "Ready to $MODE sets?" yes
	[[ $resp = n ]] && return

	for _f in $THESETS; do
		isin $_f $_get_sets || continue
		echo "Getting $_f ..."
		case $_f in
		*.ngz)	ftp $_ftp_active -o - -V -m "$_src/$_f" | tar zxphf - -C /mnt
			;;
		*)	ftp $_ftp_active -o "/mnt/$_f" -V -m "$_src/$_f"
			;;
		esac
		if [ $? -ne 0 ]; then
			echo "'$_f' did not install correctly."
		else
			DEFAULTSETS=$(rmel $_f $DEFAULTSETS)
		fi
	done
}

# Encode $1 as specified for usercodes and passwords in RFC 1738
# section 3.1 and section 5.
#
# Escape everything between 0x20 and 0x7e to avoid both illegal url
# characters and characters causing problems during script processing.
#
# *NOTE*
#	1) quotes around $1 are required to preserve trailing or
#	   embeddded blanks in usercodes and passwords.
#	2) substitute '%' FIRST so it doesn't eliminate '%' chars we insert.
encode_for_url() {
	echo "$1" | sed -e "
s/%/%25/g
s/ /%20/g
s/!/%21/g
s/\"/%22/g
s/#/%23/g
s/\\\$/%24/g
s/&/%26/g
s/'/%27/g
s/(/%28/g
s/)/%29/g
s/\*/%2a/g
s/+/%2b/g
s/,/%2c/g
s/-/%2d/g
s/\./%2e/g
s/\//%2f/g
s/:/%3a/g
s/;/%3b/g
s/</%3c/g
s/=/%3d/g
s/>/%3e/g
s/?/%3f/g
s/@@/%40/g
s/\[/%5b/g
s/\\\\/%5c/g
s/]/%5d/g
s/\^/%5e/g
s/_/%5f/g
s/\`/%60/g
s/{/%7b/g
s/|/%7c/g
s/}/%7d/g
s/~/%7e/g
"
}

# Check for the presence of an error message in the output of the ftp commands
# used to get the list of files in a directory.
#
# $1 = error message to look for
# $2 = ftp command output
ftp_error() {
	if [[ -n $(echo "$2" | grep "$1") ]]; then
		echo $1
		return 0
	fi
	return 1
}

# Get several parameters from the user, and xfer
# files from the server.
# $1 = url type (ftp or http)
# Note:	_ftp_server_ip, _ftp_server_dir, _ftp_server_login,
#	and _ftp_active must be global.
install_url() {
	local _url_type=$1 _file_list _url_base _oifs _prompt _passwd

	ask "HTTP/FTP proxy URL? (e.g. 'http://proxy:8080', or 'none')" \
	    "${ftp_proxy:-none}"
	unset ftp_proxy http_proxy
	[[ $resp == none ]] || export ftp_proxy=$resp http_proxy=$resp

	rm -f $SERVERLIST
#	ask_yn "Display the list of known $_url_type servers?" "${_get_server_list:-yes}"
#	_get_server_list=$resp
	_get_server_list=n
#	if [[ $_get_server_list == y ]]; then
#		# ftp.openbsd.org == 129.128.5.191 and will remain at
#		# that address for the forseeable future.
#		echo -n "Getting the list from 129.128.5.191 (ftp.openbsd.org)..."
#		ftp $_ftp_active -V -a -o - \
#			ftp://129.128.5.191/$FTPDIR/ftplist 2>/tmp/ftplisterr \
#			| sed -ne "/^${_url_type}:\/\//s///p" >$SERVERLIST
#		if [[ -s $SERVERLIST ]]; then
#			echo "done."
#			_prompt="Server? (IP address, hostname, list#, 'done' or '?')"
#			cat -n $SERVERLIST | less -XE
#		else
#			echo "FAILED."
#			cat /tmp/ftplisterr
#		fi
#	fi

	# Get server IP address or hostname
	: ${_prompt:="Server? (IP address, hostname or 'done')"}
	while :; do
		eval resp=\$_${_url_type}_server_ip
		ask_until "$_prompt" "$resp"
		case $resp in
		done)	return ;;
		"?")	[[ -s $SERVERLIST ]] || continue
			cat -n $SERVERLIST | less -XE
			;;
		+([0-9]))
			# A numeric hostname is ignored. A number is only used
			# as a line number in $SERVERLIST.
			[[ -s $SERVERLIST ]] || continue
			set -- $(sed -ne "${resp}p" $SERVERLIST)
			[[ $# -lt 1 ]] && { echo "There is no line $resp."; continue; }
			echo "Using	$*"
			eval _${_url_type}_server_ip=${1%%/*}
			eval _${_url_type}_server_dir=${1#*/}/$SETDIR
			# Repeat loop to get user to confirm server address.
			;;
		*)	eval _${_url_type}_server_ip=$resp
			break
			;;
		esac
	done

	# Some older servers lie about their support for passive mode ftp, so
	# ask the user if it worth trying passive mode to the chosen server.
	# Irrelevant if using a proxy.
	if [[ $_url_type == ftp && -z $ftp_proxy ]]; then
		case $_ftp_active in
		-A)	resp=no ;;
		*)	resp=yes ;;
		esac

		unset _ftp_active
		ask_yn "Does the server support passive mode ftp?" $resp
		[[ $resp == n ]] && _ftp_active=-A
	fi

	# Get server directory
	eval resp=\$_${_url_type}_server_dir
	ask_until "Server directory?" "${resp:-$SETDIR}"
	eval _${_url_type}_server_dir=$resp

	if [[ $_url_type == ftp ]]; then
		# Get login name, setting IFS to nothing so trailing or
		# embedded blanks are preserved!
		_oifs=$IFS
		IFS=
		ask_until "Login?" "${_ftp_server_login:=anonymous}"
		_ftp_server_login=$resp

		# Get password unless anonymous
		_passwd=root@@$(hostname)
		if [[ $_ftp_server_login != anonymous ]]; then
			resp=
			while [[ -z $resp ]]; do
				askpass "Password? (will not echo)"
			done
			_passwd=$resp
		fi
		IFS=$_oifs
	fi

	# Build up the base url since it is so nasty...
	_url_base=$_url_type://
	if [[ $_url_type == ftp && $_ftp_server_login != anonymous ]]; then
		_url_base=$_url_base$(encode_for_url "$_ftp_server_login"):$(encode_for_url "$_passwd")@@
	fi
	eval _url_base=$_url_base\$_${_url_type}_server_ip/\$_${_url_type}_server_dir

	# XXX Workaround for problems ftp'ing out from a v6 only host.
	ifconfig lo0 127.0.0.1

	# Get list of files from the server.
	if [[ $_url_type == ftp && -z $ftp_proxy ]]; then
		_file_list=$(ftp_list_files "$_ftp_server_ip" "$_ftp_server_login" "$_passwd" "$_ftp_server_dir")
		ftp_error "Login failed." "$_file_list" && return
		ftp_error "No such file or directory." "$_file_list" && return
	else
		# Assumes index file is "index.txt" for http (or proxy)
		# We can't use index.html since the format is server-dependent
		_file_list=$(ftp -o - -V "$_url_base/index.txt" | sed 's///')
	fi

	install_files "$_url_base" "$_file_list"
}

install_mounted_fs() {
	local _dir

	while :; do
		ask_until "Pathname to the sets? (or 'done')" "$SETDIR"
		[[ $resp == done ]] && return
		# Accept a valid /mnt2 or /mnt relative path.
		[[ -d /mnt2/$resp ]] && { _dir=/mnt2/$resp ; break ; }
		[[ -d /mnt/$resp ]] && { _dir=/mnt/$resp ; break ; }
		# Accept a valid absolute path.
		[[ -d /$resp ]] && { _dir=/$resp ; break ; }
		echo "The directory '$resp' does not exist."
	done

	install_files "file://$_dir" "$(ls -l $_dir)"
}

install_cdrom() {
	local _drive _part=c _fstype _err=0

	get_drive "CD-ROM" "$CDDEVS" || return
	_drive=$resp

	set -- $(disklabel $_drive 2>&1 | grep '^  c: ') || _err=1
	case $_err:$4 in
	1*|0:ISO9660)
		_fstype=cd9660 ;;
	0:UDF)	_fstype=udf ;;
	*)	get_partition $_drive "cd9660" || return
		set -- $resp
		_part=$1
		[[ -n $2 ]] && _fstype=$2
		;;
	esac

	mount -t $_fstype -o ro /dev/$_drive$_part /mnt2 || return
	install_mounted_fs
}

install_disk() {
	local _drive _dev _fstype _fsopts

	ask_yn "Is the disk partition already mounted?"
	if [[ $resp == n ]]; then
		get_drive "disk" "$DKDEVS" || return
		_drive=$resp

		get_partition $_drive "$MDFSTYPE" || return
		set -- $resp
		_dev=/dev/$_drive$1
		[[ -n $2 ]] && _fstype="-t $2"
		[[ $_fstype == $MDFSTYPE ]] && _fsopts=$MDFSOPTS

		if [[ -z $(mount | grep "^$_dev") ]]; then
			mount $_fstype -o ro,$_fsopts $_dev /mnt2 || return
		fi
	fi
	install_mounted_fs
}

install_nfs() {
	local _tcp

	# Get the IP address of the server.
	ask_until "Server IP address or hostname?" "$NFS_ADDR"
	NFS_ADDR=$resp

	# Get the server path to mount.
	ask_until "Filesystem on server to mount?" "$NFS_PATH"
	NFS_PATH=$resp

	# Determine use of TCP
	ask_yn "Use TCP transport? (requires TCP-capable NFS server)" yes
	[[ $resp == y ]] && _tcp=-T

	# Mount the server
	mount_nfs $_tcp -o ro $NFS_ADDR:$NFS_PATH /mnt2 || return

	install_mounted_fs
}

install_tape() {
	local _z _bs

	# Get the name of the tape device.
	get_drive "tape drive" "$MTDEVS" || return
	export TAPE=/dev/nr$resp
	if [[ ! -c $TAPE ]]; then
		echo "$TAPE is not a character special file."
		return
	fi

	# Rewind the tape device.
	echo -n "Rewinding $TAPE (mt rewind)..."
	mt rewind || return
	echo "done."

	# Extract the desired files.
	while :; do
		ask_until "Skip how many files? (or 'done')" 0
		[[ $resp == done ]] && return
		[[ $resp == +([0-9]) ]] || continue
		(($resp < 0)) && continue

		if (($resp > 0)); then
			echo -n "Skipping $resp file(s)..."
			mt fsf $resp || return
			echo "done."
		elif [[ -n $_bs ]]; then
			# Dance to start of next file.
			mt bsf ; mt fsf
		fi

		unset _z
		ask_yn "Is the file gzipped?" yes
		[[ $resp == y ]] && _z=z

		# Get the blocksize to use. If the file isn't gzipped then
		# default to the 20 x 512 = 10,240 byte tar default.
		[[ $_z == z ]] || _bs=10240
		ask_until "Blocksize for this file?" "${_bs:-8k}"
		[[ $resp == done ]] && return
		_bs=$resp

		dd if=$TAPE bs=$_bs | tar ${_z}xvphf - -C /mnt || return
	done
}

set_timezone() {
	local _zoneroot=/mnt/usr/share/zoneinfo/ _zonepath

	# If the timezone directory structure is not
	# available, return immediately.

	[[ ! -d $_zoneroot ]] && return

	if [[ -L /mnt/etc/localtime ]]; then
		TZ=$(ls -l /mnt/etc/localtime 2>/dev/null)
		TZ=${TZ#*${_zoneroot#/mnt}}
	fi

	: ${TZ:=GMT}

	while :; do
		_zonepath=$_zoneroot

		ask "What timezone are you in? ('?' for list)" "$TZ"

		if [[ $resp == ? ]]; then
			ls -F ${_zonepath}
			continue;
		fi

		_zonepath=${_zonepath}${resp}

		while [[ -d $_zonepath ]]; do
			ask "What sub-timezone of '${_zonepath#$_zoneroot}' are you in? ('?' for list)"
			case $resp in
			"")	;;
			?)	ls -F $_zonepath ;;
			*)	_zonepath=$_zonepath/$resp ;;
			esac
		done

		if [[ -f $_zonepath ]]; then
			TZ=${_zonepath#$_zoneroot}
			echo -n "Setting local timezone to '$TZ'..."
			ln -sf /usr/share/zoneinfo/$TZ /mnt/etc/localtime
			echo "done."
			return
		fi

		echo -n "'${_zonepath#$_zoneroot}'"
		echo " is not a valid timezone on this system."
	done
}

# Check with the user that missing required sets were deliberately skipped.
sane_install() {
	local _s _m

	for _s in $SANESETS; do
		isin $_s $DEFAULTSETS || continue
		ask_yn "'$_s' was not installed.\nAre you *SURE* your $MODE is complete without '$_s'?"
		[[ $resp == n ]] && _m="$_m $_s"
	done

	[[ -n $_m ]] && return 1
	return 0
}

# Ask the user for locations of sets, and then install whatever sets the
# user selects from that location. Repeat as many times as the user
# needs to get all desired sets.
install_sets() {
	local _d=disk _locs="disk ftp http"

	[[ -n $CDDEVS ]] && { _locs="cd $_locs" ; _d=cd ; }
	[[ -x /sbin/mount_nfs ]] && _locs="$_locs nfs"
	[[ -n $MTDEVS && -x /bin/mt ]] && _locs="$_locs tape"

	echo "\nLet's $MODE the sets!"
	while :; do
		umount -f /mnt2 >/dev/null 2>&1
		[[ -z $DEFAULTSETS ]] && _d=done

		ask "Location of sets? ($_locs or 'done')" "$_d"
		case $resp in
		done)	sane_install && return ;;
		c*|C*)	isin "cd" $_locs && install_cdrom ;;
		d*|D*)	install_disk ;;
		f*|F*)	isin "ftp" $_locs && install_url ftp ;;
		h*|H*)	isin "http" $_locs && install_url http ;;
		n*|N*)	isin "nfs" $_locs && install_nfs ;;
		t*|T*)	isin "tape" $_locs && install_tape ;;
		esac
	done
}

# Create a skeletal but useful /etc/fstab from /tmp/fstab by stripping all
# comment lines and dropping all filesystems which
#
#       1) can't be mounted (no mount_* command is found),
#	2) have 'xx' in the option field (usually /altroot),
#	3) have 'noauto' in the option field,
#	4) are nfs (since name resolution may not be present),
#	5) are mfs (breaks install usually).
#
# In addition,
#
#	2) mount non-ffs filesystems read only,
#	3) prepend '/mnt' to all mount points,
#	4) delete any trailing '/' from the mount point (e.g. root),
#	5) leave out fs_freq and fs_passno fields.
#
# If no /etc/fstab is created, do not proceed with install/upgrade.
munge_fstab() {
	local _dev _mp _fstype _opt _rest

	while read _dev _mp _fstype _opt _rest; do
		# Drop irrelevant lines and filesystems.
		[[ $_dev == \#* || \
		    $_fstype == nfs || \
		    $_fstype == mfs || \
		    ! -f /sbin/mount_$_fstype || \
		    $_opt == *noauto* || \
		    $_opt == *xx* ]] && continue

		# Mount non-ffs filesystems read only.
		[[ $_fstype == ffs ]] || _opt=$(echo $_opt | sed -e 's/rw/ro/')

		# Write fs entry in fstab.
		# 1) prepend '/mnt' to the mount point.
		# 2) remove a trailing '/' from the mount point (e.g. root).
		# 3) leave out fs_freq and fs_passno fields (i.e. $_rest).
		echo $_dev /mnt${_mp%/} $_fstype $_opt

	done </tmp/fstab >/etc/fstab

	# If no /etc/fstab was created, we have nowhere to $MODE to.
	if [ ! -s /etc/fstab ]; then
		echo "Unable to create valid /etc/fstab."
		exit
	fi
}

# Must mount filesystems manually, one at a time, so we can make
# sure the mount points exist.
mount_fs() {
	local _async=$1 _dev _mp _fstype _opt _rest

	while read _dev _mp _fstype _opt _rest; do
		# If not the root filesystem, make sure the mount
		# point is present.
		[ "$_mp" = "/mnt" ] || mkdir -p $_mp

		# Mount the filesystem. If the mount fails, exit.
		mount -v -t $_fstype $_async -o $_opt $_dev $_mp && continue
		# If it failed, try without async (important for raid) first
		mount -v -t $_fstype         -o $_opt $_dev $_mp && continue
		# In addition to the error message displayed by mount ...
		cat <<__EOT

FATAL ERROR:	Cannot mount filesystems. Double-check your configuration
		and restart the $MODE.

__EOT
		exit
	done </etc/fstab
}

# Preen all filesystems in /etc/fstab that have a /sbin/fsck_XXX,
# showing individual results, but skipping $ROOTDEV. This was already
# fsck'ed successfully.
#
# Exit if any fsck's fail (but do them all before exiting!).
check_fs() {
	local _dev _mp _fstype _rest _fail

	echo "Checking non-root filesystems..."

	while read _dev _mp _fstype _rest; do
		[ "$_dev" != /dev/"$ROOTDEV" ] || continue
		[ -f "/sbin/fsck_$_fstype" ] || continue
		# Make sure device exists before fsck'ing it.
		_rest=${_dev#/dev/}
		makedev ${_rest%[a-p]} || continue
		echo -n "fsck -p ${_dev}..."
		if ! fsck -fp ${_dev} >/dev/null 2>&1; then
			echo "FAILED. You must fsck $_dev manually."
			_fail=y
		else
			echo "OK."
		fi
	done </etc/fstab

	echo "...done."

	[ "$_fail" ] && exit
}

# Extract fully qualified domain name from current hostname. If none is
# currently set, use 'my.domain'.
get_fqdn() {
	local _dn

	_dn=$(hostname)
	_dn=${_dn#$(hostname -s)}
	_dn=${_dn#.}

	echo "${_dn:=my.domain}"
}

donetconfig() {
	local _dn _ns _n

	configure_ifs

	# As dhclient will populate /etc/resolv.conf, a symbolic link to
	# /tmp/resolv.conf.shadow, mv any such file to /tmp/resolv.conf
	# so it will eventually be copied to /mnt/etc/resolv.conf and will
	# not in the meantime remove the user's ability to choose to use it
	# or not, during the rest of the install.
	if [ -f /tmp/resolv.conf.shadow ]; then
		mv /tmp/resolv.conf.shadow /tmp/resolv.conf
		# Get nameserver address(es). Store as a blank separated list.
		for _n in $(grep '^nameserver ' /tmp/resolv.conf); do
			[[ $_n == nameserver ]] || _ns="$_ns$_n "
		done
		# Zap trailing space in _ns.
		set -- $_ns
		_ns=$*
		# Get default fully qualified domain name from *first* domain
		# given on *last* search or domain statement.
		_dn=$(sed -n \
			-e '/^domain[[:space:]][[:space:]]*/{s///;s/\([^[:space:]]*\).*$/\1/;h;}' \
			-e '/^search[[:space:]][[:space:]]*/{s///;s/\([^[:space:]]*\).*$/\1/;h;}' \
			-e '${g;p;}' /tmp/resolv.conf)
	fi

	# Get & apply fully qualified domain name to hostname.
	ask "DNS domain name? (e.g. 'bar.com')" "${_dn:=$(get_fqdn)}"
	hostname "$(hostname -s).$resp"

	# Get/Confirm nameservers, and construct appropriate resolv.conf.
	ask "DNS nameserver? (IP address or 'none')" "${_ns:=none}"
	if [[ $resp != none ]]; then
		echo "lookup file bind" >/tmp/resolv.conf
		for _ns in $resp; do
			echo "nameserver $_ns" >>/tmp/resolv.conf
		done
		ask_yn "Use the nameserver now?" yes
		[[ $resp == y ]] && cp /tmp/resolv.conf /tmp/resolv.conf.shadow
	fi

	# Get/Confirm an IPv4 default route if an IPv4 address was configured.
	[[ -n $(ifconfig -a | sed -ne '/[ 	]inet .* broadcast /p') ]] && v4_defroute

	edit_tmp_file hosts
	manual_net_cfg
	[[ -x /usr/sbin/ntpd ]] && /usr/sbin/ntpd -s
}

questions() {
	local _bd _td

	ask_yn "Start sshd(8) by default?" yes
	if [[ $resp == n ]]; then
		echo "sshd_flags=NO		# disabled during install" \
		    >>/mnt/etc/rc.conf.local
	fi

	ask_yn "Start ntpd(8) by default?" yes
	if [[ $resp == y ]]; then
		echo "ntpd_flags=-s		# enabled during install" \
		    >>/mnt/etc/rc.conf.local
	fi

	if [[ -n $MDXAPERTURE ]]; then
		echo 'This setting affects the machdep.allowaperture sysctl.'
		echo 'If you respond negatively, you must enable it later in'
		echo '/etc/sysctl.conf in order to be able to run XFree86®.'
		ask_yn "Do you expect to run the X Window System?"
		if [[ $resp == y ]]; then
			sed -e "/^#\(machdep\.allowaperture=${MDXAPERTURE}\)/s//\1	/" \
			    /mnt/etc/sysctl.conf >/tmp/sysctl.conf
			cp /tmp/sysctl.conf /mnt/etc/sysctl.conf
		fi
	fi

	[[ -z $SERIALDEV ]] && return
	set -- $SERIALDEV
	_bd=$1
	_td=$2
	ask_yn "Change the default console to $_bd?"
	[[ $resp == n ]] && return
	ask_which "speed" "should $_bd use" "9600 19200 38400 57600 115200"
	[[ $resp == done ]] && return
	echo "set tty $_bd\nstty $_bd $resp" >>/mnt/etc/boot.cfg
	sed	-e "/^${_td}/s/std.9600/std.${resp}/" \
		-e "/^${_td}/s/unknown/vt220	/" \
		-e "/${_td}/s/off/on secure/" /mnt/etc/ttys >/tmp/ttys
}

finish_up() {
	local _dev _mp _fstype _rest

	# Mount all known swap partitions.  This gives systems with little
	# memory a better chance at running 'MAKEDEV all'.
	if [[ -x /mnt/sbin/swapctl ]]; then
		/mnt/sbin/swapctl -a /dev/$SWAPDEV >/dev/null 2>&1
		# Can't do chmod && swapctl -A because devices are not yet
		# created on install'ed systems. On upgrade'ed system there
		# is a small chance the device does not exist on the ramdisk
		# and will thus not get mounted.
		while read _dev _mp _fstype _rest; do
			[[ $_fstype == swap ]] && \
			    /mnt/sbin/swapctl -a $_dev >/dev/null 2>&1
		done </mnt/etc/fstab
	fi

	if grep -qs '^rtsol' /mnt/etc/hostname.*; then
		sed -e "/^#\(net\.inet6\.ip6\.accept_rtadv\)/s//\1/" \
		    /mnt/etc/sysctl.conf >/tmp/sysctl.conf
		cp /tmp/sysctl.conf /mnt/etc/sysctl.conf
	fi

	echo -n "Making all device nodes..."
	cd /mnt/dev
	sh MAKEDEV all
	# Make sure any devices we found during probe are created in the
	# installed system.
	for _dev in $DKDEVS $CDDEVS $MTDEVS; do
		sh MAKEDEV $_dev
	done
	echo "done."
	cd /

	md_installboot $ROOTDISK

	[ -x /mnt/$MODE.site ] && /mnt/usr/sbin/chroot /mnt /$MODE.site

	# Pat on the back.
	cat <<__EOT

CONGRATULATIONS! Your MirBSD $MODE has been successfully completed!
To boot the new system, enter halt at the command prompt. Once the
system has halted, reset the machine and boot from the disk.

Hello there! We from the MirOS project would like to hear from you!
If you installed or updated your existing MirOS installation, which
architecture, maybe your country, a dmesg and a few words about how
you like MirOS. If you don't mind being counted to help us estimate
our userbase, mail to <miros-dev@@66h.42h.de> - thanks in advance!
__EOT

	md_congrats
}

# #######################################################################
#
# Initial actions common to both installs and upgrades.
#
# Some may require machine dependent routines, which may
# call functions defined above, so it's safest to put this
# code here rather than at the top of the file.
#
# #######################################################################

ROOTDISK=
ROOTDEV=

VERSION=9

SETDIR="v${VERSION}/$ARCH"
OBSD="MirOS BSD #$VERSION/$ARCH"
SERVERLIST=/tmp/serverlist

# Do not limit ourselves during installs or upgrades.
for _opt in d f l m n p s; do
	ulimit -$_opt unlimited
done

# Extract and save one boot's worth of dmesg
dmesg | sed -ne '/^MirBSD /h;/^MirBSD /!H;${g;p;}' >/var/run/dmesg.boot

# Scan /var/run/dmesg.boot for interesting devices.
DKDEVS=$(scan_dmesg "${MDDKDEVS:-/^r*a*[swi]d[0-9][0-9]* /s/ .*//p}")
CDDEVS=$(scan_dmesg "${MDCDDEVS:-/^cd[0-9][0-9]* /s/ .*//p}")
MTDEVS=$(scan_dmesg "${MDMTDEVS:-/^[cmsw]t[0-9][0-9]* /s/ .*//p}")
IFDEVS=$(get_ifdevs)
SERIALDEV=$(get_serialdev)

# Selected sets will be installed in the order they are listed in $THESETS.
# Ensure that siteXX.ngz is the *last* set listed so its contents overwrite
# the contents of the other sets, not the other way around.
THESETS="bsd bsd.rd $MDSETS"
DEFAULTSETS="bsd"
for _set in base etc gnu dev xbase xetc pkgutl ports source xfree site; do
	[[ $MODE == upgrade && $_set == ?(x)etc ]] && continue
	THESETS="$THESETS ${_set}${VERSION}.ngz"
	isin $_set xbase xetc pkgutl ports source xfree site || \
	    DEFAULTSETS="$DEFAULTSETS ${_set}${VERSION}.ngz"
done
# Since etc${VERSION}.ngz is not in DEFAULTSETS for upgrades, it can always be
# in SANESETS.
SANESETS="bsd base${VERSION}.ngz etc${VERSION}.ngz"

# decide upon an editor
: ${EDITOR:=ed}
[[ -x /usr/bin/vi ]] && EDITOR=vi
export EDITOR

# umount all filesystems, just in case we are re-running install or upgrade.
[[ -f /etc/fstab ]] && umount -av 1>/dev/null 2>&1
umount -v /mnt 1>/dev/null 2>&1

# Introduce ourselves.
welcome

# Get ROOTDISK, ROOTDEV and SWAPDEV.
if [[ $MODE == install && ! -f /etc/fstab ]]; then
	cat <<__EOT

You will now initialise the disk(s) that MirBSD will use. To enable all
available security features you should configure the disk(s) to allow the
creation of separate filesystems for /, /tmp, /var, /usr, and /home.

__EOT
fi

set -- $DKDEVS
[[ $# -gt 1 ]] && _defdsk=done

ask_which "disk" "is the root disk" "$DKDEVS" "$_defdsk"
[[ $resp == done ]] && exit
makedev $resp || exit

ROOTDISK=$resp
ROOTDEV=${ROOTDISK}a
SWAPDEV=${ROOTDISK}b
@


1.24
log
@show which terminal types are supported
@
text
@d1 1
a1 1
# $MirOS: src/distrib/miniroot/install.sub,v 1.23 2006/06/16 15:57:52 tg Exp $
@


1.23
log
@of course, this is MirOS #9
@
text
@d1 1
a1 1
# $MirOS: src/distrib/miniroot/install.sub,v 1.22 2006/04/06 11:15:50 tg Exp $
d89 2
@


1.22
log
@if ntpd exists, run it after network config
(kludge; I hate the old installer; besides, I'd prefer enabling network early)
@
text
@d1 1
a1 1
# $MirOS: src/distrib/miniroot/install.sub,v 1.21 2006/03/16 13:41:57 tg Exp $
d1626 1
a1626 1
VERSION=8
@


1.21
log
@default machdep.allowaperture to 0, idea from Theo (OpenBSD)
cf. http://undeadly.org/cgi?action=article&sid=20060315005122&mode=expanded
adapted because MirOS targets routers, servers and developer workstations
@
text
@d1 1
a1 1
# $MirOS: src/distrib/miniroot/install.sub,v 1.20 2006/01/11 20:42:12 tg Exp $
d1514 1
@


1.20
log
@since when is the default route a host route?
@
text
@d1 1
a1 1
# $MirOS: src/distrib/miniroot/install.sub,v 1.19 2005/12/23 13:16:03 tg Exp $
d1535 1
a1535 1
		ask_yn "Do you expect to run the X Window System?" yes
@


1.19
log
@change the 'set tty com0' and 'stty com0 <speed>' order in boot.cfg
Rationale:
* on the Soekris, it somehow doesn't allow interaction either way
* on the Strato Dedicated Server, only this order allows interaction
* no manual or anything specifies something
* the code makes me think this order is better
@
text
@d1 1
a1 1
# $MirOS: src/distrib/miniroot/install.sub,v 1.18 2005/12/21 18:14:57 tg Exp $
d705 2
a706 2
	route -n add -inet6 -host default "$resp" || return
	echo "!route -qn add -host -inet6 default $resp" >>$_hn
d722 2
a723 2
		route -n add -inet -host default "$resp" && {
			echo "route -n add -inet -host default $resp" \
d728 1
a728 1
		route -n add -inet -host default $_dr >/dev/null 2>&1
@


1.18
log
@it's boot.cfg not boot.conf
@
text
@d1 1
a1 1
# $MirOS: src/distrib/miniroot/install.sub,v 1.17 2005/12/19 17:09:48 tg Exp $
d1551 1
a1551 1
	echo "stty $_bd $resp\nset tty $_bd" >>/mnt/etc/boot.cfg
@


1.17
log
@work around a weird problem:

On 2005-12-07 I made an ISO (500-some MiB) of the snapshot,
bootable and everything, which I distributed. I also burnt
the ISO to a CD-R medium (to more than one, but I gave the
others away, for free even).

I tested the ISO file before distributing, and everything
worked fine. I can also vnconfig(8) it and disklabel(8)
shows a correct slice table.

I installed from the medium I burnt on HERC, and no problem
occured, with an UltraPLEX 24x SCSI-CD ROM drive.

The very same physical medium in ODEM showed a weird beha-
viour which I forgot until bsiegert@@ had the same while
installing from the ISO file onto MS Virtual PC for Mac:
# disklabel cd0
disklabel: can't read partition table: Invalid argument

The workaround in the installer is, that, when no disklabel
can be read and we know it's supposed to be a CD-ROM, to
just assume the 'c' slice is a correct ISO9660 filesystem.
@
text
@d1 1
a1 1
# $MirOS: src/distrib/miniroot/install.sub,v 1.16 2005/12/07 12:45:55 tg Exp $
d1551 1
a1551 1
	echo "stty $_bd $resp\nset tty $_bd" >>/mnt/etc/boot.conf
@


1.16
log
@we won't have a "sym" set
@
text
@d1 1
a1 1
# $MirOS: src/distrib/miniroot/install.sub,v 1.15 2005/12/07 07:34:34 tg Exp $
d1152 1
a1152 1
	local _drive _part=c _fstype
d1157 9
a1165 8
	set -- $(disklabel $_drive 2>&1 | grep '^  c: ')
	case $4 in
	ISO9660) _fstype=cd9660 ;;
	UDF)	 _fstype=udf ;;
	*)	 get_partition $_drive "cd9660" || return
		 set -- $resp
		 _part=$1
		 [[ -n $2 ]] && _fstype=$2
@


1.15
log
@default ntpd to yes
@
text
@d1 1
a1 1
# $MirOS: src/distrib/miniroot/install.sub,v 1.14 2005/12/06 12:53:37 tg Exp $
d1650 1
a1650 1
for _set in base etc gnu dev xbase xetc pkgutl ports source xfree sym site; do
d1653 1
a1653 1
	isin $_set xbase xetc pkgutl ports source xfree sym site || \
@


1.14
log
@* SANESETS contains base${VERSION}.tgz? no way!
* when adding a new set, add it here, d'oh
* optimise while here
@
text
@d1 1
a1 1
# $MirOS: src/distrib/miniroot/install.sub,v 1.13 2005/12/06 12:44:02 tg Exp $
d1524 1
a1524 1
	ask_yn "Start ntpd(8) by default?" no
@


1.13
log
@british spelling
@
text
@d1 1
a1 1
# $MirOS: src/distrib/miniroot/install.sub,v 1.12 2005/12/06 12:42:19 tg Exp $
a1633 3
# Since etc${VERSION}.ngz is not in DEFAULTSETS for upgrades, it can always be
# in SANESETS.
SANESETS="bsd base${VERSION}.ngz etc${VERSION}.ngz"
d1650 1
a1650 1
for _set in base etc gnu dev xbase xetc pkgutl ports source xfree site; do
d1653 2
a1654 2
	isin $_set xbase xetc pkgutl ports source xfree site && continue
	DEFAULTSETS="$DEFAULTSETS ${_set}${VERSION}.ngz"
d1656 1
a1656 1
# Since etc${VERSION}.tgz is not in DEFAULTSETS for upgrades, it can always be
d1658 1
a1658 1
SANESETS="bsd base${VERSION}.tgz etc${VERSION}.tgz"
@


1.12
log
@we're no longer OpenBSD/i386 0.8 or something
@
text
@d1 1
a1 1
# $MirOS: src/distrib/miniroot/install.sub,v 1.11 2005/11/19 21:50:38 tg Exp $
d534 2
a535 2
		ask_which "interface" "do you wish to initialize" "$_IFDEVS" \
			"" "No more interfaces to initialize"
d1679 1
a1679 1
You will now initialize the disk(s) that MirBSD will use. To enable all
@


1.11
log
@Message-ID: <200500092623.j8QNbWj8006315@@duriel.aibnet.de>
@
text
@d1 1
a1 1
# $MirOS: src/distrib/miniroot/install.sub,v 1.10 2005/09/26 22:55:26 tg Exp $
a1625 1
VNAME="$(( $VERSION / 10 )).$(( $VERSION % 10 ))"
d1627 1
a1627 1
OBSD="MirOS/BSD/$ARCH $VNAME"
@


1.10
log
@* fix syntax error
* somehow add back raid support (basic regexps SUCK)
@
text
@d1 1
a1 1
# $MirOS: src/distrib/miniroot/install.sub,v 1.9 2005/07/24 16:44:13 tg Exp $
a1514 6
populateusrlocal() {
	if [ -f /mnt/etc/mtree/BSD.local.dist ]; then
		/mnt/usr/sbin/chroot /mnt /usr/sbin/mtree -Uedqn -p /usr/local -f /etc/mtree/BSD.local.dist >/dev/null
	fi
}

d1526 1
a1526 1
		echo "ntpd_flags=		# enabled during install" \
a1591 2
	populateusrlocal

@


1.9
log
@merge and obsolete special kbd (we just use the generic one)
@
text
@d1 1
a1 1
# $MirOS: src/distrib/miniroot/install.sub,v 1.8 2005/07/01 13:31:30 tg Exp $
d79 1
a79 1
#	MDDKDEVS    - '/^[sw]d[0-9][0-9]* /s/ .*//p' assumed if not provided
d1410 1
a1410 1
		if ! mount -v -t $_fstype $_async -o $_opt $_dev $_mp; then
d1412 3
a1414 3
			if ! mount -v -t $_fstype -o $_opt $_dev $_mp; then
			# In addition to the error message displayed by mount ...
			cat <<__EOT
d1420 1
a1420 2
			exit
		fi
d1651 1
a1651 1
DKDEVS=$(scan_dmesg "${MDDKDEVS:-/^[sw]d[0-9][0-9]* /s/ .*//p}")
@


1.8
log
@EXPERIMENTAL merge the installer
PLEASE TEST
@
text
@d1 2
a2 2
# $MirOS: src/distrib/miniroot/install.sub,v 1.7 2005/06/14 13:36:09 tg Exp $
# $OpenBSD: install.sub,v 1.387 2005/06/13 23:42:38 krw Exp $
d485 2
a486 2
Select sets by entering a set name, a regular expression or 'all'. De-select
sets by prepending a '-' to the set name, regular expression or 'all'. Selected
@


1.7
log
@* gcc set is gone
* welcome dev set
* ksh -> mksh while here
@
text
@d1 2
a2 2
# $MirOS: src/distrib/miniroot/install.sub,v 1.6 2005/05/09 08:47:15 tg Exp $
# $OpenBSD: install.sub,v 1.382 2005/04/15 23:45:29 krw Exp $
a72 1
#	md_set_term()		  - set up terminal
d79 1
a79 1
#	MDDISKDEVS  - '/^[sw]d[0-9][0-9]* /s/ .*//p' assumed if not provided
d81 2
a82 1
#	MDXAPERTURE - if not empty, set machdep.allowaperture=value in sysctl.conf
d86 2
d93 10
a102 1
	md_set_term
d121 1
a121 1
	# Configure the terminal.
d135 1
a135 1
to files in the 'etc' and 'xetc' set into the files already on your system.
d171 1
a171 1
	echo "Cool!  Let's get to it..."
d174 2
a175 6
get_dkdevs() {
	bsort $(sed -ne "${MDDISKDEVS:-/^[sw]d[0-9][0-9]* /s/ .*//p}" -e '/^raid[0-9][0-9]* /s/ .*//p' -e '/^ccd[0-9][0-9]* /s/ .*//p' /var/run/dmesg.boot)
}

get_cddevs() {
	bsort $(sed -ne "${MDCDDEVS:-/^cd[0-9][0-9]* /s/ .*//p}" /var/run/dmesg.boot)
d184 51
d261 1
a261 1
	while : ; do
d302 1
a302 1
	while : ; do
d312 1
a312 2
# Ask for the user to select a device from a list generated by scanning
# /var/run/dmesg.boot, and make the device if it doesn't exist.
d314 1
a314 1
# $1 = device name (disk, cd, etc.)
d316 3
a318 3
# $3 = list of devices from /var/run/dmesg.boot scan
# $4 = default device. If it is not specified, use the first device in $3
# $5 = error message if no devices in $3, defaults to 'No $1s found.'
d320 1
a320 1
# $resp holds device selected at exit, or 'done'
d322 1
a322 1
	local _name=$1 _query=$2 _devs=$3 _defdev=$4 _err=$5
d324 2
a325 2
	set -- $_devs
	if [[ $# -lt 1 ]]; then
d330 1
a330 1
	: ${_defdev:=$1}
d332 2
a333 2
	# Eliminate extraneous (especially trailing) whitespace in _devs.
	_devs="$*"
d335 1
a335 1
	while : ; do
d339 1
a339 2
		ask "Available ${_name}s are: ${_devs}.\nWhich one ${_query}? (or 'done')" "$_defdev"
		[[ $resp == done ]] && break
d343 2
a344 5
		if isin "$resp" $_devs; then
			makedev $resp && break
		else
			echo "'$resp' is not a valid choice."
		fi
d354 1
a354 1
		[ "$_a" = "$_b" ] && return 0
d362 1
a362 1
	local	_a=$1 _b _seen=false
d377 1
a377 1
		[ "$_a" != "$_b" ] && echo -n "$_b "
d398 1
a398 1
	echo "$_a "
d447 1
a447 4
# Check for the existence of the device nodes for the
# supplied device name. If they are missing (as indicated
# by r${1}c not being found) then create them. In either
# case, return true if the nodes exist and false if not.
d449 1
a449 1
# $1 = name of the device that is about to be used.
d451 1
a451 7
	local _dev=$1 _node=/dev/r${1}c

	# Don't need to make network interface devices nodes. If the device
	# nodes exist, don't need to create them.
	if isin $_dev $IFDEVS || [[ -c $_node ]]; then
		return 0
	fi
d454 1
a454 1
		echo "No /dev/MAKEDEV. Can't create device nodes for ${_dev}."
d458 1
a458 7
	(cd /dev; sh MAKEDEV $_dev)

	# If the device nodes still do not exist, assume MAKEDEV issued a useful
	# error message and return false.
	[[ -c $_node ]] || return 1

	DEVSMADE=$(addel $_dev $DEVSMADE)
d462 2
a463 2
# same symbolic name already exists, delete it.
# $1 - IP address
d466 3
a468 1
	sed "/ $2\$/d" /tmp/hosts >/tmp/hosts.new
d471 1
a471 1
	echo "$1 $2" >>/tmp/hosts
d483 1
a483 7
	while : ; do
		_action=
		cat <<__EOT

The following sets are available. Enter a filename, 'all' to select
all the sets, or 'done'. You may de-select a set by prepending a '-'
to its name.
d485 3
d489 2
d492 1
d503 1
a503 1
		ask "\nFile name? (or 'done')" "$_next"
d533 1
a533 1
	while : ; do
d548 1
a548 1
			cat << __EOT
d554 1
a554 1
			y)	cat << __EOT
d569 1
d586 12
d599 1
a599 1
# no IP address or 0.0.0.0 assigned to $1.
d626 1
a626 1
	if [[ $1 == UP && $2 != "0.0.0.0" ]]; then
d659 1
a659 1
			echo "dhcp NONE NONE NONE $_media" > $_hn
d666 1
a666 1
			echo "inet $_addr $resp NONE $_media" > $_hn
d672 37
d718 1
a718 1
	while : ; do
d720 2
a721 4
		case $resp in
		none|dhcp) break ;;
		esac
		route delete -inet default > /dev/null 2>&1
d732 24
a755 7
# Returns true if $1 contains only alphanumerics
isalphanumeric() {
	local _n=$1
	while [[ ${#_n} -ne 0 ]]; do
		case $_n in
		[A-Za-z0-9]*)	;;
		*)		return 1;;
a756 1
		_n=${_n#?}
d758 1
a758 1
	return 0
a771 2
	DIDNET=y

d782 2
a783 8
		# Interface names must be alphanumeric only. We check to avoid
		# configuring backup or temp files, and to catch the "*" case.
		isalphanumeric "$if" || continue
		[[ $if = local ]] && continue
		ifconfig $if >/dev/null 2>&1
		if [ $? -ne 0 ]; then
			continue
		fi
d806 1
a806 1
			"#"*|"!"*|"bridge"|""|"rtsol")
d808 1
a808 1
				# IPv6 rtsol and empty lines
d817 5
d859 2
a860 2
					# Ignore IPv6 setup
					continue
a1017 2
	donetconfig

d1046 1
a1046 1
	while : ; do
d1117 3
a1133 2
# $1 - mount point directory is relative to
# $2 - default directory
d1135 1
a1135 1
	local _mp=$1 _dir=$2
d1137 9
a1145 14
	while : ; do
		ask_until "Pathname to the sets? (or 'done')" "$_dir"
		case $resp in
		done)	return
			;;
		*)
			# Accept a valid $_mp relative path.
			[[ -d $_mp/$resp ]] && { _dir=$_mp/$resp; break; }
			# Accept a valid absolute path.
			[[ -d /$resp ]] && { _dir=/$resp; break; }
			# Otherwise ask again, with original default dir.
			echo "The directory '$resp' does not exist."
			;;
		esac
d1152 1
a1152 4
	local _drive _part _fstype _directory _n

	ask_which "CD-ROM" "contains the ${MODE} media" "$CDDEVS"
	[[ $resp == done ]] && return
d1154 1
d1157 10
a1166 17
	# If it is an ISO9660 CD-ROM, we don't need to ask any other questions
	_n=0
	until disklabel $_drive >/tmp/label.$_drive 2>&1; do
		# Try up to 6 times to access the CD
		if egrep -q '(Input/output error)|(sector size 0)' /tmp/label.$_drive; then
			_n=$(( $_n + 1 ))
			if [ _n -le 5 ]; then
				echo "I/O error accessing $_drive; retrying"
				sleep 10
			else
				echo "Cannot access $_drive."
				return
			fi
		else
			break
		fi
	done
d1168 2
a1169 53
	echo
	if grep -q '^ *c: .*ISO9660' /tmp/label.$_drive; then
		_fstype=cd9660
		_part=c
	else
		# Get partition from user
		resp=
		while [ -z "$resp" ]; do
			ask "CD-ROM partition to mount? (normally 'c')" c
			case $resp in
			[a-p])
				_part=$resp
				;;
			*)	echo "Invalid response: $resp"
				# force loop to repeat
				resp=
				;;
			esac
		done

		# Ask for filesystem type
		cat <<__EOT

Two CD-ROM filesystem types are currently supported by this program:
cd9660		ISO-9660
ffs		Berkeley Fast Filesystem

__EOT
		resp=
		while [ -z "$resp" ]; do
			ask "Which filesystem type?" cd9660
			case $resp in
			cd9660|ffs)
				_fstype=$resp
				;;
			*)	echo "Invalid response: '$resp'"
				# force loop to repeat
				resp=
				;;
			esac
		done
	fi

	rm -f /tmp/label.$_drive

	# Mount the CD-ROM
	if ! mount -t ${_fstype} -o ro /dev/${_drive}${_part} /mnt2; then
		echo "Cannot mount CD-ROM drive."
		return
	fi

	install_mounted_fs /mnt2 "$SETDIR"
	umount -f /mnt2 >/dev/null 2>&1
d1172 2
a1173 6
# Mount a disk on /mnt2. The set of disk devices to choose from
# is $DKDEVS.
# returns 0 on success, 1 on failure
mount_a_disk() {
	local _drive _def_partition _partition_range _partition
	local _fstype _fsopts
d1175 4
a1178 4
	ask_which "disk" "contains the ${MODE} sets" "$DKDEVS"
	[[ $resp == done ]] && return 1

	_drive=$resp
d1180 5
a1184 2
	# Get partition
	cat <<__EOT
d1186 2
a1187 20
The following partitions have been found on $_drive:

__EOT
	disklabel $_drive 2>/dev/null | grep '^  .:'
	echo
	_likely_partition_range=$(disklabel $_drive 2>/dev/null | \
		sed -n	-e '/swap/s/.*//' -e '/unused/s/.*//' \
			-e '/^  .:/{s/^  \(.\).*/\1/;H;}' \
			-e '${g;s/\n//g;s/^/[/;s/$/]/p;}')
	_partition_range=$(disklabel $_drive 2>/dev/null | \
		sed -n	-e '/^  .:/{s/^  \(.\).*/\1/;H;}' \
			-e '${g;s/\n//g;s/^/[/;s/$/]/p;}')
	_def_partition=$(echo $_likely_partition_range | \
		sed -n 's/^\[\(.\).*\]/\1/p')
	if [ -z "$_def_partition" ]; then
		_def_partition=$(echo $_partition_range | \
			sed -n 's/^\[\(.\).*\]/\1/p')
		if [ -z "$_def_partition" ]; then
			echo "There are no usable partitions on that disk"
			return 1
d1190 1
a1190 62

	resp=
	while [ -z "$resp" ]; do
		ask "Partition?" "$_def_partition"
		case $resp in
		$_partition_range)
			_partition=$resp
			;;
		*)	echo "Invalid response: $resp"
			# force loop to repeat
			resp=
			;;
		esac
	done

	# Ask for filesystem type
	cat <<__EOT

The following filesystem types are supported:
default		(deduced from the disklabel)
ffs
msdos
$MDFSTYPE
__EOT

	resp=
	while [ -z "$resp" ]; do
		ask "Which filesystem type?" default
		case $resp in
		default)
			;;
		ffs)	_fstype="-t ffs"
			_fsopts=softdep
			;;
		msdos)	_fstype="-t msdos"
			_fsopts="-l"
			;;
		$MDFSTYPE)
			_fstype="-t $resp"
			_fsopts=$MDFSOPTS
			;;
		*)	echo "Invalid response: $resp"
			# force loop to repeat
			resp=
			;;
		esac
	done

	# Mount the disk read-only
	if ! mount $_fstype -o ro,$_fsopts /dev/${_drive}${_partition} /mnt2; then
		echo "Cannot mount disk."
		return 1
	fi

	return 0
}

install_disk() {
	if mount_a_disk; then
		install_mounted_fs /mnt2
		umount -f /mnt2 >/dev/null 2>&1
	fi
d1194 1
a1194 7
	# Can we actually mount NFS filesystems?
	if [ ! -f /sbin/mount_nfs ]; then
		echo "/sbin/mount_nfs not found. Cannot mount NFS filesystems."
		return
	fi

	donetconfig
d1196 7
a1202 7
	# Get the IP address of the server
	ask_until "Server IP address or hostname?" "$_nfs_server_ip"
	_nfs_server_ip=$resp

	# Get server path to mount
	ask_until "Filesystem on server to mount?" "$_nfs_server_path"
	_nfs_server_path=$resp
d1205 2
a1206 3
	_nfs_tcp=
	ask_yn "Use TCP transport? (only works with capable NFS server)" yes
	[[ $resp == n ]] || _nfs_tcp=-T
d1209 1
a1209 4
	if ! mount_nfs $_nfs_tcp -o ro ${_nfs_server_ip}:${_nfs_server_path} /mnt2; then
		echo "Cannot mount NFS server."
		return
	fi
d1211 1
a1211 2
	install_mounted_fs /mnt2
	umount -f /mnt2 >/dev/null 2>&1
d1215 1
a1215 1
	local _xcmd
d1217 5
a1221 11
	# Get the name of the tape from the user.
	cat <<__EOT

The installation program needs to know which tape device to use. Make
sure you use a "no rewind on close" device.

__EOT
	ask_until "Name of tape device?" "${TAPE##*/}"
	TAPE=/dev/${resp##*/}
	if [ ! -c $TAPE ]; then
		echo "$TAPE does not exist or is not a character special file."
a1223 1
	export TAPE
d1225 3
a1227 6
	# Rewind the tape device
	echo -n "Rewinding ${TAPE} (mt rewind)..."
	if ! mt rewind; then
		echo "FAILED."
		return
	fi
d1230 14
a1243 20
	# Get the file number
	resp=
	while [ -z "$resp" ]; do
		ask "File number?"
		case $resp in
		[1-9]*)	_nskip=$(( $resp - 1 ))
			;;
		*)	echo "Invalid file number ${resp}."
			# force loop to repeat
			resp=
			;;
		esac
	done

	# Skip to correct file.
	if [ $_nskip -ne 0 ]; then
		echo -n "Skipping to source file (mt fsf ${_nskip})..."
		if ! mt fsf $_nskip; then
			echo "FAILED. Could not skip $_nskip files."
			return
a1244 6
		echo "done."
	fi

cat <<__EOT

There are 2 different ways the file can be stored on tape:
d1246 10
a1255 2
1) an image of a gzipped tar file
2) a standard tar image
d1257 1
a1257 16
__EOT

	resp=
	while [ -z "$resp" ]; do
		ask "Which way is it?" 1
		case $resp in
		1)	_xcmd="tar zxvphf -"
			;;
		2)	_xcmd="tar xvphf -"
			;;
		*)	echo "Invalid response: $resp."
			# force loop to repeat
			resp=
			;;
		esac
		( cd /mnt; dd if=$TAPE | $_xcmd )
a1258 1
	echo "Extraction complete."
d1276 1
a1276 1
	while : ; do
d1290 5
a1294 5
			if [[ $resp == ? ]]; then
				ls -F $_zonepath
			else
				_zonepath=$_zonepath/$resp
			fi
d1328 1
a1328 1
	cat <<__EOT
d1330 3
a1332 5
You will now specify the location and names of the ${MODE} sets you want to
load. You will be able to repeat this step until all of your sets have been
successfully loaded. If you are not sure what sets to ${MODE}, refer to the
installation notes for details on the contents of each.
__EOT
d1334 4
a1337 7
	while : ; do
		cat <<__EOT

Sets can be located on a (m)ounted filesystem; a (c)drom, (d)isk or (t)ape
device; or a (f)tp, (n)fs or (h)ttp server.
__EOT
		ask "Where are the ${MODE} sets? (or 'done')"
d1339 1
d1342 1
a1342 1
		c*|C*)	install_cdrom ;;
d1344 4
a1347 6
		f*|F*)	install_url ftp ;;
		h*|H*)	install_url http ;;
		m*|M*)	install_mounted_fs /mnt ;;
		n*|N*)	install_nfs ;;
		t*|T*)	install_tape ;;
		*)	;;
d1392 1
a1392 1
	# If no /etc/fstab was created, we have nowhere to ${MODE} to.
d1417 1
a1417 1
		and restart the ${MODE}.
d1421 1
a1421 1
		fi; fi
a1469 4
	[[ -n $DIDNET ]] && return

	DIDNET=y

d1523 3
a1525 1
	ask_yn "Do you wish sshd(8) to be started by default?" yes
d1531 1
a1531 1
	ask_yn "Start ntpd(8) by default?" yes
d1533 1
a1533 1
		echo "ntpd_flags=		# not disabled during install" \
d1537 11
a1547 1
	[[ -n $MDXAPERTURE ]] || return
d1549 12
a1560 8
	echo This setting affects the machdep.allowaperture sysctl.
	echo If you respond negatively, you must enable it later in
	echo /etc/sysctl.conf in order to be able to run XFree86®.
	ask_yn "Do you expect to run the X Window System?" yes
	if [[ $resp == y ]]; then
		sed -e "/^#\(machdep\.allowaperture=${MDXAPERTURE}\)/s//\1	/" \
		    /mnt/etc/sysctl.conf >/tmp/sysctl.conf
	fi
d1580 6
d1589 3
a1591 3
	# Make sure any devices we added as a result of makedev() calls
	# are recreated in installed system.
	for _dev in $DEVSMADE; do
d1601 1
a1601 1
	[ -x /mnt/${MODE}.site ] && /mnt/usr/sbin/chroot /mnt /${MODE}.site
d1606 1
a1606 1
CONGRATULATIONS! Your MirBSD ${MODE} has been successfully completed!
d1651 4
a1654 3
# Scan /var/run/dmesg.boot for disks and cds
DKDEVS=$(get_dkdevs)
CDDEVS=$(get_cddevs)
d1656 1
a1656 3

# Devices created with makedev().
DEVSMADE=
d1669 3
d1674 3
a1676 7
if [ -z "$EDITOR" ]; then
	EDITOR=ed
	[ -x /usr/bin/vi ] && EDITOR=vi
	export EDITOR
	# for mksh line-editing (bsiegert@@, leave this in, thanks)
	set -o emacs
fi
d1701 1
@


1.6
log
@add some explanation text for the aperture

idea by hubertf@@netbsd
@
text
@d1 1
a1 1
# $MirOS: src/distrib/miniroot/install.sub,v 1.5 2005/05/05 00:40:50 tg Exp $
d1738 1
a1738 1
for _set in base etc gnu gcc xbase xetc ports pkgutl source xfree site; do
d1741 1
a1741 1
	isin $_set xbase xetc ports pkgutl source xfree site && continue
d1750 1
a1750 1
	# for ksh line-editing (bsiegert@@, leave this in, thanks)
@


1.5
log
@RCS ID saneness
@
text
@d1 1
a1 1
# $MirOS: src/distrib/miniroot/install.sub,v 1.4 2005/05/04 11:38:50 tg Exp $
d1633 3
@


1.4
log
@* fix timezone settable
* fix default ftp/http/cdrom/... directory
@
text
@d1 2
a2 2
# $MirOS: src/distrib/miniroot/install.sub,v 1.3 2005/04/29 16:37:44 tg Exp $
#	$OpenBSD: install.sub,v 1.382 2005/04/15 23:45:29 krw Exp $
@


1.3
log
@some improvements from krw@@obsd
tweaked by me
@
text
@d1 1
a1 1
# $MirOS: src/distrib/miniroot/install.sub,v 1.2 2005/03/06 18:58:04 tg Exp $
d988 1
a988 2
#	ask_until "Server directory?" "${resp:-mbsd7}"
	ask_until "Server directory?" "${resp:-MirOS/current/$ARCH}"
d1348 1
a1348 1
	local _zoneroot=/mnt/usr/share/zoneinfo/right/ _zonepath
d1386 1
a1386 1
			ln -sf /usr/share/zoneinfo/right/$TZ /mnt/etc/localtime
d1707 1
a1707 1
SETDIR="$VNAME/$ARCH"
d1715 1
a1715 1
# Since etc${version}.ngz is not in DEFAULTSETS for upgrades, it can always be
@


1.2
log
@merge src/distrib
@
text
@d1 2
a2 2
# $MirOS$
# $OpenBSD: install.sub,v 1.338 2004/04/12 22:55:11 krw Exp $
d5 1
a5 1
# Copyright (c) 2003, 2004
d7 1
a7 1
# Copyright (c) 1997-2004 Todd Miller, Theo de Raadt, Ken Westerback
d551 1
a551 1
	local _ifs=$1 _hostname=$2
d553 1
a553 1
	echo "initial-interval 1;" >/etc/dhclient.conf
d555 2
a556 2
	if [[ -n $_hostname ]]; then
		echo "send host-name \"$_hostname\";" >>/etc/dhclient.conf
d562 5
a566 11
	cat >>/etc/dhclient.conf <<__EOT
request subnet-mask,
	broadcast-address,
	routers,
	domain-name,
	domain-name-servers,
	host-name;
__EOT

	cat >>/etc/resolv.conf.tail <<__EOT
lookup file bind
d573 7
a579 4
	if [[ $1 == UP && $2 == "0.0.0.0" ]]; then
		ifconfig $_ifs delete down
		rm /etc/dhclient.conf /etc/resolv.conf.tail
		return 1
d581 4
a584 8

	# Move configuration files to where they will be copied to the
	# installed system. Overwrites configuration information from last
	# successful dhcp attempt.
	mv /etc/dhclient.conf /tmp/dhclient.conf
	mv /etc/resolv.conf.tail /tmp/resolv.conf.tail

	return 0
d1397 1
a1397 9
# Check that required sets were successfully installed by checking
# for the presence of a 'random' selection of their contents.
#
# Required sets are:
#	1) bsd
#	2) baseXX
#	3) etcXX
#
# If a 'problem' set is found, add it back to DEFAULTSETS.
d1399 1
a1399 1
	local _insane
d1401 5
a1405 28
	# Check if bsd is installed and >0 bytes in size.
	if [[ ! -s /mnt/bsd ]]; then
		_insane=y
		DEFAULTSETS=$(addel bsd $DEFAULTSETS)
		cat << __EOT
+*** 'bsd' must be (re)installed: no kernel found.
__EOT
	fi

	# Check if baseXX is installed.
	if [[ ! -d /mnt/sbin || ! -d /mnt/dev ]]; then
		_insane=y
		DEFAULTSETS=$(addel base${VERSION}.ngz $DEFAULTSETS)
		cat << __EOT
+*** 'base${VERSION}.tgz' must be (re)installed: /sbin or /dev is missing.
__EOT
	fi

	# Check if etcXX is installed.
	if [[ ! -s /mnt/etc/rc ]]; then
		_insane=y
		DEFAULTSETS=$(addel etc${VERSION}.ngz $DEFAULTSETS)
		cat << __EOT
+*** 'etc${VERSION}.tgz' must be (re)installed: /etc/rc is missing.
__EOT
	fi

	[[ -n $_insane ]] && return 1
d1407 1
d1561 1
a1561 1
	local _dn _ns
d1576 7
a1582 2
		# Get nameserver address(es).
		_ns=$(sed -ne '/^nameserver /s///p' /tmp/resolv.conf)
d1623 7
a1629 1
		    >/mnt/etc/rc.conf.local
d1716 3
@


1.1
log
@Initial revision
@
text
@d1 3
a3 2
#	$OpenBSD: install.sub,v 1.338 2004/04/12 22:55:11 krw Exp $
#	$NetBSD: install.sub,v 1.5.2.8 1996/09/02 23:25:02 pk Exp $
d5 2
d65 1
a65 1
# OpenBSD install/upgrade script common subroutines and initialization code
d97 1
a97 1
	cat << __EOT
d99 1
a99 1
Welcome to the $OBSD $MODE program.
d101 4
a104 4
This program will help you $MODE OpenBSD in a simple and rational way. At
any prompt except password prompts you can run a shell command by typing
'!foo', or escape to a shell by typing '!'. Default answers are shown in []'s
and are selected by pressing RETURN. At any time you can exit this program by
d113 1
a113 1
	cat << __EOT
d122 3
a124 3
		cat << __EOT
NOTE: once your system has been upgraded, you must manually merge any changes
to files in the 'etc' set into the files already on your system.
d131 1
a131 1
		cat << __EOT
d138 1
a138 1
			cat << __EOT
d152 1
a152 1
		cat << __EOT
d154 2
a155 2
Enter 'halt' at the prompt to gracefully exit OpenBSD. You can then
power cycle the machine and boot your original OS.
d164 1
a164 1
	bsort `sed -ne "${MDDISKDEVS:-/^[sw]d[0-9][0-9]* /s/ .*//p}" /var/run/dmesg.boot`
d168 1
a168 1
	bsort `sed -ne "${MDCDDEVS:-/^cd[0-9][0-9]* /s/ .*//p}" /var/run/dmesg.boot`
d229 1
a229 1
	while [[ -z $resp ]] ; do
d248 2
a249 2
		y|yes)	resp=y ; return ;;
		n|no)	resp=n ; return ;;
d335 2
a336 2
		if [[ $_a != $_b ]] ; then
			if [[ $_a > $_b ]] ; then
d358 2
a359 2
		grep "^#" /mnt/etc/$_file > /tmp/$_file.new
		[[ -f /tmp/$_file ]] && cat /tmp/$_file >> /tmp/$_file.new
d380 1
a380 1
	[[ $resp == y ]] && { echo "Type 'exit' to return to $MODE." ; sh ; }
d386 1
a386 1
	ftp ${_ftp_active} -V -n "$1" << __EOT
d405 1
a405 1
	if isin $_dev $IFDEVS || [[ -c $_node ]] ; then
d409 1
a409 1
	if [[ ! -r /dev/MAKEDEV ]] ; then
d420 1
a420 1
	DEVSMADE=`addel $_dev $DEVSMADE`
d428 1
a428 1
	sed "/ $2\$/d" /tmp/hosts > /tmp/hosts.new
d431 1
a431 1
	echo "$1 $2" >> /tmp/hosts
d445 1
a445 1
		cat << __EOT
d499 1
a499 1
		_hn=/tmp/hostname.$_ifs 
d553 1
a553 1
	echo "initial-interval 1;" > /etc/dhclient.conf
d556 1
a556 1
		echo "send host-name \"$_hostname\";" >> /etc/dhclient.conf
d562 1
a562 1
	cat >> /etc/dhclient.conf << __EOT
d571 1
a571 1
	cat >> /etc/resolv.conf.tail << __EOT
d601 1
a601 1
	fi	
d605 1
a605 1
	
d641 5
a645 1
		route -n add -inet -host default "$resp" && { echo "$resp" >/tmp/mygate ; break ; }
d689 3
a691 4
		if ! isalphanumeric "$if"; then
			continue
		fi
		ifconfig $if > /dev/null 2>&1
d712 5
a776 7
	# /mnt/etc/mygate, if it exists, contains the name of my gateway host
	# that name must be in /etc/hosts.
	if [ -f /mnt/etc/mygate ]; then
		route delete default >/dev/null 2>&1
		route -qn add -host default $(< /mnt/etc/mygate)
	fi

d778 1
a778 1
	route -qn add -host `hostname` 127.0.0.1 >/dev/null
d781 6
d810 1
a810 1
	# installation.  So, to minimize user confusion display the sets in the
d820 1
a820 1
		cat << __EOT
d838 1
a838 1
	for _f in $THESETS ; do
d842 1
a842 1
		*.tgz)	ftp $_ftp_active -o - -V -m "$_src/$_f" | tar zxphf - -C /mnt
d932 19
a950 18
	ask_yn "Display the list of known $_url_type servers?" "${_get_server_list:-yes}"
	_get_server_list=$resp
	if [[ $_get_server_list == y ]]; then
		# ftp.openbsd.org == 129.128.5.191 and will remain at
		# that address for the forseeable future.
		echo -n "Getting the list from 129.128.5.191 (ftp.openbsd.org)..."
		ftp $_ftp_active -V -a -o - \
			ftp://129.128.5.191/$FTPDIR/ftplist 2>/tmp/ftplisterr \
			| sed -ne "/^${_url_type}:\/\//s///p" >$SERVERLIST
		if [[ -s $SERVERLIST ]]; then
			echo "done."
			_prompt="Server? (IP address, hostname, list#, 'done' or '?')"
			cat -n $SERVERLIST | less -XE
		else
			echo "FAILED."
			cat /tmp/ftplisterr
		fi
	fi
d967 1
a967 1
			[[ $# -lt 1 ]] && { echo "There is no line $resp." ; continue ; }
d995 2
a996 1
	ask_until "Server directory?" "${resp:-pub/OpenBSD/$SETDIR}"
d1008 1
a1008 1
		_passwd=root@@`hostname`
d1011 1
a1011 1
			while [[ -z $resp ]] ; do
d1027 1
a1027 1
	if [[ $_url_type == ftp && -z $ftp_proxy ]] ; then
d1052 1
a1052 1
			[[ -d $_mp/$resp ]] && { _dir=$_mp/$resp ; break ; }
d1054 1
a1054 1
			[[ -d /$resp ]] && { _dir=/$resp ; break ; }
d1061 1
a1061 1
	install_files "file://$_dir" "`ls -l $_dir`"
d1097 1
a1097 1
		while [ -z "$resp" ] ; do
d1111 1
a1111 1
		cat << __EOT
d1119 1
a1119 1
		while [ -z "$resp" ] ; do
d1136 1
a1136 1
	if ! mount -t ${_fstype} -o ro /dev/${_drive}${_part} /mnt2 ; then
d1142 1
a1142 1
	umount -f /mnt2 > /dev/null 2>&1
d1158 1
a1158 1
	cat << __EOT
d1165 1
a1165 1
	_likely_partition_range=`disklabel $_drive 2>/dev/null | \
d1168 2
a1169 2
			-e '${g;s/\n//g;s/^/[/;s/$/]/p;}'`
	_partition_range=`disklabel $_drive 2>/dev/null | \
d1171 3
a1173 3
			-e '${g;s/\n//g;s/^/[/;s/$/]/p;}'`
	_def_partition=`echo $_likely_partition_range | \
		sed -n 's/^\[\(.\).*\]/\1/p'`
d1175 2
a1176 2
		_def_partition=`echo $_partition_range | \
			sed -n 's/^\[\(.\).*\]/\1/p'`
d1198 1
a1198 1
	cat << __EOT
d1203 1
d1214 4
a1217 1
			_fsopts=async
d1242 1
a1242 1
		umount -f /mnt2 > /dev/null 2>&1
d1265 2
a1266 2
	ask_yn "Use TCP transport? (only works with capable NFS server)"
	[[ $resp == y ]] && _nfs_tcp=-T
d1269 1
a1269 1
	if ! mount_nfs $_nfs_tcp -o ro ${_nfs_server_ip}:${_nfs_server_path} /mnt2 ; then
d1275 1
a1275 1
	umount -f /mnt2 > /dev/null 2>&1
d1282 1
a1282 1
	cat << __EOT
d1298 1
a1298 1
	if ! mt rewind ; then
d1321 1
a1321 1
		if ! mt fsf $_nskip ; then
d1328 1
a1328 1
cat << __EOT
d1356 1
a1356 1
	local _zoneroot=/mnt/usr/share/zoneinfo/ _zonepath
d1394 1
a1394 1
			ln -sf /usr/share/zoneinfo/$TZ /mnt/etc/localtime
d1428 1
a1428 1
		DEFAULTSETS=$(addel base${VERSION}.tgz $DEFAULTSETS)
d1437 1
a1437 1
		DEFAULTSETS=$(addel etc${VERSION}.tgz $DEFAULTSETS)
d1452 1
a1452 1
	cat << __EOT
d1461 1
a1461 1
		cat << __EOT
d1488 2
a1489 1
#	4) are nfs (since name resolution may not be present).
a1492 1
#	1) delete 'softdep' options (no soft updates in ramdisk kernels),
d1506 1
a1510 4
		# Remove any softdep options, as soft updates are not
		# available in the ramdisk kernels.
		_opt=$(echo $_opt | sed -e 's/softdep//')

d1520 1
a1520 1
	done < /tmp/fstab > /etc/fstab
d1540 3
a1542 1
		if ! mount -v -t $_fstype $_async -o $_opt $_dev $_mp ; then
d1544 1
a1544 1
			cat << __EOT
d1551 2
a1552 2
		fi
	done < /etc/fstab
d1572 1
a1572 1
		if ! fsck -fp ${_dev} > /dev/null 2>&1; then
d1578 1
a1578 1
	done < /etc/fstab
d1630 1
a1630 1
		echo "lookup file bind" > /tmp/resolv.conf
d1632 1
a1632 1
			echo "nameserver $_ns" >> /tmp/resolv.conf
d1655 1
a1655 1
		    > /mnt/etc/rc.conf.local
d1663 1
a1663 1
		    /mnt/etc/sysctl.conf > /tmp/sysctl.conf
d1702 1
a1702 1
	cat << __EOT
d1704 1
a1704 1
CONGRATULATIONS! Your OpenBSD ${MODE} has been successfully completed!
d1707 6
d1731 1
a1731 1
VERSION=35
d1735 1
a1735 2
FTPDIR="pub/OpenBSD/$VNAME"
OBSD="OpenBSD/$ARCH $VNAME"
d1744 1
a1744 1
dmesg | sed -ne '/^OpenBSD /h;/^OpenBSD /!H;${g;p;}' > /var/run/dmesg.boot
d1747 3
a1749 3
DKDEVS=`get_dkdevs`
CDDEVS=`get_cddevs`
IFDEVS=`get_ifdevs`
d1755 1
a1755 1
# Ensure that siteXX.tgz is the *last* set listed so its contents overwrite
d1759 5
a1763 5
for _set in base etc misc comp man game xbase xshare xfont xserv site ; do
	[[ $MODE == upgrade && $_set == etc ]] && continue
	THESETS="$THESETS ${_set}${VERSION}.tgz"
	isin $_set xbase xshare xfont xserv site && continue
	DEFAULTSETS="$DEFAULTSETS ${_set}${VERSION}.tgz"
d1767 1
a1767 1
if [ -z "$EDITOR" ] ; then
d1771 2
d1784 1
a1784 1
	cat << __EOT
d1786 1
a1786 1
You will now initialize the disk(s) that OpenBSD will use. To enable all
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@update from OpenBSD-current
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.387 2005/06/13 23:42:38 krw Exp $
d4 1
a4 1
# Copyright (c) 1997-2005 Todd Miller, Theo de Raadt, Ken Westerback
d70 1
d77 1
a77 1
#	MDDKDEVS    - '/^[sw]d[0-9][0-9]* /s/ .*//p' assumed if not provided
d79 1
a79 2
#	MDMTDEVS    - '/^[cmsw]t[0-9][0-9]* /s/ .*//p'
#	MDXAPERTURE - set machdep.allowaperture=value in sysctl.conf
a82 2
	local _tables

d88 1
a88 10
	[[ -x /sbin/kbd ]] || return
	_tables=$(bsort $(kbd -l | egrep -v "^(user|tables|encoding)"))
	while :; do
		ask "kbd(8) mapping? ('?' for list)" "none"
		case $resp in
		none)	return ;;
		"?")	echo "Major tables: $_tables" ;;
		*)	kbd $resp && { echo $resp >/tmp/kbdtype ; return ; } ;;
		esac
	done
d94 1
a94 1
	cat <<__EOT
d107 1
a107 1
	# Configure the terminal and keyboard.
d110 1
a110 1
	cat <<__EOT
d119 1
a119 1
		cat <<__EOT
d128 1
a128 1
		cat <<__EOT
d135 1
a135 1
			cat <<__EOT
d149 1
a149 1
		cat <<__EOT
d157 1
a157 1
	echo "Cool! Let's get to it."
d160 6
a165 2
scan_dmesg() {
	bsort $(sed -ne "$1" /var/run/dmesg.boot)
a173 51
# Get the first (lowest unit #) serial device if any, if MDSERIAL is set.
# NOTE: Only single digit serial devices (<dev>0 -> <dev>9) are looked for.
get_serialdev() {
	local _d _bd _td

	[[ -n $MDSERIAL ]] || exit
	set -- $MDSERIAL
	_d=$1
	_bd=$2
	_td=$3
	set -- $(scan_dmesg "/^${_d}\([0-9]\) .*/s//\1/p")
	echo "$_bd$1 $_td$1"
}

get_drive() {
	ask_which "$1" "contains the $MODE media" "$2"
	[[ $resp == done ]] && return 1
	makedev $resp || return 1
	return 0
}

get_partition() {
	local _drive=$1 _fstypes=$2 _part _fst

	# Create file /tmp/parts.$_drive where each line is of the
	# form "<partition letter> <fs type>".
	disklabel $_drive 2>/dev/null		\
		| grep '^  [a-p]: '		\
		| egrep -v "swap|unused"	\
		| sed -e 's/^  \(.\):  *[^ ]*  *[^ ]*  *\([^ ]*\) .*/\1 \2/' \
		>/tmp/parts.$_drive

	disklabel $_drive 2>/dev/null | grep '^  .:'

	ask_which "$_drive partition" "has the $MODE sets" \
		 "$(sed -e 's/^\(.\).*/\1/' /tmp/parts.$_drive)"
	[[ $resp == done ]] && return 1

	_part=$resp
	_fst=$(sed -ne "/^$_part /s///p" /tmp/parts.$_drive)

	ask_which "filesystem type" "should be used to mount $_drive$_part" "$_fst $_fstypes ffs"
	case $resp in
	done)	return 1 ;;
	$_fst)	resp="$_part" ;;
	*)	resp="$_part $resp" ;;
	esac

	return 0
}

d200 1
a200 1
	while :; do
d241 1
a241 1
	while :; do
d251 2
a252 1
# Ask for the user to select one value from a list, or 'done'.
d254 1
a254 1
# $1 = name of the list items (disk, cd, etc.)
d256 3
a258 3
# $3 = list of valid choices
# $4 = default choice, if it is not specified use the first item in $3
# $5 = error message if no items in $3, defaults to 'No $1s found.'
d260 1
a260 1
# At exit $resp holds selected item, or 'done'
d262 1
a262 1
	local _name=$1 _query=$2 _list=$3 _def=$4 _err=$5
d264 2
a265 2
	set -- $_list
	if (( $# < 1 )); then
d270 1
a270 1
	: ${_def:=$1}
d272 2
a273 2
	# Eliminate extraneous (especially trailing) whitespace in _list.
	_list="$*"
d275 1
a275 1
	while :; do
d279 2
a280 1
		ask "Available ${_name}s are: $_list.\nWhich one $_query? (or 'done')" "$_def"
d284 5
a288 2
		isin "$resp" $_list done && break
		echo "'$resp' is not a valid choice."
d298 1
a298 1
		[[ $_a == $_b ]] && return 0
d306 1
a306 1
	local	_a=$1
d321 1
a321 1
		[[ $_a != $_b ]] && echo -n "$_b "
d342 1
a342 1
	echo -n "$_a "
d355 2
a356 2
		grep "^#" /mnt/etc/$_file >/tmp/$_file.new
		[[ -f /tmp/$_file ]] && cat /tmp/$_file >>/tmp/$_file.new
d383 1
a383 1
	ftp ${_ftp_active} -V -n "$1" <<__EOT
d391 4
a394 1
# Create a device.
d396 1
a396 1
# $1 = name of the device to create.
d398 7
a404 1
	local _dev=$1
d407 1
a407 1
		echo "MAKEDEV not found. Can't create device nodes."
d411 7
a417 1
	cd /dev ; sh MAKEDEV $_dev || return 1 ; cd - >/dev/null
d421 2
a422 2
# same symbolic name and address family already exists, delete it.
# $1 - IP address (v6 if it contains ':', else v4)
d425 1
a425 3
	local _addr=$1 _name=$2

	sed "/^[0-9a-fA-F]*[:.].* $_name\$/d" /tmp/hosts >/tmp/hosts.new
d428 1
a428 1
	echo "$_addr $_name" >>/tmp/hosts
d440 7
a446 1
	cat <<__EOT
a447 3
Select sets by entering a set name, a regular expression or 'all'. De-select
sets by prepending a '-' to the set name, regular expression or 'all'. Selected
sets are labelled '[x]'.
a448 2
	while :; do
		_action=
a449 1
		echo
d460 1
a460 1
		ask "Set name? (or 'done')" "$_next"
d490 1
a490 1
	while :; do
d496 1
a496 1
		_hn=/tmp/hostname.$_ifs
d505 1
a505 1
			cat <<__EOT
d511 1
a511 1
			y)	cat <<__EOT
a525 1
		v6_config "$_ifs" "$_media" "$_name" "$_hn"
a541 12
# Obtain and output the inet6 information related to the given
# interface. Should output '<UP/DOWN> <addr> <prefixlen> <rest of inet line> '.
#
# $1 == interface
v6_info() {
	ifconfig $1 inet6 | sed -n '
		1s/.*<UP,.*/UP/p
		1s/.*<.*/DOWN/p
		/scopeid/d
		/inet6/s///p'
}

d543 1
a543 1
# no IP address assigned to $1.
d548 1
a548 1
	local _ifs=$1 _hn=$2
d550 1
a550 1
	echo "lookup file bind" >/etc/resolv.conf.tail
d552 2
a553 2
	if [[ -n $_hn ]]; then
		_hn="send host-name \"$_hn\";"
d559 11
a569 5
	cat >/etc/dhclient.conf <<__EOT
initial-interval 1;
$_hn
request subnet-mask, broadcast-address, routers, domain-name,
	domain-name-servers, host-name;
a571 1
	ifconfig $_ifs group dhcp >/dev/null 2>&1
d576 4
a579 7
	if [[ $1 == UP && -n $2 ]]; then
		# Move configuration files to where they will be copied to the
		# installed system. Overwrites configuration information from
		# last successful dhcp attempt.
		mv /etc/dhclient.conf /tmp/dhclient.conf
		mv /etc/resolv.conf.tail /tmp/resolv.conf.tail
		return 0
d581 8
a588 4
	
	ifconfig $_ifs delete down
	rm /etc/dhclient.conf /etc/resolv.conf.tail
	return 1
d592 1
a592 1
	local _ifs=$1 _media=$2 _name=$3 _hn=$4 _prompt _addr _mask
d594 5
a598 9
	if ifconfig $_ifs | grep 'groups:.* dhcp' >/dev/null 2>&1; then
		_addr=dhcp
	else
		set -- $(v4_info $_ifs)
		if [[ -n $2 ]]; then
			_addr=$2; _mask=$3
			ifconfig $_ifs inet $_addr delete
		fi
	fi
d602 1
a602 1

d610 1
a610 1
			echo "dhcp NONE NONE NONE $_media" >>$_hn
a614 1
		ifconfig $_ifs -group dhcp >/dev/null 2>&1
d617 1
a617 1
			echo "inet $_addr $resp NONE $_media" >$_hn
a622 36
v6_config() {
	local _ifs=$1 _media=$2 _name=$3 _hn=$4 _addr _prefixlen _prompt

	ifconfig lo0 inet6 >/dev/null 2>&1 || return

	set -- $(v6_info $_ifs)
	[[ -n $2 ]] && { _addr=$2; _prefixlen=$3; }

	[[ -x /sbin/rtsol ]] && _prompt="or 'rtsol' "
	_prompt="IPv6 address for $_ifs? (${_prompt}or 'none')"
	ask_until "$_prompt" "${_addr:-none}"

	case $resp in
	none)	return
		;;
	rtsol)	[[ ! -x /sbin/rtsol ]] && { echo "No /sbin/rtsol." ; return ; }
		ifconfig $_ifs up
		rtsol -F $_ifs
		addhostent "::1" "$_name"
		echo "up\nrtsol $media" >>$_hn
		return
		;;
	esac

	_addr=$resp
	ask_until "IPv6 prefix length for $_ifs?" "${_prefixlen:=64}"
	ifconfig $_ifs inet6 $_addr prefixlen $resp up || return
	echo "inet6 $_addr $resp $media" >>$_hn
	addhostent "$_addr" "$_name"

	v6_defroute $_ifs
	[[ $resp == none ]] && return
	route -n add -inet6 -host default "$resp" || return
	echo "!route -qn add -host -inet6 default $resp" >>$_hn
}

d632 1
a632 1
	while :; do
d634 4
a637 2
		[[ $resp == @@(none|dhcp) ]] && break
		route delete -inet default >/dev/null 2>&1
d644 7
a650 24
v6_defroute() {
	local _if=$1 _routers _oifs

	if [[ -z $(route -n show -inet6 | sed -ne '/^default */{s///; s/ .*//; p;}') ]]; then
		resp=none
		return
	fi

	if [[ -x /sbin/ping6 ]]; then
		_routers=$(ping6 -n -c 2 ff02::2%$_if 2>&1 | sed -n \
			-e '/bytes from/{s/^.*from //;s/,.*$//;p;}')
	fi

	_oifs=$IFS
	IFS=
	PS3="IPv6 default router? (list #, IPv6 address or 'none'): "
	select i in $_routers; do
		case $i in
		"")	resp=$REPLY
			[[ -n $resp ]] && break
			;;
		*)	resp=$i
			break
			;;
d652 1
d654 1
a654 1
	IFS=$_oifs
d668 2
d680 9
a688 2
		# Check for ifconfig'able interface.
		ifconfig $if >/dev/null 2>&1 || continue
d706 1
a706 1
			"#"*|"!"*|"bridge"|"")
d708 1
a708 1
				# and empty lines
a716 5
			"rtsol")
				ifconfig $if $name $mask $bcaddr $ext1 $ext2 up
				rtsif="$rtsif $if"
				cmd=
				;;
d754 2
a755 2
					[ "$mask" ] && cmd="$cmd prefixlen $mask"
					cmd="$cmd $bcaddr"
a765 2
	[[ -n $rtsif ]] && /mnt/sbin/rtsol -F $rtsif

d770 1
a770 1
		route -qn add -host default $(</mnt/etc/mygate)
d810 1
a810 1
		cat <<__EOT
d914 2
d943 1
a943 1
	while :; do
a1013 3
	# XXX Workaround for problems ftp'ing out from a v6 only host.
	ifconfig lo0 127.0.0.1

d1028 2
d1031 1
a1031 1
	local _dir
d1033 14
a1046 9
	while :; do
		ask_until "Pathname to the sets? (or 'done')" "$SETDIR"
		[[ $resp == done ]] && return
		# Accept a valid /mnt2 or /mnt relative path.
		[[ -d /mnt2/$resp ]] && { _dir=/mnt2/$resp ; break ; }
		[[ -d /mnt/$resp ]] && { _dir=/mnt/$resp ; break ; }
		# Accept a valid absolute path.
		[[ -d /$resp ]] && { _dir=/$resp ; break ; }
		echo "The directory '$resp' does not exist."
d1049 1
a1049 1
	install_files "file://$_dir" "$(ls -l $_dir)"
d1053 4
a1056 1
	local _drive _part=c _fstype
a1057 1
	get_drive "CD-ROM" "$CDDEVS" || return
d1060 68
a1127 10
	set -- $(disklabel $_drive 2>&1 | grep '^  c: ')
	case $4 in
	ISO9660) _fstype=cd9660 ;;
	UDF)	 _fstype=udf ;;
	*)	 get_partition $_drive "cd9660" || return
		 set -- $resp
		 _part=$1
		 [[ -n $2 ]] && _fstype=$2
		;;
	esac
d1129 2
a1130 2
	mount -t $_fstype -o ro /dev/$_drive$_part /mnt2 || return
	install_mounted_fs
d1133 11
a1143 2
install_disk() {
	local _drive _dev _fstype _fsopts
d1145 2
a1146 4
	ask_yn "Is the disk partition already mounted?"
	if [[ $resp == n ]]; then
		get_drive "disk" "$DKDEVS" || return
		_drive=$resp
d1148 1
a1148 5
		get_partition $_drive "$MDFSTYPE" || return
		set -- $resp
		_dev=/dev/$_drive$1
		[[ -n $2 ]] && _fstype="-t $2"
		[[ $_fstype == $MDFSTYPE ]] && _fsopts=$MDFSOPTS
d1150 18
a1167 2
		if [[ -z $(mount | grep "^$_dev") ]]; then
			mount $_fstype -o ro,$_fsopts $_dev /mnt2 || return
d1170 58
a1227 1
	install_mounted_fs
d1231 5
a1235 1
	local _tcp
d1237 9
a1245 7
	# Get the IP address of the server.
	ask_until "Server IP address or hostname?" "$NFS_ADDR"
	NFS_ADDR=$resp

	# Get the server path to mount.
	ask_until "Filesystem on server to mount?" "$NFS_PATH"
	NFS_PATH=$resp
d1248 3
a1250 2
	ask_yn "Use TCP transport? (requires TCP-capable NFS server)"
	[[ $resp == y ]] && _tcp=-T
d1253 4
a1256 1
	mount_nfs $_tcp -o ro $NFS_ADDR:$NFS_PATH /mnt2 || return
d1258 2
a1259 1
	install_mounted_fs
d1263 4
a1266 1
	local _z _bs
d1268 8
a1275 5
	# Get the name of the tape device.
	get_drive "tape drive" "$MTDEVS" || return
	export TAPE=/dev/nr$resp
	if [[ ! -c $TAPE ]]; then
		echo "$TAPE is not a character special file."
d1278 1
d1280 6
a1285 3
	# Rewind the tape device.
	echo -n "Rewinding $TAPE (mt rewind)..."
	mt rewind || return
d1288 20
a1307 14
	# Extract the desired files.
	while :; do
		ask_until "Skip how many files? (or 'done')" 0
		[[ $resp == done ]] && return
		[[ $resp == +([0-9]) ]] || continue
		(($resp < 0)) && continue

		if (($resp > 0)); then
			echo -n "Skipping $resp file(s)..."
			mt fsf $resp || return
			echo "done."
		elif [[ -n $_bs ]]; then
			# Dance to start of next file.
			mt bsf ; mt fsf
d1309 2
d1312 1
a1312 10
		unset _z
		ask_yn "Is the file gzipped?" yes
		[[ $resp == y ]] && _z=z

		# Get the blocksize to use. If the file isn't gzipped then
		# default to the 20 x 512 = 10,240 byte tar default.
		[[ $_z == z ]] || _bs=10240
		ask_until "Blocksize for this file?" "${_bs:-8k}"
		[[ $resp == done ]] && return
		_bs=$resp
d1314 21
a1334 1
		dd if=$TAPE bs=$_bs | tar ${_z}xvphf - -C /mnt || return
d1336 1
d1354 1
a1354 1
	while :; do
d1368 5
a1372 5
			case $resp in
			"")	;;
			?)	ls -F $_zonepath ;;
			*)	_zonepath=$_zonepath/$resp ;;
			esac
d1388 9
a1396 1
# Check with the user that missing required sets were deliberately skipped.
d1398 1
a1398 1
	local _s _m
d1400 28
a1427 5
	for _s in $SANESETS; do
		isin $_s $DEFAULTSETS || continue
		ask_yn "'$_s' was not installed.\nAre you *SURE* your $MODE is complete without '$_s'?"
		[[ $resp == n ]] && _m="$_m $_s"
	done
a1428 1
	[[ -n $_m ]] && return 1
d1436 1
a1436 1
	local _d=disk _locs="disk ftp http"
d1438 13
a1450 8
	[[ -n $CDDEVS ]] && { _locs="cd $_locs" ; _d=cd ; }
	[[ -x /sbin/mount_nfs ]] && _locs="$_locs nfs"
	[[ -n $MTDEVS && -x /bin/mt ]] && _locs="$_locs tape"

	echo "\nLet's $MODE the sets!"
	while :; do
		umount -f /mnt2 >/dev/null 2>&1
		[[ -z $DEFAULTSETS ]] && _d=done
a1451 1
		ask "Location of sets? ($_locs or 'done')" "$_d"
d1454 1
a1454 1
		c*|C*)	isin "cd" $_locs && install_cdrom ;;
d1456 6
a1461 4
		f*|F*)	isin "ftp" $_locs && install_url ftp ;;
		h*|H*)	isin "http" $_locs && install_url http ;;
		n*|N*)	isin "nfs" $_locs && install_nfs ;;
		t*|T*)	isin "tape" $_locs && install_tape ;;
d1507 1
a1507 1
	done </tmp/fstab >/etc/fstab
d1509 1
a1509 1
	# If no /etc/fstab was created, we have nowhere to $MODE to.
d1529 1
a1529 1
			cat <<__EOT
d1532 1
a1532 1
		and restart the $MODE.
d1537 1
a1537 1
	done </etc/fstab
d1557 1
a1557 1
		if ! fsck -fp ${_dev} >/dev/null 2>&1; then
d1563 1
a1563 1
	done </etc/fstab
d1583 5
a1587 1
	local _dn _ns _n
d1598 2
a1599 7
		# Get nameserver address(es). Store as a blank separated list.
		for _n in $(grep '^nameserver ' /tmp/resolv.conf); do
			[[ $_n == nameserver ]] || _ns="$_ns$_n "
		done
		# Zap trailing space in _ns.
		set -- $_ns
		_ns=$*
d1615 1
a1615 1
		echo "lookup file bind" >/tmp/resolv.conf
d1617 1
a1617 1
			echo "nameserver $_ns" >>/tmp/resolv.conf
d1637 1
a1637 3
	local _bd _td

	ask_yn "Start sshd(8) by default?" yes
d1640 1
a1640 1
		    >>/mnt/etc/rc.conf.local
d1643 3
a1645 1
	ask_yn "Start ntpd(8) by default?" no
d1647 2
a1648 11
		echo "ntpd_flags=		# enabled during install" \
		    >>/mnt/etc/rc.conf.local
	fi

	if [[ -n $MDXAPERTURE ]]; then
		ask_yn "Do you expect to run the X Window System?" yes
		if [[ $resp == y ]]; then
			sed -e "/^#\(machdep\.allowaperture=${MDXAPERTURE}\)/s//\1	/" \
			    /mnt/etc/sysctl.conf >/tmp/sysctl.conf
			cp /tmp/sysctl.conf /mnt/etc/sysctl.conf
		fi
a1649 13

	[[ -z $SERIALDEV ]] && return
	set -- $SERIALDEV
	_bd=$1
	_td=$2
	ask_yn "Change the default console to $_bd?"
	[[ $resp == n ]] && return
	ask_which "speed" "should $_bd use" "9600 19200 38400 57600 115200"
	[[ $resp == done ]] && return
	echo "stty $_bd $resp\nset tty $_bd" >>/mnt/etc/boot.conf
	sed	-e "/^${_td}/s/std.9600/std.${resp}/" \
		-e "/^${_td}/s/unknown/vt220	/" \
		-e "/${_td}/s/off/on secure/" /mnt/etc/ttys >/tmp/ttys
a1668 6
	if grep -qs '^rtsol' /mnt/etc/hostname.*; then
		sed -e "/^#\(net\.inet6\.ip6\.accept_rtadv\)/s//\1/" \
		    /mnt/etc/sysctl.conf >/tmp/sysctl.conf
		cp /tmp/sysctl.conf /mnt/etc/sysctl.conf
	fi

d1672 3
a1674 3
	# Make sure any devices we found during probe are created in the
	# installed system.
	for _dev in $DKDEVS $CDDEVS $MTDEVS; do
d1684 1
a1684 1
	[ -x /mnt/$MODE.site ] && /mnt/usr/sbin/chroot /mnt /$MODE.site
d1687 1
a1687 1
	cat <<__EOT
d1689 1
a1689 1
CONGRATULATIONS! Your OpenBSD $MODE has been successfully completed!
d1710 1
a1710 1
VERSION=37
d1724 6
a1729 1
dmesg | sed -ne '/^OpenBSD /h;/^OpenBSD /!H;${g;p;}' >/var/run/dmesg.boot
d1731 2
a1732 6
# Scan /var/run/dmesg.boot for interesting devices.
DKDEVS=$(scan_dmesg "${MDDKDEVS:-/^[sw]d[0-9][0-9]* /s/ .*//p}")
CDDEVS=$(scan_dmesg "${MDCDDEVS:-/^cd[0-9][0-9]* /s/ .*//p}")
MTDEVS=$(scan_dmesg "${MDMTDEVS:-/^[cmsw]t[0-9][0-9]* /s/ .*//p}")
IFDEVS=$(get_ifdevs)
SERIALDEV=$(get_serialdev)
d1737 4
a1740 4
THESETS="bsd bsd.rd bsd.mp $MDSETS"
DEFAULTSETS="bsd bsd.rd"
for _set in base etc misc comp man game xbase xetc xshare xfont xserv site ; do
	[[ $MODE == upgrade && ( $_set == etc || $_set == xetc ) ]] && continue
d1742 1
a1742 1
	isin $_set xbase xetc xshare xfont xserv site && continue
a1744 3
# Since etc${VERSION}.tgz is not in DEFAULTSETS for upgrades, it can always be
# in SANESETS.
SANESETS="bsd base${VERSION}.tgz etc${VERSION}.tgz"
d1747 5
a1751 3
: ${EDITOR:=ed}
[[ -x /usr/bin/vi ]] && EDITOR=vi
export EDITOR
d1762 1
a1762 1
	cat <<__EOT
a1775 1
makedev $resp || exit
@


1.1.1.3
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d1 1
a1 1
#	$OpenBSD: install.sub,v 1.388 2005/07/02 00:55:48 uwe Exp $
d482 2
a483 2
Select sets by entering a set name, a file name pattern or 'all'. De-select
sets by prepending a '-' to the set name, file name pattern or 'all'. Selected
@


