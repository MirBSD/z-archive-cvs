head	1.19;
access;
symbols
	MIRBSD_9_BASE:1.13
	MIRBSD_8:1.5.0.2
	MIRBSD_8_BASE:1.5
	cvs-200507211800:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2007.05.07.15.46.24;	author tg;	state dead;
branches;
next	1.18;
commitid	100463F49DA1187D74F;

1.18
date	2007.05.07.15.21.14;	author tg;	state Exp;
branches;
next	1.17;
commitid	100463F43D3067E6553;

1.17
date	2007.05.07.14.06.04;	author tg;	state Exp;
branches;
next	1.16;
commitid	100463F322D3CC3A59A;

1.16
date	2007.04.29.22.17.46;	author tg;	state Exp;
branches;
next	1.15;
commitid	100463519761D6D8E11;

1.15
date	2006.09.17.20.05.15;	author tg;	state Exp;
branches;
next	1.14;
commitid	100450DAA8B4F62B6C3;

1.14
date	2006.09.17.19.28.57;	author tg;	state Exp;
branches;
next	1.13;
commitid	100450DA20303EFF79D;

1.13
date	2006.06.08.19.03.00;	author tg;	state Exp;
branches;
next	1.12;
commitid	100448873FE537168BE;

1.12
date	2006.06.04.11.46.50;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004482C8223FB04DD1;

1.11
date	2006.05.26.12.34.37;	author tg;	state Exp;
branches;
next	1.10;
commitid	1004476F5EA1153F2A4;

1.10
date	2006.05.26.11.55.16;	author tg;	state Exp;
branches;
next	1.9;
commitid	1004476ECB0544641F5;

1.9
date	2006.05.25.12.33.09;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004475A41627A214CB;

1.8
date	2006.05.09.22.55.36;	author tg;	state Exp;
branches;
next	1.7;
commitid	10044611DC32012DAD5;

1.7
date	2006.05.09.22.17.34;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004461151461D91848;

1.6
date	2006.04.09.22.43.09;	author tg;	state Exp;
branches;
next	1.5;
commitid	10044398E051C349F15;

1.5
date	2005.11.16.17.08.46;	author tg;	state Exp;
branches
	1.5.2.1;
next	1.4;
commitid	622b437b67a833ab;

1.4
date	2005.04.12.20.57.29;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2005.03.16.17.19.06;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.06.18.55.22;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.22.06;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.5.2.1
date	2006.05.10.17.51.08;	author tg;	state Exp;
branches;
next	;
commitid	1004462281503DB3DA7;

1.1.1.1
date	2005.02.05.17.22.06;	author tg;	state Exp;
branches;
next	;


desc
@@


1.19
log
@consolidate crc.c, crc.h, md5.c, libz/adler32 into cksum.c
@
text
@/**	$MirOS: src/bin/md5/md5.c,v 1.18 2007/05/07 15:21:14 tg Exp $ */
/*	$OpenBSD: md5.c,v 1.32 2004/12/29 17:32:44 millert Exp $	*/

/*
 * Copyright (c) 2001, 2003 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * The following disclaimer must also be retained:
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 *-
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
 */

#include <sys/param.h>
#include <sys/time.h>
#include <ctype.h>
#include <err.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include <md4.h>
#include <md5.h>
#include <rmd160.h>
#include <sfv.h>
#include <sha1.h>
#include <sha2.h>
#include <suma.h>
#include <tiger.h>
#include <whirlpool.h>
#include "crc.h"

__RCSID("$MirOS: src/bin/md5/md5.c,v 1.18 2007/05/07 15:21:14 tg Exp $");

#define MAX_DIGEST_LEN	128

typedef uint64_t SIZE_CTX;

union ANY_CTX {
	CKSUM_CTX cksum;
	MD4_CTX md4;
	MD5_CTX md5;
	RMD160_CTX rmd160;
	SHA1_CTX sha1;
	SHA256_CTX sha256;
	SHA384_CTX sha384;
	SHA512_CTX sha512;
	SUM_CTX sum;
	SYSVSUM_CTX sysvsum;
	SUMA_CTX suma;
	ADLER32_CTX adler32;
	SFV_CTX sfv;
	TIGER_CTX tiger;
	WHIRLPOOL_CTX whirlpool;
	SIZE_CTX size;
};

void digest_print(const char *, const char *, const char *);
void digest_print_short(const char *, const char *, const char *);
void digest_print_string(const char *, const char *, const char *);
void digest_print_sfv(const char *, const char *, const char *);
void digest_printbin_pad(const char *);
void digest_printbin_string(const char *);
void digest_printbin_stringle(const char *);

void SIZE_Init(SIZE_CTX *);
void SIZE_Update(SIZE_CTX *, const uint8_t *, size_t);
char *SIZE_End(SIZE_CTX *, char *);

#define NHASHES	16
struct hash_functions {
	const char *name;
	size_t digestlen;
	void *ctx;	/* XXX - only used by digest_file() */
	void (*init)(void *);
	void (*update)(void *, const unsigned char *, unsigned int);
	char * (*end)(void *, char *);
	void (*printbin)(const char *);
	void (*print)(const char *, const char *, const char *);
	void (*printstr)(const char *, const char *, const char *);
} functions[NHASHES + 1] = {
	{
		"CKSUM",
		CKSUM_DIGEST_LENGTH * 2,
		NULL,
		(void (*)(void *))CKSUM_Init,
		(void (*)(void *, const unsigned char *, unsigned int))CKSUM_Update,
		(char *(*)(void *, char *))CKSUM_End,
		digest_printbin_pad,
		digest_print_short,
		digest_print_short
	}, {
		"SUM",
		SUM_DIGEST_LENGTH * 2,
		NULL,
		(void (*)(void *))SUM_Init,
		(void (*)(void *, const unsigned char *, unsigned int))SUM_Update,
		(char *(*)(void *, char *))SUM_End,
		digest_printbin_pad,
		digest_print_short,
		digest_print_short
	}, {
		"SYSVSUM",
		SYSVSUM_DIGEST_LENGTH * 2,
		NULL,
		(void (*)(void *))SYSVSUM_Init,
		(void (*)(void *, const unsigned char *, unsigned int))SYSVSUM_Update,
		(char *(*)(void *, char *))SYSVSUM_End,
		digest_printbin_pad,
		digest_print_short,
		digest_print_short
	}, {
		"ADLER32",
		ADLER32_DIGEST_LENGTH * 2,
		NULL,
		(void (*)(void *))ADLER32_Init,
		(void (*)(void *, const unsigned char *, unsigned int))ADLER32_Update,
		(char *(*)(void *, char *))ADLER32_End,
		digest_printbin_string,
		digest_print,
		digest_print_string
	}, {
		"SUMA",
		SUMA_DIGEST_LENGTH * 2,
		NULL,
		(void (*)(void *))SUMAInit,
		(void (*)(void *, const unsigned char *, unsigned int))SUMAUpdate,
		(char *(*)(void *, char *))SUMAEnd,
		digest_printbin_stringle,
		digest_print,
		digest_print_string
	}, {
		"SFV",
		SFV_DIGEST_LENGTH * 2,
		NULL,
		(void (*)(void *))SFVInit,
		(void (*)(void *, const unsigned char *, unsigned int))SFVUpdate,
		(char *(*)(void *, char *))SFVEnd,
		digest_printbin_stringle,
		digest_print_sfv,
		digest_print_sfv
	}, {
		"SIZE",
		16,
		NULL,
		(void (*)(void *))SIZE_Init,
		(void (*)(void *, const unsigned char *, unsigned int))SIZE_Update,
		(char *(*)(void *, char *))SIZE_End,
		digest_printbin_pad,
		digest_print,
		digest_print_string
	}, {
		"MD4",
		MD4_DIGEST_LENGTH * 2,
		NULL,
		(void (*)(void *))MD4Init,
		(void (*)(void *, const unsigned char *, unsigned int))MD4Update,
		(char *(*)(void *, char *))MD4End,
		digest_printbin_string,
		digest_print,
		digest_print_string
	}, {
		"MD5",
		MD5_DIGEST_LENGTH * 2,
		NULL,
		(void (*)(void *))MD5Init,
		(void (*)(void *, const unsigned char *, unsigned int))MD5Update,
		(char *(*)(void *, char *))MD5End,
		digest_printbin_string,
		digest_print,
		digest_print_string
	}, {
		"RMD160",
		RMD160_DIGEST_LENGTH * 2,
		NULL,
		(void (*)(void *))RMD160Init,
		(void (*)(void *, const unsigned char *, unsigned int))RMD160Update,
		(char *(*)(void *, char *))RMD160End,
		digest_printbin_string,
		digest_print,
		digest_print_string
	}, {
		"SHA1",
		SHA1_DIGEST_LENGTH * 2,
		NULL,
		(void (*)(void *))SHA1Init,
		(void (*)(void *, const unsigned char *, unsigned int))SHA1Update,
		(char *(*)(void *, char *))SHA1End,
		digest_printbin_string,
		digest_print,
		digest_print_string
	}, {
		"SHA256",
		SHA256_DIGEST_LENGTH * 2,
		NULL,
		(void (*)(void *))SHA256_Init,
		(void (*)(void *, const unsigned char *, unsigned int))SHA256_Update,
		(char *(*)(void *, char *))SHA256_End,
		digest_printbin_string,
		digest_print,
		digest_print_string
	}, {
		"SHA384",
		SHA384_DIGEST_LENGTH * 2,
		NULL,
		(void (*)(void *))SHA384_Init,
		(void (*)(void *, const unsigned char *, unsigned int))SHA384_Update,
		(char *(*)(void *, char *))SHA384_End,
		digest_printbin_string,
		digest_print,
		digest_print_string
	}, {
		"SHA512",
		SHA512_DIGEST_LENGTH * 2,
		NULL,
		(void (*)(void *))SHA512_Init,
		(void (*)(void *, const unsigned char *, unsigned int))SHA512_Update,
		(char *(*)(void *, char *))SHA512_End,
		digest_printbin_string,
		digest_print,
		digest_print_string
	}, {
		"TIGER",
		TIGER_DIGEST_LENGTH * 2,
		NULL,
		(void (*)(void *))TIGERInit,
		(void (*)(void *, const unsigned char *, unsigned int))TIGERUpdate,
		(char *(*)(void *, char *))TIGEREnd,
		digest_printbin_string,
		digest_print,
		digest_print_string
	}, {
		"WHIRLPOOL",
		WHIRLPOOL_DIGEST_LENGTH * 2,
		NULL,
		(void (*)(void *))WHIRLPOOLInit,
		(void (*)(void *, const unsigned char *, unsigned int))WHIRLPOOLUpdate,
		(char *(*)(void *, char *))WHIRLPOOLEnd,
		digest_printbin_string,
		digest_print,
		digest_print_string
	}, {
		NULL, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL
	},
};

__dead void usage(void);
void digest_file(const char *, struct hash_functions **, int, int);
int digest_filelist(const char *, struct hash_functions *);
void digest_string(char *, struct hash_functions **);
void digest_test(struct hash_functions **);
void digest_time(struct hash_functions **);

extern char *__progname;

int
main(int argc, char **argv)
{
	struct hash_functions *hf = NULL, *hashes[NHASHES + 1];
	int fl, i, error;
	int cflag, pflag, tflag, xflag, bflag;
	char *cp, *input_string;

	input_string = NULL;
	error = cflag = pflag = tflag = xflag = bflag = 0;
	memset(hashes, 0, sizeof(hashes));
	while ((fl = getopt(argc, argv, "a:bco:ps:tx")) != -1) {
		switch (fl) {
		case 'a':
			while ((cp = strsep(&optarg, " \t,")) != NULL) {
				if (*cp == '\0')
					continue;
				for (hf = functions; hf->name != NULL; hf++)
					if (strcasecmp(hf->name, cp) == 0)
						break;
				if (hf->name == NULL) {
					warnx("unknown algorithm \"%s\"", cp);
					usage();
				}
				for (i = 0; i < NHASHES && hashes[i] != hf; i++)
					if (hashes[i] == NULL) {
						hashes[i] = hf;
						break;
					}
			}
			break;
		case 'b':
			bflag = 1;
			break;
		case 'c':
			cflag = 1;
			break;
		case 'o':
			if (strcmp(optarg, "1") == 0)
				hf = &functions[1];
			else if (strcmp(optarg, "2") == 0)
				hf = &functions[2];
			else {
				warnx("illegal argument to -o option");
				usage();
			}
			for (i = 0; i < NHASHES && hashes[i] != hf; i++) {
				if (hashes[i] == NULL) {
					hashes[i] = hf;
					break;
				}
			}
			break;
		case 'p':
			pflag = 1;
			break;
		case 's':
			input_string = optarg;
			break;
		case 't':
			tflag = 1;
			break;
		case 'x':
			xflag = 1;
			break;
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	/* Most arguments are mutually exclusive */
	fl = pflag + tflag + xflag + cflag + (input_string != NULL) +
	    bflag - (bflag & pflag);
	if (fl > 1 || (fl && argc && cflag == 0 && bflag == 0))
		usage();
	if (cflag != 0 && hashes[1] != NULL)
		errx(1, "only a single algorithm may be specified in -c mode");

	/* No algorithm specified, check the name we were called as. */
	if (hashes[0] == NULL) {
		for (hf = functions; hf->name != NULL; hf++) {
			if (strcasecmp(hf->name, __progname) == 0) {
				hashes[0] = hf;
				break;
			}
		}
		if (hashes[0] == NULL)
			hashes[0] = &functions[0];	/* default to cksum */
	}

	if (tflag)
		digest_time(hashes);
	else if (xflag)
		digest_test(hashes);
	else if (input_string)
		digest_string(input_string, hashes);
	else if (cflag) {
		if (argc == 0)
			error = digest_filelist("-", hashes[0]);
		else
			while (argc--)
				error += digest_filelist(*argv++, hashes[0]);
	} else if (pflag || argc == 0)
		digest_file("-", hashes, pflag, bflag);
	else
		while (argc--)
			digest_file(*argv++, hashes, 0, bflag);

	return(error ? EXIT_FAILURE : EXIT_SUCCESS);
}

void
digest_string(char *string, struct hash_functions **hashes)
{
	struct hash_functions *hf;
	char digest[MAX_DIGEST_LEN + 1];
	union ANY_CTX context;

	while (*hashes != NULL) {
		hf = *hashes++;
		hf->init(&context);
		hf->update(&context, (const unsigned char *)string,
		    (unsigned int)strlen(string));
		(void)hf->end(&context, digest);
		cksum_addpool(digest);
		hf->printstr(hf->name, string, digest);
	}
}

void
digest_print(const char *name, const char *what, const char *digest)
{
	(void)printf("%s (%s) = %s\n", name, what, digest);
}

void
digest_print_string(const char *name, const char *what, const char *digest)
{
	(void)printf("%s (\"%s\") = %s\n", name, what, digest);
}

void
digest_print_short(const char *name __attribute__((unused)),
    const char *what, const char *digest)
{
	(void)printf("%s %s\n", digest, what);
}

void
digest_print_sfv(const char *name __attribute__((unused)),
    const char *what, const char *digest)

{
	(void)printf("%s %s\n", what, digest);
}

void
digest_file(const char *file, struct hash_functions **hashes, int echo,
    int dobin)
{
	struct hash_functions **hfp;
	int fd;
	ssize_t nread;
	u_char data[BUFSIZ];
	char digest[MAX_DIGEST_LEN + 1];

	if (strcmp(file, "-") == 0)
		fd = STDIN_FILENO;
	else if ((fd = open(file, O_RDONLY, 0)) == -1) {
		warn("cannot open %s", file);
		return;
	}

	if (echo)
		fflush(stdout);

	for (hfp = hashes; *hfp != NULL; hfp++) {
		if (((*hfp)->ctx = malloc(sizeof(union ANY_CTX))) == NULL)
			err(1, NULL);
		(*hfp)->init((*hfp)->ctx);
	}
	while ((nread = read(fd, data, sizeof(data))) > 0) {
		if (echo)
			write(STDOUT_FILENO, data, (size_t)nread);
		for (hfp = hashes; *hfp != NULL; hfp++)
			(*hfp)->update((*hfp)->ctx, data, (unsigned int)nread);
	}
	if (nread == -1) {
		warn("%s: read error", file);
		if (fd != STDIN_FILENO)
			close(fd);
		return;
	}
	if (fd != STDIN_FILENO)
		close(fd);
	for (hfp = hashes; *hfp != NULL; hfp++) {
		(void)(*hfp)->end((*hfp)->ctx, digest);
		free((*hfp)->ctx);
		cksum_addpool(digest);
		if (dobin)
			(*hfp)->printbin(digest);
		else if (fd == STDIN_FILENO)
			(void)puts(digest);
		else
			(*hfp)->print((*hfp)->name, file, digest);
	}
}

/*
 * Parse through the input file looking for valid lines.
 * If one is found, use this checksum and file as a reference and
 * generate a new checksum against the file on the filesystem.
 * Print out the result of each comparison.
 */
int
digest_filelist(const char *file, struct hash_functions *defhash)
{
	int fd, found, error;
	unsigned int algorithm_max, algorithm_min;
	const char *algorithm;
	char *filename, *checksum, *buf, *p;
	char digest[MAX_DIGEST_LEN + 1];
	char *lbuf = NULL;
	FILE *fp;
	ssize_t nread;
	size_t len;
	u_char data[BUFSIZ];
	union ANY_CTX context;
	struct hash_functions *hf;

	if (strcmp(file, "-") == 0) {
		fp = stdin;
	} else if ((fp = fopen(file, "r")) == NULL) {
		warn("cannot open %s", file);
		return(1);
	}

	if (defhash < &functions[7])
		/*
		 * no GNU format for sum, cksum, sysvsum, suma,
		 * adler32, size, sfv
		 */
		defhash = NULL;

	algorithm_max = algorithm_min = strlen(functions[0].name);
	for (hf = &functions[1]; hf->name != NULL; hf++) {
		len = strlen(hf->name);
		algorithm_max = MAX(algorithm_max, len);
		algorithm_min = MIN(algorithm_min, len);
	}

	error = found = 0;
	while ((buf = fgetln(fp, &len))) {
		if (buf[len - 1] == '\n')
			buf[len - 1] = '\0';
		else {
			if ((lbuf = malloc(len + 1)) == NULL)
				err(1, NULL);

			(void)memcpy(lbuf, buf, len);
			lbuf[len] = '\0';
			buf = lbuf;
		}
		while (isspace(*buf))
			buf++;

		/*
		 * Crack the line into an algorithm, filename, and checksum.
		 * Lines are of the form:
		 *  ALGORITHM (FILENAME) = CHECKSUM
		 *
		 * Fallback on GNU form:
		 *  CHECKSUM  FILENAME
		 */
		p = strchr(buf, ' ');
		if (p != NULL && *(p + 1) == '(') {
			/* BSD form */
			*p = '\0';
			algorithm = buf;
			len = strlen(algorithm);
			if (len > algorithm_max || len < algorithm_min)
				continue;

			filename = p + 2;
			p = strrchr(filename, ')');
			if (p == NULL || strncmp(p + 1, " = ", (size_t)3) != 0)
				continue;
			*p = '\0';

			checksum = p + 4;
			p = strpbrk(checksum, " \t\r");
			if (p != NULL)
				*p = '\0';

			/*
			 * Check that the algorithm is one we recognize.
			 */
			for (hf = functions; hf->name != NULL; hf++) {
				if (strcmp(algorithm, hf->name) == 0)
					break;
			}
			if (hf->name == NULL ||
			    strlen(checksum) != hf->digestlen)
				continue;
		} else {
			/* could be GNU form */
			if ((hf = defhash) == NULL)
				continue;
			algorithm = hf->name;
			checksum = buf;
			if ((p = strchr(checksum, ' ')) == NULL)
				continue;
			*p++ = '\0';
			while (isspace(*p))
				p++;
			if (*p == '\0')
				continue;
			filename = p;
			p = strpbrk(filename, "\t\r");
			if (p != NULL)
				*p = '\0';
		}

		if ((fd = open(filename, O_RDONLY, 0)) == -1) {
			warn("cannot open %s", filename);
			(void)printf("(%s) %s: FAILED\n", algorithm, filename);
			error = 1;
			continue;
		}

		found = 1;
		hf->init(&context);
		while ((nread = read(fd, data, sizeof(data))) > 0)
			hf->update(&context, data, (unsigned int)nread);
		if (nread == -1) {
			warn("%s: read error", file);
			error = 1;
			close(fd);
			continue;
		}
		close(fd);
		(void)hf->end(&context, digest);
		cksum_addpool(digest);

		if (strcmp(checksum, digest) == 0)
			(void)printf("(%s) %s: OK\n", algorithm, filename);
		else
			(void)printf("(%s) %s: FAILED\n", algorithm, filename);
	}
	if (fp != stdin)
		fclose(fp);
	if (!found)
		warnx("%s: no properly formatted checksum lines found", file);
	if (lbuf != NULL)
		free(lbuf);
	return(error || !found);
}

#define TEST_BLOCK_LEN 10000
#define TEST_BLOCK_COUNT 10000

#ifndef timersub
#define timersub(tvp, uvp, vvp)                                         \
        do {                                                            \
                (vvp)->tv_sec = (tvp)->tv_sec - (uvp)->tv_sec;          \
                (vvp)->tv_usec = (tvp)->tv_usec - (uvp)->tv_usec;       \
                if ((vvp)->tv_usec < 0) {                               \
                        (vvp)->tv_sec--;                                \
                        (vvp)->tv_usec += 1000000;                      \
                }                                                       \
        } while (0)
#endif

void
digest_time(struct hash_functions **hashes)
{
	struct hash_functions *hf;
	struct timeval start, stop, res;
	union ANY_CTX context;
	unsigned i;
	u_char data[TEST_BLOCK_LEN];
	char digest[MAX_DIGEST_LEN + 1];
	double elapsed;

	while (*hashes != NULL) {
		hf = *hashes++;
		(void)printf("%s time trial.  Processing %d %d-byte blocks...",
		    hf->name, TEST_BLOCK_COUNT, TEST_BLOCK_LEN);
		fflush(stdout);

		/* Initialize data based on block number. */
		for (i = 0; i < TEST_BLOCK_LEN; i++)
			data[i] = (u_char)(i & 0xff);

		gettimeofday(&start, NULL);
		hf->init(&context);
		for (i = 0; i < TEST_BLOCK_COUNT; i++)
			hf->update(&context, data, TEST_BLOCK_LEN);
		(void)hf->end(&context, digest);
		gettimeofday(&stop, NULL);
		timersub(&stop, &start, &res);
		elapsed = res.tv_sec + res.tv_usec / 1000000.0;

		(void)printf("\nDigest = %s\n", digest);
		(void)printf("Time   = %f seconds\n", elapsed);
		(void)printf("Speed  = %f bytes/second\n",
		    TEST_BLOCK_LEN * TEST_BLOCK_COUNT / elapsed);
	}
}

void
digest_test(struct hash_functions **hashes)
{
	struct hash_functions *hf;
	union ANY_CTX context;
	int i;
	char digest[MAX_DIGEST_LEN + 1];
	unsigned char buf[1000];
	const char *test_strings[] = {
		"",
		"a",
		"abc",
		"message digest",
		"abcdefghijklmnopqrstuvwxyz",
		"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
		"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
		    "0123456789",
		"12345678901234567890123456789012345678901234567890123456789"
		    "012345678901234567890",
	};

	while (*hashes != NULL) {
		hf = *hashes++;
		(void)printf("%s test suite:\n", hf->name);

		for (i = 0; i < 8; i++) {
			hf->init(&context);
			hf->update((void *)&context,
			    (unsigned const char *)test_strings[i],
			    (unsigned int)strlen(test_strings[i]));
			(void)hf->end(&context, digest);
			hf->printstr(hf->name, test_strings[i], digest);
		}

		/* Now simulate a string of a million 'a' characters. */
		memset(buf, 'a', sizeof(buf));
		hf->init(&context);
		for (i = 0; i < 1000; i++)
			hf->update(&context, buf,
			    (unsigned int)sizeof(buf));
		(void)hf->end(&context, digest);
		hf->print(hf->name, "one million 'a' characters",
		    digest);
	}
}

void
usage(void)
{
	fprintf(stderr, "usage: %s [-[b]p | -t | -x | -c [checklist ...] | "
	    "-s string | [-b] file ...]\n", __progname);
	if (strcmp(__progname, "cksum") == 0)
		fprintf(stderr, "             [-a algorithms]] [-o 1 | 2]\n");

	exit(EXIT_FAILURE);
}

void
digest_printbin_pad(const char *digest)
{
	uint64_t one, two;
	char *c;

	one = strtoll(digest, &c, 10);
	if (*c) {
		two = strtoll(++c, NULL, 10);
		if (asprintf(&c, "%016llX%016llX", one, two) == -1)
			return;
	} else if (asprintf(&c, "%016llX", one) == -1)
		return;
	digest_printbin_string(c);
	free(c);
}

void
digest_printbin_string(const char *digest)
{
	int i, j, k;

	for (i = 0; i < (ssize_t)(strlen(digest)/2); ++i) {
		j = digest[i * 2] - 0x30;
		k = digest[i * 2 + 1] - 0x30;
		if ((j < 0) || (k < 0))
			break;
		j = (j > 9) ? (((j - 7) > 15) ? (j - 0x27) : (j - 7)) : j;
		k = (k > 9) ? (((k - 7) > 15) ? (k - 0x27) : (k - 7)) : k;
		if ((j < 0) || (k < 0) || (j > 15) || (k > 15))
			break;
		putchar((j << 4) | k);
	}
}

void
digest_printbin_stringle(const char *digest)
{
	uint32_t dgst;
	char *c;

	dgst = strtoul(digest, NULL, 16);
	if (asprintf(&c, "%02X%02X%02X%02X",
	    dgst & 0xff, (dgst >> 8) & 0xff,
	    (dgst >> 16) & 0xff, dgst >> 24) == -1)
		return;
	digest_printbin_string(c);
	free(c);
}

void
SIZE_Init(SIZE_CTX *ctx)
{
	*ctx = 0;
}

void
SIZE_Update(SIZE_CTX *ctx, const uint8_t *buf __attribute__((unused)), size_t n)
{
	*ctx += n;
}

char *
SIZE_End(SIZE_CTX *ctx, char *digest)
{
	if (digest == NULL) {
		if (asprintf(&digest, "%llu", *ctx) == -1)
			return (NULL);
	} else
		snprintf(digest, 21, "%llu", *ctx);

	return (digest);
}
@


1.18
log
@add suma and sfv hashes in the standard format, too
(can't do adler32 that easily for now, later; sum/cksum/sysvsum differ, never)
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/md5/md5.c,v 1.17 2007/05/07 14:06:04 tg Exp $ */
d49 1
a49 1
__RCSID("$MirOS: src/bin/md5/md5.c,v 1.17 2007/05/07 14:06:04 tg Exp $");
@


1.17
log
@introduce the whirlpool hash function (finally!)
code taken from TNF pkgsrc® pkgtools/digest tool
actual source is the public domain reference implementation

XXX test this on big-endian platforms
XXX adjust mirmake

this libc addition rides on yesterday's minor bump
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/md5/md5.c,v 1.16 2007/04/29 22:17:46 tg Exp $ */
d41 1
d44 1
a47 1
#include "suma.h"
d49 1
a49 1
__RCSID("$MirOS: src/bin/md5/md5.c,v 1.16 2007/04/29 22:17:46 tg Exp $");
d142 3
a144 3
		(void (*)(void *))SUMA_Init,
		(void (*)(void *, const unsigned char *, unsigned int))SUMA_Update,
		(char *(*)(void *, char *))SUMA_End,
d149 20
a238 10
		"SFV",
		SFV_DIGEST_LENGTH * 2,
		NULL,
		(void (*)(void *))SFV_Init,
		(void (*)(void *, const unsigned char *, unsigned int))SFV_Update,
		(char *(*)(void *, char *))SFV_End,
		digest_printbin_stringle,
		digest_print_sfv,
		digest_print_sfv
	}, {
a258 10
		"SIZE",
		16,
		NULL,
		(void (*)(void *))SIZE_Init,
		(void (*)(void *, const unsigned char *, unsigned int))SIZE_Update,
		(char *(*)(void *, char *))SIZE_End,
		digest_printbin_pad,
		digest_print,
		digest_print_string
	}, {
d511 6
a516 2
	if (defhash < &functions[4])
		defhash = NULL;	/* No GNU format for sum, cksum, sysvsum, suma */
@


1.16
log
@• use adler stuff from kern lib
• fold rest into crc.[ch]

note:	crc32 here doesn't match the one from zlib, although both
	say they use the same polynomial… weird
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/md5/md5.c,v 1.15 2006/09/17 20:05:15 tg Exp $ */
d11 1
a11 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d13 9
d44 1
d48 1
a48 1
__RCSID("$MirOS: src/bin/md5/md5.c,v 1.15 2006/09/17 20:05:15 tg Exp $");
d69 1
d85 1
a85 1
#define NHASHES	15
d238 10
@


1.15
log
@who says we can't have a SIZE checksum as well?
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/md5/md5.c,v 1.14 2006/09/17 19:28:57 tg Exp $ */
a40 1
#include "adler32.h"
d44 1
a44 1
__RCSID("$MirOS: src/bin/md5/md5.c,v 1.14 2006/09/17 19:28:57 tg Exp $");
@


1.14
log
@add the SFV (from cksfv) and TIGER hashes
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/md5/md5.c,v 1.13 2006/06/08 19:03:00 tg Exp $ */
d45 1
a45 1
__RCSID("$MirOS: src/bin/md5/md5.c,v 1.13 2006/06/08 19:03:00 tg Exp $");
d49 2
d66 1
d77 5
a81 1
#define NHASHES	14
d234 10
d729 5
a733 2
	two = strtoll(++c, NULL, 10);
	if (asprintf(&c, "%016llX%016llX", one, two) == -1)
d771 24
@


1.13
log
@make adler32(3) an additional "low-trust" entropy source,
both in kernel and userland, but not in libstand, and use
it in cksum(1) to post-process digests except in time and
testsuite trials (modulated by time(NULL) or time.tv_sec,
respectively, in libz, and arc4random() in cksum too); no
change in behaviour (one-byte-at-a-time mode not affected
for speed reasons) visible
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/md5/md5.c,v 1.12 2006/06/04 11:46:50 tg Exp $ */
d40 1
a40 1
#include <crc.h>
d42 1
d45 1
a45 1
__RCSID("$MirOS: src/bin/md5/md5.c,v 1.12 2006/06/04 11:46:50 tg Exp $");
d62 2
d69 1
d74 1
a74 1
#define NHASHES	12
d207 20
d391 8
@


1.12
log
@fix endianness of 'suma -b' output (must be little endian,
for certain reasons)

sorry, this commit is too late for today's snapshot, tho
(found out during checksumming the ISO)
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/md5/md5.c,v 1.11 2006/05/26 12:34:37 tg Exp $ */
d44 1
a44 1
__RCSID("$MirOS: src/bin/md5/md5.c,v 1.11 2006/05/26 12:34:37 tg Exp $");
d342 1
d408 1
d548 1
@


1.11
log
@use uint*_t instead of u_int*_t
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/md5/md5.c,v 1.10 2006/05/26 11:55:16 tg Exp $ */
d44 1
a44 1
__RCSID("$MirOS: src/bin/md5/md5.c,v 1.10 2006/05/26 11:55:16 tg Exp $");
d68 1
d129 1
a129 1
		digest_printbin_string,
d701 15
@


1.10
log
@add adler32 (libz-based and my own asm code)
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/md5/md5.c,v 1.9 2006/05/25 12:33:09 tg Exp $ */
d44 1
a44 1
__RCSID("$MirOS: src/bin/md5/md5.c,v 1.9 2006/05/25 12:33:09 tg Exp $");
d581 1
a581 1
	u_int i;
@


1.9
log
@allow multiple -a with -b
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/md5/md5.c,v 1.8 2006/05/09 22:55:36 tg Exp $ */
d41 1
d44 1
a44 1
__RCSID("$MirOS: src/bin/md5/md5.c,v 1.8 2006/05/09 22:55:36 tg Exp $");
d60 1
d69 1
a69 1
#define NHASHES	11
d112 10
@


1.8
log
@fix -b for all supported algorithms (in general, for all "standard"
hashes with an even length of the digest, and for all "traditional"
CRCs with a two-component result and no longer CRC than x^65)

candidate for MFC
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/md5/md5.c,v 1.7 2006/05/09 22:17:34 tg Exp $ */
d43 1
a43 1
__RCSID("$MirOS: src/bin/md5/md5.c,v 1.7 2006/05/09 22:17:34 tg Exp $");
d280 2
a281 3
	if ((bflag + cflag) != 0 && hashes[1] != NULL)
		errx(1, "only a single algorithm may be specified in -%c mode",
		    cflag ? 'c' : 'b');
@


1.7
log
@fix description and usage of the -b option
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/md5/md5.c,v 1.6 2006/04/09 22:43:09 tg Exp $ */
d43 1
a43 1
__RCSID("$MirOS: src/bin/md5/md5.c,v 1.6 2006/04/09 22:43:09 tg Exp $");
d64 2
d75 1
d86 1
d96 1
d106 1
d116 1
d126 1
d136 1
d146 1
d156 1
d166 1
d176 1
d186 1
d190 1
a190 1
		NULL, 0, NULL, NULL, NULL, NULL, NULL, NULL
d395 3
a397 11
		if (dobin) {
			for (nread = 0; nread < (ssize_t)(strlen(digest)/2);
			    ++nread) {
				int i = digest[nread * 2] - 0x30;
				data[nread] = ((i > 9) ? i - 0x27: i) << 4;
				i = digest[nread * 2 + 1] - 0x30;
				data[nread] |= ((i > 9) ? i - 0x27 : i);
			}
			write(STDOUT_FILENO, data, (size_t)nread);
			return;
		} else if (fd == STDIN_FILENO)
d657 32
@


1.6
log
@document -b better and disallow combinations with others which break
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/md5/md5.c,v 1.5 2005/11/16 17:08:46 tg Exp $ */
d43 1
a43 1
__RCSID("$MirOS: src/bin/md5/md5.c,v 1.5 2005/11/16 17:08:46 tg Exp $");
d262 3
a264 2
	fl = pflag + tflag + xflag + cflag + (input_string != NULL) + bflag;
	if (fl > 1 || (fl && argc && cflag == 0))
d266 3
a268 2
	if (cflag != 0 && hashes[1] != NULL)
		errx(1, "only a single algorithm may be specified in -c mode");
a285 2
	else if (bflag)
		digest_file("-", hashes, pflag, 1);
d295 1
a295 1
		digest_file("-", hashes, pflag, 0);
d298 1
a298 1
			digest_file(*argv++, hashes, 0, 0);
d644 2
a645 2
	fprintf(stderr, "usage: %s [-b | -p | -t | -x | -c [checklist ...] | "
	    "-s string | file ...]\n", __progname);
@


1.5
log
@* apply patches from the port
* clean up for __CRAZY=Yes build
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/md5/md5.c,v 1.4 2005/04/12 20:57:29 tg Exp $ */
d43 1
a43 1
__RCSID("$MirOS: src/bin/md5/md5.c,v 1.4 2005/04/12 20:57:29 tg Exp $");
d262 1
a262 1
	fl = pflag + tflag + xflag + cflag + (input_string != NULL);
d644 1
a644 1
	fprintf(stderr, "usage: %s [-p | -t | -x | -c [checklist ...] | "
@


1.5.2.1
log
@MFC src/bin/md5,-rHEAD

ok bsiegert@@
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/md5/md5.c,v 1.8 2006/05/09 22:55:36 tg Exp $ */
d43 1
a43 1
__RCSID("$MirOS: src/bin/md5/md5.c,v 1.8 2006/05/09 22:55:36 tg Exp $");
a63 2
void digest_printbin_pad(const char *);
void digest_printbin_string(const char *);
a72 1
	void (*printbin)(const char *);
a82 1
		digest_printbin_pad,
a91 1
		digest_printbin_pad,
a100 1
		digest_printbin_pad,
a109 1
		digest_printbin_string,
a118 1
		digest_printbin_string,
a127 1
		digest_printbin_string,
a136 1
		digest_printbin_string,
a145 1
		digest_printbin_string,
a154 1
		digest_printbin_string,
a163 1
		digest_printbin_string,
a172 1
		digest_printbin_string,
d176 1
a176 1
		NULL, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL
d262 2
a263 3
	fl = pflag + tflag + xflag + cflag + (input_string != NULL) +
	    bflag - (bflag & pflag);
	if (fl > 1 || (fl && argc && cflag == 0 && bflag == 0))
d265 2
a266 3
	if ((bflag + cflag) != 0 && hashes[1] != NULL)
		errx(1, "only a single algorithm may be specified in -%c mode",
		    cflag ? 'c' : 'b');
d284 2
d295 1
a295 1
		digest_file("-", hashes, pflag, bflag);
d298 1
a298 1
			digest_file(*argv++, hashes, 0, bflag);
d381 11
a391 3
		if (dobin)
			(*hfp)->printbin(digest);
		else if (fd == STDIN_FILENO)
d644 2
a645 2
	fprintf(stderr, "usage: %s [-[b]p | -t | -x | -c [checklist ...] | "
	    "-s string | [-b] file ...]\n", __progname);
a650 32

void
digest_printbin_pad(const char *digest)
{
	uint64_t one, two;
	char *c;

	one = strtoll(digest, &c, 10);
	two = strtoll(++c, NULL, 10);
	if (asprintf(&c, "%016llX%016llX", one, two) == -1)
		return;
	digest_printbin_string(c);
	free(c);
}

void
digest_printbin_string(const char *digest)
{
	int i, j, k;

	for (i = 0; i < (ssize_t)(strlen(digest)/2); ++i) {
		j = digest[i * 2] - 0x30;
		k = digest[i * 2 + 1] - 0x30;
		if ((j < 0) || (k < 0))
			break;
		j = (j > 9) ? (((j - 7) > 15) ? (j - 0x27) : (j - 7)) : j;
		k = (k > 9) ? (((k - 7) > 15) ? (k - 0x27) : (k - 7)) : k;
		if ((j < 0) || (k < 0) || (j > 15) || (k > 15))
			break;
		putchar((j << 4) | k);
	}
}
@


1.4
log
@need <sys/time.h>
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/md5/md5.c,v 1.3 2005/03/16 17:19:06 tg Exp $ */
d43 1
a43 1
__RCSID("$MirOS: src/bin/md5/md5.c,v 1.3 2005/03/16 17:19:06 tg Exp $");
d67 2
a68 2
	char *name;
	int digestlen;
d176 1
a176 1
		NULL,
d313 2
a314 1
		hf->update(&context, string, (unsigned int)strlen(string));
d333 2
a334 1
digest_print_short(const char *name, const char *what, const char *digest)
d382 2
a383 1
			for (nread = 0; nread < (strlen(digest)/2); ++nread) {
d408 3
a410 2
	int algorithm_max, algorithm_min;
	char *algorithm, *filename, *checksum, *buf, *p;
d546 12
d603 1
a603 1
	unsigned char *test_strings[] = {
d622 2
a623 1
			hf->update((void *)&context, test_strings[i],
@


1.3
log
@add a traditional CRC algorithm of mine to the pool
looks like message digests in output, very cool ;-)

at the moment, x86-only. Wish C had a carry flag!
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/md5/md5.c,v 1.2 2005/03/06 18:55:22 tg Exp $ */
d25 1
d43 1
a43 1
__RCSID("$MirOS: src/bin/md5/md5.c,v 1.2 2005/03/06 18:55:22 tg Exp $");
@


1.2
log
@merge src/bin
@
text
@d1 1
a1 1
/**	$MirOS$ */
d40 1
d42 1
a42 1
__RCSID("$MirOS$");
d57 1
d64 1
a64 1
#define NHASHES	10
d103 9
d422 2
a423 2
	if (defhash < &functions[3])
		defhash = NULL;	/* No GNU format for sum, cksum, sysvsum */
@


1.1
log
@Initial revision
@
text
@d1 1
d41 2
d102 1
a102 1
		MD5_DIGEST_LENGTH * 2,
d168 2
a169 2
void usage(void) __attribute__((__noreturn__));
void digest_file(const char *, struct hash_functions **, int);
d180 1
a180 1
	struct hash_functions *hf, *hashes[NHASHES + 1];
d182 1
a182 1
	int cflag, pflag, tflag, xflag;
d186 1
a186 1
	error = cflag = pflag = tflag = xflag = 0;
d188 1
a188 1
	while ((fl = getopt(argc, argv, "a:co:ps:tx")) != -1) {
d208 3
d272 2
d283 1
a283 1
		digest_file("-", hashes, pflag);
d286 1
a286 1
			digest_file(*argv++, hashes, 0);
d326 2
a327 1
digest_file(const char *file, struct hash_functions **hashes, int echo)
d367 10
a376 1
		if (fd == STDIN_FILENO)
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@
