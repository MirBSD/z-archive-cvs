head	1.14;
access;
symbols
	paxmirabilis-20190825:1.14
	paxmirabilis-20190224:1.14
	paxmirabilis-20190210:1.14
	npax:1.1.1.7.0.2
	cvs-20181212:1.1.1.7
	paxmirabilis-20171021:1.10
	paxmirabilis-20161104:1.7
	paxmirabilis-20161031:1.7
	paxmirabilis-20161025:1.7
	paxmirabilis-20160306:1.6
	cvs-201603041945:1.1.1.4
	paxmirabilis-20151013:1.6
	paxmirabilis-20140703:1.6
	paxmirabilis-20120606:1.6
	paxmirabilis-20120605:1.6
	cvs-201206051745:1.1.1.3
	paxmirabilis-20120520:1.5
	paxmirabilis-20120216:1.4
	paxmirabilis-20120212:1.4
	cvs-201202112230:1.1.1.3
	paxmirabilis-20110817:1.3
	MIRBSD_10:1.2.0.2
	MIRBSD_10_BASE:1.2
	cvs-200710231945:1.1.1.2
	cvs-200606232242:1.1.1.2
	MIRBSD_9_BASE:1.1.1.2
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200507211800:1.1.1.1
	cvs-200504291700:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2018.12.13.07.14.16;	author tg;	state Exp;
branches;
next	1.13;
commitid	1005C1206DD06338A12;

1.13
date	2018.12.13.07.12.00;	author tg;	state Exp;
branches;
next	1.12;
commitid	1005C1206596A173853;

1.12
date	2018.12.13.07.09.09;	author tg;	state Exp;
branches;
next	1.11;
commitid	1005C1205A44B32AFA4;

1.11
date	2018.12.12.18.08.41;	author tg;	state Exp;
branches;
next	1.10;
commitid	1005C114EA81986F5EC;

1.10
date	2017.10.14.22.03.32;	author tg;	state Exp;
branches;
next	1.9;
commitid	10059E289C94A3ADF42;

1.9
date	2017.08.08.16.42.49;	author tg;	state Exp;
branches;
next	1.8;
commitid	1005989EA23421E2092;

1.8
date	2017.08.07.20.10.13;	author tg;	state Exp;
branches;
next	1.7;
commitid	1005988C69344442E37;

1.7
date	2016.03.12.12.53.27;	author tg;	state Exp;
branches;
next	1.6;
commitid	10056E4116046C639BE;

1.6
date	2012.06.05.18.22.56;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004FCE4E961DE91080;

1.5
date	2012.05.20.16.13.16;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004FB918314D2FECC0;

1.4
date	2012.02.12.00.27.14;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004F3707786D20BF4A;

1.3
date	2011.08.16.21.32.46;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004E4AE1EF00AF3003;

1.2
date	2007.02.17.04.52.40;	author tg;	state Exp;
branches;
next	1.1;
commitid	10045D68A2D54E2C558;

1.1
date	2005.02.05.17.22.06;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.22.06;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.06.23.23.00.12;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	100449C727D31170AA3;

1.1.1.3
date	2012.02.11.22.47.21;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	1004F36F008225F3522;

1.1.1.4
date	2016.03.04.19.46.09;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	10056D9E61429EE6550;

1.1.1.5
date	2016.03.04.20.54.58;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	10056D9F62E152ECBA5;

1.1.1.6
date	2017.08.08.16.39.56;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	1005989E971384D382B;

1.1.1.7
date	2018.12.12.00.24.22;	author tg;	state Exp;
branches
	1.1.1.7.2.1;
next	;
commitid	1005C1055452C78F9E4;

1.1.1.7.2.1
date	2018.12.12.01.05.50;	author tg;	state Exp;
branches;
next	1.1.1.7.2.2;
commitid	1005C105F03799CC958;

1.1.1.7.2.2
date	2018.12.12.03.13.30;	author tg;	state Exp;
branches;
next	1.1.1.7.2.3;
commitid	1005C107CE315DC51F3;

1.1.1.7.2.3
date	2018.12.12.04.01.20;	author tg;	state Exp;
branches;
next	1.1.1.7.2.4;
commitid	1005C108824649A94FE;

1.1.1.7.2.4
date	2018.12.12.06.03.10;	author tg;	state Exp;
branches;
next	1.1.1.7.2.5;
commitid	1005C10A4B12E5998CE;

1.1.1.7.2.5
date	2018.12.12.06.47.36;	author tg;	state Exp;
branches;
next	;
commitid	1005C10AF1965896ABA;


desc
@@


1.14
log
@place another const with no ill effect
@
text
@/*	$OpenBSD: buf_subs.c,v 1.30 2016/12/20 21:29:08 kettenis Exp $	*/
/*	$NetBSD: buf_subs.c,v 1.5 1995/03/21 09:07:08 cgd Exp $	*/

/*-
 * Copyright (c) 1992 Keith Muller.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if HAVE_STRINGS_H
#include <strings.h>
#endif
#include <unistd.h>

#include "pax.h"
#include "extern.h"

__RCSID("$MirOS: src/bin/pax/buf_subs.c,v 1.11 2018/12/12 18:08:41 tg Exp $");

/*
 * routines which implement archive and file buffering
 */

#define MINFBSZ		512		/* default block size for hole detect */
#define MAXFLT		10		/* default media read error limit */

/*
 * Need to change bufmem to dynamic allocation when the upper
 * limit on blocking size is removed (though that will violate pax spec)
 * MAXBLK define and tests will also need to be updated.
 */
static char bufmem[MAXBLK+BLKMULT];	/* i/o buffer + pushback id space */
static char *buf;			/* normal start of i/o buffer */
static char *bufend;			/* end or last char in i/o buffer */
static char *bufpt;			/* read/write point in i/o buffer */
int blksz = MAXBLK;			/* block input/output size in bytes */
int wrblksz;				/* user spec output size in bytes */
int maxflt = MAXFLT;			/* MAX consecutive media errors */
int rdblksz;				/* first read blksize (tapes only) */
off_t wrlimit;				/* # of bytes written per archive vol */
off_t wrcnt;				/* # of bytes written on current vol */
off_t rdcnt;				/* # of bytes read on current vol */

/*
 * wr_start()
 *	set up the buffering system to operate in a write mode
 * Return:
 *	0 if ok, -1 if the user specified write block size violates pax spec
 */

int
wr_start(void)
{
	buf = &(bufmem[BLKMULT]);
	/*
	 * Check to make sure the write block size meets pax specs. If the user
	 * does not specify a blocksize, we use the format default blocksize.
	 * We must be picky on writes, so we do not allow the user to create an
	 * archive that might be hard to read elsewhere. If all ok, we then
	 * open the first archive volume
	 */
	if (!wrblksz)
		wrblksz = frmt->bsz;
	if (wrblksz > MAXBLK) {
		paxwarn(1, "Write block size %d too large, maximum is: %d",
		    wrblksz, MAXBLK);
		return(-1);
	}
	if (wrblksz % BLKMULT) {
		paxwarn(1, "Write block size %d is not a %d byte multiple",
		    wrblksz, BLKMULT);
		return(-1);
	}
	if (wrblksz > MAXBLK_POSIX) {
		paxwarn(0, "Write block size %d larger than POSIX max %d, archive may not be portable",
			wrblksz, MAXBLK_POSIX);
		return(-1);
	}

	/*
	 * we only allow wrblksz to be used with all archive operations
	 */
	blksz = rdblksz = wrblksz;
	if ((ar_open(arcname) < 0) && (ar_next() < 0))
		return(-1);
	wrcnt = 0;
	bufend = buf + wrblksz;
	bufpt = buf;
	return(0);
}

/*
 * rd_start()
 *	set up buffering system to read an archive
 * Return:
 *	0 if ok, -1 otherwise
 */

int
rd_start(void)
{
	/*
	 * leave space for the header pushback (see get_arc()). If we are
	 * going to append and user specified a write block size, check it
	 * right away
	 */
	buf = &(bufmem[BLKMULT]);
	if ((act == APPND) && wrblksz) {
		if (wrblksz > MAXBLK) {
			paxwarn(1, "Write block size %d too large, maximum is: %d",
			    wrblksz, MAXBLK);
			return (-1);
		}
		if (wrblksz % BLKMULT) {
			paxwarn(1, "Write block size %d is not a %d byte multiple",
			wrblksz, BLKMULT);
			return(-1);
		}
	}

	/*
	 * open the archive
	 */
	if ((ar_open(arcname) < 0) && (ar_next() < 0))
		return(-1);
	bufend = buf + rdblksz;
	bufpt = bufend;
	rdcnt = 0;
	return(0);
}

/*
 * cp_start()
 *	set up buffer system for copying within the filesystem
 */

void
cp_start(void)
{
	buf = &(bufmem[BLKMULT]);
	rdblksz = blksz = MAXBLK;
}

/*
 * appnd_start()
 *	Set up the buffering system to append new members to an archive that
 *	was just read. The last block(s) of an archive may contain a format
 *	specific trailer. To append a new member, this trailer has to be
 *	removed from the archive. The first byte of the trailer is replaced by
 *	the start of the header of the first file added to the archive. The
 *	format specific end read function tells us how many bytes to move
 *	backwards in the archive to be positioned BEFORE the trailer. Two
 *	different position have to be adjusted, the O.S. file offset (e.g. the
 *	position of the tape head) and the write point within the data we have
 *	stored in the read (soon to become write) buffer. We may have to move
 *	back several records (the number depends on the size of the archive
 *	record and the size of the format trailer) to read up the record where
 *	the first byte of the trailer is recorded. Trailers may span (and
 *	overlap) record boundaries.
 *	We first calculate which record has the first byte of the trailer. We
 *	move the OS file offset back to the start of this record and read it
 *	up. We set the buffer write pointer to be at this byte (the byte where
 *	the trailer starts). We then move the OS file pointer back to the
 *	start of this record so a flush of this buffer will replace the record
 *	in the archive.
 *	A major problem is rewriting this last record. For archives stored
 *	on disk files, this is trivial. However, many devices are really picky
 *	about the conditions under which they will allow a write to occur.
 *	Often devices restrict the conditions where writes can be made,
 *	so it may not be feasible to append archives stored on all types of
 *	devices.
 * Return:
 *	0 for success, -1 for failure
 */

int
appnd_start(off_t skcnt)
{
	int res;
	off_t cnt;

	if (exit_val != 0) {
		paxwarn(0, "Cannot append to an archive that may have flaws.");
		return(-1);
	}
	/*
	 * if the user did not specify a write blocksize, inherit the size used
	 * in the last archive volume read. (If a is set we still use rdblksz
	 * until next volume, cannot shift sizes within a single volume).
	 */
	if (!wrblksz)
		wrblksz = blksz = rdblksz;
	else
		blksz = rdblksz;

	/*
	 * make sure that this volume allows appends
	 */
	if (ar_app_ok() < 0)
		return(-1);

	/*
	 * Calculate bytes to move back and move in front of record where we
	 * need to start writing from. Remember we have to add in any padding
	 * that might be in the buffer after the trailer in the last block. We
	 * travel skcnt + padding ROUNDED UP to blksize.
	 */
	skcnt += bufend - bufpt;
	if ((cnt = (skcnt/blksz) * blksz) < skcnt)
		cnt += blksz;
	if (ar_rev(cnt) < 0)
		goto out;

	/*
	 * We may have gone too far if there is valid data in the block we are
	 * now in front of, read up the block and position the pointer after
	 * the valid data.
	 */
	if ((cnt -= skcnt) > 0) {
		/*
		 * watch out for stupid tape drives. ar_rev() will set rdblksz
		 * to be real physical blocksize so we must loop until we get
		 * the old rdblksz (now in blksz). If ar_rev() fouls up the
		 * determination of the physical block size, we will fail.
		 */
		bufpt = buf;
		bufend = buf + blksz;
		while (bufpt < bufend) {
			if ((res = ar_read(bufpt, rdblksz)) <= 0)
				goto out;
			bufpt += res;
		}
		if (ar_rev(bufpt - buf) < 0)
			goto out;
		bufpt = buf + cnt;
		bufend = buf + blksz;
	} else {
		/*
		 * buffer is empty
		 */
		bufend = buf + blksz;
		bufpt = buf;
	}
	rdblksz = blksz;
	rdcnt -= skcnt;
	wrcnt = 0;

	/*
	 * At this point we are ready to write. If the device requires special
	 * handling to write at a point were previously recorded data resides,
	 * that is handled in ar_set_wr(). From now on we operate under normal
	 * ARCHIVE mode (write) conditions
	 */
	if (ar_set_wr() < 0)
		return(-1);
	act = ARCHIVE;
	return(0);

 out:
	paxwarn(1, "Unable to rewrite archive trailer, cannot append.");
	return(-1);
}

/*
 * rd_sync()
 *	A read error occurred on this archive volume. Resync the buffer and
 *	try to reset the device (if possible) so we can continue to read. Keep
 *	trying to do this until we get a valid read, or we reach the limit on
 *	consecutive read faults (at which point we give up). The user can
 *	adjust the read error limit through a command line option.
 * Returns:
 *	0 on success, and -1 on failure
 */

int
rd_sync(void)
{
	int errcnt = 0;
	int res;

	/*
	 * if the user says bail out on first fault, we are out of here...
	 */
	if (maxflt == 0)
		return(-1);
	if (act == APPND) {
		paxwarn(1, "Unable to append when there are archive read errors.");
		return(-1);
	}

	/*
	 * poke at device and try to get past media error
	 */
	if (ar_rdsync() < 0) {
		if (ar_next() < 0)
			return(-1);
		else
			rdcnt = 0;
	}

	for (;;) {
		if ((res = ar_read(buf, blksz)) > 0) {
			/*
			 * All right! got some data, fill that buffer
			 */
			bufpt = buf;
			bufend = buf + res;
			rdcnt += res;
			return(0);
		}

		/*
		 * Oh well, yet another failed read...
		 * if error limit reached, ditch. o.w. poke device to move past
		 * bad media and try again. if media is badly damaged, we ask
		 * the poor (and upset user at this point) for the next archive
		 * volume. remember the goal on reads is to get the most we
		 * can extract out of the archive.
		 */
		if ((maxflt > 0) && (++errcnt > maxflt))
			paxwarn(0,"Archive read error limit (%d) reached",maxflt);
		else if (ar_rdsync() == 0)
			continue;
		if (ar_next() < 0)
			break;
		rdcnt = 0;
		errcnt = 0;
	}
	return(-1);
}

/*
 * pback()
 *	push the data used during the archive id phase back into the I/O
 *	buffer. This is required as we cannot be sure that the header does NOT
 *	overlap a block boundary (as in the case we are trying to recover a
 *	flawed archived). This was not designed to be used for any other
 *	purpose. (What software engineering, HA!)
 *	WARNING: do not even THINK of pback greater than BLKMULT, unless the
 *	pback space is increased.
 */

void
pback(const char *pt, int cnt)
{
	bufpt -= cnt;
	memcpy(bufpt, pt, cnt);
}

/*
 * rd_skip()
 *	skip forward in the archive during a archive read. Used to get quickly
 *	past file data and padding for files the user did NOT select.
 * Return:
 *	0 if ok, -1 failure, and 1 when EOF on the archive volume was detected.
 */

int
rd_skip(off_t skcnt)
{
	off_t res;
	off_t cnt;
	off_t skipped = 0;

	if (skcnt < 0) {
		paxwarn(1, "Trying to skip backwards; corrupt archive likely");
		sig_cleanup(0);
	}

	/*
	 * consume what data we have in the buffer. If we have to move forward
	 * whole records, we call the low level skip function to see if we can
	 * move within the archive without doing the expensive reads on data we
	 * do not want.
	 */
	if (skcnt == 0)
		return(0);
	res = MINIMUM((bufend - bufpt), skcnt);
	bufpt += res;
	skcnt -= res;

	/*
	 * if skcnt is now 0, then no additional i/o is needed
	 */
	if (skcnt == 0)
		return(0);

	/*
	 * We have to read more, calculate complete and partial record reads
	 * based on rdblksz. we skip over "cnt" complete records
	 */
	res = skcnt%rdblksz;
	cnt = (skcnt/rdblksz) * rdblksz;

	/*
	 * if the skip fails, we will have to resync. ar_fow will tell us
	 * how much it can skip over. We will have to read the rest.
	 */
	if (ar_fow(cnt, &skipped) < 0)
		return(-1);
	res += cnt - skipped;
	rdcnt += skipped;

	/*
	 * what is left we have to read (which may be the whole thing if
	 * ar_fow() told us the device can only read to skip records);
	 */
	while (res > 0) {
		cnt = bufend - bufpt;
		/*
		 * if the read fails, we will have to resync
		 */
		if ((cnt <= 0) && ((cnt = buf_fill()) < 0))
			return(-1);
		if (cnt == 0)
			return(1);
		cnt = MINIMUM(cnt, res);
		bufpt += cnt;
		res -= cnt;
	}
	return(0);
}

/*
 * wr_fin()
 *	flush out any data (and pad if required) the last block. We always pad
 *	with zero (even though we do not have to). Padding with 0 makes it a
 *	lot easier to recover if the archive is damaged. zero padding SHOULD
 *	BE a requirement....
 */

void
wr_fin(void)
{
	if (frmt->is_uar) {
		/*XXX breaks tape/file/stream abstraction */
		extern int arfd;

		char *bufbt = buf;
		ssize_t n;

		while (bufpt > bufbt) {
			n = write(arfd, bufbt, bufpt - bufbt);
			if (n < 0) {
				syswarn(1, errno, "Could not finish writing");
				return;
			}
			bufbt += n;
		}
	} else if (bufpt > buf) {
		memset(bufpt, 0, bufend - bufpt);
		bufpt = bufend;
		(void)buf_flush(blksz);
	}
}

/*
 * wr_rdbuf()
 *	fill the write buffer from data passed to it in a buffer (usually used
 *	by format specific write routines to pass a file header). On failure we
 *	punt. We do not allow the user to continue to write flawed archives.
 *	We assume these headers are not very large (the memory copy we use is
 *	a bit expensive).
 * Return:
 *	0 if buffer was filled ok, -1 o.w. (buffer flush failure)
 */

int
wr_rdbuf(const char *out, int outcnt)
{
	int cnt;

	/*
	 * while there is data to copy copy into the write buffer. when the
	 * write buffer fills, flush it to the archive and continue
	 */
	while (outcnt > 0) {
		cnt = bufend - bufpt;
		if ((cnt <= 0) && ((cnt = buf_flush(blksz)) < 0))
			return(-1);
		/*
		 * only move what we have space for
		 */
		cnt = MINIMUM(cnt, outcnt);
		memcpy(bufpt, out, cnt);
		bufpt += cnt;
		out += cnt;
		outcnt -= cnt;
	}
	return(0);
}

/*
 * rd_wrbuf()
 *	copy from the read buffer into a supplied buffer a specified number of
 *	bytes. If the read buffer is empty fill it and continue to copy.
 *	usually used to obtain a file header for processing by a format
 *	specific read routine.
 * Return
 *	number of bytes copied to the buffer, 0 indicates EOF on archive volume,
 *	-1 is a read error
 */

int
rd_wrbuf(char *in, int cpcnt)
{
	int res;
	int cnt;
	int incnt = cpcnt;

	/*
	 * loop until we fill the buffer with the requested number of bytes
	 */
	while (incnt > 0) {
		cnt = bufend - bufpt;
		if ((cnt <= 0) && ((cnt = buf_fill()) <= 0)) {
			/*
			 * read error, return what we got (or the error if
			 * no data was copied). The caller must know that an
			 * error occurred and has the best knowledge what to
			 * do with it
			 */
			if ((res = cpcnt - incnt) > 0)
				return(res);
			return(cnt);
		}

		/*
		 * calculate how much data to copy based on whats left and
		 * state of buffer
		 */
		cnt = MINIMUM(cnt, incnt);
		memcpy(in, bufpt, cnt);
		bufpt += cnt;
		incnt -= cnt;
		in += cnt;
	}
	return(cpcnt);
}

/*
 * wr_skip()
 *	skip forward during a write. In other words add padding to the file.
 *	we add zero filled padding as it makes flawed archives much easier to
 *	recover from. the caller tells us how many bytes of padding to add
 *	This routine was not designed to add HUGE amount of padding, just small
 *	amounts (a few 512 byte blocks at most)
 * Return:
 *	0 if ok, -1 if there was a buf_flush failure
 */

int
wr_skip(off_t skcnt)
{
	int cnt;

	/*
	 * loop while there is more padding to add
	 */
	while (skcnt > 0) {
		cnt = bufend - bufpt;
		if ((cnt <= 0) && ((cnt = buf_flush(blksz)) < 0))
			return(-1);
		cnt = MINIMUM(cnt, skcnt);
		memset(bufpt, 0, cnt);
		bufpt += cnt;
		skcnt -= cnt;
	}
	return(0);
}

/*
 * wr_rdfile()
 *	fill write buffer with the contents of a file. We are passed an	open
 *	file descriptor to the file and the archive structure that describes
 *	the file we are storing. The variable "left" is modified to contain the
 *	number of bytes of the file we were NOT able to write to the archive.
 *	it is important that we always write EXACTLY the number of bytes that
 *	the format specific write routine told us to. The file can also get
 *	bigger, so reading to the end of file would create an improper archive,
 *	we just detect this case and warn the user. We never create a bad
 *	archive if we can avoid it. Of course trying to archive files that are
 *	active is asking for trouble. It we fail, we pass back how much we
 *	could NOT copy and let the caller deal with it.
 * Return:
 *	0 ok, -1 if archive write failure. a short read of the file returns a
 *	0, but "left" is set to be greater than zero.
 */

int
wr_rdfile(ARCHD *arcn, int ifd, off_t *left)
{
	int cnt;
	int res = 0;
	off_t size = arcn->sb.st_size;
	struct stat sb;

	/*
	 * while there are more bytes to write
	 */
	while (size > 0) {
		cnt = bufend - bufpt;
		if ((cnt <= 0) && ((cnt = buf_flush(blksz)) < 0)) {
			*left = size;
			return(-1);
		}
		cnt = MINIMUM(cnt, size);
		if ((res = read(ifd, bufpt, cnt)) <= 0)
			break;
		size -= res;
		bufpt += res;
	}

	/*
	 * better check the file did not change during this operation
	 * or the file read failed.
	 */
	if (res < 0)
		syswarn(1, errno, "Read fault on %s", arcn->org_name);
	else if (size != 0)
		paxwarn(1, "File changed size during read %s", arcn->org_name);
	else if (fstat(ifd, &sb) < 0)
		syswarn(1, errno, "Failed stat on %s", arcn->org_name);
	else if (st_timecmp(m, &arcn->sb, &sb, !=))
		paxwarn(1, "File %s was modified during copy to %s",
			arcn->org_name, "archive");
	*left = size;
	return(0);
}

/*
 * rd_wrfile()
 *	extract the contents of a file from the archive. If we are unable to
 *	extract the entire file (due to failure to write the file) we return
 *	the numbers of bytes we did NOT process. This way the caller knows how
 *	many bytes to skip past to find the next archive header. If the failure
 *	was due to an archive read, we will catch that when we try to skip. If
 *	the format supplies a file data crc value, we calculate the actual crc
 *	so that it can be compared to the value stored in the header
 * NOTE:
 *	We call a special function to write the file. This function attempts to
 *	restore file holes (blocks of zeros) into the file. When files are
 *	sparse this saves space, and is a LOT faster. For non sparse files
 *	the performance hit is small. As of this writing, no archive supports
 *	information on where the file holes are.
 * Return:
 *	0 ok, -1 if archive read failure. if we cannot write the entire file,
 *	we return a 0 but "left" is set to be the amount unwritten
 */

int
rd_wrfile(ARCHD *arcn, int ofd, off_t *left)
{
	int cnt = 0;
	off_t size = arcn->sb.st_size;
	int res = 0;
	char *fnm = arcn->name;
	int isem = 1;
	int rem;
	int sz = MINFBSZ;
	struct stat sb;
	uint32_t crc = 0;

	/*
	 * pass the blocksize of the file being written to the write routine,
	 * if the size is zero, use the default MINFBSZ
	 */
	if (ofd < 0)
		sz = PAXPATHLEN + 1;		/* GNU tar long link/file */
	else if (fstat(ofd, &sb) == 0) {
		if (sb.st_blksize > 0)
			sz = (int)sb.st_blksize;
	} else
		syswarn(0,errno,"Unable to obtain block size for file %s",fnm);
	rem = sz;
	*left = 0;

	/*
	 * Copy the archive to the file the number of bytes specified. We have
	 * to assume that we want to recover file holes as none of the archive
	 * formats can record the location of file holes.
	 */
	while (size > 0) {
		cnt = bufend - bufpt;
		/*
		 * if we get a read error, we do not want to skip, as we may
		 * miss a header, so we do not set left, but if we get a write
		 * error, we do want to skip over the unprocessed data.
		 */
		if ((cnt <= 0) && ((cnt = buf_fill()) <= 0))
			break;
		cnt = MINIMUM(cnt, size);
		if ((res = file_write(ofd,bufpt,cnt,&rem,&isem,sz,fnm)) <= 0) {
			*left = size;
			break;
		}

		if (docrc) {
			/*
			 * update the actual crc value
			 */
			cnt = res;
			while (--cnt >= 0)
				crc += *bufpt++ & 0xff;
		} else
			bufpt += res;
		size -= res;
	}

	/*
	 * if the last block has a file hole (all zero), we must make sure this
	 * gets updated in the file. We force the last block of zeros to be
	 * written. just closing with the file offset moved forward may not put
	 * a hole at the end of the file.
	 */
	if (isem && (arcn->sb.st_size > 0))
		file_flush(ofd, fnm, isem);

	/*
	 * if we failed from archive read, we do not want to skip
	 */
	if ((size > 0) && (*left == 0))
		return(-1);

	/*
	 * some formats record a crc on file data. If so, then we compare the
	 * calculated crc to the crc stored in the archive
	 */
	if (docrc && (size == 0) && (arcn->crc != crc))
		paxwarn(1,"Actual crc does not match expected crc %s",arcn->name);
	return(0);
}

/*
 * cp_file()
 *	copy the contents of one file to another. used during -rw phase of pax
 *	just as in rd_wrfile() we use a special write function to write the
 *	destination file so we can properly copy files with holes.
 */

void
cp_file(ARCHD *arcn, int fd1, int fd2)
{
	int cnt;
	off_t cpcnt = 0;
	int res = 0;
	char *fnm = arcn->name;
	int no_hole = 0;
	int isem = 1;
	int rem;
	int sz = MINFBSZ;
	struct stat sb;

	/*
	 * check for holes in the source file. If none, we will use regular
	 * write instead of file write.
	 */
	 if (((off_t)(arcn->sb.st_blocks * BLKMULT)) >= arcn->sb.st_size)
		++no_hole;

	/*
	 * pass the blocksize of the file being written to the write routine,
	 * if the size is zero, use the default MINFBSZ
	 */
	if (fstat(fd2, &sb) == 0) {
		if (sb.st_blksize > 0)
			sz = sb.st_blksize;
	} else
		syswarn(0,errno,"Unable to obtain block size for file %s",fnm);
	rem = sz;

	/*
	 * read the source file and copy to destination file until EOF
	 */
	for (;;) {
		if ((cnt = read(fd1, buf, blksz)) <= 0)
			break;
		if (no_hole)
			res = write(fd2, buf, cnt);
		else
			res = file_write(fd2, buf, cnt, &rem, &isem, sz, fnm);
		if (res != cnt)
			break;
		cpcnt += cnt;
	}

	/*
	 * check to make sure the copy is valid.
	 */
	if (res < 0)
		syswarn(1, errno, "Failed write during copy of %s to %s",
			arcn->org_name, arcn->name);
	else if (cpcnt != arcn->sb.st_size)
		paxwarn(1, "File %s changed size during copy to %s",
			arcn->org_name, arcn->name);
	else if (fstat(fd1, &sb) < 0)
		syswarn(1, errno, "Failed stat on %s", arcn->org_name);
	else if (st_timecmp(m, &arcn->sb, &sb, !=))
		paxwarn(1, "File %s was modified during copy to %s",
			arcn->org_name, arcn->name);

	/*
	 * if the last block has a file hole (all zero), we must make sure this
	 * gets updated in the file. We force the last block of zeros to be
	 * written. just closing with the file offset moved forward may not put
	 * a hole at the end of the file.
	 */
	if (!no_hole && isem && (arcn->sb.st_size > 0))
		file_flush(fd2, fnm, isem);
}

/*
 * buf_fill()
 *	fill the read buffer with the next record (or what we can get) from
 *	the archive volume.
 * Return:
 *	Number of bytes of data in the read buffer, -1 for read error, and
 *	0 when finished (user specified termination in ar_next()).
 */

int
buf_fill(void)
{
	return (buf_fill_internal(blksz));
}
/*XXX exposure of this breaks block alignment, use only in ar */
int
buf_fill_internal(int numb)
{
	int cnt;
	static int fini = 0;

	if (fini)
		return(0);

	for (;;) {
		/*
		 * try to fill the buffer. on error the next archive volume is
		 * opened and we try again.
		 */
		if ((cnt = ar_read(buf, numb)) > 0) {
			bufpt = buf;
			bufend = buf + cnt;
			rdcnt += cnt;
			return(cnt);
		}

		/*
		 * errors require resync, EOF goes to next archive
		 * but in case we have not determined yet the format,
		 * this means that we have a very short file, so we
		 * are done again.
		 */
		if (cnt < 0)
			break;
		if (ar_do_keepopen || frmt == NULL || ar_next() < 0) {
			fini = 1;
			return(0);
		}
		rdcnt = 0;
	}
	exit_val = 1;
	return(-1);
}

/*
 * buf_flush()
 *	force the write buffer to the archive. We are passed the number of
 *	bytes in the buffer at the point of the flush. When we change archives
 *	the record size might change. (either larger or smaller).
 * Return:
 *	0 if all is ok, -1 when a write error occurs.
 */

int
buf_flush(int bufcnt)
{
	int cnt;
	int push = 0;
	int totcnt = 0;

	/*
	 * if we have reached the user specified byte count for each archive
	 * volume, prompt for the next volume. (The non-standard -R flag).
	 * NOTE: If the wrlimit is smaller than wrcnt, we will always write
	 * at least one record. We always round limit UP to next blocksize.
	 */
	if ((wrlimit > 0) && (wrcnt > wrlimit)) {
		paxwarn(0, "User specified archive volume byte limit reached.");
		if (ar_next() < 0) {
			wrcnt = 0;
			exit_val = 1;
			return(-1);
		}
		wrcnt = 0;

		/*
		 * The new archive volume might have changed the size of the
		 * write blocksize. if so we figure out if we need to write
		 * (one or more times), or if there is now free space left in
		 * the buffer (it is no longer full). bufcnt has the number of
		 * bytes in the buffer, (the blocksize, at the point we were
		 * CALLED). Push has the amount of "extra" data in the buffer
		 * if the block size has shrunk from a volume change.
		 */
		bufend = buf + blksz;
		if (blksz > bufcnt)
			return(0);
		if (blksz < bufcnt)
			push = bufcnt - blksz;
	}

	/*
	 * We have enough data to write at least one archive block
	 */
	for (;;) {
		/*
		 * write a block and check if it all went out ok
		 */
		cnt = ar_write(buf, blksz);
		if (cnt == blksz) {
			/*
			 * the write went ok
			 */
			wrcnt += cnt;
			totcnt += cnt;
			if (push > 0) {
				/* we have extra data to push to the front.
				 * check for more than 1 block of push, and if
				 * so we loop back to write again
				 */
				memcpy(buf, bufend, push);
				bufpt = buf + push;
				if (push >= blksz) {
					push -= blksz;
					continue;
				}
			} else
				bufpt = buf;
			return(totcnt);
		} else if (cnt > 0) {
			/*
			 * Oh drat we got a partial write!
			 * if format does not care about alignment let it go,
			 * we warned the user in ar_write().... but this means
			 * the last record on this volume violates pax spec....
			 */
			totcnt += cnt;
			wrcnt += cnt;
			bufpt = buf + cnt;
			cnt = bufcnt - cnt;
			memcpy(buf, bufpt, cnt);
			bufpt = buf + cnt;
			if (!frmt->blkalgn || ((cnt % frmt->blkalgn) == 0))
				return(totcnt);
			break;
		}

		/*
		 * All done, go to next archive
		 */
		wrcnt = 0;
		if (ar_next() < 0)
			break;

		/*
		 * The new archive volume might also have changed the block
		 * size. if so, figure out if we have too much or too little
		 * data for using the new block size
		 */
		bufend = buf + blksz;
		if (blksz > bufcnt)
			return(0);
		if (blksz < bufcnt)
			push = bufcnt - blksz;
	}

	/*
	 * write failed, stop pax. we must not create a bad archive!
	 */
	exit_val = 1;
	return(-1);
}

#ifndef SMALL
/*
 * wr_rdfile replacement for the Unix Archiver (padding)
 */
int
uar_wr_data(ARCHD *arcn, int ifd, off_t *left)
{
	int cnt;

	if (wr_rdfile(arcn, ifd, left) < 0)
		return (-1);
	if (!arcn->pad)
		return (0);
	/*XXX arcn->pad == 1 */
	arcn->pad = 0;
	cnt = bufend - bufpt;
	if ((cnt <= 0) && ((cnt = buf_flush(blksz)) < 0)) {
		/* *left == 0 */
		*left = 1;
		return (-1);
	}
	*bufpt++ = '\n';
	return (0);
}
#endif
@


1.13
log
@constify
@
text
@d377 1
a377 1
pback(char *pt, int cnt)
@


1.12
log
@fixing and string pooling and int shortening offensive
@
text
@d502 1
a502 1
wr_rdbuf(char *out, int outcnt)
@


1.11
log
@merge the npax branch into MAIN

asides from a missing dprintf and portability, this ought to be
good enough for people (well me) to play with for now
@
text
@d51 1
a51 1
__RCSID("$MirOS: src/bin/pax/buf_subs.c,v 1.9 2017/08/08 16:42:49 tg Exp $");
d98 2
a99 2
		paxwarn(1, "Write block size of %d too large, maximium is: %d",
			wrblksz, MAXBLK);
d103 1
a103 1
		paxwarn(1, "Write block size of %d is not a %d byte multiple",
d108 1
a108 1
		paxwarn(0, "Write block size of %d larger than POSIX max %d, archive may not be portable",
d143 3
a145 3
			paxwarn(1,"Write block size %d too large, maximium is: %d",
				wrblksz, MAXBLK);
			return(-1);
d658 2
a659 2
		paxwarn(1, "File %s was modified during copy to archive",
			arcn->org_name);
d830 1
a830 1
		syswarn(1, errno, "Failed stat of %s", arcn->org_name);
@


1.10
log
@prevent an entire class of errors: integer overflow in rd_skip() arg

Reported as: Debian #878512

Turns out that “rd_skip(arcn->skip + arcn->pad);” is often called
without checking for negative (error) return, or even throwing away
the result entirely (õÕ) and is called often enough that checking
before calling would be tremendous effort, and to split it up à la
calloc() is certainly another option but this catches it good enough.
We (ab|re)use the signal handler exit function to do some cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.23 +1.30 2009/12/22 12:09:36 jasper Exp $	*/
d37 1
a37 2
#include <sys/param.h>
#include <sys/time.h>
d39 1
a40 2
#include <errno.h>
#include <unistd.h>
d43 5
a47 1
#include <time.h>
d244 1
a244 1
	if (ar_rev((off_t)cnt) < 0)
d266 1
a266 1
		if (ar_rev((off_t)(bufpt - buf)) < 0)
a380 1
	return;
d411 1
a411 1
	res = MIN((bufend - bufpt), skcnt);
d441 1
a441 1
	while (res > 0L) {
d450 1
a450 1
		cnt = MIN(cnt, res);
d517 1
a517 1
		cnt = MIN(cnt, outcnt);
d565 1
a565 1
		cnt = MIN(cnt, incnt);
d593 1
a593 1
	while (skcnt > 0L) {
d597 1
a597 1
		cnt = MIN(cnt, skcnt);
d634 1
a634 1
	while (size > 0L) {
d640 1
a640 1
		cnt = MIN(cnt, size);
d653 1
a653 1
	else if (size != 0L)
d657 1
a657 1
	else if (arcn->sb.st_mtime != sb.st_mtime)
d695 1
a695 1
	u_int32_t crc = 0;
d709 1
a709 1
	*left = 0L;
d716 1
a716 1
	while (size > 0L) {
d725 1
a725 1
		cnt = MIN(cnt, size);
d749 1
a749 1
	if (isem && (arcn->sb.st_size > 0L))
d755 1
a755 1
	if ((size > 0L) && (*left == 0L))
d762 1
a762 1
	if (docrc && (size == 0L) && (arcn->crc != crc))
d778 1
a778 1
	off_t cpcnt = 0L;
d831 1
a831 1
	else if (arcn->sb.st_mtime != sb.st_mtime)
d841 1
a841 1
	if (!no_hole && isem && (arcn->sb.st_size > 0L))
a842 1
	return;
@


1.9
log
@merge
@
text
@d49 1
a49 1
__RCSID("$MirOS: src/bin/pax/buf_subs.c,v 1.7 2016/03/12 12:53:27 tg Exp $");
d397 5
@


1.8
log
@filesystem
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.23 2009/12/22 12:09:36 jasper Exp $	*/
d878 3
d884 1
a884 1
		if (ar_do_keepopen || ar_next() < 0) {
@


1.7
log
@begin stripping down pax for the floppy: drop uar support
@
text
@d49 1
a49 1
__RCSID("$MirOS: src/bin/pax/buf_subs.c,v 1.5 2012/05/20 16:13:16 tg Exp $");
d165 1
a165 1
 *	set up buffer system for copying within the file system
@


1.6
log
@KNF
@
text
@d1010 1
d1034 1
@


1.5
log
@get rid of extern.h including other headers
@
text
@d49 1
a49 1
__RCSID("$MirOS: src/bin/pax/buf_subs.c,v 1.4 2012/02/12 00:27:14 tg Exp $");
d290 1
a290 1
    out:
@


1.4
log
@merge OpenBSD
@
text
@d45 1
d49 1
a49 1
__RCSID("$MirOS: src/bin/pax/buf_subs.c,v 1.3 2011/08/16 21:32:46 tg Exp $");
@


1.3
log
@backend for Unix Archiver libraries – ar(5) and deb(5) format files
(since GNU binutils on ELF systems thinks SYSV style ar is used…)
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.21 2005/11/09 19:59:06 otto Exp $	*/
d48 1
a48 2
__SCCSID("@@(#)buf_subs.c	8.2 (Berkeley) 4/18/94");
__RCSID("$MirOS: src/bin/pax/buf_subs.c,v 1.2 2007/02/17 04:52:40 tg Exp $");
d968 1
a968 1
			 * if format doesnt care about alignment let it go,
@


1.2
log
@__CRAZY clean
@
text
@d49 1
a49 1
__RCSID("$MirOS$");
d462 16
a477 1
	if (bufpt > buf) {
d602 2
a603 2
 *	file descriptor to the file an the archive structure that describes the
 *	file we are storing. The variable "left" is modified to contain the
d852 6
d869 1
a869 1
		if ((cnt = ar_read(buf, blksz)) > 0) {
d881 1
a881 1
		if (ar_next() < 0) {
d1009 24
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.20 2004/04/16 22:50:23 deraadt Exp $	*/
d37 1
a37 9
#ifndef lint
#if 0
static const char sccsid[] = "@@(#)buf_subs.c	8.2 (Berkeley) 4/18/94";
#else
static const char rcsid[] = "$OpenBSD: buf_subs.c,v 1.20 2004/04/16 22:50:23 deraadt Exp $";
#endif
#endif /* not lint */

#include <sys/types.h>
a39 1
#include <sys/param.h>
d48 3
d674 1
a674 1
	u_long crc = 0L;
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@One "miserable" byte in filenames is worth an import

agreed bsiegert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.21 2005/11/09 19:59:06 otto Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: buf_subs.c,v 1.21 2005/11/09 19:59:06 otto Exp $";
d680 1
a680 1
	u_int32_t crc = 0;
@


1.1.1.3
log
@import up-to-date pax from OpenBSD 5.1-current
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.23 2009/12/22 12:09:36 jasper Exp $	*/
d37 8
d954 1
a954 1
			 * if format does not care about alignment let it go,
@


1.1.1.4
log
@pull newer paxtar from OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.27 2015/03/19 05:14:24 guenther Exp $	*/
d40 1
d377 1
d403 1
a403 1
	res = MINIMUM((bufend - bufpt), skcnt);
d442 1
a442 1
		cnt = MINIMUM(cnt, res);
d494 1
a494 1
		cnt = MINIMUM(cnt, outcnt);
d542 1
a542 1
		cnt = MINIMUM(cnt, incnt);
d574 1
a574 1
		cnt = MINIMUM(cnt, skcnt);
d617 1
a617 1
		cnt = MINIMUM(cnt, size);
d634 1
a634 1
	else if (timespeccmp(&arcn->sb.st_mtim, &sb.st_mtim, !=))
d702 1
a702 1
		cnt = MINIMUM(cnt, size);
d808 1
a808 1
	else if (timespeccmp(&arcn->sb.st_mtim, &sb.st_mtim, !=))
d820 1
@


1.1.1.5
log
@revert the import; we’ll just backport the CVE fixes, for now ☹
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.23 2009/12/22 12:09:36 jasper Exp $	*/
a39 1
#include <sys/param.h>
a375 1
	return;
d401 1
a401 1
	res = MIN((bufend - bufpt), skcnt);
d440 1
a440 1
		cnt = MIN(cnt, res);
d492 1
a492 1
		cnt = MIN(cnt, outcnt);
d540 1
a540 1
		cnt = MIN(cnt, incnt);
d572 1
a572 1
		cnt = MIN(cnt, skcnt);
d615 1
a615 1
		cnt = MIN(cnt, size);
d632 1
a632 1
	else if (arcn->sb.st_mtime != sb.st_mtime)
d700 1
a700 1
		cnt = MIN(cnt, size);
d806 1
a806 1
	else if (arcn->sb.st_mtime != sb.st_mtime)
a817 1
	return;
@


1.1.1.6
log
@cherry-pick:
    Fix a bug where archives smaller than 512 bytes would trigger a next volume
    prompt.  From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.23 +1.30 2009/12/22 12:09:36 jasper Exp $	*/
a854 3
		 * but in case we have not determined yet the format,
		 * this means that we have a very short file, so we
		 * are done again.
d858 1
a858 1
		if (frmt == NULL || ar_next() < 0) {
@


1.1.1.7
log
@Import latest OpenBSD paxtar, unmodified, into vendor branch
@
text
@d1 1
a1 1
/*	$OpenBSD: buf_subs.c,v 1.30 2016/12/20 21:29:08 kettenis Exp $	*/
d38 1
d40 1
d240 1
a240 1
	if (ar_rev(cnt) < 0)
d262 1
a262 1
		if (ar_rev(bufpt - buf) < 0)
d377 1
d403 1
a403 1
	res = MINIMUM((bufend - bufpt), skcnt);
d433 1
a433 1
	while (res > 0) {
d442 1
a442 1
		cnt = MINIMUM(cnt, res);
d494 1
a494 1
		cnt = MINIMUM(cnt, outcnt);
d542 1
a542 1
		cnt = MINIMUM(cnt, incnt);
d570 1
a570 1
	while (skcnt > 0) {
d574 1
a574 1
		cnt = MINIMUM(cnt, skcnt);
d611 1
a611 1
	while (size > 0) {
d617 1
a617 1
		cnt = MINIMUM(cnt, size);
d630 1
a630 1
	else if (size != 0)
d634 1
a634 1
	else if (timespeccmp(&arcn->sb.st_mtim, &sb.st_mtim, !=))
d686 1
a686 1
	*left = 0;
d693 1
a693 1
	while (size > 0) {
d702 1
a702 1
		cnt = MINIMUM(cnt, size);
d726 1
a726 1
	if (isem && (arcn->sb.st_size > 0))
d732 1
a732 1
	if ((size > 0) && (*left == 0))
d739 1
a739 1
	if (docrc && (size == 0) && (arcn->crc != crc))
d755 1
a755 1
	off_t cpcnt = 0;
d808 1
a808 1
	else if (timespeccmp(&arcn->sb.st_mtim, &sb.st_mtim, !=))
d818 1
a818 1
	if (!no_hole && isem && (arcn->sb.st_size > 0))
d820 1
@


1.1.1.7.2.1
log
@a little KNF: sort the includes
@
text
@d39 1
d41 1
a41 1
#include <stdio.h>
a43 2
#include <unistd.h>

@


1.1.1.7.2.2
log
@extremely rudimentary conversion to mirtoconf, doesn’t even build yet
@
text
@a42 3
#if HAVE_STRINGS_H
#include <strings.h>
#endif
d670 1
a670 1
	uint32_t crc = 0;
@


1.1.1.7.2.3
log
@make inroads on portability
@
text
@d635 1
a635 1
	else if (st_mtim_cmp(&arcn->sb, &sb, !=))
d809 1
a809 1
	else if (st_mtim_cmp(&arcn->sb, &sb, !=))
@


1.1.1.7.2.4
log
@do the ‘c’s
@
text
@d165 1
a165 1
 *	set up buffer system for copying within the filesystem
d290 1
a290 1
 out:
a395 5
	if (skcnt < 0) {
		paxwarn(1, "Trying to skip backwards; corrupt archive likely");
		sig_cleanup(0);
	}

d461 1
a461 16
	if (frmt->is_uar) {
		/*XXX breaks tape/file/stream abstraction */
		extern int arfd;

		char *bufbt = buf;
		ssize_t n;

		while (bufpt > bufbt) {
			n = write(arfd, bufbt, bufpt - bufbt);
			if (n < 0) {
				syswarn(1, errno, "Could not finish writing");
				return;
			}
			bufbt += n;
		}
	} else if (bufpt > buf) {
d586 2
a587 2
 *	file descriptor to the file and the archive structure that describes
 *	the file we are storing. The variable "left" is modified to contain the
a834 6
	return (buf_fill_internal(blksz));
}
/*XXX exposure of this breaks block alignment, use only in ar */
int
buf_fill_internal(int numb)
{
d846 1
a846 1
		if ((cnt = ar_read(buf, numb)) > 0) {
d861 1
a861 1
		if (ar_do_keepopen || frmt == NULL || ar_next() < 0) {
a988 26

#ifndef SMALL
/*
 * wr_rdfile replacement for the Unix Archiver (padding)
 */
int
uar_wr_data(ARCHD *arcn, int ifd, off_t *left)
{
	int cnt;

	if (wr_rdfile(arcn, ifd, left) < 0)
		return (-1);
	if (!arcn->pad)
		return (0);
	/*XXX arcn->pad == 1 */
	arcn->pad = 0;
	cnt = bufend - bufpt;
	if ((cnt <= 0) && ((cnt = buf_flush(blksz)) < 0)) {
		/* *left == 0 */
		*left = 1;
		return (-1);
	}
	*bufpt++ = '\n';
	return (0);
}
#endif
@


1.1.1.7.2.5
log
@use generic macros, to compensate a bit for this insanity
@
text
@d655 1
a655 1
	else if (st_timecmp(m, &arcn->sb, &sb, !=))
d829 1
a829 1
	else if (st_timecmp(m, &arcn->sb, &sb, !=))
@


