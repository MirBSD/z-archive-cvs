head	1.10;
access;
symbols
	paxmirabilis-20190825:1.10
	paxmirabilis-20190224:1.10
	paxmirabilis-20190210:1.10
	npax:1.1.1.5.0.2
	cvs-20181212:1.1.1.5
	paxmirabilis-20171021:1.8
	paxmirabilis-20161104:1.8
	paxmirabilis-20161031:1.8
	paxmirabilis-20161025:1.8
	paxmirabilis-20160306:1.7
	cvs-201603041945:1.1.1.3
	paxmirabilis-20151013:1.6
	paxmirabilis-20140703:1.6
	paxmirabilis-20120606:1.6
	paxmirabilis-20120605:1.6
	cvs-201206051745:1.1.1.2
	paxmirabilis-20120520:1.5
	paxmirabilis-20120216:1.4
	paxmirabilis-20120212:1.4
	cvs-201202112230:1.1.1.2
	paxmirabilis-20110817:1.3
	MIRBSD_10:1.2.0.2
	MIRBSD_10_BASE:1.2
	cvs-200710231945:1.1.1.1
	cvs-200606232242:1.1.1.1
	MIRBSD_9_BASE:1.1.1.1
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200507211800:1.1.1.1
	cvs-200504291700:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2018.12.13.07.09.11;	author tg;	state Exp;
branches;
next	1.9;
commitid	1005C1205A44B32AFA4;

1.9
date	2018.12.12.18.08.46;	author tg;	state Exp;
branches;
next	1.8;
commitid	1005C114EA81986F5EC;

1.8
date	2016.10.25.19.04.26;	author tg;	state Exp;
branches;
next	1.7;
commitid	100580FACCE7785F0A8;

1.7
date	2016.03.06.14.12.28;	author tg;	state Exp;
branches;
next	1.6;
commitid	10056DC3ADA1858410D;

1.6
date	2012.06.05.18.22.57;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004FCE4E961DE91080;

1.5
date	2012.05.20.16.13.19;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004FB918314D2FECC0;

1.4
date	2012.02.12.00.27.17;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004F3707786D20BF4A;

1.3
date	2008.03.14.15.55.21;	author tg;	state Exp;
branches;
next	1.2;
commitid	10047DA9FD457B61B40;

1.2
date	2007.02.17.04.52.41;	author tg;	state Exp;
branches;
next	1.1;
commitid	10045D68A2D54E2C558;

1.1
date	2005.02.05.17.22.06;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.22.06;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2012.02.11.22.47.21;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	1004F36F008225F3522;

1.1.1.3
date	2016.03.04.19.46.09;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	10056D9E61429EE6550;

1.1.1.4
date	2016.03.04.20.55.03;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	10056D9F62E152ECBA5;

1.1.1.5
date	2018.12.12.00.24.23;	author tg;	state Exp;
branches
	1.1.1.5.2.1;
next	;
commitid	1005C1055452C78F9E4;

1.1.1.5.2.1
date	2018.12.12.00.53.00;	author tg;	state Exp;
branches;
next	1.1.1.5.2.2;
commitid	1005C105BC86262A0B7;

1.1.1.5.2.2
date	2018.12.12.03.13.34;	author tg;	state Exp;
branches;
next	1.1.1.5.2.3;
commitid	1005C107CE315DC51F3;

1.1.1.5.2.3
date	2018.12.12.13.45.36;	author tg;	state Exp;
branches;
next	1.1.1.5.2.4;
commitid	1005C111119117C9572;

1.1.1.5.2.4
date	2018.12.12.15.33.05;	author tg;	state Exp;
branches;
next	;
commitid	1005C112A434F807902;


desc
@@


1.10
log
@fixing and string pooling and int shortening offensive
@
text
@/*	$OpenBSD: sel_subs.c,v 1.27 2018/09/13 12:33:43 millert Exp $	*/
/*	$NetBSD: sel_subs.c,v 1.5 1995/03/21 09:07:42 cgd Exp $	*/

/*-
 * Copyright (c) 1992 Keith Muller.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#if HAVE_BOTH_TIME_H
#include <sys/time.h>
#include <time.h>
#elif HAVE_SYS_TIME_H
#include <sys/time.h>
#elif HAVE_TIME_H
#include <time.h>
#endif
#include <sys/stat.h>
#include <ctype.h>
#if HAVE_GRP_H
#include <grp.h>
#endif
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if HAVE_STRINGS_H
#include <strings.h>
#endif

#include "pax.h"
#include "extern.h"

__RCSID("$MirOS: src/bin/pax/sel_subs.c,v 1.9 2018/12/12 18:08:46 tg Exp $");

/*
 * data structure for storing uid/grp selects (-U, -G non standard options)
 */

#define USR_TB_SZ	317		/* user selection table size */
#define GRP_TB_SZ	317		/* user selection table size */

typedef struct usrt {
	uid_t uid;
	struct usrt *fow;		/* next uid */
} USRT;

typedef struct grpt {
	gid_t gid;
	struct grpt *fow;		/* next gid */
} GRPT;

/*
 * data structure for storing user supplied time ranges (-T option)
 */

#define ATOI2(ar)	((ar)[0] - '0') * 10 + ((ar)[1] - '0'); (ar) += 2;

typedef struct time_rng {
	time_t		low_time;	/* lower inclusive time limit */
	time_t		high_time;	/* higher inclusive time limit */
	int		flgs;		/* option flags */
#define	HASLOW		0x01		/* has lower time limit */
#define HASHIGH		0x02		/* has higher time limit */
#define CMPMTME		0x04		/* compare file modification time */
#define CMPCTME		0x08		/* compare inode change time */
#define CMPBOTH	(CMPMTME|CMPCTME)	/* compare inode and mod time */
	struct time_rng	*fow;		/* next pattern */
} TIME_RNG;

static int str_sec(const char *, time_t *);
static int usr_match(ARCHD *);
static int grp_match(ARCHD *);
static int trng_match(ARCHD *);

static TIME_RNG *trhead = NULL;		/* time range list head */
static TIME_RNG *trtail = NULL;		/* time range list tail */
static USRT **usrtb = NULL;		/* user selection table */
static GRPT **grptb = NULL;		/* group selection table */

/*
 * Routines for selection of archive members
 */

/*
 * sel_chk()
 *	check if this file matches a specified uid, gid or time range
 * Return:
 *	0 if this archive member should be processed, 1 if it should be skipped
 */

int
sel_chk(ARCHD *arcn)
{
	if (((usrtb != NULL) && usr_match(arcn)) ||
	    ((grptb != NULL) && grp_match(arcn)) ||
	    ((trhead != NULL) && trng_match(arcn)))
		return(1);
	return(0);
}

/*
 * User/group selection routines
 *
 * Routines to handle user selection of files based on the file uid/gid. To
 * add an entry, the user supplies either the name or the uid/gid starting with
 * a # on the command line. A \# will escape the #.
 */

/*
 * usr_add()
 *	add a user match to the user match hash table
 * Return:
 *	0 if added ok, -1 otherwise;
 */

int
usr_add(char *str)
{
	unsigned int indx;
	USRT *pt;
	uid_t uid;

	/*
	 * create the table if it doesn't exist
	 */
	if ((str == NULL) || (*str == '\0'))
		return(-1);
	if ((usrtb == NULL) &&
	    ((usrtb = calloc(USR_TB_SZ, sizeof(USRT *))) == NULL)) {
		paxwarn(1, "%s for %s", "Out of memory",
		    "user selection table");
		return (-1);
	}

	/*
	 * figure out user spec
	 */
	if (str[0] != '#') {
		/*
		 * it is a user name, \# escapes # as first char in user name
		 */
		if ((str[0] == '\\') && (str[1] == '#'))
			++str;
		if (uid_uncached(str, &uid) < 0) {
			paxwarn(1, "Unable to find uid for user %s", str);
			return (-1);
		}
	} else
		uid = (uid_t)strtoul(str+1, NULL, 10);
	endpwent();

	/*
	 * hash it and go down the hash chain (if any) looking for it
	 */
	indx = ((unsigned)uid) % USR_TB_SZ;
	if ((pt = usrtb[indx]) != NULL) {
		while (pt != NULL) {
			if (pt->uid == uid)
				return(0);
			pt = pt->fow;
		}
	}

	/*
	 * uid is not yet in the table, add it to the front of the chain
	 */
	if ((pt = malloc(sizeof(USRT))) != NULL) {
		pt->uid = uid;
		pt->fow = usrtb[indx];
		usrtb[indx] = pt;
		return(0);
	}
	paxwarn(1, "%s for %s", "Out of memory",
	    "user selection table");
	return (-1);
}

/*
 * usr_match()
 *	check if this files uid matches a selected uid.
 * Return:
 *	0 if this archive member should be processed, 1 if it should be skipped
 */

static int
usr_match(ARCHD *arcn)
{
	USRT *pt;

	/*
	 * hash and look for it in the table
	 */
	pt = usrtb[((unsigned)arcn->sb.st_uid) % USR_TB_SZ];
	while (pt != NULL) {
		if (pt->uid == arcn->sb.st_uid)
			return(0);
		pt = pt->fow;
	}

	/*
	 * not found
	 */
	return(1);
}

/*
 * grp_add()
 *	add a group match to the group match hash table
 * Return:
 *	0 if added ok, -1 otherwise;
 */

int
grp_add(char *str)
{
	unsigned int indx;
	GRPT *pt;
	gid_t gid;

	/*
	 * create the table if it doesn't exist
	 */
	if ((str == NULL) || (*str == '\0'))
		return(-1);
	if ((grptb == NULL) &&
	    ((grptb = calloc(GRP_TB_SZ, sizeof(GRPT *))) == NULL)) {
		paxwarn(1, "%s for %s", "Out of memory",
		    "group selection table");
		return (-1);
	}

	/*
	 * figure out group spec
	 */
	if (str[0] != '#') {
		/*
		 * it is a group name, \# escapes # as first char in group name
		 */
		if ((str[0] == '\\') && (str[1] == '#'))
			++str;
		if (gid_uncached(str, &gid) < 0) {
			paxwarn(1, "Unable to find gid for group %s", str);
			return (-1);
		}
	} else
		gid = (gid_t)strtoul(str+1, NULL, 10);
	endgrent();

	/*
	 * hash it and go down the hash chain (if any) looking for it
	 */
	indx = ((unsigned)gid) % GRP_TB_SZ;
	if ((pt = grptb[indx]) != NULL) {
		while (pt != NULL) {
			if (pt->gid == gid)
				return(0);
			pt = pt->fow;
		}
	}

	/*
	 * gid not in the table, add it to the front of the chain
	 */
	if ((pt = malloc(sizeof(GRPT))) != NULL) {
		pt->gid = gid;
		pt->fow = grptb[indx];
		grptb[indx] = pt;
		return(0);
	}
	paxwarn(1, "%s for %s", "Out of memory",
	    "group selection table");
	return (-1);
}

/*
 * grp_match()
 *	check if this files gid matches a selected gid.
 * Return:
 *	0 if this archive member should be processed, 1 if it should be skipped
 */

static int
grp_match(ARCHD *arcn)
{
	GRPT *pt;

	/*
	 * hash and look for it in the table
	 */
	pt = grptb[((unsigned)arcn->sb.st_gid) % GRP_TB_SZ];
	while (pt != NULL) {
		if (pt->gid == arcn->sb.st_gid)
			return(0);
		pt = pt->fow;
	}

	/*
	 * not found
	 */
	return(1);
}

/*
 * Time range selection routines
 *
 * Routines to handle user selection of files based on the modification and/or
 * inode change time falling within a specified time range (the non-standard
 * -T flag). The user may specify any number of different file time ranges.
 * Time ranges are checked one at a time until a match is found (if at all).
 * If the file has a mtime (and/or ctime) which lies within one of the time
 * ranges, the file is selected. Time ranges may have a lower and/or a upper
 * value. These ranges are inclusive. When no time ranges are supplied to pax
 * with the -T option, all members in the archive will be selected by the time
 * range routines. When only a lower range is supplied, only files with a
 * mtime (and/or ctime) equal to or younger are selected. When only a upper
 * range is supplied, only files with a mtime (and/or ctime) equal to or older
 * are selected. When the lower time range is equal to the upper time range,
 * only files with a mtime (or ctime) of exactly that time are selected.
 */

/*
 * trng_add()
 *	add a time range match to the time range list.
 *	This is a non-standard pax option. Lower and upper ranges are in the
 *	format: [[[[[cc]yy]mm]dd]HH]MM[.SS] and are comma separated.
 *	Time ranges are based on current time, so 1234 would specify a time of
 *	12:34 today.
 * Return:
 *	0 if the time range was added to the list, -1 otherwise
 */

int
trng_add(char *str)
{
	TIME_RNG *pt;
	char *up_pt = NULL;
	char *stpt;
	char *flgpt;
	int dot = 0;

	/*
	 * throw out the badly formed time ranges
	 */
	if ((str == NULL) || (*str == '\0')) {
		paxwarn(1, "Empty time range string");
		return(-1);
	}

	/*
	 * locate optional flags suffix /{cm}.
	 */
	if ((flgpt = strrchr(str, '/')) != NULL)
		*flgpt++ = '\0';

	for (stpt = str; *stpt != '\0'; ++stpt) {
		if ((*stpt >= '0') && (*stpt <= '9'))
			continue;
		if ((*stpt == ',') && (up_pt == NULL)) {
			*stpt = '\0';
			up_pt = stpt + 1;
			dot = 0;
			continue;
		}

		/*
		 * allow only one dot per range (secs)
		 */
		if ((*stpt == '.') && (!dot)) {
			++dot;
			continue;
		}
		paxwarn(1, "Improperly specified time range: %s", str);
		goto out;
	}

	/*
	 * allocate space for the time range and store the limits
	 */
	if ((pt = malloc(sizeof(TIME_RNG))) == NULL) {
		paxwarn(1, "%s for %s", "Out of memory",
		    "time range");
		return (-1);
	}

	/*
	 * by default we only will check file mtime, but user can specify
	 * mtime, ctime (inode change time) or both.
	 */
	if ((flgpt == NULL) || (*flgpt == '\0'))
		pt->flgs = CMPMTME;
	else {
		pt->flgs = 0;
		while (*flgpt != '\0') {
			switch (*flgpt) {
			case 'M':
			case 'm':
				pt->flgs |= CMPMTME;
				break;
			case 'C':
			case 'c':
				pt->flgs |= CMPCTME;
				break;
			default:
				paxwarn(1, "Bad option %c with time range %s",
				    *flgpt, str);
				free(pt);
				goto out;
			}
			++flgpt;
		}
	}

	/*
	 * start off with the current time
	 */
	pt->low_time = pt->high_time = time(NULL);
	if (*str != '\0') {
		/*
		 * add lower limit
		 */
		if (str_sec(str, &(pt->low_time)) < 0) {
			paxwarn(1, "Illegal %ser time range %s", "low", str);
			free(pt);
			goto out;
		}
		pt->flgs |= HASLOW;
	}

	if ((up_pt != NULL) && (*up_pt != '\0')) {
		/*
		 * add upper limit
		 */
		if (str_sec(up_pt, &(pt->high_time)) < 0) {
			paxwarn(1, "Illegal %ser time range %s", "upp", up_pt);
			free(pt);
			goto out;
		}
		pt->flgs |= HASHIGH;

		/*
		 * check that the upper and lower do not overlap
		 */
		if (pt->flgs & HASLOW) {
			if (pt->low_time > pt->high_time) {
				paxwarn(1, "Upper %s and lower %s time overlap",
					up_pt, str);
				free(pt);
				return(-1);
			}
		}
	}

	pt->fow = NULL;
	if (trhead == NULL) {
		trtail = trhead = pt;
		return(0);
	}
	trtail->fow = pt;
	trtail = pt;
	return(0);

 out:
	paxwarn(1, "Time range format is: [[[[[cc]yy]mm]dd]HH]MM[.SS][/[c][m]]");
	return(-1);
}

/*
 * trng_match()
 *	check if this files mtime/ctime falls within any supplied time range.
 * Return:
 *	0 if this archive member should be processed, 1 if it should be skipped
 */

static int
trng_match(ARCHD *arcn)
{
	TIME_RNG *pt;

	/*
	 * have to search down the list one at a time looking for a match.
	 * remember time range limits are inclusive.
	 */
	pt = trhead;
	while (pt != NULL) {
		switch (pt->flgs & CMPBOTH) {
		case CMPBOTH:
			/*
			 * user wants both mtime and ctime checked for this
			 * time range
			 */
			if (((pt->flgs & HASLOW) &&
			    (arcn->sb.st_mtime < pt->low_time) &&
			    (arcn->sb.st_ctime < pt->low_time)) ||
			    ((pt->flgs & HASHIGH) &&
			    (arcn->sb.st_mtime > pt->high_time) &&
			    (arcn->sb.st_ctime > pt->high_time))) {
				pt = pt->fow;
				continue;
			}
			break;
		case CMPCTME:
			/*
			 * user wants only ctime checked for this time range
			 */
			if (((pt->flgs & HASLOW) &&
			    (arcn->sb.st_ctime < pt->low_time)) ||
			    ((pt->flgs & HASHIGH) &&
			    (arcn->sb.st_ctime > pt->high_time))) {
				pt = pt->fow;
				continue;
			}
			break;
		case CMPMTME:
		default:
			/*
			 * user wants only mtime checked for this time range
			 */
			if (((pt->flgs & HASLOW) &&
			    (arcn->sb.st_mtime < pt->low_time)) ||
			    ((pt->flgs & HASHIGH) &&
			    (arcn->sb.st_mtime > pt->high_time))) {
				pt = pt->fow;
				continue;
			}
			break;
		}
		break;
	}

	if (pt == NULL)
		return(1);
	return(0);
}

/*
 * str_sec()
 *	Convert a time string in the format of [[[[[cc]yy]mm]dd]HH]MM[.SS] to
 *	seconds UTC. Tval already has current time loaded into it at entry.
 * Return:
 *	0 if converted ok, -1 otherwise
 */

static int
str_sec(const char *p, time_t *tval)
{
	struct tm *lt;
	const char *dot, *t;
	size_t len;
	int bigyear;
	int yearset;

	yearset = 0;
	len = strlen(p);

	for (t = p, dot = NULL; *t; ++t) {
		if (isdigit((unsigned char)*t))
			continue;
		if (*t == '.' && dot == NULL) {
			dot = t;
			continue;
		}
		return(-1);
	}

	lt = localtime(tval);

	if (dot != NULL) {			/* .SS */
		if (strlen(++dot) != 2)
			return(-1);
		lt->tm_sec = ATOI2(dot);
		if (lt->tm_sec > 61)
			return(-1);
		len -= 3;
	} else
		lt->tm_sec = 0;

	switch (len) {
	case 12:				/* cc */
		bigyear = ATOI2(p);
		lt->tm_year = (bigyear * 100LL) - 1900LL;
		yearset = 1;
		/* FALLTHROUGH */
	case 10:				/* yy */
		if (yearset) {
			lt->tm_year += ATOI2(p);
		} else {
			lt->tm_year = ATOI2(p);
			if (lt->tm_year < 69)		/* hack for 2000 ;-} */
				lt->tm_year += (2000 - 1900);
		}
		/* FALLTHROUGH */
	case 8:					/* mm */
		lt->tm_mon = ATOI2(p);
		if ((lt->tm_mon > 12) || !lt->tm_mon)
			return(-1);
		--lt->tm_mon;			/* time struct is 0 - 11 */
		/* FALLTHROUGH */
	case 6:					/* dd */
		lt->tm_mday = ATOI2(p);
		if ((lt->tm_mday > 31) || !lt->tm_mday)
			return(-1);
		/* FALLTHROUGH */
	case 4:					/* HH */
		lt->tm_hour = ATOI2(p);
		if (lt->tm_hour > 23)
			return(-1);
		/* FALLTHROUGH */
	case 2:					/* MM */
		lt->tm_min = ATOI2(p);
		if (lt->tm_min > 59)
			return(-1);
		break;
	default:
		return(-1);
	}

	/* convert broken-down time to UTC clock time seconds */
	if ((*tval = mktime(lt)) == -1)
		return(-1);
	return(0);
}
@


1.9
log
@merge the npax branch into MAIN

asides from a missing dprintf and portability, this ought to be
good enough for people (well me) to play with for now
@
text
@d62 1
a62 1
__RCSID("$MirOS: src/bin/pax/sel_subs.c,v 1.7 2016/03/06 14:12:28 tg Exp $");
d159 3
a161 2
		paxwarn(1, "Unable to allocate memory for user selection table");
		return(-1);
d174 2
a175 2
			paxwarn(1, "Unable to find uid for user: %s", str);
			return(-1);
d202 3
a204 2
	paxwarn(1, "User selection table out of memory");
	return(-1);
d256 3
a258 2
		paxwarn(1, "Unable to allocate memory fo group selection table");
		return(-1);
d271 2
a272 2
			paxwarn(1,"Cannot determine gid for group name: %s", str);
			return(-1);
d299 3
a301 2
	paxwarn(1, "Group selection table out of memory");
	return(-1);
d409 3
a411 2
		paxwarn(1, "Unable to allocate memory for time range");
		return(-1);
d451 1
a451 1
			paxwarn(1, "Illegal lower time range %s", str);
d463 1
a463 1
			paxwarn(1, "Illegal upper time range %s", up_pt);
@


1.8
log
@remove all <tzfile.h> remains
@
text
@d1 1
a1 1
/*	$OpenBSD: sel_subs.c,v 1.20 2009/11/12 20:17:03 deraadt Exp $	*/
d37 2
a38 1
#include <sys/param.h>
d40 6
d48 1
d50 1
d55 4
a58 2
#include <time.h>
#include <unistd.h>
a59 1
#include "sel_subs.h"
d63 35
a97 1
__IDSTRING(rcsid_sel_subs_h, MIRCPIO_SEL_SUBS_H);
d148 1
a148 1
	u_int indx;
a149 1
	struct passwd *pw;
d158 1
a158 1
 	    ((usrtb = (USRT **)calloc(USR_TB_SZ, sizeof(USRT *))) == NULL)) {
d172 1
a172 1
		if ((pw = getpwnam(str)) == NULL) {
a175 1
		uid = (uid_t)pw->pw_uid;
d195 1
a195 1
	if ((pt = (USRT *)malloc(sizeof(USRT))) != NULL) {
d243 1
a243 1
	u_int indx;
a244 1
	struct group *gr;
d253 1
a253 1
 	    ((grptb = (GRPT **)calloc(GRP_TB_SZ, sizeof(GRPT *))) == NULL)) {
d259 1
a259 1
	 * figure out user spec
d267 1
a267 1
		if ((gr = getgrnam(str)) == NULL) {
a270 1
		gid = (gid_t)gr->gr_gid;
d290 1
a290 1
	if ((pt = (GRPT *)malloc(sizeof(GRPT))) != NULL) {
d404 1
a404 1
	if ((pt = (TIME_RNG *)malloc(sizeof(TIME_RNG))) == NULL) {
d430 1
a430 1
				(void)free((char *)pt);
d447 1
a447 1
			(void)free((char *)pt);
d459 1
a459 1
			(void)free((char *)pt);
d471 1
a471 1
				(void)free((char *)pt);
d580 1
a580 1
		if (isdigit(*t))
d604 1
a604 1
		lt->tm_year = (bigyear * 100) - 1900;
d613 1
a613 1
				lt->tm_year += 100;
@


1.7
log
@version the *.h files as idstrings, too
@
text
@d52 1
a52 1
__RCSID("$MirOS: src/bin/pax/sel_subs.c,v 1.5 2012/05/20 16:13:19 tg Exp $");
d564 1
a564 1
		lt->tm_year = (bigyear * 100) - TM_YEAR_BASE;
d573 1
a573 3
				lt->tm_year += (2000 - TM_YEAR_BASE);
			else
				lt->tm_year += (1900 - TM_YEAR_BASE);
@


1.6
log
@KNF
@
text
@d53 1
@


1.5
log
@get rid of extern.h including other headers
@
text
@d52 1
a52 1
__RCSID("$MirOS: src/bin/pax/sel_subs.c,v 1.4 2012/02/12 00:27:17 tg Exp $");
d445 1
a445 1
    out:
@


1.4
log
@merge OpenBSD
@
text
@d46 1
d52 1
a52 1
__RCSID("$MirOS: src/bin/pax/sel_subs.c,v 1.3 2008/03/14 15:55:21 tg Exp $");
@


1.3
log
@remove dependency on <tzfile.h> for portable MirCpio

while I don't think the number of seconds per hour is ever going to
change, and preprocessor definitions for that are pointless, I keep
them because BSD policy is to not have magic numbers all over the code
@
text
@d1 1
a1 1
/*	$OpenBSD: sel_subs.c,v 1.18 2004/04/16 22:50:23 deraadt Exp $	*/
d51 1
a51 2
__SCCSID("@@(#)sel_subs.c	8.1 (Berkeley) 5/31/93");
__RCSID("$MirOS: src/bin/pax/sel_subs.c,v 1.2 2007/02/17 04:52:41 tg Exp $");
d388 1
@


1.2
log
@__CRAZY clean
@
text
@a45 1
#include <tzfile.h>
d52 1
a52 1
__RCSID("$MirOS$");
@


1.1
log
@Initial revision
@
text
@d37 1
a37 9
#ifndef lint
#if 0
static const char sccsid[] = "@@(#)sel_subs.c	8.1 (Berkeley) 5/31/93";
#else
static const char rcsid[] = "$OpenBSD: sel_subs.c,v 1.18 2004/04/16 22:50:23 deraadt Exp $";
#endif
#endif /* not lint */

#include <sys/types.h>
a39 1
#include <sys/param.h>
d52 3
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@import up-to-date pax from OpenBSD 5.1-current
@
text
@d1 1
a1 1
/*	$OpenBSD: sel_subs.c,v 1.20 2009/11/12 20:17:03 deraadt Exp $	*/
d37 8
a395 1
				(void)free((char *)pt);
@


1.1.1.3
log
@pull newer paxtar from OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: sel_subs.c,v 1.25 2014/11/23 05:47:49 guenther Exp $	*/
d40 1
d47 1
d113 1
a113 1
	    ((usrtb = calloc(USR_TB_SZ, sizeof(USRT *))) == NULL)) {
d151 1
a151 1
	if ((pt = malloc(sizeof(USRT))) != NULL) {
d210 1
a210 1
	    ((grptb = calloc(GRP_TB_SZ, sizeof(GRPT *))) == NULL)) {
d248 1
a248 1
	if ((pt = malloc(sizeof(GRPT))) != NULL) {
d362 1
a362 1
	if ((pt = malloc(sizeof(TIME_RNG))) == NULL) {
d388 1
a388 1
				free(pt);
d405 1
a405 1
			free(pt);
d417 1
a417 1
			free(pt);
d429 1
a429 1
				free(pt);
d538 1
a538 1
		if (isdigit((unsigned char)*t))
d562 1
a562 1
		lt->tm_year = (bigyear * 100) - 1900;
d571 3
a573 1
				lt->tm_year += (2000 - 1900);
@


1.1.1.4
log
@revert the import; we’ll just backport the CVE fixes, for now ☹
@
text
@d1 1
a1 1
/*	$OpenBSD: sel_subs.c,v 1.20 2009/11/12 20:17:03 deraadt Exp $	*/
a39 1
#include <sys/param.h>
a45 1
#include <tzfile.h>
d111 1
a111 1
 	    ((usrtb = (USRT **)calloc(USR_TB_SZ, sizeof(USRT *))) == NULL)) {
d149 1
a149 1
	if ((pt = (USRT *)malloc(sizeof(USRT))) != NULL) {
d208 1
a208 1
 	    ((grptb = (GRPT **)calloc(GRP_TB_SZ, sizeof(GRPT *))) == NULL)) {
d246 1
a246 1
	if ((pt = (GRPT *)malloc(sizeof(GRPT))) != NULL) {
d360 1
a360 1
	if ((pt = (TIME_RNG *)malloc(sizeof(TIME_RNG))) == NULL) {
d386 1
a386 1
				(void)free((char *)pt);
d403 1
a403 1
			(void)free((char *)pt);
d415 1
a415 1
			(void)free((char *)pt);
d427 1
a427 1
				(void)free((char *)pt);
d536 1
a536 1
		if (isdigit(*t))
d560 1
a560 1
		lt->tm_year = (bigyear * 100) - TM_YEAR_BASE;
d569 1
a569 3
				lt->tm_year += (2000 - TM_YEAR_BASE);
			else
				lt->tm_year += (1900 - TM_YEAR_BASE);
@


1.1.1.5
log
@Import latest OpenBSD paxtar, unmodified, into vendor branch
@
text
@d1 1
a1 1
/*	$OpenBSD: sel_subs.c,v 1.27 2018/09/13 12:33:43 millert Exp $	*/
d38 1
d40 1
d47 2
a48 2
#include <time.h>

d50 1
a52 35
/*
 * data structure for storing uid/grp selects (-U, -G non standard options)
 */

#define USR_TB_SZ	317		/* user selection table size */
#define GRP_TB_SZ	317		/* user selection table size */

typedef struct usrt {
	uid_t uid;
	struct usrt *fow;		/* next uid */
} USRT;

typedef struct grpt {
	gid_t gid;
	struct grpt *fow;		/* next gid */
} GRPT;

/*
 * data structure for storing user supplied time ranges (-T option)
 */

#define ATOI2(ar)	((ar)[0] - '0') * 10 + ((ar)[1] - '0'); (ar) += 2;

typedef struct time_rng {
	time_t		low_time;	/* lower inclusive time limit */
	time_t		high_time;	/* higher inclusive time limit */
	int		flgs;		/* option flags */
#define	HASLOW		0x01		/* has lower time limit */
#define HASHIGH		0x02		/* has higher time limit */
#define CMPMTME		0x04		/* compare file modification time */
#define CMPCTME		0x08		/* compare inode change time */
#define CMPBOTH	(CMPMTME|CMPCTME)	/* compare inode and mod time */
	struct time_rng	*fow;		/* next pattern */
} TIME_RNG;

d104 1
d113 1
a113 1
	    ((usrtb = calloc(USR_TB_SZ, sizeof(USRT *))) == NULL)) {
d127 1
a127 1
		if (uid_from_user(str, &uid) < 0) {
d131 1
d151 1
a151 1
	if ((pt = malloc(sizeof(USRT))) != NULL) {
d201 1
d210 1
a210 1
	    ((grptb = calloc(GRP_TB_SZ, sizeof(GRPT *))) == NULL)) {
d216 1
a216 1
	 * figure out group spec
d224 1
a224 1
		if (gid_from_group(str, &gid) < 0) {
d228 1
d248 1
a248 1
	if ((pt = malloc(sizeof(GRPT))) != NULL) {
d362 1
a362 1
	if ((pt = malloc(sizeof(TIME_RNG))) == NULL) {
d388 1
a388 1
				free(pt);
d405 1
a405 1
			free(pt);
d417 1
a417 1
			free(pt);
d429 1
a429 1
				free(pt);
d538 1
a538 1
		if (isdigit((unsigned char)*t))
d562 1
a562 1
		lt->tm_year = (bigyear * 100) - 1900;
d571 3
a573 1
				lt->tm_year += (2000 - 1900);
@


1.1.1.5.2.1
log
@Wrangle the OpenBSD branch into shape as starting point:

• Revert “Use the new libc uid_from_user() and gid_from_group()
  instead of the pax-specific functions in cache.c” (revisit later)
• fix MAX_TIME_T (plain wrong), mirtoconf later
• drop all NOCPIO
• Revert “Replace name_{uid,gid}() with the libc routines
  user_from_uid() and group_from_gid()”
@
text
@a135 1
	struct passwd *pw;
d158 1
a158 1
		if ((pw = getpwnam(str)) == NULL) {
a161 1
		uid = (uid_t)pw->pw_uid;
a230 1
	struct group *gr;
d253 1
a253 1
		if ((gr = getgrnam(str)) == NULL) {
a256 1
		gid = (gid_t)gr->gr_gid;
@


1.1.1.5.2.2
log
@extremely rudimentary conversion to mirtoconf, doesn’t even build yet
@
text
@a37 8
#if HAVE_BOTH_TIME_H
#include <sys/time.h>
#include <time.h>
#elif HAVE_SYS_TIME_H
#include <sys/time.h>
#elif HAVE_TIME_H
#include <time.h>
#endif
a39 1
#if HAVE_GRP_H
a40 1
#endif
d45 1
a45 3
#if HAVE_STRINGS_H
#include <strings.h>
#endif
d134 1
a134 1
	unsigned int indx;
d231 1
a231 1
	unsigned int indx;
@


1.1.1.5.2.3
log
@two more
@
text
@d488 1
a488 1
 out:
d606 1
a606 1
		lt->tm_year = (bigyear * 100LL) - 1900LL;
@


1.1.1.5.2.4
log
@revisit all those initial reverts
@
text
@d148 1
d171 1
a171 1
		if (uid_uncached(str, &uid) < 0) {
d175 1
d245 1
d268 1
a268 1
		if (gid_uncached(str, &gid) < 0) {
d272 1
@


