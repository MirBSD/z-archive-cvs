head	1.30;
access;
symbols
	paxmirabilis-20190825:1.30
	paxmirabilis-20190224:1.28
	paxmirabilis-20190210:1.28
	npax:1.1.1.9.0.2
	cvs-20181212:1.1.1.9
	paxmirabilis-20171021:1.24
	paxmirabilis-20161104:1.24
	paxmirabilis-20161031:1.24
	paxmirabilis-20161025:1.24
	paxmirabilis-20160306:1.23
	cvs-201603041945:1.1.1.5
	paxmirabilis-20151013:1.18
	paxmirabilis-20140703:1.16
	paxmirabilis-20120606:1.16
	paxmirabilis-20120605:1.16
	cvs-201206051745:1.1.1.4
	paxmirabilis-20120520:1.15
	paxmirabilis-20120216:1.14
	paxmirabilis-20120212:1.12
	cvs-201202112230:1.1.1.4
	paxmirabilis-20110817:1.9
	MIRBSD_10:1.8.0.2
	MIRBSD_10_BASE:1.8
	cvs-200710231945:1.1.1.3
	cvs-200606232242:1.1.1.2
	MIRBSD_9_BASE:1.6
	MIRBSD_8:1.3.0.2
	MIRBSD_8_BASE:1.3
	cvs-200507211800:1.1.1.2
	cvs-200504291700:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2019.08.25.23.06.40;	author tg;	state Exp;
branches;
next	1.29;
commitid	1005D631480152ED348;

1.29
date	2019.08.25.23.02.36;	author tg;	state Exp;
branches;
next	1.28;
commitid	1005D63139B43F0E69D;

1.28
date	2018.12.13.07.09.12;	author tg;	state Exp;
branches;
next	1.27;
commitid	1005C1205A44B32AFA4;

1.27
date	2018.12.12.18.08.47;	author tg;	state Exp;
branches;
next	1.26;
commitid	1005C114EA81986F5EC;

1.26
date	2018.12.12.00.23.07;	author tg;	state Exp;
branches;
next	1.25;
commitid	1005C1054FE750D63F3;

1.25
date	2018.12.12.00.09.28;	author tg;	state Exp;
branches;
next	1.24;
commitid	1005C1051C27816C858;

1.24
date	2016.03.06.21.06.04;	author tg;	state Exp;
branches;
next	1.23;
commitid	10056DC9BD642C24593;

1.23
date	2016.03.06.14.59.08;	author tg;	state Exp;
branches;
next	1.22;
commitid	10056DC45D014C845B2;

1.22
date	2016.03.06.14.50.21;	author tg;	state Exp;
branches;
next	1.21;
commitid	10056DC43B97A48CF3F;

1.21
date	2016.03.06.14.45.41;	author tg;	state Exp;
branches;
next	1.20;
commitid	10056DC42A43432FE88;

1.20
date	2016.03.06.14.12.29;	author tg;	state Exp;
branches;
next	1.19;
commitid	10056DC3ADA1858410D;

1.19
date	2016.03.06.13.47.50;	author tg;	state Exp;
branches;
next	1.18;
commitid	10056DC351700BAF310;

1.18
date	2015.10.13.20.34.14;	author tg;	state Exp;
branches;
next	1.17;
commitid	100561D6ADA0551C2B0;

1.17
date	2015.10.13.20.18.51;	author tg;	state Exp;
branches;
next	1.16;
commitid	100561D673C2A515BC8;

1.16
date	2012.06.05.18.22.57;	author tg;	state Exp;
branches;
next	1.15;
commitid	1004FCE4E961DE91080;

1.15
date	2012.05.20.16.13.19;	author tg;	state Exp;
branches;
next	1.14;
commitid	1004FB918314D2FECC0;

1.14
date	2012.02.16.17.27.32;	author tg;	state Exp;
branches;
next	1.13;
commitid	1004F3D3C992B2187A1;

1.13
date	2012.02.16.17.26.47;	author tg;	state Exp;
branches;
next	1.12;
commitid	1004F3D3C6F0BB38C0C;

1.12
date	2012.02.12.00.44.58;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004F370B9F1314ECC5;

1.11
date	2012.02.12.00.42.29;	author tg;	state Exp;
branches;
next	1.10;
commitid	1004F370B09500A1E8B;

1.10
date	2012.02.12.00.27.18;	author tg;	state Exp;
branches;
next	1.9;
commitid	1004F3707786D20BF4A;

1.9
date	2008.11.08.23.03.38;	author tg;	state Exp;
branches;
next	1.8;
commitid	10049161AB22DF5DFC5;

1.8
date	2007.10.23.20.07.42;	author tg;	state Exp;
branches;
next	1.7;
commitid	100471E5499154FE86E;

1.7
date	2007.02.17.04.52.41;	author tg;	state Exp;
branches;
next	1.6;
commitid	10045D68A2D54E2C558;

1.6
date	2006.06.24.00.21.54;	author tg;	state Exp;
branches;
next	1.5;
commitid	100449C85991FEF5E15;

1.5
date	2006.06.23.23.47.07;	author tg;	state Exp;
branches;
next	1.4;
commitid	100449C7D85561CCE00;

1.4
date	2006.06.23.23.40.20;	author tg;	state Exp;
branches;
next	1.3;
commitid	100449C7BF2082EC534;

1.3
date	2005.11.16.14.27.29;	author tg;	state Exp;
branches;
next	1.2;
commitid	513b437b415971b7;

1.2
date	2005.11.16.13.58.39;	author tg;	state Exp;
branches;
next	1.1;
commitid	63cf437b3768eac1;

1.1
date	2005.02.05.17.22.06;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.22.06;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.29.17.05.16;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.10.23.19.50.48;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	100471E50A5256C77AE;

1.1.1.4
date	2012.02.11.22.47.22;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	1004F36F008225F3522;

1.1.1.5
date	2016.03.04.19.46.09;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	10056D9E61429EE6550;

1.1.1.6
date	2016.03.04.20.55.03;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	10056D9F62E152ECBA5;

1.1.1.7
date	2016.03.06.13.29.55;	author tg;	state Exp;
branches;
next	1.1.1.8;
commitid	10056DC30960F3F5FA0;

1.1.1.8
date	2018.12.12.00.15.07;	author tg;	state Exp;
branches;
next	1.1.1.9;
commitid	1005C1052FA5E745A2C;

1.1.1.9
date	2018.12.12.00.24.23;	author tg;	state Exp;
branches
	1.1.1.9.2.1;
next	;
commitid	1005C1055452C78F9E4;

1.1.1.9.2.1
date	2018.12.12.00.53.00;	author tg;	state Exp;
branches;
next	1.1.1.9.2.2;
commitid	1005C105BC86262A0B7;

1.1.1.9.2.2
date	2018.12.12.00.54.17;	author tg;	state Exp;
branches;
next	1.1.1.9.2.3;
commitid	1005C105C48612B0194;

1.1.1.9.2.3
date	2018.12.12.03.13.34;	author tg;	state Exp;
branches;
next	1.1.1.9.2.4;
commitid	1005C107CE315DC51F3;

1.1.1.9.2.4
date	2018.12.12.06.03.14;	author tg;	state Exp;
branches;
next	1.1.1.9.2.5;
commitid	1005C10A4B12E5998CE;

1.1.1.9.2.5
date	2018.12.12.06.44.40;	author tg;	state Exp;
branches;
next	1.1.1.9.2.6;
commitid	1005C10AE69584968B6;

1.1.1.9.2.6
date	2018.12.12.06.47.38;	author tg;	state Exp;
branches;
next	1.1.1.9.2.7;
commitid	1005C10AF1965896ABA;

1.1.1.9.2.7
date	2018.12.12.06.53.13;	author tg;	state Exp;
branches;
next	1.1.1.9.2.8;
commitid	1005C10B06C02071195;

1.1.1.9.2.8
date	2018.12.12.06.57.43;	author tg;	state Exp;
branches;
next	1.1.1.9.2.9;
commitid	1005C10B17B60390CAF;

1.1.1.9.2.9
date	2018.12.12.07.03.48;	author tg;	state Exp;
branches;
next	1.1.1.9.2.10;
commitid	1005C10B2E50CAEB848;

1.1.1.9.2.10
date	2018.12.12.08.48.15;	author tg;	state Exp;
branches;
next	1.1.1.9.2.11;
commitid	1005C10CB641D052FC1;

1.1.1.9.2.11
date	2018.12.12.10.41.27;	author tg;	state Exp;
branches;
next	1.1.1.9.2.12;
commitid	1005C10E5E87909E6FC;

1.1.1.9.2.12
date	2018.12.12.13.21.35;	author tg;	state Exp;
branches;
next	1.1.1.9.2.13;
commitid	1005C110B68691D809E;

1.1.1.9.2.13
date	2018.12.12.13.45.36;	author tg;	state Exp;
branches;
next	1.1.1.9.2.14;
commitid	1005C111119117C9572;

1.1.1.9.2.14
date	2018.12.12.15.00.26;	author tg;	state Exp;
branches;
next	1.1.1.9.2.15;
commitid	1005C11229872472EAF;

1.1.1.9.2.15
date	2018.12.12.15.05.24;	author tg;	state Exp;
branches;
next	1.1.1.9.2.16;
commitid	1005C1123C435C5AC83;

1.1.1.9.2.16
date	2018.12.12.15.55.09;	author tg;	state Exp;
branches;
next	;
commitid	1005C112F704D0C6EE2;


desc
@@


1.30
log
@support contemporary MirBSD having just added this to libc

(but not bumped the POSuX version supported)
@
text
@/*	$OpenBSD: tables.c,v 1.53 2017/09/16 07:42:34 otto Exp $	*/
/*	$NetBSD: tables.c,v 1.4 1995/03/21 09:07:45 cgd Exp $	*/

/*-
 * Copyright (c) 2005, 2012, 2015, 2016, 2018, 2019
 *	mirabilos <m@@mirbsd.org>
 * Copyright (c) 2011
 *	Svante Signell <svante.signell@@telia.com>
 *	Guillem Jover <guillem@@debian.org>
 * Copyright (c) 1992 Keith Muller.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifdef __MirBSD__
#include <sys/param.h>
#endif
#include <sys/types.h>
#if HAVE_BOTH_TIME_H
#include <sys/time.h>
#include <time.h>
#elif HAVE_SYS_TIME_H
#include <sys/time.h>
#elif HAVE_TIME_H
#include <time.h>
#endif
#include <sys/stat.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if HAVE_STRINGS_H
#include <strings.h>
#endif
#include <unistd.h>

#include "pax.h"
#include "ftimes.h"
#include "extern.h"

__RCSID("$MirOS: src/bin/pax/tables.c,v 1.29 2019/08/25 23:02:36 tg Exp $");

#if (_POSIX_VERSION >= 200809L) || (defined(MirBSD) && (MirBSD > 0x0AB9))
#define REALPATH_CAN_ALLOCATE
#endif

/*
 * Routines for controlling the contents of all the different databases pax
 * keeps. Tables are dynamically created only when they are needed. The
 * goal was speed and the ability to work with HUGE archives. The databases
 * were kept simple, but do have complex rules for when the contents change.
 * As of this writing, the posix library functions were more complex than
 * needed for this application (pax databases have very short lifetimes and
 * do not survive after pax is finished). pax is required to handle very
 * large archives. These database routines carefully combine memory usage and
 * temporary file storage in ways which will not significantly impact runtime
 * performance while allowing the largest possible archives to be handled.
 * Trying to force the fit to the posix database routines was not considered
 * time well spent.
 */

/*
 * data structures and constants used by the different databases kept by pax
 */

/*
 * Hash Table Sizes MUST BE PRIME, if set too small performance suffers.
 * Probably safe to expect 500000 inodes per tape. Assuming good key
 * distribution (inodes) chains of under 50 long (worst case) is ok.
 */
#define L_TAB_SZ	2503		/* hard link hash table size */
#define F_TAB_SZ	50503		/* file time hash table size */
#define N_TAB_SZ	541		/* interactive rename hash table */
#define D_TAB_SZ	317		/* unique device mapping table */
#define A_TAB_SZ	317		/* ftree dir access time reset table */
#define SL_TAB_SZ	317		/* escape symlink tables */
#define MAXKEYLEN	64		/* max number of chars for hash */
#define DIRP_SIZE	64		/* initial size of created dir table */

/*
 * file hard link structure (hashed by dev/ino and chained) used to find the
 * hard links in a filesystem or with some archive formats (cpio)
 */
typedef struct hrdlnk {
	ino_t		ino;	/* files inode number */
	char		*name;	/* name of first file seen with this ino/dev */
	dev_t		dev;	/* files device number */
	u_long		nlink;	/* expected link count */
	struct hrdlnk	*fow;
} HRDLNK;

/*
 * Archive write update file time table (the -u, -C flag), hashed by filename.
 * Filenames are stored in a scratch file at seek offset into the file. The
 * file time (mod time) and the file name length (for a quick check) are
 * stored in a hash table node. We were forced to use a scratch file because
 * with -u, the mtime for every node in the archive must always be available
 * to compare against (and this data can get REALLY large with big archives).
 * By being careful to read only when we have a good chance of a match, the
 * performance loss is not measurable (and the size of the archive we can
 * handle is greatly increased).
 */
typedef struct ftm {
	off_t		seek;		/* location in scratch file */
	struct ftm	*fow;
	int		namelen;	/* file name length */
	struct stat	sb;		/* files last modification time */
} FTM;

/*
 * Interactive rename table (-i flag), hashed by orig filename.
 * We assume this will not be a large table as this mapping data can only be
 * obtained through interactive input by the user. Nobody is going to type in
 * changes for 500000 files? We use chaining to resolve collisions.
 */

typedef struct namt {
	char		*oname;		/* old name */
	char		*nname;		/* new name typed in by the user */
	struct namt	*fow;
} NAMT;

/*
 * Unique device mapping tables. Some protocols (e.g. cpio) require that the
 * <c_dev,c_ino> pair will uniquely identify a file in an archive unless they
 * are links to the same file. Appending to archives can break this. For those
 * protocols that have this requirement we map c_dev to a unique value not seen
 * in the archive when we append. We also try to handle inode truncation with
 * this table. (When the inode field in the archive header are too small, we
 * remap the dev on writes to remove accidental collisions).
 *
 * The list is hashed by device number using chain collision resolution. Off of
 * each DEVT are linked the various remaps for this device based on those bits
 * in the inode which were truncated. For example if we are just remapping to
 * avoid a device number during an update append, off the DEVT we would have
 * only a single DLIST that has a truncation id of 0 (no inode bits were
 * stripped for this device so far). When we spot inode truncation we create
 * a new mapping based on the set of bits in the inode which were stripped off.
 * so if the top four bits of the inode are stripped and they have a pattern of
 * 0110...... (where . are those bits not truncated) we would have a mapping
 * assigned for all inodes that has the same 0110.... pattern (with this dev
 * number of course). This keeps the mapping sparse and should be able to store
 * close to the limit of files which can be represented by the optimal
 * combination of dev and inode bits, and without creating a fouled up archive.
 * Note we also remap truncated devs in the same way (an exercise for the
 * dedicated reader; always wanted to say that...:)
 */

typedef struct devt {
	dev_t		dev;	/* the orig device number we now have to map */
	struct devt	*fow;	/* new device map list */
	struct dlist	*list;	/* map list based on inode truncation bits */
} DEVT;

typedef struct dlist {
	ino_t trunc_bits;	/* truncation pattern for a specific map */
	dev_t dev;		/* the new device id we use */
	struct dlist *fow;
} DLIST;

/*
 * ftree directory access time reset table. When we are done with a
 * subtree we reset the access and mod time of the directory when the tflag is
 * set. Not really explicitly specified in the pax spec, but easy and fast to
 * do (and this may have even been intended in the spec, it is not clear).
 * table is hashed by inode with chaining.
 */

typedef struct atdir {
	struct file_times ft;
	struct atdir *fow;
} ATDIR;

/*
 * created directory time and mode storage entry. After pax is finished during
 * extraction or copy, we must reset directory access modes and times that
 * may have been modified after creation (they no longer have the specified
 * times and/or modes). We must reset time in the reverse order of creation,
 * because entries are added  from the top of the file tree to the bottom.
 * We MUST reset times from leaf to root (it will not work the other
 * direction).
 */

typedef struct dirdata {
	struct file_times ft;
	uint16_t mode;		/* file mode to restore */
	uint16_t frc_mode;	/* do we force mode settings? */
} DIRDATA;

/*
 * file hard link structure (hashed by dev/ino and chained) for anonymisation
 */
typedef struct hrdflnk {
	dev_t		dev;	/* files device number */
	ino_t		ino;	/* files inode number */
	u_long		nlink;	/* expected link count */
	ino_t		newi;	/* new inode number */
	struct hrdflnk	*fow;
} HRDFLNK;

static HRDLNK **ltab = NULL;	/* hard link table for detecting hard links */
static HRDFLNK **fltab = NULL;	/* hard link table for anonymisation */
static FTM **ftab = NULL;	/* file time table for updating arch */
static NAMT **ntab = NULL;	/* interactive rename storage table */
static DEVT **dtab = NULL;	/* device/inode mapping tables */
static ATDIR **atab = NULL;	/* file tree directory time reset table */
static DIRDATA *dirp = NULL;	/* storage for setting created dir time/mode */
static size_t dirsize;		/* size of dirp table */
static size_t dircnt = 0;	/* entries in dir time/mode storage */
static int ffd = -1;		/* tmp file for file time table name storage */

static DEVT *chk_dev(dev_t, int);

#ifndef REALPATH_CAN_ALLOCATE
static char realname[PATH_MAX];
#endif

static char *
xrealpath(const char *path)
{
#ifndef REALPATH_CAN_ALLOCATE
	char *rv;

	if ((rv = realpath(path, realname)))
		rv = strdup(rv);
	return (rv);
#else
	return (realpath(path, NULL));
#endif
}

/*
 * hard link table routines
 *
 * The hard link table tries to detect hard links to files using the device and
 * inode values. We do this when writing an archive, so we can tell the format
 * write routine that this file is a hard link to another file. The format
 * write routine then can store this file in whatever way it wants (as a hard
 * link if the format supports that like tar, or ignore this info like cpio).
 * (Actually a field in the format driver table tells us if the format wants
 * hard link info. if not, we do not waste time looking for them). We also use
 * the same table when reading an archive. In that situation, this table is
 * used by the format read routine to detect hard links from stored dev and
 * inode numbers (like cpio). This will allow pax to create a link when one
 * can be detected by the archive format.
 */

/*
 * lnk_start
 *	Creates the hard link table.
 * Return:
 *	0 if created, -1 if failure
 */

int
lnk_start(void)
{
	if (ltab != NULL)
		return (0);
	if ((ltab = calloc(L_TAB_SZ, sizeof(HRDLNK *))) == NULL) {
		paxwarn(1, "%s for %s", "Out of memory",
		    "hard link table");
		return (-1);
	}
	return (0);
}

/*
 * chk_lnk()
 *	Looks up entry in hard link hash table. If found, it copies the name
 *	of the file it is linked to (we already saw that file) into ln_name.
 *	lnkcnt is decremented and if goes to 1 the node is deleted from the
 *	database. (We have seen all the links to this file). If not found,
 *	we add the file to the database if it has the potential for having
 *	hard links to other files we may process (it has a link count > 1)
 * Return:
 *	if found returns 1; if not found returns 0; -1 on error
 */

int
chk_lnk(ARCHD *arcn)
{
	HRDLNK *pt;
	HRDLNK **ppt;
	unsigned int indx;

	if (ltab == NULL)
		return(-1);
	/*
	 * ignore those nodes that cannot have hard links
	 */
	if ((arcn->type == PAX_DIR) || (arcn->sb.st_nlink <= 1))
		return(0);

	/*
	 * hash inode number and look for this file
	 */
	indx = ((unsigned)arcn->sb.st_ino) % L_TAB_SZ;
	if ((pt = ltab[indx]) != NULL) {
		/*
		 * its hash chain in not empty, walk down looking for it
		 */
		ppt = &(ltab[indx]);
		while (pt != NULL) {
			if ((pt->ino == arcn->sb.st_ino) &&
			    (pt->dev == arcn->sb.st_dev))
				break;
			ppt = &(pt->fow);
			pt = pt->fow;
		}

		if (pt != NULL) {
			/*
			 * found a link. set the node type and copy in the
			 * name of the file it is to link to. we need to
			 * handle hardlinks to regular files differently than
			 * other links.
			 */
			arcn->ln_nlen = strlcpy(arcn->ln_name, pt->name,
				sizeof(arcn->ln_name));
			/* XXX truncate? */
			if ((size_t)arcn->nlen >= sizeof(arcn->name))
				arcn->nlen = sizeof(arcn->name) - 1;
			if (arcn->type == PAX_REG)
				arcn->type = PAX_HRG;
			else
				arcn->type = PAX_HLK;

			/*
			 * if we have found all the links to this file, remove
			 * it from the database
			 */
			if (--pt->nlink <= 1) {
				*ppt = pt->fow;
				free(pt->name);
				free(pt);
			}
			return(1);
		}
	}

	/*
	 * we never saw this file before. It has links so we add it to the
	 * front of this hash chain
	 */
	if ((pt = malloc(sizeof(HRDLNK))) != NULL) {
		if ((pt->name = strdup(arcn->name)) != NULL) {
			pt->dev = arcn->sb.st_dev;
			pt->ino = arcn->sb.st_ino;
			pt->nlink = arcn->sb.st_nlink;
			pt->fow = ltab[indx];
			ltab[indx] = pt;
			return(0);
		}
		free(pt);
	}

	paxwarn(1, "%s for %s", "Out of memory", "hard link table");
	return (-1);
}

/*
 * purg_lnk
 *	remove reference for a file that we may have added to the data base as
 *	a potential source for hard links. We ended up not using the file, so
 *	we do not want to accidently point another file at it later on.
 */

void
purg_lnk(ARCHD *arcn)
{
	HRDLNK *pt;
	HRDLNK **ppt;
	unsigned int indx;

	if (ltab == NULL)
		return;
	/*
	 * do not bother to look if it could not be in the database
	 */
	if ((arcn->sb.st_nlink <= 1) || (arcn->type == PAX_DIR) ||
	    PAX_IS_HARDLINK(arcn->type))
		return;

	/*
	 * find the hash chain for this inode value, if empty return
	 */
	indx = ((unsigned)arcn->sb.st_ino) % L_TAB_SZ;
	if ((pt = ltab[indx]) == NULL)
		return;

	/*
	 * walk down the list looking for the inode/dev pair, unlink and
	 * free if found
	 */
	ppt = &(ltab[indx]);
	while (pt != NULL) {
		if ((pt->ino == arcn->sb.st_ino) &&
		    (pt->dev == arcn->sb.st_dev))
			break;
		ppt = &(pt->fow);
		pt = pt->fow;
	}
	if (pt == NULL)
		return;

	/*
	 * remove and free it
	 */
	*ppt = pt->fow;
	free(pt->name);
	free(pt);
}

/*
 * lnk_end()
 *	pull apart a existing link table so we can reuse it. We do this between
 *	read and write phases of append with update. (The format may have
 *	used the link table, and we need to start with a fresh table for the
 *	write phase
 */

void
lnk_end(void)
{
	int i;
	HRDLNK *pt;
	HRDLNK *ppt;

	if (ltab == NULL)
		return;

	for (i = 0; i < L_TAB_SZ; ++i) {
		if (ltab[i] == NULL)
			continue;
		pt = ltab[i];
		ltab[i] = NULL;

		/*
		 * free up each entry on this chain
		 */
		while (pt != NULL) {
			ppt = pt;
			pt = ppt->fow;
			free(ppt->name);
			free(ppt);
		}
	}
}

/*
 * modification time table routines
 *
 * The modification time table keeps track of last modification times for all
 * files stored in an archive during a write phase when -u is set. We only
 * add a file to the archive if it is newer than a file with the same name
 * already stored on the archive (if there is no other file with the same
 * name on the archive it is added). This applies to writes and appends.
 * An append with an -u must read the archive and store the modification time
 * for every file on that archive before starting the write phase. It is clear
 * that this is one HUGE database. To save memory space, the actual file names
 * are stored in a scratch file and indexed by an in-memory hash table. The
 * hash table is indexed by hashing the file path. The nodes in the table store
 * the length of the filename and the lseek offset within the scratch file
 * where the actual name is stored. Since there are never any deletions from
 * this table, fragmentation of the scratch file is never a issue. Lookups
 * seem to not exhibit any locality at all (files in the database are rarely
 * looked up more than once...), so caching is just a waste of memory. The
 * only limitation is the amount of scratch file space available to store the
 * path names.
 */

/*
 * ftime_start()
 *	create the file time hash table and open for read/write the scratch
 *	file. (after created it is unlinked, so when we exit we leave
 *	no witnesses).
 * Return:
 *	0 if the table and file was created ok, -1 otherwise
 */

int
ftime_start(void)
{

	if (ftab != NULL)
		return (0);
	if ((ftab = calloc(F_TAB_SZ, sizeof(FTM *))) == NULL) {
		paxwarn(1, "%s for %s", "Out of memory",
		    "file time table");
		return (-1);
	}

	/*
	 * get random name and create temporary scratch file, unlink name
	 * so it will get removed on exit
	 */
	memcpy(tempbase, _TFILE_BASE, sizeof(_TFILE_BASE));
	if ((ffd = mkstemp(tempfile)) < 0) {
		syswarn(1, errno, "Unable to create temporary file %s",
		    tempfile);
		return (-1);
	}
	(void)unlink(tempfile);

	return(0);
}

/*
 * chk_ftime()
 *	looks up entry in file time hash table. If not found, the file is
 *	added to the hash table and the file named stored in the scratch file.
 *	If a file with the same name is found, the file times are compared and
 *	the most recent file time is retained. If the new file was younger (or
 *	was not in the database) the new file is selected for storage.
 * Return:
 *	0 if file should be added to the archive, 1 if it should be skipped,
 *	-1 on error
 */

int
chk_ftime(ARCHD *arcn)
{
	FTM *pt;
	int namelen;
	unsigned int indx;
	char ckname[PAXPATHLEN+1];

	/*
	 * no info, go ahead and add to archive
	 */
	if (ftab == NULL)
		return(0);

	/*
	 * hash the pathname and look up in table
	 */
	namelen = arcn->nlen;
	indx = st_hash(arcn->name, namelen, F_TAB_SZ);
	if ((pt = ftab[indx]) != NULL) {
		/*
		 * the hash chain is not empty, walk down looking for match
		 * only read up the path names if the lengths match, speeds
		 * up the search a lot
		 */
		while (pt != NULL) {
			if (pt->namelen == namelen) {
				/*
				 * potential match, have to read the name
				 * from the scratch file.
				 */
				if (lseek(ffd,pt->seek,SEEK_SET) != pt->seek) {
					syswarn(1, errno, "Failed %s on %s",
					    "seek", "file time table");
					return (-1);
				}
				if (read(ffd, ckname, namelen) != namelen) {
					syswarn(1, errno, "Failed %s on %s",
					    "read", "file time table");
					return (-1);
				}

				/*
				 * if the names match, we are done
				 */
				if (!strncmp(ckname, arcn->name, namelen))
					break;
			}

			/*
			 * try the next entry on the chain
			 */
			pt = pt->fow;
		}

		if (pt != NULL) {
			/*
			 * found the file, compare the times, save the newer
			 */
			if (st_timecmp(m, &arcn->sb, &pt->sb, >)) {
				/*
				 * file is newer
				 */
				st_timecpy(m, &pt->sb, &arcn->sb);
				return(0);
			}
			/*
			 * file is older
			 */
			return(1);
		}
	}

	/*
	 * not in table, add it
	 */
	if ((pt = malloc(sizeof(FTM))) != NULL) {
		/*
		 * add the name at the end of the scratch file, saving the
		 * offset. add the file to the head of the hash chain
		 */
		if ((pt->seek = lseek(ffd, 0, SEEK_END)) >= 0) {
			if (write(ffd, arcn->name, namelen) == namelen) {
				st_timecpy(m, &pt->sb, &arcn->sb);
				pt->namelen = namelen;
				pt->fow = ftab[indx];
				ftab[indx] = pt;
				return(0);
			}
			syswarn(1, errno, "Failed %s on %s",
			    "write", "file time table");
		} else
			syswarn(1, errno, "Failed %s on %s",
			    "seek", "file time table");
	} else
		paxwarn(1, "%s for %s", "Out of memory", "file time table");

	if (pt != NULL)
		free(pt);
	return(-1);
}

/*
 * escaping (absolute or w/"..") symlink table routines
 *
 * By default, an archive shouldn't be able extract to outside of the
 * current directory.  What should we do if the archive contains a symlink
 * whose value is either absolute or contains ".." components?  What we'll
 * do is initially create the path as an empty file (to block attempts to
 * reference _through_ it) and instead record its path and desired
 * final value and mode.  Then once all the other archive
 * members are created (but before the pass to set timestamps on
 * directories) we'll process those records, replacing the placeholder with
 * the correct symlink and setting them to the correct mode, owner, group,
 * and timestamps.
 *
 * Note: we also need to handle hardlinks to symlinks (barf) as well as
 * hardlinks whose target is replaced by a later entry in the archive (barf^2).
 *
 * So we track things by dev+ino of the placeholder file, associating with
 * that the value and mode of the final symlink and a list of paths that
 * should all be hardlinks of that.  We'll 'store' the symlink's desired
 * timestamps, owner, and group by setting them on the placeholder file.
 *
 * The operations are:
 * a) create an escaping symlink: create the placeholder file and add an entry
 *    for the new link
 * b) create a hardlink: do the link.  If the target turns out to be a
 *    zero-length file whose dev+ino are in the symlink table, then add this
 *    path to the list of names for that link
 * c) perform deferred processing: for each entry, check each associated path:
 *    if it's a zero-length file with the correct dev+ino then recreate it as
 *    the specified symlink or hardlink to the first such
 */

struct slpath {
	char	*sp_path;
	struct	slpath *sp_next;
};
struct slinode {
	ino_t	sli_ino;
	char	*sli_value;
	struct	slpath sli_paths;
	struct	slinode *sli_fow;		/* hash table chain */
	dev_t	sli_dev;
	mode_t	sli_mode;
};

static struct slinode **slitab = NULL;

/*
 * sltab_start()
 *	create the hash table
 * Return:
 *	0 if the table and file was created ok, -1 otherwise
 */

int
sltab_start(void)
{

	if ((slitab = calloc(SL_TAB_SZ, sizeof *slitab)) == NULL) {
		syswarn(1, errno, "symlink table");
		return(-1);
	}

	return(0);
}

/*
 * sltab_add_sym()
 *	Create the placeholder and tracking info for an escaping symlink.
 * Return:
 *	0 on success, -1 otherwise
 */

int
sltab_add_sym(const char *path0, const char *value0, mode_t mode)
{
	struct stat sb;
	struct slinode *s;
	struct slpath *p;
	char *path, *value;
	unsigned int indx;
	int fd;

	/* create the placeholder */
	fd = binopen3(BO_CLEXEC, path0, O_WRONLY | O_CREAT | O_EXCL, 0600);
	if (fd == -1)
		return (-1);
	if (fstat(fd, &sb) == -1) {
		unlink(path0);
		close(fd);
		return (-1);
	}
	close(fd);

	if (havechd && *path0 != '/') {
		if ((path = xrealpath(path0)) == NULL) {
			syswarn(1, errno, "Cannot canonicalise %s", path0);
			unlink(path0);
			return (-1);
		}
	} else if ((path = strdup(path0)) == NULL) {
		syswarn(1, errno, "%s %s", "deferred symlink", "path");
		unlink(path0);
		return (-1);
	}
	if ((value = strdup(value0)) == NULL) {
		syswarn(1, errno, "%s value", "deferred symlink");
		unlink(path);
		free(path);
		return (-1);
	}

	/* now check the hash table for conflicting entry */
	indx = (sb.st_ino ^ sb.st_dev) % SL_TAB_SZ;
	for (s = slitab[indx]; s != NULL; s = s->sli_fow) {
		if (s->sli_ino != sb.st_ino || s->sli_dev != sb.st_dev)
			continue;

		/*
		 * One of our placeholders got removed behind our back and
		 * we've reused the inode.  Weird, but clean up the mess.
		 */
		free(s->sli_value);
		free(s->sli_paths.sp_path);
		p = s->sli_paths.sp_next;
		while (p != NULL) {
			struct slpath *next_p = p->sp_next;

			free(p->sp_path);
			free(p);
			p = next_p;
		}
		goto set_value;
	}

	/* Normal case: create a new node */
	if ((s = malloc(sizeof *s)) == NULL) {
		syswarn(1, errno, "deferred symlink");
		unlink(path);
		free(path);
		free(value);
		return (-1);
	}
	s->sli_ino = sb.st_ino;
	s->sli_dev = sb.st_dev;
	s->sli_fow = slitab[indx];
	slitab[indx] = s;

 set_value:
	s->sli_paths.sp_path = path;
	s->sli_paths.sp_next = NULL;
	s->sli_value = value;
	s->sli_mode = mode;
	return (0);
}

/*
 * sltab_add_link()
 *	A hardlink was created; if it looks like a placeholder, handle the
 *	tracking.
 * Return:
 *	0 if things are ok, -1 if something went wrong
 */

int
sltab_add_link(const char *path, const struct stat *sb)
{
	struct slinode *s;
	struct slpath *p;
	unsigned int indx;

	if (!S_ISREG(sb->st_mode) || sb->st_size != 0)
		return (1);

	/* find the hash table entry for this hardlink */
	indx = (sb->st_ino ^ sb->st_dev) % SL_TAB_SZ;
	for (s = slitab[indx]; s != NULL; s = s->sli_fow) {
		if (s->sli_ino != sb->st_ino || s->sli_dev != sb->st_dev)
			continue;

		if ((p = malloc(sizeof *p)) == NULL) {
			syswarn(1, errno, "%s hardlink", "deferred symlink");
			return (-1);
		}
		if (havechd && *path != '/') {
			if ((p->sp_path = xrealpath(path)) == NULL) {
				syswarn(1, errno, "Cannot canonicalise %s",
				    path);
				free(p);
				return (-1);
			}
		} else if ((p->sp_path = strdup(path)) == NULL) {
			syswarn(1, errno, "%s hardlink path", "deferred symlink");
			free(p);
			return (-1);
		}

		/* link it in */
		p->sp_next = s->sli_paths.sp_next;
		s->sli_paths.sp_next = p;
		return (0);
	}

	/* not found */
	return (1);
}

static int
sltab_process_one(struct slinode *s, struct slpath *p, const char *first,
    int in_sig)
{
	struct stat sb;
	char *path = p->sp_path;
	mode_t mode;
	int err;

	/*
	 * is it the expected placeholder?  This can fail legimately
	 * if the archive overwrote the link with another, later entry,
	 * so don't warn.
	 */
	if (stat(path, &sb) != 0 || !S_ISREG(sb.st_mode) || sb.st_size != 0 ||
	    sb.st_ino != s->sli_ino || sb.st_dev != s->sli_dev)
		return (0);

	if (unlink(path) && errno != ENOENT) {
		if (!in_sig)
			syswarn(1, errno, "%s removal", "deferred symlink");
		return (0);
	}

	err = 0;
	if (first != NULL) {
#if HAVE_LINKAT
		/* add another hardlink to the existing symlink */
		if (linkat(AT_FDCWD, first, AT_FDCWD, path, 0) == 0)
			return (0);

		/*
		 * Couldn't hardlink the symlink for some reason, so we'll
		 * try creating it as its own symlink, but save the error
		 * for reporting if that fails.
		 */
		err = errno;
#else
		err = EOPNOTSUPP;
#endif
	}

	if (symlink(s->sli_value, path)) {
		if (!in_sig) {
			const char *qualifier = "";
			if (err)
				qualifier = " hardlink";
			else
				err = errno;

			syswarn(1, err, "%s%s: %s",
			    "deferred symlink", qualifier, path);
		}
		return (0);
	}

	/* success, so set the id, mode, and times */
	mode = s->sli_mode;
	if (pids) {
		/* if can't set the ids, force the set[ug]id bits off */
		if (set_ids(path, sb.st_uid, sb.st_gid, 1))
			mode &= ~(SETBITS);
	}

	if (pmode)
		set_pmode(path, mode, 1);

	if (patime || pmtime)
		set_ftime(path, &sb, 0, 1);

	/*
	 * If we tried to link to first but failed, then this new symlink
	 * might be a better one to try in the future.  Guess from the errno.
	 */
	if (err == 0 || err == ENOENT || err == EMLINK || err == EOPNOTSUPP)
		return (1);
	return (0);
}

/*
 * sltab_process()
 *	Do all the delayed process for escape symlinks
 */

void
sltab_process(int in_sig)
{
	struct slinode *s;
	struct slpath *p;
	char *first;
	unsigned int indx;

	if (slitab == NULL)
		return;

	/* walk across the entire hash table */
	for (indx = 0; indx < SL_TAB_SZ; indx++) {
		while ((s = slitab[indx]) != NULL) {
			/* pop this entry */
			slitab[indx] = s->sli_fow;

			first = NULL;
			p = &s->sli_paths;
			while (1) {
				struct slpath *next_p;

				if (sltab_process_one(s, p, first, in_sig)) {
					if (!in_sig)
						free(first);
					first = p->sp_path;
				} else if (!in_sig)
					free(p->sp_path);

				if ((next_p = p->sp_next) == NULL)
					break;
				*p = *next_p;
				if (!in_sig)
					free(next_p);
			}
			if (!in_sig) {
				free(first);
				free(s->sli_value);
				free(s);
			}
		}
	}
	if (!in_sig)
		free(slitab);
	slitab = NULL;
}

/*
 * Interactive rename table routines
 *
 * The interactive rename table keeps track of the new names that the user
 * assigns to files from tty input. Since this map is unique for each file
 * we must store it in case there is a reference to the file later in archive
 * (a link). Otherwise we will be unable to find the file we know was
 * extracted. The remapping of these files is stored in a memory based hash
 * table (it is assumed since input must come from /dev/tty, it is unlikely to
 * be a very large table).
 */

/*
 * name_start()
 *	create the interactive rename table
 * Return:
 *	0 if successful, -1 otherwise
 */

int
name_start(void)
{
	if (ntab != NULL)
		return (0);
	if ((ntab = calloc(N_TAB_SZ, sizeof(NAMT *))) == NULL) {
		paxwarn(1, "%s for %s", "Out of memory",
		    "interactive rename table");
		return (-1);
	}
	return (0);
}

/*
 * add_name()
 *	add the new name to old name mapping just created by the user.
 *	If an old name mapping is found (there may be duplicate names on an
 *	archive) only the most recent is kept.
 * Return:
 *	0 if added, -1 otherwise
 */

int
add_name(char *oname, int onamelen, char *nname)
{
	NAMT *pt;
	unsigned int indx;

	if (ntab == NULL) {
		/*
		 * should never happen
		 */
		paxwarn(0, "No interactive rename table, links may fail");
		return(0);
	}

	/*
	 * look to see if we have already mapped this file, if so we
	 * will update it
	 */
	indx = st_hash(oname, onamelen, N_TAB_SZ);
	if ((pt = ntab[indx]) != NULL) {
		/*
		 * look down the has chain for the file
		 */
		while ((pt != NULL) && (strcmp(oname, pt->oname) != 0))
			pt = pt->fow;

		if (pt != NULL) {
			/*
			 * found an old mapping, replace it with the new one
			 * the user just input (if it is different)
			 */
			if (strcmp(nname, pt->nname) == 0)
				return(0);

			free(pt->nname);
			if ((pt->nname = strdup(nname)) == NULL) {
				paxwarn(1, "Cannot update rename table");
				return(-1);
			}
			return(0);
		}
	}

	/*
	 * this is a new mapping, add it to the table
	 */
	if ((pt = malloc(sizeof(NAMT))) != NULL) {
		if ((pt->oname = strdup(oname)) != NULL) {
			if ((pt->nname = strdup(nname)) != NULL) {
				pt->fow = ntab[indx];
				ntab[indx] = pt;
				return(0);
			}
			free(pt->oname);
		}
		free(pt);
	}
	paxwarn(1, "%s for %s", "Out of memory", "interactive rename table");
	return (-1);
}

/*
 * sub_name()
 *	look up a link name to see if it points at a file that has been
 *	remapped by the user. If found, the link is adjusted to contain the
 *	new name (oname is the link to name)
 */

void
sub_name(char *oname, int *onamelen, int onamesize)
{
	NAMT *pt;
	unsigned int indx;

	if (ntab == NULL)
		return;
	/*
	 * look the name up in the hash table
	 */
	indx = st_hash(oname, *onamelen, N_TAB_SZ);
	if ((pt = ntab[indx]) == NULL)
		return;

	while (pt != NULL) {
		/*
		 * walk down the hash chain looking for a match
		 */
		if (strcmp(oname, pt->oname) == 0) {
			/*
			 * found it, replace it with the new name
			 * and return (we know that oname has enough space)
			 */
			*onamelen = strlcpy(oname, pt->nname, onamesize);
			if (*onamelen >= onamesize)
				*onamelen = onamesize - 1; /* XXX truncate? */
			return;
		}
		pt = pt->fow;
	}

	/*
	 * no match, just return
	 */
}

/*
 * device/inode mapping table routines
 * (used with formats that store device and inodes fields)
 *
 * device/inode mapping tables remap the device field in a archive header. The
 * device/inode fields are used to determine when files are hard links to each
 * other. However these values have very little meaning outside of that. This
 * database is used to solve one of two different problems.
 *
 * 1) when files are appended to an archive, while the new files may have hard
 * links to each other, you cannot determine if they have hard links to any
 * file already stored on the archive from a prior run of pax. We must assume
 * that these inode/device pairs are unique only within a SINGLE run of pax
 * (which adds a set of files to an archive). So we have to make sure the
 * inode/dev pairs we add each time are always unique. We do this by observing
 * while the inode field is very dense, the use of the dev field is fairly
 * sparse. Within each run of pax, we remap any device number of a new archive
 * member that has a device number used in a prior run and already stored in a
 * file on the archive. During the read phase of the append, we store the
 * device numbers used and mark them to not be used by any file during the
 * write phase. If during write we go to use one of those old device numbers,
 * we remap it to a new value.
 *
 * 2) Often the fields in the archive header used to store these values are
 * too small to store the entire value. The result is an inode or device value
 * which can be truncated. This really can foul up an archive. With truncation
 * we end up creating links between files that are really not links (after
 * truncation the inodes are the same value). We address that by detecting
 * truncation and forcing a remap of the device field to split truncated
 * inodes away from each other. Each truncation creates a pattern of bits that
 * are removed. We use this pattern of truncated bits to partition the inodes
 * on a single device to many different devices (each one represented by the
 * truncated bit pattern). All inodes on the same device that have the same
 * truncation pattern are mapped to the same new device. Two inodes that
 * truncate to the same value clearly will always have different truncation
 * bit patterns, so they will be split from away each other. When we spot
 * device truncation we remap the device number to a non truncated value.
 * (for more info see table.h for the data structures involved).
 */

/*
 * dev_start()
 *	create the device mapping table
 * Return:
 *	0 if successful, -1 otherwise
 */

int
dev_start(void)
{
	if (dtab != NULL)
		return (0);
	if ((dtab = calloc(D_TAB_SZ, sizeof(DEVT *))) == NULL) {
		paxwarn(1, "%s for %s", "Out of memory",
		    "device mapping table");
		return (-1);
	}
	return (0);
}

/*
 * add_dev()
 *	add a device number to the table. this will force the device to be
 *	remapped to a new value if it be used during a write phase. This
 *	function is called during the read phase of an append to prohibit the
 *	use of any device number already in the archive.
 * Return:
 *	0 if added ok, -1 otherwise
 */

int
add_dev(ARCHD *arcn)
{
	if (chk_dev(arcn->sb.st_dev, 1) == NULL)
		return(-1);
	return(0);
}

/*
 * chk_dev()
 *	check for a device value in the device table. If not found and the add
 *	flag is set, it is added. This does NOT assign any mapping values, just
 *	adds the device number as one that need to be remapped. If this device
 *	is already mapped, just return with a pointer to that entry.
 * Return:
 *	pointer to the entry for this device in the device map table. Null
 *	if the add flag is not set and the device is not in the table (it is
 *	not been seen yet). If add is set and the device cannot be added, null
 *	is returned (indicates an error).
 */

static DEVT *
chk_dev(dev_t dev, int add)
{
	DEVT *pt;
	unsigned int indx;

	if (dtab == NULL)
		return(NULL);
	/*
	 * look to see if this device is already in the table
	 */
	indx = ((unsigned)dev) % D_TAB_SZ;
	if ((pt = dtab[indx]) != NULL) {
		while ((pt != NULL) && (pt->dev != dev))
			pt = pt->fow;

		/*
		 * found it, return a pointer to it
		 */
		if (pt != NULL)
			return(pt);
	}

	/*
	 * not in table, we add it only if told to as this may just be a check
	 * to see if a device number is being used.
	 */
	if (add == 0)
		return(NULL);

	/*
	 * allocate a node for this device and add it to the front of the hash
	 * chain. Note we do not assign remaps values here, so the pt->list
	 * list must be NULL.
	 */
	if ((pt = malloc(sizeof(DEVT))) == NULL) {
		paxwarn(1, "%s for %s", "Out of memory", "device mapping table");
		return (NULL);
	}
	pt->dev = dev;
	pt->list = NULL;
	pt->fow = dtab[indx];
	dtab[indx] = pt;
	return(pt);
}
/*
 * map_dev()
 *	given an inode and device storage mask (the mask has a 1 for each bit
 *	the archive format is able to store in a header), we check for inode
 *	and device truncation and remap the device as required. Device mapping
 *	can also occur when during the read phase of append a device number was
 *	seen (and was marked as do not use during the write phase). WE ASSUME
 *	that unsigned longs are the same size or bigger than the fields used
 *	for ino_t and dev_t. If not the types will have to be changed.
 * Return:
 *	0 if all ok, -1 otherwise.
 */

int
map_dev(ARCHD *arcn, u_long dev_mask, u_long ino_mask)
{
	DEVT *pt;
	DLIST *dpt;
	static dev_t lastdev = 0;	/* next device number to try */
	int trc_ino = 0;
	int trc_dev = 0;
	ino_t trunc_bits = 0;
	ino_t nino;

	if (dtab == NULL)
		return(0);
	/*
	 * check for device and inode truncation, and extract the truncated
	 * bit pattern.
	 */
	if ((arcn->sb.st_dev & (dev_t)dev_mask) != arcn->sb.st_dev)
		++trc_dev;
	if ((nino = arcn->sb.st_ino & (ino_t)ino_mask) != arcn->sb.st_ino) {
		++trc_ino;
		trunc_bits = arcn->sb.st_ino & (ino_t)(~ino_mask);
	}

	/*
	 * see if this device is already being mapped, look up the device
	 * then find the truncation bit pattern which applies
	 */
	if ((pt = chk_dev(arcn->sb.st_dev, 0)) != NULL) {
		/*
		 * this device is already marked to be remapped
		 */
		for (dpt = pt->list; dpt != NULL; dpt = dpt->fow)
			if (dpt->trunc_bits == trunc_bits)
				break;

		if (dpt != NULL) {
			/*
			 * we are being remapped for this device and pattern
			 * change the device number to be stored and return
			 */
			arcn->sb.st_dev = dpt->dev;
			arcn->sb.st_ino = nino;
			return(0);
		}
	} else {
		/*
		 * this device is not being remapped YET. if we do not have any
		 * form of truncation, we do not need a remap
		 */
		if (!trc_ino && !trc_dev)
			return(0);

		/*
		 * we have truncation, have to add this as a device to remap
		 */
		if ((pt = chk_dev(arcn->sb.st_dev, 1)) == NULL)
			goto bad;

		/*
		 * if we just have a truncated inode, we have to make sure that
		 * all future inodes that do not truncate (they have the
		 * truncation pattern of all 0's) continue to map to the same
		 * device number. We probably have already written inodes with
		 * this device number to the archive with the truncation
		 * pattern of all 0's. So we add the mapping for all 0's to the
		 * same device number.
		 */
		if (!trc_dev && (trunc_bits != 0)) {
			if ((dpt = malloc(sizeof(DLIST))) == NULL)
				goto bad;
			dpt->trunc_bits = 0;
			dpt->dev = arcn->sb.st_dev;
			dpt->fow = pt->list;
			pt->list = dpt;
		}
	}

	/*
	 * look for a device number not being used. We must watch for wrap
	 * around on lastdev (so we do not get stuck looking forever!)
	 */
	while (++lastdev > 0) {
		if (chk_dev(lastdev, 0) != NULL)
			continue;
		/*
		 * found an unused value. If we have reached truncation point
		 * for this format we are hosed, so we give up. Otherwise we
		 * mark it as being used.
		 */
		if (((lastdev & ((dev_t)dev_mask)) != lastdev) ||
		    (chk_dev(lastdev, 1) == NULL))
			goto bad;
		break;
	}

	if ((lastdev <= 0) || ((dpt = malloc(sizeof(DLIST))) == NULL))
		goto bad;

	/*
	 * got a new device number, store it under this truncation pattern.
	 * change the device number this file is being stored with.
	 */
	dpt->trunc_bits = trunc_bits;
	dpt->dev = lastdev;
	dpt->fow = pt->list;
	pt->list = dpt;
	arcn->sb.st_dev = lastdev;
	arcn->sb.st_ino = nino;
	return(0);

 bad:
	paxwarn(1, "Unable to fix truncated inode/device field when storing %s",
	    arcn->name);
	paxwarn(0, "Archive may create improper hard links when extracted");
	return(0);
}

/*
 * directory access/mod time reset table routines (for directories READ by pax)
 *
 * The pax -t flag requires that access times of archive files be the same
 * before being read by pax. For regular files, access time is restored after
 * the file has been copied. This database provides the same functionality for
 * directories read during file tree traversal. Restoring directory access time
 * is more complex than files since directories may be read several times until
 * all the descendants in their subtree are visited by fts. Directory access
 * and modification times are stored during the fts pre-order visit (done
 * before any descendants in the subtree are visited) and restored after the
 * fts post-order visit (after all the descendants have been visited). In the
 * case of premature exit from a subtree (like from the effects of -n), any
 * directory entries left in this database are reset during final cleanup
 * operations of pax. Entries are hashed by inode number for fast lookup.
 */

/*
 * atdir_start()
 *	create the directory access time database for directories READ by pax.
 * Return:
 *	0 is created ok, -1 otherwise.
 */

int
atdir_start(void)
{
	if (atab != NULL)
		return (0);
	if ((atab = calloc(A_TAB_SZ, sizeof(ATDIR *))) == NULL) {
		paxwarn(1, "%s for %s", "Out of memory",
		    "directory access time reset table");
		return (-1);
	}
	return (0);
}

/*
 * atdir_end()
 *	walk through the directory access time table and reset the access time
 *	of any directory who still has an entry left in the database. These
 *	entries are for directories READ by pax
 */

void
atdir_end(void)
{
	ATDIR *pt;
	int i;

	if (atab == NULL)
		return;
	/*
	 * for each non-empty hash table entry reset all the directories
	 * chained there.
	 */
	for (i = 0; i < A_TAB_SZ; ++i) {
		if ((pt = atab[i]) == NULL)
			continue;
		/*
		 * remember to force the times, set_ftime() looks at pmtime
		 * and patime, which only applies to things CREATED by pax,
		 * not read by pax. Read time reset is controlled by -t.
		 */
		for (; pt != NULL; pt = pt->fow)
			set_attr(&pt->ft, 1, 0, 0, 0);
	}
}

/*
 * add_atdir()
 *	add a directory to the directory access time table. Table is hashed
 *	and chained by inode number. This is for directories READ by pax
 */

void
add_atdir(const char *fname, const struct stat *sbp)
{
	ATDIR *pt;
	sigset_t allsigs, savedsigs;
	unsigned int indx;

	if (atab == NULL)
		return;

	/*
	 * make sure this directory is not already in the table, if so just
	 * return (the older entry always has the correct time). The only
	 * way this will happen is when the same subtree can be traversed by
	 * different args to pax and the -n option is aborting fts out of a
	 * subtree before all the post-order visits have been made.
	 */
	indx = ((unsigned)sbp->st_ino) % A_TAB_SZ;
	if ((pt = atab[indx]) != NULL) {
		while (pt != NULL) {
			if ((pt->ft.ft_ino == sbp->st_ino) && (pt->ft.ft_dev == sbp->st_dev))
				break;
			pt = pt->fow;
		}

		/*
		 * oops, already there. Leave it alone.
		 */
		if (pt != NULL)
			return;
	}

	/*
	 * add it to the front of the hash chain
	 */
	sigfillset(&allsigs);
	sigprocmask(SIG_BLOCK, &allsigs, &savedsigs);
	if ((pt = malloc(sizeof *pt)) != NULL) {
		if ((pt->ft.ft_name = strdup(fname)) != NULL) {
			pt->ft.ft_dev = sbp->st_dev;
			pt->ft.ft_ino = sbp->st_ino;
			st_timecpy(m, &pt->ft.sb, sbp);
			st_timecpy(a, &pt->ft.sb, sbp);
			pt->fow = atab[indx];
			atab[indx] = pt;
			sigprocmask(SIG_SETMASK, &savedsigs, NULL);
			return;
		}
		free(pt);
	}

	sigprocmask(SIG_SETMASK, &savedsigs, NULL);
	paxwarn(1, "%s for %s", "Out of memory", "directory access time reset table");
}

/*
 * get_atdir()
 *	look up a directory by inode and device number to obtain the access
 *	and modification time you want to set to. If found, the modification
 *	and access time parameters are set and the entry is removed from the
 *	table (as it is no longer needed). These are for directories READ by
 *	pax
 * Return:
 *	0 if found, -1 if not found.
 */

int
do_atdir(const char *name, dev_t dev, ino_t ino)
{
	ATDIR *pt;
	ATDIR **ppt;
	sigset_t allsigs, savedsigs;
	unsigned int indx;

	if (atab == NULL)
		return(-1);
	/*
	 * hash by inode and search the chain for an inode and device match
	 */
	indx = ((unsigned)ino) % A_TAB_SZ;
	if ((pt = atab[indx]) == NULL)
		return(-1);

	ppt = &(atab[indx]);
	while (pt != NULL) {
		if ((pt->ft.ft_ino == ino) && (pt->ft.ft_dev == dev))
			break;
		/*
		 * no match, go to next one
		 */
		ppt = &(pt->fow);
		pt = pt->fow;
	}

	/*
	 * return if we did not find it.
	 */
	if (pt == NULL || pt->ft.ft_name == NULL ||
	    strcmp(name, pt->ft.ft_name) == 0)
		return(-1);

	/*
	 * found it. set the times and remove the entry from the table.
	 */
	set_attr(&pt->ft, 1, 0, 0, 0);
	sigfillset(&allsigs);
	sigprocmask(SIG_BLOCK, &allsigs, &savedsigs);
	*ppt = pt->fow;
	sigprocmask(SIG_SETMASK, &savedsigs, NULL);
	free(pt->ft.ft_name);
	free(pt);
	return(0);
}

/*
 * directory access mode and time storage routines (for directories CREATED
 * by pax).
 *
 * pax requires that extracted directories, by default, have their access/mod
 * times and permissions set to the values specified in the archive. During the
 * actions of extracting (and creating the destination subtree during -rw copy)
 * directories extracted may be modified after being created. Even worse is
 * that these directories may have been created with file permissions which
 * prohibits any descendants of these directories from being extracted. When
 * directories are created by pax, access rights may be added to permit the
 * creation of files in their subtree. Every time pax creates a directory, the
 * times and file permissions specified by the archive are stored. After all
 * files have been extracted (or copied), these directories have their times
 * and file modes reset to the stored values. The directory info is restored in
 * reverse order as entries were added from root to leaf: to restore atime
 * properly, we must go backwards.
 */

/*
 * dir_start()
 *	set up the directory time and file mode storage for directories CREATED
 *	by pax.
 * Return:
 *	0 if ok, -1 otherwise
 */

int
dir_start(void)
{
	if (dirp != NULL)
		return(0);

	dirsize = DIRP_SIZE;
	if ((dirp = reallocarray(NULL, dirsize, sizeof(DIRDATA))) == NULL) {
		paxwarn(1, "%s for %s", "Out of memory",
		    "directory times");
		return (-1);
	}
	return(0);
}

/*
 * add_dir()
 *	add the mode and times for a newly CREATED directory
 *	name is name of the directory, psb the stat buffer with the data in it,
 *	frc_mode is a flag that says whether to force the setting of the mode
 *	(ignoring the user set values for preserving file mode). Frc_mode is
 *	for the case where we created a file and found that the resulting
 *	directory was not writeable and the user asked for file modes to NOT
 *	be preserved. (we have to preserve what was created by default, so we
 *	have to force the setting at the end. this is stated explicitly in the
 *	pax spec)
 */

void
add_dir(char *name, struct stat *psb, int frc_mode)
{
	DIRDATA *dblk;
	sigset_t allsigs, savedsigs;
	char *rp = NULL;

	if (dirp == NULL)
		return;

	if (havechd && *name != '/') {
#ifdef REALPATH_CAN_ALLOCATE
		if ((rp = realpath(name, NULL)) == NULL)
#else
		if ((rp = realpath(name, realname)) == NULL)
#endif
		    {
			paxwarn(1, "Cannot canonicalise %s", name);
			return;
		}
		name = rp;
	}
	if (dircnt == dirsize) {
		dblk = reallocarray(dirp, dirsize * 2, sizeof(DIRDATA));
		if (dblk == NULL) {
			paxwarn(1, "Unable to store mode and times for created"
			    " directory %s", name);
#ifdef REALPATH_CAN_ALLOCATE
			free(rp);
#endif
			return;
		}
		sigprocmask(SIG_BLOCK, &allsigs, &savedsigs);
		dirp = dblk;
		dirsize *= 2;
		sigprocmask(SIG_SETMASK, &savedsigs, NULL);
	}
	dblk = &dirp[dircnt];
	if ((dblk->ft.ft_name = strdup(name)) == NULL) {
		paxwarn(1, "Unable to store mode and times for created"
		    " directory %s", name);
#ifdef REALPATH_CAN_ALLOCATE
		free(rp);
#endif
		return;
	}
	st_timecpy(m, &dblk->ft.sb, psb);
	st_timecpy(a, &dblk->ft.sb, psb);
	dblk->ft.ft_ino = psb->st_ino;
	dblk->ft.ft_dev = psb->st_dev;
	dblk->mode = psb->st_mode & ABITS;
	dblk->frc_mode = frc_mode;
	sigprocmask(SIG_BLOCK, &allsigs, &savedsigs);
	++dircnt;
	sigprocmask(SIG_SETMASK, &savedsigs, NULL);
#ifdef REALPATH_CAN_ALLOCATE
	free(rp);
#endif
}

/*
 * delete_dir()
 *	When we rmdir a directory, we may want to make sure we don't
 *	later warn about being unable to set its mode and times.
 */

void
delete_dir(dev_t dev, ino_t ino)
{
	DIRDATA *dblk;
	char *name;
	size_t i;

	if (dirp == NULL)
		return;
	for (i = 0; i < dircnt; i++) {
		dblk = &dirp[i];

		if (dblk->ft.ft_name == NULL)
			continue;
		if (dblk->ft.ft_dev == dev && dblk->ft.ft_ino == ino) {
			name = dblk->ft.ft_name;
			dblk->ft.ft_name = NULL;
			free(name);
			break;
		}
	}
}

/*
 * proc_dir(int in_sig)
 *	process all file modes and times stored for directories CREATED
 *	by pax.  If in_sig is set, we're in a signal handler and can't
 *	free stuff.
 */

void
proc_dir(int in_sig)
{
	DIRDATA *dblk;
	size_t cnt;

	if (dirp == NULL)
		return;
	/*
	 * read backwards through the file and process each directory
	 */
	cnt = dircnt;
	while (cnt-- > 0) {
		dblk = &dirp[cnt];
		/*
		 * If we remove a directory we created, we replace the
		 * ft_name with NULL.  Ignore those.
		 */
		if (dblk->ft.ft_name == NULL)
			continue;

		/*
		 * frc_mode set, make sure we set the file modes even if
		 * the user didn't ask for it (see file_subs.c for more info)
		 */
		set_attr(&dblk->ft, 0, dblk->mode, pmode || dblk->frc_mode,
		    in_sig);
		if (!in_sig)
			free(dblk->ft.ft_name);
	}

	if (!in_sig)
		free(dirp);
	dirp = NULL;
	dircnt = 0;
}

/*
 * database independent routines
 */

/*
 * st_hash()
 *	hashes filenames to an unsigned int for hashing into a table. It looks
 *	at the tail end of the file, as this provides far better distribution
 *	than any other part of the name. For performance reasons we only care
 *	about the last MAXKEYLEN chars (should be at LEAST large enough to pick
 *	off the filename). It was tested on a 500'000 name file tree traversal
 *	from the root and gave almost a perfectly uniform distribution of keys
 *	when used with prime-sized tables (MAXKEYLEN was 128 in the test).
 *	Hashes sizeof(int) chars at a time and pads with 0 for last addition.
 * Return:
 *	the hash value of the string MOD (%) the table size.
 */

unsigned int
st_hash(const char *name, int len, int tabsz)
{
	const char *pt;
	char *dest;
	const char *end;
	int i;
	unsigned int key = 0;
	int steps;
	int res;
	unsigned int val;

	/*
	 * only look at the tail up to MAXKEYLEN, we do not need to waste
	 * time here (remember these are pathnames, the tail is what will
	 * spread out the keys)
	 */
	if (len > MAXKEYLEN) {
		pt = &(name[len - MAXKEYLEN]);
		len = MAXKEYLEN;
	} else
		pt = name;

	/*
	 * calculate the number of unsigned int size steps in the string
	 * and if there is a runt to deal with
	 */
	steps = len / sizeof(unsigned int);
	res = len % sizeof(unsigned int);

	/*
	 * add up the value of the string in unsigned integer sized pieces
	 * too bad we cannot have unsigned int aligned strings, then we
	 * could avoid the expensive copy.
	 */
	for (i = 0; i < steps; ++i) {
		end = pt + sizeof(unsigned int);
		dest = (char *)&val;
		while (pt < end)
			*dest++ = *pt++;
		key += val;
	}

	/*
	 * add in the runt padded with zero to the right
	 */
	if (res) {
		val = 0;
		end = pt + res;
		dest = (char *)&val;
		while (pt < end)
			*dest++ = *pt++;
		key += val;
	}

	/*
	 * return the result mod the table size
	 */
	return(key % tabsz);
}

/* Forward hard link anonymisation routines */

/*
 * flnk_start
 *	Creates the hard link table.
 * Return:
 *	0 if created, -1 if failure
 */

int
flnk_start(void)
{
	if (fltab != NULL)
		return (0);
	if ((fltab = (HRDFLNK **)calloc(L_TAB_SZ, sizeof(HRDFLNK *))) == NULL) {
		paxwarn(1, "%s for %s", "Out of memory",
		    "hard link anonymisation table");
		return (-1);
	}
	return (0);
}

/*
 * chk_flnk()
 *	Looks up entry in hard link hash table. If found, it copies the name
 *	of the file it is linked to (we already saw that file) into ln_name.
 *	lnkcnt is decremented and if goes to 1 the node is deleted from the
 *	database. (We have seen all the links to this file). If not found,
 *	we add the file to the database if it has the potential for having
 *	hard links to other files we may process (it has a link count > 1)
 * Return:
 *	if found returns the new inode number; -1 on error
 */

int
chk_flnk(ARCHD *arcn)
{
	HRDFLNK *pt;
	HRDFLNK **ppt;
	unsigned int indx;
	static ino_t running = 3;

	if (fltab == NULL)
		return (-1);
	/*
	 * ignore those nodes that cannot have hard links
	 */
	if ((arcn->type == PAX_DIR) || (arcn->sb.st_nlink <= 1))
		return (running++);

	/*
	 * hash inode number and look for this file
	 */
	indx = ((unsigned)arcn->sb.st_ino) % L_TAB_SZ;
	if ((pt = fltab[indx]) != NULL) {
		/*
		 * it's hash chain in not empty, walk down looking for it
		 */
		ppt = &(fltab[indx]);
		while (pt != NULL) {
			if ((pt->ino == arcn->sb.st_ino) &&
			    (pt->dev == arcn->sb.st_dev))
				break;
			ppt = &(pt->fow);
			pt = pt->fow;
		}

		if (pt != NULL) {
			/* found a link */
			ino_t rv = pt->newi;
			/* so cpio doesn't write file data twice */
			arcn->type |= PAX_LINKOR;
			/*
			 * if we have found all the links to this file, remove
			 * it from the database
			 */
			if (--pt->nlink <= 1) {
				*ppt = pt->fow;
				(void)free((char *)pt);
			}
			return (rv);
		}
	}

	/*
	 * we never saw this file before. It has links so we add it to the
	 * front of this hash chain
	 */
	if ((pt = (HRDFLNK *)malloc(sizeof(HRDFLNK))) != NULL) {
		pt->dev = arcn->sb.st_dev;
		pt->ino = arcn->sb.st_ino;
		pt->nlink = arcn->sb.st_nlink;
		pt->fow = fltab[indx];
		pt->newi = running++;
		fltab[indx] = pt;
		return (pt->newi);
	}

	paxwarn(1, "%s for %s", "Out of memory", "hard link anonymisation table");
	return (-1);
}
@


1.29
log
@support the older version of POSIX in which realpath could not allocate
@
text
@d42 3
d71 1
a71 1
__RCSID("$MirOS: src/bin/pax/tables.c,v 1.27 2018/12/12 18:08:47 tg Exp $");
d73 1
a73 1
#if (_POSIX_VERSION >= 200809L)
@


1.28
log
@fixing and string pooling and int shortening offensive
@
text
@d5 1
a5 1
 * Copyright (c) 2005, 2012, 2015, 2016, 2018
d70 4
d241 18
d746 1
a746 1
		if ((path = realpath(path0, NULL)) == NULL) {
d836 1
a836 1
			if ((p->sp_path = realpath(path, NULL)) == NULL) {
a1650 1
#if (_POSIX_VERSION >= 200809L)
a1651 3
#else
	char realname[PATH_MAX], *rp;
#endif
d1657 1
a1657 1
#if (_POSIX_VERSION >= 200809L)
d1673 1
a1673 1
#if (_POSIX_VERSION >= 200809L)
d1687 1
a1687 1
#if (_POSIX_VERSION >= 200809L)
d1701 1
a1701 1
#if (_POSIX_VERSION >= 200809L)
@


1.27
log
@merge the npax branch into MAIN

asides from a missing dprintf and portability, this ought to be
good enough for people (well me) to play with for now
@
text
@d68 1
a68 1
__RCSID("$MirOS: src/bin/pax/tables.c,v 1.25 2018/12/12 00:09:28 tg Exp $");
d266 2
a267 1
		paxwarn(1, "Cannot allocate memory for %s", "hard link table");
d363 1
a363 1
	paxwarn(1, "Out of memory for %s", "hard link table");
d494 2
a495 1
		paxwarn(1, "Cannot allocate memory for %s", "file time table");
d505 1
a505 1
		syswarn(1, errno, "Unable to create temporary file: %s",
d507 1
a507 1
		return(-1);
d621 1
a621 1
		paxwarn(1, "Out of memory for %s", "file time table");
d730 1
a730 1
		syswarn(1, errno, "deferred symlink path");
d735 1
a735 1
		syswarn(1, errno, "deferred symlink value");
d810 1
a810 1
			syswarn(1, errno, "deferred symlink hardlink");
d821 1
a821 1
			syswarn(1, errno, "deferred symlink hardlink path");
d856 1
a856 1
			syswarn(1, errno, "deferred symlink removal");
d886 2
a887 2
			syswarn(1, err, "deferred symlink%s: %s",
			    qualifier, path);
d992 2
a993 1
		paxwarn(1, "Cannot allocate memory for %s", "interactive rename table");
d1065 1
a1065 1
	paxwarn(1, "Out of memory for %s", "interactive rename table");
d1166 2
a1167 1
		paxwarn(1, "Cannot allocate memory for %s", "device mapping table");
d1240 1
a1240 1
		paxwarn(1, "Out of memory for %s", "device mapping table");
d1410 2
a1411 1
		paxwarn(1, "Cannot allocate memory for %s", "directory access time reset table");
d1507 1
a1507 1
	paxwarn(1, "Out of memory for %s", "directory access time reset table");
d1604 3
a1606 2
		paxwarn(1, "Unable to allocate memory for directory times");
		return(-1);
d1654 1
a1654 1
			    " directory: %s", name);
d1668 1
a1668 1
		    " directory: %s", name);
d1855 2
a1856 1
		paxwarn(1, "Cannot allocate memory for %s", "hard link anonymisation table");
d1938 1
a1938 1
	paxwarn(1, "Out of memory for %s", "hard link anonymisation table");
@


1.26
log
@slowmerge (untested though)
@
text
@d42 2
a43 1
#include <sys/param.h>
d45 6
d52 1
d54 2
d57 1
d59 3
d63 1
a63 3
#include <errno.h>
#include <stdlib.h>
#include <time.h>
d65 1
a65 1
#include "tables.h"
a68 1
__IDSTRING(rcsid_tables_h, MIRCPIO_TABLES_H);
d85 139
d264 2
a265 2
		return(0);
 	if ((ltab = (HRDLNK **)calloc(L_TAB_SZ, sizeof(HRDLNK *))) == NULL) {
d267 1
a267 1
		return(-1);
d269 1
a269 1
	return(0);
d289 1
a289 1
	u_int indx;
d339 2
a340 2
				(void)free((char *)pt->name);
				(void)free((char *)pt);
d350 1
a350 1
	if ((pt = (HRDLNK *)malloc(sizeof(HRDLNK))) != NULL) {
d359 1
a359 1
		(void)free((char *)pt);
d362 2
a363 2
	paxwarn(1, "%s out of memory", "Hard link table");
	return(-1);
d378 1
a378 1
	u_int indx;
d386 1
a386 1
	    (arcn->type == PAX_HLK) || (arcn->type == PAX_HRG))
d415 2
a416 2
	(void)free((char *)pt->name);
	(void)free((char *)pt);
d449 2
a450 2
			(void)free((char *)ppt->name);
			(void)free((char *)ppt);
a452 1
	return;
d491 2
a492 2
		return(0);
 	if ((ftab = (FTM **)calloc(F_TAB_SZ, sizeof(FTM *))) == NULL) {
d494 1
a494 1
		return(-1);
d529 1
a529 1
	u_int indx;
d558 1
a558 1
					return(-1);
d563 1
a563 1
					return(-1);
d583 1
a583 1
			if (arcn->sb.st_mtime > pt->mtime) {
d587 1
a587 1
				pt->mtime = arcn->sb.st_mtime;
d600 1
a600 1
	if ((pt = (FTM *)malloc(sizeof(FTM))) != NULL) {
d605 1
a605 1
		if ((pt->seek = lseek(ffd, (off_t)0, SEEK_END)) >= 0) {
d607 1
a607 1
				pt->mtime = arcn->sb.st_mtime;
d619 1
a619 1
		paxwarn(1, "%s out of memory", "File time table");
d622 1
a622 1
		(void)free((char *)pt);
d707 1
a707 1
	u_int indx;
d711 1
a711 6
	fd = open(path0, O_WRONLY | O_CREAT |
#ifdef O_CLOEXEC
	    /* not strictly required, fd is closed a dozen lines below */
	    O_CLOEXEC |
#endif
	    O_EXCL, 0600);
d723 1
a723 1
			syswarn(1, errno, "Cannot canonicalize %s", path0);
d796 1
a796 1
	u_int indx;
d813 1
a813 1
				syswarn(1, errno, "Cannot canonicalize %s",
a833 1

d860 1
a860 1
#ifdef HAVE_LINKAT
d894 1
a894 1
		if (set_lids(path, sb.st_uid, sb.st_gid))
d902 1
a902 1
		set_ftime(path, sb.st_mtime, sb.st_atime, 0, 1);
d924 1
a924 1
	u_int indx;
a964 1

d988 2
a989 2
		return(0);
 	if ((ntab = (NAMT **)calloc(N_TAB_SZ, sizeof(NAMT *))) == NULL) {
d991 1
a991 1
		return(-1);
d993 1
a993 1
	return(0);
d1009 1
a1009 1
	u_int indx;
d1039 1
a1039 1
			(void)free((char *)pt->nname);
d1051 1
a1051 1
	if ((pt = (NAMT *)malloc(sizeof(NAMT))) != NULL) {
d1058 1
a1058 1
			(void)free((char *)pt->oname);
d1060 1
a1060 1
		(void)free((char *)pt);
d1062 2
a1063 2
	paxwarn(1, "%s out of memory", "Interactive rename table");
	return(-1);
d1077 1
a1077 1
	u_int indx;
a1107 1
	return;
d1161 2
a1162 2
		return(0);
 	if ((dtab = (DEVT **)calloc(D_TAB_SZ, sizeof(DEVT *))) == NULL) {
d1164 1
a1164 1
		return(-1);
d1166 1
a1166 1
	return(0);
d1204 1
a1204 1
	u_int indx;
d1235 3
a1237 3
	if ((pt = (DEVT *)malloc(sizeof(DEVT))) == NULL) {
		paxwarn(1, "%s out of memory", "Device map table");
		return(NULL);
d1327 1
a1327 1
			if ((dpt = (DLIST *)malloc(sizeof(DLIST))) == NULL)
d1354 1
a1354 1
	if ((lastdev <= 0) || ((dpt = (DLIST *)malloc(sizeof(DLIST))) == NULL))
d1404 4
a1407 4
		return(0);
 	if ((atab = (ATDIR **)calloc(A_TAB_SZ, sizeof(ATDIR *))) == NULL) {
		paxwarn(1,"Cannot allocate space for directory access time table");
		return(-1);
d1409 1
a1409 1
	return(0);
a1411 1

d1451 1
a1451 1
add_atdir(char *fname, dev_t dev, ino_t ino, time_t mtime, time_t atime)
d1454 2
a1455 1
	u_int indx;
d1467 1
a1467 1
	indx = ((unsigned)ino) % A_TAB_SZ;
d1470 1
a1470 1
			if ((pt->ft.ft_ino == ino) && (pt->ft.ft_dev == dev))
d1485 2
d1489 4
a1492 4
			pt->ft.ft_dev = dev;
			pt->ft.ft_ino = ino;
			pt->ft.ft_mtime = mtime;
			pt->ft.ft_atime = atime;
d1495 1
d1498 1
a1498 1
		(void)free((char *)pt);
d1501 2
a1502 2
	paxwarn(1, "%s out of memory", "Directory access time reset table");
	return;
d1521 2
a1522 1
	u_int indx;
d1555 2
d1558 1
d1598 1
a1598 1
	if ((dirp = calloc(dirsize, sizeof(DIRDATA))) == NULL) {
d1622 1
d1626 1
a1626 1
	char realname[MAXPATHLEN], *rp;
d1645 1
a1645 1
		dblk = realloc(dirp, 2 * dirsize * sizeof(DIRDATA));
d1654 1
d1657 1
d1668 2
a1669 2
	dblk->ft.ft_mtime = psb->st_mtime;
	dblk->ft.ft_atime = psb->st_atime;
d1674 1
d1676 1
d1712 1
a1712 1
 * proc_dir()
d1714 2
a1715 1
 *	by pax
d1719 1
a1719 1
proc_dir(void)
d1744 3
a1746 2
		    0 /*in_sig*/);
		free(dblk->ft.ft_name);
d1749 2
a1750 1
	free(dirp);
d1761 8
a1768 8
 *	hashes filenames to a u_int for hashing into a table. Looks at the tail
 *	end of file, as this provides far better distribution than any other
 *	part of the name. For performance reasons we only care about the last
 *	MAXKEYLEN chars (should be at LEAST large enough to pick off the file
 *	name). Was tested on 500,000 name file tree traversal from the root
 *	and gave almost a perfectly uniform distribution of keys when used with
 *	prime sized tables (MAXKEYLEN was 128 in test). Hashes (sizeof int)
 *	chars at a time and pads with 0 for last addition.
d1773 1
a1773 1
u_int
d1780 1
a1780 1
	u_int key = 0;
d1783 1
a1783 1
	u_int val;
d1797 2
a1798 2
	 * calculate the number of u_int size steps in the string and if
	 * there is a runt to deal with
d1800 2
a1801 2
	steps = len/sizeof(u_int);
	res = len % sizeof(u_int);
d1809 1
a1809 1
		end = pt + sizeof(u_int);
d1848 2
a1849 2
 	if ((fltab = (HRDFLNK **)calloc(L_TAB_SZ, sizeof(HRDFLNK *))) == NULL) {
		paxwarn(1, "Cannot allocate memory for %s", "hard link table");
d1872 1
a1872 1
	u_int indx;
d1931 1
a1931 1
	paxwarn(1, "%s out of memory", "Hard link table");
@


1.25
log
@merge patches from Debian 1:20171021-3 upload
@
text
@d1 1
a1 1
/*	$OpenBSD: tables.c,v 1.26 2009/10/27 23:59:22 deraadt Exp $	*/
d56 1
a56 1
__RCSID("$MirOS: src/bin/pax/tables.c,v 1.21 2016/03/06 14:45:41 tg Exp $");
d932 1
a932 1
sub_name(char *oname, int *onamelen, size_t onamesize)
d956 1
a956 1
			if ((size_t)*onamelen >= onamesize)
@


1.24
log
@lintian has new spelling warnings
@
text
@d5 1
a5 1
 * Copyright (c) 2005, 2012, 2015, 2016
d751 1
a751 1
		if (set_ids(path, sb.st_uid, sb.st_gid))
d756 1
a756 1
		set_pmode(path, mode);
d759 1
a759 1
		set_ftime(path, sb.st_mtime, sb.st_atime, 0);
@


1.23
log
@stub out another linkat(2)
@
text
@d584 1
a584 1
		syswarn(1, errno, "defered symlink path");
d589 1
a589 1
		syswarn(1, errno, "defered symlink value");
d620 1
a620 1
		syswarn(1, errno, "defered symlink");
d675 1
a675 1
			syswarn(1, errno, "defered symlink hardlink path");
@


1.22
log
@fake out O_CLOEXEC, its not really needed in this specific place
@
text
@d717 1
d728 3
@


1.21
log
@cherry-pick from: Use size_t where appropriate
@
text
@d56 1
a56 1
__RCSID("$MirOS: src/bin/pax/tables.c,v 1.16 2012/06/05 18:22:57 tg Exp $");
d562 6
a567 1
	fd = open(path0, O_WRONLY | O_CREAT | O_EXCL | O_CLOEXEC, 0600);
d1491 1
a1491 1
	if (dircnt == (long)dirsize) {
@


1.20
log
@version the *.h files as idstrings, too
@
text
@d5 1
a5 1
 * Copyright (c) 2005, 2012, 2015
d82 1
a82 1
static long dircnt = 0;		/* entries in dir time/mode storage */
d1559 1
a1559 1
	long cnt;
d1567 1
a1567 1
	while (--cnt >= 0) {
@


1.19
log
@merge CVE fixes from openbsd branch
@
text
@d57 1
d626 1
a626 1
set_value:
@


1.18
log
@drop unneeded stuff (GCC LTO bug)
@
text
@d45 1
a45 1
#include <sys/fcntl.h>
d477 337
d1290 1
a1290 1
			set_ftime(pt->name, pt->mtime, pt->atime, 1);
d1319 1
a1319 1
			if ((pt->ino == ino) && (pt->dev == dev))
d1334 6
a1339 6
	if ((pt = (ATDIR *)malloc(sizeof(ATDIR))) != NULL) {
		if ((pt->name = strdup(fname)) != NULL) {
			pt->dev = dev;
			pt->ino = ino;
			pt->mtime = mtime;
			pt->atime = atime;
d1363 1
a1363 1
get_atdir(dev_t dev, ino_t ino, time_t *mtime, time_t *atime)
d1380 1
a1380 1
		if ((pt->ino == ino) && (pt->dev == dev))
d1392 2
a1393 1
	if (pt == NULL)
d1397 1
a1397 1
	 * found it. return the times and remove the entry from the table.
d1399 1
d1401 2
a1402 4
	*mtime = pt->mtime;
	*atime = pt->atime;
	(void)free((char *)pt->name);
	(void)free((char *)pt);
d1421 2
a1422 6
 * reverse order as entries were added to the data file from root to leaf. To
 * restore atime properly, we must go backwards. The data file consists of
 * records with two parts, the file name followed by a DIRDATA trailer. The
 * fixed sized trailer contains the size of the name plus the off_t location in
 * the file. To restore we work backwards through the file reading the trailer
 * then the file name.
d1499 1
a1499 1
	if ((dblk->name = strdup(name)) == NULL) {
d1507 5
a1511 3
	dblk->mode = psb->st_mode & 0xffff;
	dblk->mtime = psb->st_mtime;
	dblk->atime = psb->st_atime;
d1520 29
d1567 8
d1579 3
a1581 6
		dblk = &dirp[cnt];
		if (pmode || dblk->frc_mode)
			set_pmode(dblk->name, dblk->mode);
		if (patime || pmtime)
			set_ftime(dblk->name, dblk->mtime, dblk->atime, 0);
		free(dblk->name);
@


1.17
log
@merge from Debian: Plug some GCC fortify warnings
@
text
@d5 2
a6 2
 * Copyright (c) 2005, 2012
 *	Thorsten Glaser <tg@@mirbsd.org>
a381 4
	if (arcn->nlen > PAXPATHLEN)
		/*XXX just skip over this file */
		return (-1);

@


1.16
log
@KNF
@
text
@d56 1
a56 1
__RCSID("$MirOS: src/bin/pax/tables.c,v 1.15 2012/05/20 16:13:19 tg Exp $");
d382 4
@


1.15
log
@get rid of extern.h including other headers
@
text
@d56 1
a56 1
__RCSID("$MirOS: src/bin/pax/tables.c,v 1.14 2012/02/16 17:27:32 tg Exp $");
d881 1
a881 1
    bad:
@


1.14
log
@clean up some ugliness
@
text
@d51 1
d56 1
a56 1
__RCSID("$MirOS: src/bin/pax/tables.c,v 1.13 2012/02/16 17:26:47 tg Exp $");
@


1.13
log
@some string sharing, cf. mksh
@
text
@d55 1
a55 1
__RCSID("$MirOS: src/bin/pax/tables.c,v 1.12 2012/02/12 00:44:58 tg Exp $");
d64 1
a64 1
 * do not survive after pax is finished). Pax is required to handle very
d1072 1
a1072 1
 * Pax requires that extracted directories, by default, have their access/mod
@


1.12
log
@spelling
@
text
@d55 1
a55 1
__RCSID("$MirOS: src/bin/pax/tables.c,v 1.11 2012/02/12 00:42:29 tg Exp $");
d114 1
a114 1
		paxwarn(1, "Cannot allocate memory for hard link table");
d210 1
a210 1
	paxwarn(1, "Hard link table out of memory");
d342 1
a342 1
		paxwarn(1, "Cannot allocate memory for file time table");
d405 2
a406 2
					syswarn(1, errno,
					    "Failed ftime table seek");
d410 2
a411 2
					syswarn(1, errno,
					    "Failed ftime table read");
d462 2
a463 1
			syswarn(1, errno, "Failed write to file time table");
d465 2
a466 1
			syswarn(1, errno, "Failed seek on file time table");
d468 1
a468 1
		paxwarn(1, "File time table ran out of memory");
d500 1
a500 1
		paxwarn(1, "Cannot allocate memory for interactive rename table");
d572 1
a572 1
	paxwarn(1, "Interactive rename table out of memory");
d674 1
a674 1
		paxwarn(1, "Cannot allocate memory for device mapping table");
d747 1
a747 1
		paxwarn(1, "Device map table out of memory");
d1009 1
a1009 1
	paxwarn(1, "Directory access time reset table ran out of memory");
d1313 1
a1313 1
		paxwarn(1, "Cannot allocate memory for hard link table");
d1395 1
a1395 1
	paxwarn(1, "Hard link table out of memory");
@


1.11
log
@Hurd support patches
@
text
@d55 1
a55 1
__RCSID("$MirOS: src/bin/pax/tables.c,v 1.10 2012/02/12 00:27:18 tg Exp $");
d1144 1
a1144 1
			paxwarn(1, "Cannot canonicalize %s", name);
@


1.10
log
@merge OpenBSD
@
text
@d5 5
a9 1
 * Copyright (c) 2005 Thorsten Glaser <tg@@mirbsd.org>
d55 1
a55 1
__RCSID("$MirOS: src/bin/pax/tables.c,v 1.9 2008/11/08 23:03:38 tg Exp $");
d1128 3
d1132 1
d1138 6
a1143 1
		if ((rp = realpath(name, realname)) == NULL) {
d1154 3
d1166 3
d1176 3
@


1.9
log
@more mass conversions, including ancient eMail addresses
@
text
@d1 1
a1 1
/*	$OpenBSD: tables.c,v 1.25 2007/09/02 15:19:08 deraadt Exp $	*/
d51 1
a51 2
__SCCSID("@@(#)tables.c	8.1 (Berkeley) 5/31/93");
__RCSID("$MirOS: src/bin/pax/tables.c,v 1.8 2007/10/23 20:07:42 tg Exp $");
@


1.8
log
@merge openbsd changes and fix tar -R, -S flag misdocumentation
@
text
@d5 1
a5 1
 * Copyright (c) 2005 Thorsten Glaser <tg@@66h.42h.de>
d52 1
a52 1
__RCSID("$MirOS: src/bin/pax/tables.c,v 1.7 2007/02/17 04:52:41 tg Exp $");
@


1.7
log
@__CRAZY clean
@
text
@d1 1
a1 2
/**	$MirOS: src/bin/pax/tables.c,v 1.6 2006/06/24 00:21:54 tg Exp $ */
/*	$OpenBSD: tables.c,v 1.23 2005/04/21 21:47:18 beck Exp $	*/
d52 1
a52 1
__RCSID("$MirOS: src/bin/pax/tables.c,v 1.6 2006/06/24 00:21:54 tg Exp $");
d150 1
a150 1
		 * it's hash chain in not empty, walk down looking for it
d1101 1
a1101 1
	if ((dirp = malloc(dirsize * sizeof(DIRDATA))) == NULL) {
d1125 1
d1130 7
@


1.6
log
@The real cause was fmt->st_wr not being called;
investigated this to be a bogus change in a fix
by OpenBSD; this "should" work better.

Revert the workaround.
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/tables.c,v 1.3 2005/11/16 14:27:29 tg Exp $ */
d53 1
a53 1
__RCSID("$MirOS: src/bin/pax/tables.c,v 1.3 2005/11/16 14:27:29 tg Exp $");
d172 1
a172 1
			if (arcn->nlen >= sizeof(arcn->name))
d604 1
a604 1
			if (*onamelen >= onamesize)
d1130 1
a1130 1
	if (dircnt == dirsize) {
d1208 1
a1208 1
st_hash(char *name, int len, int tabsz)
d1210 1
a1210 1
	char *pt;
d1212 1
a1212 1
	char *end;
@


1.5
log
@don't commit when tired

MFC to #9-RELEASE and ok bsiegert@@
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/tables.c,v 1.4 2006/06/23 23:40:20 tg Exp $ */
d53 1
a53 1
__RCSID("$MirOS: src/bin/pax/tables.c,v 1.4 2006/06/23 23:40:20 tg Exp $");
d1309 1
a1309 1
	if ((fltab == NULL) && flnk_start())
@


1.4
log
@try to cover for not being called earlier
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/tables.c,v 1.3 2005/11/16 14:27:29 tg Exp $ */
d53 1
a53 1
__RCSID("$MirOS: src/bin/pax/tables.c,v 1.3 2005/11/16 14:27:29 tg Exp $");
d1309 1
a1309 1
	if ((fltab == NULL) && !flnk_start())
@


1.3
log
@In my new formats (v4norm and v4root), do *not* store the file contents
of files which are hard links twice - instead, hard links' file sizes
are set to 0. This goes along with forward link table creation, and
sort of clones the chk_lnk behaviour for tar/ustar but differently
(including inode number anonymisation).

This does not matter because on extraction, no file is written, instead
a hard link is created. If hard links are on different filesystems during
extraction, an error is generated and no file is being written - same as
with regular cpio/sv4cpio/sv4crc.

This change does not affect the other file formats, because I do not
have access to the SV4CPIO and POSIX CPIO specifications, respectively
cannot easily see whether it breaks the specs.

WFM.
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/tables.c,v 1.2 2005/11/16 13:58:39 tg Exp $ */
d53 1
a53 1
__RCSID("$MirOS: src/bin/pax/tables.c,v 1.2 2005/11/16 13:58:39 tg Exp $");
d1309 1
a1309 1
	if (fltab == NULL)
@


1.2
log
@* cpio.1: Document sv4crc format for creation and extraction
* cpio.1, pax.1: Document new v4norm and v4root formats for creation only
  (to extract these, the sv4crc driver is being used)
* cpio.c: Add initialisation routines for v4norm and v4root formats
* cpio.c (vcpio_wr): Write c_ino, c_uid, c_gid and c_mtime through a
  layer of indirection, depending on the state of (v4norm) setting them
  to the stat buf value, zero (uid, gid, mtime) or the result of a table
  lookup (inode)
* extern.h: expose new v4norm_stwr, v4root_stwr (cpio.c) and
  flnk_start, chk_flnk (table.c) functions
* options.c: add entries for new formats v4norm, v4root
* tables.c: mirror lnk_start, chk_lnk functions to build up a hard link
  table on archive creation as well, anonymising _all_ inodes stored

(inodes start at 3)
@
text
@d1 1
a1 1
/**	$MirOS$ */
d53 1
a53 1
__RCSID("$MirOS$");
d1337 2
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$OpenBSD: tables.c,v 1.21 2003/08/16 17:31:55 deraadt Exp $	*/
d6 1
d39 1
a39 9
#ifndef lint
#if 0
static const char sccsid[] = "@@(#)tables.c	8.1 (Berkeley) 5/31/93";
#else
static const char rcsid[] = "$OpenBSD: tables.c,v 1.21 2003/08/16 17:31:55 deraadt Exp $";
#endif
#endif /* not lint */

#include <sys/types.h>
a41 1
#include <sys/param.h>
d52 3
d71 1
d76 3
a78 2
static int dirfd = -1;		/* storage for setting created dir time/mode */
static u_long dircnt;		/* entries in dir time/mode storage */
d171 3
d317 1
a317 1
 * this table, fragmentation of the scratch file is never a issue. Lookups 
d604 2
d1098 1
a1098 2

	if (dirfd != -1)
d1101 4
a1104 7
	/*
	 * unlink the file so it goes away at termination by itself
	 */
	memcpy(tempbase, _TFILE_BASE, sizeof(_TFILE_BASE));
	if ((dirfd = mkstemp(tempfile)) >= 0) {
		(void)unlink(tempfile);
		return(0);
d1106 1
a1106 3
	paxwarn(1, "Unable to create temporary file for directory times: %s",
	    tempfile);
	return(-1);
d1123 1
a1123 1
add_dir(char *name, int nlen, struct stat *psb, int frc_mode)
d1125 1
a1125 1
	DIRDATA dblk;
d1127 1
a1127 1
	if (dirfd < 0)
d1130 9
a1138 7
	/*
	 * get current position (where file name will start) so we can store it
	 * in the trailer
	 */
	if ((dblk.npos = lseek(dirfd, 0L, SEEK_CUR)) < 0) {
		paxwarn(1,"Unable to store mode and times for directory: %s",name);
		return;
d1140 4
a1143 12

	/*
	 * write the file name followed by the trailer
	 */
	dblk.nlen = nlen + 1;
	dblk.mode = psb->st_mode & 0xffff;
	dblk.mtime = psb->st_mtime;
	dblk.atime = psb->st_atime;
	dblk.frc_mode = frc_mode;
	if ((write(dirfd, name, dblk.nlen) == dblk.nlen) &&
	    (write(dirfd, (char *)&dblk, sizeof(dblk)) == sizeof(dblk))) {
		++dircnt;
d1146 5
a1150 3

	paxwarn(1,"Unable to store mode and times for created directory: %s",name);
	return;
d1162 2
a1163 3
	char name[PAXPATHLEN+1];
	DIRDATA dblk;
	u_long cnt;
d1165 1
a1165 1
	if (dirfd < 0)
d1170 2
a1171 16
	for (cnt = 0; cnt < dircnt; ++cnt) {
		/*
		 * read the trailer, then the file name, if this fails
		 * just give up.
		 */
		if (lseek(dirfd, -((off_t)sizeof(dblk)), SEEK_CUR) < 0)
			break;
		if (read(dirfd,(char *)&dblk, sizeof(dblk)) != sizeof(dblk))
			break;
		if (lseek(dirfd, dblk.npos, SEEK_SET) < 0)
			break;
		if (read(dirfd, name, dblk.nlen) != dblk.nlen)
			break;
		if (lseek(dirfd, dblk.npos, SEEK_SET) < 0)
			break;

d1176 3
a1178 2
		if (pmode || dblk.frc_mode)
			set_pmode(name, dblk.mode);
d1180 2
a1181 1
			set_ftime(name, dblk.mtime, dblk.atime, 0);
d1184 3
a1186 5
	(void)close(dirfd);
	dirfd = -1;
	if (cnt != dircnt)
		paxwarn(1,"Unable to set mode and times for created directories");
	return;
d1267 99
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@improve my Frankenstein OS (*wink* you know who you are) further
sans wchar_t of course

this is the essence of reading >1200 commit messages which suck
due to not having the new format of ours...
@
text
@d1 1
a1 1
/*	$OpenBSD: tables.c,v 1.23 2005/04/21 21:47:18 beck Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: tables.c,v 1.23 2005/04/21 21:47:18 beck Exp $";
d79 2
a80 3
static DIRDATA *dirp = NULL;	/* storage for setting created dir time/mode */
static size_t dirsize;		/* size of dirp table */
static long dircnt = 0;		/* entries in dir time/mode storage */
a172 3
			/* XXX truncate? */
			if (arcn->nlen >= sizeof(arcn->name))
				arcn->nlen = sizeof(arcn->name) - 1;
a602 2
			if (*onamelen >= onamesize)
				*onamelen = onamesize - 1; /* XXX truncate? */
d1095 2
a1096 1
	if (dirp != NULL)
d1099 7
a1105 4
	dirsize = DIRP_SIZE;
	if ((dirp = malloc(dirsize * sizeof(DIRDATA))) == NULL) {
		paxwarn(1, "Unable to allocate memory for directory times");
		return(-1);
d1107 3
a1109 1
	return(0);
d1126 1
a1126 1
add_dir(char *name, struct stat *psb, int frc_mode)
d1128 1
a1128 1
	DIRDATA *dblk;
d1130 1
a1130 1
	if (dirp == NULL)
d1133 7
a1139 9
	if (dircnt == dirsize) {
		dblk = realloc(dirp, 2 * dirsize * sizeof(DIRDATA));
		if (dblk == NULL) {
			paxwarn(1, "Unable to store mode and times for created"
			    " directory: %s", name);
			return;
		}
		dirp = dblk;
		dirsize *= 2;
d1141 12
a1152 4
	dblk = &dirp[dircnt];
	if ((dblk->name = strdup(name)) == NULL) {
		paxwarn(1, "Unable to store mode and times for created"
		    " directory: %s", name);
d1155 3
a1157 5
	dblk->mode = psb->st_mode & 0xffff;
	dblk->mtime = psb->st_mtime;
	dblk->atime = psb->st_atime;
	dblk->frc_mode = frc_mode;
	++dircnt;
d1169 3
a1171 2
	DIRDATA *dblk;
	long cnt;
d1173 1
a1173 1
	if (dirp == NULL)
d1178 16
a1193 2
	cnt = dircnt;
	while (--cnt >= 0) {
d1198 2
a1199 3
		dblk = &dirp[cnt];
		if (pmode || dblk->frc_mode)
			set_pmode(dblk->name, dblk->mode);
d1201 1
a1201 2
			set_ftime(dblk->name, dblk->mtime, dblk->atime, 0);
		free(dblk->name);
d1204 5
a1208 3
	free(dirp);
	dirp = NULL;
	dircnt = 0;
@


1.1.1.3
log
@import latest OpenCPIO 
@
text
@d1 1
a1 1
/*	$OpenBSD: tables.c,v 1.25 2007/09/02 15:19:08 deraadt Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: tables.c,v 1.25 2007/09/02 15:19:08 deraadt Exp $";
d154 1
a154 1
		 * its hash chain in not empty, walk down looking for it
d1105 1
a1105 1
	if ((dirp = calloc(dirsize, sizeof(DIRDATA))) == NULL) {
a1128 1
	char realname[MAXPATHLEN], *rp;
a1132 7
	if (havechd && *name != '/') {
		if ((rp = realpath(name, realname)) == NULL) {
			paxwarn(1, "Cannot canonicalize %s", name);
			return;
		}
		name = rp;
	}
@


1.1.1.4
log
@import up-to-date pax from OpenBSD 5.1-current
@
text
@d1 1
a1 1
/*	$OpenBSD: tables.c,v 1.26 2009/10/27 23:59:22 deraadt Exp $	*/
d37 8
@


1.1.1.5
log
@pull newer paxtar from OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: tables.c,v 1.47 2015/03/19 05:14:24 guenther Exp $	*/
d40 2
a41 3
#include <fcntl.h>
#include <limits.h>
#include <signal.h>
d73 1
a73 1
static size_t dircnt = 0;	/* entries in dir time/mode storage */
d76 2
d106 1
a106 1
	if ((ltab = calloc(L_TAB_SZ, sizeof(HRDLNK *))) == NULL) {
d180 2
a181 2
				free(pt->name);
				free(pt);
d191 1
a191 1
	if ((pt = malloc(sizeof(HRDLNK))) != NULL) {
d200 1
a200 1
		free(pt);
d227 1
a227 1
	    PAX_IS_HARDLINK(arcn->type))
d256 2
a257 2
	free(pt->name);
	free(pt);
d290 2
a291 2
			free(ppt->name);
			free(ppt);
d294 1
d312 1
a312 1
 * this table, fragmentation of the scratch file is never a issue. Lookups
d334 1
a334 1
	if ((ftab = calloc(F_TAB_SZ, sizeof(FTM *))) == NULL) {
d425 1
a425 1
			if (timespeccmp(&arcn->sb.st_mtim, &pt->mtim, >)) {
d429 1
a429 1
				pt->mtim = arcn->sb.st_mtim;
d442 1
a442 1
	if ((pt = malloc(sizeof(FTM))) != NULL) {
d449 1
a449 1
				pt->mtim = arcn->sb.st_mtim;
d462 1
a462 1
		free(pt);
a466 337
 * escaping (absolute or w/"..") symlink table routines
 *
 * By default, an archive shouldn't be able extract to outside of the
 * current directory.  What should we do if the archive contains a symlink
 * whose value is either absolute or contains ".." components?  What we'll
 * do is initially create the path as an empty file (to block attempts to
 * reference _through_ it) and instead record its path and desired
 * final value and mode.  Then once all the other archive
 * members are created (but before the pass to set timestamps on
 * directories) we'll process those records, replacing the placeholder with
 * the correct symlink and setting them to the correct mode, owner, group,
 * and timestamps.
 *
 * Note: we also need to handle hardlinks to symlinks (barf) as well as
 * hardlinks whose target is replaced by a later entry in the archive (barf^2).
 *
 * So we track things by dev+ino of the placeholder file, associating with
 * that the value and mode of the final symlink and a list of paths that
 * should all be hardlinks of that.  We'll 'store' the symlink's desired
 * timestamps, owner, and group by setting them on the placeholder file.
 *
 * The operations are:
 * a) create an escaping symlink: create the placeholder file and add an entry
 *    for the new link
 * b) create a hardlink: do the link.  If the target turns out to be a
 *    zero-length file whose dev+ino are in the symlink table, then add this
 *    path to the list of names for that link
 * c) perform deferred processing: for each entry, check each associated path:
 *    if it's a zero-length file with the correct dev+ino then recreate it as
 *    the specified symlink or hardlink to the first such
 */

struct slpath {
	char	*sp_path;
	struct	slpath *sp_next;
};
struct slinode {
	ino_t	sli_ino;
	char	*sli_value;
	struct	slpath sli_paths;
	struct	slinode *sli_fow;		/* hash table chain */
	dev_t	sli_dev;
	mode_t	sli_mode;
};

static struct slinode **slitab = NULL;

/*
 * sltab_start()
 *	create the hash table
 * Return:
 *	0 if the table and file was created ok, -1 otherwise
 */

int
sltab_start(void)
{

	if ((slitab = calloc(SL_TAB_SZ, sizeof *slitab)) == NULL) {
		syswarn(1, errno, "symlink table");
		return(-1);
	}

	return(0);
}

/*
 * sltab_add_sym()
 *	Create the placeholder and tracking info for an escaping symlink.
 * Return:
 *	0 on success, -1 otherwise
 */

int
sltab_add_sym(const char *path0, const char *value0, mode_t mode)
{
	struct stat sb;
	struct slinode *s;
	struct slpath *p;
	char *path, *value;
	u_int indx;
	int fd;

	/* create the placeholder */
	fd = open(path0, O_WRONLY | O_CREAT | O_EXCL | O_CLOEXEC, 0600);
	if (fd == -1)
		return (-1);
	if (fstat(fd, &sb) == -1) {
		unlink(path0);
		close(fd);
		return (-1);
	}
	close(fd);

	if (havechd && *path0 != '/') {
		if ((path = realpath(path0, NULL)) == NULL) {
			syswarn(1, errno, "Cannot canonicalize %s", path0);
			unlink(path0);
			return (-1);
		}
	} else if ((path = strdup(path0)) == NULL) {
		syswarn(1, errno, "defered symlink path");
		unlink(path0);
		return (-1);
	}
	if ((value = strdup(value0)) == NULL) {
		syswarn(1, errno, "defered symlink value");
		unlink(path);
		free(path);
		return (-1);
	}

	/* now check the hash table for conflicting entry */
	indx = (sb.st_ino ^ sb.st_dev) % SL_TAB_SZ;
	for (s = slitab[indx]; s != NULL; s = s->sli_fow) {
		if (s->sli_ino != sb.st_ino || s->sli_dev != sb.st_dev)
			continue;

		/*
		 * One of our placeholders got removed behind our back and
		 * we've reused the inode.  Weird, but clean up the mess.
		 */
		free(s->sli_value);
		free(s->sli_paths.sp_path);
		p = s->sli_paths.sp_next;
		while (p != NULL) {
			struct slpath *next_p = p->sp_next;

			free(p->sp_path);
			free(p);
			p = next_p;
		}
		goto set_value;
	}

	/* Normal case: create a new node */
	if ((s = malloc(sizeof *s)) == NULL) {
		syswarn(1, errno, "defered symlink");
		unlink(path);
		free(path);
		free(value);
		return (-1);
	}
	s->sli_ino = sb.st_ino;
	s->sli_dev = sb.st_dev;
	s->sli_fow = slitab[indx];
	slitab[indx] = s;

set_value:
	s->sli_paths.sp_path = path;
	s->sli_paths.sp_next = NULL;
	s->sli_value = value;
	s->sli_mode = mode;
	return (0);
}

/*
 * sltab_add_link()
 *	A hardlink was created; if it looks like a placeholder, handle the
 *	tracking.
 * Return:
 *	0 if things are ok, -1 if something went wrong
 */

int
sltab_add_link(const char *path, const struct stat *sb)
{
	struct slinode *s;
	struct slpath *p;
	u_int indx;

	if (!S_ISREG(sb->st_mode) || sb->st_size != 0)
		return (1);

	/* find the hash table entry for this hardlink */
	indx = (sb->st_ino ^ sb->st_dev) % SL_TAB_SZ;
	for (s = slitab[indx]; s != NULL; s = s->sli_fow) {
		if (s->sli_ino != sb->st_ino || s->sli_dev != sb->st_dev)
			continue;

		if ((p = malloc(sizeof *p)) == NULL) {
			syswarn(1, errno, "deferred symlink hardlink");
			return (-1);
		}
		if (havechd && *path != '/') {
			if ((p->sp_path = realpath(path, NULL)) == NULL) {
				syswarn(1, errno, "Cannot canonicalize %s",
				    path);
				free(p);
				return (-1);
			}
		} else if ((p->sp_path = strdup(path)) == NULL) {
			syswarn(1, errno, "defered symlink hardlink path");
			free(p);
			return (-1);
		}

		/* link it in */
		p->sp_next = s->sli_paths.sp_next;
		s->sli_paths.sp_next = p;
		return (0);
	}

	/* not found */
	return (1);
}


static int
sltab_process_one(struct slinode *s, struct slpath *p, const char *first,
    int in_sig)
{
	struct stat sb;
	char *path = p->sp_path;
	mode_t mode;
	int err;

	/*
	 * is it the expected placeholder?  This can fail legimately
	 * if the archive overwrote the link with another, later entry,
	 * so don't warn.
	 */
	if (stat(path, &sb) != 0 || !S_ISREG(sb.st_mode) || sb.st_size != 0 ||
	    sb.st_ino != s->sli_ino || sb.st_dev != s->sli_dev)
		return (0);

	if (unlink(path) && errno != ENOENT) {
		if (!in_sig)
			syswarn(1, errno, "deferred symlink removal");
		return (0);
	}

	err = 0;
	if (first != NULL) {
		/* add another hardlink to the existing symlink */
		if (linkat(AT_FDCWD, first, AT_FDCWD, path, 0) == 0)
			return (0);

		/*
		 * Couldn't hardlink the symlink for some reason, so we'll
		 * try creating it as its own symlink, but save the error
		 * for reporting if that fails.
		 */
		err = errno;
	}

	if (symlink(s->sli_value, path)) {
		if (!in_sig) {
			const char *qualifier = "";
			if (err)
				qualifier = " hardlink";
			else
				err = errno;

			syswarn(1, err, "deferred symlink%s: %s",
			    qualifier, path);
		}
		return (0);
	}

	/* success, so set the id, mode, and times */
	mode = s->sli_mode;
	if (pids) {
		/* if can't set the ids, force the set[ug]id bits off */
		if (set_ids(path, sb.st_uid, sb.st_gid))
			mode &= ~(SETBITS);
	}

	if (pmode)
		set_pmode(path, mode);

	if (patime || pmtime)
		set_ftime(path, &sb.st_mtim, &sb.st_atim, 0);

	/*
	 * If we tried to link to first but failed, then this new symlink
	 * might be a better one to try in the future.  Guess from the errno.
	 */
	if (err == 0 || err == ENOENT || err == EMLINK || err == EOPNOTSUPP)
		return (1);
	return (0);
}

/*
 * sltab_process()
 *	Do all the delayed process for escape symlinks
 */

void
sltab_process(int in_sig)
{
	struct slinode *s;
	struct slpath *p;
	char *first;
	u_int indx;

	if (slitab == NULL)
		return;

	/* walk across the entire hash table */
	for (indx = 0; indx < SL_TAB_SZ; indx++) {
		while ((s = slitab[indx]) != NULL) {
			/* pop this entry */
			slitab[indx] = s->sli_fow;

			first = NULL;
			p = &s->sli_paths;
			while (1) {
				struct slpath *next_p;

				if (sltab_process_one(s, p, first, in_sig)) {
					if (!in_sig)
						free(first);
					first = p->sp_path;
				} else if (!in_sig)
					free(p->sp_path);

				if ((next_p = p->sp_next) == NULL)
					break;
				*p = *next_p;
				if (!in_sig)
					free(next_p);
			}
			if (!in_sig) {
				free(first);
				free(s->sli_value);
				free(s);
			}
		}
	}
	if (!in_sig)
		free(slitab);
	slitab = NULL;
}


/*
d490 1
a490 1
	if ((ntab = calloc(N_TAB_SZ, sizeof(NAMT *))) == NULL) {
d540 1
a540 1
			free(pt->nname);
d552 1
a552 1
	if ((pt = malloc(sizeof(NAMT))) != NULL) {
d559 1
a559 1
			free(pt->oname);
d561 1
a561 1
		free(pt);
d609 1
a611 1
#ifndef NOCPIO
a651 2
static DEVT *chk_dev(dev_t, int);

d664 1
a664 1
	if ((dtab = calloc(D_TAB_SZ, sizeof(DEVT *))) == NULL) {
d737 1
a737 1
	if ((pt = malloc(sizeof(DEVT))) == NULL) {
d829 1
a829 1
			if ((dpt = malloc(sizeof(DLIST))) == NULL)
d856 1
a856 1
	if ((lastdev <= 0) || ((dpt = malloc(sizeof(DLIST))) == NULL))
a876 1
#endif /* NOCPIO */
d907 1
a907 1
	if ((atab = calloc(A_TAB_SZ, sizeof(ATDIR *))) == NULL) {
d943 1
a943 1
			set_attr(&pt->ft, 1, 0, 0, 0);
d954 1
a954 2
add_atdir(char *fname, dev_t dev, ino_t ino, const struct timespec *mtimp,
    const struct timespec *atimp)
a956 1
	sigset_t allsigs, savedsigs;
d972 1
a972 1
			if ((pt->ft.ft_ino == ino) && (pt->ft.ft_dev == dev))
d987 6
a992 8
	sigfillset(&allsigs);
	sigprocmask(SIG_BLOCK, &allsigs, &savedsigs);
	if ((pt = malloc(sizeof *pt)) != NULL) {
		if ((pt->ft.ft_name = strdup(fname)) != NULL) {
			pt->ft.ft_dev = dev;
			pt->ft.ft_ino = ino;
			pt->ft.ft_mtim = *mtimp;
			pt->ft.ft_atim = *atimp;
a994 1
			sigprocmask(SIG_SETMASK, &savedsigs, NULL);
d997 1
a997 1
		free(pt);
a999 1
	sigprocmask(SIG_SETMASK, &savedsigs, NULL);
d1001 1
d1016 1
a1016 1
do_atdir(const char *name, dev_t dev, ino_t ino)
a1019 1
	sigset_t allsigs, savedsigs;
d1033 1
a1033 1
		if ((pt->ft.ft_ino == ino) && (pt->ft.ft_dev == dev))
d1045 1
a1045 2
	if (pt == NULL || pt->ft.ft_name == NULL ||
	    strcmp(name, pt->ft.ft_name) == 0)
d1049 1
a1049 1
	 * found it. set the times and remove the entry from the table.
a1050 3
	set_attr(&pt->ft, 1, 0, 0, 0);
	sigfillset(&allsigs);
	sigprocmask(SIG_BLOCK, &allsigs, &savedsigs);
d1052 4
a1055 3
	sigprocmask(SIG_SETMASK, &savedsigs, NULL);
	free(pt->ft.ft_name);
	free(pt);
d1074 6
a1079 2
 * reverse order as entries were added from root to leaf: to restore atime
 * properly, we must go backwards.
d1097 1
a1097 1
	if ((dirp = reallocarray(NULL, dirsize, sizeof(DIRDATA))) == NULL) {
d1121 1
a1121 2
	sigset_t allsigs, savedsigs;
	char realname[PATH_MAX], *rp;
d1134 1
a1134 1
		dblk = reallocarray(dirp, dirsize, 2 * sizeof(DIRDATA));
a1139 1
		sigprocmask(SIG_BLOCK, &allsigs, &savedsigs);
a1141 1
		sigprocmask(SIG_SETMASK, &savedsigs, NULL);
d1144 1
a1144 1
	if ((dblk->ft.ft_name = strdup(name)) == NULL) {
d1149 3
a1151 5
	dblk->ft.ft_mtim = psb->st_mtim;
	dblk->ft.ft_atim = psb->st_atim;
	dblk->ft.ft_ino = psb->st_ino;
	dblk->ft.ft_dev = psb->st_dev;
	dblk->mode = psb->st_mode & ABITS;
a1152 1
	sigprocmask(SIG_BLOCK, &allsigs, &savedsigs);
a1153 30
	sigprocmask(SIG_SETMASK, &savedsigs, NULL);
}

/*
 * delete_dir()
 *	When we rmdir a directory, we may want to make sure we don't
 *	later warn about being unable to set its mode and times.
 */

void
delete_dir(dev_t dev, ino_t ino)
{
	DIRDATA *dblk;
	char *name;
	size_t i;

	if (dirp == NULL)
		return;
	for (i = 0; i < dircnt; i++) {
		dblk = &dirp[i];

		if (dblk->ft.ft_name == NULL)
			continue;
		if (dblk->ft.ft_dev == dev && dblk->ft.ft_ino == ino) {
			name = dblk->ft.ft_name;
			dblk->ft.ft_name = NULL;
			free(name);
			break;
		}
	}
d1157 1
a1157 1
 * proc_dir(int in_sig)
d1159 1
a1159 2
 *	by pax.  If in_sig is set, we're in a signal handler and can't
 *	free stuff.
d1163 1
a1163 1
proc_dir(int in_sig)
d1166 1
a1166 1
	size_t cnt;
d1174 1
a1174 9
	while (cnt-- > 0) {
		dblk = &dirp[cnt];
		/*
		 * If we remove a directory we created, we replace the
		 * ft_name with NULL.  Ignore those.
		 */
		if (dblk->ft.ft_name == NULL)
			continue;

d1179 6
a1184 4
		set_attr(&dblk->ft, 0, dblk->mode, pmode || dblk->frc_mode,
		    in_sig);
		if (!in_sig)
			free(dblk->ft.ft_name);
d1187 1
a1187 2
	if (!in_sig)
		free(dirp);
d1211 1
a1211 1
st_hash(const char *name, int len, int tabsz)
d1213 1
a1213 1
	const char *pt;
d1215 1
a1215 1
	const char *end;
@


1.1.1.6
log
@revert the import; well just backport the CVE fixes, for now 
@
text
@d1 1
a1 1
/*	$OpenBSD: tables.c,v 1.26 2009/10/27 23:59:22 deraadt Exp $	*/
d40 3
a42 2
#include <sys/param.h>
#include <sys/fcntl.h>
d74 1
a74 1
static long dircnt = 0;		/* entries in dir time/mode storage */
a76 2
static DEVT *chk_dev(dev_t, int);

d105 1
a105 1
 	if ((ltab = (HRDLNK **)calloc(L_TAB_SZ, sizeof(HRDLNK *))) == NULL) {
d179 2
a180 2
				(void)free((char *)pt->name);
				(void)free((char *)pt);
d190 1
a190 1
	if ((pt = (HRDLNK *)malloc(sizeof(HRDLNK))) != NULL) {
d199 1
a199 1
		(void)free((char *)pt);
d226 1
a226 1
	    (arcn->type == PAX_HLK) || (arcn->type == PAX_HRG))
d255 2
a256 2
	(void)free((char *)pt->name);
	(void)free((char *)pt);
d289 2
a290 2
			(void)free((char *)ppt->name);
			(void)free((char *)ppt);
a292 1
	return;
d310 1
a310 1
 * this table, fragmentation of the scratch file is never a issue. Lookups 
d332 1
a332 1
 	if ((ftab = (FTM **)calloc(F_TAB_SZ, sizeof(FTM *))) == NULL) {
d423 1
a423 1
			if (arcn->sb.st_mtime > pt->mtime) {
d427 1
a427 1
				pt->mtime = arcn->sb.st_mtime;
d440 1
a440 1
	if ((pt = (FTM *)malloc(sizeof(FTM))) != NULL) {
d447 1
a447 1
				pt->mtime = arcn->sb.st_mtime;
d460 1
a460 1
		(void)free((char *)pt);
d465 337
d825 1
a825 1
 	if ((ntab = (NAMT **)calloc(N_TAB_SZ, sizeof(NAMT *))) == NULL) {
d875 1
a875 1
			(void)free((char *)pt->nname);
d887 1
a887 1
	if ((pt = (NAMT *)malloc(sizeof(NAMT))) != NULL) {
d894 1
a894 1
			(void)free((char *)pt->oname);
d896 1
a896 1
		(void)free((char *)pt);
a943 1
	return;
d946 1
d987 2
d1001 1
a1001 1
 	if ((dtab = (DEVT **)calloc(D_TAB_SZ, sizeof(DEVT *))) == NULL) {
d1074 1
a1074 1
	if ((pt = (DEVT *)malloc(sizeof(DEVT))) == NULL) {
d1166 1
a1166 1
			if ((dpt = (DLIST *)malloc(sizeof(DLIST))) == NULL)
d1193 1
a1193 1
	if ((lastdev <= 0) || ((dpt = (DLIST *)malloc(sizeof(DLIST))) == NULL))
d1214 1
d1245 1
a1245 1
 	if ((atab = (ATDIR **)calloc(A_TAB_SZ, sizeof(ATDIR *))) == NULL) {
d1281 1
a1281 1
			set_ftime(pt->name, pt->mtime, pt->atime, 1);
d1292 2
a1293 1
add_atdir(char *fname, dev_t dev, ino_t ino, time_t mtime, time_t atime)
d1296 1
d1312 1
a1312 1
			if ((pt->ino == ino) && (pt->dev == dev))
d1327 8
a1334 6
	if ((pt = (ATDIR *)malloc(sizeof(ATDIR))) != NULL) {
		if ((pt->name = strdup(fname)) != NULL) {
			pt->dev = dev;
			pt->ino = ino;
			pt->mtime = mtime;
			pt->atime = atime;
d1337 1
d1340 1
a1340 1
		(void)free((char *)pt);
d1343 1
a1344 1
	return;
d1359 1
a1359 1
get_atdir(dev_t dev, ino_t ino, time_t *mtime, time_t *atime)
d1363 1
d1377 1
a1377 1
		if ((pt->ino == ino) && (pt->dev == dev))
d1389 2
a1390 1
	if (pt == NULL)
d1394 1
a1394 1
	 * found it. return the times and remove the entry from the table.
d1396 3
d1400 3
a1402 4
	*mtime = pt->mtime;
	*atime = pt->atime;
	(void)free((char *)pt->name);
	(void)free((char *)pt);
d1421 2
a1422 6
 * reverse order as entries were added to the data file from root to leaf. To
 * restore atime properly, we must go backwards. The data file consists of
 * records with two parts, the file name followed by a DIRDATA trailer. The
 * fixed sized trailer contains the size of the name plus the off_t location in
 * the file. To restore we work backwards through the file reading the trailer
 * then the file name.
d1440 1
a1440 1
	if ((dirp = calloc(dirsize, sizeof(DIRDATA))) == NULL) {
d1464 2
a1465 1
	char realname[MAXPATHLEN], *rp;
d1478 1
a1478 1
		dblk = realloc(dirp, 2 * dirsize * sizeof(DIRDATA));
d1484 1
d1487 1
d1490 1
a1490 1
	if ((dblk->name = strdup(name)) == NULL) {
d1495 5
a1499 3
	dblk->mode = psb->st_mode & 0xffff;
	dblk->mtime = psb->st_mtime;
	dblk->atime = psb->st_atime;
d1501 1
d1503 30
d1536 1
a1536 1
 * proc_dir()
d1538 2
a1539 1
 *	by pax
d1543 1
a1543 1
proc_dir(void)
d1546 1
a1546 1
	long cnt;
d1554 9
a1562 1
	while (--cnt >= 0) {
d1567 4
a1570 6
		dblk = &dirp[cnt];
		if (pmode || dblk->frc_mode)
			set_pmode(dblk->name, dblk->mode);
		if (patime || pmtime)
			set_ftime(dblk->name, dblk->mtime, dblk->atime, 0);
		free(dblk->name);
d1573 2
a1574 1
	free(dirp);
d1598 1
a1598 1
st_hash(char *name, int len, int tabsz)
d1600 1
a1600 1
	char *pt;
d1602 1
a1602 1
	char *end;
@


1.1.1.7
log
@backport OpenBSD pax erratum, more specifically:

 directory bug, symlinks with -C bug
 escaping with .. and symlinks
 tar without -P
 validate directories touched in the cleanup phase
@
text
@d41 1
a41 1
#include <fcntl.h>
a466 337
 * escaping (absolute or w/"..") symlink table routines
 *
 * By default, an archive shouldn't be able extract to outside of the
 * current directory.  What should we do if the archive contains a symlink
 * whose value is either absolute or contains ".." components?  What we'll
 * do is initially create the path as an empty file (to block attempts to
 * reference _through_ it) and instead record its path and desired
 * final value and mode.  Then once all the other archive
 * members are created (but before the pass to set timestamps on
 * directories) we'll process those records, replacing the placeholder with
 * the correct symlink and setting them to the correct mode, owner, group,
 * and timestamps.
 *
 * Note: we also need to handle hardlinks to symlinks (barf) as well as
 * hardlinks whose target is replaced by a later entry in the archive (barf^2).
 *
 * So we track things by dev+ino of the placeholder file, associating with
 * that the value and mode of the final symlink and a list of paths that
 * should all be hardlinks of that.  We'll 'store' the symlink's desired
 * timestamps, owner, and group by setting them on the placeholder file.
 *
 * The operations are:
 * a) create an escaping symlink: create the placeholder file and add an entry
 *    for the new link
 * b) create a hardlink: do the link.  If the target turns out to be a
 *    zero-length file whose dev+ino are in the symlink table, then add this
 *    path to the list of names for that link
 * c) perform deferred processing: for each entry, check each associated path:
 *    if it's a zero-length file with the correct dev+ino then recreate it as
 *    the specified symlink or hardlink to the first such
 */

struct slpath {
	char	*sp_path;
	struct	slpath *sp_next;
};
struct slinode {
	ino_t	sli_ino;
	char	*sli_value;
	struct	slpath sli_paths;
	struct	slinode *sli_fow;		/* hash table chain */
	dev_t	sli_dev;
	mode_t	sli_mode;
};

static struct slinode **slitab = NULL;

/*
 * sltab_start()
 *	create the hash table
 * Return:
 *	0 if the table and file was created ok, -1 otherwise
 */

int
sltab_start(void)
{

	if ((slitab = calloc(SL_TAB_SZ, sizeof *slitab)) == NULL) {
		syswarn(1, errno, "symlink table");
		return(-1);
	}

	return(0);
}

/*
 * sltab_add_sym()
 *	Create the placeholder and tracking info for an escaping symlink.
 * Return:
 *	0 on success, -1 otherwise
 */

int
sltab_add_sym(const char *path0, const char *value0, mode_t mode)
{
	struct stat sb;
	struct slinode *s;
	struct slpath *p;
	char *path, *value;
	u_int indx;
	int fd;

	/* create the placeholder */
	fd = open(path0, O_WRONLY | O_CREAT | O_EXCL | O_CLOEXEC, 0600);
	if (fd == -1)
		return (-1);
	if (fstat(fd, &sb) == -1) {
		unlink(path0);
		close(fd);
		return (-1);
	}
	close(fd);

	if (havechd && *path0 != '/') {
		if ((path = realpath(path0, NULL)) == NULL) {
			syswarn(1, errno, "Cannot canonicalize %s", path0);
			unlink(path0);
			return (-1);
		}
	} else if ((path = strdup(path0)) == NULL) {
		syswarn(1, errno, "defered symlink path");
		unlink(path0);
		return (-1);
	}
	if ((value = strdup(value0)) == NULL) {
		syswarn(1, errno, "defered symlink value");
		unlink(path);
		free(path);
		return (-1);
	}

	/* now check the hash table for conflicting entry */
	indx = (sb.st_ino ^ sb.st_dev) % SL_TAB_SZ;
	for (s = slitab[indx]; s != NULL; s = s->sli_fow) {
		if (s->sli_ino != sb.st_ino || s->sli_dev != sb.st_dev)
			continue;

		/*
		 * One of our placeholders got removed behind our back and
		 * we've reused the inode.  Weird, but clean up the mess.
		 */
		free(s->sli_value);
		free(s->sli_paths.sp_path);
		p = s->sli_paths.sp_next;
		while (p != NULL) {
			struct slpath *next_p = p->sp_next;

			free(p->sp_path);
			free(p);
			p = next_p;
		}
		goto set_value;
	}

	/* Normal case: create a new node */
	if ((s = malloc(sizeof *s)) == NULL) {
		syswarn(1, errno, "defered symlink");
		unlink(path);
		free(path);
		free(value);
		return (-1);
	}
	s->sli_ino = sb.st_ino;
	s->sli_dev = sb.st_dev;
	s->sli_fow = slitab[indx];
	slitab[indx] = s;

set_value:
	s->sli_paths.sp_path = path;
	s->sli_paths.sp_next = NULL;
	s->sli_value = value;
	s->sli_mode = mode;
	return (0);
}

/*
 * sltab_add_link()
 *	A hardlink was created; if it looks like a placeholder, handle the
 *	tracking.
 * Return:
 *	0 if things are ok, -1 if something went wrong
 */

int
sltab_add_link(const char *path, const struct stat *sb)
{
	struct slinode *s;
	struct slpath *p;
	u_int indx;

	if (!S_ISREG(sb->st_mode) || sb->st_size != 0)
		return (1);

	/* find the hash table entry for this hardlink */
	indx = (sb->st_ino ^ sb->st_dev) % SL_TAB_SZ;
	for (s = slitab[indx]; s != NULL; s = s->sli_fow) {
		if (s->sli_ino != sb->st_ino || s->sli_dev != sb->st_dev)
			continue;

		if ((p = malloc(sizeof *p)) == NULL) {
			syswarn(1, errno, "deferred symlink hardlink");
			return (-1);
		}
		if (havechd && *path != '/') {
			if ((p->sp_path = realpath(path, NULL)) == NULL) {
				syswarn(1, errno, "Cannot canonicalize %s",
				    path);
				free(p);
				return (-1);
			}
		} else if ((p->sp_path = strdup(path)) == NULL) {
			syswarn(1, errno, "defered symlink hardlink path");
			free(p);
			return (-1);
		}

		/* link it in */
		p->sp_next = s->sli_paths.sp_next;
		s->sli_paths.sp_next = p;
		return (0);
	}

	/* not found */
	return (1);
}


static int
sltab_process_one(struct slinode *s, struct slpath *p, const char *first,
    int in_sig)
{
	struct stat sb;
	char *path = p->sp_path;
	mode_t mode;
	int err;

	/*
	 * is it the expected placeholder?  This can fail legimately
	 * if the archive overwrote the link with another, later entry,
	 * so don't warn.
	 */
	if (stat(path, &sb) != 0 || !S_ISREG(sb.st_mode) || sb.st_size != 0 ||
	    sb.st_ino != s->sli_ino || sb.st_dev != s->sli_dev)
		return (0);

	if (unlink(path) && errno != ENOENT) {
		if (!in_sig)
			syswarn(1, errno, "deferred symlink removal");
		return (0);
	}

	err = 0;
	if (first != NULL) {
		/* add another hardlink to the existing symlink */
		if (linkat(AT_FDCWD, first, AT_FDCWD, path, 0) == 0)
			return (0);

		/*
		 * Couldn't hardlink the symlink for some reason, so we'll
		 * try creating it as its own symlink, but save the error
		 * for reporting if that fails.
		 */
		err = errno;
	}

	if (symlink(s->sli_value, path)) {
		if (!in_sig) {
			const char *qualifier = "";
			if (err)
				qualifier = " hardlink";
			else
				err = errno;

			syswarn(1, err, "deferred symlink%s: %s",
			    qualifier, path);
		}
		return (0);
	}

	/* success, so set the id, mode, and times */
	mode = s->sli_mode;
	if (pids) {
		/* if can't set the ids, force the set[ug]id bits off */
		if (set_ids(path, sb.st_uid, sb.st_gid))
			mode &= ~(SETBITS);
	}

	if (pmode)
		set_pmode(path, mode);

	if (patime || pmtime)
		set_ftime(path, sb.st_mtime, sb.st_atime, 0);

	/*
	 * If we tried to link to first but failed, then this new symlink
	 * might be a better one to try in the future.  Guess from the errno.
	 */
	if (err == 0 || err == ENOENT || err == EMLINK || err == EOPNOTSUPP)
		return (1);
	return (0);
}

/*
 * sltab_process()
 *	Do all the delayed process for escape symlinks
 */

void
sltab_process(int in_sig)
{
	struct slinode *s;
	struct slpath *p;
	char *first;
	u_int indx;

	if (slitab == NULL)
		return;

	/* walk across the entire hash table */
	for (indx = 0; indx < SL_TAB_SZ; indx++) {
		while ((s = slitab[indx]) != NULL) {
			/* pop this entry */
			slitab[indx] = s->sli_fow;

			first = NULL;
			p = &s->sli_paths;
			while (1) {
				struct slpath *next_p;

				if (sltab_process_one(s, p, first, in_sig)) {
					if (!in_sig)
						free(first);
					first = p->sp_path;
				} else if (!in_sig)
					free(p->sp_path);

				if ((next_p = p->sp_next) == NULL)
					break;
				*p = *next_p;
				if (!in_sig)
					free(next_p);
			}
			if (!in_sig) {
				free(first);
				free(s->sli_value);
				free(s);
			}
		}
	}
	if (!in_sig)
		free(slitab);
	slitab = NULL;
}


/*
d943 1
a943 1
			set_attr(&pt->ft, 1, 0, 0, 0);
d972 1
a972 1
			if ((pt->ft.ft_ino == ino) && (pt->ft.ft_dev == dev))
d987 6
a992 6
	if ((pt = malloc(sizeof *pt)) != NULL) {
		if ((pt->ft.ft_name = strdup(fname)) != NULL) {
			pt->ft.ft_dev = dev;
			pt->ft.ft_ino = ino;
			pt->ft.ft_mtime = mtime;
			pt->ft.ft_atime = atime;
d1016 1
a1016 1
do_atdir(const char *name, dev_t dev, ino_t ino)
d1033 1
a1033 1
		if ((pt->ft.ft_ino == ino) && (pt->ft.ft_dev == dev))
d1045 1
a1045 2
	if (pt == NULL || pt->ft.ft_name == NULL ||
	    strcmp(name, pt->ft.ft_name) == 0)
d1049 1
a1049 1
	 * found it. set the times and remove the entry from the table.
a1050 1
	set_attr(&pt->ft, 1, 0, 0, 0);
d1052 4
a1055 2
	free(pt->ft.ft_name);
	free(pt);
d1074 6
a1079 2
 * reverse order as entries were added from root to leaf: to restore atime
 * properly, we must go backwards.
d1144 1
a1144 1
	if ((dblk->ft.ft_name = strdup(name)) == NULL) {
d1149 3
a1151 5
	dblk->ft.ft_mtime = psb->st_mtime;
	dblk->ft.ft_atime = psb->st_atime;
	dblk->ft.ft_ino = psb->st_ino;
	dblk->ft.ft_dev = psb->st_dev;
	dblk->mode = psb->st_mode & ABITS;
a1156 29
 * delete_dir()
 *	When we rmdir a directory, we may want to make sure we don't
 *	later warn about being unable to set its mode and times.
 */

void
delete_dir(dev_t dev, ino_t ino)
{
	DIRDATA *dblk;
	char *name;
	size_t i;

	if (dirp == NULL)
		return;
	for (i = 0; i < dircnt; i++) {
		dblk = &dirp[i];

		if (dblk->ft.ft_name == NULL)
			continue;
		if (dblk->ft.ft_dev == dev && dblk->ft.ft_ino == ino) {
			name = dblk->ft.ft_name;
			dblk->ft.ft_name = NULL;
			free(name);
			break;
		}
	}
}

/*
a1174 8
		dblk = &dirp[cnt];
		/*
		 * If we remove a directory we created, we replace the
		 * ft_name with NULL.  Ignore those.
		 */
		if (dblk->ft.ft_name == NULL)
			continue;

d1179 6
a1184 3
		set_attr(&dblk->ft, 0, dblk->mode, pmode || dblk->frc_mode,
		    /*in_sig*/ 0);
		free(dblk->ft.ft_name);
@


1.1.1.8
log
@merge what OpenBSD did between our last cherry-pick and today minus one commit

(Use the new libc uid_from_user() and gid_from_group() instead of
  the pax-specific functions in cache.c is ignored, for now)
@
text
@d1 1
a1 1
/*	$OpenBSD: tables.c,v 1.53 2017/09/16 07:42:34 otto Exp $	*/
a68 1
#ifndef NOCPIO
a69 1
#endif
d167 1
a167 1
			if ((size_t)arcn->nlen >= sizeof(arcn->name))
d912 1
a912 1
sub_name(char *oname, int *onamelen, int onamesize)
@


1.1.1.9
log
@Import latest OpenBSD paxtar, unmodified, into vendor branch
@
text
@d38 1
d40 1
a40 1
#include <errno.h>
a41 2
#include <limits.h>
#include <signal.h>
a42 1
#include <stdlib.h>
d45 2
a46 1

d48 1
a65 128
/*
 * data structures and constants used by the different databases kept by pax
 */

/*
 * Hash Table Sizes MUST BE PRIME, if set too small performance suffers.
 * Probably safe to expect 500000 inodes per tape. Assuming good key
 * distribution (inodes) chains of under 50 long (worst case) is ok.
 */
#define L_TAB_SZ	2503		/* hard link hash table size */
#define F_TAB_SZ	50503		/* file time hash table size */
#define N_TAB_SZ	541		/* interactive rename hash table */
#define D_TAB_SZ	317		/* unique device mapping table */
#define A_TAB_SZ	317		/* ftree dir access time reset table */
#define SL_TAB_SZ	317		/* escape symlink tables */
#define MAXKEYLEN	64		/* max number of chars for hash */
#define DIRP_SIZE	64		/* initial size of created dir table */

/*
 * file hard link structure (hashed by dev/ino and chained) used to find the
 * hard links in a file system or with some archive formats (cpio)
 */
typedef struct hrdlnk {
	ino_t		ino;	/* files inode number */
	char		*name;	/* name of first file seen with this ino/dev */
	dev_t		dev;	/* files device number */
	u_long		nlink;	/* expected link count */
	struct hrdlnk	*fow;
} HRDLNK;

/*
 * Archive write update file time table (the -u, -C flag), hashed by filename.
 * Filenames are stored in a scratch file at seek offset into the file. The
 * file time (mod time) and the file name length (for a quick check) are
 * stored in a hash table node. We were forced to use a scratch file because
 * with -u, the mtime for every node in the archive must always be available
 * to compare against (and this data can get REALLY large with big archives).
 * By being careful to read only when we have a good chance of a match, the
 * performance loss is not measurable (and the size of the archive we can
 * handle is greatly increased).
 */
typedef struct ftm {
	off_t		seek;		/* location in scratch file */
	struct timespec	mtim;		/* files last modification time */
	struct ftm	*fow;
	int		namelen;	/* file name length */
} FTM;

/*
 * Interactive rename table (-i flag), hashed by orig filename.
 * We assume this will not be a large table as this mapping data can only be
 * obtained through interactive input by the user. Nobody is going to type in
 * changes for 500000 files? We use chaining to resolve collisions.
 */

typedef struct namt {
	char		*oname;		/* old name */
	char		*nname;		/* new name typed in by the user */
	struct namt	*fow;
} NAMT;

/*
 * Unique device mapping tables. Some protocols (e.g. cpio) require that the
 * <c_dev,c_ino> pair will uniquely identify a file in an archive unless they
 * are links to the same file. Appending to archives can break this. For those
 * protocols that have this requirement we map c_dev to a unique value not seen
 * in the archive when we append. We also try to handle inode truncation with
 * this table. (When the inode field in the archive header are too small, we
 * remap the dev on writes to remove accidental collisions).
 *
 * The list is hashed by device number using chain collision resolution. Off of
 * each DEVT are linked the various remaps for this device based on those bits
 * in the inode which were truncated. For example if we are just remapping to
 * avoid a device number during an update append, off the DEVT we would have
 * only a single DLIST that has a truncation id of 0 (no inode bits were
 * stripped for this device so far). When we spot inode truncation we create
 * a new mapping based on the set of bits in the inode which were stripped off.
 * so if the top four bits of the inode are stripped and they have a pattern of
 * 0110...... (where . are those bits not truncated) we would have a mapping
 * assigned for all inodes that has the same 0110.... pattern (with this dev
 * number of course). This keeps the mapping sparse and should be able to store
 * close to the limit of files which can be represented by the optimal
 * combination of dev and inode bits, and without creating a fouled up archive.
 * Note we also remap truncated devs in the same way (an exercise for the
 * dedicated reader; always wanted to say that...:)
 */

typedef struct devt {
	dev_t		dev;	/* the orig device number we now have to map */
	struct devt	*fow;	/* new device map list */
	struct dlist	*list;	/* map list based on inode truncation bits */
} DEVT;

typedef struct dlist {
	ino_t trunc_bits;	/* truncation pattern for a specific map */
	dev_t dev;		/* the new device id we use */
	struct dlist *fow;
} DLIST;

/*
 * ftree directory access time reset table. When we are done with a
 * subtree we reset the access and mod time of the directory when the tflag is
 * set. Not really explicitly specified in the pax spec, but easy and fast to
 * do (and this may have even been intended in the spec, it is not clear).
 * table is hashed by inode with chaining.
 */

typedef struct atdir {
	struct file_times ft;
	struct atdir *fow;
} ATDIR;

/*
 * created directory time and mode storage entry. After pax is finished during
 * extraction or copy, we must reset directory access modes and times that
 * may have been modified after creation (they no longer have the specified
 * times and/or modes). We must reset time in the reverse order of creation,
 * because entries are added  from the top of the file tree to the bottom.
 * We MUST reset times from leaf to root (it will not work the other
 * direction).
 */

typedef struct dirdata {
	struct file_times ft;
	u_int16_t mode;		/* file mode to restore */
	u_int16_t frc_mode;	/* do we force mode settings? */
} DIRDATA;

d75 1
a75 1
static size_t dircnt = 0;	/* entries in dir time/mode storage */
d78 2
d108 1
a108 1
	if ((ltab = calloc(L_TAB_SZ, sizeof(HRDLNK *))) == NULL) {
d182 2
a183 2
				free(pt->name);
				free(pt);
d193 1
a193 1
	if ((pt = malloc(sizeof(HRDLNK))) != NULL) {
d202 1
a202 1
		free(pt);
d229 1
a229 1
	    PAX_IS_HARDLINK(arcn->type))
d258 2
a259 2
	free(pt->name);
	free(pt);
d292 2
a293 2
			free(ppt->name);
			free(ppt);
d296 1
d314 1
a314 1
 * this table, fragmentation of the scratch file is never a issue. Lookups
d336 1
a336 1
	if ((ftab = calloc(F_TAB_SZ, sizeof(FTM *))) == NULL) {
d427 1
a427 1
			if (timespeccmp(&arcn->sb.st_mtim, &pt->mtim, >)) {
d431 1
a431 1
				pt->mtim = arcn->sb.st_mtim;
d444 1
a444 1
	if ((pt = malloc(sizeof(FTM))) != NULL) {
d449 1
a449 1
		if ((pt->seek = lseek(ffd, 0, SEEK_END)) >= 0) {
d451 1
a451 1
				pt->mtim = arcn->sb.st_mtim;
d464 1
a464 1
		free(pt);
d741 1
a741 1
		set_ftime(path, &sb.st_mtim, &sb.st_atim, 0);
d829 1
a829 1
	if ((ntab = calloc(N_TAB_SZ, sizeof(NAMT *))) == NULL) {
d879 1
a879 1
			free(pt->nname);
d891 1
a891 1
	if ((pt = malloc(sizeof(NAMT))) != NULL) {
d898 1
a898 1
			free(pt->oname);
d900 1
a900 1
		free(pt);
d948 1
a950 1
#ifndef NOCPIO
a990 2
static DEVT *chk_dev(dev_t, int);

d1003 1
a1003 1
	if ((dtab = calloc(D_TAB_SZ, sizeof(DEVT *))) == NULL) {
d1076 1
a1076 1
	if ((pt = malloc(sizeof(DEVT))) == NULL) {
d1168 1
a1168 1
			if ((dpt = malloc(sizeof(DLIST))) == NULL)
d1195 1
a1195 1
	if ((lastdev <= 0) || ((dpt = malloc(sizeof(DLIST))) == NULL))
a1215 1
#endif /* NOCPIO */
d1246 1
a1246 1
	if ((atab = calloc(A_TAB_SZ, sizeof(ATDIR *))) == NULL) {
d1293 1
a1293 2
add_atdir(char *fname, dev_t dev, ino_t ino, const struct timespec *mtimp,
    const struct timespec *atimp)
a1295 1
	sigset_t allsigs, savedsigs;
a1325 2
	sigfillset(&allsigs);
	sigprocmask(SIG_BLOCK, &allsigs, &savedsigs);
d1330 2
a1331 2
			pt->ft.ft_mtim = *mtimp;
			pt->ft.ft_atim = *atimp;
a1333 1
			sigprocmask(SIG_SETMASK, &savedsigs, NULL);
d1336 1
a1336 1
		free(pt);
a1338 1
	sigprocmask(SIG_SETMASK, &savedsigs, NULL);
d1340 1
a1358 1
	sigset_t allsigs, savedsigs;
a1391 2
	sigfillset(&allsigs);
	sigprocmask(SIG_BLOCK, &allsigs, &savedsigs);
a1392 1
	sigprocmask(SIG_SETMASK, &savedsigs, NULL);
d1432 1
a1432 1
	if ((dirp = reallocarray(NULL, dirsize, sizeof(DIRDATA))) == NULL) {
d1456 1
a1456 2
	sigset_t allsigs, savedsigs;
	char realname[PATH_MAX], *rp;
d1469 1
a1469 1
		dblk = reallocarray(dirp, dirsize * 2, sizeof(DIRDATA));
a1474 1
		sigprocmask(SIG_BLOCK, &allsigs, &savedsigs);
a1476 1
		sigprocmask(SIG_SETMASK, &savedsigs, NULL);
d1484 2
a1485 2
	dblk->ft.ft_mtim = psb->st_mtim;
	dblk->ft.ft_atim = psb->st_atim;
a1489 1
	sigprocmask(SIG_BLOCK, &allsigs, &savedsigs);
a1490 1
	sigprocmask(SIG_SETMASK, &savedsigs, NULL);
d1523 1
a1523 1
 * proc_dir(int in_sig)
d1525 1
a1525 2
 *	by pax.  If in_sig is set, we're in a signal handler and can't
 *	free stuff.
d1529 1
a1529 1
proc_dir(int in_sig)
d1532 1
a1532 1
	size_t cnt;
d1540 1
a1540 1
	while (cnt-- > 0) {
d1554 2
a1555 3
		    in_sig);
		if (!in_sig)
			free(dblk->ft.ft_name);
d1558 1
a1558 2
	if (!in_sig)
		free(dirp);
d1582 1
a1582 1
st_hash(const char *name, int len, int tabsz)
d1584 1
a1584 1
	const char *pt;
d1586 1
a1586 1
	const char *end;
@


1.1.1.9.2.1
log
@Wrangle the OpenBSD branch into shape as starting point:

 Revert Use the new libc uid_from_user() and gid_from_group()
  instead of the pax-specific functions in cache.c (revisit later)
 fix MAX_TIME_T (plain wrong), mirtoconf later
 drop all NOCPIO
 Revert Replace name_{uid,gid}() with the libc routines
  user_from_uid() and group_from_gid()
@
text
@d197 1
d199 1
d1075 1
d1343 1
@


1.1.1.9.2.2
log
@normalise whitespace at EOL, EOF, adjacent newlines
@
text
@d799 1
d927 1
d1377 1
@


1.1.1.9.2.3
log
@extremely rudimentary conversion to mirtoconf, doesnt even build yet
@
text
@a45 3
#if HAVE_STRINGS_H
#include <strings.h>
#endif
d190 2
a191 2
	uint16_t mode;		/* file mode to restore */
	uint16_t frc_mode;	/* do we force mode settings? */
d256 1
a256 1
	unsigned int indx;
d345 1
a345 1
	unsigned int indx;
d496 1
a496 1
	unsigned int indx;
d672 1
a672 1
	unsigned int indx;
d761 1
a761 1
	unsigned int indx;
d885 1
a885 1
	unsigned int indx;
d970 1
a970 1
	unsigned int indx;
d1038 1
a1038 1
	unsigned int indx;
d1167 1
a1167 1
	unsigned int indx;
d1419 1
a1419 1
	unsigned int indx;
d1486 1
a1486 1
	unsigned int indx;
d1719 1
a1719 1
unsigned int
d1726 1
a1726 1
	unsigned int key = 0;
d1729 1
a1729 1
	unsigned int val;
d1743 2
a1744 2
	 * calculate the number of unsigned int size steps in the string
	 * and if there is a runt to deal with
d1746 2
a1747 2
	steps = len / sizeof(unsigned int);
	res = len % sizeof(unsigned int);
d1755 1
a1755 1
		end = pt + sizeof(unsigned int);
@


1.1.1.9.2.4
log
@do the cs
@
text
@d89 1
a89 1
 * hard links in a filesystem or with some archive formats (cpio)
@


1.1.1.9.2.5
log
@shove stuff into same-looking structures
@
text
@d111 2
a113 11
	off_t		seek;		/* location in scratch file */
	struct {
#if HAVE_ST_MTIM
		struct timespec st_mtim;
#else
		time_t st_mtime;
#if HAVE_ST_MTIMENSEC
		long st_mtimensec;
#endif
#endif
	} sb;				/* files last modification time */
d553 1
a553 1
			if (st_mtim_cmp(&arcn->sb, &pt->sb, >)) {
d557 1
a557 8
#if HAVE_ST_MTIM
				pt->sb.st_mtim = arcn->sb.st_mtim;
#else
				pt->sb.st_mtime = arcn->sb.st_mtime;
#if HAVE_ST_MTIMENSEC
				pt->sb.st_mtimensec = arcn->sb.st_mtimensec;
#endif
#endif
d577 1
a577 8
#if HAVE_ST_MTIM
				pt->sb.st_mtim = arcn->sb.st_mtim;
#else
				pt->sb.st_mtime = arcn->sb.st_mtime;
#if HAVE_ST_MTIMENSEC
				pt->sb.st_mtimensec = arcn->sb.st_mtimensec;
#endif
#endif
d1458 2
a1459 2
			pt->ft.sb.st_mtim = *mtimp;
			pt->ft.sb.st_atim = *atimp;
d1620 2
a1621 2
	dblk->ft.sb.st_mtim = psb->st_mtim;
	dblk->ft.sb.st_atim = psb->st_atim;
@


1.1.1.9.2.6
log
@use generic macros, to compensate a bit for this insanity
@
text
@d562 1
a562 1
			if (st_timecmp(m, &arcn->sb, &pt->sb, >)) {
@


1.1.1.9.2.7
log
@another macro to fight this Irrsinn
@
text
@d566 8
a573 1
				st_timecpy(m, &pt->sb, &arcn->sb);
@


1.1.1.9.2.8
log
@solve one of the two API issues
@
text
@d1433 2
a1434 1
add_atdir(const char *fname, const struct stat *sbp)
d1450 1
a1450 1
	indx = ((unsigned)sbp->st_ino) % A_TAB_SZ;
d1453 1
a1453 1
			if ((pt->ft.ft_ino == sbp->st_ino) && (pt->ft.ft_dev == sbp->st_dev))
d1472 4
a1475 4
			pt->ft.ft_dev = sbp->st_dev;
			pt->ft.ft_ino = sbp->st_ino;
			st_timecpy(m, &pt->ft.sb, sbp);
			st_timecpy(a, &pt->ft.sb, sbp);
@


1.1.1.9.2.9
log
@and the other half, modulo whatll be yet merged anyway
@
text
@d882 1
a882 1
		set_ftime(path, &sb, 0);
@


1.1.1.9.2.10
log
@do the fs
@
text
@d707 1
a707 1
			syswarn(1, errno, "Cannot canonicalise %s", path0);
d797 1
a797 1
				syswarn(1, errno, "Cannot canonicalise %s",
d1612 1
a1612 1
			paxwarn(1, "Cannot canonicalise %s", name);
@


1.1.1.9.2.11
log
@some more tweaks
@
text
@a37 8
#if HAVE_BOTH_TIME_H
#include <sys/time.h>
#include <time.h>
#elif HAVE_SYS_TIME_H
#include <sys/time.h>
#elif HAVE_TIME_H
#include <time.h>
#endif
a51 1
#include "ftimes.h"
@


1.1.1.9.2.12
log
@pax.h, and apparently its now ok to assume to cast off_t to long long works
@
text
@d70 1
a70 1
 * do not survive after pax is finished). pax is required to handle very
d1559 1
a1559 1
 * pax requires that extracted directories, by default, have their access/mod
@


1.1.1.9.2.13
log
@two more
@
text
@a4 5
 * Copyright (c) 2005, 2012, 2015, 2016, 2018
 *	mirabilos <m@@mirbsd.org>
 * Copyright (c) 2011
 *	Svante Signell <svante.signell@@telia.com>
 *	Guillem Jover <guillem@@debian.org>
a214 11
/*
 * file hard link structure (hashed by dev/ino and chained) for anonymisation
 */
typedef struct hrdflnk {
	dev_t		dev;	/* files device number */
	ino_t		ino;	/* files inode number */
	u_long		nlink;	/* expected link count */
	ino_t		newi;	/* new inode number */
	struct hrdflnk	*fow;
} HRDFLNK;

a215 1
static HRDFLNK **fltab = NULL;	/* hard link table for anonymisation */
a224 2
static DEVT *chk_dev(dev_t, int);

d252 1
a252 1
		return (0);
d254 2
a255 2
		paxwarn(1, "Cannot allocate memory for %s", "hard link table");
		return (-1);
d257 1
a257 1
	return (0);
d350 2
a351 2
	paxwarn(1, "Out of memory for %s", "hard link table");
	return (-1);
d479 1
a479 1
		return (0);
d481 2
a482 2
		paxwarn(1, "Cannot allocate memory for %s", "file time table");
		return (-1);
d544 3
a546 3
					syswarn(1, errno, "Failed %s on %s",
					    "seek", "file time table");
					return (-1);
d549 3
a551 3
					syswarn(1, errno, "Failed %s on %s",
					    "read", "file time table");
					return (-1);
d595 8
a602 1
				st_timecpy(m, &pt->sb, &arcn->sb);
d608 1
a608 2
			syswarn(1, errno, "Failed %s on %s",
			    "write", "file time table");
d610 1
a610 2
			syswarn(1, errno, "Failed %s on %s",
			    "seek", "file time table");
d612 1
a612 1
		paxwarn(1, "Out of memory for %s", "file time table");
d704 1
a704 6
	fd = open(path0, O_WRONLY | O_CREAT |
#ifdef O_CLOEXEC
	    /* not strictly required, fd is closed a dozen lines below */
	    O_CLOEXEC |
#endif
	    O_EXCL, 0600);
d721 1
a721 1
		syswarn(1, errno, "deferred symlink path");
d726 1
a726 1
		syswarn(1, errno, "deferred symlink value");
d757 1
a757 1
		syswarn(1, errno, "deferred symlink");
d768 1
a768 1
 set_value:
d812 1
a812 1
			syswarn(1, errno, "deferred symlink hardlink path");
a852 1
#if HAVE_LINKAT
a862 3
#else
		err = EOPNOTSUPP;
#endif
d883 1
a883 1
		if (set_ids(path, sb.st_uid, sb.st_gid, 1))
d888 1
a888 1
		set_pmode(path, mode, 1);
d891 1
a891 1
		set_ftime(path, &sb, 0, 1);
d977 1
a977 1
		return (0);
d979 2
a980 2
		paxwarn(1, "Cannot allocate memory for %s", "interactive rename table");
		return (-1);
d982 1
a982 1
	return (0);
d1051 2
a1052 2
	paxwarn(1, "Out of memory for %s", "interactive rename table");
	return (-1);
d1139 2
d1152 1
a1152 1
		return (0);
d1154 2
a1155 2
		paxwarn(1, "Cannot allocate memory for %s", "device mapping table");
		return (-1);
d1157 1
a1157 1
	return (0);
d1227 2
a1228 2
		paxwarn(1, "Out of memory for %s", "device mapping table");
		return (NULL);
d1360 1
a1360 1
 bad:
d1395 1
a1395 1
		return (0);
d1397 2
a1398 2
		paxwarn(1, "Cannot allocate memory for %s", "directory access time reset table");
		return (-1);
d1400 1
a1400 1
	return (0);
d1493 1
a1493 1
	paxwarn(1, "Out of memory for %s", "directory access time reset table");
a1613 3
#if (_POSIX_VERSION >= 200809L)
	char *rp = NULL;
#else
a1614 1
#endif
d1620 1
a1620 6
#if (_POSIX_VERSION >= 200809L)
		if ((rp = realpath(name, NULL)) == NULL)
#else
		if ((rp = realpath(name, realname)) == NULL)
#endif
		    {
a1630 3
#if (_POSIX_VERSION >= 200809L)
			free(rp);
#endif
a1641 3
#if (_POSIX_VERSION >= 200809L)
		free(rp);
#endif
a1652 3
#if (_POSIX_VERSION >= 200809L)
	free(rp);
#endif
a1805 101

/* Forward hard link anonymisation routines */

/*
 * flnk_start
 *	Creates the hard link table.
 * Return:
 *	0 if created, -1 if failure
 */

int
flnk_start(void)
{
	if (fltab != NULL)
		return (0);
	if ((fltab = (HRDFLNK **)calloc(L_TAB_SZ, sizeof(HRDFLNK *))) == NULL) {
		paxwarn(1, "Cannot allocate memory for %s", "hard link anonymisation table");
		return (-1);
	}
	return (0);
}

/*
 * chk_flnk()
 *	Looks up entry in hard link hash table. If found, it copies the name
 *	of the file it is linked to (we already saw that file) into ln_name.
 *	lnkcnt is decremented and if goes to 1 the node is deleted from the
 *	database. (We have seen all the links to this file). If not found,
 *	we add the file to the database if it has the potential for having
 *	hard links to other files we may process (it has a link count > 1)
 * Return:
 *	if found returns the new inode number; -1 on error
 */

int
chk_flnk(ARCHD *arcn)
{
	HRDFLNK *pt;
	HRDFLNK **ppt;
	u_int indx;
	static ino_t running = 3;

	if (fltab == NULL)
		return (-1);
	/*
	 * ignore those nodes that cannot have hard links
	 */
	if ((arcn->type == PAX_DIR) || (arcn->sb.st_nlink <= 1))
		return (running++);

	/*
	 * hash inode number and look for this file
	 */
	indx = ((unsigned)arcn->sb.st_ino) % L_TAB_SZ;
	if ((pt = fltab[indx]) != NULL) {
		/*
		 * it's hash chain in not empty, walk down looking for it
		 */
		ppt = &(fltab[indx]);
		while (pt != NULL) {
			if ((pt->ino == arcn->sb.st_ino) &&
			    (pt->dev == arcn->sb.st_dev))
				break;
			ppt = &(pt->fow);
			pt = pt->fow;
		}

		if (pt != NULL) {
			/* found a link */
			ino_t rv = pt->newi;
			/* so cpio doesn't write file data twice */
			arcn->type |= PAX_LINKOR;
			/*
			 * if we have found all the links to this file, remove
			 * it from the database
			 */
			if (--pt->nlink <= 1) {
				*ppt = pt->fow;
				(void)free((char *)pt);
			}
			return (rv);
		}
	}

	/*
	 * we never saw this file before. It has links so we add it to the
	 * front of this hash chain
	 */
	if ((pt = (HRDFLNK *)malloc(sizeof(HRDFLNK))) != NULL) {
		pt->dev = arcn->sb.st_dev;
		pt->ino = arcn->sb.st_ino;
		pt->nlink = arcn->sb.st_nlink;
		pt->fow = fltab[indx];
		pt->newi = running++;
		fltab[indx] = pt;
		return (pt->newi);
	}

	paxwarn(1, "Out of memory for %s", "hard link anonymisation table");
	return (-1);
}
@


1.1.1.9.2.14
log
@solution for rare open flags, also uses O_BINARY like in mksh
@
text
@d718 6
a723 1
	fd = binopen3(BO_CLEXEC, path0, O_WRONLY | O_CREAT | O_EXCL, 0600);
@


1.1.1.9.2.15
log
@drop last remaining vestiges of UCB int types
@
text
@d1768 8
a1775 8
 *	hashes filenames to an unsigned int for hashing into a table. It looks
 *	at the tail end of the file, as this provides far better distribution
 *	than any other part of the name. For performance reasons we only care
 *	about the last MAXKEYLEN chars (should be at LEAST large enough to pick
 *	off the filename). It was tested on a 500'000 name file tree traversal
 *	from the root and gave almost a perfectly uniform distribution of keys
 *	when used with prime-sized tables (MAXKEYLEN was 128 in the test).
 *	Hashes sizeof(int) chars at a time and pads with 0 for last addition.
d1879 1
a1879 1
	unsigned int indx;
@


1.1.1.9.2.16
log
@this, annoyingly, also needs a full embedded struct stat
@
text
@d125 1
d127 10
a136 1
	struct ftm	*fow;
a137 1
	struct stat	sb;		/* files last modification time */
d1675 2
a1676 2
	st_timecpy(m, &dblk->ft.sb, psb);
	st_timecpy(a, &dblk->ft.sb, psb);
@


