head	1.20;
access;
symbols
	paxmirabilis-20190825:1.20
	paxmirabilis-20190224:1.20
	paxmirabilis-20190210:1.20
	npax:1.1.1.8.0.2
	cvs-20181212:1.1.1.8
	paxmirabilis-20171021:1.18
	paxmirabilis-20161104:1.17
	paxmirabilis-20161031:1.17
	paxmirabilis-20161025:1.17
	paxmirabilis-20160306:1.15
	cvs-201603041945:1.1.1.5
	paxmirabilis-20151013:1.14
	paxmirabilis-20140703:1.14
	paxmirabilis-20120606:1.14
	paxmirabilis-20120605:1.14
	cvs-201206051745:1.1.1.4
	paxmirabilis-20120520:1.13
	paxmirabilis-20120216:1.12
	paxmirabilis-20120212:1.10
	cvs-201202112230:1.1.1.4
	paxmirabilis-20110817:1.8
	MIRBSD_10:1.6.0.2
	MIRBSD_10_BASE:1.6
	cvs-200710231945:1.1.1.3
	cvs-200606232242:1.1.1.2
	MIRBSD_9_BASE:1.3
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200507211800:1.1.1.1
	cvs-200504291700:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2018.12.13.07.09.09;	author tg;	state Exp;
branches;
next	1.19;
commitid	1005C1205A44B32AFA4;

1.19
date	2018.12.12.18.08.41;	author tg;	state Exp;
branches;
next	1.18;
commitid	1005C114EA81986F5EC;

1.18
date	2017.08.07.20.10.13;	author tg;	state Exp;
branches;
next	1.17;
commitid	1005988C69344442E37;

1.17
date	2016.10.25.19.27.12;	author tg;	state Exp;
branches;
next	1.16;
commitid	100580FB2217F8FFA4F;

1.16
date	2016.03.12.12.53.27;	author tg;	state Exp;
branches;
next	1.15;
commitid	10056E4116046C639BE;

1.15
date	2016.03.06.13.47.48;	author tg;	state Exp;
branches;
next	1.14;
commitid	10056DC351700BAF310;

1.14
date	2012.06.05.18.22.55;	author tg;	state Exp;
branches;
next	1.13;
commitid	1004FCE4E961DE91080;

1.13
date	2012.05.20.16.13.15;	author tg;	state Exp;
branches;
next	1.12;
commitid	1004FB918314D2FECC0;

1.12
date	2012.02.16.17.27.30;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004F3D3C992B2187A1;

1.11
date	2012.02.16.16.01.07;	author tg;	state Exp;
branches;
next	1.10;
commitid	1004F3D28152C6F33B8;

1.10
date	2012.02.12.00.44.56;	author tg;	state Exp;
branches;
next	1.9;
commitid	1004F370B9F1314ECC5;

1.9
date	2012.02.12.00.27.14;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004F3707786D20BF4A;

1.8
date	2011.08.16.21.32.46;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004E4AE1EF00AF3003;

1.7
date	2008.10.29.17.34.48;	author tg;	state Exp;
branches;
next	1.6;
commitid	10049089E5F758E2CFE;

1.6
date	2007.10.23.20.07.41;	author tg;	state Exp;
branches;
next	1.5;
commitid	100471E5499154FE86E;

1.5
date	2007.02.17.04.52.39;	author tg;	state Exp;
branches;
next	1.4;
commitid	10045D68A2D54E2C558;

1.4
date	2006.07.16.16.14.50;	author tg;	state Exp;
branches;
next	1.3;
commitid	10044BA65F92A873301;

1.3
date	2006.06.24.00.41.56;	author tg;	state Exp;
branches;
next	1.2;
commitid	100449C8A5912D3E5D5;

1.2
date	2006.06.24.00.21.54;	author tg;	state Exp;
branches;
next	1.1;
commitid	100449C85991FEF5E15;

1.1
date	2005.02.05.17.22.06;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.22.06;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.06.23.23.00.11;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	100449C727D31170AA3;

1.1.1.3
date	2007.10.23.19.50.48;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	100471E50A5256C77AE;

1.1.1.4
date	2012.02.11.22.47.21;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	1004F36F008225F3522;

1.1.1.5
date	2016.03.04.19.46.09;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	10056D9E61429EE6550;

1.1.1.6
date	2016.03.04.20.54.58;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	10056D9F62E152ECBA5;

1.1.1.7
date	2016.03.06.13.29.53;	author tg;	state Exp;
branches;
next	1.1.1.8;
commitid	10056DC30960F3F5FA0;

1.1.1.8
date	2018.12.12.00.24.22;	author tg;	state Exp;
branches
	1.1.1.8.2.1;
next	;
commitid	1005C1055452C78F9E4;

1.1.1.8.2.1
date	2018.12.12.00.52.58;	author tg;	state Exp;
branches;
next	1.1.1.8.2.2;
commitid	1005C105BC86262A0B7;

1.1.1.8.2.2
date	2018.12.12.03.13.29;	author tg;	state Exp;
branches;
next	1.1.1.8.2.3;
commitid	1005C107CE315DC51F3;

1.1.1.8.2.3
date	2018.12.12.04.01.19;	author tg;	state Exp;
branches;
next	1.1.1.8.2.4;
commitid	1005C108824649A94FE;

1.1.1.8.2.4
date	2018.12.12.06.03.09;	author tg;	state Exp;
branches;
next	1.1.1.8.2.5;
commitid	1005C10A4B12E5998CE;

1.1.1.8.2.5
date	2018.12.12.06.25.15;	author tg;	state Exp;
branches;
next	1.1.1.8.2.6;
commitid	1005C10A9DB34B11C85;

1.1.1.8.2.6
date	2018.12.12.06.47.36;	author tg;	state Exp;
branches;
next	1.1.1.8.2.7;
commitid	1005C10AF1965896ABA;

1.1.1.8.2.7
date	2018.12.12.09.08.55;	author tg;	state Exp;
branches;
next	1.1.1.8.2.8;
commitid	1005C10D0381A00BE25;

1.1.1.8.2.8
date	2018.12.12.10.41.25;	author tg;	state Exp;
branches;
next	1.1.1.8.2.9;
commitid	1005C10E5E87909E6FC;

1.1.1.8.2.9
date	2018.12.12.15.00.23;	author tg;	state Exp;
branches;
next	1.1.1.8.2.10;
commitid	1005C11229872472EAF;

1.1.1.8.2.10
date	2018.12.12.15.33.04;	author tg;	state Exp;
branches;
next	1.1.1.8.2.11;
commitid	1005C112A434F807902;

1.1.1.8.2.11
date	2018.12.12.15.38.31;	author tg;	state Exp;
branches;
next	;
commitid	1005C112B8E47E3ADA5;


desc
@@


1.20
log
@fixing and string pooling and int shortening offensive
@
text
@/*	$OpenBSD: ar_subs.c,v 1.48 2016/08/26 05:06:14 guenther Exp $	*/
/*	$NetBSD: ar_subs.c,v 1.5 1995/03/21 09:07:06 cgd Exp $	*/

/*-
 * Copyright (c) 2008, 2011, 2012, 2016
 *	mirabilos <m@@mirbsd.org>
 * Copyright (c) 1992 Keith Muller.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#if HAVE_BOTH_TIME_H
#include <sys/time.h>
#include <time.h>
#elif HAVE_SYS_TIME_H
#include <sys/time.h>
#elif HAVE_TIME_H
#include <time.h>
#endif
#include <sys/stat.h>
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#if HAVE_STRINGS_H
#include <strings.h>
#endif
#include <unistd.h>

#include "pax.h"
#include "ftimes.h"
#include "extern.h"

__RCSID("$MirOS: src/bin/pax/ar_subs.c,v 1.19 2018/12/12 18:08:41 tg Exp $");

static void wr_archive(ARCHD *, int is_app);
static int get_arc(void);
static int next_head(ARCHD *);
extern sigset_t s_mask;

/*
 * Routines which control the overall operation modes of pax as specified by
 * the user: list, append, read ...
 */

static char hdbuf[BLKMULT];		/* space for archive header on read */
u_long flcnt;				/* number of files processed */
char ar_do_keepopen = 0;		/* see append() below */

/*
 * list()
 *	list the contents of an archive which match user supplied pattern(s)
 *	(no pattern matches all).
 */

void
list(void)
{
	ARCHD *arcn;
	int res;
	ARCHD archd;

	arcn = &archd;
	/*
	 * figure out archive type; pass any format specific options to the
	 * archive option processing routine; call the format init routine. We
	 * also save current time for ls_list() so we do not make a system
	 * call for each file we need to print. If verbose (vflag) start up
	 * the name and group caches.
	 */
	if ((get_arc() < 0) || ((*frmt->options)() < 0) ||
	    ((*frmt->st_rd)() < 0))
		return;

#if !HAVE_UG_FROM_UGID
	if (vflag && ((uidtb_start() < 0) || (gidtb_start() < 0)))
		return;
#endif

	/*
	 * step through the archive until the format says it is done
	 */
	while (next_head(arcn) == 0) {
		if (arcn->type == PAX_GLL || arcn->type == PAX_GLF) {
			/*
			 * we need to read, to get the real filename
			 */
			off_t cnt;
			if (!(*frmt->rd_data)(arcn, arcn->type == PAX_GLF
			    ? -1 : -2, &cnt))
				(void)rd_skip(cnt + arcn->pad);
			continue;
		}

		/*
		 * check for pattern, and user specified options match.
		 * When all patterns are matched we are done.
		 */
		if ((res = pat_match(arcn)) < 0)
			break;

		if ((res == 0) && (sel_chk(arcn) == 0)) {
			/*
			 * pattern resulted in a selected file
			 */
			if (pat_sel(arcn) < 0)
				break;

			/*
			 * modify the name as requested by the user if name
			 * survives modification, do a listing of the file
			 */
			if ((res = mod_name(arcn)) < 0)
				break;
			if (res == 0)
				ls_list(arcn, stdout);
		}

		/*
		 * skip to next archive format header using values calculated
		 * by the format header read routine
		 */
		if (rd_skip(arcn->skip + arcn->pad) == 1)
			break;
	}

	/*
	 * all done, let format have a chance to cleanup, and make sure that
	 * the patterns supplied by the user were all matched
	 */
	(void)(*frmt->end_rd)();
	(void)sigprocmask(SIG_BLOCK, &s_mask, NULL);
	ar_close(0);
	pat_chk();
}

static int
cmp_file_times(int mtime_flag, int ctime_flag, ARCHD *arcn, struct stat *sbp)
{
	struct stat sb;

	if (sbp == NULL) {
		if (lstat(arcn->name, &sb) != 0)
			return (0);
		sbp = &sb;
	}

	if (ctime_flag && mtime_flag)
		return (st_timecmp(m, &arcn->sb, sbp, <=) &&
		    st_timecmp(c, &arcn->sb, sbp, <=));
	else if (ctime_flag)
		return (st_timecmp(c, &arcn->sb, sbp, <=));
	else
		return (st_timecmp(m, &arcn->sb, sbp, <=));
}

/*
 * extract()
 *	extract the member(s) of an archive as specified by user supplied
 *	pattern(s) (no patterns extracts all members)
 */

void
extract(void)
{
	ARCHD *arcn;
	int res;
	off_t cnt;
	ARCHD archd;
	int fd;

	sltab_start();

	arcn = &archd;
	/*
	 * figure out archive type; pass any format specific options to the
	 * archive option processing routine; call the format init routine;
	 * start up the directory modification time and access mode database
	 */
	if ((get_arc() < 0) || ((*frmt->options)() < 0) ||
	    ((*frmt->st_rd)() < 0) || (dir_start() < 0))
		return;

	/*
	 * When we are doing interactive rename, we store the mapping of names
	 * so we can fix up hard links files later in the archive.
	 */
	if (iflag && (name_start() < 0))
		return;

	/*
	 * step through each entry on the archive until the format read routine
	 * says it is done
	 */
	while (next_head(arcn) == 0) {
		if (arcn->type == PAX_GLL || arcn->type == PAX_GLF) {
			/*
			 * we need to read, to get the real filename
			 */
			if (!(*frmt->rd_data)(arcn, arcn->type == PAX_GLF
			    ? -1 : -2, &cnt))
				(void)rd_skip(cnt + arcn->pad);
			continue;
		}

		/*
		 * check for pattern, and user specified options match. When
		 * all the patterns are matched we are done
		 */
		if ((res = pat_match(arcn)) < 0)
			break;

		if ((res > 0) || (sel_chk(arcn) != 0)) {
			/*
			 * file is not selected. skip past any file data and
			 * padding and go back for the next archive member
			 */
			(void)rd_skip(arcn->skip + arcn->pad);
			continue;
		}

		/*
		 * with -u or -D only extract when the archive member is newer
		 * than the file with the same name in the filesystem (no
		 * test of being the same type is required).
		 * NOTE: this test is done BEFORE name modifications as
		 * specified by pax. this operation can be confusing to the
		 * user who might expect the test to be done on an existing
		 * file AFTER the name mod. In honesty the pax spec is probably
		 * flawed in this respect.
		 */
		if ((uflag || Dflag) &&
		    cmp_file_times(uflag, Dflag, arcn, NULL)) {
			(void)rd_skip(arcn->skip + arcn->pad);
			continue;
		}

		/*
		 * this archive member is now been selected. modify the name.
		 */
		if ((pat_sel(arcn) < 0) || ((res = mod_name(arcn)) < 0))
			break;
		if (res > 0) {
			/*
			 * a bad name mod, skip and purge name from link table
			 */
			purg_lnk(arcn);
			(void)rd_skip(arcn->skip + arcn->pad);
			continue;
		}

		/*
		 * Non standard -Y and -Z flag. When the existing file is
		 * same age or newer skip
		 */
		if ((Yflag || Zflag) &&
		    cmp_file_times(Yflag, Zflag, arcn, NULL)) {
			(void)rd_skip(arcn->skip + arcn->pad);
			continue;
		}

		if (vflag) {
			if (vflag > 1)
				ls_list(arcn, listf);
			else {
				(void)safe_print(arcn->name, listf);
				vfpart = 1;
			}
		} else if (Vflag) {
			(void)putc('.', listf);
			(void)fflush(listf);
			vfpart = 1;
		}

		/*
		 * if required, chdir around.
		 */
		if ((arcn->pat != NULL) && (arcn->pat->chdname != NULL))
			if (!to_stdout && chdir(arcn->pat->chdname) != 0)
				syswarn(1, errno, "Cannot chdir to %s",
				    arcn->pat->chdname);

		/*
		 * all ok, extract this member based on type
		 */
		if (!PAX_IS_REG(arcn->type)) {
			/*
			 * process archive members that are not regular files.
			 * throw out padding and any data that might follow the
			 * header (as determined by the format).
			 */
			if (!to_stdout) {
				if (PAX_IS_HARDLINK(arcn->type)) {
					res = lnk_creat(arcn, &fd);
					if (fd != -1)
						goto extdata;
				}else
					res = node_creat(arcn);
			}

			(void)rd_skip(arcn->skip + arcn->pad);
			if (res < 0)
				purg_lnk(arcn);

			if (vflag && vfpart) {
				(void)putc('\n', listf);
				vfpart = 0;
			}
			goto popd;
		}
		/*
		 * we have a file with data here. If we cannot create it, skip
		 * over the data and purge the name from hard link table
		 */
		if (to_stdout)
			fd = STDOUT_FILENO;
		else if ((fd = file_creat(arcn)) < 0) {
			(void)rd_skip(arcn->skip + arcn->pad);
			purg_lnk(arcn);
			goto popd;
		}
		/*
		 * extract the file from the archive and skip over padding and
		 * any unprocessed data
		 */
 extdata:
		res = (*frmt->rd_data)(arcn, fd, &cnt);
		if (fd != STDOUT_FILENO)
			file_close(arcn, fd);
		if (vflag && vfpart) {
			(void)putc('\n', listf);
			vfpart = 0;
		}
		if (!res)
			(void)rd_skip(cnt + arcn->pad);

 popd:
		/*
		 * if required, chdir around.
		 */
		if ((arcn->pat != NULL) && (arcn->pat->chdname != NULL))
			if (!to_stdout && fchdir(cwdfd) != 0)
				syswarn(1, errno,
				    "Cannot fchdir to starting directory");
	}

	/*
	 * all done, restore directory modes and times as required; make sure
	 * all patterns supplied by the user were matched; block off signals
	 * to avoid chance for multiple entry into the cleanup code.
	 */
	(void)(*frmt->end_rd)();
	(void)sigprocmask(SIG_BLOCK, &s_mask, NULL);
	ar_close(0);
	sltab_process(0);
	proc_dir(0);
	pat_chk();
}

/*
 * wr_archive()
 *	Write an archive. used in both creating a new archive and appends on
 *	previously written archive.
 */

static void
wr_archive(ARCHD *arcn, int is_app)
{
	int res;
	int hlk;
	int wr_one;
	off_t cnt;
	int (*wrf)(ARCHD *);
	int fd = -1;

	/*
	 * if this format supports hard link storage, start up the database
	 * that detects them.
	 */
	if (((hlk = frmt->hlk) == 1) && (lnk_start() < 0))
		return;

	/*
	 * if this is not append, and there are no files, we do not write a
	 * trailer
	 */
	wr_one = is_app;

	/*
	 * start up the file traversal code and format specific write
	 */
	if (ftree_start() < 0) {
		if (is_app)
			goto trailer;
		return;
	} else if (((*frmt->st_wr)(is_app) < 0))
		return;

	wrf = frmt->wr;

	/*
	 * When we are doing interactive rename, we store the mapping of names
	 * so we can fix up hard links files later in the archive.
	 */
	if (iflag && (name_start() < 0))
		return;

	/*
	 * while there are files to archive, process them one at at time
	 */
	while (next_file(arcn) == 0) {
		/*
		 * check if this file meets user specified options match.
		 */
		if (sel_chk(arcn) != 0)
			continue;
		fd = -1;
		if (uflag) {
			/*
			 * only archive if this file is newer than a file with
			 * the same name that is already stored on the archive
			 */
			if ((res = chk_ftime(arcn)) < 0)
				break;
			if (res > 0) {
				ftree_skipped_newer();
				continue;
			}
		}

		/*
		 * this file is considered selected now. see if this is a hard
		 * link to a file already stored
		 */
		ftree_sel(arcn);
		if (hlk && (chk_lnk(arcn) < 0))
			break;

		if (PAX_IS_REG(arcn->type) || (arcn->type == PAX_HRG)) {
			/*
			 * we will have to read this file. by opening it now we
			 * can avoid writing a header to the archive for a file
			 * we were later unable to read (we also purge it from
			 * the link table).
			 */
			if ((fd = binopen3(0, arcn->org_name, O_RDONLY, 0)) < 0) {
				syswarn(1, errno, "Unable to open %s to read",
				    arcn->org_name);
				purg_lnk(arcn);
				continue;
			}
		}

		/*
		 * Now modify the name as requested by the user
		 */
		if ((res = mod_name(arcn)) < 0) {
			/*
			 * name modification says to skip this file, close the
			 * file and purge link table entry
			 */
			rdfile_close(arcn, &fd);
			purg_lnk(arcn);
			break;
		}

		if ((res > 0) || (docrc && (set_crc(arcn, fd) < 0))) {
			/*
			 * unable to obtain the crc we need, close the file,
			 * purge link table entry
			 */
			rdfile_close(arcn, &fd);
			purg_lnk(arcn);
			continue;
		}

		if (vflag) {
			if (vflag > 1)
				ls_list(arcn, listf);
			else {
				(void)safe_print(arcn->name, listf);
				vfpart = 1;
			}
		} else if (Vflag) {
			(void)putc('.', listf);
			(void)fflush(listf);
			vfpart = 1;
		}
		++flcnt;

		/*
		 * looks safe to store the file, have the format specific
		 * routine write routine store the file header on the archive
		 */
		if ((res = (*wrf)(arcn)) < 0) {
			rdfile_close(arcn, &fd);
			break;
		}
		wr_one = 1;
		if (res > 0) {
			/*
			 * format write says no file data needs to be stored
			 * so we are done messing with this file
			 */
			if (vflag && vfpart) {
				(void)putc('\n', listf);
				vfpart = 0;
			}
			rdfile_close(arcn, &fd);
			continue;
		}

		/*
		 * Add file data to the archive, quit on write error. if we
		 * cannot write the entire file contents to the archive we
		 * must pad the archive to replace the missing file data
		 * (otherwise during an extract the file header for the file
		 * which FOLLOWS this one will not be where we expect it to
		 * be).
		 */
		res = (*frmt->wr_data)(arcn, fd, &cnt);
		rdfile_close(arcn, &fd);
		if (vflag && vfpart) {
			(void)putc('\n', listf);
			vfpart = 0;
		}
		if (res < 0)
			break;

		/*
		 * pad as required, cnt is number of bytes not written
		 */
		if (((cnt > 0) && (wr_skip(cnt) < 0)) ||
		    ((arcn->pad > 0) && (wr_skip(arcn->pad) < 0)))
			break;
	}

 trailer:
	/*
	 * tell format to write trailer; pad to block boundary; reset directory
	 * mode/access times, and check if all patterns supplied by the user
	 * were matched. block off signals to avoid chance for multiple entry
	 * into the cleanup code
	 */
	if (wr_one) {
		(*frmt->end_wr)();
		wr_fin();
	}
	(void)sigprocmask(SIG_BLOCK, &s_mask, NULL);
	ar_close(0);
	if (tflag)
		proc_dir(0);
	ftree_chk();
}

/*
 * append()
 *	Add file to previously written archive. Archive format specified by the
 *	user must agree with archive. The archive is read first to collect
 *	modification times (if -u) and locate the archive trailer. The archive
 *	is positioned in front of the record with the trailer and wr_archive()
 *	is called to add the new members.
 *	PAX IMPLEMENTATION DETAIL NOTE:
 *	-u is implemented by adding the new members to the end of the archive.
 *	Care is taken so that these do not end up as links to the older
 *	version of the same file already stored in the archive. It is expected
 *	when extraction occurs these newer versions will over-write the older
 *	ones stored "earlier" in the archive (this may be a bad assumption as
 *	it depends on the implementation of the program doing the extraction).
 *	It is really difficult to splice in members without either re-writing
 *	the entire archive (from the point were the old version was), or having
 *	assistance of the format specification in terms of a special update
 *	header that invalidates a previous archive record. The posix spec left
 *	the method used to implement -u unspecified. This pax is able to
 *	over write existing files that it creates.
 */

void
append(void)
{
	ARCHD *arcn;
	int res;
	ARCHD archd;
	const FSUB *orgfrmt;
	int udev;
	off_t tlen;

	arcn = &archd;
	orgfrmt = frmt;

	/*
	 * Do not allow an append operation if the actual archive is of a
	 * different format than the user specified format.
	 */
	if (get_arc() < 0)
		return;
	if ((orgfrmt != NULL) && (orgfrmt != frmt)) {
		paxwarn(1, "Cannot mix current archive format %s with %s",
		    frmt->name, orgfrmt->name);
		return;
	}

	/*
	 * pass the format any options and start up format
	 */
	if (((*frmt->options)() < 0) || ((*frmt->st_rd)() < 0))
		return;

	/* hack to allow appending to Unix Archiver libraries */
	if (frmt->is_uar)
		ar_do_keepopen = 1;

	/*
	 * if we only are adding members that are newer, we need to save the
	 * mod times for all files we see.
	 */
	if (uflag && (ftime_start() < 0))
		return;

	/*
	 * some archive formats encode hard links by recording the device and
	 * file serial number (inode) but copy the file anyway (multiple times)
	 * to the archive. When we append, we run the risk that newly added
	 * files may have the same device and inode numbers as those recorded
	 * on the archive but during a previous run. If this happens, when the
	 * archive is extracted we get INCORRECT hard links. We avoid this by
	 * remapping the device numbers so that newly added files will never
	 * use the same device number as one found on the archive. remapping
	 * allows new members to safely have links among themselves. remapping
	 * also avoids problems with file inode (serial number) truncations
	 * when the inode number is larger than storage space in the archive
	 * header. See the remap routines for more details.
	 */
	if ((udev = frmt->udev) && (dev_start() < 0))
		return;

	/*
	 * reading the archive may take a long time. If verbose tell the user
	 */
	if (vflag) {
		(void)fprintf(listf,
			"%s: Reading archive to position at the end...", argv0);
		vfpart = 1;
	}

	/*
	 * step through the archive until the format says it is done
	 */
	while (next_head(arcn) == 0) {
		/*
		 * check if this file meets user specified options.
		 */
		if (sel_chk(arcn) != 0) {
			if (rd_skip(arcn->skip + arcn->pad) == 1)
				break;
			continue;
		}

		if (uflag) {
			/*
			 * see if this is the newest version of this file has
			 * already been seen, if so skip.
			 */
			if ((res = chk_ftime(arcn)) < 0)
				break;
			if (res > 0) {
				if (rd_skip(arcn->skip + arcn->pad) == 1)
					break;
				continue;
			}
		}

		/*
		 * Store this device number. Device numbers seen during the
		 * read phase of append will cause newly appended files with a
		 * device number seen in the old part of the archive to be
		 * remapped to an unused device number.
		 */
		if ((udev && (add_dev(arcn) < 0)) ||
		    (rd_skip(arcn->skip + arcn->pad) == 1))
			break;
	}

	/*
	 * done, finish up read and get the number of bytes to back up so we
	 * can add new members. The format might have used the hard link table,
	 * purge it.
	 */
	tlen = (*frmt->end_rd)();
	lnk_end();

	/*
	 * try to position for write, if this fails quit. if any error occurs,
	 * we will refuse to write
	 */
	if (appnd_start(tlen) < 0)
		return;

	/*
	 * tell the user we are done reading.
	 */
	if (vflag && vfpart) {
		(void)fputs("done.\n", listf);
		vfpart = 0;
	}

	/*
	 * go to the writing phase to add the new members
	 */
	wr_archive(arcn, 1);
}

/*
 * archive()
 *	write a new archive
 */

void
archive(void)
{
	ARCHD archd;

	/*
	 * if we only are adding members that are newer, we need to save the
	 * mod times for all files; set up for writing; pass the format any
	 * options write the archive
	 */
	if ((uflag && (ftime_start() < 0)) || (wr_start() < 0))
		return;
	if ((*frmt->options)() < 0)
		return;

	wr_archive(&archd, 0);
}

/*
 * copy()
 *	copy files from one part of the filesystem to another. this does not
 *	use any archive storage. The EFFECT OF THE COPY IS THE SAME as if an
 *	archive was written and then extracted in the destination directory
 *	(except the files are forced to be under the destination directory).
 */

void
copy(void)
{
	ARCHD *arcn;
	int res;
	int fddest;
	char *dest_pt;
	size_t dlen;
	size_t drem;
	int fdsrc = -1;
	struct stat sb;
	ARCHD archd;
	char dirbuf[PAXPATHLEN+1];

	sltab_start();

	arcn = &archd;
	/*
	 * set up the destination dir path and make sure it is a directory. We
	 * make sure we have a trailing / on the destination
	 */
	dlen = strlcpy(dirbuf, dirptr, sizeof(dirbuf));
	if (dlen >= sizeof(dirbuf) ||
	    (dlen == sizeof(dirbuf) - 1 && dirbuf[dlen - 1] != '/')) {
		paxwarn(1, "directory name is too long %s", dirptr);
		return;
	}
	dest_pt = dirbuf + dlen;
	if (*(dest_pt-1) != '/') {
		*dest_pt++ = '/';
		*dest_pt = '\0';
		++dlen;
	}
	drem = PAXPATHLEN - dlen;

	if (stat(dirptr, &sb) < 0) {
		syswarn(1, errno, "Cannot access destination directory %s",
			dirptr);
		return;
	}
	if (!S_ISDIR(sb.st_mode)) {
		paxwarn(1, "Destination is not a directory %s", dirptr);
		return;
	}

	/*
	 * start up the hard link table; file traversal routines and the
	 * modification time and access mode database
	 */
	if ((lnk_start() < 0) || (ftree_start() < 0) || (dir_start() < 0))
		return;

	/*
	 * When we are doing interactive rename, we store the mapping of names
	 * so we can fix up hard links files later in the archive.
	 */
	if (iflag && (name_start() < 0))
		return;

	/*
	 * set up to cp file trees
	 */
	cp_start();

	/*
	 * while there are files to archive, process them
	 */
	while (next_file(arcn) == 0) {
		fdsrc = -1;

		/*
		 * check if this file meets user specified options
		 */
		if (sel_chk(arcn) != 0)
			continue;

		/*
		 * if there is already a file in the destination directory with
		 * the same name and it is newer, skip the one stored on the
		 * archive.
		 * NOTE: this test is done BEFORE name modifications as
		 * specified by pax. this can be confusing to the user who
		 * might expect the test to be done on an existing file AFTER
		 * the name mod. In honesty the pax spec is probably flawed in
		 * this respect
		 */
		if (uflag || Dflag) {
			/*
			 * create the destination name
			 */
			if (strlcpy(dest_pt, arcn->name + (*arcn->name == '/'),
			    drem + 1) > drem) {
				paxwarn(1, "Destination pathname too long %s",
					arcn->name);
				continue;
			}

			/*
			 * if existing file is same age or newer skip
			 */
			res = lstat(dirbuf, &sb);
			*dest_pt = '\0';

			if (res == 0) {
				ftree_skipped_newer();
				if (cmp_file_times(uflag, Dflag, arcn, &sb))
					continue;
			}
		}

		/*
		 * this file is considered selected. See if this is a hard link
		 * to a previous file; modify the name as requested by the
		 * user; set the final destination.
		 */
		ftree_sel(arcn);
		if ((chk_lnk(arcn) < 0) || ((res = mod_name(arcn)) < 0))
			break;
		if ((res > 0) || (set_dest(arcn, dirbuf, dlen) < 0)) {
			/*
			 * skip file, purge from link table
			 */
			purg_lnk(arcn);
			continue;
		}

		/*
		 * Non standard -Y and -Z flag. When the existing file is
		 * same age or newer skip
		 */
		if ((Yflag || Zflag) &&
		    cmp_file_times(Yflag, Zflag, arcn, NULL))
			continue;

		if (vflag) {
			(void)safe_print(arcn->name, listf);
			vfpart = 1;
		} else if (Vflag) {
			(void)putc('.', listf);
			(void)fflush(listf);
			vfpart = 1;
		}
		++flcnt;

		/*
		 * try to create a hard link to the src file if requested
		 * but make sure we are not trying to overwrite ourselves.
		 */
		if (lflag)
			res = cross_lnk(arcn);
		else
			res = chk_same(arcn);
		if (res <= 0) {
			if (vflag && vfpart) {
				(void)putc('\n', listf);
				vfpart = 0;
			}
			continue;
		}

		/*
		 * have to create a new file
		 */
		if (!PAX_IS_REG(arcn->type)) {
			/*
			 * create a link or special file
			 */
			if (PAX_IS_HARDLINK(arcn->type))
				res = lnk_creat(arcn, NULL);
			else
				res = node_creat(arcn);
			if (res < 0)
				purg_lnk(arcn);
			if (vflag && vfpart) {
				(void)putc('\n', listf);
				vfpart = 0;
			}
			continue;
		}

		/*
		 * have to copy a regular file to the destination directory.
		 * first open source file and then create the destination file
		 */
		if ((fdsrc = binopen3(0, arcn->org_name, O_RDONLY, 0)) < 0) {
			syswarn(1, errno, "Unable to open %s to read",
			    arcn->org_name);
			purg_lnk(arcn);
			continue;
		}
		if ((fddest = file_creat(arcn)) < 0) {
			rdfile_close(arcn, &fdsrc);
			purg_lnk(arcn);
			continue;
		}

		/*
		 * copy source file data to the destination file
		 */
		cp_file(arcn, fdsrc, fddest);
		file_close(arcn, fddest);
		rdfile_close(arcn, &fdsrc);

		if (vflag && vfpart) {
			(void)putc('\n', listf);
			vfpart = 0;
		}
	}

	/*
	 * restore directory modes and times as required; make sure all
	 * patterns were selected block off signals to avoid chance for
	 * multiple entry into the cleanup code.
	 */
	(void)sigprocmask(SIG_BLOCK, &s_mask, NULL);
	ar_close(0);
	sltab_process(0);
	proc_dir(0);
	ftree_chk();
}

/*
 * next_head()
 *	try to find a valid header in the archive. Uses format specific
 *	routines to extract the header and id the trailer. Trailers may be
 *	located within a valid header or in an invalid header (the location
 *	is format specific. The inhead field from the option table tells us
 *	where to look for the trailer).
 *	We keep reading (and resyncing) until we get enough contiguous data
 *	to check for a header. If we cannot find one, we shift by a byte
 *	add a new byte from the archive to the end of the buffer and try again.
 *	If we get a read error, we throw out what we have (as we must have
 *	contiguous data) and start over again.
 *	ASSUMED: headers fit within a BLKMULT header.
 * Return:
 *	0 if we got a header, -1 if we are unable to ever find another one
 *	(we reached the end of input, or we reached the limit on retries. see
 *	the specs for rd_wrbuf() for more details)
 */

static int
next_head(ARCHD *arcn)
{
	int ret;
	char *hdend;
	int res;
	int shftsz;
	int hsz;
	int in_resync = 0;		/* set when we are in resync mode */
	int cnt = 0;			/* counter for trailer function */
	int first = 1;			/* on 1st read, EOF isn't premature. */

	/*
	 * set up initial conditions, we want a whole frmt->hsz block as we
	 * have no data yet.
	 */
	res = hsz = frmt->hsz;
	hdend = hdbuf;
	shftsz = hsz - 1;
	for (;;) {
		/*
		 * keep looping until we get a contiguous FULL buffer
		 * (frmt->hsz is the proper size)
		 */
		for (;;) {
			if ((ret = rd_wrbuf(hdend, res)) == res)
				break;

			/*
			 * If we read 0 bytes (EOF) from an archive when we
			 * expect to find a header, we have stepped upon
			 * an archive without the customary block of zeroes
			 * end marker.  It's just stupid to error out on
			 * them, so exit gracefully.
			 */
			if (first && ret == 0)
				return(-1);
			first = 0;

			/*
			 * some kind of archive read problem, try to resync the
			 * storage device, better give the user the bad news.
			 */
			if ((ret == 0) || (rd_sync() < 0) || frmt->is_uar) {
 no_header:
				paxwarn(1,"Premature end of file on archive read");
				return(-1);
			}
			if (!in_resync) {
				if (act == APPND) {
					paxwarn(1,
					  "Archive I/O error, cannot continue");
					return(-1);
				}
				paxwarn(1,"Archive I/O error. Trying to recover.");
				++in_resync;
			}

			/*
			 * oh well, throw it all out and start over
			 */
			res = hsz;
			hdend = hdbuf;
		}

		/*
		 * ok we have a contiguous buffer of the right size. Call the
		 * format read routine. If this was not a valid header and this
		 * format stores trailers outside of the header, call the
		 * format specific trailer routine to check for a trailer. We
		 * have to watch out that we do not mis-identify file data or
		 * block padding as a header or trailer. Format specific
		 * trailer functions must NOT check for the trailer while we
		 * are running in resync mode. Some trailer functions may tell
		 * us that this block cannot contain a valid header either, so
		 * we then throw out the entire block and start over.
		 */
		if ((*frmt->rd)(arcn, hdbuf) == 0)
			break;

		if (frmt->is_uar)
			goto no_header;

		if (!frmt->inhead) {
			/*
			 * this format has trailers outside of valid headers
			 */
			if ((ret = (*frmt->trail)(arcn,hdbuf,in_resync,&cnt)) == 0){
				/*
				 * valid trailer found, drain input as required
				 */
				ar_drain();
				return(-1);
			}

			if (ret == 1) {
				/*
				 * we are in resync and we were told to throw
				 * the whole block out because none of the
				 * bytes in this block can be used to form a
				 * valid header
				 */
				res = hsz;
				hdend = hdbuf;
				continue;
			}
		}

		/*
		 * Brute force section.
		 * not a valid header. We may be able to find a header yet. So
		 * we shift over by one byte, and set up to read one byte at a
		 * time from the archive and place it at the end of the buffer.
		 * We will keep moving byte at a time until we find a header or
		 * get a read error and have to start over.
		 */
		if (!in_resync) {
			if (act == APPND) {
				paxwarn(1,"Unable to append, archive header flaw");
				return(-1);
			}
			paxwarn(1,"Invalid header, starting valid header search.");
			++in_resync;
		}
		memmove(hdbuf, hdbuf+1, shftsz);
		res = 1;
		hdend = hdbuf + shftsz;
	}

	/*
	 * ok got a valid header, check for trailer if format encodes it in the
	 * the header. NOTE: the parameters are different than trailer routines
	 * which encode trailers outside of the header!
	 */
	if (frmt->inhead && ((*frmt->trail)(arcn,NULL,0,NULL) == 0)) {
		/*
		 * valid trailer found, drain input as required
		 */
		ar_drain();
		return(-1);
	}

	++flcnt;
	return(0);
}

/*
 * get_arc()
 *	Figure out what format an archive is. Handles archive with flaws by
 *	brute force searches for a legal header in any supported format. The
 *	format id routines have to be careful to NOT mis-identify a format.
 *	ASSUMED: headers fit within a BLKMULT header.
 * Return:
 *	0 if archive found -1 otherwise
 */

static int
get_arc(void)
{
	int i;
	int hdsz = 0;
	int res;
	int minhd = BLKMULT;
	char *hdend;
	int notice = 0;

	/*
	 * find the smallest header size in all archive formats and then set up
	 * to read the archive.
	 */
	for (i = 0; ford[i] != FSUB_MAX; ++i) {
		if (fsub[ford[i]].hsz < minhd)
			minhd = fsub[ford[i]].hsz;
	}
	if (rd_start() < 0)
		return(-1);
	res = BLKMULT;
	hdsz = 0;
	hdend = hdbuf;

#ifndef SMALL
	/* try to verify against ar first */
	if (buf_fill_internal(8) == 8) {
		i = rd_wrbuf(hdend, 8);
		if (i == 8 && uar_ismagic(hdbuf) == 0) {
			frmt = &(fsub[FSUB_AR]);
			return (0);
		}
		if (i > 0)
			pback(hdend, i);
	}
#endif

	for (;;) {
		for (;;) {
			/*
			 * fill the buffer with at least the smallest header
			 */
			i = rd_wrbuf(hdend, res);
			if (i > 0)
				hdsz += i;
			if (hdsz >= minhd)
				break;

			/*
			 * if we cannot recover from a read error quit
			 */
			if ((i == 0) || (rd_sync() < 0))
				goto out;

			/*
			 * when we get an error none of the data we already
			 * have can be used to create a legal header (we just
			 * got an error in the middle), so we throw it all out
			 * and refill the buffer with fresh data.
			 */
			res = BLKMULT;
			hdsz = 0;
			hdend = hdbuf;
			if (!notice) {
				if (act == APPND)
					return(-1);
				paxwarn(1,"Cannot identify format. Searching...");
				++notice;
			}
		}

		/*
		 * we have at least the size of the smallest header in any
		 * archive format. Look to see if we have a match. The array
		 * ford[] is used to specify the header id order to reduce the
		 * chance of incorrectly id'ing a valid header (some formats
		 * may be subsets of each other and the order would then be
		 * important).
		 */
		for (i = 0; ford[i] != FSUB_MAX; ++i) {
			if ((*fsub[ford[i]].id)(hdbuf, hdsz) < 0)
				continue;
			frmt = &(fsub[ford[i]]);
			/*
			 * yuck, to avoid slow special case code in the extract
			 * routines, just push this header back as if it was
			 * not seen. We have left extra space at start of the
			 * buffer for this purpose. This is a bit ugly, but
			 * adding all the special case code is far worse.
			 */
			pback(hdbuf, hdsz);
			return(0);
		}

		/*
		 * We have a flawed archive, no match. we start searching, but
		 * we never allow additions to flawed archives
		 */
		if (!notice) {
			if (act == APPND)
				return(-1);
			paxwarn(1, "Cannot identify format. Searching...");
			++notice;
		}

		/*
		 * brute force search for a header that we can id.
		 * we shift through byte at a time. this is slow, but we cannot
		 * determine the nature of the flaw in the archive in a
		 * portable manner
		 */
		if (--hdsz > 0) {
			memmove(hdbuf, hdbuf+1, hdsz);
			res = BLKMULT - hdsz;
			hdend = hdbuf + hdsz;
		} else {
			res = BLKMULT;
			hdend = hdbuf;
			hdsz = 0;
		}
	}

 out:
	/*
	 * we cannot find a header, bow, apologise and quit
	 */
	paxwarn(1, "Sorry, unable to determine archive format.");
	return(-1);
}
@


1.19
log
@merge the npax branch into MAIN

asides from a missing dprintf and portability, this ought to be
good enough for people (well me) to play with for now
@
text
@d63 1
a63 1
__RCSID("$MirOS: src/bin/pax/ar_subs.c,v 1.17 2016/10/25 19:27:12 tg Exp $");
d77 1
a77 1
int ar_do_keepopen = 0;			/* see append() below */
d373 1
a373 1
				    "Can't fchdir to starting directory");
d613 1
a613 1
	FSUB *orgfrmt;
@


1.18
log
@filesystem
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.33 2009/10/27 23:59:22 deraadt Exp $	*/
d39 2
a40 1
#include <sys/param.h>
d42 6
d49 2
d52 1
d54 3
a56 3
#include <stdio.h>
#include <fcntl.h>
#include <errno.h>
d58 1
a58 2
#include <stdlib.h>
#include <time.h>
d60 1
a61 1
#include "options.h"
a90 1
	time_t now;
d104 1
d107 1
a107 2

	now = time(NULL);
d145 1
a145 1
				ls_list(arcn, now, stdout);
d162 1
a162 1
	ar_close();
d166 20
a198 1
	struct stat sb;
a199 1
	time_t now;
a219 2
	now = time(NULL);

d261 4
a264 16
		if ((uflag || Dflag) && ((lstat(arcn->name, &sb) == 0))) {
			if (uflag && Dflag) {
				if ((arcn->sb.st_mtime <= sb.st_mtime) &&
				    (arcn->sb.st_ctime <= sb.st_ctime)) {
					(void)rd_skip(arcn->skip + arcn->pad);
					continue;
				}
			} else if (Dflag) {
				if (arcn->sb.st_ctime <= sb.st_ctime) {
					(void)rd_skip(arcn->skip + arcn->pad);
					continue;
				}
			} else if (arcn->sb.st_mtime <= sb.st_mtime) {
				(void)rd_skip(arcn->skip + arcn->pad);
				continue;
			}
d285 4
a288 16
		if ((Yflag || Zflag) && ((lstat(arcn->name, &sb) == 0))) {
			if (Yflag && Zflag) {
				if ((arcn->sb.st_mtime <= sb.st_mtime) &&
				    (arcn->sb.st_ctime <= sb.st_ctime)) {
					(void)rd_skip(arcn->skip + arcn->pad);
					continue;
				}
			} else if (Yflag) {
				if (arcn->sb.st_ctime <= sb.st_ctime) {
					(void)rd_skip(arcn->skip + arcn->pad);
					continue;
				}
			} else if (arcn->sb.st_mtime <= sb.st_mtime) {
				(void)rd_skip(arcn->skip + arcn->pad);
				continue;
			}
d293 1
a293 1
				ls_list(arcn, now, listf);
d315 1
a315 1
		if ((arcn->type != PAX_REG) && (arcn->type != PAX_CTG)) {
d322 1
a322 1
				if ((arcn->type == PAX_HLK) || (arcn->type == PAX_HRG)) {
d326 1
a326 1
				} else
d383 1
a383 1
	ar_close();
d385 1
a385 1
	proc_dir();
a403 1
	time_t now;
a436 2
	now = time(NULL);

d468 1
a468 2
		if ((arcn->type == PAX_REG) || (arcn->type == PAX_HRG) ||
		    (arcn->type == PAX_CTG)) {
d475 3
a477 3
			if ((fd = open(arcn->org_name, O_RDONLY, 0)) < 0) {
				syswarn(1,errno, "Unable to open %s to read",
					arcn->org_name);
d508 1
a508 1
				ls_list(arcn, now, listf);
d579 1
a579 1
	ar_close();
d581 1
a581 1
		proc_dir();
d878 1
a878 8
				if (uflag && Dflag) {
					if ((arcn->sb.st_mtime<=sb.st_mtime) &&
					    (arcn->sb.st_ctime<=sb.st_ctime))
						continue;
				} else if (Dflag) {
					if (arcn->sb.st_ctime <= sb.st_ctime)
						continue;
				} else if (arcn->sb.st_mtime <= sb.st_mtime)
d903 3
a905 11
		if ((Yflag || Zflag) && ((lstat(arcn->name, &sb) == 0))) {
			if (Yflag && Zflag) {
				if ((arcn->sb.st_mtime <= sb.st_mtime) &&
				    (arcn->sb.st_ctime <= sb.st_ctime))
					continue;
			} else if (Yflag) {
				if (arcn->sb.st_ctime <= sb.st_ctime)
					continue;
			} else if (arcn->sb.st_mtime <= sb.st_mtime)
				continue;
		}
d936 1
a936 1
		if ((arcn->type != PAX_REG) && (arcn->type != PAX_CTG)) {
d940 1
a940 1
			if ((arcn->type == PAX_HLK) || (arcn->type == PAX_HRG))
d957 1
a957 1
		if ((fdsrc = open(arcn->org_name, O_RDONLY, 0)) < 0) {
d988 1
a988 1
	ar_close();
d990 1
a990 1
	proc_dir();
@


1.17
log
@fixup after the import, also clears up lies in the manpage
@
text
@d54 1
a54 1
__RCSID("$MirOS: src/bin/pax/ar_subs.c,v 1.16 2016/03/12 12:53:27 tg Exp $");
d229 1
a229 1
		 * than the file with the same name in the file system (no
d771 1
a771 1
 *	copy files from one part of the file system to another. this does not
@


1.16
log
@begin stripping down pax for the floppy: drop uar support
@
text
@d54 1
a54 1
__RCSID("$MirOS: src/bin/pax/ar_subs.c,v 1.13 2012/05/20 16:13:15 tg Exp $");
d1202 1
a1202 1
	for (i = 0; ford[i] >= 0; ++i) {
d1267 1
a1267 1
		for (i = 0; ford[i] >= 0; ++i) {
@


1.15
log
@merge CVE fixes from openbsd branch
@
text
@d5 1
a5 1
 * Copyright (c) 2008, 2011, 2012
d1212 1
d1217 1
a1217 3
			extern int F_UAR;

			frmt = &(fsub[F_UAR]);
d1223 1
@


1.14
log
@KNF
@
text
@d6 1
a6 1
 *	Thorsten Glaser <tg@@mirbsd.org>
d175 2
d384 1
d791 2
d1008 1
@


1.13
log
@get rid of extern.h including other headers
@
text
@d54 1
a54 1
__RCSID("$MirOS: src/bin/pax/ar_subs.c,v 1.12 2012/02/16 17:27:30 tg Exp $");
d568 1
a568 1
trailer:
d1304 1
a1304 1
    out:
@


1.12
log
@clean up some ugliness
@
text
@d49 1
d54 1
a54 1
__RCSID("$MirOS: src/bin/pax/ar_subs.c,v 1.11 2012/02/16 16:01:07 tg Exp $");
@


1.11
log
@implement the GNU cpio option -V (print a dot per file processed)
sponsored by tarent solutions GmbH for work on evolvis (FusionForge)
@
text
@d53 1
a53 1
__RCSID("$MirOS: src/bin/pax/ar_subs.c,v 1.10 2012/02/12 00:44:56 tg Exp $");
d338 1
a338 1
		 * we have a file with data here. If we can not create it, skip
@


1.10
log
@spelling
@
text
@d53 1
a53 1
__RCSID("$MirOS: src/bin/pax/ar_subs.c,v 1.9 2012/02/12 00:27:14 tg Exp $");
d295 4
d513 4
d923 4
@


1.9
log
@merge OpenBSD
@
text
@d53 1
a53 1
__RCSID("$MirOS: src/bin/pax/ar_subs.c,v 1.8 2011/08/16 21:32:46 tg Exp $");
d1293 1
a1293 1
	 * we cannot find a header, bow, apologize and quit
@


1.8
log
@backend for Unix Archiver libraries â€“ ar(5) and deb(5) format files
(since GNU binutils on ELF systems thinks SYSV style ar is usedâ€¦)
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.31 2006/11/17 08:38:04 otto Exp $	*/
d5 1
a5 1
 * Copyright (c) 2008, 2011
d53 1
a53 2
__SCCSID("@@(#)ar_subs.c	8.2 (Berkeley) 4/18/94");
__RCSID("$MirOS: src/bin/pax/ar_subs.c,v 1.7 2008/10/29 17:34:48 tg Exp $");
d449 2
a450 1
			if (res > 0)
d452 1
d867 1
@


1.7
log
@add code to work around broken archives such as the CPIO archive inside
Fedora Core 4 glibc-common-2.3.6-3.i386.rpm which carry the actual data
of hardlinks not in the first but a later (here, the last) occurence of
the file in question: iff hardlinking succeeds (no cross-device!), size
of the linked files is 0, size of the archive member is greater than 0,
we are extracting, but not to stdout, proceed writing out the data.
@
text
@d5 2
a6 2
 * Copyright (c) 2008
 *	Thorsten Glaser <tg@@mirbsd.de>
d54 1
a54 1
__RCSID("$MirOS: src/bin/pax/ar_subs.c,v 1.6 2007/10/23 20:07:41 tg Exp $");
d68 1
d419 1
a419 1
	} else if (((*frmt->st_wr)() < 0))
d629 4
d1054 2
a1055 1
			if ((ret == 0) || (rd_sync() < 0)) {
d1091 3
d1190 14
@


1.6
log
@merge openbsd changes and fix tar -R, -S flag misdocumentation
@
text
@d5 2
d54 1
a54 1
__RCSID("$MirOS: src/bin/pax/ar_subs.c,v 1.5 2007/02/17 04:52:39 tg Exp $");
d315 5
a319 3
				if ((arcn->type == PAX_HLK) || (arcn->type == PAX_HRG))
					res = lnk_creat(arcn);
				else
d348 1
d359 1
a359 1
popd:
d935 1
a935 1
				res = lnk_creat(arcn);
@


1.5
log
@__CRAZY clean
@
text
@d1 1
a1 2
/**	$MirOS: src/bin/pax/ar_subs.c,v 1.4 2006/07/16 16:14:50 tg Exp $ */
/*	$OpenBSD: ar_subs.c,v 1.29 2006/01/25 17:42:08 markus Exp $	*/
d52 1
a52 1
__RCSID("$MirOS: src/bin/pax/ar_subs.c,v 1.4 2006/07/16 16:14:50 tg Exp $");
d327 1
a327 1
			continue;
d338 1
a338 1
			continue;
d354 1
a411 4
		else
			return;
	}
	if (((*frmt->st_wr)() < 0))
d413 3
@


1.4
log
@* -Wall clean
* implement tar -xO mode for extracting to stdout, GNU tar compatible

for freewrt

"schön" wbx@@
@
text
@d1 1
a1 1
/**	$MirOS$ */
d53 1
a53 1
__RCSID("$MirOS$");
d762 2
a763 2
	int dlen;
	int drem;
@


1.3
log
@... as if

fix a few segfaults, on:
| cpio -o<return><ctrl-d>
| echo | cpio -o<return>
@
text
@d1 1
d38 1
a38 9
#ifndef lint
#if 0
static const char sccsid[] = "@@(#)ar_subs.c	8.2 (Berkeley) 4/18/94";
#else
static const char rcsid[] = "$OpenBSD: ar_subs.c,v 1.29 2006/01/25 17:42:08 markus Exp $";
#endif
#endif /* not lint */

#include <sys/types.h>
a40 1
#include <sys/param.h>
d50 4
d300 1
a300 1
			if (chdir(arcn->pat->chdname) != 0)
d313 6
a318 4
			if ((arcn->type == PAX_HLK) || (arcn->type == PAX_HRG))
				res = lnk_creat(arcn);
			else
				res = node_creat(arcn);
d334 3
a336 1
		if ((fd = file_creat(arcn)) < 0) {
d346 2
a347 1
		file_close(arcn, fd);
d359 1
a359 1
			if (fchdir(cwdfd) != 0)
d401 1
a401 1
	 * if this is not append, and there are no files, we do not write a 
@


1.2
log
@The real cause was fmt->st_wr not being called;
investigated this to be a bogus change in a fix
by OpenBSD; this "should" work better.

Revert the workaround.
@
text
@d408 1
a408 1
	if (ftree_start() < 0)
d411 3
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.28 2004/04/16 22:50:23 deraadt Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: ar_subs.c,v 1.28 2004/04/16 22:50:23 deraadt Exp $";
d400 6
d408 4
a411 1
	if ((ftree_start() < 0) || ((*frmt->st_wr)() < 0))
a421 6
	/*
	 * if this is not append, and there are no files, we do not write a 
	 * trailer
	 */
	wr_one = is_app;

d549 1
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@One "miserable" byte in filenames is worth an import

agreed bsiegert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.29 2006/01/25 17:42:08 markus Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: ar_subs.c,v 1.29 2006/01/25 17:42:08 markus Exp $";
a399 6
	 * if this is not append, and there are no files, we do not write a 
	 * trailer
	 */
	wr_one = is_app;

	/*
d402 2
a403 6
	if (ftree_start() < 0) {
		if (is_app)
			goto trailer;
		if (((*frmt->st_wr)() < 0))
			return;
	}
d413 6
a545 1
trailer:
@


1.1.1.3
log
@import latest OpenCPIO â˜º
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.31 2006/11/17 08:38:04 otto Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: ar_subs.c,v 1.31 2006/11/17 08:38:04 otto Exp $";
d330 1
a330 1
			goto popd;
d339 1
a339 1
			goto popd;
a353 1
popd:
d411 3
a413 4
		return;
	} else if (((*frmt->st_wr)() < 0))
		return;

@


1.1.1.4
log
@import up-to-date pax from OpenBSD 5.1-current
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.33 2009/10/27 23:59:22 deraadt Exp $	*/
d37 8
d444 1
a444 2
			if (res > 0) {
				ftree_skipped_newer(arcn);
a445 1
			}
a855 1
				ftree_skipped_newer(arcn);
@


1.1.1.5
log
@pull newer paxtar from OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.45 2015/03/19 05:14:24 guenther Exp $	*/
d40 1
d104 1
a104 1
			if (!rd_wrfile(arcn, arcn->type == PAX_GLF
d148 1
a148 1
	ar_close(0);
a151 20
static int
cmp_file_times(int mtime_flag, int ctime_flag, ARCHD *arcn, struct stat *sbp)
{
	struct stat sb;

	if (sbp == NULL) {
		if (lstat(arcn->name, &sb) != 0)
			return (0);
		sbp = &sb;
	}

	if (ctime_flag && mtime_flag)
		return (timespeccmp(&arcn->sb.st_mtim, &sbp->st_mtim, <=) &&
		        timespeccmp(&arcn->sb.st_ctim, &sbp->st_ctim, <=));
	else if (ctime_flag)
		return (timespeccmp(&arcn->sb.st_ctim, &sbp->st_ctim, <=));
	else
		return (timespeccmp(&arcn->sb.st_mtim, &sbp->st_mtim, <=));
}

d165 1
a168 2
	sltab_start();

d197 1
a197 1
			if (!rd_wrfile(arcn, arcn->type == PAX_GLF
d229 16
a244 4
		if ((uflag || Dflag) &&
		    cmp_file_times(uflag, Dflag, arcn, NULL)) {
			(void)rd_skip(arcn->skip + arcn->pad);
			continue;
d265 16
a280 4
		if ((Yflag || Zflag) &&
		    cmp_file_times(Yflag, Zflag, arcn, NULL)) {
			(void)rd_skip(arcn->skip + arcn->pad);
			continue;
d303 1
a303 1
		if (!PAX_IS_REG(arcn->type)) {
d309 1
a309 1
			if (PAX_IS_HARDLINK(arcn->type))
d337 1
a337 1
		res = rd_wrfile(arcn, fd, &cnt);
d363 2
a364 3
	ar_close(0);
	sltab_process(0);
	proc_dir(0);
d393 1
a393 1
	 * if this is not append, and there are no files, we do not write a
d450 2
a451 1
		if (PAX_IS_REG(arcn->type) || (arcn->type == PAX_HRG)) {
d529 1
a529 1
		res = wr_rdfile(arcn, fd, &cnt);
d558 1
a558 1
	ar_close(0);
d560 1
a560 1
		proc_dir(0);
d755 2
a756 2
	size_t dlen;
	size_t drem;
a761 2
	sltab_start();

d851 8
a858 1
				if (cmp_file_times(uflag, Dflag, arcn, &sb))
d883 11
a893 3
		if ((Yflag || Zflag) &&
		    cmp_file_times(Yflag, Zflag, arcn, NULL))
			continue;
d920 1
a920 1
		if (!PAX_IS_REG(arcn->type)) {
d924 1
a924 1
			if (PAX_IS_HARDLINK(arcn->type))
d972 2
a973 3
	ar_close(0);
	sltab_process(0);
	proc_dir(0);
d1163 1
a1163 1
		if (fsub[ford[i]].name != NULL && fsub[ford[i]].hsz < minhd)
d1214 1
a1214 2
			if (fsub[ford[i]].id == NULL ||
			    (*fsub[ford[i]].id)(hdbuf, hdsz) < 0)
@


1.1.1.6
log
@revert the import; weâ€™ll just backport the CVE fixes, for now â˜¹
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.33 2009/10/27 23:59:22 deraadt Exp $	*/
a39 1
#include <sys/param.h>
d103 1
a103 1
			if (!(*frmt->rd_data)(arcn, arcn->type == PAX_GLF
d147 1
a147 1
	ar_close();
d151 20
a183 1
	struct stat sb;
d187 2
d217 1
a217 1
			if (!(*frmt->rd_data)(arcn, arcn->type == PAX_GLF
d249 4
a252 16
		if ((uflag || Dflag) && ((lstat(arcn->name, &sb) == 0))) {
			if (uflag && Dflag) {
				if ((arcn->sb.st_mtime <= sb.st_mtime) &&
				    (arcn->sb.st_ctime <= sb.st_ctime)) {
					(void)rd_skip(arcn->skip + arcn->pad);
					continue;
				}
			} else if (Dflag) {
				if (arcn->sb.st_ctime <= sb.st_ctime) {
					(void)rd_skip(arcn->skip + arcn->pad);
					continue;
				}
			} else if (arcn->sb.st_mtime <= sb.st_mtime) {
				(void)rd_skip(arcn->skip + arcn->pad);
				continue;
			}
d273 4
a276 16
		if ((Yflag || Zflag) && ((lstat(arcn->name, &sb) == 0))) {
			if (Yflag && Zflag) {
				if ((arcn->sb.st_mtime <= sb.st_mtime) &&
				    (arcn->sb.st_ctime <= sb.st_ctime)) {
					(void)rd_skip(arcn->skip + arcn->pad);
					continue;
				}
			} else if (Yflag) {
				if (arcn->sb.st_ctime <= sb.st_ctime) {
					(void)rd_skip(arcn->skip + arcn->pad);
					continue;
				}
			} else if (arcn->sb.st_mtime <= sb.st_mtime) {
				(void)rd_skip(arcn->skip + arcn->pad);
				continue;
			}
d299 1
a299 1
		if ((arcn->type != PAX_REG) && (arcn->type != PAX_CTG)) {
d305 1
a305 1
			if ((arcn->type == PAX_HLK) || (arcn->type == PAX_HRG))
d333 1
a333 1
		res = (*frmt->rd_data)(arcn, fd, &cnt);
d359 3
a361 2
	ar_close();
	proc_dir();
d390 1
a390 1
	 * if this is not append, and there are no files, we do not write a 
d447 1
a447 2
		if ((arcn->type == PAX_REG) || (arcn->type == PAX_HRG) ||
		    (arcn->type == PAX_CTG)) {
d525 1
a525 1
		res = (*frmt->wr_data)(arcn, fd, &cnt);
d554 1
a554 1
	ar_close();
d556 1
a556 1
		proc_dir();
d751 2
a752 2
	int dlen;
	int drem;
d758 2
d849 1
a849 8
				if (uflag && Dflag) {
					if ((arcn->sb.st_mtime<=sb.st_mtime) &&
					    (arcn->sb.st_ctime<=sb.st_ctime))
						continue;
				} else if (Dflag) {
					if (arcn->sb.st_ctime <= sb.st_ctime)
						continue;
				} else if (arcn->sb.st_mtime <= sb.st_mtime)
d874 3
a876 11
		if ((Yflag || Zflag) && ((lstat(arcn->name, &sb) == 0))) {
			if (Yflag && Zflag) {
				if ((arcn->sb.st_mtime <= sb.st_mtime) &&
				    (arcn->sb.st_ctime <= sb.st_ctime))
					continue;
			} else if (Yflag) {
				if (arcn->sb.st_ctime <= sb.st_ctime)
					continue;
			} else if (arcn->sb.st_mtime <= sb.st_mtime)
				continue;
		}
d903 1
a903 1
		if ((arcn->type != PAX_REG) && (arcn->type != PAX_CTG)) {
d907 1
a907 1
			if ((arcn->type == PAX_HLK) || (arcn->type == PAX_HRG))
d955 3
a957 2
	ar_close();
	proc_dir();
d1147 1
a1147 1
		if (fsub[ford[i]].hsz < minhd)
d1198 2
a1199 1
			if ((*fsub[ford[i]].id)(hdbuf, hdsz) < 0)
@


1.1.1.7
log
@backport OpenBSD pax erratum, more specifically:

â€¢ directory bug, symlinks with -C bug
â€¢ escaping with .. and symlinks
â€¢ tar without -P
â€¢ validate directories touched in the cleanup phase
@
text
@a168 2
	sltab_start();

a363 1
	sltab_process(0);
a761 2
	sltab_start();

a972 1
	sltab_process(0);
@


1.1.1.8
log
@Import latest OpenBSD paxtar, unmodified, into vendor branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_subs.c,v 1.48 2016/08/26 05:06:14 guenther Exp $	*/
d38 1
d40 1
a40 2
#include <errno.h>
#include <fcntl.h>
d42 1
d44 2
a45 2
#include <string.h>
#include <time.h>
d47 1
a47 1

d90 3
d104 1
a104 1
			if (!rd_wrfile(arcn, arcn->type == PAX_GLF
d148 1
a148 1
	ar_close(0);
a151 20
static int
cmp_file_times(int mtime_flag, int ctime_flag, ARCHD *arcn, struct stat *sbp)
{
	struct stat sb;

	if (sbp == NULL) {
		if (lstat(arcn->name, &sb) != 0)
			return (0);
		sbp = &sb;
	}

	if (ctime_flag && mtime_flag)
		return (timespeccmp(&arcn->sb.st_mtim, &sbp->st_mtim, <=) &&
		        timespeccmp(&arcn->sb.st_ctim, &sbp->st_ctim, <=));
	else if (ctime_flag)
		return (timespeccmp(&arcn->sb.st_ctim, &sbp->st_ctim, <=));
	else
		return (timespeccmp(&arcn->sb.st_mtim, &sbp->st_mtim, <=));
}

d165 1
d199 1
a199 1
			if (!rd_wrfile(arcn, arcn->type == PAX_GLF
d231 16
a246 4
		if ((uflag || Dflag) &&
		    cmp_file_times(uflag, Dflag, arcn, NULL)) {
			(void)rd_skip(arcn->skip + arcn->pad);
			continue;
d267 16
a282 4
		if ((Yflag || Zflag) &&
		    cmp_file_times(Yflag, Zflag, arcn, NULL)) {
			(void)rd_skip(arcn->skip + arcn->pad);
			continue;
d305 1
a305 1
		if (!PAX_IS_REG(arcn->type)) {
d311 1
a311 1
			if (PAX_IS_HARDLINK(arcn->type))
d339 1
a339 1
		res = rd_wrfile(arcn, fd, &cnt);
d365 1
a365 1
	ar_close(0);
d367 1
a367 1
	proc_dir(0);
d396 1
a396 1
	 * if this is not append, and there are no files, we do not write a
d453 2
a454 1
		if (PAX_IS_REG(arcn->type) || (arcn->type == PAX_HRG)) {
d532 1
a532 1
		res = wr_rdfile(arcn, fd, &cnt);
d561 1
a561 1
	ar_close(0);
d563 1
a563 1
		proc_dir(0);
d758 2
a759 2
	size_t dlen;
	size_t drem;
d856 8
a863 1
				if (cmp_file_times(uflag, Dflag, arcn, &sb))
d888 11
a898 3
		if ((Yflag || Zflag) &&
		    cmp_file_times(Yflag, Zflag, arcn, NULL))
			continue;
d925 1
a925 1
		if (!PAX_IS_REG(arcn->type)) {
d929 1
a929 1
			if (PAX_IS_HARDLINK(arcn->type))
d977 1
a977 1
	ar_close(0);
d979 1
a979 1
	proc_dir(0);
d1169 1
a1169 1
		if (fsub[ford[i]].name != NULL && fsub[ford[i]].hsz < minhd)
d1220 1
a1220 2
			if (fsub[ford[i]].id == NULL ||
			    (*fsub[ford[i]].id)(hdbuf, hdsz) < 0)
@


1.1.1.8.2.1
log
@Wrangle the OpenBSD branch into shape as starting point:

â€¢ Revert â€œUse the new libc uid_from_user() and gid_from_group()
  instead of the pax-specific functions in cache.câ€ (revisit later)
â€¢ fix MAX_TIME_T (plain wrong), mirtoconf later
â€¢ drop all NOCPIO
â€¢ Revert â€œReplace name_{uid,gid}() with the libc routines
  user_from_uid() and group_from_gid()â€
@
text
@a88 3
	if (vflag && ((uidtb_start() < 0) || (gidtb_start() < 0)))
		return;

@


1.1.1.8.2.2
log
@extremely rudimentary conversion to mirtoconf, doesnâ€™t even build yet
@
text
@a37 8
#if HAVE_BOTH_TIME_H
#include <sys/time.h>
#include <time.h>
#elif HAVE_SYS_TIME_H
#include <sys/time.h>
#elif HAVE_TIME_H
#include <time.h>
#endif
d44 1
a44 3
#if HAVE_STRINGS_H
#include <strings.h>
#endif
@


1.1.1.8.2.3
log
@make inroads on portability
@
text
@d173 2
a174 2
		return (st_mtim_cmp(&arcn->sb, sbp, <=) &&
		    st_ctim_cmp(&arcn->sb, sbp, <=));
d176 1
a176 1
		return (st_ctim_cmp(&arcn->sb, sbp, <=));
d178 1
a178 1
		return (st_mtim_cmp(&arcn->sb, sbp, <=));
@


1.1.1.8.2.4
log
@do the â€˜câ€™s
@
text
@a4 2
 * Copyright (c) 2008, 2011, 2012, 2016
 *	mirabilos <m@@mirbsd.org>
a71 1
int ar_do_keepopen = 0;			/* see append() below */
d113 1
a113 1
			if (!(*frmt->rd_data)(arcn, arcn->type == PAX_GLF
d227 1
a227 1
			if (!(*frmt->rd_data)(arcn, arcn->type == PAX_GLF
d251 1
a251 1
		 * than the file with the same name in the filesystem (no
a295 4
		} else if (Vflag) {
			(void)putc('.', listf);
			(void)fflush(listf);
			vfpart = 1;
d302 1
a302 1
			if (!to_stdout && chdir(arcn->pat->chdname) != 0)
d315 4
a318 8
			if (!to_stdout) {
				if (PAX_IS_HARDLINK(arcn->type)) {
					res = lnk_creat(arcn);
					if (fd != -1)
						goto extdata;
				}else
					res = node_creat(arcn);
			}
d331 1
a331 1
		 * we have a file with data here. If we cannot create it, skip
d334 1
a334 3
		if (to_stdout)
			fd = STDOUT_FILENO;
		else if ((fd = file_creat(arcn)) < 0) {
d343 2
a344 4
 extdata:
		res = (*frmt->rd_data)(arcn, fd, &cnt);
		if (fd != STDOUT_FILENO)
			file_close(arcn, fd);
d352 1
a352 1
 popd:
d357 1
a357 1
			if (!to_stdout && fchdir(cwdfd) != 0)
d412 1
a412 1
	} else if (((*frmt->st_wr)(is_app) < 0))
a501 4
		} else if (Vflag) {
			(void)putc('.', listf);
			(void)fflush(listf);
			vfpart = 1;
d535 1
a535 1
		res = (*frmt->wr_data)(arcn, fd, &cnt);
d552 1
a552 1
 trailer:
a622 4
	/* hack to allow appending to Unix Archiver libraries */
	if (frmt->is_uar)
		ar_do_keepopen = 1;

d748 1
a748 1
 *	copy files from one part of the filesystem to another. this does not
a890 4
		} else if (Vflag) {
			(void)putc('.', listf);
			(void)fflush(listf);
			vfpart = 1;
d918 1
a918 1
				res = lnk_creat(arcn, NULL);
d1033 1
a1033 2
			if ((ret == 0) || (rd_sync() < 0) || frmt->is_uar) {
 no_header:
a1068 3
		if (frmt->is_uar)
			goto no_header;

d1156 2
a1157 2
	for (i = 0; ford[i] != FSUB_MAX; ++i) {
		if (fsub[ford[i]].hsz < minhd)
a1164 14

#ifndef SMALL
	/* try to verify against ar first */
	if (buf_fill_internal(8) == 8) {
		i = rd_wrbuf(hdend, 8);
		if (i == 8 && uar_ismagic(hdbuf) == 0) {
			frmt = &(fsub[FSUB_AR]);
			return (0);
		}
		if (i > 0)
			pback(hdend, i);
	}
#endif

d1207 3
a1209 2
		for (i = 0; ford[i] != FSUB_MAX; ++i) {
			if ((*fsub[ford[i]].id)(hdbuf, hdsz) < 0)
d1251 1
a1251 1
 out:
d1253 1
a1253 1
	 * we cannot find a header, bow, apologise and quit
@


1.1.1.8.2.5
log
@do extern.h, but weâ€™ll have to do something about time values
@
text
@d459 1
a459 1
				ftree_skipped_newer();
d881 1
a881 1
				ftree_skipped_newer();
@


1.1.1.8.2.6
log
@use generic macros, to compensate a bit for this insanity
@
text
@d176 2
a177 2
		return (st_timecmp(m, &arcn->sb, sbp, <=) &&
		    st_timecmp(c, &arcn->sb, sbp, <=));
d179 1
a179 1
		return (st_timecmp(c, &arcn->sb, sbp, <=));
d181 1
a181 1
		return (st_timecmp(m, &arcn->sb, sbp, <=));
@


1.1.1.8.2.7
log
@merge â€˜gâ€™ and switch to a global â€œnowâ€
@
text
@d88 1
d105 2
d143 1
a143 1
				ls_list(arcn, stdout);
d198 1
d219 2
d294 1
a294 1
				ls_list(arcn, listf);
d405 1
d439 2
d512 1
a512 1
				ls_list(arcn, listf);
@


1.1.1.8.2.8
log
@some more tweaks
@
text
@a59 1
#include "ftimes.h"
@


1.1.1.8.2.9
log
@solution for rare open flags, also uses O_BINARY like in mksh
@
text
@d471 3
a473 3
			if ((fd = binopen3(0, arcn->org_name, O_RDONLY, 0)) < 0) {
				syswarn(1, errno, "Unable to open %s to read",
				    arcn->org_name);
d953 1
a953 1
		if ((fdsrc = binopen3(0, arcn->org_name, O_RDONLY, 0)) < 0) {
@


1.1.1.8.2.10
log
@revisit all those initial reverts
@
text
@a101 1
#if !HAVE_UG_FROM_UGID
a103 1
#endif
@


1.1.1.8.2.11
log
@unwarn more
@
text
@d321 1
a321 1
					res = lnk_creat(arcn, &fd);
@


