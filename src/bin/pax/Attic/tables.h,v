head	1.8;
access;
symbols
	paxmirabilis-20171021:1.7
	paxmirabilis-20161104:1.6
	paxmirabilis-20161031:1.6
	paxmirabilis-20161025:1.6
	paxmirabilis-20160306:1.6
	cvs-201603041945:1.1.1.4
	paxmirabilis-20151013:1.4
	paxmirabilis-20140703:1.4
	paxmirabilis-20120606:1.4
	paxmirabilis-20120605:1.4
	cvs-201206051745:1.1.1.3
	paxmirabilis-20120520:1.4
	paxmirabilis-20120216:1.4
	paxmirabilis-20120212:1.4
	cvs-201202112230:1.1.1.3
	paxmirabilis-20110817:1.4
	MIRBSD_10:1.3.0.2
	MIRBSD_10_BASE:1.3
	cvs-200710231945:1.1.1.3
	cvs-200606232242:1.1.1.2
	MIRBSD_9_BASE:1.2
	MIRBSD_8:1.2.0.2
	MIRBSD_8_BASE:1.2
	cvs-200507211800:1.1.1.2
	cvs-200504291700:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2018.12.12.18.08.47;	author tg;	state dead;
branches;
next	1.7;
commitid	1005C114EA81986F5EC;

1.7
date	2017.08.07.20.10.18;	author tg;	state Exp;
branches;
next	1.6;
commitid	1005988C69344442E37;

1.6
date	2016.03.06.14.12.29;	author tg;	state Exp;
branches;
next	1.5;
commitid	10056DC3ADA1858410D;

1.5
date	2016.03.06.13.47.50;	author tg;	state Exp;
branches;
next	1.4;
commitid	10056DC351700BAF310;

1.4
date	2008.11.08.23.03.39;	author tg;	state Exp;
branches;
next	1.3;
commitid	10049161AB22DF5DFC5;

1.3
date	2007.10.23.20.07.42;	author tg;	state Exp;
branches;
next	1.2;
commitid	100471E5499154FE86E;

1.2
date	2005.11.16.13.58.39;	author tg;	state Exp;
branches;
next	1.1;
commitid	63cf437b3768eac1;

1.1
date	2005.02.05.17.22.06;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.22.06;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.29.17.05.16;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.10.23.19.50.48;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	100471E50A5256C77AE;

1.1.1.4
date	2016.03.04.19.46.09;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	10056D9E61429EE6550;

1.1.1.5
date	2016.03.04.20.55.04;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	10056D9F62E152ECBA5;

1.1.1.6
date	2016.03.06.13.29.56;	author tg;	state Exp;
branches;
next	;
commitid	10056DC30960F3F5FA0;


desc
@@


1.8
log
@merge the npax branch into MAIN

asides from a missing dprintf and portability, this ought to be
good enough for people (well me) to play with for now
@
text
@/*	$OpenBSD: tables.h,v 1.8 2006/08/05 23:05:13 ray Exp $	*/
/*	$NetBSD: tables.h,v 1.3 1995/03/21 09:07:47 cgd Exp $	*/

/*-
 * Copyright (c) 2005, 2016
 *	mirabilos <m@@mirbsd.org>
 * Copyright (c) 1992 Keith Muller.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)tables.h	8.1 (Berkeley) 5/31/93
 */

#ifndef MIRCPIO_TABLES_H
#define MIRCPIO_TABLES_H "$MirOS: src/bin/pax/tables.h,v 1.7 2017/08/07 20:10:18 tg Exp $"

/*
 * data structures and constants used by the different databases kept by pax
 */

/*
 * Hash Table Sizes MUST BE PRIME, if set too small performance suffers.
 * Probably safe to expect 500000 inodes per tape. Assuming good key
 * distribution (inodes) chains of under 50 long (worst case) is ok.
 */
#define L_TAB_SZ	2503		/* hard link hash table size */
#define F_TAB_SZ	50503		/* file time hash table size */
#define N_TAB_SZ	541		/* interactive rename hash table */
#define D_TAB_SZ	317		/* unique device mapping table */
#define A_TAB_SZ	317		/* ftree dir access time reset table */
#define SL_TAB_SZ	317		/* escape symlink tables */
#define MAXKEYLEN	64		/* max number of chars for hash */
#define DIRP_SIZE	64		/* initial size of created dir table */

/*
 * file hard link structure (hashed by dev/ino and chained) used to find the
 * hard links in a filesystem or with some archive formats (cpio)
 */
typedef struct hrdlnk {
	char		*name;	/* name of first file seen with this ino/dev */
	dev_t		dev;	/* files device number */
	ino_t		ino;	/* files inode number */
	u_long		nlink;	/* expected link count */
	struct hrdlnk	*fow;
} HRDLNK;

/*
 * Archive write update file time table (the -u, -C flag), hashed by filename.
 * Filenames are stored in a scratch file at seek offset into the file. The
 * file time (mod time) and the file name length (for a quick check) are
 * stored in a hash table node. We were forced to use a scratch file because
 * with -u, the mtime for every node in the archive must always be available
 * to compare against (and this data can get REALLY large with big archives).
 * By being careful to read only when we have a good chance of a match, the
 * performance loss is not measurable (and the size of the archive we can
 * handle is greatly increased).
 */
typedef struct ftm {
	int		namelen;	/* file name length */
	time_t		mtime;		/* files last modification time */
	off_t		seek;		/* location in scratch file */
	struct ftm	*fow;
} FTM;

/*
 * Interactive rename table (-i flag), hashed by orig filename.
 * We assume this will not be a large table as this mapping data can only be
 * obtained through interactive input by the user. Nobody is going to type in
 * changes for 500000 files? We use chaining to resolve collisions.
 */

typedef struct namt {
	char		*oname;		/* old name */
	char		*nname;		/* new name typed in by the user */
	struct namt	*fow;
} NAMT;

/*
 * Unique device mapping tables. Some protocols (e.g. cpio) require that the
 * <c_dev,c_ino> pair will uniquely identify a file in an archive unless they
 * are links to the same file. Appending to archives can break this. For those
 * protocols that have this requirement we map c_dev to a unique value not seen
 * in the archive when we append. We also try to handle inode truncation with
 * this table. (When the inode field in the archive header are too small, we
 * remap the dev on writes to remove accidental collisions).
 *
 * The list is hashed by device number using chain collision resolution. Off of
 * each DEVT are linked the various remaps for this device based on those bits
 * in the inode which were truncated. For example if we are just remapping to
 * avoid a device number during an update append, off the DEVT we would have
 * only a single DLIST that has a truncation id of 0 (no inode bits were
 * stripped for this device so far). When we spot inode truncation we create
 * a new mapping based on the set of bits in the inode which were stripped off.
 * so if the top four bits of the inode are stripped and they have a pattern of
 * 0110...... (where . are those bits not truncated) we would have a mapping
 * assigned for all inodes that has the same 0110.... pattern (with this dev
 * number of course). This keeps the mapping sparse and should be able to store
 * close to the limit of files which can be represented by the optimal
 * combination of dev and inode bits, and without creating a fouled up archive.
 * Note we also remap truncated devs in the same way (an exercise for the
 * dedicated reader; always wanted to say that...:)
 */

typedef struct devt {
	dev_t		dev;	/* the orig device number we now have to map */
	struct devt	*fow;	/* new device map list */
	struct dlist	*list;	/* map list based on inode truncation bits */
} DEVT;

typedef struct dlist {
	ino_t trunc_bits;	/* truncation pattern for a specific map */
	dev_t dev;		/* the new device id we use */
	struct dlist *fow;
} DLIST;

/*
 * ftree directory access time reset table. When we are done with a
 * subtree we reset the access and mod time of the directory when the tflag is
 * set. Not really explicitly specified in the pax spec, but easy and fast to
 * do (and this may have even been intended in the spec, it is not clear).
 * table is hashed by inode with chaining.
 */

typedef struct atdir {
	struct file_times ft;
	struct atdir *fow;
} ATDIR;

/*
 * created directory time and mode storage entry. After pax is finished during
 * extraction or copy, we must reset directory access modes and times that
 * may have been modified after creation (they no longer have the specified
 * times and/or modes). We must reset time in the reverse order of creation,
 * because entries are added  from the top of the file tree to the bottom.
 * We MUST reset times from leaf to root (it will not work the other
 * direction).
 */

typedef struct dirdata {
	struct file_times ft;
	u_int16_t mode;		/* file mode to restore */
	u_int16_t frc_mode;	/* do we force mode settings? */
} DIRDATA;

/*
 * file hard link structure (hashed by dev/ino and chained) for anonymisation
 */
typedef struct hrdflnk {
	dev_t		dev;	/* files device number */
	ino_t		ino;	/* files inode number */
	u_long		nlink;	/* expected link count */
	ino_t		newi;	/* new inode number */
	struct hrdflnk	*fow;
} HRDFLNK;

#endif
@


1.7
log
@filesystem
@
text
@d42 1
a42 1
#define MIRCPIO_TABLES_H "$MirOS: src/bin/pax/tables.h,v 1.6 2016/03/06 14:12:29 tg Exp $"
@


1.6
log
@version the *.h files as idstrings, too
@
text
@d42 1
a42 1
#define MIRCPIO_TABLES_H "$MirOS$"
d64 1
a64 1
 * hard links in a file system or with some archive formats (cpio)
@


1.5
log
@merge CVE fixes from openbsd branch
@
text
@a0 1
/**	$MirOS: src/bin/pax/tables.h,v 1.3 2007/10/23 20:07:42 tg Exp $ */
d5 1
a5 1
 * Copyright (c) 2005
d41 3
d182 2
@


1.4
log
@more mass conversions, including ancient eMail addresses
@
text
@d6 2
a7 1
 * Copyright (c) 2005 Thorsten Glaser <tg@@mirbsd.org>
d56 1
d150 1
a150 5
	char *name;	/* name of directory to reset */
	dev_t dev;	/* dev and inode for fast lookup */
	ino_t ino;
	time_t mtime;	/* access and mod time to reset to */
	time_t atime;
d165 2
a166 4
	char *name;	/* file name */
	time_t mtime;	/* mtime to set */
	time_t atime;	/* atime to set */
	u_int16_t mode;	/* file mode to restore */
@


1.3
log
@merge openbsd changes and fix tar -R, -S flag misdocumentation
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/tables.h,v 1.2 2005/11/16 13:58:39 tg Exp $ */
d6 1
a6 1
 * Copyright (c) 2005 Thorsten Glaser <tg@@66h.42h.de>
@


1.2
log
@* cpio.1: Document sv4crc format for creation and extraction
* cpio.1, pax.1: Document new v4norm and v4root formats for creation only
  (to extract these, the sv4crc driver is being used)
* cpio.c: Add initialisation routines for v4norm and v4root formats
* cpio.c (vcpio_wr): Write c_ino, c_uid, c_gid and c_mtime through a
  layer of indirection, depending on the state of (v4norm) setting them
  to the stat buf value, zero (uid, gid, mtime) or the result of a table
  lookup (inode)
* extern.h: expose new v4norm_stwr, v4root_stwr (cpio.c) and
  flnk_start, chk_flnk (table.c) functions
* options.c: add entries for new formats v4norm, v4root
* tables.c: mirror lnk_start, chk_lnk functions to build up a hard link
  table on archive creation as well, anonymising _all_ inodes stored

(inodes start at 3)
@
text
@d1 2
a2 2
/**	$MirOS$ */
/*	$OpenBSD: tables.h,v 1.7 2004/11/29 16:23:22 otto Exp $	*/
d140 1
a140 1
 * ftree directory access time reset table. When we are done with with a
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$OpenBSD: tables.h,v 1.6 2003/10/20 06:22:27 jmc Exp $	*/
d6 1
d56 1
d163 1
a163 2
 * direction).  Entries are recorded into a spool file to make reverse
 * reading faster.
d167 1
a167 3
	int nlen;	/* length of the directory name (includes \0) */
	off_t npos;	/* position in file where this dir name starts */
	mode_t mode;	/* file mode to restore */
d170 2
a171 1
	int frc_mode;	/* do we force mode settings? */
d173 11
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@improve my Frankenstein OS (*wink* you know who you are) further
sans wchar_t of course

this is the essence of reading >1200 commit messages which suck
due to not having the new format of ours...
@
text
@d1 1
a1 1
/*	$OpenBSD: tables.h,v 1.7 2004/11/29 16:23:22 otto Exp $	*/
a53 1
#define DIRP_SIZE	64		/* initial size of created dir table */
d160 2
a161 1
 * direction).
d165 3
a167 1
	char *name;	/* file name */
d170 1
a170 2
	u_int16_t mode;	/* file mode to restore */
	u_int16_t frc_mode;	/* do we force mode settings? */
@


1.1.1.3
log
@import latest OpenCPIO ☺
@
text
@d1 1
a1 1
/*	$OpenBSD: tables.h,v 1.8 2006/08/05 23:05:13 ray Exp $	*/
d138 1
a138 1
 * ftree directory access time reset table. When we are done with a
@


1.1.1.4
log
@pull newer paxtar from OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: tables.h,v 1.16 2015/03/19 05:14:24 guenther Exp $	*/
a52 1
#define SL_TAB_SZ	317		/* escape symlink tables */
a60 1
	ino_t		ino;	/* files inode number */
d63 1
d80 2
a82 1
	struct timespec	mtim;		/* files last modification time */
a83 1
	int		namelen;	/* file name length */
d146 5
a150 1
	struct file_times ft;
d165 4
a168 2
	struct file_times ft;
	u_int16_t mode;		/* file mode to restore */
@


1.1.1.5
log
@revert the import; we’ll just backport the CVE fixes, for now ☹
@
text
@d1 1
a1 1
/*	$OpenBSD: tables.h,v 1.8 2006/08/05 23:05:13 ray Exp $	*/
d53 1
d62 1
a64 1
	ino_t		ino;	/* files inode number */
a80 2
	int		namelen;	/* file name length */
	time_t		mtime;		/* files last modification time */
d82 1
d84 1
d147 1
a147 5
	char *name;	/* name of directory to reset */
	dev_t dev;	/* dev and inode for fast lookup */
	ino_t ino;
	time_t mtime;	/* access and mod time to reset to */
	time_t atime;
d162 2
a163 4
	char *name;	/* file name */
	time_t mtime;	/* mtime to set */
	time_t atime;	/* atime to set */
	u_int16_t mode;	/* file mode to restore */
@


1.1.1.6
log
@backport OpenBSD pax erratum, more specifically:

• directory bug, symlinks with -C bug
• escaping with .. and symlinks
• tar without -P
• validate directories touched in the cleanup phase
@
text
@d1 1
a1 1
/*	$OpenBSD: tables.h,v 1.13 2015/02/12 23:44:57 guenther Exp $	*/
a52 1
#define SL_TAB_SZ	317		/* escape symlink tables */
d146 5
a150 1
	struct file_times ft;
d165 4
a168 2
	struct file_times ft;
	u_int16_t mode;		/* file mode to restore */
@


