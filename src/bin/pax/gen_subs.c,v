head	1.21;
access;
symbols
	paxmirabilis-20190825:1.21
	paxmirabilis-20190224:1.21
	paxmirabilis-20190210:1.21
	npax:1.1.1.8.0.2
	cvs-20181212:1.1.1.8
	paxmirabilis-20171021:1.19
	paxmirabilis-20161104:1.19
	paxmirabilis-20161031:1.19
	paxmirabilis-20161025:1.19
	paxmirabilis-20160306:1.17
	cvs-201603041945:1.1.1.5
	paxmirabilis-20151013:1.15
	paxmirabilis-20140703:1.15
	paxmirabilis-20120606:1.15
	paxmirabilis-20120605:1.15
	cvs-201206051745:1.1.1.4
	paxmirabilis-20120520:1.12
	paxmirabilis-20120216:1.11
	paxmirabilis-20120212:1.10
	cvs-201202112230:1.1.1.4
	paxmirabilis-20110817:1.9
	MIRBSD_10:1.8.0.2
	MIRBSD_10_BASE:1.8
	cvs-200710231945:1.1.1.3
	cvs-200606232242:1.1.1.2
	MIRBSD_9_BASE:1.5
	MIRBSD_8:1.5.0.2
	MIRBSD_8_BASE:1.5
	cvs-200507211800:1.1.1.2
	cvs-200504291700:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2019.02.10.21.50.07;	author tg;	state Exp;
branches;
next	1.20;
commitid	1005C609C8F43A9BDCB;

1.20
date	2018.12.12.18.08.44;	author tg;	state Exp;
branches;
next	1.19;
commitid	1005C114EA81986F5EC;

1.19
date	2016.10.25.19.04.26;	author tg;	state Exp;
branches;
next	1.18;
commitid	100580FACCE7785F0A8;

1.18
date	2016.10.25.18.57.55;	author tg;	state Exp;
branches;
next	1.17;
commitid	100580FAB4B20AD4FA2;

1.17
date	2016.03.06.15.28.48;	author tg;	state Exp;
branches;
next	1.16;
commitid	10056DC4CBE3BEED25A;

1.16
date	2015.10.14.18.10.08;	author tg;	state Exp;
branches;
next	1.15;
commitid	100561E9A905398529C;

1.15
date	2012.06.05.20.20.39;	author tg;	state Exp;
branches;
next	1.14;
commitid	1004FCE6A2D1028EF82;

1.14
date	2012.06.05.18.15.58;	author tg;	state Exp;
branches;
next	1.13;
commitid	1004FCE4CF50152FFC2;

1.13
date	2012.06.05.18.13.49;	author tg;	state Exp;
branches;
next	1.12;
commitid	1004FCE4C7439736DC4;

1.12
date	2012.05.20.16.13.17;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004FB918314D2FECC0;

1.11
date	2012.02.16.17.11.45;	author tg;	state Exp;
branches;
next	1.10;
commitid	1004F3D38626EFD0781;

1.10
date	2012.02.12.00.27.16;	author tg;	state Exp;
branches;
next	1.9;
commitid	1004F3707786D20BF4A;

1.9
date	2008.03.14.15.55.21;	author tg;	state Exp;
branches;
next	1.8;
commitid	10047DA9FD457B61B40;

1.8
date	2007.10.23.20.07.42;	author tg;	state Exp;
branches;
next	1.7;
commitid	100471E5499154FE86E;

1.7
date	2007.02.17.04.52.40;	author tg;	state Exp;
branches;
next	1.6;
commitid	10045D68A2D54E2C558;

1.6
date	2006.07.16.17.58.08;	author tg;	state Exp;
branches;
next	1.5;
commitid	10044BA7E292C5FD865;

1.5
date	2005.04.29.18.34.44;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2005.04.13.20.11.24;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2005.04.13.20.03.35;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.04.13.19.49.34;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.22.06;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.22.06;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.29.17.05.15;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.10.23.19.50.48;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	100471E50A5256C77AE;

1.1.1.4
date	2012.02.11.22.47.21;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	1004F36F008225F3522;

1.1.1.5
date	2016.03.04.19.46.09;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	10056D9E61429EE6550;

1.1.1.6
date	2016.03.04.20.55.00;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	10056D9F62E152ECBA5;

1.1.1.7
date	2016.10.25.18.46.10;	author tg;	state Exp;
branches;
next	1.1.1.8;
commitid	100580FA88137705D31;

1.1.1.8
date	2018.12.12.00.24.23;	author tg;	state Exp;
branches
	1.1.1.8.2.1;
next	;
commitid	1005C1055452C78F9E4;

1.1.1.8.2.1
date	2018.12.12.00.52.58;	author tg;	state Exp;
branches;
next	1.1.1.8.2.2;
commitid	1005C105BC86262A0B7;

1.1.1.8.2.2
date	2018.12.12.03.13.32;	author tg;	state Exp;
branches;
next	1.1.1.8.2.3;
commitid	1005C107CE315DC51F3;

1.1.1.8.2.3
date	2018.12.12.09.08.56;	author tg;	state Exp;
branches;
next	1.1.1.8.2.4;
commitid	1005C10D0381A00BE25;

1.1.1.8.2.4
date	2018.12.12.16.24.28;	author tg;	state Exp;
branches;
next	;
commitid	1005C11364A797CBA33;


desc
@@


1.21
log
@port to Debian sid/{amd64,i386,hurd-i386,x32}, {stretch,jessie}/{amd64,i386}
@
text
@/*	$OpenBSD: gen_subs.c,v 1.32 2016/08/26 05:06:14 guenther Exp $	*/
/*	$NetBSD: gen_subs.c,v 1.5 1995/03/21 09:07:26 cgd Exp $	*/

/*-
 * Copyright (c) 2012, 2015, 2016, 2019
 *	mirabilos <m@@mirbsd.org>
 * Copyright (c) 1992 Keith Muller.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#if HAVE_BOTH_TIME_H
#include <sys/time.h>
#include <time.h>
#elif HAVE_SYS_TIME_H
#include <sys/time.h>
#elif HAVE_TIME_H
#include <time.h>
#endif
#include <sys/stat.h>
#if HAVE_GRP_H
#include <grp.h>
#endif
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if HAVE_STRINGS_H
#include <strings.h>
#endif
#include <unistd.h>
#if HAVE_UTMP_H
#include <utmp.h>
#elif HAVE_UTMPX_H
#include <utmpx.h>
#endif
#if HAVE_VIS_H
#include <vis.h>
#endif

#include "pax.h"
#include "extern.h"

__RCSID("$MirOS: src/bin/pax/gen_subs.c,v 1.20 2018/12/12 18:08:44 tg Exp $");

/*
 * a collection of general purpose subroutines used by pax
 */

/*
 * constants used by ls_list() when printing out archive members
 */
#define MODELEN 20
#define DATELEN 64
#define SIXMONTHS	(24 * 60 * 60 * 365 / 2)
#define CURFRMT		"%b %e %H:%M"
#define OLDFRMT		"%b %e  %Y"
#define NAME_WIDTH	8
#define	TIMEFMT(t) \
	(((t) + SIXMONTHS <= now || (t) > now) ? OLDFRMT : CURFRMT)

/*
 * ls_list()
 *	list the members of an archive in ls format
 */

void
ls_list(ARCHD *arcn, FILE *fp)
{
	struct stat *sbp;
	char f_mode[MODELEN];
	char f_date[DATELEN];
	int term;

	term = zeroflag ? '\0' : '\n';	/* path termination character */

	/*
	 * if not verbose, just print the file name
	 */
	if (!vflag) {
		if (zeroflag)
			(void)fputs(arcn->name, fp);
		else
			safe_print(arcn->name, fp);
		(void)putc(term, fp);
		(void)fflush(fp);
		return;
	}

	/*
	 * user wants long mode
	 */
	sbp = &(arcn->sb);
	strmode(sbp->st_mode, f_mode);

	/*
	 * print file mode, link count, uid, gid and time
	 */
	if (strftime(f_date, sizeof(f_date), TIMEFMT(sbp->st_mtime),
	    localtime(&(sbp->st_mtime))) == 0)
		f_date[0] = '\0';
	(void)fprintf(fp, "%s%2u %-*.*s %-*.*s ", f_mode,
	    (unsigned int)sbp->st_nlink,
	    NAME_WIDTH, UT_NAMESIZE, name_uid(sbp->st_uid, 1),
	    NAME_WIDTH, UT_NAMESIZE, name_gid(sbp->st_gid, 1));

	/*
	 * print device id's for devices, or sizes for other nodes
	 */
	if ((arcn->type == PAX_CHR) || (arcn->type == PAX_BLK))
		(void)fprintf(fp, "%4lu, %4lu ",
		    (unsigned long)MAJOR(sbp->st_rdev),
		    (unsigned long)MINOR(sbp->st_rdev));
	else
		(void)fprintf(fp, "%9" OT_FMT " ", sbp->st_size);

	/*
	 * print name and link info for hard and soft links
	 */
	(void)fputs(f_date, fp);
	(void)putc(' ', fp);
	safe_print(arcn->name, fp);
	if (PAX_IS_HARDLINK(arcn->type)) {
		fputs(" == ", fp);
		safe_print(arcn->ln_name, fp);
	} else if (arcn->type == PAX_SLK) {
		fputs(" -> ", fp);
		safe_print(arcn->ln_name, fp);
	}
	(void)putc(term, fp);
	(void)fflush(fp);
}

/*
 * tty_ls()
 *	print a short summary of file to tty.
 */

void
ls_tty(ARCHD *arcn)
{
	char f_date[DATELEN];
	char f_mode[MODELEN];

	/*
	 * convert time to string, and print
	 */
	if (strftime(f_date, DATELEN, TIMEFMT(arcn->sb.st_mtime),
	    localtime(&(arcn->sb.st_mtime))) == 0)
		f_date[0] = '\0';
	strmode(arcn->sb.st_mode, f_mode);
	tty_prnt("%s%s %s\n", f_mode, f_date, arcn->name);
}

void
safe_print(const char *str, FILE *fp)
{
#if HAVE_VIS_H
	char visbuf[5];
	const char *cp;

	/*
	 * if printing to a tty, use vis(3) to print special characters.
	 */
	if (isatty(fileno(fp))) {
		for (cp = str; *cp; cp++) {
			(void)vis(visbuf, cp[0], VIS_CSTYLE, cp[1]);
			(void)fputs(visbuf, fp);
		}
	} else
#endif
		(void)fputs(str, fp);
}

/*
 * asc_ul()
 *	convert hex/octal character string into a u_long. We do not have to
 *	check for overflow! (the headers in all supported formats are not large
 *	enough to create an overflow).
 *	NOTE: strings passed to us are NOT TERMINATED.
 * Return:
 *	unsigned long value
 */

u_long
asc_ul(char *str, int len, int base)
{
	char *stop;
	u_long tval = 0;

	stop = str + len;

	/*
	 * skip over leading blanks and zeros
	 */
	while ((str < stop) && ((*str == ' ') || (*str == '0')))
		++str;

	/*
	 * for each valid digit, shift running value (tval) over to next digit
	 * and add next digit
	 */
	if (base == HEX) {
		while (str < stop) {
			if ((*str >= '0') && (*str <= '9'))
				tval = (tval << 4) + (*str++ - '0');
			else if ((*str >= 'A') && (*str <= 'F'))
				tval = (tval << 4) + 10 + (*str++ - 'A');
			else if ((*str >= 'a') && (*str <= 'f'))
				tval = (tval << 4) + 10 + (*str++ - 'a');
			else
				break;
		}
	} else {
		while ((str < stop) && (*str >= '0') && (*str <= '7'))
			tval = (tval << 3) + (*str++ - '0');
	}
	return(tval);
}

/*
 * ul_asc()
 *	convert an unsigned long into an hex/oct ascii string. pads with LEADING
 *	ascii 0's to fill string completely
 *	NOTE: the string created is NOT TERMINATED.
 */

int
ul_asc(u_long val, char *str, int len, int base)
{
	char *pt;
	u_long digit;

	/*
	 * WARNING str is not '\0' terminated by this routine
	 */
	pt = str + len - 1;

	/*
	 * do a tailwise conversion (start at right most end of string to place
	 * least significant digit). Keep shifting until conversion value goes
	 * to zero (all digits were converted)
	 */
	if (base == HEX) {
		while (pt >= str) {
			if ((digit = (val & 0xf)) < 10)
				*pt-- = '0' + (char)digit;
			else
				*pt-- = 'a' + (char)(digit - 10);
			val >>= 4;
			if (val == 0)
				break;
		}
	} else {
		while (pt >= str) {
			*pt-- = '0' + (char)(val & 0x7);
			val >>= 3;
			if (val == 0)
				break;
		}
	}

	/*
	 * pad with leading ascii ZEROS. We return -1 if we ran out of space.
	 */
	while (pt >= str)
		*pt-- = '0';
	if (val != 0)
		return(-1);
	return(0);
}

/*
 * asc_ull()
 *	Convert hex/octal character string into a unsigned long long.
 *	We do not have to check for overflow!  (The headers in all
 *	supported formats are not large enough to create an overflow).
 *	NOTE: strings passed to us are NOT TERMINATED.
 * Return:
 *	unsigned long long value
 */

unsigned long long
asc_ull(char *str, int len, int base)
{
	char *stop;
	unsigned long long tval = 0;

	stop = str + len;

	/*
	 * skip over leading blanks and zeros
	 */
	while ((str < stop) && ((*str == ' ') || (*str == '0')))
		++str;

	/*
	 * for each valid digit, shift running value (tval) over to next digit
	 * and add next digit
	 */
	if (base == HEX) {
		while (str < stop) {
			if ((*str >= '0') && (*str <= '9'))
				tval = (tval << 4) + (*str++ - '0');
			else if ((*str >= 'A') && (*str <= 'F'))
				tval = (tval << 4) + 10 + (*str++ - 'A');
			else if ((*str >= 'a') && (*str <= 'f'))
				tval = (tval << 4) + 10 + (*str++ - 'a');
			else
				break;
		}
	} else {
		while ((str < stop) && (*str >= '0') && (*str <= '7'))
			tval = (tval << 3) + (*str++ - '0');
	}
	return(tval);
}

/*
 * ull_asc()
 *	Convert an unsigned long long into a hex/oct ascii string.
 *	Pads with LEADING ascii 0's to fill string completely
 *	NOTE: the string created is NOT TERMINATED.
 */

int
ull_asc(unsigned long long val, char *str, int len, int base)
{
	char *pt;
	unsigned long long digit;

	/*
	 * WARNING str is not '\0' terminated by this routine
	 */
	pt = str + len - 1;

	/*
	 * do a tailwise conversion (start at right most end of string to place
	 * least significant digit). Keep shifting until conversion value goes
	 * to zero (all digits were converted)
	 */
	if (base == HEX) {
		while (pt >= str) {
			if ((digit = (val & 0xf)) < 10)
				*pt-- = '0' + (char)digit;
			else
				*pt-- = 'a' + (char)(digit - 10);
			val >>= 4;
			if (val == 0)
				break;
		}
	} else {
		while (pt >= str) {
			*pt-- = '0' + (char)(val & 0x7);
			val >>= 3;
			if (val == 0)
				break;
		}
	}

	/*
	 * pad with leading ascii ZEROS. We return -1 if we ran out of space.
	 */
	while (pt >= str)
		*pt-- = '0';
	if (val != 0)
		return(-1);
	return(0);
}

/*
 * Copy at max min(bufz, fieldsz) chars from field to buf, stopping
 * at the first NUL char. NUL terminate buf if there is room left.
 */
size_t
fieldcpy(char *buf, size_t bufsz, const char *field, size_t fieldsz)
{
	char *p = buf;
	const char *q = field;
	size_t i = 0;

	if (fieldsz > bufsz)
		fieldsz = bufsz;
	while (i < fieldsz && *q != '\0') {
		*p++ = *q++;
		i++;
	}
	if (i < bufsz)
		*p = '\0';
	return(i);
}
@


1.20
log
@merge the npax branch into MAIN

asides from a missing dprintf and portability, this ought to be
good enough for people (well me) to play with for now
@
text
@d5 1
a5 1
 * Copyright (c) 2012, 2015, 2016
d72 1
a72 1
__RCSID("$MirOS: src/bin/pax/gen_subs.c,v 1.18 2016/10/25 18:57:55 tg Exp $");
d143 1
a143 1
		(void)fprintf(fp, "%9llu ", sbp->st_size);
@


1.19
log
@remove all <tzfile.h> remains
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.20 +1.27 2009/10/27 23:59:22 deraadt Exp $	*/
d39 2
a40 1
#include <sys/param.h>
d42 6
d49 4
d54 9
a62 1
#ifdef __INTERIX
a63 2
#else
#include <utmp.h>
d65 1
a65 5
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#ifdef HAVE_VIS
d68 1
d83 1
a83 1
#define SIXMONTHS	(86400 * 365 / 2)
d87 2
d96 1
a96 1
ls_list(ARCHD *arcn, time_t now, FILE *fp)
d127 2
a128 2
	if (strftime(f_date, DATELEN, ((sbp->st_mtime + SIXMONTHS) <= now) ?
	    OLDFRMT : CURFRMT, localtime(&(sbp->st_mtime))) == 0)
d131 3
a133 3
		(unsigned)sbp->st_nlink,
		NAME_WIDTH, UT_NAMESIZE, name_uid(sbp->st_uid, 1),
		NAME_WIDTH, UT_NAMESIZE, name_gid(sbp->st_gid, 1));
d139 2
a140 1
		(void)fprintf(fp, "%4lu,%4lu ", (unsigned long)MAJOR(sbp->st_rdev),
d143 1
a143 1
		(void)fprintf(fp, "%9" OT_FMT " ", (ot_type)sbp->st_size);
d151 1
a151 1
	if ((arcn->type == PAX_HLK) || (arcn->type == PAX_HRG)) {
a159 1
	return;
d176 2
a177 3
	if (strftime(f_date, DATELEN,
	    ((arcn->sb.st_mtime + SIXMONTHS) <= time(NULL)) ? OLDFRMT :
	    CURFRMT, localtime(&(arcn->sb.st_mtime))) == 0)
a180 1
	return;
d186 1
a186 1
#ifdef HAVE_VIS
d278 2
a279 1
			if ((val = (val >> 4)) == (u_long)0)
d285 2
a286 1
			if ((val = (val >> 3)) == (u_long)0)
d296 1
a296 1
	if (val != (u_long)0)
d302 4
a305 4
 * asc_ot()
 *	convert hex/octal character string into a ot_type. We do not have
 *	to check for overflow! (the headers in all supported formats are
 *	not large enough to create an overflow).
d308 1
a308 1
 *	ot_type value
d311 2
a312 2
ot_type
asc_ot(char *str, int len, int base)
d315 1
a315 1
	ot_type tval = 0;
d344 1
a344 1
	return (tval);
d348 3
a350 3
 * ot_asc()
 *	convert an ot_type into a hex/oct ascii string.
 *	pads with LEADING ascii 0s to fill string completely.
d355 1
a355 1
ot_asc(ot_type val, char *str, int len, int base)
d358 1
a358 1
	ot_type digit;
d376 2
a377 1
			if ((val = (val >> 4)) == (ot_type)0)
d383 2
a384 1
			if ((val = (val >> 3)) == (ot_type)0)
d394 3
a396 3
	if (val != (ot_type)0)
		return (-1);
	return (0);
a419 12

#ifndef HAVE_STRMODE
#include ".linked/strmode.inc"
#endif

#ifndef HAVE_STRLCPY
#undef WIDEC
#define OUTSIDE_OF_LIBKERN
#define L_strlcat
#define L_strlcpy
#include ".linked/strlfun.inc"
#endif
@


1.18
log
@fastmerge
@
text
@d58 1
a58 1
__RCSID("$MirOS: src/bin/pax/gen_subs.c,v 1.17 2016/03/06 15:28:48 tg Exp $");
d69 1
a69 2
#define SECSPERDAY	(24 * 60 * 60)
#define SIXMONTHS	(SECSPERDAY * 365 / 2)
@


1.17
log
@gcc on Debian complains about non-literal format strings; trivial fix
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.20 2009/10/27 23:59:22 deraadt Exp $	*/
d58 1
a58 1
__RCSID("$MirOS: src/bin/pax/gen_subs.c,v 1.15 2012/06/05 20:20:39 tg Exp $");
d69 2
a70 1
#define SIXMONTHS	 ((DAYSPERNYEAR / 2) * SECSPERDAY)
@


1.16
log
@end this nonsense locally, until the next obsd import
@
text
@d5 1
a5 1
 * Copyright (c) 2012, 2015
a84 1
	const char *timefrmt;
a107 5
	if ((sbp->st_mtime + SIXMONTHS) <= now)
		timefrmt = OLDFRMT;
	else
		timefrmt = CURFRMT;

d111 2
a112 1
	if (strftime(f_date,DATELEN,timefrmt,localtime(&(sbp->st_mtime))) == 0)
a155 6
	const char *timefrmt;

	if ((arcn->sb.st_mtime + SIXMONTHS) <= time(NULL))
		timefrmt = OLDFRMT;
	else
		timefrmt = CURFRMT;
d160 3
a162 2
	if (strftime(f_date, DATELEN, timefrmt,
	    localtime(&(arcn->sb.st_mtime))) == 0)
@


1.15
log
@oops, forgot…
@
text
@d5 2
a6 2
 * Copyright (c) 2012
 *	Thorsten Glaser <tg@@debian.org>
d58 1
a58 1
__RCSID("$MirOS: src/bin/pax/gen_subs.c,v 1.14 2012/06/05 18:15:58 tg Exp $");
d109 4
a112 11
	if (ltmfrmt == NULL) {
		/*
		 * no locale specified format. time format based on age
		 * compared to the time pax was started.
		 */
		if ((sbp->st_mtime + SIXMONTHS) <= now)
			timefrmt = OLDFRMT;
		else
			timefrmt = CURFRMT;
	} else
		timefrmt = ltmfrmt;
d163 4
a166 10
	if (ltmfrmt == NULL) {
		/*
		 * no locale specified format
		 */
		if ((arcn->sb.st_mtime + SIXMONTHS) <= time(NULL))
			timefrmt = OLDFRMT;
		else
			timefrmt = CURFRMT;
	} else
		timefrmt = ltmfrmt;
@


1.14
log
@HAVE_VIS, too
@
text
@d58 1
a58 1
__RCSID("$MirOS: src/bin/pax/gen_subs.c,v 1.13 2012/06/05 18:13:49 tg Exp $");
d435 1
@


1.13
log
@hook symlinked-into-here portability code as glue
@
text
@d52 1
a52 1
#ifndef __GLIBC__
d58 1
a58 1
__RCSID("$MirOS: src/bin/pax/gen_subs.c,v 1.12 2012/05/20 16:13:17 tg Exp $");
d195 1
a195 1
#ifndef __GLIBC__
@


1.12
log
@get rid of extern.h including other headers
@
text
@d58 1
a58 5
__RCSID("$MirOS: src/bin/pax/gen_subs.c,v 1.11 2012/02/16 17:11:45 tg Exp $");

#ifdef __GLIBC__
void strmode(mode_t, char *);
#endif
d425 11
@


1.11
log
@Debian GNU/kFreeBSD can be more difficult to deal with than GNU/Hurd at times.

• switch from quad_t to using unsigned long / unsigned long long
• sanitise use of off_t-relevant types
• cast when printing off_t; use a once-defined type and format specifier
• convert “This define is important” into actual compile-time assertion
• simplify ifdef mess by always defining off_t specific routines
  instead of reusing those for long if off_t is just long
@
text
@d51 1
d58 1
a58 1
__RCSID("$MirOS: src/bin/pax/gen_subs.c,v 1.10 2012/02/12 00:27:16 tg Exp $");
@


1.10
log
@merge OpenBSD
@
text
@d5 2
d57 1
a57 1
__RCSID("$MirOS: src/bin/pax/gen_subs.c,v 1.9 2008/03/14 15:55:21 tg Exp $");
d140 2
a141 7
	else {
#		ifdef LONG_OFF_T
		(void)fprintf(fp, "%9lu ", sbp->st_size);
#		else
		(void)fprintf(fp, "%9llu ", sbp->st_size);
#		endif
	}
a310 1
#ifndef LONG_OFF_T
d312 4
a315 4
 * asc_uqd()
 *	convert hex/octal character string into a u_quad_t. We do not have to
 *	check for overflow! (the headers in all supported formats are not large
 *	enough to create an overflow).
d318 1
a318 1
 *	u_quad_t value
d321 2
a322 2
u_quad_t
asc_uqd(char *str, int len, int base)
d325 1
a325 1
	u_quad_t tval = 0;
d354 1
a354 1
	return(tval);
d358 3
a360 3
 * uqd_asc()
 *	convert an u_quad_t into a hex/oct ascii string. pads with LEADING
 *	ascii 0's to fill string completely
d365 1
a365 1
uqd_asc(u_quad_t val, char *str, int len, int base)
d368 1
a368 1
	u_quad_t digit;
d386 1
a386 1
			if ((val = (val >> 4)) == (u_quad_t)0)
d392 1
a392 1
			if ((val = (val >> 3)) == (u_quad_t)0)
d402 3
a404 3
	if (val != (u_quad_t)0)
		return(-1);
	return(0);
a405 1
#endif
@


1.9
log
@remove dependency on <tzfile.h> for portable MirCpio

while I don't think the number of seconds per hour is ever going to
change, and preprocessor definitions for that are pointless, I keep
them because BSD policy is to not have magic numbers all over the code
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.19 2007/04/04 21:55:10 millert Exp $	*/
d55 1
a55 2
__SCCSID("@@(#)gen_subs.c	8.1 (Berkeley) 5/31/93");
__RCSID("$MirOS: src/bin/pax/gen_subs.c,v 1.8 2007/10/23 20:07:42 tg Exp $");
@


1.8
log
@merge openbsd changes and fix tar -R, -S flag misdocumentation
@
text
@a40 1
#include <tzfile.h>
d56 1
a56 1
__RCSID("$MirOS: src/bin/pax/gen_subs.c,v 1.7 2007/02/17 04:52:40 tg Exp $");
@


1.7
log
@__CRAZY clean
@
text
@d1 1
a1 2
/**	$MirOS: src/bin/pax/gen_subs.c,v 1.6 2006/07/16 17:58:08 tg Exp $ */
/*	$OpenBSD: gen_subs.c,v 1.18 2005/04/28 06:58:07 otto Exp $	*/
d57 1
a57 1
__RCSID("$MirOS: src/bin/pax/gen_subs.c,v 1.6 2006/07/16 17:58:08 tg Exp $");
d158 1
a158 1
		fputs(" => ", fp);
@


1.6
log
@glibc doesn't do vis(3) and requires our strmode(3)
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/gen_subs.c,v 1.5 2005/04/29 18:34:44 tg Exp $ */
d38 1
a38 1
#include <sys/types.h>
a40 1
#include <sys/param.h>
d58 1
a58 1
__RCSID("$MirOS: src/bin/pax/gen_subs.c,v 1.5 2005/04/29 18:34:44 tg Exp $");
d145 1
a145 1
		(void)fprintf(fp, "%9qu ", sbp->st_size);
@


1.5
log
@(tentative) merge, more to come
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/gen_subs.c,v 1.4 2005/04/13 20:11:24 tg Exp $ */
d52 1
d54 1
d59 5
a63 1
__RCSID("$MirOS: src/bin/pax/gen_subs.c,v 1.4 2005/04/13 20:11:24 tg Exp $");
d205 1
d217 2
a218 1
	} else {
a219 1
	}
@


1.4
log
@portability fix: long = off_t
XXX does this mean interix is worse than Linux wrt large files?
@
text
@d1 2
a2 2
/**	$MirOS: src/bin/pax/gen_subs.c,v 1.3 2005/04/13 20:03:35 tg Exp $ */
/*	$OpenBSD: gen_subs.c,v 1.17 2003/06/13 17:51:14 millert Exp $	*/
d57 1
a57 1
__RCSID("$MirOS: src/bin/pax/gen_subs.c,v 1.3 2005/04/13 20:03:35 tg Exp $");
d408 22
@


1.3
log
@these are the compile time fixes
this commit message provided by interix ;)
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/gen_subs.c,v 1.2 2005/04/13 19:49:34 tg Exp $ */
d57 1
a57 1
__RCSID("$MirOS$");
d125 2
a126 1
	(void)fprintf(fp, "%s%2u %-*.*s %-*.*s ", f_mode, sbp->st_nlink,
a133 3
#		ifdef LONG_OFF_T
		(void)fprintf(fp, "%4u,%4u ", MAJOR(sbp->st_rdev),
#		else
a134 1
#		endif
@


1.2
log
@first the compile fixes. later, link fixes will follow.
@
text
@d1 1
a1 1
/**	$MirOS$ */
a37 8
#ifndef lint
#if 0
static const char sccsid[] = "@@(#)gen_subs.c	8.1 (Berkeley) 5/31/93";
#else
static const char rcsid[] = "$OpenBSD: gen_subs.c,v 1.17 2003/06/13 17:51:14 millert Exp $";
#endif
#endif /* not lint */

d56 3
@


1.1
log
@Initial revision
@
text
@d1 1
d52 3
d56 1
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@improve my Frankenstein OS (*wink* you know who you are) further
sans wchar_t of course

this is the essence of reading >1200 commit messages which suck
due to not having the new format of ours...
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.18 2005/04/28 06:58:07 otto Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: gen_subs.c,v 1.18 2005/04/28 06:58:07 otto Exp $";
a410 22

/*
 * Copy at max min(bufz, fieldsz) chars from field to buf, stopping
 * at the first NUL char. NUL terminate buf if there is room left.
 */
size_t
fieldcpy(char *buf, size_t bufsz, const char *field, size_t fieldsz)
{
	char *p = buf;
	const char *q = field;
	size_t i = 0;

	if (fieldsz > bufsz)
		fieldsz = bufsz;
	while (i < fieldsz && *q != '\0') {
		*p++ = *q++;
		i++;
	}
	if (i < bufsz)
		*p = '\0';
	return(i);
}
@


1.1.1.3
log
@import latest OpenCPIO ☺
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.19 2007/04/04 21:55:10 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: gen_subs.c,v 1.19 2007/04/04 21:55:10 millert Exp $";
d157 1
a157 1
		fputs(" -> ", fp);
@


1.1.1.4
log
@import up-to-date pax from OpenBSD 5.1-current
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.20 2009/10/27 23:59:22 deraadt Exp $	*/
d37 8
@


1.1.1.5
log
@pull newer paxtar from OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.28 2015/03/17 03:23:17 guenther Exp $	*/
d40 1
d42 1
d60 1
a60 2
#define SECSPERDAY	(24 * 60 * 60)
#define SIXMONTHS	(SECSPERDAY * 365 / 2)
a63 2
#define	TIMEFMT(t, now) \
	(((t) + SIXMONTHS <= (now) || (t) > (now)) ? OLDFRMT : CURFRMT)
d76 1
d100 12
d115 1
a115 2
	if (strftime(f_date, sizeof(f_date), TIMEFMT(sbp->st_mtime, now),
	    localtime(&(sbp->st_mtime))) == 0)
d125 5
a129 2
		(void)fprintf(fp, "%4lu, %4lu ",
		    (unsigned long)MAJOR(sbp->st_rdev),
d132 5
a136 1
		(void)fprintf(fp, "%9llu ", sbp->st_size);
d145 1
a145 1
	if (PAX_IS_HARDLINK(arcn->type)) {
d154 1
d167 12
a178 1
	time_t now = time(NULL);
d183 1
a183 1
	if (strftime(f_date, DATELEN, TIMEFMT(arcn->sb.st_mtime, now),
d188 1
d306 1
d402 1
@


1.1.1.6
log
@revert the import; we’ll just backport the CVE fixes, for now ☹
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.20 2009/10/27 23:59:22 deraadt Exp $	*/
a39 1
#include <sys/param.h>
a40 1
#include <tzfile.h>
d58 2
a59 1
#define SIXMONTHS	 ((DAYSPERNYEAR / 2) * SECSPERDAY)
d63 2
a76 1
	const char *timefrmt;
a99 12
	if (ltmfrmt == NULL) {
		/*
		 * no locale specified format. time format based on age
		 * compared to the time pax was started.
		 */
		if ((sbp->st_mtime + SIXMONTHS) <= now)
			timefrmt = OLDFRMT;
		else
			timefrmt = CURFRMT;
	} else
		timefrmt = ltmfrmt;

d103 2
a104 1
	if (strftime(f_date,DATELEN,timefrmt,localtime(&(sbp->st_mtime))) == 0)
d114 2
a115 5
#		ifdef LONG_OFF_T
		(void)fprintf(fp, "%4u,%4u ", MAJOR(sbp->st_rdev),
#		else
		(void)fprintf(fp, "%4lu,%4lu ", (unsigned long)MAJOR(sbp->st_rdev),
#		endif
d118 1
a118 5
#		ifdef LONG_OFF_T
		(void)fprintf(fp, "%9lu ", sbp->st_size);
#		else
		(void)fprintf(fp, "%9qu ", sbp->st_size);
#		endif
d127 1
a127 1
	if ((arcn->type == PAX_HLK) || (arcn->type == PAX_HRG)) {
a135 1
	return;
d148 1
a148 12
	const char *timefrmt;

	if (ltmfrmt == NULL) {
		/*
		 * no locale specified format
		 */
		if ((arcn->sb.st_mtime + SIXMONTHS) <= time(NULL))
			timefrmt = OLDFRMT;
		else
			timefrmt = CURFRMT;
	} else
		timefrmt = ltmfrmt;
d153 1
a153 1
	if (strftime(f_date, DATELEN, timefrmt,
a157 1
	return;
a274 1
#ifndef LONG_OFF_T
a369 1
#endif
@


1.1.1.7
log
@bunch of cherry-picks from OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.20 +1.27 2009/10/27 23:59:22 deraadt Exp $	*/
d42 1
d60 1
a60 2
#define SECSPERDAY	(24 * 60 * 60)
#define SIXMONTHS	(SECSPERDAY * 365 / 2)
@


1.1.1.8
log
@Import latest OpenBSD paxtar, unmodified, into vendor branch
@
text
@d1 1
a1 1
/*	$OpenBSD: gen_subs.c,v 1.32 2016/08/26 05:06:14 guenther Exp $	*/
d38 1
d40 1
a40 2
#include <grp.h>
#include <pwd.h>
d42 2
a45 3
#include <time.h>
#include <unistd.h>
#include <utmp.h>
a46 1

a63 2
#define	TIMEFMT(t, now) \
	(((t) + SIXMONTHS <= (now) || (t) > (now)) ? OLDFRMT : CURFRMT)
d76 1
d100 12
d115 1
a115 2
	if (strftime(f_date, sizeof(f_date), TIMEFMT(sbp->st_mtime, now),
	    localtime(&(sbp->st_mtime))) == 0)
d118 2
a119 2
		NAME_WIDTH, UT_NAMESIZE, user_from_uid(sbp->st_uid, 0),
		NAME_WIDTH, UT_NAMESIZE, group_from_gid(sbp->st_gid, 0));
d125 5
a129 2
		(void)fprintf(fp, "%4lu, %4lu ",
		    (unsigned long)MAJOR(sbp->st_rdev),
d132 5
a136 1
		(void)fprintf(fp, "%9llu ", sbp->st_size);
d145 1
a145 1
	if (PAX_IS_HARDLINK(arcn->type)) {
d154 1
d167 12
a178 1
	time_t now = time(NULL);
d183 1
a183 1
	if (strftime(f_date, DATELEN, TIMEFMT(arcn->sb.st_mtime, now),
d188 1
d285 1
a285 2
			val >>= 4;
			if (val == 0)
d291 1
a291 2
			val >>= 3;
			if (val == 0)
d301 1
a301 1
	if (val != 0)
d306 1
d308 4
a311 4
 * asc_ull()
 *	Convert hex/octal character string into a unsigned long long.
 *	We do not have to check for overflow!  (The headers in all
 *	supported formats are not large enough to create an overflow).
d314 1
a314 1
 *	unsigned long long value
d317 2
a318 2
unsigned long long
asc_ull(char *str, int len, int base)
d321 1
a321 1
	unsigned long long tval = 0;
d354 3
a356 3
 * ull_asc()
 *	Convert an unsigned long long into a hex/oct ascii string.
 *	Pads with LEADING ascii 0's to fill string completely
d361 1
a361 1
ull_asc(unsigned long long val, char *str, int len, int base)
d364 1
a364 1
	unsigned long long digit;
d382 1
a382 2
			val >>= 4;
			if (val == 0)
d388 1
a388 2
			val >>= 3;
			if (val == 0)
d398 1
a398 1
	if (val != 0)
d402 1
@


1.1.1.8.2.1
log
@Wrangle the OpenBSD branch into shape as starting point:

• Revert “Use the new libc uid_from_user() and gid_from_group()
  instead of the pax-specific functions in cache.c” (revisit later)
• fix MAX_TIME_T (plain wrong), mirtoconf later
• drop all NOCPIO
• Revert “Replace name_{uid,gid}() with the libc routines
  user_from_uid() and group_from_gid()”
@
text
@d110 2
a111 2
		NAME_WIDTH, UT_NAMESIZE, name_uid(sbp->st_uid, 1),
		NAME_WIDTH, UT_NAMESIZE, name_gid(sbp->st_gid, 1));
@


1.1.1.8.2.2
log
@extremely rudimentary conversion to mirtoconf, doesn’t even build yet
@
text
@a37 8
#if HAVE_BOTH_TIME_H
#include <sys/time.h>
#include <time.h>
#elif HAVE_SYS_TIME_H
#include <sys/time.h>
#elif HAVE_TIME_H
#include <time.h>
#endif
a38 1
#if HAVE_GRP_H
a39 1
#endif
d44 1
a44 3
#if HAVE_STRINGS_H
#include <strings.h>
#endif
a45 1
#if HAVE_UTMP_H
a46 4
#elif HAVE_UTMPX_H
#include <utmpx.h>
#endif
#if HAVE_VIS_H
a47 1
#endif
@


1.1.1.8.2.3
log
@merge ‘g’ and switch to a global “now”
@
text
@a4 2
 * Copyright (c) 2012, 2015, 2016
 *	mirabilos <m@@mirbsd.org>
d79 2
a80 1
#define SIXMONTHS	(24 * 60 * 60 * 365 / 2)
d84 2
a85 2
#define	TIMEFMT(t) \
	(((t) + SIXMONTHS <= now || (t) > now) ? OLDFRMT : CURFRMT)
d93 1
a93 1
ls_list(ARCHD *arcn, FILE *fp)
d124 1
a124 1
	if (strftime(f_date, sizeof(f_date), TIMEFMT(sbp->st_mtime),
d127 3
a129 4
	(void)fprintf(fp, "%s%2u %-*.*s %-*.*s ", f_mode,
	    (unsigned int)sbp->st_nlink,
	    NAME_WIDTH, UT_NAMESIZE, name_uid(sbp->st_uid, 1),
	    NAME_WIDTH, UT_NAMESIZE, name_gid(sbp->st_gid, 1));
d138 1
a138 1
	else
d140 1
d169 1
d174 1
a174 1
	if (strftime(f_date, DATELEN, TIMEFMT(arcn->sb.st_mtime),
a183 1
#if HAVE_VIS
d195 1
a195 2
	} else
#endif
d197 1
@


1.1.1.8.2.4
log
@various bugfixes and a system header issue workaround in Makefile
@
text
@d184 1
a184 1
#if HAVE_VIS_H
@


