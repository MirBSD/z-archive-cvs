head	1.71;
access;
symbols
	paxmirabilis-20190825:1.71
	paxmirabilis-20190224:1.71
	paxmirabilis-20190210:1.68
	npax:1.1.1.11.0.2
	cvs-20181212:1.1.1.11
	paxmirabilis-20171021:1.63
	paxmirabilis-20161104:1.60
	paxmirabilis-20161031:1.60
	paxmirabilis-20161025:1.60
	paxmirabilis-20160306:1.54
	cvs-201603041945:1.1.1.7
	paxmirabilis-20151013:1.52
	paxmirabilis-20140703:1.52
	paxmirabilis-20120606:1.51
	paxmirabilis-20120605:1.51
	cvs-201206051745:1.1.1.6
	paxmirabilis-20120520:1.49
	paxmirabilis-20120216:1.44
	paxmirabilis-20120212:1.41
	cvs-201202112230:1.1.1.5
	paxmirabilis-20110817:1.37
	MIRBSD_10:1.25.0.2
	MIRBSD_10_BASE:1.25
	cvs-200710231945:1.1.1.4
	cvs-200606232242:1.1.1.3
	MIRBSD_9_BASE:1.16
	MIRBSD_8:1.8.0.2
	MIRBSD_8_BASE:1.8
	cvs-200507211800:1.1.1.2
	cvs-200504291700:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.71
date	2019.02.24.02.08.24;	author tg;	state Exp;
branches;
next	1.70;
commitid	1005C71FCA91FAAA349;

1.70
date	2019.02.24.02.04.29;	author tg;	state Exp;
branches;
next	1.69;
commitid	1005C71FBBC17559C4E;

1.69
date	2019.02.24.01.49.18;	author tg;	state Exp;
branches;
next	1.68;
commitid	1005C71F80D12F84641;

1.68
date	2019.02.10.21.50.08;	author tg;	state Exp;
branches;
next	1.67;
commitid	1005C609C8F43A9BDCB;

1.67
date	2019.01.05.10.29.50;	author tg;	state Exp;
branches;
next	1.66;
commitid	1005C30873462115C79;

1.66
date	2018.12.13.07.09.10;	author tg;	state Exp;
branches;
next	1.65;
commitid	1005C1205A44B32AFA4;

1.65
date	2018.12.12.18.08.44;	author tg;	state Exp;
branches;
next	1.64;
commitid	1005C114EA81986F5EC;

1.64
date	2018.12.12.00.23.06;	author tg;	state Exp;
branches;
next	1.63;
commitid	1005C1054FE750D63F3;

1.63
date	2017.10.14.21.26.53;	author tg;	state Exp;
branches;
next	1.62;
commitid	10059E2812D599DF828;

1.62
date	2017.08.07.20.10.15;	author tg;	state Exp;
branches;
next	1.61;
commitid	1005988C69344442E37;

1.61
date	2017.07.20.21.15.50;	author tg;	state Exp;
branches;
next	1.60;
commitid	10059711D89780CE021;

1.60
date	2016.10.25.19.27.12;	author tg;	state Exp;
branches;
next	1.59;
commitid	100580FB2217F8FFA4F;

1.59
date	2016.10.25.19.09.57;	author tg;	state Exp;
branches;
next	1.58;
commitid	100580FAE192A17AF13;

1.58
date	2016.10.25.18.57.55;	author tg;	state Exp;
branches;
next	1.57;
commitid	100580FAB4B20AD4FA2;

1.57
date	2016.03.12.13.20.48;	author tg;	state Exp;
branches;
next	1.56;
commitid	10056E417C13E8BF870;

1.56
date	2016.03.12.13.02.07;	author tg;	state Exp;
branches;
next	1.55;
commitid	10056E41368530D82C4;

1.55
date	2016.03.12.12.53.28;	author tg;	state Exp;
branches;
next	1.54;
commitid	10056E4116046C639BE;

1.54
date	2016.03.06.14.12.27;	author tg;	state Exp;
branches;
next	1.53;
commitid	10056DC3ADA1858410D;

1.53
date	2016.03.06.13.47.11;	author tg;	state Exp;
branches;
next	1.52;
commitid	10056DC34E25F0AA0A6;

1.52
date	2014.07.03.19.36.25;	author tg;	state Exp;
branches;
next	1.51;
commitid	10053B5B0CA5BBF302E;

1.51
date	2012.06.05.19.19.44;	author tg;	state Exp;
branches;
next	1.50;
commitid	1004FCE5BE75FB3BEF7;

1.50
date	2012.06.05.17.56.22;	author tg;	state Exp;
branches;
next	1.49;
commitid	1004FCE485D799CECB5;

1.49
date	2012.05.20.17.21.44;	author tg;	state Exp;
branches;
next	1.48;
commitid	1004FB9283F72C8E596;

1.48
date	2012.05.20.16.38.28;	author tg;	state Exp;
branches;
next	1.47;
commitid	1004FB91E1C135B2BB7;

1.47
date	2012.05.20.16.13.18;	author tg;	state Exp;
branches;
next	1.46;
commitid	1004FB918314D2FECC0;

1.46
date	2012.02.27.22.31.01;	author tg;	state Exp;
branches;
next	1.45;
commitid	1004F4C04341C096F4E;

1.45
date	2012.02.27.22.24.55;	author tg;	state Exp;
branches;
next	1.44;
commitid	1004F4C02CE569853D1;

1.44
date	2012.02.16.17.27.31;	author tg;	state Exp;
branches;
next	1.43;
commitid	1004F3D3C992B2187A1;

1.43
date	2012.02.16.17.11.46;	author tg;	state Exp;
branches;
next	1.42;
commitid	1004F3D38626EFD0781;

1.42
date	2012.02.16.16.01.08;	author tg;	state Exp;
branches;
next	1.41;
commitid	1004F3D28152C6F33B8;

1.41
date	2012.02.12.01.02.06;	author tg;	state Exp;
branches;
next	1.40;
commitid	1004F370F971B022B7C;

1.40
date	2012.02.12.00.27.16;	author tg;	state Exp;
branches;
next	1.39;
commitid	1004F3707786D20BF4A;

1.39
date	2012.02.12.00.14.18;	author tg;	state Exp;
branches;
next	1.38;
commitid	1004F37046449BA31C7;

1.38
date	2012.02.12.00.04.33;	author tg;	state Exp;
branches;
next	1.37;
commitid	1004F37020D48949196;

1.37
date	2011.08.17.10.47.48;	author tg;	state Exp;
branches;
next	1.36;
commitid	1004E4B9C63487D4230;

1.36
date	2011.08.17.08.10.35;	author tg;	state Exp;
branches;
next	1.35;
commitid	1004E4B77924CD3EA65;

1.35
date	2011.08.16.21.32.47;	author tg;	state Exp;
branches;
next	1.34;
commitid	1004E4AE1EF00AF3003;

1.34
date	2011.08.16.13.50.18;	author tg;	state Exp;
branches;
next	1.33;
commitid	1004E4A75A9095E9071;

1.33
date	2011.08.16.13.45.00;	author tg;	state Exp;
branches;
next	1.32;
commitid	1004E4A74015B88F988;

1.32
date	2011.08.16.13.27.01;	author tg;	state Exp;
branches;
next	1.31;
commitid	1004E4A702C39E0597C;

1.31
date	2009.10.27.18.47.26;	author tg;	state Exp;
branches;
next	1.30;
commitid	1004AE74055714A6EEB;

1.30
date	2009.10.04.14.51.06;	author tg;	state Exp;
branches;
next	1.29;
commitid	1004AC8B662360E113C;

1.29
date	2009.09.17.07.24.00;	author tg;	state Exp;
branches;
next	1.28;
commitid	1004AB1E3EE37BBC83D;

1.28
date	2008.11.08.23.03.37;	author tg;	state Exp;
branches;
next	1.27;
commitid	10049161AB22DF5DFC5;

1.27
date	2008.10.29.17.00.07;	author tg;	state Exp;
branches;
next	1.26;
commitid	100490896A131275575;

1.26
date	2008.08.07.19.40.39;	author tg;	state Exp;
branches;
next	1.25;
commitid	100489B4FBE463F8CC1;

1.25
date	2007.10.23.20.07.42;	author tg;	state Exp;
branches;
next	1.24;
commitid	100471E5499154FE86E;

1.24
date	2007.02.17.04.52.41;	author tg;	state Exp;
branches;
next	1.23;
commitid	10045D68A2D54E2C558;

1.23
date	2007.01.23.11.55.53;	author tg;	state Exp;
branches;
next	1.22;
commitid	10045B5F7D62388E117;

1.22
date	2007.01.23.11.29.17;	author tg;	state Exp;
branches;
next	1.21;
commitid	10045B5F19D02DF5C22;

1.21
date	2007.01.17.16.25.40;	author tg;	state Exp;
branches;
next	1.20;
commitid	10045AE4DFA0EEDC1D2;

1.20
date	2006.07.21.17.34.59;	author tg;	state Exp;
branches;
next	1.19;
commitid	10044C1103610EA28BB;

1.19
date	2006.07.16.17.58.39;	author tg;	state Exp;
branches;
next	1.18;
commitid	10044BA7E602527C845;

1.18
date	2006.07.16.16.14.50;	author tg;	state Exp;
branches;
next	1.17;
commitid	10044BA65F92A873301;

1.17
date	2006.07.16.15.34.23;	author tg;	state Exp;
branches;
next	1.16;
commitid	10044BA5C902D45396A;

1.16
date	2006.06.23.23.03.56;	author tg;	state Exp;
branches;
next	1.15;
commitid	100449C736877C98FFB;

1.15
date	2006.06.19.20.31.05;	author tg;	state Exp;
branches;
next	1.14;
commitid	100449709733F6F9BF6;

1.14
date	2006.06.19.19.40.55;	author tg;	state Exp;
branches;
next	1.13;
commitid	1004496FDD922F52248;

1.13
date	2006.06.19.19.33.48;	author tg;	state Exp;
branches;
next	1.12;
commitid	1004496FC2B6EC72BBA;

1.12
date	2006.06.19.19.22.08;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004496F94825B1E33A;

1.11
date	2005.12.30.14.27.20;	author tg;	state Exp;
branches;
next	1.10;
commitid	10043B543D574C971C6;

1.10
date	2005.12.30.14.19.15;	author tg;	state Exp;
branches;
next	1.9;
commitid	10043B541E63A5BE8D7;

1.9
date	2005.12.30.14.17.37;	author tg;	state Exp;
branches;
next	1.8;
commitid	10043B540F421ECA275;

1.8
date	2005.12.17.07.20.23;	author tg;	state Exp;
branches;
next	1.7;
commitid	10043A3BC2A60852C4D;

1.7
date	2005.12.17.07.12.06;	author tg;	state Exp;
branches;
next	1.6;
commitid	10043A3B7997FC3F459;

1.6
date	2005.11.23.23.27.10;	author tg;	state Exp;
branches;
next	1.5;
commitid	61c84384fa91bd26;

1.5
date	2005.11.16.13.58.39;	author tg;	state Exp;
branches;
next	1.4;
commitid	63cf437b3768eac1;

1.4
date	2005.10.21.11.02.36;	author tg;	state Exp;
branches;
next	1.3;
commitid	6c0b4358cac0ef88;

1.3
date	2005.04.13.19.49.34;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.02.28.20.04.58;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.22.06;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.22.06;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.07.21.20.45.26;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	560042e0092f571e;

1.1.1.3
date	2006.06.23.23.00.14;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	100449C727D31170AA3;

1.1.1.4
date	2007.10.23.19.50.48;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	100471E50A5256C77AE;

1.1.1.5
date	2012.02.11.22.47.21;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	1004F36F008225F3522;

1.1.1.6
date	2012.06.05.17.52.08;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	1004FCE475F54798920;

1.1.1.7
date	2016.03.04.19.46.09;	author tg;	state Exp;
branches;
next	1.1.1.8;
commitid	10056D9E61429EE6550;

1.1.1.8
date	2016.03.04.20.55.01;	author tg;	state Exp;
branches;
next	1.1.1.9;
commitid	10056D9F62E152ECBA5;

1.1.1.9
date	2016.10.25.18.46.10;	author tg;	state Exp;
branches;
next	1.1.1.10;
commitid	100580FA88137705D31;

1.1.1.10
date	2018.12.12.00.15.05;	author tg;	state Exp;
branches;
next	1.1.1.11;
commitid	1005C1052FA5E745A2C;

1.1.1.11
date	2018.12.12.00.24.23;	author tg;	state Exp;
branches
	1.1.1.11.2.1;
next	;
commitid	1005C1055452C78F9E4;

1.1.1.11.2.1
date	2018.12.12.00.52.59;	author tg;	state Exp;
branches;
next	1.1.1.11.2.2;
commitid	1005C105BC86262A0B7;

1.1.1.11.2.2
date	2018.12.12.00.54.16;	author tg;	state Exp;
branches;
next	1.1.1.11.2.3;
commitid	1005C105C48612B0194;

1.1.1.11.2.3
date	2018.12.12.03.13.32;	author tg;	state Exp;
branches;
next	1.1.1.11.2.4;
commitid	1005C107CE315DC51F3;

1.1.1.11.2.4
date	2018.12.12.06.03.12;	author tg;	state Exp;
branches;
next	1.1.1.11.2.5;
commitid	1005C10A4B12E5998CE;

1.1.1.11.2.5
date	2018.12.12.10.24.14;	author tg;	state Exp;
branches;
next	1.1.1.11.2.6;
commitid	1005C10E1DB5956B939;

1.1.1.11.2.6
date	2018.12.12.10.41.26;	author tg;	state Exp;
branches;
next	1.1.1.11.2.7;
commitid	1005C10E5E87909E6FC;

1.1.1.11.2.7
date	2018.12.12.15.00.25;	author tg;	state Exp;
branches;
next	1.1.1.11.2.8;
commitid	1005C11229872472EAF;

1.1.1.11.2.8
date	2018.12.12.15.43.38;	author tg;	state Exp;
branches;
next	1.1.1.11.2.9;
commitid	1005C112CBE1F8824CA;

1.1.1.11.2.9
date	2018.12.12.15.52.23;	author tg;	state Exp;
branches;
next	;
commitid	1005C112ECC154651A6;


desc
@@


1.71
log
@fix segfault due to the decompressors in the fsub table
@
text
@/*	$OpenBSD: options.c,v 1.102 2018/09/13 12:33:43 millert Exp $	*/
/*	$NetBSD: options.c,v 1.6 1996/03/26 23:54:18 mrg Exp $	*/

/*-
 * Copyright (c) 2005, 2006, 2007, 2009, 2011, 2012, 2014, 2016, 2019
 *	mirabilos <m@@mirbsd.org>
 * Copyright (c) 1992 Keith Muller.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#if HAVE_SYS_MTIO_H
#include <sys/mtio.h>
#endif
#include <sys/stat.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#if HAVE_PATHS_H
#include <paths.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if HAVE_STRINGS_H
#include <strings.h>
#endif
#include <unistd.h>

#define EXTERN
#include "pax.h"
#include "ar.h"
#include "cpio.h"
#include "tar.h"
#include "extern.h"

__RCSID("$MirOS: src/bin/pax/options.c,v 1.70 2019/02/24 02:04:29 tg Exp $");

#ifndef _PATH_DEFTAPE
#define _PATH_DEFTAPE "/dev/rmt0"
#endif

#define NELEM(a) (sizeof(a) / sizeof((a)[0]))
#define SELEM(a) (sizeof((a)[0]))

/*
 * argv[0] names. Used for tar and cpio emulation
 */

#define NM_TAR  "tar"
#define NM_CPIO "cpio"
#define NM_PAX  "pax"

/*
 * Constants used to specify the legal sets of flags in pax. For each major
 * operation mode of pax, a set of illegal flags is defined. If any one of
 * those illegal flags are found set, we scream and exit
 */

/*
 * flags (one for each option).
 */
#define	AF	0x00000001
#define	BF	0x00000002
#define	CF	0x00000004
#define	DF	0x00000008
#define	FF	0x00000010
#define	IF	0x00000020
#define	KF	0x00000040
#define	LF	0x00000080
#define	NF	0x00000100
#define	OF	0x00000200
#define	PF	0x00000400
#define	RF	0x00000800
#define	SF	0x00001000
#define	TF	0x00002000
#define	UF	0x00004000
#define	VF	0x00008000
#define	WF	0x00010000
#define	XF	0x00020000
#define	CBF	0x00040000	/* nonstandard extension */
#define	CDF	0x00080000	/* nonstandard extension */
#define	CEF	0x00100000	/* nonstandard extension */
#define	CGF	0x00200000	/* nonstandard extension */
#define	CHF	0x00400000	/* nonstandard extension */
#define	CLF	0x00800000	/* nonstandard extension */
#define	CPF	0x01000000	/* nonstandard extension */
#define	CTF	0x02000000	/* nonstandard extension */
#define	CUF	0x04000000	/* nonstandard extension */
#define	CXF	0x08000000
#define	CYF	0x10000000	/* nonstandard extension */
#define	CZF	0x20000000	/* nonstandard extension */
#define	C0F	0x40000000	/* nonstandard extension */

/*
 * ascii string indexed by bit position above (alter the above and you must
 * alter this string) used to tell the user what flags caused us to complain
 */
#define FLGCH	"abcdfiklnoprstuvwxBDEGHLPTUXYZ0"

/*
 * legal pax operation bit patterns
 */

#define ISLIST(x)	(((x) & (RF|WF)) == 0)
#define	ISEXTRACT(x)	(((x) & (RF|WF)) == RF)
#define ISARCHIVE(x)	(((x) & (AF|RF|WF)) == WF)
#define ISAPPND(x)	(((x) & (AF|RF|WF)) == (AF|WF))
#define	ISCOPY(x)	(((x) & (RF|WF)) == (RF|WF))
#define	ISWRITE(x)	(((x) & (RF|WF)) == WF)

/*
 * Illegal option flag subsets based on pax operation
 */

#define	BDEXTR	(AF|BF|LF|TF|WF|XF|CBF|CHF|CLF|CPF|CXF)
#define	BDARCH	(CF|KF|LF|NF|PF|RF|CDF|CEF|CYF|CZF)
#define	BDCOPY	(AF|BF|FF|OF|XF|CBF|CEF)
#define	BDLIST	(AF|BF|IF|KF|LF|OF|PF|RF|TF|UF|WF|XF|CBF|CDF|CHF|CLF|CPF|CXF|CYF|CZF)

/*
 * Routines which handle command line options
 */

static char flgch[] = FLGCH;	/* list of all possible flags */
static OPLIST *ophead = NULL;	/* head for format specific options -x */
static OPLIST *optail = NULL;	/* option tail */

#ifndef SMALL
static int no_op(void);
static int no_op_i(int);
#endif
static int mkpath(char *);
static void process_M(const char *, void (*)(void));
static void printflg(unsigned int);
static int c_frmt(const void *, const void *);
static off_t str_offt(char *);
static void pax_options(int, char **);
static void pax_usage(void) MKSH_A_NORETURN;
static void tar_set_action(int);
static void tar_options(int, char **);
static void tar_usage(void) MKSH_A_NORETURN;
static void cpio_set_action(int);
static void cpio_options(int, char **);
static void cpio_usage(void) MKSH_A_NORETURN;

#ifndef SMALL
static int compress_id(char *_blk, int _size);
static int gzip_id(char *_blk, int _size);
static int bzip2_id(char *_blk, int _size);
static int xz_id(char *_blk, int _size);
#endif

/* command to run as gzip */
static const char GZIP_CMD[] = "gzip";
#ifndef SMALL
/* command to run as compress */
static const char COMPRESS_CMD[] = "compress";
/* command to run as bzip2 */
static const char BZIP2_CMD[] = "bzip2";
/* command to run as lzma and xz */
static const char XZ_CMD[] = "xz";
/* command used for creating lzma archives */
static const char LZMA_WRCMD[] = "lzma";
/* command to run as lzop */
static const char LZOP_CMD[] = "lzop";
#endif
/* used as flag value */
#define COMPRESS_GUESS_CMD ((const void *)&compress_program)

/*
 *	Format specific routine table, MUST be in sorted order
 *	and MUST match enum fsub_order in pax.h
 *	(see pax.h for description of each function)
 *
 *	name, blksz, hdsz, udev, hlk, blkagn, id, st_read,
 *	read, end_read, st_write, write, end_write, trail,
 *	rd_data, wr_data, options, inhead, is_uar
 */

const FSUB fsub[] = {
#ifndef SMALL
/* FSUB_AR: UNIX ARCHIVER */
	{"ar", 512, sizeof(HD_AR), 0, 0, 0, uar_id, no_op,
	uar_rd, uar_endrd, uar_stwr, uar_wr, no_op, uar_trail,
	rd_wrfile, uar_wr_data, bad_opt, 0, 1},

/* FSUB_BCPIO: OLD BINARY CPIO */
	{"bcpio", 5120, sizeof(HD_BCPIO), 1, 0, 0, bcpio_id, cpio_strd,
	bcpio_rd, bcpio_endrd, cpio_stwr, bcpio_wr, cpio_endwr, cpio_trail,
	rd_wrfile, wr_rdfile, bad_opt, 1, 0},
#endif

/* FSUB_CPIO: OLD OCTAL CHARACTER CPIO */
	{"cpio", 5120, sizeof(HD_CPIO), 1, 0, 0, cpio_id, cpio_strd,
	cpio_rd, cpio_endrd, cpio_stwr, cpio_wr, cpio_endwr, cpio_trail,
	rd_wrfile, wr_rdfile, bad_opt, 1, 0},

#ifndef SMALL
/* FSUB_DIST: OLD OCTAL CHARACTER CPIO, UID/GID CLEARED (ANONYMISED) */
	{"dist", 512, sizeof(HD_CPIO), 1, 0, 0, cpio_id, cpio_strd,
	cpio_rd, cpio_endrd, dist_stwr, cpio_wr, cpio_endwr, cpio_trail,
	rd_wrfile, wr_rdfile, bad_opt, 1, 0},
#endif

/* FSUB_SV4CPIO: SVR4 HEX CPIO */
	{"sv4cpio", 5120, sizeof(HD_VCPIO), 1, 0, 0, vcpio_id, cpio_strd,
	vcpio_rd, vcpio_endrd, cpio_stwr, vcpio_wr, cpio_endwr, cpio_trail,
	rd_wrfile, wr_rdfile, bad_opt, 1, 0},

/* FSUB_SV4CRC: SVR4 HEX CPIO WITH CRC */
	{"sv4crc", 5120, sizeof(HD_VCPIO), 1, 0, 0, crc_id, crc_strd,
	vcpio_rd, vcpio_endrd, crc_stwr, vcpio_wr, cpio_endwr, cpio_trail,
	rd_wrfile, wr_rdfile, bad_opt, 1, 0},

#ifndef SMALL
/* FSUB_TAR: OLD TAR */
	{"tar", 10240, BLKMULT, 0, 1, BLKMULT, tar_id, no_op,
	tar_rd, tar_endrd, no_op_i, tar_wr, tar_endwr, tar_trail,
	rd_wrfile, wr_rdfile, tar_opt, 0, 0},
#endif

/* FSUB_USTAR: POSIX USTAR */
	{"ustar", 10240, BLKMULT, 0, 1, BLKMULT, ustar_id, ustar_strd,
	ustar_rd, tar_endrd, ustar_stwr, ustar_wr, tar_endwr, tar_trail,
	rd_wrfile, wr_rdfile, tar_opt, 0, 0},

#ifndef SMALL
/* FSUB_V4NORM: SVR4 HEX CPIO WITH CRC, UID/GID/MTIME CLEARED (NORMALISED) */
	{"v4norm", 512, sizeof(HD_VCPIO), 1, 0, 0, crc_id, crc_strd,
	vcpio_rd, vcpio_endrd, v4norm_stwr, vcpio_wr, cpio_endwr, cpio_trail,
	rd_wrfile, wr_rdfile, bad_opt, 1, 0},

/* FSUB_V4ROOT: SVR4 HEX CPIO WITH CRC, UID/GID CLEARED (ANONYMISED) */
	{"v4root", 512, sizeof(HD_VCPIO), 1, 0, 0, crc_id, crc_strd,
	vcpio_rd, vcpio_endrd, v4root_stwr, vcpio_wr, cpio_endwr, cpio_trail,
	rd_wrfile, wr_rdfile, bad_opt, 1, 0},

/* FSUBFAIL_Z: compress, to detect failure to use -Z */
	{NULL, 0, 4, 0, 0, 0, compress_id, NULL,
	NULL, NULL, NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, 0, 0},
/* FSUBFAIL_XZ: xz, to detect failure to decompress it */
	{NULL, 0, 6, 0, 0, 0, xz_id, NULL,
	NULL, NULL, NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, 0, 0},
/* FSUBFAIL_BZ2: bzip2, to detect failure to use -j */
	{NULL, 0, 4, 0, 0, 0, bzip2_id, NULL,
	NULL, NULL, NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, 0, 0},
/* FSUBFAIL_GZ: gzip, to detect failure to use -z */
	{NULL, 0, 4, 0, 0, 0, gzip_id, NULL,
	NULL, NULL, NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, 0, 0},
#endif
};

/*
 * ford is the archive search order used by get_arc() to determine what kind
 * of archive we are dealing with. This helps to properly id archive formats
 * some formats may be subsets of others....
 */
const unsigned char ford[] = {
	FSUB_USTAR,
#ifndef SMALL
	FSUB_TAR,
	FSUBFAIL_GZ,
	FSUBFAIL_BZ2,
	FSUBFAIL_XZ,
	FSUBFAIL_Z,
#endif
	FSUB_SV4CRC,
	FSUB_SV4CPIO,
	FSUB_CPIO,
#ifndef SMALL
	FSUB_BCPIO,
#endif
	FSUB_MAX
};

/* normalise archives */
int anonarch = 0;

/* extract to standard output */
char to_stdout = 0;

/*
 * Do we have -C anywhere and what is it?
 */
char havechd = 0;
char *chdname = NULL;

/*
 * options()
 *	figure out if we are pax, tar or cpio. Call the appropriate options
 *	parser
 */

void
options(int argc, char **argv)
{
	size_t n;

	/*
	 * Are we acting like pax, tar or cpio (based on argv[0])
	 */
	n = strlen(argv[0]);

	if (n >= 3 && !strcmp(argv[0] + (n - 3), NM_TAR)) {
		argv0 = NM_TAR;
		op_mode = OP_TAR;
		tar_options(argc, argv);
	} else if (n >= 4 && !strcmp(argv[0] + (n - 4), NM_CPIO)) {
		argv0 = NM_CPIO;
		op_mode = OP_CPIO;
		cpio_options(argc, argv);
	} else {
		/* assume pax as the default */
		argv0 = NM_PAX;
		op_mode = OP_PAX;
		pax_options(argc, argv);
	}
}

static int
gather_format(FSUB *fp, const char *name, int flag)
{
	size_t i;

	if ((frmt = (const FSUB *)bsearch((const void *)fp, (const void *)fsub,
	    NELEM(fsub), SELEM(fsub), c_frmt)) != NULL)
		return (0);
	paxwarn(1, "Unknown -%c format: %s", flag, optarg);
	fprintf(stderr, "%s: Known -%c formats are:", name, flag);
	for (i = 0; i < NELEM(fsub); ++i)
		if (fsub[i].name != NULL)
			fprintf(stderr, " %s", fsub[i].name);
	fputs("\n\n", stderr);
	return (1);
}

/*
 * pax_options()
 *	look at the user specified flags. set globals as required and check if
 *	the user specified a legal set of flags. If not, complain and exit
 */

static void
pax_options(int argc, char **argv)
{
	int c;
	unsigned int flg = 0;
	unsigned int bflg = 0;
	const char *errstr;
	char *pt;
	FSUB tmp;

	/*
	 * process option flags
	 */
	while ((c = getopt(argc, argv,
	    "0aB:b:cDdE:f:G:HiJjkLlM:nOo:Pp:rs:T:tU:uvwXx:YZz")) != -1) {
		switch (c) {
		case '0':
			/*
			 * Use \0 as pathname terminator.
			 * (For use with the -print0 option of find(1).)
			 */
			zeroflag = 1;
			flg |= C0F;
			break;
		case 'a':
			/*
			 * append
			 */
			flg |= AF;
			break;
		case 'B':
			/*
			 * non-standard option on number of bytes written on a
			 * single archive volume.
			 */
			if ((wrlimit = str_offt(optarg)) <= 0) {
				paxwarn(1, "Invalid write limit %s", optarg);
				pax_usage();
			}
			if (wrlimit % BLKMULT) {
				paxwarn(1, "Write limit is not a %d byte multiple",
				    BLKMULT);
				pax_usage();
			}
			flg |= CBF;
			break;
		case 'b':
			/*
			 * specify blocksize
			 */
			flg |= BF;
			if ((wrblksz = (int)str_offt(optarg)) <= 0) {
				paxwarn(1, "Invalid block size %s", optarg);
				pax_usage();
			}
			break;
		case 'c':
			/*
			 * inverse match on patterns
			 */
			cflag = 1;
			flg |= CF;
			break;
		case 'D':
			/*
			 * On extraction check file inode change time before the
			 * modification of the file name. Non standard option.
			 */
			Dflag = 1;
			flg |= CDF;
			break;
		case 'd':
			/*
			 * match only dir on extract, not the subtree at dir
			 */
			dflag = 1;
			flg |= DF;
			break;
		case 'E':
			/*
			 * non-standard limit on read faults
			 * 0 indicates stop after first error, values
			 * indicate a limit
			 */
			flg |= CEF;
			maxflt = strtonum(optarg, 0, INT_MAX, &errstr);
			if (errstr) {
				paxwarn(1, "Error count value: %s", errstr);
				pax_usage();
			}
			break;
		case 'f':
			/*
			 * filename where the archive is stored
			 */
			arcname = optarg;
			flg |= FF;
			break;
		case 'G':
			/*
			 * non-standard option for selecting files within an
			 * archive by group (gid or name)
			 */
			if (grp_add(optarg) < 0) {
				pax_usage();
				break;
			}
			flg |= CGF;
			break;
		case 'H':
			/*
			 * follow command line symlinks only
			 */
			Hflag = 1;
			flg |= CHF;
			break;
		case 'i':
			/*
			 * interactive file rename
			 */
			iflag = 1;
			flg |= IF;
			break;
#ifndef SMALL
		case 'J':
			/*
			 * use xz (non-standard option)
			 */
			compress_program = XZ_CMD;
			break;
		case 'j':
			/*
			 * use bzip2 (non-standard option)
			 */
			compress_program = BZIP2_CMD;
			break;
#endif
		case 'k':
			/*
			 * do not clobber files that exist
			 */
			kflag = 1;
			flg |= KF;
			break;
		case 'L':
			/*
			 * follow symlinks
			 */
			Lflag = 1;
			flg |= CLF;
			break;
		case 'l':
			/*
			 * try to link src to dest with copy (-rw)
			 */
			lflag = 1;
			flg |= LF;
			break;
		case 'M':
			/*
			 * MirOS extension: archive normaliser
			 */
			process_M(optarg, pax_usage);
			break;
		case 'n':
			/*
			 * select first match for a pattern only
			 */
			nflag = 1;
			flg |= NF;
			break;
		case 'O':
			/*
			 * Force one volume.  Non standard option.
			 */
			force_one_volume = 1;
			break;
		case 'o':
			/*
			 * pass format specific options
			 */
			flg |= OF;
			if (opt_add(optarg) < 0)
				pax_usage();
			break;
		case 'P':
			/*
			 * do NOT follow symlinks (default)
			 */
			Lflag = 0;
			flg |= CPF;
			break;
		case 'p':
			/*
			 * specify file characteristic options
			 */
			for (pt = optarg; *pt != '\0'; ++pt) {
				switch (*pt) {
				case 'a':
					/*
					 * do not preserve access time
					 */
					patime = 0;
					break;
				case 'e':
					/*
					 * preserve user id, group id, file
					 * mode, access/modification times
					 */
					pids = 1;
					pmode = 1;
					patime = 1;
					pmtime = 1;
					break;
				case 'm':
					/*
					 * do not preserve modification time
					 */
					pmtime = 0;
					break;
				case 'o':
					/*
					 * preserve uid/gid
					 */
					pids = 1;
					break;
				case 'p':
					/*
					 * preserve file mode bits
					 */
					pmode = 1;
					break;
				default:
					paxwarn(1, "Invalid -p string: %c", *pt);
					pax_usage();
					break;
				}
			}
			flg |= PF;
			break;
		case 'r':
			/*
			 * read the archive
			 */
			flg |= RF;
			break;
		case 's':
			/*
			 * file name substitution name pattern
			 */
			if (rep_add(optarg) < 0) {
				pax_usage();
				break;
			}
			flg |= SF;
			break;
		case 'T':
			/*
			 * non-standard option for selecting files within an
			 * archive by modification time range (lower,upper)
			 */
			if (trng_add(optarg) < 0) {
				pax_usage();
				break;
			}
			flg |= CTF;
			break;
		case 't':
			/*
			 * preserve access time on filesystem nodes we read
			 */
			tflag = 1;
			flg |= TF;
			break;
		case 'U':
			/*
			 * non-standard option for selecting files within an
			 * archive by user (uid or name)
			 */
			if (usr_add(optarg) < 0) {
				pax_usage();
				break;
			}
			flg |= CUF;
			break;
		case 'u':
			/*
			 * ignore those older files
			 */
			uflag = 1;
			flg |= UF;
			break;
		case 'v':
			/*
			 * verbose operation mode
			 */
			++vflag;
			flg |= VF;
			break;
		case 'w':
			/*
			 * write an archive
			 */
			flg |= WF;
			break;
		case 'X':
			/*
			 * do not pass over mount points in the filesystem
			 */
			Xflag = 1;
			flg |= CXF;
			break;
		case 'x':
			/*
			 * specify an archive format on write
			 */
			tmp.name = optarg;
			if (gather_format(&tmp, "pax", 'x'))
				pax_usage();
			flg |= XF;
			break;
		case 'Y':
			/*
			 * On extraction check file inode change time after the
			 * modification of the file name. Non standard option.
			 */
			Yflag = 1;
			flg |= CYF;
			break;
		case 'Z':
			/*
			 * On extraction check modification time after the
			 * modification of the file name. Non standard option.
			 */
			Zflag = 1;
			flg |= CZF;
			break;
		case 'z':
			/*
			 * use gzip (non-standard option)
			 */
			compress_program = GZIP_CMD;
			break;
		default:
			pax_usage();
			break;
		}
	}

	/*
	 * figure out the operation mode of pax read,write,extract,copy,append
	 * or list. check that we have not been given a bogus set of flags
	 * for the operation mode.
	 */
	if (ISLIST(flg)) {
		act = LIST;
		listf = stdout;
		bflg = flg & BDLIST;
	} else if (ISEXTRACT(flg)) {
		act = EXTRACT;
		bflg = flg & BDEXTR;
	} else if (ISARCHIVE(flg)) {
		act = ARCHIVE;
		bflg = flg & BDARCH;
	} else if (ISAPPND(flg)) {
		act = APPND;
		bflg = flg & BDARCH;
	} else if (ISCOPY(flg)) {
		act = COPY;
		bflg = flg & BDCOPY;
	} else
		pax_usage();
	if (bflg) {
		printflg(flg);
		pax_usage();
	}

	/*
	 * if we are writing (ARCHIVE) we use the default format if the user
	 * did not specify a format. when we write during an APPEND, we will
	 * adopt the format of the existing archive if none was supplied.
	 */
	if (!(flg & XF) && (act == ARCHIVE))
		frmt = &(fsub[FSUB_USTAR]);

	/*
	 * process the args as they are interpreted by the operation mode
	 */
	switch (act) {
	case LIST:
	case EXTRACT:
		for (; optind < argc; optind++)
			if (pat_add(argv[optind], NULL) < 0)
				pax_usage();
		break;
	case COPY:
		if (optind >= argc) {
			paxwarn(0, "Destination directory was not supplied");
			pax_usage();
		}
		--argc;
		dirptr = argv[argc];
		/* FALLTHROUGH */
	case ARCHIVE:
	case APPND:
		for (; optind < argc; optind++)
			if (ftree_add(argv[optind], 0) < 0)
				pax_usage();
		/*
		 * no read errors allowed on updates/append operation!
		 */
		maxflt = 0;
		break;
	}
}

/*
 * tar_options()
 *	look at the user specified flags. set globals as required and check if
 *	the user specified a legal set of flags. If not, complain and exit
 */

static void
tar_set_action(int op)
{
	if (act != ERROR && act != op)
		tar_usage();
	act = op;
}

static void
tar_options(int argc, char **argv)
{
	int c;
	int Oflag = FSUB_USTAR;
	int nincfiles = 0;
	int incfiles_max = 0;
	struct incfile {
		char *file;
		char *dir;
	};
	struct incfile *incfiles = NULL;

	/*
	 * Set default values.
	 */
	rmleadslash = 1;

	/*
	 * process option flags
	 */
	while ((c = getoldopt(argc, argv,
	    "014578AaBb:C:cef:HhI:JjLM:mNOoPpqRrSs:tuvwXxZz")) != -1) {
		switch (c) {
		case '0':
			arcname = DEV_0;
			break;
		case '1':
			arcname = DEV_1;
			break;
		case '4':
			arcname = DEV_4;
			break;
		case '5':
			arcname = DEV_5;
			break;
		case '7':
			arcname = DEV_7;
			break;
		case '8':
			arcname = DEV_8;
			break;
#ifndef SMALL
		case 'A':
			Oflag = FSUB_AR;
			break;
#endif
		case 'a':
			/*
			 * use compression dependent on arcname
			 * (non-standard option, gtar extension)
			 */
			compress_program = COMPRESS_GUESS_CMD;
			break;
		case 'B':
			/*
			 * Nothing to do here, this is pax default
			 */
			break;
		case 'b':
			/*
			 * specify blocksize in 512-byte blocks
			 */
			if ((wrblksz = (int)str_offt(optarg)) <= 0) {
				paxwarn(1, "Invalid block size %s", optarg);
				tar_usage();
			}
			/* XXX - check for integer overflow */
			wrblksz *= 512;
			break;
		case 'C':
			havechd++;
			chdname = optarg;
			break;
		case 'c':
			/*
			 * create an archive
			 */
			tar_set_action(ARCHIVE);
			break;
		case 'e':
			/*
			 * stop after first error
			 */
			maxflt = 0;
			break;
		case 'f':
			/*
			 * filename where the archive is stored
			 */
			arcname = optarg;
			break;
		case 'H':
			/*
			 * follow command line symlinks only
			 */
			Hflag = 1;
			break;
		case 'h':
			/*
			 * follow symlinks
			 */
			Lflag = 1;
			break;
		case 'I':
			if (++nincfiles > incfiles_max) {
				size_t n = nincfiles + 3;
				struct incfile *p;

				p = reallocarray(incfiles, n,
				    sizeof(*incfiles));
				if (p == NULL) {
					paxwarn(0, "Unable to allocate space "
					    "for option list");
					exit(1);
				}
				incfiles = p;
				incfiles_max = n;
			}
			incfiles[nincfiles - 1].file = optarg;
			incfiles[nincfiles - 1].dir = chdname;
			break;
#ifndef SMALL
		case 'J':
			/*
			 * use xz (non-standard option)
			 */
			compress_program = XZ_CMD;
			break;
		case 'j':
			/*
			 * use bzip2 (non-standard option)
			 */
			compress_program = BZIP2_CMD;
			break;
#endif
		case 'L':
			/*
			 * follow symlinks
			 */
			Lflag = 1;
			break;
		case 'M':
			/*
			 * MirOS extension: archive normaliser
			 */
			process_M(optarg, tar_usage);
			break;
		case 'm':
			/*
			 * do not preserve modification time
			 */
			pmtime = 0;
			break;
		case 'N':
			/* numeric uid and gid only */
			anonarch |= ANON_NUMID;
			break;
		case 'O':
#ifndef SMALL
			Oflag = FSUB_TAR;
#else
			Oflag = FSUB_MAX;
#endif
			to_stdout = 2;
			break;
#ifndef SMALL
		case 'o':
			Oflag = FSUB_TAR;
			tar_nodir = 1;
			break;
#endif
		case 'P':
			/*
			 * do not remove leading '/' from pathnames
			 */
			rmleadslash = 0;
			break;
		case 'p':
			/*
			 * preserve uid/gid and file mode, regardless of umask
			 */
			pmode = 1;
			pids = 1;
			break;
		case 'q':
			/*
			 * select first match for a pattern only
			 */
			nflag = 1;
			break;
#ifndef SMALL
		case 'R':
			Oflag = FSUB_SV4CPIO;
			anonarch |= ANON_INODES | ANON_HARDLINKS;
			mircpio_deprecated("-R flag",
			    "the sv4cpio format with -M set");
			break;
#endif
		case 'r':
		case 'u':
			/*
			 * append to the archive
			 */
			tar_set_action(APPND);
			break;
#ifndef SMALL
		case 'S':
			Oflag = FSUB_SV4CRC;
			anonarch |= ANON_INODES | ANON_HARDLINKS;
			mircpio_deprecated("-S flag",
			    "the sv4crc format with -M set");
			break;
#endif
		case 's':
			/*
			 * file name substitution name pattern
			 */
			if (rep_add(optarg) < 0) {
				tar_usage();
				break;
			}
			break;
		case 't':
			/*
			 * list contents of the tape
			 */
			tar_set_action(LIST);
			break;
		/* u: see r */
		case 'v':
			/*
			 * verbose operation mode
			 */
			vflag++;
			break;
		case 'w':
			/*
			 * interactive file rename
			 */
			iflag = 1;
			break;
		case 'X':
			/*
			 * do not pass over mount points in the filesystem
			 */
			Xflag = 1;
			break;
		case 'x':
			/*
			 * extract an archive, preserving mode,
			 * and mtime if possible.
			 */
			tar_set_action(EXTRACT);
			pmtime = 1;
			break;
#ifndef SMALL
		case 'Z':
			/*
			 * use compress
			 */
			compress_program = COMPRESS_CMD;
			break;
#endif
		case 'z':
			/*
			 * use gzip (non-standard option)
			 */
			compress_program = GZIP_CMD;
			break;
		default:
			tar_usage();
			break;
		}
	}
	argc -= optind;
	argv += optind;

	/* tar requires an action. */
	if (act == ERROR)
		tar_usage();

	if ((arcname == NULL) || (*arcname == '\0')) {
		arcname = getenv("TAPE");
		if ((arcname == NULL) || (*arcname == '\0'))
			arcname = _PATH_DEFTAPE;
	}
	if ((arcname[0] == '-') && (arcname[1] == '\0'))
		arcname = NULL;

	/*
	 * Traditional tar behaviour: list-like output goes to stdout unless
	 * writing the archive there.  (pax uses stderr unless in list mode)
	 */
        if (act == LIST || act == EXTRACT || arcname != NULL)
		listf = stdout;

	/* Traditional tar behaviour (pax wants to read file list from stdin) */
	if ((act == ARCHIVE || act == APPND) && argc == 0 && nincfiles == 0)
		exit(0);

	/*
	 * process the args as they are interpreted by the operation mode
	 */
	switch (act) {
	case EXTRACT:
		if (to_stdout == 2)
			to_stdout = 1;
		/* FALLTHROUGH */
	case LIST:
	default:
		{
			int sawpat = 0;
			char *file, *dir = NULL;

			while (nincfiles || *argv != NULL) {
				/*
				 * If we queued up any include files,
				 * pull them in now.  Otherwise, check
				 * for -I and -C positional flags.
				 * Anything else must be a file to
				 * extract.
				 */
				if (nincfiles) {
					file = incfiles->file;
					dir = incfiles->dir;
					incfiles++;
					nincfiles--;
				} else if (strcmp(*argv, "-I") == 0) {
					if (*++argv == NULL)
						break;
					file = *argv++;
					dir = chdname;
				} else
					file = NULL;
				if (file != NULL) {
					int fd;
					char *str;

					if (strcmp(file, "-") == 0)
						fd = STDIN_FILENO;
					else if ((fd = binopen2(0, file, O_RDONLY)) == -1) {
						syswarn(1, errno,
						    "Unable to open %s", file);
						tar_usage();
					}
					while ((str = fdgetline(fd)) != NULL) {
						if (pat_add(str, dir) < 0)
							tar_usage();
						sawpat = 1;
					}
					if (fd != STDIN_FILENO)
						close(fd);
					if (fdgetline_err) {
						paxwarn(1,
						    "Unable to read from %s",
						    strcmp(file, "-") ? file :
						    "stdin");
						tar_usage();
					}
				} else if (strcmp(*argv, "-C") == 0) {
					if (*++argv == NULL)
						break;
					chdname = *argv++;
					havechd++;
				} else if (pat_add(*argv++, chdname) < 0)
					tar_usage();
				else
					sawpat = 1;
			}
			/*
			 * if patterns were added, we are doing	chdir()
			 * on a file-by-file basis, else, just one
			 * global chdir (if any) after opening input.
			 */
			if (sawpat > 0)
				chdname = NULL;
		}
		break;
	case ARCHIVE:
	case APPND:
		if (Oflag == FSUB_MAX)
			tar_usage();
		frmt = &(fsub[Oflag]);

		if (chdname != NULL) {
			/* initial chdir() */
			if (ftree_add(chdname, 1) < 0)
				tar_usage();
		}

		while (nincfiles || *argv != NULL) {
			char *file, *dir = NULL;

			/*
			 * If we queued up any include files, pull them in
			 * now.  Otherwise, check for -I and -C positional
			 * flags.  Anything else must be a file to include
			 * in the archive.
			 */
			if (nincfiles) {
				file = incfiles->file;
				dir = incfiles->dir;
				incfiles++;
				nincfiles--;
			} else if (strcmp(*argv, "-I") == 0) {
				if (*++argv == NULL)
					break;
				file = *argv++;
				dir = NULL;
			} else
				file = NULL;
			if (file != NULL) {
				int fd;
				char *str;

				/* Set directory if needed */
				if (dir) {
					if (ftree_add(dir, 1) < 0)
						tar_usage();
				}

				if (strcmp(file, "-") == 0)
					fd = STDIN_FILENO;
				else if ((fd = binopen2(0, file, O_RDONLY)) == -1) {
					syswarn(1, errno, "Unable to open %s",
					    file);
					tar_usage();
				}
				while ((str = fdgetline(fd)) != NULL) {
					if (ftree_add(str, 0) < 0)
						tar_usage();
				}
				if (fd != STDIN_FILENO)
					close(fd);
				if (fdgetline_err) {
					paxwarn(1,
					    "Unable to read from %s",
					    strcmp(file, "-") ? file : "stdin");
					tar_usage();
				}
			} else if (strcmp(*argv, "-C") == 0) {
				if (*++argv == NULL)
					break;
				if (ftree_add(*argv++, 1) < 0)
					tar_usage();
				havechd++;
			} else if (ftree_add(*argv++, 0) < 0)
				tar_usage();
		}
		/*
		 * no read errors allowed on updates/append operation!
		 */
		maxflt = 0;
		break;
	}
	if (to_stdout != 1)
		to_stdout = 0;
}

static int
mkpath(char *path)
{
	struct stat sb;
	char *slash;
	int done = 0;

	slash = path;

	while (!done) {
		slash += strspn(slash, "/");
		slash += strcspn(slash, "/");

		done = (*slash == '\0');
		*slash = '\0';

		if (stat(path, &sb)) {
			if (errno != ENOENT || mkdir(path, 0777)) {
				paxwarn(1, "%s", path);
				return (-1);
			}
		} else if (!S_ISDIR(sb.st_mode)) {
			syswarn(1, ENOTDIR, "%s", path);
			return (-1);
		}

		if (!done)
			*slash = '/';
	}

	return (0);
}

/*
 * cpio_options()
 *	look at the user specified flags. set globals as required and check if
 *	the user specified a legal set of flags. If not, complain and exit
 */

static void
cpio_set_action(int op)
{
	if ((act == APPND && op == ARCHIVE) || (act == ARCHIVE && op == APPND))
		act = APPND;
	else if ((act == LIST && op == EXTRACT) || (act == EXTRACT && op == LIST))
		act = LIST;
	else if (act != ERROR && act != op)
		cpio_usage();
	else
		act = op;
}

static void
cpio_options(int argc, char **argv)
{
	const char *errstr;
	int c, list_only = 0;
	char *str;
	int fd;
	const char *optstr;
	FSUB tmp;

	kflag = 1;
	pids = 1;
	pmode = 1;
	pmtime = 0;
	arcname = NULL;
	dflag = 1;
	nodirs = 1;
	optstr = "iop";
	opterr = 0;
	while ((c = getopt(argc, argv, optstr)) != -1) {
		switch (c) {
		case '0':
			/*
			 * Use \0 as pathname terminator.
			 * (For use with the -print0 option of find(1).)
			 */
			zeroflag = 1;
			break;
#ifndef SMALL
		case '6':
			/*
			 * process Version 6 cpio format
			 */
			frmt = &(fsub[FSUB_BCPIO]);
			break;
#endif
		case 'A':
			/*
			 * append mode
			 */
			cpio_set_action(APPND);
			break;
		case 'a':
			/*
			 * preserve access time on files read
			 */
			tflag = 1;
			break;
		case 'B':
			/*
			 * Use 5120 byte block size
			 */
			wrblksz = 5120;
			break;
		case 'b':
			/*
			 * swap bytes and half-words when reading data
			 */
			break;
		case 'C':
			/*
			 * set block size in bytes
			 */
			wrblksz = strtonum(optarg, 0, INT_MAX, &errstr);
			if (errstr) {
				paxwarn(1, "Invalid block size %s: %s",
				    optarg, errstr);
				pax_usage();
			}
			break;
		case 'c':
			/*
			 * ASCII cpio header
			 */
			frmt = &(fsub[FSUB_CPIO]);
			break;
		case 'd':
			/*
			 * create directories as needed
			 */
			nodirs = 0;
			break;
		case 'E':
			/*
			 * file with patterns to extract or list
			 */
			if ((fd = binopen2(0, optarg, O_RDONLY)) == -1) {
				syswarn(1, errno, "Unable to open %s",
				    optarg);
				cpio_usage();
			}
			while ((str = fdgetline(fd)) != NULL) {
				pat_add(str, NULL);
			}
			close(fd);
			if (fdgetline_err) {
				paxwarn(1,
				    "Unable to read from %s", optarg);
				cpio_usage();
			}
			break;
		case 'F':
		case 'I':
		case 'O':
			/*
			 * filename where the archive is stored
			 */
			if ((optarg[0] == '-') && (optarg[1]== '\0')) {
				/*
				 * treat a - as stdin
				 */
				arcname = NULL;
				break;
			}
			arcname = optarg;
			break;
		case 'f':
			/*
			 * invert meaning of pattern list
			 */
			cflag = 1;
			break;
		case 'H':
			/*
			 * specify an archive format on write
			 */
			if (!strcmp(optarg, "bin")) {
				tmp.name = "bcpio";
			} else if (!strcmp(optarg, "crc")) {
				tmp.name = "sv4crc";
			} else if (!strcmp(optarg, "newc")) {
				tmp.name = "sv4cpio";
			} else if (!strcmp(optarg, "odc")) {
				tmp.name = "cpio";
			} else {
				tmp.name = optarg;
			}
			if (gather_format(&tmp, "cpio", 'H'))
				cpio_usage();
			break;
		/* I: see F */
		case 'i':
			/*
			 * restore an archive
			 */
			cpio_set_action(EXTRACT);
			break;
#ifndef SMALL
		case 'J':
			/*
			 * use xz (non-standard option)
			 */
			compress_program = XZ_CMD;
			break;
		case 'j':
			/*
			 * use bzip2 (non-standard option)
			 */
			compress_program = BZIP2_CMD;
			break;
#endif
		case 'k':
			break;
		case 'L':
			/*
			 * follow symbolic links
			 */
			Lflag = 1;
			break;
		case 'l':
			/*
			 * use links instead of copies when possible
			 */
			lflag = 1;
			break;
		case 'M':
			/*
			 * MirOS extension: archive normaliser
			 */
			process_M(optarg, cpio_usage);
			break;
		case 'm':
			/*
			 * preserve modification time
			 */
			pmtime = 1;
			break;
		/* O: see F */
		case 'o':
			/*
			 * create an archive
			 */
			cpio_set_action(ARCHIVE);
			frmt = &(fsub[FSUB_SV4CRC]);
			break;
		case 'p':
			/*
			 * copy-pass mode
			 */
			cpio_set_action(COPY);
			break;
		case 'r':
			/*
			 * interactively rename files
			 */
			iflag = 1;
			break;
		case 'S':
			/*
			 * swap halfwords after reading data
			 */
			break;
		case 's':
			/*
			 * swap bytes after reading data
			 */
			break;
		case 't':
			/*
			 * list contents of archive
			 */
			list_only = 1;
			break;
		case 'u':
			/*
			 * replace newer files
			 */
			kflag = 0;
			break;
		case 'V':
			/*
			 * print a dot for each file processed
			 */
			Vflag++;
			break;
		case 'v':
			/*
			 * verbose operation mode
			 */
			++vflag;
			break;
#ifndef SMALL
		case 'Z':
			/*
			 * use compress (non-standard option)
			 */
			compress_program = COMPRESS_CMD;
			break;
#endif
		case 'z':
			/*
			 * use gzip (non-standard option)
			 */
			compress_program = GZIP_CMD;
			break;
		case '?':
		default:
			if (opterr == 0) {
				paxwarn(1, "need -i or -o or -p option first");
			}
			cpio_usage();
			break;
		}
		if (opterr == 0) {
			optstr = "06AaBbC:cdE:F:fH:I:iJjkLlM:mO:oprSstuVvZz";
			opterr = 1;
		}
	}
	argc -= optind;
	argv += optind;

	/*
	 * process the args as they are interpreted by the operation mode
	 */
	switch (act) {
	case EXTRACT:
		if (list_only) {
			act = LIST;

			/*
			 * cpio is like pax: list to stderr
			 * unless in list mode
			 */
			listf = stdout;
		}
		while (*argv != NULL)
			if (pat_add(*argv++, NULL) < 0)
				cpio_usage();
		break;
	case COPY:
		if (*argv == NULL) {
			paxwarn(0, "Destination directory was not supplied");
			cpio_usage();
		}
		dirptr = *argv;
		if (mkpath(dirptr) < 0)
			cpio_usage();
		--argc;
		++argv;
		/* FALLTHROUGH */
	case ARCHIVE:
	case APPND:
		if (*argv != NULL)
			cpio_usage();
		/*
		 * no read errors allowed on updates/append operation!
		 */
		maxflt = 0;
		while ((str = fdgetline(STDIN_FILENO)) != NULL) {
			ftree_add(str, 0);
		}
		if (fdgetline_err) {
			paxwarn(1, "Unable to read from %s",
			    "stdin");
			cpio_usage();
		}
		break;
	default:
		cpio_usage();
		break;
	}
}

/*
 * printflg()
 *	print out those invalid flag sets found to the user
 */

static void
printflg(unsigned int flg)
{
	int nxt;
	int pos = 0;

	(void)fprintf(stderr,"%s: Invalid combination of options:", argv0);
	while ((nxt = ffs(flg)) != 0) {
		flg >>= nxt;
		pos += nxt;
		(void)fprintf(stderr, " -%c", flgch[pos-1]);
	}
	(void)putc('\n', stderr);
}

/*
 * c_frmt()
 *	comparison routine used by bsearch to find the format specified
 *	by the user
 */

static int
c_frmt(const void *a, const void *b)
{
	if (!((const FSUB *)b)->name)
		return (-1);
	return(strcmp(((const FSUB *)a)->name, ((const FSUB *)b)->name));
}

/*
 * opt_next()
 *	called by format specific options routines to get each format specific
 *	flag and value specified with -o
 * Return:
 *	pointer to next OPLIST entry or NULL (end of list).
 */

OPLIST *
opt_next(void)
{
	OPLIST *opt;

	if ((opt = ophead) != NULL)
		ophead = ophead->fow;
	return(opt);
}

/*
 * bad_opt()
 *	generic routine used to complain about a format specific options
 *	when the format does not support options.
 */

int
bad_opt(void)
{
	OPLIST *opt;

	if (ophead == NULL)
		return(0);
	/*
	 * print all we were given
	 */
	paxwarn(1,"These format options are not supported");
	while ((opt = opt_next()) != NULL)
		(void)fprintf(stderr, "\t%s = %s\n", opt->name, opt->value);
	pax_usage();
	return(0);
}

/*
 * opt_add()
 *	breaks the value supplied to -o into a option name and value. options
 *	are given to -o in the form -o name-value,name=value
 *	multiple -o may be specified.
 * Return:
 *	0 if format in name=value format, -1 if -o is passed junk
 */

int
opt_add(const char *str)
{
	OPLIST *opt;
	char *frpt;
	char *pt;
	char *endpt;
	char *dstr;

	if ((str == NULL) || (*str == '\0')) {
		paxwarn(0, "Invalid option name");
		return(-1);
	}
	if ((dstr = strdup(str)) == NULL) {
		paxwarn(0, "Unable to allocate space for option list");
		return(-1);
	}
	frpt = endpt = dstr;

	/*
	 * break into name and values pieces and stuff each one into a
	 * OPLIST structure. When we know the format, the format specific
	 * option function will go through this list
	 */
	while ((frpt != NULL) && (*frpt != '\0')) {
		if ((endpt = strchr(frpt, ',')) != NULL)
			*endpt = '\0';
		if ((pt = strchr(frpt, '=')) == NULL) {
			paxwarn(0, "Invalid options format");
			free(dstr);
			return(-1);
		}
		if ((opt = malloc(sizeof(OPLIST))) == NULL) {
			paxwarn(0, "Unable to allocate space for option list");
			free(dstr);
			return(-1);
		}
		/* parts of string going onto the OPLIST */
		dstr = NULL;
		*pt++ = '\0';
		opt->name = frpt;
		opt->value = pt;
		opt->fow = NULL;
		if (endpt != NULL)
			frpt = endpt + 1;
		else
			frpt = NULL;
		if (ophead == NULL) {
			optail = ophead = opt;
			continue;
		}
		optail->fow = opt;
		optail = opt;
	}
	free(dstr);
	return(0);
}

/*
 * str_offt()
 *	Convert an expression of the following forms to an off_t > 0.
 *	1) A positive decimal number.
 *	2) A positive decimal number followed by a b (mult by 512).
 *	3) A positive decimal number followed by a k (mult by 1024).
 *	4) A positive decimal number followed by a m (mult by 512).
 *	5) A positive decimal number followed by a w (mult by sizeof int)
 *	6) Two or more positive decimal numbers (with/without k,b or w).
 *	   separated by x (also * for backwards compatibility), specifying
 *	   the product of the indicated values.
 * Return:
 *	0 for an error, a positive value o.w.
 */

#if HAVE_OFFT_LONG
#define OT_MAX	LONG_MAX
#define strtoot	strtol
#else
#define OT_MAX	LLONG_MAX
#define strtoot	strtoll
#endif

static off_t
str_offt(char *val)
{
	char *expr;
	off_t num, t;

	num = strtoot(val, &expr, 0);
	if ((num == OT_MAX) || (num <= 0) || (expr == val))
		return (0);

	switch (*expr) {
	case 'b':
		t = num;
		num *= 512;
		if (t > num)
			return (0);
		++expr;
		break;
	case 'k':
		t = num;
		num *= 1024;
		if (t > num)
			return (0);
		++expr;
		break;
	case 'm':
		t = num;
		num *= 1048576;
		if (t > num)
			return (0);
		++expr;
		break;
	case 'w':
		t = num;
		num *= sizeof(int);
		if (t > num)
			return (0);
		++expr;
		break;
	}

	switch (*expr) {
	case '\0':
		break;
	case '*':
	case 'x':
		t = num;
		num *= str_offt(expr + 1);
		if (t > num)
			return(0);
		break;
	default:
		return(0);
	}
	return (num);
}

#ifndef SMALL
/*
 * no_op()
 *	for those option functions where the archive format has nothing to do.
 * Return:
 *	0
 */

static int
no_op(void)
{
	return (0);
}

static int
no_op_i(int is_app MKSH_A_UNUSED)
{
	return (0);
}
#endif

/*
 * pax_usage()
 *	print the usage summary to the user
 */

void
pax_usage(void)
{
	(void)fputs(
	    "usage: pax [-0cdJjnOvz] [-E limit] [-f archive] [-G group] [-s replstr]\n"
	    "           [-T range] [-U user] [pattern ...]\n"
	    "       pax -r [-0cDdiJjknOuvYZz] [-E limit] [-f archive] [-G group] [-M flag]\n"
	    "           [-o options] [-p string] [-s replstr] [-T range] [-U user]\n"
	    "           [pattern ...]\n"
	    "       pax -w [-0adHiJjLOPtuvXz] [-B bytes] [-b blocksize] [-f archive]\n"
	    "           [-G group] [-M flag] [-o options] [-s replstr] [-T range]\n"
	    "           [-U user] [-x format] [file ...]\n"
	    "       pax -rw [-0DdHikLlnOPtuvXYZ] [-G group] [-p string] [-s replstr]\n"
	    "           [-T range] [-U user] [file ...] directory\n",
	    stderr);
	exit(1);
}

/*
 * tar_usage()
 *	print the usage summary to the user
 */

void
tar_usage(void)
{
	(void)fputs(
	    "usage: tar {crtux}[014578AabefHhJjLmNOoPpqRSsvwXZz]\n"
	    "           [blocking-factor | archive | replstr] [-C directory] [-I file]\n"
	    "           [file ...]\n"
	    "       tar {-crtux} [-014578AaeHhJjLmNOoPpqRSvwXZz] [-b blocking-factor]\n"
	    "           [-C directory] [-f archive] [-I file] [-M flag] [-s replstr]\n"
	    "           [file ...]\n",
	    stderr);
	exit(1);
}

/*
 * cpio_usage()
 *	print the usage summary to the user
 */

void
cpio_usage(void)
{
	(void)fputs(
	    "usage: cpio -o [-0AaBcJjLVvZz] [-C bytes] [-F archive] [-H format]\n"
	    "               [-M flag] [-O archive] <name-list [>archive]\n"
	    "       cpio -i [-06BbcdfJjmrSstuVvZz] [-C bytes] [-E file] [-F archive]\n"
	    "               [-H format] [-I archive] [-M flag] [pattern ...] [<archive]\n"
	    "       cpio -p [-0adLlmuVv] destination-directory <name-list\n",
	    stderr);
	exit(1);
}

void
anonarch_init(void)
{
	if (anonarch & ANON_VERBOSE) {
		anonarch &= ~ANON_VERBOSE;
		paxwarn(0, "debug: -M 0x%08X -x %s", anonarch, frmt->name);
	}
}

static void
process_M(const char *arg, void (*call_usage)(void))
{
	int j, k = 0;

	if ((arg[0] >= '0') && (arg[0] <= '9')) {
#if HAVE_STRTONUM
		const char *s;
		int64_t i = strtonum(arg, 0,
		    ANON_MAXVAL, &s);
		if (s)
			errx(1, "%s M value: %s", s,
			    arg);
#else
		char *ep;
		long long i = strtoll(arg, &ep, 0);
		if ((ep == arg) || (*ep != '\0') ||
		    (i < 0) || (i > ANON_MAXVAL))
			errx(1, "impossible M value:"
			    " %s", arg);
#endif
		anonarch = i;
		return;
	}

	if (!strncmp(arg, "no-", 3)) {
		j = 0;
		arg += 3;
	} else
		j = 1;
	if (!strncmp(arg, "uid", 3) ||
	    !strncmp(arg, "gid", 3)) {
		k = ANON_UIDGID;
	} else if (!strncmp(arg, "ino", 3)) {
		k = ANON_INODES;
	} else if (!strncmp(arg, "mtim", 4)) {
		k = ANON_MTIME;
	} else if (!strncmp(arg, "link", 4)) {
		k = ANON_HARDLINKS;
	} else if (!strncmp(arg, "norm", 4)) {
		k = ANON_UIDGID | ANON_INODES | ANON_NUMID |
		    ANON_MTIME | ANON_HARDLINKS;
	} else if (!strncmp(arg, "root", 4)) {
		k = ANON_UIDGID | ANON_INODES | ANON_NUMID;
	} else if (!strncmp(arg, "dist", 4)) {
		k = ANON_UIDGID | ANON_INODES | ANON_NUMID |
		    ANON_HARDLINKS;
	} else if (!strncmp(arg, "set", 3)) {
		k = ANON_INODES | ANON_HARDLINKS;
	} else if (!strncmp(arg, "v", 1)) {
		k = ANON_VERBOSE;
	} else if (!strncmp(arg, "debug", 5)) {
		k = ANON_DEBUG;
	} else if (!strncmp(arg, "lncp", 4)) {
		k = ANON_LNCP;
	} else if (!strncmp(arg, "numid", 5)) {
		k = ANON_NUMID;
	} else if (!strncmp(arg, "gslash", 6)) {
		k = ANON_DIRSLASH;
	} else
		call_usage();
	if (j)
		anonarch |= k;
	else
		anonarch &= ~k;
}

void
guess_compress_program(int wr __attribute__((__unused__)))
{
	const char *ccp;

	if (compress_program != COMPRESS_GUESS_CMD)
		return;

	if (arcname == NULL || (ccp = strrchr(arcname, '.')) == NULL) {
		compress_program = NULL;
		return;
	}
	++ccp;

	/* guess standard format gzip */
	if (!strcmp(ccp, "gz") ||
	    !strcmp(ccp, "tgz") ||
	    !strcmp(ccp, "cgz") ||
	    !strcmp(ccp, "ngz") ||
	    !strcmp(ccp, "taz")) {
		compress_program = GZIP_CMD;
		return;
	}

#ifndef SMALL
	/* guess extended format xz */
	if (!strcmp(ccp, "xz") ||
	    !strcmp(ccp, "txz") ||
	    !strcmp(ccp, "cxz") ||
	    !strcmp(ccp, "nxz")) {
		compress_program = XZ_CMD;
		return;
	}

	/* guess extended format bzip2 (not bzip) */
	if (!strcmp(ccp, "bz2") ||
	    !strcmp(ccp, "tbz") ||
	    !strcmp(ccp, "tz2") ||
	    !strcmp(ccp, "tbz2") ||
	    !strcmp(ccp, "cbz") ||
	    !strcmp(ccp, "nbz")) {
		compress_program = BZIP2_CMD;
		return;
	}

	/* guess standard format Unix compress */
	if (!strcmp(ccp, "Z") ||
	    !strcmp(ccp, "mcz") ||
	    !strcmp(ccp, "taZ")) {
		compress_program = COMPRESS_CMD;
		return;
	}

	/* guess extended format lzma (using xz for decompression) */
	if (!strcmp(ccp, "lzma")) {
		compress_program = wr ? LZMA_WRCMD : XZ_CMD;
		return;
	}

	/* guess extended format lzop */
	if (!strcmp(ccp, "lzo")) {
		compress_program = LZOP_CMD;
		return;
	}
#endif

	/* no sugar */
	compress_program = NULL;
}

#ifndef SMALL
static int
compress_id(char *blk, int size)
{
	if (size >= 2 && blk[0] == '\037' && blk[1] == '\235') {
		paxwarn(0, "input compressed with %s; use the -%c option"
		    " to decompress it", "compress", 'Z');
		exit(1);
	}
	return (-1);
}

static int
gzip_id(char *blk, int size)
{
	if (size >= 2 && blk[0] == '\037' && blk[1] == '\213') {
		paxwarn(0, "input compressed with %s; use the -%c option"
		    " to decompress it", "gzip", 'z');
		exit(1);
	}
	return (-1);
}

static int
bzip2_id(char *blk, int size)
{
	if (size >= 3 && blk[0] == 'B' && blk[1] == 'Z' && blk[2] == 'h') {
		paxwarn(0, "input compressed with %s; use the -%c option"
		    " to decompress it", "bzip2", 'j');
		exit(1);
	}
	return (-1);
}

static int
xz_id(char *blk, int size)
{
	if (size >= 6 && memcmp(blk, "\xFD\x37\x7A\x58\x5A", 6) == 0) {
		paxwarn(0, "input compressed with %s; use the -%c option"
		    " to decompress it", "xz", 'J');
		exit(1);
	}
	return (-1);
}

void
mircpio_deprecated(const char *what, const char *with)
{
	paxwarn(0, "the old MirCPIO %s is deprecated and will be removed soon; use %s instead",
	    what, with);
}
#endif /* !SMALL */
@


1.70
log
@use mksh-inspired NELEM/SELEM macros for bsearch(3) arguments
@
text
@d66 1
a66 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.66 2018/12/13 07:09:10 tg Exp $");
d1671 2
@


1.69
log
@deprecate some old earliest MirCPIO extensions:

 tar -R and -S (also dedocumented)
 the dist, v4norm, v4root formats (which already were undocumented)

but indicate in tar(1) that YMMV
@
text
@d72 3
d360 1
a360 1
	    sizeof(fsub) / sizeof(FSUB), sizeof(FSUB), c_frmt)) != NULL)
d364 1
a364 1
	for (i = 0; i < (sizeof(fsub)/sizeof(FSUB)); ++i)
@


1.68
log
@port to Debian sid/{amd64,i386,hurd-i386,x32}, {stretch,jessie}/{amd64,i386}
@
text
@d225 1
d230 1
d254 1
a264 1
#ifndef SMALL
d995 1
d999 2
d1002 1
d1010 1
d1014 2
d1017 1
d2130 7
@


1.67
log
@fix cast-qual
@
text
@d1784 4
a1787 1
#if HAVE_OFFT_LLONG
a1789 3
#else
#define OT_MAX	LONG_MAX
#define strtoot	strtol
@


1.66
log
@fixing and string pooling and int shortening offensive
@
text
@d5 1
a5 1
 * Copyright (c) 2005, 2006, 2007, 2009, 2011, 2012, 2014, 2016
d66 1
a66 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.65 2018/12/12 18:08:44 tg Exp $");
d354 1
a354 1
	if ((frmt = (FSUB *)bsearch((void *)fp, (void *)fsub,
@


1.65
log
@merge the npax branch into MAIN

asides from a missing dprintf and portability, this ought to be
good enough for people (well me) to play with for now
@
text
@d66 1
a66 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.63 2017/10/14 21:26:53 tg Exp $");
d173 1
d178 1
d202 1
a202 1
 *	name, blksz, hdsz, udev, hlk, blkagn, inhead, id, st_read,
d204 1
a204 1
 *	rd_data, wr_data, options, is_uar
d207 1
a207 1
FSUB fsub[] = {
d210 1
a210 1
	{"ar", 512, sizeof(HD_AR), 0, 0, 0, 0, uar_id, no_op,
d212 1
a212 1
	rd_wrfile, uar_wr_data, bad_opt, 1},
d215 1
a215 1
	{"bcpio", 5120, sizeof(HD_BCPIO), 1, 0, 0, 1, bcpio_id, cpio_strd,
d217 1
a217 1
	rd_wrfile, wr_rdfile, bad_opt, 0},
d221 1
a221 1
	{"cpio", 5120, sizeof(HD_CPIO), 1, 0, 0, 1, cpio_id, cpio_strd,
d223 1
a223 1
	rd_wrfile, wr_rdfile, bad_opt, 0},
d226 1
a226 1
	{"dist", 512, sizeof(HD_CPIO), 1, 0, 0, 1, cpio_id, cpio_strd,
d228 1
a228 1
	rd_wrfile, wr_rdfile, bad_opt, 0},
d231 1
a231 1
	{"sv4cpio", 5120, sizeof(HD_VCPIO), 1, 0, 0, 1, vcpio_id, cpio_strd,
d233 1
a233 1
	rd_wrfile, wr_rdfile, bad_opt, 0},
d236 1
a236 1
	{"sv4crc", 5120, sizeof(HD_VCPIO), 1, 0, 0, 1, crc_id, crc_strd,
d238 1
a238 1
	rd_wrfile, wr_rdfile, bad_opt, 0},
d242 1
a242 1
	{"tar", 10240, BLKMULT, 0, 1, BLKMULT, 0, tar_id, no_op,
d244 1
a244 1
	rd_wrfile, wr_rdfile, tar_opt, 0},
d248 1
a248 1
	{"ustar", 10240, BLKMULT, 0, 1, BLKMULT, 0, ustar_id, ustar_strd,
d250 1
a250 1
	rd_wrfile, wr_rdfile, tar_opt, 0},
d253 1
a253 1
	{"v4norm", 512, sizeof(HD_VCPIO), 1, 0, 0, 1, crc_id, crc_strd,
d255 1
a255 1
	rd_wrfile, wr_rdfile, bad_opt, 0},
d258 1
a258 1
	{"v4root", 512, sizeof(HD_VCPIO), 1, 0, 0, 1, crc_id, crc_strd,
d260 1
a260 1
	rd_wrfile, wr_rdfile, bad_opt, 0},
d264 1
a264 1
	{NULL, 0, 4, 0, 0, 0, 0, compress_id, NULL,
d266 1
a266 1
	NULL, NULL, NULL, 0},
d268 1
a268 1
	{NULL, 0, 6, 0, 0, 0, 0, xz_id, NULL,
d270 1
a270 1
	NULL, NULL, NULL, 0},
d272 1
a272 1
	{NULL, 0, 4, 0, 0, 0, 0, bzip2_id, NULL,
d274 1
a274 1
	NULL, NULL, NULL, 0},
d276 1
a276 1
	{NULL, 0, 4, 0, 0, 0, 0, gzip_id, NULL,
d278 1
a278 1
	NULL, NULL, NULL, 0},
d287 1
a287 1
const int ford[] = {
d309 1
a309 1
int to_stdout = 0;
d314 1
a314 1
int havechd = 0;
d349 17
a375 1
	unsigned i;
d689 3
a691 13
			if ((frmt = (FSUB *)bsearch((void *)&tmp, (void *)fsub,
			    sizeof(fsub)/sizeof(FSUB), sizeof(FSUB), c_frmt)) != NULL) {
				flg |= XF;
				break;
			}
			paxwarn(1, "Unknown -x format: %s", optarg);
			(void)fputs("pax: Known -x formats are:", stderr);
			for (i = 0; i < (sizeof(fsub)/sizeof(FSUB)); ++i)
				if (fsub[i].name != NULL)
					(void)fprintf(stderr, " %s",
					    fsub[i].name);
			(void)fputs("\n\n", stderr);
			pax_usage();
a1310 1
	unsigned i;
d1443 2
a1444 11
			if ((frmt = (FSUB *)bsearch((void *)&tmp, (void *)fsub,
			    sizeof(fsub)/sizeof(FSUB), sizeof(FSUB), c_frmt)) != NULL)
				break;
			paxwarn(1, "Unknown -H format: %s", optarg);
			(void)fputs("cpio: Known -H formats are:", stderr);
			for (i = 0; i < (sizeof(fsub)/sizeof(FSUB)); ++i)
				if (fsub[i].name != NULL)
					(void)fprintf(stderr, " %s",
					    fsub[i].name);
			(void)fputs("\n\n", stderr);
			cpio_usage();
d2114 2
a2115 1
		paxwarn(0, "input compressed with xz");
@


1.64
log
@slowmerge (untested though)
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.101 2016/12/26 23:43:52 krw Exp $	*/
d5 1
a5 1
 * Copyright (c) 2005, 2006, 2007, 2012, 2014, 2016
d39 4
a42 2
#include <sys/param.h>
#include <sys/time.h>
a43 2
#include <stdio.h>
#include <string.h>
a46 2
#include <unistd.h>
#include <stdlib.h>
d48 1
d50 10
a59 1
#include <time.h>
d61 1
a61 1
#include "options.h"
a63 1
#include "ar.h"
a65 4
#if HAS_TAPE
#include <sys/mtio.h>
#endif

a66 6
__IDSTRING(rcsid_ar_h, MIRCPIO_AR_H);
__IDSTRING(rcsid_cpio_h, MIRCPIO_CPIO_H);
__IDSTRING(rcsid_extern_h, MIRCPIO_EXTERN_H);
__IDSTRING(rcsid_options_h, MIRCPIO_OPTIONS_H);
__IDSTRING(rcsid_pax_h, MIRCPIO_PAX_H);
__IDSTRING(rcsid_tar_h, MIRCPIO_TAR_H);
d72 74
a145 3
#ifdef __GLIBC__
char *fgetln(FILE *, size_t *);
#endif
d159 2
d165 1
a165 1
static void pax_usage(void) __attribute__((__noreturn__));
d168 1
a168 1
static void tar_usage(void) __attribute__((__noreturn__));
d171 1
a171 2
static void cpio_usage(void) __attribute__((__noreturn__));
int mkpath(char *);
d173 4
a176 1
static void process_M(const char *, void (*)(void));
d196 2
a197 2
 *	Format specific routine table - MUST BE IN SORTED ORDER BY NAME
 *	(see enum fsub_order in options.h for index)
d200 1
a200 1
 * 	name, blksz, hdsz, udev, hlk, blkagn, inhead, id, st_read,
d248 1
a248 1
	rd_wrfile, wr_rdfile, bad_opt, 0},
d259 19
d289 4
d327 1
a327 1
	 * are we acting like pax, tar or cpio (based on argv[0])
d329 3
a331 1
	if ((n = strlen(argv[0])) >= 3 && !strcmp(argv[0] + n - 3, NM_TAR)) {
d333 1
d335 1
a335 1
	} else if (n >= 4 && !strcmp(argv[0] + n - 4, NM_CPIO)) {
d337 1
d340 1
d342 1
d357 1
a357 1
	size_t i;
d360 1
d370 8
d384 16
d417 8
d432 13
d452 18
d498 7
d512 6
d525 6
d539 7
d610 11
d628 11
d650 1
a650 1
			vflag++;
d659 7
d679 3
a681 1
				(void)fprintf(stderr, " %s", fsub[i].name);
a684 117
		case 'z':
			/*
			 * use gzip (non-standard option)
			 */
			compress_program = GZIP_CMD;
			break;
		case 'B':
			/*
			 * non-standard option on number of bytes written on a
			 * single archive volume.
			 */
			if ((wrlimit = str_offt(optarg)) <= 0) {
				paxwarn(1, "Invalid write limit %s", optarg);
				pax_usage();
			}
			if (wrlimit % BLKMULT) {
				paxwarn(1, "Write limit is not a %d byte multiple",
				    BLKMULT);
				pax_usage();
			}
			flg |= CBF;
			break;
		case 'D':
			/*
			 * on extraction check file inode change time before the
			 * modification of the file name (non-standard option)
			 */
			Dflag = 1;
			flg |= CDF;
			break;
		case 'E':
			/*
			 * non-standard limit on read faults
			 * 0 indicates stop after first error, values
			 * indicate a limit, "NONE" try forever
			 */
			flg |= CEF;
			if (strcmp(NONE, optarg) == 0)
				maxflt = -1;
			else if ((maxflt = atoi(optarg)) < 0) {
				paxwarn(1, "Error count value must be positive");
				pax_usage();
			}
			break;
		case 'G':
			/*
			 * non-standard option for selecting files within an
			 * archive by group (gid or name)
			 */
			if (grp_add(optarg) < 0) {
				pax_usage();
				break;
			}
			flg |= CGF;
			break;
		case 'H':
			/*
			 * follow command line symlinks only
			 */
			Hflag = 1;
			flg |= CHF;
			break;
		case 'L':
			/*
			 * follow symlinks
			 */
			Lflag = 1;
			flg |= CLF;
			break;
		case 'M':
			/*
			 * MirOS extension: archive normaliser
			 */
			process_M(optarg, pax_usage);
			break;
		case 'O':
			/*
			 * Force one volume.  Non standard option.
			 */
			force_one_volume = 1;
			break;
		case 'P':
			/*
			 * do NOT follow symlinks (default)
			 */
			Lflag = 0;
			flg |= CPF;
			break;
		case 'T':
			/*
			 * non-standard option for selecting files within an
			 * archive by modification time range (lower,upper)
			 */
			if (trng_add(optarg) < 0) {
				pax_usage();
				break;
			}
			flg |= CTF;
			break;
		case 'U':
			/*
			 * non-standard option for selecting files within an
			 * archive by user (uid or name)
			 */
			if (usr_add(optarg) < 0) {
				pax_usage();
				break;
			}
			flg |= CUF;
			break;
		case 'X':
			/*
			 * do not pass over mount points in the filesystem
			 */
			Xflag = 1;
			flg |= CXF;
			break;
d701 1
a701 1
		case '0':
d703 1
a703 2
			 * Use \0 as pathname terminator.
			 * (For use with the -print0 option of find(1).)
d705 1
a705 2
			zeroflag = 1;
			flg |= C0F;
a779 1

a797 1
	int fstdin = 0;
d808 1
a808 1
	 * set default values
d818 18
d848 5
d864 4
a883 9
			if ((optarg[0] == '-') && (optarg[1]== '\0')) {
				/*
				 * treat a - as stdin
				 */
				fstdin = 1;
				arcname = NULL;
				break;
			}
			fstdin = 0;
d886 6
d898 18
d930 12
d948 4
d966 6
d985 4
a995 4
		case 'R':
			Oflag = FSUB_SV4CPIO;
			anonarch |= ANON_INODES | ANON_HARDLINKS;
			break;
d1015 1
d1028 6
a1041 71
		case 'z':
			/*
			 * use gzip (non-standard option)
			 */
			compress_program = GZIP_CMD;
			break;
		case 'B':
			/*
			 * nothing to do here, this is pax default
			 */
			break;
		case 'C':
			havechd++;
			chdname = optarg;
			break;
		case 'H':
			/*
			 * follow command line symlinks only
			 */
			Hflag = 1;
			break;
		case 'I':
			if (++nincfiles > incfiles_max) {
				size_t n = nincfiles + 3;
				struct incfile *p;

				p = realloc(incfiles,
				    sizeof(*incfiles) * n);
				if (p == NULL) {
					free(incfiles);
					incfiles = NULL;
					paxwarn(0, "Unable to allocate space "
					    "for option list");
					exit(1);
				}
				incfiles = p;
				incfiles_max = n;
			}
			incfiles[nincfiles - 1].file = optarg;
			incfiles[nincfiles - 1].dir = chdname;
			break;
		case 'L':
			/*
			 * follow symlinks
			 */
			Lflag = 1;
			break;
		case 'M':
			/*
			 * MirOS extension: archive normaliser
			 */
			process_M(optarg, tar_usage);
			break;
		case 'N':
			/*
			 * numeric uid and gid only
			 */
			anonarch |= ANON_NUMID;
			break;
		case 'P':
			/*
			 * do not remove leading '/' from pathnames
			 */
			rmleadslash = 0;
			break;
		case 'X':
			/*
			 * do not pass over mount points in the filesystem
			 */
			Xflag = 1;
			break;
d1050 5
a1054 17
		case '0':
			arcname = DEV_0;
			break;
		case '1':
			arcname = DEV_1;
			break;
		case '4':
			arcname = DEV_4;
			break;
		case '5':
			arcname = DEV_5;
			break;
		case '7':
			arcname = DEV_7;
			break;
		case '8':
			arcname = DEV_8;
d1068 1
a1068 1
	if (!fstdin && ((arcname == NULL) || (*arcname == '\0'))) {
a1071 4
		else if ((arcname[0] == '-') && (arcname[1]== '\0')) {
			arcname = NULL;
			fstdin = 1;
		}
d1073 2
d1076 5
a1080 4
	/* traditional tar behaviour (pax uses stderr unless in list mode) */
	if (fstdin == 1 && act == ARCHIVE)
		listf = stderr;
	else
d1083 1
a1083 1
	/* traditional tar behaviour (pax wants to read file list from stdin) */
d1127 3
a1129 2
					else if ((fd = open(file, O_RDONLY)) == -1) {
						paxwarn(1, "Unable to open file '%s' for read", file);
d1140 4
a1143 2
						paxwarn(1, "Problem with file '%s'",
						    file);
d1199 1
a1200 1
				int fd;
d1202 1
a1202 1
				/* set directory if needed */
d1210 3
a1212 2
				else if ((fd = open(file, O_RDONLY)) == -1) {
					paxwarn(1, "Unable to open file '%s' for read", file);
d1222 3
a1224 2
					paxwarn(1, "Problem with file '%s'",
					    file);
d1246 1
a1246 1
int
d1277 7
a1283 1
}
a1297 6
/*
 * cpio_options()
 *	look at the user specified flags. set globals as required and check if
 *	the user specified a legal set of flags. If not, complain and exit
 */

d1301 3
a1303 2
	int c;
	size_t i;
a1304 1
	FSUB tmp;
d1307 1
d1320 21
d1347 6
d1358 11
d1381 34
d1421 28
d1471 6
d1483 6
d1495 1
d1515 5
d1529 1
a1529 2
			cpio_set_action(LIST);
			listf = stdout;
d1547 1
a1547 99
			vflag++;
			break;
		case 'z':
			/*
			 * use gzip (non-standard option)
			 */
			compress_program = GZIP_CMD;
			break;
		case 'A':
			/*
			 * append mode
			 */
			cpio_set_action(APPND);
			break;
		case 'B':
			/*
			 * use 5120 byte block size
			 */
			wrblksz = 5120;
			break;
		case 'C':
			/*
			 * set block size in bytes
			 */
			wrblksz = atoi(optarg);
			break;
		case 'E':
			/*
			 * file with patterns to extract or list
			 */
			if ((fd = open(optarg, O_RDONLY)) == -1) {
				paxwarn(1, "Unable to open file '%s' for read", optarg);
				cpio_usage();
			}
			while ((str = fdgetline(fd)) != NULL) {
				pat_add(str, NULL);
			}
			close(fd);
			if (fdgetline_err) {
				paxwarn(1, "Problem with file '%s'", optarg);
				cpio_usage();
			}
			break;
		case 'F':
		case 'I':
		case 'O':
			/*
			 * filename where the archive is stored
			 */
			if ((optarg[0] == '-') && (optarg[1]== '\0')) {
				/*
				 * treat a - as stdin
				 */
				arcname = NULL;
				break;
			}
			arcname = optarg;
			break;
		case 'H':
			/*
			 * specify an archive format on write
			 */
			if (!strcmp(optarg, "bin")) {
				tmp.name = "bcpio";
			} else if (!strcmp(optarg, "crc")) {
				tmp.name = "sv4crc";
			} else if (!strcmp(optarg, "newc")) {
				tmp.name = "sv4cpio";
			} else if (!strcmp(optarg, "odc")) {
				tmp.name = "cpio";
			} else {
				tmp.name = optarg;
			}
			if ((frmt = (FSUB *)bsearch((void *)&tmp, (void *)fsub,
			    sizeof(fsub)/sizeof(FSUB), sizeof(FSUB), c_frmt)) != NULL)
				break;
			paxwarn(1, "Unknown -H format: %s", optarg);
			(void)fputs("cpio: Known -H formats are:", stderr);
			for (i = 0; i < (sizeof(fsub)/sizeof(FSUB)); ++i)
				(void)fprintf(stderr, " %s", fsub[i].name);
			(void)fputs("\n\n", stderr);
			cpio_usage();
			break;
		case 'L':
			/*
			 * follow symbolic links
			 */
			Lflag = 1;
			break;
		case 'M':
			/*
			 * MirOS extension: archive normaliser
			 */
			process_M(optarg, cpio_usage);
			break;
		case 'S':
			/*
			 * swap halfwords after reading data
			 */
d1557 1
a1557 1
		case '0':
d1559 1
a1559 2
			 * Use \0 as pathname terminator.
			 * (For use with the -print0 option of find(1).)
d1561 1
a1561 8
			zeroflag = 1;
			break;
#ifndef SMALL
		case '6':
			/*
			 * process Version 6 cpio format
			 */
			frmt = &(fsub[FSUB_BCPIO]);
a1562 1
#endif
a1582 1
	case LIST:
d1584 9
d1620 2
a1621 1
			paxwarn(1, "Problem while reading stdin");
d1644 1
a1644 1
		flg = flg >> nxt;
d1745 1
a1745 1
		if ((opt = (OPLIST *)malloc(sizeof(OPLIST))) == NULL) {
d1774 1
a1774 1
 * 	1) A positive decimal number.
d1786 3
a1788 3
#ifndef LONG_OFF_T
#define OT_MAX	ULLONG_MAX
#define strtoot	strtoull
d1790 2
a1791 2
#define OT_MAX	ULONG_MAX
#define strtoot	strtoul
d1798 1
a1798 1
	ot_type num, t;
d1843 1
a1843 1
			return (0);
d1846 1
a1846 1
		return (0);
d1848 1
a1848 1
	return ((off_t)num);
d1862 1
a1862 1
	return(0);
d1866 1
a1866 1
no_op_i(int is_app __attribute__((__unused__)))
d1868 1
a1868 1
	return(0);
d1947 1
a1947 1
#ifdef __OpenBSD__
d2077 45
@


1.63
log
@mising FALLTHROUGH for lint, complained by gcc on Debian
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.75 +1.88 +1.89 +1.91 2012/03/04 04:05:15 fgsch Exp $	*/
d63 1
a63 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.62 2017/08/07 20:10:15 tg Exp $");
@


1.62
log
@filesystem
@
text
@d63 1
a63 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.61 2017/07/20 21:15:50 tg Exp $");
d1006 1
@


1.61
log
@.lz and .tlz are claimed by lzip, drop most LZMA-Alone support
(one thing in which Lasse and Antonio agree)
@
text
@d63 1
a63 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.59 2016/10/25 19:09:57 tg Exp $");
d575 1
a575 1
			 * do not pass over mount points in the file system
d937 1
a937 1
			 * do not pass over mount points in the file system
@


1.60
log
@fixup after the import, also clears up lies in the manpage
@
text
@d1948 1
a1948 5
	if (!strcmp(ccp, "lz") ||
	    !strcmp(ccp, "lzma") ||
	    !strcmp(ccp, "tlz") ||
	    !strcmp(ccp, "clz") ||
	    !strcmp(ccp, "nlz")) {
@


1.59
log
@simplify Oflag handling
@
text
@d63 1
a63 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.58 2016/10/25 18:57:55 tg Exp $");
d194 1
a194 1
int ford[] = {
d205 1
a205 1
	-1
d794 1
d796 3
d801 1
d806 1
d1075 2
@


1.58
log
@fastmerge
@
text
@d63 1
a63 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.57 2016/03/12 13:20:48 tg Exp $");
d697 1
a697 1
	int Oflag = 0;
d719 1
a719 1
			Oflag = 5;
d794 1
a794 1
			Oflag = 1;
d798 1
a798 1
			Oflag = 2;
d822 1
a822 1
			Oflag = 3;
d826 1
a826 1
			Oflag = 4;
d1069 1
a1069 25
		switch(Oflag) {
		    case 0:
			frmt = &(fsub[FSUB_USTAR]);
			break;
#ifndef SMALL
		    case 1:
		    case 2:
			frmt = &(fsub[FSUB_TAR]);
			break;
#endif
		    case 3:
			frmt = &(fsub[FSUB_SV4CPIO]);
			break;
		    case 4:
			frmt = &(fsub[FSUB_SV4CRC]);
			break;
#ifndef SMALL
		    case 5:
			frmt = &(fsub[FSUB_AR]);
			break;
#endif
		    default:
			tar_usage();
			break;
		}
@


1.57
log
@drop support for bcpio and (old)tar on the floppy
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.75 2012/03/04 04:05:15 fgsch Exp $	*/
d63 1
a63 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.55 2016/03/12 12:53:28 tg Exp $");
d799 1
d973 10
a1074 2
			frmt = &(fsub[FSUB_TAR]);
			break;
a1076 2
			if (opt_add("write_opt=nodir") < 0)
				tar_usage();
a1165 5
	if (!fstdin && ((arcname == NULL) || (*arcname == '\0'))) {
		arcname = getenv("TAPE");
		if ((arcname == NULL) || (*arcname == '\0'))
			arcname = _PATH_DEFTAPE;
	}
@


1.56
log
@drop support for !gzip compression on the floppy
@
text
@d87 1
d90 1
d135 1
a135 1
/* 0: UNIX ARCHIVER */
a138 1
#endif
d140 1
a140 1
/* 1: OLD BINARY CPIO */
d144 1
d146 1
a146 1
/* 2: OLD OCTAL CHARACTER CPIO */
d151 1
a151 1
/* 3: OLD OCTAL CHARACTER CPIO, UID/GID CLEARED (ANONYMISED) */
d156 1
a156 1
/* 4: SVR4 HEX CPIO */
d161 1
a161 1
/* 5: SVR4 HEX CPIO WITH CRC */
d166 2
a167 1
/* 6: OLD TAR */
d171 1
d173 1
a173 1
/* 7: POSIX USTAR */
d178 1
a178 1
/* 8: SVR4 HEX CPIO WITH CRC, UID/GID/MTIME CLEARED (NORMALISED) */
d183 1
a183 1
/* 9: SVR4 HEX CPIO WITH CRC, UID/GID CLEARED (ANONYMISED) */
d196 1
d198 1
d202 1
d204 1
d215 1
a215 1
 * Do we have -C anywhere?
d218 1
d1062 1
d1071 1
d1464 1
d1471 1
d1751 1
d1770 1
@


1.55
log
@begin stripping down pax for the floppy: drop uar support
@
text
@d63 1
a63 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.54 2016/03/06 14:12:27 tg Exp $");
d106 1
d117 1
d303 1
d316 1
d764 1
d777 1
d925 1
d932 1
d1263 1
d1276 1
d1438 1
d1445 1
d1894 1
a1894 1
guess_compress_program(int wr)
d1917 1
d1961 1
@


1.54
log
@version the *.h files as idstrings, too
@
text
@d63 1
a63 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.51 2012/06/05 19:19:44 tg Exp $");
d121 1
d130 1
d135 1
a181 8
#define	F_OCPIO	1	/* format when called as cpio -6 */
#define	F_ACPIO	2	/* format when called as cpio -c */
#define	F_NCPIO	4	/* format when called as tar -R */
#define	F_CPIO	5	/* format when called as cpio or tar -S */
#define F_OTAR	6	/* format when called as tar -o */
#define F_TAR	7	/* format when called as tar */
int F_UAR = 0;
#define DEFLT	7	/* default write format from list above */
d188 9
a196 1
int ford[] = { 7, 6, 5, 4, 2, 1, -1 };
d631 1
a631 1
		frmt = &(fsub[DEFLT]);
d704 1
d708 1
d1043 1
a1043 1
			frmt = &(fsub[F_TAR]);
d1046 1
a1046 1
			frmt = &(fsub[F_OTAR]);
d1049 1
a1049 1
			frmt = &(fsub[F_OTAR]);
d1054 1
a1054 1
			frmt = &(fsub[F_NCPIO]);
d1057 1
a1057 1
			frmt = &(fsub[F_CPIO]);
d1059 1
d1061 1
a1061 1
			frmt = &(fsub[F_UAR]);
d1063 1
d1235 1
a1235 1
			frmt = &(fsub[F_ACPIO]);
d1286 1
a1286 1
			frmt = &(fsub[F_CPIO]);
d1445 1
a1445 1
			frmt = &(fsub[F_OCPIO]);
@


1.53
log
@apply changes from mpax-erstmalnurderbackport branch not related to the CVEs
@
text
@d64 6
@


1.52
log
@add -0 option to cpio to mirror pax
@
text
@d5 2
a6 2
 * Copyright (c) 2005, 2006, 2007, 2012, 2014
 *	Thorsten Glaser <tg@@mirbsd.org>
@


1.51
log
@get rid of fgetln wrapped by get_line
@
text
@d5 1
a5 1
 * Copyright (c) 2005, 2006, 2007, 2012
d63 1
a63 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.50 2012/06/05 17:56:22 tg Exp $");
d1421 7
d1443 1
a1443 1
			optstr = "6AaBbC:cdE:F:fH:I:iJjkLlM:mO:oprSstuVvZz";
d1783 1
a1783 1
	    "usage: cpio -o [-AaBcJjLVvZz] [-C bytes] [-F archive] [-H format]\n"
d1785 1
a1785 1
	    "       cpio -i [-6BbcdfJjmrSstuVvZz] [-C bytes] [-E file] [-F archive]\n"
d1787 1
a1787 1
	    "       cpio -p [-adLlmuVv] destination-directory <name-list\n",
@


1.50
log
@fastmerge
@
text
@d46 1
d63 1
a63 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.49 2012/05/20 17:21:44 tg Exp $");
a85 1
static char *get_line(FILE *fp);
a97 5
/* errors from get_line */
#define GET_LINE_FILE_CORRUPT 1
#define GET_LINE_OUT_OF_MEM 2
static int get_line_error;

d988 1
a988 1
					FILE *fp;
d992 2
a993 2
						fp = stdin;
					else if ((fp = fopen(file, "r")) == NULL) {
d997 1
a997 1
					while ((str = get_line(fp)) != NULL) {
d1002 5
a1006 4
					if (strcmp(file, "-") != 0)
						fclose(fp);
					if (get_line_error) {
						paxwarn(1, "Problem with file '%s'", file);
a1083 1
				FILE *fp;
d1085 1
d1094 2
a1095 2
					fp = stdin;
				else if ((fp = fopen(file, "r")) == NULL) {
d1099 1
a1099 1
				while ((str = get_line(fp)) != NULL) {
d1103 3
a1105 3
				if (strcmp(file, "-") != 0)
					fclose(fp);
				if (get_line_error) {
d1193 1
a1193 1
	FILE *fp;
d1345 1
a1345 1
			if ((fp = fopen(optarg, "r")) == NULL) {
d1349 1
a1349 1
			while ((str = get_line(fp)) != NULL) {
d1352 2
a1353 2
			fclose(fp);
			if (get_line_error) {
d1472 1
a1472 1
		while ((str = get_line(stdin)) != NULL) {
d1475 1
a1475 1
		if (get_line_error) {
a1705 23
char *
get_line(FILE *f)
{
	char *name, *temp;
	size_t len;

	name = fgetln(f, &len);
	if (!name) {
		get_line_error = ferror(f) ? GET_LINE_FILE_CORRUPT : 0;
		return(0);
	}
	if (name[len-1] != '\n')
		len++;
	temp = malloc(len);
	if (!temp) {
		get_line_error = GET_LINE_OUT_OF_MEM;
		return(0);
	}
	memcpy(temp, name, len-1);
	temp[len-1] = 0;
	return(temp);
}

@


1.49
log
@implement archive format auto-guessing  inspired by http://petereisentraut.blogspot.de/2012/05/time-to-retrain-fingers.html  with silent failback to no compressor; uses lzma only when writing .tlz and lzop transparently
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.74 2010/12/02 04:08:27 tedu Exp $	*/
d62 1
a62 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.47 2012/05/20 16:13:18 tg Exp $");
@


1.48
log
@use string pooling (also allows for comparisons, later)
@
text
@d111 6
d698 1
a698 1
	    "014578ABb:C:cef:HhI:JjLM:mNOoPpqRrSs:tuvwXxZz")) != -1) {
d703 7
d1784 1
a1784 1
	    "usage: tar {crtux}[014578AbefHhJjLmNOoPpqRSsvwXZz]\n"
d1787 1
a1787 1
	    "       tar {-crtux} [-014578AeHhJjLmNOoPpqRSvwXZz] [-b blocking-factor]\n"
d1887 72
@


1.47
log
@get rid of extern.h including other headers
@
text
@d62 1
a62 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.46 2012/02/27 22:31:01 tg Exp $");
d103 8
a110 5

#define GZIP_CMD	"gzip"		/* command to run as gzip */
#define COMPRESS_CMD	"compress"	/* command to run as compress */
#define BZIP2_CMD	"bzip2"		/* command to run as bzip2 */
#define XZ_CMD		"xz"		/* command to run as xz */
@


1.46
log
@ensure calling convention is upheld
@
text
@d50 1
d62 1
a62 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.45 2012/02/27 22:24:55 tg Exp $");
@


1.45
log
@KNF: style(9) says how to indent a switch
@
text
@d61 1
a61 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.44 2012/02/16 17:27:31 tg Exp $");
d1181 1
d1190 3
a1192 2
	while ((c = getopt(argc, argv,
	    "6AaBbC:cdE:F:fH:I:iJjkLlM:mO:oprSstuVvZz")) != -1)
d1416 3
d1422 5
@


1.44
log
@clean up some ugliness
@
text
@d61 1
a61 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.43 2012/02/16 17:11:46 tg Exp $");
d1192 148
a1339 189
			case 'a':
				/*
				 * preserve access time on files read
				 */
				tflag = 1;
				break;
			case 'b':
				/*
				 * swap bytes and half-words when reading data
				 */
				break;
			case 'c':
				/*
				 * ASCII cpio header
				 */
				frmt = &(fsub[F_ACPIO]);
				break;
			case 'd':
				/*
				 * create directories as needed
				 */
				nodirs = 0;
				break;
			case 'f':
				/*
				 * invert meaning of pattern list
				 */
				cflag = 1;
				break;
			case 'i':
				/*
				 * restore an archive
				 */
				cpio_set_action(EXTRACT);
				break;
			case 'J':
				/*
				 * use xz (non-standard option)
				 */
				compress_program = XZ_CMD;
				break;
			case 'j':
				/*
				 * use bzip2 (non-standard option)
				 */
				compress_program = BZIP2_CMD;
				break;
			case 'k':
				break;
			case 'l':
				/*
				 * use links instead of copies when possible
				 */
				lflag = 1;
				break;
			case 'm':
				/*
				 * preserve modification time
				 */
				pmtime = 1;
				break;
			case 'o':
				/*
				 * create an archive
				 */
				cpio_set_action(ARCHIVE);
				frmt = &(fsub[F_CPIO]);
				break;
			case 'p':
				/*
				 * copy-pass mode
				 */
				cpio_set_action(COPY);
				break;
			case 'r':
				/*
				 * interactively rename files
				 */
				iflag = 1;
				break;
			case 's':
				/*
				 * swap bytes after reading data
				 */
				break;
			case 't':
				/*
				 * list contents of archive
				 */
				cpio_set_action(LIST);
				listf = stdout;
				break;
			case 'u':
				/*
				 * replace newer files
				 */
				kflag = 0;
				break;
			case 'V':
				/*
				 * print a dot for each file processed
				 */
				Vflag++;
				break;
			case 'v':
				/*
				 * verbose operation mode
				 */
				vflag++;
				break;
			case 'z':
				/*
				 * use gzip (non-standard option)
				 */
				compress_program = GZIP_CMD;
				break;
			case 'A':
				/*
				 * append mode
				 */
				cpio_set_action(APPND);
				break;
			case 'B':
				/*
				 * use 5120 byte block size
				 */
				wrblksz = 5120;
				break;
			case 'C':
				/*
				 * set block size in bytes
				 */
				wrblksz = atoi(optarg);
				break;
			case 'E':
				/*
				 * file with patterns to extract or list
				 */
				if ((fp = fopen(optarg, "r")) == NULL) {
					paxwarn(1, "Unable to open file '%s' for read", optarg);
					cpio_usage();
				}
				while ((str = get_line(fp)) != NULL) {
					pat_add(str, NULL);
				}
				fclose(fp);
				if (get_line_error) {
					paxwarn(1, "Problem with file '%s'", optarg);
					cpio_usage();
				}
				break;
			case 'F':
			case 'I':
			case 'O':
				/*
				 * filename where the archive is stored
				 */
				if ((optarg[0] == '-') && (optarg[1]== '\0')) {
					/*
					 * treat a - as stdin
					 */
					arcname = NULL;
					break;
				}
				arcname = optarg;
				break;
			case 'H':
				/*
				 * specify an archive format on write
				 */
				if (!strcmp(optarg, "bin")) {
					tmp.name = "bcpio";
				} else if (!strcmp(optarg, "crc")) {
					tmp.name = "sv4crc";
				} else if (!strcmp(optarg, "newc")) {
					tmp.name = "sv4cpio";
				} else if (!strcmp(optarg, "odc")) {
					tmp.name = "cpio";
				} else {
					tmp.name = optarg;
				}
				if ((frmt = (FSUB *)bsearch((void *)&tmp, (void *)fsub,
				    sizeof(fsub)/sizeof(FSUB), sizeof(FSUB), c_frmt)) != NULL)
					break;
				paxwarn(1, "Unknown -H format: %s", optarg);
				(void)fputs("cpio: Known -H formats are:", stderr);
				for (i = 0; i < (sizeof(fsub)/sizeof(FSUB)); ++i)
					(void)fprintf(stderr, " %s", fsub[i].name);
				(void)fputs("\n\n", stderr);
d1341 9
a1349 2
				break;
			case 'L':
d1351 1
a1351 1
				 * follow symbolic links
d1353 1
a1353 1
				Lflag = 1;
d1355 20
a1374 26
			case 'M':
				/*
				 * MirOS extension: archive normaliser
				 */
				process_M(optarg, cpio_usage);
				break;
			case 'S':
				/*
				 * swap halfwords after reading data
				 */
				break;
			case 'Z':
				/*
				 * use compress (non-standard option)
				 */
				compress_program = COMPRESS_CMD;
				break;
			case '6':
				/*
				 * process Version 6 cpio format
				 */
				frmt = &(fsub[F_OCPIO]);
				break;
			case '?':
			default:
				cpio_usage();
d1376 40
d1424 4
a1427 9
		case LIST:
		case EXTRACT:
			while (*argv != NULL)
				if (pat_add(*argv++, NULL) < 0)
					cpio_usage();
			break;
		case COPY:
			if (*argv == NULL) {
				paxwarn(0, "Destination directory was not supplied");
d1429 25
a1453 24
			}
			dirptr = *argv;
			if (mkpath(dirptr) < 0)
				cpio_usage();
			--argc;
			++argv;
			/* FALLTHROUGH */
		case ARCHIVE:
		case APPND:
			if (*argv != NULL)
				cpio_usage();
			/*
			 * no read errors allowed on updates/append operation!
			 */
			maxflt = 0;
			while ((str = get_line(stdin)) != NULL) {
				ftree_add(str, 0);
			}
			if (get_line_error) {
				paxwarn(1, "Problem while reading stdin");
				cpio_usage();
			}
			break;
		default:
d1455 5
a1459 1
			break;
d1668 7
a1674 10
		case '\0':
			break;
		case '*':
		case 'x':
			t = num;
			num *= str_offt(expr + 1);
			if (t > num)
				return (0);
			break;
		default:
d1676 3
@


1.43
log
@Debian GNU/kFreeBSD can be more difficult to deal with than GNU/Hurd at times.

 switch from quad_t to using unsigned long / unsigned long long
 sanitise use of off_t-relevant types
 cast when printing off_t; use a once-defined type and format specifier
 convert This define is important into actual compile-time assertion
 simplify ifdef mess by always defining off_t specific routines
  instead of reusing those for long if off_t is just long
@
text
@d61 1
a61 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.42 2012/02/16 16:01:08 tg Exp $");
d291 1
a291 1
			gzip_program = XZ_CMD;
d297 1
a297 1
			gzip_program = BZIP2_CMD;
d440 1
a440 1
			gzip_program = GZIP_CMD;
d741 1
a741 1
			gzip_program = XZ_CMD;
d747 1
a747 1
			gzip_program = BZIP2_CMD;
d829 1
a829 1
			gzip_program = GZIP_CMD;
d900 1
a900 1
			gzip_program = COMPRESS_CMD;
d1231 1
a1231 1
				gzip_program = XZ_CMD;
d1237 1
a1237 1
				gzip_program = BZIP2_CMD;
d1306 1
a1306 1
				gzip_program = GZIP_CMD;
d1404 1
a1404 1
				gzip_program = COMPRESS_CMD;
@


1.42
log
@implement the GNU cpio option -V (print a dot per file processed)
sponsored by tarent solutions GmbH for work on evolvis (FusionForge)
@
text
@d61 1
a61 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.41 2012/02/12 01:02:06 tg Exp $");
d1618 8
d1630 1
a1630 1
	off_t num, t;
d1632 3
a1634 8
#	ifdef LONG_OFF_T
	num = strtol(val, &expr, 0);
	if ((num == LONG_MAX) || (num <= 0) || (expr == val))
#	else
	num = strtoq(val, &expr, 0);
	if ((num == QUAD_MAX) || (num <= 0) || (expr == val))
#	endif
		return(0);
d1641 1
a1641 1
			return(0);
d1648 1
a1648 1
			return(0);
d1655 1
a1655 1
			return(0);
d1662 1
a1662 1
			return(0);
d1675 1
a1675 1
				return(0);
d1678 1
a1678 1
			return(0);
d1680 1
a1680 1
	return(num);
@


1.41
log
@add most misc. patches from Debian (reopen #609825 as the test is bogus)
@
text
@d61 1
a61 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.40 2012/02/12 00:27:16 tg Exp $");
d1190 1
a1190 1
	    "6AaBbC:cdE:F:fH:I:iJjkLlM:mO:oprSstuvZz")) != -1)
d1290 6
d1773 1
a1773 1
	    "usage: cpio -o [-AaBcJjLvZz] [-C bytes] [-F archive] [-H format]\n"
d1775 1
a1775 1
	    "       cpio -i [-6BbcdfJjmrSstuvZz] [-C bytes] [-E file] [-F archive]\n"
d1777 1
a1777 1
	    "       cpio -p [-adLlmuv] destination-directory <name-list\n",
@


1.40
log
@merge OpenBSD
@
text
@d61 5
a65 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.39 2012/02/12 00:14:18 tg Exp $");
a1115 1
#ifdef _PATH_DEFTAPE
a1117 1
#endif
@


1.39
log
@update the usage and improve comments
@
text
@d61 1
a61 2
__SCCSID("@@(#)options.c	8.2 (Berkeley) 4/18/94");
__RCSID("$MirOS: src/bin/pax/options.c,v 1.38 2012/02/12 00:04:33 tg Exp $");
@


1.38
log
@slowmerge options.c; sort getopt/getoldopt arguments AGAIN, finally
merge usage changes from obsd; add xz support
@
text
@d62 1
a62 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.37 2011/08/17 10:47:48 tg Exp $");
d204 1
a204 1
	 * Are we acting like pax, tar or cpio (based on argv[0])
d435 1
a435 1
			 * use gzip.  Non standard option.
d457 2
a458 2
			 * On extraction check file inode change time before the
			 * modification of the file name. Non standard option.
d633 1
a633 1
		/* FALL THROUGH */
d677 1
a677 1
	 * Set default values.
d698 2
a699 1
			wrblksz *= 512;		/* XXX - check for int oflow */
d824 1
a824 1
			 * use gzip.  Non standard option.
d830 1
a830 1
			 * Nothing to do here, this is pax default
d870 3
a872 1
			/* special archive normalisation flags */
d876 3
a878 1
			/* numeric uid and gid only */
d895 1
a895 1
			 * use compress.
d925 1
a925 1
	/* Tar requires an action. */
d929 1
a929 1
	/* Traditional tar behaviour (pax uses stderr unless in list mode) */
d935 1
a935 1
	/* Traditional tar behaviour (pax wants to read file list from stdin) */
d1040 2
a1041 1
		if (chdname != NULL) {	/* initial chdir() */
d1071 1
a1071 1
				/* Set directory if needed */
d1297 1
a1297 1
				 * use gzip.  Non standard option.
d1309 1
a1309 1
				 * Use 5120 byte block size
d1383 3
d1395 1
a1395 1
				 * use compress.  Non standard option.
d1433 1
a1433 1
			/* FALL THROUGH */
d1575 2
a1576 1
		dstr = NULL;	/* parts of string going onto the OPLIST */
d1724 1
a1724 1
	    "usage: pax [-0cdjnOvz] [-E limit] [-f archive] [-G group] [-s replstr]\n"
d1726 1
a1726 1
	    "       pax -r [-0cDdijknOuvYZz] [-E limit] [-f archive] [-G group] [-M flag]\n"
d1729 1
a1729 1
	    "       pax -w [-0adHijLOPtuvXz] [-B bytes] [-b blocksize] [-f archive]\n"
d1747 1
a1747 1
	    "usage: tar {crtux}[014578AbefHhjLmNOoPpqRSsvwXZz]\n"
d1750 1
a1750 1
	    "       tar {-crtux} [-014578AeHhjLmNOoPpqRSvwXZz] [-b blocking-factor]\n"
d1766 1
a1766 1
	    "usage: cpio -o [-AaBcjLvZz] [-C bytes] [-F archive] [-H format]\n"
d1768 1
a1768 1
	    "       cpio -i [-6BbcdfjmrSstuvZz] [-C bytes] [-E file] [-F archive]\n"
@


1.37
log
@fix usage for tar(1) and sort option string
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.67 2007/02/24 09:50:55 jmc Exp $	*/
d5 2
a6 1
 * Copyright (c) 2005, 2006, 2007 Thorsten Glaser <tg@@mirbsd.org>
d62 1
a62 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.36 2011/08/17 08:10:35 tg Exp $");
d102 2
d237 2
a238 2
	while ((c=getopt(argc,argv,"ab:cdf:iklno:p:rs:tuvwx:zB:DE:G:HLM:OPT:U:XYZ0"))
	    != -1) {
d284 12
d685 1
a685 1
	    "014578ABb:cC:ef:HhI:LmM:OoPpqRrSs:tuvwXxZz")) != -1) {
d733 12
d844 8
a851 4
				incfiles_max = nincfiles + 3;
				incfiles = realloc(incfiles,
				    sizeof(*incfiles) * incfiles_max);
				if (incfiles == NULL) {
d856 2
d869 1
d872 4
d1182 2
a1183 1
	while ((c=getopt(argc,argv,"abcdfiklmoprstuvzABC:E:F:H:I:LM:O:SZ6")) != -1)
d1220 12
d1566 1
d1582 1
d1714 8
a1721 8
	    "usage: pax [-0cdnOvz] [-E limit] [-f archive] [-G group] [-s replstr]\n"
	    "\t  [-T range] [-U user] [pattern ...]\n"
	    "       pax -r [-0cDdiknOuvYZz] [-E limit] [-f archive] [-G group]\n"
	    "\t  [-o options] [-p string] [-s replstr] [-T range]\n"
	    "\t  [-U user] [pattern ...]\n"
	    "       pax -w [-0adHiLOPtuvXz] [-B bytes] [-b blocksize] [-f archive]\n"
	    "\t  [-G group] [-M flag] [-o options] [-s replstr]\n"
	    "\t  [-T range] [-U user] [-x format] [file ...]\n"
d1723 1
a1723 1
	    "\t  [-T range] [-U user] [file ...] directory\n",
d1737 6
a1742 5
	    "usage: tar {crtux}[014578AbefHhLmOoPpqRSsvwXZz]\n"
	    "\t  [blocking-factor | archive | replstr] [-C directory] [-I file]\n"
	    "\t  [file ...]\n"
	    "       tar {-crtux} [-014578AeHhLmOoPpqRSvwXZz] [-b blocking-factor] [-M flag]\n"
	    "\t  [-C directory] [-f archive] [-I file] [-s replstr] [file ...]\n",
d1755 7
a1761 5
	(void)fputs("usage: cpio -o [-AaBcLvZz] [-C bytes] [-F archive] [-H format]\n", stderr);
	(void)fputs("               [-M flag] [-O archive] <name-list [>archive]\n", stderr);
	(void)fputs("       cpio -i [-6BbcdfmrSstuvZz] [-C bytes] [-E file] [-F archive]\n", stderr);
	(void)fputs("               [-H format] [-I archive] [pattern...] [<archive]\n", stderr);
	(void)fputs("       cpio -p [-adLlmuv] destination-directory <name-list\n", stderr);
@


1.36
log
@sanitise tar option parsing a bit more (as much as that is possible at all, anyway)
@
text
@d61 1
a61 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.35 2011/08/16 21:32:47 tg Exp $");
d670 1
a670 1
	    "Ab:cef:hmopqruts:vwxzBC:HI:LM:OPRSXZ014578")) != -1) {
d1684 1
a1684 1
	    "usage: tar {crtux}[014578befHhLmOoPpqRSsvwXZz]\n"
d1687 1
a1687 1
	    "       tar {-crtux} [-014578eHhLmOoPpqRSvwXZz] [-b blocking-factor] [-M flag]\n"
@


1.35
log
@backend for Unix Archiver libraries  ar(5) and deb(5) format files
(since GNU binutils on ELF systems thinks SYSV style ar is used)
@
text
@d61 1
a61 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.34 2011/08/16 13:50:18 tg Exp $");
d753 1
a753 1
			anonarch = ANON_INODES | ANON_HARDLINKS;
d757 1
a757 1
			anonarch = ANON_INODES | ANON_HARDLINKS;
@


1.34
log
@use underscores with __attribute__s
@
text
@d53 1
d61 1
a61 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.33 2011/08/16 13:45:00 tg Exp $");
d76 1
d108 1
a108 1
 *	rd_data, wr_data, options
d112 6
a117 1
/* 0: OLD BINARY CPIO */
d120 1
a120 1
	rd_wrfile, wr_rdfile, bad_opt},
d122 1
a122 1
/* 1: OLD OCTAL CHARACTER CPIO */
d125 1
a125 1
	rd_wrfile, wr_rdfile, bad_opt},
d127 1
a127 1
/* 2: OLD OCTAL CHARACTER CPIO, UID/GID CLEARED (ANONYMISED) */
d130 1
a130 1
	rd_wrfile, wr_rdfile, bad_opt},
d132 1
a132 1
/* 3: SVR4 HEX CPIO */
d135 1
a135 1
	rd_wrfile, wr_rdfile, bad_opt},
d137 1
a137 1
/* 4: SVR4 HEX CPIO WITH CRC */
d140 1
a140 1
	rd_wrfile, wr_rdfile, bad_opt},
d142 1
a142 1
/* 5: OLD TAR */
d144 2
a145 2
	tar_rd, tar_endrd, no_op, tar_wr, tar_endwr, tar_trail,
	rd_wrfile, wr_rdfile, tar_opt},
d147 1
a147 1
/* 6: POSIX USTAR */
d150 1
a150 1
	rd_wrfile, wr_rdfile, bad_opt},
d152 1
a152 1
/* 7: SVR4 HEX CPIO WITH CRC, UID/GID/MTIME CLEARED (NORMALISED) */
d155 1
a155 1
	rd_wrfile, wr_rdfile, bad_opt},
d157 1
a157 1
/* 8: SVR4 HEX CPIO WITH CRC, UID/GID CLEARED (ANONYMISED) */
d160 1
a160 1
	rd_wrfile, wr_rdfile, bad_opt},
d162 8
a169 7
#define	F_OCPIO	0	/* format when called as cpio -6 */
#define	F_ACPIO	1	/* format when called as cpio -c */
#define	F_NCPIO	3	/* format when called as tar -R */
#define	F_CPIO	4	/* format when called as cpio or tar -S */
#define F_OTAR	5	/* format when called as tar -o */
#define F_TAR	6	/* format when called as tar */
#define DEFLT	6	/* default write format from list above */
d176 1
a176 1
int ford[] = {6, 5, 4, 3, 1, 0, -1 };
d670 1
a670 1
	    "b:cef:hmopqruts:vwxzBC:HI:LM:OPRSXZ014578")) != -1) {
d672 3
d989 3
d1646 6
@


1.33
log
@ aaaand the even longer awaited functionality to append a slash to a
directorys name upon ustar creation (like gtar)
@
text
@d60 1
a60 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.32 2011/08/16 13:27:01 tg Exp $");
d80 1
a80 1
static void pax_usage(void) __attribute__((noreturn));
d83 1
a83 1
static void tar_usage(void) __attribute__((noreturn));
d86 1
a86 1
static void cpio_usage(void) __attribute__((noreturn));
@


1.32
log
@implement the long-awaited option to skip writing the ASCII uid/gid
@
text
@d60 1
a60 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.31 2009/10/27 18:47:26 tg Exp $");
d1755 2
@


1.31
log
@new option -M lncp, see TFM for details
@
text
@d60 1
a60 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.30 2009/10/04 14:51:06 tg Exp $");
d1738 2
a1739 2
		k = ANON_UIDGID | ANON_INODES
		    | ANON_MTIME | ANON_HARDLINKS;
d1741 1
a1741 1
		k = ANON_UIDGID | ANON_INODES;
d1743 2
a1744 2
		k = ANON_UIDGID | ANON_INODES
		    | ANON_HARDLINKS;
d1753 2
@


1.30
log
@exclude tape support on Mac OSX too, not just Interix,
because it got removed in Snow Leopard
@
text
@d60 1
a60 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.29 2009/09/17 07:24:00 tg Exp $");
d1751 2
@


1.29
log
@dont call an internal function getline, even if its static, since
apparently, with its SUSv3 specification, it can be exposed without
using -D_GNU_SOURCE, leading to a confirmed build failure on Gentoo
GNU/Linux; caught by neclimdul:#FreeWRT
@
text
@a40 3
#ifndef __INTERIX
#include <sys/mtio.h>
#endif
d55 4
d60 1
a60 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.28 2008/11/08 23:03:37 tg Exp $");
@


1.28
log
@more mass conversions, including ancient eMail addresses
@
text
@d59 1
a59 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.27 2008/10/29 17:00:07 tg Exp $");
d77 1
a77 1
static char *getline(FILE *fp);
d90 4
a93 4
/* errors from getline */
#define GETLINE_FILE_CORRUPT 1
#define GETLINE_OUT_OF_MEM 2
static int getline_error;
d927 1
a927 1
					while ((str = getline(fp)) != NULL) {
d934 1
a934 1
					if (getline_error) {
d1024 1
a1024 1
				while ((str = getline(fp)) != NULL) {
d1030 1
a1030 1
				if (getline_error) {
d1255 1
a1255 1
				while ((str = getline(fp)) != NULL) {
d1259 1
a1259 1
				if (getline_error) {
d1367 1
a1367 1
			while ((str = getline(stdin)) != NULL) {
d1370 1
a1370 1
			if (getline_error) {
d1596 1
a1596 1
getline(FILE *f)
d1603 1
a1603 1
		getline_error = ferror(f) ? GETLINE_FILE_CORRUPT : 0;
d1610 1
a1610 1
		getline_error = GETLINE_OUT_OF_MEM;
@


1.27
log
@allow multiple -v options not only for tar(1) but also for cpio(1), pax(1)
@
text
@d5 1
a5 1
 * Copyright (c) 2005, 2006, 2007 Thorsten Glaser <tg@@66h.42h.de>
d59 1
a59 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.26 2008/08/07 19:40:39 tg Exp $");
@


1.26
log
@allow pathname to begin with anything, as long as it _ends_ in cpio or tar
@
text
@d59 1
a59 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.25 2007/10/23 20:07:42 tg Exp $");
d383 1
a383 1
			vflag = 1;
d1221 1
a1221 1
				vflag = 1;
@


1.25
log
@merge openbsd changes and fix tar -R, -S flag misdocumentation
@
text
@d59 1
a59 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.24 2007/02/17 04:52:41 tg Exp $");
d189 1
d194 2
a195 6
	if ((argv0 = strrchr(argv[0], '/')) != NULL)
		argv0++;
	else
		argv0 = argv[0];

	if (strcmp(NM_TAR, argv0) == 0) {
d197 2
a198 2
		return;
	} else if (strcmp(NM_CPIO, argv0) == 0) {
d200 3
a202 1
		return;
a203 5
	/*
	 * assume pax as the default
	 */
	argv0 = NM_PAX;
	pax_options(argc, argv);
@


1.24
log
@__CRAZY clean
@
text
@d1 1
a1 2
/**	$MirOS: src/bin/pax/options.c,v 1.23 2007/01/23 11:55:53 tg Exp $ */
/*	$OpenBSD: options.c,v 1.64 2006/04/09 03:35:34 jaredy Exp $	*/
d59 1
a59 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.23 2007/01/23 11:55:53 tg Exp $");
d176 5
d800 1
d948 1
d1046 1
d1646 4
a1649 4
	    "usage: pax [-0cdOnRSvz] [-E limit] [-f archive] [-G group] [-s replstr]\n"
	    "\t  [-T [from_date][,to_date][/[c][m]]] [-U user] [pattern ...]\n"
	    "       pax -r [-0cDdikOnuvzYZz] [-E limit] [-f archive] [-G group]\n"
	    "\t  [-o options] [-p string] [-s replstr] [-T [from_date][,to_date]]\n"
d1652 4
a1655 4
	    "\t  [-G group] [-M value] [-o options] [-s replstr]\n"
	    "\t  [-T [from_date][,to_date][/[c][m]]] [-U user] [-x format] [file ...]\n"
	    "       pax -r -w [-0DdHikLlnOPtuvXYZ] [-G group] [-p string] [-s replstr]\n"
	    "\t  [-T [from_date][,to_date][/[c][m]]] [-U user] [file ...] directory\n",
d1669 1
a1669 1
	    "usage: tar {crtux}[014578befHhLmOoPpqsvwXZz]\n"
d1672 1
a1672 1
	    "       tar {-crtux} [-014578eHhLmOoPpqvwXZz] [-b blocking-factor] [-M value]\n"
d1686 5
a1690 5
	(void)fputs("usage: cpio -o [-aABcLvVzZ] [-C bytes] [-H format] [-O archive]\n", stderr);
	(void)fputs("               [-M flag] [-F archive] <name-list [>archive]\n", stderr);
	(void)fputs("       cpio -i [-bBcdfmnrsStuvVzZ6] [-C bytes] [-E file] [-H format]\n", stderr);
	(void)fputs("               [-I archive] [-F archive] [pattern...] [<archive]\n", stderr);
	(void)fputs("       cpio -p [-adlLmuvV] destination-directory <name-list\n", stderr);
@


1.23
log
@fix DEFOP vs ERROR botch when merging from TNF
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/options.c,v 1.22 2007/01/23 11:29:17 tg Exp $ */
d60 1
a60 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.22 2007/01/23 11:29:17 tg Exp $");
d80 1
a80 1
static void pax_usage(void);
d83 1
a83 1
static void tar_usage(void);
d86 1
a86 1
static void cpio_usage(void);
d1409 1
a1409 1
	return(strcmp(((FSUB *)a)->name, ((FSUB *)b)->name));
@


1.22
log
@cpio -i -t should list the archive contents
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/options.c,v 1.21 2007/01/17 16:25:40 tg Exp $ */
d60 1
a60 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.21 2007/01/17 16:25:40 tg Exp $");
d871 4
a1126 1
	act = -1;
@


1.21
log
@  * The flags "crtux" are mutually exclusive for tar.
  * The flags "ipt" and "oA" are mutually exclusive for cpio.
(from NetBSD PR#35432)
  * fix some const warnings
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/options.c,v 1.20 2006/07/21 17:34:59 tg Exp $ */
d6 1
a6 1
 * Copyright (c) 2005, 2006 Thorsten Glaser <tg@@66h.42h.de>
d60 1
a60 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.20 2006/07/21 17:34:59 tg Exp $");
d1094 2
@


1.20
log
@* add -M option to pax
* sync manpages
* don't document deprecated format names in pax(1) any more
* add .de Mx for portability
* improve -M verb to show archive fmt
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/options.c,v 1.19 2006/07/16 17:58:39 tg Exp $ */
d60 1
a60 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.19 2006/07/16 17:58:39 tg Exp $");
d81 1
d84 1
d218 1
a218 1
	int i;
d633 8
d679 1
a679 1
			act = ARCHIVE;
d739 1
a739 1
			act = APPND;
d762 1
a762 1
			act = LIST;
d781 1
a781 1
			act = EXTRACT;
d1088 12
d1109 2
a1110 1
	int c, i;
d1158 1
a1158 1
				act = EXTRACT;
d1178 1
a1178 1
				act = ARCHIVE;
d1185 1
a1185 1
				act = COPY;
d1202 1
a1202 1
				act = LIST;
d1227 1
a1227 1
				act = APPND;
@


1.19
log
@glibc also requires our fgetln(3)
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/options.c,v 1.18 2006/07/16 16:14:50 tg Exp $ */
d60 1
a60 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.18 2006/07/16 16:14:50 tg Exp $");
d225 1
a225 1
	while ((c=getopt(argc,argv,"ab:cdf:iklno:p:rs:tuvwx:zB:DE:G:HLOPT:U:XYZ0"))
d478 6
d1617 1
a1617 1
	    "\t  [-G group] [-o options] [-s replstr]\n"
d1664 1
a1664 1
		paxwarn(0, "debug: -M 0x%08X", anonarch);
@


1.18
log
@* -Wall clean
* implement tar -xO mode for extracting to stdout, GNU tar compatible

for freewrt

"schn" wbx@@
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/options.c,v 1.17 2006/07/16 15:34:23 tg Exp $ */
d60 5
a64 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.17 2006/07/16 15:34:23 tg Exp $");
@


1.17
log
@missing include: err.h

from freewrt
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/options.c,v 1.16 2006/06/23 23:03:56 tg Exp $ */
d60 1
a60 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.16 2006/06/23 23:03:56 tg Exp $");
d81 1
d164 1
a164 1
/* Normalise archives? */
d167 3
d696 1
d865 3
a868 1
	case EXTRACT:
d872 1
a872 1
			char *file, *dir;
d964 1
a964 1
			char *file, *dir;
d1025 2
a1035 2
int mkpath(char *);

d1661 1
a1661 1
	int j, k;
@


1.16
log
@merge the OpenBSD import (bugfix)
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/options.c,v 1.15 2006/06/19 20:31:05 tg Exp $ */
d47 1
d60 1
a60 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.15 2006/06/19 20:31:05 tg Exp $");
@


1.15
log
@* fix -M option processing in tar(1)
* support ustar (in cpio(1) and tar(1)) with -M uidgid and -M mtime,
  as well as the -M debug and -M verb options
@
text
@d1 2
a2 2
/**	$MirOS: src/bin/pax/options.c,v 1.14 2006/06/19 19:40:55 tg Exp $ */
/*	$OpenBSD: options.c,v 1.63 2005/06/02 19:11:06 jaredy Exp $	*/
d59 1
a59 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.14 2006/06/19 19:40:55 tg Exp $");
@


1.14
log
@bring the -M option to tar(1)
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/options.c,v 1.13 2006/06/19 19:33:48 tg Exp $ */
d59 1
a59 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.13 2006/06/19 19:33:48 tg Exp $");
d638 1
a638 1
	    "b:cef:hmopqruts:vwxzBC:HI:LMOPRSXZ014578")) != -1) {
@


1.13
log
@flesh out -M processing into an extra function
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/options.c,v 1.12 2006/06/19 19:22:08 tg Exp $ */
d59 1
a59 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.12 2006/06/19 19:22:08 tg Exp $");
d638 1
a638 1
	    "b:cef:hmopqruts:vwxzBC:HI:LOPRSXZ014578")) != -1) {
d798 3
d1619 1
a1619 1
	    "       tar {-crtux} [-014578eHhLmOoPpqvwXZz] [-b blocking-factor]\n"
@


1.12
log
@move the anonarch commons into options.c and options.h
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/options.c,v 1.11 2005/12/30 14:27:20 tg Exp $ */
d59 1
a59 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.11 2005/12/30 14:27:20 tg Exp $");
d81 2
d1260 2
a1261 56
			case 'M': {
				int j, k;

				if ((optarg[0] >= '0') && (optarg[0] <= '9')) {
#ifdef __OpenBSD__
					const char *s;
					int64_t i = strtonum(optarg, 0,
					    ANON_MAXVAL, &s);
					if (s)
						errx(1, "%s M value: %s", s,
						    optarg);
#else
					char *ep;
					long long i = strtoll(optarg, &ep, 0);
					if ((ep == optarg) || (*ep != '\0') ||
					    (i < 0) || (i > ANON_MAXVAL))
						errx(1, "impossible M value:"
						    " %s", optarg);
#endif
					anonarch = i;
					break;
				}

				if (!strncmp(optarg, "no-", 3)) {
					j = 0;
					optarg += 3;
				} else
					j = 1;
				if (!strncmp(optarg, "uid", 3) ||
				    !strncmp(optarg, "gid", 3)) {
					k = ANON_UIDGID;
				} else if (!strncmp(optarg, "ino", 3)) {
					k = ANON_INODES;
				} else if (!strncmp(optarg, "mtim", 4)) {
					k = ANON_MTIME;
				} else if (!strncmp(optarg, "link", 4)) {
					k = ANON_HARDLINKS;
				} else if (!strncmp(optarg, "norm", 4)) {
					k = ANON_UIDGID | ANON_INODES
					    | ANON_MTIME | ANON_HARDLINKS;
				} else if (!strncmp(optarg, "root", 4)) {
					k = ANON_UIDGID | ANON_INODES;
				} else if (!strncmp(optarg, "dist", 4)) {
					k = ANON_UIDGID | ANON_INODES
					    | ANON_HARDLINKS;
				} else if (!strncmp(optarg, "set", 3)) {
					k = ANON_INODES | ANON_HARDLINKS;
				} else if (!strncmp(optarg, "v", 1)) {
					k = ANON_VERBOSE;
				} else if (!strncmp(optarg, "debug", 5)) {
					k = ANON_DEBUG;
				} else cpio_usage();
				if (j)
					anonarch |= k;
				else
					anonarch &= ~k;
a1262 1
				}
d1646 61
@


1.11
log
@fix a syntax error: ...) || || (...
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/options.c,v 1.10 2005/12/30 14:19:15 tg Exp $ */
d6 1
a6 1
 * Copyright (c) 2005 Thorsten Glaser <tg@@66h.42h.de>
d59 1
a59 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.10 2005/12/30 14:19:15 tg Exp $");
d1690 9
@


1.10
log
@found while fixing: limit not to 0x000F but to ANON_MAXVAL;
actually use the value found
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/options.c,v 1.9 2005/12/30 14:17:37 tg Exp $ */
d59 1
a59 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.9 2005/12/30 14:17:37 tg Exp $");
d1273 1
a1273 1
					    || (i < 0) || (i > ANON_MAXVAL))
@


1.9
log
@fix MirCpio on the poor Macintosh which doesn't have strtonum(3)

reported by Hawkeye (#holarse)
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/options.c,v 1.8 2005/12/17 07:20:23 tg Exp $ */
d59 1
a59 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.8 2005/12/17 07:20:23 tg Exp $");
d1264 2
a1265 1
					int64_t i = strtonum(optarg, 0, 0xF, &s);
d1273 1
a1273 1
					    || (i < 0) || (i > 0xF))
d1277 1
@


1.8
log
@shave off some bytes out our *.cgz files (MirPorts archives)
by applying the same -Mset option to tar(1)s -R and -S flags
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/options.c,v 1.7 2005/12/17 07:12:06 tg Exp $ */
d59 1
a59 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.7 2005/12/17 07:12:06 tg Exp $");
d1262 1
d1268 8
@


1.7
log
@Once upon a time, we had two new formats.
Then, a third one.

Now, we've got the -M option with which you can set all these
anonymisation, normalisation etc. options bitwise.
We also have two new bits:
 - verbose, which tells you what anon options are used
 - debug, which traces files as their headers are stored

That all of course documented in the manual page.
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/options.c,v 1.6 2005/11/23 23:27:10 tg Exp $ */
d59 1
a59 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.6 2005/11/23 23:27:10 tg Exp $");
d715 1
d719 1
@


1.6
log
@* cpio.1, pax.1: document new format "dist"
* cpio.c: implement new format "dist"
* cpio.c: trailer doesn't need an inode in any case
* cpio.h: sync comments between CPIO and VCPIO structs
* extern.h, options.c: add glue for new format "dist"
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/options.c,v 1.5 2005/11/16 13:58:39 tg Exp $ */
d59 1
a59 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.5 2005/11/16 13:58:39 tg Exp $");
d160 3
d1075 1
a1075 1
	while ((c=getopt(argc,argv,"abcdfiklmoprstuvzABC:E:F:H:I:LO:SZ6")) != -1)
d1256 47
d1671 1
a1671 1
	(void)fputs("               [-F archive] <name-list [>archive]\n", stderr);
@


1.5
log
@* cpio.1: Document sv4crc format for creation and extraction
* cpio.1, pax.1: Document new v4norm and v4root formats for creation only
  (to extract these, the sv4crc driver is being used)
* cpio.c: Add initialisation routines for v4norm and v4root formats
* cpio.c (vcpio_wr): Write c_ino, c_uid, c_gid and c_mtime through a
  layer of indirection, depending on the state of (v4norm) setting them
  to the stat buf value, zero (uid, gid, mtime) or the result of a table
  lookup (inode)
* extern.h: expose new v4norm_stwr, v4root_stwr (cpio.c) and
  flnk_start, chk_flnk (table.c) functions
* options.c: add entries for new formats v4norm, v4root
* tables.c: mirror lnk_start, chk_lnk functions to build up a hard link
  table on archive creation as well, anonymising _all_ inodes stored

(inodes start at 3)
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/options.c,v 1.4 2005/10/21 11:02:36 tg Exp $ */
d59 1
a59 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.4 2005/10/21 11:02:36 tg Exp $");
d110 6
a115 1
/* 2: SVR4 HEX CPIO */
d120 1
a120 1
/* 3: SVR4 HEX CPIO WITH CRC */
d125 1
a125 1
/* 4: OLD TAR */
d130 1
a130 1
/* 5: POSIX USTAR */
d135 1
a135 1
/* 6: SVR4 HEX CPIO WITH CRC, UID/GID/MTIME CLEARED (NORMALISED) */
d140 1
a140 1
/* 7: SVR4 HEX CPIO WITH CRC, UID/GID CLEARED (ANONYMISED) */
d147 5
a151 5
#define	F_NCPIO	2	/* format when called as tar -R */
#define	F_CPIO	3	/* format when called as cpio or tar -S */
#define F_OTAR	4	/* format when called as tar -o */
#define F_TAR	5	/* format when called as tar */
#define DEFLT	5	/* default write format from list above */
d158 1
a158 1
int ford[] = {5, 4, 3, 2, 1, 0, -1 };
@


1.4
log
@* merge bin and lib completely
* convert some ancient RCSID styles etc. to more modern stuff
* fix use of CDIAGFLAGS+=, CFLAGS+= and COPTS+= to the correct
  variant (include bsd.own.mk _then_ COPTS+=) so they're added
  after any user-specified flags
  (this is probably lurking in more places than I can imagine)
* fix some indenting, comments, etc.
* make stuff compile (fix warnings/errors)
* add script to review _all_ shlib_version after an openbsd import
* remove two more obsolete /usr/lib/debug/ references
* bin/ps: comment out some SMP code
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/options.c,v 1.3 2005/04/13 19:49:34 tg Exp $ */
d6 1
d59 1
a59 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.3 2005/04/13 19:49:34 tg Exp $");
d129 10
@


1.3
log
@first the compile fixes. later, link fixes will follow.
@
text
@d1 2
a2 2
/**	$MirOS: src/bin/pax/options.c,v 1.2 2005/02/28 20:04:58 tg Exp $ */
/*	$OpenBSD: options.c,v 1.61 2004/04/16 22:50:23 deraadt Exp $	*/
d58 1
a58 1
__RCSID("$MirOS: src/bin/pax/options.c,v 1.2 2005/02/28 20:04:58 tg Exp $");
d195 1
a195 1
	while ((c=getopt(argc,argv,"ab:cdf:iklno:p:rs:tuvwx:zB:DE:G:HLPT:U:XYZ0"))
d1563 12
a1574 23
	(void)fputs("usage: pax [-cdnvzO] [-E limit] [-f archive] ", stderr);
	(void)fputs("[-s replstr] ... [-U user] ...", stderr);
	(void)fputs("\n           [-G group] ... ", stderr);
	(void)fputs("[-T [from_date][,to_date]] ... ", stderr);
	(void)fputs("[pattern ...]\n", stderr);
	(void)fputs("       pax -r [-cdiknuvzDOYZ] [-E limit] ", stderr);
	(void)fputs("[-f archive] [-o options] ... \n", stderr);
	(void)fputs("           [-p string] ... [-s replstr] ... ", stderr);
	(void)fputs("[-U user] ... [-G group] ...\n	      ", stderr);
	(void)fputs("[-T [from_date][,to_date]] ... ", stderr);
	(void)fputs(" [pattern ...]\n", stderr);
	(void)fputs("       pax -w [-dituvzHLOPX] [-b blocksize] ", stderr);
	(void)fputs("[ [-a] [-f archive] ] [-x format] \n", stderr);
	(void)fputs("           [-B bytes] [-s replstr] ... ", stderr);
	(void)fputs("[-o options] ... [-U user] ...", stderr);
	(void)fputs("\n           [-G group] ... ", stderr);
	(void)fputs("[-T [from_date][,to_date][/[c][m]]] ... ", stderr);
	(void)fputs("[file ...]\n", stderr);
	(void)fputs("       pax -r -w [-diklntuvDHLOPXYZ] ", stderr);
	(void)fputs("[-p string] ... [-s replstr] ...", stderr);
	(void)fputs("\n           [-U user] ... [-G group] ... ", stderr);
	(void)fputs("[-T [from_date][,to_date][/[c][m]]] ... ", stderr);
	(void)fputs("\n           [file ...] directory\n", stderr);
d1586 6
a1591 3
	(void)fputs("usage: tar [-]{crtux}[-befhmopqsvwzHLOPRSXZ014578] [blocksize] ",
		 stderr);
	(void)fputs("[archive] [replstr] [-C directory] [-I file] [file ...]\n",
@


1.2
log
@merge
@
text
@d1 1
a1 1
/**	$MirOS$ */
d41 1
d43 1
d58 1
a58 1
__RCSID("$MirOS$");
d993 1
d996 1
@


1.1
log
@Initial revision
@
text
@d1 1
d38 1
a38 9
#ifndef lint
#if 0
static const char sccsid[] = "@@(#)options.c	8.2 (Berkeley) 4/18/94";
#else
static const char rcsid[] = "$OpenBSD: options.c,v 1.61 2004/04/16 22:50:23 deraadt Exp $";
#endif
#endif /* not lint */

#include <sys/types.h>
a41 1
#include <sys/param.h>
d55 3
d129 2
a130 1
#define	F_CPIO	3	/* format when called as cpio */
d615 1
a615 1
	    "b:cef:hmopqruts:vwxzBC:HI:LOPXZ014578")) != -1) {
d692 6
d899 19
a917 3
		frmt = &(fsub[Oflag ? F_OTAR : F_TAR]);

		if (Oflag == 2 && opt_add("write_opt=nodir") < 0)
d919 2
d999 1
a999 2
mkpath(path)
	char *path;
d1206 11
a1216 1
				tmp.name = optarg;
d1288 1
a1288 1
				ftree_add(str, NULL);
d1537 1
a1537 1
			
d1593 1
a1593 1
	(void)fputs("usage: tar [-]{crtux}[-befhmopqsvwzHLOPXZ014578] [blocksize] ",
d1609 1
a1609 1
	(void)fputs("               [-F archive] < name-list [> archive]\n", stderr);
d1611 2
a1612 2
	(void)fputs("               [-I archive] [-F archive] [pattern...] [< archive]\n", stderr);
	(void)fputs("       cpio -p [-adlLmuvV] destination-directory < name-list\n", stderr);
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.63 2005/06/02 19:11:06 jaredy Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: options.c,v 1.63 2005/06/02 19:11:06 jaredy Exp $";
d197 1
a197 1
	while ((c=getopt(argc,argv,"ab:cdf:iklno:p:rs:tuvwx:zB:DE:G:HLOPT:U:XYZ0"))
d1530 23
a1552 12
	(void)fputs(
	    "usage: pax [-0cdOnvz] [-E limit] [-f archive] [-G group] [-s replstr]\n"
	    "\t  [-T [from_date][,to_date][/[c][m]]] [-U user] [pattern ...]\n"
	    "       pax -r [-0cDdikOnuvzYZz] [-E limit] [-f archive] [-G group]\n"
	    "\t  [-o options] [-p string] [-s replstr] [-T [from_date][,to_date]]\n"
	    "\t  [-U user] [pattern ...]\n"
	    "       pax -w [-0adHiLOPtuvXz] [-B bytes] [-b blocksize] [-f archive]\n"
	    "\t  [-G group] [-o options] [-s replstr]\n"
	    "\t  [-T [from_date][,to_date][/[c][m]]] [-U user] [-x format] [file ...]\n"
	    "       pax -r -w [-0DdHikLlnOPtuvXYZ] [-G group] [-p string] [-s replstr]\n"
	    "\t  [-T [from_date][,to_date][/[c][m]]] [-U user] [file ...] directory\n",
	    stderr);
d1564 3
a1566 6
	(void)fputs(
	    "usage: tar {crtux}[014578befHhLmOoPpqsvwXZz]\n"
	    "\t  [blocking-factor | archive | replstr] [-C directory] [-I file]\n"
	    "\t  [file ...]\n"
	    "       tar {-crtux} [-014578eHhLmOoPpqvwXZz] [-b blocking-factor]\n"
	    "\t  [-C directory] [-f archive] [-I file] [-s replstr] [file ...]\n",
@


1.1.1.3
log
@One "miserable" byte in filenames is worth an import

agreed bsiegert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.64 2006/04/09 03:35:34 jaredy Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: options.c,v 1.64 2006/04/09 03:35:34 jaredy Exp $";
d1259 1
a1259 1
				ftree_add(str, 0);
@


1.1.1.4
log
@import latest OpenCPIO 
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.67 2007/02/24 09:50:55 jmc Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: options.c,v 1.67 2007/02/24 09:50:55 jmc Exp $";
a146 5
 * Do we have -C anywhere?
 */
int havechd = 0;

/*
a742 1
			havechd++;
a880 1
					havechd++;
a959 1
				havechd++;
d1531 4
a1534 4
	    "usage: pax [-0cdnOvz] [-E limit] [-f archive] [-G group] [-s replstr]\n"
	    "\t  [-T range] [-U user] [pattern ...]\n"
	    "       pax -r [-0cDdiknOuvYZz] [-E limit] [-f archive] [-G group]\n"
	    "\t  [-o options] [-p string] [-s replstr] [-T range]\n"
d1538 3
a1540 3
	    "\t  [-T range] [-U user] [-x format] [file ...]\n"
	    "       pax -rw [-0DdHikLlnOPtuvXYZ] [-G group] [-p string] [-s replstr]\n"
	    "\t  [-T range] [-U user] [file ...] directory\n",
d1571 5
a1575 5
	(void)fputs("usage: cpio -o [-AaBcLvZz] [-C bytes] [-F archive] [-H format]\n", stderr);
	(void)fputs("               [-O archive] < name-list [> archive]\n", stderr);
	(void)fputs("       cpio -i [-6BbcdfmrSstuvZz] [-C bytes] [-E file] [-F archive]\n", stderr);
	(void)fputs("               [-H format] [-I archive] [pattern...] [< archive]\n", stderr);
	(void)fputs("       cpio -p [-adLlmuv] destination-directory < name-list\n", stderr);
@


1.1.1.5
log
@import up-to-date pax from OpenBSD 5.1-current
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.74 2010/12/02 04:08:27 tedu Exp $	*/
d37 8
a90 1
#define BZIP2_CMD	"bzip2"		/* command to run as bzip2 */
d202 1
a202 1
	while ((c=getopt(argc,argv,"ab:cdf:ijklno:p:rs:tuvwx:zB:DE:G:HLOPT:U:XYZ0"))
a248 6
		case 'j':
			/*
			 * use bzip2.  Non standard option.
			 */
			gzip_program = BZIP2_CMD;
			break;
d624 1
a624 1
	    "b:cef:hjmopqruts:vwxzBC:HI:LNOPXZ014578")) != -1) {
a668 6
		case 'j':
			/*
			 * use bzip2.  Non standard option.
			 */
			gzip_program = BZIP2_CMD;
			break;
d759 4
a762 8
				size_t n = nincfiles + 3;
				struct incfile *p;

				p = realloc(incfiles,
				    sizeof(*incfiles) * n);
				if (p == NULL) {
					free(incfiles);
					incfiles = NULL;
a766 2
				incfiles = p;
				incfiles_max = n;
a776 4
		case 'N':
			/* numeric uid and gid only */
			Nflag = 1;
			break;
d1041 1
a1041 1
	while ((c=getopt(argc,argv,"abcdfijklmoprstuvzABC:E:F:H:I:LO:SZ6")) != -1)
a1077 6
			case 'j':
				/*
				 * use bzip2.  Non standard option.
				 */
				gzip_program = BZIP2_CMD;
				break;
a1398 1
		dstr = NULL;	/* parts of string going onto the OPLIST */
a1413 1
	free(dstr);
d1539 8
a1546 7
	    "usage: pax [-0cdjnOvz] [-E limit] [-f archive] [-G group] [-s replstr]\n"
	    "           [-T range] [-U user] [pattern ...]\n"
	    "       pax -r [-0cDdijknOuvYZz] [-E limit] [-f archive] [-G group] [-o options]\n"
	    "           [-p string] [-s replstr] [-T range] [-U user] [pattern ...]\n"
	    "       pax -w [-0adHijLOPtuvXz] [-B bytes] [-b blocksize] [-f archive]\n"
	    "           [-G group] [-o options] [-s replstr] [-T range] [-U user]\n"
	    "           [-x format] [file ...]\n"
d1548 1
a1548 1
	    "           [-T range] [-U user] [file ...] directory\n",
d1562 5
a1566 5
	    "usage: tar {crtux}[014578befHhjLmNOoPpqsvwXZz]\n"
	    "           [blocking-factor | archive | replstr] [-C directory] [-I file]\n"
	    "           [file ...]\n"
	    "       tar {-crtux} [-014578eHhjLmNOoPpqvwXZz] [-b blocking-factor]\n"
	    "           [-C directory] [-f archive] [-I file] [-s replstr] [file ...]\n",
d1579 5
a1583 7
	(void)fputs(
	    "usage: cpio -o [-AaBcjLvZz] [-C bytes] [-F archive] [-H format]\n"
	    "            [-O archive] < name-list [> archive]\n"
	    "       cpio -i [-6BbcdfjmrSstuvZz] [-C bytes] [-E file] [-F archive] [-H format]\n"
	    "            [-I archive] [pattern ...] [< archive]\n"
	    "       cpio -p [-adLlmuv] destination-directory < name-list\n",
	    stderr);
@


1.1.1.6
log
@Import latest OpenBSD paxtar
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.75 2012/03/04 04:05:15 fgsch Exp $	*/
d67 1
a67 1
static char *get_line(FILE *fp);
d75 1
a75 1
/* errors from get_line */
d887 1
a887 1
					while ((str = get_line(fp)) != NULL) {
d966 1
a966 1
				while ((str = get_line(fp)) != NULL) {
d1188 1
a1188 1
				while ((str = get_line(fp)) != NULL) {
d1287 1
a1287 1
			while ((str = get_line(stdin)) != NULL) {
d1518 1
a1518 1
get_line(FILE *f)
@


1.1.1.7
log
@pull newer paxtar from OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.92 2015/12/06 12:00:16 tobias Exp $	*/
d41 1
d65 1
a74 5
static int compress_id(char *_blk, int _size);
static int gzip_id(char *_blk, int _size);
static int bzip2_id(char *_blk, int _size);
static int xz_id(char *_blk, int _size);

d86 1
a86 1
 *	Format specific routine table
d89 1
a89 1
 *	name, blksz, hdsz, udev, hlk, blkagn, inhead, id, st_read,
a94 10
#ifdef NOCPIO
/* 0: OLD BINARY CPIO */
	{ },
/* 1: OLD OCTAL CHARACTER CPIO */
	{ },
/* 2: SVR4 HEX CPIO */
	{ },
/* 3: SVR4 HEX CPIO WITH CRC */
	{ },
#else
d98 1
a98 1
	bad_opt},
d103 1
a103 1
	bad_opt},
d108 1
a108 1
	bad_opt},
d113 2
a114 2
	bad_opt},
#endif
d118 1
a118 1
	tar_opt},
d123 1
a123 21
	tar_opt},

#ifdef SMALL
/* 6: compress, to detect failure to use -Z */
	{ },
/* 7: xz, to detect failure to decompress it */
	{ },
/* 8: bzip2, to detect failure to use -j */
	{ },
/* 9: gzip, to detect failure to use -z */
	{ },
#else
/* 6: compress, to detect failure to use -Z */
	{NULL, 0, 4, 0, 0, 0, 0, compress_id},
/* 7: xz, to detect failure to decompress it */
	{NULL, 0, 4, 0, 0, 0, 0, xz_id},
/* 8: bzip2, to detect failure to use -j */
	{NULL, 0, 4, 0, 0, 0, 0, bzip2_id},
/* 9: gzip, to detect failure to use -z */
	{NULL, 0, 4, 0, 0, 0, 0, gzip_id},
#endif
d137 1
a137 1
int ford[] = {5, 4, 9, 8, 7, 6, 3, 2, 1, 0, -1};
d140 1
a140 1
 * Do we have -C anywhere and what is it?
a142 1
char *chdname = NULL;
a152 1
	extern char *__progname;
d157 4
a160 1
	argv0 = __progname;
d165 1
a165 3
	}
#ifndef NOCPIO
	else if (strcmp(NM_CPIO, argv0) == 0) {
a168 1
#endif /* !NOCPIO */
d186 1
a186 1
	unsigned i;
a188 1
	const char *errstr;
d190 1
d372 3
a374 6
			for (i = 0; i < sizeof(fsub)/sizeof(FSUB); ++i)
				if (fsub[i].name != NULL &&
				    strcmp(fsub[i].name, optarg) == 0)
					break;
			if (i < sizeof(fsub)/sizeof(FSUB)) {
				frmt = &fsub[i];
d381 1
a381 3
				if (fsub[i].name != NULL)
					(void)fprintf(stderr, " %s",
					    fsub[i].name);
d424 3
a426 6
			else {
				maxflt = strtonum(optarg, 0, INT_MAX, &errstr);
				if (errstr) {
					paxwarn(1, "Error count value: %s", errstr);
					pax_usage();
				}
a684 1
			tar_nodir = 1;
d767 2
a768 2
				p = reallocarray(incfiles, n,
				    sizeof(*incfiles));
d770 2
a835 10
	if (!fstdin && ((arcname == NULL) || (*arcname == '\0'))) {
		arcname = getenv("TAPE");
		if ((arcname == NULL) || (*arcname == '\0'))
			arcname = _PATH_DEFTAPE;
		else if ((arcname[0] == '-') && (arcname[1]== '\0')) {
			arcname = NULL;
			fstdin = 1;
		}
	}

d921 3
d992 5
a1033 2

#ifndef NOCPIO
d1043 1
a1043 3
	const char *errstr;
	int c;
	unsigned i;
d1045 1
d1178 1
a1178 6
				wrblksz = strtonum(optarg, 0, INT_MAX, &errstr);
				if (errstr) {
					paxwarn(1, "Invalid block size %s: %s",
					    optarg, errstr);
					pax_usage();
				}
d1216 3
a1218 6
				for (i = 0; i < sizeof(fsub)/sizeof(FSUB); ++i)
					if (fsub[i].name != NULL &&
					    strcmp(fsub[i].name, optarg) == 0)
						break;
				if (i < sizeof(fsub)/sizeof(FSUB)) {
					frmt = &fsub[i];
a1219 1
				}
d1223 1
a1223 3
					if (fsub[i].name != NULL)
						(void)fprintf(stderr, " %s",
						    fsub[i].name);
a1299 1
#endif /* !NOCPIO */
d1322 12
d1415 1
a1415 1
		if ((opt = malloc(sizeof(OPLIST))) == NULL) {
d1443 1
a1443 1
 *	1) A positive decimal number.
d1461 7
a1467 2
	num = strtoll(val, &expr, 0);
	if ((num == LLONG_MAX) || (num <= 0) || (expr == val))
d1539 1
a1539 1

a1592 1
#ifndef NOCPIO
a1609 46
#endif /* !NOCPIO */

#ifndef SMALL
static int
compress_id(char *blk, int size)
{
	if (size >= 2 && blk[0] == '\037' && blk[1] == '\235') {
		paxwarn(0, "input compressed with %s; use the -%c option"
		    " to decompress it", "compress", 'Z');
		exit(1);
	}
	return (-1);
}

static int
gzip_id(char *blk, int size)
{
	if (size >= 2 && blk[0] == '\037' && blk[1] == '\213') {
		paxwarn(0, "input compressed with %s; use the -%c option"
		    " to decompress it", "gzip", 'z');
		exit(1);
	}
	return (-1);
}

static int
bzip2_id(char *blk, int size)
{
	if (size >= 3 && blk[0] == 'B' && blk[1] == 'Z' && blk[2] == 'h') {
		paxwarn(0, "input compressed with %s; use the -%c option"
		    " to decompress it", "bzip2", 'j');
		exit(1);
	}
	return (-1);
}

static int
xz_id(char *blk, int size)
{
	if (size >= 6 && memcmp(blk, "\xFD\x37\x7A\x58\x5A", 6) == 0) {
		paxwarn(0, "input compressed with xz");
		exit(1);
	}
	return (-1);
}
#endif /* !SMALL */
@


1.1.1.8
log
@revert the import; well just backport the CVE fixes, for now 
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.75 2012/03/04 04:05:15 fgsch Exp $	*/
a40 1
#include <sys/param.h>
a63 1
static int c_frmt(const void *, const void *);
d73 5
d89 1
a89 1
 *	Format specific routine table - MUST BE IN SORTED ORDER BY NAME
d92 1
a92 1
 * 	name, blksz, hdsz, udev, hlk, blkagn, inhead, id, st_read,
d98 10
d111 1
a111 1
	rd_wrfile, wr_rdfile, bad_opt},
d116 1
a116 1
	rd_wrfile, wr_rdfile, bad_opt},
d121 1
a121 1
	rd_wrfile, wr_rdfile, bad_opt},
d126 2
a127 2
	rd_wrfile, wr_rdfile, bad_opt},

d131 1
a131 1
	rd_wrfile, wr_rdfile, tar_opt},
d136 21
a156 1
	rd_wrfile, wr_rdfile, bad_opt},
d170 1
a170 1
int ford[] = {5, 4, 3, 2, 1, 0, -1 };
d173 1
a173 1
 * Do we have -C anywhere?
d176 1
d187 1
d192 1
a192 4
	if ((argv0 = strrchr(argv[0], '/')) != NULL)
		argv0++;
	else
		argv0 = argv[0];
d197 3
a199 1
	} else if (strcmp(NM_CPIO, argv0) == 0) {
d203 1
d221 1
a221 1
	int i;
d224 1
a225 1
	FSUB tmp;
d407 6
a412 3
			tmp.name = optarg;
			if ((frmt = (FSUB *)bsearch((void *)&tmp, (void *)fsub,
			    sizeof(fsub)/sizeof(FSUB), sizeof(FSUB), c_frmt)) != NULL) {
d419 3
a421 1
				(void)fprintf(stderr, " %s", fsub[i].name);
d464 6
a469 3
			else if ((maxflt = atoi(optarg)) < 0) {
				paxwarn(1, "Error count value must be positive");
				pax_usage();
d728 1
d811 2
a812 2
				p = realloc(incfiles,
				    sizeof(*incfiles) * n);
a813 2
					free(incfiles);
					incfiles = NULL;
d878 10
a972 3
		if (Oflag == 2 && opt_add("write_opt=nodir") < 0)
			tar_usage();

a1040 5
	if (!fstdin && ((arcname == NULL) || (*arcname == '\0'))) {
		arcname = getenv("TAPE");
		if ((arcname == NULL) || (*arcname == '\0'))
			arcname = _PATH_DEFTAPE;
	}
d1078 2
d1089 3
a1091 1
	int c, i;
a1092 1
	FSUB tmp;
d1225 6
a1230 1
				wrblksz = atoi(optarg);
d1268 6
a1273 3
				tmp.name = optarg;
				if ((frmt = (FSUB *)bsearch((void *)&tmp, (void *)fsub,
				    sizeof(fsub)/sizeof(FSUB), sizeof(FSUB), c_frmt)) != NULL)
d1275 1
d1279 3
a1281 1
					(void)fprintf(stderr, " %s", fsub[i].name);
d1358 1
a1380 12
 * c_frmt()
 *	comparison routine used by bsearch to find the format specified
 *	by the user
 */

static int
c_frmt(const void *a, const void *b)
{
	return(strcmp(((FSUB *)a)->name, ((FSUB *)b)->name));
}

/*
d1462 1
a1462 1
		if ((opt = (OPLIST *)malloc(sizeof(OPLIST))) == NULL) {
d1490 1
a1490 1
 * 	1) A positive decimal number.
d1508 2
a1509 7
#	ifdef LONG_OFF_T
	num = strtol(val, &expr, 0);
	if ((num == LONG_MAX) || (num <= 0) || (expr == val))
#	else
	num = strtoq(val, &expr, 0);
	if ((num == QUAD_MAX) || (num <= 0) || (expr == val))
#	endif
d1581 1
a1581 1
			
d1635 1
d1653 46
@


1.1.1.9
log
@bunch of cherry-picks from OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.75 +1.88 +1.89 +1.91 2012/03/04 04:05:15 fgsch Exp $	*/
d140 1
a140 1
 * Do we have -C anywhere and what is it?
a142 1
char *chdname = NULL;
a684 1
			tar_nodir = 1;
a835 10
	if (!fstdin && ((arcname == NULL) || (*arcname == '\0'))) {
		arcname = getenv("TAPE");
		if ((arcname == NULL) || (*arcname == '\0'))
			arcname = _PATH_DEFTAPE;
		else if ((arcname[0] == '-') && (arcname[1]== '\0')) {
			arcname = NULL;
			fstdin = 1;
		}
	}

d921 3
d992 5
@


1.1.1.10
log
@merge what OpenBSD did between our last cherry-pick and today minus one commit

(Use the new libc uid_from_user() and gid_from_group() instead of
  the pax-specific functions in cache.c is ignored, for now)
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.101 2016/12/26 23:43:52 krw Exp $	*/
a71 1
#ifndef NOCPIO
a73 1
#endif
@


1.1.1.11
log
@Import latest OpenBSD paxtar, unmodified, into vendor branch
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.102 2018/09/13 12:33:43 millert Exp $	*/
d38 1
d40 4
d45 2
a48 5
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

d50 1
a55 76
 * argv[0] names. Used for tar and cpio emulation
 */

#define NM_TAR  "tar"
#define NM_CPIO "cpio"
#define NM_PAX  "pax"

/*
 * Constants used to specify the legal sets of flags in pax. For each major
 * operation mode of pax, a set of illegal flags is defined. If any one of
 * those illegal flags are found set, we scream and exit
 */

/*
 * flags (one for each option).
 */
#define	AF	0x00000001
#define	BF	0x00000002
#define	CF	0x00000004
#define	DF	0x00000008
#define	FF	0x00000010
#define	IF	0x00000020
#define	KF	0x00000040
#define	LF	0x00000080
#define	NF	0x00000100
#define	OF	0x00000200
#define	PF	0x00000400
#define	RF	0x00000800
#define	SF	0x00001000
#define	TF	0x00002000
#define	UF	0x00004000
#define	VF	0x00008000
#define	WF	0x00010000
#define	XF	0x00020000
#define	CBF	0x00040000	/* nonstandard extension */
#define	CDF	0x00080000	/* nonstandard extension */
#define	CEF	0x00100000	/* nonstandard extension */
#define	CGF	0x00200000	/* nonstandard extension */
#define	CHF	0x00400000	/* nonstandard extension */
#define	CLF	0x00800000	/* nonstandard extension */
#define	CPF	0x01000000	/* nonstandard extension */
#define	CTF	0x02000000	/* nonstandard extension */
#define	CUF	0x04000000	/* nonstandard extension */
#define	CXF	0x08000000
#define	CYF	0x10000000	/* nonstandard extension */
#define	CZF	0x20000000	/* nonstandard extension */
#define	C0F	0x40000000	/* nonstandard extension */

/*
 * ascii string indexed by bit position above (alter the above and you must
 * alter this string) used to tell the user what flags caused us to complain
 */
#define FLGCH	"abcdfiklnoprstuvwxBDEGHLPTUXYZ0"

/*
 * legal pax operation bit patterns
 */

#define ISLIST(x)	(((x) & (RF|WF)) == 0)
#define	ISEXTRACT(x)	(((x) & (RF|WF)) == RF)
#define ISARCHIVE(x)	(((x) & (AF|RF|WF)) == WF)
#define ISAPPND(x)	(((x) & (AF|RF|WF)) == (AF|WF))
#define	ISCOPY(x)	(((x) & (RF|WF)) == (RF|WF))
#define	ISWRITE(x)	(((x) & (RF|WF)) == WF)

/*
 * Illegal option flag subsets based on pax operation
 */

#define	BDEXTR	(AF|BF|LF|TF|WF|XF|CBF|CHF|CLF|CPF|CXF)
#define	BDARCH	(CF|KF|LF|NF|PF|RF|CDF|CEF|CYF|CZF)
#define	BDCOPY	(AF|BF|FF|OF|XF|CBF|CEF)
#define	BDLIST (AF|BF|IF|KF|LF|OF|PF|RF|TF|UF|WF|XF|CBF|CDF|CHF|CLF|CPF|CXF|CYF|CZF)


/*
d65 1
d77 5
a81 4
static int compress_id(char *_blk, int _size);
static int gzip_id(char *_blk, int _size);
static int bzip2_id(char *_blk, int _size);
static int xz_id(char *_blk, int _size);
d88 1
a88 1
 *	Format specific routine table
d91 1
a91 1
 *	name, blksz, hdsz, udev, hlk, blkagn, inhead, id, st_read,
a96 10
#ifdef NOCPIO
/* 0: OLD BINARY CPIO */
	{ },
/* 1: OLD OCTAL CHARACTER CPIO */
	{ },
/* 2: SVR4 HEX CPIO */
	{ },
/* 3: SVR4 HEX CPIO WITH CRC */
	{ },
#else
d100 1
a100 1
	bad_opt},
d105 1
a105 1
	bad_opt},
d110 1
a110 1
	bad_opt},
d115 2
a116 2
	bad_opt},
#endif
d120 1
a120 1
	tar_opt},
d123 3
a125 23
	{"ustar", 10240, BLKMULT, 0, 1, BLKMULT, 0, ustar_id, no_op,
	ustar_rd, tar_endrd, no_op, ustar_wr, tar_endwr, tar_trail,
	tar_opt},

#ifdef SMALL
/* 6: compress, to detect failure to use -Z */
	{ },
/* 7: xz, to detect failure to decompress it */
	{ },
/* 8: bzip2, to detect failure to use -j */
	{ },
/* 9: gzip, to detect failure to use -z */
	{ },
#else
/* 6: compress, to detect failure to use -Z */
	{NULL, 0, 4, 0, 0, 0, 0, compress_id},
/* 7: xz, to detect failure to decompress it */
	{NULL, 0, 4, 0, 0, 0, 0, xz_id},
/* 8: bzip2, to detect failure to use -j */
	{NULL, 0, 4, 0, 0, 0, 0, bzip2_id},
/* 9: gzip, to detect failure to use -z */
	{NULL, 0, 4, 0, 0, 0, 0, gzip_id},
#endif
d139 1
a139 1
int ford[] = {5, 4, 9, 8, 7, 6, 3, 2, 1, 0, -1};
a155 1
	extern char *__progname;
d160 4
a163 1
	argv0 = __progname;
a165 1
		op_mode = OP_TAR;
d168 1
a168 4
	}
#ifndef NOCPIO
	else if (strcmp(NM_CPIO, argv0) == 0) {
		op_mode = OP_CPIO;
a171 1
#endif /* !NOCPIO */
a175 1
	op_mode = OP_PAX;
d189 1
a189 1
	unsigned i;
a191 1
	const char *errstr;
d193 1
d375 3
a377 6
			for (i = 0; i < sizeof(fsub)/sizeof(FSUB); ++i)
				if (fsub[i].name != NULL &&
				    strcmp(fsub[i].name, optarg) == 0)
					break;
			if (i < sizeof(fsub)/sizeof(FSUB)) {
				frmt = &fsub[i];
d384 1
a384 3
				if (fsub[i].name != NULL)
					(void)fprintf(stderr, " %s",
					    fsub[i].name);
d422 1
a422 1
			 * indicate a limit
d425 4
a428 3
			maxflt = strtonum(optarg, 0, INT_MAX, &errstr);
			if (errstr) {
				paxwarn(1, "Error count value: %s", errstr);
d607 1
d654 9
d771 2
a772 2
				p = reallocarray(incfiles, n,
				    sizeof(*incfiles));
d774 2
d840 1
a840 1
	if ((arcname == NULL) || (*arcname == '\0')) {
d844 4
a848 2
	if ((arcname[0] == '-') && (arcname[1]== '\0'))
		arcname = NULL;
d850 4
a853 5
	/*
	 * Traditional tar behaviour: list-like output goes to stdout unless
	 * writing the archive there.  (pax uses stderr unless in list mode)
	 */
        if (act == LIST || act == EXTRACT || arcname != NULL)
d898 1
a898 2
						syswarn(1, errno,
						    "Unable to open %s", file);
d906 4
a909 5
					if (ferror(fp)) {
						syswarn(1, errno,
						    "Unable to read from %s",
						    strcmp(file, "-") ? file :
						    "stdin");
a911 2
					if (strcmp(file, "-") != 0)
						fclose(fp);
d974 1
a974 2
					syswarn(1, errno, "Unable to open %s",
					    file);
d981 5
a985 4
				if (ferror(fp)) {
					syswarn(1, errno,
					    "Unable to read from %s",
					    strcmp(file, "-") ? file : "stdin");
a987 2
				if (strcmp(file, "-") != 0)
					fclose(fp);
a1039 2

#ifndef NOCPIO
d1049 1
a1049 3
	const char *errstr;
	int c, list_only = 0;
	unsigned i;
d1051 1
d1147 2
a1148 1
				list_only = 1;
d1184 1
a1184 6
				wrblksz = strtonum(optarg, 0, INT_MAX, &errstr);
				if (errstr) {
					paxwarn(1, "Invalid block size %s: %s",
					    optarg, errstr);
					pax_usage();
				}
d1191 1
a1191 2
					syswarn(1, errno, "Unable to open %s",
					    optarg);
d1197 3
a1199 3
				if (ferror(fp)) {
					syswarn(1, errno,
					    "Unable to read from %s", optarg);
a1201 1
				fclose(fp);
d1222 3
a1224 6
				for (i = 0; i < sizeof(fsub)/sizeof(FSUB); ++i)
					if (fsub[i].name != NULL &&
					    strcmp(fsub[i].name, optarg) == 0)
						break;
				if (i < sizeof(fsub)/sizeof(FSUB)) {
					frmt = &fsub[i];
a1225 1
				}
d1229 1
a1229 3
					if (fsub[i].name != NULL)
						(void)fprintf(stderr, " %s",
						    fsub[i].name);
d1268 1
a1269 9
			if (list_only) {
				act = LIST;

				/*
				 * cpio is like pax: list to stderr
				 * unless in list mode
				 */
				listf = stdout;
			}
d1296 2
a1297 3
			if (ferror(stdin)) {
				syswarn(1, errno, "Unable to read from %s",
				    "stdin");
a1305 1
#endif /* !NOCPIO */
d1320 1
a1320 1
		flg >>= nxt;
d1328 12
d1421 1
a1421 1
		if ((opt = malloc(sizeof(OPLIST))) == NULL) {
d1449 1
a1449 1
 *	1) A positive decimal number.
d1467 7
a1473 2
	num = strtoll(val, &expr, 0);
	if ((num == LLONG_MAX) || (num <= 0) || (expr == val))
d1526 18
a1543 14
	char *str = NULL;
	size_t size = 0;
	ssize_t len;

	do {
		len = getline(&str, &size, f);
		if (len == -1) {
			free(str);
			return NULL;
		}
		if (str[len - 1] == '\n')
			str[len - 1] = '\0';
	} while (str[0] == '\0');
	return str;
d1545 1
a1545 1

a1598 1
#ifndef NOCPIO
a1615 46
#endif /* !NOCPIO */

#ifndef SMALL
static int
compress_id(char *blk, int size)
{
	if (size >= 2 && blk[0] == '\037' && blk[1] == '\235') {
		paxwarn(0, "input compressed with %s; use the -%c option"
		    " to decompress it", "compress", 'Z');
		exit(1);
	}
	return (-1);
}

static int
gzip_id(char *blk, int size)
{
	if (size >= 2 && blk[0] == '\037' && blk[1] == '\213') {
		paxwarn(0, "input compressed with %s; use the -%c option"
		    " to decompress it", "gzip", 'z');
		exit(1);
	}
	return (-1);
}

static int
bzip2_id(char *blk, int size)
{
	if (size >= 3 && blk[0] == 'B' && blk[1] == 'Z' && blk[2] == 'h') {
		paxwarn(0, "input compressed with %s; use the -%c option"
		    " to decompress it", "bzip2", 'j');
		exit(1);
	}
	return (-1);
}

static int
xz_id(char *blk, int size)
{
	if (size >= 6 && memcmp(blk, "\xFD\x37\x7A\x58\x5A", 6) == 0) {
		paxwarn(0, "input compressed with xz");
		exit(1);
	}
	return (-1);
}
#endif /* !SMALL */
@


1.1.1.11.2.1
log
@Wrangle the OpenBSD branch into shape as starting point:

 Revert Use the new libc uid_from_user() and gid_from_group()
  instead of the pax-specific functions in cache.c (revisit later)
 fix MAX_TIME_T (plain wrong), mirtoconf later
 drop all NOCPIO
 Revert Replace name_{uid,gid}() with the libc routines
  user_from_uid() and group_from_gid()
@
text
@d144 1
d147 1
d168 10
d197 1
d204 2
a205 2
	{"ustar", 10240, BLKMULT, 0, 1, BLKMULT, 0, ustar_id, ustar_strd,
	ustar_rd, tar_endrd, ustar_stwr, ustar_wr, tar_endwr, tar_trail,
d268 3
a270 1
	} else if (strcmp(NM_CPIO, argv0) == 0) {
d275 1
d1143 1
d1432 1
d1705 1
d1723 1
@


1.1.1.11.2.2
log
@normalise whitespace at EOL, EOF, adjacent newlines
@
text
@d127 1
d689 1
@


1.1.1.11.2.3
log
@extremely rudimentary conversion to mirtoconf, doesnt even build yet
@
text
@a40 1
#if HAVE_PATHS_H
a41 1
#endif
a44 3
#if HAVE_STRINGS_H
#include <strings.h>
#endif
a46 1
#define EXTERN
@


1.1.1.11.2.4
log
@do the cs
@
text
@d592 1
a592 1
			 * do not pass over mount points in the filesystem
d889 1
a889 1
			 * do not pass over mount points in the filesystem
@


1.1.1.11.2.5
log
@this would be most of the os (some more strtonum for later)
@
text
@a4 2
 * Copyright (c) 2005, 2006, 2007, 2009, 2011, 2012, 2014, 2016
 *	mirabilos <m@@mirbsd.org>
a37 3
#if HAVE_SYS_MTIO_H
#include <sys/mtio.h>
#endif
a57 4
#ifndef _PATH_DEFTAPE
#define _PATH_DEFTAPE "/dev/rmt0"
#endif

d131 1
a131 16
#define	BDLIST	(AF|BF|IF|KF|LF|OF|PF|RF|TF|UF|WF|XF|CBF|CDF|CHF|CLF|CPF|CXF|CYF|CZF)

/*
 * Archive manipulation code
 */

#define	ANON_INODES	0x0001
#define	ANON_HARDLINKS	0x0002
#define	ANON_MTIME	0x0004
#define	ANON_UIDGID	0x0008
#define	ANON_VERBOSE	0x0010
#define	ANON_DEBUG	0x0020
#define	ANON_LNCP	0x0040
#define	ANON_NUMID	0x0080
#define	ANON_DIRSLASH	0x0100
#define	ANON_MAXVAL	0x01FF
a140 1
#ifndef SMALL
a141 4
static int no_op_i(int);
#endif
static int mkpath(char *);
static void process_M(const char *, void (*)(void));
a142 1
static int c_frmt(const void *, const void *);
d144 1
d146 1
a146 2
static void pax_usage(void) MKSH_A_NORETURN;
static void tar_set_action(int);
d148 1
a148 2
static void tar_usage(void) MKSH_A_NORETURN;
static void cpio_set_action(int);
d150 1
a150 1
static void cpio_usage(void) MKSH_A_NORETURN;
d157 3
a159 42
/* command to run as gzip */
static const char GZIP_CMD[] = "gzip";
#ifndef SMALL
/* command to run as compress */
static const char COMPRESS_CMD[] = "compress";
/* command to run as bzip2 */
static const char BZIP2_CMD[] = "bzip2";
/* command to run as lzma and xz */
static const char XZ_CMD[] = "xz";
/* command used for creating lzma archives */
static const char LZMA_WRCMD[] = "lzma";
/* command to run as lzop */
static const char LZOP_CMD[] = "lzop";
#endif
/* used as flag value */
#define COMPRESS_GUESS_CMD ((const void *)&compress_program)

/* format table, see FSUB fsub[] below */

enum fsub_order {
#ifndef SMALL
	FSUB_AR,
	FSUB_BCPIO,
#endif
	FSUB_CPIO,
	FSUB_DIST,
	FSUB_SV4CPIO,
	FSUB_SV4CRC,
#ifndef SMALL
	FSUB_TAR,
#endif
	FSUB_USTAR,
	FSUB_V4NORM,
	FSUB_V4ROOT,
#ifndef SMALL
	FSUBFAIL_Z,
	FSUBFAIL_XZ
	FSUBFAIL_BZ2
	FSUBFAIL_GZ
#endif
	FSUB_MAX
};
d162 1
a162 2
 *	Format specific routine table, MUST be in sorted order
 *	and MUST match enum fsub_order above
d167 1
a167 1
 *	rd_data, wr_data, options, is_uar
d171 1
a171 7
#ifndef SMALL
/* FSUB_AR: UNIX ARCHIVER */
	{"ar", 512, sizeof(HD_AR), 0, 0, 0, 0, uar_id, no_op,
	uar_rd, uar_endrd, uar_stwr, uar_wr, no_op, uar_trail,
	rd_wrfile, uar_wr_data, bad_opt, 1},

/* FSUB_BCPIO: OLD BINARY CPIO */
d174 1
a174 2
	rd_wrfile, wr_rdfile, bad_opt, 0},
#endif
d176 1
a176 1
/* FSUB_CPIO: OLD OCTAL CHARACTER CPIO */
d179 1
a179 1
	rd_wrfile, wr_rdfile, bad_opt, 0},
d181 1
a181 6
/* FSUB_DIST: OLD OCTAL CHARACTER CPIO, UID/GID CLEARED (ANONYMISED) */
	{"dist", 512, sizeof(HD_CPIO), 1, 0, 0, 1, cpio_id, cpio_strd,
	cpio_rd, cpio_endrd, dist_stwr, cpio_wr, cpio_endwr, cpio_trail,
	rd_wrfile, wr_rdfile, bad_opt, 0},

/* FSUB_SV4CPIO: SVR4 HEX CPIO */
d184 1
a184 1
	rd_wrfile, wr_rdfile, bad_opt, 0},
d186 1
a186 1
/* FSUB_SV4CRC: SVR4 HEX CPIO WITH CRC */
d189 2
a190 4
	rd_wrfile, wr_rdfile, bad_opt, 0},

#ifndef SMALL
/* FSUB_TAR: OLD TAR */
d192 2
a193 3
	tar_rd, tar_endrd, no_op_i, tar_wr, tar_endwr, tar_trail,
	rd_wrfile, wr_rdfile, tar_opt, 0},
#endif
d195 1
a195 1
/* FSUB_USTAR: POSIX USTAR */
d198 1
a198 1
	rd_wrfile, wr_rdfile, tar_opt, 0},
d200 18
a217 26
/* FSUB_V4NORM: SVR4 HEX CPIO WITH CRC, UID/GID/MTIME CLEARED (NORMALISED) */
	{"v4norm", 512, sizeof(HD_VCPIO), 1, 0, 0, 1, crc_id, crc_strd,
	vcpio_rd, vcpio_endrd, v4norm_stwr, vcpio_wr, cpio_endwr, cpio_trail,
	rd_wrfile, wr_rdfile, bad_opt, 0},

/* FSUB_V4ROOT: SVR4 HEX CPIO WITH CRC, UID/GID CLEARED (ANONYMISED) */
	{"v4root", 512, sizeof(HD_VCPIO), 1, 0, 0, 1, crc_id, crc_strd,
	vcpio_rd, vcpio_endrd, v4root_stwr, vcpio_wr, cpio_endwr, cpio_trail,
	rd_wrfile, wr_rdfile, bad_opt, 0},

/* FSUBFAIL_Z: compress, to detect failure to use -Z */
	{NULL, 0, 4, 0, 0, 0, 0, compress_id, NULL,
	NULL, NULL, NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, 0},
/* FSUBFAIL_XZ: xz, to detect failure to decompress it */
	{NULL, 0, 6, 0, 0, 0, 0, xz_id, NULL,
	NULL, NULL, NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, 0},
/* FSUBFAIL_BZ2: bzip2, to detect failure to use -j */
	{NULL, 0, 4, 0, 0, 0, 0, bzip2_id, NULL,
	NULL, NULL, NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, 0},
/* FSUBFAIL_GZ: gzip, to detect failure to use -z */
	{NULL, 0, 4, 0, 0, 0, 0, gzip_id, NULL,
	NULL, NULL, NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, 0},
d220 6
d232 1
a232 23
const int ford[] = {
	FSUB_USTAR,
#ifndef SMALL
	FSUB_TAR,
	FSUBFAIL_GZ,
	FSUBFAIL_BZ2,
	FSUBFAIL_XZ,
	FSUBFAIL_Z,
#endif
	FSUB_SV4CRC,
	FSUB_SV4CPIO,
	FSUB_CPIO,
#ifndef SMALL
	FSUB_BCPIO,
#endif
	FSUB_MAX
};

/* normalise archives */
int anonarch = 0;

/* extract to standard output */
int to_stdout = 0;
d249 1
a249 1
	size_t n;
d254 1
a254 1
	n = strlen(argv[0]);
d256 1
a256 2
	if (n >= 3 && !strcmp(argv[0] + (n - 3), NM_TAR)) {
		argv0 = NM_TAR;
d259 2
a260 2
	} else if (n >= 4 && !strcmp(argv[0] + (n - 4), NM_CPIO)) {
		argv0 = NM_CPIO;
d263 1
a263 5
	} else {
		/* assume pax as the default */
		argv0 = NM_PAX;
		op_mode = OP_PAX;
		pax_options(argc, argv);
d265 6
a287 1
	FSUB tmp;
d292 2
a293 2
	while ((c = getopt(argc, argv,
	    "0aB:b:cDdE:f:G:HiJjkLlM:nOo:Pp:rs:T:tU:uvwXx:YZz")) != -1) {
a338 7
#ifndef SMALL
		case 'J':
			/*
			 * use xz (non-standard option)
			 */
			compress_program = XZ_CMD;
			break;
d341 1
a341 1
			 * use bzip2 (non-standard option)
d343 1
a343 1
			compress_program = BZIP2_CMD;
a344 1
#endif
d456 1
a456 1
			++vflag;
d469 6
a474 3
			tmp.name = optarg;
			if ((frmt = (FSUB *)bsearch((void *)&tmp, (void *)fsub,
			    sizeof(fsub)/sizeof(FSUB), sizeof(FSUB), c_frmt)) != NULL) {
d489 1
a489 1
			 * use gzip (non-standard option)
d491 1
a491 1
			compress_program = GZIP_CMD;
a554 6
		case 'M':
			/*
			 * MirOS extension: archive normaliser
			 */
			process_M(optarg, pax_usage);
			break;
d661 1
a661 1
		frmt = &(fsub[FSUB_USTAR]);
d680 1
a680 1
		/* FALLTHROUGH */
a700 8
tar_set_action(int op)
{
	if (act != ERROR && act != op)
		tar_usage();
	act = op;
}

static void
d704 1
a704 1
	int Oflag = FSUB_USTAR;
d722 1
a722 1
	    "014578AaBb:C:cef:HhI:JjLM:mNOoPpqRrSs:tuvwXxZz")) != -1) {
a723 12
#ifndef SMALL
		case 'A':
			Oflag = FSUB_AR;
			break;
#endif
		case 'a':
			/*
			 * use compression dependent on arcname
			 * (non-standard option, gtar extension)
			 */
			compress_program = COMPRESS_GUESS_CMD;
			break;
d732 1
a732 2
			/* XXX - check for integer overflow */
			wrblksz *= 512;
d738 1
a738 1
			tar_set_action(ARCHIVE);
a757 7
#ifndef SMALL
		case 'J':
			/*
			 * use xz (non-standard option)
			 */
			compress_program = XZ_CMD;
			break;
d760 1
a760 1
			 * use bzip2 (non-standard option)
d762 1
a762 1
			compress_program = BZIP2_CMD;
a763 1
#endif
d771 1
a771 6
#ifndef SMALL
			Oflag = FSUB_TAR;
#else
			Oflag = FSUB_MAX;
#endif
			to_stdout = 2;
a772 1
#ifndef SMALL
d774 1
a774 1
			Oflag = FSUB_TAR;
a776 1
#endif
d795 1
a795 9
			tar_set_action(APPND);
			break;
		case 'R':
			Oflag = FSUB_SV4CPIO;
			anonarch |= ANON_INODES | ANON_HARDLINKS;
			break;
		case 'S':
			Oflag = FSUB_SV4CRC;
			anonarch |= ANON_INODES | ANON_HARDLINKS;
d810 1
a810 1
			tar_set_action(LIST);
d829 1
a829 1
			tar_set_action(EXTRACT);
d834 1
a834 1
			 * use gzip (non-standard option)
d836 1
a836 1
			compress_program = GZIP_CMD;
a876 6
		case 'M':
			/*
			 * MirOS extension: archive normaliser
			 */
			process_M(optarg, tar_usage);
			break;
d879 1
a879 1
			anonarch |= ANON_NUMID;
a892 1
#ifndef SMALL
d895 1
a895 1
			 * use compress
d897 1
a897 1
			compress_program = COMPRESS_CMD;
a898 1
#endif
a924 4
	/* tar requires an action. */
	if (act == ERROR)
		tar_usage();

d930 1
a930 1
	if ((arcname[0] == '-') && (arcname[1] == '\0'))
d948 1
a949 4
		if (to_stdout == 2)
			to_stdout = 1;
		/* FALLTHROUGH */
	case LIST:
d953 1
a953 1
			char *file, *dir = NULL;
d976 1
a976 1
					int fd;
d980 2
a981 2
						fd = STDIN_FILENO;
					else if ((fd = open(file, O_RDONLY)) == -1) {
d986 1
a986 1
					while ((str = fdgetline(fd)) != NULL) {
d991 2
a992 4
					if (fd != STDIN_FILENO)
						close(fd);
					if (fdgetline_err) {
						paxwarn(1,
d998 2
d1021 1
a1021 3
		if (Oflag == FSUB_MAX)
			tar_usage();
		frmt = &(fsub[Oflag]);
d1023 1
a1023 2
		if (chdname != NULL) {
			/* initial chdir() */
d1029 1
a1029 1
			char *file, *dir = NULL;
d1050 1
a1050 1
				int fd;
d1060 2
a1061 2
					fd = STDIN_FILENO;
				else if ((fd = open(file, O_RDONLY)) == -1) {
d1066 1
a1066 1
				while ((str = fdgetline(fd)) != NULL) {
d1070 2
a1071 4
				if (fd != STDIN_FILENO)
					close(fd);
				if (fdgetline_err) {
					paxwarn(1,
d1076 2
a1092 2
	if (to_stdout != 1)
		to_stdout = 0;
d1095 5
a1099 2
static int
mkpath(char *path)
a1137 13
cpio_set_action(int op)
{
	if ((act == APPND && op == ARCHIVE) || (act == ARCHIVE && op == APPND))
		act = APPND;
	else if ((act == LIST && op == EXTRACT) || (act == EXTRACT && op == LIST))
		act = LIST;
	else if (act != ERROR && act != op)
		cpio_usage();
	else
		act = op;
}

static void
d1144 1
a1144 3
	int fd;
	const char *optstr;
	FSUB tmp;
d1152 1
d1154 1
a1154 3
	optstr = "iop";
	opterr = 0;
	while ((c = getopt(argc, argv, optstr)) != -1) {
d1156 179
a1334 147
		case 'a':
			/*
			 * preserve access time on files read
			 */
			tflag = 1;
			break;
		case 'b':
			/*
			 * swap bytes and half-words when reading data
			 */
			break;
		case 'c':
			/*
			 * ASCII cpio header
			 */
			frmt = &(fsub[FSUB_CPIO]);
			break;
		case 'd':
			/*
			 * create directories as needed
			 */
			nodirs = 0;
			break;
		case 'f':
			/*
			 * invert meaning of pattern list
			 */
			cflag = 1;
			break;
		case 'i':
			/*
			 * restore an archive
			 */
			cpio_set_action(EXTRACT);
			break;
#ifndef SMALL
		case 'J':
			/*
			 * use xz (non-standard option)
			 */
			compress_program = XZ_CMD;
			break;
		case 'j':
			/*
			 * use bzip2 (non-standard option)
			 */
			compress_program = BZIP2_CMD;
			break;
#endif
		case 'k':
			break;
		case 'l':
			/*
			 * use links instead of copies when possible
			 */
			lflag = 1;
			break;
		case 'm':
			/*
			 * preserve modification time
			 */
			pmtime = 1;
			break;
		case 'o':
			/*
			 * create an archive
			 */
			cpio_set_action(ARCHIVE);
			frmt = &(fsub[FSUB_SV4CRC]);
			break;
		case 'p':
			/*
			 * copy-pass mode
			 */
			cpio_set_action(COPY);
			break;
		case 'r':
			/*
			 * interactively rename files
			 */
			iflag = 1;
			break;
		case 's':
			/*
			 * swap bytes after reading data
			 */
			break;
		case 't':
			/*
			 * list contents of archive
			 */
			list_only = 1;
			break;
		case 'u':
			/*
			 * replace newer files
			 */
			kflag = 0;
			break;
		case 'V':
			/*
			 * print a dot for each file processed
			 */
			Vflag++;
			break;
		case 'v':
			/*
			 * verbose operation mode
			 */
			++vflag;
			break;
		case 'z':
			/*
			 * use gzip (non-standard option)
			 */
			compress_program = GZIP_CMD;
			break;
		case 'A':
			/*
			 * append mode
			 */
			cpio_set_action(APPND);
			break;
		case 'B':
			/*
			 * Use 5120 byte block size
			 */
			wrblksz = 5120;
			break;
		case 'C':
			/*
			 * set block size in bytes
			 */
			wrblksz = strtonum(optarg, 0, INT_MAX, &errstr);
			if (errstr) {
				paxwarn(1, "Invalid block size %s: %s",
				    optarg, errstr);
				pax_usage();
			}
			break;
		case 'E':
			/*
			 * file with patterns to extract or list
			 */
			if ((fd = open(optarg, O_RDONLY)) == -1) {
				syswarn(1, errno, "Unable to open %s",
				    optarg);
d1336 19
a1354 18
			}
			while ((str = fdgetline(fd)) != NULL) {
				pat_add(str, NULL);
			}
			close(fd);
			if (fdgetline_err) {
				paxwarn(1,
				    "Unable to read from %s", optarg);
				cpio_usage();
			}
			break;
		case 'F':
		case 'I':
		case 'O':
			/*
			 * filename where the archive is stored
			 */
			if ((optarg[0] == '-') && (optarg[1]== '\0')) {
d1356 1
a1356 1
				 * treat a - as stdin
d1358 1
a1358 1
				arcname = NULL;
d1360 3
a1362 20
			}
			arcname = optarg;
			break;
		case 'H':
			/*
			 * specify an archive format on write
			 */
			if (!strcmp(optarg, "bin")) {
				tmp.name = "bcpio";
			} else if (!strcmp(optarg, "crc")) {
				tmp.name = "sv4crc";
			} else if (!strcmp(optarg, "newc")) {
				tmp.name = "sv4cpio";
			} else if (!strcmp(optarg, "odc")) {
				tmp.name = "cpio";
			} else {
				tmp.name = optarg;
			}
			if ((frmt = (FSUB *)bsearch((void *)&tmp, (void *)fsub,
			    sizeof(fsub)/sizeof(FSUB), sizeof(FSUB), c_frmt)) != NULL)
a1363 56
			paxwarn(1, "Unknown -H format: %s", optarg);
			(void)fputs("cpio: Known -H formats are:", stderr);
			for (i = 0; i < (sizeof(fsub)/sizeof(FSUB)); ++i)
				if (fsub[i].name != NULL)
					(void)fprintf(stderr, " %s",
					    fsub[i].name);
			(void)fputs("\n\n", stderr);
			cpio_usage();
			break;
		case 'L':
			/*
			 * follow symbolic links
			 */
			Lflag = 1;
			break;
		case 'M':
			/*
			 * MirOS extension: archive normaliser
			 */
			process_M(optarg, cpio_usage);
			break;
		case 'S':
			/*
			 * swap halfwords after reading data
			 */
			break;
#ifndef SMALL
		case 'Z':
			/*
			 * use compress (non-standard option)
			 */
			compress_program = COMPRESS_CMD;
			break;
#endif
		case '0':
			/*
			 * Use \0 as pathname terminator.
			 * (For use with the -print0 option of find(1).)
			 */
			zeroflag = 1;
			break;
#ifndef SMALL
		case '6':
			/*
			 * process Version 6 cpio format
			 */
			frmt = &(fsub[FSUB_BCPIO]);
			break;
#endif
		case '?':
		default:
			if (opterr == 0) {
				paxwarn(1, "need -i or -o or -p option first");
			}
			cpio_usage();
			break;
a1364 5
		if (opterr == 0) {
			optstr = "06AaBbC:cdE:F:fH:I:iJjkLlM:mO:oprSstuVvZz";
			opterr = 1;
		}
	}
d1372 3
a1374 3
	case EXTRACT:
		if (list_only) {
			act = LIST;
d1376 25
d1402 1
a1402 2
			 * cpio is like pax: list to stderr
			 * unless in list mode
d1404 7
a1410 4
			listf = stdout;
		}
		while (*argv != NULL)
			if (pat_add(*argv++, NULL) < 0)
d1412 3
a1414 4
		break;
	case COPY:
		if (*argv == NULL) {
			paxwarn(0, "Destination directory was not supplied");
d1416 1
a1416 27
		}
		dirptr = *argv;
		if (mkpath(dirptr) < 0)
			cpio_usage();
		--argc;
		++argv;
		/* FALLTHROUGH */
	case ARCHIVE:
	case APPND:
		if (*argv != NULL)
			cpio_usage();
		/*
		 * no read errors allowed on updates/append operation!
		 */
		maxflt = 0;
		while ((str = fdgetline(STDIN_FILENO)) != NULL) {
			ftree_add(str, 0);
		}
		if (fdgetline_err) {
			paxwarn(1, "Unable to read from %s",
			    "stdin");
			cpio_usage();
		}
		break;
	default:
		cpio_usage();
		break;
a1440 12
 * c_frmt()
 *	comparison routine used by bsearch to find the format specified
 *	by the user
 */

static int
c_frmt(const void *a, const void *b)
{
	return(strcmp(((const FSUB *)a)->name, ((const FSUB *)b)->name));
}

/*
d1527 1
a1527 2
		/* parts of string going onto the OPLIST */
		dstr = NULL;
a1561 8
#if HAVE_OFFT_LLONG
#define OT_MAX	LLONG_MAX
#define strtoot	strtoll
#else
#define OT_MAX	LONG_MAX
#define strtoot	strtol
#endif

d1568 3
a1570 3
	num = strtoot(val, &expr, 0);
	if ((num == OT_MAX) || (num <= 0) || (expr == val))
		return (0);
d1577 1
a1577 1
			return (0);
d1584 1
a1584 1
			return (0);
d1591 1
a1591 1
			return (0);
d1598 1
a1598 1
			return (0);
d1604 10
a1613 7
	case '\0':
		break;
	case '*':
	case 'x':
		t = num;
		num *= str_offt(expr + 1);
		if (t > num)
a1614 3
		break;
	default:
		return(0);
d1616 20
a1635 1
	return (num);
a1637 1
#ifndef SMALL
d1648 1
a1648 1
	return (0);
a1650 7
static int
no_op_i(int is_app MKSH_A_UNUSED)
{
	return (0);
}
#endif

d1660 1
a1660 1
	    "usage: pax [-0cdJjnOvz] [-E limit] [-f archive] [-G group] [-s replstr]\n"
d1662 5
a1666 6
	    "       pax -r [-0cDdiJjknOuvYZz] [-E limit] [-f archive] [-G group] [-M flag]\n"
	    "           [-o options] [-p string] [-s replstr] [-T range] [-U user]\n"
	    "           [pattern ...]\n"
	    "       pax -w [-0adHiJjLOPtuvXz] [-B bytes] [-b blocksize] [-f archive]\n"
	    "           [-G group] [-M flag] [-o options] [-s replstr] [-T range]\n"
	    "           [-U user] [-x format] [file ...]\n"
d1682 1
a1682 1
	    "usage: tar {crtux}[014578AabefHhJjLmNOoPpqRSsvwXZz]\n"
d1685 2
a1686 3
	    "       tar {-crtux} [-014578AaeHhJjLmNOoPpqRSvwXZz] [-b blocking-factor]\n"
	    "           [-C directory] [-f archive] [-I file] [-M flag] [-s replstr]\n"
	    "           [file ...]\n",
d1700 5
a1704 5
	    "usage: cpio -o [-0AaBcJjLVvZz] [-C bytes] [-F archive] [-H format]\n"
	    "               [-M flag] [-O archive] <name-list [>archive]\n"
	    "       cpio -i [-06BbcdfJjmrSstuVvZz] [-C bytes] [-E file] [-F archive]\n"
	    "               [-H format] [-I archive] [-M flag] [pattern ...] [<archive]\n"
	    "       cpio -p [-0adLlmuVv] destination-directory <name-list\n",
a1708 146
void
anonarch_init(void)
{
	if (anonarch & ANON_VERBOSE) {
		anonarch &= ~ANON_VERBOSE;
		paxwarn(0, "debug: -M 0x%08X -x %s", anonarch, frmt->name);
	}
}

static void
process_M(const char *arg, void (*call_usage)(void))
{
	int j, k = 0;

	if ((arg[0] >= '0') && (arg[0] <= '9')) {
#if HAVE_STRTONUM
		const char *s;
		int64_t i = strtonum(arg, 0,
		    ANON_MAXVAL, &s);
		if (s)
			errx(1, "%s M value: %s", s,
			    arg);
#else
		char *ep;
		long long i = strtoll(arg, &ep, 0);
		if ((ep == arg) || (*ep != '\0') ||
		    (i < 0) || (i > ANON_MAXVAL))
			errx(1, "impossible M value:"
			    " %s", arg);
#endif
		anonarch = i;
		return;
	}

	if (!strncmp(arg, "no-", 3)) {
		j = 0;
		arg += 3;
	} else
		j = 1;
	if (!strncmp(arg, "uid", 3) ||
	    !strncmp(arg, "gid", 3)) {
		k = ANON_UIDGID;
	} else if (!strncmp(arg, "ino", 3)) {
		k = ANON_INODES;
	} else if (!strncmp(arg, "mtim", 4)) {
		k = ANON_MTIME;
	} else if (!strncmp(arg, "link", 4)) {
		k = ANON_HARDLINKS;
	} else if (!strncmp(arg, "norm", 4)) {
		k = ANON_UIDGID | ANON_INODES | ANON_NUMID |
		    ANON_MTIME | ANON_HARDLINKS;
	} else if (!strncmp(arg, "root", 4)) {
		k = ANON_UIDGID | ANON_INODES | ANON_NUMID;
	} else if (!strncmp(arg, "dist", 4)) {
		k = ANON_UIDGID | ANON_INODES | ANON_NUMID |
		    ANON_HARDLINKS;
	} else if (!strncmp(arg, "set", 3)) {
		k = ANON_INODES | ANON_HARDLINKS;
	} else if (!strncmp(arg, "v", 1)) {
		k = ANON_VERBOSE;
	} else if (!strncmp(arg, "debug", 5)) {
		k = ANON_DEBUG;
	} else if (!strncmp(arg, "lncp", 4)) {
		k = ANON_LNCP;
	} else if (!strncmp(arg, "numid", 5)) {
		k = ANON_NUMID;
	} else if (!strncmp(arg, "gslash", 6)) {
		k = ANON_DIRSLASH;
	} else
		call_usage();
	if (j)
		anonarch |= k;
	else
		anonarch &= ~k;
}

void
guess_compress_program(int wr __attribute__((__unused__)))
{
	const char *ccp;

	if (compress_program != COMPRESS_GUESS_CMD)
		return;

	if (arcname == NULL || (ccp = strrchr(arcname, '.')) == NULL) {
		compress_program = NULL;
		return;
	}
	++ccp;

	/* guess standard format gzip */
	if (!strcmp(ccp, "gz") ||
	    !strcmp(ccp, "tgz") ||
	    !strcmp(ccp, "cgz") ||
	    !strcmp(ccp, "ngz") ||
	    !strcmp(ccp, "taz")) {
		compress_program = GZIP_CMD;
		return;
	}

#ifndef SMALL
	/* guess extended format xz */
	if (!strcmp(ccp, "xz") ||
	    !strcmp(ccp, "txz") ||
	    !strcmp(ccp, "cxz") ||
	    !strcmp(ccp, "nxz")) {
		compress_program = XZ_CMD;
		return;
	}

	/* guess extended format bzip2 (not bzip) */
	if (!strcmp(ccp, "bz2") ||
	    !strcmp(ccp, "tbz") ||
	    !strcmp(ccp, "tz2") ||
	    !strcmp(ccp, "tbz2") ||
	    !strcmp(ccp, "cbz") ||
	    !strcmp(ccp, "nbz")) {
		compress_program = BZIP2_CMD;
		return;
	}

	/* guess standard format Unix compress */
	if (!strcmp(ccp, "Z") ||
	    !strcmp(ccp, "mcz") ||
	    !strcmp(ccp, "taZ")) {
		compress_program = COMPRESS_CMD;
		return;
	}

	/* guess extended format lzma (using xz for decompression) */
	if (!strcmp(ccp, "lzma")) {
		compress_program = wr ? LZMA_WRCMD : XZ_CMD;
		return;
	}

	/* guess extended format lzop */
	if (!strcmp(ccp, "lzo")) {
		compress_program = LZOP_CMD;
		return;
	}
#endif

	/* no sugar */
	compress_program = NULL;
}

@


1.1.1.11.2.6
log
@some more tweaks
@
text
@d143 15
d205 26
d233 1
a233 1
 *	and MUST match enum fsub_order in pax.h
@


1.1.1.11.2.7
log
@solution for rare open flags, also uses O_BINARY like in mksh
@
text
@d1120 1
a1120 1
					else if ((fd = binopen2(0, file, O_RDONLY)) == -1) {
d1203 1
a1203 1
				else if ((fd = binopen2(0, file, O_RDONLY)) == -1) {
d1457 1
a1457 1
			if ((fd = binopen2(0, optarg, O_RDONLY)) == -1) {
@


1.1.1.11.2.8
log
@we need to bring back ar.h, too
@
text
@a58 1
#include "ar.h"
a254 1
#ifndef SMALL
@


1.1.1.11.2.9
log
@sprinkle more missing includes
@
text
@a43 1
#include <err.h>
a44 1
#include <fcntl.h>
@


