head	1.27;
access;
symbols
	paxmirabilis-20190825:1.27
	paxmirabilis-20190224:1.27
	paxmirabilis-20190210:1.26
	npax:1.1.1.6.0.2
	cvs-20181212:1.1.1.6
	paxmirabilis-20171021:1.22
	paxmirabilis-20161104:1.22
	paxmirabilis-20161031:1.22
	paxmirabilis-20161025:1.22
	paxmirabilis-20160306:1.21
	cvs-201603041945:1.1.1.3
	paxmirabilis-20151013:1.20
	paxmirabilis-20140703:1.20
	paxmirabilis-20120606:1.20
	paxmirabilis-20120605:1.20
	cvs-201206051745:1.1.1.2
	paxmirabilis-20120520:1.19
	paxmirabilis-20120216:1.18
	paxmirabilis-20120212:1.16
	cvs-201202112230:1.1.1.2
	paxmirabilis-20110817:1.15
	MIRBSD_10:1.12.0.2
	MIRBSD_10_BASE:1.12
	cvs-200710231945:1.1.1.1
	cvs-200606232242:1.1.1.1
	MIRBSD_9_BASE:1.10
	MIRBSD_8:1.9.0.2
	MIRBSD_8_BASE:1.9
	cvs-200507211800:1.1.1.1
	cvs-200504291700:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2019.02.24.01.49.17;	author tg;	state Exp;
branches;
next	1.26;
commitid	1005C71F80D12F84641;

1.26
date	2019.02.10.21.50.07;	author tg;	state Exp;
branches;
next	1.25;
commitid	1005C609C8F43A9BDCB;

1.25
date	2018.12.13.07.09.09;	author tg;	state Exp;
branches;
next	1.24;
commitid	1005C1205A44B32AFA4;

1.24
date	2018.12.12.18.08.42;	author tg;	state Exp;
branches;
next	1.23;
commitid	1005C114EA81986F5EC;

1.23
date	2018.12.12.00.23.05;	author tg;	state Exp;
branches;
next	1.22;
commitid	1005C1054FE750D63F3;

1.22
date	2016.03.12.13.20.47;	author tg;	state Exp;
branches;
next	1.21;
commitid	10056E417C13E8BF870;

1.21
date	2016.03.06.13.47.11;	author tg;	state Exp;
branches;
next	1.20;
commitid	10056DC34E25F0AA0A6;

1.20
date	2012.06.05.18.22.56;	author tg;	state Exp;
branches;
next	1.19;
commitid	1004FCE4E961DE91080;

1.19
date	2012.05.20.16.13.16;	author tg;	state Exp;
branches;
next	1.18;
commitid	1004FB918314D2FECC0;

1.18
date	2012.02.16.17.27.31;	author tg;	state Exp;
branches;
next	1.17;
commitid	1004F3D3C992B2187A1;

1.17
date	2012.02.16.17.11.45;	author tg;	state Exp;
branches;
next	1.16;
commitid	1004F3D38626EFD0781;

1.16
date	2012.02.12.00.27.15;	author tg;	state Exp;
branches;
next	1.15;
commitid	1004F3707786D20BF4A;

1.15
date	2011.08.16.21.32.47;	author tg;	state Exp;
branches;
next	1.14;
commitid	1004E4AE1EF00AF3003;

1.14
date	2011.08.16.13.50.17;	author tg;	state Exp;
branches;
next	1.13;
commitid	1004E4A75A9095E9071;

1.13
date	2008.11.08.23.03.37;	author tg;	state Exp;
branches;
next	1.12;
commitid	10049161AB22DF5DFC5;

1.12
date	2007.02.17.05.07.12;	author tg;	state Exp;
branches;
next	1.11;
commitid	10045D68D8D34244A9A;

1.11
date	2007.02.17.04.52.40;	author tg;	state Exp;
branches;
next	1.10;
commitid	10045D68A2D54E2C558;

1.10
date	2006.06.19.19.22.08;	author tg;	state Exp;
branches;
next	1.9;
commitid	1004496F94825B1E33A;

1.9
date	2005.12.17.07.12.06;	author tg;	state Exp;
branches;
next	1.8;
commitid	10043A3B7997FC3F459;

1.8
date	2005.11.23.23.27.10;	author tg;	state Exp;
branches;
next	1.7;
commitid	61c84384fa91bd26;

1.7
date	2005.11.23.22.51.02;	author tg;	state Exp;
branches;
next	1.6;
commitid	12234384f2638c21;

1.6
date	2005.11.23.22.37.09;	author tg;	state Exp;
branches;
next	1.5;
commitid	177e4384ef286916;

1.5
date	2005.11.18.13.58.47;	author tg;	state Exp;
branches;
next	1.4;
commitid	888437ddd2ba951;

1.4
date	2005.11.18.13.40.43;	author tg;	state Exp;
branches;
next	1.3;
commitid	38c0437dd9da5423;

1.3
date	2005.11.16.14.27.28;	author tg;	state Exp;
branches;
next	1.2;
commitid	513b437b415971b7;

1.2
date	2005.11.16.13.58.38;	author tg;	state Exp;
branches;
next	1.1;
commitid	63cf437b3768eac1;

1.1
date	2005.02.05.17.22.06;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.22.06;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2012.02.11.22.47.21;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	1004F36F008225F3522;

1.1.1.3
date	2016.03.04.19.46.09;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	10056D9E61429EE6550;

1.1.1.4
date	2016.03.04.20.54.59;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	10056D9F62E152ECBA5;

1.1.1.5
date	2018.12.12.00.15.03;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	1005C1052FA5E745A2C;

1.1.1.6
date	2018.12.12.00.24.22;	author tg;	state Exp;
branches
	1.1.1.6.2.1;
next	;
commitid	1005C1055452C78F9E4;

1.1.1.6.2.1
date	2018.12.12.01.05.51;	author tg;	state Exp;
branches;
next	1.1.1.6.2.2;
commitid	1005C105F03799CC958;

1.1.1.6.2.2
date	2018.12.12.03.13.30;	author tg;	state Exp;
branches;
next	1.1.1.6.2.3;
commitid	1005C107CE315DC51F3;

1.1.1.6.2.3
date	2018.12.12.04.01.20;	author tg;	state Exp;
branches;
next	1.1.1.6.2.4;
commitid	1005C108824649A94FE;

1.1.1.6.2.4
date	2018.12.12.06.03.11;	author tg;	state Exp;
branches;
next	1.1.1.6.2.5;
commitid	1005C10A4B12E5998CE;

1.1.1.6.2.5
date	2018.12.12.06.53.12;	author tg;	state Exp;
branches;
next	1.1.1.6.2.6;
commitid	1005C10B06C02071195;

1.1.1.6.2.6
date	2018.12.12.14.16.23;	author tg;	state Exp;
branches;
next	1.1.1.6.2.7;
commitid	1005C11184842A35A8D;

1.1.1.6.2.7
date	2018.12.12.15.08.29;	author tg;	state Exp;
branches;
next	1.1.1.6.2.8;
commitid	1005C112483021C3062;

1.1.1.6.2.8
date	2018.12.12.16.24.27;	author tg;	state Exp;
branches;
next	;
commitid	1005C11364A797CBA33;


desc
@@


1.27
log
@deprecate some old earliest MirCPIO extensions:

• tar -R and -S (also dedocumented)
• the dist, v4norm, v4root formats (which already were undocumented)

but indicate in tar(1) that YMMV
@
text
@/*	$OpenBSD: cpio.c,v 1.33 2017/09/16 07:42:34 otto Exp $	*/
/*	$NetBSD: cpio.c,v 1.5 1995/03/21 09:07:13 cgd Exp $	*/

/*-
 * Copyright (c) 2005, 2012, 2016, 2019
 *	mirabilos <m@@mirbsd.org>
 * Copyright (c) 1992 Keith Muller.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if HAVE_STRINGS_H
#include <strings.h>
#endif
#include <unistd.h>

#include "pax.h"
#include "cpio.h"
#include "extern.h"

__RCSID("$MirOS: src/bin/pax/cpio.c,v 1.25 2018/12/13 07:09:09 tg Exp $");

static int rd_nm(ARCHD *, int);
static int rd_ln_nm(ARCHD *);
static int com_rd(ARCHD *);

/*
 * Routines which support the different cpio versions
 */

#ifndef SMALL
static int swp_head;		/* binary cpio header byte swap */
#endif

/*
 * Routines common to all versions of cpio
 */

/*
 * cpio_strd()
 *	Fire up the hard link detection code
 * Return:
 *      0 if ok -1 otherwise (the return values of lnk_start())
 */

int
cpio_strd(void)
{
	return(lnk_start());
}

/*
 * cpio_trail()
 *	Called to determine if a header block is a valid trailer. We are
 *	passed the block, the in_sync flag (which tells us we are in resync
 *	mode; looking for a valid header), and cnt (which starts at zero)
 *	which is used to count the number of empty blocks we have seen so far.
 * Return:
 *	0 if a valid trailer, -1 if not a valid trailer,
 */

int
cpio_trail(ARCHD *arcn, char *notused MKSH_A_UNUSED,
    int notused2 MKSH_A_UNUSED, int *notused3 MKSH_A_UNUSED)
{
	/*
	 * look for trailer id in file we are about to process
	 */
	if ((strcmp(arcn->name, TRAILER) == 0) && (arcn->sb.st_size == 0))
		return(0);
	return(-1);
}

/*
 * com_rd()
 *	operations common to all cpio read functions.
 * Return:
 *	0
 */

static int
com_rd(ARCHD *arcn)
{
	arcn->skip = 0;
	arcn->pat = NULL;
	arcn->org_name = arcn->name;
	switch (arcn->sb.st_mode & C_IFMT) {
	case C_ISFIFO:
		arcn->type = PAX_FIF;
		break;
	case C_ISDIR:
		arcn->type = PAX_DIR;
		break;
	case C_ISBLK:
		arcn->type = PAX_BLK;
		break;
	case C_ISCHR:
		arcn->type = PAX_CHR;
		break;
	case C_ISLNK:
		arcn->type = PAX_SLK;
		break;
	case C_ISOCK:
		arcn->type = PAX_SCK;
		break;
	case C_ISCTG:
	case C_ISREG:
	default:
		/*
		 * we have file data, set up skip (pad is set in the format
		 * specific sections)
		 */
		arcn->sb.st_mode = (arcn->sb.st_mode & 0xfff) | C_ISREG;
		arcn->type = PAX_REG;
		arcn->skip = arcn->sb.st_size;
		break;
	}
	if (chk_lnk(arcn) < 0)
		return(-1);
	return(0);
}

/*
 * cpio_endwr()
 *	write the special file with the name trailer in the proper format
 * Return:
 *	result of the write of the trailer from the cpio specific write func
 */

int
cpio_endwr(void)
{
	ARCHD last;

	/*
	 * create a trailer request and call the proper format write function
	 */
	memset(&last, 0, sizeof(last));
	last.nlen = sizeof(TRAILER) - 1;
	last.type = PAX_REG;
	last.sb.st_nlink = 1;
	(void)strlcpy(last.name, TRAILER, sizeof(last.name));
	return((*frmt->wr)(&last));
}

/*
 * rd_nm()
 *	read in the file name which follows the cpio header
 * Return:
 *	0 if ok, -1 otherwise
 */

static int
rd_nm(ARCHD *arcn, int nsz)
{
	/*
	 * do not even try bogus values
	 */
	if ((nsz == 0) || ((size_t)nsz > sizeof(arcn->name))) {
		paxwarn(1, "cpio file name length %d is out of range", nsz);
		return(-1);
	}

	/*
	 * read the name and make sure it is not empty and is \0 terminated
	 */
	if ((rd_wrbuf(arcn->name,nsz) != nsz) || (arcn->name[nsz-1] != '\0') ||
	    (arcn->name[0] == '\0')) {
		paxwarn(1, "cpio file name in header is corrupted");
		return(-1);
	}
	return(0);
}

/*
 * rd_ln_nm()
 *	read in the link name for a file with links. The link name is stored
 *	like file data (and is NOT \0 terminated!)
 * Return:
 *	0 if ok, -1 otherwise
 */

static int
rd_ln_nm(ARCHD *arcn)
{
	/*
	 * check the length specified for bogus values
	 */
	if ((arcn->sb.st_size <= 0) ||
	    (arcn->sb.st_size >= (off_t)sizeof(arcn->ln_name))) {
		paxwarn(1, "cpio link name length is invalid: %" OT_FMT,
		    arcn->sb.st_size);
		return(-1);
	}

	/*
	 * read in the link name and \0 terminate it
	 */
	if (rd_wrbuf(arcn->ln_name, (int)arcn->sb.st_size) !=
	    (int)arcn->sb.st_size) {
		paxwarn(1, "cpio link name read error");
		return(-1);
	}
	arcn->ln_nlen = arcn->sb.st_size;
	arcn->ln_name[arcn->ln_nlen] = '\0';

	/*
	 * watch out for those empty link names
	 */
	if (arcn->ln_name[0] == '\0') {
		paxwarn(1, "cpio link name is corrupt");
		return(-1);
	}
	return(0);
}

/*
 * Routines common to the extended byte oriented cpio format
 */

/*
 * cpio_id()
 *      determine if a block given to us is a valid extended byte oriented
 *	cpio header
 * Return:
 *      0 if a valid header, -1 otherwise
 */

int
cpio_id(char *blk, int size)
{
	if ((size < (int)sizeof(HD_CPIO)) ||
	    (strncmp(blk, AMAGIC, sizeof(AMAGIC) - 1) != 0))
		return(-1);
	return(0);
}

/*
 * cpio_rd()
 *	determine if a buffer is a byte oriented extended cpio archive entry.
 *	convert and store the values in the ARCHD parameter.
 * Return:
 *	0 if a valid header, -1 otherwise.
 */

int
cpio_rd(ARCHD *arcn, char *buf)
{
	int nsz;
	unsigned long long val;
	HD_CPIO *hd;

	/*
	 * check that this is a valid header, if not return -1
	 */
	if (cpio_id(buf, sizeof(HD_CPIO)) < 0)
		return(-1);
	hd = (HD_CPIO *)buf;

	/*
	 * byte oriented cpio (posix) does not have padding! extract the octal
	 * ascii fields from the header
	 */
	arcn->pad = 0;
	arcn->sb.st_dev = (dev_t)asc_ul(hd->c_dev, sizeof(hd->c_dev), OCT);
	arcn->sb.st_ino = (ino_t)asc_ul(hd->c_ino, sizeof(hd->c_ino), OCT);
	arcn->sb.st_mode = (mode_t)asc_ul(hd->c_mode, sizeof(hd->c_mode), OCT);
	arcn->sb.st_uid = (uid_t)asc_ul(hd->c_uid, sizeof(hd->c_uid), OCT);
	arcn->sb.st_gid = (gid_t)asc_ul(hd->c_gid, sizeof(hd->c_gid), OCT);
	arcn->sb.st_nlink = (nlink_t)asc_ul(hd->c_nlink, sizeof(hd->c_nlink),
	    OCT);
	arcn->sb.st_rdev = (dev_t)asc_ul(hd->c_rdev, sizeof(hd->c_rdev), OCT);
	val = asc_ull(hd->c_mtime, sizeof(hd->c_mtime), OCT);
	if (val > MAX_TIME_T)
		arcn->sb.st_mtime = INT_MAX;			/* XXX 2038 */
	else
		arcn->sb.st_mtime = val;
#if HAVE_ST_MTIM
	arcn->sb.st_mtim.tv_nsec = 0;
#elif HAVE_ST_MTIMENSEC
	arcn->sb.st_mtimensec = 0;
#endif
	/* inline st_timecpy variant, can’t use as-is */
#if HAVE_ST_MTIM
	arcn->sb.st_ctim = arcn->sb.st_atim = arcn->sb.st_mtim;
#else
	arcn->sb.st_ctime = arcn->sb.st_atime = arcn->sb.st_mtime;
#if HAVE_ST_MTIMENSEC
	arcn->sb.st_ctimensec = arcn->sb.st_atimensec = arcn->sb.st_mtimensec;
#endif
#endif
	arcn->sb.st_size = (off_t)asc_ull(hd->c_filesize,sizeof(hd->c_filesize),
	    OCT);

	/*
	 * check name size and if valid, read in the name of this entry (name
	 * follows header in the archive)
	 */
	if ((nsz = (int)asc_ul(hd->c_namesize,sizeof(hd->c_namesize),OCT)) < 2)
		return(-1);
	arcn->nlen = nsz - 1;
	if (rd_nm(arcn, nsz) < 0)
		return(-1);

	if (((arcn->sb.st_mode&C_IFMT) != C_ISLNK)||(arcn->sb.st_size == 0)) {
		/*
		 * no link name to read for this file
		 */
		arcn->ln_nlen = 0;
		arcn->ln_name[0] = '\0';
		return(com_rd(arcn));
	}

	/*
	 * check link name size and read in the link name. Link names are
	 * stored like file data.
	 */
	if (rd_ln_nm(arcn) < 0)
		return(-1);

	/*
	 * we have a valid header (with a link)
	 */
	return(com_rd(arcn));
}

/*
 * cpio_endrd()
 *      no cleanup needed here, just return size of the trailer (for append)
 * Return:
 *      size of trailer header in this format
 */

off_t
cpio_endrd(void)
{
	return ((off_t)(sizeof(HD_CPIO) + sizeof(TRAILER)));
}

/*
 * cpio_stwr()
 *	start up the device mapping table
 * Return:
 *	0 if ok, -1 otherwise (what dev_start() returns)
 */

int
cpio_stwr(int is_app MKSH_A_UNUSED)
{
	if ((anonarch & ANON_INODES) && flnk_start())
		return (-1);
	return (dev_start());
}

#ifndef SMALL
int
dist_stwr(int is_app)
{
	mircpio_deprecated("'dist' format",
	    "the cpio format with 512 bytes blocksize and -M dist");
	anonarch &= ANON_DEBUG | ANON_VERBOSE;
	anonarch |= ANON_UIDGID | ANON_INODES | ANON_HARDLINKS;
	return (cpio_stwr(is_app));
}
#endif

/*
 * cpio_wr()
 *	copy the data in the ARCHD to buffer in extended byte oriented cpio
 *	format.
 * Return
 *      0 if file has data to be written after the header, 1 if file has NO
 *	data to write after the header, -1 if archive write failed
 */

int
cpio_wr(ARCHD *arcn)
{
	HD_CPIO *hd;
	int nsz;
	char hdblk[sizeof(HD_CPIO)];
	u_long t_uid, t_gid, t_dev;
	ino_t t_ino;
	time_t t_mtime;

	anonarch_init();

	/*
	 * check and repair truncated device and inode fields in the header
	 */
	if (map_dev(arcn, CPIO_MASK, CPIO_MASK) < 0)
		return(-1);

	arcn->pad = 0;
	nsz = arcn->nlen + 1;
	hd = (HD_CPIO *)hdblk;
	if ((arcn->type != PAX_BLK) && (arcn->type != PAX_CHR))
		arcn->sb.st_rdev = 0;

	t_uid   = (anonarch & ANON_UIDGID) ? 0UL : (u_long)arcn->sb.st_uid;
	t_gid   = (anonarch & ANON_UIDGID) ? 0UL : (u_long)arcn->sb.st_gid;
	t_mtime = (anonarch & ANON_MTIME)  ? 0   : arcn->sb.st_mtime;
	t_ino   = (anonarch & ANON_INODES) ? (ino_t)chk_flnk(arcn) :
	    arcn->sb.st_ino;
	t_dev   = (anonarch & ANON_INODES) ? 0UL : (u_long)arcn->sb.st_dev;

	if (!cpio_trail(arcn, NULL, 0, NULL))
		t_ino = 0UL;
	if (t_ino == (ino_t)-1) {
		paxwarn(1, "Invalid inode number for file %s", arcn->org_name);
		return (1);
	}
	if (!(anonarch & ANON_HARDLINKS))
		arcn->type &= ~PAX_LINKOR;

	switch (arcn->type) {
	case PAX_CTG:
	case PAX_REG:
	case PAX_HRG:
		/*
		 * set data size for file data
		 */
		if (ull_asc(arcn->sb.st_size, hd->c_filesize,
		    sizeof(hd->c_filesize), OCT)) {
			paxwarn(1, "File is too large for %s format %s",
			    "cpio", arcn->org_name);
			return (1);
		}
		break;
	case PAX_SLK:
		/*
		 * set data size to hold link name
		 */
		if (ul_asc(arcn->ln_nlen, hd->c_filesize,
		    sizeof(hd->c_filesize), OCT))
			goto out;
		break;
	default:
		/*
		 * all other file types have no file data
		 */
		if (ul_asc(0, hd->c_filesize, sizeof(hd->c_filesize), OCT))
			goto out;
		break;
	}

#ifndef SMALL
	if (anonarch & ANON_DEBUG)
		paxwarn(0, "writing dev %lX inode %10lX mode %8lo user %ld:%ld"
		    "\n\tnlink %3ld mtime %08llX name '%s'", t_dev,
		    (u_long)t_ino, (u_long)arcn->sb.st_mode, t_uid, t_gid,
		    (u_long)arcn->sb.st_nlink, (unsigned long long)t_mtime,
		    arcn->name);
#endif

	/*
	 * copy the values to the header using octal ascii
	 */
	if (ul_asc(MAGIC, hd->c_magic, sizeof(hd->c_magic), OCT) ||
	    ul_asc(t_dev, hd->c_dev, sizeof(hd->c_dev), OCT) ||
	    ul_asc((u_long)t_ino, hd->c_ino, sizeof(hd->c_ino), OCT) ||
	    ul_asc(arcn->sb.st_mode, hd->c_mode, sizeof(hd->c_mode), OCT) ||
	    ul_asc(t_uid, hd->c_uid, sizeof(hd->c_uid), OCT) ||
	    ul_asc(t_gid, hd->c_gid, sizeof(hd->c_gid), OCT) ||
	    ul_asc(arcn->sb.st_nlink, hd->c_nlink, sizeof(hd->c_nlink), OCT) ||
	    ul_asc(arcn->sb.st_rdev, hd->c_rdev, sizeof(hd->c_rdev), OCT) ||
	    ull_asc(t_mtime < 0 ? 0ULL : (unsigned long long)t_mtime, hd->c_mtime, sizeof(hd->c_mtime), OCT) ||
	    ul_asc(nsz, hd->c_namesize, sizeof(hd->c_namesize), OCT))
		goto out;

	/*
	 * write the file name to the archive
	 */
	if ((wr_rdbuf(hdblk, (int)sizeof(HD_CPIO)) < 0) ||
	    (wr_rdbuf(arcn->name, nsz) < 0)) {
		paxwarn(1, "Unable to write %s %s for %s",
		    "cpio", "header", arcn->org_name);
		return (-1);
	}

	/*
	 * if this file has data, we are done. The caller will write the file
	 * data, if we are link tell caller we are done, go to next file
	 */
	if (PAX_IS_REG(arcn->type) || (arcn->type == PAX_HRG))
		return (0);
	if (arcn->type & PAX_LINKOR) {
		arcn->type &= ~PAX_LINKOR;
		return (1);
	}
	if (arcn->type != PAX_SLK)
		return (1);

	/*
	 * write the link name to the archive, tell the caller to go to the
	 * next file as we are done.
	 */
	if (wr_rdbuf(arcn->ln_name, arcn->ln_nlen) < 0) {
		paxwarn(1, "Unable to write %s %s for %s",
		    "cpio", "link name", arcn->org_name);
		return (-1);
	}
	return(1);

 out:
	/*
	 * header field is out of range
	 */
	paxwarn(1, "%s header field is too small for file %s",
	    "cpio", arcn->org_name);
	return (1);
}

/*
 * Routines common to the system VR4 version of cpio (with/without file CRC)
 */

/*
 * vcpio_id()
 *      determine if a block given to us is a valid system VR4 cpio header
 *	WITHOUT crc. WATCH it the magic cookies are in OCTAL, the header
 *	uses HEX
 * Return:
 *      0 if a valid header, -1 otherwise
 */

int
vcpio_id(char *blk, int size)
{
	if ((size < (int)sizeof(HD_VCPIO)) ||
	    (strncmp(blk, AVMAGIC, sizeof(AVMAGIC) - 1) != 0))
		return(-1);
	return(0);
}

/*
 * crc_id()
 *      determine if a block given to us is a valid system VR4 cpio header
 *	WITH crc. WATCH it the magic cookies are in OCTAL the header uses HEX
 * Return:
 *      0 if a valid header, -1 otherwise
 */

int
crc_id(char *blk, int size)
{
	if ((size < (int)sizeof(HD_VCPIO)) ||
	    (strncmp(blk, AVCMAGIC, sizeof(AVCMAGIC) - 1) != 0))
		return(-1);
	return(0);
}

/*
 * crc_strd()
 w	set file data CRC calculations. Fire up the hard link detection code
 * Return:
 *      0 if ok -1 otherwise (the return values of lnk_start())
 */

int
crc_strd(void)
{
	docrc = 1;
	return(lnk_start());
}

/*
 * vcpio_rd()
 *	determine if a buffer is a system VR4 archive entry. (with/without CRC)
 *	convert and store the values in the ARCHD parameter.
 * Return:
 *	0 if a valid header, -1 otherwise.
 */

int
vcpio_rd(ARCHD *arcn, char *buf)
{
	HD_VCPIO *hd;
	dev_t devminor;
	dev_t devmajor;
	int nsz;

	/*
	 * during the id phase it was determined if we were using CRC, use the
	 * proper id routine.
	 */
	if (docrc) {
		if (crc_id(buf, sizeof(HD_VCPIO)) < 0)
			return(-1);
	} else {
		if (vcpio_id(buf, sizeof(HD_VCPIO)) < 0)
			return(-1);
	}

	hd = (HD_VCPIO *)buf;
	arcn->pad = 0;

	/*
	 * extract the hex ascii fields from the header
	 */
	arcn->sb.st_ino = (ino_t)asc_ul(hd->c_ino, sizeof(hd->c_ino), HEX);
	arcn->sb.st_mode = (mode_t)asc_ul(hd->c_mode, sizeof(hd->c_mode), HEX);
	arcn->sb.st_uid = (uid_t)asc_ul(hd->c_uid, sizeof(hd->c_uid), HEX);
	arcn->sb.st_gid = (gid_t)asc_ul(hd->c_gid, sizeof(hd->c_gid), HEX);
	arcn->sb.st_mtime = (time_t)asc_ul(hd->c_mtime,sizeof(hd->c_mtime),HEX);
#if HAVE_ST_MTIM
	arcn->sb.st_mtim.tv_nsec = 0;
#elif HAVE_ST_MTIMENSEC
	arcn->sb.st_mtimensec = 0;
#endif
#if HAVE_ST_MTIM
	arcn->sb.st_ctim = arcn->sb.st_atim = arcn->sb.st_mtim;
#else
	arcn->sb.st_ctime = arcn->sb.st_atime = arcn->sb.st_mtime;
#if HAVE_ST_MTIMENSEC
	arcn->sb.st_ctimensec = arcn->sb.st_atimensec = arcn->sb.st_mtimensec;
#endif
#endif
	arcn->sb.st_size = (off_t)asc_ull(hd->c_filesize,
	    sizeof(hd->c_filesize), HEX);
	arcn->sb.st_nlink = (nlink_t)asc_ul(hd->c_nlink, sizeof(hd->c_nlink),
	    HEX);
	devmajor = (dev_t)asc_ul(hd->c_maj, sizeof(hd->c_maj), HEX);
	devminor = (dev_t)asc_ul(hd->c_min, sizeof(hd->c_min), HEX);
	arcn->sb.st_dev = TODEV(devmajor, devminor);
	devmajor = (dev_t)asc_ul(hd->c_rmaj, sizeof(hd->c_rmaj), HEX);
	devminor = (dev_t)asc_ul(hd->c_rmin, sizeof(hd->c_rmin), HEX);
	arcn->sb.st_rdev = TODEV(devmajor, devminor);
	arcn->crc = asc_ul(hd->c_chksum, sizeof(hd->c_chksum), HEX);

	/*
	 * check the length of the file name, if ok read it in, return -1 if
	 * bogus
	 */
	if ((nsz = (int)asc_ul(hd->c_namesize,sizeof(hd->c_namesize),HEX)) < 2)
		return(-1);
	arcn->nlen = nsz - 1;
	if (rd_nm(arcn, nsz) < 0)
		return(-1);

	/*
	 * skip padding. header + filename is aligned to 4 byte boundaries
	 */
	if (rd_skip(VCPIO_PAD(sizeof(HD_VCPIO) + nsz)) < 0)
		return(-1);

	/*
	 * if not a link (or a file with no data), calculate pad size (for
	 * padding which follows the file data), clear the link name and return
	 */
	if (((arcn->sb.st_mode&C_IFMT) != C_ISLNK)||(arcn->sb.st_size == 0)) {
		/*
		 * we have a valid header (not a link)
		 */
		arcn->ln_nlen = 0;
		arcn->ln_name[0] = '\0';
		arcn->pad = VCPIO_PAD(arcn->sb.st_size);
		return(com_rd(arcn));
	}

	/*
	 * read in the link name and skip over the padding
	 */
	if ((rd_ln_nm(arcn) < 0) ||
	    (rd_skip(VCPIO_PAD(arcn->sb.st_size)) < 0))
		return(-1);

	/*
	 * we have a valid header (with a link)
	 */
	return(com_rd(arcn));
}

/*
 * vcpio_endrd()
 *      no cleanup needed here, just return size of the trailer (for append)
 * Return:
 *      size of trailer header in this format
 */

off_t
vcpio_endrd(void)
{
	return sizeof(HD_VCPIO) + sizeof(TRAILER) +
		(VCPIO_PAD(sizeof(HD_VCPIO) + sizeof(TRAILER)));
}

/*
 * crc_stwr()
 *	start up the device mapping table, enable crc file calculation
 * Return:
 *	0 if ok, -1 otherwise (what dev_start() returns)
 */

int
crc_stwr(int is_app MKSH_A_UNUSED)
{
	docrc = 1;
	if ((anonarch & ANON_INODES) && flnk_start())
		return (-1);
	return(dev_start());
}

#ifndef SMALL
int
v4root_stwr(int is_app)
{
	mircpio_deprecated("'v4norm' format",
	    "the sv4crc format with 512 bytes blocksize and -M root");
	anonarch &= ANON_DEBUG | ANON_VERBOSE;
	anonarch |= ANON_UIDGID | ANON_INODES;
	return (crc_stwr(is_app));
}

int
v4norm_stwr(int is_app)
{
	mircpio_deprecated("'v4norm' format",
	    "the sv4crc format with 512 bytes blocksize and -M norm");
	anonarch &= ANON_DEBUG | ANON_VERBOSE;
	anonarch |= ANON_UIDGID | ANON_INODES | ANON_MTIME | ANON_HARDLINKS;
	return (crc_stwr(is_app));
}
#endif

/*
 * vcpio_wr()
 *	copy the data in the ARCHD to buffer in system VR4 cpio
 *	(with/without crc) format.
 * Return
 *	0 if file has data to be written after the header, 1 if file has
 *	NO data to write after the header, -1 if archive write failed
 */

int
vcpio_wr(ARCHD *arcn)
{
	HD_VCPIO *hd;
	unsigned int nsz;
	char hdblk[sizeof(HD_VCPIO)];
	u_long t_uid, t_gid, t_major, t_minor;
	ino_t t_ino;
	time_t t_mtime;

	anonarch_init();

	/*
	 * check and repair truncated device and inode fields in the cpio
	 * header
	 */
	if (map_dev(arcn, VCPIO_MASK, VCPIO_MASK) < 0)
		return(-1);
	nsz = arcn->nlen + 1;
	hd = (HD_VCPIO *)hdblk;
	if ((arcn->type != PAX_BLK) && (arcn->type != PAX_CHR))
		arcn->sb.st_rdev = 0;

	/*
	 * add the proper magic value depending whether we were asked for
	 * file data crc's, and the crc if needed.
	 */
	if (docrc) {
		if (ul_asc(VCMAGIC, hd->c_magic, sizeof(hd->c_magic), OCT) ||
		    ul_asc(arcn->crc,hd->c_chksum,sizeof(hd->c_chksum), HEX))
			goto out;
	} else {
		if (ul_asc(VMAGIC, hd->c_magic, sizeof(hd->c_magic), OCT) ||
		    ul_asc(0, hd->c_chksum, sizeof(hd->c_chksum),HEX))
			goto out;
	}

	t_uid   = (anonarch & ANON_UIDGID) ? 0UL : (u_long)arcn->sb.st_uid;
	t_gid   = (anonarch & ANON_UIDGID) ? 0UL : (u_long)arcn->sb.st_gid;
	t_mtime = (anonarch & ANON_MTIME)  ? 0   : arcn->sb.st_mtime;
	t_ino   = (anonarch & ANON_INODES) ? (ino_t)chk_flnk(arcn) :
	    arcn->sb.st_ino;
	t_major = (anonarch & ANON_INODES) ? 0UL : (u_long)MAJOR(arcn->sb.st_dev);
	t_minor = (anonarch & ANON_INODES) ? 0UL : (u_long)MINOR(arcn->sb.st_dev);

	if (!cpio_trail(arcn, NULL, 0, NULL))
		t_ino = 0UL;
	if (t_ino == (ino_t)-1) {
		paxwarn(1, "Invalid inode number for file %s", arcn->org_name);
		return (1);
	}
	if (!(anonarch & ANON_HARDLINKS))
		arcn->type &= ~PAX_LINKOR;

	switch (arcn->type) {
	case PAX_CTG:
	case PAX_REG:
	case PAX_HRG:
		/*
		 * caller will copy file data to the archive. tell him how
		 * much to pad.
		 */
		arcn->pad = VCPIO_PAD(arcn->sb.st_size);
		if (ull_asc(arcn->sb.st_size, hd->c_filesize,
		    sizeof(hd->c_filesize), HEX)) {
			paxwarn(1, "File is too large for %s format %s",
			    "sv4cpio", arcn->org_name);
			return (1);
		}
		break;
	case PAX_SLK:
		/*
		 * no file data for the caller to process, the file data has
		 * the size of the link
		 */
		arcn->pad = 0;
		if (ul_asc(arcn->ln_nlen, hd->c_filesize,
		    sizeof(hd->c_filesize), HEX))
			goto out;
		break;
	default:
		/*
		 * no file data for the caller to process
		 */
		arcn->pad = 0;
		if (ul_asc(0, hd->c_filesize, sizeof(hd->c_filesize), HEX))
			goto out;
		break;
	}

#ifndef SMALL
	if (anonarch & ANON_DEBUG)
		paxwarn(0, "writing dev %lX:%lx inode %10lX mode %8lo user %ld:%ld"
		    "\n\tnlink %3ld mtime %08llX name '%s'", t_major, t_minor,
		    (u_long)t_ino, (u_long)arcn->sb.st_mode, t_uid, t_gid,
		    (u_long)arcn->sb.st_nlink, (unsigned long long)t_mtime,
		    arcn->name);
#endif

	/*
	 * set the other fields in the header
	 */
	if (ul_asc(t_ino, hd->c_ino, sizeof(hd->c_ino), HEX) ||
	    ul_asc(arcn->sb.st_mode, hd->c_mode, sizeof(hd->c_mode), HEX) ||
	    ul_asc(t_uid, hd->c_uid, sizeof(hd->c_uid), HEX) ||
	    ul_asc(t_gid, hd->c_gid, sizeof(hd->c_gid), HEX) ||
	    ul_asc(t_mtime < 0 ? 0 : t_mtime, hd->c_mtime,
		sizeof(hd->c_mtime), HEX) ||
	    ul_asc(arcn->sb.st_nlink, hd->c_nlink, sizeof(hd->c_nlink), HEX) ||
	    /* device major:minor of the device the file resides on */
	    ul_asc(t_major, hd->c_maj, sizeof(hd->c_maj), HEX) ||
	    ul_asc(t_minor, hd->c_min, sizeof(hd->c_min), HEX) ||
	    /* device major:minor of the file if it's a device node */
	    ul_asc(MAJOR(arcn->sb.st_rdev), hd->c_rmaj, sizeof(hd->c_rmaj), HEX) ||
	    ul_asc(MINOR(arcn->sb.st_rdev), hd->c_rmin, sizeof(hd->c_rmin), HEX) ||
	    ul_asc(nsz, hd->c_namesize, sizeof(hd->c_namesize), HEX))
		goto out;

	/*
	 * write the header, the file name and padding as required.
	 */
	if ((wr_rdbuf(hdblk, (int)sizeof(HD_VCPIO)) < 0) ||
	    (wr_rdbuf(arcn->name, (int)nsz) < 0)  ||
	    (wr_skip(VCPIO_PAD(sizeof(HD_VCPIO) + nsz)) < 0)) {
		paxwarn(1, "Unable to write %s %s for %s",
		    "sv4cpio", "header", arcn->org_name);
		return (-1);
	}

	/*
	 * if we have file data, tell the caller we are done, copy the file
	 */
	if (PAX_IS_REG(arcn->type) || (arcn->type == PAX_HRG))
		return(0);

	/*
	 * if we are a detected hard link, we're done too, but no data written
	 */
	if (arcn->type & PAX_LINKOR) {
		arcn->type &= ~PAX_LINKOR;
		return (1);
	}

	/*
	 * if we are not a link, tell the caller we are done, go to next file
	 */
	if (arcn->type != PAX_SLK)
		return(1);

	/*
	 * write the link name, tell the caller we are done.
	 */
	if ((wr_rdbuf(arcn->ln_name, arcn->ln_nlen) < 0) ||
	    (wr_skip(VCPIO_PAD(arcn->ln_nlen)) < 0)) {
		paxwarn(1, "Unable to write %s %s for %s",
		    "sv4cpio", "link name", arcn->org_name);
		return (-1);
	}
	return(1);

 out:
	/*
	 * header field is out of range
	 */
	paxwarn(1, "%s header field is too small for file %s",
	    "sv4cpio", arcn->org_name);
	return (1);
}

#ifndef SMALL
/*
 * Routines common to the old binary header cpio
 */

/*
 * bcpio_id()
 *      determine if a block given to us is a old binary cpio header
 *	(with/without header byte swapping)
 * Return:
 *      0 if a valid header, -1 otherwise
 */

int
bcpio_id(char *blk, int size)
{
	if (size < (int)sizeof(HD_BCPIO))
		return(-1);

	/*
	 * check both normal and byte swapped magic cookies
	 */
	if (((u_short)SHRT_EXT(blk)) == MAGIC)
		return(0);
	if (((u_short)RSHRT_EXT(blk)) == MAGIC) {
		if (!swp_head)
			++swp_head;
		return(0);
	}
	return(-1);
}

/*
 * bcpio_rd()
 *	determine if a buffer is a old binary archive entry. (it may have byte
 *	swapped header) convert and store the values in the ARCHD parameter.
 *	This is a very old header format and should not really be used.
 * Return:
 *	0 if a valid header, -1 otherwise.
 */

int
bcpio_rd(ARCHD *arcn, char *buf)
{
	HD_BCPIO *hd;
	int nsz;

	/*
	 * check the header
	 */
	if (bcpio_id(buf, sizeof(HD_BCPIO)) < 0)
		return(-1);

	arcn->pad = 0;
	hd = (HD_BCPIO *)buf;
	if (swp_head) {
		/*
		 * header has swapped bytes on 16 bit boundaries
		 */
		arcn->sb.st_dev = (dev_t)(RSHRT_EXT(hd->h_dev));
		arcn->sb.st_ino = (ino_t)(RSHRT_EXT(hd->h_ino));
		arcn->sb.st_mode = (mode_t)(RSHRT_EXT(hd->h_mode));
		arcn->sb.st_uid = (uid_t)(RSHRT_EXT(hd->h_uid));
		arcn->sb.st_gid = (gid_t)(RSHRT_EXT(hd->h_gid));
		arcn->sb.st_nlink = (nlink_t)(RSHRT_EXT(hd->h_nlink));
		arcn->sb.st_rdev = (dev_t)(RSHRT_EXT(hd->h_rdev));
		arcn->sb.st_mtime = (time_t)(RSHRT_EXT(hd->h_mtime_1));
		arcn->sb.st_mtime =  (arcn->sb.st_mtime << 16) |
			((time_t)(RSHRT_EXT(hd->h_mtime_2)));
		arcn->sb.st_size = (off_t)(RSHRT_EXT(hd->h_filesize_1));
		arcn->sb.st_size = (arcn->sb.st_size << 16) |
			((off_t)(RSHRT_EXT(hd->h_filesize_2)));
		nsz = (int)(RSHRT_EXT(hd->h_namesize));
	} else {
		arcn->sb.st_dev = (dev_t)(SHRT_EXT(hd->h_dev));
		arcn->sb.st_ino = (ino_t)(SHRT_EXT(hd->h_ino));
		arcn->sb.st_mode = (mode_t)(SHRT_EXT(hd->h_mode));
		arcn->sb.st_uid = (uid_t)(SHRT_EXT(hd->h_uid));
		arcn->sb.st_gid = (gid_t)(SHRT_EXT(hd->h_gid));
		arcn->sb.st_nlink = (nlink_t)(SHRT_EXT(hd->h_nlink));
		arcn->sb.st_rdev = (dev_t)(SHRT_EXT(hd->h_rdev));
		arcn->sb.st_mtime = (time_t)(SHRT_EXT(hd->h_mtime_1));
		arcn->sb.st_mtime =  (arcn->sb.st_mtime << 16) |
			((time_t)(SHRT_EXT(hd->h_mtime_2)));
		arcn->sb.st_size = (off_t)(SHRT_EXT(hd->h_filesize_1));
		arcn->sb.st_size = (arcn->sb.st_size << 16) |
			((off_t)(SHRT_EXT(hd->h_filesize_2)));
		nsz = (int)(SHRT_EXT(hd->h_namesize));
	}
#if HAVE_ST_MTIM
	arcn->sb.st_mtim.tv_nsec = 0;
#elif HAVE_ST_MTIMENSEC
	arcn->sb.st_mtimensec = 0;
#endif
#if HAVE_ST_MTIM
	arcn->sb.st_ctim = arcn->sb.st_atim = arcn->sb.st_mtim;
#else
	arcn->sb.st_ctime = arcn->sb.st_atime = arcn->sb.st_mtime;
#if HAVE_ST_MTIMENSEC
	arcn->sb.st_ctimensec = arcn->sb.st_atimensec = arcn->sb.st_mtimensec;
#endif
#endif

	/*
	 * check the file name size, if bogus give up. otherwise read the file
	 * name
	 */
	if (nsz < 2)
		return(-1);
	arcn->nlen = nsz - 1;
	if (rd_nm(arcn, nsz) < 0)
		return(-1);

	/*
	 * header + file name are aligned to 2 byte boundaries, skip if needed
	 */
	if (rd_skip(BCPIO_PAD(sizeof(HD_BCPIO) + nsz)) < 0)
		return(-1);

	/*
	 * if not a link (or a file with no data), calculate pad size (for
	 * padding which follows the file data), clear the link name and return
	 */
	if (((arcn->sb.st_mode & C_IFMT) != C_ISLNK)||(arcn->sb.st_size == 0)){
		/*
		 * we have a valid header (not a link)
		 */
		arcn->ln_nlen = 0;
		arcn->ln_name[0] = '\0';
		arcn->pad = BCPIO_PAD(arcn->sb.st_size);
		return(com_rd(arcn));
	}

	if ((rd_ln_nm(arcn) < 0) ||
	    (rd_skip(BCPIO_PAD(arcn->sb.st_size)) < 0))
		return(-1);

	/*
	 * we have a valid header (with a link)
	 */
	return(com_rd(arcn));
}

/*
 * bcpio_endrd()
 *      no cleanup needed here, just return size of the trailer (for append)
 * Return:
 *      size of trailer header in this format
 */

off_t
bcpio_endrd(void)
{
	return sizeof(HD_BCPIO) + sizeof(TRAILER) +
		(BCPIO_PAD(sizeof(HD_BCPIO) + sizeof(TRAILER)));
}

/*
 * bcpio_wr()
 *	copy the data in the ARCHD to buffer in old binary cpio format
 *	There is a real chance of field overflow with this critter. So we
 *	always check the conversion is ok. nobody in their right mind
 *	should write an archive in this format...
 * Return
 *      0 if file has data to be written after the header, 1 if file has NO
 *	data to write after the header, -1 if archive write failed
 */

int
bcpio_wr(ARCHD *arcn)
{
	HD_BCPIO *hd;
	int nsz;
	char hdblk[sizeof(HD_BCPIO)];
	off_t t_offt;
	int t_int;
	time_t t_timet;

	/*
	 * check and repair truncated device and inode fields in the cpio
	 * header
	 */
	if (map_dev(arcn, BCPIO_MASK, BCPIO_MASK) < 0)
		return(-1);

	if ((arcn->type != PAX_BLK) && (arcn->type != PAX_CHR))
		arcn->sb.st_rdev = 0;
	hd = (HD_BCPIO *)hdblk;

	switch (arcn->type) {
	case PAX_CTG:
	case PAX_REG:
	case PAX_HRG:
		/*
		 * caller will copy file data to the archive. tell him how
		 * much to pad.
		 */
		arcn->pad = BCPIO_PAD(arcn->sb.st_size);
		hd->h_filesize_1[0] = CHR_WR_0(arcn->sb.st_size);
		hd->h_filesize_1[1] = CHR_WR_1(arcn->sb.st_size);
		hd->h_filesize_2[0] = CHR_WR_2(arcn->sb.st_size);
		hd->h_filesize_2[1] = CHR_WR_3(arcn->sb.st_size);
		t_offt = (off_t)(SHRT_EXT(hd->h_filesize_1));
		t_offt = (t_offt<<16) | ((off_t)(SHRT_EXT(hd->h_filesize_2)));
		if (arcn->sb.st_size != t_offt) {
			paxwarn(1, "File is too large for %s format %s",
			    "bcpio", arcn->org_name);
			return (1);
		}
		break;
	case PAX_SLK:
		/*
		 * no file data for the caller to process, the file data has
		 * the size of the link
		 */
		arcn->pad = 0;
		hd->h_filesize_1[0] = CHR_WR_0(arcn->ln_nlen);
		hd->h_filesize_1[1] = CHR_WR_1(arcn->ln_nlen);
		hd->h_filesize_2[0] = CHR_WR_2(arcn->ln_nlen);
		hd->h_filesize_2[1] = CHR_WR_3(arcn->ln_nlen);
		t_int = (int)(SHRT_EXT(hd->h_filesize_1));
		t_int = (t_int << 16) | ((int)(SHRT_EXT(hd->h_filesize_2)));
		if (arcn->ln_nlen != t_int)
			goto out;
		break;
	default:
		/*
		 * no file data for the caller to process
		 */
		arcn->pad = 0;
		hd->h_filesize_1[0] = (char)0;
		hd->h_filesize_1[1] = (char)0;
		hd->h_filesize_2[0] = (char)0;
		hd->h_filesize_2[1] = (char)0;
		break;
	}

	/*
	 * build up the rest of the fields
	 */
	hd->h_magic[0] = CHR_WR_2(MAGIC);
	hd->h_magic[1] = CHR_WR_3(MAGIC);
	hd->h_dev[0] = CHR_WR_2(arcn->sb.st_dev);
	hd->h_dev[1] = CHR_WR_3(arcn->sb.st_dev);
	if (arcn->sb.st_dev != (dev_t)(SHRT_EXT(hd->h_dev)))
		goto out;
	hd->h_ino[0] = CHR_WR_2(arcn->sb.st_ino);
	hd->h_ino[1] = CHR_WR_3(arcn->sb.st_ino);
	if (arcn->sb.st_ino != (ino_t)(SHRT_EXT(hd->h_ino)))
		goto out;
	hd->h_mode[0] = CHR_WR_2(arcn->sb.st_mode);
	hd->h_mode[1] = CHR_WR_3(arcn->sb.st_mode);
	if (arcn->sb.st_mode != (mode_t)(SHRT_EXT(hd->h_mode)))
		goto out;
	hd->h_uid[0] = CHR_WR_2(arcn->sb.st_uid);
	hd->h_uid[1] = CHR_WR_3(arcn->sb.st_uid);
	if (arcn->sb.st_uid != (uid_t)(SHRT_EXT(hd->h_uid)))
		goto out;
	hd->h_gid[0] = CHR_WR_2(arcn->sb.st_gid);
	hd->h_gid[1] = CHR_WR_3(arcn->sb.st_gid);
	if (arcn->sb.st_gid != (gid_t)(SHRT_EXT(hd->h_gid)))
		goto out;
	hd->h_nlink[0] = CHR_WR_2(arcn->sb.st_nlink);
	hd->h_nlink[1] = CHR_WR_3(arcn->sb.st_nlink);
	if (arcn->sb.st_nlink != (nlink_t)(SHRT_EXT(hd->h_nlink)))
		goto out;
	hd->h_rdev[0] = CHR_WR_2(arcn->sb.st_rdev);
	hd->h_rdev[1] = CHR_WR_3(arcn->sb.st_rdev);
	if (arcn->sb.st_rdev != (dev_t)(SHRT_EXT(hd->h_rdev)))
		goto out;
	if (arcn->sb.st_mtime > 0) {
		hd->h_mtime_1[0] = CHR_WR_0(arcn->sb.st_mtime);
		hd->h_mtime_1[1] = CHR_WR_1(arcn->sb.st_mtime);
		hd->h_mtime_2[0] = CHR_WR_2(arcn->sb.st_mtime);
		hd->h_mtime_2[1] = CHR_WR_3(arcn->sb.st_mtime);
		t_timet = (time_t)SHRT_EXT(hd->h_mtime_1);
		t_timet =  t_timet << 16 | (time_t)SHRT_EXT(hd->h_mtime_2);
		if (arcn->sb.st_mtime != t_timet)
			goto out;
	} else {
		hd->h_mtime_1[0] = hd->h_mtime_1[1] = 0;
		hd->h_mtime_2[0] = hd->h_mtime_2[1] = 0;
	}
	nsz = arcn->nlen + 1;
	hd->h_namesize[0] = CHR_WR_2(nsz);
	hd->h_namesize[1] = CHR_WR_3(nsz);
	if (nsz != (int)(SHRT_EXT(hd->h_namesize)))
		goto out;

	/*
	 * write the header, the file name and padding as required.
	 */
	if ((wr_rdbuf(hdblk, (int)sizeof(HD_BCPIO)) < 0) ||
	    (wr_rdbuf(arcn->name, nsz) < 0) ||
	    (wr_skip(BCPIO_PAD(sizeof(HD_BCPIO) + nsz)) < 0)) {
		paxwarn(1, "Unable to write %s %s for %s",
		    "bcpio", "header", arcn->org_name);
		return (-1);
	}

	/*
	 * if we have file data, tell the caller we are done
	 */
	if (PAX_IS_REG(arcn->type) || (arcn->type == PAX_HRG))
		return(0);

	/*
	 * if we are not a link, tell the caller we are done, go to next file
	 */
	if (arcn->type != PAX_SLK)
		return(1);

	/*
	 * write the link name, tell the caller we are done.
	 */
	if ((wr_rdbuf(arcn->ln_name, arcn->ln_nlen) < 0) ||
	    (wr_skip(BCPIO_PAD(arcn->ln_nlen)) < 0)) {
		paxwarn(1, "Unable to write %s %s for %s",
		    "bcpio", "link name", arcn->org_name);
		return (-1);
	}
	return(1);

 out:
	/*
	 * header field is out of range
	 */
	paxwarn(1, "%s header field is too small for file %s",
	    "bcpio", arcn->org_name);
	return (1);
}
#endif
@


1.26
log
@port to Debian sid/{amd64,i386,hurd-i386,x32}, {stretch,jessie}/{amd64,i386}
@
text
@d388 1
d392 2
d398 1
d737 1
d741 2
d751 2
d757 1
@


1.25
log
@fixing and string pooling and int shortening offensive
@
text
@d5 1
a5 1
 * Copyright (c) 2005, 2012, 2016
d54 1
a54 1
__RCSID("$MirOS: src/bin/pax/cpio.c,v 1.24 2018/12/12 18:08:42 tg Exp $");
d224 1
a224 1
		paxwarn(1, "cpio link name length is invalid: %lld",
@


1.24
log
@merge the npax branch into MAIN

asides from a missing dprintf and portability, this ought to be
good enough for people (well me) to play with for now
@
text
@d54 1
a54 1
__RCSID("$MirOS: src/bin/pax/cpio.c,v 1.22 2016/03/12 13:20:47 tg Exp $");
d454 3
a456 3
			paxwarn(1,"File is too large for cpio format %s",
			    arcn->org_name);
			return(1);
d505 3
a507 2
		paxwarn(1, "Unable to write cpio header for %s", arcn->org_name);
		return(-1);
d528 3
a530 2
		paxwarn(1,"Unable to write cpio link name for %s",arcn->org_name);
		return(-1);
d538 3
a540 3
	paxwarn(1, "cpio header field is too small to store file %s",
	    arcn->org_name);
	return(1);
d823 3
a825 3
			paxwarn(1,"File is too large for sv4cpio format %s",
			    arcn->org_name);
			return(1);
d882 3
a884 2
		paxwarn(1,"Could not write sv4cpio header for %s",arcn->org_name);
		return(-1);
d912 3
a914 3
		paxwarn(1,"Could not write sv4cpio link name for %s",
		    arcn->org_name);
		return(-1);
d922 3
a924 2
	paxwarn(1, "sv4cpio header field is too small for file %s", arcn->org_name);
	return(1);
d1132 3
a1134 3
			paxwarn(1,"File is too large for bcpio format %s",
			    arcn->org_name);
			return(1);
d1222 3
a1224 2
		paxwarn(1, "Could not write bcpio header for %s", arcn->org_name);
		return(-1);
d1244 3
a1246 2
		paxwarn(1,"Could not write bcpio link name for %s",arcn->org_name);
		return(-1);
d1254 3
a1256 2
	paxwarn(1, "bcpio header field is too small for file %s", arcn->org_name);
	return(1);
@


1.23
log
@slowmerge (untested though)
@
text
@d39 1
a39 2
#include <sys/param.h>
#include <sys/time.h>
d41 3
d45 3
a47 1
#include <stdio.h>
d49 1
a49 2
#include <stdlib.h>
#include <time.h>
a52 1
#include "options.h"
d96 2
a97 3
cpio_trail(ARCHD *arcn, char *notused __attribute__((__unused__)),
    int notused2 __attribute__((__unused__)),
    int *notused3 __attribute__((__unused__)))
d180 1
a180 1
 * rd_nam()
d224 2
a225 2
		paxwarn(1, "cpio link name length is invalid: %" OT_FMT,
		    (ot_type)arcn->sb.st_size);
d283 1
d297 1
a297 1
	arcn->pad = 0L;
d306 14
a319 2
	arcn->sb.st_mtime = (time_t)asc_ul(hd->c_mtime, sizeof(hd->c_mtime),
	    OCT);
d321 5
a325 1
	arcn->sb.st_size = (off_t)asc_ot(hd->c_filesize,sizeof(hd->c_filesize),
d370 1
a370 1
	return((off_t)(sizeof(HD_CPIO) + sizeof(TRAILER)));
d381 1
a381 1
cpio_stwr(int is_app __attribute__((__unused__)))
d385 1
a385 1
	return(dev_start());
d393 1
a393 1
	return(cpio_stwr(is_app));
d411 1
a411 2

	u_long t_uid, t_gid, t_mtime, t_dev;
d413 1
d420 1
a420 1
	if (map_dev(arcn, (u_long)CPIO_MASK, (u_long)CPIO_MASK) < 0)
d423 1
a423 1
	arcn->pad = 0L;
d431 1
a431 1
	t_mtime = (anonarch & ANON_MTIME) ? 0UL : (u_long)arcn->sb.st_mtime;
d435 1
d452 1
a452 1
		if (ot_asc(arcn->sb.st_size, hd->c_filesize,
d463 1
a463 1
		if (ul_asc((u_long)arcn->ln_nlen, hd->c_filesize,
d471 1
a471 2
		if (ul_asc((u_long)0, hd->c_filesize, sizeof(hd->c_filesize),
		     OCT))
d476 1
d479 1
a479 1
		    "\n\tnlink %3ld mtime %08lX name '%s'", t_dev,
d481 3
a483 1
		    (u_long)arcn->sb.st_nlink, t_mtime, arcn->name);
d488 10
a497 18
	if (ul_asc((u_long)MAGIC, hd->c_magic, sizeof(hd->c_magic), OCT) ||
	    ul_asc(t_dev, hd->c_dev, sizeof(hd->c_dev),
		OCT) ||
	    ul_asc((u_long)t_ino, hd->c_ino, sizeof(hd->c_ino),
		OCT) ||
	    ul_asc((u_long)arcn->sb.st_mode, hd->c_mode, sizeof(hd->c_mode),
		OCT) ||
	    ul_asc(t_uid, hd->c_uid, sizeof(hd->c_uid),
		OCT) ||
	    ul_asc(t_gid, hd->c_gid, sizeof(hd->c_gid),
		OCT) ||
	    ul_asc((u_long)arcn->sb.st_nlink, hd->c_nlink, sizeof(hd->c_nlink),
		 OCT) ||
	    ul_asc((u_long)arcn->sb.st_rdev, hd->c_rdev, sizeof(hd->c_rdev),
		OCT) ||
	    ul_asc(t_mtime,hd->c_mtime,sizeof(hd->c_mtime),
		OCT) ||
	    ul_asc((u_long)nsz, hd->c_namesize, sizeof(hd->c_namesize), OCT))
d513 2
a514 3
	if ((arcn->type == PAX_CTG) || (arcn->type == PAX_REG) ||
	    (arcn->type == PAX_HRG))
		return(0);
d520 1
a520 1
		return(1);
d623 1
a623 1
	arcn->pad = 0L;
d633 8
d642 5
a646 1
	arcn->sb.st_size = (off_t)asc_ot(hd->c_filesize,
d671 1
a671 1
	if (rd_skip((off_t)(VCPIO_PAD(sizeof(HD_VCPIO) + nsz))) < 0)
d692 1
a692 1
	    (rd_skip((off_t)(VCPIO_PAD(arcn->sb.st_size))) < 0))
d711 2
a712 2
	return((off_t)(sizeof(HD_VCPIO) + sizeof(TRAILER) +
		(VCPIO_PAD(sizeof(HD_VCPIO) + sizeof(TRAILER)))));
d723 1
a723 1
crc_stwr(int is_app __attribute__((__unused__)))
d762 1
a762 2

	u_long t_uid, t_gid, t_mtime, t_major, t_minor;
d764 1
d772 1
a772 1
	if (map_dev(arcn, (u_long)VCPIO_MASK, (u_long)VCPIO_MASK) < 0)
d784 2
a785 4
		if (ul_asc((u_long)VCMAGIC, hd->c_magic, sizeof(hd->c_magic),
			OCT) ||
		    ul_asc((u_long)arcn->crc,hd->c_chksum,sizeof(hd->c_chksum),
			HEX))
d788 2
a789 3
		if (ul_asc((u_long)VMAGIC, hd->c_magic, sizeof(hd->c_magic),
			OCT) ||
		    ul_asc((u_long)0L, hd->c_chksum, sizeof(hd->c_chksum),HEX))
d795 1
a795 1
	t_mtime = (anonarch & ANON_MTIME) ? 0UL : (u_long)arcn->sb.st_mtime;
d800 1
d819 1
a819 1
		if (ot_asc(arcn->sb.st_size, hd->c_filesize,
d831 2
a832 2
		arcn->pad = 0L;
		if (ul_asc((u_long)arcn->ln_nlen, hd->c_filesize,
d840 2
a841 3
		arcn->pad = 0L;
		if (ul_asc((u_long)0L, hd->c_filesize, sizeof(hd->c_filesize),
		    HEX))
d846 1
d849 1
a849 1
		    "\n\tnlink %3ld mtime %08lX name '%s'", t_major, t_minor,
d851 3
a853 1
		    (u_long)arcn->sb.st_nlink, t_mtime, arcn->name);
d858 7
a864 12
	if (ul_asc((u_long)t_ino, hd->c_ino, sizeof(hd->c_ino),
		HEX) ||
	    ul_asc((u_long)arcn->sb.st_mode, hd->c_mode, sizeof(hd->c_mode),
		HEX) ||
	    ul_asc(t_uid, hd->c_uid, sizeof(hd->c_uid),
		HEX) ||
	    ul_asc(t_gid, hd->c_gid, sizeof(hd->c_gid),
		HEX) ||
	    ul_asc(t_mtime, hd->c_mtime, sizeof(hd->c_mtime),
		HEX) ||
	    ul_asc((u_long)arcn->sb.st_nlink, hd->c_nlink, sizeof(hd->c_nlink),
		HEX) ||
d869 3
a871 5
	    ul_asc((u_long)MAJOR(arcn->sb.st_rdev), hd->c_rmaj,
		sizeof(hd->c_rmaj), HEX) ||
	    ul_asc((u_long)MINOR(arcn->sb.st_rdev), hd->c_rmin,
		sizeof(hd->c_rmin), HEX) ||
	    ul_asc((u_long)nsz, hd->c_namesize, sizeof(hd->c_namesize), HEX))
d879 1
a879 1
	    (wr_skip((off_t)(VCPIO_PAD(sizeof(HD_VCPIO) + nsz))) < 0)) {
d887 1
a887 2
	if ((arcn->type == PAX_CTG) || (arcn->type == PAX_REG) ||
	    (arcn->type == PAX_HRG))
d908 1
a908 1
	    (wr_skip((off_t)(VCPIO_PAD(arcn->ln_nlen))) < 0)) {
d919 1
a919 1
	paxwarn(1,"sv4cpio header field is too small for file %s",arcn->org_name);
d976 1
a976 1
	arcn->pad = 0L;
d1012 8
d1021 4
d1039 1
a1039 1
	if (rd_skip((off_t)(BCPIO_PAD(sizeof(HD_BCPIO) + nsz))) < 0)
d1057 1
a1057 1
	    (rd_skip((off_t)(BCPIO_PAD(arcn->sb.st_size))) < 0))
d1076 2
a1077 2
	return((off_t)(sizeof(HD_BCPIO) + sizeof(TRAILER) +
		(BCPIO_PAD(sizeof(HD_BCPIO) + sizeof(TRAILER)))));
d1105 1
a1105 1
	if (map_dev(arcn, (u_long)BCPIO_MASK, (u_long)BCPIO_MASK) < 0)
d1138 1
a1138 1
		arcn->pad = 0L;
d1152 1
a1152 1
		arcn->pad = 0L;
d1193 13
a1205 8
	hd->h_mtime_1[0] = CHR_WR_0(arcn->sb.st_mtime);
	hd->h_mtime_1[1] = CHR_WR_1(arcn->sb.st_mtime);
	hd->h_mtime_2[0] = CHR_WR_2(arcn->sb.st_mtime);
	hd->h_mtime_2[1] = CHR_WR_3(arcn->sb.st_mtime);
	t_timet = (time_t)(SHRT_EXT(hd->h_mtime_1));
	t_timet =  (t_timet << 16) | ((time_t)(SHRT_EXT(hd->h_mtime_2)));
	if (arcn->sb.st_mtime != t_timet)
		goto out;
d1217 1
a1217 1
	    (wr_skip((off_t)(BCPIO_PAD(sizeof(HD_BCPIO) + nsz))) < 0)) {
d1225 1
a1225 2
	if ((arcn->type == PAX_CTG) || (arcn->type == PAX_REG) ||
	    (arcn->type == PAX_HRG))
d1238 1
a1238 1
	    (wr_skip((off_t)(BCPIO_PAD(arcn->ln_nlen))) < 0)) {
d1248 1
a1248 1
	paxwarn(1,"Bcpio header field is too small for file %s", arcn->org_name);
@


1.22
log
@drop support for bcpio and (old)tar on the floppy
@
text
@d1 1
a1 1
/*	$OpenBSD: cpio.c,v 1.19 2009/10/27 23:59:22 deraadt Exp $	*/
d52 1
a52 1
__RCSID("$MirOS: src/bin/pax/cpio.c,v 1.21 2016/03/06 13:47:11 tg Exp $");
d221 2
a222 2
	if ((arcn->sb.st_size == 0) ||
	    ((size_t)arcn->sb.st_size >= sizeof(arcn->ln_name))) {
d225 1
a225 1
		return (-1);
d264 1
a264 1
	if (((size_t)size < sizeof(HD_CPIO)) ||
d545 1
a545 1
	if (((size_t)size < sizeof(HD_VCPIO)) ||
d562 1
a562 1
	if (((size_t)size < sizeof(HD_VCPIO)) ||
d923 1
a923 1
	if ((size_t)size < sizeof(HD_BCPIO))
@


1.21
log
@apply changes from mpax-erstmalnurderbackport branch not related to the CVEs
@
text
@d52 1
a52 1
__RCSID("$MirOS: src/bin/pax/cpio.c,v 1.19 2012/05/20 16:13:16 tg Exp $");
d62 1
d64 1
d907 1
d1219 1
@


1.20
log
@KNF
@
text
@d5 2
a6 2
 * Copyright (c) 2005, 2012
 *	Thorsten Glaser <tg@@mirbsd.org>
@


1.19
log
@get rid of extern.h including other headers
@
text
@d52 1
a52 1
__RCSID("$MirOS: src/bin/pax/cpio.c,v 1.18 2012/02/16 17:27:31 tg Exp $");
d518 1
a518 1
    out:
d897 1
a897 1
    out:
d1209 1
a1209 1
    out:
@


1.18
log
@clean up some ugliness
@
text
@d46 1
d52 1
a52 1
__RCSID("$MirOS: src/bin/pax/cpio.c,v 1.17 2012/02/16 17:11:45 tg Exp $");
@


1.17
log
@Debian GNU/kFreeBSD can be more difficult to deal with than GNU/Hurd at times.

• switch from quad_t to using unsigned long / unsigned long long
• sanitise use of off_t-relevant types
• cast when printing off_t; use a once-defined type and format specifier
• convert “This define is important” into actual compile-time assertion
• simplify ifdef mess by always defining off_t specific routines
  instead of reusing those for long if off_t is just long
@
text
@d51 1
a51 1
__RCSID("$MirOS: src/bin/pax/cpio.c,v 1.16 2012/02/12 00:27:15 tg Exp $");
d189 1
a189 1
		paxwarn(1, "Cpio file name length %d is out of range", nsz);
d198 1
a198 1
		paxwarn(1, "Cpio file name in header is corrupted");
d230 1
a230 1
		paxwarn(1, "Cpio link name read error");
d240 1
a240 1
		paxwarn(1, "Cpio link name is corrupt");
d521 1
a521 1
	paxwarn(1, "Cpio header field is too small to store file %s",
d900 1
a900 1
	paxwarn(1,"Sv4cpio header field is too small for file %s",arcn->org_name);
@


1.16
log
@merge OpenBSD
@
text
@d5 2
a6 1
 * Copyright (c) 2005 Thorsten Glaser <tg@@mirbsd.org>
d51 1
a51 1
__RCSID("$MirOS: src/bin/pax/cpio.c,v 1.15 2011/08/16 21:32:47 tg Exp $");
d220 3
a222 8
#		ifdef LONG_OFF_T
		paxwarn(1, "Cpio link name length is invalid: %lu",
		    arcn->sb.st_size);
#		else
		paxwarn(1, "Cpio link name length is invalid: %llu",
		    arcn->sb.st_size);
#		endif
		return(-1);
d304 1
a304 5
#	ifdef LONG_OFF_T
	arcn->sb.st_size = (off_t)asc_ul(hd->c_filesize,sizeof(hd->c_filesize),
	    OCT);
#	else
	arcn->sb.st_size = (off_t)asc_uqd(hd->c_filesize,sizeof(hd->c_filesize),
a305 1
#	endif
d430 1
a430 2
#		ifdef LONG_OFF_T
		if (ul_asc((u_long)arcn->sb.st_size, hd->c_filesize,
a431 4
#		else
		if (uqd_asc((u_quad_t)arcn->sb.st_size, hd->c_filesize,
		    sizeof(hd->c_filesize), OCT)) {
#		endif
d619 1
a619 5
#	ifdef LONG_OFF_T
	arcn->sb.st_size = (off_t)asc_ul(hd->c_filesize,
	    sizeof(hd->c_filesize), HEX);
#	else
	arcn->sb.st_size = (off_t)asc_uqd(hd->c_filesize,
a620 1
#	endif
d794 1
a794 5
#		ifdef LONG_OFF_T
		if (ul_asc((u_long)arcn->sb.st_size, hd->c_filesize,
		    sizeof(hd->c_filesize), HEX)) {
#		else
		if (uqd_asc((u_quad_t)arcn->sb.st_size, hd->c_filesize,
a795 1
#		endif
@


1.15
log
@backend for Unix Archiver libraries – ar(5) and deb(5) format files
(since GNU binutils on ELF systems thinks SYSV style ar is used…)
@
text
@d1 1
a1 2
/**	$MirOS: src/bin/pax/cpio.c,v 1.14 2011/08/16 13:50:17 tg Exp $ */
/*	$OpenBSD: cpio.c,v 1.17 2004/04/16 22:50:23 deraadt Exp $	*/
d50 1
a50 2
__SCCSID("@@(#)cpio.c	8.1 (Berkeley) 5/31/93");
__RCSID("$MirOS: src/bin/pax/cpio.c,v 1.14 2011/08/16 13:50:17 tg Exp $");
d152 1
a152 1
 * cpio_end_wr()
@


1.14
log
@use underscores with __attribute__s
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/cpio.c,v 1.13 2008/11/08 23:03:37 tg Exp $ */
d52 1
a52 1
__RCSID("$MirOS: src/bin/pax/cpio.c,v 1.13 2008/11/08 23:03:37 tg Exp $");
d371 1
a371 1
cpio_stwr(void)
d379 1
a379 1
dist_stwr(void)
d383 1
a383 1
	return(cpio_stwr());
d717 1
a717 1
crc_stwr(void)
d726 1
a726 1
v4root_stwr(void)
d730 1
a730 1
	return (crc_stwr());
d734 1
a734 1
v4norm_stwr(void)
d738 1
a738 1
	return (crc_stwr());
@


1.13
log
@more mass conversions, including ancient eMail addresses
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/cpio.c,v 1.12 2007/02/17 05:07:12 tg Exp $ */
d52 1
a52 1
__RCSID("$MirOS: src/bin/pax/cpio.c,v 1.12 2007/02/17 05:07:12 tg Exp $");
d92 3
a94 3
cpio_trail(ARCHD *arcn, char *notused __attribute__((unused)),
    int notused2 __attribute__((unused)),
    int *notused3 __attribute__((unused)))
@


1.12
log
@__CRAZY on gcc 4.1.2/debian warning
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/cpio.c,v 1.11 2007/02/17 04:52:40 tg Exp $ */
d6 1
a6 1
 * Copyright (c) 2005 Thorsten Glaser <tg@@66h.42h.de>
d52 1
a52 1
__RCSID("$MirOS: src/bin/pax/cpio.c,v 1.11 2007/02/17 04:52:40 tg Exp $");
@


1.11
log
@__CRAZY clean
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/cpio.c,v 1.10 2006/06/19 19:22:08 tg Exp $ */
d52 1
a52 1
__RCSID("$MirOS: src/bin/pax/cpio.c,v 1.10 2006/06/19 19:22:08 tg Exp $");
d220 1
a220 1
	    (arcn->sb.st_size >= sizeof(arcn->ln_name))) {
@


1.10
log
@move the anonarch commons into options.c and options.h
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/cpio.c,v 1.9 2005/12/17 07:12:06 tg Exp $ */
d52 1
a52 1
__RCSID("$MirOS: src/bin/pax/cpio.c,v 1.9 2005/12/17 07:12:06 tg Exp $");
d92 3
a94 1
cpio_trail(ARCHD *arcn, char *notused, int notused2, int *notused3)
d189 1
a189 1
	if ((nsz == 0) || (nsz > sizeof(arcn->name))) {
d225 1
a225 1
		paxwarn(1, "Cpio link name length is invalid: %qu",
d267 1
a267 1
	if ((size < sizeof(HD_CPIO)) ||
d422 2
a423 1
	t_ino   = (anonarch & ANON_INODES) ? chk_flnk(arcn) : arcn->sb.st_ino;
d427 1
a427 1
	if (t_ino == -1) {
d558 1
a558 1
	if ((size < sizeof(HD_VCPIO)) ||
d575 1
a575 1
	if ((size < sizeof(HD_VCPIO)) ||
d793 2
a794 1
	t_ino   = (anonarch & ANON_INODES) ? chk_flnk(arcn) : arcn->sb.st_ino;
d799 1
a799 1
	if (t_ino == -1) {
d945 1
a945 1
	if (size < sizeof(HD_BCPIO))
@


1.9
log
@Once upon a time, we had two new formats.
Then, a third one.

Now, we've got the -M option with which you can set all these
anonymisation, normalisation etc. options bitwise.
We also have two new bits:
 - verbose, which tells you what anon options are used
 - debug, which traces files as their headers are stored

That all of course documented in the manual page.
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/cpio.c,v 1.8 2005/11/23 23:27:10 tg Exp $ */
d49 1
d52 1
a52 1
__RCSID("$MirOS: src/bin/pax/cpio.c,v 1.8 2005/11/23 23:27:10 tg Exp $");
a67 9
static void
anonarch_init(void)
{
	if (anonarch & ANON_VERBOSE) {
		anonarch &= ~ANON_VERBOSE;
		paxwarn(0, "debug: -M 0x%08X", anonarch);
	}
}

@


1.8
log
@* cpio.1, pax.1: document new format "dist"
* cpio.c: implement new format "dist"
* cpio.c: trailer doesn't need an inode in any case
* cpio.h: sync comments between CPIO and VCPIO structs
* extern.h, options.c: add glue for new format "dist"
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/cpio.c,v 1.7 2005/11/23 22:51:02 tg Exp $ */
d51 1
a51 1
__RCSID("$MirOS: src/bin/pax/cpio.c,v 1.7 2005/11/23 22:51:02 tg Exp $");
a56 7
/* Normalise archives? */
static int anonarch = 0;
#define	ANON_UIDGID	1
#define	ANON_INODES	2
#define	ANON_MTIME	4
#define	ANON_HARDLINKS	8

d67 9
d379 2
d387 3
a389 4
	anonarch = ANON_UIDGID | ANON_INODES | ANON_HARDLINKS;
	if (flnk_start())
		return (-1);
	return(dev_start());
d411 2
d476 6
d725 2
d733 2
a734 3
	anonarch = ANON_UIDGID | ANON_INODES;
	if (flnk_start())
		return (-1);
d741 2
a742 3
	anonarch = ANON_UIDGID | ANON_INODES | ANON_MTIME | ANON_HARDLINKS;
	if (flnk_start())
		return (-1);
d765 2
d852 6
@


1.7
log
@* fix renaming glitch
* convert to bitfield
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/cpio.c,v 1.6 2005/11/23 22:37:09 tg Exp $ */
d51 1
a51 1
__RCSID("$MirOS: src/bin/pax/cpio.c,v 1.6 2005/11/23 22:37:09 tg Exp $");
d380 9
d405 3
d420 14
d475 1
a475 1
	    ul_asc((u_long)arcn->sb.st_dev, hd->c_dev, sizeof(hd->c_dev),
d477 1
a477 1
	    ul_asc((u_long)arcn->sb.st_ino, hd->c_ino, sizeof(hd->c_ino),
d481 1
a481 1
	    ul_asc((u_long)arcn->sb.st_uid, hd->c_uid, sizeof(hd->c_uid),
d483 1
a483 1
	    ul_asc((u_long)arcn->sb.st_gid, hd->c_gid, sizeof(hd->c_gid),
d489 1
a489 1
	    ul_asc((u_long)arcn->sb.st_mtime,hd->c_mtime,sizeof(hd->c_mtime),
d510 4
d788 2
@


1.6
log
@rename v4norm into anonarch
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/cpio.c,v 1.5 2005/11/18 13:58:47 tg Exp $ */
d51 1
a51 1
__RCSID("$MirOS: src/bin/pax/cpio.c,v 1.5 2005/11/18 13:58:47 tg Exp $");
d57 1
a57 1
/* Normalise archives? 1=uid/gid, 2=total */
d59 4
d690 1
a690 1
	anonarch = 1;
d697 1
a697 1
anonarch_stwr(void)
d699 1
a699 1
	anonarch = 2;
d752 6
a757 6
	t_uid   = (anonarch < 1) ? (u_long)arcn->sb.st_uid : 0UL;
	t_gid   = (anonarch < 1) ? (u_long)arcn->sb.st_gid : 0UL;
	t_mtime = (anonarch < 2) ? (u_long)arcn->sb.st_mtime : 0UL;
	t_ino   = (anonarch < 1) ? arcn->sb.st_ino : chk_flnk(arcn);
	t_major = (anonarch < 2) ? (u_long)MAJOR(arcn->sb.st_dev) : 0UL;
	t_minor = (anonarch < 2) ? (u_long)MINOR(arcn->sb.st_dev) : 0UL;
d762 2
@


1.5
log
@For v4norm (but not v4root), also anonymise the device major:minor of
the device the file to archive resides/resided on (set to zero)

* does not affect the device major:minor of the file to archive itself
  (only nonzero if the file to archive is a character/block special)
* this works because of my inode serialisation algorithm, which
  uses the original device major:minor and the original inode as
  index into its database, but assigns continuous new-inode numbers
  to them no matter which device they are on

Proof:

e/x/161824 M/interix.diff C/me/x/161824l? | /cpio -oHv4norm >x                <
debug: inode    27820 ->   3, dev       41:      43, file <C/me/x/161824>
debug: inode    27820 ->   4, dev       41:      4D, file <M/interix.diff>
debug: inode    27820 ->   3, dev       41:      43, file <C/me/x/161824l2>
debug: inode    27820 ->   3, dev       41:      43, file <C/me/x/161824l3>
debug: inode        0 ->   5, dev        0:       0, file <TRAILER!!!>
/161824l? | xargs ls -li                                                      <
161824 -rw-r--r--  3 sysop      None          0 Nov 18 13:38 C/me/x/161824
161824 -rw-r--r--  3 sysop      None          0 Nov 18 13:38 C/me/x/161824l2
161824 -rw-r--r--  3 sysop      None          0 Nov 18 13:38 C/me/x/161824l3
161824 -rwxrwxrwx  1 +Everyone  +Everyone  6039 Nov 16 14:46 M/interix.diff

If a file exists twice in the source tree, it's archived twice unless
it's a hard link - in the new v4norm format, it should not matter if
they are on separate or same filesystems for the emission of a new
inode number. If they have been hardlinks before, it does of course
matter, but as far as I am concerned, mpczar does not need to deal
with these, as CVS checkouts aren't hardlinked anyway (and we don't
archive the CVS/ subdirectories).
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/cpio.c,v 1.4 2005/11/18 13:40:43 tg Exp $ */
d51 1
a51 1
__RCSID("$MirOS: src/bin/pax/cpio.c,v 1.4 2005/11/18 13:40:43 tg Exp $");
d57 2
a58 2
/* Normalise SV4CRC archives? 1=uid/gid, 2=total */
static int v4norm = 0;
d686 1
a686 1
	v4norm = 1;
d693 1
a693 1
v4norm_stwr(void)
d695 1
a695 1
	v4norm = 2;
d748 6
a753 6
	t_uid   = (v4norm < 1) ? (u_long)arcn->sb.st_uid : 0UL;
	t_gid   = (v4norm < 1) ? (u_long)arcn->sb.st_gid : 0UL;
	t_mtime = (v4norm < 2) ? (u_long)arcn->sb.st_mtime : 0UL;
	t_ino   = (v4norm < 1) ? arcn->sb.st_ino : chk_flnk(arcn);
	t_major = (v4norm < 2) ? (u_long)MAJOR(arcn->sb.st_dev) : 0UL;
	t_minor = (v4norm < 2) ? (u_long)MINOR(arcn->sb.st_dev) : 0UL;
@


1.4
log
@* improve comments about c_maj:c_min vs c_rmaj:c_rmin
* spacing
* fix sizeof() mismatch
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/cpio.c,v 1.3 2005/11/16 14:27:28 tg Exp $ */
d51 1
a51 1
__RCSID("$MirOS: src/bin/pax/cpio.c,v 1.3 2005/11/16 14:27:28 tg Exp $");
d717 1
a717 1
	u_long t_uid, t_gid, t_mtime;
d752 2
d817 2
a818 4
	    ul_asc((u_long)MAJOR(arcn->sb.st_dev), hd->c_maj,
		sizeof(hd->c_maj), HEX) ||
	    ul_asc((u_long)MINOR(arcn->sb.st_dev), hd->c_min,
		sizeof(hd->c_min), HEX) ||
@


1.3
log
@In my new formats (v4norm and v4root), do *not* store the file contents
of files which are hard links twice - instead, hard links' file sizes
are set to 0. This goes along with forward link table creation, and
sort of clones the chk_lnk behaviour for tar/ustar but differently
(including inode number anonymisation).

This does not matter because on extraction, no file is written, instead
a hard link is created. If hard links are on different filesystems during
extraction, an error is generated and no file is being written - same as
with regular cpio/sv4cpio/sv4crc.

This change does not affect the other file formats, because I do not
have access to the SV4CPIO and POSIX CPIO specifications, respectively
cannot easily see whether it breaks the specs.

WFM.
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/cpio.c,v 1.2 2005/11/16 13:58:38 tg Exp $ */
d51 1
a51 1
__RCSID("$MirOS: src/bin/pax/cpio.c,v 1.2 2005/11/16 13:58:38 tg Exp $");
d607 2
a608 2
	devmajor = (dev_t)asc_ul(hd->c_rmaj, sizeof(hd->c_maj), HEX);
	devminor = (dev_t)asc_ul(hd->c_rmin, sizeof(hd->c_min), HEX);
d814 10
a823 8
	    ul_asc((u_long)MAJOR(arcn->sb.st_dev),hd->c_maj, sizeof(hd->c_maj),
		HEX) ||
	    ul_asc((u_long)MINOR(arcn->sb.st_dev),hd->c_min, sizeof(hd->c_min),
		HEX) ||
	    ul_asc((u_long)MAJOR(arcn->sb.st_rdev),hd->c_rmaj,sizeof(hd->c_maj),
		HEX) ||
	    ul_asc((u_long)MINOR(arcn->sb.st_rdev),hd->c_rmin,sizeof(hd->c_min),
		HEX) ||
@


1.2
log
@* cpio.1: Document sv4crc format for creation and extraction
* cpio.1, pax.1: Document new v4norm and v4root formats for creation only
  (to extract these, the sv4crc driver is being used)
* cpio.c: Add initialisation routines for v4norm and v4root formats
* cpio.c (vcpio_wr): Write c_ino, c_uid, c_gid and c_mtime through a
  layer of indirection, depending on the state of (v4norm) setting them
  to the stat buf value, zero (uid, gid, mtime) or the result of a table
  lookup (inode)
* extern.h: expose new v4norm_stwr, v4root_stwr (cpio.c) and
  flnk_start, chk_flnk (table.c) functions
* options.c: add entries for new formats v4norm, v4root
* tables.c: mirror lnk_start, chk_lnk functions to build up a hard link
  table on archive creation as well, anonymising _all_ inodes stored

(inodes start at 3)
@
text
@d1 1
a1 1
/**	$MirOS$ */
d51 1
a51 1
__RCSID("$MirOS$");
d748 9
a798 9
	t_uid   = (v4norm < 1) ? (u_long)arcn->sb.st_uid : 0UL;
	t_gid   = (v4norm < 1) ? (u_long)arcn->sb.st_gid : 0UL;
	t_mtime = (v4norm < 2) ? (u_long)arcn->sb.st_mtime : 0UL;
	t_ino   = (v4norm < 1) ? arcn->sb.st_ino : chk_flnk(arcn);
	if (t_ino == -1) {
		paxwarn(1, "Invalid inode number for file %s", arcn->org_name);
		return (1);
	}

d843 8
@


1.1
log
@Initial revision
@
text
@d1 1
d6 1
d39 1
a39 9
#ifndef lint
#if 0
static const char sccsid[] = "@@(#)cpio.c	8.1 (Berkeley) 5/31/93";
#else
static const char rcsid[] = "$OpenBSD: cpio.c,v 1.17 2004/04/16 22:50:23 deraadt Exp $";
#endif
#endif /* not lint */

#include <sys/types.h>
a41 1
#include <sys/param.h>
d50 3
d57 3
d683 18
d717 3
d790 9
d802 1
a802 1
	if (ul_asc((u_long)arcn->sb.st_ino, hd->c_ino, sizeof(hd->c_ino),
d806 1
a806 1
	    ul_asc((u_long)arcn->sb.st_uid, hd->c_uid, sizeof(hd->c_uid),
d808 1
a808 1
	    ul_asc((u_long)arcn->sb.st_gid, hd->c_gid, sizeof(hd->c_gid),
d810 1
a810 1
	    ul_asc((u_long)arcn->sb.st_mtime, hd->c_mtime, sizeof(hd->c_mtime),
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@import up-to-date pax from OpenBSD 5.1-current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpio.c,v 1.19 2009/10/27 23:59:22 deraadt Exp $	*/
d37 8
d155 1
a155 1
 * cpio_endwr()
@


1.1.1.3
log
@pull newer paxtar from OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: cpio.c,v 1.27 2015/03/19 05:14:24 guenther Exp $	*/
d40 1
a40 1
#include <limits.h>
d170 1
a170 1
 * rd_nm()
d214 2
a215 1
		paxwarn(1, "Cpio link name length is invalid: %llu",
d217 4
a277 1
	u_quad_t val;
d300 7
a306 7
	val = asc_uqd(hd->c_mtime, sizeof(hd->c_mtime), OCT);
	if ((time_t)val < 0 || (time_t)val != val)
		arcn->sb.st_mtime = INT_MAX;			/* XXX 2038 */
	else
		arcn->sb.st_mtime = val;
	arcn->sb.st_mtim.tv_nsec = 0;
	arcn->sb.st_ctim = arcn->sb.st_atim = arcn->sb.st_mtim;
d309 1
d404 4
d410 1
d452 2
a453 2
	    uqd_asc(arcn->sb.st_mtime < 0 ? 0 : arcn->sb.st_mtime, hd->c_mtime,
		sizeof(hd->c_mtime), OCT) ||
d470 2
a471 1
	if (PAX_IS_REG(arcn->type) || (arcn->type == PAX_HRG))
d587 5
a591 2
	arcn->sb.st_mtim.tv_nsec = 0;
	arcn->sb.st_ctim = arcn->sb.st_atim = arcn->sb.st_mtim;
d594 1
d729 4
d735 1
d773 2
a774 2
	    ul_asc(arcn->sb.st_mtime < 0 ? 0 : arcn->sb.st_mtime, hd->c_mtime,
		sizeof(hd->c_mtime), HEX) ||
d801 2
a802 1
	if (PAX_IS_REG(arcn->type) || (arcn->type == PAX_HRG))
d918 1
a918 2
	arcn->sb.st_mtim.tv_nsec = 0;
	arcn->sb.st_ctim = arcn->sb.st_atim = arcn->sb.st_mtim;
d1087 8
a1094 13
	if (arcn->sb.st_mtime > 0) {
		hd->h_mtime_1[0] = CHR_WR_0(arcn->sb.st_mtime);
		hd->h_mtime_1[1] = CHR_WR_1(arcn->sb.st_mtime);
		hd->h_mtime_2[0] = CHR_WR_2(arcn->sb.st_mtime);
		hd->h_mtime_2[1] = CHR_WR_3(arcn->sb.st_mtime);
		t_timet = (time_t)SHRT_EXT(hd->h_mtime_1);
		t_timet =  t_timet << 16 | (time_t)SHRT_EXT(hd->h_mtime_2);
		if (arcn->sb.st_mtime != t_timet)
			goto out;
	} else {
		hd->h_mtime_1[0] = hd->h_mtime_1[1] = 0;
		hd->h_mtime_2[0] = hd->h_mtime_2[1] = 0;
	}
d1114 2
a1115 1
	if (PAX_IS_REG(arcn->type) || (arcn->type == PAX_HRG))
@


1.1.1.4
log
@revert the import; we’ll just backport the CVE fixes, for now ☹
@
text
@d1 1
a1 1
/*	$OpenBSD: cpio.c,v 1.19 2009/10/27 23:59:22 deraadt Exp $	*/
d40 1
a40 1
#include <sys/param.h>
d170 1
a170 1
 * rd_nam()
d214 1
a214 2
#		ifdef LONG_OFF_T
		paxwarn(1, "Cpio link name length is invalid: %lu",
a215 4
#		else
		paxwarn(1, "Cpio link name length is invalid: %qu",
		    arcn->sb.st_size);
#		endif
d273 1
d296 7
a302 7
	arcn->sb.st_mtime = (time_t)asc_ul(hd->c_mtime, sizeof(hd->c_mtime),
	    OCT);
	arcn->sb.st_ctime = arcn->sb.st_atime = arcn->sb.st_mtime;
#	ifdef LONG_OFF_T
	arcn->sb.st_size = (off_t)asc_ul(hd->c_filesize,sizeof(hd->c_filesize),
	    OCT);
#	else
a304 1
#	endif
a398 4
#		ifdef LONG_OFF_T
		if (ul_asc((u_long)arcn->sb.st_size, hd->c_filesize,
		    sizeof(hd->c_filesize), OCT)) {
#		else
a400 1
#		endif
d442 2
a443 2
	    ul_asc((u_long)arcn->sb.st_mtime,hd->c_mtime,sizeof(hd->c_mtime),
		OCT) ||
d460 1
a460 2
	if ((arcn->type == PAX_CTG) || (arcn->type == PAX_REG) ||
	    (arcn->type == PAX_HRG))
d576 2
a577 5
	arcn->sb.st_ctime = arcn->sb.st_atime = arcn->sb.st_mtime;
#	ifdef LONG_OFF_T
	arcn->sb.st_size = (off_t)asc_ul(hd->c_filesize,
	    sizeof(hd->c_filesize), HEX);
#	else
a579 1
#	endif
a713 4
#		ifdef LONG_OFF_T
		if (ul_asc((u_long)arcn->sb.st_size, hd->c_filesize,
		    sizeof(hd->c_filesize), HEX)) {
#		else
a715 1
#		endif
d753 2
a754 2
	    ul_asc((u_long)arcn->sb.st_mtime, hd->c_mtime, sizeof(hd->c_mtime),
		HEX) ||
d781 1
a781 2
	if ((arcn->type == PAX_CTG) || (arcn->type == PAX_REG) ||
	    (arcn->type == PAX_HRG))
d897 2
a898 1
	arcn->sb.st_ctime = arcn->sb.st_atime = arcn->sb.st_mtime;
d1067 13
a1079 8
	hd->h_mtime_1[0] = CHR_WR_0(arcn->sb.st_mtime);
	hd->h_mtime_1[1] = CHR_WR_1(arcn->sb.st_mtime);
	hd->h_mtime_2[0] = CHR_WR_2(arcn->sb.st_mtime);
	hd->h_mtime_2[1] = CHR_WR_3(arcn->sb.st_mtime);
	t_timet = (time_t)(SHRT_EXT(hd->h_mtime_1));
	t_timet =  (t_timet << 16) | ((time_t)(SHRT_EXT(hd->h_mtime_2)));
	if (arcn->sb.st_mtime != t_timet)
		goto out;
d1099 1
a1099 2
	if ((arcn->type == PAX_CTG) || (arcn->type == PAX_REG) ||
	    (arcn->type == PAX_HRG))
@


1.1.1.5
log
@merge what OpenBSD did between our last cherry-pick and today minus one commit

(“Use the new libc uid_from_user() and gid_from_group() instead of
  the pax-specific functions in cache.c” is ignored, for now)
@
text
@d1 1
a1 1
/*	$OpenBSD: cpio.c,v 1.33 2017/09/16 07:42:34 otto Exp $	*/
d182 1
a182 1
	if ((nsz == 0) || ((size_t)nsz > sizeof(arcn->name))) {
d212 2
a213 2
	if ((arcn->sb.st_size <= 0) ||
	    (arcn->sb.st_size >= (off_t)sizeof(arcn->ln_name))) {
d215 1
a215 1
		paxwarn(1, "Cpio link name length is invalid: %ld",
d218 1
a218 1
		paxwarn(1, "Cpio link name length is invalid: %lld",
d260 1
a260 1
	if ((size < (int)sizeof(HD_CPIO)) ||
d511 1
a511 1
	if ((size < (int)sizeof(HD_VCPIO)) ||
d528 1
a528 1
	if ((size < (int)sizeof(HD_VCPIO)) ||
d845 1
a845 1
	if (size < (int)sizeof(HD_BCPIO))
@


1.1.1.6
log
@Import latest OpenBSD paxtar, unmodified, into vendor branch
@
text
@d38 1
d40 1
a40 1
#include <limits.h>
d170 1
a170 1
 * rd_nm()
d214 4
d220 1
a277 1
	unsigned long long val;
d291 1
a291 1
	arcn->pad = 0;
d300 8
a307 8
	val = asc_ull(hd->c_mtime, sizeof(hd->c_mtime), OCT);
	if (val > MAX_TIME_T)
		arcn->sb.st_mtime = INT_MAX;			/* XXX 2038 */
	else
		arcn->sb.st_mtime = val;
	arcn->sb.st_mtim.tv_nsec = 0;
	arcn->sb.st_ctim = arcn->sb.st_atim = arcn->sb.st_mtim;
	arcn->sb.st_size = (off_t)asc_ull(hd->c_filesize,sizeof(hd->c_filesize),
d309 1
d353 1
a353 1
	return sizeof(HD_CPIO) + sizeof(TRAILER);
d388 1
a388 1
	if (map_dev(arcn, CPIO_MASK, CPIO_MASK) < 0)
d391 1
a391 1
	arcn->pad = 0;
d404 2
a405 1
		if (ull_asc(arcn->sb.st_size, hd->c_filesize,
d407 4
d420 1
a420 1
		if (ul_asc(arcn->ln_nlen, hd->c_filesize,
d428 2
a429 1
		if (ul_asc(0, hd->c_filesize, sizeof(hd->c_filesize), OCT))
d437 18
a454 11
	if (ul_asc(MAGIC, hd->c_magic, sizeof(hd->c_magic), OCT) ||
	    ul_asc(arcn->sb.st_dev, hd->c_dev, sizeof(hd->c_dev), OCT) ||
	    ul_asc(arcn->sb.st_ino, hd->c_ino, sizeof(hd->c_ino), OCT) ||
	    ul_asc(arcn->sb.st_mode, hd->c_mode, sizeof(hd->c_mode), OCT) ||
	    ul_asc(arcn->sb.st_uid, hd->c_uid, sizeof(hd->c_uid), OCT) ||
	    ul_asc(arcn->sb.st_gid, hd->c_gid, sizeof(hd->c_gid), OCT) ||
	    ul_asc(arcn->sb.st_nlink, hd->c_nlink, sizeof(hd->c_nlink), OCT) ||
	    ul_asc(arcn->sb.st_rdev, hd->c_rdev, sizeof(hd->c_rdev), OCT) ||
	    ull_asc(arcn->sb.st_mtime < 0 ? 0 : arcn->sb.st_mtime, hd->c_mtime,
		sizeof(hd->c_mtime), OCT) ||
	    ul_asc(nsz, hd->c_namesize, sizeof(hd->c_namesize), OCT))
d470 2
a471 1
	if (PAX_IS_REG(arcn->type) || (arcn->type == PAX_HRG))
d577 1
a577 1
	arcn->pad = 0;
d587 6
a592 3
	arcn->sb.st_mtim.tv_nsec = 0;
	arcn->sb.st_ctim = arcn->sb.st_atim = arcn->sb.st_mtim;
	arcn->sb.st_size = (off_t)asc_ull(hd->c_filesize,
d594 1
d618 1
a618 1
	if (rd_skip(VCPIO_PAD(sizeof(HD_VCPIO) + nsz)) < 0)
d639 1
a639 1
	    (rd_skip(VCPIO_PAD(arcn->sb.st_size)) < 0))
d658 2
a659 2
	return sizeof(HD_VCPIO) + sizeof(TRAILER) +
		(VCPIO_PAD(sizeof(HD_VCPIO) + sizeof(TRAILER)));
d696 1
a696 1
	if (map_dev(arcn, VCPIO_MASK, VCPIO_MASK) < 0)
d708 4
a711 2
		if (ul_asc(VCMAGIC, hd->c_magic, sizeof(hd->c_magic), OCT) ||
		    ul_asc(arcn->crc,hd->c_chksum,sizeof(hd->c_chksum), HEX))
d714 3
a716 2
		if (ul_asc(VMAGIC, hd->c_magic, sizeof(hd->c_magic), OCT) ||
		    ul_asc(0, hd->c_chksum, sizeof(hd->c_chksum),HEX))
d729 2
a730 1
		if (ull_asc(arcn->sb.st_size, hd->c_filesize,
d732 4
d746 2
a747 2
		arcn->pad = 0;
		if (ul_asc(arcn->ln_nlen, hd->c_filesize,
d755 3
a757 2
		arcn->pad = 0;
		if (ul_asc(0, hd->c_filesize, sizeof(hd->c_filesize), HEX))
d765 21
a785 12
	if (ul_asc(arcn->sb.st_ino, hd->c_ino, sizeof(hd->c_ino), HEX) ||
	    ul_asc(arcn->sb.st_mode, hd->c_mode, sizeof(hd->c_mode), HEX) ||
	    ul_asc(arcn->sb.st_uid, hd->c_uid, sizeof(hd->c_uid), HEX) ||
	    ul_asc(arcn->sb.st_gid, hd->c_gid, sizeof(hd->c_gid), HEX) ||
	    ul_asc(arcn->sb.st_mtime < 0 ? 0 : arcn->sb.st_mtime, hd->c_mtime,
		sizeof(hd->c_mtime), HEX) ||
	    ul_asc(arcn->sb.st_nlink, hd->c_nlink, sizeof(hd->c_nlink), HEX) ||
	    ul_asc(MAJOR(arcn->sb.st_dev),hd->c_maj, sizeof(hd->c_maj), HEX) ||
	    ul_asc(MINOR(arcn->sb.st_dev),hd->c_min, sizeof(hd->c_min), HEX) ||
	    ul_asc(MAJOR(arcn->sb.st_rdev),hd->c_rmaj,sizeof(hd->c_maj), HEX) ||
	    ul_asc(MINOR(arcn->sb.st_rdev),hd->c_rmin,sizeof(hd->c_min), HEX) ||
	    ul_asc(nsz, hd->c_namesize, sizeof(hd->c_namesize), HEX))
d793 1
a793 1
	    (wr_skip(VCPIO_PAD(sizeof(HD_VCPIO) + nsz)) < 0)) {
d801 2
a802 1
	if (PAX_IS_REG(arcn->type) || (arcn->type == PAX_HRG))
d815 1
a815 1
	    (wr_skip(VCPIO_PAD(arcn->ln_nlen)) < 0)) {
d882 1
a882 1
	arcn->pad = 0;
d918 1
a918 2
	arcn->sb.st_mtim.tv_nsec = 0;
	arcn->sb.st_ctim = arcn->sb.st_atim = arcn->sb.st_mtim;
d933 1
a933 1
	if (rd_skip(BCPIO_PAD(sizeof(HD_BCPIO) + nsz)) < 0)
d951 1
a951 1
	    (rd_skip(BCPIO_PAD(arcn->sb.st_size)) < 0))
d970 2
a971 2
	return sizeof(HD_BCPIO) + sizeof(TRAILER) +
		(BCPIO_PAD(sizeof(HD_BCPIO) + sizeof(TRAILER)));
d999 1
a999 1
	if (map_dev(arcn, BCPIO_MASK, BCPIO_MASK) < 0)
d1032 1
a1032 1
		arcn->pad = 0;
d1046 1
a1046 1
		arcn->pad = 0;
d1087 8
a1094 13
	if (arcn->sb.st_mtime > 0) {
		hd->h_mtime_1[0] = CHR_WR_0(arcn->sb.st_mtime);
		hd->h_mtime_1[1] = CHR_WR_1(arcn->sb.st_mtime);
		hd->h_mtime_2[0] = CHR_WR_2(arcn->sb.st_mtime);
		hd->h_mtime_2[1] = CHR_WR_3(arcn->sb.st_mtime);
		t_timet = (time_t)SHRT_EXT(hd->h_mtime_1);
		t_timet =  t_timet << 16 | (time_t)SHRT_EXT(hd->h_mtime_2);
		if (arcn->sb.st_mtime != t_timet)
			goto out;
	} else {
		hd->h_mtime_1[0] = hd->h_mtime_1[1] = 0;
		hd->h_mtime_2[0] = hd->h_mtime_2[1] = 0;
	}
d1106 1
a1106 1
	    (wr_skip(BCPIO_PAD(sizeof(HD_BCPIO) + nsz)) < 0)) {
d1114 2
a1115 1
	if (PAX_IS_REG(arcn->type) || (arcn->type == PAX_HRG))
d1128 1
a1128 1
	    (wr_skip(BCPIO_PAD(arcn->ln_nlen)) < 0)) {
@


1.1.1.6.2.1
log
@a little KNF: sort the includes
@
text
@d40 1
d42 1
a43 3
#include <string.h>
#include <unistd.h>

@


1.1.1.6.2.2
log
@extremely rudimentary conversion to mirtoconf, doesn’t even build yet
@
text
@a42 3
#if HAVE_STRINGS_H
#include <strings.h>
#endif
@


1.1.1.6.2.3
log
@make inroads on portability
@
text
@a303 1
#if HAVE_ST_MTIM
a304 4
#elif HAVE_ST_MTIMENSEC
	arcn->sb.st_mtimensec = 0;
#endif
#if HAVE_ST_MTIM
a305 6
#else
	arcn->sb.st_ctime = arcn->sb.st_atime = arcn->sb.st_mtime;
#if HAVE_ST_MTIMENSEC
	arcn->sb.st_ctimensec = arcn->sb.st_atimensec = arcn->sb.st_mtimensec;
#endif
#endif
a570 1
#if HAVE_ST_MTIM
a571 4
#elif HAVE_ST_MTIMENSEC
	arcn->sb.st_mtimensec = 0;
#endif
#if HAVE_ST_MTIM
a572 6
#else
	arcn->sb.st_ctime = arcn->sb.st_atime = arcn->sb.st_mtime;
#if HAVE_ST_MTIMENSEC
	arcn->sb.st_ctimensec = arcn->sb.st_atimensec = arcn->sb.st_mtimensec;
#endif
#endif
a878 1
#if HAVE_ST_MTIM
a879 4
#elif HAVE_ST_MTIMENSEC
	arcn->sb.st_mtimensec = 0;
#endif
#if HAVE_ST_MTIM
a880 6
#else
	arcn->sb.st_ctime = arcn->sb.st_atime = arcn->sb.st_mtime;
#if HAVE_ST_MTIMENSEC
	arcn->sb.st_ctimensec = arcn->sb.st_atimensec = arcn->sb.st_mtimensec;
#endif
#endif
@


1.1.1.6.2.4
log
@do the ‘c’s
@
text
@a4 2
 * Copyright (c) 2005, 2012, 2016
 *	mirabilos <m@@mirbsd.org>
a59 1
#ifndef SMALL
a60 1
#endif
d90 1
a90 2
cpio_trail(ARCHD *arcn, char *notused MKSH_A_UNUSED,
    int notused2 MKSH_A_UNUSED, int *notused3 MKSH_A_UNUSED)
d186 1
a186 1
		paxwarn(1, "cpio file name length %d is out of range", nsz);
d195 1
a195 1
		paxwarn(1, "cpio file name in header is corrupted");
d217 1
a217 1
		paxwarn(1, "cpio link name length is invalid: %lld",
d227 1
a227 1
		paxwarn(1, "cpio link name read error");
d237 1
a237 1
		paxwarn(1, "cpio link name is corrupt");
d362 1
a362 1
	return ((off_t)(sizeof(HD_CPIO) + sizeof(TRAILER)));
d373 1
a373 1
cpio_stwr(int is_app MKSH_A_UNUSED)
d375 1
a375 11
	if ((anonarch & ANON_INODES) && flnk_start())
		return (-1);
	return (dev_start());
}

int
dist_stwr(int is_app)
{
	anonarch &= ANON_DEBUG | ANON_VERBOSE;
	anonarch |= ANON_UIDGID | ANON_INODES | ANON_HARDLINKS;
	return (cpio_stwr(is_app));
a392 5
/*XXX TODO: u_long ⇒ unsigned long */
	u_long t_uid, t_gid, t_mtime, t_dev;
	ino_t t_ino;

	anonarch_init();
a405 16
	t_uid   = (anonarch & ANON_UIDGID) ? 0UL : (u_long)arcn->sb.st_uid;
	t_gid   = (anonarch & ANON_UIDGID) ? 0UL : (u_long)arcn->sb.st_gid;
	t_mtime = (anonarch & ANON_MTIME)  ? 0UL : (u_long)arcn->sb.st_mtime;
	t_ino   = (anonarch & ANON_INODES) ? (ino_t)chk_flnk(arcn) :
	    arcn->sb.st_ino;
	t_dev   = (anonarch & ANON_INODES) ? 0UL : (u_long)arcn->sb.st_dev;

	if (!cpio_trail(arcn, NULL, 0, NULL))
		t_ino = 0UL;
	if (t_ino == (ino_t)-1) {
		paxwarn(1, "Invalid inode number for file %s", arcn->org_name);
		return (1);
	}
	if (!(anonarch & ANON_HARDLINKS))
		arcn->type &= ~PAX_LINKOR;

a436 6
	if (anonarch & ANON_DEBUG)
		paxwarn(0, "writing dev %lX inode %10lX mode %8lo user %ld:%ld"
		    "\n\tnlink %3ld mtime %08lX name '%s'", t_dev,
		    (u_long)t_ino, (u_long)arcn->sb.st_mode, t_uid, t_gid,
		    (u_long)arcn->sb.st_nlink, t_mtime, arcn->name);

d441 2
a442 2
	    ul_asc(t_dev, hd->c_dev, sizeof(hd->c_dev), OCT) ||
	    ul_asc((u_long)t_ino, hd->c_ino, sizeof(hd->c_ino), OCT) ||
d444 2
a445 2
	    ul_asc(t_uid, hd->c_uid, sizeof(hd->c_uid), OCT) ||
	    ul_asc(t_gid, hd->c_gid, sizeof(hd->c_gid), OCT) ||
d448 2
a449 1
	    ull_asc(t_mtime < 0 ? 0ULL : (unsigned long long)t_mtime, hd->c_mtime, sizeof(hd->c_mtime), OCT) ||
d467 1
a467 5
		return (0);
	if (arcn->type & PAX_LINKOR) {
		arcn->type &= ~PAX_LINKOR;
		return (1);
	}
d469 1
a469 1
		return (1);
d481 1
a481 1
 out:
d485 1
a485 1
	paxwarn(1, "cpio header field is too small to store file %s",
d602 2
a603 2
	devmajor = (dev_t)asc_ul(hd->c_rmaj, sizeof(hd->c_rmaj), HEX);
	devminor = (dev_t)asc_ul(hd->c_rmin, sizeof(hd->c_rmin), HEX);
d672 1
a672 1
crc_stwr(int is_app MKSH_A_UNUSED)
a674 2
	if ((anonarch & ANON_INODES) && flnk_start())
		return (-1);
a677 16
int
v4root_stwr(int is_app)
{
	anonarch &= ANON_DEBUG | ANON_VERBOSE;
	anonarch |= ANON_UIDGID | ANON_INODES;
	return (crc_stwr(is_app));
}

int
v4norm_stwr(int is_app)
{
	anonarch &= ANON_DEBUG | ANON_VERBOSE;
	anonarch |= ANON_UIDGID | ANON_INODES | ANON_MTIME | ANON_HARDLINKS;
	return (crc_stwr(is_app));
}

a692 4
	u_long t_uid, t_gid, t_mtime, t_major, t_minor;
	ino_t t_ino;

	anonarch_init();
a718 17
	t_uid   = (anonarch & ANON_UIDGID) ? 0UL : (u_long)arcn->sb.st_uid;
	t_gid   = (anonarch & ANON_UIDGID) ? 0UL : (u_long)arcn->sb.st_gid;
	t_mtime = (anonarch & ANON_MTIME)  ? 0UL : (u_long)arcn->sb.st_mtime;
	t_ino   = (anonarch & ANON_INODES) ? (ino_t)chk_flnk(arcn) :
	    arcn->sb.st_ino;
	t_major = (anonarch & ANON_INODES) ? 0UL : (u_long)MAJOR(arcn->sb.st_dev);
	t_minor = (anonarch & ANON_INODES) ? 0UL : (u_long)MINOR(arcn->sb.st_dev);

	if (!cpio_trail(arcn, NULL, 0, NULL))
		t_ino = 0UL;
	if (t_ino == (ino_t)-1) {
		paxwarn(1, "Invalid inode number for file %s", arcn->org_name);
		return (1);
	}
	if (!(anonarch & ANON_HARDLINKS))
		arcn->type &= ~PAX_LINKOR;

a754 6
	if (anonarch & ANON_DEBUG)
		paxwarn(0, "writing dev %lX:%lx inode %10lX mode %8lo user %ld:%ld"
		    "\n\tnlink %3ld mtime %08lX name '%s'", t_major, t_minor,
		    (u_long)t_ino, (u_long)arcn->sb.st_mode, t_uid, t_gid,
		    (u_long)arcn->sb.st_nlink, t_mtime, arcn->name);

d758 1
a758 1
	if (ul_asc(t_ino, hd->c_ino, sizeof(hd->c_ino), HEX) ||
d760 3
a762 3
	    ul_asc(t_uid, hd->c_uid, sizeof(hd->c_uid), HEX) ||
	    ul_asc(t_gid, hd->c_gid, sizeof(hd->c_gid), HEX) ||
	    ul_asc(t_mtime < 0 ? 0 : t_mtime, hd->c_mtime,
d765 4
a768 6
	    /* device major:minor of the device the file resides on */
	    ul_asc(t_major, hd->c_maj, sizeof(hd->c_maj), HEX) ||
	    ul_asc(t_minor, hd->c_min, sizeof(hd->c_min), HEX) ||
	    /* device major:minor of the file if it's a device node */
	    ul_asc(MAJOR(arcn->sb.st_rdev), hd->c_rmaj, sizeof(hd->c_rmaj), HEX) ||
	    ul_asc(MINOR(arcn->sb.st_rdev), hd->c_rmin, sizeof(hd->c_rmin), HEX) ||
a788 8
	 * if we are a detected hard link, we're done too, but no data written
	 */
	if (arcn->type & PAX_LINKOR) {
		arcn->type &= ~PAX_LINKOR;
		return (1);
	}

	/*
d805 1
a805 1
 out:
d809 1
a809 1
	paxwarn(1, "sv4cpio header field is too small for file %s", arcn->org_name);
a812 1
#ifndef SMALL
d1133 1
a1133 1
 out:
d1137 1
a1137 1
	paxwarn(1, "bcpio header field is too small for file %s", arcn->org_name);
a1139 1
#endif
@


1.1.1.6.2.5
log
@another macro to fight this Irrsinn
@
text
@a313 1
	/* inline st_timecpy variant, can’t use as-is */
@


1.1.1.6.2.6
log
@tar, and make ANONARCH_DEBUG ifndef SMALL
@
text
@a473 1
#ifndef SMALL
a478 1
#endif
a839 1
#ifndef SMALL
a844 1
#endif
@


1.1.1.6.2.7
log
@drop a few TODO comments
@
text
@d409 2
a410 1
	u_long t_uid, t_gid, t_dev;
a411 1
	time_t t_mtime;
d429 1
a429 1
	t_mtime = (anonarch & ANON_MTIME)  ? 0   : arcn->sb.st_mtime;
d477 1
a477 1
		    "\n\tnlink %3ld mtime %08llX name '%s'", t_dev,
d479 1
a479 2
		    (u_long)arcn->sb.st_nlink, (unsigned long long)t_mtime,
		    arcn->name);
@


1.1.1.6.2.8
log
@various bugfixes and a system header issue workaround in Makefile
@
text
@d760 1
a760 1
	u_long t_uid, t_gid, t_major, t_minor;
a761 1
	time_t t_mtime;
d792 1
a792 1
	t_mtime = (anonarch & ANON_MTIME)  ? 0   : arcn->sb.st_mtime;
d846 1
a846 1
		    "\n\tnlink %3ld mtime %08llX name '%s'", t_major, t_minor,
d848 1
a848 2
		    (u_long)arcn->sb.st_nlink, (unsigned long long)t_mtime,
		    arcn->name);
@


