head	1.17;
access;
symbols
	paxmirabilis-20190825:1.17
	paxmirabilis-20190224:1.17
	paxmirabilis-20190210:1.17
	npax:1.1.1.10.0.2
	cvs-20181212:1.1.1.10
	paxmirabilis-20171021:1.12
	paxmirabilis-20161104:1.11
	paxmirabilis-20161031:1.10
	paxmirabilis-20161025:1.9
	paxmirabilis-20160306:1.8
	cvs-201603041945:1.1.1.5
	paxmirabilis-20151013:1.6
	paxmirabilis-20140703:1.6
	paxmirabilis-20120606:1.6
	paxmirabilis-20120605:1.6
	cvs-201206051745:1.1.1.4
	paxmirabilis-20120520:1.5
	paxmirabilis-20120216:1.4
	paxmirabilis-20120212:1.4
	cvs-201202112230:1.1.1.4
	paxmirabilis-20110817:1.2
	MIRBSD_10:1.2.0.2
	MIRBSD_10_BASE:1.2
	cvs-200710231945:1.1.1.3
	cvs-200606232242:1.1.1.3
	MIRBSD_9_BASE:1.1.1.3
	MIRBSD_8:1.1.1.2.0.2
	MIRBSD_8_BASE:1.1.1.2
	cvs-200507211800:1.1.1.2
	cvs-200504291700:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2018.12.13.07.09.11;	author tg;	state Exp;
branches;
next	1.16;
commitid	1005C1205A44B32AFA4;

1.16
date	2018.12.12.18.08.45;	author tg;	state Exp;
branches;
next	1.15;
commitid	1005C114EA81986F5EC;

1.15
date	2018.12.12.00.23.06;	author tg;	state Exp;
branches;
next	1.14;
commitid	1005C1054FE750D63F3;

1.14
date	2018.05.09.14.19.56;	author tg;	state Exp;
branches;
next	1.12;
commitid	1005AF3037C49F00A45;

1.12
date	2017.08.07.20.10.16;	author tg;	state Exp;
branches;
next	1.11;
commitid	1005988C69344442E37;

1.11
date	2016.11.04.20.10.31;	author tg;	state Exp;
branches;
next	1.10;
commitid	100581CEB466208665C;

1.10
date	2016.10.31.16.29.06;	author tg;	state Exp;
branches;
next	1.9;
commitid	10058177166064E9A3F;

1.9
date	2016.10.25.18.57.55;	author tg;	state Exp;
branches;
next	1.8;
commitid	100580FAB4B20AD4FA2;

1.8
date	2016.03.06.14.12.28;	author tg;	state Exp;
branches;
next	1.7;
commitid	10056DC3ADA1858410D;

1.7
date	2016.03.06.13.47.49;	author tg;	state Exp;
branches;
next	1.6;
commitid	10056DC351700BAF310;

1.6
date	2012.06.05.19.09.41;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004FCE598C750277B2;

1.5
date	2012.05.20.16.13.18;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004FB918314D2FECC0;

1.4
date	2012.02.12.00.44.57;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004F370B9F1314ECC5;

1.3
date	2012.02.12.00.27.17;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004F3707786D20BF4A;

1.2
date	2007.02.17.04.52.41;	author tg;	state Exp;
branches;
next	1.1;
commitid	10045D68A2D54E2C558;

1.1
date	2005.02.05.17.22.06;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.22.06;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.29.17.05.15;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.06.23.23.00.15;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	100449C727D31170AA3;

1.1.1.4
date	2012.02.11.22.47.21;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	1004F36F008225F3522;

1.1.1.5
date	2016.03.04.19.46.09;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	10056D9E61429EE6550;

1.1.1.6
date	2016.03.04.20.55.01;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	10056D9F62E152ECBA5;

1.1.1.7
date	2016.03.06.13.29.55;	author tg;	state Exp;
branches;
next	1.1.1.8;
commitid	10056DC30960F3F5FA0;

1.1.1.8
date	2016.10.25.18.46.10;	author tg;	state Exp;
branches;
next	1.1.1.9;
commitid	100580FA88137705D31;

1.1.1.9
date	2018.12.12.00.15.05;	author tg;	state Exp;
branches;
next	1.1.1.10;
commitid	1005C1052FA5E745A2C;

1.1.1.10
date	2018.12.12.00.24.23;	author tg;	state Exp;
branches
	1.1.1.10.2.1;
next	;
commitid	1005C1055452C78F9E4;

1.1.1.10.2.1
date	2018.12.12.03.13.33;	author tg;	state Exp;
branches;
next	1.1.1.10.2.2;
commitid	1005C107CE315DC51F3;

1.1.1.10.2.2
date	2018.12.12.06.03.13;	author tg;	state Exp;
branches;
next	1.1.1.10.2.3;
commitid	1005C10A4B12E5998CE;

1.1.1.10.2.3
date	2018.12.12.12.43.13;	author tg;	state Exp;
branches;
next	;
commitid	1005C1102747A3732E3;


desc
@@


1.17
log
@fixing and string pooling and int shortening offensive
@
text
@/*	$OpenBSD: pat_rep.c,v 1.43 2017/09/16 07:42:34 otto Exp $	*/
/*	$NetBSD: pat_rep.c,v 1.4 1995/03/21 09:07:33 cgd Exp $	*/

/*-
 * Copyright (c) 2018
 *	mirabilos <t.glaser@@tarent.de>
 * Copyright (c) 1992 Keith Muller.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <regex.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if HAVE_STRINGS_H
#include <strings.h>
#endif

#include "pax.h"
#include "extern.h"

__RCSID("$MirOS: src/bin/pax/pat_rep.c,v 1.16 2018/12/12 18:08:45 tg Exp $");

/*
 * data structure for storing user supplied replacement strings (-s)
 */
typedef struct replace {
	char		*nstr;	/* the new string we will substitute with */
	regex_t		rcmp;	/* compiled regular expression used to match */
	int		flgs;	/* print conversions? global in operation?  */
#define	PRNT		0x1
#define	GLOB		0x2
	struct replace	*fow;	/* pointer to next pattern */
} REPLACE;

/*
 * routines to handle pattern matching, name modification (regular expression
 * substitution and interactive renames), and destination name modification for
 * copy (-rw). Both file name and link names are adjusted as required in these
 * routines.
 */

#define MAXSUBEXP	10		/* max subexpressions, DO NOT CHANGE */
static PATTERN *pathead = NULL;		/* file pattern match list head */
static PATTERN *pattail = NULL;		/* file pattern match list tail */
static REPLACE *rephead = NULL;		/* replacement string list head */
static REPLACE *reptail = NULL;		/* replacement string list tail */

static int rep_name(char *, size_t, int *, int);
static int tty_rename(ARCHD *);
static int fix_path(char *, int *, char *, int);
static int fn_match(char *, char *, char **);
static char * range_match(char *, int);
static int resub(regex_t *, regmatch_t *, char *, char *, char *, char *);

/*
 * rep_add()
 *	parses the -s replacement string; compiles the regular expression
 *	and stores the compiled value and it's replacement string together in
 *	replacement string list. Input to this function is of the form:
 *		/old/new/pg
 *	The first char in the string specifies the delimiter used by this
 *	replacement string. "Old" is a regular expression in "ed" format which
 *	is compiled by regcomp() and is applied to filenames. "new" is the
 *	substitution string; p and g are options flags for printing and global
 *	replacement (over the single filename)
 * Return:
 *	0 if a proper replacement string and regular expression was added to
 *	the list of replacement patterns; -1 otherwise.
 */

int
rep_add(char *str)
{
	char *pt1;
	char *pt2;
	REPLACE *rep;
	int res;
	char rebuf[BUFSIZ];

	/*
	 * throw out the bad parameters
	 */
	if ((str == NULL) || (*str == '\0')) {
		paxwarn(1, "Empty replacement string");
		return(-1);
	}

	/*
	 * first character in the string specifies what the delimiter is for
	 * this expression
	 */
	for (pt1 = str+1; *pt1; pt1++) {
		if (*pt1 == '\\') {
			pt1++;
			continue;
		}
		if (*pt1 == *str)
			break;
	}
	if (*pt1 == '\0') {
		paxwarn(1, "%s %s", "Invalid replacement string", str);
		return (-1);
	}

	/*
	 * allocate space for the node that handles this replacement pattern
	 * and split out the regular expression and try to compile it
	 */
	if ((rep = malloc(sizeof(REPLACE))) == NULL) {
		paxwarn(1, "%s for %s", "Out of memory",
		    "replacement string");
		return (-1);
	}

	*pt1 = '\0';
	if ((res = regcomp(&(rep->rcmp), str+1, 0)) != 0) {
		regerror(res, &(rep->rcmp), rebuf, sizeof(rebuf));
		paxwarn(1, "%s while compiling regular expression %s", rebuf, str);
		free(rep);
		return(-1);
	}

	/*
	 * put the delimiter back in case we need an error message and
	 * locate the delimiter at the end of the replacement string
	 * we then point the node at the new substitution string
	 */
	*pt1++ = *str;
	for (pt2 = pt1; *pt2; pt2++) {
		if (*pt2 == '\\') {
			pt2++;
			continue;
		}
		if (*pt2 == *str)
			break;
	}
	if (*pt2 == '\0') {
		regfree(&(rep->rcmp));
		free(rep);
		paxwarn(1, "%s %s", "Invalid replacement string", str);
		return (-1);
	}

	*pt2 = '\0';
	rep->nstr = pt1;
	pt1 = pt2++;
	rep->flgs = 0;

	/*
	 * set the options if any
	 */
	while (*pt2 != '\0') {
		switch (*pt2) {
		case 'g':
		case 'G':
			rep->flgs  |= GLOB;
			break;
		case 'p':
		case 'P':
			rep->flgs  |= PRNT;
			break;
		default:
			regfree(&(rep->rcmp));
			free(rep);
			*pt1 = *str;
			paxwarn(1, "%s option %s",
			    "Invalid replacement string", str);
			return (-1);
		}
		++pt2;
	}

	/*
	 * all done, link it in at the end
	 */
	rep->fow = NULL;
	if (rephead == NULL) {
		reptail = rephead = rep;
		return(0);
	}
	reptail->fow = rep;
	reptail = rep;
	return(0);
}

/*
 * pat_add()
 *	add a pattern match to the pattern match list. Pattern matches are used
 *	to select which archive members are extracted. (They appear as
 *	arguments to pax in the list and read modes). If no patterns are
 *	supplied to pax, all members in the archive will be selected (and the
 *	pattern match list is empty).
 * Return:
 *	0 if the pattern was added to the list, -1 otherwise
 */

int
pat_add(char *str, char *chdirname)
{
	PATTERN *pt;

	/*
	 * throw out the junk
	 */
	if ((str == NULL) || (*str == '\0')) {
		paxwarn(1, "Empty pattern string");
		return(-1);
	}

	/*
	 * allocate space for the pattern and store the pattern. the pattern is
	 * part of argv so do not bother to copy it, just point at it. Add the
	 * node to the end of the pattern list
	 */
	if ((pt = malloc(sizeof(PATTERN))) == NULL) {
		paxwarn(1, "%s for %s", "Out of memory",
		    "pattern string");
		return (-1);
	}

	pt->pstr = str;
	pt->pend = NULL;
	pt->plen = strlen(str);
	pt->fow = NULL;
	pt->flgs = 0;
	pt->chdname = chdirname;

	if (pathead == NULL) {
		pattail = pathead = pt;
		return(0);
	}
	pattail->fow = pt;
	pattail = pt;
	return(0);
}

/*
 * pat_chk()
 *	complain if any the user supplied pattern did not result in a match to
 *	a selected archive member.
 */

void
pat_chk(void)
{
	PATTERN *pt;
	int wban = 0;

	/*
	 * walk down the list checking the flags to make sure MTCH was set,
	 * if not complain
	 */
	for (pt = pathead; pt != NULL; pt = pt->fow) {
		if (pt->flgs & MTCH)
			continue;
		if (!wban) {
			paxwarn(1, "WARNING! These patterns were not matched:");
			++wban;
		}
		(void)fprintf(stderr, "%s\n", pt->pstr);
	}
}

/*
 * pat_sel()
 *	the archive member which matches a pattern was selected. Mark the
 *	pattern as having selected an archive member. arcn->pat points at the
 *	pattern that was matched. arcn->pat is set in pat_match()
 *
 *	NOTE: When the -c option is used, we are called when there was no match
 *	by pat_match() (that means we did match before the inverted sense of
 *	the logic). Now this seems really strange at first, but with -c we
 *	need to keep track of those patterns that cause an archive member to NOT
 *	be selected (it found an archive member with a specified pattern)
 * Return:
 *	0 if the pattern pointed at by arcn->pat was tagged as creating a
 *	match, -1 otherwise.
 */

int
pat_sel(ARCHD *arcn)
{
	PATTERN *pt;
	PATTERN **ppt;
	size_t len;

	/*
	 * if no patterns just return
	 */
	if ((pathead == NULL) || ((pt = arcn->pat) == NULL))
		return(0);

	/*
	 * when we are NOT limited to a single match per pattern mark the
	 * pattern and return
	 */
	if (!nflag) {
		pt->flgs |= MTCH;
		return(0);
	}

	/*
	 * we reach this point only when we allow a single selected match per
	 * pattern, if the pattern matches a directory and we do not have -d
	 * (dflag) we are done with this pattern. We may also be handed a file
	 * in the subtree of a directory. in that case when we are operating
	 * with -d, this pattern was already selected and we are done
	 */
	if (pt->flgs & DIR_MTCH)
		return(0);

	if (!dflag && ((pt->pend != NULL) || (arcn->type == PAX_DIR))) {
		/*
		 * ok we matched a directory and we are allowing
		 * subtree matches but because of the -n only its children will
		 * match. This is tagged as a DIR_MTCH type.
		 * WATCH IT, the code assumes that pt->pend points
		 * into arcn->name and arcn->name has not been modified.
		 * If not we will have a big mess. Yup this is another kludge
		 */

		/*
		 * if this was a prefix match, remove trailing part of path
		 * so we can copy it. Future matches will be exact prefix match
		 */
		if (pt->pend != NULL)
			*pt->pend = '\0';

		if ((pt->pstr = strdup(arcn->name)) == NULL) {
			paxwarn(1, "%s for %s", "Out of memory",
			    "pattern select");
			if (pt->pend != NULL)
				*pt->pend = '/';
			pt->pend = NULL;
			return(-1);
		}

		/*
		 * put the trailing / back in the source string
		 */
		if (pt->pend != NULL) {
			*pt->pend = '/';
			pt->pend = NULL;
		}
		pt->plen = strlen(pt->pstr);

		/*
		 * strip off any trailing /, this should really never happen
		 */
		len = pt->plen - 1;
		if (*(pt->pstr + len) == '/') {
			*(pt->pstr + len) = '\0';
			pt->plen = len;
		}
		pt->flgs = DIR_MTCH | MTCH;
		arcn->pat = pt;
		return(0);
	}

	/*
	 * we are then done with this pattern, so we delete it from the list
	 * because it can never be used for another match.
	 * Seems kind of strange to do for a -c, but the pax spec is really
	 * vague on the interaction of -c, -n and -d. We assume that when -c
	 * and the pattern rejects a member (i.e. it matched it) it is done.
	 * In effect we place the order of the flags as having -c last.
	 */
	pt = pathead;
	ppt = &pathead;
	while ((pt != NULL) && (pt != arcn->pat)) {
		ppt = &(pt->fow);
		pt = pt->fow;
	}

	if (pt == NULL) {
		/*
		 * should never happen....
		 */
		paxwarn(1, "Pattern list inconsistent");
		return(-1);
	}
	*ppt = pt->fow;
	free(pt);
	arcn->pat = NULL;
	return(0);
}

/*
 * pat_match()
 *	see if this archive member matches any supplied pattern, if a match
 *	is found, arcn->pat is set to point at the potential pattern. Later if
 *	this archive member is "selected" we process and mark the pattern as
 *	one which matched a selected archive member (see pat_sel())
 * Return:
 *	0 if this archive member should be processed, 1 if it should be
 *	skipped and -1 if we are done with all patterns (and pax should quit
 *	looking for more members)
 */

int
pat_match(ARCHD *arcn)
{
	PATTERN *pt;

	arcn->pat = NULL;

	/*
	 * if there are no more patterns and we have -n (and not -c) we are
	 * done. otherwise with no patterns to match, matches all
	 */
	if (pathead == NULL) {
		if (nflag && !cflag)
			return(-1);
		return(0);
	}

	/*
	 * have to search down the list one at a time looking for a match.
	 */
	pt = pathead;
	while (pt != NULL) {
		/*
		 * check for a file name match unless we have DIR_MTCH set in
		 * this pattern then we want a prefix match
		 */
		if (pt->flgs & DIR_MTCH) {
			/*
			 * this pattern was matched before to a directory
			 * as we must have -n set for this (but not -d). We can
			 * only match CHILDREN of that directory so we must use
			 * an exact prefix match (no wildcards).
			 */
			if ((arcn->name[pt->plen] == '/') &&
			    (strncmp(pt->pstr, arcn->name, pt->plen) == 0))
				break;
		} else if (fn_match(pt->pstr, arcn->name, &pt->pend) == 0)
			break;
		pt = pt->fow;
	}

	/*
	 * return the result, remember that cflag (-c) inverts the sense of a
	 * match
	 */
	if (pt == NULL)
		return(cflag ? 0 : 1);

	/*
	 * we had a match, now when we invert the sense (-c) we reject this
	 * member. However we have to tag the pattern a being successful, (in a
	 * match, not in selecting a archive member) so we call pat_sel() here.
	 */
	arcn->pat = pt;
	if (!cflag)
		return(0);

	if (pat_sel(arcn) < 0)
		return(-1);
	arcn->pat = NULL;
	return(1);
}

/*
 * fn_match()
 * Return:
 *	0 if this archive member should be processed, 1 if it should be
 *	skipped and -1 if we are done with all patterns (and pax should quit
 *	looking for more members)
 *	Note: *pend may be changed to show where the prefix ends.
 */

static int
fn_match(char *pattern, char *string, char **pend)
{
	char c;
	char test;

	*pend = NULL;
	for (;;) {
		switch (c = *pattern++) {
		case '\0':
			/*
			 * Ok we found an exact match
			 */
			if (*string == '\0')
				return(0);

			/*
			 * Check if it is a prefix match
			 */
			if ((dflag == 1) || (*string != '/'))
				return(-1);

			/*
			 * It is a prefix match, remember where the trailing
			 * / is located
			 */
			*pend = string;
			return(0);
		case '?':
			if ((test = *string++) == '\0')
				return (-1);
			break;
		case '*':
			c = *pattern;
			/*
			 * collapse multiple asterisks
			 */
			while (c == '*')
				c = *++pattern;

			/*
			 * optimised hack for pattern with a * at the end
			 */
			if (c == '\0')
				return (0);

			/*
			 * General case, use recursion.
			 */
			while ((test = *string) != '\0') {
				if (!fn_match(pattern, string, pend))
					return (0);
				++string;
			}
			return (-1);
		case '[':
			/*
			 * range match
			 */
			if (((test = *string++) == '\0') ||
			    ((pattern = range_match(pattern, test)) == NULL))
				return (-1);
			break;
		case '\\':
			if ((c = *pattern++) == '\0')
				return (-1);
			/* FALLTHROUGH */
		default:
			if (c != *string++)
				return (-1);
			break;
		}
	}
	/* NOTREACHED */
}

static char *
range_match(char *pattern, int test)
{
	char c;
	char c2;
	int negate;
	int ok = 0;

	if ((negate = (*pattern == '!')) != 0)
		++pattern;

	while ((c = *pattern++) != ']') {
		/*
		 * Illegal pattern
		 */
		if (c == '\0')
			return (NULL);

		if ((*pattern == '-') && ((c2 = pattern[1]) != '\0') &&
		    (c2 != ']')) {
			if ((c <= test) && (test <= c2))
				ok = 1;
			pattern += 2;
		} else if (c == test)
			ok = 1;
	}
	return (ok == negate ? NULL : pattern);
}

/*
 * has_dotdot()
 *	Returns true iff the supplied path contains a ".." component.
 */

int
has_dotdot(const char *path)
{
	const char *p = path;

	while ((p = strstr(p, "..")) != NULL) {
		if ((p == path || p[-1] == '/') &&
		    (p[2] == '/' || p[2] == '\0'))
			return (1);
		p += 2;
	}
	return (0);
}

/*
 * mod_name()
 *	modify a selected file name. first attempt to apply replacement string
 *	expressions, then apply interactive file rename. We apply replacement
 *	string expressions to both filenames and file links (if we didn't the
 *	links would point to the wrong place, and we could never be able to
 *	move an archive that has a file link in it). When we rename files
 *	interactively, we store that mapping (old name to user input name) so
 *	if we spot any file links to the old file name in the future, we will
 *	know exactly how to fix the file link.
 * Return:
 *	0 continue to  process file, 1 skip this file, -1 pax is finished
 */

int
mod_name(ARCHD *arcn)
{
	int res = 0;

	if (rmleadslash) {
		/* CVE-2016-6321: completely skip names with dotdot in them */
		const char *p = arcn->name;

		while ((p = strstr(p, ".."))) {
			if ((p == arcn->name || p[-1] == '/') &&
			    (p[2] == '/' || p[2] == '\0')) {
				paxwarn(1,
				    "Skipping pathname with dotdot components: %s",
				    arcn->name);
				return (1);
			}
			++p;
		}
	}

	/*
	 * Strip off leading '/' if appropriate.
	 * Currently, this option is only set for the tar format.
	 */
	while (rmleadslash && arcn->name[0] == '/') {
		if (arcn->name[1] == '\0') {
			arcn->name[0] = '.';
		} else {
			(void)memmove(arcn->name, &arcn->name[1],
			    strlen(arcn->name));
			arcn->nlen--;
		}
		if (rmleadslash < 2) {
			rmleadslash = 2;
			paxwarn(0, "Removing leading / from absolute path names in the archive");
		}
	}
	while (rmleadslash && arcn->ln_name[0] == '/' &&
	    PAX_IS_HARDLINK(arcn->type)) {
		if (arcn->ln_name[1] == '\0') {
			arcn->ln_name[0] = '.';
		} else {
			(void)memmove(arcn->ln_name, &arcn->ln_name[1],
			    strlen(arcn->ln_name));
			arcn->ln_nlen--;
		}
		if (rmleadslash < 2) {
			rmleadslash = 2;
			paxwarn(0, "Removing leading / from absolute path names in the archive");
		}
	}

	/*
	 * IMPORTANT: We have a problem. what do we do with symlinks?
	 * Modifying a hard link name makes sense, as we know the file it
	 * points at should have been seen already in the archive (and if it
	 * wasn't seen because of a read error or a bad archive, we lose
	 * anyway). But there are no such requirements for symlinks. On one
	 * hand the symlink that refers to a file in the archive will have to
	 * be modified to so it will still work at its new location in the
	 * filesystem. On the other hand a symlink that points elsewhere (and
	 * should continue to do so) should not be modified. There is clearly
	 * no perfect solution here. So we handle them like hardlinks. Clearly
	 * a replacement made by the interactive rename mapping is very likely
	 * to be correct since it applies to a single file and is an exact
	 * match. The regular expression replacements are a little harder to
	 * justify though. We claim that the symlink name is only likely
	 * to be replaced when it points within the file tree being moved and
	 * in that case it should be modified. what we really need to do is to
	 * call an oracle here. :)
	 */
	if (rephead != NULL) {
		/*
		 * we have replacement strings, modify the name and the link
		 * name if any.
		 */
		if ((res = rep_name(arcn->name, sizeof(arcn->name), &(arcn->nlen), 1)) != 0)
			return(res);

		if (PAX_IS_LINK(arcn->type)) {
			if ((res = rep_name(arcn->ln_name,
			    sizeof(arcn->ln_name), &(arcn->ln_nlen), 0)) != 0)
				return(res);
		}
	}

	if (iflag) {
		/*
		 * perform interactive file rename, then map the link if any
		 */
		if ((res = tty_rename(arcn)) != 0)
			return(res);
		if (PAX_IS_LINK(arcn->type))
			sub_name(arcn->ln_name, &(arcn->ln_nlen),
			    sizeof(arcn->ln_name));
	}
	return(res);
}

/*
 * tty_rename()
 *	Prompt the user for a replacement file name. A "." keeps the old name,
 *	a empty line skips the file, and an EOF on reading the tty, will cause
 *	pax to stop processing and exit. Otherwise the file name input, replaces
 *	the old one.
 * Return:
 *	0 process this file, 1 skip this file, -1 we need to exit pax
 */

static int
tty_rename(ARCHD *arcn)
{
	char *tmpname;
	int res;

	/*
	 * prompt user for the replacement name for a file, keep trying until
	 * we get some reasonable input. Archives may have more than one file
	 * on them with the same name (from updates etc). We print verbose info
	 * on the file so the user knows what is up.
	 */
	tty_prnt("\nATTENTION: %s interactive file rename operation.\n", argv0);

	for (;;) {
		ls_tty(arcn);
		tty_prnt("Input new name, or a \".\" to keep the old name, ");
		tty_prnt("or a \"return\" to skip this file.\n");
		tty_prnt("Input > ");
		if ((tmpname = tty_rd()) == NULL)
			return (-1);
		if (strcmp(tmpname, "..") == 0) {
			tty_prnt("Try again, illegal file name: ..\n");
			free(tmpname);
			continue;
		}
		if (strlen(tmpname) > PAXPATHLEN) {
			tty_prnt("Try again, file name too long\n");
			free(tmpname);
			continue;
		}
		break;
	}

	/*
	 * empty file name, skips this file. a "." leaves it alone
	 */
	if (tmpname[0] == '\0') {
		tty_prnt("Skipping file.\n");
		free(tmpname);
		return (1);
	}
	if ((tmpname[0] == '.') && (tmpname[1] == '\0')) {
		tty_prnt("Processing continues, name unchanged.\n");
		free(tmpname);
		return (0);
	}

	/*
	 * ok the name changed. We may run into links that point at this
	 * file later. we have to remember where the user sent the file
	 * in order to repair any links.
	 */
	tty_prnt("Processing continues, name changed to: %s\n", tmpname);
	res = add_name(arcn->name, arcn->nlen, tmpname);
	arcn->nlen = strlcpy(arcn->name, tmpname, sizeof(arcn->name));
	if ((size_t)arcn->nlen >= sizeof(arcn->name))
		arcn->nlen = sizeof(arcn->name) - 1; /* XXX truncate? */
	free(tmpname);
	if (res < 0)
		return (-1);
	return (0);
}

/*
 * set_dest()
 *	fix up the file name and the link name (if any) so this file will land
 *	in the destination directory (used during copy() -rw).
 * Return:
 *	0 if ok, -1 if failure (name too long)
 */

int
set_dest(ARCHD *arcn, char *dest_dir, int dir_len)
{
	if (fix_path(arcn->name, &(arcn->nlen), dest_dir, dir_len) < 0)
		return(-1);

	/*
	 * It is really hard to deal with symlinks here, we cannot be sure
	 * if the name they point was moved (or will be moved). It is best to
	 * leave them alone.
	 */
	if (!PAX_IS_HARDLINK(arcn->type))
		return(0);

	if (fix_path(arcn->ln_name, &(arcn->ln_nlen), dest_dir, dir_len) < 0)
		return(-1);
	return(0);
}

/*
 * fix_path
 *	concatenate dir_name and or_name and store the result in or_name (if
 *	it fits). This is one ugly function.
 * Return:
 *	0 if ok, -1 if the final name is too long
 */

static int
fix_path(char *or_name, int *or_len, char *dir_name, int dir_len)
{
	char *src;
	char *dest;
	char *start;
	int len;

	/*
	 * we shift the or_name to the right enough to tack in the dir_name
	 * at the front. We make sure we have enough space for it all before
	 * we start. since dest always ends in a slash, we skip of or_name
	 * if it also starts with one.
	 */
	start = or_name;
	src = start + *or_len;
	dest = src + dir_len;
	if (*start == '/') {
		++start;
		--dest;
	}
	if ((len = dest - or_name) > PAXPATHLEN) {
		paxwarn(1, "File name %s/%s, too long", dir_name, start);
		return(-1);
	}
	*or_len = len;

	/*
	 * enough space, shift
	 */
	while (src >= start)
		*dest-- = *src--;
	src = dir_name + dir_len - 1;

	/*
	 * splice in the destination directory name
	 */
	while (src >= dir_name)
		*dest-- = *src--;

	*(or_name + len) = '\0';
	return(0);
}

/*
 * rep_name()
 *	walk down the list of replacement strings applying each one in order.
 *	when we find one with a successful substitution, we modify the name
 *	as specified. if required, we print the results. if the resulting name
 *	is empty, we will skip this archive member. We use the regexp(3)
 *	routines (regexp() ought to win a price as having the most cryptic
 *	library function manual page).
 *	--Parameters--
 *	name is the file name we are going to apply the regular expressions to
 *	(and may be modified)
 *	nsize is the size of the name buffer.
 *	nlen is the length of this name (and is modified to hold the length of
 *	the final string).
 *	prnt is a flag that says whether to print the final result.
 * Return:
 *	0 if substitution was successful, 1 if we are to skip the file (the name
 *	ended up empty)
 */

static int
rep_name(char *name, size_t nsize, int *nlen, int prnt)
{
	REPLACE *pt;
	char *inpt;
	char *outpt;
	char *endpt;
	char *rpt;
	int found = 0;
	int res;
	regmatch_t pm[MAXSUBEXP];
	char nname[PAXPATHLEN+1];	/* final result of all replacements */
	char buf1[PAXPATHLEN+1];	/* where we work on the name */

	/*
	 * copy the name into buf1, where we will work on it. We need to keep
	 * the orig string around so we can print out the result of the final
	 * replacement. We build up the final result in nname. inpt points at
	 * the string we apply the regular expression to. prnt is used to
	 * suppress printing when we handle replacements on the link field
	 * (the user already saw that substitution go by)
	 */
	pt = rephead;
	(void)strlcpy(buf1, name, sizeof(buf1));
	inpt = buf1;
	outpt = nname;
	endpt = outpt + PAXPATHLEN;

	/*
	 * try each replacement string in order
	 */
	while (pt != NULL) {
		do {
			char *oinpt = inpt;
			/*
			 * check for a successful substitution, if not go to
			 * the next pattern, or cleanup if we were global
			 */
			if (regexec(&(pt->rcmp), inpt, MAXSUBEXP, pm, 0) != 0)
				break;

			/*
			 * ok we found one. We have three parts, the prefix
			 * which did not match, the section that did and the
			 * tail (that also did not match). Copy the prefix to
			 * the final output buffer (watching to make sure we
			 * do not create a string too long).
			 */
			found = 1;
			rpt = inpt + pm[0].rm_so;

			while ((inpt < rpt) && (outpt < endpt))
				*outpt++ = *inpt++;
			if (outpt == endpt)
				break;

			/*
			 * for the second part (which matched the regular
			 * expression) apply the substitution using the
			 * replacement string and place it the prefix in the
			 * final output. If we have problems, skip it.
			 */
			if ((res = resub(&(pt->rcmp),pm,pt->nstr,oinpt,outpt,endpt))
			    < 0) {
				if (prnt)
					paxwarn(1, "Replacement name error %s",
					    name);
				return(1);
			}
			outpt += res;

			/*
			 * we set up to look again starting at the first
			 * character in the tail (of the input string right
			 * after the last character matched by the regular
			 * expression (inpt always points at the first char in
			 * the string to process). If we are not doing a global
			 * substitution, we will use inpt to copy the tail to
			 * the final result. Make sure we do not overrun the
			 * output buffer
			 */
			inpt += pm[0].rm_eo - pm[0].rm_so;

			if ((outpt == endpt) || (*inpt == '\0'))
				break;

			/*
			 * if the user wants global we keep trying to
			 * substitute until it fails, then we are done.
			 */
		} while (pt->flgs & GLOB);

		if (found)
			break;

		/*
		 * a successful substitution did NOT occur, try the next one
		 */
		pt = pt->fow;
	}

	if (found) {
		/*
		 * we had a substitution, copy the last tail piece (if there is
		 * room) to the final result
		 */
		while ((outpt < endpt) && (*inpt != '\0'))
			*outpt++ = *inpt++;

		*outpt = '\0';
		if ((outpt == endpt) && (*inpt != '\0')) {
			if (prnt)
				paxwarn(1,"Replacement name too long %s >> %s",
				    name, nname);
			return(1);
		}

		/*
		 * inform the user of the result if wanted
		 */
		if (prnt && (pt->flgs & PRNT)) {
			(void)fprintf(stderr, "%s >> %s",
			    name, *nname == '\0' ? "<empty string>" : nname);
			(void)fputc('\n', stderr);
		}

		/*
		 * if empty inform the caller this file is to be skipped
		 * otherwise copy the new name over the orig name and return
		 */
		if (*nname == '\0')
			return(1);
		*nlen = strlcpy(name, nname, nsize);
	}
	return(0);
}

/*
 * resub()
 *	apply the replacement to the matched expression. expand out the old
 *	style ed(1) subexpression expansion.
 * Return:
 *	-1 if error, or the number of characters added to the destination.
 */

static int
resub(regex_t *rp, regmatch_t *pm, char *src, char *inpt, char *dest,
	char *destend)
{
	char *spt;
	char *dpt;
	char c;
	regmatch_t *pmpt;
	int len;
	int subexcnt;

	spt =  src;
	dpt = dest;
	subexcnt = rp->re_nsub;
	while ((dpt < destend) && ((c = *spt++) != '\0')) {
		/*
		 * see if we just have an ordinary replacement character
		 * or we refer to a subexpression.
		 */
		if (c == '&') {
			pmpt = pm;
		} else if ((c == '\\') && (*spt >= '0') && (*spt <= '9')) {
			/*
			 * make sure there is a subexpression as specified
			 */
			if ((len = *spt++ - '0') > subexcnt)
				return(-1);
			pmpt = pm + len;
		} else {
			/*
			 * Ordinary character, just copy it
			 */
			if ((c == '\\') && (*spt != '\0'))
				c = *spt++;
			*dpt++ = c;
			continue;
		}

		/*
		 * continue if the subexpression is bogus
		 */
		if ((pmpt->rm_so < 0) || (pmpt->rm_eo < 0) ||
		    ((len = pmpt->rm_eo - pmpt->rm_so) <= 0))
			continue;

		/*
		 * copy the subexpression to the destination.
		 * fail if we run out of space or the match string is damaged
		 */
		if (len > (destend - dpt))
			return (-1);
		strncpy(dpt, inpt + pmpt->rm_so, len);
		dpt += len;
	}
	return(dpt - dest);
}
@


1.16
log
@merge the npax branch into MAIN

asides from a missing dprintf and portability, this ought to be
good enough for people (well me) to play with for now
@
text
@d52 1
a52 1
__RCSID("$MirOS: src/bin/pax/pat_rep.c,v 1.14 2018/05/09 14:19:56 tg Exp $");
d132 2
a133 2
		paxwarn(1, "Invalid replacement string %s", str);
		return(-1);
d141 3
a143 2
		paxwarn(1, "Unable to allocate memory for replacement string");
		return(-1);
d171 2
a172 2
		paxwarn(1, "Invalid replacement string %s", str);
		return(-1);
d197 3
a199 2
			paxwarn(1, "Invalid replacement string option %s", str);
			return(-1);
d247 3
a249 2
		paxwarn(1, "Unable to allocate memory for pattern string");
		return(-1);
d361 2
a362 1
			paxwarn(1, "Pattern select out of memory");
d1035 3
a1037 5
			if (*nname == '\0')
				(void)fprintf(stderr,"%s >> <empty string>\n",
				    name);
			else
				(void)fprintf(stderr,"%s >> %s\n", name, nname);
@


1.15
log
@slowmerge (untested though)
@
text
@d5 2
d39 1
a39 2
#include <sys/param.h>
#include <sys/time.h>
d41 1
d43 1
d45 4
a48 5
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <regex.h>
#include <time.h>
a49 1
#include "pat_rep.h"
d53 12
a64 1
__IDSTRING(rcsid_pat_rep_h, MIRCPIO_PAT_REP_H);
d140 1
a140 1
	if ((rep = (REPLACE *)malloc(sizeof(REPLACE))) == NULL) {
d149 1
a149 1
		(void)free((char *)rep);
d169 1
a169 1
		(void)free((char *)rep);
d194 1
a194 1
			(void)free((char *)rep);
d227 1
a227 1
pat_add(char *str, char *chd_name)
d244 1
a244 1
	if ((pt = (PATTERN *)malloc(sizeof(PATTERN))) == NULL) {
d254 1
a254 1
	pt->chdname = chd_name;
d410 1
a410 1
	(void)free((char *)pt);
d534 1
a534 1
			 * Collapse multiple *'s.
d644 1
a644 1
		const char *p = strstr(arcn->name, "..");
d646 9
a654 6
		if (p && (p == arcn->name || p[-1] == '/') &&
		    (p[2] == '/' || p[2] == '\0')) {
			paxwarn(1,
			    "Skipping pathname with dotdot components: %s",
			    arcn->name);
			return (1);
d676 1
a676 1
	    (arcn->type == PAX_HLK || arcn->type == PAX_HRG)) {
d717 5
a721 4
		if (((arcn->type == PAX_SLK) || (arcn->type == PAX_HLK) ||
		    (arcn->type == PAX_HRG)) &&
		    ((res = rep_name(arcn->ln_name, sizeof(arcn->ln_name), &(arcn->ln_nlen), 0)) != 0))
			return(res);
d730 3
a732 3
		if ((arcn->type == PAX_SLK) || (arcn->type == PAX_HLK) ||
		    (arcn->type == PAX_HRG))
			sub_name(arcn->ln_name, &(arcn->ln_nlen), sizeof(arcn->ln_name));
d750 1
a751 1
	char *tmpname;
d830 1
a830 1
	if ((arcn->type != PAX_HLK) && (arcn->type != PAX_HRG))
@


1.14
log
@16:07⎜«q3cpma» It fixes glob escaping, basically.

patch from hadrien.lacour@@posteo.net via IRC, merci!
@
text
@d1 1
a1 1
/*	$OpenBSD: pat_rep.c,v 1.31 +1.40 2009/10/27 23:59:22 deraadt Exp $	*/
d51 1
a51 1
__RCSID("$MirOS: src/bin/pax/pat_rep.c,v 1.11 2016/11/04 20:10:31 tg Exp $");
d551 3
a553 1
			c = *pattern++;
@


1.12
log
@filesystem
@
text
@d551 1
@


1.11
log
@fix bad patch in commitid 10058177166064E9A3F; spotted by Han Boetes (10x)
@
text
@d51 1
a51 1
__RCSID("$MirOS: src/bin/pax/pat_rep.c,v 1.8 2016/03/06 14:12:28 tg Exp $");
d680 1
a680 1
	 * file system. On the other hand a symlink that points elsewhere (and
@


1.10
log
@When extracting, skip ".." members (CVE-2016-6321); fix inspired by Debian
@
text
@d631 1
a631 1
		if ((p == arcn->name || p[-1] == '/') &&
@


1.9
log
@fastmerge
@
text
@d627 13
a670 24
	if (rmleadslash) {
		const char *last = NULL;
		const char *p = arcn->name;

		while ((p = strstr(p, "..")) != NULL) {
			if ((p == arcn->name || p[-1] == '/') &&
			    (p[2] == '/' || p[2] == '\0'))
				last = p + 2;
			p += 2;
		}
		if (last != NULL) {
			last++;
			paxwarn(1, "Removing leading \"%.*s\"",
			    (int)(last - arcn->name), arcn->name);
			arcn->nlen = strlen(last);
			if (arcn->nlen > 0)
				memmove(arcn->name, last, arcn->nlen + 1);
			else {
				arcn->name[0] = '.';
				arcn->name[1] = '\0';
				arcn->nlen = 1;
			}
		}
	}
@


1.8
log
@version the *.h files as idstrings, too
@
text
@d1 1
a1 1
/*	$OpenBSD: pat_rep.c,v 1.31 2009/10/27 23:59:22 deraadt Exp $	*/
d51 1
a51 1
__RCSID("$MirOS: src/bin/pax/pat_rep.c,v 1.5 2012/05/20 16:13:18 tg Exp $");
d301 1
a301 1
	int len;
@


1.7
log
@merge CVE fixes from openbsd branch
@
text
@d52 1
@


1.6
log
@change tty_read(buf,sz) to buf=tty_rd() in callers so fdgetline() conversion makes sense
@
text
@d589 19
d657 24
@


1.5
log
@get rid of extern.h including other headers
@
text
@d51 1
a51 1
__RCSID("$MirOS: src/bin/pax/pat_rep.c,v 1.4 2012/02/12 00:44:57 tg Exp $");
a697 1
	char tmpname[PAXPATHLEN+2];
d699 1
d714 2
a715 2
		if (tty_read(tmpname, sizeof(tmpname)) < 0)
			return(-1);
d718 1
d723 1
d734 2
a735 1
		return(1);
d739 2
a740 1
		return(0);
d753 1
d755 2
a756 2
		return(-1);
	return(0);
@


1.4
log
@spelling
@
text
@d46 1
d51 1
a51 1
__RCSID("$MirOS: src/bin/pax/pat_rep.c,v 1.3 2012/02/12 00:27:17 tg Exp $");
@


1.3
log
@merge OpenBSD
@
text
@d50 1
a50 1
__RCSID("$MirOS: src/bin/pax/pat_rep.c,v 1.2 2007/02/17 04:52:41 tg Exp $");
d526 1
a526 1
			 * Optimized hack for pattern with a * at the end
d838 1
a838 1
 *	routines (regexp() ought to win a prize as having the most cryptic
@


1.2
log
@__CRAZY clean
@
text
@d1 1
a1 1
/*	$OpenBSD: pat_rep.c,v 1.30 2005/08/05 08:30:10 djm Exp $	*/
d50 1
a50 2
__SCCSID("@@(#)pat_rep.c	8.2 (Berkeley) 4/18/94");
__RCSID("$MirOS$");
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: pat_rep.c,v 1.28 2004/06/11 03:10:43 millert Exp $	*/
d37 1
a37 9
#ifndef lint
#if 0
static const char sccsid[] = "@@(#)pat_rep.c	8.2 (Berkeley) 4/18/94";
#else
static const char rcsid[] = "$OpenBSD: pat_rep.c,v 1.28 2004/06/11 03:10:43 millert Exp $";
#endif
#endif /* not lint */

#include <sys/types.h>
a39 1
#include <sys/param.h>
d50 3
d214 1
a214 1
pat_add(char *str, char *chdname)
d241 1
a241 1
	pt->chdname = chdname;
d611 1
a611 1
	if (rmleadslash && arcn->name[0] == '/') {
d624 1
a624 1
	if (rmleadslash && arcn->ln_name[0] == '/' &&
d747 2
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@improve my Frankenstein OS (*wink* you know who you are) further
sans wchar_t of course

this is the essence of reading >1200 commit messages which suck
due to not having the new format of ours...
@
text
@d1 1
a1 1
/*	$OpenBSD: pat_rep.c,v 1.29 2005/04/21 21:47:18 beck Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: pat_rep.c,v 1.29 2005/04/21 21:47:18 beck Exp $";
a752 2
	if (arcn->nlen >= sizeof(arcn->name))
		arcn->nlen = sizeof(arcn->name) - 1; /* XXX truncate? */
@


1.1.1.3
log
@One "miserable" byte in filenames is worth an import

agreed bsiegert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pat_rep.c,v 1.30 2005/08/05 08:30:10 djm Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: pat_rep.c,v 1.30 2005/08/05 08:30:10 djm Exp $";
d617 1
a617 1
	while (rmleadslash && arcn->name[0] == '/') {
d630 1
a630 1
	while (rmleadslash && arcn->ln_name[0] == '/' &&
@


1.1.1.4
log
@import up-to-date pax from OpenBSD 5.1-current
@
text
@d1 1
a1 1
/*	$OpenBSD: pat_rep.c,v 1.31 2009/10/27 23:59:22 deraadt Exp $	*/
d37 8
@


1.1.1.5
log
@pull newer paxtar from OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: pat_rep.c,v 1.40 2015/11/17 19:01:34 mmcc Exp $	*/
d40 1
d125 1
a125 1
	if ((rep = malloc(sizeof(REPLACE))) == NULL) {
d134 1
a134 1
		free(rep);
d154 1
a154 1
		free(rep);
d179 1
a179 1
			free(rep);
d212 1
a212 1
pat_add(char *str, char *chdirname)
d229 1
a229 1
	if ((pt = malloc(sizeof(PATTERN))) == NULL) {
d239 1
a239 1
	pt->chdname = chdirname;
d298 1
a298 1
	size_t len;
d395 1
a395 1
	free(pt);
a586 19
 * has_dotdot()
 *	Returns true iff the supplied path contains a ".." component.
 */

int
has_dotdot(const char *path)
{
	const char *p = path;

	while ((p = strstr(p, "..")) != NULL) {
		if ((p == path || p[-1] == '/') &&
		    (p[2] == '/' || p[2] == '\0'))
			return (1);
		p += 2;
	}
	return (0);
}

/*
d623 1
a623 1
	    PAX_IS_HARDLINK(arcn->type)) {
a635 24
	if (rmleadslash) {
		const char *last = NULL;
		const char *p = arcn->name;

		while ((p = strstr(p, "..")) != NULL) {
			if ((p == arcn->name || p[-1] == '/') &&
			    (p[2] == '/' || p[2] == '\0'))
				last = p + 2;
			p += 2;
		}
		if (last != NULL) {
			last++;
			paxwarn(1, "Removing leading \"%.*s\"",
			    (int)(last - arcn->name), arcn->name);
			arcn->nlen = strlen(last);
			if (arcn->nlen > 0)
				memmove(arcn->name, last, arcn->nlen + 1);
			else {
				arcn->name[0] = '.';
				arcn->name[1] = '\0';
				arcn->nlen = 1;
			}
		}
	}
d664 4
a667 5
		if (PAX_IS_LINK(arcn->type)) {
			if ((res = rep_name(arcn->ln_name,
			    sizeof(arcn->ln_name), &(arcn->ln_nlen), 0)) != 0)
				return(res);
		}
d676 3
a678 3
		if (PAX_IS_LINK(arcn->type))
			sub_name(arcn->ln_name, &(arcn->ln_nlen),
			    sizeof(arcn->ln_name));
d771 1
a771 1
	if (!PAX_IS_HARDLINK(arcn->type))
@


1.1.1.6
log
@revert the import; we’ll just backport the CVE fixes, for now ☹
@
text
@d1 1
a1 1
/*	$OpenBSD: pat_rep.c,v 1.31 2009/10/27 23:59:22 deraadt Exp $	*/
a39 1
#include <sys/param.h>
d124 1
a124 1
	if ((rep = (REPLACE *)malloc(sizeof(REPLACE))) == NULL) {
d133 1
a133 1
		(void)free((char *)rep);
d153 1
a153 1
		(void)free((char *)rep);
d178 1
a178 1
			(void)free((char *)rep);
d211 1
a211 1
pat_add(char *str, char *chdname)
d228 1
a228 1
	if ((pt = (PATTERN *)malloc(sizeof(PATTERN))) == NULL) {
d238 1
a238 1
	pt->chdname = chdname;
d297 1
a297 1
	int len;
d394 1
a394 1
	(void)free((char *)pt);
d586 19
d641 1
a641 1
	    (arcn->type == PAX_HLK || arcn->type == PAX_HRG)) {
d654 24
d706 5
a710 4
		if (((arcn->type == PAX_SLK) || (arcn->type == PAX_HLK) ||
		    (arcn->type == PAX_HRG)) &&
		    ((res = rep_name(arcn->ln_name, sizeof(arcn->ln_name), &(arcn->ln_nlen), 0)) != 0))
			return(res);
d719 3
a721 3
		if ((arcn->type == PAX_SLK) || (arcn->type == PAX_HLK) ||
		    (arcn->type == PAX_HRG))
			sub_name(arcn->ln_name, &(arcn->ln_nlen), sizeof(arcn->ln_name));
d814 1
a814 1
	if ((arcn->type != PAX_HLK) && (arcn->type != PAX_HRG))
@


1.1.1.7
log
@backport OpenBSD pax erratum, more specifically:

• directory bug, symlinks with -C bug
• escaping with .. and symlinks
• tar without -P
• validate directories touched in the cleanup phase
@
text
@a586 19
 * has_dotdot()
 *	Returns true iff the supplied path contains a ".." component.
 */

int
has_dotdot(const char *path)
{
	const char *p = path;

	while ((p = strstr(p, "..")) != NULL) {
		if ((p == path || p[-1] == '/') &&
		    (p[2] == '/' || p[2] == '\0'))
			return (1);
		p += 2;
	}
	return (0);
}

/*
a635 24
	if (rmleadslash) {
		const char *last = NULL;
		const char *p = arcn->name;

		while ((p = strstr(p, "..")) != NULL) {
			if ((p == arcn->name || p[-1] == '/') &&
			    (p[2] == '/' || p[2] == '\0'))
				last = p + 2;
			p += 2;
		}
		if (last != NULL) {
			last++;
			paxwarn(1, "Removing leading \"%.*s\"",
			    (int)(last - arcn->name), arcn->name);
			arcn->nlen = strlen(last);
			if (arcn->nlen > 0)
				memmove(arcn->name, last, arcn->nlen + 1);
			else {
				arcn->name[0] = '.';
				arcn->name[1] = '\0';
				arcn->nlen = 1;
			}
		}
	}
@


1.1.1.8
log
@bunch of cherry-picks from OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: pat_rep.c,v 1.31 +1.40 2009/10/27 23:59:22 deraadt Exp $	*/
d298 1
a298 1
	size_t len;
@


1.1.1.9
log
@merge what OpenBSD did between our last cherry-pick and today minus one commit

(“Use the new libc uid_from_user() and gid_from_group() instead of
  the pax-specific functions in cache.c” is ignored, for now)
@
text
@d1 1
a1 1
/*	$OpenBSD: pat_rep.c,v 1.43 2017/09/16 07:42:34 otto Exp $	*/
a547 3
			if ((c = *pattern++) == '\0')
				return (-1);
			/* FALLTHROUGH */
d788 1
a788 1
	if ((size_t)arcn->nlen >= sizeof(arcn->name))
@


1.1.1.10
log
@Import latest OpenBSD paxtar, unmodified, into vendor branch
@
text
@d38 1
d40 1
a40 1
#include <regex.h>
d42 2
d45 2
a46 2
#include <string.h>

d48 1
a51 12
 * data structure for storing user supplied replacement strings (-s)
 */
typedef struct replace {
	char		*nstr;	/* the new string we will substitute with */
	regex_t		rcmp;	/* compiled regular expression used to match */
	int		flgs;	/* print conversions? global in operation?  */
#define	PRNT		0x1
#define	GLOB		0x2
	struct replace	*fow;	/* pointer to next pattern */
} REPLACE;

/*
d125 1
a125 1
	if ((rep = malloc(sizeof(REPLACE))) == NULL) {
d134 1
a134 1
		free(rep);
d154 1
a154 1
		free(rep);
d179 1
a179 1
			free(rep);
d212 1
a212 1
pat_add(char *str, char *chdirname)
d229 1
a229 1
	if ((pt = malloc(sizeof(PATTERN))) == NULL) {
d239 1
a239 1
	pt->chdname = chdirname;
d395 1
a395 1
	free(pt);
d645 1
a645 1
	    PAX_IS_HARDLINK(arcn->type)) {
d710 4
a713 5
		if (PAX_IS_LINK(arcn->type)) {
			if ((res = rep_name(arcn->ln_name,
			    sizeof(arcn->ln_name), &(arcn->ln_nlen), 0)) != 0)
				return(res);
		}
d722 3
a724 3
		if (PAX_IS_LINK(arcn->type))
			sub_name(arcn->ln_name, &(arcn->ln_nlen),
			    sizeof(arcn->ln_name));
d817 1
a817 1
	if (!PAX_IS_HARDLINK(arcn->type))
@


1.1.1.10.2.1
log
@extremely rudimentary conversion to mirtoconf, doesn’t even build yet
@
text
@a42 3
#if HAVE_STRINGS_H
#include <strings.h>
#endif
@


1.1.1.10.2.2
log
@do the ‘c’s
@
text
@d702 1
a702 1
	 * filesystem. On the other hand a symlink that points elsewhere (and
@


1.1.1.10.2.3
log
@pax without .h, modulo setpgent and O_CLOEXEC
@
text
@a4 2
 * Copyright (c) 2018
 *	mirabilos <t.glaser@@tarent.de>
d530 1
a530 1
			 * collapse multiple asterisks
d536 1
a536 1
			 * optimised hack for pattern with a * at the end
a637 16
	if (rmleadslash) {
		/* CVE-2016-6321: completely skip names with dotdot in them */
		const char *p = arcn->name;

		while ((p = strstr(p, ".."))) {
			if ((p == arcn->name || p[-1] == '/') &&
			    (p[2] == '/' || p[2] == '\0')) {
				paxwarn(1,
				    "Skipping pathname with dotdot components: %s",
				    arcn->name);
				return (1);
			}
			++p;
		}
	}

d669 24
d754 1
a754 1
	char *tmpname;
d770 2
a771 2
		if ((tmpname = tty_rd()) == NULL)
			return (-1);
a773 1
			free(tmpname);
a777 1
			free(tmpname);
d788 1
a788 2
		free(tmpname);
		return (1);
d792 1
a792 2
		free(tmpname);
		return (0);
a804 1
	free(tmpname);
d806 2
a807 2
		return (-1);
	return (0);
d895 1
a895 1
 *	routines (regexp() ought to win a price as having the most cryptic
@


