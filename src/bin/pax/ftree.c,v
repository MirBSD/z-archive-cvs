head	1.12;
access;
symbols
	paxmirabilis-20190825:1.12
	paxmirabilis-20190224:1.12
	paxmirabilis-20190210:1.12
	npax:1.1.1.9.0.2
	cvs-20181212:1.1.1.9
	paxmirabilis-20171021:1.9
	paxmirabilis-20161104:1.8
	paxmirabilis-20161031:1.8
	paxmirabilis-20161025:1.8
	paxmirabilis-20160306:1.8
	cvs-201603041945:1.1.1.5
	paxmirabilis-20151013:1.6
	paxmirabilis-20140703:1.6
	paxmirabilis-20120606:1.6
	paxmirabilis-20120605:1.6
	cvs-201206051745:1.1.1.4
	paxmirabilis-20120520:1.6
	paxmirabilis-20120216:1.5
	paxmirabilis-20120212:1.5
	cvs-201202112230:1.1.1.4
	paxmirabilis-20110817:1.3
	MIRBSD_10:1.3.0.2
	MIRBSD_10_BASE:1.3
	cvs-200710231945:1.1.1.3
	cvs-200606232242:1.1.1.2
	MIRBSD_9_BASE:1.1.1.2
	MIRBSD_8:1.1.1.2.0.2
	MIRBSD_8_BASE:1.1.1.2
	cvs-200507211800:1.1.1.2
	cvs-200504291700:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2018.12.13.07.09.10;	author tg;	state Exp;
branches;
next	1.11;
commitid	1005C1205A44B32AFA4;

1.11
date	2018.12.12.18.08.44;	author tg;	state Exp;
branches;
next	1.10;
commitid	1005C114EA81986F5EC;

1.10
date	2018.12.12.00.23.06;	author tg;	state Exp;
branches;
next	1.9;
commitid	1005C1054FE750D63F3;

1.9
date	2017.08.07.20.10.14;	author tg;	state Exp;
branches;
next	1.8;
commitid	1005988C69344442E37;

1.8
date	2016.03.06.14.12.27;	author tg;	state Exp;
branches;
next	1.7;
commitid	10056DC3ADA1858410D;

1.7
date	2016.03.06.13.47.49;	author tg;	state Exp;
branches;
next	1.6;
commitid	10056DC351700BAF310;

1.6
date	2012.05.20.16.13.17;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004FB918314D2FECC0;

1.5
date	2012.02.12.00.44.57;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004F370B9F1314ECC5;

1.4
date	2012.02.12.00.27.16;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004F3707786D20BF4A;

1.3
date	2007.10.23.20.07.42;	author tg;	state Exp;
branches;
next	1.2;
commitid	100471E5499154FE86E;

1.2
date	2007.02.17.04.52.40;	author tg;	state Exp;
branches;
next	1.1;
commitid	10045D68A2D54E2C558;

1.1
date	2005.02.05.17.22.06;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.22.06;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.29.17.05.15;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.10.23.19.50.48;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	100471E50A5256C77AE;

1.1.1.4
date	2012.02.11.22.47.21;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	1004F36F008225F3522;

1.1.1.5
date	2016.03.04.19.46.09;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	10056D9E61429EE6550;

1.1.1.6
date	2016.03.04.20.55.00;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	10056D9F62E152ECBA5;

1.1.1.7
date	2016.03.06.13.29.54;	author tg;	state Exp;
branches;
next	1.1.1.8;
commitid	10056DC30960F3F5FA0;

1.1.1.8
date	2018.12.12.00.15.04;	author tg;	state Exp;
branches;
next	1.1.1.9;
commitid	1005C1052FA5E745A2C;

1.1.1.9
date	2018.12.12.00.24.23;	author tg;	state Exp;
branches
	1.1.1.9.2.1;
next	;
commitid	1005C1055452C78F9E4;

1.1.1.9.2.1
date	2018.12.12.00.54.16;	author tg;	state Exp;
branches;
next	1.1.1.9.2.2;
commitid	1005C105C48612B0194;

1.1.1.9.2.2
date	2018.12.12.03.13.32;	author tg;	state Exp;
branches;
next	1.1.1.9.2.3;
commitid	1005C107CE315DC51F3;

1.1.1.9.2.3
date	2018.12.12.06.03.12;	author tg;	state Exp;
branches;
next	1.1.1.9.2.4;
commitid	1005C10A4B12E5998CE;

1.1.1.9.2.4
date	2018.12.12.06.25.16;	author tg;	state Exp;
branches;
next	1.1.1.9.2.5;
commitid	1005C10A9DB34B11C85;

1.1.1.9.2.5
date	2018.12.12.06.57.43;	author tg;	state Exp;
branches;
next	1.1.1.9.2.6;
commitid	1005C10B17B60390CAF;

1.1.1.9.2.6
date	2018.12.12.08.48.14;	author tg;	state Exp;
branches;
next	;
commitid	1005C10CB641D052FC1;


desc
@@


1.12
log
@fixing and string pooling and int shortening offensive
@
text
@/*	$OpenBSD: ftree.c,v 1.41 2017/09/16 07:42:34 otto Exp $	*/
/*	$NetBSD: ftree.c,v 1.4 1995/03/21 09:07:21 cgd Exp $	*/

/*-
 * Copyright (c) 1992 Keith Muller.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <fts.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if HAVE_STRINGS_H
#include <strings.h>
#endif
#include <unistd.h>

#include "pax.h"
#include "extern.h"

__RCSID("$MirOS: src/bin/pax/ftree.c,v 1.11 2018/12/12 18:08:44 tg Exp $");

/*
 * Data structure used to store the file args to be handed to fts().
 * It keeps track of which args generated a "selected" member.
 */
typedef struct ftree {
	char		*fname;		/* file tree name */
	int		refcnt;		/* has tree had a selected file? */
	int		newercnt;	/* skipped due to -u/-D */
	int		chflg;		/* change directory flag */
	struct ftree	*fow;		/* pointer to next entry on list */
} FTREE;

/*
 * routines to interface with the fts library function.
 *
 * file args supplied to pax are stored on a single linked list (of type FTREE)
 * and given to fts to be processed one at a time. pax "selects" files from
 * the expansion of each arg into the corresponding file tree (if the arg is a
 * directory, otherwise the node itself is just passed to pax). The selection
 * is modified by the -n and -u flags. The user is informed when a specific
 * file arg does not generate any selected files. -n keeps expanding the file
 * tree arg until one of its files is selected, then skips to the next file
 * arg. when the user does not supply the file trees as command line args to
 * pax, they are read from stdin
 */

static FTS *ftsp = NULL;		/* current FTS handle */
static int ftsopts;			/* options to be used on fts_open */
static char *farray[2];			/* array for passing each arg to fts */
static FTREE *fthead = NULL;		/* head of linked list of file args */
static FTREE *fttail = NULL;		/* tail of linked list of file args */
static FTREE *ftcur = NULL;		/* current file arg being processed */
static FTSENT *ftent = NULL;		/* current file tree entry */
static int ftree_skip;			/* when set skip to next file arg */

static int ftree_arg(void);
static char *getpathname(char *, int);

/*
 * ftree_start()
 *	initialise the options passed to fts_open() during this run of pax
 *	options are based on the selection of pax options by the user
 *	fts_start() also calls fts_arg() to open the first valid file arg. We
 *	also attempt to reset directory access times when -t (tflag) is set.
 * Return:
 *	0 if there is at least one valid file arg to process, -1 otherwise
 */

int
ftree_start(void)
{
	/*
	 * set up the operation mode of fts, open the first file arg. We must
	 * use FTS_NOCHDIR, as the user may have to open multiple archives and
	 * if fts did a chdir off into the boondocks, we may create an archive
	 * volume in an place where the user did not expect to.
	 */
	ftsopts = FTS_NOCHDIR;

	/*
	 * optional user flags that effect file traversal
	 * -H command line symlink follow only (half follow)
	 * -L follow sylinks (logical)
	 * -P do not follow sylinks (physical). This is the default.
	 * -X do not cross over mount points
	 * -t preserve access times on files read.
	 * -n select only the first member of a file tree when a match is found
	 * -d do not extract subtrees rooted at a directory arg.
	 */
	if (Lflag)
		ftsopts |= FTS_LOGICAL;
	else
		ftsopts |= FTS_PHYSICAL;
	if (Hflag)
		ftsopts |= FTS_COMFOLLOW;
	if (Xflag)
		ftsopts |= FTS_XDEV;

	if ((fthead == NULL) && ((farray[0] = malloc(PAXPATHLEN+2)) == NULL)) {
		paxwarn(1, "%s for %s", "Out of memory",
		    "file name buffer");
		return (-1);
	}

	if (ftree_arg() < 0)
		return(-1);
	if (tflag && (atdir_start() < 0))
		return(-1);
	return(0);
}

/*
 * ftree_add()
 *	add the arg to the linked list of files to process. Each will be
 *	processed by fts one at a time
 * Return:
 *	0 if added to the linked list, -1 if failed
 */

int
ftree_add(char *str, int chflg)
{
	FTREE *ft;
	int len;

	/*
	 * simple check for bad args
	 */
	if ((str == NULL) || (*str == '\0')) {
		paxwarn(0, "Invalid file name argument");
		return(-1);
	}

	/*
	 * allocate FTREE node and add to the end of the linked list (args are
	 * processed in the same order they were passed to pax). Get rid of any
	 * trailing / the user may pass us. (watch out for / by itself).
	 */
	if ((ft = malloc(sizeof(FTREE))) == NULL) {
		paxwarn(0, "%s for %s", "Out of memory",
		    "filename");
		return (-1);
	}

	if (((len = strlen(str) - 1) > 0) && (str[len] == '/'))
		str[len] = '\0';
	ft->fname = str;
	ft->refcnt = 0;
	ft->newercnt = 0;
	ft->chflg = chflg;
	ft->fow = NULL;
	if (fthead == NULL) {
		fttail = fthead = ft;
		return(0);
	}
	fttail->fow = ft;
	fttail = ft;
	return(0);
}

/*
 * ftree_sel()
 *	this entry has been selected by pax. bump up reference count and handle
 *	-n and -d processing.
 */

void
ftree_sel(ARCHD *arcn)
{
	/*
	 * set reference bit for this pattern. This linked list is only used
	 * when file trees are supplied pax as args. The list is not used when
	 * the trees are read from stdin.
	 */
	if (ftcur != NULL)
		ftcur->refcnt = 1;

	/*
	 * if -n we are done with this arg, force a skip to the next arg when
	 * pax asks for the next file in next_file().
	 * if -d we tell fts only to match the directory (if the arg is a dir)
	 * and not the entire file tree rooted at that point.
	 */
	if (nflag)
		ftree_skip = 1;

	if (!dflag || (arcn->type != PAX_DIR))
		return;

	if (ftent != NULL)
		(void)fts_set(ftsp, ftent, FTS_SKIP);
}

/*
 * ftree_skipped_newer()
 *	file has been skipped because a newer file exists and -u/-D given
 */

void
ftree_skipped_newer(void)
{
	/* skipped due to -u/-D, mark accordingly */
	if (ftcur != NULL)
		ftcur->newercnt = 1;
}

/*
 * ftree_chk()
 *	called at end on pax execution. Prints all those file args that did not
 *	have a selected member (reference count still 0)
 */

void
ftree_chk(void)
{
	FTREE *ft;
	int wban = 0;

	/*
	 * make sure all dir access times were reset.
	 */
	if (tflag)
		atdir_end();

	/*
	 * walk down list and check reference count. Print out those members
	 * that never had a match
	 */
	for (ft = fthead; ft != NULL; ft = ft->fow) {
		if ((ft->refcnt > 0) || ft->newercnt > 0 || ft->chflg)
			continue;
		if (wban == 0) {
			paxwarn(1,"WARNING! These file names were not selected:");
			++wban;
		}
		(void)fprintf(stderr, "%s\n", ft->fname);
	}
}

/*
 * ftree_arg()
 *	Get the next file arg for fts to process. Can be from either the linked
 *	list or read from stdin when the user did not them as args to pax. Each
 *	arg is processed until the first successful fts_open().
 * Return:
 *	0 when the next arg is ready to go, -1 if out of file args (or EOF on
 *	stdin).
 */

static int
ftree_arg(void)
{

	/*
	 * close off the current file tree
	 */
	if (ftsp != NULL) {
		(void)fts_close(ftsp);
		ftsp = NULL;
	}

	/*
	 * keep looping until we get a valid file tree to process. Stop when we
	 * reach the end of the list (or get an eof on stdin)
	 */
	for (;;) {
		if (fthead == NULL) {
			/*
			 * the user didn't supply any args, get the file trees
			 * to process from stdin;
			 */
			if (getpathname(farray[0], PAXPATHLEN+1) == NULL)
				return(-1);
		} else {
			/*
			 * the user supplied the file args as arguments to pax
			 */
			if (ftcur == NULL)
				ftcur = fthead;
			else if ((ftcur = ftcur->fow) == NULL)
				return(-1);
			if (ftcur->chflg) {
				/* First fchdir() back... */
				if (fchdir(cwdfd) < 0) {
					syswarn(1, errno,
					  "Cannot fchdir to starting directory");
					return (-1);
				}
				if (chdir(ftcur->fname) < 0) {
					syswarn(1, errno, "Cannot chdir to %s",
					    ftcur->fname);
					return (-1);
				}
				continue;
			} else
				farray[0] = ftcur->fname;
		}

		/*
		 * watch it, fts wants the file arg stored in a array of char
		 * ptrs, with the last one a null. we use a two element array
		 * and set farray[0] to point at the buffer with the file name
		 * in it. We cannot pass all the file args to fts at one shot
		 * as we need to keep a handle on which file arg generates what
		 * files (the -n and -d flags need this). If the open is
		 * successful, return a 0.
		 */
		if ((ftsp = fts_open(farray, ftsopts, NULL)) != NULL)
			break;
	}
	return(0);
}

/*
 * next_file()
 *	supplies the next file to process in the supplied archd structure.
 * Return:
 *	0 when contents of arcn have been set with the next file, -1 when done.
 */

int
next_file(ARCHD *arcn)
{
	int cnt;

	/*
	 * ftree_sel() might have set the ftree_skip flag if the user has the
	 * -n option and a file was selected from this file arg tree. (-n says
	 * only one member is matched for each pattern) ftree_skip being 1
	 * forces us to go to the next arg now.
	 */
	if (ftree_skip) {
		/*
		 * clear and go to next arg
		 */
		ftree_skip = 0;
		if (ftree_arg() < 0)
			return(-1);
	}

	/*
	 * loop until we get a valid file to process
	 */
	for (;;) {
		if ((ftent = fts_read(ftsp)) == NULL) {
			if (errno)
				syswarn(1, errno, "next_file");
			/*
			 * out of files in this tree, go to next arg, if none
			 * we are done
			 */
			if (ftree_arg() < 0)
				return(-1);
			continue;
		}

		/*
		 * handle each type of fts_read() flag
		 */
		switch (ftent->fts_info) {
		case FTS_D:
		case FTS_DEFAULT:
		case FTS_F:
		case FTS_SL:
		case FTS_SLNONE:
			/*
			 * these are all ok
			 */
			break;
		case FTS_DP:
			/*
			 * already saw this directory. If the user wants file
			 * access times reset, we use this to restore the
			 * access time for this directory since this is the
			 * last time we will see it in this file subtree
			 * remember to force the time (this is -t on a read
			 * directory, not a created directory).
			 */
			if (!tflag)
				continue;
			do_atdir(ftent->fts_path, ftent->fts_statp->st_dev,
			    ftent->fts_statp->st_ino);
			continue;
		case FTS_DC:
			/*
			 * fts claims a filesystem cycle
			 */
			paxwarn(1, "Filesystem cycle found at %s", ftent->fts_path);
			continue;
		case FTS_DNR:
			syswarn(1, ftent->fts_errno,
			    "Unable to read directory %s", ftent->fts_path);
			continue;
		case FTS_ERR:
			syswarn(1, ftent->fts_errno,
			    "Filesystem traversal error");
			continue;
		case FTS_NS:
		case FTS_NSOK:
			syswarn(1, ftent->fts_errno,
			    "Unable to access %s", ftent->fts_path);
			continue;
		}

		/*
		 * ok got a file tree node to process. copy info into arcn
		 * structure (initialise as required)
		 */
		arcn->skip = 0;
		arcn->pad = 0;
		arcn->ln_nlen = 0;
		arcn->ln_name[0] = '\0';
		memcpy(&arcn->sb, ftent->fts_statp, sizeof(arcn->sb));

		/*
		 * file type based set up and copy into the arcn struct
		 * SIDE NOTE:
		 * we try to reset the access time on all files and directories
		 * we may read when the -t flag is specified. files are reset
		 * when we close them after copying. we reset the directories
		 * when we are done with their file tree (we also clean up at
		 * end in case we cut short a file tree traversal). However
		 * there is no way to reset access times on symlinks.
		 */
		switch (S_IFMT & arcn->sb.st_mode) {
		case S_IFDIR:
			arcn->type = PAX_DIR;
			if (!tflag)
				break;
			add_atdir(ftent->fts_path, &arcn->sb);
			break;
		case S_IFCHR:
			arcn->type = PAX_CHR;
			break;
		case S_IFBLK:
			arcn->type = PAX_BLK;
			break;
		case S_IFREG:
			/*
			 * only regular files with have data to store on the
			 * archive. all others will store a zero length skip.
			 * the skip field is used by pax for actual data it has
			 * to read (or skip over).
			 */
			arcn->type = PAX_REG;
			arcn->skip = arcn->sb.st_size;
			break;
		case S_IFLNK:
			arcn->type = PAX_SLK;
			/*
			 * have to read the symlink path from the file
			 */
			if ((cnt = readlink(ftent->fts_path, arcn->ln_name,
			    PAXPATHLEN)) < 0) {
				syswarn(1, errno, "Unable to read symlink %s",
				    ftent->fts_path);
				continue;
			}
			/*
			 * set link name length, watch out readlink does not
			 * NUL terminate the link path
			 */
			arcn->ln_name[cnt] = '\0';
			arcn->ln_nlen = cnt;
			break;
		case S_IFSOCK:
			/*
			 * under BSD storing a socket is senseless but we will
			 * let the format specific write function make the
			 * decision of what to do with it.
			 */
			arcn->type = PAX_SCK;
			break;
		case S_IFIFO:
			arcn->type = PAX_FIF;
			break;
		}
		break;
	}

	/*
	 * copy file name, set file name length
	 */
	arcn->nlen = strlcpy(arcn->name, ftent->fts_path, sizeof(arcn->name));
	if ((size_t)arcn->nlen >= sizeof(arcn->name))
		arcn->nlen = sizeof(arcn->name) - 1; /* XXX truncate? */
	arcn->org_name = ftent->fts_path;
	return(0);
}

/*
 * getpathname()
 *	Reads a pathname from stdin, handling NUL- or newline-termination.
 * Return:
 *	NULL at end of file, otherwise the NUL-terminated buffer.
 */

static char *
getpathname(char *buf, int buflen)
{
	char *bp, *ep;
	int ch, term;

	if (zeroflag) {
		/*
		 * Read a NUL-terminated pathname, being especially
		 * paranoid about proper termination and pathname length.
		 */
		for (bp = buf, ep = buf + buflen; bp < ep; bp++) {
			if ((ch = getchar()) == EOF) {
				if (bp != buf)
					paxwarn(1, "Ignoring unterminated "
					    "pathname at EOF");
				return(NULL);
			}
			if ((*bp = ch) == '\0')
				return(buf);
		}
		/* Too long - skip this path */
		*--bp = '\0';
		term = '\0';
	} else {
		if (fgets(buf, buflen, stdin) == NULL)
			return(NULL);
		if ((bp = strchr(buf, '\n')) != NULL || feof(stdin)) {
			if (bp != NULL)
				*bp = '\0';
			return(buf);
		}
		/* Too long - skip this path */
		term = '\n';
	}
	while ((ch = getchar()) != term && ch != EOF)
		continue;
	paxwarn(1, "Ignoring too-long pathname: %s", buf);
	return(NULL);
}
@


1.11
log
@merge the npax branch into MAIN

asides from a missing dprintf and portability, this ought to be
good enough for people (well me) to play with for now
@
text
@d52 1
a52 1
__RCSID("$MirOS: src/bin/pax/ftree.c,v 1.9 2017/08/07 20:10:14 tg Exp $");
d133 3
a135 2
		paxwarn(1, "Unable to allocate memory for file name buffer");
		return(-1);
d173 3
a175 2
		paxwarn(0, "Unable to allocate memory for filename");
		return(-1);
d319 2
a320 2
					  "Can't fchdir to starting directory");
					return(-1);
d323 1
a323 1
					syswarn(1, errno, "Can't chdir to %s",
d325 1
a325 1
					return(-1);
@


1.10
log
@slowmerge (untested though)
@
text
@d37 1
a37 2
#include <sys/param.h>
#include <sys/time.h>
d39 2
a40 2
#include <unistd.h>
#include <string.h>
a41 1
#include <errno.h>
d43 6
a48 2
#include <fts.h>
#include <time.h>
a49 1
#include "ftree.h"
d53 12
a64 1
__IDSTRING(rcsid_ftree_h, MIRCPIO_FTREE_H);
d171 1
a171 1
	if ((ft = (FTREE *)malloc(sizeof(FTREE))) == NULL) {
d419 1
a419 1
			paxwarn(1,"Filesystem cycle found at %s",ftent->fts_path);
d461 1
a461 3
			add_atdir(ftent->fts_path, arcn->sb.st_dev,
			    arcn->sb.st_ino, arcn->sb.st_mtime,
			    arcn->sb.st_atime);
d492 1
a492 1
			 * always NUL terminate the link path
d565 1
a565 1
		;
@


1.9
log
@filesystem
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.29 2009/10/27 23:59:22 deraadt Exp $	*/
d51 1
a51 1
__RCSID("$MirOS: src/bin/pax/ftree.c,v 1.8 2016/03/06 14:12:27 tg Exp $");
@


1.8
log
@version the *.h files as idstrings, too
@
text
@d51 1
a51 1
__RCSID("$MirOS: src/bin/pax/ftree.c,v 1.5 2012/02/12 00:44:57 tg Exp $");
d405 1
a405 1
			 * fts claims a file system cycle
d407 1
a407 1
			paxwarn(1,"File system cycle found at %s",ftent->fts_path);
d415 1
a415 1
			    "File system traversal error");
@


1.7
log
@merge CVE fixes from openbsd branch
@
text
@d52 1
@


1.6
log
@get rid of extern.h including other headers
@
text
@a342 2
	time_t atime;
	time_t mtime;
d397 1
a397 2
			if (!tflag || (get_atdir(ftent->fts_statp->st_dev,
			    ftent->fts_statp->st_ino, &mtime, &atime) < 0))
d399 2
a400 1
			set_ftime(ftent->fts_path, mtime, atime, 1);
@


1.5
log
@spelling
@
text
@d46 1
d51 1
a51 1
__RCSID("$MirOS: src/bin/pax/ftree.c,v 1.4 2012/02/12 00:27:16 tg Exp $");
@


1.4
log
@merge OpenBSD
@
text
@d50 1
a50 1
__RCSID("$MirOS: src/bin/pax/ftree.c,v 1.3 2007/10/23 20:07:42 tg Exp $");
d80 1
a80 1
 *	initialize the options passed to fts_open() during this run of pax
d426 1
a426 1
		 * structure (initialize as required)
@


1.3
log
@merge openbsd changes and fix tar -R, -S flag misdocumentation
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.27 2006/12/26 20:58:25 otto Exp $	*/
d50 1
a50 2
__SCCSID("@@(#)ftree.c	8.2 (Berkeley) 4/18/94");
__RCSID("$MirOS: src/bin/pax/ftree.c,v 1.2 2007/02/17 04:52:40 tg Exp $");
d166 1
d212 13
d247 1
a247 1
		if ((ft->refcnt > 0) || ft->chflg)
@


1.2
log
@__CRAZY clean
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.26 2005/04/21 21:47:18 beck Exp $	*/
d51 1
a51 1
__RCSID("$MirOS$");
d352 2
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.25 2004/04/16 22:50:23 deraadt Exp $	*/
d37 1
a37 9
#ifndef lint
#if 0
static const char sccsid[] = "@@(#)ftree.c	8.2 (Berkeley) 4/18/94";
#else
static const char rcsid[] = "$OpenBSD: ftree.c,v 1.25 2004/04/16 22:50:23 deraadt Exp $";
#endif
#endif /* not lint */

#include <sys/types.h>
a39 1
#include <sys/param.h>
d50 3
d491 2
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@improve my Frankenstein OS (*wink* you know who you are) further
sans wchar_t of course

this is the essence of reading >1200 commit messages which suck
due to not having the new format of ours...
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.26 2005/04/21 21:47:18 beck Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: ftree.c,v 1.26 2005/04/21 21:47:18 beck Exp $";
a496 2
	if (arcn->nlen >= sizeof(arcn->name))
		arcn->nlen = sizeof(arcn->name) - 1; /* XXX truncate? */
@


1.1.1.3
log
@import latest OpenCPIO ☺
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.27 2006/12/26 20:58:25 otto Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: ftree.c,v 1.27 2006/12/26 20:58:25 otto Exp $";
a357 2
			if (errno)
				syswarn(1, errno, "next_file");
@


1.1.1.4
log
@import up-to-date pax from OpenBSD 5.1-current
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.29 2009/10/27 23:59:22 deraadt Exp $	*/
d37 8
a172 1
	ft->newercnt = 0;
a217 13
 * ftree_skipped_newer()
 *	file has been skipped because a newer file exists and -u/-D given
 */

void
ftree_skipped_newer(ARCHD *arcn)
{
	/* skipped due to -u/-D, mark accordingly */
	if (ftcur != NULL)
		ftcur->newercnt = 1;
}

/*
d240 1
a240 1
		if ((ft->refcnt > 0) || ft->newercnt > 0 || ft->chflg)
@


1.1.1.5
log
@pull newer paxtar from OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.38 2015/03/19 05:14:24 guenther Exp $	*/
d40 1
d156 1
a156 1
	if ((ft = malloc(sizeof(FTREE))) == NULL) {
d341 2
d397 2
a398 1
			if (!tflag)
d400 1
a400 2
			do_atdir(ftent->fts_path, ftent->fts_statp->st_dev,
			    ftent->fts_statp->st_ino);
d449 2
a450 2
			    arcn->sb.st_ino, &arcn->sb.st_mtim,
			    &arcn->sb.st_atim);
d481 1
a481 1
			 * NUL terminate the link path
@


1.1.1.6
log
@revert the import; we’ll just backport the CVE fixes, for now ☹
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.29 2009/10/27 23:59:22 deraadt Exp $	*/
a39 1
#include <sys/param.h>
d155 1
a155 1
	if ((ft = (FTREE *)malloc(sizeof(FTREE))) == NULL) {
a339 2
	time_t atime;
	time_t mtime;
d394 1
a394 2
			if (!tflag || (get_atdir(ftent->fts_statp->st_dev,
			    ftent->fts_statp->st_ino, &mtime, &atime) < 0))
d396 2
a397 1
			set_ftime(ftent->fts_path, mtime, atime, 1);
d446 2
a447 2
			    arcn->sb.st_ino, arcn->sb.st_mtime,
			    arcn->sb.st_atime);
d478 1
a478 1
			 * always NUL terminate the link path
@


1.1.1.7
log
@backport OpenBSD pax erratum, more specifically:

• directory bug, symlinks with -C bug
• escaping with .. and symlinks
• tar without -P
• validate directories touched in the cleanup phase
@
text
@d341 2
d397 2
a398 1
			if (!tflag)
d400 1
a400 2
			do_atdir(ftent->fts_path, ftent->fts_statp->st_dev,
			    ftent->fts_statp->st_ino);
@


1.1.1.8
log
@merge what OpenBSD did between our last cherry-pick and today minus one commit

(“Use the new libc uid_from_user() and gid_from_group() instead of
  the pax-specific functions in cache.c” is ignored, for now)
@
text
@d1 1
a1 1
/*	$OpenBSD: ftree.c,v 1.41 2017/09/16 07:42:34 otto Exp $	*/
d503 1
a503 1
	if ((size_t)arcn->nlen >= sizeof(arcn->name))
@


1.1.1.9
log
@Import latest OpenBSD paxtar, unmodified, into vendor branch
@
text
@d38 1
d40 4
d45 1
a46 5
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

d48 1
a51 13
 * Data structure used to store the file args to be handed to fts().
 * It keeps track of which args generated a "selected" member.
 */
typedef struct ftree {
	char		*fname;		/* file tree name */
	int		refcnt;		/* has tree had a selected file? */
	int		newercnt;	/* skipped due to -u/-D */
	int		chflg;		/* change directory flag */
	struct ftree	*fow;		/* pointer to next entry on list */
} FTREE;


/*
d156 1
a156 1
	if ((ft = malloc(sizeof(FTREE))) == NULL) {
d447 2
a448 2
			    arcn->sb.st_ino, &arcn->sb.st_mtim,
			    &arcn->sb.st_atim);
d479 1
a479 1
			 * NUL terminate the link path
d552 1
a552 1
		continue;
@


1.1.1.9.2.1
log
@normalise whitespace at EOL, EOF, adjacent newlines
@
text
@d61 1
@


1.1.1.9.2.2
log
@extremely rudimentary conversion to mirtoconf, doesn’t even build yet
@
text
@a43 3
#if HAVE_STRINGS_H
#include <strings.h>
#endif
@


1.1.1.9.2.3
log
@do the ‘c’s
@
text
@d415 1
a415 1
			 * fts claims a filesystem cycle
d417 1
a417 1
			paxwarn(1,"Filesystem cycle found at %s",ftent->fts_path);
d425 1
a425 1
			    "Filesystem traversal error");
@


1.1.1.9.2.4
log
@do extern.h, but we’ll have to do something about time values
@
text
@d229 1
a229 1
ftree_skipped_newer(void)
@


1.1.1.9.2.5
log
@solve one of the two API issues
@
text
@d459 3
a461 1
			add_atdir(ftent->fts_path, &arcn->sb);
@


1.1.1.9.2.6
log
@do the ‘f’s
@
text
@d92 1
a92 1
 *	initialise the options passed to fts_open() during this run of pax
d417 1
a417 1
			paxwarn(1, "Filesystem cycle found at %s", ftent->fts_path);
d436 1
a436 1
		 * structure (initialise as required)
@


