head	1.24;
access;
symbols
	paxmirabilis-20190825:1.24
	paxmirabilis-20190224:1.24
	paxmirabilis-20190210:1.23
	npax:1.1.1.10.0.2
	cvs-20181212:1.1.1.10
	paxmirabilis-20171021:1.19
	paxmirabilis-20161104:1.17
	paxmirabilis-20161031:1.17
	paxmirabilis-20161025:1.17
	paxmirabilis-20160306:1.15
	cvs-201603041945:1.1.1.6
	paxmirabilis-20151013:1.14
	paxmirabilis-20140703:1.14
	paxmirabilis-20120606:1.14
	paxmirabilis-20120605:1.14
	cvs-201206051745:1.1.1.5
	paxmirabilis-20120520:1.13
	paxmirabilis-20120216:1.12
	paxmirabilis-20120212:1.10
	cvs-201202112230:1.1.1.5
	paxmirabilis-20110817:1.9
	MIRBSD_10:1.4.0.2
	MIRBSD_10_BASE:1.4
	cvs-200710231945:1.1.1.4
	cvs-200606232242:1.1.1.4
	MIRBSD_9_BASE:1.3
	MIRBSD_8:1.1.1.3.0.2
	MIRBSD_8_BASE:1.1.1.3
	cvs-200507211800:1.1.1.3
	cvs-200504291700:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2019.02.23.22.39.25;	author tg;	state Exp;
branches;
next	1.23;
commitid	1005C71CBA542A18B5C;

1.23
date	2019.02.10.21.50.08;	author tg;	state Exp;
branches;
next	1.22;
commitid	1005C609C8F43A9BDCB;

1.22
date	2018.12.13.07.09.12;	author tg;	state Exp;
branches;
next	1.21;
commitid	1005C1205A44B32AFA4;

1.21
date	2018.12.12.18.08.48;	author tg;	state Exp;
branches;
next	1.20;
commitid	1005C114EA81986F5EC;

1.20
date	2018.12.12.00.23.08;	author tg;	state Exp;
branches;
next	1.19;
commitid	1005C1054FE750D63F3;

1.19
date	2017.10.21.19.05.43;	author tg;	state Exp;
branches;
next	1.18;
commitid	10059EB9A9C00C50C75;

1.18
date	2017.08.07.20.10.19;	author tg;	state Exp;
branches;
next	1.17;
commitid	1005988C69344442E37;

1.17
date	2016.10.25.18.57.56;	author tg;	state Exp;
branches;
next	1.16;
commitid	100580FAB4B20AD4FA2;

1.16
date	2016.03.12.13.20.48;	author tg;	state Exp;
branches;
next	1.15;
commitid	10056E417C13E8BF870;

1.15
date	2016.03.06.13.47.12;	author tg;	state Exp;
branches;
next	1.14;
commitid	10056DC34E25F0AA0A6;

1.14
date	2012.06.05.18.22.58;	author tg;	state Exp;
branches;
next	1.13;
commitid	1004FCE4E961DE91080;

1.13
date	2012.05.20.16.13.19;	author tg;	state Exp;
branches;
next	1.12;
commitid	1004FB918314D2FECC0;

1.12
date	2012.02.16.17.27.32;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004F3D3C992B2187A1;

1.11
date	2012.02.16.17.11.46;	author tg;	state Exp;
branches;
next	1.10;
commitid	1004F3D38626EFD0781;

1.10
date	2012.02.12.00.27.18;	author tg;	state Exp;
branches;
next	1.9;
commitid	1004F3707786D20BF4A;

1.9
date	2011.08.16.21.32.49;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004E4AE1EF00AF3003;

1.8
date	2011.08.16.13.50.18;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004E4A75A9095E9071;

1.7
date	2011.08.16.13.45.02;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004E4A74015B88F988;

1.6
date	2011.08.16.13.27.03;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004E4A702C39E0597C;

1.5
date	2009.10.04.14.54.56;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004AC8B74E47D9C64F;

1.4
date	2007.02.17.04.52.41;	author tg;	state Exp;
branches;
next	1.3;
commitid	10045D68A2D54E2C558;

1.3
date	2006.06.23.23.03.57;	author tg;	state Exp;
branches;
next	1.2;
commitid	100449C736877C98FFB;

1.2
date	2006.06.19.20.31.06;	author tg;	state Exp;
branches;
next	1.1;
commitid	100449709733F6F9BF6;

1.1
date	2005.02.05.17.22.06;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.22.06;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.29.17.05.16;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.07.21.20.45.28;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	560042e0092f571e;

1.1.1.4
date	2006.06.23.23.00.17;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	100449C727D31170AA3;

1.1.1.5
date	2012.02.11.22.47.22;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	1004F36F008225F3522;

1.1.1.6
date	2016.03.04.19.46.09;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	10056D9E61429EE6550;

1.1.1.7
date	2016.03.04.20.55.04;	author tg;	state Exp;
branches;
next	1.1.1.8;
commitid	10056D9F62E152ECBA5;

1.1.1.8
date	2016.10.25.18.46.12;	author tg;	state Exp;
branches;
next	1.1.1.9;
commitid	100580FA88137705D31;

1.1.1.9
date	2018.12.12.00.15.08;	author tg;	state Exp;
branches;
next	1.1.1.10;
commitid	1005C1052FA5E745A2C;

1.1.1.10
date	2018.12.12.00.24.23;	author tg;	state Exp;
branches
	1.1.1.10.2.1;
next	;
commitid	1005C1055452C78F9E4;

1.1.1.10.2.1
date	2018.12.12.00.53.01;	author tg;	state Exp;
branches;
next	1.1.1.10.2.2;
commitid	1005C105BC86262A0B7;

1.1.1.10.2.2
date	2018.12.12.00.54.17;	author tg;	state Exp;
branches;
next	1.1.1.10.2.3;
commitid	1005C105C48612B0194;

1.1.1.10.2.3
date	2018.12.12.03.13.35;	author tg;	state Exp;
branches;
next	1.1.1.10.2.4;
commitid	1005C107CE315DC51F3;

1.1.1.10.2.4
date	2018.12.12.06.03.15;	author tg;	state Exp;
branches;
next	1.1.1.10.2.5;
commitid	1005C10A4B12E5998CE;

1.1.1.10.2.5
date	2018.12.12.14.16.24;	author tg;	state Exp;
branches;
next	1.1.1.10.2.6;
commitid	1005C11184842A35A8D;

1.1.1.10.2.6
date	2018.12.12.15.33.05;	author tg;	state Exp;
branches;
next	1.1.1.10.2.7;
commitid	1005C112A434F807902;

1.1.1.10.2.7
date	2018.12.12.15.57.33;	author tg;	state Exp;
branches;
next	;
commitid	1005C11300575B1CEE0;


desc
@@


1.24
log
@fix -M uidgid not working for ustar (refactoro/mergo), oops…
@
text
@/*	$OpenBSD: tar.c,v 1.67 2018/09/13 12:33:43 millert Exp $	*/
/*	$NetBSD: tar.c,v 1.5 1995/03/21 09:07:49 cgd Exp $	*/

/*-
 * Copyright (c) 2006, 2012, 2016, 2017, 2019
 *	mirabilos <m@@mirbsd.org>
 * Copyright (c) 1992 Keith Muller.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <ctype.h>
#include <errno.h>
#if HAVE_GRP_H
#include <grp.h>
#endif
#include <limits.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if HAVE_STRINGS_H
#include <strings.h>
#endif
#include <unistd.h>

#include "pax.h"
#include "extern.h"
#include "tar.h"

__RCSID("$MirOS: src/bin/pax/tar.c,v 1.23 2019/02/10 21:50:08 tg Exp $");

/*
 * Routines for reading, writing and header identify of various versions of tar
 */

static size_t expandname(char *, size_t, char **, const char *, size_t);
static u_long tar_chksm(char *, int);
static char *name_split(char *, int);
static int ul_oct(u_long, char *, int, int);
static int ull_oct(unsigned long long, char *, int, int);
#ifndef SMALL
static void tar_dbgfld(const char *, const char *, size_t);
static int rd_xheader(ARCHD *arcn, int, off_t);
#endif

static uid_t uid_nobody;
static uid_t uid_warn;
static gid_t gid_nobody;
static gid_t gid_warn;

/*
 * Routines common to all versions of tar
 */

#ifndef SMALL
char tar_nodir;				/* do not write dirs under old tar */
#endif
char *gnu_name_string;			/* GNU ././@@LongLink hackery name */
char *gnu_link_string;			/* GNU ././@@LongLink hackery link */

/*
 * tar_endwr()
 *	add the tar trailer of two null blocks
 * Return:
 *	0 if ok, -1 otherwise (what wr_skip returns)
 */

int
tar_endwr(void)
{
	return (wr_skip(NULLCNT * BLKMULT));
}

/*
 * tar_endrd()
 *	no cleanup needed here, just return size of trailer (for append)
 * Return:
 *	size of trailer (2 * BLKMULT)
 */

off_t
tar_endrd(void)
{
	return (NULLCNT * BLKMULT);
}

/*
 * tar_trail()
 *	Called to determine if a header block is a valid trailer. We are passed
 *	the block, the in_sync flag (which tells us we are in resync mode;
 *	looking for a valid header), and cnt (which starts at zero) which is
 *	used to count the number of empty blocks we have seen so far.
 * Return:
 *	0 if a valid trailer, -1 if not a valid trailer, or 1 if the block
 *	could never contain a header.
 */

int
tar_trail(ARCHD *ignore MKSH_A_UNUSED, char *buf, int in_resync, int *cnt)
{
	int i;

	/*
	 * look for all zero, trailer is two consecutive blocks of zero
	 */
	for (i = 0; i < BLKMULT; ++i) {
		if (buf[i] != '\0')
			break;
	}

	/*
	 * if not all zero it is not a trailer, but MIGHT be a header.
	 */
	if (i != BLKMULT)
		return(-1);

	/*
	 * When given a zero block, we must be careful!
	 * If we are not in resync mode, check for the trailer. Have to watch
	 * out that we do not mis-identify file data as the trailer, so we do
	 * NOT try to id a trailer during resync mode. During resync mode we
	 * might as well throw this block out since a valid header can NEVER be
	 * a block of all 0 (we must have a valid file name).
	 */
	if (!in_resync && (++*cnt >= NULLCNT))
		return(0);
	return(1);
}

/*
 * ul_oct()
 *	convert an unsigned long to an octal string. many oddball field
 *	termination characters are used by the various versions of tar in the
 *	different fields. term selects which kind to use. str is '0' padded
 *	at the front to len. we are unable to use only one format as many old
 *	tar readers are very cranky about this.
 * Return:
 *	0 if the number fit into the string, -1 otherwise
 */

static int
ul_oct(u_long val, char *str, int len, int term)
{
	char *pt;

	/*
	 * term selects the appropriate character(s) for the end of the string
	 */
	pt = str + len - 1;
	switch (term) {
	case 3:
		*pt-- = '\0';
		break;
	case 2:
		*pt-- = ' ';
		*pt-- = '\0';
		break;
	case 1:
		*pt-- = ' ';
		break;
	case 0:
	default:
		*pt-- = '\0';
		*pt-- = ' ';
		break;
	}

	/*
	 * convert and blank pad if there is space
	 */
	while (pt >= str) {
		*pt-- = '0' + (char)(val & 0x7);
		val >>= 3;
		if (val == 0)
			break;
	}

	while (pt >= str)
		*pt-- = '0';
	if (val != 0)
		return(-1);
	return(0);
}

/*
 * ull_oct()
 *	Convert an unsigned long long to an octal string.  One of many oddball
 *	field termination characters are used by the various versions of tar
 *	in the different fields.  term selects which kind to use.  str is
 *	'0' padded at the front to len.  We are unable to use only one format
 *	as many old tar readers are very cranky about this.
 * Return:
 *	0 if the number fit into the string, -1 otherwise
 */

static int
ull_oct(unsigned long long val, char *str, int len, int term)
{
	char *pt;

	/*
	 * term selects the appropriate character(s) for the end of the string
	 */
	pt = str + len - 1;
	switch (term) {
	case 3:
		*pt-- = '\0';
		break;
	case 2:
		*pt-- = ' ';
		*pt-- = '\0';
		break;
	case 1:
		*pt-- = ' ';
		break;
	case 0:
	default:
		*pt-- = '\0';
		*pt-- = ' ';
		break;
	}

	/*
	 * convert and blank pad if there is space
	 */
	while (pt >= str) {
		*pt-- = '0' + (char)(val & 0x7);
		val >>= 3;
		if (val == 0)
			break;
	}

	while (pt >= str)
		*pt-- = '0';
	if (val != 0)
		return(-1);
	return(0);
}

/*
 * tar_chksm()
 *	calculate the checksum for a tar block counting the checksum field as
 *	all blanks (BLNKSUM is that value pre-calculated, the sum of 8 blanks).
 *	NOTE: we use len to short circuit summing 0's on write since we ALWAYS
 *	pad headers with 0.
 * Return:
 *	unsigned long checksum
 */

static u_long
tar_chksm(char *blk, int len)
{
	char *stop;
	char *pt;
	u_long chksm = BLNKSUM;	/* initial value is checksum field sum */

	/*
	 * add the part of the block before the checksum field
	 */
	pt = blk;
	stop = blk + CHK_OFFSET;
	while (pt < stop)
		chksm += (u_long)(*pt++ & 0xff);
	/*
	 * move past the checksum field and keep going, spec counts the
	 * checksum field as the sum of 8 blanks (which is pre-computed as
	 * BLNKSUM).
	 * ASSUMED: len is greater than CHK_OFFSET. (len is where our 0 padding
	 * starts, no point in summing zero's)
	 */
	pt += CHK_LEN;
	stop = blk + len;
	while (pt < stop)
		chksm += (u_long)(*pt++ & 0xff);
	return(chksm);
}

#ifndef SMALL
/*
 * Routines for old BSD style tar (also made portable to sysV tar)
 */

/*
 * tar_id()
 *	determine if a block given to us is a valid tar header (and not a USTAR
 *	header). We have to be on the lookout for those pesky blocks of	all
 *	zero's.
 * Return:
 *	0 if a tar header, -1 otherwise
 */

int
tar_id(char *blk, int size)
{
	HD_TAR *hd;
	HD_USTAR *uhd;

	if (size < BLKMULT)
		return (-1);
	hd = (HD_TAR *)blk;
	uhd = (HD_USTAR *)blk;

	/*
	 * check for block of NULs first, a simple and fast test, then make
	 * sure this is not a ustar header by looking for the ustar magic
	 * cookie. We should use TMAGLEN, but some USTAR archive programs are
	 * wrong and create archives missing the \0. Last we check the
	 * checksum. If this is ok we have to assume it is a valid header.
	 */
	if (hd->name[0] == '\0')
		return (-1);
	if (memcmp(uhd->magic, TMAGIC, TMAGLEN - 1) == 0)
		return (-1);
	if (asc_ul(hd->chksum, sizeof(hd->chksum), OCT) != tar_chksm(blk, BLKMULT))
		return (-1);
	force_one_volume = 1;
	return (0);
}

/*
 * tar_opt()
 *	handle tar format specific -o options
 * Return:
 *	0 if ok -1 otherwise
 */

int
tar_opt(void)
{
	OPLIST *opt;

	while ((opt = opt_next()) != NULL) {
		if (strcmp(opt->name, TAR_OPTION) ||
		    strcmp(opt->value, TAR_NODIR)) {
			paxwarn(1, "Unknown tar format -o option/value pair %s=%s",
			    opt->name, opt->value);
			paxwarn(1,"%s=%s is the only supported tar format option",
			    TAR_OPTION, TAR_NODIR);
			return(-1);
		}

		/*
		 * we only support one option, and only when writing
		 */
		if ((act != APPND) && (act != ARCHIVE)) {
			paxwarn(1, "%s=%s is only supported when writing.",
			    opt->name, opt->value);
			return(-1);
		}
		tar_nodir = 1;
	}
	return(0);
}

/*
 * tar_rd()
 *	extract the values out of block already determined to be a tar header.
 *	store the values in the ARCHD parameter.
 * Return:
 *	0
 */

int
tar_rd(ARCHD *arcn, char *buf)
{
	HD_TAR *hd;
	unsigned long long val;
	char *pt;

	/*
	 * we only get proper sized buffers passed to us
	 */
	if (tar_id(buf, BLKMULT) < 0)
		return(-1);
	memset(arcn, 0, sizeof(*arcn));
	arcn->org_name = arcn->name;
	arcn->sb.st_nlink = 1;

	/*
	 * copy out the name and values in the stat buffer
	 */
	hd = (HD_TAR *)buf;
	if (hd->linkflag != LONGLINKTYPE && hd->linkflag != LONGNAMETYPE) {
		arcn->nlen = expandname(arcn->name, sizeof(arcn->name),
		    &gnu_name_string, hd->name, sizeof(hd->name));
		arcn->ln_nlen = expandname(arcn->ln_name, sizeof(arcn->ln_name),
		    &gnu_link_string, hd->linkname, sizeof(hd->linkname));
	}
	arcn->sb.st_mode = (mode_t)(asc_ul(hd->mode,sizeof(hd->mode),OCT) &
	    0xfff);
	arcn->sb.st_uid = (uid_t)asc_ul(hd->uid, sizeof(hd->uid), OCT);
	arcn->sb.st_gid = (gid_t)asc_ul(hd->gid, sizeof(hd->gid), OCT);
	arcn->sb.st_size = (off_t)asc_ull(hd->size, sizeof(hd->size), OCT);
	val = asc_ull(hd->mtime, sizeof(hd->mtime), OCT);
	if (val > MAX_TIME_T)
		arcn->sb.st_mtime = INT_MAX;                    /* XXX 2038 */
	else
		arcn->sb.st_mtime = val;
	arcn->sb.st_ctime = arcn->sb.st_atime = arcn->sb.st_mtime;

	/*
	 * have to look at the last character, it may be a '/' and that is used
	 * to encode this as a directory
	 */
	pt = arcn->nlen > 0 ? &(arcn->name[arcn->nlen - 1]) : NULL;
	arcn->pad = 0;
	arcn->skip = 0;
	switch (hd->linkflag) {
	case SYMTYPE:
		/*
		 * symbolic link, need to get the link name and set the type in
		 * the st_mode so -v printing will look correct.
		 */
		arcn->type = PAX_SLK;
		arcn->sb.st_mode |= S_IFLNK;
		break;
	case LNKTYPE:
		/*
		 * hard link, need to get the link name, set the type in the
		 * st_mode and st_nlink so -v printing will look better.
		 */
		arcn->type = PAX_HLK;
		arcn->sb.st_nlink = 2;

		/*
		 * no idea of what type this thing really points at, but
		 * we set something for printing only.
		 */
		arcn->sb.st_mode |= S_IFREG;
		break;
	case LONGLINKTYPE:
	case LONGNAMETYPE:
		/*
		 * GNU long link/file; we tag these here and let the
		 * pax internals deal with it -- too ugly otherwise.
		 */
		arcn->type =
		    hd->linkflag == LONGLINKTYPE ? PAX_GLL : PAX_GLF;
		arcn->pad = TAR_PAD(arcn->sb.st_size);
		arcn->skip = arcn->sb.st_size;
		break;
	case DIRTYPE:
		/*
		 * It is a directory, set the mode for -v printing
		 */
		arcn->type = PAX_DIR;
		arcn->sb.st_mode |= S_IFDIR;
		arcn->sb.st_nlink = 2;
		break;
	case AREGTYPE:
	case REGTYPE:
	default:
		/*
		 * If we have a trailing / this is a directory and NOT a file.
		 */
		arcn->ln_name[0] = '\0';
		arcn->ln_nlen = 0;
		if (pt && *pt == '/') {
			/*
			 * it is a directory, set the mode for -v printing
			 */
			arcn->type = PAX_DIR;
			arcn->sb.st_mode |= S_IFDIR;
			arcn->sb.st_nlink = 2;
		} else {
			/*
			 * have a file that will be followed by data. Set the
			 * skip value to the size field and calculate the size
			 * of the padding.
			 */
			arcn->type = PAX_REG;
			arcn->sb.st_mode |= S_IFREG;
			arcn->pad = TAR_PAD(arcn->sb.st_size);
			arcn->skip = arcn->sb.st_size;
		}
		break;
	}

	/*
	 * strip off any trailing slash.
	 */
	if (pt && *pt == '/') {
		*pt = '\0';
		--arcn->nlen;
	}
	return (0);
}

/*
 * tar_wr()
 *	write a tar header for the file specified in the ARCHD to the archive.
 *	Have to check for file types that cannot be stored and file names that
 *	are too long. Be careful of the term (last arg) to ul_oct, each field
 *	of tar has it own spec for the termination character(s).
 *	ASSUMED: space after header in header block is zero filled
 * Return:
 *	0 if file has data to be written after the header, 1 if file has NO
 *	data to write after the header, -1 if archive write failed
 */

int
tar_wr(ARCHD *arcn)
{
	HD_TAR *hd;
	int len;
	char hdblk[sizeof(HD_TAR)];

	/*
	 * check for those filesystem types which tar cannot store
	 */
	switch (arcn->type) {
	case PAX_DIR:
#ifndef SMALL
		/*
		 * user asked that dirs not be written to the archive
		 */
		if (tar_nodir)
			return(1);
#endif
		break;
	case PAX_CHR:
		paxwarn(1, "%s cannot archive a %s %s",
		    "tar", "character device", arcn->org_name);
		return (1);
	case PAX_BLK:
		paxwarn(1, "%s cannot archive a %s %s",
		    "tar", "block device", arcn->org_name);
		return (1);
	case PAX_SCK:
		paxwarn(1, "%s cannot archive a %s %s",
		    "tar", "socket", arcn->org_name);
		return (1);
	case PAX_FIF:
		paxwarn(1, "%s cannot archive a %s %s",
		    "tar", "FIFO", arcn->org_name);
		return (1);
	case PAX_SLK:
	case PAX_HLK:
	case PAX_HRG:
		if ((size_t)arcn->ln_nlen > sizeof(hd->linkname)) {
			paxwarn(1, "%s name too long for %s %s",
			    "Link", "tar", arcn->ln_name);
			return (1);
		}
		break;
	case PAX_REG:
	case PAX_CTG:
	default:
		break;
	}

	/*
	 * check file name len, remember extra char for dirs (the / at the end)
	 */
	len = arcn->nlen;
	if (arcn->type == PAX_DIR)
		++len;
	if ((size_t)len > sizeof(hd->name)) {
		paxwarn(1, "%s name too long for %s %s",
		    "File", "tar", arcn->name);
		return (1);
	}

	/*
	 * Copy the data out of the ARCHD into the tar header based on the type
	 * of the file. Remember, many tar readers want all fields to be
	 * padded with zero so we zero the header first.  We then set the
	 * linkflag field (type), the linkname, the size, and set the padding
	 * (if any) to be added after the file data (0 for all other types,
	 * as they only have a header).
	 */
	memset(hdblk, 0, sizeof(hdblk));
	hd = (HD_TAR *)hdblk;
	fieldcpy(hd->name, sizeof(hd->name), arcn->name, sizeof(arcn->name));
	arcn->pad = 0;

	if (arcn->type == PAX_DIR) {
		/*
		 * directories are the same as files, except have a filename
		 * that ends with a /, we add the slash here. No data follows
		 * dirs, so no pad.
		 */
		hd->linkflag = AREGTYPE;
		hd->name[len-1] = '/';
		if (ul_oct(0, hd->size, sizeof(hd->size), 1))
			goto out;
	} else if (arcn->type == PAX_SLK) {
		/*
		 * no data follows this file, so no pad
		 */
		hd->linkflag = SYMTYPE;
		fieldcpy(hd->linkname, sizeof(hd->linkname), arcn->ln_name,
		    sizeof(arcn->ln_name));
		if (ul_oct(0, hd->size, sizeof(hd->size), 1))
			goto out;
	} else if (PAX_IS_HARDLINK(arcn->type)) {
		/*
		 * no data follows this file, so no pad
		 */
		hd->linkflag = LNKTYPE;
		fieldcpy(hd->linkname, sizeof(hd->linkname), arcn->ln_name,
		    sizeof(arcn->ln_name));
		if (ul_oct(0, hd->size, sizeof(hd->size), 1))
			goto out;
	} else {
		/*
		 * data follows this file, so set the pad
		 */
		hd->linkflag = AREGTYPE;
		if (ull_oct(arcn->sb.st_size, hd->size, sizeof(hd->size), 1)) {
			paxwarn(1, "File is too large for %s format %s",
			    "tar", arcn->org_name);
			return (1);
		}
		arcn->pad = TAR_PAD(arcn->sb.st_size);
	}

	/*
	 * copy those fields that are independent of the type
	 */
	if (ul_oct(arcn->sb.st_mode, hd->mode, sizeof(hd->mode), 0) ||
	    ull_oct(arcn->sb.st_mtime < 0 ? 0 : arcn->sb.st_mtime, hd->mtime,
		sizeof(hd->mtime), 1) ||
	    ul_oct(arcn->sb.st_uid, hd->uid, sizeof(hd->uid), 0) ||
	    ul_oct(arcn->sb.st_gid, hd->gid, sizeof(hd->gid), 0))
		goto out;

	/*
	 * calculate and add the checksum, then write the header. A return of
	 * 0 tells the caller to now write the file data, 1 says no data needs
	 * to be written
	 */
	if (ul_oct(tar_chksm(hdblk, sizeof(HD_TAR)), hd->chksum,
	    sizeof(hd->chksum), 3))
		goto out;
	if (wr_rdbuf(hdblk, sizeof(HD_TAR)) < 0)
		return(-1);
	if (wr_skip(BLKMULT - sizeof(HD_TAR)) < 0)
		return(-1);
	if (PAX_IS_REG(arcn->type))
		return(0);
	return(1);

 out:
	/*
	 * header field is out of range
	 */
	paxwarn(1, "%s header field is too small for file %s",
	    "tar", arcn->org_name);
	return (1);
}
#endif

/*
 * Routines for POSIX ustar
 */

/*
 * ustar_strd()
 *	initialization for ustar read
 * Return:
 *	0 if ok, -1 otherwise
 */

int
ustar_strd(void)
{
#if !HAVE_UGID_FROM_UG
	if ((usrtb_start() < 0) || (grptb_start() < 0))
		return(-1);
#endif
	return(0);
}

/*
 * ustar_stwr()
 *	initialization for ustar write
 * Return:
 *	0 if ok, -1 otherwise
 */

int
ustar_stwr(int is_app MKSH_A_UNUSED)
{
#if !HAVE_UG_FROM_UGID
	if ((uidtb_start() < 0) || (gidtb_start() < 0))
		return(-1);
#endif
	return(0);
}

/*
 * ustar_id()
 *	determine if a block given to us is a valid ustar header. We have to
 *	be on the lookout for those pesky blocks of all zero's
 * Return:
 *	0 if a ustar header, -1 otherwise
 */

int
ustar_id(char *blk, int size)
{
	HD_USTAR *hd;

	if (size < BLKMULT)
		return (-1);
	hd = (HD_USTAR *)blk;

	/*
	 * check for block of NULs first, a simple and fast test, then check
	 * ustar magic cookie. We should use TMAGLEN, but some USTAR archive
	 * programs are fouled up and create archives missing the \0. Last we
	 * check the checksum. If ok we have to assume it is a valid header.
	 */
	if (hd->prefix[0] == '\0' && hd->name[0] == '\0')
		return (-1);
	if (memcmp(hd->magic, TMAGIC, TMAGLEN - 1) != 0)
		return (-1);
	if (asc_ul(hd->chksum, sizeof(hd->chksum), OCT) != tar_chksm(blk, BLKMULT))
		return (-1);
	return (0);
}

/*
 * ustar_rd()
 *	extract the values out of block already determined to be a ustar header.
 *	store the values in the ARCHD parameter.
 * Return:
 *	0
 */

int
ustar_rd(ARCHD *arcn, char *buf)
{
	HD_USTAR *hd = (HD_USTAR *)buf;
	char *dest;
	int cnt = 0;
	dev_t devmajor;
	dev_t devminor;
	unsigned long long val;

	/*
	 * we only get proper sized buffers
	 */
	if (ustar_id(buf, BLKMULT) < 0)
		return(-1);

#ifndef SMALL
 reset:
#endif
	memset(arcn, 0, sizeof(*arcn));
	arcn->org_name = arcn->name;
	arcn->sb.st_nlink = 1;

#ifndef SMALL
	/* Process Extended headers. */
	if (hd->typeflag == XHDRTYPE || hd->typeflag == GHDRTYPE) {
		if (rd_xheader(arcn, hd->typeflag == GHDRTYPE,
		    (off_t)asc_ul(hd->size, sizeof(hd->size), OCT)) < 0)
			return (-1);

		/* Update and check the ustar header. */
		if (rd_wrbuf(buf, BLKMULT) != BLKMULT)
			return (-1);
		if (ustar_id(buf, BLKMULT) < 0)
			return(-1);

		/* if the next block is another extension, reset the values */
		if (hd->typeflag == XHDRTYPE || hd->typeflag == GHDRTYPE)
			goto reset;
	}
#endif

	if (!arcn->nlen) {
		/*
		 * See if the filename is split into two parts. if, so join
		 * the parts.  We copy the prefix first and add a / between
		 * the prefix and name.
		 */
		dest = arcn->name;
		if (*(hd->prefix) != '\0') {
			cnt = fieldcpy(dest, sizeof(arcn->name) - 1,
			    hd->prefix, sizeof(hd->prefix));
			dest += cnt;
			*dest++ = '/';
			cnt++;
		} else
			cnt = 0;

		if (hd->typeflag != LONGLINKTYPE &&
		    hd->typeflag != LONGNAMETYPE) {
			arcn->nlen = cnt + expandname(dest,
			    sizeof(arcn->name) - cnt, &gnu_name_string,
			    hd->name, sizeof(hd->name));
		}
	}

	if (!arcn->ln_nlen &&
	    hd->typeflag != LONGLINKTYPE && hd->typeflag != LONGNAMETYPE) {
		arcn->ln_nlen = expandname(arcn->ln_name, sizeof(arcn->ln_name),
		    &gnu_link_string, hd->linkname, sizeof(hd->linkname));
	}

	/*
	 * follow the spec to the letter. we should only have mode bits, strip
	 * off all other crud we may be passed.
	 */
	arcn->sb.st_mode = (mode_t)(asc_ul(hd->mode, sizeof(hd->mode), OCT) &
	    0xfff);
	arcn->sb.st_size = (off_t)asc_ull(hd->size, sizeof(hd->size), OCT);
	val = asc_ull(hd->mtime, sizeof(hd->mtime), OCT);
	if (val > MAX_TIME_T)
		arcn->sb.st_mtime = INT_MAX;                    /* XXX 2038 */
	else
		arcn->sb.st_mtime = val;
	arcn->sb.st_ctime = arcn->sb.st_atime = arcn->sb.st_mtime;

	/*
	 * If we can find the ascii names for gname and uname in the password
	 * and group files we will use the uid's and gid they bind. Otherwise
	 * we use the uid and gid values stored in the header. (This is what
	 * the posix spec wants).
	 */
	hd->gname[sizeof(hd->gname) - 1] = '\0';
	if ((anonarch & ANON_NUMID) ||
	    gid_name(hd->gname, &(arcn->sb.st_gid)) < 0)
		arcn->sb.st_gid = (gid_t)asc_ul(hd->gid, sizeof(hd->gid), OCT);
	hd->uname[sizeof(hd->uname) - 1] = '\0';
	if ((anonarch & ANON_NUMID) ||
	    uid_name(hd->uname, &(arcn->sb.st_uid)) < 0)
		arcn->sb.st_uid = (uid_t)asc_ul(hd->uid, sizeof(hd->uid), OCT);

	/*
	 * set the defaults, these may be changed depending on the file type
	 */
	arcn->pad = 0;
	arcn->skip = 0;
	arcn->sb.st_rdev = (dev_t)0;

	/*
	 * set the mode and PAX type according to the typeflag in the header
	 */
	switch (hd->typeflag) {
	case FIFOTYPE:
		arcn->type = PAX_FIF;
		arcn->sb.st_mode |= S_IFIFO;
		break;
	case DIRTYPE:
		arcn->type = PAX_DIR;
		arcn->sb.st_mode |= S_IFDIR;
		arcn->sb.st_nlink = 2;

		/*
		 * Some programs that create ustar archives append a '/'
		 * to the pathname for directories. This clearly violates
		 * ustar specs, but we will silently strip it off anyway.
		 */
		if (arcn->name[arcn->nlen - 1] == '/')
			arcn->name[--arcn->nlen] = '\0';
		break;
	case BLKTYPE:
	case CHRTYPE:
		/*
		 * this type requires the rdev field to be set.
		 */
		if (hd->typeflag == BLKTYPE) {
			arcn->type = PAX_BLK;
			arcn->sb.st_mode |= S_IFBLK;
		} else {
			arcn->type = PAX_CHR;
			arcn->sb.st_mode |= S_IFCHR;
		}
		devmajor = (dev_t)asc_ul(hd->devmajor,sizeof(hd->devmajor),OCT);
		devminor = (dev_t)asc_ul(hd->devminor,sizeof(hd->devminor),OCT);
		arcn->sb.st_rdev = TODEV(devmajor, devminor);
		break;
	case SYMTYPE:
	case LNKTYPE:
		if (hd->typeflag == SYMTYPE) {
			arcn->type = PAX_SLK;
			arcn->sb.st_mode |= S_IFLNK;
		} else {
			arcn->type = PAX_HLK;
			/*
			 * so printing looks better
			 */
			arcn->sb.st_mode |= S_IFREG;
			arcn->sb.st_nlink = 2;
		}
		break;
	case LONGLINKTYPE:
	case LONGNAMETYPE:
		/*
		 * GNU long link/file; we tag these here and let the
		 * pax internals deal with it -- too ugly otherwise.
		 */
		arcn->type =
		    hd->typeflag == LONGLINKTYPE ? PAX_GLL : PAX_GLF;
		arcn->pad = TAR_PAD(arcn->sb.st_size);
		arcn->skip = arcn->sb.st_size;
		break;
	case CONTTYPE:
	case AREGTYPE:
	case REGTYPE:
	default:
		/*
		 * these types have file data that follows. Set the skip and
		 * pad fields.
		 */
		arcn->type = PAX_REG;
		arcn->pad = TAR_PAD(arcn->sb.st_size);
		arcn->skip = arcn->sb.st_size;
		arcn->sb.st_mode |= S_IFREG;
		break;
	}
	return(0);
}

/*
 * ustar_wr()
 *	write a ustar header for the file specified in the ARCHD to the archive
 *	Have to check for file types that cannot be stored and file names that
 *	are too long. Be careful of the term (last arg) to ul_oct, we only use
 *	'\0' for the termination character (this is different than picky tar)
 *	ASSUMED: space after header in header block is zero filled
 * Return:
 *	0 if file has data to be written after the header, 1 if file has NO
 *	data to write after the header, -1 if archive write failed
 */

int
ustar_wr(ARCHD *arcn)
{
	HD_USTAR *hd;
	const char *name;
	char *pt, hdblk[sizeof(HD_USTAR)];
	u_long t_uid, t_gid;
	time_t t_mtime;

	anonarch_init();

	/*
	 * check for those filesystem types ustar cannot store
	 */
	if (arcn->type == PAX_SCK) {
		paxwarn(1, "%s cannot archive a %s %s",
		    "ustar", "socket", arcn->org_name);
		return (1);
	}

#ifndef SMALL
	/*
	 * user asked that dirs not be written to the archive
	 */
	if (arcn->type == PAX_DIR && tar_nodir)
		return (1);
#endif

	/*
	 * check the length of the linkname
	 */
	if (PAX_IS_LINK(arcn->type) &&
	    ((size_t)arcn->ln_nlen > sizeof(hd->linkname))) {
		paxwarn(1, "%s name too long for %s %s",
		    "Link", "ustar", arcn->ln_name);
		return (1);
	}

	/*
	 * if -M gslash: append a slash if directory
	 */
	if ((anonarch & ANON_DIRSLASH) && arcn->type == PAX_DIR &&
	    (size_t)arcn->nlen < (sizeof(arcn->name) - 1)) {
		arcn->name[arcn->nlen++] = '/';
		arcn->name[arcn->nlen] = '\0';
	}

	/*
	 * split the path name into prefix and name fields (if needed). if
	 * pt != arcn->name, the name has to be split
	 */
	if ((pt = name_split(arcn->name, arcn->nlen)) == NULL) {
		paxwarn(1, "%s name too long for %s %s",
		    "File", "ustar", arcn->name);
		return (1);
	}

	/*
	 * zero out the header so we don't have to worry about zero fill below
	 */
	memset(hdblk, 0, sizeof(hdblk));
	hd = (HD_USTAR *)hdblk;
	arcn->pad = 0;

	/*
	 * split the name, or zero out the prefix
	 */
	if (pt != arcn->name) {
		/*
		 * name was split, pt points at the / where the split is to
		 * occur, we remove the / and copy the first part to the prefix
		 */
		*pt = '\0';
		fieldcpy(hd->prefix, sizeof(hd->prefix), arcn->name,
		    sizeof(arcn->name));
		*pt++ = '/';
	}

	/*
	 * copy the name part. this may be the whole path or the part after
	 * the prefix
	 */
	fieldcpy(hd->name, sizeof(hd->name), pt,
	    sizeof(arcn->name) - (pt - arcn->name));

	t_uid   = (anonarch & ANON_UIDGID) ? 0UL : (u_long)arcn->sb.st_uid;
	t_gid   = (anonarch & ANON_UIDGID) ? 0UL : (u_long)arcn->sb.st_gid;
	t_mtime = (anonarch & ANON_MTIME)  ? 0   : arcn->sb.st_mtime;

	/*
	 * set the fields in the header that are type dependent
	 */
	switch (arcn->type) {
	case PAX_DIR:
		hd->typeflag = DIRTYPE;
		if (ul_oct(0, hd->size, sizeof(hd->size), 3))
			goto out;
		break;
	case PAX_CHR:
	case PAX_BLK:
		if (arcn->type == PAX_CHR)
			hd->typeflag = CHRTYPE;
		else
			hd->typeflag = BLKTYPE;
		if (ul_oct(MAJOR(arcn->sb.st_rdev), hd->devmajor,
		   sizeof(hd->devmajor), 3) ||
		   ul_oct(MINOR(arcn->sb.st_rdev), hd->devminor,
		   sizeof(hd->devminor), 3) ||
		   ul_oct(0, hd->size, sizeof(hd->size), 3))
			goto out;
		break;
	case PAX_FIF:
		hd->typeflag = FIFOTYPE;
		if (ul_oct(0, hd->size, sizeof(hd->size), 3))
			goto out;
		break;
	case PAX_SLK:
	case PAX_HLK:
	case PAX_HRG:
		if (arcn->type == PAX_SLK)
			hd->typeflag = SYMTYPE;
		else
			hd->typeflag = LNKTYPE;
		fieldcpy(hd->linkname, sizeof(hd->linkname), arcn->ln_name,
		    sizeof(arcn->ln_name));
		if (ul_oct(0, hd->size, sizeof(hd->size), 3))
			goto out;
		break;
	case PAX_REG:
	case PAX_CTG:
	default:
		/*
		 * file data with this type, set the padding
		 */
		if (arcn->type == PAX_CTG)
			hd->typeflag = CONTTYPE;
		else
			hd->typeflag = REGTYPE;
		arcn->pad = TAR_PAD(arcn->sb.st_size);
		if (ull_oct(arcn->sb.st_size, hd->size, sizeof(hd->size), 3)) {
			paxwarn(1, "File is too large for %s format %s",
			    "ustar", arcn->org_name);
			return (1);
		}
		break;
	}

	memcpy(hd->magic, TMAGIC, TMAGLEN);
	memcpy(hd->version, TVERSION, TVERSLEN);

	/*
	 * set the remaining fields. Some versions want all 16 bits of mode
	 * we better humor them (they really do not meet spec though)....
	 */
	if (ul_oct(t_uid, hd->uid, sizeof(hd->uid), 3)) {
		if (uid_nobody == 0) {
			if (uid_name("nobody", &uid_nobody) == -1)
				goto out;
		}
		if (uid_warn != t_uid) {
			uid_warn = t_uid;
			paxwarn(1,
			    "ustar header field is too small for %cid %lu, "
			    "using nobody", 'u', t_uid);
		}
		if (ul_oct(uid_nobody, hd->uid, sizeof(hd->uid), 3))
			goto out;
	}
	if (ul_oct(t_gid, hd->gid, sizeof(hd->gid), 3)) {
		if (gid_nobody == 0) {
			if (gid_name("nobody", &gid_nobody) == -1)
				goto out;
		}
		if (gid_warn != t_gid) {
			gid_warn = t_gid;
			paxwarn(1,
			    "ustar header field is too small for %cid %lu, "
			    "using nobody", 'g', t_gid);
		}
		if (ul_oct(gid_nobody, hd->gid, sizeof(hd->gid), 3))
			goto out;
	}
	if (ull_oct(t_mtime < 0 ? 0 : t_mtime, hd->mtime, sizeof(hd->mtime), 3) ||
	    ul_oct(arcn->sb.st_mode, hd->mode, sizeof(hd->mode), 3))
		goto out;
	if (!(anonarch & ANON_NUMID)) {
		if ((name = name_uid(t_uid, 0)) != NULL)
			strncpy(hd->uname, name, sizeof(hd->uname));
		if ((name = name_gid(t_gid, 0)) != NULL)
			strncpy(hd->gname, name, sizeof(hd->gname));
	}

	/*
	 * calculate and store the checksum write the header to the archive
	 * return 0 tells the caller to now write the file data, 1 says no data
	 * needs to be written
	 */
	if (ul_oct(tar_chksm(hdblk, sizeof(HD_USTAR)), hd->chksum,
	   sizeof(hd->chksum), 3))
		goto out;

#ifndef SMALL
	if (anonarch & ANON_DEBUG) {
		tar_dbgfld(NULL, NULL, 0);
		tar_dbgfld("writing name '", hd->name, TNMSZ);
		tar_dbgfld("' mode ", hd->mode, 8);
		tar_dbgfld(" uid ", hd->uid, 8);
		tar_dbgfld(" (", hd->uname, 32);
		tar_dbgfld(") gid ", hd->gid, 8);
		tar_dbgfld(" (", hd->gname, 32);
		tar_dbgfld(") size ", hd->size, 12);
		tar_dbgfld(" mtime ", hd->mtime, 12);
		tar_dbgfld(" type ", &(hd->typeflag), 1);
		tar_dbgfld(" linked to '", hd->linkname, TNMSZ);
		tar_dbgfld("' magic '", hd->magic, TMAGLEN);
		tar_dbgfld("' v", hd->version, TVERSLEN);
		tar_dbgfld(" device '", hd->devmajor, 8);
		tar_dbgfld(":", hd->devminor, 8);
		tar_dbgfld("' prefix '", hd->prefix, TPFSZ);
		tar_dbgfld("' checksum ", hd->chksum, CHK_LEN);
		tar_dbgfld(NULL, NULL, 1);
	}
#endif

	if (wr_rdbuf(hdblk, sizeof(HD_USTAR)) < 0)
		return(-1);
	if (wr_skip(BLKMULT - sizeof(HD_USTAR)) < 0)
		return(-1);
	if (PAX_IS_REG(arcn->type))
		return(0);
	return(1);

 out:
	/*
	 * header field is out of range
	 */
	paxwarn(1, "%s header field is too small for file %s",
	    "ustar", arcn->org_name);
	return (1);
}

/*
 * name_split()
 *	see if the name has to be split for storage in a ustar header. We try
 *	to fit the entire name in the name field without splitting if we can.
 *	The split point is always at a /
 * Return
 *	character pointer to split point (always the / that is to be removed
 *	if the split is not needed, the points is set to the start of the file
 *	name (it would violate the spec to split there). A NULL is returned if
 *	the file name is too long
 */

static char *
name_split(char *name, int len)
{
	char *start;

	/*
	 * check to see if the file name is small enough to fit in the name
	 * field. if so just return a pointer to the name.
	 * The strings can fill the complete name and prefix fields
	 * without a NUL terminator.
	 */
	if (len <= TNMSZ)
		return(name);
	if (len > (TPFSZ + TNMSZ + 1))
		return(NULL);

	/*
	 * we start looking at the biggest sized piece that fits in the name
	 * field. We walk forward looking for a slash to split at. The idea is
	 * to find the biggest piece to fit in the name field (or the smallest
	 * prefix we can find) (the -1 is correct the biggest piece would
	 * include the slash between the two parts that gets thrown away)
	 */
	start = name + len - TNMSZ - 1;

	/*
	 * the prefix may not be empty, so skip the first character when
	 * trying to split a path of exactly TNMSZ+1 characters.
	 * NOTE: This means the ustar format can't store /str if
	 * str contains no slashes and the length of str == TNMSZ
	 */
	if (start == name)
		++start;

	while ((*start != '\0') && (*start != '/'))
		++start;

	/*
	 * if we hit the end of the string, this name cannot be split, so we
	 * cannot store this file.
	 */
	if (*start == '\0')
		return(NULL);

	/*
	 * the split point isn't valid if it results in a prefix
	 * longer than TPFSZ
	 */
	if ((start - name) > TPFSZ)
		return(NULL);

	/*
	 * ok have a split point, return it to the caller
	 */
	return(start);
}

static size_t
expandname(char *buf, size_t len, char **gnu_name, const char *name,
    size_t limit)
{
	size_t nlen;

	if (*gnu_name) {
		/* *gnu_name is NUL terminated */
		if ((nlen = strlcpy(buf, *gnu_name, len)) >= len)
			nlen = len - 1;
		free(*gnu_name);
		*gnu_name = NULL;
	} else
		nlen = fieldcpy(buf, len, name, limit);
	return(nlen);
}

#ifndef SMALL
static void
tar_dbgfld(const char *pfx, const char *sp, size_t len)
{
	static char fbuf[256];
	char tbuf[256], *s;

	if ((pfx == NULL) || (sp == NULL)) {
		if ((pfx == NULL) && (sp == NULL)) {
			if (len == 0) {
				*fbuf = 0;
			} else {
				paxwarn(0, "%s", fbuf);
			}
		} else
			paxwarn(0, "tar_dbgfld: wrong call");
		return;
	}

	strlcat(fbuf, pfx, sizeof (fbuf));

	if (len == 0)
		return;

	if (len > (sizeof (tbuf) - 1))
		len = sizeof (tbuf) - 1;

	memmove(s = tbuf, sp, len);
	tbuf[len] = 0;
	while (*s == ' ')
		++s;
	while (s[strlen(s) - 1] == ' ')
		s[strlen(s) - 1] = 0;

	strlcat(fbuf, tbuf, sizeof (fbuf));
}

/* shortest possible extended record: "5 a=\n" */
#define MINXHDRSZ	5

/* longest record we'll accept */
#define MAXXHDRSZ	BLKMULT

static int
rd_xheader(ARCHD *arcn, int global, off_t size)
{
	char buf[MAXXHDRSZ];
	long len;
	char *delim, *keyword;
	char *nextp, *p, *end;
	int pad, ret = 0;

	/* before we alter size, make note of how much we have to skip */
	pad = TAR_PAD((unsigned)size);

	p = end = buf;
	while (size > 0 || p < end) {
		if (size > 0) {
			int rdlen;

			/* shift stuff down */
			if (p > buf) {
				memmove(buf, p, end - p);
				end -= p - buf;
				p = buf;
			}

			/* fill starting at end */
			rdlen = MINIMUM(size, (buf + sizeof buf) - end);
			if (rd_wrbuf(end, rdlen) != rdlen) {
				ret = -1;
				break;
			}
			size -= rdlen;
			end += rdlen;
		}

		/* [p, end) is good */
		if (memchr(p, ' ', end - p) == NULL ||
		    !isdigit((unsigned char)*p)) {
			paxwarn(1, "Invalid extended header record");
			ret = -1;
			break;
		}
		errno = 0;
		len = strtol(p, &delim, 10);
		if (*delim != ' ' || (errno == ERANGE && len == LONG_MAX) ||
		    len < MINXHDRSZ) {
			paxwarn(1, "%s length",
			    "Invalid extended header record");
			ret = -1;
			break;
		}
		if (len > end - p) {
			paxwarn(1, "Extended header record length %lu is "
			    "out of range", len);
			/* if we can just toss this record, do so */
			len -= end - p;
			if (len <= size && rd_skip(len) == 0) {
				size -= len;
				p = end = buf;
				continue;
			}
			ret = -1;
			break;
		}
		nextp = p + len;
		keyword = p = delim + 1;
		p = memchr(p, '=', len);
		if (!p || nextp[-1] != '\n') {
			paxwarn(1, "Malformed extended header record");
			ret = -1;
			break;
		}
		*p++ = nextp[-1] = '\0';
		if (!global) {
			if (!strcmp(keyword, "path")) {
				arcn->nlen = strlcpy(arcn->name, p,
				    sizeof(arcn->name));
			} else if (!strcmp(keyword, "linkpath")) {
				arcn->ln_nlen = strlcpy(arcn->ln_name, p,
				    sizeof(arcn->ln_name));
			}
		}
		p = nextp;
	}

	if (rd_skip(size + pad) < 0)
		return (-1);
	return (ret);
}
#endif
@


1.23
log
@port to Debian sid/{amd64,i386,hurd-i386,x32}, {stretch,jessie}/{amd64,i386}
@
text
@d60 1
a60 1
__RCSID("$MirOS: src/bin/pax/tar.c,v 1.22 2018/12/13 07:09:12 tg Exp $");
d1147 1
a1147 1
		if ((name = name_uid(arcn->sb.st_uid, 0)) != NULL)
d1149 1
a1149 1
		if ((name = name_gid(arcn->sb.st_gid, 0)) != NULL)
@


1.22
log
@fixing and string pooling and int shortening offensive
@
text
@d5 1
a5 1
 * Copyright (c) 2006, 2012, 2016, 2017
d60 1
a60 1
__RCSID("$MirOS: src/bin/pax/tar.c,v 1.21 2018/12/12 18:08:48 tg Exp $");
d329 1
a329 1
		return(-1);
d334 1
a334 1
	 * check for block of zero's first, a simple and fast test, then make
d341 5
a345 5
		return(-1);
	if (strncmp(uhd->magic, TMAGIC, TMAGLEN - 1) == 0)
		return(-1);
	if (asc_ul(hd->chksum,sizeof(hd->chksum),OCT) != tar_chksm(blk,BLKMULT))
		return(-1);
d347 1
a347 1
	return(0);
d736 1
a736 1
		return(-1);
d740 1
a740 1
	 * check for block of zero's first, a simple and fast test then check
d746 6
a751 6
		return(-1);
	if (strncmp(hd->magic, TMAGIC, TMAGLEN - 1) != 0)
		return(-1);
	if (asc_ul(hd->chksum,sizeof(hd->chksum),OCT) != tar_chksm(blk,BLKMULT))
		return(-1);
	return(0);
d1048 1
a1048 1
	t_mtime = (anonarch & ANON_MTIME)  ? 0UL : arcn->sb.st_mtime;
d1108 2
a1109 2
	strncpy(hd->magic, TMAGIC, TMAGLEN);
	strncpy(hd->version, TVERSION, TVERSLEN);
@


1.21
log
@merge the npax branch into MAIN

asides from a missing dprintf and portability, this ought to be
good enough for people (well me) to play with for now
@
text
@d60 1
a60 1
__RCSID("$MirOS: src/bin/pax/tar.c,v 1.19 2017/10/21 19:05:43 tg Exp $");
d86 1
a86 1
int tar_nodir;				/* do not write dirs under old tar */
d543 1
d549 1
d552 3
a554 3
		paxwarn(1, "tar cannot archive a character device %s",
		    arcn->org_name);
		return(1);
d556 3
a558 2
		paxwarn(1, "tar cannot archive a block device %s", arcn->org_name);
		return(1);
d560 3
a562 2
		paxwarn(1, "tar cannot archive a socket %s", arcn->org_name);
		return(1);
d564 3
a566 2
		paxwarn(1, "tar cannot archive a fifo %s", arcn->org_name);
		return(1);
d571 3
a573 3
			paxwarn(1, "Link name too long for tar %s",
			    arcn->ln_name);
			return(1);
d589 3
a591 2
		paxwarn(1, "File name too long for tar %s", arcn->name);
		return(1);
d641 3
a643 3
			paxwarn(1, "File is too large for tar %s",
			    arcn->org_name);
			return(1);
d678 3
a680 2
	paxwarn(1, "tar header field is too small for %s", arcn->org_name);
	return(1);
d976 3
a978 2
		paxwarn(1, "ustar cannot archive a socket %s", arcn->org_name);
		return(1);
d981 1
d987 1
d994 3
a996 2
		paxwarn(1, "Link name too long for ustar %s", arcn->ln_name);
		return(1);
d1013 3
a1015 2
		paxwarn(1, "File name too long for ustar %s", arcn->name);
		return(1);
d1101 3
a1103 3
			paxwarn(1, "File is too long for ustar %s",
			    arcn->org_name);
			return(1);
d1123 2
a1124 2
			    "ustar header field is too small for uid %lu, "
			    "using nobody", t_uid);
d1137 2
a1138 2
			    "ustar header field is too small for gid %lu, "
			    "using nobody", t_gid);
d1197 3
a1199 2
	paxwarn(1, "ustar header field is too small for %s", arcn->org_name);
	return(1);
d1376 2
a1377 1
			paxwarn(1, "Invalid extended header record length");
@


1.20
log
@slowmerge (untested though)
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.66 2017/09/16 07:42:34 otto Exp $	*/
d39 1
a39 2
#include <sys/param.h>
#include <sys/time.h>
d41 9
d51 3
a53 1
#include <stdio.h>
d55 1
a55 2
#include <stdlib.h>
#include <time.h>
a58 1
#include "options.h"
d70 2
a71 2
static int ot_oct(ot_type, char *, int, int);

d73 2
d101 1
a101 1
	return(wr_skip((off_t)(NULLCNT*BLKMULT)));
d114 1
a114 1
	return((off_t)(NULLCNT*BLKMULT));
d129 1
a129 2
tar_trail(ARCHD *ignore __attribute__((__unused__)), char *buf,
    int in_resync, int *cnt)
d203 2
a204 1
		if ((val = val >> 3) == (u_long)0)
d210 1
a210 1
	if (val != (u_long)0)
d216 6
a221 6
 * ot_oct()
 *	convert an ot_type to an octal string. one of many oddball
 *	field termination characters are used by the various versions
 *	of tar in the different fields. term selects which kind to use.
 *	str is '0' padded at the front to len. we are unable to use only
 *	one format as many old tar readers are very cranky about this.
d227 1
a227 1
ot_oct(ot_type val, char *str, int len, int term)
d258 2
a259 1
		if ((val = val >> 3) == 0)
d265 3
a267 3
	if (val != (ot_type)0)
		return (-1);
	return (0);
a384 1

d397 1
d423 6
a428 2
	arcn->sb.st_size = (off_t)asc_ot(hd->size, sizeof(hd->size), OCT);
	arcn->sb.st_mtime = (time_t)asc_ul(hd->mtime, sizeof(hd->mtime), OCT);
d516 1
a516 1
	return(0);
d609 1
a609 1
		if (ul_oct((u_long)0L, hd->size, sizeof(hd->size), 1))
d618 1
a618 1
		if (ul_oct((u_long)0L, hd->size, sizeof(hd->size), 1))
d620 1
a620 1
	} else if ((arcn->type == PAX_HLK) || (arcn->type == PAX_HRG)) {
d627 1
a627 1
		if (ul_oct((u_long)0L, hd->size, sizeof(hd->size), 1))
d634 3
a636 2
		if (ot_oct(arcn->sb.st_size, hd->size, sizeof(hd->size), 1)) {
			paxwarn(1,"File is too large for tar %s", arcn->org_name);
d645 5
a649 4
	if (ul_oct((u_long)arcn->sb.st_mode, hd->mode, sizeof(hd->mode), 0) ||
	    ul_oct((u_long)arcn->sb.st_uid, hd->uid, sizeof(hd->uid), 0) ||
	    ul_oct((u_long)arcn->sb.st_gid, hd->gid, sizeof(hd->gid), 0) ||
	    ul_oct((u_long)(u_int)arcn->sb.st_mtime, hd->mtime, sizeof(hd->mtime), 1))
d662 1
a662 1
	if (wr_skip((off_t)(BLKMULT - sizeof(HD_TAR))) < 0)
d664 1
a664 1
	if ((arcn->type == PAX_CTG) || (arcn->type == PAX_REG))
d691 1
d694 1
d706 1
a706 1
ustar_stwr(int is_app __attribute__((__unused__)))
d708 1
d711 1
d758 1
a758 1
	HD_USTAR *hd;
d763 1
d770 4
a776 1
	hd = (HD_USTAR *)buf;
d778 41
a818 13
	/*
	 * see if the filename is split into two parts. if, so joint the parts.
	 * we copy the prefix first and add a / between the prefix and name.
	 */
	dest = arcn->name;
	if (*(hd->prefix) != '\0') {
		cnt = fieldcpy(dest, sizeof(arcn->name) - 1, hd->prefix,
		    sizeof(hd->prefix));
		dest += cnt;
		*dest++ = '/';
		cnt++;
	} else {
		cnt = 0;
d821 2
a822 3
	if (hd->typeflag != LONGLINKTYPE && hd->typeflag != LONGNAMETYPE) {
		arcn->nlen = cnt + expandname(dest, sizeof(arcn->name) - cnt,
		    &gnu_name_string, hd->name, sizeof(hd->name));
d833 6
a838 2
	arcn->sb.st_size = (off_t)asc_ot(hd->size, sizeof(hd->size), OCT);
	arcn->sb.st_mtime = (time_t)asc_ul(hd->mtime, sizeof(hd->mtime), OCT);
d849 1
a849 1
	    (gid_name(hd->gname, &(arcn->sb.st_gid)) < 0))
d853 1
a853 1
	    (uid_name(hd->uname, &(arcn->sb.st_uid)) < 0))
d958 4
a961 4
	char *pt;
	char hdblk[sizeof(HD_USTAR)];

	u_long t_uid, t_gid, t_mtime;
d974 6
d982 1
a982 2
	if (((arcn->type == PAX_SLK) || (arcn->type == PAX_HLK) ||
	    (arcn->type == PAX_HRG)) &&
d1011 1
a1011 1
	arcn->pad = 0L;
d1036 1
a1036 1
	t_mtime = (anonarch & ANON_MTIME) ? 0UL : (u_long)(u_int)arcn->sb.st_mtime;
d1044 1
a1044 1
		if (ul_oct((u_long)0L, hd->size, sizeof(hd->size), 3))
d1053 1
a1053 1
		if (ul_oct((u_long)MAJOR(arcn->sb.st_rdev), hd->devmajor,
d1055 1
a1055 1
		   ul_oct((u_long)MINOR(arcn->sb.st_rdev), hd->devminor,
d1057 1
a1057 1
		   ul_oct((u_long)0L, hd->size, sizeof(hd->size), 3))
d1062 1
a1062 1
		if (ul_oct((u_long)0L, hd->size, sizeof(hd->size), 3))
d1074 1
a1074 1
		if (ul_oct((u_long)0L, hd->size, sizeof(hd->size), 3))
d1088 3
a1090 2
		if (ot_oct(arcn->sb.st_size, hd->size, sizeof(hd->size), 3)) {
			paxwarn(1,"File is too long for ustar %s",arcn->org_name);
d1114 1
a1114 1
		if (ul_oct((u_long)uid_nobody, hd->uid, sizeof(hd->uid), 3))
d1128 1
a1128 1
		if (ul_oct((u_long)gid_nobody, hd->gid, sizeof(hd->gid), 3))
d1131 2
a1132 2
	if (ul_oct((u_long)arcn->sb.st_mode, hd->mode, sizeof(hd->mode), 3) ||
	    ul_oct(t_mtime,hd->mtime,sizeof(hd->mtime),3))
d1134 6
a1139 4
#define name_id(x) ((anonarch & ANON_NUMID) ? "" : (const char *)(x))
	strncpy(hd->uname, name_id(name_uid(t_uid, 0)), sizeof(hd->uname));
	strncpy(hd->gname, name_id(name_gid(t_gid, 0)), sizeof(hd->gname));
#undef name_id
d1150 1
d1171 1
d1175 1
a1175 1
	if (wr_skip((off_t)(BLKMULT - sizeof(HD_USTAR))) < 0)
d1177 1
a1177 1
	if ((arcn->type == PAX_CTG) || (arcn->type == PAX_REG))
d1275 1
d1311 95
@


1.19
log
@fix buffer underread (Debian #878645)
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.43 +1.57 +1.59 2010/12/02 04:08:27 tedu Exp $	*/
d52 1
a52 1
__RCSID("$MirOS: src/bin/pax/tar.c,v 1.18 2017/08/07 20:10:19 tg Exp $");
@


1.18
log
@filesystem
@
text
@d5 1
a5 1
 * Copyright (c) 2006, 2012, 2016
d52 1
a52 1
__RCSID("$MirOS: src/bin/pax/tar.c,v 1.17 2016/10/25 18:57:56 tg Exp $");
d420 1
a420 1
	pt = &(arcn->name[arcn->nlen - 1]);
d473 1
a473 1
		if (*pt == '/') {
d497 1
a497 1
	if (*pt == '/') {
@


1.17
log
@fastmerge
@
text
@d52 1
a52 1
__RCSID("$MirOS: src/bin/pax/tar.c,v 1.16 2016/03/12 13:20:48 tg Exp $");
d524 1
a524 1
	 * check for those file system types which tar cannot store
d910 1
a910 1
	 * check for those file system types ustar cannot store
@


1.16
log
@drop support for bcpio and (old)tar on the floppy
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.43 2010/12/02 04:08:27 tedu Exp $	*/
d52 1
a52 1
__RCSID("$MirOS: src/bin/pax/tar.c,v 1.15 2016/03/06 13:47:12 tg Exp $");
d76 1
a76 1
static int tar_nodir;			/* do not write dirs under old tar */
d1159 10
a1177 1
	len = start - name;
d1180 2
a1181 4
	 * NOTE: /str where the length of str == TNMSZ cannot be stored under
	 * the p1003.1-1990 spec for ustar. We could force a prefix of / and
	 * the file would then expand on extract to //str. The len == 0 below
	 * makes this special case follow the spec to the letter.
d1183 1
a1183 1
	if ((len > TPFSZ) || (len == 0))
@


1.15
log
@apply changes from mpax-erstmalnurderbackport branch not related to the CVEs
@
text
@d52 1
a52 1
__RCSID("$MirOS: src/bin/pax/tar.c,v 1.13 2012/05/20 16:13:19 tg Exp $");
d75 1
d77 1
d297 1
d658 1
@


1.14
log
@KNF
@
text
@d5 2
a6 2
 * Copyright (c) 2006, 2012
 *	Thorsten Glaser <tg@@mirbsd.org>
@


1.13
log
@get rid of extern.h including other headers
@
text
@d52 1
a52 1
__RCSID("$MirOS: src/bin/pax/tar.c,v 1.12 2012/02/16 17:27:32 tg Exp $");
d648 1
a648 1
    out:
d1111 1
a1111 1
    out:
@


1.12
log
@clean up some ugliness
@
text
@d46 1
d52 1
a52 1
__RCSID("$MirOS: src/bin/pax/tar.c,v 1.11 2012/02/16 17:11:46 tg Exp $");
@


1.11
log
@Debian GNU/kFreeBSD can be more difficult to deal with than GNU/Hurd at times.

• switch from quad_t to using unsigned long / unsigned long long
• sanitise use of off_t-relevant types
• cast when printing off_t; use a once-defined type and format specifier
• convert “This define is important” into actual compile-time assertion
• simplify ifdef mess by always defining off_t specific routines
  instead of reusing those for long if off_t is just long
@
text
@d51 1
a51 1
__RCSID("$MirOS: src/bin/pax/tar.c,v 1.10 2012/02/12 00:27:18 tg Exp $");
d531 1
a531 1
		paxwarn(1, "Tar cannot archive a character device %s",
d535 1
a535 1
		paxwarn(1, "Tar cannot archive a block device %s", arcn->org_name);
d538 1
a538 1
		paxwarn(1, "Tar cannot archive a socket %s", arcn->org_name);
d541 1
a541 1
		paxwarn(1, "Tar cannot archive a fifo %s", arcn->org_name);
d651 1
a651 1
	paxwarn(1, "Tar header field is too small for %s", arcn->org_name);
d908 1
a908 1
		paxwarn(1, "Ustar cannot archive a socket %s", arcn->org_name);
d1044 1
a1044 1
			    "Ustar header field is too small for uid %lu, "
d1058 1
a1058 1
			    "Ustar header field is too small for gid %lu, "
d1114 1
a1114 1
	paxwarn(1, "Ustar header field is too small for %s", arcn->org_name);
d1166 1
a1166 1
	 * NOTE: /str where the length of str == TNMSZ can not be stored under
@


1.10
log
@merge OpenBSD
@
text
@d5 2
a6 1
 * Copyright (c) 2006 Thorsten Glaser.
d51 1
a51 1
__RCSID("$MirOS: src/bin/pax/tar.c,v 1.9 2011/08/16 21:32:49 tg Exp $");
d61 1
a61 3
#ifndef LONG_OFF_T
static int uqd_oct(u_quad_t, char *, int, int);
#endif
a201 1
#ifndef LONG_OFF_T
d203 6
a208 6
 * uqd_oct()
 *	convert an u_quad_t to an octal string. one of many oddball field
 *	termination characters are used by the various versions of tar in the
 *	different fields. term selects which kind to use. str is '0' padded
 *	at the front to len. we are unable to use only one format as many old
 *	tar readers are very cranky about this.
d214 1
a214 1
uqd_oct(u_quad_t val, char *str, int len, int term)
d251 3
a253 3
	if (val != (u_quad_t)0)
		return(-1);
	return(0);
a254 1
#endif
d408 1
a408 5
#ifdef LONG_OFF_T
	arcn->sb.st_size = (off_t)asc_ul(hd->size, sizeof(hd->size), OCT);
#else
	arcn->sb.st_size = (off_t)asc_uqd(hd->size, sizeof(hd->size), OCT);
#endif
d615 1
a615 7
#		ifdef LONG_OFF_T
		if (ul_oct((u_long)arcn->sb.st_size, hd->size,
		    sizeof(hd->size), 1)) {
#		else
		if (uqd_oct((u_quad_t)arcn->sb.st_size, hd->size,
		    sizeof(hd->size), 1)) {
#		endif
d776 1
a776 5
#ifdef LONG_OFF_T
	arcn->sb.st_size = (off_t)asc_ul(hd->size, sizeof(hd->size), OCT);
#else
	arcn->sb.st_size = (off_t)asc_uqd(hd->size, sizeof(hd->size), OCT);
#endif
d1022 1
a1022 7
#		ifdef LONG_OFF_T
		if (ul_oct((u_long)arcn->sb.st_size, hd->size,
		    sizeof(hd->size), 3)) {
#		else
		if (uqd_oct((u_quad_t)arcn->sb.st_size, hd->size,
		    sizeof(hd->size), 3)) {
#		endif
d1025 1
a1025 1
		} /* } */
@


1.9
log
@backend for Unix Archiver libraries – ar(5) and deb(5) format files
(since GNU binutils on ELF systems thinks SYSV style ar is used…)
@
text
@d1 1
a1 2
/**	$MirOS: src/bin/pax/tar.c,v 1.8 2011/08/16 13:50:18 tg Exp $ */
/*	$OpenBSD: tar.c,v 1.41 2006/03/04 20:24:55 otto Exp $	*/
d50 1
a50 2
__SCCSID("@@(#)tar.c	8.2 (Berkeley) 4/18/94");
__RCSID("$MirOS: src/bin/pax/tar.c,v 1.8 2011/08/16 13:50:18 tg Exp $");
@


1.8
log
@use underscores with __attribute__s
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/tar.c,v 1.7 2011/08/16 13:45:02 tg Exp $ */
d52 1
a52 1
__RCSID("$MirOS: src/bin/pax/tar.c,v 1.7 2011/08/16 13:45:02 tg Exp $");
d697 1
a697 1
ustar_stwr(void)
d1050 1
a1050 1
		}
@


1.7
log
@… aaaand the even longer awaited functionality to append a slash to a
directory’s name upon ustar creation (like gtar)
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/tar.c,v 1.6 2011/08/16 13:27:03 tg Exp $ */
d52 1
a52 1
__RCSID("$MirOS: src/bin/pax/tar.c,v 1.6 2011/08/16 13:27:03 tg Exp $");
d119 2
a120 2
tar_trail(ARCHD *ignore __attribute__((unused)), char *buf, int in_resync,
    int *cnt)
@


1.6
log
@implement the long-awaited option to skip writing the ASCII uid/gid
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/tar.c,v 1.5 2009/10/04 14:54:56 tg Exp $ */
d52 1
a52 1
__RCSID("$MirOS: src/bin/pax/tar.c,v 1.5 2009/10/04 14:54:56 tg Exp $");
d942 9
@


1.5
log
@caught by gcc version 4.2.1 (Apple Inc. build 5646)
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/tar.c,v 1.4 2007/02/17 04:52:41 tg Exp $ */
d52 1
a52 1
__RCSID("$MirOS: src/bin/pax/tar.c,v 1.4 2007/02/17 04:52:41 tg Exp $");
d806 2
a807 1
	if (gid_name(hd->gname, &(arcn->sb.st_gid)) < 0)
d810 2
a811 1
	if (uid_name(hd->uname, &(arcn->sb.st_uid)) < 0)
d1083 4
a1086 2
	strncpy(hd->uname, name_uid(t_uid, 0), sizeof(hd->uname));
	strncpy(hd->gname, name_gid(t_gid, 0), sizeof(hd->gname));
@


1.4
log
@__CRAZY clean
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/tar.c,v 1.3 2006/06/23 23:03:57 tg Exp $ */
d52 1
a52 1
__RCSID("$MirOS$");
d1220 1
a1220 1
				paxwarn(0, fbuf);
@


1.3
log
@merge the OpenBSD import (bugfix)
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/tar.c,v 1.2 2006/06/19 20:31:06 tg Exp $ */
d39 1
a39 9
#ifndef lint
#if 0
static const char sccsid[] = "@@(#)tar.c	8.2 (Berkeley) 4/18/94";
#else
static const char rcsid[] = "$OpenBSD: tar.c,v 1.41 2006/03/04 20:24:55 otto Exp $";
#endif
#endif /* not lint */

#include <sys/types.h>
a41 1
#include <sys/param.h>
d51 3
d119 2
a120 1
tar_trail(ARCHD *ignore, char *buf, int in_resync, int *cnt)
d555 1
a555 1
		if (arcn->ln_nlen > sizeof(hd->linkname)) {
d573 1
a573 1
	if (len > sizeof(hd->name)) {
d933 2
a934 1
	    (arcn->type == PAX_HRG)) && (arcn->ln_nlen > sizeof(hd->linkname))){
@


1.2
log
@* fix -M option processing in tar(1)
* support ustar (in cpio(1) and tar(1)) with -M uidgid and -M mtime,
  as well as the -M debug and -M verb options
@
text
@d1 2
a2 2
/**	$MirOS$ */
/*	$OpenBSD: tar.c,v 1.39 2005/06/13 19:20:05 otto Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: tar.c,v 1.39 2005/06/13 19:20:05 otto Exp $";
d648 1
a648 1
	    ul_oct((u_long)arcn->sb.st_mtime, hd->mtime, sizeof(hd->mtime), 1))
d938 1
a938 1
	    (arcn->type == PAX_HRG)) && (arcn->ln_nlen >= sizeof(hd->linkname))){
d982 1
a982 1
	t_mtime = (anonarch & ANON_MTIME) ? 0UL : (u_long)arcn->sb.st_mtime;
d1154 2
d1157 1
a1157 1
	if (len < TNMSZ)
d1159 1
a1159 1
	if (len > (TPFSZ + TNMSZ))
d1166 2
a1167 1
	 * prefix we can find)
d1169 1
a1169 1
	start = name + len - TNMSZ;
d1187 1
a1187 1
	if ((len >= TPFSZ) || (len == 0))
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$OpenBSD: tar.c,v 1.34 2004/10/23 19:34:14 otto Exp $	*/
d6 1
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: tar.c,v 1.34 2004/10/23 19:34:14 otto Exp $";
d58 1
d64 1
a64 1
static size_t expandname(char *, size_t, char **, const char *);
d72 2
d410 1
a410 1
		    &gnu_name_string, hd->name);
d412 1
a412 1
		    &gnu_link_string, hd->linkname);
d561 2
a562 1
			paxwarn(1,"Link name too long for tar %s", arcn->ln_name);
d578 1
a578 1
	if (len >= sizeof(hd->name)) {
d593 1
a593 1
	strlcpy(hd->name, arcn->name, sizeof(hd->name));
d611 2
a612 1
		strlcpy(hd->linkname, arcn->ln_name, sizeof(hd->linkname));
d620 2
a621 1
		strlcpy(hd->linkname, arcn->ln_name, sizeof(hd->linkname));
d732 1
a732 1
	if (hd->name[0] == '\0')
d774 2
a775 1
		cnt = strlcpy(dest, hd->prefix, sizeof(arcn->name) - 1);
d784 2
a785 2
		arcn->nlen = expandname(dest, sizeof(arcn->name) - cnt,
		    &gnu_name_string, hd->name);
d787 1
a787 1
		    &gnu_link_string, hd->linkname);
d922 4
d968 2
a969 1
		strlcpy(hd->prefix, arcn->name, sizeof(hd->prefix));
d977 6
a982 1
	strlcpy(hd->name, pt, sizeof(hd->name));
d1018 2
a1019 1
		strlcpy(hd->linkname, arcn->ln_name, sizeof(hd->linkname));
d1054 1
a1054 1
	if (ul_oct((u_long)arcn->sb.st_uid, hd->uid, sizeof(hd->uid), 3)) {
d1059 2
a1060 2
		if (uid_warn != arcn->sb.st_uid) {
			uid_warn = arcn->sb.st_uid;
d1063 1
a1063 1
			    "using nobody", (u_long)arcn->sb.st_uid);
d1068 1
a1068 1
	if (ul_oct((u_long)arcn->sb.st_gid, hd->gid, sizeof(hd->gid), 3)) {
d1073 2
a1074 2
		if (gid_warn != arcn->sb.st_gid) {
			gid_warn = arcn->sb.st_gid;
d1077 1
a1077 1
			    "using nobody", (u_long)arcn->sb.st_gid);
d1083 1
a1083 1
	    ul_oct((u_long)arcn->sb.st_mtime,hd->mtime,sizeof(hd->mtime),3))
d1085 2
a1086 2
	strncpy(hd->uname, name_uid(arcn->sb.st_uid, 0), sizeof(hd->uname));
	strncpy(hd->gname, name_gid(arcn->sb.st_gid, 0), sizeof(hd->gname));
d1096 22
d1194 2
a1195 1
expandname(char *buf, size_t len, char **gnu_name, const char *name)
d1200 1
d1205 2
a1206 4
	} else {
		if ((nlen = strlcpy(buf, name, len)) >= len)
			nlen = len - 1;
	}
d1209 36
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@improve my Frankenstein OS (*wink* you know who you are) further
sans wchar_t of course

this is the essence of reading >1200 commit messages which suck
due to not having the new format of ours...
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.38 2005/04/28 06:58:07 otto Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: tar.c,v 1.38 2005/04/28 06:58:07 otto Exp $";
d61 1
a61 1
static size_t expandname(char *, size_t, char **, const char *, size_t);
d405 1
a405 1
		    &gnu_name_string, hd->name, sizeof(hd->name));
d407 1
a407 1
		    &gnu_link_string, hd->linkname, sizeof(hd->linkname));
d724 1
a724 1
	if (hd->prefix[0] == '\0' && hd->name[0] == '\0')
d766 1
a766 2
		cnt = fieldcpy(dest, sizeof(arcn->name) - 1, hd->prefix,
		    sizeof(hd->prefix));
d775 2
a776 2
		arcn->nlen = cnt + expandname(dest, sizeof(arcn->name) - cnt,
		    &gnu_name_string, hd->name, sizeof(hd->name));
d778 1
a778 1
		    &gnu_link_string, hd->linkname, sizeof(hd->linkname));
d1152 1
a1152 2
expandname(char *buf, size_t len, char **gnu_name, const char *name,
    size_t limit)
a1156 1
		/* *gnu_name is NUL terminated */
d1161 4
a1164 2
	} else
		nlen = fieldcpy(buf, len, name, limit);
@


1.1.1.3
log
@Import almost everything (no ancontrol, ifconfig, pfctl, wicontrol)
of (the undeleted parts of) OpenBSD-current's userland of about 3 hours ago.
Warning: this introduces major breakage!
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.39 2005/06/13 19:20:05 otto Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: tar.c,v 1.39 2005/06/13 19:20:05 otto Exp $";
d556 1
a556 2
			paxwarn(1, "Link name too long for tar %s",
			    arcn->ln_name);
d572 1
a572 1
	if (len > sizeof(hd->name)) {
d587 1
a587 1
	fieldcpy(hd->name, sizeof(hd->name), arcn->name, sizeof(arcn->name));
d605 1
a605 2
		fieldcpy(hd->linkname, sizeof(hd->linkname), arcn->ln_name,
		    sizeof(arcn->ln_name));
d613 1
a613 2
		fieldcpy(hd->linkname, sizeof(hd->linkname), arcn->ln_name,
		    sizeof(arcn->ln_name));
d956 1
a956 2
		fieldcpy(hd->prefix, sizeof(hd->prefix), arcn->name,
		    sizeof(arcn->name));
d964 1
a964 2
	fieldcpy(hd->name, sizeof(hd->name), pt,
	    sizeof(arcn->name) - (pt - arcn->name));
d1000 1
a1000 2
		fieldcpy(hd->linkname, sizeof(hd->linkname), arcn->ln_name,
		    sizeof(arcn->ln_name));
@


1.1.1.4
log
@One "miserable" byte in filenames is worth an import

agreed bsiegert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.41 2006/03/04 20:24:55 otto Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: tar.c,v 1.41 2006/03/04 20:24:55 otto Exp $";
d643 1
a643 1
	    ul_oct((u_long)(u_int)arcn->sb.st_mtime, hd->mtime, sizeof(hd->mtime), 1))
d929 1
a929 1
	    (arcn->type == PAX_HRG)) && (arcn->ln_nlen > sizeof(hd->linkname))){
d1070 1
a1070 1
	    ul_oct((u_long)(u_int)arcn->sb.st_mtime,hd->mtime,sizeof(hd->mtime),3))
a1118 2
	 * The strings can fill the complete name and prefix fields
	 * without a NUL terminator.
d1120 1
a1120 1
	if (len <= TNMSZ)
d1122 1
a1122 1
	if (len > (TPFSZ + TNMSZ + 1))
d1129 1
a1129 2
	 * prefix we can find) (the -1 is correct the biggest piece would
	 * include the slash between the two parts that gets thrown away)
d1131 1
a1131 1
	start = name + len - TNMSZ - 1;
d1149 1
a1149 1
	if ((len > TPFSZ) || (len == 0))
@


1.1.1.5
log
@import up-to-date pax from OpenBSD 5.1-current
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.43 2010/12/02 04:08:27 tedu Exp $	*/
d37 8
d806 1
a806 1
	if (Nflag || gid_name(hd->gname, &(arcn->sb.st_gid)) < 0)
d809 1
a809 1
	if (Nflag || uid_name(hd->uname, &(arcn->sb.st_uid)) < 0)
d1072 2
a1073 7
	if (!Nflag) {
		strncpy(hd->uname, name_uid(arcn->sb.st_uid, 0), sizeof(hd->uname));
		strncpy(hd->gname, name_gid(arcn->sb.st_gid, 0), sizeof(hd->gname));
	} else {
		strncpy(hd->uname, "", sizeof(hd->uname));
		strncpy(hd->gname, "", sizeof(hd->gname));
	}
@


1.1.1.6
log
@pull newer paxtar from OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.59 2016/02/15 02:38:53 guenther Exp $	*/
d40 1
a40 3
#include <ctype.h>
#include <errno.h>
#include <limits.h>
d57 1
a58 2
#ifndef SMALL
static int rd_xheader(ARCHD *arcn, int, off_t);
d70 1
a70 1
int tar_nodir;				/* do not write dirs under old tar */
d197 1
d251 1
a379 1
	u_quad_t val;
d405 3
d409 2
a410 5
	val = asc_uqd(hd->mtime, sizeof(hd->mtime), OCT);
	if ((time_t)val < 0 || (time_t)val != val)
		arcn->sb.st_mtime = INT_MAX;                    /* XXX 2038 */
	else
		arcn->sb.st_mtime = val;
d602 1
a602 1
	} else if (PAX_IS_HARDLINK(arcn->type)) {
d616 4
d622 1
a632 2
	    uqd_oct(arcn->sb.st_mtime < 0 ? 0 : arcn->sb.st_mtime, hd->mtime,
		sizeof(hd->mtime), 1) ||
d634 2
a635 1
	    ul_oct((u_long)arcn->sb.st_gid, hd->gid, sizeof(hd->gid), 0))
d650 1
a650 1
	if (PAX_IS_REG(arcn->type))
d739 1
a739 1
	HD_USTAR *hd = (HD_USTAR *)buf;
a743 1
	u_quad_t val;
a749 4

#ifndef SMALL
reset:
#endif
d753 1
d755 13
a767 16
#ifndef SMALL
	/* Process Extended headers. */
	if (hd->typeflag == XHDRTYPE || hd->typeflag == GHDRTYPE) {
		if (rd_xheader(arcn, hd->typeflag == GHDRTYPE,
		    (off_t)asc_ul(hd->size, sizeof(hd->size), OCT)) < 0)
			return (-1);

		/* Update and check the ustar header. */
		if (rd_wrbuf(buf, BLKMULT) != BLKMULT)
			return (-1);
		if (ustar_id(buf, BLKMULT) < 0)
			return(-1);

		/* if the next block is another extension, reset the values */
		if (hd->typeflag == XHDRTYPE || hd->typeflag == GHDRTYPE)
			goto reset;
a768 1
#endif
d770 3
a772 26
	if (!arcn->nlen) {
		/*
		 * See if the filename is split into two parts. if, so join
		 * the parts.  We copy the prefix first and add a / between
		 * the prefix and name.
		 */
		dest = arcn->name;
		if (*(hd->prefix) != '\0') {
			cnt = fieldcpy(dest, sizeof(arcn->name) - 1,
			    hd->prefix, sizeof(hd->prefix));
			dest += cnt;
			*dest++ = '/';
			cnt++;
		} else
			cnt = 0;

		if (hd->typeflag != LONGLINKTYPE &&
		    hd->typeflag != LONGNAMETYPE) {
			arcn->nlen = cnt + expandname(dest,
			    sizeof(arcn->name) - cnt, &gnu_name_string,
			    hd->name, sizeof(hd->name));
		}
	}

	if (!arcn->ln_nlen &&
	    hd->typeflag != LONGLINKTYPE && hd->typeflag != LONGNAMETYPE) {
d783 3
d787 2
a788 5
	val = asc_uqd(hd->mtime, sizeof(hd->mtime), OCT);
	if ((time_t)val < 0 || (time_t)val != val)
		arcn->sb.st_mtime = INT_MAX;                    /* XXX 2038 */
	else
		arcn->sb.st_mtime = val;
a917 6
	 * user asked that dirs not be written to the archive
	 */
	if (arcn->type == PAX_DIR && tar_nodir)
		return (1);

	/*
d920 2
a921 1
	if (PAX_IS_LINK(arcn->type) && (arcn->ln_nlen > sizeof(hd->linkname))) {
d1013 4
d1019 1
d1061 2
a1062 3
	if (uqd_oct(arcn->sb.st_mtime < 0 ? 0 : arcn->sb.st_mtime, hd->mtime,
		sizeof(hd->mtime), 3) ||
	    ul_oct((u_long)arcn->sb.st_mode, hd->mode, sizeof(hd->mode), 3))
d1084 1
a1084 1
	if (PAX_IS_REG(arcn->type))
a1131 10

	/*
	 * the prefix may not be empty, so skip the first character when
	 * trying to split a path of exactly TNMSZ+1 characters.
	 * NOTE: This means the ustar format can't store /str if
	 * str contains no slashes and the length of str == TNMSZ
	 */
	if (start == name)
		++start;

d1141 1
d1144 4
a1147 2
	 * the split point isn't valid if it results in a prefix
	 * longer than TPFSZ
d1149 1
a1149 1
	if ((start - name) > TPFSZ)
a1173 97

#ifndef SMALL

/* shortest possible extended record: "5 a=\n" */
#define MINXHDRSZ	5

/* longest record we'll accept */
#define MAXXHDRSZ	BLKMULT

static int
rd_xheader(ARCHD *arcn, int global, off_t size)
{
	char buf[MAXXHDRSZ];
	unsigned long len;
	char *delim, *keyword;
	char *nextp, *p, *end;
	int pad, ret = 0;

	/* before we alter size, make note of how much we have to skip */
	pad = TAR_PAD((unsigned)size);

	p = end = buf;
	while (size > 0 || p < end) {
		if (size > 0) {
			int rdlen;

			/* shift stuff down */
			if (p > buf) {
				memmove(buf, p, end - p);
				end -= p - buf;
				p = buf;
			}

			/* fill starting at end */
			rdlen = MINIMUM(size, (buf + sizeof buf) - end);
			if (rd_wrbuf(end, rdlen) != rdlen) {
				ret = -1;
				break;
			}
			size -= rdlen;
			end += rdlen;
		}

		/* [p, end) is good */
		if (memchr(p, ' ', end - p) == NULL ||
		    !isdigit((unsigned char)*p)) {
			paxwarn(1, "Invalid extended header record");
			ret = -1;
			break;
		}
		errno = 0;
		len = strtoul(p, &delim, 10);
		if (*delim != ' ' || (errno == ERANGE && len == ULONG_MAX) ||
		    len < MINXHDRSZ) {
			paxwarn(1, "Invalid extended header record length");
			ret = -1;
			break;
		}
		if (len > end - p) {
			paxwarn(1, "Extended header record length %lu is "
			    "out of range", len);
			/* if we can just toss this record, do so */
			len -= end - p;
			if (len <= size && rd_skip(len) == 0) {
				size -= len;
				p = end = buf;
				continue;
			}
			ret = -1;
			break;
		}
		nextp = p + len;
		keyword = p = delim + 1;
		p = memchr(p, '=', len);
		if (!p || nextp[-1] != '\n') {
			paxwarn(1, "Malformed extended header record");
			ret = -1;
			break;
		}
		*p++ = nextp[-1] = '\0';
		if (!global) {
			if (!strcmp(keyword, "path")) {
				arcn->nlen = strlcpy(arcn->name, p,
				    sizeof(arcn->name));
			} else if (!strcmp(keyword, "linkpath")) {
				arcn->ln_nlen = strlcpy(arcn->ln_name, p,
				    sizeof(arcn->ln_name));
			}
		}
		p = nextp;
	}

	if (rd_skip(size + pad) < 0)
		return (-1);
	return (ret);
}
#endif
@


1.1.1.7
log
@revert the import; we’ll just backport the CVE fixes, for now ☹
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.43 2010/12/02 04:08:27 tedu Exp $	*/
d40 3
a42 1
#include <sys/param.h>
a58 1
#ifndef LONG_OFF_T
d60 2
d73 1
a73 1
static int tar_nodir;			/* do not write dirs under old tar */
a199 1
#ifndef LONG_OFF_T
a252 1
#endif
d381 1
a406 3
#ifdef LONG_OFF_T
	arcn->sb.st_size = (off_t)asc_ul(hd->size, sizeof(hd->size), OCT);
#else
d408 5
a412 2
#endif
	arcn->sb.st_mtime = (time_t)asc_ul(hd->mtime, sizeof(hd->mtime), OCT);
d604 1
a604 1
	} else if ((arcn->type == PAX_HLK) || (arcn->type == PAX_HRG)) {
a617 4
#		ifdef LONG_OFF_T
		if (ul_oct((u_long)arcn->sb.st_size, hd->size,
		    sizeof(hd->size), 1)) {
#		else
a619 1
#		endif
d630 2
d633 1
a633 2
	    ul_oct((u_long)arcn->sb.st_gid, hd->gid, sizeof(hd->gid), 0) ||
	    ul_oct((u_long)(u_int)arcn->sb.st_mtime, hd->mtime, sizeof(hd->mtime), 1))
d648 1
a648 1
	if ((arcn->type == PAX_CTG) || (arcn->type == PAX_REG))
d737 1
a737 1
	HD_USTAR *hd;
d742 1
d749 4
a755 1
	hd = (HD_USTAR *)buf;
d757 41
a797 13
	/*
	 * see if the filename is split into two parts. if, so joint the parts.
	 * we copy the prefix first and add a / between the prefix and name.
	 */
	dest = arcn->name;
	if (*(hd->prefix) != '\0') {
		cnt = fieldcpy(dest, sizeof(arcn->name) - 1, hd->prefix,
		    sizeof(hd->prefix));
		dest += cnt;
		*dest++ = '/';
		cnt++;
	} else {
		cnt = 0;
d800 2
a801 3
	if (hd->typeflag != LONGLINKTYPE && hd->typeflag != LONGNAMETYPE) {
		arcn->nlen = cnt + expandname(dest, sizeof(arcn->name) - cnt,
		    &gnu_name_string, hd->name, sizeof(hd->name));
a811 3
#ifdef LONG_OFF_T
	arcn->sb.st_size = (off_t)asc_ul(hd->size, sizeof(hd->size), OCT);
#else
d813 5
a817 2
#endif
	arcn->sb.st_mtime = (time_t)asc_ul(hd->mtime, sizeof(hd->mtime), OCT);
d947 6
d955 1
a955 2
	if (((arcn->type == PAX_SLK) || (arcn->type == PAX_HLK) ||
	    (arcn->type == PAX_HRG)) && (arcn->ln_nlen > sizeof(hd->linkname))){
a1046 4
#		ifdef LONG_OFF_T
		if (ul_oct((u_long)arcn->sb.st_size, hd->size,
		    sizeof(hd->size), 3)) {
#		else
a1048 1
#		endif
d1090 3
a1092 2
	if (ul_oct((u_long)arcn->sb.st_mode, hd->mode, sizeof(hd->mode), 3) ||
	    ul_oct((u_long)(u_int)arcn->sb.st_mtime,hd->mtime,sizeof(hd->mtime),3))
d1114 1
a1114 1
	if ((arcn->type == PAX_CTG) || (arcn->type == PAX_REG))
d1162 10
a1180 1
	len = start - name;
d1183 2
a1184 4
	 * NOTE: /str where the length of str == TNMSZ can not be stored under
	 * the p1003.1-1990 spec for ustar. We could force a prefix of / and
	 * the file would then expand on extract to //str. The len == 0 below
	 * makes this special case follow the spec to the letter.
d1186 1
a1186 1
	if ((len > TPFSZ) || (len == 0))
d1211 97
@


1.1.1.8
log
@bunch of cherry-picks from OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.43 +1.57 +1.59 2010/12/02 04:08:27 tedu Exp $	*/
d70 1
a70 1
int tar_nodir;				/* do not write dirs under old tar */
a1131 10

	/*
	 * the prefix may not be empty, so skip the first character when
	 * trying to split a path of exactly TNMSZ+1 characters.
	 * NOTE: This means the ustar format can't store /str if
	 * str contains no slashes and the length of str == TNMSZ
	 */
	if (start == name)
		++start;

d1141 1
d1144 4
a1147 2
	 * the split point isn't valid if it results in a prefix
	 * longer than TPFSZ
d1149 1
a1149 1
	if ((start - name) > TPFSZ)
@


1.1.1.9
log
@merge what OpenBSD did between our last cherry-pick and today minus one commit

(“Use the new libc uid_from_user() and gid_from_group() instead of
  the pax-specific functions in cache.c” is ignored, for now)
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.66 2017/09/16 07:42:34 otto Exp $	*/
d547 1
a547 1
		if ((size_t)arcn->ln_nlen > sizeof(hd->linkname)) {
d565 1
a565 1
	if ((size_t)len > sizeof(hd->name)) {
@


1.1.1.10
log
@Import latest OpenBSD paxtar, unmodified, into vendor branch
@
text
@d1 1
a1 1
/*	$OpenBSD: tar.c,v 1.67 2018/09/13 12:33:43 millert Exp $	*/
d38 1
d40 2
a41 5
#include <ctype.h>
#include <errno.h>
#include <grp.h>
#include <limits.h>
#include <pwd.h>
d43 1
a44 3
#include <string.h>
#include <unistd.h>

d57 2
a58 3
static int ull_oct(unsigned long long, char *, int, int);
#ifndef SMALL
static int rd_xheader(ARCHD *arcn, int, off_t);
d84 1
a84 1
	return wr_skip(NULLCNT * BLKMULT);
d97 1
a97 1
	return NULLCNT * BLKMULT;
d186 1
a186 2
		val >>= 3;
		if (val == 0)
d192 1
a192 1
	if (val != 0)
d197 1
d199 6
a204 6
 * ull_oct()
 *	Convert an unsigned long long to an octal string.  One of many oddball
 *	field termination characters are used by the various versions of tar
 *	in the different fields.  term selects which kind to use.  str is
 *	'0' padded at the front to len.  We are unable to use only one format
 *	as many old tar readers are very cranky about this.
d210 1
a210 1
ull_oct(unsigned long long val, char *str, int len, int term)
d241 1
a241 2
		val >>= 3;
		if (val == 0)
d247 1
a247 1
	if (val != 0)
d251 1
a379 1
	unsigned long long val;
d405 6
a410 6
	arcn->sb.st_size = (off_t)asc_ull(hd->size, sizeof(hd->size), OCT);
	val = asc_ull(hd->mtime, sizeof(hd->mtime), OCT);
	if (val > MAX_TIME_T)
		arcn->sb.st_mtime = INT_MAX;                    /* XXX 2038 */
	else
		arcn->sb.st_mtime = val;
d591 1
a591 1
		if (ul_oct(0, hd->size, sizeof(hd->size), 1))
d600 1
a600 1
		if (ul_oct(0, hd->size, sizeof(hd->size), 1))
d602 1
a602 1
	} else if (PAX_IS_HARDLINK(arcn->type)) {
d609 1
a609 1
		if (ul_oct(0, hd->size, sizeof(hd->size), 1))
d616 8
a623 3
		if (ull_oct(arcn->sb.st_size, hd->size, sizeof(hd->size), 1)) {
			paxwarn(1, "File is too large for tar %s",
			    arcn->org_name);
d632 4
a635 5
	if (ul_oct(arcn->sb.st_mode, hd->mode, sizeof(hd->mode), 0) ||
	    ull_oct(arcn->sb.st_mtime < 0 ? 0 : arcn->sb.st_mtime, hd->mtime,
		sizeof(hd->mtime), 1) ||
	    ul_oct(arcn->sb.st_uid, hd->uid, sizeof(hd->uid), 0) ||
	    ul_oct(arcn->sb.st_gid, hd->gid, sizeof(hd->gid), 0))
d648 1
a648 1
	if (wr_skip(BLKMULT - sizeof(HD_TAR)) < 0)
d650 1
a650 1
	if (PAX_IS_REG(arcn->type))
d667 30
d739 1
a739 1
	HD_USTAR *hd = (HD_USTAR *)buf;
a743 1
	unsigned long long val;
a749 4

#ifndef SMALL
reset:
#endif
d753 1
d755 13
a767 16
#ifndef SMALL
	/* Process Extended headers. */
	if (hd->typeflag == XHDRTYPE || hd->typeflag == GHDRTYPE) {
		if (rd_xheader(arcn, hd->typeflag == GHDRTYPE,
		    (off_t)asc_ul(hd->size, sizeof(hd->size), OCT)) < 0)
			return (-1);

		/* Update and check the ustar header. */
		if (rd_wrbuf(buf, BLKMULT) != BLKMULT)
			return (-1);
		if (ustar_id(buf, BLKMULT) < 0)
			return(-1);

		/* if the next block is another extension, reset the values */
		if (hd->typeflag == XHDRTYPE || hd->typeflag == GHDRTYPE)
			goto reset;
a768 1
#endif
d770 3
a772 26
	if (!arcn->nlen) {
		/*
		 * See if the filename is split into two parts. if, so join
		 * the parts.  We copy the prefix first and add a / between
		 * the prefix and name.
		 */
		dest = arcn->name;
		if (*(hd->prefix) != '\0') {
			cnt = fieldcpy(dest, sizeof(arcn->name) - 1,
			    hd->prefix, sizeof(hd->prefix));
			dest += cnt;
			*dest++ = '/';
			cnt++;
		} else
			cnt = 0;

		if (hd->typeflag != LONGLINKTYPE &&
		    hd->typeflag != LONGNAMETYPE) {
			arcn->nlen = cnt + expandname(dest,
			    sizeof(arcn->name) - cnt, &gnu_name_string,
			    hd->name, sizeof(hd->name));
		}
	}

	if (!arcn->ln_nlen &&
	    hd->typeflag != LONGLINKTYPE && hd->typeflag != LONGNAMETYPE) {
d783 6
a788 6
	arcn->sb.st_size = (off_t)asc_ull(hd->size, sizeof(hd->size), OCT);
	val = asc_ull(hd->mtime, sizeof(hd->mtime), OCT);
	if (val > MAX_TIME_T)
		arcn->sb.st_mtime = INT_MAX;                    /* XXX 2038 */
	else
		arcn->sb.st_mtime = val;
d798 1
a798 1
	if (Nflag || gid_from_group(hd->gname, &(arcn->sb.st_gid)) < 0)
d801 1
a801 1
	if (Nflag || uid_from_user(hd->uname, &(arcn->sb.st_uid)) < 0)
d906 2
a907 2
	const char *name;
	char *pt, hdblk[sizeof(HD_USTAR)];
a917 6
	 * user asked that dirs not be written to the archive
	 */
	if (arcn->type == PAX_DIR && tar_nodir)
		return (1);

	/*
d920 2
a921 2
	if (PAX_IS_LINK(arcn->type) &&
	    ((size_t)arcn->ln_nlen > sizeof(hd->linkname))) {
d940 1
a940 1
	arcn->pad = 0;
d969 1
a969 1
		if (ul_oct(0, hd->size, sizeof(hd->size), 3))
d978 1
a978 1
		if (ul_oct(MAJOR(arcn->sb.st_rdev), hd->devmajor,
d980 1
a980 1
		   ul_oct(MINOR(arcn->sb.st_rdev), hd->devminor,
d982 1
a982 1
		   ul_oct(0, hd->size, sizeof(hd->size), 3))
d987 1
a987 1
		if (ul_oct(0, hd->size, sizeof(hd->size), 3))
d999 1
a999 1
		if (ul_oct(0, hd->size, sizeof(hd->size), 3))
d1013 8
a1020 3
		if (ull_oct(arcn->sb.st_size, hd->size, sizeof(hd->size), 3)) {
			paxwarn(1, "File is too long for ustar %s",
			    arcn->org_name);
d1033 1
a1033 1
	if (ul_oct(arcn->sb.st_uid, hd->uid, sizeof(hd->uid), 3)) {
d1035 1
a1035 1
			if (uid_from_user("nobody", &uid_nobody) == -1)
d1044 1
a1044 1
		if (ul_oct(uid_nobody, hd->uid, sizeof(hd->uid), 3))
d1047 1
a1047 1
	if (ul_oct(arcn->sb.st_gid, hd->gid, sizeof(hd->gid), 3)) {
d1049 1
a1049 1
			if (gid_from_group("nobody", &gid_nobody) == -1)
d1058 1
a1058 1
		if (ul_oct(gid_nobody, hd->gid, sizeof(hd->gid), 3))
d1061 2
a1062 3
	if (ull_oct(arcn->sb.st_mtime < 0 ? 0 : arcn->sb.st_mtime, hd->mtime,
		sizeof(hd->mtime), 3) ||
	    ul_oct(arcn->sb.st_mode, hd->mode, sizeof(hd->mode), 3))
d1065 5
a1069 4
		if ((name = user_from_uid(arcn->sb.st_uid, 1)) != NULL)
			strncpy(hd->uname, name, sizeof(hd->uname));
		if ((name = group_from_gid(arcn->sb.st_gid, 1)) != NULL)
			strncpy(hd->gname, name, sizeof(hd->gname));
d1082 1
a1082 1
	if (wr_skip(BLKMULT - sizeof(HD_USTAR)) < 0)
d1084 1
a1084 1
	if (PAX_IS_REG(arcn->type))
a1180 97

#ifndef SMALL

/* shortest possible extended record: "5 a=\n" */
#define MINXHDRSZ	5

/* longest record we'll accept */
#define MAXXHDRSZ	BLKMULT

static int
rd_xheader(ARCHD *arcn, int global, off_t size)
{
	char buf[MAXXHDRSZ];
	long len;
	char *delim, *keyword;
	char *nextp, *p, *end;
	int pad, ret = 0;

	/* before we alter size, make note of how much we have to skip */
	pad = TAR_PAD((unsigned)size);

	p = end = buf;
	while (size > 0 || p < end) {
		if (size > 0) {
			int rdlen;

			/* shift stuff down */
			if (p > buf) {
				memmove(buf, p, end - p);
				end -= p - buf;
				p = buf;
			}

			/* fill starting at end */
			rdlen = MINIMUM(size, (buf + sizeof buf) - end);
			if (rd_wrbuf(end, rdlen) != rdlen) {
				ret = -1;
				break;
			}
			size -= rdlen;
			end += rdlen;
		}

		/* [p, end) is good */
		if (memchr(p, ' ', end - p) == NULL ||
		    !isdigit((unsigned char)*p)) {
			paxwarn(1, "Invalid extended header record");
			ret = -1;
			break;
		}
		errno = 0;
		len = strtol(p, &delim, 10);
		if (*delim != ' ' || (errno == ERANGE && len == LONG_MAX) ||
		    len < MINXHDRSZ) {
			paxwarn(1, "Invalid extended header record length");
			ret = -1;
			break;
		}
		if (len > end - p) {
			paxwarn(1, "Extended header record length %lu is "
			    "out of range", len);
			/* if we can just toss this record, do so */
			len -= end - p;
			if (len <= size && rd_skip(len) == 0) {
				size -= len;
				p = end = buf;
				continue;
			}
			ret = -1;
			break;
		}
		nextp = p + len;
		keyword = p = delim + 1;
		p = memchr(p, '=', len);
		if (!p || nextp[-1] != '\n') {
			paxwarn(1, "Malformed extended header record");
			ret = -1;
			break;
		}
		*p++ = nextp[-1] = '\0';
		if (!global) {
			if (!strcmp(keyword, "path")) {
				arcn->nlen = strlcpy(arcn->name, p,
				    sizeof(arcn->name));
			} else if (!strcmp(keyword, "linkpath")) {
				arcn->ln_nlen = strlcpy(arcn->ln_name, p,
				    sizeof(arcn->ln_name));
			}
		}
		p = nextp;
	}

	if (rd_skip(size + pad) < 0)
		return (-1);
	return (ret);
}
#endif
@


1.1.1.10.2.1
log
@Wrangle the OpenBSD branch into shape as starting point:

• Revert “Use the new libc uid_from_user() and gid_from_group()
  instead of the pax-specific functions in cache.c” (revisit later)
• fix MAX_TIME_T (plain wrong), mirtoconf later
• drop all NOCPIO
• Revert “Replace name_{uid,gid}() with the libc routines
  user_from_uid() and group_from_gid()”
@
text
@a668 30
 * ustar_strd()
 *	initialization for ustar read
 * Return:
 *	0 if ok, -1 otherwise
 */

int
ustar_strd(void)
{
	if ((usrtb_start() < 0) || (grptb_start() < 0))
		return(-1);
	return(0);
}

/*
 * ustar_stwr()
 *	initialization for ustar write
 * Return:
 *	0 if ok, -1 otherwise
 */

int
ustar_stwr(void)
{
	if ((uidtb_start() < 0) || (gidtb_start() < 0))
		return(-1);
	return(0);
}

/*
d801 1
a801 1
	if (Nflag || gid_name(hd->gname, &(arcn->sb.st_gid)) < 0)
d804 1
a804 1
	if (Nflag || uid_name(hd->uname, &(arcn->sb.st_uid)) < 0)
d1039 1
a1039 1
			if (uid_name("nobody", &uid_nobody) == -1)
d1053 1
a1053 1
			if (gid_name("nobody", &gid_nobody) == -1)
d1070 1
a1070 1
		if ((name = name_uid(arcn->sb.st_uid, 0)) != NULL)
d1072 1
a1072 1
		if ((name = name_gid(arcn->sb.st_gid, 0)) != NULL)
@


1.1.1.10.2.2
log
@normalise whitespace at EOL, EOF, adjacent newlines
@
text
@d372 1
@


1.1.1.10.2.3
log
@extremely rudimentary conversion to mirtoconf, doesn’t even build yet
@
text
@a40 1
#if HAVE_GRP_H
a41 1
#endif
a46 3
#if HAVE_STRINGS_H
#include <strings.h>
#endif
@


1.1.1.10.2.4
log
@do the ‘c’s
@
text
@d531 1
a531 1
	 * check for those filesystem types which tar cannot store
d542 1
a542 1
		paxwarn(1, "tar cannot archive a character device %s",
d546 1
a546 1
		paxwarn(1, "tar cannot archive a block device %s", arcn->org_name);
d549 1
a549 1
		paxwarn(1, "tar cannot archive a socket %s", arcn->org_name);
d552 1
a552 1
		paxwarn(1, "tar cannot archive a fifo %s", arcn->org_name);
d664 1
a664 1
	paxwarn(1, "tar header field is too small for %s", arcn->org_name);
d947 1
a947 1
	 * check for those filesystem types ustar cannot store
d950 1
a950 1
		paxwarn(1, "ustar cannot archive a socket %s", arcn->org_name);
d1079 1
a1079 1
			    "ustar header field is too small for uid %lu, "
d1093 1
a1093 1
			    "ustar header field is too small for gid %lu, "
d1130 1
a1130 1
	paxwarn(1, "ustar header field is too small for %s", arcn->org_name);
@


1.1.1.10.2.5
log
@tar, and make ANONARCH_DEBUG ifndef SMALL
@
text
@a4 2
 * Copyright (c) 2006, 2012, 2016, 2017
 *	mirabilos <m@@mirbsd.org>
a67 1
static void tar_dbgfld(const char *, const char *, size_t);
a79 1
#ifndef SMALL
a80 1
#endif
d94 1
a94 1
	return (wr_skip(NULLCNT * BLKMULT));
d107 1
a107 1
	return (NULLCNT * BLKMULT);
d122 1
a122 1
tar_trail(ARCHD *ignore MKSH_A_UNUSED, char *buf, int in_resync, int *cnt)
a300 1
#ifndef SMALL
d427 1
a427 1
	pt = arcn->nlen > 0 ? &(arcn->name[arcn->nlen - 1]) : NULL;
d480 1
a480 1
		if (pt && *pt == '/') {
d504 1
a504 1
	if (pt && *pt == '/') {
d508 1
a508 1
	return (0);
d660 1
a660 1
 out:
d695 1
a695 1
ustar_stwr(int is_app MKSH_A_UNUSED)
d835 1
a835 2
	if ((anonarch & ANON_NUMID) ||
	    gid_name(hd->gname, &(arcn->sb.st_gid)) < 0)
d838 1
a838 2
	if ((anonarch & ANON_NUMID) ||
	    uid_name(hd->uname, &(arcn->sb.st_uid)) < 0)
a944 4
	u_long t_uid, t_gid;
	time_t t_mtime;

	anonarch_init();
a969 9
	 * if -M gslash: append a slash if directory
	 */
	if ((anonarch & ANON_DIRSLASH) && arcn->type == PAX_DIR &&
	    (size_t)arcn->nlen < (sizeof(arcn->name) - 1)) {
		arcn->name[arcn->nlen++] = '/';
		arcn->name[arcn->nlen] = '\0';
	}

	/*
a1005 4
	t_uid   = (anonarch & ANON_UIDGID) ? 0UL : (u_long)arcn->sb.st_uid;
	t_gid   = (anonarch & ANON_UIDGID) ? 0UL : (u_long)arcn->sb.st_gid;
	t_mtime = (anonarch & ANON_MTIME)  ? 0UL : arcn->sb.st_mtime;

d1071 1
a1071 1
	if (ul_oct(t_uid, hd->uid, sizeof(hd->uid), 3)) {
d1076 2
a1077 2
		if (uid_warn != t_uid) {
			uid_warn = t_uid;
d1080 1
a1080 1
			    "using nobody", t_uid);
d1085 1
a1085 1
	if (ul_oct(t_gid, hd->gid, sizeof(hd->gid), 3)) {
d1090 2
a1091 2
		if (gid_warn != t_gid) {
			gid_warn = t_gid;
d1094 1
a1094 1
			    "using nobody", t_gid);
d1099 2
a1100 1
	if (ull_oct(t_mtime < 0 ? 0 : t_mtime, hd->mtime, sizeof(hd->mtime), 3) ||
d1103 1
a1103 1
	if (!(anonarch & ANON_NUMID)) {
a1117 24

#ifndef SMALL
	if (anonarch & ANON_DEBUG) {
		tar_dbgfld(NULL, NULL, 0);
		tar_dbgfld("writing name '", hd->name, TNMSZ);
		tar_dbgfld("' mode ", hd->mode, 8);
		tar_dbgfld(" uid ", hd->uid, 8);
		tar_dbgfld(" (", hd->uname, 32);
		tar_dbgfld(") gid ", hd->gid, 8);
		tar_dbgfld(" (", hd->gname, 32);
		tar_dbgfld(") size ", hd->size, 12);
		tar_dbgfld(" mtime ", hd->mtime, 12);
		tar_dbgfld(" type ", &(hd->typeflag), 1);
		tar_dbgfld(" linked to '", hd->linkname, TNMSZ);
		tar_dbgfld("' magic '", hd->magic, TMAGLEN);
		tar_dbgfld("' v", hd->version, TVERSLEN);
		tar_dbgfld(" device '", hd->devmajor, 8);
		tar_dbgfld(":", hd->devminor, 8);
		tar_dbgfld("' prefix '", hd->prefix, TPFSZ);
		tar_dbgfld("' checksum ", hd->chksum, CHK_LEN);
		tar_dbgfld(NULL, NULL, 1);
	}
#endif

d1126 1
a1126 1
 out:
a1220 35
static void
tar_dbgfld(const char *pfx, const char *sp, size_t len)
{
	static char fbuf[256];
	char tbuf[256], *s;

	if ((pfx == NULL) || (sp == NULL)) {
		if ((pfx == NULL) && (sp == NULL)) {
			if (len == 0) {
				*fbuf = 0;
			} else {
				paxwarn(0, "%s", fbuf);
			}
		} else
			paxwarn(0, "tar_dbgfld: wrong call");
		return;
	}

	strlcat(fbuf, pfx, sizeof (fbuf));

	if (len == 0)
		return;

	if (len > (sizeof (tbuf) - 1))
		len = sizeof (tbuf) - 1;

	memmove(s = tbuf, sp, len);
	tbuf[len] = 0;
	while (*s == ' ')
		++s;
	while (s[strlen(s) - 1] == ' ')
		s[strlen(s) - 1] = 0;

	strlcat(fbuf, tbuf, sizeof (fbuf));
}
@


1.1.1.10.2.6
log
@revisit all those initial reverts
@
text
@a687 1
#if !HAVE_UGID_FROM_UG
a689 1
#endif
a702 1
#if !HAVE_UG_FROM_UGID
a704 1
#endif
@


1.1.1.10.2.7
log
@huh… it builds
@
text
@a672 1
#endif
@


