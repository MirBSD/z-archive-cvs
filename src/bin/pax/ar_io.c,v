head	1.28;
access;
symbols
	paxmirabilis-20190825:1.28
	paxmirabilis-20190224:1.28
	paxmirabilis-20190210:1.28
	npax:1.1.1.9.0.2
	cvs-20181212:1.1.1.9
	paxmirabilis-20171021:1.23
	paxmirabilis-20161104:1.21
	paxmirabilis-20161031:1.21
	paxmirabilis-20161025:1.21
	paxmirabilis-20160306:1.19
	cvs-201603041945:1.1.1.4
	paxmirabilis-20151013:1.18
	paxmirabilis-20140703:1.18
	paxmirabilis-20120606:1.18
	paxmirabilis-20120605:1.18
	cvs-201206051745:1.1.1.3
	paxmirabilis-20120520:1.17
	paxmirabilis-20120216:1.14
	paxmirabilis-20120212:1.11
	cvs-201202112230:1.1.1.3
	paxmirabilis-20110817:1.10
	MIRBSD_10:1.8.0.2
	MIRBSD_10_BASE:1.8
	cvs-200710231945:1.1.1.2
	cvs-200606232242:1.1.1.2
	MIRBSD_9_BASE:1.6
	MIRBSD_8:1.4.0.2
	MIRBSD_8_BASE:1.4
	cvs-200507211800:1.1.1.1
	cvs-200504291700:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.28
date	2019.02.10.21.50.06;	author tg;	state Exp;
branches;
next	1.27;
commitid	1005C609C8F43A9BDCB;

1.27
date	2018.12.13.07.09.08;	author tg;	state Exp;
branches;
next	1.26;
commitid	1005C1205A44B32AFA4;

1.26
date	2018.12.12.18.08.41;	author tg;	state Exp;
branches;
next	1.25;
commitid	1005C114EA81986F5EC;

1.25
date	2018.12.12.00.23.04;	author tg;	state Exp;
branches;
next	1.24;
commitid	1005C1054FE750D63F3;

1.24
date	2018.10.07.01.10.12;	author tg;	state Exp;
branches;
next	1.23;
commitid	1005BB95CA10BF418E8;

1.23
date	2017.10.14.00.25.40;	author tg;	state Exp;
branches;
next	1.22;
commitid	10059E1599C715A08C3;

1.22
date	2017.08.08.16.42.49;	author tg;	state Exp;
branches;
next	1.21;
commitid	1005989EA23421E2092;

1.21
date	2016.10.25.19.00.27;	author tg;	state Exp;
branches;
next	1.20;
commitid	100580FABDA6C691A00;

1.20
date	2016.10.25.18.57.54;	author tg;	state Exp;
branches;
next	1.19;
commitid	100580FAB4B20AD4FA2;

1.19
date	2016.03.06.13.47.11;	author tg;	state Exp;
branches;
next	1.18;
commitid	10056DC34E25F0AA0A6;

1.18
date	2012.06.05.19.09.41;	author tg;	state Exp;
branches;
next	1.17;
commitid	1004FCE598C750277B2;

1.17
date	2012.05.20.17.21.44;	author tg;	state Exp;
branches;
next	1.16;
commitid	1004FB9283F72C8E596;

1.16
date	2012.05.20.16.13.15;	author tg;	state Exp;
branches;
next	1.15;
commitid	1004FB918314D2FECC0;

1.15
date	2012.05.20.16.05.04;	author tg;	state Exp;
branches;
next	1.14;
commitid	1004FB9164725036FF3;

1.14
date	2012.02.16.17.27.30;	author tg;	state Exp;
branches;
next	1.13;
commitid	1004F3D3C992B2187A1;

1.13
date	2012.02.16.17.11.45;	author tg;	state Exp;
branches;
next	1.12;
commitid	1004F3D38626EFD0781;

1.12
date	2012.02.16.16.01.07;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004F3D28152C6F33B8;

1.11
date	2012.02.12.00.27.14;	author tg;	state Exp;
branches;
next	1.10;
commitid	1004F3707786D20BF4A;

1.10
date	2011.08.16.21.32.45;	author tg;	state Exp;
branches;
next	1.9;
commitid	1004E4AE1EF00AF3003;

1.9
date	2009.10.04.14.51.06;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004AC8B662360E113C;

1.8
date	2007.02.17.04.52.39;	author tg;	state Exp;
branches;
next	1.7;
commitid	10045D68A2D54E2C558;

1.7
date	2007.02.17.04.12.40;	author tg;	state Exp;
branches;
next	1.6;
commitid	10045D680CA45EDA543;

1.6
date	2006.06.23.23.03.55;	author tg;	state Exp;
branches;
next	1.5;
commitid	100449C736877C98FFB;

1.5
date	2006.02.09.17.10.19;	author tg;	state Exp;
branches;
next	1.4;
commitid	10043EB778A57D607BC;

1.4
date	2005.04.13.20.11.24;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2005.04.13.20.03.34;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.04.13.19.49.34;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.22.06;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.22.06;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.06.23.23.00.11;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	100449C727D31170AA3;

1.1.1.3
date	2012.02.11.22.47.21;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	1004F36F008225F3522;

1.1.1.4
date	2016.03.04.19.46.08;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	10056D9E61429EE6550;

1.1.1.5
date	2016.03.04.20.54.57;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	10056D9F62E152ECBA5;

1.1.1.6
date	2016.10.25.18.46.09;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	100580FA88137705D31;

1.1.1.7
date	2017.08.08.16.32.47;	author tg;	state Exp;
branches;
next	1.1.1.8;
commitid	1005989E7C267B5D4BA;

1.1.1.8
date	2018.12.12.00.15.03;	author tg;	state Exp;
branches;
next	1.1.1.9;
commitid	1005C1052FA5E745A2C;

1.1.1.9
date	2018.12.12.00.24.22;	author tg;	state Exp;
branches
	1.1.1.9.2.1;
next	;
commitid	1005C1055452C78F9E4;

1.1.1.9.2.1
date	2018.12.12.00.52.57;	author tg;	state Exp;
branches;
next	1.1.1.9.2.2;
commitid	1005C105BC86262A0B7;

1.1.1.9.2.2
date	2018.12.12.00.54.15;	author tg;	state Exp;
branches;
next	1.1.1.9.2.3;
commitid	1005C105C48612B0194;

1.1.1.9.2.3
date	2018.12.12.01.05.50;	author tg;	state Exp;
branches;
next	1.1.1.9.2.4;
commitid	1005C105F03799CC958;

1.1.1.9.2.4
date	2018.12.12.03.13.29;	author tg;	state Exp;
branches;
next	1.1.1.9.2.5;
commitid	1005C107CE315DC51F3;

1.1.1.9.2.5
date	2018.12.12.04.42.27;	author tg;	state Exp;
branches;
next	1.1.1.9.2.6;
commitid	1005C10915E305F127F;

1.1.1.9.2.6
date	2018.12.12.10.41.24;	author tg;	state Exp;
branches;
next	1.1.1.9.2.7;
commitid	1005C10E5E87909E6FC;

1.1.1.9.2.7
date	2018.12.12.15.00.23;	author tg;	state Exp;
branches;
next	1.1.1.9.2.8;
commitid	1005C11229872472EAF;

1.1.1.9.2.8
date	2018.12.12.15.08.29;	author tg;	state Exp;
branches;
next	;
commitid	1005C112483021C3062;


desc
@@


1.28
log
@port to Debian sid/{amd64,i386,hurd-i386,x32}, {stretch,jessie}/{amd64,i386}
@
text
@/*	$OpenBSD: ar_io.c,v 1.62 2017/03/11 12:55:47 tb Exp $	*/
/*	$NetBSD: ar_io.c,v 1.5 1996/03/26 23:54:13 mrg Exp $	*/

/*-
 * Copyright (c) 2012, 2016, 2017, 2019
 *	mirabilos <m@@mirbsd.org>
 * Copyright (c) 1992 Keith Muller.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#if HAVE_SYS_MTIO_H
#include <sys/mtio.h>
#endif
#include <sys/stat.h>
#include <sys/wait.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if HAVE_STRINGS_H
#include <strings.h>
#endif
#include <unistd.h>

#include "pax.h"
#include "extern.h"

__RCSID("$MirOS: src/bin/pax/ar_io.c,v 1.27 2018/12/13 07:09:08 tg Exp $");

#ifndef PAX_SAFE_PATH
#define PAX_SAFE_PATH "/bin:/usr/bin"
#endif

/*
 * Routines which deal directly with the archive I/O device/file.
 */

#define DMOD		0666		/* default mode of created archives */
#define EXT_MODE	O_RDONLY	/* open mode for list/extract */
#define AR_MODE		(O_WRONLY | O_CREAT | O_TRUNC)	/* mode for archive */
#define APP_MODE	O_RDWR		/* mode for append */
#define STDO		"<STDOUT>"	/* pseudo name for stdout */
#define STDN		"<STDIN>"	/* pseudo name for stdin */
int arfd = -1;				/* archive file descriptor */
static char artyp = ISREG;		/* archive type: file/FIFO/tape */
static int arvol = 1;			/* archive volume number */
static int lstrval = -1;		/* return value from last i/o */
static char io_ok;			/* i/o worked on volume after resync */
static char did_io;			/* did i/o ever occur on volume? */
static char done;			/* set via tty termination */
static struct stat arsb;		/* stat of archive device at open */
static char invld_rec;			/* tape has out of spec record size */
static char wr_trail = 1;		/* trailer was rewritten in append */
static char can_unlnk = 0;		/* do we unlink null archives?  */
const char *arcname;			/* printable name of archive */
static char *arcname_alloc = NULL;	/* this is so we can free(3) it */
const char *compress_program;		/* name of compression program */
static pid_t zpid = -1;			/* pid of child process */
char force_one_volume;			/* 1 if we ignore volume changes */

#if HAVE_SYS_MTIO_H
static int get_phys(void);
#endif
extern sigset_t s_mask;
static void ar_start_compress(int, int);

/*
 * ar_open()
 *	Opens the next archive volume. Determines the type of the device and
 *	sets up block sizes as required by the archive device and the format.
 *	Note: we may be called with name == NULL on the first open only.
 * Return:
 *	-1 on failure, 0 otherwise
 */

int
ar_open(const char *name)
{
#if HAVE_SYS_MTIO_H
	struct mtget mb;
#endif

	if (arfd != -1)
		(void)close(arfd);
	arfd = -1;
	can_unlnk = did_io = io_ok = invld_rec = 0;
	artyp = ISREG;
	flcnt = 0;

	/*
	 * open based on overall operation mode
	 */
	switch (act) {
	case LIST:
	case EXTRACT:
		if (name == NULL) {
			arfd = STDIN_FILENO;
			arcname = STDN;
		} else if ((arfd = binopen3(0, name, EXT_MODE, DMOD)) < 0)
			syswarn(1, errno, "Failed open to read on %s", name);
		if (arfd != -1 && compress_program != NULL)
			ar_start_compress(arfd, 0);
		break;
	case ARCHIVE:
		if (name == NULL) {
			arfd = STDOUT_FILENO;
			arcname = STDO;
		} else if ((arfd = binopen3(0, name, AR_MODE, DMOD)) < 0)
			syswarn(1, errno, "Failed open to write on %s", name);
		else
			can_unlnk = 1;
		if (arfd != -1 && compress_program != NULL)
			ar_start_compress(arfd, 1);
		break;
	case APPND:
		if (name == NULL) {
			arfd = STDOUT_FILENO;
			arcname = STDO;
		} else if ((arfd = binopen3(0, name, APP_MODE, DMOD)) < 0)
			syswarn(1, errno, "Failed open to read/write on %s",
				name);
		break;
	case COPY:
		/*
		 * arfd not used in COPY mode
		 */
		arcname = "<NONE>";
		lstrval = 1;
		return(0);
	}
	if (arfd < 0)
		return(-1);

	if (chdname != NULL)
		if (chdir(chdname) != 0) {
			syswarn(1, errno, "Failed chdir to %s", chdname);
			return(-1);
		}
	/*
	 * set up is based on device type
	 */
	if (fstat(arfd, &arsb) < 0) {
		syswarn(1, errno, "Failed stat on %s", arcname);
		(void)close(arfd);
		arfd = -1;
		can_unlnk = 0;
		return(-1);
	}
	if (S_ISDIR(arsb.st_mode)) {
		paxwarn(0, act == LIST || act == EXTRACT ?
		    "Cannot read an archive from a directory %s" :
		    "Cannot write an archive on top of a directory %s",
		    arcname);
		(void)close(arfd);
		arfd = -1;
		can_unlnk = 0;
		return(-1);
	}

	if (S_ISCHR(arsb.st_mode))
#if HAVE_SYS_MTIO_H
		artyp = ioctl(arfd, MTIOCGET, &mb) ? ISCHR : ISTAPE;
#else
		artyp = ISCHR;
#endif
	else if (S_ISBLK(arsb.st_mode))
		artyp = ISBLK;
	else if ((lseek(arfd, 0, SEEK_CUR) == -1) && (errno == ESPIPE))
		artyp = ISPIPE;
	else
		artyp = ISREG;

	/*
	 * make sure beyond any doubt that we can unlink only regular files
	 * we created
	 */
	if (artyp != ISREG)
		can_unlnk = 0;
	/*
	 * if we are writing, we are done
	 */
	if (act == ARCHIVE) {
		blksz = rdblksz = wrblksz;
		lstrval = 1;
		return(0);
	}

	/*
	 * set default blksz on read. APPNDs writes rdblksz on the last volume
	 * On all new archive volumes, we shift to wrblksz (if the user
	 * specified one, otherwise we will continue to use rdblksz). We
	 * must set blocksize based on what kind of device the archive is
	 * stored.
	 */
	switch (artyp) {
	case ISTAPE:
		/*
		 * Tape drives come in at least two flavors. Those that support
		 * variable sized records and those that have fixed sized
		 * records. They must be treated differently. For tape drives
		 * that support variable sized records, we must make large
		 * reads to make sure we get the entire record, otherwise we
		 * will just get the first part of the record (up to size we
		 * asked). Tapes with fixed sized records may or may not return
		 * multiple records in a single read. We really do not care
		 * what the physical record size is UNLESS we are going to
		 * append. (We will need the physical block size to rewrite
		 * the trailer). Only when we are appending do we go to the
		 * effort to figure out the true PHYSICAL record size.
		 */
		blksz = rdblksz = MAXBLK;
		break;
	case ISPIPE:
	case ISBLK:
	case ISCHR:
		/*
		 * Blocksize is not a major issue with these devices (but must
		 * be kept a multiple of 512). If the user specified a write
		 * block size, we use that to read. Under append, we must
		 * always keep blksz == rdblksz. Otherwise we go ahead and use
		 * the device optimal blocksize as (and if) returned by stat
		 * and if it is within pax specs.
		 */
		if ((act == APPND) && wrblksz) {
			blksz = rdblksz = wrblksz;
			break;
		}

		if ((arsb.st_blksize > 0) && (arsb.st_blksize < MAXBLK) &&
		    ((arsb.st_blksize % BLKMULT) == 0))
			rdblksz = arsb.st_blksize;
		else
			rdblksz = DEVBLK;
		/*
		 * For performance go for large reads when we can without harm
		 */
		if ((act == APPND) || (artyp == ISCHR))
			blksz = rdblksz;
		else
			blksz = MAXBLK;
		break;
	case ISREG:
		/*
		 * if the user specified wrblksz works, use it. Under appends
		 * we must always keep blksz == rdblksz
		 */
		if ((act == APPND) && wrblksz && ((arsb.st_size%wrblksz)==0)){
			blksz = rdblksz = wrblksz;
			break;
		}
		/*
		 * See if we can find the blocking factor from the file size
		 */
		for (rdblksz = MAXBLK; rdblksz > 0; rdblksz -= BLKMULT)
			if ((arsb.st_size % rdblksz) == 0)
				break;
		/*
		 * When we cannot find a match, we may have a flawed archive.
		 */
		if (rdblksz <= 0)
			rdblksz = FILEBLK;
		/*
		 * for performance go for large reads when we can
		 */
		if (act == APPND)
			blksz = rdblksz;
		else
			blksz = MAXBLK;
		break;
	default:
		/*
		 * should never happen, worst case, slow...
		 */
		blksz = rdblksz = BLKMULT;
		break;
	}
	lstrval = 1;
	return(0);
}

/*
 * ar_close(int int_sig)
 *	closes archive device, increments volume number, and prints i/o summary
 *	If in_sig is set we're in a signal handler and can't flush stdio.
 */
void
ar_close(int in_sig)
{
	int status;

	if (arfd < 0) {
		did_io = io_ok = flcnt = 0;
		if (vfpart) {
			(void)write(listfd, "\n", 1);
			vfpart = 0;
		}
		return;
	}
	if (!in_sig)
		fflush(listf);

	/*
	 * Close archive file. This may take a LONG while on tapes (we may be
	 * forced to wait for the rewind to complete) so tell the user what is
	 * going on (this avoids the user hitting control-c thinking pax is
	 * broken).
	 */
	if (vflag && (artyp == ISTAPE)) {
		(void)dprintf(listfd,
		    "%s%s: Waiting for tape drive close to complete...",
		    vfpart ? "\n" : "", argv0);
	}

	/*
	 * if nothing was written to the archive (and we created it), we remove
	 * it
	 */
	if (can_unlnk && (fstat(arfd, &arsb) == 0) && (S_ISREG(arsb.st_mode)) &&
	    (arsb.st_size == 0)) {
		(void)unlink(arcname);
		can_unlnk = 0;
	}

	/*
	 * for a quick extract/list, pax frequently exits before the child
	 * process is done
	 */
	if ((act == LIST || act == EXTRACT) && nflag && zpid > 0) {
		kill(zpid, SIGINT);
		zpid = -1;
	}

	(void)close(arfd);

	/* Do not exit before child to ensure data integrity */
	if (zpid > 0) {
		waitpid(zpid, &status, 0);
		if (!WIFEXITED(status) || WEXITSTATUS(status))
			exit_val = 1;
	}

	if (vflag && (artyp == ISTAPE)) {
		(void)write(listfd, "done.\n", sizeof("done.\n")-1);
		vfpart = 0;
	}
	arfd = -1;

	if (!io_ok && !did_io) {
		flcnt = 0;
		return;
	}
	did_io = io_ok = 0;

	/*
	 * The volume number is only increased when the last device has data
	 * and we have already determined the archive format.
	 */
	if (frmt != NULL)
		++arvol;

	/* Vflag can cause this to have been set */
	if (vfpart) {
		(void)write(listfd, "\n", 1);
		vfpart = 0;
	}

	/* nothing to do any more, unless vflag */
	if (!vflag) {
		flcnt = 0;
		return;
	}

	/*
	 * Print out a summary of I/O for this archive volume.
	 */

	/*
	 * If we have not determined the format yet, we just say how many bytes
	 * we have skipped over looking for a header to id. there is no way we
	 * could have written anything yet.
	 */
	if (frmt == NULL) {
		(void)dprintf(listfd,
		    "%s: unknown format, %" OT_FMT " bytes skipped.\n", argv0, rdcnt);
		flcnt = 0;
		return;
	}

	if (op_mode == OP_PAX)
		(void)dprintf(listfd, "%s: %s vol %d, %lu files,"
		    " %" OT_FMT " bytes read, %" OT_FMT " bytes written.\n",
		    argv0, frmt->name, arvol-1, flcnt, rdcnt, wrcnt);
	else if (op_mode == OP_CPIO)
		(void)dprintf(listfd, "%" OT_FMT " blocks\n",
		    (rdcnt ? rdcnt : wrcnt) / 5120);
	flcnt = 0;
}

/*
 * ar_drain()
 *	drain any archive format independent padding from an archive read
 *	from a socket or a pipe. This is to prevent the process on the
 *	other side of the pipe from getting a SIGPIPE (pax will stop
 *	reading an archive once a format dependent trailer is detected).
 */
void
ar_drain(void)
{
	int res;
	char drbuf[MAXBLK];

	/*
	 * we only drain from a pipe/socket. Other devices can be closed
	 * without reading up to end of file. We sure hope that pipe is closed
	 * on the other side so we will get an EOF.
	 */
	if ((artyp != ISPIPE) || (lstrval <= 0))
		return;

	/*
	 * keep reading until pipe is drained
	 */
	while ((res = read(arfd, drbuf, sizeof(drbuf))) > 0)
		continue;
	lstrval = res;
}

/*
 * ar_set_wr()
 *	Set up device right before switching from read to write in an append.
 *	device dependent code (if required) to do this should be added here.
 *	For all archive devices we are already positioned at the place we want
 *	to start writing when this routine is called.
 * Return:
 *	0 if all ready to write, -1 otherwise
 */

int
ar_set_wr(void)
{
	off_t cpos;

	/*
	 * we must make sure the trailer is rewritten on append, ar_next()
	 * will stop us if the archive containing the trailer was not written
	 */
	wr_trail = 0;

	/*
	 * Add any device dependent code as required here
	 */
	if (artyp != ISREG)
		return(0);
	/*
	 * Ok we have an archive in a regular file. If we were rewriting a
	 * file, we must get rid of all the stuff after the current offset
	 * (it was not written by pax).
	 */
	if (((cpos = lseek(arfd, 0, SEEK_CUR)) < 0) ||
	    (ftruncate(arfd, cpos) < 0)) {
		syswarn(1, errno, "Unable to truncate archive file");
		return(-1);
	}
	return(0);
}

/*
 * ar_app_ok()
 *	check if the last volume in the archive allows appends. We cannot check
 *	this until we are ready to write since there is no spec that says all
 *	volumes in a single archive have to be of the same type...
 * Return:
 *	0 if we can append, -1 otherwise.
 */

int
ar_app_ok(void)
{
	if (artyp == ISPIPE) {
		paxwarn(1, "Cannot append to an archive obtained from a pipe.");
		return(-1);
	}

	if (!invld_rec)
		return(0);
	paxwarn(1,"Cannot append, device record size %d does not support %s spec",
		rdblksz, argv0);
	return(-1);
}

/*
 * ar_read()
 *	read up to a specified number of bytes from the archive into the
 *	supplied buffer. When dealing with tapes we may not always be able to
 *	read what we want.
 * Return:
 *	Number of bytes in buffer. 0 for end of file, -1 for a read error.
 */

int
ar_read(char *buf, int cnt)
{
	int res = 0;

	/*
	 * if last i/o was in error, no more reads until reset or new volume
	 */
	if (lstrval <= 0)
		return(lstrval);

	/*
	 * how we read must be based on device type
	 */
	switch (artyp) {
	case ISTAPE:
		if ((res = read(arfd, buf, cnt)) > 0) {
			/*
			 * CAUTION: tape systems may not always return the same
			 * sized records so we leave blksz == MAXBLK. The
			 * physical record size that a tape drive supports is
			 * very hard to determine in a uniform and portable
			 * manner.
			 */
			io_ok = 1;
			if (res != rdblksz) {
				/*
				 * Record size changed. If this happens on
				 * any record after the first, we probably have
				 * a tape drive which has a fixed record size
				 * (we are getting multiple records in a single
				 * read). Watch out for record blocking that
				 * violates pax spec (must be a multiple of
				 * BLKMULT).
				 */
				rdblksz = res;
				if (rdblksz % BLKMULT)
					invld_rec = 1;
			}
			return(res);
		}
		break;
	case ISREG:
	case ISBLK:
	case ISCHR:
	case ISPIPE:
	default:
		/*
		 * Files are so easy to deal with. These other things cannot
		 * be trusted at all. So when we are dealing with character
		 * devices and pipes we just take what they have ready for us
		 * and return. Trying to do anything else with them runs the
		 * risk of failure.
		 */
		if ((res = read(arfd, buf, cnt)) > 0) {
			io_ok = 1;
			return(res);
		}
		break;
	}

	/*
	 * We are in trouble at this point, something is broken...
	 */
	lstrval = res;
	if (res < 0)
		syswarn(1, errno, "Failed read on archive volume %d", arvol);
	else if (!frmt || !frmt->is_uar)
		paxwarn(1, "End of archive volume %d reached", arvol);
	return(res);
}

/*
 * ar_write()
 *	Write a specified number of bytes in supplied buffer to the archive
 *	device so it appears as a single "block". Deals with errors and tries
 *	to recover when faced with short writes.
 * Return:
 *	Number of bytes written. 0 indicates end of volume reached and with no
 *	flaws (as best that can be detected). A -1 indicates an unrecoverable
 *	error in the archive occurred.
 */

int
ar_write(char *buf, int bsz)
{
	int res;
	off_t cpos;

	/*
	 * do not allow pax to create a "bad" archive. Once a write fails on
	 * an archive volume prevent further writes to it.
	 */
	if (lstrval <= 0)
		return(lstrval);

	if ((res = write(arfd, buf, bsz)) == bsz) {
		wr_trail = 1;
		io_ok = 1;
		return(bsz);
	}
	/*
	 * write broke, see what we can do with it. We try to send any partial
	 * writes that may violate pax spec to the next archive volume.
	 */
	if (res < 0)
		lstrval = res;
	else
		lstrval = 0;

	switch (artyp) {
	case ISREG:
		if ((res > 0) && (res % BLKMULT)) {
			/*
			 * try to fix up partial writes which are not BLKMULT
			 * in size by forcing the runt record to next archive
			 * volume
			 */
			if ((cpos = lseek(arfd, 0, SEEK_CUR)) < 0)
				break;
			cpos -= res;
			if (ftruncate(arfd, cpos) < 0)
				break;
			res = lstrval = 0;
			break;
		}
		if (res >= 0)
			break;
		/*
		 * if file is out of space, handle it like a return of 0
		 */
		if ((errno == ENOSPC) || (errno == EFBIG) || (errno == EDQUOT))
			res = lstrval = 0;
		break;
	case ISTAPE:
	case ISCHR:
	case ISBLK:
		if (res >= 0)
			break;
		if (errno == EACCES) {
			paxwarn(0, "Write failed, archive is write protected.");
			res = lstrval = 0;
			return(0);
		}
		/*
		 * see if we reached the end of media, if so force a change to
		 * the next volume
		 */
		if ((errno == ENOSPC) || (errno == EIO) || (errno == ENXIO))
			res = lstrval = 0;
		break;
	case ISPIPE:
	default:
		/*
		 * we cannot fix errors to these devices
		 */
		break;
	}

	/*
	 * Better tell the user the bad news...
	 * if this is a block aligned archive format, we may have a bad archive
	 * if the format wants the header to start at a BLKMULT boundary. While
	 * we can deal with the mis-aligned data, it violates spec and other
	 * archive readers will likely fail. if the format is not block
	 * aligned, the user may be lucky (and the archive is ok).
	 */
	if (res >= 0) {
		if (res > 0)
			wr_trail = 1;
		io_ok = 1;
	}

	/*
	 * If we were trying to rewrite the trailer and it didn't work, we
	 * must quit right away.
	 */
	if (!wr_trail && (res <= 0)) {
		paxwarn(1,"Unable to append, trailer re-write failed. Quitting.");
		return(res);
	}

	if (res == 0)
		paxwarn(0, "End of archive volume %d reached", arvol);
	else if (res < 0)
		syswarn(1, errno, "Failed write to archive volume: %d", arvol);
	else if (!frmt->blkalgn || ((res % frmt->blkalgn) == 0))
		paxwarn(0,"WARNING: partial archive write. Archive MAY BE FLAWED");
	else
		paxwarn(1,"WARNING: partial archive write. Archive IS FLAWED");
	return(res);
}

/*
 * ar_rdsync()
 *	Try to move past a bad spot on a flawed archive as needed to continue
 *	I/O. Clears error flags to allow I/O to continue.
 * Return:
 *	0 when ok to try i/o again, -1 otherwise.
 */

int
ar_rdsync(void)
{
	long fsbz;
	off_t cpos;
	off_t mpos;
#if HAVE_SYS_MTIO_H
	struct mtop mb;
#endif

	/*
	 * Fail resync attempts at user request (done) or if this is going to be
	 * an update/append to a existing archive. if last i/o hit media end,
	 * we need to go to the next volume not try a resync
	 */
	if ((done > 0) || (lstrval == 0))
		return(-1);

	if ((act == APPND) || (act == ARCHIVE)) {
		paxwarn(1, "Cannot allow updates to an archive with flaws.");
		return(-1);
	}
	if (io_ok)
		did_io = 1;

	switch (artyp) {
#if HAVE_SYS_MTIO_H
	case ISTAPE:
		/*
		 * if the last i/o was a successful data transfer, we assume
		 * the fault is just a bad record on the tape that we are now
		 * past. If we did not get any data since the last resync try
		 * to move the tape forward one PHYSICAL record past any
		 * damaged tape section. Some tape drives are stubborn and need
		 * to be pushed.
		 */
		if (io_ok) {
			io_ok = 0;
			lstrval = 1;
			break;
		}
		mb.mt_op = MTFSR;
		mb.mt_count = 1;
		if (ioctl(arfd, MTIOCTOP, &mb) < 0)
			break;
		lstrval = 1;
		break;
#endif
	case ISREG:
	case ISCHR:
	case ISBLK:
		/*
		 * try to step over the bad part of the device.
		 */
		io_ok = 0;
		if (((fsbz = arsb.st_blksize) <= 0) || (artyp != ISREG))
			fsbz = BLKMULT;
		if ((cpos = lseek(arfd, 0, SEEK_CUR)) < 0)
			break;
		mpos = fsbz - (cpos % fsbz);
		if (lseek(arfd, mpos, SEEK_CUR) < 0)
			break;
		lstrval = 1;
		break;
	case ISPIPE:
	default:
		/*
		 * cannot recover on these archive device types
		 */
		io_ok = 0;
		break;
	}
	if (lstrval <= 0) {
		paxwarn(1, "Unable to recover from an archive read failure.");
		return(-1);
	}
	paxwarn(0, "Attempting to recover from an archive read failure.");
	return(0);
}

/*
 * ar_fow()
 *	Move the I/O position within the archive forward the specified number of
 *	bytes as supported by the device. If we cannot move the requested
 *	number of bytes, return the actual number of bytes moved in skipped.
 * Return:
 *	0 if moved the requested distance, -1 on complete failure, 1 on
 *	partial move (the amount moved is in skipped)
 */

int
ar_fow(off_t sksz, off_t *skipped)
{
	off_t cpos;
	off_t mpos;

	*skipped = 0;
	if (sksz <= 0)
		return(0);

	/*
	 * we cannot move forward at EOF or error
	 */
	if (lstrval <= 0)
		return(lstrval);

	/*
	 * Safer to read forward on devices where it is hard to find the end of
	 * the media without reading to it. With tapes we cannot be sure of the
	 * number of physical blocks to skip (we do not know physical block
	 * size at this point), so we must only read forward on tapes!
	 */
	if (artyp != ISREG)
		return(0);

	/*
	 * figure out where we are in the archive
	 */
	if ((cpos = lseek(arfd, 0, SEEK_CUR)) >= 0) {
		/*
		 * we can be asked to move farther than there are bytes in this
		 * volume, if so, just go to file end and let normal buf_fill()
		 * deal with the end of file (it will go to next volume by
		 * itself)
		 */
		if ((mpos = cpos + sksz) > arsb.st_size) {
			*skipped = arsb.st_size - cpos;
			mpos = arsb.st_size;
		} else
			*skipped = sksz;
		if (lseek(arfd, mpos, SEEK_SET) >= 0)
			return(0);
	}
	syswarn(1, errno, "Forward positioning operation on archive failed");
	lstrval = -1;
	return(-1);
}

/*
 * ar_rev()
 *	move the i/o position within the archive backwards the specified byte
 *	count as supported by the device. With tapes drives we RESET rdblksz to
 *	the PHYSICAL blocksize.
 *	NOTE: We should only be called to move backwards so we can rewrite the
 *	last records (the trailer) of an archive (APPEND).
 * Return:
 *	0 if moved the requested distance, -1 on complete failure
 */

int
ar_rev(off_t sksz)
{
	off_t cpos;
#if HAVE_SYS_MTIO_H
	struct mtop mb;
	int phyblk;
#endif

	/*
	 * make sure we do not have try to reverse on a flawed archive
	 */
	if (lstrval < 0)
		return(lstrval);

	switch (artyp) {
	case ISPIPE:
		if (sksz <= 0)
			break;
		/*
		 * cannot go backwards on these critters
		 */
		paxwarn(1, "Reverse positioning on pipes is not supported.");
		lstrval = -1;
		return(-1);
	case ISREG:
	case ISBLK:
	case ISCHR:
	default:
		if (sksz <= 0)
			break;

		/*
		 * For things other than files, backwards movement has a very
		 * high probability of failure as we really do not know the
		 * true attributes of the device we are talking to (the device
		 * may not even have the ability to lseek() in any direction).
		 * First we figure out where we are in the archive.
		 */
		if ((cpos = lseek(arfd, 0, SEEK_CUR)) < 0) {
			syswarn(1, errno,
			   "Unable to obtain current archive byte offset");
			lstrval = -1;
			return(-1);
		}

		/*
		 * we may try to go backwards past the start when the archive
		 * is only a single record. If this happens and we are on a
		 * multi-volume archive, we need to go to the end of the
		 * previous volume and continue our movement backwards from
		 * there.
		 */
		if ((cpos -= sksz) < 0) {
			if (arvol > 1) {
				/*
				 * this should never happen
				 */
				paxwarn(1,"Reverse position on previous volume.");
				lstrval = -1;
				return(-1);
			}
			cpos = 0;
		}
		if (lseek(arfd, cpos, SEEK_SET) < 0) {
			syswarn(1, errno, "Unable to seek archive backwards");
			lstrval = -1;
			return(-1);
		}
		break;
#if HAVE_SYS_MTIO_H
	case ISTAPE:
		/*
		 * Calculate and move the proper number of PHYSICAL tape
		 * blocks. If the sksz is not an even multiple of the physical
		 * tape size, we cannot do the move (this should never happen).
		 * (We also cannot handle trailers spread over two vols.)
		 * get_phys() also makes sure we are in front of the filemark.
		 */
		if ((phyblk = get_phys()) <= 0) {
			lstrval = -1;
			return(-1);
		}

		/*
		 * make sure future tape reads only go by physical tape block
		 * size (set rdblksz to the real size).
		 */
		rdblksz = phyblk;

		/*
		 * if no movement is required, just return (we must be after
		 * get_phys() so the physical blocksize is properly set)
		 */
		if (sksz <= 0)
			break;

		/*
		 * ok we have to move. Make sure the tape drive can do it.
		 */
		if (sksz % phyblk) {
			paxwarn(1,
			    "Tape drive unable to backspace requested amount");
			lstrval = -1;
			return(-1);
		}

		/*
		 * move backwards the requested number of bytes
		 */
		mb.mt_op = MTBSR;
		mb.mt_count = sksz/phyblk;
		if (ioctl(arfd, MTIOCTOP, &mb) < 0) {
			syswarn(1,errno, "Unable to backspace tape %d blocks.",
			    mb.mt_count);
			lstrval = -1;
			return(-1);
		}
		break;
#endif
	}
	lstrval = 1;
	return(0);
}

#if HAVE_SYS_MTIO_H
/*
 * get_phys()
 *	Determine the physical block size on a tape drive. We need the physical
 *	block size so we know how many bytes we skip over when we move with
 *	mtio commands. We also make sure we are BEFORE THE TAPE FILEMARK when
 *	return.
 *	This is one really SLOW routine...
 * Return:
 *	physical block size if ok (ok > 0), -1 otherwise
 */

static int
get_phys(void)
{
	int padsz = 0;
	int res;
	int phyblk;
	struct mtop mb;
	char scbuf[MAXBLK];

	/*
	 * move to the file mark, and then back up one record and read it.
	 * this should tell us the physical record size the tape is using.
	 */
	if (lstrval == 1) {
		/*
		 * we know we are at file mark when we get back a 0 from
		 * read()
		 */
		while ((res = read(arfd, scbuf, sizeof(scbuf))) > 0)
			padsz += res;
		if (res < 0) {
			syswarn(1, errno, "Unable to locate tape filemark.");
			return(-1);
		}
	}

	/*
	 * move backwards over the file mark so we are at the end of the
	 * last record.
	 */
	mb.mt_op = MTBSF;
	mb.mt_count = 1;
	if (ioctl(arfd, MTIOCTOP, &mb) < 0) {
		syswarn(1, errno, "Unable to backspace over tape filemark.");
		return(-1);
	}

	/*
	 * move backwards so we are in front of the last record and read it to
	 * get physical tape blocksize.
	 */
	mb.mt_op = MTBSR;
	mb.mt_count = 1;
	if (ioctl(arfd, MTIOCTOP, &mb) < 0) {
		syswarn(1, errno, "Unable to backspace over last tape block.");
		return(-1);
	}
	if ((phyblk = read(arfd, scbuf, sizeof(scbuf))) <= 0) {
		syswarn(1, errno, "Cannot determine archive tape blocksize.");
		return(-1);
	}

	/*
	 * read forward to the file mark, then back up in front of the filemark
	 * (this is a bit paranoid, but should be safe to do).
	 */
	while ((res = read(arfd, scbuf, sizeof(scbuf))) > 0)
		continue;
	if (res < 0) {
		syswarn(1, errno, "Unable to locate tape filemark.");
		return(-1);
	}
	mb.mt_op = MTBSF;
	mb.mt_count = 1;
	if (ioctl(arfd, MTIOCTOP, &mb) < 0) {
		syswarn(1, errno, "Unable to backspace over tape filemark.");
		return(-1);
	}

	/*
	 * set lstrval so we know that the filemark has not been seen
	 */
	lstrval = 1;

	/*
	 * return if there was no padding
	 */
	if (padsz == 0)
		return(phyblk);

	/*
	 * make sure we can move backwards over the padding. (this should
	 * never fail).
	 */
	if (padsz % phyblk) {
		paxwarn(1, "Tape drive unable to backspace requested amount");
		return(-1);
	}

	/*
	 * move backwards over the padding so the head is where it was when
	 * we were first called (if required).
	 */
	mb.mt_op = MTBSR;
	mb.mt_count = padsz/phyblk;
	if (ioctl(arfd, MTIOCTOP, &mb) < 0) {
		syswarn(1,errno,"Unable to backspace tape over %d pad blocks",
		    mb.mt_count);
		return(-1);
	}
	return(phyblk);
}
#endif

/*
 * ar_next()
 *	prompts the user for the next volume in this archive. For some devices
 *	we may allow the media to be changed. Otherwise a new archive is
 *	prompted for. By pax spec, if there is no controlling tty or an eof is
 *	read on tty input, we must quit pax.
 * Return:
 *	0 when ready to continue, -1 when all done
 */

int
ar_next(void)
{
	char *buf;
	sigset_t o_mask;

	/*
	 * WE MUST CLOSE THE DEVICE. A lot of devices must see last close, (so
	 * things like writing EOF etc will be done) (Watch out ar_close() can
	 * also be called via a signal handler, so we must prevent a race.
	 */
	if (sigprocmask(SIG_BLOCK, &s_mask, &o_mask) < 0)
		syswarn(0, errno, "Unable to set signal mask");
	ar_close(0);
	if (sigprocmask(SIG_SETMASK, &o_mask, NULL) < 0)
		syswarn(0, errno, "Unable to restore signal mask");

	if (done || !wr_trail || force_one_volume || op_mode == OP_TAR)
		return(-1);

	tty_prnt("\nATTENTION! %s archive volume change required.\n", argv0);

	/*
	 * if i/o is on stdin or stdout, we cannot reopen it (we do not know
	 * the name), the user will be forced to type it in.
	 */
	if (strcmp(arcname, STDO) && strcmp(arcname, STDN) && (artyp != ISREG)
	    && (artyp != ISPIPE)) {
		if (artyp == ISTAPE) {
			tty_prnt("%s ready for archive tape volume: %d\n",
				arcname, arvol);
			tty_prnt("Load the NEXT TAPE on the tape drive");
		} else {
			tty_prnt("%s ready for archive volume: %d\n",
				arcname, arvol);
			tty_prnt("Load the NEXT STORAGE MEDIA (if required)");
		}

		if ((act == ARCHIVE) || (act == APPND))
			tty_prnt(" and make sure it is WRITE ENABLED.\n");
		else
			tty_prnt("\n");

		for (;;) {
			tty_prnt("Type \"y\" to continue, \".\" to quit %s,",
				argv0);
			tty_prnt(" or \"s\" to switch to new device.\nIf you");
			tty_prnt(" cannot change storage media, type \"s\"\n");
			tty_prnt("Is the device ready and online? > ");

			if ((buf = tty_rd()) == NULL || !strcmp(buf, ".")) {
				free(buf);
				done = 1;
				lstrval = -1;
				tty_prnt("Quitting %s!\n", argv0);
				vfpart = 0;
				return(-1);
			}

			if ((buf[0] == '\0') || (buf[1] != '\0'))
				goto eunknown;

			switch (buf[0]) {
			case 'y':
			case 'Y':
				/*
				 * we are to continue with the same device
				 */
				free(buf);
				if (ar_open(arcname) >= 0)
					return (0);
				tty_prnt("Cannot re-open %s, try again\n",
				    arcname);
				continue;
			case 's':
			case 'S':
				/*
				 * user wants to open a different device
				 */
				free(buf);
				tty_prnt("Switching to a different archive\n");
				break;
			default:
 eunknown:
				tty_prnt("%s unknown command, try again\n", buf);
				free(buf);
				continue;
			}
			break;
		}
	} else
		tty_prnt("Ready for archive volume: %d\n", arvol);

	/*
	 * have to go to a different archive
	 */
	for (;;) {
		tty_prnt("Input archive name or \".\" to quit %s.\n", argv0);
		tty_prnt("Archive name > ");

		if ((buf = tty_rd()) == NULL || !strcmp(buf, ".")) {
			free(buf);
			done = 1;
			lstrval = -1;
			tty_prnt("Quitting %s!\n", argv0);
			vfpart = 0;
			return(-1);
		}
		if (buf[0] == '\0') {
			tty_prnt("Empty file name, try again\n");
			free(buf);
			continue;
		}
		if (!strcmp(buf, "..")) {
			tty_prnt("Illegal file name '..', try again\n");
			free(buf);
			continue;
		}
		if (strlen(buf) > PAXPATHLEN) {
			tty_prnt("File name too long, try again\n");
			free(buf);
			continue;
		}

		/*
		 * try to open new archive
		 */
		if (ar_open(buf) >= 0) {
			free(arcname_alloc);
			arcname = arcname_alloc = buf;
			break;
		}
		tty_prnt("Cannot open %s, try again\n", buf);
		free(buf);
		continue;
	}
	return (0);
}

/*
 * ar_start_compress()
 * starts the compression/decompression process as a child, using magic
 * to keep the fd the same in the calling function (parent).
 */
void
ar_start_compress(int fd, int wr)
{
	int fds[2];
	const char *compress_flags;

	guess_compress_program(wr);
	if (compress_program == NULL)
		return;

	if (pipe(fds) < 0)
		err(1, "pipe");
	zpid = fork();
	if (zpid < 0)
		err(1, "fork");

	/* parent */
	if (zpid) {
		dup2(fds[wr ? 1 : 0], fd);
		close(fds[0]);
		close(fds[1]);

#if HAVE_PLEDGE
		if (pmode == 0 || (act != EXTRACT && act != COPY)) {
		    if (pledge("stdio rpath wpath cpath fattr dpath getpw proc tape",
			NULL) == -1)
				err(1, "pledge");
		}
#endif
	} else {
		if (wr) {
			dup2(fds[0], STDIN_FILENO);
			dup2(fd, STDOUT_FILENO);
			compress_flags = "-c";
		} else {
			dup2(fds[1], STDOUT_FILENO);
			dup2(fd, STDIN_FILENO);
			compress_flags = "-dc";
		}
		close(fds[0]);
		close(fds[1]);

		/* System compressors are more likely to use pledge(2) */
		putenv("PATH=" PAX_SAFE_PATH);

		if (execlp(compress_program, compress_program,
		    compress_flags, (char *)NULL) < 0)
			err(1, "exec(%s)", compress_program);
		/* NOTREACHED */
	}
}
@


1.27
log
@fixing and string pooling and int shortening offensive
@
text
@d5 1
a5 1
 * Copyright (c) 2012, 2016, 2017
d61 1
a61 1
__RCSID("$MirOS: src/bin/pax/ar_io.c,v 1.26 2018/12/12 18:08:41 tg Exp $");
d417 1
a417 1
		    "%s: unknown format, %llu bytes skipped.\n", argv0, rdcnt);
d424 1
a424 1
		    " %llu bytes read, %llu bytes written.\n",
d427 1
a427 1
		(void)dprintf(listfd, "%llu blocks\n",
@


1.26
log
@merge the npax branch into MAIN

asides from a missing dprintf and portability, this ought to be
good enough for people (well me) to play with for now
@
text
@d61 1
a61 1
__RCSID("$MirOS: src/bin/pax/ar_io.c,v 1.24 2018/10/07 01:10:12 tg Exp $");
d78 1
a78 1
static int artyp = ISREG;		/* archive type: file/FIFO/tape */
d81 3
a83 3
static int io_ok;			/* i/o worked on volume after resync */
static int did_io;			/* did i/o ever occur on volume? */
static int done;			/* set via tty termination */
d85 3
a87 3
static int invld_rec;			/* tape has out of spec record size */
static int wr_trail = 1;		/* trailer was rewritten in append */
static int can_unlnk = 0;		/* do we unlink null archives?  */
d92 1
a92 1
int force_one_volume;			/* 1 if we ignore volume changes */
d1248 1
a1248 1
			tty_prnt("Illegal file name: .. try again\n");
d1289 1
a1289 1
		err(1, "could not pipe");
d1292 1
a1292 1
		err(1, "could not fork");
d1325 1
a1325 1
			err(1, "could not exec %s", compress_program);
@


1.25
log
@slowmerge (untested though)
@
text
@d39 5
a43 2
#include <sys/param.h>
#include <sys/time.h>
a44 1
#include <sys/ioctl.h>
d46 3
d50 2
d53 3
a55 1
#include <fcntl.h>
d57 1
a57 5
#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <time.h>
#include <err.h>
a58 1
#include "options.h"
d61 4
a64 2
#if HAS_TAPE
#include <sys/mtio.h>
a66 2
__RCSID("$MirOS: src/bin/pax/ar_io.c,v 1.24 2018/10/07 01:10:12 tg Exp $");

d94 1
a94 1
#if HAS_TAPE
d112 1
a112 1
#if HAS_TAPE
d132 1
a132 1
		} else if ((arfd = open(name, EXT_MODE, DMOD)) < 0)
d141 1
a141 1
		} else if ((arfd = open(name, AR_MODE, DMOD)) < 0)
d152 1
a152 1
		} else if ((arfd = open(name, APP_MODE, DMOD)) < 0)
d194 1
a194 1
#if HAS_TAPE
d201 1
a201 1
	else if ((lseek(arfd, (off_t)0L, SEEK_CUR) == -1) && (errno == ESPIPE))
d315 1
a315 1
 * ar_close()
d317 1
d320 1
a320 1
ar_close(void)
d327 1
a327 1
			(void)putc('\n', listf);
d332 2
d342 3
a344 6
		if (vfpart)
			(void)putc('\n', listf);
		(void)fprintf(listf,
			"%s: Waiting for tape drive close to complete...",
			argv0);
		(void)fflush(listf);
d376 1
a376 1
		(void)fputs("done.\n", listf);
a377 1
		(void)fflush(listf);
d396 1
a396 1
		(void)putc('\n', listf);
d416 2
a417 3
		(void)fprintf(listf, "%s: unknown format, %" OT_FMT
		    " bytes skipped.\n", argv0, (ot_type)rdcnt);
		(void)fflush(listf);
d422 7
a428 9
	if (strcmp(NM_CPIO, argv0) == 0)
		(void)fprintf(listf, "%" OT_FMT " blocks\n",
		    (ot_type)((rdcnt ? rdcnt : wrcnt) / 5120));
	else if (strcmp(NM_TAR, argv0) != 0)
		(void)fprintf(listf,
		    "%s: %s vol %d, %lu files, %" OT_FMT " bytes read, %"
		    OT_FMT " bytes written.\n", argv0, frmt->name, arvol-1,
		    flcnt, (ot_type)rdcnt, (ot_type)wrcnt);
	(void)fflush(listf);
d457 1
a457 1
		;
d492 1
a492 1
	if (((cpos = lseek(arfd, (off_t)0L, SEEK_CUR)) < 0) ||
d651 1
a651 1
			if ((cpos = lseek(arfd, (off_t)0L, SEEK_CUR)) < 0)
d653 1
a653 1
			cpos -= (off_t)res;
d695 1
a695 1
	 * if the format wants the header to start at a BLKMULT boundary.. While
d740 1
a740 1
#if HAS_TAPE
d760 1
a760 1
#if HAS_TAPE
d791 1
a791 1
		if ((cpos = lseek(arfd, (off_t)0L, SEEK_CUR)) < 0)
d793 1
a793 1
		mpos = fsbz - (cpos % (off_t)fsbz);
d852 1
a852 1
	if ((cpos = lseek(arfd, (off_t)0L, SEEK_CUR)) >= 0) {
d887 2
a888 1
#if HAS_TAPE
a889 1
	struct mtop mb;
d922 1
a922 1
		if ((cpos = lseek(arfd, (off_t)0L, SEEK_CUR)) < 0) {
d936 1
a936 1
		if ((cpos -= sksz) < (off_t)0L) {
d945 1
a945 1
			cpos = (off_t)0L;
d953 1
a953 1
#if HAS_TAPE
d1008 1
a1008 1
#if HAS_TAPE
d1077 1
a1077 1
		;
d1147 1
a1147 1
	ar_close();
d1151 1
a1151 1
	if (done || !wr_trail || force_one_volume || strcmp(NM_TAR, argv0) == 0)
d1184 1
a1184 2
			if ((buf = tty_rd()) == NULL ||
			    !strcmp(buf, ".")) {
d1193 1
a1193 1
			if ((buf[0] == '\0') || (buf[1] != '\0')) {
a1194 1
			}
d1299 8
d1324 1
a1324 1
		    compress_flags, NULL) < 0)
@


1.24
log
@spelling cleanup: “programme” is distinct from “program”; even in
British English, the latter is used for computer programs, while
the former serves for things like the TV programme, or a programme
to plant trees
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.39 +1.45 +1.49 +1.54 2009/10/27 23:59:22 deraadt Exp $	*/
d61 1
a61 1
__RCSID("$MirOS: src/bin/pax/ar_io.c,v 1.23 2017/10/14 00:25:40 tg Exp $");
@


1.23
log
@silly error message
@
text
@d61 1
a61 1
__RCSID("$MirOS: src/bin/pax/ar_io.c,v 1.20 2016/10/25 18:57:54 tg Exp $");
d86 1
a86 1
const char *compress_program;		/* name of compression programme */
@


1.22
log
@merge
@
text
@d5 1
a5 1
 * Copyright (c) 2012, 2016
d179 3
a181 1
		paxwarn(0, "Cannot write an archive on top of a directory %s",
@


1.21
log
@make compressor path a Makefile variable, for portability
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.39 +1.49 +1.54 2009/10/27 23:59:22 deraadt Exp $	*/
d355 1
a355 1
	if ((act == LIST || act == EXTRACT) && nflag && zpid > 0)
d357 2
d363 1
a363 1
	if (zpid > 0)
d365 3
d599 1
a599 1
		paxwarn(0, "End of archive volume %d reached", arvol);
@


1.20
log
@fastmerge
@
text
@d5 1
a5 1
 * Copyright (c) 2012
d61 1
a61 1
__RCSID("$MirOS: src/bin/pax/ar_io.c,v 1.19 2016/03/06 13:47:11 tg Exp $");
d1308 1
a1308 1
		putenv("PATH=/bin:/usr/bin");
@


1.19
log
@apply changes from mpax-erstmalnurderbackport branch not related to the CVEs
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.39 2009/10/27 23:59:22 deraadt Exp $	*/
d61 1
a61 1
__RCSID("$MirOS: src/bin/pax/ar_io.c,v 1.17 2012/05/20 17:21:44 tg Exp $");
d201 1
a201 1
	 * make sure we beyond any doubt that we only can unlink regular files
d1306 4
@


1.18
log
@change tty_read(buf,sz) to buf=tty_rd() in callers so fdgetline() conversion makes sense
@
text
@d6 1
a6 1
 *	Thorsten Glaser <tg@@debian.org>
@


1.17
log
@implement archive format auto-guessing – inspired by http://petereisentraut.blogspot.de/2012/05/time-to-retrain-fingers.html – with silent failback to no compressor; uses lzma only when writing .tlz and lzop transparently
@
text
@d61 1
a61 1
__RCSID("$MirOS: src/bin/pax/ar_io.c,v 1.16 2012/05/20 16:13:15 tg Exp $");
d85 1
a85 1
static char *arcname_alloc;		/* this is so we can free(3) it */
d1130 1
a1130 2
	char buf[PAXPATHLEN+2];
	static int freeit = 0;
d1177 3
a1179 1
			if ((tty_read(buf,sizeof(buf))<0) || !strcmp(buf,".")){
d1188 1
a1188 2
				tty_prnt("%s unknown command, try again\n",buf);
				continue;
d1197 1
d1199 1
a1199 1
					return(0);
d1201 1
a1201 1
					arcname);
d1208 1
d1212 3
a1214 1
				tty_prnt("%s unknown command, try again\n",buf);
d1229 2
a1230 1
		if ((tty_read(buf, sizeof(buf)) < 0) || !strcmp(buf, ".")) {
d1239 1
d1244 1
d1249 1
d1257 2
a1258 11
			if (freeit) {
				free(arcname_alloc);
				freeit = 0;
			}
			if ((arcname = arcname_alloc = strdup(buf)) == NULL) {
				done = 1;
				lstrval = -1;
				paxwarn(0, "Cannot save archive name.");
				return(-1);
			}
			freeit = 1;
d1262 1
d1265 1
a1265 1
	return(0);
@


1.16
log
@get rid of extern.h including other headers
@
text
@d61 1
a61 1
__RCSID("$MirOS: src/bin/pax/ar_io.c,v 1.15 2012/05/20 16:05:04 tg Exp $");
d1279 4
@


1.15
log
@move variable only used by HAS_TAPE code
@
text
@d51 1
d61 1
a61 1
__RCSID("$MirOS: src/bin/pax/ar_io.c,v 1.14 2012/02/16 17:27:30 tg Exp $");
@


1.14
log
@clean up some ugliness
@
text
@d60 1
a60 1
__RCSID("$MirOS: src/bin/pax/ar_io.c,v 1.13 2012/02/16 17:11:45 tg Exp $");
d880 1
a882 1
	int phyblk;
@


1.13
log
@Debian GNU/kFreeBSD can be more difficult to deal with than GNU/Hurd at times.

• switch from quad_t to using unsigned long / unsigned long long
• sanitise use of off_t-relevant types
• cast when printing off_t; use a once-defined type and format specifier
• convert “This define is important” into actual compile-time assertion
• simplify ifdef mess by always defining off_t specific routines
  instead of reusing those for long if off_t is just long
@
text
@d60 1
a60 1
__RCSID("$MirOS: src/bin/pax/ar_io.c,v 1.12 2012/02/16 16:01:07 tg Exp $");
d84 2
a85 2
static char *arcname_;			/* this is so we can free(3) it */
const char *gzip_program;		/* name of gzip program */
d93 1
a93 1
static void ar_start_gzip(int, int);
d129 2
a130 2
		if (arfd != -1 && gzip_program != NULL)
			ar_start_gzip(arfd, 0);
d140 2
a141 2
		if (arfd != -1 && gzip_program != NULL)
			ar_start_gzip(arfd, 1);
d1249 1
a1249 1
				free(arcname_);
d1252 1
a1252 1
			if ((arcname = arcname_ = strdup(buf)) == NULL) {
d1268 2
a1269 2
 * ar_start_gzip()
 * starts the gzip compression/decompression process as a child, using magic
d1273 1
a1273 1
ar_start_gzip(int fd, int wr)
d1276 1
a1276 1
	const char *gzip_flags;
d1286 1
a1286 4
		if (wr)
			dup2(fds[1], fd);
		else
			dup2(fds[0], fd);
d1293 1
a1293 1
			gzip_flags = "-c";
d1297 1
a1297 1
			gzip_flags = "-dc";
d1301 3
a1303 2
		if (execlp(gzip_program, gzip_program, gzip_flags, NULL) < 0)
			err(1, "could not exec %s", gzip_program);
@


1.12
log
@implement the GNU cpio option -V (print a dot per file processed)
sponsored by tarent solutions GmbH for work on evolvis (FusionForge)
@
text
@d5 2
d60 1
a60 1
__RCSID("$MirOS: src/bin/pax/ar_io.c,v 1.11 2012/02/12 00:27:14 tg Exp $");
d405 2
a406 6
#	ifdef LONG_OFF_T
		(void)fprintf(listf, "%s: unknown format, %lu bytes skipped.\n",
#	else
		(void)fprintf(listf, "%s: unknown format, %llu bytes skipped.\n",
#	endif
		    argv0, rdcnt);
d413 2
a414 5
#	ifdef LONG_OFF_T
		(void)fprintf(listf, "%lu blocks\n", (rdcnt ? rdcnt : wrcnt) / 5120);
#	else
		(void)fprintf(listf, "%llu blocks\n", (rdcnt ? rdcnt : wrcnt) / 5120);
#	endif
d417 3
a419 6
#	ifdef LONG_OFF_T
		    "%s: %s vol %d, %lu files, %lu bytes read, %lu bytes written.\n",
#	else
		    "%s: %s vol %d, %lu files, %llu bytes read, %llu bytes written.\n",
#	endif
		    argv0, frmt->name, arvol-1, flcnt, rdcnt, wrcnt);
@


1.11
log
@merge OpenBSD
@
text
@d58 1
a58 1
__RCSID("$MirOS: src/bin/pax/ar_io.c,v 1.10 2011/08/16 21:32:45 tg Exp $");
d316 4
d381 7
a395 4
	if (vfpart) {
		(void)putc('\n', listf);
		vfpart = 0;
	}
@


1.10
log
@backend for Unix Archiver libraries – ar(5) and deb(5) format files
(since GNU binutils on ELF systems thinks SYSV style ar is used…)
@
text
@d1 1
a1 2
/**	$MirOS: src/bin/pax/ar_io.c,v 1.9 2009/10/04 14:51:06 tg Exp $ */
/*	$OpenBSD: ar_io.c,v 1.37 2005/08/04 10:02:44 mpf Exp $	*/
d58 1
a58 2
__SCCSID("@@(#)ar_io.c	8.2 (Berkeley) 4/18/94");
__RCSID("$MirOS: src/bin/pax/ar_io.c,v 1.9 2009/10/04 14:51:06 tg Exp $");
d1306 1
a1306 1
			err(1, "could not exec");
@


1.9
log
@exclude tape support on Mac OSX too, not just Interix,
because it got removed in Snow Leopard
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/ar_io.c,v 1.8 2007/02/17 04:52:39 tg Exp $ */
d60 1
a60 1
__RCSID("$MirOS: src/bin/pax/ar_io.c,v 1.8 2007/02/17 04:52:39 tg Exp $");
d72 1
a72 1
static int arfd = -1;			/* archive file descriptor */
d595 1
a595 1
	else
@


1.8
log
@__CRAZY clean
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/ar_io.c,v 1.7 2007/02/17 04:12:40 tg Exp $ */
a41 3
#ifndef __INTERIX
#include <sys/mtio.h>
#endif
d55 4
d60 1
a60 1
__RCSID("$MirOS: src/bin/pax/ar_io.c,v 1.7 2007/02/17 04:12:40 tg Exp $");
d89 1
a89 1
#ifndef __INTERIX
d107 1
a107 1
#ifndef __INTERIX
d187 1
a187 1
#ifndef __INTERIX
d735 1
a735 1
#ifndef __INTERIX
d755 1
a755 1
#ifndef __INTERIX
d882 1
a882 1
#ifndef __INTERIX
d948 1
a948 1
#ifndef __INTERIX
d1003 1
a1003 1
#ifndef __INTERIX
@


1.7
log
@clean up Interix ifdef stuff
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/ar_io.c,v 1.6 2006/06/23 23:03:55 tg Exp $ */
d38 1
a38 1
#include <sys/types.h>
a44 1
#include <sys/param.h>
d59 1
a59 1
__RCSID("$MirOS: src/bin/pax/ar_io.c,v 1.6 2006/06/23 23:03:55 tg Exp $");
d83 1
d92 1
a92 1
static void ar_start_gzip(int, const char *, int);
d129 1
a129 1
			ar_start_gzip(arfd, gzip_program, 0);
d140 1
a140 1
			ar_start_gzip(arfd, gzip_program, 1);
d400 1
a400 1
		(void)fprintf(listf, "%s: unknown format, %qu bytes skipped.\n",
d412 1
a412 1
		(void)fprintf(listf, "%qu blocks\n", (rdcnt ? rdcnt : wrcnt) / 5120);
d419 1
a419 1
		    "%s: %s vol %d, %lu files, %qu bytes read, %qu bytes written.\n",
d1251 1
a1251 1
				(void)free((char *)arcname);
d1254 1
a1254 1
			if ((arcname = strdup(buf)) == NULL) {
d1275 1
a1275 1
ar_start_gzip(int fd, const char *gzip_program, int wr)
d1306 1
a1306 1
		if (execlp(gzip_program, gzip_program, gzip_flags, (char *)NULL) < 0)
@


1.6
log
@merge the OpenBSD import (bugfix)
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/ar_io.c,v 1.5 2006/02/09 17:10:19 tg Exp $ */
d60 1
a60 1
__RCSID("$MirOS: src/bin/pax/ar_io.c,v 1.5 2006/02/09 17:10:19 tg Exp $");
d88 1
d90 1
d1002 1
a1016 1
#ifndef __INTERIX
d1115 1
a1115 2
#else
	return 0;
a1116 1
}
@


1.5
log
@apply correct Interix fix
from Han Boetes
@
text
@d1 2
a2 2
/**	$MirOS: src/bin/pax/ar_io.c,v 1.4 2005/04/13 20:11:24 tg Exp $ */
/*	$OpenBSD: ar_io.c,v 1.36 2004/06/20 16:22:08 niklas Exp $	*/
d60 1
a60 1
__RCSID("$MirOS: src/bin/pax/ar_io.c,v 1.4 2005/04/13 20:11:24 tg Exp $");
d125 1
a125 1
			syswarn(0, errno, "Failed open to read on %s", name);
d134 1
a134 1
			syswarn(0, errno, "Failed open to write on %s", name);
d145 1
a145 1
			syswarn(0, errno, "Failed open to read/write on %s",
d168 1
a168 1
		syswarn(0, errno, "Failed stat on %s", arcname);
@


1.4
log
@portability fix: long = off_t
XXX does this mean interix is worse than Linux wrt large files?
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/ar_io.c,v 1.3 2005/04/13 20:03:34 tg Exp $ */
d60 1
a60 1
__RCSID("$MirOS: src/bin/pax/ar_io.c,v 1.3 2005/04/13 20:03:34 tg Exp $");
d407 5
a411 1
		(void)fprintf(listf, "%qu blocks\n", (rdcnt ? rdcnt : wrcnt) / 5120LL);
@


1.3
log
@these are the compile time fixes
this commit message provided by interix ;)
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/ar_io.c,v 1.2 2005/04/13 19:49:34 tg Exp $ */
d60 1
a60 1
__RCSID("$MirOS$");
d407 1
a407 1
		(void)fprintf(listf, "%qu blocks\n", (rdcnt ? rdcnt : wrcnt) / 5120);
@


1.2
log
@first the compile fixes. later, link fixes will follow.
@
text
@d1 1
a1 1
/**	$MirOS$ */
a37 8
#ifndef lint
#if 0
static const char sccsid[] = "@@(#)ar_io.c	8.2 (Berkeley) 4/18/94";
#else
static const char rcsid[] = "$OpenBSD: ar_io.c,v 1.36 2004/06/20 16:22:08 niklas Exp $";
#endif
#endif /* not lint */

d59 3
@


1.1
log
@Initial revision
@
text
@d1 1
d50 1
d52 1
d109 1
d111 1
d189 1
d191 3
d733 1
d735 1
d753 1
d774 1
d880 1
d882 1
d946 1
d995 1
d1015 1
d1114 3
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@One "miserable" byte in filenames is worth an import

agreed bsiegert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.37 2005/08/04 10:02:44 mpf Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: ar_io.c,v 1.37 2005/08/04 10:02:44 mpf Exp $";
d125 1
a125 1
			syswarn(1, errno, "Failed open to read on %s", name);
d134 1
a134 1
			syswarn(1, errno, "Failed open to write on %s", name);
d145 1
a145 1
			syswarn(1, errno, "Failed open to read/write on %s",
d168 1
a168 1
		syswarn(1, errno, "Failed stat on %s", arcname);
@


1.1.1.3
log
@import up-to-date pax from OpenBSD 5.1-current
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.39 2009/10/27 23:59:22 deraadt Exp $	*/
d37 8
d1287 1
a1287 1
			err(1, "could not exec %s", gzip_program);
@


1.1.1.4
log
@pull newer paxtar from OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.55 2015/12/06 16:57:45 deraadt Exp $	*/
d42 1
d185 1
a185 1
	 * make sure beyond any doubt that we can unlink only regular files
d293 1
a293 1
 * ar_close(int int_sig)
a294 1
 *	If in_sig is set we're in a signal handler and can't flush stdio.
d297 1
a297 1
ar_close(int in_sig)
a304 2
	if (!in_sig)
		fflush(listf);
d313 6
a318 3
		(void)dprintf(listfd,
		    "%s%s: Waiting for tape drive close to complete...",
		    vfpart ? "\n" : "", argv0);
d335 1
a335 1
	if ((act == LIST || act == EXTRACT) && nflag && zpid > 0) {
a336 2
		zpid = -1;
	}
d341 1
a341 1
	if (zpid > 0) {
a342 4
		if (!WIFEXITED(status) || WEXITSTATUS(status))
			exit_val = 1;
	}

d345 1
a345 1
		(void)write(listfd, "done.\n", sizeof("done.\n")-1);
d347 1
d373 1
a373 1
		(void)write(listfd, "\n", 1);
d383 7
a389 2
		(void)dprintf(listfd,
		    "%s: unknown format, %llu bytes skipped.\n", argv0, rdcnt);
d394 9
a402 3
	if (strcmp(NM_PAX, argv0) == 0)
		(void)dprintf(listfd, "%s: %s vol %d, %lu files,"
		    " %llu bytes read, %llu bytes written.\n",
d404 1
a404 5
#ifndef NOCPIO
	else if (strcmp(NM_CPIO, argv0) == 0)
		(void)dprintf(listfd, "%llu blocks\n",
		    (rdcnt ? rdcnt : wrcnt) / 5120);
#endif /* !NOCPIO */
d671 1
a671 1
	 * if the format wants the header to start at a BLKMULT boundary. While
d1114 1
a1114 1
	ar_close(0);
d1223 1
a1223 1
				free((char *)arcname);
d1247 1
a1247 1
ar_start_gzip(int fd, const char *path, int wr)
a1265 6

		if (pmode == 0 || (act != EXTRACT && act != COPY)) {
		    if (pledge("stdio rpath wpath cpath fattr dpath getpw ioctl proc",
			NULL) == -1)
				err(1, "pledge");
		}
d1278 2
a1279 6

		/* System compressors are more likely to use pledge(2) */
		putenv("PATH=/usr/bin:/usr/local/bin");

		if (execlp(path, path, gzip_flags, (char *)NULL) < 0)
			err(1, "could not exec %s", path);
@


1.1.1.5
log
@revert the import; we’ll just backport the CVE fixes, for now ☹
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.39 2009/10/27 23:59:22 deraadt Exp $	*/
a41 1
#include <sys/param.h>
d184 1
a184 1
	 * make sure we beyond any doubt that we only can unlink regular files
d292 1
a292 1
 * ar_close()
d294 1
d297 1
a297 1
ar_close(void)
d305 2
d315 3
a317 6
		if (vfpart)
			(void)putc('\n', listf);
		(void)fprintf(listf,
			"%s: Waiting for tape drive close to complete...",
			argv0);
		(void)fflush(listf);
d334 1
a334 1
	if ((act == LIST || act == EXTRACT) && nflag && zpid > 0)
d336 2
d342 1
a342 1
	if (zpid > 0)
d344 4
d350 1
a350 1
		(void)fputs("done.\n", listf);
a351 1
		(void)fflush(listf);
d377 1
a377 1
		(void)putc('\n', listf);
d387 2
a388 7
#	ifdef LONG_OFF_T
		(void)fprintf(listf, "%s: unknown format, %lu bytes skipped.\n",
#	else
		(void)fprintf(listf, "%s: unknown format, %qu bytes skipped.\n",
#	endif
		    argv0, rdcnt);
		(void)fflush(listf);
d393 3
a395 9
	if (strcmp(NM_CPIO, argv0) == 0)
		(void)fprintf(listf, "%qu blocks\n", (rdcnt ? rdcnt : wrcnt) / 5120);
	else if (strcmp(NM_TAR, argv0) != 0)
		(void)fprintf(listf,
#	ifdef LONG_OFF_T
		    "%s: %s vol %d, %lu files, %lu bytes read, %lu bytes written.\n",
#	else
		    "%s: %s vol %d, %lu files, %qu bytes read, %qu bytes written.\n",
#	endif
d397 5
a401 1
	(void)fflush(listf);
d668 1
a668 1
	 * if the format wants the header to start at a BLKMULT boundary.. While
d1111 1
a1111 1
	ar_close();
d1220 1
a1220 1
				(void)free((char *)arcname);
d1244 1
a1244 1
ar_start_gzip(int fd, const char *gzip_program, int wr)
d1263 6
d1281 6
a1286 2
		if (execlp(gzip_program, gzip_program, gzip_flags, (char *)NULL) < 0)
			err(1, "could not exec %s", gzip_program);
@


1.1.1.6
log
@bunch of cherry-picks from OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.39 +1.49 +1.54 2009/10/27 23:59:22 deraadt Exp $	*/
d185 1
a185 1
	 * make sure beyond any doubt that we can unlink only regular files
a1277 4

		/* System compressors are more likely to use pledge(2) */
		putenv("PATH=/usr/bin:/usr/local/bin");

@


1.1.1.7
log
@cherry-pick:
    Exit with non-zero status if a read is truncated, or if a compression
    program was used but it didn't exit successfully.

    Original diff by mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.39 +1.45 +1.49 +1.54 2009/10/27 23:59:22 deraadt Exp $	*/
d335 1
a335 1
	if ((act == LIST || act == EXTRACT) && nflag && zpid > 0) {
a336 2
		zpid = -1;
	}
d341 1
a341 1
	if (zpid > 0) {
a342 3
		if (!WIFEXITED(status) || WEXITSTATUS(status))
			exit_val = 1;
	}
d577 1
a577 1
		paxwarn(1, "End of archive volume %d reached", arvol);
@


1.1.1.8
log
@merge what OpenBSD did between our last cherry-pick and today minus one commit

(“Use the new libc uid_from_user() and gid_from_group() instead of
  the pax-specific functions in cache.c” is ignored, for now)
@
text
@d1 1
a1 1
/*	$OpenBSD: ar_io.c,v 1.62 2017/03/11 12:55:47 tb Exp $	*/
@


1.1.1.9
log
@Import latest OpenBSD paxtar, unmodified, into vendor branch
@
text
@d38 1
d42 1
d44 2
a45 2
#include <err.h>
#include <errno.h>
d47 1
a47 1
#include <signal.h>
d49 1
d51 1
a51 3
#include <string.h>
#include <unistd.h>

d53 1
d179 1
a179 1
	else if ((lseek(arfd, 0, SEEK_CUR) == -1) && (errno == ESPIPE))
d293 1
a293 1
 * ar_close(int int_sig)
a294 1
 *	If in_sig is set we're in a signal handler and can't flush stdio.
d297 1
a297 1
ar_close(int in_sig)
a304 2
	if (!in_sig)
		fflush(listf);
d313 6
a318 3
		(void)dprintf(listfd,
		    "%s%s: Waiting for tape drive close to complete...",
		    vfpart ? "\n" : "", argv0);
a348 1

d350 1
a350 1
		(void)write(listfd, "done.\n", sizeof("done.\n")-1);
d352 1
d378 1
a378 1
		(void)write(listfd, "\n", 1);
d388 7
a394 2
		(void)dprintf(listfd,
		    "%s: unknown format, %llu bytes skipped.\n", argv0, rdcnt);
d399 9
a407 3
	if (op_mode == OP_PAX)
		(void)dprintf(listfd, "%s: %s vol %d, %lu files,"
		    " %llu bytes read, %llu bytes written.\n",
d409 1
a409 5
#ifndef NOCPIO
	else if (op_mode == OP_CPIO)
		(void)dprintf(listfd, "%llu blocks\n",
		    (rdcnt ? rdcnt : wrcnt) / 5120);
#endif /* !NOCPIO */
d438 1
a438 1
		continue;
d473 1
a473 1
	if (((cpos = lseek(arfd, 0, SEEK_CUR)) < 0) ||
d582 1
a582 1
		paxwarn(0, "End of archive volume %d reached", arvol);
d632 1
a632 1
			if ((cpos = lseek(arfd, 0, SEEK_CUR)) < 0)
d634 1
a634 1
			cpos -= res;
d676 1
a676 1
	 * if the format wants the header to start at a BLKMULT boundary. While
d768 1
a768 1
		if ((cpos = lseek(arfd, 0, SEEK_CUR)) < 0)
d770 1
a770 1
		mpos = fsbz - (cpos % fsbz);
d829 1
a829 1
	if ((cpos = lseek(arfd, 0, SEEK_CUR)) >= 0) {
d897 1
a897 1
		if ((cpos = lseek(arfd, 0, SEEK_CUR)) < 0) {
d911 1
a911 1
		if ((cpos -= sksz) < 0) {
d920 1
a920 1
			cpos = 0;
d1049 1
a1049 1
		continue;
d1119 1
a1119 1
	ar_close(0);
d1123 1
a1123 1
	if (done || !wr_trail || force_one_volume || op_mode == OP_TAR)
d1228 1
a1228 1
				free((char *)arcname);
d1252 1
a1252 1
ar_start_gzip(int fd, const char *path, int wr)
a1270 6

		if (pmode == 0 || (act != EXTRACT && act != COPY)) {
		    if (pledge("stdio rpath wpath cpath fattr dpath getpw proc tape",
			NULL) == -1)
				err(1, "pledge");
		}
d1287 2
a1288 2
		if (execlp(path, path, gzip_flags, (char *)NULL) < 0)
			err(1, "could not exec %s", path);
@


1.1.1.9.2.1
log
@Wrangle the OpenBSD branch into shape as starting point:

• Revert “Use the new libc uid_from_user() and gid_from_group()
  instead of the pax-specific functions in cache.c” (revisit later)
• fix MAX_TIME_T (plain wrong), mirtoconf later
• drop all NOCPIO
• Revert “Replace name_{uid,gid}() with the libc routines
  user_from_uid() and group_from_gid()”
@
text
@d396 1
d400 1
@


1.1.1.9.2.2
log
@normalise whitespace at EOL, EOF, adjacent newlines
@
text
@d347 1
@


1.1.1.9.2.3
log
@a little KNF: sort the includes
@
text
@d38 1
a40 1
#include <sys/stat.h>
@


1.1.1.9.2.4
log
@extremely rudimentary conversion to mirtoconf, doesn’t even build yet
@
text
@a38 1
#if HAVE_SYS_MTIO_H
a39 1
#endif
a48 3
#if HAVE_STRINGS_H
#include <strings.h>
#endif
a1259 1
#if HAVE_PLEDGE
a1264 1
#endif
@


1.1.1.9.2.5
log
@first file merge, almost complete:

• RCSID (will be done upon merge into MAIN branch)
• various casts (likely most no longer necessary, although some,
  like explicitly casting a sentinel nil to a pointer type, are new)
• use of OT_FMT in printf, casting the arguments
  (this also will need dprintf stub consideration)
@
text
@a4 2
 * Copyright (c) 2012, 2016, 2017
 *	mirabilos <m@@mirbsd.org>
d69 1
a69 1
int arfd = -1;				/* archive file descriptor */
d81 1
a81 2
static char *arcname_alloc = NULL;	/* this is so we can free(3) it */
const char *compress_program;		/* name of compression program */
a84 1
#if HAVE_SYS_MTIO_H
a85 1
#endif
d87 1
a87 1
static void ar_start_compress(int, int);
a100 1
#if HAVE_SYS_MTIO_H
a101 1
#endif
d121 2
a122 2
		if (arfd != -1 && compress_program != NULL)
			ar_start_compress(arfd, 0);
d132 2
a133 2
		if (arfd != -1 && compress_program != NULL)
			ar_start_compress(arfd, 1);
d170 1
a170 3
		paxwarn(0, act == LIST || act == EXTRACT ?
		    "Cannot read an archive from a directory %s" :
		    "Cannot write an archive on top of a directory %s",
a178 1
#if HAVE_SYS_MTIO_H
a179 3
#else
		artyp = ISCHR;
#endif
a306 4
		if (vfpart) {
			(void)write(listfd, "\n", 1);
			vfpart = 0;
		}
a370 7
	/* Vflag can cause this to have been set */
	if (vfpart) {
		(void)write(listfd, "\n", 1);
		vfpart = 0;
	}

	/* nothing to do any more, unless vflag */
d379 4
a389 1
/*XXX TODO: OT_FMT überall */
d574 2
a575 2
	else if (!frmt || !frmt->is_uar)
		paxwarn(1, "End of archive volume %d reached", arvol);
a713 1
#if HAVE_SYS_MTIO_H
a714 1
#endif
a731 1
#if HAVE_SYS_MTIO_H
a751 1
#endif
a856 1
#if HAVE_SYS_MTIO_H
a858 1
#endif
a920 1
#if HAVE_SYS_MTIO_H
a968 1
#endif
a973 1
#if HAVE_SYS_MTIO_H
a1086 1
#endif
d1101 2
a1102 1
	char *buf;
d1149 1
a1149 2
			if ((buf = tty_rd()) == NULL || !strcmp(buf, ".")) {
				free(buf);
d1157 4
a1160 2
			if ((buf[0] == '\0') || (buf[1] != '\0'))
				goto eunknown;
a1167 1
				free(buf);
d1169 1
a1169 1
					return (0);
d1171 1
a1171 1
				    arcname);
a1177 1
				free(buf);
d1181 1
a1181 3
 eunknown:
				tty_prnt("%s unknown command, try again\n", buf);
				free(buf);
d1196 1
a1196 2
		if ((buf = tty_rd()) == NULL || !strcmp(buf, ".")) {
			free(buf);
a1204 1
			free(buf);
a1208 1
			free(buf);
a1212 1
			free(buf);
d1220 11
a1230 2
			free(arcname_alloc);
			arcname = arcname_alloc = buf;
a1233 1
		free(buf);
d1236 1
a1236 1
	return (0);
d1240 2
a1241 2
 * ar_start_compress()
 * starts the compression/decompression process as a child, using magic
d1245 1
a1245 1
ar_start_compress(int fd, int wr)
d1248 1
a1248 5
	const char *compress_flags;

	guess_compress_program(wr);
	if (compress_program == NULL)
		return;
d1258 4
a1261 1
		dup2(fds[wr ? 1 : 0], fd);
d1276 1
a1276 1
			compress_flags = "-c";
d1280 1
a1280 1
			compress_flags = "-dc";
d1286 1
a1286 1
		putenv("PATH=" PAX_SAFE_PATH);
d1288 2
a1289 3
		if (execlp(compress_program, compress_program,
		    compress_flags, (char *)NULL) < 0)
			err(1, "could not exec %s", compress_program);
@


1.1.1.9.2.6
log
@some more tweaks
@
text
@a60 4
#ifndef PAX_SAFE_PATH
#define PAX_SAFE_PATH "/bin:/usr/bin"
#endif

@


1.1.1.9.2.7
log
@solution for rare open flags, also uses O_BINARY like in mksh
@
text
@d130 1
a130 1
		} else if ((arfd = binopen3(0, name, EXT_MODE, DMOD)) < 0)
d139 1
a139 1
		} else if ((arfd = binopen3(0, name, AR_MODE, DMOD)) < 0)
d150 1
a150 1
		} else if ((arfd = binopen3(0, name, APP_MODE, DMOD)) < 0)
@


1.1.1.9.2.8
log
@drop a few TODO comments
@
text
@d414 1
@


