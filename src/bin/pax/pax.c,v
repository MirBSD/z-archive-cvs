head	1.29;
access;
symbols
	paxmirabilis-20190825:1.29
	paxmirabilis-20190224:1.29
	paxmirabilis-20190210:1.29
	npax:1.1.1.9.0.2
	cvs-20181212:1.1.1.9
	paxmirabilis-20171021:1.25
	paxmirabilis-20161104:1.22
	paxmirabilis-20161031:1.22
	paxmirabilis-20161025:1.22
	paxmirabilis-20160306:1.22
	cvs-201603041945:1.1.1.5
	paxmirabilis-20151013:1.20
	paxmirabilis-20140703:1.19
	paxmirabilis-20120606:1.19
	paxmirabilis-20120605:1.19
	cvs-201206051745:1.1.1.4
	paxmirabilis-20120520:1.17
	paxmirabilis-20120216:1.16
	paxmirabilis-20120212:1.12
	cvs-201202112230:1.1.1.3
	paxmirabilis-20110817:1.8
	MIRBSD_10:1.7.0.2
	MIRBSD_10_BASE:1.7
	cvs-200710231945:1.1.1.2
	cvs-200606232242:1.1.1.2
	MIRBSD_9_BASE:1.4
	MIRBSD_8:1.3.0.2
	MIRBSD_8_BASE:1.3
	cvs-200507211800:1.1.1.1
	cvs-200504291700:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2018.12.13.07.09.11;	author tg;	state Exp;
branches;
next	1.28;
commitid	1005C1205A44B32AFA4;

1.28
date	2018.12.12.18.08.46;	author tg;	state Exp;
branches;
next	1.27;
commitid	1005C114EA81986F5EC;

1.27
date	2018.12.12.00.23.07;	author tg;	state Exp;
branches;
next	1.26;
commitid	1005C1054FE750D63F3;

1.26
date	2018.12.12.00.09.28;	author tg;	state Exp;
branches;
next	1.25;
commitid	1005C1051C27816C858;

1.25
date	2017.10.14.22.03.31;	author tg;	state Exp;
branches;
next	1.24;
commitid	10059E289C94A3ADF42;

1.24
date	2017.10.14.21.26.54;	author tg;	state Exp;
branches;
next	1.23;
commitid	10059E2812D599DF828;

1.23
date	2017.08.07.20.10.16;	author tg;	state Exp;
branches;
next	1.22;
commitid	1005988C69344442E37;

1.22
date	2016.03.06.13.47.50;	author tg;	state Exp;
branches;
next	1.21;
commitid	10056DC351700BAF310;

1.21
date	2015.10.14.18.10.08;	author tg;	state Exp;
branches;
next	1.20;
commitid	100561E9A905398529C;

1.20
date	2015.10.13.20.11.41;	author tg;	state Exp;
branches;
next	1.19;
commitid	100561D658E30F540B3;

1.19
date	2012.06.05.18.22.57;	author tg;	state Exp;
branches;
next	1.18;
commitid	1004FCE4E961DE91080;

1.18
date	2012.06.05.17.56.22;	author tg;	state Exp;
branches;
next	1.17;
commitid	1004FCE485D799CECB5;

1.17
date	2012.05.20.16.13.19;	author tg;	state Exp;
branches;
next	1.16;
commitid	1004FB918314D2FECC0;

1.16
date	2012.02.16.17.34.35;	author tg;	state Exp;
branches;
next	1.15;
commitid	1004F3D3E43690EE62A;

1.15
date	2012.02.16.17.27.32;	author tg;	state Exp;
branches;
next	1.14;
commitid	1004F3D3C992B2187A1;

1.14
date	2012.02.16.17.11.46;	author tg;	state Exp;
branches;
next	1.13;
commitid	1004F3D38626EFD0781;

1.13
date	2012.02.16.16.01.09;	author tg;	state Exp;
branches;
next	1.12;
commitid	1004F3D28152C6F33B8;

1.12
date	2012.02.12.01.22.20;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004F3714555572B58B;

1.11
date	2012.02.12.01.02.06;	author tg;	state Exp;
branches;
next	1.10;
commitid	1004F370F971B022B7C;

1.10
date	2012.02.12.00.44.57;	author tg;	state Exp;
branches;
next	1.9;
commitid	1004F370B9F1314ECC5;

1.9
date	2012.02.12.00.27.17;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004F3707786D20BF4A;

1.8
date	2011.08.16.13.50.18;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004E4A75A9095E9071;

1.7
date	2007.02.17.04.52.41;	author tg;	state Exp;
branches;
next	1.6;
commitid	10045D68A2D54E2C558;

1.6
date	2007.01.23.11.55.54;	author tg;	state Exp;
branches;
next	1.5;
commitid	10045B5F7D62388E117;

1.5
date	2006.07.16.18.00.33;	author tg;	state Exp;
branches;
next	1.4;
commitid	10044BA7EC05C9AD0BE;

1.4
date	2006.06.23.23.03.57;	author tg;	state Exp;
branches;
next	1.3;
commitid	100449C736877C98FFB;

1.3
date	2005.04.13.20.03.35;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.04.13.19.49.34;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.22.06;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.22.06;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.06.23.23.00.16;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	100449C727D31170AA3;

1.1.1.3
date	2012.02.11.22.47.21;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	1004F36F008225F3522;

1.1.1.4
date	2012.06.05.17.52.08;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	1004FCE475F54798920;

1.1.1.5
date	2016.03.04.19.46.09;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	10056D9E61429EE6550;

1.1.1.6
date	2016.03.04.20.55.03;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	10056D9F62E152ECBA5;

1.1.1.7
date	2016.03.06.13.29.55;	author tg;	state Exp;
branches;
next	1.1.1.8;
commitid	10056DC30960F3F5FA0;

1.1.1.8
date	2018.12.12.00.15.06;	author tg;	state Exp;
branches;
next	1.1.1.9;
commitid	1005C1052FA5E745A2C;

1.1.1.9
date	2018.12.12.00.24.23;	author tg;	state Exp;
branches
	1.1.1.9.2.1;
next	;
commitid	1005C1055452C78F9E4;

1.1.1.9.2.1
date	2018.12.12.00.52.59;	author tg;	state Exp;
branches;
next	1.1.1.9.2.2;
commitid	1005C105BC86262A0B7;

1.1.1.9.2.2
date	2018.12.12.01.05.52;	author tg;	state Exp;
branches;
next	1.1.1.9.2.3;
commitid	1005C105F03799CC958;

1.1.1.9.2.3
date	2018.12.12.03.13.33;	author tg;	state Exp;
branches;
next	1.1.1.9.2.4;
commitid	1005C107CE315DC51F3;

1.1.1.9.2.4
date	2018.12.12.06.03.14;	author tg;	state Exp;
branches;
next	1.1.1.9.2.5;
commitid	1005C10A4B12E5998CE;

1.1.1.9.2.5
date	2018.12.12.09.08.57;	author tg;	state Exp;
branches;
next	1.1.1.9.2.6;
commitid	1005C10D0381A00BE25;

1.1.1.9.2.6
date	2018.12.12.10.24.15;	author tg;	state Exp;
branches;
next	1.1.1.9.2.7;
commitid	1005C10E1DB5956B939;

1.1.1.9.2.7
date	2018.12.12.12.43.14;	author tg;	state Exp;
branches;
next	1.1.1.9.2.8;
commitid	1005C1102747A3732E3;

1.1.1.9.2.8
date	2018.12.12.15.00.26;	author tg;	state Exp;
branches;
next	1.1.1.9.2.9;
commitid	1005C11229872472EAF;

1.1.1.9.2.9
date	2018.12.12.15.52.23;	author tg;	state Exp;
branches;
next	;
commitid	1005C112ECC154651A6;


desc
@@


1.29
log
@fixing and string pooling and int shortening offensive
@
text
@/*	$OpenBSD: pax.c,v 1.52 2018/09/13 12:33:43 millert Exp $	*/
/*	$NetBSD: pax.c,v 1.5 1996/03/26 23:54:20 mrg Exp $	*/

/*-
 * Copyright (c) 2012, 2015, 2016, 2017
 *	mirabilos <m@@mirbsd.org>
 * Copyright (c) 1992 Keith Muller.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#if HAVE_BOTH_TIME_H
#include <sys/time.h>
#include <time.h>
#elif HAVE_SYS_TIME_H
#include <sys/time.h>
#elif HAVE_TIME_H
#include <time.h>
#endif
#if HAVE_SYS_RESOURCE_H
#include <sys/resource.h>
#endif
#include <sys/stat.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#if HAVE_GRP_H
#include <grp.h>
#endif
#if HAVE_PATHS_H
#include <paths.h>
#endif
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if HAVE_STRINGS_H
#include <strings.h>
#endif
#include <unistd.h>

#include "pax.h"
#include "extern.h"

__RCSID("$MirOS: src/bin/pax/pax.c,v 1.28 2018/12/12 18:08:46 tg Exp $");

static int gen_init(void);

/*
 * PAX main routines, general globals and some simple start up routines
 */

/*
 * Variables that can be accessed by any routine within pax
 */
signed char act = ERROR;	/* read/write/append/copy */
const FSUB *frmt = NULL;	/* archive format type */
signed char cflag;		/* match all EXCEPT pattern/file */
signed char cwdfd;		/* starting cwd */
signed char dflag;		/* directory member match only  */
signed char iflag;		/* interactive file/archive rename */
signed char kflag;		/* do not overwrite existing files */
signed char lflag;		/* use hard links when possible */
signed char nflag;		/* select first archive member match */
signed char tflag;		/* restore access time after read */
signed char uflag;		/* ignore older modification time files */
signed char Vflag = 0;		/* print a dot for each file processed */
signed char vflag;		/* produce verbose output */
signed char Dflag;		/* same as uflag except inode change time */
signed char Hflag;		/* follow command line symlinks (write only) */
signed char Lflag;		/* follow symlinks when writing */
signed char Xflag;		/* archive files with same device id only */
signed char Yflag;		/* same as Dflag except after name mode */
signed char Zflag;		/* same as uflag except after name mode */
signed char zeroflag;		/* use \0 as pathname terminator */
signed char vfpart = 0;		/* is partial verbose output in progress */
signed char patime = 1;		/* preserve file access time */
signed char pmtime = 1;		/* preserve file modification times */
signed char nodirs;		/* do not create directories as needed */
signed char pmode;		/* preserve file mode bits */
signed char pids;		/* preserve file uid/gid */
signed char rmleadslash = 0;	/* remove leading '/' from pathnames */
signed char exit_val;		/* exit value */
signed char docrc;		/* check/create file crc */
char	*dirptr;		/* destination dir in a copy */
const char *argv0;		/* root of argv[0] */
enum op_mode op_mode;		/* what program are we acting as? */
sigset_t s_mask;		/* signal mask for cleanup critical sect */
FILE	*listf;			/* fp to print file list to (default stderr) */
int	listfd = STDERR_FILENO;	/* fd matching listf, for sighandler output */
char	*tempfile;		/* tempfile to use for mkstemp(3) */
char	*tempbase;		/* basename of tempfile to use for mkstemp(3) */
time_t	 now;			/* time of program start */

/*
 *	PAX - Portable Archive Interchange
 *
 *	A utility to read, write, and write lists of the members of archive
 *	files and copy directory hierarchies. A variety of archive formats
 *	are supported (some are described in POSIX 1003.1 10.1):
 *
 *		ustar - 10.1.1 extended tar interchange format
 *		cpio  - 10.1.2 extended cpio interchange format
 *		tar - old BSD 4.3 tar format
 *		binary cpio - old cpio with binary header format
 *		sysVR4 cpio -  with and without CRC
 *
 * This version is a superset of IEEE Std 1003.2b-d3
 *
 * Summary of Extensions to the IEEE Standard:
 *
 * 1	READ ENHANCEMENTS
 * 1.1	Operations which read archives will continue to operate even when
 *	processing archives which may be damaged, truncated, or fail to meet
 *	format specs in several different ways. Damaged sections of archives
 *	are detected and avoided if possible. Attempts will be made to resync
 *	archive read operations even with badly damaged media.
 * 1.2	Blocksize requirements are not strictly enforced on archive read.
 *	Tapes which have variable sized records can be read without errors.
 * 1.3	The user can specify via the non-standard option flag -E if error
 *	resync operation should stop on a media error, try a specified number
 *	of times to correct, or try to correct forever.
 * 1.4	Sparse files (lseek holes) stored on the archive (but stored with blocks
 *	of all zeros will be restored with holes appropriate for the target
 *	filesystem
 * 1.5	The user is notified whenever something is found during archive
 *	read operations which violates spec (but the read will continue).
 * 1.6	Multiple archive volumes can be read and may span over different
 *	archive devices
 * 1.7	Rigidly restores all file attributes exactly as they are stored on the
 *	archive.
 * 1.8	Modification change time ranges can be specified via multiple -T
 *	options. These allow a user to select files whose modification time
 *	lies within a specific time range.
 * 1.9	Files can be selected based on owner (user name or uid) via one or more
 *	-U options.
 * 1.10	Files can be selected based on group (group name or gid) via one o
 *	more -G options.
 * 1.11	File modification time can be checked against existing file after
 *	name modification (-Z)
 *
 * 2	WRITE ENHANCEMENTS
 * 2.1	Write operation will stop instead of allowing a user to create a flawed
 *	flawed archive (due to any problem).
 * 2.2	Archives written by pax are forced to strictly conform to both the
 *	archive and pax the specific format specifications.
 * 2.3	Blocking size and format is rigidly enforced on writes.
 * 2.4	Formats which may exhibit header overflow problems (they have fields
 *	too small for large filesystems, such as inode number storage), use
 *	routines designed to repair this problem. These techniques still
 *	conform to both pax and format specifications, but no longer truncate
 *	these fields. This removes any restrictions on using these archive
 *	formats on large filesystems.
 * 2.5	Multiple archive volumes can be written and may span over different
 *	archive devices
 * 2.6	A archive volume record limit allows the user to specify the number
 *	of bytes stored on an archive volume. When reached the user is
 *	prompted for the next archive volume. This is specified with the
 *	non-standard -B flag. The limit is rounded up to the next blocksize.
 * 2.7	All archive padding during write use zero filled sections. This makes
 *	it much easier to pull data out of flawed archive during read
 *	operations.
 * 2.8	Access time reset with the -t applies to all file nodes (including
 *	directories).
 * 2.9	Symbolic links can be followed with -L (optional in the spec).
 * 2.10	Modification or inode change time ranges can be specified via
 *	multiple -T options. These allow a user to select files whose
 *	modification or inode change time lies within a specific time range.
 * 2.11	Files can be selected based on owner (user name or uid) via one or more
 *	-U options.
 * 2.12	Files can be selected based on group (group name or gid) via one o
 *	more -G options.
 * 2.13	Symlinks which appear on the command line can be followed (without
 *	following other symlinks; -H flag)
 *
 * 3	COPY ENHANCEMENTS
 * 3.1	Sparse files (lseek holes) can be copied without expanding the holes
 *	into zero filled blocks. The file copy is created with holes which are
 *	appropriate for the target filesystem
 * 3.2	Access time as well as modification time on copied file trees can be
 *	preserved with the appropriate -p options.
 * 3.3	Access time reset with the -t applies to all file nodes (including
 *	directories).
 * 3.4	Symbolic links can be followed with -L (optional in the spec).
 * 3.5	Modification or inode change time ranges can be specified via
 *	multiple -T options. These allow a user to select files whose
 *	modification or inode change time lies within a specific time range.
 * 3.6	Files can be selected based on owner (user name or uid) via one or more
 *	-U options.
 * 3.7	Files can be selected based on group (group name or gid) via one o
 *	more -G options.
 * 3.8	Symlinks which appear on the command line can be followed (without
 *	following other symlinks; -H flag)
 * 3.9  File inode change time can be checked against existing file before
 *	name modification (-D)
 * 3.10 File inode change time can be checked against existing file after
 *	name modification (-Y)
 * 3.11	File modification time can be checked against existing file after
 *	name modification (-Z)
 *
 * 4	GENERAL ENHANCEMENTS
 * 4.1	Internal structure is designed to isolate format dependent and
 *	independent functions. Formats are selected via a format driver table.
 *	This encourages the addition of new archive formats by only having to
 *	write those routines which id, read and write the archive header.
 */

/*
 * main()
 *	parse options, set up and operate as specified by the user.
 *	any operational flaw will set exit_val to non-zero
 * Return: 0 if ok, 1 otherwise
 */

int
main(int argc, char **argv)
{
	const char *tmpdir;
	size_t tdlen;

	/* may not be a constant, thus initialising early */
	listf = stderr;

	now = time(NULL);

	/*
	 * Keep a reference to cwd, so we can always come back home.
	 */
	cwdfd = binopen2(BO_CLEXEC, ".", O_RDONLY);
	if (cwdfd < 0) {
		syswarn(1, errno, "Cannot open current working directory.");
		return(exit_val);
	}

	/*
	 * Where should we put temporary files?
	 */
	if ((tmpdir = getenv("TMPDIR")) == NULL || *tmpdir == '\0')
		tmpdir = _PATH_TMP;
	tdlen = strlen(tmpdir);
	while (tdlen > 0 && tmpdir[tdlen - 1] == '/')
		tdlen--;
	tempfile = malloc(tdlen + 1 + sizeof(_TFILE_BASE));
	if (tempfile == NULL) {
		paxwarn(1, "%s for %s", "Out of memory",
		    "temp file name");
		return (exit_val);
	}
	if (tdlen)
		memcpy(tempfile, tmpdir, tdlen);
	tempbase = tempfile + tdlen;
	*tempbase++ = '/';

#if HAVE_SETPGENT
	/*
	 * keep passwd and group files open for faster lookups.
	 */
	setpassent(1);
	setgroupent(1);
#endif

	/*
	 * parse options, determine operational mode, general init
	 */
	options(argc, argv);
	if ((gen_init() < 0) || (tty_init() < 0))
		return(exit_val);

#if HAVE_PLEDGE
	/*
	 * pmode needs to restore setugid bits when extracting or copying,
	 * so can't pledge at all then.
	 */
	if (pmode == 0 || (act != EXTRACT && act != COPY)) {
		if (pledge("stdio rpath wpath cpath fattr dpath getpw proc exec tape",
		    NULL) == -1)
			err(1, "pledge");

		/* Copy mode, or no gzip -- don't need to fork/exec. */
		if (compress_program == NULL || act == COPY) {
			if (pledge("stdio rpath wpath cpath fattr dpath getpw tape",
			    NULL) == -1)
				err(1, "pledge");
		}
	}
#endif

	/* make list fd independent and line-buffered */
	if ((listfd = dup(fileno(listf))) < 0 ||
	    !(listf = fdopen(listfd, "wb"))) {
		syswarn(1, errno, "Cannot open list file descriptor");
		return (exit_val);
	}
	if (fcntl(listfd, F_SETFD, FD_CLOEXEC) == -1)
		syswarn(0, errno, "%s on list file descriptor",
		    "Failed to set the close-on-exec flag");
	setlinebuf(listf);

	/*
	 * select a primary operation mode
	 */
	switch (act) {
	case EXTRACT:
		extract();
		break;
	case ARCHIVE:
		archive();
		break;
	case APPND:
		if (compress_program != NULL)
			errx(1, "cannot compress while appending");
		append();
		break;
	case COPY:
		copy();
		break;
	default:
		/* for ar_io.c etc. */
		act = LIST;
		/* FALLTHROUGH */
	case LIST:
		list();
		break;
	}
	return(exit_val);
}

/*
 * sig_cleanup()
 *	when interrupted we try to do whatever delayed processing we can.
 *	This is not critical, but we really ought to limit our damage when we
 *	are aborted by the user.
 * Return:
 *	never....
 */

void
sig_cleanup(int which_sig)
{
	/*
	 * Restore modes and times for any dirs we may have created
	 * or any dirs we may have read. Set vflag and vfpart so the
	 * user will clearly see the message on a line by itself.
	 */
	vflag = vfpart = 1;

	/* paxwarn() uses stdio; fake it as well as we can */
	if (which_sig == SIGXCPU)
		dprintf(STDERR_FILENO, "\nCPU time limit reached, cleaning up.\n");
	else if (!which_sig)
		dprintf(STDERR_FILENO, "\nCowardly giving up, trying to clean up.\n");
	else
		dprintf(STDERR_FILENO, "\nSignal caught, cleaning up.\n");

	ar_close(1);
	sltab_process(1);
	proc_dir(1);
	if (tflag)
		atdir_end();
	_exit(1);
}

/*
 * setup_sig()
 *	set a signal to be caught, but only if it isn't being ignored already
 */

static int
setup_sig(int sig, const struct sigaction *n_hand)
{
	struct sigaction o_hand;

	if (sigaction(sig, NULL, &o_hand) < 0)
		return (-1);

	if (o_hand.sa_handler == SIG_IGN)
		return (0);

	return (sigaction(sig, n_hand, NULL));
}

/*
 * gen_init()
 *	general setup routines. Not all are required, but they really help
 *	when dealing with a medium to large sized archives.
 */

static int
gen_init(void)
{
	struct rlimit reslimit;
	struct sigaction n_hand;

	/*
	 * Really needed to handle large archives. We can run out of memory for
	 * internal tables really fast when we have a whole lot of files...
	 */
	if (getrlimit(RLIMIT_DATA , &reslimit) == 0){
		reslimit.rlim_cur = reslimit.rlim_max;
		(void)setrlimit(RLIMIT_DATA , &reslimit);
	}

	/*
	 * should file size limits be waived? if the os limits us, this is
	 * needed if we want to write a large archive
	 */
	if (getrlimit(RLIMIT_FSIZE , &reslimit) == 0){
		reslimit.rlim_cur = reslimit.rlim_max;
		(void)setrlimit(RLIMIT_FSIZE , &reslimit);
	}

	/*
	 * increase the size the stack can grow to
	 */
	if (getrlimit(RLIMIT_STACK , &reslimit) == 0){
		reslimit.rlim_cur = reslimit.rlim_max;
		(void)setrlimit(RLIMIT_STACK , &reslimit);
	}

	/*
	 * not really needed, but doesn't hurt
	 */
#ifdef RLIMIT_RSS
	if (getrlimit(RLIMIT_RSS , &reslimit) == 0){
		reslimit.rlim_cur = reslimit.rlim_max;
		(void)setrlimit(RLIMIT_RSS , &reslimit);
	}
#endif

	/*
	 * signal handling to reset stored directory times and modes. Since
	 * we deal with broken pipes via failed writes we ignore it. We also
	 * deal with any file size limit through failed writes. CPU time
	 * limits are caught and a cleanup is forced.
	 */
	if ((sigemptyset(&s_mask) < 0) || (sigaddset(&s_mask, SIGTERM) < 0) ||
	    (sigaddset(&s_mask,SIGINT) < 0)||(sigaddset(&s_mask,SIGHUP) < 0) ||
	    (sigaddset(&s_mask,SIGPIPE) < 0)||(sigaddset(&s_mask,SIGQUIT)<0) ||
	    (sigaddset(&s_mask,SIGXCPU) < 0)||(sigaddset(&s_mask,SIGXFSZ)<0)) {
		paxwarn(1, "Unable to set up signal mask");
		return(-1);
	}

	/* snag the fd to be used from the signal handler */
	listfd = fileno(listf);

	memset(&n_hand, 0, sizeof n_hand);
	n_hand.sa_mask = s_mask;
	n_hand.sa_flags = 0;
	n_hand.sa_handler = sig_cleanup;

	if (setup_sig(SIGHUP,  &n_hand) ||
	    setup_sig(SIGTERM, &n_hand) ||
	    setup_sig(SIGINT,  &n_hand) ||
	    setup_sig(SIGQUIT, &n_hand) ||
	    setup_sig(SIGXCPU, &n_hand))
		goto out;

	n_hand.sa_handler = SIG_IGN;
	if ((sigaction(SIGPIPE, &n_hand, NULL) < 0) ||
	    (sigaction(SIGXFSZ, &n_hand, NULL) < 0))
		goto out;
	return (0);

 out:
	syswarn(1, errno, "Unable to set up signal handler");
	return (-1);
}
@


1.28
log
@merge the npax branch into MAIN

asides from a missing dprintf and portability, this ought to be
good enough for people (well me) to play with for now
@
text
@d74 1
a74 1
__RCSID("$MirOS: src/bin/pax/pax.c,v 1.26 2018/12/12 00:09:28 tg Exp $");
d85 29
a113 29
int	act = ERROR;		/* read/write/append/copy */
FSUB	*frmt = NULL;		/* archive format type */
int	cflag;			/* match all EXCEPT pattern/file */
int	cwdfd;			/* starting cwd */
int	dflag;			/* directory member match only  */
int	iflag;			/* interactive file/archive rename */
int	kflag;			/* do not overwrite existing files */
int	lflag;			/* use hard links when possible */
int	nflag;			/* select first archive member match */
int	tflag;			/* restore access time after read */
int	uflag;			/* ignore older modification time files */
int	Vflag = 0;		/* print a dot for each file processed */
int	vflag;			/* produce verbose output */
int	Dflag;			/* same as uflag except inode change time */
int	Hflag;			/* follow command line symlinks (write only) */
int	Lflag;			/* follow symlinks when writing */
int	Xflag;			/* archive files with same device id only */
int	Yflag;			/* same as Dflag except after name mode */
int	Zflag;			/* same as uflag except after name mode */
int	zeroflag;		/* use \0 as pathname terminator */
int	vfpart = 0;		/* is partial verbose output in progress */
int	patime = 1;		/* preserve file access time */
int	pmtime = 1;		/* preserve file modification times */
int	nodirs;			/* do not create directories as needed */
int	pmode;			/* preserve file mode bits */
int	pids;			/* preserve file uid/gid */
int	rmleadslash = 0;	/* remove leading '/' from pathnames */
int	exit_val;		/* exit value */
int	docrc;			/* check/create file crc */
d260 1
a260 1
		syswarn(1, errno, "Can't open current working directory.");
d274 3
a276 2
		paxwarn(1, "Cannot allocate memory for temp file name.");
		return(exit_val);
d309 1
a309 1
		if (gzip_program == NULL || act == COPY) {
d318 3
a320 2
	if (!(listf = fdopen((listfd = dup(fileno(listf))), "wb"))) {
		syswarn(1, errno, "Can't open list file descriptor");
@


1.27
log
@slowmerge (untested though)
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.51 2017/12/08 17:04:14 deraadt Exp $	*/
d39 5
a43 2
#include <sys/param.h>
#include <sys/stat.h>
d45 4
d50 12
a62 1
#include <unistd.h>
d66 5
a70 5
#include <errno.h>
#include <err.h>
#include <fcntl.h>
#include <paths.h>
#include <time.h>
d116 1
d119 1
d122 1
d253 2
d258 1
a258 1
	cwdfd = open(".", O_RDONLY);
d282 8
d297 19
d317 1
a317 1
	if (!(listf = fdopen(dup(fileno(listf)), "wb"))) {
d321 3
d368 3
a370 12
	 * The definition of this array doubles as compile-time assert
	 * on the size of long, off_t, and whether LONG_OFF_T is used,
	 * or not, correctly; target size is 80, error size -1.
	 */
	char errbuf[((sizeof(long) >= 4) &&
	    (sizeof(ot_type) >= 4) &&
	    (sizeof(ot_type) == sizeof(off_t))) ? 80 : -1];

	/*
	 * restore modes and times for any dirs we may have created
	 * or any dirs we may have read. Set vflag and vfpart so the user
	 * will clearly see the message on a line by itself.
d376 1
a376 2
		strlcpy(errbuf, "CPU time limit reached, cleaning up.\n",
		    sizeof errbuf);
d378 1
a378 2
		strlcpy(errbuf, "Cowardly giving up, trying to clean up.\n",
		    sizeof errbuf);
d380 1
a380 6
		strlcpy(errbuf, "Signal caught, cleaning up.\n",
		    sizeof errbuf);
	if (!write(STDERR_FILENO, errbuf, strlen(errbuf))) {
		/* dummy, to keep fortified gcc quiet */
		errbuf[0] = '\0';
	}
d382 1
a382 1
	ar_close();			/* XXX signal race */
d384 1
a384 1
	proc_dir();			/* XXX signal race */
d386 1
a386 1
		atdir_end();		/* XXX signal race */
d391 19
a419 1
	struct sigaction o_hand;
d470 4
d479 5
a483 23
	if ((sigaction(SIGHUP, &n_hand, &o_hand) < 0) || (
	    (o_hand.sa_handler == SIG_IGN) &&
	    (sigaction(SIGHUP, &o_hand, NULL) < 0)))
		goto out;

	if ((sigaction(SIGTERM, &n_hand, &o_hand) < 0) || (
	    (o_hand.sa_handler == SIG_IGN) &&
	    (sigaction(SIGTERM, &o_hand, NULL) < 0)))
		goto out;

	if ((sigaction(SIGINT, &n_hand, &o_hand) < 0) || (
	    (o_hand.sa_handler == SIG_IGN) &&
	    (sigaction(SIGINT, &o_hand, NULL) < 0)))
		goto out;

	if ((sigaction(SIGQUIT, &n_hand, &o_hand) < 0) || (
	    (o_hand.sa_handler == SIG_IGN) &&
	    (sigaction(SIGQUIT, &o_hand, NULL) < 0)))
		goto out;

	if ((sigaction(SIGXCPU, &n_hand, &o_hand) < 0) || (
	    (o_hand.sa_handler == SIG_IGN) &&
	    (sigaction(SIGXCPU, &o_hand, NULL) < 0)))
d487 2
a488 2
	if ((sigaction(SIGPIPE, &n_hand, &o_hand) < 0) ||
	    (sigaction(SIGXFSZ, &n_hand, &o_hand) < 0))
d490 1
a490 1
	return(0);
d494 1
a494 1
	return(-1);
@


1.26
log
@merge patches from Debian 1:20171021-3 upload
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.33 2012/04/19 04:26:46 deraadt Exp $	*/
d56 1
a56 1
__RCSID("$MirOS: src/bin/pax/pax.c,v 1.24 2017/10/14 21:26:54 tg Exp $");
@


1.25
log
@prevent an entire class of errors: integer overflow in rd_skip() arg

Reported as: Debian #878512

Turns out that “rd_skip(arcn->skip + arcn->pad);” is often called
without checking for negative (error) return, or even throwing away
the result entirely (õÕ) and is called often enough that checking
before calling would be tremendous effort, and to split it up à la
calloc() is certainly another option but this catches it good enough.
We (ab|re)use the signal handler exit function to do some cleanup.
@
text
@d422 1
a422 1
	    (sigaction(SIGHUP, &o_hand, &o_hand) < 0)))
d427 1
a427 1
	    (sigaction(SIGTERM, &o_hand, &o_hand) < 0)))
d432 1
a432 1
	    (sigaction(SIGINT, &o_hand, &o_hand) < 0)))
d437 1
a437 1
	    (sigaction(SIGQUIT, &o_hand, &o_hand) < 0)))
d442 1
a442 1
	    (sigaction(SIGXCPU, &o_hand, &o_hand) < 0)))
@


1.24
log
@mising FALLTHROUGH for lint, complained by gcc on Debian
@
text
@d5 1
a5 1
 * Copyright (c) 2012, 2015, 2016
d56 1
a56 1
__RCSID("$MirOS: src/bin/pax/pax.c,v 1.23 2017/08/07 20:10:16 tg Exp $");
a58 1
static void sig_cleanup(int) __attribute__((__noreturn__));
d311 1
a311 1
static void
d334 3
@


1.23
log
@filesystem
@
text
@d56 1
a56 1
__RCSID("$MirOS: src/bin/pax/pax.c,v 1.22 2016/03/06 13:47:50 tg Exp $");
d295 1
@


1.22
log
@merge CVE fixes from openbsd branch
@
text
@d56 1
a56 1
__RCSID("$MirOS: src/bin/pax/pax.c,v 1.20 2015/10/13 20:11:41 tg Exp $");
d158 1
a158 1
 *	too small for large file systems, such as inode number storage), use
d162 1
a162 1
 *	formats on large file systems.
@


1.21
log
@end this nonsense locally, until the next obsd import
@
text
@d5 1
a5 1
 * Copyright (c) 2012, 2015
d343 1
@


1.20
log
@duplicate listfd and make it line-buffered
@
text
@d56 1
a56 1
__RCSID("$MirOS: src/bin/pax/pax.c,v 1.19 2012/06/05 18:22:57 tg Exp $");
a97 1
char	*ltmfrmt;		/* -v locale time format (if any) */
a398 7
	 * Handle posix locale
	 *
	 * set user defines time printing format for -v option
	 */
	ltmfrmt = getenv("LC_TIME");

	/*
@


1.19
log
@KNF
@
text
@d5 2
a6 2
 * Copyright (c) 2012
 *	Thorsten Glaser <tg@@mirbsd.org>
d56 1
a56 1
__RCSID("$MirOS: src/bin/pax/pax.c,v 1.18 2012/06/05 17:56:22 tg Exp $");
d268 7
@


1.18
log
@fastmerge
@
text
@d56 1
a56 1
__RCSID("$MirOS: src/bin/pax/pax.c,v 1.17 2012/05/20 16:13:19 tg Exp $");
d448 1
a448 1
    out:
@


1.17
log
@get rid of extern.h including other headers
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.32 2011/05/26 14:42:06 deraadt Exp $	*/
d56 1
a56 1
__RCSID("$MirOS: src/bin/pax/pax.c,v 1.16 2012/02/16 17:34:35 tg Exp $");
d326 1
a326 1
		strlcpy(errbuf, "CPU time limit reached, cleaning up.",
d329 1
a329 1
		strlcpy(errbuf, "Signal caught, cleaning up.",
@


1.16
log
@unbreak LP64… oops
@
text
@d52 1
d56 1
a56 1
__RCSID("$MirOS: src/bin/pax/pax.c,v 1.15 2012/02/16 17:27:32 tg Exp $");
@


1.15
log
@clean up some ugliness
@
text
@d55 1
a55 1
__RCSID("$MirOS: src/bin/pax/pax.c,v 1.14 2012/02/16 17:11:46 tg Exp $");
d312 1
a312 1
	char errbuf[((sizeof(long) == 4) &&
@


1.14
log
@Debian GNU/kFreeBSD can be more difficult to deal with than GNU/Hurd at times.

• switch from quad_t to using unsigned long / unsigned long long
• sanitise use of off_t-relevant types
• cast when printing off_t; use a once-defined type and format specifier
• convert “This define is important” into actual compile-time assertion
• simplify ifdef mess by always defining off_t specific routines
  instead of reusing those for long if off_t is just long
@
text
@d55 1
a55 1
__RCSID("$MirOS: src/bin/pax/pax.c,v 1.13 2012/02/16 16:01:09 tg Exp $");
d278 2
a279 2
		if (gzip_program != NULL)
			errx(1, "can not gzip while appending");
d286 2
a287 1
		act = LIST;	/* for ar_io.c &c. */
@


1.13
log
@implement the GNU cpio option -V (print a dot per file processed)
sponsored by tarent solutions GmbH for work on evolvis (FusionForge)
@
text
@d55 1
a55 1
__RCSID("$MirOS: src/bin/pax/pax.c,v 1.12 2012/02/12 01:22:20 tg Exp $");
d306 8
a313 1
	char errbuf[80];
@


1.12
log
@F U gcc with -D_FORTIFY_SOURCE=2
@
text
@d55 1
a55 1
__RCSID("$MirOS: src/bin/pax/pax.c,v 1.11 2012/02/12 01:02:06 tg Exp $");
d78 1
d87 1
a87 1
int	vfpart;			/* is partial verbose output in progress */
@


1.11
log
@add most misc. patches from Debian (reopen #609825 as the test is bogus)
@
text
@d55 1
a55 1
__RCSID("$MirOS: src/bin/pax/pax.c,v 1.10 2012/02/12 00:44:57 tg Exp $");
d321 4
a324 1
	(void) write(STDERR_FILENO, errbuf, strlen(errbuf));
@


1.10
log
@spelling
@
text
@d55 1
a55 1
__RCSID("$MirOS: src/bin/pax/pax.c,v 1.9 2012/02/12 00:27:17 tg Exp $");
d229 3
a258 2
	listf = stderr;

@


1.9
log
@merge OpenBSD
@
text
@d55 1
a55 1
__RCSID("$MirOS: src/bin/pax/pax.c,v 1.8 2011/08/16 13:50:18 tg Exp $");
d315 1
a315 1
		strlcpy(errbuf, "Cpu time limit reached, cleaning up.",
d388 1
a388 1
	 * deal with any file size limit through failed writes. Cpu time
@


1.8
log
@use underscores with __attribute__s
@
text
@d1 1
a1 2
/**	$MirOS: src/bin/pax/pax.c,v 1.7 2007/02/17 04:52:41 tg Exp $ */
/*	$OpenBSD: pax.c,v 1.28 2005/08/04 10:02:44 mpf Exp $	*/
d5 2
d55 1
a55 4
__COPYRIGHT("@@(#) Copyright (c) 1992, 1993\n\
	The Regents of the University of California.  All rights reserved.\n");
__SCCSID("@@(#)pax.c	8.2 (Berkeley) 4/18/94");
__RCSID("$MirOS: src/bin/pax/pax.c,v 1.7 2007/02/17 04:52:41 tg Exp $");
d304 1
a304 1
	/* XXX signal races */
d312 2
d315 2
a316 1
		paxwarn(0, "Cpu time limit reached, cleaning up.");
d318 3
a320 1
		paxwarn(0, "Signal caught, cleaning up.");
d322 2
a323 2
	ar_close();
	proc_dir();
d325 2
a326 2
		atdir_end();
	exit(1);
d403 1
a403 1
	if ((sigaction(SIGHUP, &n_hand, &o_hand) < 0) &&
d405 1
a405 1
	    (sigaction(SIGHUP, &o_hand, &o_hand) < 0))
d408 1
a408 1
	if ((sigaction(SIGTERM, &n_hand, &o_hand) < 0) &&
d410 1
a410 1
	    (sigaction(SIGTERM, &o_hand, &o_hand) < 0))
d413 1
a413 1
	if ((sigaction(SIGINT, &n_hand, &o_hand) < 0) &&
d415 1
a415 1
	    (sigaction(SIGINT, &o_hand, &o_hand) < 0))
d418 1
a418 1
	if ((sigaction(SIGQUIT, &n_hand, &o_hand) < 0) &&
d420 1
a420 1
	    (sigaction(SIGQUIT, &o_hand, &o_hand) < 0))
d423 1
a423 1
	if ((sigaction(SIGXCPU, &n_hand, &o_hand) < 0) &&
d425 1
a425 1
	    (sigaction(SIGXCPU, &o_hand, &o_hand) < 0))
@


1.7
log
@__CRAZY clean
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/pax.c,v 1.6 2007/01/23 11:55:54 tg Exp $ */
d57 1
a57 1
__RCSID("$MirOS: src/bin/pax/pax.c,v 1.6 2007/01/23 11:55:54 tg Exp $");
d60 1
a60 1
static void sig_cleanup(int) __attribute__((noreturn));
@


1.6
log
@fix DEFOP vs ERROR botch when merging from TNF
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/pax.c,v 1.5 2006/07/16 18:00:33 tg Exp $ */
d57 1
a57 1
__RCSID("$MirOS: src/bin/pax/pax.c,v 1.5 2006/07/16 18:00:33 tg Exp $");
d60 1
d99 1
a99 1
char	*argv0;			/* root of argv[0] */
d228 1
a228 1
	char *tmpdir;
d303 1
a303 1
void
@


1.5
log
@initialise listf with stderr late,
on glibc it is not a constant able
to being used for .data stuff
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/pax.c,v 1.4 2006/06/23 23:03:57 tg Exp $ */
a37 6
#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1992, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

d54 2
d57 1
a57 1
__RCSID("$MirOS: src/bin/pax/pax.c,v 1.4 2006/06/23 23:03:57 tg Exp $");
d68 1
a68 1
int	act = DEFOP;		/* read/write/append/copy */
d285 1
@


1.4
log
@merge the OpenBSD import (bugfix)
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/pax.c,v 1.3 2005/04/13 20:03:35 tg Exp $ */
d61 1
a61 1
__RCSID("$MirOS: src/bin/pax/pax.c,v 1.3 2005/04/13 20:03:35 tg Exp $");
d104 1
a104 1
FILE	*listf = stderr;	/* file pointer to print file list to */
d261 2
@


1.3
log
@these are the compile time fixes
this commit message provided by interix ;)
@
text
@d1 2
a2 2
/**	$MirOS: src/bin/pax/pax.c,v 1.2 2005/04/13 19:49:34 tg Exp $ */
/*	$OpenBSD: pax.c,v 1.27 2004/04/16 22:50:23 deraadt Exp $	*/
d61 1
a61 1
__RCSID("$MirOS$");
d239 1
a239 1
		syswarn(0, errno, "Can't open current working directory.");
@


1.2
log
@first the compile fixes. later, link fixes will follow.
@
text
@d1 1
a1 1
/**	$MirOS$ */
a43 10
#ifndef lint
#if 0
static const char sccsid[] = "@@(#)pax.c	8.2 (Berkeley) 4/18/94";
#else
static const char rcsid[] = "$OpenBSD: pax.c,v 1.27 2004/04/16 22:50:23 deraadt Exp $";
#endif
#endif /* not lint */

#include <stdio.h>
#include <sys/types.h>
d50 1
d59 4
@


1.1
log
@Initial revision
@
text
@d1 1
d373 1
d378 1
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@One "miserable" byte in filenames is worth an import

agreed bsiegert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.28 2005/08/04 10:02:44 mpf Exp $	*/
d47 1
a47 1
static const char rcsid[] = "$OpenBSD: pax.c,v 1.28 2005/08/04 10:02:44 mpf Exp $";
d243 1
a243 1
		syswarn(1, errno, "Can't open current working directory.");
@


1.1.1.3
log
@import up-to-date pax from OpenBSD 5.1-current
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.32 2011/05/26 14:42:06 deraadt Exp $	*/
d37 14
a90 1
int	Nflag;			/* only use numeric uid and gid */
d310 1
a310 1
	char errbuf[80];
a317 2

	/* paxwarn() uses stdio; fake it as well as we can */
d319 1
a319 2
		strlcpy(errbuf, "Cpu time limit reached, cleaning up.",
		    sizeof errbuf);
d321 1
a321 3
		strlcpy(errbuf, "Signal caught, cleaning up.",
		    sizeof errbuf);
	(void) write(STDERR_FILENO, errbuf, strlen(errbuf));
d323 2
a324 2
	ar_close();			/* XXX signal race */
	proc_dir();			/* XXX signal race */
d326 2
a327 2
		atdir_end();		/* XXX signal race */
	_exit(1);
d402 1
a402 1
	if ((sigaction(SIGHUP, &n_hand, &o_hand) < 0) ||
d407 1
a407 1
	if ((sigaction(SIGTERM, &n_hand, &o_hand) < 0) ||
d412 1
a412 1
	if ((sigaction(SIGINT, &n_hand, &o_hand) < 0) ||
d417 1
a417 1
	if ((sigaction(SIGQUIT, &n_hand, &o_hand) < 0) ||
d422 1
a422 1
	if ((sigaction(SIGXCPU, &n_hand, &o_hand) < 0) ||
@


1.1.1.4
log
@Import latest OpenBSD paxtar
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.33 2012/04/19 04:26:46 deraadt Exp $	*/
d308 1
a308 1
		strlcpy(errbuf, "CPU time limit reached, cleaning up.\n",
d311 1
a311 1
		strlcpy(errbuf, "Signal caught, cleaning up.\n",
@


1.1.1.5
log
@pull newer paxtar from OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.44 2015/12/16 01:39:11 tb Exp $	*/
d37 1
d39 1
a50 2
#include <stdio.h>

d92 1
a95 1
int	listfd = STDERR_FILENO;	/* fd matching listf, for sighandler output */
d228 1
a228 1
	cwdfd = open(".", O_RDONLY | O_CLOEXEC);
a259 17
	 * pmode needs to restore setugid bits when extracting or copying,
	 * so can't pledge at all then.
	 */
	if (pmode == 0 || (act != EXTRACT && act != COPY)) {
		if (pledge("stdio rpath wpath cpath dpath fattr getpw ioctl proc exec",
		    NULL) == -1)
			err(1, "pledge");

		/* Copy mode, or no gzip -- don't need to fork/exec. */
		if (gzip_program == NULL || act == COPY) {
			if (pledge("stdio rpath wpath fattr cpath getpw ioctl",
			    NULL) == -1)
				err(1, "pledge");
		}
	}

	/*
d301 2
a302 1
	 * or any dirs we may have read.
d304 1
d308 1
a308 1
		strlcpy(errbuf, "\nCPU time limit reached, cleaning up.\n",
d311 1
a311 1
		strlcpy(errbuf, "\nSignal caught, cleaning up.\n",
d315 2
a316 3
	ar_close(1);
	sltab_process(1);
	proc_dir(1);
d318 1
a318 1
		atdir_end();
a322 19
 * setup_sig()
 *	set a signal to be caught, but only if it isn't being ignored already
 */

static int
setup_sig(int sig, const struct sigaction *n_hand)
{
	struct sigaction o_hand;

	if (sigaction(sig, NULL, &o_hand) < 0)
		return (-1);

	if (o_hand.sa_handler == SIG_IGN)
		return (0);

	return (sigaction(sig, n_hand, NULL));
}

/*
d333 1
d370 7
a388 4

	/* snag the fd to be used from the signal handler */
	listfd = fileno(listf);

d394 23
a416 5
	if (setup_sig(SIGHUP,  &n_hand) ||
	    setup_sig(SIGTERM, &n_hand) ||
	    setup_sig(SIGINT,  &n_hand) ||
	    setup_sig(SIGQUIT, &n_hand) ||
	    setup_sig(SIGXCPU, &n_hand))
d420 2
a421 2
	if ((sigaction(SIGPIPE, &n_hand, NULL) < 0) ||
	    (sigaction(SIGXFSZ, &n_hand, NULL) < 0))
@


1.1.1.6
log
@revert the import; we’ll just backport the CVE fixes, for now ☹
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.33 2012/04/19 04:26:46 deraadt Exp $	*/
a36 1
#include <stdio.h>
a37 1
#include <sys/param.h>
d49 2
a91 1
char	*ltmfrmt;		/* -v locale time format (if any) */
d95 1
d228 1
a228 1
	cwdfd = open(".", O_RDONLY);
d260 17
d318 1
a318 2
	 * or any dirs we may have read. Set vflag and vfpart so the user
	 * will clearly see the message on a line by itself.
a319 1
	vflag = vfpart = 1;
d323 1
a323 1
		strlcpy(errbuf, "CPU time limit reached, cleaning up.\n",
d326 1
a326 1
		strlcpy(errbuf, "Signal caught, cleaning up.\n",
d330 3
a332 2
	ar_close();			/* XXX signal race */
	proc_dir();			/* XXX signal race */
d334 1
a334 1
		atdir_end();		/* XXX signal race */
d339 19
a367 1
	struct sigaction o_hand;
a403 7
	 * Handle posix locale
	 *
	 * set user defines time printing format for -v option
	 */
	ltmfrmt = getenv("LC_TIME");

	/*
d416 4
d425 5
a429 23
	if ((sigaction(SIGHUP, &n_hand, &o_hand) < 0) ||
	    (o_hand.sa_handler == SIG_IGN) &&
	    (sigaction(SIGHUP, &o_hand, &o_hand) < 0))
		goto out;

	if ((sigaction(SIGTERM, &n_hand, &o_hand) < 0) ||
	    (o_hand.sa_handler == SIG_IGN) &&
	    (sigaction(SIGTERM, &o_hand, &o_hand) < 0))
		goto out;

	if ((sigaction(SIGINT, &n_hand, &o_hand) < 0) ||
	    (o_hand.sa_handler == SIG_IGN) &&
	    (sigaction(SIGINT, &o_hand, &o_hand) < 0))
		goto out;

	if ((sigaction(SIGQUIT, &n_hand, &o_hand) < 0) ||
	    (o_hand.sa_handler == SIG_IGN) &&
	    (sigaction(SIGQUIT, &o_hand, &o_hand) < 0))
		goto out;

	if ((sigaction(SIGXCPU, &n_hand, &o_hand) < 0) ||
	    (o_hand.sa_handler == SIG_IGN) &&
	    (sigaction(SIGXCPU, &o_hand, &o_hand) < 0))
d433 2
a434 2
	if ((sigaction(SIGPIPE, &n_hand, &o_hand) < 0) ||
	    (sigaction(SIGXFSZ, &n_hand, &o_hand) < 0))
@


1.1.1.7
log
@backport OpenBSD pax erratum, more specifically:

• directory bug, symlinks with -C bug
• escaping with .. and symlinks
• tar without -P
• validate directories touched in the cleanup phase
@
text
@a315 1
	sltab_process(1);
@


1.1.1.8
log
@merge what OpenBSD did between our last cherry-pick and today minus one commit

(“Use the new libc uid_from_user() and gid_from_group() instead of
  the pax-specific functions in cache.c” is ignored, for now)
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.51 2017/12/08 17:04:14 deraadt Exp $	*/
d297 2
@


1.1.1.9
log
@Import latest OpenBSD paxtar, unmodified, into vendor branch
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.52 2018/09/13 12:33:43 millert Exp $	*/
d37 1
d39 1
d41 1
a49 1
#include <grp.h>
a50 3
#include <pwd.h>
#include <stdio.h>

d92 1
a93 1
enum op_mode op_mode;		/* what program are we acting as? */
a95 1
int	listfd = STDERR_FILENO;	/* fd matching listf, for sighandler output */
d228 1
a228 1
	cwdfd = open(".", O_RDONLY | O_CLOEXEC);
a252 6
	 * keep passwd and group files open for faster lookups.
	 */
	setpassent(1);
	setgroupent(1);

	/*
a259 17
	 * pmode needs to restore setugid bits when extracting or copying,
	 * so can't pledge at all then.
	 */
	if (pmode == 0 || (act != EXTRACT && act != COPY)) {
		if (pledge("stdio rpath wpath cpath fattr dpath getpw proc exec tape",
		    NULL) == -1)
			err(1, "pledge");

		/* Copy mode, or no gzip -- don't need to fork/exec. */
		if (gzip_program == NULL || act == COPY) {
			if (pledge("stdio rpath wpath cpath fattr dpath getpw tape",
			    NULL) == -1)
				err(1, "pledge");
		}
	}

	/*
d299 2
a300 1
	 * or any dirs we may have read.
d302 1
d306 2
a307 1
		dprintf(STDERR_FILENO, "\nCPU time limit reached, cleaning up.\n");
d309 3
a311 1
		dprintf(STDERR_FILENO, "\nSignal caught, cleaning up.\n");
d313 1
a313 1
	ar_close(1);
d315 1
a315 1
	proc_dir(1);
d317 1
a317 1
		atdir_end();
a321 19
 * setup_sig()
 *	set a signal to be caught, but only if it isn't being ignored already
 */

static int
setup_sig(int sig, const struct sigaction *n_hand)
{
	struct sigaction o_hand;

	if (sigaction(sig, NULL, &o_hand) < 0)
		return (-1);

	if (o_hand.sa_handler == SIG_IGN)
		return (0);

	return (sigaction(sig, n_hand, NULL));
}

/*
d332 1
d369 7
a387 4

	/* snag the fd to be used from the signal handler */
	listfd = fileno(listf);

d393 23
a415 5
	if (setup_sig(SIGHUP,  &n_hand) ||
	    setup_sig(SIGTERM, &n_hand) ||
	    setup_sig(SIGINT,  &n_hand) ||
	    setup_sig(SIGQUIT, &n_hand) ||
	    setup_sig(SIGXCPU, &n_hand))
d419 2
a420 2
	if ((sigaction(SIGPIPE, &n_hand, NULL) < 0) ||
	    (sigaction(SIGXFSZ, &n_hand, NULL) < 0))
@


1.1.1.9.2.1
log
@Wrangle the OpenBSD branch into shape as starting point:

• Revert “Use the new libc uid_from_user() and gid_from_group()
  instead of the pax-specific functions in cache.c” (revisit later)
• fix MAX_TIME_T (plain wrong), mirtoconf later
• drop all NOCPIO
• Revert “Replace name_{uid,gid}() with the libc routines
  user_from_uid() and group_from_gid()”
@
text
@a253 1
#ifdef HAVE_SETPASSENT
a258 1
#endif
@


1.1.1.9.2.2
log
@a little KNF: sort the includes
@
text
@d38 1
d40 5
a44 1
#include <sys/stat.h>
a45 1
#include <errno.h>
a49 1
#include <signal.h>
a50 3
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
a53 1

@


1.1.1.9.2.3
log
@extremely rudimentary conversion to mirtoconf, doesn’t even build yet
@
text
@a37 1
#if HAVE_SYS_RESOURCE_H
a38 1
#endif
a42 1
#if HAVE_GRP_H
a43 2
#endif
#if HAVE_PATHS_H
a44 1
#endif
a49 3
#if HAVE_STRINGS_H
#include <strings.h>
#endif
d255 1
a255 1
#if HAVE_SETPGENT
a269 1
#if HAVE_PLEDGE
a285 1
#endif
@


1.1.1.9.2.4
log
@do the ‘c’s
@
text
@d165 1
a165 1
 *	too small for large filesystems, such as inode number storage), use
d169 1
a169 1
 *	formats on large filesystems.
d310 1
a310 1
			errx(1, "cannot gzip while appending");
@


1.1.1.9.2.5
log
@merge ‘g’ and switch to a global “now”
@
text
@a109 1
time_t	 now;			/* time of program start */
a236 2
	now = time(NULL);

@


1.1.1.9.2.6
log
@this would be most of the ‘o’s (some more strtonum for later)
@
text
@d88 1
@


1.1.1.9.2.7
log
@pax without .h, modulo setpgent and O_CLOEXEC
@
text
@a4 2
 * Copyright (c) 2012, 2015, 2016, 2017
 *	mirabilos <m@@mirbsd.org>
d73 1
a73 1
int	act = ERROR;		/* read/write/append/copy */
a83 1
int	Vflag = 0;		/* print a dot for each file processed */
d92 1
a92 1
int	vfpart = 0;		/* is partial verbose output in progress */
d102 1
a102 1
const char *argv0;		/* root of argv[0] */
d105 1
a105 1
FILE	*listf;			/* fp to print file list to (default stderr) */
d234 1
a234 1
	const char *tmpdir;
a236 3
	/* may not be a constant, thus initialising early */
	listf = stderr;

a299 7
	/* make list fd independent and line-buffered */
	if (!(listf = fdopen((listfd = dup(fileno(listf))), "wb"))) {
		syswarn(1, errno, "Can't open list file descriptor");
		return (exit_val);
	}
	setlinebuf(listf);

d311 2
a312 2
		if (compress_program != NULL)
			errx(1, "cannot compress while appending");
a318 3
		/* for ar_io.c etc. */
		act = LIST;
		/* FALLTHROUGH */
d339 2
a340 3
	 * Restore modes and times for any dirs we may have created
	 * or any dirs we may have read. Set vflag and vfpart so the
	 * user will clearly see the message on a line by itself.
a341 1
	vflag = vfpart = 1;
a345 2
	else if (!which_sig)
		dprintf(STDERR_FILENO, "\nCowardly giving up, trying to clean up.\n");
a416 1
#ifdef RLIMIT_RSS
a420 1
#endif
d425 1
a425 1
	 * deal with any file size limit through failed writes. CPU time
d455 1
a455 1
	return (0);
d457 1
a457 1
 out:
d459 1
a459 1
	return (-1);
@


1.1.1.9.2.8
log
@solution for rare open flags, also uses O_BINARY like in mksh
@
text
@d248 1
a248 1
	cwdfd = binopen2(BO_CLEXEC, ".", O_RDONLY);
a310 3
	if (fcntl(listfd, F_SETFD, FD_CLOEXEC) == -1)
		syswarn(0, errno, "%s on list file descriptor",
		    "Failed to set the close-on-exec flag");
@


1.1.1.9.2.9
log
@sprinkle more missing includes
@
text
@a39 8
#if HAVE_BOTH_TIME_H
#include <sys/time.h>
#include <time.h>
#elif HAVE_SYS_TIME_H
#include <sys/time.h>
#elif HAVE_TIME_H
#include <time.h>
#endif
@


