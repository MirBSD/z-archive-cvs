head	1.31;
access;
symbols
	paxmirabilis-20190825:1.31
	paxmirabilis-20190224:1.31
	paxmirabilis-20190210:1.30
	npax:1.1.1.11.0.2
	cvs-20181212:1.1.1.11
	paxmirabilis-20171021:1.25
	paxmirabilis-20161104:1.23
	paxmirabilis-20161031:1.23
	paxmirabilis-20161025:1.23
	paxmirabilis-20160306:1.22
	cvs-201603041945:1.1.1.5
	paxmirabilis-20151013:1.20
	paxmirabilis-20140703:1.19
	paxmirabilis-20120606:1.18
	paxmirabilis-20120605:1.18
	cvs-201206051745:1.1.1.4
	paxmirabilis-20120520:1.17
	paxmirabilis-20120216:1.16
	paxmirabilis-20120212:1.16
	cvs-201202112230:1.1.1.4
	paxmirabilis-20110817:1.14
	MIRBSD_10:1.12.0.2
	MIRBSD_10_BASE:1.12
	cvs-200710231945:1.1.1.3
	cvs-200606232242:1.1.1.3
	MIRBSD_9_BASE:1.7
	MIRBSD_8:1.6.0.2
	MIRBSD_8_BASE:1.6
	cvs-200507211800:1.1.1.2
	cvs-200504291700:1.1.1.2
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2019.02.23.23.42.22;	author tg;	state Exp;
branches;
next	1.30;
commitid	1005C71DA6B03DFD0A5;

1.30
date	2019.02.10.21.50.07;	author tg;	state Exp;
branches;
next	1.29;
commitid	1005C609C8F43A9BDCB;

1.29
date	2018.12.13.07.09.10;	author tg;	state Exp;
branches;
next	1.28;
commitid	1005C1205A44B32AFA4;

1.28
date	2018.12.12.18.08.43;	author tg;	state Exp;
branches;
next	1.27;
commitid	1005C114EA81986F5EC;

1.27
date	2018.12.12.00.23.05;	author tg;	state Exp;
branches;
next	1.26;
commitid	1005C1054FE750D63F3;

1.26
date	2018.12.12.00.09.27;	author tg;	state Exp;
branches;
next	1.25;
commitid	1005C1051C27816C858;

1.25
date	2017.08.08.16.42.49;	author tg;	state Exp;
branches;
next	1.24;
commitid	1005989EA23421E2092;

1.24
date	2017.08.07.20.10.14;	author tg;	state Exp;
branches;
next	1.23;
commitid	1005988C69344442E37;

1.23
date	2016.10.25.18.57.54;	author tg;	state Exp;
branches;
next	1.22;
commitid	100580FAB4B20AD4FA2;

1.22
date	2016.03.06.14.41.32;	author tg;	state Exp;
branches;
next	1.21;
commitid	10056DC41B15356B336;

1.21
date	2016.03.06.13.47.49;	author tg;	state Exp;
branches;
next	1.20;
commitid	10056DC351700BAF310;

1.20
date	2015.10.13.20.18.50;	author tg;	state Exp;
branches;
next	1.19;
commitid	100561D673C2A515BC8;

1.19
date	2014.07.03.17.52.11;	author tg;	state Exp;
branches;
next	1.18;
commitid	10053B598643F05010F;

1.18
date	2012.06.05.18.22.56;	author tg;	state Exp;
branches;
next	1.17;
commitid	1004FCE4E961DE91080;

1.17
date	2012.05.20.16.13.17;	author tg;	state Exp;
branches;
next	1.16;
commitid	1004FB918314D2FECC0;

1.16
date	2012.02.12.00.42.28;	author tg;	state Exp;
branches;
next	1.15;
commitid	1004F370B09500A1E8B;

1.15
date	2012.02.12.00.27.16;	author tg;	state Exp;
branches;
next	1.14;
commitid	1004F3707786D20BF4A;

1.14
date	2009.10.27.18.47.26;	author tg;	state Exp;
branches;
next	1.13;
commitid	1004AE74055714A6EEB;

1.13
date	2008.10.29.17.34.48;	author tg;	state Exp;
branches;
next	1.12;
commitid	10049089E5F758E2CFE;

1.12
date	2007.02.17.04.52.40;	author tg;	state Exp;
branches;
next	1.11;
commitid	10045D68A2D54E2C558;

1.11
date	2007.02.17.04.22.23;	author tg;	state Exp;
branches;
next	1.10;
commitid	10045D6830A25A501A2;

1.10
date	2007.02.17.04.18.29;	author tg;	state Exp;
branches;
next	1.9;
commitid	10045D6820F211DD8C3;

1.9
date	2007.02.17.04.16.09;	author tg;	state Exp;
branches;
next	1.8;
commitid	10045D6817E17DB1AB4;

1.8
date	2007.02.17.04.03.19;	author tg;	state Exp;
branches;
next	1.7;
commitid	10045D67E60573600F7;

1.7
date	2006.06.23.23.03.56;	author tg;	state Exp;
branches;
next	1.6;
commitid	100449C736877C98FFB;

1.6
date	2005.11.10.20.27.48;	author tg;	state Exp;
branches;
next	1.5;
commitid	16eb4373ad4947cb;

1.5
date	2005.04.29.18.34.44;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2005.04.13.21.01.00;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2005.04.13.20.03.35;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2005.02.28.20.21.27;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.22.06;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.22.06;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.29.17.05.15;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.06.23.23.00.13;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	100449C727D31170AA3;

1.1.1.4
date	2012.02.11.22.47.21;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	1004F36F008225F3522;

1.1.1.5
date	2016.03.04.19.46.09;	author tg;	state Exp;
branches;
next	1.1.1.6;
commitid	10056D9E61429EE6550;

1.1.1.6
date	2016.03.04.20.55.00;	author tg;	state Exp;
branches;
next	1.1.1.7;
commitid	10056D9F62E152ECBA5;

1.1.1.7
date	2016.03.06.13.29.54;	author tg;	state Exp;
branches;
next	1.1.1.8;
commitid	10056DC30960F3F5FA0;

1.1.1.8
date	2016.10.25.18.46.09;	author tg;	state Exp;
branches;
next	1.1.1.9;
commitid	100580FA88137705D31;

1.1.1.9
date	2017.08.08.16.34.18;	author tg;	state Exp;
branches;
next	1.1.1.10;
commitid	1005989E8201BF2190E;

1.1.1.10
date	2018.12.12.00.15.04;	author tg;	state Exp;
branches;
next	1.1.1.11;
commitid	1005C1052FA5E745A2C;

1.1.1.11
date	2018.12.12.00.24.23;	author tg;	state Exp;
branches
	1.1.1.11.2.1;
next	;
commitid	1005C1055452C78F9E4;

1.1.1.11.2.1
date	2018.12.12.00.54.15;	author tg;	state Exp;
branches;
next	1.1.1.11.2.2;
commitid	1005C105C48612B0194;

1.1.1.11.2.2
date	2018.12.12.01.05.51;	author tg;	state Exp;
branches;
next	1.1.1.11.2.3;
commitid	1005C105F03799CC958;

1.1.1.11.2.3
date	2018.12.12.03.13.31;	author tg;	state Exp;
branches;
next	1.1.1.11.2.4;
commitid	1005C107CE315DC51F3;

1.1.1.11.2.4
date	2018.12.12.04.01.21;	author tg;	state Exp;
branches;
next	1.1.1.11.2.5;
commitid	1005C108824649A94FE;

1.1.1.11.2.5
date	2018.12.12.06.03.11;	author tg;	state Exp;
branches;
next	1.1.1.11.2.6;
commitid	1005C10A4B12E5998CE;

1.1.1.11.2.6
date	2018.12.12.06.44.39;	author tg;	state Exp;
branches;
next	1.1.1.11.2.7;
commitid	1005C10AE69584968B6;

1.1.1.11.2.7
date	2018.12.12.06.47.37;	author tg;	state Exp;
branches;
next	1.1.1.11.2.8;
commitid	1005C10AF1965896ABA;

1.1.1.11.2.8
date	2018.12.12.07.03.47;	author tg;	state Exp;
branches;
next	1.1.1.11.2.9;
commitid	1005C10B2E50CAEB848;

1.1.1.11.2.9
date	2018.12.12.07.18.32;	author tg;	state Exp;
branches;
next	1.1.1.11.2.10;
commitid	1005C10B6607EEDC388;

1.1.1.11.2.10
date	2018.12.12.07.23.29;	author tg;	state Exp;
branches;
next	1.1.1.11.2.11;
commitid	1005C10B789543AAF2D;

1.1.1.11.2.11
date	2018.12.12.07.47.49;	author tg;	state Exp;
branches;
next	1.1.1.11.2.12;
commitid	1005C10BD3146450729;

1.1.1.11.2.12
date	2018.12.12.08.18.58;	author tg;	state Exp;
branches;
next	1.1.1.11.2.13;
commitid	1005C10C48822E4378D;

1.1.1.11.2.13
date	2018.12.12.08.32.29;	author tg;	state Exp;
branches;
next	1.1.1.11.2.14;
commitid	1005C10C7B32275D60D;

1.1.1.11.2.14
date	2018.12.12.08.42.11;	author tg;	state Exp;
branches;
next	1.1.1.11.2.15;
commitid	1005C10C9F510EE2367;

1.1.1.11.2.15
date	2018.12.12.08.48.14;	author tg;	state Exp;
branches;
next	1.1.1.11.2.16;
commitid	1005C10CB641D052FC1;

1.1.1.11.2.16
date	2018.12.12.10.41.26;	author tg;	state Exp;
branches;
next	1.1.1.11.2.17;
commitid	1005C10E5E87909E6FC;

1.1.1.11.2.17
date	2018.12.12.10.44.42;	author tg;	state Exp;
branches;
next	1.1.1.11.2.18;
commitid	1005C10E68E653DA8DC;

1.1.1.11.2.18
date	2018.12.12.15.00.24;	author tg;	state Exp;
branches;
next	1.1.1.11.2.19;
commitid	1005C11229872472EAF;

1.1.1.11.2.19
date	2018.12.12.16.24.27;	author tg;	state Exp;
branches;
next	;
commitid	1005C11364A797CBA33;


desc
@@


1.31
log
@don’t return(int); in a function returning void, duh…
@
text
@/*	$OpenBSD: file_subs.c,v 1.53 2017/01/21 08:17:06 krw Exp $	*/
/*	$NetBSD: file_subs.c,v 1.4 1995/03/21 09:07:18 cgd Exp $	*/

/*-
 * Copyright (c) 2007, 2008, 2009, 2012, 2014, 2016, 2018, 2019
 *	mirabilos <m@@mirbsd.org>
 * Copyright (c) 2018
 *	Jonathan de Boyne Pollard <J.deBoynePollard-newsgroups@@NTLWorld.COM>
 *	mirabilos <t.glaser@@tarent.de>
 * Copyright (c) 2011
 *	Svante Signell <svante.signell@@telia.com>
 * Copyright (c) 1992 Keith Muller.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/stat.h>
#if HAVE_BOTH_TIME_H
#include <sys/time.h>
#include <time.h>
#elif HAVE_SYS_TIME_H
#include <sys/time.h>
#elif HAVE_TIME_H
#include <time.h>
#endif
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if HAVE_STRINGS_H
#include <strings.h>
#endif
#include <unistd.h>
#if HAVE_UTIME_H
#include <utime.h>
#endif

#include "pax.h"
#define EXTERN
#include "ftimes.h"
#undef EXTERN
#include "extern.h"

__RCSID("$MirOS: src/bin/pax/file_subs.c,v 1.30 2019/02/10 21:50:07 tg Exp $");

/*
 * routines that deal with file operations such as: creating, removing;
 * and setting access modes, uid/gid and times of files
 */

#if HAVE_FUTIMENS || HAVE_FUTIMES
#define PAX_FSET_FTIME
#endif

static int mk_link(char *, struct stat *, char *, int);
#ifdef PAX_FSET_FTIME
static void fset_ftime(const char *, int, const struct stat *, int);
#endif

/*
 * file_creat()
 *	Create and open a file.
 * Return:
 *	file descriptor or -1 for failure
 */

int
file_creat(ARCHD *arcn)
{
	int fd = -1;
	mode_t file_mode;
	int oerrno;

	/*
	 * Assume file doesn't exist, so just try to create it, most times this
	 * works. We have to take special handling when the file does exist. To
	 * detect this, we use O_EXCL. For example when trying to create a
	 * file and a character device or FIFO exists with the same name, we
	 * can accidently open the device by mistake (or block waiting to open).
	 * If we find that the open has failed, then spend the effort to
	 * figure out why. This strategy was found to have better average
	 * performance in common use than checking the file (and the path)
	 * first with lstat.
	 */
	file_mode = arcn->sb.st_mode & FILEBITS;
	if ((fd = binopen3(0, arcn->name, O_WRONLY | O_CREAT | O_EXCL,
	    file_mode)) >= 0)
		return (fd);

	/*
	 * the file seems to exist. First we try to get rid of it (found to be
	 * the second most common failure when traced). If this fails, only
	 * then we go to the expense to check and create the path to the file
	 */
	if (unlnk_exist(arcn->name, arcn->type) != 0)
		return(-1);

	for (;;) {
		/*
		 * try to open it again, if this fails, check all the nodes in
		 * the path and give it a final try. if chk_path() finds that
		 * it cannot fix anything, we will skip the last attempt
		 */
		if ((fd = binopen3(0, arcn->name, O_WRONLY | O_CREAT | O_TRUNC,
		    file_mode)) >= 0)
			break;
		oerrno = errno;
		if (nodirs || chk_path(arcn->name,arcn->sb.st_uid,arcn->sb.st_gid) < 0) {
			syswarn(1, oerrno, "Unable to create %s", arcn->name);
			return(-1);
		}
	}
	return(fd);
}

/*
 * file_close()
 *	Close file descriptor to a file just created by pax. Sets modes,
 *	ownership and times as required.
 * Return:
 *	0 for success, -1 for failure
 */

void
file_close(ARCHD *arcn, int fd)
{
	int res = 0;

	if (fd < 0)
		return;

	/*
	 * set owner/groups first as this may strip off mode bits we want
	 * then set file permission modes. Then set file access and
	 * modification times.
	 */
	if (pids)
		res = fset_ids(arcn->name, fd, arcn->sb.st_uid,
		    arcn->sb.st_gid);

	/*
	 * IMPORTANT SECURITY NOTE:
	 * if not preserving mode or we cannot set uid/gid, then PROHIBIT
	 * set uid/gid bits
	 */
	if (!pmode || res)
		arcn->sb.st_mode &= ~(SETBITS);
	if (pmode)
		fset_pmode(arcn->name, fd, arcn->sb.st_mode);
#ifdef PAX_FSET_FTIME
	if (patime || pmtime)
		fset_ftime(arcn->name, fd, &arcn->sb, 0);
#endif
	if (close(fd) < 0)
		syswarn(0, errno, "Unable to close file descriptor on %s",
		    arcn->name);
}

/*
 * lnk_creat()
 *	Create a hard link to arcn->ln_name from arcn->name. arcn->ln_name
 *	must exist;
 * Return:
 *	fd+2 if data should be extracted,
 *	0 if ok, 1 if we could not make the link, -1 otherwise
 */

int
lnk_creat(ARCHD *arcn, int *fdp)
{
	struct stat sb;
	int res;

	/*
	 * we may be running as root, so we have to be sure that link target
	 * is not a directory, so we lstat and check
	 */
	if (lstat(arcn->ln_name, &sb) < 0) {
		syswarn(1, errno, "Unable to link to %s from %s",
		    arcn->ln_name, arcn->name);
		return (-1);
	}

	if (S_ISDIR(sb.st_mode)) {
		paxwarn(1, "A hard link to the directory %s is not allowed",
		    arcn->ln_name);
		return(-1);
	}

	res = mk_link(arcn->ln_name, &sb, arcn->name, 0);
	if (res == 0) {
		/* check for a hardlink to a placeholder symlink */
		res = sltab_add_link(arcn->name, &sb);

		if (res < 0) {
			/* arrgh, it failed, clean up */
			unlink(arcn->name);
		}
	}

	if (fdp != NULL && res == 0 && sb.st_size == 0 && arcn->skip > 0) {
		/* request to write out file data late (broken archive) */
		if (pmode)
			set_pmode(arcn->name, 0600, /*XXX I think */ 0);
		if ((*fdp = binopen2(0, arcn->name, O_WRONLY | O_TRUNC)) == -1) {
			res = errno;
			syswarn(1, res, "Unable to re-open %s", arcn->name);
			if (pmode)
				set_pmode(arcn->name, sb.st_mode, 0);
		}
		res = 0;
	} else if (fdp != NULL)
		*fdp = -1;
	return (res);
}

/*
 * cross_lnk()
 *	Create a hard link to arcn->org_name from arcn->name. Only used in copy
 *	with the -l flag. No warning or error if this does not succeed (we will
 *	then just create the file)
 * Return:
 *	1 if copy() should try to create this file node
 *	0 if cross_lnk() ok, -1 for fatal flaw (like linking to self).
 */

int
cross_lnk(ARCHD *arcn)
{
	/*
	 * try to make a link to original file (-l flag in copy mode). make
	 * sure we do not try to link to directories in case we are running as
	 * root (and it might succeed).
	 */
	if (arcn->type == PAX_DIR)
		return(1);
	return(mk_link(arcn->org_name, &(arcn->sb), arcn->name, 1));
}

/*
 * chk_same()
 *	In copy mode if we are not trying to make hard links between the src
 *	and destinations, make sure we are not going to overwrite ourselves by
 *	accident. This slows things down a little, but we have to protect all
 *	those people who make typing errors.
 * Return:
 *	1 the target does not exist, go ahead and copy
 *	0 skip it file exists (-k) or may be the same as source file
 */

int
chk_same(ARCHD *arcn)
{
	struct stat sb;

	/*
	 * if file does not exist, return. if file exists and -k, skip it
	 * quietly
	 */
	if (lstat(arcn->name, &sb) < 0)
		return(1);
	if (kflag)
		return(0);

	/*
	 * better make sure the user does not have src == dest by mistake
	 */
	if ((arcn->sb.st_dev == sb.st_dev) && (arcn->sb.st_ino == sb.st_ino)) {
		paxwarn(1, "Unable to copy %s, file would overwrite itself",
		    arcn->name);
		return(0);
	}
	return(1);
}

/*
 * helper function to copy a symbolic link
 */

static int
mk_link_symlink(const char *to, const char *from)
{
	int cnt;
	char buf[PAXPATHLEN + 1];

	if ((cnt = readlink(to, buf, PAXPATHLEN)) < 0)
		return (-1);
	/* cf. comment in ftree.c:next_file() */
	buf[cnt] = '\0';
	return (symlink(buf, from));
}

/*
 * mk_link()
 *	try to make a hard link between two files. if ign set, we do not
 *	complain.
 * Return:
 *	0 if successful (or we are done with this file but no error, such as
 *	finding the from file exists and the user has set -k).
 *	1 when ign was set to indicates we could not make the link but we
 *	should try to copy/extract the file as that might work (and is an
 *	allowed option). -1 an error occurred.
 */

static int
mk_link(char *to, struct stat *to_sb, char *from, int ign)
{
	struct stat sb;
	int oerrno;

	/*
	 * if from file exists, it has to be unlinked to make the link. If the
	 * file exists and -k is set, skip it quietly
	 */
	if (lstat(from, &sb) == 0) {
		if (kflag)
			return(0);

		/*
		 * make sure it is not the same file, protect the user
		 */
		if ((to_sb->st_dev==sb.st_dev)&&(to_sb->st_ino == sb.st_ino)) {
			paxwarn(1, "Unable to link file %s to itself", to);
			return(-1);
		}

		/*
		 * try to get rid of the file, based on the type
		 */
		if (S_ISDIR(sb.st_mode)) {
			if (rmdir(from) < 0) {
				syswarn(1, errno, "Unable to remove %s", from);
				return(-1);
			}
			delete_dir(sb.st_dev, sb.st_ino);
		} else if (unlink(from) < 0) {
			if (!ign) {
				syswarn(1, errno, "Unable to remove %s", from);
				return(-1);
			}
			return(1);
		}
	}

	/*
	 * from file is gone (or did not exist), try to make the hard link.
	 * if it fails, check the path and try it again (if chk_path() says to
	 * try again)
	 */
	for (;;) {
#if HAVE_LINKAT
		if (linkat(AT_FDCWD, to, AT_FDCWD, from, 0) == 0)
#else
		if (link(to, from) == 0)
#endif
			break;
		oerrno = errno;
		if (S_ISLNK(to_sb->st_mode)) {
			/* just copy the symlink */
			if (mk_link_symlink(to, from) == 0)
				break;
		}
		if (!nodirs && chk_path(from, to_sb->st_uid, to_sb->st_gid) == 0)
			continue;
		/*-
		 * non-standard (via -M lncp) cross-device link handling:
		 * copy if hard link fails (but what if there are several
		 * links for the same file mixed between several devices?
		 * this code copies for all non-original devices, instead
		 * of tracking them and linking between them on their re-
		 * spective target device)
		 */
		if (oerrno == EXDEV && (anonarch & ANON_LNCP)) {
			int fdsrc, fddest;
			ARCHD tarcn;

			if ((fdsrc = binopen3(0, to, O_RDONLY, 0)) < 0) {
				if (!ign)
					syswarn(1, errno,
					    "Unable to open %s to read", to);
				goto lncp_failed;
			}
			strlcpy(tarcn.name, from, sizeof(tarcn.name));
			memcpy(&tarcn.sb, to_sb, sizeof(struct stat));
			tarcn.type = PAX_REG;	/* XXX */
			tarcn.org_name = to;
			if ((fddest = file_creat(&tarcn)) < 0) {
				rdfile_close(&tarcn, &fdsrc);
				goto lncp_failed;
			}
			cp_file(&tarcn, fdsrc, fddest);
			file_close(&tarcn, fddest);
			rdfile_close(&tarcn, &fdsrc);
			/* file copied successfully, continue on */
			break;
		}
		if (!ign) {
 lncp_failed:
			syswarn(1, oerrno, "Unable to link to %s from %s",
			    to, from);
			return (-1);
		}
		return (1);
	}

	/*
	 * all right the link was made
	 */
	return (0);
}

/*
 * node_creat()
 *	create an entry in the filesystem (other than a file or hard link).
 *	If successful, sets uid/gid modes and times as required.
 * Return:
 *	0 if ok, -1 otherwise
 */

int
node_creat(ARCHD *arcn)
{
	int res;
	int ign = 0;
	int oerrno;
	int pass = 0;
	mode_t file_mode;
	struct stat sb;
	char *allocd = NULL;
	char *nm = arcn->name;
	int len, defer_pmode = 0;

	/*
	 * create node based on type, if that fails try to unlink the node and
	 * try again. finally check the path and try again. As noted in the
	 * file and link creation routines, this method seems to exhibit the
	 * best performance in general use workloads.
	 */
	file_mode = arcn->sb.st_mode & FILEBITS;

	for (;;) {
		switch (arcn->type) {
		case PAX_DIR:
			/*
			 * If -h (or -L) was given in tar-mode, follow the
			 * potential symlink chain before trying to create the
			 * directory.
			 */
			if (op_mode == OP_TAR && Lflag) {
				while (lstat(nm, &sb) == 0 &&
				    S_ISLNK(sb.st_mode)) {
					char *target = malloc(sb.st_size + 1);
					if (target == NULL) {
						free(allocd);
						oerrno = ENOMEM;
						syswarn(1, oerrno,
						    "Out of memory");
						return (-1);
					}
					len = readlink(nm, target,
					    sb.st_size + 1);
					if (len == -1) {
						syswarn(0, errno,
						   "cannot follow symlink %s in chain for %s",
						    nm, arcn->name);
						res = -1;
						goto badlink;
					}
					target[len] = '\0';
					nm = target;
					free(allocd);
					allocd = target;
				}
			}
			res = mkdir(nm, file_mode);

 badlink:
			if (ign)
				res = 0;
			break;
		case PAX_CHR:
			file_mode |= S_IFCHR;
			res = mknod(nm, file_mode, arcn->sb.st_rdev);
			break;
		case PAX_BLK:
			file_mode |= S_IFBLK;
			res = mknod(nm, file_mode, arcn->sb.st_rdev);
			break;
		case PAX_FIF:
			res = mkfifo(nm, file_mode);
			break;
		case PAX_SCK:
			/*
			 * Skip sockets, operation has no meaning under BSD
			 */
			paxwarn(0,
			    "%s skipped. Sockets cannot be copied or extracted",
			    nm);
			free(allocd);
			return (-1);
		case PAX_SLK:
			if (arcn->ln_name[0] != '/' &&
			    !has_dotdot(arcn->ln_name))
				res = symlink(arcn->ln_name, nm);
			else {
				/*
				 * absolute symlinks and symlinks with ".."
				 * have to be deferred to prevent the archive
				 * from bootstrapping itself to outside the
				 * working directory.
				 */
				res = sltab_add_sym(nm, arcn->ln_name,
				    arcn->sb.st_mode);
				if (res == 0)
					defer_pmode = 1;
			}
			break;
		case PAX_CTG:
		case PAX_HLK:
		case PAX_HRG:
		case PAX_REG:
		default:
			/*
			 * we should never get here
			 */
			paxwarn(0, "%s has an unknown file type, skipping",
			    nm);
			free(allocd);
			return (-1);
		}

		/*
		 * if we were able to create the node break out of the loop,
		 * otherwise try to unlink the node and try again. if that
		 * fails check the full path and try a final time.
		 */
		if (res == 0)
			break;

		/*
		 * we failed to make the node
		 */
		oerrno = errno;
		if ((ign = unlnk_exist(nm, arcn->type)) < 0) {
			free(allocd);
			return (-1);
		}

		if (++pass <= 1)
			continue;

		if (nodirs || chk_path(nm,arcn->sb.st_uid,arcn->sb.st_gid) < 0) {
			syswarn(1, oerrno, "Unable to create %s", nm);
			free(allocd);
			return (-1);
		}
	}

	/*
	 * we were able to create the node. set uid/gid, modes and times
	 */
	if (pids)
		res = set_ids(nm, arcn->sb.st_uid, arcn->sb.st_gid,
		    arcn->type == PAX_SLK);
	else
		res = 0;

	/*
	 * IMPORTANT SECURITY NOTE:
	 * if not preserving mode or we cannot set uid/gid, then PROHIBIT any
	 * set uid/gid bits
	 */
	if (!pmode || res)
		arcn->sb.st_mode &= ~(SETBITS);
	if (pmode && !defer_pmode)
		set_pmode(nm, arcn->sb.st_mode, arcn->type == PAX_SLK);

	if (arcn->type == PAX_DIR && op_mode != OP_CPIO) {
		/*
		 * Dirs must be processed again at end of extract to set times
		 * and modes to agree with those stored in the archive. However
		 * to allow extract to continue, we may have to also set owner
		 * rights. This allows nodes in the archive that are children
		 * of this directory to be extracted without failure. Both time
		 * and modes will be fixed after the entire archive is read and
		 * before pax exits.  To do that safely, we want the dev+ino
		 * of the directory we created.
		 */
		if (lstat(nm, &sb) < 0) {
			syswarn(0, errno, "Unable to stat %s", nm);
		} else if (access(nm, R_OK | W_OK | X_OK) < 0) {
			/*
			 * We have to add rights to the dir, so we make
			 * sure to restore the mode. The mode must be
			 * restored AS CREATED and not as stored if
			 * pmode is not set.
			 */
			set_pmode(nm,
			    ((sb.st_mode & FILEBITS) | S_IRWXU), 0);
			if (!pmode)
				arcn->sb.st_mode = sb.st_mode;

			/*
			 * we have to force the mode to what was set
			 * here, since we changed it from the default
			 * as created.
			 */
			arcn->sb.st_dev = sb.st_dev;
			arcn->sb.st_ino = sb.st_ino;
			add_dir(nm, &(arcn->sb), 1);
		} else if (pmode || patime || pmtime) {
			arcn->sb.st_dev = sb.st_dev;
			arcn->sb.st_ino = sb.st_ino;
			add_dir(nm, &(arcn->sb), 0);
		}
	} else if (patime || pmtime)
		set_ftime(nm, &arcn->sb, 0, arcn->type == PAX_SLK);
	free(allocd);
	return (0);
}

/*
 * unlnk_exist()
 *	Remove node from filesystem with the specified name. We pass the type
 *	of the node that is going to replace it. When we try to create a
 *	directory and find that it already exists, we allow processing to
 *	continue as proper modes etc will always be set for it later on.
 * Return:
 *	0 is ok to proceed, no file with the specified name exists
 *	-1 we were unable to remove the node, or we should not remove it (-k)
 *	1 we found a directory and we were going to create a directory.
 */

int
unlnk_exist(char *name, int type)
{
	struct stat sb;

	/*
	 * the file does not exist, or -k we are done
	 */
	if (lstat(name, &sb) < 0)
		return(0);
	if (kflag)
		return(-1);

	if (S_ISDIR(sb.st_mode)) {
		/*
		 * try to remove a directory, if it fails and we were going to
		 * create a directory anyway, tell the caller (return a 1)
		 */
		if (rmdir(name) < 0) {
			if (type == PAX_DIR)
				return(1);
			syswarn(1,errno,"Unable to remove directory %s", name);
			return(-1);
		}
		delete_dir(sb.st_dev, sb.st_ino);
		return(0);
	}

	/*
	 * try to get rid of all non-directory type nodes
	 */
	if (unlink(name) < 0) {
		syswarn(1, errno, "Unable to remove %s", name);
		return(-1);
	}
	return(0);
}

/*
 * chk_path()
 *	We were trying to create some kind of node in the filesystem and it
 *	failed. chk_path() makes sure the path up to the node exists and is
 *	writeable. When we have to create a directory that is missing along the
 *	path somewhere, the directory we create will be set to the same
 *	uid/gid as the file has (when uid and gid are being preserved).
 *	NOTE: this routine is a real performance loss. It is only used as a
 *	last resort when trying to create entries in the filesystem.
 * Return:
 *	-1 when it could find nothing it is allowed to fix.
 *	0 otherwise
 */

int
chk_path(char *name, uid_t st_uid, gid_t st_gid)
{
	char *spt = name;
	char *next;
	struct stat sb;
	int retval = -1;

	/*
	 * watch out for paths with nodes stored directly in / (e.g. /bozo)
	 */
	while (*spt == '/')
		++spt;

	for (;;) {
		/*
		 * work forward from the first / and check each part of the path
		 */
		spt = strchr(spt, '/');
		if (spt == NULL)
			break;

		/*
		 * skip over duplicate slashes; stop if there're only
		 * trailing slashes left
		 */
		next = spt + 1;
		while (*next == '/')
			next++;
		if (*next == '\0')
			break;

		*spt = '\0';

		/*
		 * if it exists we assume it is a directory, it is not within
		 * the spec (at least it seems to read that way) to alter the
		 * filesystem for nodes NOT EXPLICITLY stored on the archive.
		 * If that assumption is changed, you would test the node here
		 * and figure out how to get rid of it (probably like some
		 * recursive unlink()) or fix up the directory permissions if
		 * required (do an access()).
		 */
		if (lstat(name, &sb) == 0) {
			*spt = '/';
			spt = next;
			continue;
		}

		/*
		 * the path fails at this point, see if we can create the
		 * needed directory and continue on
		 */
		if (mkdir(name, S_IRWXU | S_IRWXG | S_IRWXO) < 0) {
			*spt = '/';
			retval = -1;
			break;
		}

		/*
		 * we were able to create the directory. We will tell the
		 * caller that we found something to fix, and it is ok to try
		 * and create the node again.
		 */
		retval = 0;
		if (pids)
			(void)set_ids(name, st_uid, st_gid, 0);

		/*
		 * make sure the user doesn't have some strange umask that
		 * causes this newly created directory to be unusable. We fix
		 * the modes and restore them back to the creation default at
		 * the end of pax
		 */
		if ((access(name, R_OK | W_OK | X_OK) < 0) &&
		    (lstat(name, &sb) == 0)) {
			set_pmode(name, ((sb.st_mode & FILEBITS) | S_IRWXU), 0);
			add_dir(name, &sb, 1);
		}
		*spt = '/';
		spt = next;
		continue;
	}
	return(retval);
}

/*
 * set_ftime()
 *	Set the access time and modification time for a named file. If frc
 *	is non-zero we force these times to be set even if the user did not
 *	request access and/or modification time preservation (this is also
 *	used by -t to reset access times).
 *	When ign is zero, only those times the user has asked for are set, the
 *	other ones are left alone. We do not assume the un-documented feature
 *	of many utimes() implementations that consider a 0 time value as a do
 *	not set request.
 */

void
set_ftime(const char *fnm, const struct stat *sbp, int frc,
    int issymlink MKSH_A_UNUSED)
{
#if HAVE_UTIMENSAT
	struct timespec ts[2];
#else
	struct {
		time_t tv_sec;
		long tv_nsec;
	} ts[2];
#if HAVE_UTIMES
	struct timeval tv[2];
#else
	struct utimbuf u;
#endif
	struct stat sb;
#endif
	int rv;

	/* pre-initialise values to set */
	st_timexp(a, &ts[0], sbp);
	st_timexp(m, &ts[1], sbp);

	if (!frc && (!patime || !pmtime)) {
		/*
		 * If we are not forcing, only set those times the user
		 * wants set. We get the current values of the times if
		 * we need them (utimensat does not).
		 */
#if HAVE_UTIMENSAT
		if (!patime)
			ts[0].tv_nsec = UTIME_OMIT;
		if (!pmtime)
			ts[1].tv_nsec = UTIME_OMIT;
#else
		if (lstat(fnm, &sb) == 0) {
			if (!patime)
				st_timexp(a, &ts[0], &sb);
			if (!pmtime)
				st_timexp(m, &ts[1], &sb);
		} else
			syswarn(0, errno, "Unable to stat %s", fnm);
#endif
	}

	/* set the times */
#if HAVE_UTIMENSAT
	rv = utimensat(AT_FDCWD, fnm, ts, AT_SYMLINK_NOFOLLOW);
#elif HAVE_UTIMES
	tv[0].tv_sec = ts[0].tv_sec;
	tv[0].tv_usec = ts[0].tv_nsec / 1000;
	tv[1].tv_sec = ts[1].tv_sec;
	tv[1].tv_usec = ts[1].tv_nsec / 1000;
	rv = (issymlink ? lutimes : utimes)(fnm, tv);
	if (rv < 0 && issymlink && (errno == ENOSYS || errno == ENOTSUP))
		/* might be glibc */
		return;
#else
	if (issymlink)
		/* no can do */
		return;
	u.actime = ts[0].tv_sec;
	u.modtime = ts[1].tv_sec;
	rv = utime(fnm, &u);
#endif

	if (rv < 0)
		syswarn(1, errno, "Access/modification time set failed on: %s",
		    fnm);
}

#ifdef PAX_FSET_FTIME
static void
fset_ftime(const char *fnm, int fd, const struct stat *sbp, int frc)
{
#if HAVE_FUTIMENS
	struct timespec ts[2];
#else
	struct {
		time_t tv_sec;
		long tv_nsec;
	} ts[2];
	struct timeval tv[2];
	struct stat sb;
#endif
	int rv;

	/* pre-initialise values to set */
	st_timexp(a, &ts[0], sbp);
	st_timexp(m, &ts[1], sbp);

	if (!frc && (!patime || !pmtime)) {
		/*
		 * If we are not forcing, only set those times the user
		 * wants set. We get the current values of the times if
		 * we need them (futimens does not).
		 */
#if HAVE_FUTIMENS
		if (!patime)
			ts[0].tv_nsec = UTIME_OMIT;
		if (!pmtime)
			ts[1].tv_nsec = UTIME_OMIT;
#else
		if (fstat(fd, &sb) == 0) {
			if (!patime)
				st_timexp(a, &ts[0], &sb);
			if (!pmtime)
				st_timexp(m, &ts[1], &sb);
		} else
			syswarn(0, errno, "Unable to stat %s", fnm);
#endif
	}

	/* set the times */
#if HAVE_FUTIMENS
	rv = futimens(fd, ts);
#else
	tv[0].tv_sec = ts[0].tv_sec;
	tv[0].tv_usec = ts[0].tv_nsec / 1000;
	tv[1].tv_sec = ts[1].tv_sec;
	tv[1].tv_usec = ts[1].tv_nsec / 1000;
	rv = futimes(fd, tv);
#endif
	if (rv < 0)
		syswarn(1, errno, "Access/modification time set failed on: %s",
		    fnm);
}
#endif

/*
 * set_ids()
 *	set the uid and gid of a filesystem node
 * Return:
 *	0 when set, -1 on failure
 */

int
set_ids(char *fnm, uid_t uid, gid_t gid, int issymlink MKSH_A_UNUSED)
{
	int rv;

#if HAVE_FCHOWNAT
	rv = fchownat(AT_FDCWD, fnm, uid, gid, AT_SYMLINK_NOFOLLOW);
#elif HAVE_LCHOWN
	rv = (issymlink ? lchown : chown)(fnm, uid, gid);
	if (rv < 0 && issymlink && (errno == ENOSYS || errno == ENOTSUP))
		/* might be glibc */
		return (0);
#else
	if (issymlink)
		/* no can do */
		return (0);
	rv = chown(fnm, uid, gid);
#endif

	if (rv < 0) {
		/*
		 * ignore EPERM unless in verbose mode or being run by root.
		 * if running as pax, POSIX requires a warning.
		 */
		if (/* portability, imake style though */
#ifndef __INTERIX
		    errno != EPERM || vflag || geteuid() == 0 ||
#endif
		    op_mode == OP_PAX)
			syswarn(1, errno, "Unable to set file uid/gid of %s",
			    fnm);
		return (-1);
	}
	return (0);
}

int
fset_ids(char *fnm, int fd, uid_t uid, gid_t gid)
{
	if (fchown(fd, uid, gid) < 0) {
		/*
		 * ignore EPERM unless in verbose mode or being run by root.
		 * if running as pax, POSIX requires a warning.
		 */
		if (/* portability, imake style though */
#ifndef __INTERIX
		    errno != EPERM || vflag || geteuid() == 0 ||
#endif
		    op_mode == OP_PAX)
			syswarn(1, errno, "Unable to set file uid/gid of %s",
			    fnm);
		return (-1);
	}
	return (0);
}

/*
 * set_pmode()
 *	Set file access mode
 */

void
set_pmode(char *fnm, mode_t mode, int issymlink MKSH_A_UNUSED)
{
	int rv;

	mode &= ABITS;
#if HAVE_FCHMODAT
	rv = fchmodat(AT_FDCWD, fnm, mode, AT_SYMLINK_NOFOLLOW);
	if (rv < 0 && (errno == ENOSYS || errno == ENOTSUP)) {
		/* glibc sucks */
		if (issymlink)
			return;
		rv = chmod(fnm, mode);
	}
#elif HAVE_LCHMOD
	rv = (issymlink ? lchmod : chmod)(fnm, mode);
	if (rv < 0 && issymlink && (errno == ENOSYS || errno == ENOTSUP))
		/* similarily glibc */
		return;
#else
	if (issymlink)
		/* no can do */
		return;
	rv = chmod(fnm, mode);
#endif
	if (rv < 0)
		syswarn(1, errno, "Could not set permissions on %s", fnm);
}

void
fset_pmode(char *fnm, int fd, mode_t mode)
{
	mode &= ABITS;
	if (fchmod(fd, mode) < 0)
		syswarn(1, errno, "Could not set permissions on %s", fnm);
}

/*
 * set_attr()
 *	Given a DIRDATA, restore the mode and times as indicated, but
 *	only after verifying that it's the directory that we wanted.
 */
int
set_attr(const struct file_times *ft, int force_times, mode_t mode,
    int do_mode, int in_sig)
{
	struct stat sb;
	int fd, r;

	if (!do_mode && !force_times && !patime && !pmtime)
		return (0);

	/*
	 * We could legitimately go through a symlink here,
	 * so do *not* use O_NOFOLLOW.  The dev+ino check will
	 * protect us from evil.
	 */
	fd = binopen2(BO_MAYBE_DIR, ft->ft_name, O_RDONLY);
	if (fd == -1) {
		if (!in_sig)
			syswarn(1, errno, "Unable to restore mode and times"
			    " for directory %s", ft->ft_name);
		return (-1);
	}

	if (fstat(fd, &sb) == -1) {
		if (!in_sig)
			syswarn(1, errno, "Unable to stat directory %s",
			    ft->ft_name);
		r = -1;
#ifndef O_DIRECTORY
	} else if (!S_ISDIR(sb.st_mode)) {
		if (!in_sig)
			syswarn(1, ENOTDIR, "Unable to restore mode and times"
			    " for directory %s", ft->ft_name);
		r = -1;
#endif
	} else if (ft->ft_ino != sb.st_ino || ft->ft_dev != sb.st_dev) {
		if (!in_sig)
			paxwarn(1, "Directory vanished before restoring"
			    " mode and times: %s", ft->ft_name);
		r = -1;
	} else {
		/* Whew, it's a match!  Is there anything to change? */
		if (do_mode && (mode & ABITS) != (sb.st_mode & ABITS))
			fset_pmode(ft->ft_name, fd, mode);
#ifdef PAX_FSET_FTIME
		if (((force_times || patime) && st_timecmp(a, &ft->sb, &sb, !=)) ||
		    ((force_times || pmtime) && st_timecmp(m, &ft->sb, &sb, !=)))
			fset_ftime(ft->ft_name, fd, &ft->sb, force_times);
#endif
		r = 0;
	}
	close(fd);

	return (r);
}

/*
 * file_write()
 *	Write/copy a file (during copy or archive extract). This routine knows
 *	how to copy files with lseek holes in it. (Which are read as file
 *	blocks containing all 0's but do not have any file blocks associated
 *	with the data). Typical examples of these are files created by dbm
 *	variants (.pag files). While the file size of these files are huge, the
 *	actual storage is quite small (the files are sparse). The problem is
 *	the holes read as all zeros so are probably stored on the archive that
 *	way (there is no way to determine if the file block is really a hole,
 *	we only know that a file block of all zero's can be a hole).
 *	At this writing, no major archive format knows how to archive files
 *	with holes. However, on extraction (or during copy, -rw) we have to
 *	deal with these files. Without detecting the holes, the files can
 *	consume a lot of file space if just written to disk. This replacement
 *	for write when passed the basic allocation size of a filesystem block,
 *	uses lseek whenever it detects the input data is all 0 within that
 *	file block. In more detail, the strategy is as follows:
 *	While the input is all zero keep doing an lseek. Keep track of when we
 *	pass over file block boundaries. Only write when we hit a non zero
 *	input. once we have written a file block, we continue to write it to
 *	the end (we stop looking at the input). When we reach the start of the
 *	next file block, start checking for zero blocks again. Working on file
 *	block boundaries significantly reduces the overhead when copying files
 *	that are NOT very sparse. This overhead (when compared to a write) is
 *	almost below the measurement resolution on many systems. Without it,
 *	files with holes cannot be safely copied. It does has a side effect as
 *	it can put holes into files that did not have them before, but that is
 *	not a problem since the file contents are unchanged (in fact it saves
 *	file space). (Except on paging files for diskless clients. But since we
 *	cannot determine one of those file from here, we ignore them). If this
 *	ever ends up on a system where CTG files are supported and the holes
 *	are not desired, just do a conditional test in those routines that
 *	call file_write() and have it call write() instead. BEFORE CLOSING THE
 *	FILE, make sure to call file_flush() when the last write finishes with
 *	an empty block. A lot of filesystems will not create an lseek hole at
 *	the end. In this case we drop a single 0 at the end to force the
 *	trailing 0's in the file.
 *	---Parameters---
 *	rem: how many bytes left in this filesystem block
 *	isempt: have we written to the file block yet (is it empty)
 *	sz: basic file block allocation size
 *	cnt: number of bytes on this write
 *	str: buffer to write
 * Return:
 *	number of bytes written, -1 on write (or lseek) error.
 */

int
file_write(int fd, char *str, int cnt, int *rem, int *isempt, int sz,
	char *name)
{
	char *pt;
	char *end;
	int wcnt;
	char *st = str;
	char **strp;

	/*
	 * while we have data to process
	 */
	while (cnt) {
		if (!*rem) {
			/*
			 * We are now at the start of filesystem block again
			 * (or what we think one is...). start looking for
			 * empty blocks again
			 */
			*isempt = 1;
			*rem = sz;
		}

		/*
		 * only examine up to the end of the current file block or
		 * remaining characters to write, whatever is smaller
		 */
		wcnt = MINIMUM(cnt, *rem);
		cnt -= wcnt;
		*rem -= wcnt;
		if (*isempt) {
			/*
			 * have not written to this block yet, so we keep
			 * looking for zero's
			 */
			pt = st;
			end = st + wcnt;

			/*
			 * look for a zero filled buffer
			 */
			while ((pt < end) && (*pt == '\0'))
				++pt;

			if (pt == end) {
				/*
				 * skip, buf is empty so far
				 */
				if (fd > -1 &&
				    lseek(fd, wcnt, SEEK_CUR) < 0) {
					if (errno == ESPIPE)
						goto isapipe;
					syswarn(1, errno,
					    "Failed seek on file %s", name);
					return (-1);
				}
				st = pt;
				continue;
			}
 isapipe:
			/*
			 * drat, the buf is not zero filled
			 */
			*isempt = 0;
		}

		/*
		 * have non-zero data in this filesystem block, have to write
		 */
		switch (fd) {
		case -1:
			strp = &gnu_name_string;
			break;
		case -2:
			strp = &gnu_link_string;
			break;
		default:
			strp = NULL;
			break;
		}
		if (strp) {
			if (*strp)
				err(1, "WARNING! Major Internal Error! GNU hack Failing!");
			*strp = malloc(wcnt + 1);
			if (*strp == NULL) {
				paxwarn(1, "Out of memory");
				return(-1);
			}
			memcpy(*strp, st, wcnt);
			(*strp)[wcnt] = '\0';
			break;
		} else if (write(fd, st, wcnt) != wcnt) {
			syswarn(1, errno, "Failed write to file %s", name);
			return(-1);
		}
		st += wcnt;
	}
	return(st - str);
}

/*
 * file_flush()
 *	when the last file block in a file is zero, many filesystems will not
 *	let us create a hole at the end. To get the last block with zeros, we
 *	write the last BYTE with a zero (back up one byte and write a zero).
 */

void
file_flush(int fd, char *fname, int isempt)
{
	static char blnk[] = "\0";

	/*
	 * silly test, but make sure we are only called when the last block is
	 * filled with all zeros.
	 */
	if (!isempt)
		return;

	/*
	 * move back one byte and write a zero
	 */
	if (lseek(fd, -1, SEEK_CUR) < 0) {
		syswarn(1, errno, "Failed seek on file %s", fname);
		return;
	}

	if (write(fd, blnk, 1) < 0)
		syswarn(1, errno, "Failed write to file %s", fname);
}

/*
 * rdfile_close()
 *	close a file we have been reading (to copy or archive). If we have to
 *	reset access time (tflag) do so (the times are stored in arcn).
 */

void
rdfile_close(ARCHD *arcn MKSH_A_UNUSED, int *fd)
{
	/*
	 * make sure the file is open
	 */
	if (*fd < 0)
		return;

	/*
	 * user wants last access time reset
	 */
#ifdef PAX_FSET_FTIME
	if (tflag)
		fset_ftime(arcn->org_name, *fd, &arcn->sb, 1);
#endif

	(void)close(*fd);
	*fd = -1;
}

/*
 * set_crc()
 *	read a file to calculate its crc. This is a real drag. Archive formats
 *	that have this, end up reading the file twice (we have to write the
 *	header WITH the crc before writing the file contents. Oh well...
 * Return:
 *	0 if was able to calculate the crc, -1 otherwise
 */

int
set_crc(ARCHD *arcn, int fd)
{
	int i;
	int res;
	off_t cpcnt = 0;
	size_t size;
	uint32_t crc = 0;
	char tbuf[FILEBLK];
	struct stat sb;

	if (fd < 0) {
		/*
		 * hmm, no fd, should never happen. well no crc then.
		 */
		arcn->crc = 0;
		return(0);
	}

	if ((size = arcn->sb.st_blksize) > sizeof(tbuf))
		size = sizeof(tbuf);

	/*
	 * read all the bytes we think that there are in the file. If the user
	 * is trying to archive an active file, forget this file.
	 */
	for (;;) {
		if ((res = read(fd, tbuf, size)) <= 0)
			break;
		cpcnt += res;
		for (i = 0; i < res; ++i)
			crc += (tbuf[i] & 0xff);
	}

	/*
	 * safety check. we want to avoid archiving files that are active as
	 * they can create inconsistent archive copies.
	 */
	if (cpcnt != arcn->sb.st_size)
		paxwarn(1, "File changed size %s", arcn->org_name);
	else if (fstat(fd, &sb) < 0)
		syswarn(1, errno, "Failed stat on %s", arcn->org_name);
	else if (st_timecmp(m, &arcn->sb, &sb, !=))
		paxwarn(1, "File %s was modified during read", arcn->org_name);
	else if (lseek(fd, 0, SEEK_SET) < 0)
		syswarn(1, errno, "File rewind failed on: %s", arcn->org_name);
	else {
		arcn->crc = crc;
		return(0);
	}
	return(-1);
}
@


1.30
log
@port to Debian sid/{amd64,i386,hurd-i386,x32}, {stretch,jessie}/{amd64,i386}
@
text
@d74 1
a74 1
__RCSID("$MirOS: src/bin/pax/file_subs.c,v 1.29 2018/12/13 07:09:10 tg Exp $");
d1034 1
a1034 1
		return (0);
@


1.29
log
@fixing and string pooling and int shortening offensive
@
text
@d5 1
a5 1
 * Copyright (c) 2007, 2008, 2009, 2012, 2014, 2016, 2018
d74 1
a74 1
__RCSID("$MirOS: src/bin/pax/file_subs.c,v 1.28 2018/12/12 18:08:43 tg Exp $");
d862 1
a862 1
	rv = utimensat(AT_FDCWD, fnm, tv, AT_SYMLINK_NOFOLLOW);
@


1.28
log
@merge the npax branch into MAIN

asides from a missing dprintf and portability, this ought to be
good enough for people (well me) to play with for now
@
text
@d74 1
a74 1
__RCSID("$MirOS: src/bin/pax/file_subs.c,v 1.26 2018/12/12 00:09:27 tg Exp $");
d108 1
a108 1
	 * file and a character device or fifo exists with the same name, we
d209 3
a211 3
		syswarn(1,errno,"Unable to link to %s from %s", arcn->ln_name,
		    arcn->name);
		return(-1);
d429 3
a431 3
			syswarn(1, oerrno, "Could not link to %s from %s", to,
			    from);
			return(-1);
d433 1
a433 1
		return(1);
d439 1
a439 1
	return(0);
d583 1
a583 1
			syswarn(1, oerrno, "Could not create: %s", nm);
d620 1
a620 1
			syswarn(0, errno,"Could not access %s (stat)", nm);
d696 1
a696 1
		syswarn(1, errno, "Could not unlink %s", name);
d1073 1
a1073 1
			    " for directory: %s", ft->ft_name);
d1079 1
a1079 1
			syswarn(1, errno, "Unable to stat directory: %s",
d1086 1
a1086 1
			    " for directory: %s", ft->ft_name);
d1212 1
a1212 1
					    "File seek on %s", name);
@


1.27
log
@slowmerge (untested though)
@
text
@d9 1
d44 5
a48 1
#include <sys/param.h>
d50 3
a52 2
#include <sys/stat.h>
#include <sys/uio.h>
d56 1
d60 3
a62 1
#include <time.h>
d64 1
a64 1
#ifdef __INTERIX
d67 1
d69 3
a71 1
#include "options.h"
d76 4
a79 18
#ifndef __GLIBC_PREREQ
#define __GLIBC_PREREQ(maj,min)	0
#endif

#if defined(__INTERIX)
#define PAX_UTIME
#elif defined(__GLIBC__) && !defined(PAX_DONT_USE_AT_FUNCTIONS)
/*XXX this really needs autoconfiguration */
/*XXX WRONG for old glibc, or glibc on non-*at() OS */
#define PAX_UTIMENSAT
#define PAX_FUTIMENS
#else
#define PAX_UTIMES
#if (!defined(__GLIBC__) || __GLIBC_PREREQ(2, 3))
/*XXX also wrong, could also use futimens() here */
#define PAX_FUTIMES
#endif
#endif
d81 1
a81 1
#if defined(PAX_FUTIMES) || defined(PAX_FUTIMENS)
d87 1
a87 1
static void fset_ftime(char *, int, time_t, time_t, int);
a90 5
 * routines that deal with file operations such as: creating, removing;
 * and setting access modes, uid/gid and times of files
 */

/*
d116 1
a116 1
	if ((fd = open(arcn->name, O_WRONLY | O_CREAT | O_EXCL,
d118 1
a118 1
		return(fd);
d134 1
a134 1
		if ((fd = open(arcn->name, O_WRONLY | O_CREAT | O_TRUNC,
d182 1
a182 2
		fset_ftime(arcn->name, fd, arcn->sb.st_mtime,
		    arcn->sb.st_atime, 0);
d202 1
a202 1
	int rv;
d220 2
a221 2
	rv = mk_link(arcn->ln_name, &sb, arcn->name, 0);
	if (rv == 0) {
d223 1
a223 1
		rv = sltab_add_link(arcn->name, &sb);
d225 1
a225 1
		if (rv < 0) {
d230 2
a231 1
	if (fdp != NULL && rv == 0 && sb.st_size == 0 && arcn->skip > 0) {
d235 3
a237 3
		if ((*fdp = open(arcn->name, O_WRONLY | O_TRUNC)) == -1) {
			rv = errno;
			syswarn(1, rv, "Unable to re-open %s", arcn->name);
d241 1
a241 1
		rv = 0;
d244 1
a244 1
	return (rv);
d381 3
d385 1
d407 1
a407 1
			if ((fdsrc = open(to, O_RDONLY, 0)) < 0) {
d459 1
a459 1
	char *target = NULL;
d479 1
a479 1
			if (strcmp(NM_TAR, argv0) == 0 && Lflag) {
d482 1
a482 1
					target = malloc(sb.st_size + 1);
d484 1
d501 2
d529 1
a529 1
			free(target);
d557 2
a558 2
				nm);
			free(target);
d575 1
a575 1
			free(target);
d584 1
a584 1
			free(target);
a587 1
	free(target);
d593 2
a594 3
		res = ((arcn->type == PAX_SLK) ?
		    set_lids(nm, arcn->sb.st_uid, arcn->sb.st_gid) :
		    set_ids(nm, arcn->sb.st_uid, arcn->sb.st_gid));
d608 1
a608 1
	if (arcn->type == PAX_DIR && strcmp(NM_CPIO, argv0) != 0) {
d647 2
a648 2
		set_ftime(nm, arcn->sb.st_mtime, arcn->sb.st_atime, 0,
		    arcn->type == PAX_SLK);
d782 1
a782 1
			(void)set_ids(name, st_uid, st_gid);
d815 2
a816 2
set_ftime(char *fnm, time_t mtime, time_t atime, int frc,
    int issymlink __attribute__((__unused__)))
d818 10
a827 6
#if defined(PAX_UTIMENSAT)
	static struct timespec ts[2] = {{0L, 0L}, {0L, 0L}};
#elif defined(PAX_UTIMES)
	static struct timeval tv[2] = {{0L, 0L}, {0L, 0L}};
	struct stat sb;
#elif defined(PAX_UTIME)
d829 1
a830 2
#else
# error define one of PAX_UTIMENSAT, PAX_UTIMES, PAX_UTIME
d834 4
d844 1
a844 1
#if defined(PAX_UTIMENSAT)
d852 1
a852 1
				atime = sb.st_atime;
d854 1
a854 1
				mtime = sb.st_mtime;
d861 7
a867 7
#if defined(PAX_UTIMENSAT)
	ts[0].tv_sec = atime;
	ts[1].tv_sec = mtime;
	rv = utimensat(AT_FDCWD, fnm, ts, AT_SYMLINK_NOFOLLOW);
#elif defined(PAX_UTIMES)
	tv[0].tv_sec = atime;
	tv[1].tv_sec = mtime;
d869 3
d876 2
a877 2
	u.actime = atime;
	u.modtime = mtime;
d880 1
a883 1
	return;
d888 1
a888 1
fset_ftime(char *fnm, int fd, time_t mtime, time_t atime, int frc)
d890 2
a891 2
#if defined(PAX_FUTIMENS)
	static struct timespec ts[2] = {{0L, 0L}, {0L, 0L}};
d893 5
a897 1
	static struct timeval tv[2] = {{0L, 0L}, {0L, 0L}};
d902 4
d912 1
a912 1
#if defined(PAX_FUTIMENS)
d920 1
a920 1
				atime = sb.st_atime;
d922 1
a922 1
				mtime = sb.st_mtime;
d929 1
a929 3
#if defined(PAX_FUTIMENS)
	ts[0].tv_sec = atime;
	ts[1].tv_sec = mtime;
d932 4
a935 2
	tv[0].tv_sec = atime;
	tv[1].tv_sec = mtime;
d952 1
a952 1
set_ids(char *fnm, uid_t uid, gid_t gid)
d954 17
a970 1
	if (chown(fnm, uid, gid) < 0) {
d975 1
a975 1
		if (strcmp(NM_PAX, argv0) == 0
d977 1
a977 2
		    || errno != EPERM || vflag ||
		    geteuid() == 0
d979 1
a979 1
		    )
d982 1
a982 1
		return(-1);
d984 1
a984 1
	return(0);
d995 1
a995 26
		if (strcmp(NM_PAX, argv0) == 0 || errno != EPERM || vflag ||
		    geteuid() == 0)
			syswarn(1, errno, "Unable to set file uid/gid of %s",
			    fnm);
		return(-1);
	}
	return(0);
}

/*
 * set_lids()
 *	set the uid and gid of a filesystem node
 * Return:
 *	0 when set, -1 on failure
 */

int
set_lids(char *fnm, uid_t uid, gid_t gid)
{
#ifndef __APPLE__
	if (lchown(fnm, uid, gid) < 0) {
		/*
		 * ignore EPERM unless in verbose mode or being run by root.
		 * if running as pax, POSIX requires a warning.
		 */
		if (strcmp(NM_PAX, argv0) == 0
d997 1
a997 2
		    || errno != EPERM || vflag ||
		    geteuid() == 0
d999 1
a999 1
		    )
d1002 1
a1002 1
		return(-1);
d1004 1
a1004 2
#endif
	return(0);
d1013 1
a1013 1
set_pmode(char *fnm, mode_t mode, int issymlink __attribute__((__unused__)))
d1018 1
a1018 3
#if defined(__MirBSD__)
	rv = (issymlink ? lchmod : chmod)(fnm, mode);
#elif defined(__OpenBSD__)
d1020 4
a1023 2
#else
	if (!issymlink) {
a1024 1
		goto out;
d1026 10
a1035 18
	/*
	 * glibc has both fchmodat and lchmod, but they (the former
	 * with AT_SYMLINK_NOFOLLOW given) always return ENOTSUP or
	 * ENOSYS; other OSes likely don’t have them at all
	 */
#ifdef HAVE_LCHMOD
	if (!(rv = lchmod(fnm, mode)) || errno != ENOSYS)
		goto out;
#endif
#if defined(HAVE_FCHMODAT) && defined(AT_SYMLINK_NOFOLLOW)
	if (!(rv = fchmodat(AT_FDCWD, fnm, mode, AT_SYMLINK_NOFOLLOW)) ||
	    errno != ENOTSUP)
		goto out;
#endif
	/* cannot set the mode of a symbolic link, silently ignore */
	return;

 out:
a1046 1
	return;
d1069 1
a1069 5
	fd = open(ft->ft_name, O_RDONLY
#ifdef O_DIRECTORY
	    | O_DIRECTORY
#endif
	    );
d1098 5
a1102 4
		if (((force_times || patime) && ft->ft_atime != sb.st_atime) ||
		    ((force_times || pmtime) && ft->ft_mtime != sb.st_mtime))
			fset_ftime(ft->ft_name, fd, ft->ft_mtime,
			    ft->ft_atime, force_times);
a1109 1

d1186 1
a1186 1
		wcnt = MIN(cnt, *rem);
d1208 1
a1208 1
				    lseek(fd, (off_t)wcnt, SEEK_CUR) < 0) {
d1211 3
a1213 3
					syswarn(1,errno,"File seek on %s",
					    name);
					return(-1);
d1281 1
a1281 1
	if (lseek(fd, (off_t)-1, SEEK_CUR) < 0) {
a1287 1
	return;
d1297 1
a1297 1
rdfile_close(ARCHD *arcn, int *fd)
d1308 1
d1310 2
a1311 2
		fset_ftime(arcn->org_name, *fd, arcn->sb.st_mtime,
		    arcn->sb.st_atime, 1);
d1331 1
a1331 1
	off_t cpcnt = 0L;
d1333 1
a1333 1
	u_int32_t crc = 0;
d1341 1
a1341 1
		arcn->crc = 0L;
d1345 1
a1345 1
	if ((size = (size_t)arcn->sb.st_blksize) > sizeof(tbuf))
d1368 1
a1368 1
	else if (arcn->sb.st_mtime != sb.st_mtime)
d1370 1
a1370 1
	else if (lseek(fd, (off_t)0L, SEEK_SET) < 0)
@


1.26
log
@merge patches from Debian 1:20171021-3 upload
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.32 +1.46 +1.48 +1.50 2009/12/22 12:08:30 jasper Exp $	*/
d62 1
a62 1
__RCSID("$MirOS: src/bin/pax/file_subs.c,v 1.23 2016/10/25 18:57:54 tg Exp $");
@


1.25
log
@merge
@
text
@d5 1
a5 1
 * Copyright (c) 2007, 2008, 2009, 2012, 2014, 2016
d7 2
d68 17
a84 2
#if !defined(__INTERIX) && (!defined(__GLIBC__) || __GLIBC_PREREQ(2, 3))
#define PAX_FUTIMES	/* we have futimes() */
d88 1
a88 1
#ifdef PAX_FUTIMES
d187 1
a187 1
#ifdef PAX_FUTIMES
d241 1
a241 1
			set_pmode(arcn->name, 0600);
d246 1
a246 1
				set_pmode(arcn->name, sb.st_mode);
a600 6
	 * symlinks are done now.
	 */
	if (arcn->type == PAX_SLK)
		return (0);

	/*
d608 1
a608 1
		set_pmode(nm, arcn->sb.st_mode);
d631 1
a631 1
			    ((sb.st_mode & FILEBITS) | S_IRWXU));
d649 2
a650 1
		set_ftime(nm, arcn->sb.st_mtime, arcn->sb.st_atime, 0);
d794 1
a794 1
			set_pmode(name, ((sb.st_mode & FILEBITS) | S_IRWXU));
d817 2
a818 1
set_ftime(char *fnm, time_t mtime, time_t atime, int frc)
d820 3
d825 1
a825 1
#ifdef __INTERIX
d827 3
d831 1
a832 2
	tv[0].tv_sec = (long)atime;
	tv[1].tv_sec = (long)mtime;
d835 10
a844 3
		 * if we are not forcing, only set those times the user wants
		 * set. We get the current values of the times if we need them.
		 */
d847 1
a847 1
				tv[0].tv_sec = (long)sb.st_atime;
d849 1
a849 1
				tv[1].tv_sec = (long)sb.st_mtime;
d851 2
a852 1
			syswarn(0,errno,"Unable to obtain file stats %s", fnm);
d855 9
a863 7
	/*
	 * set the times
	 */
#ifdef __INTERIX
	u.actime = tv[0].tv_sec;
	u.modtime = tv[1].tv_sec;
	if (utime(fnm, &u) < 0)
d865 6
a870 1
	if (utimes(fnm, tv) < 0)
d872 1
d878 1
a878 1
#ifdef PAX_FUTIMES
d882 3
d887 2
a889 2
	tv[0].tv_sec = (long)atime;
	tv[1].tv_sec = (long)mtime;
d892 10
a901 3
		 * if we are not forcing, only set those times the user wants
		 * set. We get the current values of the times if we need them.
		 */
d904 1
a904 1
				tv[0].tv_sec = (long)sb.st_atime;
d906 1
a906 1
				tv[1].tv_sec = (long)sb.st_mtime;
d908 2
a909 1
			syswarn(0,errno,"Unable to obtain file stats %s", fnm);
d911 12
a922 4
	/*
	 * set the times
	 */
	if (futimes(fd, tv) < 0)
a924 1
	return;
d1009 1
a1009 1
set_pmode(char *fnm, mode_t mode)
d1011 2
d1014 29
a1042 1
	if (chmod(fnm, mode) < 0)
a1043 1
	return;
@


1.24
log
@filesystem
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.32 +1.46 +1.48 2009/12/22 12:08:30 jasper Exp $	*/
d637 1
a637 3
	}

	if (patime || pmtime)
@


1.23
log
@fastmerge
@
text
@d60 1
a60 1
__RCSID("$MirOS: src/bin/pax/file_subs.c,v 1.22 2016/03/06 14:41:32 tg Exp $");
d430 1
a430 1
 *	create an entry in the file system (other than a file or hard link).
d646 1
a646 1
 *	Remove node from file system with the specified name. We pass the type
d696 1
a696 1
 *	We were trying to create some kind of node in the file system and it
d702 1
a702 1
 *	last resort when trying to create entries in the file system.
d745 1
a745 1
		 * file system for nodes NOT EXPLICITLY stored on the archive.
d880 1
a880 1
 *	set the uid and gid of a file system node
d925 1
a925 1
 *	set the uid and gid of a file system node
d1056 1
a1056 1
 *	for write when passed the basic allocation size of a file system block,
d1076 1
a1076 1
 *	an empty block. A lot of file systems will not create an lseek hole at
d1080 1
a1080 1
 *	rem: how many bytes left in this file system block
d1105 1
a1105 1
			 * We are now at the start of file system block again
d1157 1
a1157 1
		 * have non-zero data in this file system block, have to write
d1192 1
a1192 1
 *	when the last file block in a file is zero, many file systems will not
@


1.22
log
@work around lack of O_DIRECTORY
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.32 2009/12/22 12:08:30 jasper Exp $	*/
d60 1
a60 1
__RCSID("$MirOS: src/bin/pax/file_subs.c,v 1.19 2014/07/03 17:52:11 tg Exp $");
d106 1
a106 1
	if ((fd = open(arcn->name, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL,
d712 1
d719 1
a719 1
	if (*spt == '/')
d729 11
d752 2
a753 1
			*(spt++) = '/';
d787 2
a788 1
		*(spt++) = '/';
@


1.21
log
@merge CVE fixes from openbsd branch
@
text
@d5 1
a5 1
 * Copyright (c) 2007, 2008, 2009, 2012, 2014
d982 5
a986 1
	fd = open(ft->ft_name, O_RDONLY | O_DIRECTORY);
d999 7
@


1.20
log
@merge from Debian: Plug some GCC fortify warnings
@
text
@d6 1
a6 1
 *	Thorsten Glaser <tg@@mirbsd.org>
a79 4
#define FILEBITS		(S_ISVTX | S_IRWXU | S_IRWXG | S_IRWXO)
#define SETBITS			(S_ISUID | S_ISGID)
#define ABITS			(FILEBITS | SETBITS)

d212 9
d355 1
d447 1
a447 1
	int len;
d515 15
a529 1
			res = symlink(arcn->ln_name, nm);
d596 1
a596 1
	if (pmode)
d607 2
a608 1
		 * before pax exits.
d610 13
a622 17
		if (access(nm, R_OK | W_OK | X_OK) < 0) {
			if (lstat(nm, &sb) < 0) {
				syswarn(0, errno,"Could not access %s (stat)",
				    arcn->name);
				set_pmode(nm,file_mode | S_IRWXU);
			} else {
				/*
				 * We have to add rights to the dir, so we make
				 * sure to restore the mode. The mode must be
				 * restored AS CREATED and not as stored if
				 * pmode is not set.
				 */
				set_pmode(nm,
				    ((sb.st_mode & FILEBITS) | S_IRWXU));
				if (!pmode)
					arcn->sb.st_mode = sb.st_mode;
			}
d625 3
a627 2
			 * we have to force the mode to what was set here,
			 * since we changed it from the default as created.
d629 2
d632 3
a634 1
		} else if (pmode || patime || pmtime)
d636 1
d680 1
d963 54
a1211 5
	(void)close(*fd);
	*fd = -1;
	if (!tflag)
		return;

d1215 6
a1220 2
	set_ftime(arcn->org_name, arcn->sb.st_mtime, arcn->sb.st_atime, 1);
	return;
@


1.19
log
@fix extraction of hardlinked symlink(7)s on MirBSD
@
text
@d60 1
a60 1
__RCSID("$MirOS: src/bin/pax/file_subs.c,v 1.18 2012/06/05 18:22:56 tg Exp $");
d1161 1
a1161 1
	u_long size;
d1174 2
a1175 2
	if ((size = (u_long)arcn->sb.st_blksize) > (u_long)sizeof(tbuf))
		size = (u_long)sizeof(tbuf);
@


1.18
log
@KNF
@
text
@d5 1
a5 1
 * Copyright (c) 2007, 2008, 2009, 2012
d60 1
a60 1
__RCSID("$MirOS: src/bin/pax/file_subs.c,v 1.17 2012/05/20 16:13:17 tg Exp $");
d292 17
d368 5
@


1.17
log
@get rid of extern.h including other headers
@
text
@d60 1
a60 1
__RCSID("$MirOS: src/bin/pax/file_subs.c,v 1.16 2012/02/12 00:42:28 tg Exp $");
d462 1
a462 1
badlink:
@


1.16
log
@Hurd support patches
@
text
@d51 1
d60 1
a60 1
__RCSID("$MirOS: src/bin/pax/file_subs.c,v 1.15 2012/02/12 00:27:16 tg Exp $");
@


1.15
log
@merge OpenBSD
@
text
@d5 1
a5 1
 * Copyright (c) 2007, 2008, 2009
d7 2
d59 1
a59 1
__RCSID("$MirOS: src/bin/pax/file_subs.c,v 1.14 2009/10/27 18:47:26 tg Exp $");
d416 1
a416 1
	char target[MAXPATHLEN];
d439 7
d447 1
a447 1
					    sizeof target - 1);
d483 2
a484 1
			return(-1);
d498 2
a499 1
			return(-1);
d514 4
a517 2
		if ((ign = unlnk_exist(nm, arcn->type)) < 0)
			return(-1);
d524 2
a525 1
			return(-1);
d528 1
d544 1
a544 1
		return(0);
d595 1
a595 1
	return(0);
@


1.14
log
@new option “-M lncp”, see TFM for details
@
text
@d1 1
a1 2
/**	$MirOS: src/bin/pax/file_subs.c,v 1.13 2008/10/29 17:34:48 tg Exp $ */
/*	$OpenBSD: file_subs.c,v 1.30 2005/11/09 19:59:06 otto Exp $	*/
d57 1
a57 2
__SCCSID("@@(#)file_subs.c	8.1 (Berkeley) 5/31/93");
__RCSID("$MirOS: src/bin/pax/file_subs.c,v 1.13 2008/10/29 17:34:48 tg Exp $");
d1083 1
a1083 1
 *	close a file we have beed reading (to copy or archive). If we have to
@


1.13
log
@add code to work around broken archives such as the CPIO archive inside
Fedora Core 4 glibc-common-2.3.6-3.i386.rpm which carry the actual data
of hardlinks not in the first but a later (here, the last) occurence of
the file in question: iff hardlinking succeeds (no cross-device!), size
of the linked files is 0, size of the archive member is greater than 0,
we are extracting, but not to stdout, proceed writing out the data.
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/file_subs.c,v 1.12 2007/02/17 04:52:40 tg Exp $ */
d6 2
a7 2
 * Copyright (c) 2007, 2008
 *	Thorsten Glaser <tg@@mirbsd.de>
d59 1
a59 1
__RCSID("$MirOS: src/bin/pax/file_subs.c,v 1.12 2007/02/17 04:52:40 tg Exp $");
d352 32
d385 1
@


1.12
log
@__CRAZY clean
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/file_subs.c,v 1.11 2007/02/17 04:22:23 tg Exp $ */
d6 2
a7 1
 * Copyright (c) 2007 Thorsten Glaser
d59 1
a59 1
__RCSID("$MirOS: src/bin/pax/file_subs.c,v 1.11 2007/02/17 04:22:23 tg Exp $");
d188 2
a189 1
 *	0 if ok, -1 otherwise
d193 1
a193 1
lnk_creat(ARCHD *arcn)
d196 1
d214 15
a228 1
	return(mk_link(arcn->ln_name, &sb, arcn->name, 0));
@


1.11
log
@ok, cpp(1) is too picky, formulate it more expressively
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/file_subs.c,v 1.10 2007/02/17 04:18:29 tg Exp $ */
d6 1
d58 1
a58 1
__RCSID("$MirOS: src/bin/pax/file_subs.c,v 1.10 2007/02/17 04:18:29 tg Exp $");
@


1.10
log
@from FreeWRT: on glibc based systems with glibc<2.3 don't futimes(3) either
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/file_subs.c,v 1.9 2007/02/17 04:16:09 tg Exp $ */
d57 1
a57 1
__RCSID("$MirOS: src/bin/pax/file_subs.c,v 1.9 2007/02/17 04:16:09 tg Exp $");
d59 5
a63 2
#if !defined(__INTERIX) && \
    (!defined(__GLIBC__) || (defined(__GLIBC_PREREQ) && __GLIBC_PREREQ(2, 3)))
@


1.9
log
@make fset_ftime() static to file_subs.c as it's not used in
any other places; give it its own conditional, do not just
nullify it on Interix
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/file_subs.c,v 1.8 2007/02/17 04:03:19 tg Exp $ */
d57 1
a57 1
__RCSID("$MirOS: src/bin/pax/file_subs.c,v 1.8 2007/02/17 04:03:19 tg Exp $");
d59 2
a60 1
#if !defined(__INTERIX)
@


1.8
log
@if we're outputting to pipes, we can't seek to create holes
unbreaks -xO | scenarios where there was a hole in the archive
or the last block was empty, cought on GNU/Linux with FreeWRT
where on the Debian host, the block size was smaller than here
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/file_subs.c,v 1.7 2006/06/23 23:03:56 tg Exp $ */
d57 1
a57 1
__RCSID("$MirOS: src/bin/pax/file_subs.c,v 1.7 2006/06/23 23:03:56 tg Exp $");
d59 8
a66 2
static int
mk_link(char *, struct stat *, char *, int);
d167 1
a167 1
#ifndef __INTERIX
d717 2
a718 2
#ifndef __INTERIX
void
@


1.7
log
@merge the OpenBSD import (bugfix)
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/file_subs.c,v 1.6 2005/11/10 20:27:48 tg Exp $ */
d57 1
a57 1
__RCSID("$MirOS: src/bin/pax/file_subs.c,v 1.6 2005/11/10 20:27:48 tg Exp $");
d940 2
d949 1
@


1.6
log
@do not preserve atime/mtime on Interix if we only
have got a fd, not a filename
@
text
@d1 2
a2 2
/**	$MirOS: src/bin/pax/file_subs.c,v 1.5 2005/04/29 18:34:44 tg Exp $ */
/*	$OpenBSD: file_subs.c,v 1.29 2005/04/25 19:39:52 otto Exp $	*/
d57 1
a57 1
__RCSID("$MirOS: src/bin/pax/file_subs.c,v 1.5 2005/04/29 18:34:44 tg Exp $");
d1062 1
a1062 1
	unsigned long crc = 0L;
@


1.5
log
@(tentative) merge, more to come
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/file_subs.c,v 1.4 2005/04/13 21:01:00 tg Exp $ */
d57 1
a57 1
__RCSID("$MirOS: src/bin/pax/file_subs.c,v 1.4 2005/04/13 21:01:00 tg Exp $");
d161 1
d165 1
d711 1
d741 1
@


1.4
log
@don't bog me with uid/gid failures on Interix
(but conform to POSIX.2)
@
text
@d1 2
a2 2
/**	$MirOS: src/bin/pax/file_subs.c,v 1.3 2005/04/13 20:03:35 tg Exp $ */
/*	$OpenBSD: file_subs.c,v 1.27 2004/04/16 22:50:23 deraadt Exp $	*/
d57 1
a57 1
__RCSID("$MirOS: src/bin/pax/file_subs.c,v 1.3 2005/04/13 20:03:35 tg Exp $");
a141 3
	if (close(fd) < 0)
		syswarn(0, errno, "Unable to close file descriptor on %s",
		    arcn->name);
d149 2
a150 1
		res = set_ids(arcn->name, arcn->sb.st_uid, arcn->sb.st_gid);
d160 1
a160 1
		set_pmode(arcn->name, arcn->sb.st_mode);
d162 5
a166 1
		set_ftime(arcn->name, arcn->sb.st_mtime, arcn->sb.st_atime, 0);
d512 1
a512 1
			add_dir(nm, strlen(nm), &(arcn->sb), 1);
d514 1
a514 1
			add_dir(nm, strlen(nm), &(arcn->sb), 0);
d649 1
a649 1
			add_dir(name, spt - name, &sb, 1);
d709 30
d767 17
d828 9
@


1.3
log
@these are the compile time fixes
this commit message provided by interix ;)
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/file_subs.c,v 1.2 2005/02/28 20:21:27 tg Exp $ */
d57 1
a57 1
__RCSID("$MirOS: src/bin/pax/file_subs.c,v 1.2 2005/02/28 20:21:27 tg Exp $");
d722 6
a727 2
		if (strcmp(NM_PAX, argv0) == 0 || errno != EPERM || vflag ||
		    geteuid() == 0)
d751 6
a756 2
		if (strcmp(NM_PAX, argv0) == 0 || errno != EPERM || vflag ||
		    geteuid() == 0)
@


1.2
log
@don't attempt to lchown on Mac OSX
@
text
@d1 1
a1 1
/**	$MirOS$ */
d49 3
d57 1
a57 1
__RCSID("$MirOS$");
d672 3
d695 5
d701 1
@


1.1
log
@Initial revision
@
text
@d1 1
a37 8
#ifndef lint
#if 0
static const char sccsid[] = "@@(#)file_subs.c	8.1 (Berkeley) 5/31/93";
#else
static const char rcsid[] = "$OpenBSD: file_subs.c,v 1.27 2004/04/16 22:50:23 deraadt Exp $";
#endif
#endif /* not lint */

d53 3
d729 1
d741 1
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@improve my Frankenstein OS (*wink* you know who you are) further
sans wchar_t of course

this is the essence of reading >1200 commit messages which suck
due to not having the new format of ours...
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.29 2005/04/25 19:39:52 otto Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: file_subs.c,v 1.29 2005/04/25 19:39:52 otto Exp $";
d143 3
d153 1
a153 2
		res = fset_ids(arcn->name, fd, arcn->sb.st_uid,
		    arcn->sb.st_gid);
d163 1
a163 1
		fset_pmode(arcn->name, fd, arcn->sb.st_mode);
d165 1
a165 5
		fset_ftime(arcn->name, fd, arcn->sb.st_mtime,
		    arcn->sb.st_atime, 0);
	if (close(fd) < 0)
		syswarn(0, errno, "Unable to close file descriptor on %s",
		    arcn->name);
d511 1
a511 1
			add_dir(nm, &(arcn->sb), 1);
d513 1
a513 1
			add_dir(nm, &(arcn->sb), 0);
d648 1
a648 1
			add_dir(name, &sb, 1);
a698 30
void
fset_ftime(char *fnm, int fd, time_t mtime, time_t atime, int frc)
{
	static struct timeval tv[2] = {{0L, 0L}, {0L, 0L}};
	struct stat sb;

	tv[0].tv_sec = (long)atime;
	tv[1].tv_sec = (long)mtime;
	if (!frc && (!patime || !pmtime)) {
		/*
		 * if we are not forcing, only set those times the user wants
		 * set. We get the current values of the times if we need them.
		 */
		if (fstat(fd, &sb) == 0) {
			if (!patime)
				tv[0].tv_sec = (long)sb.st_atime;
			if (!pmtime)
				tv[1].tv_sec = (long)sb.st_mtime;
		} else
			syswarn(0,errno,"Unable to obtain file stats %s", fnm);
	}
	/*
	 * set the times
	 */
	if (futimes(fd, tv) < 0)
		syswarn(1, errno, "Access/modification time set failed on: %s",
		    fnm);
	return;
}

a722 17
int
fset_ids(char *fnm, int fd, uid_t uid, gid_t gid)
{
	if (fchown(fd, uid, gid) < 0) {
		/*
		 * ignore EPERM unless in verbose mode or being run by root.
		 * if running as pax, POSIX requires a warning.
		 */
		if (strcmp(NM_PAX, argv0) == 0 || errno != EPERM || vflag ||
		    geteuid() == 0)
			syswarn(1, errno, "Unable to set file uid/gid of %s",
			    fnm);
		return(-1);
	}
	return(0);
}

a760 9
void
fset_pmode(char *fnm, int fd, mode_t mode)
{
	mode &= ABITS;
	if (fchmod(fd, mode) < 0)
		syswarn(1, errno, "Could not set permissions on %s", fnm);
	return;
}

@


1.1.1.3
log
@One "miserable" byte in filenames is worth an import

agreed bsiegert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.30 2005/11/09 19:59:06 otto Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: file_subs.c,v 1.30 2005/11/09 19:59:06 otto Exp $";
d1040 1
a1040 1
	u_int32_t crc = 0;
@


1.1.1.4
log
@import up-to-date pax from OpenBSD 5.1-current
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.32 2009/12/22 12:08:30 jasper Exp $	*/
d37 8
d999 1
a999 1
 *	close a file we have been reading (to copy or archive). If we have to
@


1.1.1.5
log
@pull newer paxtar from OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.48 2016/02/16 04:30:07 guenther Exp $	*/
d37 1
d40 1
a43 1
#include <limits.h>
d60 4
d90 1
a90 1
	if ((fd = open(arcn->name, O_WRONLY | O_CREAT | O_EXCL,
d155 2
a156 2
		fset_ftime(arcn->name, fd, &arcn->sb.st_mtim,
		    &arcn->sb.st_atim, 0);
a173 1
	int res;
d191 1
a191 12
	res = mk_link(arcn->ln_name, &sb, arcn->name, 0);
	if (res == 0) {
		/* check for a hardlink to a placeholder symlink */
		res = sltab_add_link(arcn->name, &sb);

		if (res < 0) {
			/* arrgh, it failed, clean up */
			unlink(arcn->name);
		}
	}

	return (res);
a294 1
			delete_dir(sb.st_dev, sb.st_ino);
d310 1
a310 1
		if (linkat(AT_FDCWD, to, AT_FDCWD, from, 0) == 0)
d346 1
a346 1
	char target[PATH_MAX];
d348 1
a348 1
	int len, defer_pmode = 0;
d408 1
a408 15
			if (arcn->ln_name[0] != '/' &&
			    !has_dotdot(arcn->ln_name))
				res = symlink(arcn->ln_name, nm);
			else {
				/*
				 * absolute symlinks and symlinks with ".."
				 * have to be deferred to prevent the archive
				 * from bootstrapping itself to outside the
				 * working directory.
				 */
				res = sltab_add_sym(nm, arcn->ln_name,
				    arcn->sb.st_mode);
				if (res == 0)
					defer_pmode = 1;
			}
d451 3
a453 1
		res = set_ids(nm, arcn->sb.st_uid, arcn->sb.st_gid);
d458 6
d470 1
a470 1
	if (pmode && !defer_pmode)
d481 1
a481 2
		 * before pax exits.  To do that safely, we want the dev+ino
		 * of the directory we created.
d483 17
a499 13
		if (lstat(nm, &sb) < 0) {
			syswarn(0, errno,"Could not access %s (stat)", nm);
		} else if (access(nm, R_OK | W_OK | X_OK) < 0) {
			/*
			 * We have to add rights to the dir, so we make
			 * sure to restore the mode. The mode must be
			 * restored AS CREATED and not as stored if
			 * pmode is not set.
			 */
			set_pmode(nm,
			    ((sb.st_mode & FILEBITS) | S_IRWXU));
			if (!pmode)
				arcn->sb.st_mode = sb.st_mode;
d502 2
a503 3
			 * we have to force the mode to what was set
			 * here, since we changed it from the default
			 * as created.
a504 2
			arcn->sb.st_dev = sb.st_dev;
			arcn->sb.st_ino = sb.st_ino;
d506 1
a506 3
		} else if (pmode || patime || pmtime) {
			arcn->sb.st_dev = sb.st_dev;
			arcn->sb.st_ino = sb.st_ino;
a507 1
		}
d511 1
a511 1
		set_ftime(nm, &arcn->sb.st_mtim, &arcn->sb.st_atim, 0);
a550 1
		delete_dir(sb.st_dev, sb.st_ino);
a581 1
	char *next;
d588 1
a588 1
	while (*spt == '/')
a597 11

		/*
		 * skip over duplicate slashes; stop if there're only
		 * trailing slashes left
		 */
		next = spt + 1;
		while (*next == '/')
			next++;
		if (*next == '\0')
			break;

d610 1
a610 2
			*spt = '/';
			spt = next;
d644 1
a644 2
		*spt = '/';
		spt = next;
d657 3
a659 1
 *	other ones are left alone.
d663 1
a663 2
set_ftime(const char *fnm, const struct timespec *mtimp,
    const struct timespec *atimp, int frc)
d665 2
a666 4
	struct timespec tv[2];

	tv[0] = *atimp;
	tv[1] = *mtimp;
d668 3
a670 1
	if (!frc) {
d673 1
a673 1
		 * set.
d675 7
a681 4
		if (!patime)
			tv[0].tv_nsec = UTIME_OMIT;
		if (!pmtime)
			tv[1].tv_nsec = UTIME_OMIT;
d687 1
a687 1
	if (utimensat(AT_FDCWD, fnm, tv, AT_SYMLINK_NOFOLLOW) < 0)
d690 1
d694 1
a694 2
fset_ftime(const char *fnm, int fd, const struct timespec *mtimp,
    const struct timespec *atimp, int frc)
d696 2
a697 5
	struct timespec tv[2];

	
	tv[0] = *atimp;
	tv[1] = *mtimp;
d699 3
a701 1
	if (!frc) {
d704 1
a704 1
		 * set.
d706 7
a712 4
		if (!patime)
			tv[0].tv_nsec = UTIME_OMIT;
		if (!pmtime)
			tv[1].tv_nsec = UTIME_OMIT;
d717 1
a717 1
	if (futimens(fd, tv) < 0)
d720 1
d733 1
a733 1
	if (fchownat(AT_FDCWD, fnm, uid, gid, AT_SYMLINK_NOFOLLOW) < 0) {
d765 24
d797 1
a797 1
	if (fchmodat(AT_FDCWD, fnm, mode, AT_SYMLINK_NOFOLLOW) < 0)
d799 1
d808 1
a811 56
 * set_attr()
 *	Given a DIRDATA, restore the mode and times as indicated, but
 *	only after verifying that it's the directory that we wanted.
 */
int
set_attr(const struct file_times *ft, int force_times, mode_t mode,
    int do_mode, int in_sig)
{
	struct stat sb;
	int fd, r;

	if (!do_mode && !force_times && !patime && !pmtime)
		return (0);

	/*
	 * We could legitimately go through a symlink here,
	 * so do *not* use O_NOFOLLOW.  The dev+ino check will
	 * protect us from evil.
	 */
	fd = open(ft->ft_name, O_RDONLY | O_DIRECTORY);
	if (fd == -1) {
		if (!in_sig)
			syswarn(1, errno, "Unable to restore mode and times"
			    " for directory: %s", ft->ft_name);
		return (-1);
	}

	if (fstat(fd, &sb) == -1) {
		if (!in_sig)
			syswarn(1, errno, "Unable to stat directory: %s",
			    ft->ft_name);
		r = -1;
	} else if (ft->ft_ino != sb.st_ino || ft->ft_dev != sb.st_dev) {
		if (!in_sig)
			paxwarn(1, "Directory vanished before restoring"
			    " mode and times: %s", ft->ft_name);
		r = -1;
	} else {
		/* Whew, it's a match!  Is there anything to change? */
		if (do_mode && (mode & ABITS) != (sb.st_mode & ABITS))
			fset_pmode(ft->ft_name, fd, mode);
		if (((force_times || patime) &&
		    timespeccmp(&ft->ft_atim, &sb.st_atim, !=)) ||
		    ((force_times || pmtime) &&
		    timespeccmp(&ft->ft_mtim, &sb.st_mtim, !=)))
			fset_ftime(ft->ft_name, fd, &ft->ft_mtim,
			    &ft->ft_atim, force_times);
		r = 0;
	}
	close(fd);

	return (r);
}


/*
d887 1
a887 1
		wcnt = MINIMUM(cnt, *rem);
d986 1
d1004 5
d1012 2
a1013 6
	if (tflag)
		fset_ftime(arcn->org_name, *fd, &arcn->sb.st_mtim,
		    &arcn->sb.st_atim, 1);

	(void)close(*fd);
	*fd = -1;
d1067 1
a1067 1
	else if (timespeccmp(&arcn->sb.st_mtim, &sb.st_mtim, !=))
@


1.1.1.6
log
@revert the import; we’ll just backport the CVE fixes, for now ☹
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.32 2009/12/22 12:08:30 jasper Exp $	*/
a36 1
#include <sys/param.h>
a38 1
#include <sys/uio.h>
d42 1
a58 4
#define FILEBITS		(S_ISVTX | S_IRWXU | S_IRWXG | S_IRWXO)
#define SETBITS			(S_ISUID | S_ISGID)
#define ABITS			(FILEBITS | SETBITS)

d85 1
a85 1
	if ((fd = open(arcn->name, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL,
d150 2
a151 2
		fset_ftime(arcn->name, fd, arcn->sb.st_mtime,
		    arcn->sb.st_atime, 0);
d169 1
d187 12
a198 1
	return(mk_link(arcn->ln_name, &sb, arcn->name, 0));
d302 1
d318 1
a318 1
		if (link(to, from) == 0)
d354 1
a354 1
	char target[MAXPATHLEN];
d356 1
a356 1
	int len;
d416 15
a430 1
			res = symlink(arcn->ln_name, nm);
d473 1
a473 3
		res = ((arcn->type == PAX_SLK) ?
		    set_lids(nm, arcn->sb.st_uid, arcn->sb.st_gid) :
		    set_ids(nm, arcn->sb.st_uid, arcn->sb.st_gid));
a477 6
	 * symlinks are done now.
	 */
	if (arcn->type == PAX_SLK)
		return(0);

	/*
d484 1
a484 1
	if (pmode)
d495 2
a496 1
		 * before pax exits.
d498 13
a510 17
		if (access(nm, R_OK | W_OK | X_OK) < 0) {
			if (lstat(nm, &sb) < 0) {
				syswarn(0, errno,"Could not access %s (stat)",
				    arcn->name);
				set_pmode(nm,file_mode | S_IRWXU);
			} else {
				/*
				 * We have to add rights to the dir, so we make
				 * sure to restore the mode. The mode must be
				 * restored AS CREATED and not as stored if
				 * pmode is not set.
				 */
				set_pmode(nm,
				    ((sb.st_mode & FILEBITS) | S_IRWXU));
				if (!pmode)
					arcn->sb.st_mode = sb.st_mode;
			}
d513 3
a515 2
			 * we have to force the mode to what was set here,
			 * since we changed it from the default as created.
d517 2
d520 3
a522 1
		} else if (pmode || patime || pmtime)
d524 1
d528 1
a528 1
		set_ftime(nm, arcn->sb.st_mtime, arcn->sb.st_atime, 0);
d568 1
d600 1
d607 1
a607 1
	if (*spt == '/')
d617 11
d640 2
a641 1
			*(spt++) = '/';
d675 2
a676 1
		*(spt++) = '/';
d689 1
a689 3
 *	other ones are left alone. We do not assume the un-documented feature
 *	of many utimes() implementations that consider a 0 time value as a do
 *	not set request.
d693 2
a694 1
set_ftime(char *fnm, time_t mtime, time_t atime, int frc)
d696 4
a699 2
	static struct timeval tv[2] = {{0L, 0L}, {0L, 0L}};
	struct stat sb;
d701 1
a701 3
	tv[0].tv_sec = (long)atime;
	tv[1].tv_sec = (long)mtime;
	if (!frc && (!patime || !pmtime)) {
d704 1
a704 1
		 * set. We get the current values of the times if we need them.
d706 4
a709 7
		if (lstat(fnm, &sb) == 0) {
			if (!patime)
				tv[0].tv_sec = (long)sb.st_atime;
			if (!pmtime)
				tv[1].tv_sec = (long)sb.st_mtime;
		} else
			syswarn(0,errno,"Unable to obtain file stats %s", fnm);
d715 1
a715 1
	if (utimes(fnm, tv) < 0)
a717 1
	return;
d721 2
a722 1
fset_ftime(char *fnm, int fd, time_t mtime, time_t atime, int frc)
d724 5
a728 2
	static struct timeval tv[2] = {{0L, 0L}, {0L, 0L}};
	struct stat sb;
d730 1
a730 3
	tv[0].tv_sec = (long)atime;
	tv[1].tv_sec = (long)mtime;
	if (!frc && (!patime || !pmtime)) {
d733 1
a733 1
		 * set. We get the current values of the times if we need them.
d735 4
a738 7
		if (fstat(fd, &sb) == 0) {
			if (!patime)
				tv[0].tv_sec = (long)sb.st_atime;
			if (!pmtime)
				tv[1].tv_sec = (long)sb.st_mtime;
		} else
			syswarn(0,errno,"Unable to obtain file stats %s", fnm);
d743 1
a743 1
	if (futimes(fd, tv) < 0)
a745 1
	return;
d758 1
a758 1
	if (chown(fnm, uid, gid) < 0) {
a789 24
 * set_lids()
 *	set the uid and gid of a file system node
 * Return:
 *	0 when set, -1 on failure
 */

int
set_lids(char *fnm, uid_t uid, gid_t gid)
{
	if (lchown(fnm, uid, gid) < 0) {
		/*
		 * ignore EPERM unless in verbose mode or being run by root.
		 * if running as pax, POSIX requires a warning.
		 */
		if (strcmp(NM_PAX, argv0) == 0 || errno != EPERM || vflag ||
		    geteuid() == 0)
			syswarn(1, errno, "Unable to set file uid/gid of %s",
			    fnm);
		return(-1);
	}
	return(0);
}

/*
d798 1
a798 1
	if (chmod(fnm, mode) < 0)
a799 1
	return;
a807 1
	return;
d811 56
d942 1
a942 1
		wcnt = MIN(cnt, *rem);
a1040 1
	return;
a1057 5
	(void)close(*fd);
	*fd = -1;
	if (!tflag)
		return;

d1061 6
a1066 2
	set_ftime(arcn->org_name, arcn->sb.st_mtime, arcn->sb.st_atime, 1);
	return;
d1120 1
a1120 1
	else if (arcn->sb.st_mtime != sb.st_mtime)
@


1.1.1.7
log
@backport OpenBSD pax erratum, more specifically:

• directory bug, symlinks with -C bug
• escaping with .. and symlinks
• tar without -P
• validate directories touched in the cleanup phase
@
text
@d60 4
a173 1
	int res;
d191 1
a191 12
	res = mk_link(arcn->ln_name, &sb, arcn->name, 0);
	if (res == 0) {
		/* check for a hardlink to a placeholder symlink */
		res = sltab_add_link(arcn->name, &sb);

		if (res < 0) {
			/* arrgh, it failed, clean up */
			unlink(arcn->name);
		}
	}

	return (res);
a294 1
			delete_dir(sb.st_dev, sb.st_ino);
d348 1
a348 1
	int len, defer_pmode = 0;
d408 1
a408 15
			if (arcn->ln_name[0] != '/' &&
			    !has_dotdot(arcn->ln_name))
				res = symlink(arcn->ln_name, nm);
			else {
				/*
				 * absolute symlinks and symlinks with ".."
				 * have to be deferred to prevent the archive
				 * from bootstrapping itself to outside the
				 * working directory.
				 */
				res = sltab_add_sym(nm, arcn->ln_name,
				    arcn->sb.st_mode);
				if (res == 0)
					defer_pmode = 1;
			}
d470 1
a470 1
	if (pmode && !defer_pmode)
d481 1
a481 2
		 * before pax exits.  To do that safely, we want the dev+ino
		 * of the directory we created.
d483 17
a499 13
		if (lstat(nm, &sb) < 0) {
			syswarn(0, errno,"Could not access %s (stat)", nm);
		} else if (access(nm, R_OK | W_OK | X_OK) < 0) {
			/*
			 * We have to add rights to the dir, so we make
			 * sure to restore the mode. The mode must be
			 * restored AS CREATED and not as stored if
			 * pmode is not set.
			 */
			set_pmode(nm,
			    ((sb.st_mode & FILEBITS) | S_IRWXU));
			if (!pmode)
				arcn->sb.st_mode = sb.st_mode;
d502 2
a503 3
			 * we have to force the mode to what was set
			 * here, since we changed it from the default
			 * as created.
a504 2
			arcn->sb.st_dev = sb.st_dev;
			arcn->sb.st_ino = sb.st_ino;
d506 1
a506 3
		} else if (pmode || patime || pmtime) {
			arcn->sb.st_dev = sb.st_dev;
			arcn->sb.st_ino = sb.st_ino;
a507 1
		}
a550 1
		delete_dir(sb.st_dev, sb.st_ino);
a811 54
 * set_attr()
 *	Given a DIRDATA, restore the mode and times as indicated, but
 *	only after verifying that it's the directory that we wanted.
 */
int
set_attr(const struct file_times *ft, int force_times, mode_t mode,
    int do_mode, int in_sig)
{
	struct stat sb;
	int fd, r;

	if (!do_mode && !force_times && !patime && !pmtime)
		return (0);

	/*
	 * We could legitimately go through a symlink here,
	 * so do *not* use O_NOFOLLOW.  The dev+ino check will
	 * protect us from evil.
	 */
	fd = open(ft->ft_name, O_RDONLY | O_DIRECTORY);
	if (fd == -1) {
		if (!in_sig)
			syswarn(1, errno, "Unable to restore mode and times"
			    " for directory: %s", ft->ft_name);
		return (-1);
	}

	if (fstat(fd, &sb) == -1) {
		if (!in_sig)
			syswarn(1, errno, "Unable to stat directory: %s",
			    ft->ft_name);
		r = -1;
	} else if (ft->ft_ino != sb.st_ino || ft->ft_dev != sb.st_dev) {
		if (!in_sig)
			paxwarn(1, "Directory vanished before restoring"
			    " mode and times: %s", ft->ft_name);
		r = -1;
	} else {
		/* Whew, it's a match!  Is there anything to change? */
		if (do_mode && (mode & ABITS) != (sb.st_mode & ABITS))
			fset_pmode(ft->ft_name, fd, mode);
		if (((force_times || patime) && ft->ft_atime != sb.st_atime) ||
		    ((force_times || pmtime) && ft->ft_mtime != sb.st_mtime))
			fset_ftime(ft->ft_name, fd, ft->ft_mtime,
			    ft->ft_atime, force_times);
		r = 0;
	}
	close(fd);

	return (r);
}


/*
d1004 5
d1012 2
a1013 6
	if (tflag)
		fset_ftime(arcn->org_name, *fd, arcn->sb.st_mtime,
		    arcn->sb.st_atime, 1);

	(void)close(*fd);
	*fd = -1;
@


1.1.1.8
log
@bunch of cherry-picks from OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.32 +1.46 +1.48 2009/12/22 12:08:30 jasper Exp $	*/
d86 1
a86 1
	if ((fd = open(arcn->name, O_WRONLY | O_CREAT | O_EXCL,
a608 1
	char *next;
d615 1
a615 1
	while (*spt == '/')
a624 11

		/*
		 * skip over duplicate slashes; stop if there're only
		 * trailing slashes left
		 */
		next = spt + 1;
		while (*next == '/')
			next++;
		if (*next == '\0')
			break;

d637 1
a637 2
			*spt = '/';
			spt = next;
d671 1
a671 2
		*spt = '/';
		spt = next;
@


1.1.1.9
log
@cherry-pick
    Only try to set the times on a directory once, at the end, to avoid
    duplication of warning messages
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.32 +1.46 +1.48 +1.50 2009/12/22 12:08:30 jasper Exp $	*/
d534 3
a536 1
	} else if (patime || pmtime)
@


1.1.1.10
log
@merge what OpenBSD did between our last cherry-pick and today minus one commit

(“Use the new libc uid_from_user() and gid_from_group() instead of
  the pax-specific functions in cache.c” is ignored, for now)
@
text
@d1 1
a1 1
/*	$OpenBSD: file_subs.c,v 1.53 2017/01/21 08:17:06 krw Exp $	*/
@


1.1.1.11
log
@Import latest OpenBSD paxtar, unmodified, into vendor branch
@
text
@d37 2
d40 1
a43 1
#include <limits.h>
d49 1
d151 2
a152 2
		fset_ftime(arcn->name, fd, &arcn->sb.st_mtim,
		    &arcn->sb.st_atim, 0);
d319 1
a319 1
		if (linkat(AT_FDCWD, to, AT_FDCWD, from, 0) == 0)
d355 1
a355 1
	char target[PATH_MAX];
d375 1
a375 1
			if (op_mode == OP_TAR && Lflag) {
d474 3
a476 1
		res = set_ids(nm, arcn->sb.st_uid, arcn->sb.st_gid);
d481 6
d496 1
a496 1
	if (arcn->type == PAX_DIR && op_mode != OP_CPIO) {
d535 1
a535 1
		set_ftime(nm, &arcn->sb.st_mtim, &arcn->sb.st_atim, 0);
d696 3
a698 1
 *	other ones are left alone.
d702 1
a702 2
set_ftime(const char *fnm, const struct timespec *mtimp,
    const struct timespec *atimp, int frc)
d704 2
a705 4
	struct timespec tv[2];

	tv[0] = *atimp;
	tv[1] = *mtimp;
d707 3
a709 1
	if (!frc) {
d712 1
a712 1
		 * set.
d714 7
a720 4
		if (!patime)
			tv[0].tv_nsec = UTIME_OMIT;
		if (!pmtime)
			tv[1].tv_nsec = UTIME_OMIT;
d726 1
a726 1
	if (utimensat(AT_FDCWD, fnm, tv, AT_SYMLINK_NOFOLLOW) < 0)
d729 1
d733 1
a733 2
fset_ftime(const char *fnm, int fd, const struct timespec *mtimp,
    const struct timespec *atimp, int frc)
d735 2
a736 2
	struct timespec tv[2];

d738 3
a740 4
	tv[0] = *atimp;
	tv[1] = *mtimp;

	if (!frc) {
d743 1
a743 1
		 * set.
d745 7
a751 4
		if (!patime)
			tv[0].tv_nsec = UTIME_OMIT;
		if (!pmtime)
			tv[1].tv_nsec = UTIME_OMIT;
d756 1
a756 1
	if (futimens(fd, tv) < 0)
d759 1
d772 1
a772 1
	if (fchownat(AT_FDCWD, fnm, uid, gid, AT_SYMLINK_NOFOLLOW) < 0) {
d777 1
a777 1
		if (op_mode == OP_PAX || errno != EPERM || vflag ||
d794 25
a818 1
		if (op_mode == OP_PAX || errno != EPERM || vflag ||
d836 1
a836 1
	if (fchmodat(AT_FDCWD, fnm, mode, AT_SYMLINK_NOFOLLOW) < 0)
d838 1
d847 1
d892 4
a895 6
		if (((force_times || patime) &&
		    timespeccmp(&ft->ft_atim, &sb.st_atim, !=)) ||
		    ((force_times || pmtime) &&
		    timespeccmp(&ft->ft_mtim, &sb.st_mtim, !=)))
			fset_ftime(ft->ft_name, fd, &ft->ft_mtim,
			    &ft->ft_atim, force_times);
d980 1
a980 1
		wcnt = MINIMUM(cnt, *rem);
d1002 1
a1002 1
				    lseek(fd, wcnt, SEEK_CUR) < 0) {
d1072 1
a1072 1
	if (lseek(fd, -1, SEEK_CUR) < 0) {
d1079 1
d1101 2
a1102 2
		fset_ftime(arcn->org_name, *fd, &arcn->sb.st_mtim,
		    &arcn->sb.st_atim, 1);
d1122 2
a1123 2
	off_t cpcnt = 0;
	size_t size;
d1132 1
a1132 1
		arcn->crc = 0;
d1136 2
a1137 2
	if ((size = arcn->sb.st_blksize) > sizeof(tbuf))
		size = sizeof(tbuf);
d1159 1
a1159 1
	else if (timespeccmp(&arcn->sb.st_mtim, &sb.st_mtim, !=))
d1161 1
a1161 1
	else if (lseek(fd, 0, SEEK_SET) < 0)
@


1.1.1.11.2.1
log
@normalise whitespace at EOL, EOF, adjacent newlines
@
text
@d722 1
d861 1
@


1.1.1.11.2.2
log
@a little KNF: sort the includes
@
text
@a45 1

d49 3
a56 2
static int mk_link(char *, struct stat *, char *, int);

@


1.1.1.11.2.3
log
@extremely rudimentary conversion to mirtoconf, doesn’t even build yet
@
text
@a44 3
#if HAVE_STRINGS_H
#include <strings.h>
#endif
d1079 1
a1079 1
	uint32_t crc = 0;
@


1.1.1.11.2.4
log
@make inroads on portability
@
text
@d1117 1
a1117 1
	else if (st_mtim_cmp(&arcn->sb, &sb, !=))
@


1.1.1.11.2.5
log
@do the ‘c’s
@
text
@d340 1
a340 1
 *	create an entry in the filesystem (other than a file or hard link).
d533 1
a533 1
 *	Remove node from filesystem with the specified name. We pass the type
d583 1
a583 1
 *	We were trying to create some kind of node in the filesystem and it
d589 1
a589 1
 *	last resort when trying to create entries in the filesystem.
d632 1
a632 1
		 * filesystem for nodes NOT EXPLICITLY stored on the archive.
d748 1
a748 1
 *	set the uid and gid of a filesystem node
d878 1
a878 1
 *	for write when passed the basic allocation size of a filesystem block,
d898 1
a898 1
 *	an empty block. A lot of filesystems will not create an lseek hole at
d902 1
a902 1
 *	rem: how many bytes left in this filesystem block
d927 1
a927 1
			 * We are now at the start of filesystem block again
d976 1
a976 1
		 * have non-zero data in this filesystem block, have to write
d1011 1
a1011 1
 *	when the last file block in a file is zero, many filesystems will not
@


1.1.1.11.2.6
log
@shove stuff into same-looking structures
@
text
@d851 1
a851 1
		    st_atim_cmp(&ft->sb, &sb, !=)) ||
d853 3
a855 3
		    st_mtim_cmp(&ft->sb, &sb, !=)))
			fset_ftime(ft->ft_name, fd, &ft->sb.st_mtim,
			    &ft->sb.st_atim, force_times);
@


1.1.1.11.2.7
log
@use generic macros, to compensate a bit for this insanity
@
text
@d851 1
a851 1
		    st_timecmp(a, &ft->sb, &sb, !=)) ||
d853 1
a853 1
		    st_timecmp(m, &ft->sb, &sb, !=)))
d1117 1
a1117 1
	else if (st_timecmp(m, &arcn->sb, &sb, !=))
@


1.1.1.11.2.8
log
@and the other half, modulo what’ll be yet merged anyway
@
text
@d151 2
a152 1
		fset_ftime(arcn->name, fd, &arcn->sb, 0);
d527 1
a527 1
		set_ftime(nm, &arcn->sb, 0);
d692 2
a693 1
set_ftime(const char *fnm, const struct stat *sbp, int frc)
d697 2
a698 2
	tv[0] = sbp->st_atim;
	tv[1] = sbp->st_mtim;
d720 2
a721 1
fset_ftime(const char *fnm, int fd, const struct stat *sbp, int frc)
d725 2
a726 2
	tv[0] = sbp->st_atim;
	tv[1] = sbp->st_mtim;
d850 6
a855 7
		if (((force_times || patime) && st_timecmp(a, &ft->sb, &sb, !=)) ||
		    ((force_times || pmtime) && st_timecmp(m, &ft->sb, &sb, !=))) {
			struct stat ftsb;
			st_timecpy(m, &ftsb, &ft->sb);
			st_timecpy(a, &ftsb, &ft->sb);
			fset_ftime(ft->ft_name, fd, &ftsb, force_times);
		}
d1059 2
a1060 1
		fset_ftime(arcn->org_name, *fd, &arcn->sb, 1);
@


1.1.1.11.2.9
log
@begin merging
@
text
@a4 7
 * Copyright (c) 2007, 2008, 2009, 2012, 2014, 2016, 2018
 *	mirabilos <m@@mirbsd.org>
 * Copyright (c) 2018
 *	Jonathan de Boyne Pollard <J.deBoynePollard-newsgroups@@NTLWorld.COM>
 *	mirabilos <t.glaser@@tarent.de>
 * Copyright (c) 2011
 *	Svante Signell <svante.signell@@telia.com>
a48 3
#if HAVE_UTIME_H
#include <utime.h>
#endif
d162 1
a162 2
 *	fd+2 if data should be extracted,
 *	0 if ok, 1 if we could not make the link, -1 otherwise
d166 1
a166 1
lnk_creat(ARCHD *arcn, int *fdp)
a197 13
	if (fdp != NULL && res == 0 && sb.st_size == 0 && arcn->skip > 0) {
		/* request to write out file data late (broken archive) */
		if (pmode)
			set_pmode(arcn->name, 0600, /*XXX I think */ 0);
		if ((*fdp = open(arcn->name, O_WRONLY | O_TRUNC)) == -1) {
			res = errno;
			syswarn(1, res, "Unable to re-open %s", arcn->name);
			if (pmode)
				set_pmode(arcn->name, sb.st_mode, 0);
		}
		res = 0;
	} else if (fdp != NULL)
		*fdp = -1;
a260 17
 * helper function to copy a symbolic link
 */

static int
mk_link_symlink(const char *to, const char *from)
{
	int cnt;
	char buf[PAXPATHLEN + 1];

	if ((cnt = readlink(to, buf, PAXPATHLEN)) < 0)
		return (-1);
	/* cf. comment in ftree.c:next_file() */
	buf[cnt] = '\0';
	return (symlink(buf, from));
}

/*
a320 5
		if (S_ISLNK(to_sb->st_mode)) {
			/* just copy the symlink */
			if (mk_link_symlink(to, from) == 0)
				break;
		}
a322 32
		/*-
		 * non-standard (via -M lncp) cross-device link handling:
		 * copy if hard link fails (but what if there are several
		 * links for the same file mixed between several devices?
		 * this code copies for all non-original devices, instead
		 * of tracking them and linking between them on their re-
		 * spective target device)
		 */
		if (oerrno == EXDEV && (anonarch & ANON_LNCP)) {
			int fdsrc, fddest;
			ARCHD tarcn;

			if ((fdsrc = open(to, O_RDONLY, 0)) < 0) {
				if (!ign)
					syswarn(1, errno,
					    "Unable to open %s to read", to);
				goto lncp_failed;
			}
			strlcpy(tarcn.name, from, sizeof(tarcn.name));
			memcpy(&tarcn.sb, to_sb, sizeof(struct stat));
			tarcn.type = PAX_REG;	/* XXX */
			tarcn.org_name = to;
			if ((fddest = file_creat(&tarcn)) < 0) {
				rdfile_close(&tarcn, &fdsrc);
				goto lncp_failed;
			}
			cp_file(&tarcn, fdsrc, fddest);
			file_close(&tarcn, fddest);
			rdfile_close(&tarcn, &fdsrc);
			/* file copied successfully, continue on */
			break;
		}
a323 1
 lncp_failed:
d354 1
a354 1
	char *target = NULL;
a376 8
/*XXX TODO: leak */
					target = malloc(sb.st_size + 1);
					if (target == NULL) {
						oerrno = ENOMEM;
						syswarn(1, oerrno,
						    "Out of memory");
						return (-1);
					}
d378 1
a378 1
					    sb.st_size + 1);
d392 1
a392 1
 badlink:
d485 1
a485 1
		set_pmode(nm, arcn->sb.st_mode, arcn->type == PAX_SLK);
d508 1
a508 1
			    ((sb.st_mode & FILEBITS) | S_IRWXU), 0);
d526 2
a527 2
		set_ftime(nm, &arcn->sb, 0, arcn->type == PAX_SLK);
	return (0);
d670 1
a670 1
			set_pmode(name, ((sb.st_mode & FILEBITS) | S_IRWXU), 0);
@


1.1.1.11.2.10
log
@fix the leak (I think)
@
text
@d433 1
a433 1
	char *allocd = NULL;
d456 2
a457 1
					char *target = malloc(sb.st_size + 1);
a458 1
						free(allocd);
a474 2
					free(allocd);
					allocd = target;
d501 1
a501 2
			free(allocd);
			return (-1);
d528 2
a529 3
			    nm);
			free(allocd);
			return (-1);
d544 2
a545 4
		if ((ign = unlnk_exist(nm, arcn->type)) < 0) {
			free(allocd);
			return (-1);
		}
d552 1
a552 2
			free(allocd);
			return (-1);
a613 1
	free(allocd);
@


1.1.1.11.2.11
log
@ugly ifdeffing for portability FTW
@
text
@a67 4
#if HAVE_FUTIMENS || HAVE_FUTIMES
#define PAX_FSET_FTIME
#endif

a68 3
#ifdef PAX_FSET_FTIME
static void fset_ftime(const char *, int, const struct stat *, int);
#endif
a159 1
#ifdef PAX_FSET_FTIME
a161 1
#endif
a358 1
#if HAVE_LINKAT
a359 3
#else
		if (link(to, from) == 0)
#endif
d567 1
a567 2
		res = ((arcn->type == PAX_SLK) ? set_lids : set_ids)(nm,
		    arcn->sb.st_uid, arcn->sb.st_gid);
d782 1
a782 3
 *	other ones are left alone. We do not assume the un-documented feature
 *	of many utimes() implementations that consider a 0 time value as a do
 *	not set request.
a811 1
#ifdef PAX_FSET_FTIME
d815 1
a815 6
#if HAVE_FUTIMENS
	struct timespec ts[2];
#else
	struct timeval tv[2];
	struct stat sb;
#endif
d817 2
a818 15
	/* pre-initialise values to set */
#if HAVE_FUTIMENS
	ts[0] = sbp->st_atim;
	ts[1] = sbp->st_mtim;
#else
	tv[0].tv_sec = sbp->st_atime;
	tv[1].tv_sec = sbp->st_mtime;
#if HAVE_ST_MTIMENSEC
	tv[0].tv_usec = sbp->st_atimensec / 1000L;
	tv[1].tv_usec = sbp->st_mtimensec / 1000L;
#else
	tv[0].tv_usec = 0;
	tv[1].tv_usec = 0;
#endif
#endif
d820 1
a820 1
	if (!frc && (!patime || !pmtime)) {
d822 2
a823 3
		 * If we are not forcing, only set those times the user
		 * wants set. We get the current values of the times if
		 * we need them (futimens does not).
a824 1
#if HAVE_FUTIMENS
d826 1
a826 1
			ts[0].tv_nsec = UTIME_OMIT;
d828 6
a833 25
			ts[1].tv_nsec = UTIME_OMIT;
#else
		if (fstat(fd, &sb) == 0) {
			if (!patime) {
				tv[0].tv_sec = sb.st_atime;
#if HAVE_ST_MTIMENSEC
				tv[0].tv_usec = sb.st_atimensec / 1000L;
#endif
			}
			if (!pmtime) {
				tv[1].tv_sec = sb.st_mtime;
#if HAVE_ST_MTIMENSEC
				tv[1].tv_usec = sb.st_mtimensec / 1000L;
#endif
			}
		} else
			syswarn(0, errno, "Unable to stat %s", fnm);
#endif

	/* set the times */
#if HAVE_FUTIMENS
	if (futimens(fd, ts) < 0)
#else
	if (futimes(fd, tv) < 0)
#endif
a836 1
#endif
a941 1
#ifdef PAX_FSET_FTIME
a948 1
#endif
a1150 1
#ifdef PAX_FSET_FTIME
a1152 1
#endif
@


1.1.1.11.2.12
log
@fixup the chaos
@
text
@d802 1
a802 2
set_ftime(const char *fnm, const struct stat *sbp, int frc,
    int issymlink MKSH_A_UNUSED)
d804 1
a804 15
#if HAVE_UTIMENSAT
	struct timespec ts[2];
#else
	struct {
		time_t tv_sec;
		long tv_nsec;
	} ts[2];
#if HAVE_UTIMES
	struct timeval tv[2];
#else
	struct utimbuf u;
#endif
	struct stat sb;
#endif
	int rv;
d806 2
a807 3
	/* pre-initialise values to set */
	st_timexp(a, &ts[0], sbp);
	st_timexp(m, &ts[1], sbp);
d809 1
a809 1
	if (!frc && (!patime || !pmtime)) {
d811 2
a812 3
		 * If we are not forcing, only set those times the user
		 * wants set. We get the current values of the times if
		 * we need them (utimensat does not).
a813 1
#if HAVE_UTIMENSAT
d815 1
a815 1
			ts[0].tv_nsec = UTIME_OMIT;
d817 1
a817 10
			ts[1].tv_nsec = UTIME_OMIT;
#else
		if (lstat(fnm, &sb) == 0) {
			if (!patime)
				st_timexp(a, &ts[0], &sb);
			if (!pmtime)
				st_timexp(m, &ts[1], &sb);
		} else
			syswarn(0, errno, "Unable to stat %s", fnm);
#endif
d820 4
a823 19
	/* set the times */
#if HAVE_UTIMENSAT
	rv = utimensat(AT_FDCWD, fnm, tv, AT_SYMLINK_NOFOLLOW);
#elif HAVE_UTIMES
	tv[0].tv_sec = ts[0].tv_sec;
	tv[0].tv_usec = ts[0].tv_nsec / 1000;
	tv[1].tv_sec = ts[1].tv_sec;
	tv[1].tv_usec = ts[1].tv_nsec / 1000;
	rv = (issymlink ? lutimes : utimes)(fnm, tv);
#else
	if (issymlink)
		/* no can do */
		return;
	u.actime = ts[0].tv_sec;
	u.modtime = ts[1].tv_sec;
	rv = utime(fnm, &u);
#endif

	if (rv < 0)
d829 1
a829 1
static void
a834 4
	struct {
		time_t tv_sec;
		long tv_nsec;
	} ts[2];
a837 1
	int rv;
d840 14
a853 2
	st_timexp(a, &ts[0], sbp);
	st_timexp(m, &ts[1], sbp);
d868 12
a879 4
			if (!patime)
				st_timexp(a, &ts[0], &sb);
			if (!pmtime)
				st_timexp(m, &ts[1], &sb);
a882 1
	}
d886 1
a886 1
	rv = futimens(fd, ts);
d888 1
a888 5
	tv[0].tv_sec = ts[0].tv_sec;
	tv[0].tv_usec = ts[0].tv_nsec / 1000;
	tv[1].tv_sec = ts[1].tv_sec;
	tv[1].tv_usec = ts[1].tv_nsec / 1000;
	rv = futimes(fd, tv);
a889 1
	if (rv < 0)
@


1.1.1.11.2.13
log
@fclownat vs lchown
@
text
@d580 2
a581 2
		res = set_ids(nm, arcn->sb.st_uid, arcn->sb.st_gid,
		    arcn->type == PAX_SLK);
d769 1
a769 1
			(void)set_ids(name, st_uid, st_gid, 0);
a855 3
	if (rv < 0 && issymlink && (errno == ENOSYS || errno == ENOTSUP))
		/* might be glibc */
		return;
d936 1
a936 1
set_ids(char *fnm, uid_t uid, gid_t gid, int issymlink MKSH_A_UNUSED)
d938 1
a938 17
	int rv;

#if HAVE_FCHOWNAT
	rv = fchownat(AT_FDCWD, fnm, uid, gid, AT_SYMLINK_NOFOLLOW);
#elif HAVE_LCHOWN
	rv = (issymlink ? lchown : chown)(fnm, uid, gid);
	if (rv < 0 && issymlink && (errno == ENOSYS || errno == ENOTSUP))
		/* might be glibc */
		return (0);
#else
	if (issymlink)
		/* no can do */
		return (0);
	rv = chown(fnm, uid, gid);
#endif

	if (rv < 0) {
d943 2
a944 5
		if (/* portability, imake style though */
#ifndef __INTERIX
		    errno != EPERM || vflag || geteuid() == 0 ||
#endif
		    op_mode == OP_PAX)
d947 1
a947 1
		return (-1);
d949 1
a949 1
	return (0);
d960 2
a961 5
		if (/* portability, imake style though */
#ifndef __INTERIX
		    errno != EPERM || vflag || geteuid() == 0 ||
#endif
		    op_mode == OP_PAX)
d964 1
a964 1
		return (-1);
d966 1
a966 1
	return (0);
@


1.1.1.11.2.14
log
@the last *at() dance, the most broken one
@
text
@d1000 1
a1000 1
set_pmode(char *fnm, mode_t mode, int issymlink MKSH_A_UNUSED)
a1001 2
	int rv;

d1003 1
a1003 20
#if HAVE_FCHMODAT
	rv = fchmodat(AT_FDCWD, fnm, mode, AT_SYMLINK_NOFOLLOW);
	if (rv < 0 && (errno == ENOSYS || errno == ENOTSUP)) {
		/* glibc sucks */
		if (issymlink)
			return;
		rv = chmod(fnm, mode);
	}
#elif HAVE_LCHMOD
	rv = (issymlink ? lchmod : chmod)(fnm, mode);
	if (rv < 0 && issymlink && (errno == ENOSYS || errno == ENOTSUP))
		/* similarily glibc */
		return;
#else
	if (issymlink)
		/* no can do */
		return (0);
	rv = chmod(fnm, mode);
#endif
	if (rv < 0)
@


1.1.1.11.2.15
log
@do the ‘f’s
@
text
@d1056 1
a1056 5
	fd = open(ft->ft_name,
#ifdef O_DIRECTORY
	    O_DIRECTORY |
#endif
	    O_RDONLY);
a1068 7
#ifndef O_DIRECTORY
	} else if (!S_ISDIR(sb.st_mode)) {
		if (!in_sig)
			syswarn(1, ENOTDIR, "Unable to restore mode and times"
			    " for directory: %s", ft->ft_name);
		r = -1;
#endif
d1193 3
a1195 5
					if (errno == ESPIPE)
						goto isapipe;
					syswarn(1, errno,
					    "File seek on %s", name);
					return (-1);
a1199 1
 isapipe:
@


1.1.1.11.2.16
log
@some more tweaks
@
text
@a44 8
#if HAVE_BOTH_TIME_H
#include <sys/time.h>
#include <time.h>
#elif HAVE_SYS_TIME_H
#include <sys/time.h>
#elif HAVE_TIME_H
#include <time.h>
#endif
a60 1
#include "ftimes.h"
@


1.1.1.11.2.17
log
@ok, so we really have to embed a whole struct stat

“time_t st_atimespec.tv_sec;” in a struct definition is bogus,
and I really don’t wish to hack around and accomodate this… thing
@
text
@d1100 6
a1105 2
		    ((force_times || pmtime) && st_timecmp(m, &ft->sb, &sb, !=)))
			fset_ftime(ft->ft_name, fd, &ft->sb, force_times);
@


1.1.1.11.2.18
log
@solution for rare open flags, also uses O_BINARY like in mksh
@
text
@d112 1
a112 1
	if ((fd = binopen3(0, arcn->name, O_WRONLY | O_CREAT | O_EXCL,
d114 1
a114 1
		return (fd);
d130 1
a130 1
		if ((fd = binopen3(0, arcn->name, O_WRONLY | O_CREAT | O_TRUNC,
d231 1
a231 1
		if ((*fdp = binopen2(0, arcn->name, O_WRONLY | O_TRUNC)) == -1) {
d403 1
a403 1
			if ((fdsrc = binopen3(0, to, O_RDONLY, 0)) < 0) {
d1065 5
a1069 1
	fd = binopen2(BO_MAYBE_DIR, ft->ft_name, O_RDONLY);
@


1.1.1.11.2.19
log
@various bugfixes and a system header issue workaround in Makefile
@
text
@d1293 1
a1293 1
rdfile_close(ARCHD *arcn MKSH_A_UNUSED, int *fd)
@


