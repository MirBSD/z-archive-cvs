head	1.6;
access;
symbols
	MIRBSD_9_BASE:1.5
	MIRBSD_8:1.4.0.2
	MIRBSD_8_BASE:1.4;
locks; strict;
comment	@ * @;


1.6
date	2007.03.19.15.31.47;	author tg;	state dead;
branches;
next	1.5;
commitid	10045FEABF71FCB0511;

1.5
date	2006.03.27.20.42.52;	author tg;	state Exp;
branches;
next	1.4;
commitid	10044284E592FC199A3;

1.4
date	2005.07.23.20.33.23;	author tg;	state Exp;
branches;
next	1.3;
commitid	184042e2a997cde1;

1.3
date	2005.07.23.19.42.26;	author tg;	state Exp;
branches;
next	1.2;
commitid	3d8c42e29db25746;

1.2
date	2005.07.23.19.16.50;	author tg;	state Exp;
branches;
next	1.1;
commitid	4d6b42e297aecfde;

1.1
date	2005.07.23.19.05.59;	author tg;	state Exp;
branches;
next	;
commitid	396b42e295286a46;


desc
@@


1.6
log
@nuke nbsh(1) – I switched back to mksh(1) as /bin/sh a while ago due to
bugs in nbsh(1) which will be made available as port, and it's cruel
code, using strcpy(3) et al. all over the place; using mksh as /bin/sh
will lead to less portable shell scripting in our base system, some of
which can then only be detected when using the bash, ash, nbsh, pdksh,
zsh or Heirloom sh ports (some of which are to be done…), but actually
I somehow don't care.

I guess the policy, starting from now, is:
• use “#!/bin/mksh” or, if it's not definitively MirOS-only,
  use “#!/usr/bin/env mksh” instead; do *not* use “#!/bin/sh”
  if you use any extensions unless it's for the common subset
  of bash and mksh and that's clearly documented (or it uses
  some kind of re-exec technique like src/etc/rc,v 1.62)
• make(1) – MirMake – has been using mksh for a while
• stuff that's run with /bin/sh from the base system, i.e.
  /etc/rc and friends, are OK to use mksh witho̲u̲t̲ a re-exec
  technique, starting from now
@
text
@/* $MirOS: src/bin/sh/init.c,v 1.5 2006/03/27 20:42:52 tg Exp $ */
/*
 * This file was generated by the mkinit program.
 */

#include "shell.h"
#include "mystring.h"
#include "init.h"
#include "eval.h"
#include <stdio.h>
#include "input.h"
#include "error.h"
#include <stdlib.h>
#include "options.h"
#include "redir.h"
#include <signal.h>
#include "trap.h"
#include "output.h"
#include "memalloc.h"
#include "var.h"

__RCSID("$MirOS: src/bin/sh/init.c,v 1.5 2006/03/27 20:42:52 tg Exp $");

#undef  ATABSIZE
#define ATABSIZE 39
#undef  MAXPWD
#define MAXPWD 256
#undef  ALL
#define ALL (E_OPEN|E_CREAT|E_EXEC)
#undef  EV_EXIT
#define EV_EXIT 01		/* exit after evaluating tree */
#undef  EV_TESTED
#define EV_TESTED 02		/* exit status is checked; ignore -e flag */
#undef  EV_BACKCMD
#define EV_BACKCMD 04		/* command executing within back quotes */
#undef  CMDTABLESIZE
#define CMDTABLESIZE 31		/* should be prime */
#undef  ARB
#define ARB 1			/* actual size determined at run time */
#undef  NEWARGS
#define NEWARGS 5
#undef  MAXHISTLOOPS
#define MAXHISTLOOPS	4	/* max recursions through fc */
#undef  DEFEDITOR
#define DEFEDITOR	"ed"	/* default editor *should* be $EDITOR */
#undef  editing
#define editing (Eflag || Vflag)
#undef  EOF_NLEFT
#define EOF_NLEFT -99		/* value of parsenleft when EOF pushed back */
#undef  MAXMBOXES
#define MAXMBOXES 10
#undef  PROFILE
#define PROFILE 0
#undef  SIGSSIZE
#define SIGSSIZE (sizeof(sigs)/sizeof(sigs[0]))
#undef  MINSIZE
#define MINSIZE 504		/* minimum size of a block */
#undef  DEFINE_OPTIONS
#define DEFINE_OPTIONS
#undef  EOFMARKLEN
#define EOFMARKLEN 79
#undef  OPENBRACE
#define OPENBRACE '{'
#undef  CLOSEBRACE
#define CLOSEBRACE '}'
#undef  EMPTY
#define EMPTY -2		/* marks an unused slot in redirtab */
#undef  S_DFL
#define S_DFL 1			/* default signal handling (SIG_DFL) */
#undef  S_CATCH
#define S_CATCH 2		/* signal is caught */
#undef  S_IGN
#define S_IGN 3			/* signal is ignored (SIG_IGN) */
#undef  S_HARD_IGN
#define S_HARD_IGN 4		/* signal is ignored permenantly */
#undef  S_RESET
#define S_RESET 5		/* temporary - to reset a hard ignored sig */
#undef  OUTBUFSIZ
#define OUTBUFSIZ BUFSIZ
#undef  BLOCK_OUT
#define BLOCK_OUT -2		/* output to a fixed block of memory */
#undef  MEM_OUT
#define MEM_OUT -3		/* output to dynamically allocated memory */
#undef  OUTPUT_ERR
#define OUTPUT_ERR 01		/* error occurred on output */
#undef  TEMPSIZE
#define TEMPSIZE 24
#undef  HAVE_VASPRINTF
#define HAVE_VASPRINTF 1
#undef  VTABSIZE
#define VTABSIZE 39
#undef  VTABSIZE
#define VTABSIZE 517

extern void rmaliases(void);

extern int loopnest;		/* current loop nesting level */

extern void deletefuncs(void);
extern void hash_special_builtins(void);

struct strpush {
	struct strpush *prev;	/* preceding string on stack */
	char *prevstring;
	int prevnleft;
	int prevlleft;
	struct alias *ap;	/* if push was associated with an alias */
};

struct parsefile {
	struct parsefile *prev;	/* preceding file on stack */
	int linno;		/* current line */
	int fd;			/* file descriptor (or -1 if string) */
	int nleft;		/* number of chars left in this line */
	int lleft;		/* number of chars left in this buffer */
	char *nextc;		/* next char in buffer */
	char *buf;		/* input buffer */
	struct strpush *strpush; /* for pushing strings at this level */
	struct strpush basestrpush; /* so pushing one is fast */
};

extern int parselleft;		/* copy of parsefile->lleft */
extern struct parsefile basepf;	/* top level input file */
extern char basebuf[BUFSIZ];	/* buffer for top level input file */

extern pid_t backgndpid;	/* pid of last background process */
extern int jobctl;

extern int tokpushback;		/* last token pushed back */
extern int checkkwd;            /* 1 == check for kwds, 2 == also eat newlines */

struct redirtab {
	struct redirtab *next;
	short renamed[10];
};

extern struct redirtab *redirlist;

extern char sigmode[NSIG];	/* current value of signal */

extern char **environ;

/*
 * Initialization code.
 */

void
init(void) {

      /* from /usr/src/bin/sh/exec.c: */
      {
	      hash_special_builtins();
      }

      /* from /usr/src/bin/sh/input.c: */
      {
	      basepf.nextc = basepf.buf = basebuf;
      }

      /* from /usr/src/bin/sh/var.c: */
      {
	      char **envp;

	      initvar();
	      for (envp = environ ; *envp ; envp++) {
		      if (strchr(*envp, '=') && strncmp(*envp, "RANDOM=", 7)) {
			      setvareq(*envp, VEXPORT|VTEXTFIXED);
		      }
	      }
      }
}

/*
 * This routine is called when an error or an interrupt occurs in an
 * interactive shell and control is returned to the main command loop.
 */

void
reset(void) {

      /* from /usr/src/bin/sh/eval.c: */
      {
	      evalskip = 0;
	      loopnest = 0;
	      funcnest = 0;
      }

      /* from /usr/src/bin/sh/input.c: */
      {
	      if (exception != EXSHELLPROC)
		      parselleft = parsenleft = 0;	/* clear input buffer */
	      popallfiles();
      }

      /* from /usr/src/bin/sh/parser.c: */
      {
	      tokpushback = 0;
	      checkkwd = 0;
      }

      /* from /usr/src/bin/sh/redir.c: */
      {
	      while (redirlist)
		      popredir();
      }

      /* from /usr/src/bin/sh/output.c: */
      {
	      out1 = &output;
	      out2 = &errout;
	      if (memout.buf != NULL) {
		      ckfree(memout.buf);
		      memout.buf = NULL;
	      }
      }
}

/*
 * This routine is called to initialize the shell to run a shell procedure.
 */

void
initshellproc(void) {

      /* from /usr/src/bin/sh/alias.c: */
      {
	      rmaliases();
      }

      /* from /usr/src/bin/sh/eval.c: */
      {
	      exitstatus = 0;
      }

      /* from /usr/src/bin/sh/exec.c: */
      {
	      deletefuncs();
      }

      /* from /usr/src/bin/sh/input.c: */
      {
	      popallfiles();
      }

      /* from /usr/src/bin/sh/jobs.c: */
      {
	      backgndpid = -1;
	      jobctl = 0;
      }

      /* from /usr/src/bin/sh/options.c: */
      {
	      int i;

	      for (i = 0; optlist[i].name; i++)
		      optlist[i].val = 0;
	      optschanged();

      }

      /* from /usr/src/bin/sh/redir.c: */
      {
	      clearredir(0);
      }

      /* from /usr/src/bin/sh/trap.c: */
      {
	      char *sm;

	      clear_traps(0);
	      for (sm = sigmode ; sm < sigmode + NSIG ; sm++) {
		      if (*sm == S_IGN)
			      *sm = S_HARD_IGN;
	      }
      }

      /* from /usr/src/bin/sh/var.c: */
      {
	      shprocvar();
      }
}
@


1.5
log
@implement our arc4random-based $RANDOM here, too
@
text
@d1 1
a1 1
/* $MirOS: src/bin/sh/init.c,v 1.4 2005/07/23 20:33:23 tg Exp $ */
d22 1
a22 1
__RCSID("$MirOS$");
@


1.4
log
@more build fixes for __CRAZY (not finished), and cleanup
@
text
@d1 1
a1 1
/* $MirOS: src/bin/sh/init.c,v 1.3 2005/07/23 19:42:26 tg Exp $ */
d22 2
d166 1
a166 1
		      if (strchr(*envp, '=')) {
@


1.3
log
@clean up some of the #ifdef madness
@
text
@d1 1
a1 1
/* $MirOS: src/bin/sh/init.c,v 1.2 2005/07/23 19:16:50 tg Exp $ */
a21 2


a92 2


a140 2


d146 1
a146 1
init() {
a170 2


d177 1
a177 1
reset() {
a215 2


d221 1
a221 1
initshellproc() {
@


1.2
log
@* remove some problematic defines
* fix inclusion path
@
text
@d1 1
a1 1
/* $MirOS$ */
a255 1
#if JOBS
a256 1
#endif
@


1.1
log
@add generated source files
@
text
@d1 1
a27 2
#undef  main
#define	main	echocmd
a93 2
#undef  main
#define main killcmd
@

