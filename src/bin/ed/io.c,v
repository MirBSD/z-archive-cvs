head	1.7;
access;
symbols
	cvs-201804291800:1.1.1.4
	cvs-201704021600:1.1.1.3
	cvs-201611061700:1.1.1.3
	cvs-201104091530:1.1.1.2
	MIRBSD_10:1.2.0.4
	MIRBSD_10_BASE:1.2
	MIRBSD_9_BASE:1.2
	MIRBSD_8:1.2.0.2
	MIRBSD_8_BASE:1.2
	cvs-200507211800:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2018.04.29.18.17.37;	author tg;	state Exp;
branches;
next	1.6;
commitid	1005AE60C5B58CC813A;

1.6
date	2016.11.06.18.58.44;	author tg;	state Exp;
branches;
next	1.5;
commitid	100581F7D79676B0355;

1.5
date	2012.01.04.21.57.44;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004F04CB6F09F9D6F7;

1.4
date	2011.04.09.16.47.07;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004DA08DA1052D2486;

1.3
date	2011.04.09.16.28.48;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004DA0890A2EA8ED27;

1.2
date	2005.03.06.18.55.19;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.05.17.22.04;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.22.04;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.04.09.15.54.12;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	1004DA081363B8A3AA8;

1.1.1.3
date	2016.11.06.17.31.57;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	100581F69214EA355AF;

1.1.1.4
date	2018.04.29.18.11.52;	author tg;	state Exp;
branches;
next	;
commitid	1005AE60AF7585D8E88;


desc
@@


1.7
log
@fullmerge
@
text
@/*	$OpenBSD: io.c,v 1.21 2018/04/26 12:18:54 martijn Exp $	*/
/*	$NetBSD: io.c,v 1.2 1995/03/21 09:04:43 cgd Exp $	*/

/* io.c: This file contains the i/o routines for the ed line editor */
/*-
 * Copyright (c) 1993 Andrew Moore, Talke Studio.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <regex.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "ed.h"

__RCSID("$MirOS: src/bin/ed/io.c,v 1.6 2016/11/06 18:58:44 tg Exp $");

static int read_stream(FILE *, int);
static int get_stream_line(FILE *);
static int write_stream(FILE *, int, int);
static int put_stream_line(FILE *, char *, int);

extern int scripted;

/* read_file: read a named file/pipe into the buffer; return line count */
int
read_file(char *fn, int n)
{
	FILE *fp;
	int size;


	fp = (*fn == '!') ? popen(fn + 1, "r") : fopen(strip_escapes(fn), "r");
	if (fp == NULL) {
		perror(fn);
		seterrmsg("cannot open input file");
		return ERR;
	} else if ((size = read_stream(fp, n)) < 0)
		return ERR;
	 else if (((*fn == '!') ?  pclose(fp) : fclose(fp)) < 0) {
		perror(fn);
		seterrmsg("cannot close input file");
		return ERR;
	}
	if (!scripted)
		fprintf(stderr, "%d\n", size);
	return current_addr - n;
}


static char *sbuf;		/* file i/o buffer */
static int sbufsz;		/* file i/o buffer size */
int newline_added;		/* if set, newline appended to input file */

/* read_stream: read a stream into the editor buffer; return status */
static int
read_stream(FILE *fp, int n)
{
	line_t *lp = get_addressed_line_node(n);
	undo_t *up = NULL;
	unsigned int size = 0;
	int o_newline_added = newline_added;
	int o_isbinary = isbinary;
	int appended = (n == addr_last);
	int len;

	isbinary = newline_added = 0;
	for (current_addr = n; (len = get_stream_line(fp)) > 0; size += len) {
		SPL1();
		if (put_sbuf_line(sbuf) == NULL) {
			SPL0();
			return ERR;
		}
		lp = lp->q_forw;
		if (up)
			up->t = lp;
		else if ((up = push_undo_stack(UADD, current_addr,
		    current_addr)) == NULL) {
			SPL0();
			return ERR;
		}
		SPL0();
	}
	if (len < 0)
		return ERR;
	if (appended && size && o_isbinary && o_newline_added)
		fputs("newline inserted\n", stderr);
	else if (newline_added && (!appended || (!isbinary && !o_isbinary)))
		fputs("newline appended\n", stderr);
	if (isbinary && newline_added && !appended)
	    	size += 1;
	if (!size)
		newline_added = 1;
	newline_added = appended ? newline_added : o_newline_added;
	isbinary = isbinary | o_isbinary;
	return size;
}

/* get_stream_line: read a line of text from a stream; return line length */
static int
get_stream_line(FILE *fp)
{
	int c;
	int i = 0;

	while (((c = getc(fp)) != EOF || (!feof(fp) &&
	    !ferror(fp))) && c != '\n') {
		REALLOC(sbuf, sbufsz, i + 1, ERR);
		if (!(sbuf[i++] = c))
			isbinary = 1;
	}
	REALLOC(sbuf, sbufsz, i + 2, ERR);
	if (c == '\n')
		sbuf[i++] = c;
	else if (ferror(fp)) {
		perror(NULL);
		seterrmsg("cannot read input file");
		return ERR;
	} else if (i) {
		sbuf[i++] = '\n';
		newline_added = 1;
	}
	sbuf[i] = '\0';
	return (isbinary && newline_added && i) ? --i : i;
}


/* write_file: write a range of lines to a named file/pipe; return line count */
int
write_file(const char *fn, const char *mode, int n, int m)
{
	FILE *fp;
	int size;

	fp = (*fn == '!') ? popen(fn+1, "w") : fopen(strip_escapes(fn), mode);
	if (fp == NULL) {
		perror(fn);
		seterrmsg("cannot open output file");
		return ERR;
	} else if ((size = write_stream(fp, n, m)) < 0)
		return ERR;
	 else if (((*fn == '!') ?  pclose(fp) : fclose(fp)) < 0) {
		perror(fn);
		seterrmsg("cannot close output file");
		return ERR;
	}
	if (!scripted)
		fprintf(stderr, "%d\n", size);
	return n ? m - n + 1 : 0;
}


/* write_stream: write a range of lines to a stream; return status */
static int
write_stream(FILE *fp, int n, int m)
{
	line_t *lp = get_addressed_line_node(n);
	unsigned int size = 0;
	char *s;
	int len;

	for (; n && n <= m; n++, lp = lp->q_forw) {
		if ((s = get_sbuf_line(lp)) == NULL)
			return ERR;
		len = lp->len;
		if (n != addr_last || !isbinary || !newline_added)
			s[len++] = '\n';
		if (put_stream_line(fp, s, len) < 0)
			return ERR;
		size += len;
	}
	return size;
}


/* put_stream_line: write a line of text to a stream; return status */
static int
put_stream_line(FILE *fp, char *s, int len)
{
	while (len--) {
		if (fputc(*s, fp) < 0) {
			perror(NULL);
			seterrmsg("cannot write file");
			return ERR;
		}
		s++;
	}
	return 0;
}

/* get_extended_line: get a an extended line from stdin */
char *
get_extended_line(int *sizep, int nonl)
{
	static char *cvbuf = NULL;		/* buffer */
	static int cvbufsz = 0;			/* buffer size */

	int l, n;
	char *t = ibufp;

	while (*t++ != '\n')
		;
	if ((l = t - ibufp) < 2 || !has_trailing_escape(ibufp, ibufp + l - 1)) {
		*sizep = l;
		return ibufp;
	}
	*sizep = -1;
	REALLOC(cvbuf, cvbufsz, l, NULL);
	memcpy(cvbuf, ibufp, l);
	*(cvbuf + --l - 1) = '\n'; 	/* strip trailing esc */
	if (nonl)
		l--; 			/* strip newline */
	for (;;) {
		if ((n = get_tty_line()) < 0)
			return NULL;
		else if (n == 0 || ibuf[n - 1] != '\n') {
			seterrmsg("unexpected end-of-file");
			return NULL;
		}
		REALLOC(cvbuf, cvbufsz, l + n, NULL);
		memcpy(cvbuf + l, ibuf, n);
		l += n;
		if (n < 2 || !has_trailing_escape(cvbuf, cvbuf + l - 1))
			break;
		*(cvbuf + --l - 1) = '\n'; 	/* strip trailing esc */
		if (nonl) l--; 			/* strip newline */
	}
	REALLOC(cvbuf, cvbufsz, l + 1, NULL);
	cvbuf[l] = '\0';
	*sizep = l;
	return cvbuf;
}


/* get_tty_line: read a line of text from stdin; return line length */
int
get_tty_line(void)
{
	int oi = 0;
	int i = 0;
	int c;

	for (;;)
		switch (c = getchar()) {
		default:
			oi = 0;
			REALLOC(ibuf, ibufsz, i + 2, ERR);
			if (!(ibuf[i++] = c)) isbinary = 1;
			if (c != '\n')
				continue;
			lineno++;
			ibuf[i] = '\0';
			ibufp = ibuf;
			return i;
		case EOF:
			if (ferror(stdin)) {
				perror("stdin");
				seterrmsg("cannot read stdin");
				clearerr(stdin);
				ibufp = NULL;
				return ERR;
			} else {
				clearerr(stdin);
				if (i != oi) {
					oi = i;
					continue;
				} else if (i)
					ibuf[i] = '\0';
				ibufp = ibuf;
				return i;
			}
		}
}



#define ESCAPES "\a\b\f\n\r\t\v\\$"
#define ESCCHARS "abfnrtv\\$"

extern int rows;
extern int cols;

/* put_tty_line: print text to stdout */
int
put_tty_line(char *s, int l, int n, int gflag)
{
	int col = 0;
#ifndef BACKWARDS
	int lc = 0;
#endif
	char *cp;

	if (gflag & GNP) {
		printf("%d\t", n);
		col = 8;
	}
	for (; l--; s++) {
		if ((gflag & GLS) && ++col > cols) {
			fputs("\\\n", stdout);
			col = 1;
#ifndef BACKWARDS
			if (!scripted && !isglobal && ++lc > rows) {
				lc = 0;
				fputs("Press <RETURN> to continue... ", stdout);
				fflush(stdout);
				if (get_tty_line() < 0)
					return ERR;
			}
#endif
		}
		if (gflag & GLS) {
			if (31 < *s && *s < 127 && *s != '\\' && *s != '$')
				putchar(*s);
			else {
				putchar('\\');
				col++;
				if (*s && (cp = strchr(ESCAPES, *s)) != NULL)
					putchar(ESCCHARS[cp - ESCAPES]);
				else {
					putchar((((unsigned char) *s & 0300) >> 6) + '0');
					putchar((((unsigned char) *s & 070) >> 3) + '0');
					putchar(((unsigned char) *s & 07) + '0');
					col += 2;
				}
			}

		} else
			putchar(*s);
	}
	if (gflag & GLS)
		putchar('$');
	putchar('\n');
	return 0;
}
@


1.6
log
@preliminary merge
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.19 2016/03/22 17:58:28 mmcc Exp $	*/
d39 1
a39 1
__RCSID("$MirOS: src/bin/ed/io.c,v 1.5 2012/01/04 21:57:44 tg Exp $");
d68 2
a69 1
	fprintf(stderr, !scripted ? "%d\n" : "", size);
d170 2
a171 1
	fprintf(stderr, !scripted ? "%d\n" : "", size);
d300 2
a301 2
#define ESCAPES "\a\b\f\n\r\t\v\\"
#define ESCCHARS "abfnrtv\\"
d335 1
a335 1
			if (31 < *s && *s < 127 && *s != '\\')
a352 1
#ifndef BACKWARDS
a354 1
#endif
@


1.5
log
@cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.15 2009/10/28 15:40:47 deraadt Exp $	*/
d31 6
d39 6
a44 1
__RCSID("$MirOS: src/bin/ed/io.c,v 1.4 2011/04/09 16:47:07 tg Exp $");
d73 2
a74 11
#ifdef DES
extern int des;
#define DESGETCHAR(fp) (des ? get_des_char((fp)) : getc((fp)))
#define DESPUTCHAR(c, fp) (des ? put_des_char((c), (fp)) : fputc((c), (fp)))
#else
#define DESGETCHAR(fp) (getc((fp)))
#define DESPUTCHAR(c, fp) (fputc((c), (fp)))
#endif

char *sbuf;			/* file i/o buffer */
int sbufsz;			/* file i/o buffer size */
d78 1
a78 1
int
a89 4
#ifdef DES
	if (des)
		init_des_cipher();
#endif
a117 5
#ifdef DES
	if (des)
		/* adjust DES size */
		size += 8 - size % 8;
#endif
a120 1

d122 1
a122 1
int
d128 1
a128 1
	while (((c = DESGETCHAR(fp)) != EOF || (!feof(fp) &&
d175 1
a175 1
int
a182 4
#ifdef DES
	if (des)
		init_des_cipher();
#endif
a192 6
#ifdef DES
	if (des) {
		flush_des_file(fp);			/* flush buffer */
		size += 8 - size % 8;			/* adjust DES size */
	}
#endif
d198 1
a198 1
int
d202 1
a202 1
		if (DESPUTCHAR(*s, fp) < 0) {
@


1.4
log
@make __CRAZY clean
@
text
@d33 1
a33 1
__RCSID("$MirOS$");
d62 1
d64 6
d120 1
d122 3
a124 1
		size += 8 - size % 8;			/* adjust DES size */
a127 5
#ifdef DES
#define DESGETCHAR(fp) (des ? get_des_char((fp)) : getc((fp)))
#else
#define DESGETCHAR(fp) (getc((fp)))
#endif
a213 6
#ifdef DES
#define DESPUTCHAR(c, fp) (des ? put_des_char((c), (fp)) : fputc((c), (fp)))
#else
#define DESPUTCHAR(c, fp) (fputc((c), (fp)))
#endif

@


1.3
log
@ed:
• merge openbsd
• sync portmdoc in manpage with template
• reduce diff against openbsd
• pimp

strlfun:
• add GNUmakefile embedded in C code


⇒ both: make this possible:

tg@@frozenfish:~ $ DIST=etch sudo cowbuilder --login
root@@frozenfish:/tmp# make -f strlfun.c
root@@frozenfish:/tmp/ed# make LDFLAGS=-L.. LDADD=-lstrlfun
root@@frozenfish:/tmp/ed# ./ed
@
text
@d33 1
d155 1
a155 1
write_file(char *fn, char *mode, int n, int m)
@


1.2
log
@merge src/bin
@
text
@d1 1
a1 2
/**	$MirOS$ */
/*	$OpenBSD: io.c,v 1.11 2003/06/11 23:42:12 deraadt Exp $	*/
a32 2
__SCCSID("@@(#)io.c,v 1.1 1994/02/01 00:34:41 alm Exp");
__RCSID("$MirOS$");
d56 1
a56 1
	fprintf(stderr, !scripted ? "%lu\n" : "", (long)size);
d80 1
d83 1
d117 5
d130 1
a130 1
	while (((c = des ? get_des_char(fp) : getc(fp)) != EOF || (!feof(fp) &&
d171 1
a171 1
	fprintf(stderr, !scripted ? "%lu\n" : "", (long)size);
d185 1
d188 1
d199 1
d204 1
d208 6
d219 2
a220 2
	while (len--)
		if ((des ? put_des_char(*s++, fp) : fputc(*s++, fp)) < 0) {
d225 2
@


1.1
log
@Initial revision
@
text
@d1 1
a31 8
#ifndef lint
#if 0
static char *rcsid = "@@(#)io.c,v 1.1 1994/02/01 00:34:41 alm Exp";
#else
static char rcsid[] = "$OpenBSD: io.c,v 1.11 2003/06/11 23:42:12 deraadt Exp $";
#endif
#endif /* not lint */

d34 2
d59 1
a59 1
	fprintf(stderr, !scripted ? "%lu\n" : "", size);
d167 1
a167 1
	fprintf(stderr, !scripted ? "%lu\n" : "", size);
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@pull latest ed from openbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.15 2009/10/28 15:40:47 deraadt Exp $	*/
d31 8
d64 1
a64 1
	fprintf(stderr, !scripted ? "%d\n" : "", size);
a87 1
#ifdef DES
a89 1
#endif
a122 5
#ifdef DES
#define DESGETCHAR(fp) (des ? get_des_char((fp)) : getc((fp)))
#else
#define DESGETCHAR(fp) (getc((fp)))
#endif
d131 1
a131 1
	while (((c = DESGETCHAR(fp)) != EOF || (!feof(fp) &&
d172 1
a172 1
	fprintf(stderr, !scripted ? "%d\n" : "", size);
a185 1
#ifdef DES
a187 1
#endif
a197 1
#ifdef DES
a201 1
#endif
a204 6
#ifdef DES
#define DESPUTCHAR(c, fp) (des ? put_des_char((c), (fp)) : fputc((c), (fp)))
#else
#define DESPUTCHAR(c, fp) (fputc((c), (fp)))
#endif

d210 2
a211 2
	while (len--) {
		if (DESPUTCHAR(*s, fp) < 0) {
a215 2
		s++;
	}
@


1.1.1.3
log
@Updates for ed(1) from Ox
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.19 2016/03/22 17:58:28 mmcc Exp $	*/
a30 6
#include <regex.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

a32 4
static int read_stream(FILE *, int);
static int get_stream_line(FILE *);
static int write_stream(FILE *, int, int);
static int put_stream_line(FILE *, char *, int);
d61 4
a64 2
static char *sbuf;		/* file i/o buffer */
static int sbufsz;		/* file i/o buffer size */
d68 1
a68 1
static int
d80 4
d112 2
d117 6
d124 1
a124 1
static int
d130 1
a130 1
	while (((c = getc(fp)) != EOF || (!feof(fp) &&
d177 1
a177 1
static int
d185 4
d199 6
d208 6
d216 1
a216 1
static int
d220 1
a220 1
		if (fputc(*s, fp) < 0) {
@


1.1.1.4
log
@The “let’s obsolete mwl’s book just after its release” import
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.21 2018/04/26 12:18:54 martijn Exp $	*/
d66 1
a66 2
	if (!scripted)
		fprintf(stderr, "%d\n", size);
d167 1
a167 2
	if (!scripted)
		fprintf(stderr, "%d\n", size);
d296 2
a297 2
#define ESCAPES "\a\b\f\n\r\t\v\\$"
#define ESCCHARS "abfnrtv\\$"
d331 1
a331 1
			if (31 < *s && *s < 127 && *s != '\\' && *s != '$')
d349 1
d352 1
@


