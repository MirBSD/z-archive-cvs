head	1.5;
access;
symbols
	cvs-201804291800:1.1.1.3
	cvs-201704021600:1.1.1.3
	cvs-201611061700:1.1.1.3
	cvs-201104091530:1.1.1.2
	MIRBSD_10:1.1.1.1.0.4
	MIRBSD_10_BASE:1.1.1.1
	MIRBSD_9_BASE:1.1.1.1
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200507211800:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2016.11.06.18.58.43;	author tg;	state Exp;
branches;
next	1.4;
commitid	100581F7D79676B0355;

1.4
date	2012.01.04.21.38.46;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004F04C6FD63B64775;

1.3
date	2012.01.04.21.29.22;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004F04C4C93E344CEA;

1.2
date	2011.11.08.23.17.26;	author tg;	state Exp;
branches;
next	1.1;
commitid	1004EB9B896541203F4;

1.1
date	2005.02.05.17.22.04;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.22.04;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.04.09.15.54.12;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	1004DA081363B8A3AA8;

1.1.1.3
date	2016.11.06.17.31.57;	author tg;	state Exp;
branches;
next	;
commitid	100581F69214EA355AF;


desc
@@


1.5
log
@preliminary merge
@
text
@/*	$OpenBSD: buf.c,v 1.23 2016/03/22 17:58:28 mmcc Exp $	*/
/*	$NetBSD: buf.c,v 1.15 1995/04/23 10:07:28 cgd Exp $	*/

/* buf.c: This file contains the scratch-file buffer routines for the
   ed line editor. */
/*-
 * Copyright (c) 1993 Andrew Moore, Talke Studio.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>

#include <limits.h>
#include <regex.h>
#include <signal.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "ed.h"

__RCSID("$MirOS: src/bin/ed/buf.c,v 1.4 2012/01/04 21:38:46 tg Exp $");

static FILE *sfp;			/* scratch file pointer */
static tp_ftell sfpos;			/* scratch file position */
static int seek_write;			/* seek before writing */
static line_t buffer_head;		/* incore buffer */

/* get_sbuf_line: get a line of text from the scratch file; return pointer
   to the text */
char *
get_sbuf_line(line_t *lp)
{
	static char *sfbuf = NULL;	/* buffer */
	static int sfbufsz = 0;		/* buffer size */

	int len, ct;

	if (lp == &buffer_head)
		return NULL;
	seek_write = 1;				/* force seek on write */
	/* out of position */
	if (sfpos != lp->adr) {
		sfpos = lp->adr;
		if (do_fseek(sfp, sfpos, SEEK_SET) < 0) {
			perror(NULL);
			seterrmsg("cannot seek temp file");
			return NULL;
		}
	}
	len = lp->len;
	REALLOC(sfbuf, sfbufsz, len + 1, NULL);
	if ((ct = fread(sfbuf, sizeof(char), len, sfp)) <  0 || ct != len) {
		perror(NULL);
		seterrmsg("cannot read temp file");
		return NULL;
	}
	sfpos += len;				/* update file position */
	sfbuf[len] = '\0';
	return sfbuf;
}


/* put_sbuf_line: write a line of text to the scratch file and add a line node
   to the editor buffer;  return a pointer to the end of the text */
char *
put_sbuf_line(char *cs)
{
	line_t *lp;
	int len, ct;
	char *s;

	if ((lp = malloc(sizeof(line_t))) == NULL) {
		perror(NULL);
		seterrmsg("out of memory");
		return NULL;
	}
	/* assert: cs is '\n' terminated */
	for (s = cs; *s != '\n'; s++)
		;
	if (s - cs >= LINECHARS) {
		seterrmsg("line too long");
		free(lp);
		return NULL;
	}
	len = s - cs;
	/* out of position */
	if (seek_write) {
		if (do_fseek(sfp, (tp_ftell)0, SEEK_END) < 0) {
			perror(NULL);
			seterrmsg("cannot seek temp file");
			free(lp);
			return NULL;
		}
		sfpos = do_ftell(sfp);
		seek_write = 0;
	}
	/* assert: SPL1() */
	if ((ct = fwrite(cs, sizeof(char), len, sfp)) < 0 || ct != len) {
		sfpos = -1;
		perror(NULL);
		seterrmsg("cannot write temp file");
		free(lp);
		return NULL;
	}
	lp->len = len;
	lp->adr = sfpos;
	add_line_node(lp);
	sfpos += len;			/* update file position */
	return ++s;
}


/* add_line_node: add a line node in the editor buffer after the current line */
void
add_line_node(line_t *lp)
{
	line_t *cp;

	/* this get_addressed_line_node last! */
	cp = get_addressed_line_node(current_addr);
	INSQUE(lp, cp);
	addr_last++;
	current_addr++;
}


/* get_line_node_addr: return line number of pointer */
int
get_line_node_addr(line_t *lp)
{
	line_t *cp = &buffer_head;
	int n = 0;

	while (cp != lp && (cp = cp->q_forw) != &buffer_head)
		n++;
	if (n && cp == &buffer_head) {
		seterrmsg("invalid address");
		return ERR;
	 }
	 return n;
}


/* get_addressed_line_node: return pointer to a line node in the editor buffer */
line_t *
get_addressed_line_node(int n)
{
	static line_t *lp = &buffer_head;
	static int on = 0;

	SPL1();
	if (n > on) {
		if (n <= (on + addr_last) >> 1)
			for (; on < n; on++)
				lp = lp->q_forw;
		else {
			lp = buffer_head.q_back;
			for (on = addr_last; on > n; on--)
				lp = lp->q_back;
		}
	} else {
		if (n >= on >> 1)
			for (; on > n; on--)
				lp = lp->q_back;
		else {
			lp = &buffer_head;
			for (on = 0; on < n; on++)
				lp = lp->q_forw;
		}
	}
	SPL0();
	return lp;
}


extern int newline_added;

#define SCRATCH_TEMPLATE      "/tmp/ed.XXXXXXXXXX"
static char sfn[sizeof(SCRATCH_TEMPLATE)+1] = "";	/* scratch file name */

/* open_sbuf: open scratch file */
int
open_sbuf(void)
{
	int fd = -1;

	isbinary = newline_added = 0;
	strlcpy(sfn, SCRATCH_TEMPLATE, sizeof sfn);
	if ((fd = mkstemp(sfn)) == -1 ||
	    (sfp = fdopen(fd, "w+")) == NULL) {
		if (fd != -1)
			close(fd);
		perror(sfn);
		seterrmsg("cannot open temp file");
		return ERR;
	}
	return 0;
}


/* close_sbuf: close scratch file */
int
close_sbuf(void)
{
	if (sfp) {
		if (fclose(sfp) < 0) {
			perror(sfn);
			seterrmsg("cannot close temp file");
			return ERR;
		}
		sfp = NULL;
		unlink(sfn);
	}
	sfpos = seek_write = 0;
	return 0;
}


/* quit: remove_lines scratch file and exit */
void
quit(int n)
{
	if (sfp) {
		fclose(sfp);
		unlink(sfn);
	}
	exit(n);
}


static unsigned char ctab[256];		/* character translation table */

/* init_buffers: open scratch buffer; initialize line queue */
void
init_buffers(void)
{
	int i = 0;

	/* Read stdin one character at a time to avoid i/o contention
	   with shell escapes invoked by nonterminal input, e.g.,
	   ed - <<EOF
	   !cat
	   hello, world
	   EOF */
	setvbuf(stdin, NULL, _IONBF, 0);
	if (open_sbuf() < 0)
		quit(2);
	REQUE(&buffer_head, &buffer_head);
	for (i = 0; i < 256; i++)
		ctab[i] = i;
}


/* translit_text: translate characters in a string */
char *
translit_text(char *s, int len, int from, int to)
{
	static int i = 0;

	unsigned char *us;

	ctab[i] = i;			/* restore table to initial state */
	ctab[i = from] = to;
	for (us = (unsigned char *) s; len-- > 0; us++)
		*us = ctab[*us];
	return s;
}
@


1.4
log
@prefer setvbuf(3) over its aliases; MSYS doesnâ€™t have them (by RT)
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.19 2009/10/27 23:59:21 deraadt Exp $	*/
d32 1
a32 1
#include <sys/file.h>
d35 8
d45 1
a45 1
__RCSID("$MirOS: src/bin/ed/buf.c,v 1.3 2012/01/04 21:29:22 tg Exp $");
d47 4
a50 4
FILE *sfp;				/* scratch file pointer */
tp_ftell sfpos;				/* scratch file position */
int seek_write;				/* seek before writing */
line_t buffer_head;			/* incore buffer */
d96 1
a96 1
	if ((lp = (line_t *) malloc(sizeof(line_t))) == NULL) {
d203 1
a203 1
char	sfn[sizeof(SCRATCH_TEMPLATE)+1] = "";	/* scratch file name */
d255 1
a255 1
unsigned char ctab[256];		/* character translation table */
d269 1
a269 5
#ifdef _IOFBF
	setvbuf(stdin, stdinbuf, _IOFBF, 1);
#else
	setbuffer(stdin, stdinbuf, 1);
#endif
@


1.3
log
@fix use of f{seek,tell}{,o}, lseek
@
text
@d37 1
a37 1
__RCSID("$MirOS: src/bin/ed/buf.c,v 1.2 2011/11/08 23:17:26 tg Exp $");
d261 3
d265 1
@


1.2
log
@allow building on systems without fseeko/ftello
@
text
@d37 1
a37 1
__RCSID("$MirOS$");
d40 1
a40 1
tp_ftell sfseek;			/* scratch file position */
d58 3
a60 3
	if (sfseek != lp->seek) {
		sfseek = lp->seek;
		if (do_fseek(sfp, sfseek, SEEK_SET) < 0) {
d73 1
a73 1
	sfseek += len;				/* update file position */
d104 1
a104 1
		if (fseek(sfp, 0L, SEEK_END) < 0) {
d110 1
a110 1
		sfseek = ftello(sfp);
d115 1
a115 1
		sfseek = -1;
d122 1
a122 1
	lp->seek  = sfseek;
d124 1
a124 1
	sfseek += len;			/* update file position */
d230 1
a230 1
	sfseek = seek_write = 0;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.16 2003/10/18 19:15:43 jmc Exp $	*/
a31 8
#ifndef lint
#if 0
static char *rcsid = "@@(#)buf.c,v 1.4 1994/02/01 00:34:35 alm Exp";
#else
static char rcsid[] = "$OpenBSD: buf.c,v 1.16 2003/10/18 19:15:43 jmc Exp $";
#endif
#endif /* not lint */

d37 1
d40 1
a40 1
off_t sfseek;				/* scratch file position */
d60 1
a60 1
		if (fseek(sfp, sfseek, SEEK_SET) < 0) {
d110 1
a110 1
		sfseek = ftell(sfp);
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@pull latest ed from openbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.19 2009/10/27 23:59:21 deraadt Exp $	*/
d32 8
d67 1
a67 1
		if (fseeko(sfp, sfseek, SEEK_SET) < 0) {
d117 1
a117 1
		sfseek = ftello(sfp);
@


1.1.1.3
log
@Updates for ed(1) from Ox
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.23 2016/03/22 17:58:28 mmcc Exp $	*/
d32 1
a32 1
#include <sys/types.h>
a34 8
#include <limits.h>
#include <regex.h>
#include <signal.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

d38 4
a41 4
static FILE *sfp;			/* scratch file pointer */
static off_t sfseek;			/* scratch file position */
static int seek_write;			/* seek before writing */
static line_t buffer_head;		/* incore buffer */
d87 1
a87 1
	if ((lp = malloc(sizeof(line_t))) == NULL) {
d194 1
a194 1
static char sfn[sizeof(SCRATCH_TEMPLATE)+1] = "";	/* scratch file name */
d246 1
a246 1
static unsigned char ctab[256];		/* character translation table */
d260 1
a260 1
	setvbuf(stdin, NULL, _IONBF, 0);
@


