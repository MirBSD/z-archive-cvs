head	1.15;
access;
symbols
	cvs-201804291800:1.1.1.5
	cvs-201704021600:1.1.1.4
	cvs-201611061700:1.1.1.3
	cvs-201104091530:1.1.1.2
	MIRBSD_10:1.1.1.1.0.4
	MIRBSD_10_BASE:1.1.1.1
	MIRBSD_9_BASE:1.1.1.1
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200507211800:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2018.07.04.01.14.06;	author tg;	state Exp;
branches;
next	1.14;
commitid	1005B3C1F6B51BAA1A9;

1.14
date	2018.04.29.18.22.25;	author tg;	state Exp;
branches;
next	1.13;
commitid	1005AE60D7913C9F68E;

1.13
date	2018.04.29.18.17.37;	author tg;	state Exp;
branches;
next	1.12;
commitid	1005AE60C5B58CC813A;

1.12
date	2017.04.02.16.46.26;	author tg;	state Exp;
branches;
next	1.11;
commitid	10058E12AFC07ECAB36;

1.11
date	2016.11.27.15.09.40;	author tg;	state Exp;
branches;
next	1.10;
commitid	100583AF73A3E28B36F;

1.10
date	2016.11.06.18.58.44;	author tg;	state Exp;
branches;
next	1.9;
commitid	100581F7D79676B0355;

1.9
date	2012.01.04.21.57.44;	author tg;	state Exp;
branches;
next	1.8;
commitid	1004F04CB6F09F9D6F7;

1.8
date	2012.01.04.21.38.46;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004F04C6FD63B64775;

1.7
date	2012.01.04.21.30.33;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004F04C5116B09F46D;

1.6
date	2012.01.04.21.29.22;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004F04C4C93E344CEA;

1.5
date	2011.11.05.23.26.15;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004EB5C62F1815E144;

1.4
date	2011.04.09.16.47.07;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004DA08DA1052D2486;

1.3
date	2011.04.09.16.28.48;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004DA0890A2EA8ED27;

1.2
date	2009.06.18.20.45.51;	author tg;	state Exp;
branches;
next	1.1;
commitid	1004A3AA7566C06EEDC;

1.1
date	2005.02.05.17.22.04;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.22.04;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.04.09.15.54.12;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	1004DA081363B8A3AA8;

1.1.1.3
date	2016.11.06.17.31.57;	author tg;	state Exp;
branches;
next	1.1.1.4;
commitid	100581F69214EA355AF;

1.1.1.4
date	2017.04.02.16.39.03;	author tg;	state Exp;
branches;
next	1.1.1.5;
commitid	10058E1293B2419B0A2;

1.1.1.5
date	2018.04.29.18.11.52;	author tg;	state Exp;
branches;
next	;
commitid	1005AE60AF7585D8E88;


desc
@@


1.15
log
@make stdout line-buffered if interactive

thanks https://twitter.com/ed1conf/status/1014158263926054913
@
text
@/*	$OpenBSD: main.c,v 1.61 2018/02/26 17:35:08 martijn Exp $	*/
/*	$NetBSD: main.c,v 1.3 1995/03/21 09:04:44 cgd Exp $	*/

/* main.c: This file contains the main control and user-interface routines
   for the ed line editor. */
/*-
 * Copyright (c) 2003, 2004, 2005, 2008, 2009, 2011, 2012, 2016
 *	mirabilos <m@@mirbsd.org>
 * Copyright (c) 1993 Andrew Moore, Talke Studio.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * CREDITS
 *
 *	This program is based on the editor algorithm described in
 *	Brian W. Kernighan and P. J. Plauger's book "Software Tools
 *	in Pascal," Addison-Wesley, 1981.
 *
 *	The buffering algorithm is attributed to Rodney Ruddock of
 *	the University of Guelph, Guelph, Ontario.
 *
 */

#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/wait.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <limits.h>
#include <pwd.h>
#include <regex.h>
#include <setjmp.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#ifdef __dietlibc__
#include <termios.h>
#endif
#include <unistd.h>

#include "ed.h"

__RCSID("$MirOS: src/bin/ed/main.c,v 1.14 2018/04/29 18:22:25 tg Exp $");
__IDSTRING(ed_h, ED_H_ID);

void signal_hup(int);
void signal_int(int);
void handle_winch(int);

static int next_addr(void);
static int check_addr_range(int, int);
static int get_matching_node_addr(regex_t *, int);
static char *get_filename(void);
static int get_shell_command(void);
static int append_lines(int);
static int join_lines(int, int);
static int move_lines(int);
static int copy_lines(int);
static int mark_line_node(line_t *, int);
static int get_marked_node_addr(int);
static line_t *dup_line_node(line_t *);

sigjmp_buf env;

/* static buffers */
static char errmsg[PATH_MAX + 40];	/* error message buffer */
static char *shcmd;		/* shell command buffer */
static int shcmdsz;		/* shell command buffer size */
static int shcmdi;		/* shell command buffer index */
static char old_filename[PATH_MAX];	/* default filename */

/* global buffers */
char *ibuf;			/* ed command-line buffer */
int ibufsz;			/* ed command-line buffer size */
char *ibufp;			/* pointer to ed command-line buffer */

/* global flags */
int garrulous = 0;		/* if set, print all error messages */
int isbinary;			/* if set, buffer contains ASCII NULs */
int isglobal;			/* if set, doing a global command */
int modified;			/* if set, buffer modified since last write */
int scripted = 0;		/* if set, suppress diagnostics */
int interactive = 0;		/* if set, we are in interactive mode */

volatile sig_atomic_t mutex = 0;  /* if set, signals set flags */
volatile sig_atomic_t sighup = 0; /* if set, sighup received while mutex set */
volatile sig_atomic_t sigint = 0; /* if set, sigint received while mutex set */

/* if set, signal handlers are enabled */
volatile sig_atomic_t sigactive = 0;

int current_addr;		/* current address in editor buffer */
int addr_last;			/* last address in editor buffer */
int lineno;			/* script line number */
static const char *prompt;	/* command-line prompt */
static const char *dps = "*";	/* default command-line prompt */

static const char usage[] = "usage: %s [-] [-s] [-p string] [file]\n";

static char *home;		/* home directory */

void
seterrmsg(const char *s)
{
	strlcpy(errmsg, s, sizeof(errmsg));
}

/* ed: line editor */
int
main(volatile int argc, char ** volatile argv)
{
	int c, n;
	volatile int status = 0;

#if defined(__OpenBSD__) && !defined(__MirBSD__)
	if (pledge("stdio rpath wpath cpath proc exec tty", NULL) == -1)
		err(1, "pledge");
#endif

	home = getenv("HOME");

top:
	while ((c = getopt(argc, argv, "p:sx")) != -1)
		switch (c) {
		case 'p':				/* set prompt */
			dps = prompt = optarg;
			break;
		case 's':				/* run script */
			scripted = 1;
			break;
		case 'x':				/* use crypt */
			fprintf(stderr, "crypt unavailable\n?\n");
			break;
		default:
			fprintf(stderr, usage, argv[0]);
			exit(1);
		}
	argv += optind;
	argc -= optind;
	if (argc && **argv == '-') {
		scripted = 1;
		if (argc > 1) {
			optind = 1;
			goto top;
		}
		argv++;
		argc--;
	}

	if (!(interactive = isatty(0))) {
		struct stat sb;

		/* assert: pipes show up as FIFOs when fstat'd */
		if (fstat(STDIN_FILENO, &sb) || !S_ISFIFO(sb.st_mode)) {
			if (lseek(STDIN_FILENO, (off_t)0, SEEK_CUR)) {
				interactive = 1;
			}
		}
	}
	if (interactive)
		setvbuf(stdout, NULL, _IOLBF, 0);

	/* assert: reliable signals! */
#if defined(SIGWINCH) && defined(TIOCGWINSZ)
	if (isatty(STDIN_FILENO)) {
		handle_winch(SIGWINCH);
		signal(SIGWINCH, handle_winch);
	}
#endif
	signal(SIGHUP, signal_hup);
	signal(SIGQUIT, SIG_IGN);
	signal(SIGINT, signal_int);
	if (sigsetjmp(env, 1)) {
		status = -1;
		fputs("\n?\n", stderr);
		seterrmsg("interrupt");
	} else {
		init_buffers();
		sigactive = 1;			/* enable signal handlers */
		if (argc && **argv) {
			if (read_file(*argv, 0) < 0 && !interactive)
				quit(2);
			else if (**argv != '!')
				strlcpy(old_filename, *argv,
				    sizeof old_filename);
		} else if (argc) {
			fputs("?\n", stderr);
			if (**argv == '\0')
				seterrmsg("invalid filename");
			if (!interactive)
				quit(2);
		}
	}
	for (;;) {
		if (status < 0 && garrulous)
			fprintf(stderr, "%s\n", errmsg);
		if (prompt) {
			fputs(prompt, stdout);
			fflush(stdout);
		}
		if ((n = get_tty_line()) < 0) {
			status = ERR;
			continue;
		} else if (n == 0) {
			if (modified && !scripted) {
				fputs("?\n", stderr);
				seterrmsg("warning: file modified");
				if (!interactive) {
					if (garrulous)
						fprintf(stderr,
						    "script, line %d: %s\n",
						    lineno, errmsg);
					quit(2);
				}
				clearerr(stdin);
				modified = 0;
				status = EMOD;
				continue;
			} else
				quit(0);
		} else if (ibuf[n - 1] != '\n') {
			/* discard line */
			seterrmsg("unexpected end-of-file");
			clearerr(stdin);
			status = ERR;
			continue;
		}
		isglobal = 0;
		if ((status = extract_addr_range()) >= 0 &&
		    (status = exec_command()) >= 0)
			if (!status || (status &&
			    (status = display_lines(current_addr, current_addr,
				status)) >= 0))
				continue;
		switch (status) {
		case EOF:
			quit(0);
			break;
		case EMOD:
			modified = 0;
			fputs("?\n", stderr);		/* give warning */
			seterrmsg("warning: file modified");
			if (!interactive) {
				if (garrulous)
					fprintf(stderr,
					    "script, line %d: %s\n",
					    lineno, errmsg);
				quit(2);
			}
			break;
		case FATAL:
			if (garrulous) {
				if (!interactive)
					fprintf(stderr,
					    "script, line %d: ",
					    lineno);
				fprintf(stderr, "%s\n", errmsg);
			}
			quit(3);
			break;
		default:
			fputs("?\n", stderr);
			if (!interactive) {
				if (garrulous)
					fprintf(stderr,
					    "script, line %d: %s\n",
					    lineno, errmsg);
				quit(2);
			}
			break;
		}
	}
	/*NOTREACHED*/
}

int first_addr, second_addr, addr_cnt;

/* extract_addr_range: get line addresses from the command buffer until an
   illegal address is seen; return status */
int
extract_addr_range(void)
{
	int addr;

	addr_cnt = 0;
	first_addr = second_addr = current_addr;
	while ((addr = next_addr()) >= 0) {
		addr_cnt++;
		first_addr = second_addr;
		second_addr = addr;
		if (*ibufp != ',' && *ibufp != ';')
			break;
		else if (*ibufp++ == ';')
			current_addr = addr;
	}
	if ((addr_cnt = MIN(addr_cnt, 2)) == 1 || second_addr != addr)
		first_addr = second_addr;
	return (addr == ERR) ? ERR : 0;
}


#define	SKIP_BLANKS() \
	do { \
		while (isspace((unsigned char)*ibufp) && *ibufp != '\n') \
			ibufp++; \
	} while (0)

#define MUST_BE_FIRST() \
	do { \
		if (!first) { \
			seterrmsg("invalid address"); \
			return ERR; \
		} \
	} while (0)


/*  next_addr: return the next line address in the command buffer */
static int
next_addr(void)
{
	char *hd;
	int addr = current_addr;
	int n;
	int first = 1;
	int c;

	SKIP_BLANKS();
	for (hd = ibufp;; first = 0)
		switch ((c = (unsigned char)*ibufp)) {
		case '+':
		case '\t':
		case ' ':
		case '-':
		case '^':
			ibufp++;
			SKIP_BLANKS();
			if (isdigit((unsigned char)*ibufp)) {
				STRTOI(n, ibufp);
				addr += (c == '-' || c == '^') ? -n : n;
			} else if (!isspace(c))
				addr += (c == '-' || c == '^') ? -1 : 1;
			break;
		case '0': case '1': case '2':
		case '3': case '4': case '5':
		case '6': case '7': case '8': case '9':
			MUST_BE_FIRST();
			STRTOI(addr, ibufp);
			break;
		case '.':
		case '$':
			MUST_BE_FIRST();
			ibufp++;
			addr = (c == '.') ? current_addr : addr_last;
			break;
		case '/':
		case '?':
			MUST_BE_FIRST();
			if ((addr = get_matching_node_addr(
			    get_compiled_pattern(), c == '/')) < 0)
				return ERR;
			else if (c == *ibufp)
				ibufp++;
			break;
		case '\'':
			MUST_BE_FIRST();
			ibufp++;
			if ((addr = get_marked_node_addr((unsigned char)*ibufp++)) < 0)
				return ERR;
			break;
		case '%':
		case ',':
		case ';':
			if (first) {
				ibufp++;
				addr_cnt++;
				second_addr = (c == ';') ? current_addr : 1;
				if ((addr = next_addr()) < 0)
					addr = addr_last;
				break;
			}
			/* FALLTHROUGH */
		default:
			if (ibufp == hd)
				return EOF;
			else if (addr < 0 || addr_last < addr) {
				seterrmsg("invalid address");
				return ERR;
			} else
				return addr;
		}
	/* NOTREACHED */
}


#ifdef BACKWARDS
/* GET_THIRD_ADDR: get a legal address from the command buffer */
#define GET_THIRD_ADDR(addr) \
	do { \
		int ol1, ol2; \
		\
		ol1 = first_addr; \
		ol2 = second_addr; \
		if (extract_addr_range() < 0) \
			return ERR; \
		else if (addr_cnt == 0) { \
			seterrmsg("destination expected"); \
			return ERR; \
		} else if (second_addr < 0 || addr_last < second_addr) { \
			seterrmsg("invalid address"); \
			return ERR; \
		} \
		addr = second_addr; \
		first_addr = ol1; \
		second_addr = ol2; \
	} while (0)

#else	/* BACKWARDS */
/* GET_THIRD_ADDR: get a legal address from the command buffer */
#define GET_THIRD_ADDR(addr) \
	do { \
		int ol1, ol2; \
		\
		ol1 = first_addr; \
		ol2 = second_addr; \
		if (extract_addr_range() < 0) \
			return ERR; \
		if (second_addr < 0 || addr_last < second_addr) { \
			seterrmsg("invalid address"); \
			return ERR; \
		} \
		addr = second_addr; \
		first_addr = ol1; \
		second_addr = ol2; \
	} while (0)
#endif


/* GET_COMMAND_SUFFIX: verify the command suffix in the command buffer */
#define GET_COMMAND_SUFFIX() \
	do { \
		int done = 0; \
		do { \
			switch (*ibufp) { \
			case 'p': \
				gflag |= GPR; \
				ibufp++; \
				break; \
			case 'l': \
				gflag |= GLS; \
				ibufp++; \
				break; \
			case 'n': \
				gflag |= GNP; \
				ibufp++; \
				break; \
			default: \
				done++; \
			} \
		} while (!done); \
		if (*ibufp++ != '\n') { \
			seterrmsg("invalid command suffix"); \
			return ERR; \
		} \
	} while (0)

/* sflags */
#define SGG 001		/* complement previous global substitute suffix */
#define SGP 002		/* complement previous print suffix */
#define SGR 004		/* use last regex instead of last pat */
#define SGF 010		/* repeat last substitution */

int patlock = 0;	/* if set, pattern not freed by get_compiled_pattern() */

volatile sig_atomic_t rows = 22;	/* scroll length: ws_row - 2 */
volatile sig_atomic_t cols = 72;	/* wrap column */

/* exec_command: execute the next command in command buffer; return print
   request, if any */
int
exec_command(void)
{
	extern int u_current_addr;
	extern int u_addr_last;

	static regex_t *pat = NULL;
	static int sgflag = 0;
	static int sgnum = 0;

	regex_t *tpat;
	char *fnp;
	int gflag = 0;
	int sflags = 0;
	int addr = 0;
	int n = 0;
	int c;

	SKIP_BLANKS();
	switch ((c = (unsigned char)*ibufp++)) {
	case 'a':
		GET_COMMAND_SUFFIX();
		if (!isglobal) clear_undo_stack();
		if (append_lines(second_addr) < 0)
			return ERR;
		break;
	case 'c':
		if (check_addr_range(current_addr, current_addr) < 0)
			return ERR;
		GET_COMMAND_SUFFIX();
		if (!isglobal) clear_undo_stack();
		if (delete_lines(first_addr, second_addr) < 0 ||
		    append_lines(current_addr) < 0)
			return ERR;
		break;
	case 'd':
		if (check_addr_range(current_addr, current_addr) < 0)
			return ERR;
		GET_COMMAND_SUFFIX();
		if (!isglobal) clear_undo_stack();
		if (delete_lines(first_addr, second_addr) < 0)
			return ERR;
		else if ((addr = INC_MOD(current_addr, addr_last)) != 0)
			current_addr = addr;
		break;
	case 'e':
		if (modified && !scripted)
			return EMOD;
		/* FALLTHROUGH */
	case 'E':
		if (addr_cnt > 0) {
			seterrmsg("unexpected address");
			return ERR;
		} else if (!isspace((unsigned char)*ibufp)) {
			seterrmsg("unexpected command suffix");
			return ERR;
		} else if ((fnp = get_filename()) == NULL)
			return ERR;
		GET_COMMAND_SUFFIX();
		if (delete_lines(1, addr_last) < 0)
			return ERR;
		clear_undo_stack();
		if (close_sbuf() < 0)
			return ERR;
		else if (open_sbuf() < 0)
			return FATAL;
		if (*fnp && *fnp != '!')
			strlcpy(old_filename, fnp, sizeof old_filename);
#ifdef BACKWARDS
		if (*fnp == '\0' && *old_filename == '\0') {
			seterrmsg("no current filename");
			return ERR;
		}
#endif
		if (read_file(*fnp ? fnp : old_filename, 0) < 0)
			return ERR;
		clear_undo_stack();
		modified = 0;
		u_current_addr = u_addr_last = -1;
		break;
	case 'f':
		if (addr_cnt > 0) {
			seterrmsg("unexpected address");
			return ERR;
		} else if (!isspace((unsigned char)*ibufp)) {
			seterrmsg("unexpected command suffix");
			return ERR;
		} else if ((fnp = get_filename()) == NULL)
			return ERR;
		else if (*fnp == '!') {
			seterrmsg("invalid redirection");
			return ERR;
		}
		GET_COMMAND_SUFFIX();
		if (*fnp)
			strlcpy(old_filename, fnp, sizeof old_filename);
		puts(strip_escapes(old_filename));
		break;
	case 'g':
	case 'v':
	case 'G':
	case 'V':
		if (isglobal) {
			seterrmsg("cannot nest global commands");
			return ERR;
		} else if (check_addr_range(1, addr_last) < 0)
			return ERR;
		else if (build_active_list(c == 'g' || c == 'G') < 0)
			return ERR;
		else if ((n = (c == 'G' || c == 'V')))
			GET_COMMAND_SUFFIX();
		isglobal++;
		if (exec_global(n, gflag) < 0)
			return ERR;
		break;
	case 'h':
		if (addr_cnt > 0) {
			seterrmsg("unexpected address");
			return ERR;
		}
		GET_COMMAND_SUFFIX();
		if (*errmsg) fprintf(stderr, "%s\n", errmsg);
		break;
	case 'H':
		if (addr_cnt > 0) {
			seterrmsg("unexpected address");
			return ERR;
		}
		GET_COMMAND_SUFFIX();
		if ((garrulous = 1 - garrulous) && *errmsg)
			fprintf(stderr, "%s\n", errmsg);
		break;
	case 'i':
		if (second_addr == 0) {
			second_addr = 1;
		}
		GET_COMMAND_SUFFIX();
		if (!isglobal) clear_undo_stack();
		if (append_lines(second_addr - 1) < 0)
			return ERR;
		break;
	case 'j':
		if (check_addr_range(current_addr, current_addr + 1) < 0)
			return ERR;
		GET_COMMAND_SUFFIX();
		if (!isglobal) clear_undo_stack();
		if (first_addr != second_addr &&
		    join_lines(first_addr, second_addr) < 0)
			return ERR;
		break;
	case 'k':
		c = (unsigned char)*ibufp++;
		if (second_addr == 0) {
			seterrmsg("invalid address");
			return ERR;
		}
		GET_COMMAND_SUFFIX();
		if (mark_line_node(get_addressed_line_node(second_addr), c) < 0)
			return ERR;
		break;
	case 'l':
		if (check_addr_range(current_addr, current_addr) < 0)
			return ERR;
		GET_COMMAND_SUFFIX();
		if (display_lines(first_addr, second_addr, gflag | GLS) < 0)
			return ERR;
		gflag = 0;
		break;
	case 'm':
		if (check_addr_range(current_addr, current_addr) < 0)
			return ERR;
		GET_THIRD_ADDR(addr);
		if (first_addr <= addr && addr < second_addr) {
			seterrmsg("invalid destination");
			return ERR;
		}
		GET_COMMAND_SUFFIX();
		if (!isglobal) clear_undo_stack();
		if (move_lines(addr) < 0)
			return ERR;
		break;
	case 'n':
		if (check_addr_range(current_addr, current_addr) < 0)
			return ERR;
		GET_COMMAND_SUFFIX();
		if (display_lines(first_addr, second_addr, gflag | GNP) < 0)
			return ERR;
		gflag = 0;
		break;
	case 'p':
		if (check_addr_range(current_addr, current_addr) < 0)
			return ERR;
		GET_COMMAND_SUFFIX();
		if (display_lines(first_addr, second_addr, gflag | GPR) < 0)
			return ERR;
		gflag = 0;
		break;
	case 'P':
		if (addr_cnt > 0) {
			seterrmsg("unexpected address");
			return ERR;
		}
		GET_COMMAND_SUFFIX();
		prompt = prompt ? NULL : optarg ? optarg : dps;
		break;
	case 'q':
	case 'Q':
		if (addr_cnt > 0) {
			seterrmsg("unexpected address");
			return ERR;
		}
		GET_COMMAND_SUFFIX();
		gflag =  (modified && !scripted && c == 'q') ? EMOD : EOF;
		break;
	case 'r':
		if (!isspace((unsigned char)*ibufp)) {
			seterrmsg("unexpected command suffix");
			return ERR;
		} else if (addr_cnt == 0)
			second_addr = addr_last;
		if ((fnp = get_filename()) == NULL)
			return ERR;
		GET_COMMAND_SUFFIX();
		if (!isglobal) clear_undo_stack();
		if (*old_filename == '\0' && *fnp != '!')
			strlcpy(old_filename, fnp, sizeof old_filename);
#ifdef BACKWARDS
		if (*fnp == '\0' && *old_filename == '\0') {
			seterrmsg("no current filename");
			return ERR;
		}
#endif
		if ((addr = read_file(*fnp ? fnp : old_filename,
		    second_addr)) < 0)
			return ERR;
		else if (addr)
			modified = 1;
		break;
	case 's':
		do {
			switch (*ibufp) {
			case '\n':
				sflags |=SGF;
				break;
			case 'g':
				sflags |= SGG;
				ibufp++;
				break;
			case 'p':
				sflags |= SGP;
				ibufp++;
				break;
			case 'r':
				sflags |= SGR;
				ibufp++;
				break;
			case '0': case '1': case '2': case '3': case '4':
			case '5': case '6': case '7': case '8': case '9':
				STRTOI(sgnum, ibufp);
				sflags |= SGF;
				sgflag &= ~GSG;		/* override GSG */
				break;
			default:
				if (sflags) {
					seterrmsg("invalid command suffix");
					return ERR;
				}
			}
		} while (sflags && *ibufp != '\n');
		if (sflags && !pat) {
			seterrmsg("no previous substitution");
			return ERR;
		} else if (sflags & SGG)
			sgnum = 0;		/* override numeric arg */
		if (*ibufp != '\n' && *(ibufp + 1) == '\n') {
			seterrmsg("invalid pattern delimiter");
			return ERR;
		}
		tpat = pat;
		SPL1();
		if ((!sflags || (sflags & SGR)) &&
		    (tpat = get_compiled_pattern()) == NULL) {
		 	SPL0();
			return ERR;
		} else if (tpat != pat) {
			if (pat) {
				regfree(pat);
				free(pat);
			}
			pat = tpat;
			patlock = 1;		/* reserve pattern */
		}
		SPL0();
		if (!sflags && extract_subst_tail(&sgflag, &sgnum) < 0)
			return ERR;
		else if (isglobal)
			sgflag |= GLB;
		else
			sgflag &= ~GLB;
		if (sflags & SGG)
			sgflag ^= GSG;
		if (sflags & SGP) {
			sgflag ^= GPR;
			sgflag &= ~(GLS | GNP);
		}
		do {
			switch (*ibufp) {
			case 'p':
				sgflag |= GPR;
				ibufp++;
				break;
			case 'l':
				sgflag |= GLS;
				ibufp++;
				break;
			case 'n':
				sgflag |= GNP;
				ibufp++;
				break;
			default:
				n++;
			}
		} while (!n);
		if (check_addr_range(current_addr, current_addr) < 0)
			return ERR;
		GET_COMMAND_SUFFIX();
		if (!isglobal) clear_undo_stack();
		if (search_and_replace(pat, sgflag, sgnum) < 0)
			return ERR;
		break;
	case 't':
		if (check_addr_range(current_addr, current_addr) < 0)
			return ERR;
		GET_THIRD_ADDR(addr);
		GET_COMMAND_SUFFIX();
		if (!isglobal) clear_undo_stack();
		if (copy_lines(addr) < 0)
			return ERR;
		break;
	case 'u':
		if (addr_cnt > 0) {
			seterrmsg("unexpected address");
			return ERR;
		}
		GET_COMMAND_SUFFIX();
		if (pop_undo_stack() < 0)
			return ERR;
		break;
	case 'w':
	case 'W':
		if ((n = *ibufp) == 'q' || n == 'Q') {
			gflag = EOF;
			ibufp++;
		}
		if (!isspace((unsigned char)*ibufp)) {
			seterrmsg("unexpected command suffix");
			return ERR;
		} else if ((fnp = get_filename()) == NULL)
			return ERR;
		if (addr_cnt == 0 && !addr_last)
			first_addr = second_addr = 0;
		else if (check_addr_range(1, addr_last) < 0)
			return ERR;
		GET_COMMAND_SUFFIX();
		if (*old_filename == '\0' && *fnp != '!')
			strlcpy(old_filename, fnp, sizeof old_filename);
#ifdef BACKWARDS
		if (*fnp == '\0' && *old_filename == '\0') {
			seterrmsg("no current filename");
			return ERR;
		}
#endif
		if ((addr = write_file(*fnp ? fnp : old_filename,
		    (c == 'W') ? "a" : "w", first_addr, second_addr)) < 0)
			return ERR;
		else if (addr == addr_last && *fnp != '!')
			modified = 0;
		else if (modified && !scripted && n == 'q')
			gflag = EMOD;
		break;
	case 'x':
		if (addr_cnt > 0) {
			seterrmsg("unexpected address");
			return ERR;
		}
		GET_COMMAND_SUFFIX();
		seterrmsg("crypt unavailable");
		return ERR;
	case 'z':
		first_addr = 1;
#ifdef BACKWARDS
		if (check_addr_range(first_addr, current_addr + 1) < 0)
#else
		if (check_addr_range(first_addr, current_addr + !isglobal) < 0)
#endif
			return ERR;
		else if ('0' < *ibufp && *ibufp <= '9')
			STRTOI(rows, ibufp);
		GET_COMMAND_SUFFIX();
		if (display_lines(second_addr, MIN(addr_last,
		    second_addr + rows), gflag) < 0)
			return ERR;
		gflag = 0;
		break;
	case '=':
		GET_COMMAND_SUFFIX();
		printf("%d\n", addr_cnt ? second_addr : addr_last);
		break;
	case '!':
		if (addr_cnt > 0) {
			seterrmsg("unexpected address");
			return ERR;
		} else if ((sflags = get_shell_command()) < 0)
			return ERR;
		GET_COMMAND_SUFFIX();
		if (sflags) printf("%s\n", shcmd + 1);
		system(shcmd + 1);
		if (!scripted) printf("!\n");
		break;
	case '\n':
		first_addr = 1;
#ifdef BACKWARDS
		if (check_addr_range(first_addr, current_addr + 1) < 0
#else
		if (check_addr_range(first_addr, current_addr + !isglobal) < 0
#endif
		 || display_lines(second_addr, second_addr, 0) < 0)
			return ERR;
		break;
	default:
		seterrmsg("unknown command");
		return ERR;
	}
	return gflag;
}


/* check_addr_range: return status of address range check */
static int
check_addr_range(int n, int m)
{
	if (addr_cnt == 0) {
		first_addr = n;
		second_addr = m;
	}
	if (first_addr > second_addr || 1 > first_addr ||
	    second_addr > addr_last) {
		seterrmsg("invalid address");
		return ERR;
	}
	return 0;
}


/* get_matching_node_addr: return the address of the next line matching a
   pattern in a given direction.  wrap around begin/end of editor buffer if
   necessary */
static int
get_matching_node_addr(regex_t *pat, int dir)
{
	char *s;
	int n = current_addr;
	line_t *lp;

	if (!pat) return ERR;
	do {
		if ((n = dir ? INC_MOD(n, addr_last) : DEC_MOD(n, addr_last))) {
			lp = get_addressed_line_node(n);
			if ((s = get_sbuf_line(lp)) == NULL)
				return ERR;
			if (isbinary)
				NUL_TO_NEWLINE(s, lp->len);
			if (!regexec(pat, s, 0, NULL, 0))
				return n;
		}
	} while (n != current_addr);
	seterrmsg("no match");
	return  ERR;
}


/* get_filename: return pointer to copy of filename in the command buffer */
static char *
get_filename(void)
{
	static char *file = NULL;
	static int filesz = 0;
	int n;

	if (*ibufp != '\n') {
		SKIP_BLANKS();
		if (*ibufp == '\n') {
			seterrmsg("invalid filename");
			return NULL;
		} else if ((ibufp = get_extended_line(&n, 1)) == NULL)
			return NULL;
		else if (*ibufp == '!') {
			ibufp++;
			if ((n = get_shell_command()) < 0)
				return NULL;
			if (n) printf("%s\n", shcmd + 1);
			return shcmd;
		} else if (n >= PATH_MAX) {
			seterrmsg("filename too long");
			return  NULL;
		}
	}
#ifndef BACKWARDS
	else if (*old_filename == '\0') {
		seterrmsg("no current filename");
		return  NULL;
	}
#endif
	REALLOC(file, filesz, PATH_MAX, NULL);
	for (n = 0; *ibufp != '\n';)
		file[n++] = *ibufp++;
	file[n] = '\0';
	return file;
}


/* get_shell_command: read a shell command from stdin; return substitution
   status */
static int
get_shell_command(void)
{
	static char *buf = NULL;
	static int n = 0;

	char *s;			/* substitution char pointer */
	int i = 0;
	int j = 0;

	if ((s = ibufp = get_extended_line(&j, 1)) == NULL)
		return ERR;
	REALLOC(buf, n, j + 1, ERR);
	buf[i++] = '!';			/* prefix command w/ bang */
	while (*ibufp != '\n')
		switch (*ibufp) {
		default:
			REALLOC(buf, n, i + 2, ERR);
			buf[i++] = *ibufp;
			if (*ibufp++ == '\\')
				buf[i++] = *ibufp++;
			break;
		case '!':
			if (s != ibufp) {
				REALLOC(buf, n, i + 1, ERR);
				buf[i++] = *ibufp++;
			}
#ifdef BACKWARDS
			else if (shcmd == NULL || *(shcmd + 1) == '\0')
#else
			else if (shcmd == NULL)
#endif
			{
				seterrmsg("no previous command");
				return ERR;
			} else {
				REALLOC(buf, n, i + shcmdi, ERR);
				for (s = shcmd + 1; s < shcmd + shcmdi;)
					buf[i++] = *s++;
				s = ibufp++;
			}
			break;
		case '%':
			if (*old_filename  == '\0') {
				seterrmsg("no current filename");
				return ERR;
			}
			j = strlen(s = strip_escapes(old_filename));
			REALLOC(buf, n, i + j, ERR);
			while (j--)
				buf[i++] = *s++;
			s = ibufp++;
			break;
		}
	REALLOC(shcmd, shcmdsz, i + 1, ERR);
	memcpy(shcmd, buf, i);
	shcmd[shcmdi = i] = '\0';
	return *s == '!' || *s == '%';
}


/* append_lines: insert text from stdin to after line n; stop when either a
   single period is read or EOF; return status */
static int
append_lines(int n)
{
	int l;
	char *lp = ibuf;
	char *eot;
	undo_t *up = NULL;

	for (current_addr = n;;) {
		if (!isglobal) {
			if ((l = get_tty_line()) < 0)
				return ERR;
			else if (l == 0 || ibuf[l - 1] != '\n') {
				clearerr(stdin);
				return  l ? EOF : 0;
			}
			lp = ibuf;
		} else if (*(lp = ibufp) == '\0')
			return 0;
		else {
			while (*ibufp++ != '\n')
				;
			l = ibufp - lp;
		}
		if (l == 2 && lp[0] == '.' && lp[1] == '\n') {
			return 0;
		}
		eot = lp + l;
		SPL1();
		do {
			if ((lp = put_sbuf_line(lp)) == NULL) {
				SPL0();
				return ERR;
			} else if (up)
				up->t = get_addressed_line_node(current_addr);
			else if ((up = push_undo_stack(UADD, current_addr,
			    current_addr)) == NULL) {
				SPL0();
				return ERR;
			}
		} while (lp != eot);
		modified = 1;
		SPL0();
	}
	/* NOTREACHED */
}


/* join_lines: replace a range of lines with the joined text of those lines */
static int
join_lines(int from, int to)
{
	static char *buf = NULL;
	static int n;

	char *s;
	int size = 0;
	line_t *bp, *ep;

	ep = get_addressed_line_node(INC_MOD(to, addr_last));
	bp = get_addressed_line_node(from);
	for (; bp != ep; bp = bp->q_forw) {
		if ((s = get_sbuf_line(bp)) == NULL)
			return ERR;
		REALLOC(buf, n, size + bp->len, ERR);
		memcpy(buf + size, s, bp->len);
		size += bp->len;
	}
	REALLOC(buf, n, size + 2, ERR);
	memcpy(buf + size, "\n", 2);
	if (delete_lines(from, to) < 0)
		return ERR;
	current_addr = from - 1;
	SPL1();
	if (put_sbuf_line(buf) == NULL ||
	    push_undo_stack(UADD, current_addr, current_addr) == NULL) {
		SPL0();
		return ERR;
	}
	modified = 1;
	SPL0();
	return 0;
}


/* move_lines: move a range of lines */
static int
move_lines(int addr)
{
	line_t *b1, *a1, *b2, *a2;
	int n = INC_MOD(second_addr, addr_last);
	int p = first_addr - 1;
	int done = (addr == first_addr - 1 || addr == second_addr);

	SPL1();
	if (done) {
		a2 = get_addressed_line_node(n);
		b2 = get_addressed_line_node(p);
		current_addr = second_addr;
	} else if (push_undo_stack(UMOV, p, n) == NULL ||
	    push_undo_stack(UMOV, addr, INC_MOD(addr, addr_last)) == NULL) {
		SPL0();
		return ERR;
	} else {
		a1 = get_addressed_line_node(n);
		if (addr < first_addr) {
			b1 = get_addressed_line_node(p);
			b2 = get_addressed_line_node(addr);
					/* this get_addressed_line_node last! */
		} else {
			b2 = get_addressed_line_node(addr);
			b1 = get_addressed_line_node(p);
					/* this get_addressed_line_node last! */
		}
		a2 = b2->q_forw;
		REQUE(b2, b1->q_forw);
		REQUE(a1->q_back, a2);
		REQUE(b1, a1);
		current_addr = addr + ((addr < first_addr) ?
		    second_addr - first_addr + 1 : 0);
	}
	if (isglobal)
		unset_active_nodes(b2->q_forw, a2);
	modified = 1;
	SPL0();
	return 0;
}


/* copy_lines: copy a range of lines; return status */
static int
copy_lines(int addr)
{
	line_t *lp, *np = get_addressed_line_node(first_addr);
	undo_t *up = NULL;
	int n = second_addr - first_addr + 1;
	int m = 0;

	current_addr = addr;
	if (first_addr <= addr && addr < second_addr) {
		n =  addr - first_addr + 1;
		m = second_addr - addr;
	}
	for (; n > 0; n=m, m=0, np = get_addressed_line_node(current_addr + 1))
		for (; n-- > 0; np = np->q_forw) {
			SPL1();
			if ((lp = dup_line_node(np)) == NULL) {
				SPL0();
				return ERR;
			}
			add_line_node(lp);
			if (up)
				up->t = lp;
			else if ((up = push_undo_stack(UADD, current_addr,
			    current_addr)) == NULL) {
				SPL0();
				return ERR;
			}
			modified = 1;
			SPL0();
		}
	return 0;
}


/* delete_lines: delete a range of lines */
int
delete_lines(int from, int to)
{
	line_t *n, *p;

	SPL1();
	if (push_undo_stack(UDEL, from, to) == NULL) {
		SPL0();
		return ERR;
	}
	n = get_addressed_line_node(INC_MOD(to, addr_last));
	p = get_addressed_line_node(from - 1);
					/* this get_addressed_line_node last! */
	if (isglobal)
		unset_active_nodes(p->q_forw, n);
	REQUE(p, n);
	addr_last -= to - from + 1;
	current_addr = from - 1;
	modified = 1;
	SPL0();
	return 0;
}


/* display_lines: print a range of lines to stdout */
int
display_lines(int from, int to, int gflag)
{
	line_t *bp;
	line_t *ep;
	char *s;

	if (!from) {
		seterrmsg("invalid address");
		return ERR;
	}
	ep = get_addressed_line_node(INC_MOD(to, addr_last));
	bp = get_addressed_line_node(from);
	for (; bp != ep; bp = bp->q_forw) {
		if ((s = get_sbuf_line(bp)) == NULL)
			return ERR;
		if (put_tty_line(s, bp->len, current_addr = from++, gflag) < 0)
			return ERR;
	}
	return 0;
}


#define MAXMARK 26			/* max number of marks */

static line_t *mark[MAXMARK];		/* line markers */
static int markno;			/* line marker count */

/* mark_line_node: set a line node mark */
static int
mark_line_node(line_t *lp, int n)
{
	if (!islower(n)) {
		seterrmsg("invalid mark character");
		return ERR;
	} else if (mark[n - 'a'] == NULL)
		markno++;
	mark[n - 'a'] = lp;
	return 0;
}


/* get_marked_node_addr: return address of a marked line */
static int
get_marked_node_addr(int n)
{
	if (!islower(n)) {
		seterrmsg("invalid mark character");
		return ERR;
	}
	return get_line_node_addr(mark[n - 'a']);
}


/* unmark_line_node: clear line node mark */
void
unmark_line_node(line_t *lp)
{
	int i;

	for (i = 0; markno && i < MAXMARK; i++)
		if (mark[i] == lp) {
			mark[i] = NULL;
			markno--;
		}
}


/* dup_line_node: return a pointer to a copy of a line node */
static line_t *
dup_line_node(line_t *lp)
{
	line_t *np;

	if ((np = malloc(sizeof(line_t))) == NULL) {
		perror(NULL);
		seterrmsg("out of memory");
		return NULL;
	}
	np->adr = lp->adr;
	np->len = lp->len;
	return np;
}


/* has_trailing_escape:  return the parity of escapes preceding a character
   in a string */
int
has_trailing_escape(char *s, char *t)
{
    return (s == t || *(t - 1) != '\\') ? 0 : !has_trailing_escape(s, t - 1);
}


/* strip_escapes: return copy of escaped string of at most length PATH_MAX */
char *
strip_escapes(const char *s)
{
	static char *file = NULL;
	static int filesz = 0;

	int i = 0;

	REALLOC(file, filesz, PATH_MAX, NULL);
	/* assert: no trailing escape */
	while ((file[i++] = (*s == '\\') ? *++s : *s) != '\0' &&
	       i < PATH_MAX-1)
		s++;
	file[PATH_MAX-1] = '\0';
	return file;
}


void
signal_hup(int signo)
{
	int save_errno = errno;

	if (mutex)
		sighup = 1;
	else
		handle_hup(signo);
	errno = save_errno;
}


void
signal_int(int signo)
{
	int save_errno = errno;

	if (mutex)
		sigint = 1;
	else
		handle_int(signo);
	errno = save_errno;
}


void
handle_hup(int signo __attribute__((__unused__)))
{
	char hup[PATH_MAX];

	if (!sigactive)
		quit(1);		/* XXX signal race */
	sighup = 0;
	/* XXX signal race */
	if (addr_last && write_file("ed.hup", "w", 1, addr_last) < 0 &&
	    home != NULL && home[0] == '/') {
		if (strlcpy(hup, home, sizeof(hup)) < sizeof(hup) &&
		    strlcat(hup, "/ed.hup", sizeof(hup)) < sizeof(hup))
			write_file(hup, "w", 1, addr_last);
	}
	_exit(2);
}


void
handle_int(int signo __attribute__((__unused__)))
{
	if (!sigactive)
		_exit(1);
	sigint = 0;
	siglongjmp(env, -1);
}


#if defined(SIGWINCH) && defined(TIOCGWINSZ)
void
handle_winch(int signo __attribute__((__unused__)))
{
	int save_errno = errno;
	struct winsize ws;		/* window size structure */

	if (ioctl(STDIN_FILENO, TIOCGWINSZ, &ws) >= 0) {
		if (ws.ws_row > 2)
			rows = ws.ws_row - 2;
		if (ws.ws_col > 8)
			cols = ws.ws_col - 8;
	}
	errno = save_errno;
}
#endif
@


1.14
log
@less clunky
@
text
@d68 1
a68 1
__RCSID("$MirOS: src/bin/ed/main.c,v 1.12 2017/04/02 16:46:26 tg Exp $");
a181 1
				setvbuf(stdout, NULL, _IOLBF, 0);
d185 2
@


1.13
log
@fullmerge
@
text
@d276 2
a277 2
			if (!interactive) {
				if (garrulous)
d279 2
a280 3
					    "script, line %d: %s\n",
					    lineno, errmsg);
			} else if (garrulous)
d282 1
@


1.12
log
@merge
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.59 2017/01/03 20:24:29 tb Exp $	*/
d68 1
a68 1
__RCSID("$MirOS: src/bin/ed/main.c,v 1.10 2016/11/06 18:58:44 tg Exp $");
d233 4
a236 3
					fprintf(stderr, garrulous ?
					    "script, line %d: %s\n" :
					    "", lineno, errmsg);
d268 4
a271 3
				fprintf(stderr, garrulous ?
				    "script, line %d: %s\n" :
				    "", lineno, errmsg);
d276 7
a282 7
			if (!interactive)
				fprintf(stderr, garrulous ?
				    "script, line %d: %s\n" : "",
				    lineno, errmsg);
			else
				fprintf(stderr, garrulous ? "%s\n" : "",
				    errmsg);
d288 4
a291 3
				fprintf(stderr, garrulous ?
				    "script, line %d: %s\n" : "",
				    lineno, errmsg);
d738 1
a738 1
		else if (addr && addr != addr_last)
@


1.11
log
@dietlibc needs <termios.h> for struct winsize

XXX imake style
XXX still not enough anyway
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.58 2016/08/16 20:04:46 natano Exp $	*/
d336 1
a336 1
	
d398 2
a399 1
				addr = addr_last;
@


1.10
log
@preliminary merge
@
text
@d61 3
d68 1
a68 1
__RCSID("$MirOS: src/bin/ed/main.c,v 1.9 2012/01/04 21:57:44 tg Exp $");
@


1.9
log
@cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.34 2010/08/12 02:00:28 kevlo Exp $	*/
d7 2
a8 2
 * Copyright (c) 2003, 2004, 2005, 2008, 2009, 2011, 2012
 *	Thorsten "mirabilos" Glaser <tg@@mirbsd.org>
a43 4
 *	The cbc.c encryption code is adapted from
 *	the bdes program by Matt Bishop of Dartmouth College,
 *	Hanover, NH.
 *
d49 1
d51 5
d57 4
a61 1
#include <pwd.h>
d65 19
a83 2
__RCSID("$MirOS: src/bin/ed/main.c,v 1.8 2012/01/04 21:38:46 tg Exp $"
	"\n\t@@(""#)rcsid: " ED_H_ID);
a84 1
#ifdef _POSIX_SOURCE
a85 3
#else
jmp_buf env;
#endif
d88 7
a94 4
char stdinbuf[1];		/* stdin buffer */
char *shcmd;			/* shell command buffer */
int shcmdsz;			/* shell command buffer size */
int shcmdi;			/* shell command buffer index */
a99 3
#ifdef DES
int des = 0;			/* if set, use crypt(3) for i/o */
#endif
a103 2
int mutex = 0;			/* if set, signals set "sigflags" */
int red = 0;			/* if set, restrict shell/directory access */
a104 1
int sigflags = 0;		/* if set, signals received while mutex set */
d107 4
a113 1
char old_filename[MAXPATHLEN] = "";	/* default filename */
d117 2
a118 3
const char *prompt;		/* command-line prompt */
const char dps[] = "*";		/* default command-line prompt */
char *home;			/* home directory */
d120 3
a122 1
const char usage[] = "usage: %s [-] [-sx] [-p string] [file]\n";
d135 6
a140 1
	int status = 0;
a143 1
	red = (n = strlen(argv[0])) > 2 && argv[0][n - 3] == 'r';
d148 1
a148 1
			prompt = optarg;
a153 3
#ifdef DES
			des = get_keyword();
#else
a154 1
#endif
a155 1

a178 1
#ifdef _IOLBF
a179 3
#else
				setlinebuf(stdout);
#endif
d186 2
a187 2
	handle_winch(SIGWINCH);
	if (isatty(0))
d189 1
d194 2
a195 6
#ifdef _POSIX_SOURCE
	if (status = sigsetjmp(env, 1))
#else
	if ((status = setjmp(env)) != 0)
#endif
	{
d201 1
a201 1
		if (argc && **argv && is_legal_filename(*argv)) {
d258 1
d279 1
d322 1
a322 1
		while (isspace(*ibufp) && *ibufp != '\n') \
d336 1
a336 1
int
d347 1
a347 1
		switch ((c = *ibufp)) {
d355 1
a355 1
			if (isdigit(*ibufp)) {
d385 1
a385 1
			if ((addr = get_marked_node_addr(*ibufp++)) < 0)
d502 1
a502 1
	static pattern_t *pat = NULL;
d506 1
a506 1
	pattern_t *tpat;
d515 1
a515 1
	switch ((c = *ibufp++)) {
d549 1
a549 1
		} else if (!isspace(*ibufp)) {
d580 1
a580 1
		} else if (!isspace(*ibufp)) {
d630 1
a630 2
			seterrmsg("invalid address");
			return ERR;
d647 1
a647 1
		c = *ibufp++;
d711 1
a711 1
		if (!isspace(*ibufp)) {
d850 1
a850 1
		if (!isspace(*ibufp)) {
d871 1
a871 1
		else if (addr == addr_last)
a881 3
#ifdef DES
		des = get_keyword();
#else
a883 2
#endif
		break;
d934 1
a934 1
int
d953 2
a954 2
int
get_matching_node_addr(pattern_t *pat, int dir)
d978 1
a978 1
char *
d998 1
a998 1
		} else if (n >= MAXPATHLEN) {
d1009 1
a1009 1
	REALLOC(file, filesz, MAXPATHLEN, NULL);
d1013 1
a1013 1
	return is_legal_filename(file) ? file : NULL;
d1019 1
a1019 1
int
d1029 1
a1029 4
	if (red) {
		seterrmsg("shell access restricted");
		return ERR;
	} else if ((s = ibufp = get_extended_line(&j, 1)) == NULL)
d1082 1
a1082 1
int
d1131 1
a1131 1
int
d1168 1
a1168 1
int
d1212 1
a1212 1
int
d1298 2
a1299 2
line_t	*mark[MAXMARK];			/* line markers */
int markno;				/* line marker count */
d1302 1
a1302 1
int
d1316 1
a1316 1
int
d1342 1
a1342 1
line_t *
d1347 1
a1347 1
	if ((np = (line_t *) malloc(sizeof(line_t))) == NULL) {
d1367 1
a1367 1
/* strip_escapes: return copy of escaped string of at most length MAXPATHLEN */
d1376 1
a1376 1
	REALLOC(file, filesz, MAXPATHLEN, NULL);
d1379 1
a1379 1
	       i < MAXPATHLEN-1)
d1381 1
a1381 1
	file[MAXPATHLEN-1] = '\0';
d1392 1
a1392 1
		sigflags |= (1 << (signo - 1));
d1405 1
a1405 1
		sigflags |= (1 << (signo - 1));
d1413 1
a1413 1
handle_hup(int signo)
d1415 1
a1415 1
	char hup[MAXPATHLEN];
d1418 2
a1419 2
		quit(1);
	sigflags &= ~(1 << (signo - 1));
d1432 1
a1432 1
handle_int(int signo)
d1436 1
a1436 2
	sigflags &= ~(1 << (signo - 1));
#ifdef _POSIX_SOURCE
a1437 3
#else
	longjmp(env, -1);
#endif
d1443 1
a1443 1
handle_winch(int signo)
a1447 1
	sigflags &= ~(1 << (signo - 1));
a1456 12


/* is_legal_filename: return a legal filename */
int
is_legal_filename(char *s)
{
	if (red && (*s == '!' || !strcmp(s, "..") || strchr(s, '/'))) {
		seterrmsg("shell access restricted");
		return 0;
	}
	return 1;
}
@


1.8
log
@prefer setvbuf(3) over its aliases; MSYS doesn’t have them (by RT)
@
text
@d7 2
d60 1
a60 1
__RCSID("$MirOS: src/bin/ed/main.c,v 1.7 2012/01/04 21:30:33 tg Exp $"
d79 1
d81 1
d101 1
a104 2
char *home;		/* home directory */

@


1.7
log
@http://linuxwiki.de/ApoStrophen
@
text
@d58 1
a58 1
__RCSID("$MirOS: src/bin/ed/main.c,v 1.6 2012/01/04 21:29:22 tg Exp $"
d158 3
d162 1
@


1.6
log
@fix use of f{seek,tell}{,o}, lseek
@
text
@d58 1
a58 1
__RCSID("$MirOS: src/bin/ed/main.c,v 1.5 2011/11/05 23:26:15 tg Exp $"
d154 1
a154 1
		/* assert: pipes show up as fifo's when fstat'd */
@


1.5
log
@make TIOCGWINSZ optional, for MSYS, 10x ir0nh34d
@
text
@d58 1
a58 1
__RCSID("$MirOS: src/bin/ed/main.c,v 1.4 2011/04/09 16:47:07 tg Exp $"
d156 1
a156 1
			if (lseek(STDIN_FILENO, 0, SEEK_CUR)) {
d1341 1
a1341 1
	np->seek = lp->seek;
@


1.4
log
@make __CRAZY clean
@
text
@d58 1
a58 1
__RCSID("$MirOS: src/bin/ed/main.c,v 1.3 2011/04/09 16:28:48 tg Exp $"
d164 1
a164 1
#ifdef SIGWINCH
d1434 1
d1450 1
@


1.3
log
@ed:
• merge openbsd
• sync portmdoc in manpage with template
• reduce diff against openbsd
• pimp

strlfun:
• add GNUmakefile embedded in C code


⇒ both: make this possible:

tg@@frozenfish:~ $ DIST=etch sudo cowbuilder --login
root@@frozenfish:/tmp# make -f strlfun.c
root@@frozenfish:/tmp/ed# make LDFLAGS=-L.. LDADD=-lstrlfun
root@@frozenfish:/tmp/ed# ./ed
@
text
@d58 2
a59 1
__RCSID("$MirOS: src/bin/ed/main.c,v 1.2 2009/06/18 20:45:51 tg Exp $");
d95 2
a96 2
char *prompt;			/* command-line prompt */
char *dps = "*";		/* default command-line prompt */
d98 1
a98 1
char *usage = "usage: %s [-] [-sx] [-p string] [file]\n";
d103 1
a103 1
seterrmsg(char *s)
d1358 1
a1358 1
strip_escapes(char *s)
@


1.2
log
@ARGH! the BSD macro *is* defined in <sys/param.h> so you cannot use it
as an indicator if to include it. By consequence, ed(1) was broken since
it used MAXPATHLEN=255 ipv the one from <sys/param.h> - Also fix MIN/MAX
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.28 2003/06/11 23:42:12 deraadt Exp $	*/
d58 1
a58 6
__COPYRIGHT("@@(#) Copyright (c) 1993 Andrew Moore, Talke Studio. \n\
 All rights reserved.\n");

__SCCSID("@@(#)main.c,v 1.1 1994/02/01 00:34:42 alm Exp");
__RCSID("$MirOS$");

a84 1
int sigactive = 0;		/* if set, signal handlers are enabled */
d87 3
d97 1
a97 1
char *usage = "usage: %s [-] [-sx] [-p string] [name]\n";
d154 2
a155 2
		if (fstat(0, &sb) || !S_ISFIFO(sb.st_mode)) {
			if (lseek(0, 0, SEEK_CUR)) {
d312 1
a312 1

d377 1
a377 1
			/* FALL THROUGH */
d523 1
a523 1
		/* fall through */
d1403 1
a1403 2
	char path[MAXPATHLEN];
	char *hup = NULL;		/* hup filename */
d1408 1
d1410 4
a1413 5
	    home != NULL &&
	    strlen(home) + sizeof("/ed.hup") <= MAXPATHLEN) {
		strlcpy(path, home, sizeof(path));
		strlcat(path, "/ed.hup", sizeof(path));
		write_file(hup, "w", 1, addr_last);
d1440 1
a1440 1
	if (ioctl(0, TIOCGWINSZ, (char *) &ws) >= 0) {
@


1.1
log
@Initial revision
@
text
@a31 14
#ifndef lint
char *copyright =
"@@(#) Copyright (c) 1993 Andrew Moore, Talke Studio. \n\
 All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char *rcsid = "@@(#)main.c,v 1.1 1994/02/01 00:34:42 alm Exp";
#else
static char rcsid[] = "$OpenBSD: main.c,v 1.28 2003/06/11 23:42:12 deraadt Exp $";
#endif
#endif /* not lint */

d58 6
d296 1
a296 1
	if ((addr_cnt = min(addr_cnt, 2)) == 1 || second_addr != addr)
d315 1
a315 1
	
d883 1
a883 1
		if (display_lines(second_addr, min(addr_last,
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@pull latest ed from openbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.34 2010/08/12 02:00:28 kevlo Exp $	*/
d32 14
d98 1
a100 3
/* if set, signal handlers are enabled */
volatile sig_atomic_t sigactive = 0;

d108 1
a108 1
char *usage = "usage: %s [-] [-sx] [-p string] [file]\n";
d165 2
a166 2
		if (fstat(STDIN_FILENO, &sb) || !S_ISFIFO(sb.st_mode)) {
			if (lseek(STDIN_FILENO, 0, SEEK_CUR)) {
d388 1
a388 1
			/* FALLTHROUGH */
d534 1
a534 1
		/* FALLTHROUGH */
d1414 2
a1415 1
	char hup[MAXPATHLEN];
a1419 1
	/* XXX signal race */
d1421 5
a1425 4
	    home != NULL && home[0] == '/') {
		if (strlcpy(hup, home, sizeof(hup)) < sizeof(hup) &&
		    strlcat(hup, "/ed.hup", sizeof(hup)) < sizeof(hup))
			write_file(hup, "w", 1, addr_last);
d1452 1
a1452 1
	if (ioctl(STDIN_FILENO, TIOCGWINSZ, &ws) >= 0) {
@


1.1.1.3
log
@Updates for ed(1) from Ox
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.58 2016/08/16 20:04:46 natano Exp $	*/
d42 4
a50 1

a51 5
#include <err.h>
#include <errno.h>
#include <limits.h>
#include <pwd.h>
#include <regex.h>
a52 4
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
d54 1
a57 16
void signal_hup(int);
void signal_int(int);
void handle_winch(int);

static int next_addr(void);
static int check_addr_range(int, int);
static int get_matching_node_addr(regex_t *, int);
static char *get_filename(void);
static int get_shell_command(void);
static int append_lines(int);
static int join_lines(int, int);
static int move_lines(int);
static int copy_lines(int);
static int mark_line_node(line_t *, int);
static int get_marked_node_addr(int);
static line_t *dup_line_node(line_t *);
d59 1
d61 3
d66 4
a69 7
static char errmsg[PATH_MAX + 40];	/* error message buffer */
static char *shcmd;		/* shell command buffer */
static int shcmdsz;		/* shell command buffer size */
static int shcmdi;		/* shell command buffer index */
static char old_filename[PATH_MAX];	/* default filename */

/* global buffers */
d75 1
d80 2
d83 1
a85 4
volatile sig_atomic_t mutex = 0;  /* if set, signals set flags */
volatile sig_atomic_t sighup = 0; /* if set, sighup received while mutex set */
volatile sig_atomic_t sigint = 0; /* if set, sigint received while mutex set */

d89 1
d93 2
a94 2
static char *prompt;		/* command-line prompt */
static char *dps = "*";		/* default command-line prompt */
d96 1
a96 1
static const char usage[] = "usage: %s [-] [-s] [-p string] [file]\n";
d98 1
a98 1
static char *home;		/* home directory */
a112 3
	if (pledge("stdio rpath wpath cpath proc exec tty", NULL) == -1)
		err(1, "pledge");

d115 1
d120 1
a120 1
			dps = prompt = optarg;
d126 3
d130 1
d132 1
d156 1
a156 1
				setvbuf(stdout, NULL, _IOLBF, 0);
d162 3
a164 2
	if (isatty(STDIN_FILENO)) {
		handle_winch(SIGWINCH);
d166 1
a166 1
	}
d170 6
a175 2
	if (sigsetjmp(env, 1)) {
		status = -1;
d181 1
a181 1
		if (argc && **argv) {
a237 1
			break;
a257 1
			break;
d300 1
a300 1
		while (isspace((unsigned char)*ibufp) && *ibufp != '\n') \
d314 1
a314 1
static int
d325 1
a325 1
		switch ((c = (unsigned char)*ibufp)) {
d333 1
a333 1
			if (isdigit((unsigned char)*ibufp)) {
d363 1
a363 1
			if ((addr = get_marked_node_addr((unsigned char)*ibufp++)) < 0)
d480 1
a480 1
	static regex_t *pat = NULL;
d484 1
a484 1
	regex_t *tpat;
d493 1
a493 1
	switch ((c = (unsigned char)*ibufp++)) {
d527 1
a527 1
		} else if (!isspace((unsigned char)*ibufp)) {
d558 1
a558 1
		} else if (!isspace((unsigned char)*ibufp)) {
d608 2
a609 1
			second_addr = 1;
d626 1
a626 1
		c = (unsigned char)*ibufp++;
d690 1
a690 1
		if (!isspace((unsigned char)*ibufp)) {
d829 1
a829 1
		if (!isspace((unsigned char)*ibufp)) {
d850 1
a850 1
		else if (addr == addr_last && *fnp != '!')
d861 3
d866 2
d918 1
a918 1
static int
d937 2
a938 2
static int
get_matching_node_addr(regex_t *pat, int dir)
d962 1
a962 1
static char *
d982 1
a982 1
		} else if (n >= PATH_MAX) {
d993 1
a993 1
	REALLOC(file, filesz, PATH_MAX, NULL);
d997 1
a997 1
	return file;
d1003 1
a1003 1
static int
d1013 4
a1016 1
	if ((s = ibufp = get_extended_line(&j, 1)) == NULL)
d1069 1
a1069 1
static int
d1118 1
a1118 1
static int
d1155 1
a1155 1
static int
d1199 1
a1199 1
static int
d1285 2
a1286 2
static line_t *mark[MAXMARK];		/* line markers */
static int markno;			/* line marker count */
d1289 1
a1289 1
static int
d1303 1
a1303 1
static int
d1329 1
a1329 1
static line_t *
d1334 1
a1334 1
	if ((np = malloc(sizeof(line_t))) == NULL) {
d1354 1
a1354 1
/* strip_escapes: return copy of escaped string of at most length PATH_MAX */
d1363 1
a1363 1
	REALLOC(file, filesz, PATH_MAX, NULL);
d1366 1
a1366 1
	       i < PATH_MAX-1)
d1368 1
a1368 1
	file[PATH_MAX-1] = '\0';
d1379 1
a1379 1
		sighup = 1;
d1392 1
a1392 1
		sigint = 1;
d1402 1
a1402 1
	char hup[PATH_MAX];
d1405 2
a1406 2
		quit(1);		/* XXX signal race */
	sighup = 0;
d1423 2
a1424 1
	sigint = 0;
d1426 3
d1438 1
d1447 12
@


1.1.1.4
log
@Import ed(1) from OpenBSD CVS
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.59 2017/01/03 20:24:29 tb Exp $	*/
d386 1
a386 2
				if ((addr = next_addr()) < 0)
					addr = addr_last;
@


1.1.1.5
log
@The “let’s obsolete mwl’s book just after its release” import
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.61 2018/02/26 17:35:08 martijn Exp $	*/
d221 3
a223 4
					if (garrulous)
						fprintf(stderr,
						    "script, line %d: %s\n",
						    lineno, errmsg);
d255 3
a257 4
				if (garrulous)
					fprintf(stderr,
					    "script, line %d: %s\n",
					    lineno, errmsg);
d262 7
a268 7
			if (!interactive) {
				if (garrulous)
					fprintf(stderr,
					    "script, line %d: %s\n",
					    lineno, errmsg);
			} else if (garrulous)
				fprintf(stderr, "%s\n", errmsg);
d274 3
a276 4
				if (garrulous)
					fprintf(stderr,
					    "script, line %d: %s\n",
					    lineno, errmsg);
d723 1
a723 1
		else if (addr)
@


