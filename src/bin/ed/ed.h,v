head	1.11;
access;
symbols
	cvs-201804291800:1.1.1.3
	cvs-201704021600:1.1.1.3
	cvs-201611061700:1.1.1.3
	cvs-201104091530:1.1.1.2
	MIRBSD_10:1.1.1.1.0.4
	MIRBSD_10_BASE:1.1.1.1
	MIRBSD_9_BASE:1.1.1.1
	MIRBSD_8:1.1.1.1.0.2
	MIRBSD_8_BASE:1.1.1.1
	cvs-200507211800:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.11.06.19.36.02;	author tg;	state Exp;
branches;
next	1.10;
commitid	100581F86325258F663;

1.10
date	2016.11.06.18.58.44;	author tg;	state Exp;
branches;
next	1.9;
commitid	100581F7D79676B0355;

1.9
date	2013.10.31.20.05.37;	author tg;	state Exp;
branches;
next	1.8;
commitid	1005272B7081B0E5655;

1.8
date	2012.01.04.21.57.44;	author tg;	state Exp;
branches;
next	1.7;
commitid	1004F04CB6F09F9D6F7;

1.7
date	2012.01.04.21.29.22;	author tg;	state Exp;
branches;
next	1.6;
commitid	1004F04C4C93E344CEA;

1.6
date	2011.11.08.23.17.27;	author tg;	state Exp;
branches;
next	1.5;
commitid	1004EB9B896541203F4;

1.5
date	2011.04.09.16.47.06;	author tg;	state Exp;
branches;
next	1.4;
commitid	1004DA08DA1052D2486;

1.4
date	2011.04.09.16.28.48;	author tg;	state Exp;
branches;
next	1.3;
commitid	1004DA0890A2EA8ED27;

1.3
date	2009.06.18.20.45.51;	author tg;	state Exp;
branches;
next	1.2;
commitid	1004A3AA7566C06EEDC;

1.2
date	2008.11.02.23.00.30;	author tg;	state Exp;
branches;
next	1.1;
commitid	100490E312132E0FD49;

1.1
date	2005.02.05.17.22.04;	author tg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.02.05.17.22.04;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.04.09.15.54.12;	author tg;	state Exp;
branches;
next	1.1.1.3;
commitid	1004DA081363B8A3AA8;

1.1.1.3
date	2016.11.06.17.31.57;	author tg;	state Exp;
branches;
next	;
commitid	100581F69214EA355AF;


desc
@@


1.11
log
@we'll need this to be warning-free with GNU
@
text
@#define ED_H_ID "$MirOS: src/bin/ed/ed.h,v 1.10 2016/11/06 18:58:44 tg Exp $"
/*	$OpenBSD: ed.h,v 1.22 2016/03/27 00:43:38 mmcc Exp $	*/
/*	$NetBSD: ed.h,v 1.23 1995/03/21 09:04:40 cgd Exp $	*/

/* ed.h: type and constant definitions for the ed editor. */
/*
 * Copyright © 2013, 2016
 *	mirabilos <m@@mirbsd.org>
 * Copyright (c) 1993 Andrew Moore
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ed.h,v 1.5 1994/02/01 00:34:39 alm Exp
 */

#include <limits.h>
#include <regex.h>
#include <signal.h>

#ifdef NEED_STRLFUN_DECL
size_t strlcat(char *, const char *, size_t);
size_t strlcpy(char *, const char *, size_t);
#endif

#ifdef NEED_REALLOCARRAY_DECL
void *reallocarray(void *, size_t, size_t);
#endif

#define ERR		(-2)
#define EMOD		(-3)
#define FATAL		(-4)

#define MINBUFSZ 512		/* minimum buffer size - must be > 0 */
#define SE_MAX 30		/* max subexpressions in a regular expression */
#define LINECHARS INT_MAX	/* max chars per line */

#ifdef NO_FSEEKO
#define do_fseek fseek
#define do_ftell ftell
#define tp_ftell long
#else
#define do_fseek fseeko
#define do_ftell ftello
#define tp_ftell off_t
#endif

/* gflags */
#define GLB 001		/* global command */
#define GPR 002		/* print after command */
#define GLS 004		/* list after command */
#define GNP 010		/* enumerate after command */
#define GSG 020		/* global substitute */

/* Line node */
typedef struct	line {
	struct line	*q_forw;
	struct line	*q_back;
	tp_ftell	adr;		/* address of line in scratch buffer */
	int		len;		/* length of line */
} line_t;


typedef struct undo {

/* type of undo nodes */
#define UADD	0
#define UDEL 	1
#define UMOV	2
#define VMOV	3

	int type;			/* command type */
	line_t	*h;			/* head of list */
	line_t  *t;			/* tail of list */
} undo_t;

#ifndef MAX
# define MAX(a,b) ((a) > (b) ? (a) : (b))
#endif
#ifndef MIN
# define MIN(a,b) ((a) < (b) ? (a) : (b))
#endif

#define INC_MOD(l, k)	((l) + 1 > (k) ? 0 : (l) + 1)
#define DEC_MOD(l, k)	((l) - 1 < 0 ? (k) : (l) - 1)

/* SPL1: disable some interrupts (requires reliable signals) */
#define SPL1() mutex++

/* SPL0: enable all interrupts; check signal flags (requires reliable signals) */
#define SPL0()						\
	do {						\
		if (--mutex == 0) {			\
			if (sighup)			\
				handle_hup(SIGHUP);	\
			if (sigint)			\
				handle_int(SIGINT);	\
		}					\
	} while (0)

/* STRTOI: convert a string to int */
#define STRTOI(i, p) { \
	long l = strtol(p, &p, 10); \
	if (l <= INT_MIN || l >= INT_MAX) { \
		seterrmsg("number out of range"); \
	    	i = 0; \
		return ERR; \
	} else \
		i = (int)l; \
}

/* REALLOC: assure at least a minimum size for buffer b */
#define REALLOC(b,n,i,err) \
if ((i) > (n)) { \
	int ti = (n); \
	char *ts; \
	SPL1(); \
	if ((ts = realloc((b), ti += MAX((i), MINBUFSZ))) == NULL) { \
		perror(NULL); \
		seterrmsg("out of memory"); \
		SPL0(); \
		return err; \
	} \
	(n) = ti; \
	(b) = ts; \
	SPL0(); \
}

/* REQUE: link pred before succ */
#define REQUE(pred, succ) (pred)->q_forw = (succ), (succ)->q_back = (pred)

/* INSQUE: insert elem in circular queue after pred */
#define INSQUE(elem, pred) \
{ \
	REQUE((elem), (pred)->q_forw); \
	REQUE((pred), elem); \
}

/* remque: remove_lines elem from circular queue */
#define REMQUE(elem) REQUE((elem)->q_back, (elem)->q_forw);

/* NUL_TO_NEWLINE: overwrite ASCII NULs with newlines */
#define NUL_TO_NEWLINE(s, l) translit_text(s, l, '\0', '\n')

/* NEWLINE_TO_NUL: overwrite newlines with ASCII NULs */
#define NEWLINE_TO_NUL(s, l) translit_text(s, l, '\n', '\0')

/* Local Function Declarations */
void add_line_node(line_t *);
int build_active_list(int);
void clear_active_list(void);
void clear_undo_stack(void);
int close_sbuf(void);
int delete_lines(int, int);
int display_lines(int, int, int);
int exec_command(void);
int exec_global(int, int);
int extract_addr_range(void);
int extract_subst_tail(int *, int *);
line_t *get_addressed_line_node(int);
regex_t *get_compiled_pattern(void);
char *get_extended_line(int *, int);
int get_line_node_addr(line_t *);
char *get_sbuf_line(line_t *);
int get_tty_line(void);
void handle_hup(int) __attribute__((__noreturn__));
void handle_int(int) __attribute__((__noreturn__));
int has_trailing_escape(char *, char *);
void init_buffers(void);
int open_sbuf(void);
int pop_undo_stack(void);
undo_t *push_undo_stack(int, int, int);
char *put_sbuf_line(char *);
int put_tty_line(char *, int, int, int);
void quit(int) __attribute__((__noreturn__));
int read_file(char *, int);
int search_and_replace(regex_t *, int, int);
void seterrmsg(const char *);
char *strip_escapes(const char *);
char *translit_text(char *, int, int, int);
void unmark_line_node(line_t *);
void unset_active_nodes(line_t *, line_t *);
int write_file(const char *, const char *, int, int);

/* global buffers */
extern char *ibuf;
extern char *ibufp;
extern int ibufsz;

/* global flags */
extern int isbinary;
extern int isglobal;
extern int modified;

extern volatile sig_atomic_t mutex;
extern volatile sig_atomic_t sighup;
extern volatile sig_atomic_t sigint;

/* global vars */
extern int addr_last;
extern int current_addr;
extern int first_addr;
extern int lineno;
extern int second_addr;
@


1.10
log
@preliminary merge
@
text
@d1 1
a1 1
#define ED_H_ID "$MirOS: src/bin/ed/ed.h,v 1.9 2013/10/31 20:05:37 tg Exp $"
d40 9
@


1.9
log
@adapt most __attribute__((…)) occurrences to new KNF style(9)
@
text
@d1 2
a2 2
#define ED_H_ID "$MirOS: src/bin/ed/ed.h,v 1.8 2012/01/04 21:57:44 tg Exp $"
/*	$OpenBSD: ed.h,v 1.11 2007/02/24 13:24:47 millert Exp $	*/
d7 2
a8 2
 * Copyright © 2013
 *	Thorsten “mirabilos” Glaser <tg@@mirbsd.org>
d36 1
a36 9
#include <sys/types.h>
#ifndef NO_SYS_PARAM_H
# include <sys/param.h>		/* for MAXPATHLEN */
#endif
#include <errno.h>
#if defined(sun) || defined(__NetBSD__) || defined(__OpenBSD__) || \
    defined(__EXT_QNX)
# include <limits.h>
#endif
a38 4
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
a43 4
#ifndef MAXPATHLEN
# define MAXPATHLEN 255		/* _POSIX_PATH_MAX */
#endif

d46 1
a46 5
#ifdef INT_MAX
# define LINECHARS INT_MAX	/* max chars per line */
#else
# define LINECHARS MAXINT	/* max chars per line */
#endif
a64 2
typedef regex_t pattern_t;

d100 10
a109 6
/* SPL0: enable all interrupts; check sigflags (requires reliable signals) */
#define SPL0() \
if (--mutex == 0) { \
	if (sigflags & (1 << (SIGHUP - 1))) handle_hup(SIGHUP); \
	if (sigflags & (1 << (SIGINT - 1))) handle_int(SIGINT); \
}
a121 1
#if defined(sun) || defined(NO_REALLOC_NULL)
d128 1
a128 27
	if ((b) != NULL) { \
		if ((ts = (char *) realloc((b), ti += MAX((i), MINBUFSZ))) == NULL) { \
			perror(NULL); \
			seterrmsg("out of memory"); \
			SPL0(); \
			return err; \
		} \
	} else { \
		if ((ts = (char *) malloc(ti += MAX((i), MINBUFSZ))) == NULL) { \
			perror(NULL); \
			seterrmsg("out of memory"); \
			SPL0(); \
			return err; \
		} \
	} \
	(n) = ti; \
	(b) = ts; \
	SPL0(); \
}
#else /* NO_REALLOC_NULL */
/* REALLOC: assure at least a minimum size for buffer b */
#define REALLOC(b,n,i,err) \
if ((i) > (n)) { \
	int ti = (n); \
	char *ts; \
	SPL1(); \
	if ((ts = (char *) realloc((b), ti += MAX((i), MINBUFSZ))) == NULL) { \
a137 1
#endif /* NO_REALLOC_NULL */
a157 4
#ifdef sun
# define strerror(n) sys_errlist[n]
#endif

a159 2
int append_lines(int);
int apply_subst_template(char *, regmatch_t *, int, int);
a160 1
int check_addr_range(int, int);
a163 1
int copy_lines(int);
a165 1
line_t *dup_line_node(line_t *);
a168 1
char *extract_pattern(int);
a169 2
char *extract_subst_template(void);
int flush_des_file(FILE *);
d171 1
a171 2
pattern_t *get_compiled_pattern(void);
int get_des_char(FILE *);
a172 2
char *get_filename(void);
int get_keyword(void);
a173 2
int get_matching_node_addr(pattern_t *, int);
int get_marked_node_addr(int);
a174 2
int get_shell_command(void);
int get_stream_line(FILE *);
a177 1
void handle_winch(int);
a179 7
void init_des_cipher(void);
int is_legal_filename(char *);
int join_lines(int, int);
int mark_line_node(line_t *, int);
int move_lines(int);
line_t *next_active_node(void);
int next_addr(void);
a180 1
char *parse_char_class(char *);
a182 1
int put_des_char(int, FILE *);
a183 1
int put_stream_line(FILE *, char *, int);
d187 1
a187 3
int read_stream(FILE *, int);
int search_and_replace(pattern_t *, int, int);
int set_active_node(line_t *);
a188 2
void signal_hup(int);
void signal_int(int);
a189 1
int substitute_matching_text(pattern_t *, line_t *, int, int);
a193 1
int write_stream(FILE *, int, int);
a195 1
extern char stdinbuf[];
d204 4
a207 2
extern int mutex;
extern int sigflags;
a211 1
extern char errmsg[MAXPATHLEN + 40];
a214 3
#ifdef sun
extern char *sys_errlist[];
#endif
@


1.8
log
@cleanup
@
text
@d1 1
a1 1
#define ED_H_ID "$MirOS: src/bin/ed/ed.h,v 1.7 2012/01/04 21:29:22 tg Exp $"
d7 2
d241 2
a242 2
void handle_hup(int) __attribute__((noreturn));
void handle_int(int) __attribute__((noreturn));
d261 1
a261 1
void quit(int) __attribute__((noreturn));
@


1.7
log
@fix use of f{seek,tell}{,o}, lseek
@
text
@d1 1
a1 1
#define ED_H_ID "$MirOS: src/bin/ed/ed.h,v 1.6 2011/11/08 23:17:27 tg Exp $"
a210 2
int cbc_decode(char *, FILE *);
int cbc_encode(char *, int, FILE *);
a216 1
void des_error(const char *);
a220 1
void expand_des_key(char *, char *);
a242 1
int hex_to_binary(int, int);
a263 1
void set_des_key(char *);
@


1.6
log
@allow building on systems without fseeko/ftello
@
text
@d1 1
a1 1
#define ED_H_ID "$MirOS: src/bin/ed/ed.h,v 1.5 2011/04/09 16:47:06 tg Exp $"
d89 1
a89 1
	tp_ftell	seek;		/* address of line in scratch buffer */
@


1.5
log
@make __CRAZY clean
@
text
@d1 1
a1 1
#define ED_H_ID "$MirOS: src/bin/ed/ed.h,v 1.4 2011/04/09 16:28:48 tg Exp $"
d66 10
d89 1
a89 1
	off_t		seek;		/* address of line in scratch buffer */
@


1.4
log
@ed:
• merge openbsd
• sync portmdoc in manpage with template
• reduce diff against openbsd
• pimp

strlfun:
• add GNUmakefile embedded in C code


⇒ both: make this possible:

tg@@frozenfish:~ $ DIST=etch sudo cowbuilder --login
root@@frozenfish:/tmp# make -f strlfun.c
root@@frozenfish:/tmp/ed# make LDFLAGS=-L.. LDADD=-lstrlfun
root@@frozenfish:/tmp/ed# ./ed
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/ed/ed.h,v 1.3 2009/06/18 20:45:51 tg Exp $ */
d209 1
a209 1
void des_error(char *);
d233 2
a234 2
void handle_hup(int);
void handle_int(int);
d254 1
a254 1
void quit(int);
d260 1
a260 1
void seterrmsg(char *);
d263 1
a263 1
char *strip_escapes(char *);
d268 1
a268 1
int write_file(char *, char *, int, int);
@


1.3
log
@ARGH! the BSD macro *is* defined in <sys/param.h> so you cannot use it
as an indicator if to include it. By consequence, ed(1) was broken since
it used MAXPATHLEN=255 ipv the one from <sys/param.h> - Also fix MIN/MAX
@
text
@d1 2
a2 2
/**	$MirOS$ */
/*	$OpenBSD: ed.h,v 1.10 2002/03/24 22:17:04 millert Exp $	*/
a218 1
int filter_lines(int, int, char *);
@


1.2
log
@supplement for QNX
@
text
@d1 1
d35 1
a35 1
#if defined(BSD) && BSD >= 199103 || defined(__386BSD__)
d97 2
a98 2
#ifndef max
# define max(a,b) ((a) > (b) ? (a) : (b))
d100 2
a101 2
#ifndef min
# define min(a,b) ((a) < (b) ? (a) : (b))
d136 1
a136 1
		if ((ts = (char *) realloc((b), ti += max((i), MINBUFSZ))) == NULL) { \
d143 1
a143 1
		if ((ts = (char *) malloc(ti += max((i), MINBUFSZ))) == NULL) { \
d161 1
a161 1
	if ((ts = (char *) realloc((b), ti += max((i), MINBUFSZ))) == NULL) { \
@


1.1
log
@Initial revision
@
text
@d38 2
a39 1
#if defined(sun) || defined(__NetBSD__) || defined(__OpenBSD__)
@


1.1.1.1
log
@Import the OpenBSD foundation of MirOS BSD
@
text
@@


1.1.1.2
log
@pull latest ed from openbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: ed.h,v 1.11 2007/02/24 13:24:47 millert Exp $	*/
d217 1
@


1.1.1.3
log
@Updates for ed(1) from Ox
@
text
@d1 1
a1 1
/*	$OpenBSD: ed.h,v 1.22 2016/03/27 00:43:38 mmcc Exp $	*/
d33 8
a40 1
#include <limits.h>
d43 4
d52 4
d58 5
a62 1
#define LINECHARS INT_MAX	/* max chars per line */
d71 2
d108 6
a113 10
/* SPL0: enable all interrupts; check signal flags (requires reliable signals) */
#define SPL0()						\
	do {						\
		if (--mutex == 0) {			\
			if (sighup)			\
				handle_hup(SIGHUP);	\
			if (sigint)			\
				handle_int(SIGINT);	\
		}					\
	} while (0)
d126 27
d159 1
a159 1
	if ((ts = realloc((b), ti += max((i), MINBUFSZ))) == NULL) { \
d169 1
d190 4
d196 2
d199 3
d205 1
d207 1
d209 1
d212 1
d214 1
d216 2
d219 2
a220 1
regex_t *get_compiled_pattern(void);
d222 2
d225 2
d228 2
d233 1
d235 1
d237 7
d245 1
d248 1
d250 1
d254 4
a257 1
int search_and_replace(regex_t *, int, int);
d259 2
d262 1
d267 1
d270 1
d279 2
a280 4

extern volatile sig_atomic_t mutex;
extern volatile sig_atomic_t sighup;
extern volatile sig_atomic_t sigint;
d285 1
d289 3
@


