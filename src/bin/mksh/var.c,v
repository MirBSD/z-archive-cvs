head	1.234;
access;
symbols
	mksh-R57:1.226
	mksh-R56c:1.223
	mksh-R56b:1.220
	mksh-R56:1.220
	mksh-R55:1.214
	mksh-R54:1.209
	mksh-R53a:1.207
	mksh-R53:1.207
	mksh-R52c:1.201
	mksh-R52b:1.197
	mksh-R52:1.195
	mksh-R51:1.193
	mksh-R50f:1.183.2.4
	mksh-R50e:1.183.2.2
	mksh-R50stable:1.183.0.2
	mksh-R50d:1.183
	mksh-R50c:1.182
	mksh-R50b:1.181
	mksh-R50:1.180
	mksh-R49:1.177
	mksh-R48b:1.173
	mksh-R48:1.173
	mksh-R47:1.173
	mksh-R46:1.172
	mksh-R45:1.170
	mksh-R44:1.166
	mksh-R43:1.166
	mksh-R42b:1.165
	mksh-R41c:1.161.2.2
	mksh-R41b:1.161.2.2
	mksh-R42:1.165
	mksh-R41:1.161
	mksh-R41stable:1.161.0.2
	mksh-wheezy:1.151.0.2
	tg-multikey-bind:1.148.0.2
	mksh-R40f:1.130.2.8
	mksh-R40e:1.130.2.8
	mksh-R40d:1.130.2.6
	mksh-R40c:1.130.2.4
	mksh-R40b:1.130.2.1
	mksh-R40stable:1.130.0.2
	mksh-R40:1.123
	mksh-R39c:1.104
	mksh-R39b:1.104
	tg-wcswidth-behaviour:1.96.0.2
	tg-rndtrace:1.90.0.2
	tg-nameref:1.86.0.2
	mksh-R39:1.76
	tg-mksh-printf-builtin:1.75.0.2
	mksh-R38c:1.74
	mksh-R38b:1.72
	mksh-R38:1.72
	mksh-R37c:1.71
	mksh-R37b:1.69
	mksh-R37:1.69
	mksh-R36b:1.65
	tg-aalloc-experimental_BASE:1.62
	tg-aalloc-experimental:1.62.0.2
	mksh-R36:1.57
	mksh-R35b:1.57
	mksh-R35:1.56
	mksh-R33d:1.51
	mksh-R33c:1.51
	mksh-R33b:1.51
	MIRBSD_10:1.51.0.2
	MIRBSD_10_BASE:1.51
	mksh-R33:1.51
	mksh-R32:1.50
	mksh-R31d:1.45
	mksh-R31c:1.45
	mksh-R31b:1.45
	mksh-R31:1.44
	mksh-R30:1.42
	mksh-R29g:1.37.2.2
	mksh-R29f:1.37.2.1
	mksh-R29e:1.37.2.1
	mksh-R29stable:1.37.0.2
	mksh-R29d:1.37
	mksh-R29c:1.37
	mksh-R29b:1.37
	mksh-R29:1.37
	mksh-R28:1.23
	tg-mksh-plan9ape_BASE:1.23
	tg-mksh-plan9ape:1.21.0.2
	mksh-R27e:1.20
	MIRBSD_9_BASE:1.19
	mksh-R27d:1.19
	mksh-R27:1.18
	mksh-R26c:1.15
	mksh-R26b:1.12
	MIRBSD_8:1.12.0.2
	MIRBSD_8_BASE:1.12
	mksh-R26:1.12
	mksh-R25:1.11
	mksh-R24c:1.8
	mksh-R24b:1.8
	mksh-R24:1.8
	mksh-R23:1.6
	mksh-R22:1.6
	mksh-R21:1.3;
locks; strict;
comment	@ * @;


1.234
date	2019.12.30.04.49.31;	author tg;	state Exp;
branches;
next	1.233;
commitid	1005E0981D52F9F9769;

1.233
date	2019.12.12.12.13.25;	author tg;	state Exp;
branches;
next	1.232;
commitid	1005DF22EAE58DB1EF6;

1.232
date	2019.12.11.23.58.21;	author tg;	state Exp;
branches;
next	1.231;
commitid	1005DF182AD50645981;

1.231
date	2019.12.11.22.27.30;	author tg;	state Exp;
branches;
next	1.230;
commitid	1005DF16C840A030F8D;

1.230
date	2019.12.11.21.32.48;	author tg;	state Exp;
branches;
next	1.229;
commitid	1005DF1608F4048BFDA;

1.229
date	2019.12.11.20.55.14;	author tg;	state Exp;
branches;
next	1.228;
commitid	1005DF157C356F89236;

1.228
date	2019.12.11.20.34.42;	author tg;	state Exp;
branches;
next	1.227;
commitid	1005DF152EE279E1FF5;

1.227
date	2019.08.02.00.21.53;	author tg;	state Exp;
branches;
next	1.226;
commitid	1005D438238756E008E;

1.226
date	2018.07.15.17.21.24;	author tg;	state Exp;
branches;
next	1.225;
commitid	1005B4B82617DF9E3F8;

1.225
date	2018.05.07.00.07.23;	author tg;	state Exp;
branches;
next	1.224;
commitid	1005AEF98C1361833B5;

1.224
date	2018.04.28.07.07.39;	author tg;	state Exp;
branches;
next	1.223;
commitid	1005AE41DB710ED1782;

1.223
date	2018.01.13.23.55.15;	author tg;	state Exp;
branches;
next	1.222;
commitid	1005A5A9C627E45C2B1;

1.222
date	2018.01.13.21.38.10;	author tg;	state Exp;
branches;
next	1.221;
commitid	1005A5A7C0944B414C1;

1.221
date	2017.10.13.23.34.49;	author tg;	state Exp;
branches;
next	1.220;
commitid	10059E14D8576FA91D3;

1.220
date	2017.07.26.23.02.28;	author tg;	state Exp;
branches;
next	1.219;
commitid	10059791F906168237F;

1.219
date	2017.05.05.22.53.32;	author tg;	state Exp;
branches;
next	1.218;
commitid	100590D026845CD3DFF;

1.218
date	2017.05.05.20.36.03;	author tg;	state Exp;
branches;
next	1.217;
commitid	100590CE24264B3D492;

1.217
date	2017.04.29.22.04.31;	author tg;	state Exp;
branches;
next	1.216;
commitid	10059050DFF02CF9B3E;

1.216
date	2017.04.27.19.33.53;	author tg;	state Exp;
branches;
next	1.215;
commitid	100590247A92C66CAF9;

1.215
date	2017.04.22.00.07.10;	author tg;	state Exp;
branches;
next	1.214;
commitid	10058FA9D043131DCC0;

1.214
date	2017.04.02.16.47.43;	author tg;	state Exp;
branches;
next	1.213;
commitid	10058E12B3D7E04D5CE;

1.213
date	2017.04.02.16.25.23;	author tg;	state Exp;
branches;
next	1.212;
commitid	10058E1260356DE82DA;

1.212
date	2017.04.02.16.07.04;	author tg;	state Exp;
branches;
next	1.211;
commitid	10058E121B861F559E6;

1.211
date	2017.04.02.15.51.20;	author tg;	state Exp;
branches;
next	1.210;
commitid	10058E11DFA37740F34;

1.210
date	2017.03.26.00.10.26;	author tg;	state Exp;
branches;
next	1.209;
commitid	10058D706207E0A1FF4;

1.209
date	2016.11.11.23.31.39;	author tg;	state Exp;
branches;
next	1.208;
commitid	100582654B972655F84;

1.208
date	2016.10.22.23.56.50;	author tg;	state Exp;
branches;
next	1.207;
commitid	100580BFCCF7344F495;

1.207
date	2016.08.01.21.38.07;	author tg;	state Exp;
branches;
next	1.206;
commitid	100579FC12F14735847;

1.206
date	2016.07.25.21.02.13;	author tg;	state Exp;
branches;
next	1.205;
commitid	10057967E6E4D7B1F1D;

1.205
date	2016.07.25.20.43.54;	author tg;	state Exp;
branches;
next	1.204;
commitid	10057967A0D0C01C9C9;

1.204
date	2016.07.25.00.04.48;	author tg;	state Exp;
branches;
next	1.203;
commitid	1005795579F14A3FE5C;

1.203
date	2016.07.12.23.06.26;	author tg;	state Exp;
branches;
next	1.202;
commitid	100578577EC7B0BCBF1;

1.202
date	2016.05.05.22.56.15;	author tg;	state Exp;
branches;
next	1.201;
commitid	100572BCF9760C8313C;

1.201
date	2016.03.01.20.28.33;	author tg;	state Exp;
branches;
next	1.200;
commitid	10056D5FB7328F05C8D;

1.200
date	2016.03.01.20.06.15;	author tg;	state Exp;
branches;
next	1.199;
commitid	10056D5F63D4C4E7F63;

1.199
date	2016.02.26.18.48.14;	author tg;	state Exp;
branches;
next	1.198;
commitid	10056D09DEF7B46FCA2;

1.198
date	2016.01.21.18.24.45;	author tg;	state Exp;
branches;
next	1.197;
commitid	10056A12268001BF859;

1.197
date	2016.01.14.22.49.33;	author tg;	state Exp;
branches;
next	1.196;
commitid	100569825E73343E900;

1.196
date	2016.01.14.20.21.39;	author tg;	state Exp;
branches;
next	1.195;
commitid	1005698036956894771;

1.195
date	2015.10.09.16.11.19;	author tg;	state Exp;
branches;
next	1.194;
commitid	1005617E72E4A2BA371;

1.194
date	2015.09.05.19.19.12;	author tg;	state Exp;
branches;
next	1.193;
commitid	10055EB402C54C3076B;

1.193
date	2015.07.10.19.36.38;	author tg;	state Exp;
branches;
next	1.192;
commitid	10055A01EBD784EE31A;

1.192
date	2015.04.29.20.07.35;	author tg;	state Exp;
branches;
next	1.191;
commitid	100554139453DB97755;

1.191
date	2015.04.29.18.38.54;	author tg;	state Exp;
branches;
next	1.190;
commitid	100554125524190E2D8;

1.190
date	2015.04.19.18.50.38;	author tg;	state Exp;
branches;
next	1.189;
commitid	1005533F8D6407346B7;

1.189
date	2015.04.19.18.13.31;	author tg;	state Exp;
branches;
next	1.188;
commitid	1005533F0025455C60A;

1.188
date	2015.04.19.14.22.09;	author tg;	state Exp;
branches;
next	1.187;
commitid	1005533BA1957FA1A6A;

1.187
date	2015.03.07.20.46.31;	author tg;	state Exp;
branches;
next	1.186;
commitid	10054FB63890799A9FA;

1.186
date	2015.02.06.10.56.49;	author tg;	state Exp;
branches;
next	1.185;
commitid	10054D49DF4344D0AFC;

1.185
date	2014.12.15.23.18.47;	author tg;	state Exp;
branches;
next	1.184;
commitid	100548F6C16391FF689;

1.184
date	2014.11.25.21.13.31;	author tg;	state Exp;
branches;
next	1.183;
commitid	1005474F00E09321C83;

1.183
date	2014.10.04.11.47.19;	author tg;	state Exp;
branches
	1.183.2.1;
next	1.182;
commitid	100542FDE4766613707;

1.182
date	2014.10.03.17.20.03;	author tg;	state Exp;
branches;
next	1.181;
commitid	100542EDAC71F03264F;

1.181
date	2014.09.03.19.22.51;	author tg;	state Exp;
branches;
next	1.180;
commitid	10054076A8136C0C0D1;

1.180
date	2014.06.26.20.36.02;	author tg;	state Exp;
branches;
next	1.179;
commitid	10053AC84342ABA312F;

1.179
date	2014.06.09.11.13.19;	author tg;	state Exp;
branches;
next	1.178;
commitid	100539596D30E12579C;

1.178
date	2014.05.27.13.22.46;	author tg;	state Exp;
branches;
next	1.177;
commitid	1005384911C31753F0C;

1.177
date	2014.01.11.18.09.43;	author tg;	state Exp;
branches;
next	1.176;
commitid	10052D188DD7DFEC194;

1.176
date	2014.01.05.21.57.29;	author tg;	state Exp;
branches;
next	1.175;
commitid	10052C9D445413B34DF;

1.175
date	2014.01.05.19.14.18;	author tg;	state Exp;
branches;
next	1.174;
commitid	10052C9AF1F443DA345;

1.174
date	2014.01.05.19.11.46;	author tg;	state Exp;
branches;
next	1.173;
commitid	10052C9AE727A4482D3;

1.173
date	2013.05.31.22.47.14;	author tg;	state Exp;
branches;
next	1.172;
commitid	10051A9287543AE1F04;

1.172
date	2013.05.02.20.23.09;	author tg;	state Exp;
branches;
next	1.171;
commitid	1005182CB453941DC6B;

1.171
date	2013.04.27.18.50.25;	author tg;	state Exp;
branches;
next	1.170;
commitid	100517C1D840086DC8F;

1.170
date	2013.04.07.14.11.54;	author tg;	state Exp;
branches;
next	1.169;
commitid	10051617E987C9B32B4;

1.169
date	2013.04.01.02.37.53;	author tg;	state Exp;
branches;
next	1.168;
commitid	1005158F2D44922CF13;

1.168
date	2013.03.31.18.30.05;	author tg;	state Exp;
branches;
next	1.167;
commitid	100515880C550D567E3;

1.167
date	2013.03.30.15.39.26;	author tg;	state Exp;
branches;
next	1.166;
commitid	10051570746595A07B8;

1.166
date	2013.02.18.22.24.52;	author tg;	state Exp;
branches;
next	1.165;
commitid	1005122AA2C223BF4F6;

1.165
date	2012.12.08.18.30.31;	author tg;	state Exp;
branches;
next	1.164;
commitid	10050C3875A3CBDA8F8;

1.164
date	2012.12.04.01.18.34;	author tg;	state Exp;
branches;
next	1.163;
commitid	10050BD4F7642624FD1;

1.163
date	2012.12.04.01.11.17;	author tg;	state Exp;
branches;
next	1.162;
commitid	10050BD4DCC1620D535;

1.162
date	2012.12.01.01.36.30;	author tg;	state Exp;
branches;
next	1.161;
commitid	10050B95F03690E9DEE;

1.161
date	2012.11.30.19.25.08;	author tg;	state Exp;
branches
	1.161.2.1;
next	1.160;
commitid	10050B907135D4B5928;

1.160
date	2012.11.30.19.02.10;	author tg;	state Exp;
branches;
next	1.159;
commitid	10050B902B82AAA0C3F;

1.159
date	2012.11.26.22.49.50;	author tg;	state Exp;
branches;
next	1.158;
commitid	10050B3F2237B099269;

1.158
date	2012.11.20.18.07.45;	author tg;	state Exp;
branches;
next	1.157;
commitid	10050ABC70641D0E46B;

1.157
date	2012.11.20.18.06.53;	author tg;	state Exp;
branches;
next	1.156;
commitid	10050ABC6D54B0E4BFD;

1.156
date	2012.11.20.17.42.32;	author tg;	state Exp;
branches;
next	1.155;
commitid	10050ABC11D40F1EAFA;

1.155
date	2012.11.20.17.34.42;	author tg;	state Exp;
branches;
next	1.154;
commitid	10050ABBF4B4CEBABB8;

1.154
date	2012.10.21.21.39.06;	author tg;	state Exp;
branches;
next	1.153;
commitid	10050846B5B2B1A2932;

1.153
date	2012.07.30.21.37.17;	author tg;	state Exp;
branches;
next	1.152;
commitid	1005016FE9B27F9F4DC;

1.152
date	2012.07.01.15.38.09;	author tg;	state Exp;
branches;
next	1.151;
commitid	1004FF06EE567E89991;

1.151
date	2012.06.28.20.02.29;	author tg;	state Exp;
branches
	1.151.2.1;
next	1.150;
commitid	1004FECB86B79975962;

1.150
date	2012.06.25.16.31.18;	author tg;	state Exp;
branches;
next	1.149;
commitid	1004FE892691AED522E;

1.149
date	2012.05.09.23.21.00;	author tg;	state Exp;
branches;
next	1.148;
commitid	1004FAAFBED1D226CAF;

1.148
date	2012.05.04.21.47.04;	author tg;	state Exp;
branches;
next	1.147;
commitid	1004FA44E6C59CC7A07;

1.147
date	2012.04.22.21.50.35;	author tg;	state Exp;
branches;
next	1.146;
commitid	1004F947C3646B6F432;

1.146
date	2012.04.14.14.35.13;	author tg;	state Exp;
branches;
next	1.145;
commitid	1004F898AD566CBFC2D;

1.145
date	2012.04.07.11.19.53;	author tg;	state Exp;
branches;
next	1.144;
commitid	1004F8022E670BC1C0E;

1.144
date	2012.03.24.19.13.27;	author tg;	state Exp;
branches;
next	1.143;
commitid	1004F6E1CDE5344A082;

1.143
date	2012.03.23.23.25.30;	author tg;	state Exp;
branches;
next	1.142;
commitid	1004F6D064C65BE58AA;

1.142
date	2012.03.23.21.58.24;	author tg;	state Exp;
branches;
next	1.141;
commitid	1004F6CF1C82CE9B908;

1.141
date	2012.03.03.21.30.59;	author tg;	state Exp;
branches;
next	1.140;
commitid	1004F528D8E7F3D0F12;

1.140
date	2011.12.31.00.47.46;	author tg;	state Exp;
branches;
next	1.139;
commitid	1004EFE5BC941F48BCB;

1.139
date	2011.12.30.21.00.32;	author tg;	state Exp;
branches;
next	1.138;
commitid	1004EFE26857EA11C4E;

1.138
date	2011.12.16.20.03.28;	author tg;	state Exp;
branches;
next	1.137;
commitid	1004EEBA4214501EA9D;

1.137
date	2011.12.10.13.34.19;	author tg;	state Exp;
branches;
next	1.136;
commitid	1004EE35FEC458C37A0;

1.136
date	2011.11.26.00.45.03;	author tg;	state Exp;
branches;
next	1.135;
commitid	1004ED036A6781B96F5;

1.135
date	2011.11.11.22.14.19;	author tg;	state Exp;
branches;
next	1.134;
commitid	1004EBD9E4D2DCCBE71;

1.134
date	2011.11.08.22.07.15;	author tg;	state Exp;
branches;
next	1.133;
commitid	1004EB9A7F80119200E;

1.133
date	2011.10.16.00.18.56;	author tg;	state Exp;
branches;
next	1.132;
commitid	1004E9A23074D14BDF6;

1.132
date	2011.09.07.15.24.22;	author tg;	state Exp;
branches;
next	1.131;
commitid	1004E678C6929FE60A6;

1.131
date	2011.08.27.18.06.52;	author tg;	state Exp;
branches;
next	1.130;
commitid	1004E5932432420AA61;

1.130
date	2011.07.07.20.24.53;	author tg;	state Exp;
branches
	1.130.2.1;
next	1.129;
commitid	1004E1615FC6FBD8000;

1.129
date	2011.07.06.22.22.02;	author tg;	state Exp;
branches;
next	1.128;
commitid	1004E14E010182825E7;

1.128
date	2011.07.05.20.12.20;	author tg;	state Exp;
branches;
next	1.127;
commitid	1004E136FF75DBF04C7;

1.127
date	2011.07.02.17.57.41;	author tg;	state Exp;
branches;
next	1.126;
commitid	1004E0F5C27271F5B00;

1.126
date	2011.06.21.21.50.26;	author tg;	state Exp;
branches;
next	1.125;
commitid	1004E011236502496A9;

1.125
date	2011.06.21.21.11.21;	author tg;	state Exp;
branches;
next	1.124;
commitid	1004E01090552E993D4;

1.124
date	2011.06.21.21.08.50;	author tg;	state Exp;
branches;
next	1.123;
commitid	1004E01087333928D62;

1.123
date	2011.06.05.19.58.20;	author tg;	state Exp;
branches;
next	1.122;
commitid	1004DEBDFBB243C0DCF;

1.122
date	2011.05.29.02.18.57;	author tg;	state Exp;
branches;
next	1.121;
commitid	1004DE1AD11046BEFFC;

1.121
date	2011.05.07.02.02.47;	author tg;	state Exp;
branches;
next	1.120;
commitid	1004DC4A8485CCBD93D;

1.120
date	2011.05.04.23.16.05;	author tg;	state Exp;
branches;
next	1.119;
commitid	1004DC1DE466716BC29;

1.119
date	2011.03.27.18.50.06;	author tg;	state Exp;
branches;
next	1.118;
commitid	1004D8F86AA0EB92572;

1.118
date	2011.03.13.01.20.25;	author tg;	state Exp;
branches;
next	1.117;
commitid	1004D7C1BE368F5B459;

1.117
date	2011.03.07.20.30.41;	author tg;	state Exp;
branches;
next	1.116;
commitid	1004D75404D6F4BA14C;

1.116
date	2011.02.11.01.18.23;	author tg;	state Exp;
branches;
next	1.115;
commitid	1004D548C4E66D17A12;

1.115
date	2011.01.21.21.04.48;	author tg;	state Exp;
branches;
next	1.114;
commitid	1004D39F4C639F3DCA7;

1.114
date	2010.09.19.19.21.20;	author tg;	state Exp;
branches;
next	1.113;
commitid	1004C96629B35B82E0A;

1.113
date	2010.09.14.21.26.19;	author tg;	state Exp;
branches;
next	1.112;
commitid	1004C8FE654576B0E25;

1.112
date	2010.08.28.20.22.24;	author tg;	state Exp;
branches;
next	1.111;
commitid	1004C796FE40C544CCE;

1.111
date	2010.08.28.18.50.58;	author tg;	state Exp;
branches;
next	1.110;
commitid	1004C795A82072326AF;

1.110
date	2010.07.25.11.35.43;	author tg;	state Exp;
branches;
next	1.109;
commitid	1004C4C211F2951575A;

1.109
date	2010.07.18.17.29.50;	author tg;	state Exp;
branches;
next	1.108;
commitid	1004C4339F54CCC5B85;

1.108
date	2010.07.17.22.09.40;	author tg;	state Exp;
branches;
next	1.107;
commitid	1004C42295452E71B6E;

1.107
date	2010.07.11.11.17.33;	author tg;	state Exp;
branches;
next	1.106;
commitid	1004C39A83931615597;

1.106
date	2010.07.04.17.45.17;	author tg;	state Exp;
branches;
next	1.105;
commitid	1004C30C8946816B0C1;

1.105
date	2010.07.04.17.33.58;	author tg;	state Exp;
branches;
next	1.104;
commitid	1004C30C5ED28DF693B;

1.104
date	2010.01.28.20.26.52;	author tg;	state Exp;
branches;
next	1.103;
commitid	1004B61F30F0039EC8B;

1.103
date	2010.01.25.14.38.04;	author tg;	state Exp;
branches;
next	1.102;
commitid	1004B5DACDC357C3689;

1.102
date	2010.01.25.14.25.16;	author tg;	state Exp;
branches;
next	1.101;
commitid	1004B5DA9D162A0E82B;

1.101
date	2010.01.25.14.11.29;	author tg;	state Exp;
branches;
next	1.100;
commitid	1004B5DA60A56BFB604;

1.100
date	2009.12.05.17.43.50;	author tg;	state Exp;
branches;
next	1.99;
commitid	1004B1A9BCF3E49BC5B;

1.99
date	2009.12.01.19.15.35;	author tg;	state Exp;
branches;
next	1.98;
commitid	1004B156B29488E0456;

1.98
date	2009.11.28.14.28.03;	author tg;	state Exp;
branches;
next	1.97;
commitid	1004B11334F4604E973;

1.97
date	2009.11.28.14.21.47;	author tg;	state Exp;
branches;
next	1.96;
commitid	1004B1131E93EDF1403;

1.96
date	2009.10.18.12.30.06;	author tg;	state Exp;
branches
	1.96.2.1;
next	1.95;
commitid	1004ADB0A4708185E1A;

1.95
date	2009.10.17.21.16.05;	author tg;	state Exp;
branches;
next	1.94;
commitid	1004ADA339B53B8111A;

1.94
date	2009.09.27.10.31.06;	author tg;	state Exp;
branches;
next	1.93;
commitid	1004ABF3E7C478CDC70;

1.93
date	2009.09.26.04.01.34;	author tg;	state Exp;
branches;
next	1.92;
commitid	1004ABD92036DD32E15;

1.92
date	2009.09.26.03.40.02;	author tg;	state Exp;
branches;
next	1.91;
commitid	1004ABD8CE62D55CFD8;

1.91
date	2009.09.23.18.22.38;	author tg;	state Exp;
branches;
next	1.90;
commitid	1004ABA67775B112BE0;

1.90
date	2009.09.23.18.04.58;	author tg;	state Exp;
branches
	1.90.2.1;
next	1.89;
commitid	1004ABA62C8171BD8E4;

1.89
date	2009.09.20.13.29.18;	author tg;	state Exp;
branches;
next	1.88;
commitid	1004AB62DF51E47759B;

1.88
date	2009.09.20.13.08.12;	author tg;	state Exp;
branches;
next	1.87;
commitid	1004AB6294B732533ED;

1.87
date	2009.09.06.17.42.15;	author tg;	state Exp;
branches;
next	1.86;
commitid	1004AA3F479204C1E97;

1.86
date	2009.08.28.22.44.47;	author tg;	state Exp;
branches
	1.86.2.1;
next	1.85;
commitid	1004A985DE8429F7725;

1.85
date	2009.08.28.22.23.33;	author tg;	state Exp;
branches;
next	1.84;
commitid	1004A9858F050FF8B13;

1.84
date	2009.08.28.21.07.27;	author tg;	state Exp;
branches;
next	1.83;
commitid	1004A984722589F219C;

1.83
date	2009.08.28.21.04.18;	author tg;	state Exp;
branches;
next	1.82;
commitid	1004A9846665E529BFC;

1.82
date	2009.08.28.21.01.27;	author tg;	state Exp;
branches;
next	1.81;
commitid	1004A9845725143AD02;

1.81
date	2009.08.28.20.38.43;	author tg;	state Exp;
branches;
next	1.80;
commitid	1004A98405B0186F15C;

1.80
date	2009.08.28.20.30.59;	author tg;	state Exp;
branches;
next	1.79;
commitid	1004A983E6B745731A0;

1.79
date	2009.08.28.19.57.43;	author tg;	state Exp;
branches;
next	1.78;
commitid	1004A98365B7809CDA1;

1.78
date	2009.08.28.18.54.01;	author tg;	state Exp;
branches;
next	1.77;
commitid	1004A9827D2091BAE42;

1.77
date	2009.08.08.13.08.53;	author tg;	state Exp;
branches;
next	1.76;
commitid	1004A7D785D73D49CFA;

1.76
date	2009.08.01.20.32.45;	author tg;	state Exp;
branches;
next	1.75;
commitid	1004A74A6770161F3E7;

1.75
date	2009.06.11.12.42.21;	author tg;	state Exp;
branches;
next	1.74;
commitid	1004A30FBB114E3FED9;

1.74
date	2009.06.10.18.12.51;	author tg;	state Exp;
branches;
next	1.73;
commitid	1004A2FF7913BD44883;

1.73
date	2009.06.08.20.06.50;	author tg;	state Exp;
branches;
next	1.72;
commitid	1004A2D6F3A31FB4CBC;

1.72
date	2009.05.16.16.59.42;	author tg;	state Exp;
branches;
next	1.71;
commitid	1004A0EF0664EF4168D;

1.71
date	2009.04.07.19.27.49;	author tg;	state Exp;
branches;
next	1.70;
commitid	10049DBA93F20E1FE3F;

1.70
date	2009.04.07.19.06.44;	author tg;	state Exp;
branches;
next	1.69;
commitid	10049DBA45A68068BCD;

1.69
date	2009.03.14.18.12.55;	author tg;	state Exp;
branches;
next	1.68;
commitid	10049BBF38A0ADEDD54;

1.68
date	2008.12.29.21.34.22;	author tg;	state Exp;
branches;
next	1.67;
commitid	10049594263416D2C1C;

1.67
date	2008.12.29.21.05.15;	author tg;	state Exp;
branches;
next	1.66;
commitid	10049593B8A55E8419D;

1.66
date	2008.12.29.20.52.10;	author tg;	state Exp;
branches;
next	1.65;
commitid	10049593890439F73A6;

1.65
date	2008.12.13.17.02.18;	author tg;	state Exp;
branches;
next	1.64;
commitid	1004943EAA830C0300B;

1.64
date	2008.12.04.18.11.08;	author tg;	state Exp;
branches;
next	1.63;
commitid	10049381D2D4EEC022C;

1.63
date	2008.11.30.10.33.40;	author tg;	state Exp;
branches;
next	1.62;
commitid	10049326BED703E2AC2;

1.62
date	2008.11.15.09.00.19;	author tg;	state Exp;
branches
	1.62.2.1;
next	1.61;
commitid	100491E8FA25D360D54;

1.61
date	2008.11.15.07.35.25;	author tg;	state Exp;
branches;
next	1.60;
commitid	100491E7BBB79B0FECE;

1.60
date	2008.11.12.00.54.52;	author tg;	state Exp;
branches;
next	1.59;
commitid	100491A295841A6D8EB;

1.59
date	2008.11.12.00.27.57;	author tg;	state Exp;
branches;
next	1.58;
commitid	100491A230649FC77C0;

1.58
date	2008.10.28.14.32.43;	author tg;	state Exp;
branches;
next	1.57;
commitid	1004907226D3DEFCCD1;

1.57
date	2008.07.12.16.56.40;	author tg;	state Exp;
branches;
next	1.56;
commitid	1004878E22B104A657A;

1.56
date	2008.05.17.18.47.03;	author tg;	state Exp;
branches;
next	1.55;
commitid	100482F280E7B53AA4C;

1.55
date	2008.05.02.18.55.37;	author tg;	state Exp;
branches;
next	1.54;
commitid	100481B63B51233676D;

1.54
date	2008.04.19.22.15.06;	author tg;	state Exp;
branches;
next	1.53;
commitid	100480A6CC85EC0197B;

1.53
date	2008.04.19.21.04.09;	author tg;	state Exp;
branches;
next	1.52;
commitid	100480A5E532EE94633;

1.52
date	2008.04.19.17.21.55;	author tg;	state Exp;
branches;
next	1.51;
commitid	100480A2A2B32040FD7;

1.51
date	2008.02.24.15.20.52;	author tg;	state Exp;
branches
	1.51.2.1;
next	1.50;
commitid	10047C18B643D6401C2;

1.50
date	2007.10.25.16.10.16;	author tg;	state Exp;
branches;
next	1.49;
commitid	1004720BFD4103B1DFE;

1.49
date	2007.10.25.15.23.10;	author tg;	state Exp;
branches;
next	1.48;
commitid	1004720B4ED147A8549;

1.48
date	2007.10.25.14.26.53;	author tg;	state Exp;
branches;
next	1.47;
commitid	1004720A7B12AC914F2;

1.47
date	2007.10.25.14.18.56;	author tg;	state Exp;
branches;
next	1.46;
commitid	1004720A5D93951F8E8;

1.46
date	2007.10.18.20.32.33;	author tg;	state Exp;
branches;
next	1.45;
commitid	1004717C2CE427DDAE7;

1.45
date	2007.09.09.18.06.42;	author tg;	state Exp;
branches;
next	1.44;
commitid	10046E436442CDF8871;

1.44
date	2007.08.20.13.57.47;	author tg;	state Exp;
branches;
next	1.43;
commitid	10046C99DE973ED24F6;

1.43
date	2007.08.12.13.42.23;	author tg;	state Exp;
branches;
next	1.42;
commitid	10046BF0E4F7055959B;

1.42
date	2007.07.22.14.01.50;	author tg;	state Exp;
branches;
next	1.41;
commitid	10046A36344350ACD7B;

1.41
date	2007.07.22.13.34.52;	author tg;	state Exp;
branches;
next	1.40;
commitid	10046A35CEC35BB7B5F;

1.40
date	2007.07.01.21.10.29;	author tg;	state Exp;
branches;
next	1.39;
commitid	100468818584C6286F7;

1.39
date	2007.06.06.23.28.17;	author tg;	state Exp;
branches;
next	1.38;
commitid	1004667430836D68E66;

1.38
date	2007.05.13.17.51.24;	author tg;	state Exp;
branches;
next	1.37;
commitid	10046474FB1292DF336;

1.37
date	2007.03.04.03.04.28;	author tg;	state Exp;
branches
	1.37.2.1;
next	1.36;
commitid	10045EA374B3374AB35;

1.36
date	2007.03.04.00.13.17;	author tg;	state Exp;
branches;
next	1.35;
commitid	10045EA0F2F6674C8B9;

1.35
date	2007.03.03.21.36.08;	author tg;	state Exp;
branches;
next	1.34;
commitid	10045E9EA54328B08FC;

1.34
date	2007.01.15.02.48.28;	author tg;	state Exp;
branches;
next	1.33;
commitid	10045AAEB8E4EE42CAE;

1.33
date	2006.11.19.16.43.43;	author tg;	state Exp;
branches
	1.33.2.1;
next	1.32;
commitid	1004560891159DD45F6;

1.32
date	2006.11.12.14.58.16;	author tg;	state Exp;
branches;
next	1.31;
commitid	100455735A7145E26AA;

1.31
date	2006.11.10.07.52.04;	author tg;	state Exp;
branches;
next	1.30;
commitid	10045542F8269E05F56;

1.30
date	2006.11.10.07.18.58;	author tg;	state Exp;
branches;
next	1.29;
commitid	100455427B90A1F6E32;

1.29
date	2006.11.10.06.53.27;	author tg;	state Exp;
branches;
next	1.28;
commitid	100455421CB6900D8A1;

1.28
date	2006.11.10.06.45.28;	author tg;	state Exp;
branches;
next	1.27;
commitid	10045541FC2382F56E4;

1.27
date	2006.11.10.06.16.25;	author tg;	state Exp;
branches;
next	1.26;
commitid	100455419107E3FB2C1;

1.26
date	2006.11.10.05.23.14;	author tg;	state Exp;
branches;
next	1.25;
commitid	10045540CCB39485995;

1.25
date	2006.11.10.04.22.13;	author tg;	state Exp;
branches;
next	1.24;
commitid	1004553FE7A5FEC3897;

1.24
date	2006.11.10.01.13.52;	author tg;	state Exp;
branches;
next	1.23;
commitid	1004553D1A316532A65;

1.23
date	2006.08.18.18.48.26;	author tg;	state Exp;
branches;
next	1.22;
commitid	10044E60B7F76A8563C;

1.22
date	2006.08.18.13.40.16;	author tg;	state Exp;
branches;
next	1.21;
commitid	10044E5C34431A7C593;

1.21
date	2006.07.11.14.51.01;	author tg;	state Exp;
branches
	1.21.2.1;
next	1.20;
commitid	10044B3BAD83E16AC82;

1.20
date	2006.07.03.12.16.31;	author tg;	state Exp;
branches;
next	1.19;
commitid	10044A90AAA1B255EDF;

1.19
date	2006.06.21.19.35.38;	author tg;	state Exp;
branches;
next	1.18;
commitid	10044999F9A63254C19;

1.18
date	2006.05.26.22.17.21;	author tg;	state Exp;
branches;
next	1.17;
commitid	10044777E4D1B761877;

1.17
date	2006.05.10.18.54.13;	author tg;	state Exp;
branches;
next	1.16;
commitid	100446236E6726083C8;

1.16
date	2006.01.30.12.37.24;	author tg;	state Exp;
branches;
next	1.15;
commitid	10043DE088533ED5341;

1.15
date	2006.01.29.20.16.51;	author tg;	state Exp;
branches;
next	1.14;
commitid	10043DD22C327F0E848;

1.14
date	2006.01.29.20.10.16;	author tg;	state Exp;
branches;
next	1.13;
commitid	10043DD21313A3E31F7;

1.13
date	2006.01.29.20.04.54;	author tg;	state Exp;
branches;
next	1.12;
commitid	10043DD1FE6328EF386;

1.12
date	2005.11.22.18.40.44;	author tg;	state Exp;
branches;
next	1.11;
commitid	108a438366254326;

1.11
date	2005.10.29.07.55.51;	author tg;	state Exp;
branches;
next	1.10;
commitid	6f7b43632b08db6d;

1.10
date	2005.10.25.19.53.29;	author tg;	state Exp;
branches;
next	1.9;
commitid	76cc435e8d34d8ce;

1.9
date	2005.10.21.11.55.23;	author tg;	state Exp;
branches;
next	1.8;
commitid	74ff4358d73302e1;

1.8
date	2005.07.04.12.34.24;	author tg;	state Exp;
branches;
next	1.7;
commitid	4a8342c92cd61cc3;

1.7
date	2005.07.04.12.07.41;	author tg;	state Exp;
branches;
next	1.6;
commitid	638742c926619991;

1.6
date	2005.05.28.21.11.35;	author tg;	state Exp;
branches;
next	1.5;
commitid	14b24298de8a6027;

1.5
date	2005.05.26.23.01.30;	author tg;	state Exp;
branches;
next	1.4;
commitid	789f4296553dac75;

1.4
date	2005.05.25.13.46.02;	author tg;	state Exp;
branches;
next	1.3;
commitid	503942948197230c;

1.3
date	2005.05.23.15.36.56;	author tg;	state Exp;
branches;
next	1.2;
commitid	294b4291f8a10548;

1.2
date	2005.05.23.14.22.03;	author tg;	state Exp;
branches;
next	1.1;
commitid	7f594291e70f38dd;

1.1
date	2005.05.23.03.06.10;	author tg;	state Exp;
branches;
next	;
commitid	1a89429147b8402d;

1.183.2.1
date	2015.01.25.15.35.54;	author tg;	state Exp;
branches;
next	1.183.2.2;
commitid	10054C50D442D861FBF;

1.183.2.2
date	2015.03.01.15.43.07;	author tg;	state Exp;
branches;
next	1.183.2.3;
commitid	10054F33364551D895A;

1.183.2.3
date	2015.03.20.22.21.10;	author tg;	state Exp;
branches;
next	1.183.2.4;
commitid	100550C9D521FCB4274;

1.183.2.4
date	2015.04.19.19.18.23;	author tg;	state Exp;
branches;
next	;
commitid	1005533FF4D64965277;

1.161.2.1
date	2012.12.04.01.26.36;	author tg;	state Exp;
branches;
next	1.161.2.2;
commitid	10050BD5149729CD584;

1.161.2.2
date	2013.02.10.17.11.31;	author tg;	state Exp;
branches;
next	;
commitid	1005117D46E22B420F2;

1.151.2.1
date	2013.02.11.00.27.22;	author tg;	state Exp;
branches;
next	;
commitid	10051183A6D5475BB1E;

1.130.2.1
date	2011.07.07.21.42.20;	author tg;	state Exp;
branches;
next	1.130.2.2;
commitid	1004E162810137500DE;

1.130.2.2
date	2011.10.25.22.50.41;	author tg;	state Exp;
branches;
next	1.130.2.3;
commitid	1004EA73D456165B188;

1.130.2.3
date	2011.11.08.22.07.25;	author tg;	state Exp;
branches;
next	1.130.2.4;
commitid	1004EB9A7F80119200E;

1.130.2.4
date	2011.11.19.22.22.03;	author tg;	state Exp;
branches;
next	1.130.2.5;
commitid	1004EC82C02177E0E27;

1.130.2.5
date	2011.11.26.18.23.27;	author tg;	state Exp;
branches;
next	1.130.2.6;
commitid	1004ED12E8854A4E765;

1.130.2.6
date	2011.12.11.18.18.30;	author tg;	state Exp;
branches;
next	1.130.2.7;
commitid	1004EE4F3FF0C99C8CA;

1.130.2.7
date	2011.12.31.02.25.36;	author tg;	state Exp;
branches;
next	1.130.2.8;
commitid	1004EFE72A268DB0925;

1.130.2.8
date	2012.03.24.21.22.46;	author tg;	state Exp;
branches;
next	;
commitid	1004F6E3A967ACCD93A;

1.96.2.1
date	2009.11.28.14.27.57;	author tg;	state Exp;
branches;
next	;
commitid	1004B11334F4604E973;

1.90.2.1
date	2009.09.23.18.05.47;	author tg;	state Exp;
branches;
next	;
commitid	1004ABA638B4A59C139;

1.86.2.1
date	2009.08.30.20.56.10;	author tg;	state Exp;
branches;
next	;
commitid	1004A9AE59203C5D0BB;

1.62.2.1
date	2008.11.22.13.20.37;	author tg;	state Exp;
branches;
next	;
commitid	100492806F80A7B2451;

1.51.2.1
date	2008.05.19.18.41.33;	author tg;	state Exp;
branches;
next	1.51.2.2;
commitid	1004831C9A63DA06745;

1.51.2.2
date	2008.07.18.13.29.48;	author tg;	state Exp;
branches;
next	1.51.2.3;
commitid	10048809AD278B142AC;

1.51.2.3
date	2008.12.14.00.07.51;	author tg;	state Exp;
branches;
next	;
commitid	10049444E5325915C76;

1.37.2.1
date	2007.05.13.19.29.40;	author tg;	state Exp;
branches;
next	1.37.2.2;
commitid	1004647668D4636830B;

1.37.2.2
date	2007.07.05.11.49.23;	author tg;	state Exp;
branches;
next	;
commitid	100468CDAAD5BCF14BE;

1.33.2.1
date	2007.03.03.21.38.00;	author tg;	state Exp;
branches;
next	1.33.2.2;
commitid	10045E9EAC27ABA6ADF;

1.33.2.2
date	2007.03.03.23.59.40;	author tg;	state Exp;
branches;
next	;
commitid	10045EA0C01765C8871;

1.21.2.1
date	2006.08.18.19.02.22;	author tg;	state Exp;
branches;
next	1.21.2.2;
commitid	10044E60ECD062A26B8;

1.21.2.2
date	2006.08.24.20.52.15;	author tg;	state Exp;
branches;
next	1.21.2.3;
commitid	10044EE117A130AF943;

1.21.2.3
date	2006.08.28.01.49.21;	author tg;	state Exp;
branches;
next	;
commitid	10044F24B9666020C36;


desc
@@


1.234
log
@handle empty expansions in places we expect variable names, LP#1857826
@
text
@/*	$OpenBSD: var.c,v 1.44 2015/09/10 11:37:42 jca Exp $	*/

/*-
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
 *		 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018,
 *		 2019
 *	mirabilos <m@@mirbsd.org>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 */

#include "sh.h"
#include "mirhash.h"

#if defined(__OpenBSD__)
#include <sys/sysctl.h>
#endif

__RCSID("$MirOS: src/bin/mksh/var.c,v 1.233 2019/12/12 12:13:25 tg Exp $");

/*-
 * Variables
 *
 * WARNING: unreadable code, needs a rewrite
 *
 * if (flag&INTEGER), val.i contains integer value, and type contains base.
 * otherwise, (val.s + type) contains string value.
 * if (flag&EXPORT), val.s contains "name=value" for E-Z exporting.
 */

static struct table specials;
static uint32_t lcg_state = 5381, qh_state = 4711;
/* may only be set by typeset() just before call to array_index_calc() */
static enum namerefflag innermost_refflag = SRF_NOP;

static void c_typeset_vardump(struct tbl *, uint32_t, int, int, bool, bool);
static void c_typeset_vardump_recursive(struct block *, uint32_t, int, bool,
    bool);
static char *formatstr(struct tbl *, const char *);
static void exportprep(struct tbl *, const char *, size_t);
static int special(const char *);
static void unspecial(const char *);
static void getspec(struct tbl *);
static void setspec(struct tbl *);
static void unsetspec(struct tbl *, bool);
static int getint(struct tbl *, mksh_ari_u *, bool);
static const char *array_index_calc(const char *, bool *, uint32_t *);
static struct tbl *vtypeset(int *, const char *, uint32_t, uint32_t, int, int);

/*
 * create a new block for function calls and simple commands
 * assume caller has allocated and set up e->loc
 */
void
newblock(void)
{
	struct block *l;
	static const char *empty[] = { null };

	l = alloc(sizeof(struct block), ATEMP);
	l->flags = 0;
	/* TODO: could use e->area (l->area => l->areap) */
	ainit(&l->area);
	if (!e->loc) {
		l->argc = 0;
		l->argv = empty;
	} else {
		l->argc = e->loc->argc;
		l->argv = e->loc->argv;
	}
	l->exit = l->error = NULL;
	ktinit(&l->area, &l->vars, 0);
	ktinit(&l->area, &l->funs, 0);
	l->next = e->loc;
	e->loc = l;
}

/*
 * pop a block handling special variables
 */
void
popblock(void)
{
	ssize_t i;
	struct block *l = e->loc;
	struct tbl *vp, **vpp = l->vars.tbls, *vq;

	/* pop block */
	e->loc = l->next;

	i = 1 << (l->vars.tshift);
	while (--i >= 0)
		if ((vp = *vpp++) != NULL && (vp->flag&SPECIAL)) {
			if ((vq = global(vp->name))->flag & ISSET)
				setspec(vq);
			else
				unsetspec(vq, false);
		}
	if (l->flags & BF_DOGETOPTS)
		user_opt = l->getopts_state;
	afreeall(&l->area);
	afree(l, ATEMP);
}

/* called by main() to initialise variable data structures */
#define VARSPEC_DEFNS
#include "var_spec.h"

enum var_specs {
#define VARSPEC_ENUMS
#include "var_spec.h"
	V_MAX
};

/* this is biased with -1 relative to VARSPEC_ENUMS */
static const char * const initvar_names[] = {
#define VARSPEC_ITEMS
#include "var_spec.h"
};

void
initvar(void)
{
	int i = 0;
	struct tbl *tp;

	ktinit(APERM, &specials,
	    /* currently 21 specials: 75% of 32 = 2^5 */
	    5);
	while (i < V_MAX - 1) {
		tp = ktenter(&specials, initvar_names[i],
		    hash(initvar_names[i]));
		tp->flag = DEFINED|ISSET;
		tp->type = ++i;
	}
}

/* common code for several functions below and c_typeset() */
struct block *
varsearch(struct block *l, struct tbl **vpp, const char *vn, uint32_t h)
{
	register struct tbl *vp;

	if (l) {
 varsearch_loop:
		if ((vp = ktsearch(&l->vars, vn, h)) != NULL)
			goto varsearch_out;
		if (l->next != NULL) {
			l = l->next;
			goto varsearch_loop;
		}
	}
	vp = NULL;
 varsearch_out:
	*vpp = vp;
	return (l);
}

/*
 * Used to calculate an array index for global()/local(). Sets *arrayp
 * to true if this is an array, sets *valp to the array index, returns
 * the basename of the array. May only be called from global()/local()
 * and must be their first callee.
 */
static const char *
array_index_calc(const char *n, bool *arrayp, uint32_t *valp)
{
	const char *p;
	size_t len;
	char *ap = NULL;

	*arrayp = false;
 redo_from_ref:
	p = skip_varname(n, false);
	if (innermost_refflag == SRF_NOP && (p != n) && ctype(n[0], C_ALPHX)) {
		struct tbl *vp;
		char *vn;

		strndupx(vn, n, p - n, ATEMP);
		/* check if this is a reference */
		varsearch(e->loc, &vp, vn, hash(vn));
		afree(vn, ATEMP);
		if (vp && (vp->flag & (DEFINED | ASSOC | ARRAY)) ==
		    (DEFINED | ASSOC)) {
			char *cp;

			/* gotcha! */
			strdup2x(cp, str_val(vp), p);
			afree(ap, ATEMP);
			n = ap = cp;
			goto redo_from_ref;
		}
	}
	innermost_refflag = SRF_NOP;

	if (p != n && ord(*p) == ORD('[') && (len = array_ref_len(p))) {
		char *sub, *tmp;
		mksh_ari_t rval;
		size_t tmplen = p - n;

		/* calculate the value of the subscript */
		*arrayp = true;
		len -= 2;
		tmp = alloc((len > tmplen ? len : tmplen) + 1, ATEMP);
		memcpy(tmp, p + 1, len);
		tmp[len] = '\0';
		sub = substitute(tmp, 0);
		evaluate(sub, &rval, KSH_UNWIND_ERROR, true);
		*valp = (uint32_t)rval;
		afree(sub, ATEMP);
		memcpy(tmp, n, tmplen);
		tmp[tmplen] = '\0';
		n = tmp;
	}
	return (n);
}

#define vn vname.ro
/*
 * Search for variable, if not found create globally.
 */
struct tbl *
global(const char *n)
{
	return (isglobal(n, true));
}

/* search for variable; if not found, return NULL or create globally */
struct tbl *
isglobal(const char *n, bool docreate)
{
	struct tbl *vp;
	union mksh_cchack vname;
	struct block *l = e->loc;
	int c;
	bool array;
	uint32_t h, val;

	/*
	 * check to see if this is an array;
	 * dereference namerefs; must come first
	 */
	vn = array_index_calc(n, &array, &val);
	h = hash(vn);
	c = (unsigned char)vn[0];
	if (!ctype(c, C_ALPHX)) {
		if (array)
			errorf(Tbadsubst);
		vp = vtemp;
		vp->flag = DEFINED;
		vp->type = 0;
		vp->areap = ATEMP;
		if (ctype(c, C_DIGIT)) {
			if (getn(vn, &c)) {
				/* main.c:main_init() says 12 */
				shf_snprintf(vp->name, 12, Tf_d, c);
				if (c <= l->argc) {
					/* setstr can't fail here */
					setstr(vp, l->argv[c],
					    KSH_RETURN_ERROR);
				}
			} else
				vp->name[0] = '\0';
			vp->flag |= RDONLY;
			goto out;
		}
		vp->name[0] = c;
		vp->name[1] = '\0';
		vp->flag |= RDONLY;
		if (!c || vn[1] != '\0')
			goto out;
		vp->flag |= ISSET|INTEGER;
		switch (c) {
		case '$':
			vp->val.i = kshpid;
			break;
		case '!':
			/* if no job, expand to nothing */
			if ((vp->val.i = j_async()) == 0)
				vp->flag &= ~(ISSET|INTEGER);
			break;
		case '?':
			vp->val.i = exstat & 0xFF;
			break;
		case '#':
			vp->val.i = l->argc;
			break;
		case '-':
			vp->flag &= ~INTEGER;
			vp->val.s = getoptions();
			break;
		default:
			vp->flag &= ~(ISSET|INTEGER);
		}
		goto out;
	}
	l = varsearch(e->loc, &vp, vn, h);
	if (vp == NULL && docreate)
		vp = ktenter(&l->vars, vn, h);
	else
		docreate = false;
	if (vp != NULL) {
		if (array)
			vp = arraysearch(vp, val);
		if (docreate) {
			vp->flag |= DEFINED;
			if (special(vn))
				vp->flag |= SPECIAL;
		}
	}
 out:
	last_lookup_was_array = array;
	if (vn != n)
		afree(vname.rw, ATEMP);
	return (vp);
}

/*
 * Search for local variable, if not found create locally.
 */
struct tbl *
local(const char *n, bool copy)
{
	struct tbl *vp;
	union mksh_cchack vname;
	struct block *l = e->loc;
	bool array;
	uint32_t h, val;

	/*
	 * check to see if this is an array;
	 * dereference namerefs; must come first
	 */
	vn = array_index_calc(n, &array, &val);
	h = hash(vn);
	if (!ctype(*vn, C_ALPHX)) {
		vp = vtemp;
		vp->flag = DEFINED|RDONLY;
		vp->type = 0;
		vp->areap = ATEMP;
		goto out;
	}
	vp = ktenter(&l->vars, vn, h);
	if (copy && !(vp->flag & DEFINED)) {
		struct tbl *vq;

		varsearch(l->next, &vq, vn, h);
		if (vq != NULL) {
			vp->flag |= vq->flag &
			    (EXPORT | INTEGER | RDONLY | LJUST | RJUST |
			    ZEROFIL | LCASEV | UCASEV_AL | INT_U | INT_L);
			if (vq->flag & INTEGER)
				vp->type = vq->type;
			vp->u2.field = vq->u2.field;
		}
	}
	if (array)
		vp = arraysearch(vp, val);
	vp->flag |= DEFINED;
	if (special(vn))
		vp->flag |= SPECIAL;
 out:
	last_lookup_was_array = array;
	if (vn != n)
		afree(vname.rw, ATEMP);
	return (vp);
}
#undef vn

/* get variable string value */
char *
str_val(struct tbl *vp)
{
	char *s;

	if ((vp->flag&SPECIAL))
		getspec(vp);
	if (!(vp->flag&ISSET))
		/* special to dollar() */
		s = null;
	else if (!(vp->flag&INTEGER))
		/* string source */
		s = vp->val.s + vp->type;
	else {
		/* integer source */
		mksh_uari_t n;
		unsigned int base;
		/**
		 * worst case number length is when base == 2:
		 *	1 (minus) + 2 (base, up to 36) + 1 ('#') +
		 *	number of bits in the mksh_uari_t + 1 (NUL)
		 */
		char strbuf[1 + 2 + 1 + 8 * sizeof(mksh_uari_t) + 1];
		const char *digits = (vp->flag & UCASEV_AL) ?
		    digits_uc : digits_lc;

		s = strbuf + sizeof(strbuf);
		if (vp->flag & INT_U)
			n = vp->val.u;
		else
			n = (vp->val.i < 0) ? -vp->val.u : vp->val.u;
		base = (vp->type == 0) ? 10U : (unsigned int)vp->type;

		if (base == 1 && n == 0)
			base = 2;
		if (base == 1) {
			size_t sz = 1;

			*(s = strbuf) = '1';
			s[1] = '#';
			if (!UTFMODE)
				s[2] = (unsigned char)n;
			else if ((n & 0xFF80) == 0xEF80)
				/* OPTU-16 -> raw octet */
				s[2] = asc2rtt(n & 0xFF);
			else
				sz = utf_wctomb(s + 2, n);
			s[2 + sz] = '\0';
		} else {
			*--s = '\0';
			do {
				*--s = digits[n % base];
				n /= base;
			} while (n != 0);
			if (base != 10) {
				*--s = '#';
				*--s = digits[base % 10];
				if (base >= 10)
					*--s = digits[base / 10];
			}
			if (!(vp->flag & INT_U) && vp->val.i < 0)
				*--s = '-';
		}
		if (vp->flag & (RJUST|LJUST))
			/* case already dealt with */
			s = formatstr(vp, s);
		else
			strdupx(s, s, ATEMP);
	}
	return (s);
}

/* set variable to string value */
int
setstr(struct tbl *vq, const char *s, int error_ok)
{
	bool no_ro_check = tobool(error_ok & 0x4);

	error_ok &= ~0x4;
	if ((vq->flag & RDONLY) && !no_ro_check) {
		warningf(true, Tf_ro, vq->name);
		if (!error_ok)
			errorfxz(2);
		return (0);
	}
	if (!(vq->flag&INTEGER)) {
		/* string dest */
		char *salloc = NULL;
		size_t cursz;
		if ((vq->flag&ALLOC)) {
			cursz = strlen(vq->val.s) + 1;
#ifndef MKSH_SMALL
			/* debugging */
			if (s >= vq->val.s && s < (vq->val.s + cursz)) {
				internal_errorf(
				    "setstr: %s=%s: assigning to self",
				    vq->name, s);
			}
#endif
		} else
			cursz = 0;
		if (s && (vq->flag & (UCASEV_AL|LCASEV|LJUST|RJUST)))
			s = salloc = formatstr(vq, s);
		if ((vq->flag&EXPORT))
			exportprep(vq, s, cursz);
		else {
			size_t n = strlen(s) + 1;
			vq->val.s = aresizeif(cursz, (vq->flag & ALLOC) ?
			    vq->val.s : NULL, n, vq->areap);
			memcpy(vq->val.s, s, n);
			vq->flag |= ALLOC;
			vq->type = 0;
		}
		afree(salloc, ATEMP);
	} else {
		/* integer dest */
		if (!v_evaluate(vq, s, error_ok, true))
			return (0);
	}
	vq->flag |= ISSET;
	if ((vq->flag&SPECIAL))
		setspec(vq);
	return (1);
}

/* set variable to integer */
void
setint(struct tbl *vq, mksh_ari_t n)
{
	if (!(vq->flag&INTEGER)) {
		vtemp->flag = (ISSET|INTEGER);
		vtemp->type = 0;
		vtemp->areap = ATEMP;
		vtemp->val.i = n;
		/* setstr can't fail here */
		setstr(vq, str_val(vtemp), KSH_RETURN_ERROR);
	} else
		vq->val.i = n;
	vq->flag |= ISSET;
	if ((vq->flag&SPECIAL))
		setspec(vq);
}

static int
getint(struct tbl *vp, mksh_ari_u *nump, bool arith)
{
	mksh_uari_t c, num = 0, base = 10;
	const char *s;
	bool have_base = false, neg = false;

	if (vp->flag & SPECIAL)
		getspec(vp);
	/* XXX is it possible for ISSET to be set and val.s to be NULL? */
	if (!(vp->flag & ISSET) || (!(vp->flag & INTEGER) && vp->val.s == NULL))
		return (-1);
	if (vp->flag & INTEGER) {
		nump->i = vp->val.i;
		return (vp->type);
	}
	s = vp->val.s + vp->type;

	do {
		c = (unsigned char)*s++;
	} while (ctype(c, C_SPACE));

	switch (c) {
	case '-':
		neg = true;
		/* FALLTHROUGH */
	case '+':
		c = (unsigned char)*s++;
		break;
	}

	if (c == '0' && arith) {
		if (ksh_eq(s[0], 'X', 'x')) {
			/* interpret as hexadecimal */
			base = 16;
			++s;
			goto getint_c_style_base;
		} else if (Flag(FPOSIX) && ctype(s[0], C_DIGIT) &&
		    !(vp->flag & ZEROFIL)) {
			/* interpret as octal (deprecated) */
			base = 8;
 getint_c_style_base:
			have_base = true;
			c = (unsigned char)*s++;
		}
	}

	do {
		if (c == '#') {
			/* ksh-style base determination */
			if (have_base || num < 1)
				return (-1);
			if ((base = num) == 1) {
				/* mksh-specific extension */
				unsigned int wc;

				if (!UTFMODE)
					wc = *(const unsigned char *)s;
				else if (utf_mbtowc(&wc, s) == (size_t)-1)
					/* OPTU-8 -> OPTU-16 */
					/*
					 * (with a twist: 1#\uEF80 converts
					 * the same as 1#\x80 does, thus is
					 * not round-tripping correctly XXX)
					 */
					wc = 0xEF00 + rtt2asc(*s);
				nump->u = (mksh_uari_t)wc;
				return (1);
			} else if (base > 36)
				base = 10;
			num = 0;
			have_base = true;
			continue;
		}
		if (ctype(c, C_DIGIT))
			c = ksh_numdig(c);
		else if (ctype(c, C_UPPER))
			c = ksh_numuc(c) + 10;
		else if (ctype(c, C_LOWER))
			c = ksh_numlc(c) + 10;
		else
			return (-1);
		if (c >= base)
			return (-1);
		/* handle overflow as truncation */
		num = num * base + c;
	} while ((c = (unsigned char)*s++));

	if (neg)
		num = -num;
	nump->u = num;
	return (base);
}

/*
 * convert variable vq to integer variable, setting its value from vp
 * (vq and vp may be the same)
 */
struct tbl *
setint_v(struct tbl *vq, struct tbl *vp, bool arith)
{
	int base;
	mksh_ari_u num;

	if ((base = getint(vp, &num, arith)) == -1)
		return (NULL);
	setint_n(vq, num.i, 0);
	if (vq->type == 0)
		/* default base */
		vq->type = base;
	return (vq);
}

/* convert variable vq to integer variable, setting its value to num */
void
setint_n(struct tbl *vq, mksh_ari_t num, int newbase)
{
	if (!(vq->flag & INTEGER) && (vq->flag & ALLOC)) {
		vq->flag &= ~ALLOC;
		vq->type = 0;
		afree(vq->val.s, vq->areap);
	}
	vq->val.i = num;
	if (newbase != 0)
		vq->type = newbase;
	vq->flag |= ISSET|INTEGER;
	if (vq->flag&SPECIAL)
		setspec(vq);
}

static char *
formatstr(struct tbl *vp, const char *s)
{
	int olen, nlen;
	char *p, *q;
	size_t psiz;

	olen = (int)utf_mbswidth(s);

	if (vp->flag & (RJUST|LJUST)) {
		if (!vp->u2.field)
			/* default field width */
			vp->u2.field = olen;
		nlen = vp->u2.field;
	} else
		nlen = olen;

	p = alloc((psiz = nlen * /* MB_LEN_MAX */ 3 + 1), ATEMP);
	if (vp->flag & (RJUST|LJUST)) {
		int slen = olen;

		if (vp->flag & RJUST) {
			const char *qq;
			int n = 0;

			qq = utf_skipcols(s, slen, &slen);

			/* strip trailing spaces (AT&T uses qq[-1] == ' ') */
			while (qq > s && ctype(qq[-1], C_SPACE)) {
				--qq;
				--slen;
			}
			if (vp->flag & ZEROFIL && vp->flag & INTEGER) {
				if (!s[0] || !s[1])
					goto uhm_no;
				if (s[1] == '#')
					n = 2;
				else if (s[2] == '#')
					n = 3;
 uhm_no:
				if (vp->u2.field <= n)
					n = 0;
			}
			if (n) {
				memcpy(p, s, n);
				s += n;
			}
			while (slen > vp->u2.field)
				slen -= utf_widthadj(s, &s);
			if (vp->u2.field - slen)
				memset(p + n, (vp->flag & ZEROFIL) ? '0' : ' ',
				    vp->u2.field - slen);
			slen -= n;
			shf_snprintf(p + vp->u2.field - slen,
			    psiz - (vp->u2.field - slen),
			    "%.*s", slen, s);
		} else {
			/* strip leading spaces/zeros */
			while (ctype(*s, C_SPACE))
				s++;
			if (vp->flag & ZEROFIL)
				while (*s == '0')
					s++;
			shf_snprintf(p, psiz, "%-*.*s",
				vp->u2.field, vp->u2.field, s);
		}
	} else
		memcpy(p, s, strlen(s) + 1);

	if (vp->flag & UCASEV_AL) {
		for (q = p; *q; q++)
			*q = ksh_toupper(*q);
	} else if (vp->flag & LCASEV) {
		for (q = p; *q; q++)
			*q = ksh_tolower(*q);
	}

	return (p);
}

/*
 * make vp->val.s be "name=value" for quick exporting.
 */
static void
exportprep(struct tbl *vp, const char *val, size_t cursz)
{
	char *cp = (vp->flag & ALLOC) ? vp->val.s : NULL;
	size_t namelen = strlen(vp->name);
	size_t vallen = strlen(val) + 1;

	vp->flag |= ALLOC;
	vp->type = namelen + 1;
	/* since name+val are both in memory this can go unchecked */
	vp->val.s = aresizeif(cursz, cp, vp->type + vallen, vp->areap);
	memmove(vp->val.s + vp->type, val == cp ? vp->val.s : val, vallen);
	memcpy(vp->val.s, vp->name, namelen);
	vp->val.s[namelen] = '=';
}

/*
 * lookup variable (according to (set&LOCAL)), set its attributes
 * (INTEGER, RDONLY, EXPORT, TRACE, LJUST, RJUST, ZEROFIL, LCASEV,
 * UCASEV_AL), and optionally set its value if an assignment.
 */
struct tbl *
typeset(const char *var, uint32_t set, uint32_t clr, int field, int base)
{
	return (vtypeset(NULL, var, set, clr, field, base));
}
static struct tbl *
vtypeset(int *ep, const char *var, uint32_t set, uint32_t clr,
    int field, int base)
{
	struct tbl *vp;
	struct tbl *vpbase, *t;
	char *tvar, tvarbuf[32];
	const char *val;
	size_t len;
	bool vappend = false;
	enum namerefflag new_refflag = SRF_NOP;

	if (ep)
		*ep = 0;

	if ((set & (ARRAY | ASSOC)) == ASSOC) {
		new_refflag = SRF_ENABLE;
		set &= ~(ARRAY | ASSOC);
	}
	if ((clr & (ARRAY | ASSOC)) == ASSOC) {
		new_refflag = SRF_DISABLE;
		clr &= ~(ARRAY | ASSOC);
	}

	/* check for valid variable name, search for value */
	val = skip_varname(var, false);
	if (val == var) {
		/* no variable name given */
		return (NULL);
	}
	if (ord(*val) == ORD('[')) {
		if (new_refflag != SRF_NOP)
			return (maybe_errorf(ep, 1, Tf_sD_s, var,
			    "reference variable can't be an array"), NULL);
		len = array_ref_len(val);
		if (len == 0)
			return (NULL);
		/*
		 * IMPORT is only used when the shell starts up and is
		 * setting up its environment. Allow only simple array
		 * references at this time since parameter/command
		 * substitution is performed on the [expression] which
		 * would be a major security hole.
		 */
		if (set & IMPORT) {
			size_t i;

			for (i = 1; i < len - 1; i++)
				if (!ctype(val[i], C_DIGIT))
					return (NULL);
		}
		val += len;
	}
	if (ord(val[0]) == ORD('=')) {
		len = val - var;
		tvar = len < sizeof(tvarbuf) ? tvarbuf : alloc(len + 1, ATEMP);
		memcpy(tvar, var, len);
		tvar[len] = '\0';
		++val;
	} else if (set & IMPORT) {
		/* environment invalid variable name or no assignment */
		return (NULL);
	} else if (ord(val[0]) == ORD('+') && ord(val[1]) == ORD('=')) {
		len = val - var;
		tvar = len < sizeof(tvarbuf) ? tvarbuf : alloc(len + 1, ATEMP);
		memcpy(tvar, var, len);
		tvar[len] = '\0';
		val += 2;
		vappend = true;
	} else if (val[0] != '\0') {
		/* other invalid variable names (not from environment) */
		return (NULL);
	} else {
		/* just varname with no value part nor equals sign */
		len = strlen(var);
		tvar = len < sizeof(tvarbuf) ? tvarbuf : alloc(len + 1, ATEMP);
		memcpy(tvar, var, len);
		tvar[len] = '\0';
		val = NULL;
		/* handle foo[*] => foo (whole array) mapping for R39b */
		if (len > 3 && ord(tvar[len - 3]) == ORD('[') &&
		    ord(tvar[len - 2]) == ORD('*') &&
		    ord(tvar[len - 1]) == ORD(']'))
			tvar[len - 3] = '\0';
	}

	if (new_refflag == SRF_ENABLE) {
		const char *qval, *ccp;

		/* bail out on 'nameref foo+=bar' */
		if (vappend)
			return (maybe_errorf(ep, 1,
			    "appending not allowed for nameref"), NULL);
		/* find value if variable already exists */
		if ((qval = val) == NULL) {
			varsearch(e->loc, &vp, tvar, hash(tvar));
			if (vp == NULL)
				goto nameref_empty;
			qval = str_val(vp);
		}
		/* check target value for being a valid variable name */
		ccp = skip_varname(qval, false);
		if (ccp == qval) {
			int c;

			if (!(c = (unsigned char)qval[0]))
				goto nameref_empty;
			else if (ctype(c, C_DIGIT) && getn(qval, &c))
				goto nameref_rhs_checked;
			else if (qval[1] == '\0') switch (c) {
			case '$':
			case '!':
			case '?':
			case '#':
			case '-':
				goto nameref_rhs_checked;
			}
 nameref_empty:
			return (maybe_errorf(ep, 1, Tf_sD_s, var,
			    "empty nameref target"), NULL);
		}
		len = (ord(*ccp) == ORD('[')) ? array_ref_len(ccp) : 0;
		if (ccp[len]) {
			/*
			 * works for cases "no array", "valid array with
			 * junk after it" and "invalid array"; in the
			 * latter case, len is also 0 and points to '['
			 */
			return (maybe_errorf(ep, 1, Tf_sD_s, qval,
			    "nameref target not a valid parameter name"), NULL);
		}
 nameref_rhs_checked:
		/* prevent nameref loops */
		while (qval) {
			if (!strcmp(qval, tvar))
				return (maybe_errorf(ep, 1, Tf_sD_s, qval,
				    "expression recurses on parameter"), NULL);
			varsearch(e->loc, &vp, qval, hash(qval));
			qval = NULL;
			if (vp && ((vp->flag & (ARRAY | ASSOC)) == ASSOC))
				qval = str_val(vp);
		}
	}

	/* prevent typeset from creating a local PATH/ENV/SHELL */
	if (Flag(FRESTRICTED) && (strcmp(tvar, TPATH) == 0 ||
	    strcmp(tvar, "ENV") == 0 || strcmp(tvar, TSHELL) == 0))
		return (maybe_errorf(ep, 1, Tf_sD_s,
		    tvar, "restricted"), NULL);

	innermost_refflag = new_refflag;
	vp = (set & LOCAL) ? local(tvar, tobool(set & LOCAL_COPY)) :
	    global(tvar);
	if (new_refflag == SRF_DISABLE && (vp->flag & (ARRAY|ASSOC)) == ASSOC)
		vp->flag &= ~ASSOC;
	else if (new_refflag == SRF_ENABLE) {
		if (vp->flag & ARRAY) {
			struct tbl *a, *tmp;

			/* free up entire array */
			for (a = vp->u.array; a; ) {
				tmp = a;
				a = a->u.array;
				if (tmp->flag & ALLOC)
					afree(tmp->val.s, tmp->areap);
				afree(tmp, tmp->areap);
			}
			vp->u.array = NULL;
			vp->flag &= ~ARRAY;
		}
		vp->flag |= ASSOC;
	}

	set &= ~(LOCAL|LOCAL_COPY);

	vpbase = (vp->flag & ARRAY) ? global(arrayname(tvar)) : vp;

	/*
	 * only allow export and readonly flag to be set; AT&T ksh
	 * allows any attribute to be changed which means it can be
	 * truncated or modified (-L/-R/-Z/-i)
	 */
	if ((vpbase->flag & RDONLY) &&
	    (val || clr || (set & ~(EXPORT | RDONLY))))
		return (maybe_errorf(ep, 2, Tf_ro, tvar), NULL);
	if (tvar != tvarbuf)
		afree(tvar, ATEMP);

	/* most calls are with set/clr == 0 */
	if (set | clr) {
		bool ok = true;

		/*
		 * XXX if x[0] isn't set, there will be problems: need
		 * to have one copy of attributes for arrays...
		 */
		for (t = vpbase; t; t = t->u.array) {
			bool fake_assign;
			char *s = NULL;
			char *free_me = NULL;

			fake_assign = (t->flag & ISSET) && (!val || t != vp) &&
			    ((set & (UCASEV_AL|LCASEV|LJUST|RJUST|ZEROFIL)) ||
			    ((t->flag & INTEGER) && (clr & INTEGER)) ||
			    (!(t->flag & INTEGER) && (set & INTEGER)));
			if (fake_assign) {
				if (t->flag & INTEGER) {
					s = str_val(t);
					free_me = NULL;
				} else {
					s = t->val.s + t->type;
					free_me = (t->flag & ALLOC) ? t->val.s :
					    NULL;
				}
				t->flag &= ~ALLOC;
			}
			if (!(t->flag & INTEGER) && (set & INTEGER)) {
				t->type = 0;
				t->flag &= ~ALLOC;
			}
			t->flag = (t->flag | set) & ~clr;
			/*
			 * Don't change base if assignment is to be
			 * done, in case assignment fails.
			 */
			if ((set & INTEGER) && base > 0 && (!val || t != vp))
				t->type = base;
			if (set & (LJUST|RJUST|ZEROFIL))
				t->u2.field = field;
			if (fake_assign) {
				if (!setstr(t, s, KSH_RETURN_ERROR)) {
					/*
					 * Somewhat arbitrary action
					 * here: zap contents of
					 * variable, but keep the flag
					 * settings.
					 */
					ok = false;
					if (t->flag & INTEGER)
						t->flag &= ~ISSET;
					else {
						if (t->flag & ALLOC)
							afree(t->val.s, t->areap);
						t->flag &= ~(ISSET|ALLOC);
						t->type = 0;
					}
				}
				afree(free_me, t->areap);
			}
		}
		if (!ok)
			return (maybe_errorf(ep, 1, NULL), NULL);
	}

	if (vappend) {
		size_t tlen;
		if ((vp->flag & (ISSET|ALLOC|SPECIAL|INTEGER|UCASEV_AL|LCASEV|LJUST|RJUST)) != (ISSET|ALLOC)) {
			/* cannot special-case this */
			strdup2x(tvar, str_val(vp), val);
			val = tvar;
			goto vassign;
		}
		/* trivial string appending */
		len = strlen(vp->val.s);
		tlen = strlen(val) + 1;
		vp->val.s = aresize(vp->val.s, len + tlen, vp->areap);
		memcpy(vp->val.s + len, val, tlen);
	} else if (val != NULL) {
 vassign:
		if (vp->flag&INTEGER) {
			/* do not zero base before assignment */
			setstr(vp, val, KSH_UNWIND_ERROR | 0x4);
			/* done after assignment to override default */
			if (base > 0)
				vp->type = base;
		} else
			/* setstr can't fail (readonly check already done) */
			setstr(vp, val, KSH_RETURN_ERROR | 0x4);

		/* came here from vappend? need to free temp val */
		if (vappend)
			afree(tvar, ATEMP);
	}

	/* only x[0] is ever exported, so use vpbase */
	if ((vpbase->flag & (EXPORT|INTEGER)) == EXPORT &&
	    vpbase->type == 0)
		exportprep(vpbase, (vpbase->flag & ISSET) ?
		    vpbase->val.s : null, 0);

	return (vp);
}

/**
 * Unset a variable. The flags can be:
 * |1	= tear down entire array
 * |2	= keep attributes, only unset content
 */
void
unset(struct tbl *vp, int flags)
{
	if (vp->flag & ALLOC)
		afree(vp->val.s, vp->areap);
	if ((vp->flag & ARRAY) && (flags & 1)) {
		struct tbl *a, *tmp;

		/* free up entire array */
		for (a = vp->u.array; a; ) {
			tmp = a;
			a = a->u.array;
			if (tmp->flag & ALLOC)
				afree(tmp->val.s, tmp->areap);
			afree(tmp, tmp->areap);
		}
		vp->u.array = NULL;
	}
	if (flags & 2) {
		vp->flag &= ~(ALLOC|ISSET);
		return;
	}
	/* if foo[0] is being unset, the remainder of the array is kept... */
	vp->flag &= SPECIAL | ((flags & 1) ? 0 : ARRAY|DEFINED);
	if (vp->flag & SPECIAL)
		/* responsible for 'unspecial'ing var */
		unsetspec(vp, true);
}

/*
 * Return a pointer to the first char past a legal variable name
 * (returns the argument if there is no legal name, returns a pointer to
 * the terminating NUL if whole string is legal).
 */
const char *
skip_varname(const char *s, bool aok)
{
	size_t alen;

	if (s && ctype(*s, C_ALPHX)) {
		do {
			++s;
		} while (ctype(*s, C_ALNUX));
		if (aok && ord(*s) == ORD('[') && (alen = array_ref_len(s)))
			s += alen;
	}
	return (s);
}

/* Return a pointer to the first character past any legal variable name */
const char *
skip_wdvarname(const char *s,
    /* skip array de-reference? */
    bool aok)
{
	if (s[0] == CHAR && ctype(s[1], C_ALPHX)) {
		do {
			s += 2;
		} while (s[0] == CHAR && ctype(s[1], C_ALNUX));
		if (aok && s[0] == CHAR && ord(s[1]) == ORD('[')) {
			/* skip possible array de-reference */
			const char *p = s;
			char c;
			int depth = 0;

			while (/* CONSTCOND */ 1) {
				if (p[0] != CHAR)
					break;
				c = p[1];
				p += 2;
				if (ord(c) == ORD('['))
					depth++;
				else if (ord(c) == ORD(']') && --depth == 0) {
					s = p;
					break;
				}
			}
		}
	}
	return (s);
}

/* Check if coded string s is a variable name */
int
is_wdvarname(const char *s, bool aok)
{
	const char *p = skip_wdvarname(s, aok);

	return (p != s && p[0] == EOS);
}

/* Check if coded string s is a variable assignment */
int
is_wdvarassign(const char *s)
{
	const char *p = skip_wdvarname(s, true);

	return (p != s && p[0] == CHAR &&
	    (p[1] == '=' || (p[1] == '+' && p[2] == CHAR && p[3] == '=')));
}

/*
 * Make the exported environment from the exported names in the dictionary.
 */
char **
makenv(void)
{
	ssize_t i;
	struct block *l;
	XPtrV denv;
	struct tbl *vp, **vpp;

	XPinit(denv, 64);
	for (l = e->loc; l != NULL; l = l->next) {
		vpp = l->vars.tbls;
		i = 1 << (l->vars.tshift);
		while (--i >= 0)
			if ((vp = *vpp++) != NULL &&
			    (vp->flag&(ISSET|EXPORT)) == (ISSET|EXPORT)) {
				struct block *l2;
				struct tbl *vp2;
				uint32_t h = hash(vp->name);

				/* unexport any redefined instances */
				for (l2 = l->next; l2 != NULL; l2 = l2->next) {
					vp2 = ktsearch(&l2->vars, vp->name, h);
					if (vp2 != NULL)
						vp2->flag &= ~EXPORT;
				}
				if ((vp->flag&INTEGER)) {
					/* integer to string */
					char *val;
					val = str_val(vp);
					vp->flag &= ~(INTEGER|RDONLY|SPECIAL);
					/* setstr can't fail here */
					setstr(vp, val, KSH_RETURN_ERROR);
				}
#ifdef __OS2__
				/* these special variables are not exported */
				if (!strcmp(vp->name, "BEGINLIBPATH") ||
				    !strcmp(vp->name, "ENDLIBPATH") ||
				    !strcmp(vp->name, "LIBPATHSTRICT"))
					continue;
#endif
				XPput(denv, vp->val.s);
			}
		if (l->flags & BF_STOPENV)
			break;
	}
	XPput(denv, NULL);
	return ((char **)XPclose(denv));
}

/*
 * handle special variables with side effects - PATH, SECONDS.
 */

/* Test if name is a special parameter */
static int
special(const char *name)
{
	struct tbl *tp;

	tp = ktsearch(&specials, name, hash(name));
	return (tp && (tp->flag & ISSET) ? tp->type : V_NONE);
}

/* Make a variable non-special */
static void
unspecial(const char *name)
{
	struct tbl *tp;

	tp = ktsearch(&specials, name, hash(name));
	if (tp)
		ktdelete(tp);
}

static time_t seconds;		/* time SECONDS last set */
static mksh_uari_t user_lineno;	/* what user set $LINENO to */

/* minimum values from the OS we consider sane, lowered for R53 */
#define MIN_COLS	4
#define MIN_LINS	2

static void
getspec(struct tbl *vp)
{
	mksh_ari_u num;
	int st;
	struct timeval tv;

	switch ((st = special(vp->name))) {
	case V_COLUMNS:
	case V_LINES:
		/*
		 * Do NOT export COLUMNS/LINES. Many applications
		 * check COLUMNS/LINES before checking ws.ws_col/row,
		 * so if the app is started with C/L in the environ
		 * and the window is then resized, the app won't
		 * see the change cause the environ doesn't change.
		 */
		if (got_winch)
			change_winsz();
		break;
	}
	switch (st) {
	case V_BASHPID:
		num.u = (mksh_uari_t)procpid;
		break;
	case V_COLUMNS:
		num.i = x_cols;
		break;
	case V_HISTSIZE:
		num.i = histsize;
		break;
	case V_LINENO:
		num.u = (mksh_uari_t)current_lineno + user_lineno;
		break;
	case V_LINES:
		num.i = x_lins;
		break;
	case V_EPOCHREALTIME: {
		/* 10(%u) + 1(.) + 6 + NUL */
		char buf[18];

		vp->flag &= ~SPECIAL;
		mksh_TIME(tv);
		shf_snprintf(buf, sizeof(buf), "%u.%06u",
		    (unsigned)tv.tv_sec, (unsigned)tv.tv_usec);
		setstr(vp, buf, KSH_RETURN_ERROR | 0x4);
		vp->flag |= SPECIAL;
		return;
	}
	case V_OPTIND:
		num.i = user_opt.uoptind;
		break;
	case V_RANDOM:
		num.i = rndget();
		break;
	case V_SECONDS:
		/*
		 * On start up the value of SECONDS is used before
		 * it has been set - don't do anything in this case
		 * (see initcoms[] in main.c).
		 */
		if (vp->flag & ISSET) {
			mksh_TIME(tv);
			num.i = tv.tv_sec - seconds;
		} else
			return;
		break;
	default:
		/* do nothing, do not touch vp at all */
		return;
	}
	vp->flag &= ~SPECIAL;
	setint_n(vp, num.i, 0);
	vp->flag |= SPECIAL;
}

static void
setspec(struct tbl *vp)
{
	mksh_ari_u num;
	char *s;
	int st = special(vp->name);

#ifdef MKSH_DOSPATH
	switch (st) {
	case V_PATH:
	case V_TMPDIR:
#ifdef __OS2__
	case V_BEGINLIBPATH:
	case V_ENDLIBPATH:
#endif
		/* convert backslashes to slashes for convenience */
		if (!(vp->flag&INTEGER)) {
			s = str_val(vp);
			do {
				if (*s == ORD('\\'))
					*s = '/';
			} while (*s++);
		}
		break;
	}
#endif

	switch (st) {
#ifdef __OS2__
	case V_BEGINLIBPATH:
	case V_ENDLIBPATH:
	case V_LIBPATHSTRICT:
		setextlibpath(vp->name, str_val(vp));
		return;
#endif
#if HAVE_PERSISTENT_HISTORY
	case V_HISTFILE:
		sethistfile(str_val(vp));
		return;
#endif
	case V_IFS:
		set_ifs(str_val(vp));
		return;
	case V_PATH:
		afree(path, APERM);
		s = str_val(vp);
		strdupx(path, s, APERM);
		/* clear tracked aliases */
		flushcom(true);
		return;
#ifndef MKSH_NO_CMDLINE_EDITING
	case V_TERM:
		x_initterm(str_val(vp));
		return;
#endif
	case V_TMPDIR:
		afree(tmpdir, APERM);
		tmpdir = NULL;
		/*
		 * Use tmpdir iff it is an absolute path, is writable
		 * and searchable and is a directory...
		 */
		{
			struct stat statb;

			s = str_val(vp);
			/* LINTED use of access */
			if (mksh_abspath(s) && access(s, W_OK|X_OK) == 0 &&
			    stat(s, &statb) == 0 && S_ISDIR(statb.st_mode))
				strdupx(tmpdir, s, APERM);
		}
		return;
	/* common sub-cases */
	case V_COLUMNS:
	case V_LINES:
		if (vp->flag & IMPORT) {
			/* do not touch */
			unspecial(vp->name);
			vp->flag &= ~SPECIAL;
			return;
		}
		/* FALLTHROUGH */
	case V_HISTSIZE:
	case V_LINENO:
	case V_OPTIND:
	case V_RANDOM:
	case V_SECONDS:
	case V_TMOUT:
		vp->flag &= ~SPECIAL;
		if (getint(vp, &num, false) == -1) {
			s = str_val(vp);
			if (st != V_RANDOM)
				errorf(Tf_sD_sD_s, vp->name, Tbadnum, s);
			num.u = hash(s);
		}
		vp->flag |= SPECIAL;
		break;
#ifdef MKSH_EARLY_LOCALE_TRACKING
	case V_LANG:
	case V_LC_ALL:
	case V_LC_CTYPE:
		recheck_ctype();
		return;
#endif
	default:
		/* do nothing, do not touch vp at all */
		return;
	}

	/* process the singular parts of the common cases */

	switch (st) {
	case V_COLUMNS:
		if (num.i >= MIN_COLS)
			x_cols = num.i;
		break;
	case V_HISTSIZE:
		sethistsize(num.i);
		break;
	case V_LINENO:
		/* The -1 is because line numbering starts at 1. */
		user_lineno = num.u - (mksh_uari_t)current_lineno - 1;
		break;
	case V_LINES:
		if (num.i >= MIN_LINS)
			x_lins = num.i;
		break;
	case V_OPTIND:
		getopts_reset((int)num.i);
		break;
	case V_RANDOM:
		/*
		 * mksh R39d+ no longer has the traditional repeatability
		 * of $RANDOM sequences, but always retains state
		 */
		rndset((unsigned long)num.u);
		break;
	case V_SECONDS:
		{
			struct timeval tv;

			mksh_TIME(tv);
			seconds = tv.tv_sec - num.i;
		}
		break;
	case V_TMOUT:
		ksh_tmout = num.i >= 0 ? num.i : 0;
		break;
	}
}

static void
unsetspec(struct tbl *vp, bool dounset)
{
	/*
	 * AT&T ksh man page says OPTIND, OPTARG and _ lose special
	 * meaning, but OPTARG does not (still set by getopts) and _ is
	 * also still set in various places. Don't know what AT&T does
	 * for HISTSIZE, HISTFILE. Unsetting these in AT&T ksh does not
	 * loose the 'specialness': IFS, COLUMNS, PATH, TMPDIR
	 */

	switch (special(vp->name)) {
#ifdef __OS2__
	case V_BEGINLIBPATH:
	case V_ENDLIBPATH:
	case V_LIBPATHSTRICT:
		setextlibpath(vp->name, "");
		return;
#endif
#if HAVE_PERSISTENT_HISTORY
	case V_HISTFILE:
		sethistfile(NULL);
		return;
#endif
	case V_IFS:
		set_ifs(TC_IFSWS);
		return;
	case V_PATH:
		afree(path, APERM);
		strdupx(path, def_path, APERM);
		/* clear tracked aliases */
		flushcom(true);
		return;
#ifndef MKSH_NO_CMDLINE_EDITING
	case V_TERM:
		x_initterm(null);
		return;
#endif
	case V_TMPDIR:
		/* should not become unspecial */
		if (tmpdir) {
			afree(tmpdir, APERM);
			tmpdir = NULL;
		}
		return;
	case V_LINENO:
	case V_RANDOM:
	case V_SECONDS:
	case V_TMOUT:
		/* AT&T ksh leaves previous value in place */
		unspecial(vp->name);
		return;
#ifdef MKSH_EARLY_LOCALE_TRACKING
	case V_LANG:
	case V_LC_ALL:
	case V_LC_CTYPE:
		recheck_ctype();
		return;
#endif
	/* should not become unspecial, but allow unsetting */
	case V_COLUMNS:
	case V_LINES:
		if (dounset)
			unspecial(vp->name);
		return;
	}
}

/*
 * Search for (and possibly create) a table entry starting with
 * vp, indexed by val.
 */
struct tbl *
arraysearch(struct tbl *vp, uint32_t val)
{
	struct tbl *prev, *curr, *news;
	size_t len;

	vp->flag = (vp->flag | (ARRAY | DEFINED)) & ~ASSOC;
	/* the table entry is always [0] */
	if (val == 0)
		return (vp);
	prev = vp;
	curr = vp->u.array;
	while (curr && curr->ua.index < val) {
		prev = curr;
		curr = curr->u.array;
	}
	if (curr && curr->ua.index == val) {
		if (curr->flag&ISSET)
			return (curr);
		news = curr;
	} else
		news = NULL;
	if (!news) {
		len = strlen(vp->name);
		checkoktoadd(len, 1 + offsetof(struct tbl, name[0]));
		news = alloc(offsetof(struct tbl, name[0]) + ++len, vp->areap);
		memcpy(news->name, vp->name, len);
	}
	news->flag = (vp->flag & ~(ALLOC|DEFINED|ISSET|SPECIAL)) | AINDEX;
	news->type = vp->type;
	news->areap = vp->areap;
	news->u2.field = vp->u2.field;
	news->ua.index = val;

	if (curr != news) {
		/* not reusing old array entry */
		prev->u.array = news;
		news->u.array = curr;
	}
	return (news);
}

/*
 * Return the length of an array reference (eg, [1+2]) - cp is assumed
 * to point to the open bracket. Returns 0 if there is no matching
 * closing bracket.
 *
 * XXX this should parse the actual arithmetic syntax
 */
size_t
array_ref_len(const char *cp)
{
	const char *s = cp;
	char c;
	int depth = 0;

	while ((c = *s++) && (ord(c) != ORD(']') || --depth))
		if (ord(c) == ORD('['))
			depth++;
	if (!c)
		return (0);
	return (s - cp);
}

/*
 * Make a copy of the base of an array name
 */
char *
arrayname(const char *str)
{
	const char *p;
	char *rv;

	if (!(p = cstrchr(str, '[')))
		/* Shouldn't happen, but why worry? */
		strdupx(rv, str, ATEMP);
	else
		strndupx(rv, str, p - str, ATEMP);

	return (rv);
}

/* set (or overwrite, if reset) the array variable var to the values in vals */
mksh_uari_t
set_array(const char *var, bool reset, const char **vals)
{
	struct tbl *vp, *vq;
	mksh_uari_t i = 0, j = 0;
	const char *ccp = var;
	char *cp = NULL;
	size_t n;

	/* to get local array, use "local foo; set -A foo" */
	n = strlen(var);
	if (n > 0 && var[n - 1] == '+') {
		/* append mode */
		reset = false;
		strndupx(cp, var, n - 1, ATEMP);
		ccp = cp;
	}
	vp = global(ccp);

	/* Note: AT&T ksh allows set -A but not set +A of a read-only var */
	if ((vp->flag&RDONLY))
		errorfx(2, Tf_ro, ccp);
	/* This code is quite non-optimal */
	if (reset) {
		/* trash existing values and attributes */
		unset(vp, 1);
		/* allocate-by-access the [0] element to keep in scope */
		arraysearch(vp, 0);
		/* honour set -o allexport */
		if (Flag(FEXPORT))
			typeset(ccp, EXPORT, 0, 0, 0);
	}
	/*
	 * TODO: would be nice for assignment to completely succeed or
	 * completely fail. Only really effects integer arrays:
	 * evaluation of some of vals[] may fail...
	 */
	if (cp != NULL) {
		/* find out where to set when appending */
		for (vq = vp; vq; vq = vq->u.array) {
			if (!(vq->flag & ISSET))
				continue;
			if (arrayindex(vq) >= j)
				j = arrayindex(vq) + 1;
		}
		afree(cp, ATEMP);
	}
	while ((ccp = vals[i])) {
#if 0 /* temporarily taken out due to regression */
		if (ord(*ccp) == ORD('[')) {
			int level = 0;

			while (*ccp) {
				if (ord(*ccp) == ORD(']') && --level == 0)
					break;
				if (ord(*ccp) == ORD('['))
					++level;
				++ccp;
			}
			if (ord(*ccp) == ORD(']') && level == 0 &&
			    ord(ccp[1]) == ORD('=')) {
				strndupx(cp, vals[i] + 1, ccp - (vals[i] + 1),
				    ATEMP);
				evaluate(substitute(cp, 0), (mksh_ari_t *)&j,
				    KSH_UNWIND_ERROR, true);
				afree(cp, ATEMP);
				ccp += 2;
			} else
				ccp = vals[i];
		}
#endif

		vq = arraysearch(vp, j);
		/* would be nice to deal with errors here... (see above) */
		setstr(vq, ccp, KSH_RETURN_ERROR);
		i++;
		j++;
	}

	return (i);
}

void
change_winsz(void)
{
	struct timeval tv;

	mksh_TIME(tv);
	BAFHUpdateMem_mem(qh_state, &tv, sizeof(tv));

#ifdef TIOCGWINSZ
	/* check if window size has changed */
	if (tty_init_fd() < 2) {
		struct winsize ws;

		if (ioctl(tty_fd, TIOCGWINSZ, &ws) >= 0) {
			if (ws.ws_col)
				x_cols = ws.ws_col;
			if (ws.ws_row)
				x_lins = ws.ws_row;
		}
	}
#endif

	/* bounds check for sane values, use defaults otherwise */
	if (x_cols < MIN_COLS)
		x_cols = 80;
	if (x_lins < MIN_LINS)
		x_lins = 24;

#ifdef SIGWINCH
	got_winch = 0;
#endif
}

uint32_t
hash(const void *s)
{
	register uint32_t h;

	BAFHInit(h);
	BAFHUpdateStr_reg(h, s);
	BAFHFinish_reg(h);
	return (h);
}

uint32_t
chvt_rndsetup(const void *bp, size_t sz)
{
	register uint32_t h;

	/* use LCG as seed but try to get them to deviate immediately */
	h = lcg_state;
	(void)rndget();
	BAFHFinish_reg(h);
	/* variation through pid, ppid, and the works */
	BAFHUpdateMem_reg(h, &rndsetupstate, sizeof(rndsetupstate));
	/* some variation, some possibly entropy, depending on OE */
	BAFHUpdateMem_reg(h, bp, sz);
	/* mix them all up */
	BAFHFinish_reg(h);

	return (h);
}

mksh_ari_t
rndget(void)
{
	/*
	 * this is the same Linear Congruential PRNG as Borland
	 * C/C++ allegedly uses in its built-in rand() function
	 */
	return (((lcg_state = 22695477 * lcg_state + 1) >> 16) & 0x7FFF);
}

void
rndset(unsigned long v)
{
	register uint32_t h;
#if defined(arc4random_pushb_fast) || defined(MKSH_A4PB)
	register uint32_t t;
#endif
	struct {
		struct timeval tv;
		void *sp;
		uint32_t qh;
		pid_t pp;
		short r;
	} z;

	/* clear the allocated space, for valgrind and to avoid UB */
	memset(&z, 0, sizeof(z));

	h = lcg_state;
	BAFHFinish_reg(h);
	BAFHUpdateMem_reg(h, &v, sizeof(v));

	mksh_TIME(z.tv);
	z.sp = &lcg_state;
	z.pp = procpid;
	z.r = (short)rndget();

#if defined(arc4random_pushb_fast) || defined(MKSH_A4PB)
	t = qh_state;
	BAFHFinish_reg(t);
	z.qh = (t & 0xFFFF8000) | rndget();
	lcg_state = (t << 15) | rndget();
	/*
	 * either we have very chap entropy get and push available,
	 * with malloc() pulling in this code already anyway, or the
	 * user requested us to use the old functions
	 */
	t = h;
	BAFHUpdateMem_reg(t, &lcg_state, sizeof(lcg_state));
	BAFHFinish_reg(t);
	lcg_state = t;
#if defined(arc4random_pushb_fast)
	arc4random_pushb_fast(&lcg_state, sizeof(lcg_state));
	lcg_state = arc4random();
#else
	lcg_state = arc4random_pushb(&lcg_state, sizeof(lcg_state));
#endif
	BAFHUpdateMem_reg(h, &lcg_state, sizeof(lcg_state));
#else
	z.qh = qh_state;
#endif

	BAFHUpdateMem_reg(h, &z, sizeof(z));
	BAFHFinish_reg(h);
	lcg_state = h;
}

void
rndpush(const void *s)
{
	register uint32_t h = qh_state;

	BAFHUpdateStr_reg(h, s);
	BAFHUpdateOctet_reg(h, 0);
	qh_state = h;
}

/* record last glob match */
void
record_match(const char *istr)
{
	struct tbl *vp;

	vp = local("KSH_MATCH", false);
	unset(vp, 1);
	vp->flag = DEFINED | RDONLY;
	setstr(vp, istr, 0x4);
}

/* typeset, global(deprecated), export, and readonly */
int
c_typeset(const char **wp)
{
	struct tbl *vp, **p;
	uint32_t fset = 0, fclr = 0, flag;
	int thing = 0, field = 0, base = 0, i;
	struct block *l;
	const char *opts;
	const char *fieldstr = NULL, *basestr = NULL;
	bool localv = false, func = false, pflag = false, istset = true;
	enum namerefflag new_refflag = SRF_NOP;

	switch (**wp) {

	/* export */
	case 'e':
		fset |= EXPORT;
		istset = false;
		break;

	/* readonly */
	case 'r':
		fset |= RDONLY;
		istset = false;
		break;

	/* set */
	case 's':
		/* called with 'typeset -' */
		break;

	/* typeset */
	case 't':
		localv = true;
		break;
	}

	/* see comment below regarding possible opions */
	opts = istset ? "L#R#UZ#afgi#lnprtux" : "p";

	builtin_opt.flags |= GF_PLUSOPT;
	/*
	 * AT&T ksh seems to have 0-9 as options which are multiplied
	 * to get a number that is used with -L, -R, -Z or -i (eg, -1R2
	 * sets right justify in a field of 12). This allows options
	 * to be grouped in an order (eg, -Lu12), but disallows -i8 -L3 and
	 * does not allow the number to be specified as a separate argument
	 * Here, the number must follow the RLZi option, but is optional
	 * (see the # kludge in ksh_getopt()).
	 */
	while ((i = ksh_getopt(wp, &builtin_opt, opts)) != -1) {
		flag = 0;
		switch (i) {
		case 'L':
			flag = LJUST;
			fieldstr = builtin_opt.optarg;
			break;
		case 'R':
			flag = RJUST;
			fieldstr = builtin_opt.optarg;
			break;
		case 'U':
			/*
			 * AT&T ksh uses u, but this conflicts with
			 * upper/lower case. If this option is changed,
			 * need to change the -U below as well
			 */
			flag = INT_U;
			break;
		case 'Z':
			flag = ZEROFIL;
			fieldstr = builtin_opt.optarg;
			break;
		case 'a':
			/*
			 * this is supposed to set (-a) or unset (+a) the
			 * indexed array attribute; it does nothing on an
			 * existing regular string or indexed array though
			 */
			break;
		case 'f':
			func = true;
			break;
		case 'g':
			localv = (builtin_opt.info & GI_PLUS) ? true : false;
			break;
		case 'i':
			flag = INTEGER;
			basestr = builtin_opt.optarg;
			break;
		case 'l':
			flag = LCASEV;
			break;
		case 'n':
			new_refflag = (builtin_opt.info & GI_PLUS) ?
			    SRF_DISABLE : SRF_ENABLE;
			break;
		/* export, readonly: POSIX -p flag */
		case 'p':
			/* typeset: show values as well */
			pflag = true;
			if (istset)
				continue;
			break;
		case 'r':
			flag = RDONLY;
			break;
		case 't':
			flag = TRACE;
			break;
		case 'u':
			/* upper case / autoload */
			flag = UCASEV_AL;
			break;
		case 'x':
			flag = EXPORT;
			break;
		case '?':
			return (1);
		}
		if (builtin_opt.info & GI_PLUS) {
			fclr |= flag;
			fset &= ~flag;
			thing = '+';
		} else {
			fset |= flag;
			fclr &= ~flag;
			thing = '-';
		}
	}

	if (fieldstr && !getn(fieldstr, &field)) {
		bi_errorf(Tf_sD_s, Tbadnum, fieldstr);
		return (1);
	}
	if (basestr) {
		if (!getn(basestr, &base)) {
			bi_errorf(Tf_sD_s, "bad integer base", basestr);
			return (1);
		}
		if (base < 1 || base > 36)
			base = 10;
	}

	if (!(builtin_opt.info & GI_MINUSMINUS) && wp[builtin_opt.optind] &&
	    (wp[builtin_opt.optind][0] == '-' ||
	    wp[builtin_opt.optind][0] == '+') &&
	    wp[builtin_opt.optind][1] == '\0') {
		thing = wp[builtin_opt.optind][0];
		builtin_opt.optind++;
	}

	if (func && (((fset|fclr) & ~(TRACE|UCASEV_AL|EXPORT)) ||
	    new_refflag != SRF_NOP)) {
		bi_errorf("only -t, -u and -x options may be used with -f");
		return (1);
	}
	if (wp[builtin_opt.optind]) {
		/*
		 * Take care of exclusions.
		 * At this point, flags in fset are cleared in fclr and vice
		 * versa. This property should be preserved.
		 */
		if (fset & LCASEV)
			/* LCASEV has priority over UCASEV_AL */
			fset &= ~UCASEV_AL;
		if (fset & LJUST)
			/* LJUST has priority over RJUST */
			fset &= ~RJUST;
		if ((fset & (ZEROFIL|LJUST)) == ZEROFIL) {
			/* -Z implies -ZR */
			fset |= RJUST;
			fclr &= ~RJUST;
		}
		/*
		 * Setting these attributes clears the others, unless they
		 * are also set in this command
		 */
		if ((fset & (LJUST | RJUST | ZEROFIL | UCASEV_AL | LCASEV |
		    INTEGER | INT_U | INT_L)) || new_refflag != SRF_NOP)
			fclr |= ~fset & (LJUST | RJUST | ZEROFIL | UCASEV_AL |
			    LCASEV | INTEGER | INT_U | INT_L);
	}
	if (new_refflag != SRF_NOP) {
		fclr &= ~(ARRAY | ASSOC);
		fset &= ~(ARRAY | ASSOC);
		fclr |= EXPORT;
		fset |= ASSOC;
		if (new_refflag == SRF_DISABLE)
			fclr |= ASSOC;
	}

	/* set variables and attributes */
	if (wp[builtin_opt.optind] &&
	    /* not "typeset -p varname" */
	    !(!func && pflag && !(fset | fclr))) {
		int rv = 0, x;
		struct tbl *f;

		if (localv && !func)
			fset |= LOCAL;
		for (i = builtin_opt.optind; wp[i]; i++) {
			if (func) {
				f = findfunc(wp[i], hash(wp[i]),
				    tobool(fset & UCASEV_AL));
				if (!f) {
					/* AT&T ksh does ++rv: bogus */
					rv = 1;
					continue;
				}
				if (fset | fclr) {
					f->flag |= fset;
					f->flag &= ~fclr;
				} else {
					fpFUNCTf(shl_stdout, 0,
					    tobool(f->flag & FKSH),
					    wp[i], f->val.t);
					shf_putc('\n', shl_stdout);
				}
			} else if (!vtypeset(&x, wp[i], fset, fclr,
			    field, base)) {
				if (x)
					return (x);
				bi_errorf(Tf_sD_s, wp[i], Tnot_ident);
				return (1);
			}
		}
		return (rv);
	}

	/* list variables and attributes */

	/* no difference at this point.. */
	flag = fset | fclr;
	if (func) {
		for (l = e->loc; l; l = l->next) {
			for (p = ktsort(&l->funs); (vp = *p++); ) {
				if (flag && (vp->flag & flag) == 0)
					continue;
				if (thing == '-')
					fpFUNCTf(shl_stdout, 0,
					    tobool(vp->flag & FKSH),
					    vp->name, vp->val.t);
				else
					shf_puts(vp->name, shl_stdout);
				shf_putc('\n', shl_stdout);
			}
		}
	} else if (wp[builtin_opt.optind]) {
		for (i = builtin_opt.optind; wp[i]; i++) {
			vp = isglobal(wp[i], false);
			c_typeset_vardump(vp, flag, thing,
			    last_lookup_was_array ? 4 : 0, pflag, istset);
		}
	} else
		c_typeset_vardump_recursive(e->loc, flag, thing, pflag, istset);
	return (0);
}

static void
c_typeset_vardump_recursive(struct block *l, uint32_t flag, int thing,
    bool pflag, bool istset)
{
	struct tbl **blockvars, *vp;

	if (l->next)
		c_typeset_vardump_recursive(l->next, flag, thing, pflag, istset);
	blockvars = ktsort(&l->vars);
	while ((vp = *blockvars++))
		c_typeset_vardump(vp, flag, thing, 0, pflag, istset);
	/*XXX doesn’t this leak? */
}

static void
c_typeset_vardump(struct tbl *vp, uint32_t flag, int thing, int any_set,
    bool pflag, bool istset)
{
	struct tbl *tvp;
	char *s;

	if (!vp)
		return;

	/*
	 * See if the parameter is set (for arrays, if any
	 * element is set).
	 */
	for (tvp = vp; tvp; tvp = tvp->u.array)
		if (tvp->flag & ISSET) {
			any_set |= 1;
			break;
		}

	/*
	 * Check attributes - note that all array elements
	 * have (should have?) the same attributes, so checking
	 * the first is sufficient.
	 *
	 * Report an unset param only if the user has
	 * explicitly given it some attribute (like export);
	 * otherwise, after "echo $FOO", we would report FOO...
	 */
	if (!any_set && !(vp->flag & USERATTRIB))
		return;
	if (flag && (vp->flag & flag) == 0)
		return;
	if (!(vp->flag & ARRAY))
		/* optimise later conditionals */
		any_set = 0;
	do {
		/*
		 * Ignore array elements that aren't set unless there
		 * are no set elements, in which case the first is
		 * reported on
		 */
		if (any_set && !(vp->flag & ISSET))
			continue;
		/* no arguments */
		if (!thing && !flag) {
			if (any_set == 1) {
				shprintf(Tf_s_s_sN, Tset, "-A", vp->name);
				any_set = 2;
			}
			/*
			 * AT&T ksh prints things like export, integer,
			 * leftadj, zerofill, etc., but POSIX says must
			 * be suitable for re-entry...
			 */
			shprintf(Tf_s_s, Ttypeset, "");
			if (((vp->flag & (ARRAY | ASSOC)) == ASSOC))
				shprintf(Tf__c_, 'n');
			if ((vp->flag & INTEGER))
				shprintf(Tf__c_, 'i');
			if ((vp->flag & EXPORT))
				shprintf(Tf__c_, 'x');
			if ((vp->flag & RDONLY))
				shprintf(Tf__c_, 'r');
			if ((vp->flag & TRACE))
				shprintf(Tf__c_, 't');
			if ((vp->flag & LJUST))
				shprintf("-L%d ", vp->u2.field);
			if ((vp->flag & RJUST))
				shprintf("-R%d ", vp->u2.field);
			if ((vp->flag & ZEROFIL))
				shprintf(Tf__c_, 'Z');
			if ((vp->flag & LCASEV))
				shprintf(Tf__c_, 'l');
			if ((vp->flag & UCASEV_AL))
				shprintf(Tf__c_, 'u');
			if ((vp->flag & INT_U))
				shprintf(Tf__c_, 'U');
		} else if (pflag) {
			shprintf(Tf_s_s, istset ? Ttypeset :
			    (flag & EXPORT) ? Texport : Treadonly, "");
		}
		if (any_set)
			shprintf("%s[%lu]", vp->name, arrayindex(vp));
		else
			shf_puts(vp->name, shl_stdout);
		if ((!thing && !flag && pflag) ||
		    (thing == '-' && (vp->flag & ISSET))) {
			s = str_val(vp);
			shf_putc('=', shl_stdout);
			/* AT&T ksh can't have justified integers... */
			if ((vp->flag & (INTEGER | LJUST | RJUST)) == INTEGER)
				shf_puts(s, shl_stdout);
			else
				print_value_quoted(shl_stdout, s);
		}
		shf_putc('\n', shl_stdout);

		/*
		 * Only report first 'element' of an array with
		 * no set elements.
		 */
		if (!any_set)
			return;
	} while (!(any_set & 4) && (vp = vp->u.array));
}
@


1.233
log
@slightly optimise the non-vappend cases as well by removing some branching

(not really noticeable compared to strlen costs…)

optimisation potential: note allocated size in struct tbl…
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.231 2019/12/11 22:27:30 tg Exp $");
d283 1
a283 1
		if (vn[1] != '\0')
@


1.232
log
@further memory optimisation
@
text
@d1020 13
a1032 7
	if (/* val != NULL true for vappend */ vappend &&
	    (vp->flag & (ISSET|ALLOC|SPECIAL|INTEGER|UCASEV_AL|LCASEV|LJUST|RJUST)) == (ISSET|ALLOC)) {
		/* special-case trivial string appending */
		size_t olen = strlen(vp->val.s);
		size_t nlen = strlen(val) + 1;
		vp->val.s = aresize(vp->val.s, olen + nlen, vp->areap);
		memcpy(vp->val.s + olen, val, nlen);
d1034 1
a1034 8
		char *tval;

		if (vappend) {
			strdup2x(tval, str_val(vp), val);
			val = tval;
		} else
			tval = NULL;

d1045 1
d1047 1
a1047 1
			afree(tval, ATEMP);
d1051 1
a1051 1
	if ((vpbase->flag&EXPORT) && !(vpbase->flag&INTEGER) &&
@


1.231
log
@save tons of realloc and free by…

• reusing already allocated variables (and allocating them the max() size
  needed in the first place)
• remembering the size allocated and avoiding shrinking calls to realloc
  (unless a configurable amount is wasted to keep RAM usage sensible) in
  those places where we guess the allocated size already (or with a small
  change)
• use an on-stack buffer for variable names up to 31 bytes

also saves a few afree calls where we know it can’t be nōn-nil
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.227 2019/08/02 00:21:53 tg Exp $");
d201 1
a201 1
			cp = shf_smprintf(Tf_ss, str_val(vp), p);
d212 1
d216 4
a219 3
		tmp = alloc((len - 2 > p - n ? len - 2 : p - n) + 1, ATEMP);
		memcpy(tmp, p + 1, len - 2);
		tmp[len - 2] = '\0';
d224 2
a225 2
		memcpy(tmp, n, p - n);
		tmp[p - n] = '\0';
d1031 1
a1031 1
			tval = shf_smprintf(Tf_ss, str_val(vp), val);
@


1.230
log
@replace some alloc+free with realloc
@
text
@d53 1
a53 1
static void exportprep(struct tbl *, const char *);
d215 3
a217 1
		strndupx(tmp, p + 1, len - 2, ATEMP);
a218 2
		afree(tmp, ATEMP);
		strndupx(n, n, p - n, ATEMP);
d222 3
a457 1
	char *salloc = NULL;
d469 2
a470 1
#ifdef DEBUG
d472 2
d475 1
a475 2
			if (s >= vq->val.s &&
			    s <= strnul(vq->val.s)) {
a479 1
		}
d481 2
d486 1
a486 1
			exportprep(vq, s);
d489 1
a489 1
			vq->val.s = aresize((vq->flag & ALLOC) ?
d495 1
a503 1
	afree(salloc, ATEMP);
d739 1
a739 1
exportprep(struct tbl *vp, const char *val)
d748 1
a748 1
	vp->val.s = aresize(cp, vp->type + vallen, vp->areap);
d770 1
a770 1
	char *tvar;
d818 4
a821 1
		strndupx(tvar, var, val - var, ATEMP);
d827 4
a830 1
		strndupx(tvar, var, val - var, ATEMP);
d838 4
a841 1
		strdupx(tvar, var, ATEMP);
a843 1
		len = strlen(tvar);
d949 2
a950 1
	afree(tvar, ATEMP);
d1044 2
a1045 1
		afree(tval, ATEMP);
d1051 2
a1052 1
		exportprep(vpbase, (vpbase->flag&ISSET) ? vpbase->val.s : null);
@


1.229
log
@special-case trivial string appending; Closes: LP#1855167
@
text
@d467 1
a468 1
#ifdef DEBUG
d476 1
a477 4
			afree(vq->val.s, vq->areap);
		}
		vq->flag &= ~(ISSET|ALLOC);
		vq->type = 0;
d483 4
a486 1
			strdupx(vq->val.s, s, vq->areap);
d488 1
d736 3
a738 6
	char *xp;
	char *op = (vp->flag&ALLOC) ? vp->val.s : NULL;
	size_t namelen, vallen;

	namelen = strlen(vp->name);
	vallen = strlen(val) + 1;
d741 1
d743 4
a746 8
	xp = alloc(namelen + 1 + vallen, vp->areap);
	memcpy(vp->val.s = xp, vp->name, namelen);
	xp += namelen;
	*xp++ = '=';
	/* offset to value */
	vp->type = xp - vp->val.s;
	memcpy(xp, val, vallen);
	afree(op, vp->areap);
@


1.228
log
@move potentially slow consistency check to #ifdef DEBUG

related to LP#1855167
@
text
@d1009 8
a1016 1
	if (val != NULL) {
@


1.227
log
@fix this one, too
@
text
@d32 1
a32 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.223 2018/01/13 23:55:15 tg Exp $");
d468 1
a468 1
#ifndef MKSH_SMALL
@


1.226
log
@against better judgement, allow unsetting COLUMNS:
• GNU coreutils’ test suite insists on it, even despite it can run
  successfully without doing it (WTF‽)…
• we already unspecial, explicitly commented as “hands-off” it,
  when imported from the environment
• it was already changeable (though that didn’t unspecial it on the
  command line)
@
text
@d5 2
a6 1
 *		 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018
d61 1
d762 6
d776 3
d796 2
a797 2
			errorf(Tf_sD_s, var,
			    "reference variable can't be an array");
d847 2
a848 1
			errorf("appending not allowed for nameref");
d874 2
a875 1
			errorf(Tf_sD_s, var, "empty nameref target");
d884 2
a885 2
			errorf(Tf_sD_s, qval,
			    "nameref target not a valid parameter name");
d891 2
a892 2
				errorf(Tf_sD_s, qval,
				    "expression recurses on parameter");
d903 2
a904 1
		errorf(Tf_sD_s, tvar, "restricted");
d940 1
a940 2
		/* XXX check calls - is error here ok by POSIX? */
		errorfx(2, Tf_ro, tvar);
d1006 1
a1006 1
			errorfz();
d2042 1
a2042 1
		int rv = 0;
d2065 4
a2068 1
			} else if (!typeset(wp[i], fset, fclr, field, base)) {
@


1.225
log
@fix typeset -L vs. Unicode: snprintf second arg was wrong
@
text
@d57 1
a57 1
static void unsetspec(struct tbl *);
d108 1
a108 1
				unsetspec(vq);
d1057 1
a1057 1
		unsetspec(vp);
d1444 1
a1444 1
unsetspec(struct tbl *vp)
d1469 1
a1469 1
		break;
d1475 1
a1475 1
		break;
d1487 1
a1487 1
		break;
d1494 1
a1494 1
		break;
d1502 6
@


1.224
log
@fix allexport for arrays; add testcase that also catches exporting arrays
@
text
@d710 1
a710 1
			shf_snprintf(p, nlen + 1, "%-*.*s",
@


1.223
log
@some ord() debugging; CORD for case, ORD evaluates twice, for debugging
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.222 2018/01/13 21:38:10 tg Exp $");
d1620 3
@


1.222
log
@implement early (mediæval) locale tracking, as a compile-time option,
for SuSE; slightly inspired by the original patch submitted by
From: Dr. Werner Fink <werner@@suse.de>
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.220 2017/07/26 23:02:28 tg Exp $");
d207 1
a207 1
	if (p != n && ord(*p) == ord('[') && (len = array_ref_len(p))) {
d783 1
a783 1
	if (ord(*val) == ord('[')) {
d806 1
a806 1
	if (ord(val[0]) == ord('=')) {
d812 1
a812 1
	} else if (ord(val[0]) == ord('+') && ord(val[1]) == ord('=')) {
d825 3
a827 3
		if (len > 3 && ord(tvar[len - 3]) == ord('[') &&
		    ord(tvar[len - 2]) == ord('*') &&
		    ord(tvar[len - 1]) == ord(']'))
d864 1
a864 1
		len = (ord(*ccp) == ord('[')) ? array_ref_len(ccp) : 0;
d1074 1
a1074 1
		if (aok && ord(*s) == ord('[') && (alen = array_ref_len(s)))
d1090 1
a1090 1
		if (aok && s[0] == CHAR && ord(s[1]) == ord('[')) {
d1101 1
a1101 1
				if (ord(c) == ord('['))
d1103 1
a1103 1
				else if (ord(c) == ord(']') && --depth == 0) {
d1311 1
a1311 1
				if (*s == ord('\\'))
d1565 2
a1566 2
	while ((c = *s++) && (ord(c) != ord(']') || --depth))
		if (ord(c) == ord('['))
d1638 1
a1638 1
		if (ord(*ccp) == ord('[')) {
d1642 1
a1642 1
				if (ord(*ccp) == ord(']') && --level == 0)
d1644 1
a1644 1
				if (ord(*ccp) == ord('['))
d1648 2
a1649 2
			if (ord(*ccp) == ord(']') && level == 0 &&
			    ord(ccp[1]) == ord('=')) {
@


1.221
log
@move slashifying of PATH, TMPDIR and two OS/2-specific variables from
OS/2-specific to common DOSPATH-specific code (ifdef for the latter two)

also gets us rid of the use of getenv
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013, 2014, 2015, 2016, 2017
d139 1
a139 1
	    /* currently 18 specials: 75% of 32 = 2^5 */
d1389 7
d1495 7
@


1.220
log
@make readonly idempotent; spotted by selk from Dragora
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.213 2017/04/02 16:25:23 tg Exp $");
d1297 21
a1317 1
	int st;
d1319 1
a1319 1
	switch ((st = special(vp->name))) {
@


1.219
log
@sprinkle tons more ord() around

this is really not funny… mksh-ng will use even more “unsigned only”
@
text
@d920 3
a922 3
	 * only allow export flag to be set; AT&T ksh allows any
	 * attribute to be changed which means it can be truncated or
	 * modified (-L/-R/-Z/-i)
d925 1
a925 1
	    (val || clr || (set & ~EXPORT)))
@


1.218
log
@switch EBCDIC to “nega-UTF8”
@
text
@d207 1
a207 1
	if (p != n && *p == '[' && (len = array_ref_len(p))) {
d783 1
a783 1
	if (*val == '[') {
d806 1
a806 1
	if (val[0] == '=') {
d812 1
a812 1
	} else if (val[0] == '+' && val[1] == '=') {
d825 3
a827 2
		if (len > 3 && tvar[len - 3] == '[' && tvar[len - 2] == '*' &&
		    tvar[len - 1] == ']')
d864 1
a864 1
		len = (*ccp == '[') ? array_ref_len(ccp) : 0;
d1074 1
a1074 1
		if (aok && *s == '[' && (alen = array_ref_len(s)))
d1090 1
a1090 1
		if (aok && s[0] == CHAR && s[1] == '[') {
d1101 1
a1101 1
				if (c == '[')
d1103 1
a1103 1
				else if (c == ']' && --depth == 0) {
d1531 2
a1532 2
	while ((c = *s++) && (c != ']' || --depth))
		if (c == '[')
d1604 1
a1604 1
		if (*ccp == '[') {
d1608 1
a1608 1
				if (*ccp == ']' && --level == 0)
d1610 1
a1610 1
				if (*ccp == '[')
d1614 2
a1615 1
			if (*ccp == ']' && level == 0 && ccp[1] == '=') {
@


1.217
log
@use strnul(); optimise
@
text
@d417 3
a419 1
			if (!UTFMODE || ((n & 0xFF80) == 0xEF80))
d421 1
a421 1
				s[2] = n & 0xFF;
d582 1
a582 1
					wc = 0xEF00 + *(const unsigned char *)s;
@


1.216
log
@eliminate legacy macros
@
text
@d467 1
a467 1
			    s <= vq->val.s + strlen(vq->val.s)) {
@


1.215
log
@prepare the new fast character classes, not live yet: need sanity check

unfortunately we need at least 21 or so, maybe 19, classes, so sizing
things down to short is not possible; we can splurge with 32 bit thus
@
text
@d186 1
a186 1
	if (innermost_refflag == SRF_NOP && (p != n) && ksh_isalphx(n[0])) {
d252 1
a252 1
	if (!ksh_isalphx(c)) {
d259 1
a259 1
		if (ksh_isdigit(c)) {
d342 1
a342 1
	if (!ksh_isalphx(*vn)) {
d535 1
a535 1
	} while (ksh_isspace(c));
d552 1
a552 1
		} else if (Flag(FPOSIX) && ksh_isdigit(s[0]) &&
d589 1
a589 1
		if (ksh_isdigit(c))
d591 1
a591 1
		else if (ksh_isupper(c))
d593 1
a593 1
		else if (ksh_islower(c))
d673 1
a673 1
			while (qq > s && ksh_isspace(qq[-1])) {
d703 1
a703 1
			while (ksh_isspace(*s))
d799 1
a799 1
				if (!ksh_isdigit(val[i]))
d848 1
a848 1
			else if (ksh_isdigit(c) && getn(qval, &c))
d1067 1
a1067 1
	if (s && ksh_isalphx(*s)) {
d1070 1
a1070 1
		} while (ksh_isalnux(*s));
d1083 1
a1083 1
	if (s[0] == CHAR && ksh_isalphx(s[1])) {
d1086 1
a1086 1
		} while (s[0] == CHAR && ksh_isalnux(s[1]));
@


1.214
log
@string pooling, and more consistent look for error messages
@
text
@d1310 1
a1310 2
		setctypes(s = str_val(vp), C_IFS);
		ifs0 = *s;
d1438 1
a1438 2
		setctypes(TC_IFSWS, C_IFS);
		ifs0 = ' ';
@


1.213
log
@fix typeset -p x[2]
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.196 2016/01/14 20:21:39 tg Exp $");
d1362 1
a1362 1
				errorf(Tf_sD_sD_s, vp->name, "bad number", s);
d1920 1
a1920 1
		bi_errorf(Tf_sD_s, "bad number", fieldstr);
@


1.212
log
@refactor global(x) into isglobal(x, true)
@
text
@d48 1
a48 1
static void c_typeset_vardump(struct tbl *, uint32_t, int, bool, bool);
d2035 3
a2037 2
			varsearch(e->loc, &vp, wp[i], hash(wp[i]));
			c_typeset_vardump(vp, flag, thing, pflag, istset);
d2054 1
a2054 1
		c_typeset_vardump(vp, flag, thing, pflag, istset);
d2059 2
a2060 2
c_typeset_vardump(struct tbl *vp, uint32_t flag, int thing, bool pflag,
    bool istset)
a2062 1
	int any_set = 0;
d2074 1
a2074 1
			any_set = 1;
d2162 1
a2162 1
	} while ((vp = vp->u.array));
@


1.211
log
@move c_typeset() to var.c so we have access to either array_index_calc() or innermost_refflag for 'typeset -p x[2]'
@
text
@d231 7
d304 4
d311 5
a315 1
		goto out;
a316 6
	vp = ktenter(&l->vars, vn, h);
	if (array)
		vp = arraysearch(vp, val);
	vp->flag |= DEFINED;
	if (special(vn))
		vp->flag |= SPECIAL;
@


1.210
log
@small character classes overhaul:
• make fast character classes even faster by removing the C_SUBOP2 hack
  in favour of a separate seldom-used ksh_issubop2 macro (which also
  makes ctype() side-effect-safe) which is a slower class (no change there)
• optimise cases of ksh_isalphx followed by a ksh_isalnux loop
  (used parsing variable names)
• remove a misleading comment in initctypes() about \0 from pdksh
• rename C_ALPHA to C_ALPHX to make it more clear the underscore is included
• sprinkle a few ord() in there
• add new ksh_isalpha() which tests for [A-Za-z] (slow character class)
• there is no '_:\' drive on OS/2 (which inspired the whole changeset)
@
text
@d48 3
d1777 378
@


1.209
log
@collective R54 release preparation multi-merger:

install both lksh and mksh manpages from Build.sh (Martijn Dekker)
spelling fixes (Larry Hynes)
manpage improvements (Martijn Dekker)
initial port to Harvey-OS’ APEX (Ronald G. Minnich, Elbing Miss, Álvaro Jurado)
more from komh’s OS/2 port (KO Myung-Hun)
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013, 2014, 2015, 2016
d1056 3
a1058 2
		while (*++s && ksh_isalnux(*s))
			;
@


1.208
log
@avoid even the chance at UB, it’s too risky with “postmodern” compilers
@
text
@d136 1
a136 1
	    /* currently 15 specials: 75% of 32 = 2^5 */
d1152 7
d1284 7
d1413 7
@


1.207
log
@implement $KSH_MATCH and, to make it usable, ${foo@@/bar/baz};
add a real-life example (for slagtc’s programmable tab completion)
to the manpage
@
text
@d1689 1
a1689 2
#ifdef DEBUG
	/* clear the allocated space, for valgrind */
a1690 1
#endif
@


1.206
log
@oops…
@
text
@d1742 12
@


1.205
log
@make tmux hack workable for now (libtermcap is… ugly)

• track $TERM for the types tmux uses /^screen(-.*)?$/
• when tmux is in use (or GNU screen, really), use the, now
  hardcoded, clear-to-EOL string; otherwise, use the old behaviour
• drop unnecessary x_e_rebuildline()

carefully tested to behave no worse than R52b
@
text
@d1293 1
d1297 1
d1414 1
d1418 1
@


1.204
log
@rework string pooling; disable our own (rely on compiler’s)…
• if HAVE_STRING_POOLING is set to 1
• if HAVE_STRING_POOLING is set to 2 and not GCC < 4 is used
• if HAVE_STRING_POOLING is not set to 0 and LLVM or GCC >= 4 is used

Closes: LP#1580348
@
text
@d136 1
a136 1
	    /* currently 14 specials: 75% of 32 = 2^5 */
d1293 3
d1412 3
@


1.203
log
@move MIN_{COL,LIN}S here, only user left (edit.c has its own sanity checks)
and lower them (no need to respect edit.c’s, this is only sanity against OS)
@
text
@d196 1
a196 1
			cp = shf_smprintf("%s%s", str_val(vp), p);
d252 1
a252 1
				shf_snprintf(vp->name, 12, "%d", c);
d444 1
a444 1
		warningf(true, "read-only: %s", vq->name);
d771 1
a771 1
			errorf("%s: %s", var,
d847 1
a847 1
			errorf("%s: %s", var, "empty nameref target");
d856 1
a856 1
			errorf("%s: %s", qval,
d863 1
a863 1
				errorf("%s: %s", qval,
d873 3
a875 3
	if (Flag(FRESTRICTED) && (strcmp(tvar, "PATH") == 0 ||
	    strcmp(tvar, "ENV") == 0 || strcmp(tvar, "SHELL") == 0))
		errorf("%s: %s", tvar, "restricted");
d912 1
a912 1
		errorfx(2, "read-only: %s", tvar);
d985 1
a985 1
			tval = shf_smprintf("%s%s", str_val(vp), val);
d1330 1
a1330 1
				errorf("%s: %s: %s", vp->name, "bad number", s);
d1534 1
a1534 1
		errorfx(2, "read-only: %s", ccp);
@


1.202
log
@fix utf_widthadj/utf_skipcols handling for the remaining cases I can spot
@
text
@d1189 4
@


1.201
log
@collapse if, also to avoid braces warning
@
text
@d652 1
a652 1
		int slen = olen, i = 0;
d655 1
a655 1
			const char *qq = s;
d658 2
a659 2
			while (i < slen)
				i += utf_widthadj(qq, &qq);
@


1.200
log
@don’t read past buffer for empty nameref targets (fmunozs, Valgrind)
@
text
@d836 2
a837 3
			else if (ksh_isdigit(c))
				if (getn(qval, &c))
					goto nameref_rhs_checked;
@


1.199
log
@plug a few display problems with special parameter name expansions
reported by Stéphane Chazelas
@
text
@d832 1
a832 2
			if (ksh_isdigit(qval[0])) {
				int c;
d834 3
d839 1
a839 1
			} else if (qval[1] == '\0') switch (qval[0]) {
@


1.198
log
@save 200 bytes off .text by revisiting string pooling

also, forgotten version bump
@
text
@d245 1
a245 1
		vp = &vtemp;
a248 1
		*vp->name = c;
d250 10
a259 3
			if (getn(vn, &c) && (c <= l->argc))
				/* setstr can't fail here */
				setstr(vp, l->argv[c], KSH_RETURN_ERROR);
d263 2
d331 1
a331 1
		vp = &vtemp;
d490 4
a493 5
		struct tbl *vp = &vtemp;
		vp->flag = (ISSET|INTEGER);
		vp->type = 0;
		vp->areap = ATEMP;
		vp->val.i = n;
d495 1
a495 1
		setstr(vq, str_val(vp), KSH_RETURN_ERROR);
@


1.197
log
@permit 'read -A/-a arr[idx]' as long as only one element is read;
fix corruption of array indicēs with this construct (LP#1533396)
@
text
@d244 1
a244 1
			errorf("bad substitution");
@


1.196
log
@leak less memory
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.183 2014/10/04 11:47:19 tg Exp $");
d298 1
d349 1
d1491 1
a1491 1
	if ((p = cstrchr(str, '[')) == 0)
@


1.195
log
@partial oksh sync, up to commit 80be547da108d5c241ae068290ca3e331446aa41?
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013, 2014, 2015
d221 1
d228 2
a230 1
	struct tbl *vp;
d239 3
a241 3
	n = array_index_calc(n, &array, &val);
	h = hash(n);
	c = (unsigned char)n[0];
d251 1
a251 1
			if (getn(n, &c) && (c <= l->argc))
d255 1
a255 1
			return (vp);
d258 2
a259 2
		if (n[1] != '\0')
			return (vp);
d283 7
a289 1
		return (vp);
d291 1
a291 4
	l = varsearch(e->loc, &vp, n, h);
	if (vp != NULL)
		return (array ? arraysearch(vp, val) : vp);
	vp = ktenter(&l->vars, n, h);
d295 1
a295 1
	if (special(n))
d297 3
d309 2
a311 1
	struct tbl *vp;
d319 3
a321 3
	n = array_index_calc(n, &array, &val);
	h = hash(n);
	if (!ksh_isalphx(*n)) {
d326 1
a326 1
		return (vp);
d328 1
a328 1
	vp = ktenter(&l->vars, n, h);
d332 1
a332 1
		varsearch(l->next, &vq, n, h);
d345 1
a345 1
	if (special(n))
d347 3
d352 1
@


1.194
log
@oksh sync, simplify *all* if(x)free(x); constructs, simplify x_push() and sync boilerplate while here
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.43 2015/09/01 13:12:31 tedu Exp $	*/
d6 1
a6 1
 *	mirabilos <tg@@mirbsd.org>
@


1.193
log
@merge OS/2 style PATH (absolute with drive letters, ‘;’ as separator)

From: KO Myung-Hun <komh@@chollian.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.41 2015/04/17 17:20:41 deraadt Exp $	*/
d6 1
a6 1
 *	Thorsten Glaser <tg@@mirbsd.org>
d713 1
a713 2
	if (op != NULL)
		afree(op, vp->areap);
d951 1
a951 2
				if (free_me)
					afree(free_me, t->areap);
d977 1
a977 2
		if (tval != NULL)
			afree(tval, ATEMP);
d1260 1
a1260 2
		if (path)
			afree(path, APERM);
d1267 2
a1268 4
		if (tmpdir) {
			afree(tmpdir, APERM);
			tmpdir = NULL;
		}
d1377 1
a1377 2
		if (path)
			afree(path, APERM);
@


1.192
log
@more low-hanging fruits for EBCDIC; notes:

• ord() new, From: Daniel Richard G. <skunk@@iSKUNK.ORG>
  ‣ used in some places
• (c - '0') → ksh_numdig(c)	# may take *x++ argument
• (c - 'A') → ksh_numuc(c)	# may NOT take *x+= argument
  ‣ idem for ksh_numlc(c) and 'a'
  ‣ these need changing for EBCDIC
  ‣ add testsuite for this
• use macros more, they exist already often
• use digits_lc[foo] instead of ('0' + foo), especially for letters
• caught another ksh_eq case…
• also caught a maybe-UB overflow check, but we don’t have TIME_T_MAX ☹
@
text
@d1284 1
a1284 1
			if (s[0] == '/' && access(s, W_OK|X_OK) == 0 &&
@


1.191
log
@EBCDIC helpers and OS/390 signals
@
text
@d556 1
a556 1
			c -= '0';
d558 1
a558 1
			c -= 'A' - 10;
d560 1
a560 1
			c -= 'a' - 10;
@


1.190
log
@ordinarily, lineno must be mksh_uari_t, but edit.c most of all isn’t ready,
so we mitigate a bit (in var.c mostly) and tweak another type already, and
add some checks (mksh_{,u}ari_t must fit into {,unsigned }long) and print
line numbers with %lu already
@
text
@d513 1
a513 1
		if ((s[0] | 0x20) == 'x') {
d557 3
a559 4
		else {
			c |= 0x20;
			if (!ksh_islower(c))
				return (-1);
d561 2
a562 1
		}
@


1.189
log
@make var.c:getint() more like misc.c:getn(), except for the API differences:
getn() parses a decimal 32-bit integer, getint() a POSIX- or ksh-style based
integer with unsigned wraparound to 32 bit, then possible negation (so that,
for example, -0xFFFFFFFF continues to work)
@
text
@d1167 1
a1167 1
static int user_lineno;		/* what user set $LINENO to */
d1201 1
a1201 1
		num.i = current_lineno + user_lineno;
d1331 1
a1331 1
		user_lineno = num.u - current_lineno - 1;
@


1.188
log
@irrelevant oksh RCSID sync: we already use getint, and our $COLUMNS differs a bit anyway
@
text
@d484 1
a484 1
	mksh_uari_t c, num, base;
d488 1
a488 1
	if (vp->flag&SPECIAL)
d491 1
a491 1
	if (!(vp->flag&ISSET) || (!(vp->flag&INTEGER) && vp->val.s == NULL))
d493 1
a493 1
	if (vp->flag&INTEGER) {
d498 33
a530 18
	base = 10;
	num = 0;
	if (arith && s[0] == '0' && (s[1] | 0x20) == 'x') {
		s += 2;
		base = 16;
		have_base = true;
	}
	if (Flag(FPOSIX) && arith && s[0] == '0' && ksh_isdigit(s[1]) &&
	    !(vp->flag & ZEROFIL)) {
		/* interpret as octal (deprecated) */
		base = 8;
		have_base = true;
	}
	while ((c = (unsigned char)*s++)) {
		if (c == '-') {
			neg = true;
			continue;
		} else if (c == '#') {
d534 1
d554 2
a555 1
		} else if (ksh_isdigit(c))
d557 4
a560 1
		else if (ksh_islower(c))
d562 1
a562 4
		else if (ksh_isupper(c))
			c -= 'A' - 10;
		else
			return (-1);
d565 1
d567 2
a568 1
	}
@


1.187
log
@SECURITY: make “unset HISTFILE” really work

additionally, make “HISTFILE=” the same, document the truncation and
re-reading process’ further and already-known bugs; this needs work
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.40 2014/12/12 05:00:55 jsg Exp $	*/
@


1.186
log
@add getopts for exec (unbreaks “exec -- /bin/ls”) and steal -a and -c from ksh93
@
text
@d1354 5
@


1.185
log
@OpenBSD RCSID merge, and logical follow one change:
handle unknown bases as ksh93 does: larger downgrade to 10
(although our max will stay 36, as ksh93 doesn’t have upper/lowecase)
and smaller downgrade for typeset -i, but not for arithmetics
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013, 2014
d1115 2
@


1.184
log
@• Build.sh: fix NSIG detection for gcc-snapshot
• all: bump version to R50-current; add more comments; whitespace
• all: remove all mkssert(); we’ll do full re-runs of scan-build and,
  hopefully, Coverity Scan/Prevent
• check.t: fix a testcase (sed could exit false, but we don’t care)
• eval.c: fix tilde_ok data type (only unsigned may shl constantly)
• exec.c: fix shebang buf array accesses to always go via uint8_t *
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.38 2013/12/20 17:53:09 zhuk Exp $	*/
d516 1
a516 1
			if (have_base || num < 1 || num > 36)
d533 2
a534 1
			}
@


1.183
log
@fix null pointer deref on empty nameref assignment (no ‘=’)
found by Goodbox on IRC
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.182 2014/10/03 17:20:03 tg Exp $");
a310 1
	mkssert(n != NULL);
a680 2
	mkssert(val != NULL);

@


1.183.2.1
log
@MFC:
• portability improvements and bugfixes (ptrdiff_t → size_t,
  newer GCC, older GNU bash, no printf(1) use in testsuite,
  rename tilde function, setugid ordering)
• drop old/useless asserts
• manpage fixes
• missing brace in syn.c
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.183 2014/10/04 11:47:19 tg Exp $");
d311 1
d682 2
@


1.183.2.2
log
@MFC everything except the igli-inspired changes to jobs.c and the
.Ox Ns -inspired integer base changes .
That means: bugfixes, plus the new arguments to exec (feature)
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013, 2014, 2015
d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.183.2.1 2015/01/25 15:35:54 tg Exp $");
a1113 2
		if (l->flags & BF_STOPENV)
			break;
@


1.183.2.3
log
@MFC most of mksh-current into R50-stable:
• alias protection of local=\typeset
• use of “command -v” in dot.mkshrc
• oksh RCSID sync, where appropriate
• fix “read -n-1”
• SECURITY (privacy): make “unset HISTFILE” work
• strip_nuls() rewrite
• manpage fixes and improvements and replacement hook
• dead constant elimination
remaining differences:
• integer-base interpretation change
• default alias protection
• dot.mkshrc “enable” support
• j_waitj() refactoring
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.183.2.2 2015/03/01 15:43:07 tg Exp $");
a1352 5
#if HAVE_PERSISTENT_HISTORY
	case V_HISTFILE:
		sethistfile(NULL);
		return;
#endif
@


1.183.2.4
log
@MFC remaining fixes; tested locally a lot, plus remotely with
GNU C11 (Debian 20150413-1) version 5.0.1 20150413 (prerelease) [gcc-5-branch revision 222050] (x86_64-linux-gnu)
including ASan (testsuite) and Valgrind (short)
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.183.2.3 2015/03/20 22:21:10 tg Exp $");
d484 1
a484 1
	mksh_uari_t c, num = 0, base = 10;
d488 1
a488 1
	if (vp->flag & SPECIAL)
d491 1
a491 1
	if (!(vp->flag & ISSET) || (!(vp->flag & INTEGER) && vp->val.s == NULL))
d493 1
a493 1
	if (vp->flag & INTEGER) {
d498 19
a516 34

	do {
		c = (unsigned char)*s++;
	} while (ksh_isspace(c));

	switch (c) {
	case '-':
		neg = true;
		/* FALLTHROUGH */
	case '+':
		c = (unsigned char)*s++;
		break;
	}

	if (c == '0' && arith) {
		if ((s[0] | 0x20) == 'x') {
			/* interpret as hexadecimal */
			base = 16;
			++s;
			goto getint_c_style_base;
		} else if (Flag(FPOSIX) && ksh_isdigit(s[0]) &&
		    !(vp->flag & ZEROFIL)) {
			/* interpret as octal (deprecated) */
			base = 8;
 getint_c_style_base:
			have_base = true;
			c = (unsigned char)*s++;
		}
	}

	do {
		if (c == '#') {
			/* ksh-style base determination */
			if (have_base || num < 1)
a518 1
				/* mksh-specific extension */
d533 1
a533 2
			} else if (base > 36)
				return (-1);
d537 1
a537 2
		}
		if (ksh_isdigit(c))
d539 1
a539 4
		else {
			c |= 0x20;
			if (!ksh_islower(c))
				return (-1);
d541 4
a544 1
		}
a546 1
		/* handle overflow as truncation */
d548 1
a548 2
	} while ((c = (unsigned char)*s++));

d1147 1
a1147 1
static mksh_uari_t user_lineno;	/* what user set $LINENO to */
d1181 1
a1181 1
		num.u = (mksh_uari_t)current_lineno + user_lineno;
d1311 1
a1311 1
		user_lineno = num.u - (mksh_uari_t)current_lineno - 1;
@


1.182
log
@SECURITY: do not permit += from environment either
this makes our environment filter/sanitisation complete
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.181 2014/09/03 19:22:51 tg Exp $");
d787 3
a789 2
			if (vp != NULL)
				qval = str_val(vp);
d807 1
@


1.181
log
@permit $1, $!, etc. to be nameref’d again ($_ was); spotted by Jb_boin, 10x!
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.180 2014/06/26 20:36:02 tg Exp $");
d754 1
a754 1
	if (val[0] == '=' || (val[0] == '+' && val[1] == '=')) {
d756 10
a765 10
		if (*val++ == '+') {
			++val;
			vappend = true;
		}
	} else if ((val[0] != '\0') || (set & IMPORT)) {
		/*
		 * must have a = when setting a variable by importing
		 * the original environment, otherwise be empty; we
		 * also end up here when a variable name was invalid
		 */
@


1.180
log
@shut up valgrind in the RAND_add() code… sounds familiar…
I’m committing this from a Debian system… but fear not…
I know what I am doing…
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.179 2014/06/09 11:13:19 tg Exp $");
d792 14
a805 1
		if (ccp == qval)
d807 1
d818 1
@


1.179
log
@SYNTAX CHANGE: remove x=([2]=foo [5]=bar) due to regressions
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.178 2014/05/27 13:22:46 tg Exp $");
d1618 5
@


1.178
log
@fix LP#1277691 (“nameref RHS not syntax checked”) and the inability to
use errorf() while nameref states were being changed (by almost completely
eliminating the global variable) and the readonly first array variable
bypass (typo/refactoro); also, whitespace, one int → bool, and add a
comment wrt. the parser rewrite talked about with igli during a fever ;)
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.177 2014/01/11 18:09:43 tg Exp $");
d1497 1
d1518 1
@


1.177
log
@• use BAFH for hash ipv NZAAT
• prep for release
• fix minor nits in manpage and tests
@
text
@d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.176 2014/01/05 21:57:29 tg Exp $");
d45 2
d170 2
a171 1
 * the basename of the array.
d183 1
a183 1
	if (set_refflag == SRF_NOP && (p != n) && ksh_isalphx(n[0])) {
d191 2
a192 2
		if (vp && (vp->flag & (DEFINED|ASSOC|ARRAY)) ==
		    (DEFINED|ASSOC)) {
d202 1
d233 4
a236 1
	/* Check to see if this is an array */
d306 4
a309 1
	/* check to see if this is an array */
d714 10
d732 1
a732 1
		if (set_refflag != SRF_NOP)
d778 2
a779 2
	if (set_refflag == SRF_ENABLE) {
		const char *qval;
d783 1
a783 1
			errorfz();
d790 14
d811 1
a811 1
			if (vp && ((vp->flag & (ARRAY|ASSOC)) == ASSOC))
d821 2
a822 1
	vp = (set&LOCAL) ? local(tvar, tobool(set & LOCAL_COPY)) :
d824 1
a824 1
	if (set_refflag == SRF_DISABLE && (vp->flag & (ARRAY|ASSOC)) == ASSOC)
d826 1
a826 1
	else if (set_refflag == SRF_ENABLE) {
d846 1
a846 1
	vpbase = (vp->flag & ARRAY) ? global(arrayname(var)) : vp;
d853 1
a853 1
	if ((vpbase->flag&RDONLY) &&
d997 1
a997 1
skip_varname(const char *s, int aok)
d1375 1
a1375 1
	vp->flag = (vp->flag | (ARRAY|DEFINED)) & ~ASSOC;
d1415 2
@


1.176
log
@• fix ${12345678901234567890} segfault (OOB access / integer overflow)
  ‣ not like oksh did, but using mksh’s built-in features
• handle suggested __pure additions
• revert cid 1004F7F096867C83CF0
  ‣ always use our wcwidth code
  ‣ only use our strlcpy code if none found
• fix a couple of gcc-snapshot and clang/scan-build warnings
• mksh R49~rc1
@
text
@d25 1
d31 1
a31 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.173 2013/05/31 22:47:14 tg Exp $");
d44 1
a44 1
static uint32_t lcg_state = 5381;
d1494 5
d1529 22
a1550 3
	NZATInit(h);
	NZATUpdateString(h, s);
	NZAATFinish(h);
d1568 19
a1586 4

	NZATInit(h);
	NZATUpdateMem(h, &lcg_state, sizeof(lcg_state));
	NZATUpdateMem(h, &v, sizeof(v));
d1589 4
d1598 4
a1601 2
	lcg_state = h;
	NZAATFinish(lcg_state);
d1608 3
a1610 1
	NZATUpdateMem(h, &lcg_state, sizeof(lcg_state));
d1613 2
a1614 1
	NZAATFinish(h);
d1617 10
@


1.175
log
@oksh bumped array indicēs again, INT_MAX this time, still less than mksh…
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.37 2013/12/18 13:53:12 millert Exp $	*/
d241 1
a241 3
			for (c = 0; ksh_isdigit(*n); n++)
				c = (c * 10) + (*n - '0');
			if (c <= l->argc)
@


1.174
log
@merge oksh’s “ctype cleanups” commit

(not much of it applies since we don’t use the OS’ table-based lookup)
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.36 2013/12/17 16:37:06 deraadt Exp $	*/
@


1.173
log
@prevent indirect recursion loops for namerefs; found by ormaaj, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.35 2013/04/05 01:31:30 tedu Exp $	*/
d5 1
a5 1
 *		 2011, 2012, 2013
d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.172 2013/05/02 20:23:09 tg Exp $");
d231 1
a231 1
	c = n[0];
d242 1
a242 1
				c = c*10 + *n-'0';
d503 1
a503 1
	while ((c = *s++)) {
@


1.172
log
@more int → unsigned
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.171 2013/04/27 18:50:25 tg Exp $");
d771 9
a779 4
		/* silently ignore 'nameref foo=foo' */
		if (qval != NULL && !strcmp(qval, tvar)) {
			afree(tvar, ATEMP);
			return (&vtemp);
@


1.171
log
@after enough complaints by POSIX sh advocates,
• make parsing numbers with leading digit-zero as octal independent of
  mksh/lksh and dependent on set -o posix; adjust manpages to match
• warn about these changes and why mksh uses 32-bit consistent arithmetics
  and point people to lksh for host-long undefined-behaviour arithmetics
• point out, explicitly, that it is *legal* for the operating environment
  to make 'print $((2147483647 + 1))' (on a 32-bit system; adjust for a
  64-bit system) to run 'rm -rf ~ /' instead
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.170 2013/04/07 14:11:54 tg Exp $");
d350 1
a350 1
		int base;
d364 2
a365 2
			n = (vp->val.i < 0) ? -vp->val.i : vp->val.i;
		base = (vp->type == 0) ? 10 : vp->type;
d476 1
a476 2
	int c, base;
	mksh_uari_t num;
d510 1
a510 2
			base = (int)num;
			if (base == 1) {
d537 1
a537 1
		if (c < 0 || c >= base)
@


1.170
log
@just rcsid-sync oksh; their change was to add /* XXX 2038 */ comment
to $SECONDS (tbh, in 2038 we’ll have more problems than just that,
which is why 64-bit arithmetics, or unlimited-precision ones, are
on the “plans” list)
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.169 2013/04/01 02:37:53 tg Exp $");
d498 1
a498 2
#ifdef MKSH_LEGACY_MODE
	if (arith && s[0] == '0' && ksh_isdigit(s[1]) &&
a503 1
#endif
@


1.169
log
@one can’t cast an unsigned int to a signed int portably either, if the value
is larger than the positive range of the latter (implementation-defined), so
avoid them in all explicit cases and rearrange stuff and check for it

(I’m gonna have to revise lots more code…)
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.34 2007/10/15 02:16:35 deraadt Exp $	*/
d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.168 2013/03/31 18:30:05 tg Exp $");
@


1.168
log
@fix bug in comment
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.167 2013/03/30 15:39:26 tg Exp $");
d52 1
a52 1
static int getint(struct tbl *, mksh_ari_t *, bool);
d474 1
a474 1
getint(struct tbl *vp, mksh_ari_t *nump, bool arith)
d476 1
a476 1
	int c, base, neg;
d479 1
a479 1
	bool have_base = false;
d487 1
a487 1
		*nump = vp->val.i;
a492 1
	neg = 0;
d508 1
a508 1
			neg++;
d527 1
a527 1
				*nump = (mksh_ari_t)wc;
d545 3
a547 1
	*nump = neg ? -((mksh_ari_t)num) : (mksh_ari_t)num;
d559 1
a559 1
	mksh_ari_t num;
d563 1
a563 1
	setint_n(vq, num, 0);
d1101 1
a1101 1
	register mksh_ari_t i;
d1121 1
a1121 1
		i = (mksh_ari_t)procpid;
d1124 1
a1124 1
		i = x_cols;
d1127 1
a1127 1
		i = histsize;
d1130 1
a1130 1
		i = current_lineno + user_lineno;
d1133 1
a1133 1
		i = x_lins;
d1148 1
a1148 1
		i = user_opt.uoptind;
d1151 1
a1151 1
		i = rndget();
d1161 1
a1161 1
			i = tv.tv_sec - seconds;
d1170 1
a1170 1
	setint_n(vp, i, 0);
d1177 1
a1177 1
	mksh_ari_t i;
d1235 1
a1235 1
		if (getint(vp, &i, false) == -1) {
d1239 1
a1239 1
			i = hash(s);
d1252 2
a1253 2
		if (i >= MIN_COLS)
			x_cols = i;
d1256 1
a1256 1
		sethistsize(i);
d1260 1
a1260 1
		user_lineno = (unsigned int)i - current_lineno - 1;
d1263 2
a1264 2
		if (i >= MIN_LINS)
			x_lins = i;
d1267 1
a1267 1
		getopts_reset((int)i);
d1274 1
a1274 1
		rndset((long)i);
d1281 1
a1281 1
			seconds = tv.tv_sec - i;
d1285 1
a1285 1
		ksh_tmout = i >= 0 ? i : 0;
d1541 1
a1541 1
rndset(long v)
@


1.167
log
@catch missing variable names in typeset, to avoid confusing Hugues Moretto-Viry with bogus “read-only” messages
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.166 2013/02/18 22:24:52 tg Exp $");
d483 1
a483 1
	/* XXX is it possible for ISSET to be set and val.s to be 0? */
@


1.166
log
@fix an oversight that allowed invalid variable names to be entered
(not even at an increase in code, as I could just move a check and
slightly adapt it)
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.165 2012/12/08 18:30:31 tg Exp $");
d711 4
a748 1
		 * or none given
@


1.165
log
@add a few assertions for LLVM+Clang 3.2 scan-build; no !DEBUG changes
@
text
@d5 1
a5 1
 *		 2011, 2012
d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.164 2012/12/04 01:18:34 tg Exp $");
a710 2
	if (val == var)
		return (NULL);
d740 8
d749 1
a749 3
		/* importing from original environment: must have an = */
		if (set & IMPORT)
			return (NULL);
@


1.164
log
@Add assertions and shuffle code around for LLVM+Clang scan-build.
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.162 2012/12/01 01:36:30 tg Exp $");
d676 2
@


1.163
log
@Be more careful with string array bounds! Found by LLVM+Clang scan-build.
@
text
@d302 1
@


1.162
log
@remove *all* nonnull assertions and other workarounds for clang scan-build

this beast evolved in the last 2½ years, and we’ve had trouble with
some of them earlier
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.161 2012/11/30 19:25:08 tg Exp $");
d618 2
d624 1
@


1.161
log
@implement tty tracking and bump to R41 for feature completeness

• tty_fd is now never closed
• new tty_hasstate tracks tty_state (cf. thread around
  http://article.gmane.org/gmane.os.miros.mksh/79 and PLD bug)
• as users requested, importing COLUMNS or LINES from the environment
  now removes its special-ness as does unsetting it
• otherwise, setting COLUMNS or LINES is honoured until the next SIGWINCH
  arrives or change_winsz is otherwise run (e.g. before displaying the
  prompt in the interactive command line editing modes)
• SIGWINCH is now honoured before each reading of $COLUMNS and $LINES too
• change the Uhr to match – it no longer calls stty(1) ☺
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.159 2012/11/26 22:49:50 tg Exp $");
a706 1
	mkssert(var != NULL);
@


1.161.2.1
log
@MFC the LLVM+Clang scan-build fixes: cid 10050B95F03690E9DEE 10050BD4DA30C3ED2E7 10050BD4DCC1620D535 10050BD4E043FF1DB7C 10050BD4F7642624FD1
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.161 2012/11/30 19:25:08 tg Exp $");
a301 1
	mkssert(n != NULL);
a617 2
				if (!s[0] || !s[1])
					goto uhm_no;
a621 1
 uhm_no:
d707 1
@


1.161.2.2
log
@reduce diff against mksh-R41

http://thread.gmane.org/gmane.comp.version-control.bazaar-ng.general/74809
learned me to release more often again, so I’m keeping the bugfixes here
to a minimum and will instead release an R42 more quickly with those fixes
harder to backport or less necessary (such as ports to ancient Unicēs)
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.161.2.1 2012/12/04 01:26:36 tg Exp $");
d302 1
@


1.160
log
@use proper parenthesēs; int → bool; use same var (eno) for temp. errno
@
text
@a1092 3
	case V_BASHPID:
		i = (mksh_ari_t)procpid;
		break;
d1094 1
d1102 9
d1207 8
a1216 1
	case V_LINES:
d1483 1
a1483 1
	if (tty_fd >= 0) {
@


1.159
log
@use EPOCHREALTIME as variable, somewhat compatible with “zmodload zsh/datetime”, as ormaaj belatedly found out
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.158 2012/11/20 18:07:45 tg Exp $");
d408 1
a408 1
	int no_ro_check = error_ok & 0x4;
@


1.158
log
@add MKSH_UNIXTIME
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.154 2012/10/21 21:39:06 tg Exp $");
d1115 1
a1115 1
	case V_MKSH_UNIXTIME: {
@


1.157
log
@make more internal consistency checks #ifndef MKSH_SMALL
@
text
@d133 1
a133 1
	    /* currently 13 specials: 75% of 32 = 2^5 */
d1090 1
d1115 12
a1139 2
			struct timeval tv;

@


1.156
log
@introduce $BASHPID for ormaaj from #ksh
@
text
@d420 1
d423 1
a423 1
			    s <= vq->val.s + strlen(vq->val.s))
d427 2
@


1.155
log
@sort
@
text
@d133 2
a134 2
	    /* currently 12 specials: 75% of 16 = 2^4 */
	    4);
d1089 3
@


1.154
log
@add some bounds, for a subsequent commit:
• all writers of exstat ensure the value is in [0; 0xFF]
• all readers of exstat AND it with 0xFF (not strictly needed thus)
• trap_exstat is “safe”, i.e. always either -1 or [0; 0xFF]
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.153 2012/07/30 21:37:17 tg Exp $");
d1089 25
a1127 23
	case V_RANDOM:
		i = rndget();
		break;
	case V_HISTSIZE:
		i = histsize;
		break;
	case V_OPTIND:
		i = user_opt.uoptind;
		break;
	case V_LINENO:
		i = current_lineno + user_lineno;
		break;
	case V_COLUMNS:
	case V_LINES:
		/*
		 * Do NOT export COLUMNS/LINES. Many applications
		 * check COLUMNS/LINES before checking ws.ws_col/row,
		 * so if the app is started with C/L in the environ
		 * and the window is then resized, the app won't
		 * see the change cause the environ doesn't change.
		 */
		i = st == V_COLUMNS ? x_cols : x_lins;
		break;
d1145 9
a1161 4
	case V_IFS:
		setctypes(s = str_val(vp), C_IFS);
		ifs0 = *s;
		return;
a1180 6
#if HAVE_PERSISTENT_HISTORY
	case V_HISTFILE:
		sethistfile(str_val(vp));
		return;
#endif

d1182 1
a1182 1
	case V_OPTIND:
d1184 1
a1184 1
	case V_COLUMNS:
d1186 1
a1188 1
	case V_LINENO:
d1207 3
a1209 2
	case V_OPTIND:
		getopts_reset((int)i);
d1214 3
a1216 3
	case V_COLUMNS:
		if (i >= MIN_COLS)
			x_cols = i;
d1222 3
a1239 4
	case V_LINENO:
		/* The -1 is because line numbering starts at 1. */
		user_lineno = (unsigned int)i - current_lineno - 1;
		break;
d1249 8
d1258 4
a1268 4
	case V_IFS:
		setctypes(TC_IFSWS, C_IFS);
		ifs0 = ' ';
		break;
a1282 8

	/*
	 * AT&T ksh man page says OPTIND, OPTARG and _ lose special
	 * meaning, but OPTARG does not (still set by getopts) and _ is
	 * also still set in various places. Don't know what AT&T does
	 * for HISTSIZE, HISTFILE. Unsetting these in AT&T ksh does not
	 * loose the 'specialness': IFS, COLUMNS, PATH, TMPDIR
	 */
@


1.153
log
@implement ksh93 feature ${ foo;}
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.152 2012/07/01 15:38:09 tg Exp $");
d263 1
a263 1
			vp->val.i = exstat;
@


1.152
log
@dissolve the hashtab nonsense, ¾ is good, and mirkev will also use that
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.151 2012/06/28 20:02:29 tg Exp $");
d1257 1
a1257 1
		setctypes(" \t\n", C_IFS);
@


1.151
log
@make tempvar() and vtemp global
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.150 2012/06/25 16:31:18 tg Exp $");
d77 2
a78 2
	ktinit(&l->area, &l->vars, 0, 0);
	ktinit(&l->area, &l->funs, 0, 0);
d133 2
a134 2
	    /* currently 12 specials */
	    /* 80% of 16 = 2^4 */ 4, /* 66% of 32 = 2^5 */ 5);
@


1.151.2.1
log
@backport bugfixes for error handling related issues (set -e, traps)
and a few important improvements in the testsuite

Debian #696823, LP#1104543, RedHat BZ#865121
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.151 2012/06/28 20:02:29 tg Exp $");
d263 1
a263 1
			vp->val.i = exstat & 0xFF;
@


1.150
log
@also get back octal crap for LEGACY KSH
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.149 2012/05/09 23:21:00 tg Exp $");
a41 1
static struct tbl vtemp;
@


1.149
log
@Fix typeset issues (LP: #993847)

This was actually more evil:
• use a recursive function to display blocks in reverse order,
  so that local variable values overwrite global ones
• add array support to typeset -p (from typeset -p -)
• display 'set -A varname' line before setting values, for -p
• if -p got arguments, only display those (from the innermost scope)

Also, the usual amount of code cleanup…
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.148 2012/05/04 21:47:04 tg Exp $");
d496 8
@


1.148
log
@provide for Coherent not having gettimeofday(2), imake style (bad, but this is not for others to use without a second thought anyway)
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.147 2012/04/22 21:50:35 tg Exp $");
d144 2
a145 2
/* common code for several functions below */
static struct block *
@


1.147
log
@after discussion with ciruZ, switch mksh from NZAT to NZAAT fully
to get rid of the bias introduced by making the hash never zero

… he also pointed out a memory (heap) usage optimisation… which
may impact code size a bit though as I’d need to pass an additional
argument on hashtable function calls… or, forgo the benefit of not
having to pointer-align the key in the structure, which can be as
much as 3/7 octets per item, heap storage… OTOH the saved space is
4/8 octets per not-allocated item, possibly some code (use of an
multiply-add opcode), but the function call overhead/cost would
possibly be quite a bit… I guess I’ll have to measure…
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.146 2012/04/14 14:35:13 tg Exp $");
d1091 1
a1091 1
			gettimeofday(&tv, NULL);
d1224 1
a1224 1
			gettimeofday(&tv, NULL);
@


1.146
log
@factor out rndget() code, for adding users

XXX in the future, the entire scheme must be rethinked when we need more
XXX entropy for the hash tables; possibly a cheap add using NZAT and re-
XXX initialise the LCG only on access and when added (so keep NZAT state
XXX separate from LCG state); also, then we will need a more elaborate
XXX scheme, such as adding from environment, editor keypresses and timing
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.145 2012/04/07 11:19:53 tg Exp $");
d1474 1
a1474 1
	NZATFinish(h);
@


1.145
log
@drop all deprecated code, you have been warned
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.144 2012/03/24 19:13:27 tg Exp $");
d1097 1
a1097 5
		/*
		 * this is the same Linear Congruential PRNG as Borland
		 * C/C++ allegedly uses in its built-in rand() function
		 */
		i = ((lcg_state = 22695477 * lcg_state + 1) >> 16) & 0x7FFF;
d1478 10
@


1.144
log
@be really loud when doing unwise things that WILL break in R41
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.143 2012/03/23 23:25:30 tg Exp $");
a490 1
#ifdef MKSH_DISABLE_DEPRECATED
a495 18
#else
	if (arith && *s == '0' && *(s+1)) {
		s++;
		if (*s == 'x' || *s == 'X') {
			s++;
			base = 16;
		} else if (vp->flag & ZEROFIL) {
			while (*s == '0')
				s++;
		} else {
			warningf(true, "interpreting %s[%lu]='%s' as octal"
			    " is deprecated", vp->name,
			    arrayindex(vp), vp->val.s + vp->type);
			base = 8;
		}
		have_base = true;
	}
#endif
@


1.143
log
@huh, I thought I had extended ${parameter@@#hash} already; make it so now,
but not yet things like ${parameter@@Fi} (1 if integer, 0 otherwise), etc.
also bump patchlevel and © years in recently changed files
@
text
@d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.142 2012/03/23 21:58:24 tg Exp $");
d506 4
a509 1
		} else
d511 1
@


1.142
log
@always keep x_cols and x_lins valid; check once at start including tty init
if we find any, but not later; do not check on every read

⇒ allows changing COLUMNS and LINES (independent of each other, or both)
  for script shells by passing them in an environment setting, even if
  we get a tty; interactive shells still check before each line is read…

reported by the PLD guys, thanks
@
text
@d4 2
a5 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d30 1
a30 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.141 2012/03/03 21:30:59 tg Exp $");
@


1.141
log
@RCSID sync from oksh; reduce hash table #elements if !MKSH_SMALL to speed up
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.140 2011/12/31 00:47:46 tg Exp $");
a1134 1
		change_winsz();
a1459 10
	if (x_lins < 0) {
		/* first time initialisation */
#ifdef TIOCGWINSZ
		if (tty_fd < 0)
			/* non-FTALKING, try to get an fd anyway */
			tty_init(true, false);
#endif
		x_cols = -1;
	}

@


1.140
log
@LLVM+clang scan-build found a dead store and I found an unneeded assert
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.138 2011/12/16 20:03:28 tg Exp $");
d77 2
a78 2
	ktinit(&l->area, &l->vars, 0);
	ktinit(&l->area, &l->funs, 0);
d133 2
a134 2
	    /* currently 12 specials -> 80% of 16 (2^4) */
	    4);
@


1.139
log
@put a bit of type safety into the history code
@
text
@a711 1
	mkssert(*var != 0);
@


1.138
log
@use sane spelling of read-only consistently
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.137 2011/12/10 13:34:19 tg Exp $");
d1223 1
a1223 1
		sethistsize((int)i);
@


1.137
log
@• finally, the code and manual page text to deprecate, and code to not
  handle any more, octal 010 style constants, as promised
• overhaul the manpage re. arithmetic expressions, make the guarantees
  mksh code has explicitly, precisely, clear
• to reduce burden of the compiler, getint() now operates on mksh_uari_t
  internally; it already applied the sign after operation, anyway (C99
  guarantees wraparound on unsigned types, but for signed types we need
  specific compiler support; apparently, this comes from hardware limits)
• use const and shuffle order of locals around while here
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.136 2011/11/26 00:45:03 tg Exp $");
d412 1
a412 1
		warningf(true, "%s: %s", vq->name, "is read only");
d813 1
a813 1
		errorfx(2, "%s: %s", tvar, "is read only");
d1404 1
a1404 1
		errorfx(2, "%s: %s", ccp, "is read only");
@


1.136
log
@fix function-local arrays
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.135 2011/11/11 22:14:19 tg Exp $");
a471 1
	char *s;
d473 2
a475 1
	mksh_ari_t num;
d490 7
d509 2
a510 1
	for (c = *s++; c ; c = *s++) {
d515 2
a517 2
			if (have_base || base < 1 || base > 36)
				return (-1);
d522 1
a522 1
					wc = *(unsigned char *)s;
d530 1
a530 1
					wc = 0xEF00 + *(unsigned char *)s;
d549 1
a549 3
	if (neg)
		num = -num;
	*nump = num;
@


1.135
log
@promote x=(a b); x+=(c) to standard mksh functionality at cost of 932 MKSH_SMALL .text bytes on MirBSD/i386
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.134 2011/11/08 22:07:15 tg Exp $");
d1386 1
a1386 1
	/* to get local array, use "typeset foo; set -A foo" */
d1400 1
a1400 1
	if (reset)
d1403 3
@


1.134
log
@cid 1004E0F5C27271F5B00 broke integer-base handling of built-in parameters

mksh -c 'echo a=$RANDOM; RANDOM=0x12; echo b=$RANDOM' # behaviour changed
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.133 2011/10/16 00:18:56 tg Exp $");
d1382 1
a1382 2
	const char *ccp;
#ifndef MKSH_SMALL
a1384 1
#endif
a1386 1
#ifndef MKSH_SMALL
d1392 1
d1394 1
a1394 5
#define CPORVAR	(cp ? cp : var)
#else
#define CPORVAR	var
#endif
	vp = global(CPORVAR);
d1398 1
a1398 1
		errorfx(2, "%s: %s", CPORVAR, "is read only");
a1407 1
#ifndef MKSH_SMALL
a1417 1
#endif
a1418 1
#ifndef MKSH_SMALL
a1438 1
#endif
@


1.133
log
@fix spello in comment, by <Snader_LB:#!/bin/mksh>
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.132 2011/09/07 15:24:22 tg Exp $");
d559 1
a559 1
	setint_n(vq, num);
d568 1
a568 1
setint_n(struct tbl *vq, mksh_ari_t num)
d576 2
d1138 1
a1138 1
	setint_n(vp, i);
@


1.132
log
@• access(2) is broken in at least kFreeBSD 9.0 as “modern” OS, so bring
  back the wrapper code as well as refactor most other code calling it
• apparently, names can’t end in ‘_’ or contain ‘__’ anywhere…
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.131 2011/08/27 18:06:52 tg Exp $");
d716 1
a716 1
		 * substitution is preformed on the [expression] which
@


1.131
log
@patch most of Jerker Bäck’s concerns out, unless not applicable
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.130 2011/07/07 20:24:53 tg Exp $");
d1173 1
@


1.130
log
@take down the entire xterm (or GNU screen tab), hard, with:
mksh-R40 -c 'x=$COLUMNS; awk "BEGIN{exit(1)}"'
10x to the PLD Linux guys for spotting _and_ bisecting this!
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.129 2011/07/06 22:22:02 tg Exp $");
d173 1
a173 1
	int len;
d588 1
a588 1
	olen = utf_mbswidth(s);
d696 1
a696 1
	int len;
d720 2
a721 1
			int i;
d742 3
a744 3
		if (len > 3 && tvar[len-3] == '[' && tvar[len-2] == '*' &&
		    tvar[len-1] == ']')
			tvar[len-3] = '\0';
d948 1
a948 1
	int alen;
d1340 1
a1340 1
int
d1344 1
a1344 1
	int c;
d1378 1
a1378 1
	mksh_uari_t i, j = 0;
d1382 1
d1387 2
a1388 2
	i = strlen(var);
	if (i > 0 && var[i - 1] == '+') {
d1391 1
a1391 1
		strndupx(cp, var, i - 1, ATEMP);
a1410 1
	i = 0;
@


1.130.2.1
log
@time to open the mksh R40-stable branch:
• bring back deprecated {build options,set ±o arc4random,OAAT1 internal hash}
• change version number in TFM
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.130 2011/07/07 20:24:53 tg Exp $");
d1499 3
a1501 3
	oaat1_init_impl(h);
	oaat1_addstr_impl(h, s);
	oaat1_fini_impl(h);
d1510 3
a1512 3
	oaat1_init_impl(h);
	oaat1_addmem_impl(h, &lcg_state, sizeof(lcg_state));
	oaat1_addmem_impl(h, &v, sizeof(v));
d1521 1
a1521 1
	oaat1_fini_impl(lcg_state);
d1528 1
a1528 1
	oaat1_addmem_impl(h, &lcg_state, sizeof(lcg_state));
d1531 1
a1531 1
	oaat1_fini_impl(h);
@


1.130.2.2
log
@MFC from HEAD and adjust version

Build.sh:
- better handling of eval and CPPFLAGS in build system
- partial OPENSTEP support
- fix typo

check.t:
- mark utf8opt-2a as need-pass: no (1.481)

dot.mkshrc:
- do not close stderr (1.65)
- use only printable characters (1.65)

edit.c:
- upper bound Emacs mode command repeat by input line length

funcs.c, sh.h:
- optimise an if away, and possibly even the function bodies…

misc.c:
- jg71 reported -DMKSH_ASSUME_UTF8=* breaks defining stristr

mksh.1, sh.h. var.c:
- fix spelling

mksh.1:
- document "export -"

sh.h:
- undef optarg, optind in case the OE predefines them (1.493)

shf.c:
- handle %zu (size_t), %zd (ssize_t), etc. (1.43)

syn.c:
- avoid (not-)function-local externs (1.68)

multiple:
- do not use macros or identifiers ending with an underscore
- more {,s}size_t, type, lint, other cleanups (edit.c 1.220; eval.c 1.107;
  exec.c 1.95; expr.c 1.48; funcs.c 1.196; histrap.c 1.110; jobs.c 1.81;
  lalloc.c 1.18; lex.c 1.155; main.c 1.198; misc.c 1.171; sh.h 1.493;
  shf.c 1.43; tree.c 1.50; var.c 1.131)
- wrap access(2) (edit.c 1.221; exec.c 1.96; expr.c 1.49; funcs.c 1.197;
  histrap.c 1.111; sh.h 1.494)
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.130.2.1 2011/07/07 21:42:20 tg Exp $");
d173 1
a173 1
	size_t len;
d588 1
a588 1
	olen = (int)utf_mbswidth(s);
d696 1
a696 1
	size_t len;
d716 1
a716 1
		 * substitution is performed on the [expression] which
d720 1
a720 2
			size_t i;

d741 3
a743 3
		if (len > 3 && tvar[len - 3] == '[' && tvar[len - 2] == '*' &&
		    tvar[len - 1] == ']')
			tvar[len - 3] = '\0';
d947 1
a947 1
	size_t alen;
a1171 1
			/* LINTED use of access */
d1339 1
a1339 1
size_t
d1343 1
a1343 1
	char c;
d1377 1
a1377 1
	mksh_uari_t i = 0, j = 0;
a1380 1
	size_t n;
d1385 2
a1386 2
	n = strlen(var);
	if (n > 0 && var[n - 1] == '+') {
d1389 1
a1389 1
		strndupx(cp, var, n - 1, ATEMP);
d1409 1
@


1.130.2.3
log
@cid 1004E0F5C27271F5B00 broke integer-base handling of built-in parameters

mksh -c 'echo a=$RANDOM; RANDOM=0x12; echo b=$RANDOM' # behaviour changed
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.130.2.2 2011/10/25 22:50:41 tg Exp $");
d559 1
a559 1
	setint_n(vq, num, 0);
d568 1
a568 1
setint_n(struct tbl *vq, mksh_ari_t num, int newbase)
a575 2
	if (newbase != 0)
		vq->type = newbase;
d1136 1
a1136 1
	setint_n(vp, i, 0);
@


1.130.2.4
log
@MFC mksh-current fixes and upcoming deprecation and promotion; sync clog
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.130.2.3 2011/11/08 22:07:25 tg Exp $");
d1382 2
a1383 1
	const char *ccp = var;
d1386 1
d1389 1
a1394 1
		ccp = cp;
d1396 5
a1400 1
	vp = global(ccp);
d1404 1
a1404 1
		errorfx(2, "%s: %s", ccp, "is read only");
d1414 1
d1425 1
d1427 1
d1448 1
@


1.130.2.5
log
@• MFC this week’s bag of misc fixes
• mark “set ±o arc4random” MKSH_DISABLE_DEPRECATED (for e.g. Android)
@
text
@d1386 1
a1386 1
	/* to get local array, use "local foo; set -A foo" */
d1400 1
a1400 1
	if (reset) {
a1402 3
		/* allocate-by-access the [0] element to keep in scope */
		arraysearch(vp, 0);
	}
@


1.130.2.6
log
@MFC
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.130.2.5 2011/11/26 18:23:27 tg Exp $");
d472 1
a473 2
	mksh_uari_t num;
	const char *s;
d475 1
a489 7
#ifdef MKSH_DISABLE_DEPRECATED
	if (arith && s[0] == '0' && (s[1] | 0x20) == 'x') {
		s += 2;
		base = 16;
		have_base = true;
	}
#else
d502 1
a502 2
#endif
	while ((c = *s++)) {
d507 2
a508 1
			if (have_base || num < 1 || num > 36)
a509 1
			base = (int)num;
d514 1
a514 1
					wc = *(const unsigned char *)s;
d522 1
a522 1
					wc = 0xEF00 + *(const unsigned char *)s;
d541 3
a543 1
	*nump = neg ? -((mksh_ari_t)num) : (mksh_ari_t)num;
@


1.130.2.7
log
@MFC all those nice things (not all parts, by now); sync clog
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.130.2.6 2011/12/11 18:18:30 tg Exp $");
d712 1
d1223 1
a1223 1
		sethistsize(i);
@


1.130.2.8
log
@• MFC almost everything not breaking backwards compatibility or introducing
  deep changes into R40-stable branch
• Version accordingly: HEAD gets 2012/03/24 (hi Eddy/Chris) so we backdate
  $KSH_VERSION for R40-stable to 2012/03/20 (hi David) as that comes before
  even though it includes today’s latest fixes
• Also, sync clog (including MFC indicators)
@
text
@d4 1
a4 2
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
 *		 2011, 2012
d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.144 2012/03/24 19:13:27 tg Exp $");
d505 1
a505 4
		} else {
			warningf(true, "interpreting %s[%lu]='%s' as octal"
			    " is deprecated", vp->name,
			    arrayindex(vp), vp->val.s + vp->type);
a506 1
		}
d1135 1
d1461 10
@


1.129
log
@replace uses of OAAT hash in all its variants by NZAT (mksh internal) or NZAAT (all others)
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.128 2011/07/05 20:12:20 tg Exp $");
d1464 1
a1464 1
			tty_init(false, false);
@


1.128
log
@• bump patchlevel to today’s
• while here, reformat 'struct tbl' comment-wise and placement-wise
  and drop the Tflag typedef
• while here, write regression test for the "global" built-in, which
  does what typeset is supposed to do except that it doubles as "local"
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.127 2011/07/02 17:57:41 tg Exp $");
d1499 3
a1501 3
	oaat1_init_impl(h);
	oaat1_addstr_impl(h, s);
	oaat1_fini_impl(h);
d1510 3
a1512 3
	oaat1_init_impl(h);
	oaat1_addmem_impl(h, &lcg_state, sizeof(lcg_state));
	oaat1_addmem_impl(h, &v, sizeof(v));
d1521 1
a1521 1
	oaat1_fini_impl(lcg_state);
d1528 1
a1528 1
	oaat1_addmem_impl(h, &lcg_state, sizeof(lcg_state));
d1531 1
a1531 1
	oaat1_fini_impl(h);
@


1.127
log
@address "env RANDOM=1=2=3 mksh" DoS by integrifying more
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.126 2011/06/21 21:50:26 tg Exp $");
d690 1
a690 1
typeset(const char *var, Tflag set, Tflag clr, int field, int base)
@


1.126
log
@pretty tricky thing, IBM’s curses library does nameref foo=foo…
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.123 2011/06/05 19:58:20 tg Exp $");
a52 1
static mksh_ari_t intval(struct tbl *);
a402 14
/* get variable integer value, with error checking */
static mksh_ari_t
intval(struct tbl *vp)
{
	mksh_ari_t num;
	int base;

	base = getint(vp, &num, false);
	if (base == -1)
		/* XXX check calls - is error here ok by POSIX? */
		errorf("%s: %s", str_val(vp), "bad number");
	return (num);
}

d559 11
a575 3
	if (vq->type == 0)
		/* default base */
		vq->type = base;
a578 1
	return (vq);
d1135 1
a1135 1
	setint(vp, i);
a1181 5
	case V_TMOUT:
		/* AT&T ksh seems to do this (only listen if integer) */
		if (vp->flag & INTEGER)
			ksh_tmout = vp->val.i >= 0 ? vp->val.i : 0;
		return;
d1191 1
d1193 6
a1198 1
		i = intval(vp);
d1242 3
@


1.125
log
@make set_refflag an enum to get easier to understand code
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.124 2011/06/21 21:08:50 tg Exp $");
d754 19
@


1.124
log
@factor out some common code
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.123 2011/06/05 19:58:20 tg Exp $");
a55 2
uint8_t set_refflag = 0;

d180 1
a180 1
	if (!set_refflag && (p != n) && ksh_isalphx(n[0])) {
d714 1
a714 1
		if (set_refflag)
d761 1
a761 1
	if (set_refflag == 2 && (vp->flag & (ARRAY|ASSOC)) == ASSOC)
d763 1
a763 1
	else if (set_refflag == 1) {
@


1.123
log
@• rework hash table interna to avoid gcc-4.1 on Debian etch bug
• also improve behaviour with _a lot_ (>2²⁸) entries
• while here, improve comments and whitespace
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.122 2011/05/29 02:18:57 tg Exp $");
d146 21
a182 1
		struct block *l = e->loc;
a184 1
		uint32_t h;
a186 1
		h = hash(vn);
d188 1
a188 3
		do {
			vp = ktsearch(&l->vars, vn, h);
		} while (!vp && (l = l->next));
d280 3
a282 11
	for (l = e->loc; ; l = l->next) {
		vp = ktsearch(&l->vars, n, h);
		if (vp != NULL) {
			if (array)
				return (arraysearch(vp, val));
			else
				return (vp);
		}
		if (l->next == NULL)
			break;
	}
d315 1
a315 2
		struct block *ll = l;
		struct tbl *vq = NULL;
d317 2
a318 3
		while ((ll = ll->next) && !(vq = ktsearch(&ll->vars, n, h)))
			;
		if (vq) {
@


1.122
log
@mksh R40 Release Candidate 1

Testsuite:
• add new need-pass: {yes|no} attribute, default yes
• exit with 1 if a need-pass test failed unexpectedly
  idea by Kacper Kornet <draenog@@pld-linux.org>
• mark utf8bom-2 as need-pass: no
Infrstructure:
• add housekeeping function for making a tty raw
• switch functions with unused results to void
• struct op: u.charflag contains last char of ;; in TPAT
• var.c:arraysearch is now a global function
Language:
• add ;& (fall through) and ;| (examine next) delimiters
  in addition to ;; (end case) as zsh extensions, because
  POSIX standardised on ;& already
• add -A (read into array), -N (read exactly n bytes),
  -n (read up to n bytes), -t (timeout) flags for read
  from ksh93
• allow read -N -1 or -n -1 to slurp the entire input
• add -a (read into array the input characters) extension
  specific to mksh to read, idea by David Korn
• add -e (exit with error if PWD was not set correctly
  after a physical cd) to cd builtin, mandated by next
  POSIX, and change error codes accordingly
Rewrites:
• full rewrite of read builtin and its manpage section
• add regression tetss for most of the new functionality
• duplicate hexdump demo tests for use of read -a
• use read -raN-1 in dot.mkshrc to get NUL safe base64,
  DJB cdb hash and Jenkins one-at-a-time hash functions
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.121 2011/05/07 02:02:47 tg Exp $");
d31 1
a31 1
/*
d40 1
d70 2
a71 1
	ainit(&l->area); /* todo: could use e->area (l->area => l->areap) */
d80 2
a81 2
	ktinit(&l->vars, &l->area, 0);
	ktinit(&l->funs, &l->area, 0);
d92 1
a94 1
	int i;
d96 5
a100 2
	e->loc = l->next;	/* pop block */
	for (i = l->vars.size; --i >= 0; )
d123 1
d135 3
a137 2
	ktinit(&specials, APERM,
	    /* must be 80% of 2^n (currently 12 specials) */ 16);
d146 3
a148 2
/* Used to calculate an array index for global()/local(). Sets *arrayp to
 * true if this is an array, sets *valp to the array index, returns
d190 1
a190 1
		/* Calculate the value of the subscript */
d245 1
a245 1
			/* If no job, expand to nothing */
d295 1
a295 1
	/* Check to see if this is an array */
d338 4
a341 2
		s = null;		/* special to dollar() */
	else if (!(vp->flag&INTEGER))	/* string source */
d343 9
a351 4
	else {				/* integer source */
		/* worst case number length is when base=2 */
		/* 1 (minus) + 2 (base, up to 36) + 1 ('#') + number of bits
		 * in the mksh_uari_t + 1 (NUL) */
a354 2
		mksh_uari_t n;
		int base;
d391 2
a392 1
		if (vp->flag & (RJUST|LJUST)) /* case already dealt with */
d428 2
a429 1
	if (!(vq->flag&INTEGER)) { /* string dest */
d449 2
a450 1
	} else {		/* integer dest */
d558 2
a559 1
/* convert variable vq to integer variable, setting its value from vp
d595 2
a596 1
		if (!vp->u2.field)	/* default field width */
d681 2
a682 1
	vp->type = xp - vp->val.s; /* offset to value */
d689 3
a691 3
 * lookup variable (according to (set&LOCAL)),
 * set its attributes (INTEGER, RDONLY, EXPORT, TRACE, LJUST, RJUST, ZEROFIL,
 * LCASEV, UCASEV_AL), and optionally set its value if an assignment.
d716 2
a717 1
		/* IMPORT is only used when the shell starts up and is
d719 3
a721 3
		 * references at this time since parameter/command substitution
		 * is preformed on the [expression] which would be a major
		 * security hole.
d738 1
a738 1
		/* Importing from original environment: must have an = */
d750 1
a750 1
	/* Prevent typeset from creating a local PATH/ENV/SHELL */
d763 1
a763 1
			/* Free up entire array */
d796 3
a798 2
		/* XXX if x[0] isn't set, there will be problems: need to have
		 * one copy of attributes for arrays...
d871 1
a871 1
			/* Done after assignment to override default */
d903 1
a903 1
		/* Free up entire array */
d917 1
a917 1
	/* If foo[0] is being unset, the remainder of the array is kept... */
d920 2
a921 1
		unsetspec(vp);	/* responsible for 'unspecial'ing var */
d924 4
a927 3
/* return a pointer to the first char past a legal variable name (returns the
 * argument if there is no legal name, returns a pointer to the terminating
 * NUL if whole string is legal).
d946 2
a947 1
    int aok)				/* skip array de-reference? */
d978 1
a978 1
is_wdvarname(const char *s, int aok)
d1001 1
a1004 1
	int i;
d1007 4
a1010 2
	for (l = e->loc; l != NULL; l = l->next)
		for (vpp = l->vars.tbls, i = l->vars.size; --i >= 0; )
d1033 1
d1149 3
a1151 2
		/* Use tmpdir iff it is an absolute path, is writable and
		 * searchable and is a directory...
d1254 2
a1255 1
	case V_TMOUT:		/* AT&T ksh leaves previous value in place */
d1280 1
a1280 1
	/* The table entry is always [0] */
d1307 2
a1308 1
	if (curr != news) {		/* not reusing old array entry */
d1315 4
a1318 3
/* Return the length of an array reference (eg, [1+2]) - cp is assumed
 * to point to the open bracket. Returns 0 if there is no matching closing
 * bracket.
d1386 1
a1386 1
	 * todo: would be nice for assignment to completely succeed or
@


1.121
log
@handle MKSH_SMALL not doing foo+=(…)
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.120 2011/05/04 23:16:05 tg Exp $");
a52 1
static struct tbl *arraysearch(struct tbl *, uint32_t);
d350 2
a481 2
	if (s == NULL)	/* redundant given initial test */
		s = null;
d555 1
d559 2
a560 1
	if (vq->type == 0) /* default base */
d1244 1
a1244 1
static struct tbl *
@


1.120
log
@+= support for variables and arrays
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.119 2011/03/27 18:50:06 tg Exp $");
d1328 1
d1330 1
d1333 1
d1340 5
a1344 1
	vp = global(cp ? cp : var);
d1348 1
a1348 1
		errorfx(2, "%s: %s", cp ? cp : var, "is read only");
d1359 1
d1370 1
@


1.119
log
@• Implement http://austingroupbugs.net/view.php?id=367 and align things
  a bit more with POSIX and the other shells

I considered http://austingroupbugs.net/view.php?id=253 but the use
of bi_errorf() is interesting, especially as it’s often enough a
noreturn function, and funnily enough, 'cd -P /foo' returns 0 while
'chdir -P /foo' fails (so idk where to put -e)…
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.118 2011/03/13 01:20:25 tg Exp $");
d681 1
d710 7
a716 3
	if (*val == '=')
		strndupx(tvar, var, val++ - var, ATEMP);
	else {
d760 4
a763 2
	/* only allow export flag to be set. AT&T ksh allows any attribute to
	 * be changed which means it can be truncated or modified (-L/-R/-Z/-i)
d803 3
a805 2
			/* Don't change base if assignment is to be done,
			 * in case assignment fails.
d813 5
a817 3
					/* Somewhat arbitrary action here:
					 * zap contents of variable, but keep
					 * the flag settings.
d838 8
d855 3
d966 2
a967 1
	return (p != s && p[0] == CHAR && p[1] == '=');
d1326 1
a1326 1
	mksh_uari_t i;
d1328 1
a1328 4
#ifndef MKSH_SMALL
	char *cp;
	mksh_uari_t j;
#endif
d1331 7
a1337 1
	vp = global(var);
d1341 1
a1341 1
		errorfx(2, "%s: %s", var, "is read only");
d1346 2
a1347 1
	/* todo: would be nice for assignment to completely succeed or
d1352 10
a1361 5
#ifndef MKSH_SMALL
	j = 0;
#else
#define j i
#endif
a1389 1
#ifndef MKSH_SMALL
a1390 1
#endif
@


1.118
log
@lint is your friend
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.117 2011/03/07 20:30:41 tg Exp $");
d410 1
a410 1
			errorfz();
d761 1
a761 1
		errorf("%s: %s", tvar, "is read only");
d1316 1
a1316 1
		errorf("%s: %s", var, "is read only");
@


1.117
log
@introduce a tobool(cond) abstraction¹ and switch bool to char if !stdbool.h

① currently: ((cond) ? true : false) but (!!(cond)) and casting to bool,
  the latter only if stdbool.h, would also work – which performs best on
  (and across) all supported systems?
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.116 2011/02/11 01:18:23 tg Exp $");
d913 1
a913 1
			while (1) {
@


1.116
log
@• more comment and int→bool cleanup, add and improve some comments
• in interactive mode, always look up {LC_{ALL,CTYPE},LANG} environment
  variables if setlocale/nl_langinfo(CODESET) doesn’t suffice
• add the ability to call any builtin (some don't make sense or wouldn't
  work) directly by analysing argv[0]
• for direct builtin calls, the {LC_{ALL,CTYPE},LANG} environment
  variables determine utf8-mode, even if MKSH_ASSUME_UTF8 was set
• when called as builtin, echo behaves POSIXish
• add domainname as alias for true on MirBSD only, to be able to link it
• sync mksh Makefiles with Build.sh output
• adjust manpage wrt release plans
• link some things to mksh now that we have callable builtins:
  bin/echo bin/kill bin/pwd bin/sleep (exact matches)
  bin/test bin/[ (were scripts before)
  bin/domainname=usr/bin/true usr/bin/false (move to /bin/ now)
• drop linked utilities and, except for echo and kill, their manpages
• adjust instbin and link a few more there as well
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.115 2011/01/21 21:04:48 tg Exp $");
d729 1
a729 1
	vp = (set&LOCAL) ? local(tvar, (set & LOCAL_COPY) ? true : false) :
@


1.115
log
@• implement KSHEGID, KSHGID, KSHUID variables by suggestion of Richard K.
  (KSHEUID aka USER_ID already exists)
• simplify, speed up LCG and $RANDOM handling again
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.114 2010/09/19 19:21:20 tg Exp $");
d1087 2
a1088 1
		flushcom(1);	/* clear tracked aliases */
d1186 2
a1187 1
		flushcom(1);	/* clear tracked aliases */
@


1.114
log
@RNDEBUG showed that using the pushb_fast will have much fewer syscalls
@
text
@d4 1
a4 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.113 2010/09/14 21:26:19 tg Exp $");
d42 2
a54 3
static uint32_t oaathash_update(register uint32_t, register const uint8_t *,
    register size_t);
static uint32_t oaathash_finalise(register uint32_t);
a987 73
/* Bob Jenkins' one-at-a-time hash */
static uint32_t
oaathash_update(register uint32_t h, register const uint8_t *cp,
    register size_t n)
{
	while (n--) {
		h += *cp++;
		h += h << 10;
		h ^= h >> 6;
	}

	return (h);
}

static uint32_t
oaathash_finalise(register uint32_t h)
{
	h += h << 3;
	h ^= h >> 11;
	h += h << 15;

	return (h);
}

uint32_t
oaathash_full(register const uint8_t *bp)
{
	register uint32_t h = 0;
	register uint8_t c;

	while ((c = *bp++)) {
		h += c;
		h += h << 10;
		h ^= h >> 6;
	}

	return (oaathash_finalise(h));
}

void
change_random(const void *vp, size_t n)
{
	register uint32_t h = 0x100;
#if defined(arc4random_pushb_fast) || defined(MKSH_A4PB)
	uint32_t i;
#endif

	kshstate_v.cr_dp = vp;
	kshstate_v.cr_dsz = n;
	gettimeofday(&kshstate_v.cr_tv, NULL);
	h = oaathash_update(oaathash_update(h, (void *)&kshstate_v,
	    sizeof(kshstate_v)), vp, n);
	kshstate_v.lcg_state_ = oaathash_finalise(h);

#if defined(arc4random_pushb_fast) || defined(MKSH_A4PB)
	/*
	 * either we have very check entropy get and push available,
	 * with malloc() pulling in this code already anyway, or the
	 * user requested us to use the old functions
	 */
#if defined(arc4random_pushb_fast)
	arc4random_pushb_fast(&kshstate_v.lcg_state_,
	    sizeof(kshstate_v.lcg_state_));
	i = arc4random();
#else
	i = arc4random_pushb(&kshstate_v.lcg_state_,
	    sizeof(kshstate_v.lcg_state_));
#endif
	h = oaathash_update(h, (void *)&i, sizeof(i));
	kshstate_v.lcg_state_ = oaathash_finalise(h);
#endif
}

d1042 1
a1042 2
		i = ((kshstate_v.lcg_state_ =
		    22695477 * kshstate_v.lcg_state_ + 1) >> 16) & 0x7FFF;
d1109 1
a1109 1
		break;
d1113 1
a1113 1
		break;
d1119 1
a1119 1
		break;
d1160 1
a1160 1
		change_random(&i, sizeof(i));
d1404 1
a1404 1
evilhash(const char *s)
d1406 33
a1438 1
	register uint32_t h = 0x100;
d1440 2
a1441 4
	h = oaathash_update(h, (void *)&kshstate_f, sizeof(kshstate_f));
	kshstate_f.h = oaathash_full((const uint8_t *)s);
	return (oaathash_finalise(oaathash_update(h,
	    (void *)&kshstate_f.h, sizeof(kshstate_f.h))));
@


1.113
log
@• Address concerns of Chris Palmer from the Android security team
  – possible integer overflows in memory allocation, mostly
    ‣ multiplication: all are checked now
    ‣ addition: reviewed them, most were “proven” or guessed to be
      “almost” impossible to run over (e.g. when we have a string
      whose length is taken it is assumed that the length will be
      more than only a few bytes below SIZE_MAX, since code and
      stack have to fit); some are checked now (e.g. when one of
      the summands is an off_t); most of the unchecked ones are
      annotated now
    ⇒ cost (MirBSD/i386 static): +76 .text
    ⇒ cost (Debian sid/i386): +779 .text  -4 .data
  – on Linux targets, setuid() setresuid() setresgid() can fail
    with EAGAIN; check for that and, if so, warn once and retry
    infinitely (other targets to be added later once we know that
    they are “insane”)
    ⇒ cost (Debian sid/i386): +192 .text (includes .rodata)
• setmode.c: Do overflow checking for realloc() too; switch back
  from calloc() to a checked malloc() for simplification while there
• define -DIN_MKSH and let setmode.c look a tad nicer while here
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.112 2010/08/28 20:22:24 tg Exp $");
d1032 2
a1033 4
#if defined(__OpenBSD__)
	int mib[2];
	uint8_t k[3];
	size_t klen;
d1043 12
a1054 7
#if defined(__OpenBSD__)
	/* OpenBSD, MirBSD: proper kernel entropy comes at zero cost */

	mib[0] = CTL_KERN;
	mib[1] = KERN_ARND;
	klen = sizeof(k);
	sysctl(mib, 2, k, &klen, &kshstate_v.lcg_state_,
d1056 2
a1057 12
	/* we ignore failures and take in k anyway */
	h = oaathash_update(h, k, sizeof(k));
	kshstate_v.lcg_state_ = oaathash_finalise(h);
#elif defined(MKSH_A4PB)
	/* forced by the user to use arc4random_pushb(3) - Cygwin? */
	{
		uint32_t prv;

		prv = arc4random_pushb(&kshstate_v.lcg_state_,
		    sizeof(kshstate_v.lcg_state_));
		h = oaathash_update(h, &prv, sizeof(prv));
	}
@


1.112
log
@shave off another 468 bytes: we’re 300 bytes smaller than BEFORE the
cat builtin was added now… (also removed utf-8 from source files, in
favour of just ASCII)
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.111 2010/08/28 18:50:58 tg Exp $");
d652 4
a655 2
	int namelen = strlen(vp->name);
	int vallen = strlen(val) + 1;
d658 1
a1322 1
	len = strlen(vp->name) + 1;
d1324 3
a1326 1
		news = alloc(offsetof(struct tbl, name[0]) + len, vp->areap);
@


1.111
log
@improve string pooling: saves 316 bytes in .text
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.110 2010/07/25 11:35:43 tg Exp $");
d689 1
a689 1
			    "reference variable cannot be an array");
d715 1
a715 1
		/* handle foo[*] ⇒ foo (whole array) mapping for R39b */
d1054 1
a1054 1
	/* forced by the user to use arc4random_pushb(3) • Cygwin? */
@


1.110
log
@a tad annoying, when external programmes such as GNU screen are running,
we don’t get SIGWINCH when the window size changes during the runtime of
that, so, the signal is only usable reliably during editing in the shell
and we re-check the window size before each interactive edit line again
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.109 2010/07/18 17:29:50 tg Exp $");
d396 1
a396 1
		errorf("%s: bad number", str_val(vp));
d409 1
a409 1
		warningf(true, "%s: is read only", vq->name);
d688 2
a689 2
			errorf("%s: reference variable cannot be an array",
			    var);
d725 1
a725 1
		errorf("%s: restricted", tvar);
d759 1
a759 1
		errorf("%s: is read only", tvar);
d1392 1
a1392 1
		errorf("%s: is read only", var);
@


1.109
log
@new MKSH_A4PB cppflag: force use of arc4random_pushb(3) during seeding
just the way sysctl KERN_ARND currently is used on OpenBSD/MirBSD (for
manual packager overrides only, no mirtoconf check; e.g. for Cygwin)
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.108 2010/07/17 22:09:40 tg Exp $");
d1457 1
a1457 1
	/* check if window size has changed since first time */
@


1.108
log
@• merge printf from OpenBSD
• deactivate %a and %A since our libc doesn’t have it
• rewrite the mksh integration code to use shf instead of stdio, removing
  floating point support always in the process, as shf doesn’t support it
  ⇒ saves 11114 (6706 text, 168 data, 4240 bss) with dietlibc on Debian
• fix -Wall -Wextra -Wformat -Wstrict-aliasing=2 for gcc (Debian 4.4.4-7)
• fix these and -Wc++-compat for gcc version 4.6.0 20100711 (experimental)
  [trunk revision 162057] (Debian 20100711-1) except:
  – a few enum warnings that relate to eglibc’s {g,s}etrlimit() functions
    taking an enum instead of an int because they’re too stupid to adhere
    to POSIX interfaces they design by themselves
  – all “request for implicit conversion” involving a "void *" on one side
• tweak the manual page somewhat more
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.107 2010/07/11 11:17:33 tg Exp $");
d1053 10
@


1.107
log
@on obsd/mbsd, entropy is cheap enough for us to do this (codepath in
kernel checked for both) for additional seeding ($RANDOM is still from
the LCG only)
@
text
@d29 1
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.106 2010/07/04 17:45:17 tg Exp $");
d43 1
a43 1
static void export(struct tbl *, const char *);
d429 1
a429 1
			export(vq, s);
d648 1
a648 1
export(struct tbl *vp, const char *val)
d840 1
a840 1
		export(vpbase, (vpbase->flag&ISSET) ? vpbase->val.s : null);
d1291 1
a1291 1
	struct tbl *prev, *curr, *new;
d1307 1
a1307 1
		new = curr;
d1309 1
a1309 1
		new = NULL;
d1311 13
a1323 13
	if (!new) {
		new = alloc(offsetof(struct tbl, name[0]) + len, vp->areap);
		memcpy(new->name, vp->name, len);
	}
	new->flag = (vp->flag & ~(ALLOC|DEFINED|ISSET|SPECIAL)) | AINDEX;
	new->type = vp->type;
	new->areap = vp->areap;
	new->u2.field = vp->u2.field;
	new->ua.index = val;

	if (curr != new) {		/* not reusing old array entry */
		prev->u.array = new;
		new->u.array = curr;
d1325 1
a1325 1
	return (new);
@


1.106
log
@implement “live” SIGWINCH handling in the Emacs editing mode
for winstonw from IRC #!/bin/mksh
@
text
@d25 5
a29 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.105 2010/07/04 17:33:58 tg Exp $");
d1029 5
d1041 13
@


1.105
log
@to speed up mksh, get rid of arc4random(3) uses and use the LCG always;
depend on ASLR for seeding
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.104 2010/01/28 20:26:52 tg Exp $");
d1443 4
@


1.104
log
@Add some assertions – mkssert() – for things clang’s scan-build can’t see
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.103 2010/01/25 14:38:04 tg Exp $");
a48 1
#if !HAVE_ARC4RANDOM
d51 1
a51 3

static uint32_t lcg_state = 5381;
#endif
d982 1
a982 1
#if !HAVE_ARC4RANDOM
d996 25
a1024 19
	struct {
		const void *sp, *bp, *dp;
		size_t dsz;
		struct timeval tv;
		uint32_t s;
	} i;

	i.dp = vp;
	i.dsz = n;
	i.s = lcg_state;
	i.bp = &lcg_state;
	i.sp = &i;
	gettimeofday(&i.tv, NULL);
	h = oaathash_update(oaathash_update(h, (void *)&i, sizeof(i)), vp, n);

	/* oaathash_finalise */
	h += h << 3;
	h ^= h >> 11;
	h += h << 15;
d1026 6
a1031 1
	lcg_state = h;
a1032 1
#endif
a1083 3
#if HAVE_ARC4RANDOM
		i = arc4random() & 0x7FFF;
#else
d1088 2
a1089 2
		i = ((lcg_state = 22695477 * lcg_state + 1) >> 16) & 0x7FFF;
#endif
a1202 13
#if HAVE_ARC4RANDOM
#if HAVE_ARC4RANDOM_PUSHB
		if (Flag(FARC4RANDOM))
			/*
			 * things like initialisation, environment import,
			 * etc. are already done
			 */
			arc4random_pushb(&i, sizeof(i));
		else
			/* during start-up phase or somesuch */
#endif	/* HAVE_ARC4RANDOM_PUSHB */
			arc4random_addrandom((void *)&i, sizeof(i));
#else	/* !HAVE_ARC4RANDOM */
d1204 1
a1204 1
		 * mksh R40+ no longer has the traditional repeatability
a1207 1
#endif	/* !HAVE_ARC4RANDOM */
d1252 6
a1257 7
	/* AT&T ksh man page says OPTIND, OPTARG and _ lose special meaning,
	 * but OPTARG does not (still set by getopts) and _ is also still
	 * set in various places.
	 * Don't know what AT&T does for:
	 *		HISTSIZE, HISTFILE,
	 * Unsetting these in AT&T ksh does not loose the 'specialness':
	 * no effect: IFS, COLUMNS, PATH, TMPDIR
d1444 11
@


1.103
log
@remove some debugging code
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.102 2010/01/25 14:25:16 tg Exp $");
d683 2
@


1.102
log
@introduce “typeset -i foo[*]”, rationale see cid 1004B5DA60A56BFB604
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.101 2010/01/25 14:11:29 tg Exp $");
a1306 4
#ifdef notyet_ktremove
	/* XXX array indices must not be ktdelete'd, for now */
	new->tablep = NULL;
#endif
a1409 4
#if 0
		shprintf("setting '%s'[%lu]='%s'  <- '%s'\n",
		    vp->name, (unsigned long)j, ccp, vals[i]);
#endif
@


1.101
log
@Add “unset foo[*]” mksh extension, which allows to unset the *contents*
of foo[0] (but not its attributes), and the rest of the array, so that
later “set +A foo bar” will set foo[0]=bar but retain the attributes.

This is important, because, in the future, arrays will have different
attributes per element, instead of all the same (which, actually, is
not entirely true right now either, since “unset foo[0]” will not mo-
dify the attributes of a foo[1] existing at that point in time), where
foo[$newkey] will inherit from foo[0], but typeset foo will only affect
foo[0] no longer foo[*] in the future. (The rules about typeset=local
will still apply, as they affect creation of variables in a scope.)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.100 2009/12/05 17:43:50 tg Exp $");
d677 1
a683 2
		int len;

d712 5
d761 2
a762 1
		int ok = 1;
d767 1
a767 1
			int fake_assign;
d804 1
a804 1
					ok = 0;
@


1.100
log
@llvm/clang scan-build is now content…
@
text
@d4 1
a4 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009
d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.99 2009/12/01 19:15:35 tg Exp $");
d837 4
a840 2
/* Unset a variable. array_ref is set if there was an array reference in
 * the name lookup (eg, x[2]).
d843 1
a843 1
unset(struct tbl *vp, int array_ref)
d847 1
a847 1
	if ((vp->flag & ARRAY) && !array_ref) {
d860 4
d865 1
a865 1
	vp->flag &= SPECIAL | (array_ref ? ARRAY|DEFINED : 0);
d1372 1
a1372 1
		unset(vp, 0);
@


1.99
log
@* fix 'set -A foo -- [2]=a b c' contingency (tested against GNU bash4,
  which, in its latest sid incarnation, even received mksh's ability
  to produce ${!foo[*]} array keys, wow!)
* plug a memory leak while here (ATEMP only, but still)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.98 2009/11/28 14:28:03 tg Exp $");
d163 3
a165 6
		for (l = e->loc; ; l = l->next) {
			if ((vp = ktsearch(&l->vars, vn, h)) != NULL)
				break;
			if (l->next == NULL)
				break;
		}
@


1.98
log
@/me is annoyed

I read, IIRC in the Cederqvist, that 'cvs tag' sets a sticky tag onto
the cwd… it doesn’t, apparently. (I actually like it better this way,
but one needs to know!)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.96 2009/10/18 12:30:06 tg Exp $");
d1353 1
a1353 1
	mksh_uari_t i, n;
d1357 1
d1374 7
a1380 1
	for (n = i = 0; (ccp = vals[i]); n = ++i) {
d1395 1
a1395 1
				evaluate(substitute(cp, 0), (mksh_ari_t *)&n,
d1397 1
d1404 1
a1404 1
		vq = arraysearch(vp, n);
d1408 1
a1408 1
		    vp->name, (unsigned long)n, ccp, vals[i]);
d1411 4
@


1.97
log
@switch ${%foo} to wcswidth-like behaviour – slightly problematic, and
the “set +U” case isn’t even handled

committed to branch because I’d like to get more input on this, for now
@
text
@d577 1
a577 1
	olen = utf_mbswidth(s, true);
@


1.96
log
@• better IV for the oaathash-on-binary (as if we prepended a '\x01')
• better variable name for the LCG state
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.95 2009/10/17 21:16:05 tg Exp $");
d577 1
a577 1
	olen = utf_mbswidth(s);
@


1.96.2.1
log
@/me is annoyed

I read, IIRC in the Cederqvist, that 'cvs tag' sets a sticky tag onto
the cwd… it doesn’t, apparently. (I actually like it better this way,
but one needs to know!)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.97 2009/11/28 14:21:47 tg Exp $");
d577 1
a577 1
	olen = utf_mbswidth(s, true);
@


1.95
log
@• overhaul handling of special variables
• use a combination of the one-at-a-time hash and an LCG for handling
  the $RANDOM special if !HAVE_ARC4RANDOM instead of rand(3)/srand(3)
  and get rid of time(3) usage to reduce import footprint
• raise entropy state (mostly in the !HAVE_ARC4RANDOM case though…)
• simplify handling of the $RANDOM_SPECIAL generally
• tweak hash() to save a temp var for non-optimising compilers
• some int → mksh_ari_t and other type fixes
• general tweaking of code and comments
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.94 2009/09/27 10:31:06 tg Exp $");
d53 1
a53 1
static uint32_t lcg_seed = 5381;
d992 1
a992 1
	register uint32_t h;
d1002 2
a1003 2
	i.s = lcg_seed;
	i.bp = &lcg_seed;
d1006 1
a1006 1
	h = oaathash_update(oaathash_update(1, (void *)&i, sizeof(i)), vp, n);
d1013 1
a1013 1
	lcg_seed = h;
d1074 1
a1074 1
		i = ((lcg_seed = 22695477 * lcg_seed + 1) >> 16) & 0x7FFF;
@


1.94
log
@• avoid calling arc4random_pushb for inheritance and other redundant items;
  call it only if $RANDOM is indeed set (although pool extension would be a
  possibility we do have arc4random_atexit which does it nicely too)
• avoid calling setspec for int→str conversion just before execve()
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.93 2009/09/26 04:01:34 tg Exp $");
d49 5
a53 5
static int rnd_get(void);
#if HAVE_ARC4RANDOM
static void rnd_set(unsigned long);
#else
#define rnd_set change_random
d975 4
a978 3
#if HAVE_ARC4RANDOM
static int
rnd_get(void)
d980 5
a984 2
	return (arc4random() & 0x7FFF);
}
d986 1
a986 17
static void
rnd_set(unsigned long newval)
{
#if HAVE_ARC4RANDOM_PUSHB
	if (Flag(FARC4RANDOM))
		/* initialisation, environment import, etc. already done */
		arc4random_pushb(&newval, sizeof(newval));
	else
		/* during start-up phase or somesuch */
#endif
	arc4random_addrandom((void *)&newval, sizeof(newval));
}
#else
static int
rnd_get(void)
{
	return (rand() & 0x7FFF);
a988 7
/*
 * Called after a fork to bump the random number generator.
 * Done to ensure children will not get the same random number sequence
 * as the parent processes.
 * Also called as rnd_set - mksh R40+ no longer has the traditional
 * repeatability of randomness sequences, state is always retained.
 */
d990 1
a990 1
change_random(unsigned long newval)
d992 15
a1006 9
	register unsigned int h;

	h = rand();
	while (newval) {
		h += (newval & 0xFF);
		h += h << 10;
		h ^= h >> 6;
		newval >>= 8;
	}
d1008 1
d1013 1
a1013 2
	/* pass all of it, in case RAND_MAX is large */
	srand(h);
d1048 2
a1049 1
	int i;
d1051 1
a1051 1
	switch ((i = special(vp->name))) {
d1053 3
a1055 3
		vp->flag &= ~SPECIAL;
		/* On start up the value of SECONDS is used before seconds
		 * has been set - don't do anything in this case
d1062 3
a1064 3
			setint(vp, tv.tv_sec - seconds);
		}
		vp->flag |= SPECIAL;
d1067 9
a1075 3
		vp->flag &= ~SPECIAL;
		setint(vp, rnd_get());
		vp->flag |= SPECIAL;
d1078 1
a1078 3
		vp->flag &= ~SPECIAL;
		setint(vp, (mksh_ari_t)histsize);
		vp->flag |= SPECIAL;
d1081 1
a1081 3
		vp->flag &= ~SPECIAL;
		setint(vp, (mksh_ari_t)user_opt.uoptind);
		vp->flag |= SPECIAL;
d1084 1
a1084 3
		vp->flag &= ~SPECIAL;
		setint(vp, (mksh_ari_t)current_lineno + user_lineno);
		vp->flag |= SPECIAL;
d1088 2
a1089 1
		/* Do NOT export COLUMNS/LINES. Many applications
a1094 1
		vp->flag &= ~SPECIAL;
d1096 1
a1096 2
		setint(vp, i == V_COLUMNS ? x_cols : x_lins);
		vp->flag |= SPECIAL;
d1098 7
a1104 1
	}
d1110 1
a1110 1
	int i;
d1112 1
d1114 1
a1114 1
	switch (special(vp->name)) {
d1121 1
a1121 1
		break;
d1125 1
a1125 6
		break;
	case V_OPTIND:
		vp->flag &= ~SPECIAL;
		getopts_reset((int)intval(vp));
		vp->flag |= SPECIAL;
		break;
a1142 5
	case V_HISTSIZE:
		vp->flag &= ~SPECIAL;
		sethistsize((int)intval(vp));
		vp->flag |= SPECIAL;
		break;
d1148 9
d1158 4
d1163 19
a1181 1
		if ((i = intval(vp)) >= MIN_COLS)
a1182 1
		vp->flag |= SPECIAL;
d1185 1
a1185 2
		vp->flag &= ~SPECIAL;
		if ((i = intval(vp)) >= MIN_LINS)
a1186 1
		vp->flag |= SPECIAL;
d1189 19
a1207 3
		vp->flag &= ~SPECIAL;
		rnd_set(intval(vp));
		vp->flag |= SPECIAL;
a1209 1
		vp->flag &= ~SPECIAL;
d1214 1
a1214 1
			seconds = tv.tv_sec - intval(vp);
a1215 6
		vp->flag |= SPECIAL;
		break;
	case V_TMOUT:
		/* AT&T ksh seems to do this (only listen if integer) */
		if (vp->flag & INTEGER)
			ksh_tmout = vp->val.i >= 0 ? vp->val.i : 0;
a1217 1
		vp->flag &= ~SPECIAL;
d1219 1
a1219 2
		user_lineno = (unsigned int)intval(vp) - current_lineno - 1;
		vp->flag |= SPECIAL;
@


1.93
log
@* move the utf_* functions to a smaller file, to reduce the pain the
  CPU has to endure while gcc is crunching on edit.c
* comment on mksh not using _exactly_ OPTU-8/OPTU-16 (XXX)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.92 2009/09/26 03:40:02 tg Exp $");
d965 1
a965 1
					vp->flag &= ~(INTEGER|RDONLY);
d986 6
a991 2
	arc4random_pushb(&newval, sizeof(newval));
#else
a992 1
#endif
@


1.92
log
@further optimise and simplify the handling of $RANDOM, reads and writes
to it are now either arc4random or rand/srand, but srand retains the old
state; set +o arc4random is no longer possible, but if it's there we use
arc4random(3), if not, we use rand(3) for $RANDOM reads; optimise special
variable handling too and fix a few consts and other minor things
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.91 2009/09/23 18:22:38 tg Exp $");
d360 1
d515 6
@


1.91
log
@SUNWcc related fixes for normal and MKSH_SMALL
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.89 2009/09/20 13:29:18 tg Exp $");
d45 2
d50 1
d52 3
d110 14
d127 1
a127 21
	static const struct {
		const char *name;
		int v;
	} names[] = {
		{ "COLUMNS",		V_COLUMNS },
#if HAVE_PERSISTENT_HISTORY
		{ "HISTFILE",		V_HISTFILE },
#endif
		{ "HISTSIZE",		V_HISTSIZE },
		{ "IFS",		V_IFS },
		{ "LINENO",		V_LINENO },
		{ "LINES",		V_LINES },
		{ "OPTIND",		V_OPTIND },
		{ "PATH",		V_PATH },
		{ "RANDOM",		V_RANDOM },
		{ "SECONDS",		V_SECONDS },
		{ "TMOUT",		V_TMOUT },
		{ "TMPDIR",		V_TMPDIR },
		{ NULL,			0 }
	};
	int i;
d132 3
a134 2
	for (i = 0; names[i].name; i++) {
		tp = ktenter(&specials, names[i].name, hash(names[i].name));
d136 1
a136 1
		tp->type = names[i].v;
d388 1
a388 1
mksh_ari_t
d465 1
a465 1
int
d968 1
a968 52
/*
 * Get us a random number, either from rand(3) or arc4random(3), with
 * the latter being preferred. If Flag(FARC4RANDOM) is 0, we use rand(3),
 * otherwise arc4random(3). We have static caches to make change_random
 * and writes to $RANDOM a cheap operation.
 */
#if HAVE_ARC4RANDOM && !defined(MKSH_SMALL)
static uint32_t rnd_cache[2];
static unsigned char rnd_lastflag = 2;
#if HAVE_ARC4RANDOM_PUSHB
static bool rnd_wpush = false;
#define rnd_mix(v,w) rnd_cmix(v,w)
#else
#define rnd_mix(v,w) rnd_cmix(v)
#endif

static void rnd_mix(unsigned long, bool);

static void
rnd_mix(unsigned long newval, bool wantpush)
{
	struct {
		union {
			int rval;
			uint32_t arval;
		} v0;
		uint32_t v1;
		uint32_t v2;
		unsigned long v3;
#if HAVE_ARC4RANDOM_PUSHB
		bool neededpush;
		bool wantingpush;
#endif
	} v;

#if HAVE_ARC4RANDOM_PUSHB
	v.neededpush = rnd_wpush;
	v.wantingpush = wantpush;
	rnd_wpush = v.neededpush || v.wantingpush;
#endif

	v.v0.rval = rand();
	v.v1 = rnd_cache[0];
	v.v2 = rnd_cache[1];
	v.v3 = newval;

	rnd_cache[0] = hashmem(&v, sizeof(v));
	v.v0.arval = arc4random();
	rnd_cache[1] = hashmem(&v, sizeof(v));
}
#endif

a971 1
#if HAVE_ARC4RANDOM && defined(MKSH_SMALL)
a972 36
#else
#if HAVE_ARC4RANDOM
#if HAVE_ARC4RANDOM_PUSHB
	uint32_t rv = 0;
#endif
	if (Flag(FARC4RANDOM) != rnd_lastflag) {
		if (Flag(FARC4RANDOM) == 0)
			/* transition to 0 by set: srand */
			srand(arc4random() & 0x7FFF);
		else if (rnd_lastflag == 0)
			/* transition from 0: addrandom */
			rnd_mix(rand(), true);
		rnd_lastflag = Flag(FARC4RANDOM);
	}
	if (Flag(FARC4RANDOM)) {
		if (rnd_cache[0] || rnd_cache[1]) {
#if HAVE_ARC4RANDOM_PUSHB
			if (rnd_wpush) {
				rv = arc4random_pushb(rnd_cache,
				    sizeof(rnd_cache));
				rnd_wpush = false;
			} else
#endif
			arc4random_addrandom((void *)rnd_cache,
			    sizeof(rnd_cache));
		}
		rnd_cache[0] = rnd_cache[1] = 0;
		return ((
#if HAVE_ARC4RANDOM_PUSHB
		    rv ? rv :
#endif
		    arc4random()) & 0x7FFF);
	}
#endif
	return (rand() & 0x7FFF);
#endif
a977 1
#if HAVE_ARC4RANDOM && defined(MKSH_SMALL)
d983 1
d985 4
a988 11
#if HAVE_ARC4RANDOM
	rnd_mix(newval, true);
	if (Flag(FARC4RANDOM) == 1)
		return;
	if (Flag(FARC4RANDOM) == 2)
		Flag(FARC4RANDOM) = 0;
	/* transition to 0 by write: only srand */
	rnd_lastflag = 0;
#endif
	srand(newval & 0x7FFF);
#endif
a990 1
#if !HAVE_ARC4RANDOM || !defined(MKSH_SMALL)
d995 2
d1001 1
a1001 8
	int rval = 0;

#if HAVE_ARC4RANDOM
	if (Flag(FARC4RANDOM)) {
		rnd_mix(newval, false);
		return;
	}
#endif
d1003 11
a1013 6
	rval += newval & 0x7FFF;
	newval >>= 15;
	rval += newval & 0x7FFF;
	newval >>= 15;
	rval += newval + rand();
	rval = (rval & 0x7FFF) ^ (rval >> 15);
d1015 2
a1016 1
	srand(rval);
@


1.90
log
@* shrink MKSH_SMALL even further by removing functionality like
  some GNU bash extensions (suggested by cnuke@@) and bind macros
* make the random cache more efficient (and the code potentially
  smaller, although we have a new implementation of the oaat hash
  function, alongside the old one, now) and pushb only if needed
  (i.e. state has changed or user has set $RANDOM, but not onfork)
@
text
@d1453 1
a1453 1
				evaluate(substitute(cp, 0), &n,
@


1.90.2.1
log
@commit some debugging code for me for later
@
text
@a1006 7
fprintf(stderr, "{%lu|rnd_cachemix(%lu,%s),wpush=%s->%s",(u_long)getpid(),newval,
#if HAVE_ARC4RANDOM_PUSHB
wantpush ? "true" : "false", v.neededpush ? "true" : "false", rnd_wpush ? "true" : "false"
#else
"unknown", "unknown", "unknown"
#endif
);
a1015 3

fprintf(stderr, ":[%X,%X]->[%X,%X]}\n",v.v1,v.v2,rnd_cache[0],
rnd_cache[1]);fflush(stderr);
a1022 1
fprintf(stderr, "{%lu|rnd_get}\n",(u_long)getpid());fflush(stderr);
a1028 1
fprintf(stderr, "{%lu|rnd_get",(u_long)getpid());
a1029 1
fprintf(stderr, ":trans(%d->%d)", rnd_lastflag, Flag(FARC4RANDOM));
a1039 1
fprintf(stderr, ":cache(%X,%X)", rnd_cache[0],rnd_cache[1]);
a1040 1
fprintf(stderr, ":push(%s)", rnd_wpush ? "true" : "false");
a1050 1
fprintf(stderr, "|rnd_get}\n");fflush(stderr);
a1064 1
fprintf(stderr, "{%lu|rnd_set(%lu)}\n",(u_long)getpid(),newval);fflush(stderr);
a1095 1
fprintf(stderr, "{%lu|change_random(%lu)}\n",(u_long)getpid(),newval);fflush(stderr);
@


1.89
log
@use a slightly different algorithm for arc4random_pushb interfacing:
rate-limit calls to CryptGenRandom to every 2‥4 minutes, if the last
call was successful, and operate with hash() on rnd_cache[], so that
it is mixed in a better way
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.87 2009/09/06 17:42:15 tg Exp $");
d976 6
d983 1
a983 1
static void rnd_cachemix(unsigned long);
d986 1
a986 1
rnd_cachemix(unsigned long newval)
a987 1
	size_t i;
d996 4
d1001 6
a1006 1
	unsigned char buf[sizeof(v) * 2 + 1], *cp, num;
d1013 3
a1015 17
	num = 0;
 loop:
	cp = (void *)&v;
	i = 0;
	while (i < 2 * sizeof(v)) {
		buf[i++] = digits_uc[*cp >> 4];
		buf[i++] = digits_lc[*cp & 0x0F];
		++cp;
	}
	buf[i] = 0;

	rnd_cache[num] = hash(buf);
	if (num == 0) {
		++num;
		v.v0.arval = arc4random();
		goto loop;
	}
d1035 1
a1035 1
			rnd_cachemix(rand());
d1039 1
a1039 1
		if (rnd_cache[0] || rnd_cache[1])
d1041 6
a1046 2
			rv = arc4random_pushb(rnd_cache, sizeof(rnd_cache));
#else
d1049 1
a1049 1
#endif
d1073 1
a1073 1
	rnd_cachemix(newval);
d1087 1
a1087 1
 * Called after a fork in parent to bump the random number generator.
d1089 1
a1089 1
 * if the parent doesn't use $RANDOM.
d1098 1
a1098 1
		rnd_cachemix(newval);
d1420 1
d1422 1
d1439 1
d1459 1
@


1.88
log
@only one digits instance, thank you very much
@
text
@d976 41
d1030 1
a1030 1
		if (Flag(FARC4RANDOM) == 0) {
d1033 1
a1033 1
		} else if (rnd_lastflag == 0) {
d1035 1
a1035 3
			rnd_cache[0] ^= rand();
			rnd_cache[1] ^= rand();
		}
d1069 1
a1069 2
	rnd_cache[0] ^= (newval << 15) | rand();
	rnd_cache[1] ^= newval >> 17;
d1094 1
a1094 2
		rnd_cache[0] ^= (newval << 15) | rand();
		rnd_cache[1] ^= newval >> 17;
@


1.87
log
@merge the nameref code, using mksh standard scoping as discussed
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.86.2.1 2009/08/30 20:56:10 tg Exp $");
d342 1
a342 2
		    "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" :
		    "0123456789abcdefghijklmnopqrstuvwxyz";
@


1.86
log
@the ability to x=([key]=value ...)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.82 2009/08/28 21:01:27 tg Exp $");
d50 2
d140 1
a140 1
 * non-zero if this is an array, sets *valp to the array index, returns
d148 1
d151 1
d153 28
d681 3
d718 20
d861 2
a862 2
 * argument if there is no legal name, returns * a pointer to the terminating
 * null if whole string is legal).
d1298 1
a1298 1
	vp->flag |= ARRAY|DEFINED;
@


1.86.2.1
log
@Implement bound variables (nameref), complete with testsuite

see http://article.gmane.org/gmane.os.miros.general/8916 for
a reason why arrays-6b fails, and why we cannot change nameref-1
to the more realistic “typeset -n v=$1” or define bar after v;
until this is resolved, the code lives in a branch
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.86 2009/08/28 22:44:47 tg Exp $");
a49 2
uint8_t set_refflag = 0;

d138 1
a138 1
 * true if this is an array, sets *valp to the array index, returns
a145 1
	char *ap = NULL;
a147 1
 redo_from_ref:
a148 28
	if (!set_refflag && (p != n) && ksh_isalphx(n[0])) {
		struct block *l = e->loc;
		struct tbl *vp;
		char *vn;
		uint32_t h;

		strndupx(vn, n, p - n, ATEMP);
		h = hash(vn);
		/* check if this is a reference */
		for (l = e->loc; ; l = l->next) {
			if ((vp = ktsearch(&l->vars, vn, h)) != NULL)
				break;
			if (l->next == NULL)
				break;
		}
		afree(vn, ATEMP);
		if (vp && (vp->flag & (DEFINED|ASSOC|ARRAY)) ==
		    (DEFINED|ASSOC)) {
			char *cp;

			/* gotcha! */
			cp = shf_smprintf("%s%s", str_val(vp), p);
			afree(ap, ATEMP);
			n = ap = cp;
			goto redo_from_ref;
		}
	}

a648 3
		if (set_refflag)
			errorf("%s: reference variable cannot be an array",
			    var);
a682 20
	if (set_refflag == 2 && (vp->flag & (ARRAY|ASSOC)) == ASSOC)
		vp->flag &= ~ASSOC;
	else if (set_refflag == 1) {
		if (vp->flag & ARRAY) {
			struct tbl *a, *tmp;

			/* Free up entire array */
			for (a = vp->u.array; a; ) {
				tmp = a;
				a = a->u.array;
				if (tmp->flag & ALLOC)
					afree(tmp->val.s, tmp->areap);
				afree(tmp, tmp->areap);
			}
			vp->u.array = NULL;
			vp->flag &= ~ARRAY;
		}
		vp->flag |= ASSOC;
	}

d806 2
a807 2
 * argument if there is no legal name, returns a pointer to the terminating
 * NUL if whole string is legal).
d1243 1
a1243 1
	vp->flag = (vp->flag | (ARRAY|DEFINED)) & ~ASSOC;
@


1.85
log
@fix type (array indices should be of the unsigned arithmetic type)
@
text
@d1323 3
a1325 1
	mksh_uari_t i;
d1341 22
a1362 2
	for (i = 0; vals[i]; i++) {
		vq = arraysearch(vp, i);
d1364 5
a1368 1
		setstr(vq, vals[i], KSH_RETURN_ERROR);
@


1.84
log
@optimise
@
text
@d1319 1
a1319 1
uint32_t
d1323 1
a1323 1
	uint32_t i;
@


1.83
log
@more int→bool
@
text
@d1318 2
a1319 3
/* Set (or overwrite, if reset) the array variable var to the values in vals.
 */
void
d1344 2
@


1.82
log
@… but since I liked the bonus of having the hval stored so much, merge
it with the array index; var.c says that
│ 1244         /* The table entry is always [0] */
so that we can have a special flag and a union which stores hval for
the table index, the array index otherwise (coïncidentally *hint hint*
they have the same size)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.81 2009/08/28 20:38:43 tg Exp $");
d1318 1
a1318 1
/* Set (or overwrite, if !reset) the array variable var to the values in vals.
d1321 1
a1321 1
set_array(const char *var, int reset, const char **vals)
d1333 1
a1333 1
	if (reset > 0)
@


1.81
log
@for now, until we really use kt*() otherwise, ifdef out tablep/hval
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.80 2009/08/28 20:30:59 tg Exp $");
a1243 1
	vp->index = 0;
d1249 1
a1249 1
	while (curr && curr->index < val) {
d1253 1
a1253 1
	if (curr && curr->index == val) {
d1260 1
a1260 1
	if (!new)
d1262 3
a1264 2
	memcpy(new->name, vp->name, len);
	new->flag = vp->flag & ~(ALLOC|DEFINED|ISSET|SPECIAL);
d1268 1
a1268 1
	new->index = val;
a1271 1
	new->hval = vp->hval;
@


1.80
log
@much better solution: save tablep and hash value¹ in the struct tbl entry
① also saves time during texpand :D

XXX this doesn’t work well with the current indexed-array implementation
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.78 2009/08/28 18:54:01 tg Exp $");
d1269 1
d1273 1
@


1.79
log
@this is a rather stupid diff: give ktsearch/ktenter the capability to
return information needed to do a real ktremove instead of the pseudo
ktdelete operation which merely unsets the DEFINED flag to mark it as
eligible for texpand garbage collection (even worse, !DEFINED entries
are still counted)
@
text
@d131 1
a131 2
		tp = ktenter(&specials, names[i].name, hash(names[i].name),
		    NULL);
d228 1
a228 1
		vp = ktsearch(&l->vars, n, h, NULL);
d238 1
a238 1
	vp = ktenter(&l->vars, n, h, NULL);
d268 1
a268 1
	vp = ktenter(&l->vars, n, h, NULL);
d273 1
a273 2
		while ((ll = ll->next) && !(vq = ktsearch(&ll->vars, n, h,
		    NULL)))
d895 1
a895 2
					vp2 = ktsearch(&l2->vars, vp->name, h,
					    NULL);
d1029 1
a1029 1
	tp = ktsearch(&specials, name, hash(name), NULL);
d1037 1
a1037 1
	struct table_entry te = { NULL, NULL };
d1039 3
a1041 3
	ktsearch(&specials, name, hash(name), &te);
	if (te.ep)
		ktremove(&te);
d1269 4
@


1.78
log
@• use Jenkins’ one-at-a-time hash for mksh keytabs, as it has
  much better avalanche and no known funnels
• improve comments
• fix some types (uint32_t for hash, size_t for sizes)
• optimise ktsort()

no functional change, I think
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.77 2009/08/08 13:08:53 tg Exp $");
d131 2
a132 1
		tp = ktenter(&specials, names[i].name, hash(names[i].name));
d229 1
a229 1
		vp = ktsearch(&l->vars, n, h);
d239 1
a239 1
	vp = ktenter(&l->vars, n, h);
d269 1
a269 1
	vp = ktenter(&l->vars, n, h);
d274 2
a275 1
		while ((ll = ll->next) && !(vq = ktsearch(&ll->vars, n, h)))
d897 2
a898 1
					vp2 = ktsearch(&l2->vars, vp->name, h);
d1032 1
a1032 1
	tp = ktsearch(&specials, name, hash(name));
d1040 1
a1040 1
	struct tbl *tp;
d1042 3
a1044 3
	tp = ktsearch(&specials, name, hash(name));
	if (tp)
		ktdelete(tp);
d1047 2
a1048 2
static	time_t	seconds;		/* time SECONDS last set */
static	int	user_lineno;		/* what user set $LINENO to */
@


1.77
log
@While mksh R39 builds fine on MirOS #7s8E on my trusty sparc, pgcc 2.95.3
throws out quite some warnings – fix most of them except most emitted via
-Wconversion; work around some others; discard bogus warnings.

sync clog
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.76 2009/08/01 20:32:45 tg Exp $");
d128 2
a129 1
	ktinit(&specials, APERM, 16); /* must be 2^n (currently 12 specials) */
a174 1
	unsigned int h;
d176 1
a176 1
	uint32_t val;
a254 1
	unsigned int h;
d256 1
a256 1
	uint32_t val;
d891 1
a891 1
				unsigned int h = hash(vp->name);
@


1.76
log
@more use of memcpy(3) when we know destination and source sizes
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.75 2009/06/11 12:42:21 tg Exp $");
d922 1
a922 1
static char rnd_lastflag = 2;
@


1.75
log
@capitalise AT&T®
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.74 2009/06/10 18:12:51 tg Exp $");
d1242 1
a1242 1
	size_t namelen = strlen(vp->name) + 1;
d1258 1
a1258 2
		else
			new = curr;
d1260 5
a1264 2
		new = alloc(sizeof(struct tbl) + namelen, vp->areap);
	strlcpy(new->name, vp->name, namelen);
@


1.74
log
@more KNF, mostly whitespace, this time more manual labour applying style(9)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.73 2009/06/08 20:06:50 tg Exp $");
d558 1
a558 1
			/* strip trailing spaces (at&t uses qq[-1] == ' ') */
d688 1
a688 1
	/* only allow export flag to be set. at&t ksh allows any attribute to
d1182 1
a1182 1
		/* at&t ksh seems to do this (only listen if integer) */
d1219 1
a1219 1
	case V_TMOUT:		/* at&t ksh leaves previous value in place */
d1223 1
a1223 1
	/* at&t ksh man page says OPTIND, OPTARG and _ lose special meaning,
d1226 1
a1226 1
	 * Don't know what at&t does for:
d1228 1
a1228 1
	 * Unsetting these in at&t ksh does not loose the 'specialness':
d1323 1
a1323 1
	/* Note: at&t ksh allows set -A but not set +A of a read-only var */
@


1.73
log
@some rather mechanical KNF, now that style(9) clarified on the status
of sizeof() as a function-like unary operator; use parenthesēs around
sizeof and return args consistently too
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.72 2009/05/16 16:59:42 tg Exp $");
d136 1
a136 1
/* Used to calculate an array index for global()/local().  Sets *arrayp to
d306 3
a308 2
		/* worst case number length is when base=2, so use BITS(long) */
		/*      minus  base #   number                     NUL */
d654 1
a654 1
		 * setting up its environment.  Allow only simple array
d688 1
a688 1
	/* only allow export flag to be set.  at&t ksh allows any attribute to
d779 1
a779 1
/* Unset a variable.  array_ref is set if there was an array reference in
d824 1
a824 1
/* Return a pointer to the first character past any legal variable name.  */
d1090 1
a1090 1
		/* Do NOT export COLUMNS/LINES.  Many applications
d1223 8
a1230 8
	  /* at&t ksh man page says OPTIND, OPTARG and _ lose special meaning,
	   * but OPTARG does not (still set by getopts) and _ is also still
	   * set in various places.
	   * Don't know what at&t does for:
	   *		HISTSIZE, HISTFILE,
	   * Unsetting these in at&t ksh does not loose the 'specialness':
	   *    no effect: IFS, COLUMNS, PATH, TMPDIR
	   */
d1276 1
a1276 1
 * to point to the open bracket.  Returns 0 if there is no matching closing
d1331 1
a1331 1
	 * completely fail.  Only really effects integer arrays:
@


1.72
log
@• sync distrib/special/mksh/Makefile with bin/mksh/Build.sh and
  fix the regression test’s results while here, which have been
  broken since cid 10049D9BE5254CE65B8
• get rid of separate copyright file which was intended for De-
  bian; track down commits in all files of oksh-mirbsd and mksh
  to get correct copyright years per-file, as is BSD custom
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.71 2009/04/07 19:27:49 tg Exp $");
d60 1
a60 1
	l = alloc(sizeof (struct block), ATEMP);
d162 1
a162 1
	return n;
d197 1
a197 1
			return vp;
d201 1
a201 1
			return vp;
d225 1
a225 1
		return vp;
d231 1
a231 1
				return arraysearch(vp, val);
d233 1
a233 1
				return vp;
d244 1
a244 1
	return vp;
d267 1
a267 1
		return vp;
d290 1
a290 1
	return vp;
d308 1
a308 1
		char strbuf[1 + 2 + 1 + 8 * sizeof (mksh_uari_t) + 1];
d352 1
a352 1
	return s;
d381 1
a381 1
		return 0;
d445 1
a445 1
		return -1;
d448 1
a448 1
		return vp->type;
d496 1
a496 1
			return -1;
d498 1
a498 1
			return -1;
d504 1
a504 1
	return base;
d517 1
a517 1
		return NULL;
d528 1
a528 1
	return vq;
d604 1
a604 1
	return p;
d645 1
a645 1
		return NULL;
d651 1
a651 1
			return NULL;
d662 1
a662 1
					return NULL;
d671 1
a671 1
			return NULL;
d775 1
a775 1
	return vp;
d861 1
a861 1
	return p != s && p[0] == EOS;
d870 1
a870 1
	return p != s && p[0] == CHAR && p[1] == '=';
d948 1
a948 1
			rv = arc4random_pushb(rnd_cache, sizeof (rnd_cache));
d951 1
a951 1
			    sizeof (rnd_cache));
d970 1
a970 1
	arc4random_pushb(&newval, sizeof (newval));
d972 1
a972 1
	arc4random_addrandom((void *)&newval, sizeof (newval));
d1030 1
a1030 1
	return tp && (tp->flag & ISSET) ? tp->type : V_NONE;
d1247 1
a1247 1
		return vp;
d1256 1
a1256 1
			return curr;
d1260 1
a1260 1
		new = alloc(sizeof (struct tbl) + namelen, vp->areap);
d1271 1
a1271 1
	return new;
d1289 2
a1290 2
		return 0;
	return s - cp;
@


1.71
log
@rename env variable to denv
I'm fgrep-w'ing for struct env right now
@
text
@d3 20
d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.70 2009/04/07 19:06:44 tg Exp $");
@


1.70
log
@tabs vs spaces
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.69 2009/03/14 18:12:55 tg Exp $");
d860 1
a860 1
	XPtrV env;
d864 1
a864 1
	XPinit(env, 64);
d887 1
a887 1
				XPput(env, vp->val.s);
d889 2
a890 2
	XPput(env, NULL);
	return (char **) XPclose(env);
@


1.69
log
@sprinkle mksh_ari_t to limit arithmetics to 32 bit even
on Debian Lenny/amd64 (XXX need more verification; this
can be used for 64 bit arithmetics later too)

PPID, PGRP, RANDOM, USER_ID are now unsigned by default
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.68 2008/12/29 21:34:22 tg Exp $");
d18 7
a24 7
static char	*formatstr(struct tbl *, const char *);
static void	export(struct tbl *, const char *);
static int	special(const char *);
static void	unspecial(const char *);
static void	getspec(struct tbl *);
static void	setspec(struct tbl *);
static void	unsetspec(struct tbl *);
@


1.68
log
@always set COLUMNS and LINES; make use of the fact in dot.mkshrc
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.67 2008/12/29 21:05:15 tg Exp $");
d130 1
a130 1
		long rval;
d287 2
a288 2
		/* minus base #     number    null */
		char strbuf[1 + 2 + 1 + 8 * sizeof(long) + 1];
d292 1
a292 1
		unsigned long n;
d297 1
a297 1
			n = (unsigned long) vp->val.i;
d336 1
a336 1
long
d339 1
a339 1
	long num;
d346 1
a346 1
	return num;
d396 1
a396 1
setint(struct tbl *vq, long int n)
d414 1
a414 1
getint(struct tbl *vp, long int *nump, bool arith)
d419 1
a419 1
	long num;
d463 1
a463 1
				*nump = (long)wc;
d494 1
a494 1
	long num;
d1054 1
a1054 1
		setint(vp, (long)histsize);
d1059 1
a1059 1
		setint(vp, (long)user_opt.uoptind);
d1064 1
a1064 1
		setint(vp, (long)current_lineno + user_lineno);
@


1.67
log
@use a more common/generic routine for TIOCGWINSZ;
ensure x_cols and x_lins always have a sane value
after them (even if not tty_fd)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.66 2008/12/29 20:52:10 tg Exp $");
a89 4
		{ "IFS",		V_IFS },
		{ "OPTIND",		V_OPTIND },
		{ "PATH",		V_PATH },
		{ "TMPDIR",		V_TMPDIR },
d94 5
d102 2
a103 2
		{ "LINENO",		V_LINENO },
		{ NULL,	0 }
d108 1
a108 1
	ktinit(&specials, APERM, 16); /* must be 2^n (currently 11 specials) */
d1030 3
a1032 1
	switch (special(vp->name)) {
d1054 1
a1054 1
		setint(vp, (long) histsize);
d1059 1
a1059 1
		setint(vp, (long) user_opt.uoptind);
d1064 14
a1077 1
		setint(vp, (long) current_lineno + user_lineno);
d1086 1
d1134 10
a1143 2
		if ((x_cols = intval(vp)) <= MIN_COLS)
			x_cols = MIN_COLS;
@


1.66
log
@do not lie
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.65 2008/12/13 17:02:18 tg Exp $");
d1294 34
@


1.65
log
@* back out almost all of the memory allocator related changes, as aalloc
  was hard to type and hard to fix, galloc is also hard to fix, and some
  things I learned will probably improve things more but make me use the
  original form as base (especially for space savings)
* let sizeofN die though, remove even more casts
* optimise, polish
* regen Makefiles
* sprinkle a few /* CONSTCOND */ while here
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.64 2008/12/04 18:11:08 tg Exp $");
d107 1
a107 1
	ktinit(&specials, APERM, 32); /* must be 2^n (currently 17 specials) */
@


1.64
log
@rename utf8-hack to utf8-mode (use set -U or set +U instead, anyway)
and announce less hackish things
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.63 2008/11/30 10:33:40 tg Exp $");
d40 1
a40 1
	l = alloc(1, sizeof (struct block), ATEMP);
d42 1
a42 1
	l->areap = anew(Flag(FTALKING) ? 1024 : 64);
d51 2
a52 2
	ktinit(&l->vars, l->areap, 0);
	ktinit(&l->funs, l->areap, 0);
d77 1
a77 1
	adelete(&l->areap);
d526 1
a526 1
	p = alloc(1, (psiz = nlen * /* MB_LEN_MAX */ 3 + 1), ATEMP);
d598 1
a598 1
	xp = alloc(1, namelen + 1 + vallen, vp->areap);
d1215 1
a1215 1
		new = alloc(1, sizeof (struct tbl) + namelen, vp->areap);
@


1.63
log
@if MKSH_SMALL and HAVE_ARC4RANDOM, there is no need to use rand()/srand(3)
ever, since MKSH_SMALL is not required to be as close to compatibility as
normal/generic shells; we can also get rid of time(3) calls
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.62 2008/11/15 09:00:19 tg Exp $");
d306 1
a306 1
			if (!Flag(FUTFHACK) || ((n & 0xFF80) == 0xEF80))
d458 1
a458 1
				if (!Flag(FUTFHACK))
@


1.62
log
@give hints to anew() according to aalloc stats output for testsuite and a
little interactive use, to reduce the number realloc(3) must be called
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.61 2008/11/15 07:35:25 tg Exp $");
d898 1
a898 1
#if HAVE_ARC4RANDOM
d906 3
d941 1
d947 7
d965 1
d968 1
d996 1
@


1.62.2.1
log
@before I’m going to accidentally type “cvs -Rq up -PAd” a̲n̲o̲t̲h̲e̲r̲ time,
better save the current not-so progress into the repo… it segfaults,
and the code to free any memory is not even written, so do not use.
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.62 2008/11/15 09:00:19 tg Exp $");
d40 1
a40 1
	l = galloc(1, sizeof (struct block), ATEMP);
d42 1
a42 2
	l->gp_block = galloc_new(NULL, ATEMP, Flag(FTALKING) ? 1024 : 64
	    GALLOC_VST("newblock"));
d51 2
a52 2
	ktinit(&l->vars, l->gp_block, 0);
	ktinit(&l->funs, l->gp_block, 0);
d77 2
a78 2
	galloc_del(l->gp_block);
	gfree(l, ATEMP);
d135 1
a135 1
		gfree(tmp, ATEMP);
d139 1
a139 1
		gfree(sub, ATEMP);
d167 1
a167 1
		vp->gp_tbl = ATEMP;
d245 1
a245 1
		vp->gp_tbl = ATEMP;
d370 1
a370 1
			gfree(vq->val.s, vq->gp_tbl);
d379 1
a379 1
			strdupx(vq->val.s, s, vq->gp_tbl);
d389 1
a389 1
	gfree(salloc, ATEMP);
d401 1
a401 1
		vp->gp_tbl = ATEMP;
d499 1
a499 1
		gfree(vq->val.s, vq->gp_tbl);
d526 1
a526 1
	p = galloc(1, (psiz = nlen * /* MB_LEN_MAX */ 3 + 1), ATEMP);
d598 1
a598 1
	xp = galloc(1, namelen + 1 + vallen, vp->gp_tbl);
d605 1
a605 1
		gfree(op, vp->gp_tbl);
d673 1
a673 1
	gfree(tvar, ATEMP);
d724 1
a724 1
							gfree(t->val.s, t->gp_tbl);
d730 1
a730 1
					gfree(free_me, t->gp_tbl);
d764 1
a764 1
		gfree(vp->val.s, vp->gp_tbl);
d773 2
a774 2
				gfree(tmp->val.s, tmp->gp_tbl);
			gfree(tmp, tmp->gp_tbl);
d1061 1
a1061 1
			gfree(path, APERM);
d1077 1
a1077 1
			gfree(tmpdir, APERM);
d1141 1
a1141 1
			gfree(path, APERM);
d1152 1
a1152 1
			gfree(tmpdir, APERM);
d1201 1
a1201 1
		new = galloc(1, sizeof (struct tbl) + namelen, vp->gp_tbl);
d1205 1
a1205 1
	new->gp_tbl = vp->gp_tbl;
@


1.61
log
@enable passing of a hint how many pointers we’ll need to anew()
if 0, the default is used
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.60 2008/11/12 00:54:52 tg Exp $");
d42 1
a42 1
	l->areap = anew(0);	/* TODO: could use e->area */
@


1.60
log
@switch to a (nmemb,size) API from a (nmemb*size) API

cost: text += (308, 256, 4, -100)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.59 2008/11/12 00:27:57 tg Exp $");
d42 1
a42 1
	l->areap = anew();	/* TODO: could use e->area */
@


1.59
log
@isolate all knowledge of the area-based allocator from the rest of the code

cost: bss -= (0, 0, 16, 16); text += (520, 504, 516, 480)
[ gcc,pcc X full,small ]
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.58 2008/10/28 14:32:43 tg Exp $");
d40 1
a40 1
	l = (struct block *)alloc(sizeof (struct block), ATEMP);
d370 1
a370 1
			afree((void*)vq->val.s, vq->areap);
d526 1
a526 1
	p = (char *)alloc((psiz = nlen * /* MB_LEN_MAX */ 3 + 1), ATEMP);
d598 1
a598 1
	xp = (char*)alloc(namelen + 1 + vallen, vp->areap);
d605 1
a605 1
		afree((void*)op, vp->areap);
d724 1
a724 2
							afree((void*) t->val.s,
							    t->areap);
d730 1
a730 1
					afree((void *) free_me, t->areap);
d764 1
a764 1
		afree((void*)vp->val.s, vp->areap);
d773 1
a773 1
				afree((void *) tmp->val.s, tmp->areap);
d1201 1
a1201 2
		new = (struct tbl *)alloc(sizeof (struct tbl) + namelen,
		    vp->areap);
@


1.58
log
@• rewrite code to no longer use statements-as-expressions
• optimise a little
• Build.sh: remove HAVE_EXPSTMT test
• Build.sh, */Makefile: sort tests, regenerate
• mksh.hts: sync clog
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.57 2008/07/12 16:56:40 tg Exp $");
d42 1
a42 1
	ainit(&l->area); /* todo: could use e->area (l->area => l->areap) */
d51 2
a52 2
	ktinit(&l->vars, &l->area, 0);
	ktinit(&l->funs, &l->area, 0);
d77 1
a77 1
	afreeall(&l->area);
@


1.57
log
@• syn.c: replace expanded use of str_save() with the actual macro
• others: fix 6 (!) cases of non-constant or side-effect arguments
  to the str_save() or str_nsave() macros, and other abuse of them
• also fix some cosmetics and other un-nice code while here
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.56 2008/05/17 18:47:03 tg Exp $");
d133 1
a133 1
		tmp = str_nsave(p + 1, len - 2, ATEMP);
d136 1
a136 1
		n = str_nsave(n, p - n, ATEMP);
d329 1
a329 1
			s = str_save(s, ATEMP);
d379 1
a379 1
			vq->val.s = str_save(s, vq->areap);
d645 3
a647 4
	if (*val == '=') {
		int i = val++ - var;
		tvar = str_nsave(var, i, ATEMP);
	} else {
d651 1
a651 1
		tvar = str_save(var, ATEMP);
d1064 1
a1064 1
		path = str_save(s, APERM);
d1090 1
a1090 1
				tmpdir = str_save(s, APERM);
d1143 1
a1143 1
		path = str_save(def_path, APERM);
d1243 1
d1247 3
a1249 1
		return str_save(str, ATEMP);
d1251 1
a1251 1
	return str_nsave(str, p - str, ATEMP);
@


1.56
log
@• alloc() can’t fail, afree() can take NULL
  ‣ macro afreechk() is superfluous
• get rid of macro afreechv() by re-doing the “don’t leak that much” code
• some KNF (mostly, whitespace and 80c) while here
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.55 2008/05/02 18:55:37 tg Exp $");
d133 1
a133 1
		tmp = str_nsave(p+1, len-2, ATEMP);
d645 4
a648 3
	if (*val == '=')
		tvar = str_nsave(var, val++ - var, ATEMP);
	else {
@


1.55
log
@thinko: multibyte characters are not always 1 column wide
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.54 2008/04/19 22:15:06 tg Exp $");
d40 1
a40 1
	l = (struct block *) alloc(sizeof(struct block), ATEMP);
d389 1
a389 1
	afreechk(salloc);
d1202 1
a1202 1
		new = (struct tbl *)alloc(sizeof(struct tbl) + namelen,
@


1.54
log
@• more unsigned → unsigned int
• more int → bool
• more regression tests: check if the utf8-hack flag is really disabled
  at non-interactive startup, enabled at interactive startup, if the
  current locale is a UTF-8 one
• make the mksh-local multibyte handling functions globally accessible,
  change their names, syntax and semantics a little (XXX more work needed)
• optimise
• utf_wctomb: src → dst, as we’re writing to that char array (pasto?)
• edit.c:x_e_getmbc(): if the second byte of a 2- or 3-byte multibyte
  sequence is invalid utf-8, ungetc it (not possible for the 3rd byte yet)
• edit.c:x_zotc3(): easier (and faster) handling of UTF-8
• implement, document and test for base-1 numbers: they just get the
  ASCII (8-bit) or Unicode (UTF-8) value of the octet(s) after the ‘1#’,
  or do the same as print \x## or \u#### (depending on the utf8-hack flag),
  plus support the PUA assignment of EF80‥EFFF for the MirBSD encoding “hack”
  (print doesn’t, as it has \x## and \u#### to distinguish, but we cannot use
  base-0 numbers which I had planned to use for raw octets first, as they are
  used internally): http://thread.gmane.org/gmane.os.miros.general/7938
• as an application example, add a hexdumper to the regression tests ☺
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.53 2008/04/19 21:04:09 tg Exp $");
d528 1
a528 1
		int slen = olen, i;
d534 2
a535 2
			for (i = 0; i < slen; ++i)
				utf_widthadj(qq, &qq);
d553 2
a554 4
			while (slen > vp->u2.field) {
				utf_widthadj(s, &s);
				--slen;
			}
@


1.53
log
@if typeset -i -Z<n>, pad the value not the base
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.52 2008/04/19 17:21:55 tg Exp $");
d301 24
a324 10
		*--s = '\0';
		do {
			*--s = digits[n % base];
			n /= base;
		} while (n != 0);
		if (base != 10) {
			*--s = '#';
			*--s = digits[base % 10];
			if (base >= 10)
				*--s = digits[base / 10];
a325 2
		if (!(vp->flag & INT_U) && vp->val.i < 0)
			*--s = '-';
d416 2
a417 3
	int c;
	int base, neg;
	int have_base = 0;
d445 1
a445 1
		have_base++;
d452 13
a464 3
			base = (int) num;
			if (have_base || base < 2 || base > 36)
				return -1;
d466 1
a466 1
			have_base = 1;
d517 1
a517 1
	olen = ksh_mbswidth(s);
@


1.52
log
@• new ksh_mbswidth
• fix: when printing menus (tab expansion, for instance), honour width of
  the multibyte characters printed
• some int→bool while here
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.51 2008/02/24 15:20:52 tg Exp $");
d511 1
d520 12
d537 1
a537 1
				memset(p, (vp->flag & ZEROFIL) ? '0' : ' ',
d539 1
@


1.51
log
@sync w/ oksh
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.50 2007/10/25 16:10:16 tg Exp $");
d494 1
d496 1
a496 1
	olen = strlen(s);
d505 1
a505 1
	p = (char *) alloc(nlen + 1, ATEMP);
d507 1
a507 1
		int slen;
d510 4
a513 1
			const char *qq = s + olen;
d515 1
a515 1
			while (qq > s && ksh_isspace(qq[-1]))
d517 5
a521 4
			slen = qq - s;
			if (slen > vp->u2.field) {
				s += slen - vp->u2.field;
				slen = vp->u2.field;
d527 1
a527 1
			    nlen + 1 - (vp->u2.field - slen),
d540 1
a540 1
		memcpy(p, s, olen + 1);
@


1.51.2.1
log
@MFC: pull up mksh-R34β since it’ll be required by MirPorts soonish…
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.56 2008/05/17 18:47:03 tg Exp $");
d40 1
a40 1
	l = (struct block *)alloc(sizeof (struct block), ATEMP);
d301 10
a310 24
		if (base == 1) {
			size_t sz = 1;

			*(s = strbuf) = '1';
			s[1] = '#';
			if (!Flag(FUTFHACK) || ((n & 0xFF80) == 0xEF80))
				s[2] = n & 0xFF;
			else
				sz = utf_wctomb(s + 2, n);
			s[2 + sz] = '\0';
		} else {
			*--s = '\0';
			do {
				*--s = digits[n % base];
				n /= base;
			} while (n != 0);
			if (base != 10) {
				*--s = '#';
				*--s = digits[base % 10];
				if (base >= 10)
					*--s = digits[base / 10];
			}
			if (!(vp->flag & INT_U) && vp->val.i < 0)
				*--s = '-';
d312 2
d377 1
a377 1
	afree(salloc, ATEMP);
d404 3
a406 2
	int c, base, neg;
	bool have_base = false;
d434 1
a434 1
		have_base = true;
d441 3
a443 13
			base = (int)num;
			if (have_base || base < 1 || base > 36)
				return (-1);
			if (base == 1) {
				unsigned int wc;

				if (!Flag(FUTFHACK))
					wc = *(unsigned char *)s;
				else if (utf_mbtowc(&wc, s) == (size_t)-1)
					wc = 0xEF00 + *(unsigned char *)s;
				*nump = (long)wc;
				return (1);
			}
d445 1
a445 1
			have_base = true;
a493 1
	size_t psiz;
d495 1
a495 1
	olen = utf_mbswidth(s);
d504 1
a504 1
	p = (char *)alloc((psiz = nlen * /* MB_LEN_MAX */ 3 + 1), ATEMP);
d506 1
a506 1
		int slen = olen, i = 0;
d509 1
a509 5
			const char *qq = s;
			int n = 0;

			while (i < slen)
				i += utf_widthadj(qq, &qq);
d511 1
a511 1
			while (qq > s && ksh_isspace(qq[-1])) {
d513 4
a516 13
				--slen;
			}
			if (vp->flag & ZEROFIL && vp->flag & INTEGER) {
				if (s[1] == '#')
					n = 2;
				else if (s[2] == '#')
					n = 3;
				if (vp->u2.field <= n)
					n = 0;
			}
			if (n) {
				memcpy(p, s, n);
				s += n;
a517 2
			while (slen > vp->u2.field)
				slen -= utf_widthadj(s, &s);
d519 1
a519 1
				memset(p + n, (vp->flag & ZEROFIL) ? '0' : ' ',
a520 1
			slen -= n;
d522 1
a522 1
			    psiz - (vp->u2.field - slen),
d535 1
a535 1
		memcpy(p, s, strlen(s) + 1);
d1164 1
a1164 1
		new = (struct tbl *)alloc(sizeof (struct tbl) + namelen,
@


1.51.2.2
log
@MFC: mksh R35b
@
text
@d5 1
a5 1
__RCSID("$MirOS$");
d133 1
a133 1
		tmp = str_nsave(p + 1, len - 2, ATEMP);
d645 3
a647 4
	if (*val == '=') {
		int i = val++ - var;
		tvar = str_nsave(var, i, ATEMP);
	} else {
@


1.51.2.3
log
@MFC: mksh R36b
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.65 2008/12/13 17:02:18 tg Exp $");
d40 1
a40 1
	l = alloc(sizeof (struct block), ATEMP);
d133 1
a133 1
		strndupx(tmp, p + 1, len - 2, ATEMP);
d136 1
a136 1
		strndupx(n, n, p - n, ATEMP);
d306 1
a306 1
			if (!UTFMODE || ((n & 0xFF80) == 0xEF80))
d329 1
a329 1
			strdupx(s, s, ATEMP);
d370 1
a370 1
			afree(vq->val.s, vq->areap);
d379 1
a379 1
			strdupx(vq->val.s, s, vq->areap);
d458 1
a458 1
				if (!UTFMODE)
d526 1
a526 1
	p = alloc((psiz = nlen * /* MB_LEN_MAX */ 3 + 1), ATEMP);
d598 1
a598 1
	xp = alloc(namelen + 1 + vallen, vp->areap);
d605 1
a605 1
		afree(op, vp->areap);
d645 4
a648 3
	if (*val == '=')
		strndupx(tvar, var, val++ - var, ATEMP);
	else {
d652 1
a652 1
		strdupx(tvar, var, ATEMP);
d725 2
a726 1
							afree(t->val.s, t->areap);
d732 1
a732 1
					afree(free_me, t->areap);
d766 1
a766 1
		afree(vp->val.s, vp->areap);
d775 1
a775 1
				afree(tmp->val.s, tmp->areap);
d900 1
a900 1
#if HAVE_ARC4RANDOM && !defined(MKSH_SMALL)
a907 3
#if HAVE_ARC4RANDOM && defined(MKSH_SMALL)
	return (arc4random() & 0x7FFF);
#else
a939 1
#endif
a944 7
#if HAVE_ARC4RANDOM && defined(MKSH_SMALL)
#if HAVE_ARC4RANDOM_PUSHB
	arc4random_pushb(&newval, sizeof (newval));
#else
	arc4random_addrandom((void *)&newval, sizeof (newval));
#endif
#else
a955 1
#endif
a957 1
#if !HAVE_ARC4RANDOM || !defined(MKSH_SMALL)
a984 1
#endif
d1065 1
a1065 1
		strdupx(path, s, APERM);
d1091 1
a1091 1
				strdupx(tmpdir, s, APERM);
d1144 1
a1144 1
		strdupx(path, def_path, APERM);
d1203 2
a1204 1
		new = alloc(sizeof (struct tbl) + namelen, vp->areap);
a1243 1
	char *rv;
d1247 1
a1247 3
		strdupx(rv, str, ATEMP);
	else
		strndupx(rv, str, p - str, ATEMP);
d1249 1
a1249 1
	return (rv);
@


1.50
log
@oeps… unbreak 32-bit array indicēs (or rather, wrap of negative indicēs
into the positive high range) on 64-bit platforms: just always wrap and
ignore the result, remove the nonsensical out-of-range check
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.33 2007/08/02 11:05:54 fgsch Exp $	*/
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.49 2007/10/25 15:23:10 tg Exp $");
d153 1
a153 1
	unsigned h;
d234 1
a234 1
	unsigned h;
d833 1
a833 1
				unsigned h = hash(vp->name);
@


1.49
log
@get rid of u_char, u_int, u_long
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.48 2007/10/25 14:26:53 tg Exp $");
d138 1
a138 2
		if ((long)(*valp = (uint32_t)rval) != rval)
			errorf("%s: subscript %ld out of range", n, rval);
@


1.48
log
@even better: don't require 64-bit types at all
also, improve wording of Build.sh (passive terms)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.47 2007/10/25 14:18:56 tg Exp $");
d28 1
a28 1
static void rnd_set(u_long);
d905 1
a905 1
rnd_set(u_long newval)
d926 1
a926 1
change_random(u_long newval)
@


1.47
log
@only check for 64-bit integer types if needed (arc4random support)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.46 2007/10/18 20:32:33 tg Exp $");
d28 1
a28 1
static void rnd_set(long);
d863 1
a863 1
static uint64_t rnd_cache = 0;
d880 2
a881 1
			rnd_cache ^= rand();
d886 1
a886 1
		if (rnd_cache)
d888 1
a888 1
			rv = arc4random_pushb(&rnd_cache, sizeof (rnd_cache));
d890 1
a890 1
			arc4random_addrandom((void *)&rnd_cache,
d893 1
a893 1
		rnd_cache = 0;
d905 1
a905 1
rnd_set(long newval)
d908 2
a909 1
	rnd_cache ^= (((uint64_t)newval) << 15) | rand();
d932 2
a933 1
		rnd_cache ^= ((uint64_t)rand() << 45) ^ (uint64_t)newval;
@


1.46
log
@first step towards mksh R32 ☺
allow array indices in the uint32_t range (0‥4294967295) and map negatives
into that range; adjust manual page and regression tests; to be used RSN ☻
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.45 2007/09/09 18:06:42 tg Exp $");
d924 1
a924 1
change_random(uint64_t newval)
a927 3
	newval &= 0x00001FFFFFFFFFFF;
	newval |= (uint64_t)rand() << 45;

d930 1
a930 1
		rnd_cache ^= newval;
d939 1
a939 3
	rval += newval & 0x7FFF;
	newval >>= 15;
	rval += newval;
@


1.45
log
@• fix memory leaks found by coverity
  from netbsd via oksh
  we had the NULL pointer deref already fixed
• avoid a bogus not-setting the return value of edit.c:x_file_glob()
  introduced by the above change in oksh
• escape ? as well (but not ] because that’s wrong)
  reminded by cbiere@@netbsd via oksh
• Unsetting a non-existent variable is not an error. See
  http://www.opengroup.org/onlinepubs/009695399/utilities/unset.html
  report from Arkadiusz Miskiewicz; fixed based on
  http://cvs.pld-linux.org diff via oksh but modified slightly
• Be more smart waiting for input for non-interactive scripts.  Fix
  based on a diff from debian:  see their bug#296446 (via oksh)
  modified slightly
  this also fixes cnuke@@’s “mksh busy loop” problem, for which I never
  received a bug report, but the Debian bug page contains a set of two
  scripts to reproduce this before (and no longer after) this commit
• some KNF
• bump version
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.44 2007/08/20 13:57:47 tg Exp $");
d25 2
a26 1
static struct tbl *arraysearch(struct tbl *, int);
d120 1
a120 1
array_index_calc(const char *n, bool *arrayp, int *valp)
d138 1
a138 1
		if (rval < 0 || rval > 2147483647)
a139 1
		*valp = rval;
d155 2
a156 2
	bool	 array;
	int	 val;
d236 2
a237 2
	bool	 array;
	int	 val;
d1145 1
a1145 1
arraysearch(struct tbl *vp, int val)
d1222 1
a1222 1
	int i;
@


1.44
log
@cast to quieten gcc/obsd/sparc64 __CRAZY=Yes
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.30 2006/05/21 18:40:39 otto Exp $	*/
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.43 2007/08/12 13:42:23 tg Exp $");
d341 1
d343 1
d364 1
a364 1
			s = formatstr(vq, s);
d373 1
a373 1
			return 0;
d378 2
a379 1
	return 1;
@


1.43
log
@add “set -o arc4random”, RTFM for details
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.42 2007/07/22 14:01:50 tg Exp $");
d886 2
a887 1
			arc4random_addrandom(&rnd_cache, sizeof (rnd_cache));
@


1.42
log
@• we had an unused variable leftover
• make warning-free for both gcc and xlC
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.41 2007/07/22 13:34:52 tg Exp $");
d26 2
d854 4
a857 2
 * Someone has set the srand() value, therefore from now on
 * we return values from rand() instead of arc4random()
d860 2
a861 1
static int use_rand = 0;
d864 50
d920 1
a920 1
change_random(void)
d922 5
d928 4
a931 1
	if (use_rand)
d933 11
a943 1
		rand();
d994 1
a994 6
#if HAVE_ARC4RANDOM
		if (!use_rand)
			setint(vp, arc4random() & 0x7FFF);
		else
#endif
			setint(vp, rand() & 0x7FFF);
d1034 1
a1034 1
		getopts_reset((int) intval(vp));
d1056 1
a1056 1
		sethistsize((int) intval(vp));
d1070 1
a1070 7
		srand((unsigned int)intval(vp));
#if HAVE_ARC4RANDOM
		use_rand = 1;
#if HAVE_ARC4RANDOM_PUSH
		arc4random_push((unsigned)vp ^ (unsigned)rand());
#endif
#endif
d1091 1
a1091 1
		user_lineno = (unsigned int) intval(vp) - current_lineno - 1;
@


1.41
log
@• support IBM xlC on AIX
• fix all bugs it could find ☺
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.40 2007/07/01 21:10:29 tg Exp $");
d344 1
a344 1
			errorf("");
d693 1
a693 1
			errorf("");
@


1.40
log
@Borland C++ found these
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.39 2007/06/06 23:28:17 tg Exp $");
d344 1
a344 1
			errorf(null);
d693 1
a693 1
		    errorf(null);
@


1.39
log
@ok, icc _did_ track down a few ones, and I fixed errno abuse a little too
however, bad S/N ratio

side effect bonus: smaller code size now
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.38 2007/05/13 17:51:24 tg Exp $");
d817 1
a817 1
	struct block *l = e->loc;
@


1.38
log
@Fix for Coverity CID#2: false bug, but still a problem.
Analysis:
internal_errorf(int, fmt, ...) was only a __dead function if the int argument
was non-0, which the Prevent probably was unable to follow. Change all uses of
internal_errorf(0, fmt, ...) to internal_warningf(fmt, ...); change the pro-
totype of internal_errorf() to internal_errorf(fmt, ...) and all remaining
uses remove the non-0 int argument; add __dead to internal_errorf() proto;
flesh out guts of internal_errorf() and internal_warningf() into a new local
function for optimisation purposes.

Some whitespace cleanup and dead code removal (return after internal_errorf(1))
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.37 2007/03/04 03:04:28 tg Exp $");
d956 2
a957 1
		path = str_save(str_val(vp), APERM);
@


1.37
log
@• remove strcasestr.c, use home-grown implementation¹, call it stricmp,
  and have it return an API-correct const char *
• enhance and stylify comments
• a little KNF and simplifications
• #ifdef DEBUG: replace strchr and strstr with ucstrchr and ucstrstr
  that take and return a non-const char *, and fix the violations
• new cstrchr, cstrstr (take and give const char *)
• new vstrchr, vstrstr (take const or not, give boolean value)
• new afreechk(x) = afreechv(x,x) = if (x1) afree(x2, ATEMP)
• new ksh_isdash(str) = (str != NULL) && !strcmp(str, "-")
• replace the only use of strrchr with inlined code to shrink
• minor man page fixes
• Minix 3 signames are autogenerated with gcc
• rename strlfun.c to strlcpy.c since we don't do strlcat(3) anyway,
  only strlcpy(3), and shorten it
• dot.mkshrc: move MKSH=… down to the export line
  to not disturb the PS1 visual impression ☺
• dot.mkshrc: Lstripcom(): optimise
• bump version

¹) side effect from creating API-correct cstrchr, cstrstr, etc.
   uses goto so it must be better ☻

tested on mirbsd-current via both Makefile and Build.sh
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.36 2007/03/04 00:13:17 tg Exp $");
d352 1
a352 1
				internal_errorf(true,
@


1.37.2.1
log
@MFC most of the bugfixes from post-R29d to the R29stable branch (which
is tagged off R29d), i.e. the following commitids:
• 1004638EE466466C614
• 100464368A065F40C08
• 10046436B6D392D622C
• 10046436DC35AC3B04F
• 100464370BA2BF5141D
• 10046474FB1292DF336
• 100464753C139AD7515
• 100464755C253EE3EA9
• 100464759DE15635029
• 10046475DAE4D3D3C05
• 100464760593612AAF2
• 100464763537E100BDF
• 1004647649434DA3FE1
but not
• 1004636486176FDA6FF
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.37 2007/03/04 03:04:28 tg Exp $");
d352 1
a352 1
				internal_errorf(
@


1.37.2.2
log
@MFC:
• some harmless optimisations
• remove the -fno-tree-vrp and -fwhole-program --combine stuff
• fix a typo
• fix check for __attribute__
• remove the multi idstring check, always use ours
• fix signal stuff
• fix types
• pick up arc4random.c
• don't execute ELF, ECOFF, a.out, PE, gzip, etc. as shell script
• some regression test fixes
• fix large file support

bump version, this is gonna be R29g, but we've got to test that first
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.37.2.1 2007/05/13 19:29:40 tg Exp $");
d817 1
a817 1
	struct block *l;
@


1.36
log
@merge the const branch +- a few
@
text
@d5 1
a5 1
__RCSID("$MirOS$");
d1142 1
a1142 1
	if ((p = strchr(str, '[')) == 0)
@


1.35
log
@mirtoconf the checks if to use persistent history support
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.34 2007/01/15 02:48:28 tg Exp $");
d35 1
a35 1
	static char *empty[] = { null };
d1152 1
a1152 1
set_array(const char *var, int reset, char **vals)
@


1.34
log
@shrink .data a little
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.33 2006/11/19 16:43:43 tg Exp $");
d91 1
a91 1
#ifdef V_HISTFILE
d990 1
a990 1
#ifdef V_HISTFILE
@


1.33
log
@make mksh compatible to the AT&T ksh spec which says, according to
twkm (from #ksh on freenode), that $RANDOM is always an unsigned
15-bit decimal integer.

(RANDOM << 15 | RANDOM) thusly yields 30 bit, which is still more
than 36^5, so we can use it on the baselife CD to speed things up
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.32 2006/11/12 14:58:16 tg Exp $");
d35 1
a35 1
	static char *empty[] = {null};
@


1.33.2.1
log
@merge -rHEAD as of now into the const-correctness branch
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.35 2007/03/03 21:36:08 tg Exp $");
d35 1
a35 1
	static char *empty[] = { null };
d91 1
a91 1
#if HAVE_PERSISTENT_HISTORY
d990 1
a990 1
#if HAVE_PERSISTENT_HISTORY
@


1.33.2.2
log
@finish constification for now, passes regression tests but untested
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.33.2.1 2007/03/03 21:38:00 tg Exp $");
d35 1
a35 1
	static const char *empty[] = { null };
d1152 1
a1152 1
set_array(const char *var, int reset, const char **vals)
@


1.32
log
@remove all but these __CRAZY=Yes build warnings:
 main.c: In function 'main':
 main.c:208: warning: cast discards qualifiers from pointer target type
 main.c:329: warning: cast discards qualifiers from pointer target type

no warnings at autoconf time left either; will take care of these two later
(might revisit changes from this commit), maybe change declararion for the
builtins to have their argv[] be const strings, and go through strict type
and qualifier checking again. this'll further improve stability.

XXX these changes might have introduced (more?) memory leaks,
XXX someone who knows about these tools should verify with
XXX automatic memory usage analysers (valgrind?)

still passes testsuite
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.31 2006/11/10 07:52:04 tg Exp $");
d856 1
a856 1
int use_rand = 0;
d922 2
a923 4
		if (use_rand)
#endif
			setint(vp, (long) (rand() & 0x7FFF));
#if HAVE_ARC4RANDOM
a924 1
			setint(vp, arc4random() & 0x7FFFFFFF);
d926 1
@


1.31
log
@hand-sorted ctypes/chtypes upgrade; use table-driven where they make
sense and preprocessored otherwise; unify the logic
saves 144t 1i and lots of cpp(1) time, as well as improves readability
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.30 2006/11/10 07:18:58 tg Exp $");
d35 1
a35 1
	static char *const empty[] = {null};
d42 1
a42 1
		l->argv = (char **) empty;
d609 1
a609 1
		tvar = (char *) var;
d631 1
a631 2
	if (val)
		afree(tvar, ATEMP);
d747 1
a747 1
char *
d758 1
a758 1
	return (char *) s;
d762 1
a762 1
char *
d790 1
a790 1
	return (char *) s;
d797 1
a797 1
	char *p = skip_wdvarname(s, aok);
d806 1
a806 1
	char *p = skip_wdvarname(s, true);
d1146 1
a1146 1
		return (char *) str;
@


1.30
log
@* use only macros for ctype stuff any more
  XXX one of these uses a gcc extension, ok for now tho
* don't include <ctype.h> any more at all
* don't try nl_langinfo in small mode, just check locale

saves 171 .text, 4 .data, 256 .bss, 1 import
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.29 2006/11/10 06:53:27 tg Exp $");
d160 1
a160 1
	if (!letter(c)) {
d168 2
a169 2
		if (digit(c)) {
			for (c = 0; digit(*n); n++)
d240 1
a240 1
	if (!letter(*n)) {
d435 1
d442 10
a451 13
		} else if (letnum(c)) {
			if (ksh_isdigit(c))
				c -= '0';
			else if (ksh_islower(c))
				c -= 'a' - 10;
			else if (ksh_isupper(c))
				c -= 'A' - 10;
			else
				c = -1; /* _: force error */
			if (c < 0 || c >= base)
				return -1;
			num = num * base + c;
		} else
d453 1
d598 1
a598 1
				if (!digit(val[i]))
d753 2
a754 2
	if (s && letter(*s)) {
		while (*++s && letnum(*s))
d767 1
a767 1
	if (s[0] == CHAR && letter(s[1])) {
d770 1
a770 1
		} while (s[0] == CHAR && letnum(s[1]));
@


1.29
log
@since so many internal things hardcode 'C' locale anyway,
use own is{digit,lower,upper} macros that go via byte ranges

doesn't affect utf-8 hack because these only operate on single bytes anyway
saves 224t
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.28 2006/11/10 06:45:28 tg Exp $");
d508 1
a508 1
			while (qq > s && isspace((unsigned char)qq[-1]))
d523 1
a523 1
			while (isspace((unsigned char)*s))
d536 1
a536 1
			*q = _toupper((unsigned char)*q);
d539 1
a539 1
			*q = _tolower((unsigned char)*q);
@


1.28
log
@use tolower_() and toupper_() macros (if not available, our quick 'C' ones)
76t 8d 2i
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.27 2006/11/10 06:16:25 tg Exp $");
d442 1
a442 1
			if (isdigit(c))
d444 4
a447 4
			else if (islower(c))
				c -= 'a' - 10; /* todo: assumes ascii */
			else if (isupper(c))
				c -= 'A' - 10; /* todo: assumes ascii */
d536 1
a536 2
			if (islower((unsigned char)*q))
				*q = _toupper((unsigned char)*q);
d539 1
a539 2
			if (isupper((unsigned char)*q))
				*q = _tolower((unsigned char)*q);
@


1.27
log
@don't use setreuid(2) etc. stuff, like OpenBSD
only affects suid shell scripts, which are *ugh* anyway,
and I really have no idea what the old code did, when, why, etc.
262t 16d 2i
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.26 2006/11/10 05:23:14 tg Exp $");
d78 1
a78 1
/* called by main() to initialize variable data structures */
d537 1
a537 1
				*q = toupper((unsigned char)*q);
d541 1
a541 1
				*q = tolower((unsigned char)*q);
@


1.26
log
@if MKSH_SMALL, disable persistent history code as well (like on Solaris,
where it can't work anyway), and fix that code to shrink
saves 2071t 20d 5i
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.25 2006/11/10 04:22:13 tg Exp $");
d986 1
a986 1
			if (s[0] == '/' && eaccess(s, W_OK|X_OK) == 0 &&
a1182 23

int
eaccess(const char *pathname, int mode)
{
	bool need_uid, need_gid;
	int rv, _errno;

	if ((need_gid = (kshgid != kshegid)))
		setregid(kshegid, kshgid);
	if ((need_uid = (kshuid != ksheuid)))
		setreuid(ksheuid, kshuid);

	rv = access(pathname, mode);
	_errno = errno;

	if (need_gid)
		setregid(kshgid, kshegid);
	if (need_uid)
		setreuid(kshuid, ksheuid);

	errno = _errno;
	return (rv);
}
@


1.25
log
@more cleanup; incidentally, replacing libc function with syscall maybe speedup
9t 4d 1i
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.24 2006/11/10 01:13:52 tg Exp $");
d91 1
d93 1
d996 1
d1000 1
@


1.24
log
@* check.t: add new regression test "typeset-padding-1" according to TFM
* edit.c: remove debug stuff again; next time better use shl.c functions ;)
* sh.h: add format attributes to a few shf functions
* histrap.c, var.c: fix format string mistakes
* main.c, sh.h: error_prefix and warningf take bool not int
* misc.c: make chvt() stuff use shf_* functions
* misc.c: rewrite the TIOCSTTY stuff to be better integrated in mksh,
  since it originally was an external patch
* misc.c: chvt() no longer fails if e.g. chown fails due to e.g. R/O / fs
* var.c: fix typeset padding for right-justified zero-filled
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.23 2006/08/18 18:48:26 tg Exp $");
d913 6
a918 2
		if (vp->flag & ISSET)
			setint(vp, (long) (time(NULL) - seconds));
d1014 6
a1019 1
		seconds = time(NULL) - intval(vp);
@


1.23
log
@restrict RANDOM to a positive 31-bit integer number, for use with modulo op
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.21 2006/07/11 14:51:01 tg Exp $");
d513 6
a518 4
			shf_snprintf(p, nlen + 1,
				((vp->flag & ZEROFIL) && digit(*s)) ?
					  "%0*s%.*s" : "%*s%.*s",
				vp->u2.field - slen, null, slen, s);
@


1.22
log
@as long as we're using arc4random(3) to generate $RANDOM,
let it be an uint32_t, like nbsh(1)
@
text
@d920 1
a920 1
			setint(vp, (long) (rand() & 0x7fff));
d923 1
a923 1
			setint(vp, arc4random());
@


1.21
log
@* TNF needs more to silence char subscript warnings (on 3.0-stable)
* bump vsn
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.20 2006/07/03 12:16:31 tg Exp $");
d923 1
a923 1
			setint(vp, (long) (arc4random() & 0x7fff));
@


1.21.2.1
log
@merge diffs between tg-mksh-plan9ape_BASE and current HEAD
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.23 2006/08/18 18:48:26 tg Exp $");
d920 1
a920 1
			setint(vp, (long) (rand() & 0x7FFF));
d923 1
a923 1
			setint(vp, arc4random() & 0x7FFFFFFF);
@


1.21.2.2
log
@move tg-mksh-plan9ape_BASE to current cvs HEAD and sync tg-mksh-plan9ape branch
@
text
@@


1.21.2.3
log
@merge the latest results of HEAD in here
and bring back the probably-problematic
chunk with a fat comment
@
text
@@


1.20
log
@fix the "char subscripts" issue, bump version
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.19 2006/06/21 19:35:38 tg Exp $");
d533 1
a533 1
				*q = toupper(*q);
d537 1
a537 1
				*q = tolower(*q);
@


1.19
log
@new conditional: HAVE_ARC4RANDOM_PUSH
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.18 2006/05/26 22:17:21 tg Exp $");
d506 1
a506 1
			while (qq > s && isspace(qq[-1]))
d519 1
a519 1
			while (isspace(*s))
d532 1
a532 1
			if (islower(*q))
d536 1
a536 1
			if (isupper(*q))
@


1.18
log
@pull in last OpenBSD diff - I must admit I neither fully understand
the diff nor the commit message, but they're probably knowing what
they're doing

on an unrelated side note, mksh-beta.cpio.gz didn't get tested by
many people... so mksh R27 will be released without much more...

Set the index of item[0], since it might not have been set before
(A=0; A[1]=1) and do not use a static buffer in str_val, since the
results might be used in a loop. Report from jared r r spiegel; help
from Matthias Kilian; ok beck@@
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.17 2006/05/10 18:54:13 tg Exp $");
d1000 1
a1000 1
#if defined(__MirBSD__) && (MirBSD >= 0x07AD)
@


1.17
log
@apply some fixes from OpenBSD and don't apply some others
but sync RCS IDs for easier future adaption:
* Simplify savefd() by removing the "noclose" flag and make noclose
  behavior the default. Almost all uses of savefd() are followed
  by an implicit or explicit close.
* fix typos
* might as well make ksh_getopt() match real getopt(), ie. get rid of that
  stupid EOF concept that was never true. adobriyan@@gmail
* use SEEK_* for lseek()
* fix lint comments, no functional changes
* remove excessive optimization; from adobriyan@@gmail
* only santa checks things twice; from adobriyan@@gmail
* Interpret zero-filled numbers as decimal; PR 4213; from Alexey Dobriyan
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.29 2006/03/13 08:21:37 otto Exp $	*/
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.16 2006/01/30 12:37:24 tg Exp $");
d284 1
a284 1
		static char strbuf[1 + 2 + 1 + 8 * sizeof(long) + 1];
d313 2
d1075 1
a1075 1

d1077 1
a1077 2
	if (val == 0) {
		vp->index = 0;
a1078 1
	}
@


1.16
log
@* update to mksh R26c
* there is no comma in front of "which" in English, I was taught
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.28 2005/12/11 20:31:21 otto Exp $	*/
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.15 2006/01/29 20:16:51 tg Exp $");
d421 3
@


1.15
log
@forgot one use_rand, found on Solaris
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.14 2006/01/29 20:10:16 tg Exp $");
d586 1
a586 1
		 * is preformed on the [expression], which would be a major
d619 1
a619 2
	 * be changed, which means it can be truncated or modified
	 * (-L/-R/-Z/-i).
@


1.14
log
@optimise the non-arc4random case while not touching the default case
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.13 2006/01/29 20:04:54 tg Exp $");
d994 1
d996 1
a996 1
#if defined(__MirBSD__) && HAVE_ARC4RANDOM && (MirBSD >= 0x07AD)
d999 1
@


1.13
log
@sync with OpenBSD: remove unused code and vars; name clash with libc
compiles under MirBSD
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.12 2005/11/22 18:40:44 tg Exp $");
d16 2
a17 2
static	struct tbl vtemp;
static	struct table specials;
d851 3
a853 1
int use_rand = !HAVE_ARC4RANDOM;
d863 1
d865 1
d913 1
d915 1
@


1.12
log
@* only have one $MirOS RCS ID per file to shrink source size
  (this is an exception from normal use)
* bump to R26
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.27 2005/10/08 18:02:59 otto Exp $	*/
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.11 2005/10/29 07:55:51 tg Exp $");
d48 2
a49 2
	tinit(&l->vars, &l->area, 0);
	tinit(&l->funs, &l->area, 0);
d102 1
a102 1
	tinit(&specials, APERM, 32); /* must be 2^n (currently 17 specials) */
d104 1
a104 1
		tp = tenter(&specials, names[i].name, hash(names[i].name));
d204 1
a204 1
		vp = tsearch(&l->vars, n, h);
d214 1
a214 1
	vp = tenter(&l->vars, n, h);
d245 1
a245 1
	vp = tenter(&l->vars, n, h);
d250 1
a250 1
		while ((ll = ll->next) && !(vq = tsearch(&ll->vars, n, h)))
d829 1
a829 1
					vp2 = tsearch(&l2->vars, vp->name, h);
d875 1
a875 1
	tp = tsearch(&specials, name, hash(name));
d885 1
a885 1
	tp = tsearch(&specials, name, hash(name));
d887 1
a887 1
		tdelete(tp);
@


1.11
log
@not all MirOS BSD revisions have had arc4random_push()
for example, good old #7-stable on my sparc
@
text
@a0 1
/**	$MirOS: src/bin/mksh/var.c,v 1.10 2005/10/25 19:53:29 tg Exp $ */
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.10 2005/10/25 19:53:29 tg Exp $");
@


1.10
log
@* move _all_ #include stuff into sh.h
* sort out #include stuff which isn't necessary on MirOS into compat.h
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/var.c,v 1.9 2005/10/21 11:55:23 tg Exp $ */
d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.9 2005/10/21 11:55:23 tg Exp $");
d990 1
a990 1
#if defined(__MirBSD__) && HAVE_ARC4RANDOM
@


1.9
log
@Tell user which value of index is out of bounds. ok deraadt@@
From otto@@obsd
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/var.c,v 1.8 2005/07/04 12:34:24 tg Exp $ */
a4 3
#include <sys/stat.h>
#include <ctype.h>
#include <time.h>
d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.8 2005/07/04 12:34:24 tg Exp $");
@


1.8
log
@get rid of $PGRP
get rid of special bourne-shell emulating mode
@
text
@d1 2
a2 2
/**	$MirOS: src/bin/mksh/var.c,v 1.7 2005/07/04 12:07:41 tg Exp $ */
/*	$OpenBSD: var.c,v 1.26 2005/03/30 17:16:37 deraadt Exp $	*/
d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.7 2005/07/04 12:07:41 tg Exp $");
d138 1
a138 1
			errorf("%s: subscript out of range", n);
@


1.7
log
@mksh now does not look at $EDITOR and $VISUAL any more to determine
the editing mode; default is emacs (vi and gmacs off).
mksh also defaults to emacs-usemeta=OFF now.
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/var.c,v 1.6 2005/05/28 21:11:35 tg Exp $ */
d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.6 2005/05/28 21:11:35 tg Exp $");
a100 1
		{ "PGRP",		V_PGRP },
a935 5
	case V_PGRP:
		vp->flag &= ~SPECIAL;
		setint(vp, getpgrp());
		vp->flag |= SPECIAL;
		break;
@


1.6
log
@another conditional missed, only affects MirOS
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/var.c,v 1.5 2005/05/26 23:01:30 tg Exp $ */
d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.5 2005/05/26 23:01:30 tg Exp $");
a96 2
		{ "EDITOR",		V_EDITOR },
		{ "VISUAL",		V_VISUAL },
a990 7
	case V_VISUAL:
		set_editmode(str_val(vp));
		break;
	case V_EDITOR:
		if (!(global("VISUAL")->flag & ISSET))
			set_editmode(str_val(vp));
		break;
d1057 1
a1057 2
	   *    no effect: IFS, COLUMNS, PATH, TMPDIR,
	   *		VISUAL, EDITOR,
@


1.5
log
@* fix logic for srand() I got reversed
* introduce HAVE_ARC4RANDOM tristate (0/1/undef) and fill it appropriately
* NetBSD(R) joins the list of OSes which don't have arc4random
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/var.c,v 1.4 2005/05/25 13:46:02 tg Exp $ */
d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.4 2005/05/25 13:46:02 tg Exp $");
d1008 1
a1008 1
#ifdef __MirBSD__
@


1.4
log
@make setuid/setgid scripts and access() work again
by reverting some OpenBSD and applying some Debian diff
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/var.c,v 1.3 2005/05/23 15:36:56 tg Exp $ */
d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.3 2005/05/23 15:36:56 tg Exp $");
d858 1
a858 5
#if !defined(__gnu_linux__) && !defined(__INTERIX) && !defined(__sun__)
int use_rand = 0;
#else
int use_rand = 1;
#endif
d918 1
a918 1
#if !defined(__gnu_linux__) && !defined(__INTERIX) && !defined(__sun__)
@


1.3
log
@no persistent history (flock missing), no arc4random, etc. for Solaris
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/var.c,v 1.2 2005/05/23 14:22:03 tg Exp $ */
d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.2 2005/05/23 14:22:03 tg Exp $");
d984 1
a984 1
			if (s[0] == '/' && access(s, W_OK|X_OK) == 0 &&
d1182 23
@


1.2
log
@always use rand(3) on platforms without arc4random(3) and seed it
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/var.c,v 1.1 2005/05/23 03:06:10 tg Exp $ */
d9 1
a9 1
__RCSID("$MirOS: src/bin/mksh/var.c,v 1.1 2005/05/23 03:06:10 tg Exp $");
d858 1
a858 1
#if !defined(__gnu_linux__) && !defined(__INTERIX)
d922 1
a922 1
#if !defined(__gnu_linux__) && !defined(__INTERIX)
@


1.1
log
@Add mirbsdksh R21, which was developed in a temporary external CVS repo-
sitory whose ChangeLog follows. mksh R21 is licenced under the MirOS li-
cence, shown in "sh.h", and a two-clause UCB-style licence by Marc Espie
as shown in "alloc.c".

This executable is a fair bit smaller and shorter than our /bin/ksh that
it is designed to eventually replace (as /bin/sh hardlink), with the old
/bin/ksh to completely vanish. It is still in beta testing though, and I
don't think it will compile on other operating systems.

mksh R21 is a completely new port, bringing together the OpenBSD-current
/bin/ksh, the MirOS-current /bin/ksh and the older mksh R20 (which still
was portable, ocvs-based).
@
text
@d1 1
a1 1
/**	$MirOS: mksh/var.c,v 1.10 2005/05/23 02:20:36 tg Exp $ */
d9 1
a9 1
__RCSID("$MirOS: mksh/var.c,v 1.10 2005/05/23 02:20:36 tg Exp $");
d858 1
d860 3
d922 1
d925 1
@

