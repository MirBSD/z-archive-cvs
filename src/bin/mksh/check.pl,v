head	1.50;
access;
symbols
	mksh-R57:1.49
	mksh-R56c:1.49
	mksh-R56b:1.49
	mksh-R56:1.49
	mksh-R55:1.42
	mksh-R54:1.42
	mksh-R53a:1.42
	mksh-R53:1.42
	mksh-R52c:1.42
	mksh-R52b:1.42
	mksh-R52:1.42
	mksh-R51:1.40
	mksh-R50f:1.37.2.1
	mksh-R50e:1.37
	mksh-R50stable:1.37.0.2
	mksh-R50d:1.37
	mksh-R50c:1.37
	mksh-R50b:1.37
	mksh-R50:1.36
	mksh-R49:1.34
	mksh-R48b:1.32
	mksh-R48:1.32
	mksh-R47:1.32
	mksh-R46:1.31
	mksh-R45:1.31
	mksh-R44:1.31
	mksh-R43:1.31
	mksh-R42b:1.31
	mksh-R41c:1.31
	mksh-R41b:1.31
	mksh-R42:1.31
	mksh-R41:1.31
	mksh-R41stable:1.31.0.8
	mksh-wheezy:1.31.0.6
	tg-multikey-bind:1.31.0.4
	mksh-R40f:1.31
	mksh-R40e:1.27
	mksh-R40d:1.27
	mksh-R40c:1.27
	mksh-R40b:1.27
	mksh-R40stable:1.31.0.2
	mksh-R40:1.27
	mksh-R39c:1.23
	mksh-R39b:1.23
	tg-wcswidth-behaviour:1.23.0.6
	tg-nameref:1.23.0.4
	mksh-R39:1.23
	tg-mksh-printf-builtin:1.23.0.2
	mksh-R38c:1.23
	mksh-R38b:1.22
	mksh-R38:1.22
	mksh-R37c:1.21
	mksh-R37b:1.20
	mksh-R37:1.20
	mksh-R36b:1.18
	tg-aalloc-experimental_BASE:1.18
	tg-aalloc-experimental:1.18.0.2
	mksh-R36:1.18
	mksh-R35b:1.18
	mksh-R35:1.17
	mksh-R33d:1.17
	mksh-R33c:1.17
	mksh-R33b:1.15
	MIRBSD_10:1.14.0.2
	MIRBSD_10_BASE:1.14
	mksh-R33:1.14
	mksh-R32:1.12
	mksh-R31d:1.11
	mksh-R31c:1.11
	mksh-R31b:1.11
	mksh-R31:1.11
	mksh-R30:1.11
	mksh-R29g:1.10.2.1
	mksh-R29f:1.10
	mksh-R29e:1.10
	mksh-R29stable:1.10.0.2
	mksh-R29d:1.10
	mksh-R29c:1.10
	mksh-R29b:1.10
	mksh-R29:1.10
	mksh-R28:1.8
	tg-mksh-plan9ape_BASE:1.8
	tg-mksh-plan9ape:1.8.0.2
	mksh-R27e:1.8
	MIRBSD_9_BASE:1.8
	mksh-R27d:1.8
	mksh-R27:1.8
	mksh-R26c:1.7
	mksh-R26b:1.7
	MIRBSD_8:1.7.0.2
	MIRBSD_8_BASE:1.7
	mksh-R26:1.7
	mksh-R25:1.7
	mksh-R24c:1.7
	mksh-R24b:1.7
	mksh-R24:1.7
	mksh-R23:1.6
	mksh-R22:1.4
	mksh-R21:1.2;
locks; strict;
comment	@# @;


1.50
date	2019.08.01.20.05.55;	author tg;	state Exp;
branches;
next	1.49;
commitid	1005D4346313A1F50F7;

1.49
date	2017.05.05.21.17.31;	author tg;	state Exp;
branches;
next	1.48;
commitid	100590CEBF0559EFD63;

1.48
date	2017.05.05.19.43.50;	author tg;	state Exp;
branches;
next	1.47;
commitid	100590CD60A12E221FB;

1.47
date	2017.05.03.14.51.15;	author tg;	state Exp;
branches;
next	1.46;
commitid	1005909EE7C16B07DC3;

1.46
date	2017.05.03.13.00.10;	author tg;	state Exp;
branches;
next	1.45;
commitid	1005909D44A1764451B;

1.45
date	2017.05.01.19.43.23;	author tg;	state Exp;
branches;
next	1.44;
commitid	10059078FEA4E4D59FA;

1.44
date	2017.04.29.15.18.25;	author tg;	state Exp;
branches;
next	1.43;
commitid	1005904AECA3AA1265A;

1.43
date	2017.04.20.21.43.43;	author tg;	state Exp;
branches;
next	1.42;
commitid	10058F92BA30219649E;

1.42
date	2015.11.29.17.05.00;	author tg;	state Exp;
branches;
next	1.41;
commitid	100565B305567B17D70;

1.41
date	2015.09.05.19.19.01;	author tg;	state Exp;
branches;
next	1.40;
commitid	10055EB402C54C3076B;

1.40
date	2015.07.10.19.36.31;	author tg;	state Exp;
branches;
next	1.39;
commitid	10055A01EBD784EE31A;

1.39
date	2015.04.29.19.01.03;	author tg;	state Exp;
branches;
next	1.38;
commitid	10055412A87373F0346;

1.38
date	2015.03.08.22.54.31;	author tg;	state Exp;
branches;
next	1.37;
commitid	10054FCD1444FC13F3C;

1.37
date	2014.08.19.07.43.32;	author tg;	state Exp;
branches
	1.37.2.1;
next	1.36;
commitid	10053F3003167A3274C;

1.36
date	2014.06.09.13.25.50;	author tg;	state Exp;
branches;
next	1.35;
commitid	1005395B5803902C8E9;

1.35
date	2014.01.25.22.45.49;	author tg;	state Exp;
branches;
next	1.34;
commitid	10052E43E9D6EF636CF;

1.34
date	2013.12.15.15.45.31;	author tg;	state Exp;
branches;
next	1.33;
commitid	10052ADCEB20D3DEE89;

1.33
date	2013.11.30.17.11.06;	author tg;	state Exp;
branches;
next	1.32;
commitid	100529A1C3101314DEC;

1.32
date	2013.07.21.18.35.56;	author tg;	state Exp;
branches;
next	1.31;
commitid	10051EC29F9411252FA;

1.31
date	2012.04.06.12.22.14;	author tg;	state Exp;
branches;
next	1.30;
commitid	1004F7EDFF343FC4991;

1.30
date	2012.04.01.04.03.08;	author tg;	state Exp;
branches;
next	1.29;
commitid	1004F77D3936DACC53E;

1.29
date	2012.03.31.18.47.20;	author tg;	state Exp;
branches;
next	1.28;
commitid	1004F77514E6A88AED9;

1.28
date	2012.03.26.21.06.34;	author tg;	state Exp;
branches;
next	1.27;
commitid	1004F70DA714DF69B88;

1.27
date	2011.05.29.02.18.47;	author tg;	state Exp;
branches;
next	1.26;
commitid	1004DE1AD11046BEFFC;

1.26
date	2011.03.28.21.58.05;	author tg;	state Exp;
branches;
next	1.25;
commitid	1004D91046C6E5458E6;

1.25
date	2011.03.28.21.15.05;	author tg;	state Exp;
branches;
next	1.24;
commitid	1004D90FA4606EFF9E3;

1.24
date	2011.02.27.19.29.19;	author tg;	state Exp;
branches;
next	1.23;
commitid	1004D6AA624642CC00C;

1.23
date	2009.06.10.18.12.43;	author tg;	state Rel;
branches;
next	1.22;
commitid	1004A2FF7913BD44883;

1.22
date	2009.05.16.16.59.32;	author tg;	state Rel;
branches;
next	1.21;
commitid	1004A0EF0664EF4168D;

1.21
date	2009.04.07.18.45.19;	author tg;	state Stab;
branches;
next	1.20;
commitid	10049DB9F4A46650D6F;

1.20
date	2009.03.22.16.59.18;	author tg;	state Exp;
branches;
next	1.19;
commitid	10049C66E796B2CE34D;

1.19
date	2008.12.20.20.21.19;	author tg;	state Exp;
branches;
next	1.18;
commitid	100494D53B65FF28FC9;

1.18
date	2008.07.14.14.53.23;	author tg;	state Exp;
branches;
next	1.17;
commitid	100487B68631B3D00C3;

1.17
date	2008.04.01.16.26.42;	author tg;	state Exp;
branches;
next	1.16;
commitid	10047F262500C561EB4;

1.16
date	2008.04.01.16.01.45;	author tg;	state Exp;
branches;
next	1.15;
commitid	10047F25C6F4BD3F9BA;

1.15
date	2008.03.23.20.54.29;	author tg;	state Exp;
branches;
next	1.14;
commitid	10047E6C38C68A226BC;

1.14
date	2008.02.29.12.48.09;	author tg;	state Exp;
branches
	1.14.2.1;
next	1.13;
commitid	10047C7FF1F0589E231;

1.13
date	2008.02.29.12.47.03;	author tg;	state Exp;
branches;
next	1.12;
commitid	10047C7FEDA0CC41E2B;

1.12
date	2007.10.25.14.44.45;	author tg;	state Exp;
branches;
next	1.11;
commitid	1004720ABF324665827;

1.11
date	2007.07.01.18.00.00;	author tg;	state Exp;
branches;
next	1.10;
commitid	1004687EBB7240AE743;

1.10
date	2007.02.13.12.59.03;	author tg;	state Exp;
branches
	1.10.2.1;
next	1.9;
commitid	10045D1B62255ED8204;

1.9
date	2007.01.12.10.18.19;	author tg;	state Exp;
branches
	1.9.2.1;
next	1.8;
commitid	10045A76059104E0EFB;

1.8
date	2006.05.08.11.59.41;	author tg;	state Exp;
branches;
next	1.7;
commitid	100445F328D5580A1BA;

1.7
date	2005.07.07.23.27.52;	author tg;	state Exp;
branches;
next	1.6;
commitid	419f42cdba670de9;

1.6
date	2005.06.08.21.39.59;	author tg;	state Exp;
branches;
next	1.5;
commitid	308342a765c1f860;

1.5
date	2005.06.08.11.06.45;	author tg;	state Exp;
branches;
next	1.4;
commitid	706b42a6d1116e7f;

1.4
date	2005.06.05.16.38.19;	author tg;	state Exp;
branches;
next	1.3;
commitid	329342a32a8e3325;

1.3
date	2005.05.30.07.05.29;	author tg;	state Exp;
branches;
next	1.2;
commitid	614429abb0f4197;

1.2
date	2005.05.23.14.48.21;	author tg;	state Exp;
branches;
next	1.1;
commitid	7bf94291ed463ca9;

1.1
date	2005.05.23.03.06.05;	author tg;	state Exp;
branches;
next	;
commitid	1a89429147b8402d;

1.37.2.1
date	2015.04.12.22.32.16;	author tg;	state Exp;
branches;
next	1.37.2.2;
commitid	100552AF26A429AA816;

1.37.2.2
date	2015.04.29.21.00.45;	author tg;	state Exp;
branches;
next	;
commitid	1005541468303AD54CF;

1.14.2.1
date	2008.04.22.13.29.21;	author tg;	state Exp;
branches;
next	1.14.2.2;
commitid	100480DE80F32BAA72D;

1.14.2.2
date	2008.05.19.18.41.16;	author tg;	state Exp;
branches;
next	1.14.2.3;
commitid	1004831C9A63DA06745;

1.14.2.3
date	2008.07.18.13.29.40;	author tg;	state Exp;
branches;
next	1.14.2.4;
commitid	10048809AD278B142AC;

1.14.2.4
date	2008.12.14.00.07.32;	author tg;	state Exp;
branches;
next	;
commitid	10049444E5325915C76;

1.10.2.1
date	2007.07.05.11.49.13;	author tg;	state Exp;
branches;
next	;
commitid	100468CDAAD5BCF14BE;

1.9.2.1
date	2007.03.03.21.37.51;	author tg;	state Exp;
branches;
next	;
commitid	10045E9EAC27ABA6ADF;


desc
@@


1.50
log
@inherit “PERLIO” env. var.

On OS/2, it’s possible to disable CRLF from/to LF conversion of perl
by setting PERLIO.

From: KO Myung-Hun <komh@@chollian.net>
@
text
@# $MirOS: src/bin/mksh/check.pl,v 1.49 2017/05/05 21:17:31 tg Exp $
# $OpenBSD: th,v 1.1 2013/12/02 20:39:44 millert Exp $
#-
# Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2011,
#		2012, 2013, 2014, 2015, 2017
#	mirabilos <m@@mirbsd.org>
#
# Provided that these terms and disclaimer and all copyright notices
# are retained or reproduced in an accompanying document, permission
# is granted to deal in this work without restriction, including un-
# limited rights to use, publicly perform, distribute, sell, modify,
# merge, give away, or sublicence.
#
# This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
# the utmost extent permitted by applicable law, neither express nor
# implied; without malicious intent or gross negligence. In no event
# may a licensor, author or contributor be held liable for indirect,
# direct, other damage, loss, or other issues arising in any way out
# of dealing in the work, even if advised of the possibility of such
# damage or existence of a defect, except proven that it results out
# of said person's immediate fault when using the work as intended.
#-
# Example test:
#		name: a-test
#		description:
#			a test to show how tests are done
#		arguments: !-x!-f!
#		stdin:
#			echo -n *
#			false
#		expected-stdout: !
#			*
#		expected-stderr:
#			+ echo -n *
#			+ false
#		expected-exit: 1
#		---
#	This runs the test-program (eg, mksh) with the arguments -x and -f,
#	standard input is a file containing "echo hi*\nfalse\n". The program
#	is expected to produce "hi*" (no trailing newline) on standard output,
#	"+ echo hi*\n+false\n" on standard error, and an exit code of 1.
#
#
# Format of test files:
# - blank lines and lines starting with # are ignored
# - a test file contains a series of tests
# - a test is a series of tag:value pairs ended with a "---" line
#   (leading/trailing spaces are stripped from the first line of value)
# - test tags are:
#	Tag			Flag	Description
#	-----			----	-----------
#	name			r	The name of the test; should be unique
#	description		m	What test does
#	arguments		M	Arguments to pass to the program;
#					default is no arguments.
#	script			m	Value is written to a file which
#					is passed as an argument to the program
#					(after the arguments arguments)
#	stdin			m	Value is written to a file which is
#					used as standard-input for the program;
#					default is to use /dev/null.
#	perl-setup		m	Value is a perl script which is executed
#					just before the test is run. Try to
#					avoid using this...
#	perl-cleanup		m	Value is a perl script which is executed
#					just after the test is run. Try to
#					avoid using this...
#	env-setup		M	Value is a list of NAME=VALUE elements
#					which are put in the environment before
#					the test is run. If the =VALUE is
#					missing, NAME is removed from the
#					environment. Programs are run with
#					the following minimal environment:
#					    HOME, LD_LIBRARY_PATH, LOCPATH,
#					    LOGNAME, PATH, SHELL, UNIXMODE,
#					    UNIXROOT, USER
#					(values taken from the environment of
#					the test harness).
#					CYGWIN is set to nodosfilewarning.
#					ENV is set to /nonexistant.
#					__progname is set to the -p argument.
#					__perlname is set to $^X (perlexe).
#					@@utflocale@@ is substituted from -U.
#	file-setup		mps	Used to create files, directories
#					and symlinks. First word is either
#					file, dir or symlink; second word is
#					permissions; this is followed by a
#					quoted word that is the name of the
#					file; the end-quote should be followed
#					by a newline, then the file data
#					(if any). The first word may be
#					preceded by a ! to strip the trailing
#					newline in a symlink.
#	file-result		mps	Used to verify a file, symlink or
#					directory is created correctly.
#					The first word is either
#					file, dir or symlink; second word is
#					expected permissions; third word
#					is user-id; fourth is group-id;
#					fifth is "exact" or "pattern"
#					indicating whether the file contents
#					which follow is to be matched exactly
#					or if it is a regular expression.
#					The fifth argument is the quoted name
#					of the file that should be created.
#					The end-quote should be followed
#					by a newline, then the file data
#					(if any). The first word may be
#					preceded by a ! to strip the trailing
#					newline in the file contents.
#					The permissions, user and group fields
#					may be * meaning accept any value.
#	time-limit			Time limit - the program is sent a
#					SIGKILL N seconds. Default is no
#					limit.
#	expected-fail			'yes' if the test is expected to fail.
#	expected-exit			expected exit code. Can be a number,
#					or a C expression using the variables
#					e, s and w (exit code, termination
#					signal, and status code).
#	expected-stdout		m	What the test should generate on stdout;
#					default is to expect no output.
#	expected-stdout-pattern	m	A perl pattern which matches the
#					expected output.
#	expected-stderr		m	What the test should generate on stderr;
#					default is to expect no output.
#	expected-stderr-pattern	m	A perl pattern which matches the
#					expected standard error.
#	category		m	Specify a comma separated list of
#					'categories' of program that the test
#					is to be run for. A category can be
#					negated by prefixing the name with a !.
#					The idea is that some tests in a
#					test suite may apply to a particular
#					program version and shouldn't be run
#					on other versions. The category(s) of
#					the program being tested can be
#					specified on the command line.
#					One category os:XXX is predefined
#					(XXX is the operating system name,
#					eg, linux, dec_osf).
#	need-ctty			'yes' if the test needs a ctty, run
#					with -C regress:no-ctty to disable.
# Flag meanings:
#	r	tag is required (eg, a test must have a name tag).
#	m	value can be multiple lines. Lines must be prefixed with
#		a tab. If the value part of the initial tag:value line is
#			- empty: the initial blank line is stripped.
#			- a lone !: the last newline in the value is stripped;
#	M	value can be multiple lines (prefixed by a tab) and consists
#		of multiple fields, delimited by a field separator character.
#		The value must start and end with the f-s-c.
#	p	tag takes parameters (used with m).
#	s	tag can be used several times.

# require Config only if it exists
# pull EINTR from POSIX.pm or Errno.pm if they exist
# otherwise just skip it
BEGIN {
	eval {
		require Config;
		import Config;
		1;
	};
	$EINTR = 0;
	eval {
		require POSIX;
		$EINTR = POSIX::EINTR();
	};
	if ($@@) {
		eval {
			require Errno;
			$EINTR = Errno::EINTR();
		} or do {
			$EINTR = 0;
		};
	}
};

use Getopt::Std;

$os = defined $^O ? $^O : 'unknown';

($prog = $0) =~ s#.*/##;

$Usage = <<EOF ;
Usage: $prog [-Pv] [-C cat] [-e e=v] [-p prog] [-s fn] [-T dir] \
       [-t tmo] [-U lcl] name ...
	-C c	Specify the comma separated list of categories the program
		belongs to (see category field).
	-e e=v	Set the environment variable e to v for all tests
		(if no =v is given, the current value is used)
		Only one -e option can be given at the moment, sadly.
	-P	program (-p) string has multiple words, and the program is in
		the path (kludge option)
	-p p	Use p as the program to test
	-s s	Read tests from file s; if s is a directory, it is recursively
		scaned for test files (which end in .t).
	-T dir	Use dir instead of /tmp to hold temporary files
	-t t	Use t as default time limit for tests (default is unlimited)
	-U lcl	Use lcl as UTF-8 locale (e.g. C.UTF-8) instead of the default
	-v	Verbose mode: print reason test failed.
	name	specifies the name of the test(s) to run; if none are
		specified, all tests are run.
EOF

# See comment above for flag meanings
%test_fields = (
	'name',				'r',
	'description',			'm',
	'arguments',			'M',
	'script',			'm',
	'stdin',			'm',
	'perl-setup',			'm',
	'perl-cleanup',			'm',
	'env-setup',			'M',
	'file-setup',			'mps',
	'file-result',			'mps',
	'time-limit',			'',
	'expected-fail',		'',
	'expected-exit',		'',
	'expected-stdout',		'm',
	'expected-stdout-pattern',	'm',
	'expected-stderr',		'm',
	'expected-stderr-pattern',	'm',
	'category',			'm',
	'need-ctty',			'',
	'need-pass',			'',
	);
# Filled in by read_test()
%internal_test_fields = (
	':full-name', 1,		# file:name
	':long-name', 1,		# dir/file:lineno:name
	);

# Categories of the program under test. Provide the current
# os by default.
%categories = (
	"os:$os", '1'
	);

$nfailed = 0;
$nifailed = 0;
$nxfailed = 0;
$npassed = 0;
$nxpassed = 0;

%known_tests = ();

if (!getopts('C:Ee:Pp:s:T:t:U:v')) {
    print STDERR $Usage;
    exit 1;
}

die "$prog: no program specified (use -p)\n" if !defined $opt_p;
die "$prog: no test set specified (use -s)\n" if !defined $opt_s;
$test_prog = $opt_p;
$verbose = defined $opt_v && $opt_v;
$is_ebcdic = defined $opt_E && $opt_E;
$test_set = $opt_s;
$temp_base = $opt_T || "/tmp";
$utflocale = $opt_U || (($os eq "hpux") ? "en_US.utf8" : "en_US.UTF-8");
if (defined $opt_t) {
    die "$prog: bad -t argument (should be number > 0): $opt_t\n"
	if $opt_t !~ /^\d+$/ || $opt_t <= 0;
    $default_time_limit = $opt_t;
}
$program_kludge = defined $opt_P ? $opt_P : 0;

if ($is_ebcdic) {
	$categories{'shell:ebcdic-yes'} = 1;
	$categories{'shell:ascii-no'} = 1;
} else {
	$categories{'shell:ebcdic-no'} = 1;
	$categories{'shell:ascii-yes'} = 1;
}

if (defined $opt_C) {
    foreach $c (split(',', $opt_C)) {
	$c =~ s/\s+//;
	die "$prog: categories can't be negated on the command line\n"
	    if ($c =~ /^!/);
	$categories{$c} = 1;
    }
}

# Note which tests are to be run.
%do_test = ();
grep($do_test{$_} = 1, @@ARGV);
$all_tests = @@ARGV == 0;

# Set up a very minimal environment
%new_env = ();
foreach $env (('HOME', 'LD_LIBRARY_PATH', 'LOCPATH', 'LOGNAME',
  'PATH', 'PERLIO', 'SHELL', 'UNIXMODE', 'UNIXROOT', 'USER')) {
    $new_env{$env} = $ENV{$env} if defined $ENV{$env};
}
$new_env{'CYGWIN'} = 'nodosfilewarning';
$new_env{'ENV'} = '/nonexistant';

if (($os eq 'VMS') || ($Config{perlpath} =~ m/$Config{_exe}$/i)) {
	$new_env{'__perlname'} = $Config{perlpath};
} else {
	$new_env{'__perlname'} = $Config{perlpath} . $Config{_exe};
}
$new_env{'__perlname'} = $^X if ($new_env{'__perlname'} eq '') and -f $^X and -x $^X;
if ($new_env{'__perlname'} eq '') {
	foreach $pathelt (split /:/,$ENV{'PATH'}) {
		chomp($pathelt = `pwd`) if $pathelt eq '';
		my $x = $pathelt . '/' . $^X;
		next unless -f $x and -x $x;
		$new_env{'__perlname'} = $x;
		last;
	}
}
$new_env{'__perlname'} = $^X if ($new_env{'__perlname'} eq '');

if (defined $opt_e) {
    # XXX need a way to allow many -e arguments...
    if ($opt_e =~ /^([a-zA-Z_]\w*)(|=(.*))$/) {
	$new_env{$1} = $2 eq '' ? $ENV{$1} : $3;
    } else {
	die "$0: bad -e argument: $opt_e\n";
    }
}
%old_env = %ENV;

chop($pwd = `pwd 2>/dev/null`);
die "$prog: couldn't get current working directory\n" if $pwd eq '';
die "$prog: couldn't cd to $pwd - $!\n" if !chdir($pwd);

die "$prog: couldn't cd to $temp_base - $!\n" if !chdir($temp_base);
die "$prog: couldn't get temporary directory base\n" unless -d '.';
$temps = sprintf("chk%d-%d.", $$, time());
$tempi = 0;
until (mkdir(($tempdir = sprintf("%s%03d", $temps, $tempi)), 0700)) {
    die "$prog: couldn't get temporary directory\n" if $tempi++ >= 999;
}
die "$prog: couldn't cd to $tempdir - $!\n" if !chdir($tempdir);
chop($temp_dir = `pwd 2>/dev/null`);
die "$prog: couldn't get temporary directory\n" if $temp_dir eq '';
die "$prog: couldn't cd to $pwd - $!\n" if !chdir($pwd);

if (!$program_kludge) {
    $test_prog = "$pwd/$test_prog" if (substr($test_prog, 0, 1) ne '/') &&
      ($os ne 'os2' || substr($test_prog, 1, 1) ne ':');
    die "$prog: $test_prog is not executable - bye\n"
      if (! -x $test_prog && $os ne 'os2');
}

@@trap_sigs = ('TERM', 'QUIT', 'INT', 'PIPE', 'HUP');
@@SIG{@@trap_sigs} = ('cleanup_exit') x @@trap_sigs;
$child_kill_ok = 0;
$SIG{'ALRM'} = 'catch_sigalrm';

$| = 1;

# Create temp files
$temps = "${temp_dir}/rts";
$tempi = "${temp_dir}/rti";
$tempo = "${temp_dir}/rto";
$tempe = "${temp_dir}/rte";
$tempdir = "${temp_dir}/rtd";
mkdir($tempdir, 0700) or die "$prog: couldn't mkdir $tempdir - $!\n";

if (-d $test_set) {
    $file_prefix_skip = length($test_set) + 1;
    $ret = &process_test_dir($test_set);
} else {
    $file_prefix_skip = 0;
    $ret = &process_test_file($test_set);
}
&cleanup_exit() if !defined $ret;

$tot_failed = $nfailed + $nifailed + $nxfailed;
$tot_passed = $npassed + $nxpassed;
if ($tot_failed || $tot_passed) {
    print "Total failed: $tot_failed";
    print " ($nifailed ignored)" if $nifailed;
    print " ($nxfailed unexpected)" if $nxfailed;
    print " (as expected)" if $nfailed && !$nxfailed && !$nifailed;
    print " ($nfailed expected)" if $nfailed && ($nxfailed || $nifailed);
    print "\nTotal passed: $tot_passed";
    print " ($nxpassed unexpected)" if $nxpassed;
    print "\n";
}

&cleanup_exit('ok');

sub
cleanup_exit
{
    local($sig, $exitcode) = ('', 1);

    if ($_[0] eq 'ok') {
	unless ($nxfailed) {
		$exitcode = 0;
	} else {
		$exitcode = 1;
	}
    } elsif ($_[0] ne '') {
	$sig = $_[0];
    }

    unlink($tempi, $tempo, $tempe, $temps);
    &scrub_dir($tempdir) if defined $tempdir;
    rmdir($tempdir) if defined $tempdir;
    rmdir($temp_dir) if defined $temp_dir;

    if ($sig) {
	$SIG{$sig} = 'DEFAULT';
	kill $sig, $$;
	return;
    }
    exit $exitcode;
}

sub
catch_sigalrm
{
    $SIG{'ALRM'} = 'catch_sigalrm';
    kill(9, $child_pid) if $child_kill_ok;
    $child_killed = 1;
}

sub
process_test_dir
{
    local($dir) = @@_;
    local($ret, $file);
    local(@@todo) = ();

    if (!opendir(DIR, $dir)) {
	print STDERR "$prog: can't open directory $dir - $!\n";
	return undef;
    }
    while (defined ($file = readdir(DIR))) {
	push(@@todo, $file) if $file =~ /^[^.].*\.t$/;
    }
    closedir(DIR);

    foreach $file (@@todo) {
	$file = "$dir/$file";
	if (-d $file) {
	    $ret = &process_test_dir($file);
	} elsif (-f _) {
	    $ret = &process_test_file($file);
	}
	last if !defined $ret;
    }

    return $ret;
}

sub
process_test_file
{
    local($file) = @@_;
    local($ret);

    if (!open(IN, $file)) {
	print STDERR "$prog: can't open $file - $!\n";
	return undef;
    }
    binmode(IN);
    while (1) {
	$ret = &read_test($file, IN, *test);
	last if !defined $ret || !$ret;
	next if !$all_tests && !$do_test{$test{'name'}};
	next if !&category_check(*test);
	$ret = &run_test(*test);
	last if !defined $ret;
    }
    close(IN);

    return $ret;
}

sub
run_test
{
    local(*test) = @@_;
    local($name) = $test{':full-name'};

    return undef if !&scrub_dir($tempdir);

    if (defined $test{'stdin'}) {
	return undef if !&write_file($tempi, $test{'stdin'});
	$ifile = $tempi;
    } else {
	$ifile = '/dev/null';
    }

    if (defined $test{'script'}) {
	return undef if !&write_file($temps, $test{'script'});
    }

    if (!chdir($tempdir)) {
	print STDERR "$prog: couldn't cd to $tempdir - $!\n";
	return undef;
    }

    if (defined $test{'file-setup'}) {
	local($i);
	local($type, $perm, $rest, $c, $len, $name);

	for ($i = 0; $i < $test{'file-setup'}; $i++) {
	    $val = $test{"file-setup:$i"};

	    # format is: type perm "name"
	    ($type, $perm, $rest) =
		split(' ', $val, 3);
	    $c = substr($rest, 0, 1);
	    $len = index($rest, $c, 1) - 1;
	    $name = substr($rest, 1, $len);
	    $rest = substr($rest, 2 + $len);
	    $perm = oct($perm) if $perm =~ /^\d+$/;
	    if ($type eq 'file') {
		return undef if !&write_file($name, $rest);
		if (!chmod($perm, $name)) {
		    print STDERR
		  "$prog:$test{':long-name'}: can't chmod $perm $name - $!\n";
		    return undef;
		}
	    } elsif ($type eq 'dir') {
		if (!mkdir($name, $perm)) {
		    print STDERR
		  "$prog:$test{':long-name'}: can't mkdir $perm $name - $!\n";
		    return undef;
		}
	    } elsif ($type eq 'symlink') {
		local($oumask) = umask($perm);
		local($ret) = symlink($rest, $name);
		umask($oumask);
		if (!$ret) {
		    print STDERR
	    "$prog:$test{':long-name'}: couldn't create symlink $name - $!\n";
		    return undef;
		}
	    }
	}
    }

    if (defined $test{'perl-setup'}) {
	eval $test{'perl-setup'};
	if ($@@ ne '') {
	    print STDERR "$prog:$test{':long-name'}: error running perl-setup - $@@\n";
	    return undef;
	}
    }

    $pid = fork;
    if (!defined $pid) {
	print STDERR "$prog: can't fork - $!\n";
	return undef;
    }
    if (!$pid) {
	@@SIG{@@trap_sigs} = ('DEFAULT') x @@trap_sigs;
	$SIG{'ALRM'} = 'DEFAULT';
	if (defined $test{'env-setup'}) {
	    local($var, $val, $i);

	    foreach $var (split(substr($test{'env-setup'}, 0, 1),
		$test{'env-setup'}))
	    {
		$i = index($var, '=');
		next if $i == 0 || $var eq '';
		if ($i < 0) {
		    delete $new_env{$var};
		} else {
		    $new_env{substr($var, 0, $i)} = substr($var, $i + 1);
		}
	    }
	}
	if (!open(STDIN, "< $ifile")) {
		print STDERR "$prog: couldn't open $ifile in child - $!\n";
		kill('TERM', $$);
	}
	binmode(STDIN);
	if (!open(STDOUT, "> $tempo")) {
		print STDERR "$prog: couldn't open $tempo in child - $!\n";
		kill('TERM', $$);
	}
	binmode(STDOUT);
	if (!open(STDERR, "> $tempe")) {
		print STDOUT "$prog: couldn't open $tempe in child - $!\n";
		kill('TERM', $$);
	}
	binmode(STDERR);
	if ($program_kludge) {
	    @@argv = split(' ', $test_prog);
	} else {
	    @@argv = ($test_prog);
	}
	if (defined $test{'arguments'}) {
		push(@@argv,
		     split(substr($test{'arguments'}, 0, 1),
			   substr($test{'arguments'}, 1)));
	}
	push(@@argv, $temps) if defined $test{'script'};

	#XXX realpathise, use command -v/whence -p/which, or sth. like that
	#XXX if !$program_kludge, we get by with not doing it for now tho
	$new_env{'__progname'} = $argv[0];

	# The following doesn't work with perl5...  Need to do it explicitly - yuck.
	#%ENV = %new_env;
	foreach $k (keys(%ENV)) {
	    delete $ENV{$k};
	}
	$ENV{$k} = $v while ($k,$v) = each %new_env;

	exec { $argv[0] } @@argv;
	print STDERR "$prog: couldn't execute $test_prog - $!\n";
	kill('TERM', $$);
	exit(95);
    }
    $child_pid = $pid;
    $child_killed = 0;
    $child_kill_ok = 1;
    alarm($test{'time-limit'}) if defined $test{'time-limit'};
    while (1) {
	$xpid = waitpid($pid, 0);
	$child_kill_ok = 0;
	if ($xpid < 0) {
	    if ($EINTR) {
		next if $! == $EINTR;
	    }
	    print STDERR "$prog: error waiting for child - $!\n";
	    return undef;
	}
	last;
    }
    $status = $?;
    alarm(0) if defined $test{'time-limit'};

    $failed = 0;
    $why = '';

    if ($child_killed) {
	$failed = 1;
	$why .= "\ttest timed out (limit of $test{'time-limit'} seconds)\n";
    }

    $ret = &eval_exit($test{'long-name'}, $status, $test{'expected-exit'});
    return undef if !defined $ret;
    if (!$ret) {
	local($expl);

	$failed = 1;
	if (($status & 0xff) == 0x7f) {
	    $expl = "stopped";
	} elsif (($status & 0xff)) {
	    $expl = "signal " . ($status & 0x7f);
	} else {
	    $expl = "exit-code " . (($status >> 8) & 0xff);
	}
	$why .=
	"\tunexpected exit status $status ($expl), expected $test{'expected-exit'}\n";
    }

    $tmp = &check_output($test{'long-name'}, $tempo, 'stdout',
		$test{'expected-stdout'}, $test{'expected-stdout-pattern'});
    return undef if !defined $tmp;
    if ($tmp ne '') {
	$failed = 1;
	$why .= $tmp;
    }

    $tmp = &check_output($test{'long-name'}, $tempe, 'stderr',
		$test{'expected-stderr'}, $test{'expected-stderr-pattern'});
    return undef if !defined $tmp;
    if ($tmp ne '') {
	$failed = 1;
	$why .= $tmp;
    }

    $tmp = &check_file_result(*test);
    return undef if !defined $tmp;
    if ($tmp ne '') {
	$failed = 1;
	$why .= $tmp;
    }

    if (defined $test{'perl-cleanup'}) {
	eval $test{'perl-cleanup'};
	if ($@@ ne '') {
	    print STDERR "$prog:$test{':long-name'}: error running perl-cleanup - $@@\n";
	    return undef;
	}
    }

    if (!chdir($pwd)) {
	print STDERR "$prog: couldn't cd to $pwd - $!\n";
	return undef;
    }

    if ($failed) {
	if (!$test{'expected-fail'}) {
	    if ($test{'need-pass'}) {
		print "FAIL $name\n";
		$nxfailed++;
	    } else {
		print "FAIL $name (ignored)\n";
		$nifailed++;
	    }
	} else {
	    print "fail $name (as expected)\n";
	    $nfailed++;
	}
	$why = "\tDescription"
		. &wrap_lines($test{'description'}, " (missing)\n")
		. $why;
    } elsif ($test{'expected-fail'}) {
	print "PASS $name (unexpectedly)\n";
	$nxpassed++;
    } else {
	print "pass $name\n";
	$npassed++;
    }
    print $why if $verbose;
    return 0;
}

sub
category_check
{
    local(*test) = @@_;
    local($c);

    return 0 if ($test{'need-ctty'} && defined $categories{'regress:no-ctty'});
    return 1 if (!defined $test{'category'});
    local($ok) = 0;
    foreach $c (split(',', $test{'category'})) {
	$c =~ s/\s+//;
	if ($c =~ /^!/) {
	    $c = $';
	    return 0 if (defined $categories{$c});
	    $ok = 1;
	} else {
	    $ok = 1 if (defined $categories{$c});
	}
    }
    return $ok;
}

sub
scrub_dir
{
    local($dir) = @@_;
    local(@@todo) = ();
    local($file);

    if (!opendir(DIR, $dir)) {
	print STDERR "$prog: couldn't open directory $dir - $!\n";
	return undef;
    }
    while (defined ($file = readdir(DIR))) {
	push(@@todo, $file) if $file ne '.' && $file ne '..';
    }
    closedir(DIR);
    foreach $file (@@todo) {
	$file = "$dir/$file";
	if (-d $file) {
	    return undef if !&scrub_dir($file);
	    if (!rmdir($file)) {
		print STDERR "$prog: couldn't rmdir $file - $!\n";
		return undef;
	    }
	} else {
	    if (!unlink($file)) {
		print STDERR "$prog: couldn't unlink $file - $!\n";
		return undef;
	    }
	}
    }
    return 1;
}

sub
write_file
{
    local($file, $str) = @@_;

    if (!open(TEMP, "> $file")) {
	print STDERR "$prog: can't open $file - $!\n";
	return undef;
    }
    binmode(TEMP);
    print TEMP $str;
    if (!close(TEMP)) {
	print STDERR "$prog: error writing $file - $!\n";
	return undef;
    }
    return 1;
}

sub
check_output
{
    local($name, $file, $what, $expect, $expect_pat) = @@_;
    local($got) = '';
    local($why) = '';
    local($ret);

    if (!open(TEMP, "< $file")) {
	print STDERR "$prog:$name($what): couldn't open $file after running program - $!\n";
	return undef;
    }
    binmode(TEMP);
    while (<TEMP>) {
	$got .= $_;
    }
    close(TEMP);
    return compare_output($name, $what, $expect, $expect_pat, $got);
}

sub
compare_output
{
    local($name, $what, $expect, $expect_pat, $got) = @@_;
    local($why) = '';

    if (defined $expect_pat) {
	$_ = $got;
	$ret = eval "$expect_pat";
	if ($@@ ne '') {
	    print STDERR "$prog:$name($what): error evaluating $what pattern: $expect_pat - $@@\n";
	    return undef;
	}
	if (!$ret) {
	    $why = "\tunexpected $what - wanted pattern";
	    $why .= &wrap_lines($expect_pat);
	    $why .= "\tgot";
	    $why .= &wrap_lines($got);
	}
    } else {
	$expect = '' if !defined $expect;
	if ($got ne $expect) {
	    $why .= "\tunexpected $what - " . &first_diff($expect, $got) . "\n";
	    $why .= "\twanted";
	    $why .= &wrap_lines($expect);
	    $why .= "\tgot";
	    $why .= &wrap_lines($got);
	}
    }
    return $why;
}

sub
wrap_lines
{
    local($str, $empty) = @@_;
    local($nonl) = substr($str, -1, 1) ne "\n";

    return (defined $empty ? $empty : " nothing\n") if $str eq '';
    substr($str, 0, 0) = ":\n";
    $str =~ s/\n/\n\t\t/g;
    if ($nonl) {
	$str .= "\n\t[incomplete last line]\n";
    } else {
	chop($str);
	chop($str);
    }
    return $str;
}

sub
first_diff
{
    local($exp, $got) = @@_;
    local($lineno, $char) = (1, 1);
    local($i, $exp_len, $got_len);
    local($ce, $cg);

    $exp_len = length($exp);
    $got_len = length($got);
    if ($exp_len != $got_len) {
	if ($exp_len < $got_len) {
	    if (substr($got, 0, $exp_len) eq $exp) {
		return "got too much output";
	    }
	} elsif (substr($exp, 0, $got_len) eq $got) {
	    return "got too little output";
	}
    }
    for ($i = 0; $i < $exp_len; $i++) {
	$ce = substr($exp, $i, 1);
	$cg = substr($got, $i, 1);
	last if $ce ne $cg;
	$char++;
	if ($ce eq "\n") {
	    $lineno++;
	    $char = 1;
	}
    }
    return "first difference: line $lineno, char $char (wanted " .
	&format_char($ce) . ", got " . &format_char($cg);
}

sub
format_char
{
    local($ch, $s, $q);

    $ch = ord($_[0]);
    $q = "'";

    if ($is_ebcdic) {
	if ($ch == 0x15) {
		return $q . '\n' . $q;
	} elsif ($ch == 0x16) {
		return $q . '\b' . $q;
	} elsif ($ch == 0x05) {
		return $q . '\t' . $q;
	} elsif ($ch < 64 || $ch == 255) {
		return sprintf("X'%02X'", $ch);
	}
	return sprintf("'%c' (X'%02X')", $ch, $ch);
    }

    $s = sprintf("0x%02X (", $ch);
    if ($ch == 10) {
	return $s . $q . '\n' . $q . ')';
    } elsif ($ch == 13) {
	return $s . $q . '\r' . $q . ')';
    } elsif ($ch == 8) {
	return $s . $q . '\b' . $q . ')';
    } elsif ($ch == 9) {
	return $s . $q . '\t' . $q . ')';
    } elsif ($ch > 127) {
	$ch -= 128;
	$s .= "M-";
    }
    if ($ch < 32) {
	return sprintf("%s^%c)", $s, $ch + ord('@@'));
    } elsif ($ch == 127) {
	return $s . "^?)";
    }
    return sprintf("%s'%c')", $s, $ch);
}

sub
eval_exit
{
    local($name, $status, $expect) = @@_;
    local($expr);
    local($w, $e, $s) = ($status, ($status >> 8) & 0xff, $status & 0x7f);

    $e = -1000 if $status & 0xff;
    $s = -1000 if $s == 0x7f;
    if (!defined $expect) {
	$expr = '$w == 0';
    } elsif ($expect =~ /^(|-)\d+$/) {
	$expr = "\$e == $expect";
    } else {
	$expr = $expect;
	$expr =~ s/\b([wse])\b/\$$1/g;
	$expr =~ s/\b(SIG[A-Z][A-Z0-9]*)\b/&$1/g;
    }
    $w = eval $expr;
    if ($@@ ne '') {
	print STDERR "$prog:$test{':long-name'}: bad expected-exit expression: $expect ($@@)\n";
	return undef;
    }
    return $w;
}

sub
read_test
{
    local($file, $in, *test) = @@_;
    local($field, $val, $flags, $do_chop, $need_redo, $start_lineno);
    local(%cnt, $sfield);

    %test = ();
    %cnt = ();
    while (<$in>) {
	chop;
	next if /^\s*$/;
	next if /^ *#/;
	last if /^\s*---\s*$/;
	$start_lineno = $. if !defined $start_lineno;
	if (!/^([-\w]+):\s*(|\S|\S.*\S)\s*$/) {
	    print STDERR "$prog:$file:$.: unrecognised line \"$_\"\n";
	    return undef;
	}
	($field, $val) = ($1, $2);
	$sfield = $field;
	$flags = $test_fields{$field};
	if (!defined $flags) {
	    print STDERR "$prog:$file:$.: unrecognised field \"$field\"\n";
	    return undef;
	}
	if ($flags =~ /s/) {
	    local($cnt) = $cnt{$field}++;
	    $test{$field} = $cnt{$field};
	    $cnt = 0 if $cnt eq '';
	    $sfield .= ":$cnt";
	} elsif (defined $test{$field}) {
	    print STDERR "$prog:$file:$.: multiple \"$field\" fields\n";
	    return undef;
	}
	$do_chop = $flags !~ /m/;
	$need_redo = 0;
	if ($val eq '' || $val eq '!' || $flags =~ /p/) {
	    if ($flags =~ /[Mm]/) {
		if ($flags =~ /p/) {
		    if ($val =~ /^!/) {
			$do_chop = 1;
			$val = $';
		    } else {
			$do_chop = 0;
		    }
		    if ($val eq '') {
			print STDERR
		"$prog:$file:$.: no parameters given for field \"$field\"\n";
			return undef;
		    }
		} else {
		    if ($val eq '!') {
			$do_chop = 1;
		    }
		    $val = '';
		}
		while (<$in>) {
		    last if !/^\t/;
		    $val .= $';
		}
		chop $val if $do_chop;
		$do_chop = 1;
		$need_redo = 1;

		# Syntax check on fields that can several instances
		# (can give useful line numbers this way)

		if ($field eq 'file-setup') {
		    local($type, $perm, $rest, $c, $len, $name);

		    # format is: type perm "name"
		    if ($val !~ /^[ \t]*(\S+)[ \t]+(\S+)[ \t]+([^ \t].*)/) {
			print STDERR
		    "$prog:$file:$.: bad parameter line for file-setup field\n";
			return undef;
		    }
		    ($type, $perm, $rest) = ($1, $2, $3);
		    if ($type !~ /^(file|dir|symlink)$/) {
			print STDERR
		    "$prog:$file:$.: bad file type for file-setup: $type\n";
			return undef;
		    }
		    if ($perm !~ /^\d+$/) {
			print STDERR
		    "$prog:$file:$.: bad permissions for file-setup: $type\n";
			return undef;
		    }
		    $c = substr($rest, 0, 1);
		    if (($len = index($rest, $c, 1) - 1) <= 0) {
			print STDERR
    "$prog:$file:$.: missing end quote for file name in file-setup: $rest\n";
			return undef;
		    }
		    $name = substr($rest, 1, $len);
		    if ($name =~ /^\// || $name =~ /(^|\/)\.\.(\/|$)/) {
			# Note: this is not a security thing - just a sanity
			# check - a test can still use symlinks to get at files
			# outside the test directory.
			print STDERR
"$prog:$file:$.: file name in file-setup is absolute or contains ..: $name\n";
			return undef;
		    }
		}
		if ($field eq 'file-result') {
		    local($type, $perm, $uid, $gid, $matchType,
			  $rest, $c, $len, $name);

		    # format is: type perm uid gid matchType "name"
		    if ($val !~ /^\s*(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S.*)/) {
			print STDERR
		    "$prog:$file:$.: bad parameter line for file-result field\n";
			return undef;
		    }
		    ($type, $perm, $uid, $gid, $matchType, $rest)
			= ($1, $2, $3, $4, $5, $6);
		    if ($type !~ /^(file|dir|symlink)$/) {
			print STDERR
		    "$prog:$file:$.: bad file type for file-result: $type\n";
			return undef;
		    }
		    if ($perm !~ /^\d+$/ && $perm ne '*') {
			print STDERR
		    "$prog:$file:$.: bad permissions for file-result: $perm\n";
			return undef;
		    }
		    if ($uid !~ /^\d+$/ && $uid ne '*') {
			print STDERR
		    "$prog:$file:$.: bad user-id for file-result: $uid\n";
			return undef;
		    }
		    if ($gid !~ /^\d+$/ && $gid ne '*') {
			print STDERR
		    "$prog:$file:$.: bad group-id for file-result: $gid\n";
			return undef;
		    }
		    if ($matchType !~ /^(exact|pattern)$/) {
			print STDERR
		"$prog:$file:$.: bad match type for file-result: $matchType\n";
			return undef;
		    }
		    $c = substr($rest, 0, 1);
		    if (($len = index($rest, $c, 1) - 1) <= 0) {
			print STDERR
    "$prog:$file:$.: missing end quote for file name in file-result: $rest\n";
			return undef;
		    }
		    $name = substr($rest, 1, $len);
		    if ($name =~ /^\// || $name =~ /(^|\/)\.\.(\/|$)/) {
			# Note: this is not a security thing - just a sanity
			# check - a test can still use symlinks to get at files
			# outside the test directory.
			print STDERR
"$prog:$file:$.: file name in file-result is absolute or contains ..: $name\n";
			return undef;
		    }
		}
	    } elsif ($val eq '') {
		print STDERR
		    "$prog:$file:$.: no value given for field \"$field\"\n";
		return undef;
	    }
	}
	$val .= "\n" if !$do_chop;
	$test{$sfield} = $val;
	redo if $need_redo;
    }
    if ($_ eq '') {
	if (%test) {
	    print STDERR
	      "$prog:$file:$start_lineno: end-of-file while reading test\n";
	    return undef;
	}
	return 0;
    }

    while (($field, $val) = each %test_fields) {
	if ($val =~ /r/ && !defined $test{$field}) {
	    print STDERR
	      "$prog:$file:$start_lineno: required field \"$field\" missing\n";
	    return undef;
	}
    }

    $test{':full-name'} = substr($file, $file_prefix_skip) . ":$test{'name'}";
    $test{':long-name'} = "$file:$start_lineno:$test{'name'}";

    # Syntax check on specific fields
    if (defined $test{'expected-fail'}) {
	if ($test{'expected-fail'} !~ /^(yes|no)$/) {
	    print STDERR
	      "$prog:$test{':long-name'}: bad value for expected-fail field\n";
	    return undef;
	}
	$test{'expected-fail'} = $1 eq 'yes';
    } else {
	$test{'expected-fail'} = 0;
    }
    if (defined $test{'need-ctty'}) {
	if ($test{'need-ctty'} !~ /^(yes|no)$/) {
	    print STDERR
	      "$prog:$test{':long-name'}: bad value for need-ctty field\n";
	    return undef;
	}
	$test{'need-ctty'} = $1 eq 'yes';
    } else {
	$test{'need-ctty'} = 0;
    }
    if (defined $test{'need-pass'}) {
	if ($test{'need-pass'} !~ /^(yes|no)$/) {
	    print STDERR
	      "$prog:$test{':long-name'}: bad value for need-pass field\n";
	    return undef;
	}
	$test{'need-pass'} = $1 eq 'yes';
    } else {
	$test{'need-pass'} = 1;
    }
    if (defined $test{'arguments'}) {
	local($firstc) = substr($test{'arguments'}, 0, 1);

	if (substr($test{'arguments'}, -1, 1) ne $firstc) {
	    print STDERR "$prog:$test{':long-name'}: arguments field doesn't start and end with the same character\n";
	    return undef;
	}
    }
    if (defined $test{'env-setup'}) {
	local($firstc) = substr($test{'env-setup'}, 0, 1);

	if (substr($test{'env-setup'}, -1, 1) ne $firstc) {
	    print STDERR "$prog:$test{':long-name'}: env-setup field doesn't start and end with the same character\n";
	    return undef;
	}

	$test{'env-setup'} =~ s/\@@utflocale\@@/$utflocale/g;
    }
    if (defined $test{'expected-exit'}) {
	local($val) = $test{'expected-exit'};

	if ($val =~ /^(|-)\d+$/) {
	    if ($val < 0 || $val > 255) {
		print STDERR "$prog:$test{':long-name'}: expected-exit value $val not in 0..255\n";
		return undef;
	    }
	} elsif ($val !~ /^([\s\d<>+=*%\/&|!()-]|\b[wse]\b|\bSIG[A-Z][A-Z0-9]*\b)+$/) {
	    print STDERR "$prog:$test{':long-name'}: bad expected-exit expression: $val\n";
	    return undef;
	}
    } else {
	$test{'expected-exit'} = 0;
    }
    if (defined $test{'expected-stdout'}
	&& defined $test{'expected-stdout-pattern'})
    {
	print STDERR "$prog:$test{':long-name'}: can't use both expected-stdout and expected-stdout-pattern\n";
	return undef;
    }
    if (defined $test{'expected-stderr'}
	&& defined $test{'expected-stderr-pattern'})
    {
	print STDERR "$prog:$test{':long-name'}: can't use both expected-stderr and expected-stderr-pattern\n";
	return undef;
    }
    if (defined $test{'time-limit'}) {
	if ($test{'time-limit'} !~ /^\d+$/ || $test{'time-limit'} == 0) {
	    print STDERR
	      "$prog:$test{':long-name'}: bad value for time-limit field\n";
	    return undef;
	}
    } elsif (defined $default_time_limit) {
	$test{'time-limit'} = $default_time_limit;
    }

    if (defined $known_tests{$test{'name'}}) {
	print STDERR "$prog:$test{':long-name'}: warning: duplicate test name ${test{'name'}}\n";
    }
    $known_tests{$test{'name'}} = 1;

    return 1;
}

sub
tty_msg
{
    local($msg) = @@_;

    open(TTY, "> /dev/tty") || return 0;
    print TTY $msg;
    close(TTY);
    return 1;
}

sub
never_called_funcs
{
	return 0;
	&tty_msg("hi\n");
	&never_called_funcs();
	&catch_sigalrm();
	$old_env{'foo'} = 'bar';
	$internal_test_fields{'foo'} = 'bar';
}

sub
check_file_result
{
    local(*test) = @@_;

    return '' if (!defined $test{'file-result'});

    local($why) = '';
    local($i);
    local($type, $perm, $uid, $gid, $rest, $c, $len, $name);
    local(@@stbuf);

    for ($i = 0; $i < $test{'file-result'}; $i++) {
	$val = $test{"file-result:$i"};

	# format is: type perm "name"
	($type, $perm, $uid, $gid, $matchType, $rest) =
	    split(' ', $val, 6);
	$c = substr($rest, 0, 1);
	$len = index($rest, $c, 1) - 1;
	$name = substr($rest, 1, $len);
	$rest = substr($rest, 2 + $len);
	$perm = oct($perm) if $perm =~ /^\d+$/;

	@@stbuf = lstat($name);
	if (!@@stbuf) {
	    $why .= "\texpected $type \"$name\" not created\n";
	    next;
	}
	if ($perm ne '*' && ($stbuf[2] & 07777) != $perm) {
	    $why .= "\t$type \"$name\" has unexpected permissions\n";
	    $why .= sprintf("\t\texpected 0%o, found 0%o\n",
		    $perm, $stbuf[2] & 07777);
	}
	if ($uid ne '*' && $stbuf[4] != $uid) {
	    $why .= "\t$type \"$name\" has unexpected user-id\n";
	    $why .= sprintf("\t\texpected %d, found %d\n",
		    $uid, $stbuf[4]);
	}
	if ($gid ne '*' && $stbuf[5] != $gid) {
	    $why .= "\t$type \"$name\" has unexpected group-id\n";
	    $why .= sprintf("\t\texpected %d, found %d\n",
		    $gid, $stbuf[5]);
	}

	if ($type eq 'file') {
	    if (-l _ || ! -f _) {
		$why .= "\t$type \"$name\" is not a regular file\n";
	    } else {
		local $tmp = &check_output($test{'long-name'}, $name,
			    "$type contents in \"$name\"",
			    $matchType eq 'exact' ? $rest : undef
			    $matchType eq 'pattern' ? $rest : undef);
		return undef if (!defined $tmp);
		$why .= $tmp;
	    }
	} elsif ($type eq 'dir') {
	    if ($rest !~ /^\s*$/) {
		print STDERR "$prog:$test{':long-name'}: file-result test for directory $name should not have content specified\n";
		return undef;
	    }
	    if (-l _ || ! -d _) {
		$why .= "\t$type \"$name\" is not a directory\n";
	    }
	} elsif ($type eq 'symlink') {
	    if (!-l _) {
		$why .= "\t$type \"$name\" is not a symlink\n";
	    } else {
		local $content = readlink($name);
		if (!defined $content) {
		    print STDERR "$prog:$test{':long-name'}: file-result test for $type $name failed - could not readlink - $!\n";
		    return undef;
		}
		local $tmp = &compare_output($test{'long-name'},
			    "$type contents in \"$name\"",
			    $matchType eq 'exact' ? $rest : undef
			    $matchType eq 'pattern' ? $rest : undef);
		return undef if (!defined $tmp);
		$why .= $tmp;
	    }
	}
    }

    return $why;
}

sub
HELP_MESSAGE
{
    print STDERR $Usage;
    exit 0;
}
@


1.49
log
@catch z/OS not having $Config not filling in the __perlpath env correctly
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.pl,v 1.44 2017/04/29 15:18:25 tg Exp $
d295 1
a295 1
  'PATH', 'SHELL', 'UNIXMODE', 'UNIXROOT', 'USER')) {
@


1.48
log
@some more small EBCDIC fixes
@
text
@d300 1
d306 12
@


1.47
log
@move more EBCDIC logic into check.pl
@
text
@d884 2
a885 3
    return "first difference: line $lineno, char $char (wanted '"
	. &format_char($ce) . "', got '"
	. &format_char($cg) . "'";
d891 1
a891 1
    local($ch, $s);
d894 1
d898 1
a898 1
		return '\n';
d900 1
a900 1
		return '\b';
d902 1
a902 1
		return '\t';
d906 1
a906 1
	return chr($ch);
d909 1
d911 1
a911 1
	return '\n';
d913 1
a913 1
	return '\r';
d915 1
a915 1
	return '\b';
d917 1
a917 1
	return '\t';
d919 2
a920 4
	$ch -= 127;
	$s = "M-";
    } else {
	$s = '';
d923 1
a923 2
	$s .= '^';
	$ch += ord('@@');
d925 1
a925 1
	return $s . "^?";
d927 1
a927 1
    return $s . sprintf("%c", $ch);
@


1.46
log
@handle EBCDIC in the testsuite runner (error display)

- move categories for that to test.sh, simplifying it
- $ebcdic in Build.sh is now for the target, not the buildhost
@
text
@d270 8
@


1.45
log
@require Config only if it exists, which it reportedly doesn’t on OS/390
@
text
@d250 1
a250 1
if (!getopts('C:e:Pp:s:T:t:U:v')) {
d259 1
d887 14
@


1.44
log
@clean up OS exclusions somewhat: have Perl substitute the UTF-8 locale
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.pl,v 1.43 2017/04/20 21:43:43 tg Exp $
d156 1
d160 5
a180 1
use Config;
@


1.43
log
@fix accidentally defanged PATHSEP test
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.pl,v 1.36 2014/06/09 13:25:50 tg Exp $
d83 1
d183 1
a183 1
       [-t tmo] name ...
d196 1
d245 1
a245 1
if (!getopts('C:e:Pp:s:T:t:v')) {
d256 1
d1163 2
@


1.42
log
@janitorial work
@
text
@d5 1
a5 1
#		2012, 2013, 2014, 2015
a80 1
#					PATHSEP is set to either : or ;.
a282 1
$new_env{'PATHSEP'} = $os eq 'os2' ? ';' : ':';
@


1.41
log
@oksh sync, simplify *all* if(x)free(x); constructs, simplify x_push() and sync boilerplate while here
@
text
@d6 1
a6 1
#	mirabilos <tg@@mirbsd.org>
@


1.40
log
@merge OS/2 style PATH (absolute with drive letters, ‘;’ as separator)

From: KO Myung-Hun <komh@@chollian.net>
@
text
@d6 1
a6 1
#	Thorsten Glaser <tg@@mirbsd.org>
@


1.39
log
@fix pdksh mistake of using +-= in char class; move - to end and add \d
@
text
@d76 1
a76 1
#					    USER
d81 1
d279 1
a279 1
  'PATH', 'SHELL', 'UNIXMODE', 'USER')) {
d284 1
d317 2
a318 1
    $test_prog = "$pwd/$test_prog" if substr($test_prog, 0, 1) ne '/';
d320 1
a320 1
	if (! -x $test_prog && $os ne 'os2');
@


1.38
log
@• protect POSIX builtins and utilities from aliases, e.g:
  ‣ : → \:
  ‣ alias → \alias
    ⇒ except in some internally used cases, where we use \builtin alias
  ‣ command . → \command .
• protect Korn Shell builtins from aliases and functions, e.g:
  ‣ typeset → \builtin typeset
    ⇒ also unravels the “local” alias used
  ‣ print → \builtin print
• protect internally-used things from aliases
  ‣ “let]” is not a valid function name
  ‣ “set” is POSIX so we don’t expect anyone to override it in a function
• use “command -v” instead of “whence -p” (“which”) in most
  places; thanks izabera from #ed on IRC for pointing out
  that “command -v” is POSIX – except, “whence -p” a̲l̲w̲a̲y̲s̲ looks
  for an executable and shows its full pathname; “command -v”
  also resolves to aliases, functions and builtins, so only use
  it where it makes any sense (both never output to stderr)
• make most of dot.mkshrc work in the face of such aliases
  ‣ “ulimit -c” is used; this is not POSIX, and not portable;
    maybe we should make ulimit accept-and-ignore the most
    common limits even if the OS doesn’t use them?
• update list of builtin aliases in the manpage
@
text
@d1168 1
a1168 1
	} elsif ($val !~ /^([\s<>+-=*%\/&|!()]|\b[wse]\b|\bSIG[A-Z][A-Z0-9]*\b)+$/) {
@


1.37
log
@better output in the face of both expected-fail:yes and need-pass:no tests
@
text
@d5 1
a5 1
#		2012, 2013, 2014
d571 1
a571 1
	#XXX realpathise, use which/whence -p, or sth. like that
@


1.37.2.1
log
@MFC most things (see mksh.hts) to R50-stable; sync clog
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.pl,v 1.37 2014/08/19 07:43:32 tg Exp $
d5 1
a5 1
#		2012, 2013, 2014, 2015
d571 1
a571 1
	#XXX realpathise, use command -v/whence -p/which, or sth. like that
@


1.37.2.2
log
@MFC a bugfix in the manpage (x=([1]=x) is gone) and checksuite driver
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.pl,v 1.39 2015/04/29 19:01:03 tg Exp $
d1168 1
a1168 1
	} elsif ($val !~ /^([\s\d<>+=*%\/&|!()-]|\b[wse]\b|\bSIG[A-Z][A-Z0-9]*\b)+$/) {
@


1.36
log
@fix some of the signal stuff (still didn’t get rid of awk(1) and printf(1)
calls in Build.sh, we need HOSTCC for that… which we should do, using BER
or something encoded for integers, and pregenerated hashtables as planned)

also, bump to R50 beta, due to today’s language changes
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.pl,v 1.35 2014/01/25 22:45:49 tg Exp $
d351 1
@


1.35
log
@improved debugging, and chop the input
discovered while debugging lewellyn’s issue on Interix
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.pl,v 1.34 2013/12/15 15:45:31 tg Exp $
d915 1
a915 1
	$expr =~ s/\b(SIG[A-Z0-9]+)\b/&$1/g;
d1167 1
a1167 1
	} elsif ($val !~ /^([\s<>+-=*%\/&|!()]|\b[wse]\b|\bSIG[A-Z0-9]+\b)+$/) {
@


1.34
log
@play catchup with weird obsd reorg (in which they lost a few tests, even…)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.pl,v 1.32 2013/07/21 18:35:56 tg Exp $
d5 1
a5 1
#		2012, 2013
d935 1
d941 1
a941 1
	    print STDERR "$prog:$file:$.: unrecognised line\n";
@


1.33
log
@don’t use File::Temp because it’s Perl >= 5.6.1 only

spotted by RT
@
text
@d2 1
a2 1
# $OpenBSD: th,v 1.16 2013/06/14 20:52:08 millert Exp $
@


1.32
log
@partial merge and full RCS ID sync with oksh

merged:
• new regression tests
• check.pl (tests/th) better tmpfile handling
• exec.c 1.50: POSIX specifies that for an AND/OR list,
  only the last command's exit status matters for "set -e"
• ksh.1 1.147: document the above
• eval.c 1.39: “Make $(< /nonexistent) have the same behaviour
  as $(cat /nonexistent) wrt. errors (do not unwind and do not
  treat this as fatal if set -e is used).”
  ‣ additionally make shf_open() return errno and actually show
    the error message from the system
• regression-39 test: remove the “maybe” marker
  ‣ but decide on correct POSIX behaviour

already been fixed in mksh:
• check.pl (tests/th) exit 1 if tests fail

not merged:
• main.c 1.52: run traps in unwind() before exiting;
  I’m pretty sure this is already working as-should in mksh
• eval.c 1.38: “Commands executed via `foo` or $( bar ) should
  not inherit "set -e" status.” As discussed in IRC, this is
  just plainly WRONG.
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.pl,v 1.31 2012/04/06 12:22:14 tg Exp $
a174 1
use File::Temp qw/ :mktemp /;
d253 1
a253 1
$temp_dir = $opt_T || "/tmp";
d302 12
d328 6
a333 9
($fh, $temps) = mkstemp("${temp_dir}/rts.XXXXXXXX");
close($fh);
($fh, $tempi) = mkstemp("${temp_dir}/rti.XXXXXXXX");
close($fh);
($fh, $tempo) = mkstemp("${temp_dir}/rto.XXXXXXXX");
close($fh);
($fh, $tempe) = mkstemp("${temp_dir}/rte.XXXXXXXX");
close($fh);
$tempdir = mkdtemp("${temp_dir}/rtd.XXXXXXXX");
d376 1
@


1.31
log
@rewrite the EINTR importing code with help of stsc from #nosec on IRC,
and add a semicolon to the end of the BEGIN block (RT says it fixes LynxOS)
@
text
@d1 2
a2 2
# $MirOS: src/bin/mksh/check.pl,v 1.30 2012/04/01 04:03:08 tg Exp $
# $OpenBSD: th,v 1.13 2006/05/18 21:27:23 miod Exp $
d4 2
a5 1
# Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2011, 2012
d175 1
d182 2
a183 1
Usage: $prog [-Pv] [-C cat] [-e e=v] [-p prog] [-s fn] [-t tmo] name ...
d194 1
a235 6
$temps = "/tmp/rts$$";
$tempi = "/tmp/rti$$";
$tempo = "/tmp/rto$$";
$tempe = "/tmp/rte$$";
$tempdir = "/tmp/rtd$$";

d244 1
a244 1
if (!getopts('C:e:Pp:s:t:v')) {
d254 1
a298 2
die "$prog: couldn't make directory $tempdir - $!\n" if !mkdir($tempdir, 0777);

d316 11
d444 2
a456 2
    return undef if !&scrub_dir($tempdir);

@


1.30
log
@make even Errno.pm optional
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.pl,v 1.29 2012/03/31 18:47:20 tg Exp $
d154 2
a155 1
#use POSIX qw(EINTR);
d157 12
a168 2
	unless (eval "use Errno") {
		warn "couldn't load Errno: $@@";
d170 2
a171 1
}
d577 2
a578 2
	    if ($!{EINTR}) {
		next if $! == EINTR;
@


1.29
log
@use Errno, not POSIX, to get EINTR; maybe this is more portable
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.pl,v 1.27 2011/05/29 02:18:47 tg Exp $
d155 5
a159 1
use Errno;
@


1.28
log
@I have reason to assume this fixes a Cygwin warning (false-positive) seen by RT
@
text
@d154 2
a155 1
use POSIX qw(EINTR);
d561 3
a563 1
	    next if $! == EINTR;
@


1.27
log
@mksh R40 Release Candidate 1

Testsuite:
• add new need-pass: {yes|no} attribute, default yes
• exit with 1 if a need-pass test failed unexpectedly
  idea by Kacper Kornet <draenog@@pld-linux.org>
• mark utf8bom-2 as need-pass: no
Infrstructure:
• add housekeeping function for making a tty raw
• switch functions with unused results to void
• struct op: u.charflag contains last char of ;; in TPAT
• var.c:arraysearch is now a global function
Language:
• add ;& (fall through) and ;| (examine next) delimiters
  in addition to ;; (end case) as zsh extensions, because
  POSIX standardised on ;& already
• add -A (read into array), -N (read exactly n bytes),
  -n (read up to n bytes), -t (timeout) flags for read
  from ksh93
• allow read -N -1 or -n -1 to slurp the entire input
• add -a (read into array the input characters) extension
  specific to mksh to read, idea by David Korn
• add -e (exit with error if PWD was not set correctly
  after a physical cd) to cd builtin, mandated by next
  POSIX, and change error codes accordingly
Rewrites:
• full rewrite of read builtin and its manpage section
• add regression tetss for most of the new functionality
• duplicate hexdump demo tests for use of read -a
• use read -raN-1 in dot.mkshrc to get NUL safe base64,
  DJB cdb hash and Jenkins one-at-a-time hash functions
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.pl,v 1.26 2011/03/28 21:58:05 tg Exp $
d4 1
a4 1
# Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2011
d78 1
d266 1
@


1.26
log
@Add “-C regress:no-ctty” option to test.sh for Fedora chroots

STRONGLY DISCOURAGED
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.pl,v 1.25 2011/03/28 21:15:05 tg Exp $
d200 1
d221 1
d309 1
a309 1
$tot_failed = $nfailed + $nxfailed;
d313 1
d315 1
a315 1
    print " (as expected)" if $nfailed && !$nxfailed;
d329 5
a333 1
	$exitcode = 0;
d630 7
a636 2
	    print "FAIL $name\n";
	    $nxfailed++;
d1094 10
@


1.25
log
@• use mksh getopts to parse options in test.sh, collapse multiple -C args
• sort arguments
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.pl,v 1.24 2011/02/27 19:29:19 tg Exp $
d139 2
d199 1
d649 1
d1072 10
@


1.24
log
@port to FreeMiNT: add OS uname and flags; 2>&- is evil™; $UNIXMODE must be preserved; unlink(2) is weird
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.pl,v 1.23 2009/06/10 18:12:43 tg Rel $
d160 1
a160 2
Usage: $prog [-s test-set] [-C category] [-p prog] [-v] [-e e=v] name ...
	-p p	Use p as the program to test
d163 6
a171 2
	-P	program (-p) string has multiple words, and the program is in
		the path (kludge option)
a172 3
	-e e=v	Set the environment variable e to v for all tests
		(if no =v is given, the current value is used)
		Only one -e option can be given at the moment, sadly.
d223 1
a223 1
if (!getopts('C:p:Ps:t:ve:')) {
@


1.23
log
@more KNF, mostly whitespace, this time more manual labour applying style(9)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.pl,v 1.22 2009/05/16 16:59:32 tg Exp $
d4 1
a4 1
# Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009
d74 2
a75 1
#					    LOGNAME, PATH, SHELL, USER
d257 1
a257 1
  'PATH', 'SHELL', 'USER')) {
@


1.22
log
@• sync distrib/special/mksh/Makefile with bin/mksh/Build.sh and
  fix the regression test’s results while here, which have been
  broken since cid 10049D9BE5254CE65B8
• get rid of separate copyright file which was intended for De-
  bian; track down commits in all files of oksh-mirbsd and mksh
  to get correct copyright years per-file, as is BSD custom
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.pl,v 1.21 2009/04/07 18:45:19 tg Stab $
d38 1
a38 1
#	standard input is a file containing "echo hi*\nfalse\n".  The program
d44 10
a53 10
#   - blank lines and lines starting with # are ignored
#   - a test file contains a series of tests
#   - a test is a series of tag:value pairs ended with a "---" line
#     (leading/trailing spaces are stripped from the first line of value)
#   - test tags are:
#	Tag			  Flag	Description
#	-----			  ----	-----------
#	name			    r	The name of the test; should be unique
#	description		    m	What test does
#	arguments		    M	Arguments to pass to the program;
d55 1
a55 1
#	script			    m	Value is written to a file which
d58 1
a58 1
#	stdin			    m	Value is written to a file which is
d61 2
a62 2
#	perl-setup		    m	Value is a perl script which is executed
#					just before the test is run.  Try to
d64 2
a65 2
#	perl-cleanup		    m	Value is a perl script which is executed
#					just after the test is run.  Try to
d67 1
a67 1
#	env-setup		    M	Value is a list of NAME=VALUE elements
d69 1
a69 1
#					the test is run.  If the =VALUE is
d71 1
a71 1
#					environment.  Programs are run with
d80 2
a81 2
#	file-setup		    mps Used to create files, directories
#					and symlinks.  First word is either
d87 1
a87 1
#					(if any).  The first word may be
d90 1
a90 1
#	file-result		    mps Used to verify a file, symlink or
d104 1
a104 1
#					(if any).  The first word may be
d110 1
a110 1
#					SIGKILL N seconds.  Default is no
d113 1
a113 1
#	expected-exit			expected exit code.  Can be a number,
d117 1
a117 1
#	expected-stdout		    m	What the test should generate on stdout;
d119 1
a119 1
#	expected-stdout-pattern	    m	A perl pattern which matches the
d121 1
a121 1
#	expected-stderr		    m	What the test should generate on stderr;
d123 1
a123 1
#	expected-stderr-pattern	    m	A perl pattern which matches the
d125 1
a125 1
#	category		    m	Specify a comma separated list of
d127 1
a127 1
#					is to be run for.  A category can be
d132 1
a132 1
#					on other versions.  The category(s) of
d140 2
a141 2
#	m	value can be multiple lines.  Lines must be prefixed with
#		a tab.  If the value part of the initial tag:value line is
d178 18
a195 18
	    'name',			'r',
	    'description',		'm',
	    'arguments',		'M',
	    'script',			'm',
	    'stdin',			'm',
	    'perl-setup',		'm',
	    'perl-cleanup',		'm',
	    'env-setup',		'M',
	    'file-setup',		'mps',
	    'file-result',		'mps',
	    'time-limit',		'',
	    'expected-fail',		'',
	    'expected-exit',		'',
	    'expected-stdout',		'm',
	    'expected-stdout-pattern',	'm',
	    'expected-stderr',		'm',
	    'expected-stderr-pattern',	'm',
	    'category',			'm',
d199 2
a200 2
	    ':full-name', 1,		# file:name
	    ':long-name', 1,		# dir/file:lineno:name
d203 1
a203 1
# Categories of the program under test.  Provide the current
d206 1
a206 1
	    "os:$os", '1'
@


1.21
log
@pass LOCPATH environment variable too, might be needed on glibc systems
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.pl,v 1.20 2009/03/22 16:59:18 tg Exp $
d4 18
@


1.20
log
@spelling fixes, from oksh
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.pl,v 1.19 2008/12/20 20:21:19 tg Exp $
d55 2
a56 2
#					    HOME, LD_LIBRARY_PATH, LOGNAME,
#					    PATH, SHELL, USER
d237 2
a238 1
foreach $env (('HOME', 'LD_LIBRARY_PATH', 'LOGNAME', 'PATH', 'SHELL', 'USER')) {
@


1.19
log
@revision 1.13 told lies and was an incomplete commit
d’oh, nobody noticed, as nobody uses icc anyway… but
MirPorts llvm-gcc currently is similarily broken ;-)
@
text
@d1 2
a2 2
# $MirOS: src/bin/mksh/check.pl,v 1.18 2008/07/14 14:53:23 tg Exp $
# $OpenBSD: th,v 1.12 2005/05/28 04:53:47 millert Exp $
d924 1
a924 1
		    "$prog:$file:$.: bad paramter line for file-setup field\n";
d961 1
a961 1
		    "$prog:$file:$.: bad paramter line for file-result field\n";
@


1.18
log
@prevent using a possibly undefined variable
(although the perl installation in question is probably broken)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.pl,v 1.17 2008/04/01 16:26:42 tg Exp $
d55 2
a56 2
#					    USER, LOGNAME, HOME,
#					    LD_LIBRARY_PATH, PATH, SHELL
d237 1
a237 1
foreach $env (('USER', 'LOGNAME', 'HOME', 'PATH', 'SHELL')) {
@


1.17
log
@… and $__perlname (for perl5 ipv perl, etc.)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.pl,v 1.16 2008/04/01 16:01:45 tg Exp $
d241 1
a241 1
if (($^O eq 'VMS') || ($Config{perlpath} =~ m/$Config{_exe}$/i)) {
@


1.16
log
@export __progname as environment to the test script,
so that the "$0" abuse can stop
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.pl,v 1.15 2008/03/23 20:54:29 tg Exp $
d61 1
d134 1
d241 5
@


1.15
log
@fix environment handling for perl 5.003_02
gotta love 1997’s software
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.pl,v 1.14 2008/02/29 12:48:09 tg Exp $
d60 1
d497 4
@


1.14
log
@mention only one -e works
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.pl,v 1.13 2008/02/29 12:47:03 tg Exp $
a247 7
# The following doesn't work with perl5...  Need to do it explicitly - yuck.
#%ENV = %new_env;
foreach $k (keys(%ENV)) {
    delete $ENV{$k};
}
$ENV{$k} = $v while ($k,$v) = each %new_env;

d463 1
a463 1
		    delete $ENV{$var};
d465 1
a465 1
		    $ENV{substr($var, 0, $i)} = substr($var, $i + 1);
d495 8
@


1.14.2.1
log
@MFC: mksh-R33d code, mksh-current dot.mkshrc
(this code is MirBSD-specific, as Build.sh is not included)
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.pl,v 1.17 2008/04/01 16:26:42 tg Exp $
a59 2
#					__progname is set to the -p argument.
#					__perlname is set to $^X (perlexe).
a131 1
use Config;
a237 5
if (($^O eq 'VMS') || ($Config{perlpath} =~ m/$Config{_exe}$/i)) {
	$new_env{'__perlname'} = $Config{perlpath};
} else {
	$new_env{'__perlname'} = $Config{perlpath} . $Config{_exe};
}
d248 7
d470 1
a470 1
		    delete $new_env{$var};
d472 1
a472 1
		    $new_env{substr($var, 0, $i)} = substr($var, $i + 1);
a501 12

	#XXX realpathise, use which/whence -p, or sth. like that
	#XXX if !$program_kludge, we get by with not doing it for now tho
	$new_env{'__progname'} = $argv[0];

	# The following doesn't work with perl5...  Need to do it explicitly - yuck.
	#%ENV = %new_env;
	foreach $k (keys(%ENV)) {
	    delete $ENV{$k};
	}
	$ENV{$k} = $v while ($k,$v) = each %new_env;

@


1.14.2.2
log
@MFC: pull up mksh-R34β since it’ll be required by MirPorts soonish…
@
text
@@


1.14.2.3
log
@MFC: mksh R35b
@
text
@d1 1
a1 1
# $MirOS$
d241 1
a241 1
if (($os eq 'VMS') || ($Config{perlpath} =~ m/$Config{_exe}$/i)) {
@


1.14.2.4
log
@MFC: mksh R36b
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.pl,v 1.18 2008/07/14 14:53:23 tg Exp $
@


1.13
log
@icc needs this
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.pl,v 1.12 2007/10/25 14:44:45 tg Exp $
d150 1
@


1.12
log
@spacing
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.pl,v 1.11 2007/07/01 18:00:00 tg Exp $
d55 2
a56 1
#					    USER, LOGNAME, HOME, PATH, SHELL
@


1.11
log
@use binmode to fix on UWIN
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.pl,v 1.10 2007/02/13 12:59:03 tg Exp $
d255 1
a255 1
chop($pwd = `pwd 2> /dev/null`);
@


1.10
log
@this doesn't need a shebang line, especially not one hardcoding /usr/bin/perl
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.pl,v 1.9 2007/01/12 10:18:19 tg Exp $
d364 1
d478 1
d483 1
d488 1
d668 1
d689 1
@


1.10.2.1
log
@MFC:
• some harmless optimisations
• remove the -fno-tree-vrp and -fwhole-program --combine stuff
• fix a typo
• fix check for __attribute__
• remove the multi idstring check, always use ours
• fix signal stuff
• fix types
• pick up arc4random.c
• don't execute ELF, ECOFF, a.out, PE, gzip, etc. as shell script
• some regression test fixes
• fix large file support

bump version, this is gonna be R29g, but we've got to test that first
@
text
@d1 1
a1 1
# $MirOS: src/bin/mksh/check.pl,v 1.10 2007/02/13 12:59:03 tg Exp $
a363 1
    binmode(IN);
a476 1
	binmode(STDIN);
a480 1
	binmode(STDOUT);
a484 1
	binmode(STDERR);
a663 1
    binmode(TEMP);
a683 1
    binmode(TEMP);
@


1.9
log
@* revert some of the const-warning cleanup which must be done
  with different means (reads, tricky magical kludgery)
  YES, THIS BREAKS -rHEAD, I KNOW.
* while here, fix spelling
@
text
@d1 1
a1 2
#!/usr/bin/perl
# $MirOS: src/bin/mksh/check.pl,v 1.8 2006/05/08 11:59:41 tg Exp $
@


1.9.2.1
log
@merge -rHEAD as of now into the const-correctness branch
@
text
@d1 2
a2 1
# $MirOS: src/bin/mksh/check.pl,v 1.10 2007/02/13 12:59:03 tg Exp $
@


1.8
log
@* check.t: add two mkshrc-tests (turn on, turn off)
* check.pl, check.t: add mkshrc-test whether "real" $HOME/.mkshrc interfers
* mksh.1: sync with reality: $ENV unset isn't needed, $ENV='' is enough
  to turn on ~/.mkshrc processing
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/check.pl,v 1.7 2005/07/07 23:27:52 tg Exp $
d846 1
a846 1
	    print STDERR "$prog:$file:$.: unrecognized line\n";
d853 1
a853 1
	    print STDERR "$prog:$file:$.: unrecognized field \"$field\"\n";
@


1.7
log
@* move <sys/param.h> include to sh.h
* fix compilation and invocation of test suite with whitespace in
  the pathnames for real, this time
* clean up (especially whitespace)
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/check.pl,v 1.6 2005/06/08 21:39:59 tg Exp $
d59 1
d236 1
@


1.6
log
@beautify
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/check.pl,v 1.5 2005/06/08 11:06:45 tg Exp $
d20 1
a20 1
#	This runs the test-program (eg, pdksh) with the arguments -x and -f,
a486 1
	    $test_prog =~ s/ /\\ /g;
d495 1
a495 1
	exec(@@argv);
@


1.5
log
@use modern modules and blahblah
from openbsd, by Han Boetes originally

also, clean up comments a bit
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/check.pl,v 1.4 2005/06/05 16:38:19 tg Exp $
d137 1
a137 1
Usage: $prog [-s test-set] [-C category] [-p prog] [-v] [-e e=v] test-name ...
d149 2
a150 2
    test-name(s) specifies the name of the test(s) to run; if none are
    specified, all tests are run.
d183 1
a183 1
	"os:$os", '1'
a381 2
    #print "Running test $name...\n" if $verbose;

d406 1
a406 1
	    #
a407 1
	    #
d893 1
a893 1
		#
d896 1
a896 1
		#
d899 1
a899 1
		    #
a900 1
		    #
d936 1
a936 1
		    #
a937 1
		    #
d1124 1
a1124 1
	#
a1125 1
	#
d1196 2
a1197 1
sub HELP_MESSAGE
@


1.4
log
@mksh R22d
@
text
@d2 2
a3 2
# $MirOS: src/bin/mksh/check.pl,v 1.3 2005/05/30 07:05:29 tg Exp $
# $OpenBSD: th,v 1.11 2004/11/29 06:20:02 jsg Exp $
a4 2
# Test harness for pdksh tests.
#
d128 3
a130 1
#
a133 4
require 'signal.ph' unless $os eq 'os2';
require 'errno.ph' unless $os eq 'os2';
require 'getopts.pl';

a152 1
#
a153 1
#
a182 1
#	(defined $^O ? "os:$^O" : "os:unknown"), '1'
d199 1
a199 1
if (!&Getopts('C:p:Ps:t:ve:')) {
d512 1
a512 1
	    next if $! == &EINTR;
d1201 6
@


1.3
log
@this commit made my dedicated server reboot spontaneously,
but the Pentium 120 with a Hercules graphics card (anno 1981)
survives it:

allow building and running the testsuite if the source or
build directory contain spaces (not unusual on Windows)
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/check.pl,v 1.2 2005/05/23 14:48:21 tg Exp $
d90 1
a90 1
#	time-limit		    	Time limit - the program is sent a
d93 2
a94 2
#	expected-fail		    	'yes' if the test is expected to fail.
#	expected-exit		    	expected exit code.  Can be a number,
d268 1
a268 1
    	if (! -x $test_prog && $os ne 'os2');
d946 1
a946 1
		    	  $rest, $c, $len, $name);
@


1.2
log
@fix running of all tests
@
text
@d2 1
a2 1
# $MirOS: src/bin/mksh/check.pl,v 1.1 2005/05/23 03:06:05 tg Exp $
d497 1
@


1.1
log
@Add mirbsdksh R21, which was developed in a temporary external CVS repo-
sitory whose ChangeLog follows. mksh R21 is licenced under the MirOS li-
cence, shown in "sh.h", and a two-clause UCB-style licence by Marc Espie
as shown in "alloc.c".

This executable is a fair bit smaller and shorter than our /bin/ksh that
it is designed to eventually replace (as /bin/sh hardlink), with the old
/bin/ksh to completely vanish. It is still in beta testing though, and I
don't think it will compile on other operating systems.

mksh R21 is a completely new port, bringing together the OpenBSD-current
/bin/ksh, the MirOS-current /bin/ksh and the older mksh R20 (which still
was portable, ocvs-based).
@
text
@d2 1
a2 1
# $MirOS: mksh/tests/th,v 1.2 2005/05/22 20:54:16 tg Exp $
d623 1
@

