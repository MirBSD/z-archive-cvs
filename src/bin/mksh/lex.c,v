head	1.250;
access;
symbols
	mksh-R57:1.250
	mksh-R56c:1.247
	mksh-R56b:1.239
	mksh-R56:1.239
	mksh-R55:1.234
	mksh-R54:1.228
	mksh-R53a:1.228
	mksh-R53:1.228
	mksh-R52c:1.222
	mksh-R52b:1.218
	mksh-R52:1.214
	mksh-R51:1.204
	mksh-R50f:1.193.2.5
	mksh-R50e:1.193.2.1
	mksh-R50stable:1.193.0.2
	mksh-R50d:1.193
	mksh-R50c:1.193
	mksh-R50b:1.193
	mksh-R50:1.193
	mksh-R49:1.192
	mksh-R48b:1.189
	mksh-R48:1.188
	mksh-R47:1.186
	mksh-R46:1.185
	mksh-R45:1.184
	mksh-R44:1.182
	mksh-R43:1.182
	mksh-R42b:1.179
	mksh-R41c:1.171.2.1
	mksh-R41b:1.171.2.1
	mksh-R42:1.179
	mksh-R41:1.171
	mksh-R41stable:1.171.0.2
	mksh-wheezy:1.164.0.2
	tg-multikey-bind:1.163.0.2
	mksh-R40f:1.160
	mksh-R40e:1.158
	mksh-R40d:1.158
	mksh-R40c:1.157
	mksh-R40b:1.153
	mksh-R40stable:1.160.0.2
	mksh-R40:1.153
	mksh-R39c:1.110
	mksh-R39b:1.107
	tg-wcswidth-behaviour:1.101.0.2
	tg-nameref:1.93.0.2
	mksh-R39:1.89
	tg-mksh-printf-builtin:1.89.0.2
	mksh-R38c:1.87
	mksh-R38b:1.85
	mksh-R38:1.85
	mksh-R37c:1.82
	mksh-R37b:1.80
	mksh-R37:1.80
	mksh-R36b:1.79
	tg-aalloc-experimental_BASE:1.76
	tg-aalloc-experimental:1.76.0.2
	mksh-R36:1.73
	mksh-R35b:1.66
	mksh-R35:1.65
	mksh-R33d:1.57
	mksh-R33c:1.57
	mksh-R33b:1.57
	MIRBSD_10:1.56.0.2
	MIRBSD_10_BASE:1.56
	mksh-R33:1.54
	mksh-R32:1.48
	mksh-R31d:1.47
	mksh-R31c:1.47
	mksh-R31b:1.47
	mksh-R31:1.47
	mksh-R30:1.46
	mksh-R29g:1.29.2.2
	mksh-R29f:1.29.2.1
	mksh-R29e:1.29.2.1
	mksh-R29stable:1.29.0.2
	mksh-R29d:1.29
	mksh-R29c:1.28
	mksh-R29b:1.26
	mksh-R29:1.26
	mksh-R28:1.21
	tg-mksh-plan9ape_BASE:1.21
	tg-mksh-plan9ape:1.21.0.2
	mksh-R27e:1.13
	MIRBSD_9_BASE:1.12
	mksh-R27d:1.12
	mksh-R27:1.12
	mksh-R26c:1.11
	mksh-R26b:1.10
	MIRBSD_8:1.10.0.2
	MIRBSD_8_BASE:1.10
	mksh-R26:1.10
	mksh-R25:1.8
	mksh-R24c:1.7
	mksh-R24b:1.7
	mksh-R24:1.7
	mksh-R23:1.4
	mksh-R22:1.2
	mksh-R21:1.1;
locks; strict;
comment	@ * @;


1.250
date	2018.10.20.18.34.14;	author tg;	state Exp;
branches;
next	1.249;
commitid	1005BCB75350DE2840C;

1.249
date	2018.04.27.16.59.50;	author tg;	state Exp;
branches;
next	1.248;
commitid	1005AE35714449AB38C;

1.248
date	2018.03.09.01.29.11;	author tg;	state Exp;
branches;
next	1.247;
commitid	1005AA1E36666A5C695;

1.247
date	2018.01.14.01.44.01;	author tg;	state Exp;
branches;
next	1.246;
commitid	1005A5AB5F87C24D8D1;

1.246
date	2018.01.14.01.25.28;	author tg;	state Exp;
branches;
next	1.245;
commitid	1005A5AB1996868988F;

1.245
date	2018.01.14.00.57.55;	author tg;	state Exp;
branches;
next	1.244;
commitid	1005A5AAB2134DFC898;

1.244
date	2018.01.14.00.51.35;	author tg;	state Exp;
branches;
next	1.243;
commitid	1005A5AA9AC48DFD600;

1.243
date	2018.01.14.00.22.28;	author tg;	state Exp;
branches;
next	1.242;
commitid	1005A5AA2D643C73A14;

1.242
date	2018.01.14.00.03.02;	author tg;	state Exp;
branches;
next	1.241;
commitid	1005A5A9E3D208A81CB;

1.241
date	2018.01.13.23.55.11;	author tg;	state Exp;
branches;
next	1.240;
commitid	1005A5A9C627E45C2B1;

1.240
date	2017.10.17.23.45.18;	author tg;	state Exp;
branches;
next	1.239;
commitid	10059E695CD2C830620;

1.239
date	2017.05.05.22.53.29;	author tg;	state Exp;
branches;
next	1.238;
commitid	100590D026845CD3DFF;

1.238
date	2017.05.05.20.36.02;	author tg;	state Exp;
branches;
next	1.237;
commitid	100590CE24264B3D492;

1.237
date	2017.04.28.00.38.31;	author tg;	state Exp;
branches;
next	1.236;
commitid	10059028F0E0808B3E9;

1.236
date	2017.04.27.20.22.25;	author tg;	state Exp;
branches;
next	1.235;
commitid	1005902531266D3FCB6;

1.235
date	2017.04.27.19.33.51;	author tg;	state Exp;
branches;
next	1.234;
commitid	100590247A92C66CAF9;

1.234
date	2017.04.06.01.59.55;	author tg;	state Exp;
branches;
next	1.233;
commitid	10058E5A1067AFA1BBA;

1.233
date	2017.04.06.00.41.41;	author tg;	state Exp;
branches;
next	1.232;
commitid	10058E58ECF695338FA;

1.232
date	2017.03.26.00.10.24;	author tg;	state Exp;
branches;
next	1.231;
commitid	10058D706207E0A1FF4;

1.231
date	2017.03.22.00.20.43;	author tg;	state Exp;
branches;
next	1.230;
commitid	10058D1C35C5D0C4C46;

1.230
date	2017.03.12.02.04.14;	author tg;	state Exp;
branches;
next	1.229;
commitid	10058C4AC2520F8C875;

1.229
date	2017.02.18.02.33.12;	author tg;	state Exp;
branches;
next	1.228;
commitid	10058A7B271530B4CED;

1.228
date	2016.08.01.21.38.03;	author tg;	state Exp;
branches;
next	1.227;
commitid	100579FC12F14735847;

1.227
date	2016.07.25.21.05.21;	author tg;	state Exp;
branches;
next	1.226;
commitid	10057967F184AB0E82A;

1.226
date	2016.07.25.00.04.44;	author tg;	state Exp;
branches;
next	1.225;
commitid	1005795579F14A3FE5C;

1.225
date	2016.06.25.23.55.00;	author tg;	state Exp;
branches;
next	1.224;
commitid	100576F19E14572FB35;

1.224
date	2016.05.05.22.45.58;	author tg;	state Exp;
branches;
next	1.223;
commitid	100572BCD1534586213;

1.223
date	2016.04.09.13.55.11;	author tg;	state Exp;
branches;
next	1.222;
commitid	100570909A43DABCFC0;

1.222
date	2016.03.01.19.22.31;	author tg;	state Exp;
branches;
next	1.221;
commitid	10056D5EBFF7582D948;

1.221
date	2016.03.01.18.30.04;	author tg;	state Exp;
branches;
next	1.220;
commitid	10056D5DFC11D3566D1;

1.220
date	2016.03.01.18.00.08;	author tg;	state Exp;
branches;
next	1.219;
commitid	10056D5D8AF01B31531;

1.219
date	2016.01.21.18.24.41;	author tg;	state Exp;
branches;
next	1.218;
commitid	10056A12268001BF859;

1.218
date	2016.01.20.21.34.12;	author tg;	state Exp;
branches;
next	1.217;
commitid	100569FFD594609A81E;

1.217
date	2016.01.19.23.12.14;	author tg;	state Exp;
branches;
next	1.216;
commitid	100569EC2AE617A4288;

1.216
date	2016.01.19.23.09.48;	author tg;	state Exp;
branches;
next	1.215;
commitid	100569EC1FA2A6457B1;

1.215
date	2016.01.14.19.52.20;	author tg;	state Exp;
branches;
next	1.214;
commitid	1005697FC706232D2F1;

1.214
date	2015.12.12.19.05.52;	author tg;	state Exp;
branches;
next	1.213;
commitid	100566C70181761C132;

1.213
date	2015.10.24.19.46.10;	author tg;	state Exp;
branches;
next	1.212;
commitid	100562BE0036C605830;

1.212
date	2015.10.09.19.29.48;	author tg;	state Exp;
branches;
next	1.211;
commitid	100561815B853CF84EB;

1.211
date	2015.10.09.17.48.51;	author tg;	state Exp;
branches;
next	1.210;
commitid	1005617FE066005352E;

1.210
date	2015.10.09.16.11.16;	author tg;	state Exp;
branches;
next	1.209;
commitid	1005617E72E4A2BA371;

1.209
date	2015.09.06.19.47.00;	author tg;	state Exp;
branches;
next	1.208;
commitid	10055EC98215F2B5F9C;

1.208
date	2015.09.06.13.10.48;	author tg;	state Exp;
branches;
next	1.207;
commitid	10055EC3B713C1AA0C1;

1.207
date	2015.09.05.20.20.46;	author tg;	state Exp;
branches;
next	1.206;
commitid	10055EB4EA5242ECCAA;

1.206
date	2015.09.05.19.19.06;	author tg;	state Exp;
branches;
next	1.205;
commitid	10055EB402C54C3076B;

1.205
date	2015.08.13.21.04.12;	author tg;	state Exp;
branches;
next	1.204;
commitid	10055CD064A7F3E0C1E;

1.204
date	2015.07.05.19.53.46;	author tg;	state Exp;
branches;
next	1.203;
commitid	10055998B5B2E027FD0;

1.203
date	2015.07.05.19.37.16;	author tg;	state Exp;
branches;
next	1.202;
commitid	1005599876B5247136B;

1.202
date	2015.07.05.13.49.42;	author tg;	state Exp;
branches;
next	1.201;
commitid	100559935FE5FBD93DF;

1.201
date	2015.04.29.20.07.33;	author tg;	state Exp;
branches;
next	1.200;
commitid	100554139453DB97755;

1.200
date	2015.04.19.18.50.36;	author tg;	state Exp;
branches;
next	1.199;
commitid	1005533F8D6407346B7;

1.199
date	2015.04.11.22.03.30;	author tg;	state Exp;
branches;
next	1.198;
commitid	1005529999F77F915AE;

1.198
date	2015.03.20.23.37.39;	author tg;	state Exp;
branches;
next	1.197;
commitid	100550CAF5C47659F89;

1.197
date	2015.03.14.05.23.15;	author tg;	state Exp;
branches;
next	1.196;
commitid	1005503C5CA29059CD3;

1.196
date	2015.03.01.16.02.48;	author tg;	state Exp;
branches;
next	1.195;
commitid	10054F3383E4E01EF7A;

1.195
date	2014.12.15.22.50.10;	author tg;	state Exp;
branches;
next	1.194;
commitid	100548F65AB2DD01C69;

1.194
date	2014.11.19.18.44.11;	author tg;	state Exp;
branches;
next	1.193;
commitid	100546CE4F2089B6886;

1.193
date	2014.06.29.11.28.28;	author tg;	state Exp;
branches
	1.193.2.1;
next	1.192;
commitid	10053AFF8604CE197F5;

1.192
date	2014.01.11.18.09.40;	author tg;	state Exp;
branches;
next	1.191;
commitid	10052D188DD7DFEC194;

1.191
date	2014.01.05.19.11.45;	author tg;	state Exp;
branches;
next	1.190;
commitid	10052C9AE727A4482D3;

1.190
date	2013.11.17.22.19.42;	author tg;	state Exp;
branches;
next	1.189;
commitid	100528941112B1A0586;

1.189
date	2013.08.16.10.59.03;	author tg;	state Exp;
branches;
next	1.188;
commitid	100520E05EA33BA2E83;

1.188
date	2013.08.10.13.44.31;	author tg;	state Exp;
branches;
next	1.187;
commitid	100520643B4127D9BCA;

1.187
date	2013.07.26.20.33.38;	author tg;	state Exp;
branches;
next	1.186;
commitid	10051F2DD36363A1B44;

1.186
date	2013.06.01.00.15.57;	author tg;	state Exp;
branches;
next	1.185;
commitid	10051A93D525FED429B;

1.185
date	2013.05.02.21.59.49;	author tg;	state Exp;
branches;
next	1.184;
commitid	1005182E1E55272FF6B;

1.184
date	2013.03.29.17.33.55;	author tg;	state Exp;
branches;
next	1.183;
commitid	1005155D0985F77FD2A;

1.183
date	2013.03.24.15.01.48;	author tg;	state Exp;
branches;
next	1.182;
commitid	100514F15711E9EFAB7;

1.182
date	2013.02.19.18.45.20;	author tg;	state Exp;
branches;
next	1.181;
commitid	1005123C815760131DF;

1.181
date	2013.02.17.06.05.02;	author tg;	state Exp;
branches;
next	1.180;
commitid	100512072B8384008A7;

1.180
date	2013.02.17.05.40.16;	author tg;	state Exp;
branches;
next	1.179;
commitid	10051206D50560C037D;

1.179
date	2013.02.10.17.18.48;	author tg;	state Exp;
branches;
next	1.178;
commitid	1005117D6794EBEDD21;

1.178
date	2013.01.19.19.47.11;	author tg;	state Exp;
branches;
next	1.177;
commitid	10050FAF850424A45DD;

1.177
date	2013.01.19.18.32.56;	author tg;	state Exp;
branches;
next	1.176;
commitid	10050FAE6D775E28DAF;

1.176
date	2013.01.19.17.49.46;	author tg;	state Exp;
branches;
next	1.175;
commitid	10050FADCC17E4F9C71;

1.175
date	2013.01.19.17.20.02;	author tg;	state Exp;
branches;
next	1.174;
commitid	10050FAD5CF78028287;

1.174
date	2012.12.05.19.38.20;	author tg;	state Exp;
branches;
next	1.173;
commitid	10050BFA2C0046FB3B9;

1.173
date	2012.12.05.18.54.08;	author tg;	state Exp;
branches;
next	1.172;
commitid	10050BF986807E3B0C1;

1.172
date	2012.11.30.20.19.12;	author tg;	state Exp;
branches;
next	1.171;
commitid	10050B914D41435E735;

1.171
date	2012.11.30.19.02.08;	author tg;	state Exp;
branches
	1.171.2.1;
next	1.170;
commitid	10050B902B82AAA0C3F;

1.170
date	2012.10.30.20.49.41;	author tg;	state Exp;
branches;
next	1.169;
commitid	10050903D7D16EDB58E;

1.169
date	2012.10.22.20.19.13;	author tg;	state Exp;
branches;
next	1.168;
commitid	1005085AA537A17A752;

1.168
date	2012.10.03.17.24.20;	author tg;	state Exp;
branches;
next	1.167;
commitid	100506C74D35719B33B;

1.167
date	2012.08.17.18.34.21;	author tg;	state Exp;
branches;
next	1.166;
commitid	100502E8EAA4BFCF410;

1.166
date	2012.07.30.21.37.12;	author tg;	state Exp;
branches;
next	1.165;
commitid	1005016FE9B27F9F4DC;

1.165
date	2012.07.01.15.54.55;	author tg;	state Exp;
branches;
next	1.164;
commitid	1004FF072DE3F1A3116;

1.164
date	2012.06.28.20.05.07;	author tg;	state Exp;
branches;
next	1.163;
commitid	1004FECB8FB4B2757ED;

1.163
date	2012.05.04.22.44.33;	author tg;	state Exp;
branches;
next	1.162;
commitid	1004FA45BE357DA71DC;

1.162
date	2012.05.04.20.49.04;	author tg;	state Exp;
branches;
next	1.161;
commitid	1004FA4409A67B135DE;

1.161
date	2012.04.07.11.19.49;	author tg;	state Exp;
branches;
next	1.160;
commitid	1004F8022E670BC1C0E;

1.160
date	2012.03.31.17.29.59;	author tg;	state Exp;
branches;
next	1.159;
commitid	1004F773F2D0016E021;

1.159
date	2012.03.29.19.23.00;	author tg;	state Exp;
branches;
next	1.158;
commitid	1004F74B525291EF6DE;

1.158
date	2011.11.26.17.56.30;	author tg;	state Exp;
branches;
next	1.157;
commitid	1004ED12855386724F1;

1.157
date	2011.10.25.22.36.36;	author tg;	state Exp;
branches;
next	1.156;
commitid	1004EA73A0B4E5C1903;

1.156
date	2011.09.07.15.24.16;	author tg;	state Exp;
branches;
next	1.155;
commitid	1004E678C6929FE60A6;

1.155
date	2011.08.27.18.06.47;	author tg;	state Exp;
branches;
next	1.154;
commitid	1004E5932432420AA61;

1.154
date	2011.07.26.16.57.27;	author tg;	state Exp;
branches;
next	1.153;
commitid	1004E2EF1DA23EC569A;

1.153
date	2011.06.04.16.11.18;	author tg;	state Exp;
branches;
next	1.152;
commitid	1004DEA592B5E41F86E;

1.152
date	2011.05.29.06.19.27;	author tg;	state Exp;
branches;
next	1.151;
commitid	1004DE1E57B63B132A8;

1.151
date	2011.05.29.02.18.52;	author tg;	state Exp;
branches;
next	1.150;
commitid	1004DE1AD11046BEFFC;

1.150
date	2011.05.07.00.51.12;	author tg;	state Exp;
branches;
next	1.149;
commitid	1004DC49710562ACCB2;

1.149
date	2011.05.07.00.24.34;	author tg;	state Exp;
branches;
next	1.148;
commitid	1004DC49155257CCEE0;

1.148
date	2011.05.05.00.04.57;	author tg;	state Exp;
branches;
next	1.147;
commitid	1004DC1E8D640072140;

1.147
date	2011.05.02.22.52.51;	author tg;	state Exp;
branches;
next	1.146;
commitid	1004DBF35D72295ADB7;

1.146
date	2011.04.22.12.10.14;	author tg;	state Exp;
branches;
next	1.145;
commitid	1004DB1700F054E7B7E;

1.145
date	2011.03.28.08.27.09;	author tg;	state Exp;
branches;
next	1.144;
commitid	1004D90467358D6B13C;

1.144
date	2011.03.26.16.11.43;	author tg;	state Exp;
branches;
next	1.143;
commitid	1004D8E104206A746DC;

1.143
date	2011.03.26.15.32.37;	author tg;	state Exp;
branches;
next	1.142;
commitid	1004D8E071E7181147C;

1.142
date	2011.03.13.16.35.54;	author tg;	state Exp;
branches;
next	1.141;
commitid	1004D7CF28143D2092B;

1.141
date	2011.03.13.16.20.45;	author tg;	state Exp;
branches;
next	1.140;
commitid	1004D7CEEE36D4AFEF8;

1.140
date	2011.03.13.16.07.36;	author tg;	state Exp;
branches;
next	1.139;
commitid	1004D7CEBDB1E9EDA40;

1.139
date	2011.03.13.16.03.51;	author tg;	state Exp;
branches;
next	1.138;
commitid	1004D7CE9C2063207F0;

1.138
date	2011.03.13.15.57.23;	author tg;	state Exp;
branches;
next	1.137;
commitid	1004D7CE96D48E85688;

1.137
date	2011.03.13.15.31.46;	author tg;	state Exp;
branches;
next	1.136;
commitid	1004D7CE37942665460;

1.136
date	2011.03.13.01.11.58;	author tg;	state Exp;
branches;
next	1.135;
commitid	1004D7C19CD3847DB62;

1.135
date	2011.03.12.23.16.51;	author tg;	state Exp;
branches;
next	1.134;
commitid	1004D7BFEF7328905AB;

1.134
date	2011.03.12.23.04.46;	author tg;	state Exp;
branches;
next	1.133;
commitid	1004D7BFC0825FC39FC;

1.133
date	2011.03.12.22.44.28;	author tg;	state Exp;
branches;
next	1.132;
commitid	1004D7BF75A21025216;

1.132
date	2011.03.12.22.40.02;	author tg;	state Exp;
branches;
next	1.131;
commitid	1004D7BF6502D670A57;

1.131
date	2011.03.12.21.41.13;	author tg;	state Exp;
branches;
next	1.130;
commitid	1004D7BE79D2481A518;

1.130
date	2011.03.12.20.20.16;	author tg;	state Exp;
branches;
next	1.129;
commitid	1004D7BD58B625DCEEE;

1.129
date	2011.03.07.20.32.49;	author tg;	state Exp;
branches;
next	1.128;
commitid	1004D7540D21019BF2E;

1.128
date	2011.03.07.20.30.39;	author tg;	state Exp;
branches;
next	1.127;
commitid	1004D75404D6F4BA14C;

1.127
date	2011.03.07.20.09.34;	author tg;	state Exp;
branches;
next	1.126;
commitid	1004D753B9309B3B23D;

1.126
date	2011.03.07.20.08.48;	author tg;	state Exp;
branches;
next	1.125;
commitid	1004D753B6657DF700B;

1.125
date	2011.03.07.20.07.52;	author tg;	state Exp;
branches;
next	1.124;
commitid	1004D753B0A05C42A3D;

1.124
date	2011.03.06.17.08.12;	author tg;	state Exp;
branches;
next	1.123;
commitid	1004D73BF8011CAE269;

1.123
date	2011.03.06.01.25.33;	author tg;	state Exp;
branches;
next	1.122;
commitid	1004D72E2935F494D4B;

1.122
date	2010.12.19.20.00.54;	author tg;	state Exp;
branches;
next	1.121;
commitid	1004D0E647B738BDF7F;

1.121
date	2010.09.14.21.26.14;	author tg;	state Exp;
branches;
next	1.120;
commitid	1004C8FE654576B0E25;

1.120
date	2010.08.28.20.22.20;	author tg;	state Exp;
branches;
next	1.119;
commitid	1004C796FE40C544CCE;

1.119
date	2010.08.28.18.50.53;	author tg;	state Exp;
branches;
next	1.118;
commitid	1004C795A82072326AF;

1.118
date	2010.07.25.11.35.41;	author tg;	state Exp;
branches;
next	1.117;
commitid	1004C4C211F2951575A;

1.117
date	2010.07.21.11.31.15;	author tg;	state Exp;
branches;
next	1.116;
commitid	1004C46DA7D68DDD451;

1.116
date	2010.07.17.22.09.36;	author tg;	state Exp;
branches;
next	1.115;
commitid	1004C42295452E71B6E;

1.115
date	2010.07.04.18.29.40;	author tg;	state Exp;
branches;
next	1.114;
commitid	1004C30D32C2CAEC82C;

1.114
date	2010.07.04.17.45.14;	author tg;	state Exp;
branches;
next	1.113;
commitid	1004C30C8946816B0C1;

1.113
date	2010.04.08.13.21.06;	author tg;	state Exp;
branches;
next	1.112;
commitid	1004BBDD84556472D84;

1.112
date	2010.03.31.12.20.04;	author tg;	state Exp;
branches;
next	1.111;
commitid	1004BB33DEB65374C8F;

1.111
date	2010.03.27.16.53.16;	author tg;	state Exp;
branches;
next	1.110;
commitid	1004BAE380B7133518B;

1.110
date	2010.02.25.20.18.16;	author tg;	state Exp;
branches;
next	1.109;
commitid	1004B86DB1A7C6BCE8B;

1.109
date	2010.02.23.21.51.49;	author tg;	state Exp;
branches;
next	1.108;
commitid	1004B844DFD34FFF311;

1.108
date	2010.02.18.17.31.23;	author tg;	state Exp;
branches;
next	1.107;
commitid	1004B7D796C24BBD8E1;

1.107
date	2010.01.29.09.34.28;	author tg;	state Exp;
branches;
next	1.106;
commitid	1004B62ABB7333ED94C;

1.106
date	2010.01.28.20.58.32;	author tg;	state Exp;
branches;
next	1.105;
commitid	1004B61FA7F4ADB96C5;

1.105
date	2010.01.28.20.52.08;	author tg;	state Exp;
branches;
next	1.104;
commitid	1004B61F8ED3B383682;

1.104
date	2010.01.25.16.12.56;	author tg;	state Exp;
branches;
next	1.103;
commitid	1004B5DC2A56A6AB278;

1.103
date	2009.12.05.20.17.59;	author tg;	state Exp;
branches;
next	1.102;
commitid	1004B1ABFF06BA6261A;

1.102
date	2009.12.05.19.44.09;	author tg;	state Exp;
branches;
next	1.101;
commitid	1004B1AB81F5A9C5A85;

1.101
date	2009.11.21.23.23.18;	author tg;	state Exp;
branches;
next	1.100;
commitid	1004B08764D5928E063;

1.100
date	2009.10.04.12.45.22;	author tg;	state Exp;
branches;
next	1.99;
commitid	1004AC898E1751BB935;

1.99
date	2009.10.04.12.44.19;	author tg;	state Exp;
branches;
next	1.98;
commitid	1004AC898AF2FF5CD5F;

1.98
date	2009.10.02.18.08.34;	author tg;	state Exp;
branches;
next	1.97;
commitid	1004AC641341D9D9D02;

1.97
date	2009.09.24.17.15.31;	author tg;	state Exp;
branches;
next	1.96;
commitid	1004ABBA8D95908292B;

1.96
date	2009.09.23.18.04.56;	author tg;	state Exp;
branches;
next	1.95;
commitid	1004ABA62C8171BD8E4;

1.95
date	2009.09.19.22.33.10;	author tg;	state Exp;
branches;
next	1.94;
commitid	1004AB55C337595F86E;

1.94
date	2009.09.19.21.54.45;	author tg;	state Exp;
branches;
next	1.93;
commitid	1004AB552F7546C611E;

1.93
date	2009.08.28.22.39.09;	author tg;	state Exp;
branches;
next	1.92;
commitid	1004A985C7414904DFF;

1.92
date	2009.08.28.20.30.56;	author tg;	state Exp;
branches;
next	1.91;
commitid	1004A983E6B745731A0;

1.91
date	2009.08.28.19.57.41;	author tg;	state Exp;
branches;
next	1.90;
commitid	1004A98365B7809CDA1;

1.90
date	2009.08.28.18.53.58;	author tg;	state Exp;
branches;
next	1.89;
commitid	1004A9827D2091BAE42;

1.89
date	2009.07.06.15.06.23;	author tg;	state Exp;
branches;
next	1.88;
commitid	1004A5212AD490123A5;

1.88
date	2009.06.11.12.42.19;	author tg;	state Exp;
branches;
next	1.87;
commitid	1004A30FBB114E3FED9;

1.87
date	2009.06.10.18.12.47;	author tg;	state Exp;
branches;
next	1.86;
commitid	1004A2FF7913BD44883;

1.86
date	2009.06.08.20.06.47;	author tg;	state Exp;
branches;
next	1.85;
commitid	1004A2D6F3A31FB4CBC;

1.85
date	2009.05.27.19.52.36;	author tg;	state Exp;
branches;
next	1.84;
commitid	1004A1D99540BF61ECF;

1.84
date	2009.05.27.09.58.22;	author tg;	state Exp;
branches;
next	1.83;
commitid	1004A1D0E9B4EF3C493;

1.83
date	2009.05.16.16.59.37;	author tg;	state Exp;
branches;
next	1.82;
commitid	1004A0EF0664EF4168D;

1.82
date	2009.04.07.19.13.10;	author tg;	state Exp;
branches;
next	1.81;
commitid	10049DBA5DA72EF04C6;

1.81
date	2009.04.07.19.06.43;	author tg;	state Exp;
branches;
next	1.80;
commitid	10049DBA45A68068BCD;

1.80
date	2009.03.15.18.30.40;	author tg;	state Exp;
branches;
next	1.79;
commitid	10049BD4955503E4A16;

1.79
date	2008.12.13.17.02.15;	author tg;	state Exp;
branches;
next	1.78;
commitid	1004943EAA830C0300B;

1.78
date	2008.12.04.18.11.05;	author tg;	state Exp;
branches;
next	1.77;
commitid	10049381D2D4EEC022C;

1.77
date	2008.12.02.12.39.37;	author tg;	state Exp;
branches;
next	1.76;
commitid	10049352BD82DFF462F;

1.76
date	2008.11.12.00.54.49;	author tg;	state Exp;
branches
	1.76.2.1;
next	1.75;
commitid	100491A295841A6D8EB;

1.75
date	2008.11.11.23.50.29;	author tg;	state Exp;
branches;
next	1.74;
commitid	100491A1A3D7C6B56F1;

1.74
date	2008.10.28.14.32.41;	author tg;	state Exp;
branches;
next	1.73;
commitid	1004907226D3DEFCCD1;

1.73
date	2008.10.10.21.30.42;	author tg;	state Exp;
branches;
next	1.72;
commitid	10048EFC9600438B1CB;

1.72
date	2008.09.30.19.35.10;	author tg;	state Exp;
branches;
next	1.71;
commitid	10048E27F842E008008;

1.71
date	2008.09.30.19.28.12;	author tg;	state Exp;
branches;
next	1.70;
commitid	10048E27DDF2268C631;

1.70
date	2008.09.30.19.25.51;	author tg;	state Exp;
branches;
next	1.69;
commitid	10048E27D493BFBB014;

1.69
date	2008.09.30.17.58.49;	author tg;	state Exp;
branches;
next	1.68;
commitid	10048E268DB48FD2688;

1.68
date	2008.09.30.17.49.26;	author tg;	state Exp;
branches;
next	1.67;
commitid	10048E266AB7BDA06AF;

1.67
date	2008.09.20.14.17.30;	author tg;	state Exp;
branches;
next	1.66;
commitid	10048D505E331E8836B;

1.66
date	2008.07.12.16.56.39;	author tg;	state Exp;
branches;
next	1.65;
commitid	1004878E22B104A657A;

1.65
date	2008.07.09.21.32.43;	author tg;	state Exp;
branches;
next	1.64;
commitid	10048752E6271CABA24;

1.64
date	2008.07.09.20.41.23;	author tg;	state Exp;
branches;
next	1.63;
commitid	1004875224553997258;

1.63
date	2008.07.08.22.28.25;	author tg;	state Exp;
branches;
next	1.62;
commitid	1004873E9F769A6FF23;

1.62
date	2008.06.28.22.51.54;	author tg;	state Exp;
branches;
next	1.61;
commitid	1004866BFA427FDEFB9;

1.61
date	2008.06.28.22.01.44;	author tg;	state Exp;
branches;
next	1.60;
commitid	1004866B4DA0D76FFAB;

1.60
date	2008.05.17.18.46.59;	author tg;	state Exp;
branches;
next	1.59;
commitid	100482F280E7B53AA4C;

1.59
date	2008.05.04.01.51.30;	author tg;	state Exp;
branches;
next	1.58;
commitid	100481D16AF3E4A7EEA;

1.58
date	2008.04.19.22.15.03;	author tg;	state Exp;
branches;
next	1.57;
commitid	100480A6CC85EC0197B;

1.57
date	2008.03.28.13.46.53;	author tg;	state Exp;
branches;
next	1.56;
commitid	10047ECF6A15422B64A;

1.56
date	2008.03.05.16.49.22;	author tg;	state Exp;
branches
	1.56.2.1;
next	1.55;
commitid	10047CECEDE6B0A1147;

1.55
date	2008.03.05.16.40.57;	author tg;	state Exp;
branches;
next	1.54;
commitid	10047CECD1F746FDAE6;

1.54
date	2008.03.01.21.10.25;	author tg;	state Exp;
branches;
next	1.53;
commitid	10047C9C64165F71A5A;

1.53
date	2008.02.27.01.00.09;	author tg;	state Exp;
branches;
next	1.52;
commitid	10047C4B5C65A58F987;

1.52
date	2008.02.26.21.08.33;	author tg;	state Exp;
branches;
next	1.51;
commitid	10047C47FDA7C07C90D;

1.51
date	2008.02.26.20.43.10;	author tg;	state Exp;
branches;
next	1.50;
commitid	10047C479E866D4A3E1;

1.50
date	2008.02.26.20.35.24;	author tg;	state Exp;
branches;
next	1.49;
commitid	10047C4781501B5CDC4;

1.49
date	2008.02.24.22.12.36;	author tg;	state Exp;
branches;
next	1.48;
commitid	10047C1EBA57E4F4AF0;

1.48
date	2007.10.25.15.27.54;	author tg;	state Exp;
branches;
next	1.47;
commitid	1004720B60E089D48A6;

1.47
date	2007.08.19.23.12.22;	author tg;	state Exp;
branches;
next	1.46;
commitid	10046C8CE5279B1E703;

1.46
date	2007.07.23.14.28.52;	author tg;	state Exp;
branches;
next	1.45;
commitid	10046A4BABC39976409;

1.45
date	2007.07.22.14.01.49;	author tg;	state Exp;
branches;
next	1.44;
commitid	10046A36344350ACD7B;

1.44
date	2007.07.22.13.34.51;	author tg;	state Exp;
branches;
next	1.43;
commitid	10046A35CEC35BB7B5F;

1.43
date	2007.07.07.22.29.36;	author tg;	state Exp;
branches;
next	1.42;
commitid	1004690139E27AD731C;

1.42
date	2007.07.06.02.39.37;	author tg;	state Exp;
branches;
next	1.41;
commitid	100468DAB655B485375;

1.41
date	2007.07.06.02.24.18;	author tg;	state Exp;
branches;
next	1.40;
commitid	100468DA7E073802AA3;

1.40
date	2007.07.06.02.22.56;	author tg;	state Exp;
branches;
next	1.39;
commitid	100468DA78E140683C0;

1.39
date	2007.07.06.01.53.36;	author tg;	state Exp;
branches;
next	1.38;
commitid	100468DA0A207B760AD;

1.38
date	2007.07.05.23.48.53;	author tg;	state Exp;
branches;
next	1.37;
commitid	100468D83762B864F41;

1.37
date	2007.06.23.00.05.04;	author tg;	state Exp;
branches;
next	1.36;
commitid	100467C63BD578038F5;

1.36
date	2007.06.22.23.34.40;	author tg;	state Exp;
branches;
next	1.35;
commitid	100467C5C9519B9C52A;

1.35
date	2007.06.16.15.02.56;	author tg;	state Exp;
branches;
next	1.34;
commitid	1004673FBB32FC07FD4;

1.34
date	2007.06.15.21.55.19;	author tg;	state Exp;
branches;
next	1.33;
commitid	10046730AA46E14A9D1;

1.33
date	2007.06.04.19.25.45;	author tg;	state Exp;
branches;
next	1.32;
commitid	1004664674456E49B33;

1.32
date	2007.05.13.19.14.04;	author tg;	state Exp;
branches;
next	1.31;
commitid	100464763537E100BDF;

1.31
date	2007.05.13.18.07.22;	author tg;	state Exp;
branches;
next	1.30;
commitid	100464753C139AD7515;

1.30
date	2007.05.10.19.22.11;	author tg;	state Exp;
branches;
next	1.29;
commitid	100464370BA2BF5141D;

1.29
date	2007.04.26.11.58.53;	author tg;	state Exp;
branches
	1.29.2.1;
next	1.28;
commitid	10046309414551F7DA5;

1.28
date	2007.04.15.12.28.38;	author tg;	state Exp;
branches;
next	1.27;
commitid	10046221A4C48C9FA1F;

1.27
date	2007.04.15.10.45.58;	author tg;	state Exp;
branches;
next	1.26;
commitid	1004622020D73FDDAF8;

1.26
date	2007.03.04.03.04.26;	author tg;	state Exp;
branches;
next	1.25;
commitid	10045EA374B3374AB35;

1.25
date	2007.01.12.10.18.21;	author tg;	state Exp;
branches;
next	1.24;
commitid	10045A76059104E0EFB;

1.24
date	2006.11.10.07.52.03;	author tg;	state Exp;
branches;
next	1.23;
commitid	10045542F8269E05F56;

1.23
date	2006.11.10.07.18.57;	author tg;	state Exp;
branches;
next	1.22;
commitid	100455427B90A1F6E32;

1.22
date	2006.11.05.15.31.36;	author tg;	state Exp;
branches;
next	1.21;
commitid	100454E03E319796BE0;

1.21
date	2006.08.02.11.33.37;	author tg;	state Exp;
branches;
next	1.20;
commitid	10044D08D5007719200;

1.20
date	2006.08.02.10.42.30;	author tg;	state Exp;
branches;
next	1.19;
commitid	10044D0819F14F6845A;

1.19
date	2006.08.02.10.41.03;	author tg;	state Exp;
branches;
next	1.18;
commitid	10044D080B163DF8431;

1.18
date	2006.08.01.14.59.51;	author tg;	state Exp;
branches;
next	1.17;
commitid	10044CF6C3D59DAED92;

1.17
date	2006.08.01.14.35.44;	author tg;	state Exp;
branches;
next	1.16;
commitid	10044CF66C856AB831E;

1.16
date	2006.08.01.14.10.25;	author tg;	state Exp;
branches;
next	1.15;
commitid	10044CF60E04E385000;

1.15
date	2006.08.01.14.09.19;	author tg;	state Exp;
branches;
next	1.14;
commitid	10044CF609314C13CBE;

1.14
date	2006.08.01.13.43.27;	author tg;	state Exp;
branches;
next	1.13;
commitid	10044CF5A93693A5C0A;

1.13
date	2006.07.03.12.16.30;	author tg;	state Exp;
branches;
next	1.12;
commitid	10044A90AAA1B255EDF;

1.12
date	2006.05.10.18.54.11;	author tg;	state Exp;
branches;
next	1.11;
commitid	100446236E6726083C8;

1.11
date	2006.01.29.20.04.52;	author tg;	state Exp;
branches;
next	1.10;
commitid	10043DD1FE6328EF386;

1.10
date	2005.11.22.18.40.43;	author tg;	state Exp;
branches;
next	1.9;
commitid	108a438366254326;

1.9
date	2005.11.22.18.36.19;	author tg;	state Exp;
branches;
next	1.8;
commitid	659a438364faa8a1;

1.8
date	2005.10.25.19.53.28;	author tg;	state Exp;
branches;
next	1.7;
commitid	76cc435e8d34d8ce;

1.7
date	2005.07.04.12.47.13;	author tg;	state Exp;
branches;
next	1.6;
commitid	499742c92fe4b090;

1.6
date	2005.07.04.12.34.23;	author tg;	state Exp;
branches;
next	1.5;
commitid	4a8342c92cd61cc3;

1.5
date	2005.07.04.12.27.26;	author tg;	state Exp;
branches;
next	1.4;
commitid	3ec342c92b3a8874;

1.4
date	2005.06.08.22.34.03;	author tg;	state Exp;
branches;
next	1.3;
commitid	775142a7726c13a2;

1.3
date	2005.06.08.21.51.21;	author tg;	state Exp;
branches;
next	1.2;
commitid	318442a76849872f;

1.2
date	2005.05.25.23.31.07;	author tg;	state Exp;
branches;
next	1.1;
commitid	6fd242950a6e73e0;

1.1
date	2005.05.23.03.06.08;	author tg;	state Exp;
branches;
next	;
commitid	1a89429147b8402d;

1.193.2.1
date	2015.01.11.22.39.50;	author tg;	state Exp;
branches;
next	1.193.2.2;
commitid	10054B2FBC1440F88AD;

1.193.2.2
date	2015.03.20.22.21.03;	author tg;	state Exp;
branches;
next	1.193.2.3;
commitid	100550C9D521FCB4274;

1.193.2.3
date	2015.03.21.00.12.43;	author tg;	state Exp;
branches;
next	1.193.2.4;
commitid	100550CB7886DC367A3;

1.193.2.4
date	2015.04.12.22.32.28;	author tg;	state Exp;
branches;
next	1.193.2.5;
commitid	100552AF26A429AA816;

1.193.2.5
date	2015.04.19.19.18.19;	author tg;	state Exp;
branches;
next	;
commitid	1005533FF4D64965277;

1.171.2.1
date	2012.12.05.19.58.29;	author tg;	state Exp;
branches;
next	;
commitid	10050BFA7766B61F30F;

1.76.2.1
date	2008.11.22.13.20.32;	author tg;	state Exp;
branches;
next	;
commitid	100492806F80A7B2451;

1.56.2.1
date	2008.04.22.13.29.28;	author tg;	state Exp;
branches;
next	1.56.2.2;
commitid	100480DE80F32BAA72D;

1.56.2.2
date	2008.05.19.18.41.26;	author tg;	state Exp;
branches;
next	1.56.2.3;
commitid	1004831C9A63DA06745;

1.56.2.3
date	2008.07.11.11.49.27;	author tg;	state Exp;
branches;
next	1.56.2.4;
commitid	100487748D62394D033;

1.56.2.4
date	2008.07.18.13.29.45;	author tg;	state Exp;
branches;
next	1.56.2.5;
commitid	10048809AD278B142AC;

1.56.2.5
date	2008.12.14.00.07.44;	author tg;	state Exp;
branches;
next	;
commitid	10049444E5325915C76;

1.29.2.1
date	2007.05.13.19.29.37;	author tg;	state Exp;
branches;
next	1.29.2.2;
commitid	1004647668D4636830B;

1.29.2.2
date	2007.07.05.11.49.20;	author tg;	state Exp;
branches;
next	;
commitid	100468CDAAD5BCF14BE;


desc
@@


1.250
log
@fix #1779179 (another case of signed integers sucking)
@
text
@/*	$OpenBSD: lex.c,v 1.51 2015/09/10 22:48:58 nicm Exp $	*/

/*-
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
 *		 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018
 *	mirabilos <m@@mirbsd.org>
 *
 * Provided that these terms and disclaimer and all copyright notices
 * are retained or reproduced in an accompanying document, permission
 * is granted to deal in this work without restriction, including un-
 * limited rights to use, publicly perform, distribute, sell, modify,
 * merge, give away, or sublicence.
 *
 * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
 * the utmost extent permitted by applicable law, neither express nor
 * implied; without malicious intent or gross negligence. In no event
 * may a licensor, author or contributor be held liable for indirect,
 * direct, other damage, loss, or other issues arising in any way out
 * of dealing in the work, even if advised of the possibility of such
 * damage or existence of a defect, except proven that it results out
 * of said person's immediate fault when using the work as intended.
 */

#include "sh.h"

__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.248 2018/03/09 01:29:11 tg Exp $");

/*
 * states while lexing word
 */
#define SBASE		0	/* outside any lexical constructs */
#define SWORD		1	/* implicit quoting for substitute() */
#define SLETPAREN	2	/* inside (( )), implicit quoting */
#define SSQUOTE		3	/* inside '' */
#define SDQUOTE		4	/* inside "" */
#define SEQUOTE		5	/* inside $'' */
#define SBRACE		6	/* inside ${} */
#define SQBRACE		7	/* inside "${}" */
#define SBQUOTE		8	/* inside `` */
#define SASPAREN	9	/* inside $(( )) */
#define SHEREDELIM	10	/* parsing << or <<- delimiter */
#define SHEREDQUOTE	11	/* parsing " in << or <<- delimiter */
#define SPATTERN	12	/* parsing *(...|...) pattern (*+?@@!) */
#define SADELIM		13	/* like SBASE, looking for delimiter */
#define STBRACEKORN	14	/* parsing ${...[#%]...} !FSH */
#define STBRACEBOURNE	15	/* parsing ${...[#%]...} FSH */
#define SINVALID	255	/* invalid state */

struct sretrace_info {
	struct sretrace_info *next;
	XString xs;
	char *xp;
};

/*
 * Structure to keep track of the lexing state and the various pieces of info
 * needed for each particular state.
 */
typedef struct lex_state {
	union {
		/* point to the next state block */
		struct lex_state *base;
		/* marks start of state output in output string */
		size_t start;
		/* SBQUOTE: true if in double quotes: "`...`" */
		/* SEQUOTE: got NUL, ignore rest of string */
		bool abool;
		/* SADELIM information */
		struct {
			/* character to search for */
			unsigned char delimiter;
			/* max. number of delimiters */
			unsigned char num;
		} adelim;
	} u;
	/* count open parentheses */
	short nparen;
	/* type of this state */
	uint8_t type;
	/* extra flags */
	uint8_t ls_flags;
} Lex_state;
#define ls_base		u.base
#define ls_start	u.start
#define ls_bool		u.abool
#define ls_adelim	u.adelim

/* ls_flags */
#define LS_HEREDOC	BIT(0)

typedef struct {
	Lex_state *base;
	Lex_state *end;
} State_info;

static void readhere(struct ioword *);
static void ungetsc(int);
static void ungetsc_i(int);
static int getsc_uu(void);
static void getsc_line(Source *);
static int getsc_bn(void);
static int getsc_i(void);
static char *get_brace_var(XString *, char *);
static bool arraysub(char **);
static void gethere(void);
static Lex_state *push_state_i(State_info *, Lex_state *);
static Lex_state *pop_state_i(State_info *, Lex_state *);

static int backslash_skip;
static int ignore_backslash_newline;

/* optimised getsc_bn() */
#define o_getsc()	(*source->str != '\0' && *source->str != '\\' && \
			    !backslash_skip ? *source->str++ : getsc_bn())
/* optimised getsc_uu() */
#define	o_getsc_u()	((*source->str != '\0') ? *source->str++ : getsc_uu())

/* retrace helper */
#define o_getsc_r(carg)					\
	int cev = (carg);				\
	struct sretrace_info *rp = retrace_info;	\
							\
	while (rp) {					\
		Xcheck(rp->xs, rp->xp);			\
		*rp->xp++ = cev;			\
		rp = rp->next;				\
	}						\
							\
	return (cev);

/* callback */
static int
getsc_i(void)
{
	o_getsc_r((unsigned int)(unsigned char)o_getsc());
}

#if defined(MKSH_SMALL) && !defined(MKSH_SMALL_BUT_FAST)
#define getsc()		getsc_i()
#else
static int getsc_r(int);

static int
getsc_r(int c)
{
	o_getsc_r(c);
}

#define getsc()		getsc_r((unsigned int)(unsigned char)o_getsc())
#endif

#define STATE_BSIZE	8

#define PUSH_STATE(s)	do {					\
	uint8_t state_flags = statep->ls_flags;			\
	if (++statep == state_info.end)				\
		statep = push_state_i(&state_info, statep);	\
	state = statep->type = (s);				\
	statep->ls_flags = state_flags;				\
} while (/* CONSTCOND */ 0)

#define POP_STATE()	do {					\
	if (--statep == state_info.base)			\
		statep = pop_state_i(&state_info, statep);	\
	state = statep->type;					\
} while (/* CONSTCOND */ 0)

#define PUSH_SRETRACE(s) do {					\
	struct sretrace_info *ri;				\
								\
	PUSH_STATE(s);						\
	statep->ls_start = Xsavepos(ws, wp);			\
	ri = alloc(sizeof(struct sretrace_info), ATEMP);	\
	Xinit(ri->xs, ri->xp, 64, ATEMP);			\
	ri->next = retrace_info;				\
	retrace_info = ri;					\
} while (/* CONSTCOND */ 0)

#define POP_SRETRACE()	do {					\
	wp = Xrestpos(ws, wp, statep->ls_start);		\
	*retrace_info->xp = '\0';				\
	sp = Xstring(retrace_info->xs, retrace_info->xp);	\
	dp = (void *)retrace_info;				\
	retrace_info = retrace_info->next;			\
	afree(dp, ATEMP);					\
	POP_STATE();						\
} while (/* CONSTCOND */ 0)

/**
 * Lexical analyser
 *
 * tokens are not regular expressions, they are LL(1).
 * for example, "${var:-${PWD}}", and "$(size $(whence ksh))".
 * hence the state stack. Note "$(...)" are now parsed recursively.
 */

int
yylex(int cf)
{
	Lex_state states[STATE_BSIZE], *statep, *s2, *base;
	State_info state_info;
	int c, c2, state;
	size_t cz;
	XString ws;		/* expandable output word */
	char *wp;		/* output word pointer */
	char *sp, *dp;

 Again:
	states[0].type = SINVALID;
	states[0].ls_base = NULL;
	statep = &states[1];
	state_info.base = states;
	state_info.end = &state_info.base[STATE_BSIZE];

	Xinit(ws, wp, 64, ATEMP);

	backslash_skip = 0;
	ignore_backslash_newline = 0;

	if (cf & ONEWORD)
		state = SWORD;
	else if (cf & LETEXPR) {
		/* enclose arguments in (double) quotes */
		*wp++ = OQUOTE;
		state = SLETPAREN;
		statep->nparen = 0;
	} else {
		/* normal lexing */
		state = (cf & HEREDELIM) ? SHEREDELIM : SBASE;
		do {
			c = getsc();
		} while (ctype(c, C_BLANK));
		if (c == '#') {
			ignore_backslash_newline++;
			do {
				c = getsc();
			} while (!ctype(c, C_NUL | C_LF));
			ignore_backslash_newline--;
		}
		ungetsc(c);
	}
	if (source->flags & SF_ALIAS) {
		/* trailing ' ' in alias definition */
		source->flags &= ~SF_ALIAS;
		/* POSIX: trailing space only counts if parsing simple cmd */
		if (!Flag(FPOSIX) || (cf & CMDWORD))
			cf |= ALIAS;
	}

	/* Initial state: one of SWORD SLETPAREN SHEREDELIM SBASE */
	statep->type = state;
	statep->ls_flags = (cf & HEREDOC) ? LS_HEREDOC : 0;

	/* collect non-special or quoted characters to form word */
	while (!((c = getsc()) == 0 ||
	    ((state == SBASE || state == SHEREDELIM) && ctype(c, C_LEX1)))) {
		if (state == SBASE &&
		    subshell_nesting_type == ORD(/*{*/ '}') &&
		    (unsigned int)c == ORD(/*{*/ '}'))
			/* possibly end ${ :;} */
			break;
		Xcheck(ws, wp);
		switch (state) {
		case SADELIM:
			if ((unsigned int)c == ORD('('))
				statep->nparen++;
			else if ((unsigned int)c == ORD(')'))
				statep->nparen--;
			else if (statep->nparen == 0 &&
			    ((unsigned int)c == ORD(/*{*/ '}') ||
			    c == (int)statep->ls_adelim.delimiter)) {
				*wp++ = ADELIM;
				*wp++ = c;
				if ((unsigned int)c == ORD(/*{*/ '}') ||
				    --statep->ls_adelim.num == 0)
					POP_STATE();
				if ((unsigned int)c == ORD(/*{*/ '}'))
					POP_STATE();
				break;
			}
			/* FALLTHROUGH */
		case SBASE:
			if ((unsigned int)c == ORD('[') && (cf & CMDASN)) {
				/* temporary */
				*wp = EOS;
				if (is_wdvarname(Xstring(ws, wp), false)) {
					char *p, *tmp;

					if (arraysub(&tmp)) {
						*wp++ = CHAR;
						*wp++ = c;
						for (p = tmp; *p; ) {
							Xcheck(ws, wp);
							*wp++ = CHAR;
							*wp++ = *p++;
						}
						afree(tmp, ATEMP);
						break;
					}
				}
				*wp++ = CHAR;
				*wp++ = c;
				break;
			}
			/* FALLTHROUGH */
 Sbase1:		/* includes *(...|...) pattern (*+?@@!) */
			if (ctype(c, C_PATMO)) {
				c2 = getsc();
				if ((unsigned int)c2 == ORD('(' /*)*/)) {
					*wp++ = OPAT;
					*wp++ = c;
					PUSH_STATE(SPATTERN);
					break;
				}
				ungetsc(c2);
			}
			/* FALLTHROUGH */
 Sbase2:		/* doesn't include *(...|...) pattern (*+?@@!) */
			switch (c) {
			case ORD('\\'):
 getsc_qchar:
				if ((c = getsc())) {
					/* trailing \ is lost */
					*wp++ = QCHAR;
					*wp++ = c;
				}
				break;
			case ORD('\''):
 open_ssquote_unless_heredoc:
				if ((statep->ls_flags & LS_HEREDOC))
					goto store_char;
				*wp++ = OQUOTE;
				ignore_backslash_newline++;
				PUSH_STATE(SSQUOTE);
				break;
			case ORD('"'):
 open_sdquote:
				*wp++ = OQUOTE;
				PUSH_STATE(SDQUOTE);
				break;
			case ORD('$'):
				/*
				 * processing of dollar sign belongs into
				 * Subst, except for those which can open
				 * a string: $'…' and $"…"
				 */
 subst_dollar_ex:
				c = getsc();
				switch (c) {
				case ORD('"'):
					goto open_sdquote;
				case ORD('\''):
					goto open_sequote;
				default:
					goto SubstS;
				}
			default:
				goto Subst;
			}
			break;

 Subst:
			switch (c) {
			case ORD('\\'):
				c = getsc();
				switch (c) {
				case ORD('"'):
					if ((statep->ls_flags & LS_HEREDOC))
						goto heredocquote;
					/* FALLTHROUGH */
				case ORD('\\'):
				case ORD('$'):
				case ORD('`'):
 store_qchar:
					*wp++ = QCHAR;
					*wp++ = c;
					break;
				default:
 heredocquote:
					Xcheck(ws, wp);
					if (c) {
						/* trailing \ is lost */
						*wp++ = CHAR;
						*wp++ = '\\';
						*wp++ = CHAR;
						*wp++ = c;
					}
					break;
				}
				break;
			case ORD('$'):
				c = getsc();
 SubstS:
				if ((unsigned int)c == ORD('(' /*)*/)) {
					c = getsc();
					if ((unsigned int)c == ORD('(' /*)*/)) {
						*wp++ = EXPRSUB;
						PUSH_SRETRACE(SASPAREN);
						/* unneeded? */
						/*statep->ls_flags &= ~LS_HEREDOC;*/
						statep->nparen = 2;
						*retrace_info->xp++ = '(';
					} else {
						ungetsc(c);
 subst_command:
						c = COMSUB;
 subst_command2:
						sp = yyrecursive(c);
						cz = strlen(sp) + 1;
						XcheckN(ws, wp, cz);
						*wp++ = c;
						memcpy(wp, sp, cz);
						wp += cz;
					}
				} else if ((unsigned int)c == ORD('{' /*}*/)) {
					if ((unsigned int)(c = getsc()) == ORD('|')) {
						/*
						 * non-subenvironment
						 * value substitution
						 */
						c = VALSUB;
						goto subst_command2;
					} else if (ctype(c, C_IFSWS)) {
						/*
						 * non-subenvironment
						 * "command" substitution
						 */
						c = FUNSUB;
						goto subst_command2;
					}
					ungetsc(c);
					*wp++ = OSUBST;
					*wp++ = '{' /*}*/;
					wp = get_brace_var(&ws, wp);
					c = getsc();
					/* allow :# and :% (ksh88 compat) */
					if ((unsigned int)c == ORD(':')) {
						*wp++ = CHAR;
						*wp++ = c;
						c = getsc();
						if ((unsigned int)c == ORD(':')) {
							*wp++ = CHAR;
							*wp++ = '0';
							*wp++ = ADELIM;
							*wp++ = ':';
							PUSH_STATE(SBRACE);
							/* perhaps unneeded? */
							statep->ls_flags &= ~LS_HEREDOC;
							PUSH_STATE(SADELIM);
							statep->ls_adelim.delimiter = ':';
							statep->ls_adelim.num = 1;
							statep->nparen = 0;
							break;
						} else if (ctype(c, C_DIGIT | C_DOLAR | C_SPC) ||
						    /*XXX what else? */
						    c == '(' /*)*/) {
							/* substring subst. */
							if (c != ' ') {
								*wp++ = CHAR;
								*wp++ = ' ';
							}
							ungetsc(c);
							PUSH_STATE(SBRACE);
							/* perhaps unneeded? */
							statep->ls_flags &= ~LS_HEREDOC;
							PUSH_STATE(SADELIM);
							statep->ls_adelim.delimiter = ':';
							statep->ls_adelim.num = 2;
							statep->nparen = 0;
							break;
						}
					} else if (c == '/') {
						c2 = ADELIM;
 parse_adelim_slash:
						*wp++ = CHAR;
						*wp++ = c;
						if ((unsigned int)(c = getsc()) == ORD('/')) {
							*wp++ = c2;
							*wp++ = c;
						} else
							ungetsc(c);
						PUSH_STATE(SBRACE);
						/* perhaps unneeded? */
						statep->ls_flags &= ~LS_HEREDOC;
						PUSH_STATE(SADELIM);
						statep->ls_adelim.delimiter = '/';
						statep->ls_adelim.num = 1;
						statep->nparen = 0;
						break;
					} else if (c == '@@') {
						c2 = getsc();
						ungetsc(c2);
						if ((unsigned int)c2 == ORD('/')) {
							c2 = CHAR;
							goto parse_adelim_slash;
						}
					}
					/*
					 * If this is a trim operation,
					 * treat (,|,) specially in STBRACE.
					 */
					if (ctype(c, C_SUB2)) {
						ungetsc(c);
						if (Flag(FSH))
							PUSH_STATE(STBRACEBOURNE);
						else
							PUSH_STATE(STBRACEKORN);
						/* single-quotes-in-heredoc-trim */
						statep->ls_flags &= ~LS_HEREDOC;
					} else {
						ungetsc(c);
						if (state == SDQUOTE ||
						    state == SQBRACE)
							PUSH_STATE(SQBRACE);
						else
							PUSH_STATE(SBRACE);
						/* here no LS_HEREDOC removal */
						/* single-quotes-in-heredoc-braces */
					}
				} else if (ctype(c, C_ALPHX)) {
					*wp++ = OSUBST;
					*wp++ = 'X';
					do {
						Xcheck(ws, wp);
						*wp++ = c;
						c = getsc();
					} while (ctype(c, C_ALNUX));
					*wp++ = '\0';
					*wp++ = CSUBST;
					*wp++ = 'X';
					ungetsc(c);
				} else if (ctype(c, C_VAR1 | C_DIGIT)) {
					Xcheck(ws, wp);
					*wp++ = OSUBST;
					*wp++ = 'X';
					*wp++ = c;
					*wp++ = '\0';
					*wp++ = CSUBST;
					*wp++ = 'X';
				} else {
					*wp++ = CHAR;
					*wp++ = '$';
					ungetsc(c);
				}
				break;
			case ORD('`'):
 subst_gravis:
				PUSH_STATE(SBQUOTE);
				*wp++ = COMASUB;
				/*
				 * We need to know whether we are within double
				 * quotes in order to translate \" to " within
				 * "…`…\"…`…" because, unlike for COMSUBs, the
				 * outer double quoteing changes the backslash
				 * meaning for the inside. For more details:
				 * http://austingroupbugs.net/view.php?id=1015
				 */
				statep->ls_bool = false;
				s2 = statep;
				base = state_info.base;
				while (/* CONSTCOND */ 1) {
					for (; s2 != base; s2--) {
						if (s2->type == SDQUOTE) {
							statep->ls_bool = true;
							break;
						}
					}
					if (s2 != base)
						break;
					if (!(s2 = s2->ls_base))
						break;
					base = s2-- - STATE_BSIZE;
				}
				break;
			case QCHAR:
				if (cf & LQCHAR) {
					*wp++ = QCHAR;
					*wp++ = getsc();
					break;
				}
				/* FALLTHROUGH */
			default:
 store_char:
				*wp++ = CHAR;
				*wp++ = c;
			}
			break;

		case SEQUOTE:
			if ((unsigned int)c == ORD('\'')) {
				POP_STATE();
				*wp++ = CQUOTE;
				ignore_backslash_newline--;
			} else if ((unsigned int)c == ORD('\\')) {
				if ((c2 = unbksl(true, getsc_i, ungetsc)) == -1)
					c2 = getsc();
				if (c2 == 0)
					statep->ls_bool = true;
				if (!statep->ls_bool) {
					char ts[4];

					if ((unsigned int)c2 < 0x100) {
						*wp++ = QCHAR;
						*wp++ = c2;
					} else {
						cz = utf_wctomb(ts, c2 - 0x100);
						ts[cz] = 0;
						cz = 0;
						do {
							*wp++ = QCHAR;
							*wp++ = ts[cz];
						} while (ts[++cz]);
					}
				}
			} else if (!statep->ls_bool) {
				*wp++ = QCHAR;
				*wp++ = c;
			}
			break;

		case SSQUOTE:
			if ((unsigned int)c == ORD('\'')) {
				POP_STATE();
				if ((statep->ls_flags & LS_HEREDOC) ||
				    state == SQBRACE)
					goto store_char;
				*wp++ = CQUOTE;
				ignore_backslash_newline--;
			} else {
				*wp++ = QCHAR;
				*wp++ = c;
			}
			break;

		case SDQUOTE:
			if ((unsigned int)c == ORD('"')) {
				POP_STATE();
				*wp++ = CQUOTE;
			} else
				goto Subst;
			break;

		/* $(( ... )) */
		case SASPAREN:
			if ((unsigned int)c == ORD('('))
				statep->nparen++;
			else if ((unsigned int)c == ORD(')')) {
				statep->nparen--;
				if (statep->nparen == 1) {
					/* end of EXPRSUB */
					POP_SRETRACE();

					if ((unsigned int)(c2 = getsc()) == ORD(/*(*/ ')')) {
						cz = strlen(sp) - 2;
						XcheckN(ws, wp, cz);
						memcpy(wp, sp + 1, cz);
						wp += cz;
						afree(sp, ATEMP);
						*wp++ = '\0';
						break;
					} else {
						Source *s;

						ungetsc(c2);
						/*
						 * mismatched parenthesis -
						 * assume we were really
						 * parsing a $(...) expression
						 */
						--wp;
						s = pushs(SREREAD,
						    source->areap);
						s->start = s->str =
						    s->u.freeme = sp;
						s->next = source;
						source = s;
						goto subst_command;
					}
				}
			}
			/* reuse existing state machine */
			goto Sbase2;

		case SQBRACE:
			if ((unsigned int)c == ORD('\\')) {
				/*
				 * perform POSIX "quote removal" if the back-
				 * slash is "special", i.e. same cases as the
				 * {case '\\':} in Subst: plus closing brace;
				 * in mksh code "quote removal" on '\c' means
				 * write QCHAR+c, otherwise CHAR+\+CHAR+c are
				 * emitted (in heredocquote:)
				 */
				if ((unsigned int)(c = getsc()) == ORD('"') ||
				    (unsigned int)c == ORD('\\') ||
				    ctype(c, C_DOLAR | C_GRAVE) ||
				    (unsigned int)c == ORD(/*{*/ '}'))
					goto store_qchar;
				goto heredocquote;
			}
			goto common_SQBRACE;

		case SBRACE:
			if ((unsigned int)c == ORD('\''))
				goto open_ssquote_unless_heredoc;
			else if ((unsigned int)c == ORD('\\'))
				goto getsc_qchar;
 common_SQBRACE:
			if ((unsigned int)c == ORD('"'))
				goto open_sdquote;
			else if ((unsigned int)c == ORD('$'))
				goto subst_dollar_ex;
			else if ((unsigned int)c == ORD('`'))
				goto subst_gravis;
			else if ((unsigned int)c != ORD(/*{*/ '}'))
				goto store_char;
			POP_STATE();
			*wp++ = CSUBST;
			*wp++ = /*{*/ '}';
			break;

		/* Same as SBASE, except (,|,) treated specially */
		case STBRACEKORN:
			if ((unsigned int)c == ORD('|'))
				*wp++ = SPAT;
			else if ((unsigned int)c == ORD('(')) {
				*wp++ = OPAT;
				/* simile for @@ */
				*wp++ = ' ';
				PUSH_STATE(SPATTERN);
			} else /* FALLTHROUGH */
		case STBRACEBOURNE:
			  if ((unsigned int)c == ORD(/*{*/ '}')) {
				POP_STATE();
				*wp++ = CSUBST;
				*wp++ = /*{*/ '}';
			} else
				goto Sbase1;
			break;

		case SBQUOTE:
			if ((unsigned int)c == ORD('`')) {
				*wp++ = 0;
				POP_STATE();
			} else if ((unsigned int)c == ORD('\\')) {
				switch (c = getsc()) {
				case 0:
					/* trailing \ is lost */
					break;
				case ORD('$'):
				case ORD('`'):
				case ORD('\\'):
					*wp++ = c;
					break;
				case ORD('"'):
					if (statep->ls_bool) {
						*wp++ = c;
						break;
					}
					/* FALLTHROUGH */
				default:
					*wp++ = '\\';
					*wp++ = c;
					break;
				}
			} else
				*wp++ = c;
			break;

		/* ONEWORD */
		case SWORD:
			goto Subst;

		/* LETEXPR: (( ... )) */
		case SLETPAREN:
			if ((unsigned int)c == ORD(/*(*/ ')')) {
				if (statep->nparen > 0)
					--statep->nparen;
				else if ((unsigned int)(c2 = getsc()) == ORD(/*(*/ ')')) {
					c = 0;
					*wp++ = CQUOTE;
					goto Done;
				} else {
					Source *s;

					ungetsc(c2);
					ungetsc(c);
					/*
					 * mismatched parenthesis -
					 * assume we were really
					 * parsing a (...) expression
					 */
					*wp = EOS;
					sp = Xstring(ws, wp);
					dp = wdstrip(sp + 1, WDS_TPUTS);
					s = pushs(SREREAD, source->areap);
					s->start = s->str = s->u.freeme = dp;
					s->next = source;
					source = s;
					ungetsc('(' /*)*/);
					return (ORD('(' /*)*/));
				}
			} else if ((unsigned int)c == ORD('('))
				/*
				 * parentheses inside quotes and
				 * backslashes are lost, but AT&T ksh
				 * doesn't count them either
				 */
				++statep->nparen;
			goto Sbase2;

		/* << or <<- delimiter */
		case SHEREDELIM:
			/*
			 * here delimiters need a special case since
			 * $ and `...` are not to be treated specially
			 */
			switch (c) {
			case ORD('\\'):
				if ((c = getsc())) {
					/* trailing \ is lost */
					*wp++ = QCHAR;
					*wp++ = c;
				}
				break;
			case ORD('\''):
				goto open_ssquote_unless_heredoc;
			case ORD('$'):
				if ((unsigned int)(c2 = getsc()) == ORD('\'')) {
 open_sequote:
					*wp++ = OQUOTE;
					ignore_backslash_newline++;
					PUSH_STATE(SEQUOTE);
					statep->ls_bool = false;
					break;
				} else if ((unsigned int)c2 == ORD('"')) {
					/* FALLTHROUGH */
			case ORD('"'):
					PUSH_SRETRACE(SHEREDQUOTE);
					break;
				}
				ungetsc(c2);
				/* FALLTHROUGH */
			default:
				*wp++ = CHAR;
				*wp++ = c;
			}
			break;

		/* " in << or <<- delimiter */
		case SHEREDQUOTE:
			if ((unsigned int)c != ORD('"'))
				goto Subst;
			POP_SRETRACE();
			dp = strnul(sp) - 1;
			/* remove the trailing double quote */
			*dp = '\0';
			/* store the quoted string */
			*wp++ = OQUOTE;
			XcheckN(ws, wp, (dp - sp) * 2);
			dp = sp;
			while ((c = *dp++)) {
				if (c == '\\') {
					switch ((c = *dp++)) {
					case ORD('\\'):
					case ORD('"'):
					case ORD('$'):
					case ORD('`'):
						break;
					default:
						*wp++ = CHAR;
						*wp++ = '\\';
						break;
					}
				}
				*wp++ = CHAR;
				*wp++ = c;
			}
			afree(sp, ATEMP);
			*wp++ = CQUOTE;
			state = statep->type = SHEREDELIM;
			break;

		/* in *(...|...) pattern (*+?@@!) */
		case SPATTERN:
			if ((unsigned int)c == ORD(/*(*/ ')')) {
				*wp++ = CPAT;
				POP_STATE();
			} else if ((unsigned int)c == ORD('|')) {
				*wp++ = SPAT;
			} else if ((unsigned int)c == ORD('(')) {
				*wp++ = OPAT;
				/* simile for @@ */
				*wp++ = ' ';
				PUSH_STATE(SPATTERN);
			} else
				goto Sbase1;
			break;
		}
	}
 Done:
	Xcheck(ws, wp);
	if (statep != &states[1])
		/* XXX figure out what is missing */
		yyerror("no closing quote");

	/* This done to avoid tests for SHEREDELIM wherever SBASE tested */
	if (state == SHEREDELIM)
		state = SBASE;

	dp = Xstring(ws, wp);
	if (state == SBASE && (
	    (c == '&' && !Flag(FSH) && !Flag(FPOSIX)) ||
	    ctype(c, C_ANGLE)) && ((c2 = Xlength(ws, wp)) == 0 ||
	    (c2 == 2 && dp[0] == CHAR && ctype(dp[1], C_DIGIT)))) {
		struct ioword *iop = alloc(sizeof(struct ioword), ATEMP);

		iop->unit = c2 == 2 ? ksh_numdig(dp[1]) : c == '<' ? 0 : 1;

		if (c == '&') {
			if ((unsigned int)(c2 = getsc()) != ORD('>')) {
				ungetsc(c2);
				goto no_iop;
			}
			c = c2;
			iop->ioflag = IOBASH;
		} else
			iop->ioflag = 0;

		c2 = getsc();
		/* <<, >>, <> are ok, >< is not */
		if (c == c2 || ((unsigned int)c == ORD('<') &&
		    (unsigned int)c2 == ORD('>'))) {
			iop->ioflag |= c == c2 ?
			    ((unsigned int)c == ORD('>') ? IOCAT : IOHERE) : IORDWR;
			if (iop->ioflag == IOHERE) {
				if ((unsigned int)(c2 = getsc()) == ORD('-'))
					iop->ioflag |= IOSKIP;
				else if ((unsigned int)c2 == ORD('<'))
					iop->ioflag |= IOHERESTR;
				else
					ungetsc(c2);
			}
		} else if ((unsigned int)c2 == ORD('&'))
			iop->ioflag |= IODUP | ((unsigned int)c == ORD('<') ? IORDUP : 0);
		else {
			iop->ioflag |= (unsigned int)c == ORD('>') ? IOWRITE : IOREAD;
			if ((unsigned int)c == ORD('>') && (unsigned int)c2 == ORD('|'))
				iop->ioflag |= IOCLOB;
			else
				ungetsc(c2);
		}

		iop->ioname = NULL;
		iop->delim = NULL;
		iop->heredoc = NULL;
		/* free word */
		Xfree(ws, wp);
		yylval.iop = iop;
		return (REDIR);
 no_iop:
		afree(iop, ATEMP);
	}

	if (wp == dp && state == SBASE) {
		/* free word */
		Xfree(ws, wp);
		/* no word, process LEX1 character */
		if (((unsigned int)c == ORD('|')) ||
		    ((unsigned int)c == ORD('&')) ||
		    ((unsigned int)c == ORD(';')) ||
		    ((unsigned int)c == ORD('(' /*)*/))) {
			if ((c2 = getsc()) == c)
				c = ((unsigned int)c == ORD(';')) ? BREAK :
				    ((unsigned int)c == ORD('|')) ? LOGOR :
				    ((unsigned int)c == ORD('&')) ? LOGAND :
				    /* (unsigned int)c == ORD('(' )) */ MDPAREN;
			else if ((unsigned int)c == ORD('|') && (unsigned int)c2 == ORD('&'))
				c = COPROC;
			else if ((unsigned int)c == ORD(';') && (unsigned int)c2 == ORD('|'))
				c = BRKEV;
			else if ((unsigned int)c == ORD(';') && (unsigned int)c2 == ORD('&'))
				c = BRKFT;
			else
				ungetsc(c2);
#ifndef MKSH_SMALL
			if (c == BREAK) {
				if ((unsigned int)(c2 = getsc()) == ORD('&'))
					c = BRKEV;
				else
					ungetsc(c2);
			}
#endif
		} else if ((unsigned int)c == ORD('\n')) {
			if (cf & HEREDELIM)
				ungetsc(c);
			else {
				gethere();
				if (cf & CONTIN)
					goto Again;
			}
		} else if (c == '\0' && !(cf & HEREDELIM)) {
			struct ioword **p = heres;

			while (p < herep)
				if ((*p)->ioflag & IOHERESTR)
					++p;
				else
					/* ksh -c 'cat <<EOF' can cause this */
					yyerror(Tf_heredoc,
					    evalstr((*p)->delim, 0));
		}
		return (c);
	}

	/* terminate word */
	*wp++ = EOS;
	yylval.cp = Xclose(ws, wp);
	if (state == SWORD || state == SLETPAREN
	    /* XXX ONEWORD? */)
		return (LWORD);

	/* unget terminator */
	ungetsc(c);

	/*
	 * note: the alias-vs-function code below depends on several
	 * interna: starting from here, source->str is not modified;
	 * the way getsc() and ungetsc() operate; etc.
	 */

	/* copy word to unprefixed string ident */
	sp = yylval.cp;
	dp = ident;
	while ((dp - ident) < IDENT && (c = *sp++) == CHAR)
		*dp++ = *sp++;
	if (c != EOS)
		/* word is not unquoted, or space ran out */
		dp = ident;
	/* make sure the ident array stays NUL padded */
	memset(dp, 0, (ident + IDENT) - dp + 1);

	if (*ident != '\0' && (cf & (KEYWORD | ALIAS))) {
		struct tbl *p;
		uint32_t h = hash(ident);

		if ((cf & KEYWORD) && (p = ktsearch(&keywords, ident, h)) &&
		    (!(cf & ESACONLY) || p->val.i == ESAC ||
		    (unsigned int)p->val.i == ORD(/*{*/ '}'))) {
			afree(yylval.cp, ATEMP);
			return (p->val.i);
		}
		if ((cf & ALIAS) && (p = ktsearch(&aliases, ident, h)) &&
		    (p->flag & ISSET)) {
			/*
			 * this still points to the same character as the
			 * ungetsc'd terminator from above
			 */
			const char *cp = source->str;

			/* prefer POSIX but not Korn functions over aliases */
			while (ctype(*cp, C_BLANK))
				/*
				 * this is like getsc() without skipping
				 * over Source boundaries (including not
				 * parsing ungetsc'd characters that got
				 * pushed into an SREREAD) which is what
				 * we want here anyway: find out whether
				 * the alias name is followed by a POSIX
				 * function definition
				 */
				++cp;
			/* prefer functions over aliases */
			if (cp[0] != '(' || cp[1] != ')') {
				Source *s = source;

				while (s && (s->flags & SF_HASALIAS))
					if (s->u.tblp == p)
						return (LWORD);
					else
						s = s->next;
				/* push alias expansion */
				s = pushs(SALIAS, source->areap);
				s->start = s->str = p->val.s;
				s->u.tblp = p;
				s->flags |= SF_HASALIAS;
				s->line = source->line;
				s->next = source;
				if (source->type == SEOF) {
					/* prevent infinite recursion at EOS */
					source->u.tblp = p;
					source->flags |= SF_HASALIAS;
				}
				source = s;
				afree(yylval.cp, ATEMP);
				goto Again;
			}
		}
	} else if (*ident == '\0') {
		/* retain typeset et al. even when quoted */
		struct tbl *tt = get_builtin((dp = wdstrip(yylval.cp, 0)));
		uint32_t flag = tt ? tt->flag : 0;

		if (flag & (DECL_UTIL | DECL_FWDR))
			strlcpy(ident, dp, sizeof(ident));
		afree(dp, ATEMP);
	}

	return (LWORD);
}

static void
gethere(void)
{
	struct ioword **p;

	for (p = heres; p < herep; p++)
		if (!((*p)->ioflag & IOHERESTR))
			readhere(*p);
	herep = heres;
}

/*
 * read "<<word" text into temp file
 */

static void
readhere(struct ioword *iop)
{
	int c;
	const char *eof, *eofp;
	XString xs;
	char *xp;
	size_t xpos;

	eof = evalstr(iop->delim, 0);

	if (!(iop->ioflag & IOEVAL))
		ignore_backslash_newline++;

	Xinit(xs, xp, 256, ATEMP);

 heredoc_read_line:
	/* beginning of line */
	eofp = eof;
	xpos = Xsavepos(xs, xp);
	if (iop->ioflag & IOSKIP) {
		/* skip over leading tabs */
		while ((c = getsc()) == '\t')
			;	/* nothing */
		goto heredoc_parse_char;
	}
 heredoc_read_char:
	c = getsc();
 heredoc_parse_char:
	/* compare with here document marker */
	if (!*eofp) {
		/* end of here document marker, what to do? */
		switch (c) {
		case ORD(/*(*/ ')'):
			if (!subshell_nesting_type)
				/*-
				 * not allowed outside $(...) or (...)
				 * => mismatch
				 */
				break;
			/* allow $(...) or (...) to close here */
			ungetsc(/*(*/ ')');
			/* FALLTHROUGH */
		case 0:
			/*
			 * Allow EOF here to commands without trailing
			 * newlines (mksh -c '...') will work as well.
			 */
		case ORD('\n'):
			/* Newline terminates here document marker */
			goto heredoc_found_terminator;
		}
	} else if ((unsigned int)c == ord(*eofp++))
		/* store; then read and compare next character */
		goto heredoc_store_and_loop;
	/* nope, mismatch; read until end of line */
	while (c != '\n') {
		if (!c)
			/* oops, reached EOF */
			yyerror(Tf_heredoc, eof);
		/* store character */
		Xcheck(xs, xp);
		Xput(xs, xp, c);
		/* read next character */
		c = getsc();
	}
	/* we read a newline as last character */
 heredoc_store_and_loop:
	/* store character */
	Xcheck(xs, xp);
	Xput(xs, xp, c);
	if (c == '\n')
		goto heredoc_read_line;
	goto heredoc_read_char;

 heredoc_found_terminator:
	/* jump back to saved beginning of line */
	xp = Xrestpos(xs, xp, xpos);
	/* terminate, close and store */
	Xput(xs, xp, '\0');
	iop->heredoc = Xclose(xs, xp);

	if (!(iop->ioflag & IOEVAL))
		ignore_backslash_newline--;
}

void
yyerror(const char *fmt, ...)
{
	va_list va;

	/* pop aliases and re-reads */
	while (source->type == SALIAS || source->type == SREREAD)
		source = source->next;
	/* zap pending input */
	source->str = null;

	error_prefix(true);
	va_start(va, fmt);
	shf_vfprintf(shl_out, fmt, va);
	shf_putc('\n', shl_out);
	va_end(va);
	errorfz();
}

/*
 * input for yylex with alias expansion
 */

Source *
pushs(int type, Area *areap)
{
	Source *s;

	s = alloc(sizeof(Source), areap);
	memset(s, 0, sizeof(Source));
	s->type = type;
	s->str = null;
	s->areap = areap;
	if (type == SFILE || type == SSTDIN)
		XinitN(s->xs, 256, s->areap);
	return (s);
}

static int
getsc_uu(void)
{
	Source *s = source;
	int c;

	while ((c = ord(*s->str++)) == 0) {
		/* return 0 for EOF by default */
		s->str = NULL;
		switch (s->type) {
		case SEOF:
			s->str = null;
			return (0);

		case SSTDIN:
		case SFILE:
			getsc_line(s);
			break;

		case SWSTR:
			break;

		case SSTRING:
		case SSTRINGCMDLINE:
			break;

		case SWORDS:
			s->start = s->str = *s->u.strv++;
			s->type = SWORDSEP;
			break;

		case SWORDSEP:
			if (*s->u.strv == NULL) {
				s->start = s->str = "\n";
				s->type = SEOF;
			} else {
				s->start = s->str = T1space;
				s->type = SWORDS;
			}
			break;

		case SALIAS:
			if (s->flags & SF_ALIASEND) {
				/* pass on an unused SF_ALIAS flag */
				source = s->next;
				source->flags |= s->flags & SF_ALIAS;
				s = source;
			} else if (*s->u.tblp->val.s &&
			    ctype((c = strnul(s->u.tblp->val.s)[-1]), C_SPACE)) {
				/* pop source stack */
				source = s = s->next;
				/*
				 * Note that this alias ended with a
				 * space, enabling alias expansion on
				 * the following word.
				 */
				s->flags |= SF_ALIAS;
			} else {
				/*
				 * At this point, we need to keep the current
				 * alias in the source list so recursive
				 * aliases can be detected and we also need to
				 * return the next character. Do this by
				 * temporarily popping the alias to get the
				 * next character and then put it back in the
				 * source list with the SF_ALIASEND flag set.
				 */
				/* pop source stack */
				source = s->next;
				source->flags |= s->flags & SF_ALIAS;
				c = getsc_uu();
				if (c) {
					s->flags |= SF_ALIASEND;
					s->ugbuf[0] = c; s->ugbuf[1] = '\0';
					s->start = s->str = s->ugbuf;
					s->next = source;
					source = s;
				} else {
					s = source;
					/* avoid reading EOF twice */
					s->str = NULL;
					break;
				}
			}
			continue;

		case SREREAD:
			if (s->start != s->ugbuf)
				/* yuck */
				afree(s->u.freeme, ATEMP);
			source = s = s->next;
			continue;
		}
		if (s->str == NULL) {
			s->type = SEOF;
			s->start = s->str = null;
			return ('\0');
		}
		if (s->flags & SF_ECHO) {
			shf_puts(s->str, shl_out);
			shf_flush(shl_out);
		}
	}
	return (c);
}

static void
getsc_line(Source *s)
{
	char *xp = Xstring(s->xs, xp), *cp;
	bool interactive = Flag(FTALKING) && s->type == SSTDIN;
	bool have_tty = interactive && (s->flags & SF_TTY) && tty_hasstate;

	/* Done here to ensure nothing odd happens when a timeout occurs */
	XcheckN(s->xs, xp, LINE);
	*xp = '\0';
	s->start = s->str = xp;

	if (have_tty && ksh_tmout) {
		ksh_tmout_state = TMOUT_READING;
		alarm(ksh_tmout);
	}
	if (interactive) {
		if (cur_prompt == PS1)
			histsave(&s->line, NULL, HIST_FLUSH, true);
		change_winsz();
	}
#ifndef MKSH_NO_CMDLINE_EDITING
	if (have_tty && (
#if !MKSH_S_NOVI
	    Flag(FVI) ||
#endif
	    Flag(FEMACS) || Flag(FGMACS))) {
		int nread;

		nread = x_read(xp);
		if (nread < 0)
			/* read error */
			nread = 0;
		xp[nread] = '\0';
		xp += nread;
	} else
#endif
	  {
		if (interactive)
			pprompt(prompt, 0);
		else
			s->line++;

		while (/* CONSTCOND */ 1) {
			char *p = shf_getse(xp, Xnleft(s->xs, xp), s->u.shf);

			if (!p && shf_error(s->u.shf) &&
			    shf_errno(s->u.shf) == EINTR) {
				shf_clearerr(s->u.shf);
				if (trap)
					runtraps(0);
				continue;
			}
			if (!p || (xp = p, xp[-1] == '\n'))
				break;
			/* double buffer size */
			/* move past NUL so doubling works... */
			xp++;
			XcheckN(s->xs, xp, Xlength(s->xs, xp));
			/* ...and move back again */
			xp--;
		}
		/*
		 * flush any unwanted input so other programs/builtins
		 * can read it. Not very optimal, but less error prone
		 * than flushing else where, dealing with redirections,
		 * etc.
		 * TODO: reduce size of shf buffer (~128?) if SSTDIN
		 */
		if (s->type == SSTDIN)
			shf_flush(s->u.shf);
	}
	/*
	 * XXX: temporary kludge to restore source after a
	 * trap may have been executed.
	 */
	source = s;
	if (have_tty && ksh_tmout) {
		ksh_tmout_state = TMOUT_EXECUTING;
		alarm(0);
	}
	cp = Xstring(s->xs, xp);
	rndpush(cp);
	s->start = s->str = cp;
	strip_nuls(Xstring(s->xs, xp), Xlength(s->xs, xp));
	/* Note: if input is all nulls, this is not eof */
	if (Xlength(s->xs, xp) == 0) {
		/* EOF */
		if (s->type == SFILE)
			shf_fdclose(s->u.shf);
		s->str = NULL;
	} else if (interactive && *s->str) {
		if (cur_prompt != PS1)
			histsave(&s->line, s->str, HIST_APPEND, true);
		else if (!ctype(*s->str, C_IFS | C_IFSWS))
			histsave(&s->line, s->str, HIST_QUEUE, true);
#if !defined(MKSH_SMALL) && HAVE_PERSISTENT_HISTORY
		else
			goto check_for_sole_return;
	} else if (interactive && cur_prompt == PS1) {
 check_for_sole_return:
		cp = Xstring(s->xs, xp);
		while (ctype(*cp, C_IFSWS))
			++cp;
		if (!*cp) {
			histsave(&s->line, NULL, HIST_FLUSH, true);
			histsync();
		}
#endif
	}
	if (interactive)
		set_prompt(PS2, NULL);
}

void
set_prompt(int to, Source *s)
{
	cur_prompt = (uint8_t)to;

	switch (to) {
	/* command */
	case PS1:
		/*
		 * Substitute ! and !! here, before substitutions are done
		 * so ! in expanded variables are not expanded.
		 * NOTE: this is not what AT&T ksh does (it does it after
		 * substitutions, POSIX doesn't say which is to be done.
		 */
		{
			struct shf *shf;
			char * volatile ps1;
			Area *saved_atemp;
			int saved_lineno;

			ps1 = str_val(global("PS1"));
			shf = shf_sopen(NULL, strlen(ps1) * 2,
			    SHF_WR | SHF_DYNAMIC, NULL);
			while (*ps1)
				if (*ps1 != '!' || *++ps1 == '!')
					shf_putchar(*ps1++, shf);
				else
					shf_fprintf(shf, Tf_lu, s ?
					    (unsigned long)s->line + 1 : 0UL);
			ps1 = shf_sclose(shf);
			saved_lineno = current_lineno;
			if (s)
				current_lineno = s->line + 1;
			saved_atemp = ATEMP;
			newenv(E_ERRH);
			if (kshsetjmp(e->jbuf)) {
				prompt = safe_prompt;
				/*
				 * Don't print an error - assume it has already
				 * been printed. Reason is we may have forked
				 * to run a command and the child may be
				 * unwinding its stack through this code as it
				 * exits.
				 */
			} else {
				char *cp = substitute(ps1, 0);
				strdupx(prompt, cp, saved_atemp);
			}
			current_lineno = saved_lineno;
			quitenv(NULL);
		}
		break;
	/* command continuation */
	case PS2:
		prompt = str_val(global("PS2"));
		break;
	}
}

int
pprompt(const char *cp, int ntruncate)
{
	char delimiter = 0;
	bool doprint = (ntruncate != -1);
	bool indelimit = false;
	int columns = 0, lines = 0;

	/*
	 * Undocumented AT&T ksh feature:
	 * If the second char in the prompt string is \r then the first
	 * char is taken to be a non-printing delimiter and any chars
	 * between two instances of the delimiter are not considered to
	 * be part of the prompt length
	 */
	if (*cp && cp[1] == '\r') {
		delimiter = *cp;
		cp += 2;
	}
	for (; *cp; cp++) {
		if (indelimit && *cp != delimiter)
			;
		else if (ctype(*cp, C_CR | C_LF)) {
			lines += columns / x_cols + ((*cp == '\n') ? 1 : 0);
			columns = 0;
		} else if (*cp == '\t') {
			columns = (columns | 7) + 1;
		} else if (*cp == '\b') {
			if (columns > 0)
				columns--;
		} else if (*cp == delimiter)
			indelimit = !indelimit;
		else if (UTFMODE && (rtt2asc(*cp) > 0x7F)) {
			const char *cp2;
			columns += utf_widthadj(cp, &cp2);
			if (doprint && (indelimit ||
			    (ntruncate < (x_cols * lines + columns))))
				shf_write(cp, cp2 - cp, shl_out);
			cp = cp2 - /* loop increment */ 1;
			continue;
		} else
			columns++;
		if (doprint && (*cp != delimiter) &&
		    (indelimit || (ntruncate < (x_cols * lines + columns))))
			shf_putc(*cp, shl_out);
	}
	if (doprint)
		shf_flush(shl_out);
	return (x_cols * lines + columns);
}

/*
 * Read the variable part of a ${...} expression (i.e. up to but not
 * including the :[-+?=#%] or close-brace).
 */
static char *
get_brace_var(XString *wsp, char *wp)
{
	char c;
	enum parse_state {
		PS_INITIAL, PS_SAW_PERCENT, PS_SAW_HASH, PS_SAW_BANG,
		PS_IDENT, PS_NUMBER, PS_VAR1
	} state = PS_INITIAL;

	while (/* CONSTCOND */ 1) {
		c = getsc();
		/* State machine to figure out where the variable part ends. */
		switch (state) {
		case PS_SAW_HASH:
			if (ctype(c, C_VAR1)) {
				char c2;

				c2 = getsc();
				ungetsc(c2);
				if (ord(c2) != ORD(/*{*/ '}')) {
					ungetsc(c);
					goto out;
				}
			}
			goto ps_common;
		case PS_SAW_BANG:
			switch (ord(c)) {
			case ORD('@@'):
			case ORD('#'):
			case ORD('-'):
			case ORD('?'):
				goto out;
			}
			goto ps_common;
		case PS_INITIAL:
			switch (ord(c)) {
			case ORD('%'):
				state = PS_SAW_PERCENT;
				goto next;
			case ORD('#'):
				state = PS_SAW_HASH;
				goto next;
			case ORD('!'):
				state = PS_SAW_BANG;
				goto next;
			}
			/* FALLTHROUGH */
		case PS_SAW_PERCENT:
 ps_common:
			if (ctype(c, C_ALPHX))
				state = PS_IDENT;
			else if (ctype(c, C_DIGIT))
				state = PS_NUMBER;
			else if (ctype(c, C_VAR1))
				state = PS_VAR1;
			else
				goto out;
			break;
		case PS_IDENT:
			if (!ctype(c, C_ALNUX)) {
				if (ord(c) == ORD('[')) {
					char *tmp, *p;

					if (!arraysub(&tmp))
						yyerror("missing ]");
					*wp++ = c;
					p = tmp;
					while (*p) {
						Xcheck(*wsp, wp);
						*wp++ = *p++;
					}
					afree(tmp, ATEMP);
					/* the ] */
					c = getsc();
				}
				goto out;
			}
 next:
			break;
		case PS_NUMBER:
			if (!ctype(c, C_DIGIT))
				goto out;
			break;
		case PS_VAR1:
			goto out;
		}
		Xcheck(*wsp, wp);
		*wp++ = c;
	}
 out:
	/* end of variable part */
	*wp++ = '\0';
	ungetsc(c);
	return (wp);
}

/*
 * Save an array subscript - returns true if matching bracket found, false
 * if eof or newline was found.
 * (Returned string double null terminated)
 */
static bool
arraysub(char **strp)
{
	XString ws;
	char *wp, c;
	/* we are just past the initial [ */
	unsigned int depth = 1;

	Xinit(ws, wp, 32, ATEMP);

	do {
		c = getsc();
		Xcheck(ws, wp);
		*wp++ = c;
		if (ord(c) == ORD('['))
			depth++;
		else if (ord(c) == ORD(']'))
			depth--;
	} while (depth > 0 && c && c != '\n');

	*wp++ = '\0';
	*strp = Xclose(ws, wp);

	return (tobool(depth == 0));
}

/* Unget a char: handles case when we are already at the start of the buffer */
static void
ungetsc(int c)
{
	struct sretrace_info *rp = retrace_info;

	if (backslash_skip)
		backslash_skip--;
	/* Don't unget EOF... */
	if (source->str == null && c == '\0')
		return;
	while (rp) {
		if (Xlength(rp->xs, rp->xp))
			rp->xp--;
		rp = rp->next;
	}
	ungetsc_i(c);
}
static void
ungetsc_i(int c)
{
	if (source->str > source->start)
		source->str--;
	else {
		Source *s;

		s = pushs(SREREAD, source->areap);
		s->ugbuf[0] = c; s->ugbuf[1] = '\0';
		s->start = s->str = s->ugbuf;
		s->next = source;
		source = s;
	}
}


/* Called to get a char that isn't a \newline sequence. */
static int
getsc_bn(void)
{
	int c, c2;

	if (ignore_backslash_newline)
		return (o_getsc_u());

	if (backslash_skip == 1) {
		backslash_skip = 2;
		return (o_getsc_u());
	}

	backslash_skip = 0;

	while (/* CONSTCOND */ 1) {
		c = o_getsc_u();
		if (c == '\\') {
			if ((c2 = o_getsc_u()) == '\n')
				/* ignore the \newline; get the next char... */
				continue;
			ungetsc_i(c2);
			backslash_skip = 1;
		}
		return (c);
	}
}

void
yyskiputf8bom(void)
{
	int c;

	if (rtt2asc((c = o_getsc_u())) != 0xEF) {
		ungetsc_i(c);
		return;
	}
	if (rtt2asc((c = o_getsc_u())) != 0xBB) {
		ungetsc_i(c);
		ungetsc_i(asc2rtt(0xEF));
		return;
	}
	if (rtt2asc((c = o_getsc_u())) != 0xBF) {
		ungetsc_i(c);
		ungetsc_i(asc2rtt(0xBB));
		ungetsc_i(asc2rtt(0xEF));
		return;
	}
	UTFMODE |= 8;
}

static Lex_state *
push_state_i(State_info *si, Lex_state *old_end)
{
	Lex_state *news = alloc2(STATE_BSIZE, sizeof(Lex_state), ATEMP);

	news[0].ls_base = old_end;
	si->base = &news[0];
	si->end = &news[STATE_BSIZE];
	return (&news[1]);
}

static Lex_state *
pop_state_i(State_info *si, Lex_state *old_end)
{
	Lex_state *old_base = si->base;

	si->base = old_end->ls_base - STATE_BSIZE;
	si->end = old_end->ls_base;

	afree(old_base, ATEMP);

	return (si->base + STATE_BSIZE - 1);
}
@


1.249
log
@only ever make it possible to enter edit.c if tty_hasstate
@
text
@d1179 1
a1179 1
	} else if (c == *eofp++)
@


1.248
log
@make ${foo#'bar'} in here document behave like ksh93
reported by Martijn Dekker <martijn@@inlv.org>
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.247 2018/01/14 01:44:01 tg Exp $");
d1362 1
a1362 1
	bool have_tty = tobool(interactive && (s->flags & SF_TTY));
@


1.247
log
@clean up
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.244 2018/01/14 00:51:35 tg Exp $");
d80 2
d88 3
d155 1
d159 1
d252 1
d330 1
a330 1
				if ((cf & HEREDOC))
d368 1
a368 1
					if ((cf & HEREDOC))
d399 2
d447 2
d464 2
d483 2
d508 2
d517 2
d624 2
a625 1
				if ((cf & HEREDOC) || state == SQBRACE)
@


1.246
log
@move the cast earlier; the callback also needs it
@
text
@d248 1
a248 1
	    ((state == SBASE || state == SHEREDELIM) && cinttype(c, C_LEX1)))) {
d299 1
a299 1
			if (cinttype(c, C_PATMO)) {
@


1.245
log
@I think I’m onto something here… getsc_{uu,bn} never return -1 AFAICT
@
text
@d130 1
a130 1
	o_getsc_r(o_getsc());
d134 1
a134 1
#define getsc()		((unsigned int)(unsigned char)(getsc_i()))
d144 1
a144 1
#define getsc()		((unsigned int)(unsigned char)(getsc_r(o_getsc())))
@


1.244
log
@I think the ord thing was a red herring
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.242 2018/01/14 00:03:02 tg Exp $");
d134 1
a134 1
#define getsc()		ord(getsc_i())
d144 1
a144 1
#define getsc()		ord(getsc_r(o_getsc()))
@


1.243
log
@plug the first couple of ctype bugs
@
text
@a132 5
/*XXX
 * getsc() result is supposed to be ord()ed right now,
 * but results sometimes aren't handled correctly; re‐
 * check CVS history for *that* change and fix it
 */
d134 1
a134 1
#define getsc()		getsc_i()
d144 1
a144 1
#define getsc()		getsc_r(o_getsc())
d223 4
a226 3
		while (ctype((c = getsc()), C_BLANK))
			;
		if (ord(c) == '#') {
d228 3
a230 2
			while (!ctype((c = getsc()), C_NUL | C_LF))
				;
@


1.242
log
@revert the CORD debugging aid
(introduced so that ORD could eval its args twice in !DEBUG)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.239 2017/05/05 22:53:29 tg Exp $");
d251 1
a251 1
	    ((state == SBASE || state == SHEREDELIM) && ctype(c, C_LEX1)))) {
d302 1
a302 1
			if (ctype(c, C_PATMO)) {
@


1.241
log
@some ord() debugging; CORD for case, ORD evaluates twice, for debugging
@
text
@d315 1
a315 1
			case CORD('\\'):
d323 1
a323 1
			case CORD('\''):
d331 1
a331 1
			case CORD('"'):
d336 1
a336 1
			case CORD('$'):
d345 1
a345 1
				case CORD('"'):
d347 1
a347 1
				case CORD('\''):
d359 1
a359 1
			case CORD('\\'):
d362 1
a362 1
				case CORD('"'):
d366 3
a368 3
				case CORD('\\'):
				case CORD('$'):
				case CORD('`'):
d386 1
a386 1
			case CORD('$'):
d529 1
a529 1
			case CORD('`'):
d732 3
a734 3
				case CORD('$'):
				case CORD('`'):
				case CORD('\\'):
d737 1
a737 1
				case CORD('"'):
d801 1
a801 1
			case CORD('\\'):
d808 1
a808 1
			case CORD('\''):
d810 1
a810 1
			case CORD('$'):
d820 1
a820 1
			case CORD('"'):
d847 4
a850 4
					case CORD('\\'):
					case CORD('"'):
					case CORD('$'):
					case CORD('`'):
d1142 1
a1142 1
		case CORD(/*(*/ ')'):
d1157 1
a1157 1
		case CORD('\n'):
d1594 4
a1597 4
			case CORD('@@'):
			case CORD('#'):
			case CORD('-'):
			case CORD('?'):
d1603 1
a1603 1
			case CORD('%'):
d1606 1
a1606 1
			case CORD('#'):
d1609 1
a1609 1
			case CORD('!'):
@


1.240
log
@tentatively fix Debian #878947 by putting an end to (some) nesting

‣ also makes the error message nicer:
tg@@blau:/usr/obj/bin/mksh $ mksh -n -c '${0$(($(o[))&$(($(p[))&)'
internal error: can't allocate 8388628 data bytes
tg@@blau:/usr/obj/bin/mksh $ mksh -n -c '${0$(($(o[))&$(($(p[))&)^J'
mksh: no closing quote
1|tg@@blau:/usr/obj/bin/mksh $ ./mksh -n -c '${0$(($(o[))&$(($(p[))&)'
./mksh: syntax error: unmatched '('
1|tg@@blau:/usr/obj/bin/mksh $ ./mksh -n -c '${0$(($(o[))&$(($(p[))&)^J'
./mksh: syntax error: unmatched '('

‣ alternative fix would be to keep the block and do…
-					} else {
+					} else if (source->type != SEOF) {
… but that would keep “no closing quote” for the case with newline,
and since this seems to not break… nuking unused code is always good ☻
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013, 2014, 2015, 2016, 2017
d133 5
d139 1
a139 1
#define getsc()		ord(getsc_i())
d149 1
a149 1
#define getsc()		ord(getsc_r(o_getsc()))
d230 1
a230 1
		if (c == '#') {
d253 2
a254 2
		    subshell_nesting_type == ord(/*{*/ '}') &&
		    c == ord(/*{*/ '}'))
d260 1
a260 1
			if (c == ord('('))
d262 1
a262 1
			else if (c == ord(')'))
d264 2
a265 1
			else if (statep->nparen == 0 && (c == ord(/*{*/ '}') ||
d269 2
a270 1
				if (c == ord(/*{*/ '}') || --statep->ls_adelim.num == 0)
d272 1
a272 1
				if (c == ord(/*{*/ '}'))
d278 1
a278 1
			if (c == ord('[') && (cf & CMDASN)) {
d304 1
a304 1
				if (c2 == ord('(' /*)*/)) {
d315 1
a315 1
			case ord('\\'):
d323 1
a323 1
			case ord('\''):
d331 1
a331 1
			case ord('"'):
d336 1
a336 1
			case ord('$'):
d345 1
a345 1
				case ord('"'):
d347 1
a347 1
				case ord('\''):
d359 1
a359 1
			case ord('\\'):
d362 1
a362 1
				case ord('"'):
d366 3
a368 3
				case ord('\\'):
				case ord('$'):
				case ord('`'):
d386 1
a386 1
			case ord('$'):
d389 1
a389 1
				if (c == ord('(' /*)*/)) {
d391 1
a391 1
					if (c == ord('(' /*)*/)) {
d408 2
a409 2
				} else if (c == ord('{' /*}*/)) {
					if ((c = getsc()) == ord('|')) {
d430 1
a430 1
					if (c == ord(':')) {
d434 1
a434 1
						if (c == ord(':')) {
d466 1
a466 1
						if ((c = getsc()) == ord('/')) {
d480 1
a480 1
						if (c2 == ord('/')) {
d529 1
a529 1
			case ord('`'):
d573 1
a573 1
			if (c == ord('\'')) {
d577 1
a577 1
			} else if (c == ord('\\')) {
d605 1
a605 1
			if (c == ord('\'')) {
d618 1
a618 1
			if (c == ord('"')) {
d627 1
a627 1
			if (c == ord('('))
d629 1
a629 1
			else if (c == ord(')')) {
d635 1
a635 1
					if ((c2 = getsc()) == ord(/*(*/ ')')) {
d667 1
a667 1
			if (c == ord('\\')) {
d676 4
a679 2
				if ((c = getsc()) == ord('"') || c == ord('\\') ||
				    ctype(c, C_DOLAR | C_GRAVE) || c == ord(/*{*/ '}'))
d686 1
a686 1
			if (c == ord('\''))
d688 1
a688 1
			else if (c == ord('\\'))
d691 1
a691 1
			if (c == ord('"'))
d693 1
a693 1
			else if (c == ord('$'))
d695 1
a695 1
			else if (c == ord('`'))
d697 1
a697 1
			else if (c != ord(/*{*/ '}'))
d706 1
a706 1
			if (c == ord('|'))
d708 1
a708 1
			else if (c == ord('(')) {
d715 1
a715 1
			  if (c == ord(/*{*/ '}')) {
d724 1
a724 1
			if (c == ord('`')) {
d727 1
a727 1
			} else if (c == ord('\\')) {
d732 3
a734 3
				case ord('$'):
				case ord('`'):
				case ord('\\'):
d737 1
a737 1
				case ord('"'):
d758 1
a758 1
			if (c == ord(/*(*/ ')')) {
d761 1
a761 1
				else if ((c2 = getsc()) == ord(/*(*/ ')')) {
d783 1
a783 1
					return (ord('(' /*)*/));
d785 1
a785 1
			} else if (c == ord('('))
d801 1
a801 1
			case ord('\\'):
d808 1
a808 1
			case ord('\''):
d810 2
a811 2
			case ord('$'):
				if ((c2 = getsc()) == ord('\'')) {
d818 1
a818 1
				} else if (c2 == ord('"')) {
d820 1
a820 1
			case ord('"'):
d834 1
a834 1
			if (c != ord('"'))
d847 4
a850 4
					case ord('\\'):
					case ord('"'):
					case ord('$'):
					case ord('`'):
d868 1
a868 1
			if (c == ord(/*(*/ ')')) {
d871 1
a871 1
			} else if (c == ord('|')) {
d873 1
a873 1
			} else if (c == ord('(')) {
d903 1
a903 1
			if ((c2 = getsc()) != ord('>')) {
d914 2
a915 1
		if (c == c2 || (c == ord('<') && c2 == ord('>'))) {
d917 1
a917 1
			    (c == ord('>') ? IOCAT : IOHERE) : IORDWR;
d919 1
a919 1
				if ((c2 = getsc()) == ord('-'))
d921 1
a921 1
				else if (c2 == ord('<'))
d926 2
a927 2
		} else if (c2 == ord('&'))
			iop->ioflag |= IODUP | (c == ord('<') ? IORDUP : 0);
d929 2
a930 2
			iop->ioflag |= c == ord('>') ? IOWRITE : IOREAD;
			if (c == ord('>') && c2 == ord('|'))
d951 4
a954 2
		if ((c == ord('|')) || (c == ord('&')) || (c == ord(';')) ||
		    (c == ord('(' /*)*/))) {
d956 5
a960 5
				c = (c == ord(';')) ? BREAK :
				    (c == ord('|')) ? LOGOR :
				    (c == ord('&')) ? LOGAND :
				    /* c == ord('(' )) */ MDPAREN;
			else if (c == ord('|') && c2 == ord('&'))
d962 1
a962 1
			else if (c == ord(';') && c2 == ord('|'))
d964 1
a964 1
			else if (c == ord(';') && c2 == ord('&'))
d970 1
a970 1
				if ((c2 = getsc()) == ord('&'))
d976 1
a976 1
		} else if (c == ord('\n')) {
d1031 1
a1031 1
		    p->val.i == ord(/*{*/ '}'))) {
d1142 1
a1142 1
		case ord(/*(*/ ')'):
d1157 1
a1157 1
		case ord('\n'):
d1586 1
a1586 1
				if (ord(c2) != ord(/*{*/ '}')) {
d1594 4
a1597 4
			case ord('@@'):
			case ord('#'):
			case ord('-'):
			case ord('?'):
d1603 1
a1603 1
			case ord('%'):
d1606 1
a1606 1
			case ord('#'):
d1609 1
a1609 1
			case ord('!'):
d1627 1
a1627 1
				if (ord(c) == ord('[')) {
d1682 1
a1682 1
		if (ord(c) == ord('['))
d1684 1
a1684 1
		else if (ord(c) == ord(']'))
@


1.239
log
@sprinkle tons more ord() around

this is really not funny… mksh-ng will use even more “unsigned only”
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.229 2017/02/18 02:33:12 tg Exp $");
a286 9
					} else {
						Source *s;

						s = pushs(SREREAD,
						    source->areap);
						s->start = s->str =
						    s->u.freeme = tmp;
						s->next = source;
						source = s;
@


1.238
log
@switch EBCDIC to “nega-UTF8”
@
text
@d134 1
a134 1
#define getsc getsc_i
d144 1
a144 1
#define getsc()		getsc_r(o_getsc())
d248 2
a249 2
		    subshell_nesting_type == /*{*/ '}' &&
		    c == /*{*/ '}')
d255 1
a255 1
			if (c == '(')
d257 1
a257 1
			else if (c == ')')
d259 1
a259 1
			else if (statep->nparen == 0 && (c == /*{*/ '}' ||
d263 1
a263 1
				if (c == /*{*/ '}' || --statep->ls_adelim.num == 0)
d265 1
a265 1
				if (c == /*{*/ '}')
d271 1
a271 1
			if (c == '[' && (cf & CMDASN)) {
d306 1
a306 1
				if (c2 == '(' /*)*/ ) {
d317 1
a317 1
			case '\\':
d325 1
a325 1
			case '\'':
d333 1
a333 1
			case '"':
d338 1
a338 1
			case '$':
d347 1
a347 1
				case '"':
d349 1
a349 1
				case '\'':
d361 1
a361 1
			case '\\':
d364 1
a364 1
				case '"':
d368 3
a370 2
				case '\\':
				case '$': case '`':
d388 1
a388 1
			case '$':
d391 1
a391 1
				if (c == '(') /*)*/ {
d393 1
a393 1
					if (c == '(') /*)*/ {
d410 2
a411 2
				} else if (c == '{') /*}*/ {
					if ((c = getsc()) == '|') {
d428 1
a428 1
					*wp++ = '{'; /*}*/
d432 1
a432 1
					if (c == ':') {
d436 1
a436 1
						if (c == ':') {
d449 1
a449 1
						    c == '('/*)*/) {
d468 1
a468 1
						if ((c = getsc()) == '/') {
d482 1
a482 1
						if (c2 == '/') {
d531 1
a531 1
			case '`':
d575 1
a575 1
			if (c == '\'') {
d579 1
a579 1
			} else if (c == '\\') {
d607 1
a607 1
			if (c == '\'') {
d620 1
a620 1
			if (c == '"') {
d629 1
a629 1
			if (c == '(')
d631 1
a631 1
			else if (c == ')') {
d637 1
a637 1
					if ((c2 = getsc()) == /*(*/ ')') {
d669 1
a669 1
			if (c == '\\') {
d678 2
a679 2
				if ((c = getsc()) == '"' || c == '\\' ||
				    ctype(c, C_DOLAR | C_GRAVE) || c == /*{*/'}')
d686 1
a686 1
			if (c == '\'')
d688 1
a688 1
			else if (c == '\\')
d691 1
a691 1
			if (c == '"')
d693 1
a693 1
			else if (c == '$')
d695 1
a695 1
			else if (c == '`')
d697 1
a697 1
			else if (c != /*{*/ '}')
d706 1
a706 1
			if (c == '|')
d708 1
a708 1
			else if (c == '(') {
d715 1
a715 1
			  if (c == /*{*/ '}') {
d724 1
a724 1
			if (c == '`') {
d727 1
a727 1
			} else if (c == '\\') {
d732 3
a734 3
				case '$':
				case '`':
				case '\\':
d737 1
a737 1
				case '"':
d758 1
a758 1
			if (c == /*(*/ ')') {
d761 1
a761 1
				else if ((c2 = getsc()) == /*(*/ ')') {
d782 2
a783 2
					ungetsc('('/*)*/);
					return ('('/*)*/);
d785 1
a785 1
			} else if (c == '(')
d801 1
a801 1
			case '\\':
d808 1
a808 1
			case '\'':
d810 2
a811 2
			case '$':
				if ((c2 = getsc()) == '\'') {
d818 1
a818 1
				} else if (c2 == '"') {
d820 1
a820 1
			case '"':
d834 1
a834 1
			if (c != '"')
d847 4
a850 4
					case '\\':
					case '"':
					case '$':
					case '`':
d868 1
a868 1
			if (c == /*(*/ ')') {
d871 1
a871 1
			} else if (c == '|') {
d873 1
a873 1
			} else if (c == '(') {
d903 1
a903 1
			if ((c2 = getsc()) != '>') {
d914 1
a914 1
		if (c == c2 || (c == '<' && c2 == '>')) {
d916 1
a916 1
			    (c == '>' ? IOCAT : IOHERE) : IORDWR;
d918 1
a918 1
				if ((c2 = getsc()) == '-')
d920 1
a920 1
				else if (c2 == '<')
d925 2
a926 2
		} else if (c2 == '&')
			iop->ioflag |= IODUP | (c == '<' ? IORDUP : 0);
d928 2
a929 2
			iop->ioflag |= c == '>' ? IOWRITE : IOREAD;
			if (c == '>' && c2 == '|')
d950 2
a951 1
		if ((c == '|') || (c == '&') || (c == ';') || (c == '('/*)*/)) {
d953 5
a957 5
				c = (c == ';') ? BREAK :
				    (c == '|') ? LOGOR :
				    (c == '&') ? LOGAND :
				    /* c == '(' ) */ MDPAREN;
			else if (c == '|' && c2 == '&')
d959 1
a959 1
			else if (c == ';' && c2 == '|')
d961 1
a961 1
			else if (c == ';' && c2 == '&')
d967 1
a967 1
				if ((c2 = getsc()) == '&')
d973 1
a973 1
		} else if (c == '\n') {
d1028 1
a1028 1
		    p->val.i == /*{*/ '}')) {
d1139 1
a1139 1
		case /*(*/ ')':
d1154 1
a1154 1
		case '\n':
d1236 1
a1236 1
	while ((c = *s->str++) == 0) {
d1583 1
a1583 1
				if (c2 != /*{*/ '}') {
d1590 5
a1594 5
			switch (c) {
			case '@@':
			case '#':
			case '-':
			case '?':
d1599 2
a1600 2
			switch (c) {
			case '%':
d1603 1
a1603 1
			case '#':
d1606 1
a1606 1
			case '!':
d1624 1
a1624 1
				if (c == '[') {
d1630 2
a1631 1
					for (p = tmp; *p; ) {
d1679 1
a1679 1
		if (c == '[')
d1681 1
a1681 1
		else if (c == ']')
@


1.237
log
@commit the optimisation result from the new fast character classes
@
text
@d1539 1
a1539 1
		else if (UTFMODE && ((unsigned char)*cp > 0x7F)) {
d1757 1
a1757 1
	if ((unsigned char)(c = o_getsc_u()) != 0xEF) {
d1761 1
a1761 1
	if ((unsigned char)(c = o_getsc_u()) != 0xBB) {
d1763 1
a1763 1
		ungetsc_i(0xEF);
d1766 1
a1766 1
	if ((unsigned char)(c = o_getsc_u()) != 0xBF) {
d1768 2
a1769 2
		ungetsc_i(0xBB);
		ungetsc_i(0xEF);
@


1.236
log
@batch of optimisations
@
text
@d223 1
a223 1
		while ((c = getsc()) == ' ' || c == '\t')
d227 1
a227 1
			while ((c = getsc()) != '\0' && c != '\n')
d304 1
a304 2
			if (c == '*' || c == '@@' || c == '+' || c == '?' ||
			    c == '!') {
d678 1
a678 1
				    c == '$' || c == '`' || c == /*{*/'}')
d895 1
a895 1
	    c == '<' || c == '>') && ((c2 = Xlength(ws, wp)) == 0 ||
d1039 1
a1039 1
			while (*cp == ' ' || *cp == '\t')
d1529 1
a1529 1
		else if (*cp == '\n' || *cp == '\r') {
@


1.235
log
@eliminate legacy macros
@
text
@d447 1
a447 2
						} else if (ctype(c, C_DIGIT) ||
						    c == '('/*)*/ || c == ' ' ||
d449 1
a449 1
						    c == '$') {
d1277 1
a1277 1
			    (c = strnul(s->u.tblp->val.s)[-1], ctype(c, C_SPACE))) {
d1437 1
a1437 1
		while (*cp && ctype(*cp, C_IFSWS))
@


1.234
log
@fix reentrancy of 'typeset -f' output in the face of aliases; also,
move alias handling for COMSUBs and friends to parse time by request
of Martijn Dekker (and for consistency with function definitions)
@
text
@d447 1
a447 1
						} else if (ksh_isdigit(c) ||
d492 1
a492 1
					if (ksh_issubop2(c)) {
d506 1
a506 1
				} else if (ksh_isalphx(c)) {
d513 1
a513 1
					} while (ksh_isalnux(c));
d898 1
a898 1
	    (c2 == 2 && dp[0] == CHAR && ksh_isdigit(dp[1])))) {
d1278 1
a1278 1
			    (c = strnul(s->u.tblp->val.s)[-1], ksh_isspace(c))) {
d1613 1
a1613 1
			if (ksh_isalphx(c))
d1615 1
a1615 1
			else if (ksh_isdigit(c))
d1623 1
a1623 1
			if (!ksh_isalnux(c)) {
d1643 1
a1643 1
			if (!ksh_isdigit(c))
@


1.233
log
@streamline some error messages
@
text
@d535 1
a535 1
				*wp++ = COMSUB;
@


1.232
log
@small character classes overhaul:
• make fast character classes even faster by removing the C_SUBOP2 hack
  in favour of a separate seldom-used ksh_issubop2 macro (which also
  makes ctype() side-effect-safe) which is a slower class (no change there)
• optimise cases of ksh_isalphx followed by a ksh_isalnux loop
  (used parsing variable names)
• remove a misleading comment in initctypes() about \0 from pdksh
• rename C_ALPHA to C_ALPHX to make it more clear the underscore is included
• sprinkle a few ord() in there
• add new ksh_isalpha() which tests for [A-Za-z] (slow character class)
• there is no '_:\' drive on OS/2 (which inspired the whole changeset)
@
text
@d888 1
a888 1
		yyerror("no closing quote\n");
d1206 1
d1628 1
a1628 1
						yyerror("missing ]\n");
@


1.231
log
@fixup LINENO in eval and alias; patch and initial testcase
From: Martijn Dekker <martijn@@inlv.org>
@
text
@d492 1
a492 1
					if (ctype(c, C_SUBOP2)) {
@


1.230
log
@add a “\builtin” builtin, make it forward assignments, fix some bugs
related to that:
• while AT&T ksh may do it, POSIX says nothing about allowing
  declaration commands only without vars and redirections, and
  “without vars” especially seems against which commands they are
• fix relationship between forwarders and real declaration commands
• clean up c_builtin vs shcomexec mess

Also, re-run “make repool” with a fixed src/scripts/stringpool.sh,v 1.3
@
text
@d1066 1
@


1.229
log
@fixup relation between lksh and mksh (somewhat minimal delta)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.215 2016/01/14 19:52:20 tg Exp $");
d1017 1
a1017 1
		/* word is not unquoted */
d1022 1
a1022 4
	if (!(cf & (KEYWORD | ALIAS)))
		return (LWORD);

	if (*ident != '\0') {
d1077 1
a1077 1
	} else if (cf & ALIAS) {
d1079 4
a1082 1
		if (assign_command((dp = wdstrip(yylval.cp, 0)), true))
@


1.228
log
@implement $KSH_MATCH and, to make it usable, ${foo@@/bar/baz};
add a real-life example (for slagtc’s programmable tab completion)
to the manpage
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013, 2014, 2015, 2016
a895 1
#ifndef MKSH_LEGACY_MODE
a896 1
#endif
@


1.227
log
@remove fd>9 support in favour of upcoming named file descriptors; bump
@
text
@d465 2
d470 1
a470 1
							*wp++ = ADELIM;
d480 7
@


1.226
log
@rework string pooling; disable our own (rely on compiler’s)…
• if HAVE_STRING_POOLING is set to 1
• if HAVE_STRING_POOLING is set to 2 and not GCC < 4 is used
• if HAVE_STRING_POOLING is not set to 0 and LLVM or GCC >= 4 is used

Closes: LP#1580348
@
text
@d890 2
a891 1
	    c == '<' || c == '>')) {
d894 1
a894 11
		if (Xlength(ws, wp) == 0)
			iop->unit = c == '<' ? 0 : 1;
		else for (iop->unit = 0, c2 = 0; c2 < Xlength(ws, wp); c2 += 2) {
			if (dp[c2] != CHAR)
				goto no_iop;
			if (!ksh_isdigit(dp[c2 + 1]))
				goto no_iop;
			iop->unit = iop->unit * 10 + ksh_numdig(dp[c2 + 1]);
			if (iop->unit >= FDBASE)
				goto no_iop;
		}
@


1.225
log
@fix most of the ambiguous ${[prefix] var [op [word]]} corner cases

prodded by izabera and carstenh; resolution is:
• you can’t trim a vector in mksh, still (consider ${@@:-1})
• future POSIX will require non-empty “word” for most “op”s
• dissolve in order of standard → extension
• dissolve to prefer “op” over “prefix” where still necessary, mostly
@
text
@d991 1
a991 1
					yyerror("here document '%s' unclosed\n",
d1166 1
a1166 1
			yyerror("here document '%s' unclosed\n", eof);
d1266 1
a1266 1
				s->start = s->str = " ";
d1477 1
a1477 1
					shf_fprintf(shf, "%lu", s ?
@


1.224
log
@give C_VAR1 precedence over display variable name; izabera pointed out,
rightfully, that, in POSIX shell, ${!#} is defined, and ${!#123} should work
@
text
@d1577 12
d1590 5
a1594 1
			if (ctype(c, C_VAR1))
d1596 2
a1597 3

			if (0)
				/* FALLTHROUGH */
d1599 1
a1599 1
			  switch (c) {
d1612 1
a1612 1
		case PS_SAW_HASH:
d1617 1
a1617 13
			else if (c == '#') {
				if (state == PS_SAW_HASH) {
					char c2;

					c2 = getsc();
					ungetsc(c2);
					if (c2 != /*{*/ '}') {
						ungetsc(c);
						goto out;
					}
				}
				state = PS_VAR1;
			} else if (ctype(c, C_VAR1))
@


1.223
log
@commitid 10056D5D8AF01B31531 broke fix for Debian #783978 (add testsuite)
@
text
@d1569 2
a1570 2
		PS_INITIAL, PS_SAW_HASH, PS_IDENT,
		PS_NUMBER, PS_VAR1
d1577 6
d1584 5
a1588 1
			if (c == '#' || c == '!' || c == '%') {
d1590 4
a1593 1
				break;
d1596 1
d1637 1
@


1.222
log
@there was a comment on 1015; change comments to match, no code change
@
text
@d1353 2
a1354 1
		histsave(&s->line, NULL, HIST_FLUSH, true);
@


1.221
log
@check not-begun heredocs at EOF earlier

izabera reported they were not caught with “set -n”
@
text
@d529 5
a533 21
				 * quotes, since most shells translate \" to "
				 * within "…`…\"…`…". This is not done in POSIX
				 * mode (§2.2.3 Double-Quotes: “The backquote
				 * shall retain its special meaning introducing
				 * the other form of command substitution (see
				 * Command Substitution). The portion of the
				 * quoted string from the initial backquote and
				 * the characters up to the next backquote that
				 * is not preceded by a <backslash>, having
				 * escape characters removed, defines that
				 * command whose output replaces "`...`" when
				 * the word is expanded.”; §2.6.3 Command
				 * Substitution: “Within the backquoted style
				 * of command substitution, <backslash> shall
				 * retain its literal meaning, except when
				 * followed by: '$', '`', or <backslash>. The
				 * search for the matching backquote shall be
				 * satisfied by the first unquoted non-escaped
				 * backquote; during this search, if a
				 * non-escaped backquote is encountered[…],
				 * undefined results occur.”).
a535 4
#ifdef austingroupbugs1015_is_still_not_resolved
				if (Flag(FPOSIX))
					break;
#endif
@


1.220
log
@also flush syntax-failed or interrupted input into the history
@
text
@d1003 10
d1186 1
a1186 1
			yyerror("%s '%s' unclosed\n", Theredoc, eof);
@


1.219
log
@save 200 bytes off .text by revisiting string pooling

also, forgotten version bump
@
text
@d1362 2
a1363 1
	if (interactive)
d1365 1
@


1.218
log
@fix errno in print/echo builtin; optimise (with partial rewrite)
@
text
@d1176 1
a1176 1
			yyerror("%s '%s' unclosed\n", "here document", eof);
@


1.217
log
@align with future POSIX on http://austingroupbugs.net/view.php?id=351
with accepted interpretation (*sigh*); merge VARASN|ARRAYVAR→CMDASN
@
text
@d97 1
a97 2
static int s_get(void);
static void s_put(int);
d114 1
a114 1
#define o_getsc_r(carg)	{				\
d124 1
a124 5
	return (cev);					\
}

#if defined(MKSH_SMALL) && !defined(MKSH_SMALL_BUT_FAST)
static int getsc(void);
d126 1
d128 1
a128 1
getsc(void)
d132 3
d592 2
a593 2
				if ((c2 = unbksl(true, s_get, s_put)) == -1)
					c2 = s_get();
a1788 12

static int
s_get(void)
{
	return (getsc());
}

static void
s_put(int c)
{
	ungetsc(c);
}
@


1.216
log
@deliberately revert from POSIX to classical behaviour for "…`…\"…\"…`…"
until http://austingroupbugs.net/view.php?id=1015 is resolved (either way),
mksh R52 regression; cf. Debian #810846, #811092
@
text
@d272 1
a272 1
			if (c == '[' && (cf & (VARASN|ARRAYVAR))) {
d1095 1
a1095 1
		if (assign_command((dp = wdstrip(yylval.cp, 0))))
@


1.215
log
@parse “$( (( … ) … ) … )” correctly (LP#1532621)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.198 2015/03/20 23:37:39 tg Exp $");
d553 1
d556 1
@


1.214
log
@improve reparsing of ((…) |…) as ( (…) |…)
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013, 2014, 2015
d780 1
d793 1
@


1.213
log
@fix \u0000 and \x00 being ignored in $'…' and print +r expansion
@
text
@d787 1
a787 1
					dp = wdstrip(sp, WDS_KEEPQ);
@


1.212
log
@tweak some iop/conservative_fds-related things I picked up while thinking lksh
@
text
@d604 2
a605 1
						for (cz = 0; ts[cz]; ++cz) {
d608 1
a608 1
						}
@


1.211
log
@revert most of commitid 3ec342c92b3a8874 and fixup the rest;
this should bring us closer to POSIX again
@
text
@d954 1
a954 1
		iop->name = NULL;
@


1.210
log
@partial oksh sync, up to commit 80be547da108d5c241ae068290ca3e331446aa41?
@
text
@d237 3
a239 1
		cf |= ALIAS;
d529 22
a550 19
				 * Need to know if we are inside double quotes
				 * since sh/AT&T-ksh translate the \" to " in
				 * "`...\"...`".
				 * This is not done in POSIX mode (section
				 * 3.2.3, Double Quotes: "The backquote shall
				 * retain its special meaning introducing the
				 * other form of command substitution (see
				 * 3.6.3). The portion of the quoted string
				 * from the initial backquote and the
				 * characters up to the next backquote that
				 * is not preceded by a backslash (having
				 * escape characters removed) defines that
				 * command whose output replaces `...` when
				 * the word is expanded."
				 * Section 3.6.3, Command Substitution:
				 * "Within the backquoted style of command
				 * substitution, backslash shall retain its
				 * literal meaning, except when followed by
				 * $ ` \.").
d553 2
d742 2
a744 1
				case '$': case '`':
@


1.209
log
@replace the code related to << changes and <<< with cleaner code,
fixing a few bugs also (including new testcases, except x=<< issue)
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.50 2015/07/30 14:59:12 zhuk Exp $	*/
d6 1
a6 1
 *	mirabilos <tg@@mirbsd.org>
@


1.208
log
@fix more int vs. size_t mismatches
@
text
@d41 2
a42 2
#define SHEREDELIM	10	/* parsing <<,<<-,<<< delimiter */
#define SHEREDQUOTE	11	/* parsing " in <<,<<-,<<< delimiter */
d101 1
a101 1
static void gethere(bool);
a242 14
	/* check for here string */
	if (state == SHEREDELIM) {
		c = getsc();
		if (c == '<') {
			state = SHEREDELIM;
			while ((c = getsc()) == ' ' || c == '\t')
				;
			ungetsc(c);
			c = '<';
			goto accept_nonword;
		}
		ungetsc(c);
	}

a250 1
 accept_nonword:
d794 1
a794 1
		/* <<, <<-, <<< delimiter */
d832 1
a832 1
		/* " in <<, <<-, <<< delimiter */
d929 1
a929 1
				if ((c2 = getsc()) == '-') {
d931 1
a931 2
					c2 = getsc();
				} else if (c2 == '<')
d933 2
a934 11
				if (c2 == ' ') {
					/*XXX reentrancy hack IONDELIM */
					c2 = getsc();
					if (c2 != '\n') {
						ungetsc(c2);
						c2 = ' ';
					}
				}
				ungetsc(c2);
				if (c2 == '\n')
					iop->ioflag |= IONDELIM;
d984 8
a991 6
			gethere(false);
			if (cf & CONTIN)
				goto Again;
		} else if (c == '\0')
			/* need here strings at EOF */
			gethere(true);
d1014 2
a1015 17
	if ((cf & HEREDELIM) && (sp[1] == '<')) {
 herestringloop:
		switch ((c = *sp++)) {
		case CHAR:
			++sp;
			/* FALLTHROUGH */
		case OQUOTE:
		case CQUOTE:
			goto herestringloop;
		default:
			break;
		}
		/* dummy value */
		*dp++ = 'x';
	} else
		while ((dp - ident) < IDENT && (c = *sp++) == CHAR)
			*dp++ = *sp++;
d1091 1
a1091 1
gethere(bool iseof)
d1096 1
a1096 4
		if (iseof && !((*p)->ioflag & IOHERESTR))
			/* only here strings at EOF */
			return;
		else
d1114 1
a1114 10
	if (iop->ioflag & IOHERESTR) {
		/* process the here string */
		iop->heredoc = xp = evalstr(iop->delim, DOBLANK);
		xpos = strlen(xp) - 1;
		memmove(xp, xp + 1, xpos);
		xp[xpos] = '\n';
		return;
	}

	eof = iop->ioflag & IONDELIM ? "<<" : evalstr(iop->delim, 0);
@


1.207
log
@fix tree printing multiple heredocs in one command, bug found by izabera
@
text
@d64 1
a64 1
		int start;
d1153 1
a1153 1
	int xpos;
@


1.206
log
@oksh sync, simplify *all* if(x)free(x); constructs, simplify x_push() and sync boilerplate while here
@
text
@d949 8
@


1.205
log
@oksh sync: one rcsid-only plus this one by guenther:
Zero-pad the seconds in the output of 'time' to make columns line up
@
text
@d6 1
a6 1
 *	Thorsten Glaser <tg@@mirbsd.org>
@


1.204
log
@make certain actions flush the history buffer
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.49 2013/12/17 16:37:06 deraadt Exp $	*/
@


1.203
log
@implement completely new multiline code by delaying history store

this commit is valgrind-tested
@
text
@d1477 2
a1478 1
		if (!*cp)
d1480 1
@


1.202
log
@make $LINENO in PS1 equivalent to ! (bug spotted by carstenh in IRC)
@
text
@d1464 5
a1468 3
	} else if (interactive && *s->str &&
	    (cur_prompt != PS1 || !ctype(*s->str, C_IFS | C_IFSWS))) {
		histsave(&s->line, s->str, true, true);
d1470 2
d1473 1
@


1.201
log
@more low-hanging fruits for EBCDIC; notes:

• ord() new, From: Daniel Richard G. <skunk@@iSKUNK.ORG>
  ‣ used in some places
• (c - '0') → ksh_numdig(c)	# may take *x++ argument
• (c - 'A') → ksh_numuc(c)	# may NOT take *x+= argument
  ‣ idem for ksh_numlc(c) and 'a'
  ‣ these need changing for EBCDIC
  ‣ add testsuite for this
• use macros more, they exist already often
• use digits_lc[foo] instead of ('0' + foo), especially for letters
• caught another ksh_eq case…
• also caught a maybe-UB overflow check, but we don’t have TIME_T_MAX ☹
@
text
@d1498 1
d1510 3
d1528 1
@


1.200
log
@ordinarily, lineno must be mksh_uari_t, but edit.c most of all isn’t ready,
so we mitigate a bit (in var.c mostly) and tweak another type already, and
add some checks (mksh_{,u}ari_t must fit into {,unsigned }long) and print
line numbers with %lu already
@
text
@d923 1
a923 1
			iop->unit = (iop->unit * 10) + dp[c2 + 1] - '0';
@


1.199
log
@SECURITY: fix integer overflows related to file descriptor parsing

bug initially found by Pawel Wylecial (LP#1440685)
additional bug found and suggested fix by enh (elliott hughes)

This commit also renames struct ioword.flag to ioflag to disambiguate
it from other members named “flag”, changes it to an unsigned type,
and packs ioflag and unit into shorts each, to make the struct smaller
(aligned even: 16 bytes on 32-bit systems) and reviews some of the
code involved in fd handling, though there wasn’t much to be found.
@
text
@d1483 1
a1483 1
	cur_prompt = to;
d1506 2
a1507 2
					shf_fprintf(shf, "%d",
						s ? s->line + 1 : 0);
@


1.198
log
@fix comment no longer true since commit 1004DC49710562ACCB2
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.193 2014/06/29 11:28:28 tg Exp $");
d924 2
a927 3
		if (iop->unit >= FDBASE)
			goto no_iop;

d934 1
a934 1
			iop->flag = IOBASH;
d936 1
a936 1
			iop->flag = 0;
d941 1
a941 1
			iop->flag |= c == c2 ?
d943 1
a943 1
			if (iop->flag == IOHERE) {
d945 1
a945 1
					iop->flag |= IOSKIP;
d948 1
a948 1
					iop->flag |= IOHERESTR;
d951 1
a951 1
					iop->flag |= IONDELIM;
d954 1
a954 1
			iop->flag |= IODUP | (c == '<' ? IORDUP : 0);
d956 1
a956 1
			iop->flag |= c == '>' ? IOWRITE : IOREAD;
d958 1
a958 1
				iop->flag |= IOCLOB;
d1126 1
a1126 1
		if (iseof && !((*p)->flag & IOHERESTR))
d1147 1
a1147 1
	if (iop->flag & IOHERESTR) {
d1156 1
a1156 1
	eof = iop->flag & IONDELIM ? "<<" : evalstr(iop->delim, 0);
d1158 1
a1158 1
	if (!(iop->flag & IOEVAL))
d1167 1
a1167 1
	if (iop->flag & IOSKIP) {
d1229 1
a1229 1
	if (!(iop->flag & IOEVAL))
@


1.197
log
@“local x=$1” is supposed to not field-split and so
@
text
@d1083 1
a1083 2
				 * function definition (only the opening
				 * parenthesis is checked though)
@


1.196
log
@KNF
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013, 2014
d1047 3
a1051 3
	if (c != EOS)
		/* word is not unquoted */
		*ident = '\0';
d1053 4
a1056 1
	if (*ident != '\0' && (cf & (KEYWORD | ALIAS))) {
d1112 5
@


1.195
log
@fix here string parsing problem found by Stéphane Chazelas
@
text
@d1164 1
a1164 1
			/* nothing */;
@


1.194
log
@fix buffer overflow found by zacts from IRC (bad length calculation)
now zsh and mksh are even… :|
@
text
@d1030 11
a1040 6
	if ((cf & HEREDELIM) && (sp[1] == '<'))
		while ((dp - ident) < IDENT) {
			if ((c = *sp++) == CHAR)
				*dp++ = *sp++;
			else if ((c != OQUOTE) && (c != CQUOTE))
				break;
d1042 3
a1044 1
	else
d1047 1
a1047 1
	/* Make sure the ident array stays '\0' padded */
@


1.193
log
@fix access-after-free crash spotted by Enjolras via IRC, thanks!
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.192 2014/01/11 18:09:40 tg Exp $");
d857 1
a857 1
			XcheckN(ws, wp, (dp - sp));
@


1.193.2.1
log
@On the basis of what was uploaded to Debian jessie, open R50-stable branch:

MFC the following file changes:
• pull check.t,v up to 1.672 from 1.667
• pull dot.mkshrc,v up to 1.91 from 1.89
• pull edit.c,v up to 1.277 from 1.276
• pull exec.c,v up to 1.139 from 1.137
• pull lex.c,v up to 1.195 from 1.193
• pull mksh.1,v up to 1.347 from 1.344
MFC the following file revisions:
• apply funcs.c,v 1.263 and 1.264
MFC parts of the following file revisions:
• apply part of eval.c,v 1.160

This affects the following commits (ignoring KSH_VERSION/RCSID-only changes):

100544A426A79659D90 complete (check.t)
	printf is the wrong tool, use showargs
10054665F6C45FC6BEA complete (edit.c)
	Get rid of left over NULL elements in x_ftab as NELEM() is used instead
1005466644F12462973 complete (check.t)
	mark two ($@@/$* expansion-related) testcases as expected-fail
100546CE4F2089B6886 complete (check.t, lex.c)
	fix buffer overflow found by zacts from IRC (bad length calculation)
1005474F00E09321C83 partial
	(check.t) fix a testcase (sed could exit false, but we don't care)
	(eval.c) fix tilde_ok data type (only unsigned may shl constantly)
	(exec.c) fix shebang buf array accesses to always go via uint8_t *
100547506EF278BE75E complete (mksh.1)
	bit more on POSIX
100547506FA45A0AA5E complete (exec.c)
	fix shebang/magic decoding
100548F65AB2DD01C69 complete (check.t, lex.c)
	fix here string parsing problem
10054933E58295E7CFC complete (mksh.1)
	future directions
10054A9A4AF36B9DAFC complete (funcs.c)
	fix regression: empty line after “whence -v” with not found
10054A9ABCF7F3049A5 complete (funcs.c)
	better (whence builtin)
10054AC4B920847DDCC complete (dot.mkshrc)
	use arrname[*] to change type of all array elements
10054B1C263136FD7D2 complete (dot.mkshrc)
	typeset args are glob-prone

Finally, bump the version number.
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.195 2014/12/15 22:50:10 tg Exp $");
d857 1
a857 1
			XcheckN(ws, wp, (dp - sp) * 2);
d1030 6
a1035 11
	if ((cf & HEREDELIM) && (sp[1] == '<')) {
 herestringloop:
		switch ((c = *sp++)) {
		case CHAR:
			++sp;
			/* FALLTHROUGH */
		case OQUOTE:
		case CQUOTE:
			goto herestringloop;
		default:
			break;
d1037 1
a1037 3
		/* dummy value */
		*dp++ = 'x';
	} else
d1040 1
a1040 1
	/* make sure the ident array stays NUL padded */
@


1.193.2.2
log
@MFC most of mksh-current into R50-stable:
• alias protection of local=\typeset
• use of “command -v” in dot.mkshrc
• oksh RCSID sync, where appropriate
• fix “read -n-1”
• SECURITY (privacy): make “unset HISTFILE” work
• strip_nuls() rewrite
• manpage fixes and improvements and replacement hook
• dead constant elimination
remaining differences:
• integer-base interpretation change
• default alias protection
• dot.mkshrc “enable” support
• j_waitj() refactoring
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013, 2014, 2015
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.193.2.1 2015/01/11 22:39:50 tg Exp $");
d1047 2
d1051 1
a1051 6
		dp = ident;
	/* make sure the ident array stays NUL padded */
	memset(dp, 0, (ident + IDENT) - dp + 1);

	if (!(cf & (KEYWORD | ALIAS)))
		return (LWORD);
d1053 1
a1053 1
	if (*ident != '\0') {
a1108 5
	} else if (cf & ALIAS) {
		/* retain typeset et al. even when quoted */
		if (assign_command((dp = wdstrip(yylval.cp, 0))))
			strlcpy(ident, dp, sizeof(ident));
		afree(dp, ATEMP);
d1164 1
a1164 1
			;	/* nothing */
@


1.193.2.3
log
@sync clog
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.193.2.2 2015/03/20 22:21:03 tg Exp $");
d1083 2
a1084 1
				 * function definition
@


1.193.2.4
log
@MFC most things (see mksh.hts) to R50-stable; sync clog
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.193.2.3 2015/03/21 00:12:43 tg Exp $");
a923 2
			if (iop->unit >= FDBASE)
				goto no_iop;
d926 3
d935 1
a935 1
			iop->ioflag = IOBASH;
d937 1
a937 1
			iop->ioflag = 0;
d942 1
a942 1
			iop->ioflag |= c == c2 ?
d944 1
a944 1
			if (iop->ioflag == IOHERE) {
d946 1
a946 1
					iop->ioflag |= IOSKIP;
d949 1
a949 1
					iop->ioflag |= IOHERESTR;
d952 1
a952 1
					iop->ioflag |= IONDELIM;
d955 1
a955 1
			iop->ioflag |= IODUP | (c == '<' ? IORDUP : 0);
d957 1
a957 1
			iop->ioflag |= c == '>' ? IOWRITE : IOREAD;
d959 1
a959 1
				iop->ioflag |= IOCLOB;
d1127 1
a1127 1
		if (iseof && !((*p)->ioflag & IOHERESTR))
d1148 1
a1148 1
	if (iop->ioflag & IOHERESTR) {
d1157 1
a1157 1
	eof = iop->ioflag & IONDELIM ? "<<" : evalstr(iop->delim, 0);
d1159 1
a1159 1
	if (!(iop->ioflag & IOEVAL))
d1168 1
a1168 1
	if (iop->ioflag & IOSKIP) {
d1230 1
a1230 1
	if (!(iop->ioflag & IOEVAL))
@


1.193.2.5
log
@MFC remaining fixes; tested locally a lot, plus remotely with
GNU C11 (Debian 20150413-1) version 5.0.1 20150413 (prerelease) [gcc-5-branch revision 222050] (x86_64-linux-gnu)
including ASan (testsuite) and Valgrind (short)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.193.2.4 2015/04/12 22:32:28 tg Exp $");
d1483 1
a1483 1
	cur_prompt = (uint8_t)to;
d1506 2
a1507 2
					shf_fprintf(shf, "%lu", s ?
					    (unsigned long)s->line + 1 : 0UL);
@


1.192
log
@• use BAFH for hash ipv NZAAT
• prep for release
• fix minor nits in manpage and tests
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.191 2014/01/05 19:11:45 tg Exp $");
d162 1
a162 1
#define PUSH_SRETRACE()	do {					\
d165 1
d180 1
d409 1
a409 1
						PUSH_STATE(SASPAREN);
a410 1
						PUSH_SRETRACE();
a653 1
					POP_STATE();
d836 1
a836 2
					state = statep->type = SHEREDQUOTE;
					PUSH_SRETRACE();
@


1.191
log
@merge oksh’s “ctype cleanups” commit

(not much of it applies since we don’t use the OS’ table-based lookup)
@
text
@d5 1
a5 1
 *		 2011, 2012, 2013
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.190 2013/11/17 22:19:42 tg Exp $");
d1443 1
@


1.190
log
@oksh sync (RCSID only)
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.48 2013/11/12 04:36:02 deraadt Exp $	*/
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.188 2013/08/10 13:44:31 tg Exp $");
@


1.189
log
@Ypnose discovered a problem with multi-line prompts and SIGWINCH
related to caching some values (downside, pprompt gets back doprint option)
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.47 2013/03/03 19:11:34 guenther Exp $	*/
@


1.188
log
@reduce amount of .bss memory needed; initialise via AEDIT at x_init
or even first run of x_vi
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.187 2013/07/26 20:33:38 tg Exp $");
d1524 3
a1527 2
	bool indelimit = false;
	char delimiter = 0;
d1556 2
a1557 2
			if (indelimit ||
			    (ntruncate < (x_cols * lines + columns)))
d1563 1
a1563 1
		if ((*cp != delimiter) &&
d1567 2
a1568 1
	shf_flush(shl_out);
@


1.187
log
@• Completely overhaul prompt length calculation and
  prompt display routines; make Emacs and Vi share
  code, permitting reducing of duplication and code
  removal as well as more consistent behaviour; put
  some common code into shared helper functions, too
• New x_adjust() logic (Emacs mode): when determining
  what portion of a line to render use a much more
  sophisticated algorithm and try to fill up ⅔ of the
  total screen width (with line and prompt both) also
  as wished from Steffen Daode Nurpmeso
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.183 2013/03/24 15:01:48 tg Exp $");
d1390 1
a1390 1
		nread = x_read(xp, LINE);
@


1.186
log
@pull some quoting fixes from oksh; original patch from Alexander Polakov
@
text
@a104 2
static int dopprompt(const char *, int, bool);

d1521 2
a1522 2
static int
dopprompt(const char *cp, int ntruncate, bool doprint)
d1555 2
a1556 2
			if (doprint && (indelimit ||
			    (ntruncate < (x_cols * lines + columns))))
d1562 1
a1562 1
		if (doprint && (*cp != delimiter) &&
d1566 1
a1566 2
	if (doprint)
		shf_flush(shl_out);
a1569 13

void
pprompt(const char *cp, int ntruncate)
{
	dopprompt(cp, ntruncate, true);
}

int
promptlen(const char *cp)
{
	return (dopprompt(cp, 0, false));
}

@


1.185
log
@implement VALSUBs
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.46 2013/01/20 14:47:46 stsp Exp $	*/
d341 3
a343 1
 open_ssquote:
d506 2
a507 1
						if (state == SDQUOTE)
d628 2
d707 1
a707 1
				goto open_ssquote;
d826 1
a826 1
				goto open_ssquote;
@


1.184
log
@also do not, ever, use &> bashiop in lksh
@
text
@d424 8
a431 2
					c = getsc();
					if (ctype(c, C_IFSWS)) {
@


1.183
log
@disable parsing of &> as GNU bash iop if -o posix or -o sh, based on IRC discussion where jilles(IIRC) pointed out it breaks existing valid scripts
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.182 2013/02/19 18:45:20 tg Exp $");
d901 5
a905 2
	if (state == SBASE && (c == '<' || c == '>' ||
	    (!Flag(FSH) && !Flag(FPOSIX) && c == '&'))) {
@


1.182
log
@one more int → bool; mention “set -o sh” may (on raare OSes) be enabled
automatically (and it differs between targets); test MidnightBSD 0.1 ash
compat code and adjust the testsuite so it passes with it enabled
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.181 2013/02/17 06:05:02 tg Exp $");
d901 2
a902 1
	if ((c == '<' || c == '>' || c == '&') && state == SBASE) {
@


1.181
log
@use a different approach to the $"…" problem:
take the states that may open a string, only permit them by virtue of
moving the code out of Subst: to handle $+" and $+' at all; then add
S[Q]BRACE to that

side benefits:
• clearer, cleaner code flow
• smaller code
• better “business logic” ☺
• defuses one heavy use of duff’s device a bit
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.180 2013/02/17 05:40:16 tg Exp $");
d1511 2
a1512 1
	int columns = 0, lines = 0, indelimit = 0;
@


1.180
log
@backpedal with $'…' and $"…" interpolation

it turns out this breaks more legacy scripts than anticipated
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.179 2013/02/10 17:18:48 tg Exp $");
d351 16
a400 1
 subst_dollar:
d402 1
a522 19
				} else if (c == '\'' || c == '"') {
					switch (state) {
					/*
					 * states in which $'…'/$"…" are
					 * invalid; still not too sure about
					 * which must be included/excluded…
					 */
					case SWORD:
					case SDQUOTE:
						goto DNQUOTE;
					}
					if (c == '"')
						goto DEQUOTE;
					/* c == '\'' */
					*wp++ = OQUOTE;
					ignore_backslash_newline++;
					PUSH_STATE(SEQUOTE);
					statep->ls_bool = false;
					break;
a523 1
 DNQUOTE:
a525 1
 DEQUOTE:
d703 1
a703 1
				goto subst_dollar;
d814 2
d818 3
a822 6
					if (0)
						/* FALLTHROUGH */
			case '\'':
					  PUSH_STATE(SSQUOTE);
					*wp++ = OQUOTE;
					ignore_backslash_newline++;
@


1.179
log
@pure RCSID sync with oksh, who also added a tabcompletion fix now, with
less code, but, even according to their own comments, not as good as ours
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.174 2012/12/05 19:38:20 tg Exp $");
d362 1
a362 1
					if ((cf & (HEREDOCBODY | HERESTRBODY)))
d507 14
a520 1
				} else if (c == '\'' && !(cf & HEREDOCBODY)) {
a525 2
				} else if (c == '"' && !(cf & HEREDOCBODY)) {
					goto DEQUOTE;
d527 1
@


1.178
log
@besides more code reuse, fix $'…' everywhere (but keep it ignored in here document bodies that aren’t here strings)
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.45 2011/03/09 09:30:39 okan Exp $	*/
@


1.177
log
@use the full parser code for handling here strings (and here document words)
as ormaaj requested, including a testcase
@
text
@d5 1
a5 1
 *		 2011, 2012
d362 1
a362 1
					if ((cf & HEREDOC))
d507 1
a507 1
				} else if (c == '\'' && !(cf & HEREDOC)) {
d513 1
a513 1
				} else if (c == '"' && !(cf & HEREDOC)) {
@


1.176
log
@permit $'\n' in the bar part of ${foo:-bar}
XXX this changes slightly the herestring part
@
text
@a795 6
			 * XXX chuck this state (and the next) - use
			 * the existing states ($ and \`...` should be
			 * stripped of their specialness after the
			 * fact).
			 */
			/*
d799 3
a801 3
			if (c == '\\') {
				c = getsc();
				if (c) {
d806 2
a807 1
			} else if (c == '$') {
d811 14
a824 3
					goto sheredelim_quoted;
				} else if (c2 == '"')
					goto sheredelim_dquoted;
d826 2
a827 12
				goto sheredelim_regular;
			} else if (c == '\'') {
				PUSH_STATE(SSQUOTE);
 sheredelim_quoted:
				*wp++ = OQUOTE;
				ignore_backslash_newline++;
			} else if (c == '"') {
 sheredelim_dquoted:
				state = statep->type = SHEREDQUOTE;
				*wp++ = OQUOTE;
			} else {
 sheredelim_regular:
d833 1
a833 1
		/* " in <<,<<- delimiter */
d835 11
a845 4
			if (c == '"') {
				*wp++ = CQUOTE;
				state = statep->type = SHEREDELIM;
			} else {
d847 1
a847 3
					switch (c = getsc()) {
					case 0:
						/* trailing \ is lost */
d862 3
@


1.175
log
@remove separate SHERESTRING parsing state, it’s the same as SHEREDELIM
@
text
@d507 1
a507 2
				} else if (c == '\'' && (state == SBASE)) {
					/* XXX which other states are valid? */
d513 1
a513 2
				} else if (c == '"' && (state == SBASE)) {
					/* XXX which other states are valid? */
@


1.174
log
@fix libFirm/cparser -Wsign-compare
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.172 2012/11/30 20:19:12 tg Exp $");
d41 2
a42 2
#define SHEREDELIM	10	/* parsing <<,<<- delimiter */
#define SHEREDQUOTE	11	/* parsing " in <<,<<- delimiter */
d45 2
a46 3
#define SHERESTRING	14	/* parsing <<< string */
#define STBRACEKORN	15	/* parsing ${...[#%]...} !FSH */
#define STBRACEBOURNE	16	/* parsing ${...[#%]...} FSH */
d247 1
a247 1
			state = SHERESTRING;
d259 1
a259 2
	    ((state == SBASE || state == SHEREDELIM || state == SHERESTRING) &&
	    ctype(c, C_LEX1)))) {
d795 1
a795 36
		/* <<< delimiter */
		case SHERESTRING:
			if (c == '\\') {
				c = getsc();
				if (c) {
					/* trailing \ is lost */
					*wp++ = QCHAR;
					*wp++ = c;
				}
			} else if (c == '$') {
				if ((c2 = getsc()) == '\'') {
					PUSH_STATE(SEQUOTE);
					statep->ls_bool = false;
					goto sherestring_quoted;
				} else if (c2 == '"')
					goto sherestring_dquoted;
				ungetsc(c2);
				goto sherestring_regular;
			} else if (c == '\'') {
				PUSH_STATE(SSQUOTE);
 sherestring_quoted:
				*wp++ = OQUOTE;
				ignore_backslash_newline++;
			} else if (c == '"') {
 sherestring_dquoted:
				state = statep->type = SHEREDQUOTE;
				*wp++ = OQUOTE;
				/* just don't IFS split; no quoting mode */
			} else {
 sherestring_regular:
				*wp++ = CHAR;
				*wp++ = c;
			}
			break;

		/* <<,<<- delimiter */
d843 1
a843 4
				state = statep->type =
				    /* dp[1] == '<' means here string */
				    Xstring(ws, wp)[1] == '<' ?
				    SHERESTRING : SHEREDELIM;
d889 1
a889 1
	if (state == SHEREDELIM || state == SHERESTRING)
@


1.173
log
@shuffle declarations around (all shared between even only two files go into sh.h even if they’re not supposed to be used elsewhere) and make some static; libFirm/cparser has -Wmissing-declarations against it
@
text
@d275 2
a276 2
			else if (statep->nparen == 0 &&
			    (c == /*{*/ '}' || c == statep->ls_adelim.delimiter)) {
@


1.172
log
@MKSH_DISABLE_EXPERIMENTAL is a NOP again; use ${ precmd;} in dot.mkshrc
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.171 2012/11/30 19:02:08 tg Exp $");
a106 1
void yyskiputf8bom(void);
a109 2
struct sretrace_info *retrace_info = NULL;
int subshell_nesting_type = 0;
@


1.171
log
@use proper parenthesēs; int → bool; use same var (eno) for temp. errno
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.170 2012/10/30 20:49:41 tg Exp $");
a264 1
#ifndef MKSH_DISABLE_EXPERIMENTAL
a269 1
#endif
a403 1
#ifndef MKSH_DISABLE_EXPERIMENTAL
a404 1
#endif
a412 1
#ifndef MKSH_DISABLE_EXPERIMENTAL
a422 1
#endif
@


1.171.2.1
log
@MFC today’s batch of build/warning fixes: cid 10050BF986807E3B0C1 10050BFA2B54D772FB3 10050BFA2C0046FB3B9
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.171 2012/11/30 19:02:08 tg Exp $");
d107 1
d111 2
d280 2
a281 2
			else if (statep->nparen == 0 && (c == /*{*/ '}' ||
			    c == (int)statep->ls_adelim.delimiter)) {
@


1.170
log
@who would’ve thought proper ^C handling be so hard?
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.169 2012/10/22 20:19:13 tg Exp $");
d1397 1
a1397 1
	int have_tty = interactive && (s->flags & SF_TTY);
@


1.169
log
@bring back ${ foo;} sans dot.mkshrc patch, using a temporary file, and as experimental feature
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.168 2012/10/03 17:24:20 tg Exp $");
d111 1
a111 1
static struct sretrace_info *retrace_info;
@


1.168
log
@even more hacks to pass “-O666 -fstrict-overflow -Wstrict-overflow=9 -flto=jobserver” with “gcc version 4.8.0 20120930 (experimental) [trunk revision 191865] (Debian 20120930-1)” ☹ plus make the rtchecks mandatory
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.167 2012/08/17 18:34:21 tg Exp $");
d112 1
a112 1
uint8_t subshell_nesting_level = 0;
d265 7
d405 5
a409 1
						sp = yyrecursive();
d412 1
a412 1
						*wp++ = COMSUB;
d417 12
d1197 1
a1197 1
			if (!subshell_nesting_level)
@


1.167
log
@remove ${ foo;} from mksh again due to buffering issues jilles found
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.166 2012/07/30 21:37:12 tg Exp $");
d1037 1
a1037 1
		while (dp < ident+IDENT) {
d1044 1
a1044 1
		while (dp < ident+IDENT && (c = *sp++) == CHAR)
d1047 1
a1047 1
	memset(dp, 0, (ident+IDENT) - dp + 1);
d1680 1
a1680 1
	int depth = 1;
@


1.166
log
@implement ksh93 feature ${ foo;}
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.165 2012/07/01 15:54:55 tg Exp $");
d112 1
a112 1
int subshell_nesting_type = 0;
a264 5
		if (state == SBASE &&
		    subshell_nesting_type == /*{*/ '}' &&
		    c == /*{*/ '}')
			/* possibly end ${ :;} */
			break;
d398 1
a398 3
						c = COMSUB;
 subst_command2:
						sp = yyrecursive(c);
d401 1
a401 1
						*wp++ = c;
a405 11
					c = getsc();
					if (ctype(c, C_IFSWS)) {
						/*
						 * non-subenvironment
						 * "command" substitution
						 */
						c = FUNSUB;
						goto subst_command2;
					}
					ungetsc(c);

d1174 1
a1174 1
			if (!subshell_nesting_type)
@


1.165
log
@lesson learned from http://k1024.org/~iusty/blog/entry/perf-null/ – add -DMKSH_SMALL_BUT_FAST which gives more speed (8/20K less cycles, 5/9K less insns, 1.8/2.4k less branches, 65/275 less branch misses) on Debian/amd64 (klibc-static/eglibc) at cost of 0/2 more page faults and 6K/6K more text size
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.164 2012/06/28 20:05:07 tg Exp $");
d112 1
a112 1
short subshell_nesting_level = 0;
d265 5
d403 3
a405 1
						sp = yyrecursive();
d408 1
a408 1
						*wp++ = COMSUB;
d413 11
d1192 1
a1192 1
			if (!subshell_nesting_level)
@


1.164
log
@hackish work-around the lexer to make alias definitions in mksh -c
work (Closes: #517009) and mention in the manpage why they sometimes
do not work (doing so for COMSUBs is not worth the effort)
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.163 2012/05/04 22:44:33 tg Exp $");
d134 1
a134 1
#ifdef MKSH_SMALL
@


1.163
log
@keep up
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.161 2012/04/07 11:19:49 tg Exp $");
d1286 1
@


1.162
log
@new MKSH_NO_CMDLINE_EDITING to disable command line editing in its entirety

mainly for the Plan 9 port though it may also help the WinAPI variant,
other porting efforts, as well as a new project I cannot say yet
@
text
@d4 2
a5 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
@


1.161
log
@drop all deprecated code, you have been warned
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.160 2012/03/31 17:29:59 tg Exp $");
d1385 1
d1399 3
a1401 1
	} else {
@


1.160
log
@use _setjmp/_longjmp on NeXTstep: its Intel port always restores the signal mask on siglongjmp, which we never have
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.159 2012/03/29 19:23:00 tg Exp $");
a1442 19
#if !defined(MKSH_SMALL) && !defined(MKSH_DISABLE_DEPRECATED)
	if (interactive && *cp == '!' && cur_prompt == PS1) {
		int linelen;

		linelen = Xlength(s->xs, xp);
		XcheckN(s->xs, xp, Zfc_e_dash + /* NUL */ 1);
		/* reload after potential realloc */
		cp = Xstring(s->xs, xp);
		/* change initial '!' into space */
		*cp = ' ';
		/* NUL terminate the current string */
		*xp = '\0';
		/* move the actual string forward */
		memmove(cp + Zfc_e_dash, cp, linelen + /* NUL */ 1);
		xp += Zfc_e_dash;
		/* prepend it with "fc -e -" */
		memcpy(cp, Tfc_e_dash, Zfc_e_dash);
	}
#endif
@


1.159
log
@couple of minor/cosmetic fixes from RT’s compile farm:

• promote SCO OpenServer and UnixWare to !oswarn
• omit trying -O2/-O on OpenServer 5 and USL C
• cast mksh_ari_t to int, mksh_uari_t to unsigned int for printf
• skip ulimit-1 on syllable (which is still too broken)
• write ((mksh_ari_t)-2147483648) ipv UB ((mksh_ari_t)1 << 31)
  and add a comment that that is actually meant
• rewrite functions returning !void ending in NOTREACHED
  so they’ve got a jump target returning an error at the
  end, to aid older compilers and just to be safe
• cast struct stat.st_size to off_t or size_t explicitly when needed
• shorten struct env by two bytes and an alignment, at least

also, optimise control flow and fix more paren matching cases
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.158 2011/11/26 17:56:30 tg Exp $");
d1517 1
a1517 1
			if (sigsetjmp(e->jbuf, 0)) {
@


1.158
log
@#ifdef MKSH_DISABLE_DEPRECATED do not compile in features scheduled for removal
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.157 2011/10/25 22:36:36 tg Exp $");
d1636 1
a1636 1
					if (c2 != '}') {
@


1.157
log
@rename more identifiers with trailing underscores
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.156 2011/09/07 15:24:16 tg Exp $");
d1443 1
a1443 1
#ifndef MKSH_SMALL
@


1.156
log
@• access(2) is broken in at least kFreeBSD 9.0 as “modern” OS, so bring
  back the wrapper code as well as refactor most other code calling it
• apparently, names can’t end in ‘_’ or contain ‘__’ anywhere…
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.155 2011/08/27 18:06:47 tg Exp $");
d93 1
a93 1
static void ungetsc_(int);
d102 2
a103 2
static Lex_state *push_state_(State_info *, Lex_state *);
static Lex_state *pop_state_(State_info *, Lex_state *);
d157 1
a157 1
		statep = push_state_(&state_info, statep);	\
d163 1
a163 1
		statep = pop_state_(&state_info, statep);	\
d1730 1
a1730 1
	ungetsc_(c);
d1733 1
a1733 1
ungetsc_(int c)
d1771 1
a1771 1
			ungetsc_(c2);
d1784 1
a1784 1
		ungetsc_(c);
d1788 2
a1789 2
		ungetsc_(c);
		ungetsc_(0xEF);
d1793 3
a1795 3
		ungetsc_(c);
		ungetsc_(0xBB);
		ungetsc_(0xEF);
d1802 1
a1802 1
push_state_(State_info *si, Lex_state *old_end)
d1813 1
a1813 1
pop_state_(State_info *si, Lex_state *old_end)
@


1.155
log
@patch most of Jerker Bäck’s concerns out, unless not applicable
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.154 2011/07/26 16:57:27 tg Exp $");
d94 1
a94 1
static int getsc__(void);
d114 1
a114 1
#define _getsc()	(*source->str != '\0' && *source->str != '\\' && \
d116 2
a117 2
/* optimised getsc__() */
#define	_getsc_()	((*source->str != '\0') ? *source->str++ : getsc__())
d120 1
a120 1
#define _getsc_r(carg)	{				\
d139 1
a139 1
	_getsc_r(_getsc());
d147 1
a147 1
	_getsc_r(c);
d150 1
a150 1
#define getsc()		getsc_r(_getsc())
d1263 1
a1263 1
getsc__(void)
d1331 1
a1331 1
				c = getsc__();
d1448 1
a1448 1
		XcheckN(s->xs, xp, Tn_fc_e_ + /* NUL */ 1);
d1456 2
a1457 2
		memmove(cp + Tn_fc_e_, cp, linelen + /* NUL */ 1);
		xp += Tn_fc_e_;
d1459 1
a1459 1
		memcpy(cp, T_fc_e_, Tn_fc_e_);
d1756 1
a1756 1
		return (_getsc_());
d1760 1
a1760 1
		return (_getsc_());
d1766 1
a1766 1
		c = _getsc_();
d1768 1
a1768 1
			if ((c2 = _getsc_()) == '\n')
d1783 1
a1783 1
	if ((unsigned char)(c = _getsc_()) != 0xEF) {
d1787 1
a1787 1
	if ((unsigned char)(c = _getsc_()) != 0xBB) {
d1792 1
a1792 1
	if ((unsigned char)(c = _getsc_()) != 0xBF) {
@


1.154
log
@followup fix for 1004D90467358D6B13C regarding escaped substitutions
found in, out of all things, Debian/m68k, by Wouter Verhelst (Yoe)
fix hacked at DebConf 11, Бања Лука, Република Српска, Босна и Херцеговина
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.153 2011/06/04 16:11:18 tg Exp $");
d200 1
d398 2
a399 2
						c2 = strlen(sp) + 1;
						XcheckN(ws, wp, c2);
d401 2
a402 2
						memcpy(wp, sp, c2);
						wp += c2;
d584 3
a586 3
						c = utf_wctomb(ts, c2 - 0x100);
						ts[c] = 0;
						for (c = 0; ts[c]; ++c) {
d588 1
a588 1
							*wp++ = ts[c];
d629 4
a632 4
						c = strlen(sp) - 2;
						XcheckN(ws, wp, c);
						memcpy(wp, sp + 1, c);
						wp += c;
d1142 3
a1144 3
		c = strlen(xp) - 1;
		memmove(xp, xp + 1, c);
		xp[c] = '\n';
@


1.153
log
@better parsing for x=(…) – bug noted by Frank Terbeck
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.152 2011/05/29 06:19:27 tg Exp $");
d43 4
a46 3
#define STBRACE		13	/* parsing ${...[#%]...} */
#define SADELIM		14	/* like SBASE, looking for delimiter */
#define SHERESTRING	15	/* parsing <<< string */
d460 1
a460 1
					if (!Flag(FSH) && ctype(c, C_SUBOP2)) {
d462 4
a465 1
						PUSH_STATE(STBRACE);
d694 3
a696 7
		case STBRACE:
			/* Same as SBASE, except (,|,) treated specially */
			if (c == /*{*/ '}') {
				POP_STATE();
				*wp++ = CSUBST;
				*wp++ = /*{*/ '}';
			} else if (c == '|') {
d698 1
a698 1
			} else if (c == '(') {
d703 6
@


1.152
log
@support ;;& as alternative name for ;| unless MKSH_SMALL
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.151 2011/05/29 02:18:52 tg Exp $");
d44 2
a45 3
#define SLETARRAY	14	/* inside =( ), just copy */
#define SADELIM		15	/* like SBASE, looking for delimiter */
#define SHERESTRING	16	/* parsing <<< string */
a221 6
#ifndef MKSH_SMALL
	} else if (cf & LETARRAY) {
		state = SLETARRAY;
		statep->nparen = 0;
		PUSH_SRETRACE();
#endif
d241 1
a241 1
	/* Initial state: one of SWORD SLETPAREN SLETARRAY SHEREDELIM SBASE */
a774 24
#ifndef MKSH_SMALL
		/* LETARRAY: =( ... ) */
		case SLETARRAY:
			if (c == '('/*)*/)
				++statep->nparen;
			else if (c == /*(*/')') {
				if (statep->nparen-- == 0) {
					POP_SRETRACE();
					/* drop trailing paren */
					c = strlen(dp = sp) - 1;
					XcheckN(ws, wp, c * 2);
					while (c--) {
						*wp++ = CHAR;
						*wp++ = *dp++;
					}
					afree(sp, ATEMP);
					/* assert: c == 0 */
					goto Done;
				}
			}
			/* reuse existing state machine */
			goto Sbase2;
#endif

a905 5
#ifndef MKSH_SMALL
	if (state == SLETARRAY && statep->nparen != -1)
		yyerror("%s: %s\n", T_synerr, "missing )");
#endif

d1013 1
a1013 5
	    /* XXX ONEWORD? */
#ifndef MKSH_SMALL
	    || state == SLETARRAY
#endif
	    )
@


1.151
log
@mksh R40 Release Candidate 1

Testsuite:
• add new need-pass: {yes|no} attribute, default yes
• exit with 1 if a need-pass test failed unexpectedly
  idea by Kacper Kornet <draenog@@pld-linux.org>
• mark utf8bom-2 as need-pass: no
Infrstructure:
• add housekeeping function for making a tty raw
• switch functions with unused results to void
• struct op: u.charflag contains last char of ;; in TPAT
• var.c:arraysearch is now a global function
Language:
• add ;& (fall through) and ;| (examine next) delimiters
  in addition to ;; (end case) as zsh extensions, because
  POSIX standardised on ;& already
• add -A (read into array), -N (read exactly n bytes),
  -n (read up to n bytes), -t (timeout) flags for read
  from ksh93
• allow read -N -1 or -n -1 to slurp the entire input
• add -a (read into array the input characters) extension
  specific to mksh to read, idea by David Korn
• add -e (exit with error if PWD was not set correctly
  after a physical cd) to cd builtin, mandated by next
  POSIX, and change error codes accordingly
Rewrites:
• full rewrite of read builtin and its manpage section
• add regression tetss for most of the new functionality
• duplicate hexdump demo tests for use of read -a
• use read -raN-1 in dot.mkshrc to get NUL safe base64,
  DJB cdb hash and Jenkins one-at-a-time hash functions
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.150 2011/05/07 00:51:12 tg Exp $");
d1027 8
@


1.150
log
@• fix an inverted logic bug in the test I wrote
• only trigger deleting an alias in favour of a function for “()”, not
  just the opening parenthesis: “stop( )” is not a function definition
  (well, actually it seems to be, but… not according to POSIX, anyway)
• defer dropping the alias until the function is actually defined (õÕ)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.149 2011/05/07 00:24:34 tg Exp $");
d1021 4
@


1.149
log
@fix problem #1 and a comment
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.148 2011/05/05 00:04:57 tg Exp $");
d1104 1
a1104 7
			if (*cp == '(' /*)*/)
				/*
				 * delete alias upon encountering function
				 * definition
				 */
				ktdelete(p);
			else {
@


1.148
log
@• use a flag for determining here strings, don’t parse delimiter every time
• don’t leak memory parsing possible I/O redirection tokens
• get rid of volatile by using more const (also helps codegen, methinks)
• support empty here document markers (mksh extension)
• pimp the manpage
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.147 2011/05/02 22:52:51 tg Exp $");
a814 2
				/* invoke quoting mode */
				Xstring(ws, wp)[0] = QCHAR;
a828 2
				/* invoke quoting mode */
				Xstring(ws, wp)[0] = QCHAR;
@


1.147
log
@• fix wtf(1) by keeping the paren in ${foo#\(} properly escaped in COMSUB
• merge tputS and wdstrip_internal
⇒ net save: 604 .text 0 .data 0 .bss (MirBSD/i386)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.146 2011/04/22 12:10:14 tg Exp $");
d983 1
a983 1
				if ((c2 = getsc()) == '-')
d985 6
a990 2
				else
					ungetsc(c2);
d1010 1
a1010 1
		;
d1149 1
a1149 1
		if (iseof && (*p)->delim[1] != '<')
d1165 1
a1165 2
	char *volatile eof;
	char *eofp;
d1170 1
a1170 1
	if (iop->delim[1] == '<') {
d1172 1
a1172 1
		xp = iop->heredoc = evalstr(iop->delim, DOBLANK);
d1179 1
a1179 1
	eof = evalstr(iop->delim, 0);
@


1.146
log
@static initialisers implicitly null out a variable (I think)
so take care of that (for global variables) to avoid them
moving from .bss to .data
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.145 2011/03/28 08:27:09 tg Exp $");
d766 1
a766 1
					dp = wdstrip(sp, true, false);
@


1.145
log
@another Debian workaround for /bin/sh: don’t pattern in trims
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.144 2011/03/26 16:11:43 tg Exp $");
d110 1
a110 1
static struct sretrace_info *retrace_info = NULL;
@


1.144
log
@special-case another bizarre POSIX corner case
after david korn agreed to change ksh93 to match
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.143 2011/03/26 15:32:37 tg Exp $");
d466 1
a466 1
					if (ctype(c, C_SUBOP2)) {
@


1.143
log
@new (some possible) testcases from Austin ML, and one fix
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.142 2011/03/13 16:35:54 tg Exp $");
d1637 1
d1641 1
a1641 2
	} state;
	char c;
a1642 1
	state = PS_INITIAL;
d1658 13
a1670 1
			else if (ctype(c, C_VAR1))
@


1.142
log
@sync with oksh (nop, RCS IDs only)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.141 2011/03/13 16:20:45 tg Exp $");
d111 1
a111 1
short comsub_nesting_level = 0;
d1201 5
a1205 2
			if (!comsub_nesting_level)
				/* not allowed outside $(...) => mismatch */
d1207 1
a1207 1
			/* Allow $(...) to close here */
@


1.141
log
@we need not only store into the retrace buffers recursively but also ungetsc
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.44 2008/07/03 17:52:08 otto Exp $	*/
d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.140 2011/03/13 16:07:36 tg Exp $");
@


1.140
log
@fix/sync comments
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.139 2011/03/13 16:03:51 tg Exp $");
d1732 2
d1739 5
a1743 2
	if (retrace_info && Xlength(retrace_info->xs, retrace_info->xp))
		retrace_info->xp--;
@


1.139
log
@• speed optimisation: drop SF_FIRST flag, factor out skipping the
  UTF-8 BOM instead (UTFMODE has a separate value now for activated
  during BOM skipping)
• parsing a COMSUB now skips UTF-8 BOM, too, but only temporarily
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.138 2011/03/13 15:57:23 tg Exp $");
a620 4
			/*
			 * XXX should nest using existing state machine
			 * (embed "...", $(...), etc.)
			 */
d658 1
d802 1
@


1.138
log
@let SLETARRAY use SRETRACE, too
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.136 2011/03/13 01:11:58 tg Exp $");
d106 1
d114 2
a115 3
#define _getsc()	(*source->str != '\0' && *source->str != '\\' \
			 && !backslash_skip && !(source->flags & SF_FIRST) \
			 ? *source->str++ : getsc_bn())
d117 1
a117 2
#define	_getsc_()	((*source->str != '\0') && !(source->flags & SF_FIRST) \
			 ? *source->str++ : getsc__())
a1294 1
 getsc_again:
a1390 11
	/* check for UTF-8 byte order mark */
	if (s->flags & SF_FIRST) {
		s->flags &= ~SF_FIRST;
		if (((unsigned char)c == 0xEF) &&
		    (((const unsigned char *)(s->str))[0] == 0xBB) &&
		    (((const unsigned char *)(s->str))[1] == 0xBF)) {
			s->str += 2;
			UTFMODE = 1;
			goto getsc_again;
		}
	}
d1789 23
@


1.137
log
@drop dead code
@
text
@d217 1
a217 1
	if (cf&ONEWORD)
d219 1
a219 1
	else if (cf&LETEXPR) {
d225 1
a225 1
	} else if (cf&LETARRAY) {
d228 1
d793 10
a802 1
					c = 0;
d806 1
a806 3
			*wp++ = CHAR;
			*wp++ = c;
			break;
d1075 1
a1075 1
	if (*ident != '\0' && (cf&(KEYWORD|ALIAS))) {
@


1.136
log
@implement better SASPAREN handling (actually, reusable very good for the
case where SASPAREN→COMSUB downgrading is done) by “logging” input and
restarting from there if needed
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.134 2011/03/12 23:04:46 tg Exp $");
a662 2
			*wp++ = c;
			break;
@


1.135
log
@correct documentation
@
text
@d49 6
d63 1
a63 1
		/* marks start of $(( in output string */
d92 2
a100 1
static const char *ungetsc(int);
d109 1
d120 14
a135 1
static int getsc_(void);
d140 1
a140 1
	return (_getsc());
d142 2
d146 1
a146 1
getsc_(void)
d148 1
a148 1
	return (_getsc_());
d150 2
a151 4
#else
/* !MKSH_SMALL: use them inline */
#define getsc()		_getsc()
#define getsc_()	_getsc_()
d160 1
a160 1
} while (0)
d166 20
a185 1
} while (0)
d394 1
d397 2
a398 3
						statep->ls_start =
						    Xsavepos(ws, wp);
						*wp++ = EXPRSUB;
d541 1
a541 1
				while (1) {
d631 2
a632 2
					*wp++ = EOS;
					/* EOS == '\0', coincidentally */
d634 7
a640 2
					if ((c2 = getsc()) == /*(*/')') {
						POP_STATE();
d651 1
a651 5
						wp = Xrestpos(ws, wp,
						    statep->ls_start);
						POP_STATE();
						/* dp = $((blah))\0 */
						dp = wdstrip(wp, true, false);
d655 1
a655 3
						    (s->u.freeme = dp) + 2;
						dp[strlen(dp) - 1] = 0;
						/* s->str = (blah)\0 */
d662 1
d797 1
a797 1
			} 
d1438 1
a1438 1
		while (1) {
d1650 1
a1650 1
	while (1) {
d1738 1
a1738 1
static const char *
d1745 8
a1752 1
		return (source->str);
a1763 1
	return (source->str);
d1774 1
a1774 1
		return (getsc_());
d1778 1
a1778 1
		return (getsc_());
d1783 2
a1784 2
	while (1) {
		c = getsc_();
d1786 1
a1786 1
			if ((c2 = getsc_()) == '\n')
d1789 1
a1789 1
			ungetsc(c2);
@


1.134
log
@• back out the EXPRSUB change
• optimise some code
• split testcase into two, one with expected-fail
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.133 2011/03/12 22:44:28 tg Exp $");
d208 1
a208 1
	/* Initial state: one of SBASE SHEREDELIM SWORD SASPAREN */
@


1.133
log
@SASPAREN changes have the same problem, revert too for now
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.132 2011/03/12 22:40:02 tg Exp $");
a248 1
// subst_base:
d590 1
d592 2
a595 1
						/* end of EXPRSUB */
d623 2
a624 3
*wp++ = CHAR;
                       *wp++ = c;
                       break;
d685 3
d699 2
a700 5
					if (c) {
						/* trailing \ is lost */
						*wp++ = '\\';
						*wp++ = c;
					}
a757 2
//else if (c == '$')
//				goto subst_dollar;
d857 6
a862 2
					case '\\': case '"':
					case '$': case '`':
d865 2
a866 5
						if (c) {
							/* trailing \ lost */
							*wp++ = CHAR;
							*wp++ = '\\';
						}
@


1.132
log
@revert SLETARRAY changes for now, this introduces problems
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.131 2011/03/12 21:41:13 tg Exp $");
d249 1
a249 1
 subst_base:
d622 3
a624 1
			goto subst_base;
@


1.131
log
@• make EXPRSUB not initiate an ASCIIZ string any more but a wdstring
  (token stream, lexer output / parser input), EOS terminated, let
  SASPAREN use the same lexing as SBASE (e.g. COMSUB recursively)
• make wdstrip recursive
• fix processing of COMSUB in wdstrip
⇒ pass comsub-1 test
• expose another debugging function
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.130 2011/03/12 20:20:16 tg Exp $");
d755 3
a757 2
			} else if (c == '$')
				goto subst_dollar;
@


1.130
log
@even more test cases for comsub (2 breaking, but one of them fixed already)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.129 2011/03/07 20:32:49 tg Exp $");
d249 1
d591 1
a594 1
						*wp++ = 0;
a604 1
						*wp = EOS;
d622 1
a622 2
			*wp++ = c;
			break;
@


1.129
log
@• x=$(cat <<-EOF
	EOF) # works again now, plugging a regression
• rewrite the here document parsing code to be *much* more efficient
  (and a bit more readable too!) using goto, while here (no kidding)
@
text
@a0 1

d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.128 2011/03/07 20:30:39 tg Exp $");
d102 1
a102 1
static int comsub_nesting_level;
a361 1
						++comsub_nesting_level;
a362 1
						--comsub_nesting_level;
d751 1
a751 1
			else if (c == /*(*/')')
d756 2
@


1.128
log
@introduce a tobool(cond) abstraction¹ and switch bool to char if !stdbool.h

① currently: ((cond) ? true : false) but (!!(cond)) and casting to bool,
  the latter only if stdbool.h, would also work – which performs best on
  (and across) all supported systems?
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.127 2011/03/07 20:09:34 tg Exp $");
d103 1
d153 1
a153 1
 * hence the state stack.
d363 1
d365 1
a1119 1
	int skiptabs;
d1140 20
a1159 11
	for (;;) {
		eofp = eof;
		skiptabs = iop->flag & IOSKIP;
		xpos = Xsavepos(xs, xp);
		while ((c = getsc()) != 0) {
			if (skiptabs) {
				if (c == '\t')
					continue;
				skiptabs = 0;
			}
			if (c != *eofp)
d1161 11
a1171 19
			Xcheck(xs, xp);
			Xput(xs, xp, c);
			eofp++;
		}
		/*
		 * Allow EOF here so commands with out trailing newlines
		 * will work (eg, ksh -c '...', $(...), etc).
		 */
		if (*eofp == '\0' && (c == 0 || c == '\n')) {
			xp = Xrestpos(xs, xp, xpos);
			break;
		}
		ungetsc(c);
		while ((c = getsc()) != '\n') {
			if (c == 0)
				yyerror("%s '%s' unclosed\n", "here document",
				    eof);
			Xcheck(xs, xp);
			Xput(xs, xp, c);
d1173 9
d1184 2
d1187 13
@


1.127
log
@drop more currently unused
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.126 2011/03/07 20:08:48 tg Exp $");
d57 1
a57 1
		Lex_state *base;
d93 1
a93 1
static int arraysub(char **);
d1644 1
a1644 1
static int
d1667 1
a1667 1
	return (depth == 0 ? 1 : 0);
@


1.126
log
@drop unused
@
text
@d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.125 2011/03/07 20:07:52 tg Exp $");
a64 2
			/* SADELIM_BASH, later extensions */
			unsigned char style;
a68 2
			/* ofs. into sadelim_flags[] */
			unsigned char flags;
a79 1
#define SADELIM_BASH	0
a385 1
							statep->ls_adelim.style = SADELIM_BASH;
a401 1
							statep->ls_adelim.style = SADELIM_BASH;
a416 1
						statep->ls_adelim.style = SADELIM_BASH;
@


1.125
log
@reduce data size by 320 bytes by packing struct lex_state tighter
and reducing amount of them allocated in each “pack” from 31 to 7
since $(…) is recursive anyway (I tried hard to need even only 5)
@
text
@d1 1
d26 1
a26 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.124 2011/03/06 17:08:12 tg Exp $");
d65 1
a65 1
			/* SADELIM_BASH, SADELIM_MAKE */
a84 1
#define SADELIM_MAKE	1
@


1.124
log
@• more fixes (some regression, some new)
• more testcases, stricter testcases
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.123 2011/03/06 01:25:33 tg Exp $");
d47 1
d53 1
a53 3
typedef struct lex_state Lex_state;
struct lex_state {
	int ls_state;
d55 10
a64 32
		/* $((...)) */
		struct sasparen_info {
			int nparen;	/* count open parenthesis */
			int start;	/* marks start of $(( in output str */
#define ls_sasparen ls_info.u_sasparen
		} u_sasparen;

		/* ((...)) */
		struct sletparen_info {
			int nparen;	/* count open parenthesis */
#define ls_sletparen ls_info.u_sletparen
		} u_sletparen;

		/* `...` */
		struct sbquote_info {
			int indquotes;	/* true if in double quotes: "`...`" */
#define ls_sbquote ls_info.u_sbquote
		} u_sbquote;

#ifndef MKSH_SMALL
		/* =(...) */
		struct sletarray_info {
			int nparen;	/* count open parentheses */
#define ls_sletarray ls_info.u_sletarray
		} u_sletarray;
#endif

		/* ADELIM */
		struct sadelim_info {
			unsigned char nparen;	/* count open parentheses */
#define SADELIM_BASH	0
#define SADELIM_MAKE	1
d66 1
d68 1
d70 15
a84 13
			unsigned char flags;	/* ofs. into sadelim_flags[] */
#define ls_sadelim ls_info.u_sadelim
		} u_sadelim;

		/* $'...' */
		struct sequote_info {
			bool got_NUL;	/* ignore rest of string */
#define ls_sequote ls_info.u_sequote
		} u_sequote;

		Lex_state *base;	/* used to point to next state block */
	} ls_info;
};
d138 1
a138 1
#define STATE_BSIZE	32
d143 1
a143 1
	state = statep->ls_state = (s);				\
d149 1
a149 1
	state = statep->ls_state;				\
d171 2
a172 2
	states[0].ls_state = -1;
	states[0].ls_info.base = NULL;
d188 1
a188 1
		statep->ls_sletparen.nparen = 0;
d192 1
a192 1
		statep->ls_sletarray.nparen = 0;
d214 1
a214 1
	statep->ls_state = state;
d239 1
a239 1
				statep->ls_sadelim.nparen++;
d241 3
a243 3
				statep->ls_sadelim.nparen--;
			else if (statep->ls_sadelim.nparen == 0 &&
			    (c == /*{*/ '}' || c == statep->ls_sadelim.delimiter)) {
d246 1
a246 1
				if (c == /*{*/ '}' || --statep->ls_sadelim.num == 0)
d360 2
a361 2
						statep->ls_sasparen.nparen = 2;
						statep->ls_sasparen.start =
d391 4
a394 4
							statep->ls_sadelim.style = SADELIM_BASH;
							statep->ls_sadelim.delimiter = ':';
							statep->ls_sadelim.num = 1;
							statep->ls_sadelim.nparen = 0;
d408 4
a411 4
							statep->ls_sadelim.style = SADELIM_BASH;
							statep->ls_sadelim.delimiter = ':';
							statep->ls_sadelim.num = 2;
							statep->ls_sadelim.nparen = 0;
d424 4
a427 4
						statep->ls_sadelim.style = SADELIM_BASH;
						statep->ls_sadelim.delimiter = '/';
						statep->ls_sadelim.num = 1;
						statep->ls_sadelim.nparen = 0;
d469 1
a469 1
					statep->ls_sequote.got_NUL = false;
d506 1
a506 1
				statep->ls_sbquote.indquotes = 0;
d511 2
a512 2
						if (s2->ls_state == SDQUOTE) {
							statep->ls_sbquote.indquotes = 1;
d518 1
a518 1
					if (!(s2 = s2->ls_info.base))
d546 2
a547 2
					statep->ls_sequote.got_NUL = true;
				if (!statep->ls_sequote.got_NUL) {
d562 1
a562 1
			} else if (!statep->ls_sequote.got_NUL) {
d594 1
a594 1
				statep->ls_sasparen.nparen++;
d596 2
a597 2
				statep->ls_sasparen.nparen--;
				if (statep->ls_sasparen.nparen == 1) {
d614 1
a614 1
						    statep->ls_sasparen.start);
d697 1
a697 1
					if (statep->ls_sbquote.indquotes) {
d721 2
a722 2
				if (statep->ls_sletparen.nparen > 0)
					--statep->ls_sletparen.nparen;
d747 1
a747 1
				 * parenthesis inside quotes and
d751 1
a751 1
				++statep->ls_sletparen.nparen;
d758 1
a758 1
				++statep->ls_sletarray.nparen;
d760 1
a760 1
				if (statep->ls_sletarray.nparen-- == 0) {
d783 1
a783 1
					statep->ls_sequote.got_NUL = false;
d798 1
a798 1
				state = statep->ls_state = SHEREDQUOTE;
d830 1
a830 1
					statep->ls_sequote.got_NUL = false;
d843 1
a843 1
				state = statep->ls_state = SHEREDQUOTE;
d856 1
a856 1
				state = statep->ls_state =
d904 1
a904 1
	if (state == SLETARRAY && statep->ls_sletarray.nparen != -1)
d1736 1
a1736 1
	news[0].ls_info.base = old_end;
d1747 2
a1748 2
	si->base = old_end->ls_info.base - STATE_BSIZE;
	si->end = old_end->ls_info.base;
@


1.123
log
@the long-awaited recursive parser for COMSUB $(…) expressions

fixes RedHat BZ#496791
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.122 2010/12/19 20:00:54 tg Exp $");
a616 1
					POP_STATE();
d618 1
d625 1
d632 3
a634 1
						wp = Xstring(ws, wp);
d641 2
a642 2
						dp[strlen(dp) - 1] = c2;
						/* s->str = (blah)C\0 */
@


1.122
log
@this is a bashism but might be from ksh93 IIRC… still dead ugly as hell!
@
text
@d4 1
a4 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.121 2010/09/14 21:26:14 tg Exp $");
d38 9
a46 10
#define SCSPAREN	8	/* inside $() */
#define SBQUOTE		9	/* inside `` */
#define SASPAREN	10	/* inside $(( )) */
#define SHEREDELIM	11	/* parsing <<,<<- delimiter */
#define SHEREDQUOTE	12	/* parsing " in <<,<<- delimiter */
#define SPATTERN	13	/* parsing *(...|...) pattern (*+?@@!) */
#define STBRACE		14	/* parsing ${...[#%]...} */
#define SLETARRAY	15	/* inside =( ), just copy */
#define SADELIM		16	/* like SBASE, looking for delimiter */
#define SHERESTRING	17	/* parsing <<< string */
d48 4
a51 2
/* Structure to keep track of the lexing state and the various pieces of info
 * needed for each particular state. */
a55 7
		/* $(...) */
		struct scsparen_info {
			int nparen;	/* count open parenthesis */
			int csstate;	/* XXX remove */
#define ls_scsparen ls_info.u_scsparen
		} u_scsparen;

d213 2
a214 1
	} else {		/* normal lexing */
d226 2
a227 1
	if (source->flags & SF_ALIAS) {	/* trailing ' ' in alias definition */
d274 2
a275 1
				*wp = EOS;	/* temporary */
d385 4
a388 3
						PUSH_STATE(SCSPAREN);
						statep->ls_scsparen.nparen = 1;
						statep->ls_scsparen.csstate = 0;
d390 2
d417 2
a418 1
						    c == '$' /* XXX what else? */) {
d449 2
a450 1
					/* If this is a trim operation,
d504 2
a505 1
				/* Need to know if we are inside double quotes
d606 5
a610 5
		case SCSPAREN:	/* $( ... ) */
			/* todo: deal with $(...) quoting properly
			 * kludge to partly fake quoting inside $(...): doesn't
			 * really work because nested $(...) or ${...} inside
			 * double quotes aren't dealt with.
a611 51
			switch (statep->ls_scsparen.csstate) {
			case 0:	/* normal */
				switch (c) {
				case '(':
					statep->ls_scsparen.nparen++;
					break;
				case ')':
					statep->ls_scsparen.nparen--;
					break;
				case '\\':
					statep->ls_scsparen.csstate = 1;
					break;
				case '"':
					statep->ls_scsparen.csstate = 2;
					break;
				case '\'':
					statep->ls_scsparen.csstate = 4;
					ignore_backslash_newline++;
					break;
				}
				break;

			case 1:	/* backslash in normal mode */
			case 3:	/* backslash in double quotes */
				--statep->ls_scsparen.csstate;
				break;

			case 2:	/* double quotes */
				if (c == '"')
					statep->ls_scsparen.csstate = 0;
				else if (c == '\\')
					statep->ls_scsparen.csstate = 3;
				break;

			case 4:	/* single quotes */
				if (c == '\'') {
					statep->ls_scsparen.csstate = 0;
					ignore_backslash_newline--;
				}
				break;
			}
			if (statep->ls_scsparen.nparen == 0) {
				POP_STATE();
				*wp++ = 0;	/* end of COMSUB */
			} else
				*wp++ = c;
			break;

		case SASPAREN:	/* $(( ... )) */
			/* XXX should nest using existing state machine
			 * (embed "...", $(...), etc.) */
d617 2
a618 3
					/*(*/
					if ((c2 = getsc()) == ')') {
						POP_STATE();
d623 1
a623 1
						char *s;
d625 2
a626 2
						ungetsc(c2);
						/* mismatched parenthesis -
d630 13
a642 10
						s = Xrestpos(ws, wp,
						    statep->ls_sasparen.start);
						memmove(s + 1, s, wp - s);
						*s++ = COMSUB;
						*s = '('; /*)*/
						wp++;
						statep->ls_scsparen.nparen = 1;
						statep->ls_scsparen.csstate = 0;
						state = statep->ls_state =
						    SCSPAREN;
d695 2
a696 1
				*wp++ = ' ';	/* simile for @@ */
d730 2
a731 1
		case SWORD:	/* ONEWORD */
d734 3
a736 3
		case SLETPAREN:	/* LETEXPR: (( ... )) */
			/*(*/
			if (c == ')') {
d747 2
a748 1
					/* mismatched parenthesis -
d750 1
a750 1
					 * parsing a $(...) expression
d762 4
a765 3
				/* parenthesis inside quotes and backslashes
				 * are lost, but AT&T ksh doesn't count them
				 * either
d771 2
a772 1
		case SLETARRAY:	/* LETARRAY: =( ... ) */
d785 2
a786 1
		case SHERESTRING:	/* <<< delimiter */
d824 4
a827 2
		case SHEREDELIM:	/* <<,<<- delimiter */
			/* XXX chuck this state (and the next) - use
d832 2
a833 1
			/* here delimiters need a special case since
d868 2
a869 1
		case SHEREDQUOTE:	/* " in <<,<<- delimiter */
d896 3
a898 2
		case SPATTERN:	/* in *(...|...) pattern (*+?@@!) */
			if ( /*(*/ c == ')') {
d905 2
a906 1
				*wp++ = ' ';	/* simile for @@ */
d979 2
a980 1
		Xfree(ws, wp);	/* free word */
d988 2
a989 1
		Xfree(ws, wp);	/* free word */
d1011 2
a1012 1
	*wp++ = EOS;		/* terminate word */
d1047 2
a1048 1
		*ident = '\0';	/* word is not unquoted */
a1053 1
		/* { */
d1055 2
a1056 1
		    (!(cf & ESACONLY) || p->val.i == ESAC || p->val.i == '}')) {
d1178 2
a1179 1
		/* Allow EOF here so commands with out trailing newlines
d1212 2
a1213 1
	source->str = null;	/* zap pending input */
d1249 2
a1250 1
		s->str = NULL;		/* return 0 for EOF by default */
d1290 6
a1295 4
				source = s = s->next;	/* pop source stack */
				/* Note that this alias ended with a space,
				 * enabling alias expansion on the following
				 * word.
d1299 2
a1300 1
				/* At this point, we need to keep the current
d1302 5
a1306 6
				 * aliases can be detected and we also need
				 * to return the next character. Do this
				 * by temporarily popping the alias to get
				 * the next character and then put it back
				 * in the source list with the SF_ALIASEND
				 * flag set.
d1308 2
a1309 1
				source = s->next;	/* pop source stack */
d1320 1
a1320 1
					/* avoid reading eof twice */
d1328 2
a1329 1
			if (s->start != s->ugbuf)	/* yuck */
d1384 2
a1385 1
		if (nread < 0)	/* read error */
d1408 2
a1409 1
			xp++;	/* move past NUL so doubling works... */
d1411 2
a1412 1
			xp--;	/* ...and move back again */
d1414 2
a1415 1
		/* flush any unwanted input so other programs/builtins
d1419 1
a1419 1
		 * todo: reduce size of shf buffer (~128?) if SSTDIN
d1424 2
a1425 1
	/* XXX: temporary kludge to restore source after a
d1483 4
a1486 2
	case PS1:	/* command */
		/* Substitute ! and !! here, before substitutions are done
d1510 2
a1511 1
				/* Don't print an error - assume it has already
d1524 2
a1525 1
	case PS2:	/* command continuation */
d1537 6
a1542 5
	/* Undocumented AT&T ksh feature:
	 * If the second char in the prompt string is \r then the first char
	 * is taken to be a non-printing delimiter and any chars between two
	 * instances of the delimiter are not considered to be part of the
	 * prompt length
d1593 3
a1595 2
/* Read the variable part of a ${...} expression (ie, up to but not including
 * the :[-+?=#%] or close-brace.
d1640 2
a1641 1
					c = getsc();	/* the ] */
d1657 2
a1658 1
	*wp++ = '\0';	/* end of variable part */
d1672 3
a1674 3
	char	*wp;
	char	c;
	int	depth = 1;	/* we are just past the initial [ */
d1700 1
a1700 1
	/* Don't unget eof... */
@


1.121
log
@• Address concerns of Chris Palmer from the Android security team
  – possible integer overflows in memory allocation, mostly
    ‣ multiplication: all are checked now
    ‣ addition: reviewed them, most were “proven” or guessed to be
      “almost” impossible to run over (e.g. when we have a string
      whose length is taken it is assumed that the length will be
      more than only a few bytes below SIZE_MAX, since code and
      stack have to fit); some are checked now (e.g. when one of
      the summands is an off_t); most of the unchecked ones are
      annotated now
    ⇒ cost (MirBSD/i386 static): +76 .text
    ⇒ cost (Debian sid/i386): +779 .text  -4 .data
  – on Linux targets, setuid() setresuid() setresgid() can fail
    with EAGAIN; check for that and, if so, warn once and retry
    infinitely (other targets to be added later once we know that
    they are “insane”)
    ⇒ cost (Debian sid/i386): +192 .text (includes .rodata)
• setmode.c: Do overflow checking for realloc() too; switch back
  from calloc() to a checked malloc() for simplification while there
• define -DIN_MKSH and let setmode.c look a tad nicer while here
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.120 2010/08/28 20:22:20 tg Exp $");
d488 3
d494 1
d841 2
a842 1
				}
d853 1
d885 2
a886 1
				}
d895 1
@


1.120
log
@shave off another 468 bytes: we’re 300 bytes smaller than BEFORE the
cat builtin was added now… (also removed utf-8 from source files, in
favour of just ASCII)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.119 2010/08/28 18:50:53 tg Exp $");
d1449 1
a1449 1
		XcheckN(s->xs, xp, fc_e_n + /* NUL */ 1);
d1457 2
a1458 2
		memmove(cp + fc_e_n, cp, linelen + /* NUL */ 1);
		xp += fc_e_n;
d1460 1
a1460 1
		memcpy(cp, fc_e_, fc_e_n);
d1752 1
a1752 1
	Lex_state *news = alloc(STATE_BSIZE * sizeof(Lex_state), ATEMP);
@


1.119
log
@improve string pooling: saves 316 bytes in .text
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.118 2010/07/25 11:35:41 tg Exp $");
d947 1
a947 1
		yyerror("%s: '%s' %s\n", T_synerr, ")", "missing");
d1210 2
a1211 1
				yyerror("here document '%s' unclosed\n", eof);
@


1.118
log
@a tad annoying, when external programmes such as GNU screen are running,
we don’t get SIGWINCH when the window size changes during the runtime of
that, so, the signal is only usable reliably during editing in the shell
and we re-check the window size before each interactive edit line again
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.117 2010/07/21 11:31:15 tg Exp $");
d947 1
a947 1
		yyerror("%s: ')' missing\n", T_synerr);
@


1.117
log
@Michal Hlavinka from Red Hat found another SIGSEGV
fix: when iterating over all Sources, know when to stop…
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.116 2010/07/17 22:09:36 tg Exp $");
d1388 2
d1403 1
a1403 3
		if (interactive) {
			if (got_winch)
				change_winsz();
d1405 1
a1405 1
		} else
@


1.116
log
@• merge printf from OpenBSD
• deactivate %a and %A since our libc doesn’t have it
• rewrite the mksh integration code to use shf instead of stdio, removing
  floating point support always in the process, as shf doesn’t support it
  ⇒ saves 11114 (6706 text, 168 data, 4240 bss) with dietlibc on Debian
• fix -Wall -Wextra -Wformat -Wstrict-aliasing=2 for gcc (Debian 4.4.4-7)
• fix these and -Wc++-compat for gcc version 4.6.0 20100711 (experimental)
  [trunk revision 162057] (Debian 20100711-1) except:
  – a few enum warnings that relate to eglibc’s {g,s}etrlimit() functions
    taking an enum instead of an int because they’re too stupid to adhere
    to POSIX interfaces they design by themselves
  – all “request for implicit conversion” involving a "void *" on one side
• tweak the manual page somewhat more
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.115 2010/07/04 18:29:40 tg Exp $");
d1113 1
a1113 1
				while (s->flags & SF_HASALIAS)
@


1.115
log
@fix another initialisation error caught by Valgrind
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.114 2010/07/04 17:45:14 tg Exp $");
d1751 1
a1751 1
	Lex_state *new = alloc(STATE_BSIZE * sizeof(Lex_state), ATEMP);
d1753 4
a1756 4
	new[0].ls_info.base = old_end;
	si->base = &new[0];
	si->end = &new[STATE_BSIZE];
	return (&new[1]);
@


1.114
log
@implement “live” SIGWINCH handling in the Emacs editing mode
for winstonw from IRC #!/bin/mksh
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.113 2010/04/08 13:21:06 tg Exp $");
d1251 1
a1253 6
	s->start = NULL;
	s->line = 0;
	s->errline = 0;
	s->file = NULL;
	s->flags = 0;
	s->next = NULL;
a1256 2
	else
		memset(&s->xs, 0, sizeof(s->xs));
@


1.113
log
@Fix two more POSIX conformance bugs and minor documentation/comment issues
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.112 2010/03/31 12:20:04 tg Exp $");
d1409 2
@


1.112
log
@move label, see <Pine.BSM.4.64L.1003311156380.24549@@herc.mirbsd.org> (my
first paragraph in that) for reason: to make it more clear from the code
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.111 2010/03/27 16:53:16 tg Exp $");
d728 2
a729 3
			/* Same as SBRACE, except (,|,) treated specially */
			/*{*/
			if (c == '}') {
@


1.111
log
@fix another expand-ugly SUSv4 bug
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.110 2010/02/25 20:18:16 tg Exp $");
a326 1
 store_qchar:
d358 1
@


1.110
log
@(hopefully) fix the substitution thing for good
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.109 2010/02/23 21:51:49 tg Exp $");
d327 1
d691 17
d711 3
a713 2
			/* FALLTHROUGH */
		case SQBRACE:
a715 2
			else if (c == '\\')
				goto getsc_qchar;
@


1.109
log
@begin fixing up ${foo+word}, see austin-group-l for discussion and DR
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.108 2010/02/18 17:31:23 tg Exp $");
d324 2
a325 2
				c = getsc();
				if (c) {
d332 1
d338 1
a338 1
 open_dquote:
d375 1
d494 1
d542 1
d691 3
d695 13
a707 30
			if (c == /*{*/ '}') {
				POP_STATE();
				*wp++ = CSUBST;
				*wp++ = /*{*/ '}';
			} else if (c == '\\') {
				if ((c = getsc())) {
					*wp++ = QCHAR;
					*wp++ = c;
				}
			} else if (c == '"') {
				if (state == SQBRACE)
					goto open_dquote;
 sbrace_quote:
				c2 = c;
				for (;;) {
					if (!(c = getsc()))
						goto Done;
					if (c == c2)
						break;
					*wp++ = QCHAR;
					*wp++ = c;
				}
			} else if (state == SBRACE && c == '\'') {
				goto sbrace_quote;
			} else if (c == '$' || c == '`') {
				goto Subst;
			} else {
				*wp++ = CHAR;
				*wp++ = c;
			}
@


1.108
log
@at least _parse_ the construct ${foo+(bar)} correctly
(whether the output is correct is still up for debate)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.107 2010/01/29 09:34:28 tg Exp $");
d35 13
a47 12
#define SBRACE		5	/* inside ${} */
#define SCSPAREN	6	/* inside $() */
#define SBQUOTE		7	/* inside `` */
#define SASPAREN	8	/* inside $(( )) */
#define SHEREDELIM	9	/* parsing <<,<<- delimiter */
#define SHEREDQUOTE	10	/* parsing " in <<,<<- delimiter */
#define SPATTERN	11	/* parsing *(...|...) pattern (*+?@@!) */
#define STBRACE		12	/* parsing ${...[#%]...} */
#define SLETARRAY	13	/* inside =( ), just copy */
#define SADELIM		14	/* like SBASE, looking for delimiter */
#define SHERESTRING	15	/* parsing <<< string */
#define SEQUOTE		16	/* inside $'' */
d337 1
d453 4
a456 1
						PUSH_STATE(SBRACE);
d687 2
a688 2
			/*{*/
			if (c == '}') {
d692 26
a717 2
			} else
				goto Sbase2;
@


1.107
log
@remove some more of this ugliness
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.106 2010/01/28 20:58:32 tg Exp $");
d688 1
a688 1
				goto Sbase1;
@


1.106
log
@• unbreak testsuite for MKSH_SMALL
• sync version and © year
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.105 2010/01/28 20:52:08 tg Exp $");
d209 2
a210 1
		*wp++ = OQUOTE;	 /* enclose arguments in (double) quotes */
d277 1
a277 1
				*wp = EOS; /* temporary */
d306 1
a306 1
			/* FALLTHRU */
d319 1
a319 1
			/* FALLTHRU */
d324 5
a328 2
				if (c) /* trailing \ is lost */
					*wp++ = QCHAR, *wp++ = c;
d355 2
a356 1
					*wp++ = QCHAR, *wp++ = c;
d361 6
a366 3
					if (c) { /* trailing \ is lost */
						*wp++ = CHAR, *wp++ = '\\';
						*wp++ = CHAR, *wp++ = c;
d395 2
a396 1
						*wp++ = CHAR, *wp++ = c;
d428 2
a429 1
						*wp++ = CHAR, *wp++ = c;
d481 2
a482 1
					*wp++ = CHAR, *wp++ = '$';
d532 1
a532 1
				/* FALLTHRU */
d534 2
a535 1
				*wp++ = CHAR, *wp++ = c;
d552 4
a555 3
					if ((unsigned int)c2 < 0x100)
						*wp++ = QCHAR, *wp++ = c2;
					else {
d564 4
a567 2
			} else if (!statep->ls_sequote.got_NUL)
				*wp++ = QCHAR, *wp++ = c;
d575 4
a578 2
			} else
				*wp++ = QCHAR, *wp++ = c;
d589 1
a589 1
		case SCSPAREN: /* $( ... ) */
d596 1
a596 1
			case 0: /* normal */
d617 2
a618 2
			case 1: /* backslash in normal mode */
			case 3: /* backslash in double quotes */
d622 1
a622 1
			case 2: /* double quotes */
d629 1
a629 1
			case 4: /* single quotes */
d638 1
a638 1
				*wp++ = 0; /* end of COMSUB */
d643 1
a643 1
		case SASPAREN: /* $(( ... )) */
d654 2
a655 1
						*wp++ = 0; /* end of EXPRSUB */
d723 1
a723 1
					/* FALLTHRU */
d725 2
a726 1
					if (c) { /* trailing \ is lost */
d782 2
a783 1
			*wp++ = CHAR, *wp++ = c;
d790 2
a791 1
				if (c) { /* trailing \ is lost */
d834 2
a835 1
				if (c) { /* trailing \ is lost */
d876 2
a877 1
						if (c) { /* trailing \ lost */
d1315 1
a1315 1
			if (s->start != s->ugbuf) /* yuck */
d1391 1
a1391 1
			xp++; /* move past null so doubling works... */
d1393 1
a1393 1
			xp--; /* ...and move back again */
d1435 2
a1436 1
	if (Xlength(s->xs, xp) == 0) { /* EOF */
d1462 1
a1462 1
	case PS1: /* command */
d1500 1
a1500 1
	case PS2: /* command continuation */
d1575 1
a1575 1
		PS_NUMBER, PS_VAR1, PS_END
d1589 1
a1589 1
			/* FALLTHRU */
d1598 1
a1598 1
				state = PS_END;
a1601 1
				state = PS_END;
d1613 1
a1613 1
					c = getsc(); /* the ] */
d1615 1
d1620 1
a1620 1
				state = PS_END;
d1623 1
a1623 9
			state = PS_END;
			break;
		case PS_END: /* keep gcc happy */
			break;
		}
		if (state == PS_END) {
			*wp++ = '\0';	/* end of variable part */
			ungetsc(c);
			break;
d1628 3
@


1.105
log
@DEC ucode cc politely reminds me this is not a good way of doing stuff, 10x
@
text
@d4 1
a4 1
 * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009
d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.104 2010/01/25 16:12:56 tg Exp $");
@


1.104
log
@when using persistent history (and not MKSH_SMALL), let the shells
concurrently accessing the same $HISTFILE be more synchronised with
each other: empty lines (just pressing Return) and duplicates (that
are split and written twice by the lines loaded from $HISTFILE in
the meantime); requested by Maximilian “mxey” Gaß in #!/bin/mksh
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.103 2009/12/05 20:17:59 tg Exp $");
d545 2
a546 2
						for (c = 0; ts[c]; ++c)
							*wp++ = QCHAR, \
d548 1
@


1.103
log
@attempt a better fix: break off widthadj upon encountering NUL,
add remaining columns as octets (should also speed optimise)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.101 2009/11/21 23:23:18 tg Exp $");
d1324 1
a1324 1
	int interactive = Flag(FTALKING) && s->type == SSTDIN;
d1416 1
a1416 1
	    (cur_prompt != PS1 || !ctype(*s->str, C_IFS | C_IFSWS)))
d1418 9
@


1.102
log
@valgrind (thanks ciruZ for trying) found uninitialised memory use
in utf_skipcols by x_goto
@
text
@d1329 1
a1329 1
	memset(xp, 0, LINE);
@


1.101
log
@since we have wcwidth anyway, expose it as ${%strvar} to the user, iff
utf8-mode is enabled (otherwise it'll be a synonym for ${#strvar} aka
the number of octets in it)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.100 2009/10/04 12:45:22 tg Exp $");
d1329 1
a1329 1
	*xp = '\0';
@


1.100
log
@fix long-standing parenthesēs problem: ((foo) || bar) is now parsed corr.
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.98 2009/10/02 18:08:34 tg Exp $");
d1551 1
a1551 1
			if (c == '#' || c == '!') {
@


1.99
log
@fix dollar quotes in here strings and here documents (regression)
@
text
@d42 1
a42 1
#define STBRACE		12	/* parsing ${..[#%]..} */
d480 1
a480 1
				 * "`..\"..`".
d571 1
a571 1
		case SCSPAREN: /* $( .. ) */
d573 2
a574 2
			 * kludge to partly fake quoting inside $(..): doesn't
			 * really work because nested $(..) or ${..} inside
d625 1
a625 2
		case SASPAREN: /* $(( .. )) */
			/* todo: deal with $((...); (...)) properly */
d627 1
a627 1
			 * (embed "..", $(...), etc.) */
d644 1
a644 1
						 * parsing a $(..) expression
d724 1
a724 2
				/*(*/
				else if ((c2 = getsc()) == ')') {
d728 3
a730 1
				} else
d732 13
d803 1
a803 1
			 * the existing states ($ and \`..` should be
d808 1
a808 1
			 * $ and `..` are not to be treated specially
a960 5
				/*
				 * this is the place where
				 * ((...); (...))
				 * and similar is broken
				 */
d1374 1
a1374 1
		 * etc..
@


1.98
log
@* rename "set -o posix" (FPOSIX) to "set -o sh" (FSH) because it's not
  just a "somewhat more POSIX" but also a "/bin/sh legacy kludge" mode
* consistently capitalise POSIX and SUSv3/SUSv4 (same as AT&T ksh) and
  Bourne shell
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.97 2009/09/24 17:15:31 tg Exp $");
d463 2
a464 1
				} else if (c == '\'') {
@


1.97
log
@change undef/def MKSH_NOVI into 0/1 MKSH_S_NOVI flag (with more to come:
MKSH_S_EDIT for small (Emacs) editing mode, MKSH_S_FEAT for all the dis-
abled language features), which can be set to 0 despite MKSH_SMALL being
defined to re-enable the Vi command line editing mode (which I wouldn't,
but fits into the general mastermind scheme)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.96 2009/09/23 18:04:56 tg Exp $");
d480 1
a480 1
				 * This is not done in posix mode (section
@


1.96
log
@* shrink MKSH_SMALL even further by removing functionality like
  some GNU bash extensions (suggested by cnuke@@) and bind macros
* make the random cache more efficient (and the code potentially
  smaller, although we have a new implementation of the oaat hash
  function, alongside the old one, now) and pushb only if needed
  (i.e. state has changed or user has set $RANDOM, but not onfork)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.95 2009/09/19 22:33:10 tg Exp $");
d1328 1
a1328 1
#ifndef MKSH_NOVI
@


1.95
log
@un-do a workaroung for something fixed by 1004AB55BFD3DADFED4
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.94 2009/09/19 21:54:45 tg Exp $");
d80 1
d86 1
d134 1
a134 1
#define getsc()		(*source->str != '\0' && *source->str != '\\' \
d138 1
a138 1
#define	getsc_()	((*source->str != '\0') && !(source->flags & SF_FIRST) \
d141 21
d212 1
d216 1
d739 1
d750 1
d872 1
d875 1
d969 6
a974 2
	if (state == SWORD || state == SLETPAREN ||
	    state == SLETARRAY)	/* ONEWORD? */
d1380 1
d1398 1
@


1.94
log
@$'…' functionality, documentation improvements, fixes for backslash
expansion in all modes, regression tests for both kinds of backslash
expansion; unbksl() revamp; make CTRL macro available globally
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.93 2009/08/28 22:39:09 tg Exp $");
d509 1
a509 1
				if (c2 == 0 || c2 == 0x100)
@


1.93
log
@the capability to get array indicēs (keys), Korn shell style
bash4 doesn’t have it at all, despite knowing associative arrays
zsh does it………… differently and weird

this is for indexed arrays, as mksh doesn’t have associative arrays
but it should help ☺
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.92 2009/08/28 20:30:56 tg Exp $");
d46 1
d98 6
d117 2
d166 1
a166 1
	int c, state;
a169 1
	int c2;
d438 6
d501 27
d734 8
d744 1
d754 1
d775 8
d785 1
d792 1
d1668 12
@


1.92
log
@much better solution: save tablep and hash value¹ in the struct tbl entry
① also saves time during texpand :D

XXX this doesn’t work well with the current indexed-array implementation
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.90 2009/08/28 18:53:58 tg Exp $");
d1446 1
a1446 1
			if (c == '#') {
@


1.91
log
@this is a rather stupid diff: give ktsearch/ktenter the capability to
return information needed to do a real ktremove instead of the pseudo
ktdelete operation which merely unsets the DEFINED flag to mark it as
eligible for texpand garbage collection (even worse, !DEFINED entries
are still counted)
@
text
@a911 1
		struct table_entry te;
d915 1
a915 2
		if ((cf & KEYWORD) &&
		    (p = ktsearch(&keywords, ident, h, NULL)) &&
d920 1
a920 1
		if ((cf & ALIAS) && (p = ktsearch(&aliases, ident, h, &te)) &&
d947 1
a947 1
				ktremove(&te);
@


1.90
log
@• use Jenkins’ one-at-a-time hash for mksh keytabs, as it has
  much better avalanche and no known funnels
• improve comments
• fix some types (uint32_t for hash, size_t for sizes)
• optimise ktsort()

no functional change, I think
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.89 2009/07/06 15:06:23 tg Exp $");
d912 1
d916 2
a917 1
		if ((cf & KEYWORD) && (p = ktsearch(&keywords, ident, h)) &&
d922 1
a922 1
		if ((cf & ALIAS) && (p = ktsearch(&aliases, ident, h)) &&
d949 1
a949 1
				ktdelete(p);
@


1.89
log
@be more robust against things like Debian #535970
reverts and rewrites the code from cid 10047C1EBA57E4F4AF0

XXX find out if this is done right
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.88 2009/06/11 12:42:19 tg Exp $");
d912 1
a912 1
		int h = hash(ident);
@


1.88
log
@capitalise AT&T®
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.87 2009/06/10 18:12:47 tg Exp $");
a161 1
	bool last_terminal_was_bracket;
d883 8
a890 2
	last_terminal_was_bracket = c == '(';
	ungetsc(c);		/* unget terminator */
d922 25
a946 2
			if (last_terminal_was_bracket)
				/* prefer functions over aliases */
@


1.87
log
@more KNF, mostly whitespace, this time more manual labour applying style(9)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.86 2009/06/08 20:06:47 tg Exp $");
d440 1
a440 1
				 * since sh/at&t-ksh translate the \" to " in
d668 1
a668 1
				 * are lost, but at&t ksh doesn't count them
d1298 1
a1298 1
		 * NOTE: this is not what at&t ksh does (it does it after
@


1.86
log
@some rather mechanical KNF, now that style(9) clarified on the status
of sizeof() as a function-like unary operator; use parenthesēs around
sizeof and return args consistently too
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.85 2009/05/27 19:52:36 tg Exp $");
d132 11
a142 11
#define PUSH_STATE(s)	do { \
			    if (++statep == state_info.end) \
				statep = push_state_(&state_info, statep); \
			    state = statep->ls_state = (s); \
			} while (0)

#define POP_STATE()	do { \
			    if (--statep == state_info.base) \
				statep = pop_state_(&state_info, statep); \
			    state = statep->ls_state; \
			} while (0)
d144 1
a144 1
/*
d262 3
a264 3
							  source->areap);
						s->start = s->str
							= s->u.freeme = tmp;
d658 1
a658 1
				    --statep->ls_sletparen.nparen;
d858 5
a862 5
				    /*
				     * this is the place where
				     * ((...); (...))
				     * and similar is broken
				     */
d1135 1
a1135 1
				 * to return the next character.  Do this
d1241 1
a1241 1
		 * can read it.  Not very optimal, but less error prone
d1321 1
a1321 1
				 * been printed.  Reason is we may have forked
d1407 3
a1409 4
			   PS_INITIAL, PS_SAW_HASH, PS_IDENT,
			   PS_NUMBER, PS_VAR1, PS_END
			 }
		state;
@


1.85
log
@implement an extension that an interactive mode input line, when
starting with an ‘!’ exclamation mark at the beginning of a com-
mand (PS1 not PS2), shall have the same effect as the predefined
“r” alias, to be compatible with csh and GNU bash’s “!string” to
«Execute last used command starting with string» – documentation
and feature request provided by wbx@@ (Waldemar Brodkorb)
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.84 2009/05/27 09:58:22 tg Exp $");
d794 1
a794 1
		struct ioword *iop = alloc(sizeof (struct ioword), ATEMP);
d845 1
a845 1
		return REDIR;
d882 1
a882 1
		return LWORD;
d913 1
a913 1
			return p->val.i;
d925 1
a925 1
						return LWORD;
d946 1
a946 1
	return LWORD;
d1060 1
a1060 1
	s = alloc(sizeof (Source), areap);
d1074 1
a1074 1
	return s;
d1089 1
a1089 1
			return 0;
d1168 1
a1168 1
			return '\0';
d1186 1
a1186 1
	return c;
d1470 1
a1470 1
	return wp;
d1501 1
a1501 1
	return depth == 0 ? 1 : 0;
d1512 1
a1512 1
		return source->str;
d1524 1
a1524 1
	return source->str;
d1535 1
a1535 1
		return getsc_();
d1539 1
a1539 1
		return getsc_();
d1553 1
a1553 1
		return c;
d1560 1
a1560 1
	Lex_state *new = alloc(STATE_BSIZE * sizeof (Lex_state), ATEMP);
d1565 1
a1565 1
	return &new[1];
d1578 1
a1578 1
	return si->base + STATE_BSIZE - 1;
@


1.84
log
@• Build.sh, strlcpy.c: gcc-current conversion &c. warnings cleanup
• histrap.c, lex.c, misc.c: get average stack frame size to <= 768 bytes
• check.t, sh.h: bump version
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.83 2009/05/16 16:59:37 tg Exp $");
d1192 1
a1192 1
	char *xp = Xstring(s->xs, xp);
d1257 19
a1275 1
	s->start = s->str = Xstring(s->xs, xp);
@


1.83
log
@• sync distrib/special/mksh/Makefile with bin/mksh/Build.sh and
  fix the regression test’s results while here, which have been
  broken since cid 10049D9BE5254CE65B8
• get rid of separate copyright file which was intended for De-
  bian; track down commits in all files of oksh-mirbsd and mksh
  to get correct copyright years per-file, as is BSD custom
@
text
@d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.82 2009/04/07 19:13:10 tg Exp $");
a129 1
#ifdef MKSH_SMALL
a130 3
#else
#define STATE_BSIZE	48
#endif
@


1.82
log
@some int->bool, KNF, ...
@
text
@d3 20
d25 1
a25 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.81 2009/04/07 19:06:43 tg Exp $");
@


1.81
log
@tabs vs spaces
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.80 2009/03/15 18:30:40 tg Exp $");
d81 1
a81 2
typedef struct State_info State_info;
struct State_info {
d84 1
a84 1
};
@


1.80
log
@fix off-by-one calculation mistake making PS1 ending in newline double it
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.79 2008/12/13 17:02:15 tg Exp $");
d87 6
a92 6
static void	readhere(struct ioword *);
static int	getsc__(void);
static void	getsc_line(Source *);
static int	getsc_bn(void);
static char	*get_brace_var(XString *, char *);
static int	arraysub(char **);
d94 1
a94 1
static void	gethere(bool);
@


1.79
log
@* back out almost all of the memory allocator related changes, as aalloc
  was hard to type and hard to fix, galloc is also hard to fix, and some
  things I learned will probably improve things more but make me use the
  original form as base (especially for space savings)
* let sizeofN die though, remove even more casts
* optimise, polish
* regen Makefiles
* sprinkle a few /* CONSTCOND */ while here
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.78 2008/12/04 18:11:05 tg Exp $");
d98 1
a98 1
static int dopprompt(const char *, int, int);
d1307 1
a1307 1
dopprompt(const char *cp, int ntruncate, int doprint)
d1351 1
a1351 2
	indelimit = (x_cols * lines + columns);
	return indelimit;
d1358 1
a1358 1
	dopprompt(cp, ntruncate, 1);
d1364 1
a1364 1
	return (dopprompt(cp, 0, 0));
@


1.78
log
@rename utf8-hack to utf8-mode (use set -U or set +U instead, anyway)
and announce less hackish things
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.77 2008/12/02 12:39:37 tg Exp $");
d779 1
a779 1
		struct ioword *iop = alloc(1, sizeof (struct ioword), ATEMP);
d1041 1
a1041 1
pushs(int type, PArea areap)
d1045 1
a1045 1
	s = alloc(1, sizeof (Source), areap);
d1271 1
a1271 1
			PArea saved_atemp;
d1528 1
a1528 1
	Lex_state *new = alloc(STATE_BSIZE, sizeof (Lex_state), ATEMP);
@


1.77
log
@Alias expansion has a recursion check which tries to break the cycle if
encountered. However, when reading end of input, the source type is set
to SEOF while popping, whereas the recursion check code only checks for
an SALIAS type.

Fix: add a new SF_HASALIAS flag; change u.tblp from being valid if type
is SALIAS to being valid if SF_HASALIAS is set; set SF_HASALIAS for the
created SALIAS sources; set SF_HASALIAS and u.tblp when creating SALIAS
whose next is SEOF on the SEOF source as well.

Reported by Michael Hlavinka as Redhat Bug #474115
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.76 2008/11/12 00:54:49 tg Exp $");
d1167 1
a1167 1
			Flag(FUTFHACK) = 1;
d1335 1
a1335 1
		else if (Flag(FUTFHACK) && ((unsigned char)*cp > 0x7F)) {
@


1.76
log
@switch to a (nmemb,size) API from a (nmemb*size) API

cost: text += (308, 256, 4, -100)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.75 2008/11/11 23:50:29 tg Exp $");
d906 1
a906 1
				Source *s;
d908 1
a908 1
				for (s = source; s->type == SALIAS; s = s->next)
d911 2
d917 1
d919 5
@


1.76.2.1
log
@before I’m going to accidentally type “cvs -Rq up -PAd” a̲n̲o̲t̲h̲e̲r̲ time,
better save the current not-so progress into the repo… it segfaults,
and the code to free any memory is not even written, so do not use.
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.76 2008/11/12 00:54:49 tg Exp $");
d241 1
a241 1
						gfree(tmp, ATEMP);
d246 4
a249 2
						s = pushs(SREREAD, source->gp_source);
						s->start = s->str = s->u.freeme = tmp;
d779 1
a779 1
		struct ioword *iop = galloc(1, sizeof (struct ioword), ATEMP);
d897 1
a897 1
			gfree(yylval.cp, ATEMP);
d912 1
a912 1
				s = pushs(SALIAS, source->gp_source);
d917 1
a917 1
				gfree(yylval.cp, ATEMP);
d1033 1
a1033 1
pushs(int type, PGroup areap)
d1037 1
a1037 1
	s = galloc(1, sizeof (Source), areap);
d1046 1
a1046 1
	s->gp_source = areap;
d1048 1
a1048 1
		XinitN(s->xs, 256, s->gp_source);
d1138 1
a1138 1
				gfree(s->u.freeme, ATEMP);
d1263 1
a1263 1
			PGroup saved_atemp;
d1407 1
a1407 1
					gfree(tmp, ATEMP);
d1478 1
a1478 1
		s = pushs(SREREAD, source->gp_source);
d1520 1
a1520 1
	Lex_state *new = galloc(STATE_BSIZE, sizeof (Lex_state), ATEMP);
d1536 1
a1536 1
	gfree(old_base, ATEMP);
@


1.75
log
@change use of “Area *” to “PArea” and “struct Area” to “TArea”

no change in size (mgcc and pcc, small and full)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.74 2008/10/28 14:32:41 tg Exp $");
d779 1
a779 2
		struct ioword *iop = (struct ioword *)alloc(sizeof (*iop),
		    ATEMP);
d1037 1
a1037 1
	s = (Source *)alloc(sizeof (Source), areap);
d1520 1
a1520 1
	Lex_state *new = alloc(sizeof (Lex_state) * STATE_BSIZE, ATEMP);
@


1.74
log
@• rewrite code to no longer use statements-as-expressions
• optimise a little
• Build.sh: remove HAVE_EXPSTMT test
• Build.sh, */Makefile: sort tests, regenerate
• mksh.hts: sync clog
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.73 2008/10/10 21:30:42 tg Exp $");
d1034 1
a1034 1
pushs(int type, Area *areap)
d1264 1
a1264 1
			Area *saved_atemp;
@


1.73
log
@fix prodded by cnuke@@ for AIX with IBM xlC 7.0:
fool the compiler into not doing static bounds checking when we do
one-past-the-array-boundary pointer assignments for cases where the
only accesses are like (*--pointer); bump version
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.72 2008/09/30 19:35:10 tg Exp $");
d1102 1
a1102 1
			    ksh_isspace(strnul(s->u.tblp->val.s)[-1])) {
d1288 1
a1288 1
				prompt = str_save(cp, saved_atemp);
@


1.72
log
@smaller even
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.71 2008/09/30 19:28:12 tg Exp $");
d154 1
a154 1
	state_info.end = &states[STATE_BSIZE];
@


1.71
log
@optimise
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.70 2008/09/30 19:25:51 tg Exp $");
d1243 1
a1243 1
	    (cur_prompt != PS1 || !ctype(*s->str, C_IFS | C_IFSWS))) {
a1244 1
	}
@


1.70
log
@ignore more dups
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.69 2008/09/30 17:58:49 tg Exp $");
d1242 3
a1244 5
	} else if (interactive) {
		char *p = Xstring(s->xs, xp);
		if (*p && (cur_prompt != PS1 || !ctype(*p, C_IFS | C_IFSWS))) {
			histsave(&s->line, s->str, true, true);
		}
@


1.69
log
@implement duplicate ignoring in the history, also requested by asarch,
and wanted by me for a while
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.68 2008/09/30 17:49:26 tg Exp $");
d1245 1
a1245 9
			if ((p = strchr(p, '\n')) != NULL)
				*p = '\0';
			/* ignore dups */
			if (strcmp(s->str, *histptr)) {
				s->line++;
				histsave(s->line, s->str, true);
			}
			if (p != NULL)
				*p = '\n';
@


1.68
log
@däs isch ei buul, koa int…
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.67 2008/09/20 14:17:30 tg Exp $");
d1245 9
a1253 2
			s->line++;
			histsave(s->line, s->str, true);
@


1.67
log
@Do not push lines beginning (at the $PS1) with an IFS White Space (space,
tab, newline) or an IFS Character ($IFS) into the history at all.
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.66 2008/07/12 16:56:39 tg Exp $");
d1246 1
a1246 1
			histsave(s->line, s->str, 1);
@


1.66
log
@• syn.c: replace expanded use of str_save() with the actual macro
• others: fix 6 (!) cases of non-constant or side-effect arguments
  to the str_save() or str_nsave() macros, and other abuse of them
• also fix some cosmetics and other un-nice code while here
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.65 2008/07/09 21:32:43 tg Exp $");
d1244 1
a1244 4
		if (cur_prompt == PS1)
			while (*p && ctype(*p, C_IFS) && ctype(*p, C_IFSWS))
				p++;
		if (*p) {
@


1.65
log
@• bump NUFILE and FDBASE, allowing for more than 10 fds used by scripts
• change the code to accept more than a single digit for an fd
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.64 2008/07/09 20:41:23 tg Exp $");
d1293 4
a1296 3
			} else
				prompt = str_save(substitute(ps1, 0),
				    saved_atemp);
@


1.64
log
@… one more regression test we pass…
• hd <<< bar
  → like bash, ksh93, zsh
• hd <<< #bar
  → like zsh (bash, ksh93: syntax error)
• hd <<<
  → like hd <<< '' (bash, ksh93, zsh: syntax error)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.63 2008/07/08 22:28:25 tg Exp $");
d778 1
a778 3
	if ((c == '<' || c == '>' || c == '&') && state == SBASE &&
	    ((c2 = Xlength(ws, wp)) == 0 ||
	    (c2 == 2 && dp[0] == CHAR && ksh_isdigit(dp[1])))) {
d782 1
a782 3
		if (c2 == 2)
			iop->unit = dp[1] - '0';
		else
d784 10
@


1.63
log
@sync with openbsd: only the RCS IDs, because the changed code in
question either does not exist in mksh (lex.c) or refers to the
only “feature” we do not pull, GNU bash-like $PS1 (main.c)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.62 2008/06/28 22:51:54 tg Exp $");
d195 4
@


1.62
log
@• add code to support GNU bash’s “&> file” I/O redirection extension,
  and make it fit into mksh’s model (also gives us a couple of things
  GNU bash doesn’t have
• add regression tests for all of these

Lukas “smultron” Upton from MidnightBSD spotted a script with /bin/sh
shebang invalidly using “&>” in some Apple backup toolkit, 10x

XXX why fds are limited to one digit?
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.43 2007/06/02 16:40:59 moritz Exp $	*/
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.61 2008/06/28 22:01:44 tg Exp $");
@


1.61
log
@more safe idiom
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.60 2008/05/17 18:46:59 tg Exp $");
d774 1
a774 1
	if ((c == '<' || c == '>') && state == SBASE &&
d783 11
a793 1
			iop->unit = c == '>' ? 1 : 0;
d798 1
a798 1
			iop->flag = c == c2 ?
d807 1
a807 1
			iop->flag = IODUP | (c == '<' ? IORDUP : 0);
d809 1
a809 1
			iop->flag = c == '>' ? IOWRITE : IOREAD;
d822 2
@


1.60
log
@• alloc() can’t fail, afree() can take NULL
  ‣ macro afreechk() is superfluous
• get rid of macro afreechv() by re-doing the “don’t leak that much” code
• some KNF (mostly, whitespace and 80c) while here
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.59 2008/05/04 01:51:30 tg Exp $");
d783 1
a783 1
			iop->unit = c == '>'; /* 0 for <, 1 for > */
@


1.59
log
@remove dead code and ifdefs, speed up configuring
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.58 2008/04/19 22:15:03 tg Exp $");
d777 2
a778 1
		struct ioword *iop = (struct ioword *) alloc(sizeof(*iop), ATEMP);
d1016 1
a1016 1
	s = (Source *)alloc(sizeof(Source), areap);
d1505 1
a1505 1
	Lex_state	*new = alloc(sizeof(Lex_state) * STATE_BSIZE, ATEMP);
@


1.58
log
@• more unsigned → unsigned int
• more int → bool
• more regression tests: check if the utf8-hack flag is really disabled
  at non-interactive startup, enabled at interactive startup, if the
  current locale is a UTF-8 one
• make the mksh-local multibyte handling functions globally accessible,
  change their names, syntax and semantics a little (XXX more work needed)
• optimise
• utf_wctomb: src → dst, as we’re writing to that char array (pasto?)
• edit.c:x_e_getmbc(): if the second byte of a 2- or 3-byte multibyte
  sequence is invalid utf-8, ungetc it (not possible for the 3rd byte yet)
• edit.c:x_zotc3(): easier (and faster) handling of UTF-8
• implement, document and test for base-1 numbers: they just get the
  ASCII (8-bit) or Unicode (UTF-8) value of the octet(s) after the ‘1#’,
  or do the same as print \x## or \u#### (depending on the utf8-hack flag),
  plus support the PUA assignment of EF80‥EFFF for the MirBSD encoding “hack”
  (print doesn’t, as it has \x## and \u#### to distinguish, but we cannot use
  base-0 numbers which I had planned to use for raw octets first, as they are
  used internally): http://thread.gmane.org/gmane.os.miros.general/7938
• as an application example, add a hexdumper to the regression tests ☺
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.57 2008/03/28 13:46:53 tg Exp $");
a1136 1
#if !defined(MKSH_ASSUME_UTF8) || !defined(MKSH_SMALL)
a1137 1
#endif
@


1.57
log
@• fix one more of the enum arithmetics complaints
• split Xinit into XinitN and Xinit macro, the former
  not initialising the “xp” argument of the latter,
  and use this to get rid of two variables that are
  only assigned but never referenced (gcc doesn’t see
  this, but MIPSpro and IIRC SUNWcc do)
• re-indent while here
• bump patchlevel
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.56 2008/03/05 16:49:22 tg Exp $");
d1313 1
a1313 1
		else if (Flag(FUTFHACK) && ((unsigned)*cp > 0x7F)) {
@


1.56
log
@more, this time on mirbsd… *sigh*
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.55 2008/03/05 16:40:57 tg Exp $");
d1015 1
a1015 1
	s = (Source *) alloc(sizeof(Source), areap);
d1025 3
a1027 4
	if (type == SFILE || type == SSTDIN) {
		char *dummy;
		Xinit(s->xs, dummy, 256, s->areap);
	} else
@


1.56.2.1
log
@MFC: mksh-R33d code, mksh-current dot.mkshrc
(this code is MirBSD-specific, as Build.sh is not included)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.57 2008/03/28 13:46:53 tg Exp $");
d1015 1
a1015 1
	s = (Source *)alloc(sizeof(Source), areap);
d1025 4
a1028 3
	if (type == SFILE || type == SSTDIN)
		XinitN(s->xs, 256, s->areap);
	else
@


1.56.2.2
log
@MFC: pull up mksh-R34β since it’ll be required by MirPorts soonish…
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.60 2008/05/17 18:46:59 tg Exp $");
d777 1
a777 2
		struct ioword *iop = (struct ioword *)alloc(sizeof (*iop),
		    ATEMP);
d1015 1
a1015 1
	s = (Source *)alloc(sizeof (Source), areap);
d1137 1
d1139 1
d1313 1
a1313 1
		else if (Flag(FUTFHACK) && ((unsigned char)*cp > 0x7F)) {
d1506 1
a1506 1
	Lex_state *new = alloc(sizeof (Lex_state) * STATE_BSIZE, ATEMP);
@


1.56.2.3
log
@MFC: mksh R35
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.44 2008/07/03 17:52:08 otto Exp $	*/
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.65 2008/07/09 21:32:43 tg Exp $");
a194 4
			while ((c = getsc()) == ' ' || c == '\t')
				;
			ungetsc(c);
			c = '<';
d774 3
a776 1
	if ((c == '<' || c == '>' || c == '&') && state == SBASE) {
d780 4
a783 22
		if (Xlength(ws, wp) == 0)
			iop->unit = c == '<' ? 0 : 1;
		else for (iop->unit = 0, c2 = 0; c2 < Xlength(ws, wp); c2 += 2) {
			if (dp[c2] != CHAR)
				goto no_iop;
			if (!ksh_isdigit(dp[c2 + 1]))
				goto no_iop;
			iop->unit = (iop->unit * 10) + dp[c2 + 1] - '0';
		}

		if (iop->unit >= FDBASE)
			goto no_iop;

		if (c == '&') {
			if ((c2 = getsc()) != '>') {
				ungetsc(c2);
				goto no_iop;
			}
			c = c2;
			iop->flag = IOBASH;
		} else
			iop->flag = 0;
d788 1
a788 1
			iop->flag |= c == c2 ?
d797 1
a797 1
			iop->flag |= IODUP | (c == '<' ? IORDUP : 0);
d799 1
a799 1
			iop->flag |= c == '>' ? IOWRITE : IOREAD;
a811 2
 no_iop:
		;
@


1.56.2.4
log
@MFC: mksh R35b
@
text
@d5 1
a5 1
__RCSID("$MirOS$");
d1293 3
a1295 4
			} else {
				char *cp = substitute(ps1, 0);
				prompt = str_save(cp, saved_atemp);
			}
@


1.56.2.5
log
@MFC: mksh R36b
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.79 2008/12/13 17:02:15 tg Exp $");
d154 1
a154 1
	state_info.end = &state_info.base[STATE_BSIZE];
d779 2
a780 1
		struct ioword *iop = alloc(sizeof (struct ioword), ATEMP);
d907 1
a907 1
				Source *s = source;
d909 1
a909 1
				while (s->flags & SF_HASALIAS)
a911 2
					else
						s = s->next;
a915 1
				s->flags |= SF_HASALIAS;
a916 5
				if (source->type == SEOF) {
					/* prevent infinite recursion at EOS */
					source->u.tblp = p;
					source->flags |= SF_HASALIAS;
				}
d1038 1
a1038 1
	s = alloc(sizeof (Source), areap);
d1102 1
a1102 1
			    (c = strnul(s->u.tblp->val.s)[-1], ksh_isspace(c))) {
d1160 1
a1160 1
			UTFMODE = 1;
d1242 10
a1251 3
	} else if (interactive && *s->str &&
	    (cur_prompt != PS1 || !ctype(*s->str, C_IFS | C_IFSWS)))
		histsave(&s->line, s->str, true, true);
d1295 1
a1295 1
				strdupx(prompt, cp, saved_atemp);
d1335 1
a1335 1
		else if (UTFMODE && ((unsigned char)*cp > 0x7F)) {
d1528 1
a1528 1
	Lex_state *new = alloc(STATE_BSIZE * sizeof (Lex_state), ATEMP);
@


1.55
log
@found by gcc on OSF/1 10x to Jupp Schugt (penpen)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.54 2008/03/01 21:10:25 tg Exp $");
d854 1
a854 1
		while (dp < ident+IDENT)
d859 1
@


1.54
log
@quite a big change, but now the variables expanded are not
scanned for slashes, plus the ADELIM code gets more use and
a bugfix ☺
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.53 2008/02/27 01:00:09 tg Exp $");
d857 1
a857 3
			else if ((c == OQUOTE) || (c == CQUOTE))
				;
			else
@


1.53
log
@I _think_ this implements ${foo/bar/baz} logic (bar is a glob pattern)
todo tomorrow:
• test case (compare with e.g. GNU bash)
• manpage
• version bump

sqchar is a bit ugly, but \/ must be preserved, as we don’t get wdencoded
strings later on in the process (eval.c CSUBST) and I didn’t want to have
an implementation like ${foo: 2: 3} this time
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.52 2008/02/26 21:08:33 tg Exp $");
a213 31
#ifdef notyet
				if (statep->ls_sadelim.style == SADELIM_MAKE &&
				    statep->ls_sadelim.num == 1) {
					if (c == /*{*/'}')
						yyerror("%s: expected '%c' %s\n",
						    T_synerr,
						    statep->ls_sadelim.delimiter,
					/*{*/	    "before '}'");
					else {
						*wp++ = ADELIM;
						*wp++ = c;	/* .delimiter */
						while ((c = getsc()) != /*{*/ '}') {
							if (!c) {
								yyerror("%s: expected '%c' %s\n",
								    T_synerr,
							/*{*/	    '}', "at end of input");
							} else if (strchr(sadelim_flags[statep->ls_sadelim.flags], c)) {
								*wp++ = CHAR;
								*wp++ = c;
							} else {
								char Ttmp[15] = "instead of ' '";

								Ttmp[12] = c;
								yyerror("%s: expected '%c' %s\n",
								    T_synerr,
							/*{*/	    '}', Ttmp);
							}
						}
					}
				}
#endif /* SADELIM_MAKE */
d218 2
d343 1
d359 1
d367 14
@


1.52
log
@clean up, optimise, comment code
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.51 2008/02/26 20:43:10 tg Exp $");
d398 1
a398 1
					if (c == '#' || c == '%') {
@


1.51
log
@implement “here strings”
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.50 2008/02/26 20:35:24 tg Exp $");
d686 1
d692 1
d697 1
d736 1
d925 1
d948 1
@


1.50
log
@move some constants private to the lexer into its .c file
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.49 2008/02/24 22:12:36 tg Exp $");
d25 1
d94 1
a94 1
static void	gethere(void);
d190 10
d202 3
a204 1
	    ((state == SBASE || state == SHEREDELIM) && ctype(c, C_LEX1)))) {
d679 22
d732 3
a734 1
				state = statep->ls_state = SHEREDELIM;
d779 1
a779 1
	if (state == SHEREDELIM)
d841 1
a841 1
			gethere();
d844 3
a846 1
		}
d860 13
a872 2
	for (sp = yylval.cp, dp = ident; dp < ident+IDENT && (c = *sp++) == CHAR; )
		*dp++ = *sp++;
d915 1
a915 1
gethere(void)
d920 4
a923 1
		readhere(*p);
d942 8
@


1.49
log
@  * lex.c: Don't expand aliases if there's an opening bracket just after
    the token. Fixes unreported problem with pdksh reporting syntax error
    on the init scripts that define function named ‘stop’ (clashing
    with an built-in alias.)

 -- Robert Luberda <robert@@debian.org>  Sun, 27 Feb 2005 18:36:55 +0100
@
text
@d5 20
a24 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.48 2007/10/25 15:27:54 tg Exp $");
@


1.48
log
@reduce RAM usage
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.47 2007/08/19 23:12:22 tg Exp $");
d127 1
d797 2
d821 18
a838 13
			Source *s;

			for (s = source; s->type == SALIAS; s = s->next)
				if (s->u.tblp == p)
					return LWORD;
			/* push alias expansion */
			s = pushs(SALIAS, source->areap);
			s->start = s->str = p->val.s;
			s->u.tblp = p;
			s->next = source;
			source = s;
			afree(yylval.cp, ATEMP);
			goto Again;
@


1.47
log
@employ string pooling techniques to save off a few more bytes
(probably more than the new “rename” builtin ever required…)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.46 2007/07/23 14:28:52 tg Exp $");
d94 1
a94 1
#define STATE_BSIZE	64
@


1.46
log
@… and fix that bug.

Ｇｕｖｆ ｐｂｚｚｖｇ ｈａｘａｂｊｖａｔｙｌ ｆｃｂａｆｂｅｒｑ
ｏｌ ＮｈｅＶＦＣ ＴｏＥ， ｆｖａｐｒ ｊｒ ｈｆｒ ｚｘｆｕ，
ｎａｑ ｚｌ ｂｇｕｒｅ ｇｎｆｘｆ ｎｅｒ ｊｎｖｇｖａｔ．．．
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.45 2007/07/22 14:01:49 tg Exp $");
d185 4
a188 3
						yyerror("syntax error: expected"
					/* { */	    " '%c' before '}'\n",
						    statep->ls_sadelim.delimiter);
d194 3
a196 2
								yyerror("syntax error: expected"
							/* { */	    " '}' before end of input\n");
d200 8
a207 3
							} else
								yyerror("syntax error: expected"
							/* { */	    " '}' instead of '%c'\n", c);
d719 1
a719 1
		yyerror("syntax error: ')' missing\n");
@


1.45
log
@• we had an unused variable leftover
• make warning-free for both gcc and xlC
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.44 2007/07/22 13:34:51 tg Exp $");
d47 1
d175 6
a180 1
			if (c == /*{*/ '}' || c == statep->ls_sadelim.delimiter) {
d336 1
d351 1
@


1.44
log
@• support IBM xlC on AIX
• fix all bugs it could find ☺
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.43 2007/07/07 22:29:36 tg Exp $");
d908 1
a908 1
	errorf("");
@


1.43
log
@introduce SADELIM_MAKE matching style – ${foo:S/bar/baz/flags} –
to complement SADELIM_BASH, as before – ${foo/bar/baz} –
but ifdef'd out for now, so probably no coding style. also new
is a flags array (not declared yet)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.42 2007/07/06 02:39:37 tg Exp $");
d908 1
a908 1
	errorf(null);
d970 1
a970 1
				s->start = s->str = newline;
d973 1
a973 1
				s->start = s->str = space;
@


1.42
log
@I'm an idiot and this looks better and is more KISS (I suppose)

too bad I don't just wrap it in braces
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.41 2007/07/06 02:24:18 tg Exp $");
d47 3
d52 1
d175 24
d327 1
d341 1
@


1.41
log
@give the lexer a bigger state stack if !MKSH_SMALL
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.40 2007/07/06 02:22:56 tg Exp $");
d294 1
a294 1
							*wp++ = QCHAR;
d306 5
a310 2
							*wp++ = QCHAR;
							*wp++ = c;
@


1.40
log
@fix the rest of it
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.39 2007/07/06 01:53:36 tg Exp $");
d86 1
d88 3
@


1.39
log
@make this pass varexpand-substr-1 and ‘c’ of varexpand-substr-2
by actually using the lexer and parser for that
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.38 2007/07/05 23:48:53 tg Exp $");
d290 1
a290 1
							*wp++ = CHAR;
d299 1
a299 1
						    c == '('/*)*/ ||
d302 2
a303 1
							ungetsc(c);
@


1.38
log
@better position for that (cosmetics)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.37 2007/06/23 00:05:04 tg Exp $");
d45 7
d165 9
d289 19
@


1.37
log
@optimise – we already did that one range check before
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.36 2007/06/22 23:34:40 tg Exp $");
a38 2
		Lex_state *base;	/* used to point to next state block */

d44 2
@


1.36
log
@implement bash-style array initialisation, as requested by many
still experimental
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.35 2007/06/16 15:02:56 tg Exp $");
d690 1
a690 2
				    (c == '(' /*)*/ ) ? MDPAREN :
				    YYERRCODE;
@


1.35
log
@we can do all that
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.34 2007/06/15 21:55:19 tg Exp $");
d40 6
d130 3
d547 11
d630 3
d706 2
a707 1
	if (state == SWORD || state == SLETPAREN)	/* ONEWORD? */
@


1.34
log
@• check.t: add some FPOSIX regression tests (1 still fails)
• all: remove vi editing mode #if defined(MKSH_SMALL) || defined(MKSH_NOVI)
  saves 12608 byts on i386
• check.t: add $0 quoting
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.42 2006/07/10 17:12:41 beck Exp $	*/
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.33 2007/06/04 19:25:45 tg Exp $");
@


1.33
log
@it's FALLTHROUGH, 10x moritz@@obsd
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.32 2007/05/13 19:14:04 tg Exp $");
d972 5
a976 1
	if (have_tty && (Flag(FVI) || Flag(FEMACS) || Flag(FGMACS))) {
@


1.32
log
@fix Coverity CID #8, #9

it's wrong to use strchr(s, 0) to look for the NUL byte, because in some
environments it apparently might return NULL

use new macro strnul = s+strlen(s) instead (not side-effect safe tho)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.31 2007/05/13 18:07:22 tg Exp $");
d223 1
a223 1
					/* FALLTROUGH */
@


1.31
log
@Workaround for Coverity CID#1: the Prevent parser didn't recognise there
were multiple possible values for c inside the code.

Rewrite code in question to use if instead of switch; optimise while here.
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.30 2007/05/10 19:22:11 tg Exp $");
d889 1
a889 1
			    ksh_isspace(strchr(s->u.tblp->val.s, 0)[-1])) {
@


1.30
log
@a certain size optimisation broke the utf8bom-3 regression test if
mksh was configured to have utf-8 mode “always on” (because it's
really only always on for interactive shells); setting it to really
always on would break the other half of this regression test, so
do the optimisation only if MKSH_SMALL
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.29 2007/04/26 11:58:53 tg Exp $");
d657 1
a657 7
		switch (c) {
		default:
			return c;

		case '|':
		case '&':
		case ';':
d662 6
d673 1
a673 3
			return c;

		case '\n':
a676 12
			return c;

		case '(':  /*)*/
			if ((c2 = getsc()) == '(') /*)*/
				/* XXX need to handle ((...); (...)) */
				c = MDPAREN;
			else
				ungetsc(c2);
			return c;
		  /*(*/
		case ')':
			return c;
d678 1
@


1.29
log
@optimisation: #ifdef MKSH_ASSUME_UTF8, don't bother to “Flag(FUTFHACK) = 1;” on UTF-8 BOM encounter, it's always on (unless manually set to off) – saves a few bytes, I guess
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.28 2007/04/15 12:28:38 tg Exp $");
d960 1
a960 1
#ifndef MKSH_ASSUME_UTF8	/* otherwise it's always on */
@


1.29.2.1
log
@MFC most of the bugfixes from post-R29d to the R29stable branch (which
is tagged off R29d), i.e. the following commitids:
• 1004638EE466466C614
• 100464368A065F40C08
• 10046436B6D392D622C
• 10046436DC35AC3B04F
• 100464370BA2BF5141D
• 10046474FB1292DF336
• 100464753C139AD7515
• 100464755C253EE3EA9
• 100464759DE15635029
• 10046475DAE4D3D3C05
• 100464760593612AAF2
• 100464763537E100BDF
• 1004647649434DA3FE1
but not
• 1004636486176FDA6FF
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.29 2007/04/26 11:58:53 tg Exp $");
d657 7
a663 1
		if ((c == '|') || (c == '&') || (c == ';') || (c == '('/*)*/)) {
a667 6
				    /*
				     * this is the place where
				     * ((...); (...))
				     * and similar is broken
				     */
				    (c == '(' /*)*/ ) ? MDPAREN :
d673 3
a675 1
		} else if (c == '\n') {
d679 12
a691 1
		return (c);
d902 1
a902 1
			    ksh_isspace(strnul(s->u.tblp->val.s)[-1])) {
d960 1
a960 1
#if !defined(MKSH_ASSUME_UTF8) || !defined(MKSH_SMALL)
@


1.29.2.2
log
@MFC:
• some harmless optimisations
• remove the -fno-tree-vrp and -fwhole-program --combine stuff
• fix a typo
• fix check for __attribute__
• remove the multi idstring check, always use ours
• fix signal stuff
• fix types
• pick up arc4random.c
• don't execute ELF, ECOFF, a.out, PE, gzip, etc. as shell script
• some regression test fixes
• fix large file support

bump version, this is gonna be R29g, but we've got to test that first
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.29.2.1 2007/05/13 19:29:37 tg Exp $");
d223 1
a223 1
					/* FALLTHROUGH */
@


1.28
log
@if we read an utf-8 BOM, enable the utf8-hack flag (we can test for that on
mirbsd even because the main.c enabling is only run for interactive shells)
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.27 2007/04/15 10:45:58 tg Exp $");
d960 1
d962 1
@


1.27
log
@ignore the UTF-8 Byte Order Mark at the beginning of the input (via a file
given to execute, standard input (interactive or not), via -c command line
argument, or after “eval”, but not for $(…) comsubs, at the beginning of a
subsequent line, or within a line, etc.); regression test for it

idea during my “week off” (despite the pain), bsiegert@@ thinks it's good –
and utf-8 capable tools ought to be able to do this anyway
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.26 2007/03/04 03:04:26 tg Exp $");
d960 1
@


1.26
log
@• remove strcasestr.c, use home-grown implementation¹, call it stricmp,
  and have it return an API-correct const char *
• enhance and stylify comments
• a little KNF and simplifications
• #ifdef DEBUG: replace strchr and strstr with ucstrchr and ucstrstr
  that take and return a non-const char *, and fix the violations
• new cstrchr, cstrstr (take and give const char *)
• new vstrchr, vstrstr (take const or not, give boolean value)
• new afreechk(x) = afreechv(x,x) = if (x1) afree(x2, ATEMP)
• new ksh_isdash(str) = (str != NULL) && !strcmp(str, "-")
• replace the only use of strrchr with inlined code to shrink
• minor man page fixes
• Minix 3 signames are autogenerated with gcc
• rename strlfun.c to strlcpy.c since we don't do strlcat(3) anyway,
  only strlcpy(3), and shorten it
• dot.mkshrc: move MKSH=… down to the export line
  to not disturb the PS1 visual impression ☺
• dot.mkshrc: Lstripcom(): optimise
• bump version

¹) side effect from creating API-correct cstrchr, cstrstr, etc.
   uses goto so it must be better ☻

tested on mirbsd-current via both Makefile and Build.sh
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.25 2007/01/12 10:18:21 tg Exp $");
d67 2
a68 1
			 && !backslash_skip ? *source->str++ : getsc_bn())
d70 2
a71 1
#define	getsc_()	((*source->str != '\0') ? *source->str++ : getsc__())
d861 1
d953 10
@


1.25
log
@* revert some of the const-warning cleanup which must be done
  with different means (reads, tricky magical kludgery)
  YES, THIS BREAKS -rHEAD, I KNOW.
* while here, fix spelling
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.24 2006/11/10 07:52:03 tg Exp $");
d45 2
a46 2
	Lex_state	*base;
	Lex_state	*end;
a48 1

a84 2


d86 1
a86 1
 * Lexical analyzer
@


1.24
log
@hand-sorted ctypes/chtypes upgrade; use table-driven where they make
sense and preprocessored otherwise; unify the logic
saves 144t 1i and lots of cpp(1) time, as well as improves readability
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.23 2006/11/10 07:18:57 tg Exp $");
d66 1
a66 1
/* optimized getsc_bn() */
d69 1
a69 1
/* optimized getsc__() */
@


1.23
log
@* use only macros for ctype stuff any more
  XXX one of these uses a gcc extension, ok for now tho
* don't include <ctype.h> any more at all
* don't try nl_langinfo in small mode, just check locale

saves 171 .text, 4 .data, 256 .bss, 1 import
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.22 2006/11/05 15:31:36 tg Exp $");
d276 1
a276 1
				} else if (ctype(c, C_ALPHA)) {
d283 1
a283 1
					} while (ctype(c, C_ALPHA|C_DIGIT));
d288 1
a288 1
				} else if (ctype(c, C_DIGIT|C_VAR1)) {
d618 1
a618 1
	    (c2 == 2 && dp[0] == CHAR && digit(dp[1])))) {
d1177 1
a1177 1
			if (letter(c))
d1179 1
a1179 1
			else if (digit(c))
d1187 1
a1187 1
			if (!letnum(c)) {
d1205 1
a1205 1
			if (!digit(c))
@


1.22
log
@first part of utf-8 ability in mksh, already works pretty well
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.21 2006/08/02 11:33:37 tg Exp $");
d902 1
a902 1
			    isspace((unsigned char)strchr(s->u.tblp->val.s, 0)[-1])) {
@


1.21
log
@fix the prompt redrawal routines for multi-line prompts, prompts
with embedded newline (\n), and multi-line prompts with embedded
newlines. single-line prompts should be not affected; prompts with
embedded carriage return (\r) should be fixed by this as well.
also fix prompt_redraw comment (can't remove the variable though,
since it's required if the shell inserts a newline after the prompt
herself).
tested on cygwin and interix
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.20 2006/08/02 10:42:30 tg Exp $");
d1119 9
a1127 1
		else
@


1.20
log
@rename 'count' into the more appropriate 'columns'
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.19 2006/08/02 10:41:03 tg Exp $");
d61 1
a61 1
static int dopprompt(const char *, int, const char **, int);
d1091 1
a1091 1
dopprompt(const char *cp, int ntruncate, const char **spp, int doprint)
d1093 1
a1093 2
	int columns = 0, lines = 0;
	const char *sp = cp;
a1094 1
	int indelimit = 0;
d1110 1
a1111 2
			++lines;
			sp = cp + 1;
d1121 3
a1123 6
		if (*cp != delimiter) {
			if (ntruncate && !indelimit)
				--ntruncate;
			else if (doprint)
				shf_putc(*cp, shl_out);
		}
a1124 2
	if (spp)
		*spp = sp;
d1127 2
a1128 1
	return (columns + (lines * x_cols));
d1135 1
a1135 1
	dopprompt(cp, ntruncate, NULL, 1);
d1139 1
a1139 1
promptlen(const char *cp, const char **spp)
d1141 1
a1141 1
	return (dopprompt(cp, 0, spp, 0));
@


1.19
log
@* Build.sh: fix accidental CR-LF catastrophe
  (yeah, that's what you get from developing with a
  16-bit MS-DOS(R) executable of your favourite text editor)
* lex.c, mksh.1: do not print the delimiting character for
  not-to-be-counted character sequences (i.e. ANSI escapes)
  in prompts any more, mostly because ASCII 01h is printable
  on both Interix and Cygwin and I'm lazy
  (this also fixes prompt width counting if a printable character
  such as 'x' is used as delimiting character)
* lex.c: through printing the prompt character by character,
  also print the delimited sequences if skipping, fixes some
  prompt redrawal not honouring colours stuff while not totally
  redrawing the entire prompt
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.18 2006/08/01 14:59:51 tg Exp $");
d1093 1
a1093 1
	int count = 0, lines = 0;
d1112 1
a1112 1
			count = 0;
d1116 1
a1116 1
			count = (count | 7) + 1;
d1118 2
a1119 2
			if (count > 0)
				count--;
d1123 1
a1123 1
			count++;
d1135 1
a1135 1
	return (count + (lines * x_cols));
@


1.18
log
@fix multiline prompts with "delimiter chars"
(only the last line of the prompt is redrawn, keep this in mind
when doing the ANSI colour game)

TODO:
* maybe go back up one line and redraw whole prompt?
* optionally edit command on multiple lines, bash-like,
  instead of scrolling horizontally
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.17 2006/08/01 14:35:44 tg Exp $");
a1108 7
		if (ntruncate) {
			if (!(indelimit || (*cp == delimiter)))
				--ntruncate;
		} else if (doprint) {
			shf_puts(cp, shl_out);
			doprint = 0;
		}
d1124 6
@


1.17
log
@* use modulo operation, Mr Glockner
* allow promptlen to return values > $COLUMNS
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.16 2006/08/01 14:10:25 tg Exp $");
d1109 4
a1112 3
		if (!indelimit && ntruncate)
			--ntruncate;
		else if (doprint) {
@


1.16
log
@move promptlen from edit.c into lex.c
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.15 2006/08/01 14:09:19 tg Exp $");
d61 2
d1090 2
a1091 3
/* See also related routine, promptlen() in edit.c */
void
pprompt(const char *cp, int ntruncate)
d1093 1
a1093 8
	shf_puts(cp + ntruncate, shl_out);
	shf_flush(shl_out);
}

int
promptlen(const char *cp, const char **spp)
{
	int count = 0;
d1109 6
d1119 1
d1133 16
a1148 1
	return count;
@


1.15
log
@(partial) sync with openbsd (and fix after them),
gives us a better wrapping prompt and a manpage wording cleanup
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.14 2006/08/01 13:43:27 tg Exp $");
d1096 39
@


1.14
log
@style(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.39 2006/04/10 14:38:59 jaredy Exp $	*/
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.13 2006/07/03 12:16:30 tg Exp $");
@


1.13
log
@fix the "char subscripts" issue, bump version
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.12 2006/05/10 18:54:11 tg Exp $");
d105 1
a105 2

  Again:
d180 1
a180 1
		  Sbase1:	/* includes *(...|...) pattern (*+?@@!) */
d193 1
a193 1
		  Sbase2:	/* doesn't include *(...|...) pattern (*+?@@!) */
d214 1
a214 1
		  Subst:
d228 1
a228 1
heredocquote:
d603 1
a603 1
Done:
@


1.12
log
@apply some fixes from OpenBSD and don't apply some others
but sync RCS IDs for easier future adaption:
* Simplify savefd() by removing the "noclose" flag and make noclose
  behavior the default. Almost all uses of savefd() are followed
  by an implicit or explicit close.
* fix typos
* might as well make ksh_getopt() match real getopt(), ie. get rid of that
  stupid EOF concept that was never true. adobriyan@@gmail
* use SEEK_* for lseek()
* fix lint comments, no functional changes
* remove excessive optimization; from adobriyan@@gmail
* only santa checks things twice; from adobriyan@@gmail
* Interpret zero-filled numbers as decimal; PR 4213; from Alexey Dobriyan
@
text
@d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.11 2006/01/29 20:04:52 tg Exp $");
d901 1
a901 1
			    isspace(strchr(s->u.tblp->val.s, 0)[-1])) {
@


1.11
log
@sync with OpenBSD: remove unused code and vars; name clash with libc
compiles under MirBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.38 2005/12/11 20:31:21 otto Exp $	*/
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.10 2005/11/22 18:40:43 tg Exp $");
@


1.10
log
@* only have one $MirOS RCS ID per file to shrink source size
  (this is an exception from normal use)
* bump to R26
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.37 2005/09/11 18:02:27 otto Exp $	*/
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.9 2005/11/22 18:36:19 tg Exp $");
d713 1
a713 1
		if ((cf & KEYWORD) && (p = tsearch(&keywords, ident, h)) &&
d718 1
a718 1
		if ((cf & ALIAS) && (p = tsearch(&aliases, ident, h)) &&
@


1.9
log
@Change interpretation of '\"' in here documents with substitution
according to SUSv3 and other modern shells (POSIX allows both).
Idea for the patch (add another lex state) from OpenBSD, but the
implementation differs slightly (and is better in quality).

Also add two testcases (/bin/sh passes both, old mksh only one),
and document the change in the manual page. Sync RCS IDs with OBSD.
@
text
@a0 1
/**	$MirOS: src/bin/mksh/lex.c,v 1.8 2005/10/25 19:53:28 tg Exp $ */
d5 1
a5 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.8 2005/10/25 19:53:28 tg Exp $");
@


1.8
log
@* move _all_ #include stuff into sh.h
* sort out #include stuff which isn't necessary on MirOS into compat.h
@
text
@d1 2
a2 2
/**	$MirOS: src/bin/mksh/lex.c,v 1.7 2005/07/04 12:47:13 tg Exp $ */
/*	$OpenBSD: lex.c,v 1.36 2005/03/30 17:16:37 deraadt Exp $	*/
d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.7 2005/07/04 12:47:13 tg Exp $");
d221 5
a225 1
				case '"': case '\\':
d230 1
@


1.7
log
@clean up code
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/lex.c,v 1.6 2005/07/04 12:34:23 tg Exp $ */
a4 2
#include <ctype.h>
#include <libgen.h>
d6 1
a6 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.6 2005/07/04 12:34:23 tg Exp $");
@


1.6
log
@get rid of $PGRP
get rid of special bourne-shell emulating mode
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/lex.c,v 1.5 2005/07/04 12:27:26 tg Exp $ */
d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.5 2005/07/04 12:27:26 tg Exp $");
d100 1
a100 1
	Lex_state states[STATE_BSIZE], *statep;
d322 2
a323 2
				Lex_state *s = statep;
				Lex_state *base = state_info.base;
d325 2
a326 2
					for (; s != base; s--) {
						if (s->ls_state == SDQUOTE) {
d331 1
a331 1
					if (s != base)
d333 1
a333 1
					if (!(s = s->ls_info.base))
d335 1
a335 1
					base = s-- - STATE_BSIZE;
@


1.5
log
@get rid of special "POSIX"ish mode
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/lex.c,v 1.4 2005/06/08 22:34:03 tg Exp $ */
d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.4 2005/06/08 22:34:03 tg Exp $");
d680 5
a684 7
			if (!Flag(FSH)) {
				if ((c2 = getsc()) == '(') /*)*/
					/* XXX need to handle ((...); (...)) */
					c = MDPAREN;
				else
					ungetsc(c2);
			}
@


1.4
log
@some lint cleanup
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/lex.c,v 1.3 2005/06/08 21:51:21 tg Exp $ */
d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.3 2005/06/08 21:51:21 tg Exp $");
d141 1
a141 5
		/* In POSIX mode, a trailing space only counts if we are
		 * parsing a simple command
		 */
		if (!Flag(FPOSIX) || (cf & CMDWORD))
			cf |= ALIAS;
d322 7
a328 9
				if (!Flag(FPOSIX)) {
					Lex_state *s = statep;
					Lex_state *base = state_info.base;
					while (1) {
						for (; s != base; s--) {
							if (s->ls_state == SDQUOTE) {
								statep->ls_sbquote.indquotes = 1;
								break;
							}
a329 5
						if (s != base)
							break;
						if (!(s = s->ls_info.base))
							break;
						base = s-- - STATE_BSIZE;
d331 5
@


1.3
log
@* major revamp of build system
* whitespace cleanup; junk comment removal
* syndicate debian/copyright file from my port (shrinks sh.h)
* bump to R23
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/lex.c,v 1.2 2005/05/25 23:31:07 tg Exp $ */
d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.2 2005/05/25 23:31:07 tg Exp $");
d187 1
a187 1
			/* fall through.. */
d200 1
a200 1
			/* fall through.. */
d507 1
a507 1
					/* fall through.. */
d1126 1
a1126 1
			/* fall through.. */
@


1.2
log
@* fix emacs [ tabcompletion bug
  XXX it's probably a bug in vi mode too, it just doesn't show
* bring manual page and reality into closer sync'd state
* sort ulimits
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/mksh/lex.c,v 1.1 2005/05/23 03:06:08 tg Exp $ */
d8 1
a8 1
__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.1 2005/05/23 03:06:08 tg Exp $");
d11 1
a11 2
 * needed for each particular state.
 */
@


1.1
log
@Add mirbsdksh R21, which was developed in a temporary external CVS repo-
sitory whose ChangeLog follows. mksh R21 is licenced under the MirOS li-
cence, shown in "sh.h", and a two-clause UCB-style licence by Marc Espie
as shown in "alloc.c".

This executable is a fair bit smaller and shorter than our /bin/ksh that
it is designed to eventually replace (as /bin/sh hardlink), with the old
/bin/ksh to completely vanish. It is still in beta testing though, and I
don't think it will compile on other operating systems.

mksh R21 is a completely new port, bringing together the OpenBSD-current
/bin/ksh, the MirOS-current /bin/ksh and the older mksh R20 (which still
was portable, ocvs-based).
@
text
@d1 1
a1 1
/**	$MirOS: mksh/lex.c,v 1.8 2005/05/23 02:20:36 tg Exp $ */
d8 1
a8 1
__RCSID("$MirOS: mksh/lex.c,v 1.8 2005/05/23 02:20:36 tg Exp $");
d345 7
@

